{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012059000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 5114382, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 21, "INMDSNAM": "CBT.V500.FILE455.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 5114382, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 5114382, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE455.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00Q\\x03'", "DS1TRBAL": "b'\\xbd\\xa8'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x03G\\x00\\r\\x03M\\x00\\x04\\x00R'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01\\x19/\\x01\\x01\\x19/\\x10Y\\x00\\x0c\\x00\\x0c\\x00\\x00\\xe2\\xc8\\xc9\\xd7\\xc4\\xc1\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-07-11T00:00:00", "modifydate": "2001-07-11T10:59:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "SHIPDAT"}, "text": "REGULAR CBT TAPE - VERSION 437    FILE:  455\n\n    ORIGINAL DSNAME:  WCBT.CBT437.FILE455\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    27920   PO\n\n   PDS117I 91 MEMBERS COUNTED; CUMULATIVE SIZE IS 48,070 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   07/11/01    10:59:47    GMT-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$$DOC": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x943?\\x00\\x943?\\t%\\x00=\\x00=\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-29T00:00:00", "modifydate": "1994-11-29T09:25:00", "lines": 61, "newlines": 61, "modlines": 0, "user": "SYSPAJA"}, "text": "1   18.11.94                                            DOC - Page 1/2.\n\n          ***************************************************\n          ***     P R E L I M I N A R Y     N O T E S     ***\n          ***************************************************\n\n Files author : MOINIL P.A.\n -------------- Computing Centre (TP361)\n                J.R.C. - Ispra establishment\n                21020 ISPRA (VA), Italy\n\n Products installation requirement :\n -----------------------------------\n     Data-set \"->.SOURCE.FILE0\" is a pre-requisite.\n     See to the member $$$PROCS which contains a job to store the\n     procedures used for products installation.\n\n Data-set members structure :\n ----------------------------\n     The members names ending by a dollar sign ($) are the JCL to\n     install (assembly + link-edit) the modules, and the members\n     names ending by a paragraph sign (@) are the corresponding\n     modules documentation.\n\n                   *********************************\n                   ***     INFORMATION NOTES     ***\n                   *********************************\n\n     Assuming the LISTNO program in \"->.SOURCE.FILE0\" installed, you may\n SUBMIT the job below to obtain a copy of this document :\n         //...      JOB ...\n         //DOC     EXEC PGM=LISTNO,PARM='M=DOC'\n         //SYSPDS    DD DSN=->.SOURCE.FILE1,DISP=SHR\n         //SYSPRINT  DD SYSOUT=A\n     A complete information notes list (about 3000 lines) may be also\n obtained by this job if you specify M=INFO as parameter.\n1   18.11.94                                            DOC - Page 2/2.\n\n  *******************************************************************\n  ***     D A T A - S E T ->.SOURCE.FILE1     C O N T E N T S     ***\n  *******************************************************************\n\n AGENDA     AGENDA TSO command.\n ARITH      HEX/DECIMAL arithmetic TSO command.\n AUTOCI     Automatic Operators Commands issuer.\n BRODSCAN   Analyze Broadcast TSO data-set.\n CMPRSEQ    Sequential data-sets comparison program.\n CONAN      Operator Console Analysis Facility program.\n DAHANDBK   DATA AREA Handbook generator program.\n DHC        Hex/Decimal Calculator (TSO).\n IEBANTP    Analyze/Copy Tape/3480 Utility.\n IMSLDS     IMS log data-set(s) program/command.\n IOPACK     Input-Output Package routines.\n RECOVER    Recover data-sets program (service aids).\n SEE        See current ISPF panel.\n SETCLOCK   TOD clock synchronizer.\n SHOWMVS    Display MVS system you're running on.\n STATDS     A disk data-set statistics program.\n STRING     Assembler macro (used by SHOWMVS).\n VCOREZAP   Virtual core zap program.\n VSM        Virtual Storage Monitor.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$$PROCS": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x942\\x7f\\x00\\x942\\x7f\\x14P\\x00R\\x00R\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-23T00:00:00", "modifydate": "1994-11-23T14:50:00", "lines": 82, "newlines": 82, "modlines": 0, "user": "SYSPAJA"}, "text": "//ADDPROCS JOB (........),'INSTALL  PROCEDURES',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=1M,TIME=1\n/*JOBPARM L=2\n//*----------- ADD PRODUCTS INSTALLATION PROCEDURES -------------------\n//*            ADJUSTMENTS MUST BE DONE BEFORE YOU RUN THIS JOB (SCAN\n//*            ALL \"->\" OCCURENCES AND SET RIGHT DATA-SETS NAMES).\n//* NOTES  1 - I NORMALLY USE THE ASSEMBLER H (DON'T USE ASSEMBLER F,\n//*            THERE IS A GOOD PROBABILITY TO HAVE ERRORS).\n//*        2 - ALL PROCEDURES ASSUME THE FOLLOWING UNIT NAMES :\n//*                     DU=SYSDA : DISK UNIT\n//*                     VU=VIO   : VIRTUAL UNIT\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//*      ASSEMBLER H PROCEDURES.                                      *\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//PROCH   EXEC PGM=IEBUPDTE,PARM=NEW\n//SYSUT2    DD DSN=->.TARGET.PROCLIB,DISP=SHR\n//SYSPRINT  DD SYSOUT=*\n//SYSIN     DD DATA,DLM=ZZ\n./     ADD     NAME=PAJ1AS1        <-------------- ASSEMBLY / 1 MACLIB\n./     NUMBER  NEW1=100,INCR=100\n//PAJ1AS1 PROC OPT=,DU=SYSDA,VU=VIO,MBR=,\n//             DSM='->.SOURCE.FILE0',DM=SHR\n//             DSS='->.SOURCE.FILE1',DS=SHR\n//AS      EXEC PGM=IEV90,\n//             PARM='XREF(SHORT),NODECK,OBJECT&OPT'\n//SYSLIB    DD DSN=&DSM,DISP=&DM\n//          DD DSN=SYS1.MACLIB,DISP=SHR\n//SYSUT1    DD UNIT=&VU,DSN=&&SYSUT1,SPACE=(CYL,(10,5))\n//SYSLIN    DD UNIT=&DU,SPACE=(CYL,(1,1)),DSN=&LOADSET,\n//             DCB=(BLKSIZE=800),DISP=(MOD,PASS,DELETE)\n//SYSPRINT  DD SYSOUT=*\n//SYSIN     DD DSN=&DSS(&MBR),DISP=&DS\n./     ADD     NAME=PAJ1AS2        <------------- ASSEMBLY / 2 MACLIBS\n./     NUMBER  NEW1=100,INCR=100\n//PAJ1AS2 PROC OPT=,DU=SYSDA,VU=VIO,MBR=,\n//             DSM='->.SOURCE.FILE0',DM=SHR\n//             DSS='->.SOURCE.FILE1',DS=SHR\n//AS      EXEC PGM=IEV90,\n//             PARM='XREF(SHORT),NODECK,OBJECT&OPT'\n//SYSLIB    DD DSN=&DSM,DISP=&DM\n//          DD DSN=&DSS,DISP=&DS\n//          DD DSN=SYS1.MACLIB,DISP=SHR\n//SYSUT1    DD UNIT=&VU,DSN=&&SYSUT1,SPACE=(CYL,(10,5))\n//SYSLIN    DD UNIT=&DU,SPACE=(CYL,(1,1)),DSN=&LOADSET,\n//             DCB=(BLKSIZE=800),DISP=(MOD,PASS,DELETE)\n//SYSPRINT  DD SYSOUT=*\n//SYSIN     DD DSN=&DSS(&MBR),DISP=&DS\n./     ADD     NAME=PAJ1AS3        <------------- ASSEMBLY / 3 MACLIBS\n./     NUMBER  NEW1=100,INCR=100\n//PAJ1AS3 PROC OPT=,DU=SYSDA,VU=VIO,MBR=,\n//             DSM='->.SOURCE.FILE0',DM=SHR\n//             DSS='->.SOURCE.FILE1',DS=SHR\n//AS      EXEC PGM=IEV90,\n//             PARM='XREF(SHORT),NODECK,OBJECT&OPT'\n//SYSLIB    DD DSN=&DSM,DISP=&DM\n//          DD DSN=&DSS,DISP=&DS\n//          DD DSN=SYS1.MACLIB,DISP=SHR\n//          DD DSN=SYS1.MODGEN,DISP=SHR\n//SYSUT1    DD UNIT=&VU,DSN=&&SYSUT1,SPACE=(CYL,(10,5))\n//SYSLIN    DD UNIT=&DU,SPACE=(CYL,(1,1)),DSN=&LOADSET,\n//             DCB=(BLKSIZE=800),DISP=(MOD,PASS,DELETE)\n//SYSPRINT  DD SYSOUT=*\n//SYSIN     DD DSN=&DSS(&MBR),DISP=&DS\n./     ADD     NAME=PAJ1AS4        <------------- ASSEMBLY / 4 MACLIBS\n./     NUMBER  NEW1=100,INCR=100\n//PAJ1AS4 PROC OPT=,DU=SYSDA,VU=VIO,MBR=,\n//             DSM='->.SOURCE.FILE0',DM=SHR\n//             DSS='->.SOURCE.FILE1',DS=SHR\n//AS      EXEC PGM=IEV90,\n//             PARM='XREF(SHORT),NODECK,OBJECT&OPT'\n//SYSLIB    DD DSN=&DSM,DISP=&DM\n//          DD DSN=&DSS,DISP=&DS\n//          DD DSN=SYS1.HASPSRC,DISP=SHR\n//          DD DSN=SYS1.MACLIB,DISP=SHR\n//          DD DSN=SYS1.MODGEN,DISP=SHR\n//SYSUT1    DD UNIT=&VU,DSN=&&SYSUT1,SPACE=(CYL,(10,5))\n//SYSLIN    DD UNIT=&DU,SPACE=(CYL,(1,1)),DSN=&LOADSET,\n//             DCB=(BLKSIZE=800),DISP=(MOD,PASS,DELETE)\n//SYSPRINT  DD SYSOUT=*\n//SYSIN     DD DSN=&DSS(&MBR),DISP=&DS\n./     ENDUP\nZZ\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "#DOC#": {"ttr": 523, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x11\\x7f\\x00\\x90\\x11\\x7f\\x13W\\x00&\\x00&\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-04-27T00:00:00", "modifydate": "1990-04-27T13:57:00", "lines": 38, "newlines": 38, "modlines": 0, "user": "SYSPAJA"}, "text": "1   27/04/90\n\n\n\n\n\n\n\n\n\n\n\n\n\n                DDDDDDD          OOOOOOO         CCCCCCCC\n                DDDDDDDD        OOOOOOOOO       CCCCCCCCC\n                DD     DD       OO     OO       CC\n                DD     DD       OO     OO       CC\n                DD     DD       OO     OO       CC\n                DD     DD       OO     OO       CC\n                DD     DD       OO     OO       CC\n                DD     DD       OO     OO       CC\n                DDDDDDDD        OOOOOOOOO       CCCCCCCCC\n                DDDDDDD          OOOOOOO         CCCCCCCC\n\n\n\n\n\n\n\n\n\n\n\n\n\n=/MB     $$$DOC\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "#INFO#": {"ttr": 525, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x943?\\x00\\x943?\\t%\\x00/\\x00/\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-29T00:00:00", "modifydate": "1994-11-29T09:25:00", "lines": 47, "newlines": 47, "modlines": 0, "user": "SYSPAJA"}, "text": "1   27/04/90\n\n\n\n\n\n\n\n\n\n\n\n\n\n          IIII       NN     NN       FFFFFFFFF        OOOOOOO\n           II        NNN    NN       FFFFFFFFF       OOOOOOOOO\n           II        NNNN   NN       FF              OO     OO\n           II        NN NN  NN       FF              OO     OO\n           II        NN  NN NN       FFFFFF          OO     OO\n           II        NN   NNNN       FFFFFF          OO     OO\n           II        NN    NNN       FF              OO     OO\n           II        NN     NN       FF              OO     OO\n           II        NN     NN       FF              OOOOOOOOO\n          IIII       NN     NN       FF               OOOOOOO\n\n\n\n\n1   17/11/94\n                                                      INDEX     1/1.\n\n=/MB     ARITH@    HEX/DECIMAL arithmetic TSO command.\n=/MB     AUTOCI@   Automatic operators commands issuer.\n=/MB     BRODSCA@  Analyze Broadcast TSO data-set.\n=/MB     CMPRSEQ@  Sequential data-set comparison program.\n=/MB     CONAN@    Operator Console Analysis Facility.\n=/MB     DAHANDB@  DATA AREA Handbook generator program.\n=/MB     DHC@      Hex/decimal calculator.\n=/MB     IEBANTP@  Analyze/Copy Tape/3480 Utility.\n=/MB     IMSLDS@   IMS log data-set(s) program/command.\n=/MB     IOPACK@   I/O package routines.\n=/MB     RECOVER@  Recover data-sets program (service aids).\n=/MB     SETCLOC@  TOD clock synchronizer.\n=/MB     SHOWMVS@  Display MVS system you're running on.\n=/MB     STATDS@   Data-set statistics.\n=/MB     VCOREZA@  Virtual core zap program.\n=/MB     VSM@      Virtual storage monitor.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "AGENDA": {"ttr": 527, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x00\\x9f\\x00\\x90\\x00\\x9f\\x147\\x03\\x15\\x03\\x15\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-01-09T00:00:00", "modifydate": "1990-01-09T14:37:00", "lines": 789, "newlines": 789, "modlines": 0, "user": "SYSPAJA"}, "text": "AGND     TITLE '--  A G E N D A  --'\nAGENDA   START 0\n         SPACE 1\n*--------------------------------------------------------------------*\n* PURPOSE : AN ONLINE AGENDA AT YOUR DISPOSAL.                       *\n*        THIS CP COMPARE TODAY DATE AGAINST ALL DATES STORED         *\n*        IN THE DATA-SET 'USER-ID.AGENDA.DATA' (OLD VERSION NAMED    *\n*        'USER-ID.AGENDA' IS ALWAYS HANDLED TOO).                    *\n*        WHEN A DATE MATCH IS ENCOUNTERED, THE CORRESPONDING         *\n*        TEXT MESSAGE IS OUTPUTED TO THE TERMINAL.                   *\n*                                           M.SACRE  23 SEPTEMBRE 86 *\n*                                         P.A.MOINIL  14 DECEMBRE 89 *\n*                                                                    *\n* DATA-SET RECORD FORMAT :                                           *\n*         DD/MM/YY..............MESSAGE....................          *\n*         <---  80 BYTES LONG  --- --- --- --- --- --- --->          *\n*         IF A DATE FIELD STARTS BY AN ASTERISK (*), THEN THE        *\n*         MESSAGE IS DISPLAYED EVERY DAY.                            *\n*--------------------------------------------------------------------*\n         SPACE 1\n        $DEFREG\n         SPACE 1\nOFF      EQU   X'0F'               NOP OPERATION SWITCH SETTING\nON       EQU   X'F0'               BRANCH OPERATION SWITCH SETTING\nNTMX     EQU   1000                MAX. NO. OF MESSAGES TABLE ELEMENT\nWSZ      EQU   (NTMX*80)           MESSAGES TABLE TOTAL LENGTH\n         EJECT\n*--------------------------------------------------------------------*\n*                            H  E  L  P                              *\n*--------------------------------------------------------------------*\n* FUNCTION :                                                         *\n*   THE AGENDA COMMAND DISPLAYS ALL TODAY (BY DEFAULT) PLANNED       *\n*        ACTIVITIES OR ANY OTHERS AS REQUIRED BY A SPECIFIED DATE.   *\n*   TO USE THIS FACILITY, IT IS MANDATORY TO :                       *\n*        (1) PRE-ALLOCATE A SEQUENTIAL DATA-SET WITH THE FOLLOWING   *\n*            CHARACTERISTICS                                         *\n*            DSNAME  - 'USER-ID.AGENDA.DATA' USER-ID = YOUR USERID   *\n*            FORMAT  -  FB               FIXED BLOCKED               *\n*            DSORG   -  PS               PHYSICAL SEQUENTIAL         *\n*            LRECL   -  80               RECORD LENGTH               *\n*            BLKSIZE -  9040             BLOCK LENGTH                *\n*        (2) THEN, INITIALIZE THIS AGENDA DATA-SET WITH YOUR PLANNED *\n*            ACTIVITIES (USING AN EDIT OF YOUR CHOICE).              *\n*            THE RECORDS MUST BE FORMATED AS BELOW                   *\n*            DD/MM/YY..............MESSAGE....................       *\n*            <---  80 BYTES LONG  --- --- --- --- --- --- --->       *\n*            WHERE                                                   *\n*            COL 1-2  = DD (2 DIGITS) IS THE DAY                     *\n*            COL 3    = / (A SLASH)                                  *\n*            COL 4-5  = MM (2 DIGITS) IS THE MONTH                   *\n*            COL 6    = / (A SLASH)                                  *\n*            COL 7-8  = YY (2 DIGITS) IS THE YEAR                    *\n*            COL 9-80 = MESSAGE (CHARACTERS - FREE FORMAT)           *\n*        NOTE : AN * IN COL 1 DEFINES A MESSAGE (COL 9-80) TO BE     *\n*               ALWAYS DISPLAYED.                                    *\n* SYNTAX :                                                           *\n*        AGENDA    = TODAY MESSAGE(S) BY DEFAULT                     *\n*     OR AGENDA DD/MM/YY                                             *\n*                  = SPECIFIED DATE DD/MM/YY MESSAGE(S)              *\n*     OR AGENDA DD/MM/YY DD/MM/YY                                    *\n*                  = SPECIFIED RANGE OF DATES MESSAGE(S)             *\n*     OR ANY PREVIOUS AGENDA COMMAND FORMAT FOLLOWED BY A LAST       *\n*                  OPERAND USER-ID WHICH ALLOWS THE ACCESS TO        *\n*                  ANOTHER AGENDA DATA-SET IF DESIRED.               *\n*--------------------------------------------------------------------*\n         SPACE 1\n         PRINT NOGEN\n         EJECT\n        $XENT  BASE=(R10,R11)\n         ST    R1,CPPLADDR             ADDRESS OF CPPL\n        GETMAIN R,LV=WSZ\n         ST    R1,ATBMSG\n        EXTRACT ,'S',,MF=(E,EXTRL)\n         L     R1,APSCB\n         LTR   R1,R1\n         BZ    NOTTSO\n         USING PSCB,R1                 SET PSCB ADDRESSABILITY\n         L     R2,CPPLADDR             REG ONE AT ENTRY\n         TM    0(R2),X'80'             IF CALLED, NOT CP\n         BO    NOCALL\n         USING CPPL,R2                 SET CPPL ADDRESSABILITY\n         CLC   PSCBUPT,CPPLUPT         CPPL+4 = UPT ADDRESS?\n         BNE   *+L'*+10                NO\n         DROP  R1\n         CLC   APSCB(L'APSCB),CPPLPSCB CPPL+8 = PSCB ADDRESS?\n         BE    USOK                    YES, TSO COMMAND\n         LR    R1,R2\n         USING IKJEBECA,R1\n         L     R2,CAPTTMP              CPPL ADDRESS\n         DROP  R1\n         CLC   APSCB(L'APSCB),CPPLPSCB CPPL+8 = PSCB ADDRESS?\n         BNE   NOCALL                  NO, NOT TSO SUB-COMMAND\n         ST    R2,CPPLADDR             SET CPPL ADDRESS\nUSOK     L     R1,CPPLPSCB             ADRESSE DU PSCB\n         MVC   USID,0(R1)              SAVE USERID (FROM PSCB)\n         CLC   USID(3),=CL8'OPER '     IS USERID OPE...?\n         BNE   *+L'*+6                 IF NOT, JUMP NEXT INSTRUCTION\n         MVC   USID,=CL8'OPER '        IF YES, ALLOCATE OPER.AGENDA\n         L     R3,CPPLCBUF             ADDR. OF COMMAND BUFFER\n         DROP  R2\n         SPACE 1\n*------- LOOK IF OPERAND(S) SUPPLIED.\n*        COMMAND BUFFER FORMAT :\n*        |     |     |        |                            |\n*        | LT  | DSP | NAME   |  OPERANDS                  |\n*        |..|..|..|..|........|...................    .....|\n*\n*        LT    TOTAL COMMAND LENGTH (2 BYTES)\n*        DSP   OFFSET TO FIRST OPERAND (2 BYTES)\n*        NAME  COMMAND NAME\n*        OPERANDS ...\n         SPACE 1\nINITRQ   MVC   ALTUI(L'ALTUI),=CL8' '  INITIALIZE USERID\n         MVI   FLAG3D,0\n         BAS   R9,GETDTES              GET DATE(S) IF ANY\n         B     NOLAST                  +0\n         CLR   R4,R3                   +4\n         BNL   NOLAST\n         CLI   0(R4),C' '              LOOK FOR LAST OPERAND\n         BNE   *+L'*+8\n         BXLE  R4,R2,*-8\n         B     NOLAST\n         LA    R1,ALTUI                MOVE LAST OPERAND\n         LA    R0,L'ALTUI\nLPMVP3   MVC   0(1,R1),0(R4)\n         BXLE  R4,R2,*+L'*+4\n         B     CHKPM3\n         CLI   0(R4),C' '\n         BE    CHKPM3\n         LA    R1,1(R1)\n         BCT   R0,LPMVP3\n         B     ERRPM3                  INVALID LAST OPERAND\nCHKPM3   TR    ALTUI,MAJMIN            TRANSFORM IN UPPER CASE\n         CLI   ALTUI,C'A'\n         BL    ERRPM3                  INVALID LAST OPERAND\n         CLI   ALTUI,C'Z'\n         BH    ERRPM3                  INVALID LAST OPERAND\n         MVI   FLAG3D,1                SIGNAL A LAST OPERAND\nNOLAST   BAS   R9,CHKDTES              CHECK DATE(S)\n         SPACE 1\n*------- ALLOCATION DYNAMIQUE DU FICHIER D'AGENDA\n*        QUI SE TROUVE SOUS LA DD-NAME 'DIARY'.\n*        BUILD THE DSNAME TO BE ALLOCATED.\n         SPACE 1\n         LA    R6,L'USID               MAX 7 CHAR IN USERID\n         CLI   FLAG3D,1                WAS A LAST PARM PASSED ?\n         BNE   *+L'*+8                 IF NOT, SKIP USERID\n         LA    R4,ALTUI                USERID PASSED AS LAST PARM.\n         B     *+L'*+4\n         LA    R4,USID                 USERID ADDRESS\n         LA    R5,DYNDSNM              DSNAME ADDRESS\nLOOP1    CLI   0(R4),C' '              IS CHARACTER BLANK ?\n         BE    MOVEEND                 IF YES, ADD END OF DSNAME\n         MVC   0(1,R5),0(R4)           IF NOT, MOVE CHARACTER\n         LA    R4,1(R4)                JUMP TO NEXT CHAR IN USERID\n         LA    R5,1(R5)                JUMP TO NEXT CHAR IN DSNAME\n         BCT   R6,LOOP1                LOOP MAX 7 TIMES\nMOVEEND  MVC   0(7,R5),=CL7'.AGENDA'   END OF DSNAME (OLD VERSION)\n        $DYNALL DYNLIST                DYNAMIC ALLOC OF DIARY\n         LTR   R15,R15                 TEST RETURN CODE\n         BZ    OPDSD                   B ON ALLOCATED\n         CH    R15,=H'4'               LOOK IF NOT FOUND\n         BNE   ERRALL                  B ON ERROR ALLOC\n         CL    R0,=A(X'17080000')\n         BNE   ERRALL                  B ON ERROR ALLOC\n         NOP   ERRNFD                  B ON NOT FOUND\n         OI    *-3,ON                  CLOSE THIS WAY\n         MVC   7(5,R5),=CL5'.DATA'     END OF DSNAME (NEW VERSION)\n         B     MOVEEND+L'MOVEEND\nOPDSD   OPEN   (DIARY,(INPUT))         OPEN FILE DIARY\n         TM    DIARY+(DCBOFLGS-IHADCB),DCBOFOPN  OPEN SUCCESSFULL ?\n         BZ    ERROPN                  NO, ERROR\n         XR    R7,R7                   ENTRIES COUNTER\n         L     R6,ATBMSG               TABLE OF MESSAGES\nGET     GET    DIARY,WRKAR             READ FILE\nSWGTE    NOP   ERRGEM\n         CLI   WRKAR,C'*'              IS FIRST CHAR '*' ?\n         BNE   TESTNUM                 IF NOT, TEST IF NUMERIC\n         XC    WRKAR(8),WRKAR          SET DATE TO ZERO INSTEAD OF *\nSTRTBL   CL    R7,=A(NTMX)             CHECK PLACE IN TABLE\n         BNL   TBOVFL                  NO MORE, TABLE OVERFLOW\n         MVC   0(80,R6),WRKAR          MOVE RECORD IN TABLE\n         LA    R6,80(R6)               JUMP TO NEXT FREE ENTRY\n         AH    R7,=H'1'                ADD ONE IN COUNTER\n         B     GET                     READ NEXT RECORD\nTBOVFL   LA    R0,L'MSGOVFL\n         LA    R1,MSGOVFL\n         B     ERREXM                  EXIT\nTESTNUM  MVC   DSD,=CL6'000000'\n         MVN   DSD(2),WRKAR            MOVE DD\n         MVN   DSD+2(2),WRKAR+3        MOVE MM\n         MVN   DSD+4(2),WRKAR+6        MOVE YY\n         CLC   DSD(2),WRKAR            IS DATE IN NUMERIC ?\n         BNE   *+L'*+20\n         CLC   DSD+2(2),WRKAR+3\n         BNE   *+L'*+10\n         CLC   DSD+4(2),WRKAR+6\n         BE    CHKSEP                  YES\n         LA    R0,L'MESSAGE1           NO, ERROR MESSAGES\n         LA    R1,MESSAGE1\n         BAS   R14,PUTLNE\n         LA    R0,L'MESSAGE2\n         LA    R1,MESSAGE2\nERRVRFY  BAS   R14,PUTLNE\n         LA    R0,L'MESSAGE3\n         LA    R1,MESSAGE3\n         B     ERREXM                  EXIT\nCHKSEP   CLI   WRKAR+2,C'.'            CHECK DATES SEPARATORS\n         BE    *+L'*+8\n         CLI   WRKAR+2,C'-'\n         BNE   *+L'*+4\n         MVI   WRKAR+2,C'/'\n         CLI   WRKAR+5,C'.'\n         BE    *+L'*+8\n         CLI   WRKAR+5,C'-'\n         BNE   *+L'*+4\n         MVI   WRKAR+5,C'/'\n         CLI   WRKAR+2,C'/'\n         BNE   *+L'*+8\n         CLI   WRKAR+5,C'/'\n         BE    CHKSDTE\n         LA    R0,L'MESSAGE4           ERROR MESSAGES\n         LA    R1,MESSAGE4\n         BAS   R14,PUTLNE\n         LA    R0,L'MESSAGE5\n         LA    R1,MESSAGE5\n         BAS   R14,PUTLNE\n         LA    R0,L'MESSAGE6\n         LA    R1,MESSAGE6\n         B     ERRVRFY                 EXIT\nCHKSDTE  ICM   R0,B'0011',WRKAR        BUILD DATE\n         ICM   R0,B'1100',WRKAR+3        FROM DD/MM/YY\n         STCM  R0,B'1111',DSD              TO MMDDYYYY\n         MVC   DSD+6(2),WRKAR+6\n         CLC   WRKAR+6(2),=CL2'50'     SET CENTURY AHEAD\n         BL    *+L'*+10\n         MVC   DSD+4(2),=CL2'19'\n         B     *+L'*+6\n         MVC   DSD+4(2),=CL2'20'\n        $GSDATE DSD,WRKAR\n         LTR   R15,R15\n         BZ    COMPARE\n         ST    R15,DSD\n         UNPK  MESSAGE7+L'MESSAGE7-10(9),DSD(5)\n         TR    MESSAGE7+L'MESSAGE7-10(8),TRTAB-X'F0'\n         MVI   MESSAGE7+L'MESSAGE7-2,C')'\n         MVC   MESSAGE7+13(8),WRKAR\n         LA    R0,L'MESSAGE7\n         LA    R1,MESSAGE7\n         B     ERRVRFY                 EXIT\nCOMPARE  MVI   WRKAR+7,0               CLEAR LAST BYTE OF PREVIOUS DATE\n         CLI   FLAGP,2                 WAS THERE 2 OPERANDS PASSED ?\n         BE    RANGE                   IF YES, COMPARE A RANGE OF DATE\n         CLC   SDTE(L'SDTE),WRKAR      COMPARE DATES\n         BNE   GET                     IF DIFFERENT, READ AGAIN\n         B     STRTBL                  GO MOVE RECORD IN TABLE\nRANGE    CLC   WRKAR(L'SDTE),SDTE      COMPARE REC.DATE - LOWER LIMIT\n         BL    GET                     IF LOW, READ NEXT RECORD\n         CLC   WRKAR(L'EDTE),EDTE      COMPARE REC.DATA - HIGHER LIMIT\n         BH    GET                     IF HIGH, READ NEXT RECORD\n         B     STRTBL                  GO MOVE RECORD IN TABLE\n         SPACE 1\n*------- SORT TABLE IN ASCENDING ORDER ON THE DATE.\n         SPACE 1\nEODATA   CH    R7,=H'1'                COMPARE WITH ONE\n         BNH   NOSORT                  IF LOW OR EQUAL, NO SORT\n         L     R6,ATBMSG\n        $SORT  (R6),(R7),80,0,8        SORT TABLE ON DATE\n         SPACE 1\n*------- DISPLAY TABLE CONTENTS.\n         SPACE 1\nNOSORT   LTR   R7,R7                   ANY ENTRY ?\n         BP    *+L'*+16                YES\n         LA    R0,L'MSGNONE            NO, SAY NONE\n         LA    R1,MSGNONE\n         BAS   R14,PUTLNE\n         B     CLDSD\n         L     R4,ATBMSG               BEGINNING OF TABLE\nTH1L1    LR    R6,R4\n         OC    0(8,R4),0(R4)           IS IT AN ALL DAYS MESSAGE ?\n         BNZ   DTELN                   NO\n         LA    R0,L'MSGALLD            PUT ALL DAYS MESSAGE\n         LA    R1,MSGALLD\n         B     PDTLN\nDTELN    MVC   WRKAR(7),=CL7'Date : '\n         MVC   WRKAR+7(30),WRKAR+6\n        $GFDATE WRKAR+7,,MDY,(R4)\n         LTR   R15,R15\n         BZ    DSPLDT\n         MVC   WRKAR+7(11),=CL11'GFDATE R15='\n         ST    R15,DSD\n         UNPK  WRKAR+18(9),DSD(5)\n         MVI   WRKAR+26,C'.'\n         B     DSPLDL\nDSPLDT   NC    WRKAR+8(2),=XL2'BFBF'   LOWER-CASE\n         NC    WRKAR+13(2),=XL2'BFBF'\n         MVC   WRKAR+26(10),=CL10'(  /  /  )'\n         MVC   WRKAR+27(2),MDY+2\n         MVC   WRKAR+30(2),MDY\n         MVC   WRKAR+33(2),MDY+6\nDSPLDL   LA    R0,36                   PUT DATE LINE\n         LA    R1,WRKAR\nPDTLN    BAS   R14,PUTLNE\nTH1L2    MVC   WRKAR(4),=CL4' -> '     DISPLAY MESSAGE\n         MVC   WRKAR+4(72),8(R4)\n         LA    R0,76\n         LA    R1,WRKAR\n         BAS   R14,PUTLNE\n         BCT   R7,*+L'*+4              LOOP UNTIL END\n         B     CLDSD\n         LA    R4,80(R4)               JUMP TO NEXT ENTRY\n         CLC   0(8,R4),0(R6)           COMPARE DATES\n         BE    TH1L2                   IF EQUAL, DISPLAY MESSAGE\n         B     TH1L1                   IF DIFFERENT, DISPLAY DATE\nCLDSD   CLOSE  (DIARY)\nNXTREQ   CLI   DYNDSNM,C' '            INITIAL REQUEST ?\n         BNE   *+L'*+12                NO\n         LA    R0,L'MSGINIT\n         LA    R1,MSGINIT\n         B     *+L'*+8\n         LA    R0,L'MSGENTER\n         LA    R1,MSGENTER\n         BAS   R14,PUTLNE              ASK CONTINUE OR END\n         BAS   R14,GETLNE\n         L     R3,INPUTADR\n         CLC   0(2,R3),=H'4'           A NULL RETURN ?\n         BH    *+L'*+12                NO, GO SEE WHAT REQUESTED\n         CLI   DYNDSNM,C' '            YES, ON INITIAL REQUEST ?\n         BE    NXTREQ                  YES, NO REPLY, GO ASK AGAIN\n         B     XREPT                   NO, IT IS A REPEAT\n         CLC   0(2,R3),=H'7'           MAY BE END ?\n         BNE   ANALZE\n         MVC   DSD(3),4(R3)\n         TR    DSD(3),MAJMIN\n         CLC   DSD(3),=CL3'END'\n         BE    FRDSD                   END, EXIT\nANALZE   CLI   DYNDSNM,C' '            INITIAL REQUEST ?\n         BE    INITRQ                  YES\n         BAS   R9,GETDTES              GET DATE(S) IF ANY\n         NOP   0                       +0\n         BAS   R9,CHKDTES              +4 CHECK DATE(S)\nXREPT    NI    SWERSE+1,OFF            OPEN FIRST PUTLINE WAY\n         B     OPDSD\nFRDSD    CLI   DYNDSNM,C' '            INITIAL REQUEST ?\n         BE    LEAVE                   YES\n         XC    DYNDSNM,DYNDSNM\n        $DYNALL DYNLIST                DYNAMIC DE-ALLOC OF DIARY\n         LTR   R15,R15                 TEST RETURN CODE\n         BZ    LEAVE                   B ON DE-ALLOCATED\n         STM   R15,R0,DSD\n         LA    R0,L'ERROR1\n         LA    R1,ERROR1\n         BAS   R14,PUTLNE\n         B     ERRDLL\nNOTTSO  WTO    'NOT ALLOWED OUTSIDE TSO - REJECTED.',ROUTCDE=11,DESC=7\nLEAVE    L     R1,ATBMSG\n        FREEMAIN R,A=(1),LV=WSZ\n        $XRET  CC=0\n         SPACE 1\n*        ERROR ANALYSIS ROUTINE (DIARY-READ).\n         SPACE 1\n        CNOP   0,4\nERRGET  SYNADAF   ACSMETH=BSAM\n         MVC   MSGERR+4(72),56(R1)\n         CLI   69(R1),C'*'             TEST UNSIGNIFICANT MESSAGE ?\n         BE    SYNAD2                  BRANCH IF YES\n         CLI   8(R1),C' '              TEST IF BINARY INFORMATIONS ?\n         BE    SYNAD1                  BRANCH IF NOT\n         UNPK  MSGERR+4(7),9(4,R1)\n         TR    MSGERR+4(6),TRTAB-X'F0'\n         MVI   MSGERR+10,C','\n         UNPK  MSGERR+11(5),12(3,R1)\n         TR    MSGERR+11(4),TRTAB-X'F0'\n         MVI   MSGERR+15,C','\n         B     SYNAD2\nSYNAD1   MVC   MSGERR+4(12),8(R1)      MOVE BLANKS.\nSYNAD2  SYNADRLS\n         NI    SWGTE+1,OFF             SET NOP OPERATION\n         BR    R14                     RETURN\n         EJECT\n*--------------------------------------------------------------------*\n*        MESSAGES D'ERREURS.                                         *\n*--------------------------------------------------------------------*\n         SPACE 1\nERRPM1   LA    R0,L'ERRMPM1\n         LA    R1,ERRMPM1\n         BAS   R14,PUTLNE\n         B     NXTREQ                  ASK AGAIN\nERRPM2   LA    R0,L'ERRMPM2\n         LA    R1,ERRMPM2\n         BAS   R14,PUTLNE\n         B     NXTREQ                  ASK AGAIN\nERRPM3   LA    R0,L'ERRMPM3\n         LA    R1,ERRMPM3\n         BAS   R14,PUTLNE\n         B     NXTREQ                  ASK AGAIN\nNOCALL   L     R1,ATSO\n         TM    0(R1),X'80'             ARE WE RUNNING IN BACKGROUND?\n         BO    STSO                    NO, IN FOREGROUND\n        WTO    '\"CALL\" NOT ALLOWED - REJECTED.',ROUTCDE=11,DESC=7\n         B     LEAVE\nSTSO    TPUT   MSGNCL,L'MSGNCL\n         B     LEAVE\nERRALL   STM   R15,R0,DSD\n         LA    R0,L'ERROR0\n         LA    R1,ERROR0\n         BAS   R14,PUTLNE\nERRDLL   UNPK  ERROR1C+8(9),DSD(5)\n         TR    ERROR1C+8(8),TRTAB-X'F0'\n         MVI   ERROR1C+16,C' '\n         UNPK  ERROR1C+22(9),DSD+4(5)\n         TR    ERROR1C+22(8),TRTAB-X'F0'\n         MVI   ERROR1C+30,C' '\n         LA    R0,L'ERROR1C\n         LA    R1,ERROR1C\n         BAS   R14,PUTLNE\n         B     LEAVE                   EXIT\nERRNFD   LA    R0,L'ERROR2\n         LA    R1,ERROR2\n         BAS   R14,PUTLNE\n         B     LEAVE                   EXIT\nERRGSDT  MVI   ERROR3+5,C'S'\nERRGFDT  ST    R15,DSD\n         UNPK  ERROR3+L'ERROR3-16(9),DSD(5)\n         TR    ERROR3+L'ERROR3-16(8),TRTAB-X'F0'\n         MVI   ERROR3+L'ERROR3-8,C' '\n         LA    R0,L'ERROR3\n         LA    R1,ERROR3\n         BAS   R14,PUTLNE\n         B     FRDSD                   EXIT\nERROPN   LA    R0,L'ERROR4\n         LA    R1,ERROR4\n         BAS   R14,PUTLNE\n         B     FRDSD                   EXIT\nERRGEM   LA    R0,L'ERROR5\n         LA    R1,ERROR5\n         BAS   R14,PUTLNE\n         LA    R0,L'MSGERR\n         LA    R1,MSGERR\nERREXM   BAS   R14,PUTLNE\n        CLOSE  (DIARY)\n         B     FRDSD                   EXIT\n         EJECT\n*        GETDTES - GET DATES ROUTINE.\n*\n*              R0  : WORK REGISTER.\n*              R1  : WORK REGISTER.\n*              R2  : WORK REGISTER.\n*              R3  : INPUT BUFFER POINTER.\n*              R4  : WORK REGISTER.\n*              R9  : LINK REGISTER - RETURN +0 = NO OR ONE DATE\n*                                           +4 = TWO DATES\n         SPACE 1\nGETDTES  LA    R4,4(R3)                INPUT TEXT START ADDRESS\n         LH    R0,0(R3)                TOTAL LENGTH\n         ALR   R3,R0                   END ADDRESS + 1\n         BCTR  R3,0                    ADJUST IT\n         LA    R2,1\n         XC    SDTE,SDTE               INITIALIZE DATE(S)\n         XC    EDTE,EDTE\n         MVI   FLAGP,0                 SAY NO DATES OPERANDS\n         LA    R1,5(R4)\n         CLR   R1,R3\n         BH    *+L'*+14\n         CLC   0(6,R4),=CL6'AGENDA'    COMMAND NAME ?\n         BNE   *+L'*+4                 NO\n         LA    R4,6(R4)                YES, SKIP IT\n         CLI   0(R4),C' '              LOOK FOR START-DATE OPERAND\n         BNE   *+L'*+6\n         BXLE  R4,R2,*-8\n         BR    R9                      RETURN = +0\n         CLI   DYNDSNM,C' '            INITIAL REQUEST ?\n         BNE   *+L'*+8                 NO\n         CLI   0(R4),C'0'              YES, POSSIBLE LAST OPERAND ?\n         BL    4(R9)                   YES\n         LA    R1,DSD                  GET START-DATE OPERAND\n         LA    R0,L'DSD\nLPMVP1   MVC   0(1,R1),0(R4)\n         BXLE  R4,R2,*+L'*+4\n         B     CHKPM1\n         CLI   0(R4),C' '\n         BE    CHKPM1\n         LA    R1,1(R1)\n         BCT   R0,LPMVP1\n         B     ERRPM1                  INVALID START-DATE OPERAND\nCHKPM1   XC    WRKAR(8),WRKAR\n         MVZ   WRKAR(8),DSD\n         CLI   DSD+2,C'.'\n         BE    *+L'*+8\n         CLI   DSD+2,C'-'\n         BNE   *+L'*+4\n         MVI   DSD+2,C'/'\n         CLI   DSD+5,C'.'\n         BE    *+L'*+8\n         CLI   DSD+5,C'-'\n         BNE   *+L'*+4\n         MVI   DSD+5,C'/'\n         MVC   WRKAR+2(1),DSD+2\n         MVC   WRKAR+5(1),DSD+5\n         CLC   WRKAR(8),=CL8'00/00/00'\n         BNE   ERRPM1                  INVALID START-DATE OPERAND\n         CLC   DSD(8),=CL8'00/00/00'   START OF ALL AGENDA ?\n         BNE   *+L'*+10                NO\n         XC    SDTE,SDTE\n         B     SETFL1\n         CLC   DSD(8),=CL8'99/99/99'   END OF ALL AGENDA ?\n         BNE   *+L'*+10                NO\n         MVC   SDTE,=XL7'FFFFFFFFFFFFFF'\n         B     SETFL1\n         ICM   R0,B'0011',DSD          CHANGE DATE\n         ICM   R0,B'1100',DSD+3          FROM DD/MM/YY\n         STCM  R0,B'1111',DSD              TO MMDDYYYY\n         CLC   DSD+6(2),=CL2'50'       SET CENTURY AHEAD\n         BL    *+L'*+10\n         MVC   DSD+4(2),=CL2'19'\n         B     *+L'*+6\n         MVC   DSD+4(2),=CL2'20'\n        $GSDATE DSD,SDTE               CHECK VALIDITY\n         LTR   R15,R15\n         BNZ   CHKPM1\nSETFL1   MVI   FLAGP,1                 SET FLAG TO ONE DATE OPERAND\n         CLR   R4,R3\n         BNLR  R9                      RETURN = +0\n         CLI   0(R4),C' '              LOOK FOR END-DATE OPERAND\n         BNE   *+L'*+6\n         BXLE  R4,R2,*-8\n         BR    R9                      RETURN = +0\n         CLI   DYNDSNM,C' '            INITIAL REQUEST ?\n         BNE   *+L'*+8                 NO\n         CLI   0(R4),C'0'              YES, POSSIBLE LAST OPERAND ?\n         BL    4(R9)                   YES\n         LA    R1,DSD                  MOVE END-DATE OPERAND\n         LA    R0,L'DSD\nLPMVP2   MVC   0(1,R1),0(R4)\n         BXLE  R4,R2,*+L'*+4\n         B     CHKPM2\n         CLI   0(R4),C' '\n         BE    CHKPM2\n         LA    R1,1(R1)\n         BCT   R0,LPMVP2\n         B     ERRPM2                  INVALID END-DATE OPERAND\nCHKPM2   XC    WRKAR(8),WRKAR\n         MVZ   WRKAR(8),DSD\n         CLI   DSD+2,C'.'\n         BE    *+L'*+8\n         CLI   DSD+2,C'-'\n         BNE   *+L'*+4\n         MVI   DSD+2,C'/'\n         CLI   DSD+5,C'.'\n         BE    *+L'*+8\n         CLI   DSD+5,C'-'\n         BNE   *+L'*+4\n         MVI   DSD+5,C'/'\n         MVC   WRKAR+2(1),DSD+2\n         MVC   WRKAR+5(1),DSD+5\n         CLC   WRKAR(8),=CL8'00/00/00'\n         BNE   ERRPM2                  INVALID END-DATE OPERAND\n         CLC   DSD(8),=CL8'00/00/00'   START OF ALL AGENDA ?\n         BNE   *+L'*+10                NO\n         XC    EDTE,EDTE\n         B     SETFL2\n         CLC   DSD(8),=CL8'99/99/99'   END OF ALL AGENDA ?\n         BNE   *+L'*+10                NO\n         MVC   EDTE,=XL7'FFFFFFFFFFFFFF'\n         B     SETFL2\n         ICM   R0,B'0011',DSD          CHANGE DATE\n         ICM   R0,B'1100',DSD+3          FROM DD/MM/YY\n         STCM  R0,B'1111',DSD              TO MMDDYYYY\n         CLC   DSD+6(2),=CL2'50'       SET CENTURY AHEAD\n         BL    *+L'*+10\n         MVC   DSD+4(2),=CL2'19'\n         B     *+L'*+6\n         MVC   DSD+4(2),=CL2'20'\n        $GSDATE DSD,EDTE               CHECK VALIDITY\n         LTR   R15,R15\n         BNZ   CHKPM2\nSETFL2   MVI   FLAGP,2                 SET FLAG TO TWO DATES OPERANDS\n         B     4(R9)                   RETURN = +4\n         EJECT\n*        CHKDTES - CHECK DATE(S) ROUTINE.\n*                  GET TODAY DATE IF NONE SPECIFIED.\n*\n*              R2  : WORK REGISTER.\n*              R9  : LINK REGISTER.\n         SPACE 1\nCHKDTES  CLI   FLAGP,0                 OPERAND(S) PASSED ?\n         BNE   SEEWH                   YES\n         LA    R2,SDTE\nSETDTE  $GFDATE ,,MDY\n         LTR   R15,R15\n         BNZ   ERRGFDT\n        $GSDATE MDY,(R2)\n         LTR   R15,R15\n         BNZ   ERRGSDT\n         BR    R9                      RETURN\nSEEWH    CLI   FLAGP,1                 ONLY ONE OPERAND PASSED ?\n         BE    SETONE+L'SETONE         YES\n         CLC   SDTE,EDTE               COMPARE START AGAINST END DATES\n         BLR   R9                      IF LOW, OK, RETURN\n         BE    SETONE                  IF EQUAL, GO SAY ONLY ONE\n         XC    SDTE,EDTE               IF HIGH, EXCHANGE DATES\n         XC    EDTE,SDTE\n         XC    SDTE,EDTE\n         BR    R9                      RETURN\nSETONE   MVI   FLAGP,1                 IF EQUAL, SAY ONLY START-DATE\n         OC    SDTE,SDTE               IS IT START OF ALL AGENDA ?\n         BNZ   *+L'*+12                NO\n         MVI   FLAGP,2                 YES, SAY TWO DATES\n         LA    R2,EDTE                 SAY UNTIL TODAY\n         B     SETDTE\n         CLC   SDTE,=XL7'FFFFFFFFFFFFFF' IS IT END OF ALL AGENDA ?\n         BNER  R9                      NO, RETURN\n         MVI   FLAGP,2                 YES, SAY TWO DATES\n         MVC   EDTE,SDTE               SET IT AS END-DATE\n         LA    R2,SDTE                 SAY FROM TODAY\n         B     SETDTE\n         EJECT\n*        PUTLNE - PUTLINE ROUTINE.\n*\n*              R0  : MESSAGE TEXT LENGTH.\n*              R1  : POINTS TO THE MESSAGE TEXT.\n*              R14 : LINK REGISTER.\n         SPACE 1\nPUTLNE   STM   R0,R15,SAVEREGS         SAVE CALLER'S REGS\nSWERSE   NOP   SKPFRST\n         OI    SWERSE+1,ON             CLOSE THIS WAY\n         L     R1,ATSO\n         TM    0(R1),X'80'             ARE WE RUNNING IN BACKGROUND?\n         BZ    SKPCLR                  YES, SKIP CLEAR\n        CALL   ERASE                   EVENTUALLY CLEAR IF SCREEN\n         LA    R0,L'MSGTIT             START BY THE TITLE\n         LA    R1,MSGTIT\n         MVC   SAVEFRST(16*4),SAVEREGS\n         BAS   R14,PUTLNE\n         MVC   SAVEREGS(16*4),SAVEFRST\nSKPCLR   LM    R0,R1,SAVEREGS          RESTORE PARM-REGS\nSKPFRST  LTR   R2,R0\n         BNP   NOMSG\n         BCT   R2,*+L'*+6\n         MVC   MSGOUT(*-*),0(R1)\n         EX    R2,*-6\n         MVC   MSGCNTL,=AL2(L'MSGWORK,0)  MOVE IN PUTLINE CTL CHARS\n         LA    R5,MSGWORK              ADDR OF MSG BUFFER\n         L     R2,CPPLADDR             ADDR OF CPPL\n         USING CPPL,R2\n         L     R3,CPPLUPT              UPT ADDR\n         L     R4,CPPLECT              ECT ADDR\n         DROP  R2\n         XC    PECB,PECB               CLEAR ECB TO ZEROS\n         XC    PTPB(12),PTPB           CLEAR PLIST TO ZEROS\n         XC    IOPLZ(16),IOPLZ         CLEAR PARM LIST TO ZEROS\n         LA    R1,IOPLZ                ADDR OF LIST\n        PUTLINE PARM=PTPB,UPT=(R3),ECT=(R4),ECB=PECB,                  X\n               TERMPUT=(EDIT,WAIT,NOHOLD,NOBREAK),                     X\n               OUTPUT=((R5),TERM,SINGLE,DATA),                         X\n               MF=(E,(1))\n         MVI   MSGWORK,C' '            CLEAR BUFFER TO SPACES\n         MVC   MSGWORK+1(L'MSGWORK-1),MSGWORK\nNOMSG    LM    R0,R15,SAVEREGS         RESTORE CALLER'S REGS\n         BR    R14                     RETURN TO CALLER\n         EJECT\n*        GETLNE - GETLINE ROUTINE.\n*\n*              R14 : LINK REGISTER.\n*              AT EXIT : INPUTADR = A(INPUT BUFFER ADDRESS).\n         SPACE 1\nGETLNE   STM   R0,R15,SAVEREGS         SAVE CALLER'S REGS\n         L     R2,CPPLADDR             ADDR OF CPPL\n         USING CPPL,R2\n         L     R3,CPPLUPT              UPT ADDR\n         L     R4,CPPLECT              ECT ADDR\n         DROP  R2\n         XC    RECB,RECB               CLEAR OUT ECB\n         XC    GTPBX(8),GTPBX          CLEAR GET PARMLIST TO ZEROS\n         XC    IOPLX(16),IOPLX         CLEAR PARM LIST TO ZEROS\n         LA    R1,IOPLX                ADDR OF LIST\n        GETLINE PARM=GTPBX,UPT=(R3),ECT=(R4),ECB=RECB,                 X\n               TERMGET=(EDIT,WAIT),INPUT=(TERM,LOGICAL),               X\n               MF=(E,(1))\n         LA    R5,GTPBX                ADDRESSABILITY FOR THE GTPB\n         USING GTPB,R5\n         MVC   INPUTADR,GTPBIBUF       SAVE ADDR OF INPUT BUFFER\n         DROP  R5\n         LM    R0,R15,SAVEREGS         RESTORE CALLER'S REGS\n         BR    R14                     RETURN TO CALLER\n         EJECT\n*--------------------------------------------------------------------*\n*        VARIABLES DE TRAVAIL.                                       *\n*--------------------------------------------------------------------*\n         SPACE 1\nDIARY   DCB    DDNAME=DIARY,DSORG=PS,MACRF=GM,EODAD=EODATA,            X\n               SYNAD=ERRGET,RECFM=FB,BLKSIZE=9040,LRECL=80\n         SPACE 1\n*--------------------------------------------------------------------*\n*        DYNAMIC ALLOCATION PARAMETER LIST.                          *\n*--------------------------------------------------------------------*\n         SPACE 1\nDYNLIST  DC    CL8'DIARY'  DDNAME\nDYNDSNM  DC    CL44' '     DSNAME\n         DC    CL8' '      MEMBER NAME\n         DC    CL8' '      PASSWORD\n         DC    CL8'SHR'    STATUS\n         DC    CL256' '    FILLER\n         DC    CL88' '     FILLER\n         SPACE 1\n*                 0 1 2 3 4 5 6 7 8 9 A B C D E F\nMAJMIN   DC    X'000102030405060708090A0B0C0D0E0F'  0\n         DC    X'101112131415161718191A1B1C1D1E1F'  1\n         DC    X'202122232425262728292A2B2C2D2E2F'  2\n         DC    X'303132333435363738393A3B3C3D3E3F'  3\n         DC    X'404142434445464748494A4B4C4D4E4F'  4\n         DC    X'505152535455565758595A5B5C5D5E5F'  5\n         DC    X'606162636465666768696A6B6C6D6E6F'  6\n         DC    X'707172737475767778797A7B7C7D7E7F'  7\n         DC    X'80C1C2C3C4C5C6C7C8C98A8B8C8D8E8F'  C\n         DC    X'90D1D2D3D4D5D6D7D8D99A9B9C9D9E9F'  9\n         DC    X'A0A1E2E3E4E5E6E7E8E9AAABACADAEAF'  A\n         DC    X'F0F1F2F3F4F5F6F7F8F9BABBBCBDBEBF'  B\n         DC    X'C0C1C2C3C4C5C6C7C8C9CACBCCCDCECF'  C\n         DC    X'D0D1D2D3D4D5D6D7D8D9DADBDCDDDEDF'  D\n         DC    X'E0E1E2E3E4E5E6E7E8E9EAEBECEDEEEF'  E\n         DC    X'F0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFF'  F\nTRTAB    DC    C'0123456789ABCDEF'\n         EJECT\nSAVEREGS DC    18F'0'    FOR PUTLINE/GETLINE\nSAVEFRST DC    18F'0'    FOR FIRST PUTLINE\nCPPLADDR DC    A(*-*)    PUTLINE/GETLINE USE\nATBMSG   DC    A(*-*)    ADDRESS OF TABLE OF MESSAGES TO DISPLAY\nMSGWORK  DS    0CL84     PUTLINE WORK USE\nMSGCNTL  DC    F'0'           CONTROL WORD FOR PUTLINE\nMSGOUT   DC    CL80' '        PUTLINE TEXT\nIOPLZ    DC    4F'0'          I-O PARM LIST FOR PUTLINE\nPTPB     DC    3F'0'\nPECB     DC    F'0'\nIOPLX    DC    4F'0'          I-O PARM LIST FOR GETLINE\nGTPBX    DC    2F'0'\nINPUTADR DC    A(*-*)         ADDR FOR INPUT BFFER\nRECB     DC    F'0'\n         SPACE 1\nEXTRL   EXTRACT ATSO,'S',FIELDS=(TSO,PSB),MF=L\nATSO     DC    A(*-*)\nAPSCB    DC    A(*-*)\n         SPACE 1\nDSD      DC    D'0'\nWRKAR    DC    CL80' '\nMDY      DC    CL8' '    MONTH, DAY, YEAR (MMDDYYYY) FROM GFDATE\nSDTE     DC    CL7' '    TO GET EVENTUAL START-DATE OPERAND (YYYYDDD)\nEDTE     DC    CL7' '    TO GET EVENTUAL END-DATE OPERAND (YYYYDDD)\nUSID     DC    CL7' '    USER-ID\nALTUI    DC    CL7' '    TO GET EVENTUAL LAST OPERAND (USERID)\nFLAGP    DC    XL1'0'    FLAG TO SIGNAL AN OPERAND WAS PASSED\nFLAG3D   DC    XL1'0'    FLAG TO SIGNAL A LAST OPERAND\n         EJECT\nMSGERR   DC    CL78' '\nMSGNCL   DC    C'\"CALL\" NOT ALLOWED - REJECTED.'\nMSGINIT  DC    C'Re-enter correct command or \"END\" :'\nMSGENTER DC    C'Enter date(s), \"END\" or hit \"ENTER\" to repeat :'\nMSGTIT   DC    C'    =====  A G E N D A  ====='\nMSGALLD  DC    C'Date : all days'\nMSGNONE  DC    C'--- None in AGENDA for your request.'\nMSGOVFL  DC    C'--- Internal table space overflow, exit.'\nERRMPM1  DC    C'--- Start-date operand is invalid.'\nERRMPM2  DC    C'--- End-date operand is invalid.'\nERRMPM3  DC    C'--- User-ID last operand is invalid.'\nMESSAGE1 DC    C'---    At least one date has been found which is not'\nMESSAGE2 DC    C'       numeric form (except dates starting by an *).'\nMESSAGE3 DC    C'---    Verify the dates in your file AGENDA, please.'\nMESSAGE4 DC    C'---    At least one date has been found which is not'\nMESSAGE5 DC    C'       coded using slash, period or minus sign as'\nMESSAGE6 DC    C'       separator (except dates starting by an *).'\nMESSAGE7 DC    C'---    Date \"........\" invalid (GSDATE R15=........).'\nERROR0   DC    C'--- File AGENDA allocation error.'\nERROR1   DC    C'--- File AGENDA de-allocation error.'\nERROR1C  DC    C'    R15=........ - R0=........ - Exit.'\nERROR2   DC    C'--- File AGENDA not found, create it, please.'\nERROR3   DC    C'--- GFDATE error detected - R15=........ - exit.'\nERROR4   DC    C'--- OPEN error detected on file AGENDA, exit.'\nERROR5   DC    C'--- READ error detected on file AGENDA, exit.'\n         EJECT\n        LTORG\n         SPACE 1\n        DROP   R10,R11\n        IKJCPPL\n        IKJPSCB\n        IKJEBECA\n        IKJGTPB\n        DCBD   DEVD=DA,DSORG=PS\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "AGENDA$": {"ttr": 778, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x942\\x7f\\x00\\x942\\x7f\\x14#\\x00\\x0f\\x00\\x0f\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-23T00:00:00", "modifydate": "1994-11-23T14:23:00", "lines": 15, "newlines": 15, "modlines": 0, "user": "SYSPAJA"}, "text": "//AGENDA   JOB (........),'INSTALL  -AGENDA-',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=800K,TIME=1\n/*JOBPARM L=6\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//* PRE-REQUISITE MODULES INSTALLATION :                              *\n//*                DYNALL    ERASE     GFDATE                         *\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//ASS     EXEC PAJ1AS2,MBR=AGENDA\n//LNK     EXEC PAJILKC\n//SYSIN     DD *\n  INCLUDE      SYSADD(DYNALL,ERASE,GFDATE)\n  ENTRY   AGENDA\n  NAME    AGENDA(R)\n/*\n//HLP     EXEC PAJHELP,MBR=AGENDAH,DSS='->.SOURCE.FILE1'\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "AGENDAH": {"ttr": 780, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x00\\x9f\\x00\\x90\\x00\\x9f\\x14\\x06\\x002\\x002\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-01-09T00:00:00", "modifydate": "1990-01-09T14:06:00", "lines": 50, "newlines": 50, "modlines": 0, "user": "SYSPAJA"}, "text": "./     ADD     NAME=AGENDA\n./     NUMBER  NEW1=100,INCR=100\n)F FUNCTION : the AGENDA command displays all today (by default)\n    planned activities or any others as required by a specified date.\n    To use this facility, it is mandatory to :\n         (1) pre-allocate a sequential data-set with the following\n             characteristics :\n             DSNAME  - 'User-ID.AGENDA.DATA' User-ID = your USERID\n             FORMAT  -  FB               Fixed blocked\n             DSORG   -  PS               Physical sequential\n             LRECL   -  80               Record length\n             BLKSIZE -  9040             Block length\n             Note : if you have an already existing data-set named\n                    'User-id.AGENDA', don't worry about, it will be\n                    correctly handled (but if you want, you may rename\n                    your data-set as 'User-id.AGENDA.DATA').\n         (2) then, initialize this AGENDA data-set with your planned\n             activities (using an EDIT of your choice).\n             The records must be formated as below :\n             DD/MM/YY..............message....................\n             <---  80 bytes long  --- --- --- --- --- --- --->\n             Where :\n             col 1-2  = DD (2 digits) is the day\n             Col 3    = a slash (/), a period (.) or a minus sign (-)\n             Col 4-5  = MM (2 digits) is the month\n             Col 6    = a slash (/), a period (.) or a minus sign (-)\n             Col 7-8  = YY (2 digits) is the year\n             Col 9-80 = message (characters - free format)\n             Note : an * in col 1 defines a message (col 9-80) to be\n                    always displayed.\n)X SYNTAX :\n         AGENDA    = today message(s) by default\n      or AGENDA DD/MM/YY\n                   = specified date DD/MM/YY message(s)\n      or AGENDA DD/MM/YY DD/MM/YY\n                   = specified range of dates message(s)\n      or any previous AGENDA command format followed by a last operand\n                   User-ID which allows the access to another AGENDA\n                   data-set if desired.\n         Note : date(s) are also accepted in format DD.MM.YY (period\n                used) or DD-MM-YY (minus sign used).\n)O OPERAND : none required.\n    Remark : the date 00/00/00 means the beginning of the file, and\n             the date 99/99/99 means the end of the file.\n    Examples : AGENDA 00/00/00 99/99/99 means display the entire file.\n               AGENDA 00/00/00 means display from the beginning of the\n                      file until today date included.\n               AGENDA 99/99/99 means display from the today date until\n                      the end of file.\n./     ENDUP\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ANTPCHK": {"ttr": 1025, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x891\\x7f\\x00\\x891\\x7f\\x11I\\x00\\xdd\\x00\\xdd\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-11-13T00:00:00", "modifydate": "1989-11-13T11:49:00", "lines": 221, "newlines": 221, "modlines": 0, "user": "SYSPAJA"}, "text": "COVR     TITLE 'IEBANTP - CHECK OPERATION VALIDITY ROUTINE.'\nANTPCHK  START 0\n         SPACE 1\n* PURPOSE :    VALIDITY CHECK OF IEBANTP OPERATION REQUESTED AGAINST\n* ---------    ANY MAGNETIC TAPE OR 3480 DATA CARTRIDGE CONTENTS\n*              VIOLATION FROM AN UNAUTHORIZED USER.\n*      NOTES - VALIDITY CHECK IS SKIPPED BY SETTING 'CHCKSW' TO 'N'.\n*            - THE CHECK VALIDITY TABLES (ANTPCTB) ARE DYNAMICALLY\n*              LOADED BY THE ROUTINE.\n*            - THIS ROUTINE MAY BE USED BY OTHER PROGRAMS IF DESIRED,\n*              IT MAY CONTROL UP TO 9 REQUESTS.\n*\n* AUTHOR :     MOINIL P.A.\n* --------     COMPUTING CENTRE\n*              J.R.C. - ISPRA ESTABLISHMENT\n*              21020 ISPRA (VA), ITALY\n         SPACE 1\n*        VALIDITY CHECK CONTROL TABLES - MISCELLANEOUS DEFINITIONS\n         SPACE 1\nACCEPT   EQU   0                   ACCEPT ACCESS\nREJECT   EQU   1                   REJECT ACCESS\nREAD     EQU   2                   READ ONLY ACCESS\nUPDATE   EQU   3                   READ-WRITE ACCESS\nENDTB    EQU   255                 TABLE END MARKER\n         EJECT\n        $DEFREG\n        $XENT  BASE=R12\n         EJECT\n         XR    R10,R10             SET OK RC ---------------------- 00\n         CLI   CHCKSW,C'N'         BYPASS?\n         BE    EXIT                YES\n         L     R2,0(R1)            PARM-FIELD ADDRESS\n         LH    R1,0(R2)\n         LA    R3,2(R2)            POINT TO CONTROL(S) REQUESTED\n         USING CHREQ,R3\n         LTR   R1,R1\n         BNP   SCC04\n         CLI   CHCKNO,C'1'\n         BL    SCC04\n         CLI   CHCKNO,C'9'\n         BH    SCC04\n         XR    R8,R8\n         LA    R0,15\n         IC    R8,CHCKNO\n         NR    R8,R0\n         LR    R2,R8\n         MH    R2,=Y(CHCKTL)\n         LA    R2,1(R2)\n         CLR   R1,R2\n         BNE   SCC04\n         LA    R9,CHCKLV\n         DROP  R3\n         MVI   RQAU,0              CALLER\n         MVC   USERID,=CL8' '        USER-ID AND\n         MVC   GROUP,=CL8' '           GROUP\n        $EACM  RQUS                      REQUEST\n         CLC   USERID,=CL8' '\n         BNE   LDTBLS\n         CLC   GROUP,=CL8' '\n         BE    SCC08\nLDTBLS  BLDL   0,EPENTRY\n         LTR   R15,R15\n         BNZ   SCC12\n        LOAD   DE=EPNAME,LOADPT=TBADDR\n         L     R1,TBADDR\n         CLC   0(8,R1),=CL8'ANTPCTB'\n         BNE   SCC16\n         LA    R1,3*8(R1)\n         ST    R1,TBADDR\n        EXTRACT ATIOT,'S',FIELDS=(TIOT)\nVERIFY   BAS   R14,SCTBR\n         B     SCC28\n         AH    R9,=Y(CHCKTL)\n         BCT   R8,VERIFY\n         B     EXIT\nSCC36    LA    R10,36              UNKNOWN DEVICE ADDRESS --------- 36\n         B     EXIT\nSCC32    LA    R10,32              DD-NAME NOT FOUND -------------- 32\n         B     EXIT\nSCC28    LA    R10,28              ACCESS REJECTED ---------------- 28\n         B     EXIT\nSCC24    LA    R10,24              UNKNOWN UNIT-TYPE -------------- 24\n         B     EXIT\nSCC20    LA    R10,20              INVALID LEVEL ------------------ 20\n         B     EXIT\nSCC16    LA    R10,16              INVALID TABLE-ID --------------- 16\n         B     EXIT\nSCC12    LA    R10,12              NO CHECK TABLES ---------------- 12\n         B     LEAVE\nSCC08    LA    R10,8               NO USER-ID NOR GROUP ----------- 08\n         B     LEAVE\nSCC04    LA    R10,4               INVALID PARM-FIELD ------------- 04\n         B     LEAVE\nEXIT    DELETE DE=EPNAME\nLEAVE   $XRET  CC=(R10)\n         EJECT\n*        SCAN TABLES ROUTINE.\n*              R0-R4 = WORK REGISTER\n*              R9 = CONTROL FIELDS POINTER\n*              R14 = LINK REGISTER\n*                    RETURN +0 = REJECTED\n*                           +4 = ACCEPTED\n         SPACE 1\n         USING CHCKLV,R9\nSCTBR    CLI   CHCKLV,C'R'\n         BE    SCTBR0\n         CLI   CHCKLV,C'W'\n         BNE   SCC20\nSCTBR0   L     R3,TBADDR\nSCTBR1   CLC   CHCKUT(L'CHCKUT),0(R3)\n         BE    SCTBR10\n         LA    R3,8(R3)\n         CLI   0(R3),ENDTB\n         BNE   SCTBR1\n         B     SCC24\nSCTBR10  TM    4(R3),X'80'         IS IT POINTER TO SUB-TABLE?\n         BZ    SCTBR20             NO\n         L     R1,ATIOT            YES, TIOT ADDRESS\n         USING TIODSECT,R1\n         XR    R0,R0\nSCTBR11  CLC   TIOELNGH(4),=XL4'0' TIOT END?\n         BE    SCC32               YES, DD-NAME NOT FOUND\n         CLC   TIOEDDNM,CHCKDD\n         BE    SCTBR12\n         IC    R0,TIOELNGH         GET IN R0 DD ENTRY LENGTH\n         AR    R1,R0               R1 POINTS TO NEXT DD ENTRY\n         B     SCTBR11\nSCTBR12  ICM   R2,B'0111',TIOEFSRT GET UCB ADDRESS\n         DROP  R1\n         USING UCBOB,R2\n         MVC   DEVADD,UCBNAME      GET DEVICE ADDRESS (CUU)\n         DROP  R2\n         ICM   R1,B'1111',4(R3)    GET SUB-TABLE DEVICES ADDRESSES\n         LA    R1,0(R1)            CLEAR HIGH-ORDER BIT\nSCTBR13  CLI   0(R1),ENDTB\n         BE    SCC36               UNKNOWN DEVICE ADDRESS\n         CLC   DEVADD(L'DEVADD),0(R1)\n         BL    SCTBR14\n         BE    SCTBR15\n         CLI   3(R1),C' '\n         BE    SCTBR14\n         CLC   DEVADD(L'DEVADD),3(R1)\n         BNH   SCTBR15\nSCTBR14  LA    R1,10(R1)\n         B     SCTBR13\nSCTBR15  ICM   R2,B'1111',6(R1)    SEARCH SERIAL NUMBERS TABLE\n         B     SCTBR20+L'SCTBR20\nSCTBR20  ICM   R2,B'1111',4(R3)    SEARCH SERIAL NUMBERS TABLE\n         LA    R3,1(R2)            BUMP AND RETAIN GLOBAL DEFAULT\nSCTBR21  CLI   0(R3),ENDTB\n         BE    SCTBR40\n         CLC   CHCKVS(L'CHCKVS),0(R3)\n         BL    SCTBR22\n         BE    SCTBR30\n         CLI   6(R3),C' '\n         BE    SCTBR22\n         CLC   CHCKVS(L'CHCKVS),6(R3)\n         BNH   SCTBR30\nSCTBR22  LA    R3,16(R3)\n         B     SCTBR21\nSCTBR30  ICM   R2,B'1111',12(R3)   SEARCH USER-ID/GROUP ACCESS TABLE\n         LA    R4,1(R2)            BUMP AND RETAIN LOCAL DEFAULT\nSCTBR31  CLI   0(R4),ENDTB\n         BE    SCTBR40\n         CLI   0(R4),UPDATE\n         BE    SCTBR32\n         CLI   0(R4),READ\n         BNE   SCTBR33\nSCTBR32  LR    R0,R4\n         LA    R4,1(R4)\nSCTBR33  CLC   USERID(8),0(R4)\n         BE    SCTBR34\n         CLC   GROUP(8),0(R4)\n         BE    SCTBR34\n         LA    R4,8(R4)\n         B     SCTBR31\nSCTBR34  LR    R2,R0\nSCTBR40  CLI   0(R2),REJECT\n         BER   R14\n         CLI   CHCKLV,C'R'\n         BE    4(R14)\n         CLI   0(R2),READ\n         BNE   4(R14)\n         BR    R14\n         DROP  R9\n         EJECT\n*        CONSTANTS AND WORK-AREAS.\n*        -------------------------\n         SPACE 1\nATIOT    DC    A(*-*)\nTBADDR   DC    A(*-*)\nEPENTRY  DC    Y(1,58)\nEPNAME   DC    CL8'ANTPCTB'\n         DC    XL58'0'\nRQUS     DC    0F'0',BL1'00010000',AL3(0),AL4(RQAU)\nCHCKSW   DC    CL1'Y'              BYPASS SWITCH\nRQAU     DC    AL1(0)\nUSERID   DC    CL8' '\nGROUP    DC    CL8' '\nDEVADD   DC    CL3' '\n         SPACE 2\n        LTORG\n         SPACE 2\n*        CONTROLS REQUESTED - PARM-FIELD DESCRIPTION.\n*        --------------------------------------------\n         SPACE 1\nCHREQ    DSECT\nCHCKNO   DS    CL1                 NUMBER OF CONTROLS (1 UP TO 9)\n*        1 UP TO 9 REPEATED CONTROL FIELDS.\nCHCKLV   DS    CL1                 CHECK LEVEL (R OR W)\nCHCKUT   DS    CL4                 UNIT-TYPE\nCHCKVS   DS    CL6                 VOL. SER.\nCHCKDD   DS    CL8                 DD-NAME.\nCHCKTL   EQU   L'CHCKLV+L'CHCKUT+L'CHCKVS+L'CHCKDD\n         SPACE 2\n         PRINT NOGEN\nTIODSECT DSECT\n        IEFTIOT1\n        IEFUCBOB\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ANTPCMM": {"ttr": 1030, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x891\\x7f\\x00\\x891\\x7f\\t8\\x00I\\x00I\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-11-13T00:00:00", "modifydate": "1989-11-13T09:38:00", "lines": 73, "newlines": 73, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO\n&NAME   @E     &DUMMY\n&NAME    DC    AL1(ENDTB)\n         MEND\n         MACRO\n&NAME   @N     &A\n         LCLA  &I\n         LCLC  &Z\n         AIF   (N'&SYSLIST NE 0).A\n         AIF   ('&NAME' EQ '').D\n&NAME    DS    0CL8\n         AGO   .D\n.A       ANOP\n&Z       SETC  ' '\n         AIF   ('&NAME' EQ '').B\n&Z       SETC  '&NAME'\n.B       ANOP\n&I       SETA  1\n.C       ANOP\n&Z       DC    CL8'&SYSLIST(&I)'\n         AIF   (N'&SYSLIST EQ &I).D\n&Z       SETC  ' '\n&I       SETA  &I+1\n         AGO   .C\n.D       MEND\n         MACRO\n&NAME   @O     &A\n         AIF   (T'&A EQ 'O').OPM\n&NAME    DC    AL1(&A)\n         MEXIT\n.OPM     MNOTE 8,' OPTION MISSING *********************************** '\n         MEND\n         MACRO\n&NAME   @S     &A\n         AIF   ('&NAME' EQ '').LNM\n&NAME    DC    AL1(&A)\n         MEXIT\n.LNM     MNOTE 8,' LABEL NAME MISSING ******************************* '\n         MEND\n         MACRO\n&NAME   @ST    &A,&B\n         AIF   (N'&SYSLIST NE 2).INO\n         AIF   (T'&A EQ 'O').INO\n         AIF   (T'&B EQ 'O').INO\n         AIF   ('&A'(1,1) EQ '(').A\n&NAME    DC    CL3'&A',CL3' ',AL4(&B)\n         MEXIT\n.A       ANOP\n&NAME    DC    CL3'&A(1)',CL3'&A(2)',AL4(&B)\n         MEXIT\n.INO     MNOTE 8,' INVALID NUMBER OF OPERANDS *********************** '\n         MEND\n         MACRO\n&NAME   @T     &A,&B,&TYPE=\n         AIF   ('&TYPE' EQ 'ST').A\n&NAME    DC    CL4'&A',AL4(&B)\n         MEXIT\n.A       ANOP\n&NAME    DC    CL4'&A',AL4(X'80000000'+&B)\n         MEND\n         MACRO\n&NAME   @V     &A,&B\n         AIF   (N'&SYSLIST NE 2).INO\n         AIF   (T'&A EQ 'O').INO\n         AIF   (T'&B EQ 'O').INO\n         AIF   ('&A'(1,1) EQ '(').A\n&NAME    DC    CL6'&A',CL6' ',AL4(&B)\n         MEXIT\n.A       ANOP\n&NAME    DC    CL6'&A(1)',CL6'&A(2)',AL4(&B)\n         MEXIT\n.INO     MNOTE 8,' INVALID NUMBER OF OPERANDS *********************** '\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ANTPCTB": {"ttr": 1033, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x12/\\x00\\x90\\x12/\\x165\\x00\\x9a\\x00\\x9a\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-05-02T00:00:00", "modifydate": "1990-05-02T16:35:00", "lines": 154, "newlines": 154, "modlines": 0, "user": "SYSPAJA"}, "text": "CVRT     TITLE 'IEBANTP - CHECK VALIDITY ROUTINE TABLES.'\n         PRINT OFF\n         COPY  ANTPCMM\n         PRINT ON\n         SPACE 1\nANTPCTB  START 0\n         SPACE 1\n* TABLES ORGANIZATION : ACCESSED ONLY BY MODULE 'ANTPCHK'.\n* ---------------------\n*\n* THE MODULE STARTS WITH THE UNIT-TYPE TABLE :\n*             @T     UNIT-TYPE-NAME,VSN-TABLE\n*             @T     ...\n*             @T     UNIT-TYPE-NAME,SUB-TABLE,TYPE=ST\n*             @T     ...\n*             @E     ,   END TABLE MARKER\n*\n* SUB-TABLE ENTRY THEN POINTS TO A VOLUME-SERIAL-NUMBERS TABLE) :\n*   SUB-TABLE @ST    CUU,VSN-TABLE\n*             @ST    (CUU,CUU),VSN-TABLE\n*             @ST    ...\n*             @E     ,   END TABLE MARKER\n*\n* OR EACH UNIT-TYPE ENTRY IN THE PREVIOUS UNIT-TYPE TABLE POINTS\n* DIRECTLY TO A VOLUME-SERIAL-NUMBERS TABLE (VSN-TABLE) :\n*   VSN-TABLE @S     GLOBAL-DEFAULT-OPTION\n*             @V     VOL-SER-NUM,LIST-TABLE ------------------> SINGLE\n*             @V     (VOL-SER-NUM,VOL-SER-NUM),LIST-TABLE ----> RANGE\n*             @V     ...\n*             @E     ,   END TABLE MARKER\n*\n* EACH VOL-SER-NUM ENTRY IN THE PREVIOUS VOLUME-SERIAL-NUMBERS TABLE\n* POINTS IN TURN TO A USER-ID/GROUP-ACCESS TABLE (LIST-TABLE) :\n*  LIST-TABLE @S     LOCAL-DEFAULT-OPTION\n*             @O     ACCESS-OPTION\n*             @N     USER-ID,GROUP,...\n*             @N     ...\n*             @O     ACCESS-OPTION\n*             @N     USER-ID,GROUP,...\n*             @N     ...\n*             @E     ,   END TABLE MARKER\n*\n* AUTHOR :     MOINIL P.A.\n* --------     COMPUTING CENTRE\n*              J.R.C. - ISPRA ESTABLISHMENT\n*              21020 ISPRA (VA), ITALY\n         EJECT\n*        =============================\n* ------ VALIDITY CHECK CONTROL TABLES --------------------------------\n*        =============================\n         SPACE 1\n*        MISCELLANEOUS DEFINITIONS\n*        -------------------------\n         SPACE 1\n*                             GLOBAL/LOCAL-DEFAULT-OPTION :\nACCEPT   EQU   0                   ACCEPT OPTION\nREJECT   EQU   1                   REJECT OPTION\n*                             ACCESS-OPTION :\nREAD     EQU   2                   READ ONLY OPTION\nUPDATE   EQU   3                   READ-WRITE OPTION\n         SPACE 1\nENDTB    EQU   255                 TABLE END MARKER\n         SPACE 1\n         DC    CL8'ANTPCTB'        IDENTIFIER.\n         DC    CL8'&SYSDATE',C'-(' ASSEMBLY DATE (MM/DD/YY).\n         DC    CL5'&SYSTIME',C')'  ASSEMBLY TIME (HH.MM).\n         SPACE 1\n         PRINT NOGEN\n         EJECT\n*---------------------------------------------------------------------*\n*        UNIT NAMES TABLE.                                            *\n*---------------------------------------------------------------------*\n         SPACE 1\n        @T     TAPE,TBTAPE\n        @T     3480,TB3480,TYPE=ST\n        @E     ,                   END MARKER\n         SPACE 1\n*---------------------------------------------------------------------*\n*        PHYSICAL UNIT ADDRESSES SUB-TABLES.                          *\n*---------------------------------------------------------------------*\n         SPACE 1\nTB3480  @ST    (300,307),ROBOT\n        @ST    (308,309),CART\n        @ST    (30A,30F),CART\n        @ST    (320,329),OPTIC\n        @ST    (32A,32F),OPTIC\n        @E     ,                   END MARKER\n         EJECT\n*---------------------------------------------------------------------*\n*        VOLUME SERIAL NUMBERS TABLES.                                *\n*---------------------------------------------------------------------*\n         SPACE 1\nTBTAPE  @S     ACCEPT              GLOBAL DEFAULT OPTION\n        @V     (EU9017,EU9018),T1  SYSTEM\n        @V     EU9019,T2           QED PRODUCT\n        @V     (EU9020,EU9029),T1  SYSTEM\n        @V     (EU9030,EU9036),T1  ACCOUNT CURRENT YEAR\n        @V     (EU9037,EU9050),T1  ACCOUNT PREVIOUS YEARS\n        @V     (EU9051,EU9062),T1  SYSTEM\n        @E     ,                   END MARKER\n         SPACE 1\nROBOT   @S     REJECT              GLOBAL DEFAULT OPTION\n        @V     (EU0000,EU0499),R1  DMS - PRIMARY ARCHIVE POOL\n        @V     (EU1000,EU1499),R1  DMS - COPY ARCHIVE POOL\n        @V     (EU2000,EU2199),R1  DMS - PRIMARY BACKUP POOL\n        @V     (EU2500,EU2699),R1  DMS - COPY BACKUP POOL\n        @V     (EU5800,EU5819),R1  DUMP - SYSTEM\n        @V     (EU5820,EU5979),R1  DUMP - ADABAS\n        @V     (EU5980,EU5997),R1  TEMPORARY TESTS\n        @V     (EU5998,EU5999),R2  OTHER TEMPORARY TESTS\n        @V     (100350,100354),R1  DUMP - SPECIAL ADABAS\n        @E     ,                   END MARKER\n         SPACE 1\nCART    @S     ACCEPT              GLOBAL DEFAULT OPTION\n        @E     ,                   END MARKER\n         SPACE 1\nOPTIC   @S     REJECT              GLOBAL DEFAULT OPTION\n        @V     ($,999999),O1       SYSTEM\n        @E     ,                   END MARKER\n         EJECT\n*---------------------------------------------------------------------*\n*        USER-ID/GROUP ACCESS TABLES                                  *\n*---------------------------------------------------------------------*\n         SPACE 1\nT1      @S     REJECT              LOCAL DEFAULT OPTION\n        @O     UPDATE\n        @N     SYSSP1\n        @O     READ\n        @N     SYS1\n        @E     ,                   END MARKER\n         SPACE 1\nT2      @S     REJECT              LOCAL DEFAULT OPTION\n        @O     UPDATE\n        @N     SYSUS1\n        @O     READ\n        @N     SYS1\n        @E     ,                   END MARKER\n         SPACE 1\nR1      @S     REJECT              LOCAL DEFAULT OPTION\n        @O     UPDATE\n        @N     DMSJOBS\n        @E     ,                   END MARKER\n         SPACE 1\nR2      @S     REJECT              LOCAL DEFAULT OPTION\n        @O     UPDATE\n        @N     DMSJOBS,SYSSP1\n        @E     ,                   END MARKER\n         SPACE 1\nO1      @S     REJECT              LOCAL DEFAULT OPTION\n        @O     UPDATE\n        @N     SYS1\n        @E     ,                   END MARKER\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ARITH": {"ttr": 1037, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x95\\x07_\\x00\\x95\\x07_\\x12 \\n\\xc7\\n\\xc7\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1995-03-16T00:00:00", "modifydate": "1995-03-16T12:20:00", "lines": 2759, "newlines": 2759, "modlines": 0, "user": "SYSPAJA"}, "text": "ARTH     TITLE '--- TSO FULL-SCREEN ARITHMETIC COMMAND ---'\n         PRINT OFF\n* Here follows the Assembly SYSPARM(...) options process which allows\n*        you to select :\n*        1. NONE or omitted = no list of macros development\n*           FULL = list all macros development\n*        2. US or omitted = edit numbers as usual in USA\n*           EU = edit numbers as European like it\n*        How to define options : i.e - SYSPARM(FULL)\n*                                      SYSPARM(,EU)\n*        If you want add another selection, you can easily do it\n*        adjusting below the statements marked \"<===\", define the new\n*        OPT(n) default, and supply the new option coding just before\n*        the comment card marked \"---> Add option(s)\".\n         GBLC  &EULST,&EUEDN                                  <===\n         LCLA  &CN,&CT,&LN,&MX,&SB,&ST\n         LCLC  &OPT(2)                                        <===\n&MX      SETA  2                                              <===\n&OPT(1)  SETC  'NONE'\n&OPT(2)  SETC  'US'\n&CN      SETA  K'&SYSPARM\n         AIF   (K'&SYSPARM EQ 0).SP99\n&CT      SETA  1\n&SB      SETA  1\n&ST      SETA  &CT\n.SP1     AIF   ('&SYSPARM'(&CT,1) EQ ',').SP2\n&CT      SETA  &CT+1\n         AIF   (&CT LE &CN).SP1\n.SP2     ANOP\n&LN      SETA  &CT-&ST\n         AIF   (&LN EQ 0).SP3\n&OPT(&SB) SETC '&SYSPARM'(&ST,&LN)\n.SP3     ANOP\n&SB      SETA  &SB+1\n         AIF   (&SB GT &MX).SP99\n&CT      SETA  &CT+1\n         AIF   (&CT GT &CN).SP99\n&ST      SETA  &CT\n         AGO   .SP1\n.SP99    ANOP\n&EULST   SETC  'GEN'\n         AIF   ('&OPT(1)' EQ 'FULL').SL1\n&EULST   SETC  'NOGEN'\n.SL1     ANOP\n&EUEDN   SETC  'EUROPE'\n         AIF   ('&OPT(2)' EQ 'EU').SL99\n&EUEDN   SETC  'USA'\n.SL99    ANOP\n* ---> Add option(s)\n         MACRO\n&LABEL   #GO   &NAME,&AR=I\n         AIF   ('&NAME' NE '').A\n         MNOTE 8,'--- NAME of routine missing (it is mandatory) ---'\n         AGO   .MEND\n.A       AIF   ('&AR' EQ 'D').B\n&LABEL   L     R15,=A(&NAME)\n         AGO   .C\n.B       ANOP\n&LABEL   L     R15,&NAME\n.C       BASR  R14,R15\n.MEND    MEND\n         PRINT ON\n         SPACE 1\nARITH    START 0\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n*    Name :    ARITH (Alias : AR)                                     *\n*                                                                     *\n*    Author :  Ted BESTANI                                            *\n*                                                                     *\n*    Purpose : This command allows TSO users to enter DO decimal and  *\n*              hex arithmetic on a 3270 terminal in full-screen mode. *\n*                                                                     *\n*    Attributes : Non-reusable                                        *\n*                                                                     *\n*    Requirements : ARITH requires that VTAM or TCAM support the      *\n*              FULL-SCREEN option (macros used : TGET/TPUT).          *\n*              It is designed for 3278-2 terminals. It will work on   *\n*              bigger toobs, but it won't use the entire screen.      *\n*                                                                     *\n*    Origin :  Extracted from tape CBT 93 AUG, file 173.              *\n*              Updates : 1. use of FSRTN routine (FULL-SCREEN).       *\n*                        2. added ESPIE to handle interrupt 0C9.      *\n*                   by : MOINIL P.A.                                  *\n*                        Computing Centre (TP 361)                    *\n*                        J.R.C. - Ispra Establishment                 *\n*                        21020 Ispra (VA), Italy                      *\n*                                                                     *\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n         SPACE 1\n         PRINT &EULST\n        $DEFREG\n         EJECT\n        $XENT  BASE=(R12)\n         LM    R10,R11,=A(WORKDBLW,WORKDBLW+4*1024)\n         USING WORKDBLW,R10,R11\n*        --> CHECK IF WE ARE ENTERED AS TSO COMMAND\n         LR    R2,R1               GET ENTRY R1\n        EXTRACT ATIOT,'S',FIELDS=(TIOT,TSO,PSB)\n*        Results : BATCH-exec       TSO-background   TSO-foreground\n*                +----------------+----------------+----------------+\n*          APSCB +     0          +     a.PSCB     +     a.PSCB     +\n*           ATSO +     a.Flag     +     a.Flag     +     a.Flag     +\n*           Flag +     X'00'      +     X'00'      +     x'80'      +\n*                +----------------+----------------+----------------+\n*        Initial R1 -> a.CPPL (IKJCPPL) if TSO-command\n*                   -> a.Comm. Area (IKJEBECA) if TSO-subcommmand\n*                   -> a.Parameters List in all other cases\n         L     R1,ATSO             TSO-FLAG ADDRESS\n         TM    0(R1),X'80'         TSO FOREGROUND?\n         BZ    ERREX               NO, BACKGROUND, FLUSH\n         L     R1,APSCB            YES, GET PSCB ADDRESS\n         LTR   R1,R1               TSO RUNNING?\n         BZ    ERREX               NO, WHAT'S THAT? FLUSH\n         USING CPPL,R2\n         USING PSCB,R1\n         CLC   PSCBUPT,CPPLUPT     CPPL+4 = UPT ADDRESS?\n         BNE   *+L'*+10            NO\n         DROP  R1\n         CLC   APSCB(L'APSCB),CPPLPSCB CPPL+8 = PSCB ADDRESS?\n         BE    INITOK              YES, TSO COMMAND\n         LR    R1,R2\n         USING IKJEBECA,R1\n         L     R2,CAPTTMP          CPPL ADDRESS\n         DROP  R1\n         CLC   APSCB(L'APSCB),CPPLPSCB CPPL+8 = PSCB ADDRESS?\n         BE    INITOK              YES, TSO SUB-COMMAND\n         DROP  R2\nERREX   WTO    ' -> Only TSO foreground command allowed',              X\n               ROUTCDE=11,DESC=7\n         B     SRC16\nINITOK  @FSI   FSBFSZ,MF=(E,FSPARM) INITIALIZE FULL-SCREEN\n         LTR   R15,R15\n         BZ    INFSOK\n         CVD   R15,WORKDBLW\n         MVC   MSG1F1,=XL4'40202120'\n         ED    MSG1F1,WORKDBLW+L'WORKDBLW-2\n        TPUT   MSG1,L'MSG1         PUT OUT ERROR MESSAGE\n         B     SRC16\nINFSOK   L     R2,ATIOT            SEARCH DD IF SNAP AVAILABLE\n         USING TIODSECT,R2\nSCSNAP   CLC   TIOELNGH(4),=F'0'\n         BE    MARITH\n         CLC   TIOEDDNM(L'TIOEDDNM),=CL8'SYSSNAP '\n         BNE   *+L'*+4\n         OI    OPTFS,FSSNAP        SET USER WANT SNAP SCREEN INPUT\n         XR    R1,R1\n         IC    R1,TIOELNGH\n         ALR   R2,R1\n         B     SCSNAP\n         DROP  R2\n*        --> ARITHMETIC main process.\nMARITH   MVC   INPUT,=CL50' '      INITIALIZE INPUT FIELDS\nDRBYPASS MVC   SC1LN24,ENDLNE01    NORMAL END OF MENU MSG\n        $FS    SF=NORMAL,MF=(I,SC1LN03) SET NORMAL INPUT\n*        --> DISPLAY MENU SCREEN.\nDRBPLOOP MVC   SC1LN04,INPUT+0     MOVE OPTION REQUESTED\nDRBRSHOW LM    R0,R2,=A(SCREEN1,LSCREEN1,RSCRT1)\n         STM   R0,R2,ASCRIPTR      STORE PTR'S\n        #GO    FULLSCR             GO DO DEMO SCREEN WORK\n         B     *+L'*(R15)          HOW COMPLETE?\n         B     DRBPANAL            0 - RETURN TO MENU - WILD GOTO\n         B     DRERROR             4 - ERROR\n         LTR   R1,R1               8 - DID USER TYPE IN MENU OPTION?\n         BZ    DRBRSHOW            NO, GO PAINT MENU AGAIN\n         BM    DRCLEAR             YES, BUT GO CLEAR AND END\nDRBPANAL CLI   INPUT+0,C' '        NO OPTION?\n         BE    DRBYPASS            YES\n         CLI   INPUT+0,C'0'        OR, END?\n         BE    DRCLEAR             YES, GO HOME ...\n         CLI   INPUT+0,C'H'        OR, HELP?\n         BNE   DRBTO1              NO, TRY NEXT OPTION\nDRHINIT $FS    SF=NORMAL,MF=(I,SCHLN24I) SET NORMAL INPUT\n         MVI   INPUT+0,C' '        RESET INPUT FIELD\nDRHSHOW  MVC   SCHLN24R,INPUT+0\n         LM    R0,R2,=A(SCREENH,LSCREENH,RSCRTH)\n         STM   R0,R2,ASCRIPTR      STORE PTR'S\n        #GO    FULLSCR             GO DO DEMO SCREEN WORK\n         B     *+L'*(R15)          HOW COMPLETE?\n         B     DRHINIT             0 - RESHOW\n         B     DRERROR             4 - ERROR\n         LTR   R1,R1               8 - DID USER TYPE IN MENU OPTION?\n         BZ    DRHINIT             NO, RESHOW\n         BM    DRHQUIT             YES, RETURN TO OPTION MENU\n        $FS    SF=(INT),MF=(I,SCHLN24I) SET ERROR INPUT\n         B     DRHSHOW\nDRHQUIT  MVI   INPUT+0,C' '        RESET OPTION MENU\n         B     DRBYPASS            AND BACK TO MENU\nDRBTO1   CLI   INPUT+0,C'1'        CVD?\n         BNE   DRBTO2              NO, TRY NEXT OPTION\n        #GO    RTN$CVD             YES, GO PROCESS\n         B     DRFSANAL\nDRBTO2   CLI   INPUT+0,C'2'        CVB?\n         BNE   DRBTO3              NO, TRY NEXT OPTION\n        #GO    RTN$CVB             YES, GO PROCESS\n         B     DRFSANAL\nDRBTO3   CLI   INPUT+0,C'3'        ADD?\n         BNE   DRBTO4              NO, TRY NEXT OPTION\n        #GO    RTN$ADD             YES, GO PROCESS\n         B     DRFSANAL\nDRBTO4   CLI   INPUT+0,C'4'        SUB?\n         BNE   DRBTO5              NO, TRY NEXT OPTION\n        #GO    RTN$SUB             YES, GO PROCESS\n         B     DRFSANAL\nDRBTO5   CLI   INPUT+0,C'5'        MUL?\n         BNE   DRBTO6              NO, TRY NEXT OPTION\n        #GO    RTN$MUL             YES, GO PROCESS\n         B     DRFSANAL\nDRBTO6   CLI   INPUT+0,C'6'        DIV?\n         BNE   DRBTO7              NO, TRY NEXT OPTION\n        #GO    RTN$DIV             YES, GO PROCESS\n         B     DRFSANAL\nDRBTO7   CLI   INPUT+0,C'7'        OPTION 7?\n         BNE   DRBTO8              NO, TRY NEXT OPTION\n        #GO    RTN$SCR             YES, GO PROCESS\n         B     DRFSANAL\nDRBTO8   CLI   INPUT+0,C'8'        OPTION 8?\n         BE    DRNOTUSE            YES\n         CLI   INPUT+0,C'9'        OPTION 9?\n         BE    DRNOTUSE            YES\n         MVC   SC1LN24,ENDLNE02    MOVE END LINE\n         B     DRBSTIE             GIVE IT ANOTHER TRY\nDRNOTUSE MVC   SC1LN24,ENDLNE03    MOVE END LINE\nDRBSTIE $FS    SF=(INT),MF=(I,SC1LN03) SET ERROR INPUT\n         B     DRBPLOOP            GIVE IT ANOTHER TRY\nDRFSANAL B     *+L'*(R15)          HOW COMPLETE?\n         B     DRBPANAL            0 - RETURN TO MENU - WILD GOTO\n         B     DRERROR             4 - ERROR\n         B     DRBYPASS            8 - GO PUT OUT MENU AGAIN\nDRERROR  CVD   R15,WORKDBLW\n         MVC   MSG2F2,=XL4'40202120'\n         ED    MSG2F2,WORKDBLW+L'WORKDBLW-2\n         XR    R0,R0\n         IC    R0,OPTFS\n         STC   R0,MSG2F1+1\n         SRL   R0,4\n         STC   R0,MSG2F1\n         NC    MSG2F1,=XL2'0F0F'\n         TR    MSG2F1,TRHEXCHR\n         LA    R0,L'MSG2\n         STH   R0,ERRMSL\n         LA    R0,MSG2\n         ST    R0,ERRMSA\nDRCLEAR  MVI   OPTFS,FSEXIT        EXIT FULL-SCREEN MODE\n        @FS    OPTFS,MF=(E,FSPARM)\n         LR    R2,R15              RETAIN RETURN CODE\n         XR    R0,R0\n         ICM   R0,B'0011',ERRMSL\n         BZ    NOMSGE\n         L     R1,ERRMSA\n        TPUT   (1),(0)             PUT OUT ERROR MESSAGE\nNOMSGE   LTR   R15,R2\n         BZ    QUIT\n         CVD   R15,WORKDBLW\n         MVC   MSG2F2,=XL4'40202120'\n         ED    MSG2F2,WORKDBLW+L'WORKDBLW-2\n         XR    R0,R0\n         IC    R0,OPTFS\n         STC   R0,MSG2F1+1\n         SRL   R0,4\n         STC   R0,MSG2F1\n         NC    MSG2F1,=XL2'0F0F'\n         TR    MSG2F1,TRHEXCHR\n        TPUT   MSG2,L'MSG2\nSRC16    LA    R15,16              SET RC=16\nQUIT    $XRET  CC=(R15)\n         SPACE 1\n        LTORG\n         SPACE 1\nSCREEN1  $FS   CC=EW,WCC=(KBR,RMDT),SBA=(1,1),RA=(1,1,00),MF=L\n         $FS   SBA=(1,1),SF=(SKIP,INT),MF=L\n         $FS   SBA=(1,19),MF=L\n         $FS   TEXT='T S O   A R I T H M E T I C   C O M M A N D',MF=L\n         $FS   SBA=(2,1),RA=(3,1,-),MF=L\n         $FS   SBA=(3,80),MF=L\nSC1LN03  $FS   SF=NORMAL,MF=L\nSC1LN04  $FS   TEXT=(' ',1),MF=L\n         $FS   SF=(SKIP,INT),TEXT='<====',MF=L\n         $FS   SF=(SKIP),TEXT='Enter',MF=L\n         $FS   SF=(SKIP,INT),TEXT='option',MF=L\n         $FS   SF=(SKIP),TEXT='desired from menu below',MF=L\n         $FS   SBA=(5,8),TEXT='(or you may use the',MF=L\n         $FS   SF=(SKIP,INT),TEXT='PF-keys 1-9',MF=L\n         $FS   SF=(SKIP),MF=L\n         $FS   TEXT='to select the corresponding option)',MF=L\n         $FS   SF=(SKIP,INT),MF=L\n         $FS   SBA=(7,1),RA=(8,1,-),MF=L\n         $FS   SBA=(9,1),TEXT='H - HELP',MF=L\n         $FS   SF=(SKIP),TEXT='(short write-up)',MF=L\n         $FS   SBA=(10,80),SF=(SKIP,INT),TEXT='0 - END',MF=L\n         $FS   SF=(SKIP),TEXT='the Arithmetic command',MF=L\n         $FS   SBA=(11,40),SF=(SKIP,INT),TEXT='5',MF=L\n         $FS   SF=(SKIP),TEXT='- Multiplication',MF=L\n         $FS   SBA=(12,80),SF=(SKIP,INT),TEXT='1',MF=L\n         $FS   SF=(SKIP),TEXT='- Convert Hex to Decimal',MF=L\n         $FS   SBA=(13,40),SF=(SKIP,INT),TEXT='6',MF=L\n         $FS   SF=(SKIP),TEXT='- Division',MF=L\n         $FS   SBA=(14,80),SF=(SKIP,INT),TEXT='2',MF=L\n         $FS   SF=(SKIP),TEXT='- Convert Decimal to Hex',MF=L\n         $FS   SBA=(15,40),SF=(SKIP,INT),TEXT='7',MF=L\n         $FS   SF=(SKIP),TEXT='- Convert 3270 Buffer Addresses',MF=L\n         $FS   SBA=(16,80),SF=(SKIP,INT),TEXT='3',MF=L\n         $FS   SF=(SKIP),TEXT='- Addition',MF=L\n         $FS   SBA=(17,40),SF=(SKIP,INT),TEXT='8',MF=L\n         $FS   SF=(SKIP),TEXT='- \"not in use\"',MF=L\n         $FS   SBA=(18,80),SF=(SKIP,INT),TEXT='4',MF=L\n         $FS   SF=(SKIP),TEXT='- Subtraction',MF=L\n         $FS   SBA=(19,40),SF=(SKIP,INT),TEXT='9',MF=L\n         $FS   SF=(SKIP),TEXT='- \"not in use\"',MF=L\n         $FS   SBA=(20,80),SF=(SKIP,INT),MF=L\n         $FS   TEXT='Note :',MF=L\n         $FS   SF=(SKIP),TEXT='To',MF=L\n         $FS   SF=(SKIP,INT),TEXT='terminate,',MF=L\n         $FS   SF=(SKIP),TEXT='you may also use any one of the',MF=L\n         $FS   SF=(SKIP,INT),TEXT='PA1-PA2-PA3',MF=L\n         $FS   SF=(SKIP),TEXT='keys.',MF=L\n         $FS   SBA=(23,80),MF=L\nSC1LN24  $FS   TEXT=(' ',88),MF=L\nSC1CSRP  $FS   SBA=(4,1),SF=(IC),MF=L\nLSCREEN1 EQU   *-SCREEN1\n         SPACE 1\n         DROP  R12\n         EJECT\n*------> READ \"SCREEN1\" PROCESS ROUTINE.\n*        AT EXIT : R1=INPUT TRUE LENGTH AND R3=INPUT SCAN LENGTH.\n         SPACE 1\nRSCRT1  $XENT  BASE=(R9)\n         XR    R2,R2               INITIAL COUNT\nR1LOOP  @FSR   ,                   GET REPLY TEXT\n         LTR   R15,R15             NO MORE FIELDS MODIFIED?\n         BNZ   R1PRCD              NO\n         L     R1,4(R13)           YES, END, GET PREVIOUS SAVE AREA\n         ST    R2,24(R1)           PASS BACK COUNT IN R1\n         LA    R2,1                AND INPUT SCAN LENGTH IN R3\n         ST    R2,32(R1)\n         XR    R15,R15             EXIT\n        $XRET  CC=(R15)\nR1PRCD   CLC   SC1CSF1,0(R15)\n         BNE   R1LOOP              UNEXPECTED (CHECK SCREEN IMAGE)\n         LTR   R1,R1\n         BZ    R1FC1               FIELD CLEARED (CANC FC)\n         CH    R1,=H'1'\n         BNE   R1LOOP              UNEXPECTED (CHECK SCREEN IMAGE)\n         MVI   INPUT+0,C' '        FOR UPPERCASE\n         OC    INPUT+0(1),3(R15)   COPY OPTION\n         B     R1BF1\nR1FC1    MVI   INPUT+0,C' '        OPTION CLEARED\nR1BF1    LA    R2,1(R2)            BUMP COUNT\n         B     R1LOOP\nSC1CSF1  $FS   SBA=(4,1),MF=L\n         SPACE 1\n        LTORG\n         SPACE 1\n         DROP  R9\n         EJECT\nSCREENH  $FS   CC=EW,WCC=(KBR,RMDT),SBA=(1,1),RA=(1,1,00),MF=L\n         $FS   SBA=(1,1),SF=(SKIP,INT),MF=L\n         $FS   SBA=(1,19),MF=L\n         $FS   TEXT='T S O   A R I T H M E T I C   C O M M A N D',MF=L\n         $FS   SBA=(2,1),RA=(3,1,-),MF=L\n         $FS   TEXT='Function :',MF=L\n         $FS   SF=(SKIP),TEXT='To do',MF=L\n         $FS   SF=(SKIP,INT),TEXT='HEX',MF=L\n         $FS   SF=(SKIP),TEXT='and',MF=L\n         $FS   SF=(SKIP,INT),TEXT='DECIMAL',MF=L\n         $FS   SF=(SKIP),TEXT='integer arithmetic on',MF=L\n         $FS   SF=(SKIP,INT),TEXT='3278/9 CRT',MF=L\n         $FS   SF=(SKIP),TEXT='terminals in',MF=L\n         $FS   SBA=(4,12),TEXT='full-screen mode.',MF=L\n         $FS   SBA=(5,2),RA=(5,80,-),MF=L\n         $FS   SF=(SKIP,INT),TEXT='Syntax :   ARITH',MF=L\n         $FS   SF=(SKIP),TEXT='- Alias :',MF=L\n         $FS   SF=(SKIP,INT),TEXT='AR',MF=L\n         $FS   SBA=(7,12),TEXT='Description :',MF=L\n         $FS   SF=(SKIP),MF=L\n         $FS   TEXT='The main goal of this command is to do',MF=L\n         $FS   SF=(SKIP,INT),TEXT='HEX',MF=L\n         $FS   SF=(SKIP),TEXT='and',MF=L\n         $FS   SF=(SKIP,INT),TEXT='DECIMAL',MF=L\n         $FS   SBA=(8,25),SF=(SKIP),MF=L\n         $FS   TEXT='integer arithmetic in full-screen mode on',MF=L\n         $FS   SF=(SKIP,INT),TEXT='3278/9 CRT',MF=L\n         $FS   SBA=(9,25),SF=(SKIP),TEXT='terminals. ',MF=L\n         $FS   TEXT='The command is menu driven.',MF=L\n         $FS   SBA=(10,12),TEXT='In addition',MF=L\n         $FS   SF=(SKIP,INT),TEXT='HEX',MF=L\n         $FS   SF=(SKIP),TEXT='and',MF=L\n         $FS   SF=(SKIP,INT),TEXT='DECIMAL',MF=L\n         $FS   SF=(SKIP),TEXT='arithmetic, an',MF=L\n         $FS   SF=(SKIP,INT),TEXT='option',MF=L\n         $FS   SF=(SKIP),TEXT='is available to do',MF=L\n         $FS   SBA=(11,25),SF=(SKIP,INT),TEXT='HEX',MF=L\n         $FS   SF=(SKIP),TEXT='to',MF=L\n         $FS   SF=(SKIP,INT),TEXT='DECIMAL',MF=L\n         $FS   SF=(SKIP),TEXT='and',MF=L\n         $FS   SF=(SKIP,INT),TEXT='DECIMAL',MF=L\n         $FS   SF=(SKIP),TEXT='to',MF=L\n         $FS   SF=(SKIP,INT),TEXT='HEX',MF=L\n         $FS   SF=(SKIP),TEXT='conversions.',MF=L\n         $FS   SBA=(12,11),SF=(SKIP,INT),TEXT='Another option',MF=L\n         $FS   SF=(SKIP),TEXT='gives the user ',MF=L\n         $FS   TEXT='ability to convert',MF=L\n         $FS   SF=(SKIP,INT),TEXT='3270 Screen Buffer',MF=L\n         $FS   SBA=(13,25),TEXT='Addresses',MF=L\n         $FS   SF=(SKIP),TEXT='to',MF=L\n         $FS   SF=(SKIP,INT),TEXT='Row/Column Addresses,',MF=L\n         $FS   SF=(SKIP),TEXT='and vice versa.',MF=L\n         $FS   SBA=(14,12),TEXT='To get back to the menu ',MF=L\n         $FS   TEXT='screen from any of the option screens,',MF=L\n         $FS   SBA=(15,26),TEXT='simply press the',MF=L\n         $FS   SF=(SKIP,INT),TEXT='PA1 (ATTN)',MF=L\n         $FS   SF=(SKIP),TEXT='key. Another way of doing',MF=L\n         $FS   SBA=(16,26),TEXT='this is to enter',MF=L\n         $FS   SF=(SKIP,INT),TEXT='=X',MF=L\n         $FS   SF=(SKIP),TEXT='and press',MF=L\n         $FS   SF=(SKIP,INT),TEXT='ENTER.',MF=L\n         $FS   SF=(SKIP),TEXT='In fact, you can',MF=L\n         $FS   SBA=(17,26),TEXT='get around in',MF=L\n         $FS   SF=(SKIP,INT),TEXT='ARITH',MF=L\n         $FS   SF=(SKIP),TEXT='if you can remember the',MF=L\n         $FS   SF=(SKIP,INT),TEXT='option',MF=L\n         $FS   SBA=(18,26),TEXT='numbers',MF=L\n         $FS   SF=(SKIP),TEXT='by entering an',MF=L\n         $FS   SF=(SKIP,INT),TEXT='=',MF=L\n         $FS   SF=(SKIP),TEXT='sign followed by the',MF=L\n         $FS   SF=(SKIP,INT),TEXT='option',MF=L\n         $FS   SBA=(19,26),TEXT='number',MF=L\n         $FS   SF=(SKIP),TEXT='and pressing',MF=L\n         $FS   SF=(SKIP,INT),TEXT='ENTER,',MF=L\n         $FS   SF=(SKIP),TEXT='but',MF=L\n         $FS   SF=(SKIP,INT),TEXT='=0',MF=L\n         $FS   SF=(SKIP),TEXT='will return to',MF=L\n         $FS   SF=(SKIP,INT),TEXT='TSO.',MF=L\n         $FS   SBA=(20,11),SF=(SKIP),TEXT='Also',MF=L\n         $FS   SF=(SKIP,INT),TEXT='PF-keys',MF=L\n         $FS   SF=(SKIP),TEXT='for corresponding',MF=L\n         $FS   SF=(SKIP,INT),TEXT='options (1-9)',MF=L\n         $FS   SF=(SKIP),TEXT='are availables.',MF=L\n         $FS   SBA=(21,2),RA=(21,80,-),MF=L\n         $FS   SF=(SKIP,INT),TEXT='Operands :',MF=L\n         $FS   SF=(SKIP),MF=L\n         $FS   TEXT='None, other than as specified above.',MF=L\n         $FS   SBA=(22,80),SF=(SKIP,INT),MF=L\n         $FS   RA=(24,1,-),MF=L\n         $FS   TEXT='====>',MF=L\nSCHLN24I $FS   SF=NORMAL,MF=L\nSCHLN24R $FS   TEXT=(' ',1),MF=L\n         $FS   SF=(SKIP,INT),TEXT='<====',MF=L\n         $FS   SF=(SKIP),TEXT='To',MF=L\n         $FS   SF=(SKIP,INT),TEXT='return',MF=L\n         $FS   SF=(SKIP),TEXT='to menu press',MF=L\n         $FS   SF=(SKIP,INT),TEXT='PA1',MF=L\n         $FS   SF=(SKIP),TEXT='key.',MF=L\n         $FS   SBA=(24,7),SF=(IC),MF=L\nLSCREENH EQU   *-SCREENH\n         EJECT\n*------> READ \"SCREENH\" PROCESS ROUTINE.\n*        AT EXIT : R1=INPUT TRUE LENGTH AND R3=INPUT SCAN LENGTH.\n         SPACE 1\nRSCRTH  $XENT  BASE=(R9)\n         XR    R2,R2               INITIAL COUNT\nRHLOOP  @FSR   ,                   GET REPLY TEXT\n         LTR   R15,R15             NO MORE FIELDS MODIFIED?\n         BNZ   RHPRCD              NO\n         L     R1,4(R13)           YES, END, GET PREVIOUS SAVE AREA\n         ST    R2,24(R1)           PASS BACK COUNT IN R1\n         LA    R2,1                AND INPUT SCAN LENGTH IN R3\n         ST    R2,32(R1)\n         XR    R15,R15             EXIT\n        $XRET  CC=(R15)\nRHPRCD   CLC   SCHCSF1,0(R15)\n         BNE   RHLOOP              UNEXPECTED (CHECK SCREEN IMAGE)\n         LTR   R1,R1\n         BZ    RHFC1               FIELD CLEARED (CANC FC)\n         CH    R1,=H'1'\n         BNE   RHLOOP              UNEXPECTED (CHECK SCREEN IMAGE)\n         MVI   INPUT+0,C' '        FOR UPPERCASE\n         OC    INPUT+0(1),3(R15)   COPY OPTION\n         B     RHBF1\nRHFC1    MVI   INPUT+0,C' '        OPTION CLEARED\nRHBF1    LA    R2,1(R2)            BUMP COUNT\n         B     RHLOOP\nSCHCSF1  $FS   SBA=(24,7),MF=L\n         SPACE 1\n        LTORG\n         SPACE 1\n         DROP  R9\n         EJECT\n*------> THIS ROUTINE PROCESSES THE CONVERT-TO-DECIMAL SCREEN.\n*        AT EXIT : R15 = 0, 4 OR 8.\n         SPACE 1\nRTN$CVD $XENT  BASE=(R9)\n         MVC   INPUT+0(8),=CL50' ' CLEAR INPUT\n         MVC   SC2LN10,=CL50' '     \" \"  OUTPUT\nRCVDINIT MVC   SC2LN24,ENDLNE04    PUT OUT BEGINNING MESSAGE\n        $FS    SF=NORMAL,MF=(I,SC2LN07) SET NORMAL INPUT\nRCVDLOOP MVC   SC2LN08,INPUT+0     PUT DATA INTO SCREEN\n         LM    R0,R2,=A(SCREEN2,LSCREEN2,RSCRT2)\n         STM   R0,R2,ASCRIPTR      STORE PTR'S\n        #GO    FULLSCR             GO DO DEMO SCREEN WORK\n         B     *+L'*(R15)          HOW COMPLETE?\n         B     R$CVDX              0 - RETURN TO MENU - WILD GOTO\n         B     R$CVDX              4 - ERROR\n         LTR   R1,R1               8 - DID USER TYPE IN?\n         BZ    RCVDLOOP            NO, PUT SCREEN BACK OUT\n         BP    *+L'*+8             YES, GO PROCESS\n         MVI   INPUT+0,C' '        ELSE, RESET OPTION MENU\n         B     R$CVDX              AND RETURN TO MENU\n         MVC   HDINPUT,INPUT+0     MOVE INPUT NUMBER\n        #GO    HEXDEC              CONVERT HEX TO DEC\n         CLI   HDRC,C'0'           DID IT GO OK?\n         BNE   RCVDBAD             NO, PUT OUT ERROR MESSAGE\n         MVI   RESULTSW,C'1'       INDICATE A CURRENT RESULT\n         MVI   RESULTRD,C'D'       INDICATE RESULT IN DECIMAL\n         ZAP   RESULT99,HDOUTDEC   SAVE CURRENT RESULT\n         MVC   INPUT+0(8),HDINPUT  PUT DATA BACK\n         MVC   SC2LN10,DECEDIT     MOVE EDIT MASK\n         ED    SC2LN10,HDOUTDEC    EDIT THE OUTPUT\n         CLI   SC2LN10+L'SC2LN10-1,C' ' IS IT A SPACE?\n         BNE   RCVDINIT            NO, GO PUT ORIGINAL SCREEN OUT\n         MVI   SC2LN10+L'SC2LN10-1,C'+' WAS A SPACE, REPLACE WITH A +\n         B     RCVDINIT            PUT ORIGINAL SCREEN BACK OUT\nRCVDBAD  MVC   SC2LN24,ENDLNE05    PUT OUT ERROR MESSAGE\n        $FS    SF=(INT),MF=(I,SC2LN07) SET ERROR INPUT\n         MVC   SC2LN10,=CL50' '    CLEAR OUTPUT\n         B     RCVDLOOP\nR$CVDX  $XRET  CC=(R15)\n         SPACE 1\n        LTORG\n         SPACE 1\nSCREEN2  $FS   CC=EW,WCC=(KBR,RMDT),SBA=(1,1),RA=(1,1,00),MF=L\n         $FS   SBA=(1,1),SF=(SKIP,INT),MF=L\n         $FS   SBA=(1,19),MF=L\n         $FS   TEXT='T S O   A R I T H M E T I C   C O M M A N D',MF=L\n         $FS   SBA=(2,1),RA=(3,1,-),MF=L\n         $FS   SBA=(4,6),SF=(SKIP),MF=L\n         $FS   TEXT='====   C O N V E R T   T O   D E C I M A L',MF=L\n         $FS   TEXT='   P R O C E S S O R   ====',MF=L\n         $FS   SBA=(5,80),SF=(SKIP,INT),MF=L\n         $FS   RA=(7,1,-),MF=L\n         $FS   SBA=(7,80),MF=L\nSC2LN07  $FS   SF=NORMAL,MF=L\nSC2LN08  $FS   TEXT=(' ',8),MF=L\n         $FS   SF=(SKIP,INT),TEXT='<====',MF=L\n         $FS   SF=(SKIP),TEXT='Enter',MF=L\n         $FS   SF=(SKIP,INT),TEXT='Hex value',MF=L\n         $FS   SF=(SKIP),TEXT='that you wish converted to',MF=L\n         $FS   SF=(SKIP,INT),TEXT='Decimal',MF=L\n         $FS   SBA=(9,80),SF=(SKIP,INT),MF=L\nSC2LN10  $FS   TEXT=(' ',21),MF=L\n         $FS   SF=(SKIP),TEXT='<====',MF=L\n         $FS   SF=(SKIP,INT),TEXT='Result ',MF=L\n         $FS   SF=(SKIP),RA=(10,80,=),MF=L\n         $FS   SBA=(23,80),MF=L\nSC2LN24  $FS   TEXT=(' ',88),MF=L\nSC2CSRP  $FS   SBA=(8,1),SF=(IC),MF=L\nLSCREEN2 EQU   *-SCREEN2\n         SPACE 1\n         DROP  R9\n         EJECT\n*------> INPUT \"SCREEN2\" PROCESS ROUTINE.\n*        AT EXIT : R1=INPUT TRUE LENGTH AND R3=INPUT SCAN LENGTH.\n         SPACE 1\nRSCRT2  $XENT  BASE=(R9)\n         XR    R2,R2               INITIAL COUNT\nR2LOOP  @FSR   ,                   GET REPLY TEXT\n         LTR   R15,R15             NO MORE FIELDS MODIFIED?\n         BNZ   R2PRCD              NO\n         L     R1,4(R13)           YES, END, GET PREVIOUS SAVE AREA\n         ST    R2,24(R1)           PASS BACK COUNT IN R1\n         LA    R2,8                AND INPUT SCAN LENGTH IN R3\n         ST    R2,32(R1)\n         XR    R15,R15             EXIT\n        $XRET  CC=(R15)\nR2PRCD   CLC   SC2CSF1,0(R15)\n         BNE   R2LOOP              UNEXPECTED (CHECK SCREEN IMAGE)\n         LTR   R1,R1\n         BZ    R2FC1               FIELD CLEARED (CANC FC)\n         CH    R1,=H'8'\n         BH    R2LOOP              UNEXPECTED (CHECK SCREEN IMAGE)\n         MVC   INPUT+0(8),=CL50' ' FOR UPPERCASE\n         SH    R1,=H'1'\n         EX    R1,R2OF1            COPY HEX VALUE\n         B     R2BF1\nR2FC1    MVC   INPUT+0(8),=CL50' ' HEX VALUE CLEARED\nR2BF1    LA    R2,8(R2)            BUMP COUNT\n         B     R2LOOP\nR2OF1    OC    INPUT+0(*-*),3(R15) <<EXECUTED>>\nSC2CSF1  $FS   SBA=(8,1),MF=L\n         SPACE 1\n        LTORG\n         SPACE 1\n         DROP  R9\n         EJECT\n*------> THIS ROUTINE PROCESSES THE CONVERT-TO-HEX SCREEN.\n*        AT EXIT : R15 = 0, 4 OR 8.\n         SPACE 1\nRTN$CVB $XENT  BASE=(R9)\n         MVC   INPUT+0(16),=CL50' ' CLEAR INPUT\n         MVC   SC3LN10,=CL50' '     \" \"  OUTPUT\nRCVBINIT MVC   SC3LN24,ENDLNE04    PUT OUT BEGINNING MESSAGE\n        $FS    SF=NORMAL,MF=(I,SC3LN07) SET NORMAL INPUT\nRCVBLOOP MVC   SC3LN08,INPUT+0     PUT DATA INTO SCREEN\n         LM    R0,R2,=A(SCREEN3,LSCREEN3,RSCRT3)\n         STM   R0,R2,ASCRIPTR      STORE PTR'S\n        #GO    FULLSCR             GO DO DEMO SCREEN WORK\n         B     *+L'*(R15)          HOW COMPLETE?\n         B     R$CVBX              0 - RETURN TO MENU - WILD GOTO\n         B     R$CVBX              4 - ERROR\n         LTR   R1,R1               8 - DID USER TYPE IN?\n         BZ    RCVBLOOP            NO, PUT SCREEN BACK OUT\n         BP    *+L'*+8             YES, GO PROCESS\n         MVI   INPUT+0,C' '        ELSE, RESET OPTION MENU\n         B     R$CVBX              AND RETURN TO MENU\n         MVC   DHINPUT,INPUT       MOVE INPUT NUMBER\n        #GO    DECHEX              CONVERT TO HEX\n         CLI   DHRC,C'0'           DID IT GO OK?\n         BNE   RCVBBAD             NO, PUT OUT ERROR MESSAGE\n         MVI   RESULTSW,C'1'       INDICATE A CURRENT RESULT\n         MVI   RESULTRD,C'X'       INDICATE RESULT IN HEX\n         ZAP   RESULT99,DHOUTDEC   SAVE CURRENT RESULT\n         MVC   INPUT+0(16),DHINPUT PUT DATA BACK\n         MVC   SC3LN10,DHOUTCHR    MOVE THE OUTPUT\n         B     RCVBINIT            PUT ORIGINAL SCREEN BACK OUT\nRCVBBAD  MVC   SC3LN24,ENDLNE05    PUT OUT ERROR MESSAGE\n        $FS    SF=(INT),MF=(I,SC3LN07) SET ERROR INPUT\n         MVC   SC3LN10,=CL50' '    CLEAR OUTPUT\n         B     RCVBLOOP\nR$CVBX  $XRET  CC=(R15)\n         SPACE 1\n        LTORG\n         SPACE 1\nSCREEN3  $FS   CC=EW,WCC=(KBR,RMDT),SBA=(1,1),RA=(1,1,00),MF=L\n         $FS   SBA=(1,1),SF=(SKIP,INT),MF=L\n         $FS   SBA=(1,19),MF=L\n         $FS   TEXT='T S O   A R I T H M E T I C   C O M M A N D',MF=L\n         $FS   SBA=(2,1),RA=(3,1,-),MF=L\n         $FS   SBA=(4,3),SF=(SKIP),MF=L\n         $FS   TEXT='====  C O N V E R T   T O   H E X A D E C ',MF=L\n         $FS   TEXT='I M A L   P R O C E S S O R  ====',MF=L\n         $FS   SBA=(5,80),SF=(SKIP,INT),MF=L\n         $FS   RA=(7,1,-),MF=L\n         $FS   SBA=(7,80),MF=L\nSC3LN07  $FS   SF=NORMAL,MF=L\nSC3LN08  $FS   TEXT=(' ',16),MF=L\n         $FS   SF=(SKIP,INT),TEXT='<====',MF=L\n         $FS   SF=(SKIP),TEXT='Enter the',MF=L\n         $FS   SF=(SKIP,INT),TEXT='Decimal value',MF=L\n         $FS   SF=(SKIP),TEXT='that you wish converted to',MF=L\n         $FS   SF=(SKIP,INT),TEXT='Hex',MF=L\n         $FS   SBA=(9,80),SF=(SKIP,INT),MF=L\nSC3LN10  $FS   TEXT=(' ',8),MF=L\n         $FS   SF=(SKIP),TEXT='<====',MF=L\n         $FS   SF=(SKIP,INT),TEXT='Result ',MF=L\n         $FS   SF=(SKIP),RA=(10,80,=),MF=L\n         $FS   SBA=(23,80),MF=L\nSC3LN24  $FS   TEXT=(' ',88),MF=L\nSC3CSRP  $FS   SBA=(8,1),SF=(IC),MF=L\nLSCREEN3 EQU   *-SCREEN3\n         SPACE 1\n         DROP  R9\n         EJECT\n*------> INPUT \"SCREEN3\" PROCESS ROUTINE.\n*        AT EXIT : R1=INPUT TRUE LENGTH AND R3=INPUT SCAN LENGTH.\n         SPACE 1\nRSCRT3  $XENT  BASE=(R9)\n         XR    R2,R2               INITIAL COUNT\nR3LOOP  @FSR   ,                   GET REPLY TEXT\n         LTR   R15,R15             NO MORE FIELDS MODIFIED?\n         BNZ   R3PRCD              NO\n         L     R1,4(R13)           YES, END, GET PREVIOUS SAVE AREA\n         ST    R2,24(R1)           PASS BACK COUNT IN R1\n         LA    R2,16               AND INPUT SCAN LENGTH IN R3\n         ST    R2,32(R1)\n         XR    R15,R15             EXIT\n        $XRET  CC=(R15)\nR3PRCD   CLC   SC3CSF1,0(R15)\n         BNE   R3LOOP              UNEXPECTED (CHECK SCREEN IMAGE)\n         LTR   R1,R1\n         BZ    R3FC1               FIELD CLEARED (CANC FC)\n         CH    R1,=H'16'\n         BH    R3LOOP              UNEXPECTED (CHECK SCREEN IMAGE)\n         MVC   INPUT+0(16),=CL50' ' FOR UPPERCASE\n         SH    R1,=H'1'\n         EX    R1,R3OF1            COPY DECIMAL VALUE\n         B     R3BF1\nR3FC1    MVC   INPUT+0(16),=CL50' ' DECIMAL VALUE CLEARED\nR3BF1    LA    R2,16(R2)           BUMP COUNT\n         B     R3LOOP\nR3OF1    OC    INPUT+0(*-*),3(R15) <<EXECUTED>>\nSC3CSF1  $FS   SBA=(8,1),MF=L\n         SPACE 1\n        LTORG\n         SPACE 1\n         DROP  R9\n         EJECT\n*------> THIS ROUTINE PROCESSES THE ADD SCREEN.\n*        AT EXIT : R15 = 0, 4 OR 8.\n         SPACE 1\nRTN$ADD $XENT  BASE=(R9)\n         MVI   INPUT+0,DEFRADIX    INIT RADIX\n         MVI   INPUT+17,DEFRADIX\n         MVI   INPUT+34,DEFRADIX\n         MVC   INPUT+1(16),=CL50' ' INIT TO SPACE\n         CLI   RESULTSW,C'1'       IS THERE A CURRENT RESULT?\n         BNE   RADDNOCR            NO, BYPASS\n         CLI   RESULTRD,C'D'       IS CURRENT RESULT DECIMAL?\n         BE    RADDRESD            YES, PROCESS DECIMAL\n         UNPK  DHINPUT,RESULT99    UNPACK IT\n         OI    DHINPUT+L'DHINPUT-1,C'0' CLEAR SIGN NIBBLE\n        #GO    DECHEX              CONVERT NUMBER TO HEX DISPLAY\n         MVC   INPUT+9(L'DHOUTCHR),DHOUTCHR PUT HEX NUMBER IN SCREEN\n         MVI   INPUT+0,C'X'        INDICATE HEX RADIX\n         B     RADDNOCR            BYPASS DECIMAL CODE\nRADDRESD MVC   INPUT+1(16),EDUNPK  UNPACK CURRENT RESULT\n         ED    INPUT+1(16),RESULT99+8 EDIT CURRENT RESULT\n         MVI   INPUT+1,C'+'        INIT TO POSITIVE\n         CP    RESULT99,=PL1'0'    SET CONDITION CODE\n         BNL   RADDNOCR            BYPASS MOVE\n         MVI   INPUT+1,C'-'        SET TO NEGATIVE\nRADDNOCR MVC   INPUT+18(16),=CL50' ' INIT TO SPACE\n         MVC   DIRADIX1,INPUT+0    COPY RADIX 1ST NUMBER\n         MVC   DIDATA1,INPUT+1     COPY 1ST NUMBER\n         MVC   DIRADIX2,INPUT+17   COPY RADIX 2ND NUMBER\n         MVC   DIDATA2,INPUT+18    COPY 2ND NUMBER\n         MVC   DIRADIX3,INPUT+34   COPY RADIX RESULT\n         MVC   SC4LN13N,=CL50' '   CLEAR RESULT DATA\n        $FS    SF=NORMAL,MF=(I,SC4LN08I) SET NORMAL INPUT\n        $FS    SF=NORMAL,MF=(I,SC4LN09I)  \" \"\n        $FS    SF=NORMAL,MF=(I,SC4LN10I)  \" \"\n        $FS    SF=NORMAL,MF=(I,SC4LN11I)  \" \"\n        $FS    SF=NORMAL,MF=(I,SC4LN14I)  \" \"\n        $FS    SBA=(8,5),MF=(I,SC4CSRP) SET CURSOR TO 1ST NUMBER\n         XR    R7,R7\nRADDRCA  MVC   SC4LN24,ENDLNE04    POST GOOD MESSAGE\n         LTR   R7,R7\n         BZ    RADDINIT\n        $FS    SF=NORMAL,MF=(I,(R7)) RESET ERROR INPUT\n         XR    R7,R7\nRADDINIT MVC   SC4LN09R,DIRADIX1   PUT DATA INTO SCREEN\n         MVC   SC4LN11R,DIRADIX2\n         MVC   SC4LN14R,DIRADIX3\n         MVC   SC4LN08N,DIDATA1\n         MVC   SC4LN10N,DIDATA2\nRADDLOOP LM    R0,R2,=A(SCREEN4,LSCREEN4,RSCRT4)\n         STM   R0,R2,ASCRIPTR      STORE PTR'S\n        #GO    FULLSCR             GO DO DEMO SCREEN WORK\n         B     *+L'*(R15)          HOW COMPLETE?\n         B     R$ADDX              0 - RETURN TO MENU - WILD GOTO\n         B     R$ADDX              4 - ERROR\n         LTR   R1,R1               8 - DID USER TYPE IN?\n         BZ    RADDLOOP            NO, PUT SCREEN BACK OUT\n         BP    *+L'*+8             YES, GO PROCESS\n         MVI   INPUT+0,C' '        ELSE, RESET OPTION MENU\n         B     R$ADDX              AND RETURN TO MENU\n        #GO    DYADIC              GO DO PRELIMINARY EDITING\n         MVC   SC4LN13N,=CL50' '   CLEAR RESULT AREA\n         B     *+L'*(R15)          BRANCH ON RETURN CODE\n         B     RADD00              EDITING/CONVERSION OK\n         B     RADD04              ERROR, RC=04\n         B     RADD08              ERROR, RC=08\n         B     RADD12              ERROR, RC=12\n         B     RADD16              ERROR, RC=16\n         B     RADD20              ERROR, RC=20\nRADD00  $FS    SBA=(8,5),MF=(I,SC4CSRP) SET CURSOR TO 1ST NUMBER\n         ZAP   RESULT3,RESULT1     SHIFT FIRST RESULT\n         AP    RESULT3,RESULT2     ADD SECOND RESULT\n         ZAP   RESULT99,RESULT3    CAPTURE CURRENT RESULT\n         MVI   RESULTSW,C'1'       INDICATE CURRENT RESULT ACTIVE\n         MVC   RESULTRD,DIRADIX3   INDICATE CURRENT RESULT RADIX\n         CP    RESULT3,=PL1'0'     SET CONDITION CODE\n         BL    *+L'*+8             IF NEGATIVE, INSERT -\n         MVI   DHINPUT+L'DHINPUT-1,C'+' MOVE A POSITIVE SIGN\n         B     *+L'*+4             GO TO BYPASS\n         MVI   DHINPUT+L'DHINPUT-1,C'-' INSERT A - SIGN\n         CLI   DIRADIX3,C'D'       DID USER WANT ANSWER IN DEC?\n         BE    RADDYESD            YES, IN DECIMAL\n         UNPK  DHINPUT(L'DHINPUT-1),RESULT3 SET INPUT UP\n         OI    DHINPUT+L'DHINPUT-2,C'0' CLEAR SIGN NIBBLE\n        #GO    DECHEX              CONVERT TO HEX\n         MVC   SC4LN13N+11(L'DHOUTCHR),DHOUTCHR MOVE CONVERTED HEX\n         B     RADDRCA             GO PUT SCREEN BACK OUT\nRADDYESD MVC   SC4LN13N,DECEDIT2   PUT EDIT MASK IN SCREEN\n         ED    SC4LN13N,RESULT3+3  EDIT DECIMAL RESULT\n         CLI   SC4LN13N+L'SC4LN13N-1,C' ' IS SIGN A BLANK\n         BNE   RADDRCA             NO, GO PUT SCREEN BACK OUT\n         MVI   SC4LN13N+L'SC4LN13N-1,C'+' YES, REPLACE WITH A +\n         B     RADDRCA             GO PUT SCREEN BACK OUT\nRADD04  $FS    SBA=(9,31),MF=(I,SC4CSRP) RESET CURSOR POSITION\n         LA    R2,SC4LN09I\n         B     RADDBAD\nRADD08  $FS    SBA=(11,31),MF=(I,SC4CSRP) RESET CURSOR POSITION\n         LA    R2,SC4LN11I\n         B     RADDBAD\nRADD12  $FS    SBA=(14,46),MF=(I,SC4CSRP) RESET CURSOR POSITION\n         LA    R2,SC4LN14I\n         B     RADDBAD\nRADD16  $FS    SBA=(8,5),MF=(I,SC4CSRP) RESET CURSOR POSITION\n         LA    R2,SC4LN08I\n         B     RADDBAD\nRADD20  $FS    SBA=(10,5),MF=(I,SC4CSRP) RESET CURSOR POSITION\n         LA    R2,SC4LN10I\nRADDBAD  LTR   R7,R7\n         BZ    RADDBADX\n        $FS    SF=NORMAL,MF=(I,(R7)) RESET ERROR INPUT\nRADDBADX LR    R7,R2\n         MVC   SC4LN24,ENDLNE05    PUT OUT ERROR MESSAGE\n        $FS    SF=(INT),MF=(I,(R7)) SET ERROR INPUT\n         B     RADDINIT\nR$ADDX  $XRET  CC=(R15)\n         SPACE 1\n        LTORG\n         SPACE 1\nSCREEN4  $FS   CC=EW,WCC=(KBR,RMDT),SBA=(1,1),RA=(1,1,00),MF=L\n         $FS   SBA=(1,1),SF=(SKIP,INT),MF=L\n         $FS   SBA=(1,19),MF=L\n         $FS   TEXT='T S O   A R I T H M E T I C   C O M M A N D',MF=L\n         $FS   SBA=(2,1),RA=(3,1,-),MF=L\n         $FS   SBA=(4,15),SF=(SKIP),MF=L\n         $FS   TEXT='====   A D D I T I O N   ',MF=L\n         $FS   TEXT='P R O C E S S O R   ====',MF=L\n         $FS   SBA=(5,80),SF=(SKIP,INT),MF=L\n         $FS   RA=(7,1,-),MF=L\n         $FS   SBA=(8,1),SF=(SKIP),TEXT='1:',MF=L\nSC4LN08I $FS   SF=NORMAL,MF=L\nSC4LN08N $FS   TEXT=(' ',16),MF=L\n         $FS   SF=(SKIP,INT),TEXT='<====',MF=L\n         $FS   SF=(SKIP),TEXT='Enter',MF=L\n         $FS   SF=(SKIP,INT),TEXT='1st #',MF=L\n         $FS   SF=(SKIP),TEXT='to add',MF=L\n         $FS   SBA=(9,27),SF=(SKIP),TEXT='2:',MF=L\nSC4LN09I $FS   SF=NORMAL,MF=L\nSC4LN09R $FS   TEXT=(' ',1),MF=L\n         $FS   SF=(SKIP,INT),TEXT='<====',MF=L\n         $FS   SF=(SKIP),TEXT='Enter',MF=L\n         $FS   SF=(SKIP,INT),TEXT='Radix',MF=L\n         $FS   SBA=(10,1),SF=(SKIP),TEXT='3:',MF=L\nSC4LN10I $FS   SF=NORMAL,MF=L\nSC4LN10N $FS   TEXT=(' ',16),MF=L\n         $FS   SF=(SKIP,INT),TEXT='<====',MF=L\n         $FS   SF=(SKIP),TEXT='Enter',MF=L\n         $FS   SF=(SKIP,INT),TEXT='2nd #',MF=L\n         $FS   SF=(SKIP),TEXT='to add',MF=L\n         $FS   SBA=(11,27),SF=(SKIP),TEXT='4:',MF=L\nSC4LN11I $FS   SF=NORMAL,MF=L\nSC4LN11R $FS   TEXT=(' ',1),MF=L\n         $FS   SF=(SKIP,INT),TEXT='<====',MF=L\n         $FS   SF=(SKIP),TEXT='Enter',MF=L\n         $FS   SF=(SKIP,INT),TEXT='Radix',MF=L\n         $FS   SF=(SKIP),MF=L\n         $FS   SBA=(12,1),TEXT='------------------',MF=L\n         $FS   TEXT='----------------',MF=L\n         $FS   SBA=(13,1),SF=(SKIP,INT),MF=L\nSC4LN13N $FS   TEXT=(' ',34),MF=L\n         $FS   SF=(SKIP),TEXT='<====',MF=L\n         $FS   SF=(SKIP,INT),TEXT='Sum',MF=L\n         $FS   SF=(SKIP),RA=(13,80,=),MF=L\n         $FS   SBA=(14,42),SF=(SKIP),TEXT='5:',MF=L\nSC4LN14I $FS   SF=NORMAL,MF=L\nSC4LN14R $FS   TEXT=(' ',1),MF=L\n         $FS   SF=(SKIP,INT),TEXT='<====',MF=L\n         $FS   SF=(SKIP),TEXT='Enter',MF=L\n         $FS   SF=(SKIP,INT),TEXT='Radix',MF=L\n         $FS   SF=(SKIP),MF=L\n         $FS   SBA=(17,1),SF=(SKIP,INT),TEXT='1:',MF=L\n         $FS   SF=(SKIP),TEXT='Enter 1st # to add, please ',MF=L\n         $FS   TEXT='make sure item (2) is equivalent',MF=L\n         $FS   SBA=(18,1),SF=(SKIP,INT),TEXT='2:',MF=L\n         $FS   SF=(SKIP),TEXT='Enter Radix of 1st # to ',MF=L\n         $FS   TEXT='add (D=Decimal, X=Hexadecimal)',MF=L\n         $FS   SBA=(19,1),SF=(SKIP,INT),TEXT='3:',MF=L\n         $FS   SF=(SKIP),TEXT='Enter 2nd # to add, please',MF=L\n         $FS   TEXT=' make sure item (4) is equivalent',MF=L\n         $FS   SBA=(20,1),SF=(SKIP,INT),TEXT='4:',MF=L\n         $FS   SF=(SKIP),TEXT='Enter Radix of 2nd # to ',MF=L\n         $FS   TEXT='add (D=Decimal, X=Hexadecimal)',MF=L\n         $FS   SBA=(21,1),SF=(SKIP,INT),TEXT='5:',MF=L\n         $FS   SF=(SKIP),TEXT='Enter Radix you would display ',MF=L\n         $FS   TEXT='the sum (D=Decimal, X=Hexadecimal)',MF=L\n         $FS   SBA=(23,80),MF=L\nSC4LN24  $FS   TEXT=(' ',88),MF=L\nSC4CSRP  $FS   SBA=(8,5),SF=(IC),MF=L\nLSCREEN4 EQU   *-SCREEN4\n         SPACE 1\n         DROP  R9\n         EJECT\n*------> INPUT \"SCREEN4\" PROCESS ROUTINE.\n*        AT EXIT : R1=INPUT TRUE LENGTH AND R3=INPUT SCAN LENGTH.\n         SPACE 1\nRSCRT4  $XENT  BASE=(R9)\n         XR    R2,R2               INITIAL COUNT\nR4LOOP  @FSR   ,                   GET REPLY TEXT\n         LTR   R15,R15             NO MORE FIELDS MODIFIED?\n         BNZ   R4PRCD              NO\n         L     R1,4(R13)           YES, END, GET PREVIOUS SAVE AREA\n         ST    R2,24(R1)           PASS BACK COUNT IN R1\n         LA    R2,35               AND INPUT SCAN LENGTH IN R3\n         ST    R2,32(R1)\n         XR    R15,R15             EXIT\n        $XRET  CC=(R15)\nR4PRCD   CLC   SC4CSF1,0(R15)\n         BE    R4FL1\n         CLC   SC4CSF2,0(R15)\n         BE    R4FL2\n         CLC   SC4CSF3,0(R15)\n         BE    R4FL3\n         CLC   SC4CSF4,0(R15)\n         BE    R4FL4\n         CLC   SC4CSF5,0(R15)\n         BE    R4FL5\n         B     R4LOOP              UNEXPECTED (CHECK SCREEN IMAGE)\nR4FL1    LTR   R1,R1\n         BZ    R4FC1               FIELD CLEARED (CANC FC)\n         CH    R1,=H'1'\n         BNE   R4LOOP              UNEXPECTED (CHECK SCREEN IMAGE)\n         MVI   INPUT+0,C' '        FOR UPPERCASE\n         OC    INPUT+0(1),3(R15)   COPY RADIX OF 1ST NUMBER\n         B     R4BF1\nR4FC1    MVI   INPUT+0,C' '        RADIX OF 1ST NUMBER CLEARED\nR4BF1    LA    R2,1(R2)            BUMP COUNT\n         B     R4LOOP\nR4FL2    LTR   R1,R1\n         BZ    R4FC2               FIELD CLEARED (CANC FC)\n         CH    R1,=H'16'\n         BH    R4LOOP              UNEXPECTED (CHECK SCREEN IMAGE)\n         MVC   INPUT+1(16),=CL50' ' FOR UPPERCASE\n         SH    R1,=H'1'\n         EX    R1,R4OF2            COPY 1ST NUMBER VALUE\n         B     R4BF2\nR4FC2    MVC   INPUT+1(16),=CL50' ' 1ST NUMBER VALUE CLEARED\nR4BF2    LA    R2,16(R2)           BUMP COUNT\n         B     R4LOOP\nR4OF2    OC    INPUT+1(*-*),3(R15) <<EXECUTED>>\nR4FL3    LTR   R1,R1\n         BZ    R4FC3               FIELD CLEARED (CANC FC)\n         CH    R1,=H'1'\n         BNE   R4LOOP              UNEXPECTED (CHECK SCREEN IMAGE)\n         MVI   INPUT+17,C' '       FOR UPPERCASE\n         OC    INPUT+17(1),3(R15)  COPY RADIX OF 2ND NUMBER\n         B     R4BF3\nR4FC3    MVI   INPUT+17,C' '       RADIX OF 2ND NUMBER CLEARED\nR4BF3    LA    R2,1(R2)            BUMP COUNT\n         B     R4LOOP\nR4FL4    LTR   R1,R1\n         BZ    R4FC4               FIELD CLEARED (CANC FC)\n         CH    R1,=H'16'\n         BH    R4LOOP              UNEXPECTED (CHECK SCREEN IMAGE)\n         MVC   INPUT+18(16),=CL50' ' FOR UPPERCASE\n         SH    R1,=H'1'\n         EX    R1,R4OF4            COPY 2ND NUMBER VALUE\n         B     R4BF4\nR4FC4    MVC   INPUT+18(16),=CL50' ' 2ND NUMBER VALUE CLEARED\nR4BF4    LA    R2,16(R2)           BUMP COUNT\n         B     R4LOOP\nR4OF4    OC    INPUT+18(*-*),3(R15) <<EXECUTED>>\nR4FL5    LTR   R1,R1\n         BZ    R4FC5               FIELD CLEARED (CANC FC)\n         CH    R1,=H'1'\n         BNE   R4LOOP              UNEXPECTED (CHECK SCREEN IMAGE)\n         MVI   INPUT+34,C' '       FOR UPPERCASE\n         OC    INPUT+34(1),3(R15)  COPY RADIX OF RESULT\n         B     R4BF5\nR4FC5    MVI   INPUT+34,C' '       RADIX OF RESULT CLEARED\nR4BF5    LA    R2,1(R2)            BUMP COUNT\n         B     R4LOOP\nSC4CSF1  $FS   SBA=(9,31),MF=L\nSC4CSF2  $FS   SBA=(8,5),MF=L\nSC4CSF3  $FS   SBA=(11,31),MF=L\nSC4CSF4  $FS   SBA=(10,5),MF=L\nSC4CSF5  $FS   SBA=(14,46),MF=L\n         SPACE 1\n        LTORG\n         SPACE 1\n         DROP  R9\n         EJECT\n*------> THIS ROUTINE PROCESSES THE SUBTRACT SCREEN.\n*        AT EXIT : R15 = 0, 4 OR 8.\n         SPACE 1\nRTN$SUB $XENT  BASE=(R9)\n         MVI   INPUT+0,DEFRADIX    INIT RADIX\n         MVI   INPUT+17,DEFRADIX\n         MVI   INPUT+34,DEFRADIX\n         MVC   INPUT+1(16),=CL50' ' INIT TO SPACE\n         CLI   RESULTSW,C'1'       IS THERE A CURRENT RESULT?\n         BNE   RSUBNOCR            NO, BYPASS\n         CLI   RESULTRD,C'D'       IS CURRENT RESULT DECIMAL?\n         BE    RSUBRESD            YES, PROCESS DECIMAL\n         UNPK  DHINPUT,RESULT99    UNPACK IT\n         OI    DHINPUT+L'DHINPUT-1,C'0' CLEAR SIGN NIBBLE\n        #GO    DECHEX              CONVERT NUMBER TO HEX DISPLAY\n         MVC   INPUT+9(L'DHOUTCHR),DHOUTCHR PUT HEX NUMBER IN SCREEN\n         MVI   INPUT+0,C'X'        INDICATE HEX RADIX\n         B     RSUBNOCR            BYPASS DECIMAL CODE\nRSUBRESD MVC   INPUT+1(16),EDUNPK  UNPACK CURRENT RESULT\n         ED    INPUT+1(16),RESULT99+8 EDIT CURRENT RESULT\n         MVI   INPUT+1,C'+'        INIT TO POSITIVE\n         CP    RESULT99,=PL1'0'    SET CONDITION CODE\n         BNL   RSUBNOCR            BYPASS MOVE\n         MVI   INPUT+1,C'-'        SET TO NEGATIVE\nRSUBNOCR MVC   INPUT+18(16),=CL50' ' INIT TO SPACE\n         MVC   DIRADIX1,INPUT+0    COPY RADIX 1ST NUMBER\n         MVC   DIDATA1,INPUT+1     COPY 1ST NUMBER\n         MVC   DIRADIX2,INPUT+17   COPY RADIX 2ND NUMBER\n         MVC   DIDATA2,INPUT+18    COPY 2ND NUMBER\n         MVC   DIRADIX3,INPUT+34   COPY RADIX RESULT\n         MVC   SC5LN13N,=CL50' '   CLEAR RESULT DATA\n        $FS    SF=NORMAL,MF=(I,SC5LN08I) SET NORMAL INPUT\n        $FS    SF=NORMAL,MF=(I,SC5LN09I)  \" \"\n        $FS    SF=NORMAL,MF=(I,SC5LN10I)  \" \"\n        $FS    SF=NORMAL,MF=(I,SC5LN11I)  \" \"\n        $FS    SF=NORMAL,MF=(I,SC5LN14I)  \" \"\n        $FS    SBA=(8,5),MF=(I,SC5CSRP) SET CURSOR TO 1ST NUMBER\n         XR    R7,R7\nRSUBRCA  MVC   SC5LN24,ENDLNE04    POST GOOD MESSAGE\n         LTR   R7,R7\n         BZ    RSUBINIT\n        $FS    SF=NORMAL,MF=(I,(R7)) RESET ERROR INPUT\n         XR    R7,R7\nRSUBINIT MVC   SC5LN09R,DIRADIX1   PUT DATA INTO SCREEN\n         MVC   SC5LN11R,DIRADIX2\n         MVC   SC5LN14R,DIRADIX3\n         MVC   SC5LN08N,DIDATA1\n         MVC   SC5LN10N,DIDATA2\nRSUBLOOP LM    R0,R2,=A(SCREEN5,LSCREEN5,RSCRT5)\n         STM   R0,R2,ASCRIPTR      STORE PTR'S\n        #GO    FULLSCR             GO DO DEMO SCREEN WORK\n         B     *+L'*(R15)          HOW COMPLETE?\n         B     R$SUBX              0 - RETURN TO MENU - WILD GOTO\n         B     R$SUBX              4 - ERROR\n         LTR   R1,R1               8 - DID USER TYPE IN?\n         BZ    RSUBLOOP            NO, PUT SCREEN BACK OUT\n         BP    *+L'*+8             YES, GO PROCESS\n         MVI   INPUT+0,C' '        ELSE, RESET OPTION MENU\n         B     R$SUBX              AND RETURN TO MENU\n        #GO    DYADIC              GO DO PRELIMINARY EDITING\n         MVC   SC5LN13N,=CL50' '   CLEAR RESULT AREA\n         B     *+L'*(R15)          BRANCH ON RETURN CODE\n         B     RSUB00              EDITING/CONVERSION OK\n         B     RSUB04              ERROR, RC=04\n         B     RSUB08              ERROR, RC=08\n         B     RSUB12              ERROR, RC=12\n         B     RSUB16              ERROR, RC=16\n         B     RSUB20              ERROR, RC=20\nRSUB00  $FS    SBA=(8,5),MF=(I,SC5CSRP) SET CURSOR TO 1ST NUMBER\n         ZAP   RESULT3,RESULT1     SHIFT FIRST RESULT\n         SP    RESULT3,RESULT2     SUBTRACT SECOND RESULT\n         ZAP   RESULT99,RESULT3    CAPTURE CURRENT RESULT\n         MVI   RESULTSW,C'1'       INDICATE CURRENT RESULT ACTIVE\n         MVC   RESULTRD,DIRADIX3   INDICATE CURRENT RESULT RADIX\n         CP    RESULT3,=PL1'0'     SET CONDITION CODE\n         BL    *+L'*+8             IF NEGATIVE, INSERT -\n         MVI   DHINPUT+L'DHINPUT-1,C'+' MOVE A POSITIVE SIGN\n         B     *+L'*+4             GO TO BYPASS\n         MVI   DHINPUT+L'DHINPUT-1,C'-' INSERT A - SIGN\n         CLI   DIRADIX3,C'D'       DID USER WANT ANSWER IN DEC?\n         BE    RSUBYESD            YES, IN DECIMAL\n         UNPK  DHINPUT(L'DHINPUT-1),RESULT3 SET INPUT UP\n         OI    DHINPUT+L'DHINPUT-2,C'0' CLEAR SIGN NIBBLE\n        #GO    DECHEX              CONVERT TO HEX\n         MVC   SC5LN13N+11(L'DHOUTCHR),DHOUTCHR MOVE CONVERTED HEX\n         B     RSUBRCA             GO PUT SCREEN BACK OUT\nRSUBYESD MVC   SC5LN13N,DECEDIT2   PUT EDIT MASK IN SCREEN\n         ED    SC5LN13N,RESULT3+3  EDIT DECIMAL RESULT\n         CLI   SC5LN13N+L'SC5LN13N-1,C' ' IS SIGN A BLANK\n         BNE   RSUBRCA             NO, GO PUT SCREEN BACK OUT\n         MVI   SC5LN13N+L'SC5LN13N-1,C'+' YES, REPLACE WITH A +\n         B     RSUBRCA             GO PUT SCREEN BACK OUT\nRSUB04  $FS    SBA=(9,31),MF=(I,SC5CSRP) RESET CURSOR POSITION\n         LA    R2,SC5LN09I\n         B     RSUBBAD\nRSUB08  $FS    SBA=(11,31),MF=(I,SC5CSRP) RESET CURSOR POSITION\n         LA    R2,SC5LN11I\n         B     RSUBBAD\nRSUB12  $FS    SBA=(14,46),MF=(I,SC5CSRP) RESET CURSOR POSITION\n         LA    R2,SC5LN14I\n         B     RSUBBAD\nRSUB16  $FS    SBA=(8,5),MF=(I,SC5CSRP) RESET CURSOR POSITION\n         LA    R2,SC5LN08I\n         B     RSUBBAD\nRSUB20  $FS    SBA=(10,5),MF=(I,SC5CSRP) RESET CURSOR POSITION\n         LA    R2,SC5LN10I\nRSUBBAD  LTR   R7,R7\n         BZ    RSUBBADX\n        $FS    SF=NORMAL,MF=(I,(R7)) RESET ERROR INPUT\nRSUBBADX LR    R7,R2\n         MVC   SC5LN24,ENDLNE05    PUT OUT ERROR MESSAGE\n        $FS    SF=(INT),MF=(I,(R7)) SET ERROR INPUT\n         B     RSUBINIT\nR$SUBX  $XRET  CC=(R15)\n         SPACE 1\n        LTORG\n         SPACE 1\nSCREEN5  $FS   CC=EW,WCC=(KBR,RMDT),SBA=(1,1),RA=(1,1,00),MF=L\n         $FS   SBA=(1,1),SF=(SKIP,INT),MF=L\n         $FS   SBA=(1,19),MF=L\n         $FS   TEXT='T S O   A R I T H M E T I C   C O M M A N D',MF=L\n         $FS   SBA=(2,1),RA=(3,1,-),MF=L\n         $FS   SBA=(4,13),SF=(SKIP),MF=L\n         $FS   TEXT='====   S U B T R A C T I O N   ',MF=L\n         $FS   TEXT='P R O C E S S O R   ====',MF=L\n         $FS   SBA=(5,80),SF=(SKIP,INT),MF=L\n         $FS   RA=(7,1,-),MF=L\n         $FS   SBA=(8,1),SF=(SKIP),TEXT='1:',MF=L\nSC5LN08I $FS   SF=NORMAL,MF=L\nSC5LN08N $FS   TEXT=(' ',16),MF=L\n         $FS   SF=(SKIP,INT),TEXT='<====',MF=L\n         $FS   SF=(SKIP),TEXT='Enter',MF=L\n         $FS   SF=(SKIP,INT),TEXT='1st #',MF=L\n         $FS   SF=(SKIP),TEXT='to substract from',MF=L\n         $FS   SBA=(9,27),SF=(SKIP),TEXT='2:',MF=L\nSC5LN09I $FS   SF=NORMAL,MF=L\nSC5LN09R $FS   TEXT=(' ',1),MF=L\n         $FS   SF=(SKIP,INT),TEXT='<====',MF=L\n         $FS   SF=(SKIP),TEXT='Enter',MF=L\n         $FS   SF=(SKIP,INT),TEXT='Radix',MF=L\n         $FS   SBA=(10,1),SF=(SKIP),TEXT='3:',MF=L\nSC5LN10I $FS   SF=NORMAL,MF=L\nSC5LN10N $FS   TEXT=(' ',16),MF=L\n         $FS   SF=(SKIP,INT),TEXT='<====',MF=L\n         $FS   SF=(SKIP),TEXT='Enter',MF=L\n         $FS   SF=(SKIP,INT),TEXT='2nd #',MF=L\n         $FS   SF=(SKIP),TEXT='to substract',MF=L\n         $FS   SBA=(11,27),SF=(SKIP),TEXT='4:',MF=L\nSC5LN11I $FS   SF=NORMAL,MF=L\nSC5LN11R $FS   TEXT=(' ',1),MF=L\n         $FS   SF=(SKIP,INT),TEXT='<====',MF=L\n         $FS   SF=(SKIP),TEXT='Enter',MF=L\n         $FS   SF=(SKIP,INT),TEXT='Radix',MF=L\n         $FS   SF=(SKIP),MF=L\n         $FS   SBA=(12,2),TEXT='------------------',MF=L\n         $FS   TEXT='----------------',MF=L\n         $FS   SBA=(13,1),SF=(SKIP,INT),MF=L\nSC5LN13N $FS   TEXT=(' ',34),MF=L\n         $FS   SF=(SKIP),TEXT='<====',MF=L\n         $FS   SF=(SKIP,INT),TEXT='Difference',MF=L\n         $FS   SF=(SKIP),RA=(13,80,=),MF=L\n         $FS   SBA=(14,42),SF=(SKIP),TEXT='5:',MF=L\nSC5LN14I $FS   SF=NORMAL,MF=L\nSC5LN14R $FS   TEXT=(' ',1),MF=L\n         $FS   SF=(SKIP,INT),TEXT='<====',MF=L\n         $FS   SF=(SKIP),TEXT='Enter',MF=L\n         $FS   SF=(SKIP,INT),TEXT='Radix',MF=L\n         $FS   SF=(SKIP),MF=L\n         $FS   SBA=(17,1),SF=(SKIP,INT),TEXT='1:',MF=L\n         $FS   SF=(SKIP),TEXT='Enter # to subtract from, please ',MF=L\n         $FS   TEXT='make sure item (2) is equivalent',MF=L\n         $FS   SBA=(18,1),SF=(SKIP,INT),TEXT='2:',MF=L\n         $FS   SF=(SKIP),TEXT='Enter Radix of # to subtract ',MF=L\n         $FS   TEXT='from (D=Decimal, X=Hexadecimal)',MF=L\n         $FS   SBA=(19,1),SF=(SKIP,INT),TEXT='3:',MF=L\n         $FS   SF=(SKIP),TEXT='Enter # to subtract, please',MF=L\n         $FS   TEXT=' make sure item (4) is equivalent',MF=L\n         $FS   SBA=(20,1),SF=(SKIP,INT),TEXT='4:',MF=L\n         $FS   SF=(SKIP),TEXT='Enter Radix of # to ',MF=L\n         $FS   TEXT='subtract (D=Decimal, X=Hexadecimal)',MF=L\n         $FS   SBA=(21,1),SF=(SKIP,INT),TEXT='5:',MF=L\n         $FS   SF=(SKIP),TEXT='Enter Radix you would display ',MF=L\n         $FS   TEXT='the difference (D=Decimal, X=Hexadecimal)',MF=L\n         $FS   SBA=(23,80),MF=L\nSC5LN24  $FS   TEXT=(' ',88),MF=L\nSC5CSRP  $FS   SBA=(8,5),SF=(IC),MF=L\nLSCREEN5 EQU   *-SCREEN5\n         SPACE 1\n         DROP  R9\n         EJECT\n*------> INPUT \"SCREEN5\" PROCESS ROUTINE.\n*        AT EXIT : R1=INPUT TRUE LENGTH AND R3=INPUT SCAN LENGTH.\n         SPACE 1\nRSCRT5  $XENT  BASE=(R9)\n         XR    R2,R2               INITIAL COUNT\nR5LOOP  @FSR   ,                   GET REPLY TEXT\n         LTR   R15,R15             NO MORE FIELDS MODIFIED?\n         BNZ   R5PRCD              NO\n         L     R1,4(R13)           YES, END, GET PREVIOUS SAVE AREA\n         ST    R2,24(R1)           PASS BACK COUNT IN R1\n         LA    R2,35               AND INPUT SCAN LENGTH IN R3\n         ST    R2,32(R1)\n         XR    R15,R15             EXIT\n        $XRET  CC=(R15)\nR5PRCD   CLC   SC5CSF1,0(R15)\n         BE    R5FL1\n         CLC   SC5CSF2,0(R15)\n         BE    R5FL2\n         CLC   SC5CSF3,0(R15)\n         BE    R5FL3\n         CLC   SC5CSF4,0(R15)\n         BE    R5FL4\n         CLC   SC5CSF5,0(R15)\n         BE    R5FL5\n         B     R5LOOP              UNEXPECTED (CHECK SCREEN IMAGE)\nR5FL1    LTR   R1,R1\n         BZ    R5FC1               FIELD CLEARED (CANC FC)\n         CH    R1,=H'1'\n         BNE   R5LOOP              UNEXPECTED (CHECK SCREEN IMAGE)\n         MVI   INPUT+0,C' '        FOR UPPERCASE\n         OC    INPUT+0(1),3(R15)   COPY RADIX OF 1ST NUMBER\n         B     R5BF1\nR5FC1    MVI   INPUT+0,C' '        RADIX OF 1ST NUMBER CLEARED\nR5BF1    LA    R2,1(R2)            BUMP COUNT\n         B     R5LOOP\nR5FL2    LTR   R1,R1\n         BZ    R5FC2               FIELD CLEARED (CANC FC)\n         CH    R1,=H'16'\n         BH    R5LOOP              UNEXPECTED (CHECK SCREEN IMAGE)\n         MVC   INPUT+1(16),=CL50' ' FOR UPPERCASE\n         SH    R1,=H'1'\n         EX    R1,R5OF2            COPY 1ST NUMBER VALUE\n         B     R5BF2\nR5FC2    MVC   INPUT+1(16),=CL50' ' 1ST NUMBER VALUE CLEARED\nR5BF2    LA    R2,16(R2)           BUMP COUNT\n         B     R5LOOP\nR5OF2    OC    INPUT+1(*-*),3(R15) <<EXECUTED>>\nR5FL3    LTR   R1,R1\n         BZ    R5FC3               FIELD CLEARED (CANC FC)\n         CH    R1,=H'1'\n         BNE   R5LOOP              UNEXPECTED (CHECK SCREEN IMAGE)\n         MVI   INPUT+17,C' '       FOR UPPERCASE\n         OC    INPUT+17(1),3(R15)  COPY RADIX OF 2ND NUMBER\n         B     R5BF3\nR5FC3    MVI   INPUT+17,C' '       RADIX OF 2ND NUMBER CLEARED\nR5BF3    LA    R2,1(R2)            BUMP COUNT\n         B     R5LOOP\nR5FL4    LTR   R1,R1\n         BZ    R5FC4               FIELD CLEARED (CANC FC)\n         CH    R1,=H'16'\n         BH    R5LOOP              UNEXPECTED (CHECK SCREEN IMAGE)\n         MVC   INPUT+18(16),=CL50' ' FOR UPPERCASE\n         SH    R1,=H'1'\n         EX    R1,R5OF4            COPY 2ND NUMBER VALUE\n         B     R5BF4\nR5FC4    MVC   INPUT+18(16),=CL50' ' 2ND NUMBER VALUE CLEARED\nR5BF4    LA    R2,16(R2)           BUMP COUNT\n         B     R5LOOP\nR5OF4    OC    INPUT+18(*-*),3(R15) <<EXECUTED>>\nR5FL5    LTR   R1,R1\n         BZ    R5FC5               FIELD CLEARED (CANC FC)\n         CH    R1,=H'1'\n         BNE   R5LOOP              UNEXPECTED (CHECK SCREEN IMAGE)\n         MVI   INPUT+34,C' '       FOR UPPERCASE\n         OC    INPUT+34(1),3(R15)  COPY RADIX OF RESULT\n         B     R5BF5\nR5FC5    MVI   INPUT+34,C' '       RADIX OF RESULT CLEARED\nR5BF5    LA    R2,1(R2)            BUMP COUNT\n         B     R5LOOP\nSC5CSF1  $FS   SBA=(9,31),MF=L\nSC5CSF2  $FS   SBA=(8,5),MF=L\nSC5CSF3  $FS   SBA=(11,31),MF=L\nSC5CSF4  $FS   SBA=(10,5),MF=L\nSC5CSF5  $FS   SBA=(14,46),MF=L\n         SPACE 1\n        LTORG\n         SPACE 1\n         DROP  R9\n         EJECT\n*------> THIS ROUTINE PROCESSES THE MULTIPLY SCREEN.\n*        AT EXIT : R15 = 0, 4 OR 8.\n         SPACE 1\nRTN$MUL $XENT  BASE=(R9)\n         MVI   INPUT+0,DEFRADIX    INIT RADIX\n         MVI   INPUT+17,DEFRADIX\n         MVI   INPUT+34,DEFRADIX\n         MVC   INPUT+1(16),=CL50' ' INIT TO SPACE\n         CLI   RESULTSW,C'1'       IS THERE A CURRENT RESULT?\n         BNE   RMULNOCR            NO, BYPASS\n         CLI   RESULTRD,C'D'       IS CURRENT RESULT DECIMAL?\n         BE    RMULRESD            YES, PROCESS DECIMAL\n         UNPK  DHINPUT,RESULT99    UNPACK IT\n         OI    DHINPUT+L'DHINPUT-1,C'0' CLEAR SIGN NIBBLE\n        #GO    DECHEX              CONVERT NUMBER TO HEX DISPLAY\n         MVC   INPUT+9(L'DHOUTCHR),DHOUTCHR PUT HEX NUMBER IN SCREEN\n         MVI   INPUT+0,C'X'        INDICATE HEX RADIX\n         B     RMULNOCR            BYPASS DECIMAL CODE\nRMULRESD MVC   INPUT+1(16),EDUNPK  UNPACK CURRENT RESULT\n         ED    INPUT+1(16),RESULT99+8 EDIT CURRENT RESULT\n         MVI   INPUT+1,C'+'        INIT TO POSITIVE\n         CP    RESULT99,=PL1'0'    SET CONDITION CODE\n         BNL   RMULNOCR            BYPASS MOVE\n         MVI   INPUT+1,C'-'        SET TO NEGATIVE\nRMULNOCR MVC   INPUT+18(16),=CL50' ' INIT TO SPACE\n         MVC   DIRADIX1,INPUT+0    COPY RADIX 1ST NUMBER\n         MVC   DIDATA1,INPUT+1     COPY 1ST NUMBER\n         MVC   DIRADIX2,INPUT+17   COPY RADIX 2ND NUMBER\n         MVC   DIDATA2,INPUT+18    COPY 2ND NUMBER\n         MVC   DIRADIX3,INPUT+34   COPY RADIX RESULT\n         MVC   SC6LN13N,=CL50' '   CLEAR RESULT DATA\n        $FS    SF=NORMAL,MF=(I,SC6LN08I) SET NORMAL INPUT\n        $FS    SF=NORMAL,MF=(I,SC6LN09I)  \" \"\n        $FS    SF=NORMAL,MF=(I,SC6LN10I)  \" \"\n        $FS    SF=NORMAL,MF=(I,SC6LN11I)  \" \"\n        $FS    SF=NORMAL,MF=(I,SC6LN14I)  \" \"\n        $FS    SBA=(8,5),MF=(I,SC6CSRP) SET CURSOR TO 1ST NUMBER\n         XR    R7,R7\nRMULRCA  MVC   SC6LN24,ENDLNE04    POST GOOD MESSAGE\n         LTR   R7,R7\n         BZ    RMULINIT\n        $FS    SF=NORMAL,MF=(I,(R7)) RESET ERROR INPUT\n         XR    R7,R7\nRMULINIT MVC   SC6LN09R,DIRADIX1   PUT DATA INTO SCREEN\n         MVC   SC6LN11R,DIRADIX2\n         MVC   SC6LN14R,DIRADIX3\n         MVC   SC6LN08N,DIDATA1\n         MVC   SC6LN10N,DIDATA2\nRMULLOOP LM    R0,R2,=A(SCREEN6,LSCREEN6,RSCRT6)\n         STM   R0,R2,ASCRIPTR      STORE PTR'S\n        #GO    FULLSCR             GO DO DEMO SCREEN WORK\n         B     *+L'*(R15)          HOW COMPLETE?\n         B     R$MULX              0 - RETURN TO MENU - WILD GOTO\n         B     R$MULX              4 - ERROR\n         LTR   R1,R1               8 - DID USER TYPE IN?\n         BZ    RMULLOOP            NO, PUT SCREEN BACK OUT\n         BP    *+L'*+8             YES, GO PROCESS\n         MVI   INPUT+0,C' '        ELSE, RESET OPTION MENU\n         B     R$MULX              AND RETURN TO MENU\n        #GO    DYADIC              GO DO PRELIMINARY EDITING\n         MVC   SC6LN13N,=CL50' '   CLEAR RESULT AREA\n         B     *+L'*(R15)          BRANCH ON RETURN CODE\n         B     RMUL00              EDITING/CONVERSION OK\n         B     RMUL04              ERROR, RC=04\n         B     RMUL08              ERROR, RC=08\n         B     RMUL12              ERROR, RC=12\n         B     RMUL16              ERROR, RC=16\n         B     RMUL20              ERROR, RC=20\nRMUL00  $FS    SBA=(8,5),MF=(I,SC6CSRP) SET CURSOR TO 1ST NUMBER\n         ZAP   RESULT3,RESULT1     SHIFT FIRST RESULT\n         MP    RESULT3,RESULT2+9(7) MULTIPLY BY SECOND RESULT\n         ZAP   RESULT99,RESULT3    CAPTURE CURRENT RESULT\n         MVI   RESULTSW,C'1'       INDICATE CURRENT RESULT ACTIVE\n         MVC   RESULTRD,DIRADIX3   INDICATE CURRENT RESULT RADIX\n         CP    RESULT3,=PL1'0'     SET THE CONDITION CODE\n         BL    *+L'*+8             IF NEGATIVE, INSERT -\n         MVI   DHINPUT+L'DHINPUT-1,C'+' MOVE A POSITIVE SIGN\n         B     *+L'*+4             GO TO BYPASS\n         MVI   DHINPUT+L'DHINPUT-1,C'-' INSERT A - SIGN\n         CLI   DIRADIX3,C'D'       DID USER WANT ANSWER IN DEC?\n         BE    RMULYESD            YES, IN DECIMAL\n         UNPK  DHINPUT(L'DHINPUT-1),RESULT3 SET INPUT UP\n         OI    DHINPUT+L'DHINPUT-2,C'0' CLEAR SIGN NIBBLE\n        #GO    DECHEX              CONVERT TO HEX\n         MVC   SC6LN13N+11(L'DHOUTCHR),DHOUTCHR MOVE CONVERTED HEX\n         B     RMULRCA             GO PUT SCREEN BACK OUT\nRMULYESD MVC   SC6LN13N,DECEDIT2   PUT EDIT MASK IN SCREEN\n         ED    SC6LN13N,RESULT3+3  EDIT DECIMAL RESULT\n         CLI   SC6LN13N+L'SC6LN13N-1,C' ' IS SIGN A BLANK\n         BNE   RMULRCA             NO, GO PUT SCREEN BACK OUT\n         MVI   SC6LN13N+L'SC6LN13N-1,C'+' YES, REPLACE WITH A +\n         B     RMULRCA             GO PUT SCREEN BACK OUT\nRMUL04  $FS    SBA=(9,31),MF=(I,SC6CSRP) RESET CURSOR POSITION\n         LA    R2,SC6LN09I\n         B     RMULBAD\nRMUL08  $FS    SBA=(11,31),MF=(I,SC6CSRP) RESET CURSOR POSITION\n         LA    R2,SC6LN11I\n         B     RMULBAD\nRMUL12  $FS    SBA=(14,46),MF=(I,SC6CSRP) RESET CURSOR POSITION\n         LA    R2,SC6LN14I\n         B     RMULBAD\nRMUL16  $FS    SBA=(8,5),MF=(I,SC6CSRP) RESET CURSOR POSITION\n         LA    R2,SC6LN08I\n         B     RMULBAD\nRMUL20  $FS    SBA=(10,5),MF=(I,SC6CSRP) RESET CURSOR POSITION\n         LA    R2,SC6LN10I\nRMULBAD  LTR   R7,R7\n         BZ    RMULBADX\n        $FS    SF=NORMAL,MF=(I,(R7)) RESET ERROR INPUT\nRMULBADX LR    R7,R2\n         MVC   SC6LN24,ENDLNE05    PUT OUT ERROR MESSAGE\n        $FS    SF=(INT),MF=(I,(R7)) SET ERROR INPUT\n         B     RMULINIT\nR$MULX  $XRET  CC=(R15)\n         SPACE 1\n        LTORG\n         SPACE 1\nSCREEN6  $FS   CC=EW,WCC=(KBR,RMDT),SBA=(1,1),RA=(1,1,00),MF=L\n         $FS   SBA=(1,1),SF=(SKIP,INT),MF=L\n         $FS   SBA=(1,19),MF=L\n         $FS   TEXT='T S O   A R I T H M E T I C   C O M M A N D',MF=L\n         $FS   SBA=(2,1),RA=(3,1,-),MF=L\n         $FS   SBA=(4,10),SF=(SKIP),MF=L\n         $FS   TEXT='====   M U L T I P L I C A T I O N   ',MF=L\n         $FS   TEXT='P R O C E S S O R   ====',MF=L\n         $FS   SBA=(5,80),SF=(SKIP,INT),MF=L\n         $FS   RA=(7,1,-),MF=L\n         $FS   SBA=(8,1),SF=(SKIP),TEXT='1:',MF=L\nSC6LN08I $FS   SF=NORMAL,MF=L\nSC6LN08N $FS   TEXT=(' ',16),MF=L\n         $FS   SF=(SKIP,INT),TEXT='<====',MF=L\n         $FS   SF=(SKIP),TEXT='Enter',MF=L\n         $FS   SF=(SKIP,INT),TEXT='1st #',MF=L\n         $FS   SF=(SKIP),TEXT='to multiply (multiplicand)',MF=L\n         $FS   SBA=(9,27),SF=(SKIP),TEXT='2:',MF=L\nSC6LN09I $FS   SF=NORMAL,MF=L\nSC6LN09R $FS   TEXT=(' ',1),MF=L\n         $FS   SF=(SKIP,INT),TEXT='<====',MF=L\n         $FS   SF=(SKIP),TEXT='Enter',MF=L\n         $FS   SF=(SKIP,INT),TEXT='Radix',MF=L\n         $FS   SBA=(10,1),SF=(SKIP),TEXT='3:',MF=L\nSC6LN10I $FS   SF=NORMAL,MF=L\nSC6LN10N $FS   TEXT=(' ',16),MF=L\n         $FS   SF=(SKIP,INT),TEXT='<====',MF=L\n         $FS   SF=(SKIP),TEXT='Enter',MF=L\n         $FS   SF=(SKIP,INT),TEXT='2nd #',MF=L\n         $FS   SF=(SKIP),TEXT='to multiply (multiplier)',MF=L\n         $FS   SBA=(11,27),SF=(SKIP),TEXT='4:',MF=L\nSC6LN11I $FS   SF=NORMAL,MF=L\nSC6LN11R $FS   TEXT=(' ',1),MF=L\n         $FS   SF=(SKIP,INT),TEXT='<====',MF=L\n         $FS   SF=(SKIP),TEXT='Enter',MF=L\n         $FS   SF=(SKIP,INT),TEXT='Radix',MF=L\n         $FS   SF=(SKIP),MF=L\n         $FS   SBA=(12,2),TEXT='------------------',MF=L\n         $FS   TEXT='----------------',MF=L\n         $FS   SBA=(13,1),SF=(SKIP,INT),MF=L\nSC6LN13N $FS   TEXT=(' ',34),MF=L\n         $FS   SF=(SKIP),TEXT='<====',MF=L\n         $FS   SF=(SKIP,INT),TEXT='Product',MF=L\n         $FS   SF=(SKIP),RA=(13,80,=),MF=L\n         $FS   SBA=(14,42),SF=(SKIP),TEXT='5:',MF=L\nSC6LN14I $FS   SF=NORMAL,MF=L\nSC6LN14R $FS   TEXT=(' ',1),MF=L\n         $FS   SF=(SKIP,INT),TEXT='<====',MF=L\n         $FS   SF=(SKIP),TEXT='Enter',MF=L\n         $FS   SF=(SKIP,INT),TEXT='Radix',MF=L\n         $FS   SF=(SKIP),MF=L\n         $FS   SBA=(17,1),SF=(SKIP,INT),TEXT='1:',MF=L\n         $FS   SF=(SKIP),TEXT='Enter 1st # to multiply, please ',MF=L\n         $FS   TEXT='make sure item (2) is equivalent',MF=L\n         $FS   SBA=(18,1),SF=(SKIP,INT),TEXT='2:',MF=L\n         $FS   SF=(SKIP),TEXT='Enter Radix of 1st # to multiply ',MF=L\n         $FS   TEXT='(D=Decimal, X=Hexadecimal)',MF=L\n         $FS   SBA=(19,1),SF=(SKIP,INT),TEXT='3:',MF=L\n         $FS   SF=(SKIP),TEXT='Enter 2nd # to multiply, please',MF=L\n         $FS   TEXT=' make sure item (4) is equivalent',MF=L\n         $FS   SBA=(20,1),SF=(SKIP,INT),TEXT='4:',MF=L\n         $FS   SF=(SKIP),TEXT='Enter Radix of 2nd # to ',MF=L\n         $FS   TEXT='multiply (D=Decimal, X=Hexadecimal)',MF=L\n         $FS   SBA=(21,1),SF=(SKIP,INT),TEXT='5:',MF=L\n         $FS   SF=(SKIP),TEXT='Enter Radix you would display ',MF=L\n         $FS   TEXT='the product (D=Decimal, X=Hexadecimal)',MF=L\n         $FS   SBA=(23,80),MF=L\nSC6LN24  $FS   TEXT=(' ',88),MF=L\nSC6CSRP  $FS   SBA=(8,5),SF=(IC),MF=L\nLSCREEN6 EQU   *-SCREEN6\n         SPACE 1\n         DROP  R9\n         EJECT\n*------> INPUT \"SCREEN6\" PROCESS ROUTINE.\n*        AT EXIT : R1=INPUT TRUE LENGTH AND R3=INPUT SCAN LENGTH.\n         SPACE 1\nRSCRT6  $XENT  BASE=(R9)\n         XR    R2,R2               INITIAL COUNT\nR6LOOP  @FSR   ,                   GET REPLY TEXT\n         LTR   R15,R15             NO MORE FIELDS MODIFIED?\n         BNZ   R6PRCD              NO\n         L     R1,4(R13)           YES, END, GET PREVIOUS SAVE AREA\n         ST    R2,24(R1)           PASS BACK COUNT IN R1\n         LA    R2,35               AND INPUT SCAN LENGTH IN R3\n         ST    R2,32(R1)\n         XR    R15,R15             EXIT\n        $XRET  CC=(R15)\nR6PRCD   CLC   SC6CSF1,0(R15)\n         BE    R6FL1\n         CLC   SC6CSF2,0(R15)\n         BE    R6FL2\n         CLC   SC6CSF3,0(R15)\n         BE    R6FL3\n         CLC   SC6CSF4,0(R15)\n         BE    R6FL4\n         CLC   SC6CSF5,0(R15)\n         BE    R6FL5\n         B     R6LOOP              UNEXPECTED (CHECK SCREEN IMAGE)\nR6FL1    LTR   R1,R1\n         BZ    R6FC1               FIELD CLEARED (CANC FC)\n         CH    R1,=H'1'\n         BNE   R6LOOP              UNEXPECTED (CHECK SCREEN IMAGE)\n         MVI   INPUT+0,C' '        FOR UPPERCASE\n         OC    INPUT+0(1),3(R15)   COPY RADIX OF 1ST NUMBER\n         B     R6BF1\nR6FC1    MVI   INPUT+0,C' '        RADIX OF 1ST NUMBER CLEARED\nR6BF1    LA    R2,1(R2)            BUMP COUNT\n         B     R6LOOP\nR6FL2    LTR   R1,R1\n         BZ    R6FC2               FIELD CLEARED (CANC FC)\n         CH    R1,=H'16'\n         BH    R6LOOP              UNEXPECTED (CHECK SCREEN IMAGE)\n         MVC   INPUT+1(16),=CL50' ' FOR UPPERCASE\n         SH    R1,=H'1'\n         EX    R1,R6OF2            COPY 1ST NUMBER VALUE\n         B     R6BF2\nR6FC2    MVC   INPUT+1(16),=CL50' ' 1ST NUMBER VALUE CLEARED\nR6BF2    LA    R2,16(R2)           BUMP COUNT\n         B     R6LOOP\nR6OF2    OC    INPUT+1(*-*),3(R15) <<EXECUTED>>\nR6FL3    LTR   R1,R1\n         BZ    R6FC3               FIELD CLEARED (CANC FC)\n         CH    R1,=H'1'\n         BNE   R6LOOP              UNEXPECTED (CHECK SCREEN IMAGE)\n         MVI   INPUT+17,C' '       FOR UPPERCASE\n         OC    INPUT+17(1),3(R15)  COPY RADIX OF 2ND NUMBER\n         B     R6BF3\nR6FC3    MVI   INPUT+17,C' '       RADIX OF 2ND NUMBER CLEARED\nR6BF3    LA    R2,1(R2)            BUMP COUNT\n         B     R6LOOP\nR6FL4    LTR   R1,R1\n         BZ    R6FC4               FIELD CLEARED (CANC FC)\n         CH    R1,=H'16'\n         BH    R6LOOP              UNEXPECTED (CHECK SCREEN IMAGE)\n         MVC   INPUT+18(16),=CL50' ' FOR UPPERCASE\n         SH    R1,=H'1'\n         EX    R1,R6OF4            COPY 2ND NUMBER VALUE\n         B     R6BF4\nR6FC4    MVC   INPUT+18(16),=CL50' ' 2ND NUMBER VALUE CLEARED\nR6BF4    LA    R2,16(R2)           BUMP COUNT\n         B     R6LOOP\nR6OF4    OC    INPUT+18(*-*),3(R15) <<EXECUTED>>\nR6FL5    LTR   R1,R1\n         BZ    R6FC5               FIELD CLEARED (CANC FC)\n         CH    R1,=H'1'\n         BNE   R6LOOP              UNEXPECTED (CHECK SCREEN IMAGE)\n         MVI   INPUT+34,C' '       FOR UPPERCASE\n         OC    INPUT+34(1),3(R15)  COPY RADIX OF RESULT\n         B     R6BF5\nR6FC5    MVI   INPUT+34,C' '       RADIX OF RESULT CLEARED\nR6BF5    LA    R2,1(R2)            BUMP COUNT\n         B     R6LOOP\nSC6CSF1  $FS   SBA=(9,31),MF=L\nSC6CSF2  $FS   SBA=(8,5),MF=L\nSC6CSF3  $FS   SBA=(11,31),MF=L\nSC6CSF4  $FS   SBA=(10,5),MF=L\nSC6CSF5  $FS   SBA=(14,46),MF=L\n         SPACE 1\n        LTORG\n         SPACE 1\n         DROP  R9\n         EJECT\n*------> THIS ROUTINE PROCESSES THE DIVIDE SCREEN.\n*        AT EXIT : R15 = 0, 4 OR 8.\n         SPACE 1\nRTN$DIV $XENT  BASE=(R9)\n         MVI   INPUT+0,DEFRADIX    INIT RADIX\n         MVI   INPUT+17,DEFRADIX\n         MVI   INPUT+34,DEFRADIX\n         MVC   INPUT+1(16),=CL50' ' INIT TO SPACE\n         CLI   RESULTSW,C'1'       IS THERE A CURRENT RESULT?\n         BNE   RDIVNOCR            NO, BYPASS\n         CLI   RESULTRD,C'D'       IS CURRENT RESULT DECIMAL?\n         BE    RDIVRESD            YES, PROCESS DECIMAL\n         UNPK  DHINPUT,RESULT99    UNPACK IT\n         OI    DHINPUT+L'DHINPUT-1,C'0' CLEAR SIGN NIBBLE\n        #GO    DECHEX              CONVERT NUMBER TO HEX DISPLAY\n         MVC   INPUT+9(L'DHOUTCHR),DHOUTCHR PUT HEX NUMBER IN SCREEN\n         MVI   INPUT+0,C'X'        INDICATE HEX RADIX\n         B     RDIVNOCR            BYPASS DECIMAL CODE\nRDIVRESD MVC   INPUT+1(16),EDUNPK  UNPACK CURRENT RESULT\n         ED    INPUT+1(16),RESULT99+8 EDIT CURRENT RESULT\n         MVI   INPUT+1,C'+'        INIT TO POSITIVE\n         CP    RESULT99,=PL1'0'    SET CONDITION CODE\n         BNL   RDIVNOCR            BYPASS MOVE\n         MVI   INPUT+1,C'-'        SET TO NEGATIVE\nRDIVNOCR MVC   INPUT+18(16),=CL50' ' INIT TO SPACE\n         MVC   DIRADIX1,INPUT+0    COPY RADIX 1ST NUMBER\n         MVC   DIDATA1,INPUT+1     COPY 1ST NUMBER\n         MVC   DIRADIX2,INPUT+17   COPY RADIX 2ND NUMBER\n         MVC   DIDATA2,INPUT+18    COPY 2ND NUMBER\n         MVC   DIRADIX3,INPUT+34   COPY RADIX RESULT\n         MVC   SC7LN13N,=CL50' '   CLEAR RESULT DATA\n         MVC   SC7LN15N,=CL50' '    \" \"\n        $FS    SF=NORMAL,MF=(I,SC7LN08I) SET NORMAL INPUT\n        $FS    SF=NORMAL,MF=(I,SC7LN09I)  \" \"\n        $FS    SF=NORMAL,MF=(I,SC7LN10I)  \" \"\n        $FS    SF=NORMAL,MF=(I,SC7LN11I)  \" \"\n        $FS    SF=NORMAL,MF=(I,SC7LN14I)  \" \"\n        $FS    SBA=(8,5),MF=(I,SC7CSRP) SET CURSOR TO 1ST NUMBER\n         XR    R7,R7\nRDIVRCA  MVC   SC7LN24,ENDLNE04    POST GOOD MESSAGE\n         LTR   R7,R7\n         BZ    RDIVINIT\n        $FS    SF=NORMAL,MF=(I,(R7)) RESET ERROR INPUT\n         XR    R7,R7\nRDIVINIT MVC   SC7LN09R,DIRADIX1   PUT DATA INTO SCREEN\n         MVC   SC7LN11R,DIRADIX2\n         MVC   SC7LN14R,DIRADIX3\n         MVC   SC7LN08N,DIDATA1\n         MVC   SC7LN10N,DIDATA2\nRDIVLOOP LM    R0,R2,=A(SCREEN7,LSCREEN7,RSCRT7)\n         STM   R0,R2,ASCRIPTR      STORE PTR'S\n        #GO    FULLSCR             GO DO DEMO SCREEN WORK\n         B     *+L'*(R15)          HOW COMPLETE?\n         B     R$DIVX              0 - RETURN TO MENU - WILD GOTO\n         B     R$DIVX              4 - ERROR\n         LTR   R1,R1               DID USER TYPE IN?\n         BZ    RDIVLOOP            NO, PUT SCREEN BACK OUT\n         BP    *+L'*+8             YES, GO PROCESS\n         MVI   INPUT+0,C' '        ELSE, RESET OPTION MENU\n         B     R$DIVX              AND RETURN TO MENU\n        #GO    DYADIC              GO DO PRELIMINARY EDITING\n         MVC   SC7LN13N,=CL50' '   CLEAR RESULT AREA\n         MVC   SC7LN15N,=CL50' '    \" \"\n         B     *+L'*(R15)          BRANCH ON RETURN CODE\n         B     RDIV00              EDITING/CONVERSION OK\n         B     RDIV04              ERROR, RC=04\n         B     RDIV08              ERROR, RC=08\n         B     RDIV12              ERROR, RC=12\n         B     RDIV16              ERROR, RC=16\n         B     RDIV20              ERROR, RC=20\nRDIV00  $FS    SBA=(8,5),MF=(I,SC7CSRP) SET CURSOR TO 1ST NUMBER\n         ZAP   RESULT3,RESULT1     SHIFT FIRST RESULT\n         DP    RESULT3,RESULT2+9(7) SUBTRACT SECOND RESULT\n         ZAP   REMAIN,RESULT3+9(7) SAVE THE REMAINDER\n         ZAP   DIVWORK1,RESULT3(9) COPY THE QUOTIENT\n         ZAP   RESULT3,DIVWORK1    COPY IT BACK, EXPANDED\n         ZAP   RESULT99,RESULT3    CAPTURE CURRENT RESULT\n         MVI   RESULTSW,C'1'       INDICATE CURRENT RESULT ACTIVE\n         MVC   RESULTRD,DIRADIX3   INDICATE CURRENT RESULT RADIX\n         CP    RESULT3,=PL1'0'     SET THE CONDITION CODE\n         BL    *+L'*+8             IF NEGATIVE, INSERT -\n         MVI   DHINPUT+L'DHINPUT-1,C'+' MOVE A POSITIVE SIGN\n         B     *+L'*+4             GO TO BYPASS\n         MVI   DHINPUT+L'DHINPUT-1,C'-' INSERT A - SIGN\n         CLI   DIRADIX3,C'D'       DID USER WANT ANSWER IN DEC?\n         BE    RDIVYESD            YES, IN DECIMAL\n         UNPK  DHINPUT(L'DHINPUT-1),RESULT3 SET INPUT UP\n         OI    DHINPUT+L'DHINPUT-2,C'0' CLEAR SIGN NIBBLE\n        #GO    DECHEX              CONVERT TO HEX\n         MVC   SC7LN13N+11(L'DHOUTCHR),DHOUTCHR MOVE CONVERTED HEX\n         B     RDIVREMN\nRDIVYESD MVC   SC7LN13N,DECEDIT2   PUT EDIT MASK IN SCREEN\n         ED    SC7LN13N,RESULT3+3  EDIT DECIMAL RESULT\n         CLI   SC7LN13N+L'SC7LN13N-1,C' ' IS SIGN A BLANK\n         BNE   RDIVREMN            NO\n         MVI   SC7LN13N+L'SC7LN13N-1,C'+' YES, REPLACE WITH A +\nRDIVREMN MVI   DHINPUT+L'DHINPUT-1,C'+' MOVE A POSITIVE SIGN\n         CLI   DIRADIX3,C'D'       DID USER WANT ANSWER IN DEC?\n         BE    RDIVYSD2            YES, IN DECIMAL\n         UNPK  DHINPUT(L'DHINPUT-1),REMAIN  SET INPUT UP\n         OI    DHINPUT+L'DHINPUT-2,C'0' CLEAR SIGN NIBBLE\n        #GO    DECHEX              CONVERT TO HEX\n         MVC   SC7LN15N+11(L'DHOUTCHR),DHOUTCHR MOVE CONVERTED HEX\n         B     RDIVRCA             GO PUT SCREEN BACK OUT\nRDIVYSD2 MVC   SC7LN15N,DECEDIT2   PUT EDIT MASK IN SCREEN\n         ED    SC7LN15N,REMAIN+3   EDIT DECIMAL RESULT\n         CLI   SC7LN15N+L'SC7LN15N-1,C' ' IS SIGN A BLANK\n         BNE   RDIVRCA             NO, GO PUT SCREEN BACK OUT\n         MVI   SC7LN15N+L'SC7LN15N-1,C'+' YES, REPLACE WITH A +\n         B     RDIVRCA             GO PUT SCREEN BACK OUT\nRDIV04  $FS    SBA=(9,31),MF=(I,SC7CSRP) RESET CURSOR POSITION\n         LA    R2,SC7LN09I\n         B     RDIVBAD\nRDIV08  $FS    SBA=(11,31),MF=(I,SC7CSRP) RESET CURSOR POSITION\n         LA    R2,SC7LN11I\n         B     RDIVBAD\nRDIV12  $FS    SBA=(14,46),MF=(I,SC7CSRP) RESET CURSOR POSITION\n         LA    R2,SC7LN14I\n         B     RDIVBAD\nRDIV16  $FS    SBA=(8,5),MF=(I,SC7CSRP) RESET CURSOR POSITION\n         LA    R2,SC7LN08I\n         B     RDIVBAD\nRDIV20  $FS    SBA=(10,5),MF=(I,SC7CSRP) RESET CURSOR POSITION\n         LA    R2,SC7LN10I\nRDIVBAD  LTR   R7,R7\n         BZ    RDIVBADX\n        $FS    SF=NORMAL,MF=(I,(R7)) RESET ERROR INPUT\nRDIVBADX LR    R7,R2\n         MVC   SC7LN24,ENDLNE05    PUT OUT ERROR MESSAGE\n        $FS    SF=(INT),MF=(I,(R7)) SET ERROR INPUT\n         B     RDIVINIT\nR$DIVX  $XRET  CC=(R15)\n         SPACE 1\n        LTORG\n         SPACE 1\nSCREEN7  $FS   CC=EW,WCC=(KBR,RMDT),SBA=(1,1),RA=(1,1,00),MF=L\n         $FS   SBA=(1,1),SF=(SKIP,INT),MF=L\n         $FS   SBA=(1,19),MF=L\n         $FS   TEXT='T S O   A R I T H M E T I C   C O M M A N D',MF=L\n         $FS   SBA=(2,1),RA=(3,1,-),MF=L\n         $FS   SBA=(4,15),SF=(SKIP),MF=L\n         $FS   TEXT='====   D I V I S I O N   ',MF=L\n         $FS   TEXT='P R O C E S S O R   ====',MF=L\n         $FS   SBA=(5,80),SF=(SKIP,INT),MF=L\n         $FS   RA=(7,1,-),MF=L\n         $FS   SBA=(8,1),SF=(SKIP),TEXT='1:',MF=L\nSC7LN08I $FS   SF=NORMAL,MF=L\nSC7LN08N $FS   TEXT=(' ',16),MF=L\n         $FS   SF=(SKIP,INT),TEXT='<====',MF=L\n         $FS   SF=(SKIP),TEXT='Enter',MF=L\n         $FS   SF=(SKIP,INT),TEXT='1st #',MF=L\n         $FS   SF=(SKIP),TEXT='to divide (dividend)',MF=L\n         $FS   SBA=(9,27),SF=(SKIP),TEXT='2:',MF=L\nSC7LN09I $FS   SF=NORMAL,MF=L\nSC7LN09R $FS   TEXT=(' ',1),MF=L\n         $FS   SF=(SKIP,INT),TEXT='<====',MF=L\n         $FS   SF=(SKIP),TEXT='Enter',MF=L\n         $FS   SF=(SKIP,INT),TEXT='Radix',MF=L\n         $FS   SBA=(10,1),SF=(SKIP),TEXT='3:',MF=L\nSC7LN10I $FS   SF=NORMAL,MF=L\nSC7LN10N $FS   TEXT=(' ',16),MF=L\n         $FS   SF=(SKIP,INT),TEXT='<====',MF=L\n         $FS   SF=(SKIP),TEXT='Enter',MF=L\n         $FS   SF=(SKIP,INT),TEXT='2nd #',MF=L\n         $FS   SF=(SKIP),TEXT='to divide (divisor)',MF=L\n         $FS   SBA=(11,27),SF=(SKIP),TEXT='4:',MF=L\nSC7LN11I $FS   SF=NORMAL,MF=L\nSC7LN11R $FS   TEXT=(' ',1),MF=L\n         $FS   SF=(SKIP,INT),TEXT='<====',MF=L\n         $FS   SF=(SKIP),TEXT='Enter',MF=L\n         $FS   SF=(SKIP,INT),TEXT='Radix',MF=L\n         $FS   SF=(SKIP),MF=L\n         $FS   SBA=(12,2),TEXT='------------------',MF=L\n         $FS   TEXT='----------------',MF=L\n         $FS   SBA=(13,1),SF=(SKIP,INT),MF=L\nSC7LN13N $FS   TEXT=(' ',34),MF=L\n         $FS   SF=(SKIP),TEXT='<====',MF=L\n         $FS   SF=(SKIP,INT),TEXT='Quotient',MF=L\n         $FS   SF=(SKIP),RA=(13,80,=),MF=L\n         $FS   SBA=(14,42),SF=(SKIP),TEXT='5:',MF=L\nSC7LN14I $FS   SF=NORMAL,MF=L\nSC7LN14R $FS   TEXT=(' ',1),MF=L\n         $FS   SF=(SKIP,INT),TEXT='<====',MF=L\n         $FS   SF=(SKIP),TEXT='Enter',MF=L\n         $FS   SF=(SKIP,INT),TEXT='Radix',MF=L\n         $FS   SF=(SKIP),MF=L\n         $FS   SBA=(15,1),SF=(SKIP,INT),MF=L\nSC7LN15N $FS   TEXT=(' ',34),MF=L\n         $FS   SF=(SKIP),TEXT='<====',MF=L\n         $FS   SF=(SKIP,INT),TEXT='Remainder',MF=L\n         $FS   SF=(SKIP),RA=(15,80,=),MF=L\n         $FS   SBA=(17,1),SF=(SKIP,INT),TEXT='1:',MF=L\n         $FS   SF=(SKIP),TEXT='Enter dividend, please ',MF=L\n         $FS   TEXT='make sure item (2) is equivalent',MF=L\n         $FS   SBA=(18,1),SF=(SKIP,INT),TEXT='2:',MF=L\n         $FS   SF=(SKIP),TEXT='Enter Radix of dividend ',MF=L\n         $FS   TEXT='(D=Decimal, X=Hexadecimal)',MF=L\n         $FS   SBA=(19,1),SF=(SKIP,INT),TEXT='3:',MF=L\n         $FS   SF=(SKIP),TEXT='Enter divisor, please',MF=L\n         $FS   TEXT=' make sure item (4) is equivalent',MF=L\n         $FS   SBA=(20,1),SF=(SKIP,INT),TEXT='4:',MF=L\n         $FS   SF=(SKIP),TEXT='Enter Radix of divisor ',MF=L\n         $FS   TEXT='(D=Decimal, X=Hexadecimal)',MF=L\n         $FS   SBA=(21,1),SF=(SKIP,INT),TEXT='5:',MF=L\n         $FS   SF=(SKIP),TEXT='Enter Radix you would display ',MF=L\n         $FS   TEXT='the quotient (D=Decimal, X=Hexadecimal)',MF=L\n         $FS   SBA=(23,80),MF=L\nSC7LN24  $FS   TEXT=(' ',88),MF=L\nSC7CSRP  $FS   SBA=(8,5),SF=(IC),MF=L\nLSCREEN7 EQU   *-SCREEN7\n         SPACE 1\n         DROP  R9\n         EJECT\n*------> INPUT \"SCREEN7\" PROCESS ROUTINE.\n*        AT EXIT : R1=INPUT TRUE LENGTH AND R3=INPUT SCAN LENGTH.\n         SPACE 1\nRSCRT7  $XENT  BASE=(R9)\n         XR    R2,R2               INITIAL COUNT\nR7LOOP  @FSR   ,                   GET REPLY TEXT\n         LTR   R15,R15             NO MORE FIELDS MODIFIED?\n         BNZ   R7PRCD              NO\n         L     R1,4(R13)           YES, END, GET PREVIOUS SAVE AREA\n         ST    R2,24(R1)           PASS BACK COUNT IN R1\n         LA    R2,35               AND INPUT SCAN LENGTH IN R3\n         ST    R2,32(R1)\n         XR    R15,R15             EXIT\n        $XRET  CC=(R15)\nR7PRCD   CLC   SC7CSF1,0(R15)\n         BE    R7FL1\n         CLC   SC7CSF2,0(R15)\n         BE    R7FL2\n         CLC   SC7CSF3,0(R15)\n         BE    R7FL3\n         CLC   SC7CSF4,0(R15)\n         BE    R7FL4\n         CLC   SC7CSF5,0(R15)\n         BE    R7FL5\n         B     R7LOOP              UNEXPECTED (CHECK SCREEN IMAGE)\nR7FL1    LTR   R1,R1\n         BZ    R7FC1               FIELD CLEARED (CANC FC)\n         CH    R1,=H'1'\n         BNE   R7LOOP              UNEXPECTED (CHECK SCREEN IMAGE)\n         MVI   INPUT+0,C' '        FOR UPPERCASE\n         OC    INPUT+0(1),3(R15)   COPY RADIX OF 1ST NUMBER\n         B     R7BF1\nR7FC1    MVI   INPUT+0,C' '        RADIX OF 1ST NUMBER CLEARED\nR7BF1    LA    R2,1(R2)            BUMP COUNT\n         B     R7LOOP\nR7FL2    LTR   R1,R1\n         BZ    R7FC2               FIELD CLEARED (CANC FC)\n         CH    R1,=H'16'\n         BH    R7LOOP              UNEXPECTED (CHECK SCREEN IMAGE)\n         MVC   INPUT+1(16),=CL50' ' FOR UPPERCASE\n         SH    R1,=H'1'\n         EX    R1,R7OF2            COPY 1ST NUMBER VALUE\n         B     R7BF2\nR7FC2    MVC   INPUT+1(16),=CL50' ' 1ST NUMBER VALUE CLEARED\nR7BF2    LA    R2,16(R2)           BUMP COUNT\n         B     R7LOOP\nR7OF2    OC    INPUT+1(*-*),3(R15) <<EXECUTED>>\nR7FL3    LTR   R1,R1\n         BZ    R7FC3               FIELD CLEARED (CANC FC)\n         CH    R1,=H'1'\n         BNE   R7LOOP              UNEXPECTED (CHECK SCREEN IMAGE)\n         MVI   INPUT+17,C' '       FOR UPPERCASE\n         OC    INPUT+17(1),3(R15)  COPY RADIX OF 2ND NUMBER\n         B     R7BF3\nR7FC3    MVI   INPUT+17,C' '       RADIX OF 2ND NUMBER CLEARED\nR7BF3    LA    R2,1(R2)            BUMP COUNT\n         B     R7LOOP\nR7FL4    LTR   R1,R1\n         BZ    R7FC4               FIELD CLEARED (CANC FC)\n         CH    R1,=H'16'\n         BH    R7LOOP              UNEXPECTED (CHECK SCREEN IMAGE)\n         MVC   INPUT+18(16),=CL50' ' FOR UPPERCASE\n         SH    R1,=H'1'\n         EX    R1,R7OF4            COPY 2ND NUMBER VALUE\n         B     R7BF4\nR7FC4    MVC   INPUT+18(16),=CL50' ' 2ND NUMBER VALUE CLEARED\nR7BF4    LA    R2,16(R2)           BUMP COUNT\n         B     R7LOOP\nR7OF4    OC    INPUT+18(*-*),3(R15) <<EXECUTED>>\nR7FL5    LTR   R1,R1\n         BZ    R7FC5               FIELD CLEARED (CANC FC)\n         CH    R1,=H'1'\n         BNE   R7LOOP              UNEXPECTED (CHECK SCREEN IMAGE)\n         MVI   INPUT+34,C' '       FOR UPPERCASE\n         OC    INPUT+34(1),3(R15)  COPY RADIX OF RESULT\n         B     R7BF5\nR7FC5    MVI   INPUT+34,C' '       RADIX OF RESULT CLEARED\nR7BF5    LA    R2,1(R2)            BUMP COUNT\n         B     R7LOOP\nSC7CSF1  $FS   SBA=(9,31),MF=L\nSC7CSF2  $FS   SBA=(8,5),MF=L\nSC7CSF3  $FS   SBA=(11,31),MF=L\nSC7CSF4  $FS   SBA=(10,5),MF=L\nSC7CSF5  $FS   SBA=(14,46),MF=L\n         SPACE 1\n        LTORG\n         SPACE 1\n         DROP  R9\n         EJECT\n*------> THIS ROUTINE PROCESSES THE 3270 BUFFER CONVERSION SCREEN.\n*        AT EXIT : R15 = 0, 4 OR 8.\n         SPACE 1\nRTN$SCR $XENT  BASE=(R9)\n         MVI   INPUT+0,C'2'        DEFAULT TO MODEL 2\n         MVC   INPUT+1(2),=CL3'___' UNDERSCORE ROW FIELD\n         MVC   INPUT+3(3),=CL3'___'   \" \"     COLUMN FIELD\n         MVC   INPUT+6(2),=CL3'___'   \" \"     1ST BUFFER ADDR\n         MVC   INPUT+8(2),=CL3'___'   \" \"     2ND BUFFER ADDR\n         MVC   SC8LN09R,=CL7'24,80) ' SET MODEL (SCREEN SIZE)\n         MVC   SC8LN12R,=CL50' '   CLEAR THE DECIMAL ADDRESS\n         MVC   SC8LN13R,=CL50' '    \" \"  THE HEX ADDRESS\n        $FS    SF=NORMAL,MF=(I,SC8LN091) SET NORMAL INPUT\n        $FS    SF=NORMAL,MF=(I,SC8LN121)  \" \"\n        $FS    SF=NORMAL,MF=(I,SC8LN131)  \" \"\n        $FS    SF=NORMAL,MF=(I,SC8LN161)  \" \"\n        $FS    SF=NORMAL,MF=(I,SC8LN171)  \" \"\n         XR    R7,R7\nRSCGOOD $FS    SBA=(9,4),MF=(I,SC8CSRP) RESET THE CURSOR ADDRESS\n         MVC   SC8LN24,ENDLNE04    POST GOOD MESSAGE\n         LTR   R7,R7\n         BZ    RSCINIT\n        $FS    SF=NORMAL,MF=(I,(R7)) RESET ERROR INPUT\n         XR    R7,R7\nRSCINIT  MVC   SC8LN09N,INPUT+0    SET MODEL\n         MVC   SC8LN12N,INPUT+1    SET ROW FIELD\n         MVC   SC8LN13N,INPUT+3    SET COLUMN FIELD\n         MVC   SC8LN16N,INPUT+6    SET 1ST BUFFER ADDR\n         MVC   SC8LN17N,INPUT+8    SET 2ND BUFFER ADDR\nRSCLOOP  LM    R0,R2,=A(SCREEN8,LSCREEN8,RSCRT8)\n         STM   R0,R2,ASCRIPTR      STORE PTR'S\n        #GO    FULLSCR             GO DO DEMO SCREEN WORK\n         B     *+L'*(R15)          HOW COMPLETE?\n         B     R$SCRX              0 - RETURN TO MENU - WILD GOTO\n         B     R$SCRX              4 - ERROR\n         LTR   R1,R1               8 - DID USER TYPE IN?\n         BZ    RSCLOOP             NO, PUT SCREEN BACK OUT\n         BP    *+L'*+8             YES, GO PROCESS\n         MVI   INPUT+0,C' '        YES, RESET OPTION MENU\n         B     R$SCRX              AND RETURN TO MENU\n         CLI   INPUT+0,C'2'        IS IT  A 2?\n         BNE   *+L'*+16            NO, TRY NEXT\n         ZAP   RSCROW,=PL2'24'     YES, SET SCREEN SIZE = 24 * 80\n         ZAP   RSCCOL,=PL2'80'\n         B     RSCSMDL\n         CLI   INPUT+0,C'3'        IS IT  A 3?\n         BNE   *+L'*+16            NO, TRY NEXT\n         ZAP   RSCROW,=PL2'27'     YES, SET SCREEN SIZE = 27 * 132\n         ZAP   RSCCOL,=PL2'132'\n         B     RSCSMDL\n         CLI   INPUT+0,C'4'        IS IT  A 4?\n         BNE   *+L'*+16            NO, TRY NEXT\n         ZAP   RSCROW,=PL2'32'     YES, SET SCREEN SIZE = 32 * 80\n         ZAP   RSCCOL,=PL2'80'\n         B     RSCSMDL\n         CLI   INPUT+0,C'5'        IS IT A 5?\n         BNE   RSCBAD1             NO, POST AS ERROR\n         ZAP   RSCROW,=PL2'43'     YES, SET SCREEN SIZE = 43 * 80\n         ZAP   RSCCOL,=PL2'80'\nRSCSMDL  MVC   SC8LN09R,=CL50' '   SET MODEL (SCREEN SIZE)\n         MVC   WORKDBLW(4),=XL4'40202120'\n         ED    WORKDBLW(4),RSCROW\n         MVC   SC8LN09R(2),WORKDBLW+2\n         MVI   SC8LN09R+2,C','\n         MVC   WORKDBLW(4),=XL4'40202120'\n         ED    WORKDBLW(4),RSCCOL\n         CLI   WORKDBLW+1,C' '\n         BE    *+L'*+14\n         MVC   SC8LN09R+3(3),WORKDBLW+1\n         MVI   SC8LN09R+6,C')'\n         B     *+L'*+10\n         MVC   SC8LN09R+3(2),WORKDBLW+2\n         MVI   SC8LN09R+5,C')'\n         CLC   INPUT+1(2),=CL3'___' DID USER TYPE IN A ROW VALUE?\n         BE    RSCSBAV             NO, MAY BE HE WANTS TO GO BUFFER\n         CLC   INPUT+3(3),=CL3'___' YES, DID USER TYPE IN A COLUMN?\n         BE    RSCBAD3             NO, BUT HE SHOULD HAVE\n         CLC   SC8LN12N,INPUT+1    DID USER TYPE A NEW ROW?\n         BNE   RSCTIT2             YES\n         CLC   SC8LN13N,INPUT+3    DID USER TYPE A NEW COLUMN?\n         BNE   RSCTIT2             YES\n         CLC   SC8LN16N,INPUT+6    DID USER TYPE A NEW 1ST ADDR?\n         BNE   RSCTIT1             YES\n         CLC   SC8LN17N,INPUT+8    DID USER TYPE A NEW 2ND ADDR?\n         BNE   RSCTIT1             YES\n         CLC   SC8LN09N,INPUT+0    DID USER CHANGE MODEL?\n         BNE   RSCTIT2             YES\n         B     RSCLOOP             NO, NOTHING CHANGED\nRSCTIT1  CLC   INPUT+6(2),=CL3'___' DID USER TYPE IN 1ST BUFFER VALUE?\n         BE    RSCTIT2             NO\n         CLC   INPUT+8(2),=CL3'___' DID USER TYPE IN 2ND BUFFER VALUE?\n         BNE   RSCSBAV             YES, HE HAS TO TYPE IN SOMETHING\nRSCTIT2  TRT   INPUT+1(2),TRTDEC   IS THE ROW NUMERIC?\n         BNZ   RSCBAD2             NO, POST ERROR MESSAGE\n         TRT   INPUT+3(3),TRTDEC   IS THE COLUMN NUMERIC?\n         BNZ   RSCBAD3             NO, POST ERROR MESSAGE\n*        --> USER WANTS A ROW/COLUMN TO BUFFER ADDRESS CONVERSION.\n         PACK  RSCFLD1,INPUT+1(2)  PACK THE ROW NUMBER\n         CP    RSCFLD1,RSCROW      HIGHEST ROW POSSIBLE\n         BH    RSCBAD2             POST ERROR MESSAGE\n         PACK  RSCFLD2,INPUT+3(3)  PACK THE COLUMN\n         CP    RSCFLD2,RSCCOL      HIGHEST COLUMN POSSIBLE\n         BH    RSCBAD3             POST ERROR MESSAGE\n         SP    RSCFLD1,=PL1'1'     SUBTRACT 1\n         MP    RSCFLD1,RSCCOL      NO, MULTIPLY BY NUMBER OF COLUMNS\n         AP    RSCFLD1,RSCFLD2     ADD TO GET POSITION NUMBER\n         SP    RSCFLD1,=PL1'1'     SUBTRACT TO GET REL POSITION\n         MVC   WORKDBLW(6),=XL6'402020202120' PUT THE DECIMAL IN SCREEN\n         ED    WORKDBLW(6),RSCFLD1+1\n         MVC   SC8LN12R,WORKDBLW+2\n         UNPK  DHINPUT,RSCFLD1     SET UP FOR TRANSLATION\n         OI    DHINPUT+L'DHINPUT-1,C'0' CLEAR SIGN\n        #GO    DECHEX              CONVERT TO HEX CHARACTERS\n         MVC   SC8LN13R,DHOUTCHR+4 MOVE TO SCREEN\n         LA    R0,L'SC8LN13R-1\n         LA    R1,SC8LN13R\n         CLI   0(R1),C' '\n         BNE   *+L'*+12\n         MVI   0(R1),C'0'\n         LA    R1,1(R1)\n         BCT   R0,*-16\n         DP    RSCFLD1,=PL2'64'    DIVIDE BY BASE 64\n         ZAP   WORKDBLW,RSCFLD1(2) MOVE FOR CONVERSION\n         CVB   R2,WORKDBLW         CONVERT FOR USE AS AN INDEX\n         SLL   R2,1                MULTIPLY BY 2\n         LA    R3,TABLESCR         GET BASE ADDRESS\n         AR    R3,R2               ADD DISPLACEMENT TO BASE\n         MVC   INPUT+6(2),0(R3)    MOVE CHARACTERS FROM TABLE\n         ZAP   WORKDBLW,RSCFLD1+2(2) MOVE FOR CONVERSION\n         CVB   R2,WORKDBLW         CONVERT FOR USE AS AN INDEX\n         SLL   R2,1                MULTIPLY BY 2\n         LA    R3,TABLESCR         GET BASE ADDRESS\n         AR    R3,R2               ADD DISPLACEMENT TO BASE\n         MVC   INPUT+8(2),0(R3)    MOVE CHARACTERS FROM TABLE\n         B     RSCGOOD             GO POST GOOD MESSAGE AND DISPLAY\nRSCSBAV  CLC   INPUT+6(2),=CL3'___' DID USER TYPE IN A BUFFER VALUE?\n         BE    RSCBAD6             NO, HE HAS TO TYPE IN SOMETHING\n         CLC   INPUT+8(2),=CL3'___' DID USER TYPE IN A BUFFER VALUE?\n         BE    RSCBAD5             NO, HE HAS TO TYPE IN SOMETHING\n*        --> USER WANTS A BUFFER ADDRESS TO ROW/COLUMN CONVERSION.\n         LA    R2,TABLESCR         GET BASE ADDRESS OF TABLE\n         LA    R3,64               GET TABLE LENGTH\n         CLC   INPUT+6(2),0(R2)    IS IT THIS POINT IN TABLE\n         BE    *+L'*+12            YES, BREAK OUT\n         LA    R2,2(R2)            BUMP\n         BCT   R3,*-14             ITERATE\n         B     RSCBAD4             POST ERROR MESSAGE\n         LA    R3,TABLESCR         GET BASE ADDRESS OF TABLE\n         SR    R2,R3               GET OFFSET\n         SRL   R2,1                DIVIDE BY 2\n         SLL   R2,6                MULTIPLY BY 64\n         CVD   R2,WORKDBLW         CONVERT TO DECIMAL\n         ZAP   RSCFLD1,WORKDBLW    PLACE IN SAFE-KEEPING\n         LA    R2,TABLESCR         GET BASE ADDRESS OF TABLE\n         LA    R3,64               GET TABLE LENGTH\n         CLC   INPUT+8(2),0(R2)    IS IT THIS POINT IN TABLE\n         BE    *+L'*+12            YES, BREAK OUT\n         LA    R2,2(R2)            BUMP\n         BCT   R3,*-14             ITERATE\n         B     RSCBAD5             POST ERROR MESSAGE\n         LA    R3,TABLESCR         GET BASE ADDRESS OF TABLE\n         SR    R2,R3               GET OFFSET\n         SRL   R2,1                DIVIDE BY 2\n         CVD   R2,WORKDBLW         CONVERT TO DECIMAL\n         AP    RSCFLD1,WORKDBLW    ADD TO BASE\n         MVC   WORKDBLW(6),=XL6'402020202120' PUT THE DECIMAL IN SCREEN\n         ED    WORKDBLW(6),RSCFLD1+1\n         MVC   SC8LN12R,WORKDBLW+2\n         UNPK  DHINPUT,RSCFLD1     SET UP FOR TRANSLATION\n         OI    DHINPUT+L'DHINPUT-1,C'0' CLEAR SIGN\n        #GO    DECHEX              CONVERT TO HEX CHARACTERS\n         MVC   SC8LN13R,DHOUTCHR+4 MOVE TO SCREEN\n         LA    R0,L'SC8LN13R-1\n         LA    R1,SC8LN13R\n         CLI   0(R1),C' '\n         BNE   *+L'*+12\n         MVI   0(R1),C'0'\n         LA    R1,1(R1)\n         BCT   R0,*-16\n         DP    RSCFLD1,RSCCOL      DIVIDE BY NUMBER OF COLUMNS\n         AP    RSCFLD1+0(2),=PL1'1' ADD 1 TO GET REAL ROW\n         AP    RSCFLD1+2(2),=PL1'1' ADD 1 TO GET REAL COLUMN\n         MVC   WORKDBLW(4),=XL4'40202120' PUT ROW IN SCREEN\n         ED    WORKDBLW(4),RSCFLD1\n         MVC   INPUT+1(2),WORKDBLW+2\n         MVC   WORKDBLW(4),=XL4'40202120' PUT COLUMN IN SCREEN\n         ED    WORKDBLW(4),RSCFLD1+2\n         MVC   INPUT+3(3),WORKDBLW+1\n         B     RSCGOOD             GO POST GOOD MESSAGE AND DISPLAY\nRSCBAD1 $FS    SBA=(9,4),MF=(I,SC8CSRP) RESET CURSOR ADDRESS\n         LA    R2,SC8LN091\n         B     RSCXBAD             GO PAINT SCREEN AGAIN\nRSCBAD2 $FS    SBA=(12,3),MF=(I,SC8CSRP) RESET CURSOR ADDRESS\n         LA    R2,SC8LN121\n         B     RSCXBAD             GO PAINT SCREEN AGAIN\nRSCBAD3 $FS    SBA=(13,2),MF=(I,SC8CSRP) RESET CURSOR ADDRESS\n         LA    R2,SC8LN131\n         B     RSCXBAD             GO PAINT SCREEN AGAIN\nRSCBAD4 $FS    SBA=(16,3),MF=(I,SC8CSRP) RESET CURSOR ADDRESS\n         LA    R2,SC8LN161\n         B     RSCXBAD             GO PAINT SCREEN AGAIN\nRSCBAD5 $FS    SBA=(17,3),MF=(I,SC8CSRP) RESET CURSOR ADDRESS\n         LA    R2,SC8LN171\nRSCXBAD  LTR   R7,R7\n         BZ    RSCBADX\n        $FS    SF=NORMAL,MF=(I,(R7)) RESET ERROR INPUT\nRSCBADX  LR    R7,R2\n         MVC   SC8LN24,ENDLNE05    POST ERROR MESSAGE\n        $FS    SF=(INT),MF=(I,(R7)) SET ERROR INPUT\n         B     RSCBADZ             GO PAINT SCREEN AGAIN\nRSCBAD6 $FS    SBA=(12,3),MF=(I,SC8CSRP) RESET CURSOR ADDRESS\n         MVC   SC8LN24,ENDLNE06    POST CHOOSE MESSAGE\n         LTR   R7,R7\n         BZ    RSCBADZ             GO PAINT SCREEN AGAIN\n        $FS    SF=NORMAL,MF=(I,(R7)) RESET ERROR INPUT\n         XR    R7,R7\nRSCBADZ  MVC   SC8LN12R,=CL50' '   CLEAR THE DECIMAL ADDRESS\n         MVC   SC8LN13R,=CL50' '    \" \"  THE HEX ADDRESS\n         B     RSCINIT             GO PAINT SCREEN AGAIN\nR$SCRX  $XRET  CC=(R15)\n         SPACE 1\n        LTORG\n         SPACE 1\nSCREEN8  $FS   CC=EW,WCC=(KBR,RMDT),SBA=(1,1),RA=(1,1,00),MF=L\n         $FS   SBA=(1,1),SF=(SKIP,INT),MF=L\n         $FS   SBA=(1,19),MF=L\n         $FS   TEXT='T S O   A R I T H M E T I C   C O M M A N D',MF=L\n         $FS   SBA=(2,1),RA=(3,1,-),MF=L\n         $FS   SBA=(4,4),SF=(SKIP),MF=L\n         $FS   TEXT='====   3 2 7 0   B U F F E R   A D D ',MF=L\n         $FS   TEXT='R E S S   P R O C E S S O R   ====',MF=L\n         $FS   SBA=(5,80),SF=(SKIP,INT),MF=L\n         $FS   RA=(7,1,-),MF=L\n         $FS   SBA=(9,3),MF=L\nSC8LN091 $FS   SF=NORMAL,MF=L\nSC8LN09N $FS   TEXT=(' ',1),MF=L\n         $FS   SF=(SKIP,INT),TEXT='<====',MF=L\n         $FS   SF=(SKIP),TEXT='Enter screen',MF=L\n         $FS   SF=(SKIP,INT),TEXT='Model',MF=L\n         $FS   SF=(SKIP),TEXT='number',MF=L\n         $FS   SF=(SKIP,INT),TEXT='(2, 3, 4',MF=L\n         $FS   SF=(SKIP),TEXT='or',MF=L\n         $FS   SF=(SKIP,INT),TEXT='5)',MF=L\n         $FS   SF=(SKIP),TEXT='= ---> Screen',MF=L\n         $FS   SF=(SKIP,INT),TEXT='SIZE=(',MF=L\nSC8LN09R $FS   TEXT=(' ',7),MF=L\n         $FS   SF=(SKIP),MF=L\n         $FS   SBA=(12,2),MF=L\nSC8LN121 $FS   SF=NORMAL,MF=L\nSC8LN12N $FS   TEXT=(' ',2),MF=L\n         $FS   SF=(SKIP,INT),TEXT='<====',MF=L\n         $FS   SF=(SKIP),TEXT='Enter',MF=L\n         $FS   SF=(SKIP,INT),TEXT='ROW',MF=L\n         $FS   SF=(SKIP),TEXT='number',MF=L\n         $FS   SBA=(12,45),MF=L\n         $FS   SF=(SKIP),TEXT='Screen address',MF=L\n         $FS   SF=(SKIP,INT),TEXT='(Decimal) ====> ',MF=L\nSC8LN12R $FS   TEXT=(' ',4),MF=L\n         $FS   SBA=(13,1),MF=L\nSC8LN131 $FS   SF=NORMAL,MF=L\nSC8LN13N $FS   TEXT=(' ',3),MF=L\n         $FS   SF=(SKIP,INT),TEXT='<====',MF=L\n         $FS   SF=(SKIP),TEXT='Enter',MF=L\n         $FS   SF=(SKIP,INT),TEXT='COLUMN',MF=L\n         $FS   SF=(SKIP),TEXT='number',MF=L\n         $FS   SBA=(13,63),SF=(SKIP,INT),TEXT='(Hex) ====> ',MF=L\nSC8LN13R $FS   TEXT=(' ',4),MF=L\n         $FS   SBA=(16,2),MF=L\nSC8LN161 $FS   SF=NORMAL,MF=L\nSC8LN16N $FS   TEXT=(' ',2),MF=L\n         $FS   SF=(SKIP,INT),TEXT='<====',MF=L\n         $FS   SF=(SKIP),TEXT='Enter the',MF=L\n         $FS   SF=(SKIP,INT),TEXT='1st byte',MF=L\n         $FS   SF=(SKIP),TEXT='of the',MF=L\n         $FS   SF=(SKIP,INT),TEXT='Buffer Address',MF=L\n         $FS   SF=(SKIP),MF=L\n         $FS   SBA=(17,2),MF=L\nSC8LN171 $FS   SF=NORMAL,MF=L\nSC8LN17N $FS   TEXT=(' ',2),MF=L\n         $FS   SF=(SKIP,INT),TEXT='<====',MF=L\n         $FS   SF=(SKIP),TEXT='Enter the',MF=L\n         $FS   SF=(SKIP,INT),TEXT='2nd byte',MF=L\n         $FS   SF=(SKIP),TEXT='of the',MF=L\n         $FS   SF=(SKIP,INT),TEXT='Buffer Address',MF=L\n         $FS   SF=(SKIP),MF=L\n         $FS   SBA=(20,1),SF=(SKIP,INT),TEXT='Note:',MF=L\n         $FS   SF=(SKIP),TEXT='If you are converting from',MF=L\n         $FS   SF=(SKIP,INT),TEXT='ROW/COLUMN',MF=L\n         $FS   SF=(SKIP),TEXT='format to',MF=L\n         $FS   SF=(SKIP,INT),TEXT='Buffer Address',MF=L\n         $FS   SF=(SKIP),TEXT='format, do',MF=L\n         $FS   SBA=(21,8),TEXT='not type in the Buffer Address',MF=L\n         $FS   TEXT=' data. If you are converting',MF=L\n         $FS   SF=(SKIP,INT),TEXT='Buffer Address',MF=L\n         $FS   SBA=(22,7),SF=(SKIP),TEXT='to',MF=L\n         $FS   SF=(SKIP,INT),TEXT='ROW/COLUMN',MF=L\n         $FS   SF=(SKIP),TEXT='format, do not type in the ',MF=L\n         $FS   TEXT='ROW/COLUMN data.',MF=L\n         $FS   SBA=(23,80),MF=L\nSC8LN24  $FS   TEXT=(' ',88),MF=L\nSC8CSRP  $FS   SBA=(9,4),SF=(IC),MF=L\nLSCREEN8 EQU   *-SCREEN8\n         SPACE 1\n         DROP  R9\n         EJECT\n*------> INPUT \"SCREEN8\" PROCESS ROUTINE.\n*        AT EXIT : R1=INPUT TRUE LENGTH AND R3=INPUT SCAN LENGTH.\n         SPACE 1\nRSCRT8  $XENT  BASE=(R9)\n         XR    R2,R2               INITIAL COUNT\nR8LOOP  @FSR   ,                   GET REPLY TEXT\n         LTR   R15,R15             NO MORE FIELDS MODIFIED?\n         BNZ   R8PRCD              NO\n         L     R1,4(R13)           YES, END, GET PREVIOUS SAVE AREA\n         ST    R2,24(R1)           PASS BACK COUNT IN R1\n         LA    R2,10               AND INPUT SCAN LENGTH IN R3\n         ST    R2,32(R1)\n         XR    R15,R15             EXIT\n        $XRET  CC=(R15)\nR8PRCD   CLC   SC8CSF1,0(R15)\n         BE    R8FL1\n         CLC   SC8CSF2,0(R15)\n         BE    R8FL2\n         CLC   SC8CSF3,0(R15)\n         BE    R8FL3\n         CLC   SC8CSF4,0(R15)\n         BE    R8FL4\n         CLC   SC8CSF5,0(R15)\n         BE    R8FL5\n         B     R8LOOP              UNEXPECTED (CHECK SCREEN IMAGE)\nR8FL1    LTR   R1,R1\n         BZ    R8FC1               FIELD CLEARED (CANC FC)\n         CH    R1,=H'1'\n         BNE   R8LOOP              UNEXPECTED (CHECK SCREEN IMAGE)\n         MVI   INPUT+0,C' '        FOR UPPERCASE\n         OC    INPUT+0(1),3(R15)   COPY MODEL\n         B     R8BF1\nR8FC1    MVI   INPUT+0,C'_'        MODEL CLEARED\nR8BF1    LA    R2,1(R2)            BUMP COUNT\n         B     R8LOOP\nR8FL2    LTR   R1,R1\n         BZ    R8FC2               FIELD CLEARED (CANC FC)\n         CH    R1,=H'2'\n         BH    R8LOOP              UNEXPECTED (CHECK SCREEN IMAGE)\n         MVC   INPUT+1(2),=CL50' ' FOR UPPERCASE\n         LA    R14,INPUT+2\n         SH    R1,=H'1'\n         SR    R14,R1\n         EX    R1,R8OF2            COPY ROW NUMBER\n         CLI   INPUT+1,C'_'\n         BNE   *+L'*+4\n         MVI   INPUT+1,C' '\n         CLI   INPUT+2,C'_'\n         BNE   *+L'*+4\n         MVI   INPUT+2,C' '\n         CLC   INPUT+1(2),=CL50' '\n         BE    R8FC2\n         CLI   INPUT+2,C' '\n         BNE   R8BF2\n         MVC   INPUT+2(1),INPUT+1\n         MVI   INPUT+1,C' '\n         B     R8BF2\nR8FC2    MVC   INPUT+1(2),=CL3'___' ROW NUMBER CLEARED\nR8BF2    LA    R2,2(R2)            BUMP COUNT\n         B     R8LOOP\nR8OF2    OC    0(*-*,R14),3(R15)   <<EXECUTED>>\nR8FL3    LTR   R1,R1\n         BZ    R8FC3               FIELD CLEARED (CANC FC)\n         CH    R1,=H'3'\n         BH    R8LOOP              UNEXPECTED (CHECK SCREEN IMAGE)\n         MVC   INPUT+3(3),=CL50' ' FOR UPPERCASE\n         LA    R14,INPUT+5\n         SH    R1,=H'1'\n         SR    R14,R1\n         EX    R1,R8OF3            COPY COLUMN NUMBER\n         CLI   INPUT+3,C'_'\n         BNE   *+L'*+4\n         MVI   INPUT+3,C' '\n         CLI   INPUT+4,C'_'\n         BNE   *+L'*+4\n         MVI   INPUT+4,C' '\n         CLI   INPUT+5,C'_'\n         BNE   *+L'*+4\n         MVI   INPUT+5,C' '\n         CLC   INPUT+3(3),=CL50' '\n         BE    R8FC3\nR8SF3    CLI   INPUT+5,C' '\n         BNE   R8BF3\n         MVC   INPUT+5(1),INPUT+4\n         MVC   INPUT+4(1),INPUT+3\n         MVI   INPUT+3,C' '\n         B     R8SF3\nR8FC3    MVC   INPUT+3(3),=CL3'___' ROW NUMBER CLEARED\nR8BF3    LA    R2,3(R2)            BUMP COUNT\n         B     R8LOOP\nR8OF3    OC    0(*-*,R14),3(R15)   <<EXECUTED>>\nR8FL4    LTR   R1,R1\n         BZ    R8FC4               FIELD CLEARED (CANC FC)\n         CH    R1,=H'2'\n         BH    R8LOOP              UNEXPECTED (CHECK SCREEN IMAGE)\n         MVC   INPUT+6(2),=CL50' ' FOR UPPERCASE\n         SH    R1,=H'1'\n         EX    R1,R8OF4            COPY 1ST BUFFER ADDR\n         CLC   INPUT+6(2),=CL50' '\n         BNE   R8BF4\nR8FC4    MVC   INPUT+6(2),=CL3'___' 1ST BUFFER ADDR CLEARED\nR8BF4    LA    R2,2(R2)            BUMP COUNT\n         B     R8LOOP\nR8OF4    OC    INPUT+6(*-*),3(R15) <<EXECUTED>>\nR8FL5    LTR   R1,R1\n         BZ    R8FC5               FIELD CLEARED (CANC FC)\n         CH    R1,=H'2'\n         BH    R8LOOP              UNEXPECTED (CHECK SCREEN IMAGE)\n         MVC   INPUT+8(2),=CL50' ' FOR UPPERCASE\n         SH    R1,=H'1'\n         EX    R1,R8OF5            COPY 2ND BUFFER ADDR\n         CLC   INPUT+8(2),=CL50' '\n         BNE   R8BF5\nR8FC5    MVC   INPUT+8(2),=CL3'___' 2ND BUFFER ADDR CLEARED\nR8BF5    LA    R2,2(R2)            BUMP COUNT\n         B     R8LOOP\nR8OF5    OC    INPUT+8(*-*),3(R15) <<EXECUTED>>\nSC8CSF1  $FS   SBA=(9,4),MF=L\nSC8CSF2  $FS   SBA=(12,3),MF=L\nSC8CSF3  $FS   SBA=(13,2),MF=L\nSC8CSF4  $FS   SBA=(16,3),MF=L\nSC8CSF5  $FS   SBA=(17,3),MF=L\n         SPACE 1\n        LTORG\n         SPACE 1\n         DROP  R9\n         EJECT\n*------> FULL-SCREEN SERVICE ROUTINE (STANDARD 24 X 80 SCREEN).\n*        AT ENTRY, THE ROUTINE HAS THREE INPUTS :\n*              \"ASCRIPTR\" POINTS TO THE SCREEN IMAGE,\n*              \"ASCRLGTH\" POINTS TO THE SCREEN IMAGE LENGTH,\n*              \"ASCRRTN\" POINTS TO THE INPUT SCREEN PROCESS ROUTINE.\n*        AT EXIT : R15 = 0 - RETURN TO MENU, WILD GOTO\n*                        4 - ERROR\n*                        8 - R1 = ZERO -> RESHOW\n*                                 MINUS -> CLEAR AND END\n*                                 PLUS -> ANALYZE INPUT\n         SPACE 1\nFULLSCR $XENT  BASE=(R9)\n*        --> DO FULL-SCREEN TPUT (OUTPUT) AND TGET (INPUT).\n         NI    OPTFS,FSFULL+FSSNAP\n         L     R2,ASCRIPTR\n        @FS    OPTFS,(R2),ASCRLGTH,MF=(E,FSPARM)\n         LTR   R15,R15\n         BZ    FSCHKTX\n         CH    R15,=H'8'           END REQUESTED?\n         BE    *+L'*+8             YES\n         LA    R15,4               NO, ERROR, SET RC=4\n         B     FSX                 EXIT\n         L     R1,=F'-1'           YES (PA-KEY)\n         B     FSRC\nFSCHKTX  LTR   R1,R1               AID?\n         BZ    FSNONE              NO, NONE\n         CLI   0(R1),X'7D'         YES, ENTER KEY?\n         BE    FSENTER             YES\n         CLI   0(R1),X'F1'         NO, PF-KEY 1-9?\n         BL    FSNONE              NO\n         CLI   0(R1),X'F9'\n         BNH   FSPFKEY             YES\nFSNONE   XR    R1,R1               NO, RE-DISPLAY\n         B     FSRC\nFSENTER #GO    ASCRRTN,AR=D        GO TO REPLY ROUTINE\n*        -->   AT EXIT, R1=INPUT TRUE LENGTH AND R3=INPUT SCAN LENGTH.\n         CH    R1,=H'2'            DID WE GET ANYTHING USABLE?\n         BL    FSRC                NO, EXIT\n         XR    R15,R15             SET RC=0\n         LA    R2,INPUT            GET ADDRESS OF INPUT\nFSCHKDIR CLI   0(R2),C'='          DID USER WANT TO GO SOMEWHERE?\n         BE    FSWILDGO            YEP, DO IT TO IT ...\n         LA    R2,1(R2)            BUMP PTR\n         BCT   R3,FSCHKDIR         ITERATE\nFSRC     LA    R15,8               NOT FOUND, SET RC=8\n         L     R14,4(R13)          PREVIOUS SAVE AREA\n         ST    R1,24(R14)          SET BACK R1\n         B     FSX                 EXIT\nFSWILDGO MVC   INPUT+0(1),1(R2)    MOVE THE REQUESTED OPTION\n         OI    INPUT+0,C' '        UPPERCASE IT\n         CLI   INPUT+0,C'X'        WAS IT =X?\n         BNE   FSX                 NO, EXIT\n         MVI   INPUT+0,C' '        YES, RE-DISPLAY MAIN MENU\n         B     FSX                 EXIT\nFSPFKEY  MVC   INPUT+0(1),0(R1)    MOVE THE REQUESTED OPTION\nFSX     $XRET  CC=(R15)\n         SPACE 1\n        LTORG\n         SPACE 1\n         DROP  R9\n         EJECT\n*------> INPUT TO THIS ROUTINE IS AN 8 CHARACTER REPRESENTATION OF A\n*              FULLWORD HEX NUMBER. THIS ROUTINE RIGHT-JUSTIFIES THE\n*              NUMBER, CHECKS IT FOR ALLOWABLE CHARACTERS, PADS IT WITH\n*              ZEROES, AND TRANSLATES IT INTO REAL HEX AND DECIMAL.\n*              INPUT TO THE ROUTINE IS IN HDINPUT, OUTPUT IS HDOUTHEX,\n*              HDOUTDEC, HDINPUT(NORMALIZED), AND HDRC.\n*              HDRC=0 (GOOD), HDRC=1 (BAD).\n         SPACE 1\nHEXDEC  $XENT  BASE=(R9)\n         MVI   HDRC,C'0'           INIT TO GOOD\n*        --> CHECK FOR VALID HEX CHARACTERS.\n         TRT   HDINPUT,TRTHEX      ANY INVALID CHARS?\n         BNZ   HCVDBAD             GO PUT OUT BAD MESSAGE\n*        --> RIGHT-JUSTIFY HEX REPRESENTATION.\n         LA    R2,L'HDINPUT        GET LENGTH OF INPUT\nHCVDFNDB CLI   HDINPUT+L'HDINPUT-1,C' ' IS IT A BLANK?\n         BNE   HCVDNOTB            NO, FINISHED\n         MVC   HDWORK+1(L'HDINPUT-1),HDINPUT MOVE FIRST 7\n         MVI   HDWORK,C' '         REPLACE WITH A BLANK\n         MVC   HDINPUT,HDWORK      MOVE IT BACK\n         BCT   R2,HCVDFNDB         GO TRY NEXT\n         B     HCVDBAD             ALL BLANKS? - PUT OUT ERROR\n*        --> REPLACE LEADING BLANKS WITH ZEROES.\nHCVDNOTB LA    R3,HDINPUT          GET BEGINNING ADDRESS\n         LA    R2,L'HDINPUT        GET LENGTH\nHCVDTRBL CLI   0(R3),C' '          IS IT A BLANK?\n         BNE   HCVDTR              NO, GO TRANSLATE\n         MVI   0(R3),C'0'          CHANGE IT TO A ZERO\n         LA    R3,1(R3)            BUMP INDEX\n         BCT   R2,HCVDTRBL         GO TRY NEXT BYTE\n*        --> CHECK FOR ANY REMAINING BLANKS.\nHCVDTR   MVI   TRTHEX+C' ',X'FF'   CHANGE BLANKS TO INVALID\n         TRT   HDINPUT,TRTHEX      ANY INVALID CHARS?\n         MVI   TRTHEX+C' ',X'00'   RESTORE TRT TABLE\n         BNZ   HCVDBAD             YES, GO PUT OUT BAD MESSAGE\n*        --> TRANSLATE HEX CHARS TO HEX NIBBLES AND CONVERT RADIX.\n         MVC   HDWORK,HDINPUT      COPY INPUT TO WORK\n         TR    HDWORK,TRHEXNIB     TRANSLATE HEX TO NIBBLES\n         LA    R2,L'HDWORK         GET LENGTH\n         LA    R3,HDWORK           GET BEGINNING ADDRESS\n         XR    R4,R4               CLEAR REGISTER\n         XC    WORKDBLW,WORKDBLW   CLEAR WORK AREA\nHCVDLOAD MVC   WORKDBLW+3(1),0(R3) MOVE TRANSLATED CHAR\n         SLL   R4,4                SHIFT LEFT 4 BITS\n         O     R4,WORKDBLW         OR IN THE NIBBLE\n         LA    R3,1(R3)            BUMP INDEX\n         BCT   R2,HCVDLOAD         GO LOAD NEXT NIBBLE\n         ST    R4,HDOUTHEX         STORE HEX OUTPUT\n         CVD   R4,HDOUTDEC         STORE DEC OUTPUT\n*        --> REPLACE LEADING ZEROES WITH BLANKS IN HEX FIELD.\n         LA    R2,L'HDINPUT-1      GET LENGTH -1\n         LA    R3,HDINPUT          GET BEGINNING OF FIELD\nHCVDRPL0 CLI   0(R3),C'0'          IS IT A ZERO?\n         BNE   HEXDECX             NO, EXIT\n         MVI   0(R3),C' '          REPLACE WITH A BLANK\n         LA    R3,1(R3)            BUMP BY 1\n         BCT   R2,HCVDRPL0         ITERATE THROUGH ZERO CHECK\n         B     HEXDECX             BRANCH AROUND ERROR CODE\n*        --> FLAG AS BAD INPUT.\nHCVDBAD  MVI   HDRC,C'1'           FLAG AS BAD\nHEXDECX $XRET  CC=0\n         SPACE 1\n        LTORG\n         SPACE 1\n         DROP  R9\n         EJECT\n*------> INPUT TO THIS ROUTINE IS A 15-DIGIT DECIMAL NUMBER IN\n*              CHARACTER FORMAT. THIS ROUTINE RIGHT-JUSTIFIES THE\n*              NUMBER, CHECKS IT FOR ALLOWABLE CHARACTERS, PADS IT WITH\n*              ZEROES, AND TRANSLATES IT INTO REAL HEX AND DECIMAL.\n*              INPUT TO RTN IS DHINPUT, OUTPUT IS DHOUTHEX, DHOUTDEC,\n*              DHOUTCHR, DHINPUT(NORMALIZED), AND HDRC.\n*              DHRC=0 (GOOD), DHRC=1 (BAD).\n         SPACE 1\nDECHEX  $XENT  BASE=(R9)\n         MVI   DHRC,C'0'           INIT TO GOOD\n         MVI   DHNEG,C'+'          INITIALIZE TO POSITIVE\n*        --> CHECK FOR NEGATIVE SIGN.\n         XC    TRCOMMON,TRCOMMON   CLEAR COMMON TRT AREA\n         MVI   TRCOMMON+C'+',C'+'  INSERT A PLUS SIGN\n         TRT   DHINPUT,TRCOMMON    DID USER TYPE IN A PLUS SIGN?\n         BZ    *+L'*+8             GO TRY DASH\n         MVI   0(R1),C' '          REPLACE PLUS SIGN WITH BLANK\n         B     HCVBRTJS            GO RIGHT-JUSTIFY\n         MVI   TRCOMMON+C'+',X'00' CLEAR PLUS SIGN FROM TRT AREA\n         MVI   TRCOMMON+C'-',C'-'  INSERT A DASH\n         TRT   DHINPUT,TRCOMMON    DID USER TYPE IN NEGATIVE SIGN?\n         BZ    HCVBRTJS            GO RIGHT-JUSTIFY\n         MVI   0(R1),C' '          REPLACE NEG SIGN WITH BLANK\n         MVI   DHNEG,C'-'          SET SIGN SWITCH TO NEGATIVE\n*        --> CHECK FOR ILLEGALS THEN RIGHT-JUSTIFY.\nHCVBRTJS TRT   DHINPUT,TRTDEC      ANY INVALID CHARS?\n         BNZ   HCVBBAD             GO PUT OUT BAD MESSAGE\n         LA    R2,L'DHINPUT        GET LENGTH OF INPUT\nHCVBFNDB CLI   DHINPUT+L'DHINPUT-1,C' ' IS IT A BLANK?\n         BNE   HCVBNOTB            NO, FINISHED\n         MVC   DHWORK+1(L'DHINPUT-1),DHINPUT MOVE FIRST 15\n         MVI   DHWORK,C' '         REPLACE WITH A BLANK\n         MVC   DHINPUT,DHWORK      MOVE IT BACK\n         BCT   R2,HCVBFNDB         GO TRY NEXT\n         B     HCVBBAD             ALL BLANKS? - PUT OUT ERROR\n*        --> REPLACE LEADING BLANKS WITH ZEROES.\nHCVBNOTB LA    R3,DHINPUT          GET BEGINNING ADDRESS\n         LA    R2,L'DHINPUT        GET LENGTH\nHCVBTRBL CLI   0(R3),C' '          IS IT A BLANK?\n         BNE   HCVBTR              NO, GO TRANSLATE\n         MVI   0(R3),C'0'          CHANGE IT TO A ZERO\n         LA    R3,1(R3)            BUMP INDEX\n         BCT   R2,HCVBTRBL         GO TRY NEXT BYTE\n*        --> CHECK FOR ANY REMAINING BLANKS.\nHCVBTR   MVI   TRTDEC+C' ',X'FF'   CHANGE BLANKS TO INVALID\n         TRT   DHINPUT,TRTDEC      ANY INVALID CHARS?\n         MVI   TRTDEC+C' ',X'00'   RESTORE TRT TABLE\n         BNZ   HCVBBAD             YES, GO PUT OUT BAD MESSAGE\n*        --> TRANSLATE DECIMAL NUMBER TO HEX.\n         PACK  DHOUTDEC,DHINPUT    PACK INPUT\n         MVC   DHINPUT(L'DHINPUT-1),DHINPUT+1 SHIFT LEFT 1 BYTE\n         MVC   DHINPUT+L'DHINPUT-1(1),DHNEG INDICATE NEG OR POSITIVE\n         CLI   DHNEG,C'+'          IS IT POSITIVE?\n         BE    *+L'*+8             BYPASS CHANGE SIGN\n         NI    DHOUTDEC+7,X'F0'    TURN OFF BITS IN SIGN\n         OI    DHOUTDEC+7,X'0D'    INDICATE NEGATIVE\n         L     R1,=A(ESPLST)\n        ESPIE  SET,MF=(E,(1))      INTERCEPT INT = 9\n         ST    R1,OLDPICA          OLD PICA ADDRESS\n         CVB   R2,DHOUTDEC         CONVERT TO BINARY\n        ESPIE  RESET,OLDPICA       RESTORE SPIE/ESPIE ENVIRONMENT\n         ST    R2,DHOUTHEX         STORE HEX VERSION\n         LA    R3,L'DHOUTCHR       GET NUMBER OF NIBBLES\n         LA    R4,DHOUTCHR+L'DHOUTCHR-1 GET BEGIN ADDRESS\nHCVBCHR1 STC   R2,0(R4)            STORE LOW-ORDER NIBBLE\n         SRL   R2,4                SHIFT RIGHT ONE NIBBLE\n         BCTR  R4,0                SUBTRACT ONE FROM INDEX\n         BCT   R3,HCVBCHR1         ITERATE THROUGH ZERO CHECK\n         NC    DHOUTCHR,=8XL1'0F'  AND OUT HIGH ORDER NIBBLE\n         TR    DHOUTCHR,TRHEXCHR   TRANSLATE TO REAL CHARACTERS\n*--> REPLACE LEADING ZEROES WITH BLANKS IN HEX FIELD\n         LA    R2,L'DHOUTCHR-1     GET LENGTH -1\n         LA    R3,DHOUTCHR         GET BEGINNING OF FIELD\nHCVBRPL0 CLI   0(R3),C'0'          IS IT A ZERO?\n         BNE   HCVBRPL1            NO, EXIT\n         MVI   0(R3),C' '          REPLACE WITH A BLANK\n         LA    R3,1(R3)            BUMP BY 1\n         BCT   R2,HCVBRPL0         ITERATE THROUGH ZERO CHECK\n*        --> REPLACE LEADING ZEROES WITH BLANKS IN DEC FIELD.\nHCVBRPL1 LA    R2,L'DHINPUT-2      GET LENGTH -2 (LAST IS SIGN)\n         LA    R3,DHINPUT          GET BEGINNING OF FIELD\nHCVBRPL2 CLI   0(R3),C'0'          IS IT A ZERO?\n         BNE   DECHEXX             NO, EXIT\n         MVI   0(R3),C' '          REPLACE WITH A BLANK\n         LA    R3,1(R3)            BUMP BY 1\n         BCT   R2,HCVBRPL2         ITERATE THROUGH ZERO CHECK\n         B     DECHEXX             BYPASS ERROR CODE\nRECOVER ESPIE  RESET,OLDPICA       RESTORE SPIE/ESPIE ENVIRONMENT\n*        --> FLAG AS BAD INPUT.\nHCVBBAD  MVI   DHRC,C'1'           FLAG AS BAD\nDECHEXX $XRET  CC=0\n         SPACE 1\n        LTORG\n         SPACE 1\n         DROP  R9\n         SPACE 1\n         CNOP  0,8\n         USING *,R15\n         USING EPIE,R1\nESPEXIT  MVC   EPIEPSW+4(4),RCVADDR     SET RETURN ADDRESS\n         BR    R14                 BACK TO CONTROL PROGRAM\n         DROP  R1\n         SPACE 1\nRCVADDR  DC    A(RECOVER)\n         SPACE 1\n         DROP  R15\n         EJECT\n*------> THIS ROUTINE HANDLES ALL PRELIMINARY EDITING AND CONVERSION\n*              FOR THE HIGHER LEVEL ROUTINES THAT PERFORM DYADIC\n*              OPERATIONS SUCH AS ADDITION AND MULTIPLICATION.\n*              AT ENTRY TO THE ROUTINE, THE INPUT IS LOCATED IN THE\n*              'INPUT' INPUT BUFFER.\n*        AT EXIT, R15 = 0, 4, 8, 12, 16 or 20.\n         SPACE 1\nDYADIC  $XENT  BASE=(R9)\n         XR    R15,R15             CLEAR RETURN CODE REGISTER\n*        --> MOVE THE INPUT DATA FROM INPUT AREA TO FORMAT AREA.\n         MVC   DIRADIX1,INPUT+0    MOVE RADIX 1\n         MVC   DIDATA1,INPUT+1     MOVE DATA 1\n         MVC   DIRADIX2,INPUT+17   MOVE RADIX 2\n         MVC   DIDATA2,INPUT+18    MOVE DATA 2\n         MVC   DIRADIX3,INPUT+34   MOVE RADIX 3\n*        --> CHECK THAT RADIX ITEMS ARE ALLOWABLE.\n         MVI   TRCOMMON,X'FF'      SET UP TRT AREA\n         MVC   TRCOMMON+1(L'TRCOMMON-1),TRCOMMON\n         MVI   TRCOMMON+C'D',X'00' ALLOW D=DECIMAL\n         MVI   TRCOMMON+C'X',X'00'  \" \"  X=HEX\n         TRT   DIRADIX1,TRCOMMON   RADIX 1 OK?\n         BNZ   DPERR04             GO FLAG ERROR RC=04\n         TRT   DIRADIX2,TRCOMMON   RADIX 2 OK?\n         BNZ   DPERR08             GO FLAG ERROR RC=08\n         TRT   DIRADIX3,TRCOMMON   RADIX 3 OK?\n         BNZ   DPERR12             GO FLAG ERROR RC=12\n*        --> CHECK THE DATA ITEMS FOR DECIMAL.\n         CLI   DIRADIX1,C'D'       DECIMAL?\n         BNE   DPCHKD2             NO, CHECK RADIX 2 : DEC\n         MVC   DHINPUT,DIDATA1     SET INPUT UP\n        #GO    DECHEX              CALL REFORMAT ROUTINE\n         CLI   DHRC,C'1'           DID IT GO OK?\n         BE    DPERR16             NO, FLAG ERROR RC=16\n         MVC   DIDATA1,DHINPUT     MOVE REFORMATTED INPUT\n         ZAP   RESULT1,DHOUTDEC    SAVE RESULT IN RESULT1\nDPCHKD2  CLI   DIRADIX2,C'D'       DECIMAL?\n         BNE   DPCHKX1             NO, CHECK RADIX 1 : HEX\n         MVC   DHINPUT,DIDATA2     SET INPUT UP\n        #GO    DECHEX              CALL REFORMAT ROUTINE\n         CLI   DHRC,C'1'           DID IT GO OK?\n         BE    DPERR20             NO, FLAG ERROR RC=20\n         MVC   DIDATA2,DHINPUT     MOVE REFORMATTED INPUT\n         ZAP   RESULT2,DHOUTDEC    SAVE RESULT IN RESULT2\n*        --> CHECK THE DATA ITEMS FOR HEX; LEFT JUSTIFY AND CONVERT.\nDPCHKX1  CLI   DIRADIX1,C'D'       DECIMAL?\n         BE    DPCHKX2             YES, ALREADY CHECKED ABOVE\n         LA    R2,8                NUMBER OF BYTES\n         LA    R3,DIDATA1          GET BEGINNING ADDRESS\nDPX1LP01 CLI   0(R3),C' '          IS THIS A BLANK?\n         BNE   DPX1LP02            NO, BREAK OUT OF LOOP\n         MVC   DIDATA1(L'DIDATA1-1),DIDATA1+1 SHIFT LEFT ONE BYTE\n         MVI   DIDATA1+L'DIDATA1-1,C' ' CLEAR SLACK BYTE\n         BCT   R2,DPX1LP01         ITERATE 8 TIMES\nDPX1LP02 MVC   HDINPUT,DIDATA1     SET INPUT UP\n        #GO    HEXDEC              CALL REFORMAT ROUTINE\n         CLI   HDRC,C'1'           DID IT GO OK?\n         BE    DPERR16             NO, FLAG ERROR RC=16\n         MVC   DIDATA1+0(8),=CL50' ' CLEAR BEGINNING PART\n         MVC   DIDATA1+8(8),HDINPUT MOVE REFORMATTED INPUT\n         ZAP   RESULT1,HDOUTDEC    SAVE RESULT IN RESULT1\nDPCHKX2  CLI   DIRADIX2,C'D'       DECIMAL?\n         BE    DYADICX             YES, ALREADY CHECKED:EXIT RTN\n         LA    R2,8                NUMBER OF BYTES\n         LA    R3,DIDATA2          GET BEGINNING ADDRESS\nDPX2LP01 CLI   0(R3),C' '          IS THIS A BLANK?\n         BNE   DPX2LP02            NO, BREAK OUT OF LOOP\n         MVC   DIDATA2(L'DIDATA2-1),DIDATA2+1 SHIFT LEFT ONE BYTE\n         MVI   DIDATA2+L'DIDATA2-1,C' ' CLEAR SLACK BYTE\n         BCT   R2,DPX2LP01         ITERATE 8 TIMES\nDPX2LP02 MVC   HDINPUT,DIDATA2     SET INPUT UP\n        #GO    HEXDEC              CALL REFORMAT ROUTINE\n         CLI   HDRC,C'1'           DID IT GO OK?\n         BE    DPERR20             NO, FLAG ERROR RC=20\n         MVC   DIDATA2+0(8),=CL50' ' CLEAR BEGINNING PART\n         MVC   DIDATA2+8(8),HDINPUT MOVE REFORMATTED INPUT\n         ZAP   RESULT2,HDOUTDEC    SAVE RESULT IN RESULT2\n         B     DYADICX             EXIT RTN\nDPERR04  LA    R15,4               INDICATE RADIX 1 NO GOOD\n         B     DYADICX             EXIT RTN\nDPERR08  LA    R15,8               INDICATE RADIX 2 NO GOOD\n         B     DYADICX             EXIT RTN\nDPERR12  LA    R15,12              INDICATE RADIX 3 NO GOOD\n         B     DYADICX             EXIT RTN\nDPERR16  LA    R15,16              INDICATE DATA 1 NOT DECIMAL\n         B     DYADICX             EXIT RTN\nDPERR20  LA    R15,20              INDICATE DATA 2 NOT DECIMAL\nDYADICX $XRET  CC=(R15)\n         SPACE 1\n        LTORG\n         SPACE 1\n         DROP  R9\n         EJECT\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n*          W O R K I N G     S T O R A G E     S E C T I O N          *\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n         SPACE 1\nWORKDBLW DC    D'0'                HEX/DECIMAL CONVERSION AREA\nATIOT    DC    A(*-*)\nATSO     DC    A(*-*)\nAPSCB    DC    A(*-*)\nERRMSA   DC    F'0'\nASCRIPTR DC    A(*-*)              PTR TO ACTIVE SCREEN IMAGE\nASCRLGTH DC    A(*-*)              PTR TO LENGTH OF ACTIVE SCREEN IMAGE\nASCRRTN  DC    A(*-*)              PTR TO PROCESS READ SCREEN ROUTINE\n*                                  INT.CODE :  9 = FIXED-POINT DIVIDE\nESPLST  ESPIE  SET,ESPEXIT,(9),MF=L\nOLDPICA  DC    F'0'                SAVE OLD PICA ADDRESS\nFSPARM  @FS    ,,,MF=L\nFSMSBA   EQU   6*L'SC1CSF1         MAX. = 6 * SCREEN BUFFER ADDRESSES\nFSBFSZ   DC    A((((FSMSBA+L'INPUT)+7)/8)*8) MAX. => L.SBA'S + TEXT\nERRMSL   DC    H'0'\nINPUT    DC    CL50' '             INPUT FROM TERMINAL VIA TGET\nRESULT1  DC    PL16'0'             RESULT 1 FROM DYADIC ROUTINE\nRESULT2  DC    PL16'0'             RESULT 2 FROM DYADIC ROUTINE\nRESULT3  DC    PL16'0'             RESULT 3 FROM PROCESSORS\nREMAIN   DC    PL16'0'             REMAINDER FROM DIVIDE PROCESSOR\nRESULT99 DC    PL16'0'             RESULT FROM LAST OPERATION\nDIVWORK1 DC    PL9'0'              WORK AREA FOR DIVIDE PROC\n         PRINT GEN\nOPTFS   @FSO   ,\n         PRINT &EULST\nRESULTSW DC    CL1'0'              0=NO RESULT99, 1=CURR RESULT99\nRESULTRD DC    CL1'D'              RESULT RADIX = D/X\nMSG1     DC    C' -> \"FSRTNI\" routine failed / RC =    '\nMSG1F1   EQU   MSG1+L'MSG1-4,4\nMSG2     DC    C' -> \"FSRTN\" routine failed - OPT =    , RC =    '\nMSG2F1   EQU   MSG2+35,2\nMSG2F2   EQU   MSG2+L'MSG2-4,4\n*        --> \"END\" line message is 7 SF's + 74 characters long, so,\n*              the needed space is ((7 * 2) + 74) = 88 bytes long.\nENDLNE01 $FS   SF=(SKIP),TEXT='=============>',MF=L\n         $FS   SF=(SKIP),TEXT='Enter menu',MF=L\n         $FS   SF=(SKIP,INT),TEXT='option number',MF=L\n         $FS   SF=(SKIP),TEXT='desired',MF=L\n         $FS   SF=(SKIP),TEXT='then press',MF=L\n         $FS   SF=(SKIP,INT),TEXT='ENTER',MF=L\n         $FS   SF=(SKIP),TEXT='<==============',MF=L\nLEL01    EQU   *-ENDLNE01          THIS VALUE MUST BE X'00058' (88)\nENDLNE02 $FS   SF=(SKIP,INT),TEXT='=================>',MF=L\n         $FS   SF=(SKIP),TEXT='Correct',MF=L\n         $FS   SF=(SKIP,INT),TEXT='option number',MF=L\n         $FS   SF=(SKIP),TEXT='and',MF=L\n         $FS   SF=(SKIP),TEXT='then press',MF=L\n         $FS   SF=(SKIP,INT),TEXT='ENTER',MF=L\n         $FS   SF=(SKIP,INT),TEXT='<=================',MF=L\nLEL02    EQU   *-ENDLNE02          THIS VALUE MUST BE X'00058' (88)\nENDLNE03 $FS   SF=(SKIP,INT),TEXT='================>',MF=L\n         $FS   SF=(SKIP,INT),TEXT='Option',MF=L\n         $FS   SF=(SKIP),TEXT='not in use -',MF=L\n         $FS   SF=(SKIP,INT),TEXT='Correct',MF=L\n         $FS   SF=(SKIP),TEXT='and press',MF=L\n         $FS   SF=(SKIP,INT),TEXT='ENTER',MF=L\n         $FS   SF=(SKIP,INT),TEXT='<=================',MF=L\nLEL03    EQU   *-ENDLNE03          THIS VALUE MUST BE X'00058' (88)\nENDLNE04 $FS   SF=(SKIP),TEXT='======================>',MF=L\n         $FS   SF=(SKIP),TEXT='To',MF=L\n         $FS   SF=(SKIP,INT),TEXT='return',MF=L\n         $FS   SF=(SKIP),TEXT='to menu press',MF=L\n         $FS   SF=(SKIP,INT),TEXT='PA1',MF=L\n         $FS   SF=(SKIP),TEXT='key',MF=L\n         $FS   SF=(SKIP),TEXT='<=======================',MF=L\nLEL04    EQU   *-ENDLNE04          THIS VALUE MUST BE X'00058' (88)\nENDLNE05 $FS   SF=(SKIP,INT),TEXT='===========>',MF=L\n         $FS   SF=(SKIP,INT),TEXT='Invalid value',MF=L\n         $FS   SF=(SKIP),TEXT='entered, please',MF=L\n         $FS   SF=(SKIP,INT),TEXT='correct',MF=L\n         $FS   SF=(SKIP),TEXT='and press',MF=L\n         $FS   SF=(SKIP,INT),TEXT='ENTER',MF=L\n         $FS   SF=(SKIP,INT),TEXT='<============',MF=L\nLEL05    EQU   *-ENDLNE05          THIS VALUE MUST BE X'00058' (88)\nENDLNE06 $FS   SF=(SKIP,INT),TEXT='=================>',MF=L\n         $FS   SF=(SKIP,INT),TEXT='Choose',MF=L\n         $FS   SF=(SKIP),TEXT='either',MF=L\n         $FS   SF=(SKIP,INT),TEXT='Row/Column',MF=L\n         $FS   SF=(SKIP),TEXT='or',MF=L\n         $FS   SF=(SKIP,INT),TEXT='Buffer Address',MF=L\n         $FS   SF=(SKIP,INT),TEXT='<=================',MF=L\nLEL06    EQU   *-ENDLNE06          THIS VALUE MUST BE X'00058' (88)\nEDUNPK   DC    XL16'40202020202020202020202020202120'\n         AIF   ('&EUEDN' EQ 'EUROPE').EDN1\nDECEDIT  DC    XL21'402020206B2020206B2020206B2020206B20212060'\nDECEDIT2 DC    XL18'40202020206B2020206B2020206B2020206B'\n         DC    XL16'2020206B2020206B2020206B20212060'\n         AGO   .EDN2\n.EDN1    ANOP\nDECEDIT  DC    XL21'402020204B2020204B2020204B2020204B20212060'\nDECEDIT2 DC    XL18'40202020204B2020204B2020204B2020204B'\n         DC    XL16'2020204B2020204B2020204B20212060'\n.EDN2    ANOP\n*        --> WORK DATA ITEMS FOR 3270 TRANSLATION ROUTINE.\nRSCFLD1  DS    F                   WORK AREA\nRSCFLD2  DS    F                   WORK AREA\nRSCROW   DS    PL2                 SCREEN NUMBER OF ROWS\nRSCCOL   DS    PL2                 SCREEN NUMBER OF COLUMNS\n*        --> WORK DATA ITEMS FOR HEXDEC ROUTINE.\n         DS    0D\nHDINPUT  DS    CL8                 INPUT TO HEXDEC RTN\nHDWORK   DS    CL8                 WORKAREA FOR HEXDEC RTN\nHDOUTDEC DS    PL8                 OUTPUT FROM HEXDEC RTN:DEC\nHDOUTHEX DS    F                   OUTPUT FROM HEXDEC RTN:HEX\nHDRC     DS    CL1                 RETURN CODE FROM HEXDEC RTN\n*        --> WORK DATA ITEMS FOR DECHEX ROUTINE.\n         DS    0D\nDHOUTDEC DS    PL8                 OUTPUT FROM DECHEX RTN:DEC\nDHINPUT  DS    CL16                INPUT TO DECHEX RTN\nDHWORK   DS    CL16                WORKAREA FOR DECHEX RTN\nDHOUTCHR DS    CL8                 OUTPUT FROM DECHEX RTN:CHAR\nDHOUTHEX DS    F                   OUTPUT FROM DECHEX RTN:HEX\nDHRC     DS    CL1                 RETURN CODE FROM DECHEX RTN\nDHNEG    DC    CL1'+'              '+'=POS, '-'=NEG\n*        --> WORK AREA FOR THE DYADIC ROUTINE.\nDIDATA1  DS    CL16                DATA NUMBER 1\nDIDATA2  DS    CL16                DATA NUMBER 2\nDEFRADIX EQU   C'D'                DEFAULT RADIX\nDIRADIX1 DS    CL1                 D=DECIMAL, X=HEX\nDIRADIX2 DS    CL1                 D=DECIMAL, X=HEX\nDIRADIX3 DS    CL1                 D=DECIMAL, X=HEX\n*        --> TRT TABLES.\n         DS    0D\nTRTHEX   DC    256XL1'FF'          ALL CHARS OTHER THAN\n         ORG   TRTHEX+C'0'\n         DC    10XL1'00'               0-9\n         ORG   TRTHEX+C'A'\n         DC    6XL1'00'                A-F\n         ORG   TRTHEX+C' '\n         DC    1XL1'00'                BLANK\n         ORG\nTRTDEC   DC    256XL1'FF'          ALL CHARS OTHER THAN\n         ORG   TRTDEC+C'0'\n         DC    10XL1'00'               0-9\n         ORG   TRTDEC+C' '\n         DC    1XL1'00'                BLANK\n         ORG\nTRHEXNIB DC    256XL1'00'          DEFAULT CHARACTERS ARE ZERO\n         ORG   TRHEXNIB+C'0'\n         DC    XL10'00010203040506070809' 0-9\n         ORG   TRHEXNIB+C'A'\n         DC    XL6'0A0B0C0D0E0F'       A-F\n         ORG\nTRCOMMON DC    XL256'00'           COMMON TRT AREA\nTRHEXCHR DC    CL16'0123456789ABCDEF' TRANSLATE HEX TO HEX CHARS\n*        --> IBM 3270 BASE 64 ENCODING TABLE.\n*              (IS THERE A ROUTINE SOMEWHERE?)\nTABLESCR DC    C'40C1C2C3C4C5C6C7C8C94A4B4C4D4E4F'\n         DC    C'50D1D2D3D4D5D6D7D8D95A5B5C5D5E5F'\n         DC    C'6061E2E3E4E5E6E7E8E96A6B6C6D6E6F'\n         DC    C'F0F1F2F3F4F5F6F7F8F97A7B7C7D7E7F'\n         SPACE 1\n*- - - - DSECT'S - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n         PRINT NOGEN\n        IKJCPPL\n        IKJPSCB\n        IKJEBECA\nTIODSECT DSECT\n        IEFTIOT1\n        IHAEPIE\n        PRINT  GEN\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ARITH$": {"ttr": 2308, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x942\\x7f\\x00\\x942\\x7f\\x14#\\x00\\x18\\x00\\x18\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-23T00:00:00", "modifydate": "1994-11-23T14:23:00", "lines": 24, "newlines": 24, "modlines": 0, "user": "SYSPAJA"}, "text": "//ARITH    JOB (........),'INSTALL  -ARITH-',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=1M,TIME=1\n/*JOBPARM L=6\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//* PRE-REQUISITE MODULES INSTALLATION :                              *\n//*                FSRTN                                              *\n//*      THE ASSEMBLY SYSPARM(...) OPTIONS ALLOWS YOU TO SELECT :     *\n//*            1. NONE OR OMITTED = NO LIST OF MACROS DEVELOPMENT     *\n//*               FULL = LIST ALL MACROS DEVELOPMENT                  *\n//*            2. US OR OMITTED = EDIT NUMBERS AS USUAL IN USA        *\n//*               EU = EDIT NUMBERS AS EUROPEAN LIKE IT               *\n//*      SPECIFY OPTIONS AT ASSEMBLY STEP 'ASS' :                     *\n//*      I.E - ... EXEC PAJ1AS3,MBR=ARITH,OPT=',SYSPARM(FULL)'        *\n//*            ... EXEC PAJ1AS3,MBR=ARITH,OPT=',SYSPARM(,EU)'         *\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//ASS     EXEC PAJ1AS3,MBR=ARITH\n//LNK     EXEC PAJILKC\n//SYSIN     DD *\n  INCLUDE SYSADD(FSRTN)\n  ENTRY   ARITH\n  ALIAS   AR\n  NAME    ARITH(R)\n/*\n//HLP     EXEC PAJHELP,MBR=ARITHH,DSS='->.SOURCE.FILE1'\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ARITH@": {"ttr": 2310, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x934?\\x00\\x934?\\x11C\\x00#\\x00#\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-12-09T00:00:00", "modifydate": "1993-12-09T11:43:00", "lines": 35, "newlines": 35, "modlines": 0, "user": "SYSPAJA"}, "text": "1   09/12/93\n                                                      ARITH     1/1.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *       HEX/DECIMAL ARITHMETIC.       * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  CBT origin : Extracted from CBT tape 93 AUG, file 173.\n  ------------\n\n  Function :  To do HEX and DECIMAL integer arithmetic on 3278/9 CRT\n  ----------  terminals in full-screen mode.\n\n  Syntax :    ARITH or AR (alias)\n  --------    Description : The purpose of this command is to do HEX\n                   and DECIMAL integer arithmetic in full-screen mode\n                   on 3278/9 CRT terminals. The command is menu driven.\n              In addition HEX and DECIMAL arithmetic, an option is\n                   available to do HEX to DECIMAL and DECIMAL to HEX\n                   conversions. Another option gives the user ability\n                   to convert 3270 Screen and Buffer Addresses to\n                   Row/Column Addresses, and vice versa.\n              To get back to the menu screen from any of the option\n                   screens, simply press the PA1 (ATTN) key. Another\n                   way of doing this is to enter =X and press ENTER.\n                   In fact, you can get around in ARITH if you can\n                   remember the option numbers by entering an = sign\n                   followed by the option number and pressing ENTER\n                   (=0 will return to TSO).\n              Also the PF-keys for corresponding options (1-9) are\n                   availables.\n  Operands :  None, other than as specified above.\n  ----------\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ARITHH": {"ttr": 2312, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x934?\\x00\\x934?\\x11B\\x00\\x19\\x00\\x19\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-12-09T00:00:00", "modifydate": "1993-12-09T11:42:00", "lines": 25, "newlines": 25, "modlines": 0, "user": "SYSPAJA"}, "text": "./     ADD     NAME=ARITH\n./     NUMBER  NEW1=100,INCR=100\n)F Function : To do HEX and DECIMAL integer arithmetic on 3278/9 CRT\n              terminals in full-screen mode.\n)X Syntax :   ARITH or AR (alias)\n              Description : The purpose of this command is to do HEX\n                   and DECIMAL integer arithmetic in full-screen mode\n                   on 3278/9 CRT terminals. The command is menu driven.\n              In addition HEX and DECIMAL arithmetic, an option is\n                   available to do HEX to DECIMAL and DECIMAL to HEX\n                   conversions. Another option gives the user ability\n                   to convert 3270 Screen and Buffer Addresses to\n                   Row/Column Addresses, and vice versa.\n              To get back to the menu screen from any of the option\n                   screens, simply press the PA1 (ATTN) key. Another\n                   way of doing this is to enter =X and press ENTER.\n                   In fact, you can get around in ARITH if you can\n                   remember the option numbers by entering an = sign\n                   followed by the option number and pressing ENTER\n                   (=0 will return to TSO).\n              Also the PF-keys for corresponding options (1-9) are\n                   availables.\n)O Operands : None, other than as specified above.\n./     ALIAS   NAME=AR\n./     ENDUP\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "AUTOCI": {"ttr": 2314, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x95\\x07O\\x00\\x95\\x07O\\x15S\\x10\\xe7\\x10\\xe7\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1995-03-15T00:00:00", "modifydate": "1995-03-15T15:53:00", "lines": 4327, "newlines": 4327, "modlines": 0, "user": "SYSPAJA"}, "text": "AOCI     TITLE 'AUTOMATIC OPERATORS COMMANDS ISSUER.'\n         PRINT OFF\n         MACRO           GENERATE TABLE KEYWORDS ENTRIES.\n&NAME   $KW    &RA,&KN,&KA\n         LCLC  &X\n.*\n.* $KW MACRO : RA = ROUTINE ADDRESS.\n.* ----------- KN = KEYWORD NAME.\n.*             KA = KEYWORD ALIAS (OPTIONAL).\n.*      NOTE : KN AND KA MAY BE SPECIFIED (...,N) TO SUPPRESS THE\n.*             FINAL BLANK GENERATION.\n.*\n         AIF   (N'&SYSLIST GT 3).TOO\n         AIF   (N'&SYSLIST EQ 0).MIS\n         AIF   (T'&RA EQ 'O' AND T'&KN EQ 'O').MIS\n&X       SETC  'IHB'.'&SYSNDX'\n&NAME    DC    AL1(L'&X-1)\n         AIF   ('&KN(2)' NE '').A\n&X       DC    C'&KN ',AL4(&RA)\n         AGO   .B\n.A       AIF   ('&KN(2)' NE 'N').BKN\n&X       DC    C'&KN(1)',AL4(&RA)\n.B       AIF   (T'&KA EQ 'O').END\n         DC    AL1(L'&X.A-1)\n         AIF   ('&KA(2)' NE '').C\n&X.A     DC    C'&KA ',AL4(&RA)\n         MEXIT\n.C       AIF   ('&KA(2)' NE 'N').BKA\n&X.A     DC    C'&KA(1)',AL4(&RA)\n         MEXIT\n.TOO     MNOTE 8,' TOO MANY OPERANDS ******************************** '\n         MEXIT\n.MIS     MNOTE 8,' OPERANDS MISSING ********************************* '\n         MEXIT\n.BKN     MNOTE 8,' 2ND OPERAND SYNTAX ERROR ************************* '\n         MEXIT\n.BKA     MNOTE 8,' 3RD OPERAND SYNTAX ERROR ************************* '\n.END     MEND\n         PRINT ON\n         SPACE 1\n* PURPOSE :    ISSUE OPERATORS COMMANDS (STARTED TASK OR SPECIFIC\n* ---------    BACKGROUND JOBS ONLY). WHEN EXECUTED IN FOREGROUND\n*              REGION BY AN AUTHORIZED TSO USER, THE PROGRAM ENTER\n*              A SPECIAL TEST MODE, USEFULL TO DEBUG THE OPERATORS\n*              COMMANDS SEQUENCE PROCESS (USING TERMINAL TPUT/TGET).\n*\n* AUTHOR :     MOINIL P.A.\n* --------     COMPUTING CENTRE\n*              J.R.C. - ISPRA ESTABLISHMENT\n*              21020 ISPRA (VA), ITALY\n*\n* INVOKED BY : 1. CONSOLE START COMMAND :\n* ------------      S AUTO,FROM='...PO-DSNAME...',\n*                          M=...MEMBER-NAME...\n*\n*              2. PROCEDURE (AUTHORIZED JOB) :\n*                   //... EXEC AUTO,FROM='...PO-DSNAME...',\n*                                   M=...MEMBER-NAME...\n*                 WHERE AUTO PROCEDURE SKELETON MAY BE :\n*                   //AUTO    PROC M=...,FROM='...'\n*                   //AUTO    EXEC PGM=AUTOCI,PARM='&M'\n*                   //STEPLIB   DD DSN=...LIBRARY...,DISP=SHR\n*                   //SYSPDS    DD DSN=&FROM,DISP=SHR\n*\n*              3. JCL (AUTHORIZED JOB) :\n*                   //... EXEC PGM=AUTOCI,PARM='...MEMBER-NAME...'\n*                   //STEPLIB  DD DSN=...LIBRARY...,DISP=SHR\n*                   //SYSPDS   DD DSN=...PO-DSNAME...,DISP=SHR\n*\n*              4. TSO TEST MODE (AUTHORIZED USER) :\n*                   ALLOC DA(...PO-DSNAME...) F(SYSPDS) SHR\n*                   CALL '...LIBRARY...(AUTOCI)' '...MEMBER-NAME...'\n*                                           OR : '...MEMBER-NAME.../S'\n*                   FREE F(SYSPDS)\n*                 NOTE : CAN BE A CLIST IF DESIRED. '/S' MAY BE ADDED\n*                        AFTER THE MEMBER-NAME TO SEND THE OPERATORS\n*                        COMMANDS TO THE OPERATING SYSTEM.\n*\n*              5. TSO COMMAND OR SUB-COMMAND (AUTHORIZED USER) :\n*                   AUTOCI ...PO-DSNAME... ...MEMBER-NAME... T(EST)\n*                                                            S(YSTEM)\n*                 NOTE : OPTION T OR TEST IS THE DEFAULT, WHEN S OR\n*                        SYSTEM IS USED, THE OPERATORS COMMANDS ARE\n*                        SENDED TO THE OPERATING SYSTEM.\n         EJECT\n* PARAMETERS FIELD : PARM=...MEMBER-NAME... TO SUPPLY THE INITIAL\n* ------------------ OPERATORS COMMANDS MEMBER NAME.\n*              ...MEMBER-NAME... MAY BE 1 UP TO 8 CHARACTERS LONG.\n*\n* INPUT DATA (SYSPDS) : COLUMNS 1 TO 72 OF CARDS CAN BE USED FOR\n* --------------------- OPERATORS COMMANDS OR INSTRUCTIONS CODING.\n*              NO FIXED COLUMNS NOR CONTINUATIONS ARE PROVIDED.\n*\n* INSTRUCTIONS : EACH MUST BE CODED ON A SEPARATE CARD AND MUST BE\n* -------------- FOLLOWED BY AT LEAST ONE BLANK, EXCEPT THE NULL\n*                INSTRUCTION WHICH MAY BE FOLLOWED BY ANOTHER ONE\n*                (OBVIOUSLY NOT ANOTHER NULL) OR AN OPERATOR COMMAND\n*                IN THE SAME CARD.\n*\n*    *  ...TEXT...\n*         A STARTING ASTERISK (*) MEANS A COMMENT CARD.\n*\n*    GDATE  (ALIAS @G)\n*         DISPLAY THE DATE AND TIME OF DAY.\n*\n*    MESSAGE  ...TEXT...  (ALIAS @M)\n*         SEND A MESSAGE TEXT TO THE MAIN CONSOLE.\n*         ...TEXT... MAY BE 55 CHARACTERS LONG AT MAXIMUM, OTHERWISE\n*                   IT IS TRUNCATED.\n*\n*    PAUSE  ...TEXT...  (ALIAS @P)\n*         SEND A MESSAGE TEXT TO THE MAIN CONSOLE AND ALLOW THE\n*         OPERATOR TO REPLY IN ORDER TO CONTINUE OR STOP IMMEDIATELY\n*         THE COMMANDS SEQUENCE OF THE CURRENT MEMBER (EXECUTE) OR\n*         THE MAIN MEMBER (PROGRAM).\n*         THE OPERATOR RESPONSE MAY BE 0 UP TO 8 CHARACTERS LONG AND\n*         IS AVAILABLE TO VARIOUS OTHER STATEMENTS (UNTIL THE NEXT\n*         PAUSE), UNLESS THE REPLY TEXT IS 'CANCEL', WHICH CAUSE THE\n*         IMMEDIATE STOP AS PREVIOUSLY EXPLAINED.\n*         ...TEXT... MAY BE 55 CHARACTERS LONG AT MAXIMUM, OTHERWISE\n*                   IT IS TRUNCATED.\n*\n*    NULL  SSSS  (OR :SSSS)\n*         DEFINE A SEQUENCE SYMBOL TO WHICH A BRANCH INSTRUCTION REFERS\n*         (I.E. - GOTO, IF'S, ...).\n*         SSSS : IS THE SEQUENCE SYMBOL. IT MAY BE 1 UP TO 8 CHARACTERS\n*                   LONG.\n*\n*    GOTO  SSSS  (ALIAS GO)\n*         ALLOWS TO BRANCH UNCONDITIONALLY.\n*         SSSS : IS A SEQUENCE SYMBOL TO WHICH THE BRANCH IS DONE\n*                   (SSSS MUST BE DEFINED IN A NULL INSTRUCTION).\n*                   SSSS MAY BE 1 UP TO 8 CHARACTERS LONG.\n         EJECT\n*    IF-REPLY  WWWW  ....  SSSS  (ALIAS IF-R)\n*         ALLOWS TO BRANCH ACCORDING TO A TEST RESULT ON THE PREVIOUS\n*         PAUSE ... OPERATOR RESPONSE. THUS THE SEQUENCE IN WHICH THE\n*         OPERATORS COMMANDS ARE PROCESSED CAN BE ALTERED.\n*         WWWW MAY BE ONE OF THE FOLLOWING OPERATORS :\n*                   EQ (OR =)     NE (OR /)     LT (OR <)\n*                   GT (OR >)     LE (OR <=)    GE (OR >=)\n*         .... : IS THE DESIRED VALUE TO TEST (TO INDICATE A NULL\n*                   RESPONSE, ZERO LENGTH REPLY, CODE '').\n*                   THE TEST IS DONE WITH THE VALUE LENGTH, THIS MEANS\n*                   THAT 'YES' MATCHES ALSO 'Y' IN\n*                        IF-R  EQ  Y  ACCEPT\n*                   (THE BRANCH IS TAKEN), OR '9' IS GREATER THAN '50'\n*                   IN\n*                        IF-R  LE  50  ACCEPT\n*                   (THE BRANCH IS NOT TAKEN).\n*         SSSS : IS A SEQUENCE SYMBOL TO WHICH THE BRANCH IS TAKEN IF\n*                   THE CONDITION IS TRUE, OTHERWISE THE PROCESS\n*                   CONTINUE IN SEQUENCE (SSSS MUST BE DEFINED IN A\n*                   NULL INSTRUCTION).\n*                   SSSS MAY BE 1 UP TO 8 CHARACTERS LONG.\n*\n*    IF-REPLY-CHAR  WWWW  ....  SSSS  (ALIAS IF-C)\n*         IDENTICAL TO IF-REPLY, BUT THE OPERATOR RESPONSE AND THE TEST\n*         VALUES ARE COLLATING SEQUENCE COMPARED, THUS THE TWO VALUES\n*         ARE LEFT PADDED WITH BLANKS (SO 'YES' DOES NOT MATCH 'Y' BUT\n*         IS GREATER, AND '9' IS LOWER THAN '50').\n*\n*    IF-REPLY-BIN  WWWW  ....  SSSS  (ALIAS IF-B)\n*         IDENTICAL TO IF-REPLY, BUT THE OPERATOR RESPONSE AND THE TEST\n*         VALUES ARE CONSIDERED INTEGER NUMBERS FOR COMPARE (SO '9' IS\n*         LESS THAN '50').\n*                   NOTE : PLUS (+) OR MINUS (-) SIGN IS NOT ACCEPTED.\n*\n*    IF-REPLY-HEX  WWWW  ....  SSSS  (ALIAS IF-H)\n*         IDENTICAL TO IF-REPLY, BUT THE OPERATOR RESPONSE AND THE TEST\n*         VALUES ARE CONSIDERED HEXADECIMALS FOR COMPARE (SO 'F' IS\n*         LESS THAN 'A0').\n*                   NOTE : PLUS (+) OR MINUS (-) SIGN IS NOT ACCEPTED.\n*\n*    VER-BIN  SSSS  (ALIAS V-B)\n*    VER-HEX  SSSS  (ALIAS V-H)\n*         ALLOWS TO VERIFY THE OPERATOR RESPONSE FOR ONLY NUMERICS\n*         (0-9) OR HEXADECIMALS (0-9,A-F) CHARACTERS CONTENTS.\n*         THE BRANCH IS TAKEN IF A WRONG CHARACTER IS DETECTED.\n*                   NOTE : PLUS (+) OR MINUS (-) SIGN IS NOT ACCEPTED.\n*         SSSS : IS A SEQUENCE SYMBOL TO WHICH THE BRANCH IS TAKEN IF\n*                   THE WRONG CONDITION IS TRUE, OTHERWISE THE PROCESS\n*                   CONTINUE IN SEQUENCE (SSSS MUST BE DEFINED IN A\n*                   NULL INSTRUCTION).\n*                   SSSS MAY BE 1 UP TO 8 CHARACTERS LONG.\n         EJECT\n*    IF-REPLY-ID  ....  SSSS  (ALIAS IF-ID)\n*         ALLOWS TO BRANCH ACCORDING TO A SEARCH FOR A REPLY PENDING\n*         ID FOUND. THUS THE SEQUENCE IN WHICH THE OPERATORS COMMANDS\n*         ARE PROCESSED CAN BE ALTERED.\n*         .... : IS THE DESIRED MESSAGE-ID TEXT (MUST BE AT LEAST 8\n*                   CHARACTERS LONG). IF ANY BLANKS ARE NEEDED (UNLESS\n*                   LEADING BLANKS UP TO 8 CHARACTERS), THE MESSAGE-ID\n*                   MUST BE GIVEN AS A QUOTED CHARACTERS STRING, SO A\n*                   NEEDED QUOTE IN THE TEXT MUST BE DOUBLED.\n*         SSSS : IS A SEQUENCE SYMBOL TO WHICH THE BRANCH IS TAKEN\n*                   IF THE REPLY-ID IS FOUND, OTHERWISE THE PROCESS\n*                   CONTINUE IN SEQUENCE (SSSS MUST BE DEFINED IN A\n*                   NULL INSTRUCTION).\n*                   SSSS MAY BE 1 UP TO 8 CHARACTERS LONG.\n*         WHEN THE REPLY-ID IS FOUND, THE EDITED REPLY NUMBER IS SET\n*         IN THE RESERVED VARIABLE NAMED 'RPID' (2 CHARACTERS LONG),\n*         THIS ALLOWING THE '&S-RV(RPID)...REPLY TEXT...' STRING TO\n*         BE AN OPERATOR REPLY COMMAND.\n*\n*    LOGICAL  VAR1  VAR2  ...  VARN  (ALIAS @L)\n*         DEFINE PROCESSING LOGICAL VARIABLES (NAME MAY BE 1 UP TO 8\n*         CHARACTERS LONG). THE INITIAL VALUE OF THESE VARIABLES IS\n*         'FALSE'.\n*\n*    TRUE  VAR1  VAR2  ...  VARN  (ALIAS @T)\n*    FALSE  VAR1  VAR2  ...  VARN  (ALIAS @F)\n*         SET LOGICAL VARIABLES VALUE TO 'TRUE' OR 'FALSE'.\n*\n*    IF-TRUE  VARN  SSSS  (ALIAS IF-T)\n*    IF-FALSE  VARN  SSSS  (ALIAS IF-F)\n*         TEST THE LOGICAL VARIABLE 'VARN' ON 'TRUE' OR 'FALSE' VALUE.\n*         SSSS : IS A SEQUENCE SYMBOL TO WHICH THE BRANCH IS TAKEN IF\n*                   THE CONDITION IS MET, OTHERWISE THE PROCESS\n*                   CONTINUE IN SEQUENCE (SSSS MUST BE DEFINED IN A\n*                   NULL INSTRUCTION).\n*\n*    SET-REPLY  VVVV  (ALIASES SET, SET-VAR )\n*    SET-VAR  VVVV  ....  (ALIASES SET, SET-REPLY)\n*         MEMORIZE THE CURRENT AVAILABLE PAUSE ... OPERATOR RESPONSE\n*         (0 UP TO 8 CHARACTERS LONG) OR A SPECIFIC VALUE (0 UP TO 8\n*         CHARACTERS LONG) IN A VARIABLE.\n*         VVVV IS THE VARIABLE NAME. IT MAY BE 1 UP TO 8 CHARACTERS\n*                   LONG, AND CANNOT BE ONE OF THE RESERVED NAME (SEE\n*                   IF QQQQ WWWW .... SSSS STATEMENT).\n*         .... : IS THE DESIRED VALUE TO STORE (TO INDICATE A NULL\n*                   VALUE, ZERO LENGTH, CODE '').\n*         THEN THE STRING &S-RV(VVVV), INTO WHICH VVVV IS THE VARIABLE\n*         NAME OR ONE OF THE RESERVED NAMES (HERE IT IS ACCEPTED), IS\n*         REPLACED BY THE VARIABLE VALUE IF ENCOUNTERED IN THE TEXT OF\n*         ANY MESSAGE, PAUSE, IF-REPLY'S, EXECUTE, SUBMIT, T-WAIT,\n*         COMMON INSTRUCTIONS OR OPERATORS COMMANDS.\n         EJECT\n*    IF  QQQQ  WWWW  ....  SSSS\n*    IF-VAR  VVVV  WWWW  ....  SSSS  (ALIAS IF-V)\n*         ALLOWS TO BRANCH ACCORDING TO THE RESULT OF A CONDITION TEST.\n*         THUS THE SEQUENCE IN WHICH THE OPERATORS COMMANDS ARE\n*         PROCESSED CAN BE ALTERED.\n*         QQQQ MAY BE ONE OF THE FOLLOWING RESERVED NAMES :\n*                   SID : MEANS THE SYSTEM ID (FROM SMF : SSSS).\n*                   CPU : MEANS THE CPU MODEL (FROM CVT : MMMM).\n*                   SDATE : MEANS THE STANDARD DATE (YYMMDD).\n*                   JDATE : MEANS THE JULIAN DATE (YYDDD).\n*                   DAY : MEANS THE CURRENT DAY NAME (SUN, MON,\n*                             TUE, WED, THU, FRI AND SAT).\n*                   MONTH : MEANS THE CURRENT MONTH NAME (JAN,\n*                             FEB, MAR, APR, MAY, JUN, JUL, AUG,\n*                             SEP, OCT, NOV AND DEC).\n*                   TIME : MEANS THE CURRENT TIME OF DAY IN\n*                             HOURS/MINUTES (FORMAT : HHMM).\n*                   HOURS : MEANS THE HOURS (HH PART OF TIME).\n*                   MINS : MEANS THE MINUTES (MM PART OF TIME).\n*                   YEAR : MEANS THE YEAR (YY PART OF SDATE).\n*                   SMONTH : MEANS THE MONTH (MM PART OF SDATE).\n*                   SDAY : MEANS THE DAY (DD PART OF SDATE).\n*                   JDAY : MEANS THE DAY (DDD PART OF JDATE).\n*         VVVV IS THE NAME OF A VARIABLE WHICH HAS BEEN DEFINED BY A\n*                   PREVIOUS SET-REPLY OR SET-VAR. IT MAY BE 1 UP TO 8\n*                   CHARACTERS LONG.\n*         WWWW MAY BE ONE OF THE FOLLOWING OPERATORS :\n*                   EQ (OR =)     NE (OR /)     LT (OR <)\n*                   GT (OR >)     LE (OR <=)    GE (OR >=)\n*         .... : IS THE DESIRED VALUE TO TEST.\n*                   NOTE : THE TEST IS DONE WITH THE VALUE LENGTH AND\n*                   RIGHT JUSTIFIED (I.E. : TIME EQ 945 MATCHES 0945 AM\n*                   AND 1945 PM).\n*         SSSS : IS A SEQUENCE SYMBOL TO WHICH THE BRANCH IS TAKEN\n*                   IF THE CONDITION IS TRUE, OTHERWISE THE PROCESS\n*                   CONTINUE IN SEQUENCE (SSSS MUST BE DEFINED IN A\n*                   NULL INSTRUCTION).\n*                   SSSS MAY BE 1 UP TO 8 CHARACTERS LONG.\n         EJECT\n*    EXECUTE  ...PO-DSNAME...  ...MEMBER-NAME...  (ALIAS @E)\n*             *  ...MEMBER-NAME...\n*         ALLOWS THE EXECUTION OF ANOTHER MEMBER CONTAINING OPERATORS\n*         COMMANDS SEQUENCE, THEN AT END OF THIS MEMBER THE PROCESS\n*         CONTINUE IN SEQUENCE (UP TO 99 NESTED EXECUTE MAY BE\n*         DEFINED).\n*         ...PO-DSNAME... IS THE PARTITIONED DATA-SET NAME, AND MAY BE\n*                   1 UP TO 44 CHARACTERS LONG. WHEN * (ASTERISK) FORM\n*                   IS CODED, IT MEANS THE CURRENT DATA-SET IN USE.\n*         ...MEMBER-NAME... MAY BE 1 UP TO 8 CHARACTERS LONG.\n*\n*    SUBMIT  *(...MEMBER-NAME...)  (ALIAS SUB)\n*            ...PO-DSNAME...(...MEMBER-NAME...)\n*            ...PS-DSNAME...\n*         ALLOWS THE SUBMIT OF A BATCH JOB FOR CONVENTIONAL PROCESSING.\n*         THE JOB SUBMITTED MUST RESIDE IN EITHER A MEMBER OF A\n*         PARTITIONED OR A SEQUENTIAL DATA-SET.\n*         SUBMITTED DATA-SET MUST BE FIXED 80-BYTES RECORDS (BLOCKED\n*         OR UNBLOCKED).\n*                   NOTE : THE JCL JOB STATEMENT MUST BE THE FIRST AND\n*                   MAY CONTAIN ALL THE NEEDED INFORMATION.\n*         ...PO-DSNAME... IS THE PARTITIONED DATA-SET NAME, AND MAY BE\n*                   1 UP TO 44 CHARACTERS LONG. WHEN * (ASTERISK) FORM\n*                   IS CODED, IT MEANS THE CURRENT DATA-SET IN USE.\n*         ...MEMBER-NAME... MAY BE 1 UP TO 8 CHARACTERS LONG.\n*         ...PS-DSNAME... IS THE SEQUENTIAL DATA-SET NAME, AND MAY BE\n*                   1 UP TO 44 CHARACTERS LONG.\n*         NOTE : THE SUBMIT FUNCTION SUPPLIES THE PASSWORD ONLY IF THE\n*                USER=... KEYWORD IS CODED AND THE PASSWORD=... KEYWORD\n*                IS NOT CODED (THIS ASSUMES THE JOB STATEMENT IS MORE\n*                THAN ONE CARD CODED).\n* --- SUPPRESS - IF YOU DON'T WANT SUPPLY THE PASSWORD AS DESCRIBED\n*                ABOVE, YOU MAY BYPASS THIS PROCESS BY SETTING THE BIT\n*                'SWJS' PERMANENTLY ON IN THE SWITCH BYTE 'SWJBSC'.\n*\n*    T-WAIT  SECS  (ALIAS @W)\n*         ALLOWS TO WAIT-A-BIT.\n*         SECS : IS THE NUMBER (1-120) OF SECONDS TO WAIT. IF OMITTED\n*                   OR 0 IS SPECIFIED, IT MEANS NO WAIT.\n         EJECT\n*    LOAD-COMMON  ...PO-DSNAME...  ...MEMBER-NAME...  (ALIAS @CL)\n*    SAVE-COMMON  ...PO-DSNAME...  ...MEMBER-NAME...  (ALIAS @CS)\n*         LOAD FROM OR SAVE IN THE INDICATED DATA-SET MEMBER ALL THE\n*         COMMON-SWITCHES (1-400).\n*                   NOTE : AS SOON AS THE EXECUTION BEGINS, ALL THE\n*                   COMMON-SWITCHES ARE AVAILABLES (VALUE 'FALSE').\n*                   A LOAD FROM ANY UNEXISTANT MEMBER OF AN EXISTING\n*                   PO DATA-SET RESULTS IN A NO-OPERATION, SO ALL THE\n*                   COMMON-SWITCHES REMAIN AS THEY WERE.\n*         ...PO-DSNAME... IS THE PARTITIONED DATA-SET NAME, AND MAY BE\n*                   1 UP TO 44 CHARACTERS LONG.\n*         ...MEMBER-NAME... MAY BE 1 UP TO 8 CHARACTERS LONG.\n*\n*    SET-COMMON  NNN  NNN  ...  OR  ( NNN - NNN )  ...  (ALIAS @CT)\n*    RESET-COMMON  NNN  NNN  ...  OR  ( NNN - NNN )  ...  (ALIAS @CF)\n*         SET THE COMMON-SWITCH NUMBER NNN (1-400) OR RANGE OF\n*         COMMON-SWITCHES NUMBERS (FROM-TO) VALUE TO 'TRUE' OR 'FALSE'.\n*\n*    IF-COMMON-TRUE  NNN  SSSS  (ALIAS @CIT)\n*    IF-COMMON-FALSE  NNN  SSSS  (ALIAS @CIF)\n*         TEST THE COMMON-SWITCH NUMBER NNN (1-400) ON 'TRUE' OR\n*         'FALSE' VALUE.\n*         SSSS : IS A SEQUENCE SYMBOL TO WHICH THE BRANCH IS TAKEN IF\n*                   THE CONDITION IS MET, OTHERWISE THE PROCESS\n*                   CONTINUE IN SEQUENCE (SSSS MUST BE DEFINED IN A\n*                   NULL INSTRUCTION).\n         EJECT\nAUTOCI   START 0\n         SPACE 1\nAUTOCI  AMODE  24\nAUTOCI  RMODE  24\n         SPACE 1\n        $DEFREG\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*        AUTHORITY LEVELS DEFINITIONS.                          *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         SPACE 1\nLV0      EQU   0         REJECT LEVEL.\n         SPACE 1\n        $MDL@IX\n         SPACE 2\n*        DEFINE TABLES DIMENSIONS.\n*        -------------------------\n         SPACE 1\nMAXDD    EQU   99        MAX. DD-NAMES ALLOCATION\n*                        (MIN=0, MAX=999).\nMAXLV    EQU   100       MAX. LOGICAL VARIABLES NAMES\n*                        (MIN=1, MAX=2040).\nMAXRV    EQU   100       MAX. REPLY VARIABLES NAMES\n*                        (ONLY MIN=1).\n         SPACE 1\nEOT      EQU   X'FF'               END OF TABLE INDICATOR.\n         EJECT\n        PRINT  NOGEN\n        $DYNLIST\n        PRINT  GEN\n         SPACE 2\n*        DYNAMIC DD-NAMES TABLE (EXECUTE).\n*        ---------------------------------\n         SPACE 1\nDDTAB    DSECT\nDDTFN    DS    AL2                 FILE NO.\nDDTNME   DS    CL8                 FILE NAME (DD-NAME).\nDDTMBN   DS    CL8                 MEMBER NAME.\nDDTDSN   DS    CL44                DATA-SET NAME.\nDDTABL   EQU   *-DDTAB             ELEMENT LENGTH.\n         SPACE 2\n*        LOGICAL VARIABLES TABLE AND SWITCHES BYTES.\n*        -------------------------------------------\n*\n         SPACE 1\nLVART    DSECT\nLVARNME  DS    CL8                 VARIABLE NAME.\nLVARSBN  DS    AL1                 SWITCH BYTE NUMBER.\nLVARSMB  DS    XL1                 SWITCH MASK BIT.\nLVARTL   EQU   *-LVART             ELEMENT LENGTH.\n         SPACE 2\n*        REPLY VARIABLES TABLE.\n*        ----------------------\n*\n         SPACE 1\nRVART    DSECT\nRVARNME  DS    CL8                 VARIABLE NAME.\nRVARV    DS    CL8                 VARIABLE VALUE (PADDED WITH BLANKS).\nRVARVL   DS    AL1                 VARIABLE VALUE LENGTH.\nRVARTL   EQU   *-RVART             ELEMENT LENGTH.\n         SPACE 1\nAUTOCI   CSECT ,                   RESTORE CURRENT MAIN SECTION\n         EJECT\n        $HEDIT\n        $XENT  BASE=(R11,R12)\n         EJECT\n         LR    R4,R1               SAVE FOR LATER USE.\n         L     R10,=A(GWATBS)\n         BASR  R8,R10              GET WORK-AREAS AND TABLES SPACES.\n         SPACE 2\n*        VERIFY AUTHORITY.\n*        -----------------\n         SPACE 1\n        $EACM  REQAUT\n        EXTRACT ANSWER,'S',FIELDS=(TIOT,COMM,TSO,PSB)\n         L     R2,ACOMM            COMMUNICATION AREA ADDRESS.\n         L     R3,4(R2)            CIB ADDRESS.\n         LA    R3,0(R3)            CLEAR HIGH BYTE.\n         LTR   R3,R3               CURRENT CIB SET UP?\n         BZ    *+L'*+8             NO.\n         USING CIBDSECT,R3\n         CLI   CIBVERB,CIBSTART    START COMMAND (SYSTEM TASK)?\n         BE    PFAN                YES.\n         DROP  R3\n         L     R2,ATSO             TSO INDICATOR ADDRESS.\n         TM    0(R2),X'80'         ARE WE IN TSO?\n         BO    TPTSO               YES.\n         CLI   AUTH,LV0            AUTHORIZED?\n         BNE   PFAN                YES.\n         L     R3,ATIOT            GET TIOT ADDRESS.\n         USING TIODSECT,R3\n         MVC   MSAUT+8(8),TIOCNJOB MOVE JOB-NAME IN MESSAGE.\n         DROP  R3\n        WTO    MF=(E,MSAUT)\n         B     SETCC\nTPTSO    L     R1,APSCB            PSCB ADDRESS.\n         LTR   R1,R1\n         BZ    NOTSO\n         CLI   AUTH,LV0            AUTHORIZED?\n         BE    NOTSO               NO.\n         OI    SWITCH,SWTR         SET TSO TEST MODE.\n         USING CPPL,R4\n         USING PSCB,R1\n         CLC   PSCBUPT,CPPLUPT     CPPL+4 = UPT ADDRESS?\n         BNE   *+L'*+10            NO.\n         DROP  R1\n         CLC   CPPLPSCB(4),APSCB   CPPL+8=PSCB ADDRESS?\n         BE    XTSO                YES, TSO COMMAND.\n         DROP  R4\n         USING IKJEBECA,R4\n         L     R1,CAPTTMP          CPPL ADDRESS.\n         DROP  R4\n         USING CPPL,R1\n         CLC   CPPLPSCB(4),APSCB   CPPL+8=PSCB ADDRESS?\n         BE    XTSOS               YES, TSO SUB-COMMAND.\n         DROP  R1\n        TPUT   TSTART,L'TSTART\n         B     PFAN\nNOTSO   TPUT   TSAUT,L'TSAUT\nSETCC    LA    R9,128              C.C. = 128.\n         B     EXIT\n         SPACE 2\n*        TSO COMMAND OR SUB-COMMAND.\n*        ---------------------------\n         SPACE 1\nXTSOS    LR    R4,R1\n         USING CPPL,R4\nXTSO     ST    R4,ACCPL\n         MVC   PPLUPT,CPPLUPT      SET UP PARM. FOR PARSE.\n         MVC   PPLECT,CPPLECT\n         MVC   PPLCBUF,CPPLCBUF\n        CALLTSSR EP=IKJPARS,MF=(E,PPLUPT)\n         B     *+L'*(R15)          BRANCH ON RETURNED CODE :\n         B     PARSOK              + 0 - SUCCESSFULL.\n         B     ERROR1              + 4 - UNABLE TO PROMPT.\n         B     RETURN              + 8 - USER ATTENTION OCCURED.\n         B     ERROR2              +12 - PROGRAM BUG.\n         B     ERROR3              +16 - SPACE UNAVAILABLE IN REGION.\n         B     ERROR4              +20 - INVALID PARM.\n         B     ERROR5              +24 - PARM. CONFLICT.\n         B     ERROR6              +28 - TERMINAL DISCONNECTED.\nPARSOK   L     R3,PPLANSS          CHECK ANSWER ADDRESS.\n         LA    R3,0(R3)\n         LTR   R3,R3\n         BZ    ERROR7              PARSE ERROR.\n         MVC   DAPLUPT,CPPLUPT     SET UP DAIR BLOCK TO ALLOC. FILE.\n         MVC   DAPLECT,CPPLECT\n         MVC   DAPLPSCB,CPPLPSCB\n         DROP  R4\n         USING IKJPARMD,R3\n         TM    PODSN+6,X'80'       IS PO-DSNAME SUPPLIED?\n         BZ    ERROR8              NO.\n         TM    PODSN+6,X'40'       CHECK FOR QUOTES?\n         BO    *+L'*+4             YES, DON'T TELL DAIR TO PUT USERID.\n         OI    DA08CTL,X'20'       FLAG TO PREFIX USERID TO DSNAME.\n         LH    R1,PODSN+4          SET UP DSNAME.\n         STH   R1,DDSNAML          SAVE LENGTH FOR LATER.\n         BCTR  R1,0                EXECUTE LENGTH.\n         L     R15,PODSN           GET ADDRESS.\n         EX    R1,MVPOD            MOVE IT TO BLOCK.\n         TM    PODSN+14,X'80'      SET UP FOR MEMBER NAME ALSO?\n         BO    ERROR9              YES, NOT ALLOWED.\n         TM    PODSN+22,X'80'      TEST FOR PASSWORD?\n         BZ    NOPASS              NO.\n         LH    R1,PODSN+20         LENGTH.\n         BCTR  R1,0                EXECUTE LENGTH.\n         L     R15,PODSN+16        ADDRESS.\n         EX    R1,MVPSW            MOVE PASSWORD.\nNOPASS   TM    POMEM+6,X'80'       IS MEMBER SUPPLIED?\n         BZ    ERROR10             NO.\n         LH    R1,POMEM+4          LENGTH.\n         BCTR  R1,0                EXECUTE LENGTH.\n         L     R15,POMEM           ADDRESS.\n         EX    R1,MVPOM            MOVE MEMBER-NAME.\n         LH    R1,OPLIST           LOOK EVENTUAL OPTION.\n         LTR   R1,R1\n         BZ    *+L'*+8\n         BCT   R1,*+L'*+4\n         OI    SWITCH,SWSY        ALLOW SYSTEM.\n         DROP  R3\n        IKJRLSA PPLANSS\n         L     R1,ADDTAB           GET STARTING DD-NAME.\n         USING DDTAB,R1\n         MVC   DA08DDN,DDTNME\n         DROP  R1\n         L     R1,ATIOT\n         USING TIODSECT,R1\n         XR    R0,R0\nXTS1     CLC   TIOELNGH(4),=F'0'\n         BE    XTS3\n         CLC   TIOEDDNM,DA08DDN\n         BE    XTS2\n         IC    R0,TIOELNGH\n         ALR   R1,R0\n         B     XTS1\n         DROP  R1\nMVPOD    MVC   DDSNAM(*-*),0(R15)  << EXECUTED >>\nMVPSW    MVC   DA08PSWD(*-*),0(R15)     << EXECUTED >>\nMVPOM    MVC   MEMBER(*-*),0(R15)  << EXECUTED >>\nXTS2     LA    R1,DA18CD\n         ST    R1,DAPLDAPB\n         MVC   DA18DDN,DA08DDN\n         BAS   R8,DAIR             FREE ANY PREVIOUS ALLOCATION.\n         B     EXIT                RETURN +0.\nXTS3     LA    R1,DA08CD                  +4.\n         ST    R1,DAPLDAPB\n         OI    SWITCH,SWAL\n         BAS   R8,DAIR             SET ALLOCATION.\n         B     LEAVE               RETURN +0.\n         TM    DA08DSO,X'02'              +4, PO ORGANIZATION?\n         BZ    NOTPO               NO.\n         TM    SWITCH,SWTR\n         BZ    GETGI\n        TPUT   TSTART,L'TSTART\n         B     GETGI\nNOTPO   TPUT   TSMNPO,L'TSMNPO\n         B     LEAVE\n         SPACE 1\n*                                  TSO DYNAMIC ALLOCATION ROUTINE.\nDAIR     XC    DAPLECBS,DAPLECBS   -------------------------------\n        CALLTSSR EP=IKJDAIR,MF=(E,DAPLUPT)\n         LTR   R15,R15\n         BZ    4(R8)               OK, NORMAL RETURN IS +4.\n         ST    R15,RETC            STORE RETURN CODE.\n         LA    R1,DFDAPLP          PARM. ADDRESS.\n        LINK   EP=IKJEFF18         ERROR MESSAGE ROUTINE.\n         LR    R9,R15              GET RETURN CODE.\n         BR    R8                  ERROR RETURN IS +0.\n         SPACE 2\n*        PARM. FIELD ANALYSIS.\n*        ---------------------\n         SPACE 1\nPFAN     L     R4,0(R4)            GET PARM. FIELD ADDRESS.\n         LH    R1,0(R4)            PARM. FIELD LENGTH.\n         LTR   R1,R1\n         BNP   MISS                MISSING.\n         LA    R3,2(R4)            SCAN START ADDRESS.\n         LA    R5,1(R1,R4)         SCAN END ADDRESS.\n         LA    R4,1                SCAN STEP.\n         LR    R2,R3\n         CLI   0(R3),C'/'          SEARCH MEMBER NAME.\n         BE    *+L'*+4\n         BXLE  R3,R4,*-8\n         LR    R1,R3\n         SR    R1,R2\n         BNP   MISS                MISSING.\n         CH    R1,=H'8'\n         BH    PERR                INVALID.\n         BCT   R1,*+L'*+6\n         MVC   MEMBER(*-*),0(R2)   << EXECUTED >>\n         EX    R1,*-6              SET MEMBER NAME.\n         TM    SWITCH,SWTR\n         BZ    GETGI\n         CLR   R3,R5\n         BNL   GETGI\n         BXLE  R3,R4,*+L'*+4\n         B     GETGI\n         CLI   0(R3),C'S'\n         BNE   GETGI\n         OI    SWITCH,SWSY        ALLOW SYSTEM.\n         SPACE 2\n*        GET GENERAL INFORMATION.\n*        ------------------------\n         SPACE 1\nGETGI    L     R1,CVTPTR\n         USING CVT,R1\n         L     R2,CVTSMCA          GET SYSTEM ID.\n         DROP  R1\n         LTR   R2,R2\n         BZ    *+L'*+6\n         USING SMCABASE,R2\n         MVC   SID(L'SID),SMCASID\n         DROP  R2\n         LA    R1,0(R1)            GET CPU MODEL.\n         SL    R1,=F'6'\n         UNPK  VLSTR(L'CPU+1),0(3,R1)\n         TR    VLSTR(L'CPU),TRTAB-C'0'\n         MVC   CPU(L'CPU),VLSTR\n         TM    SWITCH,SWTR\n         BZ    INIT\n        TPUT   TSRQL,L'TSRQL       INSTRUCTIONS LIST OPTION.\nRQLBK    XC    CARD(3),CARD\n        TGET   CARD,3\n         LTR   R15,R15\n         BZ    RQLAN\n         CH    R15,=H'12'\n         BNE   TSOERR\n        TCLEARQ INPUT\n        TPUT   TSRTL,L'TSRTL\n         B     RQLBK\nRQLAN    LTR   R1,R1\n         BZ    REQINF\n         OC    CARD(3),=CL8' '\n         CLC   CARD(3),=CL8' '\n         BE    REQINF\n         CLC   CARD(3),=CL3'N  '\n         BE    REQINF\n         CLC   CARD(3),=CL3'NO '\n         BE    REQINF\n         CLC   CARD(3),=CL3'Y  '\n         BE    RQLYES\n         CLC   CARD(3),=CL3'YES'\n         BE    RQLYES\n        TPUT   TSRSE,L'TSRSE\n         B     RQLBK\nRQLYES   OI    SWITCH,SWLS\nREQINF   MVC   TSINF+10(L'CPU),CPU\n         MVC   TSINF+23(L'SID),SID\n        TPUT   TSINF,L'TSINF\n        TPUT   TSREQ,L'TSREQ\n         XR    R15,R15\nREQBK    L     R10,=A(GACHG)\n         BASR  R8,R10              GET ANY CHANGES.\n         LTR   R1,R1\n         BZ    GETDM\n         LA    R0,NLP\n         LA    R1,CARD\n         OC    0(8,R1),=CL8' '\n         LA    R1,8(R1)\n         BCT   R0,*-10\n         LM    R3,R5,SCCD\n         CLI   0(R3),C' '          ANALYZE RESPONSE.\n         BNE   *+L'*+8\n         BXLE  R3,R4,*-8\n         B     GETDM\n         CLI   0(R3),C'E'\n         BE    GETDM\nREQCN    CLC   0(4,R3),=CL4'SID='\n         BE    RQ1\n         CLC   0(4,R3),=CL4'CPU='\n         BE    RQ2\nREQER    LA    R15,4\n         B     REQBK\nRQ1      LA    R2,SID\n         MVI   VLSTR,C' '\n         B     *+L'*+8\nRQ2      LA    R2,CPU\n         MVI   VLSTR,C'0'\n         MVC   VLSTR+1(L'VLSTR-1),VLSTR\n         LA    R3,3(R3)\n         BXLE  R3,R4,*+L'*+4\n         B     REQER\n         CLI   0(R3),C' '\n         BE    REQER\n         LR    R6,R3\n         LA    R0,L'SID            OR L'CPU\nRQ3      BXLE  R3,R4,*+L'*+4\n         B     RQ4\n         CLI   0(R3),C' '\n         BE    RQ4\n         BCT   R0,RQ3\n         B     REQER\nMVREQ    MVC   0(*-*,R15),0(R6)    << EXECUTED >>\nRQ4      LA    R1,L'SID            OR L'CPU\n         SR    R1,R0\n         LA    R15,VLSTR-1\n         AR    R15,R0\n         EX    R1,MVREQ\n         MVC   0(L'SID,R2),VLSTR   OR L'CPU\n         CLR   R3,R5\n         BNL   REQNW\n         CLI   0(R3),C' '          CONTINUE.\n         BNE   *+L'*+8\n         BXLE  R3,R4,*-8\n         B     REQNW\n         CLI   0(R3),C'E'\n         BNE   REQCN\nREQNW    MVC   TSNEW+23(L'CPU),CPU\n         MVC   TSNEW+36(L'SID),SID\n        TPUT   TSNEW,L'TSNEW\n         SPACE 1\n*        GET CURRENT DAY-MONTH-TIME.\n*        ---------------------------\n         SPACE 1\nGETDM    L     R8,=A(UPDT)\n         BASR  R14,R8\n         MVC   TSIDM+10(L'DAY),DAY\n         MVC   TSIDM+24(L'MONTH),MONTH\n         MVC   TSIDM+37(L'THRS+L'TMNS),FTIME\n        TPUT   TSIDM,L'TSIDM\n        TPUT   TSRDM,L'TSRDM\n         XR    R15,R15\nRDMBK    L     R10,=A(GACHG)\n         BASR  R8,R10              GET ANY CHANGES.\n         LTR   R1,R1\n         BZ    GETJS\n         LA    R0,NLP\n         LA    R1,CARD\n         OC    0(8,R1),=CL8' '\n         LA    R1,8(R1)\n         BCT   R0,*-10\n         LM    R3,R5,SCCD\n         CLI   0(R3),C' '          ANALYZE RESPONSE.\n         BNE   *+L'*+8\n         BXLE  R3,R4,*-8\n         B     GETJS\n         CLI   0(R3),C'E'\n         BE    GETJS\nRDMCN    CLC   0(4,R3),=CL4'DAY='\n         BE    DM1\n         CLC   0(6,R3),=CL6'MONTH='\n         BE    DM2\n         CLC   0(5,R3),=CL5'TIME='\n         BE    DM10\nRDMER    LA    R15,4\n         B     RDMBK\nDM1      LA    R2,DAY\n         L     R6,=A(TDAY)\n         LA    R3,3(R3)\n         B     DM3\nDM2      LA    R2,MONTH\n         L     R6,=A(TMONTH)\n         LA    R3,5(R3)\nDM3      BXLE  R3,R4,DM4\n         B     RDMER\nDM4      LA    R1,2(R3)\n         CLR   R1,R5\n         BH    RDMER\n         CLI   0(R6),0\n         BE    RDMER\n         CLC   0(3,R3),0(R6)\n         BE    *+L'*+8\n         LA    R6,3(R6)\n         B     DM4\n         MVC   0(3,R2),0(R3)\n         LA    R3,3(R3)\n         B     DM20                CONTINUE.\nDM10     LA    R3,4(R3)\n         BXLE  R3,R4,*+L'*+4\n         B     RDMER\n         LA    R1,3(R3)\n         CLR   R1,R5\n         BH    RDMER\n         CLC   0(4,R3),=CL6'000000'\n         BL    RDMER\n         CLC   0(2,R3),=CL2'23'\n         BH    RDMER\n         CLC   2(2,R3),=CL2'59'\n         BH    RDMER\n         MVC   FTIME(L'THRS+L'TMNS),0(R3)\n         MVC   TSCS(L'TSCS),=CL6'000000'\n         MVC   RDATE(8),=CL8' (TEST) '\n         LA    R3,4(R3)\nDM20     CLR   R3,R5\n         BNL   RDMNW\n         CLI   0(R3),C' '          CONTINUE.\n         BNE   *+L'*+8\n         BXLE  R3,R4,*-8\n         B     RDMNW\n         CLI   0(R3),C'E'\n         BNE   RDMCN\nRDMNW    MVC   TSNDM+23(L'DAY),DAY\n         MVC   TSNDM+37(L'MONTH),MONTH\n         MVC   TSNDM+50(L'THRS+L'TMNS),FTIME\n        TPUT   TSNDM,L'TSNDM\n         SPACE 1\n*        GET CURRENT STANDARD-JULIAN DATE.\n*        ---------------------------------\n         SPACE 1\nGETJS    MVC   TSIJS+20(L'SDATE),SDATE\n         MVC   TSIJS+43(L'JDATE),JDATE\n        TPUT   TSIJS,L'TSIJS\n        TPUT   TSRJS,L'TSRJS\n         XR    R15,R15\nRJSBK    L     R10,=A(GACHG)\n         BASR  R8,R10              GET ANY CHANGES.\n         LTR   R1,R1\n         BZ    INIT\n         LA    R0,NLP\n         LA    R1,CARD\n         OC    0(8,R1),=CL8' '\n         LA    R1,8(R1)\n         BCT   R0,*-10\n         LM    R3,R5,SCCD\n         CLI   0(R3),C' '          ANALYZE RESPONSE.\n         BNE   *+L'*+8\n         BXLE  R3,R4,*-8\n         B     INIT\n         CLI   0(R3),C'E'\n         BE    INIT\nRJSCN    CLC   0(4,R3),=CL4'STD='\n         BE    JS1\n         CLC   0(4,R3),=CL4'JUL='\n         BE    JS2\nRJSER    LA    R15,4\n         B     RJSBK\nJS1      LA    R3,3(R3)\n         BXLE  R3,R4,*+L'*+4\n         B     RJSER\n         LA    R1,5(R3)\n         CLR   R1,R5\n         BH    RJSER\n         CLC   0(6,R3),=CL6'000000'\n         BL    RJSER\n         CLC   2(2,R3),=CL2'12'\n         BH    RJSER\n         CLC   4(2,R3),=CL2'31'\n         BH    RJSER\n         MVC   SDATE(L'SDATE),0(R3)\n         LA    R3,6(R3)\n         B     JS3\nJS2      LA    R3,3(R3)\n         BXLE  R3,R4,*+L'*+4\n         B     RJSER\n         LA    R1,4(R3)\n         CLR   R1,R5\n         BH    RJSER\n         CLC   0(5,R3),=CL6'000000'\n         BL    RJSER\n         CLC   2(3,R3),=CL3'366'\n         BH    RJSER\n         MVC   JDATE(L'JDATE),0(R3)\n         LA    R3,5(R3)\nJS3      CLR   R3,R5\n         BNL   RJSNW\n         CLI   0(R3),C' '          CONTINUE.\n         BNE   *+L'*+8\n         BXLE  R3,R4,*-8\n         B     RJSNW\n         CLI   0(R3),C'E'\n         BNE   RJSCN\nRJSNW    MVC   TSNJS+33(L'SDATE),SDATE\n         MVC   TSNJS+56(L'JDATE),JDATE\n        TPUT   TSNJS,L'TSNJS\n         SPACE 1\n*        INITIALIZATION.\n*        ---------------\n         SPACE 1\nINIT     L     R1,ADDTAB           SET STARTING DDNAME.\n         ST    R1,DDPTR\n         USING DDTAB,R1\n         MVC   DDTMBN,MEMBER       SET STARTING MEMBER NAME.\n         L     R2,=A(DUMMY)        GET STARTING JFCB.\n         USING IHADCB,R2\n         MVC   DCBDDNAM,DDTNME\n         DROP  R1,R2\n        RDJFCB (DUMMY)\n         LTR   R15,R15\n         BNZ   ERJF\n         L     R2,=A(JFILE)        GET STARTING DATA-SET NAME.\n         MVC   DSNM(L'DSNM),0(R2)\n         LA    R1,DSNM+L'DSNM-1\n         CLI   0(R1),C' '          CONTROL IF ANY MEMBER NAME.\n         BNE   *+L'*+4\n         BCT   R1,*-8\n         CLI   0(R1),C')'\n         BE    ERMB                I DON'T LIKE IT.\n         L     R1,DDPTR\n         USING DDTAB,R1\n         MVC   DDTDSN,DSNM         SET STARTING DATA-SET NAME.\n         SPACE 2\n*        READ OPERATORS COMMANDS SEQUENCE MEMBER.\n*        ----------------------------------------\n         SPACE 1\nOPDS     MVC   DDNME,DDTNME        SET DDNAME.\n         DROP  R1\n        $MOPEN LRECL,DDNME\n         LTR   R15,R15             TEST COMPLETION CODE?\n         BNZ   OERR                OPEN ERROR.\n         CLC   LRECL,=F'80'        LOGICAL LENGTH AS WE LIKE IT?\n         BNE   LERR\nRSTMB   $MFIND MEMBER,DDNME\n         LTR   R15,R15             TEST COMPLETION CODE?\n         BNZ   MERR                OPEN ERROR.\nRCMD     NI    SWPRSS,255-SWNL     ENABLE NULL.\n        $MREAD CARD,DDNME          READ COMMAND TEXT.\n         LTR   R15,R15             TEST COMPLETION CODE?\n         BM    ENDMB               ENF-OF-FILE.\n         BNZ   RERR                READ ERROR.\n         LM    R3,R5,SCCD\n         CLI   0(R3),C' '          FIND START OF TEXT.\n         BNE   SCTBL\n         BXLE  R3,R4,*-8\n         B     RCMD\nSCTBL    CLI   0(R3),C'*'          COMMENT?\n         BNE   SC1                 NO.\n         TM    SWPRSS,SWTO\n         BO    RCMD\n         B     PRCSS\nSC1      L     R2,=A(CDTBL)        FIND IF KEYWORD.\n         XR    R10,R10\nSC2      CLI   0(R2),EOT           END OF KEYWORDS TABLE?\n         BE    SNDCMD              YES, SEND COMMAND(S).\n         IC    R10,0(R2)\n         EX    R10,SCKW            THIS KEYWORD?\n         BE    *+L'*+8             YES.\n         LA    R2,6(R10,R2)        BUMP TO NEXT.\n         B     SC2\n         LA    R3,1(R10,R3)        ADJUST TEXT POINTER.\n         LA    R2,2(R10,R2)\n         ICM   R10,B'1111',0(R2)   GET PROCESS ADDRESS.\n         BR    R10                 GO TO.\nSCKW     CLC   1(*-*,R2),0(R3)     << EXECUTED >>\n         SPACE 2\n*        SEND COMMAND(S) TO SUPERVISOR.\n*        ------------------------------\n         SPACE 1\nSNDCMD   TM    SWPRSS,SWTO\n         BO    RCMD\n         L     R8,=A(RSRVAR)\n         BASR  R14,R8\n         TM    SWITCH,SWTR\n         BZ    TOOPER\n        TPUT   CARD,L'CARD-8\n         TM    SWITCH,SWSY\n         BZ    RCMD\nTOOPER   CLI   0(R5),C' '\n         BNE   *+L'*+4\n         BCT   R5,TOOPER\n         SR    R5,R3               COMMAND LENGTH -1.\n         LA    R2,CMND             COMMAND BUFFER ADDRESS.\n         USING MGCRPL,R2\n         XC    MGCRPL(MGCRLTH),MGCRPL   CLEAR PARAMETER LIST.\n         MVI   MGCRFLG1,MGCRFI     SET MGCRFLG2 VALID.\n         MVC   MGCRTEXT(*-*),0(R3) << EXECUTED >>\n         EX    R5,*-6              MOVE COMMAND TEXT.\n         LA    R1,(MGCRTEXT-MGCRPL)+1(R5)\n         STC   R1,MGCRLGTH         SET LENGTH IN MGCRPL.\n         DROP  R2\n        ZEROKEY\n         XR    R0,R0               SEND COMMAND.\n         XR    R15,R15\n        MGCR   (R2)\n         LR    R2,R15              SAVE RETURN CODE.\n        RESETKEY\n         LTR   R15,R2              TEST RETURN CODE?\n         BZ    RCMD                OK, GET ANOTHER COMMAND IF ANY.\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n* NOTE - MVS/XA (MVS/SP 2.1.3) :                                      *\n*        THE FOUR INSTRUCTIONS BELOW ARE ADDED JUST BECAUSE SOME      *\n*        OPERATORS COMMANDS (LIKE VARY B20,MSTCONS), PASSED THROUGH   *\n*        SVC 34, GIVES BACK AN ADDRESS INTO MODULE 'IEE0003D' INSTEAD *\n*        OF A RETURN CODE IN THE REGISTER 15 (DIAGNOSE HAS BEEN DONE  *\n*        USING DIDOCS).                                               *\n*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n         LA    R2,256              R.C. CONTROL.\n         CLR   R15,R2              IS IT REALLY A RETURN CODE?\n         BNL   RCMD                NO, GET ANOTHER COMMAND IF ANY.\n         B     CERR                ERROR.\nSKIPTO   OI    SWPRSS,SWTO+SWRM\n         B     PRCSS\nNOSKIP   NI    SWPRSS,255-SWTO\nPRCSS    TM    SWITCH,SWTR\n         BZ    WHERE\n         TM    SWITCH,SWLS\n         BZ    WHERE\n        TPUT   CARD,L'CARD-8\nWHERE    TM    SWPRSS,SWRM\n         BZ    RCMD\n         NI    SWPRSS,255-SWRM\n         B     RSTMB\n         SPACE 2\n*        END OF A MEMBER.\n*        ----------------\n         SPACE 1\nENDMB    NI    SWPRSS,255-SWTO\n         L     R6,DDPTR\n         USING DDTAB,R6\n         OC    DDTFN,DDTFN         MAIN MEMBER?\n         BZ    REND                YES.\n         DROP  R6\n         LR    R1,R6\n         SL    R1,=A(DDTABL)\n         ST    R1,DDPTR            BACK TO PREVIOUS.\n         USING DDTAB,R1\n         MVC   DDNME,DDTNME\n         MVC   MEMBER,DDTMBN\n         MVC   DSNM,DDTDSN\n         DROP  R1\n         USING DDTAB,R6\n         LA    R2,DDTNME           CLOSE THIS DD-NAME.\n        $MCLOSE (R2)\n         L     R1,DALIST           DE-ALLOCATE DD-NAME.\n         LR    R2,R1\n         L     R3,=A(DYNLGTH)\n         LA    R4,*\n         XR    R5,R5\n         ICM   R5,B'1000',=CL8' '\n         MVCL  R2,R4\n         USING DYNLIST,R1\n         MVC   DDNAME,DDTNME\n         XC    DSNAME,DSNAME\n         MVC   DSSTATUS(3),=CL3'SHR'\n         MVC   DSNDISP(4),=CL4'KEEP'\n         MVC   DSADISP(4),=CL4'KEEP'\n         DROP  R1\n        $DYNALL (R1),RCODES\n         LTR   R15,R15\n         BZ    *+L'*+8\n         BAS   R8,DAMSG            DE-ALLOCATION ERROR.\n         DC    CL4'FREE'\n         XC    DDTFN(DDTABL),DDTFN ELIMINE ENTRY.\n         B     RCMD                CONTINUE PROCESSING.\n         SPACE 1\n*                                  DYNALL ERROR MESSAGE ROUTINE.\nDAMSG    MVC   MSDAF+8(8),DDTNME   -----------------------------\n         MVC   MSDAF+25(4),0(R8)        R6 : DDNAME ENTRY.\n         L     R0,RCODES+4              R0 : WORK REGISTER.\n         STC   R0,MSDAF+43              R8 : LINK REGISTER.\n         SRL   R0,4\n         STC   R0,MSDAF+42\n         NC    MSDAF+42(2),=XL2'0F0F'\n         TR    MSDAF+42(2),TRTAB\n         UNPK  MSDAF+52(5),RCODES(3)\n         MVI   MSDAF+56,C','\n         TR    MSDAF+52(4),TRTAB-C'0'\n         UNPK  MSDAF+63(5),RCODES+2(3)\n         MVI   MSDAF+67,C' '\n         TR    MSDAF+63(4),TRTAB-C'0'\n         DROP  R6\n         TM    SWITCH,SWTR\n         BZ    TOPRS\n         LH    R0,MSDAF\n         SH    R0,=H'4'\n        TPUT   MSDAF+4,(0)\n        TPUT   TSPCN,L'TSPCN\n         B     4(R8)\nTOPRS   WTO    MF=(E,MSDAF)\n         B     4(R8)\n         SPACE 2\n*        ERROR MESSAGE AND EXIT.\n*        -----------------------\n         SPACE 1\nSERR     BAS   R8,TIIR\n         MVC   MSERR+19(27),=CL27'INSTR.SYNTAX ERROR DETECTED'\n         B     SENDMSM\nISNR     MVC   MSERR+19(27),=CL27'COMMON-SWITCH NO. : INVALID'\n         B     SENDMSM\nERJF     MVC   MSERR+19(19),=CL19'READ JOB-FILE ERROR'\n         B     SENDMS\nERMB     MVC   MSERR+19(27),=CL27'DS-NAME(MEMBER) NOT ALLOWED'\n         B     SENDMSM\nERTB     MVC   MSERR+19(27),=CL27'DYNAMIC EXEC-TABLE OVERFLOW'\n         B     SENDMSM\nERVB     MVC   MSERR+19(27),=CL27'LOGICAL VAR.-TABLE OVERFLOW'\n         B     SENDMSM\nERVR     MVC   MSERR+19(27),=CL27'S.REPLY VAR.-TABLE OVERFLOW'\n         B     SENDMSM\nESDV     BAS   R8,TIIR\n         MVC   MSERR+19(27),=CL27'VARIABLE NAME DEFINED TWICE'\n         B     SENDMSM\nERUV     BAS   R8,TIIR\n         MVC   MSERR+19(27),=CL27'UNDECLARED LOGICAL VARIABLE'\n         B     SENDMSM\nCERR     MVC   MSERR+19(19),=CL19'O.S. COMMAND FAILED'\n         OI    SWITCH,SWEM\n         B     SENDMS\nMISS     MVC   MSERR+19(27),=CL27'INITIAL MEMBER NAME MISSING'\n         B     SENDMSM\nPERR     MVC   MSERR+19(27),=CL27'INVALID INITIAL MEMBER NAME'\n         B     SENDMSM\nOERR     MVC   MSERR+19(19),=CL19'OPEN DATA-SET ERROR'\n         B     SENDMS\nLERR     MVC   MSERR+19(27),=CL27'LOGICAL RECORD LENGTH ERROR'\n         B     SENDMSM\nMERR     MVC   MSERR+19(19),=CL19'LOCATE MEMBER ERROR'\n         B     SENDMS\nRERR     MVC   MSERR+19(8),DDNME\n         MVC   MSERR+27(11),=CL11' READ ERROR'\n         B     SENDMS\nSRPERR   MVC   MSERR+19(19),=CL19'REPLY-ID LOOK ERROR'\nSENDMS   MVC   MSERR+38(8),=CL8' (RC=  )'\n         CVD   R15,WORK            SET RETURN CODE IN MESSAGE.\n         BAS   R14,EDITW\n         MVC   MSERR+43(2),WORK+2\nSENDMSM  L     R2,ATIOT            GET TIOT ADDRESS.\n         USING TIODSECT,R2\n         MVC   MSERR+8(8),TIOCNJOB MOVE TASK NAME IN MESSAGE.\n         DROP  R2\n         TM    SWITCH,SWTR\n         BZ    TOPER\n         LH    R0,MSERR\n         SH    R0,=H'4'\n        TPUT   MSERR+4,(0)\n         B     TOPERS\nTOPER   WTO    MF=(E,MSERR)\nTOPERS   TM    SWITCH,SWEM         WHICH WAY BACK?\n         BZ    *+L'*+8             ERROR EXIT.\n         NI    SWITCH,255-SWEM\n         B     ENDMB               TRUNCATE EXECUTION.\n         LA    R9,256              C.C. = 256.\n         B     RET\nTSOERR   LR    R9,R15              C.C. = TGET R.C.\n         NI    SWITCH,255-SWTR\n         B     RET\n         SPACE 1\n*                                  TRACE INSTRUCTION IMAGE ROUTINE.\nTIIR     TM    SWITCH,SWTR         --------------------------------\n         BZR   R8                       R3 - R5 : SCAN POINTERS.\n        TPUT   CARD,L'CARD-8            R8 : LINK REGISTER.\n         MVI   CARD,C' '\n         MVC   CARD+1(L'CARD-1),CARD\n         CLR   R3,R5\n         BNH   *+L'*+2\n         LR    R3,R5\n         MVI   0(R3),C'$'\n        TPUT   CARD,L'CARD-8\n         BR    R8\n         SPACE 1\nERROR1  TPUT   TSM1,L'TSM1\n         B     RETURN\nERROR2  TPUT   TSM2,L'TSM2\n         B     RETURN\nERROR3  TPUT   TSM3,L'TSM3\n         B     RETURN\nERROR4  TPUT   TSM4,L'TSM4\n         B     RETURN\nERROR5  TPUT   TSM5,L'TSM5\n         B     RETURN\nERROR6  TPUT   TSM6,L'TSM6\n         B     RETURN\nERROR7  TPUT   TSM7,L'TSM7\n         B     RETURN\nERROR8  TPUT   TSM8,L'TSM8\n         B     RLSA\nERROR9  TPUT   TSM9,L'TSM9\n         B     RLSA\nERROR10 TPUT   TSM10,L'TSM10\nRLSA    IKJRLSA PPLANSS\nRETURN   XR    R9,R9               C.C. = 0.\n         B     EXIT\n         SPACE 1\nREND     XR    R9,R9               C.C. = 0.\nRET     $MCLOSE\n         L     R6,DDPTR\n         LTR   R6,R6               INITIALIZED?\n         BZ    RET2                NO.\n         USING DDTAB,R6\n         OC    DDTFN,DDTFN         MAIN MEMBER?\n         BZ    RET2                YES.\nRET1     L     R1,DALIST           DE-ALLOCATE DD-NAME.\n         LR    R2,R1\n         L     R3,=A(DYNLGTH)\n         LA    R4,*\n         XR    R5,R5\n         ICM   R5,B'1000',=CL8' '\n         MVCL  R2,R4\n         USING DYNLIST,R1\n         XC    DSNAME,DSNAME\n         MVC   DSSTATUS(3),=CL3'SHR'\n         MVC   DSNDISP(4),=CL4'KEEP'\n         MVC   DSADISP(4),=CL4'KEEP'\n         MVC   DDNAME,DDTNME\n         DROP  R1\n         XC    DDTFN(DDTABL),DDTFN ELIMINE ENTRY.\n         SL    R6,=A(DDTABL)\n        $DYNALL (R1),RCODES\n         OC    DDTFN,DDTFN         MAIN MEMBER?\n         BNZ   RET1                NO, CONTINUE.\n         DROP  R6\nRET2     TM    SWITCH,SWSI\n         BZ    RET3\n         NI    SWITCH,255-SWSI\n         L     R1,DASBIN           DE-ALLOCATE SUBMIT INPUT.\n         USING DYNLIST,R1\n         XC    DSNAME,DSNAME\n         DROP  R1\n        $DYNALL (R1),RCODES\nRET3     TM    SWITCH,SWTR\n         BZ    LEAVE\n        TPUT   TSTOP,L'TSTOP\nLEAVE    TM    SWITCH,SWAL\n         BZ    EXIT\n         NI    SWITCH,255-SWAL\n         L     R1,ADDTAB\n         USING DDTAB,R1\n         MVC   DA18DDN,DDTNME\n         DROP  R1\n         LA    R1,DA18CD\n         ST    R1,DAPLDAPB\n         BAS   R8,DAIR             FREE FILE.\n         NOP   0                   RETURN +0.\nEXIT     L     R10,=A(FWATBS)             +4.\n         BASR  R8,R10              FREE WORK-AREAS AND TABLES SPACES.\n        $XRET  CC=(R9)\n         SPACE 1\n*        EDIT 'WORK' ROUTINE.\n*        --------------------\n*              R14 = LINK REGISTER.\n         SPACE 1\nEDITW    MVC   WORK(4),=XL4'40202120'\n         ED    WORK(4),WORK+6\n         BR    R14\n         SPACE 2\n*        EXECUTED INSTRUCTIONS.\n*        ----------------------\n         SPACE 1\nMVLAB    MVC   LABEL(*-*),0(R6)    << EXECUTED >>\nMVVAR    MVC   VAR(*-*),0(R6)      << EXECUTED >>\nMVVLT    MVC   VALT(*-*),0(R6)     << EXECUTED >>\n         EJECT\n*        CONSTANTS AND WORK AREAS.\n*        -------------------------\n         SPACE 1\nWORK     DC    D'0'\nVLSTR    DC    CL8' '\n         SPACE 1\nCMND     DC    XL(MGCRLTH)'0'      OPERATOR COMMANDS BUFFER.\n         SPACE 1\nANSWER   DS    0F                  EXTRACT RESPONSES.\nATIOT    DC    A(*-*)\nACOMM    DC    A(*-*)\nATSO     DC    A(*-*)\nAPSCB    DC    A(*-*)\n         SPACE 1\nACCPL    DC    A(*-*)\nADDTAB   DC    A(*-*)\nLDDTAB   DC    A(*-*)\nALVART   DC    A(*-*)\nASWVAR   DC    A(*-*)\nLLVART   DC    A(*-*)\nARVART   DC    A(*-*)\nLRVART   DC    A(*-*)\nDALIST   DC    A(*-*)\nDASBIN   DC    A(*-*)\nDACOMM   DC    A(*-*)\nLDAW     DC    A(((DYNLGTH+7)/8)*8)\nSCCD     DC    A(CARD,1,CARD+L'CARD-9)\nDDPTR    DC    A(*-*)\nRCODES   DC    2F'0'\nLRECL    DC    F'0'\nDDNME    DC    CL8' '\nMEMBER   DC    CL8' '\n         SPACE 1\nPPLUPT   DC    A(*-*)              PARSE PARM. LIST (PPL).\nPPLECT   DC    A(*-*)\nPPLECB   DC    A(PPLECBS)\nPPLPCL   DC    A(PARMLST)\nPPLANS   DC    A(PPLANSS)\nPPLCBUF  DC    A(*-*)\nPPLUWA   DC    A(0)\nPPLECBS  DC    F'0'\nPPLANSS  DC    A(0)\nDAPLUPT  DC    A(*-*)              DAIR PARM. LIST (DAPL).\nDAPLECT  DC    A(*-*)\nDAPLECB  DC    A(DAPLECBS)\nDAPLPSCB DC    A(*-*)\nDAPLDAPB DC    A(*-*)\nDAPLECBS DC    F'0'\nDA08CD   DC    0F'0',X'0008'       DAIR ALLOC. BY DSNAME.\nDA08FLG  DC    H'0'\nDA08DARC DC    H'0'\nDA08CTRC DC    H'0'\nDA08PDSN DC    A(DDSNAML)\nDA08DDN  DC    CL8' '\nDA08UNIT DC    CL8' '\nDA08SER  DC    CL8' '\nDA08BLK  DC    F'0'\nDA08PQTY DC    F'0'\nDA08SQTY DC    F'0'\nDA08DQTY DC    F'0'\nDA08MNM  DC    CL8' '\nDA08PSWD DC    CL8' '\nDA08DSP1 DC    X'08'     (SHR)\nDA08DSP2 DC    X'08'     (KEEP)\nDA08DSP3 DC    X'08'     (KEEP)\nDA08CTL  DC    X'00'\n         DC    3X'0'\nDA08DSO  DC    X'00'\nDA08ALN  DC    CL8' '\nDDSNAML  DC    H'0'\nDDSNAM   DC    CL44' '\nDASW     DC    X'0001'\nDA18CD   DC    0F'0',X'0018'       DAIR DEALLOC. BY DDNAME/DSNAME.\nDA18FLG  DC    H'0'\nDA18DARC DC    H'0'\nDA18CTRC DC    H'0'\nDA18PDSN DC    F'0'\nDA18DDN  DC    CL8' '\nDA18MNM  DC    CL8' '\nDA18SCLS DC    CL2' '\nDA18DPS2 DC    X'08'     (KEEP)\nDA18CTL  DC    X'10'     (PERMANENTLY D.S. ARE UNALLOCATED)\n         DC    XL8'0'\nDFDAPLP  DC    A(DAPLUPT)          DAIR FAILURE PARM. LIST.\nDFRCP    DC    A(RETC)\nDFJEFF02 DC    A(AEFF02)\nDFIDP    DC    A(DASW)\nRETC     DC    F'0'\nAEFF02   DC    F'0'\n         SPACE 1\nCARD     DC    CL80' '\nNLP      EQU   (L'CARD-8)/8\nDSNM     DC    CL44' '\nMSERR   WTO    '---          : 123456789012345678901234567 - END FORCEDX\n                ---',ROUTCDE=1,DESC=3,MF=L\nMSDAF   WTO    '---          : DYNAM 0123 FAILED (R15=01) - ERC=0123, IX\n               NFO=0123 ---',ROUTCDE=1,DESC=3,MF=L\nMSAUT   WTO    '---          : NOT AUTHORIZED TO PASS OPERATORS COMMANDX\n               S - END ---',ROUTCDE=11,DESC=7,MF=L\nTSM1     DC    C'INCOMPLETE PARAMETERS AND UNABLE TO PROMPT'\nTSM2     DC    C'PARSE PARAMETER BLOCK INVALID'\nTSM3     DC    C'NOT ENOUGH SPACE IN REGION'\nTSM4     DC    C'INVALID PARAMETERS'\nTSM5     DC    C'PARAMETERS CONFLICT'\nTSM6     DC    C'TERMINAL HAS BEEN DISCONNECTED'\nTSM7     DC    C'PARSE ANSWER ADDRESS ERROR'\nTSM8     DC    C'PO-DSNAME NOT SUPPLIED'\nTSM9     DC    C'PO-DSNAME(MEMBER) NOT ALLOWED'\nTSM10    DC    C'MEMBER-NAME NOT SUPPLIED'\nTSMNPO   DC    C'DATA-SET IS NOT A PARTITIONED'\nTSAUT    DC    C'--- UNAUTHORIZED - END ---'\nTSRQL    DC    C'--- DO YOU WANT THE INSTRUCTIONS LIST ? (Y/N)'\nTSINF    DC    C'--- CPU : 0123 / SID : 0123 ---'\nTSREQ    DC    C'ENTER CHANGES (CPU=.... SID=....) AND/OR E(ND) :'\nTSNEW    DC    C'--- NOW RUN WITH CPU : 0123 / SID : 0123 ---'\nTSIDM    DC    C'--- DAY : 012 / MONTH : 012 / TIME : 0123 ---'\nTSRDM    DC    C'ENTER CHANGES (DAY=... MONTH=... TIME=HHMM) AND/OR E(NX\n               D) :'\nTSNDM    DC    C'--- NOW RUN WITH DAY : 012 / MONTH : 012 / TIME : 0123X\n                ---'\nTSIJS    DC    C'--- STANDARD DATE : 012345 / JULIAN DATE : 01234 ---'\nTSRJS    DC    C'ENTER CHANGES (STD=YYMMDD JUL=YYDDD) AND/OR E(ND) :'\nTSNJS    DC    C'--- NOW RUN WITH STANDARD DATE : 012345 / JULIAN DATE X\n               : 01234 ---'\nTSRTL    DC    C'INPUT TOO LONG - RESPECIFY :'\nTSRSE    DC    C'SYNTAX ERROR - RESPECIFY :'\nTSPCN    DC    C'TEST PROCESSING CONTINUE ...'\nTSTART   DC    C'--- TEST STARTED ---'\nTSTOP    DC    C'--- TEST ENDED ---'\n         SPACE 1\n         DS    0F\nTRTAB    DC    CL16'0123456789ABCDEF'\nRAREA    DC    XL8'0'\nLABEL    DC    CL8' '\nVAR      DC    CL8' '\nVALT     DC    CL8' '\nARG1     DC    CL8' '\nARG2     DC    CL8' '\nSID      DC    CL4' '\nCPU      DC    CL4' '\nFDATE    DS    0CL20 ------------* GDATE FIELDS\nDAY      DC    CL3'DDD',CL2' '   *\nMONTH    DC    CL3'MMM',CL2' '   *\nRDATE    DC    CL10' '           *\nFTIME    DS    0CL6              *\nTHRS     DC    CL2'HH'           *\nTMNS     DC    CL2'MM'           *\nTSCS     DC    CL2'SS'           *\nSDATE    DC    CL6'YYMMDD'       *\nJDATE    DC    CL5'YYDDD'\nRPID     DC    CL2'00'\n         SPACE 1\nSWITCH   DC    XL1'0'\nSWTR     EQU   X'01'               TEST RUN FORCED (ONLY TSO ALLOWED).\nSWSY     EQU   X'02'               TSO - OPTION : SYSTEM.\nSWAL     EQU   X'04'               INITIAL FILE TSO ALLOCATED.\nSWSI     EQU   X'08'               SUBMIT INPUT FILE ALLOCATED.\nSWEM     EQU   X'10'               TRUNCATE EXECUTION ON ERROR.\nSWLS     EQU   X'20'               INSTRUCTIONS LIST.\nSWIV     EQU   X'40'               IF-VAR INSTRUCTION.\nSWPRSS   DC    XL1'0'\nSWTF     EQU   X'01'               TRUE/FALSE SET OR TEST.\nSWTO     EQU   X'02'               SKIP UNTIL NULL MATCH.\nSWNL     EQU   X'04'               NULL DISABLED.\nSWRM     EQU   X'08'               RESTART MEMBER.\nSWRP     EQU   X'10'               IF-REPLY TEXT.\nSWRB     EQU   X'20'               IF-REPLY-BIN INST.\nSWRC     EQU   X'40'               IF-REPLY-CHAR INST.\nSWRH     EQU   X'80'               IF-REPLY-HEX INST.\n         SPACE 1\nREQAUT   DC    0F'0',BL1'00000000',AL3(MDL@IX),AL4(AUTH)\nAUTH     DC    XL1'0'\nRAREAL   DC    XL1'0'\nLABELL   DC    XL1'0'\nVALTL    DC    XL1'0'\nTMASK    DC    XL1'0'\nRPTXTL   DC    AL1(*-*)\nRPTXT    DC    CL72' '\n         SPACE 2\n*        LITERAL POOL.\n*        -------------\n         SPACE 1\n        LTORG\n         SPACE 2\n*------------- BASE REGISTERS ADDRESSABILITY (R11,R12) LAST LIMIT.\n         EJECT\n        $HEDIT ROUTINES\n*        SPACES MANAGEMENT ROUTINES.\n*        ---------------------------\n*        GWATBS : GET WORK-AREAS AND TABLES SPACES.\n*        FWATBS : FREE WORK-AREAS AND TABLES SPACES.\n*              R8 : LINK REGISTER.\n*              R10 : LOCAL BASE REGISTER.\n*              R0-R1-R2-R3-R6-R14-R15 : WORK REGISTERS.\n*              R4 : MUST BE PRESERVED.\n         SPACE 1\n         DS    0H\n         USING *,R10               LOCAL BASE REGISTER.\nGWATBS   L     R3,=A(MAXDD)        GET DYNAMIC DD-NAMES TABLE SPACE.\n         CL    R3,=F'999'\n         BNH   *+L'*+4\n         L     R3,=F'999'\n         AH    R3,=H'1'\n         MH    R3,=Y(DDTABL)       TOTAL ELEMENTS LENGTH.\n         LR    R6,R3               = (MAXDD+1)*DDTABL\n         AH    R3,=H'9'\n         SRL   R3,3\n         SLL   R3,3\n         ST    R3,LDDTAB           = ((((MAXDD+1)*DDTABL)+9)/8)*8\n         LR    R0,R3\n        GETMAIN R,LV=(0)\n         ST    R1,ADDTAB\n         LR    R2,R1               INITIALIZE AREA.\n         XR    R14,R14\n         LR    R15,R14\n         MVCL  R2,R14\n         USING DDTAB,R1\n         MVC   DDTNME,=CL8'SYSPDS'\n         ALR   R1,R6\n         MVC   DDTFN(L'DDTFN),=AL1(EOT,EOT)\n         DROP  R1\n         L     R3,=A(MAXLV)        GET LOGICAL VARIABLES TABLE AND\n         LTR   R3,R3                    SWITCHES BYTES SPACE.\n         BP    *+L'*+4\n         LH    R3,=H'1'\n         CL    R3,=F'2040'\n         BNH   *+L'*+4\n         L     R3,=F'2040'\n         LR    R1,R3\n         MH    R3,=Y(LVARTL)       TOTAL ELEMENTS LENGTH.\n         LR    R6,R3               = MAXLV*LVARTL\n         AH    R1,=H'7'            NUMBER OF BYTES FOR SWITCHES.\n         SRL   R1,3                = (MAXLV+7)/8\n         AR    R3,R1\n         AH    R3,=H'8'\n         SRL   R3,3\n         SLL   R3,3\n         ST    R3,LLVART      = (((MAXLV*LVARTL)+((MAXLV+7)/8)+8)/8)*8\n         LR    R0,R3\n        GETMAIN R,LV=(0)\n         ST    R1,ALVART\n         LR    R2,R1\n         XR    R14,R14\n         LR    R15,R14\n         MVCL  R2,R14\n         ALR   R1,R6\n         MVI   0(R1),EOT\n         AH    R1,=H'1'\n         ST    R1,ASWVAR\n         L     R3,=A(MAXRV)        GET REPLY VARIABLES TABLE SPACE.\n         LTR   R3,R3\n         BP    *+L'*+4\n         LH    R3,=H'1'\n         MH    R3,=Y(RVARTL)       TOTAL ELEMENTS LENGTH.\n         LR    R6,R3               = MAXRV*RVARTL\n         AH    R3,=H'8'\n         SRL   R3,3\n         SLL   R3,3\n         ST    R3,LRVART           = (((MAXRV*RVARTL)+8)/8)*8\n         LR    R0,R3\n        GETMAIN R,LV=(0)\n         ST    R1,ARVART\n         LR    R2,R1\n         XR    R14,R14\n         LR    R15,R14\n         MVCL  R2,R14\n         ALR   R1,R6\n         MVI   0(R1),EOT\n         L     R1,LDAW             GET DYNAMIC ALLOCATION WORK SPACES.\n         LR    R3,R1\n         SLL   R3,1\n         ALR   R3,R1\n         LR    R0,R3\n        GETMAIN R,LV=(0)\n         ST    R1,DALIST\n         LR    R2,R1\n         XR    R14,R14\n         LR    R15,R14\n         ICM   R15,B'1000',=C' '\n         MVCL  R2,R14\n         AL    R1,LDAW\n         ST    R1,DASBIN\n         AL    R1,LDAW\n         ST    R1,DACOMM\n         BR    R8\n         SPACE 1\n        LTORG\n         SPACE 1\n         DROP  R10\n         SPACE 2\n         DS    0H\n         USING *,R10               LOCAL BASE REGISTER.\nFWATBS   L     R0,LDDTAB           FREE DYNAMIC DD-NAMES TABLE SPACE.\n         L     R1,ADDTAB\n        FREEMAIN R,A=(1),LV=(0)\n         L     R0,LLVART           FREE LOGICAL VARIABLES TABLE AND\n         L     R1,ALVART                SWITCHES BYTES SPACE.\n        FREEMAIN R,A=(1),LV=(0)\n         L     R0,LRVART           FREE REPLY VARIABLES TABLE SPACE.\n         L     R1,ARVART\n        FREEMAIN R,A=(1),LV=(0)\n         L     R0,LDAW             FREE DYNAMIC ALLOCATION WORK SPACES.\n         LR    R1,R0\n         SLL   R0,1\n         ALR   R0,R1\n         L     R1,DALIST\n        FREEMAIN R,A=(1),LV=(0)\n         BR    R8\n         SPACE 1\n        LTORG\n         SPACE 1\n         DROP  R10\n         SPACE 2\n*        GET ANY CHANGES ROUTINE.\n*        ------------------------\n*              R1 : INPUT CHARACTERS NUMBER AT EXIT\n*              R8 : LINK REGISTER.\n*              R10 : LOCAL BASE REGISTER.\n*              R15 : ENTRY INDEX.\n         SPACE 1\n         DS    0H\n         USING *,R10               LOCAL BASE REGISTER.\nGACHG    B     *+L'*(R15)\n         B     GAGET               +0 = NORMAL ENTRY.\n         B     GACER               +4 = ERROR ENTRY.\nGAGET    XC    CARD,CARD           CLEAR INPUT.\n        TGET   CARD,L'CARD-8\n         LTR   R15,R15\n         BZR   R8\n         CH    R15,=H'12'\n         BNE   TSOERR\n        TCLEARQ INPUT\n        TPUT   TSRTL,L'TSRTL\n         B     GAGET\nGACER    MVI   CARD,C' '\n         MVC   CARD+1(L'CARD-1),CARD\n         CLR   R3,R5\n         BNH   *+L'*+2\n         LR    R3,R5\n         MVI   0(R3),C'$'\n        TPUT   CARD,L'CARD-8\n        TPUT   TSRSE,L'TSRSE\n         B     GAGET\n         SPACE 1\n        LTORG\n         SPACE 1\n         DROP  R10\n         SPACE 2\n*        SET ...TEXT... IN MESSAGE ROUTINE.\n*        ----------------------------------\n*              R1 : TARGET ADDRESS.\n*              R3-R4-R5 : SCAN POINTERS.\n*              R8 : LOCAL BASE REGISTER.\n*              R14 : LINK REGISTER.\n         SPACE 1\n         DS    0H\n         USING *,R8                LOCAL BASE REGISTER.\nSETMSG   MVI   0(R1),C' '\n         MVC   1(54,R1),0(R1)\n         CLI   0(R3),C' '\n         BNE   SM1\n         BXLE  R3,R4,*-8\n         B     SM3\nSM1      CLI   0(R5),C' '\n         BNE   SM2\n         BCTR  R5,0\n         CLR   R5,R3\n         BNL   SM1\n         B     SM3\nSM2      SR    R5,R3\n         LA    R0,54\n         CLR   R5,R0\n         BNH   *+L'*+2\n         LR    R5,R0\n         EX    R5,SMMV\n         BR    R14\nSM3      MVC   0(20,R1),=CL20'... I AM WAITING ...'\n         BR    R14\nSMMV     MVC   0(*-*,R1),0(R3)     << EXECUTED >>\n         SPACE 1\n        LTORG\n         SPACE 1\n         DROP  R8\n         SPACE 2\n*        SCAN AND SET KEYWORD OPERATOR ROUTINE.\n*        --------------------------------------\n*        AT EXIT : 'TMASK' SET.\n*              R3-R4-R5 : SCAN POINTERS.\n*              R8 : LOCAL BASE REGISTER.\n*              R14 : LINK REGISTER.\n*              R15 : WORK REGISTER.\n         SPACE 1\n         DS    0H\n         USING *,R8                LOCAL BASE REGISTER.\nOPSET    CLI   0(R3),C'.'\n         BNE   *+L'*+8\n         BXLE  R3,R4,*+L'*+4\n         B     SERR\n         LA    R15,2(R3)\n         CLR   R15,R5\n         BNL   SERR\n         L     R15,=A(OPTBL)\nOPSET1   CLI   0(R15),EOT          END OF TABLE?\n         BE    SERR                YES, ERROR\n         CLC   0(2,R15),0(R3)\n         BE    OPSET2\n         CLC   2(2,R15),0(R3)\n         BE    OPSET2\n         LA    R15,L'OPTBL(R15)\n         B     OPSET1\nOPSET2   MVC   TMASK(1),5(R15)     GET TEST MASK.\n         LA    R3,1(R3)            ADJUST SCAN POINTER.\n         CLI   0(R3),C' '\n         BER   R14\n         LA    R3,1(R3)\n         CLI   0(R3),C' '\n         BER   R14\n         CLI   0(R3),C'.'\n         BNE   SERR\n         BR    R14\n         SPACE 1\n        LTORG\n         SPACE 1\n         DROP  R8\n         SPACE 2\n*        REPLACE SET/RESERVED VARIABLES ROUTINE.\n*        ---------------------------------------\n*              R3-R4-R5 : SCAN POINTERS.\n*              R8 : LOCAL BASE REGISTER.\n*              R14 : LINK REGISTER.\n*              R0-R1-R2-R6-R15 : WORK REGISTERS.\n         SPACE 1\n         DS    0H\n         USING *,R8                LOCAL BASE REGISTER.\nRSRVAR   STM   R3,R5,RSRSV         SAVE CURRENT POINTERS.\n         SH    R5,=H'7'            MAX. TO SCAN.\nRSR1     CLC   0(6,R3),=CL6'&&S-RV('    SEARCH ANY REPLY VARIABLE.\n         BE    RSR2\n         BXLE  R3,R4,RSR1\n         LM    R3,R5,RSRSV         RESTORE CURRENT POINTERS.\n         BR    R14\nRSR2     LR    R6,R3\n         LA    R3,5(R3)\nRSR3     BXLE  R3,R4,RSR4\nRSRERR   LR    R3,R6\n         NI    SWPRSS,255-SWRP\n         B     SERR\nRSR4     CLI   0(R3),C')'          GET THE VARIABLE NAME.\n         BNE   RSR3\n         LR    R1,R3\n         SR    R1,R6\n         SH    R1,=H'6'\n         BZ    RSRERR\n         CH    R1,=H'8'\n         BH    RSRERR\n         BCTR  R1,0\n         MVC   VALT(L'VALT),=CL16' '\n         EX    R1,MVRVN\n         L     R2,=A(FVTBL)        SCAN VARIABLES TABLES.\nRSR5     CLI   0(R2),EOT           END OF TABLE?\n         BE    RSR7                YES.\n         CLC   VALT(L'VALT),0(R2)  THIS ONE MATCH?\n         BE    *+L'*+8             YES.\n         LA    R2,L'FVTBL(R2)\n         B     RSR5\n         TM    SWITCH,SWTR         ARE WE IN TEST?\n         BO    RSR6                YES.\n         CLI   9(R2),0             UPDATE REQUIRED?\n         BE    RSR6                NO.\n         LR    R15,R8              YES, GO UPDATE VALUES.\n         STM   R14,R15,RSRUP\n         L     R8,=A(UPDT)\n         DROP  R8\n         BASR  R14,R8\n         USING *,R14\n         LM    R14,R15,RSRUP\n         DROP  R14\n         LR    R8,R15\n         USING RSRVAR,R8\nRSR6     XR    R1,R1               REPLACE BY VALUE.\n         IC    R1,10(R2)\n         XR    R15,R15\n         ICM   R15,B'0111',11(R2)\n         BCTR  R1,0\n         EX    R1,MVRFV\n         LA    R6,1(R1,R6)\n         B     RSR10\nRSR7     L     R2,ARVART\n         USING RVART,R2\nRSR8     TM    RVARNME,EOT         END OF TABLE?\n         BO    RSRERR              YES.\n         BZ    RSRERR              FREE, NO MORE.\n         CLC   RVARNME,VALT        THIS ONE MATCH?\n         BE    *+L'*+8             YES.\n         LA    R2,RVARTL(R2)\n         B     RSR8\n         XR    R1,R1\n         ICM   R1,B'0001',RVARVL   REPLACE BY VALUE.\n         BZ    RSR9\n         BCTR  R1,0\n         EX    R1,MVRVR\n         DROP  R2\n         LA    R6,1(R1,R6)\n         B     RSR10\nRSR9     TM    SWPRSS,SWRP\n         BZ    RSR10\n         MVC   0(2,R6),=CL2''''''  NULL WHEN IF-REPLY.\n         LA    R6,2(R6)\nRSR10    CLR   R6,R3               TEXT MUST BE SHIFTED?\n         BNL   RSR1                NO, CONTINUE.\n         L     R2,RSRSV+8          YES, SHIFT REST OF TEXT.\n         LR    R1,R2\n         SR    R1,R3\n         BCTR  R1,0\n         EX    R1,MVRSH\n         LR    R1,R3\n         SR    R1,R6\n         SR    R2,R1\n         EX    R1,MVRRS\n         LR    R3,R6               SET POINTER.\n         B     RSR1                CONTINUE.\nMVRVN    MVC   VALT(*-*),6(R6)     << EXECUTED >>\nMVRFV    MVC   0(*-*,R6),0(R15)    << EXECUTED >>\n         USING RVART,R2\nMVRVR    MVC   0(*-*,R6),RVARV     << EXECUTED >>\n         DROP  R2\nMVRSH    MVC   0(*-*,R6),1(R3)     << EXECUTED >>\nMVRRS    MVC   0(*-*,R2),=CL16' '  << EXECUTED >>\n         SPACE 1\nRSRSV    DC    3F'0'               SAVE R3-R5.\nRSRUP    DC    2F'0'               SAVE R14-R15(R8).\n         SPACE 1\n        LTORG\n         SPACE 1\n         DROP  R8\n         SPACE 2\n*        COMMON-SWITCH NUMBER SCAN ROUTINE.\n*        ----------------------------------\n*              R1 : COMMON-SWITCH NUMBER AT EXIT.\n*              R3-R4-R5 : SCAN POINTERS.\n*              R8 : LOCAL BASE REGISTER.\n*              R14 : LINK REGISTER.\n*              R0-R14-R15 : WORK REGISTERS.\n         SPACE 1\n         DS    0H\n         USING *,R8                LOCAL BASE REGISTER.\nCSSC     ST    R14,CSSCSV\n         LA    R0,3\n         XR    R1,R1\n         XR    R14,R14\n         LA    R15,15\nCSSC1    CLI   0(R3),C'0'\n         BL    SERR\n         CLI   0(R3),C'9'\n         BH    SERR\n         IC    R14,0(R3)\n         NR    R14,R15\n         LTR   R1,R1\n         BZ    *+L'*+4\n         MH    R1,=H'10'\n         AR    R1,R14\n         BXLE  R3,R4,*+L'*+4\n         B     CSSC2\n         CLI   0(R3),C' '\n         BE    CSSC2\n         CLI   0(R3),C'-'\n         BE    CSSC2\n         CLI   0(R3),C')'\n         BE    CSSC2\n         BCT   R0,CSSC1\n         B     SERR\nCSSC2    LTR   R1,R1\n         BNP   ISNR\n         CH    R1,=Y(L'COMMSW*8)\n         BH    ISNR\n         L     R14,CSSCSV\n         BR    R14\n         SPACE 1\nCSSCSV   DC    F'0'                SAVE R14.\n         SPACE 1\n        LTORG\n         SPACE 1\n         DROP  R8\n         SPACE 2\n*        UPDATE DATE-TIME ROUTINE.\n*        -------------------------\n*              R8 : LOCAL BASE REGISTER.\n*              R14 : LINK REGISTER.\n*              R0-R1-R14-R15 : WORK REGISTERS.\n         SPACE 1\n         DS    0H\n         USING *,R8                LOCAL BASE REGISTER.\nUPDT     ST    R14,UPDTSV\n        $GDATE FDATE,FTIME,WORK\n         MVC   SDATE+2(4),WORK\n         MVC   SDATE(2),WORK+4\n        $SDATE WORK,JDATE\n         L     R14,UPDTSV\n         BR    R14\n         SPACE 1\nUPDTSV   DC    F'0'                SAVE R14.\n         SPACE 1\n        LTORG\n         SPACE 1\n         DROP  R8\n         SPACE 2\n*        ACTION REQUEST ROUTINE.\n*        -----------------------\n*              R0 : INFO-ERC CODES FROM DYNAMIC ALLOCATION.\n*              R1 : POINTER TO DATA-SET NAME.\n*              R8 : LOCAL BASE REGISTER.\n*              R14 : LINK REGISTER.\n*              R15 : AT ENTRY = RC FROM DYNAMIC ALLOCATION.\n*                    AT EXIT = RC 0 - RETRY (R).\n*                                 4 - SKIP (S).\n*                                 8 - CANCEL (C).\n*              R0-R1-R14-R15 : WORK REGISTERS.\n         SPACE 1\n         DS    0H\n         USING *,R8                LOCAL BASE REGISTER.\nACTRQ    ST    R14,ACTRQSV\n         CH    R15,=H'4'\n         BNE   *+L'*+8\n         CL    R0,=A(X'020C0000')  SOMEBODY ELSE USE THE DATA-SET?\n         BE    *+L'*+6             NO, NOT THAT SITUATION.\n         XR    R15,R15\n         B     ACTRQ10\n         MVI   MSACT+4,C' '\n         MVC   MSACT+5(64),MSACT+4\n         MVC   MSACT+4(L'DSNM),0(R1)\n         LA    R1,MSACT+L'DSNM+3\n         CLI   0(R1),C' '\n         BNE   *+L'*+4\n         BCT   R1,*-8\n         MVC   2(20,R1),=CL20'IS USED BY SOMEBODY.'\n         TM    SWITCH,SWTR         DISPLAY MESSAGE.\n         BO    ACTRQ2\n        WTO    MF=(E,MSACT)\n         XC    ACTECB,ACTECB\n         XC    ACTAREA,ACTAREA\n        WTOR   MF=(E,ACTMS)\nACTRQ1  WAIT   ECB=ACTECB\n         B     ACTRQ5\nACTRQ2   LH    R0,MSACT\n         SH    R0,=H'4'\n        TPUT   MSACT+4,(0)\n         XR    R0,R0\n         IC    R0,ACTMS+9\n         SH    R0,=H'4'\n        TPUT   ACTMS+12,(0)\nACTRQ3   XC    ACTAREA,ACTAREA\n        TGET   ACTAREA,L'ACTAREA\n         LTR   R15,R15\n         BZ    ACTRQ5\n         CH    R15,=H'12'\n         BNE   TSOERR\n        TCLEARQ INPUT\nACTRQ4   XR    R0,R0\n         IC    R0,ACTME+9\n         SH    R0,=H'4'\n        TPUT   ACTME+12,(0)\n         B     ACTRQ3\nACTRQ5   OC    ACTAREA(8),=CL8' '\n         LA    R1,L'ACTAREA\n         LA    R14,ACTAREA+L'ACTAREA-1\n         CLI   0(R14),C' '\n         BNE   *+L'*+6\n         BCTR  R14,0\n         BCT   R1,*-10\n         STC   R1,ACTRAL\n         XR    R15,R15\n         CLI   ACTRAL,1\n         BNE   ACTRQ7\n         CLI   ACTAREA,C'S'\n         BE    ACTRQ11\n         CLI   ACTAREA,C'R'\n         BE    ACTRQ12\n         CLI   ACTAREA,C'C'\n         BE    ACTRQ10\nACTRQ6   TM    SWITCH,SWTR\n         BO    ACTRQ4\n         XC    ACTECB,ACTECB\n         XC    ACTAREA,ACTAREA\n        WTOR   MF=(E,ACTME)\n         B     ACTRQ1\nACTRQ7   CLI   ACTRAL,4\n         BNE   *+L'*+14\n         CLC   ACTAREA(4),=CL4'SKIP'\n         BE    ACTRQ11\n         B     ACTRQ6\n         CLI   ACTRAL,5\n         BNE   *+L'*+14\n         CLC   ACTAREA(5),=CL5'RETRY'\n         BE    ACTRQ12\n         B     ACTRQ6\n         CLI   ACTRAL,6\n         BNE   ACTRQ6\n         CLC   ACTAREA(6),=CL6'CANCEL'\n         BNE   ACTRQ6\nACTRQ10  LA    R15,4(R15)\nACTRQ11  LA    R15,4(R15)\nACTRQ12  L     R14,ACTRQSV\n         BR    R14\n         SPACE 1\nMSACT   WTO    '1234567890123456789012345678901234567890123456789012345X\n               6789012345',ROUTCDE=1,DESC=3,MF=L\nACTMS   WTOR   '--- REPLY ''R'' IF RECOVERED, ''S'' TO SKIP, OR ''C'' TX\n               O CANCEL',ACTAREA,L'ACTAREA,ACTECB,ROUTCDE=2,DESC=2,MF=L\nACTME   WTOR   'SYNTAX ERROR - RESPECIFY ''R'', ''S'' OR ''C''',       X\n               ACTAREA,L'ACTAREA,ACTECB,ROUTCDE=2,DESC=2,MF=L\n         SPACE 1\nACTRQSV  DC    F'0'                SAVE R14.\nACTECB   DC    F'0'\nACTAREA  DC    XL8'0'\nACTRAL   DC    XL1'0'\n         SPACE 1\n        LTORG\n         SPACE 1\n         DROP  R8\n         EJECT\n        $HEDIT KEYWORDS\n*        PAUSE KEYWORD PROCESSING.\n*        -------------------------\n         SPACE 1\n         DS    0H\n         USING PAUSE,R10           LOCAL BASE REGISTER.\nPAUSE    TM    SWPRSS,SWTO\n         BO    RCMD\n         L     R8,=A(RSRVAR)\n         BASR  R14,R8\n         LA    R1,MSOPP+24\n         L     R8,=A(SETMSG)\n         BASR  R14,R8\n         TM    SWITCH,SWTR\n         BO    PSTSO\n         XC    RECB,RECB\n         XC    RAREA,RAREA\n        WTOR   MF=(E,MSOPP)\n        WAIT   ECB=RECB\n         LA    R1,L'RAREA\n         LA    R14,RAREA+L'RAREA-1\n         CLI   0(R14),0\n         BNE   RPLY\n         BCTR  R14,0\n         BCT   R1,*-10\n         B     RPLY\nPSTSO    TM    SWITCH,SWLS\n         BZ    PSTSONL\n        TPUT   CARD,L'CARD-8\nPSTSONL  XR    R0,R0\n         IC    R0,MSOPP+9\n         SH    R0,=H'4'\n        TPUT   MSOPP+12,(0)\nPSBCK    XC    RAREA,RAREA\n        TGET   RAREA,L'RAREA\n         LTR   R15,R15\n         BZ    RPLY\n         CH    R15,=H'12'\n         BNE   TSOERR\n        TCLEARQ INPUT\n        TPUT   MSSER,L'MSSER\n         B     PSBCK\nRPLY     OC    RAREA(8),=CL8' '\n         STC   R1,RAREAL\n         CLC   RAREA(8),=CL8'CANCEL '\n         BNE   RCMD\n         B     ENDMB\n         SPACE 1\nRECB     DC    F'0'\nMSOPP   WTOR   '--- PAUSE : 1234567890123456789012345678901234567890123X\n               456789012345',RAREA,L'RAREA,RECB,ROUTCDE=2,DESC=2,MF=L\nMSSER    DC    C'SYNTAX ERROR - RESPECIFY ... OR CANCEL'\n         SPACE 1\n        LTORG\n         SPACE 1\n         DROP  R10\n         SPACE 2\n*        MESSAGE KEYWORD PROCESSING.\n*        ---------------------------\n         SPACE 1\n         DS    0H\n         USING MESSAGE,R10         LOCAL BASE REGISTER.\nMESSAGE  TM    SWPRSS,SWTO\n         BO    RCMD\n         L     R8,=A(RSRVAR)\n         BASR  R14,R8\n         LA    R1,MSOPM+18\n         L     R8,=A(SETMSG)\n         BASR  R14,R8\n         TM    SWITCH,SWTR\n         BO    MESST\n        WTO    MF=(E,MSOPM)\n         B     RCMD\nMESST    TM    SWITCH,SWLS\n         BZ    MESSTNL\n        TPUT   CARD,L'CARD-8\nMESSTNL  LH    R0,MSOPM\n         SH    R0,=H'4'\n        TPUT   MSOPM+4,(0)\n         B     RCMD\n         SPACE 1\nMSOPM   WTO    '--- MESSAGE : 12345678901234567890123456789012345678901X\n               23456789012345',ROUTCDE=2,DESC=4,MF=L\n         SPACE 1\n        LTORG\n         SPACE 1\n         DROP  R10\n         SPACE 2\n*        IF-REPLY-BIN KEYWORD PROCESSING.\n*        --------------------------------\n         SPACE 1\n         DS    0H\n         USING IFRB,R10            LOCAL BASE REGISTER.\nIFRB     NI    SWPRSS,255-SWRC-SWRH\n         OI    SWPRSS,SWRB\n         B     IFRP1\n         SPACE 1\n         DROP  R10\n         SPACE 2\n*        IF-REPLY-CHAR KEYWORD PROCESSING.\n*        ---------------------------------\n         SPACE 1\n         DS    0H\n         USING IFRC,R10            LOCAL BASE REGISTER.\nIFRC     NI    SWPRSS,255-SWRB-SWRH\n         OI    SWPRSS,SWRC\n         B     IFRP1\n         SPACE 1\n         DROP  R10\n         SPACE 2\n*        IF-REPLY-HEX KEYWORD PROCESSING.\n*        --------------------------------\n         SPACE 1\n         DS    0H\n         USING IFRH,R10            LOCAL BASE REGISTER.\nIFRH     NI    SWPRSS,255-SWRB-SWRC\n         OI    SWPRSS,SWRH\n         B     IFRP1\n         SPACE 1\n         DROP  R10\n         SPACE 2\n*        IF-REPLY KEYWORD PROCESSING.\n*        ----------------------------\n         SPACE 1\n         DS    0H\n         USING IFRP,R10            LOCAL BASE REGISTER.\nIFRP     NI    SWPRSS,255-SWRB-SWRC-SWRH\n         DROP  R10\nIFRP1    BASR  R10,0               COMMON LOCAL BASE REGISTER.\n         USING *,R10\n         TM    SWPRSS,SWTO\n         BO    RCMD\n         OI    SWPRSS,SWRP\n         L     R8,=A(RSRVAR)\n         BASR  R14,R8\n         NI    SWPRSS,255-SWRP\n         MVC   VALT,=CL8' '\n         MVI   VALTL,0\n         CLI   0(R3),C' '          FIND OPERATOR.\n         BNE   *+L'*+8\n         BXLE  R3,R4,*-8\n         B     SERR\n         L     R8,=A(OPSET)\n         BASR  R14,R8\n         BXLE  R3,R4,*+L'*+4       FIND VALUE.\n         B     SERR\n         CLI   0(R3),C' '\n         BE    *-12\n         CLC   0(2,R3),=CL2''''''  NULL VALUE REQUESTED?\n         BNE   IFRP2               NO.\n         LA    R3,1(R3)\n         BXLE  R3,R4,*+L'*+4\n         B     SERR\n         CLI   0(R3),C' '\n         BNE   SERR\n         B     IFRP3\nIFRP2    LR    R6,R3\n         LA    R0,L'VALT\n         BXLE  R3,R4,*+L'*+4\n         B     SERR\n         CLI   0(R3),C' '\n         BE    *+L'*+8\n         BCT   R0,*-16\n         B     SERR\n         LA    R1,L'VALT\n         SR    R1,R0\n         EX    R1,MVVLT\n         LA    R1,1(R1)\n         STC   R1,VALTL\nIFRP3    BXLE  R3,R4,*+L'*+4       FIND LABEL.\n         B     SERR\n         CLI   0(R3),C' '\n         BE    IFRP3\n         LR    R6,R3\n         LA    R0,L'LABEL\n         BXLE  R3,R4,*+L'*+4\n         B     IFRP4\n         CLI   0(R3),C' '\n         BE    IFRP4\n         BCT   R0,*-16\n         B     SERR\nIFRP4    LA    R1,L'LABEL\n         SR    R1,R0\n         EX    R1,MVLAB\n         STC   R1,LABELL\n         XR    R2,R2\n         IC    R2,TMASK            EXECUTE IF.\n         TM    SWPRSS,SWRB+SWRC+SWRH    BIN-CHAR-HEX?\n         BNZ   IFRBCH              YES.\n         CLI   VALTL,0             NULL TEST ?\n         BE    *+L'*+8             YES.\n         CLI   RAREAL,0            NULL REPLY ?\n         BNE   *+L'*+10            NO.\n         CLC   VALTL,RAREAL\n         B     *+L'*+10\n         IC    R4,VALTL\n         BCTR  R4,0\n         EX    R4,CLVIF\n         EX    R2,TSVIF\n         B     NOSKIP\n         SPACE 1\nIFRBCH   MVC   ARG1,=CL8' '\n         XR    R14,R14\n         ICM   R14,B'0001',RAREAL\n         BZ    *+L'*+12\n         LA    R15,ARG1+L'ARG1\n         SR    R15,R14\n         BCTR  R14,0\n         EX    R14,MVRC1\n         MVC   ARG2,=CL8' '\n         XR    R14,R14\n         ICM   R14,B'0001',VALTL\n         BZ    *+L'*+12\n         LA    R15,ARG2+L'ARG2\n         SR    R15,R14\n         BCTR  R14,0\n         EX    R14,MVRC2\n         TM    SWPRSS,SWRC         CHAR?\n         BZ    *+L'*+14            NO, IT IS BIN OR HEX.\n         CLC   ARG1,ARG2\n         EX    R2,TSVIF\n         B     NOSKIP\n         TM    SWPRSS,SWRB         BIN?\n         BZ    IFRH1               NO, IT IS HEX.\n         PACK  WORK,ARG1\n         NI    WORK+L'WORK-1,X'F0'\n         OC    WORK+L'WORK-1(1),=PL1'+0'\n         CVB   R14,WORK\n         PACK  WORK,ARG2\n         NI    WORK+L'WORK-1,X'F0'\n         OC    WORK+L'WORK-1(1),=PL1'+0'\n         CVB   R15,WORK\n         CR    R14,R15\n         EX    R2,TSVIF\n         B     NOSKIP\nIFRH1    NC    ARG1,=XL8'1F1F1F1F1F1F1F1F'\n         TR    ARG1,HEXTB\n         PACK  WORK(5),ARG1(L'ARG1+1)\n         L     R14,WORK\n         NC    ARG2,=XL8'1F1F1F1F1F1F1F1F'\n         TR    ARG2,HEXTB\n         PACK  WORK(5),ARG2(L'ARG2+1)\n         L     R15,WORK\n         CR    R14,R15\n         EX    R2,TSVIF\n         B     NOSKIP\nCLVIF    CLC   RAREA(*-*),VALT     << EXECUTED >>\nTSVIF    NOP   SKIPTO              << EXECUTED >>\nMVRC1    MVC   0(*-*,R15),RAREA    << EXECUTED >>\nMVRC2    MVC   0(*-*,R15),VALT     << EXECUTED >>\n         SPACE 1\n*                 0 1 2 3 4 5 6 7 8 9 A B C D E F\nHEXTB    DC    X'000A0B0C0D0E0F000000000000000000'\n         DC    X'00010203040506070809000000000000'\n         SPACE 1\n        LTORG\n         SPACE 1\n         DROP  R10\n         SPACE 2\n*        VER-BIN KEYWORD PROCESSING.\n*        ---------------------------\n         SPACE 1\n         DS    0H\n         USING VERB,R10            LOCAL BASE REGISTER.\nVERB     NI    SWPRSS,255-SWRC-SWRH\n         OI    SWPRSS,SWRB\n         B     VER1\n         SPACE 1\n         DROP  R10\n         SPACE 2\n*        VER-HEX KEYWORD PROCESSING.\n*        ---------------------------\n         SPACE 1\n         DS    0H\n         USING VERH,R10            LOCAL BASE REGISTER.\nVERH     NI    SWPRSS,255-SWRB-SWRC\n         OI    SWPRSS,SWRH\n         DROP  R10\nVER1     BASR  R10,0               COMMON LOCAL BASE REGISTER.\n         USING *,R10\n         TM    SWPRSS,SWTO\n         BO    RCMD\n         CLI   0(R3),C' '          FIND LABEL.\n         BNE   *+L'*+8\n         BXLE  R3,R4,*-8\n         B     SERR\n         LR    R6,R3\n         LA    R0,L'LABEL\n         BXLE  R3,R4,*+L'*+4\n         B     VER2\n         CLI   0(R3),C' '\n         BE    VER2\n         BCT   R0,*-16\n         B     SERR\nVER2     LA    R1,L'LABEL\n         SR    R1,R0\n         EX    R1,MVLAB\n         STC   R1,LABELL\n         XR    R14,R14             EXECUTE VERIFY.\n         ICM   R14,B'0001',RAREAL\n         BZ    PRCSS\n         LA    R15,RAREA-1(R14)\nVER3     TM    SWPRSS,SWRB         BIN?\n         BO    VER4                YES.\n         CLI   0(R15),C'A'         NO, IT IS HEX.\n         BL    SKIPTO\n         CLI   0(R15),C'F'\n         BNH   VER5\nVER4     CLI   0(R15),C'0'\n         BL    SKIPTO\n         CLI   0(R15),C'9'\n         BH    SKIPTO\nVER5     BCTR  R15,0\n         BCT   R14,VER3\n         B     PRCSS\n         SPACE 1\n        LTORG\n         SPACE 1\n         DROP  R10\n         SPACE 2\n*        IF/IF-VAR KEYWORD PROCESSING.\n*        -----------------------------\n         SPACE 1\n         DS    0H\n         USING IFV,R10             LOCAL BASE REGISTER.\nIFV      TM    SWPRSS,SWTO\n         BO    RCMD\n         CLI   0(R3),C' '          FIND VARIABLE NAME.\n         BNE   *+L'*+8\n         BXLE  R3,R4,*-8\n         B     SERR\n         LR    R6,R3\n         LA    R0,L'VAR\n         MVC   VAR,=CL8' '\n         BXLE  R3,R4,*+L'*+4\n         B     SERR\n         CLI   0(R3),C' '\n         BE    *+L'*+8\n         BCT   R0,*-16\n         B     SERR\n         LA    R1,L'VAR\n         SR    R1,R0\n         EX    R1,MVVAR            GET VARIABLE NAME.\n         L     R1,ARVART           SCAN VARIABLES TABLE.\n         USING RVART,R1\nIFV1     TM    RVARNME,EOT         END OF TABLE?\n         BO    SERR                YES.\n         BZ    SERR                BRANCH IF FREE ELEMENT.\n         CLC   RVARNME,VAR         IS IT THIS ONE?\n         BE    *+L'*+8             YES.\n         LA    R1,RVARTL(R1)\n         B     IFV1\n         LA    R2,RVARV\n         XR    R0,R0\n         IC    R0,RVARVL\n         DROP  R1\n         MVI   VLSTR,C' '\n         OI    SWITCH,SWIV\n         B     IFCLBR\n         DROP  R10\n         SPACE 1\n         DS    0H\n         USING IF,R10              LOCAL BASE REGISTER.\nIF       TM    SWPRSS,SWTO\n         BO    RCMD\n         CLI   0(R3),C' '          FIND WHAT.\n         BNE   *+L'*+8\n         BXLE  R3,R4,*-8\n         B     SERR\n         L     R1,=A(FVTBL)\nIF1      CLI   0(R1),EOT\n         BE    SERR\n         CLC   0(8,R1),=CL8'RPID'\n         BE    IF2\n         XR    R2,R2\n         IC    R2,8(R1)\n         BCT   R2,*+L'*+6\n         CLC   0(*-*,R3),0(R1)     << EXECUTED >>\n         EX    R2,*-6\n         BNE   IF2\n         LA    R2,1(R2,R3)\n         CLI   0(R2),C' '\n         BE    *+L'*+8\nIF2      LA    R1,L'FVTBL(R1)\n         B     IF1\n         MVC   VLSTR(1),9(R1)\n         LR    R3,R2\n         XR    R0,R0\n         LR    R2,R0\n         IC    R0,10(R1)\n         ICM   R2,B'0111',11(R1)\n         NI    SWITCH,255-SWIV\n         DROP  R10\nIFCLBR   BASR  R10,0               COMMON LOCAL BASE REGISTER.\n         USING *,R10\n         MVC   VLSTR+1(L'VLSTR-1),VLSTR\n         BXLE  R3,R4,*+L'*+4       FIND OPERATOR.\n         B     SERR\n         CLI   0(R3),C' '\n         BE    *-12\n         L     R8,=A(OPSET)\n         BASR  R14,R8\n         BXLE  R3,R4,*+L'*+4       FIND VALUE.\n         B     SERR\n         CLI   0(R3),C' '\n         BE    *-12\n         LR    R6,R3\n         LR    R14,R0\n         BXLE  R3,R4,*+L'*+4\n         B     SERR\n         CLI   0(R3),C' '\n         BE    *+L'*+8\n         BCT   R0,*-16\n         B     SERR\n         LR    R1,R14\n         SR    R1,R0\n         LA    R15,VLSTR-1\n         AR    R15,R0\n         EX    R1,MVVAL\n         LR    R14,R1\n         LR    R15,R0\n         BXLE  R3,R4,*+L'*+4       FIND LABEL.\n         B     SERR\n         CLI   0(R3),C' '\n         BE    *-12\n         LR    R6,R3\n         LA    R0,L'LABEL\n         BXLE  R3,R4,*+L'*+4\n         B     IF3\n         CLI   0(R3),C' '\n         BE    IF3\n         BCT   R0,*-16\n         B     SERR\nIF3      LA    R1,L'LABEL\n         SR    R1,R0\n         EX    R1,MVLAB\n         STC   R1,LABELL\n         LR    R4,R14              EXECUTE IF.\n         BCTR  R15,0\n         LA    R2,0(R15,R2)\n         LA    R3,VLSTR(R15)\n         TM    SWITCH,SWTR+SWIV\n         BNZ   *+L'*+6\n         L     R8,=A(UPDT)\n         BASR  R14,R8\n         XR    R1,R1\n         IC    R1,TMASK\n         EX    R4,CLVAL\n         EX    R1,TSVAL\n         B     NOSKIP\nMVVAL    MVC   0(*-*,R15),0(R6)    << EXECUTED >>\nCLVAL    CLC   0(*-*,R2),0(R3)     << EXECUTED >>\nTSVAL    NOP   SKIPTO              << EXECUTED >>\n         SPACE 1\n        LTORG\n         SPACE 1\n         DROP  R10\n         SPACE 2\n*        IF-ID KEYWORD PROCESSING.\n*        -------------------------\n         SPACE 1\n         DS    0H\n         USING IFID,R10            LOCAL BASE REGISTER.\nIFID     TM    SWPRSS,SWTO\n         BO    RCMD\n         CLI   0(R3),C' '          FIND MESSAGE-ID TEXT.\n         BNE   *+L'*+8\n         BXLE  R3,R4,*-8\n         B     SERR\n         LA    R0,L'RPTXT\n         LA    R1,RPTXT\n         LR    R2,R1\n         MVI   RPTXTL,0\n         MVI   0(R2),C' '\n         MVC   1(L'RPTXT-1,R2),0(R2)\n         CLI   0(R3),C''''\n         BNE   IFID4\nIFID1    BXLE  R3,R4,*+L'*+4       QUOTED.\n         B     SERR\n         CLI   0(R3),C''''\n         BNE   IFID2\n         BXLE  R3,R4,*+L'*+4\n         B     SERR\n         CLI   0(R3),C' '\n         BE    IFID3\n         CLI   0(R3),C''''\n         BNE   SERR\nIFID2    MVC   0(1,R2),0(R3)\n         LA    R2,1(R2)\n         BCT   R0,IFID1\n         B     SERR\nIFID3    SR    R2,R1\n         BNP   SERR\n         CH    R2,=H'8'\n         BNL   IFID5\n         B     SERR\nIFID4    MVC   0(1,R2),0(R3)       NOT QUOTED.\n         LA    R2,1(R2)\n         BCT   R0,*+L'*+4\n         B     SERR\n         BXLE  R3,R4,*+L'*+4\n         B     SERR\n         CLI   0(R3),C' '\n         BNE   IFID4\n         SR    R2,R1\n         BNP   SERR\n         CH    R2,=H'8'\n         BNL   IFID5\n         LH    R2,=H'8'\nIFID5    BCTR  R2,0\n         STC   R2,RPTXTL\n         BXLE  R3,R4,*+L'*+4       FIND LABEL.\n         B     SERR\n         CLI   0(R3),C' '\n         BE    *-12\n         LR    R6,R3\n         LA    R0,L'LABEL\n         BXLE  R3,R4,*+L'*+4\n         B     IFID6\n         CLI   0(R3),C' '\n         BE    IFID6\n         BCT   R0,*-16\n         B     SERR\nIFID6    LA    R1,L'LABEL\n         SR    R1,R0\n         EX    R1,MVLAB\n         STC   R1,LABELL\n        $SRPI  RPTXTL,RPID         EXECUTE IF.\n         B     *+L'*(R15)\n         B     SKIPTO              +0\n         B     NOSKIP               4\n         B     SRPERR               8\n         SPACE 1\n        LTORG\n         SPACE 1\n         DROP  R10\n         SPACE 2\n*        GOTO KEYWORD PROCESSING.\n*        ------------------------\n         SPACE 1\n         DS    0H\n         USING GOTO,R10            LOCAL BASE REGISTER.\nGOTO     TM    SWPRSS,SWTO\n         BO    RCMD\n         CLI   0(R3),C' '          FIND LABEL.\n         BNE   *+L'*+8\n         BXLE  R3,R4,*-8\n         B     SERR\n         LR    R6,R3\n         LA    R0,L'LABEL\n         BXLE  R3,R4,*+L'*+4\n         B     GOTO1\n         CLI   0(R3),C' '\n         BE    GOTO1\n         BCT   R0,*-16\n         B     SERR\nGOTO1    LA    R1,L'LABEL\n         SR    R1,R0\n         EX    R1,MVLAB\n         STC   R1,LABELL\n         B     SKIPTO\n         SPACE 1\n        LTORG\n         SPACE 1\n         DROP  R10\n         SPACE 2\n*        SET-REPLY/SET-VAR KEYWORD PROCESSING.\n*        -------------------------------------\n         SPACE 1\n         DS    0H\n         USING SETR,R10            LOCAL BASE REGISTER.\nSETR     TM    SWPRSS,SWTO\n         BO    RCMD\n         CLI   0(R3),C' '          FIND VARIABLE NAME.\n         BNE   *+L'*+8\n         BXLE  R3,R4,*-8\n         B     SERR\n         LR    R6,R3\n         LA    R0,L'VAR\n         MVC   VAR,=CL8' '\n         BXLE  R3,R4,*+L'*+4\n         B     SETR1\n         CLI   0(R3),C' '\n         BE    SETR1\n         BCT   R0,*-16\n         B     SERR\nSETR1    LA    R1,L'VAR\n         SR    R1,R0\n         EX    R1,MVVAR            GET VARIABLE NAME.\n         L     R1,=A(FVTBL)\nSETR2    CLI   0(R1),EOT\n         BE    SETR3\n         CLC   VAR(L'VAR),0(R1)    CHECK AGAINST RESERVED NAME.\n         BE    SERR\n         LA    R1,L'FVTBL(R1)\n         B     SETR2\nSETR3    BXLE  R3,R4,*+L'*+4\n         B     SETR6               IF NO VALUE USE REPLY.\n         CLI   0(R3),C' '\n         BE    *-12\n         MVC   VALT,=CL8' '\n         MVI   VALTL,0\n         CLC   0(2,R3),=CL2''''''  NULL VALUE REQUESTED?\n         BNE   SETR4               NO.\n         LA    R3,1(R3)\n         BXLE  R3,R4,*+L'*+4\n         B     SETR7\n         CLI   0(R3),C' '\n         BE    SETR7\n         B     SERR\nSETR4    LR    R6,R3\n         LA    R0,L'VALT\n         BXLE  R3,R4,*+L'*+4\n         B     SETR5\n         CLI   0(R3),C' '\n         BE    SETR5\n         BCT   R0,*-16\n         B     SERR\nSETR5    LA    R1,L'VALT\n         SR    R1,R0\n         EX    R1,MVVLT\n         LA    R1,1(R1)\n         STC   R1,VALTL\n         B     SETR7\nSETR6    MVC   VALT,RAREA\n         MVC   VALTL,RAREAL\nSETR7    L     R1,ARVART           SCAN VARIABLES TABLE.\n         USING RVART,R1\nSETR8    TM    RVARNME,EOT         END OF TABLE?\n         BO    ERVR                YES.\n         BZ    SETR9               BRANCH IF FREE ELEMENT.\n         CLC   RVARNME,VAR         THIS ONE MATCH?\n         BE    SETR10              YES, UPDATE IT.\n         LA    R1,RVARTL(R1)\n         B     SETR8\nSETR9    MVC   RVARNME,VAR         ENTER VARIABLE NAME IN TABLE.\nSETR10   MVC   RVARV,VALT\n         MVC   RVARVL,VALTL\n         DROP  R1\n         B     PRCSS\n         SPACE 1\n        LTORG\n         SPACE 1\n         DROP  R10\n         SPACE 2\n*        EXECUTE ANOTHER MEMBER.\n*        -----------------------\n         SPACE 1\n         DS    0H\n         USING EXECUTE,R10         LOCAL BASE REGISTER.\nEXECUTE  TM    SWPRSS,SWTO\n         BO    RCMD\n         L     R8,=A(RSRVAR)\n         BASR  R14,R8\n         CLI   0(R3),C' '          FIND PO-DSNAME.\n         BNE   *+L'*+8\n         BXLE  R3,R4,*-8\n         B     SERR\n         CLI   0(R3),C'*'          DATA-SET IN USE?\n         BE    EXC2                YES.\n         LR    R6,R3\n         LA    R0,L'DSNM\n         MVI   DSNM,C' '\n         MVC   DSNM+1(L'DSNM-1),DSNM\n         BXLE  R3,R4,*+L'*+4\n         B     EXC1\n         CLI   0(R3),C' '\n         BE    EXC1\n         BCT   R0,*-16\n         B     SERR\nEXC1     LA    R1,L'DSNM\n         SR    R1,R0\n         EX    R1,MVDSN\nEXC2     BXLE  R3,R4,*+L'*+4       FIND MEMBER NAME.\n         B     SERR\n         CLI   0(R3),C' '\n         BE    EXC2\n         LR    R6,R3\n         LA    R0,L'MEMBER\n         MVC   MEMBER,=CL8' '\n         BXLE  R3,R4,*+L'*+4\n         B     EXC3\n         CLI   0(R3),C' '\n         BE    EXC3\n         BCT   R0,*-16\n         B     SERR\nEXC3     LA    R1,L'MEMBER\n         SR    R1,R0\n         EX    R1,MVMBN\n         TM    SWITCH,SWTR\n         BZ    EXC4\n         TM    SWITCH,SWLS\n         BZ    EXC4\n        TPUT   CARD,L'CARD-8\nEXC4     XR    R0,R0               NOW ADD NEW DD-NAME ENTRY.\n         L     R6,DDPTR\n         USING DDTAB,R6\nEXC5     ICM   R0,B'0011',DDTFN\n         AL    R6,=A(DDTABL)\n         OC    DDTFN,DDTFN         ALREADY IN USE?\n         BO    ERTB                NO, TABLE OVERFLOW.\n         BNZ   EXC5                YES.\n         AH    R0,=H'1'            FREE, BUILD NEW DD-NAME.\n         STCM  R0,B'0011',DDTFN\n         CVD   R0,WORK\n         MVC   DDTNME+3(5),=XL5'2120202020'\n         ED    DDTNME+3(5),WORK+5\n         MVC   DDTNME(L'DDTNME-3),=CL5'SYSPO'\n         MVC   DDTMBN,MEMBER       SET MEMBER NAME.\n         MVC   DDTDSN,DSNM         SET DATA-SET NAME.\n         L     R1,DALIST           ALLOCATE NEW DD-NAME.\n         LR    R2,R1\n         L     R3,=A(DYNLGTH)\n         LA    R4,*\n         XR    R5,R5\n         ICM   R5,B'1000',=CL8' '\n         MVCL  R2,R4\n         USING DYNLIST,R1\n         MVC   DDNAME,DDTNME\n         MVC   DSNAME,DSNM\n         MVC   DSSTATUS(3),=CL3'SHR'\n         MVC   DSNDISP(4),=CL4'KEEP'\n         MVC   DSADISP(4),=CL4'KEEP'\n         DROP  R1\n         B     EXC6+L'EXC6\nEXC6     L     R1,DALIST\n        $DYNALL (R1),RCODES\n         LTR   R15,R15\n         BZ    EXC7\n         LA    R1,DSNM\n         L     R8,=A(ACTRQ)\n         BASR  R14,R8              REQUEST ACTION.\n         B     *+L'*(R15)\n         B     EXC6                0 - RETRY (RECOVERED).\n         B     *+L'*+4             4 - SKIP (IGNORE).\n         B     *+L'*+12            8 - CANCEL.\n         BAS   R8,DAMSG            ALLOCATION ERROR.\n         DC    CL4'ALL.'\n         B     RCMD                CONTINUE PROCESSING.\n         BAS   R8,DAMSG            ALLOCATION ERROR.\n         DC    CL4'ALL.'\n         XC    DDTFN(DDTABL),DDTFN ELIMINE ENTRY.\n         TM    SWITCH,SWTR\n         BZ    TOPERS\n         TM    SWITCH,SWSY\n         BO    TOPERS\n         B     RCMD                CONTINUE PROCESSING.\n         DROP  R6\nEXC7     ST    R6,DDPTR            PROCESS MEMBER.\n         LR    R1,R6\n         B     OPDS\nMVDSN    MVC   DSNM(*-*),0(R6)     << EXECUTED >>\nMVMBN    MVC   MEMBER(*-*),0(R6)   << EXECUTED >>\n         SPACE 1\n        LTORG\n         SPACE 1\n         DROP  R10\n         SPACE 2\n*        LOGICAL KEYWORD PROCESSING.\n*        ---------------------------\n         SPACE 1\n         DS    0H\n         USING LOGICAL,R10         LOCAL BASE REGISTER.\nLOGICAL  TM    SWPRSS,SWTO\n         BO    RCMD\n         CLI   0(R3),C' '          FIND VARIABLE.\n         BNE   LGC1\n         BXLE  R3,R4,*-8\n         B     SERR\nLGC1     LR    R6,R3\n         LA    R0,L'VAR\n         MVC   VAR,=CL8' '\n         BXLE  R3,R4,*+L'*+4\n         B     LGC2\n         CLI   0(R3),C' '\n         BE    LGC2\n         BCT   R0,*-16\n         B     SERR\nLGC2     LA    R1,L'VAR\n         SR    R1,R0\n         EX    R1,MVVAR            GET VARIABLE NAME.\n         L     R1,ALVART           SCAN VARIABLES TABLE.\n         USING LVART,R1\nLGC3     TM    LVARNME,EOT         END OF TABLE?\n         BO    ERVB                YES.\n         BZ    LGC4                BRANCH IF FREE ELEMENT.\n         CLC   LVARNME,VAR         THIS ONE MATCH?\n         BE    ESDV                YES, ALREADY DEFINED.\n         LA    R1,LVARTL(R1)\n         B     LGC3\n         DROP  R1\nLGC4     LR    R6,R1\n         USING LVART,R6\n         MVC   LVARNME,VAR         ENTER VARIABLE NAME IN TABLE.\n         XR    R0,R0\n         S     R1,ALVART\n         BZ    *+L'*+10\n         D     R0,=A(LVARTL)\n         LR    R0,R1\n         SRL   R0,3\n         STC   R0,LVARSBN          SET SWITCH BYTE NUMBER.\n         LA    R0,BIT5+BIT6+BIT7\n         NR    R1,R0\n         LA    R0,BIT0\n         SRL   R0,0(R1)\n         STC   R0,LVARSMB          SET SWITCH MASK BIT.\n         DROP  R6\n         BXLE  R3,R4,*+L'*+4\n         B     PRCSS\n         CLI   0(R3),C' '\n         BE    *-12\n         B     LGC1                GO GET NEXT VARIABLE.\n         SPACE 1\n        LTORG\n         SPACE 1\n         DROP  R10\n         SPACE 2\n*        TRUE/FALSE KEYWORD PROCESSING.\n*        ------------------------------\n         SPACE 1\n         DS    0H\n         USING TRUE,R10            LOCAL BASE REGISTER.\nTRUE     TM    SWPRSS,SWTO\n         BO    RCMD\n         OI    SWPRSS,SWTF         SET TRUE.\n         BAS   R10,TF1\n         DROP  R10\n         USING FALSE,R10           LOCAL BASE REGISTER.\nFALSE    TM    SWPRSS,SWTO\n         BO    RCMD\n         NI    SWPRSS,255-SWTF     SET FALSE.\nTF1      CLI   0(R3),C' '          FIND VARIABLE.\n         BNE   TF2\n         BXLE  R3,R4,TF1\n         B     SERR\nTF2      LR    R6,R3\n         LA    R0,L'VAR\n         MVC   VAR,=CL8' '\n         BXLE  R3,R4,*+L'*+4\n         B     TF3\n         CLI   0(R3),C' '\n         BE    TF3\n         BCT   R0,*-16\n         B     SERR\nTF3      LA    R1,L'VAR\n         SR    R1,R0\n         EX    R1,MVVAR            GET VARIABLE NAME.\n         L     R2,ALVART           SCAN VARIABLES TABLE.\n         USING LVART,R2\nTF4      TM    LVARNME,EOT         END OF TABLE?\n         BO    ERUV                YES.\n         BZ    ERUV                BRANCH IF FREE ELEMENT.\n         CLC   LVARNME,VAR         THIS ONE MATCH?\n         BE    *+L'*+8             YES.\n         LA    R2,LVARTL(R2)\n         B     TF4\n         XR    R0,R0\n         IC    R0,LVARSBN          GET SWITCH BYTE NUMBER.\n         XR    R1,R1\n         IC    R1,LVARSMB          GET SWITCH MASK BIT.\n         DROP  R2\n         L     R2,ASWVAR\n         AR    R2,R0\n         TM    SWPRSS,SWTF\n         BZ    *+L'*+8\n         EX    R1,STTRUE           SET VARIABLE TRUE.\n         B     *+L'*+10\n         LA    R0,X'FF'\n         XR    R1,R0\n         EX    R1,STFLSE           SET VARIABLE FALSE.\n         BXLE  R3,R4,*+L'*+4\n         B     PRCSS\n         CLI   0(R3),C' '\n         BE    *-12\n         B     TF2                 GO GET NEXT VARIABLE.\nSTTRUE   OI    0(R2),*-*           << EXECUTED >>\nSTFLSE   NI    0(R2),*-*           << EXECUTED >>\n         SPACE 1\n        LTORG\n         SPACE 1\n         DROP  R10\n         SPACE 2\n*        IF-TRUE/IF-FALSE KEYWORD PROCESSING.\n*        ------------------------------------\n         SPACE 1\n         DS    0H\n         USING IFTRUE,R10          LOCAL BASE REGISTER.\nIFTRUE   TM    SWPRSS,SWTO\n         BO    RCMD\n         OI    SWPRSS,SWTF         SET TRUE.\n         BAS   R10,IFTF1\n         DROP  R10\n         USING IFFALSE,R10         LOCAL BASE REGISTER.\nIFFALSE  TM    SWPRSS,SWTO\n         BO    RCMD\n         NI    SWPRSS,255-SWTF     SET FALSE.\nIFTF1    CLI   0(R3),C' '          FIND VARIABLE.\n         BNE   *+L'*+8\n         BXLE  R3,R4,IFTF1\n         B     SERR\n         LR    R6,R3\n         LA    R0,L'VAR\n         MVC   VAR,=CL8' '\n         BXLE  R3,R4,*+L'*+4\n         B     IFTF2\n         CLI   0(R3),C' '\n         BE    IFTF2\n         BCT   R0,*-16\n         B     SERR\nIFTF2    LA    R1,L'VAR\n         SR    R1,R0\n         EX    R1,MVVAR            GET VARIABLE NAME.\n         L     R2,ALVART           SCAN VARIABLES TABLE.\n         USING LVART,R2\nIFTF3    TM    LVARNME,EOT         END OF TABLE?\n         BO    ERUV                YES.\n         BZ    ERUV                BRANCH IF FREE ELEMENT.\n         CLC   LVARNME,VAR         THIS ONE MATCH?\n         BE    *+L'*+8             YES.\n         LA    R2,LVARTL(R2)\n         B     IFTF3\n         BXLE  R3,R4,*+L'*+4       FIND LABEL.\n         B     SERR\n         CLI   0(R3),C' '\n         BE    *-12\n         LR    R6,R3\n         LA    R0,L'LABEL\n         BXLE  R3,R4,*+L'*+4\n         B     IFTF4\n         CLI   0(R3),C' '\n         BE    IFTF4\n         BCT   R0,*-16\n         B     SERR\nIFTF4    LA    R1,L'LABEL\n         SR    R1,R0\n         EX    R1,MVLAB\n         STC   R1,LABELL\n         XR    R0,R0\n         IC    R0,LVARSBN          GET SWITCH BYTE NUMBER.\n         XR    R1,R1\n         IC    R1,LVARSMB          GET SWITCH MASK BIT.\n         DROP  R2\n         L     R2,ASWVAR\n         AR    R2,R0\n         TM    SWPRSS,SWTF         EXECUTE IF.\n         BZ    *+L'*+12\n         EX    R1,IFTMTF           IS VARIABLE TRUE?\n         BO    SKIPTO              YES.\n         B     NOSKIP\n         EX    R1,IFTMTF           IS VARIABLE FALSE?\n         BZ    SKIPTO              YES.\n         B     NOSKIP\nIFTMTF   TM    0(R2),*-*           << EXECUTED >>\n         SPACE 1\n        LTORG\n         SPACE 1\n         DROP  R10\n         SPACE 2\n*        NULL KEYWORD PROCESSING.\n*        ------------------------\n         SPACE 1\n         DS    0H\n         USING NULL,R10            LOCAL BASE REGISTER.\nNULL     TM    SWPRSS,SWNL         NULL DISABLED?\n         BO    SERR                YES.\n         OI    SWPRSS,SWNL         INHIBIT ANOTHER.\n         CLI   0(R3),C' '          FIND LABEL.\n         BNE   *+L'*+8\n         BXLE  R3,R4,*-8\n         B     SERR\n         XR    R1,R1\n         IC    R1,LABELL\n         EX    R1,CLLAB\n         BE    NULL3               MAY BE THIS ONE.\nNULL1    TM    SWPRSS,SWTO\n         BO    RCMD\n         BXLE  R3,R4,*+L'*+4       LOOK IF AN INSTRUCTION FOLLOWS.\n         B     PRCSS\n         CLI   0(R3),C' '\n         BNE   *-12\nNULL2    BXLE  R3,R4,*+L'*+4\n         B     PRCSS\n         CLI   0(R3),C' '\n         BE    NULL2\n         B     SCTBL\nNULL3    AR    R3,R1\n         BXLE  R3,R4,*+L'*+4\n         B     NOSKIP\n         CLI   0(R3),C' '\n         BNE   NULL1               NOT THIS ONE.\n         NI    SWPRSS,255-SWTO\n         B     NULL2\nCLLAB    CLC   LABEL(*-*),0(R3)    << EXECUTED >>\n         SPACE 1\n        LTORG\n         SPACE 1\n         DROP  R10\n         SPACE 2\n*        GDATE KEYWORD PROCESSING.\n*        -------------------------\n         SPACE 1\n         DS    0H\n         USING GDTE,R10            LOCAL BASE REGISTER.\nGDTE     TM    SWPRSS,SWTO\n         BO    RCMD\n         TM    SWITCH,SWTR\n         BO    GDTE1\n         L     R8,=A(UPDT)\n         BASR  R14,R8\n         MVC   MSGDT+15(L'FDATE),FDATE\n         MVC   MSGDT+45(L'THRS),THRS\n         MVC   MSGDT+48(L'TMNS),TMNS\n         MVC   MSGDT+51(L'TSCS),TSCS\n        WTO    MF=(E,MSGDT)\n         B     RCMD\nGDTE1    TM    SWITCH,SWLS\n         BZ    GDTE2\n        TPUT   CARD,L'CARD-8\nGDTE2    MVC   MSGDT+15(L'FDATE),FDATE\n         MVC   MSGDT+45(L'THRS),THRS\n         MVC   MSGDT+48(L'TMNS),TMNS\n         MVC   MSGDT+51(L'TSCS),TSCS\n         LH    R0,MSGDT\n         SH    R0,=H'4'\n        TPUT   MSGDT+4,(0)\n         B     RCMD\n         SPACE 1\nMSGDT   WTO    '--- DATE : 12345678901234567890 - TIME : HH.MM.SS',    X\n               ROUTCDE=2,DESC=4,MF=L\n         SPACE 1\n        LTORG\n         SPACE 1\n         DROP  R10\n         SPACE 2\n*        T-WAIT KEYWORD PROCESSING.\n*        --------------------------\n         SPACE 1\n         DS    0H\n         USING TW,R10              LOCAL BASE REGISTER.\nTW       TM    SWPRSS,SWTO\n         BO    RCMD\n         L     R8,=A(RSRVAR)\n         BASR  R14,R8\n         CLI   0(R3),C' '          FIND SECONDS.\n         BNE   *+L'*+8\n         BXLE  R3,R4,*-8\n         B     PRCSS               NONE, NO WAIT.\n         LA    R0,3\n         XR    R1,R1\n         XR    R14,R14\n         LA    R15,15\nTW1      CLI   0(R3),C'0'\n         BL    SERR\n         CLI   0(R3),C'9'\n         BH    SERR\n         IC    R14,0(R3)\n         NR    R14,R15\n         LTR   R1,R1\n         BZ    *+L'*+4\n         MH    R1,=H'10'\n         AR    R1,R14\n         BXLE  R3,R4,*+L'*+4\n         B     *+L'*+16\n         CLI   0(R3),C' '\n         BE    *+L'*+8\n         BCT   R0,TW1\n         B     SERR\n         LTR   R1,R1\n         BNP   PRCSS               ZERO, NO WAIT.\n         CH    R1,=H'120'\n         BH    SERR                ERROR, TOO HIGH.\n         MH    R1,=H'100'\n         ST    R1,WORK\n        STIMER WAIT,,BINTVL=WORK\n         B     PRCSS\n         SPACE 1\n        LTORG\n         SPACE 1\n         DROP  R10\n         SPACE 2\n*        SUBMIT KEYWORD PROCESSING.\n*        --------------------------\n         SPACE 1\n         DS    0H\n         USING SBMT,R10            LOCAL BASE REGISTER.\nSBMT     TM    SWPRSS,SWTO\n         BO    RCMD\n         L     R8,=A(RSRVAR)\n         BASR  R14,R8\n         CLI   0(R3),C' '          FIND DSNAME.\n         BNE   *+L'*+8\n         BXLE  R3,R4,*-8\n         B     SERR\n         CLI   0(R3),C'*'          FROM CURRENT DATA-SET?\n         BNE   SBM1                NO.\n         MVC   SBDSNM,DSNM         SET IT.\n         BXLE  R3,R4,*+L'*+4       MUST BE PARTITIONED MEMBER.\n         B     SERR\n         CLI   0(R3),C'('\n         BNE   SERR\n         BXLE  R3,R4,SBM4\n         B     SERR\nSBM1     LR    R6,R3\n         LA    R0,L'SBDSNM\n         MVI   SBDSNM,C' '\n         MVC   SBDSNM+1(L'SBDSNM-1),SBDSNM\n         MVC   SBMEM,=CL8' '\nSBM2     BXLE  R3,R4,*+L'*+4\n         B     SBM3\n         CLI   0(R3),C' '\n         BE    SBM3\n         CLI   0(R3),C'('\n         BE    SBM3\n         BCT   R0,SBM2\n         B     SERR\nSBM3     LA    R1,L'SBDSNM\n         SR    R1,R0\n         EX    R1,MVSBDSN\n         CLR   R3,R5\n         BH    SBM6                DATA-SET IS SEQUENTIAL.\n         CLI   0(R3),C'('\n         BNE   SBM6                DATA-SET IS SEQUENTIAL.\n         BXLE  R3,R4,SBM4          FIND MEMBER NAME OF PARTITIONED.\n         B     SERR\nSBM4     LR    R6,R3\n         LA    R0,L'SBMEM\nSBM5     BXLE  R3,R4,*+L'*+4\n         B     SBM6\n         CLI   0(R3),C' '\n         BE    SERR\n         CLI   0(R3),C')'\n         BE    *+L'*+8\n         BCT   R0,SBM5\n         B     SERR\n         LA    R1,L'SBMEM\n         SR    R1,R0\n         EX    R1,MVSBMBN\nSBM6     TM    SWITCH,SWTR\n         BZ    SBM7\n         TM    SWITCH,SWLS\n         BZ    SBM7\n        TPUT   CARD,L'CARD-8\nSBM7     L     R1,DASBIN           ALLOCATE SUBMIT INPUT.\n         LR    R2,R1\n         L     R3,=A(DYNLGTH)\n         LA    R4,*\n         XR    R5,R5\n         ICM   R5,B'1000',=CL8' '\n         MVCL  R2,R4\n         USING DYNLIST,R1\n         MVC   DDNAME,SBDDN\n         MVC   DSNAME,SBDSNM\n         MVC   DSMEMBER,SBMEM\n         MVC   DSSTATUS(3),=CL3'SHR'\n         MVC   DSNDISP(4),=CL4'KEEP'\n         MVC   DSADISP(4),=CL4'KEEP'\n         DROP  R1\n         B     SBM8+L'SBM8\nSBM8     L     R1,DASBIN\n        $DYNALL (R1),RCODES\n         LTR   R15,R15\n         BZ    SBM9\n         LA    R1,SBDSNM\n         L     R8,=A(ACTRQ)\n         BASR  R14,R8              REQUEST ACTION.\n         B     *+L'*(R15)\n         B     SBM8                0 - RETRY (RECOVERED).\n         B     *+L'*+4             4 - SKIP (IGNORE).\n         B     *+L'*+16            8 - CANCEL.\n         LA    R6,SBDDN-(DDTNME-DDTAB)\n         BAS   R8,DAMSG            ALLOCATION ERROR.\n         DC    CL4'ALL.'\n         B     RCMD                CONTINUE PROCESSING.\n         LA    R6,SBDDN-(DDTNME-DDTAB)\n         BAS   R8,DAMSG            ALLOCATION ERROR.\n         DC    CL4'ALL.'\n         TM    SWITCH,SWTR\n         BZ    TOPERS\n         TM    SWITCH,SWSY\n         BO    TOPERS\n         B     RCMD                CONTINUE PROCESSING.\nSBM9     OI    SWITCH,SWSI\n         TM    SWITCH,SWTR         LIST MAY BE ALLOWED UNDER TEST.\n         BZ    SBM11\n         TM    SWITCH,SWSY         BUT NOT IF SYSTEM OPTION.\n         BO    SBM11\n        TPUT   TSSRQ,L'TSSRQ\n         XC    RBRSC,RBRSC\n        TGET   RBRSC,L'RBRSC\n         LTR   R15,R15\n         BZ    SBM10\n         CH    R15,=H'12'\n         BNE   SBM34\n        TCLEARQ INPUT\n         B     *+L'*+6\nSBM10    LTR   R1,R1\n         BZ    SBM34\n         OI    RBRSC,C' '\n         CLI   RBRSC,C'Y'\n         BNE   SBM34\n         NI    SWJBSC,255-SWJS\n         OI    SWJBSC,SWJL         SET LIST OF SUBMIT JOB.\n         B     SBM12\nSBM11    NI    SWJBSC,255-SWJS     ALLOCATE INTERNAL READER.\n         ZAP   CCJB,=PL1'+0'\n         XC    RBRSC,RBRSC\n         MVC   TXTDDNL,=XL2'0008'\n         MVC   TXTDDN,=CL8' '\n         LA    R1,RBBKPTR\n        DYNALLOC\n         LTR   R15,R15             CHECK FOR ERRORS?\n         AIF   ('&SYSPARM' NE 'NOVSAM').O20S1\n         BZ    SBM12               OK, ALLOCATED.\n         AGO   .O20S2\n.O20S1   BZ    *+L'*+26            OK, ALLOCATED.\n.O20S2   MVC   RCODES,RBRSC\n         ST    R15,RCODES+4\n         LA    R6,TXTDDN-(DDTNME-DDTAB)\n         BAS   R8,DAMSG            ALLOCATION ERROR.\n         DC    CL4'ALL.'\n         B     TOPERS\n         AIF   ('&SYSPARM' EQ 'NOVSAM').O20S3\n         MVC   INRDR+(ACBDDNM-IFGACB)(L'ACBDDNM),TXTDDN\n        OPEN   (INRDR)             OPEN JES2 ACB.\n         LTR   R15,R15\n         BZ    SBM12\n         OI    SWJBSC,SWJIO        SET OPEN ACB ERROR.\n         MVC   MSEIR+8(15),=CL15'IN.RDR ACB OPEN'\n         B     SBM25\n.O20S3   ANOP\nSBM12   $READ  TEXT,SBDDN\n         LTR   R15,R15\n         BM    SBM27\n         BZ    *+L'*+10\n         MVC   MSEIR+8(15),=CL15'SUBMIT DATA-SET'\n         B     SBM25\n         TM    SWJBSC,SWJL         LIST OF SUBMIT JOB?\n         BZ    SBM13               NO.\n        TPUT   TEXT,L'TEXT-8\n         B     SBM12\nSBM13    TM    SWJBSC,SWJS         BYPASS REQUESTED?\n         BO    SBM23               YES.\n         TM    SWJBSC,SWJB         JOB STATEMENT PROCESSED?\n         BO    SBM23               YES.\n         AP    CCJB,=PL1'+1'\n         LM    R3,R5,SCTXT\n         CLC   0(2,R3),=CL2'//'\n         BNE   JERR\n         LA    R3,2(R3)\n         TM    SWJBSC,SWJN         JOB STATEMENT CONTINUATION?\n         BZ    SBM14               NO.\n         CLI   0(R3),C' '\n         BE    SBM15\nJERR     SL    R3,SCTXT            RELATIVE POSITION IN CARD.\n         LA    R3,1(R3)\n         CVD   R3,WORK\n         BAS   R14,EDITW\n         MVC   MSEJB+31(2),WORK+2\n         UNPK  MSEJB+26(2),CCJB    JOB RELATIVE CARD.\n         OI    MSEJB+27,C'0'\n         MVC   MSEJB+57(8),SBMEM\n         LA    R1,MSEJB\n         BAS   R8,SBMR1\n         B     SBM26\nSBM14    CLI   0(R3),C' '          SCAN JOB STATEMENT FOR :\n         BE    JERR                     USER=...\n         BXLE  R3,R4,*+L'*+4            PASSWORD=...\n         B     JERR\n         CLI   0(R3),C' '\n         BNE   *-12\n         BXLE  R3,R4,*+L'*+4\n         B     JERR\n         CLI   0(R3),C' '\n         BE    *-12\n         CLC   0(4,R3),=CL4'JOB '\n         BNE   JERR\n         AIF   ('&SYSPARM' EQ 'NOVSAM').O21S1\n         LA    R0,TEXT+3\n         LR    R1,R3\n         SLR   R1,R0\n         LA    R0,7\n         CLR   R1,R0\n         BNH   *+L'*+2\n         LR    R1,R0\n         MVC   MSJNN+16(8),INSTXT+2\n         MVC   MSJNN+16(*-*),TEXT+2\n         EX    R1,*-6              SET JOB-NAME IN MESSAGE.\n.O21S1   LA    R3,3(R3)\nSBM15    BXLE  R3,R4,*+L'*+4\n         B     JERR\n         CLI   0(R3),C' '\n         BE    SBM15\n         TM    SWJBSC,SWJN\n         BZ    *+L'*+10\n         LR    R0,R3\n         S     R0,=A(TEXT+15)\n         BP    JERR\n         OI    SWJBSC,SWJN\nSBM16    CLI   0(R3),C''''\n         BE    SBM18\n         TM    SWJBSC,SWJA\n         BO    SBM17\n         CLC   0(2,R3),=CL2', '\n         BE    SBM23\n         CLI   0(R3),C' '\n         BE    SBM20\n         CLC   0(9,R3),=CL9'PASSWORD='  PASSWORD CODED?\n         BE    SBM22               YES.\n         TM    SWJBSC,SWJU\n         BO    SBM17\n         CLC   0(5,R3),=CL5'USER='\n         BE    SBM19\nSBM17    BXLE  R3,R4,*+L'*+4\n         B     JERR\n         CLR   R3,R5\n         BL    SBM16\n         CLI   0(R3),C','\n         BNE   SBM16\n         B     SBM23\nSBM18    TM    SWJBSC,SWJA\n         BO    *+L'*+8\n         OI    SWJBSC,SWJA\n         B     SBM17\n         NI    SWJBSC,255-SWJA\n         B     SBM17\nSBM19    LA    R3,4(R3)            EXTRACT USER-ID.\n         BXLE  R3,R4,*+L'*+4\n         B     JERR\n         CLI   0(R3),C' '\n         BE    SBM23\n         CLI   0(R3),C','\n         BE    SBM23\n         LR    R6,R3\n         BXLE  R3,R4,*+L'*+4\n         B     *+L'*+16\n         CLI   0(R3),C' '\n         BE    *+L'*+8\n         CLI   0(R3),C','\n         BNE   *-20\n         LR    R1,R3\n         SR    R1,R6\n         STC   R1,JUSERL\n         MVC   JUSER,=CL8' '\n         BCTR  R1,0\n         EX    R1,SBMMVUS\n         CLR   R3,R5\n         BH    *+L'*+24\n         CLI   0(R3),C' '\n         BE    *+L'*+16\n         OI    SWJBSC,SWJU\n         B     SBM16\nSBM20    TM    SWJBSC,SWJU\n         BZ    SBM22\n         CP    CCJB,=PL1'+1'       JOB STATEMENT IN ONLY ONE CARD?\n         BE    SBM22               YES.\n         XC    GPWAR(GPWAL-L'GPWA),GPWAR     GET PASSWORD FROM RACF.\n        SETAUTH\n        ICHEINTY LOCATE,TYPE='USR',ENTRY=JUSERL,                       X\n               ACTIONS=(GPSW),WKAREA=GPWA\n         LR    R6,R15\n        RESAUTH\n         LTR   R6,R6\n         BZ    SBM21\n         CVD   R6,WORK\n         BAS   R14,EDITW\n         MVC   MSEPL+32(2),WORK+2\n         MVC   MSEPL+58(8),SBMEM\n         LA    R1,MSEPL\n         BAS   R8,SBMR1\n         B     SBM22\nSBM21    CLC   GPPL,=XL2'0008'\n         BNE   SBM22\n         MVI   INSTXTP,C' '        DECODE RACF PASSWORD.\n         MVC   INSTXTP+1(10),INSTXTP\n        CALL   PSWREST,(GPPW,INSTXTP,LGPPW),VL\n         LTR   R15,R15\n         BNZ   SBM22\n         CLI   INSTXTP,C' '\n         BE    SBM22\n         LA    R1,INSTXTP+8        ADD JOB PASSWORD KEYWORD.\n         CLI   0(R1),C' '\n         BNE   *+L'*+4\n         BCT   R1,*-8\n         MVC   1(2,R1),=CL2'),'\n         AIF   ('&SYSPARM' NE 'NOVSAM').O22S1\n        $PUNCH INSTXT,,TXTDDN\n         AGO   .O22S2\n.O22S1  MODCB  RPL=REQPL,AREA=INSTXT\n         LTR   R15,R15\n         BNZ   SBM24\n        PUT    RPL=REQPL\n.O22S2   LTR   R15,R15\n         BNZ   SBM24\nSBM22    OI    SWJBSC,SWJB\n         AIF   ('&SYSPARM' NE 'NOVSAM').O22S3\nSBM23   $PUNCH TEXT,,TXTDDN\n         AGO   .O22S4\n.O22S3   ANOP\nSBM23   MODCB  RPL=REQPL,AREA=TEXT\n         LTR   R15,R15\n         BNZ   SBM24\n        PUT    RPL=REQPL\n.O22S4   LTR   R15,R15\n         BZ    SBM12\nSBM24    MVC   MSEIR+8(15),=CL15'INTERNAL READER'\n         OI    SWJBSC,SWJIE        SET ERROR.\nSBM25    CVD   R15,WORK            SET R.C. IN MESSAGE.\n         BAS   R14,EDITW\n         MVC   MSEIR+35(2),WORK+2\n         MVC   MSEIR+61(8),SBMEM\n         LA    R1,MSEIR\n         BAS   R8,SBMR1\n         TM    SWITCH,SWTR\n         BZ    SBM26\n         TM    SWITCH,SWSY\n         BZ    SBM33\nSBM26    TM    SWJBSC,SWJIE        INT. RDR ERROR?\n         BO    SBM30               YES.\n         AIF   ('&SYSPARM' EQ 'NOVSAM').O23S1\n         TM    SWJBSC,SWJIO        OPEN ACB ERROR?\n         BO    SBM34               YES.\n.O23S1   MVI   TEXT,C' '           PURGE JOB.\n         MVC   TEXT+1(L'TEXT-1),TEXT\n         MVC   TEXT(7),=CL7'/*PURGE'    JES2 PURGE.\n         AIF   ('&SYSPARM' NE 'NOVSAM').O23S2\n        $PUNCH TEXT,,TXTDDN\n         AGO   .O23S3\n.O23S2  MODCB  RPL=REQPL,AREA=TEXT\n         LTR   R15,R15\n         BNZ   SBM30\n        PUT    RPL=REQPL\n.O23S3   LTR   R15,R15\n         BZ    SBM29\n         B     SBM30\nSBM27    TM    SWJBSC,SWJL         LIST OF SUBMIT JOB?\n         BZ    SBM28               NO.\n        TPUT   TSEOF,L'TSEOF\n         B     SBM33\nSBM28    MVI   TEXT,C' '           CLOSE JOB.\n         MVC   TEXT+1(L'TEXT-1),TEXT\n         MVC   TEXT(2),INSTXT      NULL JCL.\n         AIF   ('&SYSPARM' NE 'NOVSAM').O24S1\n        $PUNCH TEXT,,TXTDDN\n         AGO   .O24S2\n.O24S1  MODCB  RPL=REQPL,AREA=TEXT\n         LTR   R15,R15\n         BNZ   SBM30\n        PUT    RPL=REQPL\n.O24S2   LTR   R15,R15\n         BNZ   SBM30\nSBM29    MVC   TEXT(7),=CL7'/*EOF  '    JES2 END-OF-FILE.\n         AIF   ('&SYSPARM' NE 'NOVSAM').O24S3\n        $PUNCH TEXT,,TXTDDN\nSBM30   $UCLOSE TXTDDN\n         AGO   .O24S4\n.O24S3  MODCB  RPL=REQPL,AREA=TEXT\n         LTR   R15,R15\n         BNZ   SBM30\n        PUT    RPL=REQPL\n         LTR   R15,R15\n         BNZ   SBM30\n        ENDREQ RPL=REQPL           GET JOB NUMBER.\n         LTR   R15,R15             RECEIVED BACK?\n         BZ    SBM31               YES.\n         MVC   MSEIR+8(15),=CL15'IN.RDR - ENDREQ'\n         CVD   R15,WORK            SET R.C. IN MESSAGE.\n         BAS   R14,EDITW\n         MVC   MSEIR+35(2),WORK+2\n         MVC   MSEIR+61(8),SBMEM\n         LA    R1,MSEIR\n         BAS   R8,SBMR1\n         B     SBM30\nSBM31    MVC   MSJNN+26(8),REQPL+(RPLRBAR-IFGRPL) MOVE JOB NUMBER.\n         LA    R1,MSJNN+29\n         CLI   0(R1),C'0'\n         BNE   *+L'*+12\n         MVI   0(R1),C' '\n         LA    R1,1(R1)\n         B     *-16\n         TM    SWITCH,SWTR\n         BZ    SBM32\n         LH    R0,MSJNN\n         SH    R0,=H'4'\n        TPUT   MSJNN+4,(0)\n         B     SBM30\nSBM32   WTO    MF=(E,MSJNN)\nSBM30   CLOSE  (INRDR)\n.O24S4   ANOP\nSBM33   $RCLOSE SBDDN\nSBM34    NI    SWITCH,255-SWSI\n         L     R1,DASBIN           DE-ALLOCATE SUBMIT INPUT.\n         USING DYNLIST,R1\n         XC    DSNAME,DSNAME\n         DROP  R1\n        $DYNALL (R1),RCODES\n         LTR   R15,R15\n         BZ    RCMD                CONTINUE.\n         LA    R6,SBDDN-(DDTNME-DDTAB)\n         BAS   R8,DAMSG            DE-ALLOCATION ERROR.\n         DC    CL4'FREE'\n         TM    SWITCH,SWTR\n         BZ    TOPERS\n         TM    SWITCH,SWSY\n         BO    TOPERS\n         B     RCMD                CONTINUE.\n         SPACE 1\nSBMR1    TM    SWITCH,SWTR         DISPLAY MESSAGE ROUTINE.\n         BO    SBMR1A\n        WTO    MF=(E,(1))\n         BR    R8\nSBMR1A   LH    R0,0(R1)\n         SH    R0,=H'4'\n         LA    R1,4(R1)\n        TPUT   (1),(0)\n         BR    R8\n         SPACE 1\nMVSBDSN  MVC   SBDSNM(*-*),0(R6)   << EXECUTED >>\nMVSBMBN  MVC   SBMEM(*-*),0(R6)    << EXECUTED >>\nSBMMVUS  MVC   JUSER(*-*),0(R6)    << EXECUTED >>\n         SPACE 1\n        PRINT  NOGEN\nMSEIR   WTO    '--- 123456789012345 ERROR (R15=12) - ONLY SUBMIT FAILS X\n               : 12345678 ---',ROUTCDE=1,DESC=3,MF=L\nMSEJB   WTO    '--- JOB CARD ERROR (C=12,P=12) - ONLY SUBMIT FAILS : 12X\n               345678 ---',ROUTCDE=1,DESC=3,MF=L\nMSEPL   WTO    '--- RACF-ICHEINTY ERROR (RC=12) - ONLY SUBMIT FAILS : 1X\n               2345678 ---',ROUTCDE=1,DESC=3,MF=L\n         AIF   ('&SYSPARM' EQ 'NOVSAM').O30S1\nMSJNN   WTO    '--- EU-S00I 12345678 (12345678) SUBMITTED.',           X\n               ROUTCDE=1,DESC=3,MF=L\n.O30S1  PRINT  GEN\n         SPACE 1\nSCTXT    DC    A(TEXT,1,TEXT+70)\nLGPPW    DC    A(L'GPPW)\n         SPACE 1\nRBBKPTR  DC    0F'0',XL1'80',AL3(RBBK)\nRBBK     DC    0F'0',AL1(RBBKEND-RBBK)\n         DC    AL1(S99VRBAL)\n         DC    AL1(S99NOCNV+S99NOMNT,0)\nRBRSC    DC    F'0'                ERROR/INFO REASON CODES.\n         DC    A(RBTXP)\n         DC    F'0',XL4'0'\nRBBKEND  EQU   *\nRBTXP    DC    A(TXTUN1)\n         DC    A(TXTUN2)\n         DC    A(TXTUN3)\n         DC    A(TXTUN4)\n         DC    A(TXTUN5)\n         DC    XL1'80',AL3(TXTUN6)\nTXTUN1   DC    AL2(DALSYSOU),AL2(1),AL2(1),CL1'A'\nTXTUN2   DC    AL2(DALSPGNM),AL2(1),AL2(6),CL6'INTRDR'\nTXTUN3   DC    AL2(DALCLOSE),AL2(0)\nTXTUN4   DC    AL2(DALLRECL),AL2(1),AL2(2),AL2(80)\nTXTUN5   DC    AL2(DALRECFM),AL2(1),AL2(1),AL1(DCBRECF)\nTXTUN6   DC    AL2(DALRTDDN),AL2(1)\nTXTDDNL  DC    AL2(*-*)\nTXTDDN   DC    CL8' '\n         SPACE 1\nGPSW    ICHEACTN FIELD=PASSWORD,MF=L\nGPWA     DC    A(GPWAL)            WORK AREA LENGTH.\nGPWAR    DC    XL20'0'             RESERVED.\n         DC    F'0'                ACTION RESPONSE LENGTH.\nGPPL     DC    XL2'0'              PASSWORD LENGTH (8).\nGPPW     DC    XL8'0'              PASSWORD.\n         DC    XL2'0'\nGPWAL    EQU   *-GPWA\n         SPACE 1\nSWJBSC   DC    AL1(SWJS)\nSWJB     EQU   X'01'               JOB STATEMENT PROCESSED.\nSWJA     EQU   X'02'               START-STOP TEXT QUOTES.\nSWJN     EQU   X'04'               JOB STATEMENT CONTINUATION.\nSWJU     EQU   X'08'               USER= KEYWORD PROCESSED.\nSWJL     EQU   X'10'               LIST OF SUBMIT JOB.\nSWJIE    EQU   X'20'               INTERNAL READER ERROR.\nSWJS     EQU   X'40'               BYPASS JOB CARD PROCESSING.\n         AIF   ('&SYSPARM' EQ 'NOVSAM').O30S2\nSWJIO    EQU   X'80'               INTERNAL READER OPEN ACB ERROR.\n.O30S2   SPACE 1\n         DC    AL1(L'TEXT)\nTEXT     DC    CL80' '\n         DC    AL1(L'INSTXT+L'INSTXTT+L'INSTXTP)\nINSTXT   DC    CL15'// '\nINSTXTT  DC    CL10'PASSWORD=('\nINSTXTP  DC    CL35'               * SUBMIT SUPPLIED * '\n         AIF   ('&SYSPARM' EQ 'NOVSAM').O30S3\n         DC    CL20' '\n.O30S3   ANOP\nSBDDN    DC    CL8'SYSSBM'\nSBDSNM   DC    CL44' '\nSBMEM    DC    CL8' '\nJUSERL   DC    AL1(*-*)\nJUSER    DC    CL8' '\nCCJB     DC    PL2'+0'\nTSSRQ    DC    C'DO YOU WANT THE LIST? (REPLY Y/N)'\nTSEOF    DC    C'--- SUBMIT : END OF LIST ---'\n         SPACE 1\n        LTORG\n         AIF   ('&SYSPARM' EQ 'NOVSAM').O31S1\n         SPACE 1\n        PRINT  NOGEN\nINRDR   ACB    MACRF=(ADR,SEQ,OUT),DDNAME=XXXXXXXX\nREQPL   RPL    ACB=INRDR,RECLEN=80,AREALEN=80,OPTCD=(ADR,SEQ,SYN,NUP)\n        PRINT  GEN\n.O31S1   SPACE 1\n         DROP  R10\n         SPACE 2\n*        SET/RESET-COMMON PROCESSING.\n*        -----------------------------\n         SPACE 1\n         DS    0H\n         USING CTR,R10             LOCAL BASE REGISTER.\nCTR      TM    SWPRSS,SWTO\n         BO    RCMD\n         OI    SWPRSS,SWTF         SET TRUE.\n         BAS   R10,CTF1\n         DROP  R10\n         USING CFL,R10             LOCAL BASE REGISTER.\nCFL      TM    SWPRSS,SWTO\n         BO    RCMD\n         NI    SWPRSS,255-SWTF     SET FALSE.\nCTF1     L     R8,=A(RSRVAR)\n         BASR  R14,R8\n         CLI   0(R3),C' '          FIND SWITCH NUMBER.\n         BNE   CTF2\n         BXLE  R3,R4,*-8\n         B     SERR\nCTF2     CLI   0(R3),C'('          START OF A RANGE?\n         BE    CTF3                YES.\n         L     R8,=A(CSSC)         ONLY ONE.\n         BASR  R14,R8\n         CLI   0(R3),C' '          SEPARATOR?\n         BNE   SERR                NO.\n         BCTR  R1,0\n         LR    R6,R1\n         LA    R8,1\n         B     CTF8\nCTF3     BXLE  R3,R4,*+L'*+4\n         B     SERR\n         CLI   0(R3),C' '          FIND START NUMBER.\n         BE    CTF3\n         L     R8,=A(CSSC)\n         BASR  R14,R8\n         BCTR  R1,0\n         LR    R6,R1\n         CLI   0(R3),C'-'          SEPARATOR?\n         BE    CTF5                YES.\n         CLI   0(R3),C' '\n         BNE   SERR                NO.\nCTF4     BXLE  R3,R4,*+L'*+4       FIND FINAL NUMBER.\n         B     SERR\n         CLI   0(R3),C'-'          SEPARATOR?\n         BE    CTF5                YES.\n         CLI   0(R3),C' '\n         BE    CTF4                YES.\n         B     SERR\nCTF5     BXLE  R3,R4,*+L'*+4\n         B     SERR\n         CLI   0(R3),C' '\n         BE    CTF5\n         L     R8,=A(CSSC)\n         BASR  R14,R8\nCTF6     CLI   0(R3),C')'          SEPARATOR?\n         BE    CTF7                YES.\n         CLI   0(R3),C' '\n         BNE   SERR                NO.\n         BXLE  R3,R4,CTF6\n         B     SERR\nCTF7     CLR   R1,R6\n         BNH   ISNR\n         LR    R8,R1\n         SR    R8,R6\nCTF8     LR    R14,R6\n         SRDL  R14,3\n         SRL   R15,29\n         LA    R1,BIT0\n         SRL   R1,0(R15)\n         L     R2,=A(COMMSW)\n         ALR   R2,R14\n         TM    SWPRSS,SWTF\n         BZ    *+L'*+8\n         EX    R1,CTTRUE           SET SWITCH TRUE.\n         B     *+L'*+10\n         LA    R0,X'FF'\n         XR    R1,R0\n         EX    R1,CTFLSE           SET SWITCH FALSE.\n         BCT   R8,CTF9\n         BXLE  R3,R4,*+L'*+4\n         B     PRCSS\n         CLI   0(R3),C' '\n         BE    *-12\n         B     CTF2                GO GET NEXT SWITCH NUMBER(S).\nCTF9     AH    R6,=H'1'            STEP TO NEXT SWITCH.\n         B     CTF8\nCTTRUE   OI    0(R2),*-*           << EXECUTED >>\nCTFLSE   NI    0(R2),*-*           << EXECUTED >>\n         SPACE 1\n        LTORG\n         SPACE 1\n         DROP  R10\n         SPACE 2\n*        IF-COMMON-TRUE/FALSE PROCESSING.\n*        --------------------------------\n         SPACE 1\n         DS    0H\n         USING IFCTR,R10           LOCAL BASE REGISTER.\nIFCTR    TM    SWPRSS,SWTO\n         BO    RCMD\n         OI    SWPRSS,SWTF         SET TRUE.\n         BAS   R10,IFC1\n         DROP  R10\n         USING IFCFL,R10           LOCAL BASE REGISTER.\nIFCFL    TM    SWPRSS,SWTO\n         BO    RCMD\n         NI    SWPRSS,255-SWTF     SET FALSE.\nIFC1     L     R8,=A(RSRVAR)\n         BASR  R14,R8\n         CLI   0(R3),C' '          FIND SWITCH NUMBER.\n         BNE   *+L'*+8\n         BXLE  R3,R4,*-8\n         B     SERR\n         L     R8,=A(CSSC)\n         BASR  R14,R8\n         CLI   0(R3),C' '          SEPARATOR?\n         BNE   SERR                NO.\n         LR    R14,R1\n         BXLE  R3,R4,*+L'*+4       FIND LABEL.\n         B     SERR\n         CLI   0(R3),C' '\n         BE    *-12\n         LR    R6,R3\n         LA    R0,L'LABEL\nIFC2     BXLE  R3,R4,*+L'*+4\n         B     *+L'*+16\n         CLI   0(R3),C' '\n         BE    *+L'*+8\n         BCT   R0,IFC2\n         B     SERR\n         LA    R1,L'LABEL\n         SR    R1,R0\n         EX    R1,MVLAB\n         STC   R1,LABELL\n         BCTR  R14,0\n         SRDL  R14,3\n         SRL   R15,29\n         LA    R1,BIT0\n         SRL   R1,0(R15)\n         L     R2,=A(COMMSW)\n         ALR   R2,R14\n         TM    SWPRSS,SWTF         EXECUTE IF.\n         BZ    *+L'*+12\n         EX    R1,IFCTM            IS SWITCH TRUE?\n         BO    SKIPTO              YES.\n         B     NOSKIP\n         EX    R1,IFCTM            IS SWITCH FALSE?\n         BZ    SKIPTO              YES.\n         B     NOSKIP\nIFCTM    TM    0(R2),*-*           << EXECUTED >>\n         SPACE 1\n        LTORG\n         SPACE 1\n         DROP  R10\n         SPACE 2\n*        LOAD/SAVE-COMMON PROCESSING.\n*        ----------------------------\n         SPACE 1\n         DS    0H\n         USING LCM,R10             LOCAL BASE REGISTER.\nLCM      TM    SWPRSS,SWTO\n         BO    RCMD\n         MVI   SWCOMM,SWCOLD       SET LOAD.\n         BAS   R10,LSC1\n         DROP  R10\n         USING SCM,R10             LOCAL BASE REGISTER.\nSCM      TM    SWPRSS,SWTO\n         BO    RCMD\n         MVI   SWCOMM,0            SET SAVE.\nLSC1     L     R8,=A(RSRVAR)\n         BASR  R14,R8\n         CLI   0(R3),C' '          FIND PO-DSNAME.\n         BNE   *+L'*+8\n         BXLE  R3,R4,*-8\n         B     SERR\n         LR    R6,R3\n         LA    R0,L'CODSNM\n         MVI   CODSNM,C' '\n         MVC   CODSNM+1(L'CODSNM-1),CODSNM\n         BXLE  R3,R4,*+L'*+4\n         B     *+L'*+16\n         CLI   0(R3),C' '\n         BE    *+L'*+8\n         BCT   R0,*-16\n         B     SERR\n         LA    R1,L'CODSNM\n         SR    R1,R0\n         EX    R1,MVCODSN\n         BXLE  R3,R4,*+L'*+4       FIND MEMBER NAME.\n         B     SERR\n         CLI   0(R3),C' '\n         BE    *-12\n         LR    R6,R3\n         LA    R0,L'COMBRN\n         MVC   COMBRN,=CL8' '\n         BXLE  R3,R4,*+L'*+4\n         B     *+L'*+16\n         CLI   0(R3),C' '\n         BE    *+L'*+8\n         BCT   R0,*-16\n         B     SERR\n         LA    R1,L'COMBRN\n         SR    R1,R0\n         EX    R1,MVCOMBN\n         TM    SWITCH,SWTR\n         BZ    LSC2\n         TM    SWITCH,SWLS\n         BZ    LSC2\n        TPUT   CARD,L'CARD-8\nLSC2     L     R6,DACOMM\n         BAS   R8,LSCR1\n         USING DYNLIST,R6\n         MVC   DDNAME,CODDNM\n         MVC   DSNAME,CODSNM\n         MVC   DSSTATUS(3),=CL3'SHR'\n         MVC   DSNDISP(4),=CL4'KEEP'\n         MVC   DSADISP(4),=CL4'KEEP'\n         XC    DSORG,DSORG\n         BAS   R8,LSCR2            ALLOCATE DATA-SET.\n         LTR   R15,R15\n         BZ    LSC5\nLSC3     LA    R6,CODDNM-(DDTNME-DDTAB)\n         BAS   R8,DAMSG            ALLOCATION ERROR.\n         DC    CL4'ALL.'\nLSC4     TM    SWITCH,SWTR\n         BZ    TOPERS\n         TM    SWITCH,SWSY\n         BO    TOPERS\n         B     RCMD                CONTINUE PROCESSING.\nLSC5     CLC   DSORG(2),=CL2'PO'   PARTITIONED DATA-SET?\n         BE    LSC9                YES.\n         L     R1,=A(MSCPO)\n         MVC   MSCER+4(65),0(R1)\n         B     LSC7\nLSC6     MVC   MSCER+23(1),COMMDS\nLSC7     BAS   R8,LSCR3            DISPLAY MESSAGE.\n         XC    DSNAME,DSNAME       DE-ALLOCATE DD-NAME.\n         BAS   R8,LSCR2\n         LTR   R15,R15\n         BZ    LSC4\nLSC8     LA    R6,CODDNM-(DDTNME-DDTAB)\n         BAS   R8,DAMSG            DE-ALLOCATION ERROR.\n         DC    CL4'FREE'\n         B     LSC4\nLSC9     MVI   COMMDS,C'1'         SAY DATA-SET (1).\n        OPEN   (COMMPO,INPUT)      OPEN DATA-SET.\n         L     R1,=A(COMMPO)\n         USING IHADCB,R1\n         TM    DCBOFLGS,DCBOFOPN   OPEN OK?\n         BZ    LSC20               NO.\n         TM    SWCOMM,SWCORF       RECFM ERROR?\n         BO    LSC23               YES.\n         TM    SWCOMM,SWCOLR       LRECL ERROR?\n         BO    LSC24               YES.\n         MVC   COMMBM,COMBRN       SET BLDL PARM LIST.\n         XC    COMMBM+L'COMMBM(L'COMMDT),COMMBM+L'COMMBM\n        BLDL   (1),COMMBL\n         DROP  R1\n         LTR   R15,R15             COMPLETION CODE?\n         BZ    LSC13               OK.\n         CH    R15,=H'4'           MEMBER NOT FOUND?\n         BE    LSC10               YES.\n         L     R1,=A(MSCSR)\n         MVC   MSCER+4(65),0(R1)\n         STC   R15,MSCER+38\n         SRL   R15,4\n         STC   R15,MSCER+37\n         NC    MSCER+37(2),=XL3'0F0F0F'\n         TR    MSCER+37(2),TRTAB\n         STC   R0,MSCER+41\n         SRL   R15,4\n         STC   R15,MSCER+40\n         NC    MSCER+40(2),=XL3'0F0F0F'\n         TR    MSCER+40(2),TRTAB\n         BAS   R8,LSCR4            CLOSE DATA-SET.\n         B     LSC7\nLSC10    TM    SWCOMM,SWCOLD       WAS LOAD REQUESTED?\n         BZ    LSC14               NO, IT WAS SAVE.\n         BAS   R8,LSCR4            CLOSE DATA-SET.\n         L     R1,=A(MSCNF)\nLSC11    MVC   MSCER+4(65),0(R1)\n         MVC   MSCER+20(L'COMBRN),COMBRN\n         BAS   R8,LSCR3            DISPLAY MESSAGE.\nLSC12    XC    DSNAME,DSNAME       DE-ALLOCATE DD-NAME.\n         BAS   R8,LSCR2\n         LTR   R15,R15\n         BZ    RCMD                CONTINUE PROCESSING.\n         B     LSC4\nLSC13    TM    SWCOMM,SWCOLD       WAS LOAD REQUESTED?\n         BO    LSC14               YES.\n         CLC   COMMDT+20(4),=AL2(1,1)   NO, SAVE, MY ISPF SIZE-INIT?\n         BNE   *+L'*+8             NO.\n         OI    SWCOMM,SWCOIN       YES, UPDATE IN PLACE.\n         B     LSC14\n         OI    SWCOMM,SWCOFS       FORCE RE-WRITE.\nLSC14    BAS   R8,LSCR4            CLOSE DATA-SET.\n         XC    DSNAME,DSNAME       DE-ALLOCATE DD-NAME.\n         BAS   R8,LSCR2\n         LTR   R15,R15\n         BNZ   LSC8\n         BAS   R8,LSCR1\n         MVC   DDNAME,CODDNM\n         MVC   DSNAME,CODSNM\n         TM    SWCOMM,SWCOLD+SWCOIN     FIRST SAVE OR RE-WRITE?\n         BZ    *+L'*+6             YES, WILL BE DONE BY STOW.\n         MVC   DSMEMBER,COMBRN     SET MEMBER NAME.\n         MVC   DSNDISP(4),=CL4'KEEP'\n         MVC   DSADISP(4),=CL4'KEEP'\n         MVI   COMMDS,C'2'         SAY DATA-SET (2).\n         NI    SWCOMM,SWCOLD+SWCOIN+SWCOFS   RESET ALL UNLESS ...\n         TM    SWCOMM,SWCOLD       WAS LOAD REQUESTED?\n         BZ    *+L'*+10            NO, SAVE\n         MVC   DSSTATUS(3),=CL3'SHR'    YES, SET TO SHR.\n         B     LSC15\n         TM    SWCOMM,SWCOIN       UPDATE IN PLACE?\n         BNZ   *+L'*+10            YES.\n         MVC   DSSTATUS(3),=CL3'MOD'    NO, CHANGE TO MOD.\n         B     LSC15\n         MVC   DSSTATUS(3),=CL3'OLD'    CHANGE TO OLD.\nLSC15    BAS   R8,LSCR2            ALLOCATE DATA-SET.\n         LTR   R15,R15\n         BZ    LSC16\n         TM    SWCOMM,SWCOLD       WAS LOAD REQUESTED?\n         BO    LSC3                YES.\n         LA    R1,CODSNM\n         L     R8,=A(ACTRQ)\n         BASR  R14,R8              REQUEST ACTION.\n         B     *+L'*(R15)\n         B     LSC15               0 - RETRY (RECOVERED).\n         B     *+L'*+4             4 - SKIP (IGNORE).\n         B     LSC3                8 - CANCEL.\n         LA    R6,CODDNM-(DDTNME-DDTAB)\n         BAS   R8,DAMSG            ALLOCATION ERROR.\n         DC    CL4'ALL.'\n         B     RCMD                CONTINUE PROCESSING.\nLSC16    TM    SWCOMM,SWCOLD       WAS LOAD REQUESTED?\n         BO    LSC18               YES.\n         TM    SWCOMM,SWCOIN       UPDATE IN PLACE?\n         BO    LSC17               YES.\n        OPEN   (COMMPO,OUTPUT)     OPEN DATA-SET.\n         L     R5,=A(COMMPO)\n         B     LSC19+L'LSC19\nLSC17   OPEN   (COMMPS,UPDAT)      OPEN DATA-SET.\n         B     LSC19\nLSC18   OPEN   (COMMPS,INPUT)      OPEN DATA-SET.\nLSC19    L     R5,=A(COMMPS)\n         USING IHADCB,R5\n         TM    DCBOFLGS,DCBOFOPN   OPEN OK?\n         BO    LSC25               YES.\nLSC20    ICM   R2,B'1111',=CL4'OPEN'\n         TM    SWCOMM,SWCOAB       ABEND HAS OCCURED?\n         BO    LSC22               YES.\nLSC21    L     R1,=A(MSCOE)\n         MVC   MSCER+4(65),0(R1)\n         STCM  R2,B'1111',MSCER+28\n         B     LSC6\nLSC22    BAS   R8,LSCR5\n         B     LSC6\nLSC23    L     R1,=A(MSCRF)\n         B     LSC24+L'LSC24\nLSC24    L     R1,=A(MSCLR)\n         MVC   MSCER+4(65),0(R1)\n         BAS   R8,LSCR4            CLOSE DATA-SET.\n         B     LSC6\nLSC25    TM    SWCOMM,SWCORF       RECFM ERROR?\n         BO    LSC23               YES.\n         TM    SWCOMM,SWCOLR       LRECL ERROR?\n         BO    LSC24               YES.\n         LH    R1,LSCBLK           GET READ/WRITE AREA.\n         LA    R0,7(R1)\n         SRL   R0,3\n         SLL   R0,3\n         ST    R0,COMMBUF\n        GETMAIN R,LV=(0)\n         ST    R1,COMMBUF+4\n         LR    R2,R1\n         TM    SWCOMM,SWCOLD       WAS LOAD REQUESTED?\n         BO    *+L'*+8             YES.\n         TM    SWCOMM,SWCOIN       NO, SAVE, BUT UPDATE IN PLACE?\n         BZ    LSC26               NO.\n         MVC   DCBBLKSI(L'DCBBLKSI),LSCLRL\n        READ   COMMDECB,SF,(R5),(R2),80,MF=E\n        CHECK  COMMDECB\n         TM    SWCOMM,SWCOER+SWCOAB     ERROR OR ABEND HAS OCCURED?\n         BNZ   LSCEND              YES.\n         CLC   51(6,R2),=CL6'COMMSW'\n         BE    *+L'*+8\n         OI    SWCOMM,SWCONV       SAY INVALID ERROR, IGNORE.\n         B     LSCEND\n         TM    SWCOMM,SWCOIN       UPDATE IN PLACE?\n         BO    LSC26               YES.\n         L     R1,=A(COMMSW)       NO, LOAD COMMON-SWITCHES.\n         MVC   0(L'COMMSW,R1),0(R2)\n         B     LSCEND\nLSC26    L     R1,=A(COMMSW)       SAVE COMMON-SWITCHES.\n         MVC   0(L'COMMSW,R2),0(R1)\n         MVI   50(R2),C' '\n         MVC   51(6,R2),=CL6'COMMSW'\n         MVI   57(R2),C' '\n         TM    SWITCH,SWTR\n         BO    *+L'*+6\n         L     R8,=A(UPDT)\n         BASR  R14,R8\n         MVC   58(L'FTIME,R2),FTIME\n         MVI   58+L'FTIME(R2),C' '\n         MVC   59+L'FTIME(L'SDATE,R2),SDATE\n         MVI   59+L'FTIME+L'SDATE(R2),C' '\n         MVC   72(8,R2),=CL8'00010000'\n         MVC   DCBBLKSI(L'DCBBLKSI),LSCLRL\n        WRITE  COMMDECB,SF,(R5),(R2),80,MF=E\n        CHECK  COMMDECB\n         TM    SWCOMM,SWCOIN       UPDATE IN PLACE?\n         BO    LSCEND              YES.\n         MVC   COMMSTL(L'COMBRN),COMBRN NO, ADD OR REPLACE MEMBER NAME.\n         PACK  COMMSTL1,JDATE\n         MVC   COMMSTL2,COMMSTL1\n         PACK  WORK(L'COMMSTL3+1),FTIME(L'THRS+L'TMNS+1)\n         MVC   COMMSTL3(L'COMMSTL3),WORK\n         L     R1,ATIOT            GET TIOT ADDRESS.\n         USING TIODSECT,R1\n         MVC   COMMSTL4,TIOCNJOB   SET TASK NAME.\n         DROP  R1\n         TM    SWCOMM,SWCOFS       FORCE RE-WRITE?\n         BO    LSC27               YES.\n        STOW   (R5),COMMSTL,A      NO, ADD.\n         B     LSC28\nLSC27   STOW   (R5),COMMSTL,R      REPLACE.\nLSC28    LTR   R15,R15\n         BZ    LSCEND\n         L     R1,=A(MSCST)\n         MVC   MSCER+4(65),0(R1)\n         MVC   MSCER+20(L'COMBRN),COMBRN\n         STC   R15,MSCER+43\n         SRL   R15,4\n         STC   R15,MSCER+42\n         NC    MSCER+42(2),=XL3'0F0F0F'\n         TR    MSCER+42(2),TRTAB\n         STC   R0,MSCER+46\n         SRL   R0,4\n         STC   R0,MSCER+45\n         NC    MSCER+45(2),=XL3'0F0F0F'\n         TR    MSCER+45(2),TRTAB\n         BAS   R8,LSCR3            DISPLAY MESSAGE.\n         B     LSCEND\n         DROP  R5\n         SPACE 1\n        CNOP   0,4\n*        DCB EXIT ROUTINE          R2 -> R13 = AS OPEN ISSUED.\n         USING IHADCB,R1\nLSCEXT   MVC   LSCBLK,DCBBLKSI     GET RECORD SIZE.\n         TM    DCBRECFM,DCBRECF    FIXED RECORDS?\n         BZ    *+L'*+8\n         TM    DCBRECFM,DCBRECV\n         BZ    *+L'*+6\n         OI    SWCOMM,SWCORF       SAY RECFM ERROR.\n         BR    R14                 RETURN.\n         CLC   DCBLRECL,LSCLRL     RECORD LENGTH?\n         BER   R14                 OK, RETURN.\n         OI    SWCOMM,SWCOLR       SAY LRECL ERROR.\n         BR    R14                 RETURN.\n         DROP  R1\nLSCLRL   DC    H'80'               REQUESTED LRECL.\nLSCBLK   DC    H'0'                DATA-SET BLOCK-SIZE.\nLSCXLS   DC    0F'0',XL1'05',AL3(LSCEXT)\n         DC    XL1'91',AL3(LSCXAB)\n        CNOP   0,4\n*        SYNAD EXIT ROUTINE        R2 -> R13 = AS READ/WRITE ISSUED.\nLSCERR   STM   R13,R1,COMMSV\n        SYNADAF ACSMETH=BSAM\n         MVC   COMMWTX(L'COMMWTX),50(R1)     GET MESSAGE TEXT.\n        SYNADRLS\n         OI    SWCOMM,SWCOER       SAY I/O ERROR OCCURED.\n         LM    R13,R1,COMMSV\n         BR    R14                 RETURN.\n        CNOP   0,4\n*        DCB ABEND ROUTINE         R2 -> R13 = AS OPEN ... ISSUED.\nLSCXAB   TM    3(R1),B'00000100'   OPTION MASK = OK TO IGNORE?\n         BO    *+L'*+6             YES.\n         NI    3(R1),B'11110001'   NO, IMMMEDIATE ABEND.\n         BR    R14                 RETURN.\n         MVC   COCCRC(3),0(R1)     SAVE ABEND CODES.\n         OI    SWCOMM,SWCOAB       SAY ABEND.\n         NI    3(R1),B'11110101'   OK TO IGNORE ONLY.\n         BR    R14                 RETURN.\n         SPACE 1\n        CNOP   0,4\n*        EODAD EXIT\n         USING IHADCB,R5\nLSCEND   MVC   DCBBLKSI(L'DCBBLKSI),LSCBLK\n         DROP  R5\n         BAS   R8,LSCR4            CLOSE DATA-SET.\n         LM    R0,R1,COMMBUF       FREE READ/WRITE AREA.\n         LTR   R1,R1\n         BNP   LSCE1\n        FREEMAIN R,A=(1),LV=(0)\n         XC    COMMBUF(2*4),COMMBUF\nLSCE1    TM    SWCOMM,SWCOER+SWCOAB+SWCONV   ANY ERROR HAS OCCURED?\n         BZ    LSC12               NO.\n         TM    SWCOMM,SWCONV       YES, WAS INVALID ERROR?\n         BO    LSCE3               YES.\n         TM    SWCOMM,SWCOLD       NO, WAS LOAD REQUESTED?\n         BZ    *+L'*+8             NO, SAVE.\n         ICM   R2,B'1111',=CL4'LOAD'\n         B     *+L'*+4\n         ICM   R2,B'1111',=CL4'SAVE'\n         TM    SWCOMM,SWCOAB       ABEND HAS OCCURED?\n         BO    LSC22               YES.\n         TM    SWITCH,SWTR         DISPLAY SYNAD MESSAGE.\n         BO    LSCE2\n         MVC   COMMWER+2(2),MSCER+2\n         MVC   COMMWDR(L'COMMWDR),MSCER+69\n        WTO    MF=(E,COMMWER)\n         B     LSC21\nLSCE2   TPUT   COMMWTX,L'COMMWTX\n         B     LSC21\nLSCE3    L     R1,=A(MSCNV)\n         B     LSC11\n         SPACE 1\nLSCR1    LR    R2,R6               DYNAMIC ALLOCATION AREA ROUTINE.\n         L     R3,=A(DYNLGTH)\n         LA    R4,*\n         XR    R5,R5\n         ICM   R5,B'1000',=CL8' '\n         MVCL  R2,R4\n         BR    R8\nLSCR2   $DYNALL (R6),RCODES        DYNAMIC ALLOCATION ROUTINE.\n         BR    R8\nLSCR3    TM    SWITCH,SWTR         DISPLAY MESSAGE ROUTINE.\n         BO    LSCR3A\n        WTO    MF=(E,MSCER)\n         BR    R8\nLSCR3A   LH    R0,MSCER\n         SH    R0,=H'4'\n        TPUT   MSCER+4,(0)\n         BR    R8\nLSCR4    CLI   COMMDS,C'1'         CLOSE DATA-SET ROUTINE.\n         BNE   LSCR4A\n        CLOSE  (COMMPO)            DATA-SET (1).\n         BR    R8\nLSCR4A  CLOSE  ((R5))              DATA-SET (2).\n         BR    R8\nLSCR5    L     R1,=A(MSCAB)        SET ABEND MESSAGE ROUTINE.\n         MVC   MSCER+4(65),0(R1)\n         STCM  R2,B'1111',MSCER+28\n         UNPK  MSCER+41(3),COCCRC(2)\n         NC    MSCER+41(3),=XL3'0F0F0F'\n         TR    MSCER+41(3),TRTAB\n         UNPK  MSCER+45(3),COCCRC+2(2)\n         NC    MSCER+45(2),=XL3'0F0F0F'\n         TR    MSCER+45(2),TRTAB\n         MVI   MSCER+47,C'.'\n         BR    R8\n         DROP  R6\n         SPACE 1\nMVCODSN  MVC   CODSNM(*-*),0(R6)   << EXECUTED >>\nMVCOMBN  MVC   COMBRN(*-*),0(R6)   << EXECUTED >>\n         SPACE 1\nCOMMBUF  DC    A(0,*-*)\nCOMMSV   DC    5F'0'               SYNAD SAVE AREA (R13-R1).\nCOCCRC   DC    F'0'                SAVE ABEND CODES.\nCODDNM   DC    CL8'SYSCOMM'\nCODSNM   DC    CL44' '\nCOMBRN   DC    CL8' '\nCOMMWER  DC    0F'0',AL2(L'COMMWER+L'COMMWTX),H'0'\nCOMMWTX  DC    CL78' '\nCOMMWDR  DC    XL4'0'\nCOMMDS   DC    CL1'0'\nSWCOMM   DC    XL1'0'\nSWCOLD   EQU   X'01'               LOAD-COMMON FUNCTION.\nSWCOIN   EQU   X'02'               UPDATE IN PLACE.\nSWCOFS   EQU   X'04'               FORCE SAVE RE-WRITE.\nSWCONV   EQU   X'08'               INVALID ERROR.\nSWCORF   EQU   X'10'               RECFM ERROR.\nSWCOLR   EQU   X'20'               LRECL ERROR.\nSWCOER   EQU   X'40'               I/O ERROR (SYNAD ENTERED).\nSWCOAB   EQU   X'80'               DCB ABEND ENTERED.\n         SPACE 1\n        LTORG\n         SPACE 2\n*        COMMON CONTROL BLOCKS.\n*        ----------------------\n         SPACE 1\nMSCER   WTO    '1234567890123456789012345678901234567890123456789012345X\n               6789012345',ROUTCDE=1,DESC=3,MF=L\n         SPACE 1\nCOMMBL   DC    0F'0',AL2(1,L'COMMBM+L'COMMDT)\nCOMMBM   DC    CL8' '\nCOMMDT   DC    XL72'0'\n         SPACE 1\nCOMMSTL  DC    0F'0',CL8' '        STOW LIST, MEMBER NAME.\n         DC    XL3'0',XL1'0F'      TTR, C-BYTE.\n         DC    AL1(1,0),H'0'       ISPF VERSION.\nCOMMSTL1 DC    PL4'0'              ISPF DATE CREATED.\nCOMMSTL2 DC    PL4'0'              ISPF DATE LAST MOD.\nCOMMSTL3 DC    H'0'                ISPF TIME LAST MOD.\n         DC    AL2(1,1,0)          ISPF SIZE, INIT, MOD.\nCOMMSTL4 DC    CL8' ',CL2' '       ISPF ID.\n         SPACE 1\n        READ   COMMDECB,SF,,,80,MF=L\n         SPACE 1\n         DROP  R10\n         SPACE 2\n        PRINT  NOGEN\nCOMMPO  DCB    DDNAME=SYSCOMM,DSORG=PO,MACRF=(R,W),EXLST=LSCXLS,       X\n               SYNAD=LSCERR\nCOMMPS  DCB    DDNAME=SYSCOMM,DSORG=PS,MACRF=(R,W),EXLST=LSCXLS,       X\n               SYNAD=LSCERR,EODAD=LSCEND\n        PRINT  GEN\n         SPACE 1\n*        COMMON MESSAGES TEXTS.\n*        ----------------------\n         SPACE 1\nMSCPO    DC    CL65'COMMON : NOT A PARTITIONED DATA-SET.'\nMSCSR    DC    CL65'COMMON : DATA-SET SEARCH ERROR : 01/01.'\nMSCNF    DC    CL65'COMMON : MEMBER 01234567 NOT FOUND / IGNORED.'\nMSCOE    DC    CL65'COMMON : DATA-SET (0) - 0123 ERROR.'\nMSCRF    DC    CL65'COMMON : DATA-SET (0) - DCBRECFM INVALID.'\nMSCLR    DC    CL65'COMMON : DATA-SET (0) - DCBLRECL NOT 80.'\nMSCAB    DC    CL65'COMMON : DATA-SET (0) - 0123 ABEND : 012/01.'\nMSCNV    DC    CL65'COMMON : MEMBER 01234567 INVALID / IGNORED.'\nMSCST    DC    CL65'COMMON : MEMBER 01234567 STOW ERROR : 01/01.'\n         EJECT\n         DROP  R11,R12             KILL BASE REGISTERS ADDRESSABILITY.\n         SPACE 2\n*        DUMMY DCB (TO GET FIRST PO-DSNAME).\n*        -----------------------------------\n         SPACE 1\n        PRINT  NOGEN\nDUMMY   DCB    DSORG=PO,DEVD=DA,MACRF=R,EXLST=JOBFILE,DDNAME=XXXXXXNN\n        PRINT  GEN\nJOBFILE  DC    0F'0',XL1'87',AL3(JFILE)\nJFILE    DC    0F'0',XL176'0'\n         SPACE 2\n*        COMMON-SWITCHES AREA.\n*        ---------------------\n         SPACE 1\nCOMMSW   DC    XL50'0'\n         EJECT\n*        SYNTAX KEYWORDS TABLE.\n*        ----------------------\n*\n*        FORMAT :     DC AL1(...L'KEYWORD-1...)\n*                     DC C'...KEYWORD...'\n*                     DC AL4(...KEYWORD PROCESS ADDRESS...)\n         SPACE 1\n         PRINT NOGEN\nCDTBL    $KW   PAUSE,PAUSE,@P\n         $KW   MESSAGE,MESSAGE,@M\n         $KW   NULL,NULL,(:,N)\n         $KW   GOTO,GOTO,GO\n         $KW   IFRP,IF-REPLY,IF-R\n         $KW   IFRB,IF-REPLY-BIN,IF-B\n         $KW   IFRC,IF-REPLY-CHAR,IF-C\n         $KW   IFRH,IF-REPLY-HEX,IF-H\n         $KW   VERB,VER-BIN,V-B\n         $KW   VERH,VER-HEX,V-H\n         $KW   SETR,SET-REPLY\n         $KW   SETR,SET-VAR,SET\n         $KW   IF,IF\n         $KW   IFV,IF-VAR,IF-V\n         $KW   EXECUTE,EXECUTE,@E\n         $KW   SBMT,SUBMIT,SUB\n         $KW   LOGICAL,LOGICAL,@L\n         $KW   TRUE,TRUE,@T\n         $KW   FALSE,FALSE,@F\n         $KW   IFTRUE,IF-TRUE,IF-T\n         $KW   IFFALSE,IF-FALSE,IF-F\n         $KW   GDTE,GDATE,@G\n         $KW   LCM,LOAD-COMMON,@CL\n         $KW   SCM,SAVE-COMMON,@CS\n         $KW   CTR,SET-COMMON,@CT\n         $KW   CFL,RESET-COMMON,@CF\n         $KW   IFCTR,IF-COMMON-TRUE,@CIT\n         $KW   IFCFL,IF-COMMON-FALSE,@CIF\n         $KW   TW,T-WAIT,@W\n         $KW   IFID,IF-REPLY-ID,IF-ID\n         PRINT GEN\n         SPACE 1\n         DC    AL1(EOT)            END OF TABLE INDICATOR.\n         EJECT\n*        OPERATORS KEYWORDS TABLE.\n*        -------------------------\n*\n*        FORMAT :     DC CL2'...KEYWORD...',CL2'...ALIAS...'\n*                     BRANCH REGISTER OPERATION TO GENERATE THE\n*                        REQUESTED CONDITION TEST MASK.\n         SPACE 1\n         NOPR  R0                  FORCE HALFWORD ALIGNMENT.\nOPTBL    DS    0CL6\n         DC    CL2'EQ',CL2'= '\n         BER   R0\n         DC    CL2'NE',CL2'/ '\n         BNER  R0\n         DC    CL2'LT',CL2'< '\n         BLR   R0\n         DC    CL2'GT',CL2'> '\n         BHR   R0\n         DC    CL2'LE',CL2'<='\n         BNHR  R0\n         DC    CL2'GE',CL2'>='\n         BNLR  R0\n         SPACE 1\n         DC    AL1(EOT)            END OF TABLE INDICATOR.\n         SPACE 2\n*        DAY-MONTH NAMES TABLES.\n*        -----------------------\n         SPACE 1\nTDAY     DC    CL3'SUN',C'MONTUEWEDTHUFRISAT',XL1'0'\nTMONTH   DC    CL3'JAN',C'FEBMARAPRMAYJUNJULAUGSEPOCTNOVDEC',XL1'0'\n         EJECT\n*        FIXED VARIABLES NAMES TABLE.\n*        ----------------------------\n*\n*        FORMAT :     DC CL8'...'       +0   NAME (MAX. 7 CHAR.)\n*                     DC AL1(...)       +8   NAME LENGTH\n*                     DC CL1'...'       +9   CLEAR BYTE\n*                     DC AL1(...)       +10  FIELD LENGTH\n*                     DC AL3(...)       +11  FIELD ADDRESS\n         SPACE 1\nFVTBL    DS    0CL14\n         DC    CL8'SID',AL1(3),XL1'0',AL1(L'SID),AL3(SID)\n         DC    CL8'CPU',AL1(3),XL1'0',AL1(L'CPU),AL3(CPU)\n         DC    CL8'RPID',AL1(4),XL1'0',AL1(L'RPID),AL3(RPID)\n         DC    CL8'SDATE',AL1(5),CL1' ',AL1(L'SDATE),AL3(SDATE)\n         DC    CL8'JDATE',AL1(5),CL1' ',AL1(L'JDATE),AL3(JDATE)\n         DC    CL8'DAY',AL1(3),CL1' ',AL1(L'DAY),AL3(DAY)\n         DC    CL8'MONTH',AL1(5),CL1' ',AL1(L'MONTH),AL3(MONTH)\n         DC    CL8'TIME',AL1(4),CL1' ',AL1(L'THRS+L'TMNS),AL3(FTIME)\n         DC    CL8'HOURS',AL1(5),CL1' ',AL1(L'THRS),AL3(THRS)\n         DC    CL8'MINS',AL1(4),CL1' ',AL1(L'TMNS),AL3(TMNS)\n         DC    CL8'YEAR',AL1(4),CL1' ',AL1(2),AL3(SDATE)\n         DC    CL8'SMONTH',AL1(6),CL1' ',AL1(2),AL3(SDATE+2)\n         DC    CL8'SDAY',AL1(4),CL1' ',AL1(2),AL3(SDATE+4)\n         DC    CL8'JDAY',AL1(4),CL1' ',AL1(3),AL3(JDATE+2)\n         DC    AL1(EOT)            END OF TABLE INDICATOR.\n         EJECT\n        PRINT  NOGEN\nPARMLST IKJPARM\nPODSN   IKJPOSIT DSNAME,PROMPT='PO-DSNAME'\nPOMEM   IKJIDENT 'MEMBER-NAME',MAXLNTH=8,FIRST=ALPHA,OTHER=ALPHANUM\nOPLIST  IKJKEYWD\n        IKJNAME  'SYSTEM',ALIAS=('S')\n        IKJNAME  'TEST',ALIAS=('T')\n        IKJENDP\n         SPACE 2\n*        DSECT DEFINITIONS.\n*        ------------------\n         SPACE 1\nCIBDSECT DSECT\nCIB     IEZCIB\n        IKJPSCB\n        IKJCPPL\n        IKJEBECA\n        CVT    DSECT=YES,LIST=YES\n        IEESMCA\n        IEZMGCR\nTIODSECT DSECT\n        IEFTIOT1\n        IEFZB4D0\n        IEFZB4D2\n        DCBD   DSORG=PO,DEVD=DA\n         AIF   ('&SYSPARM' EQ 'NOVSAM').O90S1\n        IFGACB\n        IFGRPL\n.O90S1   SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "AUTOCI$": {"ttr": 4101, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x943O\\x00\\x943O\\x10 \\x00!\\x00!\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-30T00:00:00", "modifydate": "1994-11-30T10:20:00", "lines": 33, "newlines": 33, "modlines": 0, "user": "SYSPAJA"}, "text": "//AUTOCI   JOB (........),'INSTALL - A U T O -',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=1M,TIME=1\n/*JOBPARM L=8\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//* PRE-REQUISITE MODULES INSTALLATION :                              *\n//*                AUTHCTL   DYNALL    GFDATE    MREAD     SRCHRPI    *\n//*                TXREAD                                             *\n//* NOTES : 1. SPECIFY SYSPARM(NOVSAM) AT ASSEMBLY STEP 'ASA' IF      *\n//*            YOU WANT A NON-VSAM VERSION (SUBMIT).                  *\n//*                 I.E. : OPT=',SYSPARM(NOVSAM)'                     *\n//*         2. FOR NON-VSAM VERSION (SUBMIT) :                        *\n//*            A. TXPUNCH IS A PRE-REQUISITE.                         *\n//*            B. CHANGE THE FIRST INCLUDE CARD AT STEP 'LNK' AS      *\n//*               FOLLOWS :                                           *\n//*                 INCLUDE SYSADD(DYNALL,GFDATE,MREAD,PUNCH)         *\n//* TEST EXAMPLE : WHEN INSTALLED, YOU MAY TRY IT JUST TO SEE HOW     *\n//* -------------- IT RUNS BY ENTERING THE FOLLOWING COMMAND AT YOUR  *\n//*                TSO TERMINAL :                                     *\n//*                  AUTOCI  '->.SOURCE.FILE1'  AUTOTS                *\n//*                ASSUMING OBVIOUSLY THAT THE '->.TARGET.LINKLIB' IS *\n//*                AVAILABLE AS TSO COMMAND LIBRARY, OTHERWISE USE    *\n//*                THE ALLOC/CALL/FREE COMMANDS (SEE DOCUMENTATION).  *\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//ASA     EXEC PAJ1AS3,MBR=AUTOCI\n//ASP     EXEC PAJIAS2,OPT=',SYSPARM(CALL)',MBR=PSWREST\n//LNK     EXEC PAJILKL\n//SYSIN     DD *\n  INCLUDE SYSADD(DYNALL,GFDATE,MREAD)\n  INCLUDE SYSADD(READ,SRCHRPI)\n  ENTRY   AUTOCI\n  SETCODE AC(1)\n  NAME    AUTOCI(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "AUTOCI@": {"ttr": 4103, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x89\\x19?\\x00\\x89\\x19?\\x141\\x01=\\x01=\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-07-12T00:00:00", "modifydate": "1989-07-12T14:31:00", "lines": 317, "newlines": 317, "modlines": 0, "user": "SYSPAJA"}, "text": "1   17/05/88\n                                                      AUTO      1/7.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * *                                                 * * * * *\n  * * * * *     A U T O M A T I C     O P E R A T O R S     * * * * *\n  * * * * *                                                 * * * * *\n  * * * * *         C O M M A N D S     I S S U E R         * * * * *\n  * * * * *                                                 * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Purpose :    Issue operators commands (started task or specific\n  ---------    background jobs only). When executed in foreground\n               region by an authorized TSO user, the program enter\n               a special test mode, usefull to debug the operators\n               commands sequence process (using terminal TPUT/TGET).\n\n  Invoked by : 1. Console START command :\n  ------------      S AUTO,FROM='...PO-dsname...',\n                           M=...member-name...\n\n               2. Procedure (authorized job) :\n                    //... EXEC AUTO,FROM='...PO-dsname...',\n                                    M=...member-name...\n                  where AUTO procedure skeleton may be :\n                    //AUTO    PROC M=...,FROM='...'\n                    //AUTO    EXEC PGM=AUTOCI,PARM='&M'\n                    //STEPLIB   DD DSN=...library...,DISP=SHR\n                    //SYSPDS    DD DSN=&FROM,DISP=SHR\n\n               3. JCL (authorized job) :\n                    //... EXEC PGM=AUTOCI,PARM='...member-name...'\n                    //STEPLIB  DD DSN=...library...,DISP=SHR\n                    //SYSPDS   DD DSN=...PO-dsname...,DISP=SHR\n\n               4. TSO test mode (authorized user) :\n                    ALLOC DA(...PO-dsname...) F(SYSPDS) SHR\n                    CALL '...library...(AUTOCI)' '...member-name...'\n                                            or : '...member-name.../S'\n                    FREE F(SYSPDS)\n                  Note : can be a CLIST if desired. '/S' may be added\n                         after the member-name to send the operators\n                         commands to the operating system.\n\n               5. TSO command or sub-command (authorized user) :\n                    AUTOCI ...PO-dsname... ...member-name... T(EST)\n                                                             S(YSTEM)\n                  Note : option T or TEST is the default, when S or\n                         SYSTEM is used, the operators commands are\n                         sended to the operating system.\n1   17/05/88\n                                                      AUTO      2/7.\n\n  Parameters field : PARM=...member-name... to supply the initial\n  ------------------ operators commands member name.\n               ...member-name... may be 1 up to 8 characters long.\n\n  Input data (SYSPDS) : columns 1 to 72 of cards can be used for\n  --------------------- operators commands or instructions coding.\n               No fixed columns nor continuations are provided.\n\n  Instructions : each must be coded on a separate card and must be\n  -------------- followed by at least one blank, except the NULL\n                 instruction which may be followed by another one\n                 (obviously not another NULL) or an operator command\n                 in the same card.\n\n     *  ...text...\n          A starting asterisk (*) means a comment card.\n\n     GDATE  (alias @G)\n          Display the date and time of day.\n\n     MESSAGE  ...text...  (alias @M)\n          Send a message text to the main console.\n          ...text... may be 55 characters long at maximum, otherwise\n                    it is truncated.\n\n     PAUSE  ...text...  (alias @P)\n          Send a message text to the main console and allow the\n          operator to reply in order to continue or stop immediately\n          the commands sequence of the current member (EXECUTE) or\n          the main member (program).\n          The operator response may be 0 up to 8 characters long and\n          is available to various other statements (until the next\n          PAUSE), unless the reply text is CANCEL, which cause the\n          immediate stop as previously explained.\n          ...text... may be 55 characters long at maximum, otherwise\n                    it is truncated.\n\n     NULL  SSSS  (or :SSSS)\n          Define a sequence symbol to which a branch instruction refers\n          (i.e. - GOTO, IF's, ...).\n          SSSS : is the sequence symbol. It may be 1 up to 8 characters\n                    long.\n\n     GOTO  SSSS  (alias GO)\n          Allows to branch unconditionally.\n          SSSS : is a sequence symbol to which the branch is done\n                    (SSSS must be defined in a NULL instruction).\n                    SSSS may be 1 up to 8 characters long.\n1   17/05/88\n                                                      AUTO      3/7.\n\n     IF-REPLY  WWWW  ....  SSSS  (alias IF-R)\n          Allows to branch according to a test result on the previous\n          PAUSE ... operator response. Thus the sequence in which the\n          operators commands are processed can be altered.\n          WWWW may be one of the following operators :\n                    EQ (or =)     NE (or /)     LT (or <)\n                    GT (or >)     LE (or <=)    GE (or >=)\n          .... : is the desired value to test (to indicate a null\n                    response, zero length reply, code '').\n                    The test is done with the value length, this means\n                    that YES matches also Y in\n                         IF-R  EQ  Y  ACCEPT\n                    (the branch is taken), or 9 is greater than 50 in\n                         IF-R  LE  50  ACCEPT\n                    (the branch is not taken).\n          SSSS : is a sequence symbol to which the branch is taken if\n                    the condition is true, otherwise the process\n                    continue in sequence (SSSS must be defined in a\n                    NULL instruction).\n                    SSSS may be 1 up to 8 characters long.\n\n     IF-REPLY-CHAR  WWWW  ....  SSSS  (alias IF-C)\n          Identical to IF-REPLY, but the operator response and the test\n          values are collating sequence compared, thus the two values\n          are left padded with blanks (so YES does not match Y but is\n          greater, and 9 is lower than 50).\n\n     IF-REPLY-BIN  WWWW  ....  SSSS  (alias IF-B)\n          Identical to IF-REPLY, but the operator response and the test\n          values are considered integer numbers for compare (so 9 is\n          less than 50).\n                    Note - Plus (+) or minus (-) sign is not accepted.\n\n     IF-REPLY-HEX  WWWW  ....  SSSS  (alias IF-H)\n          Identical to IF-REPLY, but the operator response and the test\n          values are considered hexadecimals for compare (so F is less\n          than A0).\n                    Note - Plus (+) or minus (-) sign is not accepted.\n\n     VER-BIN  SSSS  (alias V-B)\n     VER-HEX  SSSS  (alias V-H)\n          Allows to verify the operator response for only numerics\n          (0-9) or hexadecimals (0-9,A-F) characters contents.\n          The branch is taken if a wrong character is detected.\n                    Note - Plus (+) or minus (-) sign is not accepted.\n          SSSS : is a sequence symbol to which the branch is taken if\n                    the wrong condition is true, otherwise the process\n                    continue in sequence (SSSS must be defined in a\n                    NULL instruction).\n                    SSSS may be 1 up to 8 characters long.\n1   12/07/89\n                                                      AUTO      4/7.\n\n     IF-REPLY-ID  ....  SSSS  (alias IF-ID)\n          Allows to branch according to a search for a reply pending\n          ID found. Thus the sequence in which the operators commands\n          are processed can be altered.\n          .... : is the desired message-ID text (must be at least 8\n                    characters long). If any blanks are needed (unless\n                    leading blanks up to 8 characters), the message-ID\n                    must be given as a quoted characters string, so a\n                    needed quote in the text must be doubled.\n          SSSS : is a sequence symbol to which the branch is taken\n                    if the reply-ID is found, otherwise the process\n                    continue in sequence (SSSS must be defined in a\n                    NULL instruction).\n                    SSSS may be 1 up to 8 characters long.\n          When the reply-ID is found, the edited reply number is set\n          in the reserved variable named RPID (2 characters long),\n          this allowing the &S-RV(RPID)...reply text... string to\n          be an operator reply command.\n\n     LOGICAL  VAR1  VAR2  ...  VARN  (alias @L)\n          Define processing logical variables (name may be 1 up to 8\n          characters long). The initial value of these variables is\n          FALSE.\n\n     TRUE  VAR1  VAR2  ...  VARN  (alias @T)\n     FALSE  VAR1  VAR2  ...  VARN  (alias @F)\n          Set logical variables value to TRUE or FALSE.\n\n     IF-TRUE  VARN  SSSS  (alias IF-T)\n     IF-FALSE  VARN  SSSS  (alias IF-F)\n          Test the logical variable VARN on TRUE or FALSE value.\n          SSSS : is a sequence symbol to which the branch is taken if\n                    the condition is met, otherwise the process\n                    continue in sequence (SSSS must be defined in a\n                    NULL instruction).\n\n     SET-REPLY  VVVV  (aliases SET, SET-VAR)\n     SET-VAR  VVVV  ....  (aliases SET, SET-REPLY)\n          Memorize the current available PAUSE ... operator response\n          (0 up to 8 characters long) or a specific value (0 up to 8\n          characters long) in a variable.\n          VVVV is the variable name. It may be 1 up to 8 characters\n                    long, and cannot be one of the reserved name (see\n                    IF QQQQ WWWW .... SSSS statement).\n          .... : is the desired value to store (to indicate a null\n                    value, zero length, code '').\n          Then the string &S-RV(VVVV), into which VVVV is the variable\n          name or one of the reserved names (here it is accepted), is\n          replaced by the variable value if encountered in the text of\n          any MESSAGE, PAUSE, IF-REPLY's, EXECUTE, SUBMIT, T-WAIT,\n          COMMON instructions or operators commands.\n1   05/07/88\n                                                      AUTO      5/7.\n\n     IF  QQQQ  WWWW  ....  SSSS\n     IF-VAR  VVVV  WWWW  ....  SSSS  (alias IF-V)\n          Allows to branch according to the result of a condition test.\n          Thus the sequence in which the operators commands are\n          processed can be altered.\n          QQQQ may be one of the following reserved names :\n                    SID : means the system ID (from SMF : SSSS).\n                    CPU : means the CPU model (from CVT : MMMM).\n                    SDATE : means the standard date (YYMMDD).\n                    JDATE : means the Julian date (YYDDD).\n                    DAY : means the current day name (SUN, MON,\n                              TUE, WED, THU, FRI and SAT).\n                    MONTH : means the current month name (JAN,\n                              FEB, MAR, APR, MAY, JUN, JUL, AUG,\n                              SEP, OCT, NOV and DEC).\n                    TIME : means the current time of day in\n                              hours/minutes (HHMM).\n                    HOURS : means the hours (HH part of TIME).\n                    MINS : means the minutes (MM part of TIME).\n                    YEAR : means the year (YY part of SDATE).\n                    SMONTH : means the month (MM part of SDATE).\n                    SDAY : means the day (DD part of SDATE).\n                    JDAY : means the day (DDD part of JDATE).\n          VVVV is the name of a variable which has been defined by a\n                    previous SET-REPLY or SET-VAR. It may be 1 up to 8\n                    characters long.\n          WWWW may be one of the following operators :\n                    EQ (or =)     NE (or /)     LT (or <)\n                    GT (or >)     LE (or <=)    GE (or >=)\n          .... : is the desired value to test.\n                    Note : The test is done with the value length and\n                    right justified (i.e. : TIME EQ 945 matches 0945 AM\n                    and 1945 PM).\n          SSSS : is a sequence symbol to which the branch is taken\n                    if the condition is true, otherwise the process\n                    continue in sequence (SSSS must be defined in a\n                    NULL instruction).\n                    SSSS may be 1 up to 8 characters long.\n1   17/05/88\n                                                      AUTO      6/7.\n\n     EXECUTE  ...PO-dsname...  ...member-name...  (alias @E)\n              *  ...member-name...\n          Allows the execution of another member containing operators\n          commands sequence, then at end of this member the process\n          continue in sequence (up to 99 nested EXECUTE may be\n          defined).\n          ...PO-dsname... is the partitioned data-set name, and may be\n                    1 up to 44 characters long. When * (asterisk) form\n                    is coded, it means the current data-set in use.\n          ...member-name... may be 1 up to 8 characters long.\n\n     SUBMIT  *(...member-name...)  (alias SUB)\n             ...PO-dsname...(...member-name...)\n             ...PS-dsname...\n          Allows the SUBMIT of a batch job for conventional processing.\n          The job submitted must reside in either a member of a\n          partitioned or a sequential data-set.\n          Submitted data-set must be fixed 80-bytes records (blocked\n          or unblocked).\n                    Note : the JCL JOB statement must be the first and\n                    may contain all the needed information.\n          ...PO-dsname... is the partitioned data-set name, and may be\n                    1 up to 44 characters long. When * (asterisk) form\n                    is coded, it means the current data-set in use.\n          ...member-name... may be 1 up to 8 characters long.\n          ...PS-dsname... is the sequential data-set name, and may be\n                    1 up to 44 characters long.\n          The SUBMIT function supplies the password only if the\n          USER=... keyword is coded and the PASSWORD=... keyword is\n          not coded (this assumes the JOB statement is more than one\n          card coded).\n\n     T-WAIT  SECS  (alias @W)\n          Allows to wait-a-bit.\n          SECS : is the number (1-120) of seconds to wait. If omitted\n                    or 0 is specified, it means no wait.\n1   17/05/88\n                                                      AUTO      7/7.\n\n     LOAD-COMMON  ...PO-dsname...  ...member-name...  (alias @CL)\n     SAVE-COMMON  ...PO-dsname...  ...member-name...  (alias @CS)\n          Load from or save in the indicated data-set member all the\n          common-switches (1-400).\n                    Note : as soon as the execution begins, all the\n                    common-switches are availables (value FALSE).\n                    A load from any unexistant member of an existing\n                    PO data-set results in a no-operation, so all the\n                    common-switches remain as they were.\n          ...PO-dsname... is the partitioned data-set name, and may be\n                    1 up to 44 characters long.\n          ...member-name... may be 1 up to 8 characters long.\n\n     SET-COMMON  NNN  NNN  ...  or  ( NNN - NNN )  ...  (alias @CT)\n     RESET-COMMON  NNN  NNN  ...  or  ( NNN - NNN )  ...  (alias @CF)\n          Set the common-switch number NNN (1-400) or range of\n          common-switches numbers (from-to) value to TRUE or FALSE.\n\n     IF-COMMON-TRUE  NNN  SSSS  (alias @CIT)\n     IF-COMMON-FALSE  NNN  SSSS  (alias @CIF)\n          Test the common-switch number NNN (1-400) on TRUE or FALSE\n          value.\n          SSSS : is a sequence symbol to which the branch is taken if\n                    the condition is met, otherwise the process\n                    continue in sequence (SSSS must be defined in a\n                    NULL instruction).\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "AUTOTS": {"ttr": 4109, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x13\\x7f\\x00\\x88\\x13\\x7f\\x16D\\x00&\\x00&\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-05-16T00:00:00", "modifydate": "1988-05-16T16:44:00", "lines": 38, "newlines": 38, "modlines": 0, "user": "SYSPAJA"}, "text": "         LOGICAL  SWC  SWD  SWDH\n         MESSAGE  -- TEST CPU-SID AND/OR DAY-MONTH --\n         PAUSE  REPLY : BOTH/B, C-S/C, D-M/D OR NONE/N\n:SL      IF-REPLY  .EQ.  NONE  PLAY\n         IF-REPLY-CHAR  .EQ.  N  PLAY\n         IF-R  .EQ.  ''  BEGIN\n         IF-R  .EQ.  BOTH  BEGIN\n         IF-C  .EQ.  B  BEGIN\n         IF-R  .EQ.  C-S  CS\n         IF-C  .EQ.  C  CS\n         IF-R  .EQ.  D-M  DM\n         IF-C  .EQ.  D  DM\n         PAUSE  INVALID RESPONSE VALUE. RESPECIFY :\n         GOTO  SL\n:CS      TRUE  SWD\n         GOTO  BEGIN\n:DM      TRUE  SWC\nNULL BEGIN\n         GDATE\n         IF-TRUE  SWC  SKCS\n         EXECUTE  *  AUTOTS1\n: SKCS   IF-T  SWD  SKDM\n         @E  *  AUTOTS2\n: SKDM\n: PLAY   @P  DO YOU WANT TO PLAY WITH ME ? (Y/N)\n         IF-R  =  N  TDHT\n         @E  *  AUTOTS3\n: TDHT   @P  DECIMAL OR HEXADECIMAL TEST ? (D/H/N)\n: RSEL   @F  SWDH\n         IF-R  =  D  SELT\n         IF-R  =  H  SETH\n         IF-R  =  N  EXIT\n         @P  INVALID SELECTION. RESPECIFY :\n         GO  RSEL\n: SETH   @T  SWDH\n: SELT   @E  *  AUTOTS4\n         GO  TDHT\nNULL EXIT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "AUTOTS1": {"ttr": 4353, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x12_\\x00\\x88\\x12_\\x14)\\x00\\x14\\x00\\x14\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-05-04T00:00:00", "modifydate": "1988-05-04T14:29:00", "lines": 20, "newlines": 20, "modlines": 0, "user": "SYSPAJA"}, "text": "         IF  CPU  NE  470  S003\n         IF  SID  NE  SYSA  S001\n         @M  CPU/SID - IT IS \"0470\" AND \"SYSA\"\n         GO  EXIT\n:S001    IF  SID  EQ  SYSB  S002\n         @M  CPU/SID - IT IS \"0470\" AND ?\n         GO  EXIT\n:S002    @M  CPU/SID - IT IS \"0470\" AND \"SYSB\"\n         GO  EXIT\n:S003    IF  CPU  NE  580  S006\n         IF  SID  NE  SYSA  S004\n         @M  CPU/SID - IT IS \"0580\" AND \"SYSA\"\n         GO  EXIT\n:S004    IF  SID  EQ  SYSB  S005\n         @M  CPU/SID - IT IS \"0580\" AND ?\n         GO  EXIT\n:S005    @M  CPU/SID - IT IS \"0580\" AND \"SYSB\"\n         GO  EXIT\n:S006    @M  CPU/SID - IT IS ? AND ?\n:EXIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "AUTOTS2": {"ttr": 4355, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x12_\\x00\\x88\\x12_\\x14)\\x00\\x19\\x00\\x19\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-05-04T00:00:00", "modifydate": "1988-05-04T14:29:00", "lines": 25, "newlines": 25, "modlines": 0, "user": "SYSPAJA"}, "text": "         IF  DAY  /  MON  S002\n         IF  MONTH  =  JAN  S001\n         @M  DAY/MONTH - IT IS \"MON\" BUT NOT \"JAN\"\n         GO  S010\n:S001    @M  DAY/MONTH - IT IS \"MON\" AND \"JAN\"\n         GO  S010\n:S002    IF  MONTH  =  JAN  S003\n         @M  DAY/MONTH - IT IS NOT \"MON\" AND NOT \"JAN\"\n         GO  S010\n:S003    @M  DAY/MONTH - IT IS NOT \"MON\" BUT \"JAN\"\n:S010    IF  TIME  >=  1200  S020\n         IF  TIME  >=  0600  S011\n         IF  TIME  <=  0300  S022\n         @M  \"YOU ARE AN EARLY BIRD\"\n         GO  EXIT\n:S011    @M  \"GOOD MORNING\"\n         GO  EXIT\n:S020    IF  TIME  >=  1800  S021\n         @M  \"GOOD AFTERNOON\"\n         GO  EXIT\n:S021    IF  TIME  >=  2200  S022\n         @M  \"GOOD EVENING\"\n         GO  EXIT\n:S022    @M  \"GOOD NIGHT\"\n:EXIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "AUTOTS3": {"ttr": 4357, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x12_\\x00\\x88\\x12_\\x14)\\x00#\\x00#\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-05-04T00:00:00", "modifydate": "1988-05-04T14:29:00", "lines": 35, "newlines": 35, "modlines": 0, "user": "SYSPAJA"}, "text": "         @L  SWI  SWL  SWLS  SWH  SWHS\n         @P  TRY TO FIND THE NUMBER I THINK (BETWEEN 1 AND 50) :\n:ANAL    V-B  ERR\n         IF-B  LT  1  ERR\n         IF-B  LE  50  OK\n:ERR     IF-T  SWI  ERRI\n         @P  INVALID NUMBER. RESPECIFY :\n         @T  SWI\n         GO  ANAL\n:ERRI    @P  HEY| MONKEY| INVALID NUMBER| RESPECIFY (1 TO 50) :\n         GO  ANAL\n:OK      @F  SWI\n         IF-R  =  17  EXIT\n         IF-B  >  17  OVER\n         @F  SWH\n         IF-T  SWL  LOWT\n         IF-F  SWLS  LOW\n:LOWT    IF-B  <=  &S-RV(PRVL)  LOWP\n:LOW     SET  PRVL\n         @P  IT IS LOW. TRY AGAIN :\n         @T  SWL  SWLS\n         GO  ANAL\n:LOWP    @P  HEY| STUPID| PREVIOUS WAS &S-RV(PRVL). TRY AGAIN :\n         GO  ANAL\n:OVER    @F  SWL\n         IF-T  SWH  HIGHT\n         IF-F  SWHS  HIGH\n:HIGHT   IF-B  >=  &S-RV(PRVH)  HIGHP\n:HIGH    SET  PRVH\n         @P  IT IS HIGH. TRY AGAIN :\n         @T  SWH  SWHS\n         GO  ANAL\n:HIGHP   @P  HEY| GENIOUS| PREVIOUS WAS &S-RV(PRVH). TRY AGAIN :\n         GO  ANAL\n:EXIT    @M  IT'S THAT ONE. BYE... BYE...\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "AUTOTS4": {"ttr": 4359, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x12_\\x00\\x88\\x12_\\x14)\\x00\\x0c\\x00\\x0c\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-05-04T00:00:00", "modifydate": "1988-05-04T14:29:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "SYSPAJA"}, "text": "         @P  ENTER A VALUE OR TYPE END (E) :\n:ANAL    IF-R  =  END  EXIT\n         IF-C  =  E  EXIT\n         IF-T  SWDH  THEX\n         V-B  ERR\n         GO  NEXT\n:THEX    V-H  ERR\n:NEXT    @P  ENTER :\n         GO  ANAL\n:ERR     @P  INVALID VALUE. RESPECIFY :\n         GO  ANAL\n:EXIT    @M  - END -\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "BRODSCA$": {"ttr": 4361, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x942\\x7f\\x00\\x942\\x7f\\x14#\\x00\\t\\x00\\t\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-23T00:00:00", "modifydate": "1994-11-23T14:23:00", "lines": 9, "newlines": 9, "modlines": 0, "user": "SYSPAJA"}, "text": "//BRODSCAN JOB (........),'INSTALL - BRODSCAN -',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=1M,TIME=1\n/*JOBPARM L=2\n//ASS     EXEC PAJ1AS3,MBR=BRODSCAN\n//LNK     EXEC PAJILKL\n//SYSIN     DD *\n  ENTRY   BRODSCAN\n  NAME    BRODSCAN(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "BRODSCA@": {"ttr": 4363, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x86\\x19\\x8f\\x00\\x86\\x19\\x8f\\x17\\x11\\x00A\\x00A\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-07-17T00:00:00", "modifydate": "1986-07-17T17:11:00", "lines": 65, "newlines": 65, "modlines": 0, "user": "SYSPAJA"}, "text": "1   25/06/86\n                                                      BRODSCAN  1/2.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *   ANALYZE TSO BROADCAST DATA-SET    * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  CBT origin : extracted from CBT tape 86 FEB, file 141.\n  ------------\n\n  Purpose :    This program analyzes the TSO BROADCAST data-set. It\n  ---------    displays the number of available blocks and how they\n               are used. It also displays the TSO users who have\n               messages waiting. In addition it also does a validity\n               check on records which are in the message pool to assure\n               they are chained off of a user record. According to\n               documentation, instances occur which can result in these\n               garbage records existing.\n\n  Sample execution JCL :\n  ----------------------\n\n               //ANAL   EXEC PGM=BRODSCAN\n               //STEPLIB  DD DSN=...USER.LOAD...,DISP=SHR\n               //BRODCAST DD DSN=SYS1.BRODCAST,DISP=SHR\n               //SYSOUT   DD SYSOUT=A,DCB=BLKSIZE=1330\n1   25/06/86\n                                                      BRODSCAN  2/2.\n\n  Sample execution output :\n  -------------------------\n\n TOTAL AVAILABLE BLOCKS IN DATASET                              795\n BLOCKS NECESSARY FOR BROADCST MSGS (DIRECTORY/MESSAGES)        104\n\n < THE FOLLOWING KEY BREAKDOWN WAS FOUND >\n          HEADER RECORDS                                          1\n          BROADCAST MSG DIRECTORY RECORDS                         4\n          BROADCAST MESSAGE RECORDS                             100\n          USERID INDEX RECORDS                                   64\n          NON-BROADCAST MESSAGE RECORDS                         133\n          FREE RECORDS                                          493\n\n < THE FOLLOWING USERS HAVE MESSAGES WAITING >\n          A7T     :   21     C1F     :    1     C1G     :    1\n          C1Q     :    1     C23     :    1     C28     :    1\n          C3I     :    2     C37     :    2     C4K     :   10\n          C4X     :    1     C45     :    1     C47     :    1\n          C5D     :    1     C5M     :    1     C52     :    1\n          C77     :    1     C79     :    1     D40     :    5\n          HAE     :    1     HAR     :    1     HA7     :    1\n          HA9     :    3     HCE     :    2     HCH     :    3\n          HCN     :    3     HC2     :    1     HC8     :    1\n          HD3     :    9     HEB     :    1     HE9     :    1\n          HZE     :    1     HZI     :    3     HZM     :    2\n          HZN     :    1     HZP     :    1     HZV     :    1\n          HZ0     :    1     HZ4     :    1     KP1     :    1\n          K14     :    5     MS8     :    1     SCM     :    8\n          SFF     :   22     SFO     :    5     SFW     :    1\n          SWW     :   10     SW2     :    5     SW7     :    1\n NUMBER OF TSO USERS DEFINED IN DATASET                         571\n\n BLOCKS FOUND TO BE GARBAGED                                      0\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "BRODSCAN": {"ttr": 4365, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x882o\\x01\\x01\\x19/\\x10Q\\x02\\x0f\\x02\\x0f\\x00\\x01\\xe6\\xe2\\xc2\\xc7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1988-11-21T00:00:00", "modifydate": "2001-07-11T10:51:00", "lines": 527, "newlines": 527, "modlines": 1, "user": "WSBG"}, "text": "BRSC     TITLE 'BRODSCAN - ANALYZE TSO BROADCAST DATA-SET.'        -EU-\n         PRINT OFF                                                 -EU-\n         MACRO                                                     -EU-\n&LAB    @SNAP  &DECB                                               -EU-\n&LAB     TM    SWITCH,SNREQ                                        -EU-\n         BZ    *+L'*+10                                            -EU-\n         LA    R1,&DECB                                            -EU-\n         L     R15,=A(SNAP)                                        -EU-\n         BASR  R14,R15                                             -EU-\n         MEND                                                      -EU-\n         MACRO                                                     -EU-\n&LAB    @PPUT  &LINE                                               -EU-\n&LAB     LA    R0,&LINE                                            -EU-\n         L     R15,=A(PPUT)                                        -EU-\n         BASR  R14,R15                                             -EU-\n         MEND                                                      -EU-\n         PRINT ON                                                  -EU-\n         SPACE 1                                                   -EU-\nBRODSCAN START 0                                                   -EU-\n         SPACE 1                                                   -EU-\n*********************************************************************\n**                                                                 **\n**       BRODSCAN -                                                **\n**                                                                 **\n**       WRITTEN 7/83                                              **\n**       WASHINGTON STATE DEPARTMENT OF TRANSPORTATION             **\n**       RICHARD G. NIKULA                                         **\n**                                                                 **\n**       THIS PROGRAM ANALYZES THE TSO BROADCAST DATA-SET. IT      **\n**       DISPLAYS THE NUMBER OF AVAILABLE BLOCKS AND HOW THEY      **\n**       ARE USED. IT ALSO DISPLAYS THE TSO USERS WHO HAVE         **\n**       MESSAGES WAITING. IN ADDITION IT ALSO DOES A VALIDITY     **\n**       CHECK ON RECORDS WHICH ARE IN THE MESSAGE POOL TO ASSURE  **\n**       THEY ARE CHAINED OFF OF A USER RECORD. ACCORDING TO       **\n**       DOCUMENTATION, INSTANCES OCCUR WHICH CAN RESULT IN THESE  **\n**       GARBAGE RECORDS EXISTING.                                 **\n**                                                                 **\n*********************************************************************\n         EJECT ,                                                   -EU-\n* ---------------------------------------------------------------- -EU-\n* CBT ORIGIN : EXTRACTED FROM CBT TAPE 86 FEB, FILE 141.           -EU-\n* ---------------------------------------------------------------- -EU-\n*                                                                  -EU-\n* UPDATED BY MOINIL P.A. - COMPUTING CENTRE                        -EU-\n*                          J.R.C. - ISPRA ESTABLISHMENT            -EU-\n*                          21020 ISPRA (VA), ITALY                 -EU-\n*        - SNAP OPTION ADDED TO GET BRODCAST BLOCKS TRACE.         -EU-\n         SPACE 2                                                   -EU-\nBRODSCAN AMODE  24                                                 -EU-\nBRODSCAN RMODE  24                                                 -EU-\n         SPACE 2                                                   -EU-\nTTL      EQU   16318               RECORDS TYPES TABLE LENGTH      -EU-\nTTLL     EQU   ((TTL+7)/8)*8       ROUNDED TO DOUBLE WORD          -EU-\nTKL      EQU   12+(51*80)          SINGLE TANK AREA LENGTH         -EU-\nTKSZ     EQU   ((TKL+7)/8)*8       ROUNDED TO DOUBLE WORD          -EU-\n         EJECT ,                                                   -EU-\n        $DEFREG ,                                                  -EU-\n        $XENT  BASE=R12                                            -EU-\n         EJECT ,                                                   -EU-\n         XR    R10,R10             C.C. = 0                        -EU-\n        GETMAIN EC,LV=TTLL,A=TYPETABL                              -EU-\n         LTR   R10,R15             STORAGE AVAILABLE?              -EU-\n         BNZ   EXIT                NO, C.C. IS SET                 -EU-\n         L     R8,TYPETABL                                         -EU-\n         LR    R2,R8               INITIALIZE TABLE                -EU-\n         L     R3,=A(TTL)                                          -EU-\n         LA    R4,*                                                -EU-\n         XR    R5,R5                                               -EU-\n         ICM   R5,B'1000',=X'99'                                   -EU-\n         MVCL  R2,R4                                               -EU-\n         SPACE 1                                                   -EU-\n        EXTRACT ATIOT,'S',FIELDS=(TIOT,TSO)                        -EU-\n         L     R2,ATSO                                             -EU-\n         TM    0(R2),X'80'                                         -EU-\n         BZ    *+L'*+4                                             -EU-\n         OI    SWITCH,TSORUN                                       -EU-\n         XR    R1,R1                                               -EU-\n         L     R2,ATIOT                                            -EU-\n         USING TIODSECT,R2                                         -EU-\n         L     R3,=A(SNAPDCB)                                      -EU-\n         USING IHADCB,R3                                           -EU-\nSNLOOP   CLC   TIOELNGH(4),=F'0'                                   -EU-\n         BE    DSOPEN                                              -EU-\n         CLC   TIOEDDNM(L'TIOEDDNM),DCBDDNAM                       -EU-\n         BE    SFOUND                                              -EU-\n         IC    R1,TIOELNGH                                         -EU-\n         ALR   R2,R1                                               -EU-\n         B     SNLOOP                                              -EU-\n         DROP  R2,R3                                               -EU-\nSFOUND   OI    SWITCH,SNREQ                                        -EU-\n         SPACE 1\nDSOPEN   OPEN  (BRODCAST,(INPUT),SYSOUT,(OUTPUT))                  -EU-\n         SPACE 1\n*        GET THE HEADER RECORD.\n         SPACE 1\n         READ  HDRECB,DI,BRODCAST,'S','S','S',BLOCKNO\n         CHECK HDRECB\n         L     R3,HDRECB+12\n         USING HEADER,R3\n         MVC   SAVERRN,USERRRN\n         MVC   HIGHVAL,TOTALREC         SAVE GET OUT VALUE\n         LH    R5,HIGHVAL               GET NUMBER FOR PRINTOUT\n         CVD   R5,CVDAREA               CONVERT IT TO PRINTABLE\n         MVC   MAXCNT,MASK2                                        -EU-\n         ED    MAXCNT,CVDAREA+5         MAKE IT PRETTY\n        @PPUT  MAXIMUM                  TELL HOW MANY              -EU-\n         LH    R5,MAXNOT                GET NUMBER OF NOTICES\n         XR    R4,R4                    CLEAR R4\n         D     R4,=F'25'                NUMBER OF BLOCKS REQUIRED\n         AH    R5,MAXNOT                PLUS TOTAL FOR MESSAGES\n         LTR   R4,R4                    REMAINDER?\n         BZ    CVDNOT\n         LA    R5,1(R5)                 ONE MORE REQUIRED\nCVDNOT   CVD   R5,CVDAREA               CONVERT IT TO PRINTABLE\n         MVC   NOTCNT,MASK1                                        -EU-\n         ED    NOTCNT,CVDAREA+6         MAKE IT PRETTY\n        @PPUT  NOTICES                  TELL HOW MANY              -EU-\n         FREEDBUF HDRECB,D,BRODCAST\n         LR    R7,R8                                               -EU-\n         MVI   0(R7),X'04'                                         -EU-\n         LA    R7,1(R7)                                            -EU-\nREADLOOP ICM   R1,7,BLOCKNO\n         LA    R1,1(R1)\n         STCM  R1,7,BLOCKNO\n         CLC   BLOCKNO+1(2),HIGHVAL\n         BE    ANALYZE\n         READ  RECECB,DI,BRODCAST,'S','S','S',BLOCKNO\n         CHECK RECECB\n         L     R2,RECECB+20             KEY ADDRESS\n         MVC   0(1,R7),0(R2)            STORE TYPE INTO TABLE\n         LA    R7,1(R7)\n         CLI   0(R2),X'00'              IS THIS NOTICE RECORD\n         BNE   CHK1                     NO.\n         AP    NOTDIR,=P'1'             ADD 1 TO TOTAL\n         B     FREEB\nCHK1     CLI   0(R2),X'01'              IS THIS USERID INDEX RECORD\n         BNE   CHK2                     NO.\n         AP    USRIND,=P'1'             ADD 1 TO TOTAL\n         B     FREEB\nCHK2     CLI   0(R2),X'02'              IS THIS NOTICE MSG RECORD\n         BNE   CHK3                     NO.\n         AP    NOTMSG,=P'1'             ADD 1 TO TOTAL\n         B     FREEB\nCHK3     CLI   0(R2),X'03'              IS THIS USER MESSAGE RECORD\n         BNE   CHKFF                    NO.\n         AP    USRMSG,=P'1'             ADD 1 TO TOTAL\n         B     FREEB\nCHKFF    CLI   0(R2),X'FF'              IS THIS USER MESSAGE RECORD\n         BNE   UNKNOWN                  NO.\n         AP    FREEREC,=P'1'            ADD 1 TO TOTAL\n         B     FREEB\nUNKNOWN  UNPK  ODDKEY+36(3),0(2,R2)                                -EU-\n         TR    ODDKEY+36(2),HEXTAB-X'F0'                           -EU-\n         MVI   ODDKEY+38,C' '                                      -EU-\n        @PPUT  ODDKEY                                              -EU-\n        @SNAP  RECECB              DUMP BLOCK READ                 -EU-\nFREEB    FREEDBUF RECECB,D,BRODCAST\n         B     READLOOP\nANALYZE @PPUT  BREAKOUT                                            -EU-\n        @PPUT  KEYCOUNT                                            -EU-\n         MVC   KEYTYPE,=CL50'BROADCAST MESSAGE DIRECTORY RECORDS'\n         MVC   KEYCNT,MASK2                                        -EU-\n         ED    KEYCNT,NOTDIR\n        @PPUT  KEYCOUNT                                            -EU-\n         MVC   KEYTYPE,=CL50'BROADCAST MESSAGE RECORDS'\n         MVC   KEYCNT,MASK2                                        -EU-\n         ED    KEYCNT,NOTMSG\n        @PPUT  KEYCOUNT                                            -EU-\n         MVC   KEYTYPE,=CL50'USERID INDEX RECORDS'\n         MVC   KEYCNT,MASK2                                        -EU-\n         ED    KEYCNT,USRIND\n        @PPUT  KEYCOUNT                                            -EU-\n         MVC   KEYTYPE,=CL50'NON-BROADCAST MESSAGE RECORDS'\n         MVC   KEYCNT,MASK2                                        -EU-\n         ED    KEYCNT,USRMSG\n        @PPUT  KEYCOUNT                                            -EU-\n         MVC   KEYTYPE,=CL50'FREE RECORDS'\n         MVC   KEYCNT,MASK2                                        -EU-\n         ED    KEYCNT,FREEREC\n        @PPUT  KEYCOUNT                                            -EU-\n        @PPUT  USERSOUT                                            -EU-\nINDEXLP  LA    R6,9                     COUNT OF USERS PER RECORD\n         MVC   BLOCKNO,SAVERRN\n         READ  SCNECB,DI,BRODCAST,'S','S','S',BLOCKNO\n         CHECK SCNECB\n         L     R3,SCNECB+12             ADDRESS OF RECORD\n         MVC   SAVERRN,126(R3)          COPY NEXT INDEX RECORD NUMBER\nUSRLOOP  MVC   USERID,0(R3)             COPY WHO THIS IS\n         CLC   USERID,=7X'00'           IS THIS A REAL USER?\n         BE    NOMSG                    NOPE, MUST HAVE BEEN DELETED\n         AP    USERS,=P'1'\n         XR    R4,R4                    CLEAR UPPER BYTE\n         ICM   R4,7,7(R3)               GET BLOCK POSITION\n         BZ    NOMSG                    NO.. JUST BUMP\nALTCODE  LA    R5,0(R4,R8)              ADDRESS OF BLOCK IN TABLE  -EU-\n         CLI   0(R5),X'03'              JUST VERIFY WERE WE ARE\n         BE    TABLOK                   OTHERWISE COUNT TABLE IS OUT\n         AP    TBECNT,=P'1'             OF SYNC WITH MY REALITY    -EU-\n         B     BUMPUSR                  JUST LET THEM KNOW I'M CONFUSED\nTABLOK   MVI   0(R5),X'88'              SET THAT IT WAS A VALID MESSAGE\nBUMPUSR  AP    MSGCOUNT,=P'1'           INCREMENT HOW MANY MESSAGES\n         STCM  R4,7,MSGNUM\n         READ  MSGECB,DI,BRODCAST,'S','S','S',MSGNUM\n         CHECK MSGECB\n         L     R4,MSGECB+12             ADDRESS OF RECORD\n         ICM   R4,7,126(R4)             RRN OF NEXT MESSAGE\n         FREEDBUF MSGECB,D,BRODCAST\n         LTR   R4,R4\n         BNZ   ALTCODE\n         AP    RECCNT,=P'1'\n         CP    RECCNT,=P'2'             TEST MID RANGE\n         BL    LINE1                    LOWER\n         BH    LINE3                    HIGHER\n         BE    LINE2                    .MIDRANGE\nLINE1    MVC   MSGCNT1,MASK1                                       -EU-\n         MVC   USERID1,USERID\n         ED    MSGCNT1,MSGCOUNT\n         B     ZAPCNT\nLINE2    MVC   MSGCNT2,MASK1                                       -EU-\n         MVC   USERID2,USERID\n         MVI   SEP2,C':'                                           -EU-\n         ED    MSGCNT2,MSGCOUNT\n         B     ZAPCNT\nLINE3    MVC   MSGCNT3,MASK1                                       -EU-\n         MVC   USERID3,USERID\n         MVI   SEP3,C':'                                           -EU-\n         ED    MSGCNT3,MSGCOUNT\n         CP    TBECNT,=P'0'                                        -EU-\n         BE    *+L'*+18                                            -EU-\n         MVC   OUTSY,=CL10'OUT SYNC :'                             -EU-\n         MVC   OUTSYN,MASK1                                        -EU-\n         ED    OUTSYN,TBECNT                                       -EU-\n        @PPUT  USERLINE                                            -EU-\n         MVC   MSGCNT2,=CL4' '\n         MVC   MSGCNT3,=CL4' '\n         MVC   USERID2,=CL7' '\n         MVC   USERID3,=CL7' '\n         MVI   SEP2,C' '                                           -EU-\n         MVI   SEP3,C' '                                           -EU-\n         MVC   OUTSY(L'OUTSY+L'OUTSYN),OUTSY-1                     -EU-\n         ZAP   TBECNT,=P'0'                                        -EU-\n         ZAP   RECCNT,=P'0'\nZAPCNT   ZAP   MSGCOUNT,=P'0'\nNOMSG    LA    R3,13(R3)                BUMP TO NEXT ENTRY\n         BCT   R6,USRLOOP               REPEAT FOR NINE TIMES\n         FREEDBUF SCNECB,D,BRODCAST\n         CLC   SAVERRN,=3X'00'          IS THIS LAST\n         BNE   INDEXLP                  GO DO NEXT ONE\n         CP    RECCNT,=P'0'\n         BE    PUTUCNT\n         CP    TBECNT,=P'0'                                        -EU-\n         BE    *+L'*+18                                            -EU-\n         MVC   OUTSY,=CL10'OUT SYNC :'                             -EU-\n         MVC   OUTSYN,MASK1                                        -EU-\n         ED    OUTSYN,TBECNT                                       -EU-\n        @PPUT  USERLINE                                            -EU-\nPUTUCNT  MVC   USERCNT,MASK2                                       -EU-\n         ED    USERCNT,USERS            HOW MANY USERS ARE THERE\n        @PPUT  UTOTLINE                                            -EU-\n         LR    R7,R8                    ONCE MORE THRU TYPE TABLE\nVERFLOOP CLI   0(R7),X'99'              END YET?\n         BE    ENDVERF\n         CLI   0(R7),X'03'              IS THIS STILL AN 03\n         LA    R7,1(R7)                 BUMP EITHER WAY\n         BNE   VERFLOOP\n         AP    UNUSABL,=P'1'\n         B     VERFLOOP\n         SPACE 1\nENDVERF  CLOSE (BRODCAST)                                          -EU-\n         TM    SWITCH,TSORUN                                       -EU-\n         BZ    NOTANK              BRANCH IF NOT TSO RUNNING       -EU-\n         L     R2,TANKS                                            -EU-\nNXTANK   LTR   R2,R2                                               -EU-\n         BZ    NOMORE                                              -EU-\n         LA    R3,16(R2)                                           -EU-\nUNTANK  PUT    SYSOUT,(R3)                                         -EU-\n         CL    R3,8(R2)                                            -EU-\n         BNL   *+L'*+8                                             -EU-\n         LA    R3,80(R3)                                           -EU-\n         B     UNTANK                                              -EU-\n         ST    R2,TANKS                                            -EU-\n         L     R2,0(R2)                                            -EU-\n        FREEMAIN E,LV=TKSZ,A=TANKS                                 -EU-\n         B     NXTANK                                              -EU-\nNOMORE   TM    SWITCH,FLUSH                                        -EU-\n         BZ    NOTANK                                              -EU-\n        PUT    SYSOUT,FLUSHMSG                                     -EU-\nNOTANK   MVC   UNUSDCNT,MASK1                                      -EU-\n         ED    UNUSDCNT,UNUSABL+1\n         PUT   SYSOUT,JUNKLINE\n         CLOSE (SYSOUT)                                            -EU-\n         SPACE 1                                                   -EU-\n         TM    SWITCH,SNOPEN                                       -EU-\n         BZ    NOSNCL                                              -EU-\n        CLOSE  (SNAPDCB)                                           -EU-\nNOSNCL  FREEMAIN E,LV=TTLL,A=TYPETABL                              -EU-\nEXIT    $XRET  CC=(R10)                                            -EU-\n         EJECT\nCVDAREA  DC    D'0'\nTYPETABL DC    A(*-*)                                              -EU-\nATIOT    DC    A(*-*)                                              -EU-\nATSO     DC    A(*-*)                                              -EU-\nHIGHVAL  DC    H'0'\nSWITCH   DC    XL1'0'                                              -EU-\nTSORUN   EQU   X'80'                                               -EU-\nFLUSH    EQU   X'40'                                               -EU-\nSNREQ    EQU   X'08'                                               -EU-\nSNOPEN   EQU   X'04'                                               -EU-\nBLOCKNO  DC    X'000000'                BLOCK NUMBERS\nMASK1    DC    X'40202120'                                         -EU-\nMASK2    DC    X'4020204B202120'                                   -EU-\nSAVERRN  DC    CL3' '                   SAVE LOCAL OF USER INDEX\nMSGNUM   DC    CL3' '                   SAVE LOCAL OF USER INDEX\nUSERID   DC    CL7' '\nHEXTAB   DC    CL16'0123456789ABCDEF'                              -EU-\nRECCNT   DC    PL1'0'\nMSGCOUNT DC    PL2'0'\nNOTDIR   DC    PL3'0'\nUSRIND   DC    PL3'0'\nNOTMSG   DC    PL3'0'\nUSRMSG   DC    PL3'0'\nFREEREC  DC    PL3'0'\nUNUSABL  DC    PL3'0'\nUSERS    DC    PL3'0'\nTBECNT   DC    PL2'0'                                              -EU-\nODDKEY   DC    CL79'  ** UNKNOWN KEY TYPE ENCOUNTERED :    **'     -EU-\nBREAKOUT DC    CL79'0< THE FOLLOWING KEY BREAKDOWN WAS FOUND >'\nUSERSOUT DC    CL79'0< THE FOLLOWING USERS HAVE MESSAGES WAITING >'\nKEYCOUNT DS    0CL79\n         DC    CL10' '\nKEYTYPE  DC    CL50'HEADER RECORDS'\nKEYCNT   DC    CL7'      1'\n         DC    (L'KEYCOUNT-(*-KEYCOUNT))C' '                       -EU-\nMAXIMUM  DS    0CL79\n         DC    CL60'1TOTAL AVAILABLE BLOCKS IN DATA-SET'\nMAXCNT   DC    CL7' '\n         DC    (L'MAXIMUM-(*-MAXIMUM))C' '                         -EU-\nNOTICES  DS    0CL79\n         DC    CL63' BLOCKS NECESSARY FOR BROADCAST (DIRECTORY/MESSAGESX\n               )'\nNOTCNT   DC    CL4' '\n         DC    (L'NOTICES-(*-NOTICES))C' '                         -EU-\nUSERLINE DS    0CL79\n         DC    CL10' '\nUSERID1  DC    CL7' '\n         DC    CL3' : '                                            -EU-\nMSGCNT1  DC    CL4' '\n         DC    CL3' '                                              -EU-\nUSERID2  DC    CL7' ',C' '                                         -EU-\nSEP2     DC    C':',C' '                                           -EU-\nMSGCNT2  DC    CL4' '\n         DC    CL3' '                                              -EU-\nUSERID3  DC    CL7' ',C' '                                         -EU-\nSEP3     DC    C':',C' '                                           -EU-\nMSGCNT3  DC    CL4' '\n         DC    CL5' '                                              -EU-\nOUTSY    DC    CL10' '                                             -EU-\nOUTSYN   DC    CL4' '                                              -EU-\n         DC    (L'USERLINE-(*-USERLINE))C' '                       -EU-\nUTOTLINE DS    0CL79\n         DC    CL60' NUMBER OF TSO USERS DEFINED IN DATA-SET'\nUSERCNT  DC    CL7' '\n         DC    (L'UTOTLINE-(*-UTOTLINE))C' '                       -EU-\nJUNKLINE DS    0CL79\n         DC    CL63'0BLOCKS FOUND TO BE GARBAGED'\nUNUSDCNT DC    CL4' '\n         DC    (L'JUNKLINE-(*-JUNKLINE))C' '                       -EU-\nFLUSHMSG DC    CL79'0... LINE(S) FLUSHED ... (TANK SHORTAGE)'      -EU-\n         EJECT\n         LTORG\n         SPACE 1\n         PRINT NOGEN                                               -EU-\nBRODCAST DCB   DDNAME=BRODCAST,BLKSIZE=129,DSORG=DA,MACRF=RISC,        X\n               OPTCD=R,RECFM=F,BUFNO=2,KEYLEN=1,BUFL=130\n         PRINT GEN                                                 -EU-\n         EJECT ,                                                   -EU-\n****************************************************************** -EU-\n*        OUTPUT (SYSOUT) ROUTINE                                 * -EU-\n*              R0      = LINE ADDRESS                            * -EU-\n*              R14     = LINK REGISTER                           * -EU-\n*              R15     = ENTRY ADDRESS                           * -EU-\n****************************************************************** -EU-\n         SPACE 1                                                   -EU-\n         DS    0D                                                  -EU-\n         USING *,R11                                               -EU-\nPPUT     STM   R14,R12,12(R13)     ENTRY                           -EU-\n         LR    R11,R15                                             -EU-\n         LR    R2,R13                                              -EU-\n         LA    R13,SVPPUT                                          -EU-\n         ST    R2,4(R13)                                           -EU-\n         ST    R13,8(R2)                                           -EU-\n         TM    SWITCH,TSORUN                                       -EU-\n         BZ    PPUTIT              BRANCH IF NOT TSO RUNNING       -EU-\n         TM    SWITCH,FLUSH                                        -EU-\n         BO    PPEXIT              BRANCH IF FLUSH SET             -EU-\n         LR    R4,R0                                               -EU-\n         ICM   R2,B'1111',TANKP                                    -EU-\n         BNZ   *+L'*+8                                             -EU-\n         LA    R2,TANKS                                            -EU-\n         B     STANK1                                              -EU-\n         L     R3,8(R2)                                            -EU-\n         LA    R3,80(R3)                                           -EU-\n         CL    R3,4(R2)                                            -EU-\n         BL    STANK3                                              -EU-\nSTANK1  GETMAIN EC,LV=TKSZ,A=(R2)                                  -EU-\n         LTR   R15,R15                                             -EU-\n         BZ    STANK2                                              -EU-\n         OI    SWITCH,FLUSH                                        -EU-\n         B     PPEXIT                                              -EU-\nSTANK2   L     R2,0(R2)                                            -EU-\n         ST    R2,TANKP                                            -EU-\n         XC    0(4,R2),0(R2)                                       -EU-\n         LR    R3,R2                                               -EU-\n         AL    R3,=A(TKL)                                          -EU-\n         ST    R3,4(R2)                                            -EU-\n         LA    R3,16(R2)                                           -EU-\nSTANK3   MVC   0(79,R3),0(R4)                                      -EU-\n         ST    R3,8(R2)                                            -EU-\n         B     PPEXIT                                              -EU-\nPPUTIT  PUT    SYSOUT,(0)                                          -EU-\nPPEXIT   L     R13,4(R13)          EXIT                            -EU-\n         LM    R14,R12,12(R13)                                     -EU-\n         MVI   12(R13),X'FF'                                       -EU-\n         BR    R14                                                 -EU-\n         SPACE 1                                                   -EU-\n         DROP  R11                                                 -EU-\n         SPACE 1                                                   -EU-\nSVPPUT   DC    18F'0'              PPUT SAVE AREA                  -EU-\nTANKS    DC    F'0'                                                -EU-\nTANKP    DC    F'0'                                                -EU-\n         SPACE 1                                                   -EU-\n         PRINT NOGEN                                               -EU-\nSYSOUT   DCB   DDNAME=SYSOUT,DSORG=PS,LRECL=79,MACRF=PM,RECFM=FBA\n         PRINT GEN                                                 -EU-\n         SPACE 1                                                   -EU-\n         LTORG ,                   LITERAL POOL                    -EU-\n         EJECT ,                                                   -EU-\n****************************************************************** -EU-\n*        TRACE ROUTINE (DEBUG AID FACILITY)                      * -EU-\n*              R1      = DECB ADDRESS                            * -EU-\n*              R11     = LOCAL BASE REGISTER                     * -EU-\n*              R12     = MAIN BASE REGISTER                      * -EU-\n*              R13     = NEW SAVE AREA                           * -EU-\n*              R14     = LINK REGISTER                           * -EU-\n*              R15     = ENTRY ADDRESS                           * -EU-\n*              NOTE - THE FOLLOWING ALLOCATION IS NEEDED TO      * -EU-\n*                     OBTAIN THE SNAP DUMPS :                    * -EU-\n*                          ALLOC F(SYSSNAP) SYSOUT(A)            * -EU-\n****************************************************************** -EU-\n         SPACE 1                                                   -EU-\n         DS    0D                                                  -EU-\n         USING *,R11                                               -EU-\nSNAP     STM   R14,R12,12(R13)     ENTRY                           -EU-\n         LR    R11,R15                                             -EU-\n         LR    R2,R13                                              -EU-\n         LA    R13,SVSNAP                                          -EU-\n         ST    R2,4(R13)                                           -EU-\n         ST    R13,8(R2)                                           -EU-\n         L     R15,12(R1)          START OF SNAP                   -EU-\n         ST    R15,SNAPLST                                         -EU-\n         AL    R15,=F'130'         LENGTH                          -EU-\n         ST    R15,SNAPLST+4       END OF SNAP                     -EU-\n         OI    SNAPLST+4,X'80'                                     -EU-\n         LA    R3,SNAPDCB                                          -EU-\n         USING IHADCB,R3                                           -EU-\n         TM    SWITCH,SNOPEN       SNAP ALREADY OPENED?            -EU-\n         BO    SNS                 YES                             -EU-\n        OPEN   (SNAPDCB,OUTPUT)                                    -EU-\n         TM    DCBOFLGS,DCBOFOPN   OPENED?                         -EU-\n         BO    SNO                 YES                             -EU-\n         LA    R15,32              SET OPEN ERROR                  -EU-\n         B     SNC                                                 -EU-\nSNO      OI    SWITCH,SNOPEN                                       -EU-\nSNS     SNAP   DCB=(R3),ID=1,LIST=SNAPLST,STRHDR=SNAPHD            -EU-\n         LTR   R15,R15             ALL OK?                         -EU-\n         BZ    SNR                 YES                             -EU-\nSNC      NI    SWITCH,255-SNREQ    KILL THE REQUEST                -EU-\n         CVD   R15,DOUBLE                                          -EU-\n         MVC   SNERR+17(3),=XL3'202120'                            -EU-\n         ED    SNERR+16(4),DOUBLE+6                                -EU-\n         ST    R15,DOUBLE                                          -EU-\n         UNPK  SNERR+26(9),DOUBLE(5)                               -EU-\n         NC    SNERR+26(8),=XL8'0F0F0F0F0F0F0F0F'                  -EU-\n         TR    SNERR+26(8),=CL16'0123456789ABCDEF'                 -EU-\n         MVI   SNERR+34,C')'                                       -EU-\n        @PPUT  SNERR                                               -EU-\nSNR      L     R13,4(R13)          EXIT                            -EU-\n         LM    R14,R12,12(R13)                                     -EU-\n         MVI   12(R13),X'FF'                                       -EU-\n         BR    R14                                                 -EU-\n         SPACE 1                                                   -EU-\n         DROP  R3,R11                                              -EU-\n         EJECT ,                                                   -EU-\nDOUBLE   DC    D'0'                                                -EU-\nSVSNAP   DC    18F'0'              SNAP SAVE AREA                  -EU-\n         SPACE 1                                                   -EU-\n         PRINT NOGEN                                               -EU-\nSNAPDCB  DCB   DSORG=PS,RECFM=VBA,MACRF=(W),                       -EU-C\n               BLKSIZE=1632,LRECL=125,                             -EU-C\n               DDNAME=SYSSNAP                                      -EU-\n         PRINT GEN                                                 -EU-\nSNAPLST  DC    2F'0'                                               -EU-\nSNAPHD   DC    A(HDR)                                              -EU-\n         SPACE 1                                                   -EU-\nHDR      DC    AL1(L'HDRT)                                         -EU-\nHDRT     DC    C'B R O A D C A S T -- DUMP OF A BLOCK READ.'       -EU-\nSNERR    DC    CL79'  ---> SNAP RC =     (R15=        )'           -EU-\n         SPACE 1                                                   -EU-\n         LTORG ,                   LITERAL POOL                    -EU-\n         EJECT ,                                                   -EU-\n         PRINT NOGEN                                               -EU-\nTIODSECT DSECT ,                                                   -EU-\n         IEFTIOT1 ,                                                -EU-\n         DCBD  DSORG=PS                                            -EU-\n         PRINT GEN                                                 -EU-\n         SPACE 1\nHEADER   DSECT\n         DS    CL1\nNOTRRN   DS    CL3                      RRN OF FIRST NOTICE RECORD\n         DS    CL1\nUSERRRN  DS    CL3                      RRN OF FIRST INDEX RECORD\n         DS    CL2\nTOTALREC DS    CL2                      NUMBER OF RECORDS IN FILE\nMAXNOT   DS    CL2                      MAXIMUM NUMBER OF NOTICES\n         DS    CL1                      -- REST OF RECORD ---\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CMPRSEQ": {"ttr": 4613, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x882\\x8f\\x00\\x882\\x8f\\x14'\\x04Z\\x04Z\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-11-23T00:00:00", "modifydate": "1988-11-23T14:27:00", "lines": 1114, "newlines": 1114, "modlines": 0, "user": "SYSPAJA"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "CMPRSEQ$": {"ttr": 5123, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x942\\x7f\\x00\\x942\\x7f\\x14#\\x00\\t\\x00\\t\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-23T00:00:00", "modifydate": "1994-11-23T14:23:00", "lines": 9, "newlines": 9, "modlines": 0, "user": "SYSPAJA"}, "text": "//CMPRSEQ  JOB (........),'INSTALL - CMPRSEQ -',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=800K,TIME=1\n/*JOBPARM L=4\n//ASS     EXEC PAJ1AS3,MBR=CMPRSEQ\n//LNK     EXEC PAJILKL\n//SYSIN     DD *\n  ENTRY   CMPRSEQ\n  NAME    CMPRSEQ(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CMPRSEQ@": {"ttr": 5125, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x875/\\x00\\x875/\\x11\"\\x00\\xc8\\x00\\xc8\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-12-18T00:00:00", "modifydate": "1987-12-18T11:22:00", "lines": 200, "newlines": 200, "modlines": 0, "user": "SYSPAJA"}, "text": "1   22/04/87\n                                                      CMPRSEQ   1/4.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *   SEQUENTIAL DATA-SETS COMPARISON   * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  CBT origin : extracted from CBT tape 87 FEB, file 226.\n  ------------\n         Descriptive name : sequential data-sets comparison program.\n         Copyright : none.\n\n  FUNCTION : compare two sequential files and report the differences.\n             Correctly handle missmatched blocks of inconsistant sizes.\n             Module name : CMPRSEQ.\n             Status : release 84, modification level A.\n             Processor : OS/VS assembler.\n             Type : problem program.\n             Dependancies : none.\n             Restrictions : none.\n             Attributes : none.\n             Last change date : APRIL 19, 1984.\n\n  AUTHOR : DAVID B. COLE. Note my apologies for the lack of commentary.\n           When I first wrote this program, it was a quick-and-dirty\n           one intended to solve only a very specific problem that I\n           was having at the time. Ever since HOWARD GILBERT let this\n           program out into the world, I have been \"intending\" to clean\n           it up. Well, I haven't done that yet (how many years has it\n           been now?), but I do, from time to time, make miscellaneous\n           functional enhancements, and from now on I will at least be\n           documenting those.\n\n              - I have added commentary describing how to use CMPRSEQ.\n              - I am changing the way in which the ignore file is\n                processed. Normally, when a card from the ignore file\n                is matched within a missmatched block, the fact that\n                the ignored card is matched does not terminate the\n                missmatched block. This is still true; however, once\n                the extent of a missmatched block has been determined,\n                then that block is rescanned for ignored matches that\n                are equidistant into the block from one end or the\n                other. if any are found, then the missmatched block\n                is segmented into smaller missmatched blocks.\n              - The SYSPRINT, NEWLIST, and OLDLIST datasets will now\n                support any RECFM, LRECL, and BLKSIZE. Note, for\n                complete messages, the minimum data length should be\n                133 bytes.\n1   22/04/87\n                                                      CMPRSEQ   2/4.\n\n  DESCRIPTION : The CMPRSEQ program compares two sequential card image\n         files and reports precisely the differences between the two.\n         Such differences can consist of insertions, deletions, and\n         replacements (of either equal or unequal sizes).\n         CMPRSEQ accomplishes this by reading the two input files\n         alternately and comparing the card images as it goes along.\n         When it encounters two cards that mismatch, it saves them and\n         continues to read the two files alternately. Each time it\n         reads a card from one file, it compares it to all cards that\n         it has read from the other file since the start of the\n         mismatch. If no match is found, then it saves that card and\n         proceeds to read the next card from the other file. CMPRSEQ\n         continues alternating back and forth in this manner until it\n         has read a card that does match one of the saved cards from\n         the other file. The mismatch then consists of all cards in\n         the two saved stacks that are below the two matching cards.\n         The mismatched cards are dumped out to logging datasets, and\n         then CMPRSEQ proceeds to look for the next mismatched block.\n\n  LIMITATIONS : CMPRSEQ will compare only card image files, i.e.,files\n         having fixed length records that are 80 bytes long.\n         CMPRSEQ will compare only one pair of files per invocation.\n         It will not compare an entire PDS library, although it will\n         compare a JCL selected PDS library member.\n         If an insertion block (for example) contains a card whose\n         duplicate already appears commonly throughout the files being\n         compared (e.g., the \"SPACE 1\" assembler language statement,\n         etc.), then the comparison may become, to a greater or lesser\n         degree, desynchronized due to the inserted card finding a\n         match with a pre-existing copy of that card in the other file.\n         CMPRSEQ provides mechanisms to help deal with sybchronization\n         problems (note, synchronization problems can occur, not just\n         with inserted blocks, but also with deleted blocks and with\n         replaced blocks).\n\n  JCL - EXEC CARD KEYWORD : REGION=\n         CMPRSEQ's memory requirements vary according to the aggregate\n         size of the largest pair of mismatched blocks encountered. If\n         a memory shortage occurs, then CMPRSEQ terminates immediately;\n         consequently, it is best to provide a generous amount of\n         available memory. Usually, REGION=1024K should be enough.\n\n        EXEC CARD KEYWORD : PARM=FULL\n         By default CMPRSEQ will compare two cards only in columns 1\n         through 72, thus ignoring the sequence number field.\n         Specifying PARM=FULL causes CMPRSEQ to examine each card in\n         all 80 columns.\n1   22/04/87\n                                                      CMPRSEQ   3/4.\n\n        DDNAMEs : OLD and NEW\n                  Attributes :\n                   Access method   QSAM\n                   DSORG           PS\n                   RECFM           F or FB\n                   LRECL           80\n                   BLKSIZE         80*N\n                   Defaults        (PS,F,80,80)\n         These DDNAMEs (OLD and NEW) must designate the two files to be\n         compared. Their existance is required. Usually, one file is an\n         updated (newer) version of the other, hence names OLD and NEW.\n\n        DDNAME : SYSPRINT\n                 Attributes :\n                   Access method   QSAM\n                   DSORG           PS\n                   RECFM           UA, VA, VBA, FA, or FBA\n                   LRECL           133 or LARGER\n                   BLKSIZE         133 or LARGER\n                   Defaults        (PS,VBA,137,4096)\n         The SYSPRINT file is optional. If it is available, then it\n         receives a log of all discovered mismatches. For each\n         mismatched block, both the OLD and NEW version of that block\n         is shown.\n\n        DDNAMEs : OLDLIST and NEWLIST\n                  Attributes :\n                   Access method   QSAM\n                   DSORG           PS\n                   RECFM           UA, VA, VBA, FA, or FBA\n                   LRECL           133 or LARGER\n                   BLKSIZE         133 or LARGER\n                   DEFAULTS        (PS,VBA,137,4096)\n         Both OLDLIST and NEWLIST are optional. If one (or both) are\n         available, then a copy of the OLD (or NEW) file is written to\n         it with the locations of all mismatches clearly flagged.\n\n        DDNAME : IGNORE\n                 Attributes :\n                   Access method   QSAM\n                   DSORG           PS\n                   RECFM           F or FB\n                   LRECL           80\n                   BLKSIZE         80*N\n                   Defaults        (PS,F,80,80)\n         The IGNORE file is optional. If it is available, then it is\n         used to help control the possible desynchronization problems\n         discussed earlier. The IGNORE file should contain copies of\n         card images that appear repeatedly throughout the files being\n         compared, and especially appearing in areas affected by\n         insertions and deletions. Copies of these cards, when\n         encountered during a mismatch resolution process, will not be\n         used to resolve the mismatch. By this means the possibility\n         of desynchronization can be reduced.\n1   22/04/87\n                                                      CMPRSEQ   4/4.\n\n        DDNAME : SYNC\n                 Attributes :\n                   Access method   QSAM\n                   DSORG           PS\n                   RECFM           F or FB\n                   LRECL           80\n                   BLKSIZE         80*N\n                   Defaults        (PS,F,80,80)\n         Unfortunately, very large files may have too many commonly\n         reoccuring cards for the IGNORE file to be wholely effective\n         in eliminating desynchronization  problems. If this is the\n         case, then the SYNC file can be provided to force\n         resynchronization at particular points in the files being\n         compared. This file should contain copies of one or more\n         cards each of which appears exactly once in both the OLD and\n         NEW files. The cards in the SYNC file should appear in the\n         same order by which they appear in the OLD and NEW files.\n         They should represent points in the OLD and NEW files at which\n         you wish to force comparison synchronization. Generally, such\n         points will be following those areas where otherwise\n         unrecoverable desynchronization has occured. When CMPRSEQ\n         encounters a resynchronization point (i.e., when it has read a\n         card from one of the comparison files that exactly matches the\n         next card from the SYNC file), it will not read any further\n         from that file until it reads the identical card from the\n         other file. This has the effect of forcing the resolution of\n         a current mismatch (if any) at the resynchronization point.\n         The SYNC file is optional. If it is available, then it must\n         be correctly formed. If it is not (i.e., if it is out of\n         sequence, or if it contains a card that does not appear in\n         both the OLD and NEW files), then the CMPRSEQ run will fail.\n\n  COMPLETION CODES :\n       0 - Processing has completed successfully. No mismatches have\n           been found.\n       4 - Processing has completed successfully. At least one mismatch\n           has been found.\n      12 - Processing has failed. A memory shortage has occured.\n      16 - Processing has aborted. One of the comparison files (DDNAME\n           OLD or NEW) is not available.\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CMPRSMAC": {"ttr": 5129, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x882\\x8f\\x00\\x882\\x8f\\x14'\\t1\\t1\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-11-23T00:00:00", "modifydate": "1988-11-23T14:27:00", "lines": 2353, "newlines": 2353, "modlines": 0, "user": "SYSPAJA"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "CONAN": {"ttr": 6149, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x882o\\x00\\x882o\\x12\"\\x01\\x02\\x01\\x02\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-11-21T00:00:00", "modifydate": "1988-11-21T12:22:00", "lines": 258, "newlines": 258, "modlines": 0, "user": "SYSPAJA"}, "text": "OCAF     TITLE 'OPERATOR CONSOLE ANALYSIS FACILITY.'\nCONAN    START 0\n         SPACE 1\n* FUNCTION :   PROGRAM TO DISPLAY AT SYSTEM CONSOLE USEFULL FUNCTIONS\n* ----------   ANALYSIS FACILITIES (ONLY STARTED TASK RUNNING).\n*\n*              A FUNCTION RECEIVES CONTROL AS FOLLOWS :\n*              R0 : ADDRESS OF TSO FLAG.\n*              R1 ---> PARML  DC  H'...L'PARMT...'\n*                      PARMT  DC  CL70'...EVENTUAL PARM. TEXT...'\n*              R14 : LINK REGISTER.\n*              R15 : FUNCTION ENTRY POINT ADDRESS.\n*\n* AUTHOR :     MOINIL P.A.\n* --------     COMPUTING CENTRE\n*              J.R.C. - ISPRA ESTABLISHMENT\n*              21020 ISPRA (VA), ITALY\n         EJECT\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*        AUTHORITY LEVELS DEFINITIONS.                          *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         SPACE 1\nLV10     EQU   10        AUTHORIZED LEVEL.\n         SPACE 1\n        $MDL@IX\n         SPACE 2\n        $DEFREG\n         EJECT\n        $XENT  BASE=R12,LV=WRKL,TYPE=RENT\n         LR    R10,R13             SET WORK AREAS ADDRESSABILITY.\n         USING WRKDSECT,R10\n         MVC   EXTR(LEXTR),EXTRP\n         XC    ACOMM,ACOMM\n        EXTRACT ACOMM,'S',FIELDS=(COMM,TSO),MF=(E,EXTR)\n         L     R1,ATSO\n         ST    R1,SENDP\n         TM    0(R1),X'80'\n         BZ    NOTTSO              NOT TSO ADDRESS SPACE.\n         XC    REQAUT(REQAUTL),REQAUT\n         MVC   REQAUT+1(3),=AL3(MDL@IX)\n         LA    R1,AUTH\n         ST    R1,REQAUT+4\n        $EACM  REQAUT\n         CLI   AUTH,LV10           AUTHORIZED?\n         BL    NOTALL              NO, NOT AUTHORIZED.\n         B     SETUP\nNOTTSO   L     R1,ACOMM            COMMUNICATION AREA ADDRESS.\n         L     R2,4(R1)            CIB ADDRESS.\n         LA    R2,0(R2)            CLEAR.\n         LTR   R2,R2               CURRENT CIB SET UP?\n         BZ    NOTALL              NO, NOT STARTED TASK.\n         USING CIBDSECT,R2\n         CLI   CIBVERB,CIBSTART    START COMMAND?\n         BE    SETUP               YES, STARTED TASK.\n         DROP  R2\nNOTALL   LA    R15,NTALLM\n         LA    R14,FINISH\n         B     SENDL\nSETUP    MVC   INQRY(LINQRY),INQRYP     AREAS INITIALIZATION.\n         LA    R1,ANSR\n         ST    R1,INQRY\n         LA    R1,L'ANSR\n         STC   R1,INQRY\n         LA    R1,ECBR\n         ST    R1,INQRY+4\n         LA    R1,L'PARMT\n         STH   R1,PARML\n         LA    R15,INITM           SEND STARTING MESSAGES.\n         BAS   R14,SENDL\n         LA    R15,INITH\n         BAS   R14,SENDL\n         SPACE 1\nREQST    XC    ECBR,ECBR\n         MVC   ANSR,BLANKS\n         LA    R15,INQRY\n         BAS   R14,SENDL           ENTER A REQUEST.\n         LTR   R15,R15             TEST TGET RC.\n         BNZ   ERRTG               THERE IS AN ERROR.\n         OC    ANSR,BLANKS\n         LA    R3,ANSR\n         LA    R4,1\n         LA    R5,ANSR+L'ANSR-1\nSCAN     CLI   0(R3),C' '          SEARCH START OF REQUEST FUNCTION.\n         BNE   FOUND\n         BXLE  R3,R4,SCAN\n         B     REPEAT              JUST REPEAT LAST ONE.\nFOUND    LR    R1,R3\n         BXLE  R3,R4,*+L'*+4\n         B     *+L'*+8\n         CLI   0(R3),C' '          SEARCH END OF REQUEST FUNCTION.\n         BNE   FOUND+L'FOUND\n         LR    R2,R3\n         SR    R2,R1\n         CH    R2,=H'8'\n         BH    INVLD\n         MVC   FUNCT(L'FUNCT),BLANKS\n         BCT   R2,*+L'*+6\n         MVC   FUNCT(*-*),0(R1)\n         EX    R2,*-6\n         MVC   PARMT(L'PARMT),BLANKS    SEARCH EVENTUAL PARM.\nLOOP     BXLE  R3,R4,*+L'*+4\n         B     REPEAT              NO PARM.\n         CLI   0(R3),C' '\n         BE    LOOP\n         SR    R5,R3\n         MVC   PARMT(*-*),0(R3)\n         EX    R5,*-6\nREPEAT   L     R2,=A(FUNTB)        SELECT REQUESTED FUNCTION.\n         CLC   0(L'FUNCT,R2),FUNCT\n         BE    GOTO\n         CLC   L'FUNCT(L'ALIAS,R2),FUNCT\n         BE    GOTO\n         LA    R2,L'FUNTB(R2)\n         CLI   0(R2),0\n         BNE   REPEAT+L'REPEAT\n         LA    R15,UNKFM\n         LA    R14,REQST\n         B     SENDL\nINVLD    LA    R15,INVLDM\n         LA    R14,REQST\n         B     SENDL\nGOTO     L     R15,12(R2)          ENTER FUNCTION.\n         LA    R1,PARML\n         L     R0,ATSO\n        CALL   (15)\n         B     REQST\n         SPACE 1\nXEQ      ST    R1,PARMP            LOAD/EXECUTE/DELETE.\n         LR    R0,R2\n        LOAD   EPLOC=(0)\n         LR    R15,R0\n         LA    R1,PARMP\n         L     R0,ATSO\n        CALL   (15)\n         LR    R0,R2\n        DELETE EPLOC=(0)\n         B     REQST\n         SPACE 1\nHELP     L     R15,=A(HELP00)      HELP DISPLAYS.\n         BAS   R14,SENDL\n         L     R15,=A(HELP01)\n         BAS   R14,SENDL\n         L     R15,=A(HELP02)\n         BAS   R14,SENDL\n         L     R15,=A(HELP03)\n         BAS   R14,SENDL\n         L     R15,=A(HELP04)\n         BAS   R14,SENDL\n         L     R15,=A(HELP90)\n         BAS   R14,SENDL\n         L     R15,=A(HELP99)\n         BAS   R14,SENDL\n         B     REQST\n         SPACE 1\nFINISH  $XRET  CC=0,LV=WRKL,TYPE=RENT\n         SPACE 1\nERRTG    MVC   ANSR(22),=CL22'TGET ERROR (R15 : XX).'\n         STC   R15,ANSR+19\n         SRL   R15,4\n         STC   R15,ANSR+18\n         NC    ANSR+18(2),=XL2'0F0F'\n         TR    ANSR+18(2),=CL16'0123456789ABCDEF'\n        TPUT   ANSR,22\n         B     FINISH\n         SPACE 1\nSENDL    LA    R1,SENDP            BUILD PARM. LIST.\n         ST    R15,4(R1)\n         L     R15,=V(SENDRTN)\n         BR    R15                 GO TO DISPLAY THIS LINE.\n         DROP  R10\n         EJECT\nEXTRP   EXTRACT *-*,'S',MF=L       EXTRACT PARM. LIST.\nINQRYP  WTOR   'ENTER FUNCTION :',*-*,*-*,*-*,ROUTCDE=2,DESC=4,MF=L\n        PRINT  NOGEN\nINITM   WTO    '    --- OPERATOR CONSOLE ANALYSIS FACILITY ---',       X\n               ROUTCDE=11,DESC=7,MF=L\nINITH   WTO    '    ENTER H TO OBTAIN COMMANDS SUMMARY',               X\n               ROUTCDE=11,DESC=7,MF=L\nNTALLM  WTO    'YOU ARE NOT ALLOWED TO CALL THIS PROGRAM.',            X\n               ROUTCDE=11,DESC=7,MF=L\nUNKFM   WTO    'UNKNOWN FUNCTION SPECIFIED - REQUEST IGNORED.',        X\n               ROUTCDE=2,DESC=4,MF=L\nINVLDM  WTO    'INVALID FUNCTION SPECIFIED - REQUEST IGNORED.',        X\n               ROUTCDE=2,DESC=4,MF=L\n        PRINT  GEN\n         SPACE 1\nBLANKS   DC    CL72' '\n         SPACE 2\n        LTORG\n         SPACE 2\n*--- END OF BASE REGISTERS ADDRESSING TAKE PLACE AT THIS POINT ---\n         EJECT\n*        -------------------------------------\n*        FUNCTIONS TABLE (NAME,ALIAS,ADDRESS).\n*        -------------------------------------\n         SPACE 1\n         DS    0F\nFUNTB    DS    0CL16\n         DC    CL8'ENQRSV',CL4'R',V(ENQRSV)\n         DC    CL8'ENQCNF',CL4'C',V(ENQCNF)\n         DC    CL8'USERS',CL4'U',A(XEQ)\n         DC    CL8'JOBS',CL4'J',A(XEQ)\n         DC    CL8'HELP',CL4'H',A(HELP)\n         DC    CL8'END',CL4'E',A(FINISH)\n         DC    AL1(0)\n         SPACE 2\n*        --------------------\n*        HELP MESSAGES TABLE.\n*        --------------------\n         SPACE 1\n        PRINT  NOGEN\nHELP00  WTO    'COMMANDS SUMMMARY :',ROUTCDE=2,DESC=4,MF=L\nHELP01  WTO    '  ENQRSV  /R    - DISPLAY RESERVE RESOURCES ENQ''D',   X\n               ROUTCDE=2,DESC=4,MF=L\nHELP02  WTO    '  ENQCNF  /C    - DISPLAY DATA-SETS ENQ''S CONFLICTS', X\n               ROUTCDE=2,DESC=4,MF=L\nHELP03  WTO    '  USERS   /U    - SHOW TSO USERS-ASID/UNIT ADDRESS',   X\n               ROUTCDE=2,DESC=4,MF=L\nHELP04  WTO    '  JOBS    /J    - SHOW EXEC JOBS AND STARTED TASKS',   X\n               ROUTCDE=2,DESC=4,MF=L\nHELP90  WTO    '  HELP    /H    - DISPLAY THIS HELP',                  X\n               ROUTCDE=2,DESC=4,MF=L\nHELP99  WTO    '  END     /E    - TERMINATE',                          X\n               ROUTCDE=2,DESC=4,MF=L\n        PRINT  GEN\n         EJECT\nWRKDSECT DSECT                     WORK AREAS DESCRIPTIONS.\n         SPACE 1\nSVA      DS    18F                 SAVE AREA.\n         SPACE 1\nEXTR    EXTRACT *-*,'S',MF=L       EXTRACT PARM. LIST.\nLEXTR    EQU   *-EXTR\nACOMM    DS    A\nATSO     DS    A\n         SPACE 1\nINQRY   WTOR   'ENTER FUNCTION :',*-*,*-*,*-*,ROUTCDE=2,DESC=4,MF=L\nLINQRY   EQU   *-INQRY\n         SPACE 1\nECBR     DS    F\nSENDP    DS    2F\nANSR     DS    CL72\nPARMP    DS    F\nPARML    DS    H\nPARMT    DS    CL70\nALIAS    DS    0CL4\nFUNCT    DS    CL8\n         SPACE 1\nREQAUT   DC    0F'0',BL1'00000000',AL3(MDL@IX),AL4(*-*)\nAUTH     DC    XL1'0'\nREQAUTL  EQU   *-REQAUT\n         SPACE 1\nWRKL     EQU   (((*-SVA)+7)/8)*8   WORK AREAS LENGTH.\n         SPACE 2\n        PRINT  NOGEN\nCIBDSECT DSECT\nCIB     IEZCIB\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CONAN$": {"ttr": 6154, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x942\\x7f\\x00\\x942\\x7f\\x14#\\x00\\x10\\x00\\x10\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-23T00:00:00", "modifydate": "1994-11-23T14:23:00", "lines": 16, "newlines": 16, "modlines": 0, "user": "SYSPAJA"}, "text": "//CONAN    JOB (........),'INSTALL -C O N A N-',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=1M,TIME=1\n/*JOBPARM L=8\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//* PRE-REQUISITE MODULES INSTALLATION :                              *\n//*                AUTHCTL   USERS     JOBS                           *\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//ASM     EXEC PAJ1AS3,OPT=',RENT',MBR=CONAN\n//ASR     EXEC PAJ1AS3,OPT=',RENT',MBR=ENQRSV\n//ASC     EXEC PAJ1AS3,OPT=',RENT',MBR=ENQCNF\n//ASS     EXEC PAJ1AS3,OPT=',RENT',MBR=SENDRTN\n//LNK     EXEC PAJILKL,OPT=',RENT'\n//SYSIN     DD *\n  ENTRY   CONAN\n  NAME    CONAN(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CONAN@": {"ttr": 6156, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x855O\\x00\\x855O\\x16\\x12\\x00\\x19\\x00\\x19\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-12-20T00:00:00", "modifydate": "1985-12-20T16:12:00", "lines": 25, "newlines": 25, "modlines": 0, "user": "SYSPAJA"}, "text": "1   25/10/85\n                                                      CONAN     1/1.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *      OPERATOR CONSOLE ANALYSIS      * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *          FACILITY PROGRAM.          * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Purpose :    A program to display at system console usefull functions\n  ---------    analysis facilities (only started task running).\n               At entry, type HELP to obtain a summary list of the\n               available commands.\n\n               The system console operator may activate this facility\n               by typing the following START command :\n                     S OCAF\n               where OCAF is the name of the cataloged procedure which\n               contains only an EXEC JCL statement as below :\n                     //OCAF  EXEC  PGM=CONAN\n\n               This module is reenterable, and may be tested in TSO\n               (use the TEST command) by authorized users only.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DAHANDB$": {"ttr": 6158, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x942\\x8f\\x00\\x942\\x8f\\x10)\\x00\\x0e\\x00\\x0e\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-24T00:00:00", "modifydate": "1994-11-24T10:29:00", "lines": 14, "newlines": 14, "modlines": 0, "user": "SYSPAJA"}, "text": "//DAHANDBK JOB (........),'INSTALL - DAHANDBK -',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=1M,TIME=1\n/*JOBPARM L=5\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//* PRE-REQUISITE MODULES INSTALLATION :                              *\n//*                GFDATE                                             *\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//ASS     EXEC PAJ1AS3,MBR=DAHANDBK\n//LNK     EXEC PAJILKL\n//SYSIN     DD *\n  INCLUDE SYSADD(GFDATE)\n  ENTRY   DAHANDBK\n  NAME    DAHANDBK(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DAHANDB@": {"ttr": 6160, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x93\\x04/\\x00\\x93\\x04/\\x15P\\x00F\\x00F\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-02-11T00:00:00", "modifydate": "1993-02-11T15:50:00", "lines": 70, "newlines": 70, "modlines": 0, "user": "SYSPAJA"}, "text": "1   26/01/93\n                                                      DAHANDBK  1/2.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *    DAHANDBK - DATA AREA HANDBOOK    * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Description : This program is designed to generate a DATA AREA\n  ------------- Handbook similar to the MVS Debugging Handbooks.\n         The input is the assembled machine readable listing (result\n         of an assembly of all mapping macros desired to be included\n         in the Handbook).\n\n  JCL :  //STEP  EXEC PGM=DAHANDBK,PARM='L=xx,title information'\n  -----  //INPUT    DD DSN=listing\n         //TITLE    DD SYSOUT=*   title and table of contents\n         //OUTPUT   DD SYSOUT=*   handbook\n\n  PARM : The L=xx parameter is optional and, if coded, must be first.\n  ------ It specifies the number of lines per page (xx must be a two\n         digits number and accepted XX value is from 20 up to 99\n         included). The title consists of up to 45 characters to be\n         used on the title page and on the bottom of each page to\n         identify the contents of the handbook.\n         I.e. : PARM='L=60'\n                PARM='JES3 SP 1.3.1 PUT 8209'\n                PARM='L=60,JES3 SP 1.3.1 PUT 8209'\n         The defaults are : 'L=54,DATA AREA HANDBOOK'\n\n  Processing :\n  ------------\n         1. The table of contents is built from the listing using\n            either the label of the macro for the name or if blank then\n            the macro itself with the first 40 bytes of data is used.\n         2. The mapping of the macro will list all DC's with the first\n            16 bytes of the value. All equates will have the value\n            displayed in hex immediately following the prior DC which\n            is assumed to be the flag byte.\n         3. After the mapping a cross-reference is performed in\n            alpha-numeric order.\n1   26/01/93\n                                                      DAHANDBK  2/2.\n\n  Here follows an execution example :\n  -----------------------------------\n\n         //...      JOB ... your job card ...\n         //AST     EXEC PGM=IEV90,PARM='XREF(SHORT),NODECK,NOOBJECT'\n         //SYSLIB    DD DSN=... your private macros library ...,\n         //             DISP=SHR\n         //          DD DSN=SYS1.MACLIB,DISP=SHR\n         //          DD DSN=SYS1.MODGEN,DISP=SHR\n         //SYSUT1    DD UNIT=VIO,DSN=&&SYSUT1,SPACE=(CYL,(10,5))\n         //SYSPRINT  DD SYSOUT=*\n         //SYSPRINT  DD UNIT=SYSDA,SPACE=(CYL,(1,1)),DSN=&&ASSLIST,\n         //             DCB=(RECFM=FBA,BLKSIZE=1210,LRECL=121),\n         //             DISP=(,PASS,DELETE)\n         //SYSIN     DD *\n                  CVT       DSECT=YES,LIST=YES\n         TIOT     DSECT\n                  IEFTIOT1\n                  END\n         /*\n         //DBK     EXEC PGM=DAHANDBK,COND=(4,LT)\n         //STEPLIB   DD DSN=... link library ...,DISP=SHR\n         //INPUT     DD DSN=&&ASSLIST,DISP=(OLD,DELETE,DELETE)\n         //TITLE     DD SYSOUT=*\n         //OUTPUT    DD SYSOUT=*\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DAHANDBK": {"ttr": 6401, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x93\\x04\\x9f\\x00\\x93\\x04\\x9f\\x17\\x10\\x05O\\x05O\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-02-18T00:00:00", "modifydate": "1993-02-18T17:10:00", "lines": 1359, "newlines": 1359, "modlines": 0, "user": "SYSPAJA"}, "text": "DAHB     TITLE 'DATA AREA HANDBOOK GENERATION PROGRAM - V3.0'\nDAHANDBK START 0\n         SPACE 1\n*---------------------------------------------------------------------*\n* NAME :       DAHANDBK                                               *\n*---------------------------------------------------------------------*\n* DESCRIPTIVE NAME : DATA AREA HANDBOOK GENERATOR                     *\n*---------------------------------------------------------------------*\n* FUNCTION :   THIS PROGRAM IS DESIGNED TO GENERATE A DATA AREA       *\n*              HANDBOOK SIMILIAR TO THE MVS DEBUGGING HANDBOOK.       *\n*              IT DOES THIS BY :                                      *\n*              1) READING THE OUTPUT OF AN ASSEMBLY OF ALL MAPPING    *\n*                 MACROS DESIRED TO BE INCLUDED IN THE HANDBOOK.      *\n*              2) DETERMINING IF IT HAS A MACRO, COMMENT, DATA        *\n*                 EQUATE OR 'CALLED' MACRO.                           *\n*              3) DETERMINE IF THERE IS A LABEL, IF SO THEN THAT IS   *\n*                 USED FOR THE TABLE OF CONTENTS. IF NOT THEN THE     *\n*                 MACRO ITSELF BECOMES THE NAME FOR THE TOC.          *\n*              4) SAVES  OFFSET, SYMBOL AND EQU VALUE.                *\n*                 NOTE : THE EQU VALUE PRINTED IS EDITED FOR ONLY     *\n*                        THE SIGNIFICANT BYTE.                        *\n*              5) AT END OF MACRO DEFINITION - SORT THE SAVED         *\n*                 ENTRIES TO GENERATE A CROSS-REFERENCE USING         *\n*                 A SLICK BUBBLE SORT.                                *\n*---------------------------------------------------------------------*\n* NOTE 1 :     'CALLED' MACROS ARE DETERMINED BY A GENERATED          *\n*              COMMENT IDENTIFYING THEM WITH 'IATY' IN COL 50         *\n*              (THIS IS A JES3 CONVENTION ONLY)                       *\n* NOTE 2 :     ALL CODE IS ASSUMED TO BE PROPERLY ALIGNED             *\n*---------------------------------------------------------------------*\n* PARM :       'L=XX,TITLE'                                           *\n*              WHERE L=XX IS THE PAGE SIZE AND IS OPTIONAL, AND       *\n*              IF SPECIFIED MUST BE FIRST.                            *\n*              ACCEPTED XX VALUE IS FROM 20 UP TO 99 INCLUDED.        *\n*              THE TITLE CONSISTS OF UP TO 45 CHARACTERS TO BE        *\n*              PRINTED ON THE TOP AND BOTTOM OF EVERY PAGE.           *\n*              DEFAULTS : 'L=54,DATA AREA HANDBOOK'                   *\n*---------------------------------------------------------------------*\n* JCL :        EXEC PGM=DAHANDBK,PARM='L=XX,TITLE INFORMATION'        *\n*              INPUT  DD : OUTPUT OF ASSEMBLER                        *\n*              TITLE  DD : GENERATED TABLE OF CONTENTS                *\n*              OUTPUT DD : GENERATED HANDBOOK                         *\n*---------------------------------------------------------------------*\n         EJECT\n*---------------------------------------------------------------------*\n* AUTHOR :     LIONEL DYCK                                            *\n*              ROCKWELL INTERNATIONAL                                 *\n*              P.O. BOX 2515                                          *\n*              SEAL BEACH, CALIF 90740                                *\n*              (213) 594-1125                                         *\n*---------------------------------------------------------------------*\n*              THIS PROGRAM IS A QUICK AND DIRTY ATTEMPT TO REMEDY    *\n*              WHAT IBM DOES NOT SEE AS A PROBLEM. THIS PROGRAM       *\n*              COMES WITH NO GUARENTEE ALTHOUGH THE AUTHOR WILL BE    *\n*              HAPPY TO ACCEPT ANY IMPROVEMENTS THAT YOU MAKE.        *\n*       NOTE : THIS PROGRAM HAS BEEN TESTED WITH THE JES3 1.3.1       *\n*              MACROS ASSEMBLED USING THE ASSEMBLER H.                *\n*---------------------------------------------------------------------*\n         SPACE 1\n*---------------------------------------------------------------------*\n* ORIGIN :     EXTRACTED FROM CBT 92 MAR TAPE,                        *\n*              FILES 437 - SOURCE ASM                                 *\n*                    435 - MACROS ASM                                 *\n*---------------------------------------------------------------------*\n* MODIFIED :   MOINIL P.A.                                            *\n*              COMPUTING CENTRE                                       *\n*              J.R.C. ISPRA ESTABLISHMENT                             *\n*              21020 ISPRA (VA), ITALY                                *\n*---------------------------------------------------------------------*\n* NOTES :   1. ALL CODE RELATIVE TO JES3 IS NOW REMOVED (WE DON'T     *\n*              HAVE IT AT OUR INSTALLATION).                          *\n*           2. MACROS CODING NEEDS NO MORE TO BE PROPERLY ALIGNED.    *\n*---------------------------------------------------------------------*\n* RETURN CODES :                                                      *\n*         0 - OK, NORMAL TERMINATION                                  *\n*         4 - \"GFDATE\" ERROR CODE                                     *\n*         8 - \"GFDATE\" ERROR CODE                                     *\n*        12 - INVALID LENGTH PARM                                     *\n*             (DROP PARM SIZE BACK TO 45 OR LESS CHARACTERS)          *\n*        16 - EXCEEDED 4000 ENTRIES TABLE FOR SYMBOLS                 *\n*             (CHANGE AT LABEL \"NETS\")                                *\n*---------------------------------------------------------------------*\n         EJECT\n        $DEFREG\n*=====================================================================*\n*        GENERAL REGISTERS USE :                                      *\n*        -----------------------                                      *\n*        R0  = WORK REGISTER                                          *\n*        R1  = CALL PARM POINTER / WORK REGISTER                      *\n*        R2  = WORK REGISTER                                          *\n*        R3  = WORK REGISTER                                          *\n*        R4  = INPUT LINE POINTER                                     *\n*        R5  = CURRENT TABLE ENTRY POINTER (BXLE)                     *\n*        R6  = TABLE ENTRY LENGTH (BXLE)                              *\n*        R7  = LAST TABLE ENTRY POINTER (BXLE)                        *\n*        R8  = 1) LINK REGISTER (TO PRINT OUTPUT : DATA AREA)         *\n*              2) COMPARE ENTRY TABLE POINTER (SORT SYMBOLS)          *\n*              3) 2ND COLUMN ENTRY TABLE POINTER (PRINT SYMBOLS)      *\n*        R9  = TABLE ENTRIES COUNTER                                  *\n*        R10 = UNUSED (FREE FOR 3RD BASE REGISTER IF NEEDED)          *\n*        R11 = 1ST BASE REGISTER                                      *\n*        R12 = 2ND BASE REGISTER                                      *\n*        R13 = SAVE AREA POINTER                                      *\n*        R14 = CALL LINK / WORK REGISTER                              *\n*        R15 = CALL ENTRY / WORK REGISTER                             *\n*=====================================================================*\n         EJECT\nNETS     EQU   4000                NUMBER ENTRIES TABLE FOR SYMBOLS\n         SPACE 1\n        $XENT BASE(R11,R12)\n         EJECT\n*=====================================================================*\n*        PROCESS THE PARM : THE PARM CAN CONTAIN ANY COMMENT TO BE\n*        PLACED ON THE TOP AND BOTTOM OF EACH PAGE WITH THE DATE\n         SPACE 1\n         L     R1,0(R1)            LOAD ADDR OF PARM\n         LH    R2,0(R1)            LOAD LENGTH OF PARM\n         LTR   R2,R2               LENGTH OF ZERO\n         BNP   NOPARM              NO, BYPASS MOVE\n         LA    R3,2(R1)\n         CLC   2(2,R1),=CL2'L='    LINES PER PAGE SPECIFIED ?\n         BNE   CKLEN\n         CH    R2,=H'4'\n         BL    NOPARM\n         TM    4(R1),C'0'\n         BNO   BADPARM\n         TM    5(R1),C'0'\n         BNO   BADPARM\n         PACK  LINEPPG,4(2,R1)\n         SH    R2,=H'5'            REDUCE LENGTH FOR TITLE MOVE\n         BNP   NOPARM\n         CLI   6(R1),C','\n         BNE   BADPARM\n         LA    R3,5(R1)\nCKLEN    CH    R2,=H'45'           CHECK MAX LENGTH\n         BH    BADPARM             INVALID LENGTH PARM\n         BCTR  R2,0                SUBTRACT LENGTH BY 1\n         LTR   R2,R2\n         BNP   NOPARM\n         EX    R2,*+L'*+4          EXECUTE THE MOVE\n         B     CKLPPG\n         MVC   PARM(*-*),0(R3)     <<EXECUTED>>\nMVPARM   MVC   0(*-*,R1),PARM      <<EXECUTED>>\nNOPARM   LA    R2,17\n         MVC   PARM(18),=CL18'DATA AREA HANDBOOK'\nCKLPPG   CP    LINEPPG,=PL2'+20'\n         BL    BADPARM             INVALID NUMBER OF LINES PER PAGE\n         EJECT\n*=====================================================================*\n*        INITIALIZATION\n         SPACE 1\n         MVC   BPARM,PARM\n         MVC   TPARM,PARM\n         LA    R1,L'PARM-1\n         SR    R1,R2\n         SRL   R1,1\n         LA    R1,COVPARM(R1)\n         EX    R2,MVPARM\n         SP    LINEPPG,=PL1'+2'    REDUCE BY 2 FOR BOTTOM OF PAGE\n         ZAP   COLWK,LINEPPG\n         CVB   R5,COLWK            CONVERT TO BINARY\n         SH    R5,=H'5'            REDUCE BY 5 LINES\n         ST    R5,COL#             SET COLUMN'S LINES PER PAGE\n         XR    R4,R4\n         M     R4,=A(SYML)         MULTIPLY BY ENTRY LENGTH\n         ST    R5,COL2PD           SET 2ND COLUMN POINTER DISPLACEMENT\n        $GFDATE ,,DATE\n         LTR   R15,R15\n         BNZ   GFDERR              GFDATE ERROR\n         MVC   TLDATE(2),DATE+2\n         MVI   TLDATE+2,C'/'\n         MVC   TLDATE+3(2),DATE\n         MVI   TLDATE+5,C'/'\n         MVC   TLDATE+6(4),DATE+4\n         MVC   DATE,TLDATE\n         MVC   COVDATE,TLDATE\n        OPEN   (MAPIN,,BOOKOUT,OUTPUT,TITLE,OUTPUT)\n         ZAP   COVWK,LINEPPG\n         CVB   R3,COVWK\n         XR    R2,R2\n         LA    R1,3\n         DR    R2,R1\n         AR    R2,R3\n         BCTR  R3,0\n         STM   R2,R3,CV#2\n         LA    R3,2                PRINT TWICE THE COVER PAGE\nPT1     PUT    TITLE,COV1\n         L     R2,CV#1\nPT2     PUT    TITLE,BLANKS\n         BCT   R2,PT2\n        PUT    TITLE,COV2\n         L     R2,CV#2\nPT3     PUT    TITLE,BLANKS\n         BCT   R2,PT3\n        PUT    TITLE,COV3\n         BCT   R3,PT1\n         L     R2,GFTSIZ\n        GETMAIN R,LV=(R2)\n         ST    R1,TABSTA           SAVE TABLE ADDRESS\n         A     R1,TABSIZ\n         L     R2,=A(SYML)         LOAD ENTRY LENGTH\n         ST    R2,TABENT           SAVE\n         SR    R1,R2\n         ST    R1,TABEND           SAVE END OF TABLE ADDRESS\n         USING TBD,R5\n         LM    R5,R7,TABLM         R5-R6-R7 = TABLE POINTERS (BXLE)\n         XC    SYM(SYML),SYM       CLEAR TABLE\n         BXLE  R5,R6,*-6\n         LM    R5,R7,TABLM         LOAD IT\n         XR    R9,R9               R9 = TABLE ENTRIES COUNTER\n         LA    R4,PRVLINE\n         EJECT\n*=====================================================================*\n*        PROCESS INPUT (ASSEMBLY OUTPUT LISTING)\n         SPACE 1\n         USING ASSLNE,R4\nREAD     MVC   PRVLINE(ASSLEN),ASSLNE\n        GET    MAPIN\n         LR    R4,R1               SAVE -> INPUT RECORD\n         TM    ASSSTN+4,C'0'       ANYTHING HERE\n         BO    *+L'*+14            YES\n         CLC   ASSFLG(2),=CL2'+ '  NO, MAY BE A GENERATED COMMENT ?\n         BE    GENED               YES\n         B     READ                NO, KEEP LOOKING\n         CLI   ASSFLG,C'*'         COMMENT ?\n         BE    READ\n         CLI   ASSFLG,C'+'         GENERATED CARD ?\n         BE    GENED               YES\n         CLI   ASSFLG,C' '         POSSIBLE MACRO CARD ?\n         BNE   READ                NO, IGNORE IT\n*--------------------------------- GET MACRO NAME --------------------*\n         BAS   R14,GTPTR           GO GET POINTERS\n         ICM   R1,B'1111',PTROPE\n         BZ    READ                NO MACRO NAME\n         CLC   0(4,R1),=CL4'END '  IS THIS THE END ?\n         BE    EOF                 YES, WE CAN STOP HERE\n         CLC   0(5,R1),=CL5'COPY ' IS THIS A COPY ?\n         BE    READ                YES, IGNORE IS\n         CLC   0(3,R1),=CL3'DS '   IS THIS A DS ?\n         BE    READ                YES, IGNORE IS\n         CLC   0(3,R1),=CL3'DC '   IS THIS A DC ?\n         BE    READ                YES, IGNORE IS\n         CLC   0(4,R1),=CL4'EQU '  IS THIS AN EQU ?\n         BE    READ                YES, IGNORE IS\n         CLC   0(6,R1),=CL6'DSECT ' IS THIS A DSECT CARD ?\n         BE    READ                YES, IGNORE IT\n         CLC   0(6,R1),=CL6'PRINT ' IS THIS A PRINT CARD ?\n         BE    READ                YES, IGNORE IT\n         CLC   0(5,R1),=CL5'PUSH ' IS THIS A PUSH CARD ?\n         BE    READ                YES, IGNORE IT\n         TM    SW1,SWHMC\n         BO    DOSORT\n         USING DLDSECT,R8\nDOIT     MVC   SOFF,BLANKS\n         MVC   TITLEMCL(L'TITLEMAC),BLANKS\n         L     R2,PTROPE           MACRO NAME\n         OI    SW1,SWHMC\n         XR    R1,R1\n         IC    R1,LGHOPE\n         LA    R0,L'TITLEMCO\n         CLR   R1,R0\n         BNH   *+L'*+2\n         LR    R1,R0\n         BCT   R1,*+L'*+6\n         MVC   TITLEMCO(*-*),0(R2) <<EXECUTED>>\n         EX    R1,*-6\n         ICM   R2,B'1111',PTRLAB   LABEL PRESENT ?\n         BZ    MVVL                NO\n         XR    R1,R1\n         IC    R1,LGHLAB\n         LA    R0,L'TITLEMCL\n         CLR   R1,R0\n         BNH   *+L'*+2\n         LR    R1,R0\n         BCT   R1,*+L'*+6\n         MVC   TITLEMCL(*-*),0(R2) <<EXECUTED>>\n         EX    R1,*-6\nMVVL     ICM   R2,B'1111',PTRVAL   ARGUMENT(S) PRESENT ?\n         BZ    NOVL                NO\n         XR    R1,R1\n         IC    R1,LGHVAL\n         LA    R0,L'TITLEMCV\n         CLR   R1,R0\n         BNH   *+L'*+2\n         LR    R1,R0\n         BCT   R1,*+L'*+6\n         MVC   TITLEMCV(*-*),0(R2) <<EXECUTED>>\n         EX    R1,*-6\nNOVL     MVC   TLMAC,TITLEMCO\n         MVC   TLMAC2,BLANKS\n         LA    R1,TLMAC2+L'TLMAC2-1\n         LA    R2,TLMAC+L'TLMAC-1\n         LA    R3,L'TLMAC\nMBLM     CLI   0(R2),C' '\n         BE    MINC\n         MVC   0(1,R1),0(R2)\n         BCTR  R1,0\nMINC     BCTR  R2,0\n         BCT   R3,MBLM\n         LA    R8,OLINE\n         MVC   DLSYM,TLMAC\n         BAS   R14,MVDEF           GO MOVE DEFINITION\n         NOP   0                   NONE, CONTINUE\n         OI    SW1,SWTPG\n         ST    R4,CURPTR           SAVE\n         LA    R4,PRVLINE          CHECK IF PRECEEDED BY A DSECT\n         BAS   R14,GTPTR           GO GET POINTERS\n         ICM   R1,B'1111',PTROPE\n         BZ    *+L'*+10            NO OPERATION NAME\n         CLC   0(6,R1),=CL6'DSECT ' IS THIS A DSECT CARD ?\n         BE    PRVDS               YES\n         L     R4,CURPTR           NO, NONE, RESTORE\n         LA    R3,OLINE\n         BAS   R8,PRTPAGE          GO TO PRINT ON A NEW PAGE\n         B     READ\nPRVDS    LA    R8,ALINE\n         MVC   DLDEF(6),=CL6'DSECT ' SAY DSECT\n         BAS   R14,MVLAB           GO MOVE LABEL IF ANY\n         LTR   R2,R2               ANY LABEL ?\n         BNZ   *+L'*+6             YES\n         MVC   SYM,BLANKS          NO, FORCE DUMMY DSECT\n         MVC   VAL,BLANKS\n         MVC   VAL+1(5),=CL6'DSECT '\n         MVI   VAL,C'-'\n         MVI   VAL+6,C'-'\n         MVC   OFF,ASSLOC+2        MOVE OFFSET OF LABEL\n         MVC   DLSYM,SYM           MOVE TO OUTPUT LINE\n         MVC   TITLENMD,DLSYM\n         LA    R3,DLDEF+5\n         BAS   R14,MVCOM           GO SET COMMENT IF ANY\n         B     DSCMPL              +0 - OK, COMMENT SET\n         LA    R3,ALINE            +4 - \"WLINE\" ALSO SET\n         BAS   R8,PRTPAGE          GO TO PRINT ON A NEW PAGE\n         OI    SW1,SWDPG\n         LA    R3,WLINE\n         BAS   R8,PRTDATA          GO TO PRINT\n         B     DSTERM\nDSCMPL   LA    R3,ALINE\n         BAS   R8,PRTPAGE          GO TO PRINT ON A NEW PAGE\n         OI    SW1,SWDPG\nDSTERM   L     R4,CURPTR           RESTORE\n         LA    R3,OLINE\n         BAS   R8,PRTDATA          GO TO PRINT\n         BAS   R14,INCRSYM         GO ADJUST TABLE\n         B     READ\n*--------------------------------- MACRO GENERATED LINE --------------*\nGENED    CLI   ASSGEN,C'*'         GENERATED COMMENT ?\n         BE    CKGCM               YES\n         BAS   R14,GTPTR           GO GET POINTERS\n         ICM   R1,B'1111',PTROPE   PSEUDO PRESENT ?\n         BZ    READ                NO, SKIP THIS RECORD\n         CLC   0(5,R1),=CL5'PUSH ' IS THIS A PUSH ?\n         BE    READ                YES, SKIP\n         CLC   0(4,R1),=CL4'POP '  IS THIS A POP ?\n         BE    READ                YES, SKIP\n         LA    R8,OLINE\n         CLC   0(4,R1),=CL4'EQU '  IS THIS AN EQUATE ?\n         BE    ISEQU               YES\n         CLC   0(6,R1),=CL6'DSECT ' IS THIS A DSECT ?\n         BE    ISDSECT             YES\n         CLC   0(4,R1),=CL4'ORG '  IS THIS AN ORG ?\n         BE    ISORG               YES\n         CLC   0(3,R1),=CL3'DS '   A DS ?\n         BE    ISDSDC              YES\n         CLC   0(3,R1),=CL3'DC '   A DC ?\n         BE    ISDSDC              YES\n         BAS   R14,MVLAB           GO MOVE LABEL IF ANY\n         LTR   R2,R2               LABEL PRESENT ?\n         BNZ   INST1L              YES\n         ST    R4,CURPTR           SAVE\n         LA    R4,PRVLINE          CHECK PREVIOUS\n         CLI   ASSCNT,C' '         WAS CONTINUATION INDICATED ?\n         BNE   *+L'*+8             YES, THIS IS A COMMENT CONTINUATION\n         L     R4,CURPTR           NO, RESTORE\n         B     INST2L\n*- - - - COMMENT CONTINUATION LINE - - - - - - - - - - - - - - - - - -*\n         L     R4,CURPTR           RESTORE\n         LA    R1,ASSGEN+L'ASSGEN-1\n         CLI   0(R1),C' '          SEARCH END OF COMMENT\n         BNE   *+L'*+4\n         BCT   R1,*-8\n         L     R2,PTROPE           GET START OF COMMENT\n         ST    R2,PTRCOM           SET IT\n         SR    R1,R2\n         LA    R1,1(R1)\n         STC   R1,LGHCOM           SET LENGTH OF COMMENT\n         CLI   LGHCOM,L'DLCOMM\n         BH    MVCM2               NOT IN NORMAL TARGET\nMVCM1    LA    R3,DLCOMM\n         BCT   R1,*+L'*+6\n         MVC   0(*-*,R3),0(R2)     <<EXECUTED>>\n         EX    R1,*-6\n         LA    R3,OLINE\n         BAS   R8,PRTDATA          GO TO PRINT\n         B     READ\nMVCM2    BAS   R15,CMPRSS          TRY TO COMPRESS COMMENT\n         CLI   ZCMPL,L'DLCOMM\n         BH    MVCM3               ALSO NOT IN NORMAL TARGET\n         XR    R1,R1\n         IC    R1,ZCMPL\n         LA    R2,ZCMPR\n         B     MVCM1\nMVCM3    CLI   LGHCOM,L'DLCOMM+6\n         BH    MVCM5               NOT IN ALTERNATE TARGET\n         XR    R1,R1\n         IC    R1,LGHCOM\nMVCM4    LA    R3,DLCOMM-6\n         B     MVCM1+L'MVCM1\nMVCM5    CLI   ZCMPL,L'DLCOMM+6\n         BH    MVCM6               AGAIN NOT IN ALTERNATE TARGET\n         XR    R1,R1\n         IC    R1,ZCMPL\n         LA    R2,ZCMPR\n         B     MVCM4\nMVCM6    XR    R1,R1               WHAT'S THAT ? MOVE IT COMPRESSED\n         IC    R1,ZCMPL\n         LA    R3,DLCOMM+L'DLCOMM-1\n         SR    R3,R1\n         LA    R2,ZCMPR\n         B     MVCM4\n*- - - - INSTRUCTION LINE  - - - - - - - - - - - - - - - - - - - - - -*\nINST1L   MVC   DLSYM,SYM           MOVE TO OUTPUT LINE\n         MVC   OFF,ASSLOC+2        MOVE OFFSET OF LABEL\nINST2L   MVC   DLOFF,ASSLOC+2      MOVE OFFSET TO OUTPUT LINE\n         MVC   SOFF,ASSLOC+2       MOVE OFFSET TO SAVE\n         LA    R3,DLDEF            -> OUTPUT DEFINITION\n         L     R2,PTROPE\n         XR    R1,R1\n         IC    R1,LGHOPE\n         BCT   R1,*+L'*+6\n         MVC   0(*-*,R3),0(R2)     <<EXECUTED>>\n         EX    R1,*-6\n         LA    R3,2(R1,R3)\n         ICM   R2,B'1111',PTRVAL\n         BZ    INST3L              NONE, SKIP\n         XR    R1,R1\n         IC    R1,LGHVAL\n         BCT   R1,*+L'*+6\n         MVC   0(*-*,R3),0(R2)     <<EXECUTED>>\n         EX    R1,*-6\n         LA    R3,2(R1,R3)\nINST3L   LA    R0,DLCOMM+L'DLCOMM-1\n         LA    R1,2+L'ASSOBJ(R3)\n         CLR   R1,R0\n         BNH   INST4L\n         LA    R3,OLINE\n         BAS   R8,PRTDATA          GO TO PRINT\n         LA    R8,OLINE\n         LA    R3,DLDEF-2          -> OUTPUT DEFINITION\n         B     INST4L+L'INST4L\nINST4L   MVI   0(R3),C':'\n         MVC   2(L'ASSOBJ,R3),ASSOBJ\n         LA    R3,2+L'ASSOBJ(R3)\n         CLI   0(R3),C' '\n         BNE   *+L'*+4\n         BCT   R3,*-8\n         LA    R1,2(R3)\n         CLR   R1,R0\n         BH    *+L'*+8\n         MVI   2(R3),C'/'\n         LA    R3,2(R3)\n         BAS   R14,MVCOM           GO SET COMMENT IF ANY\n         B     INCMPL              +0 - OK, COMMENT SET\n         LA    R3,OLINE            +4 - \"WLINE\" ALSO SET\n         BAS   R8,PRTDATA          GO TO PRINT\n         LA    R3,WLINE\n         B     INCMPL+L'INCMPL\nINCMPL   LA    R3,OLINE\n         BAS   R8,PRTDATA          GO TO PRINT\n         BAS   R14,INCRSYM         GO ADJUST TABLE\n         B     READ\n*- - - - EQU LINE - - - - - - - -  - - - - - - - - - - - - - - - - - -*\nISEQU    BAS   R14,MVLAB           GO MOVE LABEL IF ANY\n         LTR   R2,R2               LABEL PRESENT ?\n         BZ    READ                NO, WHAT'S THAT, SKIP\n         MVC   DLSYM,SYM           MOVE TO OUTPUT LINE\n         BAS   R14,MVDEF           GO MOVE DEFINITION\n         B     READ                NONE, WHAT'S THAT, SKIP\n         LA    R3,DLDEF+2(R1)\n         CLC   DLDEF(2),=CL2'* '\n         BNE   NOTSELF\n         MVC   OFF,ASSAD2+1        MOVE OFFSET OF LABEL (= VALUE)\n         MVC   DLOFF,OFF           MOVE OFFSET TO OUTPUT LINE\n         MVC   SOFF,OFF            MOVE OFFSET TO SAVE\n         B     SETEQU\nNOTSELF  MVC   OFF,SOFF\n         OC    VAL,BLANKS          INITIALIZE VAL AS BLANKS\n         CLI   ASSAD1+3,C'A'\n         BL    NOTFEQU\n         MVC   VAL(8),ASSAD1+3\n         MVI   VAL+8,C''''\n         LA    R1,8\n         B     GOTEQU\nNOTFEQU  CLC   ASSAD2-1(2),=CL2' 0' 3 BYTE EQU ?\n         BE    NOT3EQU\n         MVC   VAL(6),ASSAD2-1\n         MVI   VAL+6,C''''\n         LA    R1,6\n         CLI   VAL,C' '            BLANK FOR FIRST ?\n         BNE   GOTEQU              NO\n         OI    VAL,C'0'            YES, MAKE ZERO\n         B     GOTEQU\nNOT3EQU  CLC   ASSAD2+1(2),=CL2'00' HALF WORD EQU ?\n         BE    NOTHEQU\n         MVC   VAL(4),ASSAD2+1\n         MVI   VAL+4,C''''\n         LA    R1,4\n         B     GOTEQU\nNOTHEQU  MVC   VAL(2),ASSAD2+3     ASSUME 1 BYTE EQU\n         MVI   VAL+2,C''''\n         LA    R1,2\nGOTEQU   EX    R1,CMPRVL\n         BE    SETEQU\n         LA    R0,DLCOMM+L'DLCOMM-1\n         LA    R2,4(R1,R3)\n         CLR   R2,R0\n         BNH   CPLEQU\n         LA    R3,OLINE\n         BAS   R8,PRTDATA          GO TO PRINT\n         LA    R8,OLINE\n         LA    R3,DLDEF-2          -> OUTPUT DEFINITION\n         B     CPLEQU+L'CPLEQU\nCPLEQU   MVI   0(R3),C':'\n         MVC   2(2,R3),=CL2'X'''\n         EX    R1,MOVEVL           MOVE EQU VALUE\n         LA    R3,5(R1,R3)\nSETEQU   BAS   R14,MVCOM           GO SET COMMENT IF ANY\n         B     EQCMPL              +0 - OK, COMMENT SET\n         LA    R3,OLINE            +4 - \"WLINE\" ALSO SET\n         BAS   R8,PRTDATA          GO TO PRINT\n         LA    R8,WLINE\n         B     EQCMPL+L'EQCMPL\nEQCMPL   LA    R3,OLINE\n         BAS   R8,PRTDATA          GO TO PRINT\n         BAS   R14,INCRSYM         GO ADJUST TABLE\n         B     READ\nCMPRVL   CLC   DLVAL(*-*),VAL      <<EXECUTED>>\nMOVEVL   MVC   4(*-*,R3),VAL       <<EXECUTED>>\n*- - - - DSECT LINE - - - - - - -  - - - - - - - - - - - - - - - - - -*\nISDSECT  BAS   R14,MVLAB           GO MOVE LABEL IF ANY\n         LTR   R2,R2               LABEL PRESENT ?\n         BNZ   *+L'*+6             YES\n         MVC   SYM,BLANKS          NO, FORCE DUMMY DSECT\n         MVC   DLSYM,SYM           MOVE TO OUTPUT LINE\n         MVC   DLDEF(6),=CL6'DSECT ' SAY DSECT\n         MVC   VAL,BLANKS\n         MVC   VAL+1(5),=CL6'DSECT '\n         MVI   VAL,C'-'\n         MVI   VAL+6,C'-'\n         MVC   OFF,ASSLOC+2        MOVE OFFSET OF LABEL\n         MVC   DLOFF,OFF           MOVE OFFSET TO OUTPUT LINE\n         MVC   SOFF,OFF            MOVE OFFSET TO SAVE\n         MVC   TITLENMD,DLSYM\n         LA    R3,DLDEF+5\n         OI    SW1,SWDSH+SWABL+SWDPG\n         BAS   R14,MVCOM           GO SET COMMENT IF ANY\n         B     IDCMPL              +0 - OK, COMMENT SET\n         LA    R3,OLINE            +4 - \"WLINE\" ALSO SET\n         BAS   R8,PRTDATA          GO TO PRINT\n         LA    R3,WLINE\n         B     IDCMPL+L'IDCMPL\nIDCMPL   LA    R3,OLINE\n         BAS   R8,PRTDATA          GO TO PRINT\n         BAS   R14,INCRSYM         GO ADJUST TABLE\n         B     READ\n*- - - - ORG LINE - - - - - - - -  - - - - - - - - - - - - - - - - - -*\nISORG    MVC   DLDEF(4),=CL4'ORG ' SAY ORG\n         MVC   DLOFF,ASSAD2+1      MOVE OFFSET TO OUTPUT LINE\n         ICM   R2,B'1111',PTRVAL   -> INPUT DEFINITION\n         BZ    ISORGN              NONE, SKIP\n         XR    R1,R1\n         IC    R1,LGHVAL\n         BCT   R1,*+L'*+6\n         MVC   DLDEF+4(*-*),0(R2)  <<EXECUTED>>\n         EX    R1,*-6\nISORGN   OI    SW1,SWDSH\n         LA    R3,OLINE\n         BAS   R8,PRTDATA          GO TO PRINT\n         B     READ\n*- - - - DS-DC LINE - - - - - - -  - - - - - - - - - - - - - - - - - -*\nISDSDC   BAS   R14,MVDEF           GO MOVE DEFINITION\n         B     READ                NONE, WHAT'S THAT, SKIP\n         LA    R3,DLDEF+2(R1)\n         BAS   R14,MVLAB           GO MOVE LABEL IF ANY\n         LTR   R2,R2               LABEL PRESENT ?\n         BZ    *+L'*+12            NO, SKIP\n         MVC   DLSYM,SYM           MOVE TO OUTPUT LINE\n         MVC   OFF,ASSLOC+2        MOVE OFFSET OF LABEL\n         MVC   DLOFF,ASSLOC+2      MOVE OFFSET TO OUTPUT LINE\n         MVC   SOFF,ASSLOC+2       MOVE OFFSET TO SAVE\n         BAS   R14,MVCOM           GO SET COMMENT IF ANY\n         B     ISCMPL              +0 - OK, COMMENT SET\n         LA    R3,OLINE            +4 - \"WLINE\" ALSO SET\n         BAS   R8,PRTDATA          GO TO PRINT\n         LA    R8,WLINE\n         B     ISCMPL+L'ISCMPL\nISCMPL   LA    R3,OLINE\n         BAS   R8,PRTDATA          GO TO PRINT\n         BAS   R14,INCRSYM         GO ADJUST TABLE\n         B     READ\n*- - - - COMMENT LINE - - - - - -  - - - - - - - - - - - - - - - - - -*\nCKGCM    CLI   ASSGEN+1,C' '       PROCESS CONTINUATION IF ANY\n         BNE   READ                NOT FOR ME, IGNORE\n         CLC   ASSGEN+1(50),BLANKS\n         BE    READ                PROBABLY BLANKS, IGNORE\n         CLC   ASSGEN+1(20),BLANKS\n         BNE   READ                NOT FOR ME, IGNORE\n         BAS   R14,GTPTR           GO GET POINTERS\n         LA    R8,OLINE\n         BAS   R14,MVCOMS          GO SET COMMENT IF ANY\n         LA    R3,OLINE\n         BAS   R8,PRTDATA          GO TO PRINT\n         B     READ\n         DROP  R8\n         DROP  R4\n         EJECT\n*=====================================================================*\n*        PRINT CROSS REFERENCE LIST\n         SPACE 1\n*------- SORT THE SYMBOLS TABLE\n         SPACE 1\nEOF      OI    SW2,SWEOF\n         SPACE 1\nDOSORT   NI    SW1,255-SWHMC\n         LTR   R9,R9               ANY TO SORT\n         BNP   OFFCROS             NO, SKIP IT\n        PUT    BOOKOUT,DASHLINE\n         BAS   R8,PRTBOTT          GO TO PRINT BOTTOM\n         LM    R5,R6,TABSTA        -> TABLE\nSORTL1   BCT   R9,*+L'*+4          COUNT OF ENTRIES TO SORT\n         B     ENDSORT\n         LR    R7,R9\n         LA    R8,0(R5,R6)\n         USING TBDBIS,R8\nSORTL2   CLC   SYM,SYMB\n         BL    BUMPIT\n         BH    *+L'*+10\n         CLC   PGE,PGEB\n         BNH   BUMPIT\n         XC    SYM(SYML),SYMB      SWAP\n         XC    SYMB(SYML),SYM      ENTRIES\n         XC    SYM(SYML),SYMB      QUICKLY\nBUMPIT   AR    R8,R6\n         BCT   R7,SORTL2\n         AR    R5,R6\n         B     SORTL1\n         DROP  R8\n         SPACE 1\n*------- PRINT THE SYMBOLS TABLE\n         SPACE 1\nENDSORT  LM    R5,R7,TABLM\n         LR    R8,R5               -> TO FIRST COLUMN\nPSTRT    L     R3,COL#             ENTRIES PER COLUMN VALUE\n         CLR   R5,R7               END OF TABLE ?\n         BH    OFFCROS             YES\n         CLI   SYM,0               NO, NULL ENTRY ?\n         BE    OFFCROS             ALL DONE\n         A     R8,COL2PD           AND POINT TO 2ND COLUMN\n         USING TBDBIS,R8\n         AP    PAGECTR,=PL1'+1'\n         UNPK  PAGE(5),PAGECTR\n         OI    PAGE+4,C'0'\n        PUT    BOOKOUT,TL1\n        PUT    BOOKOUT,TLCR\n        PUT    BOOKOUT,BLANKS\n        PUT    BOOKOUT,CTITLE\n        PUT    BOOKOUT,CTD\nPLOOP    CLR   R5,R7               END OF TABLE ?\n         BH    ENDTBL              YES\n         CLI   SYM,0               NO, NULL ENTRY ?\n         BE    ENDTBL              YES, ALL DONE\n         MVC   COLSYM,SYM\n         MVC   COLOFF,OFF\n         MVC   COLPGE,PGE\n         CLI   VAL,C'-'\n         BNE   *+L'*+10\n         MVC   COLX1(L'VAL),VAL\n         B     NOVALA\n         CLI   VAL,C'A'\n         BL    NOVALA\n         MVC   COLX1,=CL2'X'''\n         MVC   COLVAL,VAL\n         OC    COLOFF,BLANKS       INSURE REAL CHARACTERS\nNOVALA   TM    SW2,SWLCB\n         BO    NOVALB\n         CLR   R8,R7               END OF TABLE ?\n         BH    *+L'*+8             YES\n         CLI   SYMB,0              NO, NULL ENTRY ?\n         BNE   *+L'*+8             NO\n         OI    SW2,SWLCB           YES\n         B     NOVALB\n         MVC   COLSYMB,SYMB\n         MVC   COLOFFB,OFFB\n         MVC   COLPGEB,PGEB\n         CLI   VALB,C'-'\n         BNE   *+L'*+10\n         MVC   COLX1B(L'VALB),VALB\n         B     NOVALB\n         CLI   VALB,C'A'\n         BL    NOVALB\n         MVC   COLX1B,=CL2'X'''\n         MVC   COLVALB,VALB\n         OC    COLOFFB,BLANKS      INSURE REAL CHARACTERS\n         DROP  R8\nNOVALB  PUT    BOOKOUT,OLINE\n         MVC   OLINE,BLANKS        CLEAR OUTPUT LINE\n         AR    R5,R6\n         AR    R8,R6\n         BCT   R3,PLOOP\n         TM    SW2,SWLCB\n         BZ    *+L'*+8\nENDTBL   NI    SW2,255-SWLCB\n         OI    SW2,SWECR\n         MVC   BPAGE1,PAGE\n         MVC   BPAGE2,PAGE\n         MVC   BOTMAC1,TLMAC\n         MVC   BOTMAC2,TLMAC2\n         LTR   R3,R3\n         BNP   DLSTSX\nCKLSTS   PUT   BOOKOUT,BLANKS\n         BCT   R3,CKLSTS\nDLSTSX  PUT    BOOKOUT,BOTTEMTL\n        PUT    BOOKOUT,BOTTEMTO\n         TM    SW2,SWECR\n         BO    OFFCROS\n         LR    R5,R8               -> TO NEXT FIRST COLUMN\n         B     PSTRT\n         SPACE 1\n*------- RESET THE SYMBOLS TABLE (BACK TO THE NEXT)\n         SPACE 1\nOFFCROS  TM    SW2,SWEOF\n         BO    STOPALL\n         NI    SW2,255-SWECR-SWLCB\n         LM    R5,R7,TABLM\n         XC    SYM(SYML),SYM       CLEAR TABLE\n         BXLE  R5,R6,*-6\n         LM    R5,R7,TABLM\n         XR    R9,R9               INITIALIAZE COUNTER\n         B     DOIT\n         EJECT\n*=====================================================================*\n*        R O U T I N E S\n         SPACE 1\n         USING ASSLNE,R4\n         SPACE 1\n*- - - - - - - - - - - - - - - - - GET POINTERS ROUTINE - - - - - - - -\n*              R0-R1-R2-R3 = WORK REGISTERS\n*              R4 = INPUT LINE POINTER\n*              R14 = LINK REGISTER\n*              AT END : POINTERS TO LABEL/OPERATION/VALUE/COMMENT SET\nGTPTR    LA    R0,L'ASSGEN\n         LA    R1,ASSGEN\n         XC    SCANS(SCANL),SCANS\n         CLI   0(R1),C'*'          COMMENT LINE ?\n         BE    GTPTRC1             YES\n         CLI   0(R1),C' '          NO, LABEL PRESENT ?\n         BE    GTPTRO1             NO\n         ST    R1,PTRLAB           YES, SET LABEL START POINTER\n         LR    R3,R1\nGTPTRL1  LA    R1,1(R1)\n         BCT   R0,*+L'*+4\n         B     *+L'*+8\n         CLI   0(R1),C' '\n         BNE   GTPTRL1\n         LR    R2,R1\n         SR    R2,R3\n         STC   R2,LGHLAB           SET LABEL LENGTH\n         LTR   R0,R0\n         BZR   R14\nGTPTRO1  LA    R1,1(R1)            SEARCH NEXT\n         BCT   R0,*+L'*+2\n         BR    R14\n         CLI   0(R1),C' '\n         BE    GTPTRO1\n         ST    R1,PTROPE           SET OPERATION POINTER\n         LR    R3,R1\nGTPTRO2  LA    R1,1(R1)\n         BCT   R0,*+L'*+4\n         B     *+L'*+8\n         CLI   0(R1),C' '\n         BNE   GTPTRO2\n         LR    R2,R1\n         SR    R2,R3\n         STC   R2,LGHOPE           SET OPERATION LENGTH\n         LTR   R0,R0\n         BZR   R14\n         CLC   0(6,R3),=CL6'DSECT ' IS THIS A DSECT ?\n         BE    GTPTRC1             YES\nGTPTRV1  LA    R1,1(R1)            SEARCH NEXT\n         BCT   R0,*+L'*+2\n         BR    R14\n         CLI   0(R1),C' '\n         BE    GTPTRV1\n         ST    R1,PTRVAL           SET VALUE POINTER\n         LR    R3,R1\n         NI    SW2,255-SWQUO\nGTPTRV2  LA    R1,1(R1)\n         BCT   R0,*+L'*+4\n         B     GTPTRV5\n         TM    SW2,SWQUO\n         BO    GTPTRV3\n         CLI   0(R1),C''''         QUOTE ?\n         BNE   GTPTRV4             NO\n         OI    SW2,SWQUO\n         B     GTPTRV2\nGTPTRV3  CLI   0(R1),C''''         QUOTE ?\n         BNE   GTPTRV2             NO\n         NI    SW2,255-SWQUO\n         B     GTPTRV2\nGTPTRV4  CLI   0(R1),C' '\n         BNE   GTPTRV2\nGTPTRV5  LR    R2,R1\n         SR    R2,R3\n         STC   R2,LGHVAL           SET VALUE LENGTH\n         LTR   R0,R0\n         BZR   R14\nGTPTRC1  LA    R1,1(R1)            SEARCH NEXT\n         BCT   R0,*+L'*+2\n         BR    R14\n         CLI   0(R1),C' '\n         BE    GTPTRC1\n         CLI   0(R1),C'-'          COMMENT ALIGNMENT ?\n         BE    GTPTRC1             YES\n         CLI   0(R1),C'.'\n         BE    GTPTRC1             YES\n         CLI   0(R1),C','\n         BE    GTPTRC1             YES\n         ST    R1,PTRCOM           SET COMMENT POINTER\n         LA    R1,ASSGEN+L'ASSGEN-1\n         CLI   0(R1),C' '\n         BNE   *+L'*+6\n         BCTR  R1,0\n         BCT   R0,*-10\n         STC   R0,LGHCOM           SET COMMENT LENGTH\n         BR    R14\n*- - - - - - - - - - - - - - - - - MOVE LABEL ROUTINE - - - - - - - - -\n*              R0-R1 = WORK REGISTERS\n*              R2 = LABEL POINTER (AT EXIT)\n*              R5 = CURRENT ENTRY TABLE POINTER\n*              R14 = LINK REGISTER\n*              AT END : SYMBOL (LABEL) SET IN TABLE\nMVLAB    ICM   R2,B'1111',PTRLAB   LABEL PRESENT ?\n         BZR   R14                 NO\n         MVC   SYM,BLANKS          YES, MOVE LABEL\n         LA    R0,L'SYM\n         XR    R1,R1\n         IC    R1,LGHLAB\n         CLR   R1,R0\n         BNH   *+L'*+2\n         LR    R1,R0               TRUNCATE LABEL\n         BCT   R1,*+L'*+6\n         MVC   SYM(*-*),0(R2)      <<EXECUTED>>\n         EX    R1,*-6\n         BR    R14\n*- - - - - - - - - - - - - - - - - MOVE DEFINITION ROUTINE  - - - - - -\n*              R1 = DEFINITION LENGTH - 1 (AT EXIT + 4)\n*              R2 = DEFINITION POINTER (AT EXIT + 4)\n*              R8 = OUTPUT LINE POINTER\n*              R14 = LINK REGISTER\n*                    RETURN : +0 - NONE\n*                             +4 - DEFINITION SET IN CURRENT LINE\n         USING DLDSECT,R8\nMVDEF    ICM   R2,B'1111',PTRVAL   -> INPUT DEFINITION\n         BZR   R14                 NONE, BACK\n         XR    R1,R1\n         IC    R1,LGHVAL\n         BCT   R1,*+L'*+6\n         MVC   DLDEF(*-*),0(R2)    <<EXECUTED>>\n         EX    R1,*-6\n         B     4(R14)\n*- - - - - - - - - - - - - - - - - MOVE COMMENT ROUTINE - - - - - - - -\n*              R0-R1-R2 = WORK REGISTERS\n*              R3 = CURRENT LINE CHECK POINTER\n*              R8 = OUTPUT LINE POINTER\n*              R14 = LINK REGISTER\n*              R15 = WORK REGISTER\n*                    RETURN : +0 - OK, COMMENT SET IN CURRENT LINE\n*                             +4 - COMMENT SET IN \"WLINE\"\nMVCOM    OC    PTRCOM,PTRCOM\n         BZR   R14                 NONE\n         CLI   0(R3),C' '\n         BNE   *+L'*+4\n         BCT   R3,*-8\n         LA    R3,3(R3)            ADDRESS WHERE SET COMMENT\n         LA    R0,DLCOMM+L'DLCOMM\n         SR    R0,R3\n         STC   R0,LAVSP            LENGTH OF AVAILABLE SPACE\n         CLC   LGHCOM,LAVSP\n         BH    MVCOM5              AVAILABLE SPACE TOO SHORT\n         CLI   LGHCOM,L'DLCOMM\n         BH    MVCOM3              NOT IN NORMAL TARGET\n         XR    R1,R1\n         IC    R1,LGHCOM\n         L     R2,PTRCOM\nMVCOM1   LA    R0,DLCOMM\n         CLR   R3,R0\n         BNL   MVCOM2\n         LR    R3,R0\nMVCOM2   BCT   R1,*+L'*+6\n         MVC   0(*-*,R3),0(R2)     <<EXECUTED>>\n         EX    R1,*-6\n         BR    R14\nMVCOM3   BAS   R15,CMPRSS          TRY TO COMPRESS COMMENT\n         CLI   ZCMPL,L'DLCOMM\n         BH    MVCOM4              ALSO NOT IN NORMAL TARGET\n         XR    R1,R1\n         IC    R1,ZCMPL\n         LA    R2,ZCMPR\n         B     MVCOM1\nMVCOM4   XR    R1,R1\n         IC    R1,LGHCOM\n         L     R2,PTRCOM\n         B     MVCOM2\nMVCOM5   BAS   R15,CMPRSS          TRY TO COMPRESS COMMENT\n         CLC   ZCMPL,LAVSP\n         BH    MVCOM6              AGAIN AVAILABLE SPACE TOO SHORT\n         XR    R1,R1\n         IC    R1,ZCMPL\n         LA    R2,ZCMPR\n         B     MVCOM2\nMVCOM6   MVC   WLINE,BLANKS\n         CLI   LGHCOM,L'DLCOMM\n         BH    MVCOM7              NOT IN NORMAL TARGET\n         XR    R1,R1\n         IC    R1,LGHCOM\n         L     R2,PTRCOM\n         LA    R3,WLINE+(DLCOMM-DLDSECT)\n         B     MVCOM2\nMVCOM7   CLI   ZCMPL,L'DLCOMM\n         BH    MVCOM11             AGAIN NOT IN NORMAL TARGET\n         LA    R3,WLINE+(DLCOMM-DLDSECT)\nMVCOM8   XR    R1,R1\n         IC    R1,ZCMPL\nMVCOM9   LA    R2,ZCMPR\nMVCOM10  BCT   R1,*+L'*+6\n         MVC   0(*-*,R3),0(R2)     <<EXECUTED>>\n         EX    R1,*-6\n         B     4(R14)\nMVCOM11  CLI   LGHCOM,L'DLCOMM+6\n         BH    MVCOM12             NOT IN ALTERNATE TARGET\n         LA    R3,WLINE+(DLCOMM-6-DLDSECT)\n         XR    R1,R1\n         IC    R1,LGHCOM\n         L     R2,PTRCOM\n         B     MVCOM10\nMVCOM12  CLI   ZCMPL,L'DLCOMM+6\n         BH    MVCOM13             AGAIN NOT IN ALTERNATE TARGET\n         LA    R3,WLINE+(DLCOMM-6-DLDSECT)\n         B     MVCOM8\nMVCOM13  XR    R1,R1               WHAT'S THAT ? MOVE IT COMPRESSED\n         IC    R1,ZCMPL\n         LA    R3,WLINE+(DLCOMM+L'DLCOMM-1-DLDSECT)\n         SR    R3,R1\n         B     MVCOM9\n*------------- \"MVCOMS\" : SPECIAL PROCESS FOR GENERATED COMMENT\nMVCOMS   OC    PTRCOM,PTRCOM\n         BZR   R14                 NONE\n         CLI   LGHCOM,L'DLCOMM\n         BH    MVCOMS2             NOT IN NORMAL TARGET\n         XR    R1,R1\n         IC    R1,LGHCOM\n         L     R2,PTRCOM\nMVCOMS1  BCT   R1,*+L'*+6\n         MVC   DLCOMM(*-*),0(R2)   <<EXECUTED>>\n         EX    R1,*-6\n         BR    R14\nMVCOMS2  BAS   R15,CMPRSS          TRY TO COMPRESS COMMENT\n         CLI   ZCMPL,L'DLCOMM\n         BH    MVCOMS3             ALSO NOT IN NORMAL TARGET\n         LA    R2,ZCMPR\n         XR    R1,R1\n         IC    R1,ZCMPL\n         B     MVCOMS1\nMVCOMS3  CLI   ZCMPL,L'DLCOMM+6\n         BH    MVCOMS4             AGAIN NOT IN ALTERNATE TARGET\n         XR    R1,R1\n         IC    R1,ZCMPL\n         LA    R2,ZCMPR\n         BCT   R1,*+L'*+6\n         MVC   DLCOMM-6(*-*),0(R2) <<EXECUTED>>\n         EX    R1,*-6\n         BR    R14\nMVCOMS4  XR    R1,R1               WHAT'S THAT ? MOVE IT COMPRESSED\n         IC    R1,ZCMPL\n         LA    R2,ZCMPR\n         LA    R3,DLCOMM+L'DLCOMM-1\n         SR    R3,R1\n         BCT   R1,*+L'*+6\n         MVC   0(*-*,R3),0(R2)     <<EXECUTED>>\n         EX    R1,*-6\n         BR    R14\n*------------- \"CMPRSS\" : LOCAL COMPRESS SUBROUTINE\nCMPRSS   MVC   ZCMPR,BLANKS        R15 = LOCAL LINK REGISTER\n         MVI   ZCMPL,0             R0-R1-R2 = WORK REGISTERS\n         XR    R0,R0\n         IC    R0,LGHCOM\n         LA    R1,ZCMPR\n         L     R2,PTRCOM\nCMPRSS1  MVC   0(1,R1),0(R2)\n         LA    R1,1(R1)\n         CLI   0(R2),C' '\n         BE    CMPRSS2\n         LA    R2,1(R2)\n         BCT   R0,CMPRSS1\n         B     CMPRSS3\nCMPRSS2  LA    R2,1(R2)\n         BCT   R0,*+L'*+4\n         B     CMPRSS3\n         CLI   0(R2),C' '\n         BE    CMPRSS2\n         B     CMPRSS1\nCMPRSS3  LA    R2,ZCMPR\n         SR    R1,R2\n         STC   R1,ZCMPL\n         BR    R15\n         DROP  R8\n*- - - - - - - - - - - - - - - - - BUMP TABLE ROUTINE - - - - - - - - -\n*              R4-R5-R6 = TABLE POINTERS (BXLE)\n*              R9 = TABLE ENTRIES COUNTER\n*              R14 = LINK REGISTER\n*              AT END : TABLE ENTRY POINTER SET\nINCRSYM  CLI   SYM,0               IS ENTRY USED ?\n         BER   R14                 NO, RE-USE IT\n         MVC   PGE,PAGE            YES, SET CURRENT PAGE\n         LA    R9,1(R9)            THEN INCREMENT COUNTER\n         BXLE  R5,R6,0(R14)        BRANCH IF NEXT ENTRY AVAILABLE\n         B     TBOVFL              NO MORE, END OF TABLE\n*- - - - - - - - - - - - - - - - - PRINT DATA AREA ROUTINE  - - - - - -\n*              R0-R1 = WORK REGISTERS\n*              R3 = LINE DATA AREA POINTER\n*              R8 = LINK REGISTER\n*              R14-R15 = WORK REGISTERS\n*              AT END : LINE PRINTED AND CLEARED\n         USING DLDSECT,R3\nPRTDATA  CLC   DLOFF,BLANKS        <- NORMAL PRINT ENTRY\n         BE    PRTNDSL\n        PUT    BOOKOUT,DASHLINE\nPRTNDSL  TM    SW1,SWABL+SWDSH     END OF PAGE CHECK\n         BZ    *+L'*+16\n         BM    *+L'*+6\n         AP    LINECTR,=PL1'+1'\n         AP    LINECTR,=PL1'+1'\n         AP    LINECTR,=PL1'+1'\n         CP    LINECTR,LINEPPG\n         BL    PRTPUTO\n         TM    SW1,SWABL+SWDSH\n         BZ    *+L'*+16\n         BM    *+L'*+6\n         SP    LINECTR,=PL1'+1'\n         SP    LINECTR,=PL1'+1'\n         SP    LINECTR,=PL1'+1'\n         ST    R8,SVRET\n         BAS   R8,PRTBOTT          GO TO PRINT BOTTOM\n         L     R8,SVRET\nPRTPAGE  ZAP   LINECTR,=PL1'+4'    <- NEW PAGE PRINT ENTRY\n         TM    SW1,SWABL+SWDSH\n         BZ    *+L'*+16\n         BM    *+L'*+6\n         AP    LINECTR,=PL1'+1'\n         AP    LINECTR,=PL1'+1'\n         AP    PAGECTR,=PL1'+1'\n         UNPK  PAGE(5),PAGECTR\n         OI    PAGE+4,C'0'\n        PUT    BOOKOUT,TL1\n        PUT    BOOKOUT,BLANKS\n        PUT    BOOKOUT,BLANKS\n         CLC   DLOFF,BLANKS\n         BE    PRTPUTO\n        PUT    BOOKOUT,DASHLINE\nPRTPUTO  TM    SW1,SWABL\n         BZ    PRTNABL\n        PUT    BOOKOUT,BLANKS\n         NI    SW1,255-SWABL\nPRTNABL  TM    SW1,SWDSH\n         BZ    PRTNDSH\n        PUT    BOOKOUT,BLANKS\n         NI    SW1,255-SWDSH\nPRTNDSH PUT    BOOKOUT,DLLNE\n         MVC   DLLNE,BLANKS        CLEAR OUTPUT LINE\n         TM    SW1,SWTPG\n         BZ    *+L'*+10\n         MVC   TITLEPAG,PAGE\n         B     *+L'*+12\n         TM    SW1,SWDPG\n         BZR   R8\n         MVC   TITLEPGD,PAGE\n         AP    TITLCTR,=PL1'+1'\n         CP    TITLCTR,LINEPPG\n         BNH   PRTNTPT\n        PUT    TITLE,TITLETL\n        PUT    TITLE,BLANKS\n        PUT    TITLE,TITLE1\n        PUT    TITLE,TITLE2\n        PUT    TITLE,BLANKS\n         ZAP   TITLCTR,=PL1'+3'\nPRTNTPT  TM    SW1,SWTPG\n         BZ    PRTNDPT\n        PUT    TITLE,TITLEL\n         NI    SW1,255-SWTPG\n         BR    R8\nPRTNDPT PUT    TITLE,TITLED\n         NI    SW1,255-SWDPG\n         BR    R8\n         DROP  R3\n*------- \"PRTBOTT\" : PRINT BOTTOM OF PAGE (SUBROUTINE)\n*              R0-R1 = WORK REGISTERS\n*              R8 = LINK REGISTER\n*              R14-R15 = WORK REGISTERS\nPRTBOTT  MVC   BOTMAC1,TLMAC\n         MVC   BOTMAC2,TLMAC2\nPRTFILL  AP    LINECTR,=PL1'+1'    FILL PAGE\n         CP    LINECTR,LINEPPG\n         BNL   PRTLAST\n        PUT  BOOKOUT,BLANKS\n         B     PRTFILL\nPRTLAST  MVC   BPAGE1,PAGE         PRINT BOTTOM\n         MVC   BPAGE2,PAGE\n        PUT    BOOKOUT,BOTTEMTL\n        PUT    BOOKOUT,BOTTEMTO\n         BR    R8\n         SPACE 1\n         DROP  R4\n         EJECT\n*=====================================================================*\n*        TERMINATION - EXIT\n         SPACE 1\n         DROP  R5\nSTOPALL CLOSE  (MAPIN,,BOOKOUT)\n         L     R2,GFTSIZ\n         L     R3,TABSTA\n        FREEMAIN R,LV=(R2),A=(R3)\nLEAVE    L     R15,RCBACK\n        $XRET  CC=(R15)\n         SPACE 1\nGFDERR   STC   R15,RCBACK+3        GFDATE RC (4/8)\n         LA    R15,X'F0'(R15)\n         STC   R15,GFDWTO+(8+24)\nGFDWTO  WTO    '-> \"GFDATE\" RETURN CODE 0 (CALL SYSTEM PROGRAMMER)',   1\n               ROUTCDE=11,DESC=7\n         B     LEAVE\nBADPARM  MVI   RCBACK+3,12         INVALID LENGTH PARM\n        WTO    '-> INVALID L=XX, OR TITLE LENGTH ERROR IN PARM.FIELD', 1\n               ROUTCDE=11,DESC=7\n         B     LEAVE\nTBOVFL   MVI   RCBACK+3,16         END OF TABLE (OVERFLOW)\n        WTO    '-> OVERFLOW : EXCEEDED 4000 ENTRIES TABLE FOR SYMBOLS',1\n               ROUTCDE=11,DESC=7\n         B     STOPALL\n         EJECT\n*=====================================================================*\n*        DCB'S - LITERAL POOL\n         SPACE 1\n         PRINT NOGEN\nMAPIN    DCB   DSORG=PS,MACRF=GL,DDNAME=INPUT,EODAD=EOF\nBOOKOUT  DCB   DSORG=PS,MACRF=PM,DDNAME=OUTPUT,LRECL=80,RECFM=FBA\nTITLE    DCB   DSORG=PS,MACRF=PM,DDNAME=TITLE,LRECL=80,RECFM=FBA\n         PRINT GEN\n         SPACE 1\n        LTORG\n         EJECT\n*=====================================================================*\n*        CONSTANTS AND WORK-AREAS\n         SPACE 1\nCOLWK    DC    D'0'\nCOL#     EQU   COLWK,4\nCOL2PD   EQU   COLWK+4,4\nCOVWK    DC    D'0'\nCV#1     EQU   COVWK+4,4\nCV#2     EQU   COVWK,4\n         SPACE 1\nTABLM    DS    0F\nTABSTA   DS    F                   START OF TABLE\nTABENT   DS    F                   ENTRY SIZE\nTABEND   DS    F                   END OF TABLE\nSZTB     EQU   SYML*NETS           SIZE OF TABLE\nTABSIZ   DC    A(SZTB)\nSZGF     EQU   ((SZTB+7)/8)*8      SIZE FOR GET-FREEMAIN\nGFTSIZ   DC    A(SYML*NETS)\n         SPACE 1\nRCBACK   DC    F'0'\nSVRET    DC    F'0'\nCURPTR   DC    F'0'\nSCANS    DS    0F =================---> KEEP TOGETHER\nPTRLAB   DC    F'0'               =\nPTROPE   DC    F'0'               =\nPTRVAL   DC    F'0'               =\nPTRCOM   DC    F'0'               =\nLGHLAB   DC    XL1'0'             =\nLGHOPE   DC    XL1'0'             =\nLGHVAL   DC    XL1'0'             =\nLGHCOM   DC    XL1'0'             =\nSCANL    EQU   *-SCANS ============\nSOFF     DC    CL4' '              SAVE FOR OFFSET\nPAGECTR  DC    PL3'0'\nLINECTR  DC    PL2'+99'\nTITLCTR  DC    PL2'+99'\nLINEPPG  DC    PL2'+54'            LINES PER PAGE\nTLMAC    DC    CL8' '\nTLMAC2   DC    CL8' '\nPAGE     DC    CL5' '\nZCMPR    DC    CL78' '\nZCMPL    DC    XL1'0'\nLAVSP    DC    XL1'0'\n         SPACE 1\nSW1      DC    XL1'0'\nSWHMC    EQU   X'80'               HEAD MACRO PROCESSED (READY)\nSWDSH    EQU   X'40'               DO DASH LINE AFTER\nSWTPG    EQU   X'08'               DO TITLE LINE/PAGE\nSWDPG    EQU   X'04'               DO DSECT LINE/PAGE\nSWABL    EQU   X'02'               ADDITIONAL BLANK LINE\nSW2      DC    XL1'0'\nSWEOF    EQU   X'80'               INPUT EOF DETECTED\nSWECR    EQU   X'40'               END OF CROSS REFERENCE\nSWLCB    EQU   X'20'               END DETECTED ON 2ND COLUMN\nSWQUO    EQU   X'01'               QUOTE PROCESSING USE\n         SPACE 1\nBLANKS   DS    0CL80\n         DC    CL80' '\n         SPACE 1\nOLINE    DS    0CL80\n         DC    CL80' '\n         SPACE 1\n*- - - - - - - - - - - - - - - --> CROSS REF LINE\nCOLSYM   EQU   OLINE+2,8           SYMBOL\nCOLOFF   EQU   OLINE+12,4          OFFSET\nCOLX1    EQU   OLINE+17,2          VALUE\nCOLVAL   EQU   OLINE+19,9\nCOLPGE   EQU   OLINE+30,5          PAGE\nCOLSYMB  EQU   OLINE+45,8          SYMBOL\nCOLOFFB  EQU   OLINE+55,4          OFFSET\nCOLX1B   EQU   OLINE+60,2          VALUE\nCOLVALB  EQU   OLINE+62,9\nCOLPGEB  EQU   OLINE+73,5          PAGE\n         SPACE 1\nDASHLINE DS    0CL80\n         DC    CL2'+',76C'_',CL2' '\n         SPACE 1\nTITLETL  DS    0CL80\n         DC    CL2'1',CL11'CONTENTS :'\nTPARM    DC    CL45' ',CL10' '\nDATE     DC    CL10' ',CL2' '\n         SPACE 1\nTITLE1   DS    0CL80\n         DC    CL2' ',CL56'MACRO'\n         DC    CL14'(DSECT   PAGE)',CL1' '\n         DC    CL5'PAGE',CL2' '\n         SPACE 1\nTITLE2   DS    0CL80\n         DC    CL2'+',70C'_',CL1' '\n         DC    5C'_',CL2' '\n         SPACE 1\nTITLEL   DS    0CL80\n         DC    CL2' '\nTITLEMAC DS    0CL71\nTITLEMCL DC    CL8' ',CL1' '\nTITLEMCO DC    CL8' ',CL1' '\nTITLEMCV DC    CL52' ',CL1' '\nTITLEPAG DC    CL5' ',CL2' '\n         SPACE 1\nTITLED   DS    0CL80\n         DC    CL58' '\nTITLENMD DC    CL8' ',CL1' '\nTITLEPGD DC    CL5' ',CL8' '\n         SPACE 1\nBOTTEMTL DS    0CL80\n         DC    CL2'0'\nBOTMAC1  DC    CL8' ',CL60' '\nBOTMAC2  DC    CL8' ',CL2' '\n         SPACE 1\nBOTTEMTO DS    0CL80\n         DC    CL2' '\nBPAGE1   DC    CL5' ',CL11' '\nBPARM    DC    CL45' ',CL10' '\nBPAGE2   DC    CL5' ',CL2' '\n         SPACE 1\nCTITLE   DS    0CL80\n         DC    CL2' ',CL8'SYMBOL'\n         DC    CL2' ',CL16'OFFSET-VALUE'\n         DC    CL2' ',CL5'PAGE',CL5' '\n         DC    CL5' ',CL8'SYMBOL'\n         DC    CL2' ',CL16'OFFSET-VALUE'\n         DC    CL2' ',CL5'PAGE',CL2' '\n         SPACE 1\nCTD      DS    0CL80               UNDERLINE FOR CTITLE\n         DC    CL2'+',8C'_',CL2' ',16C'_',CL2' ',5C'_',CL5' '\n         DC    CL5' ',8C'_',CL2' ',16C'_',CL2' ',5C'_',CL2' '\n         SPACE 1\nTLCR     DS    0CL80\n         DC    CL2' ',CL78'CROSS REFERENCE'\n         SPACE 1\nTL1      DS    0CL80\n         DC    CL2'1'\nPARM     DC    CL45' ',CL14' ',CL7'DATE :'\nTLDATE   DC    CL10' ',CL2' '\n         SPACE 1\nCOV1     DS    0CL80\n         DC    CL80'1'\n         SPACE 1\nCOV2     DS    0CL80\n         DC    CL5' ',CL15' '\nCOVPARM  DC    CL45' ',CL15' '\n         SPACE 1\nCOV3     DS    0CL80\n         DC    CL5' ',CL29' ',CL7'DATE :'\nCOVDATE  DC    CL10' ',CL29' '\n         SPACE 1\nWLINE    DS    0CL80               WORK LINE FOR COMMENT\n         DC    CL80' '\n         SPACE 1\nALINE    DS    0CL80               ALTERNATE DATA LINE\n         DC    CL80' '\n         SPACE 1\nPRVLINE  DC    CL(ASSLEN)' '       PREVIOUS LINE CONTENTS\n         EJECT\n*=====================================================================*\n*        DATA DESCRIPTIONS (DSECT'S)\n         SPACE 1\nASSLNE   DSECT ,                   INPUT ASSEMBLY LINE POINTERS\n         DS    CL1                      POSITIONS :\nASSLOC   DS    CL6,1C                      2 -   7\nASSOBJ   DS    CL14,1C                     9 -  16\nASSAD1   DS    CL5,1C                     24 -  28\nASSAD2   DS    CL5,1C                     30 -  34\nASSSTN   DS    CL5                        36 -  40\nASSFLG   DS    CL1                        41\nASSGEN   DS    CL71                       42 - 112\nASSCNT   DS    CL1                       113\n         DS    CL8                       114 - 121\nASSLEN   EQU   *-ASSLNE\n         SPACE 1\nDLDSECT  DSECT ,                   OUTPUT DATA-LINE POINTERS\nDLLNE    DS    0CL80               LINE START / LINE LENGTH\n         DS    CL2                         POSITIONS :  1 -  2\nDLOFF    DS    CL4                 OFFSET               3 -  6\n         DS    CL2                                      7 -  8\nDLSYM    DS    CL8                 LABEL                9 - 16\n         DS    CL2                                     17 - 18\nDLDEF    DS    0CL1                DEFINITION\n         DS    CL2                                     19 - 20\nDLVAL    DS    CL9                 EQUATE VALUE        21 - 29\n         DS    CL6                                     30 - 35\nDLCOMM   DS    CL42                COMMENTS            36 - 77\n         DS    CL3                                     78 - 80\n         SPACE 1\nTBD      DSECT\nSYM      DS    CL8\nOFF      DS    CL4\nVAL      DS    CL9\nPGE      DS    CL5\nSYML     EQU   *-SYM\n         SPACE 1\nTBDBIS   DSECT\nSYMB     DS    CL8\nOFFB     DS    CL4\nVALB     DS    CL9\nPGEB     DS    CL5\nSYMLB    EQU   *-SYMB\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DHC": {"ttr": 6916, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x11/\\x00\\x94\\x11/\\x11B\\x04\\xbd\\x04\\xbd\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-04-22T00:00:00", "modifydate": "1994-04-22T11:42:00", "lines": 1213, "newlines": 1213, "modlines": 0, "user": "SYSPAJA"}, "text": "DHC      TITLE '---     H E X / D E C I M A L     CALCULATOR     ---'\nDHC      START 0\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*        DHC TSO COMMAND : HEX/DECIMAL CALCULATOR                     *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n*        OBTAINED AT AFDSC/PENTAGON FROM SHARE MODS TAPE.\n*        ATTRIBUTES : RE-ENTRANT.\n*        CHANGES MADE AT AFDSC/PENTAGON, 13 MAY 81.\n*        USER MACROS REMOVED AND REPLACED WITH EQUIVALENT CODE.\n*        INPUT TRANSLATED TO UPPER CASE.\n*        DESCRIPTION PARAGRAPH ADDED.\n*\n* DESCRIPTION : (SEE TSO HELP FOR DETAILED DESCRIPTION)\n* -------------\n*\n* THIS COMMAND ACCEPTS EQUATIONS AND SUBCOMMANDS. A SEMI-COLON (;) OR\n* A COMMA (,) MAY BE USED TO SEPARATE INPUT EQUATIONS OR SUBCOMMANDS.\n* THE CALCULATOR BEGINS IN DECIMAL MODE. ENTER A LEADING ZERO ON HEX\n* VALUES SO THEY WONT BE INTERPRETED AS A SYMBOLIC NAME. ALL SYMBOLIC\n* NAMES LONGER THAN 8 CHARACTERS ARE TRUNCATED WITHOUT MESSAGE.\n*\n*        /HEX SUBCOMMAND : PUTS THE CALCULATOR IN A MODE WHERE ALL\n*              VALUES ARE ASSUMED TO BE ENTERED IN HEX, EXCEPT THOSE\n*              FOLLOWED BY A PERIOD, WHICH ARE DECIMAL.\n*        /DEC SUBCOMMAND : PUTS THE CALCULATOR IN A MODE WHERE ALL\n*              VALUES ARE ASSUMED TO BE ENTERED IN DECIMAL, EXCEPT\n*              THOSE FOLLOWED BY AN 'H', WHICH ARE HEX.\n*        /LIST SUBCOMMAND : DISPLAY ALL SYMBOLS AND THEIR VALUES.\n*        /SORT SUBCOMMAND : SORT AND THEN DISPLAY ALL SYMBOLS AND\n*              THEIR VALUES.\n*        /DELETE SUBCOMMAND : DELETE ONE OR MORE SYMBOLS AND THEIR\n*              VALUES.\n*        /DISP SUBCOMMAND : DISPLAY ALL EQUATIONS AS PROCESSED.\n*        /NODISP SUBCOMMAND : DISPLAY ONLY THE LAST RESULT UNLESS\n*              THE INPUT ENDS BY A SUBCOMMAND.\n*        /HELP SUBCOMMAND : SHORT HELP.\n*        /END SUBCOMMAND : TERMINATES THE CALCULATOR.\n*\n* SAMPLE INPUT :   /HEX\n* --------------   A=10;B=10\n*                  C=A+B\n*                  /END\n*\n* MODIFIED BY :    MOINIL P.A.\n* -------------    COMPUTING CENTRE\n*                  J.R.C. - ISPRA ESTABLISHMENT\n*                  21020 ISPRA (VA), ITALY\n         EJECT\n        $DEFREG\n         EJECT\n        $XENT  BASE=(R11,R12),LV=TSOLEN,TYPE=RENT\n         LR    R10,R13             SET ADDRESSABILITY\n         USING TSODSECT,R10\n         EJECT\n         XC    EXTR(LEXTR),EXTR\n        EXTRACT ATSO,'S',FIELDS=(TSO),MF=(E,EXTR)\n         L     R1,ATSO\n         TM    0(R1),X'80'\n         BO    OKTSO               OK, TSO ADDRESS SPACE\n        WTO    ' -> ONLY TSO FOREGROUND RUN ALLOWED.',ROUTCDE=11,DESC=7\n         B     TSOQUIT\nOKTSO    XR    R1,R1               SET MY OWN MASK\n         SPM   R1\n         XC    TSTRING(L'TSTRING),TSTRING    PUT FINISHER ON\n         MVC   SYMTBL(8),=CL8'*'\n         LA    R2,SYMTBLI\n         LA    R3,SYMTBLE-SYMTBLI\n         XR    R4,R4\n         LR    R5,R4\n         MVCL  R2,R4\n         MVC   SYMTBLE(4),=XL4'FFFFFFFF'\n         MVC   BLZR(8),=CL8'0'\n         XC    BLZR+8(8),BLZR+8\n         LA    R2,BLKSCR\n         LA    R3,NLSCR*L'BLKSCR+L'TRES+L'CVDNR+L'CVHNR\n         XR    R4,R4\n         LR    R5,R4\n         ICM   R5,B'1000',CAPS+C' '\n         MVCL  R2,R4\n         MVC   DEFDRM(L'DEFDRM),=C'           INVALID; 0 ASSUMED'\n         MVC   DEFOVM(L'DEFOVM),=C'SYMBOL TABLE OVERFLOW;'\n         MVC   DEFOVM1(L'DEFOVM1+L'DELERM),TRES\n         MVC   DELERM1(L'DELERM1),=C'NOT PREVIOUSLY DEFINED - ERROR'\n         MVC   DELMSG(L'DELMSG),=C'         DELETED'\n         MVC   TLUNDM(L'TLUNDM),=C'         UNDEFINED - SET TO 0'\n         MVC   ZRDVM(L'ZRDVM),=C'         = 0; DIVIDE SUPPRESSED'\n         MVI   SWITCH,0\n         XC    SCRSZ(L'SCRSZ+L'SCRLZ),SCRSZ\n        GTSIZE ,                   GET TERMINAL SIZE\n         LTR   R0,R0               IS IT A SCREEN?\n         BZ    TLOOP               IF ZERO, NOT A SCREEN\n         CH    R0,=H'24'           STANDARD NUMBER OF LINES?\n         BL    TLOOP               NO, LESS\n         BE    *+L'*+12            YES\n         CH    R1,=H'80'           STANDARD LINE LENGTH?\n         BL    TLOOP               LESS\n         B     *+L'*+12\n         CH    R1,=H'80'           STANDARD LINE LENGTH?\n         BL    TLOOP               NO, LESS\n         BE    *+L'*+8             YES\n         ST    R0,SCRSZ            SAVE SCREEN SIZE\n         ST    R1,SCRLZ            SAVE LINE SIZE\n         OI    SWITCH,SWSCR        SAY RUNNING ON A VALID SCREEN\n         L     R1,=A(SCRDLEN)\n        GETMAIN R,LV=(1)\n         LR    R8,R1\n         USING SCRDSECT,R8\n         LA    R2,SCRDATA\n         ST    R2,SCRIPTR\n         AL    R2,=A(SCRNL*L'SCRDATA-1)\n         ST    R2,SCRXPTR\n         XC    SCRCOPYL,SCRCOPYL\n         XC    SCRRPLY,SCRRPLY\n         XC    SCRCOPY,SCRCOPY\n         MVI   SCRSTAT,0\n         LA    R2,SCRFULL\n        $FS    CC=W,WCC=(RMDT),SBA=(24,80),MF=(I,(R2))\n        $FS    SBA=(1,1),RA=(1,1,00),MF=I\n        $FS    SBA=(1,1),SF=(PROT),RA=(1,29,-),MF=I\n        $FS    SF=(PROT,INT),TEXT='HEX/DECIMAL CALCULATOR',MF=I\n        $FS    SF=(PROT),RA=(1,80,-),MF=I\n        $FS    SF=(PROT),TEXT='ENTER',MF=I\n        $FS    SF=(PROT,INT),TEXT='===>',MF=I\n        $FS    SF=NORMAL,MF=I\n        $FS    SBA=(4,1),SF=(PROT),MF=I\n        $FS    TEXT='--- MODE =',MF=I\n        $FS    SF=(PROT,INT),MF=I\n        $FS    TEXT=(' ',3),MF=I\n        $FS    SF=(PROT),TEXT='(PF 5/17) --- DISPLAY =',MF=I\n        $FS    SF=(PROT,INT),MF=I\n        $FS    TEXT=(' ',3),MF=I\n        $FS    SF=(PROT),TEXT='(PF 6/18) ---',MF=I\n        $FS    TEXT='----- <FLIP-FLOP> ---',MF=I\n        $FS    SBA=(5,1),SF=(PROT),MF=I\n        $FS    TEXT='--- HELP:1/13 - ',MF=I\n        $FS    TEXT='END:3/15/4/16 - ',MF=I\n        $FS    TEXT='LIST:9/21 - ',MF=I\n        $FS    TEXT='SORT:10/22 - ',MF=I\n        $FS    TEXT='RESHOW:12/24/PA2 ---',MF=I\n        $FS    SBA=(6,1),SF=(PROT,INT),RA=(6,72,6D),MF=I\n        $FS    TEXT=('________',8),MF=I\n        $FS    SF=(PROT),MF=I\n         LA    R2,SCRDATA\n         LA    R3,SCRNL\n         MVI   0(R2),C' '\n         MVC   1(L'SCRDATA-1,R2),0(R2)\n         LA    R2,L'SCRDATA(R2)\n         BCT   R3,*-14\n        STFSMODE ON,INITIAL=YES    TURN ON VTAM FULL SCREEN MODE\n         OC    SCRSZ(L'SCRSZ+L'SCRLZ),SCRSZ  SCREEN SIZE TO BE SET?\n         BZ    TLOOP               NO\n        STSIZE SIZE=80,LINE=24     SET STANDARD SCREEN SIZE\nTLOOP    TM    SWITCH,SWSCR+NODISP FULL SCREEN OR NO DISPLAY?\n         BZ    *+L'*+6             NO, SAY ENTER ...\n         XR    R0,R0               YES, JUST READ A LINE\n         B     *+L'*+8\n         LA    R1,MENTER\n         LA    R0,L'MENTER\n         BAS   R14,RDLNE           SEND A MESSAGE AND READ A LINE\nTLNEW    XC    PRES(8),PRES        INITIALIZE\n         MVC   TNAME(8),SYMTBL\n         XC    TNAME+8(4),TNAME+8\n         NI    SWITCH,255-EQYET\n         MVI   PROP,C'+'\n         LA    R3,TSTRING\n         ST    R3,TLSTART          SAVE START\n         LTR   R1,R1               TEST LENGTH\n         BNP   TLO1                DON'T CHANGE OLD INPUT\n         LA    R5,0(R3,R1)\n         BCTR  R5,0\n         CLI   0(R5),C';'          SEE IF LAST IS ;\n         BE    *+L'*+8             IF SO, DO NOT INSERT\n         MVI   1(R5),C';'          PUT A ; ON THE END\n         LA    R5,1(R5)            POINT TO NEXT\n         MVI   1(R5),0             AND A ZERO AFTER THAT\nTLO1     CLI   0(R3),C' '          LOOK FOR NON-BLANK\n         BNE   *+L'*+8\n         LA    R3,1(R3)\n         B     TLO1\n         CLI   0(R3),0             SEE IF AT END\n         BE    TLOOP               IF DO, GET MORE\n         TM    SWITCH,EQYET        SEE IF DONE SOMETHING YET\n         BO    TLO2                IF SO, NO CHECK FOR COMMANDS\n         CLC   0(L'CLIST,R3),CLIST SEE IF ASKING FOR A LIST\n         BE    LIST                IF SO, GIVE I TO HIM\n         CLC   0(L'CDEC,R3),CDEC   SEE IF MODE TO BE DEC\n         BE    SETMODED            IF SO, SET THE MODE\n         CLC   0(L'CHEX,R3),CHEX   SAME FOR HEX MODE\n         BE    SETMODEH\n         CLC   0(L'CDELETE,R3),CDELETE  SEE IF TRYING TO DELETE\n         BE    DELETE\n         CLC   0(L'CDISP,R3),CDISP SEE IF SET DISPLAY MODE\n         BE    YDISP\n         CLC   0(L'CNODISP,R3),CNODISP  SEE IF SET NO DISPLAY MODE\n         BE    NDISP\n         CLC   0(L'CSORT,R3),CSORT SEE IF WANT A SORT\n         BE    SORT\n         CLC   0(L'CHELP,R3),CHELP SEE IF WANT HELP\n         BE    HELP\nTLO2     XR    R2,R2               CLEAR REG 2\n         TRT   0(20,R3),TRTBL      EXECUTE THE TRT TO FIND A STOPPER\n*                                  (1) -> BYTE, (2) = RESULT\n         BZ    TNONE               NO STOPPER FOUND, COMPLAIN\n         LR    R4,R1               PUT WHERE BYTE IS IN R4\n         SR    R4,R3               (4) = # OF BYTES - 1\n         MVI   TRES,C' '           BLANK RESULT\n         MVC   TRES+1(49),TRES\nTLO3     CLI   0(R1),C' '          LOOK AGAIN FOR NON-BLANK\n         BNE   *+L'*+8\n         LA    R1,1(R1)\n         B     TLO3\n         MVC   TRES(1),0(R1)       MOVE STOPPING CHAR\n         LTR   R4,R4               SEE IF NULL CHAR STRING\n         BNZ   TLO6\n         CLI   TRES,C'*'           SEE IF PREV RESULT\n         BE    TLO4                IF SO, SAY SO\n         CLI   TRES,C'-'           SEE IF INITIAL\n         BE    TLO5                FORCE A ZERO\n         CLI   TRES,C'+'           LEADING +?\n         BE    TLO5                YES, FORCE A ZERO\n         CLI   TRES,C';'           ONLY A SEMICOLON?\n         BNE   TLMOP               NO... MISSING OPERAND\n         B     TLO5                ELSE FORCE A 0\nTLO4     MVI   TRES+4,C'*'         SAY THIS IS A SYMBOL\n         LA    R1,1(R1)            POINT 1 TO NEXT CHAR\n         LA    R4,1                GIVE REG 4 A NICE VALUE\n         B     TLO3                THEN CONTINUE\nTLO5     MVI   TRES+4,C'0'         IF SO, FORCE A 0\n         B     TLO7\nTNONE    LA    R1,TNMESS           NO STOPPERS FOUND - COMPLAIN\n         LA    R0,L'TNMESS\n         BAS   R14,SDMSG           SEND A MESSAGE\n         B     TLOOP\nTLO6     BCT   R4,*+L'*+6          CHOP R4 DOWN\n         MVC   TRES+4(*-*),0(R3)   << EXECUTED >>\n         EX    R4,*-6              MOVE WITH EXECUTE\nTLO7     LA    R3,1(R1)            POINT R3 PAST CHAR\n         CLI   TRES,C'='           SEE IF STORE RESULT\n         BE    TLEQ\n         OI    SWITCH,EQYET        DO NOT ALLOW ANY MORE =\n         TRT   0(1,R1),TRTBL       SEE IF OPERAND STOPPED THE SCAN\n         BZ    TLNOP               IF NOT, ERROR\n         LA    R1,TRES+4           IF YES, FIND WHAT THING IS\n         LA    R2,SYMTBL           START AT BEGINNING\n         BAS   R14,DEFSYM\n         LTR   R1,R1               SEE IF DEFINED\n         BP    TLOK\n         MVC   TLUNDM(8),TRES+4    COMPLAIN ABOUT UNDEFINED\n         LA    R1,TLUNDM\n         LA    R0,L'TLUNDM\n         BAS   R14,RDLNE           SEND A MESSAGE AND READ A LINE\n         LTR   R1,R1\n         BP    TLNEW\n         LA    R2,BLZR             FAKE A NUMBER\nTLOK     CLI   PROP,C'+'           SEE IF +\n         BE    TLPL\n         CLI   PROP,C'-'\n         BE    TLMIN\n         CLI   PROP,C'*'\n         BE    TLMULT\n         CLI   PROP,C'/'\n         BNE   TLNOP\n         L     R7,8(R2)            GET DIVISOR\n         LTR   R7,R7               SEE IF ZERO\n         BE    ZRDV                IF SO, COMPLAIN\n         CH    R7,=H'-1'           SEE IF DIVIDING BY -1\n         BE    DVM1                IF SO, DO A SUBTRACT\n         L     R6,PRES+4           GET PREV RESULT\n         SRDA  R6,32               PROPAGATE SIGN\n         D     R6,8(R2)            DIVIDE BY THIS\n         ST    R7,PRES+4           STORE RESULT\n         B     NXTSYM              GO TO NEXT\nDVM1     XR    R7,R7               DIVIDE BY -1\n         S     R7,PRES+4           INSTEAD, SUBTRACT\n         ST    R7,PRES+4\n         B     NXTSYM              THEN CONTINUE\nZRDV     MVC   ZRDVM(8),TRES+4     ZERO DIVIDE COMPLAINT\n         LA    R1,ZRDVM\n         LA    R0,L'ZRDVM\n         BAS   R14,RDLNE           SEND A MESSAGE AND READ A LINE\n         LTR   R1,R1\n         BP    TLNEW\n         B     NXTSYM\nTLNOP    LA    R1,TLMOCM           MISSING OPERATOR COMPLAINT\n         LA    R0,L'TLMOCM\n         BAS   R14,RDLNE           SEND A MESSAGE AND READ A LINE\n         OI    SWITCH,EQYET        SET = OCCURED BIT\n         LTR   R1,R1\n         BP    TLNEW\n         MVI   PROP,C'+'\n         BCTR  R3,0\n         B     TLO1\nTLMOP    LA    R3,1(R1)            MISSING OPERAND COMPLAINT\n         LA    R1,TLMMOP\n         LA    R0,L'TLMMOP\n         BAS   R14,RDLNE           SEND A MESSAGE AND READ A LINE\n         OI    SWITCH,EQYET        SET = OCCURED BIT\n         LTR   R1,R1\n         BP    TLNEW\n         B     NXTSYM\nTLMULT   L     R7,PRES+4           DO MULTIPLY\n         M     R6,8(R2)            DO IT\n         ST    R7,PRES+4\n         B     NXTSYM\nTLPL     MVC   PRES+4(4),8(R2)     IF PREV WAS PLUS, SET\n         B     NXTSYM\nTLMIN    XR    R6,R6               IF -, STORE -\n         S     R6,8(R2)\n         ST    R6,PRES+4\n         B     NXTSYM\nTLEQ     TM    SWITCH,EQYET        FOUND AN =; SEE IF PREVIOUS\n         BO    DUPEQ\n         OI    SWITCH,EQYET        SET BIT\n         MVC   TNAME(8),TRES+4\n         ST    R4,TNAME+8\n         B     TLO1\nDUPEQ    LA    R1,DUMTOM           COMPLAIN OF MORE THAN 1\n         LA    R0,L'DUMTOM\n         BAS   R14,RDLNE           SEND A MESSAGE AND READ A LINE\n         LTR   R1,R1               SEE IF ANYTHING ENTERED\n         BP    TLNEW               IF SO, RESTART\n         B     TLO1                ELSE, CONTINUE\nNXTSYM   CLI   TRES,C';'           SEE IF END\n         BE    NXTSYM1             IF SO, DO NOT REPLACE OP\n         MVC   PROP(1),TRES        NOW SEE IF ADD TO BIG TERM\n         CLI   TRES,C'*'           IS NEXT OP * OR /\n         BE    TLO1                IF SO, JUST CONTINUE\n         CLI   TRES,C'/'\n         BE    TLO1\nNXTSYM1  L     R6,PRES             IF NOT, ADD TO BIG TOTAL\n         A     R6,PRES+4\n         ST    R6,PRES\n         CLI   TRES,C';'           SEE IF END\n         BNE   TLO1                IF NOT, DO MORE\n         L     R1,PRES             GET RESULT\n         TM    SWITCH,EQYET        SEE IF STORING\n         BZ    NOEQ                IF NOT, SKIP LOOKUP\n         LA    R1,TNAME            IF SO, FIND WHERE RESULT GOES\n         L     R4,TNAME+8\n         LA    R2,SYMTBL           START SEARCH AT BEGINNING\n         BAS   R14,DEFSYM          FIND WHERE IT GOES\n         L     R1,PRES             GET TOTAL\n         ST    R1,8(R2)            STORE IT\nNOEQ     ST    R1,SYMTBL+8         STORE AT SYMBOL *\n         BAS   R14,CVD             CONVERT TO DECIMAL\n         MVC   TRES(L'CVDNR+L'CVHNR),CVDNR\n         L     R1,TLSTART\n         LR    R2,R3\n         SR    R2,R1\n         CH    R2,=Y(L'TRES-50)    SEE IF MOVING TOO MUCH\n         BL    *+L'*+14            IF NOT, OK\n         LH    R2,=Y(L'TRES-50)    MOVE MAX\n         BCT   R2,*+L'*+6\n         MVC   TRES+L'BLKSCR(*-*),0(R1) << EXECUTED >>\n         EX    R2,*-6              MOVE THE DESIRED AMOUNT\n         MVI   TRES+L'CVDNR+L'CVHNR,C' '     CLEAR OUT REST OF LINE\n         MVC   TRES+L'CVDNR+L'CVHNR+1(L'BLKSCR-L'CVDNR-L'CVHNR-1),TRES+1\n               L'CVDNR+L'CVHNR\n         TM    SWITCH,NODISP       SEE IF DISPLAY\n         BZ    *+L'*+10            IF YES, DO IT\n         CLI   0(R3),0             IF NO, SEE IF AT END\n         BNE   TLNFNB              IF NOT, SUPPRESS DISPLAY\n         XR    R2,R2               IF YES, DISPLAY ONLY RESULT\n         LA    R1,TRES             PUT IT OUT\n         LA    R0,L'BLKSCR(R2)\n         BAS   R14,SDMSG           SEND A MESSAGE\nTLNFNB   CLI   0(R3),C' '          LOOK FOR NON-BLANK\n         BNE   *+L'*+8\n         LA    R3,1(R3)\n         B     TLNFNB\n         CLI   0(R3),C';'          CHECK FOR NULL STATEMENT\n         BNE   *+L'*+8\nTLNFNB1  LA    R3,1(R3)\n         B     TLNFNB\n         MVI   PROP,C'+'\n         NI    SWITCH,255-EQYET    NUTTIN YET\n         XC    PRES(8),PRES\n         MVC   TNAME(8),SYMTBL\n         XC    TNAME+8(4),TNAME+8\n         ST    R3,TLSTART\n         B     TLO1\nTLFN     CLI   0(R3),C' '          LOOK FOR NON-BLANK\n         BNE   *+L'*+8\n         LA    R3,1(R3)\n         B     TLFN\n         CLI   0(R3),C';'          CHECK FOR NULL STATEMENT\n         BE    TLNFNB1\n         LA    R1,TLMSEP           MISSING SEPARATOR COMPLAINT\n         LA    R0,L'TLMSEP\n         BAS   R14,SDMSG           SEND A MESSAGE\n         B     TLOOP\n         SPACE 1\n*        DELETE : REMOVE SYMBOLS FROM TABLE\n         SPACE 1\nDELETE   LA    R1,L'CDELETE(R3)    POINT 1 PAST KEYWORD\nDEL1     CLI   0(R1),C' '          SCAN FOR NON-BLANK\n         BNE   *+L'*+8\n         LA    R1,1(R1)\n         B     DEL1\n         CLI   0(R1),C';'          SEE IF AT END\n         BNE   DEL3\n         B     TNONE               IF SO, KILL\nDEL2     CLI   0(R1),C' '          SCAN FOR NON-BLANK\n         BNE   *+L'*+8\n         LA    R1,1(R1)\n         B     DEL2\n         CLI   0(R1),C';'          SEE IF AT END\n         BE    TLNFNB              IF SO, QUIT\nDEL3     LA    R3,1(R1)            SET 3 PAST NON-BLANK\n         CLI   0(R3),C' '          SCAN FOR BLANK OR ;\n         BE    DEL4\n         CLI   0(R3),C';'\n         BE    DEL4\n         LA    R3,1(R3)            POINT TO NEXT\n         B     DEL3+L'DEL3         TRY AGAIN\nDEL4     LR    R4,R3\n         SR    R4,R1               PUT LENGTH IN 4\n         BCTR  R4,0                CHANGE TO LENGTH-1\n         CH    R4,=H'8'            SEE IF REG 4 TOO BIG\n         BL    *+L'*+4\n         LA    R4,7                IF SO, SET TO 7\n         MVI   DELERM,C' '         BLANK OUT MESSAGE\n         MVC   DELERM+1(7),DELERM\n         EX    R4,DELMVC           MOVE TO ERROR MESSAGE IN CASE\n         LA    R1,DELERM           POINT 1 NICE\n         LA    R2,SYMTBL+12        START PAST PREV RESULT\n         BAS   R14,DEFSYM          FIND WHERE IT IS\n         CH    R1,=H'1'            SEE IF OLD\n         BNE   DELERR              IF NOT, ERROR\n         MVC   DELMSG(8),DELERM    SAY  DELETED\n         LA    R1,DELMSG\n         LA    R0,L'DELMSG\n         BAS   R14,SDMSG           SEND A MESSAGE\n         MVI   0(R2),0             DELETE SYMBOL\n         LR    R1,R3               CONTINUE\n         B     DEL2\nDELERR   LR    R4,R1               SAVE 1 IN 4\n         LA    R1,DELERM\n         LA    R0,L'BLKSCR\n         BAS   R14,RDLNE           SEND A MESSAGE AND READ A LINE\n         LTR   R4,R4               SEE IF NEW AND JUST DEFINED\n         BNZ   *+L'*+4\n         MVI   0(R2),0             DELETE SYMBOL\n         LTR   R1,R1               SEE IF ANYTHING READ\n         BP    TLNEW\n         LR    R1,R3               CONTINUE\n         B     DEL2\nDELMVC   MVC   DELERM(*-*),0(R1)   << EXECUTED >>\n         SPACE 1\n*        SORT : SORT THE SYMBOLS TABLE\n         SPACE 1\nSORT     LA    R3,L'CSORT(R3)      POINT 3 PAST KEYWORD\n         ST    R3,TLSTART\n         LA    R1,SYMTBL+12        1 -> MAIN FIELD\nSORT1    CLI   0(R1),0             SEE IF MAIN FIELD FREE\n         BE    SORT4               IF SO, IGNORE IT\n         CLI   0(R1),X'FF'         SEE IF AT END\n         BE    LIST0               IF SO, TERMINATE SORT\n         LA    R2,12(R1)           2 -> FIELD TO BE COMPARED\nSORT2    CLI   0(R2),0             SEE IF SECONDARY FIELD FREE\n         BE    SORT3               IF SO, IGNORE IT\n         CLI   0(R2),X'FF'         SEE IF AT END\n         BE    SORT4               IF SO, STOP THIS SCAN\n         CLC   0(8,R1),0(R2)       WANT 1 <= 2\n         BNH   SORT3               IF OK, SKIP EXCHANGE\n         XC    0(12,R2),0(R1)      EXCHANGE\n         XC    0(12,R1),0(R2)\n         XC    0(12,R2),0(R1)\nSORT3    LA    R2,12(R2)           POINT 2 TO NEXT ENTRY\n         B     SORT2               CONTINUE SCAN\nSORT4    LA    R1,12(R1)           IF SO, POINT 1 TO NEXT\n         B     SORT1               THEN CONTINUE\n         SPACE 1\n*        LIST : DISPLAYS SYMBOLS FROM TABLE\n         SPACE 1\nLIST     LA    R3,L'CLIST(R3)      POINT 3 PAST KEYWORD\n         ST    R3,TLSTART\nLIST0    LA    R2,SYMTBL+12        2 -> SYMBOL TABLE\nLIST1    LA    R3,BLKSCR           3 -> BLOCK-SCREEN\n         LA    R4,NLSCR-1          4 = COUNTS\nLIST2    CLI   0(R2),0             SEE IF EMPTY PLACE\n         BNE   *+L'*+8             IF SO, DO NOT DISPLAY\n         LA    R2,12(R2)           POINT 2 TO NEXT\n         B     LIST2               TRY AGAIN\n         CLI   0(R2),X'FF'\n         BE    LIST3\n         MVI   0(R3),C' '          CLEAR OUT A LINE\n         MVC   1(L'BLKSCR-1,R3),0(R3)\n         L     R1,8(R2)            GET THE VALUE\n         STM   R2,R4,LISTSV\n         BAS   R14,CVD             CONVERT TO A STRING\n         LM    R2,R4,LISTSV\n         MVC   0(8,R3),0(R2)       MOVE IN NAME\n         MVI   9(R3),C'='          AN =\n         MVC   11(L'CVDNR+L'CVHNR,R3),CVDNR  AND THE VALUE\n         LA    R3,L'BLKSCR(R3)     SET FOR NEXT\n         LA    R2,12(R2)\n         BCT   R4,LIST2            TIMES PER BLOCK-SCREEN\nLIST3    LA    R4,BLKSCR           FIND HOW MUCH TO DISPLAY\n         SR    R3,R4\n         BZ    LIST4               IF NONE, QUIT\n         LA    R1,BLKSCR           PUT IT OUT\n         LA    R0,0(R3)\n         TM    SWITCH,SWSCR        RUNNING ON A SCREEN?\n         BO    *+L'*+8             YES\n         BAS   R14,RDLNE           SEND A MESSAGE AND READ A LINE\n         B     *+L'*+4\n         BAS   R14,SDMSG           SEND A MESSAGE\n         LTR   R1,R1               SEE IF ANYTHING READ\n         BNP   LIST1               IF NOT, CONTINUE LIST\n         B     TLNEW               IF SO, GO TO PROCESS IT\nLIST4    L     R3,TLSTART\n         B     TLFN\n         SPACE 1\n*        DEC, HEX DISP, NODISP SUBCOMMANDS\n         SPACE 1\nSETMODED NI    SWITCH,255-MODE     SET THE MODE TO DECIMAL\n         LA    R3,L'CDEC(R3)       POINT 3 PAST KEYWORD\n         B     TLFN\nSETMODEH OI    SWITCH,MODE         SET THE MODE TO HEX\n         LA    R3,L'CHEX(R3)       POINT 3 PAST KEYWORD\n         B     TLFN\nYDISP    NI    SWITCH,255-NODISP   DISPLAY ALL ANSWERS\n         LA    R3,L'CDISP(R3)      POINT 3 PAST KEYWORD\n         B     TLFN\nNDISP    OI    SWITCH,NODISP       DISPLAY ONLY LAST ANSWERS\n         LA    R3,L'CNODISP(R3)    POINT 3 PAST KEYWORD\n         B     TLFN\n         SPACE 1\n*        HELP SUBCOMMAND\n         SPACE 1\nHELP     LA    R3,L'CHELP(R3)      POINT 3 PAST KEYWORD\n         ST    R3,TLSTART\n         TM    SWITCH,SWSCR        RUNNING ON A SCREEN?\n         BO    HELP10              YES\n         L     R2,=A(HELPTXT)      2 -> HELP TEXT\nHELP1    XR    R4,R4\n         IC    R4,0(R2)            4 = COUNTS\n         LTR   R4,R4               SEE IF END\n         BZ    HELP20              YES\n         LA    R2,1(R2)            SKIP COUNTS\nHELP2    LR    R1,R2\n         LA    R0,L'BLKSCR         0 -> HOW MUCH TO DISPLAY\n         ALR   R2,R0               SET FOR NEXT\n         BCT   R4,HELP3            TIMES BEFORE READ TEST\n         BAS   R14,RDLNE           SEND A MESSAGE AND READ A LINE\n         LTR   R1,R1               SEE IF ANYTHING READ\n         BNP   HELP1               IF NOT, CONTINUE HELP\n         B     TLNEW               IF SO, GO TO PROCESS IT\nHELP3    BAS   R14,SDMSG           SEND A MESSAGE\n         B     HELP2\nHELP10   LA    R1,SCRDATA\n         CL    R1,SCRIPTR          ANYTHING PENDING?\n         BE    HELP11              NO\n         XR    R0,R0               YES, PUT IT OUT\n         BAS   R14,RDLNE           SEND A MESSAGE AND READ A LINE\n         LTR   R1,R1               SEE IF ANYTHING READ\n         BP    TLNEW               IF SO, GO TO PROCESS IT\nHELP11   L     R2,=A(HELPFTX)      2 -> HELP TEXT\nHELP12   CLI   0(R2),0             SEE IF END\n         BE    HELP13              YES\n         LR    R1,R2               PUT IT OUT\n         LA    R0,L'BLKSCR         0 -> HOW MUCH TO DISPLAY\n         ALR   R2,R0               SET FOR NEXT\n         BAS   R14,SDMSG           SEND A MESSAGE\n         LTR   R1,R1               SEE IF ANYTHING READ\n         BNP   HELP12              IF NOT, CONTINUE HELP\n         B     TLNEW               IF SO, GO TO PROCESS IT\nHELP13   LA    R1,SCRDATA\n         CL    R1,SCRIPTR          ANYTHING PENDING?\n         BE    HELP20              NO\n         XR    R0,R0               YES, PUT IT OUT\n         BAS   R14,RDLNE           SEND A MESSAGE AND READ A LINE\n         LTR   R1,R1               SEE IF ANYTHING READ\n         BP    TLNEW               IF SO, GO TO PROCESS IT\nHELP20   L     R3,TLSTART\n         B     TLFN\n         EJECT\nTSOEXIT  TM    SWITCH,SWSCR        RUNNING ON A VALID SCREEN?\n         BZ    TSOQUIT             NO\n         MVC   SCRFULL(CLEARL),CLEAR    SET CLEAR SEQUENCE\n         OC    SCRSZ(L'SCRSZ+L'SCRLZ),SCRSZ  SCREEN SIZE WAS SET?\n         BZ    TSORESET            NO\n        STSIZE SIZELOC=SCRLZ,LINELOC=SCRSZ   RESTORE ORIGINAL SIZE\n        $FS    CC=EWA,MF=(I,SCRFULL)\nTSORESET LA    R1,SCRFULL          CLEAR SCREEN\n         LA    R0,CLEARL\n         ICM   R1,B'1000',=X'03'   INDICATE FULL SCREEN\n        TPUT   (1),(0),R\n        STFSMODE OFF               TURN OFF FULL SCREEN MODE\n         L     R14,=A(SCRDLEN)\n        FREEMAIN R,A=(R8),LV=(R14)\nTSOQUIT $XRET  CC=0,LV=TSOLEN,TYPE=RENT\n         EJECT\n* SDMSG OR RDLNE ARE CALLED BY :\n*\n*        LA    R1,... MESSAGE TEXT\n*        LA    R0,... MESSAGE SIZE\n*        BAS   R14,SDMSG\n*     OR BAS   R14,RDLNE\n*\n*        ONLY AFTER RDLNE - (1) = NUMBER OF CHARACTERS READ\n         SPACE 1\nRDLNE    OI    SWITCH,RDREQ        SET READ REQUESTED\nSDMSG    ST    R14,SRSR14          SAVE REG 14\n         LTR   R15,R0              LENGTH\n         BNP   SDMSG3              NONE, SKIP\n         TM    SWITCH,SWSCR        RUNNING ON A SCREEN?\n         BO    SDSCR1              YES\n         LR    R14,R1              ADDRESS\nSDMSG1   SH    R15,=Y(L'BLKSCR)    GET LENGTH\n         BNP   SDMSG2              NO, LAST TIME\n         STM   R14,R15,QQSAVE      SAVE THEM\n        TPUT   (R14),L'BLKSCR      PUT IT OUT\n         LM    R14,R15,QQSAVE      GET THEM BACK\n         LA    R14,L'BLKSCR(,R14)  POINT AT NEXT\n         B     SDMSG1              TRY AGAIN\nSDMSG2   AH    R15,=Y(L'BLKSCR)    GET LENGTH BACK\n         LR    R0,R15              GET LENTGH\n        TPUT   (R14),(R0)          PUT IT OUT\nSDMSG3   TM    SWITCH,RDREQ        READ REQUESTED?\n         BO    RDLNE1              YES\n         L     R14,SRSR14          RESTORE REG 14\n         BR    R14\nSDSCR1   L     R15,SCRIPTR         GET DATA LINES POINTER\n         CL    R15,SCRXPTR         DATA LINES FULL FILLED\n         BH    SDSCR3              YES\n         SH    R0,=Y(L'BLKSCR)     GET LENGTH\n         BNP   SDSCR2              NO, LAST TIME\n         MVC   0(L'BLKSCR,R15),0(R1)    MOVE DATA\n         LA    R1,L'BLKSCR(R1)     POINT AT NEXT\n         LA    R15,L'BLKSCR(R15)\n         B     SDSCR1+L'SDSCR1\nSDSCR2   AH    R0,=Y(L'BLKSCR)     GET LENGTH BACK\n         LR    R14,R0\n         BCT   R14,*+L'*+6\n         MVC   0(*-*,R15),0(R1)    <<EXECUTED>>\n         EX    R14,*-6             MOVE LAST DATA\n         LA    R15,L'BLKSCR(R15)\n         ST    R15,SCRIPTR         SAVE DATA LINES POINTER\n         XR    R1,R1               SET AS NO INPUT\n         B     SDMSG3\nSDSCR3   STM   R0,R1,QQSAVE        SAVE THEM\n        $FS    TEXT=('* MORE *',8),MF=(I,SCRNXTT)\n         OI    SCRSTAT,DTCNT       SAY DATA CONTINUE\n         B     RDSCR1              GO DISPLAY THIS SECTION\nSDSCR4   NI    SCRSTAT,255-DTCNT   RESET DATA CONTINUE\n         LTR   R1,R1               SEE IF ANYTHING ENTERED\n         BP    *+L'*+8             IF SO, RESTART\n         LM    R0,R1,QQSAVE        GET THEM BACK\n         B     SDSCR1              CONTINUE\n         NI    SWITCH,255-RDREQ    RESET READ REQUEST (IF ANY)\n         B     RDLNE3              GO PROCESS NEW INPUT\n         EJECT\nRDLNE1   NI    SWITCH,255-RDREQ    RESET READ REQUEST\n         TM    SWITCH,SWSCR        RUNNING ON A SCREEN?\n         BO    RDSCR1              YES\nRDLNE2   XC    READINTO(L'READINTO),READINTO\n         LA    R0,L'READINTO-1\n        TGET   READINTO,(0)        GET INPUT\n         LTR   R15,R15             TEST RETURN CODE\n         BZ    RDLNE3              OK\n        TCLEARQ INPUT              CLEAR OUT INPUT\n         B     RDLNE2              TRY AGAIN\nRDLNE3   TR    READINTO(L'READINTO),CAPS     UPPER CASE\n         CH    R1,=H'3'            IS IT AT LEAST 3 LONG?\n         BL    RDLNE4              NO\n         CLC   READINTO(4),=CL4'/END'   IS IT END?\n         BE    TSOEXIT             YES\nRDLNE4   L     R14,SRSR14          RESTORE REG 14\n         LTR   R15,R1              TEST FOR A LENGTH\n         BNPR  R14                 NONE, FORGET IT\n         XC    TSTRING(L'TSTRING),TSTRING    RESET\n         BCTR  R15,0               SUBTRACT ONE\n         EX    R15,*+L'*+2         DO IT\n         BR    R14                 RETURN TO CALLER\n         MVC   TSTRING(*-*),READINTO    <<EXECUTED>>\n         SPACE 1\nRDSCR1   TM    SWITCH,MODE         COMPLETE SCREEN\n         BO    *+L'*+10\n         MVC   SCRMODE,=CL3'DEC'\n         B     *+L'*+6\n         MVC   SCRMODE,=CL3'HEX'\n         TM    SWITCH,NODISP\n         BO    *+L'*+10\n         MVC   SCRDISP,=CL3'ON '\n         B     *+L'*+6\n         MVC   SCRDISP,=CL3'OFF'\n        $FS    SBA=(1,1),SF=(PT,IC),MF=(I,SCRIADD)\n         LA    R0,SCRLEN+SCRPTICL  SCREEN FORMAT LENGTH\n         TM    SCRSTAT,FIRST       FIRST TPUT DONE?\n         BO    RDSCR2              YES\n         OC    SCRSZ(L'SCRSZ+L'SCRLZ),SCRSZ  SCREEN SIZE TO BE SET?\n         BZ    RDSCR2              NO\n        $FS    CC=EW,MF=(I,SCRFULL)     SET ERASE/WRITE\nRDSCR2   LA    R1,SCRFULL          SCREEN START ADDRESS\n         ICM   R1,B'1000',=X'03'   INDICATE FULL SCREEN\n        TPUT   (1),(0),R\n         TM    SCRSTAT,FIRST       FIRST TPUT DONE?\n         BO    RDSCR3              YES\n         OC    SCRSZ(L'SCRSZ+L'SCRLZ),SCRSZ  SCREEN SIZE TO BE SET?\n         BZ    *+L'*+6             NO\n        $FS    CC=W,MF=(I,SCRFULL) RESTORE WRITE\n         OI    SCRSTAT,FIRST       SAY FIRST TPUT DONE\nRDSCR3   XC    SCRRPLY,SCRRPLY     RESET INPUT BUFFER\n        TGET   SCRRPLY,L'SCRRPLY-1,ASIS\n         LTR   R15,R15             TEST RETURN CODE\n         BZ    RDSCR4              OK\n        TCLEARQ INPUT              CLEAR OUT INPUT\n         B     RDSCR3              TRY AGAIN\nRDSCR4   CLI   SCRPFCD,X'F3'       PF-3 - END\n         BE    TSOEXIT\n         CLI   SCRPFCD,X'C3'       PF-15 (ALT. PF-3)\n         BE    TSOEXIT\n         CLI   SCRPFCD,X'F4'       PF-4 - END\n         BE    TSOEXIT\n         CLI   SCRPFCD,X'C4'       PF-16 (ALT. PF-4)\n         BE    TSOEXIT\n         CLI   SCRPFCD,X'6E'       PA2 (RESHOW)\n         BE    *+L'*+16\n         CLI   SCRPFCD,X'7C'       PF-12\n         BE    *+L'*+8\n         CLI   SCRPFCD,X'4C'       PF-24 (ALT. PF-12)\n         BNE   RDSCR5\n         ICM   R0,B'1111',SCRCOPYL\n         BNZ   *+L'*+8\n         LA    R0,SCRLEN+SCRPTICL  SCREEN FORMAT LENGTH\n         B     RDSCR2\n        $FS   SBA=(2,12),MF=(I,SCRIADD)\n         MVC   SCRINAR,SCRCOPY     RE-DISPLAY SCREEN WITH LAST INPUT\n         LA    R1,SCRINAR\n         ALR   R1,R0\n        $FS    SBA=(1,1),SF=(PT,IC),MF=(I,(R1))\n         LA    R1,SCRLEN++L'SCRIADD+SCRPTICL SCREEN FORMAT LENGTH\n         ALR   R0,R1\n         B     RDSCR2\nRDSCR5   TM    SCRSTAT,DTCNT\n         BO    RDSCR6\n         CLI   SCRPFCD,X'F5'       PF-5 - DEC/HEX\n         BE    *+L'*+8\n         CLI   SCRPFCD,X'C5'       PF-17 (ALT. PF-5)\n         BNE   *+L'*+8\n         XI    SWITCH,MODE         INVERT MODE\n         B     RDSCR1\n         CLI   SCRPFCD,X'F6'       PF-6 - DISP/NODISP\n         BE    *+L'*+8\n         CLI   SCRPFCD,X'C6'       PF-18 (ALT. PF-6)\n         BNE   *+L'*+8\n         XI    SWITCH,NODISP       INVERT DISPLAY\n         B     RDSCR1\nRDSCR6  $FS    TEXT=('________',8),MF=(I,SCRNXTT)\n         LA    R14,SCRDATA         RESET LINES 5-24\n         ST    R14,SCRIPTR\n         LA    R0,SCRNL\n         MVI   0(R14),C' '\n         MVC   1(L'SCRDATA-1,R14),0(R14)\n         LA    R14,L'SCRDATA(R14)\n         BCT   R0,*-14\n         CLI   SCRPFCD,X'F1'       PF-1 - HELP\n         BE    *+L'*+8\n         CLI   SCRPFCD,X'C1'       PF-13 (ALT. PF-1)\n         BNE   *+L'*+14\n         MVC   SCRTEXT(L'CHELP),CHELP\n         LA    R1,L'CHELP\n         B     RDSCR10\n         CLI   SCRPFCD,X'F9'       PF-9 - LIST\n         BE    *+L'*+8\n         CLI   SCRPFCD,X'C9'       PF-21 (ALT. PF-9)\n         BNE   *+L'*+14\n         MVC   SCRTEXT(L'CLIST),CLIST\n         LA    R1,L'CLIST\n         B     RDSCR10\n         CLI   SCRPFCD,X'7A'       PF-10 - SORT\n         BE    *+L'*+8\n         CLI   SCRPFCD,X'4A'       PF-22 (ALT. PF-10)\n         BNE   *+L'*+14\n         MVC   SCRTEXT(L'CSORT),CSORT\n         LA    R1,L'CSORT\n         B     RDSCR10\n         SH    R1,=Y(L'SCRPFCD)\n         BP    *+L'*+6\n         XR    R1,R1\n         B     RDSCR10\n         LR    R15,R1\n         XC    SCRCOPY,SCRCOPY\n         BCT   R15,*+L'*+6\n         MVC   SCRCOPY(*-*),SCRTEXT\n         EX    R15,*-6\n         ST    R1,SCRCOPYL\nRDSCR10  XC    READINTO(L'READINTO),READINTO\n         LTR   R15,R1\n         BZ    RDSCR11\n         BCT   R15,*+L'*+6\n         MVC   READINTO(*-*),SCRTEXT\n         EX    R15,*-6\nRDSCR11  TM    SCRSTAT,DTCNT\n         BZ    RDLNE3\n         B     SDSCR4\n         EJECT\n* DEFSYM IS CALLED BY :\n*\n*        LA    R1,... SYMBOL\n*        LA    R2,... START-OF-SEARCH\n*        BAS   R14,DEFSYM\n*\n*        (1) = 0 IF SYMBOL NEW,\n*              1 IF OLD, -1 IF COULD NOT FIT,\n*              2 IF CONSTANT,\n*              -1 IF COULD NOT FIT\n*        (2) = LOC. OF SYMBOL\n*\nDEFSYM   MVC   DEFDRM(10),0(R1)    MOVE TO ERROR MESSAGE IN CASE\n         CLI   0(R1),C'0'          SEE IF NUMBER\n         BL    DEFSYM1\n         CLI   0(R1),C'9'\n         BH    DEFSYM1\n         LA    R2,0(R1,R4)\n         CLI   0(R2),C'.'          SEE IF ENDS IN A .\n         BE    DEFDY               IF SO, ALWAYS DECIMAL\n         CLI   0(R2),C'H'          SEE IF ENDS IN H\n         BE    DEFH                IF SO, ALWAYS HEX\n         TM    SWITCH,MODE         SEE WHAT THE MODE IS\n         BZ    DEFD1               DECIMAL\n         LA    R4,1(R4)            ADD 1 TO LENGTH COUNT\n         B     DEFH                THEN GO TO CONVERT HEX\nDEFDY    BCTR  R2,0                CUT 2 DOWN FOR CHECK\n         BCTR  R4,0                CUT 4 DOWN FOR LENGTH\nDEFD1    CH    R4,=H'8'            SEE IF TOO LONG\n         BH    DEFDERR\nDEFD2    CLI   0(R2),C'0'          CHECK FOR VALID #\n         BL    DEFDERR\n         BCTR  R2,0\n         CLI   0(R2),C' '\n         BNE   DEFD2\n         EX    R4,DEFPACK          PACK THE NUMBER\n         CVB   R2,DEFPK            CONVERT TO BINARY\nDEFD3    ST    R2,DEFPK+8          MAKE CONSTANT LOOK LIKE SYMBOL\n         LA    R2,DEFPK\n         LA    R1,2\n         BR    R14                 RETURN\nDEFPACK  PACK  DEFPK(8),0(*-*,R1)  << EXECUTED >>\nDEFDERR  ST    R14,DFSR14          BAD DATA - SAVE R14\n         LA    R1,DEFDRM\n         LA    R0,L'DEFDRM\n         BAS   R14,RDLNE           SEND A MESSAGE AND READ A LINE\n         LTR   R1,R1\n         BNZ   TLNEW\n         L     R14,DFSR14\n         XR    R2,R2\n         B     DEFD3\nDEFH     XR    R0,R0\n         LR    R2,R1\nDEFH1    BCTR  R4,0\n         IC    R1,0(R2)            GET A CHARACTER\n         CLI   0(R2),C'0'          SEE IF 0-N\n         BNL   DEFH2               IF SO, KEEP RIGHT 4 BITS\n         CLI   0(R2),C'A'          MAKE SURE A-F\n         BL    DEFDERR             IF NOT, COMPLAIN\n         CLI   0(R2),C'F'\n         BH    DEFDERR\n         LA    R1,9(R1)            GET RIGHT 4 BITS + 9\nDEFH2    SLL   R1,28\n         LA    R2,1(R2)\n         SLDL  R0,4\n         LTR   R4,R4\n         BP    DEFH1\n         LR    R2,R0\n         B     DEFD3\nDEFSYM1  XR    R0,R0               ZERO REG 0 FOR TEST\nDEFSYM2  CLI   0(R2),X'FF'         SEE IF AT END\n         BE    DEFEND              IF SO, SEE IF FOUND ANYTHING\n         LTR   R0,R0               SEE IF FOUND A PREVIOUS PLACE\n         BNZ   DEFSYM3             IF SO, SKIP\n         CLI   0(R2),0             SEE IF SPACE OPEN\n         BNE   DEFSYM3\n         LR    R0,R2               IF SO, SAVE R2\nDEFSYM3  CLC   0(8,R2),0(R1)       SEE IF MATCH\n         BE    DEFOLD\n         LA    R2,12(R2)           IF NOT,\n         B     DEFSYM2             TRY AGAIN\nDEFEND   LTR   R2,R0               AT END - SEE IF FOUND SPACE\n         BNZ   DEFNEW              IF SO, OK\n         MVC   DEFOVM1(8),0(R1)    COULD NOT FIT\n         ST    R14,DFSR14          SAVE R14\n         LA    R1,DEFOVM           COMPLAIN\n         LA    R0,L'DEFOVM+L'DEFOVM1\n         BAS   R14,RDLNE           SEND A MESSAGE AND READ A LINE\n         LTR   R1,R1\n         BNZ   TLNEW\n         L     R14,DFSR14\n         LA    R2,SYMTBL\nDEFOLD   LA    R1,1                OLD SYMBOL\n         BR    R14                 RETURN\nDEFNEW   MVC   0(8,R2),0(R1)       NEW - MOVE SYMBOL IN\n         XC    8(4,R2),8(R2)       GIVE IT A VALUE OF ZERO\n         XR    R1,R1\n         BR    R14                 RETURN\n         EJECT\n*        CONVERT TO DECIMAL ROUTINE\n*\n*        AT ENTRY - (1) = VALUE\n*        AT EXIT - CVDNR = EDITED DEC VALUE\n*                  CVHNR = EDITED HEX VALUE\n         SPACE 1\nCVD      LR    R2,R1               SAVE VALUE\n         LA    R4,CVHNR\n         LA    R15,L'CVHNR\nCVDL     XR    R0,R0\n         SLDL  R0,4\n         STC   R0,0(R4)\n         LA    R4,1(R4)\n         BCT   R15,CVDL\n         TR    CVHNR(L'CVHNR),=CL16'0123456789ABCDEF'\n         CVD   R2,CVDN\n         LA    R1,CVDNR+L'CVDNR-2  POINT 1 FOR EDMK\n         MVC   CVDNR(13),=XL13'40202020202020202020212040'  MOVE MASK\n         EDMK  CVDNR(L'CVDNR-1),CVDN+2  DO THE EDIT\n         LTR   R2,R2               SEE IF INPUT NEGATIVE\n         BNMR  R14\n         BCTR  R1,0\n         MVI   0(R1),C'-'\n         BR    R14\n         EJECT\n*        CONSTANTS.\n         SPACE 1\nCDEC     DC    C'/DEC'\nCHEX     DC    C'/HEX'\nCLIST    DC    C'/LIST'\nCSORT    DC    C'/SORT'\nCHELP    DC    C'/HELP'\nCDISP    DC    C'/DISP'\nCNODISP  DC    C'/NODISP'\nCDELETE  DC    C'/DELETE'\nTLMOCM   DC    C'MISSING OPERATOR'\nTLMMOP   DC    C'MISSING OPERAND'\nTLMSEP   DC    C'MISSING SEPARATOR'\nTNMESS   DC    C'INVALID DATA - PLEASE RE-ENTER'\nMENTER   DC    C'ENTER EQUATION(S) OR ''/END'''\nDUMTOM   DC    C'ILLEGAL OCCURANCE OF ='\n         SPACE 1\nTRTBL    DC    C'%',XL15'0'                                 00-0F\n         DC    XL48'0'                                      10-3F\n         DC    C' ',XL13'0',C'+',XL1'0'                     40-4F\n         DC    XL12'0',C'*',XL1'0',C';',XL1'0'              50-5F\n         DC    C'-/',XL14'0'                                60-6F\n         DC    XL14'0',C'=',XL1'0'                          70-7F\n         DC    XL128'0'                                     80-FF\n         SPACE 1\nCAPS     DC    21AL1(*-CAPS)       00-14\n         DC    CL1';'              15 (BECOME ;)\n         DC    63AL1(*-CAPS)       16-54\n         DC    CL1';'              55 (BECOME ;)\n         DC    21AL1(*-CAPS)       56-6A\n         DC    CL1';'              6B (, BECOME ;)\n         DC    21AL1(*-CAPS)       6C-80\n         DC    9AL1(*-CAPS+C' ')   81-89 BECOME C1-C9\n         DC    7AL1(*-CAPS)        8A-90\n         DC    9AL1(*-CAPS+C' ')   91-99 BECOME D1-D9\n         DC    8AL1(*-CAPS)        9A-A1\n         DC    8AL1(*-CAPS+C' ')   A2-A9 BECOME E2-E9\n         DC    86AL1(*-CAPS)       AA-FF\n         EJECT\n* TURN OFF FULL SCREEN (SPF), CLEAR AND RESET CURSOR TO ROW 1/COL 1\n         SPACE 1\nCLEAR    $FS   CC=EW,WCC=(AL,KBR,RMDT),SBA=(24,79),MF=L\n         $FS   SBA=(1,1),RA=(1,1,00),MF=L\n         $FS   SBA=(1,1),SF=(IC),MF=L\nCLEARL   EQU   *-CLEAR\n         SPACE 2\n        LTORG\n         SPACE 1\n*- - - - END OF BASE REGISTERS - - - - - - - - - - - - - - - - - - - -*\n         EJECT\n*        HELP INFORMATION.\n         SPACE 1\nHELPTXT  DC   AL1(11)\n         DC   CL40'DHC IS A HEX/DECIMAL CALCULATOR.'                 1\n         DC   CL40'IT IS STRICTLY ''FIXED-POINT'' AND IGNORES'       2\n         DC   CL40'OVERFLOW CONDITIONS. DHC WILL ACCEPT'             3\n         DC   CL40'JUST ABOUT ANYTHING FOR INPUT.'                   4\n         DC   CL40'OPERATIONS THAT WILL BE ACCEPTED ARE :'           5\n         DC   CL40'     + FOR ADD, - FOR SUBTRACT,'                  6\n         DC   CL40'     * FOR MULTIPLY, / FOR DIVIDE'                7\n         DC   CL40'     (EXPONENTIATION IS NOT SUPPORTED).'          8\n         DC   CL40'A SEMI-COLON (;) OR A COMMA (,) MAY BE'           9\n         DC   CL40'USED TO SEPARATE INPUT EQUATIONS OR'             10\n         DC   CL40'COMMANDS.'                                       11\n         DC   AL1(11)\n         DC   CL40'SYNTAX : SYMBOL = VALUE;'                         1\n         DC   CL40'         VALUE;'                                  2\n         DC   CL40'         EQUATION;'                               3\n         DC   CL40'E.G. : A=23; 126H; 33+3233H-323.+7'               4\n         DC   CL40'       ARE ALL VALID.'                            5\n         DC   CL40'       THE DEFAULT MODE IS DECIMAL.'              6\n         DC   CL40'ALL HEX VALUES IN DECIMAL MODE MUST BE'           7\n         DC   CL40'     FOLLOWED BY THE CHARACTER ''H''.'            8\n         DC   CL40'ALL DECIMAL VALUES IN HEX MODE MUST BE'           9\n         DC   CL40'     FOLLOWED BY THE CHARACTER ''.'''            10\n         DC   CL40'     (PERIOD).'                                  11\n         DC   AL1(11)\n         DC   CL40'COMMANDS ARE :'                                   1\n         DC   CL40'/SORT   = DISPLAY A SORTED SYMBOLS TABLE'         2\n         DC   CL40'/LIST   = DISPLAY THE SYMBOLS TABLE'              3\n         DC   CL40'/HEX    = SET MODE TO HEX'                        4\n         DC   CL40'/DEC    = SET MODE TO DECIMAL'                    5\n         DC   CL40'/DISP   = DISPLAY ALL EQUATIONS AS'               6\n         DC   CL40'     PROCESSED'                                   7\n         DC   CL40'/NODISP = DISPLAY ONLY THE LAST RESULT'           8\n         DC   CL40'     UNLESS THE INPUT ENDS BY A COMMAND'          9\n         DC   CL40'/DELETE = DELETE ONE OR MORE SYMBOLS AND'        10\n         DC   CL40'     THEIR VALUES FROM THE SYMBOLS TABLE'        11\n         DC   AL1(12)\n         DC   CL40'EXAMPLES OF INPUT :'                              1\n         DC   CL40'     /HEX; START=0ABBC0; ERROR=0AC000;'           2\n         DC   CL40'     OFFSET=ERROR-START; /SORT'                   3\n         DC   CL40'NOTE THAT HEX VALUES BEGINNING WITH A'            4\n         DC   CL40'CHARACTER MUST BE PRECEEDED BY A ZERO'            5\n         DC   CL40'TO PREVENT THEIR BEING INTERPRETED AS'            6\n         DC   CL40'VARIABLES.'                                       7\n         DC   CL40'1) SEMI-COLONS (OR COMMAS) SEPARATE'              8\n         DC   CL40'   EQUATIONS;'                                    9\n         DC   CL40'2) DIVISION BY ZERO YIELDS AN ERROR'             10\n         DC   CL40'   MESSAGE;'                                     11\n         DC   CL40'3) 0FFFFFFFFH + 1 YIELDS ZERO.'                  12\n         DC   AL1(12)\n         DC   CL40'4) A PRIMATIVE LOOPING CAPABILITY IS'             1\n         DC   CL40'   PRESENT, IF NEW INPUT IS NOT ENTERED'          2\n         DC   CL40'   AFTER ANY DISPLAY, THE LAST INPUT'             3\n         DC   CL40'   WILL BE USED. EXAMPLE :'                       4\n         DC   CL40'     YOU ENTER : A = 3;'                          5\n         DC   CL40'     DHC RETURNS :   3 00000003'                  6\n         DC   CL40'     YOU ENTER : A = A*3;'                        7\n         DC   CL40'     DHC RETURNS :   9 00000009'                  8\n         DC   CL40'     YOU ENTER : <CARRIER RETURN OR'              9\n         DC   CL40'                  SHIFT/ENTER>'                  10\n         DC   CL40'     DHC RETURNS :  27 0000001B'                 11\n         DC   CL40'     ETC...'                                     12\n         DC   AL1(6)\n         DC   CL40'5) THE CURRENT RESULT IS KEPT IN THE'             1\n         DC   CL40'   SYMBOL ''*''... THIS MEANS THAT TO GET'        2\n         DC   CL40'   THE CURRENT RESULT TIMES 2 ONE COULD'          3\n         DC   CL40'   ENTER **2; TO GET THE CURRENT RESULT'          4\n         DC   CL40'   TO THE THIRD POWER, ONE COULD ENTER'           5\n         DC   CL40'   *****.'                                        6\n         DC   XL1'0'               STOP MARKER\nHELPFTX  DC   CL40'DHC IS A HEX/DECIMAL CALCULATOR. IT IS S'         1\n         DC   CL40'TRICTLY ''FIXED-POINT'' AND IGNORES'\n         DC   CL40'     OVERFLOW CONDITIONS. DHC WILL ACCEP'         2\n         DC   CL40'T JUST ABOUT ANYTHING FOR INPUT.'\n         DC   CL40'     OPERATIONS THAT WILL BE ACCEPTED AR'         3\n         DC   CL40'E : + FOR ADD, - FOR SUBTRACT, * FOR'\n         DC   CL40'     MULTIPLY, / FOR DIVIDE (EXPONENTIAT'         4\n         DC   CL40'ION IS NOT SUPPORTED). A SEMI-COLON (;)'\n         DC   CL40'     OR A COMMA (,) MAY BE USED TO SEPAR'         5\n         DC   CL40'ATE INPUT EQUATIONS OR COMMANDS.'\n         DC   CL40'     SYNTAX : SYMBOL = VALUE; VALUE; EQU'         6\n         DC   CL40'ATION;'\n         DC   CL40'     E.G. : A=23; 126H; 33+3233H-323.+7 '         7\n         DC   CL40'ARE ALL VALID.'\n         DC   CL40'     THE DEFAULT MODE IS DECIMAL.'                8\n         DC   CL40' '\n         DC   CL40'     ALL HEX VALUES IN DECIMAL MODE MUST'         9\n         DC   CL40' BE FOLLOWED BY THE CHARACTER ''H''. ALL'\n         DC   CL40'     DECIMAL VALUES IN HEX MODE MUST BE '        10\n         DC   CL40'FOLLOWED BY THE CHARACTER ''.'' (PERIOD).'\n         DC   CL40'COMMANDS ARE :'                                  11\n         DC   CL40' '\n         DC   CL40'    /SORT   = DISPLAY A SORTED SYMBOLS T'        12\n         DC   CL40'ABLE'\n         DC   CL40'    /LIST   = DISPLAY THE SYMBOLS TABLE'         13\n         DC   CL40' '\n         DC   CL40'    /HEX    = SET MODE TO HEX'                   14\n         DC   CL40' '\n         DC   CL40'    /DEC    = SET MODE TO DECIMAL'               15\n         DC   CL40' '\n         DC   CL40'    /DISP   = DISPLAY ALL EQUATIONS AS P'        16\n         DC   CL40'ROCESSED'\n         DC   CL40'    /NODISP = DISPLAY ONLY THE LAST RESU'        17\n         DC   CL40'LT UNLESS THE INPUT ENDS BY A COMMAND'\n         DC   CL40'    /DELETE = DELETE ONE OR MORE SYMBOLS'        18\n         DC   CL40' AND THEIR VALUES FROM THE SYMBOLS TABLE'\n         DC   CL40'EXAMPLES OF INPUT : /HEX; START=0ABBC0; '         1\n         DC   CL40'ERROR=0AC000; OFFSET=ERROR-START; /SORT'\n         DC   CL40'     NOTE THAT HEX VALUES BEGINNING WITH'         2\n         DC   CL40' A CHARACTER MUST BE PRECEEDED BY A ZERO'\n         DC   CL40'     TO PREVENT THEIR BEING INTERPRETED '         3\n         DC   CL40'AS VARIABLES.'\n         DC   CL40'1) SEMI-COLONS (OR COMMAS) SEPARATE EQUA'         4\n         DC   CL40'TIONS;'\n         DC   CL40'2) DIVISION BY ZERO YIELDS AN ERROR MESS'         5\n         DC   CL40'AGE;'\n         DC   CL40'3) 0FFFFFFFFH + 1 YIELDS ZERO.'                   6\n         DC   CL40' '\n         DC   CL40'4) A PRIMATIVE LOOPING CAPABILITY IS PRE'         7\n         DC   CL40'SENT, IF NEW INPUT IS NOT ENTERED AFTER'\n         DC   CL40'   ANY DISPLAY, THE LAST INPUT WILL BE U'         8\n         DC   CL40'SED. EXAMPLE :'\n         DC   CL40'     YOU ENTER : A = 3;'                          9\n         DC   CL40'     DHC RETURNS :   3 00000003'\n         DC   CL40'     YOU ENTER : A = A*3;'                       10\n         DC   CL40'     DHC RETURNS :   9 00000009'\n         DC   CL40'     YOU ENTER : <ENTER>'                        11\n         DC   CL40'     DHC RETURNS :  27 0000001B'\n         DC   CL40'     ETC...'                                     12\n         DC   CL40' '\n         DC   CL40'5) THE CURRENT RESULT IS KEPT IN THE SYM'        13\n         DC   CL40'BOL ''*''... THIS MEANS THAT TO GET THE'\n         DC   CL40'   CURRENT RESULT TIMES 2 ONE COULD ENTE'        14\n         DC   CL40'R **2; TO GET THE CURRENT RESULT TO THE'\n         DC   CL40'   THIRD POWER, ONE COULD ENTER *****.'          15\n         DC   CL40' '\n         DC   XL1'0'               STOP MARKER\n         EJECT\nTSODSECT DSECT                     WORK AREAS DESCRIPTION\n         SPACE 1\nTSOSAVE  DS    18F                 SAVE AREA\nDEFPK    DC    2D'0'\nCVDN     DC    2D'0'\nEXTR    EXTRACT *-*,'S',MF=L\nATSO     DC    A(0)\nLEXTR    EQU   *-EXTR\nLISTSV   DC    3F'0'\nQQSAVE   DC    2F'0'\nSRSR14   DC    F'0'\nDFSR14   DC    F'0'\nTLSTART  DC    F'0'\nSCRSZ    DC    F'0'\nSCRLZ    DC    F'0'\nPRES     DC    2F'0'\nBLZR     DC    0F'0',CL8'0',2F'0'\nTNAME    DC    0F'0',CL8' ',F'0'\nSYMTBL   DC    0F'0',CL8'*'\nSYMTBLI  DC    223F'0'\nSYMTBLE  DC    4X'FF'\nTSTRING  DC    XL256'0'\nREADINTO DC    XL256'0'\nBLKSCR   DC    11CL40' '\nNLSCR    EQU   (*-BLKSCR)/L'BLKSCR\nTRES     DC    CL250' '\nCVDNR    DC    CL13' '             DEC EDIT\nCVHNR    DC    CL8' '              HEX EDIT\nPROP     DC    CL1'+'\nSWITCH   DC    XL1'0'              FLAGS\nEQYET    EQU   X'01'               OFF - CONTROL, ON - NO CONTROL\nNODISP   EQU   X'02'               OFF - DISPLAY, ON - NO DISPLAY\nMODE     EQU   X'04'               OFF - DECIMAL, ON - HEXADECIMAL\nRDREQ    EQU   X'08'               ON - READ REQUESTED AFTER MSG\nSWSCR    EQU   X'80'               ON - RUNNING ON A VALID SCREEN\nDEFDRM   DC    C'           INVALID; 0 ASSUMED'\nDEFOVM   DC    C'SYMBOL TABLE OVERFLOW;'\nDEFOVM1  DC    CL9' '\nDELERM   DC    CL9' '\nDELERM1  DC    C'NOT PREVIOUSLY DEFINED - ERROR'\nDELMSG   DC    C'         DELETED'\nTLUNDM   DC    C'         UNDEFINED - SET TO 0'\nZRDVM    DC    C'         = 0; DIVIDE SUPPRESSED'\n         SPACE 1\nTSOLEN   EQU   (((*-TSOSAVE)+7)/8)*8    WORK AREAS LENGTH\n         EJECT\nSCRDSECT DSECT                     SCREEN AREAS DESCRIPTION\n         SPACE 1\nSCRIPTR  DC    F'0'                CURRENT DATA LINES POINTER\nSCRXPTR  DC    F'0'                DATA LINES POINTER CONTROL\nSCRCOPYL DC    F'0'                LENGTH COPY OF INPUT TEXT (RESHOW)\nSCRRPLY  DS    0CL155              AREA TO HOLD TGET REPLY\nSCRPFCD  DC    XL6'0'              AID + JUNK\nSCRTEXT  DC    XL149'0'            REPLY TEXT\nSCRCOPY  DC    XL148'0'            COPY OF INPUT TEXT (RESHOW)\nSCRSTAT  DC    XL1'0'              FLAGS\nFIRST    EQU   X'01'               ON - FIRST TPUT DONE\nDTCNT    EQU   X'02'               ON - DATA CONTINUE\n         SPACE 1\nSCRFULL  $FS   CC=W,WCC=(RMDT),SBA=(24,80),MF=L   SET BUFFER/CLEAR\n         $FS   SBA=(1,1),RA=(1,1,00),MF=L\n         $FS   SBA=(1,1),SF=(PROT),RA=(1,29,-),MF=L        LINE 1\n         $FS   SF=(PROT,INT),TEXT='HEX/DECIMAL CALCULATOR',MF=L\n         $FS   SF=(PROT),RA=(1,80,-),MF=L\n         $FS   SF=(PROT),TEXT='ENTER',MF=L                 LINE 2-3\n         $FS   SF=(PROT,INT),TEXT='===>',MF=L\n         $FS   SF=NORMAL,MF=L\n         $FS   SBA=(4,1),SF=(PROT),MF=L                    LINE 4\n         $FS   TEXT='--- MODE =',MF=L\n         $FS   SF=(PROT,INT),MF=L\nSCRMODE  $FS   TEXT=(' ',3),MF=L\n         $FS   SF=(PROT),TEXT='(PF 5/17) --- DISPLAY =',MF=L\n         $FS   SF=(PROT,INT),MF=L\nSCRDISP  $FS   TEXT=(' ',3),MF=L\n         $FS   SF=(PROT),TEXT='(PF 6/18) ---',MF=L\n         $FS   TEXT='----- <FLIP-FLOP> ---',MF=L\n         $FS   SBA=(5,1),SF=(PROT),MF=L                    LINE 5\n         $FS   TEXT='--- HELP:1/13 - ',MF=L\n         $FS   TEXT='END:3/15/4/16 - ',MF=L\n         $FS   TEXT='LIST:9/21 - ',MF=L\n         $FS   TEXT='SORT:10/22 - ',MF=L\n         $FS   TEXT='RESHOW:12/24/PA2 ---',MF=L\n         $FS   SBA=(6,1),SF=(PROT,INT),RA=(6,72,6D),MF=L   LINE 6\nSCRNXTT  $FS   TEXT=('________',8),MF=L\n         $FS   SF=(PROT),MF=L\nSCRDATA  DC    18CL80' '           DATA LINES (36*40)      LINE 7-24\nSCRNL    EQU   (*-SCRDATA)/L'SCRDATA    NUMBER OF LINES\nSCRLEN   EQU   *-SCRFULL\nSCRIADD  $FS   SBA=(2,12),MF=L     INPUT AREA BUFFER ADDR. LINE 2\nSCRINAR  DC    XL148'0'            INPUT AREA\nSCRPTIC  $FS   SBA=(1,1),SF=(PT,IC),MF=L\nSCRPTICL EQU   *-SCRPTIC\n         SPACE 1\nSCRDLEN  EQU   (((*-SCRIPTR)+7)/8)*8    SCREEN AREAS LENGTH\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DHC$": {"ttr": 7428, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x942\\x7f\\x00\\x942\\x7f\\x14#\\x00\\n\\x00\\n\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-23T00:00:00", "modifydate": "1994-11-23T14:23:00", "lines": 10, "newlines": 10, "modlines": 0, "user": "SYSPAJA"}, "text": "//DHC      JOB (........),'INSTALL  - D H C -',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=800K,TIME=1\n/*JOBPARM L=4\n//ASS     EXEC PAJ1AS2,OPT=',RENT',MBR=DHC\n//LNK     EXEC PAJILKC,OPT=',RENT'\n//SYSIN     DD *\n  ENTRY   DHC\n  NAME    DHC(R)\n/*\n//HLP     EXEC PAJHELP,MBR=DHCH,DSS='->.SOURCE.FILE1'\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DHC@": {"ttr": 7430, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x89\\x08\\x8f\\x00\\x89\\x08\\x8f\\x11!\\x00G\\x00G\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-03-29T00:00:00", "modifydate": "1989-03-29T11:21:00", "lines": 71, "newlines": 71, "modlines": 0, "user": "SYSPAJA"}, "text": "1   28/03/89\n                                                      DHC       1/2.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *       HEX/DECIMAL CALCULATOR.       * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n   Function : DHC is a hex/decimal calculator.\n   ---------- It is strictly FIXED-POINT and ignores overflow\n              conditions.\n\n   Syntax :   DHC will accept just about anything for input.\n   --------   Operations that will be accepted are :\n                 + for add\n                 - for subtract\n                 * for multiply\n                 / for divide\n              --- EXPONENTIATION is not supported ---\n              A semi-colon (;) or a comma (,) may be used to separate\n              input equations or commands.\n\n   Command syntax : SYMBOL = VALUE;\n                    VALUE;\n                    EQUATION;\n              e.g. : A=23;126H;33+3233H-323.+7 are all valid.\n              The default mode is decimal.\n              All HEX values in decimal mode must be followed by\n              the character H. All decimal values in HEX mode\n              must be followed by the character . (period).\n\n   Operands and commands :\n   -----------------------\n              /SORT   : display a sorted symbols table\n              /LIST   : display the symbols table\n              /HEX    : set mode to hexadecimal\n              /DEC    : set mode to decimal\n              /DISP   : display all equations as processed\n              /NODISP : display only the last result unless the input\n                        ends by a command.\n              /DELETE : delete one or more symbols and their values\n                        from the symbols table.\n1   28/03/89\n                                                      DHC       2/2.\n\n   Examples of input :\n   -------------------\n      /HEX;START=0ABBC0;ERROR=0AC000;OFFSET=ERROR-START;/SORT\n      Note that HEX values beginning with a character must be\n      preceeded by a zero to prevent their being interpreted as\n      variables.\n\n   Notes : 1) Semi-colons (or commas) separate equations.\n           2) Division by zero yields an error message.\n           3) 0FFFFFFFFH + 1 yields zero.\n           4) A primative looping capability is present,\n              if new input is not entered after any display,\n              the last input will be used.\n              Example :\n               you enter : A = 3;\n               DHC returns :   3 00000003\n               you enter : A = A*3;\n               DHC returns :   9 00000009\n               you enter : <carrier return or shift/enter>\n               DHC returns :  27 0000001B\n               etc...\n           5) The current result is kept in the symbol *...\n              This means that to get the current result times 2\n              one could enter **2; to get the current result to\n              the third power, one could enter *****.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DHCH": {"ttr": 7433, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x89\\x08\\x8f\\x00\\x89\\x08\\x8f\\x11!\\x008\\x008\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-03-29T00:00:00", "modifydate": "1989-03-29T11:21:00", "lines": 56, "newlines": 56, "modlines": 0, "user": "SYSPAJA"}, "text": "./     ADD     NAME=DHC\n./     NUMBER  NEW1=100,INCR=100\n)F FUNCTION : DHC IS A HEX/DECIMAL CALCULATOR.\n              IT IS STRICTLY 'FIXED-POINT' AND IGNORES OVERFLOW\n              CONDITIONS.\n)X SYNTAX :   DHC WILL ACCEPT JUST ABOUT ANYTHING FOR INPUT.\n              OPERATIONS THAT WILL BE ACCEPTED ARE :\n                 + FOR ADD\n                 - FOR SUBTRACT\n                 * FOR MULTIPLY\n                 / FOR DIVIDE\n              --- EXPONENTIATION IS NOT SUPPORTED ---\n              A SEMI-COLON (;) OR A COMMA (,) MAY BE USED TO SEPARATE\n              INPUT EQUATIONS OR COMMANDS.\n   COMMAND SYNTAX : SYMBOL = VALUE;\n                    VALUE;\n                    EQUATION;\n              E.G. : A=23;126H;33+3233H-323.+7 ARE ALL VALID.\n              THE DEFAULT MODE IS DECIMAL.\n              ALL HEX VALUES IN DECIMAL MODE MUST BE FOLLOWED BY\n              THE CHARACTER 'H'. ALL DECIMAL VALUES IN HEX MODE\n              MUST BE FOLLOWED BY THE CHARACTER '.'.\n)O OPERANDS AND COMMANDS :\n              /SORT   : DISPLAY A SORTED SYMBOLS TABLE\n              /LIST   : DISPLAY THE SYMBOLS TABLE\n              /HEX    : SET MODE TO HEX\n              /DEC    : SET MODE TO DECIMAL\n              /DISP   : DISPLAY ALL EQUATIONS AS PROCESSED\n              /NODISP : DISPLAY ONLY THE LAST RESULT UNLESS THE INPUT\n                        ENDS BY A COMMAND.\n              /DELETE : DELETE ONE OR MORE SYMBOLS AND THEIR VALUES\n                        FROM THE SYMBOLS TABLE.\n   EXAMPLES OF INPUT :\n      /HEX;START=0ABBC0;ERROR=0AC000;OFFSET=ERROR-START;/SORT\n      NOTE THAT HEX VALUES BEGINNING WITH A CHARACTER MUST BE\n      PRECEEDED BY A ZERO TO PREVENT THEIR BEING INTERPRETED AS\n      VARIABLES.\n   NOTES : 1) SEMI-COLONS (OR COMMAS) SEPARATE EQUATIONS;\n           2) DIVISION BY ZERO YIELDS AN ERROR MESSAGE;\n           3) 0FFFFFFFFH + 1 YIELDS ZERO.\n           4) A PRIMATIVE LOOPING CAPABILITY IS PRESENT,\n              IF NEW INPUT IS NOT ENTERED AFTER ANY DISPLAY,\n              THE LAST INPUT WILL BE USED.\n              EXAMPLE :\n               YOU ENTER : A = 3;\n               DHC RETURNS :   3 00000003\n               YOU ENTER : A = A*3;\n               DHC RETURNS :   9 00000009\n               YOU ENTER : <CARRIER RETURN OR SHIFT/ENTER>\n               DHC RETURNS :  27 0000001B\n               ETC...\n           5) THE CURRENT RESULT IS KEPT IN THE SYMBOL '*'...\n              THIS MEANS THAT TO GET THE CURRENT RESULT TIMES 2\n              ONE COULD ENTER **2; TO GET THE CURRENT RESULT TO\n              THE THIRD POWER, ONE COULD ENTER *****.\n./     ENDUP\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ENQCNF": {"ttr": 7435, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x88\\to\\x00\\x88\\to\\x16X\\x01'\\x01'\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-04-05T00:00:00", "modifydate": "1988-04-05T16:58:00", "lines": 295, "newlines": 295, "modlines": 0, "user": "SYSPAJA"}, "text": "CNFL     TITLE 'DISPLAY DATA-SETS ENQUE''S CONFLICTS ROUTINE.'\nENQCNF   START 0\n         SPACE 1\n* FUNCTION :   ROUTINE TO DISPLAY DATA-SETS ENQUE'S CONFLICTS ON SP1.3\n* ----------   AT SYSTEM CONSOLE.\n*\n* AUTHOR :     MOINIL P.A.\n* --------     COMPUTING CENTRE\n*              J.R.C. - ISPRA ESTABLISHMENT\n*              21020 ISPRA (VA), ITALY\n         SPACE 2\n        $DEFREG\nSIAL     EQU   102400              SCAN INFO AREA LENGTH.\n         EJECT\n        $XENT  BASE=R12,LV=WRKL,TYPE=RENT\n         LR    R5,R13              SET WORK AREAS ADDRESSABILITY.\n         USING WRKDSECT,R5\n         ST    R0,SENDP            SET TSO FLAG ADDRESS.\n         LA    R1,L'WTOLINE+L'LINE\n         STH   R1,WTOLINE\n         MVC   WTOLINE+2(2),WTOP+2\n         MVC   MCSLINE(4),WTOP+8\n         MVC   LINE,BLANK\n         L     R3,CVTPTR           GET ADDRESS OF CVT.\n         USING CVT,R3\n         L     R4,CVTSMCA\n         DROP  R3\n         USING SMCABASE,R4         SET ADDRESSABILITY.\n         MVC   LINE(28),=CL28'DATA-SET CONFLICTS DISPLAY ('\n         MVC   LINE+28(4),SMCASID  MOVE SYSTEM ID.\n         DROP  R4\n         MVI   LINE+33,C'-'\n        TIME  DEC                  R0 : HHMMSSTH\n         STM   R0,R1,WORKD         TIME - DATE\n         UNPK  LINE+44(7),WORKD(4)\n         MVC   LINE+50(2),LINE+48  XXSS\n         MVC   LINE+48(1),LINE+47  MXSS\n         MVC   LINE+47(1),LINE+46  HHXM MXSS\n         MVI   LINE+46,C'.'\n         MVI   LINE+49,C'.'        HH.MM.SS\n         UNPK  LINE+35(7),WORKD+4(4)\n         MVC   LINE+35(2),LINE+37  YY\n         MVC   LINE+38(3),LINE+39  DDD\n         MVI   LINE+37,C'.'        YY.DDDX\n         MVI   LINE+41,C' '        YY.DDD\n         MVI   LINE+42,C'-'\n         MVI   LINE+52,C')'\n         LA    R15,WTOLINE\n         BAL   R14,SENDL           TITLE AND TIME.\n         XC    TKN,TKN             ZERO OUT TOKEN AREA.\n         MVI   SWITCH,0            INITIALIZE SWITCHES.\nSTART    LA    R8,SCANAREA         ADDRESS OF RETURNED DATA.\n         LA    R9,SYSDSN           ADDRESS OF SYSDSN MAJOR NAME.\n         MVC   SYSDSN,=CL8'SYSDSN'\n         LA    R13,SCANSAVE        ADDRESS GQSCAN SAVE AREA.\n         XC    0(18*4,R13),0(R13)\n         MVC   SCAN(LSCAN),SCANP\n        GQSCAN AREA=((R8),),RESNAME=((R9)),TOKEN=TKN,MF=(E,SCAN)\n         LR    R13,R5              RESTORE MAIN SAVE AREA.\n         B     *+L'*(R15)          BRANCH TO APPROPRIATE ROUTINE.\n         B     CODE00                - ALL OK.\n         B     CODE04                - NO RESOURCES MATCHED REQUEST.\n         B     CODE08                - GQSCAN AREA TOO SMALL.\n         B     CODE0C                - ERROR WHILE PROCESSING.\n         B     CODE10                - INVALID SYSNAME.\n         SPACE 1\nCODE04   LA    R15,CODE04M\n         LA    R14,RETURN\n         B     SENDL               EXIT, DSNAME NOT FOUND.\nCODE08   OI    SWITCH,TKNSW        SET TOKEN SWITCH TO CONTINUE.\n         B     CODE00              GO CONTINUE PROCESSING.\nCODE0C   LA    R15,CODE0CM\n         LA    R14,RETURN\n         B     SENDL               EXIT, ERROR IN GQSCAN.\nCODE10   LA    R15,CODE10M   INVALID SYSNAME.\n         LA    R14,RETURN\n         B     SENDL               EXIT, INVALID SYSNAME.\n         SPACE 1\nCODE00   STCM  R0,B'1111',RIBLNGTH STORE RIB AND RIBE LENGTH.\n         LTR   R7,R1               SAVE NUMBER OF RIBS.\n         BZ    RETURN              NO RIB'S SUPPLIED.\n         LA    R6,LINE\n         LA    R10,SCANAREA        ADDRESS OF GQSCAN AREA (1ST RIB).\n         USING RIB,R10             RESOURCE INFORMATION BLOCK.\nRIBLOOP  L     R9,RIBNRIBE         LOAD THE NO. OF RIBE'S.\n         LTR   R9,R9\n         BNP   BUMPRIB             NO RIBE'S SUPPLIED.\n         LR    R11,R10             GET RIB POINTER.\n         AH    R11,RIBLNGTH        POINT TO RIB VARIABLE SECTION.\n         USING RIBVAR,R11          RESOURCE INFORMATION BLOCK.\n         MVC   LINE,BLANK          CLEAR BEFORE USING.\n         USING DSNLINE,R6\n         MVC   DSNT,=CL16'DATA-SET NAME :'\n         SR    R1,R1\n         IC    R1,RIBRNMLN         RNAME LENGTH.\n         BCT   R1,MVCDSN+L'MVCDSN  MINUS ONE FOR EX INSTRUCTION.\nMVCDSN   MVC   DSN(*-*),RIBRNAME   << EXECUTED >>\n         EX    R1,MVCDSN           MOVE DSNAME TO PRINT LINE.\n         DROP  R11\n         AH    R11,RIBVLEN         POINT TO FIRST RIBE.\n         USING RIBE,R11            RESOURCE INFORMATION BLOCK EXT.\n         CLC   RIBNTWE,=F'0'       ANY WAITING FOR EXCLUSIVE?\n         BNE   TPHDRS              YES, PROCESS.\n         CLC   RIBNTWS,=F'0'       ANY WAITING FOR SHARE?\n         BNE   TPHDRS              YES, PROCESS.\n         B     BUMPRIB             NO, BUMP TO NEXT RIB.\n         DROP  R6\n         SPACE 1\nTPHDRS   LA    R15,SEPRTR\n         BAL   R14,SENDL           SEND SEPARATOR.\n         LA    R15,WTOLINE\n         BAL   R14,SENDL           SEND DATA-SET NAME.\n         MVC   LINE,BLANK\n         MVC   LINE(L'FLAGHD),FLAGHD\n         LA    R15,WTOLINE\n         BAL   R14,SENDL           SEND FLAG HEADER.\n         MVC   LINE(L'FLAGHU),FLAGHU\n         LA    R15,WTOLINE\n         BAL   R14,SENDL           UNDER LINE IT.\n         SPACE 1\nSEARCH   MVC   LINE,BLANK          CLEAR BEFORE USING.\n         OI    SWITCH,ENQSW        SET SWITCH THAT THERE WAS ENQ.\n         USING JOBLINE,R6\n         MVC   JOBNAME,RIBEJBNM    JOBNAME OF REQUESTOR.\n         MVC   SYSTEM(4),RIBESYSN  SYSTEM NAME OF REQUESTOR.\n         TM    RIBERFLG,RIBETYPE   IS THIS EXCLUSIVE OR SHARED?\n         BO    SHARED              BRANCH IF SHARED.\n         MVC   EXCLFLAG,=CL4'EXCL' NO, EXCLUSIVE.\n         B     TSMC\nSHARED   MVC   EXCLFLAG,=CL4'SHR'\nTSMC     TM    RIBERFLG,RIBEMC     IS MUST COMPLETE?\n         BO    MUSTC               BRANCH IF YES.\n         MVI   MCFLAG,C'N'\n         B     TSRR\nMUSTC    MVI   MCFLAG,C'Y'\nTSRR     TM    RIBERFLG,RIBERESV   IS THIS RESERVE REQUEST?\n         BO    RESERVE             BRANCH IF YES.\n         MVI   RESVFLAG,C'N'\n         B     TSRG\nRESERVE  MVI   RESVFLAG,C'Y'\nTSRG     TM    RIBERFLG,RIBERESC   IS THIS RESERVE REQUEST GLOBAL?\n         BO    GLOBAL              BRANCH IF YES.\n         MVI   GLOBFLAG,C'N'\n         B     TSGO\nGLOBAL   MVI   GLOBFLAG,C'Y'\nTSGO     TM    RIBESFLG,RIBESTAT   IS THIS GUY THE OWNER?\n         BO    OWNER               BRANCH IF YES.\n         MVI   OWNFLAG,C'N'\n         MVC   WAITFLAG,=CL9'*WAITING*' TELL USER WAITING DATA-SET.\n         B     WTOIT\nOWNER    MVI   OWNFLAG,C'Y'\n         DROP  R6,R11\nWTOIT    LA    R15,WTOLINE\n         BAL   R14,SENDL           SEND IT.\n         AH    R11,RIBELENG        POINT TO NEXT RIBE.\n         BCT   R9,SEARCH           DO IT FOR NEXT USER.\nBUMPRIB  SR    R3,R3\n         L     R4,RIBNRIBE         NUMBER OF RIBE'S.\n         LTR   R4,R4\n         BNP   NEXTRIB             NO RIBE'S SUPPLIED.\nBUMPLOOP AH    R3,RIBELENG         ADD RIBE LENGTH.\n         BCT   R4,BUMPLOOP         ADD TIMES NO. OF RIBE'S.\nNEXTRIB  AH    R3,RIBLNGTH         ADD LENGTH OF RIB.\n         AH    R3,RIBVLEN          ADD LENGTH OF VARIABLE SECTION.\n         AR    R10,R3              POINT TO NEXT RIB.\n         BCT   R7,RIBLOOP          LOOP UNTIL NO MORE RIBS.\n         DROP  R10\nRETURN   TM    SWITCH,TKNSW        IS THERE MORE DATA?\n         BZ    TEST                NO\n         NI    SWITCH,255-TKNSW    YES\n         B     START               GO CONTINUE PROCESSING.\nTEST     TM    SWITCH,ENQSW        WAS THERE AN ENQ?\n         BO    FINISH              YES, EXIT.\n         LA    R15,NOENQ\n         BAL   R14,SENDL           TELL USER.\n         SPACE 1\nFINISH  $XRET  CC=0,LV=WRKL,TYPE=RENT\n         SPACE 1\nSENDL    LA    R1,SENDP            BUILD PARM. LIST.\n         ST    R15,4(R1)\n         L     R15,=V(SENDRTN)\n         BR    R15                 GO TO DISPLAY THIS LINE.\n         DROP  R5\n         EJECT\nSCANP   GQSCAN AREA=(,SIAL),REQLIM=MAX,SCOPE=ALL,MF=L\n        PRINT  NOGEN\nWTOP    WTO    '....',ROUTCDE=2,DESC=4,MF=L\nSEPRTR  WTO    '***************',ROUTCDE=2,DESC=4,MF=L\nCODE04M WTO    'ERROR ENCOUNTERED CODE 04 - RETRY COMMAND.',           X\n               ROUTCDE=2,DESC=4,MF=L\nCODE0CM WTO    'ERROR ENCOUNTERED CODE 0C - RETRY COMMAND.',           X\n               ROUTCDE=2,DESC=4,MF=L\nCODE10M WTO    'ERROR ENCOUNTERED CODE 10 - RETRY COMMAND.',           X\n               ROUTCDE=2,DESC=4,MF=L\nNOENQ   WTO    'NO DATA-SETS ENQUE''S CONFLICTS EXIST.',               X\n               ROUTCDE=2,DESC=4,MF=L\n        PRINT  GEN\n         SPACE 1\nFLAGHD   DS    0CL72               FLAG HEADER.\n         DC    CL14'JOBNAME/USERID'\n         DC    CL5' '\n         DC    CL4'DISP'\n         DC    CL2' '\n         DC    CL8' SYSTEM '\n         DC    CL2' '\n         DC    CL13'MUST COMPLETE'\n         DC    CL2' '\n         DC    CL7'RESERVE'\n         DC    CL2' '\n         DC    CL6'GLOBAL'\n         DC    CL2' '\n         DC    CL5'OWNER'\nFLAGHU   DS    0CL72               FLAG HEADER UNDERLINE.\n         DC    CL14'--------------'\n         DC    CL5' '\n         DC    CL4'----'\n         DC    CL2' '\n         DC    CL8'--------'\n         DC    CL2' '\n         DC    CL13'-------------'\n         DC    CL2' '\n         DC    CL7'-------'\n         DC    CL2' '\n         DC    CL6'------'\n         DC    CL2' '\n         DC    CL5'-----'\n         SPACE 1\nBLANK    DC    CL72' '\n         SPACE 2\n        LTORG\n         SPACE 2\nDSNLINE  DSECT                     DATA-SET NAME LINE DESCRIPTION.\nDSNT     DC    CL16'DATA-SET NAME :'\nDSN      DS    CL44\n         SPACE 1\nJOBLINE  DSECT                     INFO LINE DESCRIPTION.\nJOBNAME  DS    CL8\n         DC    C' '\nWAITFLAG DS    CL9' '\n         DC    C' '\nEXCLFLAG DS    CL4\n         DC    CL4' '\nSYSTEM   DS    CL4\n         DC    CL4' '\n         DC    CL6' '\nMCFLAG   DS    CL1\n         DC    CL6' '\n         DC    CL2' '\n         DC    CL3' '\nRESVFLAG DS    CL1\n         DC    CL3' '\n         DC    CL2' '\n         DC    CL2' '\nGLOBFLAG DS    CL1\n         DC    CL3' '\n         DC    CL2' '\n         DC    CL2' '\nOWNFLAG  DS    CL1\n         DC    CL2' '\n         SPACE 1\nWRKDSECT DSECT                     WORK AREAS DESCRIPTIONS.\n         SPACE 1\nSVA      DS    18F                 SAVE AREA.\nSCANSAVE DS    18F                 18 WORDS SAVE AREA REQ FOR GQSCAN.\n         SPACE 1\nWORKD    DS    D\n         SPACE 1\nSCAN    GQSCAN AREA=(,SIAL),REQLIM=MAX,SCOPE=ALL,MF=L\nLSCAN    EQU   *-SCAN\nSWITCH   DS    XL1                 ENQ/TOKEN SWITCHES.\nTKNSW    EQU   X'01'                - TOKEN SWITCH.\nENQSW    EQU   X'02'                - ENQ SWITCH.\nTKN      DS    F                   TOKEN AREA ADDRESS.\nRIBLNGTH DC    H'0'                RIB LENGTH.\nRIBELENG DC    H'0'                RIBE LENGTH.\nSYSDSN   DS    CL8                 QNAME FOR GQSCAN.\n         SPACE 1\nSENDP    DS    2F\n         SPACE 1\nWTOLINE  DS    F\nLINE     DS    CL72                CONSOLE LINE WORK AREA.\nMCSLINE  DS    XL4\n         SPACE 1\n         DS    0F\nSCANAREA DS    (SIAL)X             SCAN INFO AREA.\n         SPACE 2\nWRKL     EQU   (((*-SVA)+7)/8)*8   WORK AREAS LENGTH.\n         SPACE 2\n        PRINT NOGEN\n         SPACE 1\n        CVT    DSECT=YES,TSO=YES,RPS=YES,LIST=YES\n        IEESMCA\n        ISGRIB\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ENQRSV": {"ttr": 7681, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\to\\x00\\x88\\to\\x16X\\x01N\\x01N\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-04-05T00:00:00", "modifydate": "1988-04-05T16:58:00", "lines": 334, "newlines": 334, "modlines": 0, "user": "SYSPAJA"}, "text": "RSRV     TITLE 'DISPLAY RESOURCES ENQUE''S RESERVE ROUTINE.'\nENQRSV   START 0\n         SPACE 1\n* FUNCTION :   ROUTINE TO DISPLAY RESOURCES ENQUE'S RESERVE ON SP1.3\n* ----------   AT SYSTEM CONSOLE.\n*\n* AUTHOR :     MOINIL P.A.\n* --------     COMPUTING CENTRE\n*              J.R.C. - ISPRA ESTABLISHMENT\n*              21020 ISPRA (VA), ITALY\n         SPACE 2\n        $DEFREG\nSIAL     EQU   102400              SCAN INFO AREA LENGTH.\n         EJECT\n        $XENT  BASE=R12,LV=WRKL,TYPE=RENT\n         LR    R5,R13              SET WORK AREAS ADDRESSABILITY.\n         USING WRKDSECT,R5\n         ST    R0,SENDP            SET TSO FLAG ADDRESS.\n         LA    R1,L'WTOLINE+L'LINE\n         STH   R1,WTOLINE\n         MVC   WTOLINE+2(2),WTOP+2\n         MVC   MCSLINE(4),WTOP+8\n         MVC   LINE,BLANK\n         L     R3,CVTPTR           GET ADDRESS OF CVT.\n         USING CVT,R3\n         L     R4,CVTSMCA\n         DROP  R3\n         USING SMCABASE,R4         SET ADDRESSABILITY.\n         MVC   LINE(28),=CL28'RESOURCES RESERVES DISPLAY ('\n         MVC   LINE+28(4),SMCASID  MOVE SYSTEM ID.\n         MVC   CURSYS(4),SMCASID\n         DROP  R4\n         MVI   LINE+33,C'-'\n        TIME  DEC                  R0 : HHMMSSTH\n         STM   R0,R1,WORKD         TIME - DATE\n         UNPK  LINE+44(7),WORKD(4)\n         MVC   LINE+50(2),LINE+48  XXSS\n         MVC   LINE+48(1),LINE+47  MXSS\n         MVC   LINE+47(1),LINE+46  HHXM MXSS\n         MVI   LINE+46,C'.'\n         MVI   LINE+49,C'.'        HH.MM.SS\n         UNPK  LINE+35(7),WORKD+4(4)\n         MVC   LINE+35(2),LINE+37  YY\n         MVC   LINE+38(3),LINE+39  DDD\n         MVI   LINE+37,C'.'        YY.DDDX\n         MVI   LINE+41,C' '        YY.DDD\n         MVI   LINE+42,C'-'\n         MVI   LINE+52,C')'\n         LA    R15,WTOLINE\n         BAL   R14,SENDL           TITLE AND TIME.\n         XC    TKN,TKN             ZERO OUT TOKEN AREA.\n         MVI   SWITCH,0            INITIALIZE SWITCHES.\nSTART    LA    R10,SCANAREA        ADDRESS OF RETURNED DATA.\n         LA    R13,SCANSAVE        ADDRESS GQSCAN SAVE AREA.\n         XC    0(18*4,R13),0(R13)\n         MVC   SCAN(LSCAN),SCANP\n        ZEROKEY ,\n        GQSCAN AREA=((R10),),TOKEN=TKN,MF=(E,SCAN)\n         LR    R13,R5              RESTORE MAIN SAVE AREA.\n         LR    R8,R0               SAVE RIB AND RIBE LENGTHS.\n         LR    R7,R1               SAVE NUMBER OF RIBS.\n         LR    R9,R15              SAVE RETURN CODE.\n        RESETKEY ,\n         B     *+L'*(R9)           BRANCH TO APPROPRIATE ROUTINE.\n         B     CODE00                - ALL OK.\n         B     CODE04                - NO RESOURCES MATCHED REQUEST.\n         B     CODE08                - GQSCAN AREA TOO SMALL.\n         B     CODE0C                - ERROR WHILE PROCESSING.\n         B     CODE10                - INVALID SYSNAME.\n         SPACE 1\nCODE04   LA    R15,CODE04M\n         LA    R14,RETURN\n         B     SENDL               EXIT, NO RESOURCES.\nCODE08   OI    SWITCH,TKNSW        SET TOKEN SWITCH TO CONTINUE.\n         B     CODE00              GO CONTINUE PROCESSING.\nCODE0C   LA    R15,CODE0CM\n         LA    R14,RETURN\n         B     SENDL               EXIT, ERROR IN GQSCAN.\nCODE10   LA    R15,CODE10M\n         LA    R14,RETURN\n         B     SENDL               EXIT, INVALID SYSNAME.\n         SPACE 1\nCODE00   STCM  R8,B'1111',RIBLNGTH STORE RIB AND RIBE LENGTH.\n         LTR   R7,R7               TEST NUMBER OF RIBS.\n         BZ    RETURN              NO RIB'S SUPPLIED.\n         LA    R6,LINE\n         USING RIB,R10             RESOURCE INFORMATION BLOCK.\nRIBLOOP  L     R9,RIBNRIBE         LOAD THE NO. OF RIBE'S.\n         LTR   R9,R9\n         BNP   BUMPRIB             NO RIBE'S SUPPLIED.\n         LR    R11,R10             GET RIB POINTER.\n         AH    R11,RIBLNGTH        POINT TO RIB VARIABLE SECTION.\n         USING RIBVAR,R11          RESOURCE INFORMATION BLOCK.\n         MVC   LINE,BLANK          CLEAR BEFORE USING.\n         USING RNMLINE,R6\n         MVC   RNMT,=CL16'RESOURCE NAME :'\n         MVC   QNM,RIBQNAME        MOVE QNAME TO PRINT LINE.\n         MVI   QRS,C'/'\n         SR    R1,R1\n         IC    R1,RIBRNMLN         RNAME LENGTH.\n         BCT   R1,MVCRNM+L'MVCRNM  MINUS ONE FOR EX INSTRUCTION.\nMVCRNM   MVC   RNM(*-*),RIBRNAME   << EXECUTED >>\n         EX    R1,MVCRNM           MOVE RNAME TO PRINT LINE.\n         DROP  R6,R11\n         AH    R11,RIBVLEN         POINT TO FIRST RIBE.\n         USING RIBE,R11            RESOURCE INFORMATION BLOCK EXT.\n         LR    R0,R9               SAVE IN CASE.\n         LR    R1,R11\nANYRSV   TM    RIBERFLG,RIBERESV   ANY RESERVE REQUEST?\n         BO    TPHDRS              BRANCH IF YES.\n         AH    R11,RIBELENG        POINT TO NEXT RIBE.\n         BCT   R9,ANYRSV           DO IT FOR NEXT USER.\n         B     BUMPRIB             NO, BUMP TO NEXT RIB.\n         SPACE 1\nTPHDRS   LR    R9,R0               RESTART FROM FIRST RIBE.\n         LR    R11,R1\n         LA    R15,SEPRTR\n         BAL   R14,SENDL           SEND SEPARATOR.\n         LA    R15,WTOLINE\n         BAL   R14,SENDL           SEND RESOURCE NAME.\n         MVC   LINE,BLANK          CLEAR.\n         MVC   LINE(L'FLAGHD),FLAGHD\n         LA    R15,WTOLINE\n         BAL   R14,SENDL           SEND FLAG HEADER.\n         MVC   LINE(L'FLAGHU),FLAGHU\n         LA    R15,WTOLINE\n         BAL   R14,SENDL           UNDER LINE IT.\n         SPACE 1\nSEARCH   MVC   LINE,BLANK          CLEAR BEFORE USING.\n         OI    SWITCH,ENQSW        SET SWITCH THAT THERE WAS ENQ.\n         USING JOBLINE,R6\n         MVC   JOBNAME,RIBEJBNM    JOBNAME OF REQUESTOR.\n         MVC   SYSTEM(4),RIBESYSN  SYSTEM NAME OF REQUESTOR.\n         TM    RIBERFLG,RIBETYPE   IS THIS EXCLUSIVE OR SHARED?\n         BO    SHARED              BRANCH IF SHARED.\n         MVC   EXCLFLAG,=CL4'EXCL' NO, EXCLUSIVE.\n         B     TSMC\nSHARED   MVC   EXCLFLAG,=CL4'SHR'\nTSMC     TM    RIBERFLG,RIBEMC     IS MUST COMPLETE?\n         BO    MUSTC               BRANCH IF YES.\n         MVI   MCFLAG,C'N'\n         B     TSRR\nMUSTC    MVI   MCFLAG,C'Y'\nTSRR     TM    RIBERFLG,RIBERESV   IS THIS RESERVE REQUEST?\n         BO    RESERVE             BRANCH IF YES.\n         MVI   RESVFLAG,C'N'\n         B     TSRG\nRESERVE  MVI   RESVFLAG,C'Y'\nTSRG     TM    RIBERFLG,RIBERESC   IS THIS RESERVE REQUEST GLOBAL?\n         BO    GLOBAL              BRANCH IF YES.\n         MVI   GLOBFLAG,C'N'\n         B     TSGO\nGLOBAL   MVI   GLOBFLAG,C'Y'\nTSGO     TM    RIBESFLG,RIBESTAT   IS THIS GUY THE OWNER?\n         BO    OWNER               BRANCH IF YES.\n         MVI   OWNFLAG,C'N'\n         MVC   WAITFLAG,=CL3'*W*'  TELL USER WAITING DATA-SET.\n         B     SETCUA\nOWNER    MVI   OWNFLAG,C'Y'\nSETCUA   CLC   CURSYS(4),RIBESYSN  CURRENT SYSTEM NAME?\n         BNE   OTHER               BRANCH IF NOT.\n         L     R1,RIBEUCB          GET UCB ADDRESS.\n         LTR   R1,R1               IS UCB ADDRESS TRUE?\n         BZ    WTOIT               BRANCH IF NOT.\n         USING UCBDSECT,R1\n         MVC   CUA,UCBNAME         SET UCB NAME.\n         MVC   UNAME,UCBVOLI       SET VOLUME SERIAL NUMBER.\n         DROP  R1\n         B     WTOIT\nOTHER    MVC   CUA+1(4),=C'--->'   SAY OTHER SYSTEM (BYPASS A 0C4).\n         MVC   CUA+6(4),RIBESYSN\n         DROP  R6,R11\nWTOIT    LA    R15,WTOLINE\n         BAL   R14,SENDL           SEND IT.\n         AH    R11,RIBELENG        POINT TO NEXT RIBE.\n         BCT   R9,SEARCH           DO IT FOR NEXT USER.\nBUMPRIB  SR    R3,R3\n         L     R4,RIBNRIBE         NUMBER OF RIBE'S.\n         LTR   R4,R4\n         BNP   NEXTRIB             NO RIBE'S SUPPLIED.\nBUMPLOOP AH    R3,RIBELENG         ADD RIBE LENGTH.\n         BCT   R4,BUMPLOOP         ADD TIMES NO. OF RIBE'S.\nNEXTRIB  AH    R3,RIBLNGTH         ADD LENGTH OF RIB.\n         AH    R3,RIBVLEN          ADD LENGTH OF VARIABLE SECTION.\n         AR    R10,R3              POINT TO NEXT RIB.\n         BCT   R7,RIBLOOP          LOOP UNTIL NO MORE RIBS.\n         DROP  R10\nRETURN   TM    SWITCH,TKNSW        IS THERE MORE DATA?\n         BZ    TEST                NO\n         NI    SWITCH,255-TKNSW    YES\n         B     START               GO CONTINUE PROCESSING.\nTEST     TM    SWITCH,ENQSW        WAS THERE AN ENQ?\n         BO    FINISH              YES, EXIT.\n         LA    R15,NOENQS\n         BAL   R14,SENDL           TELL USER.\n         SPACE 1\nFINISH  $XRET  CC=0,LV=WRKL,TYPE=RENT\n         SPACE 1\nSENDL    LA    R1,SENDP            BUILD PARM. LIST.\n         ST    R15,4(R1)\n         L     R15,=V(SENDRTN)\n         BR    R15                 GO TO DISPLAY THIS LINE.\n         DROP  R5\n         EJECT\nSCANP   GQSCAN AREA=(,SIAL),REQLIM=MAX,SCOPE=ALL,RESERVE=YES,MF=L\n         SPACE 1\n        PRINT  NOGEN\nWTOP    WTO    '....',ROUTCDE=2,DESC=4,MF=L\nSEPRTR  WTO    '***************',ROUTCDE=2,DESC=4,MF=L\nCODE04M WTO    'ERROR ENCOUNTERED CODE 04 - RETRY COMMAND.',           X\n               ROUTCDE=2,DESC=4,MF=L\nCODE0CM WTO    'ERROR ENCOUNTERED CODE 0C - RETRY COMMAND.',           X\n               ROUTCDE=2,DESC=4,MF=L\nCODE10M WTO    'ERROR ENCOUNTERED CODE 10 - RETRY COMMAND.',           X\n               ROUTCDE=2,DESC=4,MF=L\nNOENQS  WTO    'NO RESOURCES ENQUE''S RESERVE EXIST.',                 X\n               ROUTCDE=2,DESC=4,MF=L\n        PRINT  GEN\n         SPACE 1\nFLAGHD   DS    0CL55               FLAG HEADER.\n         DC    CL14'JOBNAME/USERID'\n         DC    CL2' '\n         DC    CL4'DISP'\n         DC    CL2' '\n         DC    CL4'SYS.'\n         DC    CL2' '\n         DC    CL2'MC'\n         DC    CL2' '\n         DC    CL2'RS'\n         DC    CL2' '\n         DC    CL2'GL'\n         DC    CL2' '\n         DC    CL2'OW'\n         DC    CL2' '\n         DC    CL3'CUA'\n         DC    CL2' '\n         DC    CL6'VOLSER'\nFLAGHU   DS    0CL55               FLAG HEADER UNDERLINE.\n         DC    CL14'--------------'\n         DC    CL2' '\n         DC    CL4'----'\n         DC    CL2' '\n         DC    CL4'----'\n         DC    CL2' '\n         DC    CL2'--'\n         DC    CL2' '\n         DC    CL2'--'\n         DC    CL2' '\n         DC    CL2'--'\n         DC    CL2' '\n         DC    CL2'--'\n         DC    CL2' '\n         DC    CL3'---'\n         DC    CL2' '\n         DC    CL6'------'\n         SPACE 1\nBLANK    DC    CL72' '\n         SPACE 2\n        LTORG\n         SPACE 2\nRNMLINE  DSECT                     RESOURCE NAME LINE DESCRIPTION.\nRNMT     DC    CL16'RESOURCE NAME :'\nQNM      DS    CL8\n         DC    CL1' '\nQRS      DC    CL1'/'\n         DC    CL1' '\nRNM      DS    CL44\n         SPACE 1\nJOBLINE  DSECT                     INFO LINE DESCRIPTION.\nJOBNAME  DS    CL8\n         DC    C' '\nWAITFLAG DS    CL3\n         DC    CL2' '\n         DC    CL2' '\nEXCLFLAG DS    CL4\n         DC    CL2' '\nSYSTEM   DS    CL4\n         DC    CL2' '\n         DC    CL1' '\nMCFLAG   DS    CL1\n         DC    CL2' '\n         DC    CL1' '\nRESVFLAG DS    CL1\n         DC    CL2' '\n         DC    CL1' '\nGLOBFLAG DS    CL1\n         DC    CL2' '\n         DC    CL1' '\nOWNFLAG  DS    CL1\n         DC    CL2' '\nCUA      DS    CL3\n         DC    CL2' '\nUNAME    DS    CL6\n         DC    CL17' '\n         SPACE 1\nWRKDSECT DSECT                     WORK AREAS DESCRIPTIONS.\n         SPACE 1\nSVA      DS    18F                 SAVE AREA.\nSCANSAVE DS    18F                 18 WORDS SAVE AREA REQ FOR GQSCAN.\n         SPACE 1\nWORKD    DS    D\n         SPACE 1\nSCAN    GQSCAN AREA=(,SIAL),REQLIM=MAX,SCOPE=ALL,RESERVE=YES,MF=L\nLSCAN    EQU   *-SCAN\nSWITCH   DS    XL1                 ENQ/TOKEN SWITCHES.\nTKNSW    EQU   X'01'                - TOKEN SWITCH.\nENQSW    EQU   X'02'                - ENQ SWITCH.\nTKN      DS    F                   TOKEN AREA ADDRESS.\nRIBLNGTH DC    H'0'                RIB LENGTH.\nRIBELENG DC    H'0'                RIBE LENGTH.\n         SPACE 1\nCURSYS   DS    CL4                 CURRENT SYSTEM ID.\nSENDP    DS    2F\n         SPACE 1\nWTOLINE  DS    F\nLINE     DS    CL72                CONSOLE LINE WORK AREA.\nMCSLINE  DS    XL4\n         SPACE 1\n         DS    0F\nSCANAREA DS    (SIAL)X             SCAN INFO AREA.\n         SPACE 2\nWRKL     EQU   (((*-SVA)+7)/8)*8   WORK AREAS LENGTH.\n         SPACE 2\n        PRINT NOGEN\n         SPACE 1\n        CVT    DSECT=YES,TSO=YES,RPS=YES,LIST=YES\n        IEESMCA\n        ISGRIB\nUCBDSECT DSECT\n        IEFUCBOB\nCIBDSECT DSECT\nCIB     IEZCIB\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IEBANTP": {"ttr": 7687, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90!\\x8f\\x00\\x90!\\x8f\\x16E\\to\\to\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-08-06T00:00:00", "modifydate": "1990-08-06T16:45:00", "lines": 2415, "newlines": 2415, "modlines": 0, "user": "SYSPAJA"}, "text": "ANTP     TITLE 'IEBANTP --- ANALYZE/COPY UTILITY.'\nANTP     START 0\n         SPACE 1\nANTP    AMODE  24\nANTP    RMODE  24\n         SPACE 2\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n* * * * * * * * *                                     * * * * * * * * *\n* * * * * * * * *        ANALYZE/COPY UTILITY.        * * * * * * * * *\n* * * * * * * * *                                     * * * * * * * * *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*                                                                     *\n* AUTHOR :     P.A. MOINIL                                            *\n* --------     COMPUTING CENTRE                                       *\n*              J.R.C. - ISPRA ESTABLISHMENT                           *\n*              21020 ISPRA (VA), ITALY                                *\n*                                                                     *\n*              NOTE - THIS IS A MODIFIED VERSION OF THE 'IEBANTP'     *\n*                     PROGRAM RECEIVED FROM IBM (MILANO).             *\n*                                                                     *\n* PURPOSE :    THIS IS A MAP PROGRAM WHICH OUTPUTS A LIST GIVING THE  *\n* ---------    DESCRIPTION OF ALL THE LOGICAL FILES RECORDED ON A     *\n*              MAGNETIC TAPE. THE END OF TAPE IS ASSUMED WHEN         *\n*              READING TWO CONSECUTIVE TAPE-MARKS.                    *\n*                                                                     *\n*              ON REQUEST, THE INPUT TAPE CAN BE COPIED, WITH THE     *\n*              AVAILABILITY TO CHANGE THE DENSITY AND/OR THE VOLUME   *\n*              SERIAL NUMBER OF THE OUTPUT TAPE (BE CAREFULL WHEN     *\n*              CHANGING DENSITY THAT THE CONTENTS MUST NOT OVERFLOW   *\n*              A TAPE REEL CAPACITY : MULTIPLE VOLUMES ARE NOT        *\n*              SUPPORTED).                                            *\n*                                                                     *\n*              THE PROGRAM ACCEPTS ONLY 9-TRACKS TAPES (BLP OPTION).  *\n*                                                                     *\n* 3480 DATA CARTRIDGE : ADAPTED TO RUN AS 3480 IN CODE COMPATIBILITY  *\n* --------------------- MODE (TAPE-WRITE-IMMEDIATE).                  *\n*                                                                     *\n* CHECK REQUESTED OPERATION : WITH THE INTRODUCTION OF THE 3480 DATA  *\n* --------------------------- CARTRIDGE UNITS, THE PROGRAM HAS BEEN   *\n*              ENHANCED TO PERFORM A VALIDITY CHECK ON THE REQUESTED  *\n*              OPERATION (LINK TO 'ANTPCHK' ROUTINE).                 *\n*                                                                     *\n* MVS/XA :     MUST BE AMODE AND RMODE 24.                            *\n* --------                                                            *\n*                                                                     *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         EJECT\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*                                                                     *\n* CALL OF THE PROGRAM :                                               *\n* ---------------------                                               *\n*                                                                     *\n* 1. TAPE ANALYSIS.                                                   *\n*                                                                     *\n*        //ANAL      EXEC  PGM=IEBANTP                                *\n*        //SYSPRINT    DD  SYSOUT=A                                   *\n*        //SYSUT1      DD  UNIT=TAPE,VOL=SER=......,DSN=...,       C  *\n*        //                LABEL=(,BLP),DISP=OLD                      *\n*                                                                     *\n* 2. TAPE COPY.                                                       *\n*                                                                     *\n*        //COPY      EXEC  PGM=IEBANTP                                *\n*        //SYSPRINT    DD  SYSOUT=A                                   *\n*        //SYSUT1      DD  UNIT=TAPE,VOL=SER=......,DSN=...,       C  *\n*        //                LABEL=(,BLP),DISP=OLD                      *\n*        //SYSUT2      DD  UNIT=TAPE,VOL=SER=......,DSN=...,       C  *\n*        //                LABEL=(,BLP),DISP=NEW                      *\n*        //SYSIN       DD  *  (OPTIONAL : SEE SELECTIVE COPY)         *\n*          ... FILE NUMBERS ...                                       *\n*        /*                                                           *\n*        //SYSCHECK    DD  SYSOUT=A  (OPTIONAL : SEE SELECTIVE COPY)  *\n*                                                                     *\n*        NOTE : WHEN SYSUT2 IS A 3480 DATA CARTRIDGE, THE TRUE LABEL  *\n*               IS INDICATED BY THE VOL=SER=....... DD-PARAMETER.     *\n*                                                                     *\n* DENSITY AND VOLUME SERIAL NUMBER : NOT APPLYABLE TO 3480 (IGNORED   *\n* ---------------------------------- IF SPECIFIED)                    *\n*              A DENSITY AND/OR A NEW VOLUME SERIAL NUMBER CAN BE     *\n*        ASSIGNED TO THE OUTPUT TAPE (SYSUT2) USING THE PARAMETER'S   *\n*        FIELD OF THE 'EXEC' STATEMENT AS FOLLOWS :                   *\n*                                                                     *\n*        //COPY      EXEC  PGM=IEBANTP,PARM='DEN=X,SER=NNNNNN'        *\n*                                                                     *\n*        OR THE SHORT FORM :                                          *\n*                                                                     *\n*        //COPY      EXEC  PGM=IEBANTP,PARM='D=X,S=NNNNNN'            *\n*                                                                     *\n*        WHERE : X = 2 FOR 800 BPI.    (NOT APPLYABLE TO 3480)        *\n*                    3 FOR 1600 BPI.                                  *\n*                    4 FOR 6250 BPI.                                  *\n*                                                                     *\n*                NNNNNN = NEW VOLUME SERIAL NUMBER.                   *\n*                                                                     *\n*              IF THE DENSITY CANNOT BE DETERMINED FROM SYSUT1 OR     *\n*        IS NOT DECLARED BY THE DEN= PARAMETER, THEN THE DEFAULT OF   *\n*        1600 BPI IS ASSUMED FOR THE COPIED TAPE (SYSUT2).            *\n*                                                                     *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         EJECT\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*                                                                     *\n* BYPASS OPERATOR ADVICE MESSAGE : ALWAYS SET WHEN 3480 (IGNORED IF   *\n* -------------------------------- SPECIFIED)                         *\n*              WHEN COPYING, THE OPERATOR ADVICE MESSAGES ABOUT       *\n*        TAPES CORRECTLY MOUNTED (TO GET HIM A LAST CHANCE AGAINST    *\n*        CONTENTS DESTRUCTION) MAY BE SUPPRESSED AS FOLLOWS :         *\n*                                                                     *\n*        //...       EXEC  PGM=IEBANTP,PARM='...,NOVEROP,...'         *\n*        OR :                                                         *\n*        //...       EXEC  PGM=IEBANTP,PARM='...,N,...'               *\n*                                                                     *\n* BLOCK COUNT (EURATOM MODIFICATION) :                                *\n* ------------------------------------                                *\n*              WHEN COPYING STANDARD LABELED TAPES (SYSUT1-SYSUT2),   *\n*        ONE CAN ASK TO COMPUTE AGAIN AND REWRITE THE BLOCK COUNT     *\n*        (NUMBER OF PHYSICAL RECORDS) IN THE TRAILER LABEL (EOF1)     *\n*        BY SPECIFYING : PARM='...,BLKCOUNT' OR PARM='...,B'.         *\n*                                                                     *\n* SPECIAL USE (EURATOM MODIFICATION) :                                *\n* ------------------------------------                                *\n*              SOME APPLICATIONS IN THE CENTRE PRODUCE NO LABELED     *\n*        (NL) TAPES (I.E. - LABORATORIES ANALYSIS RECORDER) WITH A    *\n*        LARGE NUMBER OF FILES (TAPE-MARKS). OFTEN IT IS DESIRABLE    *\n*        FOR FURTHER COMPUTATIONS, TO MERGE ALL THESE FILES IN ONLY   *\n*        ONE (NL). THIS IS DONE BY THE PROGRAM WHEN PROVIDING THE     *\n*        KEYWORD 'COPYSKIP' AS IN THE EXAMPLE BELOW :                 *\n*                                                                     *\n*        //COPYSK    EXEC  PGM=IEBANTP,PARM='COPYSKIP'                *\n*        OR :                                                         *\n*        //COPYSK    EXEC  PGM=IEBANTP,PARM='C'                       *\n*        //SYSPRINT    DD  SYSOUT=A                                   *\n*        //SYSUT1      DD  UNIT=TAPE,VOL=SER=......,DSN=...,       C  *\n*        //                LABEL=(,BLP),DISP=OLD                      *\n*        //SYSUT2      DD  UNIT=TAPE,VOL=SER=......,DSN=...,       C  *\n*        //                LABEL=(,BLP),DISP=NEW                      *\n*                                                                     *\n*              THE KEYWORD 'COPYSKIP' IS ACCEPTED ONLY WHEN SYSUT2    *\n*        IS PRESENT (COPY). IT CAN BE USED IN CONJUNCTION WITH THE    *\n*        KEYWORDS 'DEN' AND 'SER' (THIS LAST IS JUST FOR INFORMATION  *\n*        ON THE OUTPUT LIST), AND THE KEYWORD 'BLKCOUNT' IS IGNORED.  *\n*                                                                     *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         EJECT\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*                                                                     *\n* ARCHIVE (EURATOM MODIFICATION) :                                    *\n* --------------------------------                                    *\n*              ANOTHER MODIFICATION TO THE PROGRAM ALLOWS THE COPY    *\n*        OF AN INPUT TAPE AFTER THE CONTENTS OF AN OUTPUT TAPE,       *\n*        THUS EXPANDING THE SYSUT2 TAPE.                              *\n*                                                                     *\n*        //COPYAD    EXEC  PGM=IEBANTP,PARM='ADD,DEN=X,SER=NNNNNN'    *\n*        OR :                                                         *\n*        //COPYAD    EXEC  PGM=IEBANTP,PARM='A,D=X,S=NNNNNN'          *\n*        //SYSPRINT    DD  SYSOUT=A                                   *\n*        //SYSUT1      DD  UNIT=TAPE,VOL=SER=......,DSN=...,       C  *\n*        //                LABEL=(,BLP),DISP=OLD                      *\n*        //SYSUT2      DD  UNIT=TAPE,VOL=SER=......,DSN=...,       C  *\n*        //                LABEL=(,BLP),DISP=...                      *\n*                                                                     *\n*              THE SYSUT2 DISPOSITION FIRST SUBPARAMETER IS 'OLD'     *\n*        IF THE TAPE IS NOT PASSED FROM A PREVIOUS STEP, OTHERWISE    *\n*        USE 'MOD' IN ORDER TO LEFT THE TAPE POSITIONED AT THE END,   *\n*        THUS GAIN TIME PREVENTING THE REWIND.                        *\n*                                                                     *\n*              THE KEYWORD 'ADD' REQUIRES THE KEYWORDS 'SER' AND      *\n*        'DEN' TO BE PRESENT, THE KEYWORD 'BLKCOUNT' IS OPTIONALLY    *\n*        USABLE, AND THE KEYWORD 'COPYSKIP' IS NOT ACCEPTED.          *\n*                                                                     *\n* SELECTIVE COPY (EURATOM MODIFICATION) :                             *\n* ---------------------------------------                             *\n*              ONLY WITH NORMAL OR ARCHIVE COPY OPERATIONS, A LIST    *\n*        OF THOSE DESIRED FILES, TO BE COPIED FROM THE SYSUT1 TAPE    *\n*        ON THE SYSUT2 TAPE, MAY BE SUPPLIED BY THE SYSIN INPUT.      *\n*                                                                     *\n*        CARD FORMAT : THE FILES NUMBERS CAN BE SPECIFIED IN ANY      *\n*                      ORDER FROM COL.1 UP TO COL.72 INCLUDED.        *\n*                      SINGLE (N) OR RANGE (N-NN) OF FILES NUMBERS    *\n*                      MUST BE SEPARATED EACH FROM THE OTHERS BY      *\n*                      AT LEAST ONE BLANK. EACH CARD STARTS NEW       *\n*                      SINGLE OR RANGE INFORMATION. AS SOON AS AN     *\n*                      ASTERISK (*) IS ENCOUNTERED, THE REST OF THE   *\n*                      CARD IS CONSIDERED COMMENT.                    *\n*        NOTE : THE FILES NUMBERS REFERS TO NL OR SL FILES DEPENDING  *\n*               ON THE AUTOMATIC TYPE RECOGNITION OF THE SYSUT1 TAPE. *\n*                                                                     *\n*              KEYWORDS 'COPYSKIP' AND 'BLKCOUNT' ARE NOT ALLOWED.    *\n*        YOU MAY USE A 'SYSCHECK' DD-CARD IF YOU WANT A CHECK LIST.   *\n*                                                                     *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         EJECT\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*                                                                     *\n* SEQUENCE NUMBERS ADJUSTMENT :                                       *\n* -----------------------------                                       *\n*              THE KEYWORDS 'V=' AND 'Q=' MAY BE USED TO SET THE      *\n*        VOLUME SEQUENCE NUMBER AND THE STARTING DATA-SET SEQUENCE    *\n*        NUMBER WHEN COPYING STANDARD LABELED (SL) TAPES ONLY :       *\n*                                                                     *\n*        //COPYAD    EXEC  PGM=IEBANTP,PARM='...,V=NNNN,Q=PPPP,...'   *\n*                                                                     *\n*        WHERE : NNNN IS THE DESIRED VOLUME SEQUENCE NUMBER (ONE TO   *\n*                    FOUR NUMERICS, VALUE MAY BE 1 TO 9999).          *\n*                PPPP IS THE DESIRED STARTING DATA-SET SEQUENCE       *\n*                    NUMBER (ONE TO FOUR NUMERICS, VALUE MAY BE 1     *\n*                    TO 9999).                                        *\n*        NOTE : THESE ADJUSTMENTS ARE AUTOMATICALLY DONE WHEN AN      *\n*               ARCHIVE OPERATION IS REQUESTED.                       *\n*                                                                     *\n* DUMP ANALYSIS :                                                     *\n* ---------------                                                     *\n*              IF A 'SYSANAL' DD-CARD IS SUPPLIED, THEN THE PROGRAM   *\n*        USES IT TO DUMP THE FIRST RECORD (FOR A MAXIMUM LENGTH OF    *\n*        1024 BYTES) OF EACH FILE ENCOUNTERED ON THE TAPE (SYSUT1).   *\n*                                                                     *\n*              IF A 'SYSUDUMP' OR 'SYSABEND' DD-CARD IS PRESENT AND   *\n*        AN UNEXPECTED ERROR OCCURS READING THE INPUT TAPE (SYSUT1)   *\n*        OR WRITING THE OUTPUT TAPE (SYSUT2), A DUMP WITH ABEND CODE  *\n*        U0001 IS TAKEN, OTHERWISE ONLY AN I/O ERROR MESSAGE IS       *\n*        SUPPLIED.                                                    *\n*                                                                     *\n* BYPASS INPUT TAPE I/O ERROR :                                       *\n* -----------------------------                                       *\n*              ANY I/O ERROR (I.E. - DATA CHECK) WHEN READING THE     *\n*        INPUT TAPE (SYSUT1) MAY BE BYPASSED BY SPECIFYING THE        *\n*        KEYWORD 'FORCE'. IF A 'SYSERR' DD-CARD IS SUPPLIED, THE      *\n*        WRONG RECORD IS DUMPED ON IT (FOR A MAXIMUM LENGTH OF 1024   *\n*        BYTES), AND WHEN THE OPERATION IS A COPY TAPE, THE RECORD IS *\n*        COPIED ON THE OUTPUT TAPE (SYSUT2) AS ENTERED IN MEMORY.     *\n*                                                                     *\n*        //...       EXEC  PGM=IEBANTP,PARM='...,FORCE,...'           *\n*        OR :                                                         *\n*        //...       EXEC  PGM=IEBANTP,PARM='...,F,...'               *\n*                                                                     *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         EJECT\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*                                                                     *\n* BYPASS CONSECUTIVE TAPE-MARKS :                                     *\n* -------------------------------                                     *\n*              SOMETIME, A NO LABELED (NL) TAPE MAY CONTAIN EMPTY     *\n*        FILES, SO IT IS NECESSARY TO INFORM THE PROGRAM ABOUT THIS   *\n*        SITUATION. THE APPROXIMATIVE NUMBER OF FILES, BEFORE TWO     *\n*        CONSECUTIVE TAPE-MARKS BE CONSIDERED THE END OF TAPE, MAY    *\n*        BE SUPPLIED USING THE PARAMETER'S FIELD OF THE 'EXEC'        *\n*        STATEMENT AS BELOW :                                         *\n*                                                                     *\n*        //...       EXEC  PGM=IEBANTP,PARM='...,EVEN=NNNNN,...'      *\n*        OR :                                                         *\n*        //...       EXEC  PGM=IEBANTP,PARM='...,E=NNNNN,...'         *\n*                                                                     *\n*        WHERE : NNNNN IS THE EXPECTED FILES NUMBER (ONE TO FIVE      *\n*                    NUMERICS, VALUE MAY BE 1 TO 99999).              *\n*                                                                     *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         SPACE 2\n***********************************************************************\n*  REMARK :    YOU CAN BUILD MIXED NL AND SL FILES TAPES, BUT THEN,   *\n*  ********    BE CAREFULL IN ANY FURTHER PROCESSING OF THESE TAPES,  *\n*              YOU PROBABLY WILL HAVE TROUBLES OF COURSE.             *\n***********************************************************************\n         EJECT\n        $DEFREG\n*        MISCELLANEOUS DEFINITIONS.\n         SPACE 1\nOFF      EQU   X'0F'               NOP OPERATION SWITCH SETTING.\nON       EQU   X'F0'               BRANCH OPERATION SWITCH SETTING.\nMS800    EQU   X'CB'               MODE SET 2(9-TRACKS), 800 BPI.\nMS1600   EQU   X'C3'               MODE SET 2(9-TRACKS), 1600 BPI,\n*                                  OR 3480 TWI.\nMS6250   EQU   X'D3'               MODE SET 2(9-TRACKS), 6250 BPI.\nTCCWRT   EQU   X'01'               WRITE\nTCCRD    EQU   X'02'               READ\nTCCNOP   EQU   X'03'               NOP\nTCCSNS   EQU   X'04'               SENSE\nTCCREW   EQU   X'07'               REWIND\nTCCWTM   EQU   X'1F'               WRITE TAPE MARK\nTCCBSR   EQU   X'27'               BACKSPACE RECORD\n         SPACE 2\n* DEBUG AID : TRACE ROUTINE (SYSTEST DD-CARD).\n* ----------- SEE AT 'TTR' LABEL IF YOU WANT TO USE IT.\n         EJECT\n        $XENT  BASE=(R11,R12)\n         L     R9,0(R1)            PARM. LIST POINTER.\n         SPACE 1\n*------- GET BUFFERS SPACE.\n         SPACE 1\n         L     R0,=A(32*1024)\n         SLL   R0,1\n        GETMAIN R,LV=(0)\n         ST    R1,ABUF\n         STCM  R1,B'0111',CCWREAD+1\n         STCM  R1,B'0111',CCWWRITE+1\n         A     R1,=A(32*1024)\n         ST    R1,AALT\n         STCM  R1,B'0111',CCWPOS+1\n         SPACE 1\n*------- PRINT STARTING TITLES, OPEN SYSUT1.\n         SPACE 1\n         LA    R10,MSG7\n         BAS   R3,PUTMSG\n         NI    CLSPRT+1,OFF\n        EXTRACT ATIOT,'S',FIELDS=(TIOT)\n         L     R3,ATIOT            TIOT ADDRESS.\n         USING TIODSECT,R3\n         XR    R4,R4\nSCAN     CLC   TIOELNGH(4),=XL4'0' TIOT END?\n         BE    LOOK                YES.\n         CLC   TIOEDDNM,DDTR\n         BE    TRON\n         IC    R4,TIOELNGH         GET IN R4 DD ENTRY LENGTH.\n         AR    R3,R4               R3 POINTS TO NEXT DD ENTRY.\n         B     SCAN\nTRON     NI    SWTR+1,OFF          OPEN TRACE REQUEST.\nLOOK     CLC   0(2,R9),=H'5'       SEE IF PARM=CHECK ONLY SPECIFIED.\n         BNE   SRCHTP\n         CLC   2(5,R9),=CL5'CHECK'\n         BNE   SRCHTP\n         OI    SWFS,PFCHK          IF SO, FILES SELECTION SCAN ONLY.\n         L     R15,=A(FSEL)\n         BASR  R14,R15\n         XR    R10,R10\n         B     CLSPRT\nSRCHTP   L     R3,ATIOT            TIOT ADDRESS.\n         XR    R4,R4\nSEARCH   CLC   TIOELNGH(4),=XL4'0' TIOT END?\n         BE    NOIN                YES.\n         CLC   TIOEDDNM,TAPE+(DCBDDNAM-IHADCB)\n         BE    FOUND\n         IC    R4,TIOELNGH         GET IN R4 DD ENTRY LENGTH.\n         AR    R3,R4               R3 POINTS TO NEXT DD ENTRY.\n         B     SEARCH\n         DROP  R3\nNOIN     LA    R10,MSG3\n         BAS   R3,PUTMSG\nEXERR    LA    R10,8               R.C. = 8. - - - - - - - - - - - - -\n         B     CLSPRT\nFOUND   DEVTYPE TAPE+(DCBDDNAM-IHADCB),DVTYPI\n         CLI   DVTYPI+2,X'80'      TEST IF MAGNETIC TAPE.\n         BE    OPENDS\n         MVI   MSGERDVA,C'1'\n         LA    R10,MSGERDV\n         BAS   R3,PUTMSG\n         B     EXERR\nOPENDS  RDJFCB (TAPE)\n         LTR   R15,R15\n         BZ    *+L'*+12\n         MVI   MSGERJFA,C'1'\n         LA    R10,MSGERJF\n         B     PRTERR\n         L     R15,=A(TTR)         JFCB OF SYSUT1 (SYSTEST).\n         BASR  R14,R15\n         DC    H'1' - - - - - - - - - - - - - - - - - - - - TRACE    1\n         LA    R1,JF\n         USING JFCB,R1\n         TM    JFCBLTYP,JFCBLP     CHECK LABEL=(...,BLP) CODED.\n         BO    *+L'*+12\n         MVI   MSGERBLA,C'1'\n         LA    R10,MSGERBL\n         B     PRTERR\n         MVC   MSGANALB,JFCBVOLS\n         DROP  R1\n        OPEN   (TAPE,(INPUT))\n         TM    TAPE+(DCBOFLGS-IHADCB),DCBOFOPN\n         BO    *+L'*+12\n         MVI   MSGEROPA,C'1'\n         LA    R10,MSGEROP\n         B     PRTERR\n         NI    CLSTPE+1,OFF\n         SPACE 1\n*------- LOOK FOR SYSUT2 DD-CARD AND DEVICE.\n         SPACE 1\n         L     R3,ATIOT            TIOT ADDRESS.\n         USING TIODSECT,R3\n         XR    R4,R4\nSCTIO    CLC   TIOELNGH(4),=XL4'0' TIOT END?\n         BE    CPYNTF              YES.\n         CLC   TIOEDDNM,COPY+(DCBDDNAM-IHADCB)\n         BE    CPYFND\n         IC    R4,TIOELNGH         GET IN R4 DD ENTRY LENGTH.\n         AR    R3,R4               R3 POINTS TO NEXT DD ENTRY.\n         B     SCTIO\nCPYFND  DEVTYPE COPY+(DCBDDNAM-IHADCB),DVTYPO\n         CLI   DVTYPO+2,X'80'      TEST IF MAGNETIC TAPE.\n         BE    DEVOK\nERRDEV   LA    R10,MSGERDV\nPRTERR   BAS   R3,PUTMSG\n         LA    R10,12              R.C. = 12. - - - - - - - - - - - - -\n         B     CLSCPY\nCPYNTF   TM    DVTYPI+3,UCB3480\n         BZ    NOTFND\n         MVC   MSGANALA,=CL4'3480'\n         B     PARM\n         SPACE 1\n*------- OPEN WAY TO COPY ON SYSUT2.\n         SPACE 1\nDEVOK    ICM   R4,B'0111',TIOEFSRT GET ADDRESS OF UCB.\n         DROP  R3\n         USING UCBOB,R4\n         MVC   OPADV4A,UCBNAME     GET UNIT NAME (CUU).\n         DROP  R4\n         NI    SENSEND+1,OFF\n         OI    COUNT+1,ON\n         TM    DVTYPO+3,UCB3480\n         BZ    *+L'*+20\n         MVI   DENOUT,C'0'\n         OI    SWVER+1,ON\n         NI    SERBC+1,OFF\n         OI    SWPF,PFSER\n         B     *+L'*+10\n         MVC   MSG2A,=CL4'1600'\n         MVI   DENOUT,C'3'\n         MVI   COPY+(DCBDEN-IHADCB),DCBMTDN3\n         MVI   CCWCONTR,MS1600\n         MVI   CCWMS,MS1600\n         TM    DVTYPI+3,UCB3480\n         BZ    NOTFND\n         MVC   MSGANALA,=CL4'3480'\n         B     PARM\n         SPACE 1\n*------- READ SYSUT1 TO STORE SENSE.\n         SPACE 1\nNOTFND   XC    ECBIN,ECBIN\n         XC    CSWIN,CSWIN\n        EXCP   IOBIN\n        WAIT   ECB=ECBIN\n         CLI   ECBIN,X'7F'\n         BE    RSEXCP\n         TM    CSWIN+4,X'01'\n         BZ    ERROR\nRSEXCP   NOP   TESTSENS\n         OI    RSEXCP+1,ON\n         LA    R10,CCWSENSE\n         ST    R10,CCWIN\n         B     NOTFND\n         SPACE 1\n*------- TEST DENSITY AND SEND MESSAGE.\n         SPACE 1\nTESTSENS NOP   TEST\n         LA    R10,CCWBSR\n         ST    R10,CCWIN\n         OI    TESTSENS+1,ON\n         B     NOTFND\nTEST     TM    SENSE+6,X'10'\n         BZ    D1600\n         TM    SENSE+6,X'08'\n         BO    D6250\n         MVC   MSG2A,=CL4' 800'\n         TM    SENSEND+1,ON\n         BO    PARM\n         TM    DVTYPO+3,UCB3480\n         BO    PARM\n         MVI   COPY+(DCBDEN-IHADCB),DCBMTDN2\n         MVI   CCWCONTR,MS800\n         MVI   CCWMS,MS800\n         MVI   DENOUT,C'2'\n         B     PARM\nD1600    MVC   MSG2A,=CL4'1600'\n         TM    SENSEND+1,ON\n         BO    PARM\n         TM    DVTYPO+3,UCB3480\n         BO    PARM\n         MVI   COPY+(DCBDEN-IHADCB),DCBMTDN3\n         MVI   CCWCONTR,MS1600\n         MVI   CCWMS,MS1600\n         MVI   DENOUT,C'3'\n         B     PARM\nD6250    MVC   MSG2A,=CL4'6250'\n         TM    SENSEND+1,ON\n         BO    PARM\n         TM    DVTYPO+3,UCB3480\n         BO    PARM\n         MVI   COPY+(DCBDEN-IHADCB),DCBMTDN4\n         MVI   CCWCONTR,MS6250\n         MVI   CCWMS,MS6250\n         MVI   DENOUT,C'4'\n         SPACE 1\n*------- ANALYZE PARM. FIELD, SET EVENTUAL OUTPUT DENSITY\n*------- AND/OR VOLUME SERIAL NUMBER AS REQUESTED.\n         SPACE 1\nPARM     LH    R0,0(R9)\n         LTR   R0,R0\n         BNP   SENSEND\n         LA    R9,2(R9)\n         AR    R0,R9\nDEN      TM    SENSEND+1,ON\n         BO    TESTEV\n         CLC   0(4,R9),=CL4'DEN='  PARM : DEN= OR D= *****************\n         BNE   DEN0\n         LA    R9,2(R9)\n         B     DEN1\nDEN0     CLC   0(2,R9),=CL2'D='\n         BNE   TESTSER\nDEN1     LA    R9,2(R9)\n         TM    DVTYPO+3,UCB3480\n         BO    SKIPDEN\n         CLI   0(R9),C'2'\n         BNE   DEN2\n         MVC   MSG2A,=CL4' 800'\n         MVI   COPY+(DCBDEN-IHADCB),DCBMTDN2\n         MVI   CCWCONTR,MS800\n         MVI   CCWMS,MS800\n         B     AFTERDEN\nDEN2     CLI   0(R9),C'3'\n         BNE   DEN3\n         MVC   MSG2A,=CL4'1600'\n         MVI   COPY+(DCBDEN-IHADCB),DCBMTDN3\n         MVI   CCWCONTR,MS1600\n         MVI   CCWMS,MS1600\n         B     AFTERDEN\nDEN3     CLI   0(R9),C'4'\n         BNE   PARMERR\n         MVC   MSG2A,=CL4'6250'\n         MVI   COPY+(DCBDEN-IHADCB),DCBMTDN4\n         MVI   CCWCONTR,MS6250\n         MVI   CCWMS,MS6250\nAFTERDEN MVC   DENOUT(1),0(R9)\n         OI    SWPF,PFDEN\nSKIPDEN  LA    R9,1(R9)\n         B     CONT\nTESTSER  CLC   0(4,R9),=CL4'SER='  PARM : SER= OR S= *****************\n         BNE   SER0\n         LA    R9,2(R9)\n         B     SER1\nSER0     CLC   0(2,R9),=CL2'S='\n         BNE   TESTCS\nSER1     LA    R9,2(R9)\n         XR    R1,R1\n         LR    R5,R9\n         LA    R6,L'LABOUT+1\nLOOPSER  CLR   R9,R0\n         BNL   ENDSER\n         CLI   0(R9),C','\n         BE    ENDSER\n         LA    R9,1(R9)\n         LA    R1,1(R1)\n         BCT   R6,LOOPSER\n         B     PARMERR\nENDSER   LTR   R1,R1\n         BZ    CONT\n         TM    DVTYPO+3,UCB3480\n         BO    CONT\n         BCT   R1,*+L'*+6\n         MVC   LABOUT(*-*),0(R5)\n         EX    R1,*-6\n         NI    SERBC+1,OFF\n         OI    SWPF,PFSER\n         B     CONT\nTESTCS   CLC   0(8,R9),=CL8'COPYSKIP'   PARM : COPYSKIP OR C *********\n         BNE   CSKIP0\n         LA    R9,7(R9)\n         B     CSKIP1\nCSKIP0   CLI   0(R9),C'C'\n         BNE   TESTADD\nCSKIP1   LA    R9,1(R9)\nCSKIPSW  NOP   ERRAC\n         OI    ADDTSW+1,ON\n         OI    SWCTM+1,ON\n         NI    SWLAST+1,OFF\n         OI    SWPF,PFSKP\n         B     CONT\nTESTADD  CLC   0(3,R9),=CL3'ADD'   PARM : ADD OR A *******************\n         BNE   ADDT0\n         LA    R9,2(R9)\n         B     ADDT1\nADDT0    CLI   0(R9),C'A'\n         BNE   TESTV\nADDT1    LA    R9,1(R9)\nADDTSW   NOP   ERRAC\n         OI    CSKIPSW+1,ON\n         NI    EXCPOUT+1,OFF\n         NI    SWAD+1,OFF\n         OI    SWPF,PFADD\n         B     CONT\nTESTV    CLC   0(2,R9),=CL2'V='    PARM : V= *************************\n         BNE   TESTQ\n         LA    R9,2(R9)\n         XR    R1,R1\n         LR    R5,R9\n         LA    R6,L'ZONE\nLOOPV    CLR   R9,R0\n         BNL   ENDV\n         CLI   0(R9),C','\n         BE    ENDV\n         LA    R9,1(R9)\n         LA    R1,1(R1)\n         BCT   R6,LOOPV\n         B     PARMERR\nENDV     LTR   R1,R1\n         BZ    CONT\n         MVC   ZZER,=CL5'00000'\n         MVC   ZONE,=CL5'00000'\n         LA    R6,ZONE+L'ZONE\n         SR    R6,R1\n         BCTR  R1,0\n         STC   R1,MOVEV+1\nMOVEV    MVC   0(*-*,R6),0(R5)\n         MVN   ZZER,ZONE\n         TR    ZZER,TRTAB-X'F0'\n         CLC   ZZER,ZONE\n         BNE   PARMERR\n         CLC   ZONE,=CL5'00000'\n         BE    PARMERR\n         PACK  VQS,ZONE\n         B     CONT\nTESTQ    CLC   0(2,R9),=CL2'Q='    PARM : Q= *************************\n         BNE   TESTBLK\n         LA    R9,2(R9)\n         XR    R1,R1\n         LR    R5,R9\n         LA    R6,L'ZONE\nLOOPQ    CLR   R9,R0\n         BNL   ENDQ\n         CLI   0(R9),C','\n         BE    ENDQ\n         LA    R9,1(R9)\n         LA    R1,1(R1)\n         BCT   R6,LOOPQ\n         B     PARMERR\nENDQ     LTR   R1,R1\n         BZ    CONT\n         MVC   ZZER,=CL5'00000'\n         MVC   ZONE,=CL5'00000'\n         LA    R6,ZONE+L'ZONE\n         SR    R6,R1\n         BCTR  R1,0\n         STC   R1,MOVEQ+1\nMOVEQ    MVC   0(*-*,R6),0(R5)\n         MVN   ZZER,ZONE\n         TR    ZZER,TRTAB-X'F0'\n         CLC   ZZER,ZONE\n         BNE   PARMERR\n         CLC   ZONE,=CL5'00000'\n         BE    PARMERR\n         PACK  DSQS,ZONE\n         B     CONT\nTESTBLK  CLC   0(8,R9),=CL8'BLKCOUNT'   PARM : BLKCOUNT OR B *********\n         BNE   BLKCNT0\n         LA    R9,7(R9)\n         B     BLKCNT1\nBLKCNT0  CLI   0(R9),C'B'\n         BNE   TESTNOV\nBLKCNT1  LA    R9,1(R9)\n         NI    CTLBLKC+1,OFF\n         B     CONT\nTESTNOV  CLC   0(7,R9),=CL7'NOVEROP'    PARM : NOVEROP OR N **********\n         BNE   NOVER0\n         LA    R9,6(R9)\n         B     NOVER1\nNOVER0   CLI   0(R9),C'N'\n         BNE   TESTEV\nNOVER1   LA    R9,1(R9)\n         OI    SWVER+1,ON          BYPASS ADVICE TO OPERATOR.\n         B     CONT\nTESTEV   CLC   0(5,R9),=CL5'EVEN=' PARM : EVEN= OR E= ****************\n         BNE   EV0\n         LA    R9,3(R9)\n         B     EV1\nEV0      CLC   0(2,R9),=CL2'E='\n         BNE   TESTFR\nEV1      LA    R9,2(R9)\n         XR    R1,R1\n         LR    R5,R9\n         LA    R6,L'ZONE+1\nLOOPEV   CLR   R9,R0\n         BNL   ENDEV\n         CLI   0(R9),C','\n         BE    ENDEV\n         LA    R9,1(R9)\n         LA    R1,1(R1)\n         BCT   R6,LOOPEV\n         B     PARMERR\nENDEV    LTR   R1,R1\n         BZ    CONT\n         MVC   ZZER,=CL5'00000'\n         MVC   ZONE,=CL5'00000'\n         LA    R6,ZONE+L'ZONE\n         SR    R6,R1\n         BCTR  R1,0\n         STC   R1,MOVEEV+1\nMOVEEV   MVC   0(*-*,R6),0(R5)\n         MVN   ZZER,ZONE\n         TR    ZZER,TRTAB-X'F0'\n         CLC   ZZER,ZONE\n         BNE   PARMERR\n         CLC   ZONE,=CL5'00000'\n         BE    PARMERR\n         PACK  EVCNT,ZONE\n         OI    SWPF,PFEV\n         B     CONT\nTESTFR   CLC   0(5,R9),=CL5'FORCE' PARM : FORCE OR F *****************\n         BNE   FORCE0\n         LA    R9,4(R9)\n         B     FORCE1\nFORCE0   CLI   0(R9),C'F'\n         BNE   TESTCSP\nFORCE1   LA    R9,1(R9)\n         NI    SWFRC+1,OFF\n         L     R5,ATIOT            TIOT ADDRESS.\n         USING TIODSECT,R5\n         XR    R6,R6\nFRCSC    CLC   TIOELNGH(4),=XL4'0' TIOT END?\n         BE    CONT                YES.\n         CLC   TIOEDDNM,DDFR\n         BE    FRCFND\n         IC    R6,TIOELNGH         GET IN R6 DD ENTRY LENGTH.\n         AR    R5,R6               R5 POINTS TO NEXT DD ENTRY.\n         B     FRCSC\n         DROP  R5\nFRCFND   NI    SWERR+1,OFF\n         B     CONT\nERRAC    LA    R10,MSGERAC\n         B     PRTERR\nPARMERR  LA    R10,MSGPERR\n         B     PRTERR\nCONT     CLR   R9,R0\n         BNL   ENDPARM\nTESTCSP  CLI   0(R9),C','\n         BNE   ERRAC\n         LA    R9,1(R9)\n         CLR   R9,R0\n         BL    DEN\nENDPARM  TM    SWPF,PFSKP\n         BZ    *+L'*+4\n         OI    CTLBLKC+1,ON\n         TM    SWPF,PFADD\n         BZ    SENSEND\n         TM    SWPF,PFSER\n         BZ    ERRAC\n         TM    DVTYPO+3,UCB3480\n         BO    SENSEND\n         TM    SWPF,PFDEN\n         BZ    ERRAC\nSENSEND  B     CHECKIN\n         TM    DVTYPO+3,UCB3480\n         BO    OKDEN\n         CLI   COPY+(DCBDEN-IHADCB),DCBMTDN3\n         BE    OKDEN\n         CLI   COPY+(DCBDEN-IHADCB),DCBMTDN2\n         BNE   TU6250\n         CLC   DVTYPO(2),=X'3420'  DENSITY 800 BPI.\n         BE    OKDEN\n         B     ERRDEV\nCHECKIN  L     R15,=A(ANTPCKA)     CHECK ANALYZE OPERATION.\n         BASR  R14,R15\n         LTR   R15,R15\n         BZ    PUTDENM\nCHECKERR LA    R10,MSGERCK\n         B     PRTERR\nTU6250   CLC   DVTYPO(2),=X'3210'  DENSITY 6250 BPI.\n         BNE   ERRDEV\n         SPACE 1\n*------- OPEN SYSUT2.\n         SPACE 1\nOKDEN    XC    JF(176),JF\n        RDJFCB (COPY)              GET JOB FILE CONTROL BLOCK.\n         LTR   R15,R15\n         BZ    *+L'*+8\n         LA    R10,MSGERJF\n         B     PRTERR\n         L     R15,=A(TTR)         JFCB OF SYSUT2 (SYSTEST).\n         BASR  R14,R15\n         DC    H'2' - - - - - - - - - - - - - - - - - - - - TRACE    2\n         LA    R1,JF\n         USING JFCB,R1\n         TM    JFCBLTYP,JFCBLP     CHECK LABEL=(...,BLP) CODED.\n         BO    *+L'*+8\n         LA    R10,MSGERBL\n         B     PRTERR\n         MVC   OPADV4B,JFCBVOLS    GET VOLUME SERIAL NUMBER.\n         MVC   MSGCOPYD,JFCBVOLS\n         TM    DVTYPO+3,UCB3480\n         BZ    NOT3480\n         MVC   LABOUT,JFCBVOLS\n         MVC   OPADV2A,=CL4'3480'\n         MVC   OPADV3A,=CL9'CARTRIDGE'\n         MVC   MSGCOPYC,=CL4'3480'\nNOT3480  L     R15,=A(ANTPCKC)     CHECK COPY OPERATION.\n         BASR  R14,R15\n         LTR   R15,R15\n         BNZ   CHECKERR\n         L     R15,=A(FSEL)        SEE IF FILES SELECTION REQUESTED.\n         BASR  R14,R15\n         TM    SWPF,PFADD\n         BZ    NORMOP\n         TM    JFCBIND2,JFCNEW     DISP=NEW?\n         BNO   TDISP               NO\n         TM    JFCBFLG2,JFCMODNW   DISP CHANGED FROM MOD TO NEW?\n         BO    LEAVOP              YES\n         LA    R10,MSGCFL\n         B     PRTERR\nTDISP    TM    JFCBIND2,JFCOLD     DISP=OLD?\n         BO    NOBSRMT             YES\n         TM    JFCBIND2,JFCMOD     DISP=MOD?\n         BO    LEAVOP              YES\n         DROP  R1\nNOBSRMT  OI    SWBSR+1,ON          BYPASS STARTING BSR FOR POSITIONING\nLEAVOP  OPEN   (COPY,(OUTPUT,LEAVE)),TYPE=J\n         B     TESTOP\nNORMOP  OPEN   (COPY,(OUTPUT)),TYPE=J\nTESTOP   TM    COPY+(DCBOFLGS-IHADCB),DCBOFOPN\n         BO    OUTOP\n         LA    R10,MSGEROP\n         B     PRTERR\nOUTOP    NI    CLSCPY+1,OFF\nSWVER    NOP   RPOK\n         LA    R1,OPADV1           ADVICE OPERATOR.\n        WTO    MF=(E,(1))\n         ST    R1,RDOM\n         LA    R1,OPADV2\n        WTO    MF=(E,(1))\n         ST    R1,RDOM+4\n         LA    R1,OPADV3\n        WTO    MF=(E,(1))\n         ST    R1,RDOM+8\n         OI    RDOM+8,X'80'\n         LA    R1,OPADV4\n        WTOR   MF=(E,(1))\n        WAIT   ECB=RECB            WAIT OPERATOR RESPONSE.\n        DOM    MSGLIST=RDOM\nRPLY     OC    RAREA(3),=CL3'   '\n         CLI   RAREA,C'Y'\n         BE    RPOK\n         CLC   RAREA(3),=CL3'YES'\n         BE    RPOK\n         CLI   RAREA,C'N'\n         BE    RPNO\n         CLC   RAREA(2),=CL2'NO'\n         BE    RPNO\n         XC    RAREA,RAREA         CLEAR REPLY AREA.\n         XC    RECB,RECB           CLEAR ECB.\n         LA    R1,OPADVR\n        WTOR   MF=(E,(1))\n        WAIT   ECB=RECB            WAIT OPERATOR RESPONSE.\n         B     RPLY\nRPNO     NI    COPY+(DCBOFLGS-IHADCB),255-DCBOFLWR\n         OI    COPY+(DCBOFLGS-IHADCB),DCBOFTM\n         LA    R10,MSGREJ\n         B     PRTERR\nRPOK     NI    TM+1,OFF\n         NI    OUTREC+1,OFF\n         NI    CLSOUT+1,OFF\n         TM    SWPF,PFSKP\n         BO    OUTB\n         NI    SWCTM+1,OFF\nOUTB     BAS   R3,EXCPOUT\nPUTDENM  TM    SENSEND+1,ON\n         BZ    *+L'*+8\n         LA    R10,MSGANAL\n         B     *+L'*+16\n         MVC   MSGCOPYA,MSGANALA\n         MVC   MSGCOPYB,MSGANALB\n         LA    R10,MSGCOPY\n         BAS   R3,PUTMSG\n         TM    SENSEND+1,ON\n         BO    *+L'*+12\n         TM    DVTYPO+3,UCB3480\n         BO    *+L'*+20\n         B     *+L'*+8\n         TM    DVTYPI+3,UCB3480\n         BO    *+L'*+8\n         LA    R10,MSG2\n         BAS   R3,PUTMSG\n         SPACE 1\n*------- READ SYSUT1.\n         SPACE 1\n         LA    R10,CCWREAD\n         ST    R10,CCWIN\n         BAS   R3,EXCPIN\n         XR    R4,R4\n         ICM   R4,B'0111',CCWREAD+1\n         CLC   0(4,R4),=CL4'VOL1'\n         BE    SETLB\n         NI    COUNT+1,OFF\n         B     NONSTD\nSETLB    NI    SWLB+1,OFF\nSWAD     B     LABELMSG\n         NI    MTTM+1,OFF\n         NI    SWNP+1,OFF\n         OI    SWAD+1,ON\n         B     LABELMSG\nROUTHDR  CLI   3(R4),C'2'          PROCESS EVENTUAL HDR2.\n         BNE   LABELMSG\n         PACK  CTRECL,10(5,R4)\n         CLI   4(R4),C'U'\n         BNE   TFIX\n         OI    UUU+1,ON\n         B     LABELMSG\nTFIX     CLI   4(R4),C'F'\n         BNE   VARB\n         OI    FFF+1,ON\n         NI    LRECL+1,OFF\n         MVC   MSGDA(L'MSGDA),10(R4)\n         B     LABELMSG\nVARB     OI    VU+1,ON\nLABELMSG B     LAB\n         S     R4,=F'1'\n         OI    LABELMSG+1,ON\nLAB      NOP   NOSK\n         OI    LAB+1,ON\n         LA    R10,SPACE\n         BAS   R3,PUTMSG\nNOSK     MVC   AREAMSG+1(80),0(R4)\nSWNP     B     PVOL1\n         OI    SWNP+1,ON\n         MVC   MSGHA(L'MSGHA),4(R4)\n         LA    R10,MSGH\n         BAS   R3,PUTMSG\n         LA    R10,SPACE\n         B     PVOL1+L'PVOL1\nPVOL1    LA    R10,AREAMSG\n         BAS   R3,PUTMSG\nSTD      BAS   R3,EXCPIN\n         CLI   SWTMIN,0\n         BE    LABEL\n         CLI   SWTMIN,2\n         BE    RESET\n         B     STD\n         SPACE 1\n*------- LABELS CONTROL.\n         SPACE 1\nLABEL    LA    R5,LABELS\n         LA    R6,LABELNO\n         CLC   0(3,R4),0(R5)\n         BE    WTOGO\n         LA    R5,L'LABELS(R5)\n         BCT   R6,*-14\nNONSTD   NOP   DATA\n         OI    NONSTD+1,ON\n         NI    LABELMSG+1,OFF\n         A     R4,=F'1'\n         B     LABEL\nWTOGO    IC    R6,3(R5)\n         B     *+L'*(R6)\n         B     LABELMSG\n         B     ROUTHDR\nLABELS   EQU   *,4\n         DC    CL3'HDR',AL1(4)\n         DC    CL3'EOF',AL1(0)\n         DC    CL3'EOV',AL1(0)\n         DC    CL3'UHL',AL1(0)\n         DC    CL3'UTL',AL1(0)\nLABELNO  EQU   (*-LABELS)/(L'LABELS)\n         SPACE 1\n*------- SAVE INFORMATION ABOUT TYPE AND LENGTH OF INPUT RECORDS.\n         SPACE 1\nDATA     L     R6,=F'32767'\n         OI    TMARK+1,ON\n         LH    R5,CSWIN+6\n         AP    CTRBLK,=PL1'1'\n         SR    R6,R5\n         CVD   R6,WORKD\n         CP    WORKD,TABVRBL(4)\n         BNH   MIN\n         MVC   TABVRBL(4),WORKD+4\nMIN      CP    WORKD,TABVRBL+4(4)\n         BNL   LOAD\n         MVC   TABVRBL+4(4),WORKD+4\n         SPACE 1\n*------- SAVE LAST THREE READ RECORDS LENGTH ROUTINE.\n         SPACE 1\nLOAD     NOP   *+L'*+8\n         LA    R7,TABCONTR\n         LA    R2,3\n         MVC   0(4,R7),0(R4)\n         MVC   4(4,R7),WORKD+4\n         LA    R7,8(R7)\n         OI    LOAD+1,ON\n         BCT   R2,*+L'*+4\n         NI    LOAD+1,OFF\n         BAS   R3,EXCPIN\n         CLI   SWTMIN,0\n         BNE   UUU\n         XR    R4,R4\n         ICM   R4,B'0111',CCWREAD+1\n         B     NONSTD\n         SPACE 1\n*------- END OF FILE - PROCESS INFORMATION ABOUT RECORDS FORMAT.\n         SPACE 1\nUUU      NOP   UNDEFIND\nFFF      NOP   FIXED\nVU       NOP   VARIABLE\n         NI    LOAD+1,OFF\n         ZAP   WORKP,TABCONTR+4(4)\n         AP    WORKP(4),TABCONTR+12(4)\n         LH    R0,TABCONTR\n         AH    R0,TABCONTR+8\n         CVD   R0,WORKD\n         CP    WORKD,WORKP\n         BE    VARIABLE\n         CP    TABVRBL(4),TABVRBL+4(4)\n         BE    FIXED\n         SPACE 1\n*------- UNDEFINED RECORDS.\n         SPACE 1\nUNDEFIND MVC   MSGAA,=CL9'UNDEFINED'\n         LA    R10,MSGA\n         BAS   R3,PUTMSG\n         UNPK  MSGGA(L'MSGGA),TABVRBL(4)\n         OI    MSGGA+L'MSGGA-1,C'0'\n         LA    R10,MSGG\n         BAS   R3,PUTMSG\n         UNPK  MSGIA(L'MSGIA),TABVRBL+4(4)\n         OI    MSGIA+L'MSGIA-1,C'0'\n         LA    R10,MSGI\n         BAS   R3,PUTMSG\n         B     NUMBER\n         SPACE 1\n*------- VARIABLE RECORDS.\n         SPACE 1\nVARIABLE MVC   MSGAA,=CL9'VARIABLE '\n         LA    R10,MSGA\n         BAS   R3,PUTMSG\n         CP    TABVRBL+4(4),TABVRBL(4)\n         BE    ONLY\n         UNPK  MSGFA(L'MSGFA),TABVRBL+4(4)\n         MVI   MSGFB+1,C'-'\n         UNPK  MSGFC(L'MSGFC),TABVRBL(4)\n         OI    MSGFC+L'MSGFC-1,C'0'\n         B     VMSG\nONLY     MVC   MSGFB+1(L'MSGFB+L'MSGFC-1),MSGFB\n         UNPK  MSGFA(L'MSGFA),TABVRBL(4)\nVMSG     OI    MSGFA+L'MSGFA-1,C'0'\n         LA    R10,MSGF\n         BAS   R3,PUTMSG\n         B     NUMBER\n         SPACE 1\n*------- FIXED RECORDS.\n         SPACE 1\nFIXED    MVC   MSGAA,=CL9'FIXED    '\n         LA    R10,MSGA\n         BAS   R3,PUTMSG\nLRECL    B     BLK\n         LA    R10,MSGD\n         BAS   R3,PUTMSG\nBLK      UNPK  MSGBA(L'MSGBA),TABVRBL(4)\n         OI    MSGBA+L'MSGBA-1,C'0'\n         LA    R10,MSGB\n         BAS   R3,PUTMSG\n         S     R7,=F'4'\n         UNPK  MSGEA(L'MSGEA),0(4,R7)\n         OI    MSGEA+L'MSGEA-1,C'0'\n         LA    R10,MSGE\n         BAS   R3,PUTMSG\n         SPACE 1\n*------- PROCESS REUSABLE FIELDS JUST IN CASE THERE ARE MULTI-FILES.\n         SPACE 1\nNUMBER   UNPK  MSGCA(L'MSGCA),CTRBLK\n         OI    MSGCA+L'MSGCA-1,C'0'\n         MVC   CTRBLKL(6),MSGCA+1\n         LA    R10,MSGC\n         BAS   R3,PUTMSG\n         BAS   R3,COUNT\n         LA    R10,MSG1\n         BAS   R3,PUTMSG\nRESET    MVC   MSG1A(L'MSG1A),MSG1A-1\n         NI    TMARK+1,OFF\n         NI    UUU+1,OFF\n         NI    FFF+1,OFF\n         NI    VU+1,OFF\n         NI    LOAD+1,OFF\n         OI    LRECL+1,ON\n         NI    NONSTD+1,OFF\n         OI    LABELMSG+1,ON\n         NI    LAB+1,OFF\n         XR    R4,R4\n         ICM   R4,B'0111',CCWREAD+1\n         SP    CTRBLK,CTRBLK\n         SP    WORKP,WORKP\n         SP    TABVRBL(4),TABVRBL(4)\n         ZAP   TABVRBL+4(4),=PL4'99999'\n         MVC   TABCONTR(8),=PL8'0'\n         MVC   TABCONTR+8(8),=PL8'0'\n         MVC   TABCONTR+16(8),=PL8'0'\n         B     STD\n         SPACE 1\n*------- PRINT MESSAGES ROUTINE.\n         SPACE 1\nPUTMSG  $PRINT (R10)\n         LTR   R10,R15\n         BNZ   CLSCPY\n         BR    R3\n         SPACE 1\n*------- READ SYSUT1 ROUTINE.\n         SPACE 1\nEXCPIN   ST    R3,WORKF\n         XC    ECBIN,ECBIN\n         XC    CSWIN,CSWIN\n        EXCP   IOBIN\n        WAIT   ECB=ECBIN\n         TM    SWFS,PFSEL\n         BZ    *+L'*+6\n         L     R15,=A(TFSEL)\n         BASR  R14,R15\n         CLI   ECBIN,X'7F'\n         BE    OK\n         TM    CSWIN+4,X'01'\n         BO    TRTS\nSWFRC    B     ERROR\n         UNPK  MSGFRCA(L'MSGFRCA),CTRBLK\n         OI    MSGFRCA+L'MSGFRCA-1,C'0'\n         LA    R10,MSGFRC\n         BAS   R3,PUTMSG\nSWERR    B     OK\n         MVI   SWTMIN,0\n         MVC   DDSNAP,DDFR\n         B     SNAPR\nERROR    BAS   R9,ABEND\n         LA    R10,MSG4\n         BAS   R3,PUTMSG\n         LA    R10,16              R.C. = 16. - - - - - - - - - - - - -\n         B     CLSOUT\nOK       MVI   SWTMIN,0\nSWTR     B     OUTREC\nFIRST    NOP   OUTREC\n         OI    FIRST+1,ON          TRACE ONLY FIRST OF A FILE.\n         MVC   DDSNAP,DDTR\nSNAPR    L     R6,=F'32767'\n         LH    R5,CSWIN+6\n         SR    R6,R5\n         BNP   OUTREC\n         CH    R6,=H'1024'\n         BNH   *+L'*+4\n         LH    R6,=H'1024'\n         ST    R6,TRLG\n         L     R15,ABUF\n        $SNAP  (R15),TRLG,DDSNAP\n         LTR   R15,R15\n         BZ    OUTREC\n         STC   R15,MSG8+L'MSG8-2\n         OI    MSG8+L'MSG8-2,C'0'\n         LA    R10,MSG8\n         BAS   R3,PUTMSG\nOUTREC   B     LOADUN\n         L     R6,=F'32767'\n         LH    R5,CSWIN+6\n         SR    R6,R5\n         STH   R6,CCWWRITE+6\n         LA    R3,CCWCONTR\n         ST    R3,CCWOUT\n         BAS   R3,EXCPOUT\nLOADUN   L     R3,WORKF\n         BR    R3\nTRTS     TM    SWTR+1,ON\n         BO    TM\n         NI    FIRST+1,OFF         OPEN TRACE OF FIRST RECORD.\nTM       B     TMARK\nSWCTM    B     NOTCPY\n         MVI   CCWNOP,TCCWTM\n         LA    R3,CCWMS\n         ST    R3,CCWOUT\n         BAS   R3,EXCPOUT\n         B     TMARK\nNOTCPY   MVC   MSG1A,=CL12'(NOT COPIED)'\nTMARK    NOP   CLSWTM\n         BAS   R3,COUNT\n         LA    R10,MSG1\n         BAS   R3,PUTMSG\n         MVC   MSG1A(L'MSG1A),MSG1A-1\n         NI    LAB+1,OFF\nCLSWTM   L     R3,WORKF\n         CLI   SWTMIN,1\n         BH    STCLS\n         BL    RDRET\n         TM    SWLB+1,ON\n         BZ    TESTSL\n         TM    SWPF,PFEV           SEE IF EMPTY NL-FILES TO HANDLE.\n         BZ    CLSIMM\n         TM    COUNT+1,ON\n         BO    CLSIMM\n         CP    TMCNT,EVCNT\n         BNL   CLSIMM\nRDRET    MVI   SWTMIN,1\n         BR    R3\nTESTSL   L     R1,ABUF\n         CLC   0(4,R1),=CL4'HDR2'  CONTINUE OVER EMPTY SL-FILE.\n         BNE   CLSIMM\n         MVI   SWTMIN,2\n         BR    R3\nCOUNT    NOPR  R3\nSWLB     B     SETCNT\n         XR    R4,R4\n         ICM   R4,B'0111',CCWREAD+1\n         CLC   0(4,R4),=CL4'EOF2'\n         BNER  R3\n         XC    0(4,R4),0(R4)\nSETCNT   AP    TMCNT,=PL1'1'\n         MVC   MSG1A,=CL12'(     ) ----'\n         UNPK  MSG1A+1(5),TMCNT\n         OI    MSG1A+5,C'0'\n         BR    R3\n         SPACE 1\n*------- WRITE SYSUT2 ROUTINE.\n         SPACE 1\nEXCPOUT  B     NOMTF\n         L     R10,CCWOUT\n         CLI   8(R10),TCCWRT\n         BNE   NOMTF\n         OI    EXCPOUT+1,ON\n         ST    R10,SVMT            OUTPUT TAPE POSITIONING.\nSWBSR    NOP   SRCHMT\nBACK     LA    R10,CCWBSR\n         ST    R10,CCWOUT\n         BAS   R10,EXCPMT\n         AP    BPOS,=PL1'1'\n         CP    BPOS,=PL2'5'\n         BNE   BACK\nSRCHMT   LA    R10,CCWPOS\n         ST    R10,CCWOUT\n         BAS   R10,EXCPMT\n         TM    CSWOUT+4,X'01'\n         BO    TSTM\n         MVI   SWTMOUT,0\nSWBYD    NOP   SWBYS\n         L     R1,AALT\n         CLC   0(4,R1),=CL4'HDR2'\n         BE    TSD\n         CLC   0(4,R1),=CL4'EOF2'\n         BNE   SWBYS\nTSD      CLC   15(1,R1),DENOUT\n         BNE   ERRDS\n         OI    SWBYD+1,ON\n         OI    SWPF,PFHE2\n         B     SRCHMT\nSWBYS    NOP   SRCHMT\n         L     R1,AALT\n         CLC   0(4,R1),=CL4'HDR1'\n         BE    TSS\n         CLC   0(4,R1),=CL4'EOF1'\n         BNE   SRCHMT\nTSS      CLC   21(L'LABOUT,R1),LABOUT\n         BNE   ERRDS\n         OI    SWBYS+1,ON\n         OI    SWPF,PFHE1\n         CP    VQS,=PL1'0'\n         BNE   *+L'*+6\n         PACK  VQS,27(4,R1)        GET VOLUME SEQUENCE NUMBER.\n         CP    DSQS,=PL1'0'\n         BNE   SRCHMT\n         PACK  DSQS,31(4,R1)       GET DATA-SET SEQUENCE NUMBER.\n         AP    DSQS,=PL1'1'\n         B     SRCHMT\nERRDS    TM    DVTYPO+3,UCB3480\n         BZ    *+L'*+8\n         LA    R10,MSGERDD\n         B     *+L'*+4\n         LA    R10,MSGERDS\n         BAS   R3,PUTMSG\n         B     ERRRET\nTSTM     CLI   SWTMOUT,1\n         BH    NOMT\n         BE    MTTM\n         MVI   SWTMOUT,1\n         B     SRCHMT\nMTTM     B     NOMT\n         L     R1,AALT\n         CLC   0(4,R1),=CL4'HDR2'  CONTINUE OVER EMPTY SL-FILE.\n         BNE   NOMT\n         MVI   SWTMOUT,2\n         B     SRCHMT\nNOMT     LA    R10,CCWBSR\n         ST    R10,CCWOUT\n         BAS   R10,EXCPMT\n         CLI   SWTMOUT,1\n         BE    *+L'*+4\n         BAS   R10,EXCPMT\n         TM    SWPF,PFHE1+PFHE2\n         BM    ERRDS\n         L     R10,SVMT\n         ST    R10,CCWOUT\n         LA    R10,8(R10)\n         XC    RESOUT+1(3),RESOUT+1\n         O     R10,RESOUT\n         ST    R10,RESOUT\n         L     R1,ABUF\n         CLC   0(4,R1),=CL4'VOL1'\n         BNE   SERBC\n         BR    R3\nEXCPMT   BAS   R9,ANALOP\n         CLI   ECBOUT,X'7F'\n         BER   R10\n         TM    CSWOUT+4,X'01'\n         BOR   R10\n         MVI   MSG5+L'MSG5-3,C'P'\n         B     ERRP\nNOMTF    L     R1,ABUF\nSERBC    B     TESTBC\n         CLC   0(4,R1),=CL4'VOL1'\n         BNE   SERHDR\n         MVC   4(L'LABOUT,R1),LABOUT\n         B     RSTECB\nSERHDR   CLC   0(4,R1),=CL4'HDR1'\n         BE    PUTSER\n         CLC   0(4,R1),=CL4'EOV1'\n         BE    CTLBLKC\n         CLC   0(4,R1),=CL4'EOF1'\n         BNE   SETDEN\nCTLBLKC  B     PUTSER\n         MVC   54(6,R1),CTRBLKL\nPUTSER   MVC   21(L'LABOUT,R1),LABOUT\n         CP    VQS,=PL1'0'\n         BE    SQNT\n         UNPK  27(4,R1),VQS        SET VOLUME SEQUENCE NUMBER.\n         OI    30(R1),C'0'\nSQNT     CP    DSQS,=PL1'0'\n         BE    RSTECB\n         UNPK  31(4,R1),DSQS       SET DATA-SET SEQUENCE NUMBER.\n         OI    34(R1),C'0'\n         CLC   0(4,R1),=CL4'HDR1'\n         BE    RSTECB\n         AP    DSQS,=PL1'1'\n         B     RSTECB\nTESTBC   TM    CTLBLKC+1,ON\n         BNZ   SETDEN\n         CLC   0(4,R1),=CL4'EOV1'\n         BE    *+L'*+10\n         CLC   0(4,R1),=CL4'EOF1'\n         BNE   RSTECB\n         MVC   54(6,R1),CTRBLKL\n         B     RSTECB\nSETDEN   CLC   0(4,R1),=CL4'HDR2'\n         BE    *+L'*+10\n         CLC   0(4,R1),=CL4'EOF2'\n         BNE   RSTECB\n         MVC   15(1,R1),DENOUT\nRSTECB   BAS   R9,ANALOP\n         CLI   ECBOUT,X'7F'\n         BER   R3\nERRP     LA    R10,MSG5\n         BAS   R3,PUTMSG\nERRRET   LA    R10,20              R.C. = 20. - - - - - - - - - - - - -\n         B     CLSOUT\n         SPACE 1\n*------- SYSUT2 EXCP AND CHECKS.\n         SPACE 1\nANALOP   NI    SWRS+1,OFF\nRESTART  MVI   ECBOUT,0\n         XC    IOBOUT+2(2),IOBOUT+2\n         XC    CSWOUT,CSWOUT\n        EXCP   IOBOUT\n        WAIT   ECB=ECBOUT\n         CLI   ECBOUT,X'7F'\n         BER   R9\n         CLI   ECBOUT,X'41'\n         BNE   SWRS\n         CLI   CSWOUT+4,X'0D'\n         BNE   ABEND\n         MVI   MSG5+L'MSG5-3,C'E'\n         BR    R9\nSWRS     NOP   ABEND\n         CLI   ECBOUT,X'44'\n         BNE   ABEND\n         OI    SWRS+1,ON\n         B     RESTART\nABEND    L     R1,ATIOT\n         USING TIODSECT,R1\n         XR    R0,R0\nSCSYS    CLC   TIOELNGH(4),=XL4'0'\n         BER   R9\n         CLC   TIOEDDNM,=CL8'SYSUDUMP'\n         BE    DUMP\n         CLC   TIOEDDNM,=CL8'SYSABEND'\n         BE    DUMP\n         IC    R0,TIOELNGH\n         AR    R1,R0\n         B     SCSYS\n         DROP  R1\nDUMP    ABEND  1,DUMP              ABEND U0001. - - - - - - - - - - - -\n         SPACE 1\n*------- CLOSE SYSUT2 IF PRESENT AND NECESSARY.\n         SPACE 1\nCLSIMM   TM    TMARK+1,ON\n         BZ    STCLS\n         LA    R10,MSG1            2ND TAPE-MARK AT START TIME.\n         BAS   R3,PUTMSG\nSTCLS    XR    R10,R10             R.C. = 0. - - - - - - - - - - - - -\nCLSOUT   B     CLSTPE\nSWLAST   B     CLSCPY\n         MVI   CCWNOP,TCCWTM\n         LA    R3,CCWMS\n         ST    R3,CCWOUT\n         BAS   R3,EXCPOUT\n         BAS   R3,EXCPOUT\n        $PRINT MSG6\nCLSCPY   B     CLSTPE\n        CLOSE  (COPY,DISP)\n         SPACE 1\n*------- CLOSE SYSUT1, END OF WORK.\n         SPACE 1\nCLSTPE   B     CLSPRT\n         LA    R1,CCWBSR           POSITION INPUT TO BE CLOSED.\n         ST    R1,CCWIN\n         XC    ECBIN,ECBIN\n         XC    CSWIN,CSWIN\n        EXCP   IOBIN\n        WAIT   ECB=ECBIN\n        CLOSE  (TAPE,REWIND)\nCLSPRT   B     EXIT\n        $PCLOSE\nEXIT     ICM   R1,B'1111',ATBFSL\n         BZ    QUIT\n         L     R0,=A(4*1024)       FREE FILES NUMBERS SPACE.\n        FREEMAIN R,A=(1),LV=(0)\nQUIT     L     R0,=A(32*1024)      FREE BUFFERS SPACE.\n         SLL   R0,1\n         L     R1,ABUF\n        FREEMAIN R,A=(1),LV=(0)\n        $XRET  CC=(R10)\n         EJECT\n*        -----------------------------------\n*        CONSTANTS, MESSAGES AND WORK-AREAS.\n*        -----------------------------------\n         SPACE 1\nWORKD    DC    D'0'\n         SPACE 1\n*------- IOB FOR SYSUT1.\n         SPACE 1\nECBIN    DC    F'0'\nIOBIN    DC    X'42000000'\n         DC    A(ECBIN)\nCSWIN    DC    XL8'0'\nCCWIN    DC    A(CCWREAD)\n         DC    A(TAPE)\n         DC    2F'0'\n         SPACE 1\n*------- IOB FOR SYSUT2.\n         SPACE 1\nECBOUT   DC    F'0'\nIOBOUT   DC    X'42000000'\n         DC    A(ECBOUT)\nCSWOUT   DC    XL8'0'\nCCWOUT   DC    A(CCWNOP)\n         DC    A(COPY)\nRESOUT   DC    2F'0'\n         SPACE 1\n*------- CCW'S FOR SYSUT1.\n         SPACE 1\nCCWSENSE CCW   TCCSNS,SENSE,X'20',L'SENSE\nCCWREAD  CCW   TCCRD,*-*,X'20',32767\nCCWBSR   CCW   TCCBSR,*,X'20',1\nCCWREW   CCW   TCCREW,*,X'20',1\n         SPACE 1\n*------- CCW'S FOR SYSUT2.\n         SPACE 1\nCCWMS    CCW   MS1600,*,X'60',1\nCCWNOP   CCW   TCCNOP,*,X'20',1\nCCWCONTR CCW   MS1600,*,X'60',1\nCCWWRITE CCW   TCCWRT,*-*,X'20',*-*\nCCWPOS   CCW   TCCRD,*-*,X'20',32767\n         SPACE 1\nSENSE    DC    XL8'0'\n         SPACE 2\nABUF     DC    A(*-*)\nAALT     DC    A(*-*)\nATIOT    DC    A(*-*)\nATBFSL   DC    A(*-*)\nFLSQN    DC    F'0'\nFLCPY    DC    F'0'\nFLCTR    DC    F'0'\nRECB     DC    F'0'\nRAREA    DC    XL3'0',X'0'\nRDOM     DC    3F'0'\nJOBFILE  DC    0F'0',XL1'87',AL3(JF)\nJF       DC    0F'0',XL176'0'\nWORKF    DC    F'0'\nSVMT     DC    F'0'\nDVTYPI   DC    2F'0'\nDVTYPO   DC    2F'0'\nTRLG     DC    F'0'\nCTRBLK   DC    PL4'0'\nCTRECL   DC    PL4'0'\nTABVRBL  DC    PL4'0'\n         DC    PL4'99999'\nTABCONTR DC    PL8'0'\n         DC    PL8'0'\n         DC    PL8'0'\nWORKP    DC    PL4'0'\nBPOS     DC    PL2'0'\nTMCNT    DC    PL3'0'\nEVCNT    DC    PL3'0'\nVQS      DC    PL3'0'\nDSQS     DC    PL3'0'\nCTRBLKL  DC    CL6' '\nLABOUT   DC    CL6' '\nDDTR     DC    CL8'SYSANAL '\nDDFR     DC    CL8'SYSERR  '\nDDSNAP   DC    CL8' '\nTRTAB    DC    CL16'0123456789......'\nZZER     DC    CL5'00000'\nZONE     DC    CL5'00000'\nSWTMIN   DC    XL1'0'\nSWTMOUT  DC    XL1'0'\nSWPF     DC    XL1'0'\nPFDEN    EQU   X'01'\nPFSER    EQU   X'02'\nPFADD    EQU   X'04'\nPFSKP    EQU   X'08'\nPFHE1    EQU   X'10'\nPFHE2    EQU   X'20'\nPFEV     EQU   X'40'\nSWFS     DC    XL1'0'\nPFSEL    EQU   X'01'\nPFCHK    EQU   X'02'\nPFSLS    EQU   X'04'\nDENOUT   DC    CL1' '\n         SPACE 2\n         DC    AL1(LMSG1)\nMSG1     DC    C'0         *****  TAPE  MARK  ***** '\nMSG1A    DC    CL12' '\nLMSG1    EQU   *-MSG1\n         DC    AL1(LMSG2)\nMSG2     DC    C'0         ***  TAPE DENSITY '\nMSG2A    DC    CL4' ',C'  ***'\nLMSG2    EQU   *-MSG2\n         DC    AL1(L'MSG3)\nMSG3     DC    C'0SYSUT1 - DD CARD MISSING.'\n         DC    AL1(L'MSG4)\nMSG4     DC    C'0SYSUT1 - I/O ERROR OR PHYSICAL END OF TAPE.'\n         DC    AL1(L'MSG5)\nMSG5     DC    C'0SYSUT2 - I/O ERROR(W).'\n         DC    AL1(L'MSG6)\nMSG6     DC    C'0         ***** COPY CLOSED WITH TWO TAPE MARKS *****'\n         DC    AL1(L'MSG7)\nMSG7     DC    C'1IEBANTP --- ANALYZE/COPY UTILITY'\n         DC    AL1(L'MSG8)\nMSG8     DC    C'0SYSANAL - SNAP ERROR CODE :  .'\n         DC    AL1(LMSGA)\nMSGA     DC    C'0RECORD FORMAT '\nMSGAA    DC    CL9' '\nLMSGA    EQU   *-MSGA\n         DC    AL1(LMSGB)\nMSGB     DC    C' PHYSICAL RECORD LENGTH '\nMSGBA    DC    CL5' '\nLMSGB    EQU   *-MSGB\n         DC    AL1(LMSGC)\nMSGC     DC    C' NO. OF BLOCKS IN THIS FILE '\nMSGCA    DC    CL7' '\nLMSGC    EQU   *-MSGC\n         DC    AL1(LMSGD)\nMSGD     DC    C' LOGICAL RECORD LENGTH '\nMSGDA    DC    CL5' '\nLMSGD    EQU   *-MSGD\n         DC    AL1(LMSGE)\nMSGE     DC    C' LAST BLOCK LENGTH '\nMSGEA    DC    CL5' '\nLMSGE    EQU   *-MSGE\n         DC    AL1(LMSGF)\nMSGF     DC    C' VARIABLE RECORDS LENGTH '\nMSGFA    DC    CL5' '\nMSGFB    DC    C' - '\nMSGFC    DC    CL5' '\nLMSGF    EQU   *-MSGF\n         DC    AL1(LMSGG)\nMSGG     DC    C' UNDEFINED BLOCK LENGTH '\nMSGGA    DC    CL5' '\nLMSGG    EQU   *-MSGG\n         DC    AL1(LMSGH)\nMSGH     DC    C'0         ADDED FROM : '\nMSGHA    DC    CL6' ',C'.'\nLMSGH    EQU   *-MSGH\n         DC    AL1(LMSGI)\nMSGI     DC    C' SHORTEST BLOCK LENGTH '\nMSGIA    DC    CL5' '\nLMSGI    EQU   *-MSGI\n         DC    AL1(LMSGFRC)\nMSGFRC   DC    C'0SYSUT1 - I/O ERROR (REC.NO. '\nMSGFRCA  DC    CL7' ',C')'\nLMSGFRC  EQU   *-MSGFRC\n         DC    AL1(LMSGEROP)\nMSGEROP  DC    C'0SYSUT'\nMSGEROPA DC    C'2',C' - OPEN ERROR.'\nLMSGEROP EQU   *-MSGEROP\n         DC    AL1(LMSGERDV)\nMSGERDV  DC    C'0SYSUT'\nMSGERDVA DC    C'2',C' - INVALID DEVICE.'\nLMSGERDV EQU   *-MSGERDV\n         DC    AL1(L'MSGERDS)\nMSGERDS  DC    C'0SYSUT2 - DEN OR SER DO NOT MATCH PARM. FIELD.'\n         DC    AL1(L'MSGERDD)\nMSGERDD  DC    C'0SYSUT2 - DEN OR SER DO NOT MATCH IN LABELS.'\n         DC    AL1(L'MSGERAC)\nMSGERAC  DC    C' PARM. FIELD KEYWORDS CONFLICT, MISSING OR INVALID.'\n         DC    AL1(L'MSGPERR)\nMSGPERR  DC    C' INVALID DEN= IN PARM. FIELD.'\n         DC    AL1(LMSGERCK)\nMSGERCK  DC    C'0IEBANTP : REQUESTED OPERATION REJECTED. '\nMSGERCKR DC    CL5' ',C'-RC='\nMSGERCKC DC    CL2' ',C'('\nMSGERCKM DC    CL16' ',C')'\nLMSGERCK EQU   *-MSGERCK\n         DC    AL1(LMSGERJF)\nMSGERJF  DC    C'0SYSUT'\nMSGERJFA DC    C'2',C' - READ JOB FILE CONTROL BLOCK ERROR.'\nLMSGERJF EQU   *-MSGERJF\n         DC    AL1(LMSGERBL)\nMSGERBL  DC    C'0SYSUT'\nMSGERBLA DC    C'2',C' - NOT BLP CODED IN LABEL=... OF DD-CARD.'\nLMSGERBL EQU   *-MSGERBL\n         DC    AL1(L'MSGREJ)\nMSGREJ   DC    C'0COPY REJECTED BY OPERATOR.'\n         DC    AL1(L'MSGCFL)\nMSGCFL   DC    C'0SYSUT2 - DISP=NEW CONFLICTS WITH ADD PARAMETER.'\n         DC    AL1(LMSGANAL)\nMSGANAL  DC    C'0         '\nMSGANALA DC    CL4'TAPE',C' '\nMSGANALB DC    CL6' ',C' ANALYSIS.'\nLMSGANAL EQU   *-MSGANAL\n         DC    AL1(LMSGCOPY)\nMSGCOPY  DC    C'0         COPY '\nMSGCOPYA DC    CL4'TAPE',C' '\nMSGCOPYB DC    CL6' ',C' ON '\nMSGCOPYC DC    CL4'TAPE',C' '\nMSGCOPYD DC    CL6' ',C'.'\nLMSGCOPY EQU   *-MSGCOPY\n         DC    AL1(L'AREAMSG)\nAREAMSG  DC    CL81' '\n         DC    AL1(L'SPACE)\nSPACE    DC    C'  '\n         SPACE 2\nOPADV1  WTO '--- OPERATOR ADVICE : THIS IS THE LAST CHANCE TO AVOID',  C\n               ROUTCDE=2,DESC=2,MF=L\nOPADV2  WTO '    RESPONSABILITY OF TAPE CONTENTS DESTROYED BY WRITE',  C\n               ROUTCDE=2,DESC=2,MF=L\nOPADV2A  EQU   OPADV2+26,4\nOPADV3  WTO '    OPERATION. CONFIRM CORRECT OUTPUT TAPE REEL MOUNTED', C\n               ROUTCDE=2,DESC=2,MF=L\nOPADV3A  EQU   OPADV3+42,9\nOPADV4 WTOR ' ON UNIT XXX (XXXXXX) - REPLY ''YES'' OR ''NO'' (Y/N).',  C\n               RAREA,L'RAREA,RECB,ROUTCDE=2,DESC=2,MF=L\nOPADV4A  EQU   OPADV4+21,3\nOPADV4B  EQU   OPADV4+26,6\nOPADVR WTOR ' SYNTAX ERROR -- RESPECIFY ''YES'' OR ''NO'' (Y/N).',     C\n               RAREA,L'RAREA,RECB,ROUTCDE=2,DESC=2,MF=L\n         SPACE 2\n         LTORG\n         SPACE 2\n        PRINT  NOGEN\nTAPE     DCB   DSORG=PS,MACRF=(E),EXLST=JOBFILE,DDNAME=SYSUT1\nCOPY     DCB   DSORG=PS,MACRF=(E),EXLST=JOBFILE,DDNAME=SYSUT2\n         SPACE 2\n*- - - - END OF BASE REGISTERS (R11-R12) ADDRESSABILITY - - - - - - - *\n         SPACE 2\n        DCBD   DSORG=PS,DEVD=TA\nTIODSECT DSECT\n        IEFTIOT1\n        IEFUCBOB\nJFCB     DSECT\n        IEFJFCBN\n         SPACE 2\n        PRINT  GEN\nANTP     CSECT ,                   RESTORE ORIGINAL CSECT.\n         EJECT\n*------- CHECK ANALYZE OR COPY OPERATION REQUEST.\n*              CALL : L     R15,=A(ANTPCKA OR ANTPCKC)\n*                     BASR  R14,R15\n* NOTE - VALIDITY CHECK IS SKIPPED BY SETTING 'CHCKSW' TO 'N'.\n         SPACE 1\n         CNOP  0,4\n         USING *,R15\nANTPCKA  STM   R0,R14,CHCKSV\n         LR    R10,R15\n         DROP  R15\n         USING ANTPCKA,R10\n         XR    R2,R2\n         MVI   CHCKNO,C'1'\n         B     CHCK00\n         DROP  R10\n         USING *,R15\nANTPCKC  STM   R0,R14,CHCKSV\n         LR    R10,R15\n         DROP  R15\n         USING ANTPCKC,R10\n         LA    R2,CHCKPOL\n         MVI   CHCKNO,C'2'\n         MVC   CHCKOT,MSGCOPYC\n         MVC   CHCKOV,MSGCOPYD\n         DROP  R10\nCHCK00   BASR  R10,0\n         USING *,R10\n         XR    R15,R15\n         CLI   CHCKSW,C'N'         BYPASS?\n         BE    CHCKEX              YES\n         MVC   CHCKIT,MSGANALA\n         MVC   CHCKIV,MSGANALB\n         LA    R2,L'CHCKNO+CHCKPIL(R2)\n         STH   R2,CHCKPL\n        BLDL   0,CHCKENT\n         LTR   R15,R15\n         BZ    *+L'*+16\n         MVC   MSGERCKR,=CL5' BLDL'\n         MVC   MSGERCKM(L'MSGERCKM),=CL16'SEE TO BLDL R.C.'\n         B     CHCKERR\n        LINK   DE=CHCKNME,PARAM=(CHCKPL),VL=1\n         LTR   R15,R15\n         BZ    CHCKEX\n         MVC   MSGERCKR,=CL5'CHECK'\n         LR    R1,R15\n         SRL   R1,2\n         BCTR  R1,0\n         SLL   R1,4\n         LA    R1,CHCKRCM(R1)\n         MVC   MSGERCKM(L'CHCKRCM),0(R1)\nCHCKERR  CVD   R15,WORKD\n         UNPK  WORKD(3),WORKD+6(2)\n         OI    WORKD+2,C'0'\n         MVC   MSGERCKC(L'MSGERCKC),WORKD+3-L'MSGERCKC\nCHCKEX   LM    R0,R14,CHCKSV\n         BR    R14\n         DROP  R10\n         EJECT\n         LTORG\n         SPACE 2\nCHCKSV   DC    15F'0'              SAVE REGISTERS 0-14.\nCHCKENT  DC    Y(1,58)\nCHCKNME  DC    CL8'ANTPCHK'\n         DC    XL58'0'\n         CNOP  2,4\nCHCKPL   DC    0H'0',AL2(*-*)\nCHCKNO   DC    CL1' '\nCHCKIL   DC    CL1'R'\nCHCKIT   DC    CL4' '\nCHCKIV   DC    CL6' '\nCHCKIN   DC    CL8'SYSUT1  '\nCHCKPIL  EQU   L'CHCKIL+L'CHCKIT+L'CHCKIV+L'CHCKIN\nCHCKOL   DC    CL1'W'\nCHCKOT   DC    CL4' '\nCHCKOV   DC    CL6' '\nCHCKON   DC    CL8'SYSUT2  '\nCHCKPOL  EQU   L'CHCKOL+L'CHCKOT+L'CHCKOV+L'CHCKON\nCHCKSW   DC    CL1'Y'              BYPASS SWITCH\nCHCKRCM  DC    CL16'INV. PARM-FIELD '   RC=04\n         DC    CL16'NO USER OR GROUP'      08\n         DC    CL16'NO CHECK TABLES '      12\n         DC    CL16'INVALID TABLE-ID'      16\n         DC    CL16'INV. LEVEL (R/W)'      20\n         DC    CL16'UNKNOWN UNIT-TY '      24\n         DC    CL16'ACCESS REJECTED '      28\n         DC    CL16'DD NOT FOUND    '      32\n         DC    CL16'UNKNOWN DEV.ADD.'      36\n         EJECT\n*------- FILES SELECT ROUTINE (SYSIN).\n*              CALL : L     R15,=A(FSEL)\n*                     BASR  R14,R15\n         SPACE 1\n         CNOP  0,4\n         USING *,R15\nFSEL     STM   R0,R15,FSELSV\n         LR    R10,R15\n         DROP  R15\n         USING FSEL,R10\n         L     R1,ATIOT\n         USING TIODSECT,R1\n         XR    R2,R2               CHECK TIOT FOR SYSIN.\nFSEL1    CLC   TIOELNGH(4),=XL4'0'\n         BE    FSELEX\n         CLC   TIOEDDNM,FSELDD\n         BE    *+L'*+10\n         IC    R2,TIOELNGH\n         AR    R1,R2\n         B     FSEL1\n         L     R1,ATIOT            CHECK TIOT FOR SYSCHECK.\nFSEL2    CLC   TIOELNGH(4),=XL4'0'\n         BE    FSEL3\n         CLC   TIOEDDNM,FSCHDD\n         BE    *+L'*+10\n         IC    R2,TIOELNGH\n         AR    R1,R2\n         B     FSEL2\n         DROP  R1\n         OI    SWFS,PFSLS\n        $PRINT TCRDFSL,,FSCHDD\n         LTR   R15,R15\n         BNZ   FSELERP\nFSEL3   $READ  CRDFSL              READ INPUT (SYSIN) CARDS.\n         LTR   R15,R15\n         BM    FSELEOF\n         BZ    *+L'*+12\n         BAS   R9,FSELCLS\n         LA    R1,PRTERR+L'PRTERR\n         B     FSELX2\n         TM    SWFS,PFSLS\n         BZ    FSEL4\n        $PRINT PCRDFSL,,FSCHDD\n         LTR   R3,R15\n         BZ    FSEL4\n         BAS   R9,FSELCLS\n         LR    R15,R3\n         B     FSELERP\nFSEL4    LM    R3,R5,CRDSCN        SCAN CARDS FOR FILES REQUESTS.\n         CLI   0(R3),C'*'\n         BE    FSEL3\n         CLI   0(R3),C' '\n         BNE   FSEL5\n         BXLE  R3,R4,FSEL4+L'FSEL4\n         B     FSEL3\nFSEL5    BAS   R14,FSSCN           GET FILE NUMBER.\n         LR    R2,R0\n         OC    ATBFSL,ATBFSL\n         BNZ   FSEL6\n         TM    SWPF,PFSKP          CHECK PARM OPTION VALIDITY.\n         BO    *+L'*+8\n         TM    CTLBLKC+1,ON\n         BO    *+L'*+12\n         BAS   R9,FSELCLS\n         LA    R1,MSGFS\n         B     FSELX1\n         L     R0,=A(4*1024)       GET BIT-MAP SPACE.\n        GETMAIN R,LV=(0)\n         ST    R1,ATBFSL\nFSEL6    LR    R14,R2\n         SRDL  R14,3\n         AL    R14,ATBFSL\n         SRL   R15,29\n         XR    R1,R1\n         IC    R1,FSBIT(R15)\n         EX    R1,FSSET\n         CLR   R3,R5\n         BH    FSEL3\n         CLI   0(R3),C' '\n         BNE   *+L'*+8\n         BXLE  R3,R4,*-8\n         B     FSEL3\n         CLI   0(R3),C'*'\n         BE    FSEL3\n         CLI   0(R3),C'-'\n         BNE   FSEL5\n         BXLE  R3,R4,*+L'*+4\n         B     FSELERR\n         CLI   0(R3),C' '\n         BE    *-12\n         BAS   R14,FSSCN           GET RANGE OF FILES NUMBERS.\n         CLR   R0,R2\n         BNH   FSELERR\n         LR    R6,R0\nFSEL7    LA    R2,1(R2)\n         LR    R14,R2\n         SRDL  R14,3\n         AL    R14,ATBFSL\n         SRL   R15,29\n         XR    R1,R1\n         IC    R1,FSBIT(R15)\n         EX    R1,FSSET\n         CLR   R2,R6\n         BL    FSEL7\n         CLR   R3,R5\n         BNH   FSEL4+L'FSEL4\n         B     FSEL3\nFSSET    OI    0(R14),*-*\nFSSCN    XR    R0,R0               EXTRACT A FILE NUMBER ROUTINE.\n         XR    R1,R1\nFSSCN1   CLI   0(R3),C'0'\n         BL    FSSCN2\n         CLI   0(R3),C'9'\n         BH    FSSCN2\n         IC    R1,0(R3)\n         N     R1,=F'15'\n         LTR   R0,R0\n         BNP   *+L'*+4\n         MH    R0,=H'10'\n         AR    R0,R1\n         CL    R0,=F'32767'\n         BH    FSELERR\n         BXLE  R3,R4,FSSCN1\nFSSCN2   LTR   R0,R0\n         BPR   R14\nFSELERR  BAS   R9,FSELCLS          DIAGNOSE DETECTED ERROR.\n         TM    SWFS,PFSLS\n         BO    FSELNOL\n        $PRINT PCRDFSL\n         LTR   R15,R15\n         BNZ   FSELERP\nFSELNOL  MVC   CRDFSL(L'CRDFSL),CRDFSL-1\n         MVI   0(R3),C'$'\n         MVC   CRDFSL-10(10),=CL10'POINTER ->'\n         TM    SWFS,PFSLS\n         BZ    FSELPRT\n        $PRINT PCRDFSL,,FSCHDD\n         B     FSELPTS\nFSELPRT $PRINT PCRDFSL\nFSELPTS  LTR   R15,R15\n         BNZ   FSELERP\n         LA    R1,MSGINV\nFSELX1   ST    R1,FSELSV+(R10*4)   SET REGISTERS TO GO BACK.\n         LA    R1,PRTERR\nFSELX2   ST    R1,FSELSV+(R14*4)\n         B     FSELEX\nFSELERP  ST    R15,FSELSV+(R10*4)\n         LA    R1,CLSTPE\n         B     FSELX2\nFSELEOF  LA    R9,FSEL10\nFSELCLS $RCLOSE ,                  CLOSE SYSIN ROUTINE.\n         BR    R9\nFSEL10   OC    ATBFSL,ATBFSL\n         BZ    FSELEX\n         TM    SWFS,PFCHK\n         BO    FSEL12\n         OI    SWFS,PFSEL\n         TM    SWPF,PFEV\n         BZ    FSEL11\n         ZAP   WORKZ,EVCNT\n         CVB   R1,WORKZ\n         ST    R1,FLCTR\nFSEL11   XR    R1,R1               CHECK SYSUT1 POSITION.\n         ICM   R1,B'0011',JF+(JFCBFLSQ-JFCB)\n         BZ    FSEL12              OK, BEGINNING.\n         LA    R1,CCWREW           REWIND SYSUT1 (FORCE BEGINNING).\n         ST    R1,CCWIN\n         XC    ECBIN,ECBIN\n         XC    CSWIN,CSWIN\n        EXCP   IOBIN\n        WAIT   ECB=ECBIN\nFSEL12   TM    SWFS,PFSLS\n         BZ    FSELEX\n        $PRINT LCRDFSL,,FSCHDD\n         LTR   R15,R15\n         BNZ   FSELERP\n         L     R15,=A(TTR)         FILES NUMBERS TABLE (SYSTEST).\n         BASR  R14,R15\n         DC    H'3' - - - - - - - - - - - - - - - - - - - - TRACE    3\n         XR    R2,R2               LIST FILES NUMBERS REQUESTS.\n         LA    R3,CRDFSL\n         MVC   CRDFSL(L'CRDFSL),CRDFSL-1\nFSEL20   LA    R2,1(R2)\n         CL    R2,=F'32767'\n         BH    FSEL26\n         LR    R14,R2\n         SRDL  R14,3\n         AL    R14,ATBFSL\n         TM    0(R14),X'FF'\n         BNZ   FSEL22\n         XR    R15,R15\n         SRL   R2,3\n         SLL   R2,3\nFSEL21   LA    R14,1(R14)\n         LA    R2,8(R2)\n         CL    R2,=F'32767'\n         BH    FSEL26\n         TM    0(R14),X'FF'\n         BZ    FSEL21\n         B     FSEL22+L'FSEL22\nFSEL22   SRL   R15,29\n         XR    R1,R1\n         IC    R1,FSBIT(R15)\n         EX    R1,FSTST\n         BZ    FSEL20\n         LR    R4,R2\nFSEL23   LA    R2,1(R2)\n         CL    R2,=F'32767'\n         BH    FSEL24\n         LR    R14,R2\n         SRDL  R14,3\n         SRL   R15,29\n         AL    R14,ATBFSL\n         XR    R1,R1\n         IC    R1,FSBIT(R15)\n         EX    R1,FSTST\n         BO    FSEL23\nFSEL24   LR    R5,R2\n         BCTR  R5,0\n         CL    R3,=A(CRDFSL+L'CRDFSL-12)\n         BNH   FSEL25\n        $PRINT PCRDFSL,,FSCHDD\n         LTR   R15,R15\n         BNZ   FSELERP\n         LA    R3,CRDFSL\n         MVC   CRDFSL(L'CRDFSL),CRDFSL-1\nFSEL25   LR    R0,R4\n         BAS   R9,FSELED\n         CLR   R4,R5\n         BE    *+L'*+14\n         MVI   0(R3),C'-'\n         LA    R3,1(R3)\n         LR    R0,R5\n         BAS   R9,FSELED\n         CL    R2,=F'32767'\n         BH    FSEL26+L'FSEL26\n         MVI   0(R3),C','\n         LA    R3,2(R3)\n         B     FSEL20\nFSTST    TM    0(R14),*-*\nFSEL26   SH    R3,=H'2'\n         MVI   0(R3),C'.'\n        $PRINT PCRDFSL,,FSCHDD\n         LTR   R15,R15\n         BNZ   FSELERP\nFSELEX   LM    R0,R15,FSELSV\n         BR    R14\nFSELED   CVD   R0,WORKZ            EDIT ROUTINE.\n         LA    R1,WORKED+L'WORKED-1\n         MVC   WORKED,=XL6'402020202120'\n         EDMK  WORKED,WORKZ+5\n         LA    R15,WORKED+L'WORKED-1\n         SLR   R15,R1\n         EX    R15,*+L'*+6\n         LA    R3,1(R15,R3)\n         BR    R9\n         MVC   0(*-*,R3),0(R1)\n         DROP  R10\n         SPACE 2\n         LTORG\n         SPACE 2\nWORKZ    DC    D'0'\nFSELSV   DC    16F'0'              SAVE ALL REGISTERS.\nCRDSCN   DC    A(CRDFSL,1,CRDFSL+71)\nFSELDD   DC    CL8'SYSIN   '\nFSCHDD   DC    CL8'SYSCHECK'\nFSBIT    DC    XL8'8040201008040201'\nWORKED   DC    XL6'0'\n         DC    AL1(L'TCRDFSL)\nTCRDFSL  DC    C'1IEBANTP - CHECK LIST :'\n         DC    AL1(L'LCRDFSL)\nLCRDFSL  DC    C'0          REQUESTED FILES NUMBERS :'\n         DC    AL1(L'PCRDFSL+L'CRDFSL)\nPCRDFSL  DC    CL16' '\nCRDFSL   DC    CL80' '\n         SPACE 1\n         DC    AL1(L'MSGFS)\nMSGFS    DC    C'0SYSIN - INVALID WITH COPYSKIP/BLKCOUNT KEYWORDS.'\n         DC    AL1(L'MSGINV)\nMSGINV   DC    C'0SYSIN - FILES NUMBERS INVALID SYNTAX.'\n         EJECT\n*------- FILES SELECT ROUTINE (PROCESS).\n*              CALL : L     R15,=A(TFSEL)\n*                     BASR  R14,R15\n         SPACE 1\n         CNOP  0,4\n         USING *,R15\nTFSEL    STM   R0,R15,TFSELSV\n         LR    R10,R15\n         DROP  R15\n         USING TFSEL,R10\nTFSELSW  NOP   TFLEAVE\n         XR    R4,R4\n         ICM   R4,B'0111',CCWREAD+1\n         OC    FLSQN,FLSQN         TYPE RECOGNIZED?\n         BNZ   TFSEL2              YES.\n         LH    R1,=H'1'            NO, FIRST READ.\n         ST    R1,FLSQN\n         XR    R2,R2\n         BAS   R9,TFSSR\n         B     TFUNEX              +0 - NONE TO COPY ???\n         ST    R2,FLCPY            +4\n         CLI   ECBIN,X'7F'\n         BE    TFSEL1\n         TM    CSWIN+4,X'01'\n         BZ    *+L'*+8\n         OI    SWTF,PFPNX\n         B     TFSEL26\n         MVC   TFSQN,FLSQN\n         OI    SWTF,PFIOE\nTFSEL1   CLC   0(4,R4),=CL4'VOL1'\n         BNE   TFSEL26\n         OI    SWTF,PFPSL          SAY SL FILES.\n         TM    SWPF,PFADD\n         BO    TFSELEX\n         CP    VQS,=PL1'0'\n         BNE   *+L'*+6\n         ZAP   VQS,=PL1'1'\n         CP    DSQS,=PL1'0'\n         BNE   TFSELEX\n         ZAP   DSQS,=PL1'1'\n         B     TFSELEX\nTFSEL2   TM    SWTF,PFPSL          SL TYPE?\n         BZ    TFSEL20             NO, IT IS NL.\n         TM    SWTF,PFPTH          COPY ACTIVATED?\n         BO    TFSEL10             YES.\n         CLI   ECBIN,X'7F'\n         BNE   TFERR1              ???, STOP.\nTFSEL3   CLC   0(4,R4),=CL4'HDR1'\n         BNE   TFERR1              ???, STOP.\n         CLC   FLSQN,FLCPY         FILE TO BE COPIED?\n         BNE   TFSEL4              NO.\n         OI    SWTF,PFPTH          YES, ACTIVATE COPY.\n         B     TFSELEX\nTFSEL4   BAS   R9,TFSXCP           SKIP HEADERS.\n         CLI   ECBIN,X'7F'\n         BE    TFSEL4\n         TM    CSWIN+4,X'01'\n         BO    TFSEL5\n         MVC   TFSQN,FLSQN\n         OI    SWTF,PFIOE\n         B     TFSEL4\nTFSEL5   BAS   R9,TFSXCP           SKIP DATA.\n         CLI   ECBIN,X'7F'\n         BE    TFSEL5\n         TM    CSWIN+4,X'01'\n         BO    TFSEL6\n         MVC   TFSQN,FLSQN\n         OI    SWTF,PFIOE\n         B     TFSEL5\nTFSEL6   BAS   R9,TFSXCP           SKIP TRAILERS.\n         CLI   ECBIN,X'7F'\n         BE    TFSEL6\n         TM    CSWIN+4,X'01'\n         BO    TFSEL7\n         MVC   TFSQN,FLSQN\n         OI    SWTF,PFIOE\n         B     TFSEL6\nTFSEL7   BAS   R9,TFSXCP           START NEW FILE.\n         CLI   ECBIN,X'7F'\n         BE    TFSEL8\n         TM    CSWIN+4,X'01'\n         BO    TFSEND              END, NO MORE TO COPY.\n         MVC   TFSQN,FLSQN\n         OI    SWTF,PFIOE\nTFSEL8   L     R1,FLSQN\n         AH    R1,=H'1'\n         ST    R1,FLSQN\n         B     TFSEL3\nTFSEL10  TM    SWTF,PFPTE          SL FILE COPIED?\n         BO    TFSEL11             YES.\n         CLI   ECBIN,X'7F'\n         BE    *+L'*+16\n         TM    CSWIN+4,X'01'\n         BZ    *+L'*+8\n         XI    SWTF,PFPTD          FLIP-FLOP OVER DATA.\n         B     TFSELEX\n         TM    SWTF,PFPTD\n         BO    TFSELEX\n         CLC   0(4,R4),=CL4'EOF2'\n         BNE   TFSELEX\n         OI    SWTF,PFPTE\n         B     TFSELEX\nTFSEL11  TM    SWTF,PFPNX          SL LAST TAPE MARK COPIED?\n         BO    TFSEL12             YES.\n         CLI   ECBIN,X'7F'\n         BE    TFERR2              ???, STOP.\n         TM    CSWIN+4,X'01'\n         BZ    TFERR2              ???, STOP.\n         OI    SWTF,PFPNX\n         B     TFSELEX\nTFSEL12  NI    SWTF,255-PFPNX-PFPTD-PFPTE-PFPTH\n         CLI   ECBIN,X'7F'\n         BE    TFSEL13\n         TM    CSWIN+4,X'01'\n         BO    TFSELEX\n         MVC   TFSQN,FLSQN\n         OI    SWTF,PFIOE\nTFSEL13  L     R2,FLCPY\n         BAS   R9,TFSCL\n         BAS   R9,TFSSR\n         B     TFSEND              +0 - END, NO MORE TO COPY.\n         ST    R2,FLCPY            +4\n         B     TFSEL8\nTFSEL20  TM    SWTF,PFPNX          TAPE MARK COPIED?\n         BO    TFSEL21             YES.\n         CLI   ECBIN,X'7F'\n         BE    TFSELEX\n         TM    CSWIN+4,X'01'\n         BZ    TFSELEX\n         OI    SWTF,PFPNX\nTFSELEX  NI    SWTF,255-PFIOE\n         LM    R0,R15,TFSELSV\n         BR    R14\nTFSEL21  L     R2,FLCPY\n         BAS   R9,TFSCL\n         BAS   R9,TFSSR\n         B     TFSEND              +0 - END, NO MORE TO COPY.\n         ST    R2,FLCPY            +4\nTFSEL22  CLI   ECBIN,X'7F'\n         BE    TFSEL23\n         TM    CSWIN+4,X'01'\n         BO    TFSEL24\n         MVC   TFSQN,FLSQN\n         OI    SWTF,PFIOE\nTFSEL23  NI    SWTF,255-PFPNX\n         B     TFSEL25\nTFSEL24  TM    SWPF,PFEV           ACCEPT EMPTY FILES?\n         BZ    TFSEND              NO, END, NO MORE TO COPY.\n         CLC   FLSQN,FLCTR         YES, IN RANGE?\n         BNL   TFSEND              NO, END, NO MORE TO COPY.\nTFSEL25  L     R1,FLSQN\n         AH    R1,=H'1'\n         ST    R1,FLSQN\nTFSEL26  CLC   FLSQN,FLCPY         FILE TO BE COPIED?\n         BE    TFSELEX             YES.\nTFSEL27  BAS   R9,TFSXCP           NO, SKIP THIS FILE.\n         CLI   ECBIN,X'7F'\n         BE    TFSEL28\n         TM    CSWIN+4,X'01'\n         BO    TFSEL29\n         MVC   TFSQN,FLSQN\n         OI    SWTF,PFIOE\nTFSEL28  NI    SWTF,255-PFPNX\n         B     TFSEL27\nTFSEL29  TM    SWTF,PFPNX\n         BO    TFSEL24\n         OI    SWTF,PFPNX\n         BAS   R9,TFSXCP\n         B     TFSEL22\nTFUNEX   BAS   R9,ABEND            NORMALLY CANNOT OCCURS.\n         LA    R1,TFMSG0\n         ST    R1,TFSELSV+(R10*4)  SET REGISTERS TO GO BACK.\n         LA    R1,PRTERR\n         ST    R1,TFSELSV+(R14*4)\n         B     TFSELEX\nTFERR1   LA    R3,TFMSG1\n         B     TFERRX\nTFERR2   LA    R3,TFMSG2\n         B     TFERRX\nTFSEND   LA    R3,TFMSG3           END OF COPY.\nTFERRX   BAS   R9,TFMESS\n         OI    TFSELSW+1,ON\nTFLEAVE  XC    ECBIN,ECBIN         PASS CONDITION AS EOF.\n         XC    CSWIN,CSWIN\n         MVI   CSWIN+4,X'01'\n         B     TFSELEX\nTFSSR    LA    R2,1(R2)            NEXT FILE TO COPY ROUTINE.\n         CL    R2,=F'32767'        RETURN +0 = NO MORE, +4 = FOUND.\n         BHR   R9                  AT ENTRY, R2 = CURRENT FILE NO.\n         LR    R14,R2              AT EXIT, R2 = NEXT FILE NO. TO COPY.\n         SRDL  R14,3               LINK REGISTER = R9.\n         AL    R14,ATBFSL\n         TM    0(R14),X'FF'\n         BNZ   TFSSR2\n         XR    R15,R15\n         SRL   R2,3\n         SLL   R2,3\nTFSSR1   LA    R14,1(R14)\n         LA    R2,8(R2)\n         CL    R2,=F'32767'\n         BHR   R9\n         TM    0(R14),X'FF'\n         BZ    TFSSR1\n         B     TFSSR2+L'TFSSR2\nTFSSR2   SRL   R15,29\n         XR    R1,R1\n         IC    R1,TFSBIT(R15)\n         EX    R1,*+L'*+8\n         BZ    TFSSR\n         B     4(R9)\n         TM    0(R14),*-*\nTFSCL    LR    R14,R2              COPIED FILE NUMBER RESET ROUTINE.\n         SRDL  R14,3               AT ENTRY, R2 = CURRENT FILE NO.\n         AL    R14,ATBFSL          LINK REGISTER = R9.\n         SRL   R15,29\n         XR    R1,R1\n         IC    R1,TFSBCL(R15)\n         EX    R1,*+L'*+2\n         BR    R9\n         NI    0(R14),*-*\nTFSXCP   TM    SWTF,PFIOE          READ ROUTINE. LINK REG. = R9.\n         BZ    TFSXCP1             NO I/O ERROR HAS OCCURED.\n         NI    SWTF,255-PFIOE\n         TM    SWFS,PFSLS          PRINT CHECK ALLOWED?\n         BZ    TFSXCP1             NO.\n         MVC   TFMSGX(32),=CL32'0SYSUT1 - I/O ERROR READING FILE'\n         L     R1,TFSQN\n         CVD   R1,WORKY\n         MVC   TFMSGX+32(6),=XL6'402020202120'\n         ED    TFMSGX+32(6),WORKY+5\n         MVC   TFMSGX+38(2),=CL2'. '\n         MVC   TFMSGX+40(L'TFMSGX-40),TFMSGX+39\n        $PRINT TFMSGX,,TFSELDD\n         LTR   R15,R15\n         BZ    TFSXCP1\n         NI    SWFS,255-PFSLS\nTFSXCP1  XC    ECBIN,ECBIN\n         XC    CSWIN,CSWIN\n        EXCP   IOBIN\n        WAIT   ECB=ECBIN\n         BR    R9\n*                                  DIAGNOSE ROUTINE. LINK REG. = R9.\nTFMESS   TM    SWFS,PFSLS          PRINT CHECK ALLOWED?\n         BZ    TFMESS1             NO.\n         MVI   TFMSGX,C' '\n         MVC   TFMSGX+1(L'TFMSGX-1),TFMSGX\n         LH    R1,0(R3)\n         SH    R1,=H'5'\n         EX    R1,TFMESSM\n         MVI   TFMSGX,C'0'\n        $PRINT TFMSGX,,TFSELDD     DIAGNOSE MESSAGES.\n         LTR   R15,R15\n         BZ    TFMESS2\n         NI    SWFS,255-PFSLS\nTFMESS1 WTO    MF=(E,(R3))\nTFMESS2  L     R1,FLSQN\n         CVD   R1,WORKY\n         MVC   TFMSSTN,=XL6'402020202120'\n         ED    TFMSSTN,WORKY+5\n         TM    SWFS,PFSLS          PRINT CHECK ALLOWED?\n         BZ    TFMESS3             NO.\n         MVI   TFMSGX,C' '\n         MVC   TFMSGX+1(L'TFMSGX-1),TFMSGX\n         LA    R3,TFMSST\n         LH    R1,0(R3)\n         SH    R1,=H'5'\n         EX    R1,TFMESSM\n        $PRINT TFMSGX,,TFSELDD\n         LTR   R15,R15\n         BZR   R9\n         NI    SWFS,255-PFSLS\nTFMESS3 WTO    MF=(E,TFMSST)\n         BR    R9\nTFMESSM  MVC   TFMSGX(*-*),4(R3)\n         DROP  R10\n         SPACE 2\n         LTORG\n         SPACE 2\nWORKY    DC    D'0'\nTFSELSV  DC    16F'0'              SAVE ALL REGISTERS.\nTFSQN    DC    F'0'\nTFSBIT   DC    XL8'8040201008040201'\nTFSBCL   DC    XL8'7FBFDFEFF7FBFDFE'\nTFSELDD  DC    CL8'SYSCHECK'\nSWTF     DC    XL1'0'\nPFPSL    EQU   X'01'\nPFPNX    EQU   X'02'\nPFPTH    EQU   X'04'\nPFPTE    EQU   X'08'\nPFPTD    EQU   X'10'\nPFIOE    EQU   X'20'\n         DC    AL1(L'TFMSG0)\nTFMSG0   DC    C'0UNEXPECTED ERROR : NONE TO COPY.'\n         DC    AL1(L'TFMSGX)\nTFMSGX   DC    CL60' '\nTFMSG1  WTO    ' SYSUT1 - I/O ERROR OR EXPECTED HDR1 NOT FOUND.',      C\n               ROUTCDE=11,DESC=7,MF=L\nTFMSG2  WTO    ' SYSUT1 - I/O ERROR OR EOF2/TAPE-MARK NOT FOUND.',     C\n               ROUTCDE=11,DESC=7,MF=L\nTFMSG3  WTO    ' SYSUT1 - END OF COPY OPERATION.',                     C\n               ROUTCDE=11,DESC=7,MF=L\nTFMSST  WTO    '          CURRENT FILE NUMBER IS :      .',            C\n               ROUTCDE=11,DESC=7,MF=L\nTFMSSTN  EQU   TFMSST+38,6\n         EJECT\n*------- TRACE ROUTINE (SYSTEST).\n*              CALL : L     R15,=A(TTR)\n*                     BASR  R14,R15\n*                     DC    H'TRACE NUMBER'\n         SPACE 1\n         CNOP  0,4\n         USING *,R15\nTTR      NOP   2(,R14)\n         STM   R0,R15,TTRSV\n         LR    R10,R15\n         DROP  R15\n         USING TTR,R10\nTTR0     NOP   TTR3\n         L     R1,ATIOT\n         USING TIODSECT,R1\n         XR    R2,R2\nTTR1     CLC   TIOELNGH(4),=XL4'0'\n         BE    TTR7\n         CLC   TIOEDDNM,TTRDD\n         BE    TTR2\n         IC    R2,TIOELNGH\n         AR    R1,R2\n         B     TTR1\n         DROP  R1\nTTR2     OI    TTR0+1,ON\nTTR3     LA    R1,TTRTB\nTTR4     CLC   0(2,R1),0(R14)\n         BE    TTR5\n         CLC   0(2,R1),TTRTBE\n         BE    TTR8\n         LA    R1,L'TTRTB(R1)\n         B     TTR4\nTTR5     ICM   R2,B'1111',2(R1)\n         LA    R3,10(R2)\n        $PRINT (R3),,TTRDD\n         LTR   R15,R15\n         BZ    TTR6\n         STC   R15,TTRPR+L'TTRPR+36\n         OI    TTRPR+L'TTRPR+36,C'0'\nTTRPR   WTO    '--- SYSTEST (PRINT ERROR CODE : 0) ---',               C\n               ROUTCDE=11,DESC=7\n         B     TTR7\nTTR6     TM    8(R2),TTRIL\n         BO    *+L'*+10\n         MVC   TTRLG(4),4(R2)\n         B     *+L'*+10\n         ICM   R1,B'1111',4(R2)\n         MVC   TTRLG(4),0(R1)\n         TM    8(R2),TTRIA\n         BO    *+L'*+8\n         ICM   R3,B'1111',0(R2)\n         B     *+L'*+8\n         ICM   R1,B'1111',0(R2)\n         ICM   R3,B'1111',0(R1)\n        $SNAP  (R3),TTRLG,TTRDD\n         LTR   R15,R15\n         BZ    TTR8\n         STC   R15,TTRMS+L'TTRMS+35\n         OI    TTRMS+L'TTRMS+35,C'0'\nTTRMS   WTO    '--- SYSTEST (SNAP ERROR CODE : 0) ---',                C\n               ROUTCDE=11,DESC=7\nTTR7     OI    TTR+1,ON\nTTR8     LM    R0,R15,TTRSV\n         B     2(,R14)\n         DROP  R10\n         SPACE 2\n         LTORG\n         SPACE 2\nTTRSV    DC    16F'0'              SAVE ALL REGISTERS.\nTTRLG    DC    F'0'\nTTRDD    DC    CL8'SYSTEST '\n         SPACE 1\nTTRTB    DS    0XL6\n         DC    H'1',AL4(TTRDT1)\n         DC    H'2',AL4(TTRDT2)\n         DC    H'3',AL4(TTRDT3)\nTTRTBE   DC    H'-1'\n         SPACE 1\nTTRIA    EQU   X'80'               INDIRECT ADDRESS OF AREA.\nTTRIL    EQU   X'40'               INDIRECT ADDRESS OF LENGTH.\n         SPACE 1\nTTRDT1   DC    AL4(JF,176),AL1(0,L'TTRDM1)\nTTRDM1   DC    C'0     SNAP - JFCB OF SYSUT1.'\nTTRDT2   DC    AL4(JF,176),AL1(0,L'TTRDM2)\nTTRDM2   DC    C'0     SNAP - JFCB OF SYSUT2.'\nTTRDT3   DC    AL4(ATBFSL,4*1024),AL1(TTRIA,L'TTRDM3)\nTTRDM3   DC    C'0     SNAP - FILES NUMBERS TABLE.'\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IEBANTP$": {"ttr": 8710, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x942\\x8f\\x00\\x942\\x8f\\x10)\\x00\\x1b\\x00\\x1b\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-24T00:00:00", "modifydate": "1994-11-24T10:29:00", "lines": 27, "newlines": 27, "modlines": 0, "user": "SYSPAJA"}, "text": "//IEBANTP  JOB (........),'INSTALL  - IEBANTP -',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=800K,TIME=1\n/*JOBPARM L=8\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//* PRE-REQUISITE MODULES INSTALLATION :                              *\n//* FOR IEBANTP :  TXPRINT   TXREAD    TXSNAP                         *\n//* FOR ANTPCHK :  AUTHCTL                                            *\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//ASS     EXEC PAJ1AS3,MBR=IEBANTP\n//LNK     EXEC PAJILKL\n//SYSIN     DD *\n  INCLUDE SYSADD(PRINT,READ,SNAP)\n  ENTRY   ANTP\n  NAME    IEBANTP(R)\n/*\n//ASR     EXEC PAJ1AS3,MBR=ANTPCHK\n//LNR     EXEC PAJILKL\n//SYSIN     DD *\n  ENTRY   ANTPCHK\n  NAME    ANTPCHK(R)\n/*\n//AST     EXEC PAJ1AS2,MBR=ANTPCTB\n//LNT     EXEC PAJILKL\n//SYSIN     DD *\n  ENTRY   ANTPCTB\n  NAME    ANTPCTB(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IEBANTP@": {"ttr": 8712, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x89\\x10/\\x00\\x89\\x10/\\x11Y\\x00\\xee\\x00\\xee\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-04-12T00:00:00", "modifydate": "1989-04-12T11:59:00", "lines": 238, "newlines": 238, "modlines": 0, "user": "SYSPAJA"}, "text": "1   11/04/89\n                                                      IEBANTP   1/6.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *   ANALYZE/COPY TAPE/3480 UTILITY.   * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Purpose :    This is a MAP program which outputs a list giving the\n  ---------    description of all the logical files recorded on a\n               magnetic tape. The end of tape is assumed when\n               reading two consecutive tape-marks (unless empty\n               SL-file or special option for NL-file).\n\n               On request, the input tape can be copied, with the\n               availability to change the density and/or the volume\n               serial number of the output tape (be carefull when\n               changing density that the contents must not overflow\n               a tape reel capacity : multiple volumes are not\n               supported).\n\n               The program accepts only 9-tracks tapes (BLP option).\n\n  3480 Data Cartridge : Now, the program is adapted to run also with\n  --------------------- 3480 Data Cartridges (SYSUT1 and/or SYSUT2).\n\n  Check requested operation : With the introduction of the 3480 Data\n  --------------------------- Cartridge units, the program has been\n               enhanced to perform a validity check on the requested\n               operation (tapes and cartridges volumes may be now\n               protected against all or some users use).\n1   11/04/89\n                                                      IEBANTP   2/6.\n\n  Call of the program :\n  ---------------------\n\n  1. Tape analysis.\n\n         //ANAL      EXEC  PGM=IEBANTP\n         //SYSPRINT    DD  SYSOUT=A\n         //SYSUT1      DD  UNIT=TAPE,VOL=SER=......,DSN=...,       C\n         //                LABEL=(,BLP),DISP=OLD\n\n  2. Tape copy.\n\n         //COPY      EXEC  PGM=IEBANTP\n         //SYSPRINT    DD  SYSOUT=A\n         //SYSUT1      DD  UNIT=TAPE,VOL=SER=......,DSN=...,       C\n         //                LABEL=(,BLP),DISP=OLD\n         //SYSUT2      DD  UNIT=TAPE,VOL=SER=......,DSN=...,       C\n         //                LABEL=(,BLP),DISP=NEW\n         //SYSIN       DD  *  (optional : see selective copy)\n           ... file numbers ...\n         /*\n         //SYSCHECK    DD  SYSOUT=A  (optional : see selective copy)\n\n         Note : When SYSUT2 is a 3480 Data Cartridge, the true label\n                is indicated by the VOL=SER=...... DD-parameter.\n\n  Density and Volume Serial Number : Not applyable to 3480 (ignored\n  ---------------------------------- if specified).\n               A density and/or a new volume serial number can be\n         assigned to the output tape (SYSUT2) using the parameter's\n         field of the EXEC statement as follows :\n\n         //COPY      EXEC  PGM=IEBANTP,PARM='DEN=X,SER=NNNNNN'\n\n         or the short form :\n\n         //COPY      EXEC  PGM=IEBANTP,PARM='D=X,S=NNNNNN'\n\n         where : X = 2 for 800 bpi.    (not applyable to 3480)\n                     3 for 1600 bpi.\n                     4 for 6250 bpi.\n\n                 NNNNNN = new volume serial number.\n\n               If the density cannot be determined from SYSUT1 or\n         is not declared by the DEN= parameter, then the default of\n         1600 bpi is assumed for the copied tape (SYSUT2).\n1   11/04/89\n                                                      IEBANTP   3/6.\n\n  Bypass operator advice message : Always set when 3480 (ignored if\n  -------------------------------- specified).\n               When copying, the operator advice messages about\n         tapes correctly mounted (to get him a last chance against\n         contents destruction) may be suppressed as follows :\n\n         //...       EXEC  PGM=IEBANTP,PARM='...,NOVEROP,...'\n         or :\n         //...       EXEC  PGM=IEBANTP,PARM='...,N,...'\n\n  Block count (EURATOM modification) :\n  ------------------------------------\n               When copying standard labeled tapes (SYSUT1-SYSUT2),\n         one can ask to compute again and rewrite the block count\n         (number of physical records) in the trailer label (EOF1)\n         by specifying : PARM='...,BLKCOUNT' or PARM='...,B'.\n\n  Special use (EURATOM modification) :\n  ------------------------------------\n               Some applications in the centre produce no labeled\n         (NL) tapes (i.e. - laboratories analysis recorder) with a\n         large number of files (tape-marks). Often it is desirable\n         for further computations, to merge all these files in only\n         one (NL). This is done by the program when providing the\n         keyword COPYSKIP as in the example below :\n\n         //COPYSK    EXEC  PGM=IEBANTP,PARM='COPYSKIP'\n         or :\n         //COPYSK    EXEC  PGM=IEBANTP,PARM='C'\n         //SYSPRINT    DD  SYSOUT=A\n         //SYSUT1      DD  UNIT=TAPE,VOL=SER=......,DSN=...,       C\n         //                LABEL=(,BLP),DISP=OLD\n         //SYSUT2      DD  UNIT=TAPE,VOL=SER=......,DSN=...,       C\n         //                LABEL=(,BLP),DISP=NEW\n\n               The keyword COPYSKIP is accepted only when SYSUT2\n         is present (copy). It can be used in conjunction with the\n         keywords DEN and SER (this last is just for information\n         on the output list), and the keyword BLKCOUNT is ignored.\n1   11/04/89\n                                                      IEBANTP   4/6.\n\n  Archive (EURATOM modification) :\n  --------------------------------\n               Another modification to the program allows the copy\n         of an input tape after the contents of an output tape,\n         thus expanding the SYSUT2 tape.\n\n         //COPYAD    EXEC  PGM=IEBANTP,PARM='ADD,DEN=X,SER=NNNNNN'\n         or :\n         //COPYAD    EXEC  PGM=IEBANTP,PARM='A,D=X,S=NNNNNN'\n         //SYSPRINT    DD  SYSOUT=A\n         //SYSUT1      DD  UNIT=TAPE,VOL=SER=......,DSN=...,       C\n         //                LABEL=(,BLP),DISP=OLD\n         //SYSUT2      DD  UNIT=TAPE,VOL=SER=......,DSN=...,       C\n         //                LABEL=(,BLP),DISP=...\n\n               The SYSUT2 disposition first subparameter is OLD\n         if the tape is not passed from a previous step, otherwise\n         use MOD in order to left the tape positioned at the end,\n         thus gain time preventing the rewind.\n\n               The keyword ADD requires the keywords SER and\n         DEN to be present, the keyword BLKCOUNT is optionally\n         usable, and the keyword COPYSKIP is not accepted.\n\n  Selective copy (EURATOM modification) :\n  ---------------------------------------\n               Only with normal or archive copy operations, a list\n         of those desired files, to be copied from the SYSUT1 tape\n         on the SYSUT2 tape, may be supplied by the SYSIN input.\n\n         Card format : the files numbers can be specified in any\n                       order from col.1 up to col.72 included.\n                       Single (N) or range (N-NN) of files numbers\n                       must be separated each from the others by\n                       at least one blank. Each card starts new\n                       single or range information. As soon as an\n                       asterisk (*) is encountered, the rest of the\n                       card is considered comments.\n         Note : the files numbers refers to NL or SL files depending\n                on the automatic type recognition of the SYSUT1 tape.\n\n               Keywords COPYSKIP and BLKCOUNT are not allowed. You\n         may use a SYSCHECK DD-card if you want a check list.\n1   11/04/89\n                                                      IEBANTP   5/6.\n\n  Sequence numbers adjustment :\n  -----------------------------\n               The keywords V= and Q= may be used to set the\n         volume sequence number and the starting data-set sequence\n         number when copying standard labeled (SL) tapes only :\n\n         //COPYAD    EXEC  PGM=IEBANTP,PARM='...,V=NNNN,Q=PPPP,...'\n\n         where : NNNN is the desired volume sequence number (one to\n                     four numerics, value may be 1 to 9999).\n                 PPPP is the desired starting data-set sequence\n                     number (one to four numerics, value may be 1\n                     to 9999).\n         Note : these adjustments are automatically done when an\n                archive operation is requested.\n\n  Dump analysis :\n  ---------------\n               If a SYSANAL DD-card is supplied, then the program\n         uses it to dump the first record (for a maximum length of\n         1024 bytes) of each file encountered on the tape (SYSUT1).\n\n               If a SYSUDUMP or SYSABEND DD-card is present and\n         an unexpected error occurs reading the input tape (SYSUT1)\n         or writing the output tape (SYSUT2), a dump with abend code\n         U0001 is taken, otherwise only an I/O error message is\n         supplied.\n\n  Bypass input tape I/O error :\n  -----------------------------\n               Any I/O error (i.e. - data check) when reading the\n         input tape (SYSUT1) may be bypassed by specifying the\n         keyword FORCE. If a SYSERR DD-card is supplied, the\n         wrong record is dumped on it (for a maximum length of 1024\n         bytes), and when the operation is a copy tape, the record is\n         copied on the output tape (SYSUT2) as entered in memory.\n\n         //...       EXEC  PGM=IEBANTP,PARM='...,FORCE,...'\n         or :\n         //...       EXEC  PGM=IEBANTP,PARM='...,F,...'\n1   11/04/89\n                                                      IEBANTP   6/6.\n\n  Bypass consecutive tape-marks :\n  -------------------------------\n               Sometime, a no labeled (NL) tape may contain empty\n         files, so it is necessary to inform the program about this\n         situation. The approximative number of files, before two\n         consecutive tape-marks which is considered the end of tape,\n         may be supplied using the parameter's field of the EXEC\n         statement as below :\n\n         //...       EXEC  PGM=IEBANTP,PARM='...,EVEN=NNNNN,...'\n         or :\n         //...       EXEC  PGM=IEBANTP,PARM='...,E=NNNNN,...'\n\n         where : NNNNN is the expected files number (one to five\n                     numerics, value may be 1 to 99999).\n\n\n   *****************************************************************\n   REMARK :    you can build mixed NL and SL files tapes, but then,\n   ********    be carefull in any further processing of these tapes,\n               you probably will have troubles of course.\n   *****************************************************************\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "IMSLDS": {"ttr": 8717, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x95\\x07O\\x00\\x95\\x07O\\x167\\t\\xce\\t\\xce\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1995-03-15T00:00:00", "modifydate": "1995-03-15T16:37:00", "lines": 2510, "newlines": 2510, "modlines": 0, "user": "SYSPAJA"}, "text": "ILDS     TITLE '--- I M S L D S --- I.M.S. LOG DATA-SET(S) ---'\n         PRINT OFF\n         MACRO\n&NAME   @CALL  &RTN,&ERR=\n         AIF   ('&RTN' EQ '').ERR\n&NAME    L     R15,=A(&RTN)        GET ROUTINE ADDRESS\n         BASR  R14,R15             LINK TO IT\n         AIF   ('&ERR' EQ '').X\n         BNZ   &ERR                BRANCH ON ERROR RC\n.X       MEXIT\n.ERR    MNOTE  8,'===> ROUTINE NAME MISSING *************************'\n         MEND\n         MACRO\n&NAME   @ENTER &DUMMY\n         CNOP  0,8\n         USING *,R11\n&NAME    STM   R14,R12,12(R13)     SAVE CALLER REGISTERS\n         LR    R11,R15             LOCAL BASE REGISTER\n         LR    R1,R13              OLD SAVE-AREA\n         LA    R13,*+L'*+4         NEW SAVE-AREA\n         B     *+L'*+18*4\n         DC    18F'0' ------------ LOCAL SAVE-AREA\n         XC    0(18*4,R13),0(R13)  CLEAN NEW SAVE-AREA\n         ST    R13,8(R1)           CHAIN SAVE-AREA'S\n         ST    R1,4(R13)\n         MEND\n         MACRO\n&NAME   @EXIT  &RC\n&NAME    L     R13,4(R13)          BACK TO PREVIOUS SAVE AREA\n         AIF   ('&RC' EQ '').A\n         AIF   ('&RC'(1,1) EQ '(').B\n         AIF   ('&RC' NE '0').C\n.A       XC    16(4,R13),16(R13)   SET RETURN CODE\n         AGO   .D\n.B       ST    &RC(1),16(R13)      SET RETURN CODE\n         AGO   .D\n.C       MVC   16(4,R13),=AL4(&RC) SET RETURN CODE\n.D       LM    R14,R12,12(R13)     RESTORE REGISTERS\n         MVI   12(R13),X'FF'       SET RETURN INDICATOR\n         LTR   R15,R15             SET CC ON RETURN CODE\n         BR    R14                 RETURN TO CALLER\n         MEND\n         MACRO\n        @STOP  &DUMMY\n        LTORG  ,\n         SPACE 1\n         DROP  R11                 KILL LOCAL ADDRESSABILITY\n         MEND\n         PRINT ON\n         SPACE 1\nIMSLDS   START 0\n         SPACE 1\n* PURPOSE :    AUTOMATIC JCL GENERATION TO CUMULATE ALL DAY'S IMS LOG\n* =========    DATA-SET(S) INTO A ONE MONTH DATA-SET.\n*\n* FUNCTIONAL SUMMARY :\n* ====================\n*        THE JCL SKELETON, USED FOR JOB GENERATION, IS OBTAINED FROM\n*   A MEMBER NAMED IMSLOG.. (DEFAULT FOR .. IS 00), AND LOCATED IN A\n*   PREDEFINED PARTITIONED DATA-SET (WITH LRECL=80 AND DECLARED AT THE\n*   ASSEMBLY STEP WITH SYSPARM).\n*        VARIOUS MEMBERS IMSLOG.. (JCL SKELETONS) CAN BE BUILD AS YOU\n*   WANT TO GENERATE DIFFERENT JOBS, ASSUMING THEY ARE ALL BASED ON\n*   IMS LOG DATA-SET(S) MANIPULATION (NORMAL JCL STATEMENTS CARDS).\n*   THE FIRST JCL STATEMENT SUPPLIED MUST BE A JOB CARD, WHICH WILL\n*   BE USED BY SUBMIT WHEN STARTED TASK RUNNING. SOME OTHER CARDS ARE\n*   EXPLAINED BELOW :\n*        1. CARDS STARTING WITH THREE ASTERISKS (COLUMNS 1-3 = ***)\n*           ARE CONSIDERED AS PRIVATE COMMENT CARDS (NEVER COPIED OR\n*           SUBMITED).\n*        2. SPECIAL CARDS STARTING (COLUMNS 1-2) WITH A QUESTION MARK\n*           FOLLOWED BY AN INDICATOR CHARACTER ARE CONTROL PROCESSING\n*           ORIENTED.\n*           POSITIONAL CONTROL ONLY :\n*           ?I = IS MANDATORY AND INDICATE WHERE THE EVENTUAL TYPRUN=\n*                PARAMETER CARD CAN BE INSERTED IN THE JOB STATEMENT.\n*           ?0 = IS MANDATORY AND INDICATE WHERE STARTS THE NORMAL JCL\n*                SKELETON (WHEN NOT STARTED TASK). GENERALLY THIS IS\n*                PLACED AFTER THE JOB STATEMENT.\n*           SUBSTITUTION VALUES DEFINITION :\n*           ?1 = IS MANDATORY AND DEFINES THE IMS DAY'S LOG DATA-SET(S)\n*                LEVEL NAME (THIS IS THE LEVEL TO SEARCH THE DAY'S\n*                DATA-SET(S) IN THE CATALOG).\n*           ?2 = IS OPTIONAL AND DEFINES THE IMS MONTH LOG DATA-SET\n*                LEVEL NAME (THIS IS THE LEVEL TO CREATE THE MONTH'S\n*                DATA-SET).\n*           THEN ?1... AND ?2... CODING ARE USED TO INDICATE WHERE\n*           SUBSTITUTION MUST BE DONE IN THE JCL SKELETON.\n         EJECT\n* HOW TO INVOKE IT :\n* ==================\n*     1. AS CONSOLE START COMMAND :\n*             S IMSLOG,D=YYDDD,J=XX,O=COPY\n*                                     SCAN\n*        WHERE \"IMSLOG\" MAY BE, I.E., THE FOLLOWING PROCEDURE :\n*             //IMSLOG  PROC D=,J=,O=\n*             //IMSLOG  EXEC PGM=IMSLDS,PARM='DAY=&D,JCL=&J,&O'\n*                                    OR PARM='D=&D,J=&J,&O'\n*     2. AS BATCH EXEC PROCEDURE :\n*             //... EXEC IMSLOG,D=YYDDD,J=XX\n*     3. AS BATCH EXEC :\n*             //... EXEC PGM=IMSLDS,PARM='DAY=YYDDD,JCL=XX'\n*                                OR PARM='D=YYDDD,J=XX'\n*     4. AS TSO CALL :\n*             CALL '...DSNAME...(IMSLDS)' 'DAY=YYDDD,JCL=XX'\n*                                      OR 'D=YYDDD,J=XX'\n*     5. AS TSO COMMAND OR SUB-COMMAND :\n*             IMSLDS ... (FOR SYNTAX DESCRIPTION SEE BELOW) ...\n*\n* WHERE : - YYDDD IS THE DESIRED SERIAL DAY DATE SELECTION (IF NOT\n* -------   SPECIFIED, YESTERDAY DATE IS USED).\n*         - JCL=XX (OR JOB=/J=) IS THE TWO CHARACTERS SUFFIX TO FORM\n*           THE MEMBER NAME \"IMSLOG..\" (DEFAULT IS 00).\n*         - COPY/SCAN (OR C/S) ARE JCL SUBMIT OPTIONS (JOB TYPRUN).\n*\n* NOTES : 1. ONLY WHEN RUNNING AS SYSTEM TASK (THROUGH OPERATOR START\n* =======    COMMAND), THE \"COPY\" OR \"SCAN\" OPTIONS ARE ACCEPTED AND\n*            ALL GENERATED JCL STATEMENTS ARE IMMEDIATELY \"SUBMIT\" TO\n*            JES2.\n*         2. OTHERWISE (BATCH OR TSO RUNNING), THE GENERATED JCL IS\n*            ALWAYS STORED IN A NEW (CREATED) DATA-SET NAMED AS\n*            FOLLOWS : '#0.GENJCL.D#1.T#2'\n*            WHERE : #0 = CURRENT RACF USER-ID\n*                    #1 = YYDDD (CURRENT DAY)\n*                    #2 = HHMMSS (CURRENT TIME OF DAY)\n*            YOU MAY THEN \"SUBMIT\" IT, IF YOU WANT.\n         EJECT\n* TSO COMMAND OR SUB-COMMAND SYNTAX :\n* ===================================\n*        IMSLDS  DAY(DD/MM/YY)  JCL(XX)  OPTION\n*                ALIAS : D(DD/MM/YY)  JOB(XX)\n*                                     J(XX)\n*        IMSLDS  FROM(DD/MM/YY)  TO(DD/MM/YY)  JCL(XX)  OPTION\n*                ALIAS : F(DD/MM/YY)  T(DD/MM/YY)  JOB(XX)\n*                                                  J(XX)\n* WHERE : DAY(DD/MM/YY) INDICATE A PARTICULAR DATE SELECTION, IF\n* -------      NOT SPECIFIED IT MEANS YESTERDAY DATE.\n*         FROM(DD/MM/YY) AND TO(DD/MM/YY) INDICATE A RANGE OF DATES\n*              (RESPECTIVELY THE STARTING AND ENDING DATE), WHICH\n*              MUST FALL IN THE SAME MONTH.\n*              IF THE ENDING DATE IS NOT SUPPLIED IT MEANS THE END\n*              OF THE STARTING DATE MONTH OR THE YESTERDAY DATE WHEN\n*              THIS IS LOWER.\n*         JCL(XX) IS THE TWO CHARACTERS SUFFIX TO FORM THE MEMBER NAME\n*              \"IMSLOG..\" (DEFAULT IS 00).\n*         OPTION MAY ONE OF THE FOLLOWING KEYWORDS :\n*                   MSG OR LIST (ALIAS M OR L)\n*              OR : NOMSG OR NOLIST (ALIAS N)\n*              WHICH ALLOWS YOU TO ACCEPT/SUPPRESS ALL MESSAGES.\n* REMARKS : 1. A \"IMSLDS\" COMMAND WITH \"FROM\" AND \"TO\" DATES IDENTICAL\n* --------     IS LIKE \"IMSLDS DAY(DD/MM/YY)\" COMMAND.\n*           2. A \"IMSLDS\" COMMAND WITH ONLY THE \"FROM(DD/MM/YY)\" DATE\n*              WHICH MATCHES THE LAST DAY OF THE MONTH IS ALSO LIKE\n*              A \"IMSLDS DAY(DD/MM/YY)\" COMMAND.\n*\n* COMPLETION CODES :     0 = NORMAL TERMINATION.\n* ==================    16 = A SEVERE ERROR HAS BEEN DETECTED.\n*\n* TSO CLIST :  WHEN RUNNING IN A TSO CLIST ENVIRONMENT, A VARIABLE\n* ===========  NAMED \"EUGENDS\" WILL CONTAIN THE NAME OF THE JCL\n*              GENERATED DATA-SET.\n*\n* AUTHOR :     MOINIL P.A. - COMPUTING CENTRE\n* ========                   J.R.C. - ISPRA ESTABLISHMENT\n*                            21020 ISPRA (VA), ITALY\n         EJECT\n        $DEFREG\n        $XENT  BASE=R12\n         ST    R1,APARM\n         B     BEGIN\n         SPACE 1\n         AIF   ('&SYSPARM' NE '').OK\n        MNOTE  8,' JCL SKELETONS LIBRARY NAME MISSING * * * * * * * * '\n.OK      ANOP\nRPLMEM   DC    CL44'&SYSPARM '\n         EJECT\nBEGIN   @CALL  XINIT,ERR=LEAVE\n        @CALL  XGTSKL,ERR=LEAVE\n        @CALL  XIDCAMS,ERR=LEAVE\n        @CALL  XANALO,ERR=LEAVE\n         TM    RUNSW,SWSYS         SYSTEM TASK?\n         BO    DOSBM               YES\n        @CALL  XGENER\n         B     LEAVE\nDOSBM   @CALL  XSUBMIT\nLEAVE    LR    R10,R15\n        @CALL  XEXIT\n         SPACE 1\n        $XRET  CC=(R15)\n         EJECT\n*------- COMMON DYNAMIC FAILURE MESSAGE ROUTINE\n*              R1 - DYNAM OPERATION NAME ('ALL.' OR 'FREE')\n*              R6 - DD-NAME POINTER\n*              R8 - LINK REGISTER\n         SPACE 1\nDFMR     STCM  R1,B'1111',DFOPER\n         MVC   DFNAME(L'DDNAME),0(R6)\n         UNPK  DFERC(L'DFERC+1),RCODES(3)\n         TR    DFERC(L'DFERC),TRTAB-X'F0'\n         MVI   DFERC+L'DFERC,C''''\n         UNPK  DFINFO(L'DFINFO+1),RCODES+2(3)\n         TR    DFINFO(L'DFINFO),TRTAB-X'F0'\n         MVI   DFINFO+L'DFINFO,C''''\n         UNPK  DFRC15(L'DFRC15+1),RCODES+4(5)\n         TR    DFRC15(L'DFRC15),TRTAB-X'F0'\n         MVI   DFRC15+L'DFRC15,C''''\n         LA    R1,DFMSG1\n         BAS   R9,SMSG\n         LA    R1,DFMSG2\n         BAS   R9,SMSG\n         BR    R8\n         EJECT\n*------- COMMON SEND MESSAGE ROUTINE\n*              R1 - POINTER -> AL1(MESSAGE LENGTH),C'...MESSAGE...'\n*              R9 - LINK REGISTER\n         SPACE 1\nSMSG     TM    REQSW,SWMSG         SUPPRESS ALL MESSAGES?\n         BOR   R9                  YES\n         XR    R15,R15\n         IC    R15,0(R1)\n         LTR   R15,R15\n         BNPR  R9\n         LH    R14,MSGAR\n         SH    R14,=H'4'\n         CLR   R15,R14\n         BNH   *+L'*+2\n         LR    R15,R14\n         LR    R0,R15\n         TM    RUNSW,SWTFG+SWTBG\n         BNZ   SMSG1\n         BCT   R15,*+L'*+6\n         MVC   MSGAR+4(*-*),1(R1)\n         EX    R15,*-6\n        WTO    ,MF=(E,MSGAR)\n         LH    R15,MSGAR\n         SH    R15,=H'6'\n         MVI   MSGAR+4,C' '\n         EX    R15,*+L'*+2\n         BR    R9\n         MVC   MSGAR+5(*-*),MSGAR+4\nSMSG1    BCT   R15,*+L'*+6\n         MVC   MSGOUT(*-*),1(R1)\n         EX    R15,*-6\n         LA    R15,L'MSGCNTL+1(R15)\n         STH   R15,MSGCNTL\n         LA    R0,MSGWORK\n         L     R1,ACPPL\n         USING CPPL,R1\n         L     R14,CPPLUPT\n         L     R15,CPPLECT\n         DROP  R1\n         XC    PECB,PECB\n         XC    PTPB(PTPBLEN),PTPB\n         XC    IOPLZ(IOPLLEN),IOPLZ\n         LA    R1,IOPLZ\n        PUTLINE PARM=PTPB,UPT=(R14),ECT=(R15),ECB=PECB,                X\n               TERMPUT=(EDIT,WAIT,NOHOLD,NOBREAK),                     X\n               OUTPUT=((R0),TERM,SINGLE,DATA),                         X\n               MF=(E,(1))\n         XC    MSGCNTL,MSGCNTL\n         MVI   MSGOUT,C' '\n         MVC   MSGOUT+1(L'MSGOUT-1),MSGOUT\n         BR    R9\n         EJECT\n*------- COMMON CONSTANTS AND WORK AREAS\n         SPACE 1\nDBLWRK   DC    D'0'\nCHKWRK   DC    D'0'\nYESWRK   DC    D'0'\nDYNPLS  $DYNALL ,RCODES,MF=L\nRCODES   DC    2F'0'               DYN. ALL. RETURN CODES\nAPARM    DC    A(*-*)\nATIOT    DC    A(*-*)\nACOMM    DC    A(*-*)\nATSO     DC    A(*-*)\nAPSCB    DC    A(*-*)\nACPPL    DC    A(*-*)\nDALIST   DS    0A\nDAGSKL   DC    A(*-*)\nDAIDIN   DC    A(*-*)\nDAIDOUT  DC    A(*-*)\nDAGJCL   DC    A(*-*)\nNDW      EQU   (*-DALIST)/L'DALIST      NUMBER OF DYN.ALL. AREAS\nTDW      EQU   (((NDW*DYNLGTH)+7)/8)*8  TOTAL GETMAIN AREA LENGTH\nLDYNW    DC    A(TDW)              DYN.ALL. TOTAL LENGTH\nSDYNW    DC    A(*-*)              DYN.ALL. START ADDRESS\nSKW      EQU   (((256*72)+7)/8)*8  TOTAL GETMAIN AREA LENGTH\nLSKLW    DC    A(SKW)              JCL SKELETON TOTAL LENGTH\nSSKLW    DC    A(*-*)              JCL SKELETON START ADDR. (JOB CARD)\nSKLJS    DC    A(*-*)              START WITHOUT JOB CARD\nSKLJE    DC    A(*-*)              LAST JCL CARD\nSKLJI    DC    A(*-*)              INSERT TYPRUN= CARD (JOB CARD)\nLVECT    DC    A(TVT)              ONE VECTOR TOTAL LENGTH\nSVECT    DC    A(*-*)              FIRST VECTOR ADDRESS (SEE VTDSECT)\nCVECT    DC    A(*-*)              CURRENT VECTOR ADDRESS\nOPTIDC   DC    H'0'\nDNMIDC   DC    Y(DNML)\n         DC    4XL8'0'\nDDI      DC    CL8'IDCIN'\nDDO      DC    CL8'IDCOUT'\nDNML     EQU   (*-DNMIDC)-L'DNMIDC\nDDP      DC    CL8'SYSPDS'\nTRTAB    DC    CL16'0123456789ABCDEF'\nSBNAME   DC    CL8' '\nDDG      DC    CL8'GENJCL '\nUSID     DC    CL8' '\nMBNME    DC    CL8'IMSLOG00'\nYDAY     DC    CL5' '              YYDDD\nSDAY     DC    CL5' '              YYDDD\nEDAY     DC    CL5' '              YYDDD\nDDAY     DC    CL6' '              MMDDYY\nFDAY     DC    CL6' '              YYMMDD\nTDAY     DC    CL6' '              YYMMDD\nMONTH    DC    CL4' '              YYMM\nUSIDL    DC    XL1'0'\nRUNSW    DC    XL1'0'\nSWSYS    EQU   X'80'               SYSTEM TASK RUNNING\nSWTFG    EQU   X'40'               TSO FOREGROUND RUNNING\nSWTBG    EQU   X'20'               TSO BACKGROUND RUNNING\nREQSW    DC    XL1'0'\nSWMSG    EQU   X'80'               NO MSG OPTION (TSO COMMAND)\nSWOLD    EQU   X'08'               MONTH LOG DATA-SET EXIST\nSWCPY    EQU   X'02'               SUBMIT JCL OPTION COPY\nSWSCN    EQU   X'01'               SUBMIT JCL OPTION SCAN\nMANSW    DC    XL1'0'\nSWDAY    EQU   X'80'               DAY LEVEL NAME MANDATORY\nSWMON    EQU   X'40'               MONTH LEVEL NAME MANDATORY\n         SPACE 1\nMSGAR   WTO    '                                                       1\n                                      ',ROUTCDE=11,DESC=7,MF=L\nPTPB    PUTLINE MF=L\nPTPBLEN  EQU   *-PTPB\n         DS    0F                  I-O PARM LIST FOR PUTLINE\nIOPLZ    DS    (IOPLLEN)X\nPECB     DS    F\nMSGWORK  DS    0CL82               PUTLINE WORK USE\nMSGCNTL  DS    F                   CONTROL WORD FOR PUTLINE\nMSGOUT   DS    CL78                PUTLINE TEXT\n         SPACE 1\nVARDATA  DC    CL44' '\n         SPACE 1\nDFMSG1   DC    AL1(DFMSG1L),C' -> DYNAMIC '\nDFOPER   DC    CL4' ',C' ('\nDFNAME   DC    CL8' ',C') FAILED : R15 = X'''\nDFRC15   DC    CL8' ',C''' '\nDFMSG1L  EQU   *-(DFMSG1+1)\nDFMSG2   DC    AL1(DFMSG2L),CL28' ',C'ERC = X'''\nDFERC    DC    CL4' ',C''', INFO = X'''\nDFINFO   DC    CL4' ',C''' '\nDFMSG2L  EQU   *-(DFMSG2+1)\nMSERL    DC    AL1(MSERLL),C' => EU-S02A UNMATCHED '\n         DC    C'\"//LOG...    DD DSN=?1...,DISP=\" <-DD-CARD '\nMSERLL   EQU   *-(MSERL+1)\nMSERS    DC    AL1(MSERSL),C' => EU-S03A CANNOT SPLIT '\n         DC    C'\"//LOG...    DD DSN=?1...,DISP=\" <-DD-CARD '\nMSERSL   EQU   *-(MSERS+1)\nMSERO    DC    AL1(MSEROL),C' => EU-S04A UNMATCHED '\n         DC    C'\"//LOGOUT    DD DSN=?2...,DISP=..., \" <-DD-CARD '\nMSEROL   EQU   *-(MSERO+1)\nMSERX    DC    AL1(MSERXL),C' => EU-S05A 44 CHARACTERS LONG '\n         DC    C'\"?1... \" IS MANDATORY '\nMSERXL   EQU   *-(MSERX+1)\n         SPACE 1\n         DC    AL1(L'TEXT)\nTEXT     DC    CL80' '\nLLN      DC    AL1(*-*)\nLINE     DC    CL133' '\nDAYMNL   DC    AL1(*-*)\nDAYMN    DC    CL44' '\nLOGMNL   DC    AL1(*-*)\nLOGMN    DC    CL44' '\n         SPACE 1\n*------- MAIN LITERAL POOL\n         SPACE 1\n        LTORG\n         EJECT\nXINIT   @ENTER\n         USING PSA,R0\n         L     R1,PSAAOLD          GET CURRENT USER-ID (RACF)\n         DROP  R0\n         USING ASCB,R1\n         L     R2,ASCBASXB\n         DROP  R1\n         USING ASXB,R2\n         L     R1,ASXBSENV\n         DROP  R2\n         USING ACEE,R1\n         MVC   USID,ACEEUSRI       GET USER ID\n         MVC   USIDL,ACEEUSRL      GET USER ID LENGTH\n         DROP  R1\n         XC    ATIOT(L'ATIOT+L'ACOMM+L'ATSO+L'APSCB),ATIOT\n        EXTRACT ATIOT,'S',FIELDS=(TIOT,COMM,TSO,PSB)\n         L     R1,ACOMM            COMMUNICATION AREA ADDRESS\n         L     R2,4(R1)            CIB ADDRESS\n         LA    R2,0(R2)\n         LTR   R2,R2               CURRENT CIB SET UP?\n         BZ    *+L'*+12            NO\n         USING CIBDSECT,R2\n         CLI   CIBVERB,CIBSTART    START COMMAND?\n         BNE   *+L'*+4             NO\n         OI    RUNSW,SWSYS         YES, SYSTEM TASK\n         DROP  R2\n         L     R1,ATIOT\n         USING TIODSECT,R1\n         MVC   SBNAME,TIOCNJOB\n         DROP  R1\n         ICM   R2,B'1111',APSCB\n         BZ    PCALL               IF 0 = BATCH-EXEC\n         L     R1,ATSO\n         TM    0(R1),X'80'\n         BZ    *+L'*+8             IF 0 = TSO-BACKGROUND\n         OI    RUNSW,SWTFG\n         B     *+L'*+4\n         OI    RUNSW,SWTBG\n         L     R3,APARM            RESTORE PARM. ADDRESS\n         TM    0(R3),X'80'         CALL PARM. LIST?\n         BO    PCALL               YES, CALL UNDER TSO\n         USING CPPL,R3             SET CPPL ADDRESSABILITY\n         USING PSCB,R2\n         CLC   PSCBUPT,CPPLUPT     CPPL+4 = UPT ADDRESS?\n         BNE   *+L'*+10            NO\n         DROP  R2\n         CLC   APSCB(L'APSCB),CPPLPSCB  CPPL+8 = PSCB ADDRESS?\n         BE    OKSCN               YES, TSO COMMAND\n         LR    R1,R3\n         USING IKJEBECA,R1\n         L     R3,CAPTTMP          CPPL ADDRESS\n         DROP  R1\n         CLC   APSCB(L'APSCB),CPPLPSCB  CPPL+8 = PSCB ADDRESS?\n         BNE   ERROR0              NO, NOT TSO SUB-COMMAND\nOKSCN    ST    R3,ACPPL            RETAIN CPPL ADDRESS\n         LA    R1,MYPPL            SET PARSE PARAMETER LIST (PPL)\n         USING PPL,R1\n         MVC   PPLUPT,CPPLUPT\n         MVC   PPLECT,CPPLECT\n         LA    R0,MYECB\n         ST    R0,PPLECB\n         MVC   PPLPCL,=A(PARMLST)\n         LA    R0,MYANS\n         ST    R0,PPLANS\n         MVC   PPLCBUF,CPPLCBUF\n         DROP  R1,R3\n        CALLTSSR EP=IKJPARS,MF=(E,(1))\n         LR    R10,R15\n         B     *+L'*(R15)          BRANCH ON RETURNED CODE\n         B     PARSOK               0 - SUCCESSFULL\n         B     ERROR1               4 - UNABLE TO PROMPT\n         B     EXINI                8 - USER ATTENTION OCCURED\n         B     ERROR2              12 - PROGRAM BUG\n         B     ERROR3              16 - SPACE UNAVAILABLE IN REGION\n         B     ERROR4              20 - INVALID PARM\n         B     ERROR5              24 - PARM. CONFLICT\n         B     ERROR6              28 - TERMINAL DISCONNECTED\nPARSOK   L     R2,MYANS            CHECK ANSWER ADDRESS\n         LA    R2,0(R2)\n         LTR   R2,R2\n         BZ    ERROR7\n         USING IKJPARMD,R2\n         MVC   DDAY,=CL6' '        SET NONE\n         CLI   PDID+1,0            DAY SPECIFIED?\n         BE    NOIDX               NO\n         TM    SDID+6,X'80'        VALUE PRESENT?\n         BZ    NOIDX               NO\n         LH    R14,SDID+4          GET LENGTH\n         LTR   R14,R14             LENGTH ZERO?\n         BNP   NOIDX               YES\n         L     R15,SDID            POINT TO VALUE\n         CLC   0(4,R15),=CL4'NONE' DEFAULT?\n         BE    NOIDX               YES\n         MVC   DDAY(2),3(R15)      MMDDYY\n         MVC   DDAY+2(2),0(R15)\n         MVC   DDAY+4(2),6(R15)\nNOIDX    MVC   FDAY,=CL6' '        SET NONE\n         CLI   PDIF+1,0            FROM SPECIFIED?\n         BE    NOIFX               NO\n         TM    SDIF+6,X'80'        VALUE PRESENT?\n         BZ    NOIFX               NO\n         LH    R14,SDIF+4          GET LENGTH\n         LTR   R14,R14             LENGTH ZERO?\n         BNP   NOIFX               YES\n         L     R15,SDIF            POINT TO VALUE\n         CLC   0(4,R15),=CL4'NONE' DEFAULT?\n         BE    NOIFX               YES\n         MVC   FDAY+4(2),0(R15)    SET YYMMDD\n         MVC   FDAY+2(2),3(R15)\n         MVC   FDAY(2),6(R15)\nNOIFX    MVC   TDAY,=CL6' '        SET NONE\n         CLI   PDIT+1,0            TO SPECIFIED?\n         BE    NOITX               NO\n         TM    SDIT+6,X'80'        VALUE PRESENT?\n         BZ    NOITX               NO\n         LH    R14,SDIT+4          GET LENGTH\n         LTR   R14,R14             LENGTH ZERO?\n         BNP   NOITX               YES\n         L     R15,SDIT            POINT TO VALUE\n         CLC   0(4,R15),=CL4'NONE' DEFAULT?\n         BE    NOITX               YES\n         MVC   TDAY+4(2),0(R15)    SET YYMMDD\n         MVC   TDAY+2(2),3(R15)\n         MVC   TDAY(2),6(R15)\nNOITX    CLI   PDIJ+1,0            JCL SPECIFIED?\n         BE    NOIJX               NO\n         TM    SDIJ+6,X'80'        VALUE PRESENT?\n         BZ    NOIJX               NO\n         LH    R14,SDIJ+4          GET LENGTH\n         LTR   R14,R14             LENGTH ZERO?\n         BNP   NOIJX               YES\n         L     R15,SDIJ            POINT TO VALUE\n         MVC   MBNME+6(2),0(R15)   SET XX\nNOIJX    LH    R1,PDOP             MSG/NOMSG OPTION\n         LTR   R1,R1\n         BNP   NOOPT\n         BCT   R1,*+L'*+4\n         B     NOOPT\n         OI    REQSW,SWMSG\n         DROP  R2\nNOOPT   IKJRLSA MYANS\n         CLI   DDAY,C' '           DAY SPECIFIED?\n         BE    CHKRG               NO\n         CLI   FDAY,C' '\n         BE    *+L'*+8\n         LA    R1,OCMSG\n         B     EXERX\n         CLI   TDAY,C' '\n         BE    *+L'*+8\n         LA    R1,TOMSG\n         B     EXERX\n         MVC   DBLWRK(L'DDAY),DDAY VALIDATE DAY DATE\n         LA    R0,DBLWRK\n         LA    R15,SDAY\n         BAS   R8,GTSDT\n         B     LSTCK               +0 - OK\n         MVC   S1RC(L'S1RC),DBLWRK+1 +4 - ERROR\n         LA    R1,S1MSG\n         B     EXERS\nCHKRG    CLI   FDAY,C' '           FROM DATE SPECIFIED?\n         BNE   *+L'*+16            YES\n         CLI   TDAY,C' '           NO, TO DATE SPECIFIED?\n         BE    GDFLT               NO, YESTERDAY\n         LA    R1,FRMSG            YES\n         B     EXERX\n         MVC   DBLWRK(4),FDAY+2    VALIDATE FROM DATE\n         MVC   DBLWRK+4(2),FDAY\n         LA    R0,DBLWRK\n         LA    R15,SDAY\n         BAS   R8,GTSDT\n         B     *+L'*+14            +0 - OK\n         MVC   S2RC(L'S2RC),DBLWRK+1 +4 - ERROR\n         LA    R1,S2MSG\n         B     EXERS\n         LA    R0,YESWRK           HERE GET TODAY DATE\n         XR    R15,R15\n         BAS   R8,GTGDT\n         B     *+L'*+4             +0 - OK\n         B     G1ERR               +4 - ERROR\n         LA    R0,YESWRK           NOW GET YESTERDAY DATE\n         LA    R15,YDAY\n         BAS   R8,GTSDT\n         B     *+L'*+4             +0 - OK\n         B     G2ERR               +4 - ERROR\n         PACK  DBLWRK,YDAY+2(3)\n         CVB   R2,DBLWRK\n         PACK  DBLWRK,YDAY(2)\n         CVB   R3,DBLWRK\nGTYT1    BCT   R2,GTYT2\n         LTR   R3,R3\n         BP    *+L'*+4\n         LA    R3,100\n         BCTR  R3,0\n         CVD   R3,DBLWRK\n         UNPK  DBLWRK(3),DBLWRK+6(2)\n         OI    DBLWRK+2,C'0'\n         MVC   YDAY(2),DBLWRK+1\n         LA    R2,366\nGTYT2    CVD   R2,DBLWRK\n         UNPK  YDAY+2(3),DBLWRK+L'DBLWRK-2(2)\n         OI    YDAY+4,C'0'\n         LA    R0,YESWRK\n         LA    R15,YDAY\n         BAS   R8,GTGDT\n         B     *+L'*+14            +0 - OK\n         CLC   YDAY+2(3),=CL3'366' +4 - ERROR\n         BE    GTYT1\n         B     G3ERR\n         ICM   R1,B'1111',YESWRK\n         MVC   YESWRK(2),YESWRK+4\n         STCM  R1,B'1111',YESWRK+2\n         CLC   FDAY(L'FDAY),YESWRK VALID FROM DATE?\n         BNH   *+L'*+8             YES\n         LA    R1,FUMSG\n         B     EXERX\n         CLI   TDAY,C' '\n         BNE   CHKTD\n         MVC   CHKWRK(2),FDAY+2    GET LAST DAY OF MONTH\n         MVC   CHKWRK+4(2),FDAY\n         MVC   DBLWRK+L'DBLWRK-2(2),=PL2'+31'\nGTLDL    UNPK  DBLWRK(3),DBLWRK+L'DBLWRK-2(2)\n         OI    DBLWRK+2,C'0'\n         MVC   CHKWRK+2(2),DBLWRK+1\n         LA    R0,CHKWRK\n         LA    R15,EDAY\n         BAS   R8,GTSDT\n         B     CHKYD               +0 - OK\n         CLC   CHKWRK+2(2),FDAY+4  +4 - ERROR, MATCH FROM DATE?\n         BE    OKCHK               YES, IT IS LIKE DAY DATE\n         BNH   *+L'*+16\n         PACK  DBLWRK,CHKWRK+2(2)\n         SP    DBLWRK+L'DBLWRK-2(2),=PL1'+1'\n         B     GTLDL\n         MVC   S3RC(L'S3RC),DBLWRK+1\n         LA    R1,S3MSG\n         B     EXERS\nCHKYD    ICM   R1,B'1111',CHKWRK\n         MVC   CHKWRK(2),CHKWRK+4\n         STCM  R1,B'1111',CHKWRK+2\n         CLC   CHKWRK(L'FDAY),YESWRK VALID DATE?\n         BNH   OKCHK               YES\n         MVC   EDAY,YDAY           TO DATE = YESTERDAY\nOKCHK    MVC   MONTH(L'MONTH),FDAY\n         B     GTDWS\nCHKTD    CLC   FDAY(4),TDAY        SAME MONTH?\n         BNE   ERRMN               NO\n         CLC   FDAY,TDAY           CORRECTLY SPECIFIED?\n         BH    ERDTE               NO\n         BE    OKCHK               SAME DATE = ONLY ONE DATE\n         CLC   TDAY(L'TDAY),YESWRK VALID TO DATE?\n         BNH   *+L'*+8             YES\n         LA    R1,TUMSG\n         B     EXERX\n         MVC   DBLWRK(4),TDAY+2    VALIDATE TO DATE\n         MVC   DBLWRK+4(2),TDAY\n         LA    R0,DBLWRK\n         LA    R15,EDAY\n         BAS   R8,GTSDT\n         B     OKCHK               +0 - OK\n         MVC   S4RC(L'S4RC),DBLWRK+1 +4 - ERROR\n         LA    R1,S4MSG\n         B     EXERS\nERRMN    LA    R1,MNMSG\n         B     EXERX\nERDTE    LA    R1,DTMSG\n         B     EXERX\nERROR0   LA    R1,ERRMS0\n         B     EXERX\nERROR1   LA    R1,ERRMS1\n         B     EXERS\nERROR2   LA    R1,ERRMS2\n         B     EXERS\nERROR3   LA    R1,ERRMS3\n         B     EXERS\nERROR4   LA    R1,ERRMS4\n         B     EXERS\nERROR5   LA    R1,ERRMS5\n         B     EXERS\nERROR6   LA    R1,ERRMS6\n         B     EXERS\nERROR7   LA    R1,ERRMS7\n         B     EXERX\nPCALL    L     R1,APARM            RESTORE PARM. ADDRESS\n         L     R1,0(R1)            PARM. FIELD ADDRESS\n         LH    R4,0(R1)            PARM. FIELD LENGTH\n         LTR   R4,R4\n         BNP   PAEND               NO PARM. FIELD\n         LA    R2,2(R1)            SET START OF PARM. FIELD TEXT\n         LA    R4,1(R4,R1)         END OF PARM. FIELD TEXT\nPANW     CLI   SDAY,C' '\n         BNE   PA2                 NOT FIRST TIME\n         CLI   0(R2),C'D'\n         BNE   PA2                 NOT DAY= OR D= KEYWORD\n         LA    R1,1(R2)\n         CLR   R1,R4\n         BH    PARMERR             END OF PARM. FIELD TEXT\n         CLI   0(R1),C'='\n         BE    PA1\n         LA    R0,2(R1)\n         CLR   R0,R4\n         BH    PARMERR             END OF PARM. FIELD TEXT\n         CLC   0(3,R1),=CL3'AY='\n         BNE   PARMERR             NOT DAY= KEYWORD\n         LA    R2,2(R2)\nPA1      LA    R2,2(R2)            START OF OPERAND ANALYSIS\n         CLR   R2,R4\n         BH    PAEND               NULL OPERAND\n         CLI   0(R2),C','\n         BE    PASK                NULL OPERAND\n         LA    R5,SDAY\n         LA    R6,L'SDAY           OPERAND LENGTH CONTROL\nPA1A     CLI   0(R2),C'0'\n         BL    PARMERR             NOT NUMERIC\n         CLI   0(R2),C'9'\n         BH    PARMERR             NOT NUMERIC\n         MVC   0(1,R5),0(R2)       MOVE OPERAND TO DESTINATION FIELD\n         LA    R2,1(R2)            INCREMENT POINTERS\n         LA    R5,1(R5)\n         CLR   R2,R4\n         BH    *+L'*+8             END OF PARM. FIELD TEXT\n         BCT   R6,PA1A             TEST OPERAND VALIDITY-LENGTH\n         B     PATS                SEPARATOR\n         BCT   R6,PARMERR\n         B     PAEND\nPA2      CLC   MBNME+6(2),=CL2'00'\n         BNE   PA3                 NOT FIRST TIME\n         CLI   0(R2),C'J'\n         BNE   PA3                 NOT JCL=, JOB= OR J= KEYWORD\n         LA    R1,1(R2)\n         CLR   R1,R4\n         BH    PARMERR             END OF PARM. FIELD TEXT\n         CLI   0(R1),C'='\n         BE    PA2A\n         LA    R0,2(R1)\n         CLR   R0,R4\n         BH    PARMERR             END OF PARM. FIELD TEXT\n         CLC   0(3,R1),=CL3'CL='\n         BE    *+L'*+10\n         CLC   0(3,R1),=CL3'OB='\n         BNE   PARMERR             NOT JCL= OR JOB= KEYWORD\n         LA    R2,2(R2)\nPA2A     LA    R2,2(R2)            START OF OPERAND ANALYSIS\n         CLR   R2,R4\n         BH    PAEND               NULL OPERAND\n         CLI   0(R2),C','\n         BE    PASK                NULL OPERAND\n         LA    R5,MBNME+6\n         LA    R6,2                OPERAND LENGTH CONTROL\nPA2B     CLI   0(R2),C' '\n         BE    PARMERR             REJECT BLANK\n         MVC   0(1,R5),0(R2)       MOVE OPERAND TO DESTINATION FIELD\n         LA    R2,1(R2)            INCREMENT POINTERS\n         LA    R5,1(R5)\n         CLR   R2,R4\n         BH    *+L'*+8             END OF PARM. FIELD TEXT\n         BCT   R6,PA2B             TEST OPERAND VALIDITY-LENGTH\n         B     PATS                SEPARATOR\n         BCT   R6,PARMERR\n         B     PAEND\nPA3      TM    RUNSW,SWSYS         SYSTEM TASK?\n         BZ    PATS                NO\n         CLI   0(R2),C'C'\n         BNE   PA4                 NOT C(OPY) KEYWORD\n         LA    R2,1(R2)\n         CLR   R2,R4\n         BNH   *+L'*+8\n         OI    REQSW,SWCPY\n         B     PAEND               END OF PARM. FIELD TEXT\n         LA    R1,2(R2)\n         CLR   R1,R4\n         BH    PARMERR             END OF PARM. FIELD TEXT\n         CLC   0(3,R2),=CL3'OPY'\n         BNE   PARMERR             NOT COPY KEYWORD\n         OI    REQSW,SWCPY\n         LA    R2,3(R2)\n         B     PANX\nPA4      CLI   0(R2),C'S'\n         BNE   PATS                NOT S(CAN) KEYWORD\n         LA    R2,1(R2)\n         CLR   R2,R4\n         BNH   *+L'*+8\n         OI    REQSW,SWSCN\n         B     PAEND               END OF PARM. FIELD TEXT\n         LA    R1,2(R2)\n         CLR   R1,R4\n         BH    PARMERR             END OF PARM. FIELD TEXT\n         CLC   0(3,R2),=CL3'CAN'\n         BNE   PARMERR             NOT SCAN KEYWORD\n         OI    REQSW,SWSCN\n         LA    R2,3(R2)\nPANX     CLR   R2,R4\n         BH    PAEND               END OF PARM. FIELD TEXT\nPATS     CLI   0(R2),C','\n         BNE   PARMERR             NOT SEPARATOR\nPASK     LA    R2,1(R2)            INCREMENT POINTER\n         CLR   R2,R4\n         BH    PAEND               END OF PARM. FIELD TEXT\n         CLI   0(R2),C','\n         BE    PASK                SEPARATOR AGAIN\n         B     PANW                GO TO SEE ANY KEYWORD\nPARMERR  LA    R1,PAMSG\n         B     EXERX\nPAEND    CLC   SDAY+2(3),=CL3'366'\n         BNH   *+L'*+8\n         LA    R1,PRMSG\n         B     EXERX\n         CLC   SDAY(L'SDAY),=CL6' ' SERIAL DAY DEFINED?\n         BE    GDFLT               NO\n         LA    R0,DBLWRK\n         LA    R15,SDAY\n         BAS   R8,GTGDT\n         B     LSTCK               +0 - OK\n         MVC   VDRC(L'VDRC),DBLWRK+1 +4 - ERROR\n         LA    R1,VDMSG\n         B     EXERS\nGDFLT    LA    R0,DBLWRK           GET TODAY DATE\n         XR    R15,R15\n         BAS   R8,GTGDT\n         B     *+L'*+4             +0 - OK\n         B     G1ERR               +4 - ERROR\n         LA    R0,DBLWRK           NOW GET YESTERDAY DATE\n         LA    R15,SDAY\n         BAS   R8,GTSDT\n         B     *+L'*+14            +0 - OK\nG2ERR    MVC   G2RC(L'G2RC),DBLWRK+1 +4 - ERROR\n         LA    R1,G2MSG\n         B     EXERS\n         PACK  DBLWRK,SDAY+2(3)\n         CVB   R2,DBLWRK\n         PACK  DBLWRK,SDAY(2)\n         CVB   R3,DBLWRK\nGDFLT1   BCT   R2,GDFLT2\n         LTR   R3,R3\n         BP    *+L'*+4\n         LA    R3,100\n         BCTR  R3,0\n         CVD   R3,DBLWRK\n         UNPK  DBLWRK(3),DBLWRK+6(2)\n         OI    DBLWRK+2,C'0'\n         MVC   SDAY(2),DBLWRK+1\n         LA    R2,366\nGDFLT2   CVD   R2,DBLWRK\n         UNPK  SDAY+2(3),DBLWRK+L'DBLWRK-2(2)\n         OI    SDAY+4,C'0'\n         LA    R0,DBLWRK\n         LA    R15,SDAY\n         BAS   R8,GTGDT\n         B     LSTCK               +0 - OK\n         CLC   SDAY+2(3),=CL3'366' +4 - ERROR\n         BE    GDFLT1\nG3ERR    MVC   G3RC(L'G3RC),DBLWRK+1\n         LA    R1,G3MSG\n         B     EXERS\nLSTCK    ICM   R1,B'1111',DBLWRK\n         MVC   DBLWRK(2),DBLWRK+4\n         STCM  R1,B'1111',DBLWRK+2\n         LA    R0,CHKWRK\n         XR    R15,R15\n         BAS   R8,GTGDT\n         B     *+L'*+18            +0 - OK\nG1ERR    MVC   G1RC(L'G1RC),DBLWRK+1 +4 - ERROR\n         LA    R1,G1MSG\nEXERS    BAS   R9,SMSG\n         B     EXINI\n         ICM   R1,B'1111',CHKWRK\n         MVC   CHKWRK(2),CHKWRK+4\n         STCM  R1,B'1111',CHKWRK+2\n         CLC   DBLWRK,CHKWRK\n         BL    CHKOK\n         LA    R1,FTMSG\nEXERX    BAS   R9,SMSG\n         LR    R10,R9\n         B     EXINI\nCHKOK    MVC   MONTH(L'MONTH),DBLWRK\nGTDWS    L     R0,LDYNW\n         LR    R3,R0\n        GETMAIN R,LV=(0)           GET DYNAMIC WORK STORAGE\n         ST    R1,SDYNW\n         ST    R1,DAGSKL\n         LR    R2,R1\n         LA    R1,DYNLGTH(R1)\n         ST    R1,DAIDIN\n         LA    R1,DYNLGTH(R1)\n         ST    R1,DAIDOUT\n         LA    R1,DYNLGTH(R1)\n         ST    R1,DAGJCL\n         XR    R5,R5\n         ICM   R5,B'1000',=CL6' '\n         BASR  R4,0\n         MVCL  R2,R4\n         XR    R10,R10\nEXINI   @EXIT  (R10)\n         SPACE 1\n*------- DATES SERVICES ROUTINES\n*              R8 - LINK REGISTER / RETURN +0 = OK\n*                                          +4 = ERROR\n*                                               (EDITED RC IN DBLWRK)\n*              R10 = R15 - RETURN CODE\n         SPACE 1\nGTSDT   $SDATE (R0),(R15)\n         B     GTTRC\nGTGDT   $GDATE ,,(R0),(R15)\nGTTRC    LTR   R10,R15\n         BZR   R8\n         CVD   R10,DBLWRK\n         MVC   DBLWRK(4),=XL4'40202120'\n         ED    DBLWRK(4),DBLWRK+L'DBLWRK-2\n         B     4(R8)\n         SPACE 1\nMYPPL    DC    0F'0',(PPLL)X'0'\nMYANS    DC    F'0'\nMYECB    DC    F'0'\n         SPACE 1\nERRMS0   DC    AL1(ERRMS0L)\n         DC    C' -> NOT TSO COMMAND OR SUB-COMMAND NOR CALL ? '\nERRMS0L  EQU   *-(ERRMS0+1)\nERRMS1   DC    AL1(ERRMS1L)\n         DC    C' -> INCOMPLETE PARAMETERS OR UNABLE TO PROMPT '\nERRMS1L  EQU   *-(ERRMS1+1)\nERRMS2   DC    AL1(ERRMS2L),C' -> PARSE PARAMETER BLOCK INVALID '\nERRMS2L  EQU   *-(ERRMS2+1)\nERRMS3   DC    AL1(ERRMS3L),C' -> NOT ENOUGH SPACE IN REGION '\nERRMS3L  EQU   *-(ERRMS3+1)\nERRMS4   DC    AL1(ERRMS4L),C' -> INVALID PARAMETERS '\nERRMS4L  EQU   *-(ERRMS4+1)\nERRMS5   DC    AL1(ERRMS5L),C' -> PARAMETERS CONFLICT '\nERRMS5L  EQU   *-(ERRMS5+1)\nERRMS6   DC    AL1(ERRMS6L),C' -> TERMINAL HAS BEEN DISCONNECTED '\nERRMS6L  EQU   *-(ERRMS6+1)\nERRMS7   DC    AL1(ERRMS7L),C' -> PARSE ANSWER ADDRESS ERROR '\nERRMS7L  EQU   *-(ERRMS7+1)\nPAMSG    DC    AL1(PAMSGL),C' -> INVALID PARM. FIELD TEXT / '\n         DC    C'SYNTAX ERROR DETECTED '\nPAMSGL   EQU   *-(PAMSG+1)\nPRMSG    DC    AL1(PRMSGL),C' -> INVALID REQUESTED DAY / '\n         DC    C'MAX. DDD VALUE IS 366 '\nPRMSGL   EQU   *-(PRMSG+1)\nFTMSG    DC    AL1(FTMSGL),C' -> INVALID REQUESTED DAY / '\n         DC    C'HIGHER THAN YESTERDAY '\nFTMSGL   EQU   *-(FTMSG+1)\nFUMSG    DC    AL1(FUMSGL),C' -> INVALID \"FROM\" DATE / '\n         DC    C'HIGHER THAN YESTERDAY '\nFUMSGL   EQU   *-(FUMSG+1)\nTUMSG    DC    AL1(TUMSGL),C' -> INVALID \"TO\" DATE / '\n         DC    C'HIGHER THAN YESTERDAY '\nTUMSGL   EQU   *-(TUMSG+1)\nOCMSG    DC    AL1(OCMSGL),C' -> \"DAY\" AND \"FROM\" OPERANDS CONFLICT '\nOCMSGL   EQU   *-(OCMSG+1)\nTOMSG    DC    AL1(TOMSGL),C' -> \"DAY\" AND \"TO\" OPERANDS CONFLICT '\nTOMSGL   EQU   *-(TOMSG+1)\nDTMSG    DC    AL1(DTMSGL),C' -> \"FROM\" DATE GREATER THAN \"TO\" DATE '\nDTMSGL   EQU   *-(DTMSG+1)\nFRMSG    DC    AL1(FRMSGL),C' -> \"FROM\" DATE MISSING '\nFRMSGL   EQU   *-(FRMSG+1)\nMNMSG    DC    AL1(MNMSGL),C' -> \"FROM\" AND \"TO\" DATES ARE NOT IN '\n         DC    C'THE SAME MONTH '\nMNMSGL   EQU   *-(MNMSG+1)\nVDMSG    DC    AL1(VDMSGL),C' -> INVALID REQUESTED DAY / '\n         DC    C'$GDATE RC='\nVDRC     DC    CL3' ',C' '\nVDMSGL   EQU   *-(VDMSG+1)\nS1MSG    DC    AL1(S1MSGL),C' -> UNABLE TO GET \"DAY\" SERIAL DATE / '\n         DC    C'$SDATE RC='\nS1RC     DC    CL3' ',C' '\nS1MSGL   EQU   *-(S1MSG+1)\nS2MSG    DC    AL1(S2MSGL),C' -> UNABLE TO GET \"FROM\" SERIAL DATE / '\n         DC    C'$SDATE RC='\nS2RC     DC    CL3' ',C' '\nS2MSGL   EQU   *-(S2MSG+1)\nS3MSG    DC    AL1(S3MSGL),C' -> UNABLE TO GET LAST DAY OF MONTH '\n         DC    C'SERIAL DATE / $SDATE RC='\nS3RC     DC    CL3' ',C' '\nS3MSGL   EQU   *-(S3MSG+1)\nS4MSG    DC    AL1(S4MSGL),C' -> UNABLE TO GET \"TO\" SERIAL DATE / '\n         DC    C'$SDATE RC='\nS4RC     DC    CL3' ',C' '\nS4MSGL   EQU   *-(S4MSG+1)\nG1MSG    DC    AL1(G1MSGL),C' -> UNABLE TO GET TODAY DATE / '\n         DC    C'$GDATE RC='\nG1RC     DC    CL3' ',C' '\nG1MSGL   EQU   *-(G1MSG+1)\nG2MSG    DC    AL1(G2MSGL),C' -> UNABLE TO GET TODAY SERIAL DATE / '\n         DC    C'$SDATE RC='\nG2RC     DC    CL3' ',C' '\nG2MSGL   EQU   *-(G2MSG+1)\nG3MSG    DC    AL1(G3MSGL),C' -> UNABLE TO GET YESTERDAY DATE / '\n         DC    C'$GDATE RC='\nG3RC     DC    CL3' ',C' '\nG3MSGL   EQU   *-(G3MSG+1)\n         SPACE 1\n        @STOP\n         EJECT\n* ------ PARSE VALIDITY CHECK ROUTINES\n*        1. CONTROL DATE (DD/MM/YY) SUPPLIED BY THE\n*           'FROM' (ALIAS 'DAY') AND 'TO' KEYWORDS.\n         SPACE 1\n         CNOP  0,8\n         USING *,R8\nDTEVALCK STM   R14,R12,12(R13)\n         LR    R8,R15\n         L     R2,0(,R1)           -> PDE\n         L     R3,0(,R2)           -> CHARACTER STRING\n         LA    R15,4               RETURN 4 IF CHECK FAILS\n         LH    R0,4(R2)            -> STRING LENGTH\n         LTR   R0,R0               NULL STRING?\n         BNP   DTEVALX             YES, OK\n         CH    R0,=H'4'            LENGTH OF 4 CHARACTERS?\n         BNE   *+L'*+14            NO\n         CLC   0(4,R3),=CL4'NONE'  DEFAULT?\n         BE    DTEVALX             YES, OK\n         B     DTEERRX             NO, EXIT WITH RC=4\n         CH    R0,=H'8'            LENGTH OF 8 CHARACTERS?\n         BNE   DTEERRX             NO, EXIT WITH RC=4\n         CLI   2(R3),C'/'          SLASH?\n         BE    DTEV1OK             YES\n         CLI   2(R3),C'.'          PERIOD?\n         BE    DTEV1ST             YES\n         CLI   2(R3),C'-'          MINUS?\n         BNE   DTEERRX             NO, EXIT WITH RC=4\nDTEV1ST  MVI   2(R3),C'/'          SET A SLASH\nDTEV1OK  CLI   5(R3),C'/'          SLASH?\n         BE    DTEV2OK             YES\n         CLI   5(R3),C'.'          PERIOD?\n         BE    DTEV2ST             YES\n         CLI   5(R3),C'-'          MINUS?\n         BNE   DTEERRX             NO, EXIT WITH RC=4\nDTEV2ST  MVI   5(R3),C'/'          SET A SLASH\nDTEV2OK  ICM   R0,B'1111',0(R3)    TEST NUMERICS?\n         N     R0,=A(X'F0F000F0')\n         CL    R0,=A(X'F0F000F0')\n         BNE   DTEERRX             NO, EXIT WITH RC=4\n         ICM   R0,B'1111',4(R3)\n         N     R0,=A(X'F000F0F0')\n         CL    R0,=A(X'F000F0F0')\n         BNE   DTEERRX             NO, EXIT WITH RC=4\n         CLC   0(2,R3),=CL2'01'    VALID DD (DAY)?\n         BL    DTEERRX             NO, EXIT WITH RC=4\n         CLC   0(2,R3),=CL2'31'    IN RANGE 01 THRU 31?\n         BH    DTEERRX             NO, EXIT WITH RC=4\n         CLC   3(2,R3),=CL2'01'    VALID MM (MONTH)?\n         BL    DTEERRX             NO, EXIT WITH RC=4\n         CLC   3(2,R3),=CL2'12'    IN RANGE 01 THRU 12?\n         BH    DTEERRX             NO, EXIT WITH RC=4\nDTEVALX  XR    R15,R15             SET RC=0\nDTEERRX  L     R14,12(,R13)\n         LM    R0,R12,20(R13)\n         BR    R14\n         SPACE 1\n         LTORG\n         SPACE 1\n         DROP  R8\n         SPACE 1\n*        2. CONTROL SUFFIX (XX) SUPPLIED BY 'JCL' KEYWORD.\n         SPACE 1\n         CNOP  0,8\n         USING *,R8\nJCLVALCK STM   R14,R12,12(R13)\n         LR    R8,R15\n         L     R2,0(,R1)           -> PDE\n         L     R3,0(,R2)           -> CHARACTER STRING\n         LA    R15,4               RETURN 4 IF CHECK FAILS\n         LH    R0,4(R2)            -> STRING LENGTH\n         LTR   R0,R0               NULL STRING?\n         BNP   JCLVALX             YES, OK\n         CH    R0,=H'2'            LENGTH OF 2 CHARACTERS?\n         BE    JCLVALX             YES, OK\n         B     JCLERRX             NO, EXIT WITH RC=4\nJCLVALX  XR    R15,R15             SET RC=0\nJCLERRX  L     R14,12(,R13)\n         LM    R0,R12,20(R13)\n         BR    R14\n         SPACE 1\n         LTORG\n         SPACE 1\n         DROP  R8\n         EJECT\nXGTSKL  @ENTER\n         L     R6,DAGSKL           GET SKELETON ALLOCATION\n         USING DYNLIST,R6\n         MVC   DDNAME,DDP\n         MVC   DSNAME,RPLMEM\n         MVC   DSSTATUS(3),=CL3'SHR'\n        $DYNALL (R6),,MF=(E,DYNPLS)\n         LTR   R10,R15             TEST RETURN CODE\n         BZ    OKGPDS              OK, ALLOCATED\n         ICM   R1,B'1111',=CL4'ALL.'\n         BAS   R8,DFMR\n         XC    DSNAME,DSNAME\n         B     EXGTS\n         DROP  R6\nOKGPDS  $MOPEN DBLWRK\n         LTR   R10,R15\n         BZ    OKGOPN\n         CVD   R10,DBLWRK\n         MVC   DBLWRK(4),=XL4'40202120'\n         ED    DBLWRK(4),DBLWRK+L'DBLWRK-2\n         MVC   MORC(L'MORC),DBLWRK+1\n         LA    R1,MOMSG\n         BAS   R9,SMSG\n         B     EXGTS\nOKGOPN   L     R0,DBLWRK\n         CH    R0,=Y(L'TEXT)\n         BE    OKLRL\n         LA    R1,LOMSG\n         BAS   R9,SMSG\n         LR    R10,R9\n         B     GSCLS\nOKLRL   $MFIND MBNME\n         LTR   R10,R15\n         BZ    OKMFN\n         CVD   R10,DBLWRK\n         MVC   DBLWRK(4),=XL4'40202120'\n         ED    DBLWRK(4),DBLWRK+L'DBLWRK-2\n         MVC   FORC(L'FORC),DBLWRK+1\n         LA    R1,FOMSG\n         BAS   R9,SMSG\n         CH    R10,=H'3'\n         BNE   GSCLS\n         MVC   NFMB,MBNME\n         LA    R1,NFMSG\n         BAS   R9,SMSG\n         B     GSCLS\nOKMFN    L     R0,LSKLW\n        GETMAIN R,LV=(0)           GET JCL WORK STORAGE\n         ST    R1,SSKLW\n         LR    R6,R1\nGNXSK   $MREAD TEXT\n         LTR   R10,R15\n         BM    GSEND\n         BZ    OKGRD\n         CVD   R10,DBLWRK\n         MVC   DBLWRK(4),=XL4'40202120'\n         ED    DBLWRK(4),DBLWRK+L'DBLWRK-2\n         MVC   MRRC(L'MRRC),DBLWRK+1\n         LA    R1,MRMSG\n         BAS   R9,SMSG\n         B     GSCLS\nOKGRD    CLC   TEXT(3),=CL3'***'\n         BE    GNXSK\n         CLI   TEXT,C'?'\n         BE    GSDEF\n         MVC   0(72,R6),TEXT\n         LA    R6,72(R6)\n         CLC   TEXT(2),=CL2'/*'\n         BE    GNXSK\n         CLC   TEXT(3),=CL3'//*'\n         BE    GNXSK\n         LM    R1,R3,=A(TEXT,1,TEXT+70)\n         BXLE  R1,R2,*+L'*+4\n         B     GNXSK\n         CLI   0(R1),C'?'\n         BNE   *-12\n         CLC   0(5,R1),=CL5'?1...'\n         BE    GNXS1\n         CLC   0(5,R1),=CL5'?2...'\n         BE    GNXS2\n         B     GNXSK\nGNXS1    OI    MANSW,SWDAY\n         B     GNXSK\nGNXS2    OI    MANSW,SWMON\n         B     GNXSK\nGSDEF    CLI   TEXT+1,C'I'\n         BE    GSSJI\n         CLI   TEXT+1,C'0'\n         BE    GSSJS\n         CLI   TEXT+1,C'1'\n         BE    *+L'*+8\n         CLI   TEXT+1,C'2'\n         BNE   GNXSK\n         LM    R1,R3,=A(TEXT,1,TEXT+70)\n         LA    R1,2(R1)\n         CLI   0(R1),C' '\n         BNE   *+L'*+8\n         BXLE  R1,R2,*-8\n         B     GDERL\n         LR    R4,R1\n         BXLE  R1,R2,*+L'*+4\n         B     *+L'*+8\n         CLI   0(R1),C' '\n         BNE   *-12\n         SR    R1,R4\n         BNP   GDERL\n         CLI   TEXT+1,C'1'\n         BNE   *+L'*+16\n         CH    R1,=H'24'\n         BH    GDERL\n         LA    R2,DAYMNL\n         B     GSSET\n         CH    R1,=H'38'\n         BH    GDERL\n         LA    R2,LOGMNL\nGSSET    STC   R1,0(R2)\n         BCT   R1,*+L'*+6\n         MVC   1(*-*,R2),0(R4)\n         EX    R1,*-6\n         B     GNXSK\nGSSJI    ST    R6,SKLJI            INSERT TYPRUN= CARD\n         B     GNXSK\nGSSJS    ST    R6,SKLJS            START WITHOUT JOB CARD\n         B     GNXSK\nGDERL    MVC   GSLN(L'GSLN),TEXT\n         LA    R1,GSMSG\n         BAS   R9,SMSG\n         LR    R10,R9\n         B     GSCLS\nGSEND    SH    R6,=H'72'\n         ST    R6,SKLJE\n         XR    R10,R10\nGSCLS   $MCLOSE ,\n         LTR   R10,R10\n         BZ    *+L'*+12\n         LTR   R15,R15\n         BZ    OKGCLS\n         LR    R10,R15\n         B     *+L'*+6\n         LTR   R10,R15\n         BZ    OKGCLS\n         CVD   R10,DBLWRK\n         MVC   DBLWRK(4),=XL4'40202120'\n         ED    DBLWRK(4),DBLWRK+L'DBLWRK-2\n         MVC   MCRC(L'MCRC),DBLWRK+1\n         LA    R1,MCMSG\n         BAS   R9,SMSG\nOKGCLS   L     R6,DAGSKL           GET SKELETON DE-ALLOCATION\n         USING DYNLIST,R6\n         XC    DSNAME,DSNAME\n        $DYNALL (R6),,MF=(E,DYNPLS)\n         LTR   R10,R10\n         BZ    *+L'*+12\n         LTR   R15,R15\n         BZ    EXGTS\n         LR    R10,R15\n         B     *+L'*+6\n         LTR   R10,R15\n         BZ    *+L'*+12\n         ICM   R1,B'1111',=CL4'FREE'\n         BAS   R8,DFMR\n         DROP  R6\n         B     EXGTS\n         OC    SKLJS,SKLJS\n         BNZ   *+L'*+8\n         MVI   GENR,C'0'\n         B     GERRM\n         OC    SKLJI,SKLJI\n         BNZ   *+L'*+8\n         MVI   GENR,C'I'\n         B     GERRM\n         TM    MANSW,SWDAY\n         BO    *+L'*+14\n         MVC   RFMB,MBNME\n         LA    R1,RFMSG\n         B     GSERR\n         XR    R1,R1\n         IC    R1,DAYMNL\n         LTR   R1,R1\n         BP    *+L'*+8\n         MVI   GENR,C'1'\n         B     GERRM\n         TM    MANSW,SWMON\n         BZ    EXGTS\n         MVI   TEXT,C' '\n         MVC   TEXT+1(L'TEXT-1),TEXT\n         XR    R1,R1               BUILD MONTH DATA-SET NAME\n         IC    R1,LOGMNL\n         LTR   R1,R1\n         BP    BLDNM\n         MVI   GENR,C'2'\nGERRM    MVC   GEMB,MBNME\n         LA    R1,GEMSG\nGSERR    BAS   R9,SMSG\n         LR    R10,R9\n         B     EXGTS\nBLDNM    BCT   R1,*+L'*+6\n         MVC   TEXT(*-*),LOGMN\n         EX    R1,*-6\n         LA    R1,TEXT+1(R1)\n         MVC   0(2,R1),=CL2'.M'\n         MVC   2(L'MONTH,R1),MONTH\n         TM    RUNSW,SWSYS         SYSTEM TASK?\n         BZ    *+L'*+10            NO, CHANGE USER-ID PREFIX\n         MVC   LOGMN(L'LOGMN),TEXT YES, OK\n         B     CMPLG\n         XR    R1,R1\n         IC    R1,USIDL\n         BCT   R1,*+L'*+6\n         MVC   LOGMN(*-*),USID\n         EX    R1,*-6\n         LA    R3,LOGMN+1(R1)\n         LA    R1,TEXT\n         CLI   0(R1),C'.'\n         BE    *+L'*+8\n         LA    R1,1(R1)\n         B     *-12\n         LR    R2,R1\n         LA    R1,1(R1)\n         CLI   0(R1),C' '\n         BNE   *-8\n         SLR   R1,R2\n         BCT   R1,*+L'*+6\n         MVC   0(*-*,R3),0(R2)\n         EX    R1,*-6\nCMPLG    LA    R1,LOGMN+L'LOGMN-1\n         CLI   0(R1),C' '\n         BNE   *+L'*+4\n         BCT   R1,*-8\n         LA    R0,LOGMNL\n         SLR   R1,R0\n         STC   R1,LOGMNL\nEXGTS   @EXIT  (R10)\n         SPACE 1\nMOMSG    DC    AL1(MOMSGL),C' -> GET JCL SKELETON FAILED / '\n         DC    C'$MOPEN RC='\nMORC     DC    CL3' ',C' '\nMOMSGL   EQU   *-(MOMSG+1)\nLOMSG    DC    AL1(LOMSGL),C' -> GET JCL SKELETON FAILED / '\n         DC    C'PO-LRECL NOT 80 '\nLOMSGL   EQU   *-(LOMSG+1)\nFOMSG    DC    AL1(FOMSGL),C' -> GET JCL SKELETON FAILED / '\n         DC    C'$MFIND RC='\nFORC     DC    CL3' ',C' '\nFOMSGL   EQU   *-(FOMSG+1)\nNFMSG    DC    AL1(NFMSGL),C' -> JCL SKELETON MEMBER \"'\nNFMB     DC    CL8' ',C'\" NOT FOUND '\nNFMSGL   EQU   *-(NFMSG+1)\nMRMSG    DC    AL1(MRMSGL),C' -> GET JCL SKELETON FAILED / '\n         DC    C'$MREAD RC='\nMRRC     DC    CL3' ',C' '\nMRMSGL   EQU   *-(MRMSG+1)\nMCMSG    DC    AL1(MCMSGL),C' -> GET JCL SKELETON FAILED / '\n         DC    C'$MCLOSE RC='\nMCRC     DC    CL3' ',C' '\nMCMSGL   EQU   *-(MCMSG+1)\nGSMSG    DC    AL1(GSMSGL),C' -> GET JCL SKELETON FAILED / '\nGSLN     DC    CL2' ',C' LEVEL NAME ERROR '\nGSMSGL   EQU   *-(GSMSG+1)\nGEMSG    DC    AL1(GEMSGL),C' -> JCL SKELETON \"'\nGEMB     DC    CL8' ',C'\" REQUIRE ?'\nGENR     DC    CL1' ',C' DEFINITION '\nGEMSGL   EQU   *-(GEMSG+1)\nRFMSG    DC    AL1(RFMSGL),C' -> JCL SKELETON \"'\nRFMB     DC    CL8' ',C'\" HAS NO REFERENCE TO ?1 DEFINITION '\nRFMSGL   EQU   *-(RFMSG+1)\n         SPACE 1\n        @STOP\n         EJECT\nXIDCAMS @ENTER\n         L     R6,DAIDIN           IDCAMS INPUT ALLOCATION\n         USING DYNLIST,R6\n         MVC   DDNAME,DDI\n         MVC   DSNAME(6),=CL6'&&&&IDIN'\n         MVI   DSPRI,C'2'\n         MVC   DSBLKSI(3),=CL3'800'\n         MVC   DSORG(2),=CL2'PS'\n         MVC   DSLRECL(2),=CL2'80'\n         MVI   DSRECFM1,C'F'\n         MVI   DSRECFM2,C'B'\n         MVC   DSSTATUS(3),=CL3'NEW'\n         MVC   DSNDISP(6),=CL6'DELETE'\n         MVC   DSADISP(6),=CL6'DELETE'\n         MVC   DSUNIT(3),=CL3'VIO'\n         MVC   DSALLOC(3),=CL3'TRK'\n         MVI   DSSEC,C'1'\n        $DYNALL (R6),,MF=(E,DYNPLS)\n         LTR   R10,R15             TEST RETURN CODE\n         BZ    OKIDCI              OK, ALLOCATED\n         ICM   R1,B'1111',=CL4'ALL.'\n         BAS   R8,DFMR\n         XC    DSNAME,DSNAME\n         B     EXIDC\nOKIDCI   MVI   TEXT,C' '\n         MVC   TEXT+1(L'TEXT-1),TEXT\n         TM    MANSW,SWMON\n         BZ    NOMDS\n         MVC   TEXT+2(12),=CL12'LISTCAT ENT('\n         XR    R1,R1\n         IC    R1,LOGMNL\n         BCT   R1,*+L'*+6\n         MVC   TEXT+14(*-*),LOGMN\n         EX    R1,*-6\n         LA    R1,TEXT+15(R1)\n         MVC   0(7,R1),=CL7') NVSAM'\n        $PUNCH TEXT,,DDI\n         LTR   R10,R15\n         BNZ   IDINCL\n         MVC   TEXT+1(L'TEXT-1),TEXT\nNOMDS    MVC   TEXT+2(12),=CL12'LISTCAT LVL('\n         XR    R1,R1\n         IC    R1,DAYMNL\n         BCT   R1,*+L'*+6\n         MVC   TEXT+14(*-*),DAYMN\n         EX    R1,*-6\n         LA    R2,TEXT+15(R1)\n         MVC   0(2,R2),=CL2'.D'\n         MVC   2(L'SDAY,R2),SDAY\n         MVC   2+L'SDAY(7,R2),=CL7') NVSAM'\nIDPULP  $PUNCH TEXT,,DDI\n         LTR   R10,R15\n         BNZ   IDINCL\n         CLC   2(L'SDAY,R2),EDAY\n         BNL   IDINCL\n         PACK  DBLWRK,2(L'SDAY,R2)\n         AP    DBLWRK,=PL1'+1'\n         UNPK  2(L'SDAY,R2),DBLWRK+L'DBLWRK-3(3)\n         OI    1+L'SDAY(R2),C'0'\n         B     IDPULP\nIDINCL  $UCLOSE DDI\n         LTR   R10,R10\n         BNZ   IPERR\n         LTR   R10,R15\n         BNZ   IUERR\n         L     R6,DAIDOUT          IDCAMS OUTPUT ALLOCATION\n         MVC   DDNAME,DDO\n         MVC   DSNAME(6),=CL6'&&&&IDOUT'\n         MVC   DSPRI(2),=CL2'10'\n         MVC   DSSTATUS(3),=CL3'NEW'\n         MVC   DSNDISP(6),=CL6'DELETE'\n         MVC   DSADISP(6),=CL6'DELETE'\n         MVC   DSUNIT(3),=CL3'VIO'\n         MVC   DSALLOC(3),=CL3'TRK'\n         MVI   DSSEC,C'5'\n        $DYNALL (R6),,MF=(E,DYNPLS)\n         LTR   R10,R15             TEST RETURN CODE\n         BZ    OKIDCO              OK, ALLOCATED\n         ICM   R1,B'1111',=CL4'ALL.'\n         BAS   R8,DFMR\n         XC    DSNAME,DSNAME\n         B     EXIDC\nOKIDCO  LINK   EP=IDCAMS,PARAM=(OPTIDC,DNMIDC),VL=1\n         LTR   R10,R15\n         BNZ   XIERR\n         L     R6,DAIDIN           IDCAMS INPUT DE-ALLOCATION\n         XC    DSNAME,DSNAME\n        $DYNALL (R6),,MF=(E,DYNPLS)\n         LTR   R10,R15             TEST RETURN CODE\n         BZ    EXIDC               OK, DE-ALLOCATED\n         ICM   R1,B'1111',=CL4'FREE'\n         BAS   R8,DFMR\n         DROP  R6\n         B     EXIDC\nIPERR    CVD   R10,DBLWRK\n         MVC   DBLWRK(4),=XL4'40202120'\n         ED    DBLWRK(4),DBLWRK+L'DBLWRK-2\n         MVC   IPRC(L'IPRC),DBLWRK+1\n         LA    R1,IPMSG\n         BAS   R9,SMSG\n         B     EXIDC\nIUERR    CVD   R10,DBLWRK\n         MVC   DBLWRK(4),=XL4'40202120'\n         ED    DBLWRK(4),DBLWRK+L'DBLWRK-2\n         MVC   IURC(L'IURC),DBLWRK+1\n         LA    R1,IUMSG\n         BAS   R9,SMSG\n         B     EXIDC\nXIERR    CVD   R10,DBLWRK\n         MVC   DBLWRK(4),=XL4'40202120'\n         ED    DBLWRK(4),DBLWRK+L'DBLWRK-2\n         MVC   XIRC(L'XIRC),DBLWRK+1\n         LA    R1,XIMSG\n         BAS   R9,SMSG\n         XR    R10,R10             JUST TO GET DIAGNOSE\nEXIDC   @EXIT  (R10)\n         SPACE 1\nIPMSG    DC    AL1(IPMSGL),C' -> IDCAMS INPUT GENERATION FAILED / '\n         DC    C'$PUNCH RC='\nIPRC     DC    CL3' ',C' '\nIPMSGL   EQU   *-(IPMSG+1)\nIUMSG    DC    AL1(IUMSGL),C' -> IDCAMS INPUT GENERATION FAILED / '\n         DC    C'$UCLOSE RC='\nIURC     DC    CL3' ',C' '\nIUMSGL   EQU   *-(IUMSG+1)\nXIMSG    DC    AL1(XIMSGL),C' -> IDCAMS DIAGNOSE FOLLOWS / '\n         DC    C'RETURN CODE ='\nXIRC     DC    CL3' ',C' '\nXIMSGL   EQU   *-(XIMSG+1)\n         SPACE 1\n        @STOP\n         EJECT\nXANALO  @ENTER\n        $VOPEN DBLWRK,DDO\n         LTR   R10,R15\n         BNZ   VOERR\n         L     R0,LVECT\n        GETMAIN R,LV=(0)           GET VECTOR STORAGE\n         ST    R1,SVECT\n         USING VTDSECT,R1\n         XC    VTNXT,VTNXT\n         LA    R4,LVT\n         LA    R5,VT1ST\n         LR    R7,R5\n         AL    R5,=A(NVT)\n         SLR   R5,R4\n         STM   R4,R5,VT1LE\n         ST    R7,VTSTR\n         MVC   VTDDN,=CL2'01'      SET 1ST DD NUMBER\n         DROP  R1\n         ST    R1,CVECT\n         SLR   R7,R4\nRDREC    MVI   LINE,C' '\n         MVC   LINE+1(L'LINE-1),LINE\n        $VREAD LINE,DDO\n         LTR   R10,R15\n         BM    RDEND\n         BNZ   VRERR\n         LM    R1,R3,=A(LINE+1,1,LINE+L'LINE-1)\n         CLI   0(R1),C' '\n         BNE   *+L'*+8\n         BXLE  R1,R2,*-8\n         B     RDREC\n         CLC   0(9,R1),=CL9'NONVSAM -'\n         BE    NNVSM\n         CLC   0(3,R1),=CL3'IDC'\n         BE    SCENT\n         B     RDREC\nNNVSM    LA    R1,9(R1)\n         CLI   0(R1),C' '\n         BE    *+L'*+8\n         BXLE  R1,R2,*-8\n         B     RDREC\n         BXLE  R1,R2,*+L'*+4\n         B     RDREC\n         CLI   0(R1),C' '\n         BE    *-12\n         LR    R15,R1\n         CLI   0(R1),C' '\n         BE    *+L'*+8\n         BXLE  R1,R2,*-8\n         B     RDREC\n         SLR   R1,R15\n         CLM   R1,B'0001',LOGMNL\n         BNE   TIDVT\n         LR    R2,R1\n         BCT   R2,*+L'*+6\n         CLC   0(*-*,R15),LOGMN\n         EX    R2,*-6\n         BNE   TIDVT\n         OI    REQSW,SWOLD\n         OI    ANSW,ANSWL\n         B     RDREC\nTIDVT    BXLE  R7,R4,TIDST\n         L     R3,CVECT\n         USING VTDSECT,R3\n         CLC   VTDDN,=CL2'09'      VECTORS OVERFLOW?\n         BNE   GTNVT               NO, GET ANOTHER ONE\n         XR    R1,R1\n         IC    R1,DAYMNL\n         LA    R15,2(R1,R15)\n         MVC   OVMD(L'OVMD),0(R15) SAY AT WHICH DAY OCCURS\n         LA    R1,OVMSG\n         BAS   R9,SMSG\n         LR    R10,R9\n         B     RDCLS\nGTNVT    SLR   R7,R4\n         ST    R7,VTEND\n         LR    R2,R1               SAVE AROUND GETMAIN\n         LR    R6,R15              ...\n         L     R0,LVECT\n        GETMAIN R,LV=(0)           GET VECTOR STORAGE\n         ST    R1,VTNXT\n         XR    R0,R0\n         ICM   R0,B'0011',VTDDN\n         DROP  R3\n         ST    R1,CVECT\n         USING VTDSECT,R1\n         XC    VTNXT,VTNXT\n         LA    R5,VT1ST\n         LR    R7,R5\n         AL    R5,=A(NVT)\n         SLR   R5,R4\n         STM   R4,R5,VT1LE\n         ST    R7,VTSTR\n         AH    R0,=H'1'\n         STCM  R0,B'0011',VTDDN    SET NEXT DD NUMBER\n         DROP  R1\n         ST    R1,CVECT\n         LR    R1,R2               RESTORE AFTER GETMAIN\n         LR    R15,R6              ...\nTIDST    BCT   R1,*+L'*+6\n         MVC   1(*-*,R7),0(R15)\n         EX    R1,*-6\n         STC   R1,0(R7)\n         B     RDREC\nSCENT    CLC   3(12,R1),=CL12'3012I ENTRY '\n         BNE   TIDCM\n         LA    R1,15(R1)\n         CLI   0(R1),C' '\n         BNE   *+L'*+8\n         BXLE  R1,R2,*-8\n         B     TIDCE\n         LR    R15,R1\n         CLI   0(R1),C' '\n         BE    *+L'*+8\n         BXLE  R1,R2,*-8\n         B     TIDCE\n         SLR   R1,R15\n         CLM   R1,B'0001',LOGMNL\n         BNE   TIDCE\n         LR    R2,R1\n         BCT   R2,*+L'*+6\n         CLC   0(*-*,R15),LOGMN\n         EX    R2,*-6\n         BNE   TIDCE\n         OI    ANSW,ANSWL\n         B     RDREC\nTIDCM    TM    3(R1),C'0'\n         BNO   RDREC\n         CLC   3(5,R1),=CL5'0001I'\n         BE    RDREC\n         CLC   3(5,R1),=CL5'0002I'\n         BNE   TIDCE\n         CLC   63(3,R1),=CL3' 0 '\n         BE    RDREC\nTIDCE    MVC   LLN(2),=AL1(74,C' ')\n         LA    R1,LLN\n         BAS   R9,SMSG\n         B     RDREC\nRDEND    XR    R10,R10\nRDCLS   $VCLOSE DDO\n         LTR   R10,R10\n         BZ    *+L'*+12\n         LTR   R15,R15\n         BZ    EXANAL\n         LR    R10,R15\n         B     VCERR\n         LTR   R10,R15\n         BNZ   VCERR\n         L     R6,DAIDOUT          IDCAMS OUTPUT DE-ALLOCATION\n         USING DYNLIST,R6\n         XC    DSNAME,DSNAME\n        $DYNALL (R6),,MF=(E,DYNPLS)\n         LTR   R10,R15             TEST RETURN CODE\n         BZ    STVCT               OK, DE-ALLOCATED\n         ICM   R1,B'1111',=CL4'FREE'\n         BAS   R8,DFMR\n         DROP  R6\n         B     EXANAL\nVOERR    CVD   R10,DBLWRK\n         MVC   DBLWRK(4),=XL4'40202120'\n         ED    DBLWRK(4),DBLWRK+L'DBLWRK-2\n         MVC   VORC(L'VORC),DBLWRK+1\n         LA    R1,VOMSG\n         BAS   R9,SMSG\n         B     EXANAL\nVRERR    CVD   R10,DBLWRK\n         MVC   DBLWRK(4),=XL4'40202120'\n         ED    DBLWRK(4),DBLWRK+L'DBLWRK-2\n         MVC   VRRC(L'VRRC),DBLWRK+1\n         LA    R1,VRMSG\n         BAS   R9,SMSG\n         B     RDCLS\nVCERR    CVD   R10,DBLWRK\n         MVC   DBLWRK(4),=XL4'40202120'\n         ED    DBLWRK(4),DBLWRK+L'DBLWRK-2\n         MVC   VCRC(L'VCRC),DBLWRK+1\n         LA    R1,VCMSG\n         BAS   R9,SMSG\n         B     EXANAL\nSTVCT    L     R1,CVECT\n         USING VTDSECT,R1\n         CL    R1,SVECT\n         BNE   STEVC\n         CL    R7,VTSTR\n         BNL   STEVC\n         CLI   EDAY,C' '\n         BNE   *+L'*+20\n         MVC   NNMD,SDAY\n         LA    R1,NNMSG\n         BAS   R9,SMSG\n         LR    R10,R9\n         B     EXANAL\n         MVC   NSMD,SDAY\n         MVC   NSME,EDAY\n         LA    R1,NSMSG\n         BAS   R9,SMSG\n         LR    R10,R9\n         B     EXANAL\nSTEVC    ST    R7,VTEND\n         DROP  R1\n         TM    ANSW,ANSWL\n         BO    EXANAL\n         TM    MANSW,SWMON\n         BZ    EXANAL\n         LA    R1,MWMSG\n         BAS   R9,SMSG\nEXANAL  @EXIT  (R10)\n         SPACE 1\nANSW     DC    XL1'0'\nANSWL    EQU   X'80'               MONTH LOG NOTICE RECEIVED\n         SPACE 1\nVOMSG    DC    AL1(VOMSGL),C' -> IDCAMS OUTPUT ANALYSIS FAILED / '\n         DC    C'$VOPEN RC='\nVORC     DC    CL3' ',C' '\nVOMSGL   EQU   *-(VOMSG+1)\nVRMSG    DC    AL1(VRMSGL),C' -> IDCAMS OUTPUT ANALYSIS FAILED / '\n         DC    C'$VREAD RC='\nVRRC     DC    CL3' ',C' '\nVRMSGL   EQU   *-(VRMSG+1)\nVCMSG    DC    AL1(VCMSGL),C' -> IDCAMS OUTPUT ANALYSIS FAILED / '\n         DC    C'$VCLOSE RC='\nVCRC     DC    CL3' ',C' '\nVCMSGL   EQU   *-(VCMSG+1)\nOVMSG    DC    AL1(OVMSGL),C' -> OVERFLOW AT DAY '\nOVMD     DC    CL5' ',C' / MORE THAN 9 * 256 LOG DATA-SETS '\nOVMSGL   EQU   *-(OVMSG+1)\nNNMSG    DC    AL1(NNMSGL),C' -> DAY '\nNNMD     DC    CL5' ',C' HAS NO LOG DATA-SETS '\nNNMSGL   EQU   *-(NNMSG+1)\nNSMSG    DC    AL1(NSMSGL),C' -> DAY RANGE '\nNSMD     DC    CL5' ',C'-'\nNSME     DC    CL5' ',C' HAS NO LOG DATA-SETS '\nNSMSGL   EQU   *-(NSMSG+1)\nMWMSG    DC    AL1(MWMSGL),C' -> IDCAMS / NONE ABOUT MONTH LOG '\n         DC    C'DATA-SET (NEW ASSUMED) '\nMWMSGL   EQU   *-(MWMSG+1)\n         SPACE 1\n        @STOP\n         EJECT\nXGENER  @ENTER\n         MVI   LLN,80\n         MVI   LINE,C' '\n         MVC   LINE+1(L'LINE-1),LINE\n         L     R6,DAGJCL           GENJCL ALLOCATION\n         USING DYNLIST,R6\n         MVC   DDNAME,DDG\n         LA    R2,DSNAME\n         XR    R1,R1\n         IC    R1,USIDL\n         BCT   R1,*+L'*+6\n         MVC   0(*-*,R2),USID\n         EX    R1,*-6\n         LA    R2,1(R1,R2)\n         MVC   0(16,R2),=CL16'.GENJCL.L     .T'\n         LA    R2,9(R2)\n         LA    R3,7(R2)\n        $GDATE ,(R3),DBLWRK\n        $SDATE DBLWRK,(R2)\n         MVC   DSPRI(2),=CL2'10'\n         MVC   DSBLKSI(3),=CL3'800'\n         MVC   DSORG(2),=CL2'PS'\n         MVC   DSLRECL(2),=CL2'80'\n         MVI   DSRECFM1,C'F'\n         MVI   DSRECFM2,C'B'\n         MVC   DSSTATUS(3),=CL3'NEW'\n         MVC   DSNDISP(5),=CL5'CATLG'\n         MVC   DSADISP(6),=CL6'DELETE'\n         MVC   DSUNIT(5),=CL5'SYSDA'\n         XC    DSVOLSER,DSVOLSER\n         MVC   DSALLOC(3),=CL3'TRK'\n         MVI   DSSEC,C'5'\n        $DYNALL (R6),,MF=(E,DYNPLS)\n         LTR   R10,R15             TEST RETURN CODE\n         BZ    GNJOP               OK, ALLOCATED\n         ICM   R1,B'1111',=CL4'ALL.'\n         BAS   R8,DFMR\n         XC    DSNAME,DSNAME\n         B     XGNJ\n         DROP  R6\nGNJOP    MVI   TEXT,C' '\n         MVC   TEXT+1(L'TEXT-1),TEXT\n         L     R4,SKLJS            START (NO JOB CARD)\n         L     R5,SKLJE            END SKELETON\nGNJLP    TM    GNSW,GNSWL          LOGOUT DD PROCESSING ?\n         BO    GNJLG\n         MVC   TEXT(72),0(R4)\n         CLC   TEXT(9),=CL9'//LOG... '\n         BE    GNJIN\n         CLC   TEXT(9),=CL9'//LOGOUT '\n         BE    GNJOU\n         LM    R1,R3,=A(TEXT,1,TEXT+70)\n         BXLE  R1,R2,*+L'*+4\n         B     GNJPT\n         CLI   0(R1),C'?'\n         BNE   *-12\n         CLC   0(6,R1),=CL6'?1... '\n         BNE   GNJPT\n         LR    R6,R1\n         SR    R3,R1\n         BNP   GNERX\n         CH    R3,=H'44'\n         BL    GNERX\n         MVI   0(R6),C' '\n         EX    R3,GNMRZ\n         L     R1,SVECT            GET THE COLLECTED DSN\n         ST    R1,CVECT\n         USING VTDSECT,R1\n         LM    R2,R3,VTEND\n         DROP  R1\nGNJAL    MVI   0(R6),C' '\n         MVC   1(43,R6),0(R6)\n         XR    R1,R1\n         IC    R1,0(R3)\n         EX    R1,GNMVD\n         CLR   R3,R2\n         BNE   GNJAV\n         L     R1,CVECT\n         USING VTDSECT,R1\n         L     R0,VTNXT\n         LTR   R1,R0\n         BNP   GNJPT\n         LM    R2,R3,VTEND\n         DROP  R1\n         ST    R1,CVECT\n         BAS   R8,GNOUT\n         B     GNJER               +0\n         B     GNJAL               +4 - NEXT DSN\nGNJAV    BAS   R8,GNOUT\n         B     GNJER               +0\n         LA    R3,LVT(R3)          +4 - NEXT DSN\n         B     GNJAL\nGNJOU    LM    R1,R3,=A(TEXT,1,TEXT+70)\n         LA    R1,9(R1)\n         CLC   0(21,R1),=CL21' DSN=?2...,DISP=..., '\n         BE    *+L'*+8\n         BXLE  R1,R2,*-10\n         B     GNERO\n         LA    R1,5(R1)\n         LR    R6,R1\n         XR    R1,R1\n         IC    R1,LOGMNL\n         BCT   R1,*+L'*+6\n         MVC   0(*-*,R6),LOGMN\n         EX    R1,*-6\n         LA    R6,1(R1,R6)\n         MVI   0(R6),C','\n         BAS   R8,GNOUT\n         B     GNJER               +0\n         TM    REQSW,SWOLD         +4 - MONTH LOG EXIST?\n         BZ    *+L'*+8             NO\n         OI    GNSW,GNSWL\n         B     GNJNX\n         MVI   TEXT+2,C' '\n         MVC   TEXT+3(L'TEXT-3),TEXT+2\n         MVC   TEXT+15(24),=CL24'DISP=(NEW,CATLG,DELETE),'\n         B     GNJPT\nGNJLG    CLC   0(3,R4),=CL3'// '\n         BE    GNJNX\n         MVI   TEXT+2,C' '\n         MVC   TEXT+3(L'TEXT-3),TEXT+2\n         MVC   TEXT+15(15),=CL15'DISP=(MOD,KEEP)'\n         BAS   R8,GNOUT\n         B     GNJER               +0\n         NI    GNSW,255-GNSWL      +4\n         B     GNJLP\nGNJIN    LM    R1,R3,=A(TEXT,1,TEXT+70)\n         LA    R1,9(R1)\n         CLC   0(16,R1),=CL16' DSN=?1...,DISP='\n         BE    *+L'*+8\n         BXLE  R1,R2,*-10\n         B     GNERL\n         MVC   TEXT+5(3),=CL3' '\n         LA    R6,5(R1)\n         LA    R1,11(R6)\n         CLI   0(R1),C' '\n         BE    *+L'*+8\n         BXLE  R1,R2,*-8\n         B     GNERS\n         SR    R3,R6\n         SH    R3,=H'6'\n         BNP   GNERL\n         EX    R3,GNMVE\n         MVI   0(R6),C' '\n         EX    R3,GNMRZ\n         MVC   GNDSN1(L'GNDSN1),TEXT\n         MVC   GNDSN1+2(3),=CL3' '\n         L     R1,SVECT            GET THE COLLECTED DSN\n         ST    R1,CVECT\n         USING VTDSECT,R1\n         LM    R2,R3,VTEND\n         MVC   TEXT+5(L'VTDDN),VTDDN\n         DROP  R1\nGNJIL    XR    R1,R1\n         IC    R1,0(R3)\n         EX    R1,GNMVD\n         LA    R1,1(R1,R6)\n         MVI   0(R1),C','\n         BAS   R8,GNOUT\n         B     GNJER               +0\n         MVC   TEXT(L'GNDSN2),GNDSN2    +4 - DISP= CARD\n         CLR   R3,R2\n         BNE   GNJNV\n         L     R1,CVECT\n         USING VTDSECT,R1\n         L     R0,VTNXT\n         LTR   R1,R0\n         BNP   GNJPT\n         LM    R2,R3,VTEND\n         DROP  R1\n         ST    R1,CVECT\n         BAS   R8,GNOUT\n         B     GNJER               +0\n         MVC   TEXT(L'GNDSN1),GNDSN1    +4 - NEXT //LOG...\n         MVC   TEXT+2(3),=CL3'LOG'\n         L     R1,CVECT\n         USING VTDSECT,R1\n         MVC   TEXT+5(L'VTDDN),VTDDN\n         DROP  R1\n         B     GNJIL\nGNJNV    BAS   R8,GNOUT\n         B     GNJER               +0\n         LA    R3,LVT(R3)          +4 - NEXT DSN\n         MVC   TEXT(L'GNDSN1),GNDSN1\n         B     GNJIL\nGNMVE    MVC   GNDSN2+15(*-*),6(R6)\nGNMRZ    MVC   1(*-*,R6),0(R6)\nGNMVD    MVC   0(*-*,R6),1(R3)\nGNJPT    BAS   R8,GNOUT\n         B     GNJER               +0\nGNJNX    LA    R4,72(R4)           +4 - NEXT JCL CARD\n         CLR   R4,R5               CHECK END OF JCL SKELETON\n         BNH   GNJLP\n         LA    R1,GNJNN\n         BAS   R9,SMSG\nGNJNM    L     R6,DAGJCL\n         USING DYNLIST,R6\n         MVC   GNJNT1,DSNAME\n         TM    RUNSW,SWTFG+SWTBG\n         BZ    *+L'*+6\n         MVC   VARDATA,DSNAME\n         DROP  R6\n         LA    R1,GNJNT\n         BAS   R9,SMSG\nGNJCL   $UCLOSE DDG\n         LTR   R10,R10\n         BNZ   XGNJ\n         LR    R10,R15\n         B     XGNJ\nGNJER    CVD   R15,DBLWRK          SET R.C. IN MESSAGE\n         UNPK  DBLWRK(3),DBLWRK+L'DBLWRK-2(2)\n         OI    DBLWRK+2,C'0'\n         MVC   GNPER1(L'GNPER1),DBLWRK+3-L'GNPER1\n         LA    R1,GNPER\n         BAS   R9,SMSG\n         B     GNJNM\nGNERX    LA    R1,MSERX\n         B     GNEND\nGNERO    LA    R1,MSERO\n         B     GNEND\nGNERL    LA    R1,MSERL\n         B     GNEND\nGNERS    LA    R1,MSERS\nGNEND    BAS   R9,SMSG\n         LR    R10,R9\n         B     GNJCL\nXGNJ    @EXIT  (R10)\n         SPACE 1\n*------- GENERATE OUTPUT ROUTINE\n*              R8 - LINK REGISTER / RETURN +0 = $PUNCH ERROR\n*                                          +4 = OK\n*              R10 = R15 - RETURN CODE\n         SPACE 1\nGNOUT    MVC   LINE(L'TEXT),TEXT\n        $PUNCH LINE,,DDG\n         LTR   R10,R15\n         BZ    4(R8)\n         BR    R8\n         SPACE 1\nGNDSN1   DC    CL72' '\nGNDSN2   DC    CL72'// '\nGNSW     DC    XL1'0'\nGNSWL    EQU   X'80'               LOGOUT DD PROCESSING\n         SPACE 1\nGNPER    DC    AL1(GNPERL),C' -> $PUNCH ERROR (R15='\nGNPER1   DC    CL2' ',C') - DATA-SET INCOMPLETE '\nGNPERL   EQU   *-(GNPER+1)\nGNJNN    DC    AL1(GNJNNL),C' => EU-S01I '\n         DC    C'JCL DATA-SET (CATALOG''D) SUCCESSFULLY GENERATED '\nGNJNNL   EQU   *-(GNJNN+1)\nGNJNT    DC    AL1(GNJNTL),C' => EU-S02I NAME IS : '\nGNJNT1   DC    CL44' ',C' '\nGNJNTL   EQU   *-(GNJNT+1)\n         SPACE 1\n        @STOP\n         EJECT\nXSUBMIT @ENTER\n         LA    R1,RBBKPTR          ALLOCATE INTERNAL READER\n        DYNALLOC ,\n         LTR   R10,R15             CHECK FOR ERRORS?\n         BZ    SBMOK               OK, ALLOCATED\n         MVC   RCODES,RBRSC\n         ST    R15,RCODES+4\n         LA    R6,=CL8'INT.RDR.'\n         ICM   R1,B'1111',=CL4'ALL.'\n         BAS   R8,DFMR\n         B     XSBMT\nSBMOK    MVC   INRDR+(ACBDDNM-IFGACB)(L'ACBDDNM),TXTDDN\n        OPEN   (INRDR)             OPEN JES2 ACB\n         LTR   R10,R15\n         BZ    SBMOP               OK, OPEN DONE\n         LA    R7,XSBMT\n         MVC   MSEIR1,=CL15'IN.RDR --- OPEN'\nSBMSM    CVD   R15,DBLWRK          SET R.C. IN MESSAGE\n         UNPK  DBLWRK(3),DBLWRK+L'DBLWRK-2(2)\n         OI    DBLWRK+2,C'0'\n         MVC   MSEIR2(L'MSEIR2),DBLWRK+3-L'MSEIR2\n         LA    R1,MSEIR\n         BAS   R9,SMSG\n         BR    R7\nSBMOP    LA    R7,SBMCL\n         MVI   TEXT,C' '\n         MVC   TEXT+1(L'TEXT-1),TEXT\n         L     R4,SSKLW            START (WITH JOB CARD)\n         L     R5,SKLJE            END SKELETON\n         LA    R2,2(R4)            GET JOB-NAME FOR FURTHER MESSAGE\n         LA    R3,SBJBNM\n         LA    R0,L'SBJBNM\n         CLI   0(R2),C' '\n         BE    *+L'*+18\n         MVC   0(1,R3),0(R2)\n         LA    R2,1(R2)\n         LA    R3,1(R3)\n         BCT   R0,*-22\n         TM    REQSW,SWCPY+SWSCN   COPY OR SCAN REQUESTED?\n         BNZ   SBMLP\n         OI    SBSW,SBSWJ          NO, SET AS JOB CARD PROCESSED\nSBMLP    TM    SBSW,SBSWL          LOGOUT DD PROCESSING ?\n         BO    SBMLG\n         TM    SBSW,SBSWJ\n         BO    SBMSC               JOB CARD PROCESSED\n         CL    R4,SKLJI            INSERT TYPRUN= CARD?\n         BNE   SBMSC               NO, NOT HERE\n         MVC   TEXT(3),=CL3'// '   YES, ADD IT\n         MVC   TEXT+3(L'TEXT-3),TEXT+2\n         MVC   TEXT+15(7),=CL7'TYPRUN='\n         TM    REQSW,SWCPY\n         BZ    *+L'*+10\n         MVC   TEXT+22(5),=CL5'COPY,'\n         B     *+L'*+6\n         MVC   TEXT+22(5),=CL5'SCAN,'\n         OI    SBSW,SBSWJ\n         BAS   R8,SBOUT\n         B     SBMEM               +0\n         B     SBMEP               +4\nSBMSC    MVC   TEXT(72),0(R4)      +8\n         CLC   TEXT(9),=CL9'//LOG... '\n         BE    SBMIN\n         CLC   TEXT(9),=CL9'//LOGOUT '\n         BE    SBMOU\n         LM    R1,R3,=A(TEXT,1,TEXT+70)\n         BXLE  R1,R2,*+L'*+4\n         B     SBMPT\n         CLI   0(R1),C'?'\n         BNE   *-12\n         CLC   0(6,R1),=CL6'?1... '\n         BNE   SBMPT\n         LR    R6,R1\n         SR    R3,R1\n         BNP   SBERX\n         CH    R3,=H'44'\n         BL    SBERX\n         MVI   0(R6),C' '\n         EX    R3,SBMRZ\n         L     R1,SVECT            GET THE COLLECTED DSN\n         ST    R1,CVECT\n         USING VTDSECT,R1\n         LM    R2,R3,VTEND\n         DROP  R1\nSBMAL    MVI   0(R6),C' '\n         MVC   1(43,R6),0(R6)\n         XR    R1,R1\n         IC    R1,0(R3)\n         EX    R1,SBMVD\n         CLR   R3,R2\n         BNE   SBMAV\n         L     R1,CVECT\n         USING VTDSECT,R1\n         L     R0,VTNXT\n         LTR   R1,R0\n         BNP   SBMPT\n         LM    R2,R3,VTEND\n         DROP  R1\n         ST    R1,CVECT\n         BAS   R8,SBOUT\n         B     SBMEM               +0\n         B     SBMEP               +4\n         B     SBMAL               +8 - NEXT DSN\nSBMAV    BAS   R8,SBOUT\n         B     SBMEM               +0\n         B     SBMEP               +4\n         LA    R3,LVT(R3)          +8 - NEXT DSN\n         B     SBMAL\nSBMOU    LM    R1,R3,=A(TEXT,1,TEXT+70)\n         LA    R1,9(R1)\n         CLC   0(21,R1),=CL21' DSN=?2...,DISP=..., '\n         BE    *+L'*+8\n         BXLE  R1,R2,*-10\n         B     SBERO\n         LA    R1,5(R1)\n         LR    R6,R1\n         XR    R1,R1\n         IC    R1,LOGMNL\n         BCT   R1,*+L'*+6\n         MVC   0(*-*,R6),LOGMN\n         EX    R1,*-6\n         LA    R6,1(R1,R6)\n         MVI   0(R6),C','\n         BAS   R8,SBOUT\n         B     SBMEM               +0\n         B     SBMEP               +4\n         TM    REQSW,SWOLD         +8 - MONTH LOG EXIST?\n         BZ    *+L'*+8             NO\n         OI    SBSW,SBSWL\n         B     SBMNX\n         MVI   TEXT+2,C' '\n         MVC   TEXT+3(L'TEXT-3),TEXT+2\n         MVC   TEXT+15(24),=CL24'DISP=(NEW,CATLG,DELETE),'\n         B     SBMPT\nSBMLG    CLC   0(3,R4),=CL3'// '\n         BE    SBMNX\n         MVI   TEXT+2,C' '\n         MVC   TEXT+3(L'TEXT-3),TEXT+2\n         MVC   TEXT+15(15),=CL15'DISP=(MOD,KEEP)'\n         BAS   R8,SBOUT\n         B     SBMEM               +0\n         B     SBMEP               +4\n         NI    SBSW,255-SBSWL      +8\n         B     SBMLP\nSBMIN    LM    R1,R3,=A(TEXT,1,TEXT+70)\n         LA    R1,9(R1)\n         CLC   0(16,R1),=CL16' DSN=?1...,DISP='\n         BE    *+L'*+8\n         BXLE  R1,R2,*-10\n         B     SBERL\n         MVC   TEXT+5(3),=CL3' '\n         LA    R6,5(R1)\n         LA    R1,11(R6)\n         CLI   0(R1),C' '\n         BE    *+L'*+8\n         BXLE  R1,R2,*-8\n         B     SBERS\n         SR    R3,R6\n         SH    R3,=H'6'\n         BNP   SBERL\n         EX    R3,SBMVE\n         MVI   0(R6),C' '\n         EX    R3,SBMRZ\n         MVC   SBDSN1(L'SBDSN1),TEXT\n         MVC   SBDSN1+2(3),=CL3' '\n         L     R1,SVECT            GET THE COLLECTED DSN\n         ST    R1,CVECT\n         USING VTDSECT,R1\n         LM    R2,R3,VTEND\n         MVC   TEXT+5(L'VTDDN),VTDDN\n         DROP  R1\nSBMIL    XR    R1,R1\n         IC    R1,0(R3)\n         EX    R1,SBMVD\n         LA    R1,1(R1,R6)\n         MVI   0(R1),C','\n         BAS   R8,SBOUT\n         B     SBMEM               +0\n         B     SBMEP               +4\n         MVC   TEXT(L'SBDSN2),SBDSN2    +8 - DISP= CARD\n         CLR   R3,R2\n         BNE   SBMNV\n         L     R1,CVECT\n         USING VTDSECT,R1\n         L     R0,VTNXT\n         LTR   R1,R0\n         BNP   SBMPT\n         LM    R2,R3,VTEND\n         DROP  R1\n         ST    R1,CVECT\n         BAS   R8,SBOUT\n         B     SBMEM               +0\n         B     SBMEP               +4\n         MVC   TEXT(L'SBDSN1),SBDSN1    +8 - NEXT //LOG...\n         MVC   TEXT+2(3),=CL3'LOG'\n         L     R1,CVECT\n         USING VTDSECT,R1\n         MVC   TEXT+5(L'VTDDN),VTDDN\n         DROP  R1\n         B     SBMIL\nSBMNV    BAS   R8,SBOUT\n         B     SBMEM               +0\n         B     SBMEP               +4\n         LA    R3,LVT(R3)          +8 - NEXT DSN\n         MVC   TEXT(L'SBDSN1),SBDSN1\n         B     SBMIL\nSBMVD    MVC   0(*-*,R6),1(R3)\nSBMVE    MVC   SBDSN2+15(*-*),6(R6)\nSBMRZ    MVC   1(*-*,R6),0(R6)\nSBMPT    BAS   R8,SBOUT\n         B     SBMEM               +0\n         B     SBMEP               +4\nSBMNX    LA    R4,72(R4)           +8 - NEXT JCL CARD\n         CLR   R4,R5               CHECK END OF JCL SKELETON\n         BNH   SBMLP\n         MVI   TEXT,C' '\n         MVC   TEXT+1(L'TEXT-1),TEXT\n         MVC   TEXT(2),SBDSN2      NULL JCL\n         BAS   R8,SBOUT\n         B     SBMEM               +0\n         B     SBMEP               +4\n         MVC   TEXT(5),=CL5'/*EOF' +8 - JES2 END-OF-FILE\n         BAS   R8,SBOUT\n         B     SBMEM               +0\n         B     SBMEP               +4\n        ENDREQ RPL=REQPL           +8 - GET JOB NUMBER\n         LTR   R10,R15             RECEIVED BACK?\n         BZ    *+L'*+10            YES\n         MVC   MSEIR1,=CL15'IN.RDR - ENDREQ'\n         B     SBMSM\n         MVC   MSJNN1,SBJBNM       MOVE JOB-NAME\n         MVC   MSJNN2(8),REQPL+(RPLRBAR-IFGRPL) MOVE JOB NUMBER\n         LA    R1,MSJNN2+3\n         CLI   0(R1),C'0'\n         BNE   *+L'*+12\n         MVI   0(R1),C' '\n         LA    R1,1(R1)\n         B     *-16\n         MVC   MSJNN3,SBNAME\n        $GDATE MSJNN4,MSJNT1\n         ICM   R1,B'1111',MSJNT1+2\n         STCM  R1,B'1100',MSJNT1+3\n         STCM  R1,B'0011',MSJNT1+6\n         MVI   MSJNT1+2,C':'\n         MVI   MSJNT1+5,C':'\n         LA    R1,MSJNN\n         BAS   R9,SMSG\n         LA    R1,MSJNT\n         BAS   R9,SMSG\nSBMCL    LA    R7,XSBMT\n        CLOSE  (INRDR)\n         LTR   R10,R10\n         BZ    *+L'*+8\n         LTR   R15,R15\n         BZR   R7\n         B     *+L'*+6\n         LTR   R10,R15\n         BZ    XSBMT\n         MVC   MSEIR1,=CL15'IN.RDR -- CLOSE'\n         B     SBMSM\nSBMEM    MVC   MSEIR1,=CL15'IN.RDR -- MODCB'\n         B     SBMSM\nSBMEP    MVC   MSEIR1,=CL15'IN.RDR ---- PUT'\n         B     SBMSM\nSBERI    TM    REQSW,SWCPY\n         BZ    *+L'*+10\n         MVC   MSERI1,=CL4'COPY'\n         B     *+L'*+6\n         MVC   MSERI1,=CL4'SCAN'\n         LA    R1,MSERI\n         B     SBPRG\nSBERX    LA    R1,MSERX\n         B     SBPRG\nSBERO    LA    R1,MSERO\n         B     SBPRG\nSBERL    LA    R1,MSERL\n         B     SBPRG\nSBERS    LA    R1,MSERS\nSBPRG    BAS   R9,SMSG\n         LR    R10,R9\n         MVC   TEXT(7),=CL7'/*PURGE'    JES2 CANCEL JOB\n         BAS   R8,SBOUT\n         B     SBMEM               +0\n         B     SBMEP               +4\n         MVC   TEXT(5),=CL5'/*EOF' +8 - JES2 END-OF-FILE\n         BAS   R8,SBOUT\n         B     SBMEM               +0\n         B     SBMEP               +4\n         BR    R7                  +8\nXSBMT   @EXIT  (R10)\n         SPACE 1\n*------- INTRDR OUTPUT ROUTINE\n*              R8 - LINK REGISTER / RETURN +0 = MODCB ERROR\n*                                          +4 = PUT ERROR\n*                                          +8 = OK\n*              R10 = R15 - RETURN CODE\n         SPACE 1\nSBOUT   MODCB  RPL=REQPL,AREA=TEXT\n         LTR   R10,R15\n         BNZR  R8\n        PUT    RPL=REQPL\n         LTR   R10,R15\n         BNZ   4(R8)\n         B     8(R8)\n         SPACE 1\nRBBKPTR  DC    0F'0',XL1'80',AL3(RBBK)\nRBBK     DC    0F'0',AL1(RBBKEND-RBBK)\n         DC    AL1(S99VRBAL)\n         DC    AL1(S99NOCNV+S99NOMNT,0)\nRBRSC    DC    F'0'                ERROR/INFO REASON CODES.\n         DC    A(RBTXP)\n         DC    F'0',XL4'0'\nRBBKEND  EQU   *\nRBTXP    DC    A(TXTUN1)\n         DC    A(TXTUN2)\n         DC    A(TXTUN3)\n         DC    A(TXTUN4)\n         DC    A(TXTUN5)\n         DC    XL1'80',AL3(TXTUN6)\nTXTUN1   DC    AL2(DALSYSOU),AL2(1),AL2(1),CL1'A'\nTXTUN2   DC    AL2(DALSPGNM),AL2(1),AL2(6),CL6'INTRDR'\nTXTUN3   DC    AL2(DALCLOSE),AL2(0)\nTXTUN4   DC    AL2(DALLRECL),AL2(1),AL2(2),AL2(80)\nTXTUN5   DC    AL2(DALRECFM),AL2(1),AL2(1),AL1(DCBRECF)\nTXTUN6   DC    AL2(DALRTDDN),AL2(1)\nTXTDDNL  DC    AL2(8)\nTXTDDN   DC    CL8' '\n         SPACE 1\nSBJBNM   DC    CL8' '\nSBDSN1   DC    CL72' '\nSBDSN2   DC    CL72'// '\nSBSW     DC    XL1'0'\nSBSWL    EQU   X'80'               LOGOUT DD PROCESSING\nSBSWJ    EQU   X'01'               JOB CARD PROCESSED\n         SPACE 1\nMSEIR    DC    AL1(MSEIRL),C' -> '\nMSEIR1   DC    CL15' ',C' ERROR (R15='\nMSEIR2   DC    CL2' ',C') - ONLY SUBMIT FAILS '\nMSEIRL   EQU   *-(MSEIR+1)\nMSJNN    DC    AL1(MSJNNL),C' => EU-S00I '\nMSJNN1   DC    CL8' ',C' ('\nMSJNN2   DC    CL8' ',C') SUBMITTED BY '\nMSJNN3   DC    CL8' ',C' ON '\nMSJNN4   DC    CL20' '\nMSJNNL   EQU   *-(MSJNN+1)\nMSJNT    DC    AL1(MSJNTL),C' => EU-S00I ',CL42' ',C'AT '\nMSJNT1   DC    CL8' ',C' '\nMSJNTL   EQU   *-(MSJNT+1)\nMSERI    DC    AL1(MSERIL),C' => EU-S01A FAILED INSERT \"TYPRUN='\nMSERI1   DC    CL4' ',C'\" CONTINUATION TO JOB CARD '\nMSERIL   EQU   *-(MSERI+1)\n         SPACE 1\n         PRINT NOGEN\nINRDR   ACB    MACRF=(ADR,SEQ,OUT),DDNAME=XXXXXXXX\nREQPL   RPL    ACB=INRDR,RECLEN=80,AREALEN=80,OPTCD=(ADR,SEQ,SYN,NUP)\n         PRINT GEN\n         SPACE 1\n        @STOP\n         EJECT\nXEXIT   @ENTER\n         LR    R7,R10\n         L     R6,DAGSKL           GET SKELETON DE-ALLOCATION\n         USING DYNLIST,R6\n         CLI   DSNAME,C' '\n         BE    NOTAP               NEVER ALLOCATED\n         CLI   DSNAME,0\n         BE    NOTAP               ALREADY DE-ALLOCATED\n         XC    DSNAME,DSNAME\n        $DYNALL (R6),,MF=(E,DYNPLS)\n         LTR   R10,R15             TEST RETURN CODE\n         BZ    NOTAP               OK, DE-ALLOCATED\n         ICM   R1,B'1111',=CL4'FREE'\n         BAS   R8,DFMR\nNOTAP    L     R6,DAIDIN           IDCAMS INPUT DE-ALLOCATION\n         CLI   DSNAME,C' '\n         BE    NOTAI               NEVER ALLOCATED\n         CLI   DSNAME,0\n         BE    NOTAI               ALREADY DE-ALLOCATED\n         XC    DSNAME,DSNAME\n        $DYNALL (R6),,MF=(E,DYNPLS)\n         LTR   R10,R15             TEST RETURN CODE\n         BZ    NOTAI               OK, DE-ALLOCATED\n         ICM   R1,B'1111',=CL4'FREE'\n         BAS   R8,DFMR\nNOTAI    L     R6,DAIDOUT          IDCAMS OUTPUT DE-ALLOCATION\n         CLI   DSNAME,C' '\n         BE    NOTAO               NEVER ALLOCATED\n         CLI   DSNAME,0\n         BE    NOTAO               ALREADY DE-ALLOCATED\n         XC    DSNAME,DSNAME\n        $DYNALL (R6),,MF=(E,DYNPLS)\n         LTR   R10,R15             TEST RETURN CODE\n         BZ    NOTAO               OK, DE-ALLOCATED\n         ICM   R1,B'1111',=CL4'FREE'\n         BAS   R8,DFMR\nNOTAO    TM    RUNSW,SWSYS         SYSTEM TASK?\n         BO    NOTAT               YES\n         L     R6,DAGJCL           GENJCL DE-ALLOCATION\n         CLI   DSNAME,C' '\n         BE    NOTAT               NEVER ALLOCATED\n         CLI   DSNAME,0\n         BE    NOTAT               ALREADY DE-ALLOCATED\n         XC    DSNAME,DSNAME\n        $DYNALL (R6),,MF=(E,DYNPLS)\n         LTR   R10,R15             TEST RETURN CODE\n         BZ    NOTAT               OK, DE-ALLOCATED\n         ICM   R1,B'1111',=CL4'FREE'\n         BAS   R8,DFMR\n         DROP  R6\nNOTAT    LM    R2,R3,LVECT         FREE ALL VECTORS STORAGE\n         LTR   R1,R3\n         BZ    NOFREE\n         USING VTDSECT,R1\n         L     R3,VTNXT\n         DROP  R1\n         LR    R0,R2\n        FREEMAIN R,LV=(0),A=(1)\n         B     NOTAT+L'NOTAT\nNOFREE   LM    R0,R1,LSKLW\n         LTR   R1,R1\n         BZ    NOSKLW\n        FREEMAIN R,LV=(0),A=(1)    FREE JCL WORK STORAGE\nNOSKLW   LM    R0,R1,LDYNW\n         LTR   R1,R1\n         BZ    STVAR\n        FREEMAIN R,LV=(0),A=(1)    FREE DYNAMIC WORK STORAGE\nSTVAR    TM    RUNSW,SWTFG+SWTBG\n         BZ    QUIT\n         CLI   VARDATA,C' '\n         BE    QUIT\n         LA    R1,VARDATA+L'VARDATA ESTABLISH TSO CLIST VARIABLE\n         LA    R0,L'VARDATA\n         BCTR  R1,0\n         CLI   0(R1),C' '\n         BNE   *+L'*+8\n         BCT   R0,*-10\n         LA    R0,1\n         ST    R0,DATALENG\n         L     R15,CVTPTR\n         USING CVTMAP,R15\n         L     R15,CVTTVT\n         DROP  R15\n         USING TSVT,R15\n         L     R15,TSVTVACC        VARIABLE ACCESS ROUTINE\n         DROP  R15\n         LA    R1,CT441PRM\n         LTR   R15,R15\n         BNZ   STVXQ\n        LINK   EP=IKJCT441,MF=(E,(1))\n         B     STVXQ+L'STVXQ\nSTVXQ    BASR  R14,R15\n         LTR   R15,R15             ANY ERROR?\n         BZ    QUIT                NO, OK\n         CH    R15,=H'40'          YES, BUT BECAUSE NOT IN A CLIST?\n         BE    QUIT                YES, OK\n         CVD   R15,DBLWRK\n         UNPK  DBLWRK(3),DBLWRK+6(2)\n         OI    DBLWRK+2,C'0'\n         MVC   TSRC(L'TSRC),DBLWRK+3-L'TSRC\n         LA    R1,TSMSG\n         BAS   R9,SMSG\nQUIT     LTR   R7,R7               SET FINAL C.C.\n         BNZ   *+L'*+6\n         LTR   R10,R10\n         BZ    *+L'*+4\n         LA    R10,16\n        @EXIT  (R10)\n         SPACE 1\nCT441PRM DC    A(ENTRYCDE)         IKJCT441 PARM.LIST\n         DC    A(NAMEADDR)\n         DC    A(NAMELENG)\n         DC    A(DATAADDR)\n         DC    A(DATALENG)\n         DC    A(TOKENPRM+X'80000000')\nENTRYCDE DC    A(TSVEUPDT)         ENTRY CODE\nNAMEADDR DC    A(VARNAME)          ADDRESS OF VARIABLE NAME\nNAMELENG DC    A(L'VARNAME)        LENGTH OF VARIABLE NAME\nDATAADDR DC    A(VARDATA)          ADDRESS OF VARIABLE DATA\nDATALENG DC    A(*-*)              LENGTH OF VARIABLE DATA\nTOKENPRM DC    A(*-*)              TOKEN TO VARIABLE ACCESS SERVICE\nVARNAME  DC    C'EUGENDS'\n         SPACE 1\nTSMSG    DC    AL1(TSMSGL),C' => EU-S02I IKJCT441 : RC = '\nTSRC     DC    CL2' ',C' / TSO CLIST VARIABLE : EUGENDS '\nTSMSGL   EQU   *-(TSMSG+1)\n         SPACE 1\n        @STOP\n         EJECT\n         DROP  R12                 KILL MAIN ADDRESSABILITY\n         SPACE 1\n*------- PARSE PCL CSECT AND PDL DSECT (COMMAND SYNTAX)\n         SPACE 1\n         PRINT  NOGEN\nPARMLST IKJPARM\nPDID    IKJKEYWD\n        IKJNAME 'DAY',SUBFLD=SFID,ALIAS=('D')\nPDIF    IKJKEYWD\n        IKJNAME 'FROM',SUBFLD=SFIF,ALIAS=('F')\nPDIT    IKJKEYWD\n        IKJNAME 'TO',SUBFLD=SFIT,ALIAS=('T')\nPDIJ    IKJKEYWD\n        IKJNAME 'JCL',SUBFLD=SFIJ,ALIAS=('JOB','J')\nPDOP    IKJKEYWD\n        IKJNAME  'MSG',ALIAS=('M','LIST','L')\n        IKJNAME  'NOMSG',ALIAS=('NOLIST','N')\nSFID    IKJSUBF\nSDID    IKJIDENT 'DAY(DATE)',MAXLNTH=8,FIRST=ANY,OTHER=ANY,            X\n               VALIDCK=DTEVALCK,DEFAULT='NONE',                        X\n               HELP=('FORMAT : DD/MM/YY, DD.MM.YY OR DD-MM-YY')\nSFIF    IKJSUBF\nSDIF    IKJIDENT 'FROM(DATE)',MAXLNTH=8,FIRST=ANY,OTHER=ANY,           X\n               VALIDCK=DTEVALCK,DEFAULT='NONE',                        X\n               HELP=('FORMAT : DD/MM/YY, DD.MM.YY OR DD-MM-YY')\nSFIT    IKJSUBF\nSDIT    IKJIDENT 'TO(DATE)',MAXLNTH=8,FIRST=ANY,OTHER=ANY,             X\n               VALIDCK=DTEVALCK,DEFAULT='NONE',                        X\n               HELP=('FORMAT : DD/MM/YY, DD.MM.YY OR DD-MM-YY')\nSFIJ    IKJSUBF\nSDIJ    IKJIDENT 'JCL(XX)',MAXLNTH=2,FIRST=ANY,OTHER=ANY,              X\n               VALIDCK=JCLVALCK,DEFAULT='00',                          X\n               HELP=('2 CHARACTERS SUFFIX TO MEMBER NAME \"IMSLOG..\"')\n        IKJENDP\n         EJECT\n*------- DSECT'S AREAS\n         SPACE 1\nVTDSECT  DSECT ,                   LOCAL VECTOR AREA DESCRIPTION\nVTNXT    DS    A                   NEXT VECTOR AREA POINTER\nVT1LE    DS    F                   LENGTH OF 1 VECTOR ELEMENT\nVTEND    DS    A                   ADDRESS OF LAST VECTOR ELEMENT\nVTSTR    DS    A                   ADDRESS OF FIRST VECTOR ELEMENT\nVTDDN    DS    CL2                 VECTOR DD NUMBER (//LOG.. NUMBER)\nBVL      EQU   *-VTDSECT\nVT1ST    DS    XL1,CL44            FIRST VECTOR ELEMENT\nLVT      EQU   *-VT1ST\nNVT      EQU   256*LVT             MAX. DD-CONCAT. = 256\nTVT      EQU   ((BVL+NVT+7)/8)*8   GETMAIN VECTOR LENGTH\n         SPACE 1\nCIBDSECT DSECT ,\nCIB     IEZCIB ,\n        CVT    DSECT=YES,LIST=YES\n        IHAPSA\n        IHAASCB\n        IHAASXB\n        IHAACEE\nTIODSECT DSECT ,\n        IEFTIOT1 ,\n        IKJTSVT\n        IKJEBECA\n        IKJCPPL\n        IKJPSCB\n        IKJPPL\nPPLL    EQU    *-PPL\n        IKJUPT\n        IKJIOPL\nIOPLLEN  EQU   *-IOPL\n        $DYNLIST R=NO\n        IEFZB4D0\n        IEFZB4D2\n        DCBD   DSORG=PS,DEVD=DA\n        IFGACB\n        IFGRPL\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IMSLDS$": {"ttr": 9738, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x942\\x8f\\x00\\x942\\x8f\\x10)\\x00 \\x00 \\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-24T00:00:00", "modifydate": "1994-11-24T10:29:00", "lines": 32, "newlines": 32, "modlines": 0, "user": "SYSPAJA"}, "text": "//IMSLDS   JOB (........),'INSTALL   -IMSLDS-',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=1M,TIME=1\n/*JOBPARM L=10\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//* PRE-REQUISITE MODULES INSTALLATION :                              *\n//*                DYNALL    GFDATE    MREAD     TXPRINT   TXPUNCH    *\n//*                VREAD                                              *\n//* MANDATORY : SPECIFY AT THE ASSEMBLY STEP 'ASS' BELOW, USING THE   *\n//* ----------- SYSPARM(...), THE FULLY QUALIFIED NAME OF THE         *\n//*             DATA-SET INTO WHICH THE MEMBERS 'IMSLOG..' (JCL       *\n//*             SKELETONS) WILL BE SEARCHED.                          *\n//*             INCLUDED MEMBER 'IMSLOG00' SHOWS THE JCL SKELETON     *\n//*             USED AT OUR INSTALLATION (YOU MAY BUILD YOUR OWN      *\n//*             LOOKING AT AS EXAMPLE).                               *\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//ASS     EXEC PAJ1AS3,MBR=IMSLDS,\n//             OPT=',SYSPARM(...)'\n//LKS     EXEC PAJILKL\n//SYSIN     DD *\n  INCLUDE      SYSADD(DYNALL,GFDATE,MREAD,PRINT,PUNCH,VREAD)\n  ENTRY   IMSLDS\n  NAME    IMSLDS(R)\n/*\n//HLP     EXEC PAJHELP,MBR=IMSLDSH,DSS='->.SOURCE.FILE1'\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//* EXECUTE THE STEP BELOW WITH PROCEDURE :                           *\n//*       \"PAJPROC\" IF YOUR ->.TARGET.PROCLIB DATA-SET                *\n//*                         IS RECFM=FB AND LRECL=80, ELSE            *\n//*       \"PAJPROV\" IF YOUR ->.TARGET.PROCLIB DATA-SET                *\n//*                         IS RECFM=VB AND LRECL=255.                *\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//PRC     EXEC PAJPROC,MBR=IMSLDSP,DSS='->.SOURCE.FILE1'\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IMSLDS@": {"ttr": 9985, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x942\\x7f\\x00\\x942\\x7f\\x15\\x10\\x00\\xad\\x00\\xad\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-23T00:00:00", "modifydate": "1994-11-23T15:10:00", "lines": 173, "newlines": 173, "modlines": 0, "user": "SYSPAJA"}, "text": "1   02/06/92\n                                                      IMSLDS    1/4.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *   I M S L D S  -  PROGRAM/COMMAND   * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *        I.M.S. LOG DATA-SET(S)       * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Purpose :    Automatic JCL generation to cumulate all days IMS log\n  =========    data-set(s) into a one month data-set.\n\n  Functional Summary :\n  ====================\n\n         The JCL skeleton, used for JOB generation, is obtained from\n    a member named IMSLOGnn (default for nn is 00), and located in a\n    predefined partitioned data-set (with LRECL=80 and declared at the\n    assembly step with SYSPARM).\n\n         Various members IMSLOGnn (JCL skeletons) can be build as you\n    want to generate different jobs, assuming they are all based on\n    IMS log data-set(s) manipulation (normal JCL statements cards).\n    The first JCL statement supplied must be a JOB card, which will\n    be used by submit when started task running. Some other cards are\n    explained below :\n         1. Cards starting with three asterisks (columns 1-3 = ***)\n            are considered as private comment cards (never copied or\n            submited).\n         2. Special cards starting (columns 1-2) with a question mark\n            followed by an indicator character are control processing\n            oriented.\n            Positional control only :\n            ?I = is mandatory and indicate where the eventual TYPRUN=\n                 parameter card can be inserted in the JOB statement.\n            ?0 = is mandatory and indicate where starts the normal JCL\n                 skeleton (when not started task). Generally this is\n                 placed after the JOB statement.\n            Substitution values definition :\n            ?1 = is mandatory and defines the IMS day's log data-set(s)\n                 level name (this is the level to search the day's\n                 data-set(s) in the catalog).\n            ?2 = is optional and defines the IMS month log data-set\n                 level name (this is the level to create the month's\n                 data-set).\n            Then ?1... and ?2... coding are used to indicate where\n            substitution must be done in the JCL skeleton.\n1   02/06/92\n                                                      IMSLDS    2/4.\n\n  Member IMSLOG00 : below follows a list of the JCL skeleton used at\n  ================= our installation.\n                    The syntax of the IMS days log data-set(s) name is\n                        IMS.SLDSP.Dyyddd.Thhmmsst.Vnn\n                    and of the IMS month log data-set name is\n                        IMS.LOGOUT.Myymm\n\n  ?1  IMS.SLDSP\n  ?2  IMS.LOGOUT\n  //IMSLOGX  JOB (AAAAPPPP),'IMS LOG DATA-SET(S)',CLASS=8,\n  //             MSGLEVEL=(1,1),MSGCLASS=X,REGION=4M,TIME=(,30),\n  ?I\n  //             GROUP=IMS,USER=IMSOPER\n  ?0\n  /*JOBPARM L=25\n  //*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n  //*      M E R G E   L O G   S T A T I S T I C S   R E P O R T      *\n  //*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n  //* DOC : THIS JOB PRODUCES A MERGED LOG FROM THE ORIGINALS LOGS    *\n  //*       DATA-SET(S) FOR THE PRINTLOG PROCEDURE.                   *\n  //*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n  //MERGE   EXEC PGM=DFSLTMG0\n  //STEPLIB   DD DSN=->.LOAD.IMS.RESLIB,DISP=SHR\n  //LOG...    DD DSN=?1...,DISP=SHR\n  //LOGOUT    DD DSN=?2...,DISP=...,\n  //             UNIT=DISK,VOL=SER=......,SPACE=(CYL,(400,20)),\n  //             DCB=(RECFM=FB,LRECL=22524,BLKSIZE=22528)\n  //SYSIN     DD *\n  MSG\n  /*\n  //PRINT     DD SYSOUT=*\n  //SYSPRINT  DD SYSOUT=*\n  //SYSUDUMP  DD SYSOUT=*\n  //*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n  //*      A R C H I V E   A L L   L O G   D A T A - S E T ( S )      *\n  //*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n  //ARCHV   EXEC ARCHIVE,COND.ARCHIVE=(0,LT,MERGE)\n  //SYSIN     DD *\n    ARCHIVE  DSN=?1...\n  /*\n\n  Note : the distributed IMSLOG00 member contain private comments\n  ------ cards with all explanations and requirements about the JCL\n         statements coding.\n1   02/06/92\n                                                      IMSLDS    3/4.\n\n  How to invoke it :\n  ==================\n      1. As console START command :\n              S IMSLOG,D=YYDDD,J=XX,O=COPY\n                                      SCAN\n         where IMSLOG may be, I.E., the following procedure :\n              //IMSLOG  PROC D=,J=,O=\n              //IMSLOG  EXEC PGM=IMSLDS,PARM='DAY=&D,JCL=&J,&O'\n                                     or PARM='D=&D,J=&J,&O'\n      2. As batch EXEC procedure :\n              //... EXEC IMSLOG,D=YYDDD,J=XX\n      3. As batch EXEC :\n              //... EXEC PGM=IMSLDS,PARM='DAY=YYDDD,JCL=XX'\n                                 or PARM='D=YYDDD,J=XX'\n      4. As TSO call :\n              CALL '...DSNAME...(IMSLDS)' 'DAY=YYDDD,JCL=XX'\n                                       or 'D=YYDDD,J=XX'\n      5. As TSO command or sub-command :\n              IMSLDS ... (for syntax description see below) ...\n\n  where : - YYDDD is the desired serial day date selection (if not\n  -------   specified, yesterday date is used).\n          - JCL=XX (or JOB=/J=) is the two characters suffix to form\n            the member name IMSLOG.. (default is 00).\n          - COPY/SCAN (or C/S) are JCL submit options (job TYPRUN).\n\n  Notes : 1. Only when running as system task (through operator START\n  =======    command), the COPY or SCAN options are accepted and all\n             generated JCL statements are immediately SUBMIT to JES2.\n          2. Otherwise (batch or TSO running), the generated JCL is\n             always stored in a new (created) data-set named as\n             follows : '#0.GENJCL.D#1.T#2'\n             where : #0 = current RACF User-id\n                     #1 = YYDDD (current day)\n                     #2 = HHMMSS (current time of day)\n             You may then submit it, if you want.\n1   02/06/92\n                                                      IMSLDS    4/4.\n\n  TSO command or sub-command syntax :\n  ===================================\n         IMSLDS  DAY(DD/MM/YY)  JCL(XX)  OPTION\n                 alias : D(DD/MM/YY)  JOB(XX)\n                                      J(XX)\n         IMSLDS  FROM(DD/MM/YY)  TO(DD/MM/YY)  JCL(XX)  OPTION\n                 alias : F(DD/MM/YY)  T(DD/MM/YY)  JOB(XX)\n                                                   J(XX)\n\n  where : DAY(DD/MM/YY) indicate a particular date selection, if\n  -------      not specified it means yesterday date.\n          FROM(DD/MM/YY) and TO(DD/MM/YY) indicate a range of dates\n               (respectively the starting and ending date), which\n               must fall in the same month.\n               If the ending date is not supplied it means the end\n               of the starting date month or the yesterday date when\n               this is lower.\n          JCL(XX) is the two characters suffix to form the member name\n               IMSLOG.. (default is 00).\n          OPTION may one of the following keywords :\n                    MSG or LIST (alias M or L)\n               or : NOMSG or NOLIST (alias N)\n               which allows you to accept/suppress all messages.\n  Remarks : 1. A IMSLDS command with FROM and TO identical dates is\n  --------     like IMSLDS DAY(DD/MM/YY) command.\n            2. A IMSLDS command with only the FROM(DD/MM/YY) date\n               which matches the last day of the month is also like\n               a IMSLDS DAY(DD/MM/YY) command.\n\n  Completion codes :     0 = normal termination.\n  ==================    16 = a severe error has been detected.\n\n  TSO CLIST :  When running in a TSO CLIST environment, a variable\n  ===========  named EUGENDS will contain the name of the generated\n               JCL data-set.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "IMSLDSH": {"ttr": 9989, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x92\\x15\\x7f\\x00\\x92\\x15\\x7f\\x13W\\x00*\\x00*\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1992-06-05T00:00:00", "modifydate": "1992-06-05T13:57:00", "lines": 42, "newlines": 42, "modlines": 0, "user": "SYSPAJA"}, "text": "./     ADD     NAME=IMSLDS\n./     NUMBER  NEW1=100,INCR=100\n)F Function :  IMS log data-set(s) TSO-command.\n               Automatic JCL generation to cumulate all days IMS log\n               data-set(s) into a one month data-set.\n)X Syntax :    IMSLDS  DAY(DD/MM/YY)  JCL(XX)  OPTION\n               or\n               IMSLDS  FROM(DD/MM/YY)  TO(DD/MM/YY)  JCL(XX)  OPTION\n               Required : none\n               Return codes (&LASTCC value) :\n                   0 = normal termination.\n                  16 = a severe error has been detected.\n               TSO CLIST : When running in a TSO CLIST environment, a\n                  variable named EUGENDS will contain the name of the\n                  generated JCL data-set.\n)O Operands :\n))DAY(DD/MM/YY) : indicate a particular date selection, if not\n               specified it means yesterday date.\n               Alias : D(DD/MM/YY)\n))FROM(DD/MM/YY) and TO(DD/MM/YY) : indicate a range of dates\n               (respectively the starting and ending date), which\n               must fall in the same month.\n               If the ending date is not supplied it means the end\n               of the starting date month or the yesterday date when\n               this is lower.\n               Aliases : F(DD/MM/YY) and T(DD/MM/YY)\n     Remarks : 1. A IMSLDS command with FROM and TO identical dates\n                  is like IMSLDS DAY(DD/MM/YY) command.\n               2. A IMSLDS command with only the FROM(DD/MM/YY) date\n                  which matches the last day of the month is also like\n                  a IMSLDS DAY(DD/MM/YY) command.\n))JCL(XX) : is the two characters suffix to form the member name\n               IMSLOG.. (default is 00).\n               Aliases : JOB(XX) or J(XX)\n))OPTION : may one of the following keywords (default is LIST)\n               LIST = full error message(s) will be displayed.\n                        Aliases : L, MSG or M.\n               NOLIST = no error message(s) will be displayed, only the\n                        return code (&LASTCC) is set.\n                        Aliases : NOMSG or N.\n               It allows you to accept/suppress all messages.\n./     ENDUP\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "IMSLDSP": {"ttr": 9991, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x92\\x15O\\x00\\x92\\x15O\\x17!\\x00\\x08\\x00\\x08\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1992-06-02T00:00:00", "modifydate": "1992-06-02T17:21:00", "lines": 8, "newlines": 8, "modlines": 0, "user": "SYSPAJA"}, "text": "./     ADD     NAME=IMSLOG\n./     NUMBER  NEW1=100,INCR=100\n//IMSLOG  PROC D=,J=,O=\n//*-----------------------------------------------------------------*\n//*             I.M.S. LOG DATA-SET(S) DAILY PROCESSING.            *\n//*-----------------------------------------------------------------*\n//IMSLOG  EXEC PGM=IMSLDS,PARM='D=&D,J=&J,&O'\n./     ENDUP\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IMSLOG00": {"ttr": 9993, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x942\\x7f\\x00\\x942\\x7f\\x15\\x10\\x00=\\x00=\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-23T00:00:00", "modifydate": "1994-11-23T15:10:00", "lines": 61, "newlines": 61, "modlines": 0, "user": "SYSPAJA"}, "text": "*************** --- SUBMIT JCL SKELETON FOR \"IMSLDS\" --- **************\n***====> IMS DAY'S LOG DATA-SET(S) LEVEL NAME (SET, AS INDICATED BELOW,\n***====> THE LEVEL TO SEARCH THE DAY'S DATA-SET(S) IN THE CATALOG).\n***====> I.E. : <------->\n?1              IMS.SLDSP\n***====> IMS MONTH LOG DATA-SET LEVEL NAME (SET, AS INDICATED BELOW,\n***====> THE LEVEL TO CREATE THE MONTH'S DATA-SET).\n***====> I.E. : <-------->\n?2              IMS.LOGOUT\n***- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -***\n***                    P R E - R E Q U I S I T E                    ***\n***- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -***\n***      JES2 USER IDENTIFICATION PROPAGATION :                     ***\n***      --------------------------------------                     ***\n***      THE GROUP AND USER DECLARED IN THE JOB CARD SKELETON       ***\n***      FOR THE STARTED TASK MUST BE THE SAME AS THOSE DEFINED     ***\n***      IN THE RACF STARTED PROCEDURES TABLE (ICHRIN03).           ***\n***- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -***\n***====> IMS LOG DATA-SET(S) JOB SKELETON (THE JOB CARD BELOW IS THAT\n***====> USED BY SUBMIT WHEN STARTED TASK).\n***====> MANDATORY : GROUP AND USER PARAMETERS MUST BE CODED IN THE\n***====>             LAST CARD OF THE JOB STATEMENT.\n//IMSLOGX  JOB (AAAAPPPP),'IMS LOG DATA-SET(S)',CLASS=8,\n//             MSGLEVEL=(1,1),MSGCLASS=X,REGION=4M,TIME=(,30),\n?I       HERE INSERT EVENTUALLY TYPRUN=... PARAMETER CARD.\n//             GROUP=IMS,USER=IMSOPER\n?0       HERE STARTS THE COMMON JCL SKELETON.\n/*JOBPARM L=25\n//*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n//*       M E R G E   L O G   S T A T I S T I C S   R E P O R T       *\n//*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n//* DOC : THIS JOB PRODUCES A MERGED LOG FROM THE ORIGINALS LOGS      *\n//*       DATA-SET(S) FOR THE PRINTLOG PROCEDURE.                     *\n//*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n//MERGE   EXEC PGM=DFSLTMG0\n//STEPLIB   DD DSN=->.LOAD.IMS.RESLIB,DISP=SHR\n***====> MANDATORY : DO NOT MODIFY NEXT CARD CODING, UNLESS THE\n***====>             DISP=SHR WHICH MAY BE CHANGED BY ANY DISP=...\n***====>             AS YOU WANT IT (I.E. : DISP=OLD).\n//LOG...    DD DSN=?1...,DISP=SHR\n***====> MANDATORY : DO NOT MODIFY NEXT FIRST CARD CODING. OTHERS ARE\n***====>             CREATION DEFINITION, MODIFY THEM AS YOU WANT.\n//LOGOUT    DD DSN=?2...,DISP=...,\n//             UNIT=DISK,VOL=SER=......,SPACE=(CYL,(400,20)),\n//             DCB=(RECFM=FB,LRECL=22524,BLKSIZE=22528)\n//SYSIN     DD *\nMSG\n/*\n//PRINT     DD SYSOUT=*\n//SYSPRINT  DD SYSOUT=*\n//SYSUDUMP  DD SYSOUT=*\n//*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n//*       A R C H I V E   A L L   L O G   D A T A - S E T ( S )       *\n//*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*\n***====> THE FOLLOWING STEP CALL A 'DMS' PROCEDURE (SOMEWHAT LIKE\n***====> THE IBM HSM) TO ARCHIVE ALL PREVIOUSLY USED IMS DAY'S LOG\n***====> DATA-SET(S).\n//ARCHV   EXEC ARCHIVE,COND.ARCHIVE=(0,LT,MERGE)\n//SYSIN     DD *\n  ARCHIVE  DSN=?1...\n/*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IOPACK": {"ttr": 9995, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x882\\x1f\\x00\\x882\\x1f\\t&\\x04e\\x04e\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-11-16T00:00:00", "modifydate": "1988-11-16T09:26:00", "lines": 1125, "newlines": 1125, "modlines": 0, "user": "SYSPAJA"}, "text": "IOPR     TITLE 'I/O PACKAGE ROUTINES - PS. - DA. - IS.'\nCROPEN   START 0\n         SPACE 1\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n* * * * * * * * *                                     * * * * * * * * *\n* * * * * * * * *        I/O PACKAGE ROUTINES         * * * * * * * * *\n* * * * * * * * *                                     * * * * * * * * *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*                                                                     *\n*                                                                     *\n* AUTHOR :     P.A. MOINIL                                            *\n* --------     COMPUTING CENTRE                                       *\n*              J.R.C. - ISPRA ESTABLISHMENT                           *\n*              21020 ISPRA (VA), ITALY                                *\n*                                                                     *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*                                                                     *\n* PURPOSE :    HELP USERS TO MANAGE FILES OF THE THREE BASIC ACCESS   *\n* ---------    METHODS TYPES AVAILABLE IN O.S. : PS, DA AND IS.       *\n*                                                                     *\n* MVS/XA :     MUST BE AMODE AND RMODE 24.                            *\n* ---------                                                           *\n*                                                                     *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         SPACE 2\n        $DEFREG\n         EJECT\n*        MISCELLANEOUS DEFINITIONS.\n*        --------------------------\n         SPACE 1\nNDST     EQU   20                  MAX. RANGE OF RESERVE TABLE.\n         SPACE 1\nOFF      EQU   X'0F'               NOP OPERATION SWITCH SETTING.\nON       EQU   X'F0'               BRANCH OPERATION SWITCH SETTING.\nALLBITS  EQU   X'FF'               ALL BITS MASK.\n         SPACE 2\nFBWAD    DSECT                     FILE BLOCK WORK AREA.\n         SPACE 1\nFPTR     DS    F                   FORWARD CHAIN POINTER.\nFDDNM    DS    CL8                 DD-NAME.\nFLIST    DS    F                   WORK PARAMETER'S LIST.\nFPARM    DS    3F                  OPEN ARGUMENTS ADDRESSES.\nFCODE    DS    C                   OPERATION CONDITION CODE.\nFOPTC    DS    C                   OPERATIONS TYPE CONTROL.\n         DS    H\nFDECB    DS    7F                  DATA EVENT CONTROL BLOCK.\n         SPACE 1\nF1STL    EQU   *-FPTR\n         SPACE 1\nFDCB     DS    70F                 DATA CONTROL BLOCK.\n         SPACE 1\nF2NDL    EQU   (*-FDCB)/2\n         SPACE 1\nFBWAL    EQU   (((*-FBWAD)+7)/8)*8\n         SPACE 1\nCROPEN   CSECT                     RESTORE ORIGINAL CSECT.\n         EJECT\n         ENTRY RDOPEN\n         ENTRY IOPEN\n         ENTRY DOPEN\n         ENTRY SOPEN\n         ENTRY CRWRIT\n         ENTRY SETL\n         ENTRY ESETL\n         ENTRY REREAD\n         ENTRY IWRITE\n         ENTRY IREAD\n         ENTRY REWRIT\n         ENTRY IREADU\n         ENTRY DWRITE\n         ENTRY DREAD\n         ENTRY SWRITE\n         ENTRY SREAD\n         ENTRY BACKSP\n         ENTRY TCLOSE\n         ENTRY SCLOSE\n         ENTRY DCLOSE\n         ENTRY CLOSAL\n         SPACE 2\n         USING *,R15\n         MVI   WTGO+3,IOPACK-*     SET CROPEN ENTRY --------  1.\n         B     WTGO                GO COMMON ENTRY.\n         DROP  R15\n         SPACE 1\n         USING *,R15\nRDOPEN   MVI   WTGO+3,IOPACK-*     SET RDOPEN ENTRY --------  2.\n         B     WTGO                GO COMMON ENTRY.\n         DROP  R15\n         SPACE 1\n         USING *,R15\nIOPEN    MVI   WTGO+3,IOPACK-*     SET IOPEN ENTRY ---------  3.\n         B     WTGO                GO COMMON ENTRY.\n         DROP  R15\n         SPACE 1\n         USING *,R15\nDOPEN    MVI   WTGO+3,IOPACK-*     SET DOPEN ENTRY ---------  4.\n         B     WTGO                GO COMMON ENTRY.\n         DROP  R15\n         SPACE 1\n         USING *,R15\nSOPEN    MVI   WTGO+3,IOPACK-*     SET SOPEN ENTRY ---------  5.\n         B     WTGO                GO COMMON ENTRY.\n         DROP  R15\n         EJECT\n         USING *,R15\nCRWRIT   MVI   WTGO+3,IOPACK-*     SET CRWRIT ENTRY --------  6.\n         B     WTGO                GO COMMON ENTRY.\n         DROP  R15\n         SPACE 1\n         USING *,R15\nSETL     MVI   WTGO+3,IOPACK-*     SET SETL ENTRY ----------  7.\n         B     WTGO                GO COMMON ENTRY.\n         DROP  R15\n         SPACE 1\n         USING *,R15\nESETL    MVI   WTGO+3,IOPACK-*     SET ESETL ENTRY ---------  8.\n         B     WTGO                GO COMMON ENTRY.\n         DROP  R15\n         SPACE 1\n         USING *,R15\nREREAD   MVI   WTGO+3,IOPACK-*     SET REREAD ENTRY --------  9.\n         B     WTGO                GO COMMON ENTRY.\n         DROP  R15\n         SPACE 1\n         USING *,R15\nIWRITE   MVI   WTGO+3,IOPACK-*     SET IWRITE ENTRY -------- 10.\n         B     WTGO                GO COMMON ENTRY.\n         DROP  R15\n         SPACE 1\n         USING *,R15\nIREAD    MVI   WTGO+3,IOPACK-*     SET IREAD ENTRY --------- 11.\n         B     WTGO                GO COMMON ENTRY.\n         DROP  R15\n         SPACE 1\n         USING *,R15\nREWRIT   MVI   WTGO+3,IOPACK-*     SET REWRIT ENTRY -------- 12.\n         B     WTGO                GO COMMON ENTRY.\n         DROP  R15\n         SPACE 1\n         USING *,R15\nIREADU   MVI   WTGO+3,IOPACK-*     SET IREADU ENTRY -------- 13.\n         B     WTGO                GO COMMON ENTRY.\n         DROP  R15\n         SPACE 1\n         USING *,R15\nDWRITE   MVI   WTGO+3,IOPACK-*     SET DWRITE ENTRY -------- 14.\n         B     WTGO                GO COMMON ENTRY.\n         DROP  R15\n         SPACE 1\n         USING *,R15\nDREAD    MVI   WTGO+3,IOPACK-*     SET DREAD ENTRY --------- 15.\n         B     WTGO                GO COMMON ENTRY.\n         DROP  R15\n         EJECT\n         USING *,R15\nSWRITE   MVI   WTGO+3,IOPACK-*     SET SWRITE ENTRY -------- 16.\n         B     WTGO                GO COMMON ENTRY.\n         DROP  R15\n         SPACE 1\n         USING *,R15\nSREAD    MVI   WTGO+3,IOPACK-*     SET SREAD ENTRY --------- 17.\n         B     WTGO                GO COMMON ENTRY.\n         DROP  R15\n         SPACE 1\n         USING *,R15\nBACKSP   MVI   WTGO+3,IOPACK-*     SET BACKSP ENTRY -------- 18.\n         B     WTGO                GO COMMON ENTRY.\n         DROP  R15\n         SPACE 1\n         USING *,R15\nTCLOSE   MVI   WTGO+3,IOPACK-*     SET TCLOSE ENTRY -------- 19.\n         B     WTGO                GO COMMON ENTRY.\n         DROP  R15\n         SPACE 1\n         USING *,R15\nSCLOSE   MVI   WTGO+3,IOPACK-*     SET SCLOSE ENTRY -------- 20.\n         B     WTGO                GO COMMON ENTRY.\n         DROP  R15\n         SPACE 1\n         USING *,R15\nDCLOSE   MVI   WTGO+3,IOPACK-*     SET DCLOSE ENTRY -------- 21.\n         B     WTGO                GO COMMON ENTRY.\n         DROP  R15\n         SPACE 1\n         USING *,R15\nCLOSAL   MVI   WTGO+3,IOPACK-*     SET CLOSAL ENTRY -------- 22.\n         DROP  R15\n         SPACE 2\nWTGO     LA    R15,*-*(R15)        SET COMMON ENTRY ADDRESS.\n         SPACE 2\nMAXENT   EQU   ((*-CROPEN)/8)+1\n         EJECT\nIOPACK  $XENT BASE=R11\n         NI    SWCTL+1,OFF\n         LR    R15,R11             COMPUTE WHERE TO GO.\n         BCTR  R15,0\n         SR    R14,R14\n         IC    R14,0(R15)\n         SRL   R14,3\n         LA    R12,MAXENT\n         SR    R12,R14\n         LR    R14,R12\n         SLL   R12,12\n         LA    R12,MAXERR(R12)\n         BCTR  R14,0\n         SLL   R14,2\n         B     *+L'*(R14)          ENTER SELECTED ROUTINE.\n         EJECT\n*        BRANCH ENTRIES VECTOR.\n         SPACE 1\n         B     #CROPEN -----------  1.\n         B     #RDOPEN -----------  2.\n         B     #IOPEN ------------  3.\n         B     #DOPEN ------------  4.\n         B     #SOPEN ------------  5.\n         B     #CRWRIT -----------  6.\n         B     #SETL -------------  7.\n         B     #ESETL ------------  8.\n         B     #REREAD -----------  9.\n         B     #IWRITE ----------- 10.\n         B     #IREAD ------------ 11.\n         B     #REWRIT ----------- 12.\n         B     #IREADU ----------- 13.\n         B     #DWRITE ----------- 14.\n         B     #DREAD ------------ 15.\n         B     #SWRITE ----------- 16.\n         B     #SREAD ------------ 17.\n         B     #BACKSP ----------- 18.\n         B     #TCLOSE ----------- 19.\n         B     #SCLOSE ----------- 20.\n         B     #DCLOSE ----------- 21.\n         B     #CLOSAL ----------- 22.\n         EJECT\n*        CALL  CROPEN (DDNAME,DCBAR,RKP,ISPEC,AREA)\n*                     (------,-----,---,-----)\n*                     (------,-----,---)\n         SPACE 1\n#CROPEN  NULL\n         BAL   R10,VERIFOP\n         USING FBWAD,R9\n         MVI   FOPTC,5\n         MVC   0(LDCBCR,R8),CRDCB\n         USING IHADCB,R8\n         MVC   DCBDDNAM(L'DCBDDNAM),0(R2)\n         LTR   R3,R3\n         BM    ERR1\n         TM    11(R1),X'03'\n         BNZ   ERR1\n         MVC   DCBRKP(L'DCBRKP),2(R4)\n         LTR   R4,R4\n         BM    CROPEN1\n         TM    15(R1),X'03'\n         BNZ   ERR1\n         L     R4,12(R1)\n         LTR   R4,R4\n         LA    R4,0(R4)\n         BM    CROPEN2\n         L     R5,16(R1)\n         LTR   R5,R5\n         BNM   ERR1\n         LA    R5,0(R5)\n         B     CROPEN3\nCROPEN1  SR    R4,R4\nCROPEN2  SR    R5,R5\nCROPEN3  STM   R4,R5,FPARM\n         LA    R1,FLIST\n         ST    R8,0(R1)\n         MVI   0(R1),X'8F'         OPEN FOR OUTPUT.\n        OPEN   MF=(E,(1))\n         TM    DCBOFLGS,DCBOFOPN\n         BO    RETURN\n         B     ERR2\n         DROP  R8,R9\n         EJECT\n*        CALL  RDOPEN (DDNAME,DCBAR,ISPEC,AREA)\n*                     (------,-----,-----)\n*                     (------,-----)\n         SPACE 1\n#RDOPEN  NULL\n         BAL   R10,VERIFOP\n         USING FBWAD,R9\n         MVI   FOPTC,4\n         MVC   0(LDCBRD,R8),RDDCB\n         USING IHADCB,R8\n         MVC   DCBDDNAM(L'DCBDDNAM),0(R2)\n         LTR   R3,R3\n         BM    RDOPEN1\n         TM    11(R1),X'03'\n         BNZ   ERR1\n         LTR   R4,R4\n         LA    R4,0(R4)\n         BM    RDOPEN2\n         L     R5,12(R1)\n         LTR   R5,R5\n         BNL   ERR1\n         LA    R5,0(R5)\n         B     RDOPEN3\nRDOPEN1  SR    R4,R4\nRDOPEN2  SR    R5,R5\nRDOPEN3  STM   R4,R5,FPARM\n         LA    R1,FLIST\n         ST    R8,0(R1)\n         MVI   0(R1),X'80'         OPEN FOR INPUT.\n        OPEN   MF=(E,(1))\n         TM    DCBOFLGS,DCBOFOPN\n         BO    RETURN\n         B     ERR2\n         DROP  R8,R9\n         EJECT\n*        CALL  IOPEN (DDNAME,DCBAR,MSHI,LMSH,MSWA,LMSW,ISPEC,KEY,AREA)\n*                    (------,-----,----,----,----,----,-----,---)\n*                    (------,-----,----,----,----,----,-----)\n*                    (------,-----,----,----,----,----)\n         SPACE 1\n#IOPEN   NULL\n         BAL   R10,VERIFOP\n         USING FBWAD,R9\n         MVI   FOPTC,3\n         MVC   0(LDCBI,R8),DCBI\n         USING IHADCB,R8\n         MVC   DCBDDNAM(L'DCBDDNAM),0(R2)\n         LTR   R3,R3\n         BM    ERR1\n         LTR   R4,R4\n         BM    ERR1\n         LM    R5,R7,12(R1)\n         TM    15(R1),X'03'\n         BNZ   ERR1\n         LTR   R5,R5\n         BM    ERR1\n         LTR   R6,R6\n         BM    ERR1\n         L     R5,0(R5)\n         LTR   R5,R5\n         BZ    IOPEN1\n         STH   R5,DCBSMSI\n         MVC   DCBMSHI+1(3),9(R1)\nIOPEN1   TM    23(R1),X'03'\n         BNZ   ERR1\n         LR    R0,R7\n         L     R7,0(R7)\n         LTR   R7,R7\n         BZ    IOPEN2\n         STH   R7,DCBSMSW\n         LA    R6,0(R6)\n         ST    R6,DCBMSWA\nIOPEN2   SR    R4,R4\n         SR    R5,R5\n         SR    R6,R6\n         LTR   R0,R0\n         BM    DOPEN1\n         TM    27(R1),X'03'\n         BNZ   ERR1\n         L     R2,24(R1)\n         LA    R4,0(R2)\n         LTR   R2,R2\n         BM    DOPEN1\n         L     R2,28(R1)\n         LA    R6,0(R2)\n         LTR   R2,R2\n         BM    DOPEN1\n         L     R2,32(R1)\n         LA    R5,0(R2)\n         LTR   R2,R2\n         BM    DOPEN1\n         B     ERR1\n         DROP  R8,R9\n         EJECT\n*        CALL  DOPEN (DDNAME,DCBAR,ISPEC,NREC,AREA)\n*                    (------,-----,-----,----)\n*                    (------,-----,-----)\n*                    (------,-----)\n         SPACE 1\n#DOPEN   NULL\n         BAL   R10,VERIFOP\n         USING FBWAD,R9\n         MVI   FOPTC,2\n         MVC   0(LDCBD,R8),DCBD\n         USING IHADCB,R8\n         MVC   DCBDDNAM(L'DCBDDNAM),0(R2)\n         SR    R5,R5\n         LR    R6,R5\n         LR    R4,R5\n         LTR   R3,R3\n         BM    DOPEN1\n         TM    11(R1),X'03'\n         BNZ   ERR1\n         L     R2,8(R1)\n         LA    R4,0(R2)\n         LTR   R2,R2\n         BM    DOPEN1\n         L     R2,12(R1)\n         LA    R6,0(R2)\n         LTR   R2,R2\n         BM    DOPEN1\n         L     R2,16(R1)\n         LA    R5,0(R2)\n         LTR   R2,R2\n         BNM   ERR1\nDOPEN1   STM   R4,R6,FPARM\n         LA    R1,FLIST\n         ST    R8,0(R1)\n         MVI   0(R1),X'94'         OPEN FOR REREAD/UPDAT.\n        OPEN   MF=(E,(1))\n         TM    DCBOFLGS,DCBOFOPN\n         BO    RETURN\n         B     ERR2\n         DROP  R8,R9\n         EJECT\n*        CALL  SOPEN (DDNAME,DCBAR,IOPT,ISPEC,AREA)\n*                    (------,-----,----,-----)\n*                    (------,-----,----)\n         SPACE 1\n#SOPEN   NULL\n         BAL   R10,VERIFOP\n         USING FBWAD,R9\n         MVI   FOPTC,1\n         MVC   0(LDCBS,R8),DCBS\n         USING IHADCB,R8\n         MVC   DCBDDNAM(L'DCBDDNAM),0(R2)\n         LTR   R3,R3\n         BM    ERR1\n         TM    11(R1),X'03'\n         BNZ   ERR1\n         SR    R5,R5\n         LR    R6,R5\n         LTR   R4,R4\n         BM    SOPEN2\n         TM    15(R1),X'03'\n         BNZ   ERR1\n         L     R2,12(R1)\n         LTR   R2,R2\n         BM    SOPEN1\n         L     R6,16(R1)\n         LTR   R6,R6\n         BNM   ERR1\n         LA    R6,0(R6)\nSOPEN1   LA    R5,0(R2)\nSOPEN2   STM   R5,R6,FPARM\n         LA    R1,FLIST\n         ST    R8,0(R1)\n         L     R4,0(R4)\n         STC   R4,0(R1)\n         OI    0(R1),X'80'\n         TM    0(R1),X'0F'\n         BO    SOPENWR\n         BZ    SOPENRD\n         TM    0(R1),X'03'\n         BNO   ERR2\n         TM    0(R1),X'08'         OPEN FOR OUTIN OR INOUT.\n         BO    ERR2\nSOPENEF OPEN   MF=(E,(1))\n         TM    DCBOFLGS,DCBOFOPN\n         BO    RETURN\n         B     ERR2\nSOPENRD  MVI   DCBMACR2,X'00'      OPEN FOR INPUT.\n         B     SOPENEF\nSOPENWR  MVI   DCBMACR1,X'00'      OPEN FOR OUTPUT.\n         B     SOPENEF\n         DROP  R8,R9\n         EJECT\n*        CALL  CRWRIT (DCBAR,AREA)\n*                     (-----)\n         SPACE 1\n#CRWRIT  NULL\n         L     R2,0(R1)\n         BAL   R10,VERIFRW\n         USING FBWAD,R9\n         CLI   FOPTC,5\n         BNE   ERR6\n         LTR   R2,R2\n         BM    CRWRIT1\n         L     R3,4(R1)\n         LA    R3,0(R3)\n         B     CRWRIT2\nCRWRIT1  L     R3,FPARM+4\n         LTR   R3,R3\n         BZ    ERR1\nCRWRIT2 PUT    (R8),(R3)\n         B     SRDWRFIN\n         DROP  R9\n         EJECT\n*        CALL  SETL (DCBAR,KEY)\n*                   (-----)\n         SPACE 1\n#SETL    NULL\n         OI    SWCTL+1,ON\n         L     R2,0(R1)\n         BAL   R10,VERIFRW\n         USING FBWAD,R9\n         CLI   FOPTC,4\n         BNE   ERR6\n         LTR   R2,R2\n         BM    SETLB\n         L     R3,4(R1)\n         LA    R3,0(R3)\n        SETL   (R8),K,(R3)\n         B     RETURN\nSETLB   SETL   (R8),B\n         B     RETURN\n         DROP  R9\n         SPACE 2\n*        CALL  ESETL (DCBAR)\n         SPACE 1\n#ESETL   NULL\n         OI    SWCTL+1,ON\n         L     R2,0(R1)\n         BAL   R10,VERIFRW\n         USING FBWAD,R9\n         CLI   FOPTC,4\n         BNE   ERR6\n        ESETL  (R8)\n         B     RETURN\n         DROP  R9\n         EJECT\n*        CALL  REREAD (DCBAR,AREA)\n*                     (-----)\n         SPACE 1\n#REREAD  NULL\n         L     R2,0(R1)\n         BAL   R10,VERIFRW\n         USING FBWAD,R9\n         CLI   FOPTC,4\n         BNE   ERR6\n         LTR   R2,R2\n         BM    REREAD1\n         L     R3,4(R1)\n         LA    R3,0(R3)\n         B     REREAD2\nREREAD1  L     R3,FPARM\n         LTR   R3,R3\n         BZ    ERR1\nREREAD2 GET    (R8),(R3)\n         USING IHADCB,R8\n         SR    R4,R4               GET THE KEY LENGTH.\n         IC    R4,DCBKEYLE\n         LA    R4,0(R4,R3)         COMPUTE RECORD FIRST BYTE POSITION.\n         LH    R5,DCBLRECL\n         BCTR  R5,0\n         LA    R6,256\nREREAD3  CR    R5,R6\n         BL    REREAD4\n         MVC   0(256,R3),R4\n         AR    R3,R6\n         AR    R4,R6\n         SR    R5,R6\n         B     REREAD3\nREREAD4  EX    R5,MVREREAD\n         B     SRDWRFIN\nMVREREAD MVC   0(1,R3),0(R4)\n         DROP  R8,R9\n         EJECT\n*        CALL  IWRITE (DCBAR,KEY,AREA)\n*                     (-----,---)\n*                     (-----)\n         SPACE 1\n#IWRITE  NULL\n         LA    R5,DECBWRKN\n         B     UREAD1\n         SPACE 2\n*        CALL  IREAD (DCBAR,KEY,AREA)\n*                    (-----,---)\n*                    (-----)\n         SPACE 1\n#IREAD   NULL\n         LA    R5,DECBRDK\n         B     UREAD1\n         SPACE 2\n*        CALL  REWRIT (DCBAR,KEY,AREA)\n*                     (-----,---)\n*                     (-----)\n         SPACE 1\n#REWRIT  NULL\n         LA    R5,DECBWRK\n         B     UREAD1\n         SPACE 2\n*        CALL  IREADU (DCBAR,KEY,AREA)\n*                     (-----,---)\n*                     (-----)\n         SPACE 1\n#IREADU  NULL\n         LA    R5,DECBRDKU\nUREAD1   L     R2,0(R1)\n         BAL   R10,VERIFRW\n         USING FBWAD,R9\n         CLI   FOPTC,3\n         BNE   ERR6\n         LTR   R2,R2\n         BM    UREAD2\n         L     R3,4(R1)\n         LTR   R3,R3\n         LA    R3,0(R3)\n         BM    UREAD3\n         L     R4,8(R1)\n         LTR   R4,R4\n         BNM   ERR1\n         LA    R4,0(R4)\n         B     UREAD4\nUREAD2   L     R3,FPARM+8\n         LTR   R3,R3\n         BZ    ERR1\nUREAD3   L     R4,FPARM+4\n         LTR   R4,R4\n         BZ    ERR1\nUREAD4   LA    R1,FDECB\n         USING DECB,R1\n         XC    DECSDECB,DECSDECB\n         MVI   DECTYPE1,DECBLNS\n         STC   R5,DECTYPE2\n         ST    R8,DECDCBAD\n         ST    R4,DECAREA\n         ST    R3,DECKYADR\n         TM    DECTYPE2,DECBWRKN\n         BO    UREAD5\n         USING IHADCB,R8\n         L     R15,DCBLRAN\n         B     UREAD6\nUREAD5   L     R15,DCBLWKN\nUREAD6   BALR  R14,R15             * READ - WRITE *\n        CHECK  FDECB,DSORG=IS\n         CLI   FCODE,0\n         BNE   SRDWRFIN\n         TM    DECBEXC1,ALLBITS-DECEXOFL\n         BZ    SRDWRFIN\n         TM    DECBEXC1,DECEXRLC+DECEXNSP+DECEXINV+DECEXERR+DECEXDUP\n         BZ    URDWRER1\n         MVI   FCODE,2             OTHER ERRORS.\n         B     SRDWRFIN\nURDWRER1 TM    DECBEXC1,DECEXUBK\n         BZ    URDWRER2\n         MVI   FCODE,3             UNREACHABLE BLOCK.\n         B     SRDWRFIN\nURDWRER2 MVI   FCODE,4             RECORD NOT FOUND.\n         B     SRDWRFIN\n         DROP  R1,R8,R9\n         EJECT\n*        CALL  DWRITE (DCBAR,NREC,AREA)\n*                     (-----,----)\n*                     (-----)\n         SPACE 1\n#DWRITE  NULL\n         LA    R5,DECBKLNS\n         L     R2,0(R1)\n         BAL   R10,VERIFRW\n         USING FBWAD,R9\n         USING IHADCB,R8\n         CLI   DCBMACF2,DCBMRWRT+DCBMRIDW\n         B     DRDWRSH1\n         SPACE 2\n*        CALL  DREAD (DCBAR,NREC,AREA)\n*                    (-----,----)\n*                    (-----)\n         SPACE 1\n#DREAD   NULL\n         LA    R5,DECBKLNS+DECOPRD\n         L     R2,0(R1)\n         BAL   R10,VERIFRW\n         CLI   DCBMACF1,DCBMRRD+DCBMRRDI+DCBMRCK\nDRDWRSH1 BNE   ERR7\n         CLI   FOPTC,2\n         BNE   ERR6\n         LTR   R2,R2\n         BM    DRDWRSH2\n         L     R4,4(R1)\n         LTR   R4,R4\n         LA    R4,0(R4)\n         BM    DRDWRSH3\n         L     R3,8(R1)\n         LTR   R3,R3\n         BNM   ERR1\n         LA    R3,0(R3)\n         B     DRDWRSH4\nDRDWRSH2 L     R4,FPARM+8\n         LTR   R4,R4\n         BZ    ERR1\nDRDWRSH3 L     R3,FPARM+4\n         LTR   R3,R3\n         BZ    ERR1\nDRDWRSH4 LA    R4,1(R4)\n         LA    R1,FDECB\n         USING DECB,R1\n         XC    DECSDECB,DECSDECB\n         MVI   DECTYPE1,0\n         STC   R5,DECTYPE2\n         ST    R8,DECDCBAD\n         ST    R3,DECAREA\n         ST    R4,DECRECPT\n         L     R15,DCBREAD OR DCBWRITE\n         BALR  R14,R15             * READ - WRITE *\n        CHECK  FDECB\n         TM    DECSDECB+1,X'DE'\n         BZ    SRDWRFIN\n         MVI   FCODE,2\n         B     SRDWRFIN\n         DROP  R1,R8,R9\n         EJECT\n*        CALL  SWRITE (DCBAR,AREA)\n*                     (-----)\n         SPACE 1\n#SWRITE  NULL\n         LA    R5,DECWRSF\n         L     R2,0(R1)\n         BAL   R10,VERIFRW\n         USING FBWAD,R9\n         USING IHADCB,R8\n         CLI   DCBMACF2,DCBMRWRT\n         B     SRDWRSH1\n         SPACE 2\n*        CALL  SREAD (DCBAR,AREA)\n*                    (-----)\n         SPACE 1\n#SREAD   NULL\n         LA    R5,DECRDSF\n         L     R2,0(R1)\n         BAL   R10,VERIFRW\n         CLI   DCBMACF1,DCBMRRD\nSRDWRSH1 BNE   ERR7\n         CLI   FOPTC,1\n         BNE   ERR6\n         LTR   R2,R2\n         BM    SRDWRSH2\n         L     R3,4(R1)\n         LA    R3,0(R3)\n         B     SRDWRSH3\nSRDWRSH2 L     R3,FPARM+4\n         LTR   R3,R3\n         BZ    ERR1\nSRDWRSH3 LA    R1,FDECB\n         USING DECB,R1\n         XC    DECSDECB,DECSDECB\n         MVI   DECTYPE1,0\n         STC   R5,DECTYPE2\n         ST    R8,DECDCBAD\n         ST    R3,DECAREA\n         L     R15,DCBREAD OR DCBWRITE\n         BALR  R14,R15             * READ - WRITE *\n        CHECK  FDECB\n         EJECT\nSRDWRFIN NULL                      COMMON EXIT FROM READ - WRITE.\n         SR    R0,R0\n         IC    R0,FCODE\n         L     R3,FPARM\n         LTR   R3,R3\n         BNZ   SRDWREX1\n         CLI   FCODE,2\n         BH    ERR8\n         BE    ERR9\n         B     RETURN\nSRDWREX1 LTR   R0,R0\n         BNZ   SRDWREX2\n         LA    R0,1\nSRDWREX2 ST    R0,0(R3)\n         B     RETURN\n         DROP  R1,R8,R9\n         EJECT\n*        CALL  BACKSP (DCBAR,N)\n*                     (-----)\n         SPACE 1\n#BACKSP  NULL\n         OI    SWCTL+1,ON\n         L     R2,0(R1)\n         BAL   R10,VERIFRW\n         USING FBWAD,R9\n         CLI   FOPTC,1\n         BNE   ERR6\n         LTR   R2,R2\n         BM    BACKSP1\n         TM    7(R1),X'03'\n         BNZ   ERR1\n         L     R3,4(R1)\n         L     R3,0(R3)\n         LTR   R3,R3\n         BP    BACKSP2\n         B     RETURN\nBACKSP1  LA    R3,1\nBACKSP2 BSP    (R8)\n         BCT   R3,BACKSP2\n         B     RETURN\n         DROP  R9\n         EJECT\n*        CALL  TCLOSE (DCBAR1,IOPT1,DCBAR2,IOPT2,...,...)\n*        CALL  SCLOSE (DCBAR1,IOPT1,DCBAR2,IOPT2,...,...)\n*                     (------,-----)\n         SPACE 1\n#TCLOSE  NULL\n         LPR   R6,R1\n         B     SCLOSE1\n         SPACE 1\n#SCLOSE  NULL\n         SR    R6,R6\nSCLOSE1  OI    SWCTL+1,ON\n         LR    R3,R1\nSCLOSE2  L     R2,0(R3)\n         L     R4,4(R3)\n         LTR   R2,R2\n         BM    ERR1\n         TM    7(R3),X'03'\n         BNZ   ERR1\n         BAL   R10,VERIFRW\n         USING FBWAD,R9\n         LA    R1,FLIST\n         ST    R8,0(R1)\n         L     R5,0(R4)\n         STC   R5,0(R1)\n         OI    0(R1),X'80'\n         LTR   R6,R6\n         BNZ   TCLOSE1\n        CLOSE  MF=(E,(1))\n         BAL   R10,LIBERE\nSCLOSE3  LA    R3,8(R3)\n         LTR   R4,R4\n         BNM   SCLOSE2\n         B     RETURN\nTCLOSE1  CLI   FOPTC,1\n         BNE   ERR6\n        CLOSE  MF=(E,(1)),TYPE=T\n         B     SCLOSE3\n         DROP  R9\n         EJECT\n*        CALL  DCLOSE (DCBAR1,DCBAR2,...,...)\n*                     (------)\n         SPACE 1\n#DCLOSE  NULL\n         OI    SWCTL+1,ON\n         LR    R3,R1\nDCLOSE1  L     R2,0(R3)\n         LR    R4,R2\n         BAL   R10,VERIFRW\n         USING FBWAD,R9\n         LA    R1,FLIST\n         ST    R8,0(R1)\n         MVI   0(R1),X'80'\n        CLOSE  MF=(E,(1))\n         BAL   R10,LIBERE\n         LA    R3,4(R3)\n         LTR   R4,R4\n         BNL   DCLOSE1\n         B     RETURN\n         DROP  R9\n         SPACE 2\n*        CALL  CLOSAL\n         SPACE 1\n#CLOSAL  NULL\nCLOSAL1  L     R9,CHAIN\n         LTR   R9,R9\n         BZR   R6\n         USING FBWAD,R9\n         LA    R8,FDCB\n         USING IHADCB,R8\n         TM    DCBOFLGS,DCBOFOPN\n         BZ    CLOSAL2\n         DROP  R8\n         LA    R1,FLIST\n         ST    R8,0(R1)\n         MVI   0(R1),X'80'\n        CLOSE  MF=(E,(1))\nCLOSAL2  BAL   R10,LIBERE\n         B     CLOSAL1\n         DROP  R9\n         B     RETURN\n         EJECT\nVERIFOP  NULL\n         LM    R2,R4,0(R1)\n         LTR   R2,R2\n         BM    ERR1\n         TM    7(R1),X'03'\n         BNZ   ERR1\n         LA    R9,CHAIN\nVERIFOP1 LR    R8,R9\n         USING FBWAD,R8\n         L     R9,FPTR\n         DROP  R8\n         USING FBWAD,R9\n         LTR   R9,R9\n         BZ    VERIFOP2\n         CLC   FDDNM(L'FDDNM),0(R2)\n         BNE   VERIFOP1\n         B     ERR3\n         DROP  R9\nVERIFOP2 ST    R1,SVREG            SAVE R1 AROUND SUPERVISOR CALL.\n         OC    ATIOT(L'ATIOT),ATIOT FIRST TIME?\n         BNZ   VERIFOP3            BRANCH IF NOT.\n        EXTRACT ATIOT,'S',FIELDS=(TIOT)\nVERIFOP3 L      R9,ATIOT\n         USING  TIODSECT,R9\n         SR     R1,R1\nVERIFOP4 CLC    TIOELNGH(4),ZEROS  SEARCH DD-CARD.\n         BE     ERR3               NOT FOUND.\n         CLC    TIOEDDNM(L'TIOEDDNM),0(R2)\n         BE     VERIFOP5\n         IC     R1,TIOELNGH\n         ALR    R9,R1\n         B      VERIFOP4\n         DROP   R9\nVERIFOP5 GETMAIN R,LV=FBWAL\n         LR    R9,R1\n         USING FBWAD,R8\n         ST    R9,FPTR\n         DROP  R8\n         USING FBWAD,R9\n         XC    FPTR(F1STL),FPTR\n         XC    FDCB(F2NDL),FDCB\n         XC    FDCB+F2NDL(F2NDL),FDCB+F2NDL\n         MVC   FDDNM(L'FDDNM),0(R2)\n         ST    R9,0(R3)\n         LA    R8,FDCB\n         L     R1,SVREG            RESTORE R1 (PARM. LIST POINTER).\n         BR    R10\n         DROP  R9\n         SPACE 2\nVERIFRW  NULL\n         L     R8,0(R2)\n         L     R9,CHAIN\n         USING FBWAD,R9\nVERIFRW1 LTR   R9,R9\n         BZ    ERR4\n         CLR   R8,R9\n         BE    VERIFRW2\n         L     R9,FPTR\n         B     VERIFRW1\nVERIFRW2 MVI   FCODE,0\n         LA    R8,FDCB\nSWCTL    NOPR  R10\n         L     R7,FPARM\n         LTR   R7,R7\n         BZR   R10\n         L     R7,0(R7)\n         LA    R0,1\n         CR    R7,R0\n         BER   R10\n         B     ERR5\n         DROP  R9\n         EJECT\nLIBERE   NULL\n         LA    R8,CHAIN\n         USING FBWAD,R8\nLIBERE1  CL    R9,FPTR\n         BE    LIBERE2\n         L     R8,FPTR\n         LTR   R8,R8\n         BNZ   LIBERE1\n         B     ERR4\n         DROP  R8\n         USING FBWAD,R9\nLIBERE2  MVC   0(L'FPTR,R8),FPTR\n         DROP  R9\n         LR    R1,R9\n        FREEMAIN R,A=(1),LV=FBWAL\n         BR    R10\n         EJECT\nERR1     BCTR  R12,0     CALLING SEQUENCE, ARGUMENT ERROR OR MISSING.\nERR2     BCTR  R12,0     OPEN(DCB) ERROR OR INVALID OPTION(SOPEN).\nERR3     BCTR  R12,0     FILE ALREADY OPENED OR DD-CARD MISSING.\nERR4     BCTR  R12,0     FILE DOES NOT EXIST.\nERR5     BCTR  R12,0     ISPEC IS NOT 1.\nERR6     BCTR  R12,0     INVALID OPERATION REQUESTED.\nERR7     BCTR  R12,0     DCB(PS OR DA) PROBABLY DESTROYED.\nERR8     BCTR  R12,0     ISPEC GREATER THAN 2(ARGUMENT NOT SUPPLIED).\nERR9     BCTR  R12,0     ISPEC EQUAL TO 2(ARGUMENT NOT SUPPLIED).\n         SPACE 1\nMAXERR   EQU   ((*-ERR1)/2)+1\n         SPACE 1\n*        THE REGISTER 12 NOW CONTAINS THE C.C. IN THE\n*        FORMAT X'00RRRNNN', WHERE :\n*\n*              RRR - IS THE ROUTINE INDICATOR NUMBER.\n*              NNN - IS THE ERROR NUMBER.\n         SPACE 1\n         OC    ATIOT(L'ATIOT),ATIOT FIRST TIME?\n         BNZ   ABND1               BRANCH IF NOT.\n        EXTRACT ATIOT,'S',FIELDS=(TIOT)\nABND1    L     R6,ATIOT            SEARCH SYSUDUMP OR SYSABEND.\n         USING TIODSECT,R6\n         SR    R1,R1\nABND2    CLC   TIOELNGH(4),ZEROS\n         BE    ABND3               DD-CARD MISSING.\n         CLC   TIOEDDNM(L'TIOEDDNM),DDDUMP\n         BE    ABND4\n         CLC   TIOEDDNM(L'TIOEDDNM),DDABND\n         BE    ABND4\n         IC    R1,TIOELNGH\n         ALR   R6,R1\n         B     ABND2\n         DROP  R6\n         EJECT\nABND3    ST    R12,SVREG           TRACE R12.\n         UNPK  ABW+8(9),SVREG(5)\n         TR    ABW+8(8),TRTAB\n         MVI   ABW+16,C'.'\n        WTO    MF=(E,ABW)\n         SPACE 1\nABND4   ABEND  1,DUMP\n         SPACE 2\nRETURN  $XRET  CC=0\n         EJECT\n         USING FBWAD,R9\n         SPACE 2\nCRERROUT NULL\n         USING *,R15\n         MVI   FCODE,3\n         MVI   SYNAD1,X'05'        SET ACCESS METHOD CODE (BISAM).\n         B     SYNAD\n         DROP  R15\n         SPACE 2\nIERROUTI NULL\n         USING *,R15\n         USING DECB,R1\n         TM    DECBEXC1,DECEXRNF+DECEXUBK\n         BNZ   IERR1\n         MVI   FCODE,2             SET ERROR CODE FOR ISPEC.\n         B     IERR3\nIERR1    TM    DECBEXC1,DECEXUBK   TEST IF UNREACHABLE RECORD,\n         BZ    IERR2               BRANCH IF RECORD NOT FOUND.\n         MVI   FCODE,3             SET ERROR CODE FOR ISPEC.\n         B     IERR3\nIERR2    MVI   FCODE,4             SET ERROR CODE FOR ISPEC.\nIERR3    MVI   SYNAD1,X'05'        SET ACCESS METHOD CODE (BISAM).\n         B     SYNAD\n         DROP  R1\n         DROP  R15\n         SPACE 2\nDEROUTI  NULL\n         USING *,R15\n         MVI   FCODE,2             SET ERROR CODE FOR ISPEC.\n         MVI   SYNAD1,X'04'        SET ACCESS METHOD CODE (BDAM).\n         B     SYNAD\n         DROP  R15\n         SPACE 2\nSERROUTI NULL\n         USING *,R15\n         MVI   FCODE,2             SET ERROR CODE FOR ISPEC.\n         MVI   SYNAD1,X'02'        SET ACCESS METHOD CODE (BSAM).\n         DROP  R15\n         EJECT\nSYNAD    DS    0H\n         BALR  R15,0\n         USING *,R15\nSYNAD0   ST    R10,SVREG           SAVE REG. 10.\n         LR    R10,R15             R10 = BASE REG.\n         DROP  R15\n         USING SYNAD0,R10\n        SYNADAF    ACSMETH=BSAM ,BDAM OR BISAM.\nSYNAD1   EQU   *-6\n         CLI   69(R1),C'*'         TEST UNSIGNIFICANT MESSAGE,\n         BE    SYNAD4              BRANCH IF YES.\n         CLI   8(R1),C' '          TEST IF BINARY INFORMATIONS,\n         BE    SYNAD2              BRANCH IF NOT.\n         UNPK  56(7,R1),9(4,R1)\n         TR    56(6,R1),TRTAB\n         MVI   62(R1),C','\n         UNPK  63(5,R1),12(3,R1)\n         TR    63(4,R1),TRTAB\n         MVI   67(R1),C','\n         B     SYNAD3\nSYNAD2   MVC   56(12,R1),8(R1)     MOVE BLANKS.\nSYNAD3   LA    R1,52(R1)           SET PARM ADDRESS FOR WTO.\n         MVC   0(4,R1),LWTO        SET PARM FOR WTO.\n         MVC   76(4,R1),RWTO\n        WTO    MF=(E,(1))\nSYNAD4   DS    0H\n        SYNADRLS\n         L     R10,SVREG           RESTORE REG. 10.\n         BR    R14                 RETURN.\n         DROP  R10\n         SPACE 2\nSENDATA  NULL\n         USING *,R15\n         MVI   FCODE,3\n         BR    R14\n         DROP  R15\n         SPACE 2\n         DROP  R9\n         EJECT\n*        DCB'S SKELETONS.\n         SPACE 1\nCRDCB    DCB   BFALN=D,DSORG=IS,EODAD=SENDATA,MACRF=(PM),              C\n               SYNAD=CRERROUT,DDNAME=XXXXXXXX\n         SPACE 1\nLDCBCR   EQU   *-CRDCB\n         SPACE 2\nRDDCB    DCB   BFALN=D,DSORG=IS,EODAD=SENDATA,MACRF=(GM,SK),           C\n               SYNAD=CRERROUT,DDNAME=XXXXXXXX\n         SPACE 1\nLDCBRD   EQU   *-RDDCB\n         SPACE 2\nDCBI     DCB   BFALN=D,DSORG=IS,MACRF=(RUC,WUAC),NCP=1,BUFNO=1,        C\n               SYNAD=IERROUTI,DDNAME=XXXXXXXX\n         SPACE 1\nLDCBI    EQU   *-DCBI\n         SPACE 2\nDCBD     DCB   BFALN=D,BFTEK=S,DSORG=DA,KEYLEN=0,LIMCT=1,              C\n               MACRF=(RIC,WIC),OPTCD=R,RECFM=F,                        C\n               SYNAD=DEROUTI,DDNAME=XXXXXXXX\n         SPACE 1\nLDCBD    EQU   *-DCBD\n         SPACE 2\nDCBS     DCB   BFALN=D,DEVD=DA,DSORG=PS,EODAD=SENDATA,MACRF=(R,W),     C\n               SYNAD=SERROUTI,DDNAME=XXXXXXXX\n         SPACE 1\nLDCBS    EQU   *-DCBS\n         SPACE 2\n*        CONSTANTS AND WORK-AREAS.\n         SPACE 1\nCHAIN    DC    A(*-*)\n         SPACE 1\nATIOT    DC    A(*-*)\nSVREG    DC    F'0'\nZEROS    DC    F'0'\nDDDUMP   DC    CL8'SYSUDUMP'\nDDABND   DC    CL8'SYSABEND'\nABW     WTO    'R12=        . DUMP DD-CARD MISSING.',                  C\n               ROUTCDE=11,DESC=7,MF=L\nLWTO     DC    AL2(76),XL2'8000'   WTO : TEXT LENGTH, MCS FLAGS.\nRWTO     DC    XL2'0200',XL2'0020' WTO : DESC=7, ROUTCDE=11.\nTRTAB    EQU   *-C'0'\n         DC    C'0123456789ABCDEF'\n         SPACE 2\n        PRINT  NOGEN\n         SPACE 1\n        IHADECB\nTIODSECT DSECT\n        IEFTIOT1\n        DCBD   DSORG=(PS,DA,IS),DEVD=DA\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IOPACK$": {"ttr": 10502, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x942\\x7f\\x00\\x942\\x7f\\x14#\\x00\\x08\\x00\\x08\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-23T00:00:00", "modifydate": "1994-11-23T14:23:00", "lines": 8, "newlines": 8, "modlines": 0, "user": "SYSPAJA"}, "text": "//IOPACK   JOB (........),'INSTALL  - IOPACK -',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=800K,TIME=1\n/*JOBPARM L=5\n//ASS     EXEC PAJ1AS3,MBR=IOPACK\n//LNK     EXEC PAJILKR\n//SYSIN     DD *\n  NAME    IOPACK(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IOPACK@": {"ttr": 10504, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x10O\\x00\\x88\\x10O\\x14R\\x02\\x08\\x02\\x08\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-04-13T00:00:00", "modifydate": "1988-04-13T14:52:00", "lines": 520, "newlines": 520, "modlines": 0, "user": "SYSPAJA"}, "text": "1   13/04/88\n                                                      IOPACK    1/12.\n\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *        I/O PACKAGE ROUTINES         * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n\n  Purpose :    Help users to manage files of the three basic access\n  =========    methods types available in O.S. : PS, DA and IS.\n               At user program link-edit step, it must be inserted by\n               an INCLUDE ...(IOPACK) statement.\n\n\n  1. DSORG=PS :\n  =============\n\n    CALL SOPEN (DDNAME,DCBAR,IOPT,ISPEC,AREA)\n               (------,-----,----,-----)\n               (------,-----,----)\n\n              DDNAME : an 8 bytes length variable containing the\n                       DD-name of the DD-card relative to the file\n                       to be open.\n              DCBAR : a fullword variable used by the package, his\n                       contents must never be modified by the program\n                       during the file is active (until closed).\n              IOPT : a fullword variable which indicates the following\n                       open options :\n                           INPUT    0          DISP     0\n                           INOUT    3          REREAD  16\n                           OUTIN    7          LEAVE   48\n                           OUTPUT  15\n                       A value must be selected in each column and the\n                       sum placed in this variable.\n                           INPUT   means only read.\n                           INOUT   means read then write.\n                           OUTIN   means write then read.\n                           OUTPUT  means write only.\n                           DISP    means apply the disposition ceded\n                                         in the DD-card.\n                           REREAD  means the file must be positioned\n                                         at the beginning.\n                           LEAVE   means the file remains at the point\n                                         it is actually positioned.\n1   23/09/85\n                                                      IOPACK    2/12.\n\n\n              ISPEC : a fullword response variable. This argument is\n                       optional, but if supplied, it must contain the\n                       value 1 before any read or write request. After\n                       the operation, it can contain the following\n                       value :\n                         1 - operation correctly executed.\n                         2 - an error has been detected.\n                         3 - the END-OF-FILE has been encountered.\n                       If this argument is not supplied, and an error\n                       or the END-OF-FILE condition is detected, the\n                       program execution is terminated.\n              AREA : array for read or write operations. The argument\n                       is optional, but if supplied, it will be used\n                       as default in case it is omitted at the time\n                       an operation is requested (SREAD or SWRITE).\n\n    CALL SREAD (DCBAR,AREA)\n               (-----)\n\n              DCBAR : the SOPEN variable used by the package, his\n                       contents must never be modified by the program\n                       during the file is active (until closed).\n              AREA : array where a record is read. The argument is\n                       mandatory if not supplied by SOPEN. If present,\n                       it is used for read even if also supplied in\n                       SOPEN.\n\n    CALL SWRITE (DCBAR,AREA)\n                (-----)\n\n              DCBAR : the SOPEN variable used by the package, his\n                       contents must never be modified by the program\n                       during the file is active (until closed).\n              AREA : array containing the record to write. The argument\n                       is mandatory if not supplied by SOPEN. If\n                       present, it is used for write even if also\n                       supplied in SOPEN.\n\n    CALL BACKSP (DCBAR,N)\n                (-----)\n\n              DCBAR : the SOPEN variable used by the package, his\n                       contents must never be modified by the program\n                       during the file is active (until closed).\n              N : a fullword variable containing the number of desired\n                       backspaces (physical records blocks) to be\n                       executed. If N is omitted, the default value is\n                       one. If N is negative or zero, the operation is\n                       bypassed. After the END-OF-FILE, the backspace\n                       is not allowed.\n1   23/09/85\n                                                      IOPACK    3/12.\n\n\n  2. DSORG=DA :\n  =============\n\n    Preliminary advice : a DSORG=DA file should be created using\n    -------------------- the SOPEN, SWRITE and SCLOSE routines. No\n                         records can be added to the file after his\n                         creation, but they can be only read or\n                         updated. The processing of files with keys\n                         is possible, but the keys are unaccessible,\n                         and the records can be retrieved only by\n                         their sequential number of order in the file.\n                         The creation of files with keys are not\n                         possible with this I/O package routines.\n\n    CALL DOPEN (DDNAME,DCBAR,ISPEC,NREC,AREA)\n               (------,-----,-----,----)\n               (------,-----,-----)\n               (------,-----)\n\n              DDNAME : an 8 bytes length variable containing the\n                       DD-name of the DD-card relative to the file\n                       to be open.\n              DCBAR : a fullword variable used by the package, his\n                       contents must never be modified by the program\n                       during the file is active (until closed).\n              ISPEC : a fullword response variable (see SOPEN).\n              NREC : a fullword variable to be used at read or write\n                       requests (DREAD or DWRITE). The argument is\n                       optional, but if supplied, it will be used as\n                       default in case it is omitted at the time of\n                       the operation.\n              AREA : array for read or write operations. The argument\n                       is optional, but if supplied, it will be used\n                       as default in case it is omitted at the time\n                       an operation is requested (DREAD or DWRITE).\n1   23/09/85\n                                                      IOPACK    4/12.\n\n\n    CALL DREAD (DCBAR,NREC,AREA)\n               (-----,----)\n               (-----)\n\n              DCBAR : the DOPEN variable used by the package, his\n                       contents must never be modified by the program\n                       during the file is active (until closed).\n              NREC : a fullword variable containing the record number\n                       to be read (the file starts with the record\n                       number zero). The argument is mandatory if not\n                       supplied by DOPEN. If present, it is used for\n                       read even if also supplied in DOPEN.\n              AREA : array where a record is read. The argument is\n                       mandatory if not supplied by DOPEN. If present,\n                       it is used for read even if also supplied in\n                       DOPEN.\n\n    CALL DWRITE (DCBAR,NREC,AREA)\n                (-----,----)\n                (-----)\n\n              DCBAR : the DOPEN variable used by the package, his\n                       contents must never be modified by the program\n                       during the file is active (until closed).\n              NREC : a fullword variable containing the record number\n                       to write (the file starts with the record\n                       number zero). The argument is mandatory if not\n                       supplied by DOPEN. If present, it is used for\n                       write even if also supplied in DOPEN.\n              AREA : array containing the record to write. The argument\n                       is mandatory if not supplied by DOPEN. If\n                       present, it is used for write even if also\n                       supplied in DOPEN.\n1   23/09/85\n                                                      IOPACK    5/12.\n\n\n  3. DSORG=IS :\n  =============\n\n  A. Create and read aequentially the file.\n  -----------------------------------------\n\n    Preliminary advice : a DSORG=IS file should be created in a\n    -------------------- sequential way (by ascending keys order).\n                         Dummy records can be inserted at the file\n                         creation to prepare space for further adds\n                         or updates. A dummy record is a record\n                         having as first byte the hexadecimal value\n                         X'FF' (see Data Management manual).\n\n    CALL CROPEN (DDNAME,DCBAR,RKP,ISPEC,AREA)\n                (------,-----,---,-----)\n                (------,-----,---)\n\n              DDNAME : an 8 bytes length variable containing the\n                       DD-name of the DD-card relative to the file\n                       to be open.\n              DCBAR : a fullword variable used by the package, his\n                       contents must never be modified by the program\n                       during the file is active (until closed).\n              RKP : a fullword variable containing the relative key\n                       position in the record (don't use 0, zero, if\n                       you want to have dummy records in the file).\n              ISPEC : a fullword response variable (see SOPEN).\n              AREA : array for write operations. The argument is\n                       optional, but if supplied, it will be used\n                       as default in case it is omitted at the time\n                       an operation is requested (CRWRIT).\n\n    CALL CRWRIT (DCBAR,AREA)\n                (-----)\n\n              DCBAR : the CROPEN variable used by the package, his\n                       contemts must never be modified by the program\n                       during the file is active (until closed).\n              AREA : array containing the record to write. The argument\n                       is mandatory if not supplied by CROPEN. If\n                       present, it is used for write even if also\n                       supplied in CROPEN.\n1   23/08/85\n                                                      IOPACK    6/12.\n\n\n    CALL RDOPEN (DDNAME,DCBAR,ISPEC,AREA)\n                (------,-----,-----)\n                (------,-----)\n\n              DDNAME : an 8 bytes length variable containing the\n                       DD-name of the DD-card relative to the file\n                       to be open.\n              DCBAR : a fullword variable used by the package, his\n                       contents must never be modified by the program\n                       during the file is active (until closed).\n              ISPEC : a fullword response variable (see SOPEN).\n              AREA : array for read operations. The argument is\n                       optional, but if supplied, it will be used\n                       as default in case it is omitted at the time\n                       an operation is requested (REREAD).\n\n    CALL REREAD (DCBAR,AREA)\n                (-----)\n\n              DCBAR : the RDOPEN variable used by the package, his\n                       contents must never be modified by the program\n                       during the file is active (until closed).\n              AREA : array where a record is read. The argument is\n                       mandatory if not supplied by RDOPEN. If present,\n                       it is used for read even if also supplied in\n                       RDOPEN. The record contains the key and the data\n                       portions.\n\n    CALL SETL (DCBAR,KEY)\n              (-----)\n\n              DCBAR : the RDOPEN variable used by the program, his\n                       contents must never be modified by the program\n                       during the file is active (until closed).\n              KEY : array containing the key to be retrieved. The\n                       argument is optional, if omitted, the file is\n                       positioned at the beginning. This call is used\n                       to position the file in the way that the next\n                       call to REREAD will obtain the record having\n                       the key equal. Note that the successive values\n                       of key must be in ascending order, and two calls\n                       to SETL must be separated by a call to ESETL.\n1   23/09/85\n                                                      IOPACK    7/12.\n\n\n    CALL ESETL (DCBAR)\n               (-----)\n\n              DCBAR : the RDOPEN variable used by the package, his\n                       contents must never be modified by the program\n                       during the file is active (until closed).\n\n  B. Adds and updates to the file.\n  --------------------------------\n\n    Preliminary advice : the following routines always gives back,\n    -------------------- if existing, the record having the key equal\n                         to that requested. It is user responsability\n                         to recognize a dummy record, and perhaps\n                         modify it in a true record by changing the\n                         first byte from the hexadecimal value X'FF'\n                         (see Data Management manual).\n\n    CALL IOPEN (DDNAME,DCBAR,MSHI,LMSH,MSWA,LMSW,ISPEC,KEY,AREA)\n               (------,-----,----,----,----,----,-----,---)\n               (------,-----,----,----,----,----,-----)\n               (------,-----,----,----,----,----)\n\n              DDNAME : an 8 bytes length variable containing the\n                       DD-name of the DD-card relative to the file\n                       to be open.\n              DCBAR : a fullword variable used by the package, his\n                       contents must never be modified by the program\n                       during the file is active (until closed).\n              MSHI : array to read in the file dictionary (see SMSI).\n              LMSH : a fullword variable containing the length (in\n                       bytes) of MSHI array. If the length value is\n                       0 (zero), the array is considered unexistant.\n                       Program execution degradation occurs when this\n                       array is not supplied, we suggest the user to\n                       define it as large as a track capacity of the\n                       device supporting the file.\n              MSWA : array which must be large enough to contain one\n                       track capacity of the device supporting the\n                       file, plus one record and his key (see SMSW).\n              LMSW : a fullword variable containing the length (in\n                       bytes) of MSWA array. If the length value is\n                       0 (zero), the array is considered unexistant,\n                       and consequently program degradation occurs.\n1   23/09/85\n                                                      IOPACK    8/12.\n\n\n              ISPEC : a fullword response variable. This argument is\n                       optional, but if supplied, it must contain the\n                       value 1 before any read or write request. After\n                       the operation, it can contain the following\n                       value :\n                         1 - operation correctly executed.\n                         2 - an error has been detected.\n                         3 - the requested record is out of file\n                             boundaries.\n                         4 - the requested record is not found.\n                       If this argument is not supplied, and the error\n                       condition 2, 3 or 4 is detected, the program\n                       execution is terminated.\n              KEY : a fullword variable to be used at read or write\n                       requests (IREAD, IREADU, IWRITE or REWRIT)\n                       and containing the search key. The argument is\n                       optional, but if supplied, it will be used as\n                       default in case it is omitted at the time of\n                       the operation.\n              AREA : array for read or write operations. The argument\n                       is optional, but if supplied, it will be used\n                       as default in case it is omitted at the time\n                       an operation is requested (IREAD, IREADU,\n                       IWRITE or REWRIT). This array must be four (4)\n                       fullwords larger than the record length to be\n                       read or write. The record effectively starts in\n                       position 17th of the array (5th fullword).\n\n    CALL IREAD (DCBAR,KEY,AREA)\n               (-----,---)\n               (-----)\n\n              DCBAR : the IOPEN variable used by the package, his\n                       contents must never be modified by the program\n                       during the file is active (until closed).\n              KEY : a fullword variable containing the key of the\n                       record to read. The argument is mandatory if\n                       not supplied by IOPEN. If present, it is used\n                       for read even if also supplied in IOPEN.\n              AREA : array where a record is read (see IOPEN). The\n                       argument is mandatory if not supplied by IOPEN.\n                       If present, it is used for read even if also\n                       supplied in IOPEN.\n1   23/09/85\n                                                      IOPACK    9/12.\n\n\n    CALL IREADU (DCBAR,KEY,AREA)\n                (-----,---)\n                (-----)\n\n              DCBAR : the IOPEN variable used by the package, his\n                       contents must never be modified by the program\n                       during the file is active (until closed).\n              KEY : a fullword variable containing the key of the\n                       record to read. The argument is mandatory if\n                       not supplied by IOPEN. If present, it is used\n                       for read even if also supplied in IOPEN.\n              AREA : array where a record is read (see IOPEN). The\n                       argument is mandatory if not supplied by IOPEN.\n                       If present, it is used for read even if also\n                       supplied in IOPEN. Any record read by this call\n                       must be succesively written back for updating\n                       by a call to REWRIT as the next file operation.\n\n    CALL IWRITE (DCBAR,KEY,AREA)\n                (-----,---)\n                (-----)\n\n              DCBAR : the IOPEN variable used by the package, his\n                       contents must never be modified by the program\n                       during the file is active (until closed).\n              KEY : a fullword variable containing the key of the\n                       record to write. The argument is mandatory if\n                       not supplied by IOPEN. If present, it is used\n                       for write even if also supplied in IOPEN.\n              AREA : array containing the record to write (see IOPEN).\n                       The argument is mandatory if not supplied by\n                       IOPEN. If present, it is used for write even\n                       if also supplied in IOPEN. This call is used to\n                       write a new record in the file.\n1   23/09/85\n                                                      IOPACK    10/12.\n\n\n    CALL REWRIT (DCBAR,KEY,AREA)\n                (-----,---)\n                (-----)\n\n              DCBAR : the IOPEN variable used by the package, his\n                       contents must never be modified by the program\n                       during the file is active (until closed).\n              KEY : a fullword variable containing the key of the\n                       record to write. The argument is mandatory if\n                       not supplied by IOPEN. If present, it is used\n                       for write even if also supplied in IOPEN.\n              AREA : array containing the record to write (see IOPEN).\n                       The argument is mandatory if not supplied by\n                       IOPEN. If present, it is used for write even\n                       if also supplied in IOPEN. This call is used to\n                       write back the updated record read with the call\n                       to IREADU (see IREADU).\n\n1   23/09/85\n                                                      IOPACK    11/12.\n\n  4. Close files :\n  ================\n\n    CALL SCLOSE (DCBAR1,IOPT1,DCBAR2,IOPT2,...,...)\n                (------,-----)\n\n              DCBAR- : the open fullword variable used by the package,\n                       it refers to the desired file to close.\n              IOPT- : a fullword variable which contains a value\n                       indicating the desired close option as below :\n                           128 - DISP    means apply the disposition\n                                               coded in the DD-card.\n                           144 - REREAD  means the file must be\n                                               positioned at the\n                                               beginning (only PS).\n                           176 - LEAVE   means the file remains at the\n                                               point it is actually\n                                               positioned (only PS).\n\n    CALL TCLOSE (DCBAR1,IOPT1,DCBAR2,IOPT2,...,...)\n                (------,-----)\n\n              DCBAR- : the open fullword variable used by the package,\n                       it refers to the desired file to close.\n              IOPT- : a fullword variable which contains a value\n                       indicating the close option (see SCLOSE).\n                       This call applies only to PS files, and allows\n                       restart of read and/or write operations without\n                       calling again SOPEN.\n\n    CALL DCLOSE (DCBAR1,DCBAR2,...,...)\n                (------)\n\n              DCBAR- : the open fullword variable used by the package,\n                       it refers to the desired file to close. This\n                       call is equivalent to call SCLOSE with the IOPT\n                       argument value of 128 (DISP).\n\n    CALL CLOSAL\n\n              Close all existing files.\n1   23/09/85\n                                                      IOPACK    12/12.\n\n\n  Errors detection : when an error is detected by a routine of this\n  ================== package, the program execution is terminated by\n                     an abend U0001 with dump if a SYSUDUMP or SYSABEND\n                     DD-card is supplied (when missing, a message is\n                     sended in the message class for the job).\n                     At the time of abend, the register 12 contains the\n                     error condition code in the format X'00RRRNNN',\n                     where :\n                        RRR - is the routine indicator number.\n                        NNN - is the error number.\n\n    Routine number (RRR) :  001 = CROPEN\n    ----------------------  002 = RDOPEN\n                            003 = IOPEN\n                            004 = DOPEN\n                            005 = SOPEN\n                            006 = CRWRIT\n                            007 = SETL\n                            008 = ESETL\n                            009 = REREAD\n                            00A = IWRITE\n                            00B = IREAD\n                            00C = REWRIT\n                            00D = IREADU\n                            00E = DWRITE\n                            00F = DREAD\n                            010 = SWRITE\n                            011 = SREAD\n                            012 = BACKSP\n                            013 = TCLOSE\n                            014 = SCLOSE\n                            015 = DCLOSE\n                            016 = CLOSAL\n\n    Error number (NNN) :\n    --------------------\n\n         001 = calling sequence, argument error or missing.\n         002 = open (DCB) error or invalid option (SOPEN).\n         003 = file already opened or DD-card missing.\n         004 = file does not exist.\n         005 = ISPEC is not 1.\n         006 = invalid operation requested.\n         007 = DCB (PS or DA) probably destroyed.\n         008 = ISPEC greater than 2 (argument not supplied).\n         009 = ISPEC equal to 2 (argument not supplied).\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RECOVER": {"ttr": 10757, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x882o\\x00\\x882o\\x175\\x01Y\\x01Y\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-11-21T00:00:00", "modifydate": "1988-11-21T17:35:00", "lines": 345, "newlines": 345, "modlines": 0, "user": "SYSPAJA"}, "text": "RCVR     TITLE 'SERVICE AIDS - RECOVER DATA-SETS.'\nRECOVER  START 0\n         SPACE 1\n*********************************************************************\n*** ALTHOUGH THIS PROGRAM HAS BEEN TESTED BY ITS AUTHOR AND IS IN ***\n*** USE AT THE UNIVERSITY OF WATERLOO, NO WARRANTY, EXPRESSED OR  ***\n*** IMPLIED, IS MADE AS TO THE ACCURACY OR FUNCTIONING OF THE     ***\n*** PROGRAM AND RELATED MATERIAL. THERE IS NO COMMITED MAINTENANCE***\n*** OF THE PROGRAM. THE FACT OF DISTRIBUTION SHALL NOT CONSTITUTE ***\n*** ANY WARRANTY AND NO RESPONSIBILITY IS ASSUMED BY THE AUTHOR   ***\n*** NOR THE UNIVERSITY OF WATERLOO IN CONNECTION HEREWITH.        ***\n*********************************************************************\n         SPACE 2\nRECOVER AMODE  24\nRECOVER RMODE  24\n         EJECT\n* SERVICE AIDS : RECOVER\n* --------------\n*\n*     PURPOSE :      THIS PROGRAM ATTEMPTS TO RECOVER DATA-SETS\n*                    THAT HAVE BECOME UNUSABLE DUE TO I/O ERRORS\n*                    OR END-OF-FILE MARKS.\n*                    WITH EITHER OF THE ABOVE ONE OR MORE BLOCKS\n*                    MAY BE PERMANENTLY LOST (AT AND IMMEDIATELY\n*                    FOLLOWING THE CAUSE), BUT THE REST CAN STILL\n*                    BE RECOVERED.\n*                    NO RE-BLOCKING FACILITY IS PROVIDED, AND TO\n*                    AVOID ERRORS, THE OUTPUT DCB IS FILLED WITH\n*                    VALUES TAKEN FROM THE INPUT DCB DURING THE\n*                    OPEN, THUS NO DCB INFORMATION SHOULD BE\n*                    SPECIFIED IN THE JCL (IT WOULD BE IGNORED).\n*\n*     USAGE :        THE FACILITIES PROVIDED IN THE PROGRAM ARE\n*                    SPECIFIED BY THE EXEC PARM AS A SET OF\n*                    KEYWORDS AND VALUES (NO BLANKS) :\n*                    COUNT=N : SPECIFIES THE NUMBER OF I/O ERRORS\n*                          OR END-OF-FILES THE PROGRAM IS TO\n*                          ACCEPT (DEFAULT = 1),\n*                    START=XXXXXXXX - SPECIFIES THE RELATIVE TRACK\n*                          AND RECORD BEYOND THE START OF THE\n*                          DATASET THAT THE RECOVERY IS TO START\n*                          AT, THE VALUE GIVEN IS IN TTRZ FORMAT\n*                          IN HEX (DEFAULT = 00000000),\n*                    POINT=T - SPECIFIES THE TYPE OF SKIP TO BE\n*                          USED WHEN AN I/O ERROR OR END-OF-FILE IS\n*                          ENCOUNTERED, THE VALID TYPES ARE T, R\n*                          OR Z TO CORRESPOND WITH TTRZ (DEFAULT = Z),\n*                    WRITE=S - SPECIFIES WHETHER THE CURRENT BLOCK\n*                          IS TO BE WRITTEN OUT IN THE EVENT OF AN\n*                          I/O ERROR (CONSIDERING THAT THE BLOCK WAS\n*                          PARTIALLY FILLED AT THE TIME OF THE ERROR\n*                          AND THUS MAY YET BE USABLE), THE VALID\n*                          SPECIFICATIONS ARE Y OR N FOR YES OR NO\n*                          (DEFAULT = N).\n*\n*                    ABBREVIATIONS CONSISTING OF THE FIRST CHARACTER\n*                    OF EACH KEYWORD ARE ALLOWED, FURTHER THE COUNT\n*                    VALUE 'N' MAY BE SPECIFIED AS A POSITIONAL\n*                    PARAMETER IF IT IS GIVEN FIRST (THIS ALLOWS\n*                    PARM=N).\n         EJECT\n*                    THE PROGRAM IS DESIGNED TO HANDLE ONLY SEQUENTIAL\n*                    FILES, BUT RECOVERY CAN OBVIOUSLY START AT THE\n*                    BEGINNING OF A SPECIFIC MEMBER OF A PDS AS LONG\n*                    AS IT IS EXPLICITLY STATED IN THE JCL.\n*                    NOTE THAT IN THE CASE OF I/O ERRORS IN THE\n*                    DIRECTORY OF A PDS THE EASIEST METHOD OF\n*                    RECOVERY IS TO START THE COPY FUNCTION AT THE\n*                    BEGINNING OF THE DATASET (IE. POINT THE\n*                    SYSUT1 DD STATEMENT TO THE DATASET ITSELF),\n*                    THIS EFFECTIVELY STARTS THE RECOVERY AT THE\n*                    DIRECTORY - WHICH WILL NOT BE USABLE IN THE\n*                    OUTPUT DATASET. THE OUTPUT DATASET WILL THEN\n*                    BE A SEQUENTIAL CONCATENATION OF ALL THE\n*                    MEMBERS IN THE PDS AND SOME OTHER UTILITY\n*                    PROGRAM OR TSO MAY THEN BE USED TO SELECT\n*                    THE PORTIONS FOR SAVING IN NEW, PERMANENT\n*                    DATASETS.\n*\n*     JCL :          //........ JOB ........\n*                    //RCV     EXEC PGM=RECOVER,PARM='C=5,P=T'\n*                    //SYSUT1   DD  DSN=PDS(BADMEMB),DISP=SHR\n*                    //SYSUT2   DD  DSN=RECOVERD,DISP=SHR\n*\n*                    WILL RESULT IN A TOTAL OF 5 INPUT ERRORS,\n*                    END-OF FILES BEING ACCEPTED WHILE MEMBER\n*                    BADMEMB IS COPIED TO DATASET RECOVERD. AT\n*                    EACH I/O ERROR OR END-OF-FILE THE RELATIVE\n*                    TRACK WILL BE INCREMENTED BEFORE COPYING IS\n*                    CONTINUED. THE RECOVERY OPERATION WILL START\n*                    AT THE BEGINNING OF MEMBER BADMEMB AND THE\n*                    CURRENT BLOCK WILL NOT BE WRITTEN WHEN ERRORS\n*                    OCCUR.\n*\n*     MESSAGES :     MESSAGES FROM THE PROGRAM ARE WRITTEN IN THE\n*                    JOB'S LOG, THE FOLLOWING ARE THE POSSIBLE\n*                    MESSAGES FROM RECOVER :\n*\n*                    **** INVALID EXEC PARM FIELD       ****\n*                    **** MERGED DEFAULTS AND EXEC PARM ****\n*                    **** CANNOT OPEN SYSUT1            **** (1)\n*                    **** CANNOT OPEN SYSUT2            **** (2)\n*                    **** EOF ON SYSUT1 NOTED           ****\n*                    **** INPUT ERROR NOTED             ****\n*                    **** CURRENT BLOCK WRITTEN         ****\n*                    **** OUTPUT ERROR, FATAL           **** (3)\n*                    **** NO. OF BLOCKS WRITTEN = VALUE ****\n*\n*                    AFTER MESSAGES 1, 2 OR 3 THE PROGRAM ISSUES\n*                    AN ABEND REQUESTING A DUMP.\n         EJECT\n        $DEFREG\nOFLGS    EQU   DCBOFLGS-IHADCB\nRECFM    EQU   DCBRECFM-IHADCB\nBLKSI    EQU   DCBBLKSI-IHADCB\nLRECL    EQU   DCBLRECL-IHADCB\n         EJECT\n        $XENT  BASE=R12\n         XR    R8,R8               INITIALIZE: WRITE CODE\n         XR    R9,R9                           INITIAL TTR\n         XR    R10,R10                         POINT METHOD\n         XR    R11,R11                         EOF / IN-ERR COUNT\n         L     R2,0(0,R1)          POINT TO PARM FIELD\n         LH    R3,0(0,R2)          GET ITS LENGTH\n         LTR   R3,R3               TEST IF PARM GIVEN\n         BZ    NOPARM              NO, OMIT PARM PROCESSING\n         LA    R2,2(0,R2)          POINT TO START OF CHAR STRING\n         CLI   0(R2),C'Z'          TEST IF FIRST (ONLY) PARM IS COUNT\n         BH    SETCOUNT            YES, GO PROCESS IT\nPARMLOOP LR    R1,R2               GET PARM STRING INDEX\n         LA    R2,6(0,R2)          POINT BEYOND KEY-WORD\n         S     R3,=F'6'            REDUCE PARM LENGTH VALUE\n         CLC   0(6,R1),=C'COUNT='  TEST FOR COUNT\n         BE    SETCOUNT            EQUAL, GO PROCESS IT\n         CLC   0(6,R1),=C'START='  TEST FOR START\n         BE    SETSTART            EQUAL, GO PROCESS IT\n         CLC   0(6,R1),=C'POINT='  TEST FOR POINT\n         BE    SETPOINT            EQUAL, GO PROCESS IT\n         CLC   0(6,R1),=C'WRITE='  TEST FOR WRITE\n         BE    SETWRITE            EQUAL, GO PROCESS IT\n         LA    R3,4(0,R3)          NOW TRY ABBREVIATED FORMS\n         S     R2,=F'4'            RESET INDEX AND COUNT\n         CLC   0(2,R1),=C'C='      IS IT COUNT ?\n         BE    SETCOUNT            YES,...\n         CLC   0(2,R1),=C'S='      IS IT START ?\n         BE    SETSTART            YES,...\n         CLC   0(2,R1),=C'P='      IS IT POINT ?\n         BE    SETPOINT            YES,...\n         CLC   0(2,R1),=C'W='      IS IT WRITE ?\n         BE    SETWRITE            YES,...\nBADPARM WTO    '**** INVALID EXEC PARM               ****', TELL USER  1\n               ROUTCDE=11,DESC=7\n         B     EXIT                NOT RECOGNISED ......\nSETCOUNT LR    R1,R2               GET START OF NUMBERS\nCNTLOOP  CLI   0(R1),C','          IS IT END OF NUMBERS ?\n         BE    ENDCOUNT            YES, GO PROCESS THEM\n         CLI   0(R1),C'0'          CHECK VALIDITY OF NUMBER\n         BL    BADPARM             NOT NUMERIC .......\n         LA    R1,1(0,R1)          POINT TO NEXT CHAR\n         BCT   R3,CNTLOOP          CONTINUE SCAN\nENDCOUNT SR    R1,R2               GET LENGTH OF NUMBER STRING\n         C     R1,=F'4'            MAX DIGITS ALLOWED = 4\n         BH    BADPARM             TOO MANY .......\n         BCTR  R1,0                REDUCE LENGTH FOR EX MVC'S\n         XC    SCRATCH,SCRATCH     CLEAR SCRATCH AREA\n         LA    R4,SCRATCH+7        POINT TO LAST BYTE OF WORK AREA\n         SR    R4,R1               POINT TO TARGET ADDRESS\n         EX    R1,NUMBMVC          SHIFT NUMBER TO SCRATCH (RIGHT ADJ)\n         MVC   WTLCOUNT+8(4),SCRATCH+4  SHIFT IT TO WTL AREA\n         MVI   WTLCOUNT+12,C','    INSERT COMMA\n         PACK  SCRATCH,SCRATCH     PACK THE CHAR STRING\n         LA    R2,1(R1,R2)         BUMP INDEX PTR\n         CVB   R11,SCRATCH         AND CVB INTO PERMANENT LOC\n         B     NEXTPARM            CONTINUE PARM PROCESSING\nSETSTART LR    R1,R2               POINT TO START OF TTRZ FIELD\nSTRTLOOP CLI   0(R1),C','          END OF TTRZ FIELD ?\n         BE    ENDTTRZ             YES, GO PROCESS IT\n         CLI   0(R1),C'A'          ENSURE VALID HEX DIGIT\n         BL    BADPARM             NOT HEX DIGIT .......\n         LA    R1,1(0,R1)          BUMP INDEX PTR\n         BCT   R3,STRTLOOP         CONTINUE SCAN\nENDTTRZ  SR    R1,R2               GET LENGTH OF STRING\n         C     R1,=F'8'            COMPARE TO NECESSARY = 8\n         BNE   BADPARM             INVALID LENGTH .....\n         MVC   WTLSTART+8(8),0(R2) INSERT INTO WTL FIELD\n         MVC   SCRATCH(8),0(R2)    SHIFT TTRZ TO WORK AREA\n         PACK  SCRATCH+4(5),SCRATCH(9)  PACK INTO RIGHT ADJUST\n         L     R9,SCRATCH+4        LOAD INTO PARAM REG\n         LA    R2,8(0,R2)          POINT TO NEXT PARM\n         B     NEXTPARM            CONTINUE PARM PROCESSING\nSETPOINT LR    R1,R2               GET STRING INDEX\n         MVC   WTLPOINT+8(1),0(R1) SHIFT POINT METHOD TO WTL\n         LA    R2,1(0,R2)          POINT BEYOND IT\n         BCTR  R3,0                REDUCE COUNT\n         LA    R10,TTRZ            GET TTRZ METH ADDR\n         CLI   0(R1),C'Z'          IT THIS THE ONE ?\n         BE    NEXTPARM            YES, GO PROCESS NEXT\n         LA    R10,TTR             GET TTR METH ADDR\n         CLI   0(R1),C'R'          IS THIS THE ONE ?\n         BE    NEXTPARM            YES, GO PROCESS NEXT\n         LA    R10,TT              GET TT METH ADDR\n         CLI   0(R1),C'T'          IS THIS THE ONE ?\n         BE    NEXTPARM            YES, GO PROCESS NEXT\n         B     BADPARM             NOT RECOGNIZED .......\nSETWRITE LR    R1,R2               GET STRG INDEX\n         LA    R2,1(0,R2)          POINT BEYOND CODE\n         BCTR  R3,0                REDUCE COUNT\n         MVC   WTLWRITE+8(1),0(R1) SHIFT CODE TO WTL\n         CLI   0(R1),C'N'          IS CODE NO-WRITE ?\n         BE    NEXTPARM            YES, LEAVE PRESET CODE\n         CLI   0(R1),C'Y'          IS IT WRITE ?\n         BNE   BADPARM             NEITHER, ......\n         LA    R8,255(0,0)         SET CODE = WRITE\nNEXTPARM LA    R2,1(0,R2)          SKIP OVER COMMA\n         BCTR  R3,0                REDUCE COUNT FOR COMMA\n         LTR   R3,R3               IS THERE ANY MORE ?\n         BP    PARMLOOP            YES, CONTINUE PARM PROCESSING\nNOPARM   STC   R8,WRFLAG           SAVE IN-ERR WRITE FLAG\n         ST    R9,SCRATCH          SAVE R9 FOR INITIAL POINT\n         LTR   R11,R11             PARM END, WAS COUNT SET ?\n         BNZ   TRYPOINT            YES, OMIT DEFAULT SET\n         LA    R11,1(0,0)          SET DEFAULT COUNT = 1\nTRYPOINT LTR   R10,R10             WAS POINT METH SET ?\n         BNZ   PARMWTL             YES, OMIT DEFAULT SET\n         LA    R10,TTRZ            SET DEFAULT METH = TTRZ\nPARMWTL WTO    '**** COUNT = 1,    START = 00000000, POINT = Z, WRITE =1\n                N ****',ROUTCDE=11,DESC=7\nWTLCOUNT EQU   PARMWTL+13\nWTLSTART EQU   PARMWTL+27\nWTLPOINT EQU   PARMWTL+45\nWTLWRITE EQU   PARMWTL+56\n         EJECT\n         L     R0,CLEAR+4\n        GETMAIN R,LV=(0)\n         ST    R1,CLEAR\n         LR    R7,R1               BUFFER ADDRESS\n        OPEN   (SYSUT1)            OPEN SYSUT1\n         TM    SYSUT1+OFLGS,DCBOFOPN    WAS SYSUT1 PROPERLY OPENED ?\n         BO    OPENUT2             YES, GO OPEN SYSUT2\n        WTO    '**** CANNOT OPEN SYSUT1              ****', TELL USER  1\n               ROUTCDE=11,DESC=7\n         B     ABEX                GO ABEND WITH DUMP\nOPENUT2  MVC   SYSUT2+RECFM(1),SYSUT1+RECFM  SHIFT RECFM\n         MVC   SYSUT2+BLKSI(2),SYSUT1+BLKSI  SHIFT BLKSIZE\n         MVC   SYSUT2+LRECL(2),SYSUT1+LRECL  SHIFT LRECL\n        OPEN   (SYSUT2,(OUTPUT))   OPEN SYSUT2\n         TM    SYSUT2+OFLGS,DCBOFOPN    WAS SYSUT2 PROPERLY OPENED ?\n         BO    INITP               YES, GO TEST FOR INITIAL POINT\n        WTO    '**** CANNOT OPEN SYSUT2              ****', TELL USER  1\n               ROUTCDE=11,DESC=7\n         B     ABEX                GO ABEND WITH DUMP\nINITP    LTR   R9,R9               WAS INITIAL POINT SPECIFIED ?\n         BZ    RDWRLOOP            NO, GO READ\n         EJECT\nPOINT   POINT  SYSUT1,SCRATCH      POINT TO NEXT BLOCK\nRDWRLOOP LM    R2,R5,CLEAR         CLEAR BUFFER TO BLANKS\n         MVCL  R2,R4\n        READ   DECB1,SF,SYSUT1,(R7),'S' READ A BLOCK\n        WAIT   1,ECB=DECB1         WAIT FOR COMPLETION\n        NOTE   SYSUT1              NOTE THE TTRZ FROM READ\n         LR    R9,R1               SAVE TTRZ IN R9\n        CHECK  DECB1               ISSUE CHECK FOR THE READ\n        WRITE  DECB2,SF,SYSUT2,(R7)     WRITE OUT THE BLOCK\n        CHECK  DECB2               ISSUE CHECK FOR WRITE\n         LA    R8,1(0,R8)          INCREMENT COUNT OF BLKS\n         B     RDWRLOOP            CONTINUE\n         EJECT\nSUT1ERR SYNADAF ACSMETH=BSAM       GET ERROR MESSAGE\n         MVC   ERRWTL+8(78),50(R1) SHIFT IT TO WTL FIELD\nERRWTL  WTO    '                                                       1\n                                        ',ROUTCDE=11,DESC=7\n        SYNADRLS                   RELEASE SAVE AREA, MESS BUFFER\n        WTO    '**** INPUT ERROR NOTED               ****', TELL USER  1\n               ROUTCDE=11,DESC=7\n         CLI   WRFLAG,X'00'        TEST ERROR WRITE FLAG\n         BE    CLOSE               OFF, DON'T ISSUE WRITE\n        WRITE  DECB3,SF,SYSUT2,(R7)     WRITE OUT THE BLOCK\n        CHECK  DECB3               ISSUE CHECK FOR WRITE\n         LA    R8,1(0,R8)          INCREMENT COUNT OF BLKS\n        WTO    '**** CURRENT BLOCK WRITTEN           ****', TELL USER  1\n               ROUTCDE=11,DESC=7\n         B     CLOSE               GO CLOSE, REOPEN, POINT\n         SPACE 2\nSUT2ERR SYNADAF ACSMETH=BSAM       GET ERROR MESSAGE\n         MVC   ERRWTL2+8(78),50(R1)     SHIFT IT TO WTL FIELD\nERRWTL2 WTO    '                                                       1\n                                        ',ROUTCDE=11,DESC=7\n        SYNADRLS                   RELEASE SAVE AREA, MESS BUFFER\n        WTO    '**** OUTPUT ERROR, FATAL             ****', TELL USER  1\n               ROUTCDE=11,DESC=7\n         BAS   R14,COUNT           GO GIVE BLOCK COUNT\nABEX    ABEND  1,DUMP              ABEND WITH DUMP\n         SPACE 2\nSUT1EOF WTO    '**** EOF ON SYSUT1 NOTED             ****', TELL USER  1\n               ROUTCDE=11,DESC=7\nCLOSE    BAS   R14,COUNT           GO GIVE BLOCK COUNT\n         BCT   R11,CONT            DO WE CONTINUE ?\n        CLOSE  (SYSUT1,,SYSUT2)    CLOSE ALL\n         L     R1,CLEAR\n         L     R0,CLEAR+4\n        FREEMAIN R,A=(1),LV=(0)\nEXIT    $XRET  CC=0                TERMINATE PROCESS\n         EJECT\nCONT    CLOSE  (SYSUT1)            CLOSE SYSUT1\n        OPEN   (SYSUT1)            REOPEN SYSUT1\n         ST    R9,SCRATCH          PUT INTO SCRATCH FOR POINT\n         BR    R10                 GO TO REQUESTED ADDRESSING METH\nTT       LH    R9,SCRATCH          PICK UP TT\n         LA    R9,1(0,R9)          INCREMENT IT\n         STH   R9,SCRATCH          AND RESTORE\n         B     POINT               GO POINT TO IT\nTTR      XR    R9,R9               CLEAR REG 9\n         IC    R9,SCRATCH+2        INSERT R OF TTR\n         LA    R9,1(0,R9)          INCREMENT IT\n         STC   R9,SCRATCH+2        AND RESTORE\n         B     POINT               GO POINT TO IT\nTTRZ     MVI   SCRATCH+3,X'01'     SET Z OF TTRZ TO SPEC 'NEXT'\n         B     POINT               GO POINT TO IT\n         SPACE 2\nCOUNT    CVD   R8,SCRATCH          CONVERT BLK COUNT\n         UNPK  WTL+36(7),SCRATCH+4(4)   UNPACK INTO WTL AREA\n         OI    WTL+42,X'F0'        ZAP SIGN TO CHAR\nWTL     WTO    '**** NO OF BLOCKS WRITTEN =          ****', TELL USER  1\n               ROUTCDE=11,DESC=7\n         BR    R14                 RETURN TO CALLER\n         SPACE 2\nNUMBMVC  MVC   0(*-*,R4),0(R2)     TO SHIFT PARM TO SCRATCH AREA\n         EJECT\n         LTORG\n         SPACE 2\nSCRATCH  DC    D'0',XL2'0'         SCRATCH AREA FOR CONVERT/POINT\nWRFLAG   DC    XL1'0'              FLAG FOR WRITE AFTER IN ERR\nBLANK    DC    CL1' '\nCLEAR    DC    A(*-*,32*1024,BLANK),CL1' ',AL3(1)\n         SPACE 2\nSYSUT1   DCB   DSORG=PS,MACRF=(RP),DDNAME=SYSUT1,      INPUT DCB       1\n               EODAD=SUT1EOF,SYNAD=SUT1ERR                ****\n         SPACE 2\nSYSUT2   DCB   DSORG=PS,MACRF=(W),DDNAME=SYSUT2,       OUTPUT DCB      2\n               SYNAD=SUT2ERR                              ****\n         SPACE 2\n        PRINT  NOGEN\n        DCBD   DSORG=PS,DEVD=DA\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RECOVER$": {"ttr": 10763, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x942\\x7f\\x00\\x942\\x7f\\x14#\\x00\\t\\x00\\t\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-23T00:00:00", "modifydate": "1994-11-23T14:23:00", "lines": 9, "newlines": 9, "modlines": 0, "user": "SYSPAJA"}, "text": "//RECOVER  JOB (........),'INSTALL  -RECOVER-',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=800K,TIME=1\n/*JOBPARM L=4\n//ASS     EXEC PAJ1AS1,MBR=RECOVER\n//LNK     EXEC PAJILKL\n//SYSIN     DD *\n  ENTRY   RECOVER\n  NAME    RECOVER(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RECOVER@": {"ttr": 10765, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x855O\\x00\\x855O\\x16\\x14\\x00e\\x00e\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-12-20T00:00:00", "modifydate": "1985-12-20T16:14:00", "lines": 101, "newlines": 101, "modlines": 0, "user": "SYSPAJA"}, "text": "1   23/09/85\n                                                      RECOVER   1/2.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *       SERVICE AIDS : RECOVER.       * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n      Purpose :      This program attempts to recover data-sets\n      ---------      that have become unusable due to I/O errors\n                     or END-OF-FILE marks.\n                     With either of the above one or more blocks\n                     may be permanently lost (at and immediately\n                     following the cause), but the rest can still\n                     be recovered.\n                     No re-blocking facility is provided, and to\n                     avoid errors, the output DCB is filled with\n                     values taken from the input DCB during the\n                     open, thus no DCB information should be\n                     specified in the JCL (it would be ignored).\n\n      Usage :        The facilities provided in the program are\n      -------        specified by the EXEC parm as a set of\n                     keywords and values (no blanks) :\n                     COUNT=N : specifies the number of I/O errors\n                           or END-OF-FILE's the program is to\n                           accept (default = 1),\n                     START=XXXXXXXX - specifies the relative track\n                           and record beyond the start of the\n                           data-set that the recovery is to start\n                           at, the value given is in TTRZ format\n                           in hex (default = 00000000),\n                     POINT=T - specifies the type of skip to be\n                           used when an I/O error or END-OF-FILE is\n                           encountered, the valid types are T, R\n                           or Z to correspond with TTRZ (default = Z),\n                     WRITE=S - specifies whether the current block\n                           is to be written out in the event of an\n                           I/O error (considering that the block was\n                           partially filled at the time of the error\n                           and thus may yet be usable), the valid\n                           specifications are Y or N for YES or NO\n                           (default = N).\n\n                     Abbreviations consisting of the first character\n                     of each keyword are allowed, further the count\n                     value N may be specified as a positional\n                     parameter if it is given first (this allows\n                     PARM=N).\n1   23/09/85\n                                                      RECOVER   2/2.\n\n                     The program is designed to handle only sequential\n                     files, but recovery can obviously start at the\n                     beginning of a specific member of a PDS as long\n                     as it is explicitly stated in the JCL.\n                     Note that in the case of I/O errors in the\n                     directory of a PDS the easiest method of\n                     recovery is to start the copy function at the\n                     beginning of the data-set (i.e. point the\n                     SYSUT1 DD statement to the data-set itself),\n                     this effectively starts the recovery at the\n                     directory - which will not be usable in the\n                     output data-set. The output data-set will\n                     then be a sequential concatenation of all\n                     the members in the PDS and some other utility\n                     program or TSO may then be used to select the\n                     portions for saving in new, permanent data-sets.\n\n      JCL :          //........ JOB ........\n      -----          //RCV     EXEC PGM=RECOVER,PARM='C=5,P=T'\n                     //SYSUT1   DD  DSN=PDS(BADMEMB),DISP=SHR\n                     //SYSUT2   DD  DSN=RECOVERD,DISP=SHR\n\n                     will result in a total of 5 input errors,\n                     END-OF-FILE's being accepted while member\n                     BADMEMB is copied to data-set RECOVERD.\n                     At each I/O error or END-OF-FILE the realtive\n                     track will be incremented before copying is\n                     continued. The recovery operation will start\n                     at the beginning of member BADMEMB and the\n                     current block will not be written when errors\n                     occur.\n\n      Messages :     Messages from the program are written in the\n      ----------     JOB's LOG, the following are the possible\n                     messages from recover :\n\n                     **** INVALID EXEC PARM FIELD       ****\n                     **** MERGED DEFAULTS AND EXEC PARM ****\n                     **** CANNOT OPEN SYSUT1            **** (1)\n                     **** CANNOT OPEN SYSUT2            **** (2)\n                     **** EOF ON SYSUT1 NOTED           ****\n                     **** INPUT ERROR NOTED             ****\n                     **** CURRENT BLOCK WRITTEN         ****\n                     **** OUTPUT ERROR, FATAL           **** (3)\n                     **** NO. OF BLOCKS WRITTEN = VALUE ****\n\n                     After messages 1, 2 or 3 the program issues\n                     an abend requesting a dump.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SEE": {"ttr": 11011, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x12o\\x00\\x94\\x12o\\tV\\x03<\\x03<\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-05-06T00:00:00", "modifydate": "1994-05-06T09:56:00", "lines": 828, "newlines": 828, "modlines": 0, "user": "SYSPAJA"}, "text": "SEE      TITLE '---  S E E  - SEE CURRENT ISPF PANEL (TSO COMMAND) ---'\n         PRINT OFF\n         MACRO\n&NAME   @SNAP  &W\n         AIF   ('&W' EQ '').MIS\n         AIF   ('&W' EQ 'OPEN').O\n         AIF   ('&W' EQ 'CLOSE').C\n         AIF   (&W EQ 0).INV\n         AIF   (&W GT 255).INV\n&NAME    LA    R0,&W               DO SNAP\n         AGO   .T\n.O       ANOP\n&NAME    XR    R0,R0               OPEN SNAP\n         AGO   .T\n.C       ANOP\n&NAME    XR    R0,R0               CLOSE SNAP\n         BCTR  R0,0\n.T       TM    SWITCH,SNPOFF       SNAP ALREADY OFF?\n         BO    *+L'*+6             YES, BYPASS CALL\n         L     R15,=A(SNAP)\n         BASR  R14,R15\n         MEXIT\n.MIS     MNOTE 8,' OPERAND MISSING ********************************** '\n         MEXIT\n.INV     MNOTE 8,' INVALID OPERAND ********************************** '\n         MEND\n         PRINT ON\n         SPACE 1\nSYSPMSDP START 0\n         SPACE 1\n* ORIGIN :     RECEIVED FROM COLOMBO A. (AMDAHL).\n* --------     UPDATED/MODIFIED BY MOINIL P.A. (J.R.C. ISPRA).\n*\n* COMMAND :    SYNTAX : SEE / WHEN DEBUG : SEE SNAP (ALIAS SEE S)\n* ---------                                + FILE SYSSNAP PRE-ALLOCATED\n         SPACE 1\n        $DEFREG\n         PRINT NOGEN\nDIDOCS  $MDL@IX\nLV15     EQU   15                  LEVEL IS HIGHLY SENSITIVE\n         PRINT GEN\n         SPACE 1\nKB       EQU   1024                1K BYTES\n         EJECT\n        $XENT  BASE=R12,LV=WKDL,TYPE=RENT\n         LR    R8,R13\n         USING WKDATA,R8\n        $TEW$EC TIOT=YES,NOTTSO=(,ONLY),MSG=PUTMSG,ERR=SETRC\n         LA    R0,MDL@IX\n         LA    R1,AUTH\n         STM   R0,R1,REQAUT\n        $EACM  REQAUT\n         CLI   AUTH,LV15\n         BNE   NOTAUT\n        $TEW$PP PARM=PARMLST,REG=R3\n         CLI   PDSN+1,0            SNAP SPECIFIED ?\n         BE    *+L'*+4             NO\n         OI    SWITCH,SNPREQ       SET SNAP REQUESTED\n         DROP  R3\n        IKJRLSA #TSANSW\n        GTSIZE ,                   GET ORIGINAL SCREEN SIZE\n         LTR   R0,R0               IS IT A SCREEN?\n         BZ    NOTSCR              BRANCH IF NOT\n         CH    R0,=H'24'           STANDARD NUMBER OF LINES?\n         BL    NOTSTD              BRANCH IF LESS\n         BE    TSTLNL              BRANCH IF YES\n         CH    R1,=H'80'           STANDARD LINE LENGTH?\n         BL    NOTSTD              BRANCH IF LESS\nSETSSZ   ST    R0,SZSCRN           SAVE SCREEN SIZE\n         ST    R1,SZLINE           SAVE LINE SIZE\n         OI    SWITCH,SCRST        INDICATE SCREEN SIZE TO BE SET\n         B     SETSCR\nTSTLNL   CH    R1,=H'80'           STANDARD LINE LENGTH?\n         BL    NOTSTD              BRANCH IF LESS\n         BH    SETSSZ              BRANCH IF MORE\nSETSCR   TM    SWITCH,SNPREQ       SNAP REQUESTED?\n         BO    *+L'*+12            YES\n         NI    SWITCH,255-SNPOPN\n         OI    SWITCH,SNPOFF\n         B     NOSNAP\n        @SNAP  OPEN                TEST AND OPEN SNAP IF DD PRESENT\n         TM    SWITCH,SNPOPN       SNAP ACTIVE?\n         BZ    NOSNAP              NO\n         MVC   ALSRB,=A(TSRBS)\n         MVC   VLSRB(VLSRBL),=Y(TSRBE,SBTEND,TSRBR,L'SBDAT+SBTNML)\n         B     *+L'*+12\nNOSNAP   MVC   ALSRB,=A(NSRBS)\n         MVC   VLSRB(VLSRBL),=Y(NSRBE,SBNEND,NSRBR,L'SBDAT)\n         L     R1,#TSTIOT\n         USING TIODSECT,R1\n         MVC   MYSELF,TIOCNJOB\n         DROP  R1\n        STFSMODE ON,INITIAL=YES    TURN ON VTAM FULL SCREEN MODE\n         TM    SWITCH,SCRST        SCREEN SIZE TO BE SET?\n         BZ    NOSCRS              BRANCH IF NOT\n        STSIZE SIZE=80,LINE=24     SET STANDARD SCREEN SIZE\n         OI    SWITCH,SCRRS        INDICATE SCREEN SIZE TO BE RESET\nNOSCRS   MVC   SCDATA(CLRSCRNL),CLRSCRN\n         LA    R0,CLRSCRNL\n         LA    R1,SCDATA\n         ICM   R1,B'1000',=X'03'\n        TPUT   (1),(0),R           TPUT FULLSCR\n        SETAUTH ,                  SET APF\n         MVI   MERR,C' '\n         MVC   MERR+1(L'MERR-1),MERR\nLLIST    NI    SWITCH,255-CLIST\nLRSTR    LA    R6,23*10\n         LA    R1,SCDATA\n        $FS    CC=EW,WCC=(KBR,RMDT),SBA=(1,1),RA=(1,1,00),MF=E\n        $FS    SBA=(1,1),SF=(SKIP,INT),TEXT='===>',MF=E\n        $FS    SF=NORMAL,MF=E\n        $FS    SBA=(1,17),SF=(SKIP,INT),MF=E\n        $FS    SBA=(1,80),SF=(SKIP),MF=E\n        $FS    SBA=(2,1),MF=E\n         TM    SWITCH,CLIST\n         BZ    *+L'*+8\n         NI    SWITCH,255-CLIST\n         B     LCONT\n         L     R2,CVTPTR           CVT\n         USING CVT,R2\n         L     R2,CVTASVT          ADDRESS SPACE VECTOR TABLE\n         DROP  R2\n         USING ASVT,R2\n         L     R5,ASVTMAXU         MAX. NUMBER OF ADDRESS SPACES\n         SLL   R5,2\n         LA    R5,ASVTENTY(R5)     + ENTRY FOR EACH POSSIBLE ASID\n         LA    R2,ASVTENTY         -> ENTRY FOR EACH POSSIBLE ASID\n         DROP  R2\nLASCB    CLR   R2,R5\n         BNL   LENDTB\n         TM    0(R2),ASVTAVAL      ASID AVAILABLE?\n         BO    LNEXT               YES\n         L     R3,0(R2)            NO, GET ASCB ADDRESS\n         USING ASCB,R3\n         CLC   ASCBASCB,=CL4'ASCB'\n         BNE   LNEXT\n         ICM   R4,B'1111',ASCBTSB  TSB ADDRESS (TSO USER)\n         BZ    LNEXT\n         ICM   R4,B'1111',ASCBJBNI GET AS-NAME\n         BNZ   *+L'*+8\n         ICM   R4,B'1111',ASCBJBNS\n         BZ    LNEXT\n         CLC   MYSELF(L'MYSELF),0(R4)\n         BE    LNEXT\n         LTR   R6,R6\n         BNP   LFILL\nLCONT    MVC   0(8,R1),0(R4)       LIST TSO USER-NAMES\n         MVC   8(2,R1),=CL10' '\n         LA    R1,10(R1)\n         BCTR  R6,0\nLNEXT    LA    R2,4(R2)            STEP TO NEXT ENTRY\n         B     LASCB\n         DROP  R3\nLFILL   $FS    SBA=(1,28),TEXT='or continue ...',MF=E\n         OI    SWITCH,CLIST\nLENDTB  $FS    SBA=(1,18),TEXT='Select ...',MF=E\n         CLI   MERR,C' '\n         BE    LPTIC\n        $FS    SBA=(1,45),MF=E\n         MVC   0(L'MERR,R1),MERR\n         LA    R1,L'MERR(R1)\n         MVI   MERR,C' '\n         MVC   MERR+1(L'MERR-1),MERR\nLPTIC   $FS    SBA=(1,1),SF=(PT,IC),MF=E\n         LR    R0,R1\n         LA    R1,SCDATA\n         SLR   R0,R1\n         ICM   R1,B'1000',=X'03'\n        TPUT   (1),(0),R           TPUT FULLSCR\n         XC    PFREPLY,PFREPLY\n        TGET   PFREPLY,L'PFREPLY,ASIS,WAIT\n         CH    R15,=H'20'          TERMINAL DISCONNECTED?\n         BE    ENDPRC              YES,... SPLIT\n         CH    R15,=H'8'           ATTENTION?\n         BE    ENDPRC              YES,... START OVER\n         CH    R15,=H'12'          IS INPUT LONGER THAN BUFFER?\n         BNE   SKCLRQ              NO\n        TCLEARQ INPUT              FLUSH THE TRASH\nSKCLRQ   CLI   PFREPLY,X'F3'       PF 3 ENTERED?\n         BE    ENDPRC              YES,... END\n         CLI   PFREPLY,X'C3'       PF 15 ENTERED (ALT. PF 3)?\n         BE    ENDPRC              YES,... END\n         OC    TXREPLY,=CL10' '\n         CLC   TXREPLY,=CL10' '    ANY REQUEST?\n         BE    LRSTR               BRANCH IF NOT\n         LA    R0,L'TARGET\n         LA    R1,TARGET\n         LA    R14,L'TXREPLY\n         LA    R15,TXREPLY\n         MVC   TARGET(L'TARGET),=CL10' '\nSCNTX    CLI   0(R15),C' '\n         BE    SKPTX\n         MVC   0(1,R1),0(R15)\n         BCT   R0,*+L'*+4\n         B     CHCKTG\n         LA    R1,1(R1)\nSKPTX    BCT   R14,*+L'*+4\n         B     CHCKTG\n         LA    R15,1(R15)\n         B     SCNTX\nCHCKTG   CLC   TARGET(4),=CL4'END ' END REQUESTED?\n         BE    ENDPRC              YES,... END\nTSCHCK   CLC   TARGET,MYSELF\n         BNE   TSCONT\n         MVC   MERR+L'TARGET+2(16),=CL16'=> Yourself ???)'\nSTMSG    MVC   MERR+1(L'TARGET),TARGET\n         MVI   MERR,C'('\n         B     LLIST\nTSCONT   XC    SVASCB,SVASCB\n         L     R2,CVTPTR           CVT\n         USING CVT,R2\n         L     R2,CVTASVT          ADDRESS SPACE VECTOR TABLE\n         DROP  R2\n         USING ASVT,R2\n         L     R5,ASVTMAXU         MAX. NUMBER OF ADDRESS SPACES\n         SLL   R5,2\n         LA    R5,ASVTENTY(R5)     + ENTRY FOR EACH POSSIBLE ASID\n         LA    R2,ASVTENTY         -> ENTRY FOR EACH POSSIBLE ASID\n         DROP  R2\nLPASCB   CLR   R2,R5\n         BNL   ENDTAB\n         TM    0(R2),ASVTAVAL      ASID AVAILABLE?\n         BO    NEXT                YES\n         L     R3,0(R2)            NO, GET ASCB ADDRESS\n         USING ASCB,R3\n         CLC   ASCBASCB,=CL4'ASCB'\n         BNE   NEXT\n         ICM   R4,B'1111',ASCBTSB  TSB ADDRESS (TSO USER)\n         BZ    NEXT\n         ICM   R4,B'1111',ASCBJBNI GET AS-NAME\n         BNZ   *+L'*+8\n         ICM   R4,B'1111',ASCBJBNS\n         BZ    NEXT\n         CLC   TARGET,0(R4)        SEARCH A SPECIFIED ASCB NAME\n         BE    *+L'*+8             BRANCH IF FOUND\nNEXT     LA    R2,4(R2)            STEP TO NEXT ENTRY\n         B     LPASCB\n         LA    R3,0(R3)\n         ST    R3,SVASCB\n         DROP  R3\nENDTAB   OC    SVASCB,SVASCB\n         BNZ   *+L'*+10\n         MVC   MERR+L'TARGET+2(18),=CL18'=> Not a TSO user)'\n         B     STMSG\n        MODESET MODE=SUP,KEY=ZERO\n         TM    SWITCH,FIRST\n         BO    LPMAIN\n         LH    R2,VLSRB1\n        GETMAIN RU,LV=(R2),SP=228\n         ST    R2,COMMON\n         ST    R1,COMMON+4\n         LR    R4,R1\n         LR    R5,R2\n         LR    R3,R2\n         L     R2,ALSRB\n         MVCL  R4,R2\n         LH    R0,VLSRB2\n        GETMAIN RU,LV=(0),SP=228\n         ST    R1,SRBADR\n         LR    R9,R1\n         OI    SWITCH,FIRST\n         USING SRBSECT,R9\nLPMAIN   XC    SRB(SBDAT-SRB),SRB\n         MVC   SRBID,=C'SRB '\n         L     R1,COMMON+4\n         ST    R1,SRBEP\n         AH    R1,VLSRB3\n         ST    R1,SRBRMTR\n         LA    R1,SBSAVE\n         ST    R1,SRBPARM\n         ST    R1,SRBSAVE\n         MVC   SRBASCB,SVASCB\n         LA    R0,SBDAT\n         LH    R1,VLSRB4\n         LR    R14,R0\n         XR    R15,R15\n         MVCL  R0,R14\n        SCHEDULE SRB=(R9),SCOPE=GLOBAL            <======== DO SERVICE\n        MODESET KEY=NZERO,MODE=PROB\n         LA    R2,3\nWTABIT  STIMER WAIT,BINTVL==F'125'\n         CLI   SBRETCC,0\n         BNE   *+L'*+4\n         BCT   R2,WTABIT\n        MODESET KEY=ZERO,MODE=SUP\n         LH    R2,VLSRB3\n         A     R2,COMMON+4\n         L     R1,SVASCB\n         USING ASCB,R1\n         MVC   ASPID,ASCBASID      ADDRESS SPACE IDENTIFIER\n         DROP  R1\n        PURGEDQ RMTR=(R2),ASID=ASPID              <==== DELETE SERVICE\n        MODESET KEY=NZERO,MODE=PROB\n        @SNAP  2                   SNAP SBTNM\n         LA    R1,SCDATA\n        $FS    CC=EW,WCC=(KBR,RMDT),SBA=(1,1),RA=(1,1,00),MF=E\n        $FS    SBA=(1,1),SF=(SKIP,INT),TEXT='===>',MF=E\n        $FS    SF=NORMAL,MF=E\n        $FS    SBA=(1,17),SF=(SKIP,INT),TEXT='/ ',MF=E\n         MVC   0(L'TARGET,R1),TARGET\n         LA    R1,L'TARGET(R1)\n         XR    R15,R15\n         IC    R15,SBRETCC\n         B     *+L'*(R15)\n         B     XRC0\n         B     XRC4\n         B     XRC8\n         B     XRC12\n         B     XRC16\n         B     XRC20\nXRC0    $FS    TEXT=' => No SRB data ...',MF=E\n         B     SHPNL\nXRC8    $FS    TEXT=' => No ISPF TLD ...',MF=E\n         B     SHPNL\nXRC12   $FS    TEXT=' => No ISPF TCT ...',MF=E\n         B     SHPNL\nXRC16   $FS    TEXT=' => No ISPF TPP1 ...',MF=E\n         B     SHPNL\nXRC20    TM    SBSWTCH,SWISPF\n         BO    XRC20A\n        $FS    TEXT=' => Not ISPF user ...',MF=E\n         B     SHPNL\nXRC20A  $FS    TEXT=' => Can''t retrieve ISPF panel ...',MF=E\n         B     SHPNL\nXRC4    @SNAP  1                   SNAP SBDAT\n         LA    R2,SBDAT\n         LA    R14,1\n         LA    R15,L'SBDAT-1(R2)\n         CLI   0(R2),C' '\n         BH    PNLOK\n         BXLE  R2,R14,*-8\n        $FS    TEXT=' => No panel data ...',MF=E\nSHPNL   $FS    SBA=(1,80),SF=(SKIP),MF=E\n         B     DSPNL\nPNLOK   $FS    TEXT=' => current ISPF panel displayed below :',MF=E\n        $FS    SBA=(1,80),SF=(SKIP),MF=E\n        $FS    SBA=(2,1),MF=E\n         LA    R2,SBDAT\n         MVC   0(240,R1),0(R2)\n         TR    0(240,R1),TABLE\n         MVC   240(240,R1),240(R2)\n         TR    240(240,R1),TABLE\n         MVC   480(240,R1),480(R2)\n         TR    480(240,R1),TABLE\n         MVC   720(240,R1),720(R2)\n         TR    720(240,R1),TABLE\n         MVC   960(240,R1),960(R2)\n         TR    960(240,R1),TABLE\n         MVC   1200(240,R1),1200(R2)\n         TR    1200(240,R1),TABLE\n         MVC   1440(240,R1),1440(R2)\n         TR    1440(240,R1),TABLE\n         MVC   1680(160,R1),1680(R2)\n         TR    1680(160,R1),TABLE\n         LA    R1,7*240+160(R1)\nDSPNL   $FS    SBA=(1,1),SF=(PT,IC),MF=E\n         LR    R0,R1\n         LA    R1,SCDATA\n         SLR   R0,R1\n         ICM   R1,B'1000',=X'03'\n        TPUT   (1),(0),R           TPUT FULLSCR\n         XC    PFREPLY,PFREPLY\n        TGET   PFREPLY,L'PFREPLY,ASIS,WAIT\n         CH    R15,=H'20'          TERMINAL DISCONNECTED?\n         BE    ENDPRC              YES,... SPLIT\n         CH    R15,=H'8'           ATTENTION?\n         BE    ENDPRC              YES,... START OVER\n         CH    R15,=H'12'          IS INPUT LONGER THAN BUFFER?\n         BNE   SKPCLRQ             NO\n        TCLEARQ INPUT              FLUSH THE TRASH\nSKPCLRQ  CLI   PFREPLY,X'F3'       PF 3 ENTERED?\n         BE    LLIST               YES,... GO BACK DISPLAY LIST\n         CLI   PFREPLY,X'C3'       PF 15 ENTERED (ALT. PF 3)?\n         BE    LLIST               YES,... GO BACK DISPLAY LIST\n         OC    TXREPLY,=CL10' '\n         CLC   TXREPLY,=CL10' '    ANY REQUEST?\n         BE    TSCONT              NO,... DISPLAY AGAIN\n         LA    R0,L'TARGET\n         LA    R1,TARGET\n         LA    R14,L'TXREPLY\n         LA    R15,TXREPLY\n         MVC   TARGET(L'TARGET),=CL10' '\nTXSCN    CLI   0(R15),C' '\n         BE    TXSKP\n         MVC   0(1,R1),0(R15)\n         BCT   R0,*+L'*+4\n         B     TGCHCK\n         LA    R1,1(R1)\nTXSKP    BCT   R14,*+L'*+4\n         B     TGCHCK\n         LA    R15,1(R15)\n         B     TXSCN\nTGCHCK   CLC   TARGET(4),=CL4'END ' END REQUESTED?\n         BE    LLIST               YES,... GO BACK DISPLAY LIST\n         B     TSCHCK              ELSE DISPLAY AGAIN\nENDPRC   TM    SWITCH,FIRST\n         BZ    QUIT\n        MODESET KEY=ZERO,MODE=SUP\n         LH    R2,VLSRB2\n        FREEMAIN R,LV=(R2),A=(R9),SP=228\n         DROP  R9\n         LM    R4,R5,COMMON\n        FREEMAIN R,A=(R5),LV=(R4),SP=228\n        MODESET KEY=NZERO,MODE=PROB\nQUIT    RESAUTH ,                  RESET APF\n         MVC   SCDATA(CLRSCRNL),CLRSCRN\n         TM    SWITCH,SCRRS        WAS SCREEN SIZE CHANGED?\n         BZ    ENDCL               BRANCH IF NOT\n        STSIZE SIZELOC=SZLINE,LINELOC=SZSCRN RESTORE ORIGINAL SIZE\n        $FS    CC=EWA,MF=(I,SCDATA)\nENDCL    LA    R0,CLRSCRNL\n         LA    R1,SCDATA\n         ICM   R1,B'1000',=X'03'\n        TPUT   (1),(0),R           TPUT FULLSCR\n        STLINENO LINE=1,MODE=OFF\n        @SNAP  CLOSE               CLOSE SNAP IF DD WAS PRESENT\n         XR    R15,R15             RC = 0 -----------------------------\nLEAVE   $XRET  CC=0,LV=WKDL,TYPE=RENT\nNOTAUT   LA    R1,AUTMS\n         B     FINISH\nNOTSCR   LA    R1,SCRMS\n         B     FINISH\nNOTSTD   LA    R1,STDMS\nFINISH   BAS   R14,PUTMSG\nSETRC    LA    R15,16              RC = 16 ----------------------------\n         B     LEAVE\n         DROP  R8\n         EJECT\n         PRINT NOGEN\nAUTMS    WTO   ' -> Illegal command',                                  X\n               ROUTCDE=11,DESC=7,MF=L\nSCRMS    WTO   ' -> Run only on a screen terminal',                    X\n               ROUTCDE=11,DESC=7,MF=L\nSTDMS    WTO   ' -> Screen want to be 24 x 80 sized',                  X\n               ROUTCDE=11,DESC=7,MF=L\n         PRINT GEN\n         SPACE 1\nCLRSCRN $FS    CC=EW,WCC=(KBR,RMDT),SBA=(24,79),MF=L\n        $FS    SBA=(1,1),RA=(1,1,00),MF=L\n        $FS    SBA=(1,1),SF=IC,MF=L\nCLRSCRNL EQU   *-CLRSCRN\n         SPACE 1\nTABLE    DS    0XL256\n         DC    64X'40'\n         DC    XL16'404140404040404040404A4B4C4D4E4F'\n         DC    XL16'504040404040404040405A5B5C5D5E5F'\n         DC    XL16'606140404040404040406A6B6C6D6E6F'\n         DC    XL16'404040404040404040797A7B7C7D7E7F'\n         DC    XL16'408182838485868788898A8B8C8D8E8F'\n         DC    XL16'909192939495969798999A9B9C9D9E9F'\n         DC    XL16'A0A1A2A3A4A5A6A7A8A9AAABACADAEAF'\n         DC    XL16'B0B1B2B3B4B5B6B7B8B9BABBBCBDBEBF'\n         DC    XL16'C0C1C2C3C4C5C6C7C8C9CA4040404040'\n         DC    XL16'D0D1D2D3D4D5D6D7D8D9404040404040'\n         DC    XL16'E0E1E2E3E4E5E6E7E8E9404040404040'\n         DC    XL16'F0F1F2F3F4F5F6F7F8F9404040404040'\n         SPACE 1\n        LTORG  ,                   LITERAL POOL\n         SPACE 1\n         DROP  R12                 END OF MAIN ADDRESSABILITY\n         EJECT\n*------- SRB PROGRAM (NORMAL ACTIVITY)\n*              R1  = SRB PARAMETER / POINTER -> SBSAVE\n*              R9  = SRB BASE REGISTER\n*              R14 = RETURN REGISTER\n*              R15 = ENTRY ADDRESS\n         SPACE 1\n        CNOP  0,8\n         USING SBSAVE,R1           SRB WORK-AREA ADDRESSABILITY\n         USING *,R9                SRB ADDRESSABILITY\nNSRBS    LR    R9,R15\n         L     R3,CVTPTR           CVT\n         USING CVT,R3\n         L     R3,CVTTCBP\n         DROP  R3\n         L     R3,12(R3)           GET CURRENT ASCB ADDRESS\n         USING ASCB,R3\n         L     R3,ASCBASXB         POINTER TO ASXB\n         DROP  R3\n         USING ASXB,R3\n         L     R3,ASXBLTCB         POINTER TO LAST TCB ON TCB QUEUE\n         DROP  R3\n         XR    R5,R5\n         USING TCB,R3\n         L     R7,TCBRBP           ADDRESS OF SVRB (SRB)\nNSRBL    L     R4,TCBRBP           ADDRESS OF RB FOR EXECUTING PROGRAM\n         USING RBBASIC,R4\nNSRBV    CLI   RBSTAB1,RBFTPRB\n         BNE   NSRBN\n         ICM   R5,B'0111',RBCDE1   ADDRESS OF CDE\n         USING CDENTRY,R5\n         CLC   CDNAME(3),=CL3'ISP'\n         BE    NSRBT\n         CLC   CDNAME(3),=CL3'IKJ'\n         BE    NSRBM\n         DROP  R5\nNSRBN    TM    RBSTAB2,RBTCBNXT\n         BO    *+L'*+8\n         ICM   R4,B'0111',RBLINKB  NEXT RB\n         B     NSRBV\n         ICM   R3,B'1111',TCBOTC   NEXT TCB\n         BNZ   NSRBL\n         DROP  R3,R4\nNSRBM    MVI   SBRETCC,20\n         BR    R14\nNSRBT    OI    SBSWTCH,SWISPF\n         USING RBBASIC,R7\n         L     R3,RBGRS9\n         DROP  R7\n         MVI   SBRETCC,8\n         CLC   0(3,R3),=CL3'TLD'\n         BNER  R14\n         L     R3,32(R3)           ADDRESS OF TCT\n         MVI   SBRETCC,12\n         CLC   0(3,R3),=CL3'TCT'\n         BNER  R14\n         L     R3,336(R3)          -> PRIVATE AREA\n         MVI   SBRETCC,16\n         CLC   0(4,R3),=CL4'TPP1'\n         BNER  R14\n         LA    R3,324(R3)          -> LAST ISPF PANEL\n         MVC   SBDAT(240),0(R3)\n         MVC   SBDAT+240(240),240(R3)\n         MVC   SBDAT+480(240),480(R3)\n         MVC   SBDAT+720(240),720(R3)\n         MVC   SBDAT+960(240),960(R3)\n         MVC   SBDAT+1200(240),1200(R3)\n         MVC   SBDAT+1440(240),1440(R3)\n         MVC   SBDAT+1680(240),1680(R3)\n         MVI   SBRETCC,4\nNSRBR    EQU   *-NSRBS             SRB RECOVERY ADDRESS\n         BR    R14\n         DROP  R1                  KILL SRB WORK-AREA ADDRESSABILITY\n         SPACE 1\n        LTORG  ,                   LITERAL POOL\n         SPACE 1\n         DS    0D\nNSRBE    EQU   *-NSRBS             SRB CODE TOTAL LENGTH\n         SPACE 1\n         DROP  R9                  KILL SRB ADDRESSABILITY\n         EJECT\n*------- SRB PROGRAM (TRACE ACTIVITY)\n*              R1  = SRB PARAMETER / POINTER -> SBSAVE\n*              R9  = SRB BASE REGISTER\n*              R14 = RETURN REGISTER\n*              R15 = ENTRY ADDRESS\n         SPACE 1\n        CNOP  0,8\n         USING SBSAVE,R1           SRB WORK-AREA ADDRESSABILITY\n         USING *,R9                SRB ADDRESSABILITY\nTSRBS    LR    R9,R15\n         L     R3,CVTPTR           CVT\n         USING CVT,R3\n         L     R3,CVTTCBP\n         DROP  R3\n         L     R3,12(R3)           GET CURRENT ASCB ADDRESS\n         USING ASCB,R3\n         L     R3,ASCBASXB         POINTER TO ASXB\n         DROP  R3\n         USING ASXB,R3\n         L     R3,ASXBLTCB         POINTER TO LAST TCB ON TCB QUEUE\n         DROP  R3\n         XR    R5,R5\n         LA    R6,SBTNM\n         USING TCB,R3\n         L     R7,TCBRBP           ADDRESS OF SVRB (SRB)\nTSRBL    L     R4,TCBRBP           ADDRESS OF RB FOR EXECUTING PROGRAM\n         MVC   0(4,R6),=F'-1'\n         STCM  R3,B'1111',4(R6)\n         LA    R6,8(R6)\n         USING RBBASIC,R4\nTSRBV    STCM  R4,B'1111',0(R6)\n         MVC   4(4,R6),RBSIZE\n         LA    R6,8(R6)\n         CLI   RBSTAB1,RBFTPRB\n         BNE   TSRBN\n         ICM   R5,B'0111',RBCDE1   ADDRESS OF CDE\n         USING CDENTRY,R5\n         MVC   0(L'CDNAME,R6),CDNAME\n         LA    R6,8(R6)\n         CLC   CDNAME(3),=CL3'ISP'\n         BNE   TSRBN\n         DROP  R5\n         OI    SBSWTCH,SWISPF\nTSRBN    TM    RBSTAB2,RBTCBNXT\n         BO    *+L'*+8\n         ICM   R4,B'0111',RBLINKB  NEXT RB\n         B     TSRBV\n         ICM   R3,B'1111',TCBOTC   NEXT TCB\n         BNZ   TSRBL\n         DROP  R3,R4\n         TM    SBSWTCH,SWISPF\n         BO    *+L'*+6\n         MVI   SBRETCC,20\n         BR    R14\n         USING RBBASIC,R7\n         L     R3,RBGRS9\n         DROP  R7\n         MVI   SBRETCC,8\n         CLC   0(3,R3),=CL3'TLD'\n         BNER  R14\n         L     R3,32(R3)           ADDRESS OF TCT\n         MVI   SBRETCC,12\n         CLC   0(3,R3),=CL3'TCT'\n         BNER  R14\n         L     R3,336(R3)          -> PRIVATE AREA\n         MVI   SBRETCC,16\n         CLC   0(4,R3),=CL4'TPP1'\n         BNER  R14\n         LA    R3,324(R3)          -> LAST ISPF PANEL\n         MVC   SBDAT(240),0(R3)\n         MVC   SBDAT+240(240),240(R3)\n         MVC   SBDAT+480(240),480(R3)\n         MVC   SBDAT+720(240),720(R3)\n         MVC   SBDAT+960(240),960(R3)\n         MVC   SBDAT+1200(240),1200(R3)\n         MVC   SBDAT+1440(240),1440(R3)\n         MVC   SBDAT+1680(240),1680(R3)\n         MVI   SBRETCC,4\nTSRBR    EQU   *-TSRBS             SRB RECOVERY ADDRESS\n         BR    R14\n         DROP  R1                  KILL SRB WORK-AREA ADDRESSABILITY\n         SPACE 1\n        LTORG  ,                   LITERAL POOL\n         SPACE 1\n         DS    0D\nTSRBE    EQU   *-TSRBS             SRB CODE TOTAL LENGTH\n         SPACE 1\n         DROP  R9                  KILL SRB ADDRESSABILITY\n         EJECT\n*------- TRACE ROUTINE (DEBUG AID FACILITY)\n*              R0  = 0 : OPEN\n*                    + : SNAP (1=SBDAT,2=SBTNM)\n*                        R9  = -> SRB\n*                    - : CLOSE\n*              R8  = -> WKDATA\n*              R12 = LOCAL BASE REGISTER\n*              R13 = SAVE AREA POINTER\n*              R14 = LINK REGISTER\n*              R15 = ENTRY ADDRESS\n*              NOTE - THE FOLLOWING ALLOCATION IS NEEDED TO\n*                     OBTAIN THE SNAP DUMPS :\n*                          ALLOC F(SYSSNAP) SYSOUT(A)\n*                     OR : ALLOC F(SYSSNAP) ...\n         SPACE 1\n        CNOP   0,8\n         USING *,R12               LOCAL BASE REGISTER\nSNAP     STM   R14,R12,12(R13)     ENTRY\n         LR    R12,R15\n         LR    R1,R13\n         USING WKDATA,R8\n         LA    R13,SVSNAP\n         ST    R1,4(R13)\n         ST    R13,8(R1)\n         LA    R3,SNAPDCB\n         USING IHADCB,R3\n         LTR   R0,R0\n         BM    SNC\n         BP    SND\n         TM    SWITCH,SNPOPN+SNPOFF SNAP ALREADY OPENED OR OFF?\n         BNZ   SNX                 YES\n         MVC   0(SNAPLL,R3),SNAPCS\n         XR    R1,R1\n         L     R2,#TSTIOT\n         USING TIODSECT,R2\nSNL      CLC   TIOELNGH(4),=XL4'0'\n         BE    SNF\n         CLC   TIOEDDNM(L'TIOEDDNM),DCBDDNAM\n         BE    *+L'*+10\n         IC    R1,TIOELNGH\n         ALR   R2,R1\n         B     SNL\n         DROP  R2\n        OPEN   ((R3),OUTPUT),MF=(E,SNAPOP)\n         TM    DCBOFLGS,DCBOFOPN   OPENED?\n         BZ    SNF                 NO\n         OI    SWITCH,SNPOPN       YES, SET OPENED\n         MVI   HDR,LHDR\n         MVC   HDRT(25),=CL25'S E E -- DATA BLOCK FROM '\n         LA    R1,HDR\n         ST    R1,SNAPHD\n         OI    SNAPHD,X'80'        HEADER BUILDED\n         B     SNX\nSND      TM    SWITCH,SNPOPN       SNAP OPENED?\n         BZ    SNX                 NO\n         TM    SWITCH,SNPOFF       SNAP OFF?\n         BO    SNX                 YES\n         MVC   HDRU(8),TARGET\n         CH    R0,=H'1'\n         BE    SN1\n         CH    R0,=H'2'\n         BE    SN2\n         B     SNX                 EXIT, UNKNOWN\nSN1      MVC   HDRW,=CL8'- PANEL.'\n         USING SRBSECT,R9\n         LA    R14,SBDAT           START OF SNAP\n         DROP  R9\n         LA    R15,L'SBDAT-1(R14)  + LENGTH = END OF SNAP\n         B     SNS\nSN2      MVC   HDRW,=CL8'- TRACE.'\n         USING SRBSECT,R9\n         LA    R14,SBTNM           START OF SNAP\n         DROP  R9\n         LA    R15,SBTNML-1(R14)   + LENGTH = END OF SNAP\nSNS      STM   R14,R15,SNAPLST\n         OI    SNAPLST+4,X'80'\n        SNAP   DCB=(R3),TCB='S',ID=0,LIST=SNAPLST,                     1\n               STRHDR=SNAPHD,MF=(E,SNAPLIST)\n         LTR   R15,R15             ALL OK?\n         BZ    SNX                 YES\nSNF      OI    SWITCH,SNPOFF       SET PERMANENTLY OFF\nSNC      TM    SWITCH,SNPOPN\n         BZ    SNX\n        CLOSE  ((R3)),MF=(E,SNAPCL)\n         NI    SWITCH,255-SNPOPN   SET CLOSED\n         DROP  R3\nSNX      L     R13,4(R13)          EXIT\n         LM    R14,R12,12(R13)\n         MVI   12(R13),X'FF'\n         XR    R15,R15\n         BR    R14\n         SPACE 1\n         DROP  R8\n         EJECT\n         PRINT NOGEN\nSNAPCS  DCB    DSORG=PS,RECFM=VBA,MACRF=(W),                           1\n               BLKSIZE=1632,LRECL=125,                                 2\n               DDNAME=SYSSNAP\n        OPEN   (*-*),MF=L\n        CLOSE  (*-*),MF=L\n        SNAP   MF=L\n         PRINT GEN\nSNAPLL   EQU   *-SNAPCS\n         SPACE 1\n        LTORG  ,                   LITERAL POOL\n         SPACE 1\n         DROP  R12                 END OF LOCAL ADDRESSABILITY\n         SPACE 1\n         PRINT NOGEN\nPARMLST IKJPARM ,                  PARSE PARAMETER'S LIST (SYNTAX)\nPDSN    IKJKEYWD\n        IKJNAME 'SNAP',ALIAS=('S')\n        IKJENDP\n         PRINT GEN\n         EJECT\nWKDATA   DSECT\n         DS    18F                 SAVE AREA\nSVSNAP   DS    18F                 SNAP SAVE AREA\n         SPACE 1\n        $TEW$WA\n         SPACE 1\n         PRINT NOGEN\nSNAPDCB DCB    DSORG=PS,RECFM=VBA,MACRF=(W),                           1\n               BLKSIZE=1632,LRECL=125,                                 2\n               DDNAME=SYSSNAP\nSNAPOP  OPEN   (*-*),MF=L\nSNAPCL  CLOSE  (*-*),MF=L\nSNAPLIST SNAP  MF=L\n         PRINT GEN\n         SPACE 1\nSNAPLST  DS    2F\nSNAPHD   DS    F\nREQAUT   DS    2F\nSZLINE   DS    F                   LINE SIZE (LINE LENGTH)\nSZSCRN   DS    F                   SCREEN SIZE (NUMBER OF LINES)\nCOMMON   DS    2A\nALSRB    DS    A\nSRBADR   DS    A\nSVASCB   DS    A\nMYSELF   DS    CL8\nTARGET   DS    CL8\nPFREPLY  DS    0CL16               AREA TO HOLD TGET REPLY\n         DS    CL6                 AID + JUNK\nTXREPLY  DS    CL10                REAL REPLY\nMERR     DS    CL30                ERROR MESSAGE\nASPID    DS    H\nVLSRB    DS    0H\nVLSRB1   DS    H                   SRB ROUTINE CODE TOTAL LENGTH\nVLSRB2   DS    H                   SRB REQUEST BLOCK TOTAL LENGTH\nVLSRB3   DS    H                   SRB RECOVERY ADDRESS DISPLACEMENT\nVLSRB4   DS    H                   SRB REQUEST BLOCK VARIABLE LENGTH\nVLSRBL   EQU   *-VLSRB\nAUTH     DS    XL1\nSWITCH   DS    XL1\nSCRST    EQU   X'80'               SCREEN SIZE TO BE SET\nSCRRS    EQU   X'40'               SCREEN SIZE TO BE RESET\nFIRST    EQU   X'10'               SRB SPACE GETMAIN'D\nSNPREQ   EQU   X'08'               SNAP REQUESTED\nSNPOPN   EQU   X'04'               SNAP DCB OPENED\nSNPOFF   EQU   X'02'               SNAP PERMANENTLY OFF\nCLIST    EQU   X'01'               CONTINUE LIST\n         SPACE 1\nHDR      DS    AL1\nHDRT     DS    CL25\nHDRU     DS    CL8\nHDRW     DS    CL8\nLHDR     EQU   *-HDRT\n         SPACE 1\n         DS    0F\nLBF      EQU   (3*KB)-(*-WKDATA)\nSCDATA   DS    (LBF)X\nWKDL     EQU   (((*-WKDATA)+7)/8)*8\n         SPACE 1\n         PRINT NOGEN\n        IHASRB ,\nSBSAVE   DS    18F\nSBRETCC  DS    XL1\nSBSWTCH  DS    XL1\nSWISPF   EQU   X'80'\n         DS    0D\nSBDAT    DS    CL1920\n         DS    0D\nSBNEND   EQU   *-SRB\nSBTNM    DS    100CL8\nSBTNML   EQU   *-SBTNM\n         DS    0D\nSBTEND   EQU   *-SRB\n         SPACE 1\n        $TEW$DS\n        IHAASVT DSECT=YES,LIST=YES\n        IHAASCB DSECT=YES,LIST=YES\n        IHAASXB DSECT=YES,LIST=YES\n        IKJTCB DSECT=YES,LIST=YES\n        IKJRB  DSECT=YES,LIST=YES\n        IHACDE ,\n        DCBD   DEVD=DA,DSORG=PO\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SEE$": {"ttr": 11270, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x942\\x7f\\x00\\x942\\x7f\\x14#\\x00\\t\\x00\\t\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-23T00:00:00", "modifydate": "1994-11-23T14:23:00", "lines": 9, "newlines": 9, "modlines": 0, "user": "SYSPAJA"}, "text": "//SEE      JOB (........),'INSTALL  -S E E-',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=1M,TIME=1\n/*JOBPARM L=5\n//ASS     EXEC PAJ1AS3,OPT=',RENT',MBR=SEE\n//LNK     EXEC PAJILKC,OPT=',RENT'\n//SYSIN     DD *\n  ENTRY   SYSPMSDP\n  NAME    SEE(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SENDRTN": {"ttr": 11272, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\t\\x7f\\x00\\x88\\t\\x7f\\t3\\x00Z\\x00Z\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-04-06T00:00:00", "modifydate": "1988-04-06T09:33:00", "lines": 90, "newlines": 90, "modlines": 0, "user": "SYSPAJA"}, "text": "SNDR     TITLE 'I/O ROUTINE (WTO/WTOR OR TPUT/TGET).'\nSENDRTN  START 0\n         SPACE 1\n* FUNCTION :   ROUTINE TO AUTOMATICALLY TRANSFORM THE WTO/WTOR INTO\n* ----------   TPUT/TGET WHEN RUNNING IN TSO ENVIRONMENT.\n*\n*              AT ENTRY : THE REGISTER 1 MUST POINT TO A PARAMETER\n*                         LIST AS FOLLOWS.\n*                         R1 ---> +0 : A(ADDRESS TSO FLAG)\n*                                 +4 : A(WTO/WTOR PARM. LIST)\n*              AT EXIT : R15 CONTAINS TGET RC WHEN SIMULATE WTOR,\n*                        IN ALL OTHER CASES IT CONTAINS ZERO.\n*\n* AUTHOR :     MOINIL P.A.\n* --------     COMPUTING CENTRE\n*              J.R.C. - ISPRA ESTABLISHMENT\n*              21020 ISPRA (VA), ITALY\n         SPACE 2\n        $DEFREG\n         EJECT\n        $XENT  BASE=R12,TYPE=RENT\n         LM    R2,R3,0(R1)\n         SR    R10,R10             RC = 0\n         TM    0(R2),X'80'         ARE WE RUNNING IN TSO ?\n         BO    STSO                YES.\n         CLI   0(R3),0             REPLY?\n         BNE   SENDR               YES.\n        WTO    MF=(E,(R3))\n         B     FINISH\nSENDR    L     R4,4(R3)\n         MVC   0(4,R4),=F'0'\n         SR    R14,R14\n         SR    R15,R15\n         CLI   8(R3),0             WHICH WTOR LIST VERSION ?\n         BE    SWOLD\n         IC    R14,8(R3)           NEW, MVS/XA\n         L     R15,0(R3)\n         B     SWTOR\nSWOLD    IC    R14,0(R3)           OLD, MVS/370\n         ICM   R15,B'0111',1(R3)\nSWTOR    BCTR  R14,0\n         MVI   0(R15),C' '\n         EX    R14,SCLR\n        WTOR   MF=(E,(R3))\n        WAIT   ECB=(R4)\n         B     FINISH\nSTSO     CLI   0(R3),0             REPLY?\n         BNE   STSOR               YES.\n         LH    R0,0(R3)\n         SH    R0,=H'4'\n         LA    R1,4(R3)\n        TPUT   (1),(0)\n         B     FINISH\nSTSOR    SR    R0,R0\n         IC    R0,9(R3)\n         SH    R0,=H'4'\n         LA    R1,12(R3)\n        TPUT   (1),(0)\nSTBK     SR    R14,R14\n         SR    R15,R15\n         CLI   8(R3),0             WHICH WTOR LIST VERSION ?\n         BE    STOLD\n         IC    R14,8(R3)           NEW, MVS/XA\n         L     R15,0(R3)\n         B     STWTR\nSTOLD    IC    R14,0(R3)           OLD, MVS/370\n         ICM   R15,B'0111',1(R3)\nSTWTR    BCTR  R14,0\n         MVI   0(R15),C' '\n         EX    R14,SCLR\n         LA    R0,1(R14)\n         LR    R1,R15\n        TGET   (1),(0)\n         LTR   R15,R15\n         BZ    FINISH\n         CH    R15,=H'12'\n         BNE   SETCC\n        TCLEARQ INPUT\n        TPUT   TSRTL,L'TSRTL\n         B     STBK\nSETCC    LR    R10,R15\nFINISH  $XRET  CC=(R10),TYPE=RENT\n         SPACE 1\nSCLR     MVC   1(*-*,R15),0(R15)   <<EXECUTED>>\n         SPACE 2\nTSRTL    DC    C'INPUT TOO LONG - RESPECIFY :'\n         SPACE 2\n        LTORG\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SETCLOC$": {"ttr": 11275, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x942\\x7f\\x00\\x942\\x7f\\x14$\\x00\\x13\\x00\\x13\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-23T00:00:00", "modifydate": "1994-11-23T14:24:00", "lines": 19, "newlines": 19, "modlines": 0, "user": "SYSPAJA"}, "text": "//SETCLOCK JOB (........),'INSTALL - SETCLOCK -',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=800K,TIME=1\n/*JOBPARM L=8\n//ASS     EXEC PAJ1AS3,MBR=SETCLOCK\n//LNK     EXEC PAJILKL,OPT=',AC=1'\n//SYSIN     DD *\n  ENTRY   SETCLOCK\n  NAME    SETCLOCK(R)\n/*\n//PRM     EXEC PAJPROC,MBR=SCKPRM00,DSS='->.SOURCE.FILE1',\n//             DSP='->.TARGET.PARMLIB'\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//* EXECUTE THE STEP BELOW WITH PROCEDURE :                           *\n//*       \"PAJPROC\" IF YOUR ->.TARGET.PROCLIB DATA-SET                *\n//*                         IS RECFM=FB AND LRECL=80, ELSE            *\n//*       \"PAJPROV\" IF YOUR ->.TARGET.PROCLIB DATA-SET                *\n//*                         IS RECFM=VB AND LRECL=255.                *\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//PRC     EXEC PAJPROC,MBR=SETCLOCP,DSS='->.SOURCE.FILE1'\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SETCLOC@": {"ttr": 11277, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x855O\\x00\\x855O\\x16\\x15\\x00\\xdd\\x00\\xdd\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-12-20T00:00:00", "modifydate": "1985-12-20T16:15:00", "lines": 221, "newlines": 221, "modlines": 0, "user": "SYSPAJA"}, "text": "1   23/11/85\n                                                      SETCLOCK  1/5.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *           S E T C L O C K           * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *        TOD CLOCK SYNCHRONIZER       * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n CBT origin :  Extracted from CBT 84 JUN, file 350.\n ------------  Installed by MOINIL P.A.\n                            COMPUTING CENTRE\n                            J.R.C. - ISPRA ESTABLISHMENT\n                            21020 ISPRA (VA), ITALY\n\n Purpose :     This is a program whose function is to synchronize the\n ---------     Time-of-Day clocks on all processors in a multi-cpu\n               complex. The communications vehicule is a Shared-Dasd\n               data-set.\n               The use of this program permits the synchronization of\n               TOD clocks of cpu's in a complex to within milliseconds\n               of each other. The program must be APF-Authorized, since\n               it must issue a MODESET to get into Supervisor state to\n               issue the SCK (set clock) instruction.\n               SETCLOCK Should be run immediately after a complex-wide\n               IPL if SMF data validity is to be ensured. The TOD\n               clocks should be set normally before starting SETCLOCK\n               on all processors. The TOD clock value used for all\n               processors may be the highest TOD clock value found\n               among the participating processors or the TOD clock\n               value of a selected participating processor.\n\n               The SETCLOCK Package consists of three members :\n                        - Assembler source for the SETCLOCK program.\n                          Installation considerations are outlined in\n                          the comments at the Start of the program.\n                        - A sample SETCLOCK catalogued procedure for\n                          starting the SETCLOCK program.\n                        - A copy of our SETCLOCK parameters (SCKPRM00),\n                          which explains and illustrates the TOD clock\n                          synchronization parameters.\n\n Authors :     LOUIS LABRECHE\n ---------     PHILIP A. FOSTER\n                    I.S.T. INC.\n                    2 COMPLEXE DESJARDINS\n                    MONTREAL, QUEBEC\n                    H5B 1B3\n                    (514) 284-1111                JUNE 1980\n1   03/10/85\n                                                      SETCLOCK  2/5.\n\n  *******************************************************************\n  **        --------------- S E T C L O C K ---------------        **\n  **        \"AUTOMATIC CLOCK SYNCHRONISATION BETWEEN CPU'S\"        **\n  *******************************************************************\n\n Purpose :     This module has been written to provide a mean by which\n ---------     different CPU's will be set to the same Time-of-Day\n               clock values.\n\n Description : This program is initiated as a Started Task on each CPU\n ------------- in a complex for which TOD clock synchronization is\n               desired. This should normally be at IPL time, so that\n               the modification of TOD clock values do not impact SMF\n               data recording. Once started, the program will remain\n               active until the TOD clock of its Host System has been\n               synchronized with those of all its partners.\n               The information is transmitted between CPU's via a\n               \"DASD\" device, and a Checkpoint Record is used to\n               transfer data. A logical lock is used to determine if\n               the Checkpoint is held by any CPU.\n               The algorithm used to synchronize the clocks is the\n               following :\n               - When a System requests the TIME to be synchronized,\n                 it asks for a \"SYSTEM TRACKING\" request on the Dasd\n                 Record.\n               - From that moment, each \"SET CLOCK\" job will access\n                 the Checkpoint and expect to communicate with each\n                 CPU specified by \"PARMLIB\", until all of the active\n                 CPU's know that a TIME synchronization will be\n                 performed (access should be done, say once each 5\n                 seconds) : this is called the \"TRACK\" state.\n               - Once all the active CPU's are in the \"TRACK\" state,\n                 the last one initiates a request for all CPU's to\n                 enter the LOCK state. Once in this state, each CPU\n                 will stop \"TRACK WAITING\" and wait for a very short\n                 period of time (2 times the \"SEEK TIME\", multiplied\n                 by the number of active CPUs) until the last one has\n                 obtained the \"LOCK\" state.\n               - When the last one is locked, each CPU will then write\n                 it's clock to the Checkpoint Record. This is done to\n                 determine which CPU has the base clock value and what\n                 discrepancies exist between the various clock values.\n               - When each CPU has written its own clock value to the\n                 record, a request is then made to set the TIME.\n               - From that moment, each CPU that reads the record\n                 will issue a \"SET CLOCK\" instruction according to\n                 the \"NORMALIZED\" time of the \"SET\" request. Normali-\n                 zation is done by adjust the clock with the calculated\n                 time discrepancy plus the seek time multiplied by the\n                 sequence of the \"SET\" CPU. The base value for the\n                 \"NORMALIZATION\" is the value of the TOD clock of the\n                 CPU in the complex which was set as base CPU by the\n                 synchronization method selected.\n1   03/10/85\n                                                      SETCLOCK  3/5.\n\n Parameters :  The parameters are passed to this program by allocating\n ------------  a data-set pointed by DDname \"SYSPARM\", it contains the\n               following specifications :\n               LONG_WAIT       = SSSS\n               TRACK_WAIT      = SSSS\n               SEEK_TIME       = SSSS\n               DISCONNECT_TIME = SSSS\n               MAXCPU          = NN\n               SYNCH_METHOD    = NN\n               SNAP_ID         = NNN\n               SNAP_IDS        = (N,NN,NNN)\n                    where : SSSS  is the time in 100th of a second,\n                            N...  is a numerical value.\n\n          \"LONG_WAIT\" is the interval of time the program should wait\n                    before checking if any \"SYSTEM TRACKING\" request is\n                    made (say 300 seconds).\n          \"TRACK_WAIT\" is the interval of time the program should wait\n                    once it has detected a \"SYSTEM TRACKING\" request.\n                    At this time, it checks if all CPU's obtained that\n                    state (say 5 seconds).\n          \"SEEK_TIME\" is the average interval of time required to\n                    complete an I/O on the Checkpoint data-set.\n          \"DISCONNECT_TIME\" is the period of time we should wait before\n                    concluding that all the other CPUs that did not\n                    reach the \"TRACK STATE\" are not active (say 500\n                    seconds). Must be higher than \"LONG WAIT\".\n          \"MAXCPU\" is the maximum number of CPU's to be synchronized\n                    together.\n          \"SYNCH_METHOD\" is the Synchronization Method number to be\n                    used :   1 = the CPU which RESET Checkpoint sets\n                                 the base clock value.\n                    Default = the CPU which has the HIGHEST clock\n                              value in the complex.\n          \"SNAP_ID\" is the Snap-Dump ID's (0-255) to set active.\n          \"SNAP_IDS\"          (needs SYSSNAP file allocated)\n1   03/10/85\n                                                      SETCLOCK  4/5.\n\n Notes :     - The \"DASD\" device is pointed to by the DDname \"SYSCKPT\".\n -------       One track is a sufficent allocation.\n             - CPU identifier is taken from \"SMCA\" and the last charac-\n               ter is used to determine entry offset in Checkpoint\n               (see in the source of SETCLOCK program the description\n               of the SETCGEN macro operands for an explanation of\n               installation tailoring options).\n               The SETCLOCK program assumes that the SMF System ID for\n               each System contains a unique 1 character identifier\n               located at a consistent offset. If this is not true for\n               your installation, the CPU identification code will have\n               to be altered (see label SCGSID).\n             - The 'PARM' field of the program can be used to RESET the\n               Checkpoint Record by coding :\n                             EXEC PGM=SETCLOCK,PARM='RESET'\n                        In that case, Checkpoint Record will be\n                        be initialized and written to the Checkpoint\n                        data-set (it may also indicate the base CPU\n                        clock value for synchronization).\n               or it can be used to request only the scan of the input\n               parameters by coding :\n                             EXEC PGM=SETCLOCK,PARM='SCAN'\n                        In that case, the execution terminates as soon\n                        as the parameters are scanned.\n\n\n  *******************************************************************\n  **                       INSTALLATION GUIDE                      **\n  *******************************************************************\n\n  Use the following steps to install SETCLOCK :\n       - Assemble and Link-Edit SETCLOCK into an AUTHORIZED Library.\n       - Move procedure member SETCLOCK into the System's start\n         procedures Library.\n       - Move the member SCKPRM00 (Synchronization parameters) into\n         the System's common parameters Library.\n1   03/10/85\n                                                      SETCLOCK  5/5.\n\n  *******************************************************************\n  **                          USER'S GUIDE                         **\n  *******************************************************************\n\n         SETCLOCK is invoked to perform \"CLOCK SYNCHRONIZATION\" between\n  CPU's. It must be started on each CPU to be synchronized, and will\n  terminate when the time is set. If it is not started on a CPU two (2)\n  minutes after the last 'S SETCLOCK', the CPU will be considered as\n  \"DISCONNECTED\" and will not be synchronized.\n         Note : this program should not run when BATCH or TSO is active\n  (because SMF records would be falsified), unless you are sure that\n  the corresponding CPU TOD CLOCK will not be set.\n         When invoking the program for the first time (or if there is\n  a problem), you should enter :\n         S SETCLOCK,OPT=RESET on the first CPU to synchronize or the\n  base CPU, and :\n         S SETCLOCK on the remaining CPU's.\n         Normally the default Synchronization parameters list\n  (SCKPRM00) is selected, but if you want to change list, enter :\n         S SETCLOCK,OPT=RESET,MBR=nn on the first or base CPU, and :\n         S SETCLOCK,MBR=nn on the remaining CPU's, where nn is the two\n  desired decimal digits list number to form the member name SCKPRMnn.\n\n         SETCLOCK runs with TPUT's instead of WTO's, does not enter the\n  Supervisor mode nor execute the \"SCK\" instruction (store clock) when\n  invoked in TSO as below :\n       - ALLOC F(SYSCKPT) DA('...Checkpoint data-set...') SHR\n       - ALLOC F(SYSPARM) DA('...Synchronization parameters...') SHR\n       - AUTHC CALL '... Link Library ...(SETCLOCK)' 'RESET'\n         on the first or base CPU, and\n         AUTHC CALL '... Link Library ...(SETCLOCK)' on the other CPUs.\n       - FREE F(SYSCKPT SYSPARM)\n       - FREE DA('... Link Library ...')\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SETCLOCK": {"ttr": 11524, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x885\\x0f\\x00\\x885\\x0f\\x11W\\x0c\\x83\\x0c\\x83\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-12-15T00:00:00", "modifydate": "1988-12-15T11:57:00", "lines": 3203, "newlines": 3203, "modlines": 0, "user": "SYSPAJA"}, "text": "SETCLOCK TITLE '-- AUTOMATIC CLOCK SYNCHRONIZATION BETWEEN CPU''S --'\n***********************************************************************\n**                                                                   **\n**       ------------------ S E T C L O C K ------------------       **\n**                                                                   **\n**       \"AUTOMATIC CLOCK SYNCHRONISATION BETWEEN CPU'S\"             **\n**                                                                   **\n**             THIS MODULE HAS BEEN WRITTEN TO PROVIDE A MEAN        **\n**             BY WHICH DIFFERENT CPU'S WILL BE SET TO THE SAME      **\n**             TIME-OF-DAY CLOCK VALUES.                             **\n**                                                                   **\n**                               AUTHOR : LOUIS LABRECHE, I.S.T.     **\n**                                        JUNE 1980                  **\n**                                                                   **\n**-------------------------------------------------------------------**\n**       LOG HERE ALL SIGNIFICANT MODIFICATION                       **\n**-------------------------------------------------------------------**\n**  DATE    |   DESCRIPTION                         | IDENTIFICATION **\n**----------|---------------------------------------|----------------**\n** 81-04-06 |   IMPLEMENT DISCREPANCY VALIDATION.   |                **\n**          |   HIGHER THAN 15 MINUTES, SEND A      |      V1.01     **\n**          |   WARNING MESSAGE TO OPERATOR.        |                **\n**          |                        L. LABRECHE    |                **\n**----------|---------------------------------------|----------------**\n** 81-04-06 |   ISSUE A WAIT MACRO WHEN LOOPING     |                **\n**          |   TO GET CHECKPOINT RECORD. WAIT TIME |      V1.02     **\n**          |   SHOULD BE 'SEEK*NCPU'.              |                **\n**          |                        L. LABRECHE    |                **\n**----------|---------------------------------------|----------------**\n** 81-04-06 |   MOVE \"CPU SET\" INDICATOR ONLY AFTER |                **\n**          |   CPU CLOCK HAD ACTUALLY BEEN SET.    |      V1.03     **\n**          |                        L. LABRECHE    |                **\n**----------|---------------------------------------|----------------**\n** 81-04-07 |   IF RESET IS NOT SPECIFIED, MAXIMUM  |                **\n**          |   NUMBER OF CPU'S WILL BE READ FROM   |      V1.04     **\n**          |   CHECKPOINT, AND WILL BE EQUAL TO    |                **\n**          |   LAST NUMBER OF ACTIVE CPU'S.        |                **\n**          |                        L. LABRECHE    |                **\n**----------|---------------------------------------|----------------**\n** 81-11-04 |   PARMLIB DATA-SET IMPLEMENTATION.    |                **\n**          |                        L. LABRECHE    |                **\n**----------|---------------------------------------|----------------**\n** 82-02-19 |   CLARIFICATION OF SOME COMMENTS AND  |                **\n**          |   ADDITION OF SOME MACROS TO AID IN   |                **\n**          |   INSTALLATION TAILORING.             |                **\n**          |                        P. FOSTER      |                **\n**----------|---------------------------------------|----------------**\n         EJECT\n**----------|---------------------------------------|----------------**\n** 85-04-15 |   TSO (TPUT) AUTO-RECOGNITION.        |      -EU-      **\n**          |   SYNCHRONIZATION METHOD SELECTION.   |                **\n**          |   APPLY \"CVTTZ\" TO CPU CLOCK VALUE.   |                **\n**          |                        P.A. MOINIL    |                **\n**----------|---------------------------------------|----------------**\n** 85-10-01 |   OPTION TO SNAP-DUMP ANY DATA AREAS  |      -EU-      **\n**          |   (DEBUG AID) IF 'SYSSNAP' DD-NAME    |                **\n**          |   FILE IS PRESENT.                    |                **\n**          |                        P.A. MOINIL    |                **\n***********************************************************************\n         EJECT\n***********************************************************************\n**                                                                   **\n**       DESCRIPTION :                                               **\n**       -------------                                               **\n**           THIS PROGRAM IS INITIATED AS A STARTED TASK ON EACH     **\n**       CPU IN A COMPLEX FOR WHICH TOD CLOCK SYNCHRONIZATION IS     **\n**       DESIRED. THIS SHOULD NORMALLY BE AT IPL TIME, SO THAT       **\n**       THE MODIFICATION OF TOD CLOCK VALUES DO NOT IMPACT SMF      **\n**       DATA RECORDING. ONCE STARTED, THE PROGRAM WILL REMAIN       **\n**       ACTIVE UNTIL THE TOD CLOCK OF ITS HOST SYSTEM HAS BEEN      **\n**       SYNCHRONIZED WITH THOSE OF ALL ITS PARTNERS.                **\n**                                                                   **\n**           THE INFORMATION IS TRANSMITTED BETWEEN CPU'S VIA        **\n**       A \"DASD\" DEVICE, AND A CHECKPOINT RECORD IS USED TO         **\n**       TRANSFER DATA. A LOGICAL LOCK IS USED TO DETERMINE IF       **\n**       THE CHECKPOINT IS HELD BY ANY CPU.                          **\n**                                                                   **\n**           THE ALGORITHM USED TO SYNCHRONIZE THE CLOCKS IS THE     **\n**       FOLLOWING :                                                 **\n**       --  WHEN A SYSTEM REQUESTS THE TIME TO BE SYNCHRONIZED,     **\n**           IT ASKS FOR A \"SYSTEM TRACKING\" REQUEST ON THE DASD     **\n**           RECORD.                                                 **\n**       --  FROM THAT MOMENT, EACH \"SET CLOCK\" JOB WILL ACCESS      **\n**           THE CHECKPOINT AND EXPECT TO COMMUNICATE WITH EACH      **\n**           CPU SPECIFIED BY \"PARMLIB\", UNTIL ALL OF THE            **\n**           ACTIVE CPU'S KNOW THAT A TIME SYNCHRONIZATION           **\n**           WILL BE PERFORMED (ACCESS SHOULD BE DONE, SAY ONCE      **\n**           EACH 5 SECONDS) : THIS IS CALLED THE \"TRACK\" STATE.     **\n**       --  ONCE ALL THE ACTIVE CPU'S ARE IN THE \"TRACK\" STATE,     **\n**           THE LAST ONE INITIATES A REQUEST FOR ALL CPU'S TO       **\n**           ENTER THE LOCK STATE. ONCE IN THIS STATE, EACH CPU      **\n**           WILL STOP \"TRACK WAITING\" AND WAIT FOR A VERY SHORT     **\n**           PERIOD OF TIME (2 TIMES THE \"SEEK TIME\", MULTIPLIED     **\n**           BY THE NUMBER OF ACTIVE CPUS) UNTIL THE LAST ONE HAS    **\n**           OBTAINED THE \"LOCK\" STATE.                              **\n**       --  WHEN THE LAST ONE IS LOCKED, EACH CPU WILL THEN         **\n**           WRITE IT'S CLOCK TO THE CHECKPOINT RECORD. THIS IS      **\n**           DONE TO DETERMINE WHICH CPU HAS THE BASE CLOCK          **\n**           VALUE AND WHAT DISCREPANCIES EXIST BETWEEN THE          **\n**           VARIOUS CLOCK VALUES.                                   **\n**       --  WHEN EACH CPU HAS WRITTEN ITS OWN CLOCK VALUE TO THE    **\n**           RECORD, A REQUEST IS THEN MADE TO SET THE TIME.         **\n**       --  FROM THAT MOMENT, EACH CPU THAT READS THE RECORD        **\n**           WILL ISSUE A \"SET CLOCK\" INSTRUCTION ACCORDING TO       **\n**           THE \"NORMALIZED\" TIME OF THE \"SET\" REQUEST. NORMALI-    **\n**           ZATION IS DONE BY ADJUST THE CLOCK WITH THE CALCULATED  **\n**           TIME DISCREPANCY AND THE SEEK TIME MULTIPLIED BY        **\n**           THE SEQUENCE OF THE \"SET\" CPU. THE BASE VALUE FOR       **\n**           THE \"NORMALIZATION\" IS THE VALUE OF THE TOD CLOCK       **\n**           OF THE CPU IN THE COMPLEX WHICH WAS SET AS BASE CPU     **\n**           BY THE SYNCHRONIZATION METHOD SELECTED.                 **\n**                                                                   **\n***********************************************************************\n         EJECT\n***********************************************************************\n**                                                                   **\n**       PARAMETERS :                                                **\n**       ------------                                                **\n**           THE PARAMETERS ARE PASSED TO THIS PROGRAM BY            **\n**       ALLOCATING A DATA-SET POINTED BY DDNAME \"SYSPARM\"           **\n**       IT CONTAINS THE FOLLOWING SPECIFICATIONS :                  **\n**                                                                   **\n**           LONG_WAIT       = SSSS          WHERE SSSS              **\n**           TRACK_WAIT      = SSSS            IS THE TIME           **\n**           SEEK_TIME       = SSSS              IN 100TH OF         **\n**           DISCONNECT_TIME = SSSS                A SECOND          **\n**           MAXCPU          = NN            WHERE N...              **\n**           SYNCH_METHOD    = NN              IS A              -EU-**\n**           SNAP_ID         = NNN               NUMERICAL       -EU-**\n**           SNAP_IDS        = (N,NN,NNN)          VALUE         -EU-**\n**                                                                   **\n**                                                                   **\n**       \"LONG_WAIT\"   IS THE INTERVAL OF TIME THE PROGRAM SHOULD    **\n**                     WAIT BEFORE CHECKING IF ANY \"SYSTEM TRACKING\" **\n**                     REQUEST IS MADE (SAY 300 SECONDS).            **\n**                                                                   **\n**       \"TRACK_WAIT\"  IS THE INTERVAL OF TIME THE PROGRAM SHOULD    **\n**                     WAIT ONCE IT HAS DETECTED A \"SYSTEM TRACKING\" **\n**                     REQUEST. AT THIS TIME, IT CHECKS IF ALL CPU'S **\n**                     OBTAINED THAT STATE (SAY 5 SECONDS).          **\n**                                                                   **\n**       \"SEEK_TIME\"   IS THE AVERAGE INTERVAL OF TIME REQUIRED TO   **\n**                     COMPLETE AN I/O ON THE CHECKPOINT DATA-SET.   **\n**                                                                   **\n**       \"DISCONNECT_TIME\" IS THE PERIOD OF TIME WE SHOULD WAIT      **\n**                     BEFORE CONCLUDING THAT ALL THE OTHER CPUS     **\n**                     THAT DID NOT REACH THE \"TRACK STATE\" ARE      **\n**                     NOT ACTIVE (SAY 500 SECONDS). MUST BE         **\n**                     HIGHER THAN \"LONG WAIT\".                      **\n**                                                                   **\n**       \"MAXCPU\"      IS THE MAXIMUM NUMBER OF CPU'S TO BE          **\n**                     SYNCHRONIZED TOGETHER.                        **\n**                                                               -EU-**\n**       \"SYNCH_METHOD\" IS THE SYNCHRONIZATION METHOD NUMBER TO BE   **\n**                     USED : 1 = THE CPU WHICH RESET CHECKPOINT     **\n**                                SET THE BASE CLOCK VALUE.          **\n**                      DEFAULT = THE CPU WHICH HAS THE HIGHEST      **\n**                                CLOCK VALUE IN THE COMPLEX.        **\n**                                                               -EU-**\n**       \"SNAP_ID\"     IS THE SNAP-DUMP ID'S (0-255) TO SET ACTIVE   **\n**       \"SNAP_IDS\"    (NEEDS \"SYSSNAP\" FILE ALLOCATED).             **\n**                                                                   **\n***********************************************************************\n         EJECT\n***********************************************************************\n**                                                                   **\n**       NOTES :                                                     **\n**       -------                                                     **\n**           THE \"DASD\" DEVICE IS POINTED TO BY THE DDNAME           **\n**       \"SYSCKPT\". ONE TRACK IS A SUFFICENT ALLOCATION.             **\n**                                                                   **\n**           CPU IDENTIFIER IS TAKEN FROM \"SMCA\" AND THE LAST        **\n**       CHARACTER IS USED TO DETERMINE ENTRY OFFSET IN CHECKPOINT.  **\n**       SEE THE DESCRIPTION OF OPERANDS FOR THE SETCGEN MACRO FOR   **\n**       AN EXPLANATION OF INSTALLATION TAILORING OPTIONS. THE       **\n**       SETCLOCK PROGRAM ASSUMES THAT THE SMF SYSTEM ID FOR EACH    **\n**       SYSTEM CONTAINS A UNIQUE 1 CHARACTER IDENTIFIER LOCATED     **\n**       AT A CONSISTENT OFFSET. IF THIS IS NOT TRUE FOR YOUR        **\n**       INSTALLATION, THE CPU IDENTIFICATION CODE WILL HAVE TO      **\n**       BE ALTERED (SEE LABEL SCGSID).                              **\n**                                                                   **\n**       THE 'PARM' FIELD OF THE PROGRAM CAN BE USED TO RESET THE    **\n**       CHECKPOINT RECORD BY CODING :                               **\n**                      EXEC PGM=SETCLOCK,PARM='RESET'               **\n**              IN THAT CASE, CHECKPOINT RECORD WILL BE INITIALIZED  **\n**              AND WRITTEN TO THE CHECKPOINT DATA-SET.              **\n**       OR IT CAN BE USED TO REQUEST ONLY THE SCAN OF THE       -EU-**\n**       INPUT PARAMETERS BY CODING :                            -EU-**\n**                      EXEC PGM=SETCLOCK,PARM='SCAN'            -EU-**\n**              IN THAT CASE, THE EXECUTION TERMINATES AS SOON   -EU-**\n**              AS THE PARAMETERS ARE SCANNED.                   -EU-**\n**                                                                   **\n*****************************************************************-EU-**\n**       DEFINED SNAP-DUMP ID'S IN THE PROGRAM :                 -EU-**\n**       ***************************************                 -EU-**\n**                                                                   **\n**       NO. - SNAP AREA         - SNAP POINT                    -EU-**\n**       ---   -----------------   ---------------------------   -EU-**\n**         1 - CHECKPOINT RECORD - INVALID DISCREPANCY           -EU-**\n**       255 - STORAGE WORK AREA - PROGRAM TERMINATION           -EU-**\n**                                                                   **\n***********************************************************************\n         EJECT\n         MACRO\n&LABEL   SETCGEN &SID,&SIDCHAR=4,&CKPTDD=SYSCKPT,&PARMDD=SYSPARM,      X\n               &DISCTIM=15\n.**********************************************************************\n.**                                                                  **\n.**  SETCLOCK GENERATION MACRO : THIS MACRO IS PROVIDED FOR THE      **\n.**                  EASY TAILORING OF THE SETCLOCK PROGRAM TO A     **\n.**                  USER'S ENVIRONMENT.                             **\n.**                                                                  **\n.**  OPERANDS :                                                      **\n.**      &SID      : A LIST, ENCLOSED IN PARENTHESES, OF ALL SMF     **\n.**                  SYSTEM IDS IN THE COMPLEX. THIS LIST IS         **\n.**                  MANDATORY, AND MUST CONTAIN FROM 2 TO 8         **\n.**                  ENTRIES.                                        **\n.**      &SIDCHAR  : THE CHARACTER POSITION (FROM 1 TO 4) OF A       **\n.**                  CHARACTER IN EACH SMF SYSTEM ID WHICH           **\n.**                  UNIQUELY IDENTIFIES EACH CPU.                   **\n.**      &CKPTDD   : THE DDNAME TO BE ASSIGNED TO THE                **\n.**                  DASD-RESIDENT CHECKPOINT DATA-SET.              **\n.**      &PARMDD   : THE DDNAME TO BE ASSIGNED TO THE SETCLOCK       **\n.**                  PARAMETER DATA-SET.                             **\n.**      &DISCTIM  : THE TIME IN MINUTES OF THE LARGEST              **\n.**                  DISCREPANCY BETWEEN TOD CLOCK VALUES ALLOWED    **\n.**                  WITHOUT GENERATING A WARNING MESSAGE.           **\n.**                                                                  **\n.**********************************************************************\n         GBLC  &SYSCKPT            DDNAME FOR CHECKPOINT DATA-SET\n         GBLC  &SETPARM            DDNAME FOR PARAMTERS DATA-SET\n         GBLC  &MAXDISC            MAXIMUM DISCREPANCY ALLOWED    V1.01\n.*                                 IN MINUTES BEFORE ISSUING MSG  V1.01\n         GBLC  &SYSID(8)           SINGLE CHARACTER\n.*                                 CPU IDENTIFIER TAKEN FROM SMCA\n.*                                 USED TO IDENTIFY SYSTEM.\n         GBLA  &MAXCPU             MAX NUMBER OF CPU'S TO BE SYNCHRON.\n         GBLC  &OFFSET             OFFSET OF UNIQUE CHAR IN SMF SYSID\n         LCLA  &N,&I\n         AIF   (N'&SID GE 2 AND N'&SID LE 8).SIDOK\n         MNOTE 8,'SYSTEM ID LIST ''&SID'' INVALID.  AT LEAST 2 SYSTEM IX\n               D''S REQUIRED, WITH A MAXIMUM OF 8.)'\n         MEXIT\n.SIDOK   AIF   ('&SIDCHAR' GE '1' AND '&SIDCHAR' LE '4').GOODCHR\n         MNOTE 4,'SIDCHAR VALUE &SIDCHAR INVALID. 4 ASSUMED.'\n&OFFSET  SETC  '4'\n         AGO   .SETCPU\n.GOODCHR ANOP\n&OFFSET  SETC  '&SIDCHAR'\n&I       SETA  &OFFSET\n.SETCPU  ANOP\n&MAXCPU  SETA  N'&SID\nMAXCPUD  EQU   &MAXCPU             MAXIMUM NUMBER OF CPU'S SUPPORTED\n&N       SETA  1\n.SYSLOOP ANOP\n&SYSID(&N) SETC '&SID(&N)'(&I,1)\n&N       SETA  &N+1\n         AIF   (&N LE &MAXCPU).SYSLOOP\n&I       SETA  &I-1\n&OFFSET  SETC  '&I'\n         MNOTE *,'SETCLOCK CURRENTLY GENERATED TO SUPPORT A MAXIMUM OF X\n               &MAXCPU CPU''S'\n         MNOTE *,'UNIQUE SYSTEM IDENTIFIER LOCATED AT SMCASID+&OFFSET..X\n               '\n&MAXDISC SETC  '&DISCTIM'\n         MNOTE *,'MAXIMUM TOD CLOCK DIFFERENCE WITHOUT GENERATION OF A X\n               WARNING MESSAGE IS &MAXDISC MIN.'\n&SYSCKPT SETC  '&CKPTDD'\n         MNOTE *,'DASD CHECKPOINT DDNAME SET TO &SYSCKPT..'\n&SETPARM SETC  '&PARMDD'\n         MNOTE *,'PARAMETER LIBRARY DDNAME SET TO &SETPARM..'\n         MEND\n         SPACE 5\n         MACRO\n&LABEL   SETCTRT\n         GBLA  &MAXCPU\n         GBLC  &SYSID(8)\n         LCLA  &I\n&LABEL   DC    256X'00'            TRANSLATE TABLE TO DEFINE SYSID'S\n&I       SETA  1\n.SYSLOOP ORG   &LABEL+C'&SYSID(&I)' SYS ID CHAR OFFSET IN TABLE\n         DC    AL1(&I)             SYSTEM NUMBER\n&I       SETA  &I+1\n         AIF   (&I LE &MAXCPU).SYSLOOP\n         ORG   ,                   RESET ORDINAL COUNTER\n         MEND\n         EJECT\n         MACRO\n&LABEL   $SUB  &LOCAL,&LOCLN,&TERMIN=NO\n.**********************************************************************\n.**                                                                  **\n.**  $SUB : SUBROUTINE ENTRY POINT MACRO DEFINITION.                 **\n.**                                                                  **\n.**  OPERANDS :                                                      **\n.**      &LOCAL    : LOCAL VARIABLES DSECT NAME                      **\n.**      &LOCLN    : LOCAL VARIABLES DSECT LENGTH                    **\n.**      &TERMIN   : IF YES (OR NOTHING) SPECIFIED, THIS SUBROUTINE  **\n.**                  DOES NOT CALL OTHER SUBROUTINES                 **\n.**                                                                  **\n.**********************************************************************\n         GBLC  &ALLOCLN            GETMAINED AREA LENGTH\n&ALLOCLN SETC  '0'                 RESET LENGTH TO ZERO\n         AIF   (T'&LABEL EQ 'O').ERROR1\n&LABEL   CSECT ,                   SUBROUTINE ENTRY POINT\n         STM   R14,R12,12(RSAVE)   SAVE REGISTERS\n         PUSH  USING               SAVE USING STATUS\n         LR    RSUB,RENTRY         LOAD BASE REGISTER\n         USING &LABEL,RSUB         SETUP SUBROUTINE ADDRESSABILITY\n         AIF   ('&TERMIN' NE 'NO').TERMIN\n&ALLOCLN SETC  '18*4'              ALLOCATE AT LEAST A SAVE AREA\n         AIF   (T'&LOCAL EQ 'O').GETMAIN\n         AIF   (T'&LOCLN EQ 'O').ERROR2\n.ALLOCDS ANOP                      ALLOCATE LOCAL VARIABLES STORAGE\n&ALLOCLN SETC  '&ALLOCLN+&LOCLN'   SET TOTAL LENGTH TO ALLOCATE\n.**********************************************************************\n.*       ISSUE GETMAIN FOR LOCAL VARIABLES AND SAVE AREA              *\n.**********************************************************************\n.GETMAIN LA    R0,&ALLOCLN         GET TOTAL DSECT LENGTH\n         GETMAIN R,                ALLOCATE STORAGE                    *\n               LV=(0)              + OF LENGTH SPECIFIED BY R0\n         ST    RSAVE,4(R1)         CHAIN SAVE AREAS\n         ST    R1,8(RSAVE)         + FORWARD AND BACKWARD\n         LM    R14,R1,12(RSAVE)    RELOAD PARAMETER REGISTERS      -EU-\n         L     RSAVE,8(RSAVE)      + AND POINT TO NEW SAVE AREA\n         AIF   (T'&LOCAL NE 'O').USING\n         MEXIT\n.USING   USING &LOCAL-(18*4),RSAVE ESTABLISH DSECT ADDRESSABILITY\n         MEXIT\n.TERMIN  AIF   (T'&LOCAL NE 'O').ALLOCDS\n         MEXIT\n.**********************************************************************\n.*       ERROR MESSAGES                                               *\n.**********************************************************************\n.ERROR1  MNOTE 8,'SUBROUTINE NAME  MUST BE SPECIFIED'\n         MEXIT\n.ERROR2  MNOTE 8,'DSECT LENGTH MUST BE SPECIFIED FOR LOCAL VARIABLES'\n         MEND\n         SPACE 5\n         MACRO\n&LABEL   $SUBRET ,                 PROTOTYPE DEFINITION\n.*********************************************************************\n.**                                                                 **\n.**  $SUBRET : RETURN FROM SUBROUTINE.                              **\n.**                                                                 **\n.*********************************************************************\n         GBLC  &ALLOCLN            ALLOCATION LENGTH\n         AIF   (T'&LABEL EQ 'O').NOLABEL\n&LABEL   DS    0H                  RETURN TO CALLER\n.NOLABEL AIF   ('&ALLOCLN' NE '0').FREE\n         ST    RCODE,12+4(RSAVE)   SAVE RETURN CODE\n         AGO   .TERM               PROCESS A TERMINAL SUBROUTINE RETURN\n.FREE    LA    R0,&ALLOCLN         GET TOTAL DSECT LENGTH\n         LR    R1,RSAVE            LOAD STORAGE ADDRESS\n         L     RSAVE,4(RSAVE)      GET PREVIOUS SAVE AREA POINTER\n         ST    RCODE,12+4(RSAVE)   SAVE RETURN CODE\n         FREEMAIN R,               FREE STORAGE                        *\n               LV=(0),             + OF LENGTH SPECIFIED BY R0         *\n               A=(1)               + AND ADDRESS IN REGISTER 1\n.TERM    LM    R14,R12,12(RSAVE)   RELOAD REGISTERS\n         B     0(RCODE,RLINK)      + AND RETURN TO CALLER\n         POP   USING               FORGET SUBROUTINE ADDRESSABILITY\n         MEND\n         EJECT\n         MACRO\n&LABEL   SCANTCB &DSECT=YES,&LIST=NO\n         PUSH  PRINT\n         PRINT OFF\n         AIF   ('&LIST' NE 'YES').NOPRINT\n         PRINT ON,GEN,NODATA\n***********************************************************************\n**                                                                   **\n**       ------------------  S C A N T C B  ------------------       **\n**                                                                   **\n**           SCAN TEXT CONTROL BLOCK IS USED FOR PASSING             **\n**       INFORMATION RELATED TO ANALYSE TEXT BUFFER.                 **\n**                                                                   **\n**           ON FIRST CALL, FOLLOWING HAS TO BE DONE :               **\n**           -- ZERO OUT ALL CONTROL BLOCK                           **\n**           -- FILL SBTXT AND SBTXTLN FIELDS                        **\n**                                                                   **\n***********************************************************************\n.NOPRINT AIF   ('&DSECT' EQ 'YES').DSECT\nSCANTCB  DS    0D\n         AGO   .NODSECT\n.DSECT   ANOP\nSCANTCB  DSECT\n.NODSECT AIF   ('&LABEL' EQ '').NEQ\n&LABEL   DS    0D\n.NEQ     ANOP\nSBTXTBUF DS    CL88                TEXT BUFFER (FOR CARD IMAGE)\n         ORG   SBTXTBUF            POINT TO BEGINNING OF BUFFER\nSBTXTLN  DC    H'0'                TEXT LENGTH STARTING FROM\n*                                  + SBTXTA (FIRST CHARACTER ADDRESS)\nSBTXTOFS DC    H'0'                OFFSET TO OBTAIN NEXT CHARACTER\n*                                  + FOLLOWING LAST PROCESSED TOKEN.\nSBATOMA  DC    A(0)                POINTER TO FIRST CHARACTER FOLLOWING\n*                                  + PROCESSED TOKEN\nSBTXT    DC    CL80' '             TEXT CARD\nSBGBUF   DC    XL80'00',X'00'      GROUP BUFFER THAT CONTAINS AN\n*                                  + IMAGE OF SBTXT, BUT REPLACING EACH\n*                                  + CHARACTER BY ASSOCIATED GROUP\n*                                  + LAST BYTE IS X'00'\nSBSFLG1  DS    FL1                 FLAGS BYTE\nSBFNEW   EQU   B'00000001'         -- USED BY SCAN ROUTINE\nSBSCNR15 DS    3F                  REGISTERS 15-0-1 UPON SCAN RETURN\n         CNOP  0,8                                                 -EU-\nSCANDLN  EQU   *-SCANTCB           DSECT LENGTH\n         POP   PRINT\n         MEND\n         EJECT\n***********************************************************************\n**                                                                   **\n**  SEND : SEND A MESSAGE MACRO.                                 -EU-**\n**  SENDR : SEND A MESSAGE AND WAIT A REPLY MACRO.               -EU-**\n**  GENMS : DEFINE A MESSAGE MACRO.                              -EU-**\n**                                                                   **\n***********************************************************************\n         SPACE 2                                                   -EU-\n         MACRO\n&LABEL   SEND  &MSID               PROTOTYPE DEFINITION\n&LABEL   L     R1,=A(&MSID)        MESSAGE POINTER                 -EU-\n         CALL  MSSEND              SEND MESSAGE                    -EU-\n         MEND\n         SPACE 2                                                   -EU-\n         MACRO                                                     -EU-\n&LABEL   SENDR &MSID               PROTOTYPE DEFINITION            -EU-\n         CNOP  0,4                                                 -EU-\n&LABEL   B     *+L'*+4                                             -EU-\n         DC    0F'0',XL1'80',AL3(&MSID)                            -EU-\n         L     R1,*-4              MESSAGE POINTER                 -EU-\n         CALL  MSSEND              SEND MESSAGE AND WAIT REPLY     -EU-\n         MEND                                                      -EU-\n         SPACE 2                                                   -EU-\n         MACRO                                                     -EU-\n&MSID    GENMS &MESS,&DC=4         PROTOTYPE DEFINITION            -EU-\n         LCLC  &X                                                  -EU-\n&X       SETC  'IHB'.'&SYSNDX'                                     -EU-\n&X       WTO   &MESS,ROUTCDE=(2),DESC=(&DC),MF=L                   -EU-\n&MSID    EQU   &X-MSDATA                                           -EU-\n         SPACE 1                                                   -EU-\n         MEND                                                      -EU-\n         EJECT                                                     -EU-\n***********************************************************************\n**                                                                   **\n**  @SNDMP : CALL SNAP-DUMP MACRO.                               -EU-**\n**                                                                   **\n***********************************************************************\n         SPACE 1                                                   -EU-\n         MACRO                                                     -EU-\n&LABEL   @SNDMP &A,&L,&SNID=0      PROTOTYPE DEFINITION            -EU-\n         LCLA  &IDN                                                -EU-\n         AIF   (&SNID LE 255).OK                                   -EU-\n         MNOTE 4,' ---> SNAP-ID ERROR (SET TO ZERO) *** *** ***'   -EU-\n&IDN     SETA  0                                                   -EU-\n         AGO   .SN                                                 -EU-\n.OK      ANOP                                                      -EU-\n&IDN     SETA  &SNID                                               -EU-\n.SN      ANOP                                                      -EU-\n&LABEL   LA    R1,&A               SNAP ADDRESS                    -EU-\n         L     R15,=V(SNDMP)       GET ENTRY ADDRESS               -EU-\n         BASR  R14,R15             GO DO SNAP REQUESTED            -EU-\n         DC    AL1(&SNID),AL3(&L)  SNAP-ID - SNAP LENGTH           -EU-\n         MEND                                                      -EU-\n         TITLE '-- SYMBOLIC VARIABLES --'\nSETCLOCK START 0                                                   -EU-\n         SPACE 1                                                   -EU-\nSETCLOCK AMODE 24                                                  -EU-\nSETCLOCK RMODE 24                                                  -EU-\n         SPACE 1                                                   -EU-\n***********************************************************************\n**                                                                   **\n**       GLOBAL AND LOCAL SYMBOLIC VARIABLES DEFINITIONS             **\n**                                                                   **\n***********************************************************************\n         SPACE 1\n         GBLC  &SYSCKPT            DDNAME FOR CHECKPOINT DATA-SET\n         GBLC  &SETPARM            DDNAME FOR PARAMTERS DATA-SET\n         GBLC  &MAXDISC            MAXIMUM DISCREPANCY ALLOWED    V1.01\n*                                  IN MINUTES BEFORE ISSUING MSG  V1.01\n         GBLC  &OFFSET             SMCASID OFFSET OF UNIQUE ID CHAR\n         SPACE 2\n***********************************************************************\n**                                                                   **\n**       SYMBOLIC VARIABLES INITIALISATION                           **\n**                                                                   **\n***********************************************************************\n         SPACE 1\n         SETCGEN (SYSA,SYSB,SYSC,SYSD,SYSE)  SET GEN PARAMETERS    -EU-\n         SPACE 1\n***********************************************************************\n**                                                                   **\n**       PARMLIB DATA-SET DEFAULT PARAMETERS                         **\n**                                                                   **\n***********************************************************************\n         SPACE 1\n*        MAXCPU DETERMINED FROM SETCGEN MACRO\nDISTIME  EQU   12000      DEFAULT DISC TIME  100TH OF A SECOND (2 MIN.)\nLONGWT   EQU   6000       DEFAULT LONG WAIT  100TH OF A SECOND (1 MIN.)\nTRAKWT   EQU   200        DEFAULT TRACK WAIT 100TH OF A SECOND (2 SEC.)\nSEKTIM   EQU   2          DEFAULT SEEK TIME  100TH OF A SECOND (20 MS.)\n         SPACE 1                                                   -EU-\n*******************************************************************-EU-\n**                                                                 -EU-\n**       SNAP-ID'S STACKS                                          -EU-\n**                                                                 -EU-\n*******************************************************************-EU-\n         SPACE 1                                                   -EU-\nSNSTCKS  EQU   20         MAX. NO. OF K FOR SNAP-DUMP STACKS       -EU-\nSTCKSL   EQU   SNSTCKS*1024  STACKS ARRAY LENGTH                   -EU-\n         TITLE '-- R E G I S T E R     D E F I N I T I O N S --'\n***********************************************************************\n**                                                                   **\n**       ABSOLUTE REGISTER DEFINITIONS :                             **\n**                                                                   **\n***********************************************************************\n         SPACE 1\nR0       EQU   0                  + GENERAL REGISTER 0\nR1       EQU   1                  + GENERAL REGISTER 1\nR2       EQU   2                  + GENERAL REGISTER 2\nR3       EQU   3                  + GENERAL REGISTER 3\nR4       EQU   4                  + GENERAL REGISTER 4\nR5       EQU   5                  + GENERAL REGISTER 5\nR6       EQU   6                  + GENERAL REGISTER 6\nR7       EQU   7                  + GENERAL REGISTER 7\nR8       EQU   8                  + GENERAL REGISTER 8\nR9       EQU   9                  + GENERAL REGISTER 9\nR10      EQU   10                 + GENERAL REGISTER 10\nR11      EQU   11                 + GENERAL REGISTER 11\nR12      EQU   12                 + GENERAL REGISTER 12\nR13      EQU   13                 + GENERAL REGISTER 13\nR14      EQU   14                 + GENERAL REGISTER 14\nR15      EQU   15                 + GENERAL REGISTER 15\n         SPACE 1\n***********************************************************************\n**                                                                   **\n**       SYMBOLIC REGISTERS DEFINITIONS :                            **\n**                                                                   **\n***********************************************************************\n         SPACE 1\nRPARM    EQU   R1                  O/S AND PROGRAM PARAMETER REGISTER\nRWORK    EQU   R11                 COMMON WORKAREA POINTER\nRBASE    EQU   R12                 BASE OF MAINLINE\nRSUB     EQU   R12                 BASE OF SUBROUTINES\nRSAVE    EQU   R13                 O/S SAVE AREA POINTER\nRLINK    EQU   R14                 O/S AND PROGRAM LINK REGISTER\nRENTRY   EQU   R15                 O/S AND PROGRAM ENTRY POINT REGISTER\nRCODE    EQU   R15                 O/S AND PROGRAM RETURN CODE REGISTER\n         SPACE 1\nRLINK2   EQU   R8                  PROGRAM SECOND LEVEL LINK REGISTER\nRBCKP    EQU   R9                  CHECKPOINT RECORD BASE REGISTER\nRSENTRY  EQU   R10                 BASE REGISTER FOR SYSTEM (IN CKPT)\n         SPACE 1\n***********************************************************************\n**                                                                   **\n**       GLOBAL EQUATES                                              **\n**                                                                   **\n***********************************************************************\n         SPACE 1\nZERO     EQU   0                   ZERO\nFF       EQU   X'FF'               X'FF' DEFINITION\n         TITLE ' -- I N I T I A L I Z A T I O N --'\n***********************************************************************\n**                                                                   **\n**       SAVE REGISTERS AND CHAIN SAVE AREAS                         **\n**                                                                   **\n***********************************************************************\n         SPACE 1\n         SAVE  (14,12),,SETCLOCK--&SYSDATE.--&SYSTIME\n         SPACE 1\n         LR    RBASE,RENTRY        LOAD BASE REGISTER\n         USING SETCLOCK,RBASE      TELL THE ASSEMBLER\n         LR    R2,RPARM            LOAD R2 WITH PARM REGISTER\n         LA    R0,WORKLEN          WORK AREA LENGTH\n         GETMAIN R,LV=(0)          ALLOCATE LOCAL WORK STORAGE\n         ST    RSAVE,4(R1)         *  CHAIN\n         ST    R1,8(RSAVE)         *  SAVE\n         LR    RWORK,R1            *  AREAS\n         USING WORK,RWORK          SET DSECT ADDRESSABILITY\n         LA    RSAVE,AREA          SET SAVEAREA POINTER\n         USING PSA,R0              SET PSA ADDRESSABILITY\n         LA    RBCKP,SCCKPNT       LOAD THE CHECKPOINT RECORD ADDRESS\n         USING CHECKPT,RBCKP       SET CHECKPOINT ADDRESSABILITY\n         EJECT\n***********************************************************************\n**                                                                   **\n**       INITIALIZE PROGRAM FLAGS AND CCW'S ADDRESSES                **\n**       DETERMINE AND PREPARE SNAP-DUMP PROCESS IF REQUESTED    -EU-**\n**                                                                   **\n***********************************************************************\n         SPACE 1\n         MVI   SCFLAGS,ZERO        CLEAR INITIAL FLAGS\n         STCM  RBCKP,B'0111',CPRBUF3\n         STCM  RBCKP,B'0111',CPRBUF2\n         LA    R1,SCCKCNT          POINT TO COUNT FIELD\n         STCM  R1,B'0111',CPWBUFA  SAVE IT IN CHANNEL PROGRAM\n         LA    R1,CKID             CHECKPOINT 'DATA' PORTION ADDRESS\n         STCM  R1,B'0111',CPRBUF1  STORE IT IN CCW\n         MVC   SCCKLEN,SCKLDL      MOVE KEY AND RECORD LENGTH\n         EXTRACT SCWTIOT,'S',FIELDS=(TIOT,TSO),MF=(E,SCWEXTR)      -EU-\n         XR    R0,R0               DETERMINE SNAP-DUMP REQUEST     -EU-\n         L     R1,SCWTIOT                                          -EU-\n         USING TIODSECT,R1                                         -EU-\n         L     R15,=A(SNAPCS)                                      -EU-\n         USING IHADCB,R15                                          -EU-\nSRSNAP   CLC   TIOELNGH(4),=XL4'0'                                 -EU-\n         BE    NOSNAP                                              -EU-\n         CLC   TIOEDDNM(L'DCBDDNAM),DCBDDNAM                       -EU-\n         BE    SETSNAP                                             -EU-\n         IC    R0,TIOELNGH                                         -EU-\n         ALR   R1,R0                                               -EU-\n         B     SRSNAP                                              -EU-\n         DROP  R1,R15                                              -EU-\nSETSNAP  OI    SCFLAGS,SCFSNAP     INDICATE IT                     -EU-\n         L     R0,=A(STCKSL)       GET STACKS ARRAY                -EU-\n         GETMAIN R,LV=(0)                                          -EU-\n         ST    R1,ASTCK            SET START ADDRESS               -EU-\n         ST    R1,CSTCK            SET CURRENT ADDRESS             -EU-\n         AL    R1,=A(STCKSL)                                       -EU-\n         ST    R1,LSTCK            SET LAST ADDRESS +1             -EU-\nNOSNAP   L     R1,SCWTSO                                           -EU-\n         TM    0(R1),X'80'         TSO ADDRESS SPACE ?             -EU-\n         BZ    *+L'*+4             NO                              -EU-\n         OI    SCFLAGS,SCFTEST     YES, INDICATE IT                -EU-\n         EJECT\n***********************************************************************\n**                                                                   **\n**       READ THE INPUT PARAMETERS FROM DDNAME \"SETPARM\"             **\n**                                                                   **\n***********************************************************************\n         SPACE 1\n         BAS   RLINK,READPARM      READ THE INPUT PARAMETERS\n         B     *+L'*+4             ERROR IN THE INPUT PARAMETERS\n         B     SCTEST              INPUT PARAMETERS ACCEPTED       -EU-\n         SPACE 1\n***********************************************************************\n**                                                                   **\n**       ERROR HAS BEEN DETECTED INPUT PARAMETERS, WRITE MSG & QUIT  **\n**                                                                   **\n***********************************************************************\n         SPACE 1\n         SEND  SCK0001E            ERROR DETECTED IN INPUT PARAMETERS\n         B     SCERR               GO PROCESS AFTER ERROR\n         SPACE 1                                                   -EU-\n***********************************************************************\n**                                                                   **\n**       CHECK MAX NUMBER OF CPU'S SPECIFIED                         **\n**                                                                   **\n***********************************************************************\n         SPACE 1                                                   -EU-\nSCTEST   CLC   SCPMAXC,=A(MAXCPUD) CHECKPOINT CAN HANDLE ?         -EU-\n         BNH   SCINIT              NO, PROCESS MAINLINE CODE       -EU-\n         SEND  SCK0020E            MAX NUMBER OF CPU'S EXCEEDED    -EU-\n         B     SCERR               GO PROCESS ERROR                -EU-\n         EJECT\n***********************************************************************\n**                                                                   **\n**       CHECK IF PARM 'RESET' IS SPECIFIED AND SET ACCORDING FLAG   **\n**       CHECK IF PARM 'SCAN' IS SPECIFIED AND EXIT              -EU-**\n**                                                                   **\n***********************************************************************\n         SPACE 1\nSCINIT   L     R1,0(R2)            LOAD PARM ADDRESS IN REGISTER ONE\n         XR    R0,R0               CLEAR WORK REGISTER\n         ICM   R0,B'0011',0(R1)    LOAD PARM LENGTH\n         BZ    SCOPEN              ZERO -- NO PARM WAS SPECIFIED\n         CL    R0,=A(L'SCANT)      COMPARE PARM LENGTH             -EU-\n         BNE   SCRST               NOT EQUAL -- LOOK TO NEXT       -EU-\n         OC    2(L'SCANT,R1),SCBL  CONVERT PARM FIELD TO UPPERCASE -EU-\n         CLC   SCANT,2(R1)         IS PARM EQUAL ?                 -EU-\n         BNE   SCERPARM            NOT EQUAL -- PARM ERROR         -EU-\n         SEND  SCK0025I            SCAN SPECIFIED -- TERMINATE     -EU-\n         B     SCRETN                                              -EU-\nSCRST    CL    R0,=A(L'RESET)      COMPARE PARM LENGTH             -EU-\n         BNE   SCERPARM            NOT EQUAL -- PARM ERROR\n         OC    2(L'RESET,R1),SCBL  CONVERT PARM FIELD TO UPPERCASE\n         CLC   RESET,2(R1)         IS PARM EQUAL ?\n         BE    SCRESET             YES, RESET THING\n         SPACE 1\n***********************************************************************\n**                                                                   **\n**       INVALID 'PARM' WAS ENCOUNTERED -- PRINT MSG & QUIT          **\n**                                                                   **\n***********************************************************************\n         SPACE 1\nSCERPARM SEND  SCK0008E            INVALID PARM WAS SPECIFIED\n         B     SCERR               QUIT WITH ERROR\n         EJECT\n***********************************************************************\n**                                                                   **\n**       RESET HAS BEEN SPECIFIED -- INIT RECORD AND SET FLAG        **\n**       ALSO TELL OPERATOR OF \"CHECKPOINT\" RESET                    **\n**                                                                   **\n***********************************************************************\n         SPACE 1\nSCRESET  SEND  SCK0016I            CHECKPOINT RECORD WILL BE RESET\n         XC    CHECKPT(CKLEN),CHECKPT\n*                                  ZERO OUT CHECKPOINT RECORD\n*                                  LOCK IS NOW FREE (IN BUFFER)\n         MVC   CKID,=CL4'CKPT'     MOVE RECORD ID\n         OI    SCFLAGS,SCFRESET    RESET HAS BEEN SPECIFIED\n         L     R1,SCPMAXC          GET MAX NUMBER OF CPU'S\n         STH   R1,CKNRCPU          THIS IS NUMBER OF RESIDUAL CPU'S\n         STH   R1,CKNACPU          POTENTIAL NUMBER OF ACTIVE CPU'S\n         LA    R2,CKSENTRY         GET SYSTEM ENTRIES ADDRESSES\n         USING CKSYS,R2            SET R2 AS BASE REGISTER\n         LA    R1,MAXCPUD          MAXIMUM NUMBER OF ENTRIES\nSCRLOOP  MVI   CKSSTAT,CKTDISC     SET SYSTEM AS 'DISCONNECTED'\n         LA    R2,L'CKSENTRY(R2)   POINT TO NEXT ENTRY\n         BCT   R1,SCRLOOP          RESET ALL SYSTEM ENTRIES\n         DROP  R2                  NO MORE USED\n         EJECT\n***********************************************************************\n**                                                                   **\n**       OPEN THE CHECKPOINT DATA-SET -- EXCP                        **\n**                                                                   **\n***********************************************************************\n         SPACE 1\nSCOPEN   OPEN  (SYSCKPT,OUTPUT)    OPEN CKPT OUTPUT MODE\n         TM    SYSCKPT+DCBOFLGS-IHADCB,DCBOFOPN\n*                                  DID THE DATA-SET OPENED PROPERLY ?\n         BO    SCGOODOP            YES, CONTINUE PROCESSING\n         SEND  SCK0006E            DASD DEVICE DID NOT OPEN PROPERLY\n         B     SCERR               GO PROCESS THE ERROR\n         EJECT\n***********************************************************************\n**                                                                   **\n**       OPEN WAS SUCCESSFUL -- ACKNOWLEGE SETCLOCK OPERATION        **\n**                           -- SAVE \"CC\" AND \"HH\" FOR I/O ROUTINE   **\n**                                                                   **\n***********************************************************************\n         SPACE 1\nSCGOODOP SEND  SCK0015I            CLOCKS SYNCHRONIZATION IN PROGRESS\n         LA    R2,SYSCKPT          GET DCB ADDRESS IN R2\n         USING IHADCB,R2           SET DCB ADDRESSABILITY\n         L     R2,DCBDEBAD         LOAD DEB ADDRESS\n         USING DEBBASIC,R2         SET BASIC ADDRESSABILITY\n         LA    R2,DEBBASND         LOAD SEGMENT ADDRESS\n         USING DEBDASD,R2          SET DASD SECTION ADDRESSABILITY\n         MVC   CPSEEKCC,DEBSTRCC   SET STARTING CYLINDER ADDRESS\n         MVC   CPSEEKHH,DEBSTRHH   SET STARTING HEAD NUMBER\n         MVI   CPSEEKR,1           SET STARTING RECORD TO '1'\n         MVC   SCCKID,CPSEEKCC     MOVE ID FOR WRITE\n         DROP  R2                  NO MORE USED\n         TITLE '-- M A I N L I N E     P R O C E S S I N G --'\n***********************************************************************\n**                                                                   **\n**       GET THE SYSTEM \"ID\" AND COMPUTE OUR ENTRY OFFSET IN THE     **\n**       CHECKPOINT RECORD. SAVE IT IN WORK AREA.                    **\n**                                                                   **\n***********************************************************************\n         SPACE 1\n         L     R1,FLCCVT           LOAD CVT ADDRESS\n         L     R1,CVTSMCA-CVT(,R1) LOAD SMCA ADDRESS\n         MVC   SCSYSID,SMCASID-SMCABASE(R1)\n*                                  AND SAVE CURRENT SYSID IN WORK AREA\n         XR    R2,R2               CLEAR WORK REGISTER\n         TRT   SCSYSID+&OFFSET.(1),SCXTBL SET R2 TO SYSTEM\n*                                  OFFSET IN RECORD\n         BNZ   SCCKSYS             BRANCH IF SMF SYSTEM ID KNOWN   -EU-\n         SEND  SCK0021E            ID NOT SUPPORTED                -EU-\n         B     SCERR               GO PROCESS ERROR                -EU-\nSCCKSYS  BCTR  R2,0                OBTAIN RELATIVE POSITION        -EU-\n         MH    R2,=Y(L'CKSENTRY)   THIS IS THE OFFSET OF OUR SYSID\n         LA    RSENTRY,CKSENTRY(R2) POINT TO OUR SYSTEM ENTRY\n         ST    RSENTRY,SCENTRYP    SAVE CPU ENTRY IN WORK AREA\n         USING CKSYS,RSENTRY       SET OUR ENTRY ADDRESSABILITY\n         EJECT\n***********************************************************************\n**                                                                   **\n**       OBTAIN THE LOCK AND READ THE CHECKPOINT RECORD              **\n**       -- IF RESET HAS BEEN SPECIFIED, SKIP THIS SECTION           **\n**                                                                   **\n***********************************************************************\n         SPACE 1\n         TM    SCFLAGS,SCFRESET    WAS RESET SPECIFIED?\n         BZ    SCRCKPT             NO                              -EU-\n         CLI   SCPMTHD+3,BASECPU   BASE CPU METHOD ?               -EU-\n         BNE   SCSETRQ             NO, SO DO NOT READ THE RECORD   -EU-\n         MVI   CKSREQ,CKTRFCPU     YES, INDICATE REFERENCE SYSTEM  -EU-\n         B     SCSETRQ             AND DO NOT READ THE RECORD      -EU-\nSCRCKPT  BAS   RLINK,SCGETREC      GET THE LOCK AND READ THE RECORD\n         B     SCERR               IF AN ERROR OCCURS\n         OC    CKSID,CKSID         ANY ONE ALREADY HERE ?          -EU-\n         BZ    SCCKOK              NO, SMF SYSTEM ID IS OK         -EU-\n         SEND  SCK0022E            DUPLICATE ID IN COMPLEX         -EU-\n         B     SCERR               GO PROCESS ERROR                -EU-\nSCCKOK   MVC   SCPMAXC+2(2),CKNACPU                           -EU-V1.04\n*                                  RESET IS NOT SPECIFIED, TAKE   V1.04\n*                                  MAX NUMBER OF CPU'S FROM CKPT  V1.04\n         EJECT\n***********************************************************************\n**                                                                   **\n**       SET THE REQUEST CODE TO \"TRACK\" --                          **\n**       NOTE THAT OUR STATUS WILL REMAIN AS \"DISCONNECTED\" OR WAIT  **\n**                                                                   **\n**       TEST IF THIS REQUEST IS TOO LATE (SYNCHRONIZATION STARTED)  **\n**       IF SO, WRITE MESSAGE AND TERMINATE EXECUTION                **\n**                                                                   **\n***********************************************************************\n         SPACE 1\nSCSETRQ  CLI   CKREQ,CKRLWAIT      IS ACTUAL REQUEST TO \"WAIT\" ?\n         BE    SCOKREQ             OK, CONTINUE\n         CLI   CKREQ,CKREND        IS ACTUAL REQUEST \"END\" ?\n         BE    SCOKREQ             OK, CONTINUE\n         CLI   CKREQ,CKRTRACK      IS ACTUAL REQUEST \"TRACK\" ?\n         BE    SCOKREQ             OK, CONTINUE\n         SEND  SCK0017I            TOO LATE FOR THIS CPU ...\n         SEND  SCK0017E            RETRY LATER OR RESET CHECKPOINT\n         B     SCERR               GO PROCESS THE ERROR\nSCOKREQ  MVI   CKREQ,CKRTRACK      SET REQUEST CODE TO TRACK\n         MVI   CKCREQ,CKCRTR       SET REQUEST CODE TO TRACK (CHAR)\n         MVC   CKSID,SCSYSID       MOVE OUR SYSTEM ID TO BUFFER\n         MVC   SCWTIME,SCPTRACK    SET WAITING TIME TO 'TRACK'\n         EJECT\n***********************************************************************\n**                                                                   **\n**       GET TIME AND DATE AND INITIALIZE REQUEST TIME AND DATE      **\n**                                                                   **\n***********************************************************************\n         SPACE 1\n         TIME  BIN                 SET TIME IN R0 AND DATE IN R1\n*                                  TIME IS IN BINARY 100TH OF SECONDS\n*                                  DATE IS IN FORMAT X'00YYDDDF'\n         STCM  R0,B'1111',CKSTIME  STORE REQUEST TIME IN BUFFER    -EU-\n         TM    SCFLAGS,SCFRESET    WAS RESET SPECIFIED?            -EU-\n         BZ    *+L'*+4             NO                              -EU-\n         STCM  R1,B'1111',CKRDATE  STORE REQUEST DATE IN BUFFER\n         SPACE 1\n***********************************************************************\n**                                                                   **\n**       WRITE THE RECORD AND FREE THE LOCK                          **\n**                                                                   **\n***********************************************************************\n         SPACE 1\n         BAS   RLINK,SCWRITE       WRITE THE RECORD\n*                                  THIS SECTION WRITES THE RECORD\n*                                  AND FREES THE LOCK BY WRITING A\n*                                  HARDWARE KEY OF X'0000000000000000'\n         B     SCERR               WHEN AN ERROR OCCURS\n         TITLE '-- STATE PROCESSING --'\n***********************************************************************\n**                                                                   **\n**       LOOP UNTIL ALL CPU'S REACH THE \"WANTED STATE\" OR IF THE     **\n**       DISCONNECT TIME IS EXPIRED (WHEN REQUEST IS TRACK)          **\n**                                                                   **\n***********************************************************************\n         SPACE 1\nSCTLOOP  LA    R1,SCWTIME          LOAD THE WAIT TIME ADDRESS\n         STIMER WAIT,              WAIT FOR TIME TO ELAPSE             *\n               BINTVL=(R1)         ADDRESS SPECIFIED BY R1\n         BAS   RLINK,SCGETREC      GET THE RECORD AND THE LOCK\n         B     SCERR               IF AN ERROR OCCURS\n         XR    R1,R1               CLEAR WORK REGISTER\n         IC    R1,CKREQ            INSERT REQUEST CODE\n         LA    RLINK,SCTWTR        SET RETURN ADDRESS TO 'WRITE'\n         B     *+L'*(R1)           GO PROCESSING ACCORDING TO REQUEST\n         B     SCTWTR              WAIT  -- WAIT FOR REQUEST\n         B     SCTREQ              TRACK -- TRACK REQUEST\n         B     SCLREQ              LOCK  -- LOCK REQUEST\n         B     SCSTIME             SET   -- SET TIME REQUEST\n         B     SCRETURN            END   -- RETURN TO CALLER\n         SPACE 1\n***********************************************************************\n**                                                                   **\n**       WRITE OUT THE RECORD AND RESET THE LOCK                     **\n**                                                                   **\n***********************************************************************\n         SPACE 1\nSCTWTR   BAS   RLINK,SCWRITE       WRITE THE RECORD\n         B     SCERR               IF AN ERROR OCCURS\n         B     SCTLOOP             LOOP AGAIN\n         TITLE '-- PROCESS A TRACK REQUEST --'\n***********************************************************************\n**                                                                   **\n**       \"TRACK REQUEST\"                                             **\n**                                                                   **\n**       ON ENTRY, STATE MIGHT BE \"DISCONNECTED\" (IF FIRST CALL )    **\n**                                \"SET\"          (IF WAS IN WAIT)    **\n**                                \"TRACKED\"      (IF PROCESSING )    **\n**                                                                   **\n***********************************************************************\n         SPACE 1\nSCTREQ   ST    RLINK,RLSAVE        SAVE RETURN REGISTER            -EU-\n         CLI   CKSSTAT,CKTTRACK    ALREADY TRACKED ?\n         BE    SCTCKDIS            YES, CHECK IF DISCONNECTED\n         MVC   SCWTIME,SCPTRACK    SET WAIT TIME TO \"TRACK\" IN CASE\n*                                  WE WERE IN \"WAIT STATE\" BEFORE\n         LH    R1,CKNRCPU          NUMBER OF RESIDUAL CPU'S\n         BCT   R1,SCTNOTL          IF NOT LAST ONE\n         SPACE 1\n***********************************************************************\n**                                                                   **\n**       WE ARE THE LAST CPU TO GET 'TRACK REQUEST'                  **\n**                                                                   **\n***********************************************************************\n         SPACE 1\n         SEND  SCK0012I            ALL CPU'S WILL BE SYNCHRONIZED\n         MVI   CKREQ,CKRLOCK       ASK TO OBTAIN LOCK\n         MVI   CKCREQ,CKCRTL       ALSO CHAR REQUEST\n         L     R1,SCPMAXC          GET MAX NUMBER OF CPU'S\n         STH   R1,CKNACPU          THIS IS NUMBER OF ACTIVE CPU\"S\n         B     SCTLOCK             AND PROCESS TO GET LOCK STATE\n         SPACE 1\n***********************************************************************\n**                                                                   **\n**       WE ARE NOT THE LAST TO GET TRACK STATE                      **\n**                                                                   **\n***********************************************************************\n         SPACE 1\nSCTNOTL  STH   R1,CKNRCPU          SAVE NUMBER OF RESIDUAL CPU'S\n         MVI   CKSSTAT,CKTTRACK    OUR STATUS IS TRACK\n         BR    RLINK               RETURN WRITE RECORD\n         EJECT\n***********************************************************************\n**                                                                   **\n**       \"TRACK REQUEST\" CHECK IF TIME IS EXPIRED                    **\n**                                                                   **\n***********************************************************************\n         SPACE 1\nSCTCKDIS TIME  BIN                 SET TIME IN R0 AND DATE IN R1\n*                                  TIME IS IN BINARY 100TH OF SECONDS\n*                                  DATE IS IN FORMAT X'00YYDDDF'\n         CLI   CKRDATE+L'CKRDATE-1,0    DATE ALREADY SET ?         -EU-\n         BE    *+L'*+8             NO, BYPASS DATE CHECK           -EU-\n         CL    R1,CKRDATE          SAME DATE ?                     -EU-\n         BNE   SCTDERR             NO, LOOP AGAIN                  -EU-\n         S     R0,CKSTIME          GET TIME DISCREPANCY            -EU-\n         C     R0,SCPDISC          CPU'S DISCONNECTED?\n         BNH   SCTRRET             NO, LOOP AGAIN                  -EU-\n         SPACE 1\n***********************************************************************\n**                                                                   **\n**       DISCONNECT TIME HAS EXPIRED -- SET NUMBER OF ACTIVE CPU'S   **\n**       AND ASK FOR A \"LOCK\" REQUEST                                **\n**                                                                   **\n***********************************************************************\n         SPACE 1\n         SEND  SCK0013I            DISCONNECT TIME HAS EXPIRED\n         B     SCTCONT                                             -EU-\nSCTDERR  SEND  SCK0004I            DISCONNECT DATE ERROR           -EU-\n         OI    SCFLAGS,SCFDTERR    INDICATE DATE ERROR             -EU-\nSCTCONT  SEND  SCK0015E            PARTIAL SYNCHRONIZATION WILL BE DONE\n         MVI   CKREQ,CKRLOCK       NEW REQUEST IS TO LOCK\n         MVI   CKCREQ,CKCRTL       SET CHAR REQUEST\n         L     R1,SCPMAXC          LOAD MAX NUMBER OF CPU'S\n         SH    R1,CKNRCPU          SUBSTRACT RESIDUAL\n         STH   R1,CKNACPU          SAVE NUMBER OF ACTIVE CPU'S\nSCTLOCK  BCTR  R1,0                NUMBER OF RESIDUAL CPU'S TO LOCK\n         STH   R1,CKNRCPU          SAVE IT IN CHECKPOINT RECORD\n         MVI   CKSSTAT,CKTLOCK     SET OUR STATUS TO 'LOCK'\n         SPACE 1\n***********************************************************************\n**                                                                   **\n**       COMPUTE WAIT TIME FOR LOCK STATE (SEEK*NACPU)               **\n**                                                                   **\n***********************************************************************\n         SPACE 1\n         L     R0,SCPSEEK          GET SEEK TIME\n         MH    R0,CKNACPU          AND MULTIPLY BY NUMBER OF ACTIVE\n*                                  CPU'S\n         ST    R0,SCPLOCK          THIS IS THE LOCK TIME\n         MVC   SCWTIME,SCPLOCK     SET WAIT TIME TO 'LOCK'\n         SPACE 1\n***********************************************************************\n**                                                                   **\n**       DETERMINE IF WE ARE THE ONLY ACTIVE CPU --                  **\n**       WRITE A MESSAGE AND GO INTO A LONG WAIT IF SO               **\n**                                                                   **\n***********************************************************************\n         SPACE 1\n         LTR   R1,R1               IS NUMBER OF RESIDUAL CPU'S ZERO ?\n         BNZ   SCTRRET             NO, SO QUIT + WRITE BACK CKPT   -EU-\n         SEND  SCK0010I            NO OTHER ACTIVE CPU FOUND\n         TM    SCFLAGS,SCFDTERR    DATE ERROR ?                    -EU-\n         BO    RPNOWT              YES                             -EU-\n         SEND  SCK0010W            WAITING FOR SYNCHRONIZATION\n         SENDR SCK0010A            ASK IF SO ?                     -EU-\n         B     RPWAIT              YES                             -EU-\n         B     RPNOWT              NO                              -EU-\n         SEND  SCK0010D            TERMINAL ERROR, NO ASSUMED      -EU-\nRPNOWT   MVI   CKREQ,CKREND        REQUEST IS TO END               -EU-\n         MVI   CKCREQ,CKCRND       REQUEST IS TO END (CHAR)        -EU-\n         MVC   CKNRCPU,CKNACPU     NUMBER OF RESIDUAL IS AS ACTIVE -EU-\n         B     SCTRRET             QUIT + WRITE BACK CKPT          -EU-\nRPWAIT   MVC   SCWTIME,SCPWAIT     SET TIME TO WAIT\n         MVI   CKREQ,CKRLWAIT      REQUEST IS TO WAIT\n         MVI   CKCREQ,CKCRLW       SO IS CHAR REQUEST\n         MVI   CKSSTAT,CKTWAIT     SET OUR STATUS TO \"LONG WAIT\"\n         L     R1,SCPMAXC          LOAD MAX NUMBER OF CPU'S\n         STH   R1,CKNACPU          SAVE IT IN CHECKPOINT\n         STH   R1,CKNRCPU          ALSO SAVE RESIDUAL NUMBER\nSCTRRET  L     RLINK,RLSAVE        RESTORE RETURN REGISTER         -EU-\n         BR    RLINK               AND RETURN WRITE THE CKPT RECORD\n         TITLE '-- PROCESS A LOCK REQUEST --'\n***********************************************************************\n**                                                                   **\n**       LOCK REQUEST                                                **\n**                                                                   **\n***********************************************************************\n         SPACE 1\nSCLREQ   TM    CKFLAGS,CKFLOCK     ARE ALL CPU'S LOCKED ?\n         BO    SCLTIME             YES, PROCESS AFTER ALL ARE LOCKED\n         CLI   CKSSTAT,CKTLOCK     ARE WE ALREADY LOCKED?\n         BER   RLINK               YES, SO RETURN TO CALLER\n         SPACE 1\n***********************************************************************\n**                                                                   **\n**       COMPUTE WAIT TIME FOR LOCK STATE (SEEK*NACPU)               **\n**                                                                   **\n***********************************************************************\n         SPACE 1\n         L     R0,SCPSEEK          GET SEEK TIME\n         MH    R0,CKNACPU          AND MULTIPLY BY NUMBER OF ACTIVE\n*                                  CPU'S\n         ST    R0,SCPLOCK          THIS IS THE LOCK TIME\n         MVC   SCWTIME,SCPLOCK     SET WAIT TIME TO 'LOCK'\n         MVI   CKSSTAT,CKTLOCK     STATUS IS 'LOCKED'\n         LH    R1,CKNRCPU          NUMBER OF RESIDUAL CPU'S TO LOCK\n         BCT   R1,SCLCNT           NOT THE LAST, CONTINUE\n         SPACE 1\n***********************************************************************\n**                                                                   **\n**       WE WERE THE LAST CPU TO GET 'LOCKED'                        **\n**                                                                   **\n***********************************************************************\n         SPACE 1\n         MVC   CKNRCPU,CKNACPU     THIS NUMBER OF RESIDUAL I/O BEFORE\n*                                  SET IS REACH\n         STCK  CKSYSCLK            MOVE CLOCK TO CHECKPOINT\n         BAS   RLINK2,SCCNORM      GO NORMALIZE THE CLOCK\n         LH    R1,CKNACPU          GET NUMBER OF ACTIVE CPU'S\n         BCTR  R1,0                SUBSTRACT ONE FROM IT (US)\n         STH   R1,CKNRCPU          THIS NUMBER TO GET \"TIME\" MODE\n         MVI   CKSSTAT,CKTTIME     SET OUR MODE TO \"TIME\"\n         OI    CKFLAGS,CKFLOCK     AND INDICATE ALL CPU'S LOCKED\n         BR    RLINK               GO BACK WRITE THE RECORD\nSCLCNT   STH   R1,CKNRCPU          NUMBER OF RESIDUAL CPU'S TO GO\n         BR    RLINK               RETURN WRITE THE RECORD\n         SPACE 1\n***********************************************************************\n**                                                                   **\n**       ALL CPU'S ARE LOCKED -- TIME SHOULD BE WRITTEN TO CKPT      **\n**       TO DETERMINE THE ONE WHO GETS THE \"BASE\" CLOCK.             **\n**                                                                   **\n***********************************************************************\n         SPACE 1\nSCLTIME  CLI   CKSSTAT,CKTTIME     WE ALREADY GOT TIME MODE ?\n         BNE   SCLREF              NO SO GO REFRESH CHECKPOINT\n         SPACE 1\n***********************************************************************\n**                                                                   **\n**       TIME MODE HAS ALREADY BEEN REACHED PRIOR TO NOW --          **\n**       THIS MEANS THAT CPU'S DID NOT READ THE CHECKPOINT           **\n**       IN SEQUENTIAL ORDER, SO TIME ACCURACY HAS BEEN LOST         **\n**       IN TIME ESTIMATION                                          **\n**                                                                   **\n**       WRITE A WARNING MESSAGE AND CONTINUE PROCESSING             **\n**                                                                   **\n***********************************************************************\n         SPACE 1\n         ST    RLINK,RLSAVE        SAVE RETURN REGISTER            -EU-\n         SEND  SCK0011I            TIME EST. MIGHT NOT BE ACCURATE\n         L     RLINK,RLSAVE        RESTORE RETURN REGISTER         -EU-\n         BR    RLINK               CONTINUE PROCESSING\n         SPACE 1\n***********************************************************************\n**                                                                   **\n**       REFRESH THE TIME IN CHECKPOINT RECORD                       **\n**                                                                   **\n***********************************************************************\n         SPACE 1\nSCLREF   STCK  CKSYSCLK            MOVE CLOCK TO CHECKPOINT RECORD\n         BAS   RLINK2,SCCNORM      GO NORMALIZE THE CLOCK\n         MVI   CKSSTAT,CKTTIME     SET OUR MODE TO \"TIME REFRESHED\"\n         LH    R1,CKNRCPU          NUMBER OF RESIDUAL CPU'S TO REFRESH\n         BCT   R1,SCLCNT           NOT THE LAST, CONTINUE\n         SPACE 1\n***********************************************************************\n**                                                                   **\n**       WE ARE THE LAST CPU TO GET 'REFRESHED'                      **\n**       DETERMINE BASE TIME , SAVE IT IN CHECKPOINT AND             **\n**       ASK FOR A \"SET TIME\" REQUEST.                               **\n**                                                                   **\n***********************************************************************\n         SPACE 1\n         XI    CKFLAGS,CKFLOCK     RESET 'LOCK' FLAG\n         XC    CKSCLOCK,CKSCLOCK   RESET 'SET CLOCK' FIELD\n         LH    R1,CKNACPU          LOAD NUMBER OF ACTIVE CPU'S\n         PUSH  USING               SAVE USING STATUS\n         DROP  RSENTRY             FORGET SYSTEM ENTRY ADDRESSABILITY\n         LA    R2,CKSENTRY-CHECKPT-L'CKSENTRY(RBCKP)\n*                                  POINT TO FIRST CPU ENTRY (- LENGTH)\n         USING CKSYS,R2            SET ENTRIES ADDRESSABILITY\nSCLTLP   LA    R2,L'CKSENTRY(R2)   POINT TO NEXT ENTRY\n         CLI   CKSSTAT,CKTTIME     IS SYSTEM 'REFRESHED' ?\n         BNE   SCLTLP              NO -- SO LOOP AGAIN\n         CLI   SCPMTHD+3,BASECPU   BASE CPU METHOD ?               -EU-\n         BNE   SCHIGH              NO, USE HIGHEST TIME            -EU-\n         CLI   CKSREQ,CKTRFCPU     REFERENCE SYSTEM ?              -EU-\n         BE    SCTSET              YES                             -EU-\n         B     SCLOOP              NO -- SO DO NOT SWAP            -EU-\nSCHIGH   CLC   CKSYSCLK,CKSCLOCK   IS TIME HIGHER THAN THE HIGHEST ?\n         BNH   SCLOOP              NO -- SO DO NOT SWAP\nSCTSET   MVC   CKSCLOCK,CKSYSCLK   MOVE TIME TO CHECKPOINT\nSCLOOP   BCT   R1,SCLTLP           LOOP UNTIL ALL ARE SEARCHED\n         DROP  R2                  NO MORE USED\n         POP   USING               RESTORE OLD ADDRESSABILITY\n         SPACE 1\n***********************************************************************\n**                                                                   **\n**       BASE TIME HAS BEEN PLACED IN CHECKPOINT -- REQUEST SET TIME **\n**                                                                   **\n***********************************************************************\n         SPACE 1\n         MVC   CKNRCPU,CKNACPU     NUMBER OF RESIDUAL IS SAME AS TO SET\n         MVI   CKREQ,CKRSET        REQUEST CODE IS TO 'SET' TIME\n         MVI   CKCREQ,CKCRST       SO IS CHAR REQUEST\n         BR    RLINK               RETURN WRITE THE RECORD\n         TITLE '-- PROCESS A SET TIME REQUEST --'\n***********************************************************************\n**                                                                   **\n**       REQUEST TO SET TIME -- ISSUE 'SET CLOCK' INSTRUCTION        **\n**                                                                   **\n**       CHECK FIRST IF TIME IS SET OR IF WE ARE THE BASE --         **\n**       IF SO, DO NOT SET TIME ... IT IS ALREADY CORRECT            **\n**                                                                   **\n***********************************************************************\n         SPACE 1\nSCSTIME  CLI   CKSSTAT,CKTSET      ARE WE ALREADY SET ?\n         BER   RLINK               IF SO, RETURN AT END OF PROCESS\n         ST    RLINK,RLSAVE        SAVE RETURN REGISTER            -EU-\n         CLC   CKSCLOCK,CKSYSCLK   ARE WE THE BASE ?\n         BNE   SCSNOTH             NO, SO ISSUE A SET CLOCK INSTRUCTION\n         SEND  SCK0014I            THIS CPU WILL BE USED AS REFERENCE\n         OI    SCFLAGS,SCFNCMS     INDICATE NO CLOCK DONE          -EU-\n         B     SCSUPD              GO RETURN UPDATE CHECKPOINT\n         SPACE 1\n***********************************************************************\n**                                                                   **\n**       GET CLOCK DISCREPANCY AND SAVE IT IN SCDCLOCK               **\n**                                                                   **\n***********************************************************************\n         SPACE 1\nSCSNOTH  BH    SCSADD                                              -EU-\n         MVI   CKSREQ,CKTSUB       SUBSTRACT NEEDED                -EU-\n         LM    R0,R1,CKSYSCLK      LOAD CLOCK INTO R0,R1 PAIR      -EU-\n         SL    R1,CKSCLOCK+4       SUBSTRACT LOW ORDER SYS.CLOCK W.-EU-\n         BC    12,*+L'*+2          IF NO CARRY, DO NOT INCR. HIGH  -EU-\n         BCTR  R0,0                DECREASE HIGH ORDER WORD        -EU-\n         SL    R0,CKSCLOCK         SUBSTRACT HIGH ORDER WORD       -EU-\n         B     SCSCLKC                                             -EU-\nSCSADD   MVI   CKSREQ,CKTADD       ADD NEEDED                      -EU-\n         LM    R0,R1,CKSCLOCK      LOAD SYSTEM CLOCK INTO R0,R1 PAIR\n         SL    R1,CKSYSCLK+4       SUBSTRACT LOW ORDER CLOCK WORD\n         BC    12,*+L'*+2          IF NO CARRY, DO NOT INCREMENT HIGH\n         BCTR  R0,0                DECREASE HIGH ORDER WORD\n         SL    R0,CKSYSCLK         SUBSTRACT HIGH ORDER WORD\nSCSCLKC  STM   R0,R1,SCDCLOCK      SAVE CLOCK DISCREPANCY          -EU-\n         SPACE 1\n***********************************************************************\n**                                                                   **\n**       VALIDATE DISCREPANCY -- IF NOT ACCEPTABLE, SEND WARN MSG    **\n**                                                                   **\n***********************************************************************\n         SPACE 1\n         CL    R0,=A(60*&MAXDISC)  IS DISCREPANCY HIGHER THAN     V1.01\n*                                  MAXIMUM EXPECTED ?             V1.01\n         BL    SCSDEPK             NO, ALL OK TO SET CLOCK        V1.01\n*                                  DISCREPANCY IS MORE THAN MAX.  V1.01\n*                                  MINUTES, CLOCK NOT SET -       V1.01\n         @SNDMP CHECKPT,CKLEN,SNID=1    DEBUG IF REQUESTED         -EU-\n         SEND  SCK0018E            ADVISE SYSTEM OPERATORS        V1.01\n         OI    SCFLAGS,SCFNCMS     INDICATE NO CLOCK DONE          -EU-\n         B     SCSUPD              PROCESS AS IF UPDATED          V1.01\n         SPACE 1\n***********************************************************************\n**                                                                   **\n**       WRITE THE OPERATOR A MSG TO DEPRESS \"CLOCK KEY\"             **\n**                                                                   **\n***********************************************************************\n         SPACE 1\nSCSDEPK  SEND  SCK0015A            PLEASE, DEPRESS TOD CLOCK KEY\n         SPACE 1\n***********************************************************************\n**                                                                   **\n**       ISSUE \"SET CLOCK\" INSTRUCTION --                            **\n**       THIS REQUIRES TO BE IN SUPERVISOR MODE                      **\n**                                                                   **\n***********************************************************************\n         SPACE 1\n         TM    SCFLAGS,SCFTEST     ARE WE IN TSO ?                 -EU-\n         BO    SCSSET              YES, BYPASS SUPERVISOR MODE     -EU-\n         MODESET MODE=SUP          GET SUPERVISOR STATE\n         LTR   R15,R15             IS IT RIGHT ?\n         BZ    SCSSET              YES, CONTINUE PROCESSING\n         DOM   MSGLIST=RDOM        DELETE TOD MESSAGE              -EU-\n         SEND  SCK0002E            COULD NOT OBTAIN SUPERVISOR MODE\n         B     SCERR               GO PROCESS THE ERROR\n         SPACE 1\n***********************************************************************\n**                                                                   **\n**       CALCULATE UPDATED CLOCK AND ISSUE SET CLOCK INSTRUCTION     **\n**       UNTIL OPERATOR DEPRESS CLOCK KEY                            **\n**                                                                   **\n***********************************************************************\n         SPACE 1\nSCSSET   STCK  SCWDBLE             STORE CLOCK IN DOUBLE WORD\n         LM    R0,R1,SCWDBLE       LOAD CLOCK IN R0,R1 PAIR\n         CLI   CKSREQ,CKTADD       ADD REQUESTED ?                 -EU-\n         BNE   SCSSUB              NO, SUBSTRACT                   -EU-\n         AL    R1,SCDCLOCK+4       ADD CLOCK DISCREPANCY\n         BC    12,*+L'*+4          IF CARRY, SHOULD ADD 1 TO HIGH\n*                                  WORD OF RESULTANT CLOCK\n         AL    R0,=A(1)            ADD 1 TO R0\n         AL    R0,SCDCLOCK         ADD TO HIGH ORDER CLOCK WORD\n         B     SCSSVCK                                             -EU-\nSCSSUB   SL    R1,SCDCLOCK+4       SUBSTRACT CLOCK DISCREPANCY     -EU-\n         BC    12,*+L'*+2          IF CARRY, SHOULD SUBSTRACT 1 TO -EU-\n*                                  HIGH WORD OF RESULTANT CLOCK    -EU-\n         BCTR  R0,0                SUBSTRACT 1 TO R0               -EU-\n         SL    R0,SCDCLOCK         SUBSTRACT TO HIGH ORDER CLOCK W.-EU-\nSCSSVCK  STM   R0,R1,SCWDBLE       SAVE CLOCK IN WORK DOUBLEWORD   -EU-\n         TM    SCFLAGS,SCFTEST     ARE WE IN TSO ?                 -EU-\n         BO    SCSUPD              YES, BYPASS SET CLOCK           -EU-\n         SCK   SCWDBLE             SET CLOCK\n         BC    7,SCSSET            IF NOT SET, GO BACK LOOP\n         MVI   CKSSTAT,CKTSET      SET STATUS TO \"TIME SET\"       V1.03\n         SPACE 1\n***********************************************************************\n**                                                                   **\n**       OBTAIN PROGRAM MODE                                         **\n**                                                                   **\n***********************************************************************\n         SPACE 1\n         MODESET MODE=PROB         RESET MODE TO PROBLEM STATE\n         DOM   MSGLIST=RDOM        DELETE TOD MESSAGE              -EU-\n         SPACE 1\n***********************************************************************\n**                                                                   **\n**       CLOCK IS UPDATED -- WRITE TIME TO CONSOLE                   **\n**                                                                   **\n***********************************************************************\n         SPACE 1\nSCSUPD   TIME  DEC                 SET TIME IN R0 AND DATE IN R1\n*                                  TIME IS IN FORMAT X'HHMMSSTH'\n*                                  DATE IS IN FORMAT X'00YYDDDF'\n         STM   R0,R1,SCWPKBUF      SAVE TIME AND DATE IN PACK FORMAT\n         TM    SCFLAGS,SCFTEST     ARE WE IN TSO ?                 -EU-\n         BZ    SCSUPDX             NO, GO WRITE TIME               -EU-\n         TM    SCFLAGS,SCFNCMS     SET CLOCK DONE ?                -EU-\n         BO    SCSUPDX             NO, GO WRITE TIME               -EU-\n         SPACE 1                                                   -EU-\n***********************************************************************\n**                                                                   **\n**       PROVIDE TIME FROM TOD CLOCK VALUE                           **\n**                                                                   **\n***********************************************************************\n         SPACE 1                                                   -EU-\n         LM    R0,R1,SCWDBLE       GET TOD CLOCK VALUE             -EU-\n         L     R15,CVTPTR          GET CVT ADDRESS                 -EU-\n         USING CVT,R15                                             -EU-\n         AL    R0,CVTTZ            ADD LOCAL TIME DEVIATION        -EU-\n         DROP  R15                                                 -EU-\n         SRDL  R0,12               ISOLATE NUMBER OF MICROSECONDS  -EU-\n*                                  DIVIDE BY 1 MINUTE IN MICS      -EU-\n         D     R0,=A(60*1000000)        (R1=MINUTES AFTER EPOCH)   -EU-\n         LR    R15,R0              REMAINDER OF MICS TO GET SECS   -EU-\n         XR    R14,R14             CLEAR FOR DIVIDE                -EU-\n         D     R14,=F'1000000'     DIVIDE BY 1 SECOND IN MICS      -EU-\n         CVD   R15,SCWDBLE         CONVERT SECONDS TO PACKED FORMAT-EU-\n         L     R15,SCWDBLE+4                                       -EU-\n         SRL   R15,4                                               -EU-\n         STC   R15,SCWPKBUF+2      SET THE SECONDS                 -EU-\n         CVD   R1,SCWDBLE          CONVERT MINUTES TO PACKED FORMAT-EU-\n         DP    SCWDBLE,=PL2'+60'   DIVIDE INTO HOURS AND MINUTES   -EU-\n         L     R15,SCWDBLE+4                                       -EU-\n         SRL   R15,4                                               -EU-\n         STC   R15,SCWPKBUF+1      SET THE MINUTES                 -EU-\n         ZAP   SCWDBLE,SCWDBLE(6)  RESET TO FULL LENGTH            -EU-\n         DP    SCWDBLE,=PL2'+24'   DIVIDE INTO DAYS AND HOURS      -EU-\n         L     R15,SCWDBLE+4                                       -EU-\n         SRL   R15,4                                               -EU-\n         STC   R15,SCWPKBUF        SET THE HOURS                   -EU-\n         SPACE 1\n***********************************************************************\n**                                                                   **\n**       MOVE DATE TO MESSAGE                                        **\n**                                                                   **\n***********************************************************************\n         SPACE 1\nSCSUPDX  L     R2,=A(SCK0019I)     MESSAGE POINTER                 -EU-\n         AL    R2,=V(MSDATA)       WTO MESSAGE ADDRESS             -EU-\n         LA    R2,4(R2)            POINT TO MESSAGE TEXT           -EU-\n         USING SCDWMSG,R2          SET DUMMY MESSAGE ADDRESSABILITY\n         UNPK  SCWDBLE(5),SCWPKBUF+5(3)\n*                                  UNPACK DATE TO WORK FIELD\n         MVC   SCDWDAT(2),SCWDBLE  MOVE YEAR AND DAY INTO MESSAGE\n         MVC   SCDWDAT+3(3),SCWDBLE+2\n         SPACE 1\n***********************************************************************\n**                                                                   **\n**       MOVE HOURS, MINUTES AND SECONDS TO MESSAGE                  **\n**                                                                   **\n***********************************************************************\n         SPACE 1\n         UNPK  SCWDBLE,SCWPKBUF(4) UNPACK TIME TO WORK FIELD\n         MVC   SCDWTIM(2),SCWDBLE+1\n         MVC   SCDWTIM+3(2),SCWDBLE+3\n         MVC   SCDWTIM+6(2),SCWDBLE+5\n*                                  TIME IS NOW HH.MM.SS,\n         SEND  SCK0019I            DATE IS YY.DDD\n         DROP  R2                  DROP MESSAGE ADDRESSABILITY\n         SPACE 1\n***********************************************************************\n**                                                                   **\n**       UPDATE THE CHECKPOINT RECORD                                **\n**                                                                   **\n***********************************************************************\n         SPACE 1\n         MVC   SCWTIME,SCPTRACK    SET TRACK TIME\n         LH    R1,CKNRCPU          NUMBER OF CPU'S TO REACH THE \"SET\"\n         SH    R1,=H'1'            MINUS ONE (BECAUSE WE NOW ARE)\n         BP    SCWRWT              HIGH, THERE ARE STILL SOME TO RUN\n         MVI   CKREQ,CKREND        REQUEST IS TO END\n         MVI   CKCREQ,CKCRND       REQUEST IS TO END (CHAR)\n         MVC   CKNRCPU,CKNACPU     NUMBER OF RESIDUAL IS AS ACTIVE\n         B     SCWRET              RETURN WRITE THE UPDATED RECORD -EU-\nSCWRWT   STH   R1,CKNRCPU          NUMBER OF RESIDUAL CPU'S TO PROCESS\nSCWRET   L     RLINK,RLSAVE        RESTORE RETURN REGISTER         -EU-\n         BR    RLINK               RETURN TO CALLER\n         TITLE '-- NORMALIZE CLOCK TIME --'\n***********************************************************************\n**                                                                   **\n**       NORMALIZE CLOCK TIME                                        **\n**                                                                   **\n**       WE MUST NORMALIZE THE TIME BY ADDING TO IT :                **\n**       1. THE 'SEEK' TIME, MULTIPLIED BY RESIDUAL NUMBER OF I/O    **\n**          BEFORE 'TIME SETTING'. BIT 51 OF THE CLOCK HAS THE       **\n**          VALUE 1 MICROSECOND, SO, TO BE ACCURATE, SEEK TIME       **\n**          SHOULD BE MULTIPLIED BY 10000 (TO GIVE IN MICROSECONDS)  **\n**          AND SHIFT LEFT 12 BITS. THIS RESULT SHOULD BE ADDED TO   **\n**          SECOND WORD OF THE CLOCK.                                **\n**       2. THE DIFFERENCE BETWEEN LOCAL TIME AND GREENWICH MEAN -EU-**\n**          TIME (CVTTZ). THIS IS EXPRESSED IN BINARY UNITS OF   -EU-**\n**          1.048576 SECONDS, AND THUS SHOULD BE ADDED TO FIRST  -EU-**\n**          WORD OF THE CLOCK.                                   -EU-**\n**                                                                   **\n**       -- LINK REGISTER IS RLINK2                                  **\n**                                                                   **\n***********************************************************************\n         SPACE 1\nSCCNORM  LH    R1,CKNRCPU          GET NUMBER OF RESIDUAL CPU'S.\n*                                  THIS IS THE NUMBER OF I/O TO DO\n*                                  ON THE CHECKPOINT DATA-SET BEFORE\n*                                  TIME WILL BE SET\n         XR    R0,R0               CLEAR REGISTER\n         M     R0,SCPSEEK          MULTIPLY BY SEEK TIME\n         MH    R1,=H'10000'        GET NUMBER OF MICROSECONDS\n         SLL   R1,12               AND ALIGN IT TO BIT 51\n         SPACE 1\n***********************************************************************\n**                                                                   **\n**       NORMALISATION TIME IS IN R1 -- UPDATE CKSYSCLK FIELD        **\n**                                                                   **\n***********************************************************************\n         SPACE 1\n         AL    R1,CKSYSCLK+4       ADD TO TIME TO BE SET\n         L     R0,CKSYSCLK         LOAD HIGH CLOCK WORD\n         BC    12,*+L'*+4          IF OVERFLOW, SHOULD ADD 1 TO HIGH\n*                                  WORD\n         AL    R0,=A(1)            ADD 1 TO HIGH ORDER CLOCK WORD\n         L     R15,CVTPTR          GET CVT ADDRESS                 -EU-\n         USING CVT,R15                                             -EU-\n         AL    R0,CVTTZ            ADD LOCAL TIME DEVIATION        -EU-\n         MVC   CKCVTTZ,CVTTZ       TRACE DEVIATION                 -EU-\n         DROP  R15                                                 -EU-\n         STM   R0,R1,CKSYSCLK      AND SAVE IT IN CHECKPOINT\n         BR    RLINK2              RETURN TO CALLER\n         TITLE '-- RETURN TO CALLER, TERMINATE PROGRAM --'\n***********************************************************************\n**                                                                   **\n**       WRITE BACK THE RECORD TO FREE THE LOCK AND RETURN           **\n**                                                                   **\n***********************************************************************\n         SPACE 1\nSCRETURN BAS   RLINK,SCWRITE       WRITE THE RECORD\n         B     SCERR               IF AN ERROR OCCURS\n         B     SCRETN              RETURN TO CALLER\n         SPACE 1\n***********************************************************************\n**                                                                   **\n**       PROCESS ERROR                                               **\n**                                                                   **\n***********************************************************************\n         SPACE 1\nSCERR    SEND  SCK0003E            ERROR ENCOUNTERED, PROCESS ENDED\n         SPACE 1\n***********************************************************************\n**                                                                   **\n**       PROGRAM TERMINATION                                         **\n**                                                                   **\n***********************************************************************\n         SPACE 1\nSCRETN   @SNDMP WORK,WORKLEN,SNID=255   DEBUG IF REQUESTED         -EU-\n         CALL  EXDMP               PROCESS SNAP-DUMP IF ANY        -EU-\n         L     RSAVE,AREA+4        LOAD BACK SAVE REGISTER         -EU-\n         LR    R1,RWORK            WORK AREA ADDRESS               -EU-\n         LA    R0,WORKLEN          WORK AREA LENGTH                -EU-\n         FREEMAIN R,LV=(0),A=(1)   FREE LOCAL WORK STORAGE         -EU-\n         LM    R14,R12,12(RSAVE)   AND THE CALLER'S REGISTERS\n         XR    RCODE,RCODE         SET RETURN CODE TO ZERO\n         BR    RLINK               RETURN TO CALLER\n         TITLE '-- OBTAIN THE LOCK AND GET THE CHECKPOINT RECORD --'\n***********************************************************************\n**                                                                   **\n**       OBTAIN THE LOCK AND GET THE CHECKPOINT RECORD               **\n**                                                                   **\n***********************************************************************\n         SPACE 1\nSCGETREC STM   R14,R12,AREA2+12    SAVE REGISTERS\nSCGLOOP  LA    R1,SCPLOCK          LOAD THE WAIT TIME ADDRESS\n         STIMER WAIT,              WAIT FOR TIME TO ELAPSE             *\n               BINTVL=(R1)         ADDRESS SPECIFIED BY R1\n         MVC   CKHKEY(4),=X'FFFFFFFF'\n*                                  MOVE 'LOCK' KEY INTO BUFFER\n         MVC   CKLKSID,SCSYSID     AND ALSO SYSTEM ID (HOLDING)\n         LA    RPARM,CPRDCK        'READ THE CHECKPOINT RECORD' CCW\n         BAS   RLINK,EXCP          READ THE CHECKPOINT RECORD\n         B     SCGTERR             GET ERROR\n         SPACE 1\n***********************************************************************\n**                                                                   **\n**       READ WAS SUCCESSFUL -- SEE IF THE CHECKPOINT IS FREE        **\n**                                                                   **\n***********************************************************************\n         SPACE 1\n         CLC   CKLKSID,SCSYSID     IS THE KEY OBTAINED ?\n         BNE   SCGLOOP             NO, SO TRY AGAIN\n         LM    R14,R12,AREA2+12    LOAD BACK CALLER'S REGISTERS\n         B     4(RLINK)            RETURN TO CALLER\nSCGTERR  LM    R14,R12,AREA2+12    LOAD BACK CALLER'S REGISTERS\n         BR    RLINK               RETURN TO CALLER -- ERROR OFFSET\n         EJECT\n***********************************************************************\n**                                                                   **\n**       'READ CHECKPOINT RECORD' CCW -- OBTAIN THE LOCK IF FREE     **\n**                                                                   **\n***********************************************************************\n         SPACE 1\nCPRDCK   DS    0D\n         CCW   CWSKHD,CPSEEKBB,CWCC,6      - SEEK HEAD\n         CCW   CWSIDEQ,CPSEEKCC,CWCC,5     - SEARCH ID EQUAL\n         CCW   CWTIC,*-8,CWCC,1            - TIC *-8\n         CCW   CWSKEYEQ,CPKFREE,CWCC,8     - SEARCH KEY EQUAL\n         CCW   CWTIC,CPLOCKED,CWCC,1       - TIC CPLOCKED  (NOT FOUND)\n         SPACE 1\n         CCW   CWRDDATA,*-*,CWCC,CKLEN-8   - READ DATA\nCPRBUF1  EQU   *-8+1,3,C'A'                DATA ADDRESS (TO BE READ)\n         SPACE 1\n         CCW   CWSKHD,CPSEEKBB,CWCC,6      - SEEK HEAD\n         CCW   CWSIDEQ,CPSEEKCC,CWCC,5     - SEARCH ID EQUAL\n         CCW   CWTIC,*-8,CWCC,1            - TIC *-8\n         CCW   CWWRKD,*-*,0,CKLEN          - WRITE KEY AND DATA (STOP)\nCPRBUF2  EQU   *-8+1,3,C'A'                DATA/KEY ADDRESS TO WRITE\n         SPACE 1\nCPLOCKED CCW   CWSKHD,CPSEEKBB,CWCC,6      - SEEK HEAD\n         CCW   CWSIDEQ,CPSEEKCC,CWCC,5     - SEARCH ID EQUAL\n         CCW   CWTIC,*-8,CWCC,1            - TIC *-8\n         CCW   CWRDKDT,*-*,0,CKLEN         - READ KEY AND DATA\nCPRBUF3  EQU   *-8+1,3,C'A'                KEY/DATA ADDRESS\n      TITLE '-- WRITE THE CHECK POINT RECORD AND RELEASE THE LOCK --'\n***********************************************************************\n**                                                                   **\n**       WRITE THE CKECKPOINT RECORD AND RELEASE THE LOCK            **\n**                                                                   **\n***********************************************************************\n         SPACE 1\nSCWRITE  STM   R14,R12,AREA2+12    SAVE REGISTERS\n         XC    CKHKEY,CKHKEY       CLEAR FREE LOCK\n         MVC   CPSEEKCW,CPSEEKCC   INIT SEEK ADDRESS\n         MVI   CPSEEKCW+4,X'00'    BUT SEARCH FOR RECORD ZERO\n         LA    RPARM,CPWRCK        WRITE RECORD CCW\n         BAS   RLINK,EXCP          WRITE THE RECORD\n         B     SCWERR              WRITE ERROR\n         LM    R14,R12,AREA2+12    LOAD BACK CALLER'S REGISTERS\n         B     4(RLINK)            RETURN TO CALLER\nSCWERR   LM    R14,R12,AREA2+12    LOAD BACK CALLER'S REGISTERS\n         BR    RLINK               RETURN TO CALLER -- ERROR OFFSET\n         SPACE 1\n***********************************************************************\n**                                                                   **\n**       'WRITE CHECKPOINT RECORD' CCW                               **\n**                                                                   **\n***********************************************************************\n         SPACE 1\nCPWRCK   DS    0D\n         CCW   CWSKHD,CPSEEKBB,CWCC,6        - SEEK HEAD\n         CCW   CWSIDEQ,CPSEEKCW,CWCC,5       - SEARCH ID EQUAL\n         CCW   CWTIC,*-8,CWCC,1              - TIC *-8\n         CCW   CWWRCKD,*-*,0,CKLEN+L'SCCKCNT - WRITE COUNT KEY AND DATA\n         SPACE 1\nCPWBUFA  EQU   *-8+1,3,C'A'                  DATA ADDRESS\n         TITLE '-- READ AND INITIALIZE THE INPUT PARAMETERS --'\n***********************************************************************\n**                                                                   **\n**       READ AND INITIALIZE THE INPUT PARAMETERS                    **\n**                                                                   **\n**       THIS  SUBROUTINE WILL SET DEFAULT PARAMETERS. IT WILL       **\n**       THEN OPEN PARMLIB DATA-SET AND READ THE SPECIFIED           **\n**       PARAMETERS. IF NO &SETPARM DDNAME IS ALLOCATED, DEFAULTS    **\n**       PARAMETERS ONLY WILL BE USED (AND MESSAGE WILL BE ISSUED)   **\n**                                                                   **\n**       IF ANY ERROR IS ENCOUNTERED WITHIN THE PARAMETERS,          **\n**       MESSAGE IS PRINTED AND EXECUTION IS TERMINATED              **\n**                                                                   **\n***********************************************************************\n         SPACE 1\nREADPARM STM   R14,R12,12(R13)    SAVE REGISTERS\n         LA    R15,AREA2          POINT TO OUR SAVE AREA\n         ST    R13,4(R15)         SAVE CALLER'S SAVEAREA ADDRESS\n         ST    R15,8(R13)         AND CHAIN BACK SAVEAREAS\n         LR    R13,R15            AND FINALLY GET OUR SAVEAREA POINTER\n         SPACE 1\n***********************************************************************\n**                                                                   **\n**       INITIALIZE PARAMETERS BY SETTING DEFAULTS                   **\n**                                                                   **\n***********************************************************************\n         SPACE 1\n         MVC   SCPMAXC,=A(MAXCPUD) -- MAX NUMBER OF CPU'S\n         MVC   SCPWAIT,=A(LONGWT)  -- LONG WAIT DEFAULT\n         MVC   SCPTRACK,=A(TRAKWT) -- TRACK WAIT DEFAULT\n         MVC   SCPSEEK,=A(SEKTIM)  -- SEEK TIME\n         MVC   SCPDISC,=A(DISTIME) -- DISCONNECT TIME\n         XC    SCPMTHD,SCPMTHD     -- SYNCH. METHOD NO.            -EU-\n         XC    SCPSNF,SCPSNF       -- SNAP-ID INDICATORS           -EU-\n         CALL  LPARMS              LOAD INPUT PARAMETERS\n         EJECT\n***********************************************************************\n**                                                                   **\n**       LOAD INPUT PARAMETERS                                       **\n**                                                                   **\n***********************************************************************\n         SPACE 1\n         B     READPXIT            EXIT, SUCCESSFULL\n         L     RSAVE,4(RSAVE)      LOAD BACK PREVIOUS SAVE AREA\n         LM    R14,R12,12(RSAVE)   RELOAD REGISTERS\n         B     0(RLINK)            RETURN AFTER ERROR IN PARMS DATA-SET\n         SPACE 1\n***********************************************************************\n**                                                                   **\n**       COMPUTE INITIAL LOCK WAIT TIME AND RETURN                   **\n**                                                                   **\n***********************************************************************\n         SPACE 1\nREADPXIT L     R1,SCPSEEK          GET SEEK TIME\n         MH    R1,SCPMAXC+2        MULTIPLY BY MAX NUMBER OF CPU'S\n         ST    R1,SCPLOCK          THIS IS COMPUTED LOCK TIME\n         L     RSAVE,4(RSAVE)      LOAD BACK PREVIOUS SAVE AREA\n         LM    R14,R12,12(RSAVE)   RELOAD REGISTERS\n         B     4(RLINK)            RETURN OK\n         TITLE '-- E X C P - EXECUTE THE SPECIFIED CHANNEL PROGRAM --'\n***********************************************************************\n**                                                                   **\n**       EXECUTE THE CHANNEL PROGRAM                                 **\n**                                                                   **\n**           THE PURPOSE OF THIS ROUTINE IS TO INTERFACE WITH        **\n**       THE OPERATING SYSTEM TO DO I/O ON THE CKECKPOINT DATA-SET   **\n**                                                                   **\n**           WHEN CONTROL WILL BE RETURNED TO THE CALLER,            **\n**       THE I/O WILL BE COMPLETED SINCE CP EXCP ISSUES A            **\n**       'WAIT' SVC UNTIL COMPLETION OF THE I/O OPERATION            **\n**                                                                   **\n**       PARAMETERS :                                                **\n**                                                                   **\n**       INPUT : RPARM -  POINTS TO THE CHANNEL PROGRAM TO           **\n**                           BE EXECUTED                             **\n**                                                                   **\n**       OUTPUT : RETURN LOCATION DEPENDS UPON I/O COMPLETION        **\n**                           0(RLINK)  UNCORRECTABLE I/O ERROR       **\n**                           4(RLINK)  SUCCESSFULL                   **\n**                                                                   **\n***********************************************************************\n         SPACE 1\nEXCP     ST    RLINK,CPXSAVE       SAVE LINK REGISTER\n         STM   R2,R5,CPXSAVE+4     AND SOME OTHER REGISTERS\n         LA    R3,SCIOB            IOB ADDRESS\n         USING IOBSTDRD,R3         SET ADDRESSABLILTY OF DSECT\n         XC    SCECB,SCECB         CLEAR EVENT CONTROL BLOCK\n         XC    IOBSENS0(2),IOBSENS0\n*                                  CLEAR SENS BYTES\n         MVI   IOBECBCC,X'00'      CLEAR CONDIITON CODE IN IOB\n         XC    IOBCSW,IOBCSW       CLEAR CSW\n         ST    RPARM,IOBSTART      SET CHANNEL PROGRAM ADDRESS\n         MVC   IOBSEEK,CPSEEK      MOVE SEEK ADDRESS IN IOB\n         SPACE 1\n***********************************************************************\n**                                                                   **\n**       EXECUTE THE I/O AND WAIT FOR COMPLETION                     **\n**                                                                   **\n***********************************************************************\n         SPACE 1\n         LA    RPARM,SCIOB         LOAD IOB ADDRESS IN PARM REGISTER\n         EXCP  (1)                 EXECUTE CHANNEL PROGRAM\n         WAIT  ECB=SCECB           WAIT FOR THE I/O COMPLETION\n         SPACE 1\n***********************************************************************\n**                                                                   **\n**       ANALYZE  I/O COMPLETION CODES AND RETURN TO CALLER          **\n**                                                                   **\n***********************************************************************\n         SPACE 1\n         CLI   SCECB,ECBNORM       NORMAL COMPLETION?\n         BE    SCRT                RETURN TO CALLER IF SO\n         CLI   SCECB,ECBPERR       INDICATING PERMANENT I/O ERROR ?\n         BE    SCNOTFND            YES, MAY BE NOT FOUND\n         CLI   SCECB,ECBDAEA       DID WE HAVE AN END OF EXTEND ?\n         BNE   SCIOERR             NO, MEANS I/O ERROR\n         TM    IOBSENS1,IOBS1B2    TEST FOR AN END OF CYLINDER\n         BZ    SCIOERR             NO, I/O ERROR\nSCNOTFND XR    R1,R1               CLEAR REGISTER\n         ICM   R1,B'0111',IOBCMDA  POINT TO COMMAND WORD\n         CLI   0(R1),CWTIC         IS IT A TIC ?\n         BNE   SCIOERR             NO, I/O ERROR\n         SH    R1,=H'8'            POINT TO COMMAND\n         TM    0(R1),X'21'         ONE OF THE SEARCH CMDS ?\n         BO    SCRT                YES, RETURN, NOT FOUND\n         SPACE 1\n***********************************************************************\n**                                                                   **\n**       PERMANENT I/O ERROR ON THE CHECKPOINT DATA-SET --           **\n**       RETURN TO CALLER WITH ERROR OFFSET                          **\n**                                                                   **\n***********************************************************************\n         SPACE 1\nSCIOERR  SEND  SCK0007E            I/O ERROR ON THE CHECKPOINT DATA-SET\n         L     RLINK,CPXSAVE       RESTORE LINK REGISTER\n         LM    R2,R5,CPXSAVE+4     AND SOME OTHER\n         BR    RLINK               RETURN TO CALLER WITH ERROR\n         SPACE 1\n***********************************************************************\n**                                                                   **\n**       I/O TERMINATED NORMALLY -- RETURN TO CALLER                 **\n**                                                                   **\n***********************************************************************\n         SPACE 1\nSCRT     L     RLINK,CPXSAVE       RESTORE LINK REGISTER\n         LM    R2,R5,CPXSAVE+4     AND SOME OTHER\n         B     4(RLINK)            RETURN TO CALLER (GOOD)\n         TITLE '-- E X C P - DATA AREAS AND EXECUTED INSTRUCTIONS --'\n***********************************************************************\n**                                                                   **\n**       I/O ROUTINE EQUATES                                         **\n**                                                                   **\n***********************************************************************\n         SPACE 1\nECBNORM  EQU   X'7F'               NORMAL COMPLETION\nECBPERR  EQU   X'41'               PERMANENT ERROR COMPLETION\nECBDAEA  EQU   X'42'               END OF EXTENT COMPLETION\n         SPACE 1\n***********************************************************************\n**                                                                   **\n**       DATA  AREAS AND CONSTANTS                                   **\n**                                                                   **\n***********************************************************************\n         SPACE 1\nSCECB    DC    F'0'                EVENT CONTROL BLOCK FOR I/O\nCPXSAVE  DS    (1+4)F              CPEXCP SAVE AREA\n         SPACE 1\n***********************************************************************\n**                                                                   **\n**       EXCP PARAMETER BLOCK (IOB)                                  **\n**                                                                   **\n***********************************************************************\n         SPACE 1\nSCIOB    DC    0F'0'               BEGINNING OF IOB\n         DC    AL1(IOBDATCH+IOBCMDCH+IOBUNREL,0,0,0)\n         DC    A(SCECB)            ECB PTR\n         DC    A(00,00)\n         DC    A(*-*)              START OF CH. PROG.\n         DC    A(SYSCKPT)          DCB ADDRESS\n         DC    A(00,00)\n         DC    XL8'00'             IOBSEEK\n         SPACE 1\n***********************************************************************\n**                                                                   **\n**       DATA AREAS AND EXECUTED INSTRUCTIONS                        **\n**                                                                   **\n***********************************************************************\n         SPACE 1\nCPSEEK   DC    0D'0'               SEEK ADDRESS FOR IOB\nCPSEEKM  DC    FL1'0'              -- EXTEND NUMBER : ZERO\nCPSEEKBB DC    FL2'0'              -- BINARY NUMBER : ZERO\nCPSEEKCC DC    XL2'0000'           -- CYLINDER NUMBER\nCPSEEKHH DC    XL2'0000'           -- HEAD NUMBER\nCPSEEKR  DC    XL1'00'             -- RECORD NUMBER\nCPSEEKCW DS    XL5                 SEEK ADDRESS FOR WRITE (RECORD 0)\n         EJECT\n***********************************************************************\n**                                                                   **\n**       CCW EQUATES  -- CHANNEL COMMAND CODES                       **\n**                                                                   **\n***********************************************************************\n         SPACE 1\nCWSKHD   EQU   X'1B'               --  SEEK HEAD\nCWSSCTR  EQU   X'23'               --  SET SECTOR\nCWSHOME  EQU   X'39'               --  SEARCH HOME ADDRESS\nCWSIDEQ  EQU   X'31'               --  SEARCH ID EQUAL\nCWSKEYEQ EQU   X'29'               --  SEARCH KEY EQUAL\nCWSKHIGH EQU   X'49'               --  SEARCH KEY HIGH\nCWSKHEQ  EQU   X'69'               --  SEARCH KEY HIGH OR EQUAL\nCWRDCNT  EQU   X'12'               --  READ COUNT\nCWRDDATA EQU   X'06'               --  READ DATA\nCWRDKDT  EQU   X'0E'               --  READ KEY AND DATA\nCWRDCKD  EQU   X'1E'               --  READ COUNT, KEY AND DATA\nCWWRCKD  EQU   X'1D'               --  WRITE COUNT, KEY AND DATA\nCWWRDAT  EQU   X'05'               --  WRITE DATA\nCWWRKD   EQU   X'0D'               --  WRITE KEY AND DATA\nCWTIC    EQU   X'08'               --  TRANSFER IN CHANNEL\nCWNOP    EQU   X'03'               --  NO OPERATION\nCWMTRK   EQU   X'80'               MULTI TRACK FEATURE BIT\n         SPACE 1\n***********************************************************************\n**                                                                   **\n**       CCW EQUATES  -- FLAGS                                       **\n**                                                                   **\n***********************************************************************\n         SPACE 1\nCWCD     EQU   X'80'               --  CHAIN ON DATA\nCWCC     EQU   X'40'               --  CHAIN ON COMMAND\nCWSILI   EQU   X'20'               --  SUPPRESS INCORRECT LENGTH\nCWSKIP   EQU   X'10'               --  SUPPRESS TRANSFER OF\n*                                      INFORMAITON TO MAIN STORAGE\nCWPCI    EQU   X'08'               --  PROGRAM CONTROLLED\n*                                      INTERRUPTION\n         TITLE '-- D C B S - PROGRAM DATA CONTROL BLOCKS --'\n***********************************************************************\n**                                                                   **\n**       DCB USED TO PROCESS CHECKPOINT DATA-SET                     **\n**                                                                   **\n***********************************************************************\n         SPACE 1\n         PUSH  PRINT               SAVE PRINT STATUS\n         PRINT  ON,NOGEN           DO NOT EXPAND THE MACRO\n         SPACE 1\nSYSCKPT  DCB   DDNAME=&SYSCKPT,    CHECKPOINT DDNAME                   +\n               MACRF=(E),          USING 'EXCP'                        +\n               RECFM=F,            FIXED LENGTH RECORD                 +\n               DSORG=DA,           DIRECT ACCESS DATA-SET              +\n               KEYLEN=8            USE A 8 BYTES KEY (LOCK INDICATOR)\n         POP   PRINT               RESTORE PRINT STATUS\n         TITLE '-- CONSTANTS, TABLES, ETC... --'\n***********************************************************************\n**                                                                   **\n**       CONSTANTS                                                   **\n**                                                                   **\n***********************************************************************\n         SPACE 1\nCPKFREE  DC    X'0000000000000000' FREE CHECKPOINT RECORD KEY\nRESET    DC    C'RESET'            RESET KEY WORD\nSCANT    DC    C'SCAN'             SCAN KEY WORD                   -EU-\nSCBL     DC    CL8' '              8 BLANKS\nSCKLDL   DC    AL1(L'CKHKEY)       LENGTH COUNT FIELD -- KEY\n         DC    AL2(CKLEN-L'CKHKEY)                    -- DATA\n         SPACE 2\n***********************************************************************\n**                                                                   **\n**       LITTERAL POOL                                               **\n**                                                                   **\n***********************************************************************\n         SPACE 1\n         LTORG ,                   EXCP LITTERAL POOL\n         SPACE 2\n***********************************************************************\n**                                                                   **\n**       TABLES                                                      **\n**                                                                   **\n***********************************************************************\n         SPACE 1\nSCXTBL   SETCTRT ,                 GENERATE SID SEARCH TABLE\n         TITLE '-- L P A R M S - LOAD INPUT PARAMETERS --'\n***********************************************************************\n**                                                                   **\n**                      ----  L P A R M S  ----                      **\n**                                                                   **\n**           THIS SUBROUTINE, CALLED BY UTILITIES PROCESSOR, WILL    **\n**       LOAD INPUT PARAMETERS SPECIFIED BY PARMLIB DATA-SET         **\n**                                                                   **\n**           -- INPUT :  RPARM    N/A                                **\n**                       RLINK    RETURN ADDRESS                     **\n**                                                                   **\n**           -- OUTPUT : RCODE = 0  PARMS SUCCUSSFULLY READ          **\n**                       RCODE = 4  PARMS ERROR ENCOUNTERED          **\n**                                                                   **\n***********************************************************************\n         SPACE 1\nLPARMS   $SUB  ,                   LOAD INPUT PARAMETERS SUBROUTINE\n         EJECT\n***********************************************************************\n**                                                                   **\n**       TRY TO OPEN PARMLIB DATA-SET. IF OPEN FAILS, SEND MSG       **\n**       AND USE DEFAULTS                                            **\n**                                                                   **\n***********************************************************************\n         SPACE 1\n         OPEN  (SETPARM,INPUT)     OPEN PARMLIB, INPUT MODE\n         TM    SETPARM+DCBOFLGS-IHADCB,DCBOFOPN\n*                                  DID THE DATA-SET OPENED PROPERLY ?\n         BO    LPAPGET             YES, CONTINUE PROCESSING\n         SEND  SCK0009E            SETPARM NOT ALLOC., USING DEFAULTS\n         B     LPAPEOD             RETURN USING DEFAULTS\n         SPACE 1\n***********************************************************************\n**                                                                   **\n**       SYSPARM DATA-SET SUCCESSFULLY OPENED                        **\n**                                                                   **\n***********************************************************************\n         SPACE 1\nLPAPGET  GET   SETPARM             GET INPUT CARD WITH QSAM\n         MVC   SCPSTCB+SBTXT-SCANTCB(L'SBTXT),0(R1)\n*                                  MOVE BUFFER TO SCAN TEXT CTL BLOCK\n         LH    R1,SETPARM+DCBLRECL-IHADCB\n*                                  GET TOTAL RECORD LENGTH\n         SH    R1,=H'8'            SUBSTRACT SEQUENCE FIELD LENGTH\n         STH   R1,SCPSTCB+SBTXTLN-SCANTCB\n*                                  SAVE LENGTH TO BE SCANNED IN STCB\nLPAPSCN  LA    RPARM,SCPSTCB       POINT TO SCANTCB\n         CALL  RDPARM              READ PARAMETER LINE\n         B     LPAPSCN             GO SCAN NEW KEYWORD WITHIN BUFFER\n         B     LPAPGET             GO GET NEW BUFFER\n         OI    SCPFLAGS,SCPFPERR   INDICATE PARSE ERROR\n         B     LPAPSCN             CONTINUE SCAN WITHIN SAME BUFFER\n         SPACE 1\n***********************************************************************\n**                                                                   **\n**       END OF FILE ENCOUNTERED ON PARMLIB DATA-SET --              **\n**       FREE/CLOSE IT AND RETURN TO CALLER WITH RCODE ZERO          **\n**                                                                   **\n***********************************************************************\n         SPACE 1\nLPAPEOD  CLOSE SETPARM             CLOSE/FREE DCB\n         XR    RCODE,RCODE         CLEAR RETURN CODE\n         TM    SCPFLAGS,SCPFPERR   TEST IF ANY PARSE ERROR\n         BZ    LPAEXIT             NONE, EXIT RETURN CODE ZERO\n         LA    RCODE,4             SET RETURN CODE = 4\nLPAEXIT  $SUBRET                   RETURN TO CALLER\n         TITLE '-- L P A R M S - DATA CONTROL BLOCKS DEFNITIONS --'\n***********************************************************************\n**                                                                   **\n**       DATA CONTROL BLOCKS DEFINITIONS AND CONSTANTS               **\n**                                                                   **\n***********************************************************************\n         SPACE 1\n         PUSH  PRINT               SAVE PRINT STATUS\n         PRINT  ON,NOGEN           DO NOT EXPAND THE MACROS\n         SPACE 1\nSETPARM  DCB   DDNAME=&SETPARM,    PARAMETER LIBRARY DDNAME            *\n               MACRF=(GL),         USING GET LOCATE                    *\n               RECFM=FB,           FIXED BLOCKED RECORDS               *\n               EODAD=LPAPEOD,      WHEN END REACHED                    *\n               DSORG=PS            SEQUENTIAL\n         SPACE 1\n         POP   PRINT               RESTORE PRINT STATUS\n         SPACE 1\n***********************************************************************\n**                                                                   **\n**       LITERAL POOL FOR LPARMS                                     **\n**                                                                   **\n***********************************************************************\n         SPACE 1\n         LTORG ,                   LITERAL POOL\n         TITLE '-- R D P A R M - READ A PARAMETERS LINE --'\n***********************************************************************\n**                                                                   **\n**                      ----  R D P A R M  ----                      **\n**                                                                   **\n**           THIS SUBROUTINE WILL READ AND PRINT THE PARAMETER       **\n**       SPECIFIED BY INPUT REGISTER                                 **\n**                                                                   **\n**           -- INPUT :  RPARM    POINTER TO \"READY\" SCAN TCB        **\n**                       RLINK    RETURN ADDRESS                     **\n**                       SCPFLAGS IN REQWA IS SET TO 1 IF WE         **\n**                                + ARE ENTERING FOR SAME KEYWORD    **\n**                                                                   **\n**           -- OUTPUT : MESSAGE IS SENT TO OPERAROR FOR PARAMETER   **\n**                       RCODE = 0  KEYWORD COMPLETELY PARSED        **\n**                       RCODE = 4  NEW TEXT LINE IS EXPECTED        **\n**                                  TO CONTINUE PARSING              **\n**                       RCODE = 8  PARSE ERROR                      **\n**                                                                   **\n***********************************************************************\n         SPACE 1\nPARMDS   DSECT                     LOCAL VARIABLES DEFINITIONS\n         SPACE 1\nPRMFLAGS DS    FL1                 FLAGS BYTE\nPRMFCOM  EQU   B'00000001'         WHEN SCANNING MULTI-DECIMAL VALUE\n*                                  + A COMMA WAS LAST ENCOUNTERED\nPRMCBUF  DS    X                   CONVERSION BUFFER\n         CNOP  0,8                                                 -EU-\nPARMDLN  EQU   *-PARMDS\n         EJECT\n***********************************************************************\n**                                                                   **\n**       READ PARM TEXT INITIALISATION                               **\n**                                                                   **\n***********************************************************************\n         SPACE 1\nRDPARM   $SUB  PARMDS,PARMDLN      READ A PARAMETERS LINE\n         LR    R6,RPARM            POINT TO SCAN TXT CTL BLOCK\n         USING SCANTCB,R6          SET ADDRESSABILITY\n         TM    SCPFLAGS,SCPFCNT    NEW KEYWORD PARSE EXPECTED ?\n         BZ    RDPSCAN             YES, GO FOR IT\n         LM    R0,R5,SCPRDSA       RELOAD REGISTERS TO CONTINUE PARSE\n         BR    R3                  GO PROCESS IT WITH NEW TEXT BUFFER\n         EJECT\n***********************************************************************\n**                                                                   **\n**       SCAN LINE FOR ANY OF THE KEYWORDS IN TABLE                  **\n**                                                                   **\n***********************************************************************\n         SPACE 1\nRDPSCAN  BASR  R3,0                SET RESTART ADDRESS IN CASE OF EOD\n         LR    RPARM,R6            LOAD SCANTCB ADDRESS\n         CALL  SCAN                CALL SCANNER\n         B     RDPGKW              GO SEARCH FOR KEYWORD\n         B     RDGKERR             HEX -- SHOULD NOT OCCUR\n         B     RDGKERR             DEC -- SHOULD NOT OCCUR\n         B     RDGKERR             DLM -- SHOULD NOT OCCUR\n         B     RDGKERR             STRING -- SHOULD NOT OCCUR\n         B     *-*                 RESERVED\n         B     RDPCNT              END OF TEXT -- PREPARE TO CONTINUE\n         B     RDGKERR             ERROR OCCURED\n         SPACE 1\n***********************************************************************\n**                                                                   **\n**       FIND KEYWORD FROM TABLE                                     **\n**                                                                   **\n***********************************************************************\n         SPACE 1\nRDPGKW   DS    0H                  GET KEYWORD FROM TABLE\n         PUSH  USING               SAVE CURRENT USING STATUS\n         LA    R5,RDPKVTBL         POINT TO KEYWORDS TABLE\n         USING RDPKVTBL,R5         SET TABLE ENTRY ADDRESSABILITY\nRDPGETKW CH    R0,RDPKLN           POSSIBLE LENGTH (NOT HIGHER) ?\n         BH    RDKNEXT             NO, SKIP TO NEXT\n         L     R2,RDPKSA           GET SYMBOL ADDRESS\n         LR    R3,R0               AND IT'S LENGTH\n         BCTR  R3,0                DECREASE COUNT BY ONE FOR EXECUTE\n         EX    R3,RDPKCLC          COMPARE KEYWORDS\n         BE    RDPKFND             EQUAL, FOUND\nRDKNEXT  TM    RDPKVTBL,X'80'      END OF TABLE ?\n         BO    RDGKNF              YES, KEYWORD NOT FOUND\n         LA    R5,RDPKELN(R5)      POINT TO NEXT ENTRY\n         B     RDPGETKW            AND TRY AGAIN\n         EJECT\n***********************************************************************\n**                                                                   **\n**       EXPECTED KEYWORD WAS FOUND, SCAN FOR '=' AND VALUE          **\n**                                                                   **\n***********************************************************************\n         SPACE 1\nRDPKFND  BASR  R3,0                SET RESTART ADDRESS IN CASE OF EOD\n         LR    RPARM,R6            LOAD SCANTCB ADDRESS\n         CALL  SCAN                CALL SCANNER\n         B     RDGDERR             GO SEARCH FOR KEYWORD\n         B     RDGDERR             HEX -- SHOULD NOT OCCUR\n         B     RDGDERR             DEC -- SHOULD NOT OCCUR\n         B     RDPEQU              EQUAL SIGN IS EXPECTED\n         B     RDGDERR             STRING -- SHOULD NOT OCCUR\n         B     *-*                 RESERVED\n         B     RDPCNT              END OF TEXT -- PREPARE TO CONTINUE\n         B     RDGDERR             ERROR OCCURED\nRDPEQU   CLI   0(R1),C'='          IS IT FOUND ?\n         BNE   RDGDERR\n         SPACE 1\n***********************************************************************\n**                                                                   **\n**       SCAN FOR VALUE ASSOCIATED WITH KEYWORD                      **\n**                                                                   **\n***********************************************************************\n         SPACE 1\n         BASR  R3,0                SET RESTART ADDRESS IN CASE OF EOD\n         LR    RPARM,R6            LOAD SCANTCB ADDRESS\n         CALL  SCAN                SCAN FOR ASSOCIATED VALUE\nRDPKVAL  B     RDPVERR             GOT A SYMBOL -- ERROR\n         B     RDPVERR             HEX -- ERROR\n         B     RDPVDEC             DEC -- DECIMAL VALUE\n         B     RDPVDLM             DLM -- MULTI-NUMERIC VALUES\n         B     RDPVSTR             STR -- STRING  VALUE\n         B     *-*                 RESERVED\n         B     RDPCNT              END OF TEXT, VALUE NOT SUPPLIED\n         B     RDPVERR             ERROR ENCOUNTERED\n         EJECT\n***********************************************************************\n**                                                                   **\n**       SYMBOL (STRING) VALUE VALIDATION ROUTINE                    **\n**                                                                   **\n***********************************************************************\n         SPACE 1\nRDPVSTR  CH    RCODE,RDPKVT        IS EXPECTED TYPE FOUND ?\n         BNE   RDPVERR             NO, MEANS ERROR\n         CH    R0,=Y(L'DS1DSNAM+2) IS IT MORE THAN 44 CHARACTERS ?\n         BH    RDPVERR             YES, VALUE LENGTH ERROR\n*        MVI   WRKPNAM,C' '        MOVE IN A BLANK\n*                                  + AND PROPAGATE IT ACROSS NAME\n*        MVC   WRKPNAM+1(L'WRKPNAM-1),WRKPNAM\n*                                  CLEAR OUT DATABASE NAME (BLANKS)\n         LR    R2,R0               SET NAME LENGTH FOR EXECUTE\n         SH    R2,=H'3'            + AND SUBSTRACT 1+2 (EX AND QUOTES)\n*        EX    R2,RDPNMVC          MOVE DATA-SET NAME\n         B     RDPEXIT             AND RETURN TO CALLER\n         SPACE 1\n***********************************************************************\n**                                                                   **\n**       NUMERIC VALUE VALIDATION ROUTINE                            **\n**                                                                   **\n***********************************************************************\n         SPACE 1\nRDPVDEC  CH    RCODE,RDPKVT        IS EXPECTED TYPE FOUND ?\n         BNE   RDPVERR             NO, MEANS ERROR\n         LR    R2,R0               SET LENGTH FOR EXECUTE\n         BCTR  R2,0                + AND DECREASE BY ONE\n         EX    R2,RDPVPAK          PACK VALUE TO WORK BUFFER\n         CVB   R0,SCWDBLE          CONVERT VALUE TO BINARY INTO R0\n         LH    R2,RDPKSEQ          GET SEQUENCE NUMBER\n         SLL   R2,2                MULTIPLY BY FOUR\n         EX    0,RDPVSTO-4(R2)     SAVE VALUE IN TABLE\n*                                       OR GO TO PROCESS IT        -EU-\n         B     RDPEXIT             RETURN TO CALLER\n         EJECT\n***********************************************************************\n**                                                                   **\n**       MULTI-NUMERIC VALIDATION ROUTINE (N1,N2,...)                **\n**                                                                   **\n***********************************************************************\n         SPACE 1\nRDPVDLM  CH    RCODE,RDPKVT        IS EXPECTED TYPE FOUND ?\n         BNE   RDPVERR             NO, MEANS ERROR\n         CLI   0(R1),C'('          IS EXPECTED '(' FOUND\n         BNE   RDPVERR             NO, VALUE ERROR\n         NI    PRMFLAGS,FF-PRMFCOM RESET COMMA INDICATOR BIT\n         LH    R2,RDPKSEQ          GET SEQUENCE NUMBER\n         SLL   R2,2                MULTIPLY BY FOUR\n*        EX    0,RDPVLDA-4(R2)     SET R4 TO POINT TO RECEIVING FIELD\n         SPACE 1\n***********************************************************************\n**                                                                   **\n**       SCAN FOR ##,##,.. UNTIL ')'  IS FOUND                       **\n**                                                                   **\n***********************************************************************\n         SPACE 1\nRDPVMNUM BASR  R3,0                SET RESTART ADDRESS IN CASE OF EOD\n         LR    RPARM,R6            LOAD SCANTCB ADDRESS\n         CALL  SCAN\n         B     RDPVERR             GOT A SYMBOL (CHARACTERS STRING)\n         B     RDPVERR             HEX -- ERROR\n         B     RDPVMDEC            DEC -- DECIMAL VALUE\n         B     RDPVMDLM            DLM -- ',' OR ')' EXPECTED\n         B     RDPVERR             STR -- ERROR\n         B     *-*                 RESERVED\n         B     RDPCNT              END OF TEXT, VALUE NOT SUPPLIED\n         B     RDPVERR             ERROR ENCOUNTERED\n         EJECT\n***********************************************************************\n**                                                                   **\n**       DELIMITER ENCOUNTERED, CHECK FOR ',' OR ')'                 **\n**                                                                   **\n***********************************************************************\n         SPACE 1\nRDPVMDLM CLI   0(R1),C','          IS-IT A COMMA ?\n         BNE   RDPVMEOD            NO, TRY FOR ')'\n         XI    PRMFLAGS,PRMFCOM    REVERSE COMMA BIT\n         TM    PRMFLAGS,PRMFCOM    IS-IT NOW RESET TO ZERO ?\n         BO    RDPVERR             NO, WAS ENTERED TWICE ... ERROR\n         B     RDPVMNUM            CONTINUE EXPECTING NUMERIC\nRDPVMEOD CLI   0(R1),C')'          IS-IT FINISHED ?\n         BE    RDPEXIT             YES, ALL OF IT IS DONE\n         B     RDPVERR             NO, DON'T KNOW WHAT IS GOING ON ...\n         SPACE 1\n***********************************************************************\n**                                                                   **\n**       DECIMAL VALUE ENCOUNTERED, PROCESS IT                       **\n**                                                                   **\n***********************************************************************\n         SPACE 1\nRDPVMDEC XI    PRMFLAGS,PRMFCOM    REVERSE COMMA BIT\n         TM    PRMFLAGS,PRMFCOM    IS-IT NOW SET TO ONE ?\n         BZ    RDPVERR             NO, NO COMMA WAS SUPPLIED ... ERROR\n         LR    R2,R0               SET LENGTH FOR EXECUTE\n         BCTR  R2,0                + AND DECREASE BY ONE\n         EX    R2,RDPVPAK          PACK VALUE TO WORK BUFFER\n         CVB   R0,SCWDBLE          CONVERT VALUE TO BINARY INTO R0\n         LH    R2,RDPKSEQ          GET SEQUENCE NUMBER\n         SLL   R2,2                MULTIPLY BY FOUR\n         B     *(R2)               PROCESS ACCORDING TO SEQUENCE #\n*        B     RDPKSEQ1            -- PROCESS FIRST KEYWORD        -EU-\n*        B     RDPKSEQ2            -- PROCESS SECOND KEYWORD       -EU-\n         B     RDPVERR             -- ERROR                        -EU-\n         B     RDPVERR             -- ERROR                        -EU-\n         B     RDPVERR             -- ERROR                        -EU-\n         B     RDPVERR             -- ERROR                        -EU-\n         B     RDPVERR             -- ERROR                        -EU-\n         B     RDPVERR             -- ERROR                        -EU-\n         B     RDPVERR             -- ERROR                        -EU-\n         B     RDPKSEQ3            -- PROCESS BIT SETTING (IDS)    -EU-\n         EJECT\n***********************************************************************\n**                                                                   **\n**       PROCESS BITMAPS ALLOCATION PATTERN                          **\n**                                                                   **\n***********************************************************************\n         SPACE 1\nRDPKSEQ1 LR    R1,R4               LOAD RECEIVING FIELD POINTER\n*        LA    R15,WRKPALP         POINT TO INITIAL ADDRESS\n         SR    R1,R15              GET CURRENT OFFSET\n*        CH    R1,=Y(&MAXLVL)      COMPARE AGAINST MAXIMUM VALUE\n         BNL   RDPVMERR            IF HIGH OR EQUAL TO MAX, IMPOSSIBLE\n         LTR   R0,R0               TEST FOR POSITIVE VALUE\n         BNP   RDPVMERR            IF NOT POSITIVE, ERROR\n         STC   R0,0(R4)            SAVE VALUE\n         LA    R4,1(R4)            POINT TO NEXT RECEIVING FIELD\n         B     RDPVMNUM            CONTINUE SCANNING\n         SPACE 1\n*******************************************************************-EU-\n**                                                                 -EU-\n**       PROCESS BIT SETTING (SNAP-ID)                             -EU-\n**                                                                 -EU-\n*******************************************************************-EU-\n         SPACE 1                                                   -EU-\nRDPKSEQ3 LA    R4,SCPSNF           TARGET FIELD                    -EU-\n         LTR   R0,R0               VALIDATE SNAP-ID NO. VALUE      -EU-\n         BM    *+L'*+8                                             -EU-\n         CH    R0,=H'255'                                          -EU-\n         BNH   *+L'*+2                                             -EU-\n         XR    R0,R0               ON ERROR, SET ZERO              -EU-\n         SPACE 1                                                   -EU-\n***********************************************************************\n**                                                                   **\n**       PROCESS SECOND KEYWORD VALUE                                **\n**                                                                   **\n***********************************************************************\n         SPACE 1\nRDPKSEQ2 DS    0H                  PROCESS MERGE BITMAP\n*        CH    R0,=Y(&MAXFLD#-1)   TEST FOR MAXIMUM VALUE\n*        BH    RDPVMERR            HIGHER, ERROR                   -EU-\n         LR    R2,R0               LOAD IT'S CONTENT\n         SRL   R2,3                DIVIDE BY 8\n         LA    R3,0(R2,R4)         POINT TO FIELD RECEIVING BIT\n         SLL   R2,3                RESET\n         SR    R0,R2               SET TO BIT# TO BE SET\n         STC   R0,PRMCBUF          SAVE IT IN CONVERT BUFFER\n         TR    PRMCBUF,RDPCTBL     TRANSLATE IT\n         OC    0(1,R3),PRMCBUF     SET RIGHT BIT\n         B     RDPVMNUM            + AND GO PROCESS NEXT VALUE\n         EJECT\n***********************************************************************\n**                                                                   **\n**       VALUE  ERROR OCCURED -- PRINT MESSAGE AND QUIT              **\n**                                                                   **\n***********************************************************************\n         SPACE 1\nRDPVERR  SEND  SCK0005E            VALUE TYPE DOES NOT MATCH KEYWORD\n         B     RDPPERR             RETURN TO CALLER\n         SPACE 1\n***********************************************************************\n**                                                                   **\n**       VALUE SUPPLIED OUT OF BOUNDS, SEND MESSAGE AND QUIT         **\n**                                                                   **\n***********************************************************************\n         SPACE 1\nRDPVMERR SEND  SCK0011E            TO MANY VALUES SUPPLIED\n         B     RDPPERR             RETURN TO CALLER\n         EJECT\n***********************************************************************\n**                                                                   **\n**       ERROR OCCURED, PRINT MESSAGE AND QUIT                       **\n**                                                                   **\n***********************************************************************\n         SPACE 1\nRDGKERR  SEND  SCK0012E            ERROR OCCURED WHILE SCANNING\n         B     RDPPERR             RETURN TO CALLER\n         SPACE 1\n***********************************************************************\n**                                                                   **\n**       EXPECTED KEYWORD WAS NOT FOUND                              **\n**                                                                   **\n***********************************************************************\n         SPACE 1\nRDGKNF   SEND  SCK0013E            KEYWORD EX.'D BUT BAD SYMBOL FOUND\n         B     RDPPERR             RETURN TO CALLER\n         EJECT\n***********************************************************************\n**                                                                   **\n**       EQUAL SIGN NOT FOUND                                        **\n**                                                                   **\n***********************************************************************\n         SPACE 1\nRDGDERR  SEND  SCK0014E            EX.'D \"=\" NOT FOUND, \"=\" ASSUMED\n         LM    R15,R1,SBSCNR15     RELOAD SCAN REGISTERS\n         B     RDPKVAL(RCODE)      RETURN VALIDATING VALUE\n         SPACE 1\n***********************************************************************\n**                                                                   **\n**        KEYWORD PARSE NOT FINISHED, PREPARE TO CONTINUE            **\n**                                                                   **\n***********************************************************************\n         SPACE 1\nRDPCNT   OI    SCPFLAGS,SCPFCNT    CONTINUE PARSE OF SAME KEYWORD\n         STM   R0,R5,SCPRDSA       SAVE REGISTERS (WHEN RE-ENTRY,\n*                                  + WILL CONTINUE AT 0(RENTRY))\n         LA    RCODE,4             SET RCODE TO 4\n         B     RDPRET              RETURN TO CALLER -- WAIT BUFFER\n         SPACE 1\n***********************************************************************\n**                                                                   **\n**        PARSE ERROR OCCURED, SET BAD RETURN CODE AND EXIT          **\n**                                                                   **\n***********************************************************************\n         SPACE 1\nRDPPERR  NI    SCPFLAGS,FF-SCPFCNT REQUEST A NEW KEYWORD (IN CASE)\n         LA    RCODE,8             SET RCODE TO 8\n         B     RDPRET              RETURN TO CALLER\n         EJECT\n*******************************************************************-EU-\n**                                                                 -EU-\n**       PROCESS SNAP-ID NO.                                       -EU-\n**                                                                 -EU-\n*******************************************************************-EU-\n         SPACE 1                                                   -EU-\nSETSNID  LTR   R0,R0               VALIDATE SNAP-ID NO. VALUE      -EU-\n         BM    *+L'*+8                                             -EU-\n         CH    R0,=H'255'                                          -EU-\n         BNH   *+L'*+2                                             -EU-\n         XR    R0,R0               ON ERROR, SET ZERO              -EU-\n         LR    R1,R0               LOAD IT'S CONTENT               -EU-\n         SRL   R1,3                DIVIDE BY 8                     -EU-\n         LA    R15,SCPSNF(R1)      POINT TO BYTE RECEIVING BIT     -EU-\n         SLL   R1,3                RESET                           -EU-\n         SR    R0,R1               SET TO BIT# TO BE SET           -EU-\n         STC   R0,PRMCBUF          SAVE IT IN CONVERT BUFFER       -EU-\n         TR    PRMCBUF,RDPCTBL     TRANSLATE IT                    -EU-\n         OC    0(1,R15),PRMCBUF    SET RIGHT BIT                   -EU-\n         SPACE 1                                                   -EU-\n***********************************************************************\n**                                                                   **\n**        RETURN TO CALLER AT PROPER LOCATION                        **\n**                                                                   **\n***********************************************************************\n         SPACE 1\nRDPEXIT  NI    SCPFLAGS,FF-SCPFCNT REQUEST A NEW KEYWORD\n         XR    RCODE,RCODE         SET RCODE TO ZERO\nRDPRET   $SUBRET                   + AND RETURN TO CALLER\n         EJECT\n***********************************************************************\n**                                                                   **\n**       RDPARM DATA AND CONSTANTS                                   **\n**                                                                   **\n***********************************************************************\n         SPACE 1\nRDPKCLC  CLC   0(*-*,R1),0(R2)     COMPARE SUPPLIED ENTRY WITH KEYWORD\n*DPNMVC  MVC   WRKPNAM(*-*),1(R1)  MOVE DATABASE NAME (EXCL QUOTE)\nRDPVPAK  PACK  SCWDBLE,0(*-*,R1)   PACK NUMERIC VALUE\n         SPACE 1\nRDPVSTO  STCM  R0,B'1111',SCPMAXC  SAVE MAX CPU TIME\n         STCM  R0,B'1111',SCPDISC  SAVE DISCONNECT TIME\n         STCM  R0,B'1111',SCPWAIT  SAVE LONG WAIT TIME\n         STCM  R0,B'1111',SCPTRACK SAVE TRACK TIME\n         STCM  R0,B'1111',SCPSEEK  SAVE SEEK TIME\n         STCM  R0,B'1111',SCPMTHD  SAVE SYNCH. METHOD NO.          -EU-\n         B     SETSNID             GO TO PROCESS SNAP-ID NO.       -EU-\n         NOP   *                   NOTHING TO DO SNAP-IDS NO.      -EU-\n         SPACE 1\n*DPVLDA  LA    R4,WRKPALP          SET TO ALLOC PATTERN ADDRESS\n*        LA    R4,WRKPMRG          SET TO ALLOC PATTERN ADDRESS\n         SPACE 1\nRDPCTBL  DC    B'10000000'         BITMAP TRANSLATE TABLE\n         DC    B'01000000'\n         DC    B'00100000'\n         DC    B'00010000'\n         DC    B'00001000'\n         DC    B'00000100'\n         DC    B'00000010'\n         DC    B'00000001'\n         SPACE 1\n***********************************************************************\n**                                                                   **\n**       LITERAL POOL DEFINITION                                     **\n**                                                                   **\n***********************************************************************\n         SPACE 1\n         LTORG ,                   LITERAL POOL DEFINITION\n         EJECT\n***********************************************************************\n**                                                                   **\n**       PARAMETERS KEYWORDS DEFINITIONS                             **\n**                                                                   **\n***********************************************************************\n         SPACE 1\nRDPKVTBL DS    0F                  KEYWORDS TABLE DEFINITION\nRDPKSA   DS    AL4                 -- SYMBOL ADDRESS (UNALIGNED)\nRDPKLN   DS    Y                   -- SYMBOL LENGTH\nRDPKVT   DS    Y                   -- EXPECTED VALUE TYPE\nRDPKSEQ  DS    Y                   -- SEQUENCE OF SYMBOL WITH SAME\n*                                     VALUE TYPE (SEE UTILDS)\nRDPKELN  EQU   *-RDPKVTBL          TABLE ENTRY LENGTH\n         ORG   RDPKVTBL            RE-ORG TO TABLE DEFINITION\n         DC    AL4(RDP1K),Y(L'RDP1K,SCTDEC,1)\n         DC    AL4(RDP2K),Y(L'RDP2K,SCTDEC,2)\n         DC    AL4(RDP3K),Y(L'RDP3K,SCTDEC,3)\n         DC    AL4(RDP4K),Y(L'RDP4K,SCTDEC,4)\n         DC    AL4(RDP5K),Y(L'RDP5K,SCTDEC,5)\n         DC    AL4(RDP6K),Y(L'RDP6K,SCTDEC,6)                      -EU-\n         DC    AL4(RDP7K),Y(L'RDP7K,SCTDEC,7)                      -EU-\n         DC    AL4(RDP8K),Y(L'RDP8K,SCTDLM,8)                      -EU-\n         ORG   *-RDPKELN           RE-ORG TO LAST ENTRY\n         DC    X'80'               END OF KEYWORDS TABLE\n         ORG   ,                   RE-ORG\nRDP1K    DC    C'MAXCPU'           MAX NUMBER OF CPU'S\nRDP2K    DC    C'DISCONNECT_TIME'  MAX TIME BEFORE DISCONNECTION\nRDP3K    DC    C'LONG_WAIT'        LONG WAIT TIME\nRDP4K    DC    C'TRACK_WAIT'       TRACK WAIT TIME\nRDP5K    DC    C'SEEK_TIME'        SEEK TIME\nRDP6K    DC    C'SYNCH_METHOD'     SYNCHRONIZATION METHOD NO.      -EU-\nRDP7K    DC    C'SNAP_ID'          SNAP-ID NUMBER REQUEST          -EU-\nRDP8K    DC    C'SNAP_IDS'         SNAP-IDS NUMBERS REQUEST        -EU-\n         TITLE '-- S C A N - SERVICE ROUTINE --'\n***********************************************************************\n**                                                                   **\n**                        ----  S C A N  ----                        **\n**                                                                   **\n**           THIS MODULE WILL EXTRACT A TOKEN FROM THE TEXT          **\n**       BUFFER AND RETURN TO THE CALLER WITH THE NEXT TOKEN.        **\n**       IT WILL ALSO FLUSH ANY COMMENT FROM TEXT (/*...*/)          **\n**                                                                   **\n**           POSSIBLE RETURNED TOKEN TYPES ARE :                     **\n**                                                                   **\n**             SYMBOL :   <ALP> (  <ALP> | <DIGIT> )                 **\n**             HEX :      ( 0|1|2|3|4|5|6|7|8|9|A|B|C|D|E|F)         **\n**             DEC :      ( 0|1|2|3|4|5|6|7|8|9 )                    **\n**             DLM :      *|-|+|&|/|%|\u00ac|'|\"|?|<|>|,|.|**|<=...       **\n**             STRING :   'ANY CHARACTER  ...'                       **\n**             OTHER :    ...                                        **\n**                                                                   **\n**       <ALP> ::=  A|B|C|D|E|F|G|H|I|J|K|L|M|N|O|P|                 **\n**                  Q|R|S|T|U|V|W|X|Y|Z|@|#|_                        **\n**                                                                   **\n**       <DIGIT>    0|1|2|3|4|5|6|7|8|9                              **\n**                                                                   **\n**       PARAMTERS :                                                 **\n**       -----------                                                 **\n**                                                                   **\n**       INPUT :  RPARM POINTS TO TEXT CONTROL BLOCK                 **\n**                FOR INFORMATION, SEE DSECT SCANTCB                 **\n**                                                                   **\n**       OUTPUT : OFFSET IS UPDATED IN TEXT CONTROL BLOCK AND        **\n**                NOW POINTS A THE FIRST CHARACTER FOLLOWING         **\n**                EXTRACTED TOKEN                                    **\n**                                                                   **\n**       --  TOKEN ADDRESS IS RETURNED IN REGISTER R1                **\n**       --  TOKEN LENGTH  IS RETURNED IN REGISTER R0                **\n**       --  RETURN CODE IS SET IN REGISTER RCODE AND INDICATES      **\n**           TOKEN TYPE :                                            **\n**           RCODE  = 0  SYMBOL         -- MIGHT BE HEX (C.F. AABBC) **\n**                  = 4  HEX            -- HEXADECIMAL NUMBER        **\n**                  = 8  DEC            -- DECIMAL NUMBER (NO SIGN)  **\n**                  = 12 DLM            -- DELIMITER                 **\n**                  = 16 STRING         -- CHARACTER STRING          **\n**                  = 20 RESERVED                                    **\n**                  = 24 END OF TEXT BUFFER                          **\n**                  = 28 SCAN ERROR (UNDEFINED OR INVALID CHARACTER) **\n**                                                                   **\n***********************************************************************\n         EJECT\n***********************************************************************\n**                                                                   **\n**       FUNCTIONNAL REGISTERS DEFINITIONS                           **\n**                                                                   **\n***********************************************************************\n         SPACE 1\nRSTCB    EQU   R10                 BASE REGISTER FOR TEXT CONTROL BLOCK\n         SPACE 1\n***********************************************************************\n**                                                                   **\n**       LOCAL EQUATES -- RETURNED TOKEN TYPES                       **\n**                                                                   **\n***********************************************************************\n         SPACE 1\nSCTSYM   EQU   0                   TYPE = SYMBOL\nSCTHEX   EQU   4                   TYPE = HEXADECIMAL\nSCTDEC   EQU   8                   TYPE = DECIMAL\nSCTDLM   EQU   12                  TYPE = DELIMITER\nSCTSTR   EQU   16                  TYPE = STRING\nSCTRES   EQU   20                  RESERVED\nSCTEND   EQU   24                  END OF TEXT BUFFER\nSCTERR   EQU   28                  ERROR ENCOUNTERED\n         SPACE 1\n***********************************************************************\n**                                                                   **\n**       LOCAL VARIABLES DEFINITION                                  **\n**                                                                   **\n***********************************************************************\n         SPACE 1\nSCANDS   DSECT\nSCATOMA  DC    A(0)                ADDRESS OF TOKEN FIRST CHARACTER\n*                                  + IN GROUPS BUFFER\n         CNOP  0,8                                                 -EU-\nSCDSLN   EQU   *-SCANDS            LENGTH OF DSECT\n         TITLE '-- S C A N - INITIALISATION --'\n***********************************************************************\n**                                                                   **\n**       S C A N  --  INITIALIZATION                                 **\n**                                                                   **\n***********************************************************************\n         SPACE 1\nSCAN     $SUB  SCANDS,SCDSLN       DEFINE SCAN ENTRY POINT\n         LR    RSTCB,RPARM         SET TEXT CONTROL BLOCK ADDR.\n         USING SCANTCB,RSTCB       SET DSECT ADDRESSABILITY\n         TITLE '-- S C A N - MAIN PROCESSING --'\n***********************************************************************\n**                                                                   **\n**       CHECK FOR FIRST CALL FOR THIS TEXT BUFFER                   **\n**                                                                   **\n**       -- IF SO, INITIALIZE FIELD \"SBGBUF\" BY ASSOCIATING FOR      **\n**          EACH CHARACTER A GROUP ACCORDING TO \"SCGTAB\" TABLE       **\n**                                                                   **\n***********************************************************************\n         SPACE 1\n         TM    SBSFLG1,SBFNEW      FIRST CALL ?\n         BO    SCOKINIT            NO, CONTINUE PROCESSING THIS BUFFER\n         OI    SBSFLG1,SBFNEW      SET INDICATOR\n         MVC   SBGBUF,SBTXT        MOVE TEXT\n         TR    SBGBUF,SCGTAB       TRANSLATE IN GROUPS\n         LA    R1,SBTXT            POINT TO TEXT\n         ST    R1,SBATOMA          INITIALIZE FIELD\n         XC    SBTXTOFS,SBTXTOFS   INITIALIZE OFFSET FROM BEGINNING\n         SPACE 1\n***********************************************************************\n**                                                                   **\n**       SKIP BLANKS AND POINT TO FIRST CHARACTER OF TOKEN           **\n**                                                                   **\n***********************************************************************\n         SPACE 1\nSCOKINIT LA    R1,SBTXT            ADDRESS OF TEXT BUFFER\n         LR    R3,R1               SET REGISTER TO POINT\n         AH    R3,SBTXTLN          + END OF BUFFER\n         BCTR  R3,0                POINT LAST CHARACTER\n         AH    R1,SBTXTOFS         POINT TO FIRST CHARACTER\n         CR    R1,R3               REACHED  END OF BUFFER ?\n         BH    SCREINIT            YES, REINITIALIZE\n         LA    R2,1                INITIALIZE TO 1 (INCREMENT)\nSCSKIP   CLI   0(R1),C' '          IS-IT A BLANK ?\n         BNE   SCBEGIN             NO, WE ARE AT THE BEGINNING\n         BXLE  R1,R2,SCSKIP        POINT TO NEXT CHARACTER\n*                                  + IF IT IS NOT FINISHED\nSCREINIT XI    SBSFLG1,SBFNEW      RESET INDICATOR TO ZERO\n         LA    R15,SCTEND          INDICATE  END OF BUFFER\n         B     SCEXIT              END OF EXECUTION\nSCBEGIN  ST    R1,SBATOMA          SAVE  TOKEN POINTER\n         LA    R2,SBTXT            ADDRESS OF TEXT BUFFER\n         SR    R1,R2               GET OFFSET\n         STH   R1,SBTXTOFS         SAVE IN TEXT CONTROL BLOCK\n         TITLE '-- S C A N - SELECTION OF TOKEN TYPE --'\n***********************************************************************\n**                                                                   **\n**       DEFINE TOKEN TYPE IN FUNCTION OF FIRST CHARACTER            **\n**       AND ANALYSE IT                                              **\n**                                                                   **\n**       -- REGISTER ONE CONTAINS TOKEN OFFSET IN BUFFER             **\n**                                                                   **\n***********************************************************************\n         SPACE 1\n         LA    R2,SBGBUF           ADDRESS OF GROUPS BUFFER\n         AR    R2,R1               GROUPE OF FIRST CHARACTER FOR\n*                                  + CURRENT SYMBOL\n         ST    R2,SCATOMA          SAVE THIS ADDRESS\n         XR    R1,R1               CLEAR BEFORE BRANCH\n         ICM   R1,B'0001',0(R2)    INSERT 1ST CHARACTER GROUP\n         BZ    SCERR1              ILLEGAL, END OF PROCESSING\n         B     *(R1)               BRANCH ACCORDING TO GROUP\n         B     SCLET               LETTER (A - F)\n         B     SCLET               LETTER (G - Z), @, #, _\n         B     SCNUM               DIGIT (0 - 9)\n         B     SCDLMS              SIMPLE DELIMITER\n         B     SCDLMM              MULTIPLE DELIMITER\n         B     SCQUOT              QUOTE\n         B     *-*                 RESERVED\n         TITLE '-- S C A N - PROCESS PARAMETERS --'\n***********************************************************************\n**                                                                   **\n**       PROCESS A SYMBOL                                            **\n**                                                                   **\n**       -- FIRST CHARACTER IS ALPHABETIC, REST IS ALPHANUMERIC      **\n**                                                                   **\n***********************************************************************\n         SPACE 1\nSCLET    LA    R15,SCTSYM          TYPE = SYMBOL\n         LA    R2,1(R2)            POINT TO NEXT\n         CLI   0(R2),SCGERR        ERROR ?\n         BE    SCEXIT              NO, STOP\n         CLI   0(R2),SCGNUM        DIGIT OR LETTER ?\n         BNH   SCLET               YES, CONTINUE\n         B     SCEXIT              RETURN TO CALLER\n         SPACE 1\n***********************************************************************\n**                                                                   **\n**       PROCESS A NUMBER                                            **\n**                                                                   **\n**       -- IT MIGHT BE HEX OR DECIMAL ...                           **\n**                                                                   **\n***********************************************************************\n         SPACE 1\nSCNUM    LA    R15,SCTDEC          INITIALIZE TYPE TO DECIMAL\n*                                  IF ANY HEX CHARACTER (A-F) IS\n*                                  + FOUND, TYPE WILL BE CHANGED TO\n*                                  + \"SCTHEX\"\nSCCHIB   LA    R2,1(R2)            SKIP TO NEXT CHARACTER\n         CLI   0(R2),SCGNUM        DIGIT ?\n         BE    SCCHIB              YES, LOOP ON NUMBER\n         CLI   0(R2),SCGHEX        LETTER ? (A-F)\n         BNE   SCEXIT              NO, THAT IS IT, ALL IS DONE\n         LA    R15,SCTHEX          INITIALIZE TYPE HEX\n         B     SCCHIB              CONTINUE PROCESSING\n         SPACE 1\n***********************************************************************\n**                                                                   **\n**       PROCESS A SIMPLE DELIMITER (1 CHARACTER)                    **\n**                                                                   **\n***********************************************************************\n         SPACE 1\nSCDLMS   LA    R15,SCTDLM          TYPE = DELIMITER\n         LA    R2,1(R2)            SKIP TO NEXT CHARACTER\n         B     SCEXIT              RETURN\n         EJECT\n***********************************************************************\n**                                                                   **\n**       PROCESS A MULTIPLE DELIMITER (MANY CHARACTERS)              **\n**       -- THE POSSIBLE DELIMITERS ARE :                            **\n**                                                                   **\n**           **,<>,>=,<=,\u00ac=,/*,/*,:=                                 **\n**                                                                   **\n***********************************************************************\n         SPACE 1\nSCDLMM   L     R4,SBATOMA          TOKEN ADDRESS\n         LR    R0,R2               SAVE REGISTER\n         TRT   0(1,R4),SCDLMTBL    TRANSLATE TO CORRESPONDING OFFSET\n         N     R2,=X'000000FF'     ZERO OUT 3 FIRST BYTES\n         LR    R1,R2               LOAD BRANCH OFFSET\n         LR    R2,R0               REINITIALIZE REGISTER\n         B     *(R1)               BRANCH ACCORDING TO FIRST CHARACTER\n         B     SCDLM00             X'04' * OR ** */\n         B     SCDLM01             X'08' <    <= <>\n         B     SCDLM02             X'0C' >    >=\n         B     SCDLM02             X'10' \u00ac    \u00ac=\n         B     SCDLM02             X'14' :    :=\n         B     SCDLM03             X'18' /    /*\nSCDLM00  CLI   1(R4),C'*'          IS-IT ** ?\n         BE    SCDLMOK             YES, IT'S CORRECT\n         CLI   1(R4),C'/'          IS-IT */ ?\n         BE    SCDLMOK             YES, IT'S CORRECT\n         B     SCDLMS              NO, IT'S A SIMPLE DELIMITER\nSCDLM01  CLI   1(R4),C'='          IS-IT <= ?\n         BE    SCDLMOK             YES, IT'S CORRECT\n         CLI   1(R4),C'>'          IS-IT <> ?\n         BE    SCDLMOK             YES, IT'S CORRECT\n         B     SCDLMS              NO, IT'S A SIMPLE DELIMITER\nSCDLM02  CLI   1(R4),C'='          IS-IT >= \u00ac= := ?\n         BE    SCDLMOK             YES, IT'S CORRECT\n         B     SCDLMS              NO, IT'S A SIMPLE DELIMITER\nSCDLM03  CLI   1(R4),C'*'          IS-IT /* ?\n         BNE   SCDLMS              NO, IT'S A SIMPLE DELIMITER\n         B     SCDCOMM             GO PROCESS A COMMENT (SKIP IT)\nSCDLMOK  LA    R15,SCTDLM          TYPE = DELIMITER\n         LA    R2,2(R2)            POINT TO NEXT CHARACTER (L=2)\n         B     SCEXIT              IT'S ALL\n         EJECT\n***********************************************************************\n**                                                                   **\n**        WE ARE PROCESSING A COMMENT, SKIP IT UNTIL */ IS FOUND     **\n**                                                                   **\n***********************************************************************\n         SPACE 1\nSCDCOMM  LA    R1,SBTXT            ADDRESS OF TEXT BUFFER\n         LR    R3,R1               SET REGISTER TO POINT\n         AH    R3,SBTXTLN          + TO END OF BUFFER\n         BCTR  R3,0                POINT TO LAST CHARACTER OF BUFFER\n         LA    R2,1                INITIALIZE TO 1 (INCREMENT)\nSCDCNXT  CLC   0(2,R4),=C'*/'      END OF COMMENT ?\n         BE    SCDCRET             YES, GO RETRY SCAN\n         BXLE  R4,R2,SCDCNXT       POINT TO NEXT CHARACTER\n*                                  + IF IT IS NOT FINISHED\n         B     SCREINIT            IF END OF BUFFER, RETURN\nSCDCRET  LA    R4,2(R4)            POINT TO NEXT CHARACTER FOLLOWING */\n         SR    R4,R1               GET OFFSET FROM BUFFER BEGINNING\n         STH   R4,SBTXTOFS         SAVE IT IN TEXT CONTROL BLOCK\n         B     SCOKINIT            + AND RESTART SCAN\n         SPACE 1\n***********************************************************************\n**                                                                   **\n**       PROCESS A CHARACTERS STRING                                 **\n**                                                                   **\n***********************************************************************\n         SPACE 1\nSCQUOT   LA    R15,SCTSTR          TYPE = STRING\n         LA    R1,1(R2)            POINT TO NEXT GROUP OF CHARACTER\n         LA    R2,1                INITIALIZE TO 1 (INCREMENT)\n         LA    R3,SBGBUF           ADDRESS OF BUFFER\n         AH    R3,SBTXTLN          POINTER AFTER LAST CHARACTER\n         BCTR  R3,0                POINTER TO LAST CHARACTER\nSCAPO00  CLI   0(R1),SCGAPO        IS-IT A QUOTE ?\n         BE    SCAPO01             YES, CHECK IF WE REACHED END\n         BXLE  R1,R2,SCAPO00       POINT TO NEXT CHARACTER\n*                                  IF NOT THE END\n         LR    R2,R1               POINTER TO LAST CHARACTER\n         B     SCERR1              IT'S AN ERROR\nSCAPO01  CLI   1(R1),SCGAPO        IS-IT AGAIN A QUOTE ?\n         BNE   SCAPO02             NO, WE TERMINATED\n         LA    R1,2(R1)            POINT TI NEXT CHARACTER\n         B     SCAPO00             LOOK FOR ENDING QUOTE\nSCAPO02  LA    R2,1(R1)            POINTER TO NEXT CHARACTER\n         B     SCEXIT              END OF PROCESSING\n         TITLE '-- S C A N - ERROR/END OF TOKEN PROCESSES --'\n***********************************************************************\n**                                                                   **\n**       PROCESS AN ERROR                                            **\n**                                                                   **\n***********************************************************************\n         SPACE 1\nSCERR1   LA    R15,SCTERR          SYNTAX ERROR\n         LA    R2,1(R2)            IGNORE CHARACTER IN ERROR\n         SPACE 1\n***********************************************************************\n**                                                                   **\n**       END OF TOKEN PROCESSING                                     **\n**       WE MUST REINITIALIZE FIELD \"SBTXTOFS\"                       **\n**                                                                   **\n**          REGISTER 2 POINTS TO END OF SYMBOL                       **\n**          REGISTER 15 CONTAINS TOKEN TYPE                          **\n**                                                                   **\n**       TO RETURN, REGISTER 0 MUST CONTAIN LENGTH                   **\n**                  REGISTER 1 MUST POINT TO SYMBOL                  **\n**                  REGISTER 15 IS SET TO TOKEN TYPE                 **\n**                                                                   **\n***********************************************************************\n         SPACE 1\nSCEXIT   LR    R0,R2               CALCULATE TOKEN LENGTH\n         S     R0,SCATOMA          SET R0 TO IT\n         LA    R1,SBGBUF           ADDRESS OF GROUP\n         SR    R2,R1               OFFSET\n         STH   R2,SBTXTOFS         SAVE IT BACK IN CONTROL BLOCK\n         L     R1,SBATOMA          SET R1 TO TOKEN ADDRESS (RETURN IT)\n         L     R2,4(RSAVE)         POINT TO PREVIOUS SAVE AREA\n         STM   R15,R1,16(R2)       SAVE RETURNED REGISTERS\n         $SUBRET ,                 RETURN TO CALLER\n         TITLE '-- S C A N - CONSTANTS AND EXECUTED INSTRUCTIONS --'\n***********************************************************************\n**                                                                   **\n**       CONSTANTS DEFINITIONS                                       **\n**                                                                   **\n***********************************************************************\n         SPACE 1\n         LTORG ,                   LITERAL POOL DEFINITION\n         SPACE 1\n***********************************************************************\n**                                                                   **\n**       MULTIPLE DELIMITERS TABLE                                   **\n**                                                                   **\n***********************************************************************\n         SPACE 1\nSCDLMTBL DC    256X'00'            INITIALIZE TABLE TO ZEROES\n         ORG   SCDLMTBL+C'*'       STARTING WITH * : ** */\n         DC    X'04'\n         ORG   SCDLMTBL+C'<'       STARTING WITH < : <= <>\n         DC    X'08'\n         ORG   SCDLMTBL+C'>'       STARTING WITH > : >=\n         DC    X'0C'\n         ORG   SCDLMTBL+C'\u00ac'       STARTING WITH \u00ac : \u00ac=\n         DC    X'10'\n         ORG   SCDLMTBL+C':'       STARTING WITH : : :=\n         DC    X'14'\n         ORG   SCDLMTBL+C'/'       STARTING WITH / : /*\n         DC    X'18'\n         ORG   ,                   REORG TO END OF TABLE\n         EJECT\n***********************************************************************\n**                                                                   **\n**       GROUPS TRANSCRIPTION TABLE                                  **\n**                                                                   **\n**       FOLLOWING ARE THE GROUPS ASSOCIATED WITH CHARACTERS :       **\n**                                                                   **\n**       X'00' : ERROR -- ILLEGAL CHARACTER                          **\n**       X'04' : A-F                                                 **\n**       X'08' : G-Z, @, #, _                                        **\n**       X'0C' : 0-9                                                 **\n**       X'10' : SIMPLE DELIMITER                                    **\n**       X'14' : MULTIPLE DELIMITER                                  **\n**       X'18' : QUOTE                                               **\n**                                                                   **\n***********************************************************************\n         SPACE 1\nSCGERR   EQU   X'00'               ERROR\nSCGHEX   EQU   X'04'               A - F\nSCGLET   EQU   X'08'               G - Z, @, #, _\nSCGNUM   EQU   X'0C'               0 - 9\nSCGDLS   EQU   X'10'               SIMPLE DELIMITER\nSCGDLM   EQU   X'14'               MULTIPLE DELIMITER\nSCGAPO   EQU   X'18'               QUOTE\n         SPACE 1\nSCGTAB   DC    0XL256'00'\n*                0 1 2 3 4 5 6 7 8 9 A B C D E F\n         DC    X'00000000000000000000000000000000'  0\n         DC    X'00000000000000000000000000000000'  1\n         DC    X'00000000000000000000000000000000'  2\n         DC    X'00000000000000000000000000000000'  3\n         DC    X'00000000000000000000001014101010'  4\n         DC    X'10000000000000000000101014101014'  5\n         DC    X'10140000000000000000001010081410'  6\n         DC    X'00000000000000000000140808181010'  7\n         DC    X'00000000000000000000000000000000'  8\n         DC    X'00000000000000000000000000000000'  9\n         DC    X'00000000000000000000000000000000'  A\n         DC    X'00000000000000000000000000000000'  B\n         DC    X'00040404040404080808000000000000'  C\n         DC    X'00080808080808080808000000000000'  D\n         DC    X'00000808080808080808000000000000'  E\n         DC    X'0C0C0C0C0C0C0C0C0C0C000000000000'  F\n         SPACE 1\n         LTORG ,                   LITERAL POOL DEFINITION\n         TITLE '-- M S S E N D - SEND MESSAGE ROUTINE --'          -EU-\n*******************************************************************-EU-\n**                                                                 -EU-\n**                      ----  M S S E N D  ----                    -EU-\n**                                                                 -EU-\n**           THIS SUBROUTINE, CALLED BY UTILITIES PROCESSOR, WILL  -EU-\n**       SEND MESSAGE BY TPUT OR WTO DEPENDING IF IN TSO OR NOT,   -EU-\n**       AND EVENTUALLY USE TGET OR WTOR IF A REPLY IS REQUESTED   -EU-\n**                                                                 -EU-\n**           -- INPUT :  RPARM    WTO/WTOR MESSAGE ADDRESS         -EU-\n**                       RLINK    RETURN ADDRESS                   -EU-\n**                                                                 -EU-\n**           -- OUTPUT : MESSAGE IS SENT (RCODE = 0)               -EU-\n**                       RCODE = 0 - REPLY IS \"YES\"                -EU-\n**                       RCODE = 4 - REPLY IS \"NO\"                 -EU-\n**                       RCODE = 8 - TGET ERROR                    -EU-\n**                                                                 -EU-\n*******************************************************************-EU-\n**                                                                 -EU-\n**       LOCAL VARIABLES DEFINITION                                -EU-\n**                                                                 -EU-\n*******************************************************************-EU-\n         SPACE 1                                                   -EU-\nMSDS     DSECT                                                     -EU-\nRECB     DC    F'0'                REPLY ECB                       -EU-\nRAREA    DC    XL8'0'              REPLY AREA                      -EU-\nRWTO     WTOR  'SCK0000* -- ... MESSAGE TEXT ...',                 -EU-*\n               *-*,*-*,*-*,MF=L                                    -EU-\n         DC    XL100'0'            WORK SPACE                      -EU-\n         CNOP  0,8                                                 -EU-\nMSLN     EQU   *-MSDS                                              -EU-\n         EJECT                                                     -EU-\nMSSEND   $SUB  MSDS,MSLN           LOAD INPUT PARAMETERS SUBROUTINE-EU-\n         SPACE 1                                                   -EU-\n         LTR   RPARM,RPARM         REPLY REQUESTED ?               -EU-\n         BM    REPLY               YES                             -EU-\n         AL    RPARM,=V(MSDATA)    COMPUTE MESSAGE ADDRESS         -EU-\n         TM    SCFLAGS,SCFTEST     ARE WE IN TSO ?                 -EU-\n         BO    MSTSO               YES                             -EU-\n         TM    2(RPARM),X'80'      MCS FLAGS ?                     -EU-\n         BZ    NOMCS               NO                              -EU-\n         LR    R2,RPARM                                            -EU-\n         AH    R2,0(RPARM)         POINT TO DESCRIPTOR CODES       -EU-\n         TM    0(R2),X'40'         DESC=2 ?                        -EU-\n         BO    SDWTO               YES                             -EU-\nNOMCS    XR    R2,R2                                               -EU-\nSDWTO    WTO   MF=(E,(1))          SEND MESSAGE TO OPERATOR        -EU-\n         LTR   R2,R2                                               -EU-\n         BZ    MSEXIT                                              -EU-\n         ST    R1,RDOM             GET MESSAGE ID                  -EU-\n         OI    RDOM,X'80'          CLOSE MESSAGE ID'S LIST         -EU-\n         B     MSEXIT                                              -EU-\nMSTSO    LH    R0,0(RPARM)         GET WTO MESSAGE LENGTH          -EU-\n         SH    R0,=H'4'            ADJUST LENGTH FOR TPUT          -EU-\n         LA    RPARM,4(RPARM)      POINT TO MESSAGE TEXT           -EU-\n         TPUT  (1),(0),EDIT        SEND MESSAGE TO TERMINAL        -EU-\n         B     MSEXIT                                              -EU-\n         SPACE 1                                                   -EU-\nREPLY    LA    RPARM,0(RPARM)      CLEAR HIGH ORDER BYTE           -EU-\n         AL    RPARM,=V(MSDATA)    COMPUTE MESSAGE ADDRESS         -EU-\n         LH    R2,0(RPARM)         GET WTO MESSAGE LENGTH          -EU-\n         LA    R2,3(R2)            ADJUST LENGTH FOR MOVE          -EU-\n         EX    R2,RPMOVE           MOVE WTO MESSAGE TEXT           -EU-\n         TM    SCFLAGS,SCFTEST     ARE WE IN TSO ?                 -EU-\n         BO    RPTSO               YES                             -EU-\n         LA    R2,RAREA                                            -EU-\n         O     R2,=A(X'80000000')                                  -EU-\n         ST    R2,RWTO                                             -EU-\n         MVI   RWTO+8,L'RAREA                                      -EU-\n         LA    R2,RECB                                             -EU-\n         ST    R2,RWTO+4                                           -EU-\nRPWTOR   XC    RECB,RECB           SEND MESSAGE AND WAIT REPLY     -EU-\n         XC    RAREA,RAREA                                         -EU-\n         WTOR  MF=(E,RWTO)                                         -EU-\n         WAIT  ECB=RECB                                            -EU-\n         B     RPLY                                                -EU-\nRPMOVE   MVC   RWTO+8(*-*),0(RPARM)                                -EU-\nRPTSO    LH    R0,RWTO+8           GET WTO MESSAGE LENGTH          -EU-\n         SH    R0,=H'4'            ADJUST LENGTH FOR TPUT          -EU-\n         TPUT  RWTO+12,(0),EDIT    SEND MESSAGE TO TERMINAL        -EU-\n         XC    RAREA,RAREA                                         -EU-\n         TGET  RAREA,L'RAREA                                       -EU-\n         LTR   R15,R15                                             -EU-\n         BZ    RPLY                                                -EU-\n         CH    R15,=H'12'                                          -EU-\n         BNE   RPERR                                               -EU-\n         TCLEARQ INPUT                                             -EU-\n         B     RPTSO                                               -EU-\nRPLY     OC    RAREA,=CL8' '                                       -EU-\n         CLC   RAREA(4),=CL4'YES'                                  -EU-\n         BE    MSEXIT                                              -EU-\n         CLC   RAREA(2),=CL2'Y'                                    -EU-\n         BE    MSEXIT                                              -EU-\n         CLC   RAREA(3),=CL3'NO'                                   -EU-\n         BE    RPNO                                                -EU-\n         CLC   RAREA(2),=CL2'N '                                   -EU-\n         BE    RPNO                                                -EU-\n         TM    SCFLAGS,SCFTEST     ARE WE IN TSO ?                 -EU-\n         BO    RPTSO               YES                             -EU-\n         B     RPWTOR              NO                              -EU-\nRPERR    LA    RCODE,8             SET RETURN CODE = 8             -EU-\n         B     MSRET                                               -EU-\nRPNO     LA    RCODE,4             SET RETURN CODE = 4             -EU-\n         B     MSRET                                               -EU-\nMSEXIT   XR    RCODE,RCODE         SET RETURN CODE = 0             -EU-\n         SPACE 1                                                   -EU-\nMSRET    $SUBRET                   RETURN TO CALLER                -EU-\n         SPACE 1                                                   -EU-\n         LTORG ,                   LITERAL POOL DEFINITION         -EU-\n         TITLE '-- M S D A T A - MESSAGE''S TEXT --'               -EU-\nMSDATA   CSECT ,                   START OF MESSAGES               -EU-\n         SPACE 1                                                   -EU-\nSCK0001E GENMS 'SCK0001E -- ERROR DETECTED IN INPUT PARAMETERS'\nSCK0002E GENMS 'SCK0002E -- SUPERVISOR MODE COULD NOT BE OBTAINED'\nSCK0003E GENMS 'SCK0003E -- ERROR ENCOUNTERED, PROCESS ENDED'\nSCK0004I GENMS 'SCK0004I -- DISCONNECT - DATE ERROR',DC=2          -EU-\nSCK0005E GENMS 'SCK0005E -- VALUE TYPE DOES NOT MATCH KEYWORD'\nSCK0006E GENMS 'SCK0006E -- DASD DEVICE DID NOT OPEN PROPERLY'\nSCK0007E GENMS 'SCK0007E -- I/O ERROR ON THE CHECKPOINT DATA-SET'\nSCK0008E GENMS 'SCK0008E -- INVALID PARM WAS SPECIFIED (RESET ?)'\nSCK0009E GENMS 'SCK0009E -- SETPARM NOT ALLOCATED, USING DEFAULTS'\nSCK0010A GENMS 'SCK0010A -- REPLY YES/NO (Y/N)',DC=2               -EU-\nSCK0010D GENMS 'SCK0010D -- TERMINAL ERROR, \"NO\" ASSUMED'\nSCK0010I GENMS 'SCK0010I -- NO OTHER ACTIVE CPU FOUND'\nSCK0010W GENMS 'SCK0010W -- WAITING FOR SYNCHRONIZATION'\nSCK0011E GENMS 'SCK0011E -- TO MANY VALUES SUPPLIED'\nSCK0011I GENMS 'SCK0011I -- TIME ESTIMATION MIGHT NOT BE ACCURATE'\nSCK0012E GENMS 'SCK0012E -- ERROR OCCURED WHILE SCANNING'\nSCK0012I GENMS 'SCK0012I -- ALL CPU''S WILL BE SYNCHRONIZED'\nSCK0013E GENMS 'SCK0013E -- KEYWORD EXPECTED BUT BAD SYMBOL FOUND'\nSCK0013I GENMS 'SCK0013I -- DISCONNECT - TIME HAS EXPIRED'\nSCK0014E GENMS 'SCK0014E -- EXPECTED \"=\" NOT FOUND, \"=\" ASSUMED'\nSCK0014I GENMS 'SCK0014I -- THIS CPU WILL BE USED AS REFERENCE'\nSCK0015A GENMS 'SCK0015A -- PLEASE, DEPRESS TOD CLOCK KEY',DC=2    -EU-\nSCK0015E GENMS 'SCK0015E -- PARTIAL SYNCHRONIZATION WILL BE DONE'\nSCK0015I GENMS 'SCK0015I -- CLOCKS SYNCHRONIZATION IN PROGRESS'\nSCK0016I GENMS 'SCK0016I -- CHECKPOINT RECORD WILL BE RESET'\nSCK0017E GENMS 'SCK0017E -- RETRY LATER OR RESET CHECKPOINT'\nSCK0017I GENMS 'SCK0017I -- TOO LATE FOR THIS CPU ...'\nSCK0018E GENMS 'SCK0018E -- DISCREPANCY IS MORE THAN &MAXDISC MINUTES, *\n               CLOCK NOT SET',DC=2                            -EU-V1.01\nSCK0019I GENMS 'SCK0019I -- TIME/DATE : HH.MM.SS/YY.DDD',DC=2      -EU-\nSCK0020E GENMS 'SCK0020E -- MAX NUMBER OF CPU''S EXCEEDED'         -EU-\nSCK0021E GENMS 'SCK0021E -- SMF SYSTEM-ID NOT SUPPORTED'           -EU-\nSCK0022E GENMS 'SCK0022E -- DUPLICATE SMF SYSTEM-ID IN COMPLEX'    -EU-\nSCK0023E GENMS 'SCK0023E -- SNAP-DUMP OPEN ERROR'                  -EU-\nSCK0024E GENMS 'SCK0024E -- SNAP-DUMP ERROR (R.C.=HH)'             -EU-\nSCK0025I GENMS 'SCK0025I -- SCAN TERMINATED'                       -EU-\n         TITLE '-- S N D M P - STACK SNAP-DUMP ROUTINE --'         -EU-\n*******************************************************************-EU-\n**                                                                 -EU-\n**                      ----  S N D M P  ----                      -EU-\n**                                                                 -EU-\n**           THIS SUBROUTINE, CALLED BY UTILITIES PROCESSOR,       -EU-\n**       WILL STACK SNAP-DUMP OF DATA AREAS (DEBUG AID) IF         -EU-\n**       'SYSSNAP' DD-NAME FILE IS PRESENT.                        -EU-\n**           WHEN THE STACKS ARRAY IS EXHAUSTED ANY NEW SNAP       -EU-\n**       REQUESTS IS LOST (SEE LABEL \"SNSTCKS\" FOR ARRAY SPACE).   -EU-\n**                                                                 -EU-\n**           -- INPUT :  R1       SNAP START ADDRESS               -EU-\n**                       RLINK+0  SNAP-ID NUMBER                   -EU-\n**                            +1  SNAP LENGTH                      -EU-\n**                            +4  RETURN ADDRESS                   -EU-\n**                                                                 -EU-\n*******************************************************************-EU-\n         SPACE 2                                                   -EU-\nSNDMP    $SUB  ,,                  LOAD INPUT PARAMETERS SUBROUTINE-EU-\n         SPACE 1                                                   -EU-\n         TM    SCFLAGS,SCFSNAP     SNAP-DUMP REQUESTED ?           -EU-\n         BZ    SNRTN               NO, SKIP ALL                    -EU-\n         L     R4,CSTCK                                            -EU-\n         LR    R6,R4                                               -EU-\n         XR    R5,R5                                               -EU-\n         ICM   R5,B'0111',1(R14)   GET LENGTH                      -EU-\n         ALR   R6,R5                                               -EU-\n         CL    R6,LSTCK                                            -EU-\n         BH    SNRTN               SKIP IF STACKS ARRAY FULL       -EU-\n         LR    R2,R1               SET START DATA ADDRESS          -EU-\n         XR    R0,R0                                               -EU-\n         IC    R0,0(R14)           SNAP-ID NO. VALUE               -EU-\n         LR    R1,R0               LOAD IT'S CONTENT               -EU-\n         SRL   R1,3                DIVIDE BY 8                     -EU-\n         LA    R3,SCPSNF(R1)       POINT TO BYTE RECEIVING BIT     -EU-\n         SLL   R1,3                RESET                           -EU-\n         SR    R0,R1               SET TO BIT# TO BE SET           -EU-\n         STC   R0,*+L'*+7          SAVE IT TO CONVERT              -EU-\n         TR    *+L'*+1(1),=XL8'8040201008040201'  TRANSLATE IT     -EU-\n         TM    0(R3),*-*           IS BIT ON ?                     -EU-\n         BZ    SNRTN               NO, SKIP                        -EU-\n         SPACE 1                                                   -EU-\n         MVC   0(4,R4),0(R14)      STORE ID AND LENGTH             -EU-\n         LA    R4,4(R4)                                            -EU-\n         LR    R3,R5                                               -EU-\n         MVCL  R4,R2               STORE DATA                      -EU-\n         ST    R6,CSTCK            UPDATE CURRENT STACK ADDRESS    -EU-\n         SPACE 1                                                   -EU-\nSNRTN    LA    RCODE,4             SET R.C. = 4 TO ADJUST RETURN   -EU-\n         $SUBRET                   RETURN TO CALLER                -EU-\n         SPACE 1                                                   -EU-\n         LTORG ,                   LITERAL POOL DEFINITION         -EU-\n         TITLE '-- E X D M P - EXECUTE SNAP-DUMP ROUTINE --'       -EU-\n*******************************************************************-EU-\n**                                                                 -EU-\n**                      ----  E X D M P  ----                      -EU-\n**                                                                 -EU-\n**           THIS SUBROUTINE, CALLED AT END OF PROCESSING,         -EU-\n**       UNLOAD ALL STACKED SNAP-DUMP DATA AREAS ON 'SYSSNAP'      -EU-\n**       DD-NAME FILE IF PRESENT.                                  -EU-\n**                                                                 -EU-\n*******************************************************************-EU-\n         SPACE 2                                                   -EU-\nEXDMP    $SUB  ,,                  LOAD INPUT PARAMETERS SUBROUTINE-EU-\n         SPACE 1                                                   -EU-\n         TM    SCFLAGS,SCFSNAP     SNAP-DUMP REQUESTED ?           -EU-\n         BZ    SNRET               NO, SKIP ALL                    -EU-\n         CLC   CSTCK,ASTCK         ANY SNAP-DUMP TO DO ?           -EU-\n         BE    SNFR                NO, SKIP                        -EU-\n         LA    R3,SNAPDCB                                          -EU-\n         USING IHADCB,R3                                           -EU-\n         MVC   SNAPDCB(SNAPLL),SNAPCS                              -EU-\n         OPEN  ((R3),OUTPUT),MF=(E,SNAPOP)                         -EU-\n         TM    DCBOFLGS,DCBOFOPN   SNAP-DUMP OPENED ?              -EU-\n         BO    SNOP                YES                             -EU-\n         SEND  SCK0023E                                            -EU-\n         B     SNFR                                                -EU-\nSNOP     LA    R1,SNHD                                             -EU-\n         ST    R1,SNAPHD                                           -EU-\n         OI    SNAPHD,X'80'                                        -EU-\n         L     R4,ASTCK            START OF STACKS                 -EU-\nSNNX     XR    R2,R2                                               -EU-\n         IC    R2,0(R4)            GET SNAP-ID                     -EU-\n         XR    R5,R5                                               -EU-\n         ICM   R5,B'0111',1(R4)    GET LENGTH                      -EU-\n         LA    R1,4(R4)            DATA START ADDRESS              -EU-\n         ST    R1,SNAPLST                                          -EU-\n         ALR   R1,R5                                               -EU-\n         ST    R1,SNAPLST+4                                        -EU-\n         OI    SNAPLST+4,X'80'                                     -EU-\n         SNAP  DCB=(R3),TCB='S',ID=(R2),LIST=SNAPLST,              -EU-*\n               STRHDR=SNAPHD,MF=(E,SNAPLIST)                       -EU-\n         LTR   R15,R15             ALL OK ?                        -EU-\n         BNZ   SNER                NO, ERROR                       -EU-\n         ALR   R4,R5               NEXT STACK                      -EU-\n         CL    R4,CSTCK                                            -EU-\n         BNL   SNEND               END IF NO MORE                  -EU-\n         CL    R4,LSTCK                                            -EU-\n         BNL   SNEND               ALL STACKS ARRAY PROCESSED      -EU-\n         B     SNNX                CONTINUE WITH NEXT              -EU-\nSNER     L     R14,=A(SCK0024E)    MESSAGE POINTER                 -EU-\n         AL    R14,=V(MSDATA)      WTO MESSAGE ADDRESS             -EU-\n         AH    R14,0(R14)          POINT TO END OF TEXT +1         -EU-\n         SH    R14,=H'3'           BACK TO R.C. TEXT               -EU-\n         STC   R15,1(R14)          SET CC IN MESSAGE               -EU-\n         SRL   R15,4                                               -EU-\n         STC   R15,0(R14)                                          -EU-\n         NC    0(2,R14),=XL2'0F0F'                                 -EU-\n         TR    0(2,R14),=CL16'0123456789ABCDEF'                    -EU-\n         SEND  SCK0024E                                            -EU-\nSNEND    CLOSE (SNAPDCB),MF=(E,SNAPCL)                             -EU-\nSNFR     L     R0,=A(STCKSL)       FREE STACKS ARRAY               -EU-\n         L     R1,ASTCK                                            -EU-\n         FREEMAIN R,LV=(0),A=(1)                                   -EU-\n         SPACE 1                                                   -EU-\nSNRET    XR    RCODE,RCODE         SET RETURN CODE = 0             -EU-\n         $SUBRET                   RETURN TO CALLER                -EU-\n         SPACE 1                                                   -EU-\n         LTORG ,                   LITERAL POOL DEFINITION         -EU-\n         TITLE '-- S N D M P - SKELETONS AND CONSTANTS --'         -EU-\nSNAPCS   DCB   DSORG=PS,RECFM=VBA,MACRF=(W),BLKSIZE=1632,          -EU-*\n               LRECL=125,DDNAME=SYSSNAP                            -EU-\n         OPEN  (*-*),MF=L                                          -EU-\n         CLOSE (*-*),MF=L                                          -EU-\n         SNAP  MF=L                                                -EU-\nSNAPLL   EQU   *-SNAPCS                                            -EU-\n         SPACE 1                                                   -EU-\nSNHD     DC    AL1(L'SNHDT)                                        -EU-\nSNHDT    DC    C'S E T C L O C K - DATA AREAS STATUS (DEBUG AID).' -EU-\n         TITLE '-- L O C A L     D S E C T S --'\n***********************************************************************\n**                                                                   **\n**       SYSTEM ENTRY -- THERE IS ONE ENTRY FOR EACH SYSTEM          **\n**                                                                   **\n***********************************************************************\n         SPACE 1\nCKSYS    DSECT                     DEFINE SYSTEM ENTRY DSECT       -EU-\n         SPACE 1                                                   -EU-\nCKSID    DS    CL4                 SYSTEM ID\nCKSSTAT  DS    C                   SYSTEM STATUS\nCKTWAIT  EQU   C'W'                -- WAIT\nCKTTRACK EQU   C'T'                -- TRACKED\nCKTLOCK  EQU   C'L'                -- LOCKED\nCKTTIME  EQU   C'R'                -- TIME REFRESHED\nCKTSET   EQU   C'S'                -- TIME IS SET\nCKTDISC  EQU   C'D'                -- DISCONNECTED\nCKSREQ   DS    C                   INDICATORS                      -EU-\nCKTRFCPU EQU   C'R'                -- REFERENCE CPU                -EU-\nCKTADD   EQU   C'A'                -- ADD DISCREPANCY VALUE        -EU-\nCKTSUB   EQU   C'S'                -- SUBSTRACT DISCREPANCY VALUE  -EU-\n         DS    2X                  RESERVED                        -EU-\nCKSYSCLK DS    D                   SYSTEM CLOCK -- CPU CLK WHEN REQUEST\n*                                  WAS TO 'LOCK'\nCKSTIME  DS    F                   TIME OF DAY IN 100TH OF SEC.    -EU-\nCKCVTTZ  DS    F                   LOCAL-GREENWICH DEVIATION.      -EU-\n         SPACE 1                                                   -EU-\nCKSYSL   EQU   (((*-CKSYS)+7)/8)*8 LENGTH ROUNDED TO DOUBLEWORD    -EU-\n         EJECT\n***********************************************************************\n**                                                                   **\n**       CHECKPOINT RECORD DESCRIPTION                               **\n**                                                                   **\n***********************************************************************\n         SPACE 1\nCHECKPT  DSECT                     DEFINE CHECKPOINT RECORD DSECT\n         SPACE 1\nCKHKEY   DS    XL8                 HARDWARE KEY DESCRIPTION\n*\n*              X'0000000000000000' -- FREE LOCK HARD KEY\n*\n         ORG   CKHKEY\n         DC    X'FFFFFFFF'         LOCKED STATE KEY\nCKLKSID  DS    CL4                 LOCKED CHECKPOINT SYSTEM ID (OWNER)\nCKID     DC    C'CKPT'             CHECKPOINT RECORD ID\nCKREQ    DS    X                   REQUEST CODE\nCKRLWAIT EQU   X'00'               -- LONG WAIT\nCKRTRACK EQU   X'04'               -- TRACK SYSTEM\nCKRLOCK  EQU   X'08'               -- LOCK  SYSTEM\nCKRSET   EQU   X'0C'               -- SET TIME AND DATE\nCKREND   EQU   X'10'               -- TERMINATE PROGRAM (END)\nCKCREQ   DS    C                   \"CHARACTER REQUEST\"\nCKCRLW   EQU   C'W'                -- LONG WAIT\nCKCRTR   EQU   C'T'                -- TRACK\nCKCRTL   EQU   C'L'                -- LOCK\nCKCRST   EQU   C'S'                -- SET TIME\nCKCRND   EQU   C'E'                -- END OF PROGRAM\nCKFLAGS  DS    FL1                 GLOBAL CHECKPOINT FLAGS\nCKFLOCK  EQU   B'00000001'         ALL SYSTEMS GOT THE LOCK STATE\n         DS    X                   RESERVED\nCKRDATE  DS    PL4                 DATE IN FORMAT X'00YYDDDF'      -EU-\nCKNACPU  DS    H                   NUMBER OF ACTIVE CPU (TRACKED BEFORE\n*                                  DISCONNECT TIME IS REACHED)\nCKNRCPU  DS    H                   RESIDUAL NUMBER OF CPU'S TO REACH\n*                                  THE \"LOCK\" STATE OR THE \"SET\" STATE\nCKSCLOCK DS    D                   CLOCK TO BE SET\n         DS    0D                  ALIGN ENTRIES TO DOUBLEWORD\nCKSENTRY DS    (MAXCPUD)XL(CKSYSL) SYSTEM ENTRY (THERE IS AS       -EU-\n*                                  MANY SYSTEM ENTRIES AS THERE    -EU-\n*                                  ARE CPU'S TO BE SYNCHRONIZED    -EU-\n*                                  TOGETHER).                      -EU-\n         SPACE 1                                                   -EU-\nCKLEN    EQU   *-CHECKPT           CHECKPOINT RECORD LENGTH        -EU-\n         EJECT\n***********************************************************************\n**                                                                   **\n**       SCAN CONTROL BLOCK DSECT DEFINITION                         **\n**                                                                   **\n***********************************************************************\n         SPACE 1\n         SCANTCB LIST=YES\n         EJECT\n***********************************************************************\n**                                                                   **\n**       WORK DSECT -- STORAGE WORK AREA                             **\n**                                                                   **\n***********************************************************************\n         SPACE 1\nWORK     DSECT                     WORK AREA DSECT DESCRIPTION\n         SPACE 1\nAREA     DS    18F                 MAINLINE SAVE AREA\nAREA2    DS    18F                 SECOND LEVEL ROUTINES SAVE AREA\nRLSAVE   DS    F                   SAVE PROCESS RETURN REGISTER    -EU-\nSCWEXTR  EXTRACT *-*,'S',MF=L                                      -EU-\nSCWTIOT  DS    F                                                   -EU-\nSCWTSO   DS    F                                                   -EU-\nSCWDBLE  DS    D                   WORK DOUBLE WORD\nSCWPKBUF DS    PL8                 PACK BUFFER\nSCSYSID  DS    CL4                 SYSTEM ID\nSCENTRYP DS    A                   POINTER TO THE SYSTEM ENTRY IN THE\n*                                  CHECKPOINT BUFFER\nSCCKCNT  DS    XL8                 COUNT FIELD (SHOULD IMMEDIATELY\n*                                  PRECEEDE 'SCCKPNT' -- USED TO\n*                                  WRITE THE RECORD)\n         ORG   SCCKCNT             RESET POINTER TO COUNT FIELD\nSCCKID   DC    XL5'0000000000'     COUNT ID (CCHHR)\nSCCKLEN  DS    AL3                 RECORD LENGTH\n         ORG   SCCKLEN             RESET ORDINAL COUNTER\n         DC    AL1(L'CKHKEY)       -- KEY  LENGTH\n         DC    AL2(CKLEN-L'CKHKEY) -- DATA LENGTH\nSCCKPNT  DS    XL(CKLEN)           CHECKPOINT RECORD BUFFER\nSCDCLOCK DS    D                   CLOCK WORK DOUBLE WORD\nSCWTIME  DS    F                   CURRENT WAITING TIME\n*                                  -- DEPEND UPON STATE\n         EJECT\n***********************************************************************\n**                                                                   **\n**        SNAP-DUMP WORK AREA                                    -EU-**\n**                                                                   **\n***********************************************************************\n         SPACE 1                                                   -EU-\nSNAPDCB  DCB   DSORG=PS,RECFM=VBA,MACRF=(W),BLKSIZE=1632,          -EU-*\n               LRECL=125,DDNAME=SYSSNAP                            -EU-\nSNAPOP   OPEN  (*-*),MF=L                                          -EU-\nSNAPCL   CLOSE (*-*),MF=L                                          -EU-\nSNAPLIST SNAP  MF=L                                                -EU-\nSNAPLST  DS    2F                                                  -EU-\nSNAPHD   DS    F                                                   -EU-\n         EJECT\n***********************************************************************\n**                                                                   **\n**        INPUT PARAMETERS VARIABLES DEFINITIONS                     **\n**                                                                   **\n***********************************************************************\n         SPACE 1\nSCPRDSA  DS    6F                  RDSCAN COMMUNICATION SAVE AREA\nSCPSTCB  DS    XL(SCANDLN)         SCAN TEXT CONTROL BLOCK\nSCPWAIT  DS    F                   LONG  WAIT TIME (HUNDREDS OF SEC)\nSCPTRACK DS    F                   TRACK WAIT TIME (HUNDREDS OF SEC)\nSCPSEEK  DS    F                   SEEK TIME -- I/O ESTIMATED TIME\nSCPMAXC  DS    F                   MAXIMUM NUMBER OF CPU'S. IF    V1.04\n*                                  RESET IS NOT SPECIFIED, IT     V1.04\n*                                  WILL BE READ FROM CHECKPOINT   V1.04\nSCPDISC  DS    F                   ELAPSED TRACKING TIME  BEFORE\n*                                  CONSIDERING A SYSTEM AS \"INACTIVE\"\nSCPMTHD  DS    F                   SYNCH. METHOD NO.               -EU-\nBASECPU  EQU   1                   -- BY BASE CPU                  -EU-\nSCPLOCK  DS    F                   LOCK WAIT TIME -- SEEK*NACPU\nRDOM     DS    F                   DELETE MESSAGE ID'S LIST        -EU-\nASTCK    DS    F                   FIRST STACK ADDRESS             -EU-\nLSTCK    DS    F                   LAST STACK ADDRESS              -EU-\nCSTCK    DS    F                   CURRENT STACK ADDRESS           -EU-\n         SPACE 1\nSCFLAGS  DS    FL1                 FLAGS\nSCFRESET EQU   B'00000001'         CHECKPOINT RECORD WILL BE RESET\nSCFTEST  EQU   B'00000010'         INDICATE 'TEST' RUN (TSO)       -EU-\nSCFNCMS  EQU   B'00000100'         INDICATE NO SET CLOCK DONE      -EU-\nSCFDTERR EQU   B'00001000'         INDICATE DATE ERROR             -EU-\nSCFSNAP  EQU   B'00010000'         INDICATE SNAP-DUMP REQUEST      -EU-\nSCPFLAGS DS    FL1                 FLAGS BYTE\nSCPFCNT  EQU   B'00000001'         -- CONTINUING SAME KEYWORD PARSE\nSCPFPERR EQU   B'00000010'         -- PARSE ERROR ENCOUNTERED\n         SPACE 1                                                   -EU-\nSCPSNF   DS    XL32                SNAP-ID INDICATORS (0-255)      -EU-\n         SPACE 1\n***********************************************************************\n**                                                                   **\n**       SET DATE MESSAGE MAPPING                                    **\n**                                                                   **\n***********************************************************************\n         SPACE 1\nSCDWMSG  DC    C'SCK0019I -- TIME/DATE : '                         -EU-\nSCDWTIM  DC    C'HH.MM.SS',C'/'    TIME                            -EU-\nSCDWDAT  DC    C'YY.DDD'           DATE\n         SPACE 1                                                   -EU-\nWORKLEN  EQU   (((*-WORK)+7)/8)*8  WORK AREA LENGTH IN DOUBLEWORDS -EU-\n         TITLE '--  S Y S T E M     D S E C T S --'\n***********************************************************************\n**                                                                   **\n**       SYSTEM DSECTS                                               **\n**                                                                   **\n***********************************************************************\n         SPACE 1\n         PUSH  PRINT               SAVE PRINT STATUS\n         PRINT ON,NOGEN            SUPPRESS SYSTEM GENERATION\n         SPACE 1\n         IHAPSA                    PREFIXED STORAGE AREA\n         DCBD DSORG=PS             DATA CONTROL BLOCK\n         IECSDSL1 1                DSCB\n         CVT   DSECT=YES           COMMUNICATION VECTOR TABLE\n         IEESMCA                   SMF CONTROL TABLE (FOR SID)\n         IEZDEB                    DEB MAP AND KEYWORDS\n         IEZIOB                    IOB MAP AND KEYWORDS\nTIODSECT DSECT                                                     -EU-\n         IEFTIOT1 ,                                                -EU-\n         SPACE 1\n         POP   PRINT               RESET PRINT STATUS\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SETCLOCP": {"ttr": 12805, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x855O\\x00\\x855O\\x16\\x15\\x00\\x1b\\x00\\x1b\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-12-20T00:00:00", "modifydate": "1985-12-20T16:15:00", "lines": 27, "newlines": 27, "modlines": 0, "user": "SYSPAJA"}, "text": "./     ADD     NAME=SETCLOCK\n./     NUMBER  NEW1=100,INCR=100\n//SETCLOCK PROC MBR=00,OPT=\n//SETCLOCK EXEC PGM=SETCLOCK,PARM='&OPT'\n//*-------------------------------------------------------------------*\n//*                          S E T C L O C K                          *\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//* SETCLOCK : THIS PROGRAM IS INVOKED TO PERFORM \"CLOCK SYNCHRONI-   *\n//*            ZATION\" BETWEEN CPU'S. IT MUST BE STARTED ON EACH CPU  *\n//*            TO BE SYNCHRONIZED, AND WILL TERMINATE WHEN TIME IS    *\n//*            SET. IF IT IS NOT STARTED ON A CPU 2 MINUTES AFTER     *\n//*            THE LAST \"S SETCLOCK\", THE CPU WILL BE CONSIDERED AS   *\n//*            \"DISCONNECTED\" AND WILL NOT BE SYNCHRONIZED.           *\n//*     NOTE : THIS PROGRAM SHOULD NOT RUN WHEN BATCH OR TSO IS       *\n//*            ACTIVE (BECAUSE SMF RECORDS WOULD BE FALSIFIED),       *\n//*            UNLESS YOU SURE THAT CPU TOD CLOCK WILL NOT BE SET.    *\n//* START ---> WHEN INVOKING THE PROGRAM FOR THE FIRST TIME (OR IF    *\n//*            THERE IS A PROBLEM), YOU SHOULD ENTER :                *\n//*                      S SETCLOCK,OPT=RESET                         *\n//*            ON THE FIRST CPU TO SYNCHRONIZE OR THE BASE CPU, AND   *\n//*                      S SETCLOCK                                   *\n//*            ON THE REMAINING CPU'S.                                *\n//*-------------------------------------------------------------------*\n//STEPLIB   DD DSN=... LINK LIBRARY ...,DISP=SHR       (IF NEEDED)\n//SYSCKPT   DD DSN=........SETCLOCK.SYNCH,DISP=SHR\n//SYSPARM   DD DSN=.... PARAMETERS LIBRARY ...(SCKPRM&MBR),DISP=SHR\n./     ENDUP\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SHOWMVS": {"ttr": 12807, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x932\\x0f\\x00\\x932\\x0f\\x10E\\x152\\x152\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-11-16T00:00:00", "modifydate": "1993-11-16T10:45:00", "lines": 5426, "newlines": 5426, "modlines": 0, "user": "SYSPAJA"}, "text": "SHOW     TITLE '---  S H O W M V S  -  ISPF, TSO or BATCH run ---'\n         PRINT OFF\n* Here follows the Assembly SYSPARM(...) options process which     EU00\n*        allows you to select :                                    EU00\n*        1. NONE or omitted = no list of macros development        EU00\n*           STRING = list only STRING macros development           EU00\n*           FULL = list all macros development                     EU00\n*        2. NONE = skip JES2 data information assembly             EU16\n*           JES2 or omitted = generate JES2 data information (need EU16\n*                             SYS1.HASPSRC to SYSLIB DD-name be    EU16\n*                             concatenated)                        EU16\n*        How to define options : i.e - SYSPARM(FULL)               EU00\n*                                      SYSPARM(,NONE)              EU00\n*        If you want add another selection, you can easily do      EU00\n*        it adjusting below the statements marked \"<===\", define   EU00\n*        the new OPT(n) default, and supply the new option coding  EU00\n*        just before the comment card marked \"---> Add option(s)\". EU00\n         GBLC  &EULST,&EUSTL,&EUJES                           <=== EU16\n         LCLA  &CN,&CT,&LN,&MX,&SB,&ST                             EU00\n         LCLC  &OPT(2)                                        <=== EU16\n&MX      SETA  2                                              <=== EU16\n&OPT(1)  SETC  'NONE'                                              EU00\n&OPT(2)  SETC  'JES2'                                              EU16\n&CN      SETA  K'&SYSPARM                                          EU00\n         AIF   (K'&SYSPARM EQ 0).SP99                              EU00\n&CT      SETA  1                                                   EU00\n&SB      SETA  1                                                   EU00\n&ST      SETA  &CT                                                 EU00\n.SP1     AIF   ('&SYSPARM'(&CT,1) EQ ',').SP2                      EU00\n&CT      SETA  &CT+1                                               EU00\n         AIF   (&CT LE &CN).SP1                                    EU00\n.SP2     ANOP                                                      EU00\n&LN      SETA  &CT-&ST                                             EU00\n         AIF   (&LN EQ 0).SP3                                      EU00\n&OPT(&SB) SETC '&SYSPARM'(&ST,&LN)                                 EU00\n.SP3     ANOP                                                      EU00\n&SB      SETA  &SB+1                                               EU00\n         AIF   (&SB GT &MX).SP99                                   EU16\n&CT      SETA  &CT+1                                               EU00\n         AIF   (&CT GT &CN).SP99                                   EU00\n&ST      SETA  &CT                                                 EU00\n         AGO   .SP1                                                EU00\n.SP99    ANOP                                                      EU00\n&EULST   SETC  'GEN'                                               EU00\n&EUSTL   SETC  'GEN'                                               EU00\n         AIF   ('&OPT(1)' EQ 'FULL').SL99                          EU00\n&EULST   SETC  'NOGEN'                                             EU00\n         AIF   ('&OPT(1)' EQ 'STRING').SL99                        EU00\n&EUSTL   SETC  'NOGEN'                                             EU00\n.SL99    ANOP                                                      EU00\n&EUJES   SETC  'JES2'                                              EU16\n         AIF   ('&OPT(2)' EQ 'JES2').SJ99                          EU16\n&EUJES   SETC  'NONE'                                              EU16\n.SJ99    ANOP                                                      EU16\n* ---> Add option(s)                                               EU00\n         MACRO\n         IHASVC\nSVCENTRY DSECT\nSVCEP    DS    F              SVC ENTRY POINT ADDRERSS\nSVCAMODE EQU   X'80'          SVC AMODE INDICATOR\nSVCATTR1 DS    0XL2           ATTRIBUTES\nSVCTP    DS    XL1            TYPE FIELD\nSVCTP1   EQU   X'00'          TYPE 1 SVC\nSVCTP2   EQU   X'80'          TYPE 2 SVC\nSVCTP34  EQU   X'C0'          TYPE 3 OR 4 SVC\nSVCTP6   EQU   X'20'          TYPE 6 SVC\nSVCAPF   EQU   X'08'          APF AUTHORIZED 1-AUTHORIZED\nSVCESR   EQU   X'04'          SVC IS PART OF THE ESR\nSVCNP    EQU   X'02'          NON-PREEMPTIVE SVC\nSVCASF   EQU   X'01'          SVC CAN BE ASSISTED\nSVCRESV1 DS    XL1            RESERVED BYTE\nSVCLOCKS DS    XL2            LOCK ATTRIBUTES\nSVCLL    EQU   X'80'          LOCAL LOCK NEEDED\nSVCCMS   EQU   X'40'          CMS LOCK NEEDED\nSVCOPT   EQU   X'20'          OPT LOCK NEEDED\nSVCALLOC EQU   X'10'          SALLOC LOCK NEEDED\nSVCDISP  EQU   X'08'          DISPATCHER LOCK NEEDED\n         SPACE 1\nSVCESRAD EQU   SVCEP,4        ADDRESS OF ESR TABLE IF SVCESR IS ON\nSVCESRMX EQU   SVCATTR1,4     MAXIMUM ESR NUMBER SUPPORTED BY THIS ESR\n         SPACE 1\nSVCLEN   EQU   *-SVCENTRY\n         MEND\n         MACRO\n         ICHPDSDT &LIST=YES,&V=1,&R=8,&M=\n.*-------------------------------------------------------------------*\n.*    MACRO ID : ICHPDSDT                                            *\n.*  DSECT NAME : DSDT                                                *\n.*  POINTED BY : RCVTDSDT FIELD OF THE RCVT DATA AREA                *\n.*    FUNCTION : THIS TABLE DESCRIBES PRIMARY AND BACK-UP RACF       *\n.*               DATA-SETS                                           *\n.*  SELECTIONS : LIST=YES - LIST ALL DSECT                           *\n.*               V=1      - RACF VERSION NUMBER                      *\n.*               R=9      - RACF RELEASE NUMBER                      *\n.*               M=       - RACF MODIFICATION NUMBER (IF NEEDED)     *\n.*                          I.E. : V=1,R=7,M=1 (RACF 1.7.1)          *\n.*-------------------------------------------------------------------*\n         AIF   ('&LIST' EQ 'YES').LIST\n         PUSH  PRINT\n         PRINT OFF\n.LIST    AIF   ('&V' EQ '1').TEST\n         MNOTE 8,'--- Unsupported RACF Version specified : &V..&R..&M '\n         AGO   .LEND\n.TEST    AIF   ('&R' LT '6').RERR\n         AIF   ('&R' LE '9').SKP0\n.RERR    MNOTE 8,'--- Unsupported RACF Release specified : &V..&R..&M '\n         AGO   .LEND\n.SKP0    ANOP\nDSDT     DSECT\nDSDTID   DS    CL4 .          EBCDIC ID\nDSDTNUM  DS    F .            NUMBER OF ENTRIES IN TABLE\n         AIF   ('&R' EQ '6').SKP3\n         AIF   ('&R' NE '7').SKP1\n         AIF   ('&M' EQ '').SKP3\n.SKP1    ANOP\nDSDTDSDX DS    A .            POINTER TO EXTENSION\nDSDTVRSN DS    X .            VERSION NUMBER OF DSDT\n         AIF   ('&R' NE '7').SKP2\n         DS    3X .           DOUBLE-WORD ALIGNMENT\n         AGO   .SKP3\n.SKP2    ANOP\nDSDTFLAG DS    X .            DSDT FLAGS OR INDICATORS\nDSDTPFMT EQU   X'80' .        FLAG FOR PRIMARY FORMAT 0 = OLD/1 = NEW\nDSDTBFMT EQU   X'40' .        FLAG FOR BACK-UP FORMAT 0 = OLD/1 = NEW\n         DS    2X .           DOUBLE-WORD ALIGNMENT\n         DS    8X .           RESERVED FOR EXPANSION\n.SKP3    ANOP\nDSDTENTY DS    0XL160 .       ENTRY FOR DATA-SET INFORMATION\nDSDTPRIM DS    0XL80 .        ENTRY FOR PRIMARY DATA-SET\nDSDPDCB  DS    A .            PTR DCB PRIMARY RACF DATA-SET\nDSDPDEB  DS    A .            PTR DEB PRIMARY RACF DATA-SET\nDSDPINDX DS    A .            PTR TO IN-STORAGE BUFFERS OR RESIDENT\n*                             INDEX TABLE (ZERO IF NO RESIDENT BLOCKS\n*                             FOR THE PRIMARY DATA-SET)\nDSDPHRD  DS    A .            PTR RACF IN-STORAGE DS HEADER RECORD OR\n*                             ZERO IF PRIMARY RACF DATA-SET IS ON A\n*                             SHARED DEVICE\nDSDPRUCB DS    A .            PTR UCB PRIMARY RACF DATA-SET\nDSDPXLEN DS    A .            LENGTH OF IN-STORAGE BUFFERS OR RESIDENT\n*                             INDEX TABLE FOR THE PRIMARY RACF DATA-SET\nDSDPBAM  DS    A .            LOCATES IN-STORAGE BAM INFORMATION FOR\n*                             PRIMARY DATA-SET\nDSDPDSNL DS    X .            LENGTH OF PRIMARY RACF DATA-SET NAME\nDSDPSTAT DS    X .            PRIMARY RACF DATA-SET STATUS\nDSDPACTV EQU   X'80' .        THIS DATA-SET IS ACTIVE\nDSDPPRIM EQU   X'40' .        THIS DATA-SET IS A PRIMARY\nDSDPMSTR EQU   X'20' .        THIS DATA-SET IS THE MASTER RACF DATA-SET\n*                             (ITS ICB CONTAINS STATUS OPTIONS)\nDSDPRFSH EQU   X'10' .        REFRESH ICB\nDSDPSHR  EQU   X'08' .        DATA-SET IS (OR WAS) SHARED\nDSDPALTI EQU   X'04' .        ALTERI REQUESTS ARE BACKED-UP\nDSDPDAT  EQU   X'02' .        IN-STORAGE BLOCKS CAN BE DATA BLOCKS\nDSDPNREC DS    H .            # RECORDS PER TRACK PRIMARY DATA-SET\nDSDPRXNO DS    X .            # IN-STORAGE BUFFERS OR RESIDENT INDEX\n*                             BLOCKS\nDSDPDSN  DS    CL44 .         DSN OF RACF PRIMARY DATA-SET\nDSDPDSNO DS    X .            DATA-SET SEQUENCE NUMBER\n         AIF   ('&R' GE '8').SKP4\n         DS    XL2 .          RESERVED\n         AGO   .SKP5\n.SKP4    ANOP\nDSDPCBLN DS    H .            LENGTH OF PRIMARY DSDE\n.SKP5    ANOP\nDSDTBACK DS    0XL80 .        ENTRY FOR BACK-UP DATA-SET\nDSDBDCB  DS    A .            PTR DCB OF BACK-UP RACF DATA-SET\nDSDBDEB  DS    A .            PTR DEB OF BACK-UP RACF DATA-SET\nDSDBINDX DS    A .            PTR TO IN-STORAGE BUFFERS OR RESIDENT\n*                             INDEX TABLE (ZERO IF NO RESIDENT BLOCKS\n*                             FOR THE BACK-UP RACF DATA-SET)\nDSDBHRD  DS    A .            PTR RACF IN-STORAGE DS HEADER RECORD OR\n*                             ZERO IF BACK-UP RACF DATA-SET IS ON A\n*                             SHARED DEVICE\nDSDBRUCB DS    A .            PTR UCB OF BACK-UP DATA-SET\nDSDBXLEN DS    A .            LENGTH OF IN-STORAGE BUFFERS OR RESIDENT\n*                             INDEX TABLE FOR THE BACK-UP RACF DATA-SET\nDSDBBAM  DS    A .            LOCATES IN-STORAGE BAM INFORMATION FOR\n*                             BACK-UP DATA-SET\nDSDBDSNL DS    X .            LENGTH OF BACK-UP DATA-SET NAME\nDSDBSTAT DS    X .            STATUS OF BACK-UP DATA-SET\nDSDBACTV EQU   X'80' .        THIS DATA-SET IS ACTIVE\nDSDBPRIM EQU   X'40' .        THIS DATA-SET IS A PRIMARY\nDSDBMSTR EQU   X'20' .        THIS DATA-SET IS THE MASTER RACF DATA-SET\n*                             (ITS ICB CONTAINS STATUS OPTIONS)\nDSDBRFSH EQU   X'10' .        REFRESH ICB\nDSDBSHR  EQU   X'08' .        DATA-SET IS (OR WAS) SHARED\nDSDBALTI EQU   X'04' .        ALTERI REQUESTS ARE BACKED-UP\nDSDBDAT  EQU   X'02' .        IN-STORAGE BLOCKS CAN BE DATA BLOCKS\nDSDBNREC DS    H .            # RECORDS PER TRACK BACK-UP DATA-SET\nDSDBRXNO DS    X .            # IN-STORAGE BUFFERS OR RESIDENT INDEX\n*                             BLOCKS\nDSDBDSN  DS    CL44 .         DSN OF BACK-UP RACF DATA-SET\nDSDBDSNO DS    X .            DATA-SET SEQUENCE NUMBER\n         AIF   ('&R' GE '8').SKP6\n         DS    XL2 .          RESERVED\n         AGO   .SKP7\n.SKP6    ANOP\nDSDBCBLN DS    H .            LENGTH OF BACK-UP DSDE\n.SKP7    SPACE 1\n*        DSECT TO MAP A SINGLE ENTRY IN TABLE\nDSDE     DSECT\nDSDENT   DS    0XL80          ENTRY FOR DATA-SET\nDSDEDCB  DS    A .            PTR DCB FOR DATA-SET\nDSDEDEB  DS    A .            PTR DEB FOR DATA-SET\nDSDEINDX DS    A .            PTR TO IN-STORAGE BUFFERS OR RESIDENT\n*                             INDEX TABLE (ZERO IF NO RESIDENT BLOCKS\n*                             FOR THE DATA-SET)\nDSDEHRD  DS    A .            PTR RACF IN-STORAGE DS HEADER RECORD OR\n*                             ZERO IF DATA-SET IS ON A SHARED DEVICE\nDSDERUCB DS    A .            PTR UCB FOR DATA-SET\nDSDEXLEN DS    A .            LENGTH OF IN-STORAGE INDEX RELATED\n*                             CONTROL BLOCKS FOR DATA-SET\nDSDEBAM  DS    A .            LOCATES IN-STORAGE BAM INFORMATION FOR\n*                             DATA-SET\nDSDEDSNL DS    X .            LENGTH OF DATA-SET NAME\nDSDESTAT DS    X .            DATA-SET STATUS\nDSDEACTV EQU   X'80' .        THIS DATA-SET IS ACTIVE\nDSDEPRIM EQU   X'40' .        THIS DATA-SET IS A PRIMARY\nDSDEMSTR EQU   X'20' .        THIS DATA-SET IS THE MASTER RACF DATA-SET\n*                             (ITS ICB CONTAINS STATUS OPTIONS)\nDSDERFSH EQU   X'10' .        REFRESH ICB\nDSDESHR  EQU   X'08' .        DATA-SET IS (OR WAS) SHARED\nDSDEALTI EQU   X'04' .        ALTERI REQUESTS ARE BACKED-UP\nDSDEDAT  EQU   X'02' .        IN-STORAGE BLOCKS CAN BE DATA BLOCKS\nDSDECMS  EQU   X'01' .        DATA-SET IS VM CMS FILE\nDSDENREC DS    H .            # RECORDS PER TRACK ON DATA-SET\nDSDERXNO DS    X .            # IN-STORAGE BUFFERS OR RESIDENT INDEX\n*                             BLOCKS\nDSDEDSN  DS    CL44 .         NAME OF DATA-SET\nDSDEDSNO DS    X .            DATA-SET SEQUENCE NUMBER\n         AIF   ('&R' GE '8').SKP8\n         DS    XL2 .          RESERVED\n         AGO   .LEND\n.SKP8    ANOP\nDSDECBLN DS    H .            LENGTH OF DSDE\n.LEND    AIF   ('&LIST' EQ 'YES').MEND\n         POP   PRINT\n.MEND    MEND\n         COPY  STRING                                              EU00\n         PRINT ON\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*          SSSS  H   H  OOOOO  W   W  M   M  V   V   SSSS             *\n*         S      H   H  O   O  W   W  MM MM  V   V  S                 *\n*          SSS   HHHHH  O   O  W W W  M M M  V   V   SSS              *\n*             S  H   H  O   O  WW WW  M   M   V V       S             *\n*         SSSS   H   H  OOOOO  W   W  M   M    V    SSSS              *\n*                                                                     *\n***********************************************************************\n*      The material in this file is placed in the public domain       *\n*      on an \"AS IS\" basis by its author, Gilbert Saint-Flour.        *\n***********************************************************************\n*                                                                     *\n*     This program runs under ISPF and displays information from      *\n*     various control blocks of the MVS system you're running on.     *\n*     It uses ISPF's BRIF services to display the data on your        *\n*     screen which allows you to browse easily through hundred of     *\n*     lines of output.                                                *\n*                                                                     *\n*     SHOWMVS displays two different types of data:                   *\n*       1. Data related to the MVS operating system:                  *\n*          MVS level, DFP level, OSLVL flags, JES2 level              *\n*          IPL DATE, TIME, VOLSER, NUC-ID, CLPA, CVTUSER              *\n*          SMFSID, JWT, GRS' SNAME                                    *\n*          Product levels for: TSO/E, ISPF, DFDSS, HSM, RACF, VTAM    *\n*          SORT level and PPT table list                              *\n*          Name and status of the RACF data-sets                      *\n*          On-line CPU's and STORAGE (REAL and EXTENDED)              *\n*          VIRTUAL STORAGE map (CSA, SQA, LPA, etc)                   *\n*          SRM data (IPS/ICS/OPT, APG, ETC)                           *\n*          OPEN catalogs                                              *\n*          PAGE data sets in use                                      *\n*          Name and status of SYS1.DUMP data-sets                     *\n*          Sub-system vector table with functions processed           *\n*          JES2 data information                                      *\n*          TCAS data (requires SHOWMVS to run authorized)             *\n*          TSO PARMLIB data                                           *\n*          Address space usage, Active jobs, TSO users, Started tasks *\n*          LINK-LIST data-sets, with creation data                    *\n*          LPA-LIST data-sets, with creation date                     *\n*          List of AUTHORIZED libraries                               *\n*          ACTIVE LPA queue                                           *\n*          SVC Table with name of the corresponding module            *\n*          T1, T2, T3 and T6 ESR tables                               *\n*          Device Classes and corresponding unit names                *\n*          On-line devices, with unit-name, VOLSER, owning job,       *\n*                use attribute, storage group                         *\n*          System consoles, with status & Routcde list                *\n         EJECT\n*       2. Data related to the current address space:                 *\n*          RACF profile (from ACEE)                                   *\n*          TSO profile (from PSCB & UPT)                              *\n*          TCB tree and PRB chain                                     *\n*          Allocated Data sets (from TIOT, SWA, TCT)                  *\n*          Enhanced view of the JPAQ and Load-lists                   *\n*                                                                     *\n*=====> SHOWMVS can be invoked as a program, as a TSO command, or     *\n*       as an edit macro and can run authorized or non-authorized.    *\n*       Displays that requires access to fetch-protected storage      *\n*       areas (such as TCAS and PPT) are bypassed unless SHOWMVS      *\n*       runs APF-authorized (TSO : IKJTSOxx member in SYS1.PARMLIB,   *\n*       but in this case, even if you are under ISPF, the Hard-copy   *\n*       mode (see below) is forced because dialog service requests    *\n*       cannot be issued, invocation has been done under TSO TMP).    *\n*                                                                     *\n*     Hard-copy mode.                                                 *\n*       In Hard-copy mode, SHOWMVS writes the output to a QSAM DCB    *\n*       with RECFM=FBA,LRECL=101 instead of displaying it on the      *\n*       terminal. Hard-copy mode is automatically activated in the    *\n*       following circumstances:                                      *\n*         1. SHOWMVS runs outside of an on-line TSO/ISPF              *\n*            environment, for example as a job step, as a TSO         *\n*            command (when no ISPF environment exists), or under      *\n*            ISPF, in a batch TMP job.                                *\n*         2. SHOWMVS runs in an on-line TSO/ISPF environment, and     *\n*            a //SHOWMVS DD is currently allocated to the TSO         *\n*            session.                                                 *\n*                                                                     *\n*       SHOWMVS output is in lower case. If you want to print it      *\n*       in upper case, you must invoke SHOWMVS as a program and       *\n*       specify PARM=CAPS.                                            *\n*                                                                     *\n*       Note that this is the only case where SHOWMVS accepts a PARM. *\n*       Any other parm (when invoked as a program) or any parameters  *\n*       (when invoked as a TSO command) are ignored.                  *\n*                                                                     *\n*       If hard-copy mode is triggered (for any of the reasons        *\n*       described above) and there is no //SHOWMVS DD allocated,      *\n*       SHOWMVS allocates one with SYSOUT=*.                          *\n*                                                                     *\n*    Assembly/link-edit information:                                  *\n*         Environment:          MVS/XA 2.2 thru MVS/ESA 4.2           *\n*         AMODE:                31                                    *\n*         RMODE:                ANY                                   *\n*         Non-IBM macro used:   STRING                                *\n*         Processor:            Assembler H V2                        *\n*         LKED Attributes:      RENT                                  *\n*         Size of load-module:  28K                                   *\n*                                                                     *\n***********************************************************************\n         EJECT\n*@384 TSO PARMLIB data and authorization tables\n*@383 Use NUCLKUP to find the address of IGCERROR\n*@382 A few glitches corrected\n*@381 TCAS data (only if APF-authorized)\n*@381 System consoles, with status and route codes\n*@381 RACF and TSO profiles (from ACEE, PSCB, UPT)\n*@381 IDENTIFY removed, ATTACH now uses main entry point\n*@380 Enhanced device status which is refreshed when you hit ENTER\n*@373 Address space usage, active jobs, TSU, STC\n*@373 Hardcopy gets title, gets converted to uppercase if PARM=CAPS\n*@372 Display device class table and corresponding unit names\n*@372 Display extent information for link-list data sets\n*@372 Change register assignment and TRTPRINT build routine\n*@371 Added a SNAP routine (and #SNAP macro) for debugging purposes\n*@371 Moved Processor speed loop to sub-task\n*@370 DISPLAY EXISTING SYS1.DUMP DATA SETS WITH FULL/EMPTY STATUS\n*@370 DISPLAY RESOURCE MANAGER PARAMETERS (SRM)\n*@364 FIXED RANDOM ABENDS (S0C4 & SA03) AND BRIF FAILURES\n*@363 FIXED JES2 410 OFFSETS (WITH A LITTLE HELP FROM MY FRIEND SAM)\n*@362 ESTIMATE PROCESSOR SPEED IN \"MIPS\", IMPROVE IPL DATE FORMAT\n*@361 PREVENT S13E ABENDS\n*----------------------------------------------------------------------\n         EJECT\n*    Origin : extracted from tape CBT 93 FEB, file 183.\n*    --------\n*\n*   Updates : by MOINIL P.A.\n*   ---------        COMPUTING CENTRE (TP 361)\n*                    J.R.C. - ISPRA ESTABLISHMENT\n*                    21020 ISPRA (VA), ITALY\n*   13JUL93 : EU00 - Included COPY STRING macro needed to Assembly this\n*                    code. Added SYSPARM(FULL or STRING) as Assembly\n*                    list options. Macro STRING documentation list with\n*                    DOC=YES specified at FINAL_CALL.\n*   14JUL93 : EU01 - Interrupt 0C4 in \"TCAS00\" (move from VTAM key 6\n*                    to private area key 8) / fixed : move in key 0.\n*                    Interrupt 0C4 in \"INITIAL\" (when in BATCH and no\n*                    PARM= specified) / fixed : test for PARM= length.\n*             EU02 - Interrupt 0C4 in \"USERS\" (LOCASCB function return\n*                    back R1 was only tested for zero = invalid) /\n*                    fixed : test also negative R1 = invalid. Also 1\n*                    instruction missing in Started Tasks loop, and 2\n*                    instructions adjusted after label \"RDRTN50\".\n*             EU03 - Interrupt 0C4 in \"INITIAL\" (when a Batch job has\n*                    no PARM) / fixed : test zero length of PARM field.\n*             EU04 - Correct NOTYPE(... when large number of no-types\n*                    in SMF data) / fixed : use next lines to continue.\n*             EU05 - Correct WMSTIPM lablel (MSO Service coefficient)\n*                    definition / fixed : EQU WMST+X'9C',4 value.\n*   16JUL93 : EU06 - In APF list, display the volume serial instead of\n*                    \"UNCAT\" when data-set catalog'd on another volume.\n*   19JUL93 : Some minor changes or rearrangements (i.e. : I like\n*                    diagnose errors, not receive Abends).\n*   20JUL93 : EU07 - Get RACF Version, Release and Modification number\n*                    from field \"RCVTVRMN\".\n*   22JUL93 : EU08 - The DUMP data-sets cannot be set FULL or EMPTY by\n*                    just testing the DS1LSTAR field of their OBTAINed\n*                    DSCB format 1 / fixed by scanning status in the\n*                    DUMP data-set queue.\n*   26JUL93 : EU09 - Processor speed in MIPS is a litle too low / fixed\n*                    by adjust number of instructions (+ 0.25).\n*   29JUL93 : EU10 - Restore display of RACF connected application and\n*                    add some other stuff.\n*   30JUL93 : EU11 - Add RACF data display information.\n*   02AUG93 : EU12 - Add PPT data display information.\n*   04AUG93 : EU13 - Allow SHOWMVS to run as TSO command (not under\n*                    ISPF, so, all environment are accepted). In this\n*                    case, SYSOUT=* is changed to SYSOUT=X (our HOLD\n*                    class) with free at CLOSE (dynamically queued to\n*                    the session). Also fixed not filled last line when\n*                    \"SHOWMVS\" DD is pre-allocated and thus used (the\n*                    error is caused by the PUT locate wrongly placed).\n*                    Don't use ATTACH when not under ISPF (not needed).\n         EJECT\n*   06AUG93 : EU14 - Change the way to see if running Batch and check\n*                    if TSO foreground or background. Also allows to\n*                    have CAPS operand when invoked as command.\n*   10AUG93 : EU15 - Added PARM= options or command operands :\n*                    1. DDN(...) to use an alternate DD-name (default\n*                                is SHOWMVS). Hardcopy use only.\n*                       Mandatory : when this keyword is used the FILE\n*                       =========== must be pre-allocated.\n*                    2. LPG(...) to set the number of Lines per Page\n*                                (default is 60).\n*                    3. PGN(...) to set the starting Page Number, it's\n*                                the initial count (default is 1).\n*                    4. HPG(YES/NO) to have or not have the heading\n*                                at top of all pages (default is YES).\n*                                HPG(NO) conflicts with PGN(...).\n*                    Note: each option must be separated from the other\n*                          by at least a blank or comma.\n*                    Ex. - program EXEC statement:\n*                          PARM='CAPS,DDN(MYPRINT),LPG(50),PGN(10)'\n*                          TSO command operands:\n*                          SHOWMVS CAPS DDN(MYPRINT) LPG(50) PGN(10)\n*                    Also the LINK, ATTACH or LOAD/CALL/DELETE macros\n*                    instructions can be used to invoke SHOWMVS from\n*                    another program/command (be careful to AMODE).\n*                    The format must be as follows :\n*                    ...  LINK/ATTACH  EP=SHOWMVS,\n*                                      PARAM=(optaddr),VL=1\n*                    ...  LOAD  EP=SHOWMVS\n*                         LR    R15,R0  <--- (*) see Note below\n*                         CALL  (15),\n*                               (optaddr),VL=1\n*                         DELETE  EP=SHOWMVS\n*                    where \"optaddr\" specifies the address of the\n*                    option list (equivalent to PARM= parameter of an\n*                    EXEC statement and must be present).\n*                    (*) Note: after the LOAD bit0 of R0 = AMODE, so\n*                              may be you must use BASSM / BSM, and\n*                              bit0 of R1 = AC code.\n*                    Typical Parameter List :\n*                    R1 = address of A(optaddr+X'80000000')\n*                                 0F'0',H'0'\n*                    optaddr ---> H'0'\n*                              or H'4',C'CAPS'\n*                              or H'25',C'CAPS DDN(MYPRINT) LPG(50)'\n*   12AUG93 : EU16 - Add JES2 data display information.\n*   16AUG93 : EU17 - Reworked Virtual Storage Map.\n*   17AUG93 : EU18 - Added PARM= option MSG(NO/YES) just to debug\n*                    (default is NO).\n*   28SEP93 : Updated to version V3R8M4 (tape CBT 93 AUG, file 183).\n         EJECT\n*   15NOV93   EU19 - Correct SORT first n bytes dump.\n*                    Correct Sub-system Vector Table when large number\n*                    of functions / fixed : use next lines to continue.\n*                    Correct Consoles ROUTCDE=(... when large number\n*                    of types) / fixed : use next lines to continue.\n*   16NOV93 : EU20 - Adjust Assembly of JES2 data display information\n*                    (check supported/solved HASP version).\n         EJECT\n*---------------------- local macros definition -----------------------\n         MACRO                                               EU17 MACRO\n         MEMORY_MAP &MSG,&START,&END,&SIZE                   EU17 MACRO\n         AIF   (T'&START NE 'O').AA                          EU17 MACRO\n         MNOTE 8,'--- Start Address missing '                EU17 MACRO\n         AGO   .ZZ                                           EU17 MACRO\n.AA      L     R1,&START               START ADDRESS         EU17 MACRO\n         AIF   (T'&END EQ 'O').CC                            EU17 MACRO\n         L     R2,&END                 END ADDRESS           EU17 MACRO\n         AIF   (T'&SIZE NE 'O').BB                           EU17 MACRO\n         LA    R0,1                    ONE BYTE              EU17 MACRO\n         ALR   R0,R2                   END ADDRESS           EU17 MACRO\n         SLR   R0,R1                   SIZE IN BYTES         EU17 MACRO\n         AGO   .EE                                           EU17 MACRO\n.BB      L     R0,&SIZE                SIZE IN BYTES         EU17 MACRO\n         AGO   .EE                                           EU17 MACRO\n.CC      AIF   (T'&SIZE NE 'O').DD                           EU17 MACRO\n         MNOTE 8,'--- End Address and/or Size missing '      EU17 MACRO\n         AGO   .ZZ                                           EU17 MACRO\n.DD      L     R0,&SIZE                SIZE IN BYTES         EU17 MACRO\n         LR    R2,R0                   SIZE IN BYTES         EU17 MACRO\n         AR    R2,R1                   END ADDRESS           EU17 MACRO\n         BCTR  R2,0                    END ADDRESS           EU17 MACRO\n.EE      STM   R1,R2,WKWORDS           START-END ADDRESSES   EU17 MACRO\n         BAL   R14,MEM_SUB             EDIT SIZE (KB AND MB) EU17 MACRO\n         STRING 4X,&MSG,2X,(WKWORDS,4,X),2X,(WKWORDS+4,4,X),2X,   MACROX\n               WKCELL1,'K  ',WKCELL2,'M',INTO=LINE           EU17 MACRO\n         BAL   R14,SPACE0              NEXT LINE             EU17 MACRO\n.ZZ      MEND                                                EU17 MACRO\n*----------------------------------------------------------------------\n         MACRO                                                    MACRO\n&NAME    STATUS &BYTE,&BIT,&MSG,&OFF=*+14,&REG=R4                 MACRO\n&NAME    TM    &BYTE,&BIT              check flag                 MACRO\n         BZ    &OFF                    OFF, JUMP                  MACRO\n&N       SETA  K'&MSG-2                                           MACRO\n         MVC   0(&N,&REG),=C&MSG       MOVE MESSAGE TEXT          MACRO\n&N       SETA  K'&MSG-1                                           MACRO\n         LA    &REG,&N.(,&REG)         BUMP POINTER               MACRO\n         MEND                                                     MACRO\n*----------------------------------------------------------------------\n         EJECT\n&VERMOD  SETC  'V3R8M4'      VERSION/RELEASE/MODIFICATION\n&NLBRIF  SETA  5000          number of lines for BRIF\n&SYSOHC  SETC  'X'           SYSOUT HOLD class                     EU13\n&LPGCHK  SETC  '200'         max. lines per page value control     EU15\n&PGNCHK  SETC  '90000'       max. starting page value control      EU15\n&QRYEP   SETC  '02A'         (ISPQRY-ISPLINK) entry displacement   EU13\n         PRINT &EULST                                              EU00\n*======================================================================\n*        MAIN PROCESSING\n*----------------------------------------------------------------------\nSHOWMVS  START 0\nSHOWMVS  AMODE 31\nSHOWMVS  RMODE ANY\n         SPLEVEL SET                   SET &SYSSPLV SYMBOL\n         AIF   ('&EUJES' EQ 'JES2').JS20A                          EU20\n         GBLC  &SYSSPLV                MVS/SP LEVEL\n         AGO   .JS20B                                              EU20\n.JS20A   PRINT OFF                                                 EU20\n         COPY  $HASPGBL                                            EU20\n         PRINT ON                                                  EU20\n         PRINT &EULST                                              EU20\n         AIF   ('&VERSION' EQ 'SP 2.2.0').JS20B                    EU20\n&EUJES   SETC  'NONE'                  NOT SUPPORTED/SOLVED        EU20\n         MNOTE 0,'--- Sorry, unsupported JES2 Version : &VERSION ' EU20\n.JS20B   SAVE  (14,12),,'SHOWMVS &VERMOD '                         EU20\n         BALR  R11,0\n         USING *,R11\nBASEADDR LTR   R1,R1                   SUB_TASK? (ATTACH by BRIF)  @380\n         L     R15,=A(SUB_TASK)        prime R15, in case it's yes @380\n         BMR   R15                     yes, go there/else continue @380\n         L     R0,=A(DYNAML)           LENGTH OF DYNAMIC STORAGE AREA\n         GETMAIN RU,LV=(0),BNDRY=PAGE\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LM    R13,R1,8(R13)           SET R13, RELOAD R1\n         USING DYNAM,R13\n         ST    R1,PARMADDR             SAVE PARM/CPPL ADDRESS      EU14\n         MVC   DYNAML2,=A(DYNAML)      STORE LENGTH FOR FREEMAIN\n         BAL   R14,INITIAL             INITIALIZE THE ENVIRONMENT\n         LTR   R2,R15                  Valid environment?          EU15\n         BNZ   GOBACK                  NO, QUIT\n         BAL   R14,SPACE1              BLANK LINE AT THE TOP\n         BAL   R14,SPLEVEL             MVS/SP & DFP LEVELS\n         BAL   R14,IPLDATA             IPL DATE\n         BAL   R14,PRODUCTS            TSO, SPF, DFDSS, HSM, RACF, VTAM\n         BAL   R14,SORT                SORT ALIAS\n         BAL   R14,PPTDATA             PPT DATA                    EU12\n         BAL   R14,RACFDATA            RACF DATA                   EU11\n         BAL   R14,SMFDATA             SMF DATA\n         BAL   R14,HARDWARE            HARDWARE DATA\n         BAL   R14,MEMORY              VIRTUAL MEMORY MAP\n         BAL   R14,SRM00               SRM DATA\n         BAL   R14,OPENCAT             OPEN CATALOGS\n         BAL   R14,PAGEDS              PAGE DATA SETS\n         BAL   R14,DUMPDS              DUMP DATA SETS\n         BAL   R14,SUBSYSTM            SUB-SYSTEMS\n         AIF   ('&EUJES' NE 'JES2').JS21                           EU16\n         BAL   R14,JES2DATA            JES2 data                   EU16\n.JS21    BAL   R14,TCAS00              TCAS data                   EU16\n         AIF   ('&SYSSPLV' LT '2').SPL1X     LOW MACLIB LEVEL, JUMP\n         BAL   R14,TSOP00              TSO PARMLIB data\n.SPL1X   BAL   R14,USERS               Active jobs, STC, TSU\n         BAL   R14,LINKLIST            LNKLSTXX\n         BAL   R14,LPALIST             LPALSTXX\n         BAL   R14,APFLIST             APF LIST\n         BAL   R14,LPACTIV             ACTIVE LPA\n         BAL   R14,SVCTABLE            SVC TABLE\n         BAL   R14,DEVICES             DEVICE CLASS & UNIT NAMES       X\n                                       ON-LINE UNITS\n         BAL   R14,CONSOLES            CONSOLES\n*\n*        Data from user's address space\n*\n         BAL   R14,RACF00              RACF Profile\n         BAL   R14,PROF00              TSO profile\n         BAL   R14,TIOT00              TIOT\n         BAL   R14,TCB_TREE            TCB TREE\n         BAL   R14,JPAQ                JPAQ\n         BAL   R14,LOADLIST            LOAD LISTS\n         ESTAE 0                       DELETE RECOVERY ENVIRONMENT\n         BAL   R14,BRIF                START BROWSE MODE\n         LR    R2,R15                  get RC                      EU15\nGOBACK   L     R0,DYNAML2              LENGTH OF DYNAMIC STORAGE AREA\n         LR    R1,R13                  ADDRESS OF DYNAMIC STORAGE AREA\n         L     R13,4(,R13)\n         FREEMAIN RU,LV=(0),A=(1)      FREE DYNAMIC STORAGE\n         LR    R15,R2                  back RC                     EU15\n         RETURN (14,12),RC=(15)\n         SPACE 1\nGO_PROC  AH    R15,0(R15)              Add offset to routine\n         BR    R15                     Enter it\n         EJECT\n*===================== general macros definitions =====================\n         MACRO                                                    MACRO\n&NAME    BEGIN_PROC   ,                                           MACRO\n         GBLC  &ENDPROC                                           MACRO\n&ENDPROC SETC  'PROC&SYSNDX'                                      MACRO\n$LTORG   LOCTR                         Addressable code           MACRO\n&NAME    BAL   R15,GO_PROC                                        MACRO\n         DC    Y(&ENDPROC-*)           Offset to far routine      MACRO\n$FARRTNE LOCTR                         Far routines               MACRO\n&ENDPROC BALR  R12,0                   Local base                 MACRO\n         USING *,R12                                              MACRO\n         LA    R15,PEND&SYSNDX         Load retry address         MACRO\n         STM   R14,R15,END_PROC        RETURN/RETRY addresses     MACRO\n&ENDPROC SETC  'PEND&SYSNDX'           For END_PROC macro         MACRO\n         MEND                                                     MACRO\n*----------------------------------------------------------------------\n         MACRO                                                    MACRO\n&NAME    XCALL &EP,&OPRNDS,&ERRET=,&VL=1                          MACRO\n         GBLB  &IHBSWA                                            MACRO\n&IHBSWA  SETB  (&VL EQ 1)              VL=1                       MACRO\n&NAME    LA    R1,WKWORDS              parm list                  MACRO\n         IHBOPLST ,&OPRNDS,MF=(E,(1))                             MACRO\n         L     R15,&EP                 EP address                 MACRO\n         BALR  R14,R15                 invoke routine             MACRO\n         AIF   (T'&ERRET EQ 'O').MEND                             MACRO\n         LTR   R15,R15                 Any error?                 MACRO\n         BNZ   &ERRET                  yes, jump                  MACRO\n.MEND    MEND                                                     MACRO\n*----------------------------------------------------------------------\n         MACRO                                                    MACRO\n&NAME    END_PROC      ,                                          MACRO\n         GBLC  &ENDPROC                                           MACRO\n         AIF   (T'&NAME EQ 'O').NNM1                              MACRO\n&NAME    EQU   *                                                  MACRO\n.NNM1    ANOP                                                     MACRO\n&ENDPROC L     R14,END_PROC            RETURN address             MACRO\n         BR    R14                                                MACRO\n         MEND                                                     MACRO\n*----------------------------------------------------------------------\n         MACRO                                                    MACRO\n&NAME   #SNAP  &ADDR=(1),&LENGTH=(0)                              MACRO\n&NAME    STM   R14,R3,SNAPREGS         save registers             MACRO\n         IHBINNRA &ADDR,&LENGTH                                   MACRO\n         L     R3,=A(SNAP00)           SNAP routine               MACRO\n         BALR  R14,R3               <- go SNAP storage            MACRO\n         LM    R14,R3,SNAPREGS         restore registers          MACRO\n         MEND                                                     MACRO\n*----------------------------------------------------------------------\n         EJECT\n*======================================================================\n*        INITIALIZE THE ENVIRONMENT\n*----------------------------------------------------------------------\nINITIAL  BEGIN_PROC ,\n         ST    R11,BASEREG             for all routines\n         MVC   MY_DDN,=CL8'SHOWMVS '   DDN(SHOWMVS) - default      EU15\n         MVC   MAXLPG,=F'60'           LPG(60) - default           EU15\n         MVC   CURPGN,=F'1'            PGN(1) - default            EU15\n         L     R8,CVTPTR               CVT ADDRESS\n         USING CVTMAP,R8               PERMANENT ASSIGNMENT\n         L     R9,PSATOLD-PSA          MY TCB\n         USING TCB,R9\n         MVC   JSTCB,TCBJSTCB          THE JOB STEP TCB\n         LA    R10,LINES               START OF TABLES\n         XR    R0,R0\n         LA    R1,L'LINE\n         M     R0,=A(&NLBRIF)\n         AR    R1,R10\n         ST    R1,DYN_CHK\n         USING LINE,R10\n*\n*        Build a translate table for NON-PRINTABLE characters\n*\n         MVI   TRTPRINT,C' '           PRINTABLE CHARACTERS\n         MVC   TRTPRINT+1(L'TRTPRINT-1),TRTPRINT\n         MVC   BLANKS,TRTPRINT         a bunch of blanks\n         MVC   ZENVIR,BLANKS\n         SLR   R15,R15\n         SLR   R0,R0\n         BAL   R1,INIT10\n         DC    X'4A,7,5A,8,6A,6,7A,6'  Special characters\n         DC    X'81,9,91,9,A2,8'       Lowercase\n         DC    X'C1,9,D1,9,E2,8'       Uppercase\n         DC    X'F0,A'                 Digits\n         DC    X'00,0'                 end of table\n*-> LOOP (1)\nINIT10   IC    R15,0(,R1)              FIRST BYTE\n         IC    R0,1(,R1)               ITERATIONS\n*-> LOOP (2)\nINIT11   STC   R15,TRTPRINT(R15)       STORE X'4A' INTO TRTPRINT+X'4A'\n         LA    R15,1(,R15)             BUMP INDEX\n         BCT   R0,INIT11               NEXT CHARACTER\n*-> end LOOP (2)\n         LA    R1,2(,R1)               NEXT ENTRY IN TABLE\n         CLI   0(R1),0                 END OF TABLE?\n         BNE   INIT10                  NEXT STRING\n*-> end LOOP (1)\n*                                                                  EU14\n*        Check if we are entered as TSO command                    EU14\n*                                                                  EU14\n         L     R2,PARMADDR             get entry R1                EU14\n         GETMAIN R,LV=EXTR24L          get 24-bit work area        EU14\n         LR    R5,R1                                               EU14\n         USING EXTR24,R5                                           EU14\n         MVC   EXTR(LEXTR),EXTRP                                   EU14\n         XC    ATSO(L'ATSO+L'APSCB),ATSO                           EU14\n        EXTRACT ATSO,'S',FIELDS=(TSO,PSB),MF=(E,EXTR)              EU14\n* Results : BATCH-exec       TSO-background   TSO-foreground       EU14\n*         +----------------+----------------+----------------+     EU14\n*   APSCB +     0          +     a.PSCB     +     a.PSCB     +     EU14\n*    ATSO +     a.Flag     +     a.Flag     +     a.Flag     +     EU14\n*    Flag +     X'00'      +     X'00'      +     x'80'      +     EU14\n*         +----------------+----------------+----------------+     EU14\n* Initial R1 -> a.CPPL (IKJCPPL) if TSO-command                    EU14\n*            -> a.Communication Area (IKJEBECA) if TSO-subcommmand EU14\n*            -> a.Parameters List in all other cases               EU14\n         L     R1,APSCB                PSCB address                EU14\n         LTR   R1,R1                   TSO running?                EU14\n         BZ    INIT22                  no, this is a Batch PGM     EU14\n         USING CPPL,R2                                             EU14\n         USING PSCB,R1                                             EU14\n         CLC   PSCBUPT,CPPLUPT         CPPL+4 = UPT address?       EU14\n         BNE   *+L'*+10                no                          EU14\n         DROP  R1                                                  EU14\n         CLC   APSCB(L'APSCB),CPPLPSCB CPPL+8 = PSCB address?      EU14\n         BE    INIT20                  yes, TSO command            EU14\n         LR    R1,R2                                               EU14\n         USING IKJEBECA,R1                                         EU14\n         L     R2,CAPTTMP              CPPL address                EU14\n         DROP  R1                                                  EU14\n         CLC   APSCB(L'APSCB),CPPLPSCB CPPL+8 = PSCB address?      EU14\n         BNE   INIT21                  no, not TSO sub-command     EU14\nINIT20   L     R1,CPPLCBUF             get command buffer address  EU14\n         DROP  R2                                                  EU14\n         LA    R4,LINES                build a like PARM field     EU14\n         AH    R4,=H'4096'                                         EU14\n         ST    R4,PARMADDR                                         EU14\n         LA    R0,6(R4)                                            EU14\n         ST    R0,0(R4)                                            EU14\n         OI    0(R4),X'80'                                         EU14\n         XC    4(4,R4),4(R4)                                       EU14\n         LH    R3,0(R1)                buffer lentgh               EU14\n         SH    R3,=H'4'                prefix length               EU14\n         LH    R2,2(R1)                offset to operand(s)        EU14\n         SR    R3,R2                   operand(s) length           EU14\n         BNP   INIT21                  none, jump                  EU14\n         STH   R3,6(R4)                store length                EU14\n         LA    R2,4(R1,R2)             start address of operand(s) EU14\n         BCT   R3,*+L'*+12             compute machine length      EU14\n         MVC   8(*-*,R4),0(R2)         <<executed>>                EU14\n         OC    8(*-*,R4),BLANKS        <<executed>>                EU14\n         EX    R3,*-12                 move operand(s)             EU14\n         EX    R3,*-10                 uppercase operand(s)        EU14\nINIT21   L     R4,ATSO                 TSO-flag address            EU14\n         TM    0(R4),X'80'             TSO background?             EU14\n         BO    INIT23                  no, foreground              EU14\n         OI    FSWITCH,TSORUN          yes, remember it            EU13\n         B     INIT23                                              EU14\nINIT22   OI    FSWITCH,BATCHRUN        remember it                 EU14\nINIT23   FREEMAIN R,LV=EXTR24L,A=(R5)  free 24-bit work area       EU14\n         DROP  R5                                                  EU14\n*\n*        Check if there is PARM= supplied and process it\n*\n         OI    FSWITCH,FLGNOMSG        NOMSG flag (debug)          EU18\n         NI    MY_DDN,X'BF'            indicator reset             EU15\n         ICM   R2,B'1111',PARMADDR     do we have a parm address?  EU14\n         BNP   INIT39                  no, jump                    EU14\n         ICM   R1,B'1111',0(R2)        do we have a parm?          EU14\n         BNM   INIT39                  no, jump                    EU14\n         XR    R2,R2                                               EU01\n         ICM   R2,B'0011',0(R1)        is it PARM= specified?      EU01\n         BZ    INIT39                  no, jump                    EU01\n         LA    R1,2(R1)                start of PARM=field text    EU15\n         AR    R2,R1                   end+1 of PARM=field text    EU15\nINIT30   CLI   0(R1),C','                                          EU15\n         BE    INIT30A                                             EU15\n         CLI   0(R1),C' '                                          EU15\n         BNE   INIT31                                              EU15\nINIT30A  LA    R1,1(R1)                skip separator              EU15\n         CLR   R1,R2                                               EU15\n         BL    INIT30                                              EU15\n         B     INIT39                                              EU15\nINIT30B  LA    R1,1(R1)                                            EU15\nINIT30C  CLR   R1,R2                                               EU15\n         BNL   INIT39                                              EU15\n         CLI   0(R1),C','                                          EU15\n         BE    INIT30A                                             EU15\n         CLI   0(R1),C' '                                          EU15\n         BE    INIT30A                                             EU15\n         LR    R3,R1                                               EU15\nINIT_ERR LA    R15,L'WTOSK1M-1(R3)                                 EU15\n         CLR   R15,R2                                              EU15\n         BL    *+L'*+4                                             EU15\n         LR    R15,R2                                              EU15\n         BCTR  R15,0                                               EU15\n         SR    R15,R3                                              EU15\n         L     R1,=A(WTOSK1)           diagnose error              EU15\n         MVC   WK256(WTOSK1L),0(R1)                                EU15\n         EX    R15,INIT_MV                                         EU15\n         B     INIT98                  QUIT                        EU15\nINIT_MV  MVC   WK256+WTOSK1M(*-*),0(R3) <<executed>>               EU15\nINIT31   LR    R3,R1                                               EU15\n         CLI   0(R1),C'C'              check for CAPS              EU15\n         BNE   INIT32                  no                          EU15\n         LA    R0,1(R1)                                            EU15\n         CLR   R0,R2                                               EU15\n         BNL   INIT31A                                             EU15\n         CLI   1(R1),C','                                          EU15\n         BE    INIT31A                                             EU15\n         CLI   1(R1),C' '                                          EU15\n         BE    INIT31A                                             EU15\n         LA    R0,4(R1)                                            EU15\n         CLR   R0,R2                                               EU15\n         BH    INIT_ERR                                            EU15\n         CLC   0(4,R1),=CL4'CAPS'                                  EU15\n         BNE   INIT_ERR                                            EU15\nINIT31A  TM    TRTPRINT+X'81',X'40'                                EU15\n         BO    INIT_ERR                                            EU15\n         OC    TRTPRINT+X'81'(48),BLANKS convert to uppercase      EU15\n         LR    R1,R0                                               EU15\n         B     INIT30C                                             EU15\nINIT32   CLI   0(R1),C'L'              check for LPG(              EU15\n         BNE   INIT33                  no                          EU15\n         LA    R0,2(R1)                                            EU15\n         CLR   R0,R2                                               EU15\n         BNL   INIT_ERR                                            EU15\n         CLI   1(R1),C'('                                          EU15\n         BE    INIT32A                                             EU15\n         LA    R0,4(R1)                                            EU15\n         CLR   R0,R2                                               EU15\n         BNL   INIT_ERR                                            EU15\n         CLC   0(4,R1),=CL4'LPG('                                  EU15\n         BNE   INIT_ERR                                            EU15\nINIT32A  LR    R1,R0                                               EU15\n         LA    R4,MAXLPG               target field address        EU15\n         LA    R5,=A(20,&LPGCHK)       values control              EU15\n         BAL   R14,INIT_S                                          EU15\n         B     INIT30B                                             EU15\nINIT33   CLI   0(R1),C'P'              check for PGN(              EU15\n         BNE   INIT34                  no                          EU15\n         LA    R0,2(R1)                                            EU15\n         CLR   R0,R2                                               EU15\n         BNL   INIT_ERR                                            EU15\n         CLI   1(R1),C'('                                          EU15\n         BE    INIT33A                                             EU15\n         LA    R0,4(R1)                                            EU15\n         CLR   R0,R2                                               EU15\n         BNL   INIT_ERR                                            EU15\n         CLC   0(4,R1),=CL4'PGN('                                  EU15\n         BNE   INIT_ERR                                            EU15\nINIT33A  TM    CURPGN,X'40'                                        EU15\n         BO    INIT_ERR                                            EU15\n         LR    R1,R0                                               EU15\n         LA    R4,CURPGN               target field address        EU15\n         LA    R5,=A(1,&PGNCHK)        values control              EU15\n         BAL   R14,INIT_S                                          EU15\n         B     INIT30B                                             EU15\nINIT34   CLI   0(R1),C'D'              check for DDN(              EU15\n         BNE   INIT35                  no                          EU15\n         LA    R0,2(R1)                                            EU15\n         CLR   R0,R2                                               EU15\n         BNL   INIT_ERR                                            EU15\n         CLI   1(R1),C'('                                          EU15\n         BE    INIT34A                                             EU15\n         LA    R0,4(R1)                                            EU15\n         CLR   R0,R2                                               EU15\n         BNL   INIT_ERR                                            EU15\n         CLC   0(4,R1),=CL4'DDN('                                  EU15\n         BNE   INIT_ERR                                            EU15\nINIT34A  LR    R1,R0                                               EU15\nINIT34B  CLI   0(R1),C')'              end of dd-name?             EU15\n         BE    INIT34C                 yes                         EU15\n         CLI   0(R1),C' '                                          EU15\n         BL    INIT_ERR                                            EU15\n         LA    R1,1(R1)                                            EU15\n         CLR   R1,R2                                               EU15\n         BL    INIT34B                                             EU15\n         B     INIT_ERR                                            EU15\nINIT34C  LR    R4,R1                                               EU15\n         LR    R5,R0                                               EU15\n         SR    R4,R0                                               EU15\n         BNP   INIT30B                 null, retain default        EU15\n         LA    R0,L'MY_DDN                                         EU15\n         CLR   R4,R0                                               EU15\n         BH    INIT_ERR                too long                    EU15\n         TM    MY_DDN,X'40'            first time?                 EU15\n         BO    INIT_ERR                no                          EU15\n         MVC   MY_DDN,BLANKS                                       EU15\n         BCT   R4,*+L'*+6                                          EU15\n         MVC   MY_DDN(*-*),0(R5)       <<executed>>                EU15\n         EX    R4,*-6                  move new DD-name            EU15\n         B     INIT30B                                             EU15\nINIT35   CLI   0(R1),C'H'              check for HPG(              EU15\n         BNE   INIT36                  no                          EU15\n         LA    R0,2(R1)                                            EU15\n         CLR   R0,R2                                               EU15\n         BNL   INIT_ERR                                            EU15\n         CLI   1(R1),C'('                                          EU15\n         BE    INIT35A                                             EU15\n         LA    R0,4(R1)                                            EU15\n         CLR   R0,R2                                               EU15\n         BNL   INIT_ERR                                            EU15\n         CLC   0(4,R1),=CL4'HPG('                                  EU15\n         BNE   INIT_ERR                                            EU15\nINIT35A  TM    CURPGN,X'40'                                        EU15\n         BO    INIT_ERR                                            EU15\n         LR    R1,R0                                               EU15\n         LA    R0,1(R1)                                            EU15\n         CLR   R0,R2                                               EU15\n         BH    INIT_ERR                                            EU15\n         CLC   0(2,R1),=CL2'N)'                                    EU15\n         BE    INIT35B                                             EU15\n         CLC   0(2,R1),=CL2'Y)'                                    EU15\n         BE    INIT35C                                             EU15\n         LA    R0,2(R1)                                            EU15\n         CLR   R0,R2                                               EU15\n         BH    INIT_ERR                                            EU15\n         CLC   0(3,R1),=CL3'NO)'                                   EU15\n         BE    INIT35B                                             EU15\n         LA    R0,3(R1)                                            EU15\n         CLR   R0,R2                                               EU15\n         BH    INIT_ERR                                            EU15\n         CLC   0(4,R1),=CL4'YES)'                                  EU15\n         BE    INIT35C                                             EU15\n         B     INIT_ERR                                            EU15\nINIT35B  TM    CURPGN,X'80'                                        EU15\n         BO    INIT_ERR                                            EU15\n         MVI   CURPGN,X'80'+X'40'                                  EU15\nINIT35C  LR    R1,R0                                               EU15\n         B     INIT30B                                             EU15\nINIT36   CLI   0(R1),C'M'              check for MSG(              EU18\n         BNE   INIT_ERR                no                          EU18\n         LA    R0,2(R1)                                            EU18\n         CLR   R0,R2                                               EU18\n         BNL   INIT_ERR                                            EU18\n         CLI   1(R1),C'('                                          EU18\n         BE    INIT36A                                             EU18\n         LA    R0,4(R1)                                            EU18\n         CLR   R0,R2                                               EU18\n         BNL   INIT_ERR                                            EU18\n         CLC   0(4,R1),=CL4'MSG('                                  EU18\n         BNE   INIT_ERR                                            EU18\nINIT36A  LR    R1,R0                                               EU18\n         LA    R0,1(R1)                                            EU18\n         CLR   R0,R2                                               EU18\n         BH    INIT_ERR                                            EU18\n         CLC   0(2,R1),=CL2'N)'                                    EU18\n         BE    INIT36B                                             EU18\n         CLC   0(2,R1),=CL2'Y)'                                    EU18\n         BE    INIT36C                                             EU18\n         LA    R0,2(R1)                                            EU18\n         CLR   R0,R2                                               EU18\n         BH    INIT_ERR                                            EU18\n         CLC   0(3,R1),=CL3'NO)'                                   EU18\n         BE    INIT36B                                             EU18\n         LA    R0,3(R1)                                            EU18\n         CLR   R0,R2                                               EU18\n         BH    INIT_ERR                                            EU18\n         CLC   0(4,R1),=CL4'YES)'                                  EU18\n         BE    INIT36C                                             EU18\n         B     INIT_ERR                                            EU18\nINIT36B  OI    FSWITCH,FLGNOMSG        NOMSG flag (debug)          EU18\n         B     INIT36D                                             EU18\nINIT36C  NI    FSWITCH,255-FLGNOMSG    NOMSG flag (debug)          EU18\nINIT36D  LR    R1,R0                                               EU18\n         B     INIT30B                                             EU18\n*        Process NNN...) routine                                   EU15\n*              R14 = link register                                 EU15\n*              R0, R15 = work registers                            EU15\n*              R1 = scan current pointer                           EU15\n*              R2 = scan end+1 pointer                             EU15\n*              R3 = current parameter start scan pointer           EU15\n*              R4 = target field address                           EU15\n*              R5 = address of low-high pair of values control     EU15\nINIT_S   XR    R15,R15                 process NNN...) routine     EU15\nINIT_S1  CLI   0(R1),C')'              end of value?               EU15\n         BE    INIT_S2                 yes                         EU15\n         CLI   0(R1),C'0'                                          EU15\n         BL    INIT_ERR                                            EU15\n         CLI   0(R1),C'9'                                          EU15\n         BH    INIT_ERR                                            EU15\n         XR    R0,R0                                               EU15\n         ICM   R0,B'1000',0(R1)                                    EU15\n         SLL   R0,4                                                EU15\n         SRL   R0,28                                               EU15\n         LTR   R15,R15                                             EU15\n         BNP   *+L'*+4                                             EU15\n         MH    R15,=H'10'                                          EU15\n         AR    R15,R0                                              EU15\n         LA    R1,1(R1)                                            EU15\n         CLR   R1,R2                                               EU15\n         BL    INIT_S1                                             EU15\n         B     INIT_ERR                                            EU15\nINIT_S2  LTR   R15,R15                                             EU15\n         BNPR  R14                     null value, retain default  EU15\n         CL    R15,0(R5)               check against low value     EU15\n         BL    INIT_ERR                too small                   EU15\n         CL    R15,4(R5)               check against high value    EU15\n         BH    INIT_ERR                too big                     EU15\n         TM    0(R4),X'80'             first time?                 EU15\n         BO    INIT_ERR                no                          EU15\n         ST    R15,0(R4)               set new value               EU15\n         OI    0(R4),X'80'             indicate stored             EU15\n         BR    R14                     return                      EU15\nINIT39   OI    MY_DDN,X'40'            indicators reset            EU15\n         NI    MAXLPG,X'7F'                                        EU15\n         TM    CURPGN,X'40'                                        EU15\n         BO    *+L'*+4                                             EU15\n         NI    CURPGN,X'7F'                                        EU15\n*\n*        Check if there is a pre-allocated DD\n*\n         DEVTYPE MY_DDN,WKCELL1        CHECK FOR \"SHOWMVS\" DD\n         LTR   R15,R15                 DD allocated?\n         BNZ   *+L'*+8                 no, jump\n         OI    FSWITCH,HARDCOPY        yes, remember it's hardcopy\n         B     INIT70                                              EU13\n         CLC   MY_DDN,=CL8'SHOWMVS '   was DDN=SHOWMVS (default)?  EU15\n         BE    INIT49                  yes                         EU15\n         L     R1,=A(WTOSK6)           diagnose error              EU15\n         MVC   WK256(WTOSK6L),0(R1)                                EU15\n         MVC   WK256+WTOSK6N(L'WTOSK6N+L'WTOSK6T),BLANKS           EU15\n         MVC   WK256+WTOSK6N(L'MY_DDN),MY_DDN                      EU15\n         LA    R15,WK256+WTOSK6N+L'WTOSK6N-1                       EU15\n         CLI   0(R15),C' '                                         EU15\n         BNE   *+L'*+4                                             EU15\n         BCT   R15,*-8                                             EU15\n         MVC   1(L'WTOSK6T,R15),WTOSK6T(R1)                        EU15\n         B     INIT98                  QUIT                        EU15\nINIT49   TM    FSWITCH,BATCHRUN        is it a Batch PGM?          EU14\n         BO    INIT60                  yes                         EU14\n         TM    FSWITCH,TSORUN          are we in TSO background?   EU14\n         BO    INIT60                  yes                         EU14\n*\n*        TSO foreground: check if we are running under ISPF\n*\n         L     R9,JSTCB                the job step TCB            EU13\n         XR    R3,R3                   indentation index           EU13\nINIT50   L     R4,TCBRBP               get the RB pointer          EU13\n         USING RBSECT,R4                                           EU13\n         CLI   RBSTAB1,RBFTPRB         is this a PRB?              EU13\n         BNE   INIT51                  no                          EU13\n         XR    R5,R5                   yes                         EU13\n         ICM   R5,B'0111',RBCDE1       get the CDE pointer         EU13\n         DROP  R4                                                  EU13\n         USING CDENTRY,R5                                          EU13\n         CLC   CDNAME(3),=C'ISP'       ISPF task?                  EU13\n         BNE   INIT51                  no                          EU13\n         DROP  R5                                                  EU13\n         L     R9,PSATOLD-PSA          yes, restore my TCB         EU13\n         B     INIT52                  go process under ISPF       EU13\nINIT51   BAL   R14,SCANTCB             get next TCB                EU13\n         BNZ   INIT50                  process it if more          EU13\n         L     R9,PSATOLD-PSA          end of chain, restore TCB   EU13\n         B     INIT59                  no more                     EU13\n*\n*        We are running under ISPF, so LOAD needed modules\n*\nINIT52   LOAD  EP=ISPLINK,ERRET=INIT5L load ISPLINK\n         ST    R0,ISPLINK              keep the address\n         LR    R15,R0                  EP address                  EU13\n         LA    R15,X'&QRYEP'(R15)      ISPQRY address              EU13\n         BALR  R14,R15                 invoke routine              EU13\n         LTR   R15,R15                 ISPF servives available?    EU13\n         BNZ   INIT5Q                  no, APF-authorized running  EU13\n         XCALL ISPLINK,                ISPF interface                  X\n               (=CL8'CONTROL',         ISPF function                   X\n               =CL8'ERRORS',           Key-word                        X\n               =CL8'RETURN'),          Key-word                        X\n               ERRET=INIT5C            in case of a problem\n         LA    R0,L'ZENVIR             variable length\n         ST    R0,WKCELL1\n         XCALL ISPLINK,(=CL8'VCOPY',   ISPF function                   X\n               =C'(ZENVIR)',           variable list                   X\n               WKCELL1,                length                          X\n               ZENVIR,                 area address                    X\n               =CL8'MOVE'),            MOVE mode                       X\n               ERRET=INIT5V            in case of a problem\n         XCALL ISPLINK,                ISPF interface                  X\n               (=CL8'ISREDIT',         ISPF function                   X\n               =F'5',                  length                          X\n               =C'MACRO'),             Key-words                       X\n               ERRET=INIT5E            in case we are not in EDIT  EU13\nINIT53   OI    CURPGN,X'40'            force no page numbered      EU15\n         B     INIT70                  proceed with initialization EU15\nINIT5L   LA    R2,=CL8'LOAD'\n         B     INIT5X\nINIT5Q   LA    R2,=CL8'ISPQRY'\n         B     INIT5X\nINIT5C   LA    R2,=CL8'CONTROL'\n         B     INIT5X\nINIT5V   LA    R2,=CL8'VCOPY'\n         B     INIT5X\nINIT5E   LA    R2,=CL8'ISREDIT'\nINIT5X   TM    FSWITCH,FLGNOMSG        NOMSG flag (debug)          EU18\n         BO    INITTT                  skip diagnose               EU18\n         L     R1,=A(WTOSK2)           diagnose error\n         MVC   WK256(WTOSK2L),0(R1)\n         MVC   WK256+WTOSK2N(L'WTOSK2N),0(R2)\n         CVD   R15,WKCELL1\n         MVC   WKCELL1(4),=X'40202120'\n         ED    WKCELL1(4),WKCELL1+L'WKCELL1-2\n         MVC   WK256+WTOSK2R(L'WTOSK2R),WKCELL1\n         WTO   MF=(E,WK256)\nINITTT   CLC   =CL8'ISREDIT',0(R2)     was EDIT macro trying?\n         BE    INIT53                  yes, can proceed, ISPF only\nINIT59   OI    FSWITCH,TSORUN          set as TSO only             EU13\n*\n*        Allocate DDN=SHOWMVS as a SYSOUT data-set\n*\nINIT60   LA    R1,WKWORDS+4            WORK AREA ADDRESS           EU13\n         ST    R1,WKWORDS              POINTER TO REQUEST BLOCK    EU13\n         OI    WKWORDS,S99RBPND                                    EU13\n         USING S99RB,R1                                            EU13\n         XC    0(S99RBEND-S99RB,R1),0(R1) CLEAR STORAGE            EU13\n         MVI   S99RBLN,S99RBEND-S99RB  LENGTH                      EU13\n         MVI   S99VERB,S99VRBAL        VERB=ALLOC                  EU13\n         MVI   S99FLG11,S99NOCNV+S99NOMNT FLAGS                    EU13\n         LA    R2,WKWORDS+(S99RBEND-S99RB)+4  PTR TO T.U. PTRS     EU13\n         ST    R2,S99TXTPP                                         EU13\n         DROP  R1                                                  EU13\n         TM    FSWITCH,TSORUN          are we under TSO?           EU13\n         BO    INIT61                  yes                         EU13\n         LA    R1,2*4(R2)              SET TEXT UNIT POINTERS      EU13\n         ST    R1,0(R2)                                            EU13\n         LA    R3,6+L'MY_DDN(R1)                                   EU13\n         ST    R3,4(R2)                                            EU13\n         OI    4(R2),S99TUPLN                                      EU13\n         USING S99TUNIT,R1                                         EU13\n         MVC   S99TUKEY,=Y(DALDDNAM)   DDN=SHOWMVS                 EU13\n         MVC   S99TUNUM,=Y(1)                                      EU13\n         MVC   S99TULNG,=Y(L'MY_DDN)                               EU13\n         MVC   S99TUPAR(L'MY_DDN),MY_DDN                           EU13\n         DROP  R1                                                  EU13\n         USING S99TUNIT,R3                                         EU13\n         MVC   S99TUKEY,=Y(DALSYSOU)   SYSOUT=*                    EU13\n         MVC   S99TUNUM,=Y(0)                                      EU13\n         DROP  R3                                                  EU13\n         B     INIT62                                              EU13\nINIT61   LA    R1,3*4(R2)              SET TEXT UNIT POINTERS      EU13\n         ST    R1,0(R2)                                            EU13\n         LA    R3,8(R1)                                            EU13\n         ST    R3,4(R2)                                            EU13\n         LA    R4,4(R3)                                            EU13\n         ST    R4,8(R2)                                            EU13\n         OI    8(R2),S99TUPLN                                      EU13\n         USING S99TUNIT,R1                                         EU13\n         MVC   S99TUKEY,=Y(DALSYSOU)   SYSOUT=X                    EU13\n         MVC   S99TUNUM,=Y(1)                                      EU13\n         MVC   S99TULNG,=Y(1)                                      EU13\n         MVI   S99TUPAR,C'&SYSOHC'                                 EU13\n         DROP  R1                                                  EU13\n         USING S99TUNIT,R3                                         EU13\n         MVC   S99TUKEY,=Y(DALCLOSE)   FREE AT CLOSE               EU13\n         MVC   S99TUNUM,=Y(0)                                      EU13\n         DROP  R3                                                  EU13\n         USING S99TUNIT,R4                                         EU13\n         MVC   S99TUKEY,=Y(DALRTDDN)   RETURN DD-NAME              EU13\n         MVC   S99TUNUM,=Y(1)                                      EU13\n         MVC   S99TULNG,=Y(L'RT_DDN)                               EU13\n         MVC   S99TUPAR(L'RT_DDN),BLANKS                           EU13\n         DROP  R4                                                  EU13\nINIT62   LA    R1,WKWORDS              REQUEST BLOCK ADDRESS       EU13\n         DYNALLOC ,                    Allocate SYSOUT=* (Batch)   EU13X\n                                       or SYSOUT=X (TSO)           EU13\n         LTR   R15,R15                 DYNALLOC WENT OK?\n         BNZ   INIT63                  no\n         OI    FSWITCH,HARDCOPY        yes, set it like hardcopy\n         TM    FSWITCH,TSORUN          are we under TSO?           EU13\n         BZ    INIT70                  no                          EU13\n         L     R1,=A(WTOSK0)           yes, advice session alloc'd EU13\n         WTO   MF=(E,(1))                                          EU13\n         B     INIT70\nINIT63   L     R1,=A(WTOSK3)           diagnose error\n         MVC   WK256(WTOSK3L),0(R1)\n         CVD   R15,WKCELL1\n         MVC   WKCELL1(4),=X'40202120'\n         ED    WKCELL1(4),WKCELL1+L'WKCELL1-2\n         MVC   WK256+WTOSK3C(L'WTOSK3C),WKCELL1\n         LA    R1,WKWORDS+4            REQUEST BLOCK ADDRESS\n         USING S99RB,R1\n         UNPK  WK256+WTOSK3R(2*L'S99ERROR+1),S99ERROR(L'S99ERROR+1)\n         L     R15,=A(@STRHEXT-240)    (from STRING macro)\n         TR    WK256+WTOSK3R(2*L'S99ERROR),0(R15) translate to hex\n         MVI   WK256+WTOSK3R+2*L'S99ERROR,C' '\n         UNPK  WK256+WTOSK3I(2*L'S99INFO+1),S99INFO(L'S99INFO+1)\n         TR    WK256+WTOSK3I(2*L'S99INFO),0(R15) translate to hex\n         MVI   WK256+WTOSK3I+2*L'S99INFO,C' '\n         DROP  R1\n         B     INIT98                  QUIT\nINIT70   TIME  DEC\n         STM   R0,R1,WKCELL1           HHMMSSHH,00YYDDDF\n         L     R1,TCBTIO               TIOT\n         USING TIOT1,R1\n         MVC   EDQNAME,TIOCNJOB\n         DROP  R1\n         MVI   EDRNAME,C'T'\n         UNPK  EDRNAME+1(9),WKCELL1(5)\n         MVI   EDRNAME+9,C'.'\n         MVI   EDRNAME+10,C'D'\n         UNPK  EDRNAME+11(5),WKCELL1+5(3)\n         OI    EDRNAME+15,C'0'\n         TM    CURPGN,X'40'                                        EU15\n         BO    *+L'*+10                                            EU15\n         MVC   WKCELL2,=CL8'  / Page'                              EU15\n         B     *+L'*+6                                             EU15\n         MVC   WKCELL2,BLANKS                                      EU15\n         ST    R10,TLNEPT              retain TITLE line pointer   EU15\n         STRING (TITLE,TITLE_L),INTO=LINE\n         STRING (WKCELL1+4,P,YY/MM/DD),INTO=(LINE+60,24),          EU15X\n               2X,(WKCELL1,1,X),':',(WKCELL1+1,1,X),WKCELL2        EU15\nPGNEPT   EQU   60+24,6                 page count edit pointer     EU15\n*        OC    LINE,BLANKS             X'00' -> X'40'              EU15\n         BAL   R14,SPACE0              First line is title\n         L     R2,=A(RECOVERY)         RECOVERY ROUTINE            EU15\n         ESTAE (R2),                   RECOVERY ROUTINE                X\n               CT,                     CREATE                          X\n               PARAM=DYNAM,            PARAM FOR RECOVERY ROUTINE      X\n               MF=(E,ESTAEL)\n         L     R1,CVTLINK              DCB FOR SYS1.LINKLIB\n         LA    R2,=C'IEFEB4UV'         device type scan rtne\n         LOAD  EPLOC=(R2),DCB=(1)      GET ADDRESS OF IEFEB4UV ROUTINE\n         ST    R0,IEFEB4UV             KEEP ADDRESS\n         DELETE EPLOC=(R2)             IEFEB4UV is in LPA\n         SLR   R15,R15                 RC=00\n         B     INIT99                  QUIT                        EU15\nINIT98   WTO   MF=(E,WK256)                                        EU15\n         LA    R15,16                  pass back RC for error      EU15\nINIT99   END_PROC\n         SPACE 1\nEXTRP   EXTRACT *-*,'S',MF=L                                       EU14\n         DROP  R12                     END_PROC\n         EJECT\n*======================================================================\n*        PRINT CVT FIELDS\n*----------------------------------------------------------------------\nSPLEVEL  BEGIN_PROC ,\n*        #SNAP ADDR=0,LENGTH=12                                  <SNAP>\n         STRING 'Operating System:',INTO=LINE\n         BAL   R14,SPACE2              BLANK LINE\n*\n*        MVS/SP1 OR MVS/SP2\n*\n         LR    R6,R8                   A(CVTMAP)\n         SH    R6,=Y(CVTMAP-CVTFIX)    SUBTRACT PREFIX LENGTH\n         USING CVTFIX,R6\n         STRING '  CVTPRODN: ',CVTPRODN,'  CVTPRODI: ',CVTPRODI,       X\n               '  CVTRELNO: ',CVTRELNO,INTO=LINE\n         BAL   R14,SPACE0              NEXT LINE\n         STRING '   CVTDCB: X''',(CVTDCB,1,X),                         X\n               ''' - CVTDCB FLAGS: (12-CVT8AOS2)',INTO=LINE\n         BAL   R14,SPACE0              NEXT LINE\n         STRING '       80-CVTMVSE 40-CVT1SSS 20-CVT2SPS 10-CVT4MS1 04-X\n               CVT4MPS 02-CVT6DAT 01-CVTMVS2',INTO=LINE\n         BAL   R14,SPACE2              BLANK LINE\n         AIF   ('&SYSSPLV' LT '2').SPL2X     LOW MACLIB LEVEL, JUMP\n         L     R7,CVTDFA               DATA FACILITIES AREA\n         USING DFA,R7\n         MVC   WKCELL1(6),=X'40204B204B20' ' X.X.X'\n         ED    WKCELL1(6),DFAREL       X'3200'\n         CLI   CVTDCB,CVTMVSE+CVTMVS2+CVT8AOS2 DO WE HAVE MVS/XA?\n         BE    SPLVLXA                 YES\n         AIF   ('&SYSSPLV' LT '3').SPL2A     NOT MVS/ESA MACLIB, JUMP\n         TM    CVTDCB,CVTOSEXT         DO WE HAVE OSLVL?\n         BO    SPLVLESA                NO, JUMP\n.SPL2A   STRING '  DFP LEVEL:',(WKCELL1,6),INTO=LINE\n         B     SPLVL99\n*\n*        MVS/XA (SP2) + JES2 LEVEL\n*\nSPLVLXA  STRING '  MVS/XA ',(CVTPRODN+2,6),                            X\n               ' - DFP LEVEL:',(WKCELL1,6),INTO=LINE\n         L     R1,CVTJESCT             JES COMM TABLE\n         L     R5,JESSSCT-JESCT(,R1)   FIRST JSCVT\n         USING SSCT,R5\n         B     SPLVL11                 FIRST TIME, JUMP\n*-> LOOP\nSPLVL10  ICM   R5,B'1111',SSCTSCTA     NEXT SSCVT\n         BZ    SPLVL99                 JES2 NOT FOUND, QUIT\nSPLVL11  CLC   =C'JES2',SSCTSNAM       IS THIS JES2?\n         BNE   SPLVL10                 NO, LOOP\n*-> end LOOP\n         BAL   R14,SPACE0              NEXT LINE\n         L     R6,SSCTSUSE             A(HASPSSSM LEVEL)\n         STRING 2X,SSCTSNAM,' Level: ',((R6),20),INTO=LINE\n         LA    R0,25\n         LA    R1,LINE+35\n         CLI   0(R1),C' '\n         BNL   *+L'*+4\n         MVI   0(R1),C' '\n         BCTR  R1,0\n         BCT   R0,*-14\n         DROP  R5\n         AIF   ('&SYSSPLV' LT '3').SPL2X     NOT MVS/ESA MACLIB, JUMP\n         B     SPLVL99\n*\n*        MVS/ESA (SP3 OR SP4) + JES2 LEVEL\n*\nSPLVLESA STRING '  MVS/ESA ',(CVTPRODN+2,6),                           X\n               '      MVS/DFP ',(WKCELL1,6),                           X\n               '       CVTOSLVL: ',                                    X\n               (CVTOSLVL,1,X),1X,(CVTOSLVL+1,1,X),1X,                  X\n               (CVTOSLVL+2,1,X),1X,(CVTOSLVL+3,1,X),1X,                X\n               (CVTOSLVL+4,1,X),1X,(CVTOSLVL+5,1,X),1X,                X\n               (CVTOSLVL+6,1,X),1X,(CVTOSLVL+7,1,X),1X,                X\n               INTO=LINE\n         L     R1,CVTJESCT             JES COMM TABLE\n         L     R5,JESSSCT-JESCT(,R1)   FIRST JSCVT\n         USING SSCT,R5\n         B     SPLVL31                 FIRST TIME, JUMP\n*-> LOOP\nSPLVL30  ICM   R5,B'1111',SSCTSCTA     NEXT SSCVT\n         BZ    SPLVL99                 JES2 NOT FOUND, QUIT\nSPLVL31  CLC   =C'JES2',SSCTSNAM       IS THIS JES2?\n         BNE   SPLVL30                 NO, LOOP\n*-> end LOOP\n         L     R6,SSCTSUS2             A(HCCT)\n         BAL   R1,SPLVL35              BRANCH AROUND TABLE\nJLVTBES  DC    X'008C'             +00 OFFSET TO CCTSSVT  (313)    @363\n         DC    X'010C'             +02 OFFSET TO CCTNDENM (313)    @363\n         DC    X'01F0'             +04 OFFSET TO CCTSNV   (313)    @363\nJLVTBEL  EQU   *-JLVTBES\nOFFSSV   EQU   0,2\nOFFNDE   EQU   2,2\nOFFSNV   EQU   4,2\n         DC    X'008C'             +00 OFFSET TO CCTSSVT  (410)    @363\n         DC    X'0120'             +02 OFFSET TO CCTNDENM (410)    @363\n         DC    X'021C'             +04 OFFSET TO CCTSNV   (410)    @363\n         DC    X'009C'             +00 OFFSET TO CCTSSVT  (420)\n         DC    X'0130'             +02 OFFSET TO CCTNDENM (420)\n         DC    X'0244'             +04 OFFSET TO CCTSNV   (420)\n         DC    X'0000'                 END OF TABLE\n*-> LOOP\nSPLVL35  LH    R2,OFFSSV(,R1)          GET OFFSET TO SSVT ADDRESS\n         LTR   R2,R2                   END OF TABLE?\n         BZ    SPLVL99                 YES, QUIT\n         ALR   R2,R6                   CHANGE OFFSET TO ADDRESS\n         CLC   SSCTSSVT,0(R2)          IS THIS MY JES2?\n         BNE   SPLVL36                 NO, JUMP\n         LH    R2,OFFSNV(,R1)          GET OFFSET TO CCTSNV\n         ALR   R2,R6                   R2=>SUBSYS NAME\n         CLC   SSCTSNAM,0(R2)          IS THIS MY JES2?\n         BE    SPLVL40                 YES, EXIT LOOP\nSPLVL36  LA    R1,JLVTBEL(,R1)         NEXT ENTRY\n         B     SPLVL35                 TRY NEXT ENTRY IN TABLE\n*-> end LOOP\nSPLVL40  LH    R7,OFFNDE(,R1)          GET OFFSET TO CCTNDENM\n         ALR   R7,R6                   R7=>OWN NODE\n         BAL   R14,SPACE2              BLANK LINE\n         CLI   8(R6),C' '              IS THIS JES2 420?          @363\n         BE    SPLVL41                 NO, JUMP                   @363\n         STRING 2X,((R2),4),' Level: ',(4(R2),4),                      X\n               '    HASPSSSM: ',(8(R6),8),' at ',(16(R6),4,X),         X\n               '    NJE Node: ',((R7),8),                              X\n               INTO=LINE\n         B     SPLVL99\nSPLVL41  STRING 4X,((R2),4),' Level: ',(4(R2),4),                 @363 X\n               '    NJE NODE: ',((R7),8),                         @363 X\n               INTO=LINE                                          @363\n         DROP  R5\n.SPL2X   ANOP\nSPLVL99  BAL   R14,SPACE2              BLANK LINE\n         END_PROC\n         DROP  R6,R7\n         DROP  R12                     END_PROC\n         EJECT\n*======================================================================\n*        IPL DATA\n*----------------------------------------------------------------------\nIPLDATA  BEGIN_PROC ,\n         STRING 'Last IPL:',INTO=LINE\n         BAL   R14,SPACE2              BLANK LINE\n         L     R6,CVTSMCA              SMF SMCA\n         USING SMCABASE,R6\n*\n*        DETERMINE DAY OF THE WEEK                                 @363\n*\n         UNPK  WKCELL1(3),SMCAIDTE+1(2)  YY FROM YY.DDD           YY\n         PACK  WKCELL1,WKCELL1(2)        YY FROM YY.DDD           YY\n         CVB   R0,WKCELL1              R0=YEAR\n         LR    R1,R0                   R1=YEAR\n         BCTR  R1,0                    R1=YEAR-1\n         SRL   R1,2                    DIVIDE YEAR-1 BY 4\n         AR    R1,R0                   ADD RESULT TO NUMBER OF YEARS\n         ZAP   WKCELL1,SMCAIDTE+2(2)   DDD FROM YY.DDD\n         SLR   R14,R14                 PREPARE DIVISION\n         CVB   R15,WKCELL1             R15=DAY\n         BCTR  R15,0                   R15=DAY-1\n         AR    R15,R1                  ADD NUMBER OF YEARS\n         D     R14,=F'7'               DIVIDE BY NUM OF DAYS IN WEEK\n         MH    R14,=H'9'               MULT BY LEN OF DAY-OF-THE-WEEK\n         LA    R7,TABLEDAY(R14)        POINT TO DAY-OF-THE-WEEK\n*\n*        CALCULATE NUMBER OF DAYS SINCE LAST IPL\n*\n*        LA    R7,=PL4'1'                                          ****\n*        LA    R8,=PL4'99365'                                      ****\n*        USING CVTDATE,R7                                          ****\n*        USING SMCAIDTE,R8                                         ****\n         ZAP   WKCELL2,CVTDATE         TODAY'S DATE\n         BAL   R14,CHECK0              CHECK NEXT LINE AVAILABLE\n         STRING '(Today)',INTO=NEXTLINE\n         SP    WKCELL2,SMCAIDTE        DIFFERENCE IN DAYS\n         BZ    IPLDATA6                TODAY, JUMP\n         BP    IPLDATA4                SAME CENTURY, JUMP\n         AP    WKCELL2,=P'100000'      COMPENSATE FOR MILLENIUM CHANGE\nIPLDATA4 CLC   SMCAIDTE(2),CVTDATE     SAME YEAR/CENTURY?\n         BE    IPLDATA5                YES, JUMP\n         SP    WKCELL2,=P'635'         DAYS DIFFERENCE (NORMAL YEAR)\n         TM    SMCAIDTE+1,X'01'        LEAP YEAR?\n         BO    IPLDATA5                NO, JUMP\n         TM    SMCAIDTE+1,X'12'        LEAP YEAR? (88 92 96 00)\n         BM    IPLDATA5                NO, JUMP\n         AP    WKCELL2,=P'1'           COMPENSATE FOR LEAP YEAR\nIPLDATA5 STRING '(Yesterday)',INTO=NEXTLINE\n         CP    WKCELL2,=P'1'           WAS IT YESTERDAY?\n         BE    IPLDATA6                YES, JUMP\n         STRING '(',(WKCELL2,P,L0),' days ago)',INTO=NEXTLINE\n*\n*        CONVERT IPL TIME FROM BINARY TO HH:MM                     @364\n*\nIPLDATA6 SLR   R0,R0\n         L     R1,SMCAITME             IPL TIME (BINARY)\n         D     R0,=F'00360000'         GET HOURS\n         LR    R2,R1                   HH\n         LR    R1,R0                   REMAINDER\n         SLR   R0,R0\n         D     R0,=F'6000'             GET MINUTES IN R1\nIPLDATA7 STRING '  Date:  ',((R7),9,T),1X,                             X\n               (SMCAIDTE,P,YY/MM/DD),1X,(NEXTLINE,,T),                 X\n               '     Time:  ',((R2),,R2Z),':',((R1),,R2Z),         @364X\n               '     Julian:  ',(SMCAIDTE+1,1,X),'.',              @364X\n               (SMCAIDTE+2,P,R3Z),INTO=LINE                        @364\n         BAL   R14,SPACE0              NEXT LINE\n         L     R7,CVTSYSAD             IPL UCB\n         USING UCBOB,R7\n         L     R3,CVTEXT2              CVT EXTENSION\n         USING CVTXTNT2,R3\n         L     R15,CVTASMVT            POINT TO ASM VECTOR TABLE\n         LA    R4,=C'NO '              CLPA=NO\n         TM    ASMFLAG2-ASMVT(R15),ASMQUICK   QUICK START?\n         BO    *+L'*+4                 YES, JUMP\n         LA    R4,=C'YES'              NO, CLPA=YES\n         STRING  '  From:  ',UCBVOLI,'/',UCBNAME,                      X\n               '     NUC Id:  ',CVTNUCLS,                              X\n               '     CLPA:  ',((R4),3),                                X\n               '     CVTUSER:  ',(CVTUSER,,X),INTO=LINE\n         BAL   R14,SPACE2              BLANK LINE\n         END_PROC\nTABLEDAY DC    C'Monday   Tuesday  WednesdayThursday '\n         DC    C'Friday   Saturday Sunday   ',0H'0'\n         DROP  R3,R6,R7\n         DROP  R12                     END_PROC\n         EJECT\n*======================================================================\n*        TSO/E, DFDSS, HSM, RACF, VTAM\n*----------------------------------------------------------------------\nPRODUCTS BEGIN_PROC ,\n         STRING 'System Software:',INTO=LINE\n         BAL   R14,SPACE2              BLANK LINE\n         L     R7,CVTTVT               TSO VECTOR TABLE\n         USING TSVT,R7\n         PACK  WKCELL1,TSVTLREL        2-DIGIT RELEASE NUMBER\n         STRING '  TSO/E Level:   ',TSVTLVER,'.',(WKCELL1,P,L0),'.',   X\n               TSVTLMOD,4X,(ZENVIR,8),INTO=LINE\n         BAL   R14,SPACE2              BLANK LINE\n         MVC   WK256(2+2),=Y(1,80)     BLDL HDR\n         MVC   WK256+4(8),=C'ADRRELVL' EPNAME\n         L     R2,CVTLINK              LINKLIST DCB\n         BLDL  (R2),WK256              ISSUE BLDL\n         LTR   R15,R15\n         BNZ   DFDSS8                  NOT FOUND, JUMP\n         LOAD  DE=WK256+4,DCB=(R2)     LOAD ADRRELVL, IF PRESENT\n         LR    R1,R0                   PASS EP ADDR\n         STRING '  DF/DSS Level:  ',((R1),H,L),'.',(2(R1),FL1,L),'.',  X\n               (3(R1),FL1,L),INTO=LINE\n         DELETE DE=WK256+4             I'M DONE WITH IT\nDFDSS8   BAL   R14,SPACE2              BLANK LINE\n         ICM   R7,B'1111',CVTHSM       HSM VECTOR TABLE\n         BZ    RACFVM00\n         USING MQCT,R7\n         CLI   MQCTID,C'Q'             CHECK CB ID\n         BNE   RACFVM00\n         STRING '  DF/HSM Level: ',MQCTVER,'.',MQCTREL,'.',MQCTMOD,    X\n               INTO=LINE\n         BAL   R14,SPACE2              BLANK LINE\nRACFVM00 ICM   R7,B'1111',CVTRAC       RACF VECTOR TABLE\n         BZ    RACFVM99\n         USING RCVT,R7                                             EU07\n         LA    R1,RCVTVRMN                                         EU07\n         LA    R2,RCVTVRMN+1                                       EU07\n         LA    R3,RCVTVRMN+3                                       EU07\n         STRING '  RACF Level:    ',((R1),1),'.',((R2),2),         EU07X\n               '.',((R3),1),INTO=LINE                              EU07\n         BAL   R14,SPACE2              BLANK LINE\nRACFVM99 L     R3,PSAATCVT-PSA         ADDR OF VTAM CVT\n         STRING '  VTAM Level:    ',((R3),4),                          X\n               '    PSAATCVT: ',((R3),,X),INTO=LINE\n         BAL   R14,SPACE2              BLANK LINE\n         L     R1,CVTJESCT             JES COMM TABLE\n         L     R5,JESSSCT-JESCT(,R1)   FIRST JSCVT\n         USING SSCT,R5\n*-> LOOP\nDB2SYS22 CLC   =C'DSN ',SSCTSNAM       IS THIS DB2?\n         BE    DB2SYS70                YES, EXIT LOOP\n         ICM   R5,B'1111',SSCTSCTA     NEXT SSCVT\n         BNZ   DB2SYS22\n*-> end LOOP\n         B     DB2SYS99\nDB2SYS70 ICM   R6,B'1111',SSCTSUSE     DB2'S ERLY\n         BZ    DB2SYS99                INACTIVE SUB-SYSTEM\n         CLC   =C'ERLY',4(R6)          IS THIS REALLY DB2?\n         BNE   DB2SYS99\n         STRING '  DB2 Level:     ',(92(R6),4+5),INTO=LINE   5740XYR01\n         BAL   R14,SPACE2              BLANK LINE\nDB2SYS99 END_PROC\n         DROP  R5,R7\n         DROP  R12                     END_PROC\n         EJECT\n*======================================================================\n*        IDENTIFY WHAT SORT'S REAL NAME IS\n*----------------------------------------------------------------------\nSORT     BEGIN_PROC ,\n         LOAD  EPLOC=SORTNAME          LOAD THE SORT UTILITY\n         L     R4,TCBLLS               POINT TO LAST LLE IN CHAIN\n         USING LLE,R4\n*-> LOOP\nSORT21   L     R6,LLECDPT              CDE PTR\n         USING CDENTRY,R6\n         CLC   SORTNAME,CDNAME         IS IT SORT'S LLE?\n         BE    SORT33                  YES, JUMP\n         ICM   R4,B'1111',LLECHN       CHECK FOR END OF CHAIN\n         BNZ   SORT21                  LOOP THROUGH LOAD LIST\n*-> end LOOP\n         B     SORT99                  SOMETHING'S WRONG HERE\nSORTNAME DC    CL8'SORT'               NAME OF SORT PGM (ANY SORT)\nSORT33   L     R5,CDENTPT              ENTRY POINT ADDRESS\n         SLL   R5,1                    ELIMINE AMODE BIT\n         SRL   R5,1\n         TM    CDATTR,CDMIN            IS THIS A MINOR CDE?\n         BNO   SORT36                  NO, JUMP\n         L     R6,CDXLMJP              YES, POINT TO MAJOR CDE/LPDE\nSORT36   L     R7,LPDEXTAD-LPDE(,R6)   LOAD POINT ADDRESS (IF LPDE)\n         TM    CDATTRB,CDELPDE         IS THIS A LPDE?\n         BO    SORT41                  YES, JUMP\n         L     R7,CDXLMJP              POINT TO XTLST\n         L     R7,XTLMSBAD-XTLST(R7)   LOAD POINT\nSORT41   SR    R5,R7                                               EU19\n         BNZ   SORT41X                                             EU19\n         ICM   R4,B'1111',0(R7)                                    EU19\n         SRDL  R4,12                                               EU19\n         CL    R4,=A(X'00047F0F')                                  EU19\n         BNE   *+L'*+8                                             EU19\n         SRL   R5,20                                               EU19\n         B     SORT41X                                             EU19\n         LA    R5,032                  DEFAULT TO 2 LINES          EU19\nSORT41X  STRING '  SORT''s true name is ',CDNAME,                  EU19X\n               '   (First ',((R5),,L0),' Bytes Follow)',INTO=LINE\n         BAL   R14,SPACE2              BLANK LINE\n*\n*        DUMP THE FIRST N-BYTES OF THE \"SORT\" FOR IDENTIFICATION\n*\n         LA    R3,15(R5)               LOOP COUNTER\n         SRL   R3,4\n         LR    R4,R3\n         SLL   R4,4\n         SLR   R4,R5\n         LR    R5,R3\n*-> LOOP\nSORT42L  STRING 4X,((R7),4,X),1X,(4(R7),4,X),1X,(8(R7),4,X),1X,        X\n               (12(R7),4,X),3X,((R7),16),INTO=LINE\n         BCT   R5,SORT43\n         LTR   R4,R4\n         BNP   SORT43\n         XR    R1,R1\n         LR    R0,R1\n         IC    R0,SORTDS-1(R4)\n         IC    R1,SORTLG-1(R4)\n         LA    R5,LINE\n         ALR   R5,R0\n         EX    R1,*+L'*+10\n         LA    R5,LINE+58\n         SLR   R5,R4\n         BCT   R4,*+L'*+6\n         MVC   0(*-*,R5),BLANKS        <<EXECUTED>>\n         EX    R4,*-6\nSORT43   TR    LINE,TRTPRINT           GET RID OF NON-PRINTABLE CHARS\n         BAL   R14,SPACE0              NEXT LINE\n         LA    R7,016(,R7)             BUMP POINTER\n         BCT   R3,SORT42L\n*-> end LOOP\n         BAL   R14,SPACE1              BLANK LINE\nSORT99   DELETE EPLOC=SORTNAME         NOW GET RID OF IT\n         END_PROC\n         DROP  R4,R6\nSORTDS   DC    AL1(37,35,33,31,28,26,24,22,19,17,15,13,10,8,6)\nSORTLG   DC    AL1(1,3,5,7,10,12,14,16,19,21,23,25,28,30,32)\n         DROP  R12                     END_PROC\n         EJECT ,                                                   EU12\n*==================================================================EU12\n*        DISPLAY PPT DATA                                          EU12\n*        (this display requires APF-authorization)                 EU12\n*------------------------------------------------------------------EU12\nPPTDATA  BEGIN_PROC ,                                              EU12\n         TESTAUTH FCTN=1               check APF status            EU12\n         LTR   R15,R15                 may I use MODESET?          EU12\n         BNZ   PPTDT99                 no, exit                    EU12\n         L     R1,CVTJESCT             JES COMM table              EU12\n         ICM   R7,B'1111',JESPPT-JESCT(R1) PPT pointer             EU12\n         BZ    PPTDT99                 none                        EU12\n         USING PPT,R7                                              EU12\n         MODESET MODE=SUP,KEY=ZERO     supervisor mode and key 0   EU12\n         XR    R6,R6                                               EU12\n         ICM   R6,B'0011',PPTUSED      number of used PPT entries  EU12\n         BZ    PPTDT1                  none                        EU12\n         LR    R4,R7                                               EU12\n         LR    R3,R6                   number of used PPT entries  EU12\n         MH    R3,PPTENTLN             multiply by entry length    EU12\n         AH    R3,PPTHDRLN             add header length           EU12\n         LR    R5,R3                                               EU12\n         LR    R0,R3                   <- get length of work area  EU12\n         BAL   R14,WORKADDR            <- get address of work area EU12\n         LR    R2,R1                                               EU12\n         MVCL  R2,R4                   copy PPT in work area       EU12\n         LR    R7,R1                                               EU12\nPPTDT1   MODESET MODE=PROB,KEY=NZERO   Switch back to key 8        EU12\n         LTR   R6,R6                   PPT empty?                  EU12\n         BNP   PPTDT99                 yes                         EU12\n         STRING 'PPT - Programs Properties Table:',INTO=LINE       EU12\n         BAL   R14,SPACE2              blank line                  EU12\n         XR    R3,R3                                               EU12\n         ICM   R3,B'0011',PPTENTS      total number of PPT entries EU12\n         STRING '  PPT entries number - Total: ',((R3),,L),        EU12X\n               ' - Used: ',((R6),,L),INTO=LINE                     EU12\n         BAL   R14,SPACE2              blank line                  EU12\n         STRING '  PGM-name  NC  SK  NS  PR  ST  ND  BP  Key  2P  1P  NX\n               P  CPU-mask  Origin',INTO=LINE                      EU12\n         BAL   R14,SPACE2              blank line                  EU12\n         LR    R5,R7                                               EU12\n         AH    R5,PPTHDRLN             first PPT entry             EU12\n         XR    R3,R3                                               EU12\n         ICM   R3,B'0011',PPTENTLN     entry length                EU12\n         USING PPT1,R5                                             EU12\nPPTDT10  MVC   LINE,BLANKS             reset line                  EU12\n         MVC   LINE+2(L'PPTNAME),PPTNAME                           EU12\n         TM    PPTBYTE1,PPTNCNCL                                   EU12\n         BZ    *+L'*+4                                             EU12\n         MVI   LINE+L'PPTNAME+5,C'x'                               EU12\n         TM    PPTBYTE1,PPTSKEY                                    EU12\n         BZ    *+L'*+4                                             EU12\n         MVI   LINE+L'PPTNAME+9,C'x'                               EU12\n         TM    PPTBYTE1,PPTNSWP                                    EU12\n         BZ    *+L'*+4                                             EU12\n         MVI   LINE+L'PPTNAME+13,C'x'                              EU12\n         TM    PPTBYTE1,PPTPRIV                                    EU12\n         BZ    *+L'*+4                                             EU12\n         MVI   LINE+L'PPTNAME+17,C'x'                              EU12\n         TM    PPTBYTE1,PPTSYSTK                                   EU12\n         BZ    *+L'*+4                                             EU12\n         MVI   LINE+L'PPTNAME+21,C'x'                              EU12\n         TM    PPTBYTE1,PPTNDSI                                    EU12\n         BZ    *+L'*+4                                             EU12\n         MVI   LINE+L'PPTNAME+25,C'x'                              EU12\n         TM    PPTBYTE1,PPTNOPAS                                   EU12\n         BZ    *+L'*+4                                             EU12\n         MVI   LINE+L'PPTNAME+29,C'x'                              EU12\n         TM    PPTBYTE1,PPTSKEY        System key?                 EU12\n         BZ    PPTDT11                 no, skip                    EU12\n         XR    R2,R2                   yes, get key                EU12\n         IC    R2,PPTKEY                                           EU12\n         SRL   R2,4                                                EU12\n         CVD   R2,WKCELL1                                          EU12\n         MVC   WKCELL1(4),=X'40202120'                             EU12\n         ED    WKCELL1(4),WKCELL1+L'WKCELL1-2                      EU12\n         MVC   LINE+L'PPTNAME+33(2),WKCELL1+2                      EU12\nPPTDT11  TM    PPTPUBYT,PPT2LPU                                    EU12\n         BZ    *+L'*+4                                             EU12\n         MVI   LINE+L'PPTNAME+38,C'x'                              EU12\n         TM    PPTPUBYT,PPT1LPU                                    EU12\n         BZ    *+L'*+4                                             EU12\n         MVI   LINE+L'PPTNAME+42,C'x'                              EU12\n         TM    PPTPUBYT,PPTN2LP                                    EU12\n         BZ    *+L'*+4                                             EU12\n         MVI   LINE+L'PPTNAME+46,C'x'                              EU12\n         UNPK  LINE+L'PPTNAME+51(2*L'PPTCPUA+1),PPTCPUA(L'PPTCPUA+1)\n         L     R15,=A(@STRHEXT-240)    (from STRING macro)         EU12\n         TR    LINE+L'PPTNAME+51(2*L'PPTCPUA),0(R15) translate to hex\n         MVI   LINE+L'PPTNAME+2*L'PPTCPUA+51,C' '                  EU12\n         TM    PPTORIG,PPTDEFLT        origin is IBM?              EU12\n         BZ    *+L'*+6                 no                          EU12\n         MVC   LINE+L'PPTNAME+2*L'PPTCPUA+57(3),=C'IBM'            EU12\n         BAL   R14,SPACE0              next line                   EU12\n         AR    R5,R3                   next entry                  EU12\n         BCT   R6,PPTDT10              loop if more                EU12\n         STRING '    SCHEDxx keyword synonyms list:',INTO=LINE     EU12\n         BAL   R14,SPACE0              next line                   EU12\n         STRING '      NC=NOCANCEL SK=KEY(x)   NS=NOSWAP   PR=PRIV     X\n               ST=SYST     ND=NODSI',INTO=LINE                     EU12\n         BAL   R14,SPACE0              next line                   EU12\n         STRING '      BP=NOPASS   2P=SPREF    1P=LPREF    NP=NOPREF', X\n               INTO=LINE                                           EU12\n         BAL   R14,SPACE0              next line                   EU12\n         STRING '      CPU mask=AFF(y) - FFFF is AFF(NONE)',       EU12X\n               INTO=LINE                                           EU12\nPPTDT90  BAL   R14,SPACE2              blank line                  EU12\nPPTDT99  END_PROC ,                                                EU12\n         DROP  R5,R7                                               EU12\n         DROP  R12                     END_PROC                    EU12\n         EJECT ,                                                   EU11\n*==================================================================EU11\n*        DISPLAY RACF DATA                                         EU11\n*------------------------------------------------------------------EU11\nRACFDATA BEGIN_PROC ,                                              EU11\n         ICM   R7,B'1111',CVTRAC       RACF Vector table           EU11\n         BZ    RACFDT99                                            EU11\n         USING RCVT,R7                                             EU11\n         STRING 'RACF Data:',INTO=LINE                             EU11\n         BAL   R14,SPACE2              blank line                  EU11\n         TM    RCVTSTAT,RCVTRNA        inactive?                   EU11\n         BZ    RACFDT1                 no, active                  EU11\n         STRING '  RACF is inactive',INTO=LINE                     EU11\n         B     RACFDT90                                            EU11\nRACFDT1  TM    RCVTFLGS,RCVTROFF       deactivated?                EU11\n         BZ    RACFDT10                no, active                  EU11\n         STRING '  RACF has been deactivated by a RVARY command',  EU11X\n               INTO=LINE                                           EU11\n         B     RACFDT90                                            EU11\nRACFDT10 L     R6,RCVTDSDT             DSN table                   EU11\n         USING DSDT,R6                                             EU11\n         L     R2,DSDTNUM              number of table entries     EU11\n         SLL   R2,1                    each consists of 2 entries  EU11\n         LA    R5,DSDTENTY             start of table              EU11\n         USING DSDE,R5                                             EU11\nRACFDT11 L     R3,DSDERUCB             UCB pointer                 EU11\n         USING UCBOB,R3                                            EU11\n         STRING 2X,DSDEDSN,1X,UCBVOLI,INTO=LINE                    EU11\n         LA    R4,LINE+2(R15)          status                      EU11\n         STATUS DSDESTAT,DSDEACTV,'Active'                         EU11\n         STATUS DSDESTAT,DSDEMSTR,'Master'                         EU11\n         STATUS DSDESTAT,DSDEPRIM,'Primary'                        EU11\n         TM    DSDESTAT,DSDEPRIM       was primary?                EU11\n         BO    *+L'*+6                 yes                         EU11\n         MVC   0(7,R4),=C'Back-up'     no, show it                 EU11\n         BCT   R2,*+L'*+4              any other entry?            EU11\n         B     RACFDT12                no                          EU11\n         BAL   R14,SPACE0              yes, next line              EU11\n         LA    R5,L'DSDENT(R5)         bump to next                EU11\n         B     RACFDT11                                            EU11\nRACFDT12 CLI   RCVTUADS,0              TSO?                        EU11\n         BE    RACFDT20                no                          EU11\n         BAL   R14,SPACE0              yes, next line              EU11\n         STRING 2X,RCVTUADS,1X,RCVTUVOL,INTO=LINE                  EU11\n         LA    R4,LINE+2(R15)          show it                     EU11\n         MVC   0(3,R4),=C'TSO'                                     EU11\nRACFDT20 BAL   R14,SPACE2              blank line                  EU11\n         XR    R2,R2                                               EU11\n         IC    R2,RCVTPINV                                         EU11\n         STRING '  Password interval in days = ',((R2),,L),        EU11X\n               INTO=LINE                                           EU11\n         BAL   R14,SPACE0              next line                   EU11\n         XR    R2,R2                                               EU11\n         IC    R2,RCVTRVOK                                         EU11\n         STRING '  Number of tries before ID revoked = ',          EU11X\n               ((R2),,L),INTO=LINE                                 EU11\n         ICM   R6,B'1111',RCVTSPT      ICHRIN03 table              EU11\n         BZ    RACFDT30                none                        EU11\n         XR    R5,R5                                               EU11\n         ICM   R5,B'1100',0(R6)                                    EU11\n         SLL   R5,1                    clear out format flag       EU11\n         SRL   R5,17                                               EU11\n         LTR   R5,R5                                               EU11\n         BZ    RACFDT30                none                        EU11\n         BAL   R14,SPACE2              blank line                  EU11\n         STRING '  ICHRIN03 - Started procedures table:',          EU11X\n               INTO=LINE                                           EU11\n         LA    R3,2(R6)                start of entries            EU11\nRACFDT21 BAL   R14,SPACE0              next line                   EU11\n         STRING 4X,(0(R3),8),1X,(8(R3),8),1X,(16(R3),8),           EU11X\n               INTO=LINE                                           EU11\n         TM    0(R6),X'80'             new format?                 EU11\n         BZ    RACFDT22                no, old                     EU11\n         LA    R4,LINE+1(R15)                                      EU11\n         MVI   0(R4),C'/'                                          EU11\n         LA    R4,2(R4)                status                      EU11\n         STATUS 24(R3),BIT0,'Privileged'                           EU11\n         STATUS 24(R3),BIT1,'Trusted'                              EU11\nRACFDT22 BCT   R5,*+L'*+4              loop if more                EU11\n         B     RACFDT30                else end                    EU11\n         LA    R3,24(R3)               next entry                  EU11\n         TM    0(R6),X'80'             new format?                 EU11\n         BZ    RACFDT21                no, old                     EU11\n         LA    R3,8(R3)                yes                         EU11\n         B     RACFDT21                                            EU11\nRACFDT30 ICM   R6,B'1111',RCVTAUTP     ICHAUTAB table              EU11\n         BZ    RACFDT90                none                        EU11\n         CLC   0(8,R6),BLANKS          empty (last entry)?         EU11\n         BE    RACFDT90                yes, none                   EU11\n         BAL   R14,SPACE2              blank line                  EU11\n         STRING '  ICHAUTAB - Authorized caller (program) table:', EU11X\n               INTO=LINE                                           EU11\nRACFDT31 BAL   R14,SPACE0              next line                   EU11\n         STRING 4X,(0(R6),8),INTO=LINE                             EU11\n         TM    8(R6),BIT0+BIT1                                     EU11\n         BZ    RACFDT32                                            EU11\n         LA    R4,LINE+1(R15)                                      EU11\n         MVI   0(R4),C'/'                                          EU11\n         LA    R4,2(R4)                authorization               EU11\n         STATUS 8(R6),BIT0,'RACINIT'                               EU11\n         STATUS 8(R6),BIT1,'RACLIST'                               EU11\nRACFDT32 LA    R6,12(R6)               next entry                  EU11\n         CLC   0(8,R6),BLANKS          last entry?                 EU11\n         BNE   RACFDT31                no                          EU11\nRACFDT90 BAL   R14,SPACE2              blank line                  EU11\nRACFDT99 END_PROC ,                                                EU11\n         DROP  R3,R5,R6,R7                                         EU11\n         DROP  R12                     END_PROC                    EU11\n         EJECT\n*======================================================================\n*        DISPLAY SMF DATA\n*----------------------------------------------------------------------\nSMFDATA  BEGIN_PROC ,\n         STRING 'SMF Data:',INTO=LINE\n         BAL   R14,SPACE2              BLANK LINE\n         L     R6,CVTSMCA              SMF SMCA\n         USING SMCABASE,R6\n         STRING '  SID: ',SMCASID,'  JWT: ',SMCASJWT,INTO=LINE,        X\n               '   System-ID: ',CVTSNAME,' (ownership GRS)'\n         BAL   R14,SPACE2              BLANK LINE\n         L     R7,SMCAFRDS             FIRST RDS\n         USING IEEMBRDS,R7\n*-> LOOP\nSMFDS1   MVC   LINE,BLANKS             CLEAR LINE\n         MVC   DSNAME(L'RDSNAME),RDSNAME    SYS1.MAX%\n         MVC   VOLSER,RDSVOLID         VOLSER\n         TM    RDSFLG1,RDSREADY        READY?\n         BO    *+L'*+6                 YES, BRANCH AROUND MVC\n         MVC   DSNAME+30(6),=C'ACTIVE' THIS IS THE CURRENT DATA SET\n         TM    RDSFLG1,RDSDUMP         DATA-SET FULL MSG ISSUED?\n         BNO   *+L'*+6                 NO, BRANCH AROUND MVC\n         MVC   DSNAME+30(13),=C'DUMP REQUIRED'\n         L     R1,RDSNXTBL             NEXT BLOCK\n         M     R0,=F'100'              CALCULATE PERCENTAGE USED\n         D     R0,RDSCAPTY             CALCULATE PERCENTAGE USED\n         STRING ((R1),,R3B),'%',INTO=CATUNCAT\n         BAL   R14,SPACE0              NEXT LINE\n         L     R7,RDSNEXT              NEXT RDS IN CHAIN\n         C     R7,SMCALRDS             IS THIS THE END OF THE CHAIN?\n         BNE   SMFDS1                  NO, PROCESS NEXT DATA SET\n*-> end LOOP\n         BAL   R14,SPACE1              BLANK LINE\n         DROP  R7\n         L     R3,SMCASSTP             SMF SELECTION CONTROL TABLE\n         LH    R4,SMCANSST             number of SST's\n*-> LOOP (1)\nSMF201   CLI   0(R3),0                 this SST in use?\n         BZ    SMF249                  no, skip it\n         STRING 2X,((R3),4),'  NOTYPE(',INTO=LINE\n         LA    R0,032                  BYTE LOOP                   EU04\n         LA    R1,16(,R3)              SELECTION BIT STRING\n         LA    R2,000                  RECORD NUMBER (0-255)\n*-> LOOP (2)\nSMF210   LA    R5,008                  BIT LOOP\n         LA    R7,X'80'                BIT MASK\n*-> LOOP (3)\nSMF220   EX    R7,SMFTST               CHECK FOR RECORDING OFF\n         BO    SMF227                  RECORDING ON, JUMP\n         CLC   LINE+76(3),BLANKS       CHECK LINE COMPLETE         EU04\n         BE    SMF221                  NO, CONTINUE                EU04\n         BAL   R14,SPACE0              YES, BUMP TO NEXT LINE      EU04\n         STRING 15X,((R2),,L),',',INTO=LINE                        EU04\n         B     SMF227                                              EU04\nSMFTST   TM    0(R1),*-*               <<EXECUTED>>\nSMF221   STRING (LINE,,L),((R2),,L),',',INTO=LINE                  EU04\nSMF227   LA    R2,1(,R2)               BUMP RECNO\n         SRL   R7,1                    OFFSET MASK\n         BCT   R5,SMF220\n*-> end LOOP (3)\n         LA    R1,1(,R1)               BUMP BYTE ADDRESS\n         BCT   R0,SMF210\n*-> end LOOP (2)\n         LA    R15,LINE(R15)           CHANGE OFFSET TO ADDRESS\n         BCTR  R15,0                   OFFSET TO LAST ','\n         CLI   0(R15),C','             is it really a comma?\n         BE    SMF247                  yes, jump\n         LA    R15,1(,R15)             no, do not overlay\nSMF247   MVI   0(R15),C')'             CLOSE PARENTHESIS\n         BAL   R14,SPACE2              BLANK LINE\n*-> end LOOP (1)\nSMF249   AH    R3,SMCALSST             next SST\n         BCT   R4,SMF201\n         END_PROC\n         DROP  R6\n         DROP  R12                     END_PROC\n         EJECT\n*======================================================================\n*        ON-LINE CPU'S AND STORAGE\n*----------------------------------------------------------------------\nHARDWARE BEGIN_PROC\n         STRING 'Hardware Configuration:',INTO=LINE\n         BAL   R14,SPACE2              BLANK LINE\n         SLR   R6,R6                   NUMBER OF CPU'S ON-LINE\n         L     R7,CVTPCCAT             PCCA VECTOR TABLE\n         LA    R3,0016                 16 IS THE MAX NUMBER OF CPU'S\n*-> LOOP\nHARDW1   ICM   R4,B'1111',0(R7)        PCCA\n         BZ    HARDW4                  THIS CPU ACTIVE, JUMP\n         USING PCCA,R4\n         STRING '  CPU ',(PCCACPUA,H,L),'  Serial: ',(PCCACPID+0,8),   X\n               '  Model: ',(PCCACPID+8,4),INTO=LINE\n         LA    R6,1(,R6)               COUNT ON-LINE CPU'S\n         BAL   R14,SPACE0              NEXT LINE\nHARDW4   LA    R7,4(,R7)               BUMP PCCAT PTR\n         BCT   R3,HARDW1\n*-> end LOOP\n         BAL   R14,SPACE1              BLANK LINE\n*\n*        Place holder for processor speed (filled in by sub-task)\n*\n         ALR   R6,R6                   # of CPUs * 2\n         LH    R6,MP_MIPS-2(R6)        Get pct of usable MIPS\n         LA    R5,LINE                 Addr of current line\n         STM   R5,R6,CPUONLNE          save them for the sub-task\n         BAL   R14,SPACE1              BLANK LINE\n         BAL   R14,SPACE1              BLANK LINE\n*\n*        REAL STORAGE\n*\n         LA    R1,0001\n         AL    R1,CVTEORM              HI-ADDR\n         SRL   R1,0010                 GET IT IN \"K\"\n         STRING '  On-line Real Storage: ',(CVTRLSTG,F,L),'K',         X\n               '   Highest Real Storage Address: ',((R1),,L),'K',      X\n               INTO=LINE\n         BAL   R14,SPACE2              BLANK LINE\n         L     R3,CVTRCEP              RSM CTL & ENUM AREA\n         L     R4,RCEESPL-RCE(,R3)     # OF EXTENDED STORAGE FRAMES\n         SLL   R4,2                    CHANGE TO \"K\"\n         STRING '      Extended Storage: ',((R4),,L),'K',INTO=LINE\n         BAL   R14,SPACE2              BLANK LINE\n         END_PROC\n         DROP  R4\n*\n*        The table below gives the multipliers used to compute the\n*        MIPS value for multi-processors, based on the number of\n*        CPUs on-line.  I made these numbers up, based on guesstimates.\n*        If you have better ones, tell Sam Golob.\n*\n*       # CPU -> 1   2   3   4   5   6   7   8   9   10  11  12  13\nMP_MIPS  DC    H'100,182,260,335,410,484,556,625,691,755,816,875,930'\n         DROP  R12                     END_PROC\n         EJECT\n*======================================================================\n*        VIRTUAL MEMORY MAP\n*----------------------------------------------------------------------\nMEMORY   BEGIN_PROC ,\n         STRING 'Virtual Storage Map:',INTO=LINE\n         BAL   R14,SPACE2              BLANK LINE\n         STRING 10X,'Area',3X,                                    EU17 X\n               'Start(hex)-End(hex)    Size(K)    Size(M)',INTO=LINE\n         BAL   R14,SPACE2              BLANK LINE\n         L     R7,CVTSMEXT             STORAGE MAP EXTENSION\n         USING CVTVSTGX,R7\n         L     R6,CVTGDA               GLOBAL DATA AREA           EU17\n         USING GDA,R6                                             EU17\n         XC    WKWORDS,WKWORDS                                    EU17\n         MEMORY_MAP 'PSA+System  ',WKWORDS,GDAVR                  EU17\n         MEMORY_MAP 'Region V=R  ',GDAVR,,GDAVRSZ                 EU17\n         L     R0,GDAVR                                           EU17\n         A     R0,GDAVRSZ                                         EU17\n         L     R1,GDAPVTSZ                                        EU17\n         S     R1,GDAVR                                           EU17\n         S     R1,GDAVRSZ                                         EU17\n         STM   R0,R1,WKWORDS                                      EU17\n         MEMORY_MAP 'Region V=V  ',WKWORDS,,WKWORDS+4             EU17\n         MEMORY_MAP '       CSA  ',GDACSA,,GDACSASZ               EU17\n         MEMORY_MAP '      MLPA  ',CVTMLPAS,CVTMLPAE              EU17\n         MEMORY_MAP '      FLPA  ',CVTFLPAS,CVTFLPAE              EU17\n         MEMORY_MAP '      PLPA  ',CVTPLPAS,CVTPLPAE              EU17\n         MEMORY_MAP '       SQA  ',GDASQA,,GDASQASZ               EU17\n         MVI   WKWORDS,0                                          EU17\n         MVI   WKWORDS+1,X'FF'                                    EU17\n         MVC   WKWORDS+2(2),WKWORDS+1                             EU17\n         MEMORY_MAP '   Nucleus  ',CVTRWNS,WKWORDS                EU17\n         STRING 8X,'16M-line',2X,                                 EU17 X\n               '----------------------------------------',INTO=LINE\n         BAL   R14,SPACE0              next line                  EU17\n         XC    WKWORDS,WKWORDS                                    EU17\n         MVI   WKWORDS,1                                          EU17\n         MEMORY_MAP 'Nucl. Ext.  ',WKWORDS,CVTERWNE               EU17\n         MEMORY_MAP '  SQA EXT.  ',GDAESQA,,GDAESQAS              EU17\n         MEMORY_MAP ' PLPA Ext.  ',CVTEPLPS,CVTEPLPE              EU17\n         MEMORY_MAP ' FLPA Ext.  ',CVTEFLPS,CVTEFLPE              EU17\n         MEMORY_MAP ' MLPA Ext.  ',CVTEMLPS,CVTEMLPE              EU17\n         MEMORY_MAP '  CSA Ext.  ',GDAECSA,,GDAECSAS              EU17\n         MEMORY_MAP ' Reg. Ext.  ',GDAEPVT,,GDAEPVTS              EU17\n         BAL   R14,SPACE1              BLANK LINE                 EU17\n         L     R1,GDACSACV             CSA space converted to SQA\n         SRL   R1,10                   in kilobytes\n         STRING '  CSA space converted to SQA: ',                      X\n               ((R1),,R8B),'K',INTO=LINE\n         LA    R10,NEXTLINE            next line\n         L     R1,GDACSARE             unallocated space in common area\n         SRL   R1,10                   in kilobytes\n         STRING '  Common Area Space Available: ',                     X\n               ((R1),,R7B),'K  (CSA+SQA)',INTO=LINE\n         BAL   R14,SPACE2              BLANK LINE\n         DROP  R6,R7                                              EU17\n         END_PROC ,                                               EU17\n*---------------------------------------------------------------- EU17\n* \"MEM_SUB\" routine => EDIT SIZE IN K-BYTES AND M-BYTES           EU17\n*                      R14 - link register                        EU17\n*---------------------------------------------------------------- EU17\nMEM_SUB  LR    R5,R0                   size to compute Mb         EU17\n         M     R4,=F'10'               multiply by 10             EU17\n         D     R4,=A(X'00100000')      and divide by 1 Mb         EU17\n         CVD   R5,WKCELL3              convert                    EU17\n         MVC   WKCELL2,=XL8'4040202020214B20' mask                EU17\n         ED    WKCELL2,WKCELL3+5       edit                       EU17\n         SRA   R0,10                   size in Kb                 EU17\n         CVD   R0,WKCELL3              convert                    EU17\n         MVC   WKCELL1,=XL8'4020202020202120' mask                EU17\n         ED    WKCELL1,WKCELL3+4       edit                       EU17\n         BR    R14                     return                     EU17\n         DROP  R12                     END_PROC                   EU17\n         EJECT\n*======================================================================\n*        RESOURCE MANAGER PARAMETERS (SRM)                         @370\n*----------------------------------------------------------------------\nSRM00    BEGIN_PROC ,\n         L     R2,CVTOPCTP             RESOURCE MANAGER CONTROL TABLE\n         USING RMCT,R2\n         L     R5,RMCTRMPT             SRM PARAMETER TABLE\n         USING RMPT,R5\n         L     R6,RMCTICST             SRM ICS TABLE\n         USING ICST,R6\n         L     R7,RMCTWMST             SRM WORKLOAD MANAGER TABLE\n         USING WMST,R7\n         STRING 'Resource Manager Data:',INTO=LINE\n         BAL   R14,SPACE2              BLANK LINE\n         BAS   R1,SRM20\n         DC    AL1(RMCTSLTN),C'NEXT  '\n         DC    AL1(RMCTSLTR),C'RANDOM'\n         DC    AL1(RMCTSLTL),C'LAST  '\n         DC    AL1(RMCTSLTF),C'FIRST '\n         DC    AL1(00000000),C'????? ',0H'0'\nSRM20    BAL   R14,SCAN_TM             CALL SCAN RTNE\n         DC    Y(1+6)               0  LENGTH OF A TABLE ENTRY\n         TM    RMCTTAPE,*-*         2  TEST SELTAPE OPTION\n         STRING '  IPS: ',WMSTID,      IEAIPSXX                        X\n               '        ICS: ',ICSTID, IEAICSXX                        X\n               '        OPT: ',RMPTOPTN, IEAICSXX                      X\n               '      SELTAPE: ',(1(R1),6),                            X\n               INTO=LINE\n         BAL   R14,SPACE0              NEXT LINE\n         STRING '  CPU: ',WMSTIPC,     CPU SERVICE COEFFICIENT         X\n               '      IOC: ',WMSTIPI,  I/O SERVICE COEFFICIENT         X\n               '      SRB: ',WMSTIPB,  SRB SERVICE COEFFICIENT         X\n               '        MSO: ',WMSTIPM, MSO SERVICE COEFFICIENT        X\n               INTO=LINE\n         BAL   R14,SPACE2              BLANK LINE\n*\n*        CALCULATE LENGTH OF A DOMAIN TABLE ENTRY FROM FIRST ENTRY,\n*        LAST ENTRY, AND NUMBER OF ENTRIES.   THIS SHOULD WORK IN\n*        MVS/XA THROUGH MVS/ESA 4.3 (DMDT LENGTH WAS INCREASED IN\n*        MVS/ESA 4.2).\n*\n         SLR   R0,R0\n         L     R1,RMCTDMDE             LAST ENTRY IN DOMAIN TABLE\n         SL    R1,RMCTDMDT             LENGTH OF DOMAIN TABLE\n         LH    R14,RMCTDMNC            NUMBER OF DOMAINS IN DOMAIN TBLE\n         BCTR  R14,0                   MINUS ONE FOR \"DR\"\n         DR    R0,R14                  SIZE OF AN ENTRY IN DOMAIN TABLE\n         LH    R6,RMCTDMNC             NUMBER OF DOMAINS IN DOMAIN TBLE\n         L     R7,RMCTDMDT             FIRST ENTRY IN DOMAIN TABLE\n         USING DMDT,R7\n         STRING '     DMN   MIN    MAX   CMPL    RUA    INC    NSW',   X\n               '   OUTU   TWSR   CIDX',                                X\n               INTO=LINE\n         BAL   R14,SPACE2              BLANK LINE\n*-> LOOP\nSRM30    STRING (DMDTNO,FL1,R7B),(DMDTLO,H,R7B),(DMDTHI,H,R7B),        X\n               (DMDTCMPL,H,R7B),(DMDTRUA,H,R7B),(DMDTINCU,H,R7B),      X\n               (DMDTNSW,H,R7B),(DMDTOUTU,H,R7B),(DMDTTWSR,F,R7B),      X\n               (DMDTCIDX,H,R7B),                                       X\n               INTO=LINE\n         BAL   R14,SPACE0              NEXT LINE\n         LA    R7,0(R1,R7)             INCREMENT\n         BCT   R6,SRM30\n*-> end LOOP\n         BAL   R14,SPACE1              BLANK LINE\n         END_PROC\n         DROP  R2,R5,R6,R7\n         DROP  R12                     END_PROC\n         EJECT\n*======================================================================\n*        LIST OPEN CATALOGS\n*----------------------------------------------------------------------\nOPENCAT  BEGIN_PROC ,\n         STRING 'Open Catalogs:',INTO=LINE\n         BAL   R14,SPACE2              BLANK LINE\n         ST    R10,APFTABLE            FOR SORT RTNE\n         L     R5,CVTCBSP              AMCBS\n         L     R6,CBSCAXCN-CBS(,R5)    FIRST CAXWA IN CHAIN\n         USING CAXWA,R6\n*-> LOOP\nOPENCAT2 MVC   LINE,BLANKS\n         L     R7,CAXUCB               UCB ADDR\n         USING UCBOB,R7\n         MVC   UNITNAME+8(4),UCBTYP    DEVICE TYPE\n         BAL   R14,GETUNIT             GET UNITNAME\n         MVC   DSNAME,CAXCNAM          DSNAME\n         MVC   VOLSER,UCBVOLI          VOLSER\n*        MVC   VOLSER,CAXVOLID         VOLSER (CRA)                ****\n         MVC   DEVTYPE,UNITNAME        DEVICE TYPE\n         STRING (CAXFLGS,2,X),INTO=(DEVTYPE+10,4)\n         TM    CAXFLGS,CAXMCT\n         BZ    OPENCAT4\n         STRING 'MASTER',INTO=(DEVTYPE+16,6)\nOPENCAT4 BAL   R14,SPACE0              NEXT LINE\n         ICM   R6,B'1111',CAXCHN       NEXT CAXWA\n         BNZ   OPENCAT2                PROCESS IF NOT END-OF-CHAIN\n*-> end LOOP\n         DROP  R6,R7\n         LA    R2,APFTABLE             TABLE DESC\n         BAL   R14,TRIZO               SORT BY DSN\n         BAL   R14,SPACE1              BLANK LINE\n         END_PROC\n         DROP  R12                     END_PROC\n         EJECT\n*======================================================================\n*        DISPLAY PAGE DATA SETS\n*----------------------------------------------------------------------\nPAGEDS   BEGIN_PROC ,\n         STRING 'Page Data Sets:',INTO=LINE\n         BAL   R14,SPACE2              BLANK LINE\n         L     R4,CVTASMVT             POINT TO ASM VECTOR TABLE\n         L     R2,ASMPART-ASMVT(,R4)   POINT TO PAGE ACT REF TABLE\n         USING PART,R2\n         L     R5,PARTDSNL             POINT TO 1ST PAGE DSN\n         LA    R6,PARTENTS             POINT TO 1ST PARTE\n         USING PARTENT,R6\n         L     R7,PARTSIZE             NUMBER OF PART ENTRIES\n*-> LOOP\nPAGEDS1  TM    PAREFLG1,PARENUSE       THIS PARTE IN USE?\n         BO    PAGEDS8                 NO, SKIP IT\n         MVC   LINE,BLANKS             BLANK LINE\n         MVC   DSNAME,0(R5)            MOVE DSNAME\n         L     R1,PAREUCBP             UCB ADDRESS\n         MVC   VOLSER,UCBVOLI-UCBOB(R1)  VOLSER\n         TM    PAREFLG1,PARENVIO       IS THIS A NON-VIO DATA SET?\n         BZ    PAGEDS4                 NO, JUMP\n         MVC   YYMMDD,=C'NONVIO'       YES, SHOW IT\nPAGEDS4  BAS   R1,PAGEDS4B\n         DC    AL1(PAREPLPA),C'PLPA  '\n         DC    AL1(PARECOMM),C'COMMON'\n         DC    AL1(PAREDPLX),C'DUPLEX'\n         DC    AL1(PARELOCL),C'LOCAL '\n         DC    AL1(00),0H'0'\nPAGEDS4B BAL   R14,SCAN_TM             CALL SCAN RTNE\n         DC    Y(1+6)               0  LENGTH OF A TABLE ENTRY\n         TM    PARETYPE,*-*         2  TEST LABEL TYPE FLAGS\n         MVC   DEVTYPE(6),1(R1)     6  TYPE OF PAGE DATA SET\n         L     R1,PARESZSL             GET TOTAL SIZE\n         S     R1,PARESLTA             SLOTS AVAILABLE\n         M     R0,=F'100'              CALCULATE PERCENTAGE USED\n         D     R0,PARESZSL             CALCULATE PERCENTAGE USED\n         STRING ((R1),,R3B),'%',INTO=CATUNCAT\n         BAL   R14,SPACE0              NEXT LINE\nPAGEDS8  LA    R5,44(,R5)              NEXT DSN\n         LA    R6,PARTELEN(,R6)        NEXT PARTE\n         BCT   R7,PAGEDS1\n*-> end LOOP\n         BAL   R14,SPACE1              BLANK LINE\n         END_PROC\n         DROP  R2,R6\n         DROP  R12                     END_PROC\n         EJECT\n*======================================================================\n*        NAME AND STATUS OF SYS1.DUMP DATA SETS\n*----------------------------------------------------------------------\nDUMPDS   BEGIN_PROC ,\n         STRING 'DUMP Data Sets:',INTO=LINE\n         BAL   R14,SPACE2              BLANK LINE\n         L     R0,=F'2048'          <- GET LENGTH OF WORK AREA\n         BAL   R14,WORKADDR         <- GET ADDRESS OF WORK AREA\n         LR    R2,R1\n         USING CTGPL,R2\n         LA    R0,DUMPNODE             ENTRY NAME\n         ST    R0,CTGENT               POINTER TO ENTRY NAME OR CI#\n         OI    CTGOPTN1,CTGGENLD       GENERIC LOCATE\n         OI    CTGFUNC,CTGAM0          OS/VS2 CATALOG MGMT REQUEST\n         OI    CTGFUNC,CTGSUPLT        SUPER LOCATE\n         MVI   CTGTYPE,CTGTALIN        NON-VSAM ENTRIES ONLY\n         LA    R1,CTGPL+CTGPLLEN       WORK AREA FOR SVC 26\n         ST    R1,CTGWKA               STORE ADDRESS INTO CTGPL\n         MVC   0(4,R1),=Y(1000,0)      BUILD WORK AREA HEADER\n         LOCATE CTGPL                  ISSUE GENERIC LOCATE REQUEST\n         LTR   R1,R15                  ANY ERROR?\n         BNZ   DUMPDS81                YES, ISSUE ERROR MESSAGE\n         LA    R1,CTGPL+CTGPLLEN+4     POINT TO FIRST ENTRY\n*-> LOOP\nDUMP20   CLI   0(R1),C'A'              CHECK ENTRY TYPE\n         BNE   DUMP29                  JUMP IF NOT A NON-VSAM DATA SET\n         MVC   LINE,BLANKS             CLEAR LINE\n         MVC   DSNAME,1(R1)            SYS1.DUMP%%\n         CLI   DSNAME+11,C' '          IS THIS REALLY SYS1.DUMP%%?\n         BNE   DUMP29                  NO, JUMP\n         MVI   VOLSER,C'?'             $LOCATE REQUIRED\n         MVI   YYMMDD,C'?'             $OBTAIN REQUIRED\n         MVC   CATUNCAT(5),=CL5'NOT-Q'                             EU08\n         L     R5,CVTRTMCT             REC. TERM. CONTROL TABLE    EU08\n         ICM   R6,B'1111',36(R5)       GET AND TEST \"RTCTSDDS\"     EU08\n         BZ    DUMP25                  NONE, JUMP                  EU08\nDUMP21   CLC   DSNAME+9(3),12(R6)      THIS DUMP NN \"SDDSQDSN\"?    EU08\n         BE    DUMP22                  YES                         EU08\n         ICM   R6,B'1111',4(R6)        NEXT ELEMENT \"SDDSQFWD\"?    EU08\n         BNZ   DUMP21                  YES                         EU08\n         B     DUMP25                  ELSE NO MORE                EU08\nDUMP22   MVC   CATUNCAT(5),=CL5'EMPTY'                             EU08\n         TM    16(R6),X'80'            IS IT EMPTY \"SDDSQDDS\"?     EU08\n         BZ    DUMP25                  YES                         EU08\n         MVC   CATUNCAT(5),=CL5'FULL ' NO                          EU08\nDUMP25   BAL   R14,SPACE0              BUMP LINE PTR\n*        MVI   LINE,0                                              ****\nDUMP29   LA    R14,1+44                LENGTH OF AN ENTRY\n         LH    R15,CTGPL+CTGPLLEN+2    GET ACTUAL LENGTH OF TABLE\n         LA    R15,CTGPL+CTGPLLEN+3(R15)  R15->LAST BYTE OF LAST ENTRY\n         BXLE  R1,R14,DUMP20           NEXT ENTRY FROM CATALOG\n*-> end LOOP\n         BAL   R14,SPACE1              BLANK LINE\n         B     DUMPDS99                EXIT\nDUMPNODE DC    AL1(9),C'SYS1.DUMP'     NODE FOR GENERIC LOCATE\nDUMPDS81 STRING '  Generic Locate Error, Return-code is ',((R1),,L),   X\n               ', Reason is IGG0CL',CTGFDBK,'-',(CTGRSNCD,FL1,L0),     X\n               INTO=LINE\n         BAL   R14,SPACE2              BLANK LINE\nDUMPDS99 END_PROC\n         DROP  R2\n         DROP  R12                     END_PROC\n         EJECT\n*======================================================================\n*        SUB-SYSTEMS AND FUNCTIONS PROCESSED\n*----------------------------------------------------------------------\nSUBSYSTM BEGIN_PROC ,\n         STRING 'Sub-system Vector Table:',INTO=LINE\n         BAL   R14,SPACE2              BLANK LINE\n         L     R1,CVTJESCT             JES COMM TABLE\n         L     R5,JESSSCT-JESCT(,R1)   FIRST JSCVT\n         USING SSCT,R5\n*-> LOOP (1)\nSUBSYS21 MVC   LINE,BLANKS             CLEAR LINE                  EU19\n         STRING 2X,SSCTSNAM,1X,(SSCTSSVT,,X),INTO=LINE             EU19\n         LA    R1,LINE+L'SSCTSNAM+1\n         LA    R0,L'SSCTSNAM\nSUBSYS22 CLI   0(R1),C' '\n         BNL   *+L'*+4\n         MVI   0(R1),C' '\n         BCTR  R1,0\n         BCT   R0,SUBSYS22\n         ICM   R6,B'1111',SSCTSSVT     SUB-SYSTEM VECTOR TABLE\n         BZ    SUBSYS70                INACTIVE SUB-SYSTEM\n         USING SSVT,R6\n         SLR   R1,R1                   FIRST FUNCTION CODE\n         LA    R2,256                  MAX NUMBER OF FUNCTIONS\n*-> LOOP (2)\nSUBSYS30 LA    R14,SSVTFCOD(R1)        FUNCTION BYTE\n         LA    R1,1(,R1)               NEXT FUNCTION CODE\n         CLI   0(R14),0\n         BE    SUBSYS35\n         CLC   LINE+76(3),BLANKS       CHECK LINE COMPLETE         EU19\n         BE    SUBSYS31                NO, CONTINUE                EU19\n         BAL   R14,SPACE0              YES, BUMP TO NEXT LINE      EU19\n         MVC   LINE,BLANKS                                         EU19\n         STRING 16X,((R1),,L0),INTO=LINE                           EU19\n         B     SUBSYS35                                            EU19\nSUBSYS31 STRING (LINE,,T),1X,((R1),,L0),INTO=LINE                  EU19\nSUBSYS35 BCT   R2,SUBSYS30\n*-> end LOOP (2)\nSUBSYS70 BAL   R14,SPACE0              NEXT LINE                   EU19\n         ICM   R5,B'1111',SSCTSCTA     NEXT SSCVT\n         BNZ   SUBSYS21\n*-> end LOOP (1)\n         BAL   R14,SPACE1              BLANK LINE\n         END_PROC\n         DROP  R5,R6\n         DROP  R12                     END_PROC\n         AIF   ('&EUJES' NE 'JES2').JS22                           EU16\n         EJECT ,                                                   EU16\n*==================================================================EU16\n*        DISPLAY JES2 DATA INFORMATION                             EU16\n*------------------------------------------------------------------EU16\nJES2DATA BEGIN_PROC ,                                              EU16\n         L     R1,CVTJESCT             JES COMM table              EU16\n         USING JESCT,R1                                            EU16\n         ICM   R2,B'1111',JESSSCT      SSCT pointer                EU16\n         BZ    JESDT99                 none                        EU16\n         USING SSCT,R2                                             EU16\nJESDT10  CLC   SSCTID,=CL4'SSCT'       right ID?                   EU16\n         BNE   JESDT99                 no, jump                    EU16\n         CLC   SSCTSNAM,=CL4'JES2'     JES2 SSCT?                  EU16\n         BE    JESDT11                 yes                         EU16\n         ICM   R2,B'1111',SSCTSCTA     no, get next SSCT           EU16\n         BNZ   JESDT10                 and loop if more            EU16\n         B     JESDT99                 else JES2 not found, QUIT   EU16\nJESDT11  STRING 'JES2 data:',INTO=LINE                             EU16\n         CLC   JESPJESN,=CL4'JES2'     JES2 is primary?            EU16\n         BNE   JESDT12                 no, jump                    EU16\n         STRING 'Primary Sub-system',INTO=(LINE+11,18)             EU16\n         DROP  R1                                                  EU16\nJESDT12  ICM   R7,B'1111',SSCTSSVT     SSVT pointer                EU16\n         BZ    JESDT90                 none, exit                  EU16\n         DROP  R2                                                  EU16\n         XR    R5,R5                                               EU16\n         LA    R2,SVTCKPT1(R7)         HFAME 1                     EU16\n         BAL   R6,JESDT20              display it                  EU16\n         LA    R2,SVTCKPT2(R7)         HFAME 2                     EU16\n         LA    R6,JESDT30              display it                  EU16\n         USING HFE,R2                                              EU16\nJESDT20  TM    HFEFLAG1,HFE1INUS       data-set in use?            EU16\n         BZR   R6                      no, skip it                 EU16\n         LTR   R5,R5                   first time?                 EU16\n         BNZ   JESDT21                 no, jump                    EU16\n         BAL   R14,SPACE2              blank line                  EU16\n         LR    R5,R14                  close this way              EU16\n         STRING '  Checkpoint data-set(s):',INTO=LINE              EU16\nJESDT21  BAL   R14,SPACE0              next line                   EU16\n         STRING 4X,'Name: ',(HFEDSN,,T),' on ',HFEVOL,INTO=LINE    EU16\n         BR    R6                      go back                     EU16\n         DROP  R2                                                  EU16\nJESDT30  ICM   R5,B'1111',SVTRDT(R7)   RMT destination table       EU16\n         BZ    JESDT40                 none, jump                  EU16\n         ICM   R6,B'1111',SVTRDTE(R7)  last RDT element address    EU16\n         BZ    JESDT40                 none, jump                  EU16\n         CLR   R5,R6                                               EU16\n         BH    JESDT40                 none, jump                  EU16\n         BAL   R14,SPACE2              blank line                  EU16\n         STRING '  RMT destination table:',INTO=LINE               EU16\n         LA    R3,2                                                EU16\n         USING RDT,R5                                              EU16\nJESDT31  BAL   R14,SPACE0              next line                   EU16\n         MVC   WKCELL2,BLANKS                                      EU16\n         XR    R2,R2                                               EU16\n         TM    RDTFLAG,RDTFLAGN        N number?                   EU16\n         BZ    *+L'*+8                 no                          EU16\n         ICM   R2,B'0011',RDTNODE      yes                         EU16\n         B     JESDT32                                             EU16\n         TM    RDTFLAG,RDTFLAGR+RDTFLAGU R or U number?            EU16\n         BZ    *+L'*+8                 no                          EU16\n         ICM   R2,B'0011',RDTRMTNO     yes                         EU16\n         B     JESDT32                                             EU16\n         CLC   RDTNAME,=CL8'LOCAL   '                              EU16\n         BNE   *+L'*+10                                            EU16\n         MVC   WKCELL1,=CL8'Default '                              EU16\n         B     JESDT35                                             EU16\n         MVC   WKCELL1,=CL8'| none ?'                              EU16\n         B     JESDT35                                             EU16\nJESDT32  CVD   R2,WKCELL3                                          EU16\n         MVC   WKCELL1,=XL8'4020202020202120'                      EU16\n         ED    WKCELL1,WKCELL3+L'WKCELL3-4                         EU16\nJESDT33  CLI   WKCELL1+1,C' '                                      EU16\n         BNE   JESDT34                                             EU16\n         MVC   WKCELL1+1(6),WKCELL1+2                              EU16\n         MVI   WKCELL1+7,C' '                                      EU16\n         B     JESDT33                                             EU16\nJESDT34  MVI   WKCELL1,C'R'                                        EU16\n         TM    RDTFLAG,RDTFLAGR        R number?                   EU16\n         BO    JESDT35                 yes                         EU16\n         MVI   WKCELL1,C'U'                                        EU16\n         TM    RDTFLAG,RDTFLAGU        U number?                   EU16\n         BO    JESDT35                 yes                         EU16\n         MVI   WKCELL1,C'N'                                        EU16\n         CLM   R2,B'0011',SVTTONOD(R7) own node ID?                EU16\n         BNE   JESDT35                                             EU16\n         MVC   WKCELL2,=C'own Node'                                EU16\nJESDT35  BCT   R3,JESDT36                                          EU16\n         STRING RDTNAME,' (',WKCELL1,') ',WKCELL2,                 EU16X\n               INTO=(LINE+40,30)                                   EU16\n         B     JESDT37                                             EU16\nJESDT36  STRING 4X,RDTNAME,' (',WKCELL1,') ',WKCELL2,INTO=LINE     EU16\nJESDT37  LA    R5,RDTSIZ(R5)           next element                EU16\n         CLR   R5,R6                   last done?                  EU16\n         BH    JESDT40                 yes                         EU16\n         LTR   R3,R3                                               EU16\n         BP    JESDT31+L'JESDT31                                   EU16\n         LA    R3,2                                                EU16\n         B     JESDT31                                             EU16\n         DROP  R5                                                  EU16\nJESDT40  ICM   R6,B'1111',SVTPIT(R7)   PIT's table pointer         EU16\n         BZ    JESDT90                 none, jump                  EU16\n         BAL   R14,SPACE2              blank line                  EU16\n         STRING '  PIT table (JES2 initiators):',INTO=LINE         EU16\n         BAL   R14,SPACE0              next line                   EU16\n         USING PIT,R6                                              EU16\nJESDT41  STRING '    PIT ',PITPATID,'  Class(es): ',PITCLASS,      EU16X\n               INTO=LINE                                           EU16\n         ICM   R1,B'1111',PITSJB       SJB for executing job       EU16\n         CLC   SJBJOBID(L'SJBJOBID,R1),=XL8'0' job-name?           EU16\n         BE    JESDT42                 none, jump                  EU16\n         BAL   R14,SPACE0              next line                   EU16\n         STRING 12X,'Executing: ',(SJBJOBID(R1),L'SJBJOBID,L),     EU16X\n               ' (',(SJBJOBNM(R1),L'SJBJOBNM,L),')',INTO=LINE      EU16\nJESDT42  BAL   R14,SPACE0              next line                   EU16\n         STRING 12X,'PIT status:',INTO=LINE                        EU16\n         LA    R4,LINE+1(R15)                                      EU16\n         STATUS PITSTAT,PITHOLDA,'HOLDed-A'                        EU16\n         STATUS PITSTAT,PITHOLD1,'HOLDed'                          EU16\n         STATUS PITSTAT,PITBUSY,'BUSY'                             EU16\n         STATUS PITSTAT,PITHALTA,'HALTed-A'                        EU16\n         STATUS PITSTAT,PITHALT1,'HALTed'                          EU16\n         STATUS PITSTAT,PITINIT,'INIT'                             EU16\n         STATUS PITSTAT,PITIDLE,'IDLE'                             EU16\n         STATUS PITSTAT,PITDUPL,'DUPL''d'                          EU16\n         TM    PITFLAGS,PITXBJCL+PITXBM+PITSMVER+PITSIVER+PITSIERR EU16\n         BZ    JESDT43                 none, jump                  EU16\n         BAL   R14,SPACE0              next line                   EU16\n         STRING 13X,'PIT flags:',INTO=LINE                         EU16\n         LA    R4,LINE+1(R15)                                      EU16\n         STATUS PITFLAGS,PITXBJCL,'Wait-XBM'                       EU16\n         STATUS PITFLAGS,PITXBM,'Batch-Mon'                        EU16\n         STATUS PITFLAGS,PITSMVER,'Wait-Mem'                       EU16\n         STATUS PITFLAGS,PITSIVER,'Wait-$SI'                       EU16\n         STATUS PITFLAGS,PITSIERR,'Start-rejected'                 EU16\nJESDT43  ICM   R6,B'1111',PITNEXT      next PIT?                   EU16\n         BZ    JESDT90                 no more                     EU16\n         BAL   R14,SPACE0              next line                   EU16\n         B     JESDT41                 go process this PIT         EU16\n         DROP  R6                                                  EU16\nJESDT90  BAL   R14,SPACE2              blank line                  EU16\nJESDT99  END_PROC ,                                                EU16\n         DROP  R12                     END_PROC                    EU16\n.JS22    EJECT                                                     EU16\n*======================================================================\n*        Terminal Control Address Space (TCAS)\n*        (this display requires APF-authorization)\n*----------------------------------------------------------------------\nTCAS00   BEGIN_PROC\n         TESTAUTH FCTN=1               CHECK APF STATUS\n         LTR   R15,R15                 may I use MODESET?\n         BNZ   TCAS99                  no, exit\n         STRING 'TCAS parameters:',INTO=LINE\n         BAL   R14,SPACE2              BLANK LINE\n         L     R0,=F'2048'          <- get length of work area\n         BAL   R14,WORKADDR         <- get address of work area\n         LR    R6,R1                   save its address\n         USING TCAST,R6\n         MODESET MODE=SUP,KEY=ZERO     supervisor mode and key 0   EU01\n*        MODESET MODE=SUP              Switch to supervisor        EU01\n*        MODESET EXTKEY=VTAM           Switch to KEY 6             EU01\n         L     R2,CVTTCASP             addr of TCAS area\n         MVC   TCAST(TCASTEND-TCAST),0(R2)\n         MODESET MODE=PROB,KEY=NZERO   Switch back to key 8\n         STRING '  CVTTCASP: ',((R2),,X),                              X\n               '  USERMAX: ',(TCASUMAX,H,L8B),                         X\n               'USERACT: ',(TCASUSEC,H,L8B),                           X\n               'RCONLIM: ',(TCASRCON,H,L8B),INTO=LINE\n         BAL   R14,SPACE2              BLANK LINE\nTCAS99   END_PROC\n         DROP  R6\n         DROP  R12                     END_PROC\n         AIF   ('&SYSSPLV' LT '2').SPL3X     LOW MACLIB LEVEL, JUMP\n*======================================================================\n*        TSO PARMLIB data and authorization tables\n*----------------------------------------------------------------------\nTSOP00   BEGIN_PROC\n         L     R2,CVTTVT\n         USING TSVT,R2\n         L     R3,TSVTTPVT             TSO/PARMLIB vector table\n         USING TPVT,R3\n         L     R4,TPVTCTLT             Control table\n         USING CTLT,R4\n         STRING 'TSO-PARMLIB data:',INTO=LINE\n         BAL   R14,SPACE2              BLANK LINE\n         AIF   ('&SYSSPLV' LT '3').SPL3A     NOT MVS/ESA MACLIB, JUMP\n         STRING '  Member(',TPVTMBR,')',INTO=LINE\n         AGO   .SPL3B\n.SPL3A   STRING '  Member(IKJTSOxx)',INTO=LINE\n.SPL3B   BAL   R14,SPACE2              BLANK LINE\n         LA    R5,CTLTE2               A(IKJEFTE2)\n         BAL   R7,TSOP10\n         DC    CL8'AUTHCMD '           IKJEFTE2\n         DC    CL8'AUTHPGM '           IKJEFTE8\n         DC    CL8'NOTBKGND'           IKJEFTNS\n         DC    CL8'AUTHTSF '           IKJEFTAP\n         DC    XL2'FFFF'\n*-> LOOP (1)\nTSOP10   STRING 2X,((R7),8),' NAMES ( +',INTO=LINE\n         BAL   R14,SPACE0              next line\n         MVC   LINE,BLANKS             blank line\n         LA    R6,LINE                 first entry\n         LH    R0,8(,R5)               # of entries\n         L     R1,0(,R5)               start of table\n         LA    R1,16(,R1)              skip table header\n*-> LOOP (2)\nTSOP11   CLI   2(R1),C' '              blank entry?\n         BE    TSOP14                  yes, jump\n         LA    R14,9                   increment in print line\n         LA    R15,LINE+70             end of line\n         BXLE  R6,R14,TSOP12           this line full?\n         MVI   0(R6),C'+'              continuation\n         BAL   R14,SPACE0              next line\n         MVC   LINE,BLANKS             blank line\n         LA    R6,LINE+9               continuation\nTSOP12   CLI   11(R5),8                entry length is 8?\n         BE    TSOP13                  yes, jump\n         MVC   0(8,R6),2(R1)           no, move name\n         B     TSOP14\nTSOP13   MVC   0(8,R6),0(R1)           move name\nTSOP14   AH    R1,10(,R5)              length of an entry\n         BCT   R0,TSOP11\n*-> end LOOP (2)\n         MVI   9(R6),C')'              close parenthsis\n         BAL   R14,SPACE2              BLANK LINE\n         LA    R5,CTLTE8-CTLTE2(,R5)   next table\n         LA    R7,8(,R7)               next name\n         CLI   0(R7),X'FF'             last table processed?\n         BL    TSOP10                  not yet, process next one\n*-> end LOOP (1)\nTSOP99   END_PROC\n         DROP  R2,R3,R4\n.SPL3X   EJECT\n*======================================================================\n*        Address Space Usage\n*        Active jobs, started tasks, TSO users\n*----------------------------------------------------------------------\nUSERS    BEGIN_PROC\n         L     R6,CVTASVT\n         USING ASVT,R6\n         STRING 'Address Space Usage:',INTO=LINE\n         BAL   R14,SPACE2              BLANK LINE\n         STRING 26X,'Total',9X,'In use',6X,'Available',INTO=LINE\n         BAL   R14,SPACE2              BLANK LINE\n         L     R1,ASVTMAXI             MAXUSER\n         SL    R1,ASVTAAV              AVAILABLE\n         STRING '  Address spaces',(ASVTMAXI,F,R15B),                  X\n               ((R1),,R15B),(ASVTAAV,F,R15B),INTO=LINE\n         BAL   R14,SPACE0              NEXT LINE\n         L     R1,ASVTSTRT             MAXUSER\n         SL    R1,ASVTAST              AVAILABLE\n         STRING '    Started/SASI',(ASVTSTRT,F,R15B),                  X\n               ((R1),,R15B),(ASVTAST,F,R15B),INTO=LINE\n         BAL   R14,SPACE0              NEXT LINE\n         L     R1,ASVTNONR             MAXUSER\n         SL    R1,ASVTANR              AVAILABLE\n         STRING '    Non-reusable',(ASVTNONR,F,R15B),                  X\n               ((R1),,R15B),(ASVTANR,F,R15B),INTO=LINE\n         BAL   R14,SPACE2              BLANK LINE\n         DROP  R6\n         STRING 'Active Jobs:',INTO=LINE\n         BAL   R14,SPACE2              blank line\n         SLR   R2,R2                   first time switch\n         LA    R4,1                    first ASID\n         L     R5,CVTASVT              point to ASVT\n         L     R5,ASVTMAXU-ASVT(,R5)   max ASID\n*-> LOOP\nUSERS11  LOCASCB ASID=(R4)             GET ADDR OF OWNER'S ASCB\n         LTR   R15,R1                  VALID ASID?\n         BNP   USERS18                 NO, JUMP                    EU02\n         ICM   R1,B'1111',ASCBJBNI-ASCB(R15) JOBNAME?\n         BZ    USERS18                 no - CONTINUE\n         BAL   R14,EOL                 check for end-of-line\n         MVC   0(8,R2),0(R1)           move job name\n         LA    R2,10(,R2)            BUMP TO 10 BYTES PAST WHERE WE ARE\nUSERS18  LA    R4,1(,R4)               bump ASID\n         BCT   R5,USERS11              CHECK AGAINST # OF UNIT NAMES\n*-> end LOOP\n         LTR   R2,R2                   any JOB found?\n         BNZ   USERS19                 yes, jump\n         STRING '  (none)',INTO=LINE   no, tell it\nUSERS19  BAL   R14,SPACE2              BLANK LINE\n         STRING 'TSO Users:',INTO=LINE\n         BAL   R14,SPACE2              blank line\n         SLR   R2,R2                   first time switch\n         LA    R4,1                    first ASID\n         L     R5,CVTASVT              point to ASVT\n         L     R5,ASVTMAXU-ASVT(,R5)   max ASID\n*-> LOOP\nUSERS21  LOCASCB ASID=(R4)             GET ADDR OF OWNER'S ASCB\n         LTR   R15,R1                  VALID ASID?\n         BNP   USERS28                 NO, JUMP                    EU02\n         ICM   R1,B'1111',ASCBJBNI-ASCB(R15) JOBNAME?\n         BNZ   USERS28                 yes - CONTINUE\n         ICM   R1,B'1111',ASCBJBNS-ASCB(R15) START/MOUNT/LOGON\n         BZ    USERS28                 no - CONTINUE\n         L     R14,ASCBOUCB-ASCB(,R15) point to OUCB\n         TM    OUCBYFL-OUCB(R14),OUCBSTT+OUCBMNT  START OR MOUNT?\n         BNZ   USERS28                 YES, IGNORE\n         BAL   R14,EOL                 check for end-of-line\n         MVC   0(8,R2),0(R1)           move job name\n         LA    R2,10(,R2)            BUMP TO 10 BYTES PAST WHERE WE ARE\nUSERS28  LA    R4,1(,R4)               bump ASID\n         BCT   R5,USERS21              CHECK AGAINST # OF UNIT NAMES\n*-> end LOOP\n         LTR   R2,R2                   any TSU found?\n         BNZ   USERS29                 yes, jump\n         STRING '  (none)',INTO=LINE   no, tell it\nUSERS29  BAL   R14,SPACE2              BLANK LINE\n         STRING 'Started Tasks:',INTO=LINE\n         BAL   R14,SPACE2              blank line\n         SLR   R2,R2                   first time switch\n         LA    R4,1                    first ASID\n         L     R5,CVTASVT              point to ASVT\n         L     R5,ASVTMAXU-ASVT(,R5)   max ASID\n*-> LOOP\nUSERS31  LOCASCB ASID=(R4)             GET ADDR OF OWNER'S ASCB\n         LTR   R15,R1                  VALID ASID?\n         BNP   USERS38                 NO, JUMP                    EU02\n         ICM   R1,B'1111',ASCBJBNI-ASCB(R15) JOBNAME\n         BNZ   USERS38                 yes - CONTINUE\n         ICM   R1,B'1111',ASCBJBNS-ASCB(R15) START/MOUNT/LOGON\n         BZ    USERS38                 no - CONTINUE               EU02\n         L     R14,ASCBOUCB-ASCB(,R15) point to OUCB\n         TM    OUCBYFL-OUCB(R14),OUCBSTT+OUCBMNT  START OR MOUNT?\n         BZ    USERS38                 NO, IGNORE\n         BAL   R14,EOL                 check for end-of-line\n         MVC   0(8,R2),0(R1)           move job name\n         LA    R2,10(,R2)            BUMP TO 10 BYTES PAST WHERE WE ARE\nUSERS38  LA    R4,1(,R4)               bump ASID\n         BCT   R5,USERS31              CHECK AGAINST # OF UNIT NAMES\n*-> end LOOP\n         BAL   R14,SPACE2              BLANK LINE\nUSERS99  END_PROC\n*----------------------------------------------------------------------\n*        \"EOL\" routine => CHECK FOR END-OF-LINE\n*                         R14 - link register\n*----------------------------------------------------------------------\nEOL      LTR   R2,R2                   first time?\n         BZ    EOL1                    yes, jump\n         LA    R0,LINE+76              last position\n         CR    R2,R0                   end of line reached yet?\n         BLR   R14                     no, exit\n         LA    R10,NEXTLINE            yes, next line\n         CL    R10,DYN_CHK\n         BNL   SPERR\nEOL1     MVC   LINE,BLANKS             CLEAR OUT MSG AREA\n         LA    R2,LINE+2               GET BEGINNING ADDR OF THE LINE\n         BR    R14                     exit\n         DROP  R12                     END_PROC\n         EJECT\n*======================================================================\n*        LNKLSTXX LIBRARIES\n*----------------------------------------------------------------------\nLINKLIST BEGIN_PROC ,\n         L     R4,CVTLINK              SYS1.LINKLIB DCB\n         ICM   R4,B'0111',DCBDEBA-IHADCB(R4) DEB ADDRESS\n         USING DEBBASIC,R4\n         LA    R1,=C'LNKLST'\n         TM    DEBFLGS1,DEBAPFIN       AUTH=YES?\n         BO    *+L'*+4                 YES, JUMP\n         LA    R1,=C'APFTAB'\n         L     R7,CVTLLTA              LINK LIST TABLE\n         USING LLT,R7\n         STRING 'Link-list: ',(LLTNO,F,R7B),' Entries     LNKAUTH=',   X\n               ((R1),6),(DEBNMEXT,FL1,R6B),' extents open',INTO=LINE\n         ST    R10,LINKXTNT            save line address for sub-task\n         BAL   R14,SPACE2              BLANK LINE\n         L     R3,LLTNO                # OF ENTRIES\n         LA    R4,LLTENTRY             LINK LIST TABLE ENTRY\n         USING LLTENTRY,R4\n         ST    R10,LNKTABLE            SAVE ADDR OF 1ST LINE\n*-> LOOP\nLNKLST41 MVC   LINE,BLANKS\n         MVC   DSNAME,LLTDSNAM         MOVE DSNAME\n         MVI   VOLSER,C'?'             $LOCATE REQUIRED\n         MVI   YYMMDD,C'?'             $OBTAIN REQUIRED\n         MVI   LINE_APF,C'?'           LNK/LPA/APF STATUS\n         BAL   R14,SPACE0              NEXT LINE\n         LA    R4,LLTNEXT              NEXT ENTRY\n         BCT   R3,LNKLST41\n*-> end LOOP\n         LA    R0,L'LINE               LONGUEUR D'UN POSTE\n         LR    R1,R10                  A(NEXTLINE)\n         SLR   R1,R0                   DERNIER POSTE DE LA TABLE\n         STM   R0,R1,LNKTABLE+4        LONGUEUR, DERNIER POSTE\n         BAL   R14,SPACE1              BLANK LINE\n         END_PROC\n         DROP  R4,R7\n         DROP  R12                     END_PROC\n         EJECT\n*======================================================================\n*        LPALSTXX LIBRARIES\n*----------------------------------------------------------------------\nLPALIST  BEGIN_PROC ,\n         TM    CVTDCB,CVTMVSE          XA/ESA?\n         BZ    LPALST99                NO, JUMP\n         L     R1,CVTSMEXT             STORAGE MAP EXTENSION\n         L     R7,CVTEPLPS-CVTVSTGX(,R1)  LPA TABLE\n         USING LLT,R7\n         STRING 'LPA list: ',((R7),,X),                                X\n               (LLTNO,F,R9B),' Entries.',INTO=LINE\n         BAL   R14,SPACE2              BLANK LINE\n         L     R3,LLTNO                # OF ENTRIES\n         LA    R4,LLTENTRY             FIRST LPA LIST TABLE ENTRY\n         USING LLTENTRY,R4\n         ST    R10,LPATABLE            SAVE ADDR OF 1ST LINE\n*-> LOOP\nLPALST42 MVC   LINE,BLANKS\n         MVC   DSNAME,LLTDSNAM         MOVE DSNAME TO UNPROTECTED STRGE\n         MVI   VOLSER,C'?'             $LOCATE REQUIRED\n         MVI   YYMMDD,C'?'             $OBTAIN REQUIRED\n         MVI   LINE_APF,C'?'           LNK/LPA/APF STATUS\n         BAL   R14,SPACE0              NEXT LINE\n         LA    R4,LLTNEXT              NEXT ENTRY\n         BCT   R3,LPALST42\n*-> end LOOP\n         LA    R0,L'LINE               LONGUEUR D'UN POSTE\n         LR    R1,R10                  A(NEXTLINE)\n         SLR   R1,R0                   DERNIER POSTE DE LA TABLE\n         STM   R0,R1,LPATABLE+4        LONGUEUR, DERNIER POSTE\n         BAL   R14,SPACE1              BLANK LINE\nLPALST99 END_PROC\n         DROP  R4,R7\n         DROP  R12                     END_PROC\n         EJECT\n*======================================================================\n*        AUTHORIZED LIBRARIES\n*----------------------------------------------------------------------\nAPFLIST  BEGIN_PROC ,\n         L     R7,CVTAUTHL             APF TABLE\n         LH    R3,0(,R7)               # OF ENTRIES\n         STRING 'APF list: ',(CVTAUTHL,,X),                            X\n               ((R3),,R9B),' Entries.',INTO=LINE\n         BAL   R14,SPACE2              BLANK LINE\n         ST    R10,APFTABLE            SAVE ADDR OF 1ST LINE\n*-> LOOP\nAPFLIST3 MVC   LINE,BLANKS\n         SLR   R1,R1\n         IC    R1,2(,R7)\n         SH    R1,=H'6'                VOLSER LENGTH\n         STRING (9(R7),(R1)),INTO=DSNAME MOVE DSNAME\n         MVC   VOLSER,3(R7)            MOVE VOLSER\n         MVI   YYMMDD,C'?'             $OBTAIN REQUIRED\n         MVI   CATUNCAT,C'?'           $LOCATE REQUIRED\n         MVI   LINE_APF,C'?'           LNK/LPA/APF STATUS\n         BAL   R14,SPACE0              NEXT LINE\n         LA    R7,7(R1,R7)             NEXT ENTRY\n         BCT   R3,APFLIST3\n*-> end LOOP\n         LA    R2,APFTABLE             APFTABLE DESCRIPTOR\n         BAL   R14,TRIZO               SORT APFTABLE\n         BAL   R14,SPACE1              BLANK LINE\n         END_PROC\n         DROP  R12                     END_PROC\n         EJECT\n*======================================================================\n*        ACTIVE LPA Q (FLPA/MLPA)\n*----------------------------------------------------------------------\nLPACTIV  BEGIN_PROC ,\n         L     R5,CVTQLPAQ             ACTIVE LPA QUEUE\n         ICM   R5,B'1111',0(R5)        FIRST LPDE ON QUEUE\n         BZ    LPACT99                 EMPTY QUEUE, SKIP SEARCH\n         USING LPDE,R5\n         STRING 'Active LPA Queue:',INTO=LINE\n         BAL   R14,SPACE2              BLANK LINE\n         STRING '   NAME     ENTPT    ATTRB SP ATTR  ATTR2  USE ',     X\n               '   MAJ-CDE   LENGTH   LOAD-PNT',INTO=LINE\n         BAL   R14,SPACE2              BLANK LINE\n*-> LOOP\nLPACT11  TM    LPDEATTR,LPDEMIN        MINOR LPDE?\n         BO    LPACT12                 YES, JUMP\n         STRING 3X,LPDENAME,1X,(LPDENTP,,X),3X,(LPDEATTB,,X),6X,       X\n               (LPDEATTR,,X),4X,(LPDEATT2,,X),4X,                      X\n               (LPDEUSE,,X),12X,                                       X\n               (LPDEXTLN,,X),2X,(LPDEXTAD,,X),INTO=LINE\n         B     LPACT20\nLPACT12  L     R2,LPDEMJP              MAJOR CDE\n         TM    LPDEATT2,LPDEXLE        EXTENT LIST BUILD?\n         BZ    LPACT13                 NO, JUMP\n         STRING 3X,LPDENAME,1X,(LPDENTP,,X),3X,(LPDEATTB,,X),6X,       X\n               (LPDEATTR,,X),4X,(LPDEATT2,,X),4X,                      X\n               (LPDEUSE,,X),2X,(LPDENAME-LPDE(R2),8),2X,               X\n               (LPDEXTLN,,X),2X,(LPDEXTAD,,X),INTO=LINE\n         B     LPACT20\nLPACT13  STRING 3X,LPDENAME,1X,(LPDENTP,,X),3X,(LPDEATTB,,X),6X,       X\n               (LPDEATTR,,X),4X,(LPDEATT2,,X),4X,                      X\n               (LPDEUSE,,X),2X,(LPDENAME-LPDE(R2),8),INTO=LINE\nLPACT20  BAL   R14,SPACE0              NEXT LINE\n         ICM   R5,B'1111',LPDECHN      NEXT LPDE ADDR\n         BNZ   LPACT11                 NO FINISHED YET, LOOP FURTHER\n*-> end LOOP\nLPACT99  BAL   R14,SPACE1              BLANK LINE\n         END_PROC\n         DROP  R5\n         DROP  R12                     END_PROC\n         EJECT\n*======================================================================\n*        SVC TABLE\n*----------------------------------------------------------------------\nSVCTABLE BEGIN_PROC ,\n         STRING 'SVC Table:',INTO=LINE\n         BAL   R14,SPACE2              BLANK LINE\n         L     R5,CVTABEND             SECONDARY CVT\n         USING SCVTSECT,R5\n         NUCLKUP BYNAME,NAME='IGCERROR',ADDR=(0)\n         ST    R0,IGCERROR             save address of IGCERROR\n         L     R5,SCVTSVCT             START OF SVC TABLE\n         LA    R3,00256/2\n         OI    K1+L'K1-1,15            INIT PACKED CTR\n         USING SVCENTRY,R5\n*-> LOOP\nSVCTAB3  L     R1,SVCEP                SVC EP ADDR\n         BAL   R14,CSVQUERY            GET EP NAME\n         BAL   R7,SVCTYPE              DECODE TYPE\n         STRING (K1,P,R5B),2X,(SVCEP,,X),1X,EP10,2X,(WK256,12),        X\n               INTO=LINE\n         LA    R5,8(,R5)               NEXT SVC (ODD NUMBER)\n         ZAP   K2,K1\n         AP    K2,=P'1'\n         L     R1,SVCEP                SVC EP ADDR\n         BAL   R14,CSVQUERY            GET EP NAME\n         BAL   R7,SVCTYPE              DECODE TYPE\n         STRING (K2,P,R5B),2X,(SVCEP,,X),1X,EP10,2X,(WK256,12),        X\n               INTO=(LINE+40,L'LINE-40)\n         BAL   R14,SPACE0              NEXT LINE\n         AP    K1,=P'2'\n         LA    R5,8(,R5)               NEXT SVC (EVEN)\n         BCT   R3,SVCTAB3\n*-> end LOOP\n         STRING '             ++                                      +X\n               +',INTO=LINE\n         BAL   R14,SPACE0              NEXT LINE\n         STRING '   LOCKS: 80-LOCAL   40-CMS     20-OPT     10-SALLOC  X\n               08-DISP',INTO=LINE\n         BAL   R14,SPACE2              BLANK LINE\n*\n*        TYPE-X ESR ENTRIES\n*\nSVCESR1  BAL   R3,SVCESR2              BRANCH AROUND TABLE\n         DC    AL2(116),C'1'           T1-ESR\n         DC    AL2(122),C'2'           T2-ESR\n         DC    AL2(109),C'3'           T3-ESR\n         DC    AL2(137),C'6'           T6-ESR\n*-> LOOP (1)\nSVCESR2  L     R1,CVTABEND             SECONDARY CVT\n         L     R5,SCVTSVCT-SCVTSECT(,R1)  START OF SVC TABLE\n         LH    R1,0(,R3)               GET SVC NUMBER\n         SLL   R1,3                    MULT BY 8\n         L     R5,0(R1,R5)             ADDR OF T3-ESR TABLE\n         L     R0,SVCESRMX             GET MAX NUMBER OF ENTRIES\n         CVD   R0,WKCELL1              KEEP IT\n         STRING 'Type-',(2(R3),1),' ESR  (SVC ',(0(R3),H,R3Z),         X\n               ' - Maximum ',(WKCELL1,P,L),' Entries)',INTO=LINE\n         BAL   R14,SPACE2              BLANK LINE\n         SP    K1,K1                   RESET CTR\n         LA    R5,8(,R5)               SKIP HEADER\n*-> LOOP (2)\nSVCESR3  LR    R1,R5                   CURRENT ENTRY\n         SH    R1,=H'16'               BACK UP 2 ENTRIES\n         CLC   0(16,R1),0(R5)          SAME UNUSED ENTRIES?\n         BE    SVCESR3P                YES, SKIP THEM\n         L     R1,SVCEP                SVC EP ADDR\n         BAL   R14,CSVQUERY            GET EP NAME\n         BAL   R7,SVCTYPE              DECODE TYPE\n         STRING (K1,P,R5B),2X,(SVCEP,,X),1X,EP10,2X,(WK256,12),        X\n               INTO=LINE\n         LA    R5,8(,R5)               NEXT SVC (ODD NUMBER)\n         CP    K1,WKCELL1              LAS NUMBER REACHED?\n         BNL   SVCESR3N                YES, EXIT LOOP\n         ZAP   K2,K1\n         AP    K2,=P'1'\n         L     R1,SVCEP                SVC EP ADDR\n         BAL   R14,CSVQUERY            GET EP NAME\n         BAL   R7,SVCTYPE              DECODE TYPE\n         STRING (K2,P,R5B),2X,(SVCEP,,X),1X,EP10,2X,(WK256,12),        X\n               INTO=(LINE+40,L'LINE-40)\nSVCESR3N BAL   R14,SPACE0              NEXT LINE\n         B     SVCESR3Q\nSVCESR3P LA    R5,8(,R5)               SKIP EVEN #\nSVCESR3Q AP    K1,=P'2'\n         LA    R5,8(,R5)               NEXT SVC (EVEN)\n         CP    K1,WKCELL1              LAST NUMBER REACHED?\n         BNH   SVCESR3                 NO, KEEP LOOPING\n*-> end LOOP (2)\n         BAL   R14,SPACE1              BLANK LINE\n         LA    R3,3(,R3)               NEXT ESR-TYPE TABLE ENTRY\n         CLI   0(R3),0                 END OF TABLE?\n         BE    SVCESR2                 NOT YET, DO IT AGAIN\n*-> end LOOP (1)\n         END_PROC\n*\n*        DECODE SVC TYPE FLAGS\n*\nSVCTYPE  MVC   WK256(12),BLANKS        FORMAT OUTPUT FIELD\n         MVC   WK256(2),=C'T3'         FORMAT OUTPUT FIELD\n         TM    SVCTP,SVCTP34           TYPE 3 (OR 4)\n         BO    SVCTYPE2                YES, JUMP\n         MVI   WK256+1,C'2'            CHANGE TO T2\n         TM    SVCTP,SVCTP2            TYPE 2?\n         BO    SVCTYPE2                YES, JUMP\n         MVI   WK256+1,C'6'            CHANGE TO T6\n         TM    SVCTP,SVCTP6            TYPE 6?\n         BO    SVCTYPE2                YES, JUMP\n         MVI   WK256+1,C'1'            CHANGE TO T1\nSVCTYPE2 TM    SVCTP,SVCAPF            APF REQUIRED?\n         BNO   SVCTYPE3                NO, JUMP\n         MVC   WK256+2(4),=C'-APF'     YES, SHOW APF\nSVCTYPE3 TM    SVCTP,SVCESR            ESR?\n         BNO   SVCTYPE6                NO, JUMP\n         MVC   WK256+2(4),=C'-ESR'     YES, SHOW ESR\nSVCTYPE6 CLI   SVCLOCKS,0              ANY LOCK REQUIRED?\n         BE    SVCTYPE9                NO, JUMP\n         STRING (WK256,12,T),'-',(SVCLOCKS,,X),INTO=(WK256,12)\nSVCTYPE9 BR    R7\n         DROP  R5\n         DROP  R12                     END_PROC\n         EJECT\n*======================================================================\n*        Device class table and corresponding unit names\n*        On-line devices\n*----------------------------------------------------------------------\nDEVICES  BEGIN_PROC ,\n         L     R3,CVTDCQA              GET DCQ ADDRESS\n         L     R3,DCQFIRST-DCQ(,R3)    GET FIRST DCQ ADDRESS\n         USING DCQELMNT,R3             DCQ element\n*-> LOOP (1)\nDEV101   ICM   R0,B'0011',DCQUCBCT     any devices gen'd?\n         BZ    DEV190                  no, exit\n         MVC   UNITNAME+18(1),DCQDEVCL Device class code\n         XCALL IEFEB4UV,                                               X\n               (UNITNAME,              IEFEB4UV parm list              X\n               =X'0010'),              FUNCTION CODE '11'              X\n               ERRET=DEV190            error, try next device class\n         L     R4,UNITNAME+4           point to the returned work area\n*        #SNAP ADDR=UNITNAME,LENGTH=32                           <SNAP>\n         ICM   R5,B'1111',4(R4)        get the number of unit-names\n         BZ    DEV180                  none found, try next class\n         STRING 'Device Class: ',DCQDEVNM,INTO=LINE\n         BAL   R14,SPACE2              blank line\n         LA    R6,8(,R4)               first unit name\n         STRING '  Unit Names:',INTO=LINE\n         B     DEV122                  first time, jump\n*-> LOOP\nDEV121   LA    R0,LINE+76              last position\n         CR    R2,R0                   end of line reached yet?\n         BL    DEV124                  no, jump\n         BAL   R14,SPACE0              yes, next line\n         MVC   LINE,BLANKS             CLEAR OUT MSG AREA\nDEV122   LA    R2,LINE+19              Point to beginning of line\nDEV124   MVC   0(8,R2),0(R6)           MOVE UNITNAME TO BUFFER\n         LA    R6,8(,R6)               GO TO NEXT UNIT NAMES (RETURNED)\n         LA    R2,10(,R2)              Bump pointer in print line\n         BCT   R5,DEV121               next unit name\n*-> end LOOP\n         BAL   R14,SPACE2              BLANK LINE\nDEV180   L     R0,0(,R4)               get sub-pool and length\n         FREEMAIN R,A=(R4),LV=(R0)\n*\n*        Display on-line devices\n*\n         SLR   R2,R2\n         LH    R4,DCQUCBCT             number of UCBs\n         L     R7,DCQUCBAD             addr of first UCB\n         USING UCBOB,R7\n*-> LOOP\nDEV201   TM    UCBSTAT,UCBONLI         THIS UNIT ONLINE?\n         BNO   DEV202                  NO, IGNORE IT\n         LA    R2,1(,R2)               count on-line devices\nDEV202   L     R7,UCBNXUCB             addr of next UCB\n         BCT   R4,DEV201               count next UCB\n*-> end LOOP\n         STRING '  UCBs:',(DCQUCBCT,H,R7B),' (defined)',               X\n               ((R2),,R7B),' (on-line)',INTO=LINE\n         BAL   R14,SPACE2              BLANK LINE\n         LTR   R2,R2                   any on-line devices?\n         BZ    DEV190                  no, exit\n         STRING '    CUA  UCBTYP    Unitname  Volser  Status',         X\n               INTO=LINE\n         BAL   R14,SPACE2              BLANK LINE\n         LH    R4,DCQUCBCT             number of UCBs\n         L     R7,DCQUCBAD             addr of first UCB\n*-> LOOP\nDEV221   TM    UCBSTAT,UCBONLI         THIS UNIT ONLINE?\n         BNO   DEV228                  NO, IGNORE IT\n         MVC   UNITNAME+8(4),UCBTYP    DEVICE TYPE\n         BAL   R14,GETUNIT             GET UNITNAME\n         CLI   UCBTBYT3,UCB3DACC       DASD?\n         BNE   DEV227                  NO, JUMP\n*\n*        get 3380 type\n*\n         BAS   R1,DEV_3380             BRANCH AROUND TABLE\n         DC    AL1(D3380D),C'D'        DCEMDRDT\n         DC    AL1(D3380E),C'E'        DCEMDRDT\n         DC    AL1(D3380J),C'J'        DCEMDRDT\n         DC    AL1(D3380K),C'K'        DCEMDRDT\n         DC    AL1(00),0H'0'\nDEV_3380 SLR   R2,R2\n         ICM   R2,B'0111',UCBEXTP         UCB common extension\n         L     R2,UCBCLEXT-UCBCMEXT(,R2)  Device class extension\n         USING DCE,R2\n         BAL   R14,SCAN_CLI            SCAN TABLE\n         DC    Y(1+1)                  SIZE OF A TABLE ENTRY\n         CLI   DCEMDRDT,*-*            TEST 3380 MODEL\n         BNE   *+L'*+6                 NOT FOUND, JUMP AROUND \"MVC\"\n         MVC   UNITNAME+4(1),1(R1)     MOVE 3380 TYPE (D/E/J/K)\n         DROP  R2\nDEV227   STRING 4X,UCBNAME,2X,(UCBTYP,4,X),2X,UNITNAME,INTO=LINE\nLINE_UCB EQU   LINE+29,4,C'A'          ucbaddr in line\n         STCM  R7,B'1111',LINE_UCB     store UCB addr for DEVSTAT rtne\n         BAL   R14,SPACE0              NEXT LINE\nDEV228   L     R7,UCBNXUCB             addr of next UCB\n         BCT   R4,DEV221               Next UCB\n*-> end LOOP\nDEV280   BAL   R14,SPACE1              BLANK LINE\nDEV190   ICM   R3,B'1111',DCQCHAIN     NEXT DCQ ELEMENT\n         BNZ   DEV101                  process it\n*-> end LOOP (1)\nDEV999   END_PROC\n         DROP  R3,R7\n         DROP  R12                     END_PROC\n         EJECT\n*======================================================================\n*        Display MCS Consoles\n*----------------------------------------------------------------------\nCONSOLES BEGIN_PROC ,\n         L    R4,CVTCUCB               Unit Control Module (UCM)\n         USING UCM,R4\n         STRING 'Consoles:',INTO=LINE\n         BAL   R14,SPACE2              BLANK LINE\n         L     R5,UCMVDATA             1st UCME\n         USING UCMLIST,R5              Individual device entry\n*-> LOOP (1)\nCONSOL21 L     R7,UCMUCB               associated UCB\n         USING UCBOB,R7\n         STRING '  Id(',(UCMID,FL1,L),')',INTO=LINE\n         STRING '  Device(',UCBNAME,')  Inactive',INTO=(LINE+12,30)\n         TM    UCMATR,UCMUF            This console active?\n         BZ    CONSOL28                no, jump\n         BAL   R14,CHECK0              check next line available\n         L     R7,UCMFEXTP             addr of fixed extension\n         USING UCMEFEXT,R7\n         STRING 'Active  ROUTCDE=(',INTO=(LINE+27,NEXTLINE)\n         LA    R0,L'UCMEFRC            BYTE LOOP\n         LA    R1,UCMEFRC              Routcde bit string\n         LA    R2,001                  Route code (1-255)\n*-> LOOP (2)\nCONS210  TM    0(R1),*-*               CHECK FOR RECORDING OFF\n         LA    R3,008                  BIT LOOP\n         LA    R6,X'80'                BIT MASK\n*-> LOOP (3)\nCONS220  EX    R6,CONS210              EXECUTE \"TM\"\n         BZ    CONS227                 Route code off, jump\n         CLC   LINE+76(3),BLANKS       check line complete         EU19\n         BE    CONS221                 no, continue                EU19\n         BAL   R14,SPACE0              yes, bump to next line      EU19\n         STRING 44X,((R2),,L),',',INTO=LINE                        EU19\n         B     CONS227                                             EU19\nCONS221  STRING (LINE,,L),((R2),,L),',',INTO=LINE                  EU19\nCONS227  LA    R2,1(,R2)               BUMP RECNO\n         SRL   R6,1                    OFFSET MASK\n         BCT   R3,CONS220\n*-> end LOOP (3)\n         LA    R1,1(,R1)               BUMP BYTE ADDRESS\n         BCT   R0,CONS210\n*-> end LOOP (2)\n         LA    R15,LINE(R15)           CHANGE OFFSET TO ADDRESS\n         BCTR  R15,0                   OFFSET TO LAST ','\n         CLI   0(R15),C','             is it really a comma?\n         BE    CONS247                 yes, jump\n         LA    R15,1(,R15)             no, do not overlay\nCONS247  MVI   0(R15),C')'             CLOSE PARENTHESIS\nCONSOL28 BAL   R14,SPACE0              next line\n         LM    R14,R15,UCMVDATA+4      length(UCME) Last(UCME)\n         BXLE  R5,R14,CONSOL21\n*-> end LOOP (1)\n*        #SNAP ADDR=UCM,LENGTH=X'170'                            <SNAP>\n*        #SNAP ADDR=(R1),LENGTH=UCMESIZE                         <SNAP>\n         BAL   R14,SPACE1              BLANK LINE\nCONSOL99 END_PROC ,\n         DROP  R4,R5,R7\n         DROP  R12                     END_PROC\n         DROP  R8                      CVT ****************************\n         EJECT\n*======================================================================\n*        Display RACF profile from ACEE\n*----------------------------------------------------------------------\nRACF00   BEGIN_PROC ,\n         L     R2,PSAAOLD-PSA          POINT TO MY ASCB.\n         L     R2,ASCBASXB-ASCB(,R2)   POINT TO MY ASXB.\n         L     R2,ASXBSENV-ASXB(,R2)   POINT TO MY ACEE.\n         USING ACEE,R2\n         TM    ACEEFLG1,ACEERACF       this user defined to RACF?\n         BZ    RACF99                  no, quit\n         STRING 'RACF Profile:',INTO=LINE\n         BAL   R14,SPACE2              BLANK LINE\n         STRING '  User: ',ACEEUSRI,   RACF user                       X\n               '  Group: ',ACEEGRPN,   Connect Group name              X\n               '  Terminal: ',ACEETRID, terminal ID                    X\n               '    Flags: ',(ACEEFLG1,,X),1X,(ACEEFLG2,,X),1X,        X\n               (ACEEFLG3,,X),1X,(ACEEFLG4,,X),1X,                      X\n               INTO=LINE\n         BAL   R14,SPACE0              NEXT LINE\n         BAS   R1,RACF10               BRANCH AROUND TABLE\n         DC    AL1(ACEEALTR),C'Alter  '\n         DC    AL1(ACEECNTL),C'Control'\n         DC    AL1(ACEEUPDT),C'Update '\n         DC    AL1(ACEEREAD),C'Read   '\n         DC    AL1(ACEENONE),C'None   '\n         DC    AL1(00),0H'0'\nRACF10   BAL   R14,SCAN_TM             SCAN TABLE\n         DC    Y(1+7)                  SIZE OF A TABLE ENTRY\n         TM    ACEEFLG2,*-*            Test SMS status on this system\n         BO    *+L'*+4                 NOT FOUND, JUMP AROUND \"MVC\"\n         LA    R1,BLANKS               UACC is ondetermined\n         STRING '  UACC: ',(1(R1),7),'   Attributes:',                 X\n               INTO=LINE\n         LA    R4,LINE+1(R15)          authority level\n         STATUS ACEEFLG1,ACEESPEC,'Special'\n         STATUS ACEEFLG1,ACEEADSP,'ADSP'\n         STATUS ACEEFLG1,ACEEOPER,'Operations'\n         STATUS ACEEFLG1,ACEEAUDT,'Auditor'\n         STATUS ACEEFLG1,ACEELOGU,'Logged'\n         STATUS ACEEFLG1,ACEEPRIV,'Privileged'\n         TM    ACEEFLG1,ACEESPEC+ACEEADSP+ACEEOPER+ACEEAUDT+ACEELOGU+ACX\n               EEPRIV\n         BNZ   RACF20                  at least one attribute, jump\n         MVC   0(6,R4),=C'(none)'      show it\nRACF20   ICM   R3,B'1111',ACEEUNAM                                 EU10\n         BZ    RACF40                                              EU10\n         XR    R1,R1                                               EU10\n         IC    R1,0(R3)                                            EU10\n         BCT   R1,*+L'*+4                                          EU10\n         B     RACF40                                              EU10\n         BAL   R14,SPACE0              next line                   EU10\n         STRING '  User name: ',(1(R3),(R1)),INTO=LINE             EU10\nRACF40   CLI  ACEEAPLN,C' '            connected Application?      EU10\n         BE   RACF41                   no                          EU10\n         BAL   R14,SPACE0              next line                   EU10\n         STRING '  Connected Application: ',ACEEAPLN,              EU10X\n               INTO=LINE                                           EU10\nRACF41   TM   ACEEFLG4,ACEEUATH+ACEEDASD+ACEETAPE+ACEETERM         EU10\n         BZ   RACF50                   none                        EU10\n         TM   ACEEFLG4,ACEEUATH        add user?                   EU10\n         BZ   RACF42                   no                          EU10\n         BAL   R14,SPACE0              next line                   EU10\n         STRING '  User is authorized to define other users',      EU10X\n               INTO=LINE                                           EU10\nRACF42   TM   ACEEFLG4,ACEEDASD        DASD protect?               EU10\n         BZ   RACF43                   no                          EU10\n         BAL   R14,SPACE0              next line                   EU10\n         STRING '  User is authorized to protect DASD volumes',    EU10X\n               INTO=LINE                                           EU10\nRACF43   TM   ACEEFLG4,ACEETAPE        TAPE protect?               EU10\n         BZ   RACF44                   no                          EU10\n         BAL   R14,SPACE0              next line                   EU10\n         STRING '  User is authorized to protect TAPE volumes',    EU10X\n               INTO=LINE                                           EU10\nRACF44   TM   ACEEFLG4,ACEETERM        Terminals protect?          EU10\n         BZ   RACF50                   no                          EU10\n         BAL   R14,SPACE0              next line                   EU10\n         STRING '  User is authorized to protect TERMINALS',       EU10X\n               INTO=LINE                                           EU10\nRACF50   BAL   R14,SPACE2              BLANK LINE\n         DROP  R2\nRACF99   END_PROC\n         DROP  R12                     END_PROC\n         EJECT\n*======================================================================\n*        Display TSO profile\n*----------------------------------------------------------------------\nPROF00   BEGIN_PROC ,\n         L     R5,TCBJSCB              point at JSCB\n         USING IEZJSCB,R5\n         ICM   R6,B'1111',JSCBPSCB     point at PSCB\n         BZ    PROF99                  not a TSU, exit\n         USING PSCB,R6\n         STRING 'TSO Profile:',INTO=LINE\n         BAL   R14,SPACE2              BLANK LINE\n         STRING '  Attributes:',INTO=LINE\n         LA    R4,LINE+1(R15)          start of attribute list\n         STATUS PSCBATR1,PSCBCTRL,'OPER'\n         STATUS PSCBATR1,PSCBACCT,'ACCT'\n         STATUS PSCBATR1,PSCBJCL,'SUBMIT'\n         STATUS PSCBATR1,PSCBVMNT,'MOUNT'\n         STATUS PSCBATR1,PSCBCNAU,'CONSOLE'\n         TM    PSCBATR1,PSCBCTRL+PSCBACCT+PSCBJCL+PSCBVMNT+PSCBCNAU\n         BNZ   PROF12                  at least one attribute, jump\n         MVC   0(6,R4),=C'(none)'      show it\nPROF12   BAL   R14,SPACE0              NEXT LINE\n         MVC   WKCELL1,=C'Local   '    default destination\n         CLI   PSCBDEST,0              any special dest?\n         BE    PROF15                  no, jump\n         MVC   WKCELL1,PSCBDEST        yes, use it\nPROF15   STRING '  Unit: ',PSCBGPNM,'   Dest: ',WKCELL1,               X\n               INTO=LINE\n         BAL   R14,SPACE0              NEXT LINE\n         MVC   WKCELL1(1),PSCBSUBH\n         MVC   WKCELL1+1(1),PSCBSUBC\n         MVC   WKCELL1+2(1),PSCBSUBM\n         MVC   WKCELL1+3(1),PSCBSOUT\n         LA    R0,4\n         LA    R1,WKCELL1+3\nPROF20   CLI   0(R1),0\n         BNE   *+L'*+4\n         MVI   0(R1),C' '\n         BCTR  R1,0\n         BCT   R0,PROF20\n         STRING '  Submit Hold Class: ',(WKCELL1,1),                   X\n               '   Submit Class: ',(WKCELL1+1,1),                      X\n               '   Msgclass: ',(WKCELL1+2,1),                          X\n               '   Sysout Class: ',(WKCELL1+3,1),                      X\n               INTO=LINE\n         BAL   R14,SPACE0              NEXT LINE\n*\n*        Display Profile options and DSN prefix from UPT\n*\nPROF31   L     R7,PSCBUPT              User profile table\n         USING UPT,R7\n         MVC   LINE,BLANKS             blank line\n         LA    R4,LINE+2               start of options\n         BAL   R1,PROF32\n         DC    AL1(UPTNPRM),C'Noprompt  '\n         DC    AL1(UPTNCOM),C'Nointercom'\n         DC    AL1(UPTPAUS),C'Pause     '\n         DC     AL1(UPTMID),C'Msgid     '\n         DC    AL1(UPTMODE),C'Mode      '\n         DC     AL1(UPTWTP),C'WTPMSG    '\n         DC    AL1(UPTRCVR),C'Recover   '\n         DC    X'00',0H'0'             end of table\nPROF31TM TM    UPTSWS,*-*              check UPT switch\n*-> LOOP\nPROF32   IC    R15,0(,R1)              pick up TM mask\n         EX    R15,PROF31TM            test UPT switch\n         BO    PROF34                  jump if one\n         CLI   1(R1),C'N'              NO-something?\n         BE    PROF33                  yes, jump\n         STRING 'No',(1(R1),10,T),INTO=((R4),10)\n         NI    2(R4),255-X'40'         lowercase\n         B     PROF36\nPROF33   STRING (1+2(R1),10-2,T),INTO=((R4),10)\n         OI    0(R4),X'40'             uppercase\n         B     PROF36\nPROF34   STRING (1(R1),10,T),INTO=((R4),10)\nPROF36   LA    R4,1(R15,R4)            bump pointer\n         LA    R1,1+10(,R1)\n         CLI   0(R1),0                 end of table?\n         BNE   PROF32                  not yet, loop\n*-> end LOOP\n         BAL   R14,CHECK0              check next line available\n         SLR   R1,R1\n         IC    R1,UPTPREFL             Prefix length\n         STRING 'Prefix(',(UPTPREFX,(R1)),')',INTO=((R4),NEXTLINE)\n         BAL   R14,SPACE2              BLANK LINE\nPROF99   END_PROC ,\n         DROP  R5,R6,R7\n         DROP  R12                     END_PROC\n         EJECT\n*======================================================================\n*        Scan the TIOT to display my file allocations\n*----------------------------------------------------------------------\nTIOT00   BEGIN_PROC ,\n         STRING 'TIOT:',INTO=LINE\n         BAL   R14,SPACE2              BLANK LINE\n         L     R5,TCBTIO               TIOT\n         USING TIOT1,R5\n         L     R6,PSAAOLD-PSA          MY ASCB\n         L     R6,ASCBOUCB-ASCB(,R6)   MY OUCB\n         USING OUCB,R6\n         L     R1,TCBTCT               SMF TCT\n         L     R1,TCTCRTBL-SMFTCT(,R1) STORAGE TABLE\n         L     R1,TCTRSZ-TCTCORE(,R1)  REGION SIZE (BELOW)\n         ALR   R1,R1                   GET REGION SIZE IN \"K\"\n         STRING '  JOB name: ',TIOCNJOB,'  Step: ',(TIOCSTEP+0,8),     X\n               ' Procstep: ',(TIOCSTEP+8,8),                           X\n               ' Region=',((R1),,L),'K',                               X\n               ' Perform=',(OUCBNPG,H,L),                              X\n               INTO=LINE\n         BAL   R14,SPACE2              BLANK LINE\n*\n*        display current allocations\n*\n         STRING '  DDname  Disp Volser   EXCP Data Set Name',32X,      X\n               'Device   Cuu Miscellaneous',INTO=LINE\n         BAL   R14,SPACE2              BLANK LINE\n*-> LOOP\nTIOT_GET CLI   TIOEDDNM,C' '           FREED DD?\n         BL    TIOT_NXT                YES, JUMP\n         LA    R6,WKWORDS+4            WORK AREA\n         ST    R6,WKWORDS              WORK AREA\n         USING ZB505,R6\n         XC    SWAEPAX,SWAEPAX         CLEAR WORK AREA             @364\n         MVC   SWVA,TIOEJFCB           SVA OF THE JFCB\n         SWAREQ FCODE=RL,EPA=WKWORDS,MF=(E,SWAREQL1),UNAUTH=YES\n         L     R6,SWBLKPTR             31-BIT ADDRESS OF JFCB\n         USING INFMJFCB,R6\n         MVC   WKCELL1,BLANKS          CLEAR WORK AREA\n         MVC   WKCELL2,BLANKS          CLEAR WORK AREA\n         MVC   STATUS,BLANKS           CLEAR WORK AREA\n         MVC   UNITNAME,BLANKS         CLEAR WORK AREA\n         MVC   VOLSER,=C'JES     '     SYSIN/SYSOUT\n         SLR   R1,R1                   EXCP=0\n         SLR   R7,R7                   NO UCB\n         TM    TIOELINK,TIOESSDS       IS THIS A JES DATA SET?\n         BO    TIOT61                  YES, JUMP\n         MVC   VOLSER,=C'DUMMY   '     DUMMY DATA SET\n         ICM   R7,B'0111',TIOEFSRT     UCB ADDRESS\n         BZ    TIOT64                  NO UCB, SKIP TCT SCAN\n         USING UCBOB,R7\n         MVC   UNITNAME+8(4),UCBTYP    DEVICE TYPE\n         BAL   R14,GETUNIT2        <== GET UNITNAME\n         MVC   VOLSER,=C'VIO     '     UNIT=VIO\n         TM    UCBOB,UCBVRDEV          IS THIS A VIO DATA SET?\n         BO    TIOT41                  YES, JUMP\n         MVC   VOLSER,JFCBVOLS         NO, MOVE FIRST VOLSER\nTIOT41   BAS   R1,TIOT41B\n         DC    AL1(JFCNEW),C'NEW'\n         DC    AL1(JFCMOD),C'MOD'\n         DC    AL1(JFCOLD+JFCSHARE),C'SHR'\n         DC    AL1(JFCOLD),C'OLD'\n         DC    X'00',0H'0'\nTIOT41B  BAL   R14,SCAN_TM             CALL SCAN RTNE\n         DC    Y(1+3)               0  LENGTH OF A TABLE ENTRY\n         TM    JFCBIND2,*-*         2  TEST DATA SET STATUS\n         MVC   STATUS,1(R1)         6  DISP\n         TM    UCBFL5,UCBSMS           SMS VOL? (X'20')\n         BZ    TIOT46                  NO, JUMP\n         MVC   WKCELL1(3),=C'SMS'      SMS-MANAGED\nTIOT46   CLI   UCBTBYT3,UCB3TAPE       TAPE DEVICE?\n         BNE   TIOT61                  NO, JUMP\n         BAS   R1,TIOT46B\n         DC    AL1(JFCBLTM),C'LTM'\n         DC    AL1(JFCBLP),C'BLP'\n         DC    AL1(JFCSUL),C'SUL'\n         DC    AL1(JFCSUL+JFCBAL),C'AUL'\n         DC    AL1(JFCBAL),C'AL '\n         DC    AL1(JFCNSL),C'NSL'\n         DC    AL1(JFCSL),C'SL '\n         DC    AL1(JFCNL),C'NL '\n         DC    X'00',0H'0'\nTIOT46B  BAL   R14,SCAN_TM             CALL SCAN RTNE\n         DC    Y(1+3)               0  LENGTH OF A TABLE ENTRY\n         TM    JFCBLTYP,*-*         2  TEST LABEL TYPE FLAGS\n         LH    R0,JFCBFLSQ             PICK UP FILE SEQUENCE NUMBER\n         LTR   R0,R0                   LABEL=0?\n         BNZ   TIOT46Y                 NO, JUMP\n         LA    R0,0001                 YES, CHANGE TO LABEL=1\nTIOT46Y  STRING ((R0),,L),',',(1(R1),3),INTO=WKCELL1\nTIOT61   LA    R0,TIOENTRY             POINT TO CURRENT TIOT ENTRY\n         SL    R0,TCBTIO               CHANGE ADDRESS TO OFFSET\n         BAL   R14,EXCP00          <== GET EXCP COUNT IN R1\n         STRING ((R1),,R6B),INTO=WKCELL2\n         CL    R1,=F'100000'           OVER 100K?\n         BL    TIOT64                  NO, JUMP\n         SLR   R0,R0                   YES, DIVIDE BY 1000\n         LA    R1,500(,R1)             YES, DIVIDE BY 1000\n         D     R0,=F'1000'             YES, DIVIDE BY 1000\n         STRING ((R1),,R4B),'K',INTO=WKCELL2\nTIOT64   LTR   R7,R7                   DO WE HAVE AN UCB?\n         BNZ   TIOT_PRT                YES, JUMP\n         LA    R7,BLANKS               NO, POINT TO A DUMMY UCB\nTIOT_PRT STRING 2X,TIOEDDNM,1X,STATUS,1X,VOLSER,1X,(WKCELL2,7),        X\n               JFCBDSNM,1X,UNITNAME,1X,UCBNAME,1X,WKCELL1,             X\n               INTO=LINE\n         MVI   LINE_LNK2,C'?'          SHOW LNKLST STATUS\n         MVI   LINE_LPA2,C'?'          SHOW LPALST STATUS\n         BAL   R14,SPACE0              NEXT LINE\nTIOT_NXT SLR   R0,R0                   PREPARE IC\n         IC    R0,TIOELNGH             LOAD LENGTH OF CURRENT ENTRY\n         ALR   R5,R0                   BUMP UP TO NEXT ENTRY\n         CLI   TIOELNGH,0              IS THIS THE END?\n         BNZ   TIOT_GET                NOT YET, LOOP THROUGH TIOT\n*-> end LOOP\n         BAL   R14,SPACE1              BLANK LINE\n         END_PROC\n         DROP  R5,R6,R7\n*----------------------------------------------------------------------\n*        \"EXCP00\" routine => GET EXCP COUNT IN R1\n*                            R14 - link register\n*----------------------------------------------------------------------\nEXCP00   L     R1,PSATOLD-PSA          MY TCB\n         L     R1,TCBTCT-TCB(,R1)      TCBTCT\n         L     R1,TCTIOTBL-SMFTCT(,R1) START OF I/O MEASUREMENT TABLE\n         LA    R1,TCTIODSP-TCTTIOT(,R1) FIRST DD ENTRY\n         USING TCTDCBTD,R1\n*-> LOOP\nEXCP11   CL    R0,TCTDCBTD             SAME TIOT OFFSET?\n         BE    EXCP21                  YES, EXIT LOOP\n         LA    R1,TCTDCBLE             NEXT LOOKUP TABLE ENTRY\n         ICM   R15,B'1111',TCTDCBLE    END OF TABLE?\n         BNZ   EXCP11                  NOT YET, TRY NEXT DD ENTRY\n*-> end LOOP\n         SLR   R0,R0                   EXCP COUNT IS ZERO\n         B     EXCP99\nEXCP21   L     R1,TCTIOTSD             OFFSET IN I/O MEASURE. TABLE\n         L     R15,PSATOLD-PSA         MY TCB\n         L     R15,TCBTCT-TCB(,R15)    MY TCT\n         A     R1,TCTIOTBL-SMFTCT(,R15) START OF I/O MEASUREMENT TABLE\n         USING TCTDDENT,R1\n         ICM   R0,B'1111',TCTDCTR      EXCP COUNT IN R0\nEXCP99   LR    R1,R0                   EXCP COUNT IN R1 TOO\n         BR    R14\n         DROP  R1\n         DROP  R12                     END_PROC\n         EJECT\n*======================================================================\n*        DISPLAY TCB TREE AND RB CHAINS\n*----------------------------------------------------------------------\nTCB_TREE BEGIN_PROC\n         L     R9,JSTCB                THE JOB STEP TCB\n         STRING 'TCB Tree and RB Chains:',INTO=LINE\n         BAL   R14,SPACE2              BLANK LINE\n         STRING '    TCB Address',18X,INTO=LINE,                       X\n               'Program    IC  STAB  FLAGS1 CDFLGS    DDname       DataX\n                 Programs'\n         BAL   R14,SPACE2              BLANK LINE\n         SLR   R3,R3                   INDENTATION INDEX\n*-> LOOP (1)\nTREE100  STCM  R9,B'0111',WKCELL1      STORE TCB ADDR\n         STRING (BLANKS,4(R3)),(WKCELL1,3,X),INTO=LINE\n         L     R5,TCBRBP               POINT TO TOP RB\n         LA    R4,WK256                START OF RB TABLE\n*\n*        BUILD RB TABLE\n*-> LOOP\nTREE110  ICM   R5,B'1000',CVTPTR       CLEAN UP HI-ORDER BYTE\n         SH    R5,=Y(RBBASIC-RBPREFIX) POINT TO RBPREFIX\n         USING RBPREFIX,R5\n         ST    R5,0(,R4)               STORE RB ADDRESS\n         TM    RBSTAB2,RBTCBNXT        CHECK FOR END OF CHAIN\n         L     R5,RBLINK               POINT TO PREVIOUS RB (OR TCB)\n         LA    R4,4(,R4)               BUMP UP TO NEXT TABLE ENTRY\n         BZ    TREE110                 JUMP IF RB FOR 1ST ATTACHED PGM\n*-> end LOOP\n*\n*        PROCESS RB TABLE BACKWARDS\n*-> LOOP\nTREE200  SH    R4,=H'4'                PREVIOUS ENTRY IN RB TABLE\n         L     R5,0(,R4)               LOAD RB ADDRESS\n         CLI   RBSTAB1,RBFTPRB         IS THIS A PRB?\n         BNE   TREE280                 NO, IGNORE IT\n         TM    RBCDFLGS,RBCDSYNC       CHECK FLAGS\n         BO    TREE260                 JUMP IF IT IS A SYNCH PRB\n         MVC   WKCELL1,BLANKS          TASKLIB DDNAME\n         ICM   R1,B'1111',TCBJLB       LOAD/TEST DCB ADDRESS\n         BZ    TREE250                 NO TASKLIB, JUMP\n         MVC   WKCELL1,=C'*LNKLST '\n         L     R14,CVTPTR              POINT AT CVT\n         CL    R1,CVTLINK-CVTMAP(,R14) SYS1.LINKLIB\n         BE    TREE250                 JUMP IF SYS1.LINKLIB DCB ADDR\n         LH    R1,DCBTIOT-IHADCB(,R1)  LOAD TIOT OFFSET\n         A     R1,TCBTIO               CHANGE OFFSET INTO AN ADDRESS\n         MVC   WKCELL1,4(R1)           MOVE TASKLIB DDNAME\nTREE250  BAL   R14,TALLY            <- TALLY allocated storage\n         STM   R0,R1,WKCELL3           data, programs\n         L     R1,RBCDE                POINT TO CDE/LPDE\n         STRING INTO=(LINE+30,L'LINE),3X,                              X\n               (CDNAME-CDENTRY(R1),8),3X,      PGM NAME                X\n               (RBWLIC+3,1,X),2X,      IC                              X\n               (RBSTAB,2,X),4X,        STATUS BYTE                     X\n               (RBFLAGS1,,X),5X,       Flags                           X\n               (RBCDFLGS,,X),6X,       FLAGS                           X\n               WKCELL1,                DDNAME OF TASKLIB               X\n               (WKCELL3,F,R8B),'K',    storage (data)                  X\n               (WKCELL3+4,F,R9B),'K'   storage (programs)\n         B     TREE270\nTREE260  MVC   WKCELL1,RBGRS15         PICK UP ENTRY POINT ADDRESS\n         NI    WKCELL1+3,X'FE'         SET BIT 31 TO ZERO\n         STRING INTO=(LINE+30,L'LINE),3X,                              X\n               (WKCELL1,4,X),3X,       EP ADDRESS                      X\n               (RBWLIC+3,1,X),2X,                                      X\n               (RBSTAB,2,X),4X,        Flags                           X\n               (RBFLAGS1,,X),5X,       Flags                           X\n               (RBCDFLGS,,X)           Flags\nTREE270  BAL   R14,SPACE0              NEXT LINE\nTREE280  LA    R0,WK256                CHECK FOR END OF CHAIN\n         CR    R4,R0                   CHECK FOR END OF CHAIN\n         BH    TREE200                 LOOP THROUGH RB TABLE\n*-> end LOOP\n         BAL   R14,SCANTCB             GET NEXT TCB\n         BNZ   TREE100                 PROCESS NEXT TCB\n*-> end LOOP (1)\n         BAL   R14,SPACE1              BLANK LINE\n         STRING '   STAB1: 00-PRB    C0-SVRB   40-IRB    60-TIRB   ',  X\n               '08-WAITP  02-ATNXIT 01-PMSVRB',INTO=LINE\n         BAL   R14,SPACE0              NEXT LINE\n         STRING '   STAB2: 80-TCBNXT 40-FACTV  20-ATTN   10-ETXR   ',  X\n               '0C-IQETP  02-FDYN   01-ECBWT',INTO=LINE\n         BAL   R14,SPACE0              NEXT LINE\n         STRING '  FLAGS1: 80-SLOCK  40-XWAIT  20-ABEND  10-XWPRM  ',  X\n               '08-ASIR   04-LONGWT 02-SCB     01-SSSYN',INTO=LINE\n         BAL   R14,SPACE0              NEXT LINE\n         STRING '  CDFLGS: 80-NOCELL 20-CDATCH 10-CDSAVE 08-CDNODE ',  X\n               '04-CDSYNC 02-CDXCTL 01-CDLOAD',INTO=LINE\n         BAL   R14,SPACE2              BLANK LINE\n         END_PROC\n         DROP  R5\n         DROP  R12                     END_PROC\n*----------------------------------------------------------------------\n*        TALLY allocated storage for current TCB\n*----------------------------------------------------------------------\nTALLY    BALR  R15,0\n         SAVE  (14,12),,TALLY\n         BALR  R12,0\n         USING *,R12                   local base register\n         SLR   R0,R0                   STORAGE ALLOCATED (DATA)\n         SLR   R1,R1                   STORAGE ALLOCATED (PROGRAMS)\n         L     R2,TCBMSS               FIRST SUB-POOL FOR THIS TCB\n         USING SPQE,R2\n*-> LOOP (1)\nTALLY21  CL    R9,TCBJSTCB             Am I the JS TCB?\n         BE    TALLY21L                yes, then I assume ownership\n         CL    R9,SPQETCB              Do I own this subpool?\n         BNE   TALLY29                 no, ignore it\nTALLY21L L     R4,SPQESPQA             chain descriptors\n         USING SPQA,R4\n         LA    R5,3                    3 ENTRIES IN SPQA\n*-> LOOP (2)\nTALLY22  CL    R4,0(,R4)               EMPTY ENTRY?\n         BE    TALLY25                 YES, EXIT\n         L     R6,0(,R4)               FIRST/LAST DQE\n         USING DQE,R6\n*-> LOOP (3)\nTALLY23  CLI   SPQEID,251              PROGRAM SUB-POOL?\n         BE    TALLY23P                YES, JUMP\n         CLI   SPQEID,252              PROGRAM SUB-POOL?\n         BE    TALLY23P                YES, JUMP\n         AL    R0,DQESIZE              ADD SIZE (DATA)\n         B     TALLY23Q\nTALLY23P AL    R1,DQESIZE              ADD SIZE (PROGRAMS)\nTALLY23Q CL    R6,4(,R4)               LAST DQE ON THIS CHAIN?\n         L     R6,DQENEXT\n         BNE   TALLY23                 NO, PROCESS NEXT ONE\n*-> end LOOP (3)\nTALLY25  LA    R4,8(,R4)               NEXT ENTRY IN SPQA\n         BCT   R5,TALLY22\n*-> end LOOP (2)\nTALLY29  ICM   R2,B'1111',SPQENEXT     NEXT SUBPOOL\n         BNZ   TALLY21\n*-> end LOOP (1)\n         SRL   R0,10                   data bytes, in K\n         SRL   R1,10                   program bytes, in K\n         L     R14,12(,R13)\n         LM    R2,R12,28(R13)\n         BR    R14\n         DROP  R2,R4,R6\n         DROP  R12                     local base register\n         EJECT\n*======================================================================\n*        DISPLAY JPAQ (CDE CHAIN)\n*----------------------------------------------------------------------\nJPAQ     BEGIN_PROC ,\n         L     R9,JSTCB                THE JOB STEP TCB\n         STRING 'JPAQ:',INTO=LINE\n         BAL   R14,SPACE2              BLANK LINE\n         L     R5,TCBJPQ               POINT TO FIRST CDE IN CHAIN\n         USING CDENTRY,R5\n         STRING '   NAME     ENTPT    ATTRB SP ATTR  ATTR2  USE ',     X\n               '   MAJ-CDE   LENGTH   LOAD-PNT',INTO=LINE\n         BAL   R14,SPACE2              BLANK LINE\n*-> LOOP\nJPAQ21   L     R6,CDXLMJP              POINT TO XL (OR MAJOR CDE)\n         TM    CDATTR,CDMIN            CHECK ATTRIBUTES\n         BO    JPAQ25                  JUMP IF THIS IS A MINOR CDE\n         USING XTLST,R6\n         STRING 3X,CDNAME,1X,(CDENTPT,,X),3X,(CDATTRB,,X),2X,          X\n               (CDSP,,X),2X,(CDATTR,,X),4X,(CDATTR2,,X),4X,(CDUSE,,X), X\n               13X,(XTLMSBLN,,X),3X,(XTLMSBAD,,X),INTO=LINE\n         B     JPAQ29\nJPAQ25   STRING 3X,CDNAME,1X,(CDENTPT,,X),3X,(CDATTRB,,X),6X,          X\n               (CDATTR,,X),4X,(CDATTR2,,X),11X,(CDNAME-CDENTRY(R6),8), X\n               INTO=LINE\nJPAQ29   BAL   R14,SPACE0              NEXT LINE\n         ICM   R5,B'1111',CDCHAIN      CHECK FOR END OF CHAIN\n         BNZ   JPAQ21                  LOOP THROUGH RB TABLE\n*-> end LOOP\n         DROP  R5,R6\n         BAL   R14,SPACE1              BLANK LINE\n         STRING '   ATTRB: 80-EOM      40-IDENTY 20-DIRTY         ',   X\n               '08-LPDE      04-GLOBAL 02-CONTAMINATION 01-RACF',      X\n               INTO=LINE\n         BAL   R14,SPACE0              NEXT LINE\n         STRING '    ATTR: 80-NIP/MLPA 40-NIC    20-RENT  10-REUS ',   X\n               '08-NREUS     04-MINOR  02-JPAQ          01-NOT_OL',    X\n               INTO=LINE\n         BAL   R14,SPACE0              NEXT LINE\n         STRING '   ATTR2: 80-SP0      40-REL    20-XLE   10-RLC  ',   X\n               '08-AMODE_ANY 04-OVLY   02-APFLIB        01-AC=1',      X\n               INTO=LINE\n         BAL   R14,SPACE2              BLANK LINE\n         END_PROC\n         DROP  R12                     END_PROC\n         EJECT\n*======================================================================\n*        DISPLAY LOAD-LISTS\n*----------------------------------------------------------------------\nLOADLIST BEGIN_PROC\n         L     R9,JSTCB                THE JOB STEP TCB\n         STRING 'LOAD list:',INTO=LINE\n         LA    R2,LINE+1(R15)\n         BAL   R14,SPACE0              NEXT LINE\n         SLR   R3,R3                   INDENTATION INDEX\n*\n*        Tally allocated storage\n*\n*-> LOOP (1)\nLOADL11  BAL   R14,SPACE1\n*\n*        Get name of current program\n*\n         L     R5,TCBRBP               TOP RB\n         USING RBBASIC,R5\nLOADL26  TM    RBCDFLGS,RBCDSYNC       THIS RB CREATED BY SYNCH?\n         BO    LOADL26I                YES, JUMP\n         TM    RBSTAB1,RBFTSVRB        IS THIS AN SVRB?\n         BNO   LOADL27                 NO, JUMP\n*        #SNAP ADDR=RBBASIC,LENGTH=44                            <SNAP>\nLOADL26I ICM   R5,B'0111',RBLINK+1     POINT TO PREVIOUS RB\n*        #SNAP ADDR=RBBASIC,LENGTH=44                            <SNAP>\n         B     LOADL26                 TEST SYNCH FLAG AGAIN\nLOADL27  L     R5,RBCDE                POINT TO CDE/LPDE\n         USING CDENTRY,R5\n         STCM  R9,B'0111',WKCELL1      STORE TCB ADDR\n         STRING '  TCB: ',(WKCELL1,3,X),'   Program: ',CDNAME,INTO=LINE\n         BAL   R14,SPACE2\n*\n*        Display load-list\n*\n         ICM   R4,B'1111',TCBLLS       POINT TO LAST LLE IN CHAIN\n         BZ    LOADL80                 SKIP THIS TCB IF NO LLE CHAIN\n         USING LLE,R4\n*-> LOOP (2)\nLOADL70  STCM  R4,B'0111',WKCELL1      STORE LLE ADDR\n         L     R5,LLECDPT              CDE PTR\n         TM    CDATTR,CDMIN            CHECK ATTRIBUTES\n         BNO   LOADL72                 JUMP IF THIS IS A MAJOR CDE\n         L     R5,CDXLMJP              POINT TO MAJOR CDE\nLOADL72  L     R6,CDXLMJP              POINT TO XL\n         USING XTLST,R6\n         TM    CDATTRB,CDELPDE         CHECK ATTRIBUTES\n         BO    LOADL75                 JUMP IF THIS IS A LPA MODULE\n         STRING 3X,CDNAME,1X,(CDENTPT,,X),3X,(CDATTRB,,X),2X,          X\n               (CDSP,,X),2X,(CDATTR,,X),4X,(CDATTR2,,X),4X,            X\n               (LLECOUNT,,X),3X,(LLESYSCT,,X),6X,                      X\n               (XTLMSBLN,,X),3X,(XTLMSBAD,,X),INTO=LINE\n         B     LOADL79\n         USING LPDE,R5\nLOADL75  STRING 3X,LPDENAME,1X,(LPDENTP,,X),3X,(LPDEATTB,,X),2X,       X\n               (LPDESP,,X),2X,(LPDEATTR,,X),4X,(LPDEATT2,,X),4X,       X\n               (LLECOUNT,,X),3X,(LLESYSCT,,X),6X,                      X\n               (LPDEXTLN+1,3,X),3X,(LPDEXTAD,,X),INTO=LINE\nLOADL79  BAL   R14,SPACE0              NEXT LINE\n         ICM   R4,B'1111',LLECHN       CHECK FOR END OF CHAIN\n         BNZ   LOADL70                 LOOP THROUGH LOAD LIST\n*-> end LOOP (2)\nLOADL80  BAL   R14,SCANTCB             NEXT TCB IN TREE\n         BNZ   LOADL11\n*-> end LOOP (1)\n         END_PROC\n         DROP  R4,R5,R6\n         DROP  R12                     END_PROC\n         DROP  R9                      TCB ****************************\n         EJECT\n*======================================================================\n*        INVOKE ISPF/PDF \"BRIF\" SERVICE\n*----------------------------------------------------------------------\nBRIF     BEGIN_PROC\n         LA    R0,LINES                FIRST LINE\n         LR    R1,R10                  LAST LINE\n         SR    R1,R0                   SIZE\n         SR    R0,R0\n         D     R0,=A(L'LINE)           NUMBER OF LINES\n         ST    R1,NUMLINES             FOR BRIF\n         AIF   (NOT D'DFASMS).SMS1     NOT DFP V3, JUMP\n*\n*        Free the unused part of the working-storage area\n*        (reserve an additional 4K for the DEVSTAT routine).\n*\n         LA    R1,LINE+4095            4K work area\n         N     R1,=F'-4096'            ROUND UP\n         ST    R1,WORK4K               save address for DEVSTAT rtne\n         A     R1,=H'4096'             leave room for a 4K work area\n         CL    R1,DYN_CHK              end of work area overflow?\n         BL    BRIF100                 no, OK\n         L     R1,=A(WTOSK4)           yes, signal shortage\n         WTO   MF=(E,(1))\n         OI    FSWITCH,ERRBRIF\n         B     BRIF900                 QUIT\nBRIF100  L     R2,DYNAML2              LENGTH OF DYNAMIC STORAGE AREA\n         LA    R2,DYNAM(R2)            END OF DYNAMIC STORAGE AREA\n         SR    R2,R1                   LENGTH OF UNUSED STORAGE\n         FREEMAIN RU,LV=(R2),A=(R1)    FREE UNUSED STORAGE\n         SLR   R1,R13                  LENGTH OF STORAGE USED\n         ST    R1,DYNAML2              STORE IT FOR NEXT FREEMAIN\n.SMS1    TM    FSWITCH,HARDCOPY        Is this a hardcopy run?\n         BO    BRIF300                 YES, JUMP\n*\n*        ATTACH the LOCATE/OBTAIN SUB-TASK\n*\n         MVC   ENQL1(ENQL1L),ENQM1     MODEL ENQ TO DYNAMIC STRGE  @364\n         L     R2,PSATOLD-PSA          my TCB                      @380\n         L     R2,TCBRBP-TCB(,R2)      my PRB                      @380\n         L     R2,RBCDE-RBBASIC(,R2)   my CDE/LPDE                 @380\n         XC    ECB1(2*L'ECB1),ECB1     clear ECB,TCB\n         LA    R1,SUB_WORK             PARM for sub task\n         LNR   R1,R1                   make it negative            @380\n         ATTACH EPLOC=CDNAME-CDENTRY(R2),   my own name            @380X\n               SZERO=NO,SF=(E,ATTACHL1)\n         LTR   R15,R15                 successful completion?      EU13\n         BZ    BRIF200                 yes                         EU13\n         L     R1,=A(WTOSK7)           no, diagnose error\n         MVC   WK256(WTOSK7L),0(R1)\n         CVD   R15,WKCELL1\n         MVC   WKCELL1(4),=X'40202120'\n         ED    WKCELL1(4),WKCELL1+L'WKCELL1-2\n         MVC   WK256+WTOSK7C(L'WTOSK7C),WKCELL1\n         WTO   MF=(E,WK256)\n         OI    FSWITCH,ERRBRIF\n         B     BRIF900                 QUIT\nBRIF200  ST    R1,ECB1+4               SAVE TCB ADDRESS\n         LA    R0,DYNAM                DIALOG DATA addr\n         ST    R0,WKWORDS+32           DIALOG DATA PTR\n         XCALL ISPLINK,(=CL8'BRIF',    ISPF function                   X\n               TITLE,                  data-name (dsname)              X\n               =C'F ',                 rec-format                      X\n               =A(L'LINE),             rec-len                         X\n               =A(RDRTNE),             read-routine                    X\n               0,                      cmd-routine address             X\n               WKWORDS+32),            dialog-data                     X\n               ERRET=BRIF212           in case of a problem        EU13\nBRIF210  ENQ   (EDQNAME,EDRNAME,E,L'EDRNAME),                      @364X\n               MF=(E,ENQL1)            SERIALIZE DETACH            EU15\n         TM    ECB1,X'40'              SUB TASK ENDED ALREADY?     @364\n         BO    BRIF211                 YES, EXIT                   @364\n         DETACH ECB1+4                 DETACH IT                   @364\nBRIF211  DEQ   MF=(E,ENQL1)            DE-SERIALIZE DETACH         @364\n         B     BRIF900                 EXIT                        @364\nBRIF212  TM    FSWITCH,FLGNOMSG        NOMSG flag (debug)          EU18\n         BO    BRIF210                 skip diagnose               EU18\n         L     R1,=A(WTOSK2)           diagnose error\n         MVC   WK256(WTOSK2L),0(R1)\n         MVC   WK256+WTOSK2N(L'WTOSK2N),=CL8'BRIF'\n         CVD   R15,WKCELL1\n         MVC   WKCELL1(4),=X'40202120'\n         ED    WKCELL1(4),WKCELL1+L'WKCELL1-2\n         MVC   WK256+WTOSK2R(L'WTOSK2R),WKCELL1\n         WTO   MF=(E,WK256)\n         OI    FSWITCH,ERRBRIF\n         B     BRIF210\nENQM1    ENQ   (*-*,*-*,E,0),MF=L                                  @364\n*                                                                  EU13\n*        Execute the SUB-TASK as a subroutine                      EU13\n*                                                                  EU13\nBRIF300  LA    R1,SUB_WORK             PARM for sub task           EU13\n         LNR   R1,R1                   make it negative as needed  EU13\n         MVI   ECB1+7,X'FF'            mark as routine called      EU13\n         L     R15,=A(SUB_RTNE)        get SUB_TASK routine entry  EU13\n         BALR  R14,R15                 go there                    EU13\n*\n*        Write lines to DD=SHOWMVS or DD=dyn.alloc.                EU13\n*\n         GETMAIN R,LV=DYNAM24L         GET 24-BIT WORK AREA\n         LR    R7,R1\n         USING DYNAM24,R7\n         LA    R0,CODE24M              MOVE 24-BIT CODE MODEL\n         L     R1,=A(CODE24L)\n         LA    R14,CODE24\n         LR    R15,R1\n         MVCL  R14,R0\n         TM    FSWITCH,TSORUN          are we under TSO?           EU13\n         BO    *+L'*+10                yes                         EU13\n         MVC   DCB24+(DCBDDNAM-IHADCB)(L'MY_DDN),MY_DDN            EU13\n         B     *+L'*+6                                             EU13\n         MVC   DCB24+(DCBDDNAM-IHADCB)(L'RT_DDN),RT_DDN            EU13\n         LA    R1,SYNAD24              set SYNAD address\n         ST    R1,DCB24+(DCBSYNAD-IHADCB)\n         MVI   WTO24T,0                set indicator\n         LA    R1,XLST24               set DCB exit list address\n         STCM  R1,B'0111',DCB24+(DCBEXLSA-IHADCB)\n         LA    R1,XDCB24               set DCB exit address\n         STCM  R1,B'0111',XLST24+1\n         OPEN  (DCB24,OUTPUT),MF=(E,OPEN24)\n         LTR   R15,R15                 how about OPEN RC?\n         BZ    BRIF301                 ok\n         L     R1,=A(WTOSK8)           diagnose error\n         MVC   WK256(WTOSK8L),0(R1)\n         CVD   R15,WKCELL1\n         MVC   WKCELL1(4),=X'40202120'\n         ED    WKCELL1(4),WKCELL1+L'WKCELL1-2\n         MVC   WK256+WTOSK8C(L'WTOSK8C),WKCELL1\n         WTO   MF=(E,WK256)\n         OI    FSWITCH,ERRBRIF\n         B     BRIF420\nBRIF301  TM    DCB24+(DCBOFLGS-IHADCB),DCBOFOPN successfully complete?\n         BO    BRIF302                 ok\n         L     R1,=A(WTOSK9)           it's not opened\n         WTO   MF=(E,(1))\n         OI    FSWITCH,ERRBRIF\n         B     BRIF420\nBRIF302  CLI   XERR24C,0               all ok?\n         BE    BRIF303                 yes, continue\n         XR    R3,R3                   no, give error message\n         IC    R3,XERR24C\n         BCTR  R3,0\n         SLL   R3,2\n         L     R1,BRIFEMV(R3)\n         WTO   MF=(E,(1))\n         OI    FSWITCH,ERRBRIF\n         B     BRIF400\nBRIF303  LA    R3,1                    LINE COUNT (for page eject)\n         LA    R4,1                    record count\n*-> LOOP\nBRIF310  ST    R4,WKCELL2              relative record number      EU13\n         ST    R13,WKCELL3             data area for read routine\n         XCALL =A(RDRTNE),             BRIF READ ROUTINE               X\n               (WKCELL1,               addr of record                  X\n               =A(L'LINE),             LRECL                           X\n               WKCELL2,                RRN                             X\n               WKCELL3),               DYNAM-DATA                      X\n               ERRET=BRIF400           end-of-data\n         LA    R15,CODE24              24-BIT CODE                 EU13\n         BASSM R2,R15                  EXECUTE 24-BIT CODE         EU13\n         CLI   WTO24T,0                PUT error occurred?         EU13\n         BNE   BRIF360                 yes                         EU13\n         LR    R5,R1                   save line address           EU13\n*        TM    WORK4K,X'F0'                                        ****\n*        BZ    *+L'*+4                                             ****\n*        EX    0,*                                                 ****\n         L     R10,WKCELL1             A(LINE)\n         CL    R10,TLNEPT              first (TITLE) line?         EU15\n         BNE   BRIF312                 no, jump                    EU15\n         MVI   0(R5),C'1'              ASA control                 EU15\nBRIF311  MVC   1(L'LINE,R5),LINE       move current line to buffer EU15\n         BAL   R14,BRIF350             go set page number          EU15\n         B     BRIF316                                             EU15\nBRIF312  CLI   LINE,C' '               IS THIS A NEW SECTION?\n         BE    BRIF313                 NO, JUMP\n         CH    R3,=H'6'                AT LEAST 6 LINES LEFT?\n         BNH   BRIF314                 NO, NEW PAGE\nBRIF313  BCT   R3,BRIF315              DECREMENT LINE COUNT\nBRIF314  TM    CURPGN,X'40'                                        EU15\n         BO    BRIF311                                             EU15\n         MVI   0(R5),C'1'              ASA control                 EU15\n         L     R14,TLNEPT              get TITLE line pointer      EU15\n         MVC   1(L'LINE,R5),0(R14)     move TITLE line to buffer   EU15\n         BAL   R14,BRIF350             go set page number          EU15\n         LA    R15,CODE24              24-BIT CODE                 EU15\n         BASSM R2,R15                  EXECUTE 24-BIT CODE         EU15\n         CLI   WTO24T,0                PUT error occurred?         EU15\n         BNE   BRIF360                 yes                         EU15\n         LR    R5,R1                   save line address           EU15\n         MVI   0(R5),C' '              ASA control                 EU15\n         MVC   1(L'LINE,R5),BLANKS     move SPACE line to buffer   EU15\n         LA    R15,CODE24              24-BIT CODE                 EU15\n         BASSM R2,R15                  EXECUTE 24-BIT CODE         EU15\n         CLI   WTO24T,0                PUT error occurred?         EU15\n         BNE   BRIF360                 yes                         EU15\n         LR    R5,R1                   save line address           EU15\n         BCTR  R3,0                    minus 2 lines               EU15\n         BCTR  R3,0                                                EU15\nBRIF315  MVI   0(R5),C' '              ASA control                 EU15\n         MVC   1(L'LINE,R5),LINE       move current line to buffer EU15\nBRIF316  LA    R4,1(,R4)               BUMP LINE counter\n         B     BRIF310                 NEXT LINE\n*-> end LOOP\nBRIF350  TM    CURPGN,X'40'                                        EU15\n         BO    BRIF351                                             EU15\n         L     R3,CURPGN               current page routine        EU15\n         CVD   R3,WKCELL2              edit current page count     EU15\n         MVC   PGNEPT(L'PGNEPT,R5),=XL6'402020202120'              EU15\n         ED    PGNEPT(L'PGNEPT,R5),WKCELL2+L'WKCELL2-3             EU15\n         A     R3,=F'1'                update current page count   EU15\n         ST    R3,CURPGN                                           EU15\nBRIF351  L     R3,MAXLPG               Max. lines per page         EU15\n         BR    R14                     return                      EU15\nBRIF360  LA    R1,WTO24                PUT error message\n         WTO   MF=(E,(1))\n         OI    FSWITCH,ERRBRIF\nBRIF400  CLOSE MF=(E,OPEN24)\n         LTR   R15,R15                 how about CLOSE RC?\n         BZ    BRIF410                 ok\n         L     R1,=A(WTOSK10)          diagnose error\n         MVC   WK256(WTOSK10L),0(R1)\n         CVD   R15,WKCELL1\n         MVC   WKCELL1(4),=X'40202120'\n         ED    WKCELL1(4),WKCELL1+L'WKCELL1-2\n         MVC   WK256+WTOSK10C(L'WTOSK10C),WKCELL1\n         WTO   MF=(E,WK256)\n         OI    FSWITCH,ERRBRIF\nBRIF410  FREEPOOL DCB24\nBRIF420  FREEMAIN R,LV=DYNAM24L,A=(R7) FREE 24-BIT WORK AREA\n         DROP  R7\nBRIF900  XR    R15,R15                 set RC=0\n         TM    FSWITCH,ERRBRIF\n         BZ    BRIF999\n         LA    R15,16                  pass back RC for error\nBRIF999  END_PROC\nBRIFEMV  DC    A(WTOSK12,WTOSK13,WTOSK14,WTOSK15)\n*----------------------------------------------------------------------\n*        RMODE24 PUT Routine (24-bit code model)\n*----------------------------------------------------------------------\n         CNOP  0,4\nCODE24M  ST    R13,4(,R7)              24-BIT SAVE AREA\n         LR    R13,R7                  24-BIT SAVE AREA\n         LA    R1,DCB24-CODE24(,R15)   GET DCB ADDRESS\n         PUT   (1)                     PUT LOCATE\n         L     R13,4(,R13)             31-BIT SAVE AREA\n         BSM   0,R2                    GOBACK WITH AMODE31\n         CNOP  0,4\nSYNAD24M STM   R13,R2,SAVE24(R15)      save registers\n         LR    R2,R15                  use as base\n         USING SYNAD24M,R2\n         SYNADAF ACSMETH=QSAM          get error message from OS\n         MVC   WTO24M(L'WTO24M,R2),68(R1) get usefull text\n         SYNADRLS                      free OS message\n         DROP  R2\n         LM    R13,R2,SAVE24(R2)       restore registers\n         BR    R14                     return\n         OPEN  (*-*,OUTPUT),MF=L\n         DC    0F'0',XL1'85',AL3(*-*)  DCB exit list\n         USING IHADCB,R1\n         USING XDCB24M,R15\nXDCB24M  XR    R0,R0\n         ICM   R0,B'0011',DCBLRECL     get LRECL\n         BZ    *+L'*+14                branch if undefined\n         CLM   R0,B'0011',XLRL24(R15)  LRECL= as needed?\n         BE    *+L'*+6                 yes\n         MVI   XERR24(R15),1           no, set error 1\n         BR    R14                     return\n         TM    DCBRECFM,DCBRECV        RECFM= V or U?\n         BZ    *+L'*+6                 no\n         MVI   XERR24(R15),2           yes, set error 2\n         BR    R14                     return\n         TM    DCBRECFM,DCBRECF        RECFM= F?\n         BO    *+L'*+4                 yes\n         OI    XREC24(R15),DCBRECF     no, set it\n         TM    DCBRECFM,DCBRECCM       CC= Machine defined?\n         BZ    *+L'*+6                 no\n         MVI   XERR24(R15),3           yes, set error 3\n         BR    R14                     return\n         TM    DCBRECFM,DCBRECCA       CC= ASA defined?\n         BO    *+L'*+4                 yes\n         OI    XREC24(R15),DCBRECCA    no, set it\n         TM    DCBRECFM,DCBRECBR       Blocked records?\n         BZ    ZDCB24M                 no\n         LH    R0,DCBBLKSI             get BLKSIZE\n         SH    R0,XLRL24(R15)          is it a multiple?\n         BP    *-4                     continue check\n         BZ    ZDCB24M                 yes\n         MVI   XERR24(R15),4           no, set error 4\n         BR    R14                     return\nZDCB24M  MVC   DCBLRECL,XLRL24(R15)    complete DCB\n         OC    DCBRECFM,XREC24(R15)\n         BR    R14                     return\n         DC    Y(L'LINE+1)\n         DC    AL1(0)\n         DC    AL1(0)\n         DROP  R1,R15\n         DCB   DSORG=PS,MACRF=PL,DDNAME=XXXXXXXX                   EU13\n         DC    6F'0'                   save registers\n         WTO   '-- PUT error :                                         X\n                                   ',ROUTCDE=11,DESC=7,MF=L\n         DROP  R12                     END_PROC\n         EJECT\n*========================== general routines ==========================\n$LTORG   LOCTR\n*----------------------------------------------------------------------\n*        GET A WORK AREA SPACE\n*----------------------------------------------------------------------\nWORKADDR L     R1,DYN_CHK              POINT TO END OF WORK AREA\n         SLR   R1,R0                   POINT TO WORK AREA\n         N     R1,=F'-32'              ALIGN ADDRESS\n         CLR   R1,R10                  CHECK AGAINST CURRENT POINTER\n         BNH   SPERR\n         XC    0(256,R1),0(R1)         CLEAR BEGINNING TO X'00'\n         BR    R14\n*----------------------------------------------------------------------\n*        PRINT A BLANK LINE\n*----------------------------------------------------------------------\nSPACE2   LA    R10,NEXTLINE\n         CL    R10,DYN_CHK\n         BNL   SPERR\nSPACE1   MVC   LINE,BLANKS\nSPACE0   LA    R10,NEXTLINE\n         CL    R10,DYN_CHK\n         BLR   R14\n         B     SPERR\nCHECK0   LA    R0,NEXTLINE\n         CL    R0,DYN_CHK\n         BLR   R14\nSPERR    TM    FSWITCH,DYNSHORT        already occured?\n         BO    SPEX                    yes\n         OI    FSWITCH,DYNSHORT        no, remember it\n         L     R1,=A(WTOSK5)           and signal shortage\n         WTO   MF=(E,(1))\nSPEX     L     R14,END_PROC            return address\n         BR    R14                     abort remaining processing\n*----------------------------------------------------------------------\n*ITLE    DC    C'SHOWMVS',X'00',C'PROGRAM',X'00',C'&VERMOD '       ****\n*ITLE    DC    C'TCN/AMS',X'00',C'UTILITIES',X'006000'\n*        DC    C'SHOWMVS',X'00',C'&VERMOD '\nTITLE    DC    C'TCN/AMS Utilities - SHOWMVS &VERMOD '             EU15\nTITLE_L  EQU   *-TITLE\n*----------------------------------------------------------------------\n*        TRI DE LA TABLE APF-LIST\n*----------------------------------------------------------------------\nTRIZO    LA    R0,L'LINE               LONGUEUR D'UN POSTE\n         LR    R1,R10                  A(NEXTLINE)\n         SLR   R1,R0                   DERNIER POSTE DE LA TABLE\n         STM   R0,R1,4(R2)             LONGUEUR, DERNIER POSTE\n*-> LOOP (1)\nTRIZO1   MVI   0(R13),0                ETAT INITIAL DE L'INDICATEUR\n         L     R15,0(,R2)              DEBUT DE LA TABLE  N=1\n         USING LINE,R15\n         SLR   R1,R0                   LE DERNIER POSTE EST TRIE\n*-> LOOP (2)\nTRIZOC   CLC   DSNAME,DSNAME+L'LINE    (POSTE N) GT (POSTE N+1)?\n         BNH   TRIZOH                  SI NON, BRANCH\n         XC    LINE,NEXTLINE           SI (POSTE N+1) LT (POSTE N)\n         XC    NEXTLINE,LINE            INVERSER LES\n         XC    LINE,NEXTLINE             DEUX POSTES\n         MVI   0(R13),8                NOTER LE DECLASSEMENT\nTRIZOH   BXLE  R15,R0,TRIZOC           FAIRE N=N+1\n*-> end LOOP (2)\nTRIZON   CLI   0(R13),0                Y-A-T-IL EU UN DECLASSEMENT?\n         BNE   TRIZO1                  SI OUI, REFAIRE UN PASSAGE\n*-> end LOOP (1)\n         BR    R14                     GOBACK\n         DROP  R15\n*----------------------------------------------------------------------\n*        SCAN LPA QUEUES TO LOCATE EPNAME FOR ADDR IN (R1)\n*----------------------------------------------------------------------\nCSVQUERY MVC   EP10,BLANKS             CLEAR OUTPUT AREA\n         CL    R1,IGCERROR             THIS SVC USED?\n         BE    CSVQRY88                NO, GOBACK\n         LA    R1,0(,R1)               CLEAN-UP AMODE BIT\n         USING CVTMAP,R8\n*\n*        SCAN ACTIVE LPA QUEUE (MLPA/FLPA)\n*\n         L     R2,CVTQLPAQ             ACTIVE LPA QUEUE\n         ICM   R2,B'1111',0(R2)        FIRST LPDE ON QUEUE\n         BZ    CSVQRY20                EMPTY QUEUE, SKIP SEARCH\n         USING LPDE,R2\n         MVI   EP10,C'A'               ACTIVE LPA Q\n*-> LOOP\nCSVQRY11 L     R15,LPDENTP             ENTRY POINT\n         LA    R15,0(,R15)             CLEAN UP AMODE BIT\n         CR    R1,R15                  IS THIS MY ENTRY POINT?\n         BE    CSVQRY82                MODULE FOUND, JUMP\n         ICM   R2,B'1111',LPDECHN      NEXT LPDE ADDR\n         BNZ   CSVQRY11                NO FINISHED YET, LOOP FURTHER\n*-> end LOOP\n*\n*        SCAN PAGEABLE LPA QUEUE (PLPA)\n*\nCSVQRY20 L     R2,CVTLPDIA             FIRST LPDE\n         USING LPDE,R2\n         MVI   EP10,C'P'               PAGEABLE LPA Q\n*-> LOOP\nCSVQRY21 L     R15,LPDENTP             ENTRY POINT\n         LA    R15,0(,R15)             CLEAN UP AMODE BIT\n         CR    R1,R15                  IS THIS MY ENTRY POINT?\n         BE    CSVQRY82                MODULE FOUND, JUMP\n         TM    LPDEATTR,LPDEMIN        MINOR LPDE?\n         BO    CSVQRY22                YES, IGNORE\n         LM    R15,R0,LPDEXTLN         LENGTH/LOAD ADDR\n         CR    R0,R1\n         BH    CSVQRY22                OUTSIDE BOUNDARIES, JUMP\n         AR    R0,R15\n         CR    R0,R1\n         BH    CSVQRY82                MODULE FOUND, JUMP\nCSVQRY22 LA    R2,LPDEXTAD+4           BUMP LPDE ADDR\n         CLI   LPDENAME,X'FF'          END OF LPA DIRECTORY?\n         BNE   CSVQRY21                NO, LOOP FURTHER\n*-> end LOOP\n         MVI   EP10,C'N'               NUCLEUS\n*        MVC   EP10+2(4),=C'*NUC'      EP FOUND IN THE NUCLEUS     @380\n         STM   R14,R1,WKWORDS          save registers              @380\n         LA    R0,0(,R1)               pass address                @380\n         NUCLKUP BYADDR,ADDR=(0),NAME=EP10+2                       @380\n         LTR   R15,R15                 FOUND?                      @380\n         LM    R14,R1,WKWORDS          restore registers           @380\n         BZR   R14                     yes, goback                 @380\n         L     R2,CVTSMEXT             STORAGE MAP EXTENSION\n         USING CVTVSTGX,R2\n*        CL    R1,CVTRWNS              NUC?                        @380\n*        BL    CSVQRY61                NO, JUMP                    @380\n*        CL    R1,CVTERWNE             NUC?                        @380\n*        BLR   R14                     YES, GOBACK                 @380\nCSVQRY61 MVC   EP10+2(8),=C'*FLPA   '  EP FOUND IN FIXED LPA\n         MVI   EP10,C'F'               FIXED LPAQ\n         CL    R1,CVTFLPAS             FLPA (BELOW)\n         BL    CSVQRY62                NO, JUMP\n         CL    R1,CVTFLPAE             END OF FLPA (BELOW)\n         BLR   R14                     YES, GOBACK\nCSVQRY62 CL    R1,CVTEFLPS             FLPA (ABOVE)\n         BL    CSVQRY63                NO, JUMP\n         CL    R1,CVTEFLPE             END OF FLPA (ABOVE)\n         BLR   R14                     YES, GOBACK\nCSVQRY63 MVC   EP10+2(5),=C'*MLPA'     EP FOUND IN FIXED LPA\n         MVI   EP10,C'F'               MODIFIED LPAQ\n         CL    R1,CVTMLPAS             MLPA (BELOW)\n         BL    CSVQRY64                NO, JUMP\n         CL    R1,CVTMLPAE             END OF MLPA (BELOW)\n         BLR   R14                     YES, GOBACK\nCSVQRY64 CL    R1,CVTEMLPS             MLPA (ABOVE)\n         BL    CSVQRY71                NO, JUMP\n         CL    R1,CVTEMLPE             END OF MLPA (ABOVE)\n         BLR   R14                     YES, GOBACK\nCSVQRY71 L     R2,CVTGDA               POINT TO GDA\n         USING GDA,R2\n         MVC   EP10+2(5),=C'*CSA '     EP FOUND IN CSA\n         MVI   EP10,C'C'               CSA\n         L     R0,GDACSA               CSA (BELOW)\n         CLR   R1,R0                   WITHIN CSA?\n         BL    CSVQRY72                NO, JUMP\n         AL    R0,GDACSASZ             END OF CSA (BELOW)\n         CLR   R1,R0                   WITHIN CSA?\n         BLR   R14                     YES, GOBACK\nCSVQRY72 L     R0,GDAECSA              CSA (ABOVE)\n         CLR   R1,R0                   WITHIN CSA?\n         BL    CSVQRY73                NO, JUMP\n         AL    R0,GDAECSAS             END OF CSA (ABOVE)\n         CLR   R1,R0                   WITHIN CSA?\n         BLR   R14                     YES, GOBACK\nCSVQRY73 MVC   EP10,BLANKS             RETURN BLANK NAME\n         BR    R14\n         USING LPDE,R2\nCSVQRY82 MVC   EP10+2(8),LPDENAME      PASS EP NAME\n         BR    R14\n         DROP  R2,R8\nCSVQRY88 MVI   EP10,C'-'               SVC IS NOT IN SERVICE\n         BR    R14\n*----------------------------------------------------------------------\n*        CONVERT UCBTYP TO UNITNAME\n*----------------------------------------------------------------------\nGETUNIT  CLC   UNITNAME+12(4),UNITNAME+8   SAME DEVICE TYPE?\n         BER   R14                     YES, UNITNAME IS OK ALREADY\n         MVC   UNITNAME+12(4),UNITNAME+8   SAVE DEVICE TYPE\nGETUNIT2 ST    R14,DYNAM               SAVE R14\n         XCALL IEFEB4UV,                                               X\n               (UNITNAME,              work area                       X\n               =X'0100'),              function flags  \"7\"             X\n               ERRET=GETUNIT6\n         XCALL IEFEB4UV,                                               X\n               (UNITNAME,              work area                       X\n               =X'2000')               function flags  \"2\"\n         LTR   R15,R15\n         BZ    GETUNIT9                GOOD RETURN CODE, GOBACK\nGETUNIT6 MVC   UNITNAME,BLANKS         CONVERSION DID NOT WORK\nGETUNIT9 L     R14,DYNAM               RESTORE R14\n         BR    R14\n*----------------------------------------------------------------------\n*        TCB TREE SCAN SOUTINE\n*----------------------------------------------------------------------\nSCANTCB  LR    R1,R9                   SAVE TCB ADDRESS\n         L     R9,TCBLTC-TCB(,R9)      DAUGHTER\n         LA    R3,1(,R3)               INDENTATION INDEX\n*-> LOOP\nSCANTCB2 LTR   R9,R9                   CHECK FOR END OF CHAIN\n         BNZR  R14                     PASS VALID TCB ADDRESS\n         L     R9,TCBNTC-TCB(,R1)      SISTER\n         L     R1,TCBOTC-TCB(,R1)      MOTHER\n         BCT   R3,SCANTCB2             INDENTATION INDEX\n*-> end LOOP\n         SR    R9,R9                   SET CC=0\n         BR    R14                     GOBACK\n*----------------------------------------------------------------------\n*        TABLE SCAN ROUTINES\n*----------------------------------------------------------------------\n*-> LOOP\nSCAN_TM  IC    R15,0(,R1)              PICK UP MASK FOR \"TM\"\n         EX    R15,2(,R14)             EXECUTE TM UNSTRUCTION\n         BO    6(,R14)                 FOUND, GOBACK\n         AH    R1,0(,R14)              BUMP TABLE PTR\n         CLI   0(R1),0                 END OF TABLE?\n         BNE   SCAN_TM                 NEXT TABLE ENTRY\n*-> end LOOP\n         LA    R1,BLANKS               ALL BLANKS\n         LTR   R1,R1                   SET CC TO 'Z'\n         B     6(,R14)                 NOT FOUND, GOBACK\n*-> LOOP\nSCAN_CLI IC    R15,0(,R1)              PICK UP MASK FOR \"TM\"\n         EX    R15,2(,R14)             EXECUTE CLI UNSTRUCTION\n         BE    6(,R14)                 FOUND, GOBACK\n         AH    R1,0(,R14)              BUMP TABLE PTR\n         CLI   0(R1),0                 END OF TABLE?\n         BNE   SCAN_CLI                NEXT TABLE ENTRY\n*-> end LOOP\n         LA    R1,BLANKS               ALL BLANKS\n         SR    R15,R15                 SET CC TO 'NE'\n         B     6(,R14)                 NOT FOUND, GOBACK\n*\n*        Define the DFA map (Data Facilities area).\n*\n*        The DFP V3 version of this macro defines the\n*        DFASMS symbol.  The existence of DFASMS is\n*        tested in the DEVSTAT routine to generate\n*        SMS-dependent code and macros.\n*\n         PUSH  PRINT\n         PRINT NOGEN\n         IHADFA  DSECT=YES             DFP AREA\n         POP   PRINT\n$FARRTNE LOCTR\n*----------------------------------------------------------------------\n*        SNAP ROUTINE    R0=LENGTH,R1=ADDRESS\n*----------------------------------------------------------------------\n         USING SNAP00,R3\nSNAP00   SLR   R15,R15                 offset=0000\n         STM   R14,R15,SNAPREGS+24     return address/offset\n         STRING '0-3 ',(SNAPREGS+08,4,X),1X,(SNAPREGS+12,4,X),         X\n               1X,(SNAPREGS+16,4,X),1X,(SNAPREGS+20,4,X),              X\n               '  4-7 ',((R4),,X),1X,((R5),,X),                        X\n               1X,((R6),,X),1X,((R7),,X),INTO=LINE\n         BAL   R14,SPACE0          <== next line\n         STRING '8-B ',((R8),,X),1X,((R9),,X),1X,((R10),,X),           X\n               1X,((R11),,X),'  C-F ',((R12),,X),1X,((R13),,X),        X\n               1X,(SNAPREGS+00,4,X),1X,(SNAPREGS+04,4,X),INTO=LINE\n         BAL   R14,SPACE0          <== next line\n*-> LOOP\nSNAP10   L     R14,SNAPREGS+24         return address\n         LTR   R0,R0                   # of remaining bytes\n         BNPR  R14                     finished, QUIT\n         STRING '  +',(SNAPREGS+30,2,X),1X,((R1),,X),3X,36X,'   *',    X\n               16X,'*',INTO=LINE\n         LA    R14,16                  # of bytes on a line\n         AL    R14,SNAPREGS+28         increment offset\n         ST    R14,SNAPREGS+28         increment offset\n         LA    R14,16                  # of chars on a line\n         CLR   R14,R0                  is this a short line?\n         BL    *+L'*+2                 no, jump\n         LR    R14,R0                  truncate last line\n         BCT   R14,*+L'*+6             FOR EX\n         MVC   LINE+59(*-*),0(R1)      <<EXECUTED>>\n         EX    R14,*-6                 MOVE FIELD\n         TR    LINE+59(16),TRTPRINT\n         LA    R2,LINE+19              start of hex data\n         BAL   R14,SNAP90              edit 4 bytes\n         BAL   R14,SNAP90              edit 4 bytes\n         LA    R2,1(,R2)               2-byte margin\n         BAL   R14,SNAP90              edit 4 bytes\n         BAL   R14,SNAP90              edit 4 bytes\n         BAL   R14,SPACE0          <== next line\n         B     SNAP10                  snap next line\n*-> end LOOP\nSNAP90   LTR   R0,R0                   # OF REMAINING BYTES\n         BNPR  R14                     FINISHED, QUIT\n         UNPK  0(9,R2),0(5,R1)         translate to hex\n         L     R15,=A(@STRHEXT-240)    (from STRING macro)\n         TR    0(8,R2),0(R15)          translate to hex\n         SH    R0,=H'4'                decrement length\n         LA    R1,4(,R1)               ptr in input area\n         MVI   8(R2),C' '\n         LA    R2,9(,R2)               ptr in output line\n         BR    R14\n         DROP  R3\n         DROP  ,  -------------------- all registers killed -----------\n         EJECT\n*======================================================================\n*        BRIF READ ROUTINE\n*----------------------------------------------------------------------\n*\n*        This routine is invoked by BRIF and returns the address\n*        of a record.  BRIF invokes it each time the line is\n*        displayed on the screen, i.e when you scroll UP, DOWN,\n*        LEFT, RIGHT, or simply hit ENTER.\n*\n*        It also provides real-time status for on-line devices.\n*\nRDRTNE   SAVE  (14,12),,*\n         BALR  R12,0\n         USING *,R12\n         L     R6,00(,R1)              RECORD DATA READ\n*        L     R3,04(,R1)              LENGTH                      ****\n         L     R4,08(,R1)              RELATIVE RECORD NUMBER\n         L     R5,12(,R1)              PTR TO DIALOG DATA AREA\n         L     R5,0(,R5)               POINT TO DYNAMIC STORAGE AREA\n         USING DYNAM,R5\n         L     R11,BASEREG             BASE REGISTER\n         USING BASEADDR,R11\n         L     R1,0(,R4)               LINE NUMBER REQUESTED BY BRIF\n         C     R1,NUMLINES             CHECK FOR END OF DATA\n         BH    RDRTN80                 JUMP IF TOO BIG\n         BCTR  R1,0                    DOWN BY 1\n         M     R0,=A(L'LINE)           OFFSET TO LAST LINE\n         LA    R10,LINES(R1)           CHANGE OFFSET TO ADDRESS\n         USING LINE,R10\n         CLI   LINE_UCB,00             refresh device status?\n         BNE   RDRTN70                 no, jump\n*\n*        refresh status for on-line devices\n*\n         ICM   R7,B'1111',LINE_UCB     A(UCBOB)\n         BZ    RDRTN70                 no, jump\n         USING UCBOB,R7\n         ST    R13,RCVYSAVE+4\n         LA    R13,RCVYSAVE            save area for IEFSSREQ & STRING\n         MVC   WK256(LINE_UCB-LINE),LINE  move first half of line\n         LA    R10,WK256               now point to modified line\n         LA    R4,LINE_UCB             message area\n         MVC   0(LINE+L'LINE-LINE_UCB,R4),BLANKS\n*\n*        show VOLSER (DASD/TAPE)\n*\n         CLI   UCBTBYT3,UCB3TAPE       TAPE?\n         BE    RDRTN20                 YES, JUMP\n         CLI   UCBTBYT3,UCB3DACC       DASD?\n         BE    RDRTN20                 YES, JUMP\n*\n*        Check for a system console\n*\n         LA    R4,8(,R4)               skip volser slot\n         CLI   UCBTBYT3,UCB3DISP       Display device (eg 3270)?\n         BNE   RDRTN50                 no, JUMP\n         STATUS UCBSTAT,UCBSYSR,'Console'\n         B     RDRTN50                 skip TAPE/DASD section\n*\n*        TAPE/DASD section\n*\nRDRTN20  CLI   UCBVOLI,C' '            VALID VOLSER?\n         BNH   RDRTN49                 NO, JUMP\n         MVC   0(6,R4),UCBVOLI         VOLSER FOR TAPE/DASD\n         LA    R4,8(,R4)               skip volser\n         CLI   UCBTBYT3,UCB3DACC       DASD?\n         BNE   RDRTN40                 NO, JUMP\n         STATUS UCBSTAT,UCBSYSR,'System'\n         AIF   (NOT D'DFASMS).SMS2     NOT DFP V3, JUMP\n*\n*        GET SMS status and storage group\n*        This section is only generated if you assemble the\n*        program with a DFP V3 MACLIB.\n*\n         TM    UCBFL5,UCBSMS           SMS-managed volume?\n         BZ    RDRTN40                 no, jump\n         L     R1,WORK4K               point to the 4K work area\n         USING SSOB,R1\n         XC    SSOB(256),SSOB          clear working storage\n         LA    R0,SSOBHSIZ             BUILD SSOB\n         STH   R0,SSOBLEN              BUILD SSOB\n         MVC   SSOBID,=C'SSOB'         BUILD SSOB\n         LA    R0,SSOBSSMS             FUNCTION CODE 55\n         STH   R0,SSOBFUNC             BUILD SSOB\n         LA    R14,SSOB+SSOBHSIZ       POINT PAST SSOB HEADER\n         ST    R14,SSOBSSIB            STORE INTO SSOB\n         USING SSIB,R14\n         LA    R0,SSIBSIZE             BUILD SSIB\n         STH   R0,SSIBLEN              BUILD SSIB\n         MVC   SSIBID,=C'SSIB'         BUILD SSIB\n         MVC   SSIBSSNM,=C'SMS '       SUB-SYSTEM NAME\n         LA    R14,SSIB+SSIBSIZE       POINT PAST SSIB\n         ST    R14,SSOBINDV            FUNCTION-DEPENDENT AREA\n         USING IEFSSSA,R14\n         LA    R0,SSSALN+SSSA1LN       LENGTH\n         STH   R0,SSSALEN\n         MVC   SSSAID,=C'SSSA'         SSSA\n         MVI   SSSAVER+1,SSOBSSVR      VERSION\n         MVI   SSSASFN+1,SSSAACTV      SUB-FUNCTION CODE\n         MVI   SSSAIFLG,SSSANAUT       NON-AUTHORIZED CALLER\n         MVI   SSSA1TYP,SSSA1VOL       GIVE VOLSER, GET VLD BACK\n         MVI   SSSA1CNT+3,1            ONE CONSTRUCT PASSED\n         MVI   SSSA1NML+1,L'UCBVOLI    LENGTH OF NAME\n         MVC   SSSA1NAM(L'UCBVOLI),UCBVOLI  MOVE VOLUME SERIAL\n         LA    R2,SSSA+SSSALN+SSSA1LN  WORK AREA\n         ST    R2,SSSA1PTR             ADDR OF WORK AREA\n         LA    R0,1024                 LENGTH OF WORK AREA\n         ST    R0,SSSA1LEN             LENGTH OF WORK AREA\n         DROP  R1,R14\n*\n*        call SMS to get a VLD (Volume Record Descriptor)\n*\n         ST    R1,WKWORDS              BUILD SSOB_PTR\n         OI    WKWORDS,X'80'           BUILD SSOB_PTR\n         LA    R1,WKWORDS              SSOB_PTR\n         IEFSSREQ                  <== CALL SMS\n         LTR   R15,R15                 SSI OK?\n         BNZ   RDRTN40                 NO, jump\n         MVC   0(7,R4),=C'SMS SG='     SMS storage group\n         USING VLD,R2\n         OC    7(8,R4),VLDSTGRP        storage group (X'00'->X'40')\n         LA    R4,16(,R4)              point past string\n*\n*        SMS volume status\n*\n         BAS   R1,RDRTN30              BRANCH AROUND TABLE\n         DC    AL1(VLDENBL),C'Enabled     '\n         DC     AL1(VLDQUI),C'Quiesced/all'\n         DC    AL1(VLDQUIN),C'Quiesced/new'\n         DC     AL1(VLDDIS),C'Disabled/all'\n         DC    AL1(VLDDISN),C'Disabled/new'\n         DC    AL1(00),0H'0'\nRDRTN30  BAL   R14,SCAN_CLI            SCAN TABLE\n         DC    Y(1+12)                 SIZE OF A TABLE ENTRY\n         CLI   VLDSMSS,*-*             Test SMS status\n*        CLI   VLDSGST,*-*        Test SMS status on this system   ****\n         BNE   *+L'*+6                 NOT FOUND, JUMP AROUND \"MVC\"\n         MVC   0(12,R4),1(R1)          move SMS status\n         LA    R4,13(,R4)              point past status\n*\n*        display free space\n*\n         ICM   R1,B'1111',VLDNTCPY     total capacity\n         BZ    RDRTN60                 prevent S0C9\n         S     R1,VLDNFREE             free space\n         M     R0,=F'100'              space used * 100\n         D     R0,VLDNTCPY             R1 = %USED\n         STRING ((R1),,R5B),'% used',INTO=((R4),11)\n         LA    R4,1(R15,R4)            point past string\n         B     RDRTN60\n         DROP  R2\n.SMS2    ANOP\n*\n*        VOLSER/MOUNT FOR TAPE, DASD\n*\nRDRTN40  STATUS UCBSTAT,UCBPRES,'Resident'\n         STATUS UCBSTAT,UCBRESV,'Reserved'\n         STATUS UCBSTAB,UCBBPRV,'Private'\n         STATUS UCBSTAB,UCBBPUB,'Public'\n         STATUS UCBSTAB,UCBBSTR,'Storage'\n*\n*        Label type and position: LABEL=(nnn,SL)\n*\n         CLI   UCBTBYT3,UCB3TAPE       TAPE?\n         BNE   RDRTN50                 no, JUMP\n         ICM   R0,B'1100',UCBFSEQ      fileseq=0?\n         BZ    RDRTN50                 yes, JUMP\n         STRING (UCBFSEQ,H,L),',',INTO=((R4),12)\n         ALR   R4,R15                  point R4 past string\n         STATUS UCBSTAT,UCBDADI,'SL'\n         STATUS UCBTFL1,UCBNLTP,'NL'\n         STATUS UCBTFL1,UCBNSLTP,'NSL'\n         STATUS UCBTFL1,UCBBLP,'BLP'\n         B     RDRTN50\nRDRTN49  LA    R4,8(,R4)               skip volser slot\n*\n*        SHOW OWNER OF NON-DASD DEVICE\n*\nRDRTN50  STATUS UCBSTAT,UCBALOC,'Allocated',OFF=RDRTN60\n         SLR   R1,R1\n         ICM   R1,B'0111',UCBEXTP      UCB COMMON EXTENSION\n         LH    R1,UCBASID-UCBCMEXT(,R1)  GET OWNER'S ASID\n         LOCASCB ASID=(1)              GET ADDR OF OWNER'S ASCB\n         LTR   R15,R1                  VALID ASID?\n         BNP   RDRTN60                 NO, JUMP                    EU02\n         ICM   R1,B'1111',ASCBJBNI-ASCB(R15) JOB name present?\n         BNZ   RDRTN59                 yes, use it\n         ICM   R1,B'1111',ASCBJBNS-ASCB(R15) STC/MOUNT/LOGON\n         BZ    RDRTN60                 NO, JUMP                    EU02\nRDRTN59  MVC   0(2,R4),=C'J='          SMS storage group\n         MVC   2(8,R4),0(R1)           JOB/STC/TSU name\n         LA    R4,11(,R4)              point past string\nRDRTN60  STATUS UCBFLA,UCBNRY,'Not-ready'\n         STATUS UCBFLA,UCBBOX,'Boxed'\n*        DEV_STAT FLA,NOPTH,'No Path Available'                    ****\n         STATUS UCBFLC,UCBIVRS,'Intervention Required'\n         L     R13,4(,R13)             BRIF save area\nRDRTN70  ST    R10,0(,R6)              PASS DATA ADDRESS\n         TR    0(L'LINE,R10),TRTPRINT  Get rid of garbage          EU14\n         RETURN (14,12),RC=0           GOBACK TO EDIT\n*\n*        END OF DATA - RETURN MAX LINE#\n*\nRDRTN80  L     R1,NUMLINES             NUMBER OF LINES\n         ST    R1,0(,R4)               PASS IT TO BRIF\n         BCTR  R1,0                    DOWN BY 1\n         M     R0,=A(L'LINE)           OFFSET TO LAST LINE\n         LA    R10,LINES(R1)           CHANGE OFFSET TO ADDRESS\n         ST    R10,0(,R6)              PASS DATA ADDRESS\n         RETURN (14,12),RC=8\n         DROP  ,  -------------------- all registers killed -----------\n         EJECT\n*======================================================================\n*        RECOVERY ROUTINE\n*----------------------------------------------------------------------\nRECOVERY LA    R15,0012                R15=12\n         CR    R0,R15                  SDWA ALLOCATED?\n         BALR  R15,0                   LOCAL BASE\n         BNE   RCVY$200-*(,R15)        YES, JUMP\n         SR    R15,R15                 SET RC=0 (IF R0=12)\n         BR    R14                     RETURN TO EXIT PROLOG\nRCVY$200 BALR  R15,0\n         SAVE  (14,12),,'RECOVERY ROUTINE'\n         BALR  R12,0\n         USING *,R12\n         LR    R8,R1\n         USING SDWA,R8\n         LR    R14,R13\n         L     R13,SDWAPARM            =A(DYNAM)\n         LA    R13,RCVYSAVE-DYNAM(,R13) =A(RCVYSAVE)\n         ST    R14,4(,R13)\n         ST    R13,8(,R14)\n         USING RCVYSAVE,R13\n         ICM   R4,B'1111',RETRY        LOAD/TEST RETRY ADDRESS\n         BNP   RCVY$999                NO RETRY, CONTINUE WITH ABEND\n         MVI   RETRY,X'FF'             INVALIDATE RETRY ADDRESS\n         MVC   SDWASRSV,SDWAGRSV       MOVE REGISTERS\n         MVC   SDWASR08,CVTPTR         R8=CVTADDR\n         MVC   SDWASR09,PSATOLD-PSA    R9=TCBADDR\n         MVC   SDWASR11,BASEREG        R11 (BASE REG)\n         MVC   SDWASR13,SDWAPARM       R13\n         L     R13,4(,R13)             R/TM SAVE AREA\n         SETRP WKAREA=(R8),RETADDR=(R4),RC=4,  <== RETRY               X\n               FRESDWA=YES,RETREGS=YES,REGS=(14,12)\nRCVY$999 L     R13,4(,R13)\n         SETRP WKAREA=(R8),REGS=(14,12),RC=00\n         DROP  ,  -------------------- all registers killed -----------\n         EJECT\n*======================================================================\n*        SUB-TASK USED FOR ASYNCHRONOUS ACCESS TO CATALOGS AND VTOCS\n*\n*        THIS SUB-TASK ALLOWS IMPATIENT USERS (LIKE ME) TO SEE THE\n*        FIRST SCREEN WITHOUT ANY DELAY WHILE VOLUME AND VTOC\n*        INFORMATION (WHICH REQUIRE I/O) IS OBTAINED FOR THE LINK-LIST,\n*        LPA-LIST AND APF-LIST DISPLAYS.\n*\n*        WHEN THE USER SCROLLS TO THESE SCREENS (WHICH TAKES A FEW\n*        SECONDS), VOLUME AND VTOC INFORMATION WILL HAVE BEEN OBTAINED\n*        IN THE BACKGROUND, WITHOUT THE USER HAVING TO WAIT.\n*\n*        IF A SPEEDY USER CHAINS A \"FIND\" COMMAND TO THE INVOCATION\n*        OF THIS PROGRAM (BY ISSUING \"TSO SHOWMVS;F LPA-LIST\" FOR\n*        EXAMPLE), THEN HE/SHE WILL PROBABLY GET A BUNCH OF QUESTION\n*        MARKS INSTEAD OF VOLUME AND VTOC INFORMATION (SURPRISE,\n*        SURPRISE !!).  AFTER A FEW SECONDS OF HESITATION, THIS USER\n*        IS LIKELY TO HIT \"ENTER\" OR SCROLL (UP OR DOWN) TO SEE IF\n*        OTHER BIZARRE THINGS HAPPEN, WHICH LEAVES ENOUGH TIME TO THE\n*        SUBTASK TO FINISH OBTAINING THE INFORMATION AND REPLACE THE\n*        QUESTION MARKS WITH PERTINENT DATA.\n*----------------------------------------------------------------------\nSUB_RTNE SAVE  (14,12),,'SUB-TASK'                                 EU13\n         CNOP  0,8\nSUB_TASK LPR   R9,R1                   SUB_WORK                    @380\n         USING SUB_WORK,R9\n         ST    R13,4(,R9)                                          EU13\n         ST    R9,8(,R13)                                          EU13\n         LR    R13,R9                                              EU13\n         USING LINE,R10\n         L     R11,BASEREG             BASE REGISTER\n         USING BASEADDR,R11\n         BALR  R12,0\n         USING *,R12\n*\n*        Estimate processor speed\n*\n         XR    R4,R4                   LOOP COUNT\n         LA    R6,SUB_DWD              WORK AREA\n         MVC   0(LOOPL,R6),SUB_LOOP    MOVE LOOP INSTRUCTION\n         BAL   R15,SUBT050\n         MVI   LOOPL-1(R6),R4*16+R5    CHANGE R4,R6 TO R4,R5\n         BR    R14\nSUB_LOOP BCTR  R4,R6                   LOOP COUNT - RR INSTRUCTION\nLOOPL    EQU   *-SUB_LOOP              INSTRUCTION LOOP LENGTH\nONETENTH DC    FL4'10'                 TEN 1/100TH OF A SECOND\nSUBT050  STIMER TASK,(R15),BINTVL=ONETENTH\n         BALR  R5,R6                   EXECUTE LOOP\n         LPR   R15,R4                  NUMBER OF ITERATIONS\n         LR    R5,R15                  ADJUST # OF INSTRUCTIONS    EU09\n         SRL   R5,2                                                EU09\n         AR    R15,R5                                              EU09\n         M     R14,CPUONLNE+4          MULT BY # OF CPU'S ON-LINE\n         D     R14,=F'1000000'         .1 MIPS\n         CVD   R15,SUB_DWD             .1 MIPS\n         MVC   SUB_W265(7),=X'40202021204B20' 0999.9\n         ED    SUB_W265(7),SUB_DWD+5   0999.9\n         L     R10,CPUONLNE            processor speed line\n         STRING '       Processor Speed: ',(SUB_W265+2,5),' MIPS',     X\n               INTO=LINE\n         LA    R10,LINES               First line\n*\n*        Pass 1: Complete VOLSER\n*-> LOOP\nSUBT100  CLI   VOLSER,C'?'             VOLSER FOUND ALREADY?\n         BNE   SUBT110                 YES, JUMP\n         MVC   VOLSER,=C'??????'       NOT FOUND\n         L     R14,=X'44,00,00,00'     CAMLST FLAGS\n         LA    R15,DSNAME              ENTRY NAME\n         SLR   R0,R0                   NO CVOL PTR\n         LA    R1,SUB_W265             WORK AREA\n         STM   R14,R1,CAMLST1          BUILD CAMLIST               @364\n         LOCATE CAMLST1                GET VOLSER FROM CATALOG     @364\n         LTR   R15,R15\n         BNZ   SUBT110                 NOT FOUND (OR OTHER ERROR)\n         MVC   VOLSER,SUB_W265+6       MOVE VOLSER\n*        => UNCAT=UNCAT\nSUBT110  CLI   CATUNCAT,C'?'           CATALOG STATUS KNOWN ALREADY?\n         BNE   SUBT120                 YES, JUMP\n         MVC   CATUNCAT,=C'UNCAT'      MOVE STATUS\n         L     R14,=X'44,00,00,00'     CAMLST FLAGS\n         LA    R15,DSNAME              ENTRY NAME\n         SLR   R0,R0                   NO CVOL PTR\n         LA    R1,SUB_W265             WORK AREA\n         STM   R14,R1,CAMLST1          BUILD CAMLIST               @364\n         LOCATE CAMLST1                GET VOLSER FROM CATALOG     @364\n         LTR   R15,R15\n         BNZ   SUBT120                 NOT FOUND (OR OTHER ERROR)\n         CLC   VOLSER,SUB_W265+6       SAME VOLSER?\n         BNE   *+L'*+10                NO                          EU06\n         MVC   CATUNCAT,BLANKS         CATALOGED=YES\n         B     SUBT120                                             EU06\n         MVC   CATUNCAT(2),=CL2'C='                                EU06\n         MVC   CATUNCAT+2(6),SUB_W265+6 MOVE OTHER VOLSER          EU06\n         MVI   LINE_APF,C' '           DON'T PROCESS               EU06\nSUBT120  LA    R10,NEXTLINE            NEXT LINE\n         CLI   LINE,0                  LAST LINE?\n         BNE   SUBT100                 NO, LOOP MORE\n*-> end LOOP\n*\n*        Pass 2: Cross-reference LNK/LPA/APF table entries\n*\n         LA    R10,LINES               First line\n*        => UNCAT=APF\n*-> LOOP\nSUBT200  CLI   LINE_APF,C'?'           LNK/LPA/APF STATUS REQUIRED?\n         BNE   SUBT210                 NO, JUMP\n         LM    R15,R1,APFTABLE         APF TABLE\n         BAL   R14,SUBT800             SCAN APFTABLE\n         DC    C'APF '                 LITERAL\n         MVC   LINE_APF,0(R1)          LITERAL OR SPACES\n         CLI   LINE_LNK,C' '           UNCAT APFLST ENTRY?\n         BNE   SUBT210                 YES, JUMP\n*        => LNK=LPA\n         LM    R15,R1,LPATABLE         LPA TABLE\n         BAL   R14,SUBT800             SCAN LPATABLE\n         DC    C'LPA '                 LITERAL\n         MVC   LINE_LPA,0(R1)          LITERAL OR SPACES\n*        => LPA=LNK\n         LM    R15,R1,LNKTABLE         LNK TABLE\n         BAL   R14,SUBT800             SCAN LNKTABLE\n         DC    C'LNK '                 LITERAL\n         MVC   LINE_LNK,0(R1)          LITERAL OR SPACES\nSUBT210  LA    R10,NEXTLINE            NEXT LINE\n         CLI   LINE,0                  LAST LINE?\n         BNE   SUBT200                 NO, LOOP MORE\n*-> end LOOP\n*\n*        Pass 3: Detect TIOT data-sets in LPALST or LNKLST\n*\n         LA    R10,LINES               First line\n*        => TIOT=LPA\n*-> LOOP\nSUBT300  CLI   LINE_LPA2,C'?'          LPA-LIST STATUS KNOWN ALREADY?\n         BNE   SUBT310                 YES, JUMP\n         LM    R15,R1,LPATABLE         LPA TABLE\n         BAL   R14,SUBT810             SCAN APFTABLE\n         DC    C'LPA '                 LITERAL\n         MVC   LINE_LPA2,0(R1)         LITERAL OR SPACES\n*        => TIOT=LNK\nSUBT310  CLI   LINE_LNK2,C'?'          LNK-LIST STATUS KNOWN ALREADY?\n         BNE   SUBT320                 YES, JUMP\n         LM    R15,R1,LNKTABLE         LNK TABLE\n         BAL   R14,SUBT810             SCAN APFTABLE\n         DC    C'LNK '                 LITERAL\n         MVC   LINE_LNK2,0(R1)         LITERAL OR SPACES\nSUBT320  LA    R10,NEXTLINE            NEXT LINE\n         CLI   LINE,0                  LAST LINE?\n         BNE   SUBT300                 NO, LOOP MORE\n*-> end LOOP\n*\n*        Pass 4: Read F1-DSCB to diaplay creation date\n*                (this pass takes the longest and is done last)\n*\n         LA    R10,LINES               First line\n         SLR   R6,R6                   extent counter\n*-> LOOP\nSUBT400  CLI   YYMMDD,C'?'             DATE FOUND ALREADY?\n         BNE   SUBT420                 YES, JUMP\n         MVC   YYMMDD,BLANKS           BLANK OUT DATE FIELD\n         L     R14,=X'C1,00,00,00'     CAMLST FLAGS\n         LA    R15,DSNAME              DATA SET NAME OF CCHHR\n         LA    R0,VOLSER               VOLUME SERIAL\n         LA    R1,DS1FMTID             WORK AREA\n         STM   R14,R1,CAMLST1          BUILD CAMLIST               @364\n         OBTAIN CAMLST1                READ F1-DSCB                @364\n         LTR   R15,R15\n         BNZ   SUBT420                 NOT FOUND (OR OTHER ERROR)\n         SLR   R0,R0\n         ICM   R0,B'0001',DS1CREDT+0   CREATION YEAR\n         CVD   R0,SUB_DWD\n         ICM   R1,B'0011',SUB_DWD+6    ....0YYC\n         SLL   R1,012                  .0YYC000\n         ICM   R0,B'0011',DS1CREDT+1   CREATION DAY\n         CVD   R0,SUB_DWD\n         STCM  R1,B'0100',SUB_DWD+5    00YYDDDC\n         STRING (SUB_DWD+4,P,YYMMDD),INTO=YYMMDD CONVERT DATE\n         CL    R10,LNKTABLE+0          LINK-LIST?\n         BL    SUBT410                 NO, JUMP\n         CL    R10,LNKTABLE+8          LINK-LIST?\n         BH    SUBT410                 NO, JUMP\n         STRING (DS1NOEPV,FL1,R3B),' Extents',INTO=(LINE+85,11)\n         SLR   R0,R0\n         IC    R0,DS1NOEPV\n         ALR   R6,R0                   Tally allocated extents\nSUBT410  CLI   CATUNCAT,C'%'           PCT USED?\n         BNE   SUBT420                 NO, JUMP\n         MVC   CATUNCAT(4),=C'FULL'    PRIME STATUS\n         ICM   R0,B'0011',DS1LSTAR     DATA SET FULL?\n         BNZ   SUBT420                 YES, JUMP\n         MVC   CATUNCAT(5),=C'EMPTY'   NO, TELL IT\nSUBT420  LA    R10,NEXTLINE            NEXT LINE\n         CLI   LINE,0                  LAST LINE?\n         BNE   SUBT400                 NO, LOOP MORE\n*-> end LOOP\n         L     R10,LINKXTNT            link-list hdr line\n         STRING (LINE,,T),' (',((R6),,L),' allocated)',INTO=LINE\n         CLI   ECB1+7,X'FF'            called as rouitne?          EU13\n         BE    SUBT999                 yes                         EU13\n*\n*        Serialize sub_task termination with DETACH to prevent Sx3E\n*\n         L     R13,4(,R13)             original \"DYNAM\"\n         ENQ   (EDQNAME,EDRNAME,E,L'EDRNAME),                      @364X\n               MF=(E,ENQL1)            SERIALIZE DETACH            EU15\n         POST  ECB1,0                  POST COMPLETION ECB\n         SVC   3                       GOOD BYE\nSUBT999  L     R13,4(,R13)                                         EU13\n         RETURN (14,12),RC=0           That's all folks            EU13\n*\n*        Scan Tables routines\n*\nSUBT800  LTR   R15,R15                 TEST\n         BZ    SUBT820\n*-> LOOP\nSUBT801  CLC   DSNAME,DSNAME-LINE(R15) MY DSNAME?\n         BNE   SUBT802                 NO, JUMP\n         CLC   VOLSER,VOLSER-LINE(R15) MY VOLSER?\n         BE    SUBT820                 YES, QUIT\nSUBT802  BXLE  R15,R0,SUBT801          NEXT ENTRY\n*-> end LOOP\n         B     SUBT821\nSUBT810  LTR   R15,R15                 TEST\n         BZ    SUBT820\n*-> LOOP\nSUBT811  CLC   LINE_DSN2,DSNAME-LINE(R15) MY DSNAME?\n         BNE   SUBT812                 NO, JUMP\n         CLC   LINE_VOL2,VOLSER-LINE(R15) MY VOLSER?\n         BE    SUBT820                 YES, QUIT\nSUBT812  BXLE  R15,R0,SUBT811          NEXT ENTRY\n         B     SUBT821\n*-> end LOOP\nSUBT820  LR    R1,R14                  APF=YES\n         B     4(,R14)\nSUBT821  LA    R1,BLANKS               APF=NO\n         B     4(,R14)\n         EJECT\n*------------------------------------------------------------------EU14\n*        24-bit dynamic storage area for EXTRACT                   EU14\n*------------------------------------------------------------------EU14\nEXTR24   DSECT                         Dynamic storage area        EU14\nEXTR    EXTRACT *-*,'S',MF=L                                       EU14\nLEXTR    EQU   *-EXTR                                              EU14\nATSO     DS    A                                                   EU14\nAPSCB    DS    A                                                   EU14\nEXTR24L  EQU   (((*-EXTR24)+7)/8)*8    Length of storage area      EU14\n*----------------------------------------------------------------------\n*        24-BIT DYNAMIC STORAGE AREA\n*----------------------------------------------------------------------\nDYNAM24  DSECT                         DYNAMIC STORAGE AREA\n         DS    18F                     24-BIT SAVE AREA FOR PUT\nCODE24   ST    R13,4(,R7)              24-BIT SAVE AREA\n         LR    R13,R7                  24-BIT SAVE AREA\n         LA    R1,DCB24-CODE24(,R15)   GET DCB ADDRESS\n         PUT   (1)                     PUT LOCATE\n         L     R13,4(,R13)             31-BIT SAVE AREA\n         BSM   0,R2                    GOBACK WITH AMODE31\n         CNOP  0,4\nSYNAD24  STM   R13,R2,SAVE24(R15)      save registers\n         LR    R2,R15                  use as base\n         USING SYNAD24,R2\n         SYNADAF ACSMETH=QSAM          get error message from OS\n         MVC   WTO24M(L'WTO24M,R2),68(R1) get usefull text\n         SYNADRLS                      free OS message\n         DROP  R2\n         LM    R13,R2,SAVE24(R2)       restore registers\n         BR    R14                     return\n         PRINT NOGEN                                               EU00\nOPEN24   OPEN  (DCB24,OUTPUT),MF=L\nXLST24   DC    0F'0',XL1'85',AL3(*-*)  DCB exit list\n         USING IHADCB,R1\n         USING XDCB24,R15\nXDCB24   XR    R0,R0\n         ICM   R0,B'0011',DCBLRECL     get LRECL\n         BZ    *+L'*+14                branch if undefined\n         CLM   R0,B'0011',XLRL24(R15)  LRECL= as needed?\n         BE    *+L'*+6                 yes\n         MVI   XERR24(R15),1           no, set error 1\n         BR    R14                     return\n         TM    DCBRECFM,DCBRECV        RECFM= V or U?\n         BZ    *+L'*+6                 no\n         MVI   XERR24(R15),2           yes, set error 2\n         BR    R14                     return\n         TM    DCBRECFM,DCBRECF        RECFM= F?\n         BO    *+L'*+4                 yes\n         OI    XREC24(R15),DCBRECF     no, set it\n         TM    DCBRECFM,DCBRECCM       CC= Machine defined?\n         BZ    *+L'*+6                 no\n         MVI   XERR24(R15),3           yes, set error 3\n         BR    R14                     return\n         TM    DCBRECFM,DCBRECCA       CC= ASA defined?\n         BO    *+L'*+4                 yes\n         OI    XREC24(R15),DCBRECCA    no, set it\n         TM    DCBRECFM,DCBRECBR       Blocked records?\n         BZ    ZDCB24                  no\n         LH    R0,DCBBLKSI             get BLKSIZE\n         SH    R0,XLRL24(R15)          is it a multiple?\n         BP    *-4                     continue check\n         BZ    ZDCB24                  yes\n         MVI   XERR24(R15),4           no, set error 4\n         BR    R14                     return\nZDCB24   MVC   DCBLRECL,XLRL24(R15)    complete DCB\n         OC    DCBRECFM,XREC24(R15)\n         BR    R14                     return\nXLRL24   EQU   *-XDCB24\n         DC    Y(L'LINE+1)\nXREC24   EQU   *-XDCB24\n         DC    AL1(0)\nXERR24   EQU   *-XDCB24\nXERR24C  DC    AL1(0)\n         DROP  R1,R15\nDCB24    DCB   DSORG=PS,MACRF=PL,DDNAME=XXXXXXXX                   EU13\n         DS    0F\nSAVE24   EQU   *-SYNAD24\n         DC    6F'0'                   save registers\nWTO24    WTO   '-- PUT error :                                         X\n                                   ',ROUTCDE=11,DESC=7,MF=L\nWTO24T   EQU   WTO24+22,1\nWTO24M   EQU   (WTO24+19)-SYNAD24,60\nCODE24L  EQU   *-CODE24                PUT LOCATE\nDYNAM24L EQU   (((*-DYNAM24)+7)/8)*8   LENGTH OF DYNAMIC STORAGE AREA\n*----------------------------------------------------------------------\n*        DESCRIPTION OF A PRINT LINE\n*----------------------------------------------------------------------\n         DSECT\nLINE     DS    CL100                   CURRENT LINE\nDSNAME   EQU   LINE+2,44\nVOLSER   EQU   LINE+2+44+3,6\nDEVTYPE  EQU   LINE+2+44+3+6+3,8\nYYMMDD   EQU   LINE+2+44+3+6+3,6\nCATUNCAT EQU   LINE+2+44+3+6+3+6+3,5   UNCAT\nLINE_LNK EQU   CATUNCAT+0,3            LNK\nLINE_LPA EQU   LINE_LNK+5,3            LPA\nLINE_APF EQU   LINE_LPA+5,3            APF\nLINE_VOL2 EQU  LINE+15,6               VOLSER   (TIOT DISPLAY)\nLINE_DSN2 EQU  LINE+28,44              DSNAME   (TIOT DISPLAY)\nLINE_LNK2 EQU  LINE+90,3               LNKLST   (TIOT DISPLAY)\nLINE_LPA2 EQU  LINE+90+4,3             LPALST   (TIOT DISPLAY)\nNEXTLINE DS    CL(L'LINE)              NEXT LINE\n*----------------------------------------------------------------------\n*        Catalog Parameter List (SVC 26)\n*----------------------------------------------------------------------\nCTGPL    DSECT\nCTGOPTN1 DS    B              FIRST OPTION BYTE:\nCTGNAME  EQU   X'04' .... .1..  CTGENT CONTAINS DSNAME OR SERIAL ADDR\nCTGGENLD EQU   X'01' .... ...1  GENERIC LOCATE REQUEST\nCTGOPTN2 DS    B              SECOND OPTION BYTE:\nCTGFUNC  DS    B     XXX. ....  SPECIFIES THE CALLER-REQUESTED FUNCTION\nCTGSUPLT EQU   X'10' ...1 ....  SUPERLOCATE FUNCTION\nCTGAM0   EQU   X'01' .... ...1  OS/VS2 CATALOG MANAGMENT REQUEST\nCTGOPTN4 DS    B              FOURTH OPTION BYTE\nCTGENT   DS    A(DUMPNODE)    ADDRESS OF CATALOG RECORD IDENTIFIER\nCTGCAT   DS    A(0)           ADDRESS OF CATALOG DSNAME OR ACB\nCTGWKA   DS    A(*-*)         ADDRESS OF CALLER'S WORK AREA\nCTGOPTNS DS    B              CATALOG MANAGMENT SERVICES REQUEST OPTION\n         DS    B              CMS REQUEST OPTIONS (2)\nCTGTYPE  DS    C              TYPE OF CATALOG RECORD\nCTGTALIN EQU   C'A'             NON-VSAM\nCTGNOFLD DS    FL1'0'         NUMBER OF ENTRIES IN CTGFIELD\nCTGFDBK  DS    XL2            FEEDBACK AREA (IF NOT SUPERLOCATE)\nCTGFBFLG DS    B              FLAGS (SUPERLOCATE)\nCTGRSNCD DS    B              REASON CODE IF R15 > 0\nCTGPSWD  DS    A(0)           ADDRESS OF CALLER-SUPPLIED PASSWORD\nCTGPLLEN EQU   *-CTGPL                 LENGTH OF CTGPL\n*----------------------------------------------------------------------\n*        DYNAMIC STORAGE AREA (RMODE=ANY)\n*----------------------------------------------------------------------\nDYNAM    DSECT                         DYNAMIC STORAGE AREA\n         DS    18F                     SAVE AREA FOR MAINLINE\nPARMADDR DS    A                       ADDRESS OF CALLER'S PARM OR CPPL\nDYNAML2  DS    A(DYNAML)               LENGTH OF DYNAMIC STORAGE AREA\nRCVYSAVE DS    18F                     SAVE AREA FOR RECOVERY ROUTINE\nWKCELL1  DS    D                       WORK AREA\nWKCELL2  DS    D                       WORK AREA\nWKCELL3  DS    D                       WORK AREA\nWKWORDS  DS    10F                     WORK AREA\n         DS    6F                      ADDITIONAL WORK AREA        EU13\n*- - - Defined here below : dynamic allocation DD-name return - -  EU13\nRT_DDN   EQU   WKWORDS+4+(S99RBEND-S99RB)+3*4+2*4+4+6,8            EU13\nJSTCB    DS    A(TCB)                  ADDRESS OF THE JOB-STEP TCB\n         AIF   (NOT D'DFASMS).SMS3     NOT DFP V3, JUMP\nWORK4K   DS    A(DYNAM+DYNAML-4096)    4K work area ptr (DEVSTAT)\n.SMS3    ANOP\nESTAEL   ESTAE MF=L\nEND_PROC DS    2A                      RETURN/RETRY ADDRESS\nRETRY    EQU   END_PROC+4,4,C'A'       RETRY ADDRESS\nNUMLINES DS    F                       NUMBER OF LINES\nIEFEB4UV DS    V(IEFEB4UV)             UNITNAME CONVERSION RTNE\nISPLINK  DS    V(ISPLINK)              ISPF DIALOG INTERFACE\nUNITNAME DS    CL8,XL4,XL4,XL4,XL8     IEFEB4UV\nZENVIR   DS    CL32                    ISPF ENVIRONMENT\nK1       DS    PL4                     COUNTER\nK2       DS    PL4                     COUNTER\nEP10     DS    CL10                    SVC TABLE\nSTATUS   DS    C'OLD'                  DATA SET STATUS\nFSWITCH  DS    XL1                     Functional switches\nHARDCOPY EQU   X'80'                   BRIF/HARDCOPY switch\nTSORUN   EQU   X'40'                   TSO running (not ISPF)      EU13\nBATCHRUN EQU   X'20'                   BATCH running               EU13\nFLGNOMSG EQU   X'10'                   NOMSG flag (debug)          EU18\nDYNSHORT EQU   X'08'                   DYNAMIC AREA SHORTAGE switch\nERRBRIF  EQU   X'04'                   BRIF error signal\nIGCERROR DS    A                       UNUSED SVC NUMBER\nSMS_R14  DS    A(R14)                  return address\nSWAREQL1 SWAREQ MF=L                   WORK AREA FOR SWAREQ\nATTACHL1 ATTACH SF=L                   WORK AREA FOR ATTACH\nSNAPREGS DS    A(14,15,0,1,2,3,14,15)\nDYN_CHK  DS    F                       lines for BRIF space\nWK256    DS    XL256,2D                265-BYTE WORK AREA\nTRTPRINT DS    XL256                   printable characters\n*----------------------------------------------------------------------\n*        SUB_TASK work area\n*----------------------------------------------------------------------\nSUB_WORK DS    0D\n         DS    18F                     SAVE AREA FOR SUB_TASK      EU13\nENQL1    ENQ   (*-*,*-*,E,0),MF=L                                  @364\nENQL1L   EQU   *-ENQL1                                             @364\nECB1     DS    F,A(TCB)                COMMUNICATION ECB,TCB\nMAXLPG   DS    A(60)                   Max. lines per page         EU15\nCURPGN   DS    A(1)                    current page number         EU15\nTLNEPT   DS    A(*-*)                  TITLE line pointer          EU15\nMY_DDN   DS    CL8                     DDN=SHOWMVS (default)       EU15\nEDQNAME  DS    CL8                     ENQ/DEQ : Q-name (Job-name)\nEDRNAME  DS    CL16                    ENQ/DEQ : R-name (Day.Time)\nBLANKS   DS    CL(L'LINE)              A BUNCH OF BLANKS\nBASEREG  DS    A(R11)                  BASE REGISTER FOR RECOVERY ...\nCPUONLNE DS    A(LINE),F'100'          Number of cpu's on-line\nLNKTABLE DS    A(LINE,L'LINE,NEXTLINE) LNK-LIST\nLPATABLE DS    A(LINE,L'LINE,NEXTLINE) LPA-LIST\nAPFTABLE DS    A(LINE,L'LINE,NEXTLINE) APF-LIST\nLINKXTNT DS    A(LINE)                 link-list header line\nCAMLST1  CAMLST NAME,DSNAME,VOLSER,SUB_W265 LOCATE/OBTAIN\nSUB_W265 DS    265X                    LOCATE\n         IECSDSL1 1                    F1-DSCB\n         DS    XL5                     PADDING FOR OBTAIN\nSUB_DWD  DS    D\n*----------------------------------------------------------------------\nLINES    DS    (&NLBRIF)CL(L'LINE)     LINES FOR BRIF\nDYNAML   EQU   (((*-DYNAM)+7)/8)*8     LENGTH OF DYNAMIC STORAGE AREA\n         EJECT\n*======================================================================\n*        DEFINE MVS CONTROL-BLOCKS\n*----------------------------------------------------------------------\n         IHASDWA DSECT=YES,VRAMAP=NO   SDWA DSECT\n         IHAPSA DSECT=YES              PREFIXED STORAGE AREA\n         CVT   PREFIX=YES,DSECT=YES,LIST=NO\n         IARRCE                        RSM CTL & ENUM AREA\n         IHAGDA                        GLOBAL DATA AREA\n         IHASCVT DSECT=YES,LIST=NO     SECONDARY CVT\n         IEFJESCT                      JES VECTOR TABLE\n         IEFJSCVT                      SUB-SYSTEM COMM. VECTOR TABLE\n         IEFJSSVT ,                    SUB-SYSTEM VECTOR TABLE\n         AIF   ('&EUJES' NE 'JES2').JS23                           EU16\n* Here follows those dsect's needed for JES2DATA assembly.         EU16\n*        Note: when the original dsect contains a TITLE card, then EU16\n*              just the needed fields only are defined below.      EU16\n* From : $SVT - HASP SUB-SYSTEM VECTOR TABLE DSECT                 EU16\nSVTTO    EQU   X'01F8',3     OWN NODE INFORMATION            @130  EU16\nSVTTONOD EQU   X'01F8',2      OWN NODE ID        (BINARY)    @130  EU16\nSVTTOQUL EQU   X'01FA',1      OWN NODE SYSTEM ID (EBCDIC)    @130  EU16\nSVTRDT   EQU   X'0208',4     ADDRESS OF REMOTE DESTINATION TABLE   EU16\nSVTRDTE  EQU   X'020C',4     ADDRESS OF LAST RDT ELEMENT           EU16\nSVTCKPT1 EQU   X'0224',51     CKPT1 HFAME                    @220  EU16\nSVTCKPT2 EQU   X'025C',51     CKPT2 HFAME                    @220  EU16\nSVTPIT   EQU   X'338',4      PARTITION INFORMATION TABLE ADDRESS   EU16\n         $HFAME ,            HASP FILE ALLOCATION MAP ENTRY        EU16\n         $RDT  ,             HASP REMOTE DESTINATION TABLE         EU16\n         $PIT  ,             HASP PARTITION INFORMATION TABLE      EU16\n* From : $SJB  HASP SUB-SYSTEM JOB BLOCK                           EU16\nSJBID    EQU   X'048',4      SJB IDENTIFIER                        EU16\nSJBJOBID EQU   X'114',8      JOB IDENTIFIER - EBCDIC, NUMERIC      EU16\nSJBJOBNM EQU   X'11C',8      JOBNAME FROM JOB CARD                 EU16\n.JS23    IEFZB4D0 ,                                                EU16\n         IEFZB4D2 ,\n         IEFZB505 LOCEPAX=YES          EPA MAPPING FOR SWAREQ      @364\n         IEFZB610 ,                    PPT MAPPING                 EU12\n         IKJTCB DSECT=YES,LIST=NO      TASK CONTROL BLOCK\n         IHARD  ,                      REGION DESCRIPTOR\n         IHASPQE ,                     sub-pool queue element\n         IHASPQA ,                     sub-pool queue element\n         IHADQE  ,                     descriptor queue element\n         IKJRB  DSECT=YES,LIST=NO      REQUEST BLOCK\n         IHACDE ,                      CONTENTS DIRECTORY ENTRY\n         IHALLE ,                      LOAD-LIST ELEMENT\n         IHAXTLST ,                    EXTENT LIST\n         IHASVC ,                      SVC TABLE ENTRY\n         IKTTCAST DSECT=YES            TCAS (a key 0 area)\n         IEFUCBOB LIST=NO,PREFIX=NO    UNIT CONTROL BLOCK\n         IECDDCE ,                     DEVICE CLASS EXTENSION\nD3380    EQU   X'14'                   MDR TYPE FOR STD 3380 MODELS\nD3380D   EQU   X'1C'                   MDR TYPE FOR 3380-D\nD3380E   EQU   X'1B'                   MDR TYPE FOR 3380-E\n*        IECDCQ  ,                     Device class table          ****\nDCQ      DSECT\nDCQNAME  DS    C'DCQ '\nDCQLNGTH DS    H\nDCQCOUNT DS    H\nDCQFIRST DS    A(DCQELMNT)             First element\nDCQDSTCT DS    XL4\nDCQUCBNO DS    F\nDCQELMNT DSECT\nDCQCHAIN DS    A(DCQELMNT)             NEXT DCQ\nDCQDEVCL DS    X                       DEVICE CLASS\nDCQFLG1  DS    X                       RESERVED\nDCQUCBCT DS    H                       # OF UCBS\nDCQUCBAD DS    V(UCBOB)                FIRST UCB\nDCQDEVNM DS    CL8                     CLASS NAME\n         DS    XL8                     RESERVED\n         IEECUCM DSECT=YES             Unit Control Module\n         DCBD  DSORG=(XE,PS),DEVD=DA   IHADCB\nJFCB     DSECT\n         IEFJFCBN LIST=NO              JOB FILE CONTROL BLOCK\nTIOT     DSECT\n         IEFTIOT1                      TASK INPUT-OUTPUT TABLE\n         IEZDEB  LIST=NO               DATA EXTENT BLOCK\n         IEZJSCB ,                     JOB STEP CONTROL BLOCK\n         IKJCPPL ,                                                 EU14\n         IKJPSCB ,                     PROTECTED STEP CONTROL BLOCK\n         IKJEBECA ,                                                EU14\n         AIF   (D'PSCBCNAU).TSO1\nPSCBCNAU EQU   X'01'                   CONSOLE authority    (TSO/E 2.3)\n.TSO1    IKJUPT ,                      User Profile Table\n         AIF   (D'UPTPLANG).TSO2\nUPTPLANG DS    CL3                     Primary language     (TSO/E 2.2)\nUPTSLANG DS    CL3                     Secondary language   (TSO/E 2.2)\n.TSO2    ANOP\n*        IHALLT DSECT=YES              LINK-LIST TABLE             ****\nLLT      DSECT\nLLTLLT   DS    C'LLT '                 BLOCK ACRONYM\nLLTNO    DS    F                       NUMBER OF ENTRIES\nLLTENTRY DS    0CL45                   DSNAME ENTRY\nLLTDSNL  DS    FL1                     DSNAME LENGTH AFTER TRUNCATION\nLLTDSNAM DS    CL44                    DATA SET NAME\nLLTNEXT  EQU   *                       NEXT ENTRY\n*        IHAPCCAT DSECT=YES            PCCA TABLE                  ****\n         IHAPCCA DSECT=YES             PHYSICAL CONFIG. COMM. AREA\n*        IDAAMCBS                      ACCESS METHOD CB STRUCTURE  ****\nCBS      DSECT\nCBSID    DS    C'AM'                   AMCBS ID\nCBSSIZ   DS    H'144'                  LENGTH OF THE AMCBS\nCBSMCSTA DS    C'CCHH'                 CCHH OF MASTER CATALOG\nCBSACB   DS    V(ACB)                  ACB FOR THE MASTER CATALOG\nCBSCBP   DS    V(IDC019C1)             CONTROL BLOCK MANIPULATION RTNE\nCBSCMP   DS    V(IGG0CLA1)             CATALOG MANAGEMENT ROUTINE\nCBSCAXCN DS    V(CAXWA)                ADDRESS OF THE CAXWA CHAIN\nCBSCRACA DS    V(CAXWA)                ADDRESS OF THE CRA CAXWA CHAIN\n*        IDACAXWA                                                  ****\nCAXWA    DSECT                         Catalog Work Area\nCAXID    DS    X'CA'                   CAX ID\nCAXFLG4  DS    X,2X                    FLAGS (4)\nCAXCHN   DS    A(CAXWA)                NEXT CAXWA IN CHAIN\nCAXFLGS  DS    X                       FLAGS (1)\nCAXMCT   EQU   X'04'                   MASTER CATALOG\nCAXFLG2  DS    X                       FLAGS (2)\nCAXFLG3  DS    X                       FLAGS (3)\nCAXFLG5  DS    X,3F                    FLAGS (5)\nCAXACB   DS    V(IFGACB)               CATALOG'S ACB\nCAXUCB   DS    V(UCBOB)                CATALOG'S UCB\n         DS    FL3,FL3,FL3,FL3,H,H,A\nCAXCNAM  DS    CL44                    CATALOG'S DSNAME\nCAXVOLID DS    CL6                     CATALOG'S VOLUME (CRA ONLY)\n*        ILRASMVT DSECT=YES       AUXILIARY STRGE MGR VECTOR TABLE ****\nASMVT    DSECT                         ILRASMVT\nASMFLAG1 DS    X                       FLAGS 1\nASMFLAG2 DS    X,2X                    FLAGS 2\nASMQUICK EQU   X'08'                   QUICK START IPL\nASMSART  DS    V(SART)                 SWAP ACTIVITY REFERENCE TABLE\nASMPART  DS    V(PART)                 PAGE ACTIVITY REFERENCE TABLE\n*        ILRPART                                                   ****\nPART     DSECT                         PAGING ACTIVITY REFERENCE TABLE\nPARTIDEN DS    C'PART'                 EYE CATCHER\nPARTSIZE DS    F             +4        NUMBER OF ENTRIES IN THE PART\nPARTEUSE DS    F             +8\nPARTCIR0 DS    A             +C\nPARTCIR1 DS    A             +10\nPARTCIR2 DS    A             +14\nPARTTPAR DS    0A            +18\nPARTDSNL DS    A             +18       ADDR OF DSN LIST\nPARTPCTQ DS    A             +1C\nPARTLCNT DS    H             +20\nPARTFLG1 DS    B             +22\n         DS    X             +23\nPARTNPCF DS    A             +24\nPARTNPCL DS    A             +28\nPARTTIME DS    F             +2C\n         DS    CL32          +30\nPARTENTS EQU   *\n         SPACE 2\nPARTENT  DSECT                         PAGE DATA SET TABLE ENTRY\nPAREPARE DS    A             +0\nPAREBRST DS    AL1           +4\nPAREIORN DS    AL1           +5\n         DS    XL2           +6\nPARETYPE DS    B             +8\nPAREPLPA EQU   X'80'                   PLPA\nPARECOMM EQU   X'40'                   COMMON\nPAREDPLX EQU   X'20'                   DUPLEX\nPARELOCL EQU   X'10'                   LOCAL\nPAREBPF  EQU   X'08'                   CACHED DEVICE\nPARESPP  EQU   X'04'                   SET PAGING PARAMETERS OK\nPAREPD   EQU   X'02'                   PAGEDEL IN PROCESS\nPAREDRN  EQU   X'01'                   DAINING\nPAREFLG1 DS    B             +9\nPARENUSE EQU   X'80'                   NOT IN USE\nPARENVIO EQU   X'10'                   VIO=NO\nPARENN   DS    H             +A\nPAREDEIB DS    A             +C        POINTER TO DEIB\nPARESZSL DS    F             +10       SIZE OF DATA SET (IN SLOTS)\nPARESLTA DS    F             +14       NUMBER OF AVAILABLE SLOTS\nPARERRCT DS    F             +18       NUMBER OF PERMANENT I/O ERRORS\nPAREIORB DS    A             +1C       ADDR OF 1ST IORB\nPAREPATP DS    A             +20       POINTER TO PAT\nPAREPCTP DS    A             +24       POINTER TO PCT\nPAREEDBP DS    A             +28       POINTER TO EDB\nPAREUCBP DS    A             +2C       POINTER TO UCB\nPARETIOR DS    A             +30\nPARETIME DS    F             +34\nPARERQTM DS    F             +38       LATEST REQUEST SERVICE TIME\n         DS    H             +3C       RESERVED\nPAREREQS DS    H             +3E       OUTSTANDING I/O REQUESTS\nPAREFLG2 DS    B             +40       FLAGS\nPARELSLT DS    XL3           +41       WRITE CURSOR\nPAREOCTB DS    A             +44       OLD CTB ADDR\nPAREMIGA DS    A             +48       MIGRATED SLOT COUNT\nPARECADR DS    FL1           +4C       INDEX NUMBER FOR CACHE ENTRY\n         DS    XL19          +4D       RESERVED\nPARTELEN EQU   *-PARTENT               96 BYTES\n         IKJTSVT                       TSO VECTOR TABLE\n         AIF   ('&SYSSPLV' LT '2').SPL4X     LOW MACLIB LEVEL, JUMP\nTPVT     DSECT ,                       TSO PARMLIB vector table\nTPVTTPVT DS    C'TPVT'                 BLOCK ID\n         AIF   ('&SYSSPLV' LT '3').SPL4A     NOT MVS/ESA MACLIB, JUMP\nTPVTLEN  DS    H'72'                   LENGTH OF TPVT\nTPVTLVL  DS    X'02'                   LEVEL\nTPVTMBR  DS    C'IKJTSO00'             CURRENT PARMLIB MEMBER\n         DS    X,4X                    UNUSED\nTPVTCTLT DS    A(CTLT),F'60'           IKJCTLT\n         DS    4X                      UNUSED\nTPVTSCB  DS    V(SCB)                  IKJEESCB   (SYS1.BRODCAST)\nTPVTALPL DS    V(ALPL)                 ?\nTPVTTPT  DS    V(TPT)                  ?\nTPVTXPRM DS    V(XPRM)                 INMXPARM   (XMIT)\nTPVTCNPR DS    V(CNPRM)                IKJCNPRM   (CONSOLE)\n         DS    8X                      UNUSED\nTPVTHCB  DS    V(HCB)                  IKJEFHCB   (HELP)\n         DS    8X                      UNUSED\n         AGO   .SPL4B\n.SPL4A   ANOP\nTPVTLEN  DS    H'44'                   LENGTH OF TPVT\nTPVTLVL  DS    X'01'                   LEVEL\n         DS    X                       UNUSED\nTPVTCTLT DS    A(CTLT)                 IKJCTLT\n         DS    4X                      UNUSED\nTPVTEXTV DS    V(EXTV)                 ?\nTPVTSCB  DS    V(SCB)                  IKJEESCB   (SYS1.BRODCAST)\n         DS    20X                     UNUSED\n.SPL4B   ANOP\nCTLT     DSECT\nCTLTCTLT DS    C'CTLT'                 BLOCK ID\n         AIF   ('&SYSSPLV' LT '3').SPL4C     NOT MVS/ESA MACLIB, JUMP\nCTLTLEN  DS    H'60'                   LENGTH OF TPVT\nCTLTLVL  DS    X'02'                   LEVEL\n         AGO   .SPL4D\n.SPL4C   ANOP\nCTLTLEN  DS    H'48'                   LENGTH OF TPVT\nCTLTLVL  DS    X'01'                   LEVEL\n.SPL4D   DS    X                       UNUSED\nCTLTE2   DS    A,F,H,H                 IKJEFTE2\nCTLTE8   DS    A,F,H,H                 IKJEFTE2\nCTLTNS   DS    A,F,H,H                 IKJEFTNS\nCTLTAP   DS    A,F,H,H                 IKJEFTAP\n.SPL4X   IEESMCA                       SMF\n*        IEEMBRDS ,                    SMF RDS                     ****\nIEEMBRDS DSECT ,\nRDSID    DS    C'RDS '                 CONTROL BLOCK ID\nRDSNEXT  DS    A(IEEMBRDS)             FORWARD CHAIN POINTER\nRDSPREV  DS    A(IEEMBRDS)             BACKWARD CHAIN POINTER\n*\nRDSFLG1  DS    X\nRDSFREE  EQU   X'10'                   NEED TO FREE DATASET\nRDSDUMP  EQU   X'08'                   OPER HAS BEEN TOLD TO DUMP DS\nRDSREADY EQU   X'04'                   DS IS OPEN AND READY\nRDSCLOSE EQU   X'02'                   DS NEEDS TO BE CLOSED\nRDSNDOP  EQU   X'01'                   DS NEEDS TO BE OPENED\n*\nRDSFLG2  DS    X\nRDSLOST  EQU   X'80'                   DUMMY RDS FOR LOST DATA\nRDSPHYER EQU   X'40'                   PHYSICAL I/O ERROR\nRDSLOGER EQU   X'20'                   LOGICAL I/O ERROR\n*\nRDSFLG3  DS    X                       RESERVED\nRDSFLG4  DS    X                       RESERVED\nRDSNAME  DS    C'SYS1.MANX '           DATASET NAME\nRDSVOLID DS    C'SYSRES'               VOLUME SERIAL\nRDSDDN   DS    C'SYS00001'             DDNAME RETND BY DYNALLOC\nRDSCAPTY DS    F                       CAPACITY IN # OF BLOCKS\nRDSNXTBL DS    F                       NUMBER OF NEXT AVAIL BLOCK\nRDSBQE   DS    F                       ADDR OF BQE BEING WRITTEN\nRDSAVSPC DS    F                       AVAIL SPACE FROM SHOWCB\nRDSENRBA DS    F                       ENDRBA FROM SHOWCB\nRDSCINV  DS    F                       CONTROL INTERVAL SIZE\nRDSDOMID DS    F                       MSG # OF DUMP MSG\nRDSRPL   DS    19F                     VSAM RPL\nRDSACB   DS    19F                     VSAM ACB\n         IEFTCT ,                      SMF TCT\n         ICHPRCVT ,                    RACF <=== CVTRAC            EU07\n         ICHPDSDT ,                    RACF <=== RCVTDSDT          EU11\n*        ARCQCT                        HSM                         ****\nMQCT     DSECT                         ARCACT <=== CVTHSM\n         ORG   *+X'002C'\nMQCTID   DS    C'QCT*'                 BLOCK ID\nMQCTVER  DS    C' 2'                   VERSION\nMQCTREL  DS    C'5'                    RELEASE\nMQCTMOD  DS    C'0'                    MODIFICATION\n         IHALPDE ,                     LPA DIRECTORY ENTRY\n         IHAASCB DSECT=YES             ADDRESS SPACE CONTROL BLOCK\n         IHAASVT DSECT=YES             ADDRESS SPACE VECTOR TABLE\n         IHAASXB DSECT=YES         MAP THE ASXB.\n         IHAACEE ,                 MAP THE ACEE.\n         IRAOUCB DSECT=YES             SRM PARMS\n*        IRARMCT DSECT=YES                                         ****\nRMCT     DSECT                     RESOURCE MANAGER CONTROL TABLE\nRMCTNAME DS    C'RMCT' -           BLOCK IDENTIFICATION\nRMCTCCT  DS    V(CCT) -            CPU MANAGEMENT CONTROL TABLE\nRMCTICT  DS    V(ICT) -            I/O MANAGEMENT CONTROL TABLE\nRMCTMCT  DS    V(MCT) -            STORAGE MANAGEMENT CONTROL TABLE\nRMCTRMPT DS    V(RMPT) -           CTL ALGORITHM PARAMETER TABLE\nRMCTRMCA DS    V(RMCA) -           CTL ALGORITHM CONTROL AREA\nRMCTWMST DS    A(0) -              ADDR OF WLM SPECIFICATION TABLE\nRMCTRLCT DS    A(0) -              ADDR OF LOGICAL CHANNEL MGMT TABLE\nRMCTRMSA DS    A(0) -              ADDR OF RESOURCES MANAGER SAVE AREA\nRMCTRMPD DS    A(0) -              ADDR OF RESOURCES MANAGER PERF DATA\nRMCTRMEX DS    V(RMEX) -           ROUTINE EXITING VECTOR TABLE\nRMCTRMSB DS    V(RMSB) -           SUBROUTINE CALLING VECTOR TABLE\nRMCTEPPA DS    V(IRAEPPA) -        PRTL ANALYSIS ENTRY TABLE\nRMCTEPDT DS    V(EPDTSCN) -        USER ACTION ENTRY TABLE\nRMCTEPAT DS    V(EPATSCN) -        ALGORITHM ENTRY TABLE\nRMCTEPBG DS    V(EPAT) -           ADDR OF ALG ENTRY PT TABLE\nRMCTADJC DS    F'0' -              ADJUSTMENT FACTOR FOR CPU RATE\nRMCTITT  DS    V(IRASECHT) -       INTFC EVENT CHARACTERISTICS TABLE\nRMCTEPET DS    V(IRAPRCSR) -       EVENT ROUTING VECTOR TABLE\nRMCTFLTM DS    V(IRAFLTM) -        TIME OF DAY ADJUST VECTOR TABLE\nRMCTEPPR DS    V(IRAEPPR) -        PROCESS RATE DEPENDENT ENTRY TABLE\nRMCTWAST DS    A(0) -              ADDR OF WAR SPECIFICATION TABLE\nRMCTWAMT DS    A(0) -              ADDR OF WAR MEASUREMENT TABLE\nRMCTTMQE DS    V(IRACTMQE) -       SCHEDULED RTNE QUEUE HEADER ADDR\nRMCTAQCT DS    F'0' -              ACTION QUEUE MEMBER COUNT\nRMCTAQHD DS    V(IRAOUCB) -        ACTION QUEUE FORWARD POINTER\nRMCTWTQE DS    V(IRAWTQE) -        WAIT - QUEUE HEADER BLOCK ADDRESS\nRMCTOTQE DS    V(IRAOTQE) -        OUT - QUEUE HEADER BLOCK ADDRESS\nRMCTINQE DS    V(IRAINQE) -        IN - QUEUE HEADER BLOCK ADDRESS\nRMCTR10  DS    F'0' -              RESERVED\nRMCTTBS  DS    F'0' -              STARTING TIME BASE FOR TIME OF DAY\nRMCTTOD  DS    F'0' -              TIME OF DAY - SYST RSRC MGR INVOKE\nRMCTTOC  DS    D'0' -              TIME OF CENTURY - 64BIT BINARY NMB\nRMCTALA  DS    4B'00000000' -      ALGORITHM REQUEST ACCUMULATOR FIELD\nRMCTALR  DS    4B'00000000' -      IMMEDIATE ALGORITHM REQUEST FIELD\nRMCTRQSV DS    V(RQSV) -           ADDR OF REQ SRV DATA AREA\nRMCTFLGS DS    1B'00000000' -      PROCESSING CONTROL FLAGS\nRMCTMFA  EQU   BIT0 -              MEASUREMENT FACILITY ACTIVE\nRMCTCPS1 EQU   BIT1                CAP SWITCH\nRMCTINIT EQU   BIT3 -              SRM INITIALIZATION WAS PERFORMED\nRMCTRSV1 EQU   BIT4 -              RESERVED\nRMCTSTW  EQU   BIT5 -              SET HAS STOPPED WAR COLLECTION\nRMCTRSV2 EQU   BIT6 -              RESERVED\n         DS    1B'00000000' -      OVERRIDE CONDITION FLAGS\nRMCTMFS  EQU   BIT1 -              MF1 ACTIVE,SET IPS RCVD\nRMCTTAPE DS    X,X                     SELTAPE\nRMCTSLTN EQU   X'80'                     NEXT\nRMCTSLTR EQU   X'40'                     RANDOM\nRMCTSLTL EQU   X'20'                     LAST\nRMCTSLTF EQU   X'10'                     FIRST\nRMCTTELM DS    V(IEATSELM) -       RESOURCES MANAGER TIMING ELEMENT\nRMCTCPID DS    C'RM1',X'03' -      RESOURCES MANAGER CELL POOL ID\nRMCTTOCI DS    D'0' -              CLOCK READ AREA - 64BIT BINARY NMB\nRMCTOUCB DS    V(IRAOUCB) -        PREASSEMBLED MODEL OUCB\nRMCTOUXB DS    V(IRAOUXB) -        INTERPOSED DUMMY OUXB\nRMCTSRBT DS    V(IRASRBT) -        RESOURCES MANAGER SRB TABLE\nRMCTDMDT DS    A(DMDT)             ADDR OF DOMAIN TABLE\nRMCTDMDE DS    A(DMDT)             ADDR OF LAST DMN TAB ENTRY\nRMCTDMNC DS    H'0' -              NUMBER OF DOMAINS\n         DS    H,7F\nRMCTICST DS    V(ICST)             ICS TABLE\n*        IRACCT DSECT=YES                                          ****\nCCT      DSECT , -                 CPU MANAGEMENT CONTROL TABLE\nCCTCCT   DS    C'CCT '  -          ACRONYM IN EBCDIC -CCT-\nCCCAPMET DS    F'200' -            MINIMUM USER EXECUTION INTERVAL FOR\n*                                  MEAN TIME TO WAIT COMPUTATION\nCCCR00   DS    F'0'                RESERVED\nCCCMNSIN DS    F'5000' -           MINIMUM INTERVAL FOR COMPUTING\n*        APG DISPATCHING PRIORITY COMPUTATION CONSTANTS\nCCCR000  DS    H'0'                RESERVED\nCCCAPGHI DS    H'0'                APG HIGH VALUE\nCCCAPLDP DS    H'1' -              DP FOR UNDISPATCHED APG USERS\nCCCAPGLO DS    H'0'                APG LOW  VALUE\nCCCAPLEN DS    H'0'                LENGTH OF MTW GROUPS 1\n*        IRARMPT DSECT=YES                                         ****\nRMPT     DSECT                         SRM PARAM TABLE (IRARMPT)\n         DC    C'RMPT'\n         ORG   RMPT+X'53'\nRMPTOPTN DC    C'00'                   SYS1.PARMLIB(IEAIPSXX)\n*        IRAWMST DSECT=YES                                         ****\nWMST     DSECT                         WORKLOAD MGR SPECIFICATIONS TBLE\n         DC    C'WMST'\nWMSTID   DC    C'00'                   SYS1.PARMLIB(IEAIPSXX)\nWMSTIPC  EQU   WMST+X'94',4            CPU SERVICE COEFFICIENT\nWMSTIPI  EQU   WMST+X'98',4            I/O SERVICE COEFFICIENT\nWMSTIPM  EQU   WMST+X'9C',4            MSO SERVICE COEFFICIENT     EU05\nWMSTIPB  EQU   WMST+X'A0',4            SRB SERVICE COEFFICIENT\n*        IRAICST DSECT=YES                                         ****\nICST     DSECT                         SRM ICS TABLE\nICSTID   DC    C'00'                   SYS1.PARMLIB(IEAICSXX)\n*\n*        SRM DOMAIN TABLE (IRADMDT)\n*\n*        THIS MAPPING IS VALID FOR MVS/XA THROUGH MVS/ESA 4.1.\n*        STARTING WITH MVS/ESA 4.2, THE DOMAIN TABLE ENTRIES ARE\n*        X'B4' BYTES LONG.\n*\n*        IRADMDT DSECT=YES                                         ****\nDMDT     DSECT\nDMDTNO   DS    FL1,X,X                 DOMAIN NUMBER\nDMDTWT   DS    FL1                     WEIGHTING FACTOR\nDMDTMPLT DS    H                       CURRENT MPL TARGET\nDMDTRUA  DS    H,2X                    AVG # OF READY USERS * 16\nDMDTCMPL DS    H                       CURRENT MPL\nDMDTOUTU DS    H                       USERS SWAPPED OUT\nDMDTINCU DS    H                       INCORE USERS\nDMDTRUC  DS    F,F                     ACCUM FOR READY USER AVG\nDMDTTWSR DS    F                       WEIGHTED INTVL DMN SVCE\nDMDTAOBJ DS    FL1                     USER PERF OBJ NUMBER\nDMDTDOBJ DS    FL1                     USER PERF OBJ NUMBER\nDMDTFWKL DS    FL2                     DOMAIN FIXED WKLD * 256\nDMDTCIDX DS    FL2                     CONTENTION INDEX\nDMDTNSW  DS    H                       NON-SWAPPABLE USERS\nDMDTRUMX DS    H                       MAX # READY USERS IN INTVL\nDMDTFLGS DS    X,X                     FLAGS\nDMDTTRNC DS    F                       XACTN COUNT FOR RTO\nDMDTTRNT DS    F                       ELAPSED TIME ACCUM FOR RTO\nDMDTTWET DS    F                       ELAPSED TIME AVG FOR RTO\nDMDTLO   DS    H                       MIN MPL\nDMDTHI   DS    H                       MAX MPL\nDMDTHIRV DS    V(ASCB),4X              USER WITH MAX RECOMMENDATION VAL\nDMDTEND  EQU   *                X'40'\n         YREGS                         REGISTER EQUATES\n         IEZBITS                       BIT0-BIT7\n         AIF   (NOT D'DFASMS).SMS4     NOT DFP V3, JUMP\n         IEFJSSIB                      SSIB\n         IEFJSSOB ,                    SSOB header\n         IEFSSSA                       SSOB extension for SMS\n         IGDVLD                        Volume record definition\n.SMS4    PRINT &EULST                                              EU00\n         EJECT\n*======================================================================\n*        GENERATE SUB-RTNE & LITERALS\n*----------------------------------------------------------------------\n         SPACE 1\n         STRING FINAL_CALL,DOC=YES                                 EU00\n         EJECT\n*======================================================================\n*        LITERAL POOL\n*----------------------------------------------------------------------\n         PRINT GEN                                                 EU00\n         LTORG\n         EJECT\n*======================================================================\n*        MESSAGES (LOG) DEFINITIONS\n*----------------------------------------------------------------------\n         PRINT &EULST                                              EU00\nWTOSK0   WTO   '-- Output dynamically allocated to TSO session as SYSOUX\n               T=&SYSOHC --',ROUTCDE=11,DESC=7,MF=L                EU13\nWTOSK1   WTO   '-- PARM= error at :                                --',X\n               ROUTCDE=11,DESC=7,MF=L                              EU15\nWTOSK1M  EQU   24,30                                               EU15\nWTOSK1L  EQU   *-WTOSK1                                            EU15\nWTOSK2   WTO   '-- ISPLINK :          failed - RC =     -- ',          X\n               ROUTCDE=11,DESC=7,MF=L\nWTOSK2N  EQU   17,8\nWTOSK2R  EQU   39,4\nWTOSK2L  EQU   *-WTOSK2\nWTOSK3   WTO   '-- Dynamic allocation error - RC =     REASON=     INFOX\n               =     --',ROUTCDE=11,DESC=7,MF=L\nWTOSK3C  EQU   38,4\nWTOSK3R  EQU   50,4\nWTOSK3I  EQU   60,4\nWTOSK3L  EQU   *-WTOSK3\n         AIF   (NOT D'DFASMS).SMS5     NOT DFP V3, JUMP\nWTOSK4   WTO   '-- DEVSTAT 4K storage unavailable (increment \"NLBRIF\" vX\n               alue --',ROUTCDE=11,DESC=7,MF=L\n.SMS5    ANOP\nWTOSK5   WTO   '-- Dynamic storage area shortage (increment \"NLBRIF\" vaX\n               lue --',ROUTCDE=11,DESC=7,MF=L\nWTOSK6   WTO   '-- Requested FILE(        ) not pre-allocated -- ',    X\n               ROUTCDE=11,DESC=7,MF=L                              EU15\nWTOSK6N  EQU   22,8                                                EU15\nWTOSK6T  EQU   30,22                                               EU15\nWTOSK6L  EQU   *-WTOSK6                                            EU15\nWTOSK7   WTO   '-- Sub-Task ATTACH failed - RC =     --',              X\n               ROUTCDE=11,DESC=7,MF=L\nWTOSK7C  EQU   36,4\nWTOSK7L  EQU   *-WTOSK7\nWTOSK8   WTO   '-- Output file : OPEN failed - RC =     --',           X\n               ROUTCDE=11,DESC=7,MF=L\nWTOSK8C  EQU   39,4\nWTOSK8L  EQU   *-WTOSK8\nWTOSK9   WTO   '-- Output file : OPEN unsuccessfully complete --',     X\n               ROUTCDE=11,DESC=7,MF=L\nWTOSK10  WTO   '-- Output file : CLOSE failed - RC =     --',          X\n               ROUTCDE=11,DESC=7,MF=L\nWTOSK10C EQU   40,4\nWTOSK10L EQU   *-WTOSK10\nWTOSK11  WTO   '-- Output file : PUT error has occurred --',           X\n               ROUTCDE=11,DESC=7,MF=L\nWTOSK12  WTO   '-- Output file : invalid LRECL (must be 101) --',      X\n               ROUTCDE=11,DESC=7,MF=L\nWTOSK13  WTO   '-- Output file : invalid RECFM (must be Fixed) --',    X\n               ROUTCDE=11,DESC=7,MF=L\nWTOSK14  WTO   '-- Output file : invalid RECFM (must be ASA) --',      X\n               ROUTCDE=11,DESC=7,MF=L\nWTOSK15  WTO   '-- Output file : invalid BLKSIZE (not multiple of 101) X\n               --',ROUTCDE=11,DESC=7,MF=L\n         PRINT GEN                                                 EU00\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SHOWMVS$": {"ttr": 15107, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x942\\x7f\\x00\\x942\\x7f\\x14$\\x00\\x17\\x00\\x17\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-23T00:00:00", "modifydate": "1994-11-23T14:24:00", "lines": 23, "newlines": 23, "modlines": 0, "user": "SYSPAJA"}, "text": "//SHOWMVS  JOB (........),'INSTALL  -SHOWMVS-',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=1M,TIME=1\n/*JOBPARM L=15\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//*      THE ASSEMBLY SYSPARM(...) OPTIONS ALLOWS YOU TO SELECT :     *\n//*            1. NONE OR OMITTED = NO LIST OF MACROS DEVELOPMENT     *\n//*               STRING = LIST ONLY STRING MACROS DEVELOPMENT        *\n//*               FULL = LIST ALL MACROS DEVELOPMENT                  *\n//*            2. NONE = SKIP JES2 DATA INFORMATION ASSEMBLY          *\n//*               JES2 OR OMITTED = GENERATE JES2 DATA INFORMATION    *\n//*                          N.B. - SYS1.HASPSRC TO SYSLIB DD-NAME    *\n//*                                 CONCATENATION NEEDED              *\n//*      SPECIFY OPTIONS AT ASSEMBLY STEP 'ASS' :                     *\n//*      I.E - ... EXEC PAJ1AS4,MBR=SHOWMVS,OPT=',SYSPARM(FULL)'      *\n//*            ... EXEC PAJ1AS3,MBR=SHOWMVS,OPT=',SYSPARM(,NONE)'     *\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//ASS     EXEC PAJ1AS4,MBR=SHOWMVS\n//LNK     EXEC PAJILKC,OPT=',MAP,RENT,AC=1'\n//SYSIN     DD *\n  ENTRY   SHOWMVS\n  NAME    SHOWMVS(R)\n/*\n//HLP     EXEC PAJHELP,MBR=SHOWMVSH,DSS='->.SOURCE.FILE1'\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SHOWMVS@": {"ttr": 15109, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x93'/\\x00\\x93'/\\x10\\x18\\x00z\\x00z\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-09-29T00:00:00", "modifydate": "1993-09-29T10:18:00", "lines": 122, "newlines": 122, "modlines": 0, "user": "SYSPAJA"}, "text": "1   29/09/93\n                                                      SHOWMVS   1/3.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *            S H O W M V S            * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  CBT origin : extracted from CBT tape 93 FEB, file 183.\n  ------------\n\n  FUNCTION : program/command - displays various information about the\n  ---------- MVS system you're running on.\n             This program runs under ISPF/PDF and displays a lot of\n             information that you generally have to get from different\n             sources. It uses the BRIF services to display the data,\n             which makes it easier to browse through hundreds of\n             lines of output. It shows you the following :\n                 MVS level, DFP level, OSLVL flags, JES2 level\n                 IPL date, time, VOLSER, NUC-ID, CLPA, CVTUSER\n                 Product level for : TSO/E, ISPF, DFDSS, HSM,\n                                     RACF,  VTAM, (DB2), SORT\n                 PPT table list\n                 Name and status of the RACF data-sets\n                 SMF data : SID, JWT, GRS' SNAME, SYS1.MANx\n                 On-line CPU's, processor speed in MIPS\n                 On-line storage (real and extended)\n                 Virtual storage map (CSA, SQA, LPA, etc)\n                 Resource Manager (SRM) parameters and domains\n                 OPEN catalogs\n                 PAGE data sets in use\n                 Name and status of SYS1.DUMP data sets\n                 Sub-system vector table with functions processed\n                 JES2 data information\n                 TCAS data (requires SHOWMVS to run authorized)\n                 TSO PARMLIB data\n                 Address Space Usage, active Jobs, TSU's, STC's\n                 Active LPA queue (MLPA, FLPA)\n                 SVC table with name of corresponding LPA module\n                 T1, T2, T3 and T6 ESR tables\n                 Link-list data sets, with creation date\n                 LPA-list data sets, with creation date\n                 List of authorized libraries, with creation date\n                 Device classes and corresponding unit-names\n                 On-line devices, with type, volser, status, owner\n                     label type (tapes), SMS storage group\n                 System consoles, with status and routcde list\n                 LNKLST, LPALST and APFLST lists cross-reference each\n                     other to help you keep them up-to-date\n                 Device status is refreshed when you hit \"enter\"\n             SHOWMVS also displays some information related to your\n             own TSO session :\n                   The RACF and TSO profiles\n                   The TCB tree and PRB chains\n                   Allocated ddnames, with DSN and EXCP count\n                   Enhanced view of the JPAQ and load-lists\n1   19/07/93\n                                                      SHOWMVS   2/3.\n\n             SHOWMVS can run in batch or as a TSO command and write\n             the output to a QSAM data-set instead of displaying the\n             data via BRIF (when invoked under ISPF not authorized).\n             Normally SHOWMVS output is in lower case, but if you want\n             to print it in lower case, you must invoke it as :\n                   1. a program and specify PARM=CAPS, or\n                   2. a command and specify CAPS operand.\n             If a SHOWMVS DD-name data-set is pre-allocated (QSAM DCB\n             with REFCM=FBA,LRECL=101), then the output print is always\n             written on it.\n             When not present, the following action is taken :\n             1. in a TSO/ISPF environment, the output is displayed on\n                the terminal,\n             2. in a TSO only environment (background-job/foreground-\n                session) the output is written on a SYSOUT data-set\n                in HOLD status class and dynamically allocated,\n             3. in a Batch program environment, the output is written\n                on a SYSOUT=* data-set dynamically allocated with the\n                DD-name SHOWMVS.\n             Additional PARM= options or command operands :\n             1. DDN(...) to use an alternate DD-name (default name is\n                         SHOWMVS).\n                         Mandatory : when this keyword is used the FILE\n                         =========== must be pre-allocated.\n             2. LPG(...) to set the number of Lines per Page (default\n                         is 60).\n             3. PGN(...) to set the starting Page Number, it's the\n                         initial page count (default is 1).\n             4. HPG(YES/NO) to have or not have the heading at top of\n                         all pages (default is YES).\n                         HPG(NO) conflicts with PGN(...).\n             Note: each option must be separated from the other by at\n                   least a blank or comma.\n             Ex. - program EXEC statement:\n                         PARM='CAPS,DDN(MYPRINT),LPG(50),PGN(10)'\n                   TSO command operands:\n                         SHOWMVS CAPS DDN(MYPRINT) LPG(50) PGN(10)\n             Also the LINK, ATTACH or LOAD/CALL/DELETE macros\n             instructions can be used to invoke SHOWMVS from another\n             program/command (be careful to AMODE).\n             The format must be as follows :\n                     ...  LINK/ATTACH  EP=SHOWMVS,\n                                       PARAM=(optaddr),VL=1\n                     ...  LOAD  EP=SHOWMVS\n                          LR    R15,R0  <--- (*) see Note below\n                          CALL  (15),\n                                (optaddr),VL=1\n                          DELETE  EP=SHOWMVS\n             where \"optaddr\" specifies the address of the option list\n                   (equivalent to PARM= parameter of an EXEC statement\n                   and must be present).\n             (*) Note: after the LOAD bit0 of R0 = AMODE, so may be you\n                       must use BASSM / BSM, and bit0 of R1 = AC code.\n1   19/07/93\n                                                      SHOWMVS   3/3.\n\n             Typical Parameter List :\n                     R1 = address of A(optaddr+X'80000000')\n                                  0F'0',H'0'\n                     optaddr ---> H'0'\n                               or H'4',C'CAPS'\n                               or H'25',C'CAPS DDN(MYPRINT) LPG(50)'\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SHOWMVSH": {"ttr": 15112, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x93%/\\x00\\x93%/\\x14S\\x00\\x19\\x00\\x19\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-09-09T00:00:00", "modifydate": "1993-09-09T14:53:00", "lines": 25, "newlines": 25, "modlines": 0, "user": "SYSPAJA"}, "text": "./     ADD     NAME=SHOWMVS\n./     NUMBER  NEW1=100,INCR=100\n)F Function : Program/Command - displays various information about the\n              MVS system you're running on.\n              SHOWMVS can run in batch or as a TSO command and write\n              the output to a QSAM data-set instead of displaying the\n              data via BRIF (when invoked under ISPF-panel).\n)X Syntax :   SHOWMVS Options\n              or the SH select option (ISPF main panel, if supplied)\n              to SUBMIT it as a Batch job.\n)O Operands : None required.\n))CAPS :      C or CAPS if you want to print it in upper case.\n              Default : normally SHOWMVS output is in lower case.\n))DDN :       D(...) or DDN(...) to use an alternate DD-name.\n              Default : SHOWMVS DD-name.\n              Mandatory : when this keyword is used the FILE must be\n                          pre-allocated.\n))LPG :       L(...) or LPG(...) to set the number of Lines per Page.\n              Default : 60.\n))PGN :       P(...) or PGN(...) to set starting Page Number, it's the\n              initial page count. Default : 1.\n))HPG :       H(YES/NO) or HPG(YES/NO) to have or not have the heading\n              at top of all pages. Default : YES.\n              HPG(NO) conflicts with PGN(...).\n./     ENDUP\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "STATDS": {"ttr": 15114, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x12o\\x00\\x94\\x12o\\tY\\x07\\x10\\x07\\x10\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-05-06T00:00:00", "modifydate": "1994-05-06T09:59:00", "lines": 1808, "newlines": 1808, "modlines": 0, "user": "SYSPAJA"}, "text": "STDS     TITLE 'DISK DATA-SET STATISTICS PROGRAM.'\n* PURPOSE :        COMPUTE DATA-SET USEAGE STATISTICS FOR DISK\n* ---------        DATA-SETS.\n*\n* MVS/XA :         MUST BE AMODE AND RMODE 24.\n* --------\n*\n* AUTHOR :         A. BRUCE LELAND\n* --------         ADD'S BY : 1. BILL GODFREY\n*                                PRC COMPUTER CENTER INC.\n*                                MCLEAN, VIRGINIA\n*                             2. P.A. MOINIL\n*                                COMPUTING CENTRE (TP 361)\n*                                J.R.C. - ISPRA ESTABLISHMENT\n*                                21020 ISPRA (VA), ITALY\n*\n* DESCRIPTION :    THIS PROGRAM FORMATS INFORMATION ON ANY DISK\n* -------------    DATA-SET. IT READS THROUGH THE ENTIRE DATA-SET AND\n*                  OUTPUTS DISK TRACK USAGE, BLOCKSIZE AND OTHER\n*                  STATISTICS.\n*\n* OPERATION :\n* -----------\n*        A. THE PROGRAM GETS THE INPUT DATA-SET NAME AND VOLUME SERIAL\n*           NUMBER VIA \"RDJFCB\".\n*        B. THE PROGRAM INPUTS THE FORMAT 1 DSCB TO DETERMINE OTHER\n*           DATA-SET CHARACTERISTICS.\n*        C. THE PROGRAM OPENS THE INPUT FILE, THEN FORMATS AND\n*           OUTPUTS DEB AND DSCB INFORMATION.\n*        D. IF A PARM OF \"LABEL\" IS NOT CODED, THE PROGRAM READS\n*           EACH BLOCK OF DATA IN THE DATA-SET AND COLLECTS RECORD\n*           COUNTS, RECORD SIZE AND TRACK USEAGE STATISTICS.\n*        E. ADDITIONAL PROCESSING :\n*           1. FOR DSORG=PS, NONE.\n*           2. FOR DSORG=DA, NONE.\n*           3. FOR DSORG=IS, THE PROGRAM READS THROUGH THE ENTIRE\n*              DATA-SET (THERE MAY BE UP TO THREE SEPARATE FILES OF\n*              DATA AND REPORTS ON EACH FILE). ALSO, THE PROGRAM\n*              INPUTS THE ISAM LABEL (FORMAT TWO DSCB) RECORD AND\n*              PROVIDES A DATA-SET PROFILE WHICH INCLUDES DATA-SET\n*              REORGANIZATION DATA AND DATA-SET CHARACTERISTICS.\n         EJECT\n*           4. FOR DSORG=PO, THE PROGRAM COMPARES DIRECTORY TTR'S\n*              AGAINST ACTUAL DISK ADDRESSES TO DETERMINE THE TTRS\n*              OF \"GAS\" MEMBERS (THE PROGRAM ALSO OUTPUTS THE FIRST\n*              72 CHARACTERS OF ANY GAS MEMBER). STATISTICS ARE\n*              MAINTAINED ON THE SIZE OF GAS AND REAL MEMBERS AND\n*              THE NUMBER OF ALIAS MEMBERS.\n*              IF ANY ALIASES ARE IN THE DATA-SET, A CHECK IS MADE\n*              TO SEE THAT CORRESPONDING REAL ENTRIES ALSO EXIST.\n*              THE PROGRAM FINDS \"GAS\" MEMBERS ONLY IF THE DATA-SET\n*              HAS NOT BEEN COMPRESSED OUT YET.\n*              OPTIONS WHICH MAY BE SELECTED THROUGH THE PARM :\n*              1. A PARM OF 'NO' WILL NULLIFY THE GAS TTR REPORT.\n*              2. A PARM OF 'FULL' WILL PRODUCE THE LIST OF ALL\n*                 DIRECTORY MEMBERS.\n*              3. A PARM OF 'GAS(TT.TT.RR)' WILL ADD A MEMBER NAME\n*                 TO THE DIRECTORY FOR THE \"GAS\" MEMBER HAVING THE\n*                 SPECIFIED TTR LOCATION (IN HEX, OBTAINED FROM A\n*                 PREVIOUS RUN). THIS IS USEFULL IF YOU KNOW WHICH\n*                 ONE YOU WANT. ANY USER DATA THAT WAS IN THE\n*                 DIRECTORY ENTRY OF A DELETED OR REPLACED MEMBER\n*                 CANNOT BE RECOVERED.\n*                 A PARM OF 'GAS(ALL)' ALLOWS TO RECOVER ALL \"GAS\"\n*                 MEMBERS IN A DATA-SET.\n*              -- NOTE ABOUT LOAD MODULES - THIS PROGRAM CANNOT\n*                 RECOVER A \"GAS\" LOAD MODULE. IT WILL GIVE IT A\n*                 MEMBER NAME SO IT WONT BE COMPRESSED OUT, BUT THE\n*                 DIRECTORY ENTRY WILL NOT BE A LOAD MODULE TYPE.\n*                 TO RECONSTRUCT THE PROPER LOAD MODULE DIRECTORY\n*                 WOULD REQUIRE INFORMATION THAT IS NO LONGER IN\n*                 THE PARTITIONED DATA-SET.\n*              4. A PARM OF 'TEST' MAY BE USED TO OBTAIN MBBCCHHR'S\n*                 TRACE (ON 'TRC').\n*\n* FILE NAMES : DD-NAME 'IN'  - INPUT DATA-SET.\n* ------------ DD-NAME 'OUT' - OUTPUT LIST.\n*              DD-NAME 'TRC' - TRACE LIST (SEE 'TEST' OPTION).\n*\n* TSO ACCESS : USE %STATDS COMMAND TO INVOKE THE CLIST DESCRIBED BELOW.\n* ------------\n*              PROC   1 DSN PARM() DSOUT(*)\n*              ALLOC  F(IN) DA(&DSN.) SHR\n*              ALLOC  F(OUT) DA(&DSOUT.)\n*              STATS  &PARM\n*              FREE   F(IN OUT)\n*              TSO    END\n         EJECT\n         MACRO\n&LBL    OUTPT  &R0,&R1,&LN=50,&A=I OUTPUT MACRO\n&LBL     LA    R15,&LN             LENGTH OF STRING\n         AIF   ('&R0' EQ 'R0').NOR0\n         L     R0,&R0              NUMBER TO BE OUTPUT\n.NOR0    AIF   ('&R1' EQ 'R1').NOR2\n         AIF   ('&A' EQ 'I').NOR1\n         LA    R1,&R1              STRING TO FOLLOW\n         AGO   .NOR2\n.NOR1    L     R1,=A(&R1)          ADDRESS OF STRING TO FOLLOW\n.NOR2    BAS   R14,OUTRTN          OUTPUT ROUTINE\n         AIF   ('&R1' NE 'WORK').MEND\n         MVC   WORK,BLANKS\n.MEND    MEND\n         SPACE 1\n         MACRO\n&LBL    TTRMBB &TTR,&MBB=DOUBLE    TTR TO MBBCCHHR CONVERSION MACRO\n&LBL     STM   R14,R12,12(R13)\n         XR    R0,R0\n         ICM   R0,B'1110',&TTR     GET TTR INTO R0\n         L     R1,DCBDEBAD         DEB ADDRESS\n         LA    R2,&MBB             RESULT ADDRESS\n         LR    R3,R13              SAVE SAVEAREA REGISTER\n         L     R15,CVTPTR          CVT POINTER\n         USING CVT,R15             CVT ADDRESSABILITY\n         L     R15,CVTPCNVT        TTRN TO MBBCCHHR ROUTINE ADDRESS\n         DROP  R15\n         BASR  R14,R15\n         LR    R13,R3\n         LM    R14,R12,12(R13)\n         MEND\n         SPACE 1\n         MACRO\n&LBL    KILL   &N                  GO TO \"ABEND WITH DUMP\" MACRO\n&LBL     LA    R1,&N               SET ABEND CODE\n         B     GDMP                GO TO ABEND WITH DUMP.\n         MEND\n         EJECT\n         MACRO\n&LBL    HEXES  &SRC,&NUM,&OUT      OUTPUT LOOKS LIKE C1.C2.C3 . . .\n         LCLC  &ONE                     FOR NUM SOURCE CHARACTERS\n&ONE     SETC  'HX'.'&SYSNDX'\n&LBL     XR    R15,R15\n         LA    R14,&NUM\n         LR    R1,R14\n         BCTR  R1,0\n         LA    R1,&NUM.(R1,R1)     LAST PERIOD AT (N-1)*3+1\n         LA    R1,&OUT.(R1)\n         S     R1,=F'3'            OUTPUT START LOCATION\n&ONE     LA    R15,&SRC            SOURCE BASE ADDRESS\n         XR    R0,R0\n         BCTR  R15,0\n         IC    R0,0(R14,R15)       INPUT CHARACTER\n         LR    R15,R0\n         N     R15,=F'15'\n         IC    R15,HEXTBL(R15)\n         STC   R15,2(,R1)          LOW NIBBLE\n         LR    R15,R0\n         SRL   R15,4\n         IC    R15,HEXTBL(R15)\n         STC   R15,1(,R1)          HIGH NIBBLE\n         MVI   0(R1),C'.'          SEPARATOR\n         S     R1,=F'3'            BACK UP 3 IN OUTPUT ADDRESS\n         BCT   R14,&ONE            DO PREVIOUS INPUT CHARACTER\n         MVI   3(R1),C' '          BLANK THE LEADING PERIOD\n         MEND\n         EJECT\nSTATS    START 0\n         SPACE 1\nSTATS   AMODE  24\nSTATS   RMODE  24\n         SPACE 1\nNTEL     EQU   2000 -------------- \"SAVETBL\" NUMBER OF ELEMENTS -------\nNGEL     EQU   2000 -------------- MAX. NUMBER OF \"GAS\" MEMBERS -------\n         SPACE 1\n        $DEFREG\n         EJECT\n        $XENT  BASE=(R8,R9,R10,R11,R12)\n         LR    R2,R1               SAVE PARM ADDRESS\n         L     R3,TLMX             ROOM FOR DIRECTORY ENTRIES\n         AH    R3,=H'1'\n         MH    R3,TLC+2\n         LR    R5,R3\n         LA    R3,7(R3)\n         SRL   R3,3\n         SLL   R3,3\n         AL    R3,=A(32776)\n         ST    R3,ARLGTH\n        GETMAIN R,LV=(R3)\n         ST    R1,BUFFER\n         STCM  R1,B'0111',CCW3+1\n         AL    R1,=A(32776)\n         LR    R4,R1\n         LA    R14,*\n         XR    R15,R15\n         ICM   R15,B'1000',BLANKS\n         MVCL  R4,R14              SET TO ALL BLANKS\n         SL    R1,TLC\n         ST    R1,SAVETBL\n         LA    R6,WORKAREA\n         USING DS1FMTID,R6\n         LA    R7,IN\n         USING IHADCB,R7\n        $TEW$EC REG=R2,NOTTSO=CALLM,NOTCMD=CALLM,MSG=PUTMSG,ERR=SETRC\n        $TEW$PP PARM=PARMLST\n         CLI   PGAS+1,0            GAS SPECIFIED?\n         BE    NGAS                NO\n         TM    SDGAS+6,X'80'       VALUE PRESENT?\n         BZ    NGAS                NO\n         CLC   SDGAS+4(2),=H'8'    CORRECT LENGTH VALUE FOR TT.TT.RR?\n         BE    GTTR                YES\n         CLC   SDGAS+4(2),=H'3'    NO, CORRECT LENGTH VALUE FOR ALL?\n         BNE   WRVL                NO\n         L     R1,SDGAS            POINT TO VALUE\n         CLC   0(3,R1),=CL4'ALL)'  CONTROL SYNTAX\n         BNE   WRVL\n         OI    FLAGS,GASALL\n         B     SETG\nGTTR     L     R1,SDGAS            POINT TO VALUE\n         CLI   2(R1),C'.'          CONTROL SYNTAX\n         BNE   WRVL\n         CLI   5(R1),C'.'\n         BNE   WRVL\n         MVC   GASTTR(L'GASTTR),0(R1)   SAVE TT.TT.RR\n         BAS   R14,HEXCTL\n         B     WRVL\nSETG     OI    FLAGS,GASADD\n         B     OKPA\nNGAS     LH    R1,POPT\n         DROP  R2\n         LTR   R1,R1               OPTIONS SPECIFIED?\n         BNP   OKPA                NO\n         BCT   R1,TON\n         B     OKPA\nTON      BCT   R1,TOF\n         NI    FLAGS,255-GAS       TURN OFF GAS RECORDS\n         B     OKPA\nTOF      BCT   R1,TOL\n         OI    FLAGS,FULL          TURN ON FULL LIST\n         B     OKPA\nTOL      BCT   R1,TOT\n         OI    FLAGS,LABELS        SET THE \"LABELS ONLY\" FLAG\n         B     OKPA\nTOT      BCT   R1,OKPA\n         OI    FLAGS,FULL+TEST     TURN ON FULL & TEST LIST\nOKPA     BAS   R2,RLSA             ALL OK\nWRVL     XR    R2,R2               WRONG\nRLSA    IKJRLSA #TSANSW\n         LTR   R2,R2               WHERE TO GO\n         BNZ   NOPARM\n         LA    R1,SNTMS\n         BAS   R14,PUTMSG\n         B     SETRC\nSNTMS   WTO    ' -> GAS(TT.TT.RR) SYNTAX ERROR.',                      X\n               ROUTCDE=11,DESC=7,MF=L\n         SPACE 1\nCALLM    L     R2,0(R2)            PARM ADDRESS\n         LH    R0,0(R2)\n         LTR   R0,R0               IS LENGTH ZERO?\n         BNP   NOPARM              YES, BRANCH\n         CH    R0,=H'13'           IS PARM LENGTH 13?\n         BE    *+L'*+8             YES\n         CH    R0,=H'8'            IS PARM LENGTH 8?\n         BNE   GSWH                NO, GO SEE WHAT ELSE\n         CLC   2(4,R2),=C'GAS('    PARM=GAS(TT.TT.RR) OR GAS(ALL)?\n         BNE   GSWH                NO, GO SEE WHAT ELSE\n         CH    R0,=H'8'            IS PARM LENGTH 8?\n         BNE   GTTTR               NO\n         CLC   6(4,R2),=CL4'ALL)'  CONTROL SYNTAX\n         BNE   WRONG\n         OI    FLAGS,GASALL\n         B     SETGS\nGTTTR    CLI   8(R2),C'.'          CONTROL SYNTAX\n         BNE   WRONG\n         CLI   11(R2),C'.'\n         BNE   WRONG\n         CLI   14(R2),C')'\n         BNE   WRONG\n         MVC   GASTTR(L'GASTTR),6(R2)   SAVE TT.TT.RR\n         BAS   R14,HEXCTL\n         B     WRONG\nSETGS    OI    FLAGS,GASADD\n         B     NOPARM\nHEXCTL   LA    R0,8                TT.TT.RR CONTROL\n         LA    R15,GASTTR+L'GASTTR-1\nHEXCTLL  CLI   0(R15),C'.'\n         BE    HEXCTLI\n         CLI   0(R15),C'A'\n         BLR   R14\n         CLI   0(R15),C'F'\n         BNH   HEXCTLI\n         CLI   0(R15),C'0'\n         BLR   R14\n         CLI   0(R15),C'9'\n         BHR   R14\nHEXCTLI  BCTR  R15,0\n         BCT   R0,HEXCTLL\n         B     4(R14)\nWRONG   OUTPT  MINUS1,WRMSG\n         B     ENDALL\nGSWH     CLI   2(R2),C'U'          PARM=U SAME AS NO PARM\n         BE    NOPARM              YES, BRANCH\n         CLI   2(R2),C'N'          NO, ARE GAS RECORDS DESIRED?\n         BNE   *+L'*+4             YES, BRANCH\n         NI    FLAGS,255-GAS       NO, TURN OFF GAS RECORDS\n         CLI   2(R2),C'F'          FULLY INFORMATION LIST?\n         BNE   *+L'*+4             NO, BRANCH\n         OI    FLAGS,FULL          YES, TURN ON FULL LIST\n         CLI   2(R2),C'T'          TEST INFORMATION LIST?\n         BNE   *+L'*+4             NO, BRANCH\n         OI    FLAGS,FULL+TEST     YES, TURN ON FULL & TEST LIST\n         CLI   2(R2),C'L'          LABEL INFORMATION ONLY?\n         BNE   NOPARM              NO, BRANCH\n         OI    FLAGS,LABELS        YES, SET THE \"LABELS ONLY\" FLAG\n         SPACE 1\nNOPARM   TM    FLAGS,GASALL        ALL GAS TO RECOVER?\n         BZ    NOGALL              NO\n         L     R3,GTLGTH           YES, GET RECORDING AREA\n        GETMAIN R,LV=(R3)\n         ST    R1,GTANK\n         LR    R2,R1\n         SL    R1,GTSTR+4\n         ST    R1,GTSTR\n         AL    R1,GTSTR+8\n         ST    R1,GTSTR+8\n         LA    R14,*\n         XR    R15,R15\n         MVCL  R2,R14              SET TO ALL ZEROS\nNOGALL   BAS   R14,OPENIN          OPEN THE INPUT FILE\n        OUTPT  MINUS1,SQL\n        OUTPT  MINUS1,PRGRM        PROGRAM NAME AND PURPOSE\n        OUTPT  MINUS1,SQL\n        OUTPT  MINUS1,BLANKS,A=\n         MVC   WORK(4),=CL4'DSN='\n         MVC   WORK+4(44),JFCBDSNM      DATA-SET NAME\n         LA    R1,WORK+4\n         LA    R1,1(,R1)           SCAN FOR\n         CLI   0(R1),C' '               FINAL\n         BNE   *-8                           BLANK\n         MVC   0(9,R1),=CL9',VOL=SER='\n         MVC   9(6,R1),JFCBVOLS    ADD THE VOLUME SERIAL\n        OUTPT  MINUS1,WORK,LN=L'WORK,A=\n         TM    FLAGS,GASADD        GAS TO RECOVER?\n         BZ    NDCB                NO, BRANCH\n         TM    DS1DSORG,DS1DSGPO   PARTITIONED DATA-SET ORG?\n         BO    OKPO                YES, BRANCH\n        OUTPT  MINUS1,NOTPDS\n        CLOSE  IN\n         B     ENDALL\nOKPO     MVC   TEMP(4),DS1LSTAR\n        TTRMBB TEMP,MBB=LASTMBB    SAVE THE LAST USED MBBCCHHR\n         B     PO\n         SPACE 1\n*------- FORMATS A STRING LIKE \"DCB=(RECFM=...)\".\n         SPACE 1\nNDCB     LA    R1,WORK             FORMAT THE DCB INFORMATION\n         MVC   0(12,R1),=CL12'DCB=(RECFM=*'\n         LA    R1,11(,R1)\n         TM    DS1RECFM,DCBRECU    RECFM=U?\n         BNO   *+L'*+8             NO, BRANCH\n         MVI   0(R1),C'U'\n         B     NDCB1\n         TM    DS1RECFM,DCBRECF    RECFM=F?\n         BNO   *+L'*+8             NO, BRANCH\n         MVI   0(R1),C'F'\n         B     NDCB1\n         TM    DS1RECFM,DCBRECV    RECFM=V?\n         BNO   NDCB1               NO, BRANCH\n         MVI   0(R1),C'V'\nNDCB1    LA    R1,1(,R1)\n         TM    DS1RECFM,DCBRECBR   RECFM=.B?\n         BNO   *+L'*+8             NO, BRANCH\n         MVI   0(R1),C'B'\n         LA    R1,1(,R1)\n         TM    DS1RECFM,DCBRECTO   RECFM=.T?\n         BNO   *+L'*+8             NO, BRANCH\n         MVI   0(R1),C'T'\n         LA    R1,1(,R1)\n         TM    DS1RECFM,DCBRECCA   RECFM=.A?\n         BNO   *+L'*+8             NO, BRANCH\n         MVI   0(R1),C'A'\n         LA    R1,1(,R1)\n         TM    DS1RECFM,DCBRECCM   RECFM=.M?\n         BNO   *+L'*+8             NO, BRANCH\n         MVI   0(R1),C'M'\n         LA    R1,1(,R1)\n         TM    DS1RECFM,DCBRECU    RECFM=U?\n         BO    NDCB3               YES, NO LRECL MESSAGE\n         MVC   0(7,R1),=CL7',LRECL='\n         LA    R1,7(,R1)\n         LH    R15,DS1LRECL\n         CVD   R15,DOUBLE\n         UNPK  DOUBLE(5),DOUBLE+5(3)\n         LA    R15,DOUBLE-1\n         LA    R15,1(,R15)         SCAN\n         CLI   0(R15),C'0'              PAST LAST\n         BE    *-8                           LEADING ZERO\n         OI    DOUBLE+4,X'F0'\nNDCB2    MVC   0(1,R1),0(R15)      MOVE IN EACH CHARACTER\n         LA    R1,1(,R1)\n         LA    R15,1(,R15)\n         TM    0(R15),X'F0'        NEXT CHARACTER NUMERIC?\n         BO    NDCB2               NO, BRANCH\nNDCB3    MVC   0(9,R1),=CL9',BLKSIZE='\n         LA    R1,9(,R1)\n         LH    R15,DS1BLKL\n         CVD   R15,DOUBLE\n         UNPK  DOUBLE(5),DOUBLE+5(3)\n         LA    R15,DOUBLE-1\n         LA    R15,1(,R15)         SCAN\n         CLI   0(R15),C'0'              PAST LAST\n         BE    *-8                           LEADING ZERO\n         OI    DOUBLE+4,X'F0'\nNDCB4    MVC   0(1,R1),0(R15)      MOVE IN EACH CHARACTER\n         LA    R1,1(,R1)\n         LA    R15,1(,R15)\n         TM    0(R15),X'F0'        NEXT CHARACTER NUMERIC?\n         BO    NDCB4               NO, BRANCH\n         MVC   0(7,R1),=CL7',DSORG='\n         LA    R1,7(,R1)\n         TM    DS1DSORG,DS1DSGPS   PS?\n         BNO   *+L'*+6             NO, BRANCH\n         MVC   0(2,R1),=CL2'PS'\n         TM    DS1DSORG,DS1DSGPO   PO?\n         BNO   *+L'*+6             NO, BRANCH\n         MVC   0(2,R1),=CL2'PO'\n         TM    DS1DSORG,DS1DSGDA   DA?\n         BNO   *+L'*+6             NO, BRANCH\n         MVC   0(2,R1),=CL2'DA'\n         TM    DS1DSORG,DS1DSGIS   IS?\n         BNO   *+L'*+6             NO, BRANCH\n         MVC   0(2,R1),=CL2'IS'\n         TM    DS1DSORG,DS1DSGU    UNMOVEABLE?\n         BNO   *+L'*+8             NO, BRANCH\n         MVI   2(R1),C'U'\n         LA    R1,1(,R1)\n         MVI   2(R1),C')'\n        OUTPT  MINUS1,WORK,LN=L'WORK,A=\n         SPACE 1\n         L     R1,DCBDEBAD\n         L     R14,NUMEXT          NUMBER OF EXTENTS\n         XR    R0,R0\n         AH    R0,46(,R1)          TRACKS IN THE EXTENT\n         LA    R1,16(,R1)          OFFSET BETWEEN EXTENTS\n         BCT   R14,*-8             REPEAT FOR EACH EXTENT\n         ST    R0,TOTALTRK         SAVE TRACK TOTAL\n         LH    R1,DS1LSTAR         LAST TT USED\n         SR    R0,R1               AVAILABLE SPACE + 0.5 TRACKS\n         BCTR  R0,0                SUBTRACT ONE MORE\n         ST    R0,AVAILTRK\n         MVC   TEMP(4),DS1LSTAR\n        TTRMBB TEMP,MBB=LASTMBB    SAVE THE LAST USED MBBCCHHR\n        OUTPT  TOTALTRK,NUMTRKS\n        OUTPT  AVAILTRK,FRETRKS\n         MVC   TEMP(2),=H'0'\n         MVC   TEMP+2(2),DS1TRBAL\n        OUTPT  TEMP,TRBALS         BYTES LEFT ON LAST USED TRACK\n        OUTPT  NUMEXT,NUMEXTS\n         L     R2,DCBDEBAD\n         L     R3,NUMEXT\n         XR    R1,R1\n         IC    R1,24(R2)\n         SRL   R1,4\n         IC    R1,HEXTBL(R1)\n         STC   R1,PROTECT          PROTECTION KEY FOR THIS DATA-SET\n        OUTPT  MINUS1,PROTECT,A=\n         TM    DS1SCALO,X'C0'      CYLINDER ALLOC?\n         BNO   *+L'*+10            NO, BRANCH\n         MVC   SCALOS+25(9),=CL9'CYLINDERS'  YES\n         B     ALLOCS\n         BNZ   *+L'*+10            ABS. TRACKS\n         MVC   SCALOS+25(15),=CL15'ABSOLUTE TRACKS'    YES\n         B     ALLOCS\n         TM    DS1SCALO,X'80'      TRACKS?\n         BNO   *+L'*+10            NO, BRANCH\n         MVC   SCALOS+25(6),=CL6'TRACKS'     YES\n         B     ALLOCS\n         MVC   SCALOS+25(6),=CL6'BLOCKS'     BLOCKS\n         TM    DS1SCALO,X'01'      ROUND TO CYL?\n         BNO   ALLOCS              NO, BRANCH\n         MVC   SCALOS+32(12),=CL12'(WITH ROUND)'       YES\nALLOCS  OUTPT  MINUS1,SCALOS,A=\n         MVC   TEMP+1(3),DS1SCALO+1     SECONDARY ALLOCATION QUANTITY\n         MVI   TEMP,X'00'\n         CLC   TEMP,=F'0'          ANY SECONDARIES ALLOWED?\n         BNE   SECS                YES, BRANCH\n        OUTPT  MINUS1,NOSEC        NO\n         B     ALLSECS\nSECS    OUTPT  TEMP,EXTENTS\n         SPACE 1\nALLSECS  XR    R4,R4               EXTENT NUMBER\n        HEXES  LASTMBB,8,LSTAR+13\n        OUTPT  MINUS1,LSTAR,A=     LAST USED MBBCCHHR\n        OUTPT  MINUS1,BLANKS,A=\n        OUTPT  MINUS1,EXTHDR\n        OUTPT  MINUS1,EXTUND\n         SPACE 1\nHEXAGN   CVD   R4,DOUBLE\n         LA    R4,1(,R4)\n         UNPK  DOUBLE(5),DOUBLE+5(3)\n         MVC   WORK+1(2),DOUBLE+3\n         OI    WORK+2,X'F0'        EXTENT NUMBER\n         CLI   WORK+1,C'0'\n         BNE   *+L'*+4\n         MVI   WORK+1,C' '\n         L     R1,32(R2)           UCB ADDRESS\n         MVC   WORK+8(3),13(R1)    UCB\n        HEXES  38(R2),4,WORK+14    INITIAL CCHH\n        HEXES  42(R2),4,WORK+28    END CCHH\n         LH    R1,46(,R2)          NUMBER OF TRACKS IN THIS EXTENT\n         CVD   R1,DOUBLE\n         UNPK  WORK+41(9),DOUBLE+3(5)\n         LA    R1,WORK+40\n         LA    R1,1(,R1)\n         CLI   1(R1),C'0'          NEXT DIGIT ZERO?\n         MVI   0(R1),C' '          REPLACE CURRENT DIGIT WITH BLANK\n         BE    *-12                YES, CONTINE BLANKING LEADING ZEROES\n         OI    WORK+49,X'F0'       MAKE THE ZONE PRINTABLE\n        OUTPT  MINUS1,WORK,A=\n         LA    R2,16(,R2)          NEXT EXTENT DISPLACEMENT\n         BCT   R3,HEXAGN\n        OUTPT  MINUS1,BLANKS,A=\n         SPACE 1\n         XR    R0,R0\n         IC    R0,DS1KEYL\n         LTR   R0,R0               KEYLENGTH=0?\n         BZ    DSORGTST            YES, BRANCH\n        OUTPT  R0,KEYLEN           NO, OUTPUT KEYLEN AND RKP\n         MVC   TEMP+2(2),DS1RKP\n        OUTPT  TEMP,KEYPOS\n        OUTPT  MINUS1,BLANKS,A=\nDSORGTST TM    FLAGS,LABELS        LABEL INFORMATION ONLY DESIRED?\n         BO    END3                YES, DO NOT DO ANY READS\n         TM    DS1DSORG,DS1DSGPO   PARTITIONED DATA-SET ORGANIZATION?\n         BO    PO                  YES, BRANCH. NO -- PS, DA OR IS\nINPUTS   BAS   R14,EXCPSTAT        READ EACH BLOCK AND COLLECT STATS\n         LTR   R15,R15             END OF FILE?\n         BZ    INPUTS              NO, CONTINUE READING\n         LR    R2,R15              SAVE FOR LATER\n        OUTPT  MINUS1,EOFSS\n         TM    DS1DSORG,DS1DSGIS   ISAM?\n         BNO   ENDDATA             NO, BRANCH -- END OF DATA-SET\n         CLC   MINBLKI,=F'33000'   EVER CHANGED?\n         BNE   *+L'*+6             YES, BRANCH\n         XR    R14,R14             NO, RESET TO ZERO\n         ST    R14,MINBLKI\n        OUTPT  MINBLKI,MINBLKS\n         LA    R14,1\n         C     R14,READTOTI\n         BH    *+L'*+4\n         L     R14,READTOTI        TAKE MAX OF READTOTI AND 1\n         L     R1,READTOTI\n         SRL   R1,1\n         A     R1,BYTECNTI\n         XR    R0,R0\n         DR    R0,R14              AVG BLK = (BYTECNTI+READTOTI/2) /\n         LR    R0,R1                    MAX(READTOTI,1)\n        OUTPT  R0,AVGBLKS\n        OUTPT  MAXBLKI,MAXBLKS\n        OUTPT  READTOTI,NUMBLKS\n        OUTPT  MINUS1,BLANKS,A=\n         MVC   MINBLKI,=F'33000'   RESET\n         XR    R14,R14                  THE\n         ST    R14,READTOTI                  FILE\n         ST    R14,MAXBLKI                        STATISTICS\n         ST    R14,BYTECNTI                            VARIABLES\n         C     R2,=F'5'            END OF DATA-SET?\n         BL    INPUTS              NO, REPORT ON THE NEXT SEGMENT\n         SPACE 1\nENDDATA  L     R0,READTOT\n         LTR   R0,R0               ANY RECORDS READ?\n         BP    ENDPSPO             YES, NORMAL DATA-SET\n        OUTPT  MINUS1,NULL         NO RECORDS IN THE DATA-SET\n         B     END3                QUIT\n         SPACE 1\nPO       XR    R5,R5               CLEAR R5 FOR LATER\n         MVI   SWITCH,0\n         OI    FLAGS,DIRECTOR      TURN ON THE \"IN DIRECTORY\" FLAG\n         TM    FLAGS,GASADD        GAS TO RECOVER?\n         BO    NEXTMBR             YES, BRANCH\n         CLI   DS1NOBDB,0          LAST DIRECTORY BLOCK IN USE?\n         BE    NEXTMBR             NO, BRANCH\n         XR    R0,R0\n         IC    R0,DS1NOBDB         NUMBER OF BYTES IN USE\n         ST    R0,TEMP\n        OUTPT  TEMP,NOBDBS\n         SPACE 1\nNEXTMBR  BAS   R14,MEMBERS         GET THE NEXT MEMBER\n         B     *+L'*(R15)          BRANCH TABLE\n         B     GOODMBR             SUCCESSFUL\n         B     MBREOF              EOF IN DIRECTORY\n         B     LASTUSED            LAST USED ENTRY FOUND\n         B     NOTDIREC            NOT A DIRECTORY RECORD\n         SPACE 1\nGOODMBR  LA    R2,REALMBR          SET A REAL ENTRY\n         NI    SWITCH,255-ALIAS    TURN OFF THE ALIAS BIT FOR NAME\n         TM    11(R1),X'80'        ALIAS ENTRY?\n         BZ    NOTAL               NO, BRANCH\n         LA    R2,ALIASES          YES, AN ALIAS ENTRY\n         OI    SWITCH,ALIAS        TURN ON THE ALIAS BIT FOR NAME\nNOTAL    L     R14,0(,R2)\n         LA    R14,1(,R14)         INCREMENT ALIASES OR REALMBR\n         ST    R14,0(,R2)\n         LR    R2,R1\n        TTRMBB 8(R1),MBB=DOUBLE    CONVERT TTR TO MBBCCHHR\n         TM    FLAGS,FULL          FULLY LIST REQUESTED?\n         BZ    STTBL               NO, BRANCH\n         TM    SWITCH,DIRPR\n         BO    PRDIR\n         OI    SWITCH,DIRPR\n        OUTPT  MINUS1,DIRTLA\n        OUTPT  MINUS1,DIRTL1\n        OUTPT  MINUS1,DIRTL2\nPRDIR    MVC   WORK,BLANKS         CLEAR WORK AREA\n         MVC   WORK(8),0(R2)       MOVE MEMBER OR ALIAS NAME\n         MVC   WORK+8(3),=C'(M)'   INDICATE MEMBER NAME\n         TM    SWITCH,ALIAS        ALIAS ENTRY?\n         BZ    *+L'*+4             NO, OK\n         MVI   WORK+9,C'A'         INDICATE ALIAS NAME\n        HEXES  8(R2),3,WORK+15     TTR\n        HEXES  DOUBLE,8,WORK+26    MBBCCHHR\n        OUTPT  MINUS1,WORK,A=\nSTTBL    L     R1,SAVETBL\nTBLINC   AL    R1,TLC\n         USING TLELM,R1\n         CLI   0(R1),C' '          EMPTY TABLE ENTRY?\n         BE    INSERT              YES, BRANCH\n         CLC   TLADDR(L'TLADDR),DOUBLE  IS IT THIS ENTRY?\n         BNE   TBLINC              NO, CHECK NEXT ENTRY\n         TM    SWITCH,ALIAS        ALIAS?\n         BO    NEXTMBR             YES, BRANCH\n         MVC   TLNAME(L'TLNAME),0(R2)   NO, USE THE REAL MEMBER NAME\n         B     NEXTMBR\nINSERT   MVC   TLNAME(L'TLNAME),0(R2)   INSERT THE NAME\n         MVC   TLADDR(L'TLADDR),DOUBLE  INSERT THE MBBCCHHR\n         MVC   TLTTR(L'TLTTR),8(R2)     INSERT THE TTR\n         MVI   TLSTAT,0\n         TM    SWITCH,ALIAS        ALIAS?\n         BZ    *+L'*+4             NO, BRANCH\n         OI    TLSTAT,TLALIAS      INDICATE ALIAS NAME\n         DROP  R1\n         LR    R5,R1               SAVE THE \"HIGH-WATER\" MARK\n         L     R1,REALENT\n         LA    R1,1(,R1)           COUNT THE NUMBER OF TABLE ENTRIES\n         ST    R1,REALENT\n         C     R1,TLMX\n         BL    NEXTMBR\n        OUTPT  MINUS1,MANYENT\n        KILL   1 ------- TOO MANY MEMBER ENTRIES IN THE TABLE *** 1 ***\nNOTDIREC XR    R15,R15             SIMULATED END OF FILE (GOOD READ)\nMBREOF   L     R1,READTOT          END OF FILE IN DIRECTORY\n         ST    R1,USEDBLK          USED COUNT\n         ST    R1,ALLOCBLK         ALLOCATED COUNT\n         B     PRESORT\n         SPACE 1\nLASTUSED L     R0,READTOT          END OF USED ENTRIES IN DIRECTORY\n         ST    R0,USEDBLK\nRPTEXCP  BAS   R14,EXCPSTAT        READ AND COLLECT STATISTICS\n         LTR   R15,R15\n         BZ    RPTEXCP\n         L     R1,READTOT\n         ST    R1,ALLOCBLK         ALLOCATED COUNT\nPRESORT  XR    R0,R0\n         XI    FLAGS,DIRECTOR      TURN OFF THE \"IN DIRECTORY\" FLAG\n         ST    R15,TEMP            SAVE FOR LATER\n         ST    R0,READTOT          REINITIALIZE READTOT\n         ST    R0,MAXBLK                MAXBLK\n         ST    R0,BYTECNT                    BYTECNT\n         MVC   MINBLK(4),=F'33000' REINITIALIZE MINBLK\n         SPACE 1\n*------- SORT THE MEMBER ARRAY BY MBBCCHHR (USES A SHELLSORT).\n         SPACE 1\n         L     R3,REALENT          NUMBER OF ELEMENTS TO SORT\n         LTR   R3,R3\n         BNP   SORTED\n         MH    R3,TLC+2            GAP IS LENGTH * NO. OF ELEMENTS\n         LR    R0,R3               N=GAP\nSHELLG   XR    R2,R2               GAP=GAP/2  (DROP FRACTION BITS)\n         D     R2,TLC\n         SRL   R3,1\n         LTR   R3,R3               GAP LESS THAN ONE?\n         BZ    SORTED              YES, DONE\n         MH    R3,TLC+2\n         L     R2,SAVETBL          TABLE BASE ADDRESS\n         LR    R4,R3               I=GAP\nSHELLI   AL    R4,TLC              I=I+1 (TABLE WIDTH)\n         CR    R4,R0               I<=N?\n         BH    SHELLG              NO, HALVE THE GAP\n         LR    R1,R4               YES, J=I\nSHELLJ   SR    R1,R3               J=J-GAP\n         BNP   SHELLI              IF J<=0, INCREMENT I\n         LA    R15,0(R2,R1)        ADDRESS OF SAVETBL(J)\n         LA    R14,0(R3,R1)        JG=J+GAP\n         LA    R14,0(R2,R14)       ADDRESS OF SAVETBL(JG)\n         CLC   8(8,R15),8(R14)     MBBCCHHR(J) <= MBBCCHHR(JG)\n         BNH   SHELLI              YES, INCREMENT I\n         XC    0(TLG,R14),0(R15)   INTERCHANGE\n         XC    0(TLG,R15),0(R14)        SAVETBL ENTRIES\n         XC    0(TLG,R14),0(R15)             J AND JG\n         B     SHELLJ              INCREMENT J\n         SPACE 1\nSORTED   TM    SWITCH,DIRPR\n         BZ    LKTBL\n        OUTPT  MINUS1,BLANKS,A=\n        OUTPT  MINUS1,DIRTLB\n        OUTPT  MINUS1,DIRTL1\n        OUTPT  MINUS1,DIRTL2\n         L     R2,SAVETBL\n         AL    R2,TLC\n         MVC   WORK,BLANKS         CLEAR WORK AREA\n         USING TLELM,R2\nPSDIR    MVC   WORK(L'TLNAME),TLNAME    MOVE MEMBER NAME\n         MVC   WORK+L'TLNAME(3),=C'(M)' INDICATE MEMBER NAME\n        HEXES  TLTTR,L'TLTTR,WORK+15    TTR\n        HEXES  TLADDR,L'TLADDR,WORK+26  MBBCCHHR\n        OUTPT  MINUS1,WORK,A=\n         AL    R2,TLC\n         CLI   0(R2),C' '          EMPTY TABLE ENTRY?\n         BNE   PSDIR               NO, BRANCH\n         DROP  R2\n        OUTPT  MINUS1,BLANKS,A=\n         L     R2,SAVETBL\n         B     NULLPDS\nLKTBL    L     R2,SAVETBL\n         LTR   R5,R5               ANY MEMBERS?\n         BZ    NULLPDS             NO, BRANCH\n         TM    FLAGS,GASADD        GAS TO RECOVER?\n         BO    NULLPDS             YES, BRANCH\n         USING TLELM,R5\n         MVC   LASTMEMS(L'TLNAME),TLNAME     LAST MEMBER IN THE PDS\n         DROP  R5\n        OUTPT  MINUS1,LASTMEMS,A=\nNULLPDS  L     R15,TEMP            RESTORE THE RETURN CODE\n         SPACE 1\nNXTREAL  AL    R2,TLC              LAST MEMBER WAS REAL\n         USING TLELM,R2\n         TM    FLAGS,TEST          TRACE REQUESTED?\n         BZ    NXTONE              NO, BRANCH\n         XR    R1,R1               TRACE TABLED MBBCCHHR\n         BAS   R14,TRACE\nNXTONE   L     R0,BYTECNT          LAST MEMBER WAS GAS\n         ST    R0,SAVETOT          SAVE FOR LATER\n         C     R15,=F'8'           END OF DATA-SET?\n         BE    LASTMTCH            YES, BRANCH\n         OI    FLAGS,REALONE       SET FLAG FOR ACTUAL MEMBER\nNXTTBL   MVC   CURRMBR(L'TLNAME),TLNAME SAVE THE CURRENT MEMBER NAME\n         CLC   TLADDR(L'TLADDR),IOBSEEK NEXT MBBCCHHR IN THE TABLE?\n         BE    REALRD              YES, BRANCH TO READ LOOP\n         BH    NOABE13             NO, HIGHER -- A \"GAS\" MEMBER\n         CLI   TLG(R2),C' '        EMPTY TABLE?\n         BE    ABE13               YES, BRANCH\n        OUTPT  MINUS1,BLANKS,A=    NO, INVALID TTR\n         MVC   INVTTR+9(L'TLNAME),TLNAME SET MEMBER NAME IN MESSAGE\n        OUTPT  MINUS1,INVTTR,A=\n         AL    R2,TLC              BUMP TABLE POINTER\n         TM    FLAGS,TEST          TRACE REQUESTED?\n         BZ    NXTTBL              NO, BRANCH\n         XR    R1,R1               TRACE TABLED MBBCCHHR\n         BAS   R14,TRACE\n         B     NXTTBL              TRY WITH NEXT\nABE13   OUTPT  MINUS1,TTRTOLOW\n        KILL   2 ------- TABLED TTR < CURRENT TTR *************** 2 ***\nNOABE13  L     R1,GASCNT           NO, HIGHER -- A \"GAS\" MEMBER\n         LA    R1,1(,R1)\n         ST    R1,GASCNT           ADD ONE TO THE GAS MEMBER COUNT\n         XI    FLAGS,REALONE       TURN OFF THE ACTUAL MEMBER FLAG\n         TM    FLAGS,GAS           GAS RECORDS DESIRED?\n         BNO   GASRD               NO, BRANCH\n         L     R0,TRACKNUM         CURRENT TRACK NUMBER (RELATIVE 1)\n         BCTR  R0,0                CURRENT TRACK NUMBER (RELATIVE 0)\n         L     R1,LASTR            CURRENT RECORD NUMBER\n         LA    R1,1(,R1)           NEXT RECORD NUMBER (R OF TTR)\n         CLC   CURMBB(7),IOBSEEK   SWITCHED TRACKS?\n         BE    *+L'*+6             NO, BRANCH\n         LA    R1,1                RECORD ONE\n         AR    R0,R1               NEXT RELATIVE TRACK\n         STH   R0,TEMP             SAVE RELATIVE TRACK NUMBER\n         STC   R1,TEMP+2           SAVE RECORD NUMBER\n        HEXES  TEMP,3,GASMEM+21\n         TM    FLAGS,GASADD        GAS TO RECOVER?\n         BZ    NORCV               NO, BRANCH\n         OC    STOWTTR,STOWTTR     ALREADY RESOLVED?\n         BNZ   NORCV               YES, BRANCH\n         TM    FLAGS,GASALL        ALL GAS TO RECOVER?\n         BZ    NOGAST              NO\n         L     R1,GTSTR\n         LM    R14,R15,GTSTR+4\n         BXLE  R1,R14,SVTTR\nSWOVG    NOP   NORCV\n         OI    SWOVG+1,X'F0'\n        OUTPT  MINUS1,GOVFLOW\n         B     NORCV\nSVTTR    MVC   0(L'STOWTTR,R1),TEMP     SAVE TTR FOR STOW\n         ST    R1,GTSTR\n         B     NORCV\nNOGAST   CLC   GASTTR(L'GASTTR),GASMEM+20    IS THIS THE ONE?\n         BNE   NORCV               NO, BRANCH\n         MVC   STOWTTR(L'STOWTTR),TEMP  SAVE TTR FOR STOW\nNORCV    TM    DS1RECFM,DCBRECU    LRECL=U?\n         BNO   DODATA              NO, BRANCH\n        OUTPT  MINUS1,GASMEM,LN=28,A=   YES, DO NOT DO A DATA LINE\n         B     GASRD\n         SPACE 1\nDODATA  OUTPT  MINUS1,BLANKS,A=\n        OUTPT  MINUS1,GASMEM,A=\n         BAS   R14,EXCPSTAT        INPUT THE NEXT REAL BLOCK\n         ST    R15,TEMP            SAVE THE RETURN CODE\n         L     R15,LS\n         C     R15,=F'72'\n         BNH   *+L'*+4\n         L     R15,=F'72'          LIMIT OUTPUT LENGTH TO 72 BYTES\n         L     R1,BUFFER           BUFFER ADDRESS\n         LTR   R15,R15\n         BNZ   *+L'*+8\n         LA    R15,1               IF NULL LENGTH, USE ONE BYTE AND\n         MVI   0(R1),C' '               BLANK THE FIRST BYTE OF BUFFER\n        OUTPT  MINUS1,R1,LN=0(R15)\n         L     R15,TEMP            RESTORE THE RETURN CODE\n         B     GASRDF              SKIP THE FIRST READ (ALREADY DONE)\n         SPACE 1\nGASRD    BAS   R14,EXCPSTAT        \"GAS\" MEMBER\n         L     R1,GASRDS\n         LA    R1,1(,R1)           ADD ONE TO THE GAS RECORD COUNT\n         ST    R1,GASRDS\n         TM    FLAGS,TEST          TRACE REQUESTED?\n         BZ    GASRDF              NO, BRANCH\n         LA    R1,IOBSEEK          TRACE NEXT MBBCCHHR\n         BAS   R14,TRACE\nGASRDF   LTR   R15,R15             (DON'T COUNT THE FIRST ONE)\n         BNZ   GASRDE\n         CLC   TLADDR(L'TLADDR),IOBSEEK NEXT MBBCCHHR IN THE TABLE?\n         BH    GASRD               NO, CONTINUE\n*                                  YES, END OF \"GAS\", THUS\nGASRDE   L     R0,BYTECNT               START OF A \"REAL\"\n         S     R0,SAVETOT          GAS BYTES THIS MEMBER\n         L     R1,GASBYTE\n         AR    R1,R0\n         ST    R1,GASBYTE          TOTAL GAS BYTES\n         C     R0,MAXGAS\n         BNH   *+L'*+4\n         ST    R0,MAXGAS           MAX BYTES/GAS MEMBER\n         C     R0,MINGAS\n         BNL   NXTONE\n         ST    R0,MINGAS           MIN BYTES/GAS MEMBER\n         B     NXTONE\n         SPACE 1\nREALRD   BAS   R14,EXCPSTAT        \"REAL\" MEMBER\n         TM    FLAGS,TEST          TRACE REQUESTED?\n         BZ    REALRDF             NO, BRANCH\n         LA    R1,IOBSEEK          TRACE NEXT MBBCCHHR\n         BAS   R14,TRACE\nREALRDF  LTR   R15,R15             END OF FILE?\n         BNZ   REALRDE             YES, END OF \"REAL\"\n         CLI   TLG(R2),C' '        EMPTY TABLE?\n         BE    REALRD              NO, CONTINUE\n         CLC   TLADDR+TLG(L'TLADDR),IOBSEEK NEXT MBBCCHHR IN TABLE?\n         BH    REALRD              NO, CONTINUE\n        OUTPT  MINUS1,BLANKS,A=\n         MVC   NOMEOF+9(8),CURRMBR SET MEMBER NAME IN MESSAGE\n        OUTPT  MINUS1,NOMEOF,A=    END OF \"REAL\", BUT NO EOF\n         LA    R15,4               SET RETURN CODE\nREALRDE  L     R0,BYTECNT\n         S     R0,SAVETOT\n         L     R1,RELBYTE\n         AR    R1,R0\n         ST    R1,RELBYTE          TOTAL BYTES FOR REAL MEMBERS\n         C     R0,MAXREL\n         BNH   *+L'*+4\n         ST    R0,MAXREL           MAX BYTES/REAL MEMBER\n         C     R0,MINREL\n         BNL   NXTREAL\n         ST    R0,MINREL           MIN BYTES/REAL MEMBER\n         B     NXTREAL\n         SPACE 1\nLASTMTCH CLI   0(R2),C' '\n         BE    ENDPO\n        OUTPT  MINUS1,NOTFOUND\n        KILL   3 ------- ALL MEMBERS IN THE TABLE NOT FOUND ***** 3 ***\nENDPO    TM    FLAGS,GASADD        GAS TO RECOVER?\n         BO    STOW                YES, BRANCH\n         DROP  R2\n         TM    FLAGS,TEST          TRACE REQUESTED?\n         BZ    ENDPSPO             NO, BRANCH\n         L     R1,MINUS1           CLOSE TRACE\n         BAS   R14,TRACE\nENDPSPO OUTPT  MINUS1,BLANKS,A=\n        OUTPT  MINR,MINRS\n         L     R15,TRACKNUM\n         SRL   R15,1\n         A     R15,ALLR            (ALLR + TRACKNUM/2) / TRACKNUM\n         XR    R14,R14\n         D     R14,TRACKNUM        AVERAGE RECORDS PER TRACK\n         LR    R0,R15\n        OUTPT  R0,AVGRS\n        OUTPT  MAXR,MAXRS\n        OUTPT  MINUS1,BLANKS,A=\n         L     R15,TRACKNUM\n         SRL   R15,1\n         A     R15,TRKBYTE         (TRKBYTE + TRACKNUM/2) / TRACKNUM\n         XR    R14,R14\n         D     R14,TRACKNUM        AVERAGE BYTES PER TRACK\n         ST    R15,AVGBTRK\n        OUTPT  MINBYTE,MINBYTES    MIN BYTES/TRACK\n        OUTPT  AVGBTRK,AVGBYTES    AVG BYTES/TRACK\n        OUTPT  MAXBYTE,MAXBYTES    MAX BYTES/TRACK\n        OUTPT  MINUS1,BLANKS,A=\n        OUTPT  TRKBYTE,TOTBYTS     TOTAL DATA BYTES ON ALL TRACKS\n        OUTPT  MINUS1,BLANKS,A=\n         CLC   MINBLK,=F'33000'    EVER CHANGED?\n         BNE   *+L'*+6             YES, BRANCH\n         XR    R14,R14             NO, RESET TO ZERO\n         ST    R14,MINBLK\n        OUTPT  MINBLK,MINBLKS\n         LA    R14,1\n         C     R14,READTOT\n         BH    *+L'*+4\n         L     R14,READTOT         TAKE MAX OF READTOT AND 1\n         L     R1,READTOT\n         SRL   R1,1\n         A     R1,BYTECNT\n         XR    R0,R0\n         DR    R0,R14              AVG BLK = (BYTECNT+READTOT/2) /\n         LR    R0,R1                    MAX(READTOT,1)\n        OUTPT  R0,AVGBLKS\n        OUTPT  MAXBLK,MAXBLKS\n        OUTPT  MINUS1,BLANKS,A=\n        OUTPT  READTOT,NUMBLKS\n         TM    DS1DSORG,DS1DSGPO   DSORG=PO?\n         BNO   END3\n        OUTPT  GASRDS,GASBLKS\n        OUTPT  EOFS,ENDMBR\n        OUTPT  GASCNT,GASMBR\n         L     R0,GASCNT\n         LTR   R0,R0\n         BZ    NOGASM\n        OUTPT  MINUS1,BLANKS,A=\n        OUTPT  MINGAS,MINGASS      MIN BYTES PER GAS MEMBER\n         L     R15,GASCNT\n         SRL   R15,1\n         A     R15,GASBYTE\n         XR    R14,R14\n         D     R14,GASCNT\n         LR    R0,R15\n        OUTPT  R0,AVGGASS          AVG BYTES PER GAS MEMBER\n        OUTPT  MAXGAS,MAXGASS      MAX BYTES PER GAS MEMBER\n        OUTPT  MINUS1,BLANKS,A=\n         L     R1,GASBYTE\n         LA    R15,100\n         MR    R0,R15\n         A     R1,=F'5'\n         D     R0,AVGBTRK          TRKS*100 = (GASBYTE*100+5) / AVGBTRK\n         CVD   R1,DOUBLE                (DOES THE REQUIRED ROUNDING)\n         UNPK  GASTRK(9),DOUBLE+3(5)\n         MVC   GASTRK+8(1),GASTRK+7     MOVE TENS DIGIT OVER HUNDREDS\n         MVI   GASTRK+7,C'.'       MOVE IN THE DECIMAL POINT\n         LA    R1,GASTRK-1\n         LA    R1,1(,R1)           SCAN FOR\n         CLI   0(R1),C'0'               FIRST\n         BE    *-8                           NON-ZERO\n         CLI   0(R1),C'.'          WAS FIRST NON-ZERO THE PERIOD?\n         BNE   *+L'*+2             NO, BRANCH\n         BCTR  R1,0                YES, BACK UP ONE CHARACTER\n        OUTPT  MINUS1,0(R1),A=     OUTPUT GAS TRACK TOTAL\nNOGASM  OUTPT  MINUS1,BLANKS,A=\n         L     R0,EOFS\n         S     R0,GASCNT\n         BNP   NOREAL\n         ST    R0,TEMP\n        OUTPT  MINREL,MINRELS      MIN BYTES PER REAL MEMBER\n         L     R15,TEMP\n         SRL   R15,1\n         A     R15,RELBYTE\n         XR    R14,R14\n         D     R14,TEMP\n         LR    R0,R15\n        OUTPT  R0,AVGRELS          AVG BYTES PER MEMBER\n        OUTPT  MAXREL,MAXRELS      MAX BYTES PER MEMBER\n         B     SOMEARE\nNOREAL  OUTPT  MINUS1,NOREALS\nSOMEARE OUTPT  MINUS1,BLANKS,A=\n        OUTPT  ALLOCBLK,ALLBLK\n        OUTPT  USEDBLK,USEBLK\n         L     R1,REALMBR\n         A     R1,ALIASES\n         ST    R1,MINBLK\n        OUTPT  MINBLK,USENAME\n         L     R1,ALIASES\n         LTR   R1,R1\n         BZ    END3\n        OUTPT  ALIASES,ALSNAME\n         CLC   REALMBR,REALENT     ANY ALIASES WITHOUT REALS?\n         BE    END3                NO, DONE\n        OUTPT  MINUS1,BLANKS,A=\n         BAS   R14,REREAD\n         L     R3,ALIASES\nTRYAGN   L     R2,SAVETBL\n         USING TLELM,R2\n         BAS   R14,MEMBERS\n         LTR   R15,R15\n         BP    END3\n         TM    11(R1),X'80'        ALIAS?\n         BNO   TRYAGN              NO, GET THE NEXT ENTRY\n         MVC   ALNOREAL(8),0(R1)   PREPARE ERROR MESSAGE\n        TTRMBB 8(R1),MBB=DOUBLE\nREALAGN  AL    R2,TLC\n         CLC   TLADDR(L'TLADDR),DOUBLE  CORRESPONDING TABLE ENTRY?\n         BNE   REALAGN             NO, TRY THE NEXT ONE\n         TM    TLSTAT,TLALIAS      YES, ALIAS (IN THE TABLE)?\n         BZ    FOUNDIT             NO, BRANCH\n        OUTPT  MINUS1,ALNOREAL,A=  YES, ALIAS WITH NO REAL\nFOUNDIT  BCT   R3,TRYAGN\n         DROP  R2\n         SPACE 1\nEND3    CLOSE  IN                  END POINT IF DSORG=PO, PS OR DA\n         TM    DS1DSORG,DS1DSGIS   ISAM DATA-SET?\n         BNO   ENDALL              NO, BRANCH\n         OI    JFCBTSDM,JFCNWRIT   PREVENT REVERSE MERGE TO JFCB\n         MVI   JFCBDSNM,X'04'      SET-UP DSNAME FOR\n         MVC   JFCBDSNM+1(43),JFCBDSNM  FORMAT 4 DSCB\n        OPEN   (IN,INPUT),TYPE=J   DO AN OPEN JFCB\n         TM    DCBOFLGS,DCBOFOPN   OPENED CORRECTLY?\n         BZ    ABE40               NO, QUIT\n         BAS   R14,REREAD\n         MVC   IOBSEEK+3(5),DS1PTRDS    POINTER TO FORMAT 2 DSCB\n         BAS   R14,EXCP            READ THE FORMAT 2 DSCB\n         LTR   R15,R15\n         BZ    NOABE11\n        OUTPT  MINUS1,NODSCB2      FORMAT 2 DSCB NOT READ CORRECTLY\n        KILL   4 ------- READ FMT 2 DSCB ERROR ****************** 4 ***\nNOABE11 OUTPT  MINUS1,BLANKS,A=\n        OUTPT  MINUS1,DSCB2\n         L     R5,BUFFER\n         USING DS2FMTID,R5\n         XR    R0,R0\n         IC    R0,DS2NOLEV\n         ST    R0,TEMP\n        OUTPT  R0,DSSNOLEV         INDEX LEVELS\n         MVC   TEMP+3(1),DS2DVIND\n        OUTPT  TEMP,DSSDVIND       TRACKS FOR MASTER INDEX\n         MVC   TEMP+3(1),DS2CYLOV\n        OUTPT  TEMP,DSSCYLOV       TRACKS OF CYL. OVERFLOW PER CYLINDER\n         MVC   TEMP+2(2),DS2TAGDT\n        OUTPT  TEMP,DSSTAGDT       TAGGED FOR DELETION\n         MVC   TEMP+1(3),DS2RORG3\n        OUTPT  TEMP,DSSRORG3       OVERFLOW RECORD ACCESSES\n         LH    R0,DS2NOBYT\n        OUTPT  R0,DSSNOBYT         CORE TO HOLD THE HIGHEST INDEX\n         XR    R0,R0\n         IC    R0,DS2NOTRK\n        OUTPT  R0,DSSNOTRK         TRACKS OCCUPIED BY THE HIGHEST INDEX\n         MVC   TEMP(4),DS2PRCTR\n        OUTPT  TEMP,DSSPRCTR       RECORDS IN THE PRIME AREA\n         LH    R0,DS2BYOVL\n        OUTPT  R0,DSSBYOVL         BYTES LEFT ON CUR. IND. OVER. TRACK\n         LH    R0,DS2RORG2\n        OUTPT  R0,DSSRORG2         TRACKS LEFT IN IND. OVERFLOW AREA\n         LH    R0,DS2OVRCT\n        OUTPT  R0,DSSOVRCT         RECORDS IN THE OVERFLOW AREA\n         LH    R0,DS2RORG1\n        OUTPT  R0,DSSRORG1         CYLINDER OVERFLOW AREAS (FULL)\n         DROP  R5\n        CLOSE  IN\n         B     ENDALL\n         SPACE 1\nSTOW    CLOSE  IN\n         TM    FLAGS,GASALL        ALL GAS TO RECOVER?\n         BO    STGALL              YES\n         OC    STOWTTR,STOWTTR     GAS (TTR) ENCOUNTERED?\n         BNZ   STOWIT              YES, BRANCH\n        OUTPT  MINUS1,NTFGAS\n         B     ENDALL\nSTGALL   CLC   GTSTR,GTANK         ANY GAS FOUND?\n         BL    NGDS                NO\n         MVC   GTSTR+8,GTSTR       YES, SET POINTERS\n         MVC   GTSTR,GTANK\n         B     STOWIT\nNGDS    OUTPT  MINUS1,NGASDS\n         B     ENDALL\nSTOWIT  OPEN   (PDS,UPDAT)\n         LA    R3,1                MEMBER NAME SEQUENCE NUMBER\nSTOWLP   CVD   R3,DOUBLE\n         UNPK  STOWMEM+4(4),DOUBLE+5(3)\n         OI    STOWMEM+7,C'0'\n         L     R2,SAVETBL\n         USING TLELM,R2\nSTOWST   AL    R2,TLC\n         CLI   0(R2),C' '          EMPTY TABLE ENTRY?\n         BE    STOWOK              YES, BRANCH\n         CLC   TLNAME(L'TLNAME),STOWMEM IS IT THIS ENTRY?\n         BNE   STOWST              NO, CHECK NEXT ENTRY\n         DROP  R2\nSTOWNX   LA    R3,1(R3)            NEXT SEQUENCE NUMBER\n         CL    R3,=F'9999'         MAXIMUM REACHED?\n         BNH   STOWLP              NO\n         TM    FLAGS,GASALL        YES, ALL GAS TO RECOVER?\n         BO    GALLUN              YES\n        OUTPT  MINUS1,GUNABLE\n         B     STOWEX\nGALLUN  OUTPT  MINUS1,TOOMUCH\n         B     STOWEX\nSTOWOK   TM    FLAGS,GASALL        ALL GAS TO RECOVER?\n         BZ    *+L'*+10            NO\n         L     R1,GTSTR            YES, SET TTR OF GAS\n         MVC   STOWTTR(L'STOWTTR),0(R1)\n         XR    R15,R15\n        STOW   PDS,STOWMEM,A\n         MVC   WORK,BLANKS         CLEAR WORK AREA\n         MVC   WORK(6),=CL6'MEMBER'\n         MVC   WORK+7(L'STOWMEM),STOWMEM\n         MVC   WORK+L'STOWMEM+8(L'STOWMSGA),STOWMSGA\n         LTR   R15,R15\n         BNZ   STOWERR\n         TM    FLAGS,GASALL        ALL GAS TO RECOVER?\n         BO    *+L'*+10            YES\n         MVC   WORK+L'STOWMEM+L'STOWMSGA+9(L'GASTTR),GASTTR\n         B     STOWMS\n         UNPK  DOUBLE(2*L'STOWTTR+1),STOWTTR(L'STOWTTR+1)\n         TR    DOUBLE(2*L'STOWTTR),HEXTBL-X'F0'\n         MVC   WORK+L'STOWMEM+L'STOWMSGA+9(2),DOUBLE\n         MVI   WORK+L'STOWMEM+L'STOWMSGA+11,C'.'\n         MVC   WORK+L'STOWMEM+L'STOWMSGA+12(2),DOUBLE+2\n         MVI   WORK+L'STOWMEM+L'STOWMSGA+14,C'.'\n         MVC   WORK+L'STOWMEM+L'STOWMSGA+15(2),DOUBLE+4\n        OUTPT  MINUS1,WORK,LN=L'WORK,A=\n         L     R1,TOTGAS\n         AH    R1,=H'1'\n         ST    R1,TOTGAS\n         L     R1,GTSTR\n         LM    R14,R15,GTSTR+4\n         BXLE  R1,R14,STOWONA\n         L     R1,TOTGAS\n         CVD   R1,DOUBLE\n         MVC   LASTMBB(6),=XL6'402020202120'\n         ED    LASTMBB(6),DOUBLE+5\n         MVC   ENDGALL(5),LASTMBB+1\n        OUTPT  MINUS1,ENDGALL,A=\n         B     STOWEX\nSTOWONA  ST    R1,GTSTR\n         B     STOWNX\nSTOWERR  MVC   WORK+L'STOWMEM+8(L'STOWMSGB),STOWMSGB\n         STC   R15,WORK+L'STOWMEM+L'STOWMSGB-9\n         SRL   R15,4\n         STC   R15,WORK+L'STOWMEM+L'STOWMSGB-10\n         NC    WORK+L'STOWMEM+L'STOWMSGB-10(2),=XL2'0F0F'\n         TR    WORK+L'STOWMEM+L'STOWMSGB-10(2),HEXTBL\n         STC   R0,WORK+L'STOWMEM+L'STOWMSGB-1\n         SRL   R0,4\n         STC   R0,WORK+L'STOWMEM+L'STOWMSGB-2\n         NC    WORK+L'STOWMEM+L'STOWMSGB-2(2),=XL2'0F0F'\n         TR    WORK+L'STOWMEM+L'STOWMSGB-2(2),HEXTBL\nSTOWMS  OUTPT  MINUS1,WORK,LN=L'WORK,A=\nSTOWEX  CLOSE  PDS\n         SPACE 1\nENDALL  CLOSE  OUT\n         XR    R2,R2               RC = 0 -----------------------------\nLEAVE    TM    FLAGS,GASALL        WAS ALL GAS TO RECOVER?\n         BZ    NOFGAR              NO\n         LM    R0,R1,GTLGTH        YES\n        FREEMAIN R,A=(1),LV=(0)\nNOFGAR   LM    R0,R1,ARLGTH\n        FREEMAIN R,A=(1),LV=(0)\n        $XRET  CC=(R2)\nSETRC    LA    R2,16               RC = 16 ----------------------------\n         B     LEAVE\n         EJECT\n*------ ISSUES EXCP'S AND GATHERS STATISTICS.\n         SPACE 1\nEXCPSTAT ST    R14,STATR14\n         BAS   R14,EXCP\n         B     *+L'*(R15)\n         B     R15IS0              GOOD READ\n         B     R15IS4              END OF FILE OR END OF MEMBER\n         B     R15IS8              END OF DATA-SET\nR15IS12 OUTPT  MINUS1,BLANKS,A=    I/O OR OTHER DISK ERROR\n         L     R14,INAROW\n         LA    R14,1(,R14)         UPDATE NUMBER OF CONSECUTIVE ERRORS\n         ST    R14,INAROW\n         C     R14,=F'10'          ALLOW ONLY 10 CONSECUTIVE ERRORS\n         BL    CONTINUE\n        OUTPT  MINUS1,TOOMANY      TOO MANY CONSECUTIVE ERRORS\n        KILL   5 ------- PERMANENT I/O DISK ERROR *************** 5 ***\nCONTINUE HEXES SAVECB,1,IOERROR+21 ECB ERROR CODE\n        HEXES  CURMBB+3,5,IOERROR+33    CURRENT DISK CCHHR\n        OUTPT  MINUS1,IOERROR,A=\n         TM    DS1DSORG,DS1DSGPO   PDS?\n         BNO   BLKNUM              NO, BRANCH\n         TM    FLAGS,DIRECTOR      ERROR IN THE DIRECTORY?\n         BO    DIRERR              YES, BRANCH\n         TM    FLAGS,REALONE       ACTUAL MEMBER?\n         BNO   GASERR              NO, BRANCH\n        OUTPT  MINUS1,CURRMBR,A=   OUTPUT THE CURRENT MEMBER NAME\n         B     R15IS4$\nGASERR  OUTPT  MINUS1,GASERRS      ERROR IN READING GAS DATA\n         B     R15IS4$\nDIRERR  OUTPT  MINUS1,DIRERRS      DIRECTORY I/O ERROR (IGNORE BLOCK)\nBLKNUM  OUTPT  READTOT,BLKNUMS     READ ERROR MESSAGE\n         B     EXCPSTAT+4          CONTINUE -- USING THE NEXT BLOCK\n         SPACE 1\nR15IS4   MVC   INAROW,=F'0'        END OF MEMBER\nR15IS4$  LA    R15,4               TREAT AS END OF MEMBER CONDITION\n         L     R1,EOFS\n         LA    R1,1(,R1)           END OF MEMBER COUNTER\n         ST    R1,EOFS\n         CLC   MBBCCHH(7),CURMBB   NEW TRACK\n         BNE   NEWTRACK\n         L     R1,LASTR\n         LA    R1,1(,R1)\n         ST    R1,LASTR            UPDATE THE RECORD COUNT\n         B     RETURNS\n         SPACE 1\nR15IS0   MVC   INAROW,=F'0'        GOOD READ\nR15IS0$  L     R1,READTOT\n         LA    R1,1(,R1)\n         ST    R1,READTOT          COUNT OF BLOCKS READ\n         L     R1,LS               CURRENT BLKSIZE\n         LR    R0,R1               SAVE FOR LATER\n         C     R1,MINBLK\n         BH    *+L'*+4\n         ST    R1,MINBLK           MINIMUM LENGTH BLOCK READ\n         C     R1,MAXBLK\n         BL    *+L'*+4\n         ST    R1,MAXBLK           MAXIMUM LENGTH BLOCK READ\n         A     R1,BYTECNT\n         ST    R1,BYTECNT          TOTAL NUMBER OF BYTES READ\n         TM    DS1DSORG,DS1DSGIS   ISAM DATA-SET?\n         BNO   NOFILSUM            NO, BRANCH\n         L     R1,READTOTI\n         LA    R1,1(,R1)\n         ST    R1,READTOTI         COUNT OF BLOCKS READ\n         LR    R1,R0               CURRENT BLKSIZE\n         C     R1,MINBLKI\n         BH    *+L'*+4\n         ST    R1,MINBLKI          MINIMUM LENGTH BLOCK READ\n         C     R1,MAXBLKI\n         BL    *+L'*+4\n         ST    R1,MAXBLKI          MAXIMUM LENGTH BLOCK READ\n         A     R1,BYTECNTI\n         ST    R1,BYTECNTI         TOTAL NUMBER OF BYTES READ\nNOFILSUM CLC   MBBCCHH(7),CURMBB   SAME MBBCCHH?\n         BNE   NEWTRACK            NO, BRANCH\n         A     R0,CURBYTE\n         ST    R0,CURBYTE          ACCUMULATE TRACK BYTE COUNT\n         L     R1,LASTR\n         LA    R1,1(,R1)\n         ST    R1,LASTR            ACCUMULATE RECORD COUNT/TRACK\n         B     RETURNS\n         SPACE 1\nNEWTRACK L     R1,TRACKNUM         SWITCH TRACKS --\n         LA    R1,1(,R1)\n         ST    R1,TRACKNUM         ACTUAL TRACKS USED\nR15IS8   MVC   MBBCCHH(7),CURMBB   SAVE CURRENT TRACK NUMBER\n         L     R0,CURBYTE\n         L     R1,LS\n         ST    R1,CURBYTE\n         L     R1,TRKBYTE\n         AR    R1,R0\n         ST    R1,TRKBYTE          COUNT OF ALL CHARACTERS READ\n         L     R1,LASTR\n         LA    R14,1\n         ST    R14,LASTR\n         L     R14,ALLR\n         AR    R14,R1\n         ST    R14,ALLR            COUNT OF ALL READS\n         LTR   R0,R0               FIRST ENTRY HERE?\n         BNP   NOMINS              YES, BRANCH\n         C     R0,MINBYTE\n         BNL   *+L'*+4\n         ST    R0,MINBYTE          MIN BYTES/TRACK\n         C     R1,MINR\n         BNL   NOMINS\n         ST    R1,MINR             MIN RECORD NUMBER/TRACK\nNOMINS   C     R0,MAXBYTE\n         BNH   *+L'*+4\n         ST    R0,MAXBYTE          MAX BYTES/TRACK\n         C     R1,MAXR\n         BNH   RETURNS\n         ST    R1,MAXR             MAX RECORD NUMBER/TRACK\n         SPACE 1\nRETURNS  L     R14,STATR14\n         BR    R14\n         EJECT\n*------- MEMBER INPUT ROUTINE.\n         SPACE 1\nMEMBERS  ST    R14,MEMBR14\n         LM    R15,R1,DIRPTRS      PICK UP ADDR, INCR, LIMIT\n         LTR   R1,R1               INITIALIZED?\n         BNZ   DEBLOCK             YES, BRANCH\n         BAS   R14,REREAD          OPEN IN FOR INPUT OF THE DIRECTORY\nGETBLK   BAS   R14,EXCPSTAT        GET A DIRECTORY BLOCK\n         LTR   R15,R15             END OF FILE?\n         BP    MBRDONE             YES, END OF FILE INDICATION\n         CLC   LS+2(2),=H'256'     GOOD DIRECTORY BLOCK?\n         BNE   NODIRBLK            NO, BRANCH\n         LA    R0,2                INCREMENT IS 2 FIRST\n         L     R15,BUFFER          START\n         LH    R1,0(R15)           LENGTH HALFWORD\n         LA    R1,0(R1,R15)        LIMIT\n         BCTR  R1,0\nDEBLOCK  BXH   R15,R0,GETBLK\n         IC    R0,11(,R15)\n         N     R0,=F'31'           GET LENGTH BITS\n         AR    R0,R0               LENGTH * 2\n         A     R0,=F'12'           LENGTH * 2  +  12\n         STM   R15,R1,DIRPTRS      SAVE FOR LATER\n         CLI   0(R15),X'FF'        LAST MEMBER\n         BNE   *+L'*+8             NO, BRANCH\n         LA    R15,8               LAST MEMBER USED INDICATION\n         B     MBRDONE\n         LR    R1,R15              ADDRESS OF MEMBER NAME (RETURNED)\n         XR    R15,R15             GOOD READ INDICATION\n         B     MBRDONE\nNODIRBLK OUTPT MINUS1,EOFSIMS      RECORD LENGTH IS NOT 256\n        OUTPT  LS,BLOCKLEN         OUTPUT CURRENT LRECL\n         LA    R15,12              ERROR INDICATION\nMBRDONE  L     R14,MEMBR14         RETURN ADDRESS\n         BR    R14\n         EJECT\n*======= EXCP SUBROUTINES (OPENIN, REREAD AND EXCP).\n*------- OPEN THE FILE WITH DDNAME \"IN\".\n         SPACE 1\nOPENIN   ST    R14,EXCPR14         ENTRY TO OPEN THE FILE\n        RDJFCB (IN)                GET DSN AND VOLUME SERIAL\n         LTR   R15,R15             SUCCESSFUL?\n         BZ    NOABE40             YES, BRANCH\nABE40   OUTPT  MINUS1,NOTOPEN\n        KILL   6 ------- RDJFCB, OBTAIN OR OPEN FAILED ********** 6 ***\nNOABE40 OBTAIN MYLABEL             READ IN THE FORMAT 1 DSCB\n         LTR   R15,R15             SUCCESSFUL?\n         BNZ   ABE40               NO, STOP THE PROGRAM\n        OPEN   (IN,INPUT)\n         TM    DCBOFLGS,DCBOFOPN   IN OPEN?\n         BZ    ABE40               NO, STOP THE PROGRAM\n         B     REREAD+4\n         SPACE 1\n*------- ENTRY TO REREAD THE OPEN DATA-SET (DDNAME IS \"IN\").\n         SPACE 1\nREREAD   ST    R14,EXCPR14\n         L     R1,DCBDEBAD\n         XR    R14,R14\n         IC    R14,16(R1)          NUMBER OF EXTENTS\n         ST    R14,NUMEXT          SAVE FOR LATER\n         LA    R14,16(R1)          CURRENT EXTENT POINTER - 16\n         ST    R14,CUREXT          SAVE FOR LATER\n         MVI   IOBSEEK,0           RESET THE EXTENT NUMBER\n         LA    R15,4               EARLY EXIT FLAG\n         B     FIRSTONE            DO THE INITIAL EXTENT\n         SPACE 1\n*------- FOR EACH EXTENT, INITIALIZE CCHHR, SECTOR NUMBER\n*        AND READ IN THE LENGTH OF THE FIRST RECORD.\n         SPACE 1\nEACHXTNT XR    R1,R1               AFTER THE FIRST EXTENT --\n         IC    R1,IOBSEEK\n         LA    R1,1(,R1)\n         STC   R1,IOBSEEK          INCREMENT THE EXTENT NUMBER\n         C     R1,NUMEXT           PAST LAST EXTENT?\n         BNL   EOF$DS              YES, NO END OF DATA-SET RECORDED\n         SPACE 1\nFIRSTONE ST    R15,EXCPR15         SAVE ENTRY CODE FOR LATER\n         L     R1,CUREXT\n         LA    R1,16(R1)           CURRENT EXTENT ENTRY\n         MVC   IOBSEEK+3(4),6(R1)  INITIAL CCHH\n         ST    R1,CUREXT           UPDATE FOR LATER\n         MVI   IOBSEEK+7,0\n         MVI   SNO,0               SET SECTOR NUMBER=ZERO\n         LA    1,CCW1A\n         ST    1,CPADDR\n        EXCP   IOB\n        WAIT   ECB=ECB\n         CLI   ECB,X'7F'           GOOD READ?\n         BE    NOABE30             YES, BRANCH\n        OUTPT  MINUS1,FIRSTRD\n        KILL   7 ------- FIRST READ OF EXTENT DID NOT WORK ****** 7 ***\nNOABE30  LA    R1,CCW1\n         ST    R1,CPADDR\n         MVC   CCW3+6(2),DATALN    GET LENGTH FOR NEXT READ\n         MVI   IOBSEEK+7,1         SET R=1\n         L     R15,EXCPR15\n         LTR   R15,R15             EARLY EXIT DESIRED?\n         BZ    EXCP+4              NO, ISSUE THE EXCP AGAIN\n         L     R14,EXCPR14         RETURN FROM OPENIN, REREAD OR\n         BR    R14                 AFTER EOF AND EXTENT VIOLATION\n         SPACE 1\n*------- ENTRY FOR EACH EXCP TO BE PERFORMED.\n         SPACE 1\nEXCP     ST    R14,EXCPR14\n         CLI   ECB,X'42'           EXTENT VIOLATION LAST TIME?\n         BE    EACHXTNT            YES, DO THE NEXT EXTENT\n         MVC   CURMBB(8),IOBSEEK   SAVE DISK ADDRESS OF THIS RECORD\n         MVC   LS+2(2),DATALN      SAVE BLOCK LENGTH FOR THIS READ\n        EXCP   IOB\n        WAIT   ECB=ECB\n         XR    R15,R15             GOOD READ FLAG\n         CLI   ECB,X'42'           EXTENT VIOLATION (NEXT TIME)?\n         BE    ENDEXCP             YES, QUIT\n         TM    DS1DSORG,DS1DSGIS   ISAM DATA-SET?\n         BO    *+L'*+10            YES, IGNORE DS1LSTAR CHECK FOR ISAM\n         CLC   LASTMBB(8),CURMBB   PAST THE DS1LSTAR MARKER?\n         BNH   EOF$DS              YES, END OF FILE AND DATA-SET\n         CLI   ECB,X'7F'           GOOD READ?\n         BE    ENDEXCP             YES, QUIT\n         SPACE 1\n         CLI   ECB,X'41'           PERMANENT ERROR?\n         BE    NOABE10             YES, BRANCH\n        OUTPT  MINUS1,BADERROR\n         B     SOMERR              BAD ERROR, ECB NOT HEX 41, 42 OR 7F\nNOABE10  TM    CSW+4,X'01'         ACTUALLY EOF?\n         BO    EOF\n         CLC   CSW+4(4),=X'00200000'    NULL MEMBER OR DATA-SET?\n         BE    EOF                 YES, BRANCH\n        OUTPT  MINUS1,PERMERR\nSOMERR   LA    R15,12              PERMANENT ERROR -- NOT END OF FILE\n         MVC   SAVECB(1),ECB       SAVE ECB CODE FOR LATER\n         B     REISSUE\n         SPACE 1\nEOF      TM    DS1DSORG,DS1DSGPS+DS1DSGDA    DSORG=PS OR DA?\n         BNZ   EOF$DS              YES, END OF FILE AND DATA-SET\n         LA    R15,4               END OF MEMBER FLAG\n         CLC   =H'0',DATALN        NEXT BLOCK LENGTH = 0?\n         BNE   ENDEXCP             NO, BRANCH\nREISSUE  ST    R15,EXCPR15\n         LA    R1,CCW1A            NEED TO REISSUE THE INITIALIZATION\n         ST    R1,CPADDR                EXCP TO GET LENGTH AND ADDRESS\n        EXCP   IOB                      OF THE NEXT DATA BLOCK\n        WAIT   ECB=ECB\n         L     R15,EXCPR15         READ ERROR (12) OR END OF MEMBER (4)\n         LA    R1,CCW1\n         ST    R1,CPADDR\n         MVC   CCW3+6(2),DATALN    DATA LENGTH FOR NEXT EXCP\n         CLI   ECB,X'42'           EXTENT VIOLATION?\n         BE    EACHXTNT            YES, DO NEXT EXTENT -- EARLY EXIT\n         CLI   ECB,X'7F'           GOOD READ?\n         BE    ENDEXCP             YES, QUIT\n         CLI   ECB,X'41'           PERMANENT ERROR?\n         BE    NOABE70             YES, CHECK EOF\nABE70   OUTPT  MINUS1,BADERROR\n        KILL   8 ------- SOME OTHER BAD ERROR ******************* 8 ***\nNOABE70  TM    CSW+4,X'01'         NULL MEMBER (ANOTHER EOF)?\n         BO    ENDEXCP\nABE80   OUTPT  MINUS1,PERMERR\n        KILL   9 ------- PERMANENT ERROR AFTER EOF ************** 9 ***\nEOF$DS   LA    R15,8               END OF FILE AND DATA-SET FLAG\nENDEXCP  L     R14,EXCPR14         RETURN ADDRESS\n         BR    R14\n         EJECT\n*------- OUTPUT ROUTINE.\n*        NOTE : R0 NEGATIVE IF NO NUMERIC OUTPUT,\n*                  OTHERWISE OUTPUT NUMERIC\n*               R1 CONTAINS THE ADDRESS OF THE STRING TO OUTPUT\n*               R14 CONTAINS THE RETURN ADDRESS\n*               R15 CONTAINS THE LENGTH OF THE STRING\n         SPACE 1\nOUTRTN   ST    R14,RETOUT\n         BCTR  R15,0               MACHINE LENGTH\n         EX    R15,OUTMOVE         MOVE IN THE STRING\n         LTR   R0,R0               ANY LEADING NUMERICS?\n         LA    R1,OUTLINE+10\n         BM    OUTSTMT             NO, BRANCH\n         CVD   R0,DOUBLE\n         UNPK  OUTLINE(9),DOUBLE+3(5)   ASSUME NO MORE THAN 9 DIGITS\n         LA    R1,OUTLINE-1\n         LA    R1,1(,R1)           SCAN FOR\n         CLI   0(R1),C'0'               FIRST\n         BE    *-8                           NON-ZERO\n         OI    OUTLINE+8,X'F0'     MAKE THE LAST DIGIT PRINTABLE\nOUTSTMT  TM    DCBOFLGS-IHADCB+OUT,DCBOFOPN  OUT OPEN?\n         BO    OUTNOW              YES, BRANCH TO PUT\n         ST    R1,SAVER1           SAVE R1\n        OPEN   (OUT,OUTPUT)        OPEN\n         TM    DCBOFLGS-IHADCB+OUT,DCBOFOPN  OPEN NOW?\n         BO    OUTRST              YES, BRANCH\n         LA    R1,SMSG\n         BAS   R14,PUTMSG\n        KILL   10 ------ OUTPUT FILE DID NOT OPEN ************** 10 ***\nSMSG    WTO    ' -> DDNAME \"OUT\" COULD NOT BE OPENED.',                X\n               ROUTCDE=11,DESC=7,MF=L\nOUTRST   L     R1,SAVER1           RESTORE R1\nOUTNOW   BCTR  R1,0\n         MVI   0(R1),C' '\n         LR    R0,R1\n        PUT    OUT,(0)             OUTPUT THE LINE\n         MVI   OUTLINE,C' '\n         MVC   OUTLINE+1(L'OUTLINE-1),OUTLINE     BLANK IT\n         L     R14,RETOUT          RETURN\n         BR    R14\nOUTMOVE  MVC   OUTLINE+10(*-*),0(R1)    <<EXECUTED>>\n         SPACE 1\nGDMP    ABEND  (1),DUMP            THAT'S ALL FOLKS\n         EJECT\n*------- TRACE ROUTINE.\n*        NOTE : R1 POSITIVE = NEXT MBBCCHHR, ZERO = TABLED MBBCCHHR\n*                  AND NEGATIVE = CLOSE TRACE.\n*               R15 = CURRENT 'EXCP' CC (ONLY WHEN R1 POSITIVE).\n*      OUTPUT : 4 MBBCCHHR'S BY LINE, EACH ONE PRECEEDED BY\n*               - A BLANK TO INDICATE A NORMAL DATA BLOCK READ,\n*               - THE CHARACTER 'T' FOR A TABLED LOCATION (DIRECTORY),\n*               - ANOTHER CHARACTER (GENERALLY '4' FOR AN EOF) TO SAY\n*                 SPECIAL CONDITION.\n         SPACE 1\nTRACE    STM   R14,R3,TRSVREG      SAVE REGISTERS AROUND ROUTINE\n         L     R3,TCURPTR          GET CURRENT POINTER\n         LTR   R1,R1               WHAT REQUESTED?\n         BZ    TR01                TABLED\n         BP    TR02                NEXT\n         CL    R3,TSTRPTR          FINAL, ANYTHING TO TRACE?\n         BE    TR06                NO, BRANCH TO CLOSE\n         LR    R2,R1               YES, PASS INDICATOR\n         B     TR04                GO OUTPUT LAST INFORMATION\n         USING TLELM,R2\nTR01     MVI   0(R3),C'T'          INDICATE TABLED ORIGIN\n         UNPK  1(9,R3),TLADDR(5)   STORE TABLED MBBCCHHR\n         UNPK  9(9,R3),TLADDR+4(5)\n         MVI   17(R3),C' '\n         TR    1(16,R3),HEXTBL-X'F0'\n         B     TR03\n         DROP  R2\nTR02     MVI   0(R3),C' '\n         UNPK  1(9,R3),0(5,R1)     STORE NEXT MBBCCHHR\n         UNPK  9(9,R3),4(5,R1)\n         MVI   17(R3),C' '\n         TR    1(16,R3),HEXTBL-X'F0'\n         LTR   R15,R15             EOF ON PREVIOUS MBBCCHHR?\n         BZ    TR03                NO, BRANCH\n         STC   R15,0(R3)           INDICATE EOF\n         OI    0(R3),X'F0'\n         TR    0(1,R3),HEXTBL-X'F0'\nTR03     LA    R3,18(,R3)          BUMP POINTER\n         CL    R3,TMAXPTR          END OF AREA?\n         BL    TR08                NO, BRANCH\nTR04     TM    DCBOFLGS-IHADCB+TRC,DCBOFOPN  TRC OPEN?\n         BO    TR05                YES, BRANCH\n        OPEN   (TRC,OUTPUT)        OPEN\n         TM    DCBOFLGS-IHADCB+TRC,DCBOFOPN  OPEN NOW?\n         BO    TR05                YES, BRANCH\n        OUTPT  MINUS1,TRCOERR\n        KILL   11 ------ TRACE FILE DID NOT OPEN *************** 11 ***\nTR05    PUT    TRC,TRCL            OUTPUT THE LINE\n         MVC   TRCL+1(L'TRCL-1),TRCL    BLANK IT\n         LTR   R2,R2               FINAL CALL?\n         BNM   TR07                NO, BRANCH\nTR06    CLOSE  TRC                 CLOSE TRACE\n         NI    FLAGS,255-TEST      OFF TRACE\nTR07     L     R3,TSTRPTR          SET STARTING ADDRESS\nTR08     ST    R3,TCURPTR          SET NEW CURRENT POINTER\n         LM    R14,R3,TRSVREG      RESTORE REGISTERS\n         BR    R14                 RETURN\n         EJECT\n*------- CONSTANTS AND WORK AREAS.\n         SPACE 1\nDOUBLE   DC    D'0'\nLASTMBB  DC    D'0'\nCCW1A    CCW   X'31',IOBSEEK+3,X'60',5       SEARCH ID EQUAL (CCHHR)\nCCW2A    CCW   X'08',*-8,X'60',1             TIC\nCCW3A    CCW   X'92',IOBSEEK+3,X'20',8       MT READ NEXT COUNT\n         SPACE 1\nCCW0     CCW   X'23',SNO,X'60',1             SET SECTOR\nCCW1     CCW   X'31',IOBSEEK+3,X'60',5       SEARCH ID EQUAL (CCHHR)\nCCW2     CCW   X'08',*-8,X'60',1             TIC\nCCW3     CCW   X'06',*-*,X'60',32767         READ DATA\nCCW4     CCW   X'92',IOBSEEK+3,X'60',8       MT READ NEXT COUNT\nCCW5     CCW   X'22',SNO,X'20',1             READ SECTOR NUMBER\n         SPACE 1\nIOB      DC    0F'0',X'C2000000'\n         DC    A(ECB)\nCSW      DC    2A(0)\nCPADDR   DC    A(CCW1)\n         DC    A(IN)\n         DC    2A(0)\nIOBSEEK  DC    2A(0)               NEXT MBBCCHHR ADDRESS\n         DC    X'0'                NEXT KEYLENGTH\nDATALN   DC    2X'0'               NEXT RECORD LENGTH\nSNO      DC    X'0'                NEXT SECTOR NUMBER\nCURMBB   DC    CL8' '              CURRENT MBBCCHHR ADDRESS\nMBBCCHH  DC    CL7' '              SAVE AREA FOR MBBCCHH\nSAVECB   DC    X'0'                SAVE AREA FOR ECB\nECB      DC    F'0'                ECB\n         SPACE 1\nDIRPTRS  DC    3A(0)               SAVEAREA FOR R15, R0 AND R1\nMEMBR14  DC    A(0)                SAVEAREA FOR RETURN ADDRESS\nRETOUT   DC    A(0)                SAVEAREA FOR RETURN ADDRESS\nSAVER1   DC    A(0)                SAVEAREA FOR R1 DURING OPEN\nLS       DC    F'0'                LENGTH OF THE CURRENT RECORD\nLASTR    DC    F'0'                CURRENT NUMBER OF RECORDS/TRK\nEXCPR14  DC    F'0'                RETURN REGISTER FOR EXCP\nEXCPR15  DC    F'0'                EXIT FLAG REGISTER SAVEAREA\nSTATR14  DC    F'0'                RETURN REGISTER FOR EXCPSTAT\nCUREXT   DC    F'0'                ADDRESS OF THE CURRENT EXTENT\nNUMEXT   DC    F'0'                TOTAL EXTENTS IN THE DATA-SET\nREADTOT  DC    F'0'                TOTAL RECORDS READ\nMINBLK   DC    F'33000'            MINIMUM LENGTH BLOCK\nMAXBLK   DC    F'0'                MAXIMUM LENGTH BLOCK\nBYTECNT  DC    F'0'                TOTAL BYTES READ\nREADTOTI DC    F'0'                TOTAL RECORDS READ (ISAM)\nMINBLKI  DC    F'33000'            MINIMUM LENGTH BLOCK (ISAM)\nMAXBLKI  DC    F'0'                MAXIMUM LENGTH BLOCK (ISAM)\nBYTECNTI DC    F'0'                TOTAL BYTES READ (ISAM)\nTEMP     DC    F'0'                WORK STORAGE\nGASBYTE  DC    F'0'                TOTAL BYTES IN GAS MEMBERS\nRELBYTE  DC    F'0'                TOTAL BYTES IN REAL MEMBERS\nMINGAS   DC    X'7F000000'         MIN BYTES IN GAS MEMBERS\nMAXGAS   DC    F'0'                MAX BYTES IN GAS MEMBERS\nMINREL   DC    X'7F000000'         MIN BYTES IN REAL MEMBERS\nMAXREL   DC    F'0'                MAX BYTES IN REAL MEMBERS\nSAVETOT  DC    F'0'                STARTING BYTE COUNT HOLD\nMAXR     DC    F'0'                MAXIMUM RECORDS/TRACK\nMINR     DC    F'255'              MINIMUM RECORDS/TRACK\nTRKBYTE  DC    F'0'                SUM OF ALL BLOCKSIZES\nINAROW   DC    F'0'                NUMBER OF CONSECUTIVE ERRORS\nALLR     DC    F'0'                SUM OF ALL RECORDS READ\nCURBYTE  DC    F'0'                CURRENT TRACK BYTE COUNT\nMAXBYTE  DC    F'0'                MAXIMUM BYTES/TRACK\nMINBYTE  DC    X'7F000000'         MINIMUM BYTES/TRACK\nTRACKNUM DC    F'0'                ACTUAL COUNT OF TRACKS USED\nMINUS1   DC    F'-1'               NO NUMERIC OUTPUT FLAG\nEOFS     DC    F'0'                COUNT OF END OF FILES\nGASCNT   DC    F'0'                NUMBER OF \"GAS\" MEMBERS\nGASRDS   DC    F'0'                NUMBER OF \"GAS\" RECORDS\nAVGBTRK  DC    F'0'                AVERAGE BYTES PER TRACK\nAVAILTRK DC    F'0'                FREE TRACKS\nTOTALTRK DC    F'0'                TOTAL TRACKS\nALIASES  DC    F'0'                ALIASES IN THE DIRECTORY\nREALMBR  DC    F'0'                REAL ENTRIES (DIRECTORY)\nREALENT  DC    F'0'                MEMBER TABLE ENTRIES\nALLOCBLK DC    F'0'                DIRECTORY BLOCKS ALLOCATED\nUSEDBLK  DC    F'0'                DIRECTORY BLOCKS USED\nTOTGAS   DC    F'0'                TOTAL GAS MEMBERS PROCESSED\nTLC      DC    A(TLG)\nTLMX     DC    A(NTEL)\nARLGTH   DC    F'0'                I/O AREA AND DIR. ENTRIES LENGTH\nBUFFER   DC    A(*-*)              I/O AREA AND DIR. ENTRIES ADDRESS\nGTNEL    EQU   NGEL*L'STOWTTR      GAS RECORDING ELEMENTS AREA\nGTLGTH   DC    A(((GTNEL+7)/8)*8)  GAS RECORDING AREA LENGTH\nGTANK    DC    A(*-*)              GAS RECORDING AREA ADDRESS\nGTSTR    DC    A(*-*,L'STOWTTR,GTNEL-L'STOWTTR)   TO STORE GAS TTR'S\nSAVETBL  DC    A(*-*)              BASE ADDR. TO ROOM FOR DIR. ENTRIES\nTRSVREG  DC    6F'0'\nTCURPTR  DC    A(TRCL+6)\nTSTRPTR  DC    A(TRCL+6)\nTMAXPTR  DC    A(TRCL+(4*18))\nSTOWMEM  DC    CL8'$GAS0000'       GAS - MEMBER NAME\nSTOWTTR  DC    XL3'0',X'80'        TTR, ALIAS FLAG\nGASTTR   DC    XL8'0'\n         SPACE 1\n        $TEW$WA\n         SPACE 1\n        PRINT  NOGEN\nOUT     DCB    DDNAME=OUT,DSORG=PS,MACRF=PM,                           1\n               RECFM=FB,LRECL=80,BLKSIZE=80\n         SPACE 1\nTRC     DCB    DDNAME=TRC,DSORG=PS,MACRF=PM,                           1\n               RECFM=FB,LRECL=80,BLKSIZE=80\n         SPACE 1\nPDS     DCB    DDNAME=IN,DSORG=PO,MACRF=(R)\n         SPACE 1\nIN      DCB    DDNAME=IN,DSORG=PS,MACRF=E,EXLST=JFCBXIT\n         SPACE 1\nJFCBXIT  DC    X'87',AL3(JFCB)     JFCB BLOCK\nJFCB     DS    0D\n        IEFJFCBN                   JFCB MAPPING MACRO\n         SPACE 1\n        PRINT  GEN\nMYLABEL CAMLST SEARCH,JFCBDSNM,JFCBVOLS,WORKAREA\nWORKAREA DS    0D,148C\n         SPACE 1\nALNOREAL DC    CL50'12345678 IS AN ALIAS BUT HAS NO \"REAL\" ENTRY      '\nSCALOS   DC    CL50'DATA-SET IS ALLOCATED IN 123456                   '\nIOERROR  DC    CL50'READ ERROR -- ECB = 12, CCHHR = 12.45.78.01.34    '\nCURRMBR  DC    CL50'12345678 IS THE MEMBER (END OF MEMBER SIMULATED)  '\nLASTMEMS DC    CL50'12345678 IS THE LAST REAL MEMBER IN THE DATA-SET  '\nPROTECT  DC    CL50'X IS THE PROTECTION KEY                           '\nGASMEM   DC    CL50'\"GAS\" MEMBER AT TTR TT.TT.RR, DATA :              '\nLSTAR    DC    CL50'DS1LSTAR IS MM.BB.BB.CC.CC.HH.HH.RR               '\nNOMEOF   DC    CL50'MEMBER : 12345678 (END OF MEMBER MISSING) ++++++++'\nINVTTR   DC    CL50'MEMBER : 12345678 (INVALID TTR POINTER) ..........'\nENDGALL  DC    CL50'12345 \"GAS\" MEMBERS PROCESSED - END               '\nGASTRK   DC    CL60'1234567.9 TRACKS WOULD BE REGAINED BY COMPRESSING '\nBLANKS   DC    CL80' '\n         SPACE 1\nFLAGS    DC    AL1(GAS)            FLAG BYTE\nGAS      EQU   X'01'                    GAS RECORDS DESIRED (DEFAULT)\nLABELS   EQU   X'02'                    LABELS ONLY (NO DATA READ)\nFULL     EQU   X'04'                    FULLY INFORMATION LIST\nTEST     EQU   X'08'                    TRACE MBBCCHHR'S\nGASADD   EQU   X'10'                    GAS RECORD TO BE RECOVERED\nGASALL   EQU   X'20'                    ALL GAS RECORDS TO BE RECOVERED\nREALONE  EQU   X'40'                    ERROR IN ACTUAL MEMBER FLAG\nDIRECTOR EQU   X'80'                    ERROR IN DIRECTORY RECORDS\n         SPACE 1\nSWITCH   DC    AL1(0)                   WORK SWITCH BYTE\nDIRPR    EQU   X'01'\nALIAS    EQU   X'02'\n         SPACE 1\nHEXTBL   DC    CL16'0123456789ABCDEF'\nWORK     DC    CL80' '\n         DC    CL2' '\nOUTLINE  DC    CL90' '\nTRCL     DC    CL80' '\n         SPACE 1\nSTOWMSGA DC    C'ADDED TO DIRECTORY FOR TTR'\nSTOWMSGB DC    C'NOT ADDED TO DIRECTORY : R15=XX - R0=XX'\n         SPACE 1\n        LTORG\n         SPACE 1\n         DROP  R8,R9,R10,R11,R12   END OF BASE REGISTERS ADDRESSABILITY\n         EJECT\n*------- UNMODIFIED MESSAGES (OUTPT A=I).\n         SPACE 1\nPRGRM    DC    CL50'STATDS : DISK DATA-SET STATISTICS PROGRAM         '\nSQL      DC    CL50'-----------------------------------------         '\nNODSCB2  DC    CL50'ISAM FMT 2 DSCB READ ERROR -----------------------'\nDSCB2    DC    CL50'THE FOLLOWING DATA IS FROM THE ISAM LABEL RECORD :'\nDSSNOLEV DC    CL50'INDEX LEVELS PRESENT IN THIS DATA-SET             '\nDSSDVIND DC    CL50'TRACKS FOR EACH MASTER INDEX                      '\nDSSCYLOV DC    CL50'TRACKS OF CYLINDER OVERFLOW AREA ON EACH CYLINDER '\nDSSTAGDT DC    CL50'RECORDS TAGGED FOR DELETION                       '\nDSSRORG3 DC    CL50'OVERFLOW ACCESSES (NOT COUNTING FIRST IN CHAIN)   '\nDSSNOBYT DC    CL50'BYTES NEEDED TO HOLD THE HIGHEST INDEX IN CORE    '\nDSSNOTRK DC    CL50'TRACKS OCCUPIED BY THE HIGHEST-LEVEL INDEX        '\nDSSPRCTR DC    CL50'RECORDS IN THE PRIME AREA                         '\nDSSBYOVL DC    CL50'BYTES LEFT ON CURRENT INDEPENDENT OVERFLOW TRACK  '\nDSSRORG2 DC    CL50'TRACKS REMAINING IN THE INDEPENDENT OVERFLOW AREA '\nDSSOVRCT DC    CL50'RECORDS IN THE OVERFLOW AREA                      '\nDSSRORG1 DC    CL50'CYLINDER OVERFLOW AREAS THAT ARE FULL             '\nMINRS    DC    CL50'IS THE MINIMUM NUMBER OF RECORDS PER TRACK        '\nAVGRS    DC    CL50'IS THE AVERAGE NUMBER OF RECORDS PER TRACK        '\nMAXRS    DC    CL50'IS THE MAXIMUM NUMBER OF RECORDS PER TRACK        '\nMINBYTES DC    CL50'IS THE MINIMUM NUMBER OF DATA BYTES PER TRACK     '\nAVGBYTES DC    CL50'IS THE AVERAGE NUMBER OF DATA BYTES PER TRACK     '\nMAXBYTES DC    CL50'IS THE MAXIMUM NUMBER OF DATA BYTES PER TRACK     '\nMINGASS  DC    CL50'IS THE MINIMUM NUMBER OF BYTES IN ANY GAS MEMBER  '\nAVGGASS  DC    CL50'IS THE AVERAGE NUMBER OF BYTES IN A GAS MEMBER    '\nMAXGASS  DC    CL50'IS THE MAXIMUM NUMBER OF BYTES IN ANY GAS MEMBER  '\nMINRELS  DC    CL50'IS THE MINIMUM NUMBER OF BYTES IN ANY REAL MEMBER '\nAVGRELS  DC    CL50'IS THE AVERAGE NUMBER OF BYTES IN A REAL MEMBER   '\nMAXRELS  DC    CL50'IS THE MAXIMUM NUMBER OF BYTES IN ANY REAL MEMBER '\nNOREALS  DC    CL50'NO REAL MEMBERS ARE IN THIS PARTITIONED DATA-SET  '\nMINBLKS  DC    CL50'IS THE SHORTEST BLOCK LENGTH                      '\nAVGBLKS  DC    CL50'IS THE AVERAGE BLOCK LENGTH                       '\nMAXBLKS  DC    CL50'IS THE MAXIMUM BLOCK LENGTH                       '\nTOTBYTS  DC    CL50'TOTAL DATA BYTES ARE IN THIS DATA-SET             '\nNUMBLKS  DC    CL50'TOTAL DATA BLOCKS ARE RECORDED                    '\nGASBLKS  DC    CL50'OF THESE ARE GAS BLOCKS                           '\nEOFSS    DC    CL50'END OF FILE                                       '\nENDMBR   DC    CL50'END OF MEMBER (FILE MARKS) ARE RECORDED           '\nGASMBR   DC    CL50'OF THESE ARE FOR GAS MEMBERS                      '\nALLBLK   DC    CL50'DIRECTORY BLOCKS ARE ALLOCATED                    '\nUSEBLK   DC    CL50'OF THESE ARE IN USE                               '\nUSENAME  DC    CL50'MEMBER NAMES ARE IN THE DIRECTORY                 '\nALSNAME  DC    CL50'OF THESE ARE ALIASES                              '\nNUMTRKS  DC    CL50'TRACKS ARE ALLOCATED FOR THIS DATA-SET            '\nEXTENTS  DC    CL50'IS THE SECONDARY ALLOCATION QUANTITY              '\nNOSEC    DC    CL50'NO SECONDARY ALLOCATION QUANTITY IS IN THE LABEL  '\nFRETRKS  DC    CL50'OF THESE ARE NOT IN USE                           '\nNUMEXTS  DC    CL50'EXTENTS ARE IN THIS DATA-SET                      '\nNOBDBS   DC    CL50'BYTES ARE USED IN LAST PDS DIRECTORY BLOCK        '\nTRBALS   DC    CL50'BYTES ARE AVAILABLE ON THE LAST USED TRACK        '\nTOOMANY  DC    CL50'TOO MANY CONSECUTIVE I/O ERRORS (10) -------------'\nMANYENT  DC    CL50'MEMBER ENTRIES TABLE OVERFLOW --------------------'\nNOTOPEN  DC    CL50'RDJFCB, OBTAIN OR OPEN FOR DDNAME \"IN\" FAILED ----'\nFIRSTRD  DC    CL50'FIRST READ OF AN EXTENT DID NOT WORK -------------'\nTTRTOLOW DC    CL50'TTR IN MEMBER TABLE .LT. CURRENT TTR -------------'\nNOTFOUND DC    CL50'MEMBERS NOT FOUND IN THE MEMBER TABLE ------------'\nBADERROR DC    CL50'UNDEFINED READ ERROR -----------------------------'\nPERMERR  DC    CL50'UNDEFINED PERMANENT ERROR ------------------------'\nEOFSIMS  DC    CL50'BAD DIRECTORY RECORD -- RECORD LENGTH IS NOT 256 -'\nBLOCKLEN DC    CL50'IS THE BLOCK LENGTH (END OF DIRECTORY SIMULATED)  '\nDIRERRS  DC    CL50'READ ERROR IN THE DIRECTORY ----------------------'\nBLKNUMS  DC    CL50'IS THE BLOCK NUMBER (BLOCK IGNORED)               '\nGASERRS  DC    CL50'ERROR IN A GAS MEMBER (END OF MEMBER SIMULATED)   '\nKEYLEN   DC    CL50'IS THE KEY LENGTH                                 '\nKEYPOS   DC    CL50'IS THE RELATIVE KEY POSITION                      '\nNULL     DC    CL50'DATA-SET IS EMPTY --------------------------------'\nEXTHDR   DC    CL50'EXTENT  UCB  CC.CC.HH.HH   CC.CC.HH.HH   T./TRACKS'\nEXTUND   DC    CL50'------  ---  -----------   -----------   ---------'\nNOTPDS   DC    CL50'THIS IS NOT A PARTITIONED DATA-SET ... -----------'\nNTFGAS   DC    CL50'REQUESTED \"GAS\" (TTR) NOT FOUND ... --------------'\nNGASDS   DC    CL50'NO \"GAS\" IN THE DATA-SET ... ---------------------'\nGOVFLOW  DC    CL50'NUMBER OF \"GAS\" OVERFLOW (INCOMPLETE PROCESS) ----'\nGUNABLE  DC    CL50'UNABLE TO RECOVER THE REQUESTED \"GAS\" ... --------'\nTOOMUCH  DC    CL50'UNABLE TO RECOVER ALL \"GAS\" IN DATA-SET ... ------'\nWRMSG    DC    CL50'PARM=GAS(TT.TT.RR) SYNTAX ERROR ... --------------'\nTRCOERR  DC    CL50'DDNAME \"TRC\" COULD NOT BE OPENED -----------------'\nDIRTLA   DC    CL50'DIRECTORY CONTENTS :                              '\nDIRTLB   DC    CL50'MEMBERS SORTED BY MBBCCHHR (OR TTR) :             '\nDIRTL1   DC    CL50'NAME    M/A   TT.TT.RR   MM.BB.BB.CC.CC.HH.HH.RR  '\nDIRTL2   DC    CL50'----    ---   --------   -----------------------  '\n         EJECT\n        PRINT  NOGEN\nPARMLST IKJPARM\nPGAS    IKJKEYWD\n        IKJNAME 'GAS',SUBFLD=SFGAS,ALIAS=('G')\nPOPT    IKJKEYWD\n        IKJNAME 'U'\n        IKJNAME 'NO',ALIAS=('N')\n        IKJNAME 'FULL',ALIAS=('F')\n        IKJNAME 'LABEL',ALIAS=('L')\n        IKJNAME 'TEST',ALIAS=('T')\nSFGAS   IKJSUBF\nSDGAS   IKJIDENT 'TT.TT.RR',MAXLNTH=8,FIRST=ANY,OTHER=ANY\n        IKJENDP\n         EJECT\nTLELM    DSECT                     \"SAVETBL\" ELEMENT DESCRIPTION\n         SPACE 1\nTLNAME   DS    CL8                 MEMBER NAME\nTLADDR   DS    XL8                 MBBCCHHR\nTLTTR    DS    XL3                 TTR\nTLSTAT   DS    XL1                 STATUS FLAGS\n         SPACE 1\nTLALIAS  EQU   X'01'               ALIAS NAME\n         SPACE 1\nTLG      EQU   *-TLELM             \"SAVETBL\" ELEMENT LENGTH\n         SPACE 1\n        $TEW$DS\nDSCDSECT DSECT\n        IECSDSL1 (1)\n         ORG   DS1DSNAM\n        IECSDSL1 (2)\n        DCBD   DSORG=PS,DEVD=DA\n        PRINT  GEN\n         SPACE 1\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "STATDS$": {"ttr": 15877, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x943O\\x00\\x943O\\x10S\\x00\\x1b\\x00\\x1b\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-30T00:00:00", "modifydate": "1994-11-30T10:53:00", "lines": 27, "newlines": 27, "modlines": 0, "user": "SYSPAJA"}, "text": "//STATDS   JOB (........),'INSTALL  -STATDS-',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=800K,TIME=1\n/*JOBPARM L=8\n//ASS     EXEC PAJ1AS3,MBR=STATDS\n//LNK     EXEC PAJILKL\n//SYSIN     DD *\n  ENTRY   STATS\n  NAME    STATS(R)\n/*\n//HLP     EXEC PAJHELP,MBR=STATDSH,DSS='->.SOURCE.FILE1'\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//* EXECUTE THE STEP BELOW WITH PROCEDURE :                           *\n//*       \"PAJPROC\" IF YOUR ->.TARGET.PROCLIB DATA-SET                *\n//*                         IS RECFM=FB AND LRECL=80, ELSE            *\n//*       \"PAJPROV\" IF YOUR ->.TARGET.PROCLIB DATA-SET                *\n//*                         IS RECFM=VB AND LRECL=255.                *\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//PRC     EXEC PAJPROC,MBR=STATDSP,DSS='->.SOURCE.FILE1'\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//* EXECUTE THE STEP BELOW WITH PROCEDURE :                           *\n//*       \"PAJPROC\" IF YOUR ->.TARGET.TSO.CLISTS DATA-SET             *\n//*                         IS RECFM=FB AND LRECL=80, ELSE            *\n//*       \"PAJPROV\" IF YOUR ->.TARGET.TSO.CLISTS DATA-SET             *\n//*                         IS RECFM=VB AND LRECL=255.                *\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//TCL     EXEC PAJPROC,MBR=STATDST,DSS='->.SOURCE.FILE1',\n//             DSP='->.TARGET.TSO.CLISTS'\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "STATDS@": {"ttr": 15879, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x08?\\x00\\x88\\x08?\\x15!\\x00V\\x00V\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-03-23T00:00:00", "modifydate": "1988-03-23T15:21:00", "lines": 86, "newlines": 86, "modlines": 0, "user": "SYSPAJA"}, "text": "1   23/03/88\n                                                      STATDS    1/2.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *         DATA-SET STATISTICS.        * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n   Function : The STATDS command procedure formats information on any\n   ---------- disk data-set. It reads through the entire data-set and\n              outputs disk track usage, blocksize and other statistics.\n\n   Syntax :   %STATDS 'DSN' PARM(/NO/LABEL/FULL)\n   --------   Required : 'DSN'\n              Default : the first value given is the default.\n              PARM() : means that all types of characteristics and\n                       statistics will be printed.\n              ALIAS : none.\n              Special : %STATDS 'DSN' PARM('GAS(TT.TT.RR)')\n                        or %STATDS 'DSN' PARM('GAS(ALL)')\n                        only for partitioned data-set.\n\n   Operands : 'DSN' - name of the data-set to be considered.\n   ----------\n  PARM(/NO/LABEL/FULL) :\n              specifies the amount and the types of information and\n              statistics desired.\n\n     PARM() : is the default value. The following information will be\n              given :\n              A) DCB and DSCB characteristics.\n              B) record counts, record size, track usage statistics\n                 for any type of data-set organization.\n                 For DSORG=IS, the command reads through the entire\n                 data-set (there may be up to three separate files of\n                 data and reports on each file). Also, the ISAM label\n                 (format 2 DSCB) record will be read and a data-set\n                 profile which includes data-set reorganization data\n                 and data-set characteristics will be provided.\n              C) for DSORG=PO, the directory TTR's will be compared\n                 against actual disk addresses to determine the TTRs\n                 of \"GAS\" members (the first 72 characters of any\n                 \"GAS\" member are outputed).\n                 \"GAS\" members are the old members which, after a\n                 replacement, keep the data blocks. The blocks are\n                 freed only by a compress.\n                 Statistics are maintained on the size of \"GAS\" and\n                 \"REAL\" members and the number of ALIAS members. If\n                 any ALIASes are in the data-set, a check is made\n                 to see that corresponding real entries also exist.\n                 The program finds \"GAS\" members only if the data-set\n                 has not been compressed out yet.\n1   23/03/88\n                                                      STATDS    2/2.\n\n     PARM(NO) : suppress the \"GAS\" TTR report.\n\n     PARM(LABEL) : only DCB and DSCB characteristics are reported.\n\n     PARM(FULL) : supply the directory members list (only DSORG=PO).\n\n     PARM('GAS(TT.TT.RR)') : will add a member name to the directory\n                 for the \"GAS\" member having the specified TTR location\n                 (in hex, obtained from a previous run). This is\n                 usefull if you know which one you want. Any user\n                 data that was in the directory entry of a deleted\n                 or replaced member cannot be recovered.\n     PARM('GAS(ALL)') : allows to recover all \"GAS\" members in a\n                 data-set.\n              -- Note about LOAD modules : this program cannot recover\n                 a \"GAS\" LOAD module. It will give it a member name so\n                 it wont be compressed out, but the directory entry\n                 will not be a LOAD module type. To reconstruct the\n                 proper LOAD module directory would require information\n                 that is no longer in the partitioned data-set.\n\n   Alternate way of use : the data-set statistics may be also executed\n   ---------------------- in a job as showed below.\n\n          JCL statement : //STAT EXEC STATDS,P=...,DSN='...'\n          where STATDS is the name of the following procedure :\n               //STDS    PROC P=,DSN=\n               //STDS    EXEC PGM=STATS,PARM='&P'\n               //IN        DD DSN=&DSN,DISP=SHR\n               //OUT       DD SYSOUT=*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "STATDSH": {"ttr": 15882, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\x08?\\x00\\x88\\x08?\\x15!\\x00;\\x00;\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-03-23T00:00:00", "modifydate": "1988-03-23T15:21:00", "lines": 59, "newlines": 59, "modlines": 0, "user": "SYSPAJA"}, "text": "./     ADD     NAME=STATDS\n./     NUMBER  NEW1=100,INCR=100\n)F FUNCTION : THE STATDS COMMAND PROCEDURE FORMATS INFORMATION ON ANY\n              DISK DATA-SET. IT READS THROUGH THE ENTIRE DATA-SET AND\n              OUTPUTS DISK TRACK USAGE, BLOCKSIZE AND OTHER STATISTICS.\n)X SYNTAX :   %STATDS 'DSN' PARM(/NO/LABEL/FULL)\n              REQUIRED : 'DSN'\n              DEFAULT : THE FIRST VALUE GIVEN IS THE DEFAULT.\n              PARM() : MEANS THAT ALL TYPES OF CHARACTERISTICS AND\n                       STATISTICS WILL BE PRINTED.\n              ALIAS : NONE.\n              SPECIAL : %STATDS 'DSN' PARM('GAS(TT.TT.RR)')\n                        ONLY FOR PARTITIONED DATA-SET.\n)O OPERANDS : 'DSN' - NAME OF THE DATA-SET TO BE CONSIDERED.\n))PARM(/NO/LABEL/FULL) :\n              SPECIFIES THE AMOUNT AND THE TYPES OF INFORMATION AND\n              STATISTICS DESIRED.\n     PARM() : IS THE DEFAULT VALUE. THE FOLLOWING INFORMATION WILL BE\n              GIVEN :\n              A) DCB AND DSCB CHARACTERISTICS.\n              B) RECORD COUNTS, RECORD SIZE, TRACK USAGE STATISTICS\n                 FOR ANY TYPE OF DATA-SET ORGANISATION.\n                 FOR DSORG=IS, THE COMMAND READS THROUGH THE ENTIRE\n                 DATA-SET (THERE MAY BE UP TO THREE SEPARATE FILES OF\n                 DATA AND REPORTS ON EACH FILE). ALSO, THE ISAM LABEL\n                 (FORMAT TWO DSCB) RECORD WILL BE READ AND A DATA-SET\n                 PROFILE WHICH INCLUDES DATA-SET REORGANIZATION DATA\n                 AND DATA-SET CHARACTERISTICS WILL BE PROVIDED.\n              C) FOR DSORG=PO, THE DIRECTORY TTR'S WILL BE COMPARED\n                 AGAINST ACTUAL DISK ADDRESSES TO DETERMINE THE TTRS\n                 OF \"GAS\" MEMBERS (THE FIRST 72 CHARACTERS OF ANY\n                 \"GAS\" MEMBER ARE OUTPUTED).\n                 \"GAS\" MEMBERS ARE THE OLD MEMBERS WHICH, AFTER A\n                 REPLACEMENT, KEEP THE DATA BLOCKS. THE BLOCKS ARE\n                 FREED ONLY BY A COMPRESS.\n                 STATISTICS ARE MAINTAINED ON THE SIZE OF \"GAS\" AND\n                 \"REAL\" MEMBERS AND THE NUMBER OF ALIAS MEMBERS. IF\n                 ANY ALIASES ARE IN THE DATA-SET, A CHECK IS MADE\n                 TO SEE THAT CORRESPONDING REAL ENTRIES ALSO EXIST.\n                 THE PROGRAM FINDS \"GAS\" MEMBERS ONLY IF THE DATA-SET\n                 HAS NOT BEEN COMPRESSED OUT YET.\n     PARM(NO) : SUPPRESS THE \"GAS\" TTR REPORT.\n     PARM(LABEL) : ONLY DCB AND DSCB CHARACTERISTICS ARE REPORTED.\n     PARM(FULL) : SUPPLY THE DIRECTORY MEMBERS LIST (ONLY DSORG=PO).\n     PARM('GAS(TT.TT.RR)') : WILL ADD A MEMBER NAME TO THE DIRECTORY\n                 FOR THE \"GAS\" MEMBER HAVING THE SPECIFIED TTR LOCATION\n                 (IN HEX, OBTAINED FROM A PREVIOUS RUN). THIS IS\n                 USEFULL IF YOU KNOW WHICH ONE YOU WANT. ANY USER\n                 DATA THAT WAS IN THE DIRECTORY ENTRY OF A DELETED OR\n                 REPLACED MEMBER CANNOT BE RECOVERED.\n     PARM('GAS(ALL)') : ALLOWS TO RECOVER ALL \"GAS\" MEMBERS IN A\n                 DATA-SET.\n              -- NOTE ABOUT LOAD MODULES : THIS PROGRAM CANNOT RECOVER\n                 A \"GAS\" LOAD MODULE. IT WILL GIVE IT A MEMBER NAME SO\n                 IT WONT BE COMPRESSED OUT, BUT THE DIRECTORY ENTRY\n                 WILL NOT BE A LOAD MODULE TYPE. TO RECONSTRUCT THE\n                 PROPER LOAD MODULE DIRECTORY WOULD REQUIRE INFORMATION\n                 THAT IS NO LONGER IN THE PARTITIONED DATA-SET.\n./     ENDUP\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "STATDSP": {"ttr": 15884, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x855O\\x00\\x855O\\x16\\x15\\x00\\n\\x00\\n\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-12-20T00:00:00", "modifydate": "1985-12-20T16:15:00", "lines": 10, "newlines": 10, "modlines": 0, "user": "SYSPAJA"}, "text": "./     ADD     NAME=STATDS\n./     NUMBER  NEW1=100,INCR=100\n//STDS    PROC P=,DSN=\n//*            ****************************\n//*              DISK DATA-SET STATISTICS\n//*            ****************************\n//STDS    EXEC PGM=STATS,PARM='&P'\n//IN        DD DSN=&DSN,DISP=SHR\n//OUT       DD SYSOUT=*\n./     ENDUP\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "STATDST": {"ttr": 15886, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x855O\\x00\\x855O\\x16\\x15\\x00\\x11\\x00\\x11\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1985-12-20T00:00:00", "modifydate": "1985-12-20T16:15:00", "lines": 17, "newlines": 17, "modlines": 0, "user": "SYSPAJA"}, "text": "./     ADD     NAME=STATDS\n./     NUMBER  NEW1=100,INCR=100\nPROC     1 DSN PARM() DSOUT(*)\n/**/\n/*         ****************************   */\n/*           DISK DATA-SET STATISTICS     */\n/*         ****************************   */\n/**/\nCONTROL  NOMSG\nFREE     F(IN OUT)\nCONTROL  MSG\nALLOC    F(IN) DA(&DSN.) SHR\nALLOC    F(OUT) DA(&DSOUT.)\nSTATS    &PARM\nFREE     F(IN OUT)\nTSO END\n./     ENDUP\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "STRING": {"ttr": 15888, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x93 \\x0f\\x00\\x93 \\x0f\\x123\\x02\\xe6\\x02\\xe6\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-07-19T00:00:00", "modifydate": "1993-07-19T12:33:00", "lines": 742, "newlines": 742, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO ,\n&NAME    STRING &INTO=,&PRINT=NOGEN,&DOC=NO                        EU-0\n         GBLC  &EUSTL                                              EU-0\n         AIF   ('&EUSTL' EQ 'GEN').FGENL                           EU-0\n         AIF   ('&PRINT' EQ 'GEN').FGENL                           EU-0\n         AGO   .NOGEN                                              EU-0\n.FGENL   PUSH  PRINT                                               EU-0\n         PRINT GEN\n.NOGEN   LCLA  &I,&J,&N                                            EU-0\n         GBLA  &$_FIELD,&$_MAXBL\n         GBLC  &$_FIELDS(9999)\n         AIF   (N'&SYSLIST EQ 1 AND '&SYSLIST(1)' EQ 'FINAL_CALL'      X\n               AND T'&INTO EQ 'O').GENL\n&LABEL   SETC  'IHB&SYSNDX'            stem for local labels\n&LQ      SETC  'L'''                   length attribute\n&NAME    BAS   R14,$STRING             Call @STRING sub-routine\n         AIF   (N'&SYSLIST EQ 0).ERR1\n         AIF   (T'&INTO EQ 'O').ERR2\n         DC    AL2(&LABEL.P-*)\n         AIF   (D'$STRING).LOCTR2\n$LTORG   LOCTR ,                       ADDRESSABLE CONSTANTS\n         CNOP  0,4\n$STRING  BALR  R15,0                   local base\n         L     R15,6(,R15)             routine address           00\n         BSM   0,R15                   go there with amode31     04\n         DC    A(@STRING+X'80000000')  routine address           06\n$FARRTNE LOCTR ,                       far routines\n.LOCTR2  ANOP\n$LITERAL LOCTR ,                       NON-ADDRESSABLE CONSTANTS\n&TO1     SETC  '&INTO(1)'\n&TO2     SETC  '&LQ&INTO'\n         AIF   (N'&INTO EQ 1).PUNTO8            JUMP IF INTO=XXX\n         AIF   ('&INTO(1)'(1,1) NE '(').PUNTO3  JUMP IF INTO=(XXX,44)\n&TO1     SETC  '0&INTO(1)'                              INTO=((R3),44)\n.PUNTO3  ANOP\n&TO2     SETC  '&INTO(2)'                               INTO=(XXX,LL)\n         AIF   ('&INTO(2)'(1,1) NE '(').PUNTO8  JUMP IF INTO=(XXX,44)\n&TO2     SETC  '0&INTO(2)'                              INTO=(XXX,(R1))\n.PUNTO8  ANOP\n&LABEL.P DC    S(&TO1,&TO2)\n.*---------------------------------------------------------------------\n.*-------      FIELDS       -------------------------------------------\n.*---------------------------------------------------------------------\n         LCLB  &LAST,&BIN,&HEXA,&REG,&PACKED,&LEFT,&ZERO,&TRUNC\n&I       SETA  1\n.*\n.LOOP1   ANOP\n&LAST    SETB  (&I EQ N'&SYSLIST)                LOOP\n         AIF   ('&SYSLIST(&I)'(1,1) EQ '''').LIT00\n.*---------------------------------------------------------------------\n.*       PROCESS FIRST SUBPARAMETER (ADDRESS)\n.*---------------------------------------------------------------------\n&P1S     SETC  '&SYSLIST(&I,1)'\n&P2L     SETC  '0'                     INPUT LENGTH\n&P3L     SETC  '0'                     OUTPUT LENGTH\n         AIF   ('&SYSLIST(&I)'(1,1) GE '0').FLD180 SPACES\n         AIF   ('&SYSLIST(&I)' EQ '%TIME').FLD190 %TIME\n         AIF   ('&SYSLIST(&I,1)'(1,1) NE '(').FLD115 (R2)\n         AIF   (T'&SYSLIST(&I,2) EQ 'O').FLD250\n&P1S     SETC  '0&SYSLIST(&I,1)'       CHANGE (R1) TO 0(R1)\n.FLD115  ANOP\n.*\n         AIF   (T'&SYSLIST(&I,2) NE 'O').FLD200\n.*\n         AIF   (NOT D'&SYSLIST(&I)).FLD140\n&P2C     SETC  T'&SYSLIST(&I)\n.*MNOTE *,'&P1 &P2C'\n         AIF   ('&P2C' EQ 'F' OR '&P2C' EQ 'H' OR '&P2C' EQ 'P').FLD220\n         AIF   ('&P2C' EQ 'G').FLD210  FL2\n.FLD140  ANOP\n&P2L     SETC  '&LQ&SYSLIST(&I,1)'     L'ABCDEF\n         AGO   .FLD300\n.*\n.FLD180  AIF   ('&SYSLIST(&I)'(K'&SYSLIST(&I),1) NE 'X').FLD800\n&P1S     SETC  'BLANKS'\n&P2L     SETC  '&SYSLIST(&I)'(1,K'&SYSLIST(&I)-1) 12\n&L       SETA  &P2L                    NUMBER OF BLANKS\n         AIF   (&L LE &$_MAXBL).FLD800\n&$_MAXBL SETA   &L                     MAX NUMBER OF BLANKS\n         AGO   .FLD800\n.*\n.FLD190  ANOP                          %TIME\n&P1S     SETC  '1(14)'                 %TIME\n         AGO   .FLD800\n.*---------------------------------------------------------------------\n.*       PROCESS SECOND SUBPARAMETER (LENGTH/TYPE)\n.*---------------------------------------------------------------------\n.FLD200  AIF   (T'&SYSLIST(&I,2) EQ 'O').FLD300 NO LENGTH SPECIFIED\n&P2C     SETC  '&SYSLIST(&I,2)'\n         AGO   .FLD220\n.*T'&P1=G\n.FLD210  ANOP\n&L       SETA  L'&SYSLIST(&I)          T'&P1 = 'G'\n&P2C     SETC  'FL&L'                  T'&P1 = 'G'\n.*\n.FLD220  ANOP\n&P2L     SETC  '0&P2C'                 (R2) LENGTH\n         AIF   ('&P2C'(1,1) EQ '(').FLD300\n&P2L     SETC  '&P2C'                  3(R2) LENGTH\n         AIF   ('&P2C'(K'&P2C,1) EQ ')').FLD300\n&P2L     SETC  '0'\n&PACKED  SETB  ('&P2C' EQ 'P')\n         AIF   (&PACKED).FLD300\n&P2L     SETC  '1'\n         AIF   ('&P2C' EQ 'FL1').FLD240\n&P2L     SETC  '3'\n         AIF   ('&P2C' EQ 'FL2' OR '&P2C' EQ 'H').FLD240\n&P2L     SETC  '7'\n         AIF   ('&P2C' EQ 'FL3').FLD240\n&P2L     SETC  '15'\n         AIF   ('&P2C' EQ 'F').FLD240\n&P2L     SETC  '&P2C'                  IMMEDIATE LENGTH, FIELD\n         AGO   .FLD300\n.*\n.FLD240  ANOP                          BINARY VARIABLE\n&BIN     SETB  1\n         AGO   .FLD300\n.*\n.FLD250  ANOP                          REGISTER CONTENT\n&REG     SETB  1\n.*---------------------------------------------------------------------\n.*       PROCESS THIRD SUBPARAMETER (OUTPUT FORMAT)\n.*---------------------------------------------------------------------\n.FLD300  AIF   (T'&SYSLIST(&I,3) EQ 'O').FLD800\n&HEXA    SETB  ('&SYSLIST(&I,3)' EQ 'X') HEXADECIMAL\n&TRUNC   SETB  ('&SYSLIST(&I,3)' EQ 'T') TRUNCATE\n         AIF   (&HEXA OR &TRUNC).FLD800\n.*\n&P3C     SETC  '&SYSLIST(&I,3)'\n&P3L     SETC  '250'\n         AIF   ('&P3C' EQ 'YY/MM/DD' AND &PACKED).FLD800\n&P3L     SETC  '251'\n         AIF   ('&P3C' EQ 'DD/MM/YY' AND &PACKED).FLD800\n&P3L     SETC  '252'\n         AIF   ('&P3C' EQ 'MM/DD/YY' AND &PACKED).FLD800\n&P3L     SETC  '253'\n         AIF   ('&P3C' EQ 'YYMMDD'   AND &PACKED).FLD800\n&P3L     SETC  '0'\n         AIF   (T'&SYSLIST(&I,2) NE 'N').FLD310\n         MNOTE 8,'EDIT PATTERN NOT ALLOWED WITH CHARACTER STRING'\n.*LOOP\n.FLD310  AIF   ('&P3C'(1,1) EQ 'R').FLD318       DEFAULT\n         AIF   ('&P3C'(1,1) EQ 'B').FLD318       DEFAULT\n         AIF   ('&P3C'(1,1) NE 'L').FLD311\n&LEFT    SETB  1\n         AGO   .FLD318\n.FLD311  AIF   ('&P3C'(1,1) NE 'Z').FLD312\n&ZERO    SETB  1\n         AGO   .FLD318\n.FLD312  AIF   ('&P3C'(1,1) LT '0').FLD993\n&P3L     SETC  '&P3L'.'&P3C'(1,1)\n.FLD318  ANOP\n.*MNOTE *,'&SYSLIST(&I) P3C=/&P3C/ P3L=/&P3L/'\n&P3C     SETC  '&P3C'(2,K'&P3C-1)     STRIP OFF FIRST CHARACTER\n         AIF   (K'&P3C GT 0).FLD310\n.*ENDLOOP\n.*---------------------------------------------------------------------\n.FLD800  AIF   ('&BIN&PACKED&REG' EQ '000').FLD810\n         AIF   (&LEFT OR '&P3L' NE '0').FLD810\n         AIF   (&HEXA).FLD810\n&P3L     SETC  '7'                     DEFAULT OUTPUT LENGTH ((R3))\n         AIF   (&REG).FLD810\n&P3L     SETC  '3'                     DEFAULT OUTPUT LENGTH\n         AIF   ('&P2C' EQ 'FL1').FLD810\n&P3L     SETC  '5'                     DEFAULT OUTPUT LENGTH\n         AIF   ('&P2C' EQ 'H' OR '&P2C' EQ 'FL2').FLD810\n&P3L     SETC  '7'                     DEFAULT OUTPUT LENGTH\n.FLD810  ANOP\n&FLAG    SETA  &LAST*128+&HEXA*8+&BIN*4+&PACKED*2+&REG*1\n&LEN2    SETA  &TRUNC*128+&LEFT*128+&ZERO*64+&P3L\n         DC    S(&P1S,&P2L),AL1(&FLAG,&LEN2)\n&BIN     SETB  0                    RESET FLAGS\n&HEXA    SETB  0                    RESET FLAGS\n&REG     SETB  0                    RESET FLAGS\n&PACKED  SETB  0                    RESET FLAGS\n&LEFT    SETB  0                    RESET FLAGS\n&ZERO    SETB  0                    RESET FLAGS\n&TRUNC   SETB  0                    RESET FLAGS\n         AGO   .LIT99\n.FLD990  MNOTE 8,'MISSING OR INCORRECT PARAMETER'\n         AGO   .LIT99\n.FLD993  MNOTE 8,'THIRD SUBPARAMETER IS INVALID: ''&SYSLIST(&I,3)'''\n         AGO   .LIT99\n.*---------------------------------------------------------------------\n.*------------ LITERALS -----------------------------------------------\n.*---------------------------------------------------------------------\n.LIT00   AIF   (&$_FIELD EQ 0).LIT50\n&N       SETA  1\n.LIT10   AIF   (&N GT &$_FIELD).LIT50                LOOP\n&L       SETA  &N+1000                               LOOP\n         AIF   ('&SYSLIST(&I)' EQ '&$_FIELDS(&N)').LIT80 LOOP\n&N       SETA  &N+1                                  LOOP\n         AGO   .LIT10                                LOOP\n.LIT50   ANOP\n&$_FIELD SETA  &$_FIELD+1\n&$_FIELDS(&$_FIELD) SETC '&SYSLIST(&I)'\n&L       SETA  &$_FIELD+1000\n.LIT80   ANOP\n&J       SETA  X'4000'+&LAST*X'8000'\n         DC    AL2($LIT&L-*,&LQ.$LIT&L,&J)\n.LIT99   ANOP\n.*---------------------------------------------------------------------\n&I       SETA  1+&I                              LOOP\n         AIF   (&I LE N'&SYSLIST).LOOP1          LOOP\n&SYSLOC  LOCTR\n         AGO   .MEND\n.ERR1    MNOTE 12,'AT LEAST ONE INPUT FIELD MUST BE SPECIFIED'\n         AGO   .MEND\n.ERR2    MNOTE 12,'INVALID OUTPUT AREA SPECIFICATION'\n         AGO   .MEND\n.**********************************************************************\n.*       FINAL_CALL: GENERATE LITERALS\n.**********************************************************************\n.GENL    AIF   (&$_FIELD EQ 0).GENL3\n$LITERAL LOCTR\n.GENL2   ANOP                                LOOP\n&N       SETA  &N+1                          LOOP\n&I       SETA  &N+1000                       LOOP\n$LIT&I   DC    C&$_FIELDS(&N)                LOOP\n         AIF   (&N LT &$_FIELD).GENL2        LOOP\n.GENL3   AIF   ('&DOC' NE 'YES').NODOC                             EU-0\n         AIF   ('&EUSTL' EQ 'GEN').OKDOC                           EU-0\n         AIF   ('&PRINT' EQ 'GEN').OKDOC                           EU-0\n         PUSH  PRINT                                               EU-0\n         PRINT GEN                                                 EU-0\n.OKDOC   EJECT ,                                                   EU-0\n*         +----------------------------------------+\n*         +                                        +\n*         +   Documentation for the STRING macro   +\n*         +      (Last update: 08 Dec 1992)        +\n*         +       (EU update: 15 Jul 1993)         +\n*         +----------------------------------------+\n*\n*        The STRING macro is functionally similar to the COBOL DISPLAY\n*   or PL/I PUT EDIT instructions.\n*\n*        Using STRING, you can concatenate any number of fields, edit\n*   each of them if necessary, and get the result in the work area\n*   you specify.\n*\n*   Formats:\n*\n*        (1) label  STRING  field_specification1\n*                           ,field_specification2,...\n*                           ,INTO=workarea|(workarea,length)\n*                           ,PRINT=GEN|NOGEN\n*\n*        (2) label  STRING  FINAL_CALL\n*                           ,PRINT=GEN|NOGEN\n*\n*\n*   field_specification\n*\n*        Each field to be printed is described as a positional operand.\n*        Each operand specifies the field address, its length, and its\n*        formatting requirements.\n*\n*        Four field description formats are supported:\n*\n*        1.   symbol\n*        2.   (symbol,length,format)\n*        3.   (d(r)|(r),length,format)\n*        4.   ((r),,format)\n*        5.   'character string'\n*\n*        Symbol specifies the field address. It must be an\n*        S-type (relocatable) address.\n*\n*        d(r) may be used to specify the field address in S/370\n*        base-displacement format. If d is zero, it may be omitted.\n*        If d(r) or (r) is used, length must also be specified. R14\n*        and R15 may not be used. If d(0) is used, it is handled the\n*        way the assembler does, i.e. R0 as a base register is assumed\n*        to contain zero: 16(0) is equivalent to 16, CVTPTR or, X'10'.\n*\n*        ((r),,format) specifies that (r) contains the value\n*        itself, not an address. R14 and R15 may not be used.\n         EJECT\n*        'character string' specifies a literal enclosed in single\n*        quotes as specified in a DC instruction.\n*\n*        Length specifies the length and/or the type of the input\n*        field. It may be specified as an integer, a symbol, a\n*        register, or a constant. When used with symbol, it overrides\n*        the assembled length and/or type. Length is required if field\n*        is specified as d(r) or (r).\n*\n*        nn   field length in bytes\n*        H    half-word\n*        F    full-word\n*        FL1  1-byte binary integer\n*        FL3  3-byte binary integer\n*        P    packed field\n*        (r)  length of character string (R0 thru R9)\n*        d(r) length of character string (R1 thru R9)\n*\n*        Notes: If the field address is specified as a symbol that has\n*                  been defined previously in the program, the symbol\n*                  type is known and there is no need to specify it.\n*               If the length is specified as (r) or d(r) and the value\n*                  is greater than the address itself, (r) or d(r) is\n*                  considered to be the end address +1 instead of the\n*                  length.\n*               The length is not specified for packed fields. The\n*                  @STRING subroutine scans the field until a byte with\n*                  X'0C' is found.\n*\n*        format  optionally indicates editing options that must\n*        be applied to a field.\n*\n*             L        left justified\n*             R        right justified\n*             nn       output length\n*             0        adjust length\n*             Z        leading zeroes\n*             B        leading/trailing blanks\n*             T        truncate character string after last non-blank\n*             X        display in hexadecimal\n*             YYMMDD   convert julian date to YYMMDD\n*             YY/MM/DD convert julian date to YY/MM/DD\n*             DD/MM/YY convert julian date to DD/MM/YY\n*             MM/DD/YY convert julian date to MM/DD/YY\n*\n*             The default format is L for character-type fields and\n*             R7B for numeric fields. L0 and T are equivalent.\n*\n*        'character string' is any character string enclosed in\n*        single quotes. Blank spaces may be specified as nnX,\n*        where nn is the number of X'40' bytes you want to be\n*        inserted in the output line. %TIME may be specified to\n*        obtain the current time in hh.mm.ss.hh format.\n         EJECT\n*   INTO=workarea|(workarea,length)\n*\n*        INTO indicates the address and length of the output work area\n*        into which the result of the concatenation should be placed\n*        (left justified). If the work area is too small, truncation\n*        will occur. If it is too large, the rest is padded with\n*        blanks.\n*\n*        The address may be a symbol, d(r) (S-type address) or (r). The\n*        length is required for d(r) and (r). If no length is specified\n*        for a symbol-type address, it defaults to the assembled length\n*        of the symbol.\n*\n*        Upon return from STRING, R15 contains the length actually used\n*        in the output work area (before padding).\n*\n*   PRINT=GEN|NOGEN\n*\n*        This operand allows you to temporarily override the PRINT\n*        specification (GEN or NOGEN).\n*\n*   FINAL_CALL (format 2)\n*\n*        The FINAL_CALL format must be specified once at the end of\n*        the program. It generates the literals used in previous\n*        invocations and the @STRING sub-routine.\n*\n*   Examples:\n*\n*        STRING 'ERROR===>',LINE1,'<=== POS ',((R6),,L0),INTO=WORKAREA\n*\n*        STRING 8X,'ERRORS FOUND: ',(ERRORS,,L0),INTO=((R7),44)\n*\n*        STRING 'CVT ADDR IS ',(CVTPTR,4,X),INTO=LINE\n*\n*        LA    R5,WORK+16              end addr +1\n*        STRING 'R4=',((R4),,X),INTO=(WORK,(R5)),PRINT=GEN\n*\n*        STRING '//JOBLIB DD DSN=',(DSN1,,T),',DISP=SHR',INTO=((R2),72)\n*\n*        PUT31 SYSLIN\n*        LH    R0,SYSLIN+82            LRECL\n*        STRING '   NAME  ',(4(R3),8,T),'(R)',INTO=((R1),(R0))\n*\n*        STRING FINAL_CALL       Generate literals and sub-routine\n         EJECT\n*   Programming Notes:\n*\n*        A STRING macro generates only 6 bytes that need to be covered\n*        by base registers. More code is generated at the end of the\n*        current CSECT (using LOCTR pseudo instruction), but this code\n*        does not require addressability. This is particularly useful\n*        if STRING calls contain lots of literals.\n*\n*        Additionally, STRING does not use A-type constants (ACON),\n*        but S-type constants (SCON) which require symbols to be\n*        addressable at the point in the program where STRING is\n*        issued.\n*\n*        While this reduces the number of base registers required\n*        to cover the program's code and makes it easier to write\n*        reentrant programs, it will produce assembly errors in the\n*        following situations:\n*\n*        a. STRING is used in more than one CSECT in the same assembly\n*\n*        b. the CSECT in which STRING is used is longer than 64K\n*\n*        c. symbols are not addressable at the point in the program\n*           where STRING is issued\n*\n*        d. the $STRING symbol (generated by the first call to the\n*           STRING macro) is not addressable in subsequent STRING calls\n*\n*   Assembly JCL:\n*        //ASMH EXEC PGM=IEV90,PARM=(OBJECT,NODECK,NOESD,NORLD,NOXREF)\n         SPACE 1\n*930130  Add $FARRTNE LOCTR to prevent negative offsets\n*921205  Restructure module, optimize, AMODE31\n*921204  Return length used in output work area in R15\n*920926  @JDATE routine integrated into @STRING CSECT\n         SPACE 1\n* Origin :     Extracted from CBT 93 FEB, file 183.\n* --------\n*\n* Updates :    done by MOINIL P.A.\n* ---------            COMPUTING CENTRE (TP 361)\n*                      J.R.C. - ISPRA ESTABLISHMENT\n*                      21020 ISPRA (VA), ITALY\n*   15JUL93 : EU-0 - Included GBLC &EUSTL in macro to handle external\n*                    SYSPARM(FULL or STRING) Assembly list options.\n*                    Added DOC=YES to allow macro documentation list.\n*           : EU-1 - Added missing process to set trailing blanks (B)\n*                    when left justified (L) edit option is required.\n         AIF   ('&EUSTL' EQ 'GEN').NODOC                           EU-0\n         AIF   ('&PRINT' EQ 'GEN').NODOC                           EU-0\n         POP   PRINT                                               EU-0\n.NODOC   EJECT ,                                                   EU-0\n.**********************************************************************\n.*\n.*       STRING SUB-ROUTINE\n.*\n.*             CAUTION: BYTES 49-72 OF THE CALLER'S SAVE AREA\n.*                      (R7-R12 SLOTS) ARE USED AS WORK SPACE\n.*\n.**********************************************************************\n@STRING  CSECT\n@STRING  RMODE ANY\n.*R0     EQU   0                       WORK REGISTER\n.*R1     EQU   1                       WORK REGISTER\n.*R2     EQU   2                       WORK REGISTER\n.*R3     EQU   3                       WORK REGISTER\n.*R4     EQU   4                       WORK REGISTER\n.*R5     EQU   5                       WORK REGISTER\n.*R6     EQU   6                       WORK REGISTER\n.*R7     EQU   7                       NOT SAVED, NOT USED\n.*R8     EQU   8                       NOT SAVED, NOT USED\n.*R9     EQU   9                       NOT SAVED, NOT USED\n.*R10    EQU   10                      NOT SAVED, NOT USED\n.*R11    EQU   11                      NOT SAVED, NOT USED\n.*R12    EQU   12                      NOT SAVED, NOT USED\n.*R13    EQU   13                      NOT SAVED, NOT USED\n.*R14    EQU   14                      WORK REGISTER\n.*R15    EQU   15                      base reg\n         SAVE  (14,6),,'@STRING 921205 '\n         USING @STRING,R15\n         USING @STRSAVE,R13\n         LR    R6,R14                  KEEP ADDRESS OF PARMLIST OFFSET\n         USING @STRPARM,R6\n         SLR   R0,R0\n         ICM   R0,B'0011',0(R6)        PICK UP PARM LIST OFFSET\n         ALR   R6,R0                   GET PARM LIST ADDRESS\n         LA    R2,@STRSCON             RESOLVE FIRST SCON (ADDR)\n         BAL   R14,@STRS2A             GET ADDRESS IN R2\n         LR    R4,R2                   KEEP ADDRESS OF \"INTO\" FIELD\n         OI    0(R4),0                 get clean S0C4 if address is bad\n         LA    R2,@STRFLEN             RESOLVE SECOND S-CON (LEN)\n         BAL   R14,@STRS2A             GET LENGTH IN R2\n         LR    R5,R1                   KEEP LENGTH OF \"INTO\" FIELD\n         CR    R5,R4                   end address?\n         BL    @STR282                 NO, JUMP\n         SR    R5,R4                   CALCULATE LENGTH\n@STR282  ST    R4,8(,R13)              SAVE ADDRESS FOR LATER\n.**********************************************************************\n.*       MOVE FIELDS TO OUTPUT AREA\n.**********************************************************************\n         LA    R6,@STRFLAG             POINT TO 1ST FIELD DESC\n.*LOOP\n@STR310  CLI   @STRSCON,X'E0'          CHECK FOR %TIME\n         BE    @STR388T                JUMP IF %TIME\n         TM    @STRFLAG,@STRLIT        IS THIS A LITERAL?\n         BO    @STR388L                yes, process it\n         TM    @STRFLAG,@STRREG        CHECK CONVERSION TYPE\n         BO    @STR335                 JUMP IF REGISTER\n.*IT'S A FIELD (SCON)\n         LA    R2,@STRFLEN             RESOLVE SECOND S-CON (LEN)\n         BAL   R14,@STRS2A             GET LENGTH IN R2\n         LR    R3,R2                   KEEP LENGTH\n         LA    R2,@STRSCON             RESOLVE FIRST SCON (ADDR)\n         BAL   R14,@STRS2A             GET ADDRESS IN R2\n         CLI   0(R2),0                 get clean S0C4 if address is bad\n         CR    R3,R2                   end address?\n         BL    @STR312                 NO, JUMP\n         LA    R0,X'0080'              PSA address              @921221\n         CLR   R2,R0                   PSA reference?           @921221\n         BL    @STR312                 yes, jump                @921221\n         SR    R3,R2                   CALCULATE LENGTH\n.*\n@STR312  TM    @STRFLAG,@STRPACK       CHECK CONVERSION TYPE\n         BO    @STR330                 JUMP IF PACKED FIELD\n         TM    @STRFLAG,@STRHEX        CHECK CONVERSION TYPE\n         BO    @STR361                 JUMP IF HEX STRING\n         TM    @STRFLAG,@STRBIN        CHECK CONVERSION TYPE\n         BZ    @STR370                 JUMP IF NO CONVERSION REQ'D\n.*BINARY VARIABLE: R3 CONTAINS THE ICM MASK (1 3 7 F)\n@STR320  SLR   R0,R0\n         EX    R3,@STRICM              LOAD THE BINARY VARIABLE\n         B     @STR340                 EDIT R0 VALUE\n@STRICM  ICM   R0,*-*,0(R2)            LOAD A BINARY VARIABLE\n.*PACKED FIELD\n@STR330  LR    R3,R2                   FIRST BYTE OF PACKED FIELD\n         BALR  R14,0\n         TM    0(R3),X'0C'             IS THIS THE SIGN BYTE?\n         LA    R3,1(,R3)                (NEXT BYTE)\n         BNOR  R14                     NO, LOOP MORE\n         SLR   R3,R2                   GET LENGTH OF PACKED FIELD\n         BCTR  R3,0\n         EX    R3,@STRZAP              EXECUTE ZAP\n         CLI   @STRLEN2,250            JULIAN-TO-YYMMDD CONV?\n         BL    @STR341                 no, edit DWD\n         B     @STR380                 yes, convert it\n.*REGISTER (R0-R13)\n@STR335  LH    R1,@STRSCON             REG NUMBER IN BITS 28-31\n         EX    R1,@STR335S             copy R7-R13 INTO r0\n         CLI   @STRSCON+1,R7           IS THIS R7-R13?\n         BNL   @STR336                 yes, jump\n         SLL   R1,2                    R1= 000000BB BASE * 4\n         L     R0,20(R1,R13)           PICK UP VALUE FOR R0-R6\n@STR336  TM    @STRFLAG,@STRHEX        CHECK CONVERSION TYPE\n         BO    @STR360                 JUMP IF HEX STRING\n.*EDIT @STRDWD\n@STR340  CVD   R0,@STRDWD              CONVERT VALUE TO DECIMAL\n@STR341  IC    R0,@STRLEN2             OUTPUT LENGTH\n         LA    R3,X'003F'              MASK FOR \"AND\"\n         NR    R3,R0                   OUTPUT LENGTH\n         MVC   @STRWKE(L'@STRWKE),@STRMASK EDIT MASK\n         TM    @STRLEN2,@STRLEFT       CHECK JUSTIFICATION\n         BO    @STR350                 JUMP IF LEFT JUSTIFICATION\n         TM    @STRLEN2,@STRZERO       leading zeroes req'd?\n         BNO   @STR344                 no, jump\n         MVI   @STRWKE,C'0'            yes, change X'40' to C'0'\n@STR344  ED    @STRWKE,@STRDWD         ZONED DECIMAL\n         LA    R2,@STRWKE+L'@STRWKE    FIRST POSITION AFTER STRING\n         SR    R2,R3                   FIRST STRING POSITION\n         B     @STR390                 MOVE STRING TO OUTPUT LINE\n.*L\n@STR350  LA    R1,@STRWKE+L'@STRWKE-1  PREVENT BAD R1\n         EDMK  @STRWKE,@STRDWD         ZONED DECIMAL\n         LR    R2,R1                   FIRST STRING POSITION\n         LTR   R3,R3                   CHECK OUTPUT LENGTH\n         BNZ   @STR390                 JUMP IF NOT ZERO\n         LA    R3,@STRWKE+L'@STRWKE    FIRST POSITION AFTER STRING\n         SR    R3,R2                   COMPUTE STRING LENGTH\n         B     @STR390                 MOVE FIELD TO OUTPUT LINE\n.*HEX STRING\n@STR360  STCM  R0,B'1111',@STRDWD-1    STORE IT FOR CVD/UNPK\n         LA    R3,8                    output LENGTH\n         B     @STR363\n@STR361  LTR   R3,R3                   ZERO LENGTH?\n         BZ    @STR398                 YES, IGNORE IT\n         LA    R0,8                    MAX LENGTH\n         CLR   R3,R0                   CHECK LENGTH\n         BNH   @STR362                 JUMP IF LE 8\n         LR    R3,R0                   TRUNCATE TO MAXIMUM LENGTH\n@STR362  LR    R1,R3                   input length\n         BCTR  R1,0\n         EX    R1,@STR360M             MOVE DATA TO SAFE STORAGE\n         ALR   R3,R3                   output length\n@STR363  LA    R2,@STRWKE              work area\n         UNPK  0(9,R2),@STRDWD-1(5)    EXPAND SOURCE BYTES FOR \"TR\"\n         UNPK  8(9,R2),@STRDWD+3(5)    EXPAND SOURCE BYTES FOR \"TR\"\n         TR    0(16,R2),@STRHEXT-240   =C'0123456789ABCDEF'\n.*TRUNCATE CHARACTER STRING\n@STR370  TM    @STRLEN2,@STRLEFT       CHECK JUSTIFICATION, OUTPUT LEN\n         BZ    @STR390                 NO STRING TRUNCATION, JUMP\n         LA    R1,0(R3,R2)             FIRST BYTE AFTER FIELD\n@STR372  BCTR  R1,0                    DOWN 1 BYTE                 LOOP\n         CLI   0(R1),C' '              IS IT A SPACE ?             LOOP\n         BNE   @STR390                 LAST NON-BLANK BYTE         LOOP\n         BCT   R3,@STR372              LOOP UNTIL 1ST NON-BLANK    LOOP\n         B     @STR398                 BLANK FIELD, DO NOT EDIT\n@STR335S LR    R0,*-*                  COPY VALUE FOR EDIT\n@STRZAP  ZAP   @STRDWD,0(*-*,R2)       MOVE TO @STRDWD\n@STR360M MVC   @STRDWD-1(*-*),0(R2)    PREVENT S0C4 IN UNPK\n@STRHEXT DC    C'0123456789ABCDEF'\n@STRMASK DC    X'40202020202020202020202020202120'\n.*CONVERT JULIAN DATE TO YYMMDD\n@STR380  ZAP   @STRDWD,@STRDWD         DATE=0000000?               @JDT\n         BZ    @STR380Z                YES, JUMP                   @JDT\n         MVO   @STRDWD+0(2),@STRDWD+4+1(1)           0YY00000,00YY0DDC\n         MVI   @STRDWD+2,X'0C'                       0YY00C00,00YY0DDC\n         BAL   R1,@STR380T+2*13        TABLE OF MONTHS (NUMBER OF DAYS)\n@STR380T DC    P'59,31,29,31,30,31,30,31,31,30,31,30,31'\n         TM    @STRDWD+4+1,X'01'       ODD YEARS\n         BO    @STR380N                  AREN'T LEAP YEARS\n         TM    @STRDWD+4+1,X'12'       ZEROES IN 1980, ALL ONES IN 1992\n         BNM   @STR380L                MIXED IN 1982/1990\n.*IF IT'S NOT A LEAP YEAR AND DDD>59, THEN ADD 1 TO DDD\n@STR380N CP    @STRDWD+4+2(2),@STR380T ARE WE PAST FEB 28 (DDD>59) ?\n         BNH   @STR380L                NO, JUMP\n         AP    @STRDWD+4+2(2),@STR380T+3(1) ADD 1 (FROM 31) TO DDD\n.*loop while DDD > 0\n@STR380L AP    @STRDWD+1(2),@STR380T+3(1)   ADD 1 (FROM 31) TO MONTH\n         LA    R1,2(,R1)               NEXT ENTRY IN \"MONTHS\" TABLE\n         SP    @STRDWD+4+2(2),0(2,R1)  SUB DAYS-IN-MONTH FROM DDD\n         BP    @STR380L\n.*endloop\n         AP    @STRDWD+4+2(2),0(2,R1)  UNDO LAST \"SP\" INSTRUCTION\n         UNPK  @STRDWD+0(4),@STRDWD+0(3) FYFYFMCM,00YY0DDC\n         UNPK  @STRDWD+4(2),@STRDWD+6(2) FYFYFMCM,FDCD0DDC\n         MVZ   @STRDWD+3(3),@STRDWD+2    FYFYFMFM,FDFD0DDC\n         MVI   @STRDWD+6,C'/'          SEPARATOR\n         LA    R0,250                  MASK FOR 'NR'\n         SLR   R1,R1\n         IC    R1,@STRLEN2             250-255\n         SLR   R1,R0                   000-005\n         LA    R0,1+8                  L'@STR380W\n         MR    R0,R0                   COMPUTE OFFSET\n         LA    R1,@STR380W(R1)         entry in \"TR\" MASK TABLE\n         LA    R2,@STRWKE              WORK AREA\n         SLR   R3,R3\n         IC    R3,0(,R1)               LENGTH OF DATE (6 OR 8)\n         MVC   0(8,R2),1(R1)           MOVE CORRESPONDING MASK\n         TR    0(8,R2),@STRDWD         CONVERT DATE TO THE RIGHT FORMAT\n         B     @STR390                 MOVE FIELD TO OUTPUT LINE\n@STR380W DC    AL1(8,0,1,6,2,3,6,4,5)  YY/MM/DD   250\n         DC    AL1(8,4,5,6,2,3,6,0,1)  DD/MM/YY   251\n         DC    AL1(8,2,3,6,4,5,6,0,1)  MM/DD/YY   252\n         DC    AL1(6,0,1,2,3,4,5,6,6)  YYMMDD//   253\n.*       DC    AL1(6,4,5,2,3,0,1,6,6)  DDMMYY//   254\n.*       DC    AL1(6,2,3,4,5,0,1,6,6)  MMDDYY//   255\n@STR380Z BAL   R2,*+4+8                WORK AREA\n         DC    8C' '                   RETURN SPACES\n         LA    R3,008                  LENGTH OF 'YY/MM/DD'\n         CLI   @STRLEN2,253            YY/MM/DD OK?\n         BL    @STR390                 YES, JUMP\n         LA    R3,006                  LENGTH OF 'YYMMDD'\n         B     @STR390\n.*%TIME\n@STR388T TIME  DEC                     GET HHMMSSHH\n         L     R15,16(,R13)            RESTORE BASE REG\n         ST    R0,@STRDWD              STORE HHMMSSHH\n         MVC   @STRWKE(L'@STRTIME-1),@STRTIME MOVE EDIT MASK\n         ED    @STRWKE(L'@STRTIME-1),@STRDWD EDIT HH:MM:SS:HH\n         LA    R2,@STRWKE+1            WORK AREA\n         LA    R3,12                   HH:MM:SS:HH+ SPACE\n         B     @STR390\n@STRTIME DC    X'4021207A20207A20207A20204000'    0X.XX.XX.XX\n.*literal (@STRSCON is a 16-bit offset)\n@STR388L SLR   R2,R2\n         ICM   R2,B'0011',@STRSCON     LOAD LITERAL OFFSET\n         LA    R2,@STRSCON(R2)         CONVERT OFFSET TO FULL ADDRESS\n         LH    R3,@STRFLEN             GET LITERAL LENGTH\n.*MOVE\n@STR390  CR    R5,R3                   COMPARE REM. LEN TO CURR LEN\n         BNL   @STR391                 JUMP IF HIGH OR EQUAL\n         LR    R3,R5                   TRUNCATE TO REMAINING LENGTH\n@STR391  SR    R5,R3                   COMPUTE REMAINING LENGTH\n         LR    R0,R4                   POINTER IN OUTPUT LINE\n         LR    R1,R3                   PASS REMAINING LENGTH\n         ICM   R3,B'1000',@STRPAD      PAD WITH BLANKS\n         TM    @STRLEN2,@STRLEFT       CHECK LEFT JUSTIFICATION    EU-1\n         BZ    *+L'*+10                NO, JUMP                    EU-1\n         STCM  R3,B'1000',@STRDWD      SET TRAILING BLANKS FOR     EU-1\n         MVC   @STRDWD+1(L'@STRDWD-1),@STRDWD NEXT MOVE            EU-1\n         MVCL  R0,R2                   MOVE FIELD TO OUTPUT LINE\n         LR    R4,R0                   NEW POINTER IN OUTPUT LINE\n@STR398  TM    @STRFLAG,@STRLAST       TEST LAST-ENTRY INDICATOR\n         LA    R6,@STRNEXT             BUMP UP TO NEXT ENTRY\n         BNO   @STR310                 PROCESS NEXT ENTRY\n.*ENDLOOP\n.*END-OF-LINE PROCESSING\n         LA    R14,2                   increment\n         AL    R14,12(,R13)            RETURN ADDRESS\n         ICM   R1,B'1111',@STRPAD      SET UP R1 FOR PADDING\n         LR    R15,R4                  CURRENT POINTER IN OUTPUT FIELD\n         SL    R15,8(,R13)             CALCULATE LENGTH USED\n         MVCL  R4,R0                   PAD WITH BLANKS\n         LM    R0,R6,20(R13)           RESTORE WORK REGISTERS\n         STM   R7,R12,48(R13)          MAKE SAVE AREA LOOK NORMAL\n         OI    15(R13),1               SIMULATE \"T\" OPTION OF RETURN\n         BSM   0,R14                   RETURN TO CALLER\n.**********************************************************************\n.*       convert S-CON to 31-bit address\n.**********************************************************************\n@STRS2A  SLR   R0,R0\n         ICM   R0,B'0011',0(R2)        R0 = 0000BDDD\n         SRDL  R0,12                   R0 = 0000000B, R1= DDD.....\n         SRL   R1,20                   R1 = 00000DDD  (DISPLACEMENT)\n         CLI   0(R2),R7*16             R7-R13?\n         BL    @STRS2A5                NO, JUMP\n.*BASE REG IS R7-R13\n         LR    R2,R0                   R2= 0000000B (BASE REG NUMBER)\n         EX    R2,@STRS2A4             ADD BASE REG VALUE TO DISPL\n         B     @STRS2A7                clean up address\n@STRS2A4 LA    R2,0(*-*,R1)            ADD BASE REG VALUE TO DISPL\n.*BASE REG IS R0-R6\n@STRS2A5 LTR   R2,R0                   is R0 the base reg?\n         BNZ   @STRS2A6                no, jump\n         LTR   R2,R1                   IS THIS A PSA ADDRESS?\n         BNZR  R14                     yes, goback\n@STRS2A6 SLL   R2,2                    R2= 000000BB BASE * 4\n         L     R2,20(R2,R13)           PICK UP BASE REG VALUE\n         LA    R2,0(R2,R1)             ADD BASE REG VALUE TO DISPL\n.*clean up R1 based on caller's amode\n@STRS2A7 TM    12(R13),X'80'           caller's in amode31?\n         BOR   R14                     yes, goback\n         ICM   R2,B'1000',@STRPAD+1    no, zero hi-order byte\n         BR    R14\n@STRPAD  DC    X'40,000000'            PADDING\n.**********************************************************************\n@STRSAVE DSECT                         24-BYTE WORK AREA\n         DS    A(0,@STRSAVE,@STRSAVE,14,15,0,1,2,3,4,5,6)\n@STRWKE  DS    0XL16,F'7,8,9,10'       WORK AREA\n@STRDWD  DS    0XL8,D'1112'            WORK AREA\n@STRPARM DSECT\n@STRSCON DS    S                   +0  FIELD ADDRESS\n@STRFLEN DS    S                   +2  FIELD LENGTH\n@STRFLAG DS    B                   +4  FORMAT, FLAGS\n@STRLAST EQU   X'80'                     LAST ENTRY\n@STRLIT  EQU   X'40'                     LITERAL, @STRSCON IS AN OFFSET\n@STRJDT  EQU   X'20'                     JULIAN TO YYMMDD\n.*             X'3F'                   CONVERSION REQUIRED\n@STRHEX  EQU   X'08'                     HEXADECIMAL\n@STRBIN  EQU   X'04'                     BINARY\n@STRPACK EQU   X'02'                     PACKED\n@STRREG  EQU   X'01'                     REGISTER\n@STRLEN2 DS    B                   +5  FORMAT, OUTPUT LENGTH\n@STRLEFT EQU   X'80'                     LEFT JUSTIFICATION\n@STRZERO EQU   X'40'                     LEADING ZEROES\n.*             X'3F'                     OUTPUT LENGTH, 0 MEANS TRUNC.\n@STRNEXT EQU   *                   +6\n$LTORG   LOCTR\n         AIF   (D'BLANKS).MEND\nBLANKS   DC    &$_MAXBL.C' '       A BUNCH OF BLANKS\n.MEND    AIF   ('&EUSTL' EQ 'GEN').DGENL                           EU-0\n         AIF   ('&PRINT' EQ 'GEN').DGENL                           EU-0\n         AGO   .MEND99                                             EU-0\n.DGENL   POP   PRINT                                               EU-0\n.MEND99  MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "VCOREZA$": {"ttr": 16139, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x942\\x8f\\x00\\x942\\x8f\\x10)\\x00\\x0f\\x00\\x0f\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-24T00:00:00", "modifydate": "1994-11-24T10:29:00", "lines": 15, "newlines": 15, "modlines": 0, "user": "SYSPAJA"}, "text": "//VCOREZAP JOB (........),'INSTALL  -VCOREZAP-',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=1M,TIME=1\n/*JOBPARM L=15\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//* PRE-REQUISITE MODULES INSTALLATION :                              *\n//*                AUTHCTL   DTUR                                     *\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//ASS     EXEC PAJ1AS3,MBR=VCOREZAP\n//ASSH    EXEC PAJ1AS2,MBR=VCOREZAH\n//LNK     EXEC PAJILKL\n//SYSIN     DD *\n  INCLUDE SYSADD(DTUSE)\n  ENTRY   VCOREZAP\n  NAME    VCOREZAP(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "VCOREZA@": {"ttr": 16385, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x92\\x18\\x1f\\x00\\x92\\x18\\x1f\\x15\\x10\\x00\\xf6\\x00\\xf6\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1992-06-29T00:00:00", "modifydate": "1992-06-29T15:10:00", "lines": 246, "newlines": 246, "modlines": 0, "user": "SYSPAJA"}, "text": "1   29/06/92\n                                                      VCOREZAP  1/6.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *           V C O R E Z A P           * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *          VIRTUAL CORE ZAP.          * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  Purpose :    This module allows the alteration or display of any\n  ---------    virtual storage locations in the NUCLEUS, CSA, Address\n               Spaces (not swap-out), etc...\n               Note : it does'nt replace the INCORZAP program to\n                      modify the LPA which is store protected.\n\n  Notes : - VCOREZAP is an authorized users only TSO command.\n  ------- - VCOREZAP may be also executed by the console operator\n            typing the following START command :\n                  S VZAP\n            where VZAP is the name of the cataloged procedure which\n            contains only an EXEC JCL statement as below :\n                  //VZAP  EXEC  PGM=VCOREZAP\n          - VCOREZAP now allows the use of dsect's references through\n            generated dsects tables stored in a data-set (see program\n            GDTUTIL and routine DTUR).\n1   29/06/92\n                                                      VCOREZAP  2/6.\n\n  Virtual Storage commands at disposal :\n  --------------------------------------\n\n         D NNNN :\n               To display 16 hex bytes starting at location NNNN.\n               Just ENTER or type only D to display 16 hex bytes\n               starting at the current or +16 address pointer\n               (continue the display of data). This pointer is\n               updated by any D, S, F and A commands. Enter + or\n               - decimal 1 up to 999 to display forward/backward\n               from the current location pointer.\n               NNNN may be :\n               a label (1 to 8 characters),\n                 or an hex address (1 to 8 hex digits preceeded by\n                    a period, which may be omitted if the first one\n                    is a numeric 0-9),\n                 or a field-name and a dsect-name (separated by a\n                    slash and given in this order, where dsect-name\n                    must also exist as label),\n               followed by an eventual displacement expressed as +\n               or - DDDD (another label or hex value),\n                    or a field-name and dsect-name (separated by a\n                       slash and given in this order).\n\n         S NNNN HHHH,... or @N :\n               To store data bytes (HHHH,...) or the contents of a\n               user-area (@N) starting at NNNN location (see at\n               previous D NNNN command for how to specify it).\n               HHHH are pairs of hex digits separated by blanks or\n               commas as desired. @N indicate which user-area to use.\n               An * in place of NNNN continue to store in sequence.\n\n         F '...' OR HHHH... :\n               To find the next first occurrence of a character\n               (1 to 16 characters) or hexadecimal (2 to 32 hex\n               digits) string from the current location pointer\n               until the next end of page boundary address (4K\n               boundary address). Just ENTER or type only F to\n               continue the search in the successive 4K.\n               FULL keyword : may be specified before or after\n                      the search string. It allows to scan the\n                      entire address space, starting-ending at\n                      the current location pointer.\n               NOTE : The last 16 bytes of every 4K page search\n                      are never tested for the requested string\n                      (they are just displayed with the advice\n                      '<--NF'), but they are retained and used\n                      with the 4K successive immediate check, so\n                      scan over pages boundaries is supplied.\n1   29/06/92\n                                                      VCOREZAP  3/6.\n\n  Labels define commands at disposal :\n  ------------------------------------\n\n         A LLLL NNNN :\n               To assign to label LLLL (1 to 8 characters) the\n               specified address or displacement value NNNN (see at\n               previous D NNNN command for how to specify it).\n               If NNNN is omitted, the label LLLL is assigned the\n               current address pointer value.\n\n         Z LLLL :\n               To delete the specified label LLLL reference.\n\n         L LLLL :\n               To display the value of the specified label or\n               all the labels starting by the characters defined\n               by string LLLL. If LLLL is not specified, all the\n               existing labels will be listed.\n\n         I :   To display the internal predefined labels.\n\n  Dsect's commands at disposal :\n  ------------------------------\n\n         B :   Browse all dsects names in the current data-set.\n\n         B DDDD :\n               Browse sequentially the contents of an entire dsect\n               (DDDD is a dsect-name).\n\n         B DDDD ... :\n               Browse information from a dsect (DDDD is a dsect-name).\n               Then follows ... which may be :\n               FFFF : a field-name, or\n               FFFF : a flag-name, or\n               HHHH : a field-displacement (hex), or\n               FFFF HH : a field-name and flag-value (hex).\n\n         Q :   Display how core storage space has grown.\n\n         Q * : Restart the current dsect's data-set.\n\n         Q SSSS :\n               Start a new dsect's data-set (SSSS is a data-set name).\n               Note : Q * and Q SSSS commands may be used to free all\n                      core storage space and start again with the same\n                      or another dsects tables data-set.\n1   29/06/92\n                                                      VCOREZAP  4/6.\n\n  User-areas commands at disposal :\n  ---------------------------------\n\n         M @N :\n               Set and retain as current the user-area number N.\n\n         M :   Display the current user-area.\n\n         M Z or R :\n               Reset to zeros (Z) or blanks (R) the current user-area.\n\n         M HHHH,... or '...' :\n               Store data bytes or characters string in current\n               user-area starting at the current location pointer.\n               HHHH are pairs of hex digits separated by blanks or\n               commas as desired.\n\n         M + or - XX :\n               Move the location pointer forward (+) or backward (-)\n               of XX (hex) data bytes in the current user-area.\n\n         M L XX :\n               Set user-area text data length to XX (hex).\n\n  Miscellaneous commands at disposal :\n  ------------------------------------\n\n         G TTT :\n               This command is available only in full screen mode,\n               and may be used to insert in the input area 1 up to\n               16 bytes (TTT, default is 4) located at the current\n               pointer (usefull to then assign a label or store data\n               in a user-area).\n\n         P ON C(?) D(?) :\n               To start HARDCOPY function (Class/Destination).\n\n         P OFF :\n               To stop HARDCOPY function.\n\n         C ON/OFF :\n               To enable/disable the use of the Address Space\n               commands.\n\n         Y :   Display current Address Space segment-table.\n1   29/06/92\n                                                      VCOREZAP  5/6.\n\n  Address Space commands at disposal :\n  ------------------------------------\n\n         XT :  To load or refresh the AS-table and reset the\n               AS-id mode.\n\n         XA XXXX :\n               To activate the AS-id XXXX mode for the next XD,\n               XS and XF commands. XXXX may be an AS-name (1 to\n               8 characters) or an hex AS-id number (1 to 4 hex\n               digits preceeded by a period, which may be omitted\n               if the first one is a numeric 0-9).\n\n         XC :  To clear the AS-table and reset the AS-id mode.\n\n         XR :  To reset the AS-id mode.\n\n         XL XXXX :\n               To display the value of the specified AS-name (1\n               to 8 characters), AS-id number (1 to 4 hex digits\n               preceeded by a period, which may be omitted if the\n               first one is a numeric 0-9) or all the AS-names\n               starting by the characters defined by string XXXX.\n               If XXXX is not specified, all the AS-table will be\n               listed.\n\n         XD ..., XS ... and XF ... :\n               To display, store and find in the active AS-id.\n               Syntax and processing are identical to D, S and\n               F commands.\n\n         XG TTT :\n               This command is available only in full screen mode,\n               and has the same function as G TTT command, but the\n               bytes are extracted from the active AS-id.\n1   29/06/92\n                                                      VCOREZAP  6/6.\n\n  Special test commands at disposal :\n  -----------------------------------\n\n         T ON/OFF :\n               To enable/disable the access to the VCOREZAP\n               program and arrays storage.\n\n         T L(INE)/S(CREEN) :\n               To change the display mode between line and full\n               screen (only for screen terminal obviously).\n\n         T Y(ES)/N(O) :\n               To enable/disable the segment-table processing use\n               when FIND FULL command.\n\n  Helps commands at disposal :\n  ----------------------------\n\n         H :   To have the Virtual Storage commands summary.\n\n         HL :  To have the label's and dsect's commands summary.\n\n         HM :  To have the miscellaneous commands summary.\n\n         HX :  To have the Address Space commands summary (or XH).\n\n  At any time, enter :       ?     To obtain INFO status.\n  --------------------       E     To terminate.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "VCOREZAH": {"ttr": 16390, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x92\\x17\\x8f\\x00\\x92\\x17\\x8f\\x15\\x03\\x00\\xe0\\x00\\xe0\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1992-06-26T00:00:00", "modifydate": "1992-06-26T15:03:00", "lines": 224, "newlines": 224, "modlines": 0, "user": "SYSPAJA"}, "text": "VCZH     TITLE 'VCOREZAH - VIRTUAL CORE ZAP HELP PANELS.'\n         PRINT OFF\n         MACRO\n&LABEL  @H     &TEXT,&T=NO\n         AIF   ('&TEXT' EQ '').B\n         AIF   ('&T' EQ 'YES').A\n&LABEL  $FS    SF=(PROT),TEXT=(&TEXT,79),MF=L\n         MEXIT\n.A       ANOP\n&LABEL  $FS    TEXT=(&TEXT,80),MF=L\n         MEXIT\n.B       AIF   ('&T' EQ 'YES').C\n&LABEL  $FS    SF=(PROT),TEXT=(' ',79),MF=L\n         MEXIT\n.C       ANOP\n&LABEL  $FS    TEXT=(' ',80),MF=L\n         MEND\n         MACRO\n&LABEL  @FSD   &DUMMY\n&LABEL  $FS    CC=W,MF=L      FULL SCREEN DEFINITIONS\n        $FS    WCC=(KBR,RMDT),SBA=(24,80),MF=L\n        $FS    SBA=(1,1),SF=(PROT),RA=(1,30,'-'),MF=L       LINE 1\n        $FS    SF=(PROT,INT),TEXT='VIRTUAL CORE   Z A P',MF=L\n        $FS    SF=(PROT),RA=(1,80,'-'),MF=L\n        $FS    SF=(PROT,INT),MF=L\n        $FS    TEXT='COMMAND ===>',MF=L                     LINE 2\n        $FS    SBA=(2,80),MF=L          SKIP OVER COMMAND INPUT AREA\n        $FS    SF=(PROT,INT),MF=L\n         MEND\n         MACRO\n&LABEL  @FSI   &DUMMY\n        $FS    SBA=(2,13),SF=NORMAL,MF=L          COMMAND INPUT AREA\n&LABEL.I DC    XL(FSRPLYL)'0'\n        $FS    SBA=(1,1),SF=(PT,IC),MF=L\n&LABEL.L EQU   *-&LABEL\n         MEND\n         PRINT ON\n         SPACE 1\n*---------------------------------------------------------------------*\n*                                                                     *\n*        VIRTUAL CORE ZAP HELP PANELS DEFINITIONS.                    *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 1\nVCOREZAH START 0\n         SPACE 1\n         ENTRY VCOREZHE\n         SPACE 1\n*        VECTOR OF POINTERS TO HELP PANELS DATA.\n*        ---------------------------------------\n         SPACE 1\n         DC    A(HELP,HELPL,HELPI)      H PANEL\n         DC    A(LHELP,LHELPL,LHELPI)   H L PANEL\n         DC    A(MHELP,MHELPL,MHELPI)   H M PANEL\n         DC    A(XHELP,XHELPL,XHELPI)   H X PANEL\n         DC    A(AUTH1F,AUTH1T,AUTH1L)  1ST RESERVED LINE(S) ADDRESSES\n         DC    A(AUTH2F,AUTH2T,AUTH2L)  2ND RESERVED LINE(S) ADDRESSES\n         SPACE 2\nFSRPLYL  EQU   66             LENGTH OF REPLY AREA\nHLRESL   EQU   81             LENGTH OF RESERVED LINES TEXT\n         SPACE 2\n         PRINT NOGEN\nAUTH1F   EQU   *\n @H 'H X : Address Space commands help (PF-2/14).'\n @H 'Special - C ON/OFF : to alter Virtual Core Storage.'\n @H '          T L(INE)/S(CREEN) : flip-flop line/full screen.'\n @H '          T ON/OFF : to access own program storage (C OFF only).'\n @H '          T YES/NO : to use segment-table process (FIND FULL).'\nAUTH1L   EQU   (*-AUTH1F)/HLRESL\n         SPACE 1\nAUTH2F   EQU   *\n @H 'V : display current Address Space segment-table.'\nAUTH2L   EQU   (*-AUTH2F)/HLRESL\n         PRINT GEN\n         SPACE 2\n* NOTES : 1. ANY CHANGE ABOVE MUST BE REPORTED IN THE HELPVP DSECT.\n*         2. EACH PANEL MUST CONTAIN A TITLE LINE AND 21 HELP LINES.\n         EJECT\nHELP    @FSD   ,\n         PRINT NOGEN\n         EJECT\n @H 'VIRTUAL STORAGE COMMANDS SUMMARY :',T=YES\n @H 'D NNNN : display 16 bytes at location NNNN (address + or - a displ1\n               acement'\n @H '         is allowed). Just ENTER or type only D to display 16 hex 1\n               bytes'\n @H '         starting at the current or +16 address pointer (continue 1\n               display).'\n @H '         Updated by D, S, F and A commands. Enter + or - decimal 11\n                up to 999'\n @H '         to display forward/backward from current location pointer1\n                (you may'\n @H '         use PF-7/19 = D current loc.-128 and PF-8/20 = D current 1\n               loc.+128).'\n @H 'S NNNN HHHH,... or @N : store HHHH,... or the contents of user-are1\n               a N'\n @H '         at location NNNN (address + or - a displacement is allowe1\n               d).'\n @H 'S * HHHH,... or @N : continue to store at location in sequence.'\n @H 'F ''...'' or HHHH... : to find a string. Just ENTER or use PF-5/171\n                or'\n @H '         type only F to continue the search in the next 4K page.'\n @H '    FULL : search an entire Address Space (only ENTER maintain con1\n               dition).'\n @H 'E : terminate processing (exit : PF-3/15 or PF-4/16).'\n @H 'H : Virtual Storage commands help (PF-1/13).'\n @H 'H L : Labels''s and Dsect''s commands help (PF-10/22).'\n @H 'H M : Miscellaneous commands help (PF-11/23).'\nAUTH1T   @H    ,              RESERVED LINE (H X)\n         @H    ,              RESERVED LINE (C ON/OFF)\n         @H    ,              RESERVED LINE (T LINE/SCREEN)\n         @H    ,              RESERVED LINE (T ON/OFF)\n         @H    ,              RESERVED LINE (T YES/NO)\n         PRINT GEN\nHELP    @FSI   ,\n         EJECT\nLHELP   @FSD   ,\n         PRINT NOGEN\n         EJECT\n @H 'LABEL''S AND DSECT''S COMMANDS SUMMARY :',T=YES\n @H 'A LLLL NNNN : assign to label LLLL the value NNNN (location or onl1\n               y displ.).'\n @H '         If NNNN omitted = current address pointer.'\n @H 'Z LLLL : delete the label LLLL and his value.'\n @H 'L LLLL : display value of label(s) LLLL (if LLLL omitted = all lab1\n               els).'\n @H 'I : to display all the predefined labels.'\n @H ,\n @H 'B : browse all dsect''s names in the current data-set.'\n @H 'B DDDD : browse sequentially an entire dsect (DDDD is the dsect-na1\n               me).'\n @H 'B DDDD ... : browse information from a dsect (DDDD is the dsect-na1\n               me).'\n @H '         Then follows ... which may be :'\n @H '         FFFF : a field-name, or'\n @H '         FFFF : a flag-name, or'\n @H '         HHHH : a field-displacement (hex), or'\n @H '         FFFF HH : a field-name and flag-value (hex).'\n @H 'Q : display how core storage space has grown.'\n @H 'Q * : restart the current dsect''s data-set.'\n @H 'Q SSSS : start a new dsect''s data-set (SSSS is the data-set name)1\n               .'\n @H '         Note : Q * and Q SSSS commands may be used to free all co1\n               re'\n @H '                storage space and start again with the same or ano1\n               ther'\n @H '                dsects tables data-set.'\n @H ,\n         PRINT GEN\nLHELP   @FSI   ,\n         EJECT\nMHELP   @FSD   ,\n         PRINT NOGEN\n         EJECT\n @H 'MISCELLANEOUS COMMANDS SUMMARY :',T=YES\n @H 'M @N : set and retain as current the user-area number N.'\n @H 'M : display the current user-area.'\n @H 'M Z or R : reset to zeros (Z) or blanks (R) the actual user-area.'\n @H 'M HHHH,... or ''...'' : store data bytes or characters string in c1\n               urrent'\n @H '         user-area starting at the current location pointer. HHHH 1\n               are'\n @H '         pairs of hex digits separated by blanks or commas as desi1\n               red.'\n @H 'M + OR - XX : move the location pointer forward (+) or backward (-1\n               ) of XX'\n @H '         (hex) data bytes in the current user-area.'\n @H 'M L XX : set user-area text data length to XX (hex).'\n @H 'G TTT : to insert in the input area 1 up to 16 bytes (TTT, default1\n                is 4)'\n @H '         located at the current pointer (usefull to then assign a 1\n               label or'\n @H '         store data in a user-area). PF-6/18 : G (default is 4).'\nAUTH2T   @H    ,              RESERVED LINE (V)\n @H 'P ON C(?) D(?) : start the HARDCOPY function. C(?) is the SYSOUT c1\n               lass'\n @H '         for hardcopy (default is A). D(?) is a JES2 destination f1\n               or'\n @H '         hardcopy (default is local).'\n @H 'P OFF : stop the HARDCOPY function (default).'\n @H ,\n @H 'PA2 or PF-12/24 : redisplay last display command (RESHOW).'\n @H '? : display status.'\n @H ,\n         PRINT GEN\nMHELP   @FSI   ,\n         EJECT\nXHELP   @FSD   ,\n         PRINT NOGEN\n         EJECT\n @H 'ADDRESS SPACE COMMANDS SUMMARY :',T=YES\n @H 'XT : load/refresh AS-table and reset AS-id mode.'\n @H 'XA XXXX : activate AS-id XXXX mode (for next XD, XF and XS command1\n               s).'\n @H 'XC : clear AS-table and reset AS-id mode.'\n @H 'XR : reset AS-id mode.'\n @H 'XL XXXX : display AS-name/AS-id of AS-table (if XXXX omitted = all1\n                AS-table).'\n @H ,\n @H 'XD, XF and XS : display, find and store in the active AS-id (same 1\n               as D,'\n @H '         F and S commands, always prefixed by X, see at H or PF-1/1\n               13).'\n @H 'XG TTT : same function as G TTT command (see at H M or PF-11/23), 1\n               but the'\n @H '         bytes located at the current pointer are extracted from t1\n               he'\n @H '         active AS-id. PF-6/18 : X G (default is 4).'\n @H ,\n @H 'XH : Address Space commands help (PF-2/14).'\n @H ,\n @H ,\n @H ,\n @H ,\n @H ,\n @H ,\n @H ,\n @H ,\n         PRINT GEN\nXHELP   @FSI   ,\n         SPACE 2\nVCOREZHE EQU   *              PROGRAM SPACE END CONTROL\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "VCOREZAP": {"ttr": 16395, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x92\\x18\\x1f\\x00\\x92\\x18\\x1f\\x14V\\x17\\xae\\x17\\xae\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1992-06-29T00:00:00", "modifydate": "1992-06-29T14:56:00", "lines": 6062, "newlines": 6062, "modlines": 0, "user": "SYSPAJA"}, "text": "VCRZ     TITLE 'VCOREZAP - VIRTUAL CORE ZAP.'\n        PRINT  OFF\n         MACRO\n&NAME   @INIT  &LABEL\n&NAME   $HEDIT &LABEL\n         USING &NAME,R10           LOCAL ADDRESSABILITY\n         MEND\n         MACRO\n&DUML   @END   &DUMA\n        LTORG\n         SPACE 1\n         DROP  R10                 END OF LOCAL ADDRESSABILITY\n         MEND\n         MACRO\n&LABEL  @SEND  &A,&OP=L\n         AIF   ('&OP' EQ 'L').A\n         AIF   ('&OP' EQ 'LA').B\n         AIF   ('&OP' EQ 'NONE').C\n        MNOTE  4,'*** INVALID OP= SPECIFIED, OP=L ASSUMED.'\n.A       ANOP\n&LABEL   L     R1,=A(&A)\n         AGO   .Z\n.B       ANOP\n&LABEL   LA    R1,&A\n.Z       BAS   R8,SEND\n         MEXIT\n.C       ANOP\n&LABEL   BAS   R8,SEND\n         MEND\n         MACRO\n&LABEL  @WL    &N\n         LCLA  &Z\n&Z       SETA  &N\n         AIF   (&Z LT 1).A\n         AIF   (&Z LE 24).B\n&Z       SETA  24\n         AGO   .B\n.A       ANOP\n&Z       SETA  1\n.B       ANOP\n&LABEL  $FS    SF=(PROT),TEXT=(' ',79),MF=L\n.C       AIF   (&Z EQ 1).D\n        $FS    SF=(PROT),TEXT=(' ',79),MF=L\n&Z       SETA  &Z-1\n         AGO   .C\n.D       MEND\n         MACRO\n&LABEL  @WTO   &TEXT\n&LABEL  WTO    &TEXT,MF=L\n         MEND\n        PRINT  ON\n         SPACE 1\nVCOREZAP START 0\n         SPACE 1\n* PURPOSE :    THIS MODULE ALLOWS THE ALTERATION OR DISPLAY OF ANY\n* ---------    VIRTUAL STORAGE LOCATIONS IN THE NUCLEUS, CSA, ADDRESS\n*              SPACES (NOT SWAP-OUT), ETC...\n*              NOTE : IT DOES'NT REPLACE THE 'INCORZAP' PROGRAM TO\n*                     MODIFY THE LPA WHICH IS STORE PROTECTED.\n*\n* CBT ORIGIN : BASE IDEA FROM CBT TAPE FEB 85, FILE 056.\n* ------------ ENLARGED BY : MOINIL P.A.\n*                            COMPUTING CENTRE\n*                            J.R.C. - ISPRA ESTABLISHMENT\n*                            21020 ISPRA (VA), ITALY\n*\n* ADDS/CHANGES : - CHECK CALLER AUTHORITY AND ENVIRONMENT.\n* -------------- - EXTENDED COMMANDS LANGUAGE TO USE LABELS FACILITY.\n*                - ADDRESS SPACE COMMANDS (CROSS MEMORY).\n*                - USER-AREAS COMMANDS.\n*                - FULL SCREEN DISPLAY.\n*                - HARDCOPY FUNCTION.\n*                - DSECTS AVAILABILITY (PRE-REQUISITE GDTUTIL/DTUR).\n*                - SEGMENT-TABLE PROCESSING USE WITH \"FIND FULL\".\n*\n***********************************************************************\n* NOTE :       A DEFAULT DATA-SET NAME FOR DSECTS TABLES IS DEFINED   *\n* ------       IN THE ASSEMBLY FIELD 'DRFDSN'.                        *\n***********************************************************************\n         EJECT\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n*        AUTHORITY LEVELS DEFINITIONS.                                *\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n         SPACE 1\n*                             X-M = CROSS MEMORY REFERENCE.\nLV15     EQU   15             FULL DISPLAY/STORE/TEST LEVEL.\nLV10     EQU   10 - 14        FULL DISPLAY AND STORE WITHOUT X-M LEVEL.\nLV5      EQU   5 - 9          FULL DISPLAY LEVEL.\nLV1      EQU   1 - 4          ONLY DISPLAY WITHOUT X-M LEVEL.\n         SPACE 1\n        $MDL@IX\n         SPACE 2\n*        TABLES DIMENSIONS.\n*        ------------------\n         SPACE 1\nNASSTE   EQU   100            MAX. NO. OF ASSIGNED LABELS\nNFIXTE   EQU   50             MAX. NO. OF PREDEFINED LABELS\nNASNTE   EQU   300            MAX. NO. OF AS-NAMES/AS-ID'S.\nNTKWAS   EQU   10             MAX. NO. OF TANKS USER-AREAS (MAX=999).\n         EJECT\n* VIRTUAL STORAGE COMMANDS AT DISPOSAL :\n* --------------------------------------\n*\n*        D NNNN :\n*              TO DISPLAY 16 HEX BYTES STARTING AT LOCATION NNNN.\n*              JUST ENTER OR TYPE ONLY D TO DISPLAY 16 HEX BYTES\n*              STARTING AT THE CURRENT OR +16 ADDRESS POINTER\n*              (CONTINUE THE DISPLAY OF DATA). THIS POINTER IS\n*              UPDATED BY ANY D, S, F AND A COMMANDS. ENTER + OR\n*              - DECIMAL 1 UP TO 999 TO DISPLAY FORWARD/BACKWARD\n*              FROM CURRENT LOCATION POINTER.'\n*              NNNN MAY BE :\n*              A LABEL (1 TO 8 CHARACTERS),\n*                OR AN HEX ADDRESS (1 TO 8 HEX DIGITS PRECEEDED BY\n*                   A PERIOD, WHICH MAY BE OMITTED IF THE FIRST ONE\n*                   IS A NUMERIC 0-9),\n*                OR A FIELD-NAME AND DSECT-NAME (SEPARATED BY A\n*                   SLASH AND GIVEN IN THIS ORDER, WHERE DSECT-NAME\n*                   MUST ALSO EXIST AS LABEL),\n*              FOLLOWED BY AN EVENTUAL DISPLACEMENT EXPRESSED AS +\n*              OR - DDDD (ANOTHER LABEL OR HEX VALUE),\n*                   OR A FIELD-NAME AND DSECT-NAME (SEPARATED BY A\n*                      SLASH AND GIVEN IN THIS ORDER).\n*\n*        S NNNN HHHH,... OR @N :\n*              TO STORE DATA BYTES (HHHH,...) OR THE CONTENTS OF A\n*              USER-AREA (@N) STARTING AT NNNN LOCATION (SEE AT\n*              PREVIOUS D NNNN COMMAND FOR HOW TO SPECIFY IT).\n*              HHHH ARE PAIRS OF HEX DIGITS SEPARATED BY BLANKS OR\n*              COMMAS AS DESIRED. @N INDICATE WHICH USER-AREA TO USE.\n*              AN * IN PLACE OF NNNN CONTINUE TO STORE IN SEQUENCE.\n*\n*        F '...' OR HHHH... :\n*              TO FIND THE NEXT FIRST OCCURRENCE OF A CHARACTER\n*              (1 TO 16 CHARACTERS) OR HEXADECIMAL (2 TO 32 HEX\n*              DIGITS) STRING FROM THE CURRENT LOCATION POINTER\n*              UNTIL THE NEXT END OF PAGE BOUNDARY ADDRESS (4K\n*              BOUNDARY ADDRESS). JUST ENTER OR TYPE ONLY F TO\n*              CONTINUE THE SEARCH IN THE SUCCESSIVE 4K.\n*              'FULL' KEYWORD : MAY BE SPECIFIED BEFORE OR AFTER\n*                     THE SEARCH STRING. IT ALLOWS TO SCAN THE\n*                     ENTIRE ADDRESS SPACE, STARTING-ENDING AT\n*                     THE CURRENT LOCATION POINTER.\n*              NOTE : THE LAST 16 BYTES OF EVERY 4K PAGE SEARCH\n*                     ARE NEVER TESTED FOR THE REQUESTED STRING\n*                     (THEY ARE JUST DISPLAYED WITH THE ADVICE\n*                     '<--NF'), BUT THEY ARE RETAINED AND USED\n*                     WITH THE 4K SUCCESSIVE IMMEDIATE CHECK, SO\n*                     SCAN OVER PAGES BOUNDARIES IS SUPPLIED.\n         EJECT\n* LABELS DEFINE COMMANDS AT DISPOSAL :\n* ------------------------------------\n*\n*        A LLLL NNNN :\n*              TO ASSIGN TO LABEL LLLL (1 TO 8 CHARACTERS) THE\n*              SPECIFIED ADDRESS OR DISPLACEMENT VALUE NNNN (SEE AT\n*              PREVIOUS D NNNN COMMAND FOR HOW TO SPECIFY IT).\n*              IF NNNN IS OMITTED, THE LABEL LLLL IS ASSIGNED THE\n*              CURRENT ADDRESS POINTER VALUE.\n*\n*        Z LLLL :\n*              TO DELETE THE SPECIFIED LABEL LLLL REFERENCE.\n*\n*        L LLLL :\n*              TO DISPLAY THE VALUE OF THE SPECIFIED LABEL OR\n*              ALL THE LABELS STARTING BY THE CHARACTERS DEFINED\n*              BY STRING LLLL. IF LLLL IS NOT SPECIFIED, ALL THE\n*              EXISTING LABELS WILL BE LISTED.\n*\n*        I :   TO DISPLAY THE INTERNAL PREDEFINED LABELS.\n*\n* DSECT'S COMMANDS AT DISPOSAL :\n* ------------------------------\n*\n*        B :   BROWSE ALL DSECTS NAMES IN THE CURRENT DATA-SET.\n*\n*        B DDDD :\n*              BROWSE SEQUENTIALLY THE CONTENTS OF AN ENTIRE DSECT\n*              (DDDD IS A DSECT-NAME).\n*\n*        B DDDD ... :\n*              BROWSE INFORMATION FROM A DSECT (DDDD IS A DSECT-NAME).\n*              THEN FOLLOWS ... WHICH MAY BE :\n*              FFFF : A FIELD-NAME, OR\n*              FFFF : A FLAG-NAME, OR\n*              HHHH : A FIELD-DISPLACEMENT (HEX), OR\n*              FFFF HH : A FIELD-NAME AND FLAG-VALUE (HEX).\n*\n*        Q :   DISPLAY HOW CORE STORAGE SPACE HAS GROWN.\n*\n*        Q * : RESTART THE CURRENT DSECT'S DATA-SET.\n*\n*        Q SSSS :\n*              START A NEW DSECT'S DATA-SET (SSSS IS A DATA-SET NAME).\n*              NOTE : Q * AND Q SSSS COMMANDS MAY BE USED TO FREE ALL\n*                     CORE STORAGE SPACE AND START AGAIN WITH THE SAME\n*                     OR ANOTHER DSECTS TABLES DATA-SET.\n         EJECT\n* USER-AREAS COMMANDS AT DISPOSAL :\n* ---------------------------------\n*\n*        M @N :\n*              SET AND RETAIN AS CURRENT THE USER-AREA NUMBER N.\n*\n*        M :   DISPLAY THE CURRENT USER-AREA.\n*\n*        M Z OR R :\n*              RESET TO ZEROS (Z) OR BLANKS (R) THE CURRENT USER-AREA.\n*\n*        M HHHH,... OR '...' :\n*              STORE DATA BYTES OR CHARACTERS STRING IN CURRENT\n*              USER-AREA STARTING AT THE CURRENT LOCATION POINTER.\n*              HHHH ARE PAIRS OF HEX DIGITS SEPARATED BY BLANKS OR\n*              COMMAS AS DESIRED.\n*\n*        M + OR - XX :\n*              MOVE THE LOCATION POINTER FORWARD (+) OR BACKWARD (-)\n*              OF XX (HEX) DATA BYTES IN THE CURRENT USER-AREA.\n*\n*        M L XX :\n*              SET USER-AREA TEXT DATA LENGTH TO XX (HEX).\n*\n* MISCELLANEOUS COMMANDS AT DISPOSAL :\n* ------------------------------------\n*\n*        G TTT :\n*              THIS COMMAND IS AVAILABLE ONLY IN FULL SCREEN MODE,\n*              AND MAY BE USED TO INSERT IN THE INPUT AREA 1 UP TO\n*              16 BYTES (TTT, DEFAULT IS 4) LOCATED AT THE CURRENT\n*              POINTER (USEFULL TO THEN ASSIGN A LABEL OR STORE DATA\n*              IN A USER-AREA).\n*\n*        P ON C(?) D(?) :\n*              START HARDCOPY (CLASS/DESTINATION).\n*\n*        P OFF :\n*              STOP HARDCOPY.\n*\n*        C ON/OFF :\n*              TO ENABLE/DISABLE THE USE OF THE ADDRESS SPACE\n*              COMMANDS.\n*\n*        Y :   DISPLAY CURRENT ADDRESS SPACE SEGMENT-TABLE.\n         EJECT\n* ADDRESS SPACE COMMANDS AT DISPOSAL :\n* ------------------------------------\n*\n*        XT :  TO LOAD OR REFRESH THE AS-TABLE AND RESET THE\n*              AS-ID MODE.\n*\n*        XA XXXX :\n*              TO ACTIVATE THE AS-ID XXXX MODE FOR THE NEXT XD,\n*              XS AND XF COMMANDS. XXXX MAY BE AN AS-NAME (1 TO\n*              8 CHARACTERS) OR AN HEX AS-ID NUMBER (1 TO 4 HEX\n*              DIGITS PRECEEDED BY A PERIOD, WHICH MAY BE OMITTED\n*              IF THE FIRST ONE IS A NUMERIC 0-9).\n*\n*        XC :  TO CLEAR THE AS-TABLE AND RESET THE AS-ID MODE.\n*\n*        XR :  TO RESET THE AS-ID MODE.\n*\n*        XL XXXX :\n*              TO DISPLAY THE VALUE OF THE SPECIFIED AS-NAME (1\n*              TO 8 CHARACTERS), AS-ID NUMBER (1 TO 4 HEX DIGITS\n*              PRECEEDED BY A PERIOD, WHICH MAY BE OMITTED IF THE\n*              FIRST ONE IS A NUMERIC 0-9) OR ALL THE AS-NAMES\n*              STARTING BY THE CHARACTERS DEFINED BY STRING XXXX.\n*              IF XXXX IS NOT SPECIFIED, ALL THE AS-TABLE WILL BE\n*              LISTED.\n*\n*        XD ..., XS ... AND XF ... :\n*              TO DISPLAY, STORE AND FIND IN THE ACTIVE AS-ID.\n*              SYNTAX AND PROCESSING ARE IDENTICAL TO D, S AND\n*              F COMMANDS.\n*\n*        XG TTT :\n*              THIS COMMAND IS AVAILABLE ONLY IN FULL SCREEN MODE,\n*              AND HAS THE SAME FUNCTION AS G TTT COMMAND, BUT THE\n*              BYTES ARE EXTRACTED FROM THE ACTIVE AS-ID.\n         EJECT\n* SPECIAL TEST COMMANDS AT DISPOSAL :\n* ------------------------------------\n*\n*        T ON/OFF :\n*              TO ENABLE/DISABLE THE ACCESS TO THE \"VCOREZAP\"\n*              PROGRAM AND ARRAYS STORAGE (AVAILABLE ONLY WITH\n*              \"C OFF\").\n*\n*        T L(INE)/S(CREEN) :\n*              TO CHANGE THE DISPLAY MODE BETWEEN LINE AND FULL\n*              SCREEN (ONLY FOR SCREEN TERMINAL OBVIOUSLY).\n*\n*        T Y(ES)/N(O) :\n*              TO ENABLE/DISABLE THE SEGMENT-TABLE PROCESSING USE\n*              WHEN \"FIND FULL\" COMMAND.\n*\n* HELPS COMMANDS AT DISPOSAL :\n* ----------------------------\n*\n*        H :   TO HAVE THE VIRTUAL STORAGE COMMANDS SUMMARY.\n*\n*        HL :  TO HAVE THE LABEL'S AND DSECT'S COMMANDS SUMMARY.\n*\n*        HM :  TO HAVE THE MISCELLANEOUS COMMANDS SUMMARY.\n*\n*        XH :  TO HAVE THE ADDRESS SPACE COMMANDS SUMMARY.\n*\n* AT ANY TIME, ENTER :       ?     TO OBTAIN INFO STATUS.\n* --------------------       E     TO TERMINATE.\n         EJECT\n        $DEFREG\nKB       EQU   1024                1 K-BYTES\n         SPACE 1\nVCOREZAP AMODE 24\nVCOREZAP RMODE 24\n         EJECT\n        $HEDIT\n        $XENT  BASE=R12\n         L     R15,AVSVERR\n         MVC   0(18*4,R15),0(R13)  COPY SAVE AREA\n         LR    R13,R15             SUBSTITUTION\n         USING VSVERR,R13\n         L     R11,AVCWORK\n         USING VCWORK,R11\n         L     R10,=A(VCINIT)\n         BR    R10                 -> INITIALIZATION\n         SPACE 1\nAVSVERR  DC    A(VSVERR)           SAVE AREA - ERROR RETURNS\nAVCWORK  DC    A(VCWORK)           WORK AREAS ADDRESS/BASE REGISTER\n         EJECT\n***********************************************************************\n*        GET A COMMAND OR CONTINUE WITH PREVIOUS.                     *\n***********************************************************************\nINQUIRT  TM    FSCRSW,FSCRSF       FULL SCREEN?\n         BZ    INQUIRY             NO\n         L     R10,=A(INFST)       YES, GET STATUS\n         USING INFST,R10\n         B     INFST0\n         DROP  R10\nINQUIRY  NI    SWITCH,255-XMEMRF   RESET X-MEM REF. REQUEST\n         NI    OPERSW,255-GETBSW\n        @SEND  INQRY\n         OC    ANSR(L'ANSR),ALLBLKS\n         LM    R3,R5,SCVAL\n         CLI   0(R3),C' '\n         BNE   WHAT\n         BXLE  R3,R4,*-8\n         TM    STATUS,TESTRUN\n         BZ    *+L'*+6\n         MVC   RCVIND(L'RCVIND),ALLBLKS\n         TM    FSCRSW,FSCRSF       FULL SCREEN?\n         BZ    *+L'*+8             NO\n         TM    FSCRSW,FSCRSC       CONTINUATION?\n         BO    CONTOUT             YES\n         CLI   PRVOP,C'S'\n         BNE   INQ1\n         L     R6,PVPTR\n         TM    SWITCH,POPXMR       WAS PREVIOUS OP. X-MEM. REF. MODE?\n         BZ    *+L'*+4             NO\n         OI    SWITCH,XMEMRF       YES, CONTINUE IN X-MEM. REF. MODE\n         NI    SWITCH,255-ASFULL-PVALID RESET\n         L     R10,=A(DSPLY)\n         USING DSPLY,R10\n         B     DSPLY0\n         DROP  R10\nINQ1     L     R6,CRPTR\n         ST    R6,DATA\n         TM    SWITCH,POPXMR       WAS PREVIOUS OP. X-MEM. REF. MODE?\n         BZ    *+L'*+4             NO\n         OI    SWITCH,XMEMRF       YES, CONTINUE IN X-MEM. REF. MODE\n         CLI   PRVOP,C'F'\n         BNE   *+L'*+8\n         L     R10,=A(FIND)\n         USING FIND,R10\n         B     FNCNT\n         DROP  R10\n         NI    SWITCH,255-ASFULL-PVALID RESET\n         L     R10,=A(DSPLY)\n         USING DSPLY,R10\n         B     DSPLY1\n         DROP  R10\nWHAT     L     R10,=A(ENCMD)\n         BR    R10\nLISTOUT  TM    FSCRSW,FSCRSF       FULL SCREEN?\n         BZ    ADDOUT              NO\n         CLC   FSPOINT,=A(16*81)   YES, SCREEN FULL?\n         BL    ADDOUT              NO\n         MVC   MSGSVT(L'MSGTXT),MSGTXT  YES, SAVE DATA\n         OI    FSCRSW,FSCRSC       SAY CONTINUATION\n         NI    FSCRSW,255-FSCRSL   RESET DATA\n        $FS    SF=(PROT,INT),MF=(I,FSCRSDC)\n         MVC   FSCRTDC,=CL6'*MORE*'     INDICATE THAT DATA CONTINUE\n         STM   R2,R10,FSSAVE  SAVE REGISTERS AROUND SCREEN OPERATIONS\n         L     R10,=A(INFST)\n         USING INFST,R10\n         B     INFST0\n         DROP  R10\nCONTOUT  LM    R2,R10,FSSAVE       RESTORE REGISTERS\n         MVC   MSGTXT(L'MSGTXT),MSGSVT  RESTORE DATA\n         XC    FSPOINT,FSPOINT\n         OI    FSCRSW,FSCRSL       SAY DATA LINES\n         NI    FSCRSW,255-FSCRSC   RESET CONTINUATION\nADDOUT  @SEND  MSGOUT,OP=LA\n         BR    R9                  RETURN\n         EJECT\n***********************************************************************\n*        RECOVERY PROCESS.                                            *\n***********************************************************************\nRECOVER0 TM    STATUS,TESTRUN ------------------------------ * DANGER *\n         BZ    RECOVER                                                *\n         MVI   RCVIND,C'0'                                            *\nRECOVER  BAS   R8,DISABLE ---------------------------------- * DANGER *\n         TM    SWITCH,ASFULL       ENTIRE A.S. SEARCH?\n         BO    RCVR4               YES\n         TM    FSCRSW,FSCRSF       FULL SCREEN?\n         BZ    RCVR2               NO, PROCESS 0C4\n         TM    FSPRSW,FSPRDS       DISPLAY OPERATION?\n         BZ    RCVR2               NO, PROCESS 0C4\n         LM    R0,R15,FSRCVR       RESTORE REGISTERS\n         AR    R2,R6               0C4 IS OCCURED ON NEXT PAGE\n         LR    R1,R2\n         SRL   R2,8                COMPUTE HOW MANY BYTES IN GOOD PAGE\n         SLL   R2,8\n         SR    R2,R6\n         BNP   RCVR2               NONE, PROCESS 0C4\n         LR    R0,R6\n         SRL   R0,12\n         SLL   R0,12\n         LTR   R0,R0\n         BZ    RCVR1               PAGE 0 IS AN EXCEPTION\n         SRL   R1,12\n         SLL   R1,12\n         CLR   R0,R1\n         BE    RCVR2               SAME PAGE, PROCESS 0C4\nRCVR1    LR    R1,R2\n         XR    R0,R0\n         D     R0,=A(L'HXDATA)\n         LR    R4,R1               NEW NUMBER OF LINES TO DISPLAY\n         NI    FSPRSW,255-FSPRDS   RESET\n         TM    SWITCH,POPXMR       WAS PREVIOUS OP. X-MEM. REF. MODE?\n         BZ    *+L'*+4             NO\n         OI    SWITCH,XMEMRF       YES, CONTINUE IN X-MEM. REF. MODE\n         L     R10,=A(DSPLY)\n         USING DSPLY,R10\n         B     DSPLY3              RESTART\n         DROP  R10\nRCVR2    L     R1,=A(DISCC)\n         UNPK  32(9,R1),RCVPTR(5)\n         TR    32(8,R1),HEXTAB-X'F0'\n         MVI   40(R1),C' '\n        @SEND  OP=NONE             DISPLAY 0C4.\n         CLI   PRVOP,C'S'\n         BE    INQUIRT\n         L     R1,RCVPTR           RECOVER POINTERS\n         ST    R1,PVPTR\n         CLI   PRVOP,C'F'\n         BE    *+L'*+8\n         LA    R1,L'HXDATA(R1)     NEXT DATA DISPLAY\n         B     RCVR3\n         NI    SWITCH,255-PVALID\n         LA    R1,2048(R1)         NEXT PAGE FIND\n         LA    R1,2048(R1)\nRCVR3    ST    R1,CRPTR\n         B     INQUIRT\nRCVR4    NI    SWITCH,255-PVALID\n         L     R4,RCVPTR\n         TM    SGTPSW,STPDIS+STPUSE     SEGMENT PROCESSING DISABLED?\n         BNZ   RCVR5               YES\n         LR    R10,R4              NO, CHECK IF ON A NEW M-BYTE SEGMENT\n         SRL   R10,20\n         SLL   R10,20\n         CLR   R10,R4\n         BNE   RCVR5\n         L     R10,=A(SGTCHK)\n         BASR  R14,R10             GO CHECK SEGMENT-TABLE\n         L     R4,RCVPTR\n         LTR   R15,R15             HOW COMPLETE?\n         BZ    RCVR5               OK, CONTINUE\n         ST    R4,CRPTR            ERROR, GO DISPLAY DIAGNOSE\n         B     INQUIRT\nRCVR5    L     R10,=A(FIND)\n         USING FIND,R10\n         B     FNRCV\n         DROP  R10\n         EJECT\n***********************************************************************\n*        DIAGNOSTIC MESSAGE.                                          *\n***********************************************************************\nERROR    TM    STATUS,TESTRUN\n         BZ    *+L'*+6\n         MVC   RCVIND(L'RCVIND),ALLBLKS\n         TM    FSCRSW,FSCRSF       FULL SCREEN?\n         BZ    ERRORMS             NO\n         XC    FSPOINT,FSPOINT     YES, RESET\n         NI    FSCRSW,255-FSCRSC-FSCRSH-FSCRST-FSCRSL-FSCRSI\n         NI    FSPRSW,255-FSPRDS\nERRORMS @SEND  OP=NONE\n         B     INQUIRT\n         SPACE 1\n***********************************************************************\n*        THAT'S ALL FOLKS.                                            *\n***********************************************************************\nFINISH   L     R10,=A(VCEND)\n         BR    R10                 -> TERMINATION\nEXRET    L     R15,RETCC\n        $XRET  CC=(R15)\n         EJECT\n***********************************************************************\n*        SUBROUTINE TO DECODE AN HEX FIELD (MAX. LENGTH 8).           *\n*        REGISTERS USE : R1 - WORK REGISTER / NO. OF HEX DIGITS       *\n*                        R2 - WORK REGISTER                           *\n*                        R3-R4-R5 - ANSWER SCAN REGISTERS             *\n*                        R14 - LINK REGISTER                          *\n*                               +0 - NO FIELD FOUND                   *\n*                               +4 - INVALID HEX                      *\n*                               +8 - TOO LONG                         *\n*                              +12 - FIELD PROCESSED                  *\n*                                    (VALUE IS IN 'DATA')             *\n***********************************************************************\nSCAN     XR    R1,R1\n         XC    DATA,DATA\n         LR    R2,R3               START OF DATA FIELD\nSCAN1    CLI   0(R3),C','          DELIMITER ,?\n         BE    SCAN2               YES\n         CLI   0(R3),C'+'          DELIMITER +?\n         BE    SCAN2               YES\n         CLI   0(R3),C'-'          DELIMITER -?\n         BE    SCAN2               YES\n         CLI   0(R3),C' '          END OF DATA?\n         BE    SCAN2               YES\n         CLI   0(R3),C'A'\n         BL    4(R14)              EXIT ---------------------------> +4\n         CLI   0(R3),C'9'\n         BH    4(R14)              EXIT ---------------------------> +4\n         CLI   0(R3),C'0'\n         BNL   *+L'*+8\n         CLI   0(R3),C'F'\n         BH    4(R14)              EXIT ---------------------------> +4\n         BXLE  R3,R4,SCAN1         INC PTR\nSCAN2    LR    R1,R3               TURN TO WK REG\n         SR    R1,R2               GET NO OF CHAR SCANNED\n         BNPR  R14                 SKIP MOVE IF ZERO --------------> +0\n         CH    R1,=H'8'\n         BH    8(R14)              SKIP MOVE IF INVALID ADDRESS ---> +8\n         BCTR  R1,0                DECR. BY 1\n         XC    FXLAB,FXLAB         CLEAR WORK AREA\n         EX    R1,MVTMP            MOVE TO WORK AREA\n         EX    R1,NRTMP            NORMALIZE FOR TRANSLATE\n         EX    R1,TRTMP            TRANSLATE TO BINARY\n         LA    R1,1(R1)            INCR. BY 1\n         EX    R1,PKTMP            CONVERT TO HEX\n         B     12(R14)             EXIT --------------------------> +12\nMVTMP    MVC   FXLAB(*-*),0(R2)    <<EXECUTED>>\nNRTMP    NC    FXLAB(*-*),=XL8'1F1F1F1F1F1F1F1F'  <<EXECUTED>>\nTRTMP    TR    FXLAB(*-*),TRANTBL  <<EXECUTED>>\nPKTMP    PACK  DATA(L'DATA+1),FXLAB(*-*)     <<EXECUTED>>\n         EJECT\n***********************************************************************\n*        SUBROUTINE TO EXTRACT A LABEL (MAX. LENGTH 8).               *\n*        REGISTERS USE : R1 - WORK REGISTER / NO. OF CHAR. -1         *\n*                        R2 - WORK REGISTER                           *\n*                        R3-R4-R5 - ANSWER SCAN REGISTERS             *\n*                        R7-R8-R9 - P.LABELS TABLE SCAN REGISTERS     *\n*                        R14 - LINK REGISTER                          *\n*                               +0 - NO LABEL FOUND                   *\n*                               +4 - INVALID LABEL                    *\n*                               +8 - TOO LONG                         *\n*                              +12 - PREDEFINED LABEL + R7            *\n*                                    (NAME IS IN 'LBLF')              *\n*                              +16 - LABEL PROCESSED + NOT FOUND      *\n*                                    (NAME IS IN 'LBLF')              *\n***********************************************************************\nLABEL    CLI   0(R3),C'0'          FIRST CHAR NUMERIC?\n         BNL   4(R14)              YES, INVALID -------------------> +4\n         CLI   0(R3),C'A'          FIRST CHAR ALPHA?\n         BNL   LABEL1              YES\n         CLI   0(R3),C'$'          DOLLAR SIGN?\n         BE    LABEL1              YES\n         CLI   0(R3),C'#'          NUMBER SIGN?\n         BE    LABEL1              YES\n         CLI   0(R3),C'@'          AT SIGN?\n         BNE   4(R14)              NO, INVALID --------------------> +4\nLABEL1   LR    R2,R3               START OF LABEL\nLABEL2   BXLE  R3,R4,*+L'*+4       INC PTR\n         B     LABEL3\n         CLI   0(R3),C' '          END OF LABEL?\n         BE    LABEL3              YES\n         CLI   0(R3),C'/'          END OF LABEL BY /?\n         BE    LABEL3              YES\n         CLI   0(R3),C'+'          END OF LABEL BY +?\n         BE    LABEL3              YES\n         CLI   0(R3),C'-'          END OF LABEL BY -?\n         BNE   LABEL2              NO\nLABEL3   LR    R1,R3               TURN TO WK REG\n         SR    R1,R2               GET NO OF CHAR SCANNED\n         BNPR  R14                 SKIP MOVE IF ZERO --------------> +0\n         CH    R1,=H'8'\n         BH    8(R14)              SKIP MOVE IF INVALID LABEL -----> +8\n         MVC   LBLF(L'LBLF),ALLBLKS     CLEAR WORK AREA\n         BCT   R1,*+L'*+6          DECR. BY 1\n         MVC   LBLF(*-*),0(R2)     <<EXECUTED>>\n         EX    R1,*-6              MOVE TO WORK AREA\n         LA    R14,12(R14)         ADJUST RETURN\nSCITBL   LM    R7,R9,SCFIX         SCAN PREDEFINED LABELS TABLE\n         CLC   0(L'LBLF,R7),LBLF\n         BER   R14                 EXIT -----------------------> +12/+0\n         BXLE  R7,R8,*-8\n         B     4(R14)              EXIT -----------------------> +16/+4\n         EJECT\n***********************************************************************\n*        SUBROUTINE TO EXTRACT A NAME (MAX. LENGTH 8).                *\n*        REGISTERS USE : R1 - WORK REGISTER / NO. OF CHAR. -1         *\n*                        R2 - WORK REGISTER                           *\n*                        R3-R4-R5 - ANSWER SCAN REGISTERS             *\n*                        R14 - LINK REGISTER                          *\n*                               +0 - NO NAME FOUND                    *\n*                               +4 - INVALID NAME                     *\n*                               +8 - TOO LONG                         *\n*                              +12 - NAME PROCESSED                   *\n*                                    (NAME IS IN 'NMEF')              *\n***********************************************************************\nNAME     CLI   0(R3),C'*'          FIRST CHAR *?\n         BE    NAME1               YES, VALID\nNAMER    CLI   0(R3),C'0'          FIRST CHAR NUMERIC?\n         BNL   4(R14)              YES, INVALID -------------------> +4\n         CLI   0(R3),C'A'          FIRST CHAR ALPHA?\n         BNL   NAME1               YES\n         CLI   0(R3),C'$'          DOLLAR SIGN?\n         BE    NAME1               YES\n         CLI   0(R3),C'#'          NUMBER SIGN?\n         BE    NAME1               YES\n         CLI   0(R3),C'@'          AT SIGN?\n         BNE   4(R14)              NO, INVALID --------------------> +4\nNAME1    LR    R2,R3               START OF NAME\n         BXLE  R3,R4,*+L'*+4       INC PTR\n         B     *+L'*+8\n         CLI   0(R3),C' '          END OF NAME?\n         BNE   *-12                NO\n         LR    R1,R3               TURN TO WK REG\n         SR    R1,R2               GET NO OF CHAR SCANNED\n         BNPR  R14                 SKIP MOVE IF ZERO --------------> +0\n         CH    R1,=H'8'\n         BH    8(R14)              SKIP MOVE IF INVALID NAME ------> +8\n         MVC   NMEF(L'NMEF),ALLBLKS     CLEAR WORK AREA\n         BCT   R1,*+L'*+6          DECR. BY 1\n         MVC   NMEF(*-*),0(R2)     <<EXECUTED>>\n         EX    R1,*-6              MOVE TO WORK AREA\n         B     12(R14)             EXIT --------------------------> +12\n         EJECT\n***********************************************************************\n*        SUBROUTINE TO SCAN LABELS TABLE.                             *\n*        REGISTERS USE : R7-R8-R9 - LABELS TABLE SCAN REGISTERS       *\n*                        R14 - LINK REGISTER                          *\n***********************************************************************\nSCLTBL   CLC   TBVAL+8(4),TBVAL\n         BL    ERR19\n         LM    R7,R9,TBVAL         SCAN LABELS TABLE\n         CLC   0(L'LBLF,R7),LBLF\n         BER   R14\n         BXLE  R7,R8,*-8\n         B     ERR20\n         SPACE 2\n***********************************************************************\n*        SUBROUTINE TO POSITION ON NEXT CHARACTER.                    *\n*        REGISTERS USE : R3-R4-R5 - ANSWER SCAN REGISTERS             *\n*                        R14 - LINK REGISTER                          *\n*                              +0 - NO CHARACTER FOUND                *\n*                              +4 - NEXT CHARACTER POINTED            *\n***********************************************************************\nNEXT     CLR   R3,R5               NO MORE CHAR?\n         BHR   R14                 YES, LIKE NO CHARACTER FOUND ---> +0\n         CLI   0(R3),C' '          IS THIS CHAR BLANK?\n         BNE   4(R14)              NO, OK POINTED -----------------> +4\nNEXTCH   BXLE  R3,R4,*-8           BUMP POINTER\n         BR    R14                 NO CHARACTER FOUND -------------> +0\n         EJECT\n***********************************************************************\n*        I/O ROUTINE (WTO/WTOR OR TPUT/TGET AND FULL SCREEN).         *\n*        REGISTERS USE : R0 - WORK REGISTER                           *\n*                        R1 - WTO(R) LIST / WORK REGISTER             *\n*                        R2 - ALTERNATE SCREEN ADDRESS                *\n*                        R3 - ALTERNATE SCREEN LENGTH                 *\n*                        R4 - ALTERNATE SCREEN INPUT                  *\n*                        R14-R15 - WORK REGISTERS                     *\n*                        R8 - LINK REGISTER                           *\n***********************************************************************\nSEND     TM    STATUS,TSORUN\n         BO    STSO\n*        --------------------------------------------------------------\n*        WTO/WTOR PROCESSING.\n*        --------------------------------------------------------------\n         CLI   0(R1),0             REPLY?\n         BNE   SENDR               YES\n         TM    HCPRSW,HCCOPY       IS HARDCOPY ACTIVE?\n         BZ    *+L'*+6             NO\n         L     R15,=A(HCOPYSC)     HARDCOPY LINE\n         BASR  R14,R15\n        WTO    MF=(E,(1))\n         BR    R8\nSENDR    L     R14,4(R1)           ECB\n         TM    OPERSW,INPEND       INPUT IS ALREADY PENDING?\n         BZ    SENDM               NO\n         TM    OPERSW,FFSTUP       FIND FULL UPDATE?\n         BZ    *+L'*+12            NO\n         NI    OPERSW,255-FFSTUP\n         USING ECB,R14\n         TM    ECBCC,ECBPOST       REPLY HAS COMPLETED?\n         BZ    SENDF               NO\n         DROP  R14\n         NI    OPERSW,255-INPEND\n         ST    R14,SVAD\n         B     SENDW\nSENDM    XC    0(4,R14),0(R14)\n         ST    R14,SVAD\n         XR    R14,R14\n         IC    R14,8(R1)           REPLY LENGTH\n         BCTR  R14,0\n         BCTR  R14,0\n         ICM   R15,B'1111',0(R1)   REPLY AREA\n         MVI   0(R15),C' '\n         EX    R14,SCLR\n        WTOR   MF=(E,(1))\n         TM    OPERSW,FFSTUP       FIND FULL UPDATE?\n         BZ    SENDW               NO\n         OI    OPERSW,INPEND       SAY INPUT PENDING\n         NI    OPERSW,255-FFSTUP\nSENDF    L     R10,=A(FIND)        BACK TO FIND FULL\n         USING FIND,R10\n         B     FNFLC\n         DROP  R10\nSENDW    L     R1,SVAD\n        WAIT   ECB=(1)\n         TM    HCPRSW,HCCOPY       IS HARDCOPY ACTIVE?\n         BZR   R8                  NO\n         OI    HCPRSW,HCANSR\n         L     R15,=A(HCOPYSC)     HARDCOPY COMMAND\n         BASR  R14,R15\n         BR    R8\n         SPACE 1\n*        --------------------------------------------------------------\n*        TPUT/TGET PROCESSING.\n*        --------------------------------------------------------------\n         SPACE 1\nSTSO     TM    FSCRSW,FSCRSF       FULL SCREEN?\n         BO    FSC                 YES\n         CLI   0(R1),0             REPLY?\n         BNE   STSOR               YES\n         LH    R0,0(R1)\n         SH    R0,=H'4'\n         LA    R1,4(R1)\n         TM    HCPRSW,HCCOPY       IS HARDCOPY ACTIVE?\n         BZ    *+L'*+6             NO\n         L     R15,=A(HCOPYSC)     HARDCOPY LINE\n         BASR  R14,R15\n        TPUT   (1),(0)\n         TM    STATUS,TESTRUN\n         BZR   R8\n         NI    OPERSW,255-INPEND\n         BR    R8\nSTSOR    ST    R1,SVAD\n         TM    STATUS,TESTRUN\n         BZ    *+L'*+8\n         TM    OPERSW,INPEND       INPUT IS ALREADY PENDING?\n         BZ    *+L'*+8             NO\n         NI    OPERSW,255-INPEND\n         B     STBK+L'STBK\n         XR    R0,R0\n         IC    R0,9(R1)\n         SH    R0,=H'4'\n         LA    R1,12(R1)\n        TPUT   (1),(0)\nSTBK     L     R1,SVAD\n         XR    R14,R14\n         IC    R14,8(R1)           REPLY LENGTH\n         BCTR  R14,0\n         BCTR  R14,0\n         ICM   R15,B'1111',0(R1)   REPLY AREA\n         MVI   0(R15),C' '\n         EX    R14,SCLR\n         LA    R0,1(R14)\n         LR    R1,R15\n         TM    OPERSW,FFSTUP       FIND FULL UPDATE?\n         BZ    STSON               NO\n         NI    OPERSW,255-FFSTUP   YES\n        TGET   (1),(0),NOWAIT\n         LTR   R15,R15             ANY INPUT AVAILABLE?\n         BZ    STSOI               YES, INTERRUPT\n         CH    R15,=H'4'           NORMAL NOWAIT?\n         BNE   STSOA               NO, INTERRUPT\n         TM    STATUS,TESTRUN\n         BZ    *+L'*+4\n         OI    OPERSW,INPEND       YES, SAY INPUT PENDING\n         L     R10,=A(FIND)        CONTINUE FIND FULL\n         USING FIND,R10\n         B     FNFLC\n         DROP  R10\nSTSON   TGET   (1),(0)\n         LTR   R15,R15\n         BNZ   STSOA\nSTSOI    TM    HCPRSW,HCCOPY       IS HARDCOPY ACTIVE?\n         BZR   R8                  NO\n         OI    HCPRSW,HCANSR\n         L     R15,=A(HCOPYSC)     HARDCOPY COMMAND\n         BASR  R14,R15\n         BR    R8\nSTSOA    CH    R15,=H'12'\n         BE    CLRIQ\n         ST    R15,RETCC\n         B     FINISH\nCLRIQ   TCLEARQ INPUT\n        TPUT   TSRTL,L'TSRTL\n         B     STBK\nSCLR     MVC   1(*-*,R15),0(R15)   <<EXECUTED>>\n         SPACE 1\n*        --------------------------------------------------------------\n*        FULL SCREEN TPUT/TGET PROCESSING.\n*        --------------------------------------------------------------\n         SPACE 1\nFSC      CLI   0(R1),0             REPLY?\n         BNE   FSC10               YES\n         LH    R14,0(R1)\n         SH    R14,=H'4'\n         BNPR  R8\n         BCTR  R14,0\n         LA    R1,4(R1)\n         TM    FSCRSW,FSCRSL       DATA LINE?\n         BO    FSC1                YES\n         TM    FSCRSW,FSCRST       STATUS LINE?\n         BO    FSC2                YES\n         CH    R14,=H'79'\n         BNH   *+L'*+4\n         LH    R14,=H'79'\n         EX    R14,FSCMVM\n         BR    R8\nFSCMVM   MVC   FSCRMSG(*-*),0(R1)  <<EXECUTED>>\nFSC1     LA    R15,FSCRLNS\n         B     FSC3\nFSC2     LA    R15,FSCRLST\nFSC3     L     R0,FSPOINT\n         ALR   R15,R0\n         CH    R14,=H'78'\n         BNH   *+L'*+4\n         LH    R14,=H'78'\n         TM    FSCRSW,FSCRSI       INTENSIVE LINE REQUEST?\n         BZ    FSC4                NO\n        $FS    SF=(PROT,INT),MF=(I,(R15))\n         NI    FSCRSW,255-FSCRSI\nFSC4     EX    R14,FSCMVL\n         AH    R0,=H'81'\n         ST    R0,FSPOINT\n         BR    R8\nFSCMVL   MVC   2(*-*,R15),0(R1)    <<EXECUTED>>\nFSC10    TM    FSCRSW,FSCRSH       HELP PANEL TO DISPLAY?\n         BZ    *+L'*+8             NO\n         NI    FSCRSW,255-FSCRSH\n         B     *+L'*+12\n         LA    R2,FSCREEN\n         LA    R3,FSCRLNG\n         LA    R4,FSCRTXT\n         TM    FSCRSW,FSCRSS+FSCRSR     FIRST TPUT DONE?\n         BNO   FSC11               YES\n        $FS    CC=EW,MF=(I,(R2))   SET ERASE/WRITE\nFSC11    TM    OPERSW,FFSTUP       FIND FULL UPDATE?\n         BZ    FSC12               NO\n         LA    R1,2(R2)\n        $FS    WCC=(KBR),MF=(I,(R1))\n         LA    R3,FSCRLNW          PRESERVE COMMAND INPUT AREA\n        TPUT   (R2),(R3),FULLSCR\n         LA    R1,2(R2)\n        $FS    WCC=(KBR,RMDT),MF=(I,(R1))\n         B     FSC13\nFSC12   TPUT   (R2),(R3),FULLSCR\nFSC13    TM    FSCRSW,FSCRSS+FSCRSR     FIRST TPUT DONE?\n         BNO   FSC14          YES\n        $FS    CC=W,MF=(I,(R2))    RESTORE WRITE\n         NI    FSCRSW,255-FSCRSS   SAY FIRST TPUT DONE\nFSC14    TM    HCPRSW,HCCOPY       IS HARDCOPY ACTIVE?\n         BZ    *+L'*+6             NO\n         L     R15,=A(HCOPYSC)     HARDCOPY SCREEN\n         BASR  R14,R15\n         XC    0(FSRPLYL,R4),0(R4)\n         XC    FSCODE(REPLYL),FSCODE\n         TM    OPERSW,FFSTUP       FIND FULL UPDATE?\n         BZ    FSC15               NO\n         NI    OPERSW,255-FFSTUP   YES\n        TGET   FSCODE,REPLYL-1,ASIS,NOWAIT   DON'T WAIT FOR REPLY\n         LTR   R15,R15             ANY INPUT AVAILABLE?\n         BZ    FSC22               YES, INTERRUPT\n         CH    R15,=H'4'           NORMAL NOWAIT?\n         BNE   FSC16               NO, INTERRUPT\n         L     R10,=A(FIND)        YES, CONTINUE FIND FULL\n         USING FIND,R10\n         B     FNFLC\n         DROP  R10\nFSC15   TGET   FSCODE,REPLYL-1,ASIS     WAIT FOR REPLY\nFSC16    CH    R15,=H'12'          INPUT LONGER THAN BUFFER?\n         BNE   FSC20               NO, CONTINUE\n        TCLEARQ INPUT              CLEAR THE QUEUE\n         XR    R15,R15             RESET RC\nFSC20    LTR   R15,R15             INPUT OK?\n         BZ    *+L'*+8             YES\n         ST    R15,RETCC\n         B     FSC26\n         CLI   FSCODE,X'6E'        PA2? (RESHOW)\n         BE    FSC21               YES\n         CLI   FSCODE,X'7C'        PF 12 ENTERED?\n         BE    FSC21               YES\n         CLI   FSCODE,X'4C'        PF 24 ENTERED (ALT. PF 12)?\n         BNE   FSC22               NO\nFSC21    MVC   0(FSRPLYL,R4),LSTDSP     YES, RE-DISPLAY LAST SCREEN\n         B     FSC11               WITH THE LAST DISPLAY INPUT COMMAND\nFSC22    MVC   FSCRMSG,ALLBLKS\n         CLI   FSCODE,X'F1'        PF 1 ENTERED?\n         BE    *+L'*+8             YES\n         CLI   FSCODE,X'C1'        PF 13 ENTERED (ALT. PF 1)?\n         BNE   *+L'*+10            NO\n         MVC   FSTEXT(3),=CL3'H  '\n         B     FSC40\n         CLI   FSCODE,X'F2'        PF 2 ENTERED?\n         BE    *+L'*+8             YES\n         CLI   FSCODE,X'C2'        PF 14 ENTERED (ALT. PF 2)?\n         BNE   *+L'*+10            NO\n         MVC   FSTEXT(3),=CL3'X H'\n         B     FSC40\n         CLI   FSCODE,X'7A'        PF 10 ENTERED?\n         BE    *+L'*+8             YES\n         CLI   FSCODE,X'4A'        PF 22 ENTERED (ALT. PF 10)?\n         BNE   *+L'*+10            NO\n         MVC   FSTEXT(3),=CL3'H L'\n         B     FSC40\n         CLI   FSCODE,X'7B'        PF 11 ENTERED?\n         BE    *+L'*+8             YES\n         CLI   FSCODE,X'4B'        PF 23 ENTERED (ALT. PF 11)?\n         BNE   *+L'*+10            NO\n         MVC   FSTEXT(3),=CL3'H M'\n         B     FSC40\n         CLI   FSCODE,X'F5'        PF 5 ENTERED?\n         BE    *+L'*+8             YES\n         CLI   FSCODE,X'C7'        PF 17 ENTERED (ALT. PF 5)?\n         BNE   FSC24               NO\n         TM    SWITCH,POPXMR\n         BO    *+L'*+10\n         MVC   FSTEXT(3),=CL3'F  '\n         B     FSC23\n         MVC   FSTEXT(3),=CL3'X F'\nFSC23    XC    FSTEXT+3(L'FSTEXT-3),FSTEXT+3\n         B     FSC30\nFSC24    CLI   FSCODE,X'F6'        PF 6 ENTERED?\n         BE    *+L'*+8             YES\n         CLI   FSCODE,X'C6'        PF 18 ENTERED (ALT. PF 6)?\n         BNE   FSC25               NO\n         TM    SWITCH,POPXMR\n         BO    *+L'*+10\n         MVC   FSTEXT(3),=CL3'G  '\n         B     FSC23\n         MVC   FSTEXT(3),=CL3'X G'\n         B     FSC23\nFSC25    CLI   FSCODE,X'F3'        PF 3 ENTERED?\n         BE    FSC26               YES\n         CLI   FSCODE,X'C3'        PF 15 ENTERED (ALT. PF 3)?\n         BE    FSC26               YES\n         CLI   FSCODE,X'F4'        PF 4 ENTERED?\n         BE    FSC26               YES\n         CLI   FSCODE,X'C4'        PF 16 ENTERED (ALT. PF 4)?\n         BNE   *+L'*+10            NO\nFSC26    MVC   FSTEXT(3),=CL3'END'\n         B     FSC40\n         CLI   FSCODE,X'F7'        PF 7 ENTERED?\n         BE    *+L'*+8             YES\n         CLI   FSCODE,X'C7'        PF 19 ENTERED (ALT. PF 7)?\n         BNE   *+L'*+10            NO\n         MVC   FSTEXT(5),=CL5'- 128'\n         B     FSC27\n         CLI   FSCODE,X'F8'        PF 8 ENTERED?\n         BE    *+L'*+8             YES\n         CLI   FSCODE,X'C8'        PF 20 ENTERED (ALT. PF 8)?\n         BNE   FSC30               NO\n         MVC   FSTEXT(5),=CL5'+ 128'\nFSC27    XC    FSTEXT+5(L'FSTEXT-5),FSTEXT+5\nFSC30    LA    R14,FSCRLNS\n         LA    R15,16              RESET LINES 5 TO 20\nFSC31   $FS    SF=(PROT),MF=(I,(R14))\n         MVC   2(79,R14),ALLBLKS\n         LA    R14,81(R14)\n         BCT   R15,FSC31\n         LA    R14,FSCRLST\n         LA    R15,3               RESET LINES 22 TO 24\nFSC32   $FS    SF=(PROT),MF=(I,(R14))\n         MVC   2(79,R14),ALLBLKS\n         LA    R14,81(R14)\n         BCT   R15,FSC32\n         MVC   FSCRSCL(L'FSCRSCL),ALLBLKS    RESET SCALING\n        $FS    SF=(PROT),MF=(I,FSCRSDC)\n         MVC   FSCRTDC(L'FSCRTDC),ALLBLKS    RESET DATA CONTINUE\n         B     FSC40+L'FSC40\nFSC40    XC    FSTEXT+3(L'FSTEXT-3),FSTEXT+3\n         MVC   ANSR(L'ANSR),ALLBLKS\n         OC    ANSR(L'FSTEXT),FSTEXT\n         BR    R8                  RETURN TO CALLER\n         EJECT\n***********************************************************************\n***********************************************************************\n***      DANGEROUS ROUTINES : ENABLE/DISABLE ACTIVE/DEACTIV.        ***\n***      REGISTERS USE : R0-R1-R14-R15 - WORK REGISTERS             ***\n***                      R8 - LINK REGISTER                         ***\n***********************************************************************\n***********************************************************************\n         SPACE 1\nENABLE  $HEDIT\n***********************************************************************\n*        WHEN IN SUPERVISOR MODE OR X-MEM REF. MODE :                 *\n*              R6 = START ADDRESS TO BE ACCESSED                      *\n*              R2 = NUMBER OF BYTES TO BE ACCESSED (FIELD LENGTH)     *\n*        RETURN TO CALLER :                                           *\n*              R8 - LINK REGISTER +0 = X-MEM REF. MODE                *\n*                                 +4 = PROBLEM OR SUPERVISOR MODE     *\n***********************************************************************\n         SPACE 1\n         TM    STATUS,TESTRUN\n         BZ    ENBLE1+L'ENBLE1\n         CLI   RCVIND,C' '\n         BE    ENBLE1+L'ENBLE1\n         LA    R0,L'RCVIND-1\n         LA    R1,RCVIND+L'RCVIND-2\n         MVC   1(1,R1),0(R1)\n         BCTR  R1,0\n         BCT   R0,*-8\nENBLE1   MVI   RCVIND,C' '\n         L     R1,=A(ESPLST)\n        ESPIE  SET,MF=(E,(1))      INTERCEPT 0C4\n         ST    R1,OLDPICA          OLD PICA ADDRESS\n         TM    STATUS,DANGER\n         BZ    4(R8)               EXIT ---------------------------> +4\n        ZEROKEY ,                  ENTER SYSTEM MODE\n         TM    SWITCH,ACTIVM+XMEMRF     ACTIVE MODE + X-MEM.REF.?\n         BO    ENBLE5              YES\n         XR    R1,R1\n         TPROT 0(R6),0(R1)         TEST PROTECTION/TRANSLATION\n         BZ    ENBLE4              OK\n         BP    RECOVER2            NO ACCESS, SHOW 0C4\n         BO    RECOVER3            NO TRANSLATION, SHOW 0C4\n         CLI   PRVOP,C'S'          ONLY FETCH, IS IT A STORE REQUESTED?\n         BE    RECOVER1            YES, BUT PROTECTED, SO SHOW 0C4\nENBLE4   TM    SWITCH,TSTEAP       END ADDRESS PROTECTION REQUESTED?\n         BZ    4(R8)               NO, EXIT -----------------------> +4\n         LR    R0,R6\n         ALR   R6,R2               COMPUTE END ADDRESS\n         BCTR  R6,0\n         TPROT 0(R6),0(R1)         TEST PROTECTION/TRANSLATION\n         LR    R6,R0\n         BZ    4(R8)               OK, EXIT -----------------------> +4\n         BP    RECOVER5            NO ACCESS, SHOW 0C4\n         BO    RECOVER6            NO TRANSLATION, SHOW 0C4\n         CLI   PRVOP,C'S'          ONLY FETCH, IS IT A STORE REQUESTED?\n         BE    RECOVER4            YES, BUT PROTECTED, SO SHOW 0C4\n         B     4(R8)               NO, EXIT -----------------------> +4\nENBLE5   L     R1,CVTPTR           POINT TO CVT\n         USING CVT,R1\n         L     R14,CVTASVT         POINT TO ASVT\n         DROP  R1\n         L     R1,WASID            GET SECONDARY WORK AS-ID\n         USING ASVT,R14\n         C     R1,ASVTMAXU         IS AS-ID TOO BIG?\n         BH    ERR29               YES\n         SLL   R1,2                (AS-ID)*4\n         LA    R1,ASVTENTY-4(R1)   POINT AT ENTRY\n         TM    0(R1),ASVTAVAL      IS IT AVAILABLE?\n         BO    ERR30               NO\n         DROP  R14\n         L     R15,0(R1)           POINT TO ASCB\n         USING ASCB,R15\n         TM    ASCBRCTF,ASCBOUT    IS ASCB SWAPPED OUT?\n         BO    ERR31               YES\n         DROP  R15\n         L     R15,ACSQA           COMMON SQA AREA\n         LTR   R15,R15             ALREADY BUILDED?\n         BNZ   ENBLE6              YES\n        GETMAIN R,LV=CSQAL,SP=226  NO, GET IT\n         ST    R1,ACSQA            START ADDRESS\n         MVC   0(CSQALL,R1),CSQATXT     MOVE IN INSTRUCTIONS DATA\n         LR    R15,R1              SET HIS ADDRESSABILITY\n         OI    SWITCH,CSQAF        SET SQA AREA ACQUIRED\nENBLE6   L     R1,WASID            GET SECONDARY WORK AS-ID\n         SSAR  R1                  SET IT AS SECONDARY\n         LA    R0,2\n         XR    R1,R1\n         BASR  R14,R15             TEST ACCESS TO SECONDARY AS-ID\n         LTR   R0,R0               WHAT ABOUT PROTECTION?\n         BZ    ENBLE7              OK\n         BM    *+L'*+8             ONLY FETCH\n         BCT   R0,RECOVER9         NO TRANSLATION, SHOW 0C4\n         B     RECOVER8            NO ACCESS, SHOW 0C4\n         CLI   PRVOP,C'S'          IS IT A STORE REQUESTED?\n         BE    RECOVER7            YES, BUT PROTECTED, SO SHOW 0C4\nENBLE7   TM    SWITCH,TSTEAP       END ADDRESS PROTECTION REQUESTED?\n         BZR   R8                  NO, EXIT -----------------------> +0\n         ST    R6,SVSADD\n         ALR   R6,R2               COMPUTE END ADDRESS\n         BCTR  R6,0\n         LA    R0,2\n         XR    R1,R1\n         BASR  R14,R15             TEST ACCESS TO SECONDARY AS-ID\n         L     R6,SVSADD\n         LTR   R0,R0               WHAT ABOUT PROTECTION?\n         BZR   R8                  OK, EXIT -----------------------> +0\n         BM    *+L'*+8             ONLY FETCH\n         BCT   R0,RECOVERC         NO TRANSLATION, SHOW 0C4\n         B     RECOVERB            NO ACCESS, SHOW 0C4\n         CLI   PRVOP,C'S'          IS IT A STORE REQUESTED?\n         BE    RECOVERA            YES, BUT PROTECTED, SO SHOW 0C4\n         BR    R8                  EXIT ---------------------------> +0\n         SPACE 1\nRECOVER1 BAS   R8,RECOVERS\nRECOVER2 BAS   R8,RECOVERS\nRECOVER3 BAS   R8,RECOVERS\nRECOVER4 BAS   R8,RECOVERS\nRECOVER5 BAS   R8,RECOVERS\nRECOVER6 BAS   R8,RECOVERS\nRECOVER7 BAS   R8,RECOVERS\nRECOVER8 BAS   R8,RECOVERS\nRECOVER9 BAS   R8,RECOVERS\nRECOVERA BAS   R8,RECOVERS\nRECOVERB BAS   R8,RECOVERS\nRECOVERC BAS   R8,RECOVERS\nRECOVERS TM    STATUS,TESTRUN\n         BZ    RECOVER\n         LA    R1,RECOVERS\n         LA    R8,0(R8)\n         SLR   R1,R8\n         SRL   R1,2\n         STC   R1,RCVIND           SET RECOVER INDICATOR\n         TR    RCVIND(1),=C'CBA987654321'\n         B     RECOVER\n         SPACE 1\nPRMODE   EQU   X'000'              PRIMARY A.S. MODE\nSCMODE   EQU   X'100'              SECONDARY A.S. MODE\n         USING *,R15\nCSQATXT  SAC   SCMODE              SET A.S. CONTROL TO SECONDARY\n         TPROT 0(R6),0(R1)         TEST PROTECTION/TRANSLATION\n         BZ    *+L'*+10            FETCH + STORE (R0=0)\n         BP    *+L'*+8             NONE (R0=+1)\n         BO    *+L'*+6             NO TRANSLATION (R0=+2)\n         BCTR  R0,0                ONLY FETCH (R0=-1)\n         BCTR  R0,0\n         BCTR  R0,0\n         SAC   PRMODE              RESTORE A.S. CONTROL TO PRIMARY\n         BR    R14                 BACK TO CALLER\n         DROP  R15\nCSQALL   EQU   *-CSQATXT           LENGTH\nCSQAL    EQU   ((CSQALL+7)/8)*8    GETMAIN/FREEMAIN LENGTH\n         EJECT\nDISABLE $HEDIT\n         NI    SWITCH,255-TSTEAP   RESET E.A. PROT. REQUEST\n         TM    STATUS,DANGER\n         BZ    DSBLE2\n         TM    SWITCH,ACTIVM+XMEMRF     ACTIVE MODE + X-MEM.REF.?\n         BNO   DSBLE1              NO\n         L     R1,SASID            RESTORE SECONDARY AS-ID\n         SSAR  R1                  SHOULD BE AS PRIMARY\n         NI    SWITCH,255-XMEMRF   RESET X-MEM. REF. REQUEST\nDSBLE1  RESETKEY ,                 RESTORE PROBLEM MODE\nDSBLE2  ESPIE  RESET,OLDPICA       RESTORE SPIE/ESPIE ENVIRONMENT\n         BR    R8\n         EJECT\nACTIVE  $HEDIT ACTIVE\n         TM    SWITCH,ACTIVM       ALREADY ACTIVE MODE?\n         BOR   R8                  YES, GO BACK, DON'T DO IT TWICE\n         XC    WASID,WASID         SET SECONDARY WORK AS-ID\n         MVC   WASID+2(L'ASIDN),ASIDN\n        ZEROKEY ,                  ENTER SYSTEM MODE\n         MVC   AXPL,=XL4'00010000'\n        AXRES  AXLIST=AXPL\n         ST    R15,RCXR            SAVE RC\n         LTR   R15,R15             SUCCESSFULL?\n         BNZ   ACTIVE1             NO, GO BACK\n         L     R0,=F'1'            FULLY AUTHORIZED AX\n        AXSET  AX=(0)              SET AX TO ALLOW IT AS 2ND\n         ST    R15,RCXS            SAVE RC\n         LTR   R15,R15             SUCCESSFULL?\n         BNZ   ACTIVE1             NO, GO BACK\n         OI    SWITCH,ACTIVM       ACTIVE MODE READY\nACTIVE1 RESETKEY ,                 RESTORE PROBLEM MODE\n         TM    SWITCH,ACTIVM       ACTIVE MODE SET?\n         BOR   R8                  YES\n         L     R15,=A(FSCLEAR)\n         BASR  R8,R15              RESET FULL SCREEN IF APPLY\n         OC    RCXR,RCXR           AXRES FAILED?\n         BZ    ACTIVE2             NO, IT IS AXSET\n        @SEND  XRFAIL\n         L     R1,=A(DISRC)\n         UNPK  19(9,R1),RCXR(5)\n         B     EXIT                GO DISPLAY R15 (RC)\nACTIVE2 @SEND  XSFAIL\n         L     R1,=A(DISRC)\n         UNPK  19(9,R1),RCXS(5)\n         B     EXIT                GO DISPLAY R15 (RC)\n         EJECT\nDEACTIV $HEDIT DEACTIV\n         TM    SWITCH,ACTIVM       ACTIVE MODE?\n         BZR   R8                  NO, GO BACK, NOTHING TO DO\n        ZEROKEY ,                  ENTER SYSTEM MODE\n        AXFRE  AXLIST=AXPL         FREE AX\n         ST    R15,RCXF            SAVE RC\n        RESETKEY ,                 RESTORE PROBLEM MODE\n         NI    SWITCH,255-ACTIVM   RESET ACTIVE MODE\n         XC    WASID,WASID         ZEROES WORK AS-ID\n         OC    RCXF,RCXF           AXFRE FAILED?\n         BZR   R8                  NO\n         L     R15,=A(FSCLEAR)\n         BASR  R8,R15              RESET FULL SCREEN IF APPLY\n        @SEND  XFFAIL\n         L     R1,=A(DISRC)\n         UNPK  19(9,R1),RCXF(5)\nEXIT     TR    19(8,R1),HEXTAB-X'F0'\n         MVI   27(R1),C' '\n        @SEND  OP=NONE\n         B     FINISH              ABORT PROCESS\n         EJECT\n***********************************************************************\n*        LITERAL POOL.                                                *\n***********************************************************************\n         SPACE 1\n        LTORG\n         SPACE 1\n*--- --- END OF BASE REGISTER (R12) ADDRESSING --- --- --- --- --- ---*\n         EJECT\nVCINIT  @INIT  INITIAL\n         SPACE 1\n***********************************************************************\n*        CONTROL CALLER AUTHORITY AND ENVIRONMENT.                    *\n***********************************************************************\n        $EACM  REQAUT              GET USER AUTHORITY\n         CLI   AUTH,LV1            AUTHORIZED?\n         BNL   OKAUTH              YES\n        @SEND  UNAUT\n         B     FINISH\nOKAUTH  EXTRACT ATSO,'S',FIELDS=(TSO)\n         L     R1,ATSO\n         TM    0(R1),X'80'         CALLED IN TSO?\n         BZ    INMSG               NO\n         OI    STATUS,TSORUN       YES\n        GTSIZE ,                   GET TERMINAL SIZE\n         LTR   R0,R0               IS IT A SCREEN?\n         BZ    INMSG               IF ZERO, NOT A SCREEN\n         CH    R0,=H'24'           STANDARD NUMBER OF LINES?\n         BL    INMSG               LESS\n         BE    TSTLNL              YES\n         CH    R1,=H'80'           STANDARD LINE LENGTH?\n         BL    INMSG               LESS\n         B     SETSSZ\nTSTLNL   CH    R1,=H'80'           STANDARD LINE LENGTH?\n         BL    INMSG               LESS\n         BE    SETFSC              YES\nSETSSZ   ST    R0,SZSCRN           SAVE SCREEN SIZE\n         ST    R1,SZLINE           SAVE LINE SIZE\nSETFSC   OI    STATUS,TSORSC       SAY RUNNING IN TSO ON A SCREEN\n         L     R15,=A(FSSETFS)\n         BASR  R8,R15              SET FULL SCREEN\n         B     SETMODE\nINMSG   @SEND  INITM\n        @SEND  INITH\n         SPACE 2\n***********************************************************************\n*        SET MVS/XA AMODE.                                            *\n***********************************************************************\nSETMODE $TSWXA 31,EXPAND=ONLY      ENTER 31-BIT MODE\n         EJECT\n***********************************************************************\n*        RECOGNIZE MYSELF.                                            *\n***********************************************************************\n         USING PSA,R0\nMYSELF   L     R1,PSAAOLD\n         ST    R1,MYASCB\n         USING ASCB,R1\n         MVC   MYASIDN,ASCBASID    GET MY AS-ID NUMBER\n         L     R15,ASCBJBNI\n         LTR   R15,R15\n         BNZ   *+L'*+10\n         L     R15,ASCBJBNS\n         LTR   R15,R15\n         BZ    *+L'*+6\n         MVC   MYASNME(L'MYASNME),0(R15)     GET MY AS-NAME\n         DROP  R0,R1\n        ZEROKEY ,                  ENTER SYSTEM MODE\n         ESAR  R1\n         ST    R1,SASID            GET SECONDARY AS-ID\n        RESETKEY ,                 RESTORE PROBLEM MODE\n         EJECT\n***********************************************************************\n*        SET PROGRAM SPACE BOUNDARIES.                                *\n***********************************************************************\n         L     R0,=V(VCOREZAH)\n         L     R1,BEGADD\n         CLR   R0,R1\n         BNL   *+L'*+2\n         LR    R1,R0\n         SRL   R1,4\n         SLL   R1,4\n         ST    R1,BEGADD\n         L     R0,=V(VCOREZHE)\n         L     R1,ENDADD\n         CLR   R0,R1\n         BNH   *+L'*+2\n         LR    R1,R0\n         LA    R1,15(R1)\n         SRL   R1,4\n         SLL   R1,4\n         ST    R1,ENDADD\n         SPACE 2\n***********************************************************************\n*        INITIALIZE TANKS USER-AREAS.                                 *\n***********************************************************************\n         LA    R1,NTKWAS\n         L     R3,ATKWAS\n         USING TKWA,R3\nINT1     XC    TKWPT,TKWPT\n         XC    TKWDL,TKWDL\n         XC    TKWTX,TKWTX\n         LA    R3,TKWAL(R3)\n         BCT   R1,INT1\n         DROP  R3\n         EJECT\n***********************************************************************\n*        INITIALIZE PREDEFINED LABELS TABLE.                          *\n***********************************************************************\n         LM    R3,R5,SCFIX\n         XR    R1,R1\n         BAS   R8,STFIX\n         DC    CL8'PSA'            PSA\n         USING PSA,R0\n         L     R1,PSAAOLD\n         BAS   R8,STFIX\n         DC    CL8'ASCB'           ASCB\n         DROP  R0\n         L     R2,CVTPTR\n         LR    R1,R2\n         BAS   R8,STFIX\n         DC    CL8'CVT'            CVT\n         USING CVT,R2\n         L     R1,CVTTCBP\n         L     R1,4(R1)\n         BAS   R8,STFIX\n         DC    CL8'TCB'            TCB\n         L     R1,CVTSMCA\n         BAS   R8,STFIX\n         DC    CL8'SMCA'           SMCA\n         L     R1,CVTABEND\n         BAS   R8,STFIX\n         DC    CL8'SCVT'           SCVT\n         L     R1,CVTMSER\n         BAS   R8,STFIX\n         DC    CL8'BASE'           BASE\n         L     R1,CVTIXAVL\n         BAS   R8,STFIX\n         DC    CL8'IOCOM'          IOCOM\n         L     R1,CVTGDA\n         BAS   R8,STFIX\n         DC    CL8'GDA'            GDA\n         L     R1,CVTCSD\n         BAS   R8,STFIX\n         DC    CL8'CSD'            CSD\n         L     R1,CVTPCCAT\n         BAS   R8,STFIX\n         DC    CL8'PCCAVT'         PCCAVT\n         L     R1,CVTLCCAT\n         BAS   R8,STFIX\n         DC    CL8'LCCAVT'         LCCAVT\n         DROP  R2\n         B     SRTFIX\n         SPACE 1\nSTFIX    MVC   0(L'LBLF,R3),0(R8)\n         STCM  R1,B'1111',L'LBLF(R3)\n         ST    R3,SCFIX+8\n         BXLE  R3,R4,8(R8)\nSRTFIX   L     R5,SCFIX            SORT LABELS\n         SR    R3,R5\n         XR    R2,R2\n         DR    R2,R4\n        $SORT  (R5),(R3),L'FIXTB,0,L'LBLF\n         B     INQUIRT\n         SPACE 1\n        @END   ,\n         EJECT\nVCEND   @INIT  LEAVE\n         SPACE 1\n***********************************************************************\n*        END OF PROCESS.                                              *\n***********************************************************************\n         BAS   R8,DEACTIV          RESET AS-ID MODE IF ANY\n         TM    SWITCH,CSQAF        SQA AREA ACQUIRED?\n         BZ    NOSQA               NO\n        ZEROKEY ,                  ENTER SYSTEM MODE\n         L     R1,ACSQA            COMMON SQA AREA\n        FREEMAIN R,A=(1),LV=CSQAL,SP=226     FREE IT\n        RESETKEY ,                 RESTORE PROBLEM MODE\nNOSQA    TM    HCPRSW,HCCOPY       IS HARDCOPY ACTIVE?\n         BZ    NOHCPY              NO\n         OI    HCPRSW,HCCLOSE      SAY CLOSE IT\n         L     R10,=A(HCPRTSS)     CLOSE HARDCOPY FILE\n         BR    R10\nNOHCPY  $TSWXA 24,EXPAND=ONLY      BACK TO 24-BIT\n         L     R15,=A(FSCLEAR)\n         BASR  R8,R15              RESET FULL SCREEN IF APPLY\n         TM    OPERSW,DRFDDS       DATA-SET ALREADY ENDED\n         BZ    EXRET               YES\n         LA    R1,=AL1(255)        NO, ENDS IT\n         L     R15,=V(DTUSE)\n         BASR  R14,R15\n         OC    RETCC,RETCC\n         BZ    EXRET+L'EXRET\n         B     EXRET\n         SPACE 1\n        @END   ,\n         EJECT\nENCMD   @INIT  COMMANDS\n         SPACE 1\n***********************************************************************\n*        ENTER A COMMAND.                                             *\n***********************************************************************\n         SPACE 1\n         TM    FSCRSW,FSCRSF       FULL SCREEN?\n         BZ    *+L'*+4             NO\n         NI    FSCRSW,255-FSCRSC-FSCRSH-FSCRST-FSCRSL-FSCRSI     RESET\n         CLI   0(R3),C'?'          INFO STATUS\n         BNE   *+L'*+6\n         L     R10,=A(INFST)\n         BR    R10\n         CLI   0(R3),C'B'          DSECTS INFO\n         BNE   *+L'*+6\n         L     R10,=A(BRWSE)\n         BR    R10\n         CLI   0(R3),C'H'          HELP\n         BNE   *+L'*+6\n         L     R10,=A(HELP)\n         BR    R10\n         CLI   0(R3),C'I'          INTERNAL\n         BNE   *+L'*+6\n         L     R10,=A(PRDEF)\n         BR    R10\n         CLI   0(R3),C'L'          LIST\n         BNE   *+L'*+8\n         L     R10,=A(PRDEF)\n         DROP  R10\n         USING PRDEF,R10\n         B     LIST\n         DROP  R10\n         USING ENCMD,R10\n         CLI   0(R3),C'M'          MEMORIZE\n         BNE   *+L'*+6\n         L     R10,=A(MMTK)\n         BR    R10\n         CLI   0(R3),C'Q'          DSECTS DATA-SET\n         BNE   *+L'*+8\n         L     R10,=A(BRWSE)\n         DROP  R10\n         USING BRWSE,R10\n         B     DSDST\n         DROP  R10\n         USING ENCMD,R10\n         CLI   0(R3),C'X'          MEM. X-REF\n         BNE   *+L'*+6\n         L     R10,=A(ASNID)\n         BR    R10\n         TM    STATUS,TESTRUN\n         BZ    *+L'*+6\n         MVC   RCVIND(L'RCVIND),ALLBLKS\n         CLI   0(R3),C'+'          FORWARD DISPLAY\n         BE    *+L'*+8\n         CLI   0(R3),C'-'          BACKWARD DISPLAY\n         BNE   *+L'*+8\n         L     R10,=A(DSPLY)\n         DROP  R10\n         USING DSPLY,R10\n         B     FBDSPL\n         DROP  R10\n         USING ENCMD,R10\n         NI    SWITCH,255-POPXMR-ASFULL RESET X-MEM. MODE AND A.S.\n         CLI   0(R3),C'F'          FIND\n         BNE   *+L'*+6\n         L     R10,=A(FIND)\n         BR    R10\n         NI    SWITCH,255-PVALID   RESET PREVIOUS LAST DATA\n         CLI   0(R3),C'A'          ASSIGN\n         BNE   *+L'*+6\n         L     R10,=A(ASSGN)\n         BR    R10\n         CLI   0(R3),C'C'          CONTROL\n         BNE   *+L'*+8\n         L     R10,=A(TEST)\n         DROP  R10\n         USING TEST,R10\n         B     CNTRL\n         DROP  R10\n         USING ENCMD,R10\n         CLI   0(R3),C'V'          VIEW\n         BNE   *+L'*+8\n         L     R10,=A(TEST)\n         DROP  R10\n         USING TEST,R10\n         B     SGVIEW\n         DROP  R10\n         USING ENCMD,R10\n         CLI   0(R3),C'D'          DISPLAY\n         BNE   *+L'*+6\n         L     R10,=A(DSPLY)\n         BR    R10\n         CLI   0(R3),C'E'          END\n         BE    FINISH\n         TM    FSCRSW,FSCRSF       FULL SCREEN?\n         BZ    *+L'*+16            NO\n         CLI   0(R3),C'G'          GET\n         BNE   *+L'*+8\n         L     R10,=A(DSPLY)\n         DROP  R10\n         USING DSPLY,R10\n         B     GBYTES\n         DROP  R10\n         USING ENCMD,R10\n         CLI   0(R3),C'P'          HARDCOPY\n         BNE   *+L'*+6\n         L     R10,=A(HCPRTSS)\n         BR    R10\n         CLI   0(R3),C'S'          STORE\n         BNE   *+L'*+6\n         L     R10,=A(STORE)\n         BR    R10\n         CLI   0(R3),C'T'          TEST\n         BNE   *+L'*+6\n         L     R10,=A(TEST)\n         BR    R10\n         CLI   0(R3),C'Z'          DELETE\n         BNE   *+L'*+8\n         L     R10,=A(ASSGN)\n         DROP  R10\n         USING ASSGN,R10\n         B     DELET\n         DROP  R10\n         USING ENCMD,R10\n         B     ERR1\n         SPACE 1\n        @END   ,\n         EJECT\nINFST   @INIT  INFO''S\n         SPACE 1\n***********************************************************************\n*        INFO STATUS REQUEST.                                         *\n***********************************************************************\n         SPACE 1\n         TM    FSCRSW,FSCRSF       FULL SCREEN?\n         BZ    *+L'*+10            NO\nINFST0   OI    FSCRSW,FSCRST       YES, SAY STATUS\n         XC    FSPOINT,FSPOINT\n         MVC   MSGTXT(L'MSGTXT),ALLBLKS\n         MVC   MSGTXT(7),=CL7'AS-ID ='\n         UNPK  MSGTXT+8(5),MYASIDN(3)\n         TR    MSGTXT+8(4),HEXTAB-X'F0'\n         MVC   MSGTXT+12(2),=CL2' ('\n         MVC   MSGTXT+14(L'MYASNME),MYASNME\n         MVC   MSGTXT+22(12),=CL12') : DISABLED'\n         TM    STATUS,DANGER\n         BZ    *+L'*+6\n         MVC   MSGTXT+26(8),=CL8'ENABLED '\n         MVC   MSGTXT+35(9),=CL9'/ SGT-OFF'\n         TM    SGTPSW,STPDIS+STPUSE     SEGMENT PROCESSING DISABLED?\n         BNZ   *+L'*+6             YES\n         MVC   MSGTXT+42(2),=CL2'N '\n         TM    STATUS,TESTRUN\n         BZ    *+L'*+6\n         MVC   MSGTXT+45(6),=CL6'/ TEST'\n         MVC   MSGTXT+54(7),=CL7'D-PT. ='\n         CLI   PRVOP,C'S'\n         BE    INFST1\n         UNPK  MSGTXT+62(9),CRPTR(5)\n         B     INFST2\nINFST1   MVC   MSGTXT+52(2),=CL2'F/'\n         UNPK  MSGTXT+62(9),PVPTR(5)\nINFST2   TR    MSGTXT+62(8),HEXTAB-X'F0'\n         MVI   MSGTXT+70,C' '\n        @SEND  MSGOUT,OP=LA\n         MVC   MSGTXT(L'MSGTXT),ALLBLKS\n         MVC   MSGTXT(10),=CL10'F-STRING ='\n         XR    R15,R15\n         IC    R15,STRNGL\n         TM    STATUS,FTYPE\n         BZ    INFST10\n         MVI   MSGTXT+11,C''''\n         LA    R1,MSGTXT+12\n         LA    R14,STRNG\n         EX    R15,INFSTMV\n         LA    R1,MSGTXT+13(R15)\n         MVI   0(R1),C''''\n         LA    R1,1(R1)\n         B     INFST11\nINFST10  UNPK  TBUF(15),STRNG(8)\n         UNPK  TBUF+14(15),STRNG+7(8)\n         UNPK  TBUF+28(5),STRNG+14(3)\n         TR    TBUF(32),HEXTAB-X'F0'\n         SLL   R15,1\n         LA    R15,1(R15)\n         LA    R14,TBUF\n         LA    R1,MSGTXT+11\n         EX    R15,INFSTMV\n         LA    R1,MSGTXT+12(R15)\nINFST11  TM    SWITCH,ASFULL\n         BZ    *+L'*+6\n         MVC   1(6,R1),=CL6'(FULL)'\n         MVC   MSGTXT+54(7),=CL7'S-PT. ='\n         CLI   PRVOP,C'S'\n         BE    INFST12\n         MVC   MSGTXT+52(2),=CL2'F/'\n         UNPK  MSGTXT+62(9),PVPTR(5)\n         B     INFST13\nINFST12  UNPK  MSGTXT+62(9),CRPTR(5)\nINFST13  TR    MSGTXT+62(8),HEXTAB-X'F0'\n         MVI   MSGTXT+70,C' '\n        @SEND  MSGOUT,OP=LA\n         TM    STATUS,DANGER\n         BO    *+L'*+8\n         TM    STATUS,TESTRUN\n         BZ    INFST30\n         MVC   MSGTXT(L'MSGTXT),ALLBLKS\n         TM    SWITCH,VASTB\n         BO    INFST20\n         MVC   MSGTXT(18),=CL18'NO VALID AS-TABLE.'\n         B     INFST22\nINFST20  TM    SWITCH,ACTIVM\n         BO    INFST21\n         MVC   MSGTXT(21),=CL21'NO AS-ID MODE ACTIVE.'\n         B     INFST22\nINFST21  MVC   MSGTXT(20),=CL20'ACTIVE AS-ID MODE IS'\n         UNPK  MSGTXT+21(5),ASIDN(3)\n         TR    MSGTXT+21(4),HEXTAB-X'F0'\n         MVC   MSGTXT+25(2),=CL2' ('\n         MVC   MSGTXT+27(L'ASNME),ASNME\n         MVC   MSGTXT+35(2),=CL2').'\nINFST22  TM    STATUS,TESTRUN\n         BZ    INFST23\n         CLC   RCVIND(L'RCVIND),ALLBLKS\n         BE    INFST23\n         MVC   MSGTXT+50(11),=CL11'TRACE 0C4 :'\n         MVC   MSGTXT+62(L'RCVIND),RCVIND\nINFST23  TM    FSCRSW,FSCRSF       FULL SCREEN?\n         BZ    *+L'*+4             NO\n         OI    FSCRSW,FSCRSI       SAY INTENSIVE LINE\n        @SEND  MSGOUT,OP=LA\nINFST30  TM    FSCRSW,FSCRSF       FULL SCREEN?\n         BZ    INFST31             NO\n         NI    FSCRSW,255-FSCRST   RESET STATUS\n         XC    FSPOINT,FSPOINT\n         B     INQUIRY\nINFST31  L     R1,CATKWA\n         LTR   R1,R1\n         BZ    INQUIRY\n         MVC   MSGTXT(L'MSGTXT),ALLBLKS\n         USING TKWA,R1\n         MVC   MSGTXT(11),=CL11'USER-AREA :'\n         MVC   MSGTXT+12(L'CTKWAN),CTKWAN\n         MVC   MSGTXT+L'CTKWAN+13(10),=CL10'- LENGTH :'\n         UNPK  DBLWD(5),TKWDL+2(3)\n         TR    DBLWD+1(3),HEXTAB-X'F0'\n         MVC   MSGTXT+L'CTKWAN+23(3),DBLWD+1\n         MVC   MSGTXT+L'CTKWAN+27(11),=CL11'- POINTER :'\n         UNPK  DBLWD(5),TKWPT+2(3)\n         TR    DBLWD+2(2),HEXTAB-X'F0'\n         MVC   MSGTXT+L'CTKWAN+39(2),DBLWD+2\n         DROP  R1\n        @SEND  MSGOUT,OP=LA\n         B     INQUIRY\nINFSTMV  MVC   0(*-*,R1),0(R14)    <<EXECUTED>>\n         SPACE 1\n        @END   ,\n         EJECT\nHELP    @INIT  ,\n         SPACE 1\n***********************************************************************\n*        HELP COMMAND.                                                *\n***********************************************************************\n         SPACE 1\n         MVC   CRPTR,PVPTR         ADJUST POINTERS FOR AFTER\n         LR    R1,R3               RETAIN ACTUAL POSITION\n         TM    FSCRSW,FSCRSF       FULL SCREEN?\n         BZ    HELPNF              NO\n         OI    FSCRSW,FSCRSH       YES, SAY HELP PANEL\n         BAS   R14,NEXTCH          POSITION TO NEXT\n         B     HELPDF              +0 - DEFAULT\n         CLI   0(R3),C'X'          +4 - CROSS MEMORY?\n         BE    HELPXM              YES\n         CLI   0(R3),C'L'          LABELS AND DSECTS?\n         BE    HELPLS              YES\n         CLI   0(R3),C'M'          MISCELLANEOUS?\n         BE    HELPMS              YES\nHELPDF   L     R1,=V(VCOREZAH)\n         USING HELPVP,R1\n         LM    R2,R4,HLDF\n         LM    R14,R0,HLAUTHF\nHELPFLL  CLI   AUTH,LV5            AUTHORIZED?\n         BL    *+L'*+22            NO\n         MVC   0(HLRESL,R15),0(R14)\n         LA    R14,HLRESL(R14)\n         LA    R15,HLRESL(R15)\n         BCT   R0,*-14\n         B     INQUIRY\n         MVC   2(HLRESL-2,R15),ALLBLKS\n         LA    R14,HLRESL(R14)\n         LA    R15,HLRESL(R15)\n         BCT   R0,*-14\n         B     INQUIRY\nHELPMS   L     R1,=V(VCOREZAH)\n         LM    R2,R4,HLMS\n         LM    R14,R0,HLAUTHM\n         B     HELPFLL\nHELPLS   L     R1,=V(VCOREZAH)\n         LM    R2,R4,HLLS\n         B     INQUIRY\n         DROP  R1\nHELPNF   BAS   R14,NEXTCH          POSITION TO NEXT\n         B     HELPDL              +0 - DEFAULT\n         CLI   0(R3),C'X'          +4 - CROSS MEMORY?\n         BE    HELPXM              YES\n         CLI   0(R3),C'L'          LABELS AND DSECTS?\n         BE    HELPHL              YES\n         CLI   0(R3),C'M'          MISCELLANEOUS?\n         BE    HELPHM              YES\n        PRINT  NOGEN\nHELPDL  @SEND  HELP01\n        @SEND  HELP02\n        @SEND  HELP03\n        @SEND  HELP04\n        @SEND  HELP05\n        @SEND  HELP06\n        @SEND  HELP07\n        @SEND  HELP08\n        @SEND  HELP09\n        @SEND  HELP10\n        @SEND  HELP11\n        @SEND  HELP12\n        @SEND  HELP13\n        @SEND  HELP14\n        @SEND  HELP15\n        @SEND  HELP16\n        @SEND  HELP17\n        @SEND  HELP18\n        @SEND  HELP19\n        @SEND  HELP20\n        @SEND  HELP21\n         CLI   AUTH,LV5            X-MEM AUTHORIZED?\n         BL    INQUIRY             NO\n        @SEND  HELP22\n        @SEND  HELP23\n        @SEND  HELP24\n        @SEND  HELP25\n        @SEND  HELP26\n         B     INQUIRY\nHELPHL  @SEND  HELP30\n        @SEND  HELP31\n        @SEND  HELP32\n        @SEND  HELP33\n        @SEND  HELP34\n        @SEND  HELP35\n        @SEND  HELP36\n        @SEND  HELP37\n        @SEND  HELP38\n        @SEND  HELP39\n        @SEND  HELP40\n        @SEND  HELP41\n        @SEND  HELP42\n        @SEND  HELP43\n        @SEND  HELP44\n        @SEND  HELP45\n        @SEND  HELP46\n        @SEND  HELP47\n        @SEND  HELP48\n        @SEND  HELP49\n        @SEND  HELP50\n         B     INQUIRY\nHELPHM  @SEND  HELP60\n        @SEND  HELP61\n        @SEND  HELP62\n        @SEND  HELP63\n        @SEND  HELP64\n        @SEND  HELP65\n        @SEND  HELP66\n        @SEND  HELP67\n        @SEND  HELP68\n        @SEND  HELP69\n         CLI   AUTH,LV5            AUTHORIZED?\n         BL    INQUIRY             NO\n        @SEND  HELP70\n         B     INQUIRY\nHELPXM   MVI   0(R1),C'X'          SET X H COMMAND\n         MVI   0(R3),C'H'\n         LR    R3,R1\n         L     R10,=A(ASNID)\n         BR    R10\n        PRINT  GEN\n         SPACE 1\n        @END   ,\n         EJECT\nDSPLY   @INIT  DISPLAY\n         SPACE 1\n***********************************************************************\n*        DISPLAY COMMAND.                                             *\n***********************************************************************\n         SPACE 1\n         BAS   R14,NEXTCH     POSITION TO NEXT\n         B     DS11           +0\n         BAS   R14,LABEL      +4 - GET LABEL\n         B     DS11                +0\n         B     DS2                 +4 - MAY BE HEX ADDRESS\n         B     ERR6                +8\n         B     DS3                 +12\n         BAS   R14,NEXT            +16 - POSITION TO NEXT\n         B     DS1                       +0\n         CLI   0(R3),C'/'                +4\n         BNE   DS1\n         BAS   R14,NEXTCH     POSITION TO NEXT\n         B     ERR37          +0\n         BAS   R14,NAMER      +4 - GET DSECT-NAME\n         B     ERR37               +0\n         B     ERR38               +4\n         B     ERR39               +8\n         MVC   DRFDSCT,NMEF        +12 - DSECT NAME\n         MVC   DRFFLDN,LBLF   FIELD NAME\n         MVC   LBLF,NMEF\n         BAS   R14,SCITBL     PREDEFINED LABELS\n         B     *+L'*+4        +0\n         BAS   R14,SCLTBL     +4 - LABELS\n         ICM   R6,B'1111',L'LBLF(R7)    SET ADDRESS\n         XC    DRFDSPL(L'DRFDSPL+L'DRFLNGH),DRFDSPL\n         MVC   DRFFLGN(L'DRFFLGN),ALLBLKS\n         XC    DRFFLVL(L'DRFFLVL+L'DRFFLLG),DRFFLVL\n         LA    R0,1           ASK SEARCH\n         L     R15,=A(DRFCALL)\n         BASR  R14,R15\n         B     *+L'*(R15)\n         B     *+L'*+8        +0\n         B     *+L'*+4        +4\n         B     ERROR          +8\n         XR    R0,R0\n         ICM   R0,B'0011',DRFDSPL  SET DISPLACEMENT\n         ALR   R6,R0          COMPUTE ADDRESS\n         B     DS3+L'DS3\nDS1      BAS   R14,SCLTBL\n         B     DS3\nDS2      CLI   0(R3),C'.'     HEX ADDRESS?\n         BNE   *+L'*+8\n         BAS   R14,NEXTCH     POSITION TO NEXT\n         B     ERR2           +0\n         BAS   R14,SCAN       +4 - GET ADDRESS\n         B     ERR2                +0\n         B     ERR17               +4\n         B     ERR3                +8\n         L     R6,DATA             +12 - SET ADDRESS\n         B     DS3+L'DS3\nDS3      ICM   R6,B'1111',L'LBLF(R7)    SET ADDRESS\n         NI    STATUS,255-SUBSTRCT\n         BAS   R14,NEXT       POSITION TO NEXT\n         B     DS12           +0 - NO DISPLACEMENT\n         CLI   0(R3),C'+'     +4 - TEST IF DELIMITER\n         BE    DS4\n         CLI   0(R3),C'-'\n         BNE   ERR10\n         OI    STATUS,SUBSTRCT\nDS4      BAS   R14,NEXTCH     POSITION TO NEXT\n         B     ERR9           +0\n         BAS   R14,LABEL      +4 - GET DISPLACEMENT\n         B     ERR9                +0\n         B     DS6                 +4 - MAY BE HEX DISPLACEMENT\n         B     ERR6                +8\n         B     DS5+L'DS5           +12\n         BAS   R14,NEXT            +16 - POSITION TO NEXT\n         B     DS5                       +0\n         CLI   0(R3),C'/'                +4\n         BNE   ERR37\n         BAS   R14,NEXTCH     POSITION TO NEXT\n         B     ERR37          +0\n         BAS   R14,NAMER      +4 - GET DSECT-NAME\n         B     ERR37               +0\n         B     ERR38               +4\n         B     ERR39               +8\n         MVC   DRFDSCT,NMEF        +12 - DSECT NAME\n         MVC   DRFFLDN,LBLF   FIELD NAME\n         XC    DRFDSPL(L'DRFDSPL+L'DRFLNGH),DRFDSPL\n         MVC   DRFFLGN(L'DRFFLGN),ALLBLKS\n         XC    DRFFLVL(L'DRFFLVL+L'DRFFLLG),DRFFLVL\n         LA    R0,1           ASK SEARCH\n         L     R15,=A(DRFCALL)\n         BASR  R14,R15\n         B     *+L'*(R15)\n         B     *+L'*+8        +0\n         B     *+L'*+4        +4\n         B     ERROR          +8\n         XR    R0,R0\n         ICM   R0,B'0011',DRFDSPL  SET DISPLACEMENT\n         B     DS10\nDS5      BAS   R14,SCLTBL\n         ICM   R0,B'1111',L'LBLF(R7)    SET DISPLACEMENT\n         B     DS10\nDS6      CLI   0(R3),C'.'     HEX DISPLACEMENT?\n         BNE   *+L'*+8\n         BAS   R14,NEXTCH     POSITION TO NEXT\n         B     ERR9           +0\n         BAS   R14,SCAN       +4 - GET DISPLACEMENT\n         B     ERR9                +0\n         B     ERR17               +4\n         B     ERR3                +8\n         L     R0,DATA             +12\nDS10     TM    STATUS,SUBSTRCT     APPLY DISPLACEMENT\n         BO    *+L'*+6\n         ALR   R6,R0\n         B     *+L'*+2\n         SLR   R6,R0\n         LA    R6,0(R6)\n         B     DS12\nDS11     CLI   PRVOP,C'S'\n         BNE   *+L'*+8\n         L     R6,PVPTR\n         B     DS12\n         L     R6,CRPTR\nDS12     LA    R0,FSRPLYL     RETAIN DISPLAY INPUT COMMAND IF NOT\n         LA    R1,ANSR             ONLY A CONTINUE D (RESHOW)\n         CLI   0(R1),C' '\n         BNE   *+L'*+12\n         LA    R1,1(R1)\n         BCT   R0,*-12\n         B     DSPLY0\n         LA    R15,ANSR+FSRPLYL-1\n         CLI   0(R15),C' '\n         BNE   *+L'*+4\n         BCT   R15,*-8\n         SR    R15,R1\n         BNP   DSPLY0\n         LA    R0,1(R15)\n         LR    R14,R1\n         CLI   0(R14),C'X'\n         BNE   DS14\nDS13     LA    R14,1(R14)\n         BCT   R0,*+L'*+4\n         B     DSPLY0\n         CLI   0(R14),C' '\n         BE    DS13\nDS14     CLI   0(R14),C'D'\n         BNE   DSPLY0\nDS15     LA    R14,1(R14)\n         BCT   R0,*+L'*+4\n         B     DSPLY0\n         CLI   0(R14),C' '\n         BE    DS15\n         XC    LSTDSP,LSTDSP\n         EX    R15,*+L'*+4\n         B     DSPLY0\n         MVC   LSTDSP(*-*),0(R1)   <<EXECUTED>>\nFBDSPL   TM    SWITCH,POPXMR  WAS PREVIOUS OP. X-MEM. REF. MODE?\n         BZ    *+L'*+4        NO\n         OI    SWITCH,XMEMRF  YES, CONTINUE IN X-MEM. REF. MODE\n         NI    SWITCH,255-ASFULL-PVALID RESET\n         NI    STATUS,255-SUBSTRCT\n         CLI   0(R3),C'-'\n         BNE   *+L'*+4\n         OI    STATUS,SUBSTRCT\n         BAS   R14,NEXTCH     POSITION TO NEXT\n         B     ERR2           +0\n         LA    R0,15          +4 - GET NUMBER OF BYTES (1 TO 999)\n         XR    R1,R1\n         XR    R2,R2\nFB1      CLI   0(R3),C'0'\n         BL    ERR4\n         CLI   0(R3),C'9'\n         BH    ERR4\n         IC    R1,0(R3)\n         NR    R1,R0\n         LTR   R2,R2\n         BNP   *+L'*+4\n         MH    R2,=H'10'\n         AR    R2,R1\n         CH    R2,=H'999'\n         BH    ERR4\n         BXLE  R3,R4,*+L'*+4\n         B     *+L'*+8\n         CLI   0(R3),C' '\n         BNE   FB1\n         LTR   R2,R2\n         BNP   ERR4\n         CLI   PRVOP,C'S'\n         BE    *+L'*+8\n         L     R6,PVPTR\n         B     *+L'*+4\n         L     R6,CRPTR\n         TM    STATUS,SUBSTRCT     APPLY DISPLACEMENT\n         BO    *+L'*+6\n         ALR   R6,R2\n         B     *+L'*+2\n         SLR   R6,R2\n         LA    R6,0(R6)\n         B     DSPLY0\nGBYTES   LA    R6,3           SET DEFAULT (FOUR BYTES)\n         BAS   R14,NEXTCH     POSITION TO NEXT\n         B     GB2            +0 - DEFAULT\n         LR    R2,R3          +4 - GET NUMBER OF BYTES (1-16)\nGB1      CLI   0(R3),C'0'\n         BL    ERR48\n         CLI   0(R3),C'9'\n         BH    ERR48\n         BXLE  R3,R4,*+L'*+4\n         B     *+L'*+8\n         CLI   0(R3),C' '\n         BNE   GB1\n         LR    R1,R3\n         SR    R1,R2\n         CH    R1,=H'8'\n         BH    ERR48\n         BCT   R1,*+L'*+6\n         PACK  DBLWD,0(*-*,R2)\n         EX    R1,*-6\n         CVB   R6,DBLWD\n         LTR   R6,R6\n         BNP   ERR48\n         CH    R6,=H'16'\n         BH    ERR48\n         BCTR  R6,0\nGB2      STC   R6,GNBYT\n         OI    OPERSW,GETBSW\n         CLI   PRVOP,C'D'\n         BNE   *+L'*+8\n         L     R6,PVPTR\n         B     DSPLY0\n         L     R6,CRPTR\nDSPLY0   ST    R6,DATA\n         MVI   PRVOP,C'D'\nDSPLY1   MVC   ADVICE(L'ADVICE),ALLBLKS\n         TM    SWITCH,ACTIVM+XMEMRF ACTIVE MODE + X-MEM.REF.?\n         BO    DSPLY2         YES\n         TM    STATUS,DANGER\n         BO    *+L'*+8\n         TM    STATUS,TESTRUN\n         BO    DSPLY2\n         CL    R6,BEGADD\n         BL    DSPLY2\n         CL    R6,ENDADD\n         BL    ERR23\nDSPLY2   ST    R6,RCVPTR\n         L     R3,=A(HXDATA)  ADDRESS OF MOVE (=BLDATA)\n         TM    FSCRSW,FSCRSF  FULL SCREEN?\n         BO    *+L'*+8        YES\n         L     R2,=A(L'HXDATA)     LENGTH OF MOVE\n         B     DS20\n         SRL   R6,7           SET START OF BLOCK\n         SLL   R6,7\n         ST    R6,BLKPTR\n         L     R2,=A(L'BLDATA)     LENGTH OF MOVE\n         LA    R4,L'BLDATA/L'HXDATA     NUMBER OF LINES TO DISPLAY\n         OI    FSPRSW,FSPRDS  SAY FULL SCREEN DISPLAY TO RECOVER\n         STM   R0,R15,FSRCVR  SET REGISTERS IN CASE OF RECOVER\nDS20     OI    SWITCH,TSTEAP  SET E.A. PROT. REQUEST\nDSPLY3   BAS   R8,ENABLE ----------------------------------- * DANGER *\n         B     DS21           +0 - X-MEM. REF.                        *\n         BCTR  R2,0           +4 - GET DATA AT ADDRESS                *\n         EX    R2,*+L'*+4                                             *\n         B     DS23                                                   *\n         MVC   0(*-*,R3),0(R6)     <<EXECUTED>>                       *\nDS21     XR    R15,R15        FROM KEY                                *\nDS22     MVCP  0(R2,R3),0(R6),R15  GET DATA AT ADDRESS                *\n         BZ    DS23                                                   *\n         AL    R6,=F'256'     BUMP FROM ADDRESS                       *\n         AL    R3,=F'256'     BUMP TO ADDRESS                         *\n         SL    R2,=F'256'     DECREMENT THE LENGTH                    *\n         B     DS22           GO BACK AND GET MORE                    *\nDS23     BAS   R8,DISABLE ---------------------------------- * DANGER *\n         TM    FSCRSW,FSCRSF  FULL SCREEN?\n         BO    DS30           YES\nDSPLY4   CLI   PRVOP,C'F'\n         BNE   *+L'*+10\n         XR    R7,R7\n         IC    R7,STRNGL      BUMP WITH LENGTH OF STRING\n         B     *+L'*+8\n         CLI   PRVOP,C'S'\n         BNE   *+L'*+8\n         LA    R1,1(R6,R7)    BUMP WITH LENGTH OF STORE\n         B     *+L'*+4\n         LA    R1,L'HXDATA(R6)\n         ST    R1,CRPTR       CURRENT POINTER\n         ST    R6,PVPTR       PREVIOUS POINTER\n         LA    R2,MSGTXT\n         MVC   MSGTXT(L'MSGTXT),ALLBLKS\n         USING CONSLOUT,R2\n         UNPK  CONSL1(L'CONSL1+1),DATA(5)\n         TR    CONSL1(L'CONSL1),HEXTAB-X'F0'\n         MVI   CONSL1+L'CONSL1,C' '\n         MVI   CONSL2,C':'\n         L     R1,=A(HXDATA)  ADDRESS OF MOVED DATA\n         UNPK  CONSL3(L'CONSL3+1),0(5,R1)\n         TR    CONSL3(L'CONSL3),HEXTAB-X'F0'\n         MVI   CONSL3+L'CONSL3,C' '\n         UNPK  CONSL4(L'CONSL4+1),4(5,R1)\n         TR    CONSL4(L'CONSL4),HEXTAB-X'F0'\n         MVI   CONSL4+L'CONSL4,C' '\n         UNPK  CONSL5(L'CONSL5+1),8(5,R1)\n         TR    CONSL5(L'CONSL5),HEXTAB-X'F0'\n         MVI   CONSL5+L'CONSL5,C' '\n         UNPK  CONSL6(L'CONSL6+1),12(5,R1)\n         TR    CONSL6(L'CONSL6),HEXTAB-X'F0'\n         MVI   CONSL6+L'CONSL6,C' '\n         MVI   CONSL7,C'*'\n         MVC   CONSL8(L'HXDATA),0(R1)\n         L     R1,=A(CHARTB)\n         TR    CONSL8,0(R1)\n         MVI   CONSL9,C'*'\n         MVC   CONSLA,ADVICE\n         TM    SWITCH,POPXMR  WAS PREVIOUS OP. X-MEM. REF. MODE?\n         BO    DS24           YES\n         TM    STATUS,DANGER\n         BO    *+L'*+8\n         TM    STATUS,TESTRUN\n         BO    DS24\n         CLI   PRVOP,C'D'\n         BNE   DS24\n         CLC   PVPTR,BEGADD\n         BNL   DS24\n         CLC   CRPTR,BEGADD\n         BNH   DS24\n         L     R1,BEGADD\n         SL    R1,PVPTR       NUMBER OF VIEWABLE DATA BYTES\n         MH    R1,=Y(L'DSVD+4)\n         B     DSVD-L'DSVD-4(R1)\nDSVD     MVC   CONSL3+2(2),ALLBLKS\n         MVI   CONSL8+1,C' '\n         MVC   CONSL3+4(2),ALLBLKS\n         MVI   CONSL8+2,C' '\n         MVC   CONSL3+6(2),ALLBLKS\n         MVI   CONSL8+3,C' '\n         MVC   CONSL4(2),ALLBLKS\n         MVI   CONSL8+4,C' '\n         MVC   CONSL4+2(2),ALLBLKS\n         MVI   CONSL8+5,C' '\n         MVC   CONSL4+4(2),ALLBLKS\n         MVI   CONSL8+6,C' '\n         MVC   CONSL4+6(2),ALLBLKS\n         MVI   CONSL8+7,C' '\n         MVC   CONSL5(2),ALLBLKS\n         MVI   CONSL8+8,C' '\n         MVC   CONSL5+2(2),ALLBLKS\n         MVI   CONSL8+9,C' '\n         MVC   CONSL5+4(2),ALLBLKS\n         MVI   CONSL8+10,C' '\n         MVC   CONSL5+6(2),ALLBLKS\n         MVI   CONSL8+11,C' '\n         MVC   CONSL6(2),ALLBLKS\n         MVI   CONSL8+12,C' '\n         MVC   CONSL6+2(2),ALLBLKS\n         MVI   CONSL8+13,C' '\n         MVC   CONSL6+4(2),ALLBLKS\n         MVI   CONSL8+14,C' '\n         MVC   CONSL6+6(2),ALLBLKS\n         MVI   CONSL8+15,C' '\n         DROP  R2\nDS24    @SEND  MSGOUT,OP=LA\n         B     INQUIRY\nDS30     NI    FSPRSW,255-FSPRDS   RESET\n         L     R6,RCVPTR      RESTORE POINTER\n         CLI   PRVOP,C'S'\n         BNE   *+L'*+12\n         LA    R1,1(R6,R7)    BUMP WITH LENGTH OF STORE\n         ST    R1,WDSPT\n         B     DS32\n         CLI   PRVOP,C'F'\n         BNE   DS31\n         XR    R7,R7\n         IC    R7,STRNGL\n         LA    R1,1(R6,R7)    BUMP WITH LENGTH OF STRING\n         B     DS31+L'DS31\nDS31     LA    R1,L'HXDATA(R6)\n         MVC   WDSPT,DATA\nDS32     ST    R1,CRPTR       CURRENT POINTER\n         ST    R6,PVPTR       PREVIOUS POINTER\n         TM    OPERSW,GETBSW\n         BZ    DSPLY5\n         XC    GFBYT(L'GFBYT+L'GLBYT),GFBYT\nDSPLY5   L     R3,=A(HXDATA)  ADDRESS OF MOVED DATA (=BLDATA)\n         LA    R2,MSGSVT\n         MVC   WDSLN,BLKPTR\n         XC    FSPOINT,FSPOINT     SAY DATA LINES\n         OI    FSCRSW,FSCRSL\nDS40     TM    SWITCH,POPXMR  WAS PREVIOUS OP. X-MEM. REF. MODE?\n         BO    DS41           YES\n         TM    STATUS,DANGER\n         BO    *+L'*+8\n         TM    STATUS,TESTRUN\n         BO    DS41\n         CLI   PRVOP,C'D'\n         BNE   DS41\n         CLC   WDSLN,BEGADD\n         BL    DS41\n         CLC   WDSLN,ENDADD\n         BNL   DS41\n         L     R1,WDSLN       UNVIEWABLE DATA\n         AL    R1,=A(L'HXDATA)\n         ST    R1,WDSLN\n         B     DS45\nDS41     MVC   MSGSVT(L'MSGSVT),ALLBLKS\n         USING FSLOUT,R2\n         UNPK  FSL1(L'FSL1+1),WDSLN(5)\n         TR    FSL1(L'FSL1),HEXTAB-X'F0'\n         MVI   FSL1+L'FSL1,C' '\n         LA    R0,4\n         LA    R1,FSL2\n         LR    R14,R3\n         TM    OPERSW,GETBSW\n         BZ    DS42\n         OC    GFBYT,GFBYT\n         BNZ   DS42\n         ST    R14,GFBYT\nDS42     UNPK  TBUF(9),0(5,R14)\n         TR    TBUF(8),HEXTAB-X'F0'\n         MVC   1(4,R1),TBUF\n         MVC   6(4,R1),TBUF+4\n         BCT   R0,*+L'*+4\n         B     DS43\n         LA    R1,L'FSL2(R1)\n         LA    R14,4(R14)\n         B     DS42\nDS43     TM    OPERSW,GETBSW\n         BZ    *+L'*+6\n         BCTR  R14,0\n         ST    R14,GLBYT\n         MVI   FSL3,C'|'\n         MVC   FSL4(L'HXDATA),0(R3)\n         L     R1,=A(CHARTB)\n         TR    FSL4,0(R1)\n         MVI   FSL5,C'|'\n         L     R1,WDSLN\n         AL    R1,=A(L'HXDATA)\n         CLC   WDSPT,WDSLN\n         BL    DS44\n         BE    *+L'*+8\n         CL    R1,WDSPT\n         BNH   DS44\n         L     R1,WDSPT\n         SL    R1,WDSLN\n         SLL   R1,1\n         AL    R1,=A(FSTAPD)\n         XR    R0,R0\n         IC    R0,0(R1)\n         LA    R14,FSLOUT\n         ALR   R14,R0\n         MVC   0(1,R14),1(R1) MARK CURRENT ADDRESS POINTER\n         MVC   FSL6,ADVICE\n         DROP  R2\n         OI    FSCRSW,FSCRSI  SAY INTENSIVE LINE\n         L     R1,WDSLN\n         AL    R1,=A(L'HXDATA)\nDS44     ST    R1,WDSLN\n        @SEND  MSGSVTO,OP=LA\nDS45     AL    R3,=A(L'HXDATA)\n         BCT   R4,DS40\n         NI    FSCRSW,255-FSCRSL   RESET DATA\n         MVC   FSCRSCL,=CL54'ADDRESS+    0 1  2 3   4 5  6 7   8 9  A B1\n                  C D  E F '       SET SCALE\n         TM    OPERSW,GETBSW\n         BZ    INQUIRT\n         NI    OPERSW,255-GETBSW\n         SL    R6,BLKPTR\n         AL    R6,=A(HXDATA)\n         CL    R6,GFBYT\n         BL    INQUIRT\n         CL    R6,GLBYT\n         BH    INQUIRT\n         XR    R14,R14\n         IC    R14,GNBYT\n         ALR   R14,R6\n         CL    R14,GLBYT\n         BNH   *+L'*+4\n         BCT   R14,*-8\n         SLR   R14,R6\n         LA    R15,FSCRTXT\nGBX1     CH    R14,=H'5'\n         BNH   GBX2\n         MVC   TBUF(6),0(R6)\n         UNPK  0(13,R15),TBUF(7)\n         TR    0(12,R15),HEXTAB-X'F0'\n         LA    R6,6(R6)\n         LA    R15,12(R15)\n         SH    R14,=H'6'\n         B     GBX1\nGBX2     EX    R14,GBMV1\n         UNPK  TBUF(13),TBUF+16(7)\n         TR    TBUF(12),HEXTAB-X'F0'\n         SLL   R14,1\n         LA    R14,1(R14)\n         EX    R14,GBMV2\n         B     INQUIRT\nGBMV1    MVC   TBUF+16(*-*),0(R6)\nGBMV2    MVC   0(*-*,R15),TBUF\n         SPACE 1\n        @END   ,\n         EJECT\nSTORE   @INIT  ,\n         SPACE 1\n***********************************************************************\n*        STORE COMMAND.                                               *\n***********************************************************************\n         SPACE 1\n         CLI   AUTH,LV10      AUTHORIZED?\n         BL    ERR22          NO\n         BAS   R14,NEXTCH     POSITION TO NEXT\n         B     ERR2           +0\n         BAS   R14,LABEL      +4 - GET LABEL\n         B     ERR5                +0\n         B     ST2                 +4 - MAY BE HEX ADDRESS\n         B     ERR6                +8\n         B     ST3                 +12\n         BAS   R14,NEXT            +16 - POSITION TO NEXT\n         B     ST1                       +0\n         CLI   0(R3),C'/'                +4\n         BNE   ST1\n         BAS   R14,NEXTCH     POSITION TO NEXT\n         B     ERR37          +0\n         BAS   R14,NAMER      +4 - GET DSECT-NAME\n         B     ERR37               +0\n         B     ERR38               +4\n         B     ERR39               +8\n         MVC   DRFDSCT,NMEF        +12 - DSECT NAME\n         MVC   DRFFLDN,LBLF   FIELD NAME\n         MVC   LBLF,NMEF\n         BAS   R14,SCITBL     PREDEFINED LABELS\n         B     *+L'*+4        +0\n         BAS   R14,SCLTBL     +4 - LABELS\n         ICM   R6,B'1111',L'LBLF(R7)    SET ADDRESS\n         XC    DRFDSPL(L'DRFDSPL+L'DRFLNGH),DRFDSPL\n         MVC   DRFFLGN(L'DRFFLGN),ALLBLKS\n         XC    DRFFLVL(L'DRFFLVL+L'DRFFLLG),DRFFLVL\n         LA    R0,1           ASK SEARCH\n         L     R15,=A(DRFCALL)\n         BASR  R14,R15\n         B     *+L'*(R15)\n         B     *+L'*+8        +0\n         B     *+L'*+4        +4\n         B     ERROR          +8\n         XR    R0,R0\n         ICM   R0,B'0011',DRFDSPL  SET DISPLACEMENT\n         ALR   R6,R0          COMPUTE ADDRESS\n         B     ST3+L'ST3\nST1      BAS   R14,SCLTBL\n         B     ST3\nST2      CLI   0(R3),C'.'     HEX ADDRESS?\n         BNE   *+L'*+8\n         BAS   R14,NEXTCH     POSITION TO NEXT\n         B     ERR2           +0\n         BAS   R14,SCAN       +4 - GET ADDRESS\n         B     ERR2                +0\n         B     ST15                +4\n         B     ERR3                +8\n         L     R6,DATA             +12 - SET ADDRESS\n         B     ST3+L'ST3\nST3      ICM   R6,B'1111',L'LBLF(R7)    SET ADDRESS\n         NI    STATUS,255-SUBSTRCT\n         BAS   R14,NEXT       POSITION TO NEXT\n         B     ERR2           +0\n         CLI   0(R3),C'+'     +4 - TEST IF DELIMITER\n         BE    ST4\n         CLI   0(R3),C'-'\n         BNE   ST12\n         OI    STATUS,SUBSTRCT\nST4      BAS   R14,NEXTCH     POSITION TO NEXT\n         B     ERR9           +0\n         BAS   R14,LABEL      +4 - GET DISPLACEMENT\n         B     ERR9                +0\n         B     ST10                +4 - MAY BE HEX DISPLACEMENT\n         B     ERR6                +8\n         B     ST5+L'ST5           +12\n         BAS   R14,NEXT            +16 - POSITION TO NEXT\n         B     ST5                       +0\n         CLI   0(R3),C'/'                +4\n         BNE   ERR37\n         BAS   R14,NEXTCH     POSITION TO NEXT\n         B     ERR37          +0\n         BAS   R14,NAMER      +4 - GET DSECT-NAME\n         B     ERR37               +0\n         B     ERR38               +4\n         B     ERR39               +8\n         MVC   DRFDSCT,NMEF        +12 - DSECT NAME\n         MVC   DRFFLDN,LBLF   FIELD NAME\n         XC    DRFDSPL(L'DRFDSPL+L'DRFLNGH),DRFDSPL\n         MVC   DRFFLGN(L'DRFFLGN),ALLBLKS\n         XC    DRFFLVL(L'DRFFLVL+L'DRFFLLG),DRFFLVL\n         LA    R0,1           ASK SEARCH\n         L     R15,=A(DRFCALL)\n         BASR  R14,R15\n         B     *+L'*(R15)\n         B     *+L'*+8        +0\n         B     *+L'*+4        +4\n         B     ERROR          +8\n         XR    R0,R0\n         ICM   R0,B'0011',DRFDSPL  SET DISPLACEMENT\n         B     ST11\nST5      BAS   R14,SCLTBL\n         ICM   R0,B'1111',L'LBLF(R7)    SET DISPLACEMENT\n         B     ST11\nST10     CLI   0(R3),C'.'     HEX DISPLACEMENT?\n         BNE   *+L'*+8\n         BAS   R14,NEXTCH     POSITION TO NEXT\n         B     ERR9           +0\n         BAS   R14,SCAN       +4 - GET DISPLACEMENT\n         B     ERR9                +0\n         B     ERR17               +4\n         B     ERR3                +8\n         L     R0,DATA             +12\nST11     TM    STATUS,SUBSTRCT     APPLY DISPLACEMENT\n         BO    *+L'*+6\n         ALR   R6,R0\n         B     *+L'*+2\n         SLR   R6,R0\n         LA    R6,0(R6)\nST12     ST    R6,DTPTR\n         B     ST20\nST15     CLI   0(R3),C'*'     CONTINUE IN SEQUENCE...\n         BNE   ERR4           NO, ERROR\n         BAS   R14,NEXTCH     POSITION TO NEXT\n         B     ERR2           +0\n         CLI   PRVOP,C'S'     +4\n         BNE   ST16\n         OC    CRPTR,CRPTR\n         BZ    ERR4\n         MVC   DTPTR,CRPTR\n         B     ST20\nST16     MVC   DTPTR,PVPTR\nST20     BAS   R14,NEXT       POSITION TO NEXT\n         B     ERR2           +0\n         CLI   0(R3),C'@'     +4 - TANK NUMBER?\n         BE    ST25           YES\n         LA    R6,TBUF\n         XR    R7,R7\nST21     XC    DATA,DATA      GET HEX DATA\n         LA    R1,L'DATA\n         LR    R2,R3          START OF DATA FIELD\nST22     CLI   0(R3),C','     DELIMITER ,?\n         BE    ST23           YES\n         CLI   0(R3),C' '     END OF DATA?\n         BE    ST23           YES\n         CLI   0(R3),C'A'\n         BL    ERR17\n         CLI   0(R3),C'9'\n         BH    ERR17\n         CLI   0(R3),C'0'\n         BNL   *+L'*+8\n         CLI   0(R3),C'F'\n         BH    ERR17\n         BXLE  R3,R4,*+L'*+4  INCREMENT POINTER\n         B     ST23\n         BCT   R1,ST22\nST23     LR    R1,R3\n         SR    R1,R2          COMPUTE NUMBER OF CHARACTERS\n         BP    ST24\n         CLR   R3,R5          NO MOVE IF NONE\n         BH    ST30\n         BAS   R14,NEXTCH     POSITION TO NEXT\n         B     ST30           +0 - NO MORE DATA\n         B     ST21           +4 - CONTINUE\nST24     STC   R1,TSTBT\n         TM    TSTBT,X'01'\n         BO    ERR18\n         BCTR  R1,0           DECREMENT BY 1\n         XC    FXLAB,FXLAB    CLEAR WORK AREA\n         EX    R1,STMWA       MOVE TO WORK AREA\n         EX    R1,STNFT       NORMALIZE FOR TRANSLATE\n         EX    R1,STTTB       TRANSLATE TO BINARY\n         LA    R1,1(R1)       INCR. BY 1\n         EX    R1,STCTH       CONVERT TO HEX\n         LR    R14,R1\n         SRL   R14,1\n         LA    R15,DATA+L'DATA\n         SLR   R15,R14\n         EX    R14,STDTA      SET DATA IN TEMPORARY AREA\n         ALR   R6,R14\n         ALR   R7,R14\n         CLR   R3,R5\n         BH    ST30\n         BAS   R14,NEXT       POSITION TO NEXT\n         B     ST30           +0 - NO MORE DATA\n         B     ST21           +4 - CONTINUE\nST25     BAS   R14,NEXTCH     POSITION TO NEXT\n         B     ERR2           +0 - NO MORE DATA\n         XR    R2,R2          +4 - GET TANK NUMBER\n         LA    R0,15\nST26     CLI   0(R3),C'0'     NUMERIC?\n         BL    ERR4\n         CLI   0(R3),C'9'\n         BH    ERR4\n         IC    R1,0(R3)       COMPUTE NUMBER\n         NR    R1,R0\n         LTR   R2,R2\n         BZ    *+L'*+4\n         MH    R2,=H'10'\n         AR    R2,R1\n         CH    R2,=Y(NTKWAS)\n         BH    ERR4\n         BXLE  R3,R4,*+L'*+4  TO NEXT\n         B     *+L'*+8        NO MORE DATA\n         CLI   0(R3),C' '     END?\n         BNE   ST26           NO, CONTINUE\n         LTR   R2,R2\n         BNP   ERR4\n         BCTR  R2,0\n         MH    R2,=Y(TKWAL)\n         AL    R2,ATKWAS      REQUESTED TANK ADDRESS\n         USING TKWA,R2\n         L     R7,TKWDL       GET TEXT LENGTH\n         LA    R3,TKWTX       START OF TEXT\n         DROP  R2\n         LTR   R7,R7\n         BNP   ERR36\n         B     ST31\nST30     LA    R3,TBUF        ADDRESS OF TEXT TO MOVE\n         LTR   R7,R7\n         BNP   ERR2\nST31     L     R6,DTPTR\n         LA    R1,0(R6,R7)\n         ST    R1,CRPTR       CURRENT POINTER\n         ST    R6,PVPTR       PREVIOUS POINTER\n         BCTR  R7,0           LENGTH OF MOVE\n         TM    SWITCH,ACTIVM+XMEMRF ACTIVE MODE + X-MEM.REF.?\n         BNO   *+L'*+8        NO\n         LA    R2,1(R7)       YES, LENGTH OF MOVE\n         B     ST40\n         TM    STATUS,DANGER\n         BO    *+L'*+8\n         TM    STATUS,TESTRUN\n         BO    ST40\n         CL    R6,BEGADD\n         BL    ST32\n         CL    R6,ENDADD\n         BNL   ST40\n         B     ERR24          UNTOUCHABLE DATA\nST32     LA    R1,0(R6,R2)\n         CL    R1,BEGADD\n         BNL   ERR24          OVERFLOW IN UNTOUCHABLE DATA\nST40     MVI   PRVOP,C'S'\n         OI    SWITCH,TSTEAP  SET E.A. PROT. REQUEST\n         BAS   R8,ENABLE ----------------------------------- * DANGER *\n         B     ST41           +0 - X-MEM. REF.                        *\n         EX    R7,*+L'*+4     +4 - MOVE INTO VIRTUAL STORAGE          *\n         B     ST43                                                   *\n         MVC   0(*-*,R6),0(R3)     <<EXECUTED>>                       *\nST41     XR    R15,R15        FROM KEY                                *\nST42     MVCS  0(R2,R6),0(R3),R15  MOVE INTO VIRTUAL STORAGE          *\n         BZ    ST43                                                   *\n         AL    R3,=F'256'     BUMP FROM ADDRESS                       *\n         AL    R6,=F'256'     BUMP TO ADDRESS                         *\n         SL    R2,=F'256'     DECREMENT THE LENGTH                    *\n         B     ST42           GO BACK AND GET MORE                    *\nST43     BAS   R8,DISABLE ---------------------------------- * DANGER *\n         L     R6,PVPTR\n         ST    R6,DATA\n         TM    SWITCH,POPXMR  WAS PREVIOUS OP. X-MEM. REF. MODE?\n         BZ    *+L'*+4        NO\n         OI    SWITCH,XMEMRF  YES, CONTINUE IN X-MEM. REF. MODE\n         L     R10,=A(DSPLY)\n         DROP  R10\n         USING DSPLY,R10\n         B     DSPLY1\n         DROP  R10\n         USING STORE,R10\nSTMWA    MVC   FXLAB(*-*),0(R2)    <<EXECUTED>>\nSTNFT    NC    FXLAB(*-*),=XL8'1F1F1F1F1F1F1F1F'  <<EXECUTED>>\nSTTTB    TR    FXLAB(*-*),TRANTBL  <<EXECUTED>>\nSTCTH    PACK  DATA(L'DATA+1),FXLAB(*-*)     <<EXECUTED>>\nSTDTA    MVC   0(*-*,R6),0(R15)    <<EXECUTED>>\n         SPACE 1\n        @END   ,\n         EJECT\nFIND    @INIT  ,\n         SPACE 1\n***********************************************************************\n*        FIND A STRING COMMAND.                                       *\n***********************************************************************\n         SPACE 1\n         BAS   R14,NEXTCH     POSITION TO NEXT\n         B     FN10                +0 - USE STRING (CONTINUE)\n         CLC   0(4,R3),=CL4'FULL'  +4 - ENTIRE A.S. SEARCH?\n         BNE   FN1            NO\n         OI    SWITCH,ASFULL\n         LA    R3,4(R3)\n         BAS   R14,NEXTCH     POSITION TO NEXT\n         B     FN10                +0 - USE STRING (CONTINUE)\nFN1      NI    STATUS,255-FTYPE    +4 - GET STRING TYPE\n         MVI   STRNGL,0\n         XC    STRNG,STRNG\n         CLI   0(R3),C''''    CHAR STRING?\n         BNE   FN2            NO\n         OI    STATUS,FTYPE   YES, SET CHAR TYPE\n         MVC   STRNG(L'STRNG),ALLBLKS\n         LA    R3,1(R3)       START OF STRING\nFN2      CLI   0(R5),C' '     SEARCH END OF STRING\n         BNE   *+L'*+4\n         BCT   R5,FN2\n         LR    R2,R5\n         SH    R2,=H'4'\n         CLR   R2,R3\n         BNH   FN4\n         CLC   1(4,R2),=CL4'FULL'  ENTIRE A.S. SEARCH?\n         BNE   FN4            NO\n         OI    SWITCH,ASFULL\n         LR    R5,R2\nFN3      CLI   0(R5),C' '     SEARCH END OF STRING\n         BNE   *+L'*+4\n         BCT   R5,FN3\nFN4      TM    STATUS,FTYPE   DATA STRING TYPE?\n         BZ    FN5            BR IF HEX\n         CLI   0(R5),C''''    END OF CHAR STRING?\n         BNE   ERR35          NO\n         LR    R4,R5\n         SR    R4,R3\n         BNP   ERR4\n         CH    R4,=Y(L'STRNG)\n         BH    ERR3           TOO LONG\n         BCTR  R4,0\n         STC   R4,STRNGL      MCH LENGTH OF FIND CHAR DATA\n         EX    R4,*+L'*+4     SET FIND CHAR DATA\n         B     FN10\n         MVC   STRNG(*-*),0(R3)    <<EXECUTED>>\nFN5      LA    R4,1(R5)\n         SR    R4,R3\n         CH    R4,=Y(2*L'STRNG)\n         BH    ERR3           TOO LONG\n         STC   R4,STRNGL      LENGTH OF FIND HEX DATA\n         TM    STRNGL,X'01'   ODD NUMBER OF DIGITS?\n         BO    ERR18          YES, ERROR\n         LR    R0,R4          VALID STRING VALUE CONTROL\nFN6      CLI   0(R5),C'A'\n         BL    ERR17\n         CLI   0(R5),C'9'\n         BH    ERR17\n         CLI   0(R5),C'0'\n         BNL   FN7\n         CLI   0(R5),C'F'\n         BH    ERR17\nFN7      NI    0(R5),X'1F'    NORMALIZE FOR TRANSLATE\n         TR    0(1,R5),TRANTBL     TRANSLATE TO BINARY\n         BCTR  R5,0\n         BCT   R0,FN6\n         SRL   R4,1           NUMBER OF BINARY BYTES\n         LR    R1,R4\n         BCTR  R1,0\n         STC   R1,STRNGL      MCH LENGTH OF FIND HEX DATA\n         XR    R0,R0\n         XR    R1,R1\n         LA    R5,STRNG       BUILD BINARY DATA\nFN8      IC    R1,0(R3)\n         IC    R0,1(R3)\n         SLL   R1,4\n         OR    R1,R0\n         STC   R1,0(R5)\n         LA    R3,2(R3)\n         LA    R5,1(R5)\n         BCT   R4,FN8\nFN10     CLI   PRVOP,C'F'     GET REAL FIND START ADDRESS\n         BE    *+L'*+8\n         L     R6,PVPTR\n         B     *+L'*+4\n         L     R6,CRPTR\n         TM    SWITCH,ASFULL  ENTIRE A.S. SEARCH?\n         BZ    FNCNT          NO\n         LA    R4,2048(R6)    COMPUTE ENDING ADDRESS\n         LA    R4,2047(R4)\n         SRL   R4,12\n         SLL   R4,12\n         ST    R4,WRPTR\n         OI    WRPTR,X'80'\n         TM    STATUS,TSORUN\n         BZ    FNCNT\n         TM    FSCRSW,FSCRSF\n         BZ    FNCNT\n         L     R4,=A(256*KB)  COMPUTE CONTROL ADDRESS\n         LA    R4,0(R4,R6)\n         SRL   R4,18\n         ST    R4,CFFPTR\nFNCNT    LR    R4,R6          COMPUTE PAGE START ADDRESS\n         SRL   R4,12\n         SLL   R4,12\n         L     R2,=A(FNBUF)\n         L     R3,=A(4*KB)\n         LR    R5,R3\n         LR    R7,R6          COMPUTE START DISPLACEMENT\n         SLR   R7,R4\n         TM    SWITCH,ACTIVM+XMEMRF ACTIVE MODE + X-MEM.REF.?\n         BO    FN13           YES\n         TM    STATUS,DANGER\n         BO    *+L'*+8\n         TM    STATUS,TESTRUN\n         BO    FN13\n         CL    R6,BEGADD\n         BH    FN11\n         BE    FN12\n         LR    R1,R4\n         AL    R1,=A(4*KB)\n         CL    R1,BEGADD\n         BNH   FN13\n         B     FN12\nFN11     CL    R6,ENDADD\n         BNL   FN13\nFN12     TM    SWITCH,ASFULL  ENTIRE A.S. SEARCH?\n         BZ    ERR25          NO, UNACCESSIBLE PAGE\nFNRCV    L     R6,=A(4*KB)    YES, SKIP THIS PAGE\n         LA    R6,0(R6,R4)\n         B     FN37\nFN13     LR    R6,R4          KEEP PAGE START ADDRESS\n         ST    R6,RCVPTR\n         MVI   PRVOP,C'F'\n         BAS   R8,ENABLE ----------------------------------- * DANGER *\n         B     FN20           +0 - X-MEM. REF.                        *\n         MVCL  R2,R4          +4 - GET REQUESTED 4K PAGE              *\n         B     FN22                                                   *\nFN20     XR    R15,R15        FROM KEY                                *\nFN21     MVCP  0(R3,R2),0(R4),R15  GET REQUESTED 4K PAGE              *\n         BZ    FN22                                                   *\n         AL    R4,=F'256'     BUMP FROM ADDRESS                       *\n         AL    R2,=F'256'     BUMP TO ADDRESS                         *\n         SL    R3,=F'256'     DECREMENT THE LENGTH                    *\n         B     FN21           GO BACK AND GET MORE                    *\nFN22     BAS   R8,DISABLE ---------------------------------- * DANGER *\n         XR    R1,R1\n         TM    SWITCH,PVALID\n         BZ    FN30\n         L     R3,=A(PVBUF)\n         L     R1,=A(L'HXDATA)\n         B     *+L'*+4\nFN30     L     R3,=A(FNBUF)\n         L     R5,=A(4*KB)\n         TM    SWITCH,PVALID\n         BO    *+L'*+4\n         SL    R5,=A(L'HXDATA)\n         LA    R5,0(R5,R3)\n         ALR   R3,R7\n         CLR   R3,R5\n         BH    FN32\n         LA    R4,1\n         XR    R2,R2\n         IC    R2,STRNGL\nFN31     EX    R2,FNCLC       SEARCH A MATCH\n         BE    FN33\n         BXLE  R3,R4,FN31\nFN32     OI    SWITCH,PVALID\n         L     R3,=A(PVBUF)\n         MVC   0(L'HXDATA,R3),0(R5)\n         TM    SWITCH,ASFULL  ENTIRE A.S. SEARCH?\n         BO    FN36           YES\n         MVC   ADVICE,=CL5'<--NF'\n         LR    R3,R5\n         B     FN34\nFN33     NI    SWITCH,255-PVALID\n         MVC   ADVICE,=CL5'FOUND'\nFN34     L     R14,=A(HXDATA)\n         MVC   0(L'HXDATA,R14),0(R3)\n         ALR   R3,R1          COMPUTE DISPLACEMENT\n         SL    R3,=A(FNBUF)\n         SLR   R6,R1          REAL ADDRESS OF MATCH\n         LA    R6,0(R6,R3)\n         ST    R6,DATA\n         ST    R6,CRPTR\n         TM    FSCRSW,FSCRSF  FULL SCREEN?\n         BO    *+L'*+8        YES\n         L     R10,=A(DSPLY)\n         DROP  R10\n         USING DSPLY,R10\n         B     DSPLY4\n         DROP  R10\n         USING FIND,R10\n         CLC   ADVICE,=CL5'FOUND'\n         BNE   FN35\n         TM    SWITCH,POPXMR  WAS PREVIOUS OP. X-MEM. REF. MODE?\n         BZ    *+L'*+4        NO\n         OI    SWITCH,XMEMRF  YES, CONTINUE IN X-MEM. REF. MODE\n         L     R10,=A(DSPLY)\n         DROP  R10\n         USING DSPLY,R10\n         B     DSPLY2\n         DROP  R10\n         USING FIND,R10\nFN35     LA    R1,L'HXDATA(R6)\n         ST    R1,CRPTR       CURRENT POINTER\n         ST    R6,PVPTR       PREVIOUS POINTER\n         SRL   R6,4           SET ADDRESS FOR WORK\n         SLL   R6,4\n         ST    R6,BLKPTR\n         LA    R4,1\n         MVC   WDSPT,DATA\n         L     R10,=A(DSPLY)\n         DROP  R10\n         USING DSPLY,R10\n         B     DSPLY5\n         DROP  R10\n         USING FIND,R10\nFN36     SL    R5,=A(FNBUF)   COMPUTE DISPLACEMENT\n         LA    R6,L'HXDATA(R6,R5)  COMPUTE REAL ADDRESS\nFN37     TM    WRPTR,X'80'    FIRST TIME?\n         BZ    *+L'*+8        NO\n         NI    WRPTR,X'7F'\n         B     FN40\n         CL    R6,WRPTR       END OF A.S. SEARCH?\n         BNE   FN40           NO\n        @SEND  NFNDAS\n         B     INQUIRT\nFN40     ST    R6,CRPTR       UPDATE POINTERS\n         ST    R6,PVPTR\n         TM    STATUS,TSORUN\n         BZ    FN41\n         TM    FSCRSW,FSCRSF\n         BZ    FN41\n         LR    R4,R6\n         SRL   R4,18\n         CL    R4,CFFPTR\n         BNE   FN50\n         L     R4,=A(256*KB)  COMPUTE NEW CONTROL ADDRESS\n         LA    R4,0(R4,R6)\n         SRL   R4,18\n         ST    R4,CFFPTR\n         OI    OPERSW,FFSTUP\n         L     R10,=A(INFST)  GO GET INFO STATUS\n         BR    R10\nFN41     OI    OPERSW,FFSTUP\n         B     INQUIRY        GET COMMAND INPUT IF ANY\nFNFLC    L     R6,CRPTR\nFN50     TM    SWITCH,POPXMR  WAS PREVIOUS OP. X-MEM. REF. MODE?\n         BZ    FNCNT          NO\n         OI    SWITCH,XMEMRF  YES, CONTINUE IN X-MEM. REF. MODE\n         B     FNCNT\nFNCLC    CLC   STRNG(*-*),0(R3)    <<EXECUTED>>\n         SPACE 1\n        @END   ,\n         EJECT\nMMTK    @INIT  MEMORIZE\n         SPACE 1\n***********************************************************************\n*        MEMORIZE - BUILD A TANK USER-AREA.                           *\n***********************************************************************\n         SPACE 1\n         MVC   CRPTR,PVPTR    ADJUST POINTERS FOR AFTER\n         TM    STATUS,TESTRUN\n         BZ    *+L'*+6\n         MVC   RCVIND(L'RCVIND),ALLBLKS\n         BAS   R14,NEXTCH     POSITION TO NEXT\n         B     MMTK40         + 0\n         CLI   0(R3),C'@'     + 4 - TANK NUMBER?\n         BE    MMTK10         YES\n         OC    CATKWA,CATKWA  HOW CURRENT TANK?\n         BZ    ERR11          NONE\n         CLI   0(R3),C'Z'     RESET CURRENT TO ZEROS?\n         BE    MMTK30         YES\n         CLI   0(R3),C'R'     RESET CURRENT TO BLANKS?\n         BE    MMTK31         YES\n         CLI   0(R3),C'L'     SET TEXT LENGTH?\n         BE    MMTK35         YES\n         NI    STATUS,255-SUBSTRCT\n         CLI   0(R3),C'+'     POINTER ADJUSTEMENT?\n         BE    MMTK21         YES\n         CLI   0(R3),C'-'     POINTER ADJUSTEMENT?\n         BE    MMTK20         YES\n*        --------------------------------------------------------------\n*        M HHHH,...  OR '...' COMMAND.\n*        --------------------------------------------------------------\n         CLI   0(R3),C''''    CHARACTERS STORE?\n         BE    MMTK6          YES\n         LA    R6,TBUF\n         XR    R7,R7\nMMTK1    XC    DATA,DATA      GET HEX DATA\n         LA    R1,L'DATA\n         LR    R2,R3          START OF DATA FIELD\nMMTK2    CLI   0(R3),C','     DELIMITER ,?\n         BE    MMTK4          YES\n         CLI   0(R3),C' '     END OF DATA?\n         BE    MMTK4          YES\n         CLI   0(R3),C'A'\n         BL    ERR17\n         CLI   0(R3),C'9'\n         BH    ERR17\n         CLI   0(R3),C'0'\n         BNL   MMTK3\n         CLI   0(R3),C'F'\n         BH    ERR17\nMMTK3    BXLE  R3,R4,*+L'*+4  INCREMENT POINTER\n         B     MMTK4\n         BCT   R1,MMTK2\nMMTK4    LR    R1,R3\n         SR    R1,R2          COMPUTE NUMBER OF CHARACTERS\n         BP    MMTK5          SKIP MOVE IF ZERO\n         CLR   R3,R5\n         BH    MMTK8\n         BAS   R14,NEXTCH     POSITION TO NEXT\n         B     MMTK8          +0 - NO MORE DATA\n         B     MMTK1          +4 - CONTINUE\nMMTK5    STC   R1,TSTBT\n         TM    TSTBT,X'01'\n         BO    ERR18\n         BCTR  R1,0           DECREMENT BY 1\n         XC    FXLAB,FXLAB    CLEAR WORK AREA\n         EX    R1,MMMWA       MOVE TO WORK AREA\n         EX    R1,MMNFT       NORMALIZE FOR TRANSLATE\n         EX    R1,MMTTB       TRANSLATE TO BINARY\n         LA    R1,1(R1)       INCR. BY 1\n         EX    R1,MMCTH       CONVERT TO HEX\n         LR    R14,R1\n         SRL   R14,1\n         LA    R15,DATA+L'DATA\n         SLR   R15,R14\n         EX    R14,MMDTA      SET DATA IN TEMPORARY AREA\n         ALR   R6,R14\n         ALR   R7,R14\n         CLR   R3,R5\n         BH    MMTK8\n         BAS   R14,NEXT       POSITION TO NEXT\n         B     MMTK8          +0 - NO MORE DATA\n         B     MMTK1          +4 - CONTINUE\nMMTK6    BXLE  R3,R4,*+L'*+4\n         B     ERR2\n         LR    R6,R3          HANDLE THE CHARACTERS STRING\n         LR    R7,R5\nMMTK7    CLI   0(R7),C''''\n         BE    *+L'*+10\n         CLR   R7,R6\n         BNH   ERR35\n         BCT   R7,MMTK7\n         SR    R7,R6\n         LR    R15,R6\n         B     MMTK8+L'MMTK8\nMMTK8    LA    R15,TBUF\n         LTR   R7,R7\n         BNP   ERR2\n         L     R2,CATKWA\n         USING TKWA,R2\n         L     R6,TKWPT\n         LR    R1,R6\n         AR    R1,R7\n         CH    R1,=H'256'\n         BH    ERR3           TOO LONG, TANK OVERFLOW\n         LR    R0,R1\n         BL    *+L'*+2\n         BCTR  R1,0\n         ST    R1,TKWPT       NEW TEXT POINTER\n         CL    R0,TKWDL\n         BNH   *+L'*+4\n         ST    R0,TKWDL       NEW TEXT LENGTH\n         LA    R6,TKWTX(R6)\n         BCTR  R7,0\n         EX    R7,MMDTA       MOVE TEXT IN TANK\n         DROP  R2\n         B     MMTK41\n*        --------------------------------------------------------------\n*        M @N COMMAND.\n*        --------------------------------------------------------------\nMMTK10   BAS   R14,NEXTCH     POSITION TO NEXT\n         B     ERR2           +0 - NO MORE DATA\n         XR    R2,R2          +4 - GET TANK NUMBER\n         LA    R0,15\nMMTK11   CLI   0(R3),C'0'     NUMERIC?\n         BL    ERR4\n         CLI   0(R3),C'9'\n         BH    ERR4\n         IC    R1,0(R3)       COMPUTE NUMBER\n         NR    R1,R0\n         LTR   R2,R2\n         BZ    *+L'*+4\n         MH    R2,=H'10'\n         AR    R2,R1\n         CH    R2,=Y(NTKWAS)\n         BH    ERR4\n         BXLE  R3,R4,*+L'*+4  TO NEXT\n         B     *+L'*+8        NO MORE DATA\n         CLI   0(R3),C' '     END?\n         BNE   MMTK11         NO, CONTINUE\n         LTR   R2,R2\n         BNP   ERR4\n         CVD   R2,DBLWD\n         MVC   CTKWAN,=XL4'40202120'\n         ED    CTKWAN,DBLWD+6 NEW CURRENT TANK NUMBER\n         LA    R1,CTKWAN+L'CTKWAN-2\n         CLI   0(R1),C' '\n         BE    *+L'*+4\n         BCT   R1,*-8\n         MVI   0(R1),C'@'\n         BCTR  R2,0\n         MH    R2,=Y(TKWAL)\n         AL    R2,ATKWAS\n         ST    R2,CATKWA      CURRENT TANK ADDRESS\n         B     MMTK41\n*        --------------------------------------------------------------\n*        M + OR - XX COMMAND.\n*        --------------------------------------------------------------\nMMTK20   OI    STATUS,SUBSTRCT\nMMTK21   BAS   R14,NEXTCH     POSITION TO NEXT\n         B     ERR9           +0\n         BAS   R8,MMTKRT      +4 - GET DISPLACEMENT\n         L     R0,DATA        GET DISPLACEMENT VALUE\n         L     R2,CATKWA\n         USING TKWA,R2\n         L     R1,TKWPT       GET CURRENT TEXT POINTER\n         TM    STATUS,SUBSTRCT     APPLY DISPLACEMENT\n         BO    *+L'*+6\n         AR    R1,R0\n         B     *+L'*+2\n         SR    R1,R0\n         LTR   R1,R1          CONTROL\n         BNM   *+L'*+2\n         XR    R1,R1\n         CH    R1,=H'256'\n         BL    *+L'*+4\n         LA    R1,255\n         ST    R1,TKWPT       NEW TEXT POINTER\n         DROP  R2\n         B     MMTK41\n*        --------------------------------------------------------------\n*        M Z OR R COMMAND.\n*        --------------------------------------------------------------\nMMTK30   L     R2,CATKWA\n         USING TKWA,R2\n         XC    TKWTX,TKWTX    RESET TO ZEROS\n         B     MMTK32\nMMTK31   L     R2,CATKWA\n         MVI   TKWTX,C' '     RESET TO BLANKS\n         MVC   TKWTX+1(L'TKWTX-1),TKWTX\nMMTK32   XC    TKWPT,TKWPT\n         XC    TKWDL,TKWDL\n         DROP  R2\n         B     MMTK41\n*        --------------------------------------------------------------\n*        M L XX COMMAND.\n*        --------------------------------------------------------------\nMMTK35   BAS   R14,NEXTCH     POSITION TO NEXT\n         B     ERR2           +0 - NO MORE DATA\n         BAS   R8,MMTKRT      +4 - GET NEW LENGTH\n         L     R1,DATA        GET LENGTH VALUE\n         LH    R0,=H'256'\n         CLR   R1,R0          CONTROL\n         BNH   *+L'*+2\n         LR    R1,R0\n         L     R2,CATKWA\n         USING TKWA,R2\n         ST    R1,TKWDL       NEW LENGTH\n         DROP  R2\n         B     MMTK41\n*        --------------------------------------------------------------\n*        M COMMAND - DISPLAY CURRENT USER-AREA.\n*        --------------------------------------------------------------\nMMTK40   OC    CATKWA,CATKWA  HOW CURRENT TANK?\n         BZ    ERR11          NONE\nMMTK41   L     R6,CATKWA      DISPLAY DATA IN TANK\n         USING TKWA,R6\n         TM    FSCRSW,FSCRSF  FULL SCREEN?\n         BO    MMTK50         YES\n         LA    R2,MSGTXT\n         MVC   MSGTXT(L'MSGTXT),ALLBLKS\n         L     R3,TKWPT\n         LTR   R3,R3\n         BZ    MMTK42\n         SRL   R3,4\n         SLL   R3,4\n         CL    R3,TKWPT\n         BNE   MMTK42\n         SL    R3,=A(L'HXDATA)\nMMTK42   ST    R3,DATA\n         LA    R3,TKWTX(R3)\n         LA    R1,TBUF\n         MVC   0(L'HXDATA,R1),0(R3)\n         USING CONSLOUT,R2\n         UNPK  CONSL1(L'CONSL1+1),DATA(5)\n         TR    CONSL1(L'CONSL1),HEXTAB-X'F0'\n         MVI   CONSL1+L'CONSL1,C' '\n         MVI   CONSL2,C':'\n         UNPK  CONSL3(L'CONSL3+1),0(5,R1)\n         TR    CONSL3(L'CONSL3),HEXTAB-X'F0'\n         MVI   CONSL3+L'CONSL3,C' '\n         UNPK  CONSL4(L'CONSL4+1),4(5,R1)\n         TR    CONSL4(L'CONSL4),HEXTAB-X'F0'\n         MVI   CONSL4+L'CONSL4,C' '\n         UNPK  CONSL5(L'CONSL5+1),8(5,R1)\n         TR    CONSL5(L'CONSL5),HEXTAB-X'F0'\n         MVI   CONSL5+L'CONSL5,C' '\n         UNPK  CONSL6(L'CONSL6+1),12(5,R1)\n         TR    CONSL6(L'CONSL6),HEXTAB-X'F0'\n         MVI   CONSL6+L'CONSL6,C' '\n         MVI   CONSL7,C'*'\n         MVC   CONSL8(L'HXDATA),0(R1)\n         L     R1,=A(CHARTB)\n         TR    CONSL8,0(R1)\n         MVI   CONSL9,C'*'\n         DROP  R2\n        @SEND  MSGOUT,OP=LA\n         B     INQUIRY\nMMTK50   MVC   WDSPT,TKWPT\n         LA    R3,TKWTX\n         LA    R2,MSGSVT\n         LA    R4,L'TKWTX/L'HXDATA NUMBER OF LINES TO DISPLAY\n         XC    WDSLN,WDSLN\n         XC    FSPOINT,FSPOINT     SAY DATA LINES\n         OI    FSCRSW,FSCRSL\nMMTK51   MVC   MSGSVT(L'MSGSVT),ALLBLKS\n         USING FSLOUT,R2\n         UNPK  FSL1(L'FSL1+1),WDSLN(5)\n         TR    FSL1(L'FSL1),HEXTAB-X'F0'\n         MVI   FSL1+L'FSL1,C' '\n         LA    R0,4\n         LA    R1,FSL2\n         LR    R14,R3\nMMTK52   UNPK  TBUF(9),0(5,R14)\n         TR    TBUF(8),HEXTAB-X'F0'\n         MVC   1(4,R1),TBUF\n         MVC   6(4,R1),TBUF+4\n         BCT   R0,*+L'*+4\n         B     MMTK53\n         LA    R1,L'FSL2(R1)\n         LA    R14,4(R14)\n         B     MMTK52\nMMTK53   MVI   FSL3,C'|'\n         MVC   FSL4(L'HXDATA),0(R3)\n         L     R1,=A(CHARTB)\n         TR    FSL4,0(R1)\n         MVI   FSL5,C'|'\n         L     R1,WDSLN\n         AL    R1,=A(L'HXDATA)\n         CLC   WDSPT,WDSLN\n         BL    MMTK54\n         BE    *+L'*+8\n         CL    R1,WDSPT\n         BNH   MMTK54\n         L     R1,WDSPT\n         SL    R1,WDSLN\n         SLL   R1,1\n         AL    R1,=A(FSTAPD)\n         XR    R0,R0\n         IC    R0,0(R1)\n         LA    R14,FSLOUT\n         ALR   R14,R0\n         MVC   0(1,R14),1(R1) MARK CURRENT ADDRESS POINTER\n         OI    FSCRSW,FSCRSI  SAY INTENSIVE LINE\n         L     R1,WDSLN\n         AL    R1,=A(L'HXDATA)\nMMTK54   ST    R1,WDSLN\n        @SEND  MSGSVTO,OP=LA\n         AL    R3,=A(L'HXDATA)\n         BCT   R4,MMTK51\n         DROP  R2\n         NI    FSCRSW,255-FSCRSL   RESET DATA\n         MVC   FSCRSCL,=CL54'ADDRESS+    0 1  2 3   4 5  6 7   8 9  A B1\n                  C D  E F '       SET SCALE\n         MVC   FSCRMSG(11),=CL11'USER-AREA :'\n         MVC   FSCRMSG+12(L'CTKWAN),CTKWAN\n         MVC   FSCRMSG+L'CTKWAN+13(10),=CL10'- LENGTH :'\n         UNPK  DBLWD(5),TKWDL+2(3)\n         TR    DBLWD+1(3),HEXTAB-X'F0'\n         MVC   FSCRMSG+L'CTKWAN+24(3),DBLWD+1\n         DROP  R6\n         B     INQUIRT\n         SPACE 1\nMMTKRT   XC    DATA,DATA      GET DISPLACEMENT ROUTINE\n         LA    R1,L'DATA\n         LR    R2,R3\nMMTKRT1  CLI   0(R3),C' '     SCAN HEX DIGITS\n         BE    MMTKRT3\n         CLI   0(R3),C'A'\n         BL    ERR17\n         CLI   0(R3),C'9'\n         BH    ERR17\n         CLI   0(R3),C'0'\n         BNL   MMTKRT2\n         CLI   0(R3),C'F'\n         BH    ERR17\nMMTKRT2  BXLE  R3,R4,*+L'*+4  INCREMENT POINTER\n         B     MMTKRT3\n         BCT   R1,MMTKRT1\n         B     ERR3\nMMTKRT3  LR    R1,R3\n         SR    R1,R2\n         BCTR  R1,0           DECREMENT BY 1\n         XC    FXLAB,FXLAB    CLEAR WORK AREA\n         EX    R1,MMMWA       MOVE TO WORK AREA\n         EX    R1,MMNFT       NORMALIZE FOR TRANSLATE\n         EX    R1,MMTTB       TRANSLATE TO BINARY\n         LA    R1,1(R1)       INCR. BY 1\n         EX    R1,MMCTH       CONVERT TO HEX\n         BR    R8             RETURN\n         SPACE 1\nMMMWA    MVC   FXLAB(*-*),0(R2)    <<EXECUTED>>\nMMNFT    NC    FXLAB(*-*),=XL8'1F1F1F1F1F1F1F1F'  <<EXECUTED>>\nMMTTB    TR    FXLAB(*-*),TRANTBL  <<EXECUTED>>\nMMCTH    PACK  DATA(L'DATA+1),FXLAB(*-*)     <<EXECUTED>>\nMMDTA    MVC   0(*-*,R6),0(R15)    <<EXECUTED>>\n         SPACE 1\n        @END   ,\n         EJECT\nASSGN   @INIT  ASSIGN\n         SPACE 1\n***********************************************************************\n*        ASSIGN - DELETE LABELS COMMANDS.                             *\n***********************************************************************\n         SPACE 1\n         BAS   R14,NEXTCH     POSITION TO NEXT\n         B     ERR5           +0\n         BAS   R14,LABEL      +4 - GET LABEL\n         B     ERR5                +0\n         B     ERR7                +4\n         B     ERR6                +8\n         B     ERR26               +12\n         MVC   ASSNME,LBLF         +16\n         BAS   R14,NEXT       POSITION TO NEXT\n         B     ASS20          +0 - SET TO ACTUAL DATA POINTER\n         BAS   R14,LABEL      +4 - GET LABEL\n         B     ERR2                +0\n         B     ASS2                +4 - MAY BE HEX ADDRESS\n         B     ERR6                +8\n         B     ASS3                +12\n         BAS   R14,NEXT            +16 - POSITION TO NEXT\n         B     ASS1                      +0\n         CLI   0(R3),C'/'                +4\n         BNE   ASS1\n         BAS   R14,NEXTCH     POSITION TO NEXT\n         B     ERR37          +0\n         BAS   R14,NAMER      +4 - GET DSECT-NAME\n         B     ERR37               +0\n         B     ERR38               +4\n         B     ERR39               +8\n         MVC   DRFDSCT,NMEF        +12 - DSECT NAME\n         MVC   DRFFLDN,LBLF   FIELD NAME\n         MVC   LBLF,NMEF\n         BAS   R14,SCITBL     PREDEFINED LABELS\n         B     *+L'*+4        +0\n         BAS   R14,SCLTBL     +4 - LABELS\n         ICM   R6,B'1111',L'LBLF(R7)    SET ADDRESS\n         XC    DRFDSPL(L'DRFDSPL+L'DRFLNGH),DRFDSPL\n         MVC   DRFFLGN(L'DRFFLGN),ALLBLKS\n         XC    DRFFLVL(L'DRFFLVL+L'DRFFLLG),DRFFLVL\n         LA    R0,1           ASK SEARCH\n         L     R15,=A(DRFCALL)\n         BASR  R14,R15\n         B     *+L'*(R15)\n         B     *+L'*+8        +0\n         B     *+L'*+4        +4\n         B     ERROR          +8\n         XR    R0,R0\n         ICM   R0,B'0011',DRFDSPL  SET DISPLACEMENT\n         ALR   R6,R0          COMPUTE ADDRESS\n         B     ASS3+L'ASS3\nASS1     BAS   R14,SCLTBL\n         B     ASS3\nASS2     CLI   0(R3),C'.'     HEX ADDRESS?\n         BNE   *+L'*+8\n         BAS   R14,NEXTCH     POSITION TO NEXT\n         B     ERR2           +0\n         BAS   R14,SCAN       +4 - GET ADDRESS\n         B     ERR2                +0\n         B     ERR17               +4\n         B     ERR3                +8\n         L     R6,DATA             +12 - SET ADDRESS\n         B     ASS3+L'ASS3\nASS3     ICM   R6,B'1111',L'LBLF(R7)    SET ADDRESS\n         NI    STATUS,255-SUBSTRCT\n         BAS   R14,NEXT       POSITION TO NEXT\n         B     ASSGN0         +0 - NO DISPLACEMENT\n         CLI   0(R3),C'+'     +4 - TEST IF DELIMITER\n         BE    ASS4\n         CLI   0(R3),C'-'\n         BNE   ERR10\n         OI    STATUS,SUBSTRCT\nASS4     BAS   R14,NEXTCH     POSITION TO NEXT\n         B     ERR9           +0\n         BAS   R14,LABEL      +4 - GET DISPLACEMENT\n         B     ERR9                +0\n         B     ASS6                +4 - MAY BE HEX DISPLACEMENT\n         B     ERR6                +8\n         B     ASS5+L'ASS5         +12\n         BAS   R14,NEXT            +16 - POSITION TO NEXT\n         B     ASS5                      +0\n         CLI   0(R3),C'/'                +4\n         BNE   ERR37\n         BAS   R14,NEXTCH     POSITION TO NEXT\n         B     ERR37          +0\n         BAS   R14,NAMER      +4 - GET DSECT-NAME\n         B     ERR37               +0\n         B     ERR38               +4\n         B     ERR39               +8\n         MVC   DRFDSCT,NMEF        +12 - DSECT NAME\n         MVC   DRFFLDN,LBLF   FIELD NAME\n         XC    DRFDSPL(L'DRFDSPL+L'DRFLNGH),DRFDSPL\n         MVC   DRFFLGN(L'DRFFLGN),ALLBLKS\n         XC    DRFFLVL(L'DRFFLVL+L'DRFFLLG),DRFFLVL\n         LA    R0,1           ASK SEARCH\n         L     R15,=A(DRFCALL)\n         BASR  R14,R15\n         B     *+L'*(R15)\n         B     *+L'*+8        +0\n         B     *+L'*+4        +4\n         B     ERROR          +8\n         XR    R0,R0\n         ICM   R0,B'0011',DRFDSPL  SET DISPLACEMENT\n         B     ASS10\nASS5     BAS   R14,SCLTBL\n         ICM   R0,B'1111',L'LBLF(R7)    SET DISPLACEMENT\n         B     ASS10\nASS6     CLI   0(R3),C'.'     HEX DISPLACEMENT?\n         BNE   *+L'*+8\n         BAS   R14,NEXTCH     POSITION TO NEXT\n         B     ERR9           +0\n         BAS   R14,SCAN       +4 - GET DISPLACEMENT\n         B     ERR9                +0\n         B     ERR17               +4\n         B     ERR3                +8\n         L     R0,DATA             +12\nASS10    TM    STATUS,SUBSTRCT     APPLY DISPLACEMENT\n         BO    *+L'*+6\n         ALR   R6,R0\n         B     *+L'*+2\n         SLR   R6,R0\n         LA    R6,0(R6)\n         B     ASSGN0\nASS20    CLI   PRVOP,C'S'\n         BE    *+L'*+8\n         L     R6,PVPTR\n         B     ASSGN0\n         L     R6,CRPTR\nASSGN0   ST    R6,DATA\n         LM    R3,R5,TBVAL    SCAN LABELS TABLE\n         LR    R2,R5\n         ALR   R2,R4\n         CLR   R5,R3\n         BL    ASSGN3\nASSGN1   CLC   0(L'ASSNME,R3),ASSNME\n         BNE   ASSGN2\n         MVC   L'ASSNME(L'DATA,R3),DATA\n         B     ASSGN4\nASSGN2   BXLE  R3,R4,ASSGN1\n         CL    R2,=A(TABLEND)\n         BNL   ERR8\nASSGN3   MVC   0(L'ASSNME,R2),ASSNME\n         MVC   L'ASSNME(L'DATA,R2),DATA\n         ST    R2,TBVAL+8\nASSGN4   MVI   PRVOP,C'D'\n         MVC   PVPTR,DATA     PREVIOUS POINTER\n         MVC   CRPTR,PVPTR    CURRENT POINTER\n         B     SRTTB\n         SPACE 1\nDELET    MVC   CRPTR,PVPTR    ADJUST POINTERS FOR AFTER\n         CLC   TBVAL+8(4),TBVAL\n         BL    ERR19\n         BAS   R14,NEXTCH     POSITION TO NEXT\n         B     ERR5           +0\n         BAS   R14,LABEL      +4 - GET LABEL\n         B     ERR5                +0\n         B     ERR7                +4\n         B     ERR6                +8\n         B     ERR26               +12\n         LM    R3,R5,TBVAL         +16 - SCAN LABELS TABLE\nDELET1   CLC   0(L'LBLF,R3),LBLF\n         BE    DELET2\n         BXLE  R3,R4,DELET1\n         B     ERR20\nDELET2   L     R2,TBVAL+8\n         CLR   R2,R3\n         BE    DELET3\n         MVC   0(TBELL,R3),0(R2)   REPLACE BY LAST\nDELET3   XC    0(TBELL,R2),0(R2)\n         SL    R2,TBVAL+4\n         ST    R2,TBVAL+8\n         SPACE 1\nSRTTB    CLC   TBVAL+8(4),TBVAL\n         BNH   INQUIRT        TABLE EMPTIED OR JUST ONE\n         LM    R4,R6,TBVAL    SORT LABELS TABLE\n         XR    R2,R2\n         LA    R3,0(R5,R6)\n         SR    R3,R4\n         DR    R2,R5\n        $SORT  (R4),(R3),L'TABLE,0,L'LBLF\n         B     INQUIRT\n         SPACE 1\n        @END   ,\n         EJECT\nPRDEF   @INIT  LABELS\n         SPACE 1\n***********************************************************************\n*        LIST EXTERNAL/INTERNAL LABELS COMMANDS.                      *\n***********************************************************************\n         SPACE 1\n         MVC   CRPTR,PVPTR    ADJUST POINTERS FOR AFTER\n         NI    STATUS,255-ONELSTD-MATCHREQ\n         LM    R3,R5,SCFIX    SCAN PREDEFINED LABELS TABLE\n         TM    FSCRSW,FSCRSF  FULL SCREEN?\n         BZ    LIST2          NO\n         XC    FSPOINT,FSPOINT     YES, SAY DATA LINES\n         OI    FSCRSW,FSCRSL\n         B     LIST2\nPRDEF1   LR    R2,R1\n         MVC   MSGTXT(L'MSGTXT),ALLBLKS\n         LA    R6,MSGTXT\n         USING CNSLOUT,R6\n         MVC   CNSLLB(L'CNSLLB),LBLF\n         MVI   CNSLLS,C':'\n         MVC   DATA(L'DATA),L'LBLF(R7)\n         UNPK  CNSLAD(L'CNSLAD+1),DATA(L'DATA+1)\n         TR    CNSLAD(L'CNSLAD),HEXTAB-X'F0'\n         MVC   CNSLAD+L'CNSLAD(20),=CL20' (PREDEFINED LABEL)'\n         DROP  R6\n         BAS   R9,LISTOUT\n         OI    STATUS,ONELSTD\n         B     LIST0\nLIST     MVC   CRPTR,PVPTR    ADJUST POINTERS FOR AFTER\n         NI    STATUS,255-ONELSTD-MATCHREQ\n         TM    FSCRSW,FSCRSF  FULL SCREEN?\n         BZ    *+L'*+10       NO\n         XC    FSPOINT,FSPOINT     YES, SAY DATA LINES\n         OI    FSCRSW,FSCRSL\n         BAS   R14,NEXTCH     POSITION TO NEXT\n         B     LIST1          +0\n         BAS   R14,LABEL      +4 - GET LABEL OR MATCH STRING\n         B     LIST1               +0\n         B     ERR7                +4\n         B     ERR6                +8\n         B     PRDEF1              +12\n         LR    R2,R1               +16\nLIST0    OI    STATUS,MATCHREQ\nLIST1    CLC   TBVAL+8(4),TBVAL\n         BL    ERR19\n         LM    R3,R5,TBVAL    SCAN LABELS TABLE\nLIST2    MVC   MSGTXT(L'MSGTXT),ALLBLKS\n         LA    R6,MSGTXT\n         USING CNSLOUT,R6\n         LA    R7,3\nLIST3    TM    STATUS,MATCHREQ\n         BZ    LIST5\nLIST4    EX    R2,CMTCH\n         BE    LIST5\n         BXLE  R3,R4,LIST4\n         B     LIST7\nCMTCH    CLC   0(*-*,R3),LBLF      <<EXECUTED>>\nLIST5    MVC   CNSLLB(L'CNSLLB),0(R3)\n         MVI   CNSLLS,C':'\n         UNPK  CNSLAD(L'CNSLAD+1),L'LBLF(L'DATA+1,R3)\n         TR    CNSLAD(L'CNSLAD),HEXTAB-X'F0'\n         MVI   CNSLAD+L'CNSLAD,C' '\n         DROP  R6\n         LA    R6,CNSLBL(R6)\n         BXLE  R3,R4,LIST6\n         B     LIST7\nLIST6    BCT   R7,LIST3\n         BAS   R9,LISTOUT\n         OI    STATUS,ONELSTD\n         B     LIST2\nLIST7    CLC   MSGTXT(L'MSGTXT),ALLBLKS\n         BE    LIST8\n         BAS   R9,LISTOUT\n         B     *+L'*+8\nLIST8    TM    STATUS,ONELSTD\n         BZ    ERR20\n         TM    FSCRSW,FSCRSF  FULL SCREEN?\n         BZ    INQUIRY        NO\n         NI    FSCRSW,255-FSCRSL   YES, RESET DATA\n         L     R10,=A(INFST)\n         DROP  R10\n         USING INFST,R10\n         B     INFST0         GO GET STATUS\n         SPACE 1\n        @END   ,\n         EJECT\nTEST    @INIT  ,\n         SPACE 1\n***********************************************************************\n*        TEST ON/OFF AND LINE/SCREEN COMMAND.                         *\n***********************************************************************\n         SPACE 1\n         MVC   CRPTR,PVPTR    ADJUST POINTERS FOR AFTER\n         CLI   AUTH,LV15      AUTHORIZED?\n         BL    ERR22          NO\n         BAS   R14,NEXTCH     POSITION TO NEXT\n         B     ERR4                +0\n         CLC   0(4,R3),=CL4'OFF'   +4 - TEST OPERAND\n         BE    TESTOFF\n         CLC   0(3,R3),=CL3'ON'\n         BE    TESTON\n         CLI   0(R3),C'L'\n         BE    TESTLNE\n         CLI   0(R3),C'S'\n         BE    TESTSCR\n         TM    SGTPSW,STPDIS       SEGMENT-TABLE PROCESS DISABLED?\n         BO    ERR49               YES\n         CLI   0(R3),C'Y'\n         BE    TESTYES\n         CLI   0(R3),C'N'\n         BE    TESTNO\n         B     ERR4\nTESTON   MVC   MSGTXT(L'MSGTXT),ALLBLKS\n         MVC   MSGTXT(8),VCOREZAP+10\n         MVI   MSGTXT+9,C':'\n         ST    R12,DATA\n         UNPK  MSGTXT+11(9),DATA(5)\n         TR    MSGTXT+11(8),HEXTAB-X'F0'\n         MVI   MSGTXT+19,C' '\n         MVC   MSGTXT+22(10),=CL10'V.TABLE  :'\n         UNPK  MSGTXT+33(9),TBVAL(5)\n         TR    MSGTXT+33(8),HEXTAB-X'F0'\n         MVI   MSGTXT+41,C' '\n         MVC   MSGTXT+44(10),=CL10'V.FIXED  :'\n         UNPK  MSGTXT+55(9),SCFIX(5)\n         TR    MSGTXT+55(8),HEXTAB-X'F0'\n         MVI   MSGTXT+63,C' '\n        @SEND  MSGOUT,OP=LA\n         OI    STATUS,TESTRUN\n         B     INQUIRT\nTESTOFF  NI    STATUS,255-TESTRUN\n         B     INQUIRT\nTESTLNE  TM    STATUS,TSORSC  ARE WE IN TSO ON A SCREEN?\n         BZ    ERR21          NO\n         TM    FSCRSW,FSCRSF  FULL SCREEN?\n         BZ    ERR21          NO, ALREADY LINE WORKING\n         L     R15,=A(FSCLEAR)\n         BASR  R8,R15         RESET FULL SCREEN\n         TM    HCPRSW,HCCOPY  IS HARDCOPY ACTIVE?\n         BZ    INQUIRY        NO\n         OI    HCPRSW,HCANSR\n         L     R15,=A(HCOPYSC)     HARDCOPY COMMAND\n         BASR  R14,R15\n         B     INQUIRY\nTESTSCR  TM    STATUS,TSORSC  ARE WE IN TSO ON A SCREEN?\n         BZ    ERR21          NO\n         TM    FSCRSW,FSCRSF  FULL SCREEN?\n         BO    ERR21          YES, ALREADY SCREEN WORKING\n         L     R15,=A(FSSETFS)     NO\n         BASR  R8,R15         SET FULL SCREEN\n         L     R10,=A(INFST)\n         DROP  R10\n         USING INFST,R10\n         B     INFST0         GO GET STATUS\nTESTYES  NI    SGTPSW,255-STPUSE\n         B     INQUIRT\nTESTNO   OI    SGTPSW,STPUSE\n         B     INQUIRT\n         SPACE 1\n         DROP  R10\n         EJECT\n***********************************************************************\n*        CONTROL ON/OFF COMMAND.                                      *\n***********************************************************************\n         SPACE 1\n         USING TEST,R10       LOCAL ADDRESSABILITY\nCNTRL    MVC   CRPTR,PVPTR    ADJUST POINTERS FOR AFTER\n         CLI   AUTH,LV5       AUTHORIZED?\n         BL    ERR22          NO\n         BAS   R14,NEXTCH     POSITION TO NEXT\n         B     ERR4                +0\n         CLC   0(4,R3),=CL4'OFF'   +4 - TEST OPERAND\n         BE    CNTRLOFF\n         CLC   0(3,R3),=CL3'ON'\n         BNE   ERR4\n         OI    STATUS,DANGER\n        @SEND  ENBLM\n         B     INQUIRT\nCNTRLOFF NI    SWITCH,255-VASTB    KILL VALID TABLE\n         BAS   R8,DEACTIV     RESET AS-ID MODE IF ANY\n         NI    STATUS,255-DANGER\n        @SEND  DSBLM\n         B     INQUIRT\n         EJECT\n***********************************************************************\n*        DISPLAY ADDRESS SPACE SEGMENT-TABLE COMMAND.                 *\n***********************************************************************\n         SPACE 1\nSGVIEW   CLI   AUTH,LV5            AUTHORIZED?\n         BL    ERR22               NO\n         TM    SGTPSW,STPDIS+STPUSE     YES, SEGMENT PROCESS DISABLED?\n         BNZ   ERR49               YES\n         OI    SGTPSW,STPLST       NO, SET DISPLAY REQUEST\n         L     R10,=A(SGTCHK)\n         BASR  R14,R10             GO DISPLAY SEGMENT-TABLE\n         B     INQUIRT             END OR ERROR\n         SPACE 1\n        @END   ,\n         EJECT\nASNID   @INIT  XM-REF\n         SPACE 1\n***********************************************************************\n*        ADDRESS SPACE (CROSS MEMORY REFERENCE) COMMANDS.             *\n***********************************************************************\n         SPACE 1\n         TM    STATUS,DANGER  AVAILABLE?\n         BZ    ERR22          NO\n         BAS   R14,NEXTCH     POSITION TO NEXT\n         B     ERR1           +0 - UNKNOWN\n         CLI   0(R3),C'H'     HELP\n         BE    XH0\n         TM    STATUS,TESTRUN\n         BZ    *+L'*+6\n         MVC   RCVIND(L'RCVIND),ALLBLKS\n         NI    SWITCH,255-POPXMR-ASFULL RESET X-MEM. MODE AND A.S.\n         CLI   0(R3),C'F'     FIND\n         BE    XF0\n         NI    SWITCH,255-PVALID   RESET PREVIOUS LAST DATA\n         CLI   0(R3),C'A'     +4 - ACTIVATE\n         BE    XA0\n         CLI   0(R3),C'C'     CLEAR AND RESET\n         BE    XC0\n         CLI   0(R3),C'D'     DISPLAY\n         BE    XD0\n         CLI   0(R3),C'F'     FIND\n         BE    XF0\n         TM    FSCRSW,FSCRSF  FULL SCREEN?\n         BZ    *+L'*+8        NO\n         CLI   0(R3),C'G'     GET\n         BE    XG0\n         CLI   0(R3),C'L'     LIST\n         BE    XL0\n         CLI   0(R3),C'R'     RESET\n         BE    XR0\n         CLI   0(R3),C'S'     STORE\n         BE    XS0\n         CLI   0(R3),C'T'     REFRESH/LOAD AND RESET\n         BE    XT0\n         B     ERR1\n*        --------------------------------------------------------------\n*        ACTIVATE AS-ID MODE FOR NEXT XD, XF AND XS COMMANDS.\n*        --------------------------------------------------------------\nXA0      MVC   CRPTR,PVPTR    ADJUST POINTERS FOR AFTER\n         TM    SWITCH,VASTB   VALID TABLE?\n         BZ    ERR13          NO\n         BAS   R14,NEXTCH     POSITION TO NEXT\n         B     ERR2           +0\n         BAS   R14,NAME       +4 - GET AS-NAME\n         B     ERR14               +0\n         B     XA5                 +4 - MAY BE AS-ID NO.\n         B     ERR15               +8\n         LM    R3,R5,SCASTB        +12 - SCAN AS-ID TABLE\nXA1      CLC   0+L'ASIDN(L'ASNME,R3),NMEF    THIS NAME?\n         BE    XA2            YES\n         BXLE  R3,R4,XA1      LOOP TO NEXT\n         B     ERR16          NOT FOUND\nXA2      LR    R2,R3          RETAIN THIS ONE\n         BXLE  R3,R4,XA3      LOOP TO NEXT\n         B     XA4            NO MORE, OK\nXA3      CLC   0+L'ASIDN(L'ASNME,R3),NMEF    THIS NAME?\n         BE    ERR27          YES, MULTIPLE ...\n         BXLE  R3,R4,XA3      LOOP TO NEXT\nXA4      LR    R3,R2          POINT TO AS-TABLE ENTRY\n         B     XA8\nXA5      CLI   0(R3),C'.'     HEX AS-ID NO.?\n         BNE   XA6\n         BAS   R14,NEXTCH     POSITION TO NEXT\n         B     ERR2           +0\nXA6      BAS   R14,SCAN       +4 - GET AS-ID NUMBER\n         B     ERR2                +0\n         B     ERR17               +4\n         B     ERR3                +8\n         CH    R1,=H'4'            +12\n         BH    ERR3\n         LM    R3,R5,SCASTB   SCAN AS-ID TABLE\nXA7      CLC   0(L'ASIDN,R3),DATA+2     THIS AS-ID NUMBER?\n         BE    XA8            YES\n         BXLE  R3,R4,XA7      LOOP TO NEXT\n         B     ERR16          NOT FOUND\nXA8      TM    SWITCH,ACTIVM  ALREADY ACTIVE MODE?\n         BZ    XA9            NO\n         CLC   0(L'ASIDN,R3),ASIDN SAME AS CURRENT?\n         BE    INQUIRT        YES, NO CHANGE NEEDED\n         BAS   R8,DEACTIV     NO, RESET AS-ID MODE\nXA9      MVC   ASIDN(L'ASIDN),0(R3)     MAKE THE CHANGE\n         MVC   ASNME(L'ASNME),0+L'ASIDN(R3)\n         BAS   R8,ACTIVE      SET NEW AS-ID MODE\n         B     INQUIRT\n*        --------------------------------------------------------------\n*        CLEAR AS-TABLE AND RESET AS-ID MODE.\n*        --------------------------------------------------------------\nXC0      MVC   CRPTR,PVPTR    ADJUST POINTERS FOR AFTER\n         NI    SWITCH,255-VASTB    KILL VALID TABLE\n         BAS   R8,DEACTIV     RESET AS-ID MODE\n         B     INQUIRT\n*        --------------------------------------------------------------\n*        DISPLAY IN ACTIVE AS-ID.\n*        --------------------------------------------------------------\nXD0      TM    SWITCH,ACTIVM  ALREADY ACTIVE MODE?\n         BZ    ERR28          NO\n         OI    SWITCH,XMEMRF+POPXMR     SET/REMEMBER X-MEM.REF.\n         L     R10,=A(DSPLY)  GO TO DISPLAY COMMAND\n         BR    R10\n*        --------------------------------------------------------------\n*        FIND IN ACTIVE AS-ID.\n*        --------------------------------------------------------------\nXF0      TM    SWITCH,ACTIVM  ALREADY ACTIVE MODE?\n         BZ    ERR28          NO\n         OI    SWITCH,XMEMRF+POPXMR     SET/REMEMBER X-MEM.REF.\n         L     R10,=A(FIND)   GO TO FIND COMMAND\n         BR    R10\n*        --------------------------------------------------------------\n*        GET BYTES IN ACTIVE AS-ID.\n*        --------------------------------------------------------------\nXG0      TM    SWITCH,ACTIVM  ALREADY ACTIVE MODE?\n         BZ    ERR28          NO\n         OI    SWITCH,XMEMRF+POPXMR     SET/REMEMBER X-MEM.REF.\n         L     R10,=A(DSPLY)\n         DROP  R10\n         USING DSPLY,R10\n         B     GBYTES\n         DROP  R10\n         USING ASNID,R10\n*        --------------------------------------------------------------\n*        X-MEM REF. HELP COMMAND.\n*        --------------------------------------------------------------\nXH0      MVC   CRPTR,PVPTR    ADJUST POINTERS FOR AFTER\n         TM    FSCRSW,FSCRSF  FULL SCREEN?\n         BZ    XH1            NO\n         OI    FSCRSW,FSCRSH  YES, SAY HELP PANEL\n         L     R1,=V(VCOREZAH)\n         USING HELPVP,R1\n         LM    R2,R4,HLXH\n         DROP  R1\n         B     INQUIRY\nXH1     @SEND  HELP80\n        @SEND  HELP81\n        @SEND  HELP82\n        @SEND  HELP83\n        @SEND  HELP84\n        @SEND  HELP85\n        @SEND  HELP86\n        @SEND  HELP87\n        @SEND  HELP88\n        @SEND  HELP89\n        @SEND  HELP90\n         B     INQUIRY\n*        --------------------------------------------------------------\n*        LIST AS-TABLE OR A SPECIFIC AS-ID FROM AS-TABLE.\n*        --------------------------------------------------------------\nXL0      MVC   CRPTR,PVPTR    ADJUST POINTERS FOR AFTER\n         TM    SWITCH,VASTB   VALID TABLE?\n         BZ    ERR13          NO\n         NI    STATUS,255-ONELSTD-MATCHREQ\n         TM    FSCRSW,FSCRSF  FULL SCREEN?\n         BZ    *+L'*+10       NO\n         XC    FSPOINT,FSPOINT     YES, SAY DATA LINES\n         OI    FSCRSW,FSCRSL\n         BAS   R14,NEXTCH     POSITION TO NEXT\n         B     XL4            +0 - LIST ALL\n         BAS   R14,NAME       +4 - GET AS-NAME OR MATCH STRING\n         B     ERR14               +0\n         B     XL1                 +4 - MAY BE AS-ID NO.\n         B     ERR15               +8\n         LR    R2,R1               +12\n         B     XL3\nXL1      CLI   0(R3),C'.'     HEX AS-ID NO.?\n         BNE   XL2\n         BAS   R14,NEXTCH     POSITION TO NEXT\n         B     ERR2           +0\nXL2      BAS   R14,SCAN       +4 - GET AS-ID NUMBER\n         B     ERR2                +0\n         B     ERR17               +4\n         B     ERR3                +8\n         CH    R1,=H'4'            +12\n         BH    ERR3\n         LNR   R2,R1\nXL3      OI    STATUS,MATCHREQ\nXL4      LM    R3,R5,SCASTB   SCAN AS-ID TABLE\nXL5      MVC   MSGTXT(L'MSGTXT),ALLBLKS\n         LA    R6,MSGTXT\n         USING CNSASOUT,R6\n         LA    R7,4\nXL6      TM    STATUS,MATCHREQ\n         BZ    XL9\n         LTR   R2,R2\n         BM    XL8\nXL7      EX    R2,XMTCH\n         BE    XL9\n         BXLE  R3,R4,XL7\n         B     XL11\nXL8      CLC   0(L'ASIDN,R3),DATA+2\n         BE    XL9\n         BXLE  R3,R4,XL8\n         B     XL11\nXL9      UNPK  CNSASID(L'CNSASID+1),0(L'ASIDN+1,R3)\n         TR    CNSASID(L'CNSASID),HEXTAB-X'F0'\n         MVI   CNSASID+L'CNSASID,C' '\n         MVI   CNSASSP,C':'\n         MVC   CNSASNM(L'CNSASNM),L'ASIDN(R3)\n         L     R1,=A(CHARTB)\n         TR    CNSASNM,0(R1)\n         DROP  R6\n         LA    R6,CNSASL(R6)\n         BXLE  R3,R4,XL10\n         B     XL11\nXL10     BCT   R7,XL6\n         BAS   R9,LISTOUT\n         OI    STATUS,ONELSTD\n         B     XL5\nXL11     CLC   MSGTXT(L'MSGTXT),ALLBLKS\n         BE    XL12\n         BAS   R9,LISTOUT\n         B     *+L'*+8\nXL12     TM    STATUS,ONELSTD\n         BZ    ERR16\n         TM    FSCRSW,FSCRSF  FULL SCREEN?\n         BZ    INQUIRY        NO\n         NI    FSCRSW,255-FSCRSL   YES, RESET DATA\n         L     R10,=A(INFST)\n         DROP  R10\n         USING INFST,R10\n         B     INFST0         GO GET STATUS\n         DROP  R10\n         USING ASNID,R10\nXMTCH    CLC   0+L'ASIDN(*-*,R3),NMEF   <<EXECUTED>>\n*        --------------------------------------------------------------\n*        RESET AS-ID MODE.\n*        --------------------------------------------------------------\nXR0      MVC   CRPTR,PVPTR    ADJUST POINTERS FOR AFTER\n         BAS   R8,DEACTIV     RESET AS-ID MODE\n         B     INQUIRT\n*        --------------------------------------------------------------\n*        STORE IN ACTIVE AS-ID.\n*        --------------------------------------------------------------\nXS0      CLI   AUTH,LV15      AUTHORIZED?\n         BL    ERR22          NO\n         TM    SWITCH,ACTIVM  ALREADY ACTIVE MODE?\n         BZ    ERR28          NO\n         OI    SWITCH,XMEMRF+POPXMR     SET/REMEMBER X-MEM.REF.\n         L     R10,=A(STORE)  GO TO STORE COMMAND\n         BR    R10\n*        --------------------------------------------------------------\n*        REFRESH/LOAD AS-TABLE AND RESET AS-ID MODE.\n*        --------------------------------------------------------------\nXT0      MVC   CRPTR,PVPTR    ADJUST POINTERS FOR AFTER\n         BAS   R8,DEACTIV     RESET AS-ID MODE\n         NI    SWITCH,255-VASTB    KILL VALID TABLE\n         LM    R3,R4,SCASTB\n         SLR   R3,R4\n         L     R5,=A(ASTBE)\n         USING PSA,R0\n         L     R1,FLCCVT      GET CVT ADDRESS\n         USING CVT,R1\n         L     R2,CVTASVT     GET ASVT POINTER\n         USING ASVT,R2\n         L     R6,ASVTMAXU    NUMBER OF ASCB'S\n         LA    R7,ASVTENTY    FIRST ENTRY ADDRESS\n         DROP  R0,R1,R2\nXT1      TM    0(R7),ASVTAVAL IS IT AN AVAILABLE ASID?\n         BO    XT4            YES, GO GET NEXT\n         L     R2,0(R7)       GET ASCB ADDRESS\n         USING ASCB,R2\n         CLC   MYASIDN,ASCBASID    IS IT MYSELF?\n         BE    XT4            YES, GO GET NEXT\n         L     R1,ASCBJBNI\n         LTR   R1,R1\n         BNZ   XT2\n         L     R1,ASCBJBNS\n         LTR   R1,R1\n         BZ    XT4\nXT2      BXLE  R3,R4,XT3\n         ST    R5,SCASTB+8    SET END ADDRESS\n         OI    SWITCH,VASTB   SET VALID TABLE\n         B     ERR12\nXT3      MVC   0(L'ASIDN,R3),ASCBASID\n         MVC   0+L'ASIDN(L'ASNME,R3),0(R1)\n         DROP  R2\nXT4      LA    R7,4(R7)       NEXT ENTRY\n         BCT   R6,XT1         LOOP UNTIL END\n         CL    R3,SCASTB      TABLE OK?\n         BL    INQUIRT        NO, LET INVALID AS-TABLE\n         ST    R3,SCASTB+8    SET END ADDRESS\n         OI    SWITCH,VASTB   SET VALID TABLE\n         B     INQUIRT\n         SPACE 1\n        @END   ,\n         EJECT\nBRWSE   @INIT  DSECT''S\n         SPACE 1\n***********************************************************************\n*        DSECTS INFO - DATA-SET COMMANDS.                             *\n***********************************************************************\n         SPACE 1\n         MVC   CRPTR,PVPTR    ADJUST POINTERS FOR AFTER\n         BAS   R14,NEXTCH     POSITION TO NEXT\n         B     BRDIR          +0 - BROWSE DIRECTORY\n         BAS   R14,NAMER      +4 - GET DSECT NAME\n         B     ERR37               +0\n         B     ERR38               +4\n         B     ERR39               +8\n         MVC   DRFDSCT,NMEF        +12 - DSECT NAME\n         MVC   DRFFLDN(L'DRFFLDN),ALLBLKS\n         XC    DRFDSPL(L'DRFDSPL+L'DRFLNGH),DRFDSPL\n         MVC   DRFFLGN(L'DRFFLGN),ALLBLKS\n         XC    DRFFLVL(L'DRFFLVL+L'DRFFLLG),DRFFLVL\n         NI    OPERSW,255-DRF1ST-DRFL1F-DRFL2F\n         BAS   R14,NEXTCH     POSITION TO NEXT\n         B     BLIST          +0 - LIST DSECT\n         BAS   R14,NAMER      +4 - GET FIELD OR FLAG NAME\n         B     ERR40               +0\n         B     BRW10               +4 - MAY BE HEX REQUEST\n         B     ERR41               +8\n         MVC   DRFFLDN,NMEF        +12 - FIELD OR FLAG NAME\n         BAS   R14,NEXTCH     POSITION TO NEXT\n         B     BRW20          +0\n         BAS   R14,SCAN       +4 - GET FLAG HEX VALUE\n         B     ERR42               +0\n         B     ERR17               +4\n         B     ERR43               +8\n         OC    DATA(L'DATA-L'DRFFLVL),DATA   +12 - FLAG VALUE\n         BNZ   ERR43\n         MVC   DRFFLVL(L'DRFFLVL),DATA+L'DATA-L'DRFFLVL\n         MVI   DRFFLGN,C'*'\n         TM    FSCRSW,FSCRSF  FULL SCREEN?\n         BZ    BRW1           NO\n         XC    FSPOINT,FSPOINT     YES, SAY DATA LINES\n         OI    FSCRSW,FSCRSL\nBRW1     LA    R0,1           ASK SEARCH\n         L     R15,=A(DRFCALL)\n         BASR  R14,R15\n         B     *+L'*(R15)\n         B     BRW4           +0\n         B     *+L'*+4        +4\n         B     BRW5           +8\n         LA    R6,MSGTXT+2    BROWSE BY FLAG VALUE\n         TM    OPERSW,DRFL1F\n         BO    BRW3\n         MVC   MSGTXT(L'MSGTXT),ALLBLKS\n         TM    OPERSW,DRF1ST\n         BO    BRW2\n         USING CNSDST,R6\n         OI    OPERSW,DRF1ST\n         MVC   CNSDSCT,DRFDSCT\n         MVC   CNSDSF1,DRFFLDN\n         MVI   CNSDSS1,C':'\n         UNPK  CNSDSD1(L'CNSDSD1+1),DRFDSPL(L'DRFDSPL+1)\n         TR    CNSDSD1(L'CNSDSD1),HEXTAB-X'F0'\n         MVI   CNSDSD1+L'CNSDSD1,C' '\n         UNPK  CNSDSL1(L'CNSDSL1+1),DRFLNGH(L'DRFLNGH+1)\n         TR    CNSDSL1(L'CNSDSL1),HEXTAB-X'F0'\n         MVI   CNSDSL1+L'CNSDSL1,C' '\n         MVI   CNSDSS2,C'-'\nBRW2     MVC   CNSDSF3,DRFFLGN\n         MVI   CNSDSS4,C':'\n         UNPK  CNSDSV1(L'CNSDSV1+1),DRFFLVL(L'DRFFLVL+1)\n         TR    CNSDSV1(L'CNSDSV1),HEXTAB-X'F0'\n         MVI   CNSDSV1+L'CNSDSV1,C' '\n         OI    OPERSW,DRFL1F\n         B     BRW1\nBRW3     MVI   CNSDSS5,C'-'\n         MVC   CNSDSF4,DRFFLGN\n         MVI   CNSDSS6,C':'\n         UNPK  CNSDSV2(L'CNSDSV2+1),DRFFLVL(L'DRFFLVL+1)\n         TR    CNSDSV2(L'CNSDSV2),HEXTAB-X'F0'\n         MVI   CNSDSV2+L'CNSDSV2,C' '\n         NI    OPERSW,255-DRFL1F\n         DROP  R6\n         BAS   R9,LISTOUT\n         B     BRW1\nBRW4     TM    OPERSW,DRFL1F\n         BZ    BRWEX\nBRWLST   BAS   R9,LISTOUT\nBRWEX    TM    FSCRSW,FSCRSF  FULL SCREEN?\n         BZ    INQUIRY        NO\n         NI    FSCRSW,255-FSCRSL   YES, RESET DATA\n         L     R10,=A(INFST)\n         DROP  R10\n         USING INFST,R10\n         B     INFST0         GO GET STATUS\n         DROP  R10\n         USING BRWSE,R10      LOCAL ADDRESSABILITY\nBRW5     TM    OPERSW,DRFL1F\n         BZ    ERROR\n         LR    R6,R1\n         BAS   R9,LISTOUT\n         LR    R1,R6\n         B     ERROR\nBRW10    CLI   0(R3),C'.'     HEX DISPLACEMENT?\n         BNE   *+L'*+8\n         BAS   R14,NEXTCH     POSITION TO NEXT\n         B     ERR40          +0\n         BAS   R14,SCAN       +4 - GET DISPLACEMENT\n         B     ERR45              +0\n         B     ERR17              +4\n         B     ERR46              +8\n         OC    DATA(L'DATA-L'DRFFLVL),DATA   +12 - DISPLACEMENT\n         BNZ   ERR46\n         MVC   DRFDSPL(L'DRFDSPL),DATA+L'DATA-L'DRFDSPL\n         TM    FSCRSW,FSCRSF  FULL SCREEN?\n         BZ    BRW11          NO\n         XC    FSPOINT,FSPOINT     YES, SAY DATA LINES\n         OI    FSCRSW,FSCRSL\nBRW11    LA    R0,1           ASK SEARCH\n         L     R15,=A(DRFCALL)\n         BASR  R14,R15\n         B     *+L'*(R15)\n         B     BRW13          +0\n         B     *+L'*+4        +4\n         B     BRW14          +8\n         LA    R6,MSGTXT+9    BROWSE BY FIELD DISPLACEMENT\n         TM    OPERSW,DRFL1F\n         BO    BRW12\n         MVC   MSGTXT(L'MSGTXT),ALLBLKS\n         USING CNSDST,R6\n         TM    OPERSW,DRF1ST\n         BO    *+L'*+10\n         OI    OPERSW,DRF1ST\n         MVC   CNSDSCT,DRFDSCT\n         OI    OPERSW,DRFL1F\n         MVC   CNSDSF1,DRFFLDN\n         MVI   CNSDSS1,C':'\n         UNPK  CNSDSD1(L'CNSDSD1+1),DRFDSPL(L'DRFDSPL+1)\n         TR    CNSDSD1(L'CNSDSD1),HEXTAB-X'F0'\n         MVI   CNSDSD1+L'CNSDSD1,C' '\n         UNPK  CNSDSL1(L'CNSDSL1+1),DRFLNGH(L'DRFLNGH+1)\n         TR    CNSDSL1(L'CNSDSL1),HEXTAB-X'F0'\n         MVI   CNSDSL1+L'CNSDSL1,C' '\n         B     BRW11\nBRW12    NI    OPERSW,255-DRFL1F\n         MVI   CNSDSS2,C'-'\n         MVC   CNSDSF2,DRFFLDN\n         MVI   CNSDSS3,C':'\n         UNPK  CNSDSD2(L'CNSDSD2+1),DRFDSPL(L'DRFDSPL+1)\n         TR    CNSDSD2(L'CNSDSD2),HEXTAB-X'F0'\n         MVI   CNSDSD2+L'CNSDSD2,C' '\n         UNPK  CNSDSL2(L'CNSDSL2+1),DRFLNGH(L'DRFLNGH+1)\n         TR    CNSDSL2(L'CNSDSL2),HEXTAB-X'F0'\n         MVI   CNSDSL2+L'CNSDSL2,C' '\n         DROP  R6\n         BAS   R9,LISTOUT\n         B     BRW11\nBRW13    TM    OPERSW,DRFL1F\n         BO    BRWLST\n         B     BRWEX\nBRW14    TM    OPERSW,DRF1ST\n         BZ    ERROR\n         LR    R6,R1\n         BAS   R9,LISTOUT\n         LR    R1,R6\n         B     ERROR\nBRW20    MVC   DRFFLGN,DRFFLDN\n         MVC   DRFFLDN(L'DRFFLDN),ALLBLKS\n         LA    R0,1           ASK SEARCH (FIRST TRY AS FLAG NAME)\n         L     R15,=A(DRFCALL)\n         BASR  R14,R15\n         B     *+L'*(R15)\n         B     *+L'*+8        +0\n         B     ERR44          +4\n         B     BRW21          +8\n         TM    FSCRSW,FSCRSF  FULL SCREEN?\n         BZ    *+L'*+10       NO\n         XC    FSPOINT,FSPOINT     YES, SAY DATA LINES\n         OI    FSCRSW,FSCRSL\n         MVC   MSGTXT(L'MSGTXT),ALLBLKS\n         LA    R6,MSGTXT+13   BROWSE BY FLAG NAME\n         USING CNSDST,R6\n         MVC   CNSDSCT,DRFDSCT\n         MVC   CNSDSF1,DRFFLDN\n         MVI   CNSDSS1,C':'\n         UNPK  CNSDSD1(L'CNSDSD1+1),DRFDSPL(L'DRFDSPL+1)\n         TR    CNSDSD1(L'CNSDSD1),HEXTAB-X'F0'\n         MVI   CNSDSD1+L'CNSDSD1,C' '\n         UNPK  CNSDSL1(L'CNSDSL1+1),DRFLNGH(L'DRFLNGH+1)\n         TR    CNSDSL1(L'CNSDSL1),HEXTAB-X'F0'\n         MVI   CNSDSL1+L'CNSDSL1,C' '\n         MVI   CNSDSS2,C'-'\n         MVC   CNSDSF3,DRFFLGN\n         MVI   CNSDSS4,C':'\n         UNPK  CNSDSV1(L'CNSDSV1+1),DRFFLVL(L'DRFFLVL+1)\n         TR    CNSDSV1(L'CNSDSV1),HEXTAB-X'F0'\n         MVI   CNSDSV1+L'CNSDSV1,C' '\n         DROP  R6\n         B     BRWLST\nBRW21    MVC   DRFFLDN,DRFFLGN\n         MVC   DRFFLGN(L'DRFFLGN),ALLBLKS\n         TM    FSCRSW,FSCRSF  FULL SCREEN?\n         BZ    BRW22          NO\n         XC    FSPOINT,FSPOINT     YES, SAY DATA LINES\n         OI    FSCRSW,FSCRSL\nBRW22    LA    R0,1           ASK SEARCH (THEN TRY AS FIELD NAME)\n         L     R15,=A(DRFCALL)\n         BASR  R14,R15\n         B     *+L'*(R15)\n         B     BRW26          +0\n         B     *+L'*+4        +4\n         B     BRW28          +8\n         LA    R6,MSGTXT+2    BROWSE BY FIELD NAME\n         TM    OPERSW,DRF1ST\n         BO    BRW23\n         MVC   MSGTXT(L'MSGTXT),ALLBLKS\n         USING CNSDST,R6\n         OI    OPERSW,DRF1ST\n         MVC   CNSDSCT,DRFDSCT\n         MVC   CNSDSF1,DRFFLDN\n         MVI   CNSDSS1,C':'\n         UNPK  CNSDSD1(L'CNSDSD1+1),DRFDSPL(L'DRFDSPL+1)\n         TR    CNSDSD1(L'CNSDSD1),HEXTAB-X'F0'\n         MVI   CNSDSD1+L'CNSDSD1,C' '\n         UNPK  CNSDSL1(L'CNSDSL1+1),DRFLNGH(L'DRFLNGH+1)\n         TR    CNSDSL1(L'CNSDSL1),HEXTAB-X'F0'\n         MVI   CNSDSL1+L'CNSDSL1,C' '\n         B     BRW22\nBRW23    TM    OPERSW,DRFL2F\n         BO    BRW25\n         TM    OPERSW,DRFL1F\n         BO    BRW24\n         OI    OPERSW,DRFL1F\n         MVI   CNSDSS2,C'-'\n         B     BRW24+L'BRW24\nBRW24    MVC   MSGTXT(L'MSGTXT),ALLBLKS\n         MVC   CNSDSF3,DRFFLGN\n         MVI   CNSDSS4,C':'\n         UNPK  CNSDSV1(L'CNSDSV1+1),DRFFLVL(L'DRFFLVL+1)\n         TR    CNSDSV1(L'CNSDSV1),HEXTAB-X'F0'\n         MVI   CNSDSV1+L'CNSDSV1,C' '\n         OI    OPERSW,DRFL2F\n         B     BRW22\nBRW25    MVI   CNSDSS5,C'-'\n         MVC   CNSDSF4,DRFFLGN\n         MVI   CNSDSS6,C':'\n         UNPK  CNSDSV2(L'CNSDSV2+1),DRFFLVL(L'DRFFLVL+1)\n         TR    CNSDSV2(L'CNSDSV2),HEXTAB-X'F0'\n         MVI   CNSDSV2+L'CNSDSV2,C' '\n         NI    OPERSW,255-DRFL2F\n         BAS   R9,LISTOUT\n         B     BRW22\nBRW26    TM    OPERSW,DRF1ST\n         BZ    BRW27\n         TM    OPERSW,DRFL2F\n         BO    BRWLST\n         B     BRWEX\nBRW27    LA    R6,MSGTXT+13\n         MVC   MSGTXT(L'MSGTXT),ALLBLKS\n         MVC   CNSDSCT,DRFDSCT\n         MVC   CNSDSF1,DRFFLDN\n         MVI   CNSDSS1,C':'\n         UNPK  CNSDSD1(L'CNSDSD1+1),DRFDSPL(L'DRFDSPL+1)\n         TR    CNSDSD1(L'CNSDSD1),HEXTAB-X'F0'\n         MVI   CNSDSD1+L'CNSDSD1,C' '\n         UNPK  CNSDSL1(L'CNSDSL1+1),DRFLNGH(L'DRFLNGH+1)\n         TR    CNSDSL1(L'CNSDSL1),HEXTAB-X'F0'\n         MVI   CNSDSL1+L'CNSDSL1,C' '\n         DROP  R6\n         B     BRWLST\nBRW28    TM    OPERSW,DRF1ST\n         BZ    ERROR\n         TM    OPERSW,DRFL2F\n         BZ    ERROR\n         LR    R6,R1\n         BAS   R9,LISTOUT\n         LR    R1,R6\n         B     ERROR\n         SPACE 1\nBLIST    TM    FSCRSW,FSCRSF  FULL SCREEN?\n         BZ    *+L'*+10       NO\n         XC    FSPOINT,FSPOINT     YES, SAY DATA LINES\n         OI    FSCRSW,FSCRSL\n         MVC   DRFFRMN,DRFDSCT\n         LA    R0,127         ASK MOD-ID\n         L     R15,=A(DRFCALL)\n         BASR  R14,R15\n         B     *+L'*(R15)\n         B     *+L'*+8        +0\n         NOP   0              +4\n         B     ERROR          +8\n         MVC   MSGTXT(L'MSGTXT),ALLBLKS\n         MVC   MSGTXT+2(L'DRFFRMN),DRFFRMN\n         MVC   MSGTXT+L'DRFFRMN+4(12),=CL12'MACRO NAME ='\n         MVC   MSGTXT+L'DRFFRMN+17(L'DRFFRMA),DRFFRMA\n         MVC   MSGTXT+L'DRFFRMN+L'DRFFRMA+18(10),=CL10'/ ASS-ID ='\n         MVC   MSGTXT+L'DRFFRMN+L'DRFFRMA+29(L'DRFFRMD),DRFFRMD\n         BAS   R9,LISTOUT\nBLS1     LA    R0,2           ASK LIST\n         L     R15,=A(DRFCALL)\n         BASR  R14,R15\n         B     *+L'*(R15)\n         B     BLS5           +0\n         B     *+L'*+4        +4\n         B     BLS6           +8\n         LA    R6,MSGTXT+2\n         CLC   DRFFLGN(L'DRFFLGN),ALLBLKS\n         BNE   BLS2\n         TM    OPERSW,DRFL1F\n         BZ    *+L'*+8\n         NI    OPERSW,255-DRFL1F-DRFL2F\n         BAL   R9,LISTOUT\n         MVC   MSGTXT(L'MSGTXT),ALLBLKS\n         USING CNSDST,R6\n         TM    OPERSW,DRF1ST\n         BO    *+L'*+10\n         OI    OPERSW,DRF1ST\n         MVC   CNSDSCT,DRFDSCT\n         MVC   CNSDSF1,DRFFLDN\n         MVI   CNSDSS1,C':'\n         UNPK  CNSDSD1(L'CNSDSD1+1),DRFDSPL(L'DRFDSPL+1)\n         TR    CNSDSD1(L'CNSDSD1),HEXTAB-X'F0'\n         MVI   CNSDSD1+L'CNSDSD1,C' '\n         UNPK  CNSDSL1(L'CNSDSL1+1),DRFLNGH(L'DRFLNGH+1)\n         TR    CNSDSL1(L'CNSDSL1),HEXTAB-X'F0'\n         MVI   CNSDSL1+L'CNSDSL1,C' '\n         OI    OPERSW,DRFL1F\n         B     BLS1\nBLS2     TM    OPERSW,DRFL1F\n         BZ    BLS3\n         TM    OPERSW,DRFL2F\n         BO    BLS4\n         MVI   CNSDSS2,C'-'\n         B     BLS3+L'BLS3\nBLS3     MVC   MSGTXT(L'MSGTXT),ALLBLKS\n         MVC   CNSDSF3,DRFFLGN\n         MVI   CNSDSS4,C':'\n         UNPK  CNSDSV1(L'CNSDSV1+1),DRFFLVL(L'DRFFLVL+1)\n         TR    CNSDSV1(L'CNSDSV1),HEXTAB-X'F0'\n         MVI   CNSDSV1+L'CNSDSV1,C' '\n         OI    OPERSW,DRFL1F+DRFL2F\n         B     BLS1\nBLS4     MVI   CNSDSS5,C'-'\n         MVC   CNSDSF4,DRFFLGN\n         MVI   CNSDSS6,C':'\n         UNPK  CNSDSV2(L'CNSDSV2+1),DRFFLVL(L'DRFFLVL+1)\n         TR    CNSDSV2(L'CNSDSV2),HEXTAB-X'F0'\n         MVI   CNSDSV2+L'CNSDSV2,C' '\n         DROP  R6\n         NI    OPERSW,255-DRFL1F-DRFL2F\n         BAS   R9,LISTOUT\n         B     BLS1\nBLS5     TM    OPERSW,DRFL1F\n         BO    BRWLST\n         B     BRWEX\nBLS6     TM    OPERSW,DRF1ST+DRFL1F\n         BNO   ERROR\n         LR    R6,R1\n         BAS   R9,LISTOUT\n         LR    R1,R6\n         B     ERROR\n         SPACE 1\nBRDIR    TM    FSCRSW,FSCRSF  FULL SCREEN?\n         BZ    BRD1           NO\n         XC    FSPOINT,FSPOINT     YES, SAY DATA LINES\n         OI    FSCRSW,FSCRSL\nBRD1     MVC   MSGTXT(L'MSGTXT),ALLBLKS\n         LA    R0,64          ASK RD-DIR\n         L     R15,=A(DRFCALL)\n         BASR  R14,R15\n         B     *+L'*(R15)\n         B     BRD3           +0\n         B     *+L'*+4        +4\n         B     BRD4           +8\n         LA    R6,MSGTXT+3\n         CLI   0(R6),C' '\n         BE    BRD2\n         LA    R6,6+L'DRFFRMN+L'DRFFRMA(R6)\n         CLI   0(R6),C' '\n         BE    BRD2\n         LA    R6,6+L'DRFFRMN+L'DRFFRMA(R6)\nBRD2     MVC   0(L'DRFFRMN,R6),DRFFRMN\n         CLC   DRFFRMA(L'DRFFRMA),ALLBLKS\n         BE    *+L'*+10\n         MVI   1+L'DRFFRMN(R6),C'-'\n         MVC   3+L'DRFFRMN(L'DRFFRMA,R6),DRFFRMA\n         CLI   MSGTXT+(2*(L'DRFFRMN+L'DRFFRMA+6))+3,C' '\n         BE    BRD1+L'BRD1\n         BAS   R9,LISTOUT\n         B     BRD1\nBRD3     CLI   MSGTXT+3,C' '\n         BNE   BRWLST\n         B     BRWEX\nBRD4     CLI   MSGTXT+3,C' '\n         BE    ERROR\n         LR    R6,R1\n         BAS   R9,LISTOUT\n         LR    R1,R6\n         B     ERROR\n         SPACE 1\nDSDST    MVC   CRPTR,PVPTR    ADJUST POINTERS FOR AFTER\n         BAS   R14,NEXTCH     POSITION TO NEXT\n         B     DSD10          +0 - GET STATISTICS\n         CLI   0(R3),C'*'     +4 - JUST FREE ALL SPACE?\n         BE    DSD1                YES\n         LR    R2,R3\n         BXLE  R3,R4,*+L'*+4\n         B     *+L'*+8\n         CLI   0(R3),C' '\n         BNE   *-12\n         SR    R3,R2\n         CH    R3,=H'44'\n         BH    ERR47\n         STC   R3,DRFDSL      SET DATA-SET NAME\n         MVI   DRFDSN,C' '\n         MVC   DRFDSN+1(L'DRFDSN-1),DRFDSN\n         BCT   R3,*+L'*+6\n         MVC   DRFDSN(*-*),0(R2)   <<EXECUTED>>\n         EX    R3,*-6\nDSD1     XR    R0,R0          ASK START\n         L     R15,=A(DRFCALL)\n         BASR  R14,R15\n         B     *+L'*(R15)\n         B     INQUIRT        +0\n         NOP   0              +4\n         B     ERROR\nDSD10    LA    R0,128         ASK STATS\n         L     R15,=A(DRFCALL)\n         BASR  R14,R15\n         B     *+L'*(R15)\n         B     *+L'*+8        +0\n         NOP   0              +4\n         B     ERROR\n         MVC   MSGTXT(L'MSGTXT),ALLBLKS\n         MVC   MSGTXT(8),=XL8'4020202020202120'\n         ICM   R1,B'1111',DRFTOTN\n         CVD   R1,DBLWD\n         ED    MSGTXT(8),DBLWD+4\n         MVC   MSGTXT+9(22),=CL22'LOAD(S) FOR A TOTAL OF'\n         MVC   MSGTXT+31(6),=XL6'402020202120'\n         ICM   R1,B'1111',DRFTOTL\n         SLL   R1,3\n         CL    R1,=A(16*KB)\n         BH    *+L'*+10\n         MVC   MSGTXT+38(5),=CL5'BYTES'\n         B     DSD11\n         AL    R1,=A(1*KB)\n         SRL   R1,10\n         MVC   MSGTXT+38(7),=CL7'K-BYTES'\n         CL    R1,=A(1*KB)\n         BNH   DSD11\n         AL    R1,=A(1*KB)\n         SRL   R1,10\n         MVI   MSGTXT+38,C'M'\nDSD11    CVD   R1,DBLWD\n         ED    MSGTXT+31(6),DBLWD+5\n        @SEND  MSGOUT,OP=LA\n         B     INQUIRT\n         SPACE 1\n        @END   ,\n         EJECT\nHCPRTSS @INIT  SS-HCOPY\n         SPACE 1\n***********************************************************************\n*        PRINT - START/STOP HARDCOPY COMMAND.                         *\n***********************************************************************\n         SPACE 1\n         MVC   CRPTR,PVPTR    ADJUST POINTERS FOR AFTER\n         TM    HCPRSW,HCFAIL  IS HARDCOPY OPEN FAILED?\n         BO    ERR33          YES, BYPASS ALL\n         TM    HCPRSW,HCCLOSE IS HARDCOPY TO BE CLOSED?\n         BO    HCPSTOP        YES, GO DO IT\n         BAS   R14,NEXTCH     POSITION TO NEXT\n         B     HCPSTP              +0 - ASSUME STOP\n         CLC   0(4,R3),=CL4'OFF'   +4 - IS PRINT OFF?\n         BE    HCPSTP         YES, GO STOP IT\n         CLC   0(3,R3),=CL3'ON'    IS IT ON?\n         BNE   ERR4           NO, INVALID OPERAND\n         TM    HCPRSW,HCCOPY  IS HARDCOPY ALREADY ACTIVE?\n         BO    ERR32          YES\n         LA    R1,H99TUKY3    INITIALIZE\n         ST    R1,H99TUPL+8\n         MVI   H99SYSOC,C'A'  SET DEFAULTS\n         MVC   H99DEST(L'H99DEST),ALLBLKS\n         XC    H99DESTL,H99DESTL\n         LA    R3,2(R3)       PROCESS PARMS IF ANY\nHCPNEXT  BAS   R14,NEXTCH     POSITION TO NEXT\n         B     HCPNDEST            +0 - NONE OR NO MORE\n         CLC   0(2,R3),=CL2'C('    +4 - SYSOUT CLASS?\n         BE    HCPSCCHG       YES, CHANGE OF SYSOUT CLASS\n         CLC   0(2,R3),=CL2'D('    DESTINATION?\n         BNE   ERR4           NO, INVALID OPERAND\n         LA    R3,2(R3)       EXTRACT DESTINATION NAME\n         LR    R1,R3\n         CLC   0(2,R3),=CL2') '\n         BE    *+L'*+8\n         BXLE  R3,R4,*-10\n         B     ERR4\n         LR    R14,R3\n         SR    R14,R1\n         BNP   ERR4\n         STCM  R14,B'0011',H99DESTL     SET LENGTH\n         BCTR  R14,0\n         EX    R14,*+L'*+4         SET DESTINATION NAME\n         B     HCPNEXT\n         MVC   H99DEST(*-*),0(R1)  <<EXECUTED>>\nHCPSCCHG CLC   3(2,R3),=CL2') '    VERIFY\n         BNE   ERR4           INVALID OPERAND\n         CLI   2(R3),C'A'     IS IT ALPHA?\n         BL    ERR4           NO, INVALID OPERAND\n         MVC   H99SYSOC,2(R3) MOVE IN PARM FOR SYSOUT CLASS\n         LA    R3,5(R3)       BUMP\n         B     HCPNEXT\nHCPNDEST CLC   H99DEST(L'H99DEST),ALLBLKS\n         BNE   *+L'*+6\n         MVC   H99TUPL+8(4),H99TUPL+12  OVERRIDE DEST= PARM\n         LA    1,H99RBPTR     ADDRESS OF PARM LIST FOR DYNALLOC\n        DYNALLOC ,            DO THE ALLOCATION\n         LTR   R15,R15        CHECK RETURN CODE?\n         BNZ   HCPCANT        ERROR, CAN DO POST MESSAGE\n         LA    R6,HCPYDCB     ADDRESS OF OUTPUT DCB\n         USING IHADCB,R6      ADDRESSABILITY TO OUTPUT DCB\n         MVC   DCBDDNAM(L'DCBDDNAM),ALLBLKS\n         ICM   R15,B'0011',H99DDNL\n         BCT   R15,*+L'*+6\n         MVC   DCBDDNAM(*-*),H99DDN     <<EXECUTED>>\n         EX    R15,*-6        SET DDNAME\n        $TSWXA 24,EXPAND=ONLY BACK TO 24-BIT\n        OPEN  (HCPYDCB,OUTPUT)     OPEN THE FILE\n        $TSWXA 31,EXPAND=ONLY RE-ENTER 31-BIT\n         TM    DCBOFLGS,DCBOFOPN   CHECK FOR SUCCESSFUL OPEN\n         DROP  R6             KILL DCB ADDRESSABILITY\n         BO    *+L'*+12       OK, OPENED\n         NI    HCPRSW,255-HCCOPY   TURN OFF HARDCOPY FLAG\n         OI    HCPRSW,HCFAIL  SET HARDCOPY OPEN FAILED FLAG\n         B     ERR33\n         OI    HCPRSW,HCCOPY  SAY HARDCPY FILE ACTIVE\n         ZAP   HCPAGE#,=PL1'+0'    RESET PAGE NUMBER\n         ZAP   HCLINE#,=PL2'+999'  RESET LINES COUNT\n         MVC   MSGTXT(L'MSGTXT),ALLBLKS\n         MVC   MSGTXT(33),=CL33'HARDCOPY STARTED : SYSOUT= ,DEST='\n         MVC   MSGTXT+26(L'H99SYSOC),H99SYSOC     SYSOUT CLASS\n         MVC   MSGTXT+33(L'H99DEST),H99DEST\n         CLI   MSGTXT+33,C' ' ANY DEST?\n         BNE   *+L'*+6\n         MVC   MSGTXT+33(L'H99DEST),=CL8'LOCAL'   SAY LOCAL\nHCPMSG  @SEND  MSGOUT,OP=LA\n         B     INQUIRT\nHCPCANT  CLC   H99ERROR,=XL2'046C' WAS IT 'RMT NOT DEF TO JES2'?\n         BE    HCPBRMT        YES, POST MSG AND EXIT\n         MVC   MSGTXT(L'MSGTXT),ALLBLKS\n         MVC   MSGTXT(45),=CL45'HARDCOPY ALL. ERR. : DARC=     INFO=   1\n                 R15='\n         CVD   R15,HCWORK     CONVERT SVC 99 RETURN CODE\n         MVC   MSGTXT+45(4),=XL4'40202020'   TO DEC\n         ED    MSGTXT+45(4),HCWORK+6\n         UNPK  MSGTXT+26(5),H99ERROR(3) ERR CODE\n         TR    MSGTXT+26(4),HEXTAB-X'F0'\n         MVI   MSGTXT+30,C' '\n         UNPK  MSGTXT+36(5),H99INFO(3)  INFO CODE\n         TR    MSGTXT+36(4),HEXTAB-X'F0'\n         MVI   MSGTXT+40,C' '\n         B     HCPMSG         GO SEND THE MESSAGE\nHCPBRMT  MVC   MSGTXT(L'MSGTXT),ALLBLKS\n         MVC   MSGTXT(49),=CL49'HARDCOPY ERR. : REMOTE          UNDEFIN1\n               ED TO JES2'\n         MVC   MSGTXT+23(L'H99DEST),H99DEST  RMT ASKED FOR\n         B     HCPMSG         GO SEND THE MESSAGE\nHCPSTP   TM    HCPRSW,HCCOPY  IS HARDCOPY ACTIVE?\n         BZ    ERR34          NO\nHCPSTOP $TSWXA 24,EXPAND=ONLY BACK TO 24-BIT\n        CLOSE  (HCPYDCB)      CLOSE THE FILE\n        FREEPOOL HCPYDCB      FREE THE BUFFERS TOO\n        $TSWXA 31,EXPAND=ONLY RE-ENTER 31-BIT\n         TM    HCPRSW,HCCLOSE WAS HARDCOPY TO BE CLOSED?\n         BZ    HCPBACK        NO\n         L     R10,=A(VCEND)  YES, BACK TO LEAVE\n         DROP  R10\n         USING VCEND,R10\n         B     NOHCPY\n         DROP  R10\n         USING HCPRTSS,R10\nHCPBACK  NI    HCPRSW,255-HCCOPY   TURN OFF HARDCOPY FLAG\n        @SEND  HCSFM\n         B     INQUIRT\n         SPACE 1\n        @END   ,\n         EJECT\nHCOPYSC @INIT  HARDCOPY\n         SPACE 1\n***********************************************************************\n*        HARDCOPY ROUTINE.                                            *\n*        AT ENTRY : R0 - TSO/TPUT LINE LENGTH                         *\n*                   R1 - WTO ADDRESS                                  *\n*                        TSO/TPUT LINE ADDRESS                        *\n*                   R2 - FULL SCREEN DISPLAY ADDRESS                  *\n*                   ANSR - WTOR REPLY                                 *\n*                          TSO/TGET RESPONSE                          *\n*                   R14 - RETURN ADDRESS                              *\n*                   R15 - ENTRY ADDRESS                               *\n***********************************************************************\n         SPACE 1\n         STM   R0,R15,HCSAVE  SAVE ALL REGISTERS AROUND HARDCOPY\n         LR    R10,R15   LOCAL ADDRESSABILITY\n        $TSWXA 24,EXPAND=ONLY BACK TO 24-BIT\n         TM    FSCRSW,FSCRSF  FULL SCREEN?\n         BO    HCFULL         YES\n         TM    HCPRSW,HCANSR  WTOR OR TSO/TGET?\n         BZ    HCSEND         NO\n         NI    HCPRSW,255-HCANSR\n         MVC   HCLINE(L'HCLINE),ALLBLKS\n         OC    HCLINE+8(L'ANSR),ANSR    COPY COMMAND\n         CLC   HCLINE(L'HCLINE),ALLBLKS\n         BE    HCTEXIT+L'HCTEXIT   DON'T HARDCOPY JUST ENTER\n         MVC   HCLINE(7),=CL7'ENTER :'\n         BAS   R8,HCTPAGE     TEST IF EJECT NEEDED\nHCPRTL  PUT    HCPYDCB,HCDETAIL\n         B     HCTEXIT\nHCSEND   MVC   HCLINE(L'HCLINE),ALLBLKS COPY TEXT\n         TM    STATUS,TSORUN\n         BZ    *+L'*+8\n         LM    R14,R15,HCSAVE\n         B     *+L'*+16\n         L     R1,HCSAVE+4\n         LH    R14,0(R1)\n         SH    R14,=H'4'\n         LA    R15,4(R1)\n         BCTR  R14,0\n         EX    R14,*+L'*+8\n         BAS   R8,HCTPAGE     TEST IF EJECT NEEDED\n         B     HCPRTL\n         MVC   HCLINE(*-*),0(R15)  <<EXECUTED>>\nHCFULL   BAS   R7,HCPHEAD     PREPARE HEADING\n         MVI   HCHEAD1,C'0'   SET DOUBLE SPACE\n         CP    HCLINE#,=PL2'+35'   EJECT TO BE SCHEDULED?\n         BNH   HCNPAGE        NO, ... SKIP PAGE SETTING\n         AP    HCPAGE#,=PL1'+1'    BUMP PAGE COUNT\n         MVI   HCPAGS,C'/'\n         MVC   HCPAGE,=XL6'402020202021'     MOVE IN MASK\n         ZAP   HCWORK,HCPAGE# MOVE INTO AREA\n         ED    HCPAGE,HCWORK+5     EDIT IN PAGE NUMBER\n         MVI   HCHEAD1,C'1'   SET EJECT\n         ZAP   HCLINE#,=PL1'+0'    RESET LINES COUNT\nHCNPAGE PUT    HCPYDCB,HCHEAD1     PUT OUT TITLE LINE\n        PUT    HCPYDCB,HCHEAD2     PUT OUT UNDERLINE\n         AP    HCLINE#,=PL1'+3'    BUMP LINES COUNT\n         MVC   HCLINE(L'HCLINE),ALLBLKS RECONSTRUCT IMAGE OF\n         MVC   HCLINE(12),=CL12'COMMAND ===>'     COMMAND LINE\n         OC    HCLINE+13(L'FSTEXT),FSTEXT\n        PUT    HCPYDCB,HCDETAIL\n         AP    HCLINE#,=PL1'+1'    BUMP LINES COUNT\n         LA    R2,FSCRFIXL(R2)     SET SCAN REGISTERS\nHCSNEXT  LA    R3,HCLINE\n         LA    R4,L'HCLINE\n         MVC   HCLINE,ALLBLKS\nHCSLOOP  CLI   0(R2),X'1D'    IS IT A SF ORDER?\n         BNE   *+L'*+8        NO\n         LA    R2,1(R2)       SKIP IT\n         B     HCTLNE\n         CLI   0(R2),X'11'    IS IT A SBA ORDER?\n         BE    HCTLEND        YES\n         CLI   0(R2),X'3C'    IS IT A RA ORDER?\n         BNE   HCTMOVE        NO\n         MVI   0(R3),C'-'     YES, THIS IS STATUS LINE (LINE 21)\n         MVC   1(L'HCLINE-3,R3),0(R3)\n         MVC   36(8,R3),=CL8' STATUS '\n         LA    R2,FSCRSTLL(R2)     SKIP IT\n         B     HCTPDL\nHCTMOVE  MVC   0(1,R3),0(R2)  NO, GET THIS CHAR IN LINE\nHCTLNE   LA    R2,1(R2)       BUMP POINTERS\n         LA    R3,1(R3)\n         BCT   R4,HCSLOOP     CONTINUE THROUGH SCREEN\nHCTPDL   CLC   HCLINE,ALLBLKS BLANK LINE?\n         BE    HCSNEXT        YES\n        PUT    HCPYDCB,HCDETAIL    PUT DETAIL LINE OUT\n         AP    HCLINE#,=PL1'+1'    BUMP LINES COUNT\n         B     HCSNEXT\nHCTLEND  MVI   HCDETAIL,C'0'  DOUBLE SPACE\n         MVC   HCLINE,ALLBLKS BLANK LINE\n        PUT    HCPYDCB,HCDETAIL    AND PRINT IT\n         MVI   HCDETAIL,C' '  RESTORE TO SINGLE SPACE\nHCTEXIT  AP    HCLINE#,=PL1'+1'    BUMP LINES COUNT\n        $TSWXA 31,EXPAND=ONLY RE-ENTER 31-BIT\n         LM    R0,R15,HCSAVE  RESTORE ALL REGISTERS\n         BR    R14            RETURN\n         SPACE 1\nHCPHEAD TIME   DEC       GET DATE/TIME FOR HEADING\n         ST    R1,HCBDATE     SAVE DATE FOR LATER\n         ST    R0,HCWORK CONVERT PACKED TO DEC\n         MVI   HCWORK+3,X'0F'\n         UNPK  DBLWD(7),HCWORK(4)\n         MVC   HTMEHRS,DBLWD  MOVE TIME TO MSG\n         MVC   HTMMINS,DBLWD+2\n         MVC   HTMSECS,DBLWD+4\n         MVC   DBLWD(4),HCBDATE    MOVE DATE TO WORK AREA\n         MVO   DBLWD+1(3),DBLWD(2) MAKE 00YYDDDS INTO 00000YYS\n         UNPK  HCYR(2),DBLWD+2(2)  FORMAT YEAR\n         XC    HCWORK,HCWORK\n         MVC   HCWORK+4(4),DBLWD   CONVERT YEAR TO BIN\n         CVB   R0,HCWORK\n         ST    R0,HCBYEAR     AND SAVE\n         TM    HCBYEAR+3,X'03'     LEAP YEAR?\n         BNZ   HCMN1          NO\n         MVI   HCMNMSK+10,29  YES, CORRECT\nHCMN1    XC    HCWORK,HCWORK  CONVERT DAYS TO BIN\n         MVC   HCWORK+6(2),HCBDATE+2\n         CVB   R14,HCWORK\n         ST    R14,HCBDAYS    SAVE FOR LATER\n         XR    R1,R1\n         LA    R15,11\nHCMN2    IC    R1,HCMNMSK(R15)     COMPUTE MON AND DAY\n         SR    R14,R1\n         BNP   *+L'*+8\n         BCT   R15,HCMN2\n         B     *+L'*+2\n         AR    R14,R1         CORRECT OVERDRAW\n         CVD   R14,HCWORK     FORMAT DAY\n         UNPK  HCDAYN(2),HCWORK+6(2)\n         OI    HCDAYN+1,C'0'  FIX UP SIGN\n         MH    R15,=Y(L'HCMONTAB)  GET TABLE OFFSET\n         LA    R15,HCMONTAB(R15)   AND POINT AT MONTH\n         MVC   HCMON(L'HCMON),0(R15)    MOVE IT TO THE MSG\n         L     R15,HCBYEAR    DAY OF WEEK\n         SH    R15,=H'69'\n         BNP   HCOUTT         MUST BE GREATER OR BAD\n         XR    R14,R14        CLEAR DAY REG\n         D     R14,=F'4'\n         MH    R15,=H'5'\n         AR    R14,R15\n         A     R14,HCBDAYS\n         SRDA  R14,32\n         D     R14,=F'7'      MODULO 7 FOR WEEK\n         MH    R14,=Y(L'HCDAYTAB)\n         LA    R14,HCDAYTAB(R14)   POINT AT TODAY\n         MVC   HCDAY(L'HCDAY),0(R14)    INSERT IN MSG\n         B     HCMVEJD\nHCOUTT   MVC   HCDAY(L'HCDAY),=CL3'???'\nHCMVEJD  MVC   HJDATE,=XL7'4020204B202020'\n         ED    HJDATE,HCBDATE+1\n         MVI   HJDATE,C'='\n         MVC   HCUSER,MYASNME MOVE IN USERID\n         MVI   HCPAGS,C' '\n         MVC   HCPAGE(L'HCPAGE),ALLBLKS CLEAR OUT PAGE FIELD\n         BR    R7             RETURN\n         SPACE 1\nHCTPAGE  CP    HCLINE#,=PL2'+55'   EJECT TO BE SCHEDULED?\n         BNHR  R8             NO, ... SKIP PAGE SETTING\n         BAS   R7,HCPHEAD     PREPARE HEADING\n         AP    HCPAGE#,=PL1'+1'    BUMP PAGE COUNT\n         MVI   HCPAGS,C'/'\n         MVC   HCPAGE,=XL6'402020202021'     MOVE IN MASK\n         ZAP   HCWORK,HCPAGE# MOVE INTO AREA\n         ED    HCPAGE,HCWORK+5     EDIT IN PAGE NUMBER\n         MVI   HCHEAD1,C'1'   SET EJECT\n         ZAP   HCLINE#,=PL1'+0'    RESET LINES COUNT\n        PUT    HCPYDCB,HCHEAD1     PUT OUT TITLE LINE\n        PUT    HCPYDCB,HCHEAD2     PUT OUT UNDERLINE\n         AP    HCLINE#,=PL1'+3'    BUMP LINES COUNT\n         BR    R8             RETURN\n         SPACE 1\n        @END   ,\n         EJECT\nSGTCHK  @INIT  'SEGMENT  TABLE   CHECK  PROCESS'\n         SPACE 1\n         STM   R0,R14,SGSAVE       SAVE REGISTERS 0-14\n         L     R0,LSVSGT           SIZE FOR GETMAIN REQUEST\n        GETMAIN RC,LV=(0),BNDRY=PAGE\n         LTR   R15,R15\n         BNZ   SGERR1\n         ST    R1,ASVSGT           SAVE ADDRESS\n         L     R0,=F'-1'\n         ST    R0,0(R1)\n         A     R1,=A(4*KB)\n         ST    R0,0(R1)\n         L     R1,=A(CC0)\n         ST    R0,0(R1)\n         MVI   CC1,X'FF'\n         MVI   CC2,X'FF'\n        SETAUTH ,                  SET APF\n         L     R1,=A(SGELST)\n        ESPIE  SET,MF=(E,(1))      INTERCEPT 0C4\n         ST    R1,OLDPICA          SAVE OLD PICA ADDRESS\n        MODESET KEY=ZERO,MODE=SUP  ENTER SYSTEM MODE\n         ST    R13,SGSVR13\n         LA    R13,SGASVA\n        SETLOCK OBTAIN,TYPE=LOCAL,MODE=UNCOND,REGS=SAVE,RELATED=O$R1\n         L     R1,ASVSGT\n         LR    R2,R1\n         AL    R2,LSVSGT\n         BCTR  R2,0\n        PGSER  R,FIX,A=(1),EA=(2),ECB=0,BRANCH=Y,RELATED=FREEPAGE\n        SETLOCK RELEASE,TYPE=LOCAL,REGS=SAVE,RELATED=R$O1\n         L     R13,SGSVR13\n         TM    SWITCH,ACTIVM       ACTIVE MODE?\n         BZ    SGNOACT             NO\n         L     R1,CVTPTR           POINT TO CVT\n         USING CVT,R1\n         L     R14,CVTASVT         POINT TO ASVT\n         DROP  R1\n         L     R1,WASID            GET SECONDARY WORK AS-ID\n         USING ASVT,R14\n         C     R1,ASVTMAXU         IS AS-ID TOO BIG?\n         BH    ERR29               YES\n         SLL   R1,2                (AS-ID)*4\n         LA    R1,ASVTENTY-4(R1)   POINT AT ENTRY\n         TM    0(R1),ASVTAVAL      IS IT AVAILABLE?\n         BO    ERR30               NO\n         DROP  R14\n         L     R2,0(R1)            POINT TO ASCB\n         USING ASCB,R2\n         TM    ASCBRCTF,ASCBOUT    IS ASCB SWAPPED OUT?\n         BO    ERR31               YES\n         B     SGNOACT+L'SGNOACT\nSGNOACT  L     R2,MYASCB           GET MY ASCB ADDRESS\n         L     R3,ASCBASTE         POINTER TO ASTE\n         DROP  R2\n         USING ASTE,R3\n         L     R4,ASTESTD          SEGMENT-TABLE DESIGNATOR\n         DROP  R3\n         SRDL  R4,7\n         SRL   R4,5\n         SLL   R4,13\n         SRL   R4,1\n         LR    R6,R4\n         SRL   R5,25\n         LA    R5,1(R5)\n         SLL   R5,6                MULTIPLY BY (16*SGTEL)\n         ST    R5,MVSGT\n         LR    R7,R5\n         CL    R7,=A(4*KB)         OVER PAGE SIZE?\n         BNH   *+L'*+4             NO\n         L     R5,=A(4*KB)         YES, GET 1ST PAGE\n         L     R2,ASVSGT\n         LR    R3,R5\n         XR    R1,R1\n         LRA   R2,0(R2)\n         BZ    *+L'*+20\n         LA    R1,4(R1)\n         BM    *+L'*+12\n         LA    R1,14(R1)\n         BP    *+L'*+4\n         LA    R1,14(R1)\n         STC   R1,CC1\n         CLI   CC1,0\n         BNE   SGRCVRY\n        DATOFF INDMVCL0\n         CL    R7,=A(4*KB)\n         BNH   SGRCVRY\n         LR    R5,R7               GET 2ND PAGE\n         S     R5,=A(4*KB)\n         LR    R4,R6\n         A     R4,=A(4*KB)\n         L     R2,ASVSGT\n         A     R2,=A(4*KB)\n         LR    R3,R5\n         XR    R1,R1\n         LRA   R2,0(R2)\n         BZ    *+L'*+20\n         LA    R1,4(R1)\n         BM    *+L'*+12\n         LA    R1,14(R1)\n         BP    *+L'*+4\n         LA    R1,14(R1)\n         STC   R1,CC2\n         CLI   CC2,0\n         BNE   SGRCVRY\n        DATOFF INDMVCL0\nSGRCVRY  ST    R13,SGSVR13\n         LA    R13,SGASVA\n        SETLOCK OBTAIN,TYPE=LOCAL,MODE=UNCOND,REGS=SAVE,RELATED=O$R2\n         L     R1,ASVSGT\n         LR    R2,R1\n         AL    R2,LSVSGT\n         BCTR  R2,0\n        PGSER  R,FREE,A=(1),EA=(2),BRANCH=Y,RELATED=FIXEPAGE\n        SETLOCK RELEASE,TYPE=LOCAL,REGS=SAVE,RELATED=R$O2\n         L     R13,SGSVR13\n        MODESET KEY=NZERO,MODE=PROB     RESTORE PROBLEM MODE\n        ESPIE  RESET,OLDPICA       RESTORE SPIE/ESPIE ENVIRONMENT\n        RESAUTH ,                  RESET APF\n         L     R15,=A(CC0)\n         CLC   0(4,R15),=F'-1'\n         BNE   SGERR2\n         CLI   CC1,X'FF'\n         BE    *+L'*+12\n         XR    R15,R15\n         IC    R15,CC1\n         LTR   R15,R15\n         BNZ   SGERR3\n         CLI   CC2,X'FF'\n         BE    *+L'*+12\n         XR    R15,R15\n         IC    R15,CC2\n         LTR   R15,R15\n         BNZ   SGERR4\n         L     R2,ASVSGT\n         CLC   0(4,R2),=F'-1'\n         BE    SGERR5\n         TM    SGTPSW,STPLST       DISPLAY REQUESTED?\n         BO    SGLST               YES\n         SPACE 1\n***********************************************************************\n*        CHECK ADDRESS WITH SEGMENT-TABLE.                            *\n***********************************************************************\n         SPACE 1\n         L     R3,RCVPTR\n         SRL   R3,20\n         SLL   R3,2                MULTIPLY BY SGTEL\n         LR    R4,R3\n         TM    WRPTR,X'80'         FIRST TIME?\n         BZ    *+L'*+8             NO\n         L     R6,=F'-1'           YES, INHIBIT WRAP TEST\n         B     SGCHECK\n         L     R6,WRPTR\n         SRL   R6,20\n         SLL   R6,2                MULTIPLY BY SGTEL\nSGCHECK  CL    R3,MVSGT\n         BL    *+L'*+2\n         XR    R3,R3               REMAINING M-BYTES INVALID, WRAP\n         LA    R5,0(R2,R3)\n         TM    3(R5),X'20'         TEST (I) BIT\n         BZ    SGMBVL              THIS M-BYTE IS VALID\n         CLR   R3,R6               WRAP DONE?\n         BE    *+L'*+8             YES\n         LA    R3,SGTEL(R3)        OTHERWISE FIND NEXT VALID\n         B     SGCHECK\n         L     R3,WRPTR\n         LTR   R3,R3\n         BNZ   SGSTAP\nSGSTPP   L     R3,=A(X'7FFFF000')  2GB - 4KB (1 PAGE)\n         ST    R3,RCVPTR\n         B     SGXOK\nSGMBVL   CLR   R3,R4\n         BE    SGXOK\n         ST    R3,CFFPTR           NEXT VALID M-BYTE ADDRESS\n         LTR   R3,R3\n         BZ    SGSTPP\n         SLL   R3,18\nSGSTAP   SL    R3,=A(4*KB)\n         ST    R3,RCVPTR\n         B     SGXOK\n         SPACE 1\n***********************************************************************\n*        DISPLAY SEGMENT-TABLE.                                       *\n***********************************************************************\n         SPACE 1\nSGLST    XR    R3,R3\n         TM    FSCRSW,FSCRSF       FULL SCREEN?\n         BZ    SGLST2              NO\n         XC    FSPOINT,FSPOINT     YES, SAY DATA LINES\n         OI    FSCRSW,FSCRSL\n         B     SGLST3\nSGLST1   TM    FSCRSW,FSCRSF       FULL SCREEN?\n         BZ    SGLST3              NO\n         CLC   FSPOINT,=F'81'      YES, NEW SCREEN-PAGE?\n         BNE   SGLST3              NO\n         NI    FSCRSW,255-FSCRSL   YES\nSGLST2   MVC   MSGTXT(L'MSGTXT),ALLBLKS\n         MVI   MSGTXT,C'\"'\n         TM    SWITCH,ACTIVM\n         BO    *+L'*+10\n         MVC   MSGTXT+1(L'MYASNME),MYASNME\n         B     *+L'*+6\n         MVC   MSGTXT+1(L'ASNME),ASNME\n         LA    R1,MSGTXT+L'ASNME\n         CLI   0(R1),C' '\n         BNE   *+L'*+4\n         BCT   R1,*-8\n         MVC   1(29,R1),=CL29'\" ADDRESS SPACE SEGMENT-TABLE'\n        @SEND  MSGOUT,OP=LA\n         TM    FSCRSW,FSCRSF       FULL SCREEN?\n         BZ    SGLST3              NO\n         OI    FSCRSW,FSCRSL       YES\nSGLST3   LA    R5,0(R2,R3)\n         LA    R0,4\n         MVC   MSGTXT(L'MSGTXT),ALLBLKS\n         LR    R1,R3\n         SLL   R1,2\n         ST    R1,DBLWD+4\n         UNPK  DBLWD(3),DBLWD+6(2)\n         OI    DBLWD+2,X'F0'\n         TR    DBLWD(3),HEXTAB-X'F0'\n         MVC   MSGTXT+1(3),DBLWD\n         LA    R1,MSGTXT+13\nSGLST4   LA    R4,0(R2,R3)\n         MVC   DBLWD(SGTEL),0(R4)\n         UNPK  0(2*SGTEL+1,R1),DBLWD(SGTEL+1)\n         TR    0(2*SGTEL,R1),HEXTAB-X'F0'\n         MVI   2*SGTEL(R1),C' '\n         LA    R1,2*SGTEL+2(R1)\n         BCT   R0,*+L'*+4\n         B     *+L'*+8\n         LA    R3,SGTEL(R3)\n         B     SGLST4\n         LR    R1,R3\n         LA    R3,SGTEL(R3)\nSGLST5   CL    R3,MVSGT\n         BNL   SGLST6\n         LA    R4,0(R2,R3)\n         CLC   0(4*SGTEL,R4),0(R5)\n         BNE   SGLST6\n         LA    R3,4*SGTEL(R3)\n         LA    R1,4*SGTEL(R1)\n         B     SGLST5\nSGLST6   SLL   R1,2\n         ST    R1,DBLWD+4\n         UNPK  DBLWD(3),DBLWD+6(2)\n         OI    DBLWD+2,X'F0'\n         TR    DBLWD(3),HEXTAB-X'F0'\n         MVI   MSGTXT+5,C'-'\n         MVC   MSGTXT+7(3),DBLWD\n         MVI   MSGTXT+11,C':'\n         BAS   R9,LISTOUT\n         CL    R3,MVSGT\n         BL    SGLST1\n         TM    FSCRSW,FSCRSF       FULL SCREEN?\n         BZ    SGXOK               NO\n         NI    FSCRSW,255-FSCRSL   YES, RESET DATA\n         B     SGXOK\n         SPACE 1\n***********************************************************************\n*        ERRORS DIAGNOSE.                                             *\n***********************************************************************\n         SPACE 1\nSGERR1   TM    FSCRSW,FSCRSF       FULL SCREEN?\n         BZ    *+L'*+10            NO\n         XC    FSPOINT,FSPOINT     YES, SAY DATA LINES\n         OI    FSCRSW,FSCRSL\n         MVC   MSGTXT(L'MSGTXT),ALLBLKS\n         CVD   R15,DBLWD\n         MVC   DBLWD(4),=XL4'40202120'\n         ED    DBLWD(4),DBLWD+L'DBLWD-2\n         MVC   MSGTXT(37),=CL37'GETMAIN OF 8K (2 PAGES) FAILED - RC ='\n         MVC   MSGTXT+38(2),DBLWD+2\n        @SEND  MSGOUT,OP=LA\n         B     SGERRX\nSGERR2   TM    FSCRSW,FSCRSF       FULL SCREEN?\n         BZ    *+L'*+10            NO\n         XC    FSPOINT,FSPOINT     YES, SAY DATA LINES\n         OI    FSCRSW,FSCRSL\n         MVC   MSGTXT(L'MSGTXT),ALLBLKS\n         MVC   MSGTXT(36),=CL36'=> 0C4 INTERRUPT PROCESS AT OFFSET +'\n         L     R2,=A(SV0C4)\n         LA    R2,L'EPIEGPR(R2)\n         MVC   DBLWD(4),4(R2)\n         NI    DBLWD,255-X'80'\n         CLC   DBLWD(4),BEGADD\n         BL    *+L'*+10\n         CLC   DBLWD(4),ENDADD\n         BNH   *+L'*+10\n         MVC   MSGTXT+25(15),=CL15'/ OUT OF BOUNDS'\n         B     *+L'*+28\n         L     R0,DBLWD\n         SL    R0,BEGADD\n         ST    R0,DBLWD\n         UNPK  MSGTXT+36(5),DBLWD(5)\n         TR    MSGTXT+36(4),HEXTAB-X'F0'\n         MVI   MSGTXT+40,C' '\n        @SEND  MSGOUT,OP=LA\n         XR    R2,R2\n         LA    R3,4\n         L     R4,=A(SV0C4)\nSGLBIG   LA    R5,4\n         MVC   MSGTXT(L'MSGTXT),ALLBLKS\n         LA    R6,MSGTXT\nSGLLOW   MVC   1(2,R6),=CL2'GR'\n         CVD   R2,DBLWD\n         MVC   DBLWD(4),=XL4'40202120'\n         ED    DBLWD(4),DBLWD+L'DBLWD-2\n         MVC   4(2,R6),DBLWD+2\n         MVI   7(R6),C'='\n         UNPK  9(9,R6),0(L'SV0C4+1,R4)\n         TR    9(8,R6),HEXTAB-X'F0'\n         MVI   17(R6),C' '\n         LA    R2,1(R2)\n         LA    R4,L'SV0C4(R4)\n         LA    R6,18(R6)\n         BCT   R5,SGLLOW\n        @SEND  MSGOUT,OP=LA\n         BCT   R3,SGLBIG\n         MVC   MSGTXT(L'MSGTXT),ALLBLKS\n         MVC   MSGTXT+1(25),=CL25'EC MODE PROGRAM OLD PSW ='\n         UNPK  MSGTXT+27(9),0(L'SV0C4+1,R4)\n         TR    MSGTXT+27(8),HEXTAB-X'F0'\n         MVI   MSGTXT+35,C' '\n         LA    R4,L'SV0C4(R4)\n         UNPK  MSGTXT+36(9),0(L'SV0C4+1,R4)\n         TR    MSGTXT+36(8),HEXTAB-X'F0'\n         MVI   MSGTXT+44,C' '\n         LA    R4,L'SV0C4(R4)\n        @SEND  MSGOUT,OP=LA\n         MVC   MSGTXT(L'MSGTXT),ALLBLKS\n         MVC   MSGTXT+1(31),=CL31'PROGRAM INTERRUPT INFORMATION ='\n         UNPK  MSGTXT+33(9),0(L'SV0C4+1,R4)\n         TR    MSGTXT+33(8),HEXTAB-X'F0'\n         MVI   MSGTXT+41,C' '\n         LA    R4,L'SV0C4(R4)\n        @SEND  MSGOUT,OP=LA\n         MVC   MSGTXT(L'MSGTXT),ALLBLKS\n         MVC   MSGTXT+1(31),=CL31'TRANSLATION EXCEPTION ADDRESS ='\n         UNPK  MSGTXT+33(9),0(L'SV0C4+1,R4)\n         TR    MSGTXT+33(8),HEXTAB-X'F0'\n         MVI   MSGTXT+41,C' '\n        @SEND  MSGOUT,OP=LA\n         B     SGERRX\nSGERR3   TM    FSCRSW,FSCRSF       FULL SCREEN?\n         BZ    *+L'*+10            NO\n         XC    FSPOINT,FSPOINT     YES, SAY DATA LINES\n         OI    FSCRSW,FSCRSL\n         MVC   MSGTXT(L'MSGTXT),ALLBLKS\n         MVC   MSGTXT(3),=CL3'1ST'\n         BAS   R6,SGSTCC\n         CLI   CC2,X'FF'\n         BE    SGERRX\n         XR    R15,R15\n         IC    R15,CC2\n         LTR   R15,R15\n         BNZ   SGERRC\n         B     SGERRX\nSGERR4   TM    FSCRSW,FSCRSF       FULL SCREEN?\n         BZ    SGERRC              NO\n         XC    FSPOINT,FSPOINT     YES, SAY DATA LINES\n         OI    FSCRSW,FSCRSL\nSGERRC   MVC   MSGTXT(L'MSGTXT),ALLBLKS\n         MVC   MSGTXT(3),=CL3'2ND'\n         BAS   R6,SGSTCC\n         B     SGERRX\nSGSTCC   MVC   MSGTXT+4(8),=CL8'LRA CC ='\n         MVI   MSGTXT+15,C'('\n         B     *(R15)\n         MVI   MSGTXT+13,C'1'\n         MVC   MSGTXT+16(28),=CL28'SEGMENT-TABLE ENTRY INVALID)'\n         B     *+L'*+24\n         MVI   MSGTXT+13,C'2'\n         MVC   MSGTXT+16(25),=CL25'PAGE-TABLE ENTRY INVALID)'\n         B     *+L'*+10\n         MVI   MSGTXT+13,C'3'\n         MVC   MSGTXT+16(39),=CL39'SEGMENT- OR PAGE-TABLE LENGTH EXCEEDX\n               ED)'\n        @SEND  MSGOUT,OP=LA\n         BR    R6\nSGERR5   TM    FSCRSW,FSCRSF       FULL SCREEN?\n         BZ    *+L'*+10            NO\n         XC    FSPOINT,FSPOINT     SAY DATA LINES\n         OI    FSCRSW,FSCRSL\n        @SEND  SGERM1\nSGERRX   TM    FSCRSW,FSCRSF       FULL SCREEN?\n         BZ    *+L'*+4             NO\n         NI    FSCRSW,255-FSCRSL   YES, RESET DATA\n        @SEND  SGERM2\n         OI    SGTPSW,STPDIS       DISABLE THIS PROCESSING\n         LA    R2,4                SET COMPLETION CODE = ERROR\n         B     SGXOK+L'SGXOK\nSGXOK    XR    R2,R2               SET COMPLETION CODE = OK\n         NI    SGTPSW,255-STPLST   RESET REQUEST(S)\n         LM    R0,R1,LSVSGT        LENGTH-ADDRESS FOR FREEMAIN\n         LTR   R1,R1\n         BZ    SGQUIT\n        FREEMAIN R,LV=(0),A=(1)    FREE WORKING STORAGE\n         XC    ASVSGT,ASVSGT\nSGQUIT   LR    R15,R2              PASS BACK THE COMPLETION CODE\n         LM    R0,R14,SGSAVE       RESTORE REGISTERS 0-14\n         BR    R14                 RETURN\n         SPACE 1\n        @END   ,\n         EJECT\n        $HEDIT ROUTINES\n         SPACE 1\n***********************************************************************\n*        SUBROUTINE TO SET FULL SCREEN DISPLAY.                       *\n*        REGISTERS USE : R0-R1-R14-R15 - WORK REGISTERS               *\n*                        R8 - LINK REGISTER                           *\n*                        R10 - LOCAL BASE REGISTER (PREVIOUS SAVED    *\n*                              AND RESTORED AROUND ROUTINE BY R15)    *\n***********************************************************************\n         USING FSSETFS,R15\nFSSETFS  ST    R10,FSR10SV         SAVE PREVIOUS R10\n         LR    R10,R15             SET LOCAL BASE\n         DROP  R15\n         USING FSSETFS,R10\n        STFSMODE ON,INITIAL=YES    VTAM INITIALIZATION\n         MVI   FSCRSW,FSCRSF       SAY FULL SCREEN\n         MVI   FSPRSW,0\n         OC    SZLINE(L'SZLINE+L'SZSCRN),SZLINE   SIZE TO BE SET?\n         BZ    FSS1                NO\n        STSIZE SIZE=80,LINE=24     SET STANDARD SCREEN SIZE\n         OI    FSCRSW,FSCRSS+FSCRSR     SAY SIZE SET AND TO BE RESET\nFSS1     XC    FSTEXT(L'FSTEXT),FSTEXT\n         MVC   FSCRMSG,ALLBLKS\n         LA    R14,FSCRLNS\n         LA    R15,16              RESET LINES 5 TO 20\nFSS2    $FS    SF=(PROT),MF=(I,(R14))\n         MVC   2(79,R14),ALLBLKS\n         LA    R14,81(R14)\n         BCT   R15,FSS2\n         LA    R14,FSCRLST\n         LA    R15,3               RESET LINES 22 TO 24\nFSS3    $FS    SF=(PROT),MF=(I,(R14))\n         MVC   2(79,R14),ALLBLKS\n         LA    R14,81(R14)\n         BCT   R15,FSS3\n         MVC   FSCRSCL(L'FSCRSCL),ALLBLKS    RESET SCALING\n        $FS    SF=(PROT),MF=(I,FSCRSDC)\n         MVC   FSCRTDC(L'FSCRTDC),ALLBLKS    RESET DATA CONTINUE\n         MVC   ANSR(L'ANSR),ALLBLKS\n         L     R10,FSR10SV         RESTORE PREVIOUS R10\n         DROP  R10\n         BR    R8                  RETURN\n         SPACE 1\n***********************************************************************\n*        SUBROUTINE TO RESET FULL SCREEN DISPLAY.                     *\n*        REGISTERS USE : R0-R1-R14-R15 - WORK REGISTERS               *\n*                        R8 - LINK REGISTER                           *\n***********************************************************************\n         USING FSCLEAR,R15\nFSCLEAR  TM    FSCRSW,FSCRSF       FULL SCREEN?\n         BZR   R8                  NO\n         ST    R10,FSR10SV         SAVE PREVIOUS R10\n         LR    R10,R15             SET LOCAL BASE\n         DROP  R15\n         USING FSCLEAR,R10\n         TM    FSCRSW,FSCRSR       SCREEN SIZE TO BE RESET?\n         BZ    FSCLEAZ             NO\n        STSIZE SIZELOC=SZLINE,LINELOC=SZSCRN RESTORE\n        $FS    CC=EWA,MF=(I,FSCLR)\nFSCLEAZ TPUT   FSCLR,FSCLRL,FULLSCR,,HOLD    CLEAR SCREEN\n        STFSMODE OFF               TELL VTAM WE'RE DONE\n         MVI   FSCRSW,0            RESET ALL FLAGS\n         MVI   FSPRSW,0\n         L     R10,FSR10SV         RESTORE PREVIOUS R10\n         DROP  R10\n         BR    R8\n         SPACE 1\nFSR10SV  DC    F'0'\n         SPACE 1\n        LTORG\n         SPACE 1\n***********************************************************************\n*        SUBROUTINE TO CALL DTUR ROUTINE FUNCTIONS.                   *\n*        REGISTERS USE : R2-R10 SAVED AND RESTORED                    *\n*                        R11-R13 UNCHANGED (MUST BE SET AND RETAINED) *\n*        AT ENTRY : R0 - FUNCTION NUMBER                              *\n*                   R14 - LINK REGISTER                               *\n*                   R15 - ENTRY REGISTER                              *\n*        AT EXIT : R15 - 0 = OPERATION CORRECTLY DONE (SEE DTUR)      *\n*                        4 = OPERATION MAY CONTINUE (SEE DTUR)        *\n*                        8 = OPERATION ERROR (R1 = MESSAGE ADDRESS /  *\n*                            SEE DTUR WHEN RC IS 8 OR 12)             *\n***********************************************************************\n         USING DRFCALL,R15\nDRFCALL  STM   R2,R10,DRFSV        SAVE R2-R10\n         LR    R10,R15             SET LOCAL BASE\n         DROP  R15\n         USING DRFCALL,R10\n         ST    R14,DRFRET\n         STC   R0,DRFFSE\n         CLI   DRFFSE,0            START\n         BE    DRFSR1\n         CLI   DRFFSE,1            SEARCH\n         BE    DRFSL1\n         CLI   DRFFSE,2            LIST\n         BE    DRFSL1\n         CLI   DRFFSE,64           RD-DIR\n         BE    DRFRM1\n         CLI   DRFFSE,127          MOD-ID\n         BE    DRFRM1\n         CLI   DRFFSE,128          STATS\n         BE    DRFST1\n         CLI   DRFFSE,255          END\n         BE    DRFEN1\n         LA    R1,DRFLSE           JUST TO HAVE DIAGNOSTIC MESSAGE\n         BAS   R8,DRFDTUR\nDRFSMS   MVI   DRFMSG+4,C' '\n         MVC   DRFMSG+5(78),DRFMSG+4\n         XR    R14,R14\n         IC    R14,0(R1)\n         CH    R14,=H'79'\n         BNH   *+L'*+4\n         LH    R14,=H'79'\n         BCT   R14,*+L'*+6\n         LTR   R14,R14\n         BM    *+L'*+4\n         EX    R14,DRFMVM\n         CLC   DRFMSG+77(6),ALLBLKS\n         BNE   DRFMEX\n         LA    R14,DRFMSG+76\n         CLI   0(R14),C' '\n         BNE   *+L'*+4\n         BCT   R14,*-8\n         MVC   1(6,R14),=CL6'/RC=  '\n         CVD   R15,DRFWKD\n         UNPK  DRFWKD(5),DRFWKD+6(3)\n         MVC   5(2,R14),DRFWKD+1\nDRFMEX   LA    R1,DRFMSG           MESSAGE ADDRESS\n         LA    R15,8               CC=8\nDRFEXIT  L     R14,DRFRET\n         LM    R2,R10,DRFSV        RESTORE R2-R10\n         BR    R14\nDRFMVM   MVC   DRFMSG+4(*-*),1(R1) <<EXECUTED>>\n         SPACE 1\nDRFSR1   TM    OPERSW,DRFDDS       DATA-SET ALREADY STARTED\n         BZ    DRFSR2              NO\n         MVI   DRFFSE,255          YES, CLOSE CURRENT\n         LA    R1,DRFLSE\n         BAS   R8,DRFDTUR\n         NI    OPERSW,255-DRFDDS   SAY ENDED\n         LTR   R15,R15\n         BNZ   DRFSMS              ERROR\n         MVI   DRFFSE,0            RESTORE START\nDRFSR2   LA    R1,DRFLSE\n         BAS   R8,DRFDTUR\n         LTR   R15,R15\n         BNZ   DRFSMS              ERROR\n         OI    OPERSW,DRFDDS       SAY STARTED\n         B     DRFEXIT\n         SPACE 1\nDRFSL1   MVC   DRFFSL,DRFFSE\n         BAS   R7,DRFDSOP\n         LA    R1,DRFLSL\nDRFSS1   BAS   R8,DRFDTUR\n         CH    R15,=H'4'\n         BNH   DRFEXIT\n         B     DRFSMS              ERROR\n         SPACE 1\nDRFRM1   MVC   DRFFRM,DRFFSE\n         BAS   R7,DRFDSOP\n         LA    R1,DRFLRM\n         B     DRFSS1\n         SPACE 1\nDRFST1   XC    DRFTOTN(L'DRFTOTN+L'DRFTOTL),DRFTOTN\n         LA    R1,DRFLST\n         B     DRFSS1\n         SPACE 1\nDRFEN1   TM    OPERSW,DRFDDS       DATA-SET ALREADY ENDED\n         BO    *+L'*+6             NO\n         XR    R15,R15             YES, CC=0\n         B     DRFEXIT\n         LA    R1,DRFLSE\n         BAS   R8,DRFDTUR\n         LTR   R15,R15\n         BNZ   DRFSMS              ERROR\n         NI    OPERSW,255-DRFDDS   SAY ENDED\n         B     DRFEXIT\n         SPACE 1\nDRFDSOP  TM    OPERSW,DRFDDS       DATA-SET ALREADY STARTED\n         BOR   R7                  YES, RETURN\n         MVI   DRFFSE,0            SAY START\n         LA    R1,DRFLSE\n         BAS   R8,DRFDTUR\n         LTR   R15,R15\n         BNZ   DRFSMS              ERROR\n         OI    OPERSW,DRFDDS       SAY STARTED\n         BR    R7                  RETURN\n         SPACE 1\nDRFDTUR $TSWXA 24,EXPAND=ONLY      BACK TO 24-BIT\n         L     R15,=V(DTUSE)\n         BASR  R14,R15\n        $TSWXA 31,EXPAND=ONLY      RE-ENTER 31-BIT\n         BR    R8\n         DROP  R10\n         SPACE 1\nDRFWKD   DC    D'0'\nDRFSV    DC    9F'0'               R2-R10\nDRFRET   DC    F'0'                R14\nDRFLSE   DC    A(X'80000000'+DRFFSE)\nDRFLSL   DC    A(X'80000000'+DRFFSL)\nDRFLRM   DC    A(X'80000000'+DRFFRM)\nDRFLST   DC    A(X'80000000'+DRFFST)\nDRFMSG  WTO    '----+----1----+----2----+----3----+----4----+----5----+1\n               ----6----+----7----+----',MF=L\n         SPACE 1\n        LTORG\n         EJECT\n         DROP  R11\n         SPACE 1\n         DS    0D\nVCWORK  $HEDIT WORK\n         USING VCWORK,R11          SERVICE ROUTINES AND WORK AREAS\n         SPACE 1\n***********************************************************************\n*        CONSTANTS AND WORK AREAS.                                    *\n***********************************************************************\n         SPACE 1\nDBLWD    DC    D'0'\nREQAUT   DC    0F'0',B'00000000',AL3(MDL@IX),AL4(AUTH)\nATSO     DC    A(*-*)\nACSQA    DC    A(*-*)              COMMON SQA SUBPOOL 226 ADDRESS\nOLDPICA  DC    F'0'                SAVE OLD PICA ADDRESS\nSVSADD   DC    F'0'\nBEGADD   DC    A(VCOREZAP)\nENDADD   DC    A(VCOREEND)\nSVAD     DC    A(*-*)\nSCVAL    DC    A(ANSR,1,ANSR+L'ANSR-1)\nSCFIX    DC    A(FIXTB,L'FIXTB,FIXTBE)\nTBVAL    DC    A(TABLE,L'TABLE,TABLE-L'TABLE)\nSCASTB   DC    A(ASTB,ASTBL,*-*)\nATKWAS   DC    A(STKWAS)\nCATKWA   DC    A(*-*)\nECBR     DC    F'0'\nAXPL     DC    0F'0',H'1',H'0'\nSASID    DC    F'0'                SECONDARY AS-ID\nWASID    DC    F'0'                SECONDARY WORK AS-ID\nMYASCB   DC    F'0'                MY ASCB ADDRESS\nRCXR     DC    F'0'                AXRES RETURN CODE\nRCXS     DC    F'0'                AXSET RETURN CODE\nRCXF     DC    F'0'                AXFRE RETURN CODE\nDTPTR    DC    F'0'                DATA ADDRESS\nPVPTR    DC    F'0'                PREVIOUS DATA POINTER\nCRPTR    DC    F'0'                CURRENT DATA POINTER\nRCVPTR   DC    F'0'                RECOVERY DATA POINTER\nBLKPTR   DC    F'0'                BLOCK DATA ADDRESS\nWRPTR    DC    F'0'                A.S. WRAP POINTER\nCFFPTR   DC    F'0'                CONTROL FIND FULL POINTER\nWDSLN    DC    F'0'\nWDSPT    DC    F'0'\nGFBYT    DC    F'0'\nGLBYT    DC    F'0'\nRETCC    DC    F'0'                RETURN CODE (CC)\nDATA     DC    F'0',X'0'\nAUTH     DC    XL1'0'\nLBLF     DC    CL8' '\nNMEF     DC    CL8' '\nASSNME   DC    CL8' '\nFXLAB    DC    XL8'0',X'0'\nTSTBT    DC    XL1'0'\nTRANTBL  DC    X'000A0B0C0D0E0F'\n         DC    9X'00'\n         DC    X'00010203040506070809'\n         DC    6X'00'\nMSGOUT   DC    0F'0',AL2(MSGLL),XL2'0'\nMSGTXT   DC    CL72' '\nMSGLL    EQU   *-MSGOUT\nANSR     DC    CL72' '\nMSGSVTO  DC    0F'0',AL2(MSGSVTL),XL2'0'\nMSGSVT   DC    CL79' '\nMSGSVTL  EQU   *-MSGSVTO\nSTRNGL   DC    XL1'0'              LENGTH OF FIND DATA\nSTRNG    DC    XL16'0'             STORAGE OF FIND DATA\nTBUF     DC    XL40'0'             TEMPORARY STORAGE OF DATA\nTSRTL    DC    C'INPUT TOO LONG - RESPECIFY :'\nMYASIDN  DC    H'0'                MY AS-ID NUMBER\nASIDN    DC    H'0'                AS-ID NUMBER\nMYASNME  DC    CL8' '              MY AS-ID NAME\nASNME    DC    CL8' '              AS-ID NAME\nCTKWAN   DC    CL4' '              CURRENT TANK NUMBER\nPRVOP    DC    CL1'S'\nGNBYT    DC    XL1'0'\nADVICE   DC    CL5' '\nRCVIND   DC    CL5' '\nHEXTAB   DC    CL16'0123456789ABCDEF'   HEX TABLE TRANSLATION\nALLBLKS  DC    CL80' '\n         EJECT\n***********************************************************************\n*        DTUR ROUTINE FUNCTIONS WORK AREAS.                           *\n***********************************************************************\n         SPACE 1\nDRFFSE   DC    AL1(*-*)            FUNCTION = 0 (START) OR 255 (END)\nDRFDSL   DC    AL1(16)\nDRFDSN   DC    CL44'SYS.TDSECTS.DATA'\nDRFFSL   DC    AL1(*-*)            FUNCTION = 1 (SEARCH) OR 2 (LIST)\nDRFDSCT  DC    CL8' '\nDRFFLDN  DC    CL8' '\nDRFDSPL  DC    XL2'0'\nDRFLNGH  DC    XL2'0'\nDRFFLGN  DC    CL8' '\nDRFFLVL  DC    XL2'0'\nDRFFLLG  DC    XL2'0'\nDRFFRM   DC    AL1(*-*)       FUNCTION = 64 (RD-DIR) OR 127 (MOD-ID)\nDRFFRMN  DC    CL8' '\nDRFFRMA  DC    CL8' '\nDRFFRMD  DC    CL16' '\nDRFFST   DC    AL1(128)            FUNCTION = 128 (STATS)\nDRFTOTN  DC    XL4'0'\nDRFTOTL  DC    XL4'0'\n         EJECT\n***********************************************************************\n*        FULL SCREEN DISPLAY WORK AREAS.                              *\n***********************************************************************\n         SPACE 1\nFSRCVR   DC    7F'0'               SAVE R0-R6 (OVERLAP IN NEXT FIELD)\nFSSAVE   DC    9F'0'               SAVE R2-R10 (OR R7-R15 OF PREVIOUS)\nSZLINE   DC    F'0'                LINE SIZE (LINE LENGTH)\nSZSCRN   DC    F'0'                SCREEN SIZE (NUMBER OF LINES)\nFSPOINT  DC    F'0'                SCREEN LINE POINTER\nFSRPLYL  EQU   66                  LENGTH OF REPLY AREA\nFSCODE   DC    XL6'0'              AID + JUNK\nFSTEXT   DC    XL(FSRPLYL)'0'      REAL REPLY\nREPLYL   EQU   L'FSCODE+L'FSTEXT\nLSTDSP   DC    XL(FSRPLYL)'0'      RETAIN LAST DISPLAY COMMAND\n         SPACE 1\nFSCREEN $FS    CC=W,MF=L           FULL SCREEN DEFINITIONS\n        $FS    WCC=(KBR,RMDT),SBA=(24,80),MF=L\n        $FS    SBA=(1,1),SF=(PROT),RA=(1,30,'-'),MF=L       LINE 1\n        $FS    SF=(PROT,INT),TEXT='VIRTUAL CORE   Z A P',MF=L\n        $FS    SF=(PROT),RA=(1,80,'-'),MF=L\n        $FS    SF=(PROT,INT),MF=L\n        $FS    TEXT='COMMAND ===>',MF=L                     LINE 2\n        $FS    SBA=(2,80),MF=L     SKIP OVER COMMAND INPUT AREA\n        $FS    SF=(PROT,INT),MF=L\nFSCRFIXL EQU   *-FSCREEN           LENGTH OF FIXED PART (LINES 1 AND 2)\nFSCRMSG $FS    TEXT=(' ',80),MF=L                           LINE 3\n        $FS    SF=(PROT),MF=L                               LINE 4\nFSCRSCL $FS    TEXT=(' ',54),MF=L\n        $FS    TEXT=(' ',18),MF=L\nFSCRSDC $FS    SF=(PROT),MF=L\nFSCRTDC $FS    TEXT=(' ',6),MF=L\n        PRINT  NOGEN\nFSCRLNS @WL    16                                     LINES 5 TO 20\n        PRINT  GEN\n        $FS    SF=(PROT),MF=L                               LINE 21\nFSCRSTL $FS    RA=(21,37,'-'),MF=L\n        $FS    SF=(PROT,INT),TEXT='STATUS',MF=L\n        $FS    SF=(PROT),RA=(21,80,'-'),MF=L\n        $FS    TEXT=' ',MF=L\nFSCRSTLL EQU   *-FSCRSTL\n        PRINT  NOGEN\nFSCRLST @WL    3                                     LINES 22 TO 24\n        PRINT  GEN\nFSCRLNW  EQU   *-FSCREEN\n        $FS    SBA=(2,13),SF=NORMAL,MF=L     COMMAND INPUT AREA\nFSCRTXT  DC    XL(FSRPLYL)'0'\n        $FS    SBA=(1,1),SF=(PT,IC),MF=L\nFSCRLNG  EQU   *-FSCREEN\n         SPACE 1\nFSCLR   $FS    CC=EW,MF=L          CLEAR SCREEN DEFINITIONS\n        $FS    WCC=(AL,KBR,RMDT),SBA=(24,79),MF=L\n        $FS    SBA=(1,1),RA=(1,1,00),MF=L\n        $FS    SF=(INT,IC),MF=L\nFSCLRL   EQU   *-FSCLR\n         EJECT\n***********************************************************************\n*        PROCESSING SWITCHES.                                         *\n***********************************************************************\n         SPACE 1\nSTATUS   DC    XL1'0'         STATUS INDICATORS\n         SPACE 1\nFTYPE    EQU   X'80'               FIND TYPE IS CHAR\nMATCHREQ EQU   X'40'               LIST MATCH REQUESTED\nONELSTD  EQU   X'20'               AT LEAST ONE LINE LISTED\nSUBSTRCT EQU   X'10'               SUBSTRACT REQUESTED\nTSORUN   EQU   X'08'               WE ARE RUNNING IN TSO\nTSORSC   EQU   X'04'               WE ARE RUNNING IN TSO ON A SCREEN\nTESTRUN  EQU   X'02'               TEST RUN REQUESTED\nDANGER   EQU   X'01'               BE CARE WITH ALTERATION\n         SPACE 1\nSWITCH   DC    XL1'0'         ACTION INDICATORS\n         SPACE 1\nVASTB    EQU   X'80'               VALID AS-ID TABLE\nACTIVM   EQU   X'40'               ACTIVE AS-ID MODE\nXMEMRF   EQU   X'20'               X-MEM. REF. REQUEST\nPOPXMR   EQU   X'10'               PREVIOUS OP. X-MEM. REF. MODE\nASFULL   EQU   X'08'               FIND THROUGH ENTIRE A.S.\nPVALID   EQU   X'04'               VALID PREVIOUS LAST 16 BYTES\nTSTEAP   EQU   X'02'               TEST END ADDRESS PROTECTION\nCSQAF    EQU   X'01'               COMMON SQA SUBPOOL 226\n         SPACE 1\nOPERSW   DC    XL1'0'         OPERATION INDICATORS\n         SPACE 1\nFFSTUP   EQU   X'80'               FIND FULL STATUS UPDATE\nINPEND   EQU   X'40'               INPUT IS PENDING\nGETBSW   EQU   X'20'               GET BYTES REQUESTED\nDRFDDS   EQU   X'10'               DTUR DATA-SET STARTED\nDRF1ST   EQU   X'08'               DTUR 1ST OF LIST DONE\nDRFL1F   EQU   X'04'               DTUR LIST 1ST FLIP-FLOP\nDRFL2F   EQU   X'02'               DTUR LIST 2ND FLIP-FLOP\n         EJECT\nFSCRSW   DC    XL1'0'         FULL SCREEN INDICATORS\n         SPACE 1\nFSCRSF   EQU   X'80'               FULL SCREEN\nFSCRSS   EQU   X'40'               SET SCREEN SIZE\nFSCRSR   EQU   X'20'               RESET SCREEN SIZE\nFSCRSC   EQU   X'10'               SET CONTINUATION\nFSCRSH   EQU   X'08'               HELP PANEL DISPLAY\nFSCRST   EQU   X'04'               SET STATUS LINES\nFSCRSL   EQU   X'02'               SET DATA LINES\nFSCRSI   EQU   X'01'               SET INTENSIVE DISPLAY LINE\n         SPACE 1\nFSPRSW   DC    XL1'0'         FULL SCREEN PROCESSING INDICATORS\n         SPACE 1\nFSPRDS   EQU   X'80'               FULL SCREEN DISPLAY FOR RECOVER\n         SPACE 1\nHCPRSW   DC    XL1'0'         HARDCOPY REQUESTS - STATUS\n         SPACE 1\nHCCOPY   EQU   X'80'               HARDCOPY ACTIVE\nHCCLOSE  EQU   X'40'               CLOSE HARDCOPY\nHCFAIL   EQU   X'20'               HARDCOPY OPEN FAILED\nHCANSR   EQU   X'01'               WTOR OR TSO/TGET DONE\n         EJECT\n***********************************************************************\n*        HARDCOPY WORK AREAS.                                         *\n***********************************************************************\n         SPACE 1\nHCSAVE   DC    16F'0'\nHCWORK   DC    D'0'\n         SPACE 1\nH99RBPTR DC    A(H99RB+X'80000000')     SVC 99 REQUEST BLOCK PTR\nH99RB    DS    0F             SVC 99 REQUEST BLOCK\n         DC    AL1(H99RBLN)             RB LENGTH IN BYTES\nH99VERB  DC    AL1(S99VRBAL)            VERB CODE (DSNAME ALL.)\nH99FLAG1 DC    AL1(S99NOCNV+S99NOMNT,0) FLAGS 1\nH99ERROR DC    XL2'0'                   ERROR CODE\nH99INFO  DC    XL2'0'                   INFO CODE\nH99TXTPP DC    A(H99TUPL)               POINTER TO TEXT UNIT PTRS\nH99RSVD1 DC    XL4'0'                   RESERVED\nH99FLAG2 DC    XL4'0'                   FLAGS 2\nH99RBLN  EQU   *-H99RB                  RB LENGTH\nH99TUPL  DS    0F                  TEXT UNIT POINTERS\n         DC    A(H99TUKY1)              SYSOUT\n         DC    A(H99TUKY2)              FREE AT CLOSE\n         DC    A(H99TUKY3)              LAST PARM IF NO DEST=\n         DC    A(H99TUKY4+X'80000000')  LAST PARM IF DEST= GIVEN\nH99TUKY1 DC    AL2(DALSYSOU),AL2(1),AL2(1)\nH99SYSOC DC    CL1'A'                   SYSOUT=A\nH99TUKY2 DC    AL2(DALCLOSE),AL2(0)     UNALLOC AT CLOSE\nH99TUKY3 DC    AL2(DALSUSER),AL2(1)     OPTIONAL : DEST=RMTXXX\nH99DESTL DC    AL2(*-*)                 LENGTH OF DEST\nH99DEST  DC    CL8' '                   DEST PARAMETER\nH99TUKY4 DC    AL2(DALRTDDN),AL2(1)     DDNAME RETURN\nH99DDNL  DC    AL2(8)                   LENGTH OF DDNAME\nH99DDN   DC    CL8' '                   DDNAME\n         SPACE 1\nHCPYDCB  DCB   DDNAME=VCZHCOPY,DSORG=PS,MACRF=(PM),                    1\n               RECFM=FA,LRECL=91,BLKSIZE=91\n         SPACE 1\nHCBYEAR  DC    F'0'\nHCBDAYS  DC    F'0'\nHCBDATE  DC    F'0'\nHCPAGE#  DC    PL3'+1'             PAGE NUMBER\nHCLINE#  DC    PL3'+0'             LINES COUNT\nHCMNMSK  DC    AL1(31,30,31,30,31,31,30,31,30,31,28,31)\nHCDAYTAB DC    CL3'TUE',C'WEDTHUFRISATSUNMON'\nHCMONTAB DC    CL3'DEC',C'NOVOCTSEPAUGJULJUNMAYAPRMARFEBJAN'\n         SPACE 1\nHCHEAD1  DC    CL1'1',CL10' '      ASA ON HEADING\n         DC    CL23'VCZ-HARDCOPY LOG  USER='\nHCUSER   DC    CL7' ',CL2' '       FOR USERID\n         DC    CL4'DATE'\nHJDATE   DC    CL7' ',CL3' - '\nHTMEHRS  DC    CL2' ',CL1':'\nHTMMINS  DC    CL2' ',CL1':'\nHTMSECS  DC    CL2' ',CL1' '\nHCDAY    DC    CL3' ',CL1' '\nHCMON    DC    CL3' ',CL1' '\nHCDAYN   DC    CL2' ',CL3',19'\nHCYR     DC    CL2' ',CL1' '\nHCPAGS   DC    CL1' ',CL2'  '\nHCPAGE   DC    CL6' '\n         SPACE 1\nHCHEAD2  DC    CL1' ',CL10' ',80C'-'\n         SPACE 1\nHCDETAIL DC    CL1' ',CL10' '      ASA CONTROL CHARACTER\nHCLINE   DC    CL80' '             TO HOLD PRINT LINE\n         EJECT\n***********************************************************************\n*        SEGMENT-TABLE CHECK WORK AREAS.                              *\n***********************************************************************\n         SPACE 1\nSGASVA   DC    18F'0'\nSGSAVE   DC    15F'0'\nSGSVR13  DC    F'0'\nSGTEL    EQU   4                   SEGMENT-TABLE ENTRY LENGTH\nLSVSGT   DC    A(2*KB*SGTEL)\nASVSGT   DC    A(*-*)\nMVSGT    DC    F'0'\nCC1      DC    XL1'0'\nCC2      DC    XL1'0'\n         SPACE 1\nSGTPSW   DC    XL1'0'         SEGMENT-TABLE PROCESSING INDICATORS\nSTPDIS   EQU   X'80'               SEGMENT-TABLE PROCESSING DISABLED\nSTPUSE   EQU   X'40'               SEGMENT-TABLE PROCESSING INHIBIT\nSTPLST   EQU   X'01'               SEGMENT-TABLE DISPLAY REQUEST\n         SPACE 1\n*--- --- END OF BASE REGISTER (R11) ADDRESSING --- --- --- --- --- ---*\n         EJECT\n         DROP  R13\n         SPACE 1\n         DS    0D\nVSVERR  $HEDIT ERRORS\n         USING VSVERR,R13          SAVE AREA AND ERROR RETURNS\n         SPACE 1\n***********************************************************************\n*        SAVE AREA.                                                   *\n***********************************************************************\n         SPACE 1\n         DC    18F'0'\n         SPACE 1\n***********************************************************************\n*        ERROR RETURNS.                                               *\n***********************************************************************\n         SPACE 1\nERR1     L     R1,=A(ERM1)\n         B     ERROR\nERR2     L     R1,=A(ERM2)\n         B     ERROR\nERR3     L     R1,=A(ERM3)\n         B     ERROR\nERR4     L     R1,=A(ERM4)\n         B     ERROR\nERR5     L     R1,=A(ERM5)\n         B     ERROR\nERR6     L     R1,=A(ERM6)\n         B     ERROR\nERR7     L     R1,=A(ERM7)\n         B     ERROR\nERR8     L     R1,=A(ERM8)\n         B     ERROR\nERR9     L     R1,=A(ERM9)\n         B     ERROR\nERR10    L     R1,=A(ERM10)\n         B     ERROR\nERR11    L     R1,=A(ERM11)\n         B     ERROR\nERR12    L     R1,=A(ERM12)\n         B     ERROR\nERR13    L     R1,=A(ERM13)\n         B     ERROR\nERR14    L     R1,=A(ERM14)\n         B     ERROR\nERR15    L     R1,=A(ERM15)\n         B     ERROR\nERR16    L     R1,=A(ERM16)\n         B     ERROR\nERR17    L     R1,=A(ERM17)\n         B     ERROR\nERR18    L     R1,=A(ERM18)\n         B     ERROR\nERR19    L     R1,=A(ERM19)\n         B     ERROR\nERR20    L     R1,=A(ERM20)\n         B     ERROR\nERR21    L     R1,=A(ERM21)\n         B     ERROR\nERR22    L     R1,=A(ERM22)\n         B     ERROR\nERR23    L     R1,=A(ERM23)\n         B     ERROR\nERR24    L     R1,=A(ERM24)\n         B     ERROR\nERR25    L     R1,=A(ERM25)\n         B     ERROR\nERR26    L     R1,=A(ERM26)\n         B     ERROR\nERR27    L     R1,=A(ERM27)\n         B     ERROR\nERR28    L     R1,=A(ERM28)\n         B     ERROR\nERR29    NI    SWITCH,255-XMEMRF-POPXMR-ASFULL-PVALID  RESET\n         BAS   R8,DISABLE ---------------------------------- * DANGER *\n         L     R1,=A(ERM29)\n         B     ERROR\nERR30    NI    SWITCH,255-XMEMRF-POPXMR-ASFULL-PVALID  RESET\n         BAS   R8,DISABLE ---------------------------------- * DANGER *\n         L     R1,=A(ERM30)\n         B     ERROR\nERR31    NI    SWITCH,255-XMEMRF-POPXMR-ASFULL-PVALID  RESET\n         BAS   R8,DISABLE ---------------------------------- * DANGER *\n         L     R1,=A(ERM31)\n         B     ERROR\nERR32    L     R1,=A(ERM32)\n         B     ERROR\nERR33    L     R1,=A(ERM33)\n         B     ERROR\nERR34    L     R1,=A(ERM34)\n         B     ERROR\nERR35    L     R1,=A(ERM35)\n         B     ERROR\nERR36    L     R1,=A(ERM36)\n         B     ERROR\nERR37    L     R1,=A(ERM37)\n         B     ERROR\nERR38    L     R1,=A(ERM38)\n         B     ERROR\nERR39    L     R1,=A(ERM39)\n         B     ERROR\nERR40    L     R1,=A(ERM40)\n         B     ERROR\nERR41    L     R1,=A(ERM41)\n         B     ERROR\nERR42    L     R1,=A(ERM42)\n         B     ERROR\nERR43    L     R1,=A(ERM43)\n         B     ERROR\nERR44    L     R1,=A(ERM44)\n         B     ERROR\nERR45    L     R1,=A(ERM45)\n         B     ERROR\nERR46    L     R1,=A(ERM46)\n         B     ERROR\nERR47    L     R1,=A(ERM47)\n         B     ERROR\nERR48    L     R1,=A(ERM48)\n         B     ERROR\nERR49    L     R1,=A(ERM49)\n         B     ERROR\n         SPACE 1\n        LTORG\n         SPACE 1\n*--- --- END OF BASE REGISTER (R13) ADDRESSING --- --- --- --- --- ---*\n         EJECT\n         DROP  R11,R12,R13         KILL ADDRESSABILITIES\n         SPACE 2\n***********************************************************************\n*        NEXT COMMAND REQUEST.                                        *\n***********************************************************************\n         SPACE 1\nINQRY   WTOR   'ENTER :',ANSR,L'ANSR,ECBR,MF=L\n         EJECT\n***********************************************************************\n*        INTERCEPT 0C4 PARAMETER LISTS.                               *\n***********************************************************************\n         SPACE 1\nESPLST  ESPIE  SET,ESPEXIT,(4),MF=L\n         SPACE 1\nSGELST  ESPIE  SET,SGEXIT,(4,17),MF=L\n         EJECT\n***********************************************************************\n*        INTERCEPT 0C4 ROUTINES.                                      *\n***********************************************************************\n         SPACE 1\n         CNOP  0,8\n         USING *,R15\n         USING EPIE,R1\nESPEXIT  MVC   EPIEPSW+4(4),RCVADDR     SET RETURN ADDRESS\n         BR    R14                 BACK TO CONTROL PROGRAM\n         DROP  R1\n         SPACE 1\nRCVADDR  DC    A(X'80000000'+RECOVER0)\n         DROP  R15\n         SPACE 2\n         CNOP  0,8                 INTERCEPT 0C4 EXIT ROUTINE\n         USING *,R15\n         USING EPIE,R1\nSGEXIT   MVC   EPIEPSW+4(4),SGRCVA SET RETURN ADDRESS\n         MVC   SV0C4(PLGTH),EPIEGPR     MOVE ALL INFORMATION FROM EPIE\n         XC    CC0,CC0             SAY INTERCEPTED\n         BR    R14                 BACK TO CONTROL PROGRAM\n         DROP  R1\n         SPACE 1\nSGRCVA   DC    A(X'80000000'+SGRCVRY)\nCC0      DC    F'0'\nPLGTH    EQU   L'EPIEGPR+L'EPIEPSW+L'EPIEINT+L'EPIETEA\nNWRDS    EQU   PLGTH/4\nSV0C4    DC    (NWRDS)F'0'\n         DROP  R15\n         EJECT\n***********************************************************************\n*        MESSAGES TEXT.                                               *\n***********************************************************************\n         SPACE 1\n        PRINT  NOGEN\nINITM  @WTO    '    --- VIRTUAL CORE ZAP ---'\nINITH  @WTO    '    ENTER H TO OBTAIN COMMANDS SUMMARY'\nUNAUT  @WTO    'UNAUTHORIZED USE - END PROCESS FORCED'\nENBLM  @WTO    'STORE ANYWHERE ENABLED. - TAKE CARE |||'\nDSBLM  @WTO    'STORE ANYWHERE DISABLED. - O.K.'\nXRFAIL @WTO    'AXRES (RESERVE AUTHORIZATION INDEX) FAILED'\nXSFAIL @WTO    'AXSET (SET AUTHORIZATION INDEX) FAILED'\nXFFAIL @WTO    'AXFRE (FREE AUTHORIZATION INDEX) FAILED'\nDISRC  @WTO    '    R15 (RC) =           '\nDISCC  @WTO    '    0C4 --- PROTECTION AT :           '\nNFNDAS @WTO    'NOT FOUND - ADDRESS SPACE SCAN ENDED'\nHCSFM  @WTO    'HARDCOPY STOPPED - SYSOUT FREED FOR PRINT'\nSGERM1 @WTO    'SEGMENT-TABLE EMPTY (NO ENTRIES HAS BEEN MOVED)'\nSGERM2 @WTO    'SEGMENT-TABLE PROCESS ERROR (DISABLED FOR EVER)'\n         SPACE 1\nERM1   @WTO    'UNKNOWN COMMAND - REQUEST IGNORED'\nERM2   @WTO    'OPERAND MISSING - REQUEST IGNORED'\nERM3   @WTO    'OPERAND TOO LONG - REQUEST IGNORED'\nERM4   @WTO    'INVALID OPERAND - REQUEST IGNORED'\nERM5   @WTO    'LABEL MISSING - REQUEST IGNORED'\nERM6   @WTO    'LABEL TOO LONG - REQUEST IGNORED'\nERM7   @WTO    'INVALID LABEL - REQUEST IGNORED'\nERM8   @WTO    'LABELS TABLE FULL - REQUEST IGNORED'\nERM9   @WTO    'DISPLACEMENT MISSING - REQUEST IGNORED'\nERM10  @WTO    '+ OR - OPERATOR MISSING - REQUEST IGNORED'\nERM11  @WTO    'NO ACTIVE USER-AREA - REQUEST IGNORED'\nERM12  @WTO    'AS-ID TABLE FULL : REMAINING AS-ID LOST'\nERM13  @WTO    'NO VALID AS-ID TABLE - REQUEST IGNORED'\nERM14  @WTO    'INVALID NAME - REQUEST IGNORED'\nERM15  @WTO    'NAME TOO LONG - REQUEST IGNORED'\nERM16  @WTO    'NOT FOUND IN TABLE - REQUEST IGNORED'\nERM17  @WTO    'INVALID HEX DIGITS ENTERED - REQUEST IGNORED'\nERM18  @WTO    'ODD NO. OF DIGITS ENTERED - REQUEST IGNORED'\nERM19  @WTO    'NO LABELS ENTERED IN TABLE - REQUEST IGNORED'\nERM20  @WTO    'UNDEFINED LABEL - REQUEST IGNORED'\nERM21  @WTO    'INVALID COMMAND - REQUEST IGNORED'\nERM22  @WTO    'UNAUTHORIZED COMMAND - REQUEST IGNORED'\nERM23  @WTO    'UNAUTHORIZED DISPLAY - REQUEST IGNORED'\nERM24  @WTO    'UNAUTHORIZED STORE - REQUEST IGNORED'\nERM25  @WTO    'UNAUTHORIZED FIND - REQUEST IGNORED'\nERM26  @WTO    'PREDEFINED LABEL NAME - REQUEST IGNORED'\nERM27  @WTO    'NOT UNIQUE AS-ID NAME - REQUEST IGNORED'\nERM28  @WTO    'NO AS-ID MODE ACTIVE - REQUEST IGNORED'\nERM29  @WTO    'INVALID ACTIVE AS-ID - REQUEST IGNORED / RESET'\nERM30  @WTO    'UNEXISTANT ACTIVE AS-ID - REQUEST IGNORED / RESET'\nERM31  @WTO    'ACTIVE AS-ID SWAP-OUT - REQUEST IGNORED / RESET'\nERM32  @WTO    '=== HARDCOPY IS ALREADY ACTIVE ==='\nERM33  @WTO    'SORRY, ... HARDCOPY OPEN FAILED'\nERM34  @WTO    '=== HARDCOPY IS ALREADY INACTIVE ==='\nERM35  @WTO    'FINAL DELIMITER MISSING - REQUEST IGNORED'\nERM36  @WTO    'USER-AREA EMPTY - REQUEST IGNORED'\nERM37  @WTO    'DSECT-NAME MISSING - REQUEST IGNORED'\nERM38  @WTO    'INVALID DSECT-NAME - REQUEST IGNORED'\nERM39  @WTO    'DSECT-NAME TOO LONG - REQUEST IGNORED'\nERM40  @WTO    'DSECT REQUEST MISSING - REQUEST IGNORED'\nERM41  @WTO    'FIELD OR FLAG NAME TOO LONG - REQUEST IGNORED'\nERM42  @WTO    'INVALID FLAG VALUE - REQUEST IGNORED'\nERM43  @WTO    'FLAG VALUE TOO LONG - REQUEST IGNORED'\nERM44  @WTO    'UNEXPECTED RC=4 FROM \"DTUR\" ROUTINE'\nERM45  @WTO    'INVALID DISPLACEMENT - REQUEST IGNORED'\nERM46  @WTO    'DISPLACEMENT TOO LONG - REQUEST IGNORED'\nERM47  @WTO    'DATA-SET TOO LONG - REQUEST IGNORED'\nERM48  @WTO    'INVALID NUMBER OF BYTES (1-16) - REQUEST IGNORED'\nERM49  @WTO    'SEGMENT-TABLE PROCESS HAS BEEN DISABLED FOR EVER'\n         EJECT\n***********************************************************************\n*        HELP MESSAGES TEXT.                                          *\n***********************************************************************\n         SPACE 1\nHELP01 @WTO  'VIRTUAL STORAGE COMMANDS SUMMARY :'\nHELP02 @WTO  '  D NNNN : DISPLAY 16 BYTES AT LOCATION NNNN'\nHELP03 @WTO  '           (ADDR + OR - DISPL ALLOWED).'\nHELP04 @WTO  '           JUST ENTER OR TYPE ONLY D TO DISPLAY'\nHELP05 @WTO  '           16 HEX BYTES STARTING AT THE CURRENT OR'\nHELP06 @WTO  '           +16 ADDRESS POINTER (CONTINUE DISPLAY).'\nHELP07 @WTO  '           UPDATED BY D, S, F AND A COMMANDS.'\nHELP08 @WTO  '           ENTER + OR - DECIMAL 1 UP TO 999 TO DISPLAY'\nHELP09 @WTO  '           FORWARD/BACKWARD FROM CURRENT POINTER.'\nHELP10 @WTO  '  S NNNN HHHH,... OR @N : STORE HHHH,... OR CONTENTS OF'\nHELP11 @WTO  '           USER-AREA N AT LOC. NNNN'\nHELP12 @WTO  '           (ADDR + OR - DISPL ALLOWED).'\nHELP13 @WTO  '  S * HHHH,... OR @N : CONTINUE STORE AT LOC. IN SEQ.'\nHELP14 @WTO  '  F ''...'' OR HHHH... : TO FIND A STRING.'\nHELP15 @WTO  '           JUST ENTER OR TYPE ONLY F TO CONTINUE'\nHELP16 @WTO  '           THE SEARCH IN THE NEXT 4K PAGE.'\nHELP17 @WTO  '           FULL : SEARCH ENTIRE ADDRESS SPACE.'\nHELP18 @WTO  '  --- ? : STATUS          --- E : TERMINATE'\nHELP19 @WTO  '  --- H : HELP VIRTUAL STORAGE COMMANDS.'\nHELP20 @WTO  '  --- HL : HELP LABEL''S AND DSECT''S COMMANDS.'\nHELP21 @WTO  '  --- HM : HELP MISCELLANEOUS COMMANDS.'\nHELP22 @WTO  '  --- HX : HELP ADDRESS SPACE COMMANDS (OR XH).'\nHELP23 @WTO  '  C ON/OFF : TO ALTER VIRTUAL CORE STORAGE.'\nHELP24 @WTO  '  T L(INE)/S(CREEN) : FLIP-FLOP LINE/FULL SCREEN.'\nHELP25 @WTO  '  T ON/OFF : TO ACCESS OWN PROGRAM STORAGE (C OFF ONLY).'\nHELP26 @WTO  '  T YES/NO : TO USE SEGMENT-TABLE PROCESS (FIND FULL).'\n         SPACE 2\nHELP30 @WTO  'LABEL''S AND DSECT''S COMMANDS SUMMARY :'\nHELP31 @WTO  '  A LLLL NNNN : ASSIGN TO LABEL LLLL VALUE NNNN'\nHELP32 @WTO  '           (ADDR + OR - DISPL ALLOWED).'\nHELP33 @WTO  '           IF NNNN OMITTED = CURRENT POINTER.'\nHELP34 @WTO  '  Z LLLL : DELETE LABEL LLLL AND HIS VALUE.'\nHELP35 @WTO  '  L LLLL : DISPLAY VALUE OF LABEL(S) LLLL'\nHELP36 @WTO  '           (IF LLLL OMITTED = ALL LABELS).'\nHELP37 @WTO  '  I : TO DISPLAY ALL THE PREDEFINED LABELS.'\nHELP38 @WTO  '  B : BROWSE ALL DSECT''S NAMES IN THE CURRENT DATA-SET.'\nHELP39 @WTO  '  B DDDD : BROWSE SEQUENTIALLY AN ENTIRE DSECT (DDDD IS'\nHELP40 @WTO  '           THE DSECT-NAME).'\nHELP41 @WTO  '  B DDDD ... : BROWSE INFORMATION FROM A DSECT (DDDD IS'\nHELP42 @WTO  '           THE DSECT-NAME). THEN ... MAY BE :'\nHELP43 @WTO  '           FFFF : A FIELD-NAME, OR'\nHELP44 @WTO  '           FFFF : A FLAG-NAME, OR'\nHELP45 @WTO  '           HHHH : A FIELD-DISPLACEMENT (HEX), OR'\nHELP46 @WTO  '           FFFF HH : A FIELD-NAME AND FLAG-VALUE (HEX).'\nHELP47 @WTO  '  Q : DISPLAY HOW CORE STORAGE SPACE HAS GROWN.'\nHELP48 @WTO  '  Q * : RESTART THE CURRENT DSECT''S DATA-SET.'\nHELP49 @WTO  '  Q SSSS : START A NEW DSECT''S DATA-SET (SSSS IS THE'\nHELP50 @WTO  '           DATA-SET NAME).'\n         SPACE 2\nHELP60 @WTO  'MISCELLANEOUS COMMANDS SUMMARY :'\nHELP61 @WTO  '  M @N : SET AND RETAIN AS CURRENT USER-AREA N.'\nHELP62 @WTO  '  M : DISPLAY THE CURRENT USER-AREA.'\nHELP63 @WTO  '  M Z OR R : ZEROS (Z) OR BLANKS (R) CURRENT USER-AREA.'\nHELP64 @WTO  '  M HHHH,... : STORE HHHH,... AT CURRENT LOC. POINTER.'\nHELP65 @WTO  '  M ''...'' : STORE CHARACTERS AT CURRENT LOC. POINTER.'\nHELP66 @WTO  '  M + OR - XX : FORWARD/BACKWARD MOVE OF LOC. POINTER.'\nHELP67 @WTO  '  M L XX : SET USER-AREA TEXT LENGTH TO XX (HEX).'\nHELP68 @WTO  '  P ON C(?) D(?) : START HARDCOPY (CLASS/DESTINATION).'\nHELP69 @WTO  '  P OFF : STOP HARDCOPY.'\nHELP70 @WTO  '  V : DISPLAY CURRENT ADDRESS SPACE SEGMENT-TABLE.'\n         SPACE 2\nHELP80 @WTO  'ADDRESS SPACE COMMANDS SUMMARY :'\nHELP81 @WTO  '  XT : LOAD/REFRESH AS-TABLE AND RESET AS-ID MODE.'\nHELP82 @WTO  '  XA XXXX : ACTIVATE AS-ID XXXX MODE (FOR NEXT'\nHELP83 @WTO  '           XD, XF AND XS COMMANDS).'\nHELP84 @WTO  '  XC : CLEAR AS-TABLE AND RESET AS-ID MODE.'\nHELP85 @WTO  '  XR : RESET AS-ID MODE.'\nHELP86 @WTO  '  XL XXXX : DISPLAY AS-NAME/AS-ID OF AS-TABLE'\nHELP87 @WTO  '           (IF XXXX OMITTED = ALL AS-TABLE).'\nHELP88 @WTO  '  XD, XF AND XS : DISPLAY, FIND AND STORE IN THE'\nHELP89 @WTO  '           ACTIVE AS-ID (SAME AS D, F AND S).'\nHELP90 @WTO  '  --- XH : HELP ADDRESS SPACE COMMANDS (OR HX).'\n         EJECT\n***********************************************************************\n*        TABLE OF PRINTABLE CHARACTERS.                               *\n***********************************************************************\n         SPACE 1\n        PRINT  GEN\nCHARTB   DC    256C'.'             TRANSLATE ALL GARBAGE TO '.'\n         ORG   CHARTB+C' '         BLANK\n         DC    C' '\n         ORG   CHARTB+C'\u00a2'         CENT\n         DC    C'\u00a2.<(+|&&'\n         ORG   CHARTB+C'!'         EXCLAMATION\n         DC    C'!$*);\u00ac-/'\n         ORG   CHARTB+C'\u00a6'         BROKEN BAR\n         DC    C'\u00a6,%_>?'\n         ORG   CHARTB+C'`'         ACCENT GRAVE\n         DC    C'`:#@''=\"'\n         ORG   CHARTB+C'A'-X'40'\n         DC    X'818283848586878889'\n         ORG   CHARTB+C'J'-X'40'\n         DC    X'919293949596979899'\n         ORG   CHARTB+C'S'-X'40'\n         DC    X'A2A3A4A5A6A7A8A9'\n         ORG   CHARTB+C'A'\n         DC    C'ABCDEFGHI'\n         ORG   CHARTB+C'J'\n         DC    C'JKLMNOPQR'\n         ORG   CHARTB+C'S'\n         DC    C'STUVWXYZ'\n         ORG   CHARTB+C'0'\n         DC    C'0123456789'\n         ORG   CHARTB+C'{'         LEFT BRACE\n         DC    C'{'\n         ORG   CHARTB+C'}'         RIGHT BRACE\n         DC    C'}'\n         ORG   CHARTB+C'~'         TILDE\n         DC    C'~'\n         ORG   CHARTB+C'\\'         BACKSLASH\n         DC    C'\\'\n         ORG\n         EJECT\n***********************************************************************\n*        TABLE OF ADDRESS POINTER DISPLACEMENTS (FULL SCREEN).        *\n***********************************************************************\n         SPACE 1\nFSTAPD   DC    AL1(FSL2-FSLOUT),CL1'>'                 0\n         DC    AL1(FSL2+5-FSLOUT),CL1'<'               1\n         DC    AL1(FSL2+5-FSLOUT),CL1'>'               2\n         DC    AL1(FSL2+10-FSLOUT),CL1'<'              3\n         DC    AL1(FSL2+L'FSL2-FSLOUT),CL1'>'          4\n         DC    AL1(FSL2+L'FSL2+5-FSLOUT),CL1'<'        5\n         DC    AL1(FSL2+L'FSL2+5-FSLOUT),CL1'>'        6\n         DC    AL1(FSL2+L'FSL2+10-FSLOUT),CL1'<'       7\n         DC    AL1(FSL2+2*L'FSL2-FSLOUT),CL1'>'        8\n         DC    AL1(FSL2+2*L'FSL2+5-FSLOUT),CL1'<'      9\n         DC    AL1(FSL2+2*L'FSL2+5-FSLOUT),CL1'>'      A\n         DC    AL1(FSL2+2*L'FSL2+10-FSLOUT),CL1'<'     B\n         DC    AL1(FSL2+3*L'FSL2-FSLOUT),CL1'>'        C\n         DC    AL1(FSL2+3*L'FSL2+5-FSLOUT),CL1'<'      D\n         DC    AL1(FSL2+3*L'FSL2+5-FSLOUT),CL1'>'      E\n         DC    AL1(FSL2+3*L'FSL2+10-FSLOUT),CL1'<'     F\n         EJECT\n***********************************************************************\n*        TABLES, ...                                                  *\n***********************************************************************\n         SPACE 1\nTBELL    EQU   0+L'LBLF+L'DATA\n         SPACE 1\n         DS    0D\nTABLE    DC    (NASSTE)XL(TBELL)'0'     ASSIGNED LABELS\nTABLEND  EQU   *-L'TABLE\n         DC    XL2'0'\n         SPACE 1\n         DS    0D\nFIXTB    DC    (NFIXTE)XL(TBELL)'0'     PREDEFINED LABELS\nFIXTBE   EQU   *-L'FIXTB\n         DC    XL2'0'\n         SPACE 2\nASTBL    EQU   0+L'ASIDN+L'ASNME\n         DS    0D\nASTB     DS    (NASNTE)XL(ASTBL)   AS-ID TABLE AREA SPACE\nASTBE    EQU   *-L'ASTB\n         SPACE 2\n         DS    0D\nHXDATA   DS    0XL16               MOVED DATA AREA\nBLDATA   DS    XL256               MOVED BLOCK DATA AREA (FULL SCREEN)\nPVBUF    DS    XL(L'HXDATA)        PREVIOUS LAST 16 BYTES OF 4K PAGE\nFNBUF    DS    (4*KB)X             4K PAGE AREA SPACE\nSTKWAS   DS    (NTKWAS*TKWAL)X     TANKS USER-AREAS POOL\n         SPACE 2\nVCOREEND EQU   *                   PROGRAM SPACE END CONTROL\n         EJECT\n***********************************************************************\n*        WORK AREAS DESCRIPTIONS.                                     *\n***********************************************************************\n         SPACE 1\nCONSLOUT DSECT ,              DATA LIST LINE\n         DS    CL1\nCONSL1   DS    CL8                 ADDRESS\n         DS    CL1\nCONSL2   DS    CL1                 :\n         DS    CL1\nCONSL3   DS    CL8                 DATA (HEX)\n         DS    CL1\nCONSL4   DS    CL8                 DATA (HEX)\n         DS    CL1\nCONSL5   DS    CL8                 DATA (HEX)\n         DS    CL1\nCONSL6   DS    CL8                 DATA (HEX)\n         DS    CL1\nCONSL7   DS    CL1                 *\nCONSL8   DS    CL16                DATA (CHAR)\nCONSL9   DS    CL1                 *\n         DS    CL1\nCONSLA   DS    CL5                 ADVICE\nCONSLL   EQU   *-CONSLOUT          MAX. LENGTH = L'MSGTXT\n         SPACE 1\nFSLOUT   DSECT ,              DATA LIST FULL SCREEN LINE\nFSL1     DS    CL8                 ADDRESS\n         DS    CL2\nFSL2     DS    4CL11               DATA (HEX)\n         DS    CL1\nFSL3     DS    CL1                 |\nFSL4     DS    CL16                DATA (CHAR)\nFSL5     DS    CL1                 |\n         DS    CL1\nFSL6     DS    CL5                 ADVICE\nFSLL     EQU   *-FSLOUT            MAX. LENGTH = L'MSGSVT\n         SPACE 1\nCNSLOUT  DSECT ,              LABELS LIST LINE\n         DS    CL3\nCNSLLB   DS    CL8                 LABEL\n         DS    CL1\nCNSLLS   DS    CL1                 :\n         DS    CL1\nCNSLAD   DS    CL8                 ADDRESS\nCNSLBL   EQU   *-CNSLOUT           STAY 3 TIMES IN L'MSGTXT\n         SPACE 1\nCNSASOUT DSECT ,              AS-ID'S LIST LINE\n         DS    CL3\nCNSASID  DS    CL4                 AS-ID NUMBER (HEX)\n         DS    CL1\nCNSASSP  DS    CL1                 :\n         DS    CL1\nCNSASNM  DS    CL8                 AS-ID NAME\nCNSASL   EQU   *-CNSASOUT          STAY 4 TIMES IN L'MSGTXT\n         SPACE 1\nCNSDST   DSECT ,              DSECT'S LIST LINE\nCNSDSCT  DS    CL8                 DSECT NAME\n         DS    CL2\nCNSDSF1  DS    CL8                 FIELD NAME\n         DS    CL1\nCNSDSS1  DS    CL1                 :\n         DS    CL1\nCNSDSD1  DS    CL4                 FIELD DISPLACEMENT\n         DS    CL1\nCNSDSL1  DS    CL4                 FIELD LENGTH\n         DS    CL1\nCNSDSS2  DS    CL1                 -\n         DS    CL1\nCNSDSF2  DS    CL8                 FIELD NAME\n         DS    CL1\nCNSDSS3  DS    CL1                 :\n         DS    CL1\nCNSDSD2  DS    CL4                 FIELD DISPLACEMENT\n         DS    CL1\nCNSDSL2  DS    CL4                 FIELD LENGTH\n         DS    CL1\nCNSDSTL  EQU   *-CNSDST            MAX. LENGTH = L'MSGTXT\n         ORG   CNSDSF2\nCNSDSF3  DS    CL8                 FLAG NAME\n         DS    CL1\nCNSDSS4  DS    CL1                 :\n         DS    CL1\nCNSDSV1  DS    CL4                 FLAG VALUE\n         DS    CL1\nCNSDSS5  DS    CL1                 -\n         DS    CL1\nCNSDSF4  DS    CL8                 FLAG NAME\n         DS    CL1\nCNSDSS6  DS    CL1                 :\n         DS    CL1\nCNSDSV2  DS    CL4                 FLAG VALUE\n         DS    CL1\nCNSDSTF  EQU   *-CNSDST            MAX. LENGTH = L'MSGTXT\n         EJECT\nHELPVP   DSECT ,              VECTOR OF POINTERS TO HELP PANELS DATA\nHLDF     DS    3A                  H PANEL\nHLLS     DS    3A                  H L PANEL\nHLMS     DS    3A                  H M PANEL\nHLXH     DS    3A                  X H PANEL\nHLAUTHF  DS    3A                  1ST RESERVED LINE(S) ADDRESSES\nHLAUTHM  DS    3A                  2ND RESERVED LINE(S) ADDRESSES\nHLRESL   EQU   81                  LENGTH OF RESERVED LINES TEXT\n         SPACE 1\nTKWA     DSECT ,              TANK USER-AREA\nTKWPT    DS    F                   TEXT POINTER\nTKWDL    DS    F                   LENGTH OF TEXT STORED IN AREA\nTKWTX    DS    XL256               TEXT AREA\nTKWAL    EQU   *-TKWA              TANK USER-AREA LENGTH\n         SPACE 2\n        PRINT  NOGEN\n        IHAPSA DSECT=YES,LIST=YES\n        CVT    DSECT=YES,LIST=YES\n        IHAASCB DSECT=YES,LIST=YES\n        IHAASVT\n        IHAASTE DSECT=YES\n        IHAEPIE\n        IHAECB\n        DCBD   DSORG=PS\n        IEFZB4D0\n        IEFZB4D2\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "VSM$": {"ttr": 18950, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x942\\x7f\\x00\\x942\\x7f\\x14$\\x00\\x14\\x00\\x14\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-11-23T00:00:00", "modifydate": "1994-11-23T14:24:00", "lines": 20, "newlines": 20, "modlines": 0, "user": "SYSPAJA"}, "text": "//VSM      JOB (........),'INSTALL - V S M -',\n//             MSGLEVEL=(1,1),MSGCLASS=A,REGION=1M,TIME=2\n/*JOBPARM L=12\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//* PRE-REQUISITE MODULES INSTALLATION :                              *\n//*                AUTHCTL                                            *\n//* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *\n//AS0     EXEC PAJ1AS3,MBR=VSM00000\n//AS1     EXEC PAJ1AS3,MBR=VSM00100\n//AS2     EXEC PAJ1AS3,MBR=VSM00200\n//AS3     EXEC PAJ1AS3,MBR=VSM00300\n//AS7     EXEC PAJ1AS3,MBR=VSM77000\n//AS8     EXEC PAJ1AS3,MBR=VSM88000\n//AS9     EXEC PAJ1AS3,MBR=VSM99000\n//ASH     EXEC PAJ1AS3,MBR=VSMHELP\n//LNK     EXEC PAJILKC,OPT=',REUS'\n//SYSIN     DD *\n  ENTRY   VSM00000\n  NAME    VSM(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "VSM@": {"ttr": 18952, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x91\\x07\\x8f\\x00\\x91\\x07\\x8f\\x15B\\x00+\\x00+\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-03-19T00:00:00", "modifydate": "1991-03-19T15:42:00", "lines": 43, "newlines": 43, "modlines": 0, "user": "SYSPAJA"}, "text": "1   19/03/91\n                                                      VSM       1/1.\n\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * *       VIRTUAL STORAGE MONITOR       * * * * * * * *\n  * * * * * * * *                                     * * * * * * * *\n  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\n  CBT origin : Extracted from CBT tape 84 JUN, file 347.\n  ------------\n\n  Purpose :    The Virtual Storage Monitor is a command processor\n  ---------    designed to assist in identifying virtual storage\n               problems, particularly those associated with CSA\n               utilization. Mainly it is composed of three functions,\n               as below :\n\n                1. VIRTUAL STORAGE MAP : it will show the high and low\n                   virtual address of SQA, PLPA , CSA, the private area\n                   and the NUCLEUS. It will also show the size of each\n                   area in MEG and in K.\n\n                2. CSA/SQA SUBPOOL UTILIZATION : it will show the\n                   amount of free or unalloacted space in each subpool,\n                   the largest contiguous free space and the percentage\n                   free or unused.\n\n                3. CSA SUBPOOL UTILIZATION by protect key.\n\n  Authority :  only system group USER-id's are authorized to issue\n  -----------  this command.\n\n  BATCH run :  The Virtual Storage Monitor may run in BATCH like a\n  -----------  program called as below :\n               //VSMXB  EXEC  PGM=VSM,PARM=...\n                                 or : PARM='$/...'\n               where $ is the sysout class (default is A), and\n                     ... are the desired VSM funstions.\n               I.e. - PARM=12R3R\n               If you want, you may also use a pre-allocated JCL DD\n               for the hardcopy output, as i.e. below :\n               //VSMHCOPY  DD SYSOUT=*\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "VSMDOC": {"ttr": 18954, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x88\\t\\x8f\\x00\\x88\\t\\x8f\\x10\\x01\\x00r\\x00r\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-04-07T00:00:00", "modifydate": "1988-04-07T10:01:00", "lines": 114, "newlines": 114, "modlines": 0, "user": "SYSPAJA"}, "text": "                  *********************************\n                  ***  VIRTUAL STORAGE MONITOR  ***\n                  *********************************\n\n     THE VIRTUAL STORAGE MONITOR IS DESIGNED TO ASSIST IS IDENTIFYING\n VIRTUAL STORAGE PROBLEMS, PARTICULARLY THOSE ASSOCIATED WITH CSA\n UTILIZATION. VSM IS A COMMAND PROCESSOR. IT HAS BEEN TESTED ON\n MVS/SP1.1.1 AND ON SP1.3. VSM IS DESIGNED TO RUN WITH ACF/VTAM BUT\n SHOULD WORK WITH TCAM IF A FEW CHANGES ARE MADE.\n\n INSTALLATION :\n --------------\n\n DSECTS :\n\n     VSM USES A NUMBER OF DSECTS FOR IBM CONTROL BLOCKS. WE CODED\n THEM OURSELVES BECAUSE WE DO NOT HAVE SYS1.PVTMACS. IF YOU DO HAVE\n SYS1.PVTMACS YOU CAN CHANGE OUR CODE TO PICKUP THE IBM SUPPLIED\n DSECTS. IF YOU DO NOT HAVE SYS1.PVTMACS AND DO NOT WANT TO USE OUR\n DSECTS TAKE THEM OUT AND CODE THE OFFSETS (TEDIOUS).\n     THE EASIEST APPROACH IS TO PLACE THIS LIBRARY FIRST IN THE SYSLIB\n CONCATENATION AND USE OUR DSECTS.\n\n KEY ZERO :\n\n     VSM00200 AND VSM00300 NEED TO BE IN KEY ZERO IN ORDER TO READ\n THE FETCH PROTECTED SUBPOOLS IN CSA. WE ACCOMPLISH THIS BY USING AN\n INHOUSE MACRO (PKEY) TO INVOKE AN IN-HOUSE SVC WHICH FLIPS BIT 15 IN\n THE PSW ON AND OFF. DO A FIND ON PKEY IN THE TWO MODULES MENTIONED AND\n EITHER INSERT YOUR OWN SVC OR REPLACE PKEY WITH THE MODESET MACRO AND\n THEN UPDATE THE APPROPRIATE TABLES (IKJEFTE2 AND/OR IKJEFTE8). PKEY\n APPEARS TWICE IN EACH MODULE; ONCE TO GET INTO KEY ZERO AND ONCE TO\n RETURN TO PROBLEM STATE.\n\n VTAM/TCAM :\n\n     WE RUN ACF/VTAM RELEASE 3. IF YOU DO ALSO SO SHOULD NOT HAVE\n PROBLEMS. IF YOU RUN TCAM YOU MAY HAVE TO CHANGE THE DEVICE ORDERS.\n FURTHERMORE YOU MAY HAVE TO REMOVE THE STFSMODE MACROS FROM MODULES\n VSM00000 AND VSM99000.\n\n TAILORING :\n\n     THE PRIMARY MENU IS CREATED IN MODULE VSM. TO CHANGE THE HEADER\n FROM HALLMARK CARDS DO A FIND ON HALLMARK IN MODULE VSM00000. CHANGE\n TO YOUR OWN HEADER AND CHANGE THE COLUMN INDICATOR IN THE LINE ABOVE\n TO CENTER YOUR HEADER.\n     MODULE VSM00300 SHOWS CSA UTILIZATION BY PROTECT KEY. A NAME IS\n ASSIGNED TO THOSE PROTECT KEYS IN USE HERE. KEYS 2-4 AND 7 ARE NOT\n USED HERE AND HENCE THE NAME IS BLANK. TO INSERT THE NAME YOU WANT\n (EX : VSPC OR IMS) EDIT MODULE VSM00300 AND FIND #0XNAME WHERE X IS\n THE PROTECT KEY THEN EDIT THE 10 BYTE FIELD.\n\n ASSEMBLY :\n\n     THE LIBRARY CREATED FROM THE DISTRIBUTION TAPE SHOULD BE IN THE\n SYSLIB CONCATENATION TO PICKUP SOME IN-HOUSE MACROS THAT WE USE.\n\n LINK :\n\n     VSM SHOULD BE LINKED REUS. IF YOU USE MODESET VSM MUST BE LINKED\n AC(1). IF YOU USE AN AUTHORIZATION SVC THE NEED FOR AC(1) WILL DEPEND\n ON WHETHER YOUR SVC CHECKS FOR IT OR NOT.\n\n     ASSEMBLE AND LINK VSM00100,VSM00200,VSM00300,VSM99000 AND VSMHELP.\n ASSEMBLE VSM00000 AND INCLUDE THE ABOVE MODULES WHEN YOU DO THE LINK.\n WE THEN COPY VSM00000 INTO CMDLIB AND RENAME IT TO VSM.\n\n DISCLAIMER :\n ------------\n\n     THE PROGRAMS IN THIS FILE ARE BEING CONTRIBUTED TO THE CBT MODS\n TAPE TO HELP OTHER USERS OF IBM'S MVS OPERATING SYSTEM. THEY MAY BE\n FREELY DISTRIBUTED TO OTHER ORGANIZATIONS OR INDIVIDUALS PROVIDED THAT\n THEY ARE NOT DISTRIBUTED FOR PROFIT AND THAT THIS DISCLAIMER IS ALSO\n DISTRIBUTED.\n\n     THE PROGRAMS CONTAINED IN THIS FILE WERE WRITTEN AT HALLMARK CARDS\n ENFIELD, CT. TO THE BEST OF OUR KNOWLEDGE THEY FUNCTION AS INTENDED AND\n AS DOCUMENTED WITHOUT CAUSING SYSTEM OR INTEGRITY PROBLEMS. HOWEVER,\n THEY ARE NOT COVERED BY ANY WARRANTY, EITHER EXPRESSED OR IMPLIED, AS\n TO THE RELIABILITY OR FITNESS FOR USE AT ANY INSTALLATION OTHER THAN\n HALLMARK CARDS. NO COMMITMENT IS MADE THAT WE WILL MAINTAIN THESE\n PROGRAMS OR THAT THEY WILL FUNCTION WITH LATER RELEASES OF MVS OR VTAM.\n\n CBT MODIFICATIONS :\n -------------------\n\n WE USE ACF/TCAM AT CBT AND IT RUNS FINE.\n WE AT CBT MADE THE FOLLOWING CHANGES TO THE CODE SO IT WOULD RUN\n ALL OUR CHANGES ARE MARKED 'CBT-AXC' :\n  - IN VSM00000 WE USED OUR HEADER RATHER THAN HALLMARK'S\n  - IN VSM00200 WE USED OUR SVC INSTEAD OF PKEY\n  - IN VSM00300 WE USED OUR SVC INSTEAD OF PKEY\n\n EURATOM MODIFICATIONS :\n -----------------------\n\n ALL OUR CHANGES ARE MARKED '-EU-' :\n  - IN VSM00000 WE USED S. REL. RATHER THAN 'CBT-AXC' HEADER AND WE\n                ADDED SYSTEM SUPPORT PERSONNEL ONLY CONTROL\n  - IN VSM00200 WE USED OUR SVC INSTEAD OF CBT SVC\n  - IN VSM00300 WE USED OUR SVC INSTEAD OF CBT SVC\n\n AT 12 NOV 1986, VSM NOW ADAPTED FOR MVS/XA :\n  - IN VSM001XA, VSM002XA AND VSM003XA ADDED\n  - VSM88000 : DEBUGING AID MODULE ADDED\n  - VSM77000 : HARDCOPY MODULE ADDED\n\n AT 04 FEB 1987, VSM ADAPTED TO A BATCH RUN\n\n AT 07 APR 1988, VSM FOR MVS/XA ONLY :\n  - MODULES VSM001XA, VSM002XA AND VSM003XA NORMALLY RENAMED VSM00100,\n                VSM00200 AND VSM00300\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "VSMHELP": {"ttr": 18957, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x882?\\x00\\x882?\\x144\\x00\\xa1\\x00\\xa1\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-11-18T00:00:00", "modifydate": "1988-11-18T14:34:00", "lines": 161, "newlines": 161, "modlines": 0, "user": "SYSPAJA"}, "text": "VSMH     TITLE 'VSMHELP - VIRTUAL STORAGE MONITOR HELP SCREEN.'\n         PRINT OFF                                                 -EU-\n         COPY  VSMMAC                                              -EU-\n         PRINT ON                                                  -EU-\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*    MODULE :           VSMHELP                                       *\n*                       VERSION : 1.1                                 *\n*                       DATE : 9/1/82                                 *\n*                       NAME : VIRTUAL STORAGE MONITOR HELP SCREEN    *\n*                       ATTRIBUTES : REUS                             *\n*                                                                     *\n*    AUTHOR :           R.P. SHANNON                                  *\n*                       HALLMARK CARDS                                *\n*                       ENFIELD DISTRIBUTION CENTER                   *\n*                                                                     *\n*    FUNCTION :         PROVIDE HELP FOR VSM COMMANDS                 *\n*                                                                     *\n*    REGS AT ENTRY :    R1   - INTER MODULE LINKAGE                   *\n*                       R14  - RETURN ADDRESS                         *\n*                       R15  - EPA                                    *\n*                                                                     *\n*    REGS USAGE :       R0   - WORK REGISTER                          *\n*                       R1   - POINTER TO INTER MODULE LINKAGE        *\n*                       R10  - LINKAGE AREA POINTER                   *\n*                       R11  - BASE REGISTER                          *\n*                       R12  - 2ND BASE REGISTER (RESERVED)           *\n*                       R13  - SAVE AREA POINTER                      *\n*                                                                     *\n*    REGS AT EXIT :     R14  - RETURN ADDRESS                         *\n*                                                                     *\n*    LABELS :           SOME OF THE FIELD USAGE IN THIS MODULE CAN    *\n*                       BE DETERMINED BY THE FIRST CHARACTER OF THE   *\n*                       FIELD. THE KEYS ARE :                         *\n*                            @ - FIELD IS IN INTER MODULE LINKAGE     *\n*                                AREA                                 *\n*                            # - FIELD IS PART OF THE OUTPUT SCREEN   *\n*                            $ - DSECT                                *\n*                                                                     *\n*    MODS : VERSION 1.0  - BASE                                       *\n*           VERSION 1.1  -  REMOVED AUTOMATIC UPSHIFT OF KEYBOARD     *\n*                           FOR TERMINALS WITH NUM OPTION             *\n*                                                                     *\n***********************************************************************\n         EJECT\nVSMHELP  START 0\n         SPACE 1\n        $DEFREG ,                                                  -EU-\n***********************************************************************\n*        STANDARD OS LINKAGE                                          *\n***********************************************************************\n         SPACE 1\n        $XENT  BASE=R11            SAVE CALLER'S REGS              -EU-\n         EJECT\n***********************************************************************\n*        GET LINKAGE ADDRESSABILITY                                   *\n***********************************************************************\n         SPACE 1\n         LR    R10,R1              LOAD INTER MOD LNKG ADDR R10\n         USING $LNKSECT,R10        DSECT ADDRESSABILITY\nP000200  MVC   #MSG1,=CL26' '      CLEAR\n         MVC   #MSG2,=CL26' '        MESSAGES\n         CLI   @BADCMND,C'1'       WAS BAD COMMAND ENTERED ?\n         BE    P000210             BRANCH IF YES                   -EU-\n         CLI   @BADCMND,C'2'       WAS HARDCOPY HAS FAILED ?       -EU-\n         BNE   P000400             BRANCH IF NO\n         MVC   #MSG1,MSG1B                                         -EU-\n         B     P000300             BRANCH IF NO                    -EU-\nP000210  MVC   #MSG1,MSG1A                                         -EU-\nP000300  MVC   #MSG2,MSG2                                          -EU-\n         SPACE 1\n***********************************************************************\n*        OUTPUT THE SCREEN                                            *\n***********************************************************************\n         SPACE 1\nP000400  MVI   @BADCMND,C' '       MOVE BLANK TO BAD COMMAND IND\n         MVI   @RSPONSE,C' '       MOVE BLANK TO RESPONSE\n         LA    R0,#SCREEN          LOAD SCREEN ADDRESS\n         ST    R0,@PUTAREA         STORE IN LINKAGE AREA\n         LA    R0,#SCRNLEN         LOAD SCREEN LENGTH\n         ST    R0,@PUTLEN          STORE IN LINKAGE AREA\n         LR    R1,R10              POINT R1 TO LINKAGE AREA\n         L     R15,@IOMOD          LOAD ADDRESS OF TERMINAL I/O MOD\n         BASR  R14,R15             GO DO TERMINAL IO\n         CLI   @RSPONSE,C'R'       REFRESH SCREEN ?\n         BE    P000200             BRANCH IF YES\n        $XRET  CC=0                B O O G I E                     -EU-\n         EJECT\nMSG1A    DC    CL26'  COMMAND NOT RECOGNIZED  '\nMSG1B    DC    CL26' HARDCOPY OPEN HAS FAILED '\nMSG2     DC    CL26'PLEASE ENTER VALID COMMAND'\n         SPACE 1\n#SCREEN  DS    0F\n         $FS   WCC=(KBR,RMDT),MF=L                                 -EU-\n         $FS   SBA=(1,1),RA=(1,1,00),MF=L                          -EU-\n         $FS   SBA=(1,1),SF=(PROT,INT),MF=L                        -EU-\n         $FS   TEXT='SELECT OPTION =>',MF=L                        -EU-\n         $FS   SF=NORMAL,TEXT=' ',MF=L                             -EU-\n         $FS   SF=(PROT),MF=L                                      -EU-\n         $FS   SBA=(3,35),SF=(PROT,INT),MF=L                       -EU-\n         $FS   TEXT='HELP MENU',MF=L                               -EU-\n         $FS   SF=(PROT),MF=L                                      -EU-\n         $FS   SBA=(5,19),TEXT='THE VIRTUAL STORAGE ',MF=L         -EU-\n         $FS   TEXT='MONITOR WAS DESIGNED TO',MF=L                 -EU-\n         $FS   SBA=(6,19),TEXT='ASSIST IN SOLVING ',MF=L           -EU-\n         $FS   TEXT='VIRTUAL STORAGE PROBLEMS.',MF=L               -EU-\n         $FS   SBA=(8,19),TEXT='THE FOLLOWING COMMANDS ',MF=L      -EU-\n         $FS   TEXT='MAY BE ENTERED FROM',MF=L                     -EU-\n         $FS   SBA=(9,19),TEXT='ANY SCREEN :',MF=L                 -EU-\n         $FS   SBA=(11,19),SF=(PROT,INT),TEXT='PFK-10/22',MF=L     -EU-\n         $FS   SF=(PROT),TEXT='OR',MF=L                            -EU-\n         $FS   SF=(PROT,INT),TEXT='1',MF=L                         -EU-\n         $FS   SF=(PROT),TEXT='=> VIRTUAL STORAGE MAPPER',MF=L     -EU-\n         $FS   SBA=(12,19),SF=(PROT,INT),TEXT='PFK-11/23',MF=L     -EU-\n         $FS   SF=(PROT),TEXT='OR',MF=L                            -EU-\n         $FS   SF=(PROT,INT),TEXT='2',MF=L                         -EU-\n         $FS   SF=(PROT),TEXT='=> SUBPOOL MONITOR',MF=L            -EU-\n         $FS   SBA=(13,19),SF=(PROT,INT),TEXT='PFK-12/24',MF=L     -EU-\n         $FS   SF=(PROT),TEXT='OR',MF=L                            -EU-\n         $FS   SF=(PROT,INT),TEXT='3',MF=L                         -EU-\n         $FS   SF=(PROT),TEXT='=> PROTECT KEY MONITOR',MF=L        -EU-\n         $FS   SBA=(14,20),SF=(PROT,INT),TEXT='PFK-1/13',MF=L      -EU-\n         $FS   SF=(PROT),TEXT='OR',MF=L                            -EU-\n         $FS   SF=(PROT,INT),TEXT='H',MF=L                         -EU-\n         $FS   SF=(PROT),TEXT='=> HELP SCREEN',MF=L                -EU-\n         $FS   SBA=(15,20),SF=(PROT,INT),TEXT='PFK-2/14',MF=L      -EU-\n         $FS   SF=(PROT),TEXT='OR',MF=L                            -EU-\n         $FS   SF=(PROT,INT),TEXT='M',MF=L                         -EU-\n         $FS   SF=(PROT),TEXT='=> PRIMARY MENU',MF=L               -EU-\n         $FS   SBA=(16,23),SF=(PROT,INT),TEXT='ENTER',MF=L         -EU-\n         $FS   SF=(PROT),TEXT='OR',MF=L                            -EU-\n         $FS   SF=(PROT,INT),TEXT='R',MF=L                         -EU-\n         $FS   SF=(PROT),TEXT='=> REFRESH THE SCREEN',MF=L         -EU-\n         $FS   SBA=(17,20),SF=(PROT,INT),TEXT='PFK-7/19',MF=L      -EU-\n         $FS   SF=(PROT),TEXT='OR',MF=L                            -EU-\n         $FS   SF=(PROT,INT),TEXT='S',MF=L                         -EU-\n         $FS   SF=(PROT),MF=L                                      -EU-\n         $FS   TEXT='=> START HARDCOPY OF 1, 2 AND 3',MF=L         -EU-\n         $FS   SBA=(18,20),SF=(PROT,INT),TEXT='PFK-8/20',MF=L      -EU-\n         $FS   SF=(PROT),TEXT='OR',MF=L                            -EU-\n         $FS   SF=(PROT,INT),TEXT='P',MF=L                         -EU-\n         $FS   SF=(PROT),TEXT='=> STOP HARDCOPY',MF=L              -EU-\n         $FS   SBA=(19,20),SF=(PROT,INT),TEXT='PFK-3/15',MF=L      -EU-\n         $FS   SF=(PROT),TEXT='OR',MF=L                            -EU-\n         $FS   SF=(PROT,INT),TEXT='Z',MF=L                         -EU-\n         $FS   SF=(PROT),TEXT='=> EXIT VSM',MF=L                   -EU-\n         $FS   SBA=(21,27),SF=(PROT,INT),MF=L                      -EU-\n#MSG1    $FS   TEXT=(' ',26),MF=L                                  -EU-\n         $FS   SF=(PROT),MF=L                                      -EU-\n         $FS   SBA=(22,27),SF=(PROT,INT),MF=L                      -EU-\n#MSG2    $FS   TEXT=(' ',26),MF=L                                  -EU-\n         $FS   SF=(PROT),MF=L                                      -EU-\n         $FS   SBA=(1,1),SF=(PT,IC),MF=L                           -EU-\n#SCRNLEN EQU   *-#SCREEN\n         SPACE 2\n         LTORG\n         EJECT\n         $LNKSECT\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "VSMMAC": {"ttr": 19202, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x882?\\x00\\x882?\\x14(\\x00\\x85\\x00\\x85\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-11-18T00:00:00", "modifydate": "1988-11-18T14:28:00", "lines": 133, "newlines": 133, "modlines": 0, "user": "SYSPAJA"}, "text": "         MACRO --- $ABDF --- ALLOCATED BLOCK DESCRIPTOR FORMAT     -EU-\n         $AFUF ,                                                   -EU-\n         SPACE 1                                                   -EU-\n*        FORMAT OF ALLOCATED/FREE/UNALLOCATED SPACE DESCRIPTOR.    -EU-\n         SPACE 1                                                   -EU-\nAFUF     DSECT .                                                   -EU-\nAFUFVA   DS    A .           VIRTUAL ADDRESS OF THE SPACE          -EU-\nAFUFLG   DS    F .           LENGTH OF THE SPACE                   -EU-\nLAFUF    EQU   *-AFUF .      LENGTH OF DSECT                       -EU-\n         MEND  ,                                                   -EU-\n         MACRO --- $GDA --- GLOBAL DATA AREA DSECT\n         $GDA  &G=YES                                              -EU-\n         AIF   ('&G' EQ 'YES').GEN                                 -EU-\n         PRINT NOGEN                                               -EU-\n.GEN     IHAGDA  ,                                                 -EU-\n         AIF   ('&G' EQ 'YES').EXT                                 -EU-\n         PRINT GEN                                                 -EU-\n.EXT     MEND  ,                                                   -EU-\n         MACRO --- $HCPY --- VSM CALL HARDCOPY SCREEN              -EU-\n&NAME    $HCPY &HSA=                                               -EU-\n         AIF   ('&HSA'(1,1) EQ '(').REG                            -EU-\n&NAME    LA    R0,&HSA       GET HARDCOPY SCREEN ADDRESS           -EU-\n         AGO   .CNT                                                -EU-\n.REG     AIF   ('&HSA(1)' EQ '0').SET                              -EU-\n         AIF   ('&HSA(1)' NE 'R0').SRG                             -EU-\n.SET     ANOP  ,                                                   -EU-\n&NAME    ST    R0,@HCPY      SET HARDCOPY SCREEN ADDRESS           -EU-\n         AGO   .CLL                                                -EU-\n.SRG     ANOP  ,                                                   -EU-\n&NAME    LR    R0,&HSA(1)    GET HARDCOPY SCREEN ADDRESS           -EU-\n.CNT     ST    R0,@HCPY      SET IT                                -EU-\n.CLL     XR    R0,R0         HARD COPY REQUEST                     -EU-\n         LR    R1,R10        POINT TO LINKAGE                      -EU-\n         L     R15,@HCMOD    EXECECUTE                             -EU-\n         BASR  R14,R15         HARDCOPY ROUTINE                    -EU-\n         MEND  ,                                                   -EU-\n         MACRO --- $LNKSECT--- VSM LINKAGE SECTION/DSECT\n&NAME    $LNKSECT &DS=YES,&SZ=4                                    -EU-\n         SPACE 1\n         AIF   ('&DS' NE 'YES').NODS                               -EU-\n*        VSM LINKAGE SECTION DSECT.\n         SPACE 1\n         AIF   ('&NAME' EQ '').DFLT                                -EU-\n&NAME    DSECT .                                                   -EU-\n         AGO   .CONT                                               -EU-\n.DFLT    ANOP                                                      -EU-\n$LNKSECT DSECT .\n.CONT    ANOP                                                      -EU-\n@GDA     DS    F .           ADDRESS OF GLOBAL DATA AREA\n@PUTAREA DS    F .           ADDRESS OF OUTPUT SCREEN\n@PUTLEN  DS    F .           LENGTH OF OUTPUT SCREEN\n@IOMOD   DS    F .           ADDRESS OF I/O MODULE\n@GETAREA EQU   * .\n@PFKCODE DS    XL6 .         CONTROL CHARACTERS                    -EU-\n@RSPONSE DS    CL1 .         TERMINAL COMMAND\n@BADCMND DS    CL1 .         BAD COMMAND INDICATOR\n@GETLEN  EQU   *-@GETAREA .  LENGTH OF INPUT AREA\n@HCMOD   DS    F .           ADDRESS OF HARDCOPY MODULE            -EU-\n@HCPY    DS    F .           HARDCOPY SCREEN ADDRESS               -EU-\n@SNAP    DS    F .           SNAP ROUTINE ADDRESS                  -EU-\n@TIOT    DS    F .           TIOT ADDRESS                          -EU-\n@SNPLST  DS    2F .          SNAP START-END AREA ADDRESSES         -EU-\n@WAADD   DS    F .           WORK AREA ADDRESS                     -EU-\n@WASIZ   DS    F .           WORK AREA SIZE                        -EU-\n@MSGW   WTO    '----+----1----+----2----+----3----+----4----+----5',   1\n               ROUTCDE=11,DESC=7,MF=L                              -EU-\n@MSG     EQU   @MSGW+4,50    MESSAGE AREA                          -EU-\n@PPTR    DS    F .           PARM. FIELD POINTER (DISPLACEMENT)    -EU-\n@HCLASS  DS    CL1 .         HARDCOPY BATCH SYSOUT CLASS           -EU-\n@SBXQ    DS    CL1 .         START OF BATCH EXECUTION              -EU-\n@PARM    DS    CL20 .        BATCH RUN - PARM. FIELD               -EU-\n         DS    CL2 .         END OF BATCH EXECUTION                -EU-\n@SWITCH  DS    XL1 .         GENERAL SWITCHES                      -EU-\n@SNPFNA  EQU   X'20' .            SNAP FUNCTION NOT ACTIVE         -EU-\n@SNPOPN  EQU   X'10' .            SNAP DATA-SET IS OPENED          -EU-\n@BATCH   EQU   X'08' .            BATCH CALL RUNNING               -EU-\n@HFAIL   EQU   X'02' .            HARDCOPY OPEN HAS FAILED         -EU-\n@HCOPY   EQU   X'01' .            HARDCOPY IS OPENED               -EU-\n         MEXIT                                                     -EU-\n.NODS    ANOP                                                      -EU-\n*        VSM LINKAGE SECTION.                                      -EU-\n         SPACE 1                                                   -EU-\n&NAME    DC    F'0' .        ADDRESS OF GLOBAL DATA AREA           -EU-\n         DC    F'0' .        ADDRESS OF OUTPUT SCREEN              -EU-\n         DC    F'0' .        LENGTH OF OUTPUT SCREEN               -EU-\n         DC    F'0' .        ADDRESS OF I/O MODULE                 -EU-\n         DC    XL6'0' .      CONTROL CHARACTERS                    -EU-\n         DC    CL1' ' .      TERMINAL COMMAND                      -EU-\n         DC    CL1' ' .      BAD COMMAND INDICATOR                 -EU-\n         DC    F'0' .        ADDRESS OF HARDCOPY MODULE            -EU-\n         DC    F'0' .        HARDCOPY SCREEN ADDRESS               -EU-\n         DC    F'0' .        SNAP ROUTINE ADDRESS                  -EU-\n         DC    F'0' .        TIOT ADDRESS                          -EU-\n         DC    2F'0' .       SNAP START-END AREA ADDRESSES         -EU-\n         DC    F'0' .        WORK AREA ADDRESS                     -EU-\n         DC    A(&SZ*1024) . WORK AREA SIZE                        -EU-\n        WTO    '----+----1----+----2----+----3----+----4----+----5',   1\n               ROUTCDE=11,DESC=7,MF=L                              -EU-\n         DC    F'0' .        PARM. FIELD POINTER (DISPLACEMENT)    -EU-\n         DC    CL1'A' .      HARDCOPY BATCH SYSOUT CLASS           -EU-\n         DC    CL1'S' .      START OF BATCH EXECUTION              -EU-\n         DC    XL20'0' .     BATCH RUN - PARM. FIELD               -EU-\n         DC    XL2'0' .      END OF BATCH EXECUTION                -EU-\n         DC    XL1'0' .      GENERAL SWITCHES                      -EU-\n         MEND\n         MACRO --- $SDF --- SUBPOOL DESCRIPTOR FORMAT              -EU-\n         $SDF  ,                                                   -EU-\n         SPACE 1                                                   -EU-\n*        FORMAT OF SUBPOOL DESCRIPTOR.                             -EU-\n         SPACE 1                                                   -EU-\nSDF      DSECT .                                                   -EU-\nSDFIS    DS    XL1 .         X'00' TO IDENTIFY A SUBPOOL DESCRIPTOR-EU-\nSDFLG    DS    XL1 .         LENGTH OF SUBPOOL DESCRIPTOR          -EU-\nSDFID    DS    XL1 .         SUBPOOL ID                            -EU-\nSDFKF    DS    XL1 .         STORAGE KEY (BITS 0-3) AND FLAGS      -EU-\nSDFTCB   DS    A .           OWNING TCB (PVT) OR ZERO              -EU-\n         MEND  ,                                                   -EU-\n         MACRO --- $SNAP --- VSM CALL SNAP                         -EU-\n&NAME    $SNAP &ID=0                                               -EU-\n         AIF   ('&ID'(1,1) EQ '(').REG                             -EU-\n&NAME    LA    R0,&ID        SET SNAP-ID NUMBER                    -EU-\n         AGO   .CNT                                                -EU-\n.REG     AIF   ('&ID(1)' EQ '0').SET                               -EU-\n         AIF   ('&ID(1)' NE 'R0').SRG                              -EU-\n.SET     ANOP  ,                                                   -EU-\n&NAME    LR    R1,R10        POINT TO LINKAGE                      -EU-\n         AGO   .CLL                                                -EU-\n.SRG     ANOP  ,                                                   -EU-\n&NAME    LR    R0,&ID(1)     SET SNAP-ID NUMBER                    -EU-\n.CNT     LR    R1,R10        POINT TO LINKAGE                      -EU-\n.CLL     L     R15,@SNAP     EXECECUTE                             -EU-\n         BASR  R14,R15         SNAP ROUTINE                        -EU-\n         MEND  ,                                                   -EU-\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "VSM00000": {"ttr": 19205, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x91\\x07\\x8f\\x00\\x91\\x07\\x8f\\x15\\x18\\x01~\\x01~\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-03-19T00:00:00", "modifydate": "1991-03-19T15:18:00", "lines": 382, "newlines": 382, "modlines": 0, "user": "SYSPAJA"}, "text": "VSM0     TITLE 'VSM00000 - VIRTUAL STORAGE MONITOR CONTROL MODULE.'\n         PRINT OFF                                                 -EU-\n         COPY  VSMMAC                                              -EU-\n         PRINT ON                                                  -EU-\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*    MODULE :           VSM00000                                      *\n*                       VERSION : 1.2                                 *\n*                       DATE : 12 NOV 1986                            *\n*                       NAME : VIRTUAL STORAGE MONITOR CONTROL MODULE *\n*                       ATTRIBUTES : REUS                             *\n*                                                                     *\n*    AUTHOR :           R.P. SHANNON (VERSION 1.1 - 9/1/82)           *\n*                       HALLMARK CARDS                                *\n*                       ENFIELD DISTRIBUTION CENTER                   *\n*                                                                     *\n*    FUNCTION :         THIS IS THE CONTROL MODULE FOR THE VIRTUAL    *\n*                       STORAGE MONITOR. IT PRODUCES THE PRIMARY      *\n*                       MENU AND SERVICES REQUESTS BY BRANCHING TO    *\n*                       THE APPROPRIATE MODULES.                      *\n*                                                                     *\n*    REGS AT ENTRY :    R14  - RETURN ADDRESS                         *\n*                       R15  - EPA                                    *\n*                                                                     *\n*    REGS USAGE :       R0   - WORK REGISTER                          *\n*                       R1   - POINTER TO INTER MODULE LINKAGE        *\n*                       R2-R4 - WORK REGISTERS                        *\n*                       R9   - RETURN CODE                            *\n*                       R10  - LINKAGE AREA POINTER                   *\n*                       R11  - BASE REGISTER                          *\n*                       R12  - 2ND BASE REGISTER (RESERVED)           *\n*                       R13  - SAVE AREA POINTER                      *\n*                       R14  - LINKAGE REGISTER                       *\n*                       R15  - ADDRESS OF CALLED MODULES              *\n*                                                                     *\n*    REGS AT EXIT :     R14  - RETURN ADDRESS                         *\n*                       R15  - RETURN CODE                            *\n*                                                                     *\n*    LABELS :           SOME OF THE FIELD USAGE IN THIS MODULE CAN    *\n*                       BE DETERMINED BY THE FIRST CHARACTER OF THE   *\n*                       FIELD. THE KEYS ARE :                         *\n*                            @ - FIELD IS IN INTER-MODULE LINKAGE     *\n*                                AREA                                 *\n*                            # - FIELD IS PART OF THE OUTPUT SCREEN   *\n*                            $ - DSECT                                *\n*                                                                     *\n***********************************************************************\n         EJECT\n***********************************************************************\n*                                                                     *\n*    MODS : VERSION 1.0  - BASE                                       *\n*           VERSION 1.1  - REMOVED AUTOMATIC UPSHIFT OF KEYBOARD FOR  *\n*                          TERMINALS WITH NUM OPTION                  *\n*    NEW ADDS DONE BY :    MOINIL P.A. - COMPUTING CENTRE         -EU-*\n*                          J.R.C. - ISPRA ESTABLISHMENT           -EU-*\n*                          21020 ISPRA (VA), ITALY                -EU-*\n*           VERSION 1.2  - ADAPTED TO MVS/XA , HARDCOPY ADDED AND -EU-*\n*                          BATCH RUN ALLOWED                      -EU-*\n*           VERSION 1.3  - WHEN BATCH RUNNING, THE HARDCOPY MAY   -EU-*\n*                          BE PRE-ALLOCATED TO DDNAME 'VSMHCOPY'  -EU-*\n*                                                                     *\n***********************************************************************\n         SPACE 2\nVSM00000 START 0\n         SPACE 1                                                   -EU-\nVSM00000 AMODE 24                                                  -EU-\nVSM00000 RMODE 24                                                  -EU-\n         SPACE 1                                                   -EU-\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *  -EU-\n*        AUTHORITY LEVELS DEFINITIONS.                          *  -EU-\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *  -EU-\n         SPACE 1                                                   -EU-\nLV0      EQU   0         REJECT LEVEL.                             -EU-\n         SPACE 1                                                   -EU-\nVSM     $MDL@IX ,        MODULE INDEX.                             -EU-\n         EJECT ,                                                   -EU-\n        $DEFREG ,                                                  -EU-\n        $XENT  BASE=R11            SAVE CALLER'S REGS              -EU-\n         EJECT                                                     -EU-\n         LR    R2,R1                    SAVE ENTRY R1 POINTER      -EU-\n         L     R10,=A(LINKAGE)          POINT TO LINKAGE SECTION   -EU-\n         USING $LNKSECT,R10             LINKAGE DSECT ADDRESSABILITY\n         MVI   @MSG,C' '                CLEAR MESSAGE AREA         -EU-\n         MVC   @MSG+1(L'@MSG-1),@MSG                               -EU-\n         MVI   @SWITCH,0                RESET SWITCHES             -EU-\n         SPACE 1                                                   -EU-\n******************************************************************-EU-*\n*        CONTROL WHO CALL ME ? AND HOW ?                          -EU-*\n*        IF BATCH EXECUTION, PARM. FIELD MUST BE SUPPLIED         -EU-*\n*        AS : PARM=...  (VSM FUNCTIONS)                           -EU-*\n*        OR : PARM=C/...  (SYSOUT CLASS/VSM FUNCTIONS)            -EU-*\n*             I.E. - PARM=12R3R  (DEFAULT SYSOUT CLASS IS A)      -EU-*\n*                    PARM=X/1                                     -EU-*\n******************************************************************-EU-*\n         SPACE 1                                                   -EU-\n        EXTRACT ANSWER,'S',FIELDS=(TIOT,TSO)                       -EU-\n         L     R4,ANSWER+4              GET ADDRESS OF TSO FLAG    -EU-\n         TM    0(R4),X'80'              ARE WE IN TSO ?            -EU-\n         BO    TPTSO                    YES                        -EU-\n         OI    @SWITCH,@BATCH           NO, BATCH RUN              -EU-\n         L     R3,0(R2)                 PARM. FIELD ADDRESS        -EU-\n         LH    R2,0(R3)                 GET PARM. FIELD LENGTH     -EU-\n         LTR   R2,R2                    ANY PARM. SPECIFIED ?      -EU-\n         BNP   NOPARM                   NO, MISSING                -EU-\n         CH    R2,=H'2'                 POSSIBLE SYSOUT CLASS ?    -EU-\n         BL    GTPARM                   NO                         -EU-\n         CLI   3(R3),C'/'               SYSOUT CLASS SPECIFIED ?   -EU-\n         BNE   GTPARM                   NO                         -EU-\n         MVC   @HCLASS(1),2(R3)         YES, GET IT                -EU-\n         SH    R2,=H'2'                 ADJUST PARM. FIELD PTRS    -EU-\n         LA    R3,2(R3)                                            -EU-\nGTPARM   CH    R2,=Y(L'@PARM)           ACCEPTABLE PARM. LENGTH ?  -EU-\n         BH    PARMERR                  NO, TOO LONG               -EU-\n         XC    @PPTR,@PPTR                                         -EU-\n         XC    @PARM,@PARM                                         -EU-\n         MVI   @PARM+L'@PARM,0                                     -EU-\n         BCTR  R2,0                                                -EU-\n         EX    R2,MVPARM                GET PARM. SPECIFIED        -EU-\n         LA    R1,@PARM+1(R2)                                      -EU-\n         MVI   0(R1),C'P'               SET STOP HARDCOPY          -EU-\n         B     TPTSO                                               -EU-\nMVPARM   MVC   @PARM(*-*),2(R3)         << EXECUTED >>             -EU-\nNOPARM  WTO    'REQUESTED PARM. FIELD MISSING.',ROUTCDE=11,DESC=7  -EU-\n         LA    R9,12                    SET R.C.                   -EU-\n         B     PEXIT                    EXIT                       -EU-\nPARMERR WTO    'PARM. FIELD IS TOO LONG.',ROUTCDE=11,DESC=7        -EU-\n         LA    R9,16                    SET R.C.                   -EU-\n         B     PEXIT                    EXIT                       -EU-\nTPTSO   $EACM  REQAUT                                              -EU-\n         CLI   AUTH,LV0                 AUTHORIZED?                -EU-\n         BNE   P000100                  YES                        -EU-\n         TM    @SWITCH,@BATCH           NO, BATCH RUNNING ?        -EU-\n         BO    BATCH01                  YES                        -EU-\n        TPUT   MUAUT,L'MUAUT            NO, NOT AUTHORIZED         -EU-\n         B     BATCH02                                             -EU-\nBATCH01 WTO    'UNAUTHORIZED EXECUTION.',ROUTCDE=11,DESC=7         -EU-\nBATCH02  LA    R9,20                    SET R.C.                   -EU-\n         B     PEXIT                    EXIT                       -EU-\n         EJECT\nP000100  TM    @SWITCH,@BATCH           NO, BATCH RUNNING ?        -EU-\n         BO    P000110                  YES                        -EU-\n        STFSMODE INITIAL=YES            PREPARE FOR VTAM TERMINAL I/O\nP000110  MVC   @TIOT,ANSWER             SET ADDRESS OF TIOT        -EU-\n         MVC   @HCMOD,VSM77000          SET ADDRESS OF HARDCOPY RTN-EU-\n         MVC   @SNAP,VSM88000           SET ADDRESS OF SNAP RTN    -EU-\n         MVC   #TYPE,=CL4'XA'           SET MVS SYSTEM TYPE        -EU-\n        $TSWXA 31,EXPAND=ONLY           ENTER 31-BIT MODE          -EU-\n         SPACE 1                                                   -EU-\n         L     R0,@WASIZ                WORK AREA SIZE             -EU-\n        GETMAIN R,LV=(0)                OBTAIN IT                  -EU-\n         ST    R1,@WAADD                WORK AREA ADDRESS          -EU-\n         SPACE 1                                                   -EU-\n         L     R3,CVTPTR                CVT POINTER\n         LA    R2,256                   BACKUP TO\n         SR    R3,R2                    CVT PREFIX\n         USING CVTFIX,R3                CVT DSECT ADDRESSABILITY\n         L     R2,CVTGDA                DETERMINE GDA ADDRESS\n         LA    R2,0(R2)                 CLEAR HIGH ORDER BYTE/BIT\n         ST    R2,@GDA                  STORE GDA ADDRESS\n         L     R2,CVTSMCA               POINT TO SMF WORK AREA\n         LA    R2,0(R2)                 CLEAR HIGH ORDER BYTE/BIT\n         LTR   R2,R2                    SMF IN USE (ADDR = 0) ?\n         BZ    P000200                  BRANCH IF NO\n         MVC   #CPUID,16(R2)            MOVE CPU ID TO SCREEN (SMCASID)\nP000200  MVC   CPUMDL,CVTMDL            DETERMINE CPU MODEL\n         MVC   #RELNO,CVTRELNO          SET SYSTEM RELEASE         -EU-\n         DROP  R3                       DROP CVT DSECT ADDRESSABILITY\n         UNPK  TENBYTE,CPUMDL           UNPACK CPU MODEL\n         TR    TENBYTE+3(4),TRTABLE     TRANSLATE\n         MVC   CPUMDL,TENBYTE+3         MOVE BACK\n         MVC   #CPUMDL,CPUMDL           MOVE CPU MODEL TO SCREEN\n         MVC   @IOMOD,VSM99000          MOVE I/O MOD ADDR TO LINKAGE\n         MVI   @BADCMND,C' '            MOVE BLANK TO BAD COMMAND IND\nP000300  MVC   #MSG,@MSG                SET EVENTUAL MESSAGE\n         MVI   @MSG,C' '                  AND CLEAR IT\n         MVC   @MSG+1(L'@MSG-1),@MSG\n         LA    R0,#SCREEN               LOAD SCREEN ADDRESS\n         ST    R0,@PUTAREA              SAVE ADDR IN LINKAGE SECTION\n         LA    R0,#SCRNLEN              LOAD SCREEN LENGTH\n         ST    R0,@PUTLEN               STORE IN LINKAGE SECTION\n         LR    R1,R10                   POINT TO LINKAGE\n         L     R15,VSM99000             LOAD ADDRESS OF I/O MODULE\n         BASR  R14,R15                  GO DO TERMINAL I/O\n         SPACE 1\nP000400  CLI   @RSPONSE,C'1'            MAP VIRTUAL STORAGE ?\n         BE    P000500                  BRANCH IF YES\n         CLI   @RSPONSE,C'2'            SHOW SUBPOOL UTILIZATION ?\n         BE    P000600                  BRANCH IF YES\n         CLI   @RSPONSE,C'3'            SHOW CSA BY PROTECT KEY ?\n         BE    P000700                  BRANCH IF YES\n         CLI   @RSPONSE,C'H'            SHOW HELP MENU\n         BE    P000910                  BRANCH IF YES\n         CLI   @RSPONSE,C'M'            SHOW THE PRIMARY MENU ?\n         BE    P000300                  BRANCH IF YES\n         CLI   @RSPONSE,C'R'            REFRESH SCREEN ?\n         BE    P000300                  BRANCH IF YES (DUMB BUT DOIT)\n         CLI   @RSPONSE,C'Z'            TERMINATE VSM?\n         BE    P999999                  BRANCH IF YES\n         TM    @SWITCH,@HFAIL           HARDCOPY OPEN HAS FAILED ? -EU-\n         BO    P000850                  BRANCH IF YES              -EU-\n         CLI   @RSPONSE,C'S'            START HARDCOPY ?           -EU-\n         BE    P000800                  BRANCH IF YES              -EU-\n         CLI   @RSPONSE,C'P'            STOP HARDCOPY ?            -EU-\n         BE    P000810                  BRANCH IF YES              -EU-\n         B     P000900                  ELSE BAD COMMAND\n         EJECT\nP000500  L     R15,VSM00100             LOAD ADDR OF VIRT STOR MAP -EU-\n         B     P000920                  GO MAP VIRTUAL STORAGE     -EU-\n         SPACE 1                                                   -EU-\nP000600  L     R15,VSM00200             LOAD ADDR OF SUBPOOL MON.  -EU-\n         B     P000920                  GO MONITOR SUBPOOLS        -EU-\n         SPACE 1                                                   -EU-\nP000700  L     R15,VSM00300             LOAD ADDR OF PROT. KEY CP  -EU-\n         B     P000920                  GO MONITOR PROTECT KEYS    -EU-\n         SPACE 1\nP000800  LA    R0,1                     SET R0 POSITIVE            -EU-\n         B     P000820                                             -EU-\nP000810  XR    R0,R0                    SET R0 NEGATIVE            -EU-\n         BCTR  R0,0                                                -EU-\nP000820  L     R15,VSM77000             LOAD ADDRESS OF HARDCOPY   -EU-\n         B     P000920                  GO HARDCOPY                -EU-\nP000850  MVI   @BADCMND,C'2'            INDICATE HARDCOPY FAILED   -EU-\n         B     P000910                                             -EU-\n         SPACE 1\nP000900  MVI   @BADCMND,C'1'            INDICATE INVALID COMMAND\nP000910  L     R15,VSMHELP              LOAD ADDRESS OF HELP SCREEN\nP000920  BASR  R14,R15                  GO HELP OUT                -EU-\n         B     P000400                  READ RESPONSE\n         EJECT                                                     -EU-\n******************************************************************-EU-*\n*        CLEAR SCREEN BEFORE EXIT                                 -EU-*\n******************************************************************-EU-*\n         SPACE 1                                                   -EU-\nP999999  TM    @SWITCH,@BATCH           NO, BATCH RUNNING ?        -EU-\n         BO    BATCH90                  YES                        -EU-\n        TPUT   CLEAR,CLEARL,FULLSCR,,HOLD                          -EU-\n        STFSMODE OFF                    INDICATE NO MORE FULLSCREEN\n        TCLEARQ INPUT                   CLEANUP\nBATCH90  LR    R1,R10                   POINT TO LINKAGE           -EU-\n         LH    R0,=H'-1'                CLOSE                      -EU-\n         L     R15,VSM88000               SNAP FILE                -EU-\n         BASR  R14,R15                      IF NEEDED              -EU-\n         EJECT                                                     -EU-\n******************************************************************-EU-*\n*        TERMINATE VSM                                            -EU-*\n******************************************************************-EU-*\n         SPACE 1                                                   -EU-\n         L     R1,@WAADD                WORK AREA ADDRESS          -EU-\n         L     R0,@WASIZ                WORK AREA SIZE             -EU-\n        FREEMAIN R,A=(1),LV=(0)         FREE IT                    -EU-\n        $TSWXA 24,EXPAND=ONLY           BACK TO 24-BIT MODE        -EU-\n         XR    R9,R9                    SET EXIT CC=0              -EU-\n         TM    @SWITCH,@HFAIL           HARDCOPY OPEN HAS FAILED ? -EU-\n         BO    PEXIT                    YES                        -EU-\n         TM    @SWITCH,@HCOPY           HARDCOPY OPENED YET ?      -EU-\n         BZ    PEXIT                    NO                         -EU-\n         XR    R0,R0                    YES, CLOSE IT              -EU-\n         BCTR  R0,0                     SET R0 NEGATIVE            -EU-\n         LR    R1,R10                   POINT TO LINKAGE           -EU-\n         L     R15,VSM77000             LOAD ADDRESS OF HARDCOPY   -EU-\n         BASR  R14,R15                  GO STOP HARDCOPY           -EU-\n         TM    @SWITCH,@BATCH           NO, BATCH RUNNING ?        -EU-\n         BO    BATCH99                  YES                        -EU-\n        TPUT   @MSG,L'@MSG              SAY IT                     -EU-\n         B     PEXIT                                               -EU-\nBATCH99 WTO    MF=(E,@MSGW)             SAY IT                     -EU-\n         SPACE 1\nPEXIT   $XRET  CC=(R9)                  B O O G I E                -EU-\n         EJECT\nVSM00100 DC    V(VSM00100)              VIRTUAL STORAGE MAPPER     -EU-\nVSM00200 DC    V(VSM00200)              SUBPOOL MONITOR            -EU-\nVSM00300 DC    V(VSM00300)              PROTECT KEY MONITOR        -EU-\nVSM77000 DC    V(VSM77000)              HARDCOPY MODULE            -EU-\nVSM88000 DC    V(VSM88000)              DEBUGING AID MODULE        -EU-\nVSM99000 DC    V(VSM99000)              TERMINAL I/O MODULE\nVSMHELP  DC    V(VSMHELP)               HELP SCREEN\n         SPACE 1\nTRTABLE  DS    0CL256\n         DC    CL240' '\n         DC    CL16'0123456789ABCDEF'\nCPUMDL   DC    F'0'\nTENBYTE  DC    XL10'0'\nCLEAR    $FS   WCC=(AL,KBR,RMDT),MF=L                              -EU-\n         $FS   SBA=(1,1),RA=(1,1,00),MF=L                          -EU-\n         $FS   SBA=(1,1),SF=IC,MF=L                                -EU-\nCLEARL   EQU   *-CLEAR                                             -EU-\n         SPACE 1\n#SCREEN  DS    0F\n         $FS   WCC=(KBR,RMDT),MF=L                                 -EU-\n         $FS   SBA=(1,1),RA=(1,1,00),MF=L                          -EU-\n         $FS   SBA=(1,1),SF=(PROT,INT),MF=L                        -EU-\n         $FS   TEXT='SELECT OPTION =>',MF=L                        -EU-\n         $FS   SF=NORMAL,TEXT=' ',MF=L                             -EU-\n         $FS   SF=(PROT),MF=L                                      -EU-\n         $FS   SBA=(1,65),TEXT='CPU ID :',MF=L                     -EU-\n         $FS   SF=(PROT,INT),MF=L                                  -EU-\n#CPUID   $FS   TEXT=(' ',4),MF=L                                   -EU-\n         $FS   SF=(PROT),MF=L                                      -EU-\n         $FS   SBA=(2,62),TEXT='CPU MODEL :',MF=L                  -EU-\n         $FS   SF=(PROT,INT),MF=L                                  -EU-\n#CPUMDL  $FS   TEXT=(' ',4),MF=L                                   -EU-\n         $FS   SF=(PROT),MF=L                                      -EU-\n         $FS   SBA=(3,63),TEXT='MVS REL. :',MF=L                   -EU-\n         $FS   SF=(PROT,INT),MF=L                                  -EU-\n#RELNO   $FS   TEXT=(' ',4),MF=L                                   -EU-\n         $FS   SF=(PROT),MF=L                                      -EU-\n         $FS   SBA=(4,63),TEXT='MVS TYPE :',MF=L                   -EU-\n         $FS   SF=(PROT,INT),MF=L                                  -EU-\n#TYPE    $FS   TEXT=(' ',4),MF=L                                   -EU-\n         $FS   SF=(PROT),MF=L                                      -EU-\n*        $FS   SBA=(6,33),SF=(PROT,INT),MF=L                CBT-AXC-EU-\n*        $FS   TEXT='HALLMARK CARDS',MF=L                   CBT-AXC-EU-\n*        $FS   SF=(PROT),MF=L                               CBT-AXC-EU-\n*        $FS   SBA=(6,33),SF=(PROT,INT),MF=L                CBT-AXC-EU-\n*        $FS   TEXT='CONNECTICUT BANK AND TRUST',MF=L       CBT-AXC-EU-\n*        $FS   SF=(PROT),MF=L                               CBT-AXC-EU-\n         $FS   SBA=(7,28),SF=(PROT,INT),MF=L                       -EU-\n         $FS   TEXT='VIRTUAL STORAGE MONITOR',MF=L                 -EU-\n         $FS   SF=(PROT),MF=L                                      -EU-\n         $FS   SBA=(10,11),SF=(PROT,INT),TEXT='PFK-10/22',MF=L     -EU-\n         $FS   SF=(PROT),TEXT='OR',MF=L                            -EU-\n         $FS   SF=(PROT,INT),TEXT='1 ',MF=L                        -EU-\n         $FS   SF=(PROT),MF=L                                      -EU-\n         $FS   TEXT='MAP VIRTUAL STORAGE',MF=L                     -EU-\n         $FS   SBA=(11,11),SF=(PROT,INT),TEXT='PFK-11/23',MF=L     -EU-\n         $FS   SF=(PROT),TEXT='OR',MF=L                            -EU-\n         $FS   SF=(PROT,INT),TEXT='2 ',MF=L                        -EU-\n         $FS   SF=(PROT),MF=L                                      -EU-\n         $FS   TEXT='DISPLAY CSA/SQA SUBPOOL UTILIZATION',MF=L     -EU-\n         $FS   SBA=(12,11),SF=(PROT,INT),TEXT='PFK-12/24',MF=L     -EU-\n         $FS   SF=(PROT),TEXT='OR',MF=L                            -EU-\n         $FS   SF=(PROT,INT),TEXT='3 ',MF=L                        -EU-\n         $FS   SF=(PROT),MF=L                                      -EU-\n         $FS   TEXT='DISPLAY CSA UTILIZATION BY PROTECT KEY',MF=L  -EU-\n         $FS   SBA=(13,12),SF=(PROT,INT),TEXT='PFK-1/13',MF=L      -EU-\n         $FS   SF=(PROT),TEXT='OR',MF=L                            -EU-\n         $FS   SF=(PROT,INT),TEXT='H ',MF=L                        -EU-\n         $FS   SF=(PROT),MF=L                                      -EU-\n         $FS   TEXT='HELP MENU',MF=L                               -EU-\n         $FS   SBA=(14,15),SF=(PROT,INT),TEXT='ENTER',MF=L         -EU-\n         $FS   SF=(PROT),TEXT='OR',MF=L                            -EU-\n         $FS   SF=(PROT,INT),TEXT='R ',MF=L                        -EU-\n         $FS   SF=(PROT),MF=L                                      -EU-\n         $FS   TEXT='REFRESH THE SCREEN',MF=L                      -EU-\n         $FS   SBA=(15,12),SF=(PROT,INT),TEXT='PFK-7/19',MF=L      -EU-\n         $FS   SF=(PROT),TEXT='OR',MF=L                            -EU-\n         $FS   SF=(PROT,INT),TEXT='S ',MF=L                        -EU-\n         $FS   SF=(PROT),MF=L                                      -EU-\n         $FS   TEXT='START HARDCOPY OF 1, 2 AND 3',MF=L            -EU-\n         $FS   SBA=(16,12),SF=(PROT,INT),TEXT='PFK-8/20',MF=L      -EU-\n         $FS   SF=(PROT),TEXT='OR',MF=L                            -EU-\n         $FS   SF=(PROT,INT),TEXT='P ',MF=L                        -EU-\n         $FS   SF=(PROT),MF=L                                      -EU-\n         $FS   TEXT='STOP HARDCOPY',MF=L                           -EU-\n         $FS   SBA=(17,12),SF=(PROT,INT),TEXT='PFK-3/15',MF=L      -EU-\n         $FS   SF=(PROT),TEXT='OR',MF=L                            -EU-\n         $FS   SF=(PROT,INT),TEXT='Z ',MF=L                        -EU-\n         $FS   SF=(PROT),MF=L                                      -EU-\n         $FS   TEXT='EXIT VSM',MF=L                                -EU-\n         $FS   SBA=(23,9),SF=(PROT,INT),MF=L                       -EU-\n#MSG     $FS   TEXT=(' ',50),MF=L                                  -EU-\n         $FS   SF=(PROT),MF=L                                      -EU-\n         $FS   SBA=(1,1),SF=(PT,IC),MF=L                           -EU-\n#SCRNLEN EQU   *-#SCREEN\n         EJECT\nANSWER   DC    A(*-*,*-*)                                          -EU-\nREQAUT   DC    0F'0',BL1'00000000',AL3(MDL@IX),AL4(AUTH)           -EU-\nAUTH     DC    XL1'0'                                              -EU-\nMUAUT    DC    C'UNAUTHORIZED COMMAND.'                            -EU-\n         SPACE 2\n         LTORG\n         SPACE 2                                                   -EU-\nLINKAGE $LNKSECT DS=NO,SZ=12                                       -EU-\n         EJECT\n         PRINT NOGEN                                               -EU-\n         CVT   DSECT=YES,PREFIX=YES,LIST=YES\n         PRINT GEN                                                 -EU-\n         SPACE 2\n         $LNKSECT\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "VSM00100": {"ttr": 19212, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x882?\\x00\\x882?\\x144\\x02\\xf5\\x02\\xf5\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-11-18T00:00:00", "modifydate": "1988-11-18T14:34:00", "lines": 757, "newlines": 757, "modlines": 0, "user": "SYSPAJA"}, "text": "V100     TITLE 'VSM00100 - VIRTUAL STORAGE MEMORY MAPPER.'\n         PRINT OFF\n         COPY  VSMMAC\n         PRINT ON\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*    MODULE :           VSM00100 (MVS/XA)                             *\n*                       VERSION : 1.0                                 *\n*                       DATE : 12 NOV 1986                            *\n*                       NAME : VIRTUAL STORAGE MEMORY MAPPER          *\n*                       ATTRIBUTES : REUS                             *\n*                                                                     *\n*    AUTHOR :           MOINIL P.A. - COMPUTING CENTRE                *\n*                       J.R.C. - ISPRA ESTABLISHMENT                  *\n*                       21020 ISPRA (VA), ITALY                       *\n*                                                                     *\n*    FUNCTION :         THIS MODULE WILL MAP VIRTUAL STORAGE. IT      *\n*                       WILL SHOW THE HIGH AND LOW VIRTUAL ADDRESS    *\n*                       OF SQA, PLPA, CSA, THE PRIVATE AREA AND THE   *\n*                       NUCLEUS. IT WILL ALSO SHOW THE SIZE OF EACH   *\n*                       AREA IN MEG AND IN K.                         *\n*                                                                     *\n*    REGS AT ENTRY :    R1   - INTER MODULE LINKAGE                   *\n*                       R14  - RETURN ADDRESS                         *\n*                       R15  - EPA                                    *\n*                                                                     *\n*    REGS USAGE :       R0   - WORK REGISTER                          *\n*                       R1   - POINTER TO INTER MODULE LINKAGE        *\n*                       R2-R5 - WORK REGISTERS                        *\n*                       R10  - LINKAGE AREA POINTER                   *\n*                       R11  - BASE REGISTER                          *\n*                       R12  - 2ND BASE REGISTER (RESERVED)           *\n*                       R13  - SAVE AREA POINTER                      *\n*                       R14  - LINKAGE REGISTER                       *\n*                       R15  - ADDRESS OF CALLED MODULES              *\n*                                                                     *\n*    REGS AT EXIT :     R14  - RETURN ADDRESS                         *\n*                                                                     *\n*    LABELS :           SOME OF THE FIELD USAGE IN THIS MODULE CAN    *\n*                       BE DETERMINED BY THE FIRST CHARACTER OF THE   *\n*                       FIELD. THE KEYS ARE :                         *\n*                            @ - FIELD IS IN INTER-MODULE LINKAGE     *\n*                                AREA                                 *\n*                            # - FIELD IS PART OF THE OUTPUT SCREEN   *\n*                            $ - DSECT                                *\n*                                                                     *\n***********************************************************************\n         EJECT\nVSM00100 START 0\n         SPACE 1\n        $DEFREG ,\n***********************************************************************\n*        STANDARD OS LINKAGE                                          *\n***********************************************************************\n         SPACE 1\n        $XENT  BASE=R11            SAVE CALLER'S REGS\n         LR    R10,R1              POINT TO LINKAGE AREA\n         USING $LNKSECT,R10        DSECT ADDRESSABILITY\n         EJECT\n***********************************************************************\n*        INITIALIZATION                                               *\n***********************************************************************\n         SPACE 1\n         MVI   DBLEWORD,0          CLEAR WORK FIELDS WITH ZEROS\n         MVC   DBLEWORD+1(CLRL-1),DBLEWORD\n         L     R1,CVTPTR           GET CVT ADDRESS\n         USING CVTMAP,R1           DSECT ADDRESSABILITY\n         L     R4,CVTSMEXT         GET STORAGE MAP EXTENSION ADDRESS\n         DROP  R1                  DROP CVT ADDRESSABILITY\n         USING CVTVSTGX,R4         DSECT ADDRESSABILITY\n         MVC   MLPAS,CVTMLPAS      START MLPA ADDRESS\n         MVC   FLPAS,CVTFLPAS      START FLPA ADDRESS\n         MVC   FLPAE,CVTFLPAE      END FLPA ADDRESS\n         MVC   PLPAS,CVTPLPAS      START PLPA ADDRESS\n         MVC   PLPAE,CVTPLPAE      END PLPA ADDRESS\n         MVC   EPLPS,CVTEPLPS      START EXT. PLPA ADDRESS\n         MVC   EPLPE,CVTEPLPE      END EXT. PLPA ADDRESS\n         MVC   EFLPS,CVTEFLPS      START EXT. FLPA ADDRESS\n         MVC   EFLPE,CVTEFLPE      END EXT. FLPA ADDRESS\n         MVC   EMLPE,CVTEMLPE      END EXT. MLPA ADDRESS\n         MVC   NUCSTR,CVTRWNS      START NUCLEUS ADDRESS\n         MVC   NUCEND,CVTERWNE     END EXT. NUCLEUS ADDRESS\n         DROP  R4                  DROP ADDRESSABILITY\n         L     R4,@GDA             GET GDA ADDRESS\n         USING GDA,R4              DSECT ADDRESSABILITY\n         ST    R4,@SNPLST          BUILD\n         LA    R1,GDAEND             GDA\n         ST    R1,@SNPLST+4            SNAP\n         OI    @SNPLST+4,X'80'           LIST\n        $SNAP  ID=1                ID-NUMBER - - - - - - - - - - - 001\n         MVC   CSALOW,GDACSA       LOWEST CSA AREA ADDRESS\n         MVC   CSASIZE,GDACSASZ    CSA AREA SIZE\n         MVC   CSAELOW,GDAECSA     LOWEST CSA AREA EXT. ADDRESS\n         MVC   CSAESIZE,GDAECSAS   CSA AREA EXTENDED SIZE\n         MVC   SQALOW,GDASQA       BEGIN SQA AREA ADDRESS\n         MVC   SQASIZE,GDASQASZ    SQA AREA SIZE\n         MVC   SQAELOW,GDAESQA     BEGIN SQA AREA EXT. ADDRESS\n         MVC   SQAESIZE,GDAESQAS   SQA AREA EXTENDED SIZE\n         MVC   PVTLOW,GDAPVT       BEGIN PRIVATE AREA ADDRESS\n         MVC   PVTSIZE,GDAPVTSZ    PRIVATE AREA SIZE\n         MVC   PVTELOW,GDAEPVT     BEGIN PRIVATE AREA EXT. ADDRESS\n         MVC   PVTESIZE,GDAEPVTS   PRIVATE AREA EXTENDED SIZE\n         MVC   VRLOW,GDAVR         ADDRESS OF GLOBAL V=R AREA\n         MVC   VRSIZE,GDAVRSZ      SIZE OF GLOBAL V=R AREA\n         DROP  R4                  DROP GDA ADDRESSABILITY\n         EJECT\n***********************************************************************\n*        DO THE CALCULATIONS AND FORMAT DATA TO BE OUTPUT             *\n***********************************************************************\n         SPACE 1\n         LA    R4,10               SET R4 TO 10\n         L     R5,=A(X'00100000')  LOAD 1 MEG INTO R5\n         MVC   FIVEBYTE,PVTELOW    LOWEST PVT AREA EXT. ADDRESS\n         UNPK  TENBYTE,FIVEBYTE    UNPACK\n         TR    TENBYTE+1(8),TRTABLE     TRANSLATE\n         MVC   #EPVTL,TENBYTE+1    MOVE TO OUTPUT SCREEN\n         L     R3,PVTELOW          LOWEST PVT AREA EXT. ADDRESS\n         A     R3,PVTESIZE         SIZE OF PRIVATE AREA EXTENDED\n         BCTR  R3,0                HIGHEST PVT AREA EXT. ADDRESS\n         STCM  R3,B'1111',FIVEBYTE\n         UNPK  TENBYTE,FIVEBYTE    UNPACK\n         TR    TENBYTE+1(8),TRTABLE     TRANSLATE\n         MVC   #EPVTH,TENBYTE+1    MOVE TO OUTPUT SCREEN\n         XR    R2,R2               CLEAR R2\n         L     R3,PVTESIZE         SIZE OF PRIVATE AREA EXTENDED\n         LR    R0,R3               SAVE FOR COMPUTATION IN K\n         MR    R2,R4               MULTIPLY BY 10\n         DR    R2,R5               THEN DIVIDE BY 1 MEG\n         CVD   R3,DBLEWORD         CONVERT\n         MVC   #EPVTSM,EDIT1       FORMAT\n         ED    #EPVTSM,DBLEWORD+5  MOVE TO OUTPUT SCREEN\n         SRA   R0,10               SIZE IN K\n         CVD   R0,DBLEWORD         CONVERT\n         MVC   #EPVTSK,EDIT2       FORMAT\n         ED    #EPVTSK,DBLEWORD+4  MOVE TO OUTPUT SCREEN\n         MVC   FIVEBYTE,CSAELOW    LOWEST CSA AREA EXT. ADDRESS\n         UNPK  TENBYTE,FIVEBYTE    UNPACK\n         TR    TENBYTE+1(8),TRTABLE     TRANSLATE\n         MVC   #ECSAL,TENBYTE+1    MOVE TO OUTPUT SCREEN\n         L     R3,CSAELOW          LOWEST CSA AREA EXT. ADDRESS\n         A     R3,CSAESIZE         SIZE OF CSA AREA EXTENDED\n         BCTR  R3,0                HIGHEST CSA AREA EXT. ADDRESS\n         STCM  R3,B'1111',FIVEBYTE\n         UNPK  TENBYTE,FIVEBYTE    UNPACK\n         TR    TENBYTE+1(8),TRTABLE     TRANSLATE\n         MVC   #ECSAH,TENBYTE+1    MOVE TO OUTPUT SCREEN\n         XR    R2,R2               CLEAR R2\n         L     R3,CSAESIZE         SIZE OF CSA AREA EXTENDED\n         LR    R0,R3               SAVE FOR COMPUTATION IN K\n         MR    R2,R4               MULTIPLY BY 10\n         DR    R2,R5               THEN DIVIDE BY 1 MEG\n         CVD   R3,DBLEWORD         CONVERT\n         MVC   #ECSASM,EDIT1       FORMAT\n         ED    #ECSASM,DBLEWORD+5  MOVE TO OUTPUT SCREEN\n         SRA   R0,10               SIZE IN K\n         CVD   R0,DBLEWORD         CONVERT\n         MVC   #ECSASK,EDIT2       FORMAT\n         ED    #ECSASK,DBLEWORD+4  MOVE TO OUTPUT SCREEN\n         MVC   FIVEBYTE,EFLPS      START FLPA EXT. ADDRESS\n         UNPK  TENBYTE,FIVEBYTE    UNPACK\n         TR    TENBYTE+1(8),TRTABLE     TRANSLATE\n         MVC   #EFLPAL,TENBYTE+1   MOVE TO OUTPUT SCREEN\n         L     R3,EMLPE            END MLPA EXT. ADDRESS\n         LTR   R3,R3               MLPA EXT. DEFINED ?\n         BZ    *+L'*+10            NO\n         MVC   #TXE(14),=CL14'MLPA+FLPA EXT.'     SET TEXT\n         B     *+L'*+10\n         L     R3,EFLPE            END FLPA EXT. ADDRESS\n         MVC   #TXE(14),=CL14'     FLPA EXT.'     SET TEXT\n         STCM  R3,B'1111',FIVEBYTE\n         UNPK  TENBYTE,FIVEBYTE    UNPACK\n         TR    TENBYTE+1(8),TRTABLE     TRANSLATE\n         MVC   #EFLPAH,TENBYTE+1   MOVE TO OUTPUT SCREEN\n         L     R3,EMLPE            END MLPA EXT. ADDRESS\n         LTR   R3,R3               MLPA EXT. DEFINED ?\n         BNZ   *+L'*+4             YES\n         L     R3,EFLPE            END FLPA EXT. ADDRESS\n         LA    R3,1(R3)\n         S     R3,EFLPS            COMPUTE SIZE\n         LR    R0,R3               SAVE FOR COMPUTATION IN K\n         MR    R2,R4               MULTIPLY BY 10\n         DR    R2,R5               THEN DIVIDE BY 1 MEG\n         CVD   R3,DBLEWORD         CONVERT\n         MVC   #EFLPASM,EDIT1      FORMAT\n         ED    #EFLPASM,DBLEWORD+5 MOVE TO OUTPUT SCREEN\n         SRA   R0,10               SIZE IN K\n         CVD   R0,DBLEWORD         CONVERT\n         MVC   #EFLPASK,EDIT2      FORMAT\n         ED    #EFLPASK,DBLEWORD+4 MOVE TO OUTPUT SCREEN\n         MVC   FIVEBYTE,EPLPS      START PLPA EXT. ADDRESS\n         UNPK  TENBYTE,FIVEBYTE    UNPACK\n         TR    TENBYTE+1(8),TRTABLE     TRANSLATE\n         MVC   #EPLPAL,TENBYTE+1   MOVE TO OUTPUT SCREEN\n         MVC   FIVEBYTE,EPLPE      END PLPA EXT. ADDRESS\n         UNPK  TENBYTE,FIVEBYTE    UNPACK\n         TR    TENBYTE+1(8),TRTABLE     TRANSLATE\n         MVC   #EPLPAH,TENBYTE+1   MOVE TO OUTPUT SCREEN\n         L     R3,EPLPE            COMPUTE PLPA EXT. SIZE\n         LA    R3,1(R3)\n         S     R3,EPLPS\n         LR    R0,R3               SAVE FOR COMPUTATION IN K\n         MR    R2,R4               MULTIPLY BY 10\n         DR    R2,R5               THEN DIVIDE BY 1 MEG\n         CVD   R3,DBLEWORD         CONVERT\n         MVC   #EPLPASM,EDIT1      FORMAT\n         ED    #EPLPASM,DBLEWORD+5 MOVE TO OUTPUT SCREEN\n         SRA   R0,10               SIZE IN K\n         CVD   R0,DBLEWORD         CONVERT\n         MVC   #EPLPASK,EDIT2      FORMAT\n         ED    #EPLPASK,DBLEWORD+4 MOVE TO OUTPUT SCREEN\n         MVC   FIVEBYTE,SQAELOW    LOWEST SQA AREA EXT. ADDRESS\n         UNPK  TENBYTE,FIVEBYTE    UNPACK\n         TR    TENBYTE+1(8),TRTABLE     TRANSLATE\n         MVC   #ESQAL,TENBYTE+1    MOVE TO OUTPUT SCREEN\n         L     R3,SQAELOW          LOWEST SQA AREA EXT. ADDRESS\n         A     R3,SQAESIZE         SIZE OF SQA AREA EXTENDED\n         BCTR  R3,0                HIGHEST SQA AREA EXT. ADDRESS\n         STCM  R3,B'1111',FIVEBYTE\n         UNPK  TENBYTE,FIVEBYTE    UNPACK\n         TR    TENBYTE+1(8),TRTABLE     TRANSLATE\n         MVC   #ESQAH,TENBYTE+1    MOVE TO OUTPUT SCREEN\n         XR    R2,R2               CLEAR R2\n         L     R3,SQAESIZE         SIZE OF SQA AREA EXTENDED\n         LR    R0,R3               SAVE FOR COMPUTATION IN K\n         MR    R2,R4               MULTIPLY BY 10\n         DR    R2,R5               THEN DIVIDE BY 1 MEG\n         CVD   R3,DBLEWORD         CONVERT\n         MVC   #ESQASM,EDIT1       FORMAT\n         ED    #ESQASM,DBLEWORD+5  MOVE TO OUTPUT SCREEN\n         SRA   R0,10               SIZE IN K\n         CVD   R0,DBLEWORD         CONVERT\n         MVC   #ESQASK,EDIT2       FORMAT\n         ED    #ESQASK,DBLEWORD+4  MOVE TO OUTPUT SCREEN\n         MVC   FIVEBYTE,NUCEND     HIGHEST EXT. NUCLEUS ADDRESS\n         UNPK  TENBYTE,FIVEBYTE    UNPACK\n         TR    TENBYTE+1(8),TRTABLE     TRANSLATE\n         MVC   #ENUCH,TENBYTE+1    MOVE TO OUTPUT SCREEN\n         XR    R2,R2               CLEAR R2\n         L     R3,NUCEND           HIGHEST EXT. NUCLEUS ADDRESS\n         LA    R3,1(R3)\n         S     R3,=A(16*1024*1024) COMPUTE EXT. NUCLEUS SIZE\n         LR    R0,R3               SAVE FOR COMPUTATION IN K\n         MR    R2,R4               MULTIPLY BY 10\n         DR    R2,R5               THEN DIVIDE BY 1 MEG\n         CVD   R3,DBLEWORD         CONVERT\n         MVC   #ENUCSM,EDIT1       FORMAT\n         ED    #ENUCSM,DBLEWORD+5  MOVE TO OUTPUT SCREEN\n         SRA   R0,10               SIZE IN K\n         CVD   R0,DBLEWORD         CONVERT\n         MVC   #ENUCSK,EDIT2       FORMAT\n         ED    #ENUCSK,DBLEWORD+4  MOVE TO OUTPUT SCREEN\n         MVC   FIVEBYTE,NUCSTR     LOWEST NUCLEUS ADDRESS\n         UNPK  TENBYTE,FIVEBYTE    UNPACK\n         TR    TENBYTE+1(8),TRTABLE     TRANSLATE\n         MVC   #NUCL,TENBYTE+1     MOVE TO OUTPUT SCREEN\n         XR    R2,R2               CLEAR R2\n         L     R3,=A(16*1024*1024) HIGHEST NUCLEUS ADDRESS + 1\n         S     R3,NUCSTR           COMPUTE NUCLEUS SIZE\n         LR    R0,R3               SAVE FOR COMPUTATION IN K\n         MR    R2,R4               MULTIPLY BY 10\n         DR    R2,R5               THEN DIVIDE BY 1 MEG\n         CVD   R3,DBLEWORD         CONVERT\n         MVC   #NUCSM,EDIT1        FORMAT\n         ED    #NUCSM,DBLEWORD+5   MOVE TO OUTPUT SCREEN\n         SRA   R0,10               SIZE IN K\n         CVD   R0,DBLEWORD         CONVERT\n         MVC   #NUCSK,EDIT2        FORMAT\n         ED    #NUCSK,DBLEWORD+4   MOVE TO OUTPUT SCREEN\n         MVC   FIVEBYTE,SQALOW     LOWEST SQA AREA ADDRESS\n         UNPK  TENBYTE,FIVEBYTE    UNPACK\n         TR    TENBYTE+1(8),TRTABLE     TRANSLATE\n         MVC   #SQAL,TENBYTE+1     MOVE TO OUTPUT SCREEN\n         L     R3,SQALOW           LOWEST SQA AREA ADDRESS\n         A     R3,SQASIZE          SIZE OF SQA AREA\n         BCTR  R3,0                HIGHEST SQA AREA ADDRESS\n         STCM  R3,B'1111',FIVEBYTE\n         UNPK  TENBYTE,FIVEBYTE    UNPACK\n         TR    TENBYTE+1(8),TRTABLE     TRANSLATE\n         MVC   #SQAH,TENBYTE+1     MOVE TO OUTPUT SCREEN\n         XR    R2,R2               CLEAR R2\n         L     R3,SQASIZE          SIZE OF SQA AREA\n         LR    R0,R3               SAVE FOR COMPUTATION IN K\n         MR    R2,R4               MULTIPLY BY 10\n         DR    R2,R5               THEN DIVIDE BY 1 MEG\n         CVD   R3,DBLEWORD         CONVERT\n         MVC   #SQASM,EDIT1        FORMAT\n         ED    #SQASM,DBLEWORD+5   MOVE TO OUTPUT SCREEN\n         SRA   R0,10               SIZE IN K\n         CVD   R0,DBLEWORD         CONVERT\n         MVC   #SQASK,EDIT2        FORMAT\n         ED    #SQASK,DBLEWORD+4   MOVE TO OUTPUT SCREEN\n         MVC   FIVEBYTE,PLPAS      START PLPA ADDRESS\n         UNPK  TENBYTE,FIVEBYTE    UNPACK\n         TR    TENBYTE+1(8),TRTABLE     TRANSLATE\n         MVC   #PLPAL,TENBYTE+1    MOVE TO OUTPUT SCREEN\n         MVC   FIVEBYTE,PLPAE      END PLPA ADDRESS\n         UNPK  TENBYTE,FIVEBYTE    UNPACK\n         TR    TENBYTE+1(8),TRTABLE     TRANSLATE\n         MVC   #PLPAH,TENBYTE+1    MOVE TO OUTPUT SCREEN\n         L     R3,PLPAE            COMPUTE PLPA SIZE\n         LA    R3,1(R3)\n         S     R3,PLPAS\n         LR    R0,R3               SAVE FOR COMPUTATION IN K\n         MR    R2,R4               MULTIPLY BY 10\n         DR    R2,R5               THEN DIVIDE BY 1 MEG\n         CVD   R3,DBLEWORD         CONVERT\n         MVC   #PLPASM,EDIT1       FORMAT\n         ED    #PLPASM,DBLEWORD+5  MOVE TO OUTPUT SCREEN\n         SRA   R0,10               SIZE IN K\n         CVD   R0,DBLEWORD         CONVERT\n         MVC   #PLPASK,EDIT2       FORMAT\n         ED    #PLPASK,DBLEWORD+4  MOVE TO OUTPUT SCREEN\n         L     R3,MLPAS            START MLPA ADDRESS\n         LTR   R3,R3               MLPA DEFINED ?\n         BZ    *+L'*+10            NO\n         MVC   #TX(9),=CL9'FLPA+MLPA'   SET TEXT\n         B     *+L'*+10\n         L     R3,FLPAS            START FLPA ADDRESS\n         MVC   #TX(9),=CL9'     FLPA'   SET TEXT\n         STCM  R3,B'1111',FIVEBYTE\n         UNPK  TENBYTE,FIVEBYTE    UNPACK\n         TR    TENBYTE+1(8),TRTABLE     TRANSLATE\n         MVC   #FLPAL,TENBYTE+1    MOVE TO OUTPUT SCREEN\n         MVC   FIVEBYTE,FLPAE      END FLPA ADDRESS\n         UNPK  TENBYTE,FIVEBYTE    UNPACK\n         TR    TENBYTE+1(8),TRTABLE     TRANSLATE\n         MVC   #FLPAH,TENBYTE+1    MOVE TO OUTPUT SCREEN\n         L     R3,FLPAE            END FLPA ADDRESS\n         LA    R3,1(R3)\n         OC    MLPAS,MLPAS         MLPA DEFINED ?\n         BZ    *+L'*+8             NO\n         S     R3,MLPAS            COMPUTE FLPA+MLPA SIZE\n         B     *+L'*+4             NO\n         S     R3,FLPAS            COMPUTE FLPA SIZE\n         LR    R0,R3               SAVE FOR COMPUTATION IN K\n         MR    R2,R4               MULTIPLY BY 10\n         DR    R2,R5               THEN DIVIDE BY 1 MEG\n         CVD   R3,DBLEWORD         CONVERT\n         MVC   #FLPASM,EDIT1       FORMAT\n         ED    #FLPASM,DBLEWORD+5  MOVE TO OUTPUT SCREEN\n         SRA   R0,10               SIZE IN K\n         CVD   R0,DBLEWORD         CONVERT\n         MVC   #FLPASK,EDIT2       FORMAT\n         ED    #FLPASK,DBLEWORD+4  MOVE TO OUTPUT SCREEN\n         MVC   FIVEBYTE,CSALOW     LOWEST CSA AREA ADDRESS\n         UNPK  TENBYTE,FIVEBYTE    UNPACK\n         TR    TENBYTE+1(8),TRTABLE     TRANSLATE\n         MVC   #CSAL,TENBYTE+1     MOVE TO OUTPUT SCREEN\n         L     R3,CSALOW           LOWEST CSA AREA ADDRESS\n         A     R3,CSASIZE          SIZE OF CSA AREA\n         BCTR  R3,0                HIGHEST CSA AREA ADDRESS\n         STCM  R3,B'1111',FIVEBYTE\n         UNPK  TENBYTE,FIVEBYTE    UNPACK\n         TR    TENBYTE+1(8),TRTABLE     TRANSLATE\n         MVC   #CSAH,TENBYTE+1     MOVE TO OUTPUT SCREEN\n         XR    R2,R2               CLEAR R2\n         L     R3,CSASIZE          SIZE OF CSA AREA\n         LR    R0,R3               SAVE FOR COMPUTATION IN K\n         MR    R2,R4               MULTIPLY BY 10\n         DR    R2,R5               THEN DIVIDE BY 1 MEG\n         CVD   R3,DBLEWORD         CONVERT\n         MVC   #CSASM,EDIT1        FORMAT\n         ED    #CSASM,DBLEWORD+5   MOVE TO OUTPUT SCREEN\n         SRA   R0,10               SIZE IN K\n         CVD   R0,DBLEWORD         CONVERT\n         MVC   #CSASK,EDIT2        FORMAT\n         ED    #CSASK,DBLEWORD+4   MOVE TO OUTPUT SCREEN\n         L     R3,VRLOW            LOWEST V=R AREA ADDRESS PLUS\n         A     R3,VRSIZE           SIZE OF V=R AREA\n         STCM  R3,B'1111',FIVEBYTE LOWEST PVT AREA ADDRESS\n         UNPK  TENBYTE,FIVEBYTE    UNPACK\n         TR    TENBYTE+1(8),TRTABLE     TRANSLATE\n         MVC   #PVTL,TENBYTE+1     MOVE TO OUTPUT SCREEN\n         L     R3,PVTLOW           LOWEST PVT AREA ADDRESS\n         A     R3,PVTSIZE          SIZE OF PRIVATE AREA\n         BCTR  R3,0                HIGHEST PVT AREA ADDRESS\n         STCM  R3,B'1111',FIVEBYTE\n         UNPK  TENBYTE,FIVEBYTE    UNPACK\n         TR    TENBYTE+1(8),TRTABLE     TRANSLATE\n         MVC   #PVTH,TENBYTE+1     MOVE TO OUTPUT SCREEN\n         XR    R2,R2               CLEAR R2\n         L     R3,PVTSIZE          SIZE OF PRIVATE AREA MINUS\n         S     R3,VRLOW            LOWEST V=R AREA ADDRESS MINUS\n         S     R3,VRSIZE           SIZE OF V=R AREA\n         LR    R0,R3               SAVE FOR COMPUTATION IN K\n         MR    R2,R4               MULTIPLY BY 10\n         DR    R2,R5               THEN DIVIDE BY 1 MEG\n         CVD   R3,DBLEWORD         CONVERT\n         MVC   #PVTSM,EDIT1        FORMAT\n         ED    #PVTSM,DBLEWORD+5   MOVE TO OUTPUT SCREEN\n         SRA   R0,10               SIZE IN K\n         CVD   R0,DBLEWORD         CONVERT\n         MVC   #PVTSK,EDIT2        FORMAT\n         ED    #PVTSK,DBLEWORD+4   MOVE TO OUTPUT SCREEN\n         MVC   FIVEBYTE,VRLOW      LOWEST V=R AREA ADDRESS\n         UNPK  TENBYTE,FIVEBYTE    UNPACK\n         TR    TENBYTE+1(8),TRTABLE     TRANSLATE\n         MVC   #VRAL,TENBYTE+1     MOVE TO OUTPUT SCREEN\n         L     R3,VRLOW            LOWEST V=R AREA ADDRESS\n         A     R3,VRSIZE           SIZE OF V=R AREA\n         BCTR  R3,0                HIGHEST V=R AREA ADDRESS\n         STCM  R3,B'1111',FIVEBYTE\n         UNPK  TENBYTE,FIVEBYTE    UNPACK\n         TR    TENBYTE+1(8),TRTABLE     TRANSLATE\n         MVC   #VRAH,TENBYTE+1     MOVE TO OUTPUT SCREEN\n         XR    R2,R2               CLEAR R2\n         L     R3,VRSIZE           SIZE OF V=R AREA\n         LR    R0,R3               SAVE FOR COMPUTATION IN K\n         MR    R2,R4               MULTIPLY BY 10\n         DR    R2,R5               THEN DIVIDE BY 1 MEG\n         CVD   R3,DBLEWORD         CONVERT\n         MVC   #VRASM,EDIT1        FORMAT\n         ED    #VRASM,DBLEWORD+5   MOVE TO OUTPUT SCREEN\n         SRA   R0,10               SIZE IN K\n         CVD   R0,DBLEWORD         CONVERT\n         MVC   #VRASK,EDIT2        FORMAT\n         ED    #VRASK,DBLEWORD+4   MOVE TO OUTPUT SCREEN\n         L     R3,VRLOW            LOWEST V=R AREA ADDRESS\n         BCTR  R3,0                HIGHEST PSA+SYSTEM ADDRESS\n         STCM  R3,B'1111',FIVEBYTE\n         UNPK  TENBYTE,FIVEBYTE    UNPACK\n         TR    TENBYTE+1(8),TRTABLE     TRANSLATE\n         MVC   #PSSH,TENBYTE+1     MOVE TO OUTPUT SCREEN\n         XR    R2,R2               CLEAR R2\n         L     R3,VRLOW            LOWEST V=R AREA ADDR = PSA+SYSTEM\n         LR    R0,R3               SAVE FOR COMPUTATION IN K\n         MR    R2,R4               MULTIPLY BY 10\n         DR    R2,R5               THEN DIVIDE BY 1 MEG\n         CVD   R3,DBLEWORD         CONVERT\n         MVC   #PSSSM,EDIT1        FORMAT\n         ED    #PSSSM,DBLEWORD+5   MOVE TO OUTPUT SCREEN\n         SRA   R0,10               COMPUTE IT IN K\n         CVD   R0,DBLEWORD         CONVERT\n         MVC   #PSSSK,EDIT2        FORMAT\n         ED    #PSSSK,DBLEWORD+4   MOVE TO OUTPUT SCREEN\n         EJECT\n***********************************************************************\n*        OUTPUT THE SCREEN                                            *\n***********************************************************************\n         SPACE 1\nP000500  LA    R0,#SCREEN          LOAD SCREEN ADDRESS\n         ST    R0,@PUTAREA         SAVE ADDR IN LINKAGE AREA\n         LA    R0,#SCRNLEN         LOAD SCREEN LENGTH\n         ST    R0,@PUTLEN          STORE IN LINKAGE AREA\n         L     R0,=A(HCSCR)        HARDCOPY SCREEN\n        $HCPY  HSA=(R0)              IF NEEDED\n         MVI   @RSPONSE,C' '       MOVE BLANK TO RESPONSE\n         LR    R1,R10              POINT TO LINKAGE\n         L     R15,@IOMOD          LOAD ADDR OF TERMINAL I/O MODULE\n         BASR  R14,R15             GO DO TERMINAL IO\n         CLI   @RSPONSE,C'R'       REFRESH THE SCREEN ? (THIS IS DUMB\n*                                  BECAUSE THE VALUES WON'T CHANGE)\n         BE    P000500             BRANCH IF YES\n         SPACE 1\n        $XRET CC=0                 B O O G I E\n         EJECT\nDBLEWORD DC   D'0'                 DOUBLE WORD WORK AREA\nTENBYTE  DC   XL10'0'\nFIVEBYTE DC   XL5'0'\n         SPACE 1\nPVTELOW  DC    F'0'                LOWEST PVT AREA EXT. ADDRESS\nPVTESIZE DC    F'0'                SIZE OF PRIVATE AREA EXTENDED\nCSAELOW  DC    F'0'                LOWEST CSA AREA EXT. ADDRESS\nCSAESIZE DC    F'0'                SIZE OF CSA AREA EXTENDED\nEMLPE    DC    F'0'                HIGHEST MLPA EXT. ADDRESS\nEFLPS    DC    F'0'                LOWEST FLPA EXT. ADDRESS\nEFLPE    DC    F'0'                HIGHEST FLPA EXT. ADDRESS\nEPLPS    DC    F'0'                LOWEST PLPA EXT. ADDRESS\nEPLPE    DC    F'0'                HIGHEST PLPA EXT. ADDRESS\nSQAELOW  DC    F'0'                LOWEST SQA AREA EXT. ADDRESS\nSQAESIZE DC    F'0'                SIZE OF SQA AREA EXTENDED\nNUCSTR   DC    F'0'                START NUCLEUS ADDRESS\nNUCEND   DC    F'0'                END EXT. NUCLEUS ADDRESS\nSQALOW   DC    F'0'                LOWEST SQA AREA ADDRESS\nSQASIZE  DC    F'0'                SIZE OF SQA AREA\nPLPAS    DC    F'0'                LOWEST PLPA ADDRESS\nPLPAE    DC    F'0'                HIGHEST PLPA ADDRESS\nFLPAS    DC    F'0'                LOWEST FLPA ADDRESS\nFLPAE    DC    F'0'                HIGHEST FLPA ADDRESS\nMLPAS    DC    F'0'                LOWEST MLPA ADDRESS\nCSALOW   DC    F'0'                LOWEST CSA AREA ADDRESS\nCSASIZE  DC    F'0'                SIZE OF CSA AREA\nPVTLOW   DC    F'0'                LOWEST PVT AREA ADDRESS\nPVTSIZE  DC    F'0'                SIZE OF PRIVATE AREA\nVRLOW    DC    F'0'                GLOBAL V=R AREA ADDRESS\nVRSIZE   DC    F'0'                SIZE OF GLOBAL V=R AREA\nCLRL     EQU  *-DBLEWORD\n         SPACE 1\nTRTABLE  DS   0CL256\n         DC   CL240' '\n         DC   CL16'0123456789ABCDEF'\nEDIT1    DC   XL7'40202020214B20'  EDIT PATTERN FOR SIZE IN MEG\nEDIT2    DC   XL8'4020202020202120'     EDIT PATTERN FOR SIZE IN K\n         SPACE 1\n#SCREEN  DS   0F\n         $FS  WCC=(KBR,RMDT),MF=L\n         $FS  SBA=(1,1),RA=(1,1,00),MF=L\n         $FS  SBA=(1,1),SF=(PROT,INT),MF=L\nHCL1     $FS  TEXT='SELECT OPTION =>',MF=L\n         $FS  SF=NORMAL,TEXT=' ',MF=L\n         $FS  SF=(PROT),MF=L\n         $FS  SBA=(3,29),SF=(PROT,INT),MF=L\nHCL3     $FS  TEXT='VIRTUAL STORAGE MAP',MF=L\n         $FS  SF=(PROT),MF=L\n         $FS  SBA=(6,10),MF=L\nHCL6     $FS  TEXT='PRIVATE EXT.  ',MF=L\n#EPVTL   $FS  TEXT=(' ',8),MF=L\n         $FS  TEXT=' - ',MF=L\n#EPVTH   $FS  TEXT=(' ',8),MF=L\n         $FS  TEXT='  SIZE =',MF=L\n#EPVTSM  $FS  TEXT=(' ',7),MF=L\n         $FS  TEXT=' MEG -',MF=L\n#EPVTSK  $FS  TEXT=(' ',8),MF=L\n         $FS  TEXT=' K',MF=L\nHCL6L    EQU  *-HCL6\n         $FS  SBA=(7,14),MF=L\nHCL7     $FS  TEXT='CSA EXT.  ',MF=L\n#ECSAL   $FS  TEXT=(' ',8),MF=L\n         $FS  TEXT=' - ',MF=L\n#ECSAH   $FS  TEXT=(' ',8),MF=L\n         $FS  TEXT='  SIZE =',MF=L\n#ECSASM  $FS  TEXT=(' ',7),MF=L\n         $FS  TEXT=' MEG -',MF=L\n#ECSASK  $FS  TEXT=(' ',8),MF=L\n         $FS  TEXT=' K',MF=L\nHCL7L    EQU  *-HCL7\n         $FS  SBA=(8,8),MF=L\n#TXE     $FS  TEXT=(' ',16),MF=L\n#EFLPAL  $FS  TEXT=(' ',8),MF=L\n         $FS  TEXT=' - ',MF=L\n#EFLPAH  $FS  TEXT=(' ',8),MF=L\n         $FS  TEXT='  SIZE =',MF=L\n#EFLPASM $FS  TEXT=(' ',7),MF=L\n         $FS  TEXT=' MEG -',MF=L\n#EFLPASK $FS  TEXT=(' ',8),MF=L\n         $FS  TEXT=' K',MF=L\nHCL8L    EQU  *-#TXE\n         $FS  SBA=(9,13),MF=L\nHCL9     $FS  TEXT='PLPA EXT.  ',MF=L\n#EPLPAL  $FS  TEXT=(' ',8),MF=L\n         $FS  TEXT=' - ',MF=L\n#EPLPAH  $FS  TEXT=(' ',8),MF=L\n         $FS  TEXT='  SIZE =',MF=L\n#EPLPASM $FS  TEXT=(' ',7),MF=L\n         $FS  TEXT=' MEG -',MF=L\n#EPLPASK $FS  TEXT=(' ',8),MF=L\n         $FS  TEXT=' K',MF=L\nHCL9L    EQU  *-HCL9\n         $FS  SBA=(10,14),MF=L\nHCL10    $FS  TEXT='SQA EXT.  ',MF=L\n#ESQAL   $FS  TEXT=(' ',8),MF=L\n         $FS  TEXT=' - ',MF=L\n#ESQAH   $FS  TEXT=(' ',8),MF=L\n         $FS  TEXT='  SIZE =',MF=L\n#ESQASM  $FS  TEXT=(' ',7),MF=L\n         $FS  TEXT=' MEG -',MF=L\n#ESQASK  $FS  TEXT=(' ',8),MF=L\n         $FS  TEXT=' K',MF=L\nHCL10L   EQU  *-HCL10\n         $FS  SBA=(11,10),MF=L\nHCL11    $FS  TEXT='NUCLEUS EXT.  01000000 - ',MF=L\n#ENUCH   $FS  TEXT=(' ',8),MF=L\n         $FS  TEXT='  SIZE =',MF=L\n#ENUCSM  $FS  TEXT=(' ',7),MF=L\n         $FS  TEXT=' MEG -',MF=L\n#ENUCSK  $FS  TEXT=(' ',8),MF=L\n         $FS  TEXT=' K',MF=L\nHCL11L   EQU  *-HCL11\n         $FS  SBA=(12,11),SF=(PROT,INT),MF=L\nHCL12    $FS  TEXT='16-MB LINE ',MF=L\n         $FS  SF=(PROT),MF=L\n         $FS  RA=(12,74,-),MF=L\n         $FS  SBA=(13,15),MF=L\nHCL13    $FS  TEXT='NUCLEUS  ',MF=L\n#NUCL    $FS  TEXT=(' ',8),MF=L\n         $FS  TEXT=' - 00FFFFFF  SIZE =',MF=L\n#NUCSM   $FS  TEXT=(' ',7),MF=L\n         $FS  TEXT=' MEG -',MF=L\n#NUCSK   $FS  TEXT=(' ',8),MF=L\n         $FS  TEXT=' K',MF=L\nHCL13L   EQU  *-HCL13\n         $FS  SBA=(14,19),MF=L\nHCL14    $FS  TEXT='SQA  ',MF=L\n#SQAL    $FS  TEXT=(' ',8),MF=L\n         $FS  TEXT=' - ',MF=L\n#SQAH    $FS  TEXT=(' ',8),MF=L\n         $FS  TEXT='  SIZE =',MF=L\n#SQASM   $FS  TEXT=(' ',7),MF=L\n         $FS  TEXT=' MEG -',MF=L\n#SQASK   $FS  TEXT=(' ',8),MF=L\n         $FS  TEXT=' K',MF=L\nHCL14L   EQU  *-HCL14\n         $FS  SBA=(15,18),MF=L\nHCL15    $FS  TEXT='PLPA  ',MF=L\n#PLPAL   $FS  TEXT=(' ',8),MF=L\n         $FS  TEXT=' - ',MF=L\n#PLPAH   $FS  TEXT=(' ',8),MF=L\n         $FS  TEXT='  SIZE =',MF=L\n#PLPASM  $FS  TEXT=(' ',7),MF=L\n         $FS  TEXT=' MEG -',MF=L\n#PLPASK  $FS  TEXT=(' ',8),MF=L\n         $FS  TEXT=' K',MF=L\nHCL15L   EQU  *-HCL15\n         $FS  SBA=(16,13),MF=L\n#TX      $FS  TEXT=(' ',11),MF=L\n#FLPAL   $FS  TEXT=(' ',8),MF=L\n         $FS  TEXT=' - ',MF=L\n#FLPAH   $FS  TEXT=(' ',8),MF=L\n         $FS  TEXT='  SIZE =',MF=L\n#FLPASM  $FS  TEXT=(' ',7),MF=L\n         $FS  TEXT=' MEG -',MF=L\n#FLPASK  $FS  TEXT=(' ',8),MF=L\n         $FS  TEXT=' K',MF=L\nHCL16L   EQU  *-#TX\n         $FS  SBA=(17,19),MF=L\nHCL17    $FS  TEXT='CSA  ',MF=L\n#CSAL    $FS  TEXT=(' ',8),MF=L\n         $FS  TEXT=' - ',MF=L\n#CSAH    $FS  TEXT=(' ',8),MF=L\n         $FS  TEXT='  SIZE =',MF=L\n#CSASM   $FS  TEXT=(' ',7),MF=L\n         $FS  TEXT=' MEG -',MF=L\n#CSASK   $FS  TEXT=(' ',8),MF=L\n         $FS  TEXT=' K',MF=L\nHCL17L   EQU  *-HCL17\n         $FS  SBA=(18,11),MF=L\nHCL18    $FS  TEXT='PRIVATE V=V  ',MF=L\n#PVTL    $FS  TEXT=(' ',8),MF=L\n         $FS  TEXT=' - ',MF=L\n#PVTH    $FS  TEXT=(' ',8),MF=L\n         $FS  TEXT='  SIZE =',MF=L\n#PVTSM   $FS  TEXT=(' ',7),MF=L\n         $FS  TEXT=' MEG -',MF=L\n#PVTSK   $FS  TEXT=(' ',8),MF=L\n         $FS  TEXT=' K',MF=L\nHCL18L   EQU  *-HCL18\n         $FS  SBA=(19,11),MF=L\nHCL19    $FS  TEXT='PRIVATE V=R  ',MF=L\n#VRAL    $FS  TEXT=(' ',8),MF=L\n         $FS  TEXT=' - ',MF=L\n#VRAH    $FS  TEXT=(' ',8),MF=L\n         $FS  TEXT='  SIZE =',MF=L\n#VRASM   $FS  TEXT=(' ',7),MF=L\n         $FS  TEXT=' MEG -',MF=L\n#VRASK   $FS  TEXT=(' ',8),MF=L\n         $FS  TEXT=' K',MF=L\nHCL19L   EQU  *-HCL19\n         $FS  SBA=(20,10),MF=L\nHCL20    $FS  TEXT='PSA + SYSTEM  00000000 - ',MF=L\n#PSSH    $FS  TEXT=(' ',8),MF=L\n         $FS  TEXT='  SIZE =',MF=L\n#PSSSM   $FS  TEXT=(' ',7),MF=L\n         $FS  TEXT=' MEG -',MF=L\n#PSSSK   $FS  TEXT=(' ',8),MF=L\n         $FS  TEXT=' K',MF=L\nHCL20L   EQU  *-HCL20\n         $FS  SBA=(1,1),SF=(PT,IC),MF=L\n#SCRNLEN EQU  *-#SCREEN\n         SPACE 2\n         LTORG\n         EJECT\n***********************************************************************\n*                                                                     *\n*        HARDCOPY SCREEN PROCESS                                      *\n*                                                                     *\n*        HERE, WE RECEIVES CONTROL FROM HARDCOPY MODULE WITH THE      *\n*        REGISTERS AS BELOW :                                         *\n*              R2   - '#SCREEN' ADDRESS                               *\n*              R3   - HARDCOPY TARGET LINE ADDRESS (BLANKS            *\n*              R4   - 'HCSCR' ADDRESS                                 *\n*                     INITIALIZED AND LENGTH 80)                      *\n*              R10  - LINKAGE AREA POINTER                            *\n*              R14  - LINKAGE REGISTER                                *\n*                                                                     *\n*        NOTE : DO NOT USE ANY OTHER REGISTER WITHOUT LOOKING IN      *\n*               THE HARDCOPY MODULE FOR HIS AVAILABILITY              *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         DS    0F\n         USING #SCREEN,R2\n         USING *,R4\nHCSCR    B     HCSCR1              LINE 1\n         B     0(R14)              LINE 2\n         B     HCSCR3              LINE 3\n         B     0(R14)              LINE 4\n         B     0(R14)              LINE 5\n         B     HCSCR6              LINE 6\n         B     HCSCR7              LINE 7\n         B     HCSCR8              LINE 8\n         B     HCSCR9              LINE 9\n         B     HCSCR10             LINE 10\n         B     HCSCR11             LINE 11\n         B     HCSCR12             LINE 12\n         B     HCSCR13             LINE 13\n         B     HCSCR14             LINE 14\n         B     HCSCR15             LINE 15\n         B     HCSCR16             LINE 16\n         B     HCSCR17             LINE 17\n         B     HCSCR18             LINE 18\n         B     HCSCR19             LINE 19\n         B     HCSCR20             LINE 20\n         B     0(R14)              LINE 21\n         B     0(R14)              LINE 22\n         B     0(R14)              LINE 23\n         B     0(R14)              LINE 24\n         SPACE 1\nHCSCR1   MVC   2(L'HCL1,R3),HCL1\n         MVC   3+L'HCL1(1,R3),@RSPONSE\n         BR    R14\nHCSCR3   MVC   30(L'HCL3,R3),HCL3\n         BR    R14\nHCSCR6   MVC   10(HCL6L,R3),HCL6\n         BR    R14\nHCSCR7   MVC   14(HCL7L,R3),HCL7\n         BR    R14\nHCSCR8   MVC   8(HCL8L,R3),#TXE\n         BR    R14\nHCSCR9   MVC   13(HCL9L,R3),HCL9\n         BR    R14\nHCSCR10  MVC   14(HCL10L,R3),HCL10\n         BR    R14\nHCSCR11  MVC   10(HCL11L,R3),HCL11\n         BR    R14\nHCSCR12  MVC   12(L'HCL12,R3),HCL12\n         MVI   13+L'HCL12(R3),C'-'\n         MVC   14+L'HCL12(49,R3),13+L'HCL12(R3)\n         BR    R14\nHCSCR13  MVC   15(HCL13L,R3),HCL13\n         BR    R14\nHCSCR14  MVC   19(HCL14L,R3),HCL14\n         BR    R14\nHCSCR15  MVC   18(HCL15L,R3),HCL15\n         BR    R14\nHCSCR16  MVC   13(HCL16L,R3),#TX\n         BR    R14\nHCSCR17  MVC   19(HCL17L,R3),HCL17\n         BR    R14\nHCSCR18  MVC   11(HCL18L,R3),HCL18\n         BR    R14\nHCSCR19  MVC   11(HCL19L,R3),HCL19\n         BR    R14\nHCSCR20  MVC   10(HCL20L,R3),HCL20\n         BR    R14\n         SPACE 1\n         DROP  R2,R4\n         EJECT\n         $GDA  G=NO                GENERAL DATA AREA DSECT\nGDAEND   EQU   *                   NOT SUPPLIED IN IHAGDA MACRO\n         SPACE 2\n         $LNKSECT                  LINKAGE AREA DSECT\n         SPACE 2\n         PRINT NOGEN\n         CVT   DSECT=YES,LIST=YES\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "VSM00200": {"ttr": 19715, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x882?\\x00\\x882?\\x144\\x03V\\x03V\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-11-18T00:00:00", "modifydate": "1988-11-18T14:34:00", "lines": 854, "newlines": 854, "modlines": 0, "user": "SYSPAJA"}, "text": "V200     TITLE 'VSM00200 - SQA/CSA SUBPOOL MONITOR.'\n         PRINT OFF\n         COPY  VSMMAC\n         PRINT ON\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*    MODULE :           VSM00200 (MVS/XA)                             *\n*                       VERSION : 1.0                                 *\n*                       DATE : 12 NOV 1986                            *\n*                       NAME : SQA/CSA SUBPOOL MONITOR                *\n*                       ATTRIBUTES : REUS                             *\n*                                                                     *\n*    AUTHOR :           MOINIL P.A. - COMPUTING CENTRE                *\n*                       J.R.C. - ISPRA ESTABLISHMENT                  *\n*                       21020 ISPRA (VA), ITALY                       *\n*                                                                     *\n*    FUNCTION :         THIS MODULE WILL SHOW SUBPOOL UTILIZATION     *\n*                       IN CSA AND IN SQA. IT SHOWS THE AMOUNT OF     *\n*                       FREE OR UNALLOCATED SPACE IN EACH SUBPOOL,    *\n*                       THE LARGEST CONTIGUOUS FREE SPACE AND THE     *\n*                       PERCENTAGE FREE OR UNUSED.                    *\n*                                                                     *\n*    REGS AT INPUT :    R1   - INTER MODULE LINKAGE                   *\n*                       R14  - RETURN ADDRESS                         *\n*                       R15  - EPA                                    *\n*                                                                     *\n*    REGS USAGE :       R0   - WORK REGISTER                          *\n*                       R1   - POINTER TO INTER MODULE LINKAGE        *\n*                       R2-R5 - WORK REGISTERS                        *\n*                       R6   - WORK AREA POINTER (VSMLIST)            *\n*                       R7   - WORK AREA SIZE (VSMLIST)               *\n*                       R8   - WORK REGISTER                          *\n*                       R9   - INTERNAL LINKAGE REGISTER              *\n*                       R10  - LINKAGE AREA POINTER                   *\n*                       R11  - BASE REGISTER                          *\n*                       R12  - 2ND BASE REGISTER (RESERVED)           *\n*                       R13  - SAVE AREA POINTER                      *\n*                       R14  - LINKAGE REGISTER                       *\n*                       R15  - ADDRESS OF CALLED MODULES              *\n*                                                                     *\n*    REGS AT EXIT :     R14  - RETURN ADDRESS                         *\n*                                                                     *\n*    LABELS :           SOME OF THE FIELD USAGE IN THIS MODULE CAN    *\n*                       BE DETERMINED BY THE FIRST CHARACTER OF THE   *\n*                       FIELD. THE KEYS ARE :                         *\n*                            @ - THE FIELD IS IN THE INTER MODULE     *\n*                                LINKAGE AREA                         *\n*                            # - FIELD IS PART OF THE OUTPUT SCREEN   *\n*                            $ - DSECT                                *\n*                                                                     *\n***********************************************************************\n         EJECT\nVSM00200 START 0\n         SPACE 1\n        $DEFREG ,\n***********************************************************************\n*        STANDARD OS LINKAGE                                          *\n***********************************************************************\n         SPACE 1\n        $XENT  BASE=R11            SAVE CALLER'S REGS\n         EJECT\n***********************************************************************\n*        INITIALIZATION                                               *\n***********************************************************************\n         SPACE 1\n         MVI   SW16M,0             RESET\n         LR    R10,R1              LOAD INTER MOD LNKG ADDR R10\n         USING $LNKSECT,R10        DSECT ADDRESSABILITY\nP000100  MVI   DBLEWORD,0          CLEAR WORK AREA WITH ZEROS\n         MVC   DBLEWORD+1(CLRL-1),DBLEWORD\n         L     R1,=A(WCELLS)       RESET SP COLLECT DATA AREAS\n         XC    0(WSPL,R1),0(R1)\n         TM    SW16M,UP16M\n         BO    *+L'*+8\n         MVI   #S16M,C'<'\n         B     *+L'*+4\n         MVI   #S16M,C'>'\n         MVI   #SQATHRS,C' '\n         MVC   #SQATHRS+1(L'#SQATHRS-1),#SQATHRS\n         MVC   #SQAOVFA(L'#SQAOVFA),#SQATHRS\n         MVC   #SQAOVFX(L'#SQAOVFX),#SQATHRS\n         MVC   #SQAOVFB(L'#SQAOVFB),#SQATHRS\n         MVC   #ALTM01(L'#ALTM01),#SQATHRS\n         MVC   #ALTM02(L'#ALTM02),#SQATHRS\n         LM    R6,R7,@WAADD        SET WORK AREA POINTER/SIZE\n         L     R4,@GDA             GDA POINTER\n         USING GDA,R4              GDA DSECT ADDRESSABILITY\n         TM    GDAFLGS,GDALOW1+GDALOW2  ANY PROBLEMS ?\n         BZ    P000120             NO\n         TM    GDAFLGS,GDALOW1     THRESHOLD 1 ?\n         BZ    P000110             IF NO, MUST BE THRESHOLD 2\n         MVC   #SQATHRS,MSG1       MOVE THRESHOLD 1 MSG TO OUTPUT SCR\nP000110  MVC   #SQATHRS,MSG2       MOVE THRESHOLD 2 MSG TO OUTPUT SCR\nP000120  MVC   SQASIZE,GDASQASZ    SQA AREA SIZE\n         MVC   SQAESIZE,GDAESQAS   SQA AREA EXTENDED SIZE\n         MVC   CSASIZE,GDACSASZ    CSA AREA SIZE\n         MVC   CSAESIZE,GDAECSAS   CSA AREA EXTENDED SIZE\n         DROP  R4                  DROP GDA ADDRESSABILITY\n         EJECT\n***********************************************************************\n*        SQA - GET VSM DATA                                           *\n***********************************************************************\n         SPACE 1\n         MVC   #ALTM03,=CL3'SQA'\n         LR    R2,R6               CLEAR\n         LR    R3,R7                 VSMLIST\n         LR    R4,R6                   WORK AREA\n         XR    R5,R5                     WITH\n         MVCL  R2,R4                       ZEROS\n        VSMLIST SP=SQA,SPACE=FREE,WKAREA=((R6),(R7))\n         LTR   R15,R15             SUCCESSFULLY EXECUTED ?\n         BNZ   ERRG                NO, ERROR\n         BAS   R9,WKSNAP           TAKE W.A. SNAP IF NEEDED\n         EJECT\n***********************************************************************\n*        SQA - COLLECT DATA FROM VSM                                  *\n***********************************************************************\n         SPACE 1\n         L     R3,4(R6)            GET ADDRESS OF DATA\n         L     R5,8(R6)            GET LENGTH OF DATA\n         AR    R5,R3               END OF DATA+1 ADDRESS\n         L     R8,0(R3)            GET NUMBER OF SUBPOOLS\n         LTR   R8,R8               NONE ?\n         BNP   ERRN                YES\n         LA    R3,4(R3)            BUMP CURRENT POINTER,\nP000200  CLR   R3,R5                 TEST IF OVERFLOW,\n         BNL   ERR0                    AND BRANCH IF YES, ERROR\n         BAS   R9,SDLOOP           DO A SUBPOOL COMPUTATIONS\n         BCT   R8,P000200          LOOP IF MORE SUBPOOLS\n         CLR   R3,R5               DATA EXHAUSTED ?\n         BNE   ERRD                BRANCH IF NOT, ERROR\n         EJECT\n***********************************************************************\n*        CSA - GET VSM DATA                                           *\n***********************************************************************\n         SPACE 1\n         MVC   #ALTM03,=CL3'CSA'\n         OI    SWPRC,PRCCSA\n         LR    R2,R6               CLEAR\n         LR    R3,R7                 VSMLIST\n         LR    R4,R6                   WORK AREA\n         XR    R5,R5                     WITH\n         MVCL  R2,R4                       ZEROS\n        VSMLIST SP=CSA,SPACE=FREE,WKAREA=((R6),(R7))\n         LTR   R15,R15             SUCCESSFULLY EXECUTED ?\n         BNZ   ERRG                NO, ERROR\n         BAS   R9,WKSNAP           TAKE W.A. SNAP IF NEEDED\n         EJECT\n***********************************************************************\n*        CSA - COLLECT DATA FROM VSM                                  *\n***********************************************************************\n         SPACE 1\n         L     R3,4(R6)            GET ADDRESS OF DATA\n         L     R5,8(R6)            GET LENGTH OF DATA\n         AR    R5,R3               END OF DATA+1 ADDRESS\n         L     R8,0(R3)            GET NUMBER OF SUBPOOLS\n         LTR   R8,R8               NONE ?\n         BNP   ERRN                YES\n         LA    R3,4(R3)            BUMP CURRENT POINTER,\nP000300  CLR   R3,R5                 TEST IF OVERFLOW,\n         BNL   ERR0                    AND BRANCH IF YES, ERROR\n         BAS   R9,SDLOOP           DO A SUBPOOL COMPUTATIONS\n         BCT   R8,P000300          LOOP IF MORE SUBPOOLS\n         CLR   R3,R5               DATA EXHAUSTED ?\n         BNE   ERRD                BRANCH IF NOT, ERROR\n         EJECT\n***********************************************************************\n*        SQA - DO THE CALCULATIONS AND FORMAT DATA TO BE OUTPUT       *\n***********************************************************************\n         SPACE 1\n         XC    TOTSIZE(TOTL),TOTSIZE    RESET\n         L     R5,=A(SPSQA)        START OF SQA SUBPOOLS\n         LA    R8,SPSQAN           NUMBER OF SQA SUBPOOLS\nP000400  BAS   R9,SPEDIT           FORMAT SUBPOOL OUTPUT DATA\n         BAS   R9,SPTOTL           COMPUTE SQA SUBPOOLS TOTAL\n         LA    R5,L'SPTAB(R5)      POINT TO NEXT\n         BCT   R8,P000400          LOOP IF MORE SUBPOOLS IN SQA\n         TM    SW16M,UP16M         SET GLOBAL SQA VALUES\n         BO    *+L'*+8\n         L     R0,SQASIZE\n         B     *+L'*+4\n         L     R0,SQAESIZE\n         C     R0,TOTSIZE\n         BL    P000410\n         BE    P000420\n         LR    R1,R0\n         S     R1,TOTSIZE\n         ST    R0,TOTSIZE\n         A     R1,TOTFREE\n         ST    R1,TOTFREE\n         MVI   TOTLARGE,X'FF'\n         B     P000420\nP000410  MVC   #SQAOVFA,MSG3A      SQA OVERFLOWS INTO CSA\n         MVC   #SQAOVFB,MSG3B\n         L     R1,TOTSIZE\n         SR    R1,R0\n         ST    R1,OVERFLOW\n         SRA   R1,10               DIVIDE BY 1024 TO HAVE IN K\n         CVD   R1,DBLEWORD         CONVERT\n         MVC   #SQAOVFX,EDIT2        AND\n         ED    #SQAOVFX,DBLEWORD+4     EDIT\nP000420  LA    R3,#SQALINE\n         LA    R4,TOTSIZE\n         BAS   R9,GLEDIT           EDIT SQA TOTAL\n         EJECT\n***********************************************************************\n*        CSA - DO THE CALCULATIONS AND FORMAT DATA TO BE OUTPUT       *\n***********************************************************************\n         SPACE 1\n         XC    TOTSIZE(TOTL),TOTSIZE    RESET\n         L     R5,=A(SPCSA)        START OF CSA SUBPOOLS\n         LA    R8,SPCSAN           NUMBER OF CSA SUBPOOLS\nP000500  BAS   R9,SPEDIT           FORMAT SUBPOOL OUTPUT DATA\n         BAS   R9,SPTOTL           COMPUTE CSA SUBPOOLS TOTAL\n         LA    R5,L'SPTAB(R5)      POINT TO NEXT\n         BCT   R8,P000500          LOOP IF MORE SUBPOOLS IN CSA\n         TM    SW16M,UP16M         SET GLOBAL CSA VALUES\n         BO    *+L'*+8\n         L     R0,CSASIZE\n         B     *+L'*+4\n         L     R0,CSAESIZE\n         C     R0,TOTSIZE\n         BE    P000510\n         LR    R1,R0\n         S     R1,TOTSIZE\n         A     R1,TOTFREE\n         ST    R1,TOTFREE\n         MVI   TOTLARGE,X'FF'\nP000510  S     R0,OVERFLOW\n         ST    R0,TOTSIZE\n         LA    R3,#CSALINE\n         LA    R4,TOTSIZE\n         BAS   R9,GLEDIT           EDIT CSA TOTAL\n         EJECT\n***********************************************************************\n*        OUTPUT THE SCREEN                                            *\n***********************************************************************\n         SPACE 1\n         LA    R0,#SCREEN          LOAD SCREEN ADDR\n         ST    R0,@PUTAREA         STORE IN LINKAGE AREA\n         LA    R0,#SCRNLEN         LOAD SCREEN LENGTH\n         ST    R0,@PUTLEN          STORE IN LINKAGE AREA\n         L     R0,=A(HCSCR)        HARDCOPY SCREEN                 -EU-\n        $HCPY  HSA=(R0)              IF NEEDED                     -EU-\nP000900  MVI   @RSPONSE,C' '       MOVE BLANK TO RESPONSE\n         LR    R1,R10              POINT R1 TO LINKAGE AREA\n         L     R15,@IOMOD          LOAD ADDRESS OF TERMINAL I/O MOD\n         BASR  R14,R15             GO DO TERMINAL IO\n         CLI   @RSPONSE,C'R'       REFRESH SCREEN ?\n         BNE   *+L'*+8             BRANCH IF NOT\n         XI    SW16M,UP16M         FLIP/FLOP BETWEEN LOW/UP 16 MB LINE\n         B     P000100\n        $XRET  CC=0                B O O G I E\n         EJECT\n***********************************************************************\n*        ERRORS DIAGNOSE                                              *\n***********************************************************************\n         SPACE 1\nERRG     MVC   #ALTM01,=CL16'VSMLIST REG 15 :'\n         CH    R15,=H'4'           ALL INFORMATION NOT RECEIVED R.C. ?\n         BNE   *+L'*+10            NO\n         MVC   #ALTM02,=CL8'4 - W.A.'   YES, WORK AREA IS TOO SMALL\n         B     ERRSV\n         STCM  R15,B'1111',FIVEBYTE     NO, DISPLAY R.C.\n         UNPK  TENBYTE,FIVEBYTE\n         TR    TENBYTE+1(8),TRTABLE\n         MVC   #ALTM02,TENBYTE+1\n         B     ERRSV\nERRS     MVC   #ALTM01,=CL16'UNDEF. SUBPOOL :'\n         STM   R0,R15,SVREGS\n         XR    R0,R0\n         USING SDF,R3\n         IC    R0,SDFID            SUBPOOL ID NUMBER\n         DROP  R3\n         CVD   R0,DBLEWORD\n         MVC   #ALTM02+L'#ALTM02-L'EDIT1(L'EDIT1),EDIT1\n         ED    #ALTM02+L'#ALTM02-L'EDIT1(L'EDIT1),DBLEWORD+6\n         B     ERRDIAG\nERR0     MVI   #ALTM02+6,C'0'\n         B     ERRMSG\nERR1     MVI   #ALTM02+6,C'1'\n         B     ERRMSG\nERR2     MVI   #ALTM02+6,C'2'\n         B     ERRMSG\nERR3     MVI   #ALTM02+6,C'3'\n         B     ERRMSG\nERR4     MVI   #ALTM02+6,C'4'\n         B     ERRMSG\nERRD     MVI   #ALTM02+6,C'D'\n         B     ERRMSG\nERRN     MVI   #ALTM02+6,C'N'\n         B     ERRMSG\nERRIS    MVC   #ALTM02+6(2),=CL2'IS'\nERRMSG   MVC   #ALTM02(5),=CL5'ERROR'\nERRSV    STM   R0,R15,SVREGS\nERRDIAG  LA    R1,SVREGS           BUILD\n         ST    R1,@SNPLST            REGISTERS AT\n         LA    R1,16*4-1(R1)           TIME OF ERROR\n         ST    R1,@SNPLST+4              SNAP\n         OI    @SNPLST+4,X'80'             LIST\n        $SNAP  ID=0                ID-NUMBER - - - - - - - - - - - 000\n         TM    @SWITCH,@SNPFNA     SNAP INACTIVE ?\n         BZ    *+L'*+10            NO\n         MVC   #ALTM04,MSGE1       YES\n         B     *+L'*+10\n         BAS   R9,WKSNAP           TAKE W.A. SNAP\n         MVC   #ALTM04,MSGE2\n         MVC   #A16M,#S16M\n         LA    R0,#ALTSCR          LOAD ALTERNATE SCREEN ADDR\n         ST    R0,@PUTAREA         STORE IN LINKAGE AREA\n         LA    R0,#ALTSCRL         LOAD ALTERNATE SCREEN LENGTH\n         ST    R0,@PUTLEN          STORE IN LINKAGE AREA\n         B     P000900\n         EJECT\n***********************************************************************\n*                                                                     *\n* ===> SDLOOP <===                                                    *\n*                                                                     *\n*        COLLECT VSM DATA OF A SUBPOOL                                *\n*                                                                     *\n*        REGISTERS AT ENTRY IN THIS SUBROUTINE                        *\n*                                                                     *\n*        R3 =>   POINT TO SUBPOOL DESCRIPTOR                          *\n*        R5 =>   END OF DATA ADDRESS                                  *\n*        R9 =>   RETURN ADDRESS                                       *\n*                                                                     *\n*        REGISTERS USAGE FOR THIS SUBROUTINE                          *\n*                                                                     *\n*        R0 =>   TEMPORARY WORK REGISTER                              *\n*        R1 =>   SUB-POOL FREE SPACE ACCUMULATOR                      *\n*        R2 =>   NUMBER OF ALLOCATED BLOCKS                           *\n*        R3 =>   DATA CURRENT POINTER                                 *\n*        R4 =>   NUMBER OF FREE SPACE DESCRIPTORS                     *\n*        R14 =>  SUB-POOL WORK CELLS POINTER                          *\n*        R15 =>  SUB-POOL ALLOCATED SPACE ACCUMULATOR                 *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         USING SDF,R3\nSDLOOP   CLI   SDFIS,X'00'         SUBPOOL DESCRIPTOR IDENTIFIER ?\n         BNE   ERRIS\n         LA    R0,SPTABN           SCAN SUBPOOLS TABLE\n         L     R1,=A(SPTAB)\nSDLOOP1  CLC   0(1,R1),SDFID       THIS SUBPOOL ID NUMBER ?\n         BE    SDLOOP2             YES\n         LA    R1,L'SPTAB(R1)\n         BCT   R0,SDLOOP1\n         B     ERRS                UNKNOWN SUBPOOL\nSDLOOP2  L     R14,4(R1)           GET SP WORK CELLS ADDRESS\n         L     R15,0(R14)          ALLOCATED SPACE ACCUMULATOR\n         L     R1,4(R14)           FREE SPACE ACCUMULATOR\n         XR    R0,R0\n         IC    R0,SDFLG            LENGTH OF SUBPOOL DESCRIPTOR\n         DROP  R3\n         AR    R3,R0               BUMP CURRENT PTR\n         CLR   R3,R5               TEST IF DATA OVERFLOW\n         BNL   ERR1                BRANCH IF YES, ERROR\n         ICM   R2,B'1111',0(R3)    GET NUMBER OF ALLOCATED BLOCKS\n         LA    R3,4(R3)            BUMP CURRENT POINTER\n         LTR   R2,R2               HOW MANY ALLOCATED BLOCKS ?\n         BNPR  R9                  RETURN IF NONE\nSDLOOP3  CLR   R3,R5               TEST IF DATA OVERFLOW\n         BNL   ERR2                BRANCH IF YES, ERROR\n         USING AFUF,R3\n         NI    SW16M,255-SKACC\n         ICM   R4,B'1111',AFUFVA   VIRTUAL ADDRESS OF ALLOC. BLOCK\n         LA    R4,0(R4)\n         TM    SW16M,UP16M\n         BO    SDLOOP5\n         CL    R4,=A(16*1024*1024)\n         BL    SDLOOP6\nSDLOOP4  OI    SW16M,SKACC\n         B     SDLOOP7\nSDLOOP5  CL    R4,=A(16*1024*1024)\n         BL    SDLOOP4\nSDLOOP6  ICM   R0,B'1111',AFUFLG   LENGTH OF ALLOCATED BLOCK\n         AR    R15,R0\n         DROP  R3\nSDLOOP7  LA    R3,LAFUF(R3)        BUMP CURRENT POINTER,\n         CLR   R3,R5               TEST IF OVERFLOW\n         BNL   ERR3                BRANCH IF YES, ERROR\n         ICM   R4,B'1111',0(R3)    GET NUMBER OF FREE SPACE DESC.\n         LA    R3,4(R3)            BUMP CURRENT POINTER\n         LTR   R4,R4               HOW MANY FREE SPACE DESC. ?\n         BNP   SDLOOP10            BRANCH IF NONE\nSDLOOP8  CLR   R3,R5               TEST IF DATA OVERFLOW\n         BNL   ERR4                BRANCH IF YES, ERROR\n         TM    SW16M,SKACC\n         BO    SDLOOP9\n         USING AFUF,R3\n         ICM   R0,B'1111',AFUFLG   LENGTH OF FREE SPACE\n         AR    R1,R0\n         DROP  R3\n         C     R0,8(R14)           COLLECT\n         BNH   *+L'*+4               THE LARGEST\n         ST    R0,8(R14)               FREE SPACE\nSDLOOP9  LA    R3,LAFUF(R3)        BUMP CURRENT POINTER\n         BCT   R4,SDLOOP8          LOOP IF MORE FREE SPACE DESC.\nSDLOOP10 BCT   R2,SDLOOP3          LOOP IF MORE ALLOCATED BLOCKS\n         ST    R15,0(R14)          SUBPOOL SIZE\n         ST    R1,4(R14)           FREE SPACE\n         BR    R9                  RETURN\n         EJECT\n***********************************************************************\n*                                                                     *\n* ===> SPEDIT / GLEDIT <===                                           *\n*                                                                     *\n*        FORMAT SUBPOOL / TOTAL COMPUTATIONS DATA                     *\n*                                                                     *\n*        REGISTERS AT ENTRY IN THIS SUBROUTINE                        *\n*                                                                     *\n*        R3 =>   SCREEN OUTPUT LINE ADDRESS ---> GLEDIT               *\n*        R4 =>   TOTAL WORK CELLS POINTER ---> GLEDIT                 *\n*        R5 =>   SUBPOOL TABLE POINTER ---> SPEDIT                    *\n*        R9 =>   RETURN ADDRESS                                       *\n*                                                                     *\n*        REGISTERS USAGE FOR THIS SUBROUTINE                          *\n*                                                                     *\n*        R0 =>   TEMPORARY WORK REGISTER                              *\n*        R1 =>   TEMPORARY WORK REGISTER                              *\n*        R2 =>   TEMPORARY WORK REGISTER                              *\n*        R3 =>   SCREEN OUTPUT LINE ADDRESS                           *\n*        R4 =>   SUBPOLL WORK CELLS POINTER                           *\n*        R15 =>  TEMPORARY WORK REGISTER                              *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nSPEDIT   XR    R3,R3\n         ICM   R3,B'0111',1(R5)    SCREEN OUTPUT LINE ADDRESS\n         L     R4,4(R5)            SUBPOOL DATA CELLS\n         USING $WRKSECT,R3\n         XR    R0,R0\n         IC    R0,0(R5)            SUBPOOL ID NUMBER\n         CVD   R0,DBLEWORD         CONVERT\n         MVC   $WRKNUMB,EDIT1        AND\n         ED    $WRKNUMB,DBLEWORD+6     EDIT\nGLEDIT   L     R0,0(R4)            SUBPOOL SIZE\n         LR    R15,R0\n         SRA   R0,10               DIVIDE BY 1024 TO HAVE IN K\n         CVD   R0,DBLEWORD         CONVERT\n         MVC   $WRKSIZE,EDIT2        AND\n         ED    $WRKSIZE,DBLEWORD+4     EDIT\n         L     R0,4(R4)            SUBPOOL FREE SPACE\n         LR    R1,R0\n         SRA   R0,10               DIVIDE BY 1024 TO HAVE IN K\n         CVD   R0,DBLEWORD         CONVERT\n         MVC   $WRKFREE,EDIT2        AND\n         ED    $WRKFREE,DBLEWORD+4     EDIT\n         CLI   8(R4),X'FF'\n         BNE   SETLFS\n         MVI   $WRKLRGE,C' '\n         MVC   $WRKLRGE+1(L'$WRKLRGE-1),$WRKLRGE\n         B     NOLFS\nSETLFS   L     R0,8(R4)            SUBPOOL LARGEST FREE SPACE\n         SRA   R0,10               DIVIDE BY 1024 TO HAVE IN K\n         CVD   R0,DBLEWORD         CONVERT\n         MVC   $WRKLRGE,EDIT2        AND\n         ED    $WRKLRGE,DBLEWORD+4     EDIT\nNOLFS    XR    R0,R0               SUBPOOL FREE PERCENTAGE\n         LA    R2,1000             SET R2 TO 1000\n         MR    R0,R2               MULTIPLY FREE SPACE BY 1000\n         CLR   R1,R15              PERCENT CAN BE DONE ?\n         BNH   *+L'*+6             BRANCH IF NOT\n         DR    R0,R15              COMPUTE PERCENT FREE WITH\n         B     *+L'*+2               ONE DIGIT AFTER DECIMAL POINT\n         XR    R1,R1               SET ZERO PERCENT\n         CVD   R1,DBLEWORD         CONVERT\n         MVC   $WRKPCT,EDIT3         AND\n         ED    $WRKPCT,DBLEWORD+6      EDIT\n         DROP  R3\n         BR    R9                  RETURN\n         EJECT\n***********************************************************************\n*                                                                     *\n* ===> SPTOTL <===                                                    *\n*                                                                     *\n*        COMPUTE SUBPOOLS TOTAL                                       *\n*                                                                     *\n*        REGISTERS AT ENTRY IN THIS SUBROUTINE                        *\n*                                                                     *\n*        R4 =>   SUBPOLL WORK CELLS POINTER                           *\n*        R9 =>   RETURN ADDRESS                                       *\n*                                                                     *\n*        REGISTERS USAGE FOR THIS SUBROUTINE                          *\n*                                                                     *\n*        R0 =>   TEMPORARY WORK REGISTER                              *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nSPTOTL   L     R0,0(R4)            COMPUTE\n         A     R0,TOTSIZE            TOTAL\n         ST    R0,TOTSIZE              SIZE\n         L     R0,4(R4)            COMPUTE\n         A     R0,TOTFREE            TOTAL\n         ST    R0,TOTFREE              FREE SPACE\n         CLC   8(4,R4),TOTLARGE    RETAIN THE LARGEST\n         BNHR  R9                    FREE SPACE\n         MVC   TOTLARGE(4),8(R4)       OF TOTAL\n         BR    R9                  RETURN\n         EJECT\n***********************************************************************\n*                                                                     *\n* ===> WKSNAP <===                                                    *\n*                                                                     *\n*        WORK AREA SNAP                                               *\n*                                                                     *\n*        REGISTERS USAGE FOR THIS SUBROUTINE                          *\n*                                                                     *\n*        R1 =>   TEMPORARY WORK REGISTER                              *\n*        R9 =>   RETURN ADDRESS                                       *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nWKSNAP   ST    R6,@SNPLST          BUILD\n         LR    R1,R6                 VSMLIST\n         BCTR  R1,0                    WORK\n         AR    R1,R7                     AREA\n         ST    R1,@SNPLST+4                SNAP\n         OI    @SNPLST+4,X'80'               LIST\n         TM    SWPRC,PRCCSA        SET ID-NUMBER\n         BO    *+L'*+8\n         LA    R0,2                2 = SQA\n         B     *+L'*+4\n         LA    R0,3                3 = CSA\n        $SNAP  ID=(R0)             ID-NUMBER - - - - - - - - 002 - 003\n         BR    R9                  RETURN\n         EJECT\nDBLEWORD DC    D'0'                DOUBLE WORD WORK AREA\nOVERFLOW DC    F'0'                SQA SPACE INTO CSA\nTENBYTE  DC    XL10'0'\nFIVEBYTE DC    XL5'0'\nSWPRC    DC    XL1'0'         PROCESSING FLAGS\nPRCCSA   EQU   X'01'               PROCESS CSA\nCLRL     EQU   *-DBLEWORD          LENGTH FOR CLEAR\n         SPACE 1\nTOTSIZE  DC    F'0'                WORK AREA FOR TOTAL SIZE\nTOTFREE  DC    F'0'                WORK AREA FOR TOTAL FREE SPACE\nTOTLARGE DC    F'0'                WORK AREA FOR LARGEST OF TOTAL\nTOTL     EQU   *-TOTSIZE           LENGTH FOR CLEAR\n         SPACE 1\nSQASIZE  DC    F'0'                SIZE OF SQA AREA\nSQAESIZE DC    F'0'                SIZE OF SQA AREA EXTENDED\nCSASIZE  DC    F'0'                SIZE OF CSA AREA\nCSAESIZE DC    F'0'                SIZE OF CSA AREA EXTENDED\nSVREGS   DC    16F'0'              SAVE REGS 0-15\nTRTABLE  DS    0CL256\n         DC    CL240' '\n         DC    CL16'0123456789ABCDEF'\nMSG1     DC    C'===> COMMON AREA FREE SPACE THRESHOLD 1 <==='\nMSG2     DC    C'===> COMMON AREA FREE SPACE THRESHOLD 2 <==='\nMSG3A    DC    C'===> SQA OVERFLOWING INTO CSA :'\nMSG3B    DC    C' K <==='\nMSGE1    DC    C'===> ALLOCATE A FILE \"SYSSNAP\" FOR MORE DETAILS.'\nMSGE2    DC    C'===> SEE TO FILE \"SYSSNAP\" FOR MORE DETAILS.    '\nEDIT1    DC    XL4'40202120'       EDIT PATTERN FOR ID NUMBER\nEDIT2    DC    XL8'4020202020202120'    EDIT PATTERN FOR SIZE IN K\nEDIT3    DC    XL5'4020214B20'     EDIT PATTERN FOR PERCENT\nSW16M    DC    XL1'0'         16 MB PROCESS FLAGS\nUP16M    EQU   X'01'               PROCESS UP 16 MB LINE\nSKACC    EQU   X'02'               SKIP ACCOUNT\n         SPACE 1\n#SCREEN  DS    0F\n         $FS   WCC=(KBR,RMDT),MF=L\n         $FS   SBA=(1,1),RA=(1,1,00),MF=L\n         $FS   SBA=(1,1),SF=(PROT,INT),MF=L\nHCL1     $FS   TEXT='SELECT OPTION =>',MF=L\n         $FS   SF=NORMAL,TEXT=' ',MF=L\n         $FS   SF=(PROT),MF=L\n         $FS   SBA=(3,23),SF=(PROT,INT),MF=L\nHCL3     $FS   TEXT='SQA/CSA UTILIZATION : ',MF=L\n#S16M    $FS   TEXT=' ',MF=L\n         $FS   TEXT=' 16MB-LINE',MF=L\nHCL3L    EQU   *-HCL3\n         $FS   SF=(PROT),MF=L\n         $FS   SBA=(5,34),MF=L\nHCL5     $FS   TEXT='UNAL OR       LARGEST       % UNAL',MF=L\n         $FS   SBA=(6,14),MF=L\nHCL6     $FS   TEXT='ID         SIZE     FREE SP     ',MF=L\n         $FS   TEXT='UNAL/FREE      OR FREE',MF=L\nHCL6L    EQU   *-HCL6\n         $FS   SBA=(8,13),MF=L\nHCL8     $FS   TEXT='SQA  ',MF=L\n#SQALINE EQU   *-4\n         $FS   TEXT=(' ',11),MF=L\n         $FS   TEXT=' K  ',MF=L\n         $FS   TEXT=(' ',8),MF=L\n         $FS   TEXT=' K    ',MF=L\n         $FS   TEXT=(' ',8),MF=L\n         $FS   TEXT=' K      ',MF=L\n         $FS   TEXT=(' ',5),MF=L\nHCL8L    EQU   *-HCL8\n         $FS   SBA=(9,11),MF=L\nHCL9     $FS   TEXT='SP ',MF=L\n#226LINE $FS   TEXT=(' ',4),MF=L\n         $FS   TEXT=(' ',3),MF=L\n         $FS   TEXT=(' ',8),MF=L\n         $FS   TEXT=' K  ',MF=L\n         $FS   TEXT=(' ',8),MF=L\n         $FS   TEXT=' K    ',MF=L\n         $FS   TEXT=(' ',8),MF=L\n         $FS   TEXT=' K      ',MF=L\n         $FS   TEXT=(' ',5),MF=L\nHCL9L    EQU   *-HCL9\n         $FS   SBA=(10,11),MF=L\nHCL10    $FS   TEXT='SP ',MF=L\n#239LINE $FS   TEXT=(' ',4),MF=L\n         $FS   TEXT=(' ',3),MF=L\n         $FS   TEXT=(' ',8),MF=L\n         $FS   TEXT=' K  ',MF=L\n         $FS   TEXT=(' ',8),MF=L\n         $FS   TEXT=' K    ',MF=L\n         $FS   TEXT=(' ',8),MF=L\n         $FS   TEXT=' K      ',MF=L\n         $FS   TEXT=(' ',5),MF=L\nHCL10L   EQU   *-HCL10\n         $FS   SBA=(11,11),MF=L\nHCL11    $FS   TEXT='SP ',MF=L\n#245LINE $FS   TEXT=(' ',4),MF=L\n         $FS   TEXT=(' ',3),MF=L\n         $FS   TEXT=(' ',8),MF=L\n         $FS   TEXT=' K  ',MF=L\n         $FS   TEXT=(' ',8),MF=L\n         $FS   TEXT=' K    ',MF=L\n         $FS   TEXT=(' ',8),MF=L\n         $FS   TEXT=' K      ',MF=L\n         $FS   TEXT=(' ',5),MF=L\nHCL11L   EQU   *-HCL11\n         $FS   SBA=(12,11),RA=(12,68,-),MF=L\n         $FS   SBA=(13,13),MF=L\nHCL13    $FS   TEXT='CSA  ',MF=L\n#CSALINE EQU   *-4\n         $FS   TEXT=(' ',11),MF=L\n         $FS   TEXT=' K  ',MF=L\n         $FS   TEXT=(' ',8),MF=L\n         $FS   TEXT=' K    ',MF=L\n         $FS   TEXT=(' ',8),MF=L\n         $FS   TEXT=' K      ',MF=L\n         $FS   TEXT=(' ',5),MF=L\nHCL13L   EQU   *-HCL13\n         $FS   SBA=(14,11),MF=L\nHCL14    $FS   TEXT='SP ',MF=L\n#227LINE $FS   TEXT=(' ',4),MF=L\n         $FS   TEXT=(' ',3),MF=L\n         $FS   TEXT=(' ',8),MF=L\n         $FS   TEXT=' K  ',MF=L\n         $FS   TEXT=(' ',8),MF=L\n         $FS   TEXT=' K    ',MF=L\n         $FS   TEXT=(' ',8),MF=L\n         $FS   TEXT=' K      ',MF=L\n         $FS   TEXT=(' ',5),MF=L\nHCL14L   EQU   *-HCL14\n         $FS   SBA=(15,11),MF=L\nHCL15    $FS   TEXT='SP ',MF=L\n#228LINE $FS   TEXT=(' ',4),MF=L\n         $FS   TEXT=(' ',3),MF=L\n         $FS   TEXT=(' ',8),MF=L\n         $FS   TEXT=' K  ',MF=L\n         $FS   TEXT=(' ',8),MF=L\n         $FS   TEXT=' K    ',MF=L\n         $FS   TEXT=(' ',8),MF=L\n         $FS   TEXT=' K      ',MF=L\n         $FS   TEXT=(' ',5),MF=L\nHCL15L   EQU   *-HCL15\n         $FS   SBA=(16,11),MF=L\nHCL16    $FS   TEXT='SP ',MF=L\n#231LINE $FS   TEXT=(' ',4),MF=L\n         $FS   TEXT=(' ',3),MF=L\n         $FS   TEXT=(' ',8),MF=L\n         $FS   TEXT=' K  ',MF=L\n         $FS   TEXT=(' ',8),MF=L\n         $FS   TEXT=' K    ',MF=L\n         $FS   TEXT=(' ',8),MF=L\n         $FS   TEXT=' K      ',MF=L\n         $FS   TEXT=(' ',5),MF=L\nHCL16L   EQU   *-HCL16\n         $FS   SBA=(17,11),MF=L\nHCL17    $FS   TEXT='SP ',MF=L\n#241LINE $FS   TEXT=(' ',4),MF=L\n         $FS   TEXT=(' ',3),MF=L\n         $FS   TEXT=(' ',8),MF=L\n         $FS   TEXT=' K  ',MF=L\n         $FS   TEXT=(' ',8),MF=L\n         $FS   TEXT=' K    ',MF=L\n         $FS   TEXT=(' ',8),MF=L\n         $FS   TEXT=' K      ',MF=L\n         $FS   TEXT=(' ',5),MF=L\nHCL17L   EQU   *-HCL17\n         $FS   SBA=(20,18),SF=(PROT,INT),MF=L\n#SQATHRS $FS   TEXT=(' ',44),MF=L\n         $FS   SF=(PROT),MF=L\n         $FS   SBA=(21,17),SF=(PROT,INT),MF=L\n#SQAOVFA $FS   TEXT=(' ',31),MF=L\n#SQAOVFX $FS   TEXT=(' ',8),MF=L\n#SQAOVFB $FS   TEXT=(' ',7),MF=L\nHCL21L   EQU   *-#SQAOVFA\n         $FS   SF=(PROT),MF=L\n         $FS   SBA=(1,1),SF=(PT,IC),MF=L\n#SCRNLEN EQU   *-#SCREEN\n         SPACE 1\n#ALTSCR  DS    0F\n         $FS   WCC=(KBR,RMDT),MF=L\n         $FS   SBA=(1,1),RA=(1,1,00),MF=L\n         $FS   SBA=(1,1),SF=(PROT,INT),MF=L\n         $FS   TEXT='SELECT OPTION =>',MF=L\n         $FS   SF=NORMAL,TEXT=' ',MF=L\n         $FS   SF=(PROT),MF=L\n         $FS   SBA=(3,20),SF=(PROT,INT),MF=L\n         $FS   TEXT='SQA/CSA UTILIZATION : DEBUG AID SERVICE',MF=L\n         $FS   SF=(PROT),MF=L\n         $FS   SBA=(6,1),MF=L\n#ALTM01  $FS   TEXT=(' ',16),MF=L\n         $FS   SF=(PROT,INT),MF=L\n#ALTM02  $FS   TEXT=(' ',8),MF=L\n         $FS   SF=(PROT),MF=L\n         $FS   SBA=(8,1),TEXT='CURRENT PROCESSING WAS :',MF=L\n         $FS   SF=(PROT,INT),MF=L\n#ALTM03  $FS   TEXT=(' ',3),MF=L\n         $FS   TEXT=' (',MF=L\n#A16M    $FS   TEXT=' ',MF=L\n         $FS   TEXT=' 16MB-LINE)',MF=L\n         $FS   SF=(PROT),MF=L\n         $FS   SBA=(10,5),MF=L\n#ALTM04  $FS   TEXT=(' ',48),MF=L\n         $FS   SBA=(1,1),SF=(PT,IC),MF=L\n#ALTSCRL EQU   *-#ALTSCR\n         EJECT\n         LTORG\n         EJECT\n***********************************************************************\n*                                                                     *\n*        HARDCOPY SCREEN PROCESS                                      *\n*                                                                     *\n*        HERE, WE RECEIVES CONTROL FROM HARDCOPY MODULE WITH THE      *\n*        REGISTERS AS BELOW :                                         *\n*              R2   - '#SCREEN' ADDRESS                               *\n*              R3   - HARDCOPY TARGET LINE ADDRESS (BLANKS            *\n*                     INITIALIZED AND LENGTH 80)                      *\n*              R4   - 'HCSCR' ADDRESS                                 *\n*              R10  - LINKAGE AREA POINTER                            *\n*              R14  - LINKAGE REGISTER                                *\n*                                                                     *\n*        NOTE : DO NOT USE ANY OTHER REGISTER WITHOUT LOOKING IN      *\n*               THE HARDCOPY MODULE FOR HIS AVAILABILITY              *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         DS    0F\n         USING #SCREEN,R2\n         USING *,R4\nHCSCR    B     HCSCR1              LINE 1\n         B     0(R14)              LINE 2\n         B     HCSCR3              LINE 3\n         B     0(R14)              LINE 4\n         B     HCSCR5              LINE 5\n         B     HCSCR6              LINE 6\n         B     0(R14)              LINE 7\n         B     HCSCR8              LINE 8\n         B     HCSCR9              LINE 9\n         B     HCSCR10             LINE 10\n         B     HCSCR11             LINE 11\n         B     HCSCR12             LINE 12\n         B     HCSCR13             LINE 13\n         B     HCSCR14             LINE 14\n         B     HCSCR15             LINE 15\n         B     HCSCR16             LINE 16\n         B     HCSCR17             LINE 17\n         B     0(R14)              LINE 18\n         B     0(R14)              LINE 19\n         B     HCSCR20             LINE 20\n         B     HCSCR21             LINE 21\n         B     0(R14)              LINE 22\n         B     0(R14)              LINE 23\n         B     0(R14)              LINE 24\n         SPACE 1\nHCSCR1   MVC   2(L'HCL1,R3),HCL1\n         MVC   3+L'HCL1(1,R3),@RSPONSE\n         BR    R14\nHCSCR3   MVC   24(HCL3L,R3),HCL3\n         BR    R14\nHCSCR5   MVC   34(L'HCL5,R3),HCL5\n         BR    R14\nHCSCR6   MVC   14(HCL6L,R3),HCL6\n         BR    R14\nHCSCR8   MVC   13(HCL8L,R3),HCL8\n         BR    R14\nHCSCR9   MVC   11(HCL9L,R3),HCL9\n         BR    R14\nHCSCR10  MVC   11(HCL10L,R3),HCL10\n         BR    R14\nHCSCR11  MVC   11(HCL11L,R3),HCL11\n         BR    R14\nHCSCR12  MVI   11(R3),C'-'\n         MVC   12(56,R3),11(R3)\n         BR    R14\nHCSCR13  MVC   13(HCL13L,R3),HCL13\n         BR    R14\nHCSCR14  MVC   11(HCL14L,R3),HCL14\n         BR    R14\nHCSCR15  MVC   11(HCL15L,R3),HCL15\n         BR    R14\nHCSCR16  MVC   11(HCL16L,R3),HCL16\n         BR    R14\nHCSCR17  MVC   11(HCL17L,R3),HCL17\n         BR    R14\nHCSCR20  MVC   19(L'#SQATHRS,R3),#SQATHRS\n         BR    R14\nHCSCR21  MVC   18(HCL21L,R3),#SQAOVFA\n         BR    R14\n         SPACE 1\n         DROP  R2,R4\n         EJECT\nSPTAB    DS    0D                  SUB-POOLS TABLE\nSPSQA    DC    AL1(226),AL3(#226LINE),A(W226) --- SQA SUB-POOLS\n         DC    AL1(239),AL3(#239LINE),A(W239)\n         DC    AL1(245),AL3(#245LINE),A(W245)\nSPSQAN   EQU   (*-SPSQA)/L'SPTAB   NUMBER OF SQA SUB-POOLS\nSPCSA    DC    AL1(227),AL3(#227LINE),A(W227) --- CSA SUB-POOLS\n         DC    AL1(228),AL3(#228LINE),A(W228)\n         DC    AL1(231),AL3(#231LINE),A(W231)\n         DC    AL1(241),AL3(#241LINE),A(W241)\nSPCSAN   EQU   (*-SPCSA)/L'SPTAB   NUMBER OF CSA SUB-POOLS\nSPTABN   EQU   (*-SPTAB)/L'SPTAB   NUMBER OF SUB-POOLS IN TABLE\n         SPACE 1\nWCELLS   DS    0F                  SUB-POOLS WORK CELLS\nW226     DC    3F'0'\nW227     DC    3F'0'\nW228     DC    3F'0'\nW231     DC    3F'0'\nW239     DC    3F'0'\nW241     DC    3F'0'\nW245     DC    3F'0'\nWSPL     EQU   *-WCELLS\n         EJECT\n$WRKSECT DSECT\n$WRKNUMB DS    CL4\n         DS    CL3\n$WRKSIZE DS    CL8\n         DS    CL4\n$WRKFREE DS    CL8\n         DS    CL6\n$WRKLRGE DS    CL8\n         DS    CL8\n$WRKPCT  DS    CL5\n         SPACE 2\n         $GDA  G=NO                GENERAL DATA AREA DSECT\n         SPACE 2\n         $SDF\n         SPACE 2\n         $AFUF\n         EJECT\n         $LNKSECT\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "VSM00300": {"ttr": 19975, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x882?\\x00\\x882?\\x144\\x02\\xc7\\x02\\xc7\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-11-18T00:00:00", "modifydate": "1988-11-18T14:34:00", "lines": 711, "newlines": 711, "modlines": 0, "user": "SYSPAJA"}, "text": "V300     TITLE 'VSM00300 - CSA PROTECT KEY MONITOR.'\n         PRINT OFF\n         COPY  VSMMAC\n         PRINT ON\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*    MODULE :           VSM00300 (MVS/XA)                             *\n*                       VERSION : 1.0                                 *\n*                       DATE : 12 NOV 1986                            *\n*                       NAME : CSA PROTECT KEY MONITOR                *\n*                       ATTRIBUTES : REUS                             *\n*                                                                     *\n*    AUTHOR :           MOINIL P.A. - COMPUTING CENTRE                *\n*                       J.R.C. - ISPRA ESTABLISHMENT                  *\n*                       21020 ISPRA (VA), ITALY                       *\n*                                                                     *\n*    FUNCTION :         SHOW CSA SUBPOOL UTILIZATION BY PROTECT KEY   *\n*                                                                     *\n*    REGS AT INPUT :    R1   - INTER MODULE LINKAGE                   *\n*                       R14  - RETURN ADDRESS                         *\n*                       R15  - EPA                                    *\n*                                                                     *\n*    REGS USAGE :       R0   - WORK REGISTER                          *\n*                       R1   - POINTER TO INTER MODULE LINKAGE        *\n*                       R2-R5 - WORK REGISTERS                        *\n*                       R6   - WORK AREA POINTER (VSMLIST)            *\n*                       R7   - WORK AREA SIZE (VSMLIST)               *\n*                       R8   - WORK REGISTER                          *\n*                       R9   - INTERNAL LINKAGE REGISTER              *\n*                       R10  - LINKAGE AREA POINTER                   *\n*                       R11  - BASE REGISTER                          *\n*                       R12  - 2ND BASE REGISTER (RESERVED)           *\n*                       R13  - SAVE AREA POINTER                      *\n*                       R14  - LINKAGE REGISTER                       *\n*                       R15  - ADDRESS OF CALLED MODULES              *\n*                                                                     *\n*    REGS AT EXIT :     R14  - RETURN ADDRESS                         *\n*                                                                     *\n*    LABELS :           SOME OF THE FIELD USAGE IN THIS MODULE CAN    *\n*                       BE DETERMINED BY THE FIRST CHARACTER OF THE   *\n*                       FIELD. THE KEYS ARE :                         *\n*                            @ - FIELD IS IN INTER MODULE LINKAGE     *\n*                                AREA                                 *\n*                            # - FIELD IS PART OF THE OUTPUT SCREEN   *\n*                            $ - DSECT                                *\n*                                                                     *\n***********************************************************************\n         EJECT\nVSM00300 START 0\n         SPACE 1\n        $DEFREG ,\n***********************************************************************\n*        STANDARD OS LINKAGE                                          *\n***********************************************************************\n         SPACE 1\n        $XENT  BASE=R11            SAVE CALLER'S REGS\n         EJECT\n***********************************************************************\n*        INITIALIZATION                                               *\n***********************************************************************\n         SPACE 1\n         MVI   SW16M,0             RESET\n         LR    R10,R1              POINT TO LINKAGE AREA\n         USING $LNKSECT,R10        DSECT ADDRESSABILITY\nP000100  MVI   DBLEWORD,0          CLEAR WORK FIELDS WITH ZEROS\n         MVC   DBLEWORD+1(CLRL-1),DBLEWORD\n         L     R1,=A(WCELLS)       RESET SP COLLECT DATA AREAS\n         XC    0(WSPL,R1),0(R1)\n         TM    SW16M,UP16M\n         BO    *+L'*+8\n         MVI   #S16M,C'<'\n         B     *+L'*+4\n         MVI   #S16M,C'>'\n         MVI   #ALTM01,C' '\n         MVC   #ALTM01+1(L'#ALTM01-1),#ALTM01\n         MVC   #ALTM02(L'#ALTM02),#ALTM01\n         LM    R6,R7,@WAADD        SET WORK AREA POINTER/SIZE\n         EJECT\n***********************************************************************\n*        CSA - GET VSM DATA                                           *\n***********************************************************************\n         SPACE 1\n         LR    R2,R6               CLEAR\n         LR    R3,R7                 VSMLIST\n         LR    R4,R6                   WORK AREA\n         XR    R5,R5                     WITH\n         MVCL  R2,R4                       ZEROS\n        VSMLIST SP=CSA,SPACE=FREE,WKAREA=((R6),(R7))\n         LTR   R15,R15             SUCCESSFULLY EXECUTED ?\n         BNZ   ERRG                NO, ERROR\n         BAS   R9,WKSNAP           TAKE W.A. SNAP IF NEEDED\n         EJECT\n***********************************************************************\n*        CSA - COLLECT DATA FROM VSM                                  *\n***********************************************************************\n         SPACE 1\n         L     R3,4(R6)            GET ADDRESS OF DATA\n         L     R5,8(R6)            GET LENGTH OF DATA\n         AR    R5,R3               END OF DATA+1 ADDRESS\n         L     R8,0(R3)            GET NUMBER OF SUBPOOLS\n         LTR   R8,R8               NONE ?\n         BNP   ERRN                YES\n         LA    R3,4(R3)            BUMP CURRENT POINTER,\nP000200  CLR   R3,R5                 TEST IF OVERFLOW,\n         BNL   ERR0                    AND BRANCH IF YES, ERROR\n         USING SDF,R3\n         CLI   SDFIS,X'00'         SUBPOOL DESCRIPTOR IDENTIFIER ?\n         BNE   ERRIS\n         LA    R0,SPTABN           SCAN SUBPOOLS TABLE\n         L     R2,=A(SPTAB)\nP000210  CLC   0(1,R2),SDFID       THIS SUBPOOL ID NUMBER ?\n         LA    R2,L'SPTAB(R2)\n         BE    P000220             YES\n         BCT   R0,P000210\n         B     ERRS                UNKNOWN SUBPOOL\nP000220  SL    R2,=A(SPTAB)        COMPUTE DISPLACEMENT\n         SLL   R2,2                  INTO WORK CELLS\n         MVZ   KEY,SDFKF           EXTRACT STORAGE KEY\n         L     R1,=A(KEYTAB)       SCAN KEYS TABLE\nP000230  CLC   KEY(L'KEY),0(R1)    THIS KEY ?\n         BNH   P000240             YES\n         LA    R1,L'KEYTAB(R1)\n         B     P000230\nP000240  L     R14,4(R1)           GET WORK CELLS ADDRESS\n         XR    R15,R15             ALLOCATED SPACE ACCUMULATOR\n         XR    R1,R1               FREE SPACE ACCUMULATOR\n         XR    R0,R0\n         IC    R0,SDFLG            LENGTH OF SUBPOOL DESCRIPTOR\n         DROP  R3\n         AR    R3,R0               BUMP CURRENT PTR\n         CLR   R3,R5               TEST IF DATA OVERFLOW\n         BNL   ERR1                BRANCH IF YES, ERROR\n         ICM   R9,B'1111',0(R3)    GET NUMBER OF ALLOCATED BLOCKS\n         LA    R3,4(R3)            BUMP CURRENT POINTER\n         LTR   R9,R9               HOW MANY ALLOCATED BLOCKS ?\n         BNP   P000280             BRANCH IF NONE\nP000250  CLR   R3,R5               TEST IF DATA OVERFLOW\n         BNL   ERR2                BRANCH IF YES, ERROR\n         USING AFUF,R3\n         NI    SW16M,255-SKACC\n         ICM   R4,B'1111',AFUFVA   VIRTUAL ADDRESS OF ALLOC. BLOCK\n         LA    R4,0(R4)\n         TM    SW16M,UP16M\n         BO    P000252\n         CL    R4,=A(16*1024*1024)\n         BL    P000253\nP000251  OI    SW16M,SKACC\n         B     P000254\nP000252  CL    R4,=A(16*1024*1024)\n         BL    P000251\nP000253  ICM   R0,B'1111',AFUFLG   LENGTH OF ALLOCATED BLOCK\n         AR    R15,R0\n         DROP  R3\nP000254  LA    R3,LAFUF(R3)        BUMP CURRENT POINTER,\n         CLR   R3,R5               TEST IF OVERFLOW\n         BNL   ERR3                BRANCH IF YES, ERROR\n         ICM   R4,B'1111',0(R3)    GET NUMBER OF FREE SPACE DESC.\n         LA    R3,4(R3)            BUMP CURRENT POINTER\n         LTR   R4,R4               HOW MANY FREE SPACE DESC. ?\n         BNP   P000270             BRANCH IF NONE\nP000260  CLR   R3,R5               TEST IF DATA OVERFLOW\n         BNL   ERR4                BRANCH IF YES, ERROR\n         TM    SW16M,SKACC\n         BO    P000261\n         USING AFUF,R3\n         ICM   R0,B'1111',AFUFLG   LENGTH OF FREE SPACE\n         AR    R1,R0\n         DROP  R3\nP000261  LA    R3,LAFUF(R3)        BUMP CURRENT POINTER\n         BCT   R4,P000260          LOOP IF MORE FREE SPACE DESC.\nP000270  BCT   R9,P000250          LOOP IF MORE ALLOCATED BLOCKS\n         SR    R15,R1              COMPUTE SPACE USED\n         LR    R1,R15\n         LR    R0,R15\n         A     R15,0(R14)          CSA SPACE\n         ST    R15,0(R14)\n         A     R1,0(R2,R14)        SUBPOOL SPACE\n         ST    R1,0(R2,R14)\n         L     R15,=A(TOTCSA)      COMPUTE CSA TOTAL (ALL KEYS)\n         L     R1,0(R15)\n         AR    R1,R0\n         ST    R1,0(R15)\n         L     R1,0(R2,R15)\n         AR    R1,R0\n         ST    R1,0(R2,R15)\nP000280  BCT   R8,P000200          LOOP IF MORE SUBPOOLS\n         CLR   R3,R5               DATA EXHAUSTED ?\n         BNE   ERRD                BRANCH IF NOT, ERROR\n         EJECT\n***********************************************************************\n*        CSA - FORMAT DATA TO BE OUTPUT                               *\n***********************************************************************\n         SPACE 1\n         L     R5,=A(KEYTAB)       START OF CSA KEYS - SUBPOOLS\nP000500  BAS   R9,TSEDIT           FORMAT KEY OUTPUT DATA\n         CLI   0(R5),VRKEY         ALL KEYS PROCESSED ?\n         BE    P000510             YES\n         LA    R5,L'KEYTAB(R5)     POINT TO NEXT\n         B     P000500\nP000510  LA    R3,#TOTLINE         EDIT CSA TOTAL (ALL KEYS)\n         L     R4,=A(TOTCSA)\n         BAS   R9,ALLEDIT\n         EJECT\n***********************************************************************\n*        OUTPUT THE SCREEN                                            *\n***********************************************************************\n         SPACE 1\n         LA    R0,#SCREEN          LOAD SCREEN ADDR INTO R0\n         ST    R0,@PUTAREA         STORE IN LINKAGE AREA\n         LA    R0,#SCRNLEN         LOAD SCREEN LENGTH INTO R0\n         ST    R0,@PUTLEN          STORE LENGTH IN LINKAGE AREA\n         L     R0,=A(HCSCR)        HARDCOPY SCREEN\n        $HCPY  HSA=(R0)              IF NEEDED\nP000900  MVI   @RSPONSE,C' '       MOVE BLANK TO RESPONSE\n         LR    R1,R10              POINT R1 TO LINKAGE AREA\n         L     R15,@IOMOD          LOAD ADDR OF TERMINAL I/O MODULE\n         BASR  R14,R15             GO DO TERMINAL I/O\n         CLI   @RSPONSE,C'R'       REFRESH SCREEN ?\n         BNE   *+L'*+8             BRANCH IF NOT\n         XI    SW16M,UP16M         FLIP/FLOP BETWEEN LOW/UP 16 MB LINE\n         B     P000100\n        $XRET  CC=0                B O O G I E\n         EJECT\n***********************************************************************\n*        ERRORS DIAGNOSE                                              *\n***********************************************************************\n         SPACE 1\nERRG     MVC   #ALTM01,=CL16'VSMLIST REG 15 :'\n         CH    R15,=H'4'           ALL INFORMATION NOT RECEIVED R.C. ?\n         BNE   *+L'*+10            NO\n         MVC   #ALTM02,=CL8'4 - W.A.'   YES, WORK AREA IS TOO SMALL\n         B     ERRSV\n         STCM  R15,B'1111',FIVEBYTE     NO, DISPLAY R.C.\n         UNPK  TENBYTE,FIVEBYTE\n         TR    TENBYTE+1(8),TRTABLE\n         MVC   #ALTM02,TENBYTE+1\n         B     ERRSV\nERRS     MVC   #ALTM01,=CL16'UNDEF. SUBPOOL :'\n         STM   R0,R15,SVREGS\n         XR    R0,R0\n         USING SDF,R3\n         IC    R0,SDFID            SUBPOOL ID NUMBER\n         DROP  R3\n         CVD   R0,DBLEWORD\n         MVC   #ALTM02+L'#ALTM02-L'EDIT1(L'EDIT1),EDIT1\n         ED    #ALTM02+L'#ALTM02-L'EDIT1(L'EDIT1),DBLEWORD+6\n         B     ERRDIAG\nERR0     MVI   #ALTM02+6,C'0'\n         B     ERRMSG\nERR1     MVI   #ALTM02+6,C'1'\n         B     ERRMSG\nERR2     MVI   #ALTM02+6,C'2'\n         B     ERRMSG\nERR3     MVI   #ALTM02+6,C'3'\n         B     ERRMSG\nERR4     MVI   #ALTM02+6,C'4'\n         B     ERRMSG\nERRD     MVI   #ALTM02+6,C'D'\n         B     ERRMSG\nERRN     MVI   #ALTM02+6,C'N'\n         B     ERRMSG\nERRIS    MVC   #ALTM02+6(2),=CL2'IS'\nERRMSG   MVC   #ALTM02(5),=CL5'ERROR'\nERRSV    STM   R0,R15,SVREGS\nERRDIAG  LA    R1,SVREGS           BUILD\n         ST    R1,@SNPLST            REGISTERS AT\n         LA    R1,16*4-1(R1)           TIME OF ERROR\n         ST    R1,@SNPLST+4              SNAP\n         OI    @SNPLST+4,X'80'             LIST\n        $SNAP  ID=0                ID-NUMBER - - - - - - - - - - - 000\n         TM    @SWITCH,@SNPFNA     SNAP INACTIVE ?\n         BZ    *+L'*+10            NO\n         MVC   #ALTM03,MSGE1       YES\n         B     *+L'*+10\n         BAS   R9,WKSNAP           TAKE W.A. SNAP\n         MVC   #ALTM03,MSGE2\n         MVC   #A16M,#S16M\n         LA    R0,#ALTSCR          LOAD ALTERNATE SCREEN ADDR\n         ST    R0,@PUTAREA         STORE IN LINKAGE AREA\n         LA    R0,#ALTSCRL         LOAD ALTERNATE SCREEN LENGTH\n         ST    R0,@PUTLEN          STORE IN LINKAGE AREA\n         B     P000900\n         EJECT\n***********************************************************************\n*                                                                     *\n* ===> TSEDIT / ALLEDIT <===                                          *\n*                                                                     *\n*        FORMAT KEYS / ALL KEYS COMPUTATIONS DATA                     *\n*                                                                     *\n*        REGISTERS AT ENTRY IN THIS SUBROUTINE                        *\n*                                                                     *\n*        R3 =>   SCREEN OUTPUT LINE ADDRESS ---> ALLEDIT              *\n*        R4 =>   ALL KEYS WORK CELLS POINTER ---> ALLEDIT             *\n*        R5 =>   KEY TABLE POINTER ---> TSEDIT                        *\n*        R9 =>   RETURN ADDRESS                                       *\n*                                                                     *\n*        REGISTERS USAGE FOR THIS SUBROUTINE                          *\n*                                                                     *\n*        R0 =>   TEMPORARY WORK REGISTER                              *\n*        R1 =>   TEMPORARY WORK REGISTER                              *\n*        R2 =>   TEMPORARY WORK REGISTER                              *\n*        R3 =>   SCREEN OUTPUT LINE ADDRESS                           *\n*        R4 =>   WORK CELLS POINTER                                   *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nTSEDIT   XR    R3,R3\n         ICM   R3,B'0111',1(R5)    SCREEN OUTPUT LINE ADDRESS\n         L     R4,4(R5)            KEY SUBPOOLS WORK CELLS\nALLEDIT  LA    R2,SPTABN+1\nTSEDIT1  L     R0,0(R4)            GET VALUE\n         LTR   R0,R0\n         BNZ   TSEDIT2\n         MVI   0(R3),C' '\n         MVC   1(L'EDIT1-1,R3),0(R3)\n         B     TSEDIT3\nTSEDIT2  SRA   R0,10               DIVIDE BY 1024 TO HAVE IN K\n         CVD   R0,DBLEWORD         CONVERT\n         MVC   0(L'EDIT1,R3),EDIT1   AND\n         ED    0(L'EDIT1,R3),DBLEWORD+4 EDIT\nTSEDIT3  LA    R3,L'EDIT1+3(R3)    NEXT VALUE\n         LA    R4,4(R4)\n         BCT   R2,TSEDIT1          LOOP IF MORE\n         BR    R9                  RETURN\n         EJECT\n***********************************************************************\n*                                                                     *\n* ===> WKSNAP <===                                                    *\n*                                                                     *\n*        WORK AREA SNAP                                               *\n*                                                                     *\n*        REGISTERS USAGE FOR THIS SUBROUTINE                          *\n*                                                                     *\n*        R1 =>   TEMPORARY WORK REGISTER                              *\n*        R9 =>   RETURN ADDRESS                                       *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nWKSNAP   ST    R6,@SNPLST          BUILD\n         LR    R1,R6                 VSMLIST\n         BCTR  R1,0                    WORK\n         AR    R1,R7                     AREA\n         ST    R1,@SNPLST+4                SNAP\n         OI    @SNPLST+4,X'80'               LIST\n        $SNAP  ID=3                ID-NUMBER - - - - - - - - - - - 003\n         BR    R9                  RETURN\n         EJECT\nDBLEWORD DC    D'0'                DOUBLE WORD WORK AREA\nTENBYTE  DC    XL10'0'\nFIVEBYTE DC    XL5'0'\nKEY      DC    XL1'0'\nCLRL     EQU   *-DBLEWORD\n         SPACE 1\nSVREGS   DC    16F'0'              SAVE REGS 0-15\nTRTABLE  DS    0CL256\n         DC    CL240' '\n         DC    CL16'0123456789ABCDEF'\nMSGE1    DC    C'===> ALLOCATE A FILE \"SYSSNAP\" FOR MORE DETAILS.'\nMSGE2    DC    C'===> SEE TO FILE \"SYSSNAP\" FOR MORE DETAILS.    '\nEDIT1    DC    XL8'4020202020202120'    EDIT PATTERN FOR SIZE IN K\nSW16M    DC    XL1'0'         16 MB PROCESS FLAGS\nUP16M    EQU   X'01'               PROCESS UP 16 MB LINE\nSKACC    EQU   X'02'               SKIP ACCOUNT\n         SPACE 1\n#SCREEN  DS    0F\n         $FS   WCC=(KBR,RMDT),MF=L\n         $FS   SBA=(1,1),RA=(1,1,00),MF=L\n         $FS   SBA=(1,1),SF=(PROT,INT),MF=L\nHCL1     $FS   TEXT='SELECT OPTION =>',MF=L\n         $FS   SF=NORMAL,TEXT=' ',MF=L\n         $FS   SF=(PROT),MF=L\n         $FS   SBA=(3,18),SF=(PROT,INT),MF=L\nHCL3     $FS   TEXT='CSA UTILIZATION BY PROTECT KEY : ',MF=L\n#S16M    $FS   TEXT=' ',MF=L\n         $FS   TEXT=' 16MB-LINE',MF=L\nHCL3L    EQU   *-HCL3\n         $FS   SF=(PROT),MF=L\n         $FS   SBA=(5,5),MF=L\nHCL5     $FS   TEXT='KEY        NAME         CSA       ',MF=L\n         $FS   TEXT='SP 227     SP 228     SP 231     SP 241',MF=L\nHCL5L    EQU   *-HCL5\n         $FS   SBA=(6,5),MF=L\nHCL6     $FS   TEXT=' 0  ',MF=L\n         $FS   TEXT=(' ',4),MF=L\n         $FS   TEXT='SUPERVISOR',MF=L\n         $FS   TEXT=' ',MF=L\n#00LINE  $FS   TEXT=(' ',8),MF=L\n         $FS   TEXT=' K ',MF=L\n         $FS   TEXT=(' ',8),MF=L\n         $FS   TEXT=' K ',MF=L\n         $FS   TEXT=(' ',8),MF=L\n         $FS   TEXT=' K ',MF=L\n         $FS   TEXT=(' ',8),MF=L\n         $FS   TEXT=' K ',MF=L\n         $FS   TEXT=(' ',8),MF=L\n         $FS   TEXT=' K',MF=L\nHCL6L    EQU   *-HCL6\n         $FS   SBA=(7,5),MF=L\nHCL7     $FS   TEXT=' 1  ',MF=L\n         $FS   TEXT=(' ',4),MF=L\n         $FS   TEXT='SCHDLR/JES',MF=L\n         $FS   TEXT=' ',MF=L\n#01LINE  $FS   TEXT=(' ',8),MF=L\n         $FS   TEXT=' K ',MF=L\n         $FS   TEXT=(' ',8),MF=L\n         $FS   TEXT=' K ',MF=L\n         $FS   TEXT=(' ',8),MF=L\n         $FS   TEXT=' K ',MF=L\n         $FS   TEXT=(' ',8),MF=L\n         $FS   TEXT=' K ',MF=L\n         $FS   TEXT=(' ',8),MF=L\n         $FS   TEXT=' K',MF=L\nHCL7L    EQU   *-HCL7\n         $FS   SBA=(8,5),MF=L\nHCL8     $FS   TEXT=' 2  ',MF=L\n         $FS   TEXT=(' ',4),MF=L\n         $FS   TEXT='VSPC      ',MF=L\n         $FS   TEXT=' ',MF=L\n#02LINE  $FS   TEXT=(' ',8),MF=L\n         $FS   TEXT=' K ',MF=L\n         $FS   TEXT=(' ',8),MF=L\n         $FS   TEXT=' K ',MF=L\n         $FS   TEXT=(' ',8),MF=L\n         $FS   TEXT=' K ',MF=L\n         $FS   TEXT=(' ',8),MF=L\n         $FS   TEXT=' K ',MF=L\n         $FS   TEXT=(' ',8),MF=L\n         $FS   TEXT=' K',MF=L\nHCL8L    EQU   *-HCL8\n         $FS   SBA=(9,5),MF=L\nHCL9     $FS   TEXT=' 3  ',MF=L\n         $FS   TEXT=(' ',4),MF=L\n         $FS   TEXT=(' ',10),MF=L\n         $FS   TEXT=' ',MF=L\n#03LINE  $FS   TEXT=(' ',8),MF=L\n         $FS   TEXT=' K ',MF=L\n         $FS   TEXT=(' ',8),MF=L\n         $FS   TEXT=' K ',MF=L\n         $FS   TEXT=(' ',8),MF=L\n         $FS   TEXT=' K ',MF=L\n         $FS   TEXT=(' ',8),MF=L\n         $FS   TEXT=' K ',MF=L\n         $FS   TEXT=(' ',8),MF=L\n         $FS   TEXT=' K',MF=L\nHCL9L    EQU   *-HCL9\n         $FS   SBA=(10,5),MF=L\nHCL10    $FS   TEXT=' 4  ',MF=L\n         $FS   TEXT=(' ',4),MF=L\n         $FS   TEXT=(' ',10),MF=L\n         $FS   TEXT=' ',MF=L\n#04LINE  $FS   TEXT=(' ',8),MF=L\n         $FS   TEXT=' K ',MF=L\n         $FS   TEXT=(' ',8),MF=L\n         $FS   TEXT=' K ',MF=L\n         $FS   TEXT=(' ',8),MF=L\n         $FS   TEXT=' K ',MF=L\n         $FS   TEXT=(' ',8),MF=L\n         $FS   TEXT=' K ',MF=L\n         $FS   TEXT=(' ',8),MF=L\n         $FS   TEXT=' K',MF=L\nHCL10L   EQU   *-HCL10\n         $FS   SBA=(11,5),MF=L\nHCL11    $FS   TEXT=' 5  ',MF=L\n         $FS   TEXT=(' ',4),MF=L\n         $FS   TEXT='DATA MNGT ',MF=L\n         $FS   TEXT=' ',MF=L\n#05LINE  $FS   TEXT=(' ',8),MF=L\n         $FS   TEXT=' K ',MF=L\n         $FS   TEXT=(' ',8),MF=L\n         $FS   TEXT=' K ',MF=L\n         $FS   TEXT=(' ',8),MF=L\n         $FS   TEXT=' K ',MF=L\n         $FS   TEXT=(' ',8),MF=L\n         $FS   TEXT=' K ',MF=L\n         $FS   TEXT=(' ',8),MF=L\n         $FS   TEXT=' K',MF=L\nHCL11L   EQU   *-HCL11\n         $FS   SBA=(12,5),MF=L\nHCL12    $FS   TEXT=' 6  ',MF=L\n         $FS   TEXT=(' ',4),MF=L\n         $FS   TEXT='TCAM/VTAM ',MF=L\n         $FS   TEXT=' ',MF=L\n#06LINE  $FS   TEXT=(' ',8),MF=L\n         $FS   TEXT=' K ',MF=L\n         $FS   TEXT=(' ',8),MF=L\n         $FS   TEXT=' K ',MF=L\n         $FS   TEXT=(' ',8),MF=L\n         $FS   TEXT=' K ',MF=L\n         $FS   TEXT=(' ',8),MF=L\n         $FS   TEXT=' K ',MF=L\n         $FS   TEXT=(' ',8),MF=L\n         $FS   TEXT=' K',MF=L\nHCL12L   EQU   *-HCL12\n         $FS   SBA=(13,5),MF=L\nHCL13    $FS   TEXT=' 7  ',MF=L\n         $FS   TEXT=(' ',4),MF=L\n         $FS   TEXT='IMS       ',MF=L\n         $FS   TEXT=' ',MF=L\n#07LINE  $FS   TEXT=(' ',8),MF=L\n         $FS   TEXT=' K ',MF=L\n         $FS   TEXT=(' ',8),MF=L\n         $FS   TEXT=' K ',MF=L\n         $FS   TEXT=(' ',8),MF=L\n         $FS   TEXT=' K ',MF=L\n         $FS   TEXT=(' ',8),MF=L\n         $FS   TEXT=' K ',MF=L\n         $FS   TEXT=(' ',8),MF=L\n         $FS   TEXT=' K',MF=L\nHCL13L   EQU   *-HCL13\n         $FS   SBA=(14,5),MF=L\nHCL14    $FS   TEXT=' 8  ',MF=L\n         $FS   TEXT=(' ',4),MF=L\n         $FS   TEXT='V=V JOBS  ',MF=L\n         $FS   TEXT=' ',MF=L\n#08LINE  $FS   TEXT=(' ',8),MF=L\n         $FS   TEXT=' K ',MF=L\n         $FS   TEXT=(' ',8),MF=L\n         $FS   TEXT=' K ',MF=L\n         $FS   TEXT=(' ',8),MF=L\n         $FS   TEXT=' K ',MF=L\n         $FS   TEXT=(' ',8),MF=L\n         $FS   TEXT=' K ',MF=L\n         $FS   TEXT=(' ',8),MF=L\n         $FS   TEXT=' K',MF=L\nHCL14L   EQU   *-HCL14\n         $FS   SBA=(15,5),MF=L\nHCL15    $FS   TEXT='9-15',MF=L\n         $FS   TEXT=(' ',4),MF=L\n         $FS   TEXT='V=R JOBS  ',MF=L\n         $FS   TEXT=' ',MF=L\n#VRLINE  $FS   TEXT=(' ',8),MF=L\n         $FS   TEXT=' K ',MF=L\n         $FS   TEXT=(' ',8),MF=L\n         $FS   TEXT=' K ',MF=L\n         $FS   TEXT=(' ',8),MF=L\n         $FS   TEXT=' K ',MF=L\n         $FS   TEXT=(' ',8),MF=L\n         $FS   TEXT=' K ',MF=L\n         $FS   TEXT=(' ',8),MF=L\n         $FS   TEXT=' K',MF=L\nHCL15L   EQU   *-HCL15\n         $FS   SBA=(16,5),RA=(16,78,-),MF=L\n         $FS   SBA=(17,5),MF=L\nHCL17    $FS   TEXT='0-15',MF=L\n         $FS   TEXT=(' ',4),MF=L\n         $FS   TEXT='ALL KEYS  ',MF=L\n         $FS   TEXT=' ',MF=L\n#TOTLINE $FS   TEXT=(' ',8),MF=L\n         $FS   TEXT=' K ',MF=L\n         $FS   TEXT=(' ',8),MF=L\n         $FS   TEXT=' K ',MF=L\n         $FS   TEXT=(' ',8),MF=L\n         $FS   TEXT=' K ',MF=L\n         $FS   TEXT=(' ',8),MF=L\n         $FS   TEXT=' K ',MF=L\n         $FS   TEXT=(' ',8),MF=L\n         $FS   TEXT=' K',MF=L\nHCL17L   EQU   *-HCL17\n         $FS   SBA=(1,1),SF=(PT,IC),MF=L\n#SCRNLEN EQU  *-#SCREEN\n         SPACE 1\n#ALTSCR  DS    0F\n         $FS   WCC=(KBR,RMDT),MF=L\n         $FS   SBA=(1,1),RA=(1,1,00),MF=L\n         $FS   SBA=(1,1),SF=(PROT,INT),MF=L\n         $FS   TEXT='SELECT OPTION =>',MF=L\n         $FS   SF=NORMAL,TEXT=' ',MF=L\n         $FS   SF=(PROT),MF=L\n         $FS   SBA=(3,15),SF=(PROT,INT),MF=L\n         $FS   TEXT='CSA UTILIZATION BY PROTECT KEY : ',MF=L\n         $FS   TEXT='DEBUG AID SERVICE',MF=L\n         $FS   SF=(PROT),MF=L\n         $FS   SBA=(6,1),MF=L\n#ALTM01  $FS   TEXT=(' ',16),MF=L\n         $FS   SF=(PROT,INT),MF=L\n#ALTM02  $FS   TEXT=(' ',8),MF=L\n         $FS   SF=(PROT),MF=L\n         $FS   SBA=(8,1),TEXT='CURRENT PROCESSING WAS :',MF=L\n         $FS   SF=(PROT,INT),MF=L\n         $FS   TEXT='CSA (',MF=L\n#A16M    $FS   TEXT=' ',MF=L\n         $FS   TEXT=' 16MB-LINE)',MF=L\n         $FS   SF=(PROT),MF=L\n         $FS   SBA=(10,5),MF=L\n#ALTM03  $FS   TEXT=(' ',48),MF=L\n         $FS   SBA=(1,1),SF=(PT,IC),MF=L\n#ALTSCRL EQU   *-#ALTSCR\n         EJECT\n         LTORG\n         EJECT\n***********************************************************************\n*                                                                     *\n*        HARDCOPY SCREEN PROCESS                                      *\n*                                                                     *\n*        HERE, WE RECEIVES CONTROL FROM HARDCOPY MODULE WITH THE      *\n*        REGISTERS AS BELOW :                                         *\n*              R2   - '#SCREEN' ADDRESS                               *\n*              R3   - HARDCOPY TARGET LINE ADDRESS (BLANKS            *\n*                     INITIALIZED AND LENGTH 80)                      *\n*              R4   - 'HCSCR' ADDRESS                                 *\n*              R10  - LINKAGE AREA POINTER                            *\n*              R14  - LINKAGE REGISTER                                *\n*                                                                     *\n*        NOTE : DO NOT USE ANY OTHER REGISTER WITHOUT LOOKING IN      *\n*               THE HARDCOPY MODULE FOR HIS AVAILABILITY              *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         DS    0F\n         USING #SCREEN,R2\n         USING *,R4\nHCSCR    B     HCSCR1              LINE 1\n         B     0(R14)              LINE 2\n         B     HCSCR3              LINE 3\n         B     0(R14)              LINE 4\n         B     HCSCR5              LINE 5\n         B     HCSCR6              LINE 6\n         B     HCSCR7              LINE 7\n         B     HCSCR8              LINE 8\n         B     HCSCR9              LINE 9\n         B     HCSCR10             LINE 10\n         B     HCSCR11             LINE 11\n         B     HCSCR12             LINE 12\n         B     HCSCR13             LINE 13\n         B     HCSCR14             LINE 14\n         B     HCSCR15             LINE 15\n         B     HCSCR16             LINE 16\n         B     HCSCR17             LINE 17\n         B     0(R14)              LINE 18\n         B     0(R14)              LINE 19\n         B     0(R14)              LINE 20\n         B     0(R14)              LINE 21\n         B     0(R14)              LINE 22\n         B     0(R14)              LINE 23\n         B     0(R14)              LINE 24\n         SPACE 1\nHCSCR1   MVC   2(L'HCL1,R3),HCL1\n         MVC   3+L'HCL1(1,R3),@RSPONSE\n         BR    R14\nHCSCR3   MVC   19(HCL3L,R3),HCL3\n         BR    R14\nHCSCR5   MVC   5(HCL5L,R3),HCL5\n         BR    R14\nHCSCR6   MVC   5(HCL6L,R3),HCL6\n         BR    R14\nHCSCR7   MVC   5(HCL7L,R3),HCL7\n         BR    R14\nHCSCR8   MVC   5(HCL8L,R3),HCL8\n         BR    R14\nHCSCR9   MVC   5(HCL9L,R3),HCL9\n         BR    R14\nHCSCR10  MVC   5(HCL10L,R3),HCL10\n         BR    R14\nHCSCR11  MVC   5(HCL11L,R3),HCL11\n         BR    R14\nHCSCR12  MVC   5(HCL12L,R3),HCL12\n         BR    R14\nHCSCR13  MVC   5(HCL13L,R3),HCL13\n         BR    R14\nHCSCR14  MVC   5(HCL14L,R3),HCL14\n         BR    R14\nHCSCR15  MVC   5(HCL15L,R3),HCL15\n         BR    R14\nHCSCR16  MVI   5(R3),C'-'\n         MVC   6(72,R3),5(R3)\n         BR    R14\nHCSCR17  MVC   5(HCL17L,R3),HCL17\n         BR    R14\n         SPACE 1\n         DROP  R2,R4\n         EJECT\nVRKEY    EQU   X'F0'\n         SPACE 1\nKEYTAB   DS    0D                  KEYS TABLE\n         DC    XL1'00',AL3(#00LINE),A(WK00)\n         DC    XL1'10',AL3(#01LINE),A(WK01)\n         DC    XL1'20',AL3(#02LINE),A(WK02)\n         DC    XL1'30',AL3(#03LINE),A(WK02)\n         DC    XL1'40',AL3(#04LINE),A(WK04)\n         DC    XL1'50',AL3(#05LINE),A(WK05)\n         DC    XL1'60',AL3(#06LINE),A(WK06)\n         DC    XL1'70',AL3(#07LINE),A(WK07)\n         DC    XL1'80',AL3(#08LINE),A(WK08)\n         DC    AL1(VRKEY),AL3(#VRLINE),A(WKVR)\n         SPACE 1\nSPTAB    DS    0C                  CSA SUB-POOLS TABLE\n         DC    AL1(227,228,231,241)\nSPTABN   EQU   *-SPTAB             NUMBER OF CSA SUB-POOLS\n         SPACE 1\nWCELLS   DS    0F                  KEYS SUB-POOLS WORK CELLS\nWK00     DC    (SPTABN+1)F'0'\nWK01     DC    (SPTABN+1)F'0'\nWK02     DC    (SPTABN+1)F'0'\nWK03     DC    (SPTABN+1)F'0'\nWK04     DC    (SPTABN+1)F'0'\nWK05     DC    (SPTABN+1)F'0'\nWK06     DC    (SPTABN+1)F'0'\nWK07     DC    (SPTABN+1)F'0'\nWK08     DC    (SPTABN+1)F'0'\nWKVR     DC    (SPTABN+1)F'0'\nTOTCSA   DC    (SPTABN+1)F'0'\nWSPL     EQU   *-WCELLS\n         EJECT\n         $SDF\n         SPACE 2\n         $AFUF\n         EJECT\n         $LNKSECT                  INTER MODULE LINKGAGE AREA DSECT\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "VSM77000": {"ttr": 20233, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x91\\x07\\x8f\\x00\\x91\\x07\\x8f\\x15\\x19\\x01\\xe5\\x01\\xe5\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-03-19T00:00:00", "modifydate": "1991-03-19T15:19:00", "lines": 485, "newlines": 485, "modlines": 0, "user": "SYSPAJA"}, "text": "VSM7     TITLE 'VSM77000 - HARDCOPY MODULE.'\n         PRINT OFF\n         COPY  VSMMAC\n         PRINT ON\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*    MODULE :           VSM77000                                      *\n*                       VERSION : 1.0                                 *\n*                       DATE : 12 NOV 1986                            *\n*                       NAME : HARDCOPY MODULE                        *\n*                       ATTRIBUTES : REUS                             *\n*                                                                     *\n*    AUTHOR :           MOINIL P.A. - COMPUTING CENTRE                *\n*                       J.R.C. - ISPRA ESTABLISHMENT                  *\n*                       21020 ISPRA (VA), ITALY                       *\n*                                                                     *\n*    FUNCTION :         THIS MODULE TAKES HARDCOPIES ALL SCREEN       *\n*                       DISPLAYS OF VSM. THE SCREEN DISPLAYS          *\n*                       ADDRESSES ARE PASSED TO VSM77000 VIA THE      *\n*                       LINKAGE AREA.                                 *\n*                                                                     *\n*    NOTE :             SYSOUT DYNAMIC ALLOCATION IS USED.            *\n*                                                                     *\n*    REGS AT ENTRY :    R0   - IF ZERO = HARDCOPY REQUEST             *\n*                              IF POSITIVE = OPEN REQUEST             *\n*                              IF NEGATIVE = CLOSE REQUEST            *\n*                       R1   - INTER MODULE LINKAGE                   *\n*                       R14  - RETURN ADDRESS                         *\n*                       R15  - EPA                                    *\n*                                                                     *\n*    REGS USAGE :       R0   - WORK REGSITER                          *\n*                       R1   - POINTER TO INTER MODULE LINKAGE        *\n*                       R2-R5 - WORK REGISTERS                        *\n*                       R10  - LINKAGE AREA POINTER                   *\n*                       R11  - BASE REGISTER                          *\n*                       R12  - 2ND BASE REGISTER (RESERVED)           *\n*                       R13  - SAVE AREA POINTER                      *\n*                                                                     *\n*    REGS AT EXIT :     R14  - RETURN ADDRESS                         *\n*                                                                     *\n*    LABELS :           SOME OF THE FIELD USAGE IN THIS MODULE CAN    *\n*                       BE DETERMINED BY THE FIRST CHARACTER OF THE   *\n*                       FIELD. THE KEYS ARE :                         *\n*                            @ - FIELD IS IN INTER MODULE LINKAGE     *\n*                                AREA                                 *\n*                            # - FIELD IS PART OF THE OUTPUT SCREEN   *\n*                            $ - DSECT                                *\n*                                                                     *\n***********************************************************************\n         EJECT\nVSM77000 START 0\n         SPACE 1\n        $DEFREG\n         EJECT\n***********************************************************************\n*        STANDARD OS LINKAGE                                          *\n***********************************************************************\n         SPACE 1\n        $XENT  BASE=R11            SAVE CALLER'S REGS\n         LR    R10,R1              POINT TO LINKAGE\n         USING $LNKSECT,R10        DSECT ADDRESSABILITY\n         TM    @SWITCH,@HFAIL      HARDCOPY OPEN HAS FAILED ?\n         BO    RETURN              YES, BYPASS ALL\n         LTR   R0,R0               TEST HARCOPY REQUEST\n         BP    HOPEN               BRANCH IF OPEN REQUESTED\n         BM    HCLOSE              BRANCH IF CLOSE REQUESTED\n         EJECT\n***********************************************************************\n*        HARDCOPY A SCREEN DISPLAY, FORMAT DATE/TIME HEADING          *\n***********************************************************************\n         SPACE 1\n         TM    @SWITCH,@HCOPY      IS HARDCOPY ALREADY OPENED ?\n         BZ    RETURN              NO, BYPASS ALL\n        TIME   DEC\n         ST    R1,BINDATE          SAVE DATE FOR LATER\n         STCM  R0,B'1111',FIVEBYTE CONVERT PACKED TO DECIMAL\n         MVI   FIVEBYTE+4,X'0F'\n         UNPK  TENBYTE,FIVEBYTE\n         MVC   HTMEHRS,TENBYTE+1   MOVE TIME TO HEADING\n         MVC   HTMMINS,TENBYTE+3\n         MVC   HTMSECS,TENBYTE+5\n         MVC   FIVEBYTE(4),BINDATE MOVE DATE TO WORK AREA\n         MVO   FIVEBYTE+1(3),FIVEBYTE(2)  MAKE 00YYDDDS INTO 00000YYS\n         UNPK  HCYR(2),FIVEBYTE+2(2)    FORMAT YEAR\n         XC    DBLEWORD,DBLEWORD\n         MVC   DBLEWORD+4(4),FIVEBYTE   CONVERT YEAR TO BINARY\n         CVB   R0,DBLEWORD\n         ST    R0,BINYEAR          AND SAVE\n         TM    BINYEAR+3,X'03'     LEAP YEAR ?\n         BNZ   MON1                NO\n         MVI   HMONMSK+10,29       YES, CORRECT\nMON1     XC    DBLEWORD,DBLEWORD   CONVERT DAYS TO BINARY\n         MVC   DBLEWORD+6(2),BINDATE+2\n         CVB   R2,DBLEWORD\n         ST    R2,BINDAYS          SAVE FOR LATER\n         XR    R1,R1\n         LA    R3,11\nMON2     IC    R1,HMONMSK(R3)      COMPUTE MON AND DAY\n         SR    R2,R1\n         BNP   MONOVR\n         BCT   R3,MON2\n         B     MONOVR+L'MONOVR\nMONOVR   AR    R2,R1               CORRECT OVERDRAW\n         CVD   R2,DBLEWORD         FORMAT DAY\n         UNPK  HCDAYN(2),DBLEWORD+6(2)\n         OI    HCDAYN+1,C'0'       FIX UP SIGN\n         MH    R3,=Y(L'HMONTAB)    GET TABLE OFFSET\n         LA    R3,HMONTAB(R3)      AND POINT AT MONTH\n         MVC   HCMON(L'HCMON),0(R3)     MOVE IT TO HEADING\n         L     R3,BINYEAR          DAY OF WEEK\n         SH    R3,=H'69'\n         BNP   OUTT                MUST BE GREATER OR BAD\n         XR    R2,R2               CLEAR DAY REG\n         D     R2,=F'4'\n         MH    R3,=H'5'\n         AR    R2,R3\n         A     R2,BINDAYS\n         SRDA  R2,32\n         D     R2,=F'7'            MODULO 7 FOR WEEK\n         MH    R2,=Y(L'HDAYTAB)\n         LA    R2,HDAYTAB(R2)      POINT AT TODAY\n         MVC   HCDAY(L'HCDAY),0(R2)     INSERT IN HEADING\n         B     MOVEJD\nOUTT     MVC   HCDAY(L'HCDAY),=CL3'???'\nMOVEJD   MVC   HJDATE,=XL7'4020204B202020'\n         ED    HJDATE,BINDATE+1\n         MVI   HJDATE,C'='\n         L     R1,@TIOT\n         USING TIODSECT,R1\n         MVC   HUSER,TIOCNJOB      MOVE IN USERID\n         DROP  R1\n         MVI   HPAGS,C' '\n         MVC   HPAGE(L'HPAGE),=CL8' '   CLEAR OUT PAGE FIELD\n         MVI   HHEAD1,C'0'         SET DOUBLE SPACE\n         EJECT\n***********************************************************************\n*        PUT OUT FORMAT DATE/TIME HEADING                             *\n***********************************************************************\n         SPACE 1\n         CLI   @RSPONSE,C'R'       IS IT A RESHOW ?\n         BE    CNTNUE              YES\n         CLC   @RSPONSE,PREVIOUS   WAS THE SAME AS PREVIOUS ?\n         BE    CNTNUE              YES\n         MVC   PREVIOUS,@RSPONSE   NO,... NEW PAGE\n         B     SKIPPG\nCNTNUE   CP    HLINE#,=PL2'+35'    EJECT TO BE SCHEDULED ?\n         BNH   NOPAGE              NO,... SKIP PAGE SETTING\nSKIPPG   AP    HPAGE#,=PL1'+1'     BUMP PAGE COUNT\n         MVI   HPAGS,C'/'\n         MVC   HPAGE,=XL6'402020202021' MOVE IN MASK\n         ZAP   DBLEWORD,HPAGE#     MOVE INTO AREA\n         ED    HPAGE,DBLEWORD+5    EDIT IN PAGE NUMBER\n         MVI   HHEAD1,C'1'         SET EJECT\n         ZAP   HLINE#,=PL1'+0'     RESET LINES COUNT\nNOPAGE  $TSWXA 24,EXPAND=ONLY      BACK TO 24-BIT MODE FOR I/O'S\n        PUT    CPYDCB,HHEAD1       PUT OUT TITLE LINE\n        PUT    CPYDCB,HHEAD2       PUT OUT UNDERLINE\n         AP    HLINE#,=PL1'+3'     BUMP LINES COUNT\n         MVI   HLINE,C' '\n         MVC   HLINE+1(L'HLINE-1),HLINE\n        PUT    CPYDCB,HDETAIL      PRINT A BLANK LINE\n         AP    HLINE#,=PL1'+1'     BUMP LINES COUNT\n         EJECT\n***********************************************************************\n*        PUT OUT ENTIRE SCREEN OF DETAIL LINES                        *\n***********************************************************************\n         SPACE 1\n         L     R2,@PUTAREA         SET OUTPUT SCREEN ADDRESS\n         LA    R3,HLINE            SET TARGET LINE ADDRESS\n         L     R4,@HCPY            GET HARDCOPY SCREEN ADDRESS\n         XR    R5,R5               INCREMENT REGISTER\nSCLOOP   BAS   R14,0(R4,R5)        BUILD A LINE\n        PUT    CPYDCB,HDETAIL      PUT DETAIL LINE OUT\n         AP    HLINE#,=PL1'+1'     BUMP LINES COUNT\n         CH    R5,=Y(23*4)         LAST LINE DONE ?\n         BNL   *+L'*+18            YES\n         LA    R5,4(R5)            GO GET NEXT\n         MVI   HLINE,C' '\n         MVC   HLINE+1(L'HLINE-1),HLINE\n         B     SCLOOP\n         SPACE 1\n        $TSWXA 31,EXPAND=ONLY      RESTORE 31-BIT MODE\nRETURN  $XRET  CC=0                B O O G I E\n         EJECT\n***********************************************************************\n*        CHANGE HARDCOPY DEFAULT IF SPECIFIED                         *\n***********************************************************************\n         SPACE 1\nHOPEN    TM    @SWITCH,@HCOPY      IS HARDCOPY ALREADY OPENED ?\n         BO    ERRAO               YES\n         TM    @SWITCH,@BATCH      BATCH RUNNING ?\n         BO    BATCH01             YES\n         LA    R1,P99TUKY3\n         ST    R1,P99TUPL+8\n         MVC   P99DDN,=CL8' '\n         MVC   P99DEST,=CL8' '\n         XC    P99DESTL,P99DESTL\nRESHOW   LA    R0,#SCRNLEN         LOAD SCREEN LENGTH INTO R0\n         LA    R1,#SCREEN          POINT TO SCREEN\n         XR    R2,R2\n         ICM   R2,B'1000',=B'00100011'  BIT SETTINGS FOR PUT TO R2\n         OR    R1,R2               PUT FLAGS IN R1 HI-ORDER BYTE\n        TPUT   (1),(0),R           PUT SCREEN\n         MVI   #MSG,C' '           CLEAR ANY ERROR MSG\n         MVC   #MSG+1(L'#MSG-1),#MSG\n         MVC   #ARROW(L'#ARROW),#MSG\n         XC    GETAREA(GETLEN),GETAREA  CLEAR INPUT BUFFER\n         LA    R0,GETLEN           INPUT BUFFER LENGTH IN R0\n         LA    R1,GETAREA          INPUT BUFFER ADDRESS IN R1\n         XR    R2,R2\n         ICM   R2,B'1000',=B'10100001'  BIT SETTINGS FOR GET TO R2\n         OR    R1,R2               PUT FLAGS IN R1 HI-ORDER BYTE\n        TGET   (1),(0),R           READ SCREEN - WAIT FOR RESPONSE\n         CLI   PFKCODE,X'7D'       SPECIFIC REQUEST ?\n         BE    ENTER               YES\n         CLI   PFKCODE,X'F3'       PF 3 ENTERED ?\n         BE    BACK                YES\n         CLI   PFKCODE,X'C3'       PF 15 ENTERED (ALT. PF 3) ?\n         BE    BACK                YES\n         MVC   #MSG(30),=CL30'INVALID, PLEASE USE ENTER ONLY'\nSETARR   MVC   #ARROW,=CL4'===>'\n         B     RESHOW\nENTER    OI    RSPCLASS,C' '       UPPERCASE DATA\n         OC    RSPDEST,=CL8' '\n         CLI   RSPCLASS,C'A'       IS IT ALPHA ?\n         BL    ERRCL               NO, SYSOUT CLASS ERROR\n         CLC   RSPDEST,=CL8'LOCAL' ANY DESTINATION SPECIFIED ?\n         BE    NODEST\n         CLC   RSPDEST,=CL8' '\n         BE    NODEST\n         LA    R0,L'RSPDEST        SCAN SPECIFIED DESTINATION\n         LA    R1,RSPDEST+L'RSPDEST-1\nSCDEST   CLI   0(R1),C' '\n         BNE   CSDEST\n         BCTR  R1,0\n         BCT   R0,SCDEST\nERRDS    MVC   #MSG(39),=CL39'DESTINATION (        ) ERROR, RESPECIFY'\n         MVC   #MSG+13(L'RSPDEST),RSPDEST\n         B     SETARR\nERRCL    MVC   #MSG(33),=CL33'SYSOUT CLASS ( ) ERROR, RESPECIFY'\n         MVC   #MSG+14(L'RSPCLASS),RSPCLASS\n         B     SETARR\nCSDEST   LR    R2,R0\n         BCTR  R1,0\n         BCT   R0,*+L'*+4\n         B     OKDEST\n         CLI   0(R1),C' '\n         BE    ERRDS\n         B     CSDEST+L'CSDEST\nOKDEST   MVC   P99DEST,RSPDEST     MOVE DESTINATION\n         STCM  R2,B'0011',P99DESTL MOVE LENGTH\n         B     DYALL\nBATCH01  MVI   #MSG,C' '           CLEAR ANY ERROR MSG\n         MVC   #MSG+1(L'#MSG-1),#MSG\n         LA    R2,CPYDCB           ADDRESS OF OUTPUT DCB\n         USING IHADCB,R2           ADDRESSABILITY TO OUTPUT DCB\n         L     R3,@TIOT\n         USING TIODSECT,R3\n         XR    R1,R1\nHCDDS    CLC   TIOELNGH(4),=F'0'\n         BE    HCDDN\n         CLC   TIOEDDNM(L'TIOEDDNM),DCBDDNAM\n         BE    HCDDF\n         IC    R1,TIOELNGH\n         ALR   R3,R1\n         B     HCDDS\n         DROP  R2,R3               KILL DCB ADDRESSABILITY\nHCDDN    MVC   RSPCLASS,@HCLASS    SET SYSOUT CLASS\n         MVC   P99DDN,=CL8' '\nNODEST   MVC   P99TUPL+8(4),P99TUPL+12  OVERRIDE DEST= PARM\nDYALL    MVC   P99SYSOC,RSPCLASS   MOVE SYSOUT CLASS\n         EJECT\n***********************************************************************\n*        ALLOCATE/OPEN AND START HARDCOPY PROCESS                     *\n***********************************************************************\n         SPACE 1\n         XC    P99ERROR,P99ERROR\n         XC    P99INFO,P99INFO\n         LA    1,P99RBPTR          ADDR OF PARM LIST FOR DYNALLOC.\n        DYNALLOC ,\n         LTR   R15,R15             CHECK RETURN CODE ?\n         BNZ   ERRAL               ERROR, CAN DO POST MESSAGE\n         LA    R2,CPYDCB           ADDRESS OF OUTPUT DCB\n         USING IHADCB,R2           ADDRESSABILITY TO OUTPUT DCB\n         MVC   DCBDDNAM,=CL8' '\n         ICM   R1,B'0011',P99DDNL\n         BCT   R1,*+L'*+6\n         MVC   DCBDDNAM(*-*),P99DDN     <<EXECUTED>>\n         EX    R1,*-6              SET DDNAME\nHCDDF   OPEN   (CPYDCB,OUTPUT)     OPEN THE FILE\n         TM    DCBOFLGS,DCBOFOPN   CHECK FOR SUCCESSFUL OPEN\n         BZ    ERROP               BYPASS IF BAD OPEN\n         OI    @SWITCH,@HCOPY      SET HARDCOPY FILE AVAILABLE\n         ZAP   HPAGE#,=PL1'+0'     RESET PAGE NUMBER\n         ZAP   HLINE#,=PL2'+999'   RESET LINES COUNT\n         MVC   @MSG(L'MSSTART),MSSTART  MOVE START MSG\n         CLC   DCBDDNAM,=CL8'VSMHCOPY'\n         BNE   *+L'*+10\n         MVC   @MSG+MSJCL(L'MSJCL),=CL20'PRE-ALLOCATED BY JCL'\n         B     BACK\n         DROP  R2                  KILL DCB ADDRESSABILITY\n         MVC   @MSG+MSCLASS(L'MSCLASS),P99SYSOC   SYSOUT CLASS\n         MVC   @MSG+MSDEST(L'MSDEST),P99DEST\n         CLI   @MSG+MSDEST,C' '    ANY DESTINATION ?\n         BNE   *+L'*+6             YES\n         MVC   @MSG+MSDEST(L'MSDEST),=CL8'LOCAL'  SAY LOCAL\n         B     BACK\nERROP    NI    @SWITCH,255-@HCOPY  TURN OFF HARDCOPY FLAG\n         OI    @SWITCH,@HFAIL      SET HARDCOPY OPEN FAILED FLAG\n         MVC   @MSG(31),=CL31'SORRY, ... HARDCOPY OPEN FAILED'\n         B     BACK\nERRAO    MVC   @MSG(34),=CL34'HARDCOPY IS STILL ALREADY OPENED |'\n         B     BACK\n         EJECT\n***********************************************************************\n*        FORMULATE TEXT FOR SVC99 ALLOCATE FAILURE                    *\n***********************************************************************\n         SPACE 1\nERRAL    TM    @SWITCH,@BATCH      BATCH RUNNING ?\n         BO    *+L'*+10            YES\n         CLC   P99ERROR,=XL2'046C' WAS IT 'RMT NOT DEF TO JES2' ?\n         BE    BADRMT              YES, POST MSG AND EXIT\n         MVC   #MSG(L'MSERR),MSERR\n         CVD   R15,DBLEWORD        CONVERT SVC 99 RETURN CODE\n         MVC   #MSG+MSRC(L'MSRC),=XL4'40202020'   TO DECIMAL\n         ED    #MSG+MSRC(L'MSRC),DBLEWORD+6\n         UNPK  #MSG+MSERC(L'MSERC+1),P99ERROR(3)  ERROR CODE\n         NC    #MSG+MSERC(L'MSERC),=XL4'0F0F0F0F' TO HEX.\n         TR    #MSG+MSERC(L'MSERC),=CL16'0123456789ABCDEF'\n         MVI   #MSG+MSERC+L'MSERC,C' '\n         UNPK  #MSG+MSINFO(L'MSINFO+1),P99INFO(3) INFO CODE\n         NC    #MSG+MSINFO(L'MSINFO),=XL4'0F0F0F0F'    TO HEX.\n         TR    #MSG+MSINFO(L'MSINFO),=CL16'0123456789ABCDEF'\n         MVI   #MSG+MSINFO+L'MSINFO,C' '\n         TM    @SWITCH,@BATCH      BATCH RUNNING ?\n         BZ    SETARR              NO, GO SEND THE MESSAGE\n         MVC   @MSG,#MSG           YES, PASS THE MESSAGE\n         B     BACK\nBADRMT   MVC   #MSG(L'MSNRMT),MSNRMT    MOVE IN NO SUCH REMOTE MSG\n         MVC   #MSG+MSRMTN(L'MSRMTN),P99DEST RMT ASKED FOR\n         B     SETARR              GO SEND THE MESSAGE\n         EJECT\n***********************************************************************\n*        STOP HARDCOPY PROCESS AND FREE SYSOUT FILE                   *\n***********************************************************************\n         SPACE 1\nHCLOSE   TM    @SWITCH,@HCOPY      IS HARDCOPY ACTIVE?\n         BZ    ERRCH               NO\n        CLOSE  (CPYDCB)            CLOSE THE FILE\n        FREEPOOL CPYDCB            FREE THE BUFFERS TOO\n         NI    @SWITCH,255-@HCOPY  TURN OFF HARDCOPY FLAG\n         LA    R2,CPYDCB           ADDRESS OF OUTPUT DCB\n         USING IHADCB,R2           ADDRESSABILITY TO OUTPUT DCB\n         CLC   DCBDDNAM,=CL8'VSMHCOPY'\n         BNE   *+L'*+10\n         MVC   @MSG(36),=CL36'HARDCOPY STOPPED : JCL PRE-ALLOCATED'\n         B     BACK\n         DROP  R2                  KILL DCB ADDRESSABILITY\n         MVC   @MSG(36),=CL36'HARDCOPY STOPPED : SYSOUT NOW FREE''D'\nBACK     MVI   @RSPONSE,C'M'       SHOW PRIMARY MENU\n         B     RETURN\nERRCH    MVC   @MSG(30),=CL30'HARDCOPY IS ALREADY INACTIVE |'\n         B     BACK\n         EJECT\nDBLEWORD DC    D'0'\nTENBYTE  DC    XL10'0'\nFIVEBYTE DC    XL5'0'\nPREVIOUS DC    CL1' '\n         SPACE 1\n         PRINT NOGEN\nCPYDCB   DCB   DDNAME=VSMHCOPY,DSORG=PS,MACRF=(PM),                    1\n               RECFM=FA,LRECL=91,BLKSIZE=91\n         PRINT GEN\n         SPACE 1\nBINYEAR  DC    F'0'\nBINDAYS  DC    F'0'\nBINDATE  DC    F'0'\nHPAGE#   DC    PL3'+1'             PAGE NUMBER\nHLINE#   DC    PL3'+0'             LINES COUNT\nGETAREA  EQU   *\nPFKCODE  DC    XL6'0'\nRSPCLASS DC    XL1'0'\n         DC    XL3'0'\nRSPDEST  DC    XL8'0'\nGETLEN   EQU   *-GETAREA\n         SPACE 1\nP99RBPTR DC    A(X'80000000'+P99RB)     SVC 99 REQUEST BLOCK PTR\nP99RB    DS    0F                  SVC 99 REQUEST BLOCK\n         DC    AL1(P99RBLN)             RB LENGTH IN BYTES\nP99VERB  DC    AL1(S99VRBAL)            VERB CODE (DSNAME ALL.)\nP99FLAG1 DC    AL1(S99NOCNV+S99NOMNT,0) FLAGS 1\nP99ERROR DC    XL2'0'                   ERROR CODE\nP99INFO  DC    XL2'0'                   INFO CODE\nP99TXTPP DC    A(P99TUPL)               POINTER TO TEXT UNIT PTRS\nP99RSVD1 DC    XL4'0'                   RESERVED\nP99FLAG2 DC    XL4'0'                   FLAGS 2\nP99RBLN  EQU   *-P99RB                  RB LENGTH\nP99TUPL  DS    0F                  TEXT UNIT POINTERS\n         DC    A(P99TUKY1)              SYSOUT\n         DC    A(P99TUKY2)              FREE AT CLOSE\n         DC    A(P99TUKY3)              LAST PARM IF NO DEST=\n         DC    A(X'80000000'+P99TUKY4)  LAST PARM IF DEST= GIVEN\nP99TUKY1 DC    AL2(DALSYSOU),AL2(1),AL2(1)\nP99SYSOC DC    C'A'                     SYSOUT=A\nP99TUKY2 DC    AL2(DALCLOSE),AL2(0)     UNALLOC AT CLOSE\nP99TUKY3 DC    AL2(DALSUSER),AL2(1)     OPTIONAL : DEST=RMTXXX\nP99DESTL DC    AL2(*-*)                 LENGTH OF DEST\nP99DEST  DC    CL8' '                   DEST PARAMETER\nP99TUKY4 DC    AL2(DALRTDDN),AL2(1)     DDNAME RETURN\nP99DDNL  DC    AL2(8)                   LENGTH OF DDNAME\nP99DDN   DC    CL8' '                   DDNAME\n         SPACE 1\nHHEAD1   DC    CL1'1',CL10' '      ASA ON HEADING\n         DC    CL20'VSM HARDCOPY : USER='\nHUSER    DC    CL8' ',CL4' '       FOR USERID\n         DC    CL4'DATE'\nHJDATE   DC    CL7' ',CL3' - '\nHTMEHRS  DC    CL2' ',CL1':'\nHTMMINS  DC    CL2' ',CL1':'\nHTMSECS  DC    CL2' ',CL1' '\nHCDAY    DC    CL3' ',CL1' '\nHCMON    DC    CL3' ',CL1' '\nHCDAYN   DC    CL2' ',CL3',19'\nHCYR     DC    CL2' ',CL1' '\nHPAGS    DC    CL1' ',CL2'  '\nHPAGE    DC    CL6' '\n         SPACE 1\nHHEAD2   DC    CL11' ',80C'-'\n         SPACE 1\nHDETAIL  DC    CL11' '\nHLINE    DC    CL80' '             TO HOLD PRINT LINE\n         SPACE 1\nHMONMSK  DC    AL1(31,30,31,30,31,31,30,31,30,31,28,31)\nHDAYTAB  DS    0CL3\n         DC    C'TUEWEDTHUFRISATSUNMON'\nHMONTAB  DS    0CL3\n         DC    C'DECNOVOCTSEPAUGJULJUNMAYAPRMARFEBJAN'\nMSSTART  DC    CL42'HARDCOPY STARTED : SYSOUT=  DEST=         '\nMSJCL    EQU   19,20\nMSCLASS  EQU   26,1\nMSDEST   EQU   33,8\nMSERR    DC    CL50'HARDCOPY ALL. ERR. : DARC=     INFO=     R15=     '\nMSERC    EQU   26,4\nMSINFO   EQU   36,4\nMSRC     EQU   45,4\nMSNRMT   DC    CL50'HARDCOPY ERR. : REMOTE          UNDEFINED TO JES2 '\nMSRMTN   EQU   23,8\n         SPACE 1\n#SCREEN  DS    0F\n         $FS   WCC=(KBR,RMDT),MF=L\n         $FS   SBA=(1,1),RA=(1,1,00),MF=L\n         $FS   SBA=(1,1),SF=(PROT),MF=L\n         $FS   SBA=(1,25),SF=(PROT,INT),MF=L\n         $FS   TEXT='VSM - HARDCOPY SELECT OPTIONS',MF=L\n         $FS   SF=(PROT),MF=L\n         $FS   SBA=(5,10),TEXT='SYSOUT CLASS =',MF=L\n         $FS   SF=(INT,MDT),TEXT='A',MF=L\n         $FS   SF=(PROT),MF=L\n         $FS   SBA=(7,11),TEXT='DESTINATION =',MF=L\n         $FS   SF=(INT,MDT),TEXT='LOCAL   ',MF=L\n         $FS   SF=(PROT),MF=L\n         $FS   SBA=(11,1),SF=(PROT,INT),MF=L\n#ARROW   $FS   TEXT=(' ',4),MF=L\n         $FS   SF=(PROT),MF=L\n#MSG     $FS   TEXT=(' ',50),MF=L\n         $FS   SBA=(15,1),SF=(PROT,INT),TEXT='PFK-3/15',MF=L\n         $FS   SF=(PROT),TEXT='ALLOWS YOU TO NULLIFY ',MF=L\n         $FS   TEXT='THE START HARDCOPY',MF=L\n         $FS   SBA=(1,1),SF=(PT,IC),MF=L\n#SCRNLEN EQU   *-#SCREEN\n         EJECT\n         LTORG\n         EJECT\n         $LNKSECT                  LINKAGE SECTION DSECT\n         SPACE 2\n         PRINT NOGEN\n         CVT   DSECT=YES,LIST=YES\nTIODSECT DSECT\n         IEFTIOT1\n         IEFZB4D0\n         IEFZB4D2\n         DCBD  DSORG=PS,DEVD=DA\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "VSM88000": {"ttr": 20487, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x882?\\x00\\x882?\\x144\\x00\\x93\\x00\\x93\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-11-18T00:00:00", "modifydate": "1988-11-18T14:34:00", "lines": 147, "newlines": 147, "modlines": 0, "user": "SYSPAJA"}, "text": "VSM8     TITLE 'VSM88000 - DEBUGING AID MODULE.'\n         PRINT OFF\n         COPY  VSMMAC\n         PRINT ON\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*    MODULE :           VSM88000                                      *\n*                       VERSION : 1.0                                 *\n*                       DATE : 12 NOV 1986                            *\n*                       NAME : DEBUGING AID MODULE                    *\n*                       ATTRIBUTES : REUS                             *\n*                                                                     *\n*    AUTHOR :           MOINIL P.A. - COMPUTING CENTRE                *\n*                       J.R.C. - ISPRA ESTABLISHMENT                  *\n*                       21020 ISPRA (VA), ITALY                       *\n*                                                                     *\n*    FUNCTION :         THIS MODULE TAKES SNAP-DUMPS FOR TEST AND     *\n*                       DEBUG OF VSM. THE SNAP-DUMP START-END         *\n*                       ADDRESSES ARE PASSED TO VSM88000 VIA THE      *\n*                       LINKAGE AREA.                                 *\n*                                                                     *\n*    NOTE :             THE FOLLOWING ALLOCATION IS NEEDED TO         *\n*                       OBTAIN THE SNAP DUMPS :                       *\n*                            ALLOC F(SYSSNAP) SYSOUT=A                *\n*                       OR : ALLOC F(SYSSNAP) DA(...) OLD             *\n*                                                                     *\n*    REGS AT ENTRY :    R0   - SNAP-ID NUMBER (0-255)                 *\n*                              IF NEGATIVE = CLOSE REQUEST            *\n*                       R1   - INTER MODULE LINKAGE                   *\n*                       R14  - RETURN ADDRESS                         *\n*                       R15  - EPA                                    *\n*                                                                     *\n*    REGS USAGE :       R0   - WORK REGSITER                          *\n*                       R1   - POINTER TO INTER MODULE LINKAGE        *\n*                       R2-R6 - WORK REGISTERS                        *\n*                       R10  - LINKAGE AREA POINTER                   *\n*                       R11  - BASE REGISTER                          *\n*                       R12  - 2ND BASE REGISTER (RESERVED)           *\n*                       R13  - SAVE AREA POINTER                      *\n*                                                                     *\n*    REGS AT EXIT :     R14  - RETURN ADDRESS                         *\n*                                                                     *\n*    LABELS :           SOME OF THE FIELD USAGE IN THIS MODULE CAN    *\n*                       BE DETERMINED BY THE FIRST CHARACTER OF THE   *\n*                       FIELD. THE KEYS ARE :                         *\n*                            @ - FIELD IS IN INTER MODULE LINKAGE     *\n*                                AREA                                 *\n*                            # - FIELD IS PART OF THE OUTPUT SCREEN   *\n*                            $ - DSECT                                *\n*                                                                     *\n***********************************************************************\n         EJECT\nVSM88000 START 0\n         SPACE 1\n        $DEFREG\n***********************************************************************\n*        STANDARD OS LINKAGE                                          *\n***********************************************************************\n         SPACE 1\n        $XENT  BASE=R11            SAVE CALLER'S REGS\n         EJECT\n         LR    R10,R1              POINT TO LINKAGE\n         USING $LNKSECT,R10        DSECT ADDRESSABILITY\n         LTR   R4,R0               TEST AND SAVE SNAP-ID NUMBER\n         BM    SNAPCL              BRANCH IF CLOSE REQUESTED\n         TM    @SWITCH,@SNPFNA     FUNCTION INACTIVE ?\n         BO    RETURN              YES, BYPASS\n         LA    R2,SNAPDCB\n         USING IHADCB,R2\n         TM    @SWITCH,@SNPOPN     DATA-SET ALREADY OPENED ?\n         BO    SNO                 YES\n         L     R3,@TIOT\n         USING TIODSECT,R3\n         XR    R1,R1\nSNS      CLC   TIOELNGH(4),=F'0'\n         BE    SNN\n         CLC   TIOEDDNM(L'TIOEDDNM),DCBDDNAM\n         BE    SNF\n         IC    R1,TIOELNGH\n         ALR   R3,R1\n         B     SNS\n         DROP  R3\nSNF     OPEN   (SNAPDCB,OUTPUT)\n         TM    DCBOFLGS,DCBOFOPN   SUCCESSFULLY OPENED ?\n         BZ    SNN                 NO\n         DROP  R2\n         OI    @SWITCH,@SNPOPN     INDICATE DATA-SET OPENED\nSNO      CH    R4,SNAPMAX          KNOWN ID NUMBER ?\n         BL    SNI                 YES\n         XR    R4,R4\n         LA    R6,SNAPUN\n         B     SNG\nSNI      LR    R6,R4\n         MH    R6,SNAPTLE\n         LA    R6,SNAPTB(R6)\n         TM    0(R6),X'80'         UNUSED ELEMENT ?\n         BZ    RETURN              YES, BYPASS\nSNG      LA    R5,@SNPLST\n        SNAP   TCB='S',ID=(R4),LIST=(R5),STRHDR=(R6),MF=(E,SNAPLIST)\n         LTR   R15,R15             ALL OK ?\n         BZ    RETURN              YES\nSNN      OI    @SWITCH,@SNPFNA     INACTIVE FUNCTION\nRETURN  $XRET  CC=0                B O O G I E\n         SPACE 2\nSNAPCL   TM    @SWITCH,@SNPOPN     DATA-SET IS OPENED ?\n         BZ    RETURN              NO\n        CLOSE  (SNAPDCB)\n         B     SNN\n         EJECT\n         PRINT NOGEN\nSNAPDCB  DCB   DSORG=PS,RECFM=VBA,MACRF=(W),                           1\n               BLKSIZE=1632,LRECL=125,DDNAME=SYSSNAP\nSNAPLIST SNAP  DCB=SNAPDCB,MF=L\n         PRINT GEN\n         SPACE 1\nSNAPTB   DS    0F\n         DC    XL1'80',AL3(SHD0)\n         DC    XL1'80',AL3(SHD1)\n         DC    XL1'80',AL3(SHD2)\n         DC    XL1'80',AL3(SHD3)\nSNAPTBM  EQU   (*-SNAPTB)/L'SNAPTB NUMBER OF ELEMENTS\nSNAPUN   DC    XL1'80',AL3(SHDU)\n         SPACE 1\nSNAPTLE  DC    Y(L'SNAPTB)         ELEMENT LENGTH\nSNAPMAX  DC    Y(SNAPTBM)          NUMBER OF ELEMENTS (MAX ID)\nSHD0     DC    AL1(L'SHD0T)\nSHD0T    DC    C'V S M - REGSITERS 0-15 CONTENTS AT TIME OF ERROR.'\nSHD1     DC    AL1(L'SHD1T)\nSHD1T    DC    C'V S M - DUMP OF GLOBAL DATA AREA (GDA).'\nSHD2     DC    AL1(L'SHD2T)\nSHD2T    DC    C'V S M - DUMP OF VSMLIST WORK AREA (SP=SQA).'\nSHD3     DC    AL1(L'SHD3T)\nSHD3T    DC    C'V S M - DUMP OF VSMLIST WORK AREA (SP=CSA).'\nSHDU     DC    AL1(L'SHDUT)\nSHDUT    DC    C'V S M - DUMP OF ??? (UNKNOWN).'\n         EJECT\n         LTORG\n         SPACE 2\n         $LNKSECT                  LINKAGE SECTION DSECT\n         SPACE 2\n         PRINT NOGEN\nTIODSECT DSECT\n         IEFTIOT1\n         DCBD  DSORG=PS,DEVD=DA\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "VSM99000": {"ttr": 20491, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x882?\\x00\\x882?\\x144\\x00\\xaa\\x00\\xaa\\x00\\x00\\xe2\\xe8\\xe2\\xd7\\xc1\\xd1\\xc1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1988-11-18T00:00:00", "modifydate": "1988-11-18T14:34:00", "lines": 170, "newlines": 170, "modlines": 0, "user": "SYSPAJA"}, "text": "VSM9     TITLE 'VSM99000 - TERMINAL I/O MODULE.'\n         PRINT OFF                                                 -EU-\n         COPY  VSMMAC                                              -EU-\n         PRINT ON                                                  -EU-\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*    MODULE :           VSM99000                                      *\n*                       VERSION : 1.1                                 *\n*                       DATE : 06 JUL 1984                            *\n*                       NAME : TERMINAL I/O MODULE                    *\n*                       ATTRIBUTES : REUS                             *\n*                                                                     *\n*    AUTHOR :           R.P. SHANNON (VERSION 1.0 - 9/1/82)           *\n*                       HALLMARK CARDS                                *\n*                       ENFIELD DISTRIBUTION CENTER                   *\n*                                                                     *\n*    FUNCTION :         THIS MODULE DOES ALL THE TERMINAL I/O FOR     *\n*                       VSM. THE SCREEN ADDRESSES AND LENGTHS ARE     *\n*                       PASSED TO VSM99000 VIA THE LINKAGE AREA.      *\n*                                                                     *\n*    REGS AT ENTRY :    R1   - INTER MODULE LINKAGE                   *\n*                       R14  - RETURN ADDRESS                         *\n*                       R15  - EPA                                    *\n*                                                                     *\n*    REGS USAGE :       R0   - SCREEN LENGTH FOR I/O                  *\n*                       R1   - SCREEN ADDR FOR I/O                    *\n*                       R2   - TGET/TPUT FLAGS                        *\n*                       R10  - LINKAGE AREA POINTER                   *\n*                       R11  - BASE REGISTER                          *\n*                       R12  - 2ND BASE REGISTER (RESERVED)           *\n*                       R13  - SAVE AREA POINTER                      *\n*                                                                     *\n*    REGS AT EXIT :     R14  - RETURN ADDRESS                         *\n*                                                                     *\n*    LABELS :           SOME OF THE FIELD USAGE IN THIS MODULE CAN    *\n*                       BE DETERMINED BY THE FIRST CHARACTER OF THE   *\n*                       FIELD. THE KEYS ARE :                         *\n*                            @ - FIELD IS IN INTER MODULE LINKAGE     *\n*                                AREA                                 *\n*                            # - FIELD IS PART OF THE OUTPUT SCREEN   *\n*                            $ - DSECT                                *\n*                                                                     *\n*    MODS : VERSION 1.0  - BASE                                       *\n*           VERSION 1.1  - PFK'S ADDED AND BATCH RUN ALLOWED      -EU-*\n*                          MOINIL P.A. - COMPUTING CENTRE         -EU-*\n*                          J.R.C. - ISPRA ESTABLISHMENT           -EU-*\n*                          21020 ISPRA (VA), ITALY                -EU-*\n*                                                                     *\n***********************************************************************\n         EJECT\nVSM99000 START 0\n         SPACE 1\n        $DEFREG ,                                                  -EU-\n***********************************************************************\n*        STANDARD OS LINKAGE                                          *\n***********************************************************************\n         SPACE 1\n        $XENT  BASE=R11            SAVE CALLER'S REGS              -EU-\n         EJECT\n         LR    R10,R1              POINT TO LINKAGE\n         USING $LNKSECT,R10        DSECT ADDRESSABILITY\n         TM    @SWITCH,@BATCH      BATCH RUNNING ?                 -EU-\n         BO    BATCH01             YES                             -EU-\n         MVI   @RSPONSE,C' '       CLEAR RESPONSE\n         L     R0,@PUTLEN          LOAD SCREEN LENGTH INTO R0\n         L     R1,@PUTAREA         POINT TO SCREEN\n         XR    R2,R2\n         ICM   R2,B'1000',=B'00100011'  BIT SETTINGS FOR PUT TO R2\n         OR    R1,R2               PUT FLAGS IN R1 HI-ORDER BYTE\n         TPUT  (1),(0),R           PUT SCREEN\n         LA    R0,@GETLEN          INPUT BUFFER LENGTH IN R0\n         LA    R1,@GETAREA         INPUT BUFFER ADDR IN R1\n         XR    R2,R2\n         ICM   R2,B'1000',=B'10100001'  BIT SETTINGS FOR GET TO R2\n         OR    R1,R2               PUT FLAGS IN R1 HI-ORDER BYTE\n         TGET  (1),(0),R           READ SCREEN - WAIT FOR RESPONSE\n         CLI   @PFKCODE,X'7D'      SPECIFIC REQUEST ?              -EU-\n         BE    ENTER               YES                             -EU-\n         CLI   @PFKCODE,X'6E'      PA 2 ENTERED ?                  -EU-\n         BE    ENTER               YES                             -EU-\n         CLI   @PFKCODE,X'F1'      PF 1 ENTERED ?                  -EU-\n         BE    SETH                YES                             -EU-\n         CLI   @PFKCODE,X'C1'      PF 13 ENTERED (ALT. PF 1) ?     -EU-\n         BE    SETH                YES                             -EU-\n         CLI   @PFKCODE,X'F2'      PF 2 ENTERED ?                  -EU-\n         BE    SETM                YES                             -EU-\n         CLI   @PFKCODE,X'C2'      PF 14 ENTERED (ALT. PF 2) ?     -EU-\n         BE    SETM                YES                             -EU-\n         CLI   @PFKCODE,X'F3'      PF 3 ENTERED ?                  -EU-\n         BE    SETZ                YES                             -EU-\n         CLI   @PFKCODE,X'C3'      PF 15 ENTERED (ALT. PF 3) ?     -EU-\n         BE    SETZ                YES                             -EU-\n         CLI   @PFKCODE,X'F7'      PF 7 ENTERED ?                  -EU-\n         BE    SETS                YES                             -EU-\n         CLI   @PFKCODE,X'C7'      PF 19 ENTERED (ALT. PF 7) ?     -EU-\n         BE    SETS                YES                             -EU-\n         CLI   @PFKCODE,X'F8'      PF 8 ENTERED ?                  -EU-\n         BE    SETP                YES                             -EU-\n         CLI   @PFKCODE,X'C8'      PF 20 ENTERED (ALT. PF 8) ?     -EU-\n         BE    SETP                YES                             -EU-\n         CLI   @PFKCODE,X'7A'      PF 10 ENTERED ?                 -EU-\n         BE    SET1                YES                             -EU-\n         CLI   @PFKCODE,X'4A'      PF 22 ENTERED (ALT. PF 10) ?    -EU-\n         BE    SET1                YES                             -EU-\n         CLI   @PFKCODE,X'7B'      PF 11 ENTERED ?                 -EU-\n         BE    SET2                YES                             -EU-\n         CLI   @PFKCODE,X'4B'      PF 23 ENTERED (ALT. PF 11) ?    -EU-\n         BE    SET2                YES                             -EU-\n         CLI   @PFKCODE,X'7C'      PF 12 ENTERED ?                 -EU-\n         BE    SET3                YES                             -EU-\n         CLI   @PFKCODE,X'4C'      PF 24 ENTERED (ALT. PF 12) ?    -EU-\n         BE    SET3                YES                             -EU-\n         MVI   @RSPONSE,C'?'       SET INVALID RESPONSE            -EU-\n         B     RETURN                                              -EU-\nSETH     MVI   @RSPONSE,C'H'       SET HELP                        -EU-\n         B     RETURN                                              -EU-\nSETM     MVI   @RSPONSE,C'M'       SET PRIMARY                     -EU-\n         B     RETURN                                              -EU-\nSETP     MVI   @RSPONSE,C'P'       SET STOP HARDCOPY               -EU-\n         B     RETURN                                              -EU-\nSETS     MVI   @RSPONSE,C'S'       SET START HARDCOPY              -EU-\n         B     RETURN                                              -EU-\nSETZ     MVI   @RSPONSE,C'Z'       SET TERMINATION                 -EU-\n         B     RETURN                                              -EU-\nSET1     MVI   @RSPONSE,C'1'       SET MAP VS                      -EU-\n         B     RETURN                                              -EU-\nSET2     MVI   @RSPONSE,C'2'       SET MAP SUBPOOL                 -EU-\n         B     RETURN                                              -EU-\nSET3     MVI   @RSPONSE,C'3'       SET MAP CSA                     -EU-\n         B     RETURN                                              -EU-\nBATCH01  L     R1,@PPTR            NEXT COMMAND IF ANY             -EU-\n         XR    R0,R0                                               -EU-\n         IC    R0,@SBXQ(R1)                                        -EU-\n         LTR   R0,R0               END OF PARM. ?                  -EU-\n         BNZ   BATCH02             NO, CONTINUE                    -EU-\n         MVI   @RSPONSE,C'Z'       TERMINATION                     -EU-\n         B     ENTER                                               -EU-\nBATCH02  STC   R0,@RSPONSE                                         -EU-\n         LA    R1,1(R1)                                            -EU-\n         ST    R1,@PPTR                                            -EU-\nENTER    TR    @RSPONSE,TRTABLE    TRANSLATE TO UPPER CASE         -EU-\n         CLI   @RSPONSE,C' '       JUST ENTER ?                    -EU-\n         BNE   RETURN              NO                              -EU-\n         MVI   @RSPONSE,C'R'       SET REFRESH                     -EU-\nRETURN  $XRET  CC=0                B O O G I E                     -EU-\n         EJECT\nTRTABLE  DS    0CL256              UPPER CASE TRANSLATE TABLE\n         DC    X'000102030405060708090A0B0C0D0E0F'\n         DC    X'101112131415161718191A1B1C1D1E1F'\n         DC    X'202122232425262728292A2B2C2D2E2F'\n         DC    X'303132333435363738393A3B3C3D3E3F'\n         DC    X'404142434445464748494A4B4C4D4E4F'\n         DC    X'505152535455565758595A5B5C5D5E5F'\n         DC    X'606162636465666768696A6B6C6D6E6F'\n         DC    X'707172737475767778797A7B7C7D7E7F'\n         DC    X'80C1C2C3C4C5C6C7C8C98A8B8C8D8E8F'\n         DC    X'90D1D2D3D4D5D6D7D8D99A9B9C9D9E9F'\n         DC    X'A0A1E2E3E4E5E6E7E8E9AAABACADAEAF'\n         DC    X'B0B1B2B3B4B5B6B7B8B9BABBBCBDBEBF'\n         DC    X'C0C1C2C3C4C5C6C7C8C9CACBCCCDCECF'\n         DC    X'D0D1D2D3D4D5D6D7D8D9DADBDCDDDEDF'\n         DC    X'E0E1E2E3E4E5E6E7E8E9EAEBECEDEEEF'\n         DC    X'F0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFF'\n         SPACE 2\n         LTORG\n         SPACE 2\n         $LNKSECT                  LINKAGE SECTION DSECT\n         SPACE 2\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT455/FILE455.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT455", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}