{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220011717000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 1646008, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 8, "INMDSNAM": "CBT.V500.FILE309.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 1646008, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 1646008, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE309.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x1a\\n'", "DS1TRBAL": "b' \\xf0'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x02)\\x00\\r\\x02+\\x00\\t\\x00\\x1b'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"ALGOLGEN": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x98\\x01\\x9f\\x00\\x98\\x01\\x9f\\x12\\x19\\x04\\xaf\\x04\\xaf\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1998-01-19T00:00:00", "modifydate": "1998-01-19T12:19:00", "lines": 1199, "newlines": 1199, "modlines": 0, "user": "SBGOLOB"}, "text": "//SBGOLOBA  JOB (ACCT#),S-GOLOB,\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X\n//*\n//*    RE-LINKEDIT OF THE OS/360 IBM ALGOL COMPILER AND LIBRARY.\n//*    (SUBSTITUTE GEN  -  USE WITH SOURCE CODE ON FILE 309, 310)\n//*\n//*    THIS JOB WAS GENERATED BY STARTOOL VERSION 5.2.0.\n//*    YOU CAN ALSO USE PDS 8.5   MAP : RELINK AGAINST FILE 176.\n//*\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.FILE176.PDS\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.ALGOL.LOADLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB(IEX00)\n ORDER   IEX00001,IEX00000\n ENTRY   IEX00000\n ALIAS   ALGOL(IEX00000)\n NAME    IEX00(R)\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.FILE176.PDS\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.ALGOL.LOADLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB(IEX00)\n ORDER   IEX00001,IEX00000\n ENTRY   IEX00000\n ALIAS   ALGOL(IEX00000)\n NAME    IEX00(R)\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.FILE176.PDS\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.ALGOL.LOADLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB(IEX10)\n ORDER   IEX10000,IEX10001\n SETSSI  00015216\n ENTRY   IEX10000\n ALIAS   IEX10000\n NAME    IEX10(R)\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.FILE176.PDS\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.ALGOL.LOADLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB(IEX10)\n ORDER   IEX10000,IEX10001\n SETSSI  00015216\n ENTRY   IEX10000\n ALIAS   IEX10000\n NAME    IEX10(R)\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.FILE176.PDS\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.ALGOL.LOADLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB(IEX11)\n ORDER   IEX11000,IEX11001,IEX11002,IEX11003\n SETSSI  03012827\n ENTRY   IEX11000\n ALIAS   IEX11000\n NAME    IEX11(R)\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.FILE176.PDS\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.ALGOL.LOADLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB(IEX11)\n ORDER   IEX11000,IEX11001,IEX11002,IEX11003\n SETSSI  03012827\n ENTRY   IEX11000\n ALIAS   IEX11000\n NAME    IEX11(R)\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.FILE176.PDS\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.ALGOL.LOADLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB(IEX20)\n ORDER   IEX20000\n SETSSI  01010360\n ENTRY   IEX20000\n ALIAS   IEX20000\n NAME    IEX20(R)\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.FILE176.PDS\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.ALGOL.LOADLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB(IEX20)\n ORDER   IEX20000\n SETSSI  01010360\n ENTRY   IEX20000\n ALIAS   IEX20000\n NAME    IEX20(R)\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.FILE176.PDS\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.ALGOL.LOADLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB(IEX21)\n ORDER   IEX21000,IEX60000,IEX21M00\n ENTRY   IEX21000\n ALIAS   IEX21000\n NAME    IEX21(R)\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.FILE176.PDS\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.ALGOL.LOADLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB(IEX21)\n ORDER   IEX21000,IEX60000,IEX21M00\n ENTRY   IEX21000\n ALIAS   IEX21000\n NAME    IEX21(R)\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.FILE176.PDS\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.ALGOL.LOADLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB(IEX30)\n ORDER   IEX30000,IEX30001,IEX30002\n SETSSI  03012812\n ENTRY   IEX30000\n ALIAS   IEX30000\n NAME    IEX30(R)\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.FILE176.PDS\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.ALGOL.LOADLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB(IEX30)\n ORDER   IEX30000,IEX30001,IEX30002\n SETSSI  03012812\n ENTRY   IEX30000\n ALIAS   IEX30000\n NAME    IEX30(R)\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.FILE176.PDS\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.ALGOL.LOADLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB(IEX31)\n ORDER   IEX31000,IEX60000,IEX31M00\n ENTRY   IEX31000\n ALIAS   IEX31000\n NAME    IEX31(R)\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.FILE176.PDS\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.ALGOL.LOADLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB(IEX31)\n ORDER   IEX31000,IEX60000,IEX31M00\n ENTRY   IEX31000\n ALIAS   IEX31000\n NAME    IEX31(R)\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.FILE176.PDS\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.ALGOL.LOADLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB(IEX40)\n ORDER   IEX40000,IEX40001\n SETSSI  01010770\n ENTRY   IEX40000\n ALIAS   IEX40000\n NAME    IEX40(R)\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.FILE176.PDS\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.ALGOL.LOADLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB(IEX40)\n ORDER   IEX40000,IEX40001\n SETSSI  01010770\n ENTRY   IEX40000\n ALIAS   IEX40000\n NAME    IEX40(R)\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.FILE176.PDS\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.ALGOL.LOADLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB(IEX50)\n ORDER   IEX50000,IEX50001,IEX50002,IEX50003,IEX50004,IEX50005\n ORDER   IEX50006\n SETSSI  01012912\n ENTRY   IEX50000\n ALIAS   IEX50000\n NAME    IEX50(R)\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.FILE176.PDS\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.ALGOL.LOADLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB(IEX50)\n ORDER   IEX50000,IEX50001,IEX50002,IEX50003,IEX50004,IEX50005\n ORDER   IEX50006\n SETSSI  01012912\n ENTRY   IEX50000\n ALIAS   IEX50000\n NAME    IEX50(R)\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.FILE176.PDS\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.ALGOL.LOADLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB(IEX51)\n ORDER   IEX51000,IEX60000,IEX51002,IEX51M00\n ENTRY   IEX51000\n ALIAS   IEX51ER1,IEX51ER2,IEX51000,IEX51002\n NAME    IEX51(R)\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.FILE176.PDS\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.ALGOL.LOADLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB(IEX51)\n ORDER   IEX51000,IEX60000,IEX51002,IEX51M00\n ENTRY   IEX51000\n ALIAS   IEX51ER1,IEX51ER2,IEX51000,IEX51002\n NAME    IEX51(R)\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.FILE176.PDS\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.ALGOL.LOADLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB(IEX51)\n ORDER   IEX51000,IEX60000,IEX51002,IEX51M00\n ENTRY   IEX51000\n ALIAS   IEX51ER1,IEX51ER2,IEX51000,IEX51002\n NAME    IEX51(R)\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.FILE176.PDS\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.ALGOL.LOADLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB(IEX51)\n ORDER   IEX51000,IEX60000,IEX51002,IEX51M00\n ENTRY   IEX51000\n ALIAS   IEX51ER1,IEX51ER2,IEX51000,IEX51002\n NAME    IEX51(R)\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.FILE176.PDS\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.ALGOL.LOADLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB(IEX51)\n ORDER   IEX51000,IEX60000,IEX51002,IEX51M00\n ENTRY   IEX51000\n ALIAS   IEX51ER1,IEX51ER2,IEX51000,IEX51002\n NAME    IEX51(R)\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET,REUS'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.FILE176.PDS\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.ALGOL.LOADLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB(IHIFDD)\n ORDER   IHIFDDXP\n SETSSI  00015176\n ENTRY   IHIFDDXP\n NAME    IHIFDD(R)\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET,REUS'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.FILE176.PDS\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.ALGOL.LOADLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB(IHIFDI)\n ORDER   IHIFDIXP\n SETSSI  00015177\n ENTRY   IHIFDIXP\n NAME    IHIFDI(R)\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET,REUS'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.FILE176.PDS\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.ALGOL.LOADLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB(IHIFII)\n ORDER   IHIFIIXP\n SETSSI  00015178\n ENTRY   IHIFIIXP\n NAME    IHIFII(R)\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET,REUS'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.FILE176.PDS\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.ALGOL.LOADLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB(IHIFRI)\n ORDER   IHIFRIXP\n SETSSI  00015179\n ENTRY   IHIFRIXP\n NAME    IHIFRI(R)\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET,REUS'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.FILE176.PDS\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.ALGOL.LOADLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB(IHIFRR)\n ORDER   IHIFRRXP\n SETSSI  00015180\n ENTRY   IHIFRRXP\n NAME    IHIFRR(R)\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET,REUS'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.FILE176.PDS\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.ALGOL.LOADLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB(IHIFSA)\n ORDER   IHIFSARA,IHIFSARB\n SETSSI  03012912\n ENTRY   IHIFSARA\n ALIAS   IHIFSAIN\n NAME    IHIFSA(R)\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET,REUS'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.FILE176.PDS\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.ALGOL.LOADLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB(IHIFSA)\n ORDER   IHIFSARA,IHIFSARB\n SETSSI  03012912\n ENTRY   IHIFSARA\n ALIAS   IHIFSAIN\n NAME    IHIFSA(R)\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET,REUS'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.FILE176.PDS\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.ALGOL.LOADLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB(IHIGPR)\n ORDER   IHIGPRTN\n SETSSI  01010040\n ENTRY   IHIGPRPT\n ALIAS   IHIGPRCL,IHIGPRGT,IHIGPRPT(IHIGPRTN)\n NAME    IHIGPR(R)\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET,REUS'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.FILE176.PDS\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.ALGOL.LOADLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB(IHIGPR)\n ORDER   IHIGPRTN\n SETSSI  01010040\n ENTRY   IHIGPRPT\n ALIAS   IHIGPRCL,IHIGPRGT,IHIGPRPT(IHIGPRTN)\n NAME    IHIGPR(R)\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET,REUS'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.FILE176.PDS\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.ALGOL.LOADLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB(IHIGPR)\n ORDER   IHIGPRTN\n SETSSI  01010040\n ENTRY   IHIGPRPT\n ALIAS   IHIGPRCL,IHIGPRGT,IHIGPRPT(IHIGPRTN)\n NAME    IHIGPR(R)\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET,REUS'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.FILE176.PDS\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.ALGOL.LOADLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB(IHIGPR)\n ORDER   IHIGPRTN\n SETSSI  01010040\n ENTRY   IHIGPRPT\n ALIAS   IHIGPRCL,IHIGPRGT,IHIGPRPT(IHIGPRTN)\n NAME    IHIGPR(R)\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET,REUS'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.FILE176.PDS\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.ALGOL.LOADLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB(IHIIAR)\n ORDER   IHIIARTN\n SETSSI  00015183\n ENTRY   IHIIARRT\n ALIAS   IHIIARRT(IHIIARTN),IHIIARRY\n NAME    IHIIAR(R)\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET,REUS'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.FILE176.PDS\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.ALGOL.LOADLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB(IHIIAR)\n ORDER   IHIIARTN\n SETSSI  00015183\n ENTRY   IHIIARRT\n ALIAS   IHIIARRT(IHIIARTN),IHIIARRY\n NAME    IHIIAR(R)\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET,REUS'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.FILE176.PDS\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.ALGOL.LOADLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB(IHIIAR)\n ORDER   IHIIARTN\n SETSSI  00015183\n ENTRY   IHIIARRT\n ALIAS   IHIIARRT(IHIIARTN),IHIIARRY\n NAME    IHIIAR(R)\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET,REUS'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.FILE176.PDS\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.ALGOL.LOADLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB(IHIIBA)\n ORDER   IHIIBARR\n SETSSI  00015184\n ENTRY   IHIIBARR\n ALIAS   IHIIBARR\n NAME    IHIIBA(R)\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET,REUS'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.FILE176.PDS\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.ALGOL.LOADLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB(IHIIBA)\n ORDER   IHIIBARR\n SETSSI  00015184\n ENTRY   IHIIBARR\n ALIAS   IHIIBARR\n NAME    IHIIBA(R)\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET,REUS'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.FILE176.PDS\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.ALGOL.LOADLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB(IHIIBO)\n ORDER   IHIIBOOL\n SETSSI  02013610\n ENTRY   IHIIBOOL\n ALIAS   IHIIBOAR,IHIIBOOL\n NAME    IHIIBO(R)\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET,REUS'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.FILE176.PDS\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.ALGOL.LOADLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB(IHIIBO)\n ORDER   IHIIBOOL\n SETSSI  02013610\n ENTRY   IHIIBOOL\n ALIAS   IHIIBOAR,IHIIBOOL\n NAME    IHIIBO(R)\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET,REUS'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.FILE176.PDS\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.ALGOL.LOADLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB(IHIIBO)\n ORDER   IHIIBOOL\n SETSSI  02013610\n ENTRY   IHIIBOOL\n ALIAS   IHIIBOAR,IHIIBOOL\n NAME    IHIIBO(R)\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET,REUS'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.FILE176.PDS\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.ALGOL.LOADLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB(IHIIDE)\n ORDER   IHIIDECM\n SETSSI  02013491\n ENTRY   IHIIDEAI\n ALIAS   IHIIDEAI(IHIIDECM),IHIIDEII,IHIIDEIR\n NAME    IHIIDE(R)\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET,REUS'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.FILE176.PDS\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.ALGOL.LOADLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB(IHIIDE)\n ORDER   IHIIDECM\n SETSSI  02013491\n ENTRY   IHIIDEAI\n ALIAS   IHIIDEAI(IHIIDECM),IHIIDEII,IHIIDEIR\n NAME    IHIIDE(R)\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET,REUS'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.FILE176.PDS\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.ALGOL.LOADLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB(IHIIDE)\n ORDER   IHIIDECM\n SETSSI  02013491\n ENTRY   IHIIDEAI\n ALIAS   IHIIDEAI(IHIIDECM),IHIIDEII,IHIIDEIR\n NAME    IHIIDE(R)\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET,REUS'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.FILE176.PDS\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.ALGOL.LOADLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB(IHIIDE)\n ORDER   IHIIDECM\n SETSSI  02013491\n ENTRY   IHIIDEAI\n ALIAS   IHIIDEAI(IHIIDECM),IHIIDEII,IHIIDEIR\n NAME    IHIIDE(R)\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET,REUS'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.FILE176.PDS\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.ALGOL.LOADLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB(IHIIOR)\n ORDER   IHIIORTN\n SETSSI  01010360\n ENTRY   IHIIOROQ\n ALIAS   IHIIOREN,IHIIOREV,IHIIORNX,IHIIOROP\n NAME    IHIIOR(R)\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET,REUS'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.FILE176.PDS\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.ALGOL.LOADLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB(IHIIOR)\n ORDER   IHIIORTN\n SETSSI  01010360\n ENTRY   IHIIOROQ\n ALIAS   IHIIOREN,IHIIOREV,IHIIORNX,IHIIOROP\n NAME    IHIIOR(R)\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET,REUS'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.FILE176.PDS\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.ALGOL.LOADLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB(IHIIOR)\n ORDER   IHIIORTN\n SETSSI  01010360\n ENTRY   IHIIOROQ\n ALIAS   IHIIOREN,IHIIOREV,IHIIORNX,IHIIOROP\n NAME    IHIIOR(R)\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET,REUS'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.FILE176.PDS\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.ALGOL.LOADLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB(IHIIOR)\n ORDER   IHIIORTN\n SETSSI  01010360\n ENTRY   IHIIOROQ\n ALIAS   IHIIOREN,IHIIOREV,IHIIORNX,IHIIOROP\n NAME    IHIIOR(R)\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET,REUS'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.FILE176.PDS\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.ALGOL.LOADLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB(IHIIOR)\n ORDER   IHIIORTN\n SETSSI  01010360\n ENTRY   IHIIOROQ\n ALIAS   IHIIOREN,IHIIOREV,IHIIORNX,IHIIOROP\n NAME    IHIIOR(R)\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET,REUS'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.FILE176.PDS\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.ALGOL.LOADLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB(IHIISY)\n ORDER   IHIISYMB\n SETSSI  02013491\n ENTRY   IHIISYMB\n ALIAS   IHIISYMB\n NAME    IHIISY(R)\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET,REUS'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.FILE176.PDS\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.ALGOL.LOADLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB(IHIISY)\n ORDER   IHIISYMB\n SETSSI  02013491\n ENTRY   IHIISYMB\n ALIAS   IHIISYMB\n NAME    IHIISY(R)\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET,REUS'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.FILE176.PDS\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.ALGOL.LOADLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB(IHILAT)\n ORDER   IHILATAN\n SETSSI  00015189\n ENTRY   IHILATAN\n NAME    IHILAT(R)\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET,REUS'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.FILE176.PDS\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.ALGOL.LOADLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB(IHILEX)\n ORDER   IHILEXPT\n SETSSI  01012912\n ENTRY   IHILEXPT\n NAME    IHILEX(R)\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET,REUS'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.FILE176.PDS\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.ALGOL.LOADLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB(IHILLO)\n ORDER   IHILLOGM\n SETSSI  00015191\n ENTRY   IHILLOGM\n NAME    IHILLO(R)\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET,REUS'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.FILE176.PDS\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.ALGOL.LOADLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB(IHILOR)\n ORDER   IHILOREA\n SETSSI  01013430\n ENTRY   IHILORAR\n ALIAS   IHILORAR(IHILOREA),IHILOREL\n NAME    IHILOR(R)\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET,REUS'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.FILE176.PDS\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.ALGOL.LOADLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB(IHILOR)\n ORDER   IHILOREA\n SETSSI  01013430\n ENTRY   IHILORAR\n ALIAS   IHILORAR(IHILOREA),IHILOREL\n NAME    IHILOR(R)\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET,REUS'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.FILE176.PDS\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.ALGOL.LOADLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB(IHILOR)\n ORDER   IHILOREA\n SETSSI  01013430\n ENTRY   IHILORAR\n ALIAS   IHILORAR(IHILOREA),IHILOREL\n NAME    IHILOR(R)\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET,REUS'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.FILE176.PDS\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.ALGOL.LOADLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB(IHILSC)\n ORDER   IHILSCSN\n SETSSI  00015193\n ENTRY   IHILSCSN\n ALIAS   IHILSCC,IHILSCS\n NAME    IHILSC(R)\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET,REUS'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.FILE176.PDS\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.ALGOL.LOADLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB(IHILSC)\n ORDER   IHILSCSN\n SETSSI  00015193\n ENTRY   IHILSCSN\n ALIAS   IHILSCC,IHILSCS\n NAME    IHILSC(R)\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET,REUS'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.FILE176.PDS\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.ALGOL.LOADLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB(IHILSC)\n ORDER   IHILSCSN\n SETSSI  00015193\n ENTRY   IHILSCSN\n ALIAS   IHILSCC,IHILSCS\n NAME    IHILSC(R)\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET,REUS'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.FILE176.PDS\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.ALGOL.LOADLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB(IHILSQ)\n ORDER   IHILSQRT\n SETSSI  00015194\n ENTRY   IHILSQRT\n NAME    IHILSQ(R)\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET,REUS'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.FILE176.PDS\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.ALGOL.LOADLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB(IHIOAR)\n ORDER   IHIOARRY\n SETSSI  01012913\n ENTRY   IHIOARRY\n ALIAS   IHIOARRY\n NAME    IHIOAR(R)\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET,REUS'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.FILE176.PDS\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.ALGOL.LOADLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB(IHIOAR)\n ORDER   IHIOARRY\n SETSSI  01012913\n ENTRY   IHIOARRY\n ALIAS   IHIOARRY\n NAME    IHIOAR(R)\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET,REUS'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.FILE176.PDS\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.ALGOL.LOADLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB(IHIOBA)\n ORDER   IHIOBARR\n SETSSI  00015196\n ENTRY   IHIOBARR\n ALIAS   IHIOBARR\n NAME    IHIOBA(R)\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET,REUS'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.FILE176.PDS\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.ALGOL.LOADLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB(IHIOBA)\n ORDER   IHIOBARR\n SETSSI  00015196\n ENTRY   IHIOBARR\n ALIAS   IHIOBARR\n NAME    IHIOBA(R)\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET,REUS'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.FILE176.PDS\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.ALGOL.LOADLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB(IHIOBO)\n ORDER   IHIOBOOL\n SETSSI  01013610\n ENTRY   IHIOBOOL\n ALIAS   IHIOBOAR,IHIOBOOL\n NAME    IHIOBO(R)\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET,REUS'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.FILE176.PDS\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.ALGOL.LOADLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB(IHIOBO)\n ORDER   IHIOBOOL\n SETSSI  01013610\n ENTRY   IHIOBOOL\n ALIAS   IHIOBOAR,IHIOBOOL\n NAME    IHIOBO(R)\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET,REUS'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.FILE176.PDS\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.ALGOL.LOADLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB(IHIOBO)\n ORDER   IHIOBOOL\n SETSSI  01013610\n ENTRY   IHIOBOOL\n ALIAS   IHIOBOAR,IHIOBOOL\n NAME    IHIOBO(R)\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET,REUS'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.FILE176.PDS\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.ALGOL.LOADLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB(IHIOIN)\n ORDER   IHIOINTE\n SETSSI  01013430\n ENTRY   IHIOINAR\n ALIAS   IHIOINAR(IHIOINTE),IHIOINTG\n NAME    IHIOIN(R)\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET,REUS'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.FILE176.PDS\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.ALGOL.LOADLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB(IHIOIN)\n ORDER   IHIOINTE\n SETSSI  01013430\n ENTRY   IHIOINAR\n ALIAS   IHIOINAR(IHIOINTE),IHIOINTG\n NAME    IHIOIN(R)\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET,REUS'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.FILE176.PDS\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.ALGOL.LOADLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB(IHIOIN)\n ORDER   IHIOINTE\n SETSSI  01013430\n ENTRY   IHIOINAR\n ALIAS   IHIOINAR(IHIOINTE),IHIOINTG\n NAME    IHIOIN(R)\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET,REUS'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.FILE176.PDS\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.ALGOL.LOADLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB(IHIOST)\n ORDER   IHIOSTRG\n SETSSI  01013433\n ENTRY   IHIOSTRG\n ALIAS   IHIOSTRG\n NAME    IHIOST(R)\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET,REUS'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.FILE176.PDS\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.ALGOL.LOADLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB(IHIOST)\n ORDER   IHIOSTRG\n SETSSI  01013433\n ENTRY   IHIOSTRG\n ALIAS   IHIOSTRG\n NAME    IHIOST(R)\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET,REUS'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.FILE176.PDS\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.ALGOL.LOADLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB(IHIOSY)\n ORDER   IHIOSYMB\n SETSSI  01013431\n ENTRY   IHIOSYMB\n ALIAS   IHIOSYMB\n NAME    IHIOSY(R)\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET,REUS'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.FILE176.PDS\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.ALGOL.LOADLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB(IHIOSY)\n ORDER   IHIOSYMB\n SETSSI  01013431\n ENTRY   IHIOSYMB\n ALIAS   IHIOSYMB\n NAME    IHIOSY(R)\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET,REUS'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.FILE176.PDS\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.ALGOL.LOADLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB(IHIOTA)\n ORDER   IHIOTARR\n SETSSI  00015201\n ENTRY   IHIOTARR\n ALIAS   IHIOTARR\n NAME    IHIOTA(R)\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET,REUS'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.FILE176.PDS\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.ALGOL.LOADLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB(IHIOTA)\n ORDER   IHIOTARR\n SETSSI  00015201\n ENTRY   IHIOTARR\n ALIAS   IHIOTARR\n NAME    IHIOTA(R)\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET,REUS'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.FILE176.PDS\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.ALGOL.LOADLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB(IHIPTT)\n ORDER   IHIPTTAB\n SETSSI  00015202\n ENTRY   IHIPTTAB\n ALIAS   IHIPTTAB\n NAME    IHIPTT(R)\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET,REUS'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.FILE176.PDS\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.ALGOL.LOADLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB(IHIPTT)\n ORDER   IHIPTTAB\n SETSSI  00015202\n ENTRY   IHIPTTAB\n ALIAS   IHIPTTAB\n NAME    IHIPTT(R)\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET,REUS'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.FILE176.PDS\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.ALGOL.LOADLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB(IHISAT)\n ORDER   IHISATAN\n SETSSI  00015203\n ENTRY   IHISATAN\n NAME    IHISAT(R)\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET,REUS'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.FILE176.PDS\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.ALGOL.LOADLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB(IHISEX)\n ORDER   IHISEXPT\n SETSSI  01012913\n ENTRY   IHISEXPT\n NAME    IHISEX(R)\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET,REUS'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.FILE176.PDS\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.ALGOL.LOADLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB(IHISLO)\n ORDER   IHISLOGM\n SETSSI  00015205\n ENTRY   IHISLOGM\n NAME    IHISLO(R)\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET,REUS'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.FILE176.PDS\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.ALGOL.LOADLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB(IHISOR)\n ORDER   IHISOREA\n SETSSI  01013430\n ENTRY   IHISORAR\n ALIAS   IHISORAR(IHISOREA),IHISOREL\n NAME    IHISOR(R)\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET,REUS'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.FILE176.PDS\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.ALGOL.LOADLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB(IHISOR)\n ORDER   IHISOREA\n SETSSI  01013430\n ENTRY   IHISORAR\n ALIAS   IHISORAR(IHISOREA),IHISOREL\n NAME    IHISOR(R)\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET,REUS'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.FILE176.PDS\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.ALGOL.LOADLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB(IHISOR)\n ORDER   IHISOREA\n SETSSI  01013430\n ENTRY   IHISORAR\n ALIAS   IHISORAR(IHISOREA),IHISOREL\n NAME    IHISOR(R)\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET,REUS'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.FILE176.PDS\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.ALGOL.LOADLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB(IHISSC)\n ORDER   IHISSCSN\n SETSSI  00015207\n ENTRY   IHISSCSN\n ALIAS   IHISSCC,IHISSCS\n NAME    IHISSC(R)\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET,REUS'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.FILE176.PDS\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.ALGOL.LOADLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB(IHISSC)\n ORDER   IHISSCSN\n SETSSI  00015207\n ENTRY   IHISSCSN\n ALIAS   IHISSCC,IHISSCS\n NAME    IHISSC(R)\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET,REUS'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.FILE176.PDS\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.ALGOL.LOADLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB(IHISSC)\n ORDER   IHISSCSN\n SETSSI  00015207\n ENTRY   IHISSCSN\n ALIAS   IHISSCC,IHISSCS\n NAME    IHISSC(R)\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET,REUS'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.FILE176.PDS\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.ALGOL.LOADLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB(IHISSQ)\n ORDER   IHISSQRT\n SETSSI  00015208\n ENTRY   IHISSQRT\n NAME    IHISSQ(R)\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET,REUS'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.FILE176.PDS\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.ALGOL.LOADLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB(IHISYS)\n ORDER   IHISYSCT\n SETSSI  03012913\n ENTRY   IHISYSCT\n ALIAS   IHISYSCT\n NAME    IHISYS(R)\n//LKED   EXEC  PGM=IEWL,\n//       PARM='NCAL,MAP,LIST,LET,REUS'\n//SYSUT1   DD  UNIT=SYSDA,SPACE=(2048,(200,20))\n//SYSPRINT DD  SYSOUT=*\n//SYSLIB   DD  DISP=SHR,DSN=SBGOLOB.FILE176.PDS\n//SYSLMOD  DD  DISP=SHR,DSN=SBGOLOB.ALGOL.LOADLIB\n//SYSLIN   DD  *\n INCLUDE SYSLIB(IHISYS)\n ORDER   IHISYSCT\n SETSSI  03012913\n ENTRY   IHISYSCT\n ALIAS   IHISYSCT\n NAME    IHISYS(R)\n/*\n//\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IEX00": {"ttr": 1027, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x98\\x01/\\x00\\x98\\x01/\\x16 \\x01\\xa8\\x01\\xa8\\x00\\x00\\xd6\\xf3\\xf6\\xf0`\\xf2\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1998-01-12T00:00:00", "modifydate": "1998-01-12T16:20:00", "lines": 424, "newlines": 424, "modlines": 0, "user": "O360-20"}, "text": " TITLE 'IEX00 - OS/360 ALGOL COMPILER DIRECTORY'\n*\n*STATUS.. CHANGE LEVEL 0.\n*\n*FUNCTION/OPERATION..\n*   THIS MODULE HAS TWO FUNCTIONS..\n*   1. IT PROVIDES THE INITIAL ENTRY POINT TO AND FINAL EXIT POINT\n*   FROM THE ALGOL COMPILER.\n*   2. IT CONTAINS ROUTINES AND DATA WHICH MAY BE NEEDED BY SOME OR ALL\n*   OF THE FOLLOWING COMPILER PHASES.\n*\n*ENTRY POINTS..\n*        IEX00000 - INITIAL ENTRY POINT. MAY BE ENTERED BY AN\n*   '// EXEC' STATEMENT OR BY ANY ONE OF THE MACROS LINK, CALL, XCTL\n*   OR ATTACH.\n*        IEX00PIC - PROGRAM INTERRUPT ROUTINE\n*        IEX00ED1 - END OF DATA ROUTINE FOR SYSUT1\n*        EODAD2 -  END OF DATA ROUTINE FOR SYSUT2\n*        EODAD3 -  END OF DATA ROUTINE FOR SYSUT3\n*        IEX00EDI - END OF DATA ROUTINE FOR SYSIN\n*   (THE FOUR END OF DATA ROUTINES ABOVE ARE DUMMIES WHICH ONLY\n*   TRANSFER CONTROL TO THE ACTUAL ROUTINES, THE ADDRESSES OF WHICH\n*   HAVE BEEN STORED IN THE COMMON WORK AREA).\n*        IEX00SYN - SYNCHRONOUS ERROR ROUTINE FOR ALL DATA SETS\n*   EXCEPT SYSPRINT.\n*        SYNPR - SYNCHRONOUS ERROR ROUTINE FOR SYSPRINT.\n*        IEX00PRI - A COMMON SUBROUTINE FOR WRITING OUTPUT TO SYSPRINT.\n*\n*INPUT.. N/A\n*\n*OUTPUT..\n*   THE SUBROUTINE PRINT EXECUTES ALL OUTPUT OPERATIONS ON SYSPRINT.\n*   THE FINAL DESTINATION IS A PRINTER, ALTHOUGH A TAPE OR DIRECT\n*   ACCESS DEVICE MAY BE USED AS INTERMEDIATE MEDIUM. THE FORMAT IS\n*   FIXED BLOCKED WITH RECORD LENGTH 91 BYTES. THE MACHINE CODE CONTROL\n*   CHARACTERS FOR THE PRINTER ARE USED.\n*\n*EXTERNAL ROUTINES..\n*        IEX00001 - THE COMMON WORK AREA. THIS IS NOT AN EXECUTABLE\n*   ROUTINE BUT RATHER A COLLECTION OF TABLES, DATA AND WORK AREAS\n*   WHICH ARE NEEDED BY SOME OR ALL OF THE COMPILER PHASES, THUS\n*   SUPPLEMENTING THE FUNCTION OF THIS MODULE. IT IS ASSEMBLED\n*   SEPARATELY AND LINKAGE EDITED WITH THIS MODULE. ITS CONTENTS AND\n*   FORMAT CAN BE FOUND IN THE DUMMY CONTROL SECTION WORKAREA.\n*        IEX10000 - THE COMPILER INITIALIZATION PHASE. THE WHOLE CHAIN\n*   OF COMPILER PHASES STARTING WITH IEX10000 AND ENDING WITH IEX51002\n*   CAN BE REGARDED AS A SUBROUTINE TO THIS MODULE. IT IS ENTERED BY\n*   A MACRO 'LINK EP=IEX10000'. ON ENTRY, REG 0 CONTAINS THE ADDRESS\n*   OF THE COMMON WORK AREA. CONTROL IS FINALLY RETURNED TO THIS\n*   MODULE FROM IEX51002 BY A RETURN MACRO WITH THE COMPLETION CODE\n*   IN REG. 15.\n*\n*EXITS - NORMAL:\n*   THE FINAL EXIT FROM THE COMPILER IS BY A RETURN MACRO TO THE\n*   INVOKING PROGRAM. REG. 15 THEN CONTAINS A RETURN CODE TO\n*   INDICATE WHETHER THE COMPILATION WAS SUCCESSFUL OR NOT.\n*\n*   EXIT FROM THE SUBROUTINE PRINT IS BY A RETURN MACRO. REG. 1 THEN\n*   CONTAINS THE ADDRESS OF A BUFFER AREA INTO WHICH THE NEXT OUTPUT\n*   LINE CAN BE MOVED.\n*\n*EXITS - ERRORS:\n*   EXIT FROM THE COMMON ERROR ROUTINES PIROUT, SYNAD AND SYNPR IS\n*   NORMALLY TO AN ERROR ROUTINE WHICH IS PRIVATE TO EACH COMPILER\n*   PHASE. THE ADDRESS OF THIS ROUTINE HAS BEEN STORED IN ERET IN THE\n*   COMMON WORK AREA. HOWEVER, IF THE PIROUT ROUTINE IS ENTERED FOR\n*   THE SECOND TIME, EXIT IS MADE TO THE ROUTINE GOTOEND IN THIS MODULE\n*   WHICH IN ITS TURN XCTL'S TO THE TERMINATING PHASE IEX51002.\n*\n*   EXIT FROM THE ROUTINES SYNAD AND SYNPR IS BY LOADING ERET INTO REG.\n*   15 AND BRANCHING.\n*\n*   EXIT FROM THE ROUTINE PIROUT IS BY MOVING THE RETURN ADDRESS INTO\n*   THE OLD PSW AND EXECUTING A RETURN MACRO.\n*\n*TABLES/WORK AREAS..\n*        SAVE - THE SAVE AREA IN STANDARD FORMAT.\n*        PICA - THE PROGRAM INTERRUPT CONTROL AREA.\n*        DCBPRINT - DCB FOR SYSPRINT.\n*        DCBLIN -   DCB FOR SYSLIN.\n*        DCBPCH -   DCB FOR SYSPUNCH.\n*        DCBUT2 -   DCB FOR SYSUT2.\n*        DCBUT3 -   DCB FOR SYSUT3.\n*        WORKAREA - THE COMMON WORKAREA IN THE EXTERNAL CONTROL SECTION\n*   IEX0001.\n*\n*ATTRIBUTES..  NOT SERIALLY REUSABLE.\n*\n*NOTES..\n*   THIS MODULE IS TO BE LINKAGE EDITED WITH THE COMMON WORK AREA\n*   (MODULE IEX00001). THE RESULTING LOAD MODULE FORMS THE RESIDENT\n*   PART (IEX00) OF THE ALGOL COMPILER.\n*\n*   THE OPERATION OF THIS MODULE DEPENDS UPON AN INTERNAL REPRESEN-\n*   TATION OF THE EXTERNAL CHARACTER SET WHICH IS EQUIVALENT TO THE\n*   ONE USED AT ASSEMBLY TIME.\n EJECT\nIEX00000 START 0\n         SPACE\n* REGISTER ASSIGNMENTS\n         SPACE\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nRA       EQU   4\nRB       EQU   5\nR13      EQU   13\nR15      EQU   15\n         SPACE\nNXT      EQU   6         ADDR OF CURRENT ENTRY IN ERROR POOL\nIDX      EQU   7         USED AS INDEX\n         SPACE\n*  BIT PATTERNS\n         SPACE\nONSW     EQU   X'F0'                    ON SWITCH IN BRANCH INSTR\nOFFSW    EQU   X'0F'                    OFF SWITCH IN BRANCH INSTR\n         SPACE\n*  ENTRY POINTS\n         SPACE\n         ENTRY IEX00LIN,IEX00PCH,IEX00PRT,IEX00UT2,IEX00UT3\n         ENTRY IEX00SYN,IEX00ED1,IEX00EDI,IEX00PIC,IEX00PRI\n         EJECT\n         SPACE\n* ENTRY POINT OF THE COMPILER\n         SPACE\n* UPON ENTRY, REG 15 CONTAINS THE ADDR OF THE ENTRY POINT, REG 14 CON-\n* TAINS THE RETURN ADDR AND REG 1 CONTAINS THE ADDR OF THE PARAM LIST.\n         SPACE\n         EXTRN IEX00001\n         SPACE\n         USING *,15\n         SAVE  (14,12)\n         ST    R13,SAVE+4\n         MVC   8(4,R13),=A(SAVE)\n         L     R13,=A(SAVE)\n         L     R0,=A(IEX00001)     ADDR OF COMMON WORKAREA\n         LINK  EP=IEX10            LINK TO PHASE 10\n         SPACE\n* TWO PARAMTERS ARE TRANSMITTED TO PHASE 10, REG 0 CONTAINS THE ADDR\n* OF THE COMMON WORKAREA, REG 1 CONTAINS THE ADDR OF THE PARAMETER LIST\n* OF THE INVOKER\n         SPACE 2\n* FINAL EXIT OF THE COMPILER\n         SPACE\n* PHASE 51 GENERATED THE RETURN CODE IN REG 15, THE RETURN CODE IS\n* TRANSMITTED BACK TO THE INVOKER\n         BALR  14,0                                                0219\n         SPACE\n         USING *,14\n         L     R13,SAVE+4\n         RETURN (14,12),RC=(15)\n         SPACE 2\n* SAVEAREA FOR THIS LEVEL OF CONTROL\n         SPACE\nSAVE     DC    18F'0'\n         SPACE 2\n         LTORG\n         EJECT\n* THE FOLLOWING SECTION CONTAINS THE PROG. INTERRUPT CONTROL AREA,THE\n* PROG CHECK AND I/O ERROR ROUTINES, THE PRINT ROUTINE AND THE DCBS FOR\n* SYSLIN, SYSPUNCH, SYSPRINT, SYSUT2 AND SYSUT3\n         SPACE 2\n         USING WORKAREA,R13\n         SPACE 2\n* PROGRAM INTERRUPT CONTROL AREA\n         SPACE\nPICA     SPIE  PIROUT,((1,15)),MF=L\nIEX00PIC EQU   PICA\n         SPACE 2\n* PROGRAM INTERRUPT ROUTINE\n         SPACE\n         USING *,R15\nPIROUT   TM    HCOMPMOD+1,TERM     IF PROG INTERRUPT IN TERMINATING PHA\n         BO    TERMERR                                               SE\n         TM    HCOMPMOD+1,ERR\n         BO    ERRERR              IF PROG INTERRUPT IN ERROR ROUT\n         STM   RA,IDX,PISAVE            SAVE REGISTERS\n         L     NXT,NEXTERR         ADDR OF NEXT BYTE IN ERROR POOL\n         MVC   0(2,NXT),=AL1(20,209) PATTERN FOR MSG 209\n         MVC   2(2,NXT),SEMCNT     SEMICOLON COUNTER\n         TM    HCOMPMOD+2,NOSC\n         BZ    *+8\n         OI    0(NXT),X'80'             INDICATE SCNTR NOT VALID\n         SR    IDX,IDX             INITIALIZE INDEX\n         L     RB,4(R1)            FIRST HALF OF PSW\nLOOP     SR    RA,RA\n         SLDL  RA,4                GET HALF A BYTE OF OLD PSW\n         STC   RA,4(IDX,NXT)         AND STORE IT FOR CONVERSION\n         LA    IDX,1(IDX)          INCREASE INDEX\n         CH    IDX,=H'8'           PERFORM LOOP\n         BL    LOOP                  EIGHT TIMES\n         L     RB,8(0,R1)          SECOND HALF OF PSW\nLOOP2    SR    RA,RA\n         SLDL  RA,4                GET HALF A BYTE OF OLD PSW\n         STC   RA,4(IDX,NXT)         AND STORE IT FOR CONVERSION\n         LA    IDX,1(IDX)          INCREASE INDEX\n         CH    IDX,=H'16'          PERFORM LOOP\n         BL    LOOP2                 EIGHT TIMES\n         TR    4(16,NXT),=C'0123456789ABCDEF' TRANSLATE TO PRINTABLE HX\n         LA    NXT,20(NXT)         UPDATE POINTER\n         ST    NXT,NEXTERR           TO ERROR POOL\nFIRSTERR OI    HCOMPMOD+1,ERR      SET ERROR ROUT SWITCH ON\n         LM    RA,IDX,PISAVE            RESTORE REGISTERS\nTERMERR  MVC   9(3,R1),ERET+1      ADDR OF ERR ROUT TO OLD PSW\n         OI    HCOMPMOD,X'08'      INDICATE TERMINATING ERROR\n         RETURN\nPISAVE   DC    4F'0'                    REGISTER SAVE AREA\n         SPACE\nERRERR   MVC   9(3,R1),=AL3(GOTOEND) SET ADDR IN OLD PSW\n         RETURN\n         DROP  R15\nGOTOEND  BALR  R15,0\n         USING *,R15\n         XCTL  EP=IEX51002              GO TO TERMINATING PHASE\n         DROP  R15\n         SPACE 2\n* ENTRY OF THE END OF DATA EXIT ROUTINES\n         SPACE\nIEX00ED1 EQU   *\nEODAD1   L     R15,EODUT1               SYSUT1\n         BR    R15\nEODAD2   L     R15,EODUT2               SYSUT2\n         BR    R15\nEODAD3   L     R15,EODUT3               SYSUT3\n         BR    R15\nIEX00EDI EQU   *\nEODADIN  L     R15,EODIN                SYSIN\n         BR    R15\n         SPACE 2\n*  SYNAD ROUTINE (ENTRY POINT FOR SYSPRINT)\n         SPACE\nSYNPR    OI    HCOMPMOD+2,PRT      SET SYSPRINT DOWN SWITCH ON\n         BALR  R15,0\n         SPACE 2\n*  SYNAD ROUTINE (ENTRY POINT FOR ALL DATA SETS EXCEPT SYSPRINT)\n         SPACE\n         USING *,R15\nIEX00SYN EQU   *\nSYNAD    LR    R2,R1                    GET DCB ADDRESS\n         LA    R2,0(R2)                 REMOVE HIGH-ORDER BYTE\n         CLOSE ((R2))\n         DROP  R15\n         BALR  R15,0\n         USING *,R15\n         L     R3,NEXTERR               STORE ERROR PATTERN\n         MVC   0(2,R3),PTTRN210           IN ERROR POOL\n         MVC   2(2,R3),SEMCNT\n         USING IHADCB,R2\n         MVC   4(8,R3),DCBDDNAM\n         DROP  R2\n         LA    R3,12(R3)                UPDATE ERROR POINTER\n         ST    R3,NEXTERR\n         OI    HCOMPMOD,X'08'      INDICATE TERMINATING ERROR\n         TM    HCOMPMOD+2,PRT\n         BZ    *+8                      BRANCH IF NOT SYSPRINT\n         LM    LINKP,RETURN,SAVEP       RESTORE REGS. F*OM PRINT ROUT.\n         L     R15,ERET                 EXIT TO ERROR ROUTINE\n         BR    R15                        IN CURRENT PHASE\nPTTRN210 DC    AL1(12),AL1(210)\n         DROP  R15\n         EJECT\nPRINT    EQU   *\nIEX00PRI EQU   *\n         SPACE\n*        THIS ROUTINE PRINTS ONE LINE ON SYSPRINT. IT ALSO TAKES CARE\n*  OF LINE COUNTING, PAGE COUNTING AND PRINTING OF HEADING LINES AT\n*   THE TOP AF EACH NEW PAGE.\n         SPACE\n*  CALLING SEQUENCE\n         SPACE\n*        L     ENTRY,PRTRTADD           ENTRY ADDRESS IN CWA\n*        BALR  RETURN,ENTRY\n*        ---             ON RETURN, GR1 CONTAINS ADDRESS OF PRINT BUFF.\n         SPACE\n*  GENERAL REGISTERS\nGR1      EQU   1\nLINKP    EQU   4\nBASEP    EQU   5\nLCT      EQU   6         LINE COUNTER\nPCT      EQU   7         PAGE CPUNTER\nLINC     EQU   8         LINE COUNTER INCREMENT FOR HEADLINES\nHDNG     EQU   9         ADDRESS OF CURRENT HEADLINE (MUST BE ODD REG)\nDCB      EQU   12        SYSPRINT DCB ADDRESS\nRETURN   EQU   14\nENTRY    EQU   15\n         SPACE\nNOPRINT  EQU   X'FF'     IF IN FIRST PRINT POSITION-SKIP THIS HEADLINE\nSPACE1   EQU   X'09'                    CTL CHAR FOR SINGLE SPACE\nSKIP     EQU   X'89'                    CTL CHAR FOR PAGE SKIP\n         SPACE\n         USING PRINT,ENTRY\n         STM   LINKP,RETURN,SAVEP\n         DROP  ENTRY\n         LR    BASEP,ENTRY\n         USING PRINT,BASEP\n         L     DCB,PRINTADD             ADDR OF SYSPRINT DCB\n         LH    LCT,LINCNT               TEST LINE COUNTER\nPRINTSW  EQU   *+1                      SWITCH FOR NEW PAGE\n         NOP   PRINTA\n         TM    LINCNTA+1,X'FF'\n         BNZ   PRINTG                   IF FIRST PAGE\nPRINTF   CH    LCT,MAXLINES\n         BL    PRINTD                   IF NOT END OF PAGE\n         L     GR1,PREVLIN              ADDRESS OF PREV. LINE\n         MVI   0(GR1),SKIP              SKIP AFTER PREV. LINE\n         SR    LCT,LCT                  RESET LINE COUNTER\nPRINTG   OI    PRINTSW,ONSW             TO PRINT HEADING NEXT TIME\nPRINTD   EQU   *\n         BAL   LINKP,PRINTP\n         TM    LINCNT,X'7F'\n         BNZ   PRINTH                   IF FORCED NEW PAGE\nPRINTE   EQU   *\n         MVI   0(GR1),SPACE1            CONTROL CHARACTER\n         MVI   1(GR1),C' '\n         MVC   2(89,GR1),1(GR1)         BLANK PRINT AREA\n         STH   LCT,LINCNT\n         LA    GR1,1(0,GR1)        RETURN ADDRESS OF PRINT AREA TO USER\n         LM    LINKP,RETURN,SAVEP\n         BR    RETURN\n         SPACE\nPRINTA   EQU   *                   PRINT HEADLINES AT TOP OF NEW PAGE\n         SPACE\n         L     GR1,PREVLIN              ADDRESS OF PREVIOUS LINE\n         MVC   SAVELINE(91),0(GR1)      SAVE TEXT LINE\nPRINTH   EQU   *\n         NI    PRINTSW,OFFSW\n         LH    LCT,LINCNTA              RESET LINE COUNTER\n         MVI   LINCNTA+1,0\n         L     PCT,PAGECNT\n         LA    PCT,1(0,PCT)             STEP PAGE COUNTER\n         ST    PCT,PAGECNT\n         CVD   PCT,DBWORD               CONVERT PAGE NUMBER\n         OI    DBWORD+7,X'0F'\n         UNPK  PAGEHEAD+89(3),DBWORD+6(2)  INSERT PAGE CT INTO HEADLINE\n         LA    HDNG,PAGEHEAD            SET UP COUNTER FOR HEADLINES\n         LA    HDNG+1,HDLG\n         LA    HDNG+2,PAGEHEND\nPRINTC   CLI   2(HDNG),NOPRINT\n         BE    PRINTB                   BR IF HEADING IS TO BE SKIPPED\n         MVC   0(HDLG,GR1),1(HDNG)      MOVE HEADING TO PRINT BUFFER\n         BAL   LINKP,PRINTP\nPRINTB   BXLE  HDNG,HDNG+1,PRINTC\n         TM    LINCNT,X'7F'\n         BNZ   PRINTE                   IF FORCED NEW PAGE\n         MVC   0(91,GR1),SAVELINE       RESTORE TEXT LINE\n         B     PRINTD                   RETURN TO REGULAR PRINTING\n         SPACE\nPRINTP   EQU   *                   SUBROUTINE FOR PRINTING A LINE\n         SPACE\n         L     GR1,PREVLIN               ADDRESS OF PREVIOUS LINE\n         SR    LINC,LINC\n         IC    LINC,0(GR1)              EXTRACT NUMBER OF LINES\n         SLL   LINC,25                   FROM CONTROL CHARACTER\n         SRL   LINC,28\n         AR    LCT,LINC                  STEP LINE COUNTER\n         PUT   (DCB)\n         ST    GR1,PREVLIN\n         BR    LINKP\n         SPACE\nLINCNTA  DC    H'2'                     INITIAL LINECOUNT (SET TO ZERO\n*                                         AFTER THE FIRST PAGE)\nPREVLIN  DC    A(*)                     ADDR. OF PREV. LINE CTL CHAR\nSAVEP    DS    11F                      SAVE REG LINKP TO RETURN\nDBWORD   DS    1D        USED AT BINARY-DECIMAL CONVERSION\nSAVELINE DS    CL91                     TEMP. STORAGE FOR TEXT LINE\n         EJECT\n         LTORG\n         EJECT\n* DATA CONTROL BLOCKS\n         SPACE 4\nDCBPRINT DCB   DDNAME=SYSPRINT,                                        X\n               DSORG=PS,                                               2\n               MACRF=(PL),                                             X\n               RECFM=FBM,                                              X\n               LRECL=91,                                               5\n               BFTEK=S,                                                X\n               SYNAD=SYNPR\n         SPACE 4\nDCBLIN   DCB   DDNAME=SYSLIN,                                          1\n               DSORG=PS,                                               2\n               MACRF=(PL),                                             X\n               RECFM=FB,                                               4\n               LRECL=80,                                               5\n               BFTEK=S,                                                X\n               SYNAD=SYNAD\n         SPACE 4\nDCBPCH   DCB   DDNAME=SYSPUNCH,                                        1\n               DSORG=PS,                                               2\n               MACRF=(PL),                                             X\n               RECFM=FB,                                               4\n               LRECL=80,                                               5\n               BFTEK=S,                                                X\n               SYNAD=SYNAD\n         SPACE 4\nDCBUT2   DCB   DDNAME=SYSUT2,                                          1\n               DSORG=PS,                                               2\n               MACRF=(R,W),                                            3\n               RECFM=F,                                                X\n               SYNAD=SYNAD,                                            X\n               EODAD=EODAD2\n         SPACE 4\nDCBUT3   DCB   DDNAME=SYSUT3,                                          1\n               DSORG=PS,                                               2\n               MACRF=(RP,WP),                                          X\n               BLKSIZE=2000,                                           X\n               RECFM=U,                                                X\n               SYNAD=SYNAD,                                            8\n               EODAD=EODAD3\n         SPACE\nIEX00PRT EQU   DCBPRINT\nIEX00LIN EQU   DCBLIN\nIEX00PCH EQU   DCBPCH\nIEX00UT2 EQU   DCBUT2\nIEX00UT3 EQU   DCBUT3\n         EJECT\n         SPACE\nWORKAREA DSECT\n         COPY  WORKAREA\n EJECT\n* DUMMY CONTROL SECTION TO PROVIDE ADRESSABILITY OF DCB\n         SPACE\n         DCBD  DSORG=(PS)\n         END   IEX00000\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IEX10": {"ttr": 1035, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x98\\x01/\\x00\\x98\\x01/\\x16 \\x03\\xe2\\x03\\xe2\\x00\\x00\\xd6\\xf3\\xf6\\xf0`\\xf2\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1998-01-12T00:00:00", "modifydate": "1998-01-12T16:20:00", "lines": 994, "newlines": 994, "modlines": 0, "user": "O360-20"}, "text": " TITLE 'IEX10 - OS/360 ALGOL COMPILER INITIALIZATION PHASE'\n*STATUS: CHANGE LEVEL 0.\n*\n*FUNCTION/OPERATION:\n*   THIS MODULE PERFORMS THE FOLLOWING INITIALIZATION ACTIONS:\n*   1.  SAVE THE REGISTERS AND ESTABLISH THE LOWER PART OF THE COMMON\n*   WORKAREA AS THE NEW SAVE AREA TO BE USED THROUGHOUT THE COMPILATION\n*   2.  EXECUTE A SPIE MACRO.\n*   3.  SCAN THE OPTION PARAMETER FIELD PROVIDED BY THE USER AND SET\n*   THE SWITCHES IN HCOMPMOD ACCORDINGLY.\n*   4.  IF PROVIDED BY THE USER, INSERT NEW DD NAMES INTO THE DCB'S AND\n*   STORE THE INITIAL PAGECOUNT IN THE COMMON WORKAREA.\n*   5.  ACCORDING TO THE VALUE OF THE SIZE OPTION PARAMETER, SELECT\n*   A TABLE OF SIZES FOR CERTAIN STORAGE-SIZE DEPENDENT STORAGE AREAS\n*   AND MOVE THE TABLE TO THE COMMON WORKAREA.\n*   6.  OBTAIN STORAGE FOR THE ERROR POOL AND MOVE ANY ERROR PATTERNS\n*   ALREADY STORED FROM THE PRELIMINARY ERROR POOL INTO THE NEW POOL.\n*   7.  COMPLETE AND OPEN THE DCB'S FOR ALL DATA SETS TO BE USED.\n*   8.  OBTAIN THE CALENDAR DATE BY MEANS OF A TIME MACRO AND STORE\n*   IT IN EDITED FORM IN A HEADLINE, WHICH IS PRINTED AT THE TOP OF THE\n*   FIRST PAGE.\n*   9.  TRANSFER CONTROL TO THE SCANI/II PHASE (IEX11).\n*\n*   IF ERRORS ARE DETECTED IN THE STEPS DESCRIBED ABOVE (SUCH AS\n*   INVALID OPTION PARAMETERS OR INCORRECT DD CARDS), SOME OF THE STEPS\n*   MAY BE BYPASSED, AND AN ERROR EXIT MAY BE TAKEN.\n*\n*ENTRY POINTS:\n*        IEX10000 - THE ONLY ENTRY POINT TO THIS MODULE. CONTROL IS\n*   TRANSFERRED HERE FROM IEX00 BY THE MACRO 'LINK EP=IEX10'. REG. 0\n*   THEN CONTAINS THE ADDRESS OF THE COMMON WORKAREA AND REG. 1 THE\n*   ADDRESS OF THE PARAMETER LIST PROVIDED BY THE USER.\n*\n*INPUT: N/A.\n*\n*OUTPUT:  THE TEXT STORED AT FIRSTLIN IS OUTPUT TO SYSPRINT AS A\n*   91-CHARACTER RECORD WITH MACHINE CONTROL CHARACTER.\n*\n*EXTERNAL ROUTINES: N/A.\n*\n*   IF NO TERMINATING ERRORS ARE FOUND, CONTROL IS TRANSFERRED TO\n*   THE SCANI/II PHASE BY MEANS OF THE MACRO 'XCTL EP=IEX11'.\n*\n*EXITS - ERRORS:\n*   IF A PROGRAM CHECK OR UNRECOVERABLE I/O ERROR OCCURS DURING ONE\n*   OF THE INITIALIZATION STEPS, CONTROL IS TRANSFERRED (VIA AN ERROR\n*   ROUTINE IN IEX00) TO THE ROUTINE GOTOTERM IN THIS MODULE. FROM\n*   THERE AN EXIT IS MADE TO THE TERMINATING PHASE BY MEANS OF THE\n*   MACRO 'XCTL EP=IEX51002'.\n*\n*   IF ANY OTHER TERMINATING ERROR IS DETECTED, CONTROL IS TRANSFERRED\n*   TO THE ROUTINE GOTOEDIT IN THIS MODULE.  FROM THERE AN EXIT IS\n*   MADE TO THE ERROR EDITING MODULE BY MEANS OF THE MACRO\n*   'XCTL EP=IEX21000'.\n*\n*TABLES/WORK AREAS:\n*   ARTAB - A TABLE OF SIZES OF WORK AREAS AND BUFFERS WHICH DEPEND\n*   ON THE STORAGE SIZE.\n*   STARTING AT PTRN200 - ERROR PATTERNS FOR ALL ERRORS WHICH MAY BE\n*   DETECTED IN THIS MODULE.\n*   FIRSTLIN - THE FIRST OUTPUT LINE TO BE PRINTED. CONTAINS PROGRAM\n*   IDENTIFICATION AND LEVEL AND THE DATE OF THE RUN.\n*   JANUARY - A TABLE OF THE MONTHS OF THE YEAR. USED WHEN EDITING\n*   THE DATE FOR FIRSTLIN.\n*   PARMLIST - A TABLE USED FOR DECODING THE OPTION PARAMETERS.\n*\n*ATTRIBUTES:  NOT REUSABLE.\n*\n*NOTES:\n*   THIS MODULE IS ONLY INTENDED TO BE USED IN CONNECTION WITH THE\n*   OTHER MODULES COMPRISING THE ALGOL COMPILER.\n*\n*   THE OPERATION OF THIS MODULE DEPENDS UPON AN INTERNAL REPRESEN-\n*   TATION OF THE EXTERNAL CHARACTER SET WHICH IS EQUIVALENT TO THE\n*   ONE USED AT ASSEMBLY TIME.\n         EJECT\nIEX10000 START 0\n         SPACE\n* REGISTER ASSIGNMENTS\n         SPACE\nRA       EQU   4\nRB       EQU   5\nRC       EQU   6\nRD       EQU   7\nRE       EQU   8\nRF       EQU   9\nRG       EQU   10\nRH       EQU   11\n         SPACE\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         SPACE\nBASE     EQU   2                        BASE REGISTER\nIDX      EQU   7                        INDEX USED BY EDITDATE ROUT.\n         SPACE\nREGA     EQU   4    RUNNING ADDR OF PARAMETER FIELD MINUS 2\nREGB     EQU   5    ADDR OF BYTE FOLLOWING LAST BYTE OF FIELD MINUS 2\nREGC     EQU   6    RUNNING ADDR OF PARAMETER LIST\nREGD     EQU   7    ADDR OF LAST ENTRY OF PARAMETER LIST\nREGE     EQU   8    LENGTH -1 OF PARAMETER\nREGF     EQU   9    CURRENT FIELD IN ERROR POOL\nREGG     EQU   10   NEXT FIELD IN ERROR POOL\nREGH     EQU   11   BYTE COUNT OF PARAMETER IN ERROR\n EJECT\n         SPACE 2\n         SAVE  (14,12)\n         BALR  BASE,0              GET BASE\n         USING *,BASE\n         ST    R0,8(R13)           ADDR OF LOWER LEVEL SAVAREA\n         LR    R12,R13\n         LR    R13,R0\n         ST    R12,4(R13)          ADDR OF HIGHER LEVEL SAVEAREA\n         USING WORKAREA,R13\n         SPACE 2\n* EXECUTE THE SPIE MACRO\n         SPACE\n         L     R3,PICAADD          ADDR OF PICA OF COMPILER\n         SPIE  MF=(E,(3))\n         ST    R1,OLDPICA          STORE ADDR OF OLD PICA IN WORKAREA\n         SPACE 2\n         MVC   ERET,=A(GOTOTERM)   ERROR ROUT FOR NEXT PART OF PHASE\n* INTERROGATE THE CONTROL PARAMETERS AND SET SWITCHES IN WORKAREA\n         SPACE\n         L     R14,4(R13)\n         L     R14,24(R14)\n         LTR   R14,R14\n         BC    8,OPEN              NO OPTIONS ARE SPECIFIED\n         SPACE\n         L     REGA,0(0,14)        ADDRESS OF PARMETERFIELD\n         LA    REGA,0(0,REGA)           RESET HIGH ORDER BYTE\n         LH    REGB,0(REGA)        FIELDLENGTH\n         LTR   REGB,REGB           TEST FIELDLENGTH\n         BZ    DDNAMES             NO CONTROL PARAMETERS SPECIFIED\n         SPACE\n         AR    REGB,REGA           END OF FIELD\n         LA    REGD,LSTENTRY       LAST ENTRY OF LIST\n         SR    REGE,REGE           ZERO REGISTER\nFNDCOMMA CLI   2(REGA),C','\n         BNE   FNDPAR              IF NOT COMMA\nSTEP1    LA    REGA,1(REGA)        STEP FIELD\nCOMP1    CR    REGA,REGB\n         BL    FNDCOMMA            IF NOT END OF FIELD YET\n         TM    HCOMPMOD+1,X'60'\n         BC    14,*+8\n         OI    HCOMPMOD,X'80'\n         B     DDNAMES             END OF FIELD\n         USING LENGTH,REGC\nCOMPINST CLC   2(0,REGA),PARAM\nFNDPAR   CLC   2(5,REGA),=C'SIZE='\n         BE    FNDSIZE\n         LA    REGC,PARMLIST\nNXTPAR   IC    REGE,LENGTH\n         EX    REGE,COMPINST\n         BNE   NOTFOUND\n         LA    REGG,1(REGA,REGE)   ADDR OF BYTE FOLLOWING PARAMETER -2\n         CLI   2(REGG),C','        IS IT COMMA\n         BE    SETBIT\n         CR    REGG,REGB           IS IT END OF PARAMETERFIELD\n         BL    ERROR200            IF NO\nSETBIT   LR    REGA,REGG\n         EX    0,INSTR\n         DROP  REGC\n         B     COMP1\nNOTFOUND CR    REGC,REGD\n         LA    REGC,LENGTH-PARMLIST(REGC)  STEP LIST ADDR\n         BL    NXTPAR              IF NOT END OF LIST YET\n         SPACE\nERROR200 L     REGF,NEXTERR        ADDR OF NEXT FREE BYTE IN ERRORPOOL\n         CLI   0(REGF),C'X'        TEST IF THE PRELIMINARY ERROR\n         BE    FULLPOOL              POOL IS FILLED\n         LA    REGG,16(REGF)\n         ST    REGG,NEXTERR\n         MVC   0(16,REGF),PTRN200  PATTERN WITH BLANKS TO ERROR POOL\n         LA    REGH,12(0)\nMOVE     MVC   4(1,REGF),2(REGA)\n         LA    REGF,1(REGF)\nMOVENOT  LA    REGA,1(REGA)\n         CLI   2(REGA),C','\n         BE    STEP1               IF END OF PARAMETER\n         CLR   REGA,REGB\n         BNL   DDNAMES             IF END OF PARAMETER LIST\n         SH    REGH,=H'1'\n         BP    MOVE\n         B     MOVENOT\n         SPACE\nFNDSIZE  LA    REGG,5(REGA)        ADDR OF FIRST DIGIT -2\n         SR    REGH,REGH           SET COUNT OF DIGITS TO ZERO\nTSTDIGIT CLI   2(REGG),C'0'        TEST IF\n         BL    ERROR200              THE CHARACTER\n         CLI   2(REGG),C'9'          IS A DIGIT\n         BH    ERROR200\n         LA    REGG,1(REGG)\n         CR    REGG,REGB           TEST IF END OF PARAMTER FIELD\n         BE    PCKSIZE\n         CLI   2(REGG),C','        TEST IF DIGIT IS FOLLOWED BY A COMMA\n         BE    PCKSIZE\n         LA    REGH,1(REGH)        ADD 1 TO DIGIT COUNT\n         CH    REGH,=H'7'          TEST IF TOO MANY DIGITS\n         BE    ERROR200\n         B     TSTDIGIT\nPCKINSTR PACK  FIELD1,7(0,REGA)\nPCKSIZE  EX    REGH,PCKINSTR       L2 IS IN TEGH\n         CVB   REGC,FIELD1\n         LR    REGA,REGG\n         C     REGC,=F'45056'      TEST IF SPECIFIED STORAGE SIZE\n         BL    ERROR208              IS TOO SMALL\n         ST    REGC,SIZE\n         B     COMP1\n         SPACE\nERROR208 L     REGF,NEXTERR\n         MVC   0(4,REGF),PTRN208   PATTERN FOR MSG 208 TO ERROR POOL\n         LA    REGF,4(REGF)        UPDATE POINTER TO NEXT\n         CLI   0(REGF),C'X'        TEST IF THE PRELIMINARY ERROR\n         BE    FULLPOOL              POOL IS FILLED\n         ST    REGF,NEXTERR          FREE ENTRY\n         B     COMP1\n         SPACE\nFULLPOOL MVC   0(4,REGF),PTRN206   PATTERN FOR MESSAGE 206\n         LA    REGF,4(REGF)        UPDATE POINTER TO\n         ST    REGF,NEXTERR          NEXT FREE ENTRY\n         B     DDNAMES             NO PARAMERER TESTING ANY MORE\n         SPACE 2\n* FIND THE DD NAMES\n         SPACE\nDDNAMES  TM    0(14),X'80'\n         BO    OPEN                IF NO DDNAMES AND HEADING INFO\n         L     REGA,4(14)\n         LH    REGB,0(REGA)\n         LTR   REGB,REGB\n         BZ    HEADINFO                 IF NO DDNAMES SPECIFIED\n         CL    REGB,=F'80'         MORE THAN TEN\n         BNH   FNDDCB-4              DD NAMES\n         L     REGB,=F'80'             NOT ALLOWED\n         L     REGF,NEXTERR\n         MVC   0(4,REGF),PTRN207   PATTERN TO ERROR POOL\n         LA    REGF,4(REGF)        UPDATE POINTER\n         ST    REGF,NEXTERR          TO ERROR POOL\n         LA    REGC,LINADD\nFNDDCB   L     REGD,0(REGC)\n         LTR   REGD,REGD\n         BC    8,NXTDDNAM          IF THIS DATASET DOES NOT EXIST\n         CLC   2(8,REGA),=XL8'00'\n         BE    NXTDDNAM            IF THIS DDNAME WAS NOT SPECIFIED\n         USING IHADCB,REGD\n         MVC   DCBDDNAM,2(REGA)\n         DROP  REGD\nNXTDDNAM LA    REGA,8(REGA)\n         LA    REGC,4(REGC)\n         SH    REGB,=H'8'\n         BP    FNDDCB\n         SPACE 2\n* HANDLE HEADING INFORMATION\n         SPACE\nHEADINFO TM    4(14),X'80'\n         BO    OPEN                IF NO HEADING INFORMATION\n         L     RA,8(14)            POINTER TO HEADING INFO\n         ST    RA,HDING            STORE POINTER FOR USE IN LAST PHASE\n         MVC   PAGECNT(4),2(RA)\n         SPACE 2\n* OPEN THE SYSPRINT DCB IF THE SIZE PARAMETER WAS INCORRECT\n         SPACE\nOPEN     L     R8,PRINTADD         ADDR OF SYSPRINT DCB\n         USING IHADCB,R8\n         MVC   DCBEXLST+1(3),=AL3(PRINTEX) ADDR OF EXLIST FOR PRINT DCB\n         DROP  R8\n         SPACE 2\n* FIND THE CORRECT AREA SIZE TABLE AND MOVE IT TO THE COMMON WORKAREA\n         SPACE\nFNDARSIZ LA    RA,ARTAB-(ARTAB1-ARTAB) ADDR OF TABLES - LNGTH OF 1 TAB\n         L     RB,SIZE             SIZE OF AVAILABLE STORAGE\nFNDARTAB LA    RA,ARTAB1-ARTAB(RA) STEP TO NEXT TABLE\n         C     RB,0(RA)\n         BNL   FNDARTAB\n         MVC   INBLKS(ARTAB1-ARTAB-4),4(RA) MOVE TABLE TO COM WORKAREA\n         SPACE 2\n* ACQUIRE THE ERROR POOL AND THE SOURCE PROG BUFFER 1\n* STORE CONTENT OF PRELIMINARY ERROR POOL IN NEW ERROR POOL\n         SPACE\n         L     R0,POOLS            SIZE OF ERROR POOL\n         LR    RA,R0\n         A     R0,SRCE1S           SIZE OF SOURCE PROG BUFFER 1\n         LR    RC,R0               SIZE OF TOTAL AREA\n       GETMAIN R,LV=(0)\n         XI    HCOMPMOD+1,NOBUF         COMMON BUFFER AREA PRESENT\n         L     RB,NEXTERR          ADDR OF NEXT FREE BYTE IN PREL POOL\n         LA    RD,PRELPOOL         ADDR OF BEGIN OF PREL POOL\n         SR    RB,RD               NUMBER OF BYTES IN ERROR POOL\n         EX    RB,MOVEPOOL\n         B     *+10                BRANCH AROUND MVC INSTR\nMOVEPOOL MVC   0(0,R1),PRELPOOL\n         ST    R1,ERRPOOL          ADDR OF FIRST BYTE OF POOL\n         AR    RB,R1               ADDR OF NEXT FREE BYTE\n         ST    RB,NEXTERR\n         AR    RA,R1               ADDR OF END OF POOL +1\n         ST    RA,SRCE1ADD         ADDR OF SOURCE PROG BUFFER 1\n         AR    RC,R1               END ADDR OF SOURCE PROG BUFFER 1\n         ST    RC,SRCE1END\n         SH    RA,=H'24'           ADDR OF END OF POOL -23\n         ST    RA,ENDPOOL\n         SPACE 2\n* COMPLETE THE DATA CONTROL BLOCKS\n         SPACE\n         LM    R3,R12,LINADD       ADDRESSES OF THE DCBS\n         USING IHADCB,R3           SYSLIN DCB\n         MVC   DCBEXLST+1(3),=AL3(LINEX) ADDR OF EXLIST\n         DROP  R3\n         USING IHADCB,R7           SYSIN DCB\n         MVC   DCBEXLST+1(3),=AL3(INEX) ADDR OF EXLIST\n         DROP  R7\n         USING IHADCB,R9           SYSPUNCH DCB\n         MVC   DCBEXLST+1(3),=AL3(PCHEX) ADDR OF EXLIST\n         DROP  R9\n         USING IHADCB,R10          SYSUT1 DCB\n         LH    R4,SRCE1S+2         SOURCE PROG BUFFER 1 SIZE\n         STH   R4,DCBBLKSI         BLOCK SIZE\n         DROP  R10\n         USING IHADCB,R11          SYSUT2 DCB\n         STH   R4,DCBBLKSI         BLOCK SIZE\n         DROP  R11\n         SPACE 2\n* OPEN ALL DATA CONTROL BLOCKS\n         SPACE\n         MVC   ERET,=A(OPEXERR)    ERROR ROUT FOR OPEN EXIT ROUTINES\n         OPEN  ((3),OUTPUT,(8),OUTPUT,(9),OUTPUT,(11),OUTIN,(12),OUTIN)X\n                                   OPEN THE SYSLIN-, SYSPRINT-,        X\n                                   SYSPUNCH-, SYSUT2- AND SYSUT3 DCBS\n         OPEN  ((10),OUTIN)        OPEN THE SYSUT1 DCB\n         OPEN  ((R7),)                  OPEN THE SYSIN DCB\n         MVC   ERET,=A(GOTOTERM)\n         SPACE 2\n* TEST IF THE SYSPRINT DCB HAS BEEN OPENED\n         SPACE\n         USING IHADCB,8\nTSTDCB   TM    DCBOFLGS,X'10'      TERMINATE THE COMPILATION IF THE\n         DROP  8\n         BO    EDITDATE\n         OI    HCOMPMOD+2,PRTNO         SYSPRINT DCB NOT OPENED\n         LR    R7,R8                    DCB ADDRESS\n         L     R4,NEXTERR\n         B     ERROR201\n         SPACE 2\n* GET DATE AND TRANSLATE IT TO MMM DD 19YY\n         SPACE\nEDITDATE EQU   *\n         TIME  ,                   GET SYSTEM DATE\n         ST    R1,FIELD2\n         MVI   FIELD2,X'19'        TWENTIETH CENTURY\n         UNPK  FIELD1(7),FIELD2(4)\n         MVC   YEAR(4),FIELD1      YEAR IN UNPACKED FORM\n         MVO   FIELD1(8),FIELD2+1(1) YEAR IN PACKED FORM\n         CVB   RB,FIELD1\n         SR    RA,RA\n         D     RA,=F'4'\n         LTR   RA,RA\n         BC    7,NOLEAP            LEAP-YEAR IF NO REMAINDER\n         MVI   FEBRUARY+1,X'1D'    FEBRUARY HAS 29 DAYS\nNOLEAP   MVC   FIELD1+6(2),FIELD2+2 PACKED DAY OF THE YEAR\n         CVB   RA,FIELD1           BINARY DAY OF THE YEAR\n         LA    IDX,JANUARY-6       INITIALIZE FOR THE LOOP TO FIND\n*                                    THE ACTUAL MONTH\nFNDMONTH LA    IDX,6(IDX)          INCREASE INDEX FOR NEXT MONTH\n         LR    RB,RA               SAVE DAY\n         SH    RA,0(IDX)           THE MONTH IS FOUND IF\n         BC    12,MONFOUND           THE DIFFERENCE IS ZERO OR NEG\n         CLI   5(IDX),X'FF'\n         BNE   FNDMONTH            IF NOT END OF YEAR\n         MVC   MONTH-1(12),=C'IS INCORRECT'\n         B     DATEND              THE SYSTEM DATE IS INCORRECT\nMONFOUND MVC   MONTH(3),2(IDX)     3-LETTER MONTH NAME\n         CVD   RB,FIELD1           PACKED DAY OF THE MONTH\n         UNPK  DAY(2),FIELD1+6(2)  UNPACKED DAY OF THE MONTH\n         MVZ   DAY+1(1),DAY        MOVE IN PROPER ZONE\nDATEND   EQU   *\n         SPACE 2\n* WRITE FIRST RECORD ON SYSPRINT\n         SPACE\n         L     R1,PRINTADD\n         PUT   (1)                      SKIP TO NEW PAGE\n         MVC   0(2,1),SKIP                BY PRINTING A BLANK LINE\n         MVC   2(89,1),1(1)\n         L     R1,PRINTADD\n         PUT   (1)\n         MVC   0(91,1),FIRSTLIN         FIRST LINE ON FIRST PAGE\n         SPACE 2\n         MVC   ERET,=A(GOTOEDIT)   ERROR ROUT FOR REST OF PHASE\n         SPACE 2\n* TEST IF THE OTHER DCBS HAVE BEEN OPENED\n         SPACE\n         LM    R3,R12,LINADD\n         L     R4,NEXTERR\n         SPACE\n         USING IHADCB,R3           TEST SYSLIN\n         TM    HCOMPMOD+1,NLOAD\n         BO    TSTPUNCH            IF NOLOAD SPECIFIED\n         TM    DCBOFLGS,X'10'\n         BO    TSTPUNCH            IF DCB HAS BEEN OPENED\n         OI    HCOMPMOD+1,NLOAD    SET NOLOAD OPTION BIT ON\n         MVC   0(4,R4),PTRN202     PATTERN FOR MSG 202\n         LA    R4,4(R4)            POINTER TO NEXT FREE ENTRY\n         DROP  R3\n         SPACE\n         USING IHADCB,R9           TEST SYSPUNCH\nTSTPUNCH TM    HCOMPMOD+1,NDCK\n         BO    TSTIN               IF NODECK SPECIFIED\n         TM    DCBOFLGS,X'10'\n         BO    TSTIN               IF DCB HAS BEEN OPENED\n         OI    HCOMPMOD+1,NDCK     SWT NODECK OPTION BIT ON\n         MVC   0(4,R4),PTRN203     PATTERN FOR MSG 203\n         LA    R4,4(R4)            POINTER TO NEXT FREE ENTRY\n         DROP  R9\n         SPACE\nTSTIN    BAL   R14,TSTDCBRT        DCB ADDR FOR SYSIN IS IN REG 7\n         LR    R7,R10              TEST SYSUT1\n         BAL   R14,TSTDCBRT\n         LR    R7,R11              TEST SYSUT2\n         BAL   R14,TSTDCBRT\n         LR    R7,R12              TEST SYSUT3\nERROR201 EQU   *                        ENTRY IF SYSPRINT NOT OPENED\n         LA    R14,STPOINTR        DO NOT RETURN\n         USING IHADCB,R7\nTSTDCBRT TM    DCBOFLGS,X'10'      TEST IF DCB OPENED\n         BCR   1,R14               RETURN IF OK\n         MVC   0(4,R4),PTRN201     PATTERN FOR MSG 201\n         MVC   4(8,R4),DCBDDNAM    DDNAM\n         LA    R4,12(R4)           UPDATE POINTER\n         OI    HCOMPMOD+1,NOGO     SET NOGO SWITCH ON\n         BR    R14                 RETURN\n         DROP  R7\nSTPOINTR ST    R4,NEXTERR\n         SPACE 2\n* END OF INITIALIZATION OF THE COMPILER GO TO SCAN 1/2 OR TO PHASE 21\n* FOR ERROR EDITING IF COMPILATION IS IMPOSSIBLE\n         SPACE\n         TM    HCOMPMOD+1,NOGO\n         BO    GOTOEDIT            IF COMPILATION IMPOSSIBLE\n         L     BASE,=A(IEX10001)\n         BR    BASE                     TO INITIALIZE IEX11\n         SPACE 2\n* DCB EXIT ROUTINES\n         SPACE\n         USING IHADCB,R1\n         SPACE\nINEXRT   LH    RC,INBLKS           MAX BLOCKSIZE ALLOWED\n         BAL   RE,COMEXRT          BRANCH TO ROUT COMMON TO ALL EXIT RT\n         OI    HCOMPMOD+1,NOGO     ABNORMAL RETURN, SET NOGO SWITCH ON\n         MVC   0(4,RF),PTRN204     ERROR PATTERN FOR MSG 204\n         LA    RF,4(RF)            UPDATE POINTER TO\n         ST    RF,NEXTERR            NEXT ENTRY\n         BR    R14                 RETURN TO OPEN ROUT\n         SPACE\nLINEXRT  LH    RC,LINBLKS          MAX BLOCKSIZE ALLOWED\n         BAL   RE,COMEXRT          BRANCH TO COMMON ROUTINE\n         MVC   0(12,RF),PTRN205A   PATTERN FOR MSG 205 AND SYSLIN\n         LA    RF,12(RF)           UPDATE POINTER TO\n         ST    RF,NEXTERR            NEXT ENTRY\n         BR    R14                 RETURN TO OPEN ROUT\n         SPACE\nPCHEXRT  LH    RC,PCHBLKS          MAX BLOCKSIZE ALLOWED\n         BAL   RE,COMEXRT          BRANCH TO COMMON ROUTINE\n         MVC   0(12,RF),PTRN205B   PATTERN FOR MSG 205 AND SYSPUNCH\n         LA    RF,12(RF)           UPDATE POINTER TO\n         ST    RF,NEXTERR            NEXT ENTRY\n         BR    R14                 RETURN TO OPEN ROUTINE\n         SPACE\nPRTEXRT  LH    RC,PRTBLKS          MAX BLOCKSIZE ALLOWED\n         BAL   RE,COMEXRT          BRANCH TO COMMON ROUTINE\n         MVC   0(12,RF),PTRN205C   PATTERN FOR MSG 205 AND SYSPRINT\n         LA    RF,12(RF)           UPDATE POINTER TO\n         ST    RF,NEXTERR            NEXT ENTRY\n         BR    R14                 RETURN TO OPEN ROUTINE\n         SPACE\nCOMEXRT  LH    RB,DCBBLKSI         BLOCKSIZE FROM DCB\n         LH    RD,DCBLRECL         RECORD LENGTH FROM DCB\n         LTR   RB,RB               TEST IF BLKSIZE WAS SPECIFIED IN DD\n         BC    7,DIVTEST           IF SPECIFIED.\n         STH   RD,DCBBLKSI         SET BLKSIZE EQU LRECL\n         BR    R14                 RETURN TO OPEN ROUTINE\nDIVTEST  L     RF,NEXTERR          ADD OF NEXT ENTRY IN ERROR POOL\n         SR    RA,RA               TEST IF BLKSIZE\n         DR    RA,RD                 IS A MULTIPLE\n         LTR   RA,RA                 OF LRECL\n         BC    7,NOTOK             IF NOT MULTIPLE\n         TM    HCOMPMOD+1,NOBUF    GO BACK TO OPEN ROUTINE IF THE\n         BCR   1,R14                 SIZE PARAMETER WAS INCORRECT\n         LH    RA,DCBBLKSI\n         CLR   RA,RC               TEST IF BLOCKSIZE TOO LARGE\n         BCR   12,R14              IF OK\nNOTOK    STH   RD,DCBBLKSI         SET BLOCKSIZE EQU RECORD LENGTH\n         BR    RE                  ERROR RETURN\n         DROP  R1\n         SPACE 2\n* ERROR ROUTINES\n         SPACE\n*  ROUTINE FOR UNEXPECTED ERROR DURING OPEN. ENTERED VIA ERET.\n         SPACE\nOPEXERR  OI    HCOMPMOD+1,NOGO\n         BR    R14                 GO BACK TO OPEN ROUTINE\n         DROP  BASE\n         SPACE\n*  EXIT TO TERMINATING PHASE IF ERROR EDITING NOT POSSIBLE.\n         SPACE\nGOTOTERM BALR  BASE,0\n         USING *,BASE\n         BAL   RA,CLOSE\n         XCTL  EP=IEX51002         GO TO TERMINATING PHASE\n         DROP  BASE\n         SPACE\n*  TERMINATE VIA ERROR EDITING PHASE.\n         SPACE\nGOTOEDIT BALR  BASE,0\n         USING *,BASE\n         BAL   RA,CLOSE\n         OI    HCOMPMOD,X'08'      INDICATE TERMINATING ERROR\n         XCTL  EP=IEX21000         GO TO EDIT PHASE\n         DROP  BASE\n         SPACE\n*  SUBROUTINE FOR CLOSING SYSIN AND SYSUT1\n         SPACE\nCLOSE    BALR  R3,0\n         USING *,R3\n         L     R6,INADD\n         USING IHADCB,R6\n         TM    DCBOFLGS,X'10'           TEST IF OPENED\n         DROP  R6\n         BO    *+8\n         OI    SWITCH+1,X'F0'           IF SYSIN NOT OPENED\n         L     R7,UT1ADD\n         CLOSE ((6),,(7))               CLOSE SYSIN AND SYSUT1\nSWITCH   NOPR  RA                       RETURN IF SYSIN NOT OPENED\n         FREEPOOL (R6)                  FREE SYSIN BUFFER\n         BR    RA                       RETURN\n         DROP  R3\n         SPACE 2\n         LTORG\n         EJECT\n* DCB EXIT LIST FOR SYSIN, SYSLIN, SYSPUNCH AND SYSPRINT\n         SPACE\n         DS    0F\nINEX     DC    X'85',AL3(INEXRT)\nLINEX    DC    X'85',AL3(LINEXRT)\nPCHEX    DC    X'85',AL3(PCHEXRT)\nPRINTEX  DC    X'85',AL3(PRTEXRT)\n         SPACE 2\n* TABLE OF THE SIZES OF WORKAREAS WHICH VARY WITH THE AVAILABLE MAIN-\n* STORAGE\n         SPACE\n* AVAILABLE SPACE IS BETWEEN 44K AND 50K\nARTAB    EQU   *\n         DC    F'51200'  50K\n         DC    H'400'    MAX BLKSIZE FOR SYSIN\n         DC    H'455'    MAX BLKSIZE FOR SYSPRINT\n         DC    H'400'    MAX BLKSIZE FOR SYSLIN\n         DC    H'80'     MAX BLKSIZE FOR SYSPUNCH\n         DC    F'600'    SIZE OF ERROR POOL\n         DC    F'1024'   SOURCE PROG BUFFERS 1 AND 2\n         DC    F'8184'   ITAB FOR PHASE 10\n         DC    F'25000'  ITAB FOR PHASE 20\n         DC    F'8800'   ITAB FOR PHASE 30\n         DC    F'450'    CRIDTAB FOR PHASE 30\n         DC    F'1400'   SUTAB BUFFER FOR PHASE 30\n         DC    F'800'    LVTAB BUFFER FOR PHASE 30\n         DC    F'224'    OPTAB BUFFERS 1 AND 2 FOR PHASES 40 AND 50\n         DC    F'7200'   LVTAB UNSORTED AND SORTED FOR PHASE 40\n         DC    F'14000'  SUTAB UNSORTED AND SORTED FOR PHASE 40\n         DC    F'768'    OPERATOR OPERAND STACK FOR PHASE 50\n         SPACE\n* AVAILABLE SPACE IS BETWEEN 50K AND 58K\nARTAB1   EQU   *\n         DC    F'59392'  58K\n         DC    H'400'    MAX BLKSIZE FOR SYSIN\n         DC    H'455'    MAX BLKSIZE FOR SYSPRINT\n         DC    H'400'    MAX BLKSIZE FOR SYSLIN\n         DC    H'400'    MAX BLKSIZE FOR SYSPUNCH\n         DC    F'1000'   SIZE OF ERROR POOL\n         DC    F'1536'   SOURCE PROGRAM BUFFERS 1 AND 2\n         DC    F'11924'  ITAB FOR PHASE 10\n         DC    F'29500'  ITAB FOR PHASE 20\n         DC    F'11500'  ITAB FOR PHASE 30\n         DC    F'450'    CRIDTAB FOR PHASE 30\n         DC    F'1400'   SUTAB BUFFER FOR PHASE 30\n         DC    F'800'    LVTAB BUFFER FOR PHASE 30\n         DC    F'910'    OPTAB BUFFERS FOR PHASE 40 AND 50\n         DC    F'8000'   LVTAB UNSORTED AND SORTED FOR PHASE 40\n         DC    F'15400'  SUTAB UNSORTED AND SORTED FOR PHASE 40\n         DC    F'3072'   OPERATOR/OPERAND STACK FOR PHASE 50\n         SPACE\n* AVAILABLE SPACE IS BETWEEN 58K AND 66K\n         DC    F'67584'  66K\n         DC    H'400'    MAX BLKSIZE FOR SYSIN\n         DC    H'455'    MAX BLKSIZE FOR SYSPRINT\n         DC    H'400'    MAX BLKSIZE FOR SYSLIN\n         DC    H'400'    MAX BLKSIZE FOR SYSPUNCH\n         DC    F'1304'   SIZE OF ERROR POOL\n         DC    F'2000'   SOURCE PROGRAM BUFFERS 1 AND 2\n*                          INCREASE TO 2048 WHEN TRACK OVFL SUPPORTED\n         DC    F'17754'  ITAB FOR PHASE 10\n         DC    F'36500'  ITAB FOR PHASE 20\n         DC    F'15000'  ITAB FOR PHASE 30\n         DC    F'900'    CRIDTAB FOR PHASE 30\n         DC    F'1400'   SUTAB BUFFER FOR PHASE 30\n         DC    F'800'    LVTAB BUFFER FOR PHASE 30\n         DC    F'1792'   OPTAB BUFFERS FOR PHASE 40 AND 50\n         DC    F'9600'   LVTAB UNSORTED AND SORTED FOR PHASE 40\n         DC    F'18200'  SUTAB UNSORTED AND SORTED FOR PHASE 40\n         DC    F'6144'   OPERATOR/OPERAND STACK FOR PHASE 50\n         SPACE\n* AVAILABLE SPACE IS BETWEEN 66K AND 76K\n         DC    F'77824'  76K\n         DC    H'400'    MAX BLKSIZE FOR SYSIN\n         DC    H'455'    MAX BLKSIZE FOR SYSPRINT\n         DC    H'400'    MAX BLKSIZE FOR SYSLIN\n         DC    H'400'    MAX BLKSIZE FOR SYSPUNCH\n         DC    F'1600'   SIZE OF ERROR POOL\n         DC    F'2000'   SOURCE PROGRAM BUFFERS 1 AND 2\n*                          INCREASE TO 4096 WHEN TRACK OVFL SUPPORTED\n         DC    F'21054'  ITAB FOR PHASE 10\n         DC    F'41000'  ITAB FOR PHASE 20\n         DC    F'16000'  ITAB FOR PHASE 30\n         DC    F'900'    CRIDTAB FOR PHASE 30\n         DC    F'1400'   SUTAB BUFFER FOR PHASE 30\n         DC    F'800'    LVTAB BUFFER FOR PHASE 30\n         DC    F'1792'   OPTAB BUFFERS FOR PHASE 40 AND 50\n         DC    F'11200'  LVTAB UNSORTED AND SORTED FOR PHASE 40\n         DC    F'21000'  SUTAB UNSORTED AND SORTED FOR PHASE 40\n         DC    F'6144'   OPERATOR/OPERAND STACK FOR PHASE 50\n         SPACE\n* AVAILABLE SPACE IS BETWEEN 76K AND 88K\n         DC    F'90112'  88K\n         DC    H'400'    MAX BLKSIZE FOR SYSIN\n         DC    H'455'    MAX BLKSIZE FOR SYSPRINT\n         DC    H'400'    MAX BLKSIZE FOR SYSLIN\n         DC    H'400'    MAX BLKSIZE FOR SYSPUNCH\n         DC    F'2000'   SIZE OF ERROR POOL\n         DC    F'2000'   SOURCE PROGRAM BUFFERS 1 AND 2\n*                          INCREASE TO 6144 WHEN TRACK OVFL SUPPORTED\n         DC    F'23584'  ITAB FOR PHASE 10\n         DC    F'48000'  ITAB FOR PHASE 20\n         DC    F'16000'  ITAB FOR PHASE 30\n         DC    F'1350'   CRIDTAB FOR PHASE 30\n         DC    F'1400'   SUTAB BUFFER FOR PHASE 30\n         DC    F'800'    LVTAB BUFFER FOR PHASE 30\n         DC    F'1792'   OPTAB BUFFERS FOR PHASE 40 AND 50\n         DC    F'12800'  LVTAB UNSORTED AND SORTED FOR PHASE 40\n         DC    F'23800'  SUTAB UNSORTED AND SORTED FOR PHASE 40\n         DC    F'6144'   OPERATOR/OPERAND STACK FOR PHASE 50\n         SPACE\n* AVAILABLE SPACE IS BETWEEN 88K AND 102K\n         DC    F'104448' 102K\n         DC    H'1600'   MAX BLKSIZE FOR SYSIN\n         DC    H'1820'   MAX BLKSIZE FOR SYSPRINT\n         DC    H'3200'   MAX BLKSIZE FOR SYSLIN\n         DC    H'1600'   MAX BLKSIZE FOR SYSPUNCH\n         DC    F'2000'   SIZE OF ERROR POOL\n         DC    F'2000'   SOURCE PROGRAM BUFFERS 1 AND 2\n*                          INCREASE TO 6144 WHEN TRACK OVFL SUPPORTED\n         DC    F'23584'  ITAB FOR PHASE 10\n         DC    F'50000'  ITAB FOR PHASE 20\n         DC    F'16000'  ITAB FOR PHASE 30\n         DC    F'1350'   CRIDTAB FOR PHASE 30\n         DC    F'1400'   SUTAB BUFFER FOR PHASE 30\n         DC    F'800'    LVTAB BUFFER FOR PHASE 30\n         DC    F'1792'   OPTAB BUFFERS FOR PHASE 40 AND 50\n         DC    F'13600'  LVTAB UNSORTED AND SORTED FOR PHASE 40\n         DC    F'25200'  SUTAB UNSORTED AND SORTED FOR PHASE 40\n         DC    F'6144'   OPERATOR/OPERAND STACK FOR PHASE 50\n         SPACE\n* AVAILABLE SPACE IS BETWEEN 102K AND 118K\n         DC    F'120832' 118K\n         DC    H'1600'   MAX BLKSIZE FOR SYSIN\n         DC    H'1820'   MAX BLKSIZE FOR SYSPRINT\n         DC    H'3200'   MAX BLKSIZE FOR SYSLIN\n         DC    H'1600'   MAX BLKSIZE FOR SYSPUNCH\n         DC    F'2000'   SIZE OF ERROR POOL\n         DC    F'2000'   SOURCE PROGRAM BUFFERS 1 AND 2\n*                          INCREASE TO 8192 WHEN TRACK OVFL SUPPORTED\n         DC    F'32736'  ITAB FOR PHASE 10\n         DC    F'62000'  ITAB FOR PHASE 20\n         DC    F'19000'  ITAB FOR PHASE 30\n         DC    F'2250'   CRIDTAB FOR PHASE 30\n         DC    F'1400'   SUTAB BUFFER FOR PHASE 30\n*                          INCREASE TO  2800 WHEN TRACK OVFL SUPPORTED\n         DC    F'1600'   LVTAB BUFFER FOR PHASE 30\n         DC    F'1792'   OPTAB BUFFERS FOR PHASE 40 AND 50\n         DC    F'16000'  LVTAB UNSORTED AND SORTED FOR PHASE 40\n         DC    F'30800'  SUTAB UNSORTED AND SORTED FOR PHASE 40\n         DC    F'6144'   OPERATOR/OPERAND STACK FOR PHASE 50\n         SPACE\n* AVAILABLE SPACE IS BETWEEN 118K AND 136K\n         DC    F'139264' 136K\n         DC    H'1600'   MAX BLKSIZE FOR SYSIN\n         DC    H'1820'   MAX BLKSIZE FOR SYSPRINT\n         DC    H'3200'   MAX BLKSIZE FOR SYSLIN\n         DC    H'1600'   MAX BLKSIZE FOR SYSPUNCH\n         DC    F'2000'   SIZE OF ERROR POOL\n         DC    F'2000'   SOURCE PROGRAM BUFFERS 1 AND 2\n*                          INCREASE TO 8192 WHEN TRACK OVFL SUPPORTED\n         DC    F'32736'  ITAB FOR PHASE 10\n         DC    F'75000'  ITAB FOR PHASE 20\n         DC    F'25000'  ITAB FOR PHASE 30\n         DC    F'3600'   CRIDTAB FOR PHASE 30\n         DC    F'1400'   SUTAB BUFFER FOR PHASE 30\n*                          INCREASE TO  7000 WHEN TRACK OVFL SUPPORTED\n         DC    F'1600'   LVTAB BUFFER FOR PHASE 30\n*                          INCREASE TO 4800 WHEN TRACK OVFL SUPPORTED\n         DC    F'1792'   OPTAB BUFFERS FOR PHASE 40 AND 50\n         DC    F'19200'  LVTAB UNSORTED AND SORTED FOR PHASE 40\n         DC    F'35000'  SUTAB UNSORTED AND SORTED FOR PHASE 40\n         DC    F'6144'   OPERATOR/OPERAND STACK FOR PHASE 50\n         SPACE\n* AVAILABLE SPACE IS BETWEEN 136K AND 156K\n         DC    F'159744' 156K\n         DC    H'1600'   MAX BLKSIZE FOR SYSIN\n         DC    H'1820'   MAX BLKSIZE FOR SYSPRINT\n         DC    H'3200'   MAX BLKSIZE FOR SYSLIN\n         DC    H'1600'   MAX BLKSIZE FOR SYSPUNCH\n         DC    F'2000'   SIZE OF ERROR POOL\n         DC    F'2000'   SOURCE PROGRAM BUFFERS 1 AND 2\n*                          INCREASE TO 8192 WHEN TRACK OVFL SUPPORTED\n         DC    F'32736'  ITAB FOR PHASE 10\n         DC    F'95000'  ITAB FOR PHASE 20\n         DC    F'38000'  ITAB FOR PHASE 30\n         DC    F'3600'   CRIDTAB FOR PHASE 30\n         DC    F'1400'   SUTAB BUFFER FOR PHASE 30\n*                          INCREASE TO  7000 WHEN TRACK OVFL SUPPORTED\n         DC    F'1600'   LVTAB BUFFER FOR PHASE 30\n*                          INCREASE TO 4800 WHEN TRACK OVFL SUPPORTED\n         DC    F'1792'   OPTAB BUFFERS FOR PHASE 40 AND 50\n         DC    F'24000'  LVTAB UNSORTED AND SORTED FOR PHASE 40\n         DC    F'35000'  SUTAB UNSORTED AND SORTED FOR PHASE 40\n         DC    F'6144'   OPERATOR/OPERAND STACK FOR PHASE 50\n         SPACE\n* AVAILABLE SPACE IS BETWEEN 156K AND 180K\n         DC    F'184320' 180K\n         DC    H'1600'   MAX BLKSIZE FOR SYSIN\n         DC    H'1820'   MAX BLKSIZE FOR SYSPRINT\n         DC    H'3200'   MAX BLKSIZE FOR SYSLIN\n         DC    H'1600'   MAX BLKSIZE FOR SYSPUNCH\n         DC    F'2000'   SIZE OF ERROR POOL\n         DC    F'2000'   SOURCE PROGRAM BUFFERS 1 AND 2\n*                          INCREASE TO 8192 WHEN TRACK OVFL SUPPORTED\n         DC    F'32736'  ITAB FOR PHASE 10\n         DC    F'115000' ITAB FOR PHASE 20\n         DC    F'58000'  ITAB FOR PHASE 30\n         DC    F'3600'   CRIDTAB FOR PHASE 30\n         DC    F'1400'   SUTAB BUFFER FOR PHASE 30\n*                          INCREASE TO  7000 WHEN TRACK OVFL SUPPORTED\n         DC    F'1600'   LVTAB BUFFER FOR PHASE 30\n*                          INCREASE TO 6400 WHEN TRACK OVFL SUPPORTED\n         DC    F'1792'   OPTAB BUFFERS FOR PHASE 40 AND 50\n         DC    F'25600'  LVTAB UNSORTED AND SORTED FOR PHASE 40\n         DC    F'56000'  SUTAB UNSORTED AND SORTED FOR PHASE 40\n         DC    F'6144'   OPERATOR/OPERAND STACK FOR PHASE 50\n         SPACE\n* AVAILABLE SPACE IS BETWEEN 180K AND 208K\n         DC    F'212992' 208K\n         DC    H'3200'   MAX BLKSIZE FOR SYSIN\n         DC    H'3640'   MAX BLKSIZE FOR SYSPRINT\n         DC    H'3200'   MAX BLKSIZE FOR SYSLIN\n         DC    H'3200'   MAX BLKSIZE FOR SYSPUNCH\n         DC    F'2000'   SIZE OF ERROR POOL\n         DC    F'2000'   SOURCE PROGRAM BUFFERS 1 AND 2\n*                          INCREASE TO 8192 WHEN TRACK OVFL SUPPORTED\n         DC    F'32736'  ITAB FOR PHASE 10\n         DC    F'135000' ITAB FOR PHASE 20\n         DC    F'58000'  ITAB FOR PHASE 30\n         DC    F'3600'   CRIDTAB FOR PHASE 30\n         DC    F'1400'   SUTAB BUFFER FOR PHASE 30\n*                          INCREASED TO 7000 WHEN TRACK OVFL SUPPORTED\n         DC    F'1600'   LVTAB BUFFER FOR PHASE 30\n*                          INCREASE TO 6400 WHEN TRACK OVFL SUPPORTED\n         DC    F'1792'   OPTAB BUFFERS FOR PHASE 40 AND 50\n         DC    F'25600'  LVTAB UNSORTED AND SORTED FOR PHASE 40\n         DC    F'56000'  SUTAB UNSORTED AND SORTED FOR PHASE 40\n         DC    F'6144'   OPERATOR/OPERAND STACK FOR PHASE 50\n         SPACE\n* AVAILABLE SPACE IS 208K OR MORE\n         DC    F'16777216'\n         DC    H'3200'   MAX BLKSIZE FOR SYSIN\n         DC    H'3640'   MAX BLKSIZE FOR SYSPRINT\n         DC    H'3200'   MAX BLKSIZE FOR SYSLIN\n         DC    H'3200'   MAX BLKSIZE FOR SYSPUNCH\n         DC    F'2000'   SIZE OF ERROR POOL\n         DC    F'2000'   SOURCE PROGRAM BUFFERS 1 AND 2\n*                          INCREASE TO 8192 WHEN TRACK OVFL SUPPORTED\n         DC    F'32736'  ITAB FOR PHASE 10\n         DC    F'162000' ITAB FOR PHASE 20\n         DC    F'58000'  ITAB FOR PHASE 30\n         DC    F'3600'   CRIDTAB FOR PHASE 30\n         DC    F'1400'   SUTAB BUFFER FOR PHASE 30\n*                          INCREASE TO 11200 WHEN TRACK OVFL SUPPORTED\n         DC    F'1600'   LVTAB BUFFER FOR PHASE 30\n*                          INCREASE TO 6400 WHEN TRACK OVFL SUPPORTED\n         DC    F'1792'   OPTAB BUFFERS FOR PHASE 40 AND 50\n         DC    F'25600'  LVTAB UNSORTED AND SORTED FOR PHASE 40\n         DC    F'56000'  SUTAB UNSORTED AND SORTED FOR PHASE 40\n         DC    F'6144'   OPERATOR/OPERAND STACK FOR PHASE 50\n         SPACE 2\n* PATTERNS FOR THE ERROR MESSAGES OF THE INITIALIZATION PHASE\n         SPACE\n* W OPTION PARAMETER ... IS INVALID. THE PARAMETER IS DISREGARDED\nPTRN200  DC    AL1(128+16,200),AL2(0),CL12' '\n         SPACE\n* T DD CARD FOR ... IS INCORRECT OR MISSING\nPTRN201  DC    AL1(128+12,201),AL2(0)\n         SPACE\n* W DD CARD FOR SYSLIN IS INCORRECT OR MISSING. OPTION NOLOAD IS\n*   ASSUMED\nPTRN202  DC    AL1(128+4,202),AL2(0)\n         SPACE\n* W DD CARD FOR SYSPUNCH IS INCORRECT OF MISSING. OPTION NODECK IS\n*   ASSUMED\nPTRN203  DC    AL1(128+4,203),AL2(0)\n         SPACE\n* T BLOCKSIZE SPECIFIED FOR SYSIN IS INCORRECT\nPTRN204  DC     AL1(128+4,204),AL2(0)\n         SPACE\n* W BLOCKSIZE SPECIFIED FOR ... IS INCORRECT. UNBLOCKED OUTPUT IS\n*   GENERATED INSTEAD\nPTRN205A DC    AL1(128+12,205),AL2(0),CL8'SYSLIN'\nPTRN205B DC    AL1(128+12,205),AL2(0),CL8'SYSPUNCH'\nPTRN205C DC    AL1(128+12,205),AL2(0),CL8'SYSPRINT'\n         SPACE\n* W INCORRECT PARAMETER FIELD. NO OPTION PARAMETERS ARE HANDLED ANY\n*   MORE\nPTRN206  DC    AL1(128+4,206),AL2(0)\n         SPACE\n* W POSSIBLE ERROR IN DD NAMES PARAMETER\nPTRN207  DC    AL1(128+4,207),AL2(0)\n         SPACE\n* T SIZE PARAMERER IS INCORRECT. MINIMUM STORAGE SIZE FOR ALGOL F COM-\n*   PILER IS 45056 BYTES\nPTRN208   DC   AL1(128+4,208),AL2(0)\n         SPACE 2\n* FIRST LINE OF PRINTED OUTPUT\n         SPACE\nSKIP     DC    X'89',C' '               RECORD WITH SKIP CTL CHAR.\nFIRSTLIN DC    X'11'                    CTL PRINT AND DOUBLE SPACE\nLEVEL    DC    C'LEVEL 1JUL67',CL28' ',C'OS ALGOL F',CL23' ',C'DATE  '\nMONTH    DC    CL4' '\nDAY      DC    CL3' '\nYEAR     DC    CL4' '\n         SPACE 2\n* TABLE OF THE MONTH NAMES AND THE NUMBER OF DAYS\n         SPACE\nJANUARY  DC    H'31'\n         DC    C'JAN '\nFEBRUARY DC    H'28'\n         DC    C'FEB '\n         DC    H'31'\n         DC    C'MAR '\n         DC    H'30'\n         DC    C'APR '\n         DC    H'31'\n         DC    C'MAY '\n         DC    H'30'\n         DC    C'JUN '\n         DC    H'31'\n         DC    C'JUL '\n         DC    H'31'\n         DC    C'AUG '\n         DC    H'30'\n         DC    C'SEP '\n         DC    H'31'\n         DC    C'OCT '\n         DC    H'30'\n         DC    C'NOV '\n         DC    H'31'\n         DC    C'DEC'\n         DC    X'FF'               END OF YEAR INDICATOR\n         SPACE 2\n* TABLE OF OPTION PARAMETERS\n         SPACE\nPARMLIST DC    HL1'6'\n         DC    CL9'PROGRAM'\n         NI    PARMFLD,PGR\nLENGTH   DC    HL1'8'                   (LENGTH-1) OF PARAM\nPARAM    DC    CL9'PROCEDURE'           PARAMETER\nINSTR    OI    PARMFLD,PROC             SET SWITCH IN HCOMPMOD\n         DC    HL1'4'\n         DC    CL9'SHORT'\n         NI    PARMFLD,SHRT\n         DC    HL1'3'\n         DC    CL9'LONG'\n         OI    PARMFLD,LNG\n         DC    HL1'5'\n         DC    CL9'SOURCE'\n         NI    PARMFLD+1,SRCE\n         DC    HL1'7'\n         DC    CL9'NOSOURCE'\n         OI    PARMFLD+1,NSRCE\n         DC    HL1'3'\n         DC    CL9'LOAD'\n         NI    PARMFLD+1,LOAD\n         DC    HL1'5'\n         DC    CL9'NOLOAD'\n         OI    PARMFLD+1,NLOAD\n         DC    HL1'3'\n         DC    CL9'DECK'\n         NI    PARMFLD+1,DCK\n         DC    HL1'5'\n         DC    CL9'NODECK'\n         OI    PARMFLD+1,NDCK\n         DC    HL1'5'\n         DC    CL9'EBCDIC'\n         NI    PARMFLD+1,EBCDIC\n         DC    HL1'5'\n         DC    CL9'NOTEST'\n         OI    PARMFLD+2,NOTEST\n         DC    HL1'3'\n         DC    CL9'TEST'\n         NI    PARMFLD+2,TEST\n         DC    HL1'2'\n         DC    CL9'ISO'\n         OI    PARMFLD+1,ISO\n         DC    HL1'1'\n         DC    CL9'NS'\n         OI    PARMFLD+1,NSRCE\n         DC    HL1'1'\n         DC    CL9'ND'\n         OI    PARMFLD+1,NDCK\n         DC    HL1'1'\n         DC    CL9'NL'\n         OI    PARMFLD+1,NLOAD\n         DC    HL1'1'\n         DC    CL9'EB'\n         NI    PARMFLD+1,EBCDIC\n         DC    HL1'1'\n         DC    CL9'PG'\n         NI    PARMFLD,PGR\n         DC    HL1'1'\n         DC    CL9'PC'\n         OI    PARMFLD,PROC\n         DC    HL1'1'\n         DC    CL9'NT'\n         OI    PARMFLD+2,NOTEST\n         DC    HL1'1'\n         DC    CL9'SP'\n         NI    PARMFLD,SHRT\n         DC    HL1'1'\n         DC    CL9'LP'\n         OI    PARMFLD,LNG\n         DC    HL1'0'\n         DC    CL9'D'\n         NI    PARMFLD+1,DCK\n         DC    HL1'0'\n         DC    CL9'I'\n         OI    PARMFLD+1,ISO\n         DC    HL1'0'\n         DC    CL9'L'\n         NI    PARMFLD+1,LOAD\n         DC    HL1'0'\n         DC    CL9'S'\n         NI    PARMFLD+1,SRCE\nLSTENTRY DC    HL1'0'\n         DC    CL9'T'\n         NI    PARMFLD+2,TEST\n         SPACE 2\n* WORKSPACE FOR TRANSLATING THE SIZE PARAMTER AND THE ACTUAL DATE\n         SPACE\nFIELD1   DS    0D\n         DC    PL8'0'\nFIELD2   DS    F\n         EJECT\nIEX10001 CSECT\n         USING IEX10001,BASE\n         SPACE 2\n*  (INSTRUCTIONS FOR INITIALIZING IEX11 CAN BE INSERTED HERE)\n         SPACE 2\n         XCTL  EP=IEX11000              EXIT TO NEXT PHASE\n         EJECT\n* DUMMY CONTROL SECTION TO PROVIDE ADRESSABILITY OF DCB\n         SPACE\n         DCBD  DSORG=(PS)\n EJECT\nWORKAREA DSECT\n         COPY  WORKAREA\n         SPACE 2\n*  CWA SYMBOL DEFINITIONS FOR IEX11 CAN BE INSERTED HERE\n         SPACE 2\n         END   IEX10000\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IEX11": {"ttr": 1542, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x98\\x01/\\x00\\x98\\x01/\\x16 \\x10:\\x10:\\x00\\x00\\xd6\\xf3\\xf6\\xf0`\\xf2\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1998-01-12T00:00:00", "modifydate": "1998-01-12T16:20:00", "lines": 4154, "newlines": 4154, "modlines": 0, "user": "O360-20"}, "text": "         TITLE 'SCAN I/II  IEX11000'\n*STATUS: CHANGE LEVEL 000                                             *\n*                                                                     *\n*FUNCTION/OPERATION: TO TRANSFORM THE SOURCE PROGRAM TO               *\n*   MODIFICATION LEVEL 1, WHICH INCLUDES A ONE FOR ONE TRANSLATION OF *\n*   ALL CHARACTERS, THE REPLACEMENT OF ALL ALGOL DELIMITERS BY ONE    *\n*   BYTE OPERATORS AND THE REMOVAL OR MODIFICATION OF ALL             *\n*   DECLARATIONS.                                                     *\n*   TO TABULATE AND CLASSIFY ALL VALID IDENTIFIERS.                   *\n*   TO ASSIGN A SERIAL PROGRAM BLOCK NUMBER TO ALL BLOCKS AND         *\n*   PROCEDURES AND A SERIAL GROUP NUMBER TO ALL BLOCKS, PROCEDURES    *\n*   AND FOR STATEMENTS.                                               *\n*   TO RECOGNIZE SYNTACTICAL ERRORS IN THE SOURCE PROGRAM AND TO      *\n*   GENERATE APPROPRIATE ERROR PATTERNS.                              *\n*   TO PRINT A LISTING ON SYSPRINT OF THE SOURCE PROGRAM IF OPTION    *\n*   'SOURCE' IS SPECIFIED.                                            *\n*   TO PREPARE TABLES TO BE USED BY THE SUCCEEDING PHASES. THE TABLES *\n*   ARE PBTAB1, GROUPTABLE, AND SCOPETABLE.                           *\n*                                                                     *\n*ENTRY POINTS:                                                        *\n*        IEX11000   SCAN I/II    XCTL EP=IEX11000                     *\n*                                                                     *\n*INPUT: THE SOURCE PROGRAM IS READ IN FROM SYSIN.                     *\n*                                                                     *\n*OUTPUT: THE SOURCE PROGRAM, MODIFICATION LEVEL 1, IS WRITTEN ON      *\n*   SYSUT1.                                                           *\n*   AN ITAB RECORD IS WRITTEN FOR EACH BLOCK ON SYSUT3.               *\n*   ESD CARD FOR THE OBJECT MODULE AND TXT CARDS FOR THE CONSTANTS 0  *\n*   THROUGH 15 AND THE STRINGS IN THE CONSTANT POOL ARE WRITTEN ON    *\n*   SYSLIN AND OR SYSPUNCH IF THE OPTIONS 'LOAD' AND OR 'DECK' IS     *\n*   SPECIFIED.                                                        *\n*   THE SOURCE PROGRAM IS LISTED ON SYSPRINT IF OPTION 'SOURCE' IS    *\n*   SPECIFIED.                                                        *\n*                                                                     *\n*EXITS-NORMAL: CONTROL IS GIVEN TO ITAB MANIPULATION, XCTL EP=IEX20000*\n*   IF NO TERMINATING ERROR HAS BEEN DETECTED.                        *\n*                                                                     *\n*EXITS-ERROR: IF A TERMINATING ERROR HAS BEEN DETECTED CONTROL IS     *\n*   GIVEN TO THE ERROR MESSAGE HANDLING PHASE        XCTL  EP=IEX21000*\n*                                                                     *\n*EXTERNAL ROUTINES: THE PRINT ROUTINE IN IEX00 IS USED.               *\n*                                                                     *\n*TABLES/WORKAREAS:                                                    *\n*   BPRTAB    BRANCH ADDRESS TABLE                                    *\n*   TESTTABL  FOR MAINLOOP SCANNING                                   *\n*   RETRANS   FOR TRANSLATION FROM INTERNAL TO EBCDIC CHARACTER SET   *\n*   COMTABLE  USED BY COMMENT PROGRAM                                 *\n*   STRTABLE  USED BY STRING PROGRAM                                  *\n*   BTABLE    USED BY BLANK PROGRAM                                   *\n*   KEYTAB    USED BY TRANSOP                                         *\n*   PTTABLE   USED BY POINT AND POINT IN LIST PROGRAMS                *\n*   TRLTABLE  FOR TRANSLATION FROM EBCDIC TO INTERNAL CHARACTER SET   *\n*   KOPOOL    CONTAIN THE CONSTANTS 0 THROUGH 15                      *\n*   ATABLE    USED BY APOSTROF                                        *\n*   SCTAB     USED TO SAVE THE STARTING SC COUNTER FOR THE BLOCKS     *\n*   WITAB     USED FOR THE ALGOL DELIMITERS                           *\n*   LITAB     FOR DISPLACEMENTS TO WITAB                              *\n*   DELPRGTB  BRANCH ADDRESS TABLE AFTER A DELIMITER HAS BEEN FOUND   *\n*   ARTABLE   USED BY LIST PROGRAM                                    *\n*   WA        80 BYTE WORKAREA WITH 17 PRECEEDING CHARACTERS, USED FOR*\n*             INPUT RECORDS. THE 17 EXTRA BYTES USED TO OVERLAP       *\n*             BETWEEN ONE RECORD AND THE NEXT ONE.                    *\n*   STACK     USED FOR THE SCOPE STRUCTURE HANDLING                   *\n*   ITAB      USED TO TABULATE ALL VALID IDENTIFIERS                  *\n*   SAVEPRT   DUMMY PRINTAREA. USED TO PICK UP STRINGS FROM IN EBCDIC *\n*             FORM IF THE OPTION 'NOSOURCE IS SPECIFIED.              *\n*                                                                     *\n*ATTRIBUTES: NONE                                                     *\n*                                                                     *\n*NOTES: CHARACTER CODE DEPENDENCE                                     *\n*   IF THE SOURCE PROGRAM IS IN ISO CODE A SCAN IS MADE IN THE        *\n*   PROGRAM CIB TO EXCHANGE THE CHARACTERS   4C, 7B, 7C, 6C, 50,      *\n*   WITH THE EBCDIC CHARACTERS               5D, 7E, 7D, 4D, 4E.      *\n*   THEN WHEN THE SOURCE PROGRAM IN WA IS IN EBCDIC FORM IT IS        *\n*   TRANSFERRED TO THE PRINTBUFFER, POSSIBLY THE DUMMY PRINTAREA.     *\n*   THE SOURCE PROGRAM IN WA IS THEN TRANSLATED TO INTERNAL CODE BY   *\n*   MEANS OF THE HEXADECIMAL TABLE TRLTABLE.                          *\n*   THE INVERS TABLE, TRANSLATING FROM INTERNAL TO EBCDIC CODE IS     *\n*   CALLED RETRANS AND IS IN CHARACTER FROM.                          *\n*   THE TRANSFER OF PRECOMPILED AND CODE PROCEDURE NAMES, THE         *\n*   TRANSFER OF STRINGS AND CONSTANTS TO THE CONSTANT POOL AND THE    *\n*   OPERATION OF THE ROUTINE GENERATE DEPENDS ON AN INTERNAL          *\n*   REPRESENTATION OF THE EXTERNAL CHARACTER SET WHICH IS             *\n*   EQUIVALENT TO THE ONE USED AT ASSEMBLY TIME.\n*   THE OPERATION OF THE OTHER PARTS DOES NOT DEPEND UPON A           *\n*   PARTICULAR INTERNAL REPRESENTATION OF THE EXTERNAL CHARACTER SET. *\n*                                                                     *\n*   THIS MODULE IS ONLY INTENDED TO BE EXECUTED IN CONNECTION         *\n*   WITH THE OTHER MODULES OF THE ALGOL COMPILER. IN PARTICULAR IT    *\n*   REQUIRES THE COMMON WORKAREA.                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n         SPACE 2\n         SPACE 2\n         SPACE 2\n*   CONTROL SECTION 1 CONTAINS:\n*                               INITIALIZATION\n*                               MAINLOOP AND ITS SUBPROGRAMS\n*                                       BLANK\n*                                       TRANSOP (*,/,(,>,<,NOT,)\n*                                       RIGHTPAR\n*                                       POINT\n*                                       COLON\n*                                            LABEL\n*                                            LETDEL\n*                                            ASSIGN\n*                                       APOSTROPHE\n*                                            SCALE\n*                                            BLKAPOS\n*                                            ZETAAPOS\n*                                            NPAFAPO (NOT PERMITTED)\n*                               SOME GENERAL ROUTINES\n*                                       STATE  (STATEMENT PROGRAM)\n*                                       ERROR ROUTINES\n*                                       ITABCLEA\n*                                       IDCHCK1\n*                                       FINDSEMCO\n*                             AND TABLES AND CONSTANTS OUTSIDE CWA\n*   CONTROL SECTION 2 CONTAINS:\n*                               COB (CHANGE OUTPUT BUFFER)\n*                               CIB (CHANGE INPUT BUFFER)\n*                               DELIMITER\n*                                       EROUT (DELIMITER ERROR ROUTINE)\n*                             NORMAL (/ OR AND NOT STEP LESS\n*                                     IMPL UNTIL WHILE POWER EQUIU\n*                                     NOTLESS GREATER NOTEQUAL\n*                                     NOT GREATER)\n*                                       BOLCON ('TRUE', 'FALSE')\n*                                       GIF (GOTO, IF)\n*                                       TED (THEN, ELSE, DO)\n*                                       BEGIN\n*                                       BEGI (BLOCKHEAD)\n*                                       END\n*                                            FOREND\n*                                            PBLCKEND\n*                                       COM (COMMENT)\n*                                       FOR\n*                                       TYPE ( REAL, INTEGER, BOOLEAN)\n*                                  IER (IDENT. ERROR ROUTINE)\n*                                       CODE\n*   CONTROL SECTION 3 CONTAINS:\n*                               IDCHECK (SPECIFIED IDENTIFIERS)\n*                               VALUE\n*                               TYPEARRAY\n*                                       ARRAY\n*                               TRATE (ARRAY AND SWITCH LIST)\n*                                       PONTLST\n*                                       SEMCLST\n*                                       LEFTPARL\n*                                       RIGHTPARL\n*                                       SLASHLST\n*                                       COMMALST\n*                                       COLONLST\n*                               SWITCH\n*                               STRING\n*                               TYPPROC\n*                               PROCEDURE\n*                                     PROCEDEL (PROC. LETTERSTRING)\n*                               ENDMISSIN (UNBALLANCED BEGIN END COUNT)\n*   CONTROL SECTION 4 CONTAINS:\n*                               TERMINATION\n*\n*\n*\nIEX11000 START\n* RELEASE 19 CHANGES\n* 777400                                                         A22571\n*                                                                A28230\n*                                                                A28251\n* RELEASE 20 CHANGES\n* 112800,348000                                                  A32949\nREG0     EQU   0\nREGI     EQU   1                  INPUT POINTER\nK        EQU   2\nREGZ     EQU   2\nEAP      EQU   3                  OUTPUT POINTER\nREGM     EQU   4                  POINTS TO FIRST APOSTROPHE\nKEY      EQU   4                  TRANSOP REGISTER\nREGE     EQU   4              LINKREGISTER FOR PRGBLOCKEND\nREGF     EQU   4              LINKREGISTER FOR FDREND\nREGB     EQU   6                  RETURN REG. FROM ERROR ROUTINES\nIN       EQU   7                  ITAB POINTER\nREGN     EQU   7\nREG7     EQU   7\nREG8     EQU   8                  BASE REGISTER\nREGX     EQU   9                  RETURN REGISTER FROM BEGI\nREG9     EQU   9\nREGIX    EQU   9                  RETURN REG. FROM CIB\nREGA     EQU   9\nRET      EQU   10                 TESTLOOP AND LIST MAIN RETURN REG.\nREG11    EQU   11                 BASE REGISTER\nREGPS    EQU   12                 SPECIFICATION HANDLING\nREG12    EQU   12\nREGOX    EQU   12                 RETURN REG. FROM COB\nPIN      EQU   14                 LABEL POINTER\nREGL     EQU   14\nREGY     EQU   15\nREGH     EQU   15\n         SPACE 2\n*****   INITIALIZATION   **********************************************\n*                   GETMAIN FOR KOPOOL\n*                                STACK\n*                                ITABBUF\n*                                OUTPUTAREA2\n*                                ITAB\n*                   ALPHA  00 IS PUT IN STACK AND SP (STACK POINTER)\n*                        IS MADE TO POINT TO NEXT BYTE                *\n*                   ADDRESS OF THE FIRST O/P AREA IS TAKEN FROM CWA\n*                        AND PUT IN ADDARI. THE ADDRESS OF SECOND\n*                        O/P AREA (FROM GETMAIN) IS PUT IN ADDARI+4\n*                   AITAB, LIGP, LPBP, AITAB AND ELI ARE INITILIZED IN*\n*                        ITAB. HEADLINE FOR PB0 IS CREATED.           *\n*                   AITAB, LPBP, LIGP WILL POINT TO PB0 HEAD\n*                   AITL TO NEXT FREE ENTRY\n*                   ELI TO LAST POSITION+1 OF ITAB                    *\n*                   APE WILL POINT TO LAST POSSITION IN FIRST\n*                        OUTPUT BUFFER\n*                   WADDARI (CURRENT OUTPUT BUFFER) WILL POINT TO\n*                        FIRST OUTPUT BUFFER\n*                   EAP (REGISTR 3) WILL POINT TO FIRST O/P BUFFER\n*                   PRINTING OF HEADLINES IS INITILIZED IF SOURCE\n*                        WAS SPECIFIED\n*                   SWITCHES ARE SET TO ZERO\n*                   FIRST ENTRIES IN TABLES ARE SET TO ZERO\n         SPACE 2\n         USING IEX11001,8\n         USING IEX11002,11\n         BALR  5,0                      GET BASE REGISTERS\n         USING *,5\n         USING WORKAREA,13\n         L     REG8,VIEX1\n         L     REG11,VIEX2\n         LA    REGOX,SLUT2\n         ST    REGOX,ERET               INTERUPT BEFORE GETMAIN\n         LH    REGI,FOURKA              KOPOOL\n         LA    REGI,1000(0,REGI)        STACK\n         A     REGI,SRCE1S              O/P BUFFER 1\n         A     REGI,ITAB10S             ITAB\n         LA    REGI,2000(0,REGI)        ITAB BUF\n         ST    REGI,POOLLEN             STORE TOTAL LENGTH\n         LR    REG0,REGI\n         GETMAIN R,LV=(0)               GET AREAS NEEDED\n         ST    REGI,POOLLOC             SAVE LOCATION\n         LA    REGOX,ENDMISS       END OF DATA ADDRESS\n         ST    REGOX,EODIN\n         LA    REGOX,EODADIN\n         ST    REGOX,ERET               INTERUPT ADDRESS AFTER GETMAIN\n         ST    REGI,AKOPOOL             ADDRESS OF KOPOOL\n         LA    REGI,4095(0,REGI)\n         MVC   1(4,REGI),KOPOOL         INITILIZE STACK\n         LA    REGI,2(0,REGI)\n         ST    REGI,SP                  ADDRESS OF SECOND BYTE IN STACK\n         LA    REGI,999(0,REGI)\n         ST    REGI,AITABBUF            INITILIZE ITAB BUFFER\n         LA    REGI,2000(0,REGI)\n         ST    REGI,ADDARI+4                      OUTPUTAREA 2\n         A     REGI,SRCE1S\n         ST    REGI,AITAB                         ITAB\n         ST    REGI,LIGP                SURROUNDING GROUP ADDRESS\n         ST    REGI,LPBP                            BLOCK ADDRESS\n         MVI   0(REGI),X'00'       CLEAR FIRST TWO ITABENTRIES\n         MVC   1(21,REGI),0(REGI)\n         MVI   3(REGI),X'FF'       CONSTRUCT CONTINUATION\n         MVI   5(REGI),X'2B'       LINE FOR PB0\n         LA    REGOX,11(0,REGI)\n         ST    REGOX,AITL               ADDRESS OF FIRST FREE ENTRY\n         A     REGI,ITAB10S\n         ST    REGI,ELI            END OF ITAB\n         L     EAP,SRCE1ADD        ADD OF FIRST OUTPUT BUFFER\n         A     EAP,SRCE1S\n         BCTR  EAP,0\n         ST    EAP,APE                  END OF FIRST O/P BUFFER\n         L     EAP,SRCE1ADD             OUTPUTAREAS' CONSTANTS\n         MVC   ADDARI(4),SRCE1ADD\n         MVC   WADDARI(4),ADDARI        CURRENT O/P AREA ADDRESS\n         LA    REGOX,SAVEPRNT           APRNTAR IS INITILIZED WITH\n         ST    REGOX,APRNTAR            DUMMY PRINTAREA ADDRESS\n         MVI   PAGEHEAD+2,X'40'         CREATE HEADLINES\n         MVC   PAGEHEAD+3(81),PAGEHEAD+2\n         MVC   PAGEHEAD+39(14),HDING1\n         MVI   PAGEHEAD+92,X'02'\n         MVI   PAGEHEAD+93,X'11'\n         MVI   PAGEHEAD+94,X'40'\n         MVC   PAGEHEAD+95(81),PAGEHEAD+94\n         MVC   PAGEHEAD+94(24),HDING2\n         MVI   PAGEHEAD+186,X'FF'\n         MVI   LINCNT,X'7F'\n         BAL   REGIX,CIB                GET FIRST RECORD AND ADDRESS\n*                                       OF FIRST PRINTAREA\n         SR    REGZ,REGZ\n         STC   REGZ,ONC                 USE REGZ TO ZERO COUNTERS\n         STC   REGZ,DISP                AND SWITCHES\n         LA    REGOX,64            INITIAL VALUE FOR KOPOOL ASSAIGNMENT\n         ST    REGOX,SPCLT\n         STH   REGZ,IGC            ITABGROUPCOUNTER AND\n         ST    REGZ,MGESITL\n         STC   REGZ,PBC            INITIAL VALUE OF PROGRAMBLOCKCOUNTER\n         STC   REGZ,ONC           OUTPUTRECORDCOUNTER\n         STC   REGZ,BITS1          INITIAL VALUE OF SWITCHBITS\n         STC   REGZ,BITS2\n         STC   REGZ,BITS3\n         STH   REGZ,SC                  INITIAL VALUE OF SC COUNTER\n         STC   REGZ,FSN          INITIAL VALUE OF FSN\n         STC   REGZ,PBTAB1       INITIAL VALUE OF PB0\n         ST    REGZ,GPTAB+3             INITILIZE GROUP AND SCOUP TABLE\n         STC   REGZ,SPTAB\n         STC   REGZ,0(0,EAP)      FIRST BYTE IN FIRST OUTPUTRECORD\n         ST    EAP,OPIN\n         ST    EAP,LAPIN                SET LABEL POINTERS\n         STC   REGZ,OPIN+4\n         LA    REGOX,GPTAB\n         ST    REGOX,AGT                ADDRESS TO GROUPTABLE\n         LA    REGOX,0                 MAKE                      A28251\n         ST    REGOX,BRACKET                BRACKETCOUNTER ZERO  A28251\n         L     REGOX,AITABBUF\n         BCTR  REGOX,0\n         ST    REGOX,ATOPSTAK           HIGHEST BYTE IN STACK TO USE\n         B     TESTLOOP                 GO TO START PROCESSING\n         DS    0H\nMOVE     MVC   0(1,EAP),0(REGM)\n         SPACE 3\nSAVE1    DS    7F\nSAVEPRNT DS    CL88\n         SPACE 2\n*****   BPRTAB   ******************************************************\n*                   CONTAINS ADDRESSCONSTANTS OF PROGRAMS UTILIZED BY\n*                        TEST\n*                        LIST\n*                        POINT\n*                        APOSTROF\n*                        POINTLST\n*                   THE ADDRESSES ARE PICKED UP WITH DISPLACEMENTS FROM\n*                        TESTTABL\n*                        ARTABLE\n*                        PTTABLE\n*                        ATABLE\n*                        PTTABLE FOR POINTLST 56 IS ADDED TO DISP GIVEN\n         SPACE 2\n         DS    0F\nBPRTAB   DS    0CL140\n         DC    4X'00'\n         DC    A(TRANSOP)\n         DC    A(TRANSOP)\n         DC    A(TRANSOP)\n         DC    A(TRANSOP)\n         DC    A(TRANSOP)\n         DC    A(TRANSOP)\n         DC    A(COLON)                COLON\n         DC    A(SEMCO)                SEMICOLON\n         DC    A(RIGHTPAR)\n         DC    A(BLANK)\n         DC    A(ERR1)\n         DC    A(POINT)\n         DC    A(APOSTROF)\n         DC    A(CIB)\n         DC    A(ASSIGN)\n         DC    A(DECPOINT)\n         DC    A(ERR5)             ERROR AFTER POINT\n         DC    A(BLKAPOS)              BLANK AFTER APOSTROPHE\n         DC    A(NPAFTAPO)             NOT PERMITTED AFTER APOSTR\n         DC    A(SCALE)                DIGIT OR SIGN AFTER APOSTROPHE\n         DC    A(COLONLST)             COLON IN LIST\n         DC    A(SEMCLST)              SEMICOLON IN LIST\n         DC    A(DELIMIT)              DELIMITER PROGRAM\n         DC    A(ZETAAPO)              ZETA AFTER APOSTROPHE\n         DC    A(EROUT)                ERROR (FROM W1,W2OR W3 TAB)\n         DC    A(LEFTPARL)             LEFT PARENTHESIS IN LIST\n         DC    A(RIGTPARL)             RIGHT PARENTHESIS IN LIST\n         DC    A(PZETA)                ZETA AFTER POINT IN LIST\n         DC    A(ASSIGN)               ASSIGNMENT POINT IN LIST\n         DC    A(DECPOINT)             DECPOINT IN LIST\n         DC    A(ERR5A)            POINT ERROR IN LIST\n         DC    A(COMMALST)             COMMA IN LIST\n         DC    A(PONTLST)              POINT IN LIST\n         DC    A(SLASHLST)             SLASH IN LIST\n         DC    A(QUOTE)                QUOTE\n         DC    A(SEMC60)\n         SPACE 2\n*****   TESTTABL ******************************************************\n*                   USED BY TEST - GIVES DISPLACEMENTS TO BPRTAB\n         SPACE 2\nTESTTABL DS    0CL90\n         DC    2X'00'\n         DC    X'0408'\n         DC    2X'00'\n         DC    X'0C1C'\n         DC    3X'00'\n         DC    X'90'\n         DC    4X'00'\n         DC    X'001014'\n         DC    13X'00'\n         DC    X'18'\n         DC    5X'00'\n         DC    X'24'\n         DC    4X'00'\n         DC    X'282C303438'\n         DC    42X'00'\n         SPACE 2\n*****   RETRANS  ******************************************************\n*                   CONVERT TABLE FOR INTERNAL CODE TO EBCDIC\n*                   USED BY CODE TO TRANSLATE PROCEDURE NAME\n*                           PROCEDURE TO TRANSLATE PROCEDURE NAME FOR\n*                                     ESD CARD IF PRECOMPILED SPECIFIED\n         SPACE 2\nRETRANS  DS    0CL90\n         DC    C' '\n         DC    47C'\"'\n         DC    C'0123456789'\n         DC    6C'\"'\n         DC    C'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n         SPACE 2\n*****   COMTABLE ******************************************************\n*                   USED BY COMMENT PROGRAM\n*                   TESTS FOR POINT, SEMICOLON, ZETA AND APOSTROPHE\n*                   GIVES DISPLACEMENT TO PROGRAMS FROM COMCEE2+2\nCOMTABLE DS    0CL90\n         DC    11X'00'\n         DC    X'2A'\n         DC    33X'00'\n         DC    X'220E1E'\n         DC    42X'00'\n         SPACE 2\n*****   STRTABLE ******************************************************\n*                   USED BY STRING PROGRAM. SCANS FOR APOSTROPHE OR   *\n*                        ZETA\n*                   GIVES DISPLACEMENTS TO BPRTAB\n         SPACE 2\nSTRTABLE DS    0CL90         TRT-TABLE USED BY STRING-PROGRAM\n         DC    46X'00'\n         DC    X'8C38'\n         DC    42X'00'\n         SPACE 2\n*****   BTABLE   ******************************************************\n*                   BLANK TABLES - SCANNES FOR FIRST NONBLANK CHARACTER\n*                   USED BY BLANK\n*                           BLKAPOS  BLANK AFTER APOSTROPHE\n*                           READROUT IN TERMINATION\n         SPACE 2\nBTABLE   DS    0CL90\n         DC    4X'FF'\n         DC    2X'00'\n         DC    2X'FF'\n         DC    3X'00'\n         DC    X'FF'\n         DC    4X'00'\n         DC    3X'FF'\n         DC    13X'00'\n         DC    X'FF'\n         DC    X'00'\n         DC    2X'FF'\n         DC    X'00'\n         DC    2X'FF'\n         DC    5X'00'\n         DC    14X'FF'\n         DC    6X'00'\n         DC    26X'FF'\n         DS    0F\n         SPACE 2\n*****   KEYTAB   ******************************************************\n*                   USED BY TRANSOP\n*                   BYTE 3 IS EXCPECTED BYTE, IF THAT ONE MATCHES CHAR.\n*                        IN INPUT BYTE 1 IS PUT OUT OTHERWISE BYTE 2\n*                   THE DISPLACEMENT FROM TESTTABL OR ATABLE IS USED  *\n*                        TO GET THE APPROPRIATE ENTRY IN KEYTAB\n*                   USED WHEN  *  FOUND      EXCPECTED  *\n*                              /                        )\n*                              (                        /\n*                              <  LESS THAN             = EQUAL\n*                              >  GREATER THAN          =\n*                              \u00ac  NOT                   =\n         SPACE 2\nKEYTAB   DS    0CL28\n         DS    CL4\n         DC    X'00050202'\n         DC    X'00280326'\n         DC    X'00080603'\n         DC    X'00141110'\n         DC    X'00151210'\n         DC    X'00132010'\n         SPACE 2\n*****   PTTABLE  ******************************************************\n*                   USED BY POINT\n*                            PONTLST\n*                   GIVES DISPLACEMENTS TO BPRTAB\n*                   WHEN USED BY PONTLST 56 IS ADDED TO ORIGINAL DISP.\n         SPACE 2\nPTTABLE  DS    0CL90\n         DC    4X'44'\n         DC    2X'00'\n         DC    2X'44'\n         DC    3X'00'\n         DC    X'44'\n         DC    4X'00'\n         DC    X'3C'\n         DC    2X'44'\n         DC    13X'00'\n         DC    X'44'\n         DC    X'00'\n         DC    2X'44'\n         DC    X'00'\n         DC    X'2044'\n         DC    5X'00'\n         DC    X'441C4438'\n         DC    10X'40'\n         DC    6X'00'\n         DC    26X'44'\n         SPACE 2\n*****   TRLTABLE ******************************************************\n*                   USED IN CIB TO TRANSLAT FROM EBCDIC TO INTERNAL\n*                        CODE\n         SPACE 2\nTRLTABLE DS    0CL256\n         DC    64X'2C'\n         DC    X'2B'\n         DC    10X'2C'\n         DC    X'2D1106002223'\n         DC    11X'2C'\n         DC    X'02260B200103'\n         DC    9X'2C'\n         DC    X'25'\n         DC    2X'2C'\n         DC    X'12'\n         DC    11X'2C'\n         DC    X'07'\n         DC    2X'2C'\n         DC    X'2E10'\n         DC    66X'2C'\n         DC    X'404142434445464748'\n         DC    7X'2C'\n         DC    X'494A4B4C4D4E4F5051'\n         DC    8X'2C'\n         DC    X'5253545556575859'\n         DC    6X'2C'\n         DC    X'30313233343536373839'\n         DC    6X'2C'\n         SPACE 2\n*****   KOPOOL   ******************************************************\n*                   KEEPS THE CONSTANTS 0 THROUGH 15\n*                   THE CONSTANS ARE USED WITHIN SCAN 1/2 FOR\n*                        CALCULATION AND ARE THEN INSERTED AS\n*                        THE FIRST 64 BYTES OF THE CONSTANT POOL\n         SPACE 2\nKOPOOL   DC    F'0'\n         DC    F'1'\n         DC    F'2'\n         DC    F'3'\n         DC    F'4'\n         DC    F'5'\n         DC    F'6'\n         DC    F'7'\n         DC    F'8'\n         DC    F'9'\n         DC    F'10'\n         DC    F'11'\n         DC    F'12'\n         DC    F'13'\n         DC    F'14'\n         DC    F'15'\n         SPACE 2\n*****   ATABLE   ******************************************************\n*                   USED BY THE APOSTROPHE PROGRAM\n*                   GIVES DISPLACEMENTS TO BPRTAB\n         SPACE 2\nATABLE   DS    0CL90\n         DC    2X'50'\n         DC    X'64'\n         DC    X'00'\n         DC    2X'00'\n         DC    X'0064'\n         DC    3X'00'\n         DC    X'64'                   SEMICOLON                 A32949\n         DC    4X'00'\n         DC    3X'64'\n         DC    13X'00'\n         DC    X'64'\n         DC    X'00'\n         DC    2X'64'\n         DC    X'00'\n         DC    2X'64'\n         DC    4X'00'\n         DC    X'484C645C60'\n         DC    10X'50'\n         DC    32X'00'\n         SPACE 2\n*****   CONSTANTS  ****************************************************\nTWOFIVEK DC    F'25000'\nTWOK     DC    F'2000'\nFOURK    DC    F'4095'\nFOURKA   DC    H'4096'\nDOUBLE   DC    D'0'\nD256     DC    F'256'\nINT      DC    X'2EC8030000'           COMMON PART OF THE INTERNAL\n*                                  NAMES OF BOOLEAN CONSTANTS\nENDCOUNT DC    H'0'\nERRSAVE  DS    4F\nSAVAR    EQU   ERRSAVE\nVIEX1    DC    A(IEX11001)\nVIEX2    DC    A(IEX11002)\nVIEX14   DC    V(IEX11003)\nESDPARAM DC    8C' '\nHDING1   DC    C'SOURCE PROGRAM'\nHDING2   DC    C' SC     SOURCE STATEMENT'\nOPINCHAR DC    C'0'\nBRACKET  DS    F                       BRACKET COUNTER           A28251\n         SPACE 2\n         SPACE 2\n*****   MAINLOOP ******************************************************\n*\n*              SCANS  THE INPUT STREAM\n*              EVERYTHING PRECEDING THE FIRST REAL ALGOL WORD WILL BE\n*              SKIPED WITH THE HELP OF BITS2,X'20'\n         SPACE 2\nTESTLOOP BALR  RET,0\n         LR    REGIX,RET          RETURNADDRESS FOR CIBPROGRAM\n         LR    REGM,REGI\n         SR    REGZ,REGZ\n         TRT   0(73,REGI),TESTTABL\n         TM    BITS2,X'20'              Q. FIRST BEGIN FOUND\n         BZ    FIRSTSTR                 NO\nCONT     LR    REGH,REGI                FIND LENGTH OF SCANNED BYTES\n         SR    REGH,REGM\n         BZ    SUBROUT\n         BAL   REGOX,COB\n         LA    REG0,0(REGH,EAP)\n         C     REG0,APE                 Q. SPACE LEFT IN O/P BUFFER\n         BH    MSBLOOP\n         BCTR  REGH,0\n         EX    REGH,MOVE                MOVE SCANNED BYTES\n         LR    EAP,REG0           INCREASE OUTPUTPOINTER\nSUBROUT  L     REGB,BPRTAB(REGZ)\n         BCR   15,REGB                  BRANCH TO PROGRAM\n*                             MSBLOOP-  USED WHEN SCANNED BYTES HAS\n*                                       TO BE PLACED IN TWO O/P AREAS\nMSBLOOP  L     REGB,APE\n         SR    REGB,EAP\n         BCTR  REGB,0\n         EX    REGB,MOVE          MOVE TO FIRST O/P AREA\n         LA    EAP,1(REGB,EAP)\n         BAL   REGOX,COB+8        CHANGE O/P BUFFER\n         LA    REGOX,1(REGB,REGM)\n         SR    REGH,REGB\n         BCTR  REGH,0\n         BCTR  REGH,0\n         EX    REGH,MOVERST       MOVE TO 2ND O/P BUFFER\n         LA    EAP,1(REGH,EAP)\n         B     SUBROUT            RETURN\n         CNOP  0,4\nMOVERST  MVC   0(1,EAP),0(REGOX)\nFIRSTSTR CLI   0(REGI),X'2E'       Q APOSTROPHY\n         BE    APOSTROF\n         CLI   0(REGI),X'2F'         Q. ZETA\n         BE    CIB\n         LA    REGI,1(0,REGI)           IF NEITHER- CONTINUE SCANNING\n         B     TESTLOOP\n         SPACE 2\n*****   BLANK    ******************************************************\n*              SCANS   TO THE NEXT NONBLANK CHARACTER\n*              ALL BLANK CHARACTER WILL BE SKIPPED\n*              USED BY MAIN LOOP AND ARRAYLIST\n         SPACE 2\nBLANK    LA    REGI,1(0,REGI)           INCREASE INPUTPOINTER\n         CLI   0(REGI),X'2B'            COMPARE BLANK\n         BCR   7,RET                    IF NO , RETURN\n         LA    REGI,1(0,REGI)           IF YES, INCREASE INPUTPOINTER\n         SR    REGZ,REGZ\n         TRT   0(73,REGI),BTABLE        SCAN INPUT TO NEXT DELIMITER\n         BCR   15,RET                   RETURN\n         SPACE 2\n*****   TRANSOP  ******************************************************\n*\n*              CHECKS THE NEXT BYTE IN THE INPUT INPUTAREA AGAINS A KEY\n*              I.E. IF ( FOUND, NEXT BYTE WILL BE CHECKED FOR /, IF A\n*              SLASH IS FOUND A LEFT SQUARE BRACKET WILL BE TRANSFERED\n*              OTHERWISE A (\n*              USED BY MAIN LOOP AND ARRAYLIST\n         SPACE 2\nTRANSOP  LA    KEY,KEYTAB(REGZ)         GET CORRECT ENTRY IN TABLE\n         CNOP  0,4\nINCR     LA    REGI,1(0,REGI)\n         CLC   0(1,REGI),3(KEY)      Q. INPUT EQUAL EXPECTED ONE\n         BE    TROE                     YES TAKE SUBSTITUTE CHAR.\n         CLI   0(REGI),X'2B'      Q. BLANK\n         BE    INCR\n         CLI   0(REGI),X'2F'      Q. ZETA\n         BNE   TRONE              IF NEITHER TAKE CHAR. IN I/P\n         LA    REGIX,INCR+4\n         BC    15,CIB\nTRONE    BAL   REGOX,COB           CHECK IF O/P AREA FILLED\n         MVC   0(1,EAP),2(KEY)          TAKE CHAR FOUND IN INPUT\n         LA    EAP,1(0,EAP)\n         BCR   15,RET             RETURN\nTROE     BAL   REGOX,COB           CHECK IF O/P AREA FILLED\n         MVC   0(1,EAP),1(KEY)          TAKE SUBSTITUE CHAR FROM TABLE\n         L     REGOX,BRACKET                                     A28251\n         TM    0(EAP),X'28'            IS IT RIGHT BRACKET       A28251\n         BC    14,TSTMORE              NO                        A28251\n         BCTR  REGOX,0                 YES  SUBTRACT 1 FROM CTR  A28251\n         BC    15,NOUPDAT                                        A28251\nTSTMORE  TM    0(EAP),X'08'            IS IT LEFT BRACKET        A28251\n         BC    14,NOUPDAT              NO                        A28251\n         LA    REGOX,1(REGOX)          YES  ADD 1 TO CTR         A28251\nNOUPDAT  ST    REGOX,BRACKET                                     A28251\n         LA    EAP,1(0,EAP)\n         LA    REGI,1(0,REGI)\n         BCR   15,RET             RETURN\n         SPACE 2\n*****   RIGHTPAR ******************************************************\n*              INSERTS A ) IN O/P, SETS THE LABEL POINTERS\n         SPACE 2\nRIGHTPAR BAL   REGOX,COB           CHECK IF O/P AREA FILLED\n         MVI   0(EAP),X'26'        TRANSFER ) TO OUTPUTBUFFER\n         ST    EAP,OPIN            NOTE ITS POSITION\n         MVI   OPINCHAR,X'26'\n         MVC   OPIN+4(1),ONC       AND THE OUTPUTRECORDNUMBER\n         LA    EAP,1(0,EAP)\n         ST    EAP,LAPIN           NOTE POSITION WHERE LETTERSTRING\n         LA    REGI,1(0,REGI)      MAY START\n         B     TESTLOOP\n         SPACE 2\n*****   POINT    ******************************************************\n*              SCANS FOR : DECPOINT\n*                          ERROR\n*                          COLON\n*                          SEMICOLON\n*                          ASSIGN\n*              USED BY MAIN LOOP AND ARRAYLIST\n         SPACE 2\nPOINT    LA    REGI,1(0,REGI)           SCAN SOURCESTRING\n         CNOP  0,4\n         LA    REGIX,*            RETURNADDRESS FOR CIBPROGRAM\n         SR    REGZ,REGZ\n         TRT   0(73,REGI),PTTABLE       TO NEXT DELIMITER\n         L     REGB,BPRTAB(REGZ)        BRANCH TO SUITABLE\n         BCR   15,REGB                  SUBROUTINE\n         SPACE 2\n*****   DECPOINT ******************************************************\n*              TRANSFERS A DECIMAL POINT\n         SPACE 2\nDECPOINT BAL   REGOX,COB           CHECK IF O/P AREA FILLED\n         MVI   0(EAP),X'3E'             TRANSFER DECIMALPOINT\n         LA    EAP,1(0,EAP)\n         BCR   15,RET\n         SPACE 2\n*****   ASSIGN   ******************************************************\n*              TRANSFERS A ASSIGN CHAR TO O/P. RETURNS VIA STATEMENT\n         SPACE 2\nASSIGN   BAL   REGOX,COB           CHECK IF O/P AREA FILLED\n         MVI   0(EAP),X'16'        TRANSFER .= TO OUTPUTBUFFER\n         LA    REGI,1(0,REGI)      INCREASE INPUT- AND\n         LA    EAP,1(0,EAP)        OUTPUTPOINTER\n         BC    15,STATE            BRANCH TO STATEMENT PROGRAM\n         SPACE 2\n*****   STATE    ******************************************************\n*\n*                   CHECKS WITH PROBIT IF FIRST LABEL, FOR, IF, GOTO\n*                   OR ASSIGN STATMENT AFTER A PROCEDURE\n*                   CHECKS THAT ALL PARAMETERS HAVE BEEN SPECIFIED\n*                   TURNS OFF THE PROBIT\n*                   AND THE BEGBIT, POSSIBLE PROCEEDING BEGIN WILL BE\n*                   COMPOOND BEGIN\n         SPACE 2\nSTATE    NI    BITS1,X'7F'              BEGBIT = 0\n         L     REGY,SP\n         CLI   0(REGY),X'0C'            Q. PROC IN STACK\n         BCR   7,RET               IF NO.RETURN\n         MVI   0(REGY),X'14'\n         NI    BITS1,X'BF'         PROBIT.=0\n         CLI   PZ,X'00'                 Q. ALL PARAMETERS SPECIFIED\n         BCR   8,RET                    YES RETURN\n         BAL   REGOX,ERROR10            NO- GENERATE E10\n         BCR   15,RET             RETURN\n         SPACE 2\n*****   APOSTROF ******************************************************\n*              SCANS FOR : SCALE\n*                                 BLANK\n*                               ZETA\n*                               NOT PERMITTED\n*                               ONE MORE APOSTROPHE (DELIMITER)\n*                   REGM WILL POINT TO THE APOSTROPHE\n*                   USED BY TESTLOOP AND LIST\n         SPACE 2\nAPOSTROF MVI   FBYTE,X'00'              ZEROSET FBYTE\nENTRAPR  LR    REGM,REGI          REGM WILL POINT TO FIRST APOSTROPHE\n         LA    REGI,1(0,REGI)\n         BALR  REGIX,0\n         SR    REGZ,REGZ\n         TRT   0(73,REGI),ATABLE   SOURCESTRING IS SCANNED TO THE NEXT\n         L     REGB,BPRTAB(REGZ)   SIGNIFICANT DELIMITER AND THE\n         BCR   15,REGB             SUITABLE SUBROUTINE SELECTED\n         SPACE 2\n*****   SCALE    ******************************************************\n*                CORRECT ONLY DIRECT AFTER TESTLOOP OR LIST\n*                CHECK THAT THE APOSTROPHE IS ONLY ONE CHAR. IN FRONT\n*                    OF DIGIT\n         SPACE 2\nSCALE    TM    FBYTE,X'FF'\n         BO    COMCEE2            COMMENT UNDER PROCESS\n         BM    TYPESPEC           DECLARATION UNDER PROCESS\nSCALEOK  LR    REGB,REGI\n         TM    BITS2,X'20'        Q. PROGRAM STARTED YET\n         BZ    TESTLOOP           NO - RETURN\n         BCTR  REGB,0\n         CLI   0(REGB),X'2E'  Q  APOSTOF ONE BYTE BEFORE SIGN OR DIGIT\n         BNE   EROUT               IF NO,BRANCH TO ERROR-ROUTINE\n         BAL   REGOX,COB           CHECK IF O/P AREA FILLED\nMOVETEN  MVI   0(EAP),X'3F'        MOVE SCALEFACTOR TO OUTPUT RECORD\n         LA    EAP,1(0,EAP)        INCREASE OUTPUT- AND\n         BCR   15,RET              RETURN\n         SPACE 2\n*****   BLKAPOS  ******************************************************\n*                   SHIFT THE BLANK OR BLANKS AWAY AND MOVES THE\n*                   APOSTROPHE AND VALID CHARACTERS UP TO THE RIGHT\n*                   SETS REGM TO POINT NEW LOCATION OF THE\n*                   APOSTROPHE\n*                   USED BY MAINLOOP AND INDIRECT BY THE ARRYLIST\n*                          AND THE NPAFTAPO\n         SPACE 2\nBLKAPOS  LR    REGH,REGI           NOTE POSITION OF FIRST BLANK.\n         TRT   0(73,REGI),BTABLE\n         LR    REGB,REGI           COMPUTE  NUMBER OF BLANKS .\n         SR    REGB,REGH           NUMBER OF BLANKS IN REGB .\n         LR    REGL,REGH\n         SR    REGL,REGM\n         C     REGL,KOPOOL+44      Q BYTES EXEED THE LIMIT ALLREADY\n         BH    EROUT\n         BCTR  REGL,0         NUMBER OF BYTES TO BE SHIFTED\n         LA    REGH,0(REGB,REGM)   COMPUTE NEW POSITION OF APOSTPOPHE,\n         EX    REGL,MAPOS     MOVE APOSTROPHE AND SCANNED CHARACTERS\n         EX    REGL,MAPOS2\n         LR    REGM,REGH           NOTE NEW POSITION OF APOSTROPHE .\n         BCR   15,REGIX           RETURN\n         CNOP  0,4\nMAPOS    MVC   BUCKET(1),0(REGM)\n         CNOP  0,4\nMAPOS2   MVC   0(1,REGH),BUCKET\nBUCKET   DC    11X'00'\n         SPACE 2\n*****   ZETAAPO  ******************************************************\n*                   MOVES SCANED BYTES AND APOSTROPHE IN FRONT OF WA\n*                   AND PUTS REGM TO NEW START LOCATION\n*                   OF POSSIBLE DELIMITER\n*                   USED BY MAINLOOP AND ARRAYLIST\n         SPACE 2\nZETAAPO  LR    REGY,REGM               COMPUTE\n         LR    REGL,REGI               NR OF SCANNED\n         SR    REGL,REGM               BYTES\n         C     REGL,KOPOOL+44      Q EXEED LIMIT\n         BH    EROUT                    YES\n         LA    REGM,WA                  NO- CALCULATE WHERE TO MOVE\n         SR    REGM,REGL                CHAR. STRING\n         BCTR  REGL,0\n         EX    REGL,MOVBEFWA            MOVE CHAR IN FRONT OF WA\n         B     CIB                CHANGE INPUT BUFFER\n         CNOP  0,4\nMOVBEFWA MVC   0(1,REGM),0(REGY)\n         SPACE 2\n*****   NPAFAPO  ******************************************************\n*                   GIVES ERROR MESSAGE AND UTILIZES BLANKAPO TO SHIFT\n*                   THE INVALID CHARACTER AWAY\n*                   USED BY MAINLOOP AND ARRAYLIST\n         SPACE 2\nNPAFTAPO TM    FBYTE,X'FF'\n         BM    TYPESPEC            INVALID IDENTIFIER\n         BO    COMCED2            COMMENT UNDER PROCESS\n         TM    BITS2,X'20'         Q. PROGRAM STARTED YET\n         BZ    *+10                NO\n         BAL   REGB,ERR7\n         DC    X'0401'             E1\n         LR    REGH,REGI\n         LA    REGI,1(0,REGI)           GO TO BLKAPOS TO SHIFT AWAY\n         B     BLKAPOS+2                INVALID CHARACTER\n         SPACE 2\n*****   COLON    ******************************************************\n*                   ENTERD FROM MAINLOOP OR POINT\n*                   CHECKS FOR   :=  ASSIGN\n*                                :(  DELIMITER\n*                                    LABEL\n         SPACE 2\nCOLON    LR    REGB,REGI           STORE PRECEEDING 6 CHARACTERS\n         S     REGB,KOPOOL+24      TO BE USED ONLY IF INCORRECT\n         MVC   BUCKET(6),0(REGB)   USE OF COLON E3\nCOLON2   LA    REGI,1(0,REGI)\nEQUAL    CLI   0(REGI),X'10'       IF COLON IS FOLLOWED BY EQUALSIGN\n         BE    ASSIGN              BRANCH TO ASSIGN-PROGRAM\n         CLI   0(REGI),X'06'       IF COLON IS FOLLOWED BY LEFT PAREN-\n         BE    LETDEL              THESIS,BRANCH TO DELIMITERPROCESSING\n         CLI   0(REGI),X'2B'       IF COLON IS FOLLOWED BY BLANK\n         BE    COLON2              REPEAT SEARCH\n         CLI   0(REGI),X'2F'       IF COLON IS FOLLOWED BY ZETA\n         BNE   *+12\n         LA    REGIX,EQUAL         PROVIDE RETURNADDRESS AND\n         BC    15,CIB              CHANGE INPUTBUFFER\n         SPACE 2\n*****   LABEL    ******************************************************\n*                   OPIN POINTS TO LAST OPERATOR WHICH MIGHT BE       *\n*                        FOLLOWED BY A LABEL.                         *\n*                   PIN IS THE POINTER, STEPPING UP BETWEEN LAPIN AND\n*                        THE COLON WHICH EAP POINTS TO\n*                   OPIN+4 CONTAINS THE O/P REC. NUMBER WHEN OPIN\n*                        WAS SET\n*                   LABEL IS CHECKED FOR VALIDITY. THE FIRST 6 CHAR.\n*                        ARE MOVED TO OUTPUT AND ITAB.                *\n*                   CHECKS IF THE LABEL IS SPLIT OVER MORE THAN\n*                        ONE  O/P BUFFER\n*                   IF THE LABEL IS SPLIT BY ONE O/P BUFFER END THE\n*                        HANDLING IS THE SAME AS IF NOT EXEPT THAT WHEN\n*                        ZETA- RECORD END - IS FOUND PIN IS UPDATED TO\n*                        THE FIRST CHARACTER OF THE CURRENT O/P REC.  *\n*                   E3 IF THERE IS NO LABEL\n*                   E6 IF LABEL LONGER THAN 1024 BYTES\n*                   E7 IF LABEL CONTAINS INVALID CHARACTER\n*                   E8 IF LABEL STARTS WITH INVALID CHAR.\n         SPACE 2\n         CLC   ONC(1),OPIN+4         Q. LABEL EXCEEDS ONE O/P REC.\n         BE    LABEL                    NO\n         SR    REGM,REGM\n         IC    REGM,OPIN+4\n         LA    REGM,1(0,REGM)\n         IC    REGZ,ONC\n         CR    REGZ,REGM                Q. LABEL EXCEEDS 2 O/P REC.\n         BE    *+10                     NO\n         BAL   REGB,ERR4\n         DC    X'0406'        E6   TERMINATING ERROR\nLABEL    L     PIN,LAPIN\n         CR    EAP,PIN             IS THERE ANY IDENTIFIER\n         BE    ERROR3              E3 COLON DELETED\n         CLI   OPINCHAR,X'26'      Q LABEL PROCEEDED BY RIGHT\n         BE    ERROR3              PARENTHESIS IF YES E3 IS GIVEN\nLABNAME  CLI   0(PIN),X'40'     Q. FIRST CHAR. IS LETTER\n         BL    LABNAMER\n         L     IN,AITL\n         MVC   0(1,IN),0(PIN)           MOVE CONTENTS OF PIN TO ITAB\n         LA    IN,1(0,IN)                INCREABE IN\n         LA    K,1                      INITILIZE K WITH 1\nLABID    LA    PIN,1(0,PIN)        GET NEXT CHAR.\n         CR    PIN,EAP                   Q(PIN=EAP\n         BE    LABEND\nLABCHECK CLI   0(PIN),X'2F'        Q. LETTER, DIGIT\n*                                         OR ZETA\n         BNE   *+12\n         L     PIN,WADDARI              GET START OF CURRENT O/P AREA\n         B     LABCHECK\n         BL    ERROR7\n         C     K,KOPOOL+24              Q. K=6\n         BE    LABID                    YES- DON'T MOVE MORE CHAR. TO\n*                                       ITAB\n         MVC   0(1,IN),0(PIN)            MOVE CONTENT OF PINTOIN\n         LA    IN,1(0,IN)                INCREASE  IN ANO PIN\n         LA    K,1(0,K)                 AND K\n         B     LABID\nLABNAMER CLI   0(PIN),X'2F'        Q. ZETA  OR DIGIT\n         BNE   *+12\n         L     PIN,WADDARI         UPDATE PIN TO CURRENT O/P BUFFER\n         B     LABNAME\n         CLI   0(PIN),X'2B'        Q. BLANK\n         BE    LABNAME\n         BAL   REGB,ERR7\n         DC    X'0408'        E8\n         B     ERROR7+6\nERROR7   BAL   REGB,ERR2\n         DC    X'0007'             E7 INCORRECT LABEL\n         L     REGY,AITL\n         BAL   REGOX,ITABCLEA+8         CLEAR  THE ITAB ENTRY\n         BCR   15,RET\n         SPACE 2\n********LABEND   ******************************************************\n*                   IF  (LABEL:LABELX) THE LN (LABEL NUMBER)\n*                   WILL ONLY BE INCREASE ONCE\n*                   INTERNAL NAME IS CREATED AND LN INSERTED\n*                   X'27' IS MOVED TO THE O/P TO INDICATE LABEL\n*                   OPIN, OPIN+4 AND LAPIN ARE UPDATED\n*                   ITABCLEA IS ACTIVATED TO PREPARE NEXT ITABENTRY\n         SPACE 2\nLABEND   CLI   OPINCHAR,X'27'           +. LABEL PRECEEDED BY LABEL\n         BE    LABLAHEI                 YES- DO NOT UPDATE LN\n         LH    REGY,LN             LN=LN+4\n         LA    REGY,4(0,REGY)\nLABCREAT CLC   LN(2),FOURKA      Q. LN= 2**12\n         BL    *+14\n         BAL   REGB,ERR7\n         DC    X'04D8'                  E216\n         LA    REGY,LATBEG         RESET LN\n         STH   REGY,LN\nLABLAHEI L     REGY,AITL\n         MVI   6(REGY),X'CC'            CREATE INTERNAL NAME\n         MVI   7(REGY),X'08'\n         L     REGL,LPBP\n         MVC   8(1,REGY),10(REGL)      PROGRAMMBLOCKNR   AITL + 7\n         MVC   9(2,REGY),LN             LN IN AITL+9\n         BAL   REGOX,COB           CHECK IF O/P AREA FILLED\n         MVI   0(EAP),X'27'             MOVE LABEL IND. TO O/P\n         ST    EAP,OPIN                 SET LABEL POINTERS\n         MVI   OPINCHAR,X'27'\n         MVC   OPIN+4(1),ONC\n         LA    EAP,1(0,EAP)\n         ST    EAP,LAPIN\n         BAL   REG12,ITABCLEA           CHECK AND CLEAR NEXT ITABENTRY\n         B     STATE                    RETURN VIA STATEMENT PCM\n         SPACE 2\n*****   LETDEL   ******************************************************\n*                   :( HAS BEEN FOUND IN THE I/P\n*                  IF OPIN POINTS TO A RIGHT PARENTHESIS IT SHOULD BE\n*                   LETTER DELIMITER, WHITCH SHOULD BE REMOVED AND\n*                   REPLACED BY A COMMA\n*                   IT IS CHECKED THAT ALL CHARACTERS ARE LETTERS\n*                        OTHERWISE E3 IS GIVEN\n         SPACE 2\nLETDEL   CLI   OPINCHAR,X'26'           Q. OPIN POINTS TO A RIGHT PAREN\n         BNE   ERROR3                   NO- E3- COLON DELETED\n         CLC   ONC(1),OPIN+4           Q LETDEL EXCEEDS ONE O/P REC\n         BNE   LETDELB2                YES\n         L     PIN,OPIN\n         LA    REGB,1(0,PIN)\n         CR    REGB,EAP                 Q. AT LEAST ONE CHAR.\n         BE    ERROR3                   NO- E3 DELETE COLON\nLETDELE1 LA    PIN,1(0,PIN)            OTHER CHAR. THAN\n         CLI   0(PIN),X'39'            LETTERS\n         BNH   ERROR3\n         LA    REGB,1(0,PIN)\n         CR    REGB,EAP                 Q. ALL CHAR. CHECKED\n         BNE   LETDELE1                 NO- CHECK NEXT\n         L     EAP,OPIN            SET O/P POINTER TO BEGINING OF\n         MVI   0(EAP),X'25'            THE STRING,MOVE IN A COMMA\n         LA    EAP,1(0,EAP)\n         LA    REGI,1(0,REGI)          GET NEXT CHAR.\n         BCR   15,RET\n*  DELIMITER EXCEEDS  ONE O/P RECORD\nLETDELB2 SR    REGB,REGB           Q. DOES THE STRING\n         IC    REGB,OPIN+4           Q. EXCEED 2 O/P RECORDS\n         LA    REGB,1(0,REGB)\n         IC    REGZ,ONC\n         CR    REGB,REGZ\n         BE    *+10                     NO\n         BAL   REGB,ERR4\n         DC    X'0404'             E4  GOES TO COMPFIN\n         L     PIN,OPIN                MAKE PIN POINT TO LETTER DEL.\nLETDELB3 LA    PIN,1(0,PIN)\n         CLI   0(PIN),X'40'            Q LETTER\n         BNL   *-8                     YES\n         CLI   0(PIN),X'2F'            NO-Q ZETA\n         BNE   ERROR3\n         L     PIN,WADDARI         CHANGE BACK SO PIN POINT TO CURR.O/P\nLETDELF4 CLI   0(PIN),X'40'            Q LETTER\n         BL    ERROR3                   E3 DELETE COLON\n         LA    PIN,1(0,PIN)            SKIP ALL LETTERS\n         CR    PIN,EAP            UNTIL END OF DELIMITERS\n         BNE   LETDELF4\n         L     EAP,WADDARI         LOAD ADD. OF CURRENT  O/P REC\n         MVI   0(EAP),X'3D'            MOVE IN $ RHO\n         LA    EAP,1(0,EAP)\n         LA    REGI,1(0,REGI)          GET NEXT CHAR\n         BCR   15,RET\n         SPACE 2\n*****   SEMCO    ******************************************************\n*                   IF THE DELTA BIT IS ON, THE DELTA AND SEMICOLON\n*                   COUNTER (SC) IS MOVED TO THE OUTPUT\n*                   IF THE DELTABIT IS OFF THE STACK IS INSPECTED\n*                   BEGIN, BETA OR PROC* - A SEMICOLON AND THE SC\n*                             IS MOVED TO THE O/P AND PROCESSING IS\n*                             CONTINUES VIA TEST\n*                   FOR - THE FORSTATMENT IS COMPLETE, THE FOREND\n*                             PROGRAM IS ACTIUATED\n*                             THE RETURN IS TO STACKTST TO SEE IF ONE\n*                             MORE FOR STATEMENT OR A PROC** HAS ENDED\n*                             AT THE SAME TIME\n*                   PROC - A PROCEDURE CONSISTING OF ONLY ONE\n*                             STATMENT OR A DOMMY STATMENT HAS ENDED\n*                             IT IS CHECKED THAT ALL PARAMETERS HAVE\n*                             BEEN SPECIFIED, AND THE PROC** PGM IS\n*                             JOINED\n*                   PROC** - A PROCEDURE CONSISTING OF ONE LABELED\n*                             STATEMENT OR ONE FOR, IF, GOTO OR ASSIGN\n*                             STATEMENT HAS ENDED\n*                             THE PROGRAM BLOCKEND PROGRAM IS ACTIVATED\n*                             AND A DELTA AND THE SC IS MOVED OUT\n*                   THE FINAL EXIT IS IN ALL CASES TO TEST\n         SPACE 2\nSEMC60   OI    HCOMPMOD+2,SET60         SET SWITCH FOR 60 CHAR. SET\nSEMCO    LH    REGM,SC\n         C     REGM,SCOVFL         TEST SC OVERFLOW\n         BL    SEMCO01\n         BAL   REGB,ERR7\n         DC    X'0411'             E17\n         MVC   SC(2),KOPOOL        RESET SC COUNTER TO ZERO\nSEMCO01  LA    REGM,1(0,REGM)      INCREASE SC\n         STH   REGM,SC\n         LA    REG0,3(0,EAP)       PROVIDE 3 BYTES IN OUTPUTBUFFER\n         BAL   REGOX,COBSPEC       CHECK IF ENOUGH SPACE IN O/P\n         NI    BITS3,FMOFF\n         TM    BITS1,X'20'         TEST DELTABIT\n         BO    DELTA               IF  1  BRANCH TO DELTATRANSFER\n         LA    REGE,STACKTST       RETURN REGISTER ( FOREND, PBLCKEND )\n         L     REGY,SP             SELECT\n         IC    REGZ,0(0,REGY)      BRANCH\n         L     REGB,PROG2(REGZ)    ADDRESS\n         BCR   15,REGB             DEPENDING ON WHAT IS IN STACK\n         DS    0F\nPROG2    DC    A(ERR8)             SHOULD NOT OCCUR, TOPBYTE IS ALPHA\n         DC    A(SCTRANS)                                      BETA\n         DC    A(SCTRANS)                                      BEGIN\n         DC    A(SEMPROC)                                      PROC\n         DC    A(SCTRANS)                                      PROC*\n         DC    A(SEMPROC2)                                     PROC**\n         DC    A(FOREND)                                       FOR\nDELTA    NI    BITS1,X'DF'         DELTA BIT= 0\n         MVI   0(EAP),X'29'        TRANSFER DELTA\n         BC    15,SCTRANS+4\nSCTRANS  MVI   0(EAP),X'0B'        TRANSFER SEMICOLON\n         MVI   OPINCHAR,X'0B'\n         ST    EAP,OPIN            NOTE POSITION OF SEMICOLON IN OPIN\n         MVC   OPIN+4(1),ONC       AND O/P NO\n         MVC   1(2,EAP),SC         TRANSFER SEMICOLONCOUNTER\n         LA    EAP,3(0,EAP)        INCREASE OUTPUTPOINTER\n         ST    EAP,LAPIN\n         NI    BITS1,X'7F'         BEGBIT.=0\n         LA    REGI,1(0,REGI)      INCREASE INPUTPOINTER\n         B     TESTLOOP\nSCOVFL   DC    F'65535'           (2**16)-1\nSEMPROC  NI    BITS1,X'BF'         PROBIT.=0\n         CLI   PZ,X'00'            ALL PARAMETERS SPECIFIED\n         BE    *+8\n         BAL   REGOX,ERROR10\nSEMPROC2 BAL   REGE,PBLCKEND\n         LA    REG0,3(0,EAP)       PROVIDE 3 BYTES IN OUTPUTBUFFER\n         BAL   REGOX,COBSPEC       CHECK IF ENOUGH SPACE IN O/P\n         MVI   0(EAP),X'29'        TRANSFER DELTA\n         BC    15,SCTRANS+4\nSTACKTST CLI   0(REGY),X'14'\n         BE    SEMPROC2            PROC**\n         BH    FOREND              FOR\n         LA    REG0,3(0,EAP)\n         BAL   REGOX,COBSPEC       CHECK IF ENOUGH SPACE IN O/P\n         B     SCTRANS\n         SPACE 2\n         SPACE 2\n*****   ERROR ROUTINE  ************************************************\n*                   GENERATES ERROR PATTERNS\n*                   MAINLY CLOSED SUBROUTINES, ENTERED WITH BAL REGB\n*                        FOLLOWED BY TWO BYTES. FIRST BYTE SPECIFIES\n*                        THE LENGTH, IF KNOW AND SECOND BYTE ERROR\n*                        NUMBER\n*                   USES ERROR1 TO CHECK FOR ERRORPOL OVERFLOW AND\n*                        TO INSERT NUMBER, LENGTH AND SC\n         SPACE 2\n*****   ERR0     ******************************************************\n*                   GENERATES E212 PATTERN\n*                   EXITS TO COMFIN\n         SPACE 2\nERR0     MVI   0(REGY),X'02'\n         MVI   1(REGY),X'D4'       E212\n         LA    REGY,2(0,REGY)\n         ST    REGY,NEXTERR\n         B     COMPFIN\n         SPACE 2\n*****   ERR1     ******************************************************\n*                   E1\n*                   ACTIVATES ERR7, SKIPPS INVALID CHARACTER AND\n*                        RETURNS TO EITHER TESTLOOP OR LIST\n*                        ENTERED VIA BPRTAB WHEN USED BY TESTLOOP OR\n*                             LIST\n*                        INVALID CHARACTER FOLLOWING AN APOSTROPHE IS\n*                             TREATED SPECIALLY IN NPAFTAPO\n         SPACE 2\nERR1     BAL   REGB,ERR7     NOT PERMITTED CHARACTER\n         DC    X'0401'        E1\n         LA    REGI,1(0,REGI)\n         BCR   15,RET              RETURN TO TEST OR TRATE\n         SPACE 2\n*****   ERR2     ******************************************************\n*                   ERR2      7, 16, 31, 32, 33, 34\n*                        ENTERED   ERROR7, IER, ARRAYERR, SWITCHERR\n*                                  SLASHERR, SEMCLST, SEMCLER, ARRYSLSH\n*                                  SLASHLST, PNAMERR\n*                        NAME TAKE FROM AITL\n*                   ERR2B          10, 36, 37\n*                                  ERROR10, PROCFIN, ERROP37\n*                        NAME TAKEN FROM LPBP-11\n*                   ERR2C     14\n*                                  EROUT\n*                        DELIMITER TAKEN FROM BUCKET\n*                   ERR2E     16, 26, 27, 30\n*                                  IDVALCHK, VALDLB2, IDSELSE, NOTFOUND\n*                        NAME TAKEN FROM IDBUCKET\n*                   ERR2D UTILISES ERROR2 TO FIND LENGTH\n*                                  ERROR1 TO CREATE MESSAGE\n*                                  MOVES IN INFORMATION\n*                                  RETURNS TO CALLING SEQUENCE\n         SPACE 2\nERR2     L     IN,AITL                  NAME FROM AITL\n         B     ERR2D\nERR2B    L     IN,LPBP                  NAME FRM LPBP-11\n         S     IN,KOPOOL+44\n         B     ERR2D\nERR2C    MVC   BUCKET(6),1(REGM)        DELIMITER FROM BUCKET\n         LA    IN,BUCKET\n         B     ERR2D\nERR2E    LA    IN,IDBUCKET     E26      NAME FROM IDBUCKET\nERR2D    STM   12,15,ERRSAVE\n         BAL   REG12,ERROR2             GET NAME AND LENGTHS\n         BAL   REG12,ERROR1             CREATE ENTRY IN ERRPOOL\n         EX    K,ERRMOVE                MOVE THE NAME\n         LM    12,15,ERRSAVE\n         BC    15,2(0,REGB)\n         SPACE 2\n*****   ERROR3   ******************************************************\n*                   GENERATES PATTERN FOR E3\n*                   ENTERED FROM LABEL, COLONLST\n*                   TAKES INFORMATION FROM BUCKET\n         SPACE 2\nERROR3   STM   12,15,ERRSAVE            GET PARAMETER FIELD\n         LA    REGB,PARAM3\n         BAL   REG12,ERROR1             CREATE PATTERN\n         MVC   4(6,REGY),BUCKET         MOVE IN INFORMATION\n         LM    12,15,ERRSAVE\n         BCR   15,RET\nPARAM3   DC    X'0A03'\n         SPACE 2\n*****   ERR4     ******************************************************\n*                   TAKES CARE OF ALL TERMINATING ERRORS THAT ARE\n*                        4 BYTETS LONG\n*                   THAT IS   4, 6, 20, 22, 38, 41, 44, 213, 215, 216\n*                   ENTERED FROM   LABEL, ITABCLEA, COB, BEGIN, BEG1,\n*                                  PBLCKEND, FOR, PROCEDUR, ENDMISS\n*                   EXITS TO COMPFIN\n         SPACE 2\nERR4     BAL   REG12,ERROR1\n         SPACE 2\n*****   COMPFIN  ******************************************************\n*                   TERMINATING ERROR HAS BEEN FOUND\n*                   SETS TERMBIT IN HCOMPMOD\n*                   EXITS TO KOPOOLRL IN TERMINATION\n*\nCOMPFIN  OI    HCOMPMOD,X'08'      SET TERMINATING ERROR BIT\n         L     REG11,VIEX14\n         USING IEX11003,11\n         B     KOPOOLRL                 EXIT TO ERMINATION\n         USING IEX11002,11\n         SPACE 2\n*****   ERR5     ******************************************************\n*                   ERR5A     E35  FROM BPRTAB, DISP IN TESTTABL\n*                   ERR5      E2   FROM BPRTAB, DISP IN ARTABLE\n*                   GENERATES ERROR PATTERN RETURNS TO TESTLOOP OR LIST\n*\n         SPACE 2\nERR5A    LA    REGB,PPARLST             GET PARAMETER FIELD\n         B     *+8\nERR5     LA    REGB,PONTPAR             GET PARAMETER FIELD\n         STM   12,15,ERRSAVE\n         BAL   REGOX,ERROR1             GENERATE PATTERN\n         LM    12,15,ERRSAVE\n         BCR   15,RET                   RETURN TO TESTLOOP OR LIST\nPPARLST  DC    X'0423'\nPONTPAR  DC    X'0402'             E2\n         SPACE 2\n*****   ERR6     ******************************************************\n*                   GENERATES PATTERN FOR E6\n*                   TESTS IF PROGRAM STARTED IF NOT, NO ERROR MESSAGE\n*                   TEST IF IN COMMENT OR IDENTIFIER PROGRAM\n*                   TAKES THE 6 CHARACTERS PRECEEDING THE FIRST\n*                        APOSTROPHE\n*                   RETURNS TO APOSTROPHE PROGRAM TO TEST ON SECOND\n*                        APOSTROPHE\n         SPACE 2\nERR6     TM    BITS2,X'20'              Q. FIRST BEGIN FOUND YET\n         BZ    TESTLOOP                 NO\n         TM    FBYTE,X'FF'\n         BO    ENTRAPR             INVALID IDENTIFIER\n         BZ    *+12                COMMENT\n         LA    REGI,1(0,REGI)\n         B     TPSPECER\n         BCTR  REGI,0\n         STM   12,15,ERRSAVE\n         BAL   REG12,ERROR1\n         S     REGI,KOPOOL+24      SUBTRACT 6\n         MVC   4(6,REGY),0(REGI)        MOVE OUT INFORMATION TO POOL\n         LA    REGI,7(0,REGI)\n          LM    12,15,ERRSAVE\n         B     ENTRAPR             RETURN TO TEST SECOND APOSTROPHE\n         SPACE 2\n*****   ERR7     ******************************************************\n*                   TAKES CARE OF ALL SERIOUS AND WARNING MESSAGES THAT\n*                        ARE 4 BYTES LONG\n*                   ENTERED FROM ERR1, IERSPEC, ARNAMSE, SWITCHNSE\n*                                 PNAMESE, LABNAMER, CODE, SEMCO, ERR18\n*                                 ERR23, CODE, SPEC, VALUE, VALDLB2,\n*                                  FIRSTBEG, ERR9, LABEL, PROCEDURE,\n*                                 SWITCH, COM\n*                   1, 5, 8, 15, 17, 18, 23, 24, 25, 28, 29, 42, 43,216\n*                   RETURNS TO CALLING SEQUENCE\n         SPACE 2\nERR7     STM   12,15,ERRSAVE\n         BAL   REG12,ERROR1             CREATE ENTRY\n         LM    12,15,ERRSAVE\n         BC    15,2(0,REGB)\n         SPACE 2\n*****   ERR8     ******************************************************\n*                   GENERATES ERROR PATTERN E11 ONCE\n*                   IF FOUND DELIMITER IS COMMENT E18 IS GIVEN\n*                        INSTEAD\n*                   ENTERED FROM   TYPESPEC\n*                                  STARTDEL\n*                   EXITS TO TESTLOOP\n         SPACE 2\nERR8     TM    BITS3,E11BIT             Q. MESSAGE ALLREADY GIVEN ONCE\n         LA    REGI,1(0,REGI)      GET NEXT CARACTER\n         BO    TESTLOOP                 YES- RETURN\n         CLI   BCHAR,X'38'              Q COMMENT FOUND\n         BE    E18                YES GENERATE E18 INSTEAD\n         OI    BITS3,E11BIT             SET E11BIT\n         BAL   REGB,ERR7                GENERATE E11 PATTERN\n         DC    X'040B'\n         B     *+10\nE18      BAL   REGB,ERR7\n         DC    X'0412'\n         BCR   15,RET              RETURN\n         SPACE 2\n*****   ERR9    *******************************************************\n*                   GENERATE  E9 PATTERN\n*                   ENTERED FROM TED\n*                                 END\n*                                 READROUT\n*                   EXITS TO EODADIN\n         SPACE 2\nERR9     BAL   REGB,ERR7           PROGRAM CONTINIUED AFTER LAST END\n         DC    X'042B'\n         B     EODADIN\n         SPACE 2\n*****   ERROR10  ******************************************************\n*                   GENERATES E10 PATTERN\n*                   INSERTS IN THE NOT SPECIFID PARAMETERS A\n*                        ALLPURPOS IDENTIFIER\n*                   RETURNS TO CALLING PROGRAM\n         SPACE 2\nERROR10  BAL   REGB,ERR2B\n         DC    X'000A'             E10\n         L     REGB,LPBP\nFINDEMTY LA    REGB,11(0,REGB)     GET FIRST PARAMETER\n         C     REGB,AITL                Q. ALL PARAMETERS CHECKED\n         BCR   8,REGOX             WHEN ALL CHECKED RETURN\n         CLI   6(REGB),X'00'       INSERT ALL PURPOSE IDENTIFIER\n         BNE   FINDEMTY            IN EMPTY INTERNAL NAMES\n         MVC   6(5,REGB),ALLPUPOS\n         B     FINDEMTY\nALLPUPOS DC    X'91FF010000'\n         SPACE 2\n*****   ERR13    ******************************************************\n*                   GENERATES E13 PATTERN\n*                   PICKS UP THE DELIMITER FROM W1TAB\n         SPACE 2\nERR13    STM   12,15,ERRSAVE\n         LA    REGOX,5(0,REGL)     INCREASE TO GET WHOLE LENGTH\n         STC   REGOX,0(REGB)\n         BAL   REGOX,ERROR1\n         L     REGL,ERRSAVE+8      GET LENGTH OF DELIMITER\n         LA    IN,1(0,REGM)        GET START ADDRESS OF DELIMITER\n         EX    REGL,ERRMOVE        MOVE DELIMITER TO ERROR PATTER\n         LM    12,15,ERRSAVE\n         BC    15,2(0,REGB)        RETURN\n         SPACE 2\n*****   ERROR21  ******************************************************\n*                   GENERATES E21 PATTERN\n*                   PICKS UP DELIMITER FROM DELIMITER TABLE\n*                   EXITS TO PROGRAM WHICH CALLED FOR BEG1\n         SPACE 2\nERROR21  STM   12,15,ERRSAVE\n         LA    REGB,5(0,REGL)           INCREASE L TO GET WHOLE LENGTH\n         STC   REGB,E21PAR\n         LA    REGB,E21PAR\n         BAL   REG12,ERROR1\n         L     IN,SAVE1                 GET DEK. FROM DELIMITER TABEL\n         L     REGL,ERRSAVE+8                LENGTH FROM SAVEAREA\n         EX    REGL,ERRMOVE             MOVE IN DEK. IN ERROR MESSAGE\n         LA    EAP,1(0,EAP)             SUBSTITUTE BEG1 DECREASION\n         LM    12,15,ERRSAVE            BEGIN WILL REMAIN COMPOUND\n         BCR   15,REGX                  RETURN\nE21PAR   DC    X'0015'                  E21\n         SPACE 2\n         SPACE 2\n*****   ERROR1   ******************************************************\n*                   CHECKS IF SPACE LEFT IN ERRORPOOL\n*                   INSERTS LENGTH, SC, ERROR NUMBER\n*                   RETURNS TO CALLIN ERROR PUTINE\n         SPACE 2\nERROR1   MVC   ERRMOD1+3(1),0(REGB)     MOVES IN THE LENGTH AND\n         MVC   ERRMOD2+1(1),0(REGB)     ERRORNUMBER IN THE FOLLOWING\n         MVC   ERRMOD3+1(1),1(REGB)     INSTRUCTIONS\n         L     REGY,NEXTERR\nERRMOD1  LA    REGL,0(0,REGY)\n         C     REGL,ENDPOOL        Q. ROOM LEFT IN ERRORPOOL\n         BNH   *+8                 FOR THIS MESSAGE\n         B     ERR0                     NO- GENERATE E212\n         L     REGY,NEXTERR\n         ST    REGL,NEXTERR             CORRECT NEXTERR POINTER\nERRMOD2  MVI   0(REGY),X'00'            MOVE IN LENGTH\nERRMOD3  MVI   1(REGY),X'00'                    ERRORNUMBER\n         MVC   2(2,REGY),SC                     SC COUNTER\n         LR    REGL,REGI                MAKE REGL POINT TO SIX CHAR\n         SH    REGL,SEVEN               BEFORE CURRENT INPUT POINTER\n         BCR   15,REG12\n         SPACE 2\n*****   ERROR2   ******************************************************\n*                   FINDS FIRST NONZERO CHAR. IN BUCKET, ITAB,\n*                   IDBUCKET OR BUCKET\n         SPACE 2\nERROR2   LA    K,5                      INITILIZE K FOR THE LOOP\n         STC   K,ERRKCAL+3\nERRKCAL  CLI   0(IN),X'00'              LOOP TO FIND THE FIRST 0 CHAR\n         BNE   *+8                      OR END OF EXTERNALNAME\n         BCT   K,ERRKCAL-4\n         LA    REGY,5(0,K)    INCREASE TO GET THE WHOLE\n         STC   REGY,0(0,REGB)      ERROR MESSAGE LENGTH\n         BCR   15,REG12\n         CNOP  0,4\nERRMOVE  MVC   4(1,REGY),0(IN)\nSEVEN    DC    X'0007'\n         SPACE 2\n*****   IDCHECK1 ******************************************************\n*                   CHECKS IDENTIFIER NAMES FOR ARRAY, PROCEDURE AND\n*                   SWITCH\n*                   MOVES THE FIRST 6 CHARATERS OF THE NAME TO ITAB\n*                   AND THE OUTPUT\n*                   RETURNS VIA REGB WHEN A CHARACTER IS FOUND THAT\n*                   IS NOT LETTER, DIGIT, BLANK OR ZETA\n         SPACE 2\nIDCHECK1 BAL   REGOX,COB           CHECK IF O/P AREA FILLED\n         MVC   0(1,EAP),0(REGI)    MOVE OUT FIRST CHAR.\n         LA    EAP,1(0,EAP)\n         L     IN,AITL             GET ITAB POINTER\n         MVC   0(1,IN),0(REGI)     MOVE IN FIRST CHAR. TO ITAB\n         LA    IN,1(0,IN)\n         LA    K,1                 INITILIZE K\n         LA    REGIX,*+8\nIDCHECK2 LA    REGI,1(0,REGI)      GET NEXT CHAR.\n         CLI   0(REGI),X'2F'       Q.WHAT IS CHAR.\n         BCR   4,REGB              NOT LETTER OR ZETA\n         BE    CIB                 ZETA\n         C     K,KOPOOL+24         LETTER Q. 6 CHAR. MOVED ALLREADY\n         BE    IDCHECK2            YES SKIP ADDITIONAL CHAR\n         BAL   REGOX,COB           CHECK IF O/P AREA FILLED\n         MVC   0(1,EAP),0(REGI)    MOVE CHAR TO OUTPUT\n         LA    EAP,1(0,EAP)\n         MVC   0(1,IN),0(REGI)               TO ITAB\n         LA    IN,1(0,IN)          INCREASE\n         LA    K,1(0,K)            POINTERS\n         B     IDCHECK2            GO AND CHECK NEXT CHAR.\n         SPACE 2\n*****   FINDSEMC ******************************************************\n*                   CHECKS FOR SEMICOLON OR POINT- COMMA\n*                   BLANKS AND I/P BUFFER CHANGE IS HANDLED\n*                   IF SEMICOLON IS FOUND THE RETURN IS VIA REG12\n*                   IF NOT THE RETURN IS VIA REGB\n         SPACE 2\n         LA    REGI,1(0,REGI)\nFINDSEMC LA    REGIX,*\n         CLI   0(REGI),X'0B'       Q. SEMICOLON\n         BC    8,0(0,REG12)        EQUAL- SEMICOLON FOUND\n         CLI   0(REGI),X'2D'       Q POINT\n         BE    FINDCOMA                 YES- LOOK FOR COMMA\n         CLI   0(REGI),X'2B'       Q BLANK\n         BE    FINDSEMC-4\n         CLI   0(REGI),X'2F'\n         BE    CIB\n         BCR   15,REGB             ERROR- NO SEMICOLON\nFINDCOMA LA    REGIX,*+8\n         LA    REGI,1(0,REGI)\n         CLI   0(REGI),X'25'       Q COMMA\n         BC    8,0(0,REG12)        EQUAL- SEMICOLON FOUND\n         CLI   0(REGI),X'2B'       Q BLANK\n         BE    FINDCOMA+4\n         CLI   0(REGI),X'2F'\n         BE    CIB\n         BCR   15,REGB             ERROR NO SEMICOLON\n         SPACE 2\n*****   ITABCLEA ***\n*                   CHECKS FOR ITABOVERFLOW AND CLEARS THE NEXT ENTRY\n         SPACE 2\nITABCLEA L     REGY,AITL\n         LA    REGY,11(0,REGY)\n         C     REGY,ELI            Q ROOM FOR ONE MORE ITAB ENTRY\n         BL    *+10\n         BAL   REGB,ERR4\n         DC    X'04D5'             E213\n         LR    IN,REGY             INCREASE ITAB POINTERS\n         ST    REGY,AITL\n         MVI   0(REGY),X'00'       CLEAR NEXT\n         MVC   1(10,REGY),0(REGY)  ITAB ENTRY\n         BCR   15,REG12            RETURN\nIEX11001 CSECT\n         SPACE 2\n*****   COB      ******************************************************\n*                   CHECKS IF NEW O/P BUFFER IS NEEDED\n*                   ENTRY IS TO COBSPEC IF TWO OR MORE CONTINIOUS\n*                        BYTES ARE NEEDED\n*                   THE CHANGE OF ADDRESS BETWEEN THE TWO BUFFERS IS\n*                        DONE WITH DISP. DISP IS EITHER 0 OR 4\n*                        SO ADDARI+DISP WILL PICK UP EITHER ADDARI OR\n*                        THE ADDRESS OF THE ALTERNATE O/P BUFFER\n*                   WADDARI POINTS TO THE FIRST BYTE OF THE CURRENT\n*                        O/P BUFFER\n*                   EAP IS THE CURRENT O/P POINTER\n*                   APE POINTS TO THE LAST BYTE OF THE CORRENT BUFFER\n*                   ONC CONTAINS THE CURRENT O/P RECORD NUMBER\n*                   ZETA IS THE BUFFER END INDICATION\n         SPACE 2\nCOBSPEC  C     REG0,APE                 Q. SPACE LEFT FOR X MORE BYTES\n         BC    4,0(0,REGOX)             YES- RETURN\n         B     *+12                NO CHANGE OUTPUT BUFFER FIRST\nCOB      C     EAP,APE                  Q. SPACE LEFT FOR ONE MORE BYTE\n         BC    4,0(0,REGOX)             YES- RETURN\n         MVI   0(EAP),X'2F'             MOVE ZETA TO O/P BUFFER\n         STM   14,2,SAVE1          SAVE REGISTERS\n         ST    REGB,SAVE1+24\n         CLI   ONC,X'FF'           Q ALREADY 256 OUTPUTRECORDS\n         BL    *+10\n         BAL   REGB,ERR4           IF YES TERMINATE COMPILATION\n         DC    X'04D7'             E215\n         L     EAP,WADDARI         LOAD ADD. OF CURRENT  O/P REC\n         LA    REGB,DCBUT1         DCBADDRESS\n         CLI   ONC,X'00'           Q FIRST OUTPUTRECORD\n         BE    WRITEOB             IF YES SKIP CHECK\n         CHECK ODECB               CHECK IF BEFORELAST RECORD IS\n*                                  WRITTEN\nWRITEOB  WRITE ODECB,SF,(REGB),(EAP)\n         XI    DISP,X'04'          CHANGE ADDRESSDISPLACEMENT\n         IC    REGZ,DISP\n         L     EAP,ADDARI(REGZ)         COMPUTE VALID O/P BUFFERADD\n         ST    EAP,WADDARI              STORE IT IN WADDARI\n         LR    REGL,EAP            COMPUTE ADDRESS OF LAST BYTE IN\n         A     REGL,SRCE1S         THE NEW OUTPUT AREA\n         BCTR  REGL,0              AND SAVE IT\n         ST    REGL,APE            IN APE\n         IC    REGZ,ONC            INCREASE OUTPUTRECORDCOUNTER\n         LA    REGZ,1(0,REGZ)\n         STC   REGZ,ONC\n         L     REGB,SAVE1+24\n         LM    14,2,SAVE1\n         BCR   15,REGOX                 RETURN TO CALLING SEQUENCE\n         SPACE 2\n*****   CIB      ******************************************************\n*                   GET NEXT RECORD AND PRINTS IT WITH THE SC\n*                   IF ISO CODE IS SPECIFIED A TRANSLATION IS FIRST\n*                        MADE TO EBCDIC\n*                   THE RECORD IS TRANSLATE AND THE RECORD END\n*                        INDICATION - ZETA- IS INSERTED\n         SPACE 2\nCIB      STM   14,2,SAVE1          SAVE REGISTERS\n         SH    REGI,SEVEN          MOVE SEVEN CHAR INFRONT\n         MVC   WABEFOR(7),0(REGI)  OF WORKAREA\n         TM    HCOMPMOD+1,NSRCE         Q. NOSOURCE SPECIFIED\n         BO    GETREC                   YES SKIP PRINTING\n         L     15,PRTRTADD              PRINT\n         BALR  14,15\n         ST    REGI,APRNTAR             SAVE NEW PRINT BUFFER ADDRESS\nGETREC   L     REGI,INADD               DCBADDRESS\n         GET   (1),WA              GET NEXT RECORD\nTESTISO  TM    HCOMPMOD+1,ISO      TEST IF ISO INPUT\n         BO    ISOTRANS                 YES TRANSLATE ISO TO EBCDIC\n         L     REGI,APRNTAR\n         TM    HCOMPMOD+1,NSRCE         Q. NOSOURCE SPECIFIED\n         BO    NOPRINT                  YES- MOVE TO DUMMY PRINTAREA\n         LH    REGY,SC        CONVERT  SEMICOLON  COUNTER\n         CVD   REGY,DOUBLE\n         UNPK  0(5,REGI),DOUBLE(8)\n         MVZ   4(1,REGI),3(REGI)        MOVE OUT SC COUNTER\n         MVC   8(80,REGI),WA       MOVE RECORD TO PRINTAREA\n         B     *+10\nNOPRINT  MVC   SAVEPRNT+8(72),WA   IF NSRCE MOVE RECORD TO DUMMY PRINT\n         LM    14,2,SAVE1\n         LA    REGI,WA             SET INPUT POINTER\n         TR    WA(72),TRLTABLE     TRANSLATE RECORD\n         MVI   72(REGI),X'2F'      MOVE RECORD END IDENTIFIER\n         BCR   15,REGIX            RETURN\nISOTRANS ST    REGB,SAVE1+24\n         LA    REGB,WA                  GET START OF WA\n         LA    REGY,79(0,REGB)          GET END OF WA\nLOOP     CLI   0(REGB),X'4C'       )\n         BE    IRPAR\n         CLI   0(REGB),X'7B'       =\n         BE    IEQUAL\n         CLI   0(REGB),X'7C'       '\n         BE    IAPOST\n         CLI   0(REGB),X'6C'       (\n         BE    ILPAR\n         CLI   0(REGB),X'50'       +\n         BNE   LOOPEND\n         MVI   0(REGB),X'4E'       +\n         B     LOOPEND\nIRPAR    MVI   0(REGB),X'5D'       )\n         B     LOOPEND\nIEQUAL   MVI   0(REGB),X'7E'       =\n         B     LOOPEND\nIAPOST   MVI   0(REGB),X'7D'       '\n         B     LOOPEND\nILPAR    MVI   0(REGB),X'4D'       (\nLOOPEND  LA    REGB,1(0,REGB)\n         CR    REGB,REGY                Q. ALL CHAR. CHECKE IN WA\n         BNH   LOOP                     NO- CHECK NEXT\n         L     REGB,SAVE1+24            YES RETURN\n          B     TESTISO+8\n         SPACE 2\n*****   WITAB    ******************************************************\n*                   CONTAINS ALL DELIMITERS, EACH FOLLOWED BY\n*                        3 BYTES OF INFORMATION, 2 CHARACTERISTICS\n*                   AND A DISPLACEMENT TO DELPRGTB\n         SPACE 2\nW1TAB    DS    0CL256\nB1       DC    X'020304000006000004'\n*                  SLASH    STRING\nB2       DC    X'03434E1C000848451D000C4E51220000'\n*                   DO        IF        OR\nB3       DC    X'04444D43000010454E51000014404D432300004D4E53200000'\n*                   END                     AND         NOT\nB4       DC    X'095144404BC212185253444F1900005347444D1E0008444B52441F$\n               0008464E534E17000C5351544407001C4B445252110000424E4344'\n*                   REAL          STEP          THEN         ELSE\n*                   GOTO          TRUE          LESS         CODE\n         DC    X'000020484C4F4B210000'\n*                       IMPL\n*                       IMPL\nB5       DC    X'0A414446484D000024544D53484B1A00004051514058CA16285540$\n               4B544400002C4B4041444BCA18305647484B441B000045404B5244'\n*                   BEGIN           UNTIL          ARRAY            VA\n*              LUE          LABEL           WHILE           FALSE\n         DC    X'00001C4F4E564451050000445054404B10000044'\n*                       POWER           EQUAL\n         DC    X'50544855240000'\n*                   EQUIV\nB6       DC    X'02525648534247CA1C34525351484D46CB1030'\n*                   SWITCH            STRING\nB7       DC    X'05484D5344464451C21118414E4E4B44404DC21318424E4C4C444D$\n               530000384D4E534B44525215000046514440534451120000'\n*                   INTEGER             BOOLEAN              COMMENT\n*                       NOTLESS             GREATER\nB8       DC    X'014D4E53445054404B130000'\n*                   NOTEQUAL\nB9       DC    X'014F514E424443545144CAD03C'\n*                   PROCEDURE\nB10      DC    X'014D4E5346514440534451140000'\n*                   NOTGREATER\n         DS    0F\n         SPACE 2\n*****   LITAB    ******************************************************\n*                   USED TO SET REFERENCE IN W1TAB TO STRING\n*                        DELIMITERS WITH A PATICULARY LENGTH\n         SPACE 2\nL1TAB    DC    A(B1)\n         DC    A(B2)\n         DC    A(B3)\n         DC    A(B4)\n         DC    A(B5)\n         DC    A(B6)\n         DC    A(B7)\n         DC    A(B8)\n         DC    A(B9)\n         DC    A(B10)\n         SPACE 2\n*****   DELPRGTB ******************************************************\n*                   BRANCH ADDRESS TABLE USED AFTER A DELIMITER\n*                        HAS BEEN FOUND\n         SPACE 2\nDELPRGTB DS    0CL68\n         DC    A(NORMAL)\n         DC    A(STRING)\n         DC    A(TED)\n         DC    A(GIF)\n         DC    A(END)\n         DC    A(FOR)\n         DC    A(TYPE)\n         DC    A(BOLCON)\n         DC    A(CODE)\n         DC    A(BEGIN)\n         DC    A(ARRAY)\n         DC    A(VALUE)\n         DC    A(SPEC)\n         DC    A(SWITCH)\n         DC    A(COM)\n         DC    A(PROCEDUR)\n         DC    A(TYPEARRY)\n         DC    A(TYPPROC)\n         SPACE 2\n*****   DELTMIT  ******************************************************\n*                   TWO APOSTROPHES HAVE BEEN FOUND\n*                   IT IS CHECKED THAT THE LENGTH IS NOT ZERO OR EXCEED\n*                        THE LIMIT FOR A DELIMITER (10 CHARACTERS)\n*                   REGM POINTS TO THE FIRST AND REGI TO THE LAST\n*                        APOSTROPHE\n*                   THE LENGTH IS USED TO GET A DISPLACEMENT FROM THE\n*                        LITAB FOR A SECTION IN THE WITAB\n*                   A    SECTION IN THE WITAR CONTAINS ALL DELIMITERS\n*                        OF THE SAME LENGTH\n*                   THE FIRST BYTE IN EACH SECTION SAYS HOW MANY\n*                        ENTRIES THERE ARE IN THE SECTION\n*                        THEREAFTER A DELIMITER PLUS 3 BYTES OF\n*                        INTERNAL CODE MAKES A SUBSECTION\n*                        THE FIRST 2 BYTES OF THE INTERNAL CODE IS\n*                        CHARECTERISTCS FOR THE DELIMITER\n*                        THE THIRD BYTE IS A DISPLACEMENT TO THE\n*                        DELPRGTB, WHERE THE ADDRESS IS PICKED UP\n*                        TO THE PROGRAM TO HANDLE THE DELIMITER\n*                   A CHECK IS MADE WHEN A DILIMITER IS FOUND IF IF IS\n*                        THE FIRST FOUND IN THE PROGRAM - THE EXIT IS\n*                        THEN TO STARTDEL. THE TEST IS ON BITS2 X'20'\n*                   IF NO DELIMITER IS FOUND THE EXIT IS TO THE EROUT\n*                        PROGRAM\n*                   FBYTE- SWITCH\n*                        THE FBYTE IS FF IF AN APOSTROPHE IS FOUND IN\n*                        THE COMMENT PROGRAM\n*                        THE FBYTE IS F0 IF AN APOSTROPHE IS FOUND IN\n*                        THE TYPE PROGRAM INSTEAD OF THE FIRST\n*                        CHARACTER OF THE NAME\n*                        OTHERWISE IT IS 00\n         SPACE 2\nDELIMIT  SR    REGY,REGY\n         SR    REGL,REGL\n         LR    REGL,REGI\n         BCTR  REGL,0\n         SR    REGL,REGM           COMPUTE LENGTH L\n         BP    *+10                     Q. GREATER THAN ZERO\n         BAL   REGB,ERR6\n         DC    X'0A0C'        E12 DELETE FIRST APOSTROPHE\n         C     REGL,KOPOOL+44      Q. LIMIT EXEEDED ALLREADY\n         BH    EROUT               BRANCH TO ERRORROUTINE\n         BCTR  REGL,0\n         LA    REGX,L1TAB\n         TM    FBYTE,X'FF'              TEST FBYTE\n         BO    COMSPEC\n         BM    TYPESPEC\n         SLA   REGL,2(0)               START OF LOOKUP STRING\n         L     REGX,0(REGL,REGX)\n         IC    REGY,0(0,REGX)      NUMBER OF ENTRIES IN THIS SECTION\n         LA    REGX,1(0,REGX)      AND ADDRESS OF FIRST WORDENTRY\n         SRA   REGL,2(0)\nCLC      EX    REGL,COMPARE             Q. DELIMITER FOUND\n         BNE   NOTEQUAL                    NO- TRY NEXT IN SAME SECTION\n         IC    REGZ,3(REGL,REGX)\n         TM    BITS2,X'20'              Q. PROGRAM STARTED YET\n         BO    *+8                      YES\n         B     STARTDEL                 NO- CHECK FOR CORRECT START\n         L     REGB,DELPRGTB(REGZ)      BRANCH TO APPROPRIATE SUBPGM\n         BCR   15,REGB                  DEPENDING ON DISP IN WITAB\nNOTEQUAL LA    REGX,4(REGL,REGX)   GET  NEXT DELIMITER\n         BCT   REGY,CLC                 Q. AMY DELIMITERS LEFT TO CHECK\n         BC    15,EROUT            BRANCH TO ERRORROUTINE\n         CNOP  0,4\nCOMPARE  CLC   1(1,REGM),0(REGX)\n         SPACE 2\n*****   EROUT    ******************************************************\n*                   CHECKS ALL SECTIONS OF THE WITAB FOR AN EQUAL\n*                   DELIMITER TO THE ONE IN I/P, DISREGARDING LENGTH\n*                   IF NO EQUAL FOUND E14 IS GENERATED AND THE FIRST\n*                   APOSTROPHE IS DELETED. EXIT IS THEN TO TEST\n*                   IF AN EQUAL IS FOUND E13 IS FENERATED AND AN BRANCH\n*                   IS TAKEN TO THE APPROPRIATE SUBPROGRAM\n         SPACE 2\nEROUT    TM    FBYTE,X'FF'\n         BM    TYPESPEC                 INVALID IDENTIFIER\n         BO    COMCEE2                 COMMENT                   A32949\nEROUTOK  LA    REGZ,10       GO THROUGH ALL POSSIBILITIES\n         SR    REGY,REGY\n         LA    REGL,0                   INITILIZE REGL= 0\nEROUT2   SLA   REGL,2(0)\n         LA    REGX,L1TAB\n         L     REGX,0(REGL,REGX)        GET SECTION IN WITAB\n         IC    REGY,0(0,REGX)          NUMBER OF ENTRIES IN STRING\n         LA    REGX,1(0,REGX)          FIRST ENTRY\n         SRA   REGL,2(0)\nCLCERR   EX    REGL,COMPARE             Q. DELIMITER FOUND\n         BNE   EROUT3                   NO\n         TM    BITS2,STARTBIT           Q. PROGRAM STARTED YET\n         BZ    STARTDEL                 NO- CHECK FOR A CORRECT START\n         BAL   REGB,ERR13\n         DC    X'000D'             E13\n         LA    REGI,1(REGL,REGM)  SET REGI TO ONE BEYOND DELIMITER\n         IC    REGZ,3(REGL,REGX)       GET DISPLACEMENT OF PROGRAM\n         L     REGB,DELPRGTB(REGZ)     IN DELPRGTB\n         BCR   15,REGB                 BRANCH TO PROGRAM\nEROUT3   LA    REGX,4(REGL,REGX)   NO GET NEXT DELIMITER\n         BCT   REGY,CLCERR             Q ALL DEL IN STRING CHECKED\n         LA    REGL,1(0,REGL)          YES-GET NEXT STRING\n         BCT   REGZ,EROUT2\n         TM    BITS2,X'20'         Q. PROGRAM STARTED YET\n         BZ    TESTLOOP            NO RETURN TO MAINLOOP SCANNING\n         BAL   REGB,ERR2C\n         DC    X'0A0E'        E14\n         LA    REGI,1(0,REGM)          GET NEXT CHAR\n         BCR   15,RET                  RETURN\n         SPACE 2\n*****   TYPESPEC ******************************************************\n*                   'REAL'' OR 'INTEGER'' OR 'BOOLEAN'' HAS BEEN FOUND\n*                   THE ONLY VALID DELIMITERS ARE AT THIS POINT\n*                   ARRAY OR PROCEDURE\n         SPACE 2\nTYPESPEC CLC   1(9,REGM),B9+1      Q. TYPE PROCEDURE\n         BE    TYPPROC                  YES\n         TM    BITS2,X'20'              Q. PROGRAM STARTED YET\n         BZ    ERR8                     NO- GENERATE E11\n         CLC   1(5,REGM),B5+17     Q. TYPE ARRAY\n         BE    TYPEARRY                 YES\n*                                       INVALID IDENTIFIER HAS BEEN\n*                                       FOUND GO TO IER SPEC\nTPSPECER TM    BITS1,X'40'              Q. SPECIFICATION\n         BO    *+12\n         LA    REGH,TYPEDAFI            NO- SET RETURN TO TYPE PGM.\n         B     IERSPEC\n         LA    REGH,IDCHECK             YES- SET RETURN TO IDCHECK\n         B     IERSPEC\n         SPACE 2\n*****   COMSPEC  ******\n*                   TWO APOSTROPHES HAVE BEEN FOUND IN A COMMENT\n*                   VALID DELIMITERS TO END A COMMENT ARE\n*                   END OR ELSE\n         SPACE 2\nCOMSPEC  LA    REGX,B4+22      Q.COMMENT ENDING WITH ELSE\n         CLC   1(4,REGM),B4+22\n         BNE   *+16                     NO\n         C     REGL,KOPOOL+12      CHECK CORRECT LENGTH\n         BE    TED\n         B     ENTRAPR         RETURN TO FIND ANOTHER APOSTROPHE   4762\n         CLC   1(3,REGM),B3+1           Q. COMMENT ENDED WITH END\n         BNE   ENTRAPR         RETURN TO FIND ANOTHER APOSTROPHE   4762\n         C     REGL,KOPOOL+8       CHECK CORRECT LENGTH\n         BE    END                 END\n         B     ENTRAPR         RETURN TO FIND ANOTHER APOSTROPHE   4762\n         SPACE 2\n*****   STARTDEL ******************************************************\n*                   THE ONLY VALID DELIMITERS TO START A PROGRAM IS\n*                   BEGIN OR IF PRECOMPILED PROCEDURE IS SPECIFIED\n*                   PROCEDURE OR TYPE PROCEDURE\n         SPACE 2\nSTARTDEL STC   REGZ,BCHAR               GET DELIMITERS CHARACTERISTIC\n*                                       FROM WITAB\n         CLI   BCHAR,X'24'              Q. BEGIN FOUND\n         BE    FIRSTBEG                 YES\n         TM    HCOMPMOD,PROC       Q. PRECOMPIELED SPECIFIED\n         BZ    ERR8                     NO- GENERATE E11\n         CLI   BCHAR,X'3C'         Q. FOUND WORD IS PROCEDURE\n         BNE   TYPEPREC-8          NO\n         B     PROCEDUR                 YES\n         CLI   BCHAR,X'18'         Q. TYPE FOUND\n         BNE   ERR8                NO\nTYPEPREC LA    REGI,1(0,REGI)           LOOK FOR APOSTROPHE- TYPE PROC\n         CLI   0(REGI),X'2E'            Q. APOSTROPHE FOUND\n         BNE   *+10\n         BCTR  REGI,0                   YES- DECREASE TO LET TYPE PGM\n         B     TYPE                     FIND THE APOSTROPHE AGAIN\n         CLI   0(REGI),X'2B'            Q. BLANK\n         BE    TYPEPREC\n         CLI   0(REGI),X'2F'            Q. ZETA\n         BNE   ERR8                     NEITHER- GENERATE E11\n         ST    REGX,SAVE1+20            CHANGE I/P AND LOOK AGAIN\n         BAL   REGIX,CIB\n         L     REGX,SAVE1+20\n         B     TYPEPREC+4\n         SPACE 2\n         SPACE 2\n*****   NORMAL   ******************************************************\n*                   INSERTS IN THE O/P THE INTERNAL CODE FROM WITAB\n         SPACE 2\nNORMAL   BAL   REGOX,COB           CHECK IF O/P AREA FILLED\n         LA    REGX,1(REGL,REGX)   COMPUTE ADDRESS OF CODE\n         MVC   0(1,EAP),0(REGX)    MOVE CODE TO OUTPUTBUFFER\n         LA    EAP,1(0,EAP)        INCREASE OUTPUT- AND\n         LA    REGI,1(0,REGI)      INPUTPOINTERS\n         BCR   15,RET\n         SPACE 2\n*****   BOLCON   ******************************************************\n*                   MOVES OUT SIX BYTES OF INTERNAL CODE FOR\n*                   FALSE OR TRUE\n         SPACE 2\nBOLCON   LA    REG0,6(0,EAP)\n         BAL   REGOX,COBSPEC       CHECK IF ENOUGH SPACE IN O/P\n         MVC   0(5,EAP),INT        TRANSFER FIRST PART OF INTERNAL NAME\n         LA    REGN,1(REGL,REGX)   AND\n         MVC   5(1,EAP),0(REGN)    LAST PART\n         LA    EAP,6(0,EAP)        INCREASE OUTPUT-\n         LA    REGI,1(0,REGI)      AND INPUTPOINTERS\n         BCR   15,RET\n         SPACE 2\n*****   GIF      ******************************************************\n*                   TRANSFERS INTERNAL CODEBYTE AND EXITS\n*                   TO THE STATEMENT PROGRAM TO CHECK IF A PROCEDURE\n*                   BOBY HAS STARTED\n         SPACE 2\nGIF      BAL   REGOX,COB           CHECK IF O/P AREA FILLED\n         LA    REGN,1(REGL,REGX)   TRANSFER INTERNAL CODE\n         MVC   0(1,EAP),0(REGN)\n         LA    EAP,1(0,EAP)        INCREASE OUTPUT-\n         LA    REGI,1(0,REGI)      AND INPUTPOINTER\n         BC    15,STATE            BRANCH TO STATEMENTPROGRAM\n         SPACE 2\n*****   TED      ******************************************************\n*                   TRANSFERS INTERNAL CODE\n*                   SETS POSSIBLE LABEL POINTERS\n         SPACE 2\nTED      TM    BITS2,ENDBIT      Q. ELSE ENDED FINAL END COMMENT\n         BO    ERR9              YES\n         BAL   REGOX,COB\n         LA    REGX,1(REGL,REGX)\n         MVC   0(1,EAP),0(REGX)         TRANSFER INTERNAL CODE\n         ST    EAP,OPIN                 SET LABEL POINTERS\n         MVC   OPIN+4(1),ONC\n         MVC   OPINCHAR(1),0(REGX)\n         LA    EAP,1(0,EAP)\n         ST    EAP,LAPIN\n         LA    REGI,1(0,REGI)\n         NI    BITS2,X'FE'         SET ENDELSE BIT TO ZERO\n         BCR   15,RET\n         SPACE 2\n*****   BEGIN    ******************************************************\n*                   TEST IF PROC IN STACK\n*                   TRANSFERS 'BEGIN' TO OUTPUT AND STACK\n*                   SETS OPIN, OPIN+4, LAPIN, BEGBIT\n*                   BEGBIT IS USED TO DISTINGUISH BETWEEN COMPOUND\n*                        BEGIN AND BLOCK BEGIN. IF A DECLARATION IS\n*                        FOUND WHEN THE BEGBIT IS ON IT'S A BLOCK BEGIN\n*                        THE BEGBIT IS TURNED OF BY THE STATEMENT\n*                        PROGRAM AND THE BEG1 PROGRAM\n         SPACE 2\nBEGIN    L     REGY,SP\n         CLI   0(REGY),X'0C'            Q. PROC IN STACK\n         BE    BEGPROC             IF YES BRANCH TO PROC PROCESSING\n         LA    REG0,4(0,EAP)\n         BAL   REGOX,COBSPEC       CHECK IF ENOUGH SPACE IN O/P\n         MVI   0(EAP),X'0C'   TRANSFER BEGIN TO O/P\n         MVI   OPINCHAR,X'0C'           SET LABELSAVE\n         ST    EAP,OPIN            NOTE ITS POSITION IN OPIN AND\n         MVC   OPIN+4(1),ONC       THE NUMBER OF THE OUTPUTBUFFER\n         LA    EAP,1(0,EAP)        INCREASE OUTPUTPOINTER\n         ST    EAP,LAPIN           NOTE WHERE LABEL MAY START\n         OI    BITS1,X'80'         BEGBIT.= 1\n         LA    REGY,1(0,REGY)     INCREASE STACKPOINTER\n         C     REGY,ATOPSTAK\n         BL    *+10\n         BAL   REGB,ERR4           STACK OVERFLOW\n         DC    X'0414'             E20\n         MVI   0(REGY),X'08'            PUT BEGIN IN STACK\n         ST    REGY,SP\n         LA    REGI,1(0,REGI)\n         B     TESTLOOP\n         SPACE 2\n*****   BEGPROC  ******************************************************\n*                   PROCEDURE- SPECIFICATIONS- BEGIN HAS BEEN FOUND\n*                   PROC BOBY IS TO COME. PROC IS CHANGED TO PROC*\n*                   ITS CHECKED THAT ALL PARAMETERS HAVE BEEN\n*                        SPECIFIED\n*                   THE RETURN IS TO TEST VIA THE BEGIN PROGRAM\n         SPACE 2\nBEGPROC  MVI   0(REGY),X'10'       CONVERT PROC INTO PROC*\n         NI    BITS1,X'BF'         PROBIT=0\n         CLI   PZ,X'00'            TEST IF ALL PARAMETERS SPECIFIED\n         BE    BEGPROC-8                YES\n         BAL   REGOX,ERROR10            NO- GENERATE E11\n         B     BEGPROC-8\n         SPACE 2\n*****   FIRSTBEG ******************************************************\n*                   THE FIRST BEGIN IS CONSIDERED AS A BLOCK BEGIN\n*                   THE START BIT IS TURNED OFF\n*                   THE BEG1 PROGRAM IS JOINED\n*                   IF PRECOMPILED PROCEDURE HAS BEEN SPECIFID E42 IS\n*                        GIVEN AS A WARNING AND THE BEGIN IS\n*                        DISREGARDED\n         SPACE 2\nFIRSTBEG TM    HCOMPMOD,PROC       Q. PRECOMPIELED PROCEDURE\n         BZ    *+18\n         BAL   REGB,ERR7           YES  GIVE WARNING MESSAGE\n         DC    X'042A'\n         LA    REGI,1(0,REGI)      DISREGARD THE BEGIN\n         B     TESTLOOP\n         OI    BITS2,X'20'         NO  TURN STARTBIT OFF\n         LA    REGX,TESTLOOP            MAKE RETURN FROM BEGI BE TEST\n         LA    REGI,1(0,REGI)\n         B     BEG1FRST       FIRST BEGIN =BLOCK BEGIN\n         SPACE 2\n*****   BEGI     ******************************************************\n*                   BLOCKBEGIN PROGRAM\n*                   CHANGES BEGIN TO BETA IN STACK AND OUTPUT\n*                   INCREASES ITAB GROUP NR. AND PROGRAM BLOCK NR.\n*                   ENTRIES ARE MADE IN.\n*                        GROUPTABEL\n*                             SORROUNDING BLOCKS IG. NR\n*                        PBTAB1\n*                             SURROUNDING PBN\n*                        SCTAB - CURRENTSC COUNTER\n*                        ITAB\n*                             ADDRESSES OF SORROUNDIN BLOCK AND\n*                             IG HEADENTRIES, NEW PBN AND IGN.\n*                   LPBP (ADDRESS OF CURRENT PROGRAM BLOCK HEAD ENTRY)\n*                        AND\n*                   LIGP (ADDRESS OF CURRENT ITAB GROUP HEAD ENTRY)\n*                        ARE UPDATED\n*                   PUTS BETA + NEW PBN AND IGN TO OUTPUT REC.\n         SPACE 2\nBEG1     BCTR  EAP,0\n         NI    BITS1,BEGOFF        BEGBIT 0\n         CLI   0(EAP),X'0C'          Q. BEGIN IN O/P\n         BNE   ERROR21                  NO- DECLARATION INCORRECT PLACE\nBEG1FRST MVI   0(EAP),X'0D'             MOVE BETA TO O/P\n         L     REGY,SP             AND\n         MVI   0(REGY),X'04'       STACK\n         SR    REGB,REGB\n         LH    REGB,IGC\n         LA    REGB,1(0,REGB)           INCREASE ITABGROUPNUMBER\n         STH   REGB,IGC\n         AR    REGB,REGB                ENTRY IS TO GO INTO\n         AH    REGB,IGC                 A(GT)+3*(IGC)\n         A     REGB,AGT\n         L     REG7,LIGP\n         MVC   0(2,REGB),8(REG7)        ENTRY INTO GROUPTABLE\n         MVI   2(REGB),X'00'\n         NI    0(REGB),X'7F'            CLEAR POSSIBLE PHI IND.\n         CLI   PBC,X'FF'                Q. MORE THAN 255 BLOCKS\n         BNE   *+10\n         BAL   REGB,ERR4\n         DC    X'0416'             E22\n         IC    REGZ,PBC                 INCREASE\n         LA    REGZ,1(0,REGZ)      PROGRAMBLOCKNUMBER\n         STC   REGZ,PBC\n         L     REG7,LPBP\n         LA    REGB,PBTAB1\n         AR    REGB,REGZ\n         MVC   0(1,REGB),10(REG7)       ENTRY INTO PROGRAMBLOCKTABLE\n         STC   REGZ,1(0,EAP)            TRANSFER PBN TO O/P\n         AR    REGZ,REGZ           MAKE ENTRY OF CURRENT\n         LA    REGB,SCTAB(REGZ)    SC COUNTER IN SCTAB\n         MVC   0(2,REGB),SC\n         MVC   2(2,EAP),IGC        IGN IN OUTPUT BUFFER\n         LA    EAP,4(0,EAP)\n         ST    EAP,LAPIN                SET LABEL POINTERS\n         L     REGY,AITL                MAKE BLOCK HEAD IN ITAB\n         MVC   0(4,REGY),LIGP\n         MVC   4(4,REGY),LPBP\n         MVC   8(2,REGY),IGC\n         MVC   10(1,REGY),PBC\n         ST    REGY,LPBP                UPDATE LIGP AND LPBP\n         ST    REGY,LIGP\n         BAL   REG12,ITABCLEA           CHECK AND CLEAR NEXT ITABENTRY\n         BCR   15,REGX\n         SPACE 2\n*****   END      ******************************************************\n*                   ACTION DEPENDS ON WHAT IS IN THE STACK\n*                   TURNS IN ALL CASES OFF THE DELTABIT AND THE\n*                        END ELSE BIT\n*                   GENERAL RETURN POINT IS CSPEND IF RETURN\n*                        ADDRESS - IN REGE- IS NOT CHANGED\n*                   FINAL RETURN IS TO TEST VIA SEMCO OR COMMENT\n*                        PROGRAM\n*                   PROC** IN STACK ACTIVATES PBLOCKEND AND RETURNS\n*                        TO END TO INSPECT THE STACK AGAIN\n         SPACE 2\nEND      NI    BITS1,X'DF'         DELTABIT.=0\n         TM    BITS2,ENDBIT      Q. END FINISHED FINAL END COMMENT\n         BO    ERR9              YES\n         NI    BITS2,X'FE'         SET ENDELSE BIT TO ZERO\nCSPEND   LA    REGE,*             RETURN FOR PBLCKEND, FOREND\n         L     REGY,SP\n         IC    REGZ,0(0,REGY)      BRANCH\n         L     REGB,PROG1(REGZ)    DEPENDING ON TOPBYTE\n         BCR   15,REGB             OF THE STACK\n         CNOP  0,4\nPROG1    DC    A(ERR8)                  E11 IF ALPHA\n         DC    A(BLOCKEND)                     BETA\n         DC    A(COMPDEND)                     BEGIN\n         DC    A(PREND)                        PROC\n         DC    A(STAREND)                    PROC*\n         DC    A(PBLCKEND)\n         DC    A(FOREND)                FOR\n         SPACE 2\n*****   STAREND  ******************************************************\n*                   PROC* HAS ENDED\n*                        ACTIVATES THE PBLOCKEND PROGRAM AND RETURNS\n*                        AFTERWARDS TO TEST VIA COMMENT PROGRAM\n         SPACE 2\nSTAREND  OI    BITS1,X'20'         DELTABIT= 1\n         LA    REGE,COMMEND        LOAD ADDRESS OF ENDENTRY INTO COM-\n*                                  MENTPROGRAM\n         BC    15,PBLCKEND\n         SPACE 2\n*****   PREND    ******************************************************\n*                   PROC  HAS ENDED\n*                        CHECKS IF ALL PARAMETERS SPECIFIED\n*                        TURNS OFF THE PROBIT\n*                   A PROC THAT ENDS WITH 'END' IS NOT CORRECTED,\n*                        THEREFOR THE STACK IS AGAIN INSPECTED AFTER\n*                        THE PBLOCKEND PROGRAM HAS BEEN ACTIVATED\n         SPACE 2\nPREND    NI    BITS1,X'BF'         PROBIT.=0\n         CLI   PZ,X'00'            ALL PARAMETERS SPECIFIED\n         BE    PBLCKEND                 YES- ACTIVATE PBLCKEND\n         BAL   REGOX,ERROR10            NO- GENERATE E10 FIRST\n         B     PBLCKEND\n         SPACE 2\n*****   COMPDEND ******************************************************\n*                   A COMPOUND STATMENT HAS ENDED\n*                        TRANSFERS END '2C' TO OUTPUT AND RELEASES\n*                        BEGIN IN STACK\n*                   THEN- IT CHECKS IF THE END OF THIS COMPOUND\n*                        STATEMENT INDICATETS THE END OF ANY\n*                        FORSTATMENT(S) OR PROC**.\n*                        THIS IS DONE WITH BITS2 X'01' AND THE\n*                        COMMENT PROGRAM\n*                        IF THE END IS FOLLOWED BY A ., OR 'END' THE\n*                        STACK IS INSPECTED AGAIN\n*                        IF THE END IS FOLLOWED BY AN 'ELSE' THE\n*                        COUMPOUND STATMENT ITSELF IS ALL THAT HAS\n*                        ENDED AT THIS POINT\n         SPACE 2\nCOMPDEND BAL   REGOX,COB           CHECK IF O/P AREA FILLED\n         MVI   0(EAP),X'2C'        TRANSFER END TO OUTPUTBUFFER\n         LA    EAP,1(0,EAP)        INCREASE OUTPUTPOINTER\n         L     REGY,SP             RELEASE BEGIN IN\n         BCTR  REGY,0              STACK\n         ST    REGY,SP\nCOMPENDI CLI   0(REGY),X'00'       Q. ALPHA IN STACK\n         BE    PGMEND                   YES- LOGICAL PROGRAM END\n         CLI   0(REGY),X'14'       Q. PROC**\n         BL    COMMEND             BRANCH TO COM-PROGRAM,END-ENTRY\n*                                  FOR BEGIN OR BETA OR PROC* IN STACK\n         OI    BITS2,X'01'         SET END-ELSE BIT\n         B     COMMEND                  CHECK HOW ENDCOMMENT ENDS\n*                                  ENDCOMMENT ENDED WITH A SEMICOLON\nCOMPEND2 NI    BITS2,X'FE'         RESET END ELSE BIT\n         L     REGY,SP                  INSPECT STACK AGAIN\n         CLI   0(REGY),X'14'            Q. PROC** OR FOR IN STACK\n         BE    *+12                     PROC**\n         LA    REGE,COMPEND4            FOR  GOTO FORENS AND THEN\n         B     FOREND                   TEST AGAIN - COMPEND4\nCOMPEND3 OI    BITS1,X'20'              PROC**- SET DELTABIT\n         LA    REGE,SEMCO               RETURN FROM PBLCKEND\n         B     PBLCKEND                 BLOCKEND FOR PROC**\nCOMPEND4 CLI   0(REGY),X'14'            Q. PROC**,FOR OR S.E.\n         BE    COMPEND3                 PROC**\n         BH    FOREND                   FOR\n         B     SEMCO                    SOMETHING ELSE\n         SPACE 2\n*****   BLOCKEND ******************************************************\n*                   A BETA BLOCK HAS ENDED\n*                        THE RETURN AFTER THE PBLOCKEND PROGRAM IS\n*                        TO THE COMPENDI TO CHECK IF SOME MORE\n*                        ITAB GROUP SHOULD END AT THIS POINT\n         SPACE 2\nBLOCKEND BAL   REGE,PBLCKEND       EXECUTE PROGRAMBLOCKEND-PROGRAM\n         B     COMPENDI\n         SPACE 2\n*****   FOREND   ******************************************************\n*                   CORRECTS THE LIGP POINTER\n*                   INSERTS A CONTINUATION LINE IN ITAB IF THE\n*                        FORSTATMENT CONTAINED ANY LABEL\n*                   IF THE FORSTATMENT DID NOT CONTAIN ANY DEKLARATIONS\n*                        THE PREVIOUSC CREATED FOR HEADENTRY IS\n*                        ERASED\n*                   IF ONE CONTINUATION LINE IS CREATED, FOLLOWING\n*                        ENCLOSING FORSTATEMENTS WILL OVERLAY THE\n*                        FIRST CONTINUATION LINE, IF LABELS OR NOT\n*                   ETA AND SURROVNDING ITABGROUPS IG NR. IS MOVED\n*                        TO THE OUTPUT\n*                   FOR IS RELEASED IN THE STACK\n*                   ENTERED FROM SEMCO\n*                                END\n*                   EXITS TO     END\n*                                COMPEND4\n*                                STACKTST (IN SEMCO)\n         SPACE 2\nFOREND   L     REGB,LIGP\n         MVC   LIGP(4),0(REGB)     GET PREVIOUS LIGP HEAD\n         L     REGY,AITL           CURRENT ENTRY\n         S     REGY,KOPOOL+44           MINUS ELEVEN\n         TM    6(REGY),X'FF'       Q. IS CONTINUATION LINE NEEDED\n         BZ    EMPTYFOR            NO\n         BO    *+8                 OVERLAY PREVIOUS CONT. LINE\n         LA    REGY,11(0,REGY)     CREATE NEW CONT. LINE\n         L     REGB,LIGP\n         MVC   8(2,REGY),8(REGB)        COPY IG NUMBER\n         MVI   6(REGY),X'FF'       CONTINUATION LINE INDICATOR\n         NI    8(REGY),X'7F'            CLEAR POSSIBLE PHI INDICATOR\n         MVI   5(REGY),X'2B'\n         BAL   REG12,ITABCLEA+4    CLEA NEXT ENTRY\n         B     *+8\nEMPTYFOR BAL   REG12,ITABCLEA+8    CLEAR FORHEAD FOR EMPTY FORGROUP\n         LA    REG0,3(0,EAP)\n         BAL   REGOX,COBSPEC       CHECK IF ENOUGH SPACE IN O/P\n         MVI   0(EAP),X'2B'        INSERT ETA\n         L     REGB,LIGP\n         MVC   1(2,EAP),8(REGB)    AND CURRENT  IGN  IN OUTPUTBUFFER\n         NI    1(EAP),X'7F'        CLEAR EVENTUALLY PHI\n         LA    EAP,3(0,EAP)\n         L     REGY,SP             RELEASE FOR IN STACK\n         BCTR  REGY,0\n         ST    REGY,SP\n         BCR   15,REGF             RETURN\n         SPACE 2\n*****   PBLCKEND ******************************************************\n*                   ERASES EMPTY CONTINUATION LINES\n*                   WRITES OUT THE PROGRAMBLOCK TO SYSUT 3\n*                        LENGTH IS CALCULATED AND SAVED IN ITABLEN\n*                        AND STORED IN THE FIRST TWO BYTES OF THE\n*                        ITAB RECORD\n*                   THE SC IS PICKED UP FROM SCTAB AND ENTERED IN BYTES\n*                        6 AND 7\n*                        THE BLOCK IS MOVED TO THE ITABBUFFER WHERE\n*                        FROM IT IS WRITTEN OUT.\n*                   THE SURROUNDING BLOCKS NEW DECLARATIONS WILL\n*                   BE OVERLAYING THE OUTWRITTEN RECORD\n*                   AITL WILL POINT TO THE HEADENTRY'S PLACE OF THE\n*                       BLOCK WHICH NOW WAS WRITTEN OUT\n*                   LPBP TO THE SURROUNDING BLOCKS HEADENTRY\n*                   LIGP TO THE SURROUNDING ITABGROUPS HEADENTRY\n*                   AITL, LPBP AND LIGP WILL BE MODIFIED ACCORDINLY\n*                   EPSILON, THE SURROUNDING BLOCKS PBN AND IGN WILL\n*                        BE PUT TO THE OUTPUT\n*                   THE BLOCK INDICATOR IN THE STACK WILL BE RELEASED\n*                   IF STACK NOW IS EMPTY - ALPHA IN STACK - PGMEND\n*                        WILL SET THE END BIT AND CHANGE END OF DATA\n*                        EXIT TO EODADIN. THIS WILL CAUSE THE COMMENT\n*                        PROGRAM TO CHECK FOR AN CORRECT ENDCOMMENT\n*                        BUT NOTHING MORE IS TO BE PROCESSED\n*                   FOR PROGRAM BLOCK 0, IF ANY, THE BLOCK WILL ONLY\n*                        BE WRITTEN OUT AND NO FURTHER ACTIONS TAKEN\n*                   ENTERED FROM END (BETA, PROC* )\n*                                SEMCO (PROC, PROC**)\n*                   EXITS  TO    COMMEND  (NORMAL)\n*                                COMPEND4 ( PROC OR PROC** FOLLOWED BY\n*                                          END)\n*                                TERMINATION (NOPBN0)\n         SPACE 2\nPBLCKEND L     REGY,AITL\n         S     REGY,KOPOOL+44           SUBTRACT 11 TO EARSE\n         CLI   6(REGY),X'00'       EMPTY\n         BE    *-8                      CONTINUATION\n         LA    REGY,11(0,REGY)\nWRTITAB  S     REGY,LPBP            COMPUTE LENGTH OFITABSECTION\n         ST    REGY,ITABLEN\n         C     REGY,TWOK                Q. ITAB SECTION TOO LONG\n         BL    *+10\n         BAL   REGB,ERR4\n         DC    X'0426'        E38  MORE THAN 184 IDENTIFIERS\n         MVC   AITL(4),LPBP             UPDATE AITL\n         L     REGB,LPBP\n         MVC   LIGP(4),0(REGB)          UPDATE LIGP\n         MVC   LPBP(4),4(REGB)         UPDATE LPBP\n         MVC   0(2,REGB),ITABLEN+2      INSERT LENGTH IN HEADENTRY\n         MVI   5(REGB),X'2B'\n         STM   14,3,SAVE1          SAVE REGISTERS\n         SR    REGZ,REGZ\n         IC    REGZ,10(0,REGB)          GET CORRENT PBN\n         AR    REGZ,REGZ           INSERT SC AT BLOCKSTART\n         LA    REG7,SCTAB(REGZ)    IN HEADING\n         MVC   6(2,REGB),0(REG7)\n         TM    BITS2,X'08'             IS IT PB0                 A28230\n         BC    8,*+12                  NO                        A28230\n         MVI   6(REGB),X'00'           CORRECT SC                A28230\n         MVI   7(REGB),X'00'                FOR PB0              A28230\n         TM    BITS3,FRSITB             Q. FIRST BLOCK TO BE WRITEN\n         BZ    WRT1                     YES- DO NOT CHECK\n         STM   14,15,ERRSAVE            CHECK PREVIOUS WRITE\n         CHECK ITABC\n         LM    14,15,ERRSAVE\nWRT      L     REG7,AITABBUF       ADDRESS OF BUFFER\nCOMPARE1 C     REGY,D256                Q. MORE THAN 256 BYTES TO MOVE\n         BL    EX1                      NO MOVE ALL AT ONCE\n         MVC   0(256,REG7),0(REGB)      YES- MOVE A SECTION OF 256\n         LA    REGB,256(0,REGB)         BYTES AT A TIME\n         LA    REG7,256(0,REG7)\n         S     REGY,D256\n         C     REGY,D256                Q. STILL MORE THAN 256 LEFT\n         BH    COMPARE1+8               YES MOVE NEXT SECTION\nEX1      EX    REGY,MOVE4               MOVE A SECTION OF LESS THAN 256\n         LA    EAP,0(REGY,REG7)\n         L     REG7,AITABBUF          LOAD ADD. OF ITABBUFFER\n         L     REGY,UT3ADD                        DCB\n         L     REGL,ITABLEN                       LENGTH\n        WRITE ITABC,SF,(REGY),(REG7),(REGL)\n         LM    14,3,SAVE1\n         TM    BITS2,X'08'              Q. PB0 WAS WRITTEN\n         BCR   1,REGE              BRANCH BACK IF TERBIT ON\n         L     REGB,AITL                CLEAR\n         MVI   0(REGB),X'00'            NEXT\n         MVC   1(10,REGB),0(REGB)       ITABENTRY\n         LA    REG0,4(0,EAP)\n         BAL   REGOX,COBSPEC       CHECK IF ENOUGH SPACE IN O/P\n         MVI   0(EAP),X'2A'             INSERT EPSILON\n         L     REGB,LPBP\n         MVC   1(1,EAP),10(REGB)                         PBN\n         L     REGB,LIGP\n         MVC   2(2,EAP),8(REGB)                          IGN\n         NI    2(EAP),X'7F'        CLEAR FIRST BIT OF IGN (PHI IND)\n         LA    EAP,4(0,EAP)\n         L     REGY,SP       RELEASE\n         BCTR  REGY,0        TOPBYTE\n         ST    REGY,SP       IN STACK\n         TM    BITS1,X'01'        Q. TERMINATION BIT ON\n         BCR   1,REGE                   YES- RETURN TO ENDMISS PGM.\n         CLI   0(REGY),X'00'         Q.  STACK EMPTY\n         BE    PGMEND                   YES- LOGICAL PROGRAM ENP\n         BCR   15,REGE                  RETURN\nPGMEND   OI    BITS2,ENDBIT      SET ENDBIT\n         LA    REGOX,EODADIN            NEW.EOD ADDRESS\n         ST    REGOX,EODIN\n         B     COMMEND\nWRT1     OI    BITS3,FRSITB        DON'T CHECK FIRST TIME\n         B     WRT\n         CNOP  0,4\nMOVE4    MVC   0(1,REG7),0(REGB)        PBLCKEND MOVE FOR ITAB\nSCTAB    DS    CL510\n         SPACE 2\n*****   COMMENT  ******************************************************\n*                   THREE ENTRIES\n*                       1 COM  FOR THE ALGOL WORD COMMENT\n*                             SETS CODIT=1, CHECKS THAT COMMENT IS IN\n*                             A LEGAL POSSITION\n*                       2 COMERR FOR ERRORS IN DECLARATIONS ALL CHAR\n*                             TO NEXT SEMICOLON WILL BE SKIPPED\n*                             SET COBIT AND DELTABIT=1\n*                       3 COMMEND  ENTERED AFTER AN END IS FOUND.\n*                             SKIPPS ALL CHARACTERS TO NEXT ., OR END\n*                             OR ELSE\n*                             SETS THE COBIT =0\n         SPACE 2\nCOMERR   OI    BITS2,X'40'         SET COBIT AND\n         OI    BITS1,X'20'             DELTABIT ON\n         B     COMCEE2\nCOMMEND  NI    BITS2,X'BF'           SET  COBIT TO 0\n         BC    15,COMCED2\nCOM      OI    BITS2,X'40'           SET  COBIT  TO  I\n         LR    REGM,EAP\n         BCTR  REGM,0\n         CLI   0(REGM),X'0C'            Q. BEGIN IN O/P\n         BE    COMCED2\n         BCTR  REGM,0\n         BCTR  REGM,0\n         CLI   0(REGM),X'0B'            Q. BETA IN O/P\n         BE    COMCED2\n         CLI   0(REGM),X'29'            Q. DELTA IN O/P\n         BE    COMCED2\n         BCTR  REGM,0\n         CLI   0(REGM),X'0D'            SEMICOLON IN O/P\n         BE    COMCED2\n         BAL   REGB,ERR7                E18\n         DC    X'0412'\nCOMCED2  LA    REGI,1(0,REGI)        INCREASE  REGI BY I\nCOMCEE2  BALR  REGIX,0\n         SR    REGZ,REGZ\n         TRT   0(73,REGI),COMTABLE      SCAN THE COMMENT\n         LA    REGM,0(REGZ,REGIX)       BRANCH WITH HELP OF DISP.\n         BCR   15,REGM                  TO APPROPRIATE SUB. PGM.\n         SPACE 2\n*****   COMAPOST *****\n*                   IF AN END COMMENT IS PROCESSED, COBIT= 0, CHECK IF\n*                        APOSTROPHE IS THE START OF END OR ELSE\n*                   OTHERWISE RETURN TO SCAN THE COMMENT AGAIN\n         SPACE 2\nCOMAPOST TM    BITS2,X'40'              Q. COBIT ON\n         BO    COMCED2                  YES- RETURN TO SCANNING AGAIN\n         MVI   FBYTE,X'FF'              SET FBYTE\n         BC    15,ENTRAPR                 RETUN TO APOSTROFPROGRAM\nCOMZETA  B     CIB                 ZETA - RETURN TO COMERR\n         SPACE 2\n*****   COMPOINT *****\n*                   CHECK FOR SEMICOLON ., IF NOT RETURN\n         SPACE 2\nCOMPOINT LA    REGB,COMCEE2             RETURN IF NOT SEMCOLON\n         BAL   REG12,FINDSEMC\n         SPACE 2\n*****   COMSEMCO *****\n*                   ENDELSE BIT ON- END COMMENT AFTER BEGIN OR BETA\n*                        ENDED WITH A ., MEANS THAT THE END MIGHT ALSO\n*                        CLOSE AN FORSTATEMENT OR A PROCEDURE\n*                   ENDBIT ON- FINAL END HAS BEEN REACHED NOTHING IS TO\n*                        FOLLOW THIS COMMENT IN THE CORRECT CASE\n*                   AN SEMICOLON AFTER AN COMMENT IS NOT TO BE COUNTED\n*                        THAT IS COBIT= 1 AND DELTABIT=0 RETURN TO\n*                        TEST OTHERWISE RETURN VIA SEMICOLON PROGRAM\n         SPACE 2\nCOMSEMCO TM    BITS2,X'01'         END ELSE BIT\n         BO    COMPEND2            YES\n         TM    BITS2,ENDBIT      Q.FINAL END COMMENT HAS ENDED\n         BO    READROUT            YES OK\n         TM    BITS2,X'40'              Q. COMMENT\n         BZ    SEMCO                    NO\n         TM    BITS1,X'20'              Q. DELIMITER ERROR\n         BO    SEMCO                    YES\n         LA    REGI,1(0,REGI)           FOR A COMMENT SKIP SEMICOLON\n         B     TESTLOOP\n         SPACE 2\n*****   FOR      ******************************************************\n*                   INCREASES IG AND FSN NUMBER\n*                   MAKES ENTRIES IN SCOPE AND GROUPTABEL\n*                   MOVES FOR (18) TO OUTPUT FOLLOWED BY NEW IG NUMBER\n*                   CHECKS IF PROC IN STACK, IF YES PROC IS CHANGED TO\n*                        PROC**\n*                   PUTS FOR IN STACK\n*                   AN FORHEAD ENTRY IS MADE IN ITAB\n*                   THE RETURN IS TO TEST\n         SPACE 2\nFOR      LA    REG0,3(0,EAP)\n         BAL   REGOX,COBSPEC       CHECK IF ENOUGH SPACE IN O/P\n         LH    REGY,IGC            INCREASE ITABGROUPNUMBER\n         LA    REGY,1(0,REGY)\n         MVI   0(EAP),X'18'        MOVE 'FOR'\n         STH   REGY,IGC            AND  IGN\n         MVC   1(2,EAP),IGC\n         LA    EAP,3(0,EAP)        TO OUTPUTBUFFER\n         CLI   FSN,X'FF'           Q. MORE THAN 255 FOR STATEMENTS\n         BNE   *+10\n         BAL   REGB,ERR4\n         DC    X'0429'             E41\n         IC    REGZ,FSN            INCREASE FSN\n         LA    REGZ,1(0,REGZ)\n         STC   REGZ,FSN\n         LA    REG12,SPTAB-1\n         AR    REG12,REGZ\n         L     REGY,LPBP\n         MVC   0(1,REG12),10(REGY) MAKE ENTRY IN SCOUPTABLE\n         NI    BITS1,X'7F'              BEGBIT= 0\n         L     REG12,SP\n         C     REG12,ATOPSTAK           Q. STACK OVERFLOW\n         BL    *+10\n         BAL   REGB,ERR4\n         DC    X'0414'             E20\n         CLI   0(REG12),X'0C'           Q. PROC IN STACK\n         BNE   NOPROCBY                 NO\n         MVI   0(REG12),X'14'           MAKE PROC BE PROC**\n         NI    BITS1,X'BF'        PROBIT=0\n         CLI   PZ,X'00'            Q.ALLPARAMETERS SPECIFIED\n         BE    *+8                 YES\n         BAL   REGOX,ERROR10       NO- GENERATE E10\nNOPROCBY L     REG12,SP\n         LA    REG12,1(0,REG12)    INCREASE STACKPOINTER\n         MVI   0(REG12),X'18'      PUT FOR INTO STACK\n         ST    REG12,SP\n         LH    REG12,IGC\n         AR    REG12,REG12\n         AH    REG12,IGC\n         A     REG12,AGT\n         L     REGY,LIGP\n         MVC   0(2,REG12),8(REGY)  ENTRY INTO GROUPTABLE\n         STC   REGZ,2(REG12)\n         NI    0(REGOX),X'7F'      CLEAR POSSIBLE PHI IND.\n         L     REGY,AITL\n         MVC   0(4,REGY),LIGP      CONSTRUCT FOR HEADENTRY IN ITAB\n         MVI   5(REGY),X'2B'\n         MVC   8(2,REGY),IGC\n         ST    REGY,LIGP           UPDATE LIGP\n         BAL   REG12,ITABCLEA           CHECK AND CLEAR NEXT ITABENTRY\n         LA    REGI,1(0,REGI)\n         B     TESTLOOP\n         SPACE 2\n*****   TYPE     ******************************************************\n*                   ENTRED FOR INTEGER, REAL AND BOOLEAN\n*                   TESTS FOR NEWBLOCK, BEGBIT, AND IF IDENTIFIER IS\n*                        SPECIFIED, PROBIT\n*                   MOVES INTERNAL NAME CHARACTERISTICS AND PBN TO ITAB\n*                   CHECKS THE IDENTIFIER FOR VALIDITY AND MOVES UP TO\n*                        6 CHARACTERS TO ITAB EXTERNAL NAME\n*                   IF THE FIRST CHARACTER FOUND IS AN OPOSTROPHE THE\n*                        CHECK IS VIA APOSTROF, DELIMITER AND TYPESPEC\n*                        FOR ARRAY OR PROCEDURE (FBYTE=F0)\n         SPACE 2\nTYPE     TM    BITS1,X'40'               Q PROBIT = 1\n         BO    SPECENT                   YES\n         TM    BITS1,X'80'               Q BEGBIT = 1\n         BZ    *+16\n         ST    REGX,SAVE1               IF YES GO TO BEGI PGM\n         BAL   REGX,BEG1\n         L     REGX,SAVE1\n         L     REGY,AITL                MOVE CHARACTERISTICS TO ITAB\n         MVI   6(REGY),X'C0'             TO  THE  7TH  AND  8TH\n         MVI   7(REGY),X'30'            BYTE OF THE ENTRY\n         LA    REGB,2(REGL,REGX)        MODIFIY THE LAST 4 BITS WITH\n         MVN   7(1,REGY),0(REGB)        INFORMATION FROM THE WITAB\n         L     REGB,LPBP\n         MVC   8(1,REGY),10(REGB)  MOVE IN PROGRAMBLOCK NUMBER\nTYPEDAFI LA    REGI,1(0,REGI)            GET NEXT CHARACTER\n         CLI   0(REGI),X'40'       Q IS CHAR A LETTER\n         BNL   TYPENAME                  YES\n         CLI   0(REGI),X'2B'               Q IS IT BLANK\n         BE    TYPEDAFI\n         CLI   0(REGI),X'2F'     Q. IS IT ZETA\n         BNE   *+12\n         LA    REGIX,TYPEDAFI+4    CHANGE INPUT\n         BC    15,CIB                       BUFFER\n         CLI   0(REGI),X'2E'               Q  IS  IT  APOSTROPHE\n         BE    *+12\n         LA    REGH,TYPEDAFI               STORE RETURN ADDR\n         B     IERSPEC             GO TO ERRORROUTINE\n         MVI   FBYTE,X'F0'                 MOVE F0 TO FBYTE\n         BC    15,ENTRAPR               CHECK FOR TYPE ARRAY OR PROC\nTYPENAME L     IN,AITL             GET ITAB POINTER\n         MVC   0(1,IN),0(REGI)     MOVE FIRST CHAR. TO ITAB\n         LA    IN,1(0,IN)          INCREASE POINTER\n         LA    K,1                 INITILIZE COUNTER\n         LA    REGIX,*+8           RETURN IF CHANGE OF I/P BUF. NEEDED\nTYPENM02 LA    REGI,1(0,REGI)      GET NEXT CHAR.\n         CLI   0(REGI),X'2F'       Q. LETTER, ZETA OR SOMETHING ELSE\n         BE    CIB                 CHANGE I/P BUFFER\n         BL    TLISTSE             CHECK FURTHER\n         C     K,KOPOOL+24         Q. 6 CHAR. ALLREADY MOVED IN\n         BE    TYPENM02            YES\n         MVC   0(1,IN),0(REGI)     NO- MOVE IN NEXT CHAR\n         LA    IN,1(0,IN)          INCREASE\n         LA    K,1(0,K)            POINTERS\n         B     TYPENM02            TAKE NEXT CHAR.\nTLISTSE  CLI   0(REGI),X'2B'  Q. BLANK\n         BE    TYPENM02\n         CLI   0(REGI),X'25'       Q. COMMA\n         BE    TYPECOMA\n         LA    REGH,TYPEDAFI            RETURN ADDRESS FOR IER\n         LA    REGB,IER                 RETURN ADDRESS IF NO SEMICOLON\n         BAL   REG12,FINDSEMC           LOOK FOR SEMICOLON\n         SPACE 2\n*****   TYPESEMC ******\n*                   SEMICOLON FOUND\n*                   END OF THIS DECLARATION\n*                   DELTABIT IS TURNED ON AND THE RETURN TO TEST IS\n*                        VIA SEMCO\n         SPACE 2\nTYPESEMC BAL   REG12,ITABCLEA           CLEAR NEXT ITAB ENTRY\n         OI    BITS1,X'20'              SET DELTABIT TO ONE\n         B     SEMCO                    GO TO SEMICOLON PROGRAM\n         SPACE 2\n*****   TYPECOMA ******\n*                   AN COMMA ENDED THE IDENTIFIER\n*                   THE INTERNAL NAME IS COPIED AND TYPEPROGRAM\n*                        UTILIZED AGAIN\n         SPACE 2\nTYPECOMA L     REGA,AITL\n         BAL   REG12,ITABCLEA           CHECK AND CLEAR NEXT ITABENTRY\n         MVC   6(3,REGY),6(REGA)        COPY ID AND PBN FIELDS\n         B     TYPEDAFI                 RETURN TO CHECK NEXT IDENTIFIER\n         SPACE 2\n*****   IER      ******************************************************\n*                   IDENTIFIER ERROR ROUTINE\n*                   HAS 2 ENTRIES\n*                       1. IERSPEC IF FIRST CHARACTER IS IN ERROR, E5\n*                       2. IER ANY OTHER CHARACTER, E16\n*                   THE RETURN\n*                       1. VIA REGH IF AN COMMA IS FOUND AFTER THE\n*                             IDENTIFIER IN ERROR\n*                       2. TO TEST VIA SEMCO IF AN SEMICOLON IS FOUND\n*                       3. TO PROCFIN IF AN RIGHT PARENTHESIS IS FOUND\n*                             AND THE FMBIT IS ON WHITCH INDICATES\n*                             THAT THE FORMAL PARAMETER LIST OF A\n*                             PROCEDURE IS UNDER PROCESS\n*                   REGH MIGHT LEAD TO TYPEDAFI\n*                                       IDCHECK\n*                                       PROCID\n         SPACE 2\nIERSPEC  BAL   REGB,ERR7\n         DC    X'0405'             E5\n         B     *+10\nIER      BAL   REGB,ERR2\n         DC    X'0010'             E16\n         L     IN,AITL                      RESET IN TO START\n         MVI   0(IN),X'00'              CLEAR EXTERNAL NAME PART\n         MVC   1(5,IN),0(IN)\nIERCOMMA LA    REGI,1(0,REGI)\n         LA    REGB,IERSELSE       RETURN IF NO SEMICOLON FOUND\n         BAL   REG12,FINDSEMC      LOOK FOR SEMICOLON\nIERSEMCO L     REGY,AITL           SEMICOLON FOUND - END OF DECLARATION\n         BAL   REG12,ITABCLEA+8    CLEAR ITAB ENTRY\n         TM    BITS3,FMBIT         Q. FORMAL PARAMETER LIST PROCESSED\n         BO    SCYES3-8            YES RETURN TO PROCEDURE END\n         OI    BITS1,X'20'         DELTABIT = 1\n         NI    BITS2,X'EF'              VALBIT=0\n         MVC   KB(2),KOPOOL        CKB = 00\n         B     SEMCO               RETURN TO TEST VIA SEMCO\nIERSELSE CLI   0(REGI),X'25'       Q COMMA\n         BCR   8,REGH              RETURN IF COMMA FOUND\n         TM    BITS3,FMBIT         Q. FORMAL PARAMETER LIST PROCESSED\n         BZ    IERCOMMA            NO\n         CLI   0(REGI),X'26'       Q CHAR IS RIGHT PARENTHESIS\n         BE    PROCFIN        YES GO TO PROCEDURE END HANDLING\n         B     IERCOMMA            CONTINUE CHECKING NEXT CHAR\n         SPACE 2\n*****   CODE     ******************************************************\n*                   SETS THE PROBIT TO ZERO\n*                   CHECKS THAT CODE IS IN THE CORRECT PLACE AND IS\n*                        FOLLOWED BY A SEMICOLON\n*                   CORRECTS THE INTERNAL NAME OF THE PROCEDURE\n*                   TRANSFER THE NAME IN EXTERNAL FORM TO OUTPUT\n*                   RETURNS VIA PROGRAM BLOCK END TO TEST\n         SPACE 2\nCODE     NI    BITS1,X'BF'         PROBIT=0\n         CLI   PZ,X'00'            Q. ALL PARAMETERS SPECIFIED\n         BZ    *+8                 YES\n         BAL   REGOX,ERROR10       NO- GENERATE E10\n         L     REGY,SP\n         CLI   0(REGY),X'0C'       PROC IN STACK\n         BNE   CODERR              IF NO BRANCH TO ERROR\n         LR    REGL,EAP\n         S     REGL,KOPOOL+12\n         CLI   0(REGL),X'29'       Q. DELTA IN O/P\n         BNE   CODERR              IF NO  BRANCH TO ERROR\n         L     REGY,LPBP\n         S     REGY,KOPOOL+44      GET PROCEDURE NAME\n         XI    7(REGY),X'80'       INTERNAL NAME IS CORRECTED\n         TM    19(REGY),X'80'      Q. TYPE PROCEDURE\n         BZ    *+8\n         XI    29(REGY),X'80'      YES- CORRECT SECOND NAME ENTRY\n         LA    REG0,9(0,EAP)\n         BAL   REGOX,COBSPEC       CHECK IF ENOUGH SPACE IN O/P\n         MVI   0(EAP),X'3C'        TRANSFER GAMMA\n         MVC   1(6,EAP),0(REGY)    TRANSFER NAME AND\n         TR    1(6,EAP),RETRANS    CONVERT TO EXTERNAL CODE\n         MVC   7(1,EAP),RETRANS    INSERT EXTERNAL BLANKS\n         MVC   8(1,EAP),RETRANS\n         LA    EAP,9(0,EAP)\n         OI    BITS1,X'20'         DELTABIT.=1\nSEARCH   LA    REGB,NOSEMC         RETURN IF NO SEMICOLON FOUND\n         LA    REGE,SEMCO          RETURN ADD. FOR PBLCKEND\n         LA    REGI,1(0,REGI)\n         BAL   REG12,FINDSEMC      Q. SEMICOLON FOLLOWS\n         B     PBLCKEND            SEMICOLON FOUND- GO TO PBLCKEND\nNOSEMC   BAL   REGB,ERR7\n         DC    X'040F'             E15\n         LA    REGB,FINDSEMC       Q WAS A PERIOD FOUND\n         CR    REGB,REGIX\n         BE    PBLCKEND            NO\n         BCTR  REGI,0              YES-\n         MVI   0(REGI),X'2D'       MOVE IN A PERIOD\n         BCTR  REGI,0              DECREASE REGI, WILL BE INCREASED\n         B     PBLCKEND            BY SEMCO. RETURN VIA PBLCKEND\n*                                  AND SEMCO TO TEST\nCODERR   BAL   REGB,ERR7\n         DC    X'0418'             E24\n         B     COMERR              SKIP TO NEXT SEMICOLON\n         SPACE 2\nIEX11002 CSECT\n         SPACE 2\n*****   SPEC     ******************************************************\n*                   ENTERED FOR LABEL AND STRING\n*                   CHECKS THAT THEY ARE IN PROCEDURE HEAD\n         SPACE 2\nSPEC     TM    BITS1,X'40'         Q. PROBIT ON\n         BO    SPECENT YES PROCESS SPECIFIED LABEL OR STRING\n         BAL   REGB,ERR7\n         DC    X'0419'             E25\n         B     COMERR              SKIP TO NEXT SEMICOLON\n         SPACE 2\n*****   SPECENT  ******************************************************\n*                   ENTERED FOR SPECIFICATIONS FROM\n*                                                 TYPE\n*                                                 SPEC\n*                                                ARRAY\n*                                                SWITCH\n*                                                PROCEDURE\n*                   SAVES IN KB THE CHARACTERISTICS TAKEN FROM THE\n*                        DELIMITER TABLE\n         SPACE 2\nSPECENT  LA    REGY,1(REGL,REGX)   MOVE IN IDFIELD\n         MVC   KB(2),0(REGY)\n         SPACE 2\n*****   IDCHECK  ******************************************************\n*                   ENTERED FROM VALUE\n*                                 TYPEARRAY\n*                                 TYPEPROCEDURE\n*                                  SPECENT\n*                   CHECKS THE NAME FOR FORMAL PARAMETERS\n*                   FINDS THE ENTRY IN ITAB AND INSERTS THERE THE\n*                        CHARACTERISTICS AND PROGRAM BLOCK NUMBER\n*                   DECREASES THE PARAMETER COUNT PZ BY ONE FOR EACH\n*                        CORRECT PARAMETER FOUND\n*                   IF A COMMA ENDS THE IDENTIFIER IDCHECK WILL BE\n*                        ACTIVATED AGIAN\n*                   IF A SEMICOLON ENDS THE DELIMITER THE RETURN IS TO\n*                        TEST VIA SEMICOLON PROGRAM\n         SPACE 2\nIDCHECK  LA    REGI,1(0,REGI)               GET NEXT  CHAR\n         CLI   0(REGI),X'39'              Q IS IT A LETTER\n         BNH   IDNOLETR                     NO\n         MVC   IDBUCKET(6),KOPOOL       CLEAR BUCKET WITH ZEROS\n         LA    IN,IDBUCKET\n         LA    REGL,1\n         MVC   0(1,IN),0(REGI)     MOVE FIRST CHAR. TO BOCKET\n         LA    IN,1(0,IN)\n         LA    REGIX,*+8           RETURN IF CIB NEEDED\nIDLOOP   LA    REGI,1(0,REGI)      GET NEXT CHAR.\n         CLI   0(REGI),X'2F'            Q ZETA\n         BE    CIB                      YES\n         BL    IDSEARCH                 SOMETHING ELSE\n         C     REGL,KOPOOL+24           LETTER OR DIGIT\n         BE    IDLOOP                   Q 6 CHAR MOVED ALLREADY YES\n         MVC   0(1,IN),0(REGI)          NO MOVE CHAR\n         LA    IN,1(0,IN)          INCREASE POINTERS\n         LA    REGL,1(0,REGL)\n         B     IDLOOP              TAKE NEXT CHAR.\nIDNOLETR CLI   0(REGI),X'2B'      FIRST CHAR WAS NOT LETTER. Q. BLANK\n         BE    IDCHECK                       YES . GET NEXT CHAR\n         CLI   0(REGI),X'2F'                Q  IS IT A ZETA\n         BNE   *+12\n         LA    REGIX,IDCHECK+4         YES- CHANGE I/P-BUFFER\n         BC    15,CIB                        BUFFER\n         CLI   0(REGI),X'2E'                 Q  IS IT A APOSTROPHE\n         BE    *+12\n         LA    REGH,IDCHECK             NO- SET RETURN ADD AND GOTO\n         B     IERSPEC                  IDENTIFIER ERROR ROUTINE\n         MVI   FBYTE,X'F0'              SET FBYTE- LOOK FOR TYPE\n         BC    15,ENTRAPR               ARRAY OR TYPE PROC\nIDSELSE  BAL   REGB,ERR2E\n         DC    X'0010'                  E16\n         LA    REGH,IDCHECK             RETURN ADD FOR IER\n         B     IERCOMMA                 GO TO IDENTIFIER ERROR ROUTINE\nIDBUCKET DC    6X'00'\nIDSEARCH CLI   0(REGI),X'2B'            Q BLANK\n         BE    IDLOOP\n         CLI   0(REGI),X'25'            Q COMMA\n         BE    IDCOMMA\n         LA    REGB,IDSELSE             IF NOT SEMICOLON FOUND\n         BAL   REG12,FINDSEMC           LOOK FOR SEMICOLON\n         OI    BITS1,X'20'              SEMICOLON FOUND SET DELTABIT\nIDCOMMA  CLC   PRIMPAR(4),KOPOOL        Q. ARE THERE ANY PARAMETER\n         BE    NOTFOUND                 NO\n         L     REGPS,PRIMPAR            GET FIRST PARAMETER\n         SPACE 2\n*****   COMPID   ******\n*                   A LOOP TO FIND THE PARAMETER IN ITAB\n         SPACE 2\nCOMPID   CLC   IDBUCKET(6),0(REGPS)     CHECK IF IDENTIFIER FOUND\n         BE    IDVALCHK                     FOUND\n         LA    REGPS,11(0,REGPS)        NOT FOUND  TRY NEXT PARAMETER\n         C     REGPS,AITL                   IF THERE ARE ANY LEFT\n         BNE   COMPID                       YES\nNOTFOUND BAL   REGB,ERR2E\n         DC    X'001B'                  E27\n         B     IDENDER\nIDVALCHK TM    BITS2,X'10'                   VALUE  CALL\n         BO    VALDLB2                      YES - GO TO VAL ROUTINE\n         TM    6(REGPS),X'06'           Q SPECIAL USE BITS ON\n         BZ    IDCHKEND                 NO\n         BAL   REGB,ERR2E               YES CREATE\n         DC    X'001A'                  E26\n         B     IDENDER        GET NEXT IDENTIFIER\n         SPACE 2\n*****   IDCHKEND ******\n*                   INSERTS CHARACTERISTICS AND PBN, DECRESES PZ\n*                   IF BOTH VALUE AND NAME BIT ON BYTE 7 EQVALS 30\n*                        A VALUE SPECIFICATION HAS BEEN MADE EARLIER\n*                        SO IT IS CORRECTED TO BE A CALL BY VALUE\n         SPACE 2\nIDCHKEND L     REGB,LPBP\n         MVC   8(1,REGPS),10(REGB)      INSERT PBN\n         OC    6(2,REGPS),KB\n         IC    REGB,PZ                 CORRECT IDFIELD IS CREATED\n         BCTR  REGB,0              PZ= PZ-1\n         STC   REGB,PZ\n         TM    7(REGPS),X'30'           Q. VALUE BIT ON\n         BM    *+8\nVALCALL  NI    7(REGPS),X'EF'           YES- ZERO NAME BIT\nIDENDER  TM    BITS1,X'20'         Q. DELTABIT ON\n         BZ    IDCHECK                  NO-GET NEXT  IDENT.\n         MVC   KB(2),KOPOOL        YES CLEAR IDFIELD\n         NI    BITS2,X'EF'         SET VALBIT TO ZERO\n         BC    15,SEMCO                  GO TO SEMICOLON PROGRAM.\n         SPACE 2\n*****   VALUE    ******\n*                   CHECKS THAT SPECIFICATION IS IN A PROCEDURE HEAD\n*                   EXITS FIRST TO IDCHECK TO FIND THE PARAMETER\n*                   WILL THEN RETURN TO VALDLB2 FOR FUTHER CHECKS AND\n*                   TO INSERT THE VALUE BIT IN THE INTERNAL NAME\n         SPACE 2\nVALUE    TM    BITS1,X'40'            Q PROCEDDRE  PROCECED\n         BZ    *+12                   NO- ERROR\n         OI    BITS2,X'10'              YES- SET VALUE BIT TO ONE\n         BC    15,IDCHECK             AND GO TO IDCHEK\n         BAL   REGB,ERR7                E28  VALVE\n         DC    X'041C'                   OUTSIDE PROC.\n         B     COMERR              SKIP TO NEXT SEMICOLON\nVALDLB2  TM    7(REGPS),X'20'      Q. VALUE BIT ON IN IDENTIFIER\n         BZ    *+14                     NO\n         BAL   REGB,ERR2E\n         DC    X'001E'             E30\n         B     IDENDER        GET NEXT IDENTIFIER\n         TM    6(REGPS),X'06'        Q SPECIAL USE BIT ENTERED\n         BZ    *+18                     NO\n         BAL   REGB,ERR7\n         DC    X'041D'             E29\n         XI    7(REGPS),X'30'          MOVE IN IDFIELD\n         B     IDENDER        GET NEXT IDENTIFIER\n         MVI   7(REGPS),X'30'           CORRECT - MOVE IN IDFIELD\n         B     IDENDER        GET NEXT IDENTIFIER\n         SPACE 2\n*****   TYPEARRAY *****************************************************\n*                   ENTERED FROM TYPESPEC\n*                   TEST FOR PROBIT, BEGBIT\n*                   INSERTS CHARACTERISTICS IN INTERNAL NAME WITHOUT\n*                        DESTROYING THE TYPE SPECIFICATIONS ENTERED BY\n*                        THE TYPE PROGRAM\n*                   JOINS ARRAY PROGRAM\n*                   FOR A SPECIFIED TYPEARRAY THE EXIT IS TO IDCHECK\n         SPACE 2\nTYPEARRY TM    BITS1,X'40'             Q IS PROBIT ON\n         BO    TARYDHB3               YES - SPECIFICATION\n         TM    BITS1,X'80'              Q. BEGBIT ON\n         BZ    *+16\n         ST    REGX,SAVE1               YES\n         BAL   REGX,BEG1           GO AND PROCESS PROGRAMBLOCK HEAD\n         L     REGX,SAVE1\n         L     IN,AITL\n         MVI   6(IN),X'C8'              MOVE IN\n         XI    7(IN),X'34'              ID FIELD\n         BC    15,ARRYDME1           GO  TO ARRAY  PROCECING\nTARYDHB3 MVI   KB,X'CA'                 MOVE IN\n         OI    KB+1,X'04'             TYPE ARRAY SPECIFICATION ID\n         BC    15,IDCHECK\n         SPACE 2\n*****   ARRAY    ******************************************************\n*                   TESTS FOR PRO AND BEGBIT\n*                   ENTERS CHARACTERISTICS IN INTERNAL NAME\n*                TYPEARRAY JOINS HERE\n*                   PBN IS ENTERED IN INTERNAL NAME\n*                   09 FOR ARRAY IS MOVED TO OUTPUT\n*                   THE NAME IS CHECKED AND MOVED TO OUTPUT AND ITAB\n*                   SHOULD BE FOLLOWED BY A COMMA OR LEFT PARENTHISIS\n*                SETS N (NUMBER OF ARRAYS WITH SAME DIMENSIONS) TO ONE\n         SPACE 2\nARRAY    TM    BITS1,X'40'               Q  PROBIT  ON\n         BO    SPECENT                    YES\n         TM    BITS1,X'80'               Q  BEGBITI  ON\n         BZ    *+16\n         ST    REGX,SAVE1     YES- GO TO PROCESS PROGRAMBLOCKHEAD\n         BAL   REGX,BEG1\n         L     REGX,SAVE1\n         L     IN,AITL\n         MVI   6(IN),X'C8'              MOVE IN\n         MVI   7(IN),X'06'                IO-FIELD\nARRYDME1 L     REGB,LPBP\n         MVC   8(1,IN),10(REGB)           MOVE IN PROGRAMBLOCK NR.\n         LA    REGB,9(0,IN)               MOVE  ADD  OF  AITL+9\n         ST    REGB,DIM                   TO  DIM\n         BAL   REGOX,COB\n         MVI   0(EAP),X'09'             MOVE ARRAY ID TO O/P\n         LA    EAP,1(0,EAP)\nARRYNAME LA    REGI,1(0,REGI)           GET FIRST CHAR\n         CLI   0(REGI),X'39'            Q. LETTER\n         BNH   ARNAMESE                 NO\n         TM    BITS1,X'04'              Q. LISTBIT ON\n         BO    ARRYMULT                 YES\n         MVC   N(1),KOPOOL+7            SET N=1\nARRYID   BAL   REGB,IDCHECK1       CHECK, MOVE IDENT. TO ITAB AND O/P\nARRYSE   CLI   0(REGI),X'2B'       Q. BLANK\n         BE    IDCHECK2\n         CLI   0(REGI),X'06'       Q  LEFT PARENTHESIS\n         BE    ARRYLPAR\n         CLI   0(REGI),X'25'       Q. COMMA\n         BE    ARCOMMA\nARRAYERR BAL   REGB,ERR2           SOMETHING ELSE FOUND\n         DC    X'0010'             E16\n         BAL   REGOX,COB\n         MVI   0(EAP),X'3D'   MOVE IN RHA\n         LA    EAP,1(0,EAP)\nARYEXIT  L     REGY,AITL\n         BAL   REG12,ITABCLEA+8         CLEAR ITAB-ENTRY\n         NI    BITS1,X'F7'    TURN OFF ARBIT\n         LA    RET,TESTLOOP        RESET RETURN REGISTER TO MAINLOOP\n         B     COMERR              SKIP TO NEXT SEMICOLON\nARNAMESE CLI   0(REGI),X'2B'       Q. NAME STARTS WITH BLANK\n         BE    ARRYNAME\n         CLI   0(REGI),X'2F'       Q. ZETA\n         BNE   *+12\n         LA    REGIX,ARRYNAME+4\n         B     CIB\n         BAL   REGB,ERR7                FIRST CHAR. OF NAME IN ERROR\n         DC    X'0405'\n         B     ARYEXIT             DELETE DECLARATION\n         SPACE 2\n*****   ARRAYPAR ******\n*                   ENTERED WHEN A LEFT PARENTHESIS IS FOUND AFTER THE\n*                        NAME\n*                   INITILIZES D DIMENSION COUNTER=0\n*                   SETS THE ARBIT\n*                              C PARENTHESIS COUNT=1\n*                   SEARCHES FOR A SLASH\n*                   MOVES OUT SUBSCRIPT BRACKETS TO OUTPUT\n*                   EXITS TO ARRAYLIST\n         SPACE 2\nARRYLPAR OI    BITS1,X'08'              ARBIT = 1\n         LA    REGOX,1\n         STH   REGOX,C                  C=1\n         LA    REGOX,0\n         STC   REGOX,D                  D=0\n         LA    REGI,1(0,REGI)          GET NEXT CHAR\nARRYSLSH CLI   0(REGI),X'03'            Q SLASH\n         BE    ARRYLSQB                 YES- MOVE IN LEFT SQ. BRACKET\n         CLI   0(REGI),X'2B'            Q CHAR IS BLANK\n         BE    ARRYSLSH-4               YES-GET NEXT CHAR.\n         CLI   0(REGI),X'2F'            Q CHAR IS ZETA\n         BNE   *+12                     NO-GOTO ERROR ROUTIEN\n         LA    REGIX,ARRYSLSH           YES- CHANGE\n         BC    15,CIB                  INPUT  BUFFER\n         BAL   REGB,ERR2\n         DC    X'001F'        E31\n         BCTR  REGI,0\nARRYLSQB BAL   REGOX,COB           CHECK IF O/P AREA FILLED\n         MVI   0(EAP),X'08'             MOVE IN LEFT SQUAREBRACKET\n         LA    EAP,1(0,EAP)             INCREASE\n         LA    REGI,1(0,REGI)      POINTERS\n         B     LIST                     GO TO PROCESS ARRAY LIST\n         SPACE 2\n*****   ARCOMMA  ******\n*                   COPIES INTERNAL PART OF ITAB ENTRY SETS THE LISBIT\n*                   EXITS TO ARRAYNAME TO CHECK FIRST CHARACTER OF NEXT\n*                        NAME. THE LIST BIT WILL THEN CAUSE ARRAYMULT\n*                        TO BE EXECUTED BEFORE THE REST OF THE NAME\n*                        IS CHECKED\n*                   INCREASES N, NUMBER OF ARRAYS WITH THE SAME\n*                        DIMENSIONS, BY ONE\n         SPACE 2\nARCOMMA  L     REGA,AITL                SAVE AITL\n         BAL   REG12,ITABCLEA           CHECK AND CLEAR NEXT ITABENTRY\n         MVC   6(3,REGY),6(REGA)        COPY ID AND PBN FIELDS\n         IC    REGB,N                   INCREASE\n         LA    REGB,1(0,REGB)      N\n         STC   REGB,N                   BY ONE\n         OI    BITS1,X'04'              SET LISTBIT TO ONE\n         B     ARRYNAME            GET NEXT EXTERNAL NAME\n         SPACE 2\n*****   ARRAYMULT  ******\n*                   MOVES OUT THE COMMA PREVIONSLY FOUND\n*                   SETS THE LISTBIT TO ZERO\n*                   RETURNS TO ARRAYID (AVOIDS RESETING N TO ONE)\n         SPACE 2\nARRYMULT BAL   REGOX,COB\n         MVI   0(EAP),X'25'        MOVE OUT THE COMMA\n         LA    EAP,1(0,EAP)\n         NI    BITS1,X'FB'         SET LISTBIT TO ZERO\n         B     ARRYID\n         SPACE 2\n*****   ARTABLE  ******************************************************\n*                  USED BY LIST EQUIVALENT TO THE USE OF TESTTABLE\n*                        BY TESTLOOP. GIVES DISPLACEMENT TO BPRTAB\n         SPACE 2\nARTABLE  DS    0CL90\n         DC    2X'00'\n         DC    X'0488'\n         DC    2X'00'\n         DC    X'6854'\n         DC    3X'00'\n         DC    X'58'\n         DC    5X'00'\n         DC    X'1014'\n         DC    13X'00'\n         DC    X'18'\n         DC    4X'00'\n         DC    X'806C'\n         DC    4X'00'\n         DC    X'282C843438'\n         DC    42X'00'\n         SPACE 2\n*****   LIST     ******************************************************\n*                   USED FOR ARRAY AND SWITCH LIST PROCESSING\n*                   MAKES THE TRT AGAINST ARTABLE AND UTILIZES MAINLOOP\n*                        TO MOVE SCANNED BYTES AND BRANCH TO THE\n*                        APPROPRIATE PROGRAM, EITHER A LIST PROGRAM\n*                        OR ONE OF THE COMMON PROGRAMS\n*                        THE RETURN WILL BE TO LIST VIA REGISTER 10,\n*                   RET WILL POINT TO LIST UNTIL CHANGED BY ENDLIST\n*                        TO POINT TO TESTLOOP AGAIN\n         SPACE 2\nLIST     BALR  RET,0                    SET RETURN REGISTER\n         LR    REGM,REGI                START CHAR IN SCAN\n         LR    REGIX,RET                RETURN FROM CIB\n         SR    REGZ,REGZ\n         TRT   0(73,REGI),ARTABLE       SCAN AGAINST AR TABLE\n         B     CONT                     UTILIZE TESTLOOP\n         SPACE 2\n*****   PONTLST  ******\n*                   USES THE SAME POINTABEL AS MAINLOOP BUT\n*                   ADDS 56 TO THE DISPLACEMENTS\n         SPACE 2\nPONTLST  LA    REGI,1(0,REGI)                GET NEXT CHAR.\n         SR    REGZ,REGZ\n         TRT   0(73,REGI),PTTABLE       SCAN TO NEXT DELIMITER\n         LA    REGB,BPRTAB         IN PTTABLE\n         L     REGB,56(REGB,REGZ)\n         BCR   15,REGB             BRANCH ACCORDING TO 56+ DISP+ BPRTAB\n         SPACE 2\nPZETA    LA    REGIX,PONTLST+4               ZETA IN POINTLIST\n         BC    15,CIB\n         SPACE 2\n*****   RIGTPARL ******  MOVES OUT THE RIGHT PARENTHESIS DECREASES THE\n*                        PARENTHESIS COUNT AND RETURNS TO LIST\n         SPACE 2\nRIGTPARL BAL   REGOX,COB           CHECK IF O/P AREA FILLED\n         MVI   0(EAP),X'26'            MOVE  IN   $   RIGHT  PAREN.\n         LA    EAP,1(0,EAP)\n         LA    REGI,1(0,REGI)           GET NEXT  CHAR.\n         LH    REGB,C\n         BCTR  REGB,0              DECREASE PARENTHESIS COUNT\n         STH   REGB,C\n         BCR   15,RET\n         SPACE 2\n*****   LEFTPARL ******\n*                        INCREASES THE PARENTHESIS COUNT\n*                        CHECKS IF NEXT CHARACTER IS A SLASH, IF IT IS\n*                        MOVES A SUBSCRIPT BRACKET OUTPUT, IF NOT\n*                        MOVES A SIMPLE PARENTHESIS\n         SPACE 2\nLEFTPARL LH    REGB,C              INCREASE PARENTHESIS COUNT\n         LA    REGB,1(0,REGB)\n         STH   REGB,C\nLPARDQC3 LA    REGI,1(0,REGI)           GET  NEXT  CHAR.\n         CLI   0(REGI),X'03'            Q   SLASH\n         BNE   SIMPLPAR                 NO SIMPLE PARENTHESIS\n         BAL   REGOX,COB           CHECK IF O/P AREA FILLED\n         MVI   0(EAP),X'08'            YES - MOVE IN SQUARE BRACKET\nLPARDQ63 LA    REGI,1(0,REGI)      INCREASE POINTERS\n         LA    EAP,1(0,EAP)\n         BCR   15,RET              RETURN\nSIMPLPAR CLI   0(REGI),X'2B'           Q IS NEXT CHAR  BLANK\n         BE    LPARDQC3                YES\n         CLI   0(REGI),X'2F'           NO -  Q    ZETA\n         BNE   *+12\n         LA    REGIX,LPARDQC3+4                                    1520\n         BC    15,CIB\n         BAL   REGOX,COB           CHECK IF O/P AREA FILLED\n         MVI   0(EAP),X'06'              MOVE  IN  LEFT  PARENTHESIS\n         B     LPARDQ63+4\n         SPACE 2\n*****   COMMALST ******\n*                   INCREASES THE DIEMSION COUNTER D IF C THE\n*                        PARENTHESIS COUNTER IS 1 FOR ARRAY OR 0 FOR\n*                        SWITCH LIST\n         SPACE 2\nCOMMALST TM    BITS1,X'08'             Q AR BIT = 0\n         BZ    COMMAG3\n         CLC   C(2),KOPOOL+6  Q. C=1\n         BNE   COMMAJ2                  NO\nCOMMAH2  IC    REGZ,D                  INCREASE D-COUNTER\n         LA    REGZ,1(0,REGZ)\n         STC   REGZ,D\nCOMMAJ2  BAL   REGOX,COB           CHECK IF O/P AREA FILLED\n         MVI   0(EAP),X'25'            MOVE COMMA TO OUTPUT\n         LA    EAP,1(0,EAP)            INCREASE POINTERS\n         LA    REGI,1(0,REGI)\n         BCR   15,RET\nCOMMAG3  CLC   C(2),KOPOOL         Q. C=0\n         BE    COMMAH2\n         BC    15,COMMAJ2\n         SPACE 2\n*****   COLONLST ******\n*                   CORRECT ONLY FOR AN ARRAYLIST\n         SPACE 2\nCOLONLST TM    BITS1,X'08'         Q. ARBIT ON\n         BZ    ERROR3              E3 COLON DELETE D\n         BAL   REGOX,COB           CHECK IF O/P AREA FILLED\n         MVI   0(EAP),X'07'            MOVE $ COLON TO O/P\n         LA    EAP,1(0,EAP)\n         LA    REGI,1(0,REGI)          GET NEXT CHAR\n         BCR   15,RET                  AND RETURN\n         SPACE 2\n*****   SEMCLST  ******\n*                   IS ONLY VALID FOR AN SWITCH IN WHITCH CASE\n*                        INDICATES THE END OF THE SWITCH LIST\n*                   THE NUMBER OF COMPONENTS IS INSERTED IN THE\n*                        INTERNAL NAME\n*                   EXIT IS TO ENDLIST\n         SPACE 2\nSEMCLST  TM    BITS1,X'08'                   Q ARBIT=1\n         BO    SEMCLER             YES- ERROR\n*  END OF SWITCH HANDLING\n         CLI   D,X'10'                  Q. MORE THAN 15 COMPONENTS\n         BL    *+14\n         BAL   REGB,ERR2\n         DC    X'0021'             E33\n         B     COMPFIN\n         L     IN,AITL                  INSERT DIMENSION COUNTER\n         SR    REGB,REGB\n         IC    REGB,D\n         SLA   REGB,4(0)                IN LEFTMOST 4 BYTES\n         STC   REGB,D\n         MVZ   9(1,IN),D                IN DECLARATION\n         B     ENDLIST                  GO TO ENDLIST\n         SPACE 2\n*****   SEMCLER  ******\n*                   ENTERED IF A SEMICOLON IS FOUND IN AN ARRAY\n*                        LIST\n*                   GIVES E32, CLEAR THE ITAB ENTRY SETS THE\n*                        ARBIT OFF, DELTABIT ON AND RETURNS TO\n*                        TEST VIA SEMCO\n         SPACE 2\nSEMCLER  BAL   REGB,ERR2\n         DC    X'0020'        E32\n         L     REGY,AITL\n         BAL   REG12,ITABCLEA+8    CLEAR THE ENTRY\n         OI    BITS1,X'20'         DELTABIT ON\n         NI    BITS1,X'F7'         ARRAYBIT OFF\n         B     SEMCO                    RETURN TO SEMCO- WILL RESET RET\n         SPACE 2\n*****   SLASHLST ******\n*                   CHECKS IF NEXT CHARACTER IS A RIGHT PARENTHESIS\n*                        IT IS NOT MOVES OUT A SLASH\n*                   IF IT IS MOVES OUT A RIGHT SQUARE BRACKET\n*                   DECREASES THE PARENTHESIS COUNT\n*                   RETURNS TO LIST IF EITHER AN SWITCH LIST IS\n*                        PROCESSED OR THE PARENTHESIS COUNT NOT IS 0\n         SPACE 2\nSLASHLST LA    REGI,1(0,REGI)              GET NEXT CHAR.\n         CLI   0(REGI),X'26'               Q  LEFT  PARENTHWSIS\n         BNE   SLASHSE                  NO SOMETHING ELSE\n         BAL   REGOX,COB           CHECK IF O/P AREA FILLED\n         MVI   0(EAP),X'28'        TRANSFER A RIGHT SQUARE BRACKET\n         LA    EAP,1(0,EAP)\n         LA    REGI,1(0,REGI)\n         LH    REGB,C\n         BCTR  REGB,0              DECREASE PARENTHESIS COUNT\n         STH   REGB,C\n         TM    BITS1,X'08'               Q ARBIT = 1\n         BC    8,0(0,RET)          NO- RETURN\n         CLC   C(2),KOPOOL         Q. C=0\n         BC    7,0(0,RET)          NO- RETURN\n         SPACE 2\n*****   ARRAY END HANDLING\n*                   INSERT THE DIMENSION COUNTERS IN THE INTERNAL\n*                        NAME OR NAMES IF MORE THAN ONE ARRAY WITH\n*                        THE SAME DIMENSIONS\n*                   IF A COMMA FOLLOWS THE CHARACTERISTICS AND THE PBN\n*                        IS COPIED AND THE NEXT ARRAY NAME IS HANDLED\n*                   IF A SEMICOLON FOLLOWS ENDLIST IS ACTIVATED\n         SPACE 2\n         IC    REGZ,D\n         CLI   D,X'10'             Q. MORE THAN 16 DIMENSIONS\n         BL    *+14\n         BAL   REGB,ERR2\n         DC    X'0021'             EOO\n         B     COMPFIN\n         SLA   REGZ,4                   SHIFT DIMENSION COUNTER\n         STC   REGZ,D\nSLASHREP L     REGB,DIM\n         MVZ   0(1,REGB),D              INSERT DIMENSION COUNTER\n         LA    REGB,11(0,REGB)           INCREASE   DIM POINTER\n         ST    REGB,DIM\n         IC    REGOX,N                   DECREASE\n         BCTR  REGOX,0                  REP.DECLARATION COUNTER\n         STC   REGOX,N\n         CLC   N(1),KOPOOL              Q. IS IT ZERO\n         BNE   SLASHREP                 NO INSERT DIM IN NEXT\n         B     SLASHEND+4               ITAB ENTRY\nSLASHSE  CLI   0(REGI),X'2B'            Q. BLANK\n         BE    SLASHLST\n         CLI   0(REGI),X'2F'            Q. ZETA\n         BNE   *+12\n         LA    REGIX,SLASHLST+4\n         BC    15,CIB\n         BAL   REGOX,COB           CHECK IF O/P AREA FILLED\n         MVI   0(EAP),X'03'              MOVE  IN  A  SLASH\n         LA    EAP,1(0,EAP)\n         BCR   15,RET\nSLASHEND LA    REGI,1(0,REGI)            GET NEXT  CHAR.\n         CLI   0(REGI),X'25'             Q   COMMA\n         BNE   SLSHENSE                 NO SOMETHING ELSE\n         BAL   REGOX,COB           CHECK IF O/P AREA FILLED\n         MVI   0(EAP),X'25'             MOVE IN A COMMA\n         LA    EAP,1(0,EAP)\n         L     REGA,AITL           SAVE AITL\n         BAL   REG12,ITABCLEA      CHECK AND CLEAR NEXT ITABENTRY\n         MVC   6(3,REGY),6(REGA)   COPY ID AND PBN FIELDS\n         B     ARRYNAME            GET NEXT NAME\nSLSHENSE CLI   0(REGI),X'2B'            Q BLANK\n         BE    SLASHEND\n         CLI   0(REGI),X'2F'       Q ZETA\n         BNE   *+12\n         LA    REGIX,SLASHEND+4\n         B     CIB\n         LA    REGB,SLASHERR       RETURN IF NO SEMICOLON FOUND\n         BAL   REG12,FINDSEMC      LOOK FOR SEMICOLON\n         SPACE 2\n*****   ENDLIST  ******\n*                   SETS DELTABIT TO ONE, ARBIT TO ZERO, CLEARS NEXT\n*                        ITABENTRY\n*                   RESETS THE RETUN REGISTER TO TEST\n*                   RETURNS TO TESTLOOP VIA SEMCO\n         SPACE 2\nENDLIST  OI    BITS1,X'20'                 DELTA BIT =1\n         NI    BITS1,X'F7'         ARBIT= 0\n         BAL   REG12,ITABCLEA      CHECK AND CLEAR NEXT ITABENTRY\n         LA    RET,TESTLOOP        RESET RETURN REGISTER TO MAINLOOP\n         B     SEMCO               GO TO SEMICOLONPROGRAM\nSLASHERR BAL   REGB,ERR2\n         DC    X'0022'             E34\n         BAL   REG12,ITABCLEA      CHECK AND CLEA NEXT ITABENTRY\n         B     ARYEXIT+8           CLEAR THE ENTRY IN ITAB AND RETURN\n         SPACE 2\n*****   SWITCH   ******************************************************\n*                   TESTS ON PROBIT (SPECIFICATION) AND BEGBIT\n*                        (PROGRAM BLOCK HEAD)\n*                   INSERTS CHARACTERISTICS AND PBN IN INTERNAL NAME\n*                   INCREASES AND INSERTS LABELNUMBER LN\n*                   MOVES 0A SWITCH TO OUTPUT\n*                   SETS ARBIT TO ZERO\n*                   CHECKS THE NAME FOR VALIDITY AND MOVES FIRST 6\n*                        CHARACTERS TO OUTPUT AND ITAB VIA IDCHECK\n*                   SEARCHES FOR ASSIGN TO FOLLOW THE SWITCHNAME\n*                   INITILIZES C PARENTHESIS COUNT AND D DIMENSION\n*                        COUNT WITH ZERO AND N WITH ONE\n*                   EXITS TO LIST\n         SPACE 2\nSWITCH   TM    BITS1,X'40'             Q PROCEDURE HEAD\n         BO    SPECENT                 YES\n         TM    BITS1,X'80'             Q BLOCK START\n         BZ    *+16\n         ST    REGX,SAVE1\n         BAL   REGX,BEG1                YES- PROCESS BLOCKBEGIN\n         L     REGX,SAVE1\n         L     REGY,AITL                MOVE IN ID FIELDS\n         MVI   6(REGY),X'CC'\n         MVI   7(REGY),X'0C'\n         L     REGOX,LPBP\n         MVC   8(1,REGY),10(REGOX)      AND PBN- NUMBER\n         LH    REGOX,LN                IN CREASE LABELNUMBER\n         LA    REGOX,4(0,REGOX)\n         CLC   LN(2),FOURKA             Q. LN OVERFLOW\n         BL    *+14\n         BAL   REGB,ERR7\n         DC    X'04D8'        E216\n         LA    REGOX,LATBEG        RESET LN\n         STH   REGOX,LN\n         MVC   9(2,REGY),LN             MOVE IN LABEL NUMBER\n         BAL   REGOX,COB           CHECK IF O/P AREA FILLED\n         MVI   0(EAP),X'0A'            MOVE IN $ SWITCH\n         LA    EAP,1(0,EAP)\n         NI    BITS1,X'F7'         SET ARBIT TO ZERO\nSWTCHB3  LA    REGI,1(0,REGI)      GET FIRST CHAR.\n         CLI   0(REGI),X'39'           Q IS IT A LETTER\n         BL    SWTCHNSE                 NO\n         BAL   REGB,IDCHECK1  INIILIZ N WITH ONE\nSWITCHSE CLI   0(REGI),X'2B'           Q IS CHAR A BLANK\n         BE    IDCHECK2\n         CLI   0(REGI),X'07'       Q COLON\n         BE    SWCOLON\n         CLI   0(REGI),X'2D'       Q. POINT\n         BNE   SWITCHER\nSWPOINT  LA    REGI,1(0,REGI)      ONE POINT HAS BEEN FOUND\n         CLI   0(REGI),X'2D'       Q. ONE MORE POINT\n         BE    SWCOLON\n         CLI   0(REGI),X'10'       Q. EQUALSIGN  E.G.  .=\n         BE    EQUALOK\n         CLI   0(REGI),X'2B'       Q. BLANK\n         BE    SWPOINT\n         CLI   0(REGI),X'2F'       Q.ZETA\n         BNE   SWITCHER\n         LA    REGIX,SWPOINT+4\n         B     CIB\nSWCOLON  LA    REGI,1(0,REGI)      NOW A COLON OR TWO POINTS ARE FOUND\n         CLI   0(REGI),X'10'       Q EQUALSIGN\n         BE    EQUALOK             IF YES '= OR  .= OR ..= ARE FOUND\n         CLI   0(REGI),X'2B'       Q BLANK\n         BE    SWCOLON\n         CLI   0(REGI),X'2F'       Q  ZETA\n         BNE   SWITCHER\n         LA    REGIX,SWCOLON+4\n         B     CIB\nEQUALOK  BAL   REGOX,COB           CHECK IF O/P AREA FILLED\n         MVI   0(EAP),X'16'            MOVE IN $ EQUALSIGN\n         LA    EAP,1(0,EAP)            INCREASE O/P POINTER\n         SR    REGB,REGB\n         STH   REGB,C                   C=0                        1514\n         MVI   N,X'01'                  N=1\n         STC   REGB,D                   D=0\n         LA    REGI,1(0,REGI)          GET NEXT CHAR\n         B     LIST                     GO TO PROCESS LIST\nSWTCHNSE CLI   0(REGI),X'2B'       Q. BLANK\n         BE    SWTCHB3\n         CLI   0(REGI),X'2F'       Q. ZETA\n         BNE   *+12\n         LA    REGIX,SWTCHB3+4\n         B     CIB\n         BAL   REGB,ERR7\n         DC    X'0405'             E5\n         B     SWITCHER+18\nSWITCHER BAL   REGB,ERR2\n         DC    X'0010'             E16\n         BAL   REGOX,COB\n         MVI   0(EAP),X'3D'        MOVE IN RHA\n         LA    EAP,1(0,EAP)\n         L     REGB,AITL               CLEAR ITAB-ENTRY\n         MVI   0(REGB),X'00'\n         MVC   1(10,REGB),0(REGB)\n         BC    15,COMERR               COM-PRGM ERROR-ENTRY\n         SPACE 2\n*****   STRING   ******************************************************\n*                   MOVES INTERNAL NAME TO OUTPUT\n*                   THE STRING IS TAKEN FROM THE PRINTAREA (OR DUMMY)\n*                        AND MOVED TO KOPOOL, START ADDRESS IS IN\n*                        SPCLT\n*                   THE STRINGS TWO FIRST BYTES SPECIFIES ITS LENGTH\n*                   THE TRT TESTS ONLY FOR APOSTROPHE AND ZETA\n         SPACE 2\nSTRING   LA    REG0,6(0,EAP)       PROVIDE 6 BYTES IN O/P\n         BAL   REGOX,COBSPEC\n         MVC   0(4,EAP),SINT       MOVE FIRST 4 BYTES OF INTERNAL NAME\n         MVC   4(2,EAP),SPCLT+2         AND LAST TWO BYTES IN O/P\n         LA    EAP,6(0,EAP)\n         L     REGL,SPCLT          GET CURRENT DISP WITHIN KOPOOL\n         LA    REGL,2(0,REGL)      INCREASE FOR LENGTH SPECIFICATION\n         C     REGL,FOURK          Q  STRINGPOOL  OVERFLOW\n         BNH   *+8\n         BAL   REGOX,E23\n         LA    REGI,1(0,REGI)\n         MVC   SQC(4),KOPOOL+4     STRINQUOTE=1\nCDE2     LA    REGIX,*             PROVIDE RETURNADDRESS FOR CIB\n         LR    REGM,REGI\n         SR    REGZ,REGZ\n         TRT   0(73,REGI),STRTABLE SCAN STRING\n         LR    REGN,REGI           COMPUTE NUMBER OF SCANNED BYTES\n         SR    REGN,REGM\n         BZ    SROUT\n         LA    REG0,0(REGN,REGL)   Q. STRINGPOOL OVERFLOW\n         C     REG0,FOURK\n         BNH   *+8\n         BAL   REGOX,E23\n         BCTR  REGN,0              MOVE SCANNED BYTES TO KOPOOL\n         L     REGB,AKOPOOL\n         LA    REGY,0(REGB,REGL)  COMPUTE NEW KOPOOL ADDRESS\n         LA    REG0,WA             COMPUTE ADDRESS\n         LR    REG12,REGM          OF STRING IN\n         SR    REG12,REG0          PRINTBUFFER\n         L     REGB,APRNTAR\n         LA    REG12,8(REGB,REG12) GET STRING FROM PRINTBUFFER\n         EX    REGN,MV1\n         LA    REGL,1(REGN,REGL)   INCREASE SPCLT\nSROUT    L     REG12,BPRTAB(REGZ)  BRANCH TO APPROPRIATE\n         BCR   15,REG12            SUBROUTINE\n         SPACE 2\n*****   QUOTE   *****\n*                   CHECKS IF THE APOSTROPHE IS THE START OF A QUOTE\n*                        SIGN\n*                   USES REPL TO MOVE THE FOUND CHARACTER(S) TO\n*                        KOPOOL. REPL+1 WILL BE A LEFT OR RIGHT\n*                        PARENTHESIS\n*                   HOW MUCH OF REPL THAT IS TO BE MOVED TO KOPOOL\n*                        IS KEPT TRACK OF IN REGN\n*                   IF A COMPLETE LEFT STRING QUOTE IS FOUND THE\n*                        STRING QUOTE COUNTER IS INCREASED AND THE\n*                        REPL MOVED TO KOPOOL\n*                   IF A COMPLETE RIGHT STRING QUOTE IS FOUND IT IS\n*                        CHECKED IF IT IS THE CLOSING ONE FOR THE\n*                        STRING (SQC=0) IF IT IS ENDSTRING IS ACTIVATED\n*                        IF NOT REPL IS MOVED TO KOPOOL AFTER\n*                        SQC IS DECREASED\n*                   IF NO COMPLETE QUOTE IS FOUND THE CHARACTER(S)\n*                        FOUND ARE MOVED TO KOPOOL FROM REPL, LENGTH\n*                        SPECIFIED BY REGN AND THE SCANNING OF\n*                        THE STRING IS REASSUMED\n         SPACE 2\nQUOTE    LA    REGI,1(0,REGI)\n         LA    REGIX,*+4\n         CLI   0(REGI),X'26'       Q RIGHT PARENTHESIS IN SOURCE\n         BNE   NORIP\n         MVI   REPL+1,C')'         MAKE REPL A RIGHT STRING QUOTE\n         B     TESTAPOS            LOOK FOR APOSTROPHE\nNORIP    CLI   0(REGI),X'06'       Q. LEFT PARENTHESIS\n         BNE   TESTZETA            NO\n         MVI   REPL+1,C'('         MAKE REPL A LEFT STRING QUOTE\n         B     TESTAPOS            LOOK FOR APOSTROPHE\nTESTZETA CLI   0(REGI),X'2F'       Q.ZETA\n         BE    CIB                 YES\n         LA    REGN,1              NO MOVE TO STRING ONLY FIRST APOST .\n         B     CID1                MOVE REPL\nTESTAPOS LA    REGI,1(0,REGI)\n         LA    REGIX,*+4           NEW RETURN FOR CIB\n         CLI   0(REGI),X'2E'       Q. SECOND APOSTROPHE\n         BE    CID                 YES\n         CLI   0(REGI),X'2F'       ZETA\n         BE    CIB                 YES\n         LA    REGN,2              NO MOVE TO STRING ONLY THE FIRST\n         B     CID1                APOSTROPHE AND THE PARENTHESIS\nCID      LA    REGI,1(0,REGI)\n         L     REGOX,SQC\n         CLI   REPL+1,X'4D'        Q. LEFT STRING QUOTE\n         BNE   *+12                NO\n         LA    REGOX,1(0,REGOX)    YES- INCREASE STRING QUOTE COUNT\n         B     *+12\n         S     REGOX,KOPOOL+4      RIGHT QUOTE- DECREASE QUOTE COUNT\n         BC    13,ENDSTRIN         BRANCH IF LAST QUOTE\n         ST    REGOX,SQC\n         LA    REGN,3\nCID1     LA    REG0,0(REGN,REGL)\n         C     REG0,FOURK          Q STRINGPOOL OVERFLOW\n         BNH   *+8\n         BAL   REGOX,E23\n         L     REGB,AKOPOOL\n         LA    REGB,0(REGB,REGL)   COMPUTE NEW KOPOOL ADDRESS\n         BCTR  REGN,0\n         EX    REGN,MV2            MOVE CONTENTS OF REPL TO KOPOOL\n         LA    REGL,1(REGN,REGL)   INCREASE SPCLT\n         BC    15,CDE2                  RESUME SCAN OF STRING\n         SPACE 2\n*****   ENDSTRIN *****\n*                   INCREASES SPCLT\n*                   PUTS THE LENGTH OF THE STRING (DIFFERENCE BETWEEN\n*                        NEW AND OLD SPCLT) AS TWO FIRST BYTES IN THE\n*                        STRING\n         SPACE 2\nENDSTRIN L     REG9,SPCLT          COMPUTE LENGTH AND PUT IT\n         STH   REGL,SPCLT+2        AS THE FIRST 2 BYTES IN STRING\n         L     REGB,AKOPOOL        AND\n         LA    REGOX,0(REGB,REG9)   STORE NEW DISPLACEMENT\n         SR    REGL,REG9                IN  SPCLT\n         STH   REGL,LENSTRIG\n         MVC   0(2,REGOX),LENSTRIG\n         BCR   15,RET              RETURN TO TESTLOOP\nE23      BC    0,*+10                   NO BRANCH FIRST TIME       0208\n         BAL   REGB,ERR7                RECORD ERROR               0208\n         DC    X'0417'             E23\n         OI    E23+1,X'F0'              NO ERROR RECORDING NEXT    0208\n         LA    REGL,64\n         ST    REGL,SPCLT          RESETSPCLT TO 64 AGAIN\n         BCR   15,REGOX            RESUME STRING PROCESSING\n         CNOP  0,4\nMV1      MVC   0(1,REGY),0(REG12)\nLENSTRIG DS    H                        MUST NOT BE MOVED\nMV2      MVC   0(1,REGB),REPL\nSQC      DC    F'0'                STRINGQOUTECOUNTER  (AFTER MV2\nSINT     DC    X'2EC90000'             STRING INTERNAL NAME\n*                             OF THE CONSTANT POOL NAMED KOPOOL\nREPL     DC    C''' '''                 BUCKET TO BUILD STRING QUOTES\n         SPACE 2\n*****   TYPPROC  ******************************************************\n*                   TEST PRO AND BEGBIT (FORMAL PARAMETER, BLOCKSTART)\n*                   MOVE PHI TO OUTPUT\n*                   INSERT CHARACTERISTICS IN INTERNAL NAME\n*                   JOIN PROCEDURE PROGRAM\n         SPACE 2\nTYPPROC  TM    BITS1,X'40'           QPROCEDURE PROCEDED\n         BZ    *+16                  NO\n         MVI   KB,X'CA'            YES-MOVE IN IDFIELD\n         OI    KB+1,X'C0'\n         BC    15,IDCHECK\n         TM    BITS1,X'80'         Q. BEGBIT ON\n         BZ    *+16                NO\n         ST    REGX,SAVE1\n         BAL   REGX,BEG1           GO TO PROCESS PROGRAM BLOCK HEAD\n         L     REGX,SAVE1\n         LA    REG0,4(0,EAP)      PROVIDE FOUR BYTES IN OUTPUT\n         BAL   REGOX,COBSPEC       CHECK IF ENOUGH SPACE IN O/P\n         MVI   0(EAP),X'0F'        MOVE PHI TO O/P\n         L     REGY,AITL\n         XI    7(REGY),X'F0'            MOVE IN THE IDCODE\n         MVI   6(REGY),X'CA'            TO ITAB\n         B     PROCEAG1            JOIN THE PROCEDUR PROGRAM\n         SPACE 2\n*****   PROCEDURE *****************************************************\n*                   TEST PRO AND BEGBIT\n*                   MOVE PI TO OUTPUT\n*                   INSERT CHARACTERISTICS IN INTERNAL NAME\n*                   TYPEPROCEDURE JOINS PROCEDURE PROGRAM AT THIS POINT\n*                   IF ALPHA IN STACK, PRECOMPILED PROCEDURE,\n*                        THE STARTBIT IS TURNED ON\n*                   PROC IS PUT IN STACK\n*                   PROGRAM BLOCK AND ITAB GROUP NUMBER ARE INCREASED\n*                        THE NEW PBN IS INSERTED IN THE INTERNAL NAME\n*                   LABELNUMBER IS INCREASED AND INSERTED IN THE\n*                        INTERNAL NAME\n*                   THE SURRONDING BLOCKNUMBET IS ENTERED IN PBTAB1\n*                   THE SURROUNDING ITABGROUP NUMBER IN GROUPTABLE\n*                   THE SC IS ENTERED IN SCTAB\n*                   PROBIT AND IDBIT ARE SET TO ONE\n*                   PROBIT WILL STAY AS ONE TILL THE WHOLE PROCEDURE\n*                        HEAD IS PROCESSED. THE IDBIT IS ONLY ONE\n*                        WHILE THE PROCEDURE NAME IS PROCESSED\n*                   THE FM (FORMAL PARAMETER)BIT IS ONE WHEN THE\n*                        FORMAL PARAMETER LIST IS PROCESSED\n*                   THE ITABGROUP NUMBER IS MOVED TO O/P\n         SPACE 2\nPROCEDUR TM    BITS1,X'40'         IF PROBIT IS ONE\n         BO    SPECENT             GOTO IDCHECK VIA SPECENT\n         TM    BITS1,X'80'         Q. BEGBIT ON\n         BZ    *+16                NO\n         ST    REGX,SAVE1\n         BAL   REGX,BEG1      GO TO PROCESS PROGRAMBLOCKHEAD\n         L     REGX,SAVE1\n         LA    REG0,4(0,EAP)      PROVIDE FOUR BYTES IN OUTPUT\n         BAL   REGOX,COBSPEC\n         MVI   0(EAP),X'0E'        TRANSFER PI IN OUTPUTBUFFER\n         L     REGY,AITL\n         MVI   6(REGY),X'CA'       CONSTRUCT FIRST PART\n         MVI   7(REGY),X'C0'       OF INTERNAL NAME\nPROCEAG1 L     REGL,SP\n         CLI   0(REGL),X'00'       Q ALPHA IN STACK\n         BNE   L3\n         OI    BITS2,X'20'         TURN ON THE STARTBIT\n         OI    BITS3,PROCESD\nL3       LA    REGL,1(0,REGL)      INCREASE STACKPOINTER\n         C     REGL,ATOPSTAK       Q STACKOVERFLOW\n         BL    *+10\n         BAL   REGB,ERR4\n         DC    X'0414'             E20\n         MVI   0(REGL),X'0C'       PUT PROC IN STACK\n         ST    REGL,SP\n         CLI   PBC,X'FF'           Q.PBN OVERFLOW\n         BNE   *+10                NO\n         BAL   REGB,ERR4\n         DC    X'0416'             E22\n         IC    REGZ,PBC\n         LA    REGZ,1(0,REGZ)      INCREASE PROGRAMBLOCKNUMBER\n         STC   REGZ,8(0,REGY)      INSERT PBN IN INTERVAL NAME\n         STC   REGZ,PBC\n         LA    REGL,PBTAB1(REGZ)   CONSTRUCTION\n         L     REGB,LPBP           PBTAB1-ENTRY\n         MVC   0(1,REGL),10(REGB)\n         AR    REGZ,REGZ\n         LA    REGL,SCTAB(REGZ)\n         MVC   0(2,REGL),SC        MAKE ENTRY IN SCTAB\n         LH    REGL,LN             INCREASE\n         LA    REGL,4(0,REGL)      LABELNUMBER BY 4\n         CLC   LN(2),FOURKA        Q. LNOVERFLOW\n         BL    *+14\n         BAL   REGB,ERR7\n         DC    X'04D8'        E216\n         LA    REGL,LATBEG         RESET LN\n         STH   REGL,LN\n         L     REGY,AITL\n         MVC   9(2,REGY),LN        PUT LN IN INTERNAL NAME\n         LH    REGY,IGC            INCREASE\n         LA    REGY,1(0,REGY)      ITABGROUPNUMBER\n         STH   REGY,IGC\n         MVC   1(2,EAP),IGC        INSERT IT IN OUTPUT BUFFER\n         LA    EAP,3(0,EAP)\n         AR    REGY,REGY\n         AH    REGY,IGC\n         A     REGY,AGT\n         L     REG7,LIGP\n         MVC   0(2,REGY),8(REG7)   CONSTRACT ENTRY\n         MVI   2(REGY),X'00'       IN   GROUPTABEL\n         NI    0(REGY),X'7F'       CLEAR POSSIBLE PHI IND.\n         MVC   PRIMPAR(4),KOPOOL   CLEARPRIMPAR WITH ZEROS\n         OI    BITS1,X'50'         PROBIT =1,IDBIT =1\n         MVI   PZ,X'00'       SET PARAMTER COUNT TO ZERO\n         SPACE 2\n*****   PROCID   *****\n*                   PROCESSES PROCEDURE NAME (IDBIT=1)\n*                        AND THE FORMAL PARAMETER LIST (IDBIT=0)\n*                   CHECKS THE NAMES FOR VALIDITY AND MOVES THEM\n*                        TO ITAB AND OUTPUT\n*                        THIS IS DONE VIA IDCHECK1\n         SPACE 2\nPROCID   LA    REGI,1(0,REGI)\n         CLI   0(REGI),X'40'            Q IDENTIFIER STARTS WITH LETTER\n         BL    NOLETTER\n         BAL   REGB,IDCHECK1  CHECK AND MOVE IDENTIFIER TO O/P AND ITAB\n         CLI   0(REGI),X'2B'       Q BLANK\n         BE    IDCHECK2\n         TM    BITS1,X'10'         Q IDBIT ONE\n         BZ    EDA1                GOTO PROCESS FORMAL PARAMETER NAME\n         SPACE 2\n*****   PROCEDURE NAME  *****\n*                   CHECKS IF NAME IS FOLLOWED BY (A FORMAL PARAMETER\n*                        LIST FOLLOWS OR ., NO PARAMETERS\n*                   CHECKS IF PROCEDURE IS TO BE PRECOMPILED, IF YES\n*                       THE NAME IN EXTERNAL FORM AND EXPANDED WITH\n*                        TWO ZEROS IS PUT FOR AN ESDCARD IF SYLIN OR\n*                        DECK HAS BEEN SPECIFIED\n*                   THE NEW BLOCK ENTRY IS DONE IN ITAB\n*                        ADD, OF SURROUNDIN BLOCK AND ITAB GROUP, PBN\n*                             AND IGN ARE INSERTED\n*                       IF TYPEPROCEDURE, BIT 0 IN BYTE 8 IS\n*                        TURNED ON AND A SECOND ENTRY OF THE NAME\n*                        IS DONE AFTER THE HEAD ENTRY\n*                   IDBIT IS SET TO ZERO, FMBIT TO ONE\n*                   IF THE NAME WAS FOLLOWED BY A SEMICOLON THE\n*                   SEMCO IS ACTIUATED\n*                   IF THE NAME WAS FOLLOWED BY A(PROCID IS\n*                        ACTIVATED TO PROCESS THE NAME IN THE LIST\n         SPACE 2\n         CLI   0(REGI),X'06'       Q IDENTIFIER FOLLOWED BY )\n         BE    EBF4\n         LA    REGB,ERROR16             RETURN IF NOT SEMICOLON\n         BAL   REG12,FINDSEMC           Q SEMICOLON\n         OI    BITS1,X'20'          YES DELTABIT = 1\nEBF4     TM    BITS3,PROCESD\n         BZ    DEL1                NO\n         NI    BITS3,PROCOFF\n         TM    HCOMPMOD+1,X'60' Q. DECK AND OR LOAD SPECIFIED\n         BO    DEL1                 NO- NO NEED FOR ESDCARD\n         L     REGY,AITL\n         LA    REGB,ESDPARAM\n         MVC   0(6,REGB),0(REGY)   MOVE IN AND TRANSLATE EXTERNAL NAME\n         TR    0(6,REGB),RETRANS\nDEL1     TM    BITS1,X'20'         Q DELTABIT = 1\n         BO    ECA3\n         BAL   REGOX,COB           CHECK IF O/P AREA FILLED\n         MVI   0(EAP),X'06'        INSERT )\n         LA    EAP,1(0,EAP)\nECA3     BAL   REG12,ITABCLEA\n         MVC   0(4,REGY),LIGP      MOVE ADDRESS HEADINGENTRY OF EMBRAC\n         MVC   4(4,REGY),LPBP      ING ITABGROUP AND PBLOCK TO ENTRY\n         MVC   8(2,REGY),IGC            INSERT CURRENT IGN\n         MVC   10(1,REGY),PBC      AND CURRENT PBN\n         ST    REGY,LIGP           NEW VALUE OF LIGP\n         ST    REGY,LPBP           AND LPBP\n         S     REGY,KOPOOL+44      DECREASE REGY BY 11\n         TM    7(REGY),X'03'       Q TYPEPROCEDURE\n         BC    5,TPROHEAD\n         LA    REGY,22(0,REGY)     IF NO INCREASE ITABPOINTER\nECJ3     BAL   REG12,ITABCLEA+8\n         OI    BITS3,FMBIT         FMBIT\n         TM    BITS1,X'20'         Q DELTABIT = 1\n         BO    SEMCO               IF YES BRANCH TO SEMICOLONPROGRAM\n         NI    BITS1,X'EF'         IDBIT'= 0\n         BC    15,PROCID           CHECK NEXT IDENTIFIER\n*                CONSTRUCT TYPE PROCEDURE ENTRIES\nTPROHEAD OI    19(REGY),X'80'           FLAGBIT IN IGN IS SET ON\n         LA    REG0,22(0,REGY)     Q ONE MORE ENTRY IN ITAB AVAILABLE\n         C     REG0,ELI\n         BNE   *+10\n         BAL   REGB,ERR4\n         DC    X'04D5'             E213\n         MVC   22(11,REGY),0(REGY) ENTER PROCEDURE NAME ONCE MORE\n         XI    28(REGY),X'08'      NO-ASSIGNMENTBIT IS SWITCHED OFF\n         LA    REGY,33(0,REGY)     INCREASE ITABPOINTER\n         BC    15,ECJ3             BRANCH BACK TO MAINPROGRAM\nNOLETTER CLI   0(REGI),X'2B'            Q BLANK INSTEAD OF LETTER\n         BE    PROCID\n         LA    REGIX,PROCID+4\n         CLI   0(REGI),X'2F'            Q ZETA\n         BE    CIB                 CHANGE INPUTBUFFER\n         TM    BITS1,X'10'\n         BO    PNAMERR-10\n         LA    REGH,PROCID         LOAD RETURN ADDRESS\n         B     IERSPEC             BRANCH TO IDENTIFIER ERROR ROUTINE\nERROR16  BAL   REGOX,COB\n         MVI   0(EAP),X'3D'        MOVE IN RHA\n         LA    EAP,1(0,EAP)\n         TM    BITS1,X'10'         Q. PROC NAME UNDER PROCESS\n         BO    PNAMERR             YES\n         LA    REGH,PROCID         LOAD RETURN ADDRESS\n         B     IER                 GO TO IDENTIFIER ERROR ROUTINE\n         BAL   REGB,ERR7\n         DC    X'0405'             E5\n         B     *+10\nPNAMERR  BAL   REGB,ERR2\n         DC    X'0010'             E16\n         L     IN,AITL\n         MVI   0(IN),X'00'       CLEAR ERRONEOUS NAME\n         MVC   1(5,IN),0(IN)\n         LA    REGB,PROCIDSE       THE PROCEDURE HEAD SHOULD\n         BAL   REGOX,FINDSEMC\n         B     EBF4-4              BE FOLLOWED BY EITHER  ( OR .,\nPROCIDSE CLI   0(REGI),X'06'       KEEP LOOPING UNTIL ONE OF TWO FOUND\n         BE    EBF4                LEFT PARENTHESIS FOUND\n         BAL   REGOX,FINDSEMC-4\n         B     EBF4-4              SEMICOLON FOUND\n         SPACE 2\n*****   FORMAL PARAMETER LIST *****\n*                   IF A COMMA TERMINATES THE NAME, THE COMMA IS\n*                        TRANSFERED TO OUTPUT AND THE PARAMETER COUNT\n*                        (PZ) IS INCREASED BY ONE\n*                        AND PROCID IS ACTIVATED AGAIN TO TAKE NEXT\n*                        NAME\n*                   IF A ) FOLLOWED BY A SEMICOLON TERMINATES THE NAME\n*                        PROCFIN IS ACTIVATED\n*                   IF A ) BUT NO SEMICOLON TERMINATES THE NAME\n*                        PROCDEL IS ACTIVATED\n*                   IS SOMETHING ELSE IS FOUND RHA IS MOVED TO OUTPUT,\n*                        THE PARAMETER COUNT IS NOT INCREASED AND IER\n*                        ACTIVATED (NOLETTER, ERROR16)\n         SPACE 2\nEDA1     CLI   0(REGI),X'25'       Q COMMA TERMINATES IDENTIFIER\n         BNE   PAR\nPROCEND  IC    REGZ,PZ             INCREASE\n         LA    REGZ,1(0,REGZ)      PARAMETER\n         STC   REGZ,PZ             COUNT BY ONE\n         BAL   REG12,ITABCLEA      CHECK AND CLEAR NEXT ITABENTRY\n         BAL   REGOX,COB           CHECK IF O/P AREA FILLED\n         CLI   0(REGI),X'25'       Q COMMA\n         BNE   PROCFIN\n         MVI   0(EAP),X'25'        MOVE COMMA TO OUTPUTBUFFER\n         LA    EAP,1(0,EAP)        INCREASE OUTPUTPOINTER\n         BC    15,PROCID           BRANCK TO CHECK THE NEXT IDENTIFIER\nPAR      CLI   0(REGI),X'26'       Q ( TERMINATES IDENTIFIER\n         BE    PROCEND\n         BAL   REGOX,COB\n         MVI   0(EAP),X'3D'        MOVE IN RHA\n         LA    EAP,1(0,EAP)\n         LA    REGH,PROCID              NOTE RETURN ADDRESS AND BRANCH\n         BC    15,IER              TO IER\n         SPACE 2\n*****   PROCFIN  *****\n*                   THE PARAMERER LIST HAS BEEN COMPLETLY CHECKED\n*                        THE RIGHT PARENTHESIS IS MOVED TO OUTPUT\n*                        DELTABIT IS SET TO ONE\n*                   THE PARENTHESIS COUNT IS INSERTED IN THE\n*                        PROCEDURE NAME (NAMES IF TYPEPROCEDURE)\n*                   FMBIT IS TURNED OFF\n*                   THE RETURN TO TEST IS VIA SEMCO\n*                   IF SOMETHING ELSE, E5 OR E16 IS GENERATED AND\n*                        EVERYTHING SKIPPED TILL A (OR A., IS\n*                        FOUND (NOLETTER, PNAMERR)\n         SPACE 2\nPROCFIN  LA    REGI,1(0,REGI)\n         LA    REGB,PROCDEL        RETURN IF NO SEMICOLON\n         BAL   REG12,FINDSEMC           Q SEMICOLON\n         BAL   REGOX,COB\n         LA    REGL,SEMCO          EXIT FROM PROCEDUR\nSCYES3   MVI   0(EAP),X'26'        MOVE RIGHT PARENTHESIS\n         LA    EAP,1(0,EAP)\n         OI    BITS1,X'20'         DELTABIT'=1\n         CLI   PZ,X'10'       Q.MORE THAN 15 PARAMETERS\n         BL    *+14\n         BAL   REGB,ERR2B\n         DC    X'0024'             E36\n         B     COMPFIN\n         L     REGY,LPBP\n         S     REGY,KOPOOL+44      REGY CONTAINS ADDRESS OF PROC ENTRY\n         SR    REGB,REGB\n         IC    REGB,PZ\n         SLA   REGB,4(0)\n         STC   REGB,PZ\n         MVZ   9(1,REGY),PZ        INSERT NUMBER OF PARAMETERS INTO\n*                                  INTERNAL NAME OF THE PROCEDURE\n         SRA   REGB,4(0)\n         STC   REGB,PZ             NOTE NUMBER OF PARAMETER\n         NI    BITS3,FMOFF         FMBIT=0\n         TM    19(REGY),X'80'      Q TYPE PROCEDURE\n         BZ    TESTPAR             NO\n         MVZ   31(1,REGY),9(REGY)  INSERT NUMBER OF PARAMETERS INTO\n*                                  SECOND NAME-ENTRY IN ITAB\n         LA    REGY,33(0,REGY)     GET ADDRESS OF FIRST PARAMETER\n         B     *+8\nTESTPAR  LA    REGY,22(0,REGY)\n         CLI   PZ,X'00'            Q. IS THERE ANY PARAMETERS\n         BCR   8,REGL              NO BRANCH TO SEMCO OR COMERR\n         ST    REGY,PRIMPAR        YES- SAVE ADDRESS OF FIRST\n         BCR   15,REGL             B TO SEMCO OR COMERR\n         SPACE 2\n*****   PROCDEL  *****\n*                   A RIGHT PARENTHESIS HAS BEEN FOUND IN THE LIST\n*                        THAT NOT WAS FOLLOWED BY A .,\n*                   IF A LETTERSTRING IS FOUND, NOTHING BUT LETTERS\n*                        AND BLANKS FOLLOWED BY ..(A COMMA IS MOVED\n*                        TO OUTPUT AND PROCID ACTIVATED TO TAKE\n*                        NEXT NAME\n*                   IF ANYTHING ELSE IS FOUND E37 IS GENERATED\n*                        AND COMERR ACTIVATED TO SKIP TO NEXT\n*                        SEMICOLON\n*                   ADDRESS OF COMERR IS PUT IN REGL\n         SPACE 2\nPROCDEL  LA    REGIX,DELCHECK+4\nDELCHECK LA    REGI,1(0,REGI)\n         CLI   0(REGI),X'40'       Q. LETTER\n         BNL   DELCHECK\n         CLI   0(REGI),X'2F'       Q. ZETA\n         BE    CIB\n         CLI   0(REGI),X'07'       Q. COLON\n         BE    DELCOLON\n         CLI   0(REGI),X'2B'\n         BE    DELCHECK\n         CLI   0(REGI),X'2D'       Q. POINT\n         BNE   ERROR37\nDELPOINT LA    REGI,1(0,REGI)\n         CLI   0(REGI),X'2D'       Q. ONE MORE POINT\n         BE    DELCOLON\n         CLI   0(REGI),X'2B'\n         BE    DELPOINT\n         CLI   0(REGI),X'2F'       Q  ZETA\n         BNE   ERROR37\n         LA    REGIX,DELPOINT+4\n         B     CIB\nDELCOLON LA    REGI,1(0,REGI)\n         CLI   0(REGI),X'06'       Q LEFT PARENTHESIS\n         BE    DELPAREN\n         CLI   0(REGI),X'2B'       Q. BLANK\n         BE    DELCOLON\n         CLI   0(REGI),X'2F'       Q. ZETA\n         BNE   *+12\n         LA    REGIX,DELCOLON+4\n         B     CIB\n         BCTR  REGI,0              NO PARENTHESIS FOLLOWS THE COLON\n         B     ERROR37             RESET REGI AND GO TO ERROR 37\nDELPAREN BAL   REGOX,COB\n         MVI   0(EAP),X'25'        MOVE COMMA TO OUTPUT INSTEAD OF\n         LA    EAP,1(0,EAP)        DELIMITER INCREASE  O/P POINTER\n         B     PROCID              RETURN TO  PROCEDURE  CHECKING\nERROR37  BAL   REGB,ERR2B\n         DC    X'0025'             E37\n         LA    REGL,COMERR\n         B     SCYES3\n         SPACE 2\n*****   ENDMISS  ******************************************************\n*                   ENTERED VIA OS IF END OF DATA SENSED BEFORE\n*                   LOGICAL PROGRAM END IS FOUND BY SCAN I/II\n*                   CLOSES WHAT REMAINS OPEN IN STACK\n*                   GENERATES PATTERN FOR ERR. MESS. 39.\n         SPACE 2\nENDMISS  TM    BITS2,STARTBIT           Q. FIRST BEGIN FOUND\n         BO *+10                        YES\n         BAL   REGB,ERR4\n         DC    X'042C'             E44 NOTHING PROCESSED\n         OI    BITS1,TERBIT\nTERMSEAC LA    REGE,TERMSEAC            RETURN FOR PBLCKEND PROG.\n         L     REGY,SP             GET STACKPOINTER\n         CLI   0(REGY),X'04'            Q.BETA IN STACK\n         BE    STEPUP\n         CLI   0(REGY),X'08'            Q.BEGIN\n         BE    STEPUP\n         CLI   0(REGY),X'10'            Q. PROC*\n         BNE   TERMBRNC\nSTEPUP   LH    REGB,ENDCOUNT            INCREASE ENDCOUNT\n         LA    REGB,1(0,REGB)\n         STH   REGB,ENDCOUNT\nTERMBRNC IC    REGZ,0(0,REGY)\n         L     REGB,TERMTAB(REGZ)       BRANCH ACORDING TO STACKBYTE\n         BCR   15,REGB\n         CNOP  0,4\nTERMTAB  DC    A(ERROR39)\n         DC    A(PBLCKEND)              BEGIN\n         DC    A(TERMBGN)               BETA\n         DC    A(PBLCKEND)              PROC\n         DC    A(PBLCKEND)              PROC*\n         DC    A(PBLCKEND)              PROC**\n         DC    A(FOREND)                FOR\nTERMBGN  BAL   REGOX,COB\n         MVI   0(EAP),X'2C'             MOVE OUT END TO O/P\n         LA    EAP,1(0,EAP)\n         L     REGY,SP\n         BCTR  REGY,0                   RELEASE BEGIN IN STACK\n         ST    REGY,SP\n         B     TERMSEAC\n         SPACE 2\n*****   SLUT2    ******************************************************\n*                   INTERED FROM IEX00 IF INTERUPT OCCURS BEFORE\n*                   GETMAIN\n         SPACE 2\nSLUT2    OI    BITS3,NOFREE        INTERUPT OCCURED PRIOR TO GETMAIN\n         L     REG11,VIEX14\n         USING IEX11003,11\n         B     SCANEND                  GO TO PROCESS TERMINATING PART\n         USING IEX11002,11\n         SPACE 2\n*****   READROUT ******************************************************\n*                   ENTERED AFTER FINAL ENDCOMMENT HAS BEEN CHECKED\n*                   SHOULD EXIT TO EODADIN VIA OS EOD ROUTINE\n         SPACE 2\nREADROUT LA    REGI,1(0,REGI)\n         LA    REGIX,*+4\n         TRT   0(73,REGI),BTABLE        ONLY VALID CHARACTER AFTER\n         CLI   0(REGI),X'2F'            FINAL END COMMENT IS ZETA\n         BE    CIB\n         B     ERR9                     ANYTHING ELSE FOUND\nE39PAR   DC    X'0727'             E39\nERROR39  LA    REGB,E39PAR\n         BAL   REG12,ERROR1             CREATE E39 PATTERN\n         LH    REGB,ENDCOUNT\n         CVD   REGB,DOUBLE\n         UNPK  SAVE1(4),DOUBLE+5(3)\n         MVZ   SAVE1+3(1),SAVE1+2       INSERT NUMBER OF ENDS MISSING\n         MVC   4(3,REGY),SAVE1+1        IN ERROR PATTERN\n         SPACE 2\n*****   EODADIN  ******************************************************\n*                   FALL THROUGH TO TERMINATION SECTION\n         SPACE 2\nEODADIN  L     REG11,VIEX14\n         USING IEX11003,11\n         B     TERMOK\nIEX11003 CSECT\n         SPACE 2\n*****   TERMINATION  **************************************************\n*                   WRITES PB0 ITAB BLOCK FOR A PRECOMPILED PROCEDURE\n*                   WRITES LAST O/P REC IF MORE THAN ONE O/P REC\n*                   CORRECTS SPCLT AND MOVES THE CONSTANTS 0 TROUGH\n*                        15 TO THE CONSTANT POOL\n*                   IF NO TERMINATION ERROR AND EITHER DECK OR LOAD\n*                        IS SPECIFIED ESD CARD AND TXT CARDS ARE\n*                        GENERATED WITH GENERATE\n*                   CHECKS LAST ITAB RECORD WRITTEN, IF ANY\n*                   CLOSES SYSIN, SYSUT1, SYSUT3\n*                   MAKES A FREEMAIN\n*                   EXITS TO IEX20 IF NO TERMINATING ERROR\n*                            IEX21 IF TERMINATING ERROR\n         SPACE 2\nTERMOK   TM    HCOMPMOD,X'08'           Q. TERMINATING ERROR\n         BO    KOPOOLRL                 YES- DO NOT WRITE OUT ANYTHING\n         L     REGI,AITAB          CHECK IF PB0\n         LA    REGI,11(0,REGI)     CONTAINS  ANYTHING\n         C     REGI,AITL\n         BE    NOPBN0                   NO PB0\n         L     REGY,AITL\n         OI    BITS2,X'08'              SET SWITCH\n         BAL   REGE,WRTITAB        WRITE OUT PB0\nNOPBN0   BAL   REGOX,COB\n         MVI   0(EAP),X'2D'             MOVE OMEGA TO O/P\n         LA    EAP,1(0,EAP)\n         CLI   ONC,X'00'           Q  ONLY ONE O/P RECORD\n         BE    *+12                EQUAL=YES\n         BAL   REGOX,COB+8         NO- WRITE LAST O/P BUFFER\n         B     KOPOOLRL\n         OI    HCOMPMOD+2,X'40'    YES- LEAVE THE SINGLE BUFFER IN CORE\nKOPOOLRL L     REG7,POOLLOC\n         MVC   0(64,REG7),KOPOOL        MOVE THE CONSTANTS 0 TO 15\n         L     REGB,SPCLT\n         A     REGB,KOPOOL+28      MAKE SPCLT POINT\n         ST    REGB,SPCLT          TO THE NEAREST\n         NI    SPCLT+3,X'F8'            DOUBLE WORD BOUNDARY\n         MVC   PBN+1(1),PBC             SAVE NUMBER OF BLOCKS\n         IC    REGI,FSN\n         BCTR  REGI,0                   CORRECT FSN\n         STC   REGI,ZFSNMAX             SET FOR SCAN 3\n         CLC   MGESITL,TWOFIVEK         Q. WILL ITAB OVERFLOW\n         BL    *+10\n         BAL   REGB,ERR7\n         DC    X'0413'               E 19\n         TM    HCOMPMOD+1,X'60'         DECK AND OR LOAD SPECIFIED\n         BO    SCANEND                  NO SKIP ESD CARD GENERATION\n        SR    PRPOINT,PRPOINT\n         TM    HCOMPMOD,PROC       Q. PRECOMPILED PROCEDURE\n         BZ    *+10           NO\n         MVC   ESDPAR2(8),ESDPARAM      GET NAME OF PROCEDURE\n         BAL   INFORM,GENESD            WRITE ESD\nESDPAR2  DC    8X'40'\n         DC    X'00'\n         MVC   29(3,OUTAREA),KOPOOL    CORRECT FIRST ESD CARD    A22571\nSKIPESD  L     INFORM,AKOPOOL\n         MVC   *+10(2),SPCLT+2          GET LENGTH OF KOPOOL FOR TXT\n         BAL   LENGTH,GENTXTS           GENERATE TXT CARD\n         DC    H'0'\nSCANEND  TM    BITS3,FRSITB\n         BZ    CLSYSUT3\n         CHECK ITABC\nCLSYSUT3 L     REGB,UT3ADD\n         CLOSE ((REGB),REREAD),TYPE=T   RESET SYSUT3\n         L     REGB,INADD          CLOSE SYSIN\n         CLOSE ((REGB),REREAD)\n         L     1,INADD                  FREE QSAM BUFFER POOL\n         FREEPOOL (1)\n         L     REGB,UT1ADD\n         TM    HCOMPMOD,X'08'           Q. TERMINATING ERROR\n         BO    CLSPERM             YES- CLOSE SYSUT1 FOR GOOD\n         CLOSE ((REGB),REREAD),TYPE=T   RESET SYSUT1\n         B     FREE\nCLSPERM  CLOSE ((REGB),REREAD)          CLOSE SYSUT1\nFREE     TM    BITS3,NOFREE          Q. INTERUPT BEFOR GETMAIN\n         BO    GETERRPH                 YES- DONOT MAKE FREEMAIN\n         L     REG0,POOLLEN\n         L     REGI,POOLLOC\n         FREEMAIN R,LV=(0),A=(1)\n         OI    HCOMPMOD+2,NOSC          SET SWITCH FOR ERROR MESSAGES\n         TM    HCOMPMOD,X'08'           Q. TERMINATING ERROR\n         BO    GETERRPH                 YES- CALL IEX21\n         L     REGB,BRACKET                                      A28251\n         SR    REGOX,REGOX                                       A28251\n         CR    REGOX,REGB              IS BRACKETCOUNTER ZERO    A28251\n         BC    8,*+8                   YES                       A28251\n         OI    HCOMPMOD,X'90'          NO  SET SYNTAX MODE       A28251\n         XCTL  EP=IEX20000         GO TO ITAB-MANIPULATION\nGETERRPH XCTL  EP=IEX21000         GO TO ERROR MESSAGE HANDLING\n         SPACE 2\n         SPACE 2\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*                                                                     *\n*        S U B R O U T I N E   G E N E R A T E                        *\n*                                                                     *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 3\n* REGISTER DEFINITIONS\nOUTAREA  EQU   1                        OUTPUT RECORD POINTER\nINFORM   EQU   2                        ADDRESS OF INFORMATION\nTYPER    EQU   3                        TYPE OF RECORD TO BE GENERATED\nRETURN   EQU   4                        RETURN REGISTER\nPRPOINT  EQU   6\nLENGTH   EQU   14                       LENGTH OF INFORM. FROM CALL\nL        EQU   15                       LENGTH WITHIN RECORD\n         SPACE 3\n* BIT PATTERNS\nSDENTRY  EQU   X'00'                    SD-ENTRY IDENTIFICATION\nLDENTRY  EQU   X'01'                    LD-ENTRY IDENTIFICATION\nRLDFLAG  EQU   B'00001101'              FLAG USED IN RLD-ENTRY\n*ADDRESS DISPLACEMENTS\nRSTART   EQU   0                        START OF RECORD TYPE TABLE\nRTYP     EQU   1                        RECORD IDENTIFICATION\nRLEN     EQU   4                        INITIAL LENGTH 0 OR 4\nRESID    EQU   6                        ESID OR BLANKS\nRMAX     EQU   12                       MAXIMUM NUMBER OF BYTES IN REC\nRMOV     EQU   14                       START OF MOVE ROUTINE\nINFL     EQU   10                       LENGTH OF INFORM IN A RECORD\n         SPACE 3\nGENESD   LA    LENGTH,16            LENGTH ALLWAYS 16\n         LA    TYPER,ESDT               INDICATE ESD-CALL\n         MVC   PIDENT(4),0(INFORM)      NAME TO IDENT. PART\n         B     GEN3                     CALLFOR FIRST OUT REC\n*\nGENTXTS  LA    RETURN,2(0,LENGTH)   COMPUTE RETURN ADDRESS\n         LH    LENGTH,0(0,LENGTH)       LOAD LENGTH GIVEN IN CALL\nGEN2     LA    TYPER,TXTT               INDICATE TXT-CALL\n         SPACE 3\nGEN1     L     OUTAREA,SAVOUTA         LOAD ADDRESS OF OUT RECORD\n         CLC   RTYP(3,OUTAREA),RTYP(TYPER)     RECORD RIGTH TYPE\n         BNE   GEN3                     NO,CALL IOR NEW\n         CLC   INFL(2,OUTAREA),RMAX(TYPER)     RECORD FILLED\n         BNL   GEN3                     YES,CALL FOR NEW\nGEN6     LA    L,56\n         LH    REG0,INFL(0,OUTAREA)     REG0=LENGTH OF INFORM IN REC\n         SR    L,REG0                   L=EMPTY POS LEFT IN RECORD\n         CR    L,LENGTH                 ENOUTH SPACE LEFT\n         BL    *+6                      NO\n         LR    L,LENGTH                 YES L=LENGTH FROM CALL\n         AR    L,REG0\n         STH   L,INFL(0,OUTAREA)        INSERT NEW LENGTH INTO RECORD\n*\n         SR    L,REG0\n         AR    OUTAREA,REG0             START ADDRESS WITHIN RECORD\n         SR    LENGTH,L                 REMAINING LENGTH\n         B     RMOV(TYPER)              TO DIFFERENT MOVE ROUTINES\n*\nGEN4     LTR   LENGTH,LENGTH            MORE INFORMATION MUST BE MOVED\n         BH    GEN3                     YES\n         BR    RETURN\n         SPACE 3\nGEN3     EQU   *                        CALL FOR NEW OUTPUT RECORD\nPUNCH    ST  14,SAVAR\n         TM    HCOMPMOD+1,X'60'    Q. BOTH DECK AND LOAD SPECIFIED\n         BZ    BOTH                     YES\n         TM    HCOMPMOD+1,NDCK         Q. ONLY DECK\n         L     OUTAREA,PCHADD           IF ONLY DECK\n         BZ    PUT1                     YES\n         L     OUTAREA,LINADD           ONLY SYSLIN\nPUT1     PUT   (OUTAREA)                PUT FOR SYSLIN AND SYSPUNCH IF\n         ST    OUTAREA,SAVOUTA          ONLY SYSPUNCH SPECIFIED\n         L     14,SAVAR\n         B     PUNCHOUT\nBOTH     TM    BITS2,X'02'              Q. FIRST PUT\n         BZ    FIRSTPUT                 YES\n         L     LENGTH,OUTAREA2          COPY SYSLIN BUFFER TO SYSPUNCH\n         L     OUTAREA,SAVOUTA\n         MVC   0(80,LENGTH),0(OUTAREA)  BUFFER\nPUT2     L     OUTAREA,PCHADD\n         PUT   (OUTAREA)                PUT FOR SYSPUNCH WHEN BOTH HAS\n         ST    OUTAREA,OUTAREA2         BEEN SPECIFIED\n         B     PUT1-4                   GO TO PUT SYSLIN\nFIRSTPUT OI    BITS2,X'02'\n         B     PUT2\nPUNCHOUT EQU   *\n         MVC   0(4,OUTAREA),RSTART(TYPER)     INSERT FIRST 4 BYTES\n         MVI   4(OUTAREA),C' '          INSERT ONE BLANK\n         MVC   5(67,OUTAREA),4(OUTAREA)      BLANK OUTPUT RECORD\n         MVC   72(4,OUTAREA),PIDENT     INSERT PROGRAM IDENT\n         L     L,SEQU\n         LA    L,1(0,L)\n         ST    L,SEQU\n         CVD   L,DOUBLE\n         UNPK  76(4,OUTAREA),DOUBLE+5(3)\n         MVZ   79(1,OUTAREA),76(OUTAREA)\n         MVC   10(2,OUTAREA),RLEN(TYPER)     INSERT INITIAL LENGTH\n         MVC   14(6,OUTAREA),RESID(TYPER)     INSERT ESID+R AND P\n         CLC   TXTT+1(3),RTYP(TYPER)    TXT-RECORD PROCESSED\n         BNE   GEN6                     NO\n         ST    PRPOINT,4(OUTAREA)       YES INSERT PRPOINT\n         MVI   4(OUTAREA),C' '\n         B     GEN6\n         SPACE 3\n* TABLES AND MOVE ROUTINES\n         SPACE 3\nESDT     DS    0H                  START OF ESD-RECORD TABLE\n         DC    X'02'                    CARD CODE\n         DC    C'ESD'                   IDENTIFICATION\n         DC    H'0'                     INITIAL LENGTH 0\n         DC    C'      '\n         DC    H'48'                    MAXIMUM LENTH IN RECORD\nGEN7     EQU   *                   MOVE ESD-INFORMATION TO OUTAREA\n         MVC   16(16,OUTAREA),0(INFORM)     MOVE INFORM TO OUTAREA\n         MVC   25(7,OUTAREA),ESDCON     CHANGE LAST PART OF ENTRY\n         LA    TYPER,1                 ESID NR IS 1\n         STH   TYPER,14(OUTAREA)        YES INSERT ESID NUMBER\n         B     10(INFORM)               RETURN TO CALLING ROUTINE\n         SPACE 3\nTXTT     DS    0H                  START OF TXT-RECORD  TABLE\n         DC    X'02'                    CARD CODE\n         DC    C'TXT'                   IDENTIFICATION\n         DC    H'0'                     INITIAL LENGTH 0\n         DC    H'1'                     ESID\n         DC    C'    '\n         DC    H'56'                    MAXIMUM LENGTH\nGEN8     EQU   *                   MOVE TXT-INFORMATION TO OUTAREA\n         BCTR  L,0                      L=L-1\n         STC   L,*+5                    INSERT PROPER LENGTH TO MOVE\n         MVC   16(0,OUTAREA),0(INFORM)      MOVE INFORM TO OUTAREA\n         LA    PRPOINT,1(L,PRPOINT)     INCREASE PROGRAM POINTER\n         LA    INFORM,1(L,INFORM)       MODIFY DATA ADDRESS\n         B     GEN4                     OUT OF MOVE TXT ROUTINE\n         SPACE 3\n* VARIABLES AND CONSTANTS\nDEC1     DC    P'1'                     ADD CONSTANT\nESDCON   DC    X'000000'                ESD-\n         DC    C'    '                  *CONSTANT,7 BYTES\n         SPACE 3\nWORKAREA DSECT\n         COPY  WORKAREA\nC        DS    H                  PARENTHESIS COUNT\nKB       DS    H                  HOLDS ID FIELD FOR SPECIFICATIONS\nPOOLLEN  DS    F                  LENGTH OF AREA GOTTEN FROM GETMAIN\nPOOLLOC  DS    F                  START LOC. OF AREA FROM GETMAIN\nAITABBUF DS    F                  ADD. OF ITAB BUFFER\nELI      DS    F                  ADD. OF ONE LOC. BEYOND ITAB AREA\nADDARI   DS    A                  ADDRESS OF FIRST O/P BUFFER\n         DS    A                  ADD. OF SECOND O/P BUFFER\nDISP     DS    C                  DISPLACEMENT TO ADDARI\nD        DS    C                  DIMENSION COUNTER\nSPCLT    EQU   PRPT\nSP       DS    F                  CURRENT STACK POINTER\nSC       EQU   SEMCNT\nAPE      DS    F                  LAST AVAILABLE BYTE IN CURRENT O/P\nWASAVE   DS    CL12\nWABEFOR  DS    CL7\nWA       DS    CL80               INPUT AREA\nAPRNTAR  DS    A                  ADD. OF CURRENT PRINTAREA\nATOPSTAK DS    A                  LAST BYTE IN THE STACK\nIGC      DS    H                  ITAB GROUP COUNTER\nAGT      DS    A                  ADD. OF GROUPE TAB. -3\nAKOPOOL  DS    A                  ADD. OF THE CONSTANT POOL (0)\nLAPIN    DS    A                  ADD. OF LAST POSS. LABEL START\nDIM      DS    A                  ADD. FOR DIMENSION IN ITAB NAME\nPRIMPAR  DS    A                  ADD. OF FIRST SPECIFICATION\nAITAB    DS    A                  START ADD. OF ITAB\nAITL     DS    A                  CURRENT ITAB ENTRY ADD.\nLIGP     DS    A                  POINTER TO CURRENT IG HEAD ENTRY\nLPBP     DS    A                 POINTER TO CURRENT PBHEADING\nWADDARI  DS    A                  CURRENT O/P BUFFER ADD.\nITABLEN  DS    F                  ITAB LENGTH\nMGESITL  DS    F                  ACCUMULATED ITAB LENGTH\nBCHAR    DS    C                  SAVE CHAR.\nFBYTE    DS    CL1                SWITCH BYTE FOR APOSTROPHE\nFSN      DS    C                 FORSTATEMENR COUNTER\nZFSNMAX  DS    C\nPBC      DS    C                  PROGRAM BLOCK COUNTER\nONC      DS    C                  O/P REC. COUNTER\nN        DS    C                  NR. OF ARRAYS WITH SAME DIM.\nOPIN     DS    A                  POINTS TO LAST LABEL OPERATER\n         DS    C                  O/P REC. NR. WHEN OPIN WAS SET\nPZ       DS    C                  COUNTS NR. OF PARMETERS\nBITS1    DS    C                  INTERNAL SWITCHES\nBEGBIT   EQU   X'80'              BLOCK BEGIN\nBEGOFF   EQU   X'7F'\nPROBIT   EQU   X'40'              PROCEDURE HEAD PROCESSING\nDELTABIT EQU   X'20'              SEMICOLON FOUND AFTER DECLARATION\nIDBIT    EQU   X'10'              PROCEDURE NAME\nARBIT    EQU   X'08'              ARRAY PROCESSED\nLISTBIT  EQU   X'04'              COMMA FOUND AFTER ARRAY NAME\nTERBIT   EQU   X'01'              RETURN TO TERM. AFTER PBLCKEND\nBITS2    DS    C\nENDBIT   EQU   X'80'              LOGICAL END HAS BEEN FOUND\nCOBIT    EQU   X'40'              COMMENT\nSTARTBIT EQU   X'20'              ZERO UNTIL FIRST BEGIN FOUND\nVALBIT   EQU   X'10'              VALUE\nPB0BIT   EQU   X'08'              WRITE PB0 FOR PRE. COMP. PROC.\nFRSTPUT  EQU   X'02'              FIRST PUT IN GENERATE\nENDELSE  EQU   X'01'              END MAY CLOSE FOR OR PROC**\nBITS3    DS    C\nE11BIT   EQU   X'80'              E11 HAS BEEN GENERATED ONCE\nFMBIT    EQU   X'40'               FORMAL PARAMETER BIT\nFMOFF    EQU   X'BF'\nNOFREE   EQU   X'20'              INTERUPT BEFORE GETMAIN\nFRSITB   EQU   X'10'              FIRST ITAB REC. IS WRITTEN\nPROCESD  EQU   X'08'              WRITE SED CARD FOR PRE. COMP. PROC.\nPROCOFF  EQU   X'F7'\n         END   IEX11000\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IEX20": {"ttr": 3331, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x98\\x01/\\x00\\x98\\x01/\\x16 \\x02\\xca\\x02\\xca\\x00\\x00\\xd6\\xf3\\xf6\\xf0`\\xf2\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1998-01-12T00:00:00", "modifydate": "1998-01-12T16:20:00", "lines": 714, "newlines": 714, "modlines": 0, "user": "O360-20"}, "text": "         TITLE 'ITAB MANIPULATION IEX20'\n*STATUS: CHANGE LEVEL 000                                             *\n*                                                                     *\n*FUNCTION/OPERATION: EACH ITAB BLOCK IS SCANNED FOR DUPLICATE         *\n*   IDENTIFIERS.                                                      *\n*   RELATIVE DISPLACEMENTS IN DSA IS ALLOCATED FOR ALL IDENTIFIERS,   *\n*   EXCEPT PROCEDURES, LABELS AND SWITCHES.                           *\n*   THE ITAB BLOCKS ARE WRITTEN IN PROGRAM BLOCK NUMBER ORDER TO      *\n*   SYSUT3.                                                           *\n*   THE ITAB BLOCKS ARE PRINTED ON SYSPRINT IN PROGRAM BLOCK NUMBER   *\n*   ORDER AND WITH THE IDENTIFIERS IN ALPHABETIC FORM WITHIN EACH     *\n*   BLOCK, IF THE OPTION 'SOURCE' IS SPECIFIED.                       *\n*   CREATES PBTAB2                                                    *\n*                                                                     *\n*ENTRY POINT:                                                         *\n*        IEX20000 ITAB MANIPULATION     XCTL EP=IEX20                 *\n*                                                                     *\n*INPUT: THE ITAB BLOCKS ARE READ IN FROM SYSUT3.                      *\n*                                                                     *\n*OUTPUT: THE ITAB BLOCKS ARE WRITTEN TO SYSUT3 AND PRINTED ON SYSPRINT*\n*   IF THE OPTION 'SOURCE' IS SPECIFIED.                              *\n*                                                                     *\n*EXTERNAL ROUTINES: THE PRINT ROUTINE IN IEX00 IS USED.               *\n*                                                                     *\n*EXITS-NORMAL: CONTROL IS GIVEN TO IEX21  XCTL EP=IEX21               *\n*                                                                     *\n*     -ERROR: N/A                                                     *\n*                                                                     *\n*TABLES/WORKAREA:                                                     *\n*   ATAB  FOR ADDRESS IS OF THE ITAB RECORDS IN PROGRAM BLOCK NUMBER  *\n*         ORDER                                                       *\n*   TRTAB FOR TRANSLATION OC INTERNAL CHATACTERS TO EBCDIC CHARACTERS.*\n*   TAB   FOR PRINTING OF HEXADECIMAL DIGITS.                         *\n*   WORK  FOR BUILDING THE PRINT ENTRIES.                             *\n*                                                                     *\n*ATTRIBUTES: NONE.                                                    *\n*                                                                     *\n*NOTES: CHARACTER CODE DEPENDENCE.                                    *\n*   THE OUTPUT ON SYSPRINT:                                           *\n*   THE IDENTIFIER NAME IS TRANSLATED BY MEANS OF TRTAB, WHICH IS     *\n*   A CHARACTER TABLE.                                                *\n*   THE HEXADECIMAL PART IS TRANSLATED BY MEANS OF TAB.               *\n*   THE REMAININ PARTS DEPEND ON THE INTERNAL REPRESENTATION OF THE   *\n*   EXTERNAL CHARACTER SET WHICH IS EQUIVALENT TO THE ONE USED AT     *\n*   ASSEMBLY TIME.                                                    *\n*   THE OPERATION OF THE OTHER PARTS OF THE PHASE DOES NOT DEPEND     *\n*   UPON A PARTICULAT INTERNAL REPRESENTATION OF THE EXTERNAL         *\n*   CHARACTER SET                                                     *\nIEX20000 START\n* RELEASE 19 CHANGES\n* 110600                                                         A28230\nREG0     EQU   0                  CALCULATIONS\nREGI     EQU   1                  PBN\nREGZ     EQU   2                  CALCULATIONS\nREGD     EQU   3                  PARAMETER FOR CONVERT ROUTINE\nDP       EQU   3                  DOUBLE WORD POINTER\nWP       EQU   4                  WORD POINTER\nREGC     EQU   5                  KEEPS TRACK OF WHEN TO PRINT\nHP       EQU   5                  HALF WORD POINTER\nBP       EQU   6                  BYTE POINTER\nRAID     EQU   7                  CURRENT IDENTIFIER\nAIB      EQU   8                  CURRENT BLOCKHEAD\nRAKOM    EQU   9                  SCANS FOR DUPLICATES\nREGY     EQU   10\nREGDIM   EQU   10                 ARRAY STORAGE ALLOCATIONS\nREG11    EQU   11                 BASE REGISTER\nREGB     EQU   12                 RETURN FROM CONVERT, PRINT ROUTINE\nREGP     EQU   14                 PBN DURING PRINTING\nREG15    EQU   15\n         SPACE 2\n*****   INITIALIZATION  ***********************************************\n*              GETMAIN FOR ITAB AND ATAB\n*              FIRST ENTRY IN ATAB IS MADE ZERO IF NO PBN 0\n*              PRINTING OF HEADLINES IS INTITLIZED IF SOURCE SPECIFIED\n*              C IS MADE 4 IF SHORT SPECIFIED OTHERWISE IT REMAINS 8\n         SPACE 2\n         BALR  REG11,0\n         USING *,REG11\n         USING WORKAREA,13\n         LA    REG15,SLUT2        INTERUPT BEFORE GETMAIN\n         ST    REG15,ERET\n         L     REGI,ITAB20S       ITAB\n         LA    REGI,1024(0,REGI)      ATAB\n         LR    REG0,REGI\n         GETMAIN R,LV=(0)              GET ITAB ATAB AREAS\n         LA    REG15,SLUT\n         ST    REG15,ERET         INTERUPT ADD. AFTER GETMAIN\n         ST    REGI,AREALOC\n         ST    REGI,AITAB         ITAB START LOCATION\n         A     REGI,ITAB20S\n         ST    REGI,ATABAD        ATAB START LOCATION\n         SR    REGZ,REGZ\n         ST    REGZ,KOPOOL\n         ST    REGZ,SAVEPB\n         TM    HCOMPMOD,PROC       Q. IS THERE A PB0\n         BO    *+12\n         LA    REG15,1             NO- PROGRAM BLOCK 1 IS FIRST BLOCK\n         ST    REG15,SAVEPB\n         MVC   0(4,REGI),KOPOOL\n         ST    REGZ,SAVE                INITILIZE WITH ZEROS\n         MVC   SAVE1(16),SAVE\n         STC   REGZ,BITS1               INITILIZE SWITCHES\n         LA    REGY,PBTAB2\n         ST    REGY,APBTAB2              START ADDRESS OF PBTAB2\n         TM    HCOMPMOD+1,NSRCE   Q. SOURCE SPECIFIED\n         BO    INITIAL            NO\n         MVI   LINCNT,X'7F'\n         MVI   PAGEHD1,X'02'\n         MVI   PAGEHD1+1,X'11'\n         MVI   PAGEHEAD+2,X'40'\n         MVC   PAGEHEAD+3(81),PAGEHEAD+2\n         MVC   PAGEHEAD+39(16),HDING1\n         MVI   PAGEHD2,X'01'\n         MVI   PAGEHD2+1,X'09'\n         MVC   PAGEHD2+2(90),HEAD1\n         MVI   PAGEHD3,X'01'\n         MVI   PAGEHD3+1,X'11'\n         MVC   PAGEHD3+2(90),HEAD2\n         BAL   REGB,PRINTITB            INITILIZE PRINTING FOR ITAB\nINITIAL  SR    REGI,REGI\n         TM    HCOMPMOD,LNG        LONG OR SHORT PRECISION\n         BO    *+8                 LONG\n         MVI   C+1,X'04'          SHORT   C=4\n*****   SCAN FOR DUPLICATES   *****************************************\n*                   READS IN A NEW BLOCK\n*                   START ADDRESS IN AIB END ADDRESS IN AITAB\n*                   COMPARES EACH IDENTIFIER WITH ALL IDENTIFIERS\n*                        FOLLOWING IT IN THE BLOCK\n*                   IF TWO EQUAL FOUND AND IF NOT FIRST ONE IS A\n*                        FORMAL PARAMETER AND SECOND NOT E45 IS\n*                        GENERATED\n*                   WHEN ALL IDENTIFIERS IN THE BLOCK HAVE BEEN\n*                        CHECK THE EXIT IS TO ALLOSTUR\nREADBLK  L     REGB,AITAB         START ADD. OF NEW BLOCK\n         L     REGZ,UT3ADD        READ IN NEW BLOCK\n         READ  ITABC,SF,(REGZ),(REGB),'S'\n         CHECK ITABC\n         SR    REGZ,REGZ\n         IC    REGZ,10(0,REGB)    GET NEW PBN\n         SLA   REGZ,2\n         L     RAID,ATABAD\n         ST    REGB,0(REGZ,RAID)        SAVE ADD. OF BLOCK IN ATAB\n         LR    AIB,REGB\n         MVC   LENCOUNT(2),0(REGB)      GET LENTH OF BLOCK\n         AH    REGB,LENCOUNT\n         ST    REGB,AITAB               SAVE END ADDRESS OF BLOCK\n         LR    RAID,AIB\n         TM    8(AIB),X'80'        Q. IS BLOCK TYPE PROC\n         BZ    SCANNXT             NO\n         LA    RAID,22(0,AIB)      YES- SKIP  CHECKING AGAINST\n         B     SCANNXT+4           TYPE PROCEDURE NAME\nSCANNXT  LA    RAID,11(0,RAID)\n         C     RAID,AITAB               Q. ALL IDENTIFIERS CHECKED\n         BE    ALLOSTOR                 YES- GO TO ALLOCATE STORAGE\n         CLI   5(RAID),X'2B'       Q. FOR HEAD OR CONT. ENTRY\n         BE    SCANNXT                  YES- SKIP CHECKING\n         CLI   0(RAID),X'00'            Q. INVALID PROCEDURE NAME\n         BE    SCANNXT                  YES- SKIP CHECKING\n         LR    RAKOM,RAID\nCHECKNXT LA    RAKOM,11(0,RAKOM)\n         C     RAKOM,AITAB              Q. ALL IDENT. CHECKED AGAINST\n         BE    SCANNXT                  THE ONE PROCESSED\n         CLI   5(RAKOM),X'2B'        Q. FOR HEAD OR CONT ENTRY\n         BE    CHECKNXT\n         CLC   0(6,RAKOM),0(RAID)       COMPARE EACH IDENTIFIER AGAINST\n*ALL FOLLOWING INDENTIFIERS IN THE      BLOCK\n         BNE   CHECKNXT\n         TM    7(RAID),X'30'            TWO EQUAL FOUND Q. PROCESSED\n         BM    *+8                     ONE FORMAL PARAMETER\n         B     E43                     NO\n         TM    7(RAKOM),X'30'      Q. COMPARED ONE IS FORMAL PARAMETER\n         BM    E43                     YES\n         B     CHECKNXT                NO\n         SPACE 2\n*****   ALLOSTOR ******************************************************\n*                   ALLOCATETS STORAGE FOR THE IDENTIFIERS\n*                   FOR A TYPE PROC BLOCK ALLOCATION STARTS AT 32\n*                        OTHERWISE AT 24\n*                   NO BLOCK MAY GET MORE THAN 4K ALLOCATED\n*                   IT IS ALSO CHECKED THAT THERE IS NO PROC, STRING\n*                        OR SWITCH CALLED BY VALUE\n*                        WHEN ALL DECLARATIONS IN THE BLOCK ARE\n*                             PROCESSED DP-C WILL BE PUT IN PBTAB2\n*                        IF THERE ARE MORE BLOCKS TO BE PROCESSED THE\n*                             EXIT IS TO IDENTIFIER SCAN OTHERWISE\n*                             TO WRITE ITAB\n*                        FOUR POINTERS ARE USED DP DOUBLE WORD POINTER\n*                                               WP WORD\n*                                               HP HALF WORD\n*                                               BP BOOLEAN\n*                        DP IS INCREASED BY C WHICH IS 8 FOR LONG\n*                                                      4 FOR SHORT\n*                        FOR LONG PRESITION ALL 4 POINTERS ARE USED\n*                        FOR SHORT WP IS NEVER USED, WILL CONTAIN 0\n*                             ALL THE TIME\n*                        REAL WILL BE ALLOCATED TO DP, 4 OR 8 BYTES\n*                        INTEGER WILL GET DP OR WP. DP ALLWAYS IF SHORT\n*                             WP IF LONG AND WP NOT ZERO\n*                             OTHERWISE DP, IN WHITCH CASE WP WILL\n*                             EQUAL DP+4 FOR THE NEXT INTEGER\n*                        BOOLEAN WILL GET DP, WP, HP OR BP IF LONG\n*                             DP, HP OR BP IF SHORT\n*                        FIRST BOOLEAN FOUND WILL GET EITHER WP OR DP\n*                                 HP IS THEN INITILIZED TO WP+2 OR DP+2\n*                                 BP                       WP+1    DP+1\n*                        SECOND BOOLEND WILL GET THE VALUE OF BP\n*                             AND BP WILL BE 0\n*                        THIRD BOOLEAN WILL GET HP AND HP WILL BE 0\n*                                  BP=HP+1\n*                        FORTH BOOLEAN WILL GET BP AND BP WILL BE 0\n*                        THIS WILL THEN BE REPEATED FOR EVERY FOUR\n*                             BOOLEAN IDENTIFIERS\n*                        ALL FORMAL PARAMETERS WILL GET THE DP VALUE\n*                             AND DP WILL BE INCREASED BY 8\n*                        ARRAYS WILL GET DP VALUE AND DP WILL BE\n*                             INCREASED BY 4(DIM+6)+X WHERE X IS 4\n*                             WHEN LONG PRECITION AND DIM IS AN UNEVAN\n*                             NUMBER, OTHERWISE X IS 0\n*                        LABEL, SWITCH , PROCEDURE WILL NOT GET ANYTHIN\n*                        EX. OF STORAGE ALLOCATION\n*                        LONG           SHORT\n*                        01234567       01234567  FP   FORMAL PARAMETER\n*                        FP             FP        R    REAL\n*                        FP             FP        INT  INTEGER\n*                        R              R   INT   B    BOOLEAN\n*                        INT INT        INT INT   NU   NOT USED SPACE\n*                        INT BBB        BBB R\n*                        R              INT R\n*                        INT NU\n*                        R\n         SPACE 2\nALLOSTOR TM    8(AIB),X'80'   Q. IS THE BLOCK A TYPE PROCEDURE\n         BZ    STARTALL-4     NO\n         LA    DP,32          YES- SET DOUBLE WORD POINTER\n         NI    8(AIB),X'7F'   CLEAR TYPE PROCEDURE INDICATION\n         B     *+8\n         LA    DP,24          SET DOUBLE WORD POINTER\nSTARTALL LA    WP,0                SET ALL POINTERS TO ZERO\n         LA    HP,0\n         LA    BP,0\n         LR    RAID,AIB            GET FIRST VARIABLE\n         B     GETNEXT\nSTORALLO AH    DP,C           INCREASE ALLOCATION POINTER\n         C     DP,FOURK            Q. HAS FOURK BEEN ALLOCATED ALLREADY\n         BH    E44\nGETNEXT  LA    RAID,11(0,RAID)     GET NEXT VARIABLE\n         STM   DP,BP,DPC           STORE ALL POINTERS\n         C     RAID,AITAB          Q. ALL VARIABLES TAKEN CARE OF\n         BE    LASTREC             YES\n         CLI   5(RAID),X'2B'       Q. FOR HEADING OR CONTINUATION\n         BE    GETNEXT\n         CLI   6(RAID),X'91'       Q. ALL PURPOS IDENTIFIER\n         BE    GETNEXT\n         TM    7(RAID),X'30'       Q. FORMPARAM, DEK. VARIABL. OR CONST\n         BM    FORMPARM\n         BZ    CONST\n         TM    7(RAID),X'03'       Q. BOOLEAN VARIABLE\n         BO    BOOLEAN\n         TM    HCOMPMOD,LNG      Q,SHORT PRESISION\n         BZ    REAL                YES- ALLOCATE SAME FOR REAL AND\n*                                  INTEGER\n         TM    7(RAID),X'01'       Q. INTEGER OR REAL\n         BO    INTEGER\nREAL     MVC   9(2,RAID),DPC+2     MOVE IN DISPLACEMENT\n         B     STORALLO\nINTEGER  LTR   WP,WP               Q. EMTY HOLE LEFT FOR INTEGER\n         BZ    *+18                NO\n         MVC   9(2,RAID),WPC+2     YES- FILL THE HOLE AND MAKE\n         LA    WP,0                WORDPOINTER= 0.\n         B     GETNEXT\n         MVC   9(2,RAID),DPC+2     MOVE IN DOUBLEWORD POINTER AND MAKE\n         LA    WP,4(0,DP)          WORDPOINTER POINT TD EMPTY HOLE NEXT\n         B     STORALLO            TO IT\nBOOLEAN  LTR   BP,BP               Q SPACE LEFT NEXT TO PREVIOUS BOOL.\n         BZ    *+18                NO\n         MVC   9(2,RAID),BPC+2     YES- MOVE IN DISPLACEMENT AND MAKE\n         LA    BP,0                BYTE  POINTER 0\n         B     GETNEXT\n         LTR   HP,HP               Q.SPACE LEFT NEXT TO 2 PREVIOUS BOOL\n         BZ    TESTWP-8            NO\n         MVC   9(2,RAID),HPC+2     YES- MOVE IN DISPLACEMENT AND MAKE\n         LA    BP,1(0,HP)          MAKE BYTEPOINTER POINT TO NEXT\n         LA    HP,0                HALFWORD POINTER 0\n         B     GETNEXT             FREE BYTE\n         TM    HCOMPMOD,LNG      Q, SHORT PRECISION\n         BZ    TAKEDP              YES- DO NOT USE WP POINTER\nTESTWP   LTR   WP,WP               Q. WPPOINTE FREE\n         BZ    TAKEDP              NO- TAKE DP POINTER INSTEAP\n         MVC   9(2,RAID),WPC+2     YES- USE WP AS DISPLACEMENT\n         LA    BP,1(0,WP)          SET  HP AND BP TO FREE BYTES IN WORD\n         LA    HP,2(0,WP)\n         LA    WP,0                SET WP TO ZERO\n         B     GETNEXT\nTAKEDP   MVC   9(2,RAID),DPC+2     USE DP AS DISPLACEMENT\n         LA    BP,1(0,DP)          SET WP, HP, BP TO FREE BYTES WITHIN\n         LA    HP,2(0,DP)          THE DOUBLE WORD\n         LA    WP,4(0,DP)\n         B     STORALLO\nCONST    TM    7(RAID),X'04'       FOR LABEL, STRING, PROCEDURE DO NOT\n         BZ    GETNEXT\n         TM    7(RAID),X'08'       ALLOCATE ANY STORAGE\n         BO    GETNEXT\n         SR    REGDIM,REGDIM\n         IC    REGDIM,9(RAID)\n         SRA   REGDIM,4            FOR  AN ARRAY\n         LA    REGDIM,6(0,REGDIM)      STORAGE NEEDED IS 4(DIM+6)+X\n         SLA   REGDIM,2\n         OC    9(2,RAID),DPC+2    OR IN THE DISP. TO SAVE DIMENSIONS\n         TM    HCOMPMOD,LNG        X IS 4 IF LONG PRECITION AND DIM IS\n         BZ    *+16\n         TM    9(RAID),X'10'       AN UNEVAN NUMBER\n         BZ    *+8                 INCREASE IF NEEDED TO GET\n         LA    REGDIM,4(0,REGDIM)       ON DOUBLE WORD BOUNDARY\n         LA    DP,0(REGDIM,DP)\n         B     STORALLO+4\nFORMPARM TM    7(RAID),X'03'       Q. TYPE PARAMETER\n         BZ    NOTTYPE             NO\nFORMPALL MVC   9(2,RAID),DPC+2     MOVE IN DISPLACEMENT\n         LA    DP,8(0,DP)\n         B     STORALLO+4\nNOTTYPE  TM    7(RAID),X'10'       Q. CALL BY NAME\n         BO    FORMPALL            YES\n         TM    7(RAID),X'03'       NO- CHECK IF VALUE CALL CORRECT\n         BZ    *+8\n         B     FORMPALL\n         CLI   7(RAID),X'28'       Q. LABLE CALLED BY VALUE\n         BE    FORMPALL\n         B     E45       PROC SWITCH OR STRING CALLED BY VALUE\nLASTREC  SR    REGZ,REGZ           CONSTRUCT ENTRY OF PBTAB2\n       IC    REGZ,10(0,AIB)       GET PBN\n         SLA   REGZ,1\n         L     REGP,APBTAB2\n         LA    REGP,0(REGZ,REGP)\n         SH    DP,C               GET LAST BYTE USED\n         STH   DP,0(0,REGP)\n         L     REGI,SAVEPB\n         CH    REGI,PBN       Q.ALL ITAB-REC WRITTEN OUT\n         LA    REGI,1(0,REGI)\n         ST    REGI,SAVEPB\n         BNE   READBLK            NO\n         SPACE 2\n*****   WRITITAB ******************************************************\n*                   WRITES THE ITABRECORD TO SYSUT3 IN PROGRAM BLOCK\n*                        NUMBER ORDER\n*                   THE ADDRESS TO WHERE THE BLOCK IS GOING TO BE\n*                        WRITTEN IS PICKED UP FROM ATAB\n*                   IN EACH BLOCK THE LENGTH OF THE NEXT BLOCK IS\n*                        INSERTED\n         SPACE 2\nWRITITAB L     REGB,ATABAD        START OF ADDRESS TABLE\n         L     REGY,UT3ADD        DCB ADDRESS\n         CLOSE ((REGY),REREAD),TYPE=T   GET  TO START OF SYSUT3\n         SR    REGZ,REGZ\n         TM    HCOMPMOD,PROC       Q. IS THERE A PB0\n         BZ    ITLP2              NO\nITABLOOP L     REGY,0(0,REGB)     GET ADDRESS OF BLOCK\n         L     RAID,UT3ADD        DCB ADDRESS\n         L     REGC,4(0,REGB)     GET ADDRESS OF NEXT BLOCK\n         CH    REGZ,PBN            Q. LAST BLOCK\n         BE    *+10               YES\n         MVC   2(2,REGY),0(REGC)      INSERT LENGTH OF NEXT BLOCK\n         MVC   LENCOUNT(2),0(REGY)    GET LENGTH OF CURRENT BLOCK\n         LH    REG15,LENCOUNT\n         WRITE PRCH4,SF,(RAID),(REGY),(REG15)\n         CHECK PRCH4\nITLP2    LA    REGB,4(0,REGB)       GET ADDRESS OF NEXT BLOCK\n         CH    REGZ,PBN       Q.ALL ITAB-REC WRITTEN OUT\n         LA    REGZ,1(0,REGZ)\n         BNE   ITABLOOP            NO\n         B     ITABPRNT           YES\n         SPACE 2\n*****   E43      ****************************************************\n*                   GENERATES ERROR MESSAGE 45\n*                   RETURNS TO SCANNING FOR DUPLICATES\n         SPACE 2\nE43      BAL   REG15,ERRNAME\n         MVI   1(REGY),X'2D'       E45\n         B     SCANNXT\n         SPACE 2\n*****   E45      ******************************************************\n*                   GENERATER ERROR MESSAGE 47\n*                   RETURNS TO FORMPALL AS IF VAR. WAS CORRECT\n         SPACE 2\nE45      BAL   REG15,ERRNAME\n         MVI   1(REGY),X'2F'       E47\n         B     FORMPALL\n         SPACE 2\n*****   E44      ******************************************************\n*                   GENERATES ERROR MESSAGE 214\n*                   RETURNS TO LASTREC TO TAKE NEXT BLOCK, IF ANY\n*                                                                     *\n*                                                                     *\nE44      L     REGD,SAVEPB\n         BAL   REGB,CONVERT        CONVERT PBN\n         L     REGY,NEXTERR\n         LA    REGB,7(0,REGY)        Q. SPACE LEFT IN ERRORPOOL\n         C     REGB,ENDPOOL\n         BH    E0\n         ST    REGB,NEXTERR\n         MVI   0(REGY),X'87'       MOVE LENGTH AND BLANK SC INDICATOR\n         MVI   1(REGB),X'D6'            E214\n         MVC   4(3,REGY),SAVE+1          PBN\n         B     LASTREC\n         SPACE 2\n*****   ERRNAME  *****\n*                   FINDS THE LENGTH OF THE VAR. IN ERROR CHECKS FOR\n*                        ERRPOOL OVERFLOW, MOVES IN THE NAME OF THE\n*                        VAR. AND LENGTH OF MESSAGE\n*                        RETURNS TO CALLING PROGRAM, E43 OR E44\n         SPACE 2\nERRNAME  LA    REGB,5\n         STC   REGB,*+7\n         CLI   0(RAID),X'00'      FIND LENGTH OF NAME\n         BNE   *+8\n         BCT   REGB,ERRNAME+4\n         L     RAKOM,NEXTERR\n         LA    RAKOM,5(REGB,RAKOM)\n         C     RAKOM,ENDPOOL      CHECK SPACE IN ERRORPOOL\n         BH    E0\n         L     REGY,NEXTERR\n         ST    RAKOM,NEXTERR\n         EX    REGB,MOVE          INSERT NAME IN ERROR PATTERN\n         LA    REGB,5(0,REGB)\n         STC   REGB,0(REGY)\n         OI    0(REGY),X'80'       BLANK SC INDICATOR\n         BCR   15,REG15\n         CNOP  0,4\nMOVE     MVC   4(1,REGY),0(RAID)\nE0       LA    REGB,NEXTERR\n         MVI   0(REGB),X'02'\n         MVI   1(REGB),X'D4'            E212\n         ST    REGB,NEXTERR\n         B     SLUT\n         SPACE 2\n         SPACE 2\n*****   ITABPRNT ******************************************************\n*                   PRINTS ON SYSPRINT, IF SOURCE SPECIFIED, ALL VAR.\n*                   THE BLOCKS IN PBN NUMBER ORDER AND WITH THE VAR\n*                        SORTED WITHIN EACH BLOCK\n*                   REGC KEEPS TRACK OF WHEN PRINTING IS NEEDED, THE\n*                        INFORMATION ABOUT EACH VAR. IS BUILT UP IN\n*                        WORK AND THEN TRANSFERD TO PRINTAREA. WHEN\n*                        3 VAR. HAVE BEEN PLACED IN THE PRINTAREA THE\n*                        LINES IS PRINTED\n*                   THE ADDRESS TO THE BLOCK IS TAKEN FROM ATAB\n*                   THE LENGTH IS TAKEN FROM THE FIRST 2 BYTES IN THE\n*                        BLOCK.\n*                   THE SURROUNDING PBN FROM PBTAB1\n*                   THE STARTING SC COUNTER FOR THE BLOCK FROM BYTE 6\n*                        AND 7 IN THE BLOCK\n*                   IF THE BLOCK DOES NOT CONTAIN ANY VAR. ONLY THE\n*                        PBN AND SURROUNDING PBN ARE PRINTED\n*                   ALL HEADENTRIES, FOR AND CONTLINES ARE SKIPPED\n*                   EACH NEW BLOCK IS PRECEEDED BY A BLANK LINE\n*                   START ADDRESS OF THE BLOCK IS IN AIB\n*                   END ADDRESS OF THE BLOCK IS IN AITAB, THIS ADD.\n*                        WILL BE AIB+11 WHEN ALL VAR. PROCESSED\n         SPACE 2\nITABPRNT TM    HCOMPMOD+1,NSRCE     Q. SOURCE SPECIFIED\n         BO    SLUT               NO\n         SR    REGP,REGP           CLEAR REGISTER\n         TM    HCOMPMOD,PROC       IS THERE A PB0\n         BO    GETPB+4             YES- PROCESS PB0, REGP=0\nGETPB    LA    REGP,1(0,REGP)      INCREASE PBN\n         LR    REGB,REGP\n         SLA   REGB,2\n         L     AIB,ATABAD               GET ADDRESS OF NEW BLOCK\n         L     AIB,0(REGB,AIB)          VIA ATAB+ 4 TIMES PBN\n         MVC   LENCOUNT(2),0(AIB)       GET LENGTH OF THE BLOCK\n         LH    REGB,LENCOUNT\n         LA    REGB,0(REGB,AIB)         GET END OF BLOCK\n         ST    REGB,AITAB          STORE END OF IT\n         BAL   REGB,PRINTITB       PRINT A BLANK LINE\n         LR    REGD,REGP           CONVERT PBN\n         BAL   REGB,CONVERT\n         MVC   0(3,REGI),SAVE+1    NEW PBN\n         IC    REGD,PBTAB1(REGP)   CONVERT SURROUNDING PBN\n         BAL   REGB,CONVERT\n         MVC   10(3,REGI),SAVE+1   SURROUNDING PBN\n         MVC   SCSAVE(2),6(AIB)    CONVERT SC COUNTER TO DECIMAL\n         LH    REGB,SCSAVE\n         CVD   REGB,DOUBLE    STARTING SC OF BLOCK IS INSERTED\n         UNPK  4(5,REGI),DOUBLE(8)\n         MVZ   8(1,REGI),7(REGI)\n         CLC   LENCOUNT(2),ELEVEN    Q. EMPTY BLOCK\n         BNE   *+12               NO\n         BAL   REGB,PRINTITB      FOR AN EMPTY BLOCK PRINT\n         B     ENDBLOCK            ONLY THE BLOCK NUMBERS\n         SR    REGC,REGC\n         SPACE 2\n*****   GETNVAR  *****\n*                   LOOPS THROUGH BLOCK TO GET THE CURRENT LOWEST\n*                        VAR.\n*                   EXITS TO ENDBLOCK WHEN ALL VAR. IN THE BLOCK HAVE\n*                        BEEN PROCESSED, OTHERWISE TO TESTVAR\n         SPACE 2\nGETNVAR  LA    RAID,11(0,AIB)           GET FIRST VAR. AFTER HEADING\n         LR    REGY,RAID\n         C     RAID,AITAB               Q. ALL VAR. PROCESSED\n         BE    ENDBLOCK                 YES\n         CLI   5(RAID),X'2B'            Q. HEAD OR CONTINUATION LINE\n         BE    ENDVAR2\nTESTNXT  LA    REGY,11(0,REGY)          GET NEXT VAR.\n         C     REGY,AITAB               Q. ALL VAR. COMPARED\n         BE    TESTVAR\n         CLI   5(REGY),X'2B'            Q. HEAD OR CONTINUATION LINE\n         BE    TESTNXT                  YES- SKIP THAT LINE\n         CLC   0(6,RAID),0(REGY)        Q. COMPARE CURRENT LOWEST - NEW\n         BL    TESTNXT                  CURRENT LOWEST STILL LOW\n         LR    RAID,REGY                NO- SHIFT RAID TO NEW\n         B     TESTNXT\n         SPACE 2\n*****   TESTVAR  *****\n*                   CHECKS THE INTERNAL NAME TO FIND TYPE AND MOVES\n*                        CHARACTERISTICS TO WORKAREA\n         SPACE 2\nTESTVAR  TM    6(RAID),X'91'      Q. ALL PURPOSE IDENTIFIER\n         BO    ENDVAR             YES\n         TM    7(RAID),X'03'       Q. TYPE\n         BO    BOL                 TYPE=BOOLEAN\n         BZ    BOL+4               NOT TYPE\n         TM    7(RAID),X'01'      Q.INTEGER OR REAL\n         BZ    *+12\n         MVI   WORK+7,C'I'         INTEGER\n         B     BOL+4\n         MVI   WORK+7,C'R'         REAL\n         B     BOL+4\nBOL      MVI   WORK+7,C'B'         BOOLEAN\n         TM    7(RAID),X'0C'\n         BZ    TESTPROC\n         BO    SWITCH\n         TM    7(RAID),X'08'       Q. ARRAY OR LABEL\n         BZ    ARRAY\n         MVI   WORK+8,C'L'         LABEL\nTESTPROC TM    7(RAID),X'C0'\n         BO    PROCEDUR\n         BZ    FORMAL\n         TM    7(RAID),X'40'\n         BZ    FORMAL\n         MVI   WORK+11,C'C'        CODE PROCEDURE\n         B     PROCEDUR\nFORMAL   TM    7(RAID),X'30'       Q. SPECIFIED IDENTIFIER\n         BO    ENDVAR\n         BZ    ENDVAR\n         NI    BITS1,PROCOFF       RESET PROCEDURE BIT\n         TM    6(RAID),X'01'\n         BZ    *+8\n         MVI   WORK+8,C'T'         STRING\n         TM    7(RAID),X'10'       Q. NAME OR VALUE CALL\n         BZ    *+12\n         MVI   WORK+10,C'N'        NAME\n         B     ENDVAR\n         MVI   WORK+10,C'V'        VALUE\n         B     ENDVAR\nSWITCH   MVI   WORK+8,C'S'             SWITCH                    A28230\n         B     CONVERT2            CONVERT NR. OF COMPONENTS\nPROCEDUR MVI   WORK+9,C'P'         PROCEDURE\n         OI    BITS1,PROCBIT       SET PROCEDURE BIT\n         B     CONVERT2            CONVERT NR. OF PARAMETERS\nARRAY    MVI   WORK+9,C'A'         ARRAY\n         SPACE 2\n*****   CONVERT2 *****\n*                   ENTERED FOR PROCEDURE, ARRAY AND SWITCH CONVERTS\n*                        THE NUMBER OF PARAMETERS, DIMENSIONS OR\n*                        COMPONENTS TO DECIMAL FORM AND PUTS IT IN\n*                        WORK\n*                   FOR ARRAY OR SWITCH THE COUNTER IS FIRST\n*                        INCREASED BY ONE TO GET THE REAL VALUE\n         SPACE 2\nCONVERT2 TM    7(RAID),X'30'\n         BM    FORMAL+12\n         IC    REGD,9(0,RAID)\n         SRA   REGD,4              SWITCH OR PROCEDURE\n         TM    BITS1,PROCBIT     TEST IF PROC PARAMETERS\n         BO    *+8                 YES\n         LA    REGD,1(0,REGD)      NO- INCREASE DIM COUNTER\n         NI    BITS1,PROCOFF       TO GIVE CORRECT VALUE\n         BAL   REGB,CONVERT             CONVERT IT TO DECIMAL\n         MVC   WORK+13(2),SAVE+2   AND MOVE IT OUT\n         B     FORMAL\n         SPACE 2\n*****   CONVERT  *****\n*                   CONVERTS FROM HEXADECIMAL TO DECIMAL\n*                   USED FOR LN, DISP AND PBN TO BE WRITEN OUT\n         SPACE 2\nCONVERT  CVD   REGD,DOUBLE         CONVERT TO DECIMAL\n         UNPK  SAVE(4),DOUBLE+5(3)      UNPACK AND\n         MVZ   SAVE+3(1),SAVE+2         CLEAR SIGN\n         BCR   15,REGB                  RETURN\n         SPACE 2\n*****   PRINTITB *****\n*                   PRINTS A LINE, SAVES NEW PRINTAREA ADDRESS, RESETS\n*                        REGC, RETURNS\n         SPACE 2\nPRINTITB STM   14,15,SAVE1\n         L     15,PRTRTADD         PRINT A RECORD\n         BALR  14,15\n         ST    REGI,APRNTAR        SAVE ADD. OF NEXT PRINT AREA\n         LM    14,15,SAVE1\n         SR    REGC,REGC           RESET REGC\n         BCR   15,REGB             RETURN\n         SPACE 2\n*****   ENDVAR   *****\n*                   MOVES EXTERNAL NAME TO WORK, TRANSLATES IT\n*                   CONVERTS LN OR DISP AND MOVES THAT TO WORK\n*                   MOVES WORK TO CURRENT PRINTAREA WITH HELP OF AN\n*                        EXECUTET MOVE\n*                   INCREASES REGC AND CHECKS IF ONE LINE HAS BEEN\n*                        FILLED UP. IN THAT CASE - PRINTS THAT LINE\n*                   SHIFTS AWAY THE NOW PROCESSED VAR. AND STORES THE\n*                        NEW ENDING ADDRESS OF THE BLOCK IN AITAB\n*                   RETURNS TO PROCESS NEXT VAR.\n         SPACE 2\nENDVAR   MVC   WORK(6),0(RAID)     MOVE EXTERNAL NAME\n         TR    WORK(6),TRTAB\n         MVC   SAVE2+1(1),10(RAID) MOVE\n         MVN   SAVE2(1),9(RAID)    AND\n         UNPK  SAVE3(5),SAVE2(3)        CONVERT DISP. OR LABELNUMBER\n         TR    SAVE3+1(3),TAB-X'EF'     TO BE WRITTEN OUT\n         MVC   WORK+16(3),SAVE3+1\n         EX    REG0,MOVEVAR(REGC)  MOVE OUT WORK TO PRINTAREA\n         MVI   WORK,C' '          CLEAR WORKAREA\n         MVC   WORK+1(29),WORK\n         LA    REGC,8(0,REGC)\n         C     REGC,TWOFOUR        Q. TIME TO PRINT\n         BNE   *+8                 NO\n         BAL   REGB,PRINTITB       YES- CALL FOR PRINTROUTINE\nENDVAR2  L     REGY,AITAB\n         LA    REGB,12(0,RAID)          LEN. TO MOVE ITAB UP TO\n         C     REGB,AITAB               Q. NOTHING TO MOVE\n         BNH   *+12\n         ST    RAID,AITAB          STOREADD. OF CURRENT AS END ADD.\n         B     GETNVAR\n         SR    REGY,REGB           CALCULATE NEW END ADDRESS OF THE\n         LA    REGB,1(REGY,RAID)   BLOCKAND STORE IT IN AITAB\n         ST    REGB,AITAB\nCOMPARE  C     REGY,D256\n         BNH   EX1\n         MVC   0(256,RAID),11(RAID)     TRANSFER A 256 BYTE SECTION\n         LA    RAID,256(0,RAID)         OF THE BLOCK AT THE TIME\n         S     REGY,D256\n         B     COMPARE\nEX1      EX    REGY,MOVEITAB            MOVE LAST PARTIAL SECTION\n         B     GETNVAR\n         SPACE 2\n*****   ENDBLOCK *****\n*                   PRINTS LAST LINE OF BLOCK, IF NEEDED\n*                   EXITS TO GETPB IF ANY BLOCK LEFT TO BE PROCESSED\n*                   OTHERWISE A FREEMAIN IS DONE AND IEX21 IS LINKED\n*                        TO\n         SPACE 2\nENDBLOCK C     REGC,ZERO           Q VAR LEFT TO BE WRITTEN OUT\n         BE    *+8\n         BAL   REGB,PRINTITB\n         LA    REGB,1(0,REGP)\n         CH    REGB,PBN            Q ALL BLOCKS PROCESSED\n         BNH   GETPB               NO- TAKE NEXT\nSLUT     L     REGI,ITAB20S        ITAB AREA\n         LA    REGI,1024(0,REGI)   AND ATAB AREA ARE MADE\n         LR    REG0,REGI           FREEMAIN FOR\n         L     REGI,AREALOC\n         FREEMAIN R,LV=(0),A=(1)\nSLUT2    XCTL  EP=IEX21000\nHDING1   DC    C'IDENTIFIER TABLE'\nHEAD1    DC    CL90'PBN SC    PBN      NAME   TYPE  DM DSP       NAME  X\n                TYPE  DM DSP       NAME   TYPE  DM DSP'\nHEAD2    DC    CL90'          SURR                  PR LN              X\n                      PR LN                     PR LN '\nSCSAVE   DS    H                  SAVE SEMICOLON COUNTER\nD256     DC    F'256'             USED BY MOVE LOOP\nSAVE2    DC    C'000'             USED FOR CONVERTION\nSAVE3    DC    5X'EF'\nDOUBLE   DC    D'0'\nMOVEITAB MVC   0(1,RAID),11(RAID)     USED BY ENDVAR\nWORK     DC    30C' '        USED TO BUILD PRINT REC.\nFOURK    DC    F'4095'            STORAGE ALLOCATION MAXIMUM\nMOVEVAR  MVC   19(27,REGI),WORK     USED TO SORT REC. TO BE PRINTED\n         CNOP  0,4\n         MVC   45(27,REGI),WORK\n         CNOP  0,4\n         MVC   71(19,REGI),WORK\nTWOFOUR  DC    F'24'              USED BY ENDVAR\nC        DC    H'8'      INCREASE VALUE DURING STORAGE ALLOCATION\n*                            USED TO TRANSLATE FROM INTERNAL\n*                            TO EBCDIC CODE\nTRTAB    DS    0CL90\n         DC    C' '\n         DC    47C')'\n         DC    C'0123456789'\n         DC    6C')'\n         DC    C'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\nTAB      DC    C' 0123456789ABCDEF'    FOR PRINTABLE HEXADECIMAL\nELEVEN   DC    X'000B'\nWORKAREA DSECT\n         COPY  WORKAREA\nKOPOOL   DS    F                  ZERO CONSTANT\nZERO     EQU   KOPOOL\nSAVE     DS    F\nSAVE1    DS    4F\nAPBTAB2  DS    A                  START ADD. OF PBTAB2\nATABAD   DS    A                  START ADD. OF ATAB\nDPC      DS    F                  SAVE AREAS FOR DP, WP, HP AND BP\nWPC      DS    F\nHPC      DS    F\nBPC      DS    F\nAITAB    DS    F                  ITAB ADDRESS\nAPRNTAR  DS    A                  ADDRESS OF CURRENT PRINTAREA\nAREALOC  DS    A                  ADDRESS OF GETMAIN POOL\nSAVEPB   DS    F                  COUNTS NR. OF BLOCKS READ\nLENCOUNT DS    H                  SAVES LENGTH OF BLOCK\nBITS1    DS    C\nPROCBIT  EQU   X'02'              PROCEDURE IS PROCESSED\nPROCOFF  EQU   X'FD'\n         END   IEX20000\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IEX21": {"ttr": 3589, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x98\\x01/\\x00\\x98\\x01/\\x16 \\x00i\\x00i\\x00\\x00\\xd6\\xf3\\xf6\\xf0`\\xf2\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1998-01-12T00:00:00", "modifydate": "1998-01-12T16:20:00", "lines": 105, "newlines": 105, "modlines": 0, "user": "O360-20"}, "text": " TITLE 'IEX21, ERROR MESSAGE EDITING'\n*                                                                     *\n*STATUS: CHANGE LEVEL 000.                                            *\n*                                                                     *\n*FUNCTION/OPERATION: THE ERROR PATTERNS GENERATED DURING SCANI/II     *\n*   AND ITAB-MANIPULATION ARE HANDLED AND THE CORRESPONDING DIAGNOSTIC*\n*   MESSAGES ARE GENERATED.                                           *\n*                                                                     *\n*ENTRY POINT:                                                         *\n*        IEX21000 - ERROR MESSAGE EDITING         XCTL EP=IEX21       *\n*   THE MODULE IS ENTERED FROM IEX20.                                 *\n*                                                                     *\n*INPUT: N/A                                                           *\n*                                                                     *\n*OUTPUT: THE DIAGNOSTIC MESSAGES ARE PUT OUT ON SYSPRINT. IF SYSPRINT *\n*   IS DOWN THIS IS REPORTED ON THE CONSOLE TYPEWRITER.               *\n*                                                                     *\n*EXTERNAL ROUTINE: THE PRINT ROUTINE IN IEX00 IS USED.                *\n*                                                                     *\n*EXIT-NORMAL: IF NO TERMINATING ERROR HAS OCCURRED, CONTROL IS GIVEN  *\n*   TO THE NEXT PHASE BY MEANS OF  XCTL EP=IEX30000.                  *\n*                                                                     *\n*EXIT-ERROR: IF A TERMINATING ERROR HAS OCCURRED (IN THIS MODULE OR   *\n*   ONE OF THE PRECEDING) CONTROL IS GIVEN TO THE TERMINATING MODULE  *\n*   BY MEANS OF  XCTL EP=IEX51002.                                    *\n*                                                                     *\n*TABLES/WORKAREAS: THE MESSAGE TEXTS WITH CORRESPONDING ADDRESS TABLE *\n*   ARE IN THE LOAD MODULE IEX21M.                                    *\n*   THE ERROR MESSAGE EDITING ROUTINE, CSECT IEX60000, ALSO USES THE  *\n*   FOLLOWING TABLES:                                                 *\n*   WINTEBC   FOR TRANSLATION OF INTERNAL CHARACTERS TO EBCDIC        *\n*   WSYMBSRC  FOR TRANSLATION OF                                      *\n*   WSYMBSTK                     INTERNAL SYMBOLS TO EBCDIC           *\n*   WORDSEBC  FOR TRANSLATION OF COMPOUND SYMBOLS IF SOURCE IN EBCDIC *\n*   WORDSISO  FOR TRANSLATION OF COMPOUND SYMBOLS IF SOURCE IN ISOCODE*\n*   WEBCDIC   FOR TRANSLATION EBCDIC-EBCDIC                           *\n*                                                                     *\n*   A WORKAREA OF 270 BYTES, WAREA, IS USED FOR BUILDING THE MESSAGES.*\n*                                                                     *\n*ATTRIBUTES: NONE.                                                    *\n*                                                                     *\n*NOTES: CHARACTER CODE DEPENDENCE: FOR THE BUILDING OF A MESSAGE      *\n*   (CODE PART BETWEEN COT03 AND COT12) THE FOLLOWING APPLIES:        *\n*   IN CASE NO SOURCE INFORMATION IS TO BE INSERTED (COT31), OR IF    *\n*   THE INFORMATION IS EBCDIC-CHARACTERS (COT07), THE OPERATION OF    *\n*   CSECT IEX60000 DEPENDS UPON AN INTERNAL REPRESENTATION OF THE     *\n*   EXTERNAL CHARACTER SET WHICH IS EQUIVALENT TO THE ONE USED AT     *\n*   ASSEMBLY TIME.                                                    *\n*   IF THE SOURCE INFORMATION TO BE INSERTED IS INTERNAL CHARACTERS   *\n*   (COT33) THE OPERATION OF CSECT IEX60000 DEPENDS UPON A TRANSLATION*\n*   FROM THE INTERNAL REPRESENTATION TO THE EBCDIC CHARACTER SET BY   *\n*   MEANS OF THE TABLE 'WINTEBC'.                                     *\n*   IF THE SOURCE INFORMATION TO BE INSERTED IS INTERNAL ALGOL SYMBOLS*\n*   (COT10) THE OPERATION OF CSECT IEX60000 DEPENDS UPON A TRANSLATION*\n*   FROM THE INTERNAL REPRESENTATION TO THE EBCDIC CHARACTER SET BY   *\n*   MEANS OF THE TABLES 'WSYMBSTK'/'WSYMBSRC' AND 'WORDSISO'/         *\n*   'WORDSEBC'.                                                       *\n*   FOR THE OUTPUT OF A MESSAGE (CODE PART BETWEEN COT12 AND COT21)   *\n*   THE FOLLOWING APPLIES:                                            *\n*   WHEN A MESSAGE HAS BEEN BUILT IN EBCDIC, AN EBCDIC-EBCDIC TRANSLA-*\n*   TION IS PERFORMED BEFORE OUTPUT BY MEANS OF THE TABLE 'WEBCDIC'.  *\n*   THUS THE OUTPUT MAY BE MODIFIED BY MAKING CHANGES IN THIS TABLE.  *\n*                                                                     *\n*   THE OPERATION OF CSECT IEX21000 DOES NOT DEPEND UPON A PARTICULAR *\n*   INTERNAL REPRESENTATION OF THE EXTERNAL CHARACTER SET.            *\n*                                                                     *\n*   AT SYSTEM GENERATION THIS MODULE WILL BE LINKED TOGETHER WITH     *\n*   THE MODULE IEX21M TO FORM THE MODULE IEX21 IN LINKLIB.            *\n*                                                                     *\n*   THIS MODULE IS ONLY INTENDED TO BE EXECUTED IN CONNECTION         *\n*   WITH THE OTHER MODULES OF THE ALGOL COMPILER. IN PARTICULAR IT    *\n*   REQUIRES THE COMMON WORKAREA.                                     *\n*                                                                     *\n         EJECT\nIEX21000 CSECT\n         SPACE\n* REGISTER DEFINITIONS\n         SPACE\nRINFO    EQU   1\nRCOT     EQU   2\nRET      EQU   14\nRENT     EQU   15\n         SPACE 2\n         USING *,RENT\n         SPACE\n         L     RCOT,=A(IEX60000)        ADDRESS ERROR MSG EDIT ROUTINE\n         LA    RET,SCAN3                LOAD RETURN ADDRESS\n         LA    RINFO,ERRINFO            ADDRESS INFO FOR ERROR ED ROUT\n         BR    RCOT                     GO TO ERROR MESSAGE EDITING\n         SPACE 2\n         DS    0F\nSCAN3    EQU   *                   INITIALIZATION OF SCAN III\n         XCTL  EP=IEX30000\n         SPACE 2\nERRINFO  DC    V(IEX21M00)              ADDRESS OF MESSAGE TEXTS\n         DC    V(IEX21M01)              ADDRESS OF ADDRESS-TABLE\n         DC    H'152'                   MODIFICATION NUMBER\n         SPACE\n         LTORG\n         EJECT\n         COPY  IEX60000\n         EJECT\nWORKAREA DSECT\n         COPY  WORKAREA\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IEX21M": {"ttr": 3592, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x98\\x01/\\x00\\x98\\x01/\\x16 \\x01\\x1a\\x01\\x1a\\x00\\x00\\xd6\\xf3\\xf6\\xf0`\\xf2\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1998-01-12T00:00:00", "modifydate": "1998-01-12T16:20:00", "lines": 282, "newlines": 282, "modlines": 0, "user": "O360-20"}, "text": " TITLE 'IEX21M, ERROR MESSAGE TEXT POOL 1'\n*                                                                     *\n*STATUS: CHANGE LEVEL 000.                                            *\n*                                                                     *\n*FUNCTION/OPERATION: THIS MODULE CONTAINS MESSAGE TEXTS FOR ALL       *\n*   ERRORS THAT MAY BE DETECTED BY IEX00, IEX10, IEX11, AND IEX20,    *\n*   AND THE CORRESPONDING ADDRESS TABLE.                              *\n*                                                                     *\n*ENTRY POINT: N/A.                                                    *\n*                                                                     *\n*INPUT: N/A.                                                          *\n*                                                                     *\n*OUTPUT: N/A.                                                         *\n*                                                                     *\n*EXTERNAL ROUTINES: N/A.                                              *\n*                                                                     *\n*EXITS-NORMAL: N/A.                                                   *\n*                                                                     *\n*EXITS-ERROR: N/A.                                                    *\n*                                                                     *\n*TABLES/WORKAREAS: N/A.                                               *\n*                                                                     *\n*ATTRIBUTES: N/A.                                                     *\n*                                                                     *\n*NOTES: AT SYSTEM GENERATION THIS MODULE WILL BE LINKED TOGETHER WITH *\n*   THE MODULE IEX21 TO FORM THE MODULE IEX21 IN LINKLIB.             *\n*                                                                     *\nIEX21M00 CSECT\n         SPACE\n         ENTRY IEX21M01\n         SPACE\nWEMPOOL1 EQU   *                   ERROR MESSAGE POOL 1\n         SPACE\nW001     DC    X'1C00'\n         DC    CL27'WINVALID CHARACTER DELETED.'\nW002     DC    X'2100'\n         DC    CL32'WILLEGAL PERIOD. PERIOD DELETED.'\nW003     DC    X'2F0300130C240020000F20'\n         DC    CL37'WINVALID COLON AFTER . COLON DELETED.'\nW004     DC    X'1900'\n         DC    CL24'TLETTER STRING TOO LONG.'\nW005     DC    X'3F00'\n         DC    CL62'SIDENTIFIER BEGINS WITH INVALID CHARACTER. IDENTIFIX\n               ER DELETED.'\nW006     DC    X'2500'\n         DC    CL36'TLABEL CONTAINS TOO MANY CHARACTERS.'\nW007     DC    X'5005001412240027001B27F00000000D43'\n         DC    CL64'WLABEL BEGINNING WITH  CONTAINS INVALID CHARACTER.CX\n               OLON DELETED.'\nW008     DC    X'3500'\n         DC    CL52'WLABEL BEGINS WITH INVALID CHARACTER. COLON DELETEDX\n               .'\nW010     DC    X'3703001F0C24002C000B2C'\n         DC    CL45'SSPECIFICATION PART OF PROCEDURE  INCOMPLETE.'\nW011     DC    X'2800'\n         DC    CL39'SPROGRAM STARTS WITH ILLEGAL DELIMITER.'\nW012     DC    X'3C0300150C240022001A22'\n         DC    CL50'WTWO APOSTROPHES AFTER . FIRST APOSTROPHE DELETED.'\nW013     DC    X'3E0300310C24003E00003E'\n         DC    CL52'WAPOSTROPHE ASSUMED AFTER DELIMITER BEGINNING WITH X\n               .'\nW014     DC    X'470300180C240025002225'\n         DC    CL61'SDELIMITER BEGINNING WITH  INVALID. FIRST APOSTROPHX\n               E DELETED.'\nW015     DC    X'3400'\n         DC    CL51'WMISSING SEMICOLON AFTER ''CODE''. SEMICOLON ASSUMEX\n               D.'\nW016     DC    X'5A0500191224002C001B2CF00000001248'\n         DC    CL74'SIDENTIFIER BEGINNING WITH  CONTAINS INVALID CHARACX\n               TER.IDENTIFIER DELETED.'\nW017     DC    X'3E00'\n         DC    CL61'SMORE THAN 65535 SEMICOLONS. SEMICOLON COUNTER RESEX\n               T TO ZERO.'\nW018     DC    X'2A00'\n         DC    CL41'WDELIMITER ''COMMENT'' IN ILLEGAL POSITION.'\nW020     DC    X'6200'\n         DC    CL97'TBLOCKS, COMPOUND STATEMENTS, FOR STATEMENTS AND PRX\n               OCEDURE DECLARATIONSNESTED TO TOO MANY LEVELS.'\nW021     DC    X'2B03000A0C240017001417'\n         DC    CL33'SDECLARATOR  IN ILLEGAL POSITION.'\nW022     DC    X'1F00'\n         DC    CL30'TMORE THAN 255 PROGRAM BLOCKS.'\nW023     DC    X'1700'\n         DC    CL22'SSTRING POOL OVERFLOW.'\nW024     DC    X'3700'\n         DC    CL54'SDELIMITER ''CODE'' IN ILLEGAL POSITION. ''CODE'' DX\n               ELETED.'\nW025     DC    X'530300310CF0000000153E'\n         DC    CL73'SSPECIFIER ''STRING'' OR ''LABEL'' IN ILLEGAL POSITX\n               ION.SPECIFICATION DELETED.'\nW026     DC    X'430300090C240016002D16'\n         DC    CL57'WPARAMETER  MULTIPLY SPECIFIED. FIRST SPECIFICATIONX\n                USED.'\nW027     DC    X'550500091224001C00231CF00000001540'\n         DC    CL69'SPARAMETER  MISSING FROM FORMAL PARAMETER LIST.SPECX\n               IFICATION IGNORED.'\nW028     DC    X'3E00'\n         DC    CL61'SDELIMITER ''VALUE'' IN ILLEGAL POSITION. ''VALUE''X\n                PART DELETED.'\nW029     DC    X'2900'\n         DC    CL40'WSPECIFICATION PART PRECEDES VALUE PART.'\nW030     DC    X'2D0300090C240016001716'\n         DC    CL35'WPARAMETER  REPEATED IN VALUE PART.'\nW031     DC    X'660500391224004C00004CF0000000194D'\n         DC    CL86'WLEFT PARENTHESIS NOT FOLLOWED BY / AFTER ARRAY IDEX\n               NTIFIER .SUBSCRIPT BRACKET ASSUMED.'\nW032     DC    X'5C05003512240048000048F00000001349'\n         DC    CL76'SMISSING RIGHT PARENTHESIS IN BOUND PAIR LIST OF ARX\n               RAY .DECLARATION DELETED.'\nW033     DC    X'440300370C240044000044'\n         DC    CL58'TMORE THAN 16 DIMENSIONS OR COMPONENTS IN DECLARATIX\n               ON OF .'\nW034     DC    X'6805000D12240020002320F00000002444'\n         DC    CL88'SARRAY SEGMENT  NOT FOLLOWED BY SEMICOLON OR COMMA.X\n               CHARACTERS TO NEXT SEMICOLON DELETED.'\nW035     DC    X'3900'\n         DC    CL56'WILLEGAL PERIOD IN ARRAY OR SWITCH LIST. PERIOD DELX\n               ETED.'\nW036     DC    X'360300290C240036000036'\n         DC    CL44'TMORE THAN 15 PARAMETERS IN DECLARATION OF .'\nW037     DC    X'6805003012240043000043F00000002444'\n         DC    CL88'SSEMICOLON MISSING AFTER FORMAL PARAMETER LIST OF .X\n               CHARACTERS TO NEXT SEMICOLON DELETED.'\nW038     DC    X'2B00'\n         DC    CL42'TTOO MANY IDENTIFIERS DECLARED IN A BLOCK.'\nW039     DC    X'790484000F00390FF00000003049'\n         DC    CL108'S MISSING ''END'' BRACKETS. OPEN BLOCKS, COMPOUND X\n               STATEMENTS,FOR STATEMENTS AND PROCEDURE DECLARATIONS CLOX\n               SED.'\nW041     DC    X'1F00'\n         DC    CL30'TMORE THAN 255 FOR STATEMENTS.'\nW042     DC    X'3A00'\n         DC    CL57'W''BEGIN'' PRECEDES PRECOMPILED PROCEDURE. ''BEGIN'X\n               ' DELETED.'\nW043     DC    X'5E0300300CF0000000213D'\n         DC    CL84'SEQUAL NUMBER OF ''BEGIN'' AND ''END'' BRACKETS FOUX\n               ND.REMAINING PART OF PROGRAM IGNORED.'\nW044     DC    X'1A00'\n         DC    CL25'TNO SOURCE PROGRAM FOUND.'\nW045     DC    X'4003000A0C240017002917'\n         DC    CL54'SIDENTIFIER  MULTIPLY DECLARED. LAST DECLARATION USX\n               ED.'\nW045B    DC    X'300300230C240030000030'\n         DC    CL38'SILLEGAL CALL BY VALUE OF IDENTIFIER .'\n         SPACE\n*\n* DIRECTORY MESSAGES, INITIATION PHASE\n*\n         SPACE\nW200     EQU   *\nW046     DC    X'380300100C84001D001B1D'\n         DC    CL46'WOPTION PARAMETER  INVALID. PARAMETER IGNORED.'\nW201     EQU   *\nW047     DC    X'2D03000B0C840018001518'\n         DC    CL35'TDD CARD FOR  INCORRECT OR MISSING.'\nW202     EQU   *\nW048     DC    X'4100'\n         DC    CL64'WDD CARD FOR SYSLIN INCORRECT OR MISSING. OPTION NOX\n               LOAD ASSUMED.'\nW203     EQU   *\nW049     DC    X'4300'\n         DC    CL66'WDD CARD FOR SYSPUNCH INCORRECT OR MISSING. OPTION X\n               NODECK ASSUMED.'\nW204     EQU   *\nW050     DC    X'2A00'\n         DC    CL41'TBLOCKSIZE SPECIFIED FOR SYSIN INCORRECT.'\nW205     EQU   *\nW051     DC    X'480300170C840024002424'\n         DC    CL62'WBLOCKSIZE SPECIFIED FOR  INCORRECT. UNBLOCKED OUTPX\n               UT ASSUMED.'\nW206     EQU   *\nW052     DC    X'4200'\n         DC    CL65'WTOO MANY OPTION PARAMETER ERRORS. SUBSEQUENT PARAMX\n               ETERS IGNORED.'\nW207     EQU   *\nW053     DC    X'2700'\n         DC    CL38'WPOSSIBLE ERROR IN DD NAMES PARAMETER.'\nW208     EQU   *\nW054     DC    X'2D00'\n         DC    CL44'WSIZE PARAMETER INVALID. SIZE 45056 ASSUMED.'\n         SPACE\n*\n* OTHER DIRECTORY MESSAGES\n*\n         SPACE\nW209     EQU   *\nW055     DC    X'460400360FF00000840046000046'\n         DC    CL57'TCOMPILATION UNSUCCESSFUL DUE TO PROGRAM INTERRUPT.X\n                PSW .'\nW056     EQU   *\nW210     EQU   *\n         DC    X'300300230C840030000030'\n         DC    CL38'TUNRECOVERABLE I/O ERROR ON DATA SET .'\nW057     EQU   *\nW211     EQU   *\n         DC    CL56'PROGRAM INTERRUPT IN ERROR MESSAGE EDITING ROUTINE.X\n                PSW '\nW058     EQU   *\nW212     DC    X'1200'\n         DC    CL17'TTOO MANY ERRORS.'\nW059     EQU   *\nW213     DC    X'2800'\n         DC    CL39'TINTERNAL OVERFLOW OF IDENTIFIER TABLE.'\nW060     EQU   *\nW214     DC    X'3903002D0C84003A00003A'\n         DC    CL48'SDATA STORAGE AREA EXCEEDED, PROGRAM BLOCK NO. .'\nW215     EQU   *\nW061     DC    X'1A00'\n         DC    CL25'TSOURCE PROGRAM TOO LONG.'\nW216     DC    X'2600'\n         DC    CL37'STOO MANY LABELS. LABEL NUMBER RESET.'\n         EJECT\n         DS    0F\n         SPACE 2\nIEX21M01 EQU   *                   ADDRESS TABLE FOR WEMPOOL1\n         SPACE\n         DC    F'0'\n         DC    A(W001)\n         DC    A(W002)\n         DC    A(W003)\n         DC    A(W004)\n         DC    A(W005)\n         DC    A(W006)\n         DC    A(W007)\n         DC    A(W008)\n         DS    A\n         DC    A(W010)\n         DC    A(W011)\n         DC    A(W012)\n         DC    A(W013)\n         DC    A(W014)\n         DC    A(W015)\n         DC    A(W016)\n         DC    A(W017)\n         DC    A(W018)\n         DC    F'0'\n         DC    A(W020)\n         DC    A(W021)\n         DC    A(W022)\n         DC    A(W023)\n         DC    A(W024)\n         DC    A(W025)\n         DC    A(W026)\n         DC    A(W027)\n         DC    A(W028)\n         DC    A(W029)\n         DC    A(W030)\n         DC    A(W031)\n         DC    A(W032)\n         DC    A(W033)\n         DC    A(W034)\n         DC    A(W035)\n         DC    A(W036)\n         DC    A(W037)\n         DC    A(W038)\n         DC    A(W039)\n         DS    F\n         DC    A(W041)\n         DC    A(W042)\n         DC    A(W043)\n         DC    A(W044)\n         DC    A(W045)\n         DC    F'0'\n         DC    A(W045B)\n         DC    A(W046)\n         DC    A(W047)\n         DC    A(W048)\n         DC    A(W049)\n         DC    A(W050)\n         DC    A(W051)\n         DC    A(W052)\n         DC    A(W053)\n         DC    A(W054)\n         DC    A(W055)\n         DC    A(W056)\n         DC    A(W057)\n         DC    A(W058)\n         DC    A(W059)\n         DC    A(W060)\n         DC    A(W061)\n         DC    A(W216)\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IEX30": {"ttr": 3841, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x98\\x01/\\x00\\x98\\x01/\\x16 \\x0bv\\x0bv\\x00\\x00\\xd6\\xf3\\xf6\\xf0`\\xf2\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1998-01-12T00:00:00", "modifydate": "1998-01-12T16:20:00", "lines": 2934, "newlines": 2934, "modlines": 0, "user": "O360-20"}, "text": " TITLE 'IEX30, SCAN III'\n*                                                                     *\n*STATUS: CHANGE LEVEL 000.                                            *\n*                                                                     *\n*FUNCTION/OPERATION: THE SOURCE PROGRAM IS TRANSFORMED FROM MODIFICA- *\n*   TION LEVEL 1 INTO MODIFICATION LEVEL 2. MAIN FUNCTIONS: EXTERNAL  *\n*   NAMES OF IDENTIFIERS ARE REPLACED BY THE INTERNAL NAMES CONTAINED *\n*   IN THE ITAB-ENTRY OF THE IDENTIFIER, AND CONSTANTS ARE REPLACED BY*\n*   INTERNAL NAMES CONSTRUCTED IN IEX30.                              *\n*   OBJECT CODE IS PRODUCED FROM THE CONSTANT POOL IF ANY OF THE PARA-*\n*   METERS DECK OR LOAD IS SPECIFIED IN THE EXEC-CARD.                *\n*   FOR STATEMENTS ARE CLASSIFIED FOR FUTHER USE BY IEX50.            *\n*   THE SUBSCRIPT TABLE (SUTAB)AND THE LEFT VARIABLE TABLE (LVTAB) ARE*\n*   CONSTRUCTED FOR FUTHER USE BY IEX40.                              *\n*   SOURCE PROGRAM ERRORS CAUSES GENERATION OF ERROR PATTERNS FOR     *\n*   FUTHER USE BY 1EX31.                                              *\n*                                                                     *\n*ENTRY POINT:                                                         *\n*        IEX30000.                                                    *\n*                                                                     *\n*INPUT: THE SOURCE PROGRAM MODIFICATION LEVEL 1 IS READ IN FROM       *\n*   SYSUT1.                                                           *\n*   THE IDENTIFIER TABLE (ITAB) IS READ IN FROM SYSUT3.               *\n*                                                                     *\n*OUTPUT: THE SOURCE PROGRAM MODIFICATION LEVEL 2 IS WRITTEN OUT ON    *\n*   SYSUT2.                                                           *\n*   OBJECT TXT-RECORDS IS WRITTEN ON SYSLIN OR/AND SYSPUNCH IF THE    *\n*   PARAMETERS LOAD OR/AND DECK ARE SPECIFIED IN THE EXEC-CARD.       *\n*   THE SUBSCRIPT TABLE (SUTAB) IS WRITTEN OUT ON SYSUT3. A LINEAR    *\n*   SUBSCRIPT EXPRESSION ENCOUNTED IN A FOR STATEMENT THAT IS OPTIMI- *\n*   ZABLE IN REGARD TO SUBSCRIPTS WILL GENERATE AN ENTRY IN THIS      *\n*   TABLE.                                                            *\n*   THE LEFT VARIABLE TABLE (LVTAB) IS WRITTEN OUT ON SYSUT3. INTEGER *\n*   LEFT VARIABLES ENCOUNTED IN FOR STATEMENT THAT IS OPTIMIZABLE IN  *\n*   REGARD TO SUBSCRIPTS WILL GENERATE AN ENTRY IN THIS TABLE.        *\n*                                                                     *\n*EXTERNAL ROUTINES: THE INTERRUPT ROUTINE OF IEX00 ARE USED FOR ALL   *\n*   INTERRUPTS EXCEPT FLOATING POINT OVERFLOW.                        *\n*                                                                     *\n*EXITS-NORMAL: CONTROL IS ALWAYS GIVEN TO IEX31 BY MEANS OF           *\n*        XCTL  EP=IEX31.                                              *\n*                                                                     *\n*TABLES/WORKAREAS: GROUP TABLE (GPTAB) CONSTRUCTED IN IEX11, USED TO  *\n*   DIAGNOSE BRANCHES INTO FOR STATEMENTS.                            *\n*   SCOPE TABLE (SPTAB) CONSTRUCTED IN IEX11, USED TO CHECK SUBSCRIPT *\n*   EXPRESSIONS FOR POSSIBLE OPTIMIZATION.                            *\n*   FOR STATEMENT TABLE (FSTAB) CONSTRUCTED IN IEX30 COMPLEATED IN    *\n*   IEX40 AND FINALLY USED IN IEX50, CONTAINS A CLASSIFICATION BYTE   *\n*   FOR EVERY FOR STATEMENT                                           *\n*   ERROR POOL CONSTRUCTED IN IEX30 AND USED IN IEX31, CONTAINS ERROR *\n*   PATTERNS GENERATED FROM SOURCE PROGRAM ERRORS.                    *\n*   CONSTANT POOL INTERNAL TABLE IN IEX30. THE FIRST APPEARANCE OF A  *\n*   CONSTANT IN THE SOURCE STREAM GENERATES AN ENTRY IN THE TABLE. THE*\n*   RELATIVE ADDRESS OF THE CONSTANT POOL ENTRY IS USED IN CONSTRUCT- *\n*   ING THE INTERNAL NAME OF A CONSTANT.                              *\n*   CRITICAL VARIABLE TABLE (CRIDTAB) INTERNAL TABLE IN IEX30. DURING *\n*   THE TREATMENT OF A FOR STATEMENT THE TABLE CONTAINS ENTRIES       *\n*   CORRESPONDING TO THE IDENTIFIERS IN THE FOR LIST.                 *\n*                                                                     *\n*ATTRIBUTES: NONE.                                                    *\n*                                                                     *\n*NOTES: THE OPERATION OF THIS MODULE DOES NOT DEPEND ON ANY SPECIAL   *\n*   REPRESENTATION OF THE CHARACTER SET.                              *\n*   THIS MODULE IS ONLY INTENDED TO BE EXECUTED IN CONNECTION         *\n*   WITH THE OTHER MODULES OF THE ALGOL COMPILER. IN PARTICULAR IT    *\n*   REQUIRES THE COMMON WORKAREA.                                     *\n*                                                                     *\n         EJECT\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nZINR     EQU   3                        INPUT RECORD POINTER REGISTER\nZOUR     EQU   4                        OUTPUT RECORD POINTER REGISTER\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10                       BASE REGISTER\nR11      EQU   11                       BASE REGISTER\nR12      EQU   12                       BASE REGISTER\nWAREG    EQU   13                       WORKAREA BASE REGISTER\nR14      EQU   14\nR15      EQU   15\nWORKR    EQU   R5\nWORKX    EQU   R6\n         SPACE\n*              LENGTHS OF VARIABEL AREAS\nFIXITABL EQU   319                      LENGTH OF ITAB FIXED PART\n         SPACE\n*              BIT PATTERNS\nONEREC   EQU   X'40'                    SOURCE INPUT IN CORE STORAGE\nMANYREC  EQU   X'BF'                    SOURCE INPUT ON SYSUT1\nSYNTAX   EQU   X'80'                    SYNTAX CHECK MODE\nSARRAY   EQU   X'80'                    HANDLING ARRAY DECLARATION\nSSWITCH  EQU   X'40'                    HANDLING SWITCH DECLARATION\nFF       EQU   X'FF'\n         SPACE\n*                                       SCALE FACTOR MASKS\nSFSIGN   EQU   X'80'                    SIGNED SCALE FACTOR\nSFL0     EQU   X'40'                    LEADING ZERO IN SCALE FACTOR\nSF19     EQU   X'20'                    SIGNIFICANT DIGIT IN SCALE FAC.\nSF       EQU   X'10'                    SCALE FACTOR PRESENT\nSFDIGIT  EQU   X'60'\nSFLSIGN  EQU   X'E0'\nPRECERR  EQU   X'08'                    REAL CONSTANT EXCEEDS PRECITION\n         SPACE\n*              CLASSIFICATION MASKS OF I/O STATUS ON SYSUT3\nREADM    EQU   X'80'                    UNCHECKED READ OPERATION\nWRITEM   EQU   X'40'                    UNCHECKED WRITE OPERATION\nREADC    EQU   X'20'                    CHECKED READ OPERATION\nWRITEC   EQU   X'10'                    CHECKED WRITE OPERATION\n         SPACE\n*              FOR STATEMENT CLASSIFICATION MASKS\nNOCOUNT  EQU   X'80'                    COUNTING LOOP IMPOSSIBLE\nNOSUOP   EQU   X'40'                    NO SUBSCRIPT OPTIMIZATION\nOUTOFFOR EQU   X'20'                    BRANCH OUT OF FOR STATEMENT\nNORMAL   EQU   X'F0'                    NORMAL LOOP\nSTEPM    EQU   X'08'                    STEP IN FORLIST\nWHILEM   EQU   X'84'                    WHILE IN FOR LIST\n         EJECT\nIEX30000 CSECT\n*3491                                                              1511\n*3491265600                                                        1513\n* RELEASE 20 CHANGES                                             A32962\n* 205400-206400                                                  A32962\nSTART    BALR  R12,0\n         USING *,R12\n         USING IEX30001,R11\n         USING IEX30002,R10\n         USING WORKAREA,WAREG\n         L     R11,ASEC1\n         L     R10,ASEC2\n         B     INITIATE\n         EJECT\nZERO     DC    3H'0'\nONE      DC    H'1'\nFIVE     DC    H'5'\nSEVEN    DC    H'7'\nEIGHT    DC    H'8'\nNINE     DC    H'9'\nTEN      DC    H'10'\nELEVEN   DC    H'11'\nTWELVE   DC    H'12'\nFIFTEEN  DC    H'15'\nEIGHTEEN DC    H'18'\nFIVSIX   DC    H'56'\nSIXFOUR  DC    H'64'\nTWOFIVFI DC    H'255'\nC1792    DC    H'1792'\nFOURK    DC    H'4096'\n         SPACE\n*              ERROR MESSAGE NUMBERS\nINVOP    DC    H'80'                    SYNTAX ERROR IN OPERAND\nUNDEFOP  DC    H'81'                    UNDEFINED IDENTIFIER\nRANGEREA DC    H'82'                    REAL CONSTANT OUT OF RANGE\nRANGEINT DC    H'83'                    INTEGER OUT OF RANGE\nPRECREAL DC    H'84'                    PRECITION OF REAL TOO GREAT\nGOTOFOR  DC    H'85'                    GO TO INTO FOR STATEMENT\nMANYCON  DC    H'86'                    TOO MANY CONSTANTS\nTABOVER  DC    H'87'                    OPTIMIZATION TABLE OVERFLOW\nARRAYERR DC    H'88'                    INVALID ARRAY LIST IDENTIFIER\nSWITCHER DC    H'89'                    SWITCH DECLARATION ERROR\nITABOVER DC    H'213'                   ITAB OVERFLOW\nTOOMANY  EQU   212                      TOO MANY ERRORS\nTOOLONG  DC    H'215'                   TOO MUCH SOURCE OUTPUT\n         SPACE\n*              SUBSCRIPT TABLE\nZSUTAPO  DS    F                        CURRENT SUTAB PT\nZSUDAD   DS    F                        ADDRESS OF FIRST SUTAB ENTRY\nZSUTMAX  DS    F                        SUTAB END PT\nSUSTRT   DS    F                        START ADDRESS OF SUTAB RECORD\nSUKEY    DC    C'SUTB'                  SUTAB RECORD IDENTIFICATION\nSULENGTH DC    F'0'                     ACCUMULATED LENGTH OF SUTAB\nSUCNT    DC    H'0'                     NUMBER OF WRITTEN SUTAB RECORDS\n         SPACE\n*              LEFT VARIABLE TABLE\nZLESTA   DS    F                        ADDRESS OF FIRST LVTAB ENTRY\nZLEVA    DS    F                        CURRENT LVTAB PT\nZLEMAX   DS    F                        LVTAB END PT\nLVSTRT   DS    F                        START ADDRESS OF LVTAB RECORD\nLVKEY    DC    C'LVTB'                  LVTAB RECORD IDENTIFICATION\nLVLENGTH DC    F'0'                     ACCUMULATED LENGTH OF LVTAB\nLVCNT    DC    H'0'                     NUMBER OF WRITTEN LVTAB RECORDS\n         SPACE\n*              INPUT RECORD\nZIBRUN   DS    F                        START OF ACTIVE INPUT BUF\nZIBREAD  DS    F                        START OF NEXT INPUT BUFFER\n         SPACE\n*              OUTPUT RECORD\nZOBWORK  DS    F                        START OF ACTIVE OUTPUT BUFFER\nZOBWRITE DS    F                        START OF LAST OUTPUT BUFFER\nZFILE1   DS    F                        OUTPUT RECORD END - 1\nZFILE2   DS    F                        OUTPUT RECORD END - 2\nZFILE3   DS    F                        OUTPUT RECORD END - 3\nZFILE5   DS    F                        OUTPUT RECORD END - 5\nZFILE6   DS    F                        OUTPUT RECORD END - 6\nZFILE9   DS    F                        OUTPUT RECORD END - 9\nZOUTCOT  DC    H'1'                     OUTPUT RECORD NUMBER\n         SPACE\n*              IDENTIFIER TABLE\nZIBSTAO  DS    F                        ITAB START ADDRESS\nZITAN    DS    F                        ADDR OF ITAB ENTRY OF LAST ID.\nZCURITEN DS    F                        ADDRESS OF LAST ITAB ENTRY\nZITREC   DS    F                        START OF NEXT ITAB RECORD\nZITEND   DS    F                        ITAB END ADDRESS\nZCURITLE DS    H                        LENGTH OF LAST ITAB RECORD\n         SPACE\n*              ERROR MESSAGES\nZBEGERR  DS    F                        START OF VARIABLE INFORMATION\nZENDERR  DS    F                        END OF VARIABLE INFORMATION\nZERRONU  DS    H                        ERROR NUMBER\n         SPACE\n*              ARRAY IDENTIFIER STACK\nZARMAX   DC    A(ZARSTACK+28)           END ADDRESS IN ARIDSTACK\nZARNO    DC    A(ZARSTACK-7)            START ADDRESS OF ARIDSTACK\nZARSPO   DC    A(ZARSTACK-7)            CURRENT PT IN ARIDSTACK\nZPOSIX   DC    H'0'                     COMPONENT NUMBER IN ARRAY\nZARSTACK DS    CL35                     ARIDSTACK\n         SPACE\n*              SUBSCRIPT TEST ROUTIN2\nSUBEND   DS    F                        SUBSCRIPT END ADDRESS\nADDEND   DS    3H                       SAVE AREA FOR ADDEND\nFACTOR   DS    3H                       SAVE AREA FOR FACTOR\nZEROELEM DC    XL6'00C801000000'        INTERNAL CODE FOR +0\nONEELEM  DC    XL6'00C801000004'        INTERNAL CODE FOR +1\nZBRACK   DS    F                        SUBSCRIPT START ADDRESS - 1\n         SPACE\nZSTO     DS    F                        TEMPORARY STORAGE\nZSTO1    DC    X'0670'                                           A32962\nZSTO2    DC    X'0240'                                           A32962\nZIGN     DC    H'0'                     CURRENT IDENTIFIER GROUP NUMBER\nZPOINT   DC    X'3E3E3E3E3E3E'\nZALLPUP  DC    X'91FF010000'            ALL PURPOSE IDENTIFIER\nZALLPU   EQU   ZALLPUP-6\nZIDEX    DS    37C                      WORKAREA\nNUMBER   EQU   ZIDEX+1\nOPSTART  DC    A(ZIDEX)\n         SPACE\nBRCNT    DS    H                        BRACKET COUNTER IN ARRAY DECL.\nSTATUS   DC    X'00'                    STATUS BYTE\nCURPBN   DS    C                        PBN OF LAST BLOCK\nZCLOBRA  DC    X'00'                    SUBSCRIPT TEST BYTE\nZFORTEST DC    X'00'                    FOR STATEMENT TEST BYTE\nZLVOV    DC    X'00'                    SET X'FF' IF NO MORE SUBSC OPT\nZFSN     DS    C                        CURRENT FOR STATEMENT NUMBER\nFSNEMBR  DS    C                        NUMBER OR EMBRACING BLOCK\nIOBYTE   DS    C                        STATUS BYTE FOR SYSUT3\nNOTEW    DS    F                        ID. OF LAST WRITTEN RECORD\nNOTER    DS    F                        ID. OF LAST READ ITAB RECORD\n         SPACE\n*              CRITICAL VARIABLE TABLE\nPFA      DS    F                        CURRENT CRIDTAB PT\nPFANO    DS    F                        START ADDRESS OF CRIDTAB\nPFAMAX   DS    F                        END ADDRESS OF CRIDTAB\nZFSPTR   DS    F                        PT TO CURRENT FSTAB ENTRY\nZFOCRI   DS    F\n         SPACE\n*              CONSTANT POOL\nZKOPOOL  DS    F                        START ADDRESS OF POOL\nZKOPEND  DS    F                        END ADDRESS OF POOL\nZLITSTA  DS    F                        START ADDRESS OF USED PART\nZTEXTCO  DS    F                        END ADDRESS OF TXT PIECE\nZKBNMAX  DS    H                        NUMBER OF NEXT POOL\nTXTPUT   DC    H'56'                    LENGTH OF TXT PIECE\n         SPACE\nZPACK    DS    D                        WORKAREA TO PACK NUMBERS\nZEROFLOA DC    D'0.0'\nZONEFLOA DC    D'1.0'\nZTEN9    DC    D'1.0E+9'\nZFLOFIEL DC    X'4E00000000000000'      WORKAREA FOR FLOATING CONVERS.\nROUND    DC    X'0000000080000000'      USED TO ROUND SHORT FORM REAL\nZWP      DS    F                        WORD PT IN CONSTANT POOL\nZDWP     DS    F                        DOUBLE WORD PT IN CONSTANT POOL\nNSTART   DC    A(NUMBER)                PTR TO NUMBER\nSCALEMSK DC    XL4'38'\nLREAL    DC    F'8'                     SHORT PREC 4, LONG PREC 8\nNREAL    DC    F'18'                    SHORT PREC 7, LONG PREC 18\nZLIRE    DS    H\nZINTYP   DC    X'C801'                  ID. OF INTEGER CONSTANT\nZREALTYP DC    X'C802'                  ID. OF REAL CONSTANT\nSREF     DC    P'+1'                    PLUS\n         DC    P'-1'                    MINUS, MUST FOLLOW SREF\nSCATEST  DS    C                        SCALE FACTOR TEST BYTE\nSCALEQ   DC    X'2E00'\nSCALE    EQU   SCALEQ+1\nMAXNR    DC    X'32313437343833363437'  INTERNAL CODE OF MAX INTEGER\nSCAWORK  DS    10C                      STORE FOR SCALE FACTOR\nZTO      DS    F\nZEXCORR  DS    F\nZTOSCA   DS    F\nSCAWORKA DC    A(SCAWORK+1)\n         SPACE\nOLDSPIE  DS    F                        ADDRESS OF OLD PICA\nTABSIZE  DS    F                        ACCUMULATED SIZE OF TABLES\nREGSAVE  DS    5F                       SAVE AREA FOR REGISTERS\nSPECUSE  DC    XL4'06'\nALIGN    DC    F'0'                     FULL WORD ALIGNMENT\nALIGNH   EQU   ALIGN+2                  HALF WORD ALIGNMENT\n         SPACE\nZEXTABP  DC    D'1.0E+1'\n         DC    D'1.0E+2'                                           0892\n         DC    D'1.0E+3'                                           0900\n         DC    D'1.0E+4'                                           0908\n         DC    D'1.0E+5'                                           0916\n         DC    D'1.0E+6'                                           0924\n         DC    D'1.0E+7'                                           0932\n         SPACE\n         DC    D'1.0E+8'                                           0940\n         DC    D'1.0E+16'\n         DC    D'1.0E+24'                                          0956\n         DC    D'1.0E+32'                                          0964\n         DC    D'1.0E+40'                                          0972\n         DC    D'1.0E+48'                                          0980\n         DC    D'1.0E+56'                                          0988\n         DC    D'1.0E+64'                                          0996\n         SPACE\nZEXTABN  DC    D'1.0E-1'\n         DC    D'1.0E-2'                                           1024\n         DC    D'1.0E-3'                                           1032\n         DC    D'1.0E-4'                                           1040\n         DC    D'1.0E-5'                                           1048\n         DC    D'1.0E-6'                                           1056\n         DC    D'1.0E-7'                                           1064\n         SPACE\n         DC    D'1.0E-8'                                           1072\n         DC    D'1.0E-16'                                          1080\n         DC    D'1.0E-24'                                          1088\n         DC    D'1.0E-32'\n         DC    D'1.0E-40'                                          1104\n         DC    D'1.0E-48'                                          1112\n         DC    D'1.0E-56'                                          1120\n         DC    D'1.0E-64'                                          1128\nGENER    EQU   *\n         DC    X'5454546854685454'\n         DC    X'3C606438541C2020'\n         DC    8X'54'\n         DC    X'245C543430'\n         DC    8X'54'\n         DC    X'4054544438282C545018480C'\n         DC    9X'08'\n         DC    X'00004C581014'\n         DC    26X'04'\nIDENTI   DC    45X'10'                                             1292\n         DC    X'000C04'\n         DC    13X'00'\n         DC    X'080C0C'\n         DC    26X'00'\nDIG19    DC    45X'18'\n         DC    X'000C10'                                           1372\n         DC    13X'00'\n         DC    X'140408'\n         DC    26X'0C'\nDIG0     DC    45X'1C'                                             1452\n         DC    X'00081400'\n         DC    9X'04'\n         DC    X'000000180C10'\n         DC    26X'08'\nDECPO    DC    45X'14'                                             1532\n         DC    X'00081004'\n         DC    13X'00'\n         DC    X'080C'\n         DC    26X'08'\nSCAFAC   DC    X'0C0C'                                             1612\n         DC    43X'18'\n         DC    X'00101408'\n         DC    9X'04'\n         DC    4X'00'\n         DC    28X'10'\n         SPACE\n*              ITAB ENTRIES OF STANDARD PROCEDURES\nFIXITAB  EQU   *\n         DC    X'013F0000002B0000000000'     HEADER FOR PBN O\n         DC    X'4041520000008882002080'     ABS\n         DC    X'5248464D000088810020C0'     SIGN\n         DC    X'4B444D46534788810000E0'     LENGTH\n         DC    X'5258524042538A80911203'     SYSACT\n         DC    X'5250515300008882002004'     SQRT\n         DC    X'52484D0000008882002008'     SIN\n         DC    X'424E52000000888200200C'     COS\n         DC    X'40514253404D8882002010'     ARCTAN\n         DC    X'4B4D000000008882002014'     LN\n         DC    X'44574F0000008882002018'     EXP\n         DC    X'444D5348445188810020F0'     ENTIER\n         DC    X'484D52584C418A8090181F'     INSYMB\n         DC    X'484D5144404B8A800A1822'     INREAL\n         DC    X'484D484D53448A80091826'     ININTE\n         DC    X'484D414E4E4B8A800B182A'     INBOOL\n         DC    X'484D4051514088800E182E'     INARRA\n         DC    X'484D5340515188800D1832'     INTARR\n         DC    X'484D414051518880071836'     INBARR\n         DC    X'4E545352584C888010143B'     OUTSYM\n         DC    X'4E5453514440888002143E'     OUTREA\n         DC    X'4E5453484D538880011442'     OUTINT\n         DC    X'4E5453414E4E8880031446'     OUTBOO\n         DC    X'4E5453405151888006144A'     OUTARR\n         DC    X'4E5453534051888005144E'     OUTTAR\n         DC    X'4E54534140518880071452'     OUTBAR\n         DC    X'4E54535253518880001456'     OUTSTR\n         DC    X'4F54530000008A8004115A'     PUT\n         DC    X'4644530000008A8004115E'     GET\n         SPACE\nASEC1    DC    A(IEX30001)\nASEC2    DC    A(IEX30002)\n         EJECT\nINITIATE EQU   *\n         LA    WORKR,TERM1              ERROR EXIT ADDRESS\n         ST    WORKR,ERET\n         LA    WORKR,LOMEGA6            PROVIDE EOD ADDR           2846\n         ST    WORKR,EODUT1                      FOR UT1           2846\n         MVC   SEMCNT(2),ZERO           SET SEMICOLON COUNTER TO ZERO\n         SPIE  INTERUPT,((1,7),9,11,12,15)\n         ST    R1,OLDSPIE               SAVE ADDRESS OF OLD PICA\n         SPACE\n*                                  ALLOCATE STORAGE FOR TABLESD\n         LH    R0,FOURK                 CONSTANT POOL SIZE\n         A     R0,ITAB30S               ITABSIZE\n         A     R0,SRCE1S                INPUT BUFFER SIZE\n         A     R0,SRCE3S                OUTPUT BUFFER SIZE\n         A     R0,SRCE3S                OUTPUT BUFFER SIZE\n         A     R0,CRIDTABS              CRIDTAB SIZE\n         A     R0,SUTAB30S              SUTAB SIZE\n         A     R0,LVTAB30S              LVTAB SIZE\n         AH    R0,EIGHT                 RECORD KEY LENGTH\n         ST    R0,TABSIZE               SAVE TABLE AREA LENGTH\n         GETMAIN R,LV=(0)               ALLOCATE STORAGE\n         LA    WORKR,TERM2              ERROR RETURN ADDRESS\n         ST    WORKR,ERET\n         ST    R1,ZKOPOOL               CONSTANT POOL START ADDRESS\n         AH    R1,FOURK\n         ST    R1,ZIBSTAO               ITAB START ADDRESS\n         A     R1,ITAB30S\n         ST    R1,ZIBREAD               SECOND INPUT BUFFER START ADDR.\n         A     R1,SRCE1S\n         ST    R1,ZOBWORK               OUTPUT BUFFER START ADDRESS\n         A     R1,SRCE3S\n         ST    R1,ZOBWRITE              OUTPUT BUFFER START ADDRESS\n         A     R1,SRCE3S\n         ST    R1,ZFOCRI                CRIDTAB START ADDRESS\n         A     R1,CRIDTABS\n         ST    R1,SUSTRT                SUTAB START ADDRESS\n         A     R1,SUTAB30S\n         LA    R1,4(0,R1)\n         ST    R1,LVSTRT                LVTAB START ADDRESS\n         SPACE\n*              INITILIZE INPUT BUFFERS\n         L     ZINR,SRCE1ADD            ADDRESS OF FIRST INPUT BUFFER\n         ST    ZINR,ZIBRUN\n         TM    HCOMPMOD+2,ONEREC        INPUT ALREADY IN CORE\n         BO    INCORE                   YES\n         BAL   R15,ICHAI                READ FIRST RECORD\nINCORE   EQU   *\n         SPACE\n*              ITAB POINTERS INITIALIZATION\n         L     R1,ZIBSTAO               ITAB START ADDRESS\n         MVC   0(256,R1),FIXITAB        INSERT ITAB FIXED PART\n         MVC   256(FIXITABL-256,R1),FIXITAB+256\n         LA    WORKR,FIXITABL-11(0,R1)  ADDRESS LAST FIXED ENTRY\n         ST    WORKR,ZCURITEN\n         LA    WORKR,11(0,WORKR)        ADDRESS FIRST FREE ITAB ENTRY\n         ST    WORKR,ZITREC\n         A     R1,ITAB30S               ITAB END ADDRESS PLUS 1\n         ST    R1,ZITEND\n         L     R1,UT3ADD                ADDRESS OF DCB-SUSUT3\n         NOTE  (1)                      ID OF LAST ITAB BLOCK\n         ST    R1,SULTSTRT              TRANSFER TO SUBSCRIPT HANDLING\n         ST    R1,NOTEW                 PREPARE WRITE OF SUTAB OR LVTAB\n         L     WORKR,UT3ADD             DCB ADDRESS\n         CLOSE ((WORKR),REREAD),TYPE=T  TEMPORARY CLOSE\n         BAL   R15,ITABREAD             READ FIRST ITAB RECORD\n         SPACE\n*              INITILIZE OUTPUT BUFFERS\n         L     ZOUR,ZOBWORK             START OF ACTIVE OUTPUT BUFFER\n         L     WORKR,SRCE3S             LENGTH OF OUTPUT BUFFER\n         SH    WORKR,TWELVE        SET BUFFER END PTRS\n         AR    WORKR,ZOUR\n         ST    WORKR,ZFILE9\n         LA    WORKR,3(0,WORKR)\n         ST    WORKR,ZFILE6\n         LA    WORKR,1(0,WORKR)\n         ST    WORKR,ZFILE5\n         LA    WORKR,2(0,WORKR)\n         ST    WORKR,ZFILE3\n         LA    WORKR,1(0,WORKR)\n         ST    WORKR,ZFILE2\n         LA    WORKR,1(0,WORKR)\n         ST    WORKR,ZFILE1\n         BCTR  ZOUR,0\n         SPACE\n*              CRIDTAB AND FSTAB INITIALIZATION\n         L     R1,ZFOCRI                CRIDTAB START ADDRESS\n         SH    R1,NINE                  INITILIZE PTRS\n         ST    R1,PFANO\n         ST    R1,PFA                   CURRENT CRIDTAB PTR\n         A     R1,CRIDTABS              GET ADDRESS OF LAST ENTRY\n         ST    R1,PFAMAX                END PTR\n         MVI   ZFOSTA,X'00'             ZEROIZE FSTAB\n         MVC   ZFOSTA+1(254),ZFOSTA\n         LA    WORKR,FSTAB-1            START ADDRESS OF FSTAB -1\n         ST    WORKR,ZFSPTR             INITILIZE FORSTATEMENT ZERO\n         SPACE\n*              SUTAB INITIALIZATION\n         L     R1,SUSTRT                SUTAB START ADDRESS\n         MVC   0(4,R1),SUKEY            SET SUTAB KEY\n         SH    R1,TEN                   INITILIZE PTRS\n         ST    R1,ZSUDAD                START PTR\n         ST    R1,ZSUTAPO               CURRENT PTR\n         A     R1,SUTAB30S\n         ST    R1,ZSUTMAX               END PTR\n         SPACE\n*              LVTAB INITIALIZATION\n         L     R1,LVSTRT                LVTAB START ADDRESS\n         MVC   0(4,R1),LVKEY            SET LVTAB KEY\n         ST    R1,ZLESTA                START PTR\n         ST    R1,ZLEVA                 CURRENT PTR\n         A     R1,LVTAB30S\n         ST    R1,ZLEMAX                END PTR\n         SPACE\n*              LITERAL HANDLING INITIALIZATION\n         TM    HCOMPMOD,X'02'           LONG PRECITION\n         BNZ   INLIT2                   YES\n         LA    WORKR,4\n         ST    WORKR,LREAL\n         LA    WORKR,7\n         ST    WORKR,NREAL              MAXIMAL PRECITION\nINLIT2   EQU   *\n         SPACE\n*              CONSTANT POOL INITALIZATION\n         L     R1,ZKOPOOL               CONSTANT POOL START ADDRESS\n         LH    WORKR,FOURK              LENGTH OF CONSTANT POOL\n         AR    WORKR,R1                 CONSTANT POOL END ADDRESS\n         ST    WORKR,ZKOPEND            END PTR\n         A     R1,PRPT\n         ST    R1,ZWP                   WORD PTR\n         ST    R1,ZDWP                  DOUBLE WORD PTR\n         ST    R1,ZLITSTA               START ADDRESS OF ACTIVE POOL\n         AH    R1,TXTPUT                TXT OUTPUT PTR\n         ST    R1,ZTEXTCO\n         MVC   ZKBNMAX(2),PBN           PREPARE CONSTANT POOL EXCHANGE\n         MVC   KBN(2),ZERO              CURRENT POOL NUMBER\n         SPACE\n*              START READ INTO ALTERNATE INPUTBUFFER IF NECCESSARY\n         TM    HCOMPMOD+2,ONEREC\n         BO    INITEND                  YES\n         BAL   R15,ICHA\nINITEND  EQU   *\n         SPACE\n         NI    HCOMPMOD+2,X'FF'-NOSC    SET SEMICOLON COUNTER ACTIVE\n         TM    HCOMPMOD,PROC            PRECOMPILED PROCEDURE\n         BZ    *+8                      NO\n         BAL   R15,ITABMOVE             YES, GET ITAB RECORD\n         B     GENTEST\n         EJECT\nGENTEST1 LA    ZINR,1(0,ZINR)\nGENTEST  SR    R2,R2\n         TRT   0(80,ZINR),GENER\n         B     *(R2)\n         B     LETTER\n         B     DIGIT19\n         B     DIGIT0\n         B     DECPOIN\n         B     SCAFACT\n         B     QUOTE\n         B     BETA\n         B     PIPHI\n         B     FOR\n         B     EPSILON\n         B     ETA\n         B     DO\n         B     WHILE\n         B     SEMIDELT\n         B     OPBRACK\n         B     COMMA\n         B     CLOBRACK\n         B     ZETA\n         B     GAMMA\n         B     OMEGA\n         B     OTHOP\n         B     RHO\n         B     STEP\n         B     ARRAY\n         B     SWITCH\n         B     DIPOW\n         SPACE 3\n*              STRING OR LOGICAL VALUE\nQUOTE    EQU   *\n         C     ZOUR,ZFILE5              OUTPUT BUFFER EXCHANGE\n         BH    LQUOT2                   YES\nLQUOT3   MVC   1(5,ZOUR),1(ZINR)        OUTPUT INTERNAL NAME\n         LA    ZINR,6(0,ZINR)\n         CLI   0(ZINR),X'2E'            FOLLOWS AN OPERATOR\n         BNL   LQUOT1                   PROBABLY NOT, MIGHT BE ZETA\nLQUOT5   LA    ZOUR,5(0,ZOUR)           STEP OUTPUT PTR\n         B     GENTEST                  BRANCH TO GENTEST\nLQUOT2   BAL   R15,OUCHA                BRANCH TO SUBROUTINE OUCHA\n         B     LQUOT3                   BRANCH TO LQUOT3\nLQUOT1   CLI   0(ZINR),X'2F'            ZETA\n         BNE   LQUOT4                   NO, GIVE ERROR MESSAGE\n         BAL   R15,ICHA                 CHANGE INPUT BUFFER\n         CLI   0(ZINR),X'2E'            FOLLOWS OPERATOR\n         BL    LQUOT5                   YES\nLQUOT4   MVC   ZIDEX(6),ZPOINT          REPLACE OPERAND BY SIX POINTS\n         LA    RTO,ZIDEX+6\n         LA    R0,ZIDEX+12\n         MVC   ZERRONU(2),INVOP\n         B     INCOROP                  INCORRECT OPERAND ERROR ROUTINE\n         SPACE 3\n*              PROGRAM BLOCK BEGIN\nBETA     EQU   *\n         CLI   LETTERB,X'F0'            PROCEDURE BLOCK TO READ\n         BE    LBETA4                   YES\nBETA1    BAL   R15,ITABMOVE             READ ITAB BLOCK\nLBETA2   C     ZOUR,ZFILE2             COMPARE ZOUT WITH ZFILE(2)\n         BH    LBETA1                   BRANCH IF HIGH\nLBETA3   MVC   1(2,ZOUR),0(ZINR)\n         LA    ZOUR,2(0,ZOUR)           ZOUT IS INCREASED BY 2\n         MVC   ZIGN(2),2(ZINR)         IGN IS RECOGNIZED AND STORED\n         LA    ZINR,4(0,ZINR)           ZIN IS INCREASED BY 4\n         B     GENTEST                  BRANCH TO GENTEST\nLBETA1   BAL   R15,OUCHA                BRANCH TO SUBROUTINE OUCHA\n         B     LBETA3                  BRANCH TO LBETA 2\nLBETA4   BAL   R15,ITABMOP              READ PROCEDURE BLOCK\n         B     BETA1\n         SPACE 3\n*              PROCEDURE BLOCK BEGIN\nPIPHI    EQU   *\n         NI    PROCHD,X'0F'             PROC. HEAD SWITCH ON       0209\n         CLI   LETTERB,X'F0'            PROCEDURE BLOCK TO READ\n         BE    LPIPHI6\nPIPHI1   MVC   ZIGN(2),1(ZINR)          SAVE CURRENT IGN\n         C     ZOUR,ZFILE6              SPACE IN OUTPUT BUFFER\n         BH    LPIPHI1                  BRANCH IF HIGH\nLPIPHI2  MVC   1(1,ZOUR),0(ZINR)        OPERATOR IS MOVED TO O-BUFFER\n         LA    ZOUR,1(0,ZOUR)           ZOUT IS INCREASED BY 1\n         LA    ZINR,3(0,ZINR)          ZIN IS INCREASED BY 3\nLPIPHI3  CLI   0(ZINR),X'40'            LETTER FOLLOWS IN SOURCE INPUT\n         BL    LPIPHI4                  NO\n         OI    LETTERB,X'F0'            YES, SET PROCEDURE SWITCH\n         B     LETTER                   GET IDENT. AND READ ITAB   0209\n         SPACE\nLPIPHI4  CLI   0(ZINR),X'2F'       ZETA IN SOURCE INPUT\n         BE    LPIPHI5                  YES\n         BAL   R15,ITABMOVE             NO, READ ITAB BLOCK\n         B     GENTEST\n         SPACE\nLPIPHI5  BAL   R15,ICHA                 GET NEXT INPUT RECORD\n         B     LPIPHI3\nLPIPHI1  BAL   R15,OUCHA                BRANCH TO SUBROUTINE OUCHA\n         B     LPIPHI2                  BRANCH TO LPIPHI2\nLPIPHI6  BAL   R15,ITABMOP              READ PROCEDURE BLOCK\n         B     PIPHI1\n         SPACE 3\n*              FOR STATEMENT BEGIN\nFOR      MVI   ZFORTEST,X'C0'          ZFORTEST IS SET TO X'C0'\n         L     WORKR,ZFSPTR             UPDATE PTR TO FSTAB ENTRY\n         LA    WORKR,1(0,WORKR)\n         ST    WORKR,ZFSPTR\n         LA    WORKX,FSTAB              GET FOR STATEMENT NUMBER\n         SR    WORKR,WORKX\n         STC   WORKR,ZFSN\nLFOR3    MVC   ZIGN(2),1(ZINR)         IGN IS RECOGNIZED AND STORED\n         C     ZOUR,ZFILE1              TEST IF SPACE IN OUTPUT-BUFFER\n         BH    LFOR1                    BRANCH IF HIGH\nLFOR4    MVC   1(1,ZOUR),0(ZINR)\n         LA    ZOUR,1(0,ZOUR)           ZOUT IS INCREASED BY 1\n         LA    ZINR,3(0,ZINR)           ZIN IS INCREASED BY 3\n         B     GENTEST                  BRANCH TO GENTEST\nLFOR1    BAL   R15,OUCHA                BRANCH TO SUBROUTINE OUCHA\n         B     LFOR4                   BRANCH TO LFOR2\n         SPACE 3\n*              END OF PROGRAM OR PROCED URE BLOCK\nEPSILON  EQU   *\n         CLI   LETTERB,X'F0'            ITAB BLOCK TO READ\n         BE    EPSILON2                 YES\nEPSILON1 L     R6,ZCURITEN              ADDRESS LAST ITAB ENTRY\n         SH    R6,ZCURITLE             ZCURITEN=ZCURITEN-ZCURITLE\n         ST    R6,ZCURITEN             ZCURITEN IS STORED\n         MVC   ZCURITLE(2),17(R6)      ZCURITLE IS UPDATED\n         B     LBETA2                   BRANCH TO LBETA2\nEPSILON2 BAL   R15,ITABMOP              READ ITAB BLOCK\n         B     EPSILON1\n         SPACE 3\n*              FOR STATEMENT END\nETA      MVI   ZFORTEST,X'00'           ZFORTEST IS SET TO X'00'\n         TM    HCOMPMOD,SYNTAX          COMPILE MODE\n         BO    LFOR3                    NO\n         BAL   R15,CRIFODEL             BRANCH TO SUBROUTINE CRIFODEL\n         B     LFOR3                    BRANCH TO LFOR3\n         SPACE 3\n*              FOR LIST END\nDO       MVI   ZFORTEST,X'00'          ZFORTEST IS SET TO X'00'\nLDO3     C     ZOUR,ZFILE1             COMPARE ZOUT WITH ZFILE(1)\nOTHOP    EQU   LDO3\n         BH    LDO1                     BRANCH IF HIGH\nLDO2     MVC   1(1,ZOUR),0(ZINR)        OPERATOR IS MOVED TO O-BUFFER\n         LA    ZOUR,1(0,ZOUR)           ZOUT IS INCREASED BY 1\n         B     GENTEST1\nLDO1     BAL   R15,OUCHA               BRANCH TO SUBROUTINE OUCHA\n         B     LDO2                     BRANCH TO LDO2\n         SPACE 3\n*              WHILE\nWHILE    EQU   *\n         L     WORKR,ZFSPTR             ADDRESS FSTAB ENTRY\n         OI    0(WORKR),WHILEM          INDICATE 'WHILE HAS APPEARED'\n         B     LDO3\n         SPACE 3\n*              STEP OPERATOR\nSTEP     EQU   *\n         L     WORKR,ZFSPTR             ADDRESS FSTAB ENTRY\n         OI    0(WORKR),STEPM           INDICATE 'STEP HAS APPEARED'\n         B     LDO3\n         SPACE 3\n*              DIVIDE AND POWER ROUTINE\nDIPOW    EQU   *\n         CLI   ZFORTEST,X'00'           OPERATOR IN FOR LIST\n         BE    OTHOP                    NO, MOVE TO OUTPUT STREAM\n         L     WORKR,ZFSPTR             YES, ADDRESS FSTAB ENTRY\n         OI    0(WORKR),NOCOUNT         COUNTING LOOP IMPOSSIBLE\n         B     OTHOP                    MOVE TO OUTPUT STREAM\n         SPACE 3\n*              SEMICOLON OR DELTA\nSEMIDELT MVC   SEMCNT(2),1(ZINR)        SAVE SEMICOLON COUNTER\n         OI    PROCHD,X'F0'             PROC. HEAD SWITCH OFF      0209\n         C     ZOUR,ZFILE3             COMPARE ZOUT WITH ZFILE(3)\n         BH    LSEM1                    BRANCH IF HIGH\nLSEM2    MVC   1(3,ZOUR),0(ZINR)        OPERATOR,SC ARE MOVED TO O-BUFF\n         LA    ZOUR,3(0,ZOUR)           ZOUT IS INCREASED BY 3\n         LA    ZINR,3(0,ZINR)           ZIN IS INCREASED BY 3\n         MVI   STATUS,X'00'             TURN OFF SWITCH OR ARRAY BITS\n         B     GENTEST                  BRANCH TO GENTEST\nLSEM1    BAL   R15,OUCHA               BRANCH TO SUBROUTINE OUCHA\n         B     LSEM2                    BRANCH TO LSEM2\n         SPACE 3\nSWITCH   OI    STATUS,SSWITCH           SET ON SWITCH SWITCH\n         B     OTHOP\n         SPACE 3\nARRAY    OI    STATUS,SARRAY            SET ON ARRAY SWOTCH\n         MVC   BRCNT(2),ZERO            ZEROISE BRACKET COUNTER\n         B     OTHOP                    OUTPUT OPERATOR\n         SPACE 3\n*              PROGRAM END\nOMEGA    MVC   1(1,ZOUR),0(ZINR)\n         OI    HCOMPMOD+2,NOSC          SET SEMICOLON COUNTER INACTIVE\n         TM    HCOMPMOD+2,ONEREC        INPUT AT ONCE IN CORE      2846\n         BO    LOMEGA6                  YES                        2846\n         CHECK SREAD                                               2846\nLOMEGA6  L     WORKR,UT1ADD                                        2846\n         CLOSE ((WORKR))                CLOSE UTILITY 1 FINALY\n         CLC   ONE(2),ZOUTCOT           COMPARE ZOUTCOT WITH 1\n         BE    LOMEGA1\n         LA    ZOUR,1(0,ZOUR)           SAVE OMEGA FROM OVERLAY\n         BAL   R15,OUCHA                WRITE LAST RECORD\n         NI    HCOMPMOD+2,MANYREC       OUTPUT ON SECONDARY STORAGE\n         CHECK SWRITE              CHECK LAST OUTPUT RECORD\n         SPACE\nLOMEGA3  EQU   *\n*                                       WRITE OUT CONSTANT POOL\n         L     RWP,ZDWP                 ADDRESS OF FREE BYTE IN C.POOL\n         LR    WORKR,RWP\n         AH    WORKR,TXTPUT             MORE TXT TO WRITE\n         C     WORKR,ZTEXTCO\n         BE    LOMEGA2\n         BAL   R14,TXTTRAF              YES, WRITE REST OF CONST.POOL\n         SPACE\nLOMEGA2  EQU   *\nTERM2    EQU   *\n         SR    WORKR,WORKR\n         IC    WORKR,ZFSN\n         STH   WORKR,FSNMAX\n         MVC   SUCOUNT(2),SUCNT         NUMBER OF SUTAB RECORDS\n         MVC   LVCOUNT(2),LVCNT         NUMBER OF LVTAB RECORDS\n         SPACE\n         L     R1,SULENGTH              GET FULL LENGTH OF SUTAB\n         A     R1,ZSUTAPO\n         S     R1,ZSUDAD\n         ST    R1,ZSUTEN                LENGTH OF SUTAB\n         BZ    LOMEGA4\n         CLC   ZSUTAPO(4),ZSUDAD        ANYTHING IN SUTAB BUFFER\n         BE    LOMEGA5                  NO\n         SPACE\n         BAL   WORKR,CHECK              CHECK LAST I/O OPERATION ON UT3\n         L     WORKR,SUSTRT             WRITE START ADDRESS\n         L     WORKX,SUTAB30S           LENGTH OF RECORD\n         BAL   R15,WRITE                WRITE\n         SPACE\nLOMEGA5  EQU   *\n         L     R1,LVLENGTH              GET FULL LENGTH OF LVTAB\n         A     R1,ZLEVA\n         S     R1,ZLESTA\n         ST    R1,ZLEVEN                LENGTH OF LVTAB\n         BZ    LOMEGA4\n         CLC   ZLEVA(4),ZLESTA          ANYTHING IN LVTAB BUFFER\n         BE    LOMEGA4                  NO\n         SPACE\n         BAL   WORKR,CHECK              CHECK LAST I/O OPERATION ON UT3\n         L     WORKR,LVSTRT             LVTAB BUFFER START ADDRESS\n         L     WORKX,LVTAB30S           LENGTH OF LVTAB BUFFER\n         BAL   R15,WRITE                WRITE\n         SPACE\nLOMEGA4  BAL   WORKR,CHECK              CHECK LAST I/O OPERATION ON UT3\n         L     WORKR,UT2ADD\n         CLOSE ((WORKR),REREAD),TYPE=T  CLOSE UTILITY 2 TEMPORARILY\n         SPACE\n*                                  RELEASE MAIN STORAGE\n         L     R0,TABSIZE\n         L     R1,ZKOPOOL\n         FREEMAIN R,LV=(0),A=(1)\nTERM1    EQU   *\n         L     R1,OLDSPIE\n         SPIE  MF=(E,(1))\n         XCTL  EP=IEX31                 TRANSFER TO NEXT PHASE\n         SPACE\nLOMEGA1  OI    HCOMPMOD+2,ONEREC        INDICATE ONLY ONE OUTPUT RECORD\n         L     R1,SRCE1ADD              ADDRESS OF RESIDENT BUFFER\n         L     R2,ZOBWORK               ADDRESS OF OUTPUT BUFFER\n         L     WORKR,SRCE1S             BUFFER LENGTH\n         BCTR  WORKR,0\n         LR    WORKX,WORKR\n         SRA   WORKX,8                  GET MULTIPLE OF 256\n         LTR   WORKX,WORKX              MAXIMUM 256\n         BZ    LOMEGA12                 YES\nLOMEGA11 MVC   0(256,R1),0(R2)          MOVE BLOCK OF 256\n         LA    R1,256(0,R1)\n         LA    R2,256(0,R2)\n         BCT   WORKX,LOMEGA11\nLOMEGA12 EX    WORKR,ONERM              MOVE REST OF BUFFER\n         B     LOMEGA3\nONERM    MVC   0(0,R1),0(R2)            LENGTH IN WORKR\n         SPACE 3\n*              CODE PROCEDURE\nGAMMA    C     ZOUR,ZFILE9             COMPARE ZOUT WITH ZFILE9\n         BH    LGAMMA1                       BRANCH IF HIGH\nLGAMMA2  MVI   1(ZOUR),X'2E'            NEW CODE FOR GAMMA IS SET\n         MVC   2(8,ZOUR),1(ZINR)        OPT,EXTERN.NAME TO O-BUFF.\n         LA    ZINR,9(0,ZINR)                ZIN IS INCREASE BY 9\n         LA    ZOUR,9(0,ZOUR)\n         B     GENTEST                       BRANCH TO GENETEST\nLGAMMA1  BAL   R15,OUCHA\n         B     LGAMMA2                       BRANCH TO LGAMMA2\n         SPACE 3\n*              END OF INPUT BUFFER\nZETA     EQU   *\n         BAL   R15,ICHA                      BRANCH TO SUBROUTINE ICHA\n         B     GENTEST                       BRANCH TO GENTEST\n         SPACE 3\n*              OPENING BRACKET\nOPBRACK  EQU   *\n         TM    STATUS,SARRAY            HANDLING ARRAY DECLARATION\n         BO    LOPBRA5                  YES\n         TM    HCOMPMOD,SYNTAX          COMPILE MODE\n         BO    OTHOP                    NO\n         L     R7,ZITAN                ZITEAN IS LOADED INTO R7\n         TM    7(R7),X'08'              IS IT AN ARRAY IDENTIFIER\n         BO    LDO3                     NO\n         TM    7(R7),X'04'\n         BZ    LDO3\n         CLC   PFA(4),PFANO             PFA IS COMPARED WITH PFANO\n         BE    LDO3                          BRANCH IF EQUAL\n         CLI   ZLVOV,X'FF'              TABLE OVERFLOW\n         BE    LDO3                     YES\n         CLC   ZARSPO(4),ZARNO         COMPARE ZARSPO WITH ZARNO\n         BE    LOPBRA4             NO SUBSCRIPT NESTING\n         BAL   SUCRIDX,SUCRIDEL\n         L     R8,ZARSPO               ZARSPO IS SET INTO R8\n         C     R8,ZARMAX               COMPARE ZARSPO WITH ZARMAX\n         BE    LOPBRA4                  BRANCH IF EQUAL\n         MVC   10(1,R8),ZPOSIX+1        NUMBER OF COMMAS TO ARIDSTACK\n          LA   R8,7(0,R8)               ADDRESS NEXT ENTRY\nLOPBRA3  ST    R8,ZARSPO               ZARSPO IS SET TO ZARSTACK\n         MVC   0(3,R8),8(R7)            ARRAY IDENTIFIER IS STORED\n         LA    R0,1(0,ZOUR)\n         ST    R0,ZBRACK               ZBRACK IS SET TO ZOUT+1\n         S     R0,ZOBWORK\n         ST    R0,ALIGN                 RELATIVE BUFFER ADDRESS\n         MVC   5(2,R8),ALIGNH\n         MVC   4(1,R8),ZOUTCOT+1        RECORD COUNTER TO ARIDSTAB\n         MVC   ZPOSIX(2),ZERO          ZPOSIX IS SET TO 0\n         MVI   ZCLOBRA,X'00'           ZCLOBRA IS SET TO X'00'\n         B     LDO2                     PUT OUT OPERATOR\nLOPBRA4  LA    R8,ZARSTACK              STARTADDRESS OF ARIDSTAB\n         B     LOPBRA3                       BRANCH TO LOPBRA3\nLOPBRA5  LH    WORKR,BRCNT              INCREASE BRACKET COUNTER\n         LA    WORKR,1(0,WORKR)\n         STH   WORKR,BRCNT\n         B     OTHOP                    OUTPUT OPERATOR\n         SPACE 3\n*              COMMA\nCOMMA    EQU   *\n         TM    HCOMPMOD,SYNTAX          COMPILE MODE\n         BO    OTHOP                    YES\n         CLC   ZARSPO(4),ZARNO         ZARSPO=ZARNO\n         BE    LDO3                          BRANCH IF EQUAL\n         CLC   ZPOSIX(2),FIFTEEN       ZPOSIX=15\n         BE    LCOMMA1                       BRANCH IF EQUAL\n         CLI   ZCLOBRA,X'00'            IS ZCLOBRA = X'FF'\n         BNE   LCOMMA2\n         L     R7,ZBRACK               ZBRACK IS SET INTO R7\n         LA    R7,18(0,R7)\n         CR    ZOUR,R7                       COMPARE ZOUT AND ZBRACK+18\n         BH    LCOMMA3\n         BAL   SUBTSTX,SUSCRITE         TEST IF OPTIMIZATION POSSIBLE\nLCOMMA4  LH    R7,ZPOSIX               ZPOSIX IS SET INTO R7\n         LA    R7,1(0,R7)                    ZPOSIX IS INCREASED BY 1\n         STH   R7,ZPOSIX\n         LA    R7,1(0,ZOUR)\n         ST    R7,ZBRACK               ZBRACK IS SET TO ZOUT+1\n         B     LDO2                     PUT OUT OPERATOR\nLCOMMA1  OI    HCOMPMOD,X'80'          SWITCH SYNTAX CHECK MODE\n         B     LDO3                          BRANCH TO LDO3\nLCOMMA2  MVI   ZCLOBRA,X'00'           ZCLOBRA IS SET TO X'00'\nLCOMMA3  BAL   SUCRIDX,SUCRIDEL\n         B     LCOMMA4                      BRANCH TO LCOMMA4\n         SPACE 3\n*              CLOSING BRACKET\nCLOBRACK EQU   *\n         TM    STATUS,SARRAY            HANDLING ARRAY DECLARATION\n         BO    CLOBRA3\n         TM    HCOMPMOD,SYNTAX          COMPILE MODE\n         BO    OTHOP                    YES\n         CLC   ZARSPO(4),ZARNO          IS THERE AN ARIDSTAB-ENTRY\n         BE    LDO3                     NO\n         CLI   ZCLOBRA,X'00'            PRECEEDING SUBSCR.OPER. CLOBRA.\n         BNE   CLOBRA1                  YES\n         L     R7,ZBRACK                SUBSCRIPT MORE THAN 18 BYTES\n         LA    R7,18(0,R7)\n         CR    ZOUR,R7\n         BH    CLOBRA1                  YES, NO OPTIMIZATION\n         BAL   SUBTSTX,SUSCRITE         TEST IF OPTIMIZABLE\nCLOBRA2  L     R7,ZARSPO                UPDATE CURRENT ARIDSTAB PTR\n         SH    R7,SEVEN\n         ST    R7,ZARSPO\n         C     R7,ZARNO                 ARIDSTAB EMPTY\n         BE    LDO3                     YES\n         MVC   ZPOSIX+1(1),10(R7)       RESET SUBSC.POSITION CNTR. 0217\n         LA    R7,1(0,ZOUR)             SET ZBRACK\n         ST    R7,ZBRACK\n         MVI   ZCLOBRA,X'FF'            LAST SUBSCR. OPER. CLOBRACK\n         B     LDO3\nCLOBRA1  BAL   SUCRIDX,SUCRIDEL         NO OPTIMIZATION POSSIBLE\n         B     CLOBRA2\nCLOBRA3  LH    WORKR,BRCNT              DECREASE BRACKET COUNTER\n         BCTR  WORKR,0\n         STH   WORKR,BRCNT\n         B     OTHOP                    OUTPUT OPERATOR\n         EJECT\nIEX30001 CSECT\n*                   *****  LETTER  *****\n         SPACE\n*              SCAN FOR END OF IDENTIFIER. BRANCH TO IDENT TO SEARCH\n*              FOR THE IDENTIFIER IN ITAB. REPLACE IDENTIFIER BY INTER-\n*              NAL NAME.\n         SPACE\n*              INITILIZED REG ZIDSTAR = IDENTIFIER START ADDRESS\n*              SUBROUTINE LINK IDENTX\n         SPACE\nLETTER5  BAL   R15,ITABMOP              READ ITAB RECORD\n         B     LETTERP\nLETTER   NOP   LETTER5                  BRANCH TO READ ITAB RECORD\nLETTERB  EQU   LETTER+1\nLETTERP  LA    RTO,ZIDEX\n         LA    R0,ZIDEX+6\nLETTER4  LR    RFI,ZINR\n         SR    R2,R2\n         SR    R1,R1\nLETTER6  TRT   0(256,ZINR),IDENTI\n         BZ    LETTER0                  STILL SAME IDENTIFIER\n         LR    ZINR,1                   UPDATE ZINR\n         B     *(R2)\n         B     ZETALET\n         B     RHO\n         B     ERROR1\n*                                  END OF IDENTIFIER IS FOUND\n         B     IDENT                    ITAB SEARCH\nLETTER1  ST    ZITANR,ZITAN             SAVE POINTER TO LAST IDENTIFIER\n         C     ZOUR,ZFILE5              SPACE IN OUTPUTBUFFER\n         BH    LETTER2                  NO SPACE\nLETTER3  MVC   1(5,ZOUR),6(ZITANR)      MOVE INTERNAL NAME TO OUTPUTBUF\n         LA    ZOUR,5(0,ZOUR)\n         B     GENTEST\nLETTER2  BAL   R15,OUCHA\n         B     LETTER3\nLETTER0  LA    ZINR,256(0,ZINR)         UPDATE INPUT PTR\n         B     LETTER6\n         SPACE 3\n*              END OF INPUT BUFFER IN THE MIDLE OF AN IDENTIFIER\nZETALET  BAL   MOVEX,MOVE\n         BAL   R15,ICHA\n         B     LETTER4\n         SPACE 3\n*              LETTER STRING USED AS PARAMETER DELIMITER. REPLACE\n*              STRING BY COMMA.\nRHO      CLI   0(ZOUR),X'26'            RIGHT PARENTHES\n         BNE   GENTEST1                 NO\n         MVI   0(ZOUR),X'25'            REPLACE PARENTHES BY COMMA\n         B     GENTEST1\n         SPACE 3\n*              INVALID CHARACTER IN IDENTIFIER\nERROR1   EQU   *\n         BAL   MOVEX,MOVE\n         MVC   ZERRONU(2),INVOP\n         B     INCOROP\n         SPACE 3\n*                   *****  IDENT  *****\n         SPACE\n*              A SEARCH THRU ITAB FOR THE IDENTIFIER WITH THE STARTADD-\n*              RESS IN ZIDSTAR IS DONE. IF FOUND BRANCH TO ROUTINE FOL1\n*              FOR TYPECHECK, IF NOT REPLACE IDENTIFIER WITH ALL PUR-\n*              POSE IDENTIFIER.\n         SPACE\n*              RECIEVED REG ZIDSTAR = ADDRESS OF IDENTIFIER START *D*\n*              INITILIZED REG ZITANR\n         SPACE\nFOLIR    EQU   WORKR\nZITANR   EQU   R7\nIDENT    BAL   MOVEX,MOVE               MOVE IDENTIFIER\n         MVC   0(5,RTO),ZERO            FILL UP WITH ZERO\n*                                  START ITAB SEARCH\n         L     ZITANR,ZCURITEN          ADDRESS OF LAST ITAB-ENTRY\n         L     R1,ZIBSTAO               ITAB START ADDRESS\n         LH    R0,ELEVEN\n         LCR   R0,R0                    MINUS ELEVEN\nIDENT2   LA    FOLIR,IDENT4\nIDENT3   CLC   0(6,ZITANR),ZIDEX        IDENTIFIER SEARCH\n         BCR   8,FOLIR                  FOUND\nIDENT6   BXH   ZITANR,R0,IDENT3         PROCEED SEARCH, IF NOT ITAB0209\n         SPACE\n         MVC   ZBEGERR(4),OPSTART\n         ST    RTO,ZENDERR\n         MVC   ZERRONU(2),UNDEFOP\n         BAL   MOVERROX,MOVERRO\n         OI    HCOMPMOD,X'80'           SWITCH SYNTAX CHECK MODE\n         LA    ZITANR,ZALLPU            ALL PURPOSE IDENTIFIER\n         B     LETTER1\n         SPACE\nIDENT4   BC    15,IDENT5                BRANCH IF NOT PROC.HEAD    0209\nPROCHD   EQU   IDENT4+1                 PROC.HEAD SWITCH           0209\n         TM    6(ZITANR),X'02'          PROC.OR FORMAL PARAMETER   0209\n         BZ    IDENT6                   NO,CONTINUE SEARCH         0209\n         CLC   8(1,ZITANR),CURPBN       DECLARED IN LAST BLOCK     0209\n         BNE   IDENT6                   NO,CONTINUE SEARCH         0209\nIDENT5   TM    STATUS,SARRAY            HANDLING ARRAY DECLARATION 0209\n         BZ    FOLI                     NO\n         CLC   BRCNT(2),ZERO            IDENTIFIER IN ARRAY LIST\n         BE    FOLI                     NO, ARRAY IDENTIFIER\n         CLC   8(1,ZITANR),CURPBN       DECLARED IN LAST BLOCK\n         BL    FOLI                     NO                       A32962\n         MVC   ZSTO(2),6(ZITANR)        IDENT CHARACTERISTIC     A32962\n         NC    ZSTO(2),ZSTO1                                     A32962\n         CLC   ZSTO(2),ZSTO2            FUNCTION PROCEDURE?      A32962\n         BE    IDENT7                   YES                      A32962\n         CLI   ZSTO,X'02'               FORMAL PARAM OR PROC?    A32962\n         BE    FOLI                     YES                      A32962\nIDENT7   MVC   ZBEGERR(4),OPSTART       GIVE WARNING MESSAGE     A32962\n         ST    RTO,ZENDERR\n         MVC   ZERRONU(2),ARRAYERR\n         BAL   MOVERROX,MOVERRO\n         AR    ZITANR,R0                PROCEED SEARCH FOR IDENTIFIER\n         B     IDENT2\n         SPACE 3\n*                   *****  FOLI  *****\n         SPACE\n*              CHECK TYPE OF IDENTIFIER\nFOLI     IC    WORKR,6(0,ZITANR)        ISOLATE SPECIAL USE BITS\n         N     WORKR,SPECUSE            X'6'\n         AR    WORKR,WORKR              SPECIALUSE BITS MULTIPLIED BY 4\n         B     *+4(WORKR)\n         B     NOCRI                    NON-CRITICAL IDENTIFIER\n         B     PROFU                    PROCEDURE OR FORMAL PARAMETER\n         B     SWILA                    LABEL OR SWITCH\n         B     CRITI                    CRITICAL IDENTIFIER\nNOCRI    EQU   *\n         TM    HCOMPMOD,SYNTAX          COMPILE MODE\n         BO    LETTER1\n         CLI   ZFORTEST,X'00'           APPEARS IDENT. BETWEEN FOR - DO\n         BNE   NOCRI1                   YES\n*                                  SHOULD ENTRY TO LVTAB BE DONE\n         CLC   PFA(4),PFANO             FOR-STATMENT\n         BE    LETTER1                  NO, NO LVTAB-ENTRY\n         CLI   0(ZINR),X'16'            IDENTIFIER FOLLOWED BY ASSIGN.\n         BC    7,LETTER1                NO, NO LVTEB-ENTRY\n         TM    7(ZITANR),X'02'          INTEGER\n         BO    LETTER1                  NO, NO LVTAB-ENTRY\n         BAL   LETRAFX,LETRAF           MAKE ENTRY IN LVTAB\n         B     LETTER1                  RETURN\nNOCRI1   BAL   CRIMAX,CRIMA             MAKE CRIDTAB ENTRY\n         B     LETTER1\n         SPACE 3\n*                   *****  PROFU  *****\n         SPACE\n*              BECAUSE OF POSSIBLE SIDE EFFECTS OF A PROCEDURE, OPTIMI-\n*              ZATION OF SUBSCRIPTS AND FOR-STATEMENTS IS INHIBITED\n         SPACE\n*              SUBROUTINE LINK DELCRIVX\n         SPACE\nPROFU    EQU   *\n         TM    HCOMPMOD,SYNTAX          SYNTAX CHECK MODE\n         BO    LETTER1                  YES\n         MVC   ZARSPO(4),ZARNO          SKIP ARIDSTAB\n         CLI   ZFORTEST,X'C0'           CONTROLLED VARIABLE\n         BNE   PROFU1                   NO\n         L     WORKR,ZFSPTR             YES, CLASSIFIE NORMAL\n         OI    0(WORKR),NORMAL\nPROFU1   EQU   *\n         MVI   ZFORTEST,X'00'           TURN OFF FOR-SWITCH\n         CLC   PFA(4),PFANO             CRIDTAB EMPTY\n         BE    LETTER1                  YES, RETURN\n         BAL   DELCRIVX,DELCRIV         DELETE ALL CRIDTAB-ENTRIES\n         B     LETTER1                  RETURN\n         SPACE 2\n*                   *****  SWILA  *****\n         SPACE\n*              IN CASE OF SWITCH OF LABEL DECLARATION NO ACTION IS\n*              TAKEN. IF USED IN A GO-TO-STATEMENT A TEST IS DONE IF\n*              THE ALFOL-RULES IS FOLLOWED. IF NOT GIVE MESSAGE\n         SPACE\n*              RECIEVED REG ZITANR, ZIDSTAR\n*              WORK REG ZITHEADR, SIGNEMBR, ZFOSTAR, ZIGNDECR\n         SPACE\nZITHEADR EQU   R1\nZFOSTAR  EQU   R1\nZIGNEMBR EQU   R2\nZIGNDECR EQU   R9\n         SPACE\nSWILA    LR    ZITHEADR,ZITANR          START SEARCH FOR HEADING ENTRY\nSWILA1   SH    ZITHEADR,ELEVEN\n         CLI   5(ZITHEADR),X'2B'        HEADING TEST\n         BNE   SWILA1                   NO HEADING\n         MVC   ALIGNH(2),8(ZITHEADR)\n         L     ZIGNDECR,ALIGN\n         LH    ZIGNEMBR,ZIGN            ACTUELL IGN\n         LA    ZFOSTAR,ZFOSTA-1         ADDRESS OF BYTE PRECEED. FSTAB\nSWILA2   CR    ZIGNEMBR,ZIGNDECR        COMPORE DECLARAD AND CUR. IGN\n         BH    SWILA3                   CHECK EMBRACING IGN TO CUR. IGN\n         BE    LETTER1\n         TM    STATUS,SSWITCH           IN SWITCH DECLARATION\n         BZ    SWILA21                  NO, SERIOUS ERROR\n         MVC   ZBEGERR(4),OPSTART       YES, GEVE WARNING MESSAGE\n         ST    RTO,ZENDERR\n         MVC   ZERRONU(2),SWITCHER\n         BAL   MOVERROX,MOVERRO\n         B     LETTER1\nSWILA21  EQU   *\n         MVC   ZERRONU(2),GOTOFOR\n         B     INCOROP\nSWILA3   LR    WORKR,ZIGNEMBR           COMPUTE ADDRESS OF IGN-TAB-ENTR\n         AR    WORKR,ZIGNEMBR\n         AR    WORKR,ZIGNEMBR           3+ZIGNEMB\n         LA    WORKR,GPTAB(WORKR)       GPTAB+3*ZIGNEMB\n         CLI   2(WORKR),X'00'           TEST IF FORGROUP\n         BE    SWILA4                   NO\n         MVC   *+9(1),2(WORKR)          ADDRESS ACTUELL ENTRY IN FSTAB\n         OI    0(ZFOSTAR),X'20'         SET BIT INDICAT BRANCH OUTOF FS\nSWILA4   MVC   ALIGNH(2),0(WORKR)\n         L     ZIGNEMBR,ALIGN           LOAD EMBRACING IGN\n         B     SWILA2\n         SPACE 3\n*                   *****  CRITI  *****\n         SPACE\n*              ROUTINE ENTRED WHEN A CRITICAL IDENTIFIER IS FOUND IN\n*              ITAB. IF THE IDENTIFIER APPEARS BETWEEN FOR AND DO A\n*              NEW CHAINED CRIDTAB-ENTRY IS MADE. OTHERWISE ONLY THE\n*              FSTAB-ENTRY IS TREATED.\n         SPACE\n*              WORK REG ZMR,PFAR\n         SPACE\nZMR      EQU   R1\nCRITI    CLI   ZFORTEST,X'00'           CRITICAL IDENTIFIER IN FOR-LIST\n         BNE   CRITIF                   YES\n         SPACE\n*                                  IDENTIFIER NOT FOR-LIST-ELEMENT\n         CLC   ZARSPO(4),ZARNO          CURRENTLY HANDLING SUBSCR.EXPR.\n         BC    7,LETTER1                YES\n         L     ZMR,PFA                  POINTER TO LAST CRIDTAB-ENTRY\nCRITI1   CLC   1(3,ZMR),8(ZITANR)       SCAN CRIDTAB FOR LAST ENTRY\n         BE    CRITI2                   FOUND\n         SH    ZMR,NINE\n         B     CRITI1\n         SPACE\nCRITI2   CLI   0(ZINR),X'16'            IDENTIFIER FOLLOWED BY ASSIGNM\n         BE    CRITI3                   YES\n         TM    4(ZMR),X'80'             CONTROLLED VARIABEL\n         BZ    LETTER1                  NO, RETURN\n         SR    WORKR,WORKR              ADDRESS FSTAB-ENTRY\n         IC    WORKR,0(0,ZMR)\n         LA    WORKR,ZFOSTA(WORKR)\n         OI    0(WORKR),X'80'           ELEMENTARY LOOP\n         B     LETTER1                  RETURN\n         SPACE\n*                                  IDENTIFIER FOLLOWED BY ASSIGNMENT\nCRITI3   SR    WORKR,WORKR              GET ADDRESS OF FSTAB-ENTRY\n         IC    WORKR,0(0,ZMR)\n         LA    WORKR,ZFOSTA(WORKR)\n         TM    4(ZMR),X'80'             CONTROLLED VARIABEL\n         BO    CRITI4                   YES\n         OI    0(WORKR),NORMAL          NORMAL LOOP\n         TM    4(ZMR),X'40'             MORE CHAINED ENTRIES\n         BZ    LETTER1                  NO, RETURN\n         MVC   ALIGNH(2),5(ZMR)         GET ADDRESS OF NEXT ENTRY\n         L     ZMR,ALIGN\n         A     ZMR,ZFOCRI\n         B     CRITI3                   HANDLE NEXT ENTRY\nCRITI4   OI    0(WORKR),X'40'           INDICATE ASSIGN. TO CTR VAR\n         B     LETTER1\n         SPACE\n*                                  TREATMENT OF CRIT. ID. IN FOR-LIST\nCRITIF   BAL   CRIMAX,CRIMA             MAKE CRIDTAB-ENTRY\n         L     PFAR,PFA                 PTR TO LAST CRIDTAB-ENTRY\n         LR    ZMR,PFAR            START SCAN FOR PREVIOUS ENTRY\nCRITIF1  SH    ZMR,NINE\n         C     ZMR,PFANO                IS THARE A PREVIOUS ENTRY\n         BC    12,LETTER1               NO, DELETED AT CRIDTAB-OVERFLOW\n         CLC   1(3,ZMR),1(PFAR)         PREVIOUS ENTRY\n         BNE   CRITIF1                  NO\n         SPACE\n*                                  PREVIOUS ENTRY IN CRIDTAB FOUND\n         BAL   PUTCHX,PUTCHAIN          CHAIN NEW ENTRY TO PREVIOUS\n         TM    4(PFAR),X'80'            NEW ENTRY CONTROLLED VARIABEL\n         BZ    CRITIN                   NO\n         SPACE\n*                                  TREATMENT OF CONTROLLED VARIABEL\nCRITIC   SR    WORKR,WORKR\n         IC    WORKR,0(0,ZMR)           FSN OF CHAINED CRIDTAB-ENTRY\n         LA    WORKR,ZFOSTA(WORKR)      ADDRESS OF CHAINED FSTAB-ENTRY\n         TM    4(ZMR),X'80'             CHAINED ENTRY CONTROLLED\n         BO    CRITIC1                  YES\n         OI    0(WORKR),NORMAL          INDICATE NORMAL LOOP\n         TM    4(ZMR),X'40'             MORE CHAINED ENTRIES\n         BZ    LETTER1                  NO, RETURN\n         MVC   ALIGNH(2),5(ZMR)    GET ADDRESS OF NEXT CHAINED ENTRY\n         L     ZMR,ALIGN\n         A     ZMR,ZFOCRI\n         B     CRITIC\n         SPACE\nCRITIC1  OI    0(WORKR),X'40'           BIT FOR ASSIGN. TO CONTR. VAR.\n         B     LETTER1\n         SPACE\n*                                  TREATMENT OF NON-CONTROLLED VARIABEL\nCRITIN   TM    4(ZMR),X'80'             CHAINED ENTRY CONTROLLED\n         BO    CRITIN1                  YES\n         TM    4(ZMR),X'40'             MORE CHAINED ENTRIES\n         BZ    LETTER1                  NO\n         MVC   ALIGNH(2),5(ZMR)         GET ADDRESS OF CHAINED ENTRY\n         L     ZMR,ALIGN\n         A     ZMR,ZFOCRI\n         B     CRITIN\n         SPACE\nCRITIN1  SR    WORKR,WORKR              GET ADDRESS OF CHAINED FSTAB-EN\n         IC    WORKR,0(0,ZMR)\n         LA    WORKR,ZFOSTA(WORKR)\n         CLC   0(1,ZMR),ZFSN            CHAINED ENTRY PART OF ACTIV FOR\n         BE    CRITIN2                  YES\n         CLC   ZARSPO(4),ZARNO          CURRENTLY HANDLING A SUBSCRIPT\n         BC    7,LETTER1                YES, RETURN\n         OI    0(WORKR),X'80'           SET ELEMENTARY LOOP\n         B     LETTER1\nCRITIN2  OI    0(WORKR),NORMAL          INDICATE NORMAL LOOP\n         B     LETTER1\n         SPACE 3\n*                   *****  PUTCHAIN  *****\n         SPACE\n*              ROUTINE TO CHAIN NEW CRIDTAB-ENTRY TO PREVIOUS\n         SPACE\n*              RETURN REG PUTCHX\n*              RECIEVED REG PFAR, ZMR\n         SPACE\nPUTCHX   EQU   R15\nPUTCHAIN OI    4(PFAR),X'40'            BIT FOR PREVIOUS CRITICAL IDENT\n         OI    4(ZMR),X'20'             BIT FOR SUBSEQUENT CRIT. IDENT\n         L     WORKX,ZFOCRI             CRIDTAB START ADDRESS\n         LR    WORKR,ZMR                GET BACKWARD CHAIN\n         SR    WORKR,WORKX\n         ST    WORKR,ALIGN\n         MVC   5(2,PFAR),ALIGNH\n         LR    WORKR,PFAR               GET FORWARD CHAIN\n         SR    WORKR,WORKX\n         ST    WORKR,ALIGN\n         MVC   7(2,ZMR),ALIGNH\n         BR    PUTCHX                   RETURN\n         SPACE 3\n*                   *****  CRIMA  *****\n         SPACE\n*              SUBROUTINE TO MAKE A NEW CRIDTAB-ENTRY. IN CASE OF\n*              CRIDTAB OVERFLOW THE ROUTINE CRIFLOW IS ENTRED TO\n*              DELETE FROM CRIDTAB ALL ENTRIES BELONG TO THE MOST\n*              EMBRACING FOR-STATEMENT. CRIFODEL IS ENTERED IF AN\n*              ARRAY ELEMENT IS HANDELED.\n         SPACE\n*              RETURN REG CRIMAX\n*              RECIEVED REG ZITANR  POINTER TO ACTUELL ITAB ENTRY\n*              WORK REG PFAR\n*              SUBROUTINE CRIFLOW, LETRAF,CRIFODEL, SUCRIDEL\n         SPACE\nPFAR     EQU   R8\nCRIMAX   EQU   R14\n         SPACE\nCRIMA    TM    7(ZITANR),X'04'          ARRAY\n         BO    CRIMA1                   YES, NO OPTIMIZATION POSSIBLE\n         L     PFAR,PFA                 CURRENT CRIDTAB PTR\n         TM    ZFORTEST,X'C0'           CONTROLLED VARIABLE\n         BO    CRIMAC                   YES\n         SPACE\n*                                  TREATMENT OF 'NOT CONTROLLED' VARIAB\n         C     PFAR,PFAMAX              CRIDTAB OVERFLOW\n         BE    CRIMAN1                  YES\nCRIMAN2  LA    PFAR,9(0,PFAR)           UPDATE CURRENT PTR\n         MVI   4(PFAR),X'00'            FLAG-BYTE SHOWS NO CTR.VARIABEL\n         TM    7(ZITANR),X'02'          INTEGER\n         BZ    CRIMA2                   YES\n         L     WORKR,ZFSPTR             ADDRESS FSTAB ENTRY\n         OI    0(WORKR),NOCOUNT         CLASSIFY AS NOT COUNTING LOOP\n         SPACE\nCRIMA2   MVC   1(3,PFAR),8(ZITANR)      MOVE ADDRESS PART TO CRIDTAB\n         MVC   0(1,PFAR),ZFSN           MOVE FSN TO CRIDTAB\n         LR    WORKR,ZITANR             GET RELATIVE ADDRESS IN ITAB\n         S     WORKR,ZIBSTAO\n         ST    WORKR,ALIGN              ITAB RELATIVE ADDRESS\n         MVC   5(2,PFAR),ALIGNH\n         OI    6(ZITANR),X'06'          TURN ON SPECIAL USE BITS\n         ST    PFAR,PFA                 SAVE CURRENT PTR\n         BR    CRIMAX                   RETURN\n         SPACE\nCRIMAN1  EQU   *\n         BAL   CRIFLOWX,CRIFLOW         DELETE MOST EMBRACING FOR-STAT.\n         C     PFAR,PFANO               ALL CRIDTAB DELETED\n         BNE   CRIMAN2                  NO\n         MVI   ZFORTEST,X'00'           NO MOR CRIDTABENTRIES TO BE DON\n         BR    CRIMAX\n         SPACE\nCRIMAC   TM    7(ZITANR),X'02'          INTEGER\n         BZ    CRIMAC1                  YES\n         L     WORKR,ZFSPTR             CURRENT FSTAB PTR\n         OI    0(WORKR),X'80'           SET BIT FOR ELEMENTARY LOOP\nCRIMAC4  C     PFAR,PFAMAX              OVERFLOW\n         BE    CRIMAC2                  YES\nCRIMAC3  LA    PFAR,9(0,PFAR)           UPDATE CURRENT PTR\n         MVI   ZFORTEST,X'80'           INDICATE CONTR. VAR. TREATED\n         MVI   4(PFAR),X'80'            SET BIT FOR CONTROLLED VAR.\n         B     CRIMA2\n         SPACE\nCRIMAC1  C     PFAR,PFANO               NESTED FOR STATEMENT\n         BE    CRIMAC3                  NO\n         BAL   LETRAFX,LETRAF           MAKE LVTAB ENTRY\n         B     CRIMAC4\nCRIMAC2  BAL   CRIFLOWX,CRIFLOW         CRIDTAB OVERFLOW\n         B     CRIMAC3\nCRIMA1   L     WORKR,ZFSPTR             CURRENT FSTAB PTR\n         OI    0(WORKR),NORMAL          NORMAL LOOP\n         MVI   ZFORTEST,X'00'           NO MORE CRIDTAB-ENTRIES\n         BR    CRIMAX                   RETURN\n         SPACE 3\n*                   *****  CRIFLOW  *****\n         SPACE\n*              THE SUBROUTINE IS ENTERED AT CRIDTAB OVERFLOW TO DELETE\n*              ALL CRIDTAB-ENTRIES BELONGING TO THE MOST EMBRACING\n*              FOR-STATEMENT\n         SPACE\n*              RETURN REG CRIFLOWX\n*              WORK REG ZMAR, ZMIR, ZMATOR\n         SPACE\nZMIR     EQU   R1\nZMATOR   EQU   R9\nCRIFLOWX EQU   R15\n         SPACE\nCRIFLOW  L     ZMAR,ZFOCRI              CRIDTAB START ADDRESS\n         CLC   0(1,ZMAR),0(PFAR)        ALL ENTRIES FROM SAME FOR-ST.\n         BE    DELCRIV                  YES, DELETE WHOLE CRIDTAB\n         MVC   FSNEMBR(1),0(ZMAR)       SAVE MOST EMBRACING FSN\nCRIFLOW1 CLC   0(1,ZMAR),FSNEMBR        ENTRY OF MOST EMBRACING FOR-ST.\n         BNE   CRIFLOW2                 NO\n         TM    4(ZMAR),X'20'            SUBSEQUENT CHAINED ENTRY\n         BO    CRIFLOW3                 YES\n         SPACE\n         MVC   ALIGNH(2),5(ZMAR)        ADDRESS ITAB-ENTRY\n         L     WORKR,ALIGN\n         A     WORKR,ZIBSTAO\n         NI    6(WORKR),X'F9'           SET SPECIAL USE BITS TO 00\nCRIFLOW4 LA    ZMAR,9(0,ZMAR)           ADDRESS NEXT CRIDTAB ENTRY\n         B     CRIFLOW1\n         SPACE\nCRIFLOW3 MVC   ALIGNH(2),7(ZMAR)        ADDRESS CHAINED ENTRY\n         L     WORKR,ALIGN\n         A     WORKR,ZFOCRI\n         NI    4(WORKR),X'B0'           TURN OFF BIT FOR PRECEED. ENTRY\n         MVC   5(2,WORKR),5(ZMAR)       INSERT RELATIVE ITAB-ADDRESS\n         B     CRIFLOW4\n         SPACE\nCRIFLOW2 SR    WORKR,WORKR              ADDRESS FSTAB-ENTRY OF DEL. FOR\n         IC    WORKR,FSNEMBR\n         LA    WORKR,ZFOSTA(WORKR)\n         OI    0(WORKR),NORMAL          NORMAL LOOP\n         L     ZMATOR,ZFOCRI            CRIDTAB START ADDRESS\n         LR    ZMIR,ZMAR\n         SR    ZMIR,ZMATOR              GET LENGTH OF DELETED PART\n         SPACE\nCRIFLOW5 TM    4(ZMAR),X'40'       PRECEEDING CRIDTAB-ENTRY\n         BZ    CRIFLOW6            NO\n         MVC   ALIGNH(2),5(ZMAR)        DECREASE CHAIN-ADDRESS\n         L     WORKR,ALIGN\n         SR    WORKR,ZMIR\n         ST    WORKR,ALIGN\n         MVC   5(2,ZMAR),ALIGNH\nCRIFLOW6 TM    4(ZMAR),X'20'       SUBSEQUENT CRITAB-ENTRY\n         BZ    CRIFLOW7\n         MVC   ALIGNH(2),7(ZMAR)        DECREASE CHAIN-ADDRESS\n         L     WORKR,ALIGN\n         SR    WORKR,ZMIR\n         ST    WORKR,ALIGN\n         MVC   7(2,ZMAR),ALIGNH\nCRIFLOW7 MVC   0(9,ZMATOR),0(ZMAR)      MOVE ENTRY DOWN IN CRIDTAB\n         CR    ZMAR,PFAR                LAST ENTRY\n         BE    CRIFLOW8            YES\n         LA    ZMAR,9(0,ZMAR)      ADDRESS NEXT ENTRY\n         LA    ZMATOR,9(0,ZMATOR)\n         B     CRIFLOW5\n         SPACE\nCRIFLOW8 SR    PFAR,ZMIR                GET ADDRESS OF LAST CRIDTAB-ENT\n         BR    CRIFLOWX\n         SPACE 3\n*                   *****  DELCRIV  *****\n         SPACE\n*              ROUTINE TO DELETE ALL ENTRIES IN CRIDTAB AND TURN OFF\n*              THE SPECIAL USE BITS OF CORRESPONDING ITAB ENTRY. ALL\n*              FOR-STATEMENTS WITH CRIDTAB-ENTRIES WILL BE CLASSIFIED\n*              NORMAL\n         SPACE\n*              RETURN REG DELCRIVX\n*              INITILIZED REG PFAR\n         SPACE\nDELCRIVX EQU   CRIFLOWX\n         SPACE\nDELCRIV  L     WORKR,ZFOCRI             CRIDTAB START ADDRESS\nDELCRIV1 SR    WORKX,WORKX              ADDRESS FSTAB-ENTRY\n         IC    WORKX,0(0,WORKR)\n         LA    WORKX,ZFOSTA(WORKX)\n         OI    0(WORKX),NORMAL          CLASSIFIE NORMAL\n         TM    4(WORKR),X'40'           IDENT. CRIT.IN EMBR. FOR-STAT.\n         BO    DELCRIV2                 YES, ITAB-ENTRY ALREADY NON-CRI\n         MVC   ALIGNH(2),5(WORKR)       ADDRESS ITAB ENTRY\n         L     WORKX,ALIGN\n         A     WORKX,ZIBSTAO\n         NI    6(WORKX),X'F9'           CLEAR SPEC. USE BITS\nDELCRIV2 C     WORKR,PFA                LAST CRIDTAB-ENTRY\n         BE    DELCRIV3                 YES\n         LA    WORKR,9(0,WORKR)         ADDRESS NEXT CRIDTAB-ENTRY\n         B     DELCRIV1\nDELCRIV3 L     PFAR,PFANO\n         ST    PFAR,PFA\n         BR    DELCRIVX\n         SPACE 3\n*                   *****  CRIFODEL  *****\n         SPACE\n*              ROUTINE TO DELETE THE CRIDTAB ENTRIES OF THE LAST FOR-\n*              STATEMENT\n         SPACE\n*              RETURN REG R15\n*              WORK REG PFAR\n         SPACE\nCRIFODEL L     PFAR,PFA                 POINTER TO LAST CRIDTAB-ENTRY\n         MVC   CRIFODS+1(1),0(PFAR)     INSERT FOR STATEMENT NUMBER\nCRIFOD1  C     PFAR,PFANO               CRIDTAB EMPTY\n         BE    CRIFOD4                  YES, RETURN\nCRIFODS  CLI   0(PFAR),X'00'            NEW FORSTATEMENT, OLD FSN INSER\n         BNE   CRIFOD4                  YES, RETURN\n         TM    4(PFAR),X'40'            IDENTIFIER USED IN EMBR. FOR-ST\n         BO    CRIFOD2                  YES\n         SPACE\n         MVC   ALIGNH(2),5(PFAR)   CLEAR SPECIAL USE BITS IN CRIDTAB\n         L     WORKR,ALIGN\n         A     WORKR,ZIBSTAO            ABSOLUTE ITAB ADDRESS\n         NI    6(WORKR),X'F9'           CLEAR SPECIAL USE BITS IN ITAB\nCRIFOD3  SH    PFAR,NINE                POINT TO PRECEEDING ENTRY\n         B     CRIFOD1\n         SPACE\nCRIFOD2  L     WORKR,ZFOCRI        TURN OFF BIT FOR SUBSEQUENT ENTRY\n         MVC   ALIGNH(2),5(PFAR)        ADDRESS OF PREVIOUS CRIDTAB-ENT\n         A     WORKR,ALIGN\n         NI    4(WORKR),X'CF'           TURN OFF BIT FOR SUBSEQ. ENTRY\n         B     CRIFOD3                  GET NEXT ENTRY\n         SPACE\nCRIFOD4  ST    PFAR,PFA\n         BR    R15\n         SPACE 3\n*                   *****  SUCRIDEL  *****\n*              THE SUBROUTINE IS ENTERED WHEN UNOPTIMIZABLE SUB-\n*              SCRIPT EXPRESSION IS FOUND. A SCAN BETWEEN THE TWO LAST\n*              SUBSCRIPT OPERATORS IS DONE IN THE OUTPUT BUFFER. IF A\n*              CONTROLLED CRITICAL IDENTIFIER IS FOUND, CORRESPONDING\n*              ENTRY IN FSTAB IS MADE ELEMENTARY. OTHERWISE NO ACTION.\n         SPACE\n*              RETURN REG SUCRIDX\n*              WORK REG ZSUPOR, ZLESUR, ZMSR\n         SPACE\nZSUPOR   EQU   R1\nZLESUR   EQU    R2\nZMSR     EQU   R14\nSUCRIDX  EQU   R15\nSUCRIDEL CLC   PFA(4),PFANO             CRIDTAB EMPTY\n         BCR   8,SUCRIDX                YES, RETURN\n         LA    ZLESUR,1(0,ZOUR)         ADDRESS OF LAST SUBSCR. OPERAND\n         L     ZSUPOR,ZBRACK            ADDRESS OF FIRST SUBSCR.OPERAND\n         SPACE\nSUCRID1  LA    ZSUPOR,1(0,ZSUPOR)       CHECK NEXT BYTE\nSUCRID2  CR    ZSUPOR,ZLESUR            END OF SCAN\n         BCR   10,SUCRIDX               YES, RETURN\n         TM    0(ZSUPOR),X'80'          IS AN OPERAND FOUND\n         BZ    SUCRID1                  NO\n         TM    0(ZSUPOR),X'06'          CRITICAL IDENTIFIER\n         BO    SUCRID4                  YES\nSUCRID3  LA    ZSUPOR,5(0,ZSUPOR)       ADDRESS NEXT ELEMENT\n         B     SUCRID2\n         SPACE\n*                                  TREATMENT OF CRITICAL IDENTIFIERS\nSUCRID4  L     ZMSR,PFA                 ADDRESS OF LAST CRIDTAB ENTRY\n         LA    ZMSR,9(0,ZMSR)\nSUCRID5  SH    ZMSR,NINE                FIND IDENTIFIER IN CRIDTAB\n         CLC   1(3,ZMSR),2(ZSUPOR)      IDENTIFIER FOUND\n         BNE   SUCRID5                  NO\n         SPACE\nSUCRID6  TM    4(ZMSR),X'80'            CONTROLLED VARIABEL\n         BZ    SUCRID7                  NO\n         LA    WORKR,ZFOSTA             ADDRESS OF FSTAB\n         MVC   *+9(1),0(ZMSR)           DISPLACEMENT EQVALS FOR-NUMBER\n         OI    0(WORKR),X'80'           ELEMENTARY LOUP\n         B     SUCRID3\n         SPACE\n*                                  FIND CHAINED CONTROLLED VARIABEL\nSUCRID7  TM    4(ZMSR),X'40'            ANY CHAINING\n         BZ    SUCRID3                  NO\n         MVC   ALIGNH(2),5(ZMSR)        CRIDTAB CHAIN\n         L     ZMSR,ALIGN\n         A     ZMSR,ZFOCRI              ADDRESS CHAINED ENTRY\n         B     SUCRID6\n         SPACE 3\n*                   *****  LETRAF  *****\n         SPACE\n*              MAKE ENTRIES IN LVTAB CORRESPONDING TO ALL SUBSCRIPTABLE\n*              NESTED FOR-STATEMENTS\n         SPACE\n*              RETURN REG LETRAFX\n*              RECIEVED REG ZITANR\n*              WORK REG ZMER, ZMAR, ZLEVAR\n         SPACE\nZMER     EQU   R1\nZMAR     EQU   R2\nZLEVAR   EQU   WORKX\nLETRAFX  EQU   R9\nLETRAF   EQU   *\n         CLI   ZLVOV,X'FF'              HAS TABLE OVERFLOW OCCURED\n         BCR   8,LETRAFX                YES\n         L     ZMER,PFA                 ADDRESS OF LAST CRIDTAB ENTRY\nLETRAF1  LR    ZMAR,ZMER\n         LA    WORKR,ZFOSTA\n         MVC   *+9(1),0(ZMER)           ADDRESS ACTUAL FSTAB-ENTRY\n         TM    0(WORKR),NOSUOP\n         BO    LETRAF2\n         L     ZLEVAR,ZLEVA\n         C     ZLEVAR,ZLESTA            HAS A WRITE BEEN ISSUED\n         BNE   LETRAF5                  NO\n         BAL   WORKR,CHECK         YES, CHECK\n          CLC   LVLENGTH(4),LVTAB40S    MORE OUTPUT ALLOWED\n         BNL   LETRAF4                  NO\n          LH   WORKR,LVCNT              STEP RECORD COUNTER\n         LA    WORKR,1(0,WORKR)\n         STH   WORKR,LVCNT\nLETRAF5  LA    ZLEVAR,4(0,ZLEVAR)\n         MVC   0(1,ZLEVAR),0(ZMER)      PLUG IN FS-NUMBER\n         MVC   1(3,ZLEVAR),8(ZITANR)    PLUG IN ADDRESSPART OF CUR. ID.\n         C     ZLEVAR,ZLEMAX            LVTAB FILLED UP\n         BE    LETRAF3                  YES\nLETRAF6  ST    ZLEVAR,ZLEVA\nLETRAF2  SH    ZMER,NINE                GET NEXT CRIDTAB-ENTRY\n         C     ZMER,PFANO               BEGINNING OF CRIDTAB\n         BCR   8,LETRAFX                YES, RETURN\n         CLC   0(1,ZMER),0(ZMAR)        IS IT AN ENTRY IN SAME FS\n         BE    LETRAF2                  SAME\n         B     LETRAF1                  NEW\n         SPACE\nLETRAF3  EQU   *\n         BAL   WORKR,CHECK              CHECK POSSIBLE WRITE\n         L     WORKR,LVSTRT             WRITE START ADDRESS\n         L     WORKX,LVTAB30S           LENGTH OF WRITE\n         BAL   R15,WRITE                WRITE\n         L     WORKR,LVLENGTH           LENGTH OF LVTAB\n         A     WORKR,LVTAB30S           BUFFER LENGTH\n         ST    WORKR,LVLENGTH\n         L     ZLEVAR,ZLESTA            START ADDRESS OF LVTAB\n         B     LETRAF6\nLETRAF4  EQU   *\n         BAL   R15,TABOFLO\n         BAL   MOVERROX,MOVERRO\n         BR    LETRAFX\n         EJECT\n*                   *****  SUSCRITE  ******\n         SPACE\n*              ROUTINE TO CHECK IF AN SUBSCRIPT EXPRESSION IS OPTIMIZA-\n*              BLE IN WHAT CASE AN SUTAB-ENTRY IS DONE, OTHER SUBROU-\n*              TINE SUCRIDEL IS ENTRED BEFORE RETURN.\n         SPACE\n*              RETURN REG SUBTSTX\n*              WORK REG ZARSPOR, SUBR, OPPTR, ADDENDR, CVR, SUTR\n*              SUBROUTINE LINKS OPERANDX, SUBMULTX, SUTABX\n         SPACE\nSUBR     EQU   R1\nSUTR     EQU   R1\nOPPTR    EQU   R2\nZARSPOR  EQU   R2\nADDENDR  EQU   R7\nCVR      EQU   R8\nSUTABX   EQU   R14\nSUBTSTX  EQU   R9\nSUBMULTX EQU   R14\nOPERANDX EQU   R15\n         SPACE\nSUSCRITE L     SUBR,ZBRACK              INITILIZE CURRENT POINTER\n         LR    WORKR,ZOUR               ADDRESS OF LAST BYTE OF SUBSCR.\n         SH    WORKR,FIVE               ADDRESS OPERATOR BEFOR LAST OPD\n         ST    WORKR,SUBEND\n         CLI   1(SUBR),X'01'            SUBSCRIPT START WITH + OR -\n         BH    SUB1                     NO\n         LA    SUBR,1(0,SUBR)           POINT TO BYTE BEFORE OPERAND\n         SPACE\nSUB1     C     SUBR,SUBEND              ANY OPERAND IN SUBSCRIPT\n         BCR   2,SUBTSTX                NO, RETURN\n         BAL   OPERANDX,OPERAND         TEST OPERAND\n         C     SUBR,SUBEND              END OF SUBSCRIPT\n         BE    SUBONE\n         CLI   6(SUBR),X'02'            WHAT FOLLOWS FIRST OPERAND\n         BL    SUBPM                    PLUS OR MINUS\n         BE    SUBAST                   ASTERISK\n         SPACE\n*                                  UNOPTIMIZABLE SUBSCRIPT EXPRESSION\nSUBNOOP  BAL   SUCRIDX,SUCRIDEL         HANDLE UNOPTIMIZABLE EXPRESSION\n         BR    SUBTSTX                  RETURN\n         SPACE\n         SPACE\n*                                  ONLY ONE OPERAND\nSUBONE   LTR   CVR,OPPTR                CONTROLLED VARIABLE\n         BP    SUBONE3                  YES\n         MVC   ADDEND(6),0(SUBR)        OPERAND IS ADDEND\n         MVC   FACTOR(6),ZEROELEM       SET FACTOR TO ZERO\n         L     CVR,ZFOCRI               ADDRESS OF LAST CRIDTAB ENTRY\n         L     ZARSPOR,ZARSPO           ADDRESS CURRENT ARIDSTAB-ENTRY\nSUBONE1  SR    WORKR,WORKR              GET FSN\n         IC    WORKR,0(0,CVR)\n         STC   WORKR,OLDFSN\n         LA    WORKX,ZFOSTA(WORKR)      ADDRESS FSTAB-ENTRY\n         TM    0(WORKX),X'40'           SUBSCRIPT OPTIMIZATION POSSIBLE\n         BO    SUBONE2\n         L     ZARSPOR,ZARSPO           ADDRESS LAST ARIDSTACK ENTRY\n         LA    WORKX,SPTAB(WORKR)       ADDRESS SPTAB-ENTRY\n         CLC   0(1,WORKX),0(ZARSPOR)    SCOPE OF ARRAY OK\n         BL    SUBONE2                  NO\n         TM    ADDEND+2,X'30'           CONSTANT\n         BZ    SUBONE4                  YES\n         CLC   0(1,WORKX),ADDEND+3      SCOPE-TEST OF ADDEND\n         BL    SUBONE2                  NOT OK\nSUBONE4  BAL   SUTABX,SUTABENT          MAKE SUTAB-ENTRY\nSUBONE2  C     CVR,PFA                  END OF CRIDTAB\n         BCR   8,SUBTSTX                YES,RETURN\n         LA    CVR,9(0,CVR)             FIND ENCLOSED FOR STATEMENT\nOLDFSN   EQU   *+1\n         CLI   0(CVR),X'00'             ENTRY TO SAME FOR-STATEMENT\n         BE    SUBONE2                  YES, CHECK NEXT ENTRY\n         B     SUBONE1                  NO, POSSIBLY NEW SUTAB-ENTRY\n         SPACE\n*                                  OPERAND IS CONTROLLED VARIABEL\nSUBONE3  MVC   FACTOR(1),0(SUBR)        OPERATOR TO FACTOR\n         MVC   FACTOR+1(5),ONEELEM+1    SET FACTOR TO ONE\nSUBONE5  MVC   ADDEND(6),ZEROELEM       SET ADDEND TO ZERO\n         B     SUBFIN1\n*                                  FIRST OPERAND FOLLOWED BY + OR -.\nSUBPM    MVC   ADDEND(6),0(SUBR)        FIRST OPERAND PROBABLY ADDEND\n         LR    ADDENDR,OPPTR            SAVE CRIDTAB POINTER\n         LA    SUBR,6(0,SUBR)           ADDRESS SIGN OF SECOND OPERAND\n         BAL   OPERANDX,OPERAND         CHECK SECOND OPERAND\n         C     SUBR,SUBEND              END OF SUBSCRIPT\n         BE    SUBPM1                   YES\n         CLI   6(SUBR),X'02'            ASTERISK SHOULD FOLLOW\n         BNE   SUBNOOP                  NOT OPTIMIZABLE\n         BAL   SUBMULTX,SUBMULT         CHECK MULTIPLICATION\n         B     SUBFIN                   TERMINATE\n         SPACE\nSUBPM1   CR    OPPTR,ADDENDR            WHAT IS SECOND OPERAND\n         BL    SUBPM3                   ADDEND\n         BE    SUBPM4                   NOT OPTIMIZABLE EXPRESSION\n         LR    CVR,OPPTR                ADDRESS CRIDTAB-ENTRY OF CONTR.\n         MVC   FACTOR(1),0(SUBR)        SIGN OF FACTOR\nSUBPM2   MVC   FACTOR+1(5),ONEELEM+1    SET FACTOR TO ONE\n         B     SUBFIN\nSUBPM3   LR    CVR,ADDENDR              SECOND OPERAND ADDEND, SHIFT\n         LR    ADDENDR,OPPTR\n         MVC   FACTOR(1),ADDEND         SIGN OF FACTOR\n         MVC   ADDEND(6),0(SUBR)\n         B     SUBPM2\nSUBPM4   LTR   CVR,ADDENDR              CONTROLLED VARIABEL\n         BCR   8,SUBTSTX                NO\n         B     SUBFIN4                  YES\n         SPACE\n*                                  FIRST OPERAND FOLLOWED BY ASTERISK\nSUBAST   BAL   SUBMULTX,SUBMULT         CHECK MULTIPLICATION\n         C     SUBR,SUBEND              END OF SUBSCRIPT\n         BE    SUBONE5                  YES, SET ADDEND TO ZERO\n         CLI   6(SUBR),X'01'            PLUS OR MINUS\n         BH    SUBNOOP                  NO, NO SUBSCRIPT OPTIMIZATION\n         LA    SUBR,6(0,SUBR)           ADDRESS SIGN\n         BAL   OPERANDX,OPERAND         CHECK OPERAND\n         MVC   ADDEND(6),0(SUBR)        SAVE ADDEND\n         LR    ADDENDR,OPPTR            LAST OPERAND WAS ADDEND\n         SPACE\nSUBFIN   LTR   ADDENDR,ADDENDR          ADDEND CONTROLLED VARIABEL\n         BZ    SUBFIN1                  NO\n         SR    WORKR,WORKR              YES INDICATE ELEMENTARY LOOP\n         IC    WORKR,0(0,ADDENDR)\n         LA    WORKX,ZFOSTA(WORKR)\n         OI    0(WORKX),X'80'\n         CR    CVR,ADDENDR              OPTIMIZATION POSSIBLE\n         BNH   SUBFIN4                  NO\nSUBFIN1  SR    WORKR,WORKR              FSN OF CONTROLLED VAR.TO RE6\n         IC    WORKR,0(0,CVR)\n         L     ZARSPOR,ZARSPO           ADDRESS LAST ARIDSTAB-ENTRY\n         LA    WORKX,ZFOSTA(WORKR)      ADDRESS FSTAB-ENTRY\n         TM    0(WORKX),X'40'           SUBSCRIPT OPTIMIZATION POSSIBLE\n         BO    SUBFIN4                  NO, NO OPTIMIZATION\n         LA    WORKX,SPTAB(WORKR)       ADDRESS SPTAB-ENTRY\n         CLC   0(1,WORKX),0(ZARSPOR)    SCOPE OF ARRAY OK\n         BL    SUBFIN4                  NO, NO OPTIMIZATION\n         TM    FACTOR+2,X'30'           FACTOR CONSTANT\n         BZ    SUBFIN2                  YES\n         CLC   0(1,WORKX),FACTOR+3      SCOPE OF FACTOR OK\n         BL    SUBFIN4                  NO, NO OPTIMIZATION\nSUBFIN2  TM    ADDEND+2,X'30'           ADDEND CONSTANT\n         BZ    SUBFIN3                  YES\n         CLC   0(1,WORKX),ADDEND+3      SCOPE OF ADDEND OK\n         BL    SUBFIN4                  NO, NO OPTIMIZATION\nSUBFIN3  BAL   SUTABX,SUTABENT          MAKE SUTAB ENTRY\n         BR    SUBTSTX                  RETURN\n         SPACE\nSUBFIN4  SR    WORKR,WORKR\n         IC    WORKR,0(0,CVR)           FSN OF CONTROLLED VARIABEL\n         LA    WORKX,ZFOSTA(WORKR)      ADDRESS FSTAB-ENTRY\n         OI    0(WORKX),X'80'           ELEMENTARY LOOP\n         BR    SUBTSTX\n         SPACE 3\n*                   *****  OPERAND  *****\n         SPACE\n*              SUBROUTINE TO SUSCRITE TO CHECK WHAT FOLLOWS AN OPERATOR\n*              IF NOT AN INTEGER OPERAND AN ERROR-EXIT IS TAKEN. OTHER-\n*              WISE THE SETTING OF REGISTER OPPTR SHOWS TYPE OF OPERAND\n         SPACE\n*              INITILIZED REGISTER OPPTR\n         SPACE\nOPERAND  TM    1(SUBR),X'80'            OPERAND\n         BZ    SUBNOOP                  NO\n         TM    2(SUBR),X'CE'            INTEGER\n         BM    SUBNOOP                  NO\n         TM    1(SUBR),X'06'            CRITICAL IDENTIFIER\n         BO    OPERAND1                 YES\nOPERAND4 SR    OPPTR,OPPTR              INDICATE 'NO-CONTROLLED VARIAB.\n         BR    OPERANDX                 RETURN\n         SPACE\n*                                  IS OPERAND CONTROLLED VARIABEL\nOPERAND1 L     OPPTR,PFA                ADDRESS OF LAST CRIDTAB ENTRY\n         LA    OPPTR,9(0,OPPTR)         INITILIZE LOOP\nOPERAND2 SH    OPPTR,NINE               GET NEXT ENTRY\n         CLC   1(3,OPPTR),3(SUBR)       OPERAND FOUND\n         BNE   OPERAND2                 NO, GET NEXT CRIDTAB ENTRY\n         SPACE\nOPERAND3 TM    4(OPPTR),X'80'           CONTROLLED VARIABEL\n         BCR   1,OPERANDX               YES\n         TM    4(OPPTR),X'40'           PRECEEDING CRITICAL IDENTIFIER\n         BZ    OPERAND4                 NO\n         MVC   ALIGNH(2),5(OPPTR)       GET CRIDTAB CHAIN\n         L     OPPTR,ALIGN              GET ADDRESS OF CHAINED ENTRY\n         A     OPPTR,ZFOCRI\n         B     OPERAND3                 CHECK THIS ENTRY\n         SPACE 3\n*                   *****  SUBMULT  *****\n         SPACE\n*              SUBROUTINE TO SUSCRITE TO CHECK WHAT FOLLOWS AN ASTERISK\n*              IF NOT INTEGER FACTOR TIMES INTEGER CONTROLLED VARIABEL\n*              AN ERROR-EXIT IS TAKEN. OTHERWISE REGISTER CVR AND BUC-\n*              KET FACTOR ARE INITILIZED.\n         SPACE\n*              INITILIZED REG CVR\n         SPACE\nSUBMULT  MVC   FACTOR(6),0(SUBR)        MOVE OPERAND TO FACTOR\n         LR    CVR,OPPTR                SAVE PTR\n         LA    SUBR,6(0,SUBR)           ADDRESS NEXT OPERAND\n         BAL   OPERANDX,OPERAND         CHECK SECOND OPERAND\n         CR    OPPTR,CVR                WHICH OPERAND IS FACTOR\n         BH    SUBMULT2                 FIRST\n         BE    SUBNOOP                  NONE, NO OPTIMIZATION\n         MVC   FACTOR+1(5),1(SUBR)      SECOND, MOVE OPERAND TO FACTOR\nSUBMULT1 LTR   OPPTR,OPPTR              FACTOR CONTROLLED VARIABEL\n         BCR   8,SUBMULTX               NO, RETURN\n         SR    WORKR,WORKR         SET FOR-LOOP OF FACTOR ELEMENTARY\n         IC    WORKR,0(0,OPPTR)         FSN OF FACTOR\n         LA    WORKX,ZFOSTA(WORKR)      ADDRESS FSTAB-ENTRY\n         OI    0(WORKX),X'80'           MAKE LOOP ELEMENTARY\n         BR    SUBMULTX                 RETURN\nSUBMULT2 LR    WORKR,OPPTR              EXCHANGE REGISTERS\n         LR    OPPTR,CVR\n         LR    CVR,WORKR\n         B     SUBMULT1\n         SPACE 3\n*                    *****  SUTABENT  *****\n         SPACE\n*              SUBROUTINE TO SUBSCRITE TO MAKE AN SUTAB-ENTRY.\n         SPACE\nSUTABENT L     SUTR,ZSUTAPO             CURRENT SUTAB PTR\n         C     SUTR,ZSUDAD              HAS A WRITE MACRO BEEN GIVEN\n         BNE   SUTAB1                   NO\n         BAL   WORKR,CHECK              CHECK LAST OPERATION NO UT3\n         CLC   SULENGTH(4),SUTAB40S     TABLE OVERFLOW\n         BNL   SUTAB4                   YES\n         LH    WORKR,SUCNT              STEP RECORD COUNTER\n         LA    WORKR,1(0,WORKR)\n         STH   WORKR,SUCNT\nSUTAB1   LA    SUTR,14(0,SUTR)          ADDRESS NEW SUTAB-ENTRY\n         ST    SUTR,ZSUTAPO             SAVE SUTAB PTR\n*                                  MAKE SUTAB ENTRY\n         MVC   0(1,SUTR),0(CVR)         INSERT FSN\n         MVC   1(3,SUTR),0(ZARSPOR)     ADDRESS PART OF ARRAY\n         MVC   4(3,SUTR),FACTOR+3       ADDRESS PART OF FACTOR\n         MVC   7(3,SUTR),ADDEND+3       ADDRESS PART OF ADDEND\n         MVC   10(1,SUTR),ZPOSIX+1      SUBSCRIPT NUMBER\n         CLI   FACTOR,X'01'             SIGN OF FACTOR MINUS\n         BNE   SUTAB2                   NO\n         OI    10(SUTR),X'80'           YES, SET 1.BIT TO ONE\nSUTAB2   CLI   ADDEND,X'01'             SIGN OF ADDEND MINUS\n         BNE   SUTAB3                   NO\n         OI    10(SUTR),X'40'           YES, SET 2.BIT TO ONE\nSUTAB3   MVC   11(3,SUTR),4(ZARSPOR)    POSITION OF OPENING BRACKET\n         SPACE\n         C     SUTR,ZSUTMAX             SUTAB FILLED UP\n         BCR   4,SUTABX\n         BAL   WORKR,CHECK              CHECK POSSIBLE WRITE\n         L     WORKR,SUSTRT             WRITE START ADDRESS\n         L     WORKX,SUTAB30S           LENGTH OF WRITE\n         BAL   R15,WRITE                WRITE\n         L     WORKR,SULENGTH           GET FULL SUTAB LENGTH\n         A     WORKR,SUTAB30S\n         ST    WORKR,SULENGTH\n         MVC   ZSUTAPO(4),ZSUDAD        INITILIZE CURRENT SUTAB PTR\n         BR    SUTABX\n         SPACE\nSUTAB4   EQU   *\n         BAL   R15,TABOFLO              HANDLE TABLE OVERFLOW\n         BAL   MOVERROX,MOVERRO\n         B     SUBFIN4                  NO OPT, MAKE LOOP ELEMENTARY\n         SPACE 3\nOUCHA    EQU   *\n         STM   R14,R2,REGSAVE           SAVE REGISTERS\nLOUCHAF  B     LOUCHA7                  BRANCH ONLY IF FIRST RECORD\n         CHECK SWRITE\nLOUCHA6  CLC   ZARSPO(4),ZARNO          BUFFER EXCHANGE IN SUBSCR.EXPR.\n         BNE   LOUCHA1                  YES\nLOUCHA5  MVI   1(ZOUR),X'2F'                 ZETA TERMINATES O-BUFFER\n         L     ZOUR,ZOBWRITE\n         LR    WORKX,ZOUR\n         BCTR  ZOUR,0                   INITILIZE ZOUR\nLOUCHA4  L     WORKR,SRCE3S             OUTPUT BUFFER LENGTH\n         SH    WORKR,TWELVE             SET END PTRS\n         AR    WORKR,WORKX\n         ST    WORKR,ZFILE9\n         LA    WORKR,3(0,WORKR)\n         ST    WORKR,ZFILE6\n         LA    WORKR,1(0,WORKR)\n         ST    WORKR,ZFILE5\n         LA    WORKR,2(0,WORKR)\n         ST    WORKR,ZFILE3\n         LA    WORKR,1(0,WORKR)\n         ST    WORKR,ZFILE2\n         LA    WORKR,1(0,WORKR)\n         ST    WORKR,ZFILE1\n         MVC   ZOBWRITE(4),ZOBWORK     ZOBWRITE=ZOBWORK\n         ST    WORKX,ZOBWORK            STARTADDRESS OF NEW OUT-BUFFER\n         LH    WORKR,ZOUTCOT            OUTPUT RECORD COUNTER\n         CH    WORKR,TWOFIVFI           TOO MUCH SOURCE OUTPUT\n         BE    LOUCHA8                  YES\n         LA    WORKR,1(0,WORKR)\n         STH   WORKR,ZOUTCOT\n         L     WORKR,UT2ADD             DCB ADDRESS\n         L     WORKX,ZOBWRITE           AREA ADDRESS\n         WRITE SWRITE,SF,(WORKR),(WORKX)\n         LM    R14,R2,REGSAVE\n         BR    R15\nLOUCHA1  L     WORKR,ZBRACK        GET  CURRENT LENGTH OF SUBSCRIPT\n         LR    WORKX,ZOUR\n         SR    WORKX,WORKR              SUBSCRIPT LENGTH\n         BM    LOUCHA5                  NOTHING TO SAVE\n         CH    WORKX,EIGHTEEN           SUBSCRIPT ALREADY TOO LONG\n         BH    LOUCHA2                  YES\n         STC   WORKX,LOUCHAM+1          LENGTH OF SUBSCRIPT\n         STC   WORKX,LOUCHAL+3\n         L     WORKX,ZOBWRITE           STARTADDRESS OF NEW OUT-BUFFER\nLOUCHAM  MVC   0(1,WORKX),0(WORKR)      SAVE SUBSCRIPT\n         MVI   0(WORKR),X'2F'           REPLACE OPENING BRACKET BY ZETA\nLOUCHAL  LA    ZOUR,0(0,WORKX)          DISPLACEMENT LENGTH OF SUB\n         ST    WORKX,ZBRACK             ADDRESS OF OPENING BRACKET\n         CLI   0(WORKX),X'08'           IS SUBSCRIPT OPERATOR OPEN BRAC\n         BNE   LOUCHA4                  NO\n         L     WORKR,ZARSPO             YES, UPDATE ARIDSTAB-ENTRY\n         LH    WORKX,ZOUTCOT            OUTPUT-RECORD COUNTER\n         LA    WORKX,1(0,WORKX)         UPDATE\n         STC   WORKX,4(0,WORKR)         STORE RECORD COUNTER\n         MVC   5(2,WORKR),ZERO          SET RELATIVE ADDRESS TO ZERO\n         L     WORKX,ZOBWRITE           START ADDRESS OF NEW BUFFER\n         B     LOUCHA4\nLOUCHA2  BAL   SUCRIDX,SUCRIDEL\n         MVI   ZCLOBRA,X'FF'           ZCLOBRA IS SET TO X'FF'\n         L     WORKR,ZOBWRITE           START ADDRESS OF NEW BUFFER\n         BCTR  WORKR,0\n         ST    WORKR,ZBRACK\n         B     LOUCHA5                       BRANCH TO LOUCHA5\nLOUCHA7  MVI   LOUCHAF+1,X'00'          TURN OFF SWITCH\n         B     LOUCHA6\nLOUCHA8  MVC   ZERRONU(2),TOOLONG\n         MVC   ZBEGERR(4),ZENDERR\n         BAL   MOVERROX,MOVERRO\n         B     LOMEGA3\n         SPACE 3\n*                   *****  ICHA  *****\n         SPACE\n*              THE ROUTINE IS ENTERED WHEN OPERATOR ZETA (END OF INPUT-\n*              BUFFER) IS FOUND. IF NECESSARY A PART OF THE OLD BUFFER\n*              IS SAVED IMMEDIATLY BEFORE THE NEW BUFFER. START ADDRESS\n*              OF SAVED AREA IS STORED IN ZIBWORK\n         SPACE\n*              RETURN REG R15\n         SPACE\nICHA     EQU   *\n         STM   R14,R2,REGSAVE           SAVE REGISTERS\n         CHECK SREAD                    CHECK LAST READ\nICHA1    L     WORKR,UT1ADD             DCB ADDRESS\n         L     WORKX,ZIBRUN             AREA ADDRESS\n         READ  SREAD,SF,(WORKR),(WORKX)\n         LM    R14,R2,REGSAVE           RESTORE REGISTERS\n         L     ZINR,ZIBREAD             BEGIN OF ACTIVITED BUFFER\n         MVC   ZIBREAD(4),ZIBRUN        EXCHANGE POINTERS\n         ST    ZINR,ZIBRUN\n         BR    R15\nICHAI    STM   R14,R2,REGSAVE\n         B     ICHA1\n         SPACE 3\n*                   *****  ITABMOVE  ****\n         SPACE\n*              ITABMOVE IS ENTERD AT THE BEGINNING OF A NEW PROGRAM-\n*              BLOCK AND DURING INITIALIZATION. THE READ OF NEXT ITAB-\n*              RECORD IS ALREADY INITILIZED. IF A MOVE OF NEXT RECORD\n*              IS NECESSARY IT IS DONE BY THE SUBROUTINE ITABM. ALL\n*              CURRENT ITAB-POINTERS IS UPDATED\n         SPACE\n*              RETURN REG R15\n*              WORKREG ZITRECR, ZITABSTR\n*              SUBROUTINE ITABM, MOVERRO\n         SPACE\nZITRECR  EQU   R7\nZITABSTR EQU   R8\nITABMOP  MVI   LETTERB,X'00'            TURN OFF PROCEDURE SWITCH\nITABMOVE EQU   *\n         STM   R14,R2,REGSAVE\n         CLI   IOBYTE,READM             INITILIZED READ OPERATION\n         BNE   ITAB4                    NO\n         CHECK RITAB                    YES, CHECK\n         MVI   IOBYTE,READC             SET READ CHECK MASK\nITAB4    EQU   *\n         L     ZITRECR,ZITREC           ADDRESS OF BLOCKBEGIN\n         MVC   6(2,ZITRECR),ZCURITLE    ITAB REC LENGTH OF EMBR BLOCK\n         MVC   ZCURITLE(2),0(ZITRECR)   LENGTH OF BLOCK\n         SPACE\n         L     ZITABSTR,ZCURITEN   TEST IF A MOVE IS NECESSARY\n         LA    ZITABSTR,11(0,ZITABSTR)\n         CR    ZITABSTR,ZITRECR\n         BE    ITAB1                    NO MOVE\n         SPACE\n*                                  MOVE ITAB RECORD\n         LH    WORKX,ZCURITLE           LENGTH OF ITAB RECORD\n         EX    WORKX,ITABMEX            MOVE FIRST PART\n         LR    WORKR,WORKX\n         AR    ZITRECR,WORKR            END ADDRESS OF MOVED RECORD\n         AR    WORKR,ZITABSTR           END ADDRESS OR UNMOVED RECORD\n         SH    ZITRECR,C1792            PREPARE MOVE\n         SH    WORKR,C1792              PREPARE MOVE\n         SRA   WORKX,8                  PREPARE BRANCH\n         SLA   WORKX,2\n         B     *+4(WORKX)\n         B     ITABM8\n         B     ITABM7\n         B     ITABM6\n         B     ITABM5\n         B     ITABM4\n         B     ITABM3\n         B     ITABM2\n         MVC   0(256,WORKR),0(ZITRECR)\nITABM2   MVC   256(256,WORKR),256(ZITRECR)\nITABM3   MVC   512(256,WORKR),512(ZITRECR)\nITABM4   MVC   768(256,WORKR),768(ZITRECR)\nITABM5   MVC   1024(256,WORKR),1024(ZITRECR)\nITABM6   MVC   1280(256,WORKR),1280(ZITRECR)\nITABM7   MVC   1536(256,WORKR),1536(ZITRECR)\nITABM8   EQU   *\n         SPACE\nITAB1    LH    WORKR,ZCURITLE           GET ADDRESS OF LAST ITAB ENTRY\n         A     WORKR,ZCURITEN           ACTUELL RECORDLENGTH + PREV.ADD\n         ST    WORKR,ZCURITEN\n         LA    WORKR,11(0,WORKR)        ADDRESS OF FIRST FREE BYTE\n         ST    WORKR,ZITREC\n         CLC   10(1,ZITABSTR),PBN+1     LAST ITAB RECORD\n         BE    ITAB7                    YES\n         MVC   ALIGNH(2),2(ZITABSTR)    LENGTH OF NEXT BLOCK\n         A     WORKR,ALIGN              END ADDRESS OF NEXT BLOCK\n         C     WORKR,ZITEND             ITAB OVERFLOW\n         BH    ITAB10                   YES\n         CLI   IOBYTE,READC             WHICH I/O STATUS\n         BE    ITAB6                    CHECKED READ OPERATION\n         BL    ITAB5                    CHECKED WRITE OPERATION\n         CHECK TWRITE                   INITILIZED WRITE OPERATION\nITAB5    EQU   *\n         L     R1,UT3ADD                DCB ADDRESS\n         NOTE  (1)                      SAVE ID OF LAST BLOCK\n         ST    R1,NOTEW\n         L     R1,UT3ADD                DCB ADDRESS\n         MVI   NOTER+3,X'01'            ADDRESS NEXT ITAB BLOCK\n         POINT (1),NOTER\nITAB6    EQU   *\n         L     WORKR,UT3ADD             DCB ADDRESS\n         L     WORKX,ZITREC             READ START ADDRESS\n         READ  RITAB,SF,(WORKR),(WORKX),'S'\n         MVI   IOBYTE,READM             SET ITAB READ\nITAB7    EQU   *\n         LM    R14,R2,REGSAVE\n         MVC   CURPBN(1),10(ZITABSTR)   SAVE CURRENT PBN\n         BR    R15                      RETURN\nITAB10   ST    ZINR,ZBEGERR        ERROR EDIT\n         ST    ZINR,ZENDERR\n         MVC   ZERRONU(2),ITABOVER\n         BAL   MOVERROX,MOVERRO\n         B     LOMEGA3\nITABREAD EQU   *\n         STM   R14,R2,REGSAVE\n         LA    ZITABSTR,GENER           ADDRESS DUMMY HEADER\n         B     ITAB6\n         SPACE\nITABMEX  MVC   0(1,ZITABSTR),0(ZITRECR)\n         SPACE 3\n*              INVALID OPERAND FOUND. SET SYNTAX CHECK MODE AND GIVE\n*              ERRORMESSAGE.\nINCOROP  OI    HCOMPMOD,X'80'           SET SYNTAX CHECK MODE\n         LA    R0,ZIDEX+12\nINCOROP5 LR    RFI,ZINR\nINCOROP1 CLI   0(ZINR),X'2E'            END OF OPERAND\n         BL    INCOROP2                 YES\n         BE    INCOROP3                 STRING OR LOGICAL VALUE\n         CLI   0(ZINR),X'2F'            END OF INPUT BUFFER\n         BE    INCOROP4                 YES\n         LA    ZINR,1(0,ZINR)           PROCEED SCAN FOR OPERAND END\n         B     INCOROP1\n         SPACE\nINCOROP4 EQU   *\n         LR    R1,ZINR\n         BAL   MOVEX,MOVE\n         BAL   R15,ICHA\n         B     INCOROP5\nINCOROP2 EQU   *\n         LR    R1,ZINR\n         BAL   MOVEX,MOVE\n         ST    RTO,ZENDERR\n         MVC   ZBEGERR,OPSTART\n         BAL   MOVERROX,MOVERRO\n         LA    ZITANR,ZALLPU            REPLACE INCOR.ID. BY ALL PUB.ID\n         B     LETTER1\n         SPACE\nINCOROP3 MVC   0(6,ZINR),ZPOINT         REPLACE INT.NAME BY SIX PERIODS\n         LA    ZINR,6(0,ZINR)\n         B     INCOROP1\n         SPACE 2\n*                   *****  MOVERRO  *****\n         SPACE\n*              ERROR-EDITING ROUTINE. OUTPUTS ALWAYS FIXED PART CON-\n*              TAINING LENGTH OF ENTRY, ERROR NUMBER AND SEMICOLON\n*              COUNTER. SOMETMES VARIABEL PART WHOS STARTADDRESS IS\n*              STORED IN ZBEGERR AND (END ADDRESS + 1) IN ZENDERR.\n         SPACE\n*              RETURN REG MOVERROX\n         SPACE\nZERRPOR  EQU   WORKR\nZLER     EQU   WORKX\nMOVERROX EQU   R15\nMOVERRO  EQU   *\n         L     ZERRPOR,NEXTERR\n         C     ZERRPOR,ENDPOOL          ERROR POOL OVERFLOW\n         BH    MOVERRO2                 YES\n         L     ZLER,ZENDERR             GET LENGTH OF VARIABEL PART\n         S     ZLER,ZBEGERR\n         CH    ZLER,TWELVE              DOES LENGTH EXCEEDS MAXIMUM\n         BNH   MOVERRO1                 NO\n         LH    ZLER,TWELVE              YES, SET LENGTH TO MAX\nMOVERRO1 LA    ZLER,4(0,ZLER)           LENGTH OF FULL ERROR ENTRY\n         SPACE\n         AR    ZERRPOR,ZLER             GET ADDRESS OF NEXT ERROR ENTRY\n         ST    ZERRPOR,NEXTERR\n         SR    ZERRPOR,ZLER\n         SPACE\n         STC   ZLER,0(0,ZERRPOR)   FIXED PART OF ERROR ENTRY, LENGTH\n         MVC   1(1,ZERRPOR),ZERRONU+1   ERROR NUMBER\n         MVC   2(2,ZERRPOR),SEMCNT      SEMICOLON COUNTER\n         SPACE\n         SH    ZLER,FIVE                ANY VARIABEL PART\n         BM    MOVERRO3                 NO\n         STC   ZLER,MOVERROM+1          LENGTH OF MOVE\n         L     ZLER,ZBEGERR             START ADD OF ADDITIONAL PART\nMOVERROM MVC   4(1,ZERRPOR),0(ZLER)     MOVE ADDITIONAL PART\nMOVERRO3 BR    MOVERROX\nMOVERRO2 EQU   *\n         MVI   0(ZERRPOR),X'04'         TERMINATING ERROR ENTRY\n         MVI   1(ZERRPOR),TOOMANY\n         MVC   2(2,ZERRPOR),SEMCNT\n         LA    ZERRPOR,4(0,ZERRPOR)\n         ST    ZERRPOR,NEXTERR\n         B     LOMEGA3\n         SPACE 3\nMOVEX    EQU   R15\nRTO      EQU   R8\nRFI      EQU   R9\n         SPACE\nMOVEP    EQU   *\n         LR    WORKR,ZINR               FIELD OF ONE BYTE\n         SR    WORKR,RFI\n         BC    7,MOVE\n         LTR   REXCORR,REXCORR          POINT FOLLOWED BY ZERO\n         BCR   4,MOVEX                  YES, NO SYNTAX ERROR\n         LA    WORKR,NUMBER(REXCORR)    ADDRESS IMPLIED POINT\n         CR    WORKR,RTO                POINT TERMINATE NUMBER\n         BE    QTORLT1                  YES\n         SPACE\nMOVE     EQU   *\n         SR    R1,RFI                   LENGTH OF MOVE\n         LR    WORKR,RTO                CALCULATE END ADDRESS\n         AR    WORKR,R1\n         CR    WORKR,R0                 FULL MOVE POSSIBLE\n         BH    MOVE1                    NO\n         EX    R1,MOVEEX                MOVE\n         LR    RTO,WORKR                STEP PTR\n         BR    MOVEX\n         SPACE\nMOVE1    LR    WORKR,R0                 CALCULATE LENGTH OF POSSI .MOVE\n         SR    WORKR,RTO\n         EX    WORKR,MOVEEX\n         LR    RTO,R0\n         BR    MOVEX\n         SPACE\nMOVEEX   MVC   0(0,RTO),0(RFI)\n         SPACE 3\nCHECK    EQU   *\n         CLI   IOBYTE,WRITEM            INITILIZED WRITE OPERATION\n         BCR   7,WORKR                  NO, RETURN\n         STM   R14,R2,REGSAVE\n         CHECK TWRITE                   CHECK LAST WRITE\n         MVI   IOBYTE,WRITEC            SET WRITE CHECK MASK\n         LM    R14,R2,REGSAVE\n         BR    WORKR\n         SPACE 3\nWRITE    EQU   *\n         STM   R14,R2,REGSAVE\n         CLI   IOBYTE,READC             WHICH I/O STATUS\n         BL    WRITE2                   CHECKED WRITE OPERATION\n         BE    WRITE1                   CHECKED READ OPERATION\n         CHECK RITAB                    INITILIZED READ OPERATION\nWRITE1   EQU   *\n         L     R1,UT3ADD                DCB ADDRESS\n         NOTE  (1)                      SAVE ID OF LAST BLOCK\n         ST    R1,NOTER\n         L     R1,UT3ADD                DCB ADDRESS\n         MVI   NOTEW+3,X'01'            ADDRESS NEXT OUTPUT BLOCK\n         POINT (1),NOTEW\nWRITE2   EQU   *\n         L     R0,UT3ADD                DCB ADDRESS\n         LA    WORKX,4(0,WORKX)         ADD KEY-LENGTH\n         WRITE TWRITE,SF,(R0),(WORKR),(WORKX)\n         MVI   IOBYTE,WRITEM            SET WRITE MASK\n         LM    R14,R2,REGSAVE\n         BR    R15\n         SPACE\nTABOFLO  EQU   *\n         L     WORKR,PFA                ADDRESS OF LAST CRIDTAB ENTRY\nTABOFLO1 SR    WORKX,WORKX\n         IC    WORKX,0(0,WORKR)         FOR STATEMENT NUMBER\n         LA    WORKX,FSTAB(WORKX)       ADDRESS FOR STATEMENT ENTRY\n         OI    0(WORKX),NOSUOP\n         SH    WORKR,NINE\n         C     WORKR,PFANO              END OF CRIDTAB\n         BNH   TABOFLO1                 NO\n         SPACE\n         MVI   ZLVOV,X'FF'              SET ERROR SWITCH\n         MVC   ZARSPO(4),ZARNO          SKIP ALL ARIDSTAB-ENTRIES\n         ST    ZINR,ZBEGERR             ERROR EDITING\n         ST    ZINR,ZENDERR\n         MVC   ZERRONU(2),TABOVER\n         BR    R15\n         EJECT\nIEX30002 CSECT\nRET      EQU   R14\nREXCORR  EQU   R7\n         SPACE\nDIGIT19  EQU   *\n         LA    RTO,NUMBER\n         LA    R0,NUMBER+19             MAX LENGTH OF CONSTANT + 1\n         SR    REXCORR,REXCORR\n         LR    RFI,ZINR                 SET FIELD START\n         MVI   SCATEST,X'00'\nDIG191   LA    R1,1(0,ZINR)             TRT START\nDIG192   SR    R2,R2\nDIG193   TRT   0(256,R1),DIG19\n         BZ    DIGL19                   MORE THAN 256 BYTES\n         LR    ZINR,R1                  UPDATE ZINR\n         B     *(R2)                    BRANCH TABLE\n         B     DECPTM\n         B     SCAFACTM\n         B     QTORLT\n         B     ZETAM\n         B     RHO\n         B     OTHER\n         SPACE\nDECPTM   EQU   *\n         BAL   MOVEX,MOVE\n         AR    REXCORR,R1               EXPONENT CORRECTION\n         B     DECPOIN1\n         SPACE\nSCAFACTM BAL   MOVEX,MOVE\n         AR    REXCORR,R1               EXPONENT CORRECTION\n         B     SCA1\n         SPACE\nQTORLT   EQU   *\n         BAL   MOVEX,MOVE\n         AR    REXCORR,R1               NUMBER OF INTEGERS\nQTORLT1  ST    REXCORR,ZEXCORR\n         BAL   CERRX,CERR               REBUILD CONSTANT\n         MVC   ZERRONU(2),INVOP\n         B     INCOROP\n         SPACE\nZETAM    EQU   *\n         BAL   MOVEX,MOVE\n         AR    REXCORR,R1               EXPONENT CORRECTION\n         BAL   R15,ICHA\n         LR    R1,ZINR\n         LR    RFI,ZINR\n         B     DIG192\n         SPACE\nOTHER    EQU   *\n         C     RTO,NSTART               BUFFER EXCHANGE WITHIN INTEGER\n         BNE   OTHER1                   YES\n         LR    REXCORR,ZINR             COMPUTE NUMBER OF DIGITS\n         SR    REXCORR,RFI\n         B     INTCON\nOTHER1   BAL   MOVEX,MOVE\n         AR    REXCORR,R1               GET NUMBER OF DIGITS\n         LR    R1,RTO                   ADJUST POINTERS\n         LA    RFI,NUMBER\n         B     INTCON\n         SPACE\nDIGL19   LA    R1,256(0,R1)             UPDATE INPUT PTR\n         B     DIG193\n         SPACE\nDIGIT0   EQU   *\n         LA    RTO,NUMBER\n         LA    R0,NUMBER+19             MAX LENGTH OF CONSTANT + 1\n         SR    REXCORR,REXCORR\n         MVI   SCATEST,X'00'\n         LA    R1,1(0,ZINR)\nDIG01    SR    R2,R2\nDIG02    TRT   0(256,R1),DIG0\n         BZ    DIGL0                    MORE THAN 256 BYTES\n         LR    ZINR,R1\n         LR    RFI,ZINR\n         B     *(R2)\n         B     DIG191\n         B     QTORLT\n         B     DECPOIN1\n         B     SCA0\n         B     ZETA0\n         B     RHO\n         B     OTHOP0\n         SPACE\nSCA0     EQU   *\n         LD    XFLOAT,ZEROFLOA          FLOATING ZERO\n         B     SCA1\n         SPACE\nZETA0    EQU   *\n         BAL   R15,ICHA                 CHANGE INPUT BUFFER\n         LR    R1,ZINR\n         B     DIG01\n         SPACE\nOTHOP0   EQU   *\n         C     ZOUR,ZFILE5              OUTPUT BUFFER FULL\n         BNH   *+8                      NO\n         BAL   R15,OUCHA                YES\n         MVC   3(3,ZOUR),ZERO           ADDRESSPART OF INTERNAL NAME\n         MVC   1(2,ZOUR),ZINTYP         INDICATE INTEGER\n         LA    ZOUR,5(0,ZOUR)\n         B     GENTEST\n         SPACE\nDIGL0    LA    R1,256(0,R1)             UPDATE INPUT PTR\n         B     DIG02\n         SPACE\nDECPOIN  EQU   *\n         LA    RTO,NUMBER\n         LA    R0,NUMBER+19             MAX LENGTH OF CONSTANT + 1\n         SR    REXCORR,REXCORR\n         MVI   SCATEST,X'00'\nDECPOIN1 LA    RFI,1(0,ZINR)\nDECPOIN2 LA    R1,1(0,ZINR)\nDECPOIN3 SR    R2,R2\nDECPOIN4 TRT   0(256,R1),DECPO\n         BZ    DECPOINL                 MORE THAN 256 BYTES\n         LR    ZINR,R1\n         B     *(R2)\n         B     DECP0                    ZERO\n         B     QTORLTP\n         B     DECPSCA                  SCALE FACTOR\n         B     DECPZETA                 ZETA\n         B     DECPOT                   OTHER OPERATOR\n         SPACE\nDECP0    EQU   *\n         CR    RFI,ZINR                 ZERO FOLLOWING POINT\n         BNE   DECPOIN2                 NO\n         C     RTO,NSTART               PRECEEDING SIGNIFICANT DIGIT\n         BNE   DECPOIN2                 YES\n         BCTR  REXCORR,0                NO, DECREASE EXPONENT\n         B     DECPOIN1\n         SPACE\nQTORLTP  BAL   MOVEX,MOVE\n         B     QTORLT1\n         SPACE\nDECPSCA  EQU   *\n         BAL   MOVEX,MOVEP              SYNTAX CHECK AND MOVE\n         C     RTO,NSTART               ZERO\n         BNE   SCA1                     NO\n         LD    XFLOAT,ZEROFLOA          YES, FLOATING ZERO\n         B     SCA1\n         SPACE\nDECPZETA EQU   *\n         BAL   MOVEX,MOVE\n         BAL   R15,ICHA\n         LR    RFI,ZINR\n         LR    R1,ZINR\n         B     DECPOIN3\n         SPACE\nDECPOT   EQU   *\n         ST    REXCORR,ZEXCORR\n         BAL   MOVEX,MOVEP              SYNTAX CHECK AND MOVE\n         C     RTO,NSTART               ZERO\n         BNE   REALCON                  NO, CONVERT NUMBER\n         LD    XFLOAT,ZEROFLOA          YES, NUMBER IS FLOATING ZERO\n         B     REALHAN                  MAKE A CONSTANT POOL ENTRY\n         SPACE\nDECPOINL LA    R1,256(0,R1)             UPDATE INPUT PTR\n         B     DECPOIN4\n         SPACE\nSCAFACT  EQU   *\n         SR    REXCORR,REXCORR\n         LD    XFLOAT,ZONEFLOA          MANTISSA SET TO ONE\n         LA    RTO,NUMBER               NO MANTISSA DIGIT\nSCA1     ST    RTO,ZTO\n         ST    REXCORR,ZEXCORR\n         LA    RTO,SCAWORK\n         LA    R0,SCAWORK+9\n         MVI   SCATEST,X'10'            SCALE FACTOR PRESENT\n         MVI   SCALE,X'00'              CLEAR OLD SIGN\nSCA20    LA    RFI,1(0,ZINR)\nSCA2     LA    R1,1(0,ZINR)\nSCA3     SR    R2,R2\nSCA4     TRT   0(256,R1),SCAFAC\n         BZ    SCAL                     MORE THAN 256 BYTES\n         LR    ZINR,R1\n         B     *(R2)\n         B     SCA19\n         B     SCAZERO\n         B     SCASIGN\n         B     SCAQL\n         B     SCAZETA\n         B     SCAOT\n         SPACE\nSCA19    EQU   *\n         OI    SCATEST,SF19             SIGNIFICANT DIGIT PRESENT\n         B     SCA2\n         SPACE\nSCAZERO  EQU   *\n         TM    SCATEST,SF19             ANY SIGNIFICANT DIGIT\n         BO    SCA2                     YES\n         OI    SCATEST,SFL0             LEADING ZERO\n         B     SCA20\n         SPACE\nSCASIGN  EQU   *\n         TM    SCATEST,SFLSIGN          LEADING SIGN\n         BC    7,SCAOT                  NO,TREAT AS OTHER OPERATOR\n         MVC   SCALE(1),0(ZINR)         SAVE SIGN\n         OI    SCATEST,SFSIGN           SIGNED SCALE FACTOR\n         B     SCA20\n         SPACE\nSCAZETA  EQU   *\n         BAL   MOVEX,MOVE               SAVE FIELD\n         BAL   R15,ICHA\n         LR    R1,ZINR\n         LR    RFI,ZINR\n         B     SCA3\n         SPACE\nSCAOT    EQU   *\n         TM    SCATEST,SFDIGIT          ANY DIGIT\n         BZ    SCAQL                    NO, ERROR MESSAGE\n         TM    SCATEST,SF19             ANY SIGNIFICANT DIGIT\n         BZ    SCAOT1                   NO\n         BAL   MOVEX,MOVE\n         S     RTO,SCAWORKA\n         EX    RTO,SCAPACK\n         MVN   ZPACK+7(1),SREF          SET SIGN TO PLUS\n         CLI   SCALE,X'01'              MUNUS SIGN\n         BNE   *+10                     NO\n         MVN   ZPACK+7(1),SREF+1        YES, REPLACE PLUS SIGN\n         CVB   WORKR,ZPACK              CONVERT\n         AR    REXCORR,WORKR            GET EXPONENT\n         SPACE\nSCAOT1   ST    RTO,ZTOSCA\n         L     RTO,ZTO\n         B     REALCON\nSCAPACK  PACK  ZPACK(8),SCAWORK(0)\n         SPACE\nSCAQL    EQU   *\n         BAL   MOVEX,MOVE\n         S     RTO,SCAWORKA             SCALE FACTOR LENGTH\n         ST    RTO,ZTOSCA\n         L     RTO,ZTO\n         BAL   CERRX,CERR               REBUILD CONSTANT\n         MVC   ZERRONU(2),INVOP\n         B     INCOROP\n         SPACE\nSCAL     LA    R1,256(0,R1)             UPDATE INPUT PTR\n         B     SCA4\n         SPACE 3\nCERRX    EQU   R2\n         SPACE\nCERR     EQU   *                   CONSTANT ERROR ROUTINE\n         TM    SCATEST,PRECERR          CONSTANT ALREADY REBUILT\n         BCR   1,CERRX                  YES\n         L     WORKR,ZEXCORR            NUMBER OF INTEGERS IN MANTISSA\n         LTR   WORKR,WORKR              LEADING ZEROS AFTER POINT\n         BM    CERR1                    YES\n         CH    WORKR,TWELVE             CONSTANT TOO LONG\n         BNH   *+8                      NO\n         LH    WORKR,TWELVE             SET MAXIMAL LENGTH\n         EX    WORKR,CERREX             MOVE CONSTANT INTEGERS\n         A     WORKR,OPSTART            ADDRESS DECIMAL POINT\n         MVI   0(WORKR),X'3E'           INSERT POINT\n         BCTR  RTO,0\n         CR    RTO,WORKR                ANY DECIMAL POINT\n         BE    *+8                      NO\n         LA    RTO,1(0,RTO)             PREVENT POINT OVERLAY\n         B     CERR2\n         SPACE\nCERR1    MVI   ZIDEX,X'3E'              INSERT POINT\nCERR2    EQU   *\n         TM    SCATEST,SF               SCALE FACTOR PRESENT\n         BZ    CERR3                    NO\n         LA    R0,NUMBER+21\n         MVC   0(2,RTO),SCALEQ          INSERT QUOTE AND SIGN\n         TM    SCATEST,SFSIGN           SIGNED SCALE FACTOR\n         BO    *+6                      YES\n         BCTR  RTO,0\n         LA    RTO,2(0,RTO)\n         L     R1,ZTOSCA\n         LA    R1,1(0,R1)          SCALE FACTOR LENGTH\n         LA    RFI,SCAWORK\n         AR    R1,RFI                   SCALE FACTOR END ADDRESS\n         BAL   MOVEX,MOVE               MOVE SCALE FACTOR\n         SPACE\nCERR3    LA    WORKR,ZIDEX+12\n         CR    RTO,WORKR                MORE THAN 12 CHARACTERS\n         BNH   *+6                      NO\n         LR    RTO,WORKR                YES SET LENGTH TO 12\n         ST    RTO,ZENDERR\n         MVC   ZBEGERR(4),OPSTART\n         BR    CERRX\nCERREX   MVC   ZIDEX(0),NUMBER\n         EJECT\nRLIT     EQU   R1\nRBIN     EQU   R2\nRCNT     EQU   R9\nREXNU    EQU   R9\nREXNX    EQU   R1\nREXTAB   EQU   R2\nXFLOAT   EQU   0\n         SPACE\nINTCON   EQU   *\n         CH    REXCORR,TEN              NUMBER OF DIGITS\n         BL    INTCON1                  NO\n         BH    INTCON2                  YES, REAL CONSTANT\n         CLC   0(10,RFI),MAXNR          MAXIMAL INTEGER\n         BH    INTCON2                  GREATER, REAL CONSTANT\nINTCON1  BCTR  REXCORR,0\n         EX    REXCORR,INTPACK          PACK\n         MVN   ZPACK+7(1),SREF          SET PLUS SIGN\n         CVB   RBIN,ZPACK               PACK\n         B     INTHAN\nINTCON2  ST    RFI,ZBEGERR              GIVE ERROR MESSAGE\n         ST    R1,ZENDERR\n         MVC   ZERRONU(2),RANGEINT\n         BAL   MOVERROX,MOVERRO\n         ST    REXCORR,ZEXCORR\n         L     RTO,NSTART\n         BAL   MOVEX,MOVE\n         B     REALCON\nINTPACK  PACK  ZPACK(8),0(0,RFI)        LENGTH IN R1\n         EJECT\nREALCON  EQU   *\n         LR    WORKX,RTO                GET LENGTH OF CONSTANT\n         S     WORKX,NSTART\n         BZ    REALCON7\n         SPACE\n*              CONVERT MANTISSA TO FLOATING FORM\n         LD    XFLOAT,ZEROFLOA          ZEROIZE REGISTER\n         LR    RCNT,WORKX               NUMBER OF DIGITS\n         SR    REXCORR,RCNT             UPDATE EXPONENT CORRECTION\n         CH    RCNT,NINE                CONVERSION IN ONE STEP\n         BH    REALCON1                 NO\n         BCTR  RCNT,0\n         EX    RCNT,REPACK              PACK\nREALCON2 MVN   ZPACK+7(1),SREF          SET PLUS SIGN\n         CVB   WORKR,ZPACK              CONVERT TO BINARY\n         ST    WORKR,ZFLOFIEL+4         CONVERT TO FLOATING FORM\n         AD    XFLOAT,ZFLOFIEL           GET NORMALIZED FLOATING NUMBER\n         SPACE\n         C     WORKX,NREAL              MORE DIGITS THAN ALLOWED\n         BNH   REALCON3                 NO\n         BAL   CERRX,CERR               REBUILD CONSTANT\n         MVC   ZERRONU(2),PRECREAL\n         BAL   MOVERROX,MOVERRO\n         OI    SCATEST,PRECERR          INDICATE PRECITION ERROR\n         B     REALCON3\n         SPACE\n*              CONVERT EXPONENT TO FLOATING FORM\nREALCON7 EQU   *\n         LTDR  XFLOAT,XFLOAT            FLOATING ZERO\n         BZ    REALHAN                  YES\nREALCON3 LPR   REXNU,REXCORR            ZERO EXPONENT\n         BZ    REALHAN                  YES\n         LR    REXNX,REXNU\n         LA    REXTAB,ZEXTABP-8         TABLE FOR POSITIVE EXPONENT\n         LTR   REXCORR,REXCORR          POSITIVE EXPONENT\n         BP    *+8                      YES\n         LA    REXTAB,ZEXTABN-8         N/, TABLE FOR NEGATIVE EXPONENT\nREALCON6 CH    REXNU,SIXFOUR            EXPONENT MORE THAN 64\n         BNL   REALCON5                 YES\n         N     REXNU,SCALEMSK           NO, X'38'\n         BZ    REALCON8\n         MD    XFLOAT,56(REXNU,REXTAB)\nREALCON8 EQU   *\n         SLA   REXNX,3                  MULTIPLY BY 8\n         N     REXNX,SCALEMSK\n         BZ    REALCON9\n         MD    XFLOAT,0(REXNX,REXTAB)\nREALCON9 EQU   *\n         LTDR  XFLOAT,XFLOAT            EXPONENT UNDERFLOW\n         BZ    REALERR1\n         B     REALHAN\nREALCON5 MD    XFLOAT,120(0,REXTAB)     10 ** +- 64\n         LTDR  XFLOAT,XFLOAT\n         BZ    REALERR1\n         SH    REXNU,SIXFOUR            ADJUST EXPONENT\n         B     REALCON6\nREALCON1 SH    RCNT,TEN\n         CH    RCNT,NINE                CONSTANT TOO LONG\n         BL    *+10                     NO\n         BCTR  RCNT,0                   YES, SKIP THE NINETEENTH DIGIT\n         AH    REXCORR,ONE              UPDATE REXCORR\n         EX    RCNT,REPACK              PACK FIRST PART\n         MVN   ZPACK+7(1),SREF          SET PLUS SIGN\n         CVB   WORKR,ZPACK              CONVERT TO BINARY\n         ST    WORKR,ZFLOFIEL+4         CONVERT TO FLOATING FORM\n         AD    XFLOAT,ZFLOFIEL          NORMALIZE\n         MD    XFLOAT,ZTEN9             MULTIPLY BY 10 ** 9\n         LA    RCNT,NUMBER+1(RCNT)      ADDRESS SECOND PART\n         PACK  ZPACK(8),0(9,RCNT)       PACK SECOND PART\n         B      REALCON2                TERMINATE CONVERSION\nREPACK   PACK  ZPACK(8),NUMBER(0)       LENGTH OF NUMBER IN RCNT\n         SPACE\nREALERR  EQU   *\n         LA    WORKR,REALHAN            SET EXIT ADDRESS\n         ST    WORKR,ZSTO\n         MVC   9(3,R1),ZSTO+1           MODIFIE OLD PSW IN PIE\n         BAL   CERRX,CERR               REBUILD CONSTANT\n         MVC   ZERRONU(2),RANGEREA\n         BAL   MOVERROX,MOVERRO\n         OI    HCOMPMOD,X'80'\n         BR    R14\nREALERR1 BAL   CERRX,CERR               REBUILD CONSTANT\n         MVC   ZERRONU(2),RANGEREA\n         BAL   MOVERROX,MOVERRO\n         OI    HCOMPMOD,SYNTAX\n         B     REALHAN\n         EJECT\nRWP      EQU   R9                       CANNOT BE CHANGED\nRDWP     EQU   R7                       CANNOT BE CHANGED\nRINTL    EQU   R14\nREALL    EQU   R14\n         SPACE\nINTHAN   EQU   *                   INTEGER HANDLING\n         C     ZOUR,ZFILE5              SPACE ENOUGH IN OUTPUT BUFFER\n         BNH   *+8                      YES\n         BAL   R15,OUCHA                NO, CHANGE BUFFER\n         MVC   1(2,ZOUR),ZINTYP         FIRST TWO BYTES OF INTERNAL NAM\nINTHANR  EQU   *\n         CH    RBIN,FIFTEEN             IS NUMBER GREATER THAN 15\n         BH    INTHAN2                  YES\n         SLA   RBIN,2                   NO, MULTIPLY BY 4\n         STH   RBIN,ZLIRE\n         MVI   3(ZOUR),X'00'                    OUTPUT\n         MVC   4(2,ZOUR),ZLIRE                         FIELD\n         LA    ZOUR,5(0,ZOUR)           UPDATE OUTPUT POINTER\n         B     GENTEST                  RETURN\nINTHAN2  EQU   *\n         TM    HCOMPMOD,SYNTAX          COMPILE MODE\n         BO    INTHAN1                  NO\n         LA    RINTL,INTHAN6       INITILIZE INTEGER SEARCH\n         LA    R8,4\n         L     RWP,ZWP\n         L     RDWP,ZDWP\n         L     RLIT,ZLITSTA\n         SR    RLIT,R8\n         SR    RWP,R8\nINTHAN6  BXH   RLIT,R8,INTHAN3          EXIT FOR END OF SEARCH\n         C     RBIN,0(0,RLIT)           INTEGER FOUND\n         BCR   7,RINTL                  NO, PROCEED SEARCH\n         SPACE\nREALH1   EQU   *\nINTHAN1  EQU   *\n         S     RLIT,ZKOPOOL             GET REL ADDRESS\n         STH   RLIT,ZLIRE                               IN CONST POOL\n         MVC   3(1,ZOUR),KBN+1          INSERT CONSTANT BLOCK NUMBER\n         MVC   4(2,ZOUR),ZLIRE          DISPLACEMENT ADDRESS\n         LA    ZOUR,5(0,ZOUR)\n         B     GENTEST\n         SPACE\nINTHAN3  EQU   *\n         AR    RWP,R8\n         CR    RWP,RDWP                 DOUBLE WORD BOUNDARY\n         BE    INTHAN9                  YES\n         SPACE\nINTHAN4  LA    RLIT,4(0,RLIT)           SCAN REST OF CONSTANT POOL\n         CR    RLIT,RDWP                CURRENT END OF CONSTANT POOL\n         BE    INTHAN10                 YES\n         C     RBIN,0(0,RLIT)           LITERAL FOUND\n         BNE   INTHAN4                  NO\n         BE    INTHAN1\n         SPACE\nINTHAN10 LR    RLIT,RWP\n         LR    RWP,RDWP\nINTHAN7  ST    RWP,ZWP                  SAVE PTR\n         ST    RBIN,0(0,RLIT)           MAKE LITERAL POOL ENTRY\n         B     INTHAN1\nINTHAN9  C     RWP,ZKOPEND              END OF LITERAL POOL\n         BNL   INTHAN8\n         C     RWP,ZTEXTCO              WRITE TXT-CARD\n         BL    INTHAN5                  NO\n         BAL   R14,TXTTRAF              WRITE\nINTHAN5  LA    RWP,4(0,RWP)             UPDATE POINTERS\n         A     RDWP,LREAL\n         ST    RDWP,ZDWP                SAVE UPDATE ZDWP\n         B     INTHAN7\n         SPACE\nINTHAN8  CLC   ZKBNMAX(2),TWOFIVFI      LAST CONST POOL\n         BE    INTHAN11                 YES, GIVE ERROR MESSAGE\n         L     RWP,ZDWP                                            1511\n         BAL   R14,TXTTRAF              OUTPUT TXT-RECORD\n         BAL   R14,CPOLEX               CONSTANT POOL EXCHANGE\n         L     RLIT,ZKOPOOL             START ADDRESS OF CONSTANT POOL\n         LA    RWP,4(0,RLIT)            UPDATE POINTERS\n         LR    RDWP,RLIT\n         A     RDWP,LREAL\n         ST    RWP,ZWP\n         ST    RDWP,ZDWP\n         ST    RLIT,ZLITSTA\n         ST    RBIN,0(0,RLIT)\n         B     INTHAN1\n         SPACE\nINTHAN11 ST    R1,ZBEGERR               GIVE\n         ST    R1,ZENDERR                    ERROR\n         MVC   ZERRONU(2),MANYCON\n         BAL   R15,MOVERRO              GO TO ERROR RTN\n         OI    HCOMPMOD,X'80'           SET SYNTAX CHECK BIT\n         B     INTHAN1\n         EJECT\nREALHAN  EQU   *\n         C     ZOUR,ZFILE5              SPACE ENOUGH IN OUTPUT BUFFER\n         BNH   *+8                      YES\n         BAL   R15,OUCHA                NO, CHANGE BUFFER\n         MVC   1(2,ZOUR),ZREALTYP       FIRST TWO BYTES OF INTERNAL NAM\n         CLI   ZFORTEST,X'00'           IN FOR LIST\n         BE    REALHAN1                 NO\n         L     WORKR,ZFSPTR             ADDRESS FSTAB ENTRY\n         OI    0(WORKR),NOCOUNT         CLASSIFY AS NO COUNTING LOOP\nREALHAN1 EQU   *\n         TM    HCOMPMOD,X'02'           WHICH PRESITION\n         BO    REALH                    LONG\n         STE   XFLOAT,ZSTO              START ROUNDING\n         MVC   ROUND(1),ZSTO\n         AD    XFLOAT,ROUND             ROUND\n         STE   XFLOAT,ZSTO              SHORT, TREAT AS INTEGER\n         L     RBIN,ZSTO\n         B     INTHANR\n         SPACE\nREALH    EQU   *\n         L     RLIT,ZLITSTA             INITILIZE LITERAL SEARCH\n         TM    HCOMPMOD,SYNTAX          COMPILE MODE\n         BO    REALH1                   YES\n         LA    R6,8\n         LR    R8,R6\n         SR    RLIT,R6\n         L     RWP,ZWP\n         L     RDWP,ZDWP\n         CR    RWP,RDWP\n         BE    REALH2\n         SR    RDWP,R6\n         LA    REALL,REALH3\nREALH3   BXH   RLIT,R8,REALH4           EXIT AT END OF SEARCH\n         CD    XFLOAT,0(0,RLIT)         LITERAL FOUND\n         BCR   7,REALL                  NO\n         SPACE\nREALH4   LA    REALL,REALH5\n         SR    RLIT,R6\nREALH5   BXH   RLIT,R6,REALH6           EXIT AT END OF SCAN\n         CD    XFLOAT,0(0,RLIT)         CONSTANT FOUND\n         BCR   7,REALL                  NO\n         B     REALH1                   YES\n         SPACE\nREALH6   AR    RDWP,R6\n         C     RDWP,ZKOPEND             END OF LITERAL POOL\n         BNL   REALH10                  YES\nREALH8   AR    RDWP,R6                  UPDATE ZDWP\n         ST    RDWP,ZDWP\n         STD   XFLOAT,0(0,RLIT)\n         B     REALH1\n         SPACE\nREALH7   BAL   RET,TXTTRAF              OUTPUT TXT\nREALH9   AR    R8,RDWP                  UPDATE ZWP\n         ST    R8,ZWP\n         B     REALH8\n         SPACE\nREALH2   LA    REALL,REALH21\n         SR    RDWP,R6\nREALH21  BXH   RLIT,R6,REALH22          EXIT AT END OF SCAN\n         CD    XFLOAT,0(0,RLIT)         LITERAL FOUND\n         BCR   7,REALL                  NO\n         B     REALH1                   YES\n         SPACE\nREALH22  AR    RDWP,R6\n         C     RDWP,ZKOPEND             END OF LITERAL POOL\n         BNL   REALH10\n         C     RDWP,ZTEXTCO             TXT TO BE PUT OUT\n         BL    REALH9                   NO\n         B     REALH7                   YES\n         SPACE\nREALH10  CLC   ZKBNMAX(2),TWOFIVFI      LAST CONSTANT POOL\n         BE    REALH11                  YES\n         L     RWP,ZDWP                                            1511\n         BAL   RET,TXTTRAF              OUTPUT TXT\n         BAL   RET,CPOLEX               CONSTANT POOL EXCHANGE\n         L     RLIT,ZKOPOOL             START ADDRESS OF CONSTANT POOL\n         LA    RDWP,8(0,RLIT)           UPDATE PTRS\n         ST    RDWP,ZDWP\n         ST    RDWP,ZWP\n         ST    RLIT,ZLITSTA\n         STD   XFLOAT,0(0,RLIT)         LITERAL ENTRY\n         B     REALH1\n         SPACE\nREALH11  ST    ZINR,ZBEGERR             TOO MANY LITERALS, MESSAGE\n         ST    ZINR,ZENDERR\n         MVC   ZERRONU(2),MANYCON\n         BAL   MOVERROX,MOVERRO\n         OI    HCOMPMOD,X'80'           SYNTAX CHECK MODE\n         B     REALH1\n         EJECT\nCPOLEX   EQU   *                   CONSTANT POOL EXCHANGE\n         L     R15,ZKOPOOL              UPDATE\n         ST    R15,ZLITSTA\n         AH    R15,TXTPUT\n         ST    R15,ZTEXTCO                     TXT-RECORD POINTER\n         LH    R15,ZKBNMAX\n         LA    R15,1(0,R15)\n         STH   R15,ZKBNMAX                     CONSTANT POOL\n         STH   R15,KBN                            NUMBER\n         BR    R14                      RETURN\n         SPACE\nTXTTRAF  EQU   *                   TRANSFER TXT-RECORD\n         STM   14,6,TXTSAV              SAVE REGISTERS\n         L     INFORM,ZTEXTCO\n         SH    INFORM,TXTPUT            ADDRESS OUTPUT TXT\n         LR    WORKR,RWP                CALCULATE LENGTH OF TXT\n         SR    WORKR,INFORM\n         STH   WORKR,TXTLE\n         LR    WORKR,RWP                GET NEW PUT ADDRESS\n         AH    WORKR,TXTPUT\n         ST    WORKR,ZTEXTCO\n         L     PRPOINT,PRPT             LOAD PROGRAM PTR\n         TM    HCOMPMOD+1,X'60'         NOLOAD AND NODECK\n         BO    TXTLE2                   YES\n         BAL   LENGTH,GENTXT            OUTPUT OF TEXT\nTXTLE    DS    H                        INSERT LENGTH OF TEXT\nTXTLE1   ST    PRPOINT,PRPT             STORE PROGRAM PTR\n         LM    14,6,TXTSAV              RESTORE REGISTERS\n         BR    R14                      RETURN\nTXTLE2   AR    PRPOINT,WORKR            UPDATE PROGRAM PTR\n         B     TXTLE1\n         SPACE\nREG0     EQU   0\nOUTAREA  EQU   1\nTYPER    EQU   3\nRETURN   EQU   4\nL        EQU   15\nPRPOINT  EQU   6\nINFORM   EQU   2\nLENGTH   EQU   14\n         SPACE\nGENTXT   EQU   *                   GENERATE TXT-RECORDS\n         LA    RETURN,2(0,LENGTH)       COMPUTE RETURN ADDRESS\n         LH    LENGTH,0(0,LENGTH)       LOAD LENGTH GIVEN IN CALL\n         LA    TYPER,TXTT               INDICATE TXT-CALL\n         SPACE\n         L     OUTAREA,SAVOUTA          LOAD ADDRESS OF OUT RECORD\n         CLC   RTYP(3,OUTAREA),RTYP(TYPER)     RECORD RIGTH TYPE\n         BNE   GEN3                     NO,CALL IOR NEW\n         CLC   INFL(2,OUTAREA),RMAX(TYPER)     RECORD FILLED\n         BNL   GEN3                     YES,CALL FOR NEW\n         SPACE\nGEN6     LA    L,56\n         LH    REG0,INFL(0,OUTAREA)     REG0=LENGTH OF INFORM IN REC\n         SR    L,REG0                   L=EMPTY POS LEFT IN RECORD\n         CR    L,LENGTH                 ENOUTH SPACE LEFT\n         BL    *+6                      NO\n         LR    L,LENGTH                 YES L=LENGTH FROM CALL\n         AR    L,REG0\n         STH   L,INFL(0,OUTAREA)        INSERT NEW LENGTH INTO RECORD\n         SR    L,REG0\n         AR    OUTAREA,REG0             START ADDRESS WITHIN RECORD\n         SR    LENGTH,L                 REMAINING LENGTH\n         B     GEN8                     GO TO MOVE TEXT\n         SPACE\nGEN4     LTR   LENGTH,LENGTH            MORE INFORMATION MUST BE MOVED\n         BCR   8,RETURN                 NO, RETURN TO CALLING ROUTINE\n         SPACE\nGEN3     EQU   *                   CALL FOR NEW OUTPUT RECORD\n         ST    LENGTH,SAVELT            SAVE LENGTH\n         TM    HCOMPMOD+1,X'60'    Q. BOTH DECK AND LOAD SPECIFIED\n         BZ    BOTH                     YES\n         TM    HCOMPMOD+1,NDCK         Q. ONLY DECK\n         L     OUTAREA,PCHADD           IF ONLY DECK\n         BZ    PUT1                     YES\n         L     OUTAREA,LINADD           ONLY SYSLIN\nPUT1     PUT   (OUTAREA)                PUT FOR SYSLIN AND SYSPUNCH IF\n         ST    OUTAREA,SAVOUTA          ONLY SYSPUNCH SPECIFIED\n         L     LENGTH,SAVELT           RESTORE LENGTH\n         B     PUNCHOUT\nSAVELT   DS    F                       SAVE AREA FOR LENGTH\nBOTH     L     LENGTH,OUTAREA2         COPY SYSLIN BUFFER TO SYSPUNCH\n         L     OUTAREA,SAVOUTA\n         MVC   0(80,LENGTH),0(OUTAREA)  BUFFER\n         L     OUTAREA,PCHADD\n         PUT   (OUTAREA)                PUT FOR SYSPUNCH WHEN BOTH HAS\n         ST    OUTAREA,OUTAREA2         BEEN SPECIFIED\n         B     PUT1-4                   GO TO PUT SYSLIN\n         SPACE\nPUNCHOUT EQU   *\n         MVC   0(4,OUTAREA),RSTART(TYPER)     INSERT FIRST 4 BYTES\n         MVI   4(OUTAREA),C' '          INSERT ONE BLANK\n         MVC   5(67,OUTAREA),4(OUTAREA)      BLANK OUTPUT RECORD\n         MVC   72(4,OUTAREA),PIDENT     INSERT PROGRAM IDENT\n         L     L,SEQU                   STEP SEQUENCE NUMBER\n         LA    L,1(0,L)\n         ST    L,SEQU\n         CVD   L,ZPACK                  CONVERT TO DECIMAL\n         UNPK  76(4,OUTAREA),ZPACK+5(3)\n         MVZ   79(1,OUTAREA),76(OUTAREA)\n         MVC   10(2,OUTAREA),RLEN(TYPER)     INSERT INITIAL LENGTH\n         MVC   14(6,OUTAREA),RESID(TYPER)     INSERT ESID+R AND P\n         ST    PRPOINT,4(0,OUTAREA)\n         MVI   4(OUTAREA),C' '\n         B     GEN6\n         SPACE\n* TABLE AND MOVE ROUTINE\n         SPACE\nTXTT     DS    0H                  START OF TXT-RECORD  TABLE\n         DC    X'02'                    CARD CODE\n         DC    C'TXT'                   IDENTIFICATION\n         DC    H'0'                     INITIAL LENGTH 0\n         DC    H'1'                     ESID\n         DC    C'    '\n         DC    H'56'                    MAXIMUM LENGTH\n         SPACE\nGEN8     EQU   *                   MOVE TXT-INFORMATION TO OUTAREA\n         BCTR  L,0                      L=L-1\n         STC   L,*+5                    INSERT PROPER LENGTH TO MOVE\n         MVC   16(0,OUTAREA),0(INFORM)      MOVE INFORM TO OUTAREA\n         LA    PRPOINT,1(L,PRPOINT)     INCREASE PROGRAM POINTER\n         LA    INFORM,1(L,INFORM)       MODIFY DATA ADDRESS\n         B     GEN4                     OUT OF MOVE TXT ROUTINE\n* ADDRESS DISPLACEMENTS FOR GENTXT\n         SPACE\nRSTART   EQU   0                        START OF RECORD TYPE TABLE\nRTYP     EQU   1                        RECORD IDENTIFICATION\nRLEN     EQU   4                        INITIAL LENGTH 0 OR 4\nRESID    EQU   6                        ESID OR BLANKS\nRMAX     EQU   12                       MAXIMUM NUMBER OF BYTES IN REC\nINFL     EQU   10                       LENGTH OF INFORM IN A RECORD\n         SPACE\n* AREAS AND CONSTANTS LOCAL FOR GENTXT\n         SPACE\nTXTSAV   DS    9F                       REGISTER SAVE AREA\n         SPACE\n         EJECT\nINTERUPT CLI   7(R1),X'0C'              FLOATING POINT OVERFLOW\n         BE    REALERR                  YES\n         L     WORKR,OLDSPIE            NO, USE DIRECTORY ROUTINE\n         L     R15,0(0,WORKR)           ADDRESS ERROR ROUTINE OF DIREC.\n         BR    R15                      ENTER ERROR ROUTINE\n         EJECT\nWORKAREA DSECT\n         COPY  WORKAREA\nZFOSTA   EQU   FSTAB\n         ORG   DCBUT1\nFSNMAX   DS    H\nLVCOUNT  DS    H\nSUCOUNT  DS    H\nZLEVEN   DS    F\nZSUTEN   DS    F\n         END   START\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IEX31": {"ttr": 4872, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x98\\x01/\\x00\\x98\\x01/\\x16 \\x00h\\x00h\\x00\\x00\\xd6\\xf3\\xf6\\xf0`\\xf2\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1998-01-12T00:00:00", "modifydate": "1998-01-12T16:20:00", "lines": 104, "newlines": 104, "modlines": 0, "user": "O360-20"}, "text": " TITLE 'IEX31, ERROR MESSAGE EDITING'\n*                                                                     *\n*STATUS: CHANGE LEVEL 000.                                            *\n*                                                                     *\n*FUNCTION/OPERATION: THE ERROR PATTERNS GENERATED DURING SCANIII ARE  *\n*   HANDLED AND THE CORRESPONDING DIAGNOSTIC MESSAGES ARE GENERATED.  *\n*                                                                     *\n*ENTRY POINT:                                                         *\n*        IEX31000 - ERROR MESSAGE EDITING         XCTL EP=IEX31       *\n*   THE MODULE IS ENTERED FROM IEX30.                                 *\n*                                                                     *\n*INPUT: N/A                                                           *\n*                                                                     *\n*OUTPUT: THE DIAGNOSTIC MESSAGES ARE PUT OUT ON SYSPRINT. IF SYSPRINT *\n*   IS DOWN, THIS IS REPORTED ON THE CONSOLE TYPEWRITER.              *\n*                                                                     *\n*EXTERNAL ROUTINE: THE PRINT ROUTINE IN IEX00 IS USED.                *\n*                                                                     *\n*EXIT-NORMAL: IF NO TERMINATING ERROR HAS OCCURRED CONTROL IS GIVEN   *\n*   TO THE NEXT PHASE BY MEANS OF  XCTL EP=IEX40.                     *\n*                                                                     *\n*EXIT-ERROR: IF A TERMINATING ERROR HAS OCCURRED (IN THIS MODULE OR   *\n*   THE PRECEDING) CONTROL IS GIVEN TO THE TERMINATING MODULE BY MEANS*\n*   OF  XCTL EP=51002.                                                *\n*                                                                     *\n*TABLES/WORKAREAS: THE MESSAGE TEXTS WITH CORRESPONDING ADDRESS TABLE *\n*   ARE IN THE LOAD MODULE IEX31M.                                    *\n*   THE ERROR MESSAGE EDITING ROUTINE, CSECT IEX60000, ALSO USES THE  *\n*   FOLLOWING TABLES:                                                 *\n*   WINTEBC   FOR TRANSLATION OF INTERNAL CHARACTERS TO EBCDIC        *\n*   WSYMBSRC  FOR TRANSLATION OF                                      *\n*   WSYMBSTK                     INTERNAL SYMBOLS TO EBCDIC           *\n*   WORDSEBC  FOR TRANSLATION OF COMPOUND SYMBOLS IF SOURCE IN EBCDIC *\n*   WORDSISO  FOR TRANSLATION OF COMPOUND SYMBOLS IF SOURCE IN ISOCODE*\n*   WEBCDIC   FOR TRANSLATION EBCDIC-EBCDIC                           *\n*                                                                     *\n*   A WORKAREA OF 270 BYTES, WAREA, IS USED FOR BUILDING THE MESSAGES.*\n*                                                                     *\n*ATTRIBUTES: NONE.                                                    *\n*                                                                     *\n*NOTES: CHARACTER CODE DEPENDENCE: FOR THE BUILDING OF A MESSAGE      *\n*   (CODE PART BETWEEN COT03 AND COT12) THE FOLLOWING APPLIES:        *\n*   IN CASE NO SOURCE INFORMATION IS TO BE INSERTED (COT31), OR IF    *\n*   THE INFORMATION IS EBCDIC-CHARACTERS (COT07), THE OPERATION OF    *\n*   CSECT IEX60000 DEPENDS UPON AN INTERNAL REPRESENTATION OF THE     *\n*   EXTERNAL CHARACTER SET WHICH IS EQUIVALENT TO THE ONE USED AT     *\n*   ASSEMBLY TIME.                                                    *\n*   IF THE SOURCE INFORMATION TO BE INSERTED IS INTERNAL CHARACTERS   *\n*   (COT33) THE OPERATION OF CSECT IEX60000 DEPENDS UPON A TRANSLATION*\n*   FROM THE INTERNAL REPRESENTATION TO THE EBCDIC CHARACTER SET BY   *\n*   MEANS OF THE TABLE 'WINTEBC'.                                     *\n*   IF THE SOURCE INFORMATION TO BE INSERTED IS INTERNAL ALGOL SYMBOLS*\n*   (COT10) THE OPERATION OF CSECT IEX60000 DEPENDS UPON A TRANSLATION*\n*   FROM THE INTERNAL REPRESENTATION TO THE EBCDIC CHARACTER SET BY   *\n*   MEANS OF THE TABLES 'WSYMBSTK'/'WSYMBSRC' AND 'WORDSISO'/         *\n*   'WORDSEBC'.                                                       *\n*   FOR THE OUTPUT OF A MESSAGE (CODE PART BETWEEN COT12 AND COT21)   *\n*   THE FOLLOWING APPLIES:                                            *\n*   WHEN A MESSAGE HAS BEEN BUILT IN EBCDIC, AN EBCDIC-EBCDIC TRANSLA-*\n*   TION IS PERFORMED BEFORE OUTPUT BY MEANS OF THE TABLE 'WEBCDIC'.  *\n*   THUS THE OUTPUT MAY BE MODIFIED BY MAKING CHANGES IN THIS TABLE.  *\n*                                                                     *\n*   THE OPERATION OF CSECT IEX31000 DOES NOT DEPEND UPON A PARTICULAR *\n*   INTERNAL REPRESENTATION OF THE EXTERNAL CHARACTER SET.            *\n*                                                                     *\n*   AT SYSTEM GENERATION THIS MODULE WILL BE LINKED TOGETHER WITH     *\n*   THE MODULE IEX31M TO FORM THE MODULE IEX31 IN LINKLIB.            *\n*                                                                     *\n*   THIS MODULE IS ONLY INTENDED TO BE EXECUTED IN CONNECTION         *\n*   WITH THE OTHER MODULES OF THE ALGOL COMPILER. IN PARTICULAR IT    *\n*   REQUIRES THE COMMON WORKAREA.                                     *\n*                                                                     *\n         EJECT\nIEX31000 CSECT\n         SPACE\n* REGISTER DEFINITIONS\n         SPACE\nRINFO    EQU   1\nRCOT     EQU   2\nRET      EQU   14\nRENT     EQU   15\n         SPACE 2\n         USING *,RENT\n         SPACE\n         L     RCOT,=A(IEX60000)        ADDRESS ERROR MSG EDIT ROUTINE\n         LA    RET,SUSCR                LOAD RETURN ADDRESS\n         LA    RINFO,ERRINFO            ADDRESS INFO FOR ERROR ED ROUT\n         BR    RCOT                     GO TO ERROR MESSAGE EDITING\n         SPACE\n         DS    0F\nSUSCR    EQU   *                   INITIALIZATION OF SUBSCR HANDLING\n         SPACE\n         XCTL  EP=IEX40000\n         SPACE 2\nERRINFO  DC    V(IEX31M00)              ADDRESS OF MESSAGE TEXTS\n         DC    V(IEX31M01)              ADDRESS OF ADDRESS-TABLE\n         DC    H'119'                   MODIFICATION NUMBER\n         LTORG\n         EJECT\n         COPY  IEX60000\n         EJECT\nWORKAREA DSECT\n         COPY  WORKAREA\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IEX31M": {"ttr": 4875, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x98\\x01/\\x00\\x98\\x01/\\x16 \\x00o\\x00o\\x00\\x00\\xd6\\xf3\\xf6\\xf0`\\xf2\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1998-01-12T00:00:00", "modifydate": "1998-01-12T16:20:00", "lines": 111, "newlines": 111, "modlines": 0, "user": "O360-20"}, "text": " TITLE 'IEX31M, ERROR MESSAGE TEXT POOL 2'\n*                                                                     *\n*STATUS: CHANGE LEVEL 000.                                            *\n*                                                                     *\n*FUNCTION/OPERATION: THIS MODULE CONTAINS MESSAGE TEXTS FOR ALL       *\n*   ERRORS THAT MAY BE DETECTED BY IEX00 AND IEX30, AND THE CORRE-    *\n*   SPONDING ADDRESS TABLE.                                           *\n*                                                                     *\n*ENTRY POINT: N/A.                                                    *\n*                                                                     *\n*INPUT: N/A.                                                          *\n*                                                                     *\n*OUTPUT: N/A.                                                         *\n*                                                                     *\n*EXTERNAL ROUTINES: N/A.                                              *\n*                                                                     *\n*EXITS-NORMAL: N/A.                                                   *\n*                                                                     *\n*EXITS-ERROR: N/A.                                                    *\n*                                                                     *\n*TABLES/WORKAREAS: N/A.                                               *\n*                                                                     *\n*ATTRIBUTES: N/A.                                                     *\n*                                                                     *\n*NOTES: AT SYSTEM GENERATION THIS MODULE WILL BE LINKED TOGETHER WITH *\n*   THE MODULE IEX31 TO FORM THE MODULE IEX31 IN LINKLIB.             *\n*                                                                     *\nIEX31M00 CSECT\n         SPACE\n         ENTRY IEX31M01\n         SPACE\nWEMPOOL2 EQU   *                   ERROR MESSAGE POOL 2\n         SPACE\nW080     DC    X'3E0300160C240023001B23'\n         DC    CL52'SOPERAND BEGINNING WITH  IS SYNTACTICALLY INCORRECTX\n               .'\nW081     DC    X'2403000A0C240017000D17'\n         DC    CL26'SIDENTIFIER  NOT DECLARED.'\nW082     DC    X'3603001C0C240029000D29'\n         DC    CL44'SREAL CONSTANT BEGINNING WITH  OUT OF RANGE.'\nW083     DC    X'5A05001612240029001E29F00000001149'\n         DC    CL74'WINTEGER BEGINNING WITH  OUT OF RANGE. INTEGER CONSX\n               TANT CONVERTED TO REAL.'\nW084     DC    X'750500291224003C00083CF00000003045'\n         DC    CL101'WPRECISION OF REAL CONSTANT BEGINNING WITH  EXCEEDX\n               S INTERNALLY HANDLED PRECISION. CONSTANT TRUNCATED.'\nW085     DC    X'210300140C240021000021'\n         DC    CL23'SILLEGAL USE OF LABEL .'\nW086     DC    X'1500'\n         DC    CL20'STOO MANY CONSTANTS.'\nW087     DC    X'3A00'\n         DC    CL57'WFULL OPTIMIZATION NOT POSSIBLE DUE TO INTERNAL OVEX\n               RFLOW.'\nW088     DC    X'8805000A1224001C002C1DF00000003D4B'\n         DC    CL120'WIDENTIFIER  IN BOUND EXPRESSION DECLARED IN SAME X\n               PROGRAM BLOCK AS ARRAY. DECLARATION IN SURROUNDING BLOCKX\n                SEARCHED FOR.'\nW089     DC    X'450300040C240011003411'\n         DC    CL59'WGOTO  INVALID OUTSIDE FOR STATEMENT CONTAINING THIX\n               S LABEL.'\n         SPACE\n*\n* DIRECTORY MESSAGES\n*\n         SPACE\nW090     EQU   *\nW209     EQU   *\n         DC    X'460400360FF00000840046000046'\n         DC    CL57'TCOMPILATION UNSUCCESSFUL DUE TO PROGRAM INTERRUPT.X\n                PSW .'\nW091     EQU   *\nW210     EQU   *\n         DC    X'300300270C840030000030'\n         DC    CL38'TUNRECOVERABLE I/O ERROR ON DATA SET .'\nW092     EQU   *\nW211     EQU   *\n         DC    CL56'PROGRAM INTERRUPT IN ERROR MESSAGE EDITING ROUTINE.X\n                PSW '\nW093     EQU   *\nW212     DC    X'1200'\n         DC    CL17'TTOO MANY ERRORS.'\nW094     EQU   *\nW213     DC    X'2800'\n         DC    CL39'TINTERNAL OVERFLOW OF IDENTIFIER TABEL.'\nW095     EQU   *\nW215     EQU   *\n         DC    X'1A00'\n         DC    CL25'TSOURCE PROGRAM TOO LONG.'\n         EJECT\n         DS    0F\n         SPACE 2\nIEX31M01 EQU   *-320                    ADDRESS TABLE FOR WEMPOOL2\n         SPACE\n         DC    A(W080)\n         DC    A(W081)\n         DC    A(W082)\n         DC    A(W083)\n         DC    A(W084)\n         DC    A(W085)\n         DC    A(W086)\n         DC    A(W087)\n         DC    A(W088)\n         DC    A(W089)\n         DC    A(W090)\n         DC    A(W091)\n         DC    A(W092)\n         DC    A(W093)\n         DC    A(W094)\n         DS    F\n         DC     A(W095)\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IEX40": {"ttr": 5123, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x98\\x01/\\x00\\x98\\x01/\\x16!\\x03Z\\x03Z\\x00\\x00\\xd6\\xf3\\xf6\\xf0`\\xf2\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1998-01-12T00:00:00", "modifydate": "1998-01-12T16:21:00", "lines": 858, "newlines": 858, "modlines": 0, "user": "O360-20"}, "text": " TITLE 'IEX40, SUBSCRIPT HANDLING AND INITIALIZATION OF COMPILATION PHAX\n               SE'\n*                                                                     *\n*STATUS: CHANGE LEVEL 000.                                            *\n*                                                                     *\n*FUNCTION/OPERATION: CSECT IEX40000 BUILDS THE OPTIMIZATION TABLE     *\n*   (OPTAB) USING THE SUBSCRIPT TABLE, THE LEFT VARIABLE TABLE AND    *\n*   THE FOR STATEMENT TABLE. AN OPTAB ENTRY \"ORRESPOND TO AN OPTIMI-  *\n*   ZABLE SUBSCRIPT EXPRESSION INSIDE A FORSTATEMENT. IF NO OPTAB IS  *\n*   PRODUCED THIS IS INDICATED IN THE COMPILER STATUS BYTES           *\n*   (HCOMPMOD).                                                       *\n*   CSECT IEX40001 IS THE INITIALIZATION OF NEXT MODULE, IEX50, AND   *\n*   PERFORMS THE FOLLOWING FUNCTIONS: CALCULATION AND RESERVATION OF  *\n*   CORE STORAGE AREAS NEEDED, LOADING REGISTERS WITH START ADDRESSES,*\n*   READING THE FIRST RECORDS OF SOURCE PROGRAM AND OPTAB, AND SETTING*\n*   INITIAL VALUES IN THE PRIVATE PART OF COMMON WORKAREA.            *\n*                                                                     *\n*ENTRY POINT:                                                         *\n*        IEX40000.                                                    *\n*                                                                     *\n*INPUT: CSECT IEX40000 READS TWO TABLES CONSTRUCTED IN IEX30 FROM     *\n*   SYSUT3. THE SUBSCRIPT TABLE (SUTAB) CONTAINS ENTRIES FOR LINEAR   *\n*   SUBSCRIPT EXPRESSIONS IN FOR STATEMENTS THAT ARE OPTIMIZABLE IN   *\n*   REGARD TO SUBSCRIPTS.                                             *\n*   THE LEFT VARIABLE TABLE (LVTAB) CONTAINS ENTRIES FOR INTEGER LEFT *\n*   VARIABLES IN FOR STATEMENTS THAT ARE OPTIMIZABLE IN REGARD TO     *\n*   SUBSCRIPTS.                                                       *\n*   CSECT IEX40001 READS THE FIRST TWO RECORDS OF THE SOURCE PROGRAM  *\n*   FROM SYSUT2 INTO TWO SOURCE BUFFERS.                              *\n*   THE FIRST TWO RECORDS OF OPTAB ARE READ IN FROM SYSUT3 TO TWO     *\n*   OPTAB BUFFERS.                                                    *\n*                                                                     *\n*OUTPUT: THE OPTIMIZATION TABLE (UPTAB)IS WRITTEN OUT ON SYSUT3. OPTAB*\n*   CONTAINS ONE ENTRY FOR EVERY OPTIMIZABLE SUBSCRIPT EXPRESSION IN  *\n*   A FOR STATEMENT                                                   *\n*                                                                     *\n*EXTERNAL ROUTINES: THE INTERRUPT ROUTINES OF IEX00 ARE USED.         *\n*                                                                     *\n*EXIT-NORMAL: CONTROL IS GIVEN TO THE NEXT LOAD MODULE BY MEANS OF    *\n*        XCTL  EP=IEX50.                                              *\n*                                                                     *\n*EXITS-ERROR: INPUT/OUTPUT ERRORS AND PROGRAM INTERRUPTS ARE HANDLED  *\n*   BY A DIRECTORY ROUTINE WHICH RETURNS CONTROL TO THE INTERRUPTED   *\n*   MODULE. IF THE ERROR OCCURED BEFORE THE GETMAIN IN IEX40001       *\n*   CONTROL IS GIVEN TO THE \\ERMINATING MODULE BY MEANS OF            *\n*        XCTL  EP=IEX51ER2.                                           *\n*   IF THE ERROR OCCURED AFTER THE GETMAIN CONTROL IS GIVEN TO THE    *\n*   TERMINATING MODULE BY MEANS OF                                    *\n*        XCTL  EP=IEX51ER1.                                           *\n*                                                                     *\n*TABLES/WORKAREAS: THE FOR STATEMENT TABLE (FSTAB) CONSTRUCTED IN     *\n*   IEX30 AND POSSIBLY REVISED BY IEX40000 CONTAINS CLASSIFICATIONS   *\n*   OF THE FOR STATEMENTS.                                            *\n*                                                                     *\n*ATTRIBUTES: NONE.                                                    *\n*                                                                     *\n*NOTES: THE OPERATION OF THIS MODULE DOES NOT DEPEND UPON ANY SPECIAL *\n*   REPRESENTATION OF THE EXTERNAL CHARACTER SET.                     *\n*   THIS MODULE IS ONLY INTENDED TO BE EXECUTED IN CONNECTION         *\n*   WITH THE OTHER MODULES OF THE ALGOL COMPILER. IN PARTICULAR IT    *\n*   REQUIRES THE COMMON WORKAREA.                                     *\n*                                                                     *\n         EJECT\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\nWORKR    EQU   R2\nWORKX    EQU   R3\n         SPACE\n*              BIT PATTERNS\nFIRSTM   EQU   X'20'                    FIRST ENTRY IN SUTAB CHAIN\nSUCM     EQU   X'10'                    SUCCEDING ENTRY IN SUTAB CHAIN\nLASTM    EQU   X'30'                    LAST ENTRY IN SUTAB CHAIN\nOFFM     EQU   X'CF'                    TURN OFF SUTAB CHAIN BITS\nSUOP     EQU   X'40'                    SUBSCRIPT OPTIMIZATION BIT\nNOOP     EQU   X'20'                    NO SUBSCRIPT OPTIMIZATION\nSYNTAX   EQU   X'80'                    SYNTAX CHEXK MASK\n         EJECT\nIEX40000 CSECT\n* RELEASE 19 CHANGES                                             A27002\n* 020800,056000,068800                                           A27002\nSTART    BALR  R12,0\n         USING *,R12\n         USING WORKAREA,R13\n         TM    HCOMPMOD,SYNTAX          SYNTAX CHECK MODE\n         BO    NOSUTAB                  YES\n         SPACE\n*              INITILIZE SUTAB\n         SPACE\n         SPACE\n         CLC   ZSUTEN(4),ZERO           SUTAB EMPTY\n         BE    NOSUTAB                  YES\n*                                                                A27002\n*              ANY NESTED FOR LOOPS                              A27002\n*                                                                A27002\n         SR    WORKR,WORKR                                       A27002\n         ST    WORKR,FOR1                                        A27002\n         MVC   FOR1+4(255),FOR1+3      SET FOR STMNT COUNT       A27002\n         MVC   FOR2+2(255),FOR2+1       AREAS TO ZERO            A27002\n         LH    R0,FSNMAX                                         A27002\n         AH    R0,FOR5                  NO OF FOR STMNT          A27002\n         LA    R1,GPTAB                                          A27002\nGP1      LA    R1,3(0,R1)               PTR TO NEXT GPTAB RECORD A27002\n         CLC   ZERO(1),2(R1)            FOR STATEMENT?           A27002\n         BE    GP1                      NO                       A27002\n         SH    R0,FOR5                 ALL FOR STMNT CHECKED?    A27002\n         BM    GP10                    YES                       A27002\n         MVC   FOR4(3),0(R1)           MOVE GPTAB RECORD         A27002\n         LH    WORKX,FOR4              MULTIPLY GPTAB PTR BY 3   A27002\n         AR    WORKX,WORKX              GIVES CORRECT ADDRESS    A27002\n         AH    WORKX,FOR4                IN GPTAB                A27002\n         LA    WORKX,GPTAB(WORKX)                                A27002\n         CLC   ZERO(1),2(WORKX)        Q. NESTED                 A27002\n         BE    GP1                      NO                       A27002\n         IC    WORKR,FOR4+2            FOR STMNT NO+1            A27002\n         LA    R4,FOR2-1(WORKR)                                  A27002\n         MVC   0(1,R4),2(WORKX)         STORE ENCLOSING FSN      A27002\n         B     GP1                                               A27002\n         SPACE 1\nGP10     LA    WORKR,TERMIN2           TERMINATION ADDRESS       A27002\n         ST    WORKR,ERET\n         L     R0,SUTAB40S              RESERVE TABLE AREA\n         A     R0,OPTABS\n         AR    R0,R0\n         AH    R0,EIGHT\n         ST    R0,TABSIZE               SAVE LENGTH OF TABLE AREA\n         GETMAIN R,LV=(0)               ALLOCATE STORAGE TO SUTAB\n         LA    WORKR,TERM1              ERROR RETURN ADDRESS\n         ST    WORKR,ERET\n         ST    R1,TSTART                SUTAB START ADDRESS\n         SPACE\n*                                  READ SUTAB\n         SPACE\n         LH    RCOUNT,SUCOUNT           NUMBER OF SUTAB RECORDS - 1\n         L     RTYPE,SUTYPE             SUTAB RECORD IDENTIFICATION\n         L     RLE,SUTAB30S             LENGTH OF WRITTEN SUTAB RECORDS\n         L     RSTART,TSTART            TABLE START ADDRESS\n         BAL   READX,READ               READ FULL SUTAB\n         EJECT\nRSUDEN   EQU   R11                      END ADDRESS OF UNSORTED SUTAB\nRFSN     EQU   R10                      FOR STATEMENT NUMBER\nRSEARCH  EQU   R9                       CURRENT PTR IN UNSORTED SUTAB\nRS       EQU   R8                       PTR FOR CHAINING CHECK\nRFALL    EQU   R7                       FULL LENGTH OF DELETED ENTRIES\n         SPACE\n*              SCAN SUTAB FOR ENTRY CHAINING AND ENTRY DELETION\n         SPACE\n         L     RSEARCH,TSTART           TABLE START ADDRESS WITH KEY\n         LA    RSEARCH,4(0,RSEARCH)     DELETE KEY\n         LR    RSUDEN,RSEARCH           CLACULATE END.ADDRESS\n         A     RSUDEN,ZSUTEN\n         SR    RFSN,RFSN\n         SR    RFALL,RFALL\n         SPACE\nSUTABS   IC    RFSN,0(0,RSEARCH)        ISOLATE ACTUELL FOR STATEM.NUMB\n         LA    WORKR,FSTAB(RFSN)        ADDRESS ACRUELL FOR ENTRY\n         TM    0(WORKR),SUOP            SUBSCRIPT OPTIMIZATION POSSIBLE\n         BZ    SUTABS2                  YES\n         LA    RFALL,14(0,RFALL)        LENGTH OF DELETED ENTRIES\n         MVI   0(RSEARCH),X'FF'         NOT OPTIMIZABLE ENTRY\n         LA    RSEARCH,14(0,RSEARCH)    GET NEXT ENTRY\n         CR    RSEARCH,RSUDEN           SUTAB END\n         BE    SORTSU                   YES\n         B     SUTABS\n         SPACE\nSUTABS2  LR    RS,RSEARCH               CHECK ENTRY CHAINING\nSUTABS3  EQU   *\n         LA    RS,14(0,RS)              SCAN SUTAB FOWORD FOR CHAINING\n         CR    RS,RSUDEN                SUTAB END\n         BE    SORTSU                   YES\n         CLC   10(4,RSEARCH),10(RS)     CHAIN\n         BE    SUTABS4                  YES\n         LR    RSEARCH,RS               PROCESS NEW ENTRY AS FIRST\n         B     SUTABS\n         SPACE\nSUTABS4  IC    RFSN,0(0,RS)             ISOLATE FSN OF NEW ENTRY\n         LA    WORKR,FSTAB(RFSN)        ADDRESS FSTAB ENTRY\n         TM    0(WORKR),SUOP            SUBSCRIPT OPTIMIZABLE\n         BZ    SUTABS5                  YES\n         MVI   0(RS),X'FF'              NO, DELETE ENTRY\n         LA    RFALL,14(0,RFALL)        COUNT LENGTH OF DELETED ENTRIES\n         B     SUTABS3                  CHECK NEXT ENTRY\n         SPACE\nSUTABS5  OI    10(RSEARCH),FIRSTM       INDICATE FIRST ENTRY IN CHAIN\nSUTABS6  LR    RSEARCH,RS               ADDRESS CURRENT LAST CHAIN ENTR\nSUTABS7  EQU   *\n         LA    RS,14(0,RS)              CHECK NEXT SUTAB ENTRY\n         CR    RS,RSUDEN                SUTAB END\n         BE    SUTABS9                  YES\n         CLC   10(4,RSEARCH),10(RS)     ANOTHER CHAINED ENTRY\n         BE    SUTABS8                  YES\n         OI    10(RSEARCH),LASTM        INDICATE ENTRY IN CHAEN\n         LR    RSEARCH,RS               PROCESS NEW ENTRY AS FIRST\n         B     SUTABS\n         SPACE\nSUTABS8  IC    RFSN,0(0,RS)             NEW FOR STATEMENT NUMBER\n         LA    WORKR,FSTAB(RFSN)        ADDRESS FSTAB ENTRY\n         TM    0(WORKR),SUOP            SUBSCRIPT OPTIMIZATION POSSIBLE\n         BZ    SUTABS10                 YES, CHAIN\n         SPACE\n         MVI   0(RS),X'FF'              DELETE ENTRY\n         LA    RFALL,14(0,RFALL)        CALCULATE DELETED LENGTH\n         B     SUTABS7\n         SPACE\nSUTABS9  OI    10(RSEARCH),LASTM        INDICATE LAST ENTRY IN CHAIN\n         B     SORTSU\n         SPACE\nSUTABS10 OI    10(RSEARCH),SUCM         INDICATE BETWEEN ENTRY\n         B     SUTABS6\n         SPACE\nSORTSU   EQU   *\n         L     WORKX,TSTART\n         LA    WORKR,4(0,WORKX)         START ADDRESS OF UNSORTED SUTAB\n         ST    WORKR,ZSTAD              START OF UNSORTED TABLE\n         L     REND,ZSUTEN              GET END OF UNSORTED SUTAB\n         AR    REND,WORKR\n         A     WORKX,TABSIZE            END ADDRESS OF SORTED SUTAB\n         ST    WORKX,ZSUDEN\n         S     WORKX,ZSUTEN\n         AR    WORKX,RFALL              START OF SORTED SUTAB\n         C     WORKX,ZSUDEN             WHOLE SUTAB DELETED\n         BE    NOSUTAB1                 YES\n         ST    WORKX,ZSUDAD\n         ST    WORKX,ZSORTSTA\n         LA    RENTRY,14                ENTRY LENGTH\n         BAL   SORTX,SORT               SORT SUTAB\n         SPACE\n*                                  INITILIZE OPTAB BUFFERS\n         L     WORKR,TSTART\n         ST    WORKR,ZOTAWRI            SECOND OPTAB BUFFER\n         A     WORKR,OPTABS\n         ST    WORKR,ZOTAFILL           FIRST OPTAB BUFFER\n         A     WORKR,OPTABS\n         ST    WORKR,ZOTMAX             ACTUELL BUFFER END\n         SPACE\n         CLC   ZLEVEN(4),ZERO           LVTAB EMPTY\n         BNE   SORTLE                   NO\n         MVC   ZLESTA(4),ZOTMAX         SET DUMMY START ADDRESS\n         B     SORTLE1\n         SPACE\nSORTLE   EQU   *\n         LH    RCOUNT,LVCOUNT           NUMBER OF LVTAB RECORDS -7\n         L     RTYPE,LVTYPE             LVTAB-RECORD IDENTIFICATION\n         L     RLE,LVTAB30S             LENGTH OF LVTAB RECORD\n         L     RSTART,TSTART            START ADDRESS OF TABLE AREA\n         BAL   READX,READ               READ LVTAB INTO CORE\n         SPACE\n         L     WORKR,TSTART\n         LA    WORKR,4(0,WORKR)\n         ST    WORKR,ZSTAD              START ADDRESS OF UNSORTED TABLE\n         A     WORKR,ZLEVEN\n         LR    REND,WORKR               END OF UNSORTED TABLE\n         C     WORKR,ZOTMAX             LVTAB LONGER THAN OPTAB BUFFER\n         BH    *+8                      YES\n         L     WORKR,ZOTMAX             NO,START SORTED TAB AFTER OPTAB\n         ST    WORKR,ZSORTSTA           START ADDRESS OF SORTED TABLE\n         ST    WORKR,ZLESTA\n         LA    RENTRY,4                 ENTRY LENGTH\n         BAL   SORTX,SORT               SORT LVTAB\n         SPACE\nSORTLE1  L     WORKR,ZLESTA\n         A     WORKR,ZLEVEN\n         MVI   0(WORKR),X'FF'           SET LVTAB END\n         SPACE\n         L     WORKR,UT3ADD\n         CLOSE ((WORKR),REREAD),TYPE=T  POINT TO BEGINNING OF DATA SET\n         SPACE\nRLV      EQU   R4                       PTR TO START OF LVTAB GROUP\nRL       EQU   R5                       CURRENT PTR IN LVTAB GROUP\nRSUPO    EQU   R6                       CURRENT SUTAB PTR\nRSU      EQU   R7                       SUTAB CHAIN SEARCHING PTR\nROTPO    EQU   R8                       CURRENT OPTAB BUFFER PTR\nOTACHAX  EQU   R9\nOPTAB    EQU   *\n         L     RLV,ZLESTA               START OF LVTAB\n         L     RSUPO,ZSUDAD             START OF SUTAB\n         L     ROTPO,ZOTAFILL           START OF FIRST OPT AB BUFFER\n         SPACE\nOPT1     EQU   *\n*              DOES LVTAB-GROUP CORRESPOND TO THIS SUTAB ENTRY\n         CLC   0(1,RSUPO),0(RLV)\n         BL    OPT3                     NO LVTAB-ENTRIES TO THIS FOR-ST\n         LR    RL,RLV                   INITILIZE CURRENT GROUP PTR\n         BH    OPT6                     SCAN FOR NEXT LVTAB GROUP\nOPT2     CLC   1(3,RL),4(RSUPO)         CHECK FACTOR\n         BE    OPT71                    NO OPTIMIZATION\n         CLC   1(3,RL),7(RSUPO)         CHECK ADDEND\n         BE    OPT7                     NO OPTIMIZATION\n         LA    RL,4(0,RL)               ADDRESS NEXT LVTAB ENTRY\n         CLC   0(1,RL),0(RLV)           NEW ENTRY OF SAME GROUP\n         BE    OPT2                     YES, PROCEED CHECK\n         SPACE\nOPT3     C     ROTPO,ZOTMAX             END OF OPTAB BUFFER\n         BNL   OPT10                    YES\nOPT4     MVC   0(14,ROTPO),0(RSUPO)     MOVE SUTAB ENTRY TO OPTAB\n         SR    R2,R2                                             A27002\n         IC    R2,0(0,ROTPO)           FOR STATEMENT NO          A27002\n         SR    R0,R0                                             A27002\nOPT42    IC    R0,FOR1(R2)             FOR STATEMENT COUNT       A27002\n         AH    R0,FOR5                 INCREASE FS COUNT         A27002\n         CL    R0,FOR3                 >85 ENTRIES IN OPTAB      A27002\n         BL    OPT44                   NO                        A27002\n         LA    R1,FSTAB(R2)                                      A27002\n         OI    0(R1),X'80'             SET ELEMENTARY LOOP       A27002\nOPT44    STC   R0,FOR1(R2)             RESTORE FSN COUNT         A27002\n         IC    R2,FOR2(R2)                                       A27002\n         CL    R2,ZERO                 ANY ENCLOSING FOR STMT    A27002\n         BE    OPT46                    NO                       A27002\n         SH    R2,FOR5                 GIVES CORRECT FSN         A27002\n         B     OPT42                    ADD UP ENCLOSING LOOP    A27002\nOPT46    LA    ROTPO,14(0,ROTPO)       UPDATE OPTAB PTR          A27002\nOPT5     LA    RSUPO,14(0,RSUPO)        GET NEXT SUTAB ENTRY\n         C     RSUPO,ZSUDEN             SUTAB END\n         BE    TERMIN                   YES\n         TM    10(RSUPO),SUCM           ACTIVE ENTRY\n         BZ    OPT1                     YES\n         B     OPT5                     NO, GET NEXT ENTRY\n         SPACE\nOPT6     EQU   *                   SCAN FOR NEXT LVTAB GROUP\n         LA    RL,4(0,RL)               GET NEXT LVTAB ENTRY\n         CLC   0(1,RL),0(RLV)           SAME GROUP\n         BE    OPT6                     YES\n         LR    RLV,RL                   NO, SET LVTAB GROUP PTR\n         B     OPT1\n         SPACE\nOPT7     EQU   *\n         CLC   4(3,RSUPO),ZERO          FACTOR ZERO\n         BE    OPT72                    YES\nOPT71    SR    WORKR,WORKR              ADDRESS FSTAB ENTRY\n         IC    WORKR,0(0,RSUPO)\n         LA    WORKR,FSTAB(WORKR)\n         OI    0(WORKR),X'80'           SET ELEMENTARY LOOP\n         SPACE\nOPT72    EQU   *                   HANDLE SUTAB CHAINING\n         TM    10(RSUPO),FIRSTM         ANY CHAINING\n         BZ    OPT5\n         LR    RSU,RSUPO                INITILIZE CHAIN SZARCH\nOPT8     LA    RSU,14(0,RSU)            NEXT SUTAB ENTRY\n         CLC   11(3,RSU),11(RSUPO)      ENTRY IN CHAIN\n         BNE   OPT8                     NO\n         MVN   SUPOS(1),10(RSU)         SUBSCRIPT NUMBER\n         MVN   *+7(1),10(RSUPO)         SUBSCRIPT NUMBER\n         CLI   SUPOS,X'00'              SUBSCRIPT NUMBER EQUAL\n         BNE   OPT8                     NO\n         SPACE\n         TM    10(RSU),LASTM            LAST ENTRY IN CHAIN\n         BO    OPT9                     YES\n         NI    10(RSU),OFFM             TURN OFF CHAIN BITS\n         OI    10(RSU),FIRSTM           SET FIRST ENTRY BIT\n         B     OPT5\n         SPACE\nOPT9     NI    10(RSU),OFFM             TURN OFF CHAIN BITS\n         B     OPT5\n         SPACE\nOPT10    BAL   OTACHAX,OTACHA           CHANGE OPTAB BUFFER\n         B     OPT4\n         SPACE\nTERMIN   EQU   *\n         C     ROTPO,ZOTAFILL           ANY OPTAB\n         BNE   *+12                     YES\n         OI    HCOMPMOD+2,NOOP          NO OPTAB PRESENT\n         B     TERM1\n         SPACE\n         C     ROTPO,ZOTMAX             END OF OPTAB BUFFER\n         BNE   TERMIN1                  NO\n         BAL   OTACHAX,OTACHA           CHANGE OUTPUT BUFFER\nTERMIN1  MVI   0(ROTPO),X'FF'           INDICATE END OF SUTAB\n         BAL   OTACHAX,OTACHA           WRITE LAST OPTAB RECORD\n         CHECK OWRITE                   CHECK LAST OPTAB RECORD\n         SPACE\n         L     R0,UT3ADD                DCB ADDRESS\n         CLOSE ((R0),REREAD),TYPE=T     POINT TO BEGINNING OF DATASET\n         SPACE\n         SPACE 1\nTERM1    LH    R4,FSNMAX                                         A27002\n         SR    R3,R3                                             A27002\n         SR    R1,R1                                             A27002\nTERM12   LA    R1,1(0,R1)                                        A27002\n         CLR   R1,R4                   ALL FOR STMNT CHECKED     A27002\n         BH    TERM15                  YES                       A27002\n         LA    R2,FOR2(R1)                                       A27002\n         CLC   ZERO(1),0(R2)           ANY ENCLOSING LOOP?       A27002\n         BE    TERM12                  NO                        A27002\n         IC    R3,0(R2)                GET NO OF OPTAB ENTRIES   A27002\n         SR    R2,R2                                             A27002\n         IC    R2,FOR1-1(R3)            IN ENCLOSING LOOP        A27002\n         CL    R2,FOR3                 MORE THAN 85              A27002\n         BL    TERM12                  NO                        A27002\n         LA    R2,255                  MARK FOR SUCCEDING FS     A27002\n         STC   R2,FOR1(R1)              THAT THIS FS IS ELEMEN.  A27002\n         LA    R2,FSTAB(R1)                                      A27002\n         OI    0(R2),X'80'             SET ELEMENTARY LOOP       A27002\n         B     TERM12                                            A27002\n         SPACE 1\nTERM15   L     R0,TABSIZE              LENGTH OF TABLE AREA      A27002\n         L     R0,TABSIZE               LENGTH OF TABLE AREA\n         L     R1,TSTART\n         FREEMAIN R,LV=(0),A=(1)\n         SPACE\nTERMIN2  EQU   *\n         TM    HCOMPMOD,ERR             ERROR CONDITION\n         BO    TERMERR                  YES\n         L     R12,VSEC1                ADDRESS OF NEXT CSECT\n         BR    R12\n         SPACE\nTERMERR  EQU   *\n         XCTL  EP=IEX51ER2\n         SPACE\nNOSUTAB  EQU   *\n         OI    HCOMPMOD+2,NOOP          NO SUBSCRIPT OPTIMIZATION BIT\n         B     TERMIN2\n         SPACE\nNOSUTAB1 EQU   *\n         OI    HCOMPMOD+2,NOOP          NO OPTAB BIT\n         B     TERM1\n         EJECT\nOTACHA   EQU   *\n         B     OTACHA2                  FIRST TIME SWITCH\n         CHECK OWRITE\nOTACHA1  EQU   *\n         L     R0,UT3ADD                DCB ADDRESS\n         L     WORKR,ZOTAFILL           ADDRESS OF BUFFER TO WRITE\n         L     WORKX,OPTABS             SIZE OF OPTAB BUFFER\n         WRITE OWRITE,SF,(R0),(WORKR),(WORKX)\n         L     ROTPO,ZOTAWRI            CHANGE OPTAB BUFFERS\n         MVC   ZOTAWRI(4),ZOTAFILL\n         ST    ROTPO,ZOTAFILL\n         LR    WORKR,ROTPO\n         A     WORKR,OPTABS             BUFFER END ADDRESS\n         ST    WORKR,ZOTMAX\n         BR    OTACHAX\nOTACHA2  MVI   OTACHA+1,X'00'           SET OFF FIRST TIME SWITCH\n         B     OTACHA1\n         SPACE 3\nRSTART   EQU   R11                      START  ADDRESS OF INPUT AREA\nRCOUNT   EQU   R10                      RECORD COUNT\nRTYPE    EQU   R9                       RECORD IDENTIFICATION\nRLE      EQU   R8                       RECORD LENGTH\nREADX    EQU   R7                       RETURN REGISTER\nREAD     EQU   *\n         L     R1,UT3ADD                DCB ADDRESS\n         MVI   SULTSTRT+3,X'01'         ADDRESS FIRST INPUT RECORD\n         POINT (1),SULTSTRT\n         SPACE\nREAD1    L     WORKR,UT3ADD             DCB ADDRESS\n         READ  READR,SF,(WORKR),(RSTART),'S'\n         CHECK READR\n         C     RTYPE,0(0,RSTART)\n         BNE   READ1\n         SPACE\n         MVC   0(4,RSTART),SAVETAB      RESTORE OVERLAYED PART\n         BCT   RCOUNT,READ2             MORE RECORDS TO READ\n         BR    READX                    NO\n         SPACE\nREAD2    AR    RSTART,RLE               UPDATE CURRENT PT2\n         MVC   SAVETAB(4),0(RSTART)\n         B     READ1\n         SPACE 3\nRENTRY   EQU   R11                      LENGTH OF TABLE ENTRY\nRPO      EQU   R10                      CURRENT PTR IN UNSORTED TABLE\nREND     EQU   R9                       END OF UNSORTED TABLE\nSORTX    EQU   R15                      RETURN REGISTER\n         SPACE\nREL      EQU   RPO                      RELATIVE ADDRESS IN SORTED TAB.\nRPAD     EQU   R8                       PTR TO ACTUEL ADDRESS TAB ENTRY\nRGO      EQU   R7                       PTR TO ACTUEL COUNT TAB ENTRY\nRE       EQU   WORKX                    ADDRESS OF LAST COUNT TAB ENTRY\n         SPACE\nRTO      EQU   RPAD                     START ADDRESS OF SORTED TABLE\n         SPACE 3\nSORT     EQU   *\n         MVC   ZCOSTA(1),ZERO           ZEROIZE TABLES\n         MVC   ZCOSTA+1(254),ZCOSTA\n         MVC   ZCOSTA+255(255),ZCOSTA\n         MVC   ZADSTA(255),ZCOSTA\n         MVC   ZADSTA+255(255),ZCOSTA\n         L     RPO,ZSTAD                CURRENT PTR\n         SPACE\nSORT1    CLI   0(RPO),X'FF'             DELETED ENTRY\n         BE    SORT2                    YES\n         SR    WORKR,WORKR              ISOLATE ACTUELL FSN\n         IC    WORKR,0(0,RPO)\n         AR    WORKR,WORKR              FSN * 2\n         LH    WORKX,ZCOSTA(WORKR)      GET OLD COUNTER\n         LA    WORKX,1(0,WORKX)         INCREASE BY ONE\n         STH   WORKX,ZCOSTA(WORKR)      STORE NEW COUNTER\n         SPACE\nSORT2    AR    RPO,RENTRY               ADDRESS NEXT ENTRY\n         CR    RPO,REND                 END OF TABLE\n         BL    SORT1                    NO\n         SPACE\n*              BUILD ADDRESS TABLE\n         LH    WORKR,FSNMAX             GET ADDRESS OF LAST COUNT ENTRY\n         AR    WORKR,WORKR\n         LA    RE,ZCOSTA(WORKR)         LAST ENTRY\n         SPACE\n         SR    REL,REL                  RELATIVE ADDRESS IN NEW TABLE\n         LA    RGO,ZCOSTA               CURRENT COUNT TABLE PTR\n         LA    RPAD,ZADSTA+2            CURRENT ADDRESS TABLE PTR\nSORT3    EQU   *\n         CR    RGO,RE                   LAST ENTRY\n         BH    SORT4                    YES\n         LH    R1,0(0,RGO)              NUMBER OF ENTRIES\n         MR    R0,RENTRY                COMPUTE TABLE LENGTH\n         AR    REL,R1                   RELATIVE TABLE ADDRESS\n         STH   REL,0(0,RPAD)            MAKE ENTRY IN ADDRESS TABLE\n         LA    RGO,2(0,RGO)             ADDRESS NEXT ENTRY\n         LA    RPAD,2(0,RPAD)           ADDRESS NEXT ENTRY\n         B     SORT3\n         SPACE\n*              BUILD SORTED TABLE\nSORT4    EQU   *\n         L     RPO,ZSTAD                START OF UNSORTED TABLE\n         L     RTO,ZSORTSTA             START OF SORTED TABLE\n         LR    WORKR,RENTRY             INITLIZE MOVE OF ENTRY\n         BCTR  WORKR,0\n         STC   WORKR,SORTM+1\n         SPACE\nSORT5    CLI   0(RPO),X'FF'             DELETED ENTRY\n         BE    SORT6                    YES\n         SR    WORKR,WORKR              ISOLATE FSN\n         IC    WORKR,0(0,RPO)\n         AR    WORKR,WORKR              FSN * 2\n         LH    WORKX,ZADSTA(WORKR)      GET RELATIVE ADDRESS\n         LR    R0,WORKX                 UPDATE RELATIVE ADDRESS\n         AR    R0,RENTRY\n         STH   R0,ZADSTA(WORKR)\n         AR    WORKX,RTO                GET ADDRESS IN SORTED TABLE\nSORTM    MVC   0(0,WORKX),0(RPO)        MOVE ENTRY\nSORT6    EQU   *\n         AR    RPO,RENTRY               GET NEXT ENTRY\n         CR    RPO,REND                 END OF TABLE\n         BNE   SORT5                    NO\n         BR    SORTX\n         EJECT\nVSEC1    DC    V(IEX40001)              ADDRESS OF IEX40001\nSUTYPE   DC    C'SUTB'                  SUTAB IDENTIFICATION\nLVTYPE   DC    C'LVTB'                  LVTAB IDENTIFICATION\nZERO     DC    F'0'\nEIGHT    DC    H'8'\nSUPOS    DC    X'00'\n         DS    0F                                                A27002\nFOR1     DS    CL256                   FOR STMNT COUNT AREA      A27002\nFOR2     DS    CL256                    ENCLOSING FS MARK AREA   A27002\nFOR3     DC    F'86'                    MAX ENTRIES IN OPTAB     A27002\nFOR4     DS    3H                      WORK AREA FOR GPTAB REC   A27002\nFOR5     DC    H'1'                                              A27002\n         EJECT\n         TITLE 'IEX40001, INITIALIZATION OF COMPILATION PHASE'\nIEX40001 CSECT\n         SPACE 2\n* REGISTER DEFINITIONS\n         SPACE\nRESAR    EQU   1\nRLTOTAR  EQU   2\nWRK1     EQU   2\nRLIBUF1  EQU   3\nWRK2     EQU   3\nWRK3     EQU   4\nRLOPBUF1 EQU   4\nWRK4     EQU   5\nRLOPDST  EQU   6\nRPRPT    EQU   6\nRLLAT    EQU   7\nRSOURCE  EQU   8\nROPDK    EQU   9\nROPTK    EQU   10\nRBASE    EQU   12\nRWRKA    EQU   13\n         EJECT\n         USING *,RBASE\n         USING WORKAREA,RWRKA\n         SPACE 2\n*                                  CALCULATE AND RESERVE SPACE NEEDED\n         LA    WRK1,INERR1              PROVIDE DIRECTORY\n         ST    WRK1,ERET                                  RETURN ADDR\n         SR    RLTOTAR,RLTOTAR          INITIATE LENGTH OF RES AREA\n         L     RLIBUF1,SRCE1S           GET LENGTH OF 1ST SOURCE BUFFER\n         TM    HCOMPMOD+2,X'40'         IS SOURCE PRG IN CORE\n         BO    IN16                     YES\n         LR    RLTOTAR,RLIBUF1          NO, OBTAIN A SECOND BUFFER\nIN16     TM    HCOMPMOD+2,X'20'         ANY OPTAB\n         BO    IN17                     NO\n         L     RLOPBUF1,OPTABS           OBTAIN LENGTH OF OPTAB-BUFFER\n         AR    RLTOTAR,RLOPBUF1         ADD TO TOTAL LENGTH\n         AR    RLTOTAR,RLOPBUF1         ADD LENGTH OF 2ND OPTAB-BUFFER\nIN17     L     RLOPDST,OOSTACKS         OBTAIN LENGTH OF OPERATOR STACK\n         AR    RLTOTAR,RLOPDST          ADD TO TOTAL LENGTH\n         LH    RLLAT,LLAT               OBTAIN LENGTH OF LAT\n         AR    RLTOTAR,RLLAT            ADD TO TOTAL LENGTH\n         ST    RLTOTAR,FREEMSIZ         STORE LENGTH OF RESERVED AREA\n         SPACE\n         GETMAIN R,LV=(2)               RESERVE AREA\n         SPACE\n         LA    WRK4,INERR2              PROVIDE NEW\n         ST    WRK4,ERET                            DIR RETURN ADDRESS\n         ST    RESAR,FREEMADR           STORE ADDRESS OF RESERVED AREA\n         SPACE 2\n*                                  LOAD REGISTERS FOR REST OF PHASE\n         L     RSOURCE,IBUF1            SET 1ST BUFFER\n         ST    RSOURCE,SOURCEB                         AS CURRENT\n         LR    ROPTK,RESAR              GET CORRECT REG FOR OPT ST ADR\n         SPACE\n         TM    HCOMPMOD+2,X'40'         IS SOURCE PROGRAM IN CORE\n         BO    IN18                     YES\n         SPACE\n         ST    ROPTK,IBUF2              NO, STORE ADDR OF 2ND INPUT BUF\n         ST    ROPTK,RSRCB              SECOND BUFFER = READ BUFFER\n         LA    ROPTK,0(RLIBUF1,ROPTK)   GET ADDR OF NEXT RESERVED AREA\n         SPACE\nIN18     TM    HCOMPMOD+2,X'20'         ANY OPTAB\n         BO    IN19                     NO\n         SPACE\n         ST    ROPTK,OPBUF1             YES, STORE ADDR OF 1ST OPTBUF\n         ST    ROPTK,AOPTABE            ADDRESS FIRST OPTAB ENTRY\n         ST    ROPTK,OPBUFB             1ST OPTBUF = CURRENT\n         LA    ROPTK,0(RLOPBUF1,ROPTK)  GET ADDR OF 2ND OPTABBUFFER\n         ST    ROPTK,OPBUF2             STORE        -''-\n         ST    ROPTK,ROPTB              2ND OPTBUF = READ BUFFER\n         LA    ROPTK,0(RLOPBUF1,ROPTK)  GET ADDR OF OPERATOR STACK\n         SPACE\nIN19     LA    ROPDK,0(RLOPDST,ROPTK)   GET ADDR OF LAT\n         ST    ROPDK,LATAB              STORE IT\n         BCTR  ROPDK,0                  GET ADDR OF OPERAND STACK\n         L     RPRPT,PRPT               PRPOINTER\n         SPACE 2\n*                                  INITILIZE WORKAREA FOR REST OF PHASE\n         TM    HCOMPMOD+2,NOPT          ANY OPTAB\n         BZ    *+12                     YES\n         LA    WRK3,MAXFSN              NO, STORE ADDRESS OF\n         ST    WRK3,AOPTABE                                  MAX FS NR\n         LA    WRK3,SUTABC-9            INITIATE LAST USED\n         ST    WRK3,SUTABCA                                SUTAB ENTRY\n         SPACE\n         LA    WRK3,IOTAB               COMPUTE\n         LA    WRK2,GPBN                        LENGTH OF AREA\n         SR    WRK2,WRK3                                       WITH 0\n         STC   WRK2,*+9                 STORE IN MOVE-INSTR\n         MVI   0(WRK3),X'00'            MOVE\n         MVC   1(0,WRK3),0(WRK3)             ZEROES\n         SPACE\n         MVI   MAXFSN,X'FF'             INSERT MAX FS NUMBER\n         MVI   CII+1,X'07'\n         MVI   CIR+1,X'06'\n         MVI   CLEARDIS,X'F0'           INSERT\n         MVI   ONEENTRY+1,X'08'                VALUES FOR\n         MVC   MAXOVERF(2),LONG                           LONG PREC\n         TM    HCOMPMOD,X'02'           TEST PRECISION\n         BO    IN3                      LONG\n         MVI   ONEENTRY+1,X'04'         SHORT,\n         MVI   PRECMASK,X'10'                  CHANGE\n         MVC   MAXOVERF(2),SHORT                      VALUES\nIN3      MVI   GPBN+1,X'FF'\n         MVC   SEMCNT(2),ZEROHW         INITIATE SEMICOLON COUNTER\n         SPACE 2\n*                                  INITILIZE OPERATOR STACK\n         MVI   0(ROPTK),X'25'           INSERT OPERATOR ALPHA\n         SPACE 2\n*                                  INITIALIZATION OF LABEL ADDRESS TAB\n         L     WRK1,LATAB\n         MVI   0(WRK1),X'00'            ZERO BEGIN\n         MVC   1(LATBEG-1,WRK1),0(WRK1)            OF LAT\n         LA    1,15                *    ZERO\n         LA    11,79(0,WRK1)       *         REST\nTSTZER   MVC   1(256,11),0(11)     *              OF\n         LA    11,256(0,11)        *                   LAT\n         BCT   1,TSTZER            *                       FOR\n         MVC   1(176,11),0(11)     *                            TEST\n         LA    WRK2,LATNR\nIN4      MVI   0(WRK1),X'80'            TURN ON FIRST BIT IN LAT-ENTRY\n         LA    WRK1,4(0,WRK1)           STEP ADDRESS\n         BCT   WRK2,IN4                 HANDLE NEXT ENTRY IF ANY\n         SPACE 2\n*                                  START READ-IN OF SOURCE PRG, IF NEC\n         TM    HCOMPMOD+2,X'40'         IS SOURCE PRG IN CORE\n         BZ    IN6                      NO, NO BRANCHES WILL BE TAKEN\n         OI    IN6+1,X'F0'              YES, ALL\n         OI    IN9+1,X'F0'                       BRANCHES WILL\n         OI    IN14+1,X'F0'                                    BE TAKEN\n         SPACE\nIN6      BC    0,IN22                   BRANCH IF SOURCE PRG IN CORE\n         L     WRK2,UT2ADD              LOAD ADDRESS OF DCB\n         READ  SRC1,SF,(3),(8)          READ 1ST SOURCE RECORD\nIN22     BCTR  RSOURCE,0                INITIATE SOURCE POINTER\n         SPACE 2\n*                                  CONSTRUCT PBTAB3\n         LA    WRK1,PBTAB2              START ADDR OF PBTAB2 IN WORKAR\n         LA    WRK4,PBTAB3              START ADDR OF PBTAB3 IN WORKAR\n         LH    WRK3,PBN                 GET NR OF PRG BLOCKS\n         LA    WRK3,1(0,WRK3)\nIN8      MVC   0(2,WRK4),0(WRK1)        MOVE ONE PBTAB2 ENTRY\n         MVC   2(2,WRK4),ZEROHW         ZERO REST OF ENTRY\n         LA    WRK1,2(0,WRK1)           STEP\n         LA    WRK4,4(0,WRK4)                ADDRESSES\n         BCT   WRK3,IN8                 MOVE NEXT IF NOT ALL MOVED\n         SPACE 2\nIN9      EQU   *                   CHECK READ OF 1ST SOURCE REC IF NEC\n         BC    0,IN10                   BRANCH IF SOURCE PRG IN CORE\n         CHECK SRC1\n         SPACE\nIN10     LA    WRK1,1                   INITIATE RECORD COUNT\n         STC   WRK1,NUMBBL              STORE IT\n         SPACE\n         SPACE\n*                                  START READING OF OPTAB\n         TM    HCOMPMOD+2,X'20'         IS OPTAB EMPTY\n         BO    IN14                     YES, BYPASS READING\n         SPACE\n         LA    WRK1,IN14                GIVE ADDR OF\n         ST    WRK1,EODUT3                           EOD RTN TO DIR\n         L     WRK1,OPBUF1              GET ADDRESS OF 1ST BUFFER\n         L     WRK3,UT3ADD              GET ADDRESS OF DCB\n         SPACE\nIN12     READ  OPTB1,SF,(4),(2),'S'     READ 1ST RECORD\n         SPACE\n         CHECK OPTB1\n         SPACE\nIN13     BC    0,IN14                   BRANCH AFTER 2ND CHECK\n         L     WRK1,OPBUF2              GET ADDRESS OF 2ND BUFFER\n         OI    IN13+1,X'F0'\n         B     IN12                     READ 2ND RECORD\n         SPACE\n         SPACE\nIN14     EQU   *                   READ 2ND SOURCE RECORD IF ANY\n         BC    0,IN15                   BRANCH IF SOURCE PRG IN CORE\n         LA    WRK1,IN15                GIVE ADDR OF\n         ST    WRK1,EODUT2                           EOD RTN TO DIR\n         L     WRK1,IBUF2               GET ADDRESS OF 2ND BUFFER\n         READ  SRC2,SF,(3),(2)          READ 2ND RECORD\n         SPACE\n         CHECK SRC2\n         SPACE\n         SPACE\nIN15     EQU   *                   GO TO NEXT LOAD MODULE\n         NI    HCOMPMOD+2,X'F7'         SET OFF NOSC SWITCH\n         XCTL  EP=IEX50000\n         SPACE\n         SPACE\nINERR1   EQU   *                   DIRECTORY RETURN BEFORE GETMAIN\n         XCTL  EP=IEX51ER2\n         SPACE\n         SPACE\nINERR2   EQU   *                   DIRECTORY RETURN AFTER GETMAIN\n         XCTL  EP=IEX51ER1\n         EJECT\n* CONSTANTS\n         SPACE\nLLAT     DC    H'4096'                  LENGTH OF LABEL ADDRESS TABLE\nSHORT    DC    H'4092'                  TO CHECK OBJ TIME STACK OVFLOW\nLONG     DC    H'4088'                               -''-\n         EJECT\nWORKAREA DSECT\n         COPY  WORKAREA\n         ORG   DCBUT1\nFSNMAX   DS    H\nLVCOUNT  DS    H\nSUCOUNT  DS    H\nZLEVEN   DS    F\nZSUTEN   DS    F\nZCOSTA   DS    255H                     SORT COUNT TABLE\nZADSTA   DS    255H                     SORT ADDRESS TABLE\nTSTART   DS    F                        START OF TABLE AREA\nSAVETAB  DS    F                        AREA TO SAVE TABLE END\nZSTAD    DS    F                        START ADDRESS OF UNSORTED TABLE\nZSORTSTA DS    F                        START ADDRESS OF SORTED TABLE\nZSUDAD   DS    F                        START OF SORTED SUTAB\nZSUDEN   DS    F                        END ADDRESS OF SORTED SUTAB\nZLESTA   DS    F                        START ADDRESS OF SORTED LUTAB\nZOTAFILL DS    F                        OPTAB WORK-BUFFER ADDRESS\nZOTAWRI  DS    F                        OPTAB WRITE-BUFFER ADDRESS\nZOTMAX   DS    F                        END OF OUTPUT BUFFER IN USE\nTABSIZE  DS    F                        SIZE OF TABLE AREA\n         EJECT\n*\n* AREA USED BY COMPILATION PHASE\n*\n         SPACE\n         ORG   DCBUT1\n         SPACE\nRETADR   DS    17F                      SAVE AREA\nPLACE14  DS    F                           -''-\nRUTI     DS    9F                       GPR CONTROL\nRUTR     DS    4F                       FLREG CONTROL\nGPROLN   DS    H                        LABEL NR OF OBJ PRG ENTRY POINT\nKONSUM   DS    H                        WORKPLACE\nWORKPL   DS    F                        WORKPLACE\nIBUF1    EQU   SRCE1ADD                 ADDR OF FIRST SOURCE BUFFER\nIBUF2    DS    A                          -''  SECOND    -''-\nSOURCEB  DS    A                          -''  CURRENT   -''-\nRSRCB    DS    A                          -''  READ      -''-\nOPBUF1   DS    A                        ADDR OF FIRST OPTAB BUFFER\nOPBUF2   DS    A                          -''-  SECOND    -''-\nOPBUFB   DS    A                          -''-  CURRENT   -''-\nROPTB    DS    A                          -''-  READ      -''-\nAOPTABE  DS    A                        ADDRESS OF CURRENT OPTAB ENTRY\nLATAB    DS    A                        ADDR OF LABEL ADDRESS TABLE\nAPBTAB4  EQU   LATAB                    ADDRESS OF PBTAB4\nSUTABCA  DS    A                        ADDR OF LAST USED SUTAB ENTRY\nSTRETURN DS    F                        RETURN ADDRESS\nFREEMADR DS    A                       ADR FOR FREEMAIN IN 50000\nFREEMSIZ DS    F                        SIZE          -''-\n         SPACE\nPBTAB3   DS    1024C                    PROGRAM BLOCK TABLE, 3RD VERS\n         SPACE\nIOTAB    DC    18X'00'                  LIST OF DATA SETS\nCII      DC    H'0'                     REGISTER CONTROL\nCIR      DC    H'0'                          -''-\nRII      DC    H'0'                          -''-\nRIR      DC    H'0'                          -''-\nOPDPBN   DC    H'0'                     PROGRAM BLOCK NR (BYTE 2 OF OPD\nOPDADR   DC    H'0'                     BYTES 3 AND 4 OF OPERAND\nOPDLN    DC    H'0'                     LABEL NUMBER TIMES FOUR\nSCSC     EQU   SEMCNT                  SEMICOLON COUNTER\nZEROHW   DC    H'0'                     ZEROES\nCFSN     DC    X'00'                    CURRENT FS NUMBER\nMAXFSN   DC    X'FF'                    MAX FS NUMBER\nCLEARDIS DC    X'F000'                  FOR CLEARING OF DISPLACEM PART\nONEENTRY DC    H'4'                     SHORT, FOR INCR OF OT STACK PTR\n         ORG   ONEENTRY\n         DC    H'8'                     LONG            -''-\nPRECMASK DC    X'10'                    SHORT, TO MODIFY INSTRUCTIONS\n         ORG   PRECMASK\n         DC    X'00'                    LONG            -''-\nNUMBBL   DC    X'00'                    RECORD COUNTER\n         DS    H\nSPBNST   DC    H'0'                     CURRENT PBN\n         DS    H                                    AND DISPLACEMENT\nGPBN     DC    H'255'                   GLOBAL DSA CONTROL\nMAXOVERF DC    H'4092'                  SHORT, TO CHECK OT STACK OVERFL\n         ORG   MAXOVERF\n         DC    H'4088'                  LONG            -''-\nHALFW    DS    H                        WORKPLACE\nUSPEI2   DS    H                        FOR ARRAY DECLA-\nUSPEI4   DS    H                                        RATION HANDLING\nWPLACE   DS    H                        FOR INSTRUCTION GENERATION\nXPLACE   DS    H\nYPLACE   DS    H\nUPLACE   DS    H\nVPLACE   DS    C                                    -''-\nSTRDNAME DS    5C                       TO STORE OPERAND\nCBVTAB   DS    48C                      CALLED-BY-VALUE TABLE\nSUTABC   DS    768C                     FOR SUBSCRIPT OPTIMIZATION\n         ORG   SUTABC\nDSTAB    DS    608C                     DATA SET TABLE\n         END   START\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IEX50": {"ttr": 5383, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x98\\x01/\\x00\\x98\\x01/\\x16!\\x07\\xab\\x07\\xab\\x00\\x00\\xd6\\xf3\\xf6\\xf0`\\xf2\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1998-01-12T00:00:00", "modifydate": "1998-01-12T16:21:00", "lines": 1963, "newlines": 1963, "modlines": 0, "user": "O360-20"}, "text": " TITLE 'IEX50, COMPILATION PHASE'\n*                                                                     *\n*STATUS  CHANGE LEVEL 000.                                            *\n*                                                                     *\n*FUNCTION/OPERATION  THIS MODULE PERFORMS THE REAL TRANSLATION OF THE *\n*   SOURCE PROGRAM INTO SYSTEM/360 INSTRUCTIONS. THE SOURCE PROGRAM   *\n*   IS AT MODIFICATION LEVEL 2 AND CONSISTS OF A SEQUENCE OF ONE-BYTE *\n*   OPERATORS AND FIVE-BYTE OPERANDS, WHICH IS SCANNED SEQUENTIALLY.  *\n*   THE STATUS OF RECOGNITION OF THE SOURCE PROGRAM IS DESCRIBED BY   *\n*   1. A SEQUENCE OF CONTEXTS (SEE BELOW)                             *\n*   2. A SEQUENCE OF STACKED OPERATORS (THE OPERATOR STACK)           *\n*   THE ACTION OF THE COMPILER IS DETERMINED BY THE OPERATOR PAIR     *\n*   STACK-SOURCE OPERATOR AND THE CURRENT CONTEXT. THE OPERATOR PAIR  *\n*   DETERMINES AN ELEMENT IN A DECISION MATRIX, WHICH IS DETERMINED   *\n*   BY THE CONTEXT. THE MATRIXELEMENTS REPRESENT ADDRESSES OF THE     *\n*   COMPILER PROGRAMS, WHICH PERFORM THE ACTIONS REQUESTED BY ALL     *\n*   POSSIBLE OPERATOR PAIRS.                                          *\n*   THERE ARE THREE CONTEXTS, PROGRAM, STATEMENT, AND EXPRESSION CON- *\n*   TEXT, AND THE CURRENT CONTEXT IS INDICATED BY A REGISTER. SWITCH- *\n*   ING FROM ONE CONTEXT TO ANOTHER IS IN MOST CASES DETERMINED BY    *\n*   THE STACK-SOURCE OPERATOR PAIR, I.E., THE COMPILER PROGRAM ACTI-  *\n*   VATED JUST PERFORMS THE CHANGE OF CONTEXT, BUT IN A FEW CASES THE *\n*   SOURCE OPERATOR ALONE DETERMINES THE NEW CONTEXT. IN THIS LATTER  *\n*   CASE THE OPERATOR IS STACKED TOGETHER WITH A CONTEXT OPERATOR,    *\n*   INDICATING THE PRECEDING CONTEXT.                                 *\n*                                                                     *\n*   BESIDES THE COMPILER PROGRAMS THERE ARE OTHER ROUTINES PROVIDING  *\n*   DIFFERENT SERVICES. THE MOST IMPORTANT ARE (THOSE MARKED WITH *   *\n*   ARE USED AS SUBROUTINES BY THE COMPILER PROGRAMS)                 *\n*   SNOT       SCAN TO NEXT OPERATOR IN SOURCE PROGRAM                *\n*   COMP       CHOOSE COMPILER PROGRAM AND BRANCH                     *\n*   JBUFFER    READ A NEW SOURCE PROGRAM RECORD                       *\n*   NXTOPT    *GET NEXT ENTRY OF OPTAB                                *\n*   SERR      *GENERATE AN ERROR PATTERN                              *\n*   CPEND      NORMAL TERMINATION                                     *\n*   CPERRI     ABNORMAL TERMINATION                                   *\n*   GENERATE  *GENERATE TXT AND RLD-RECORDS                           *\n*                                                                     *\n*   A COMPILER PROGRAM IS ALWAYS FOLLOWED BY SNOT OR COMP OR A BRANCH *\n*   TO ANOTHER COMPILER PROGRAM.                                      *\n*                                                                     *\n*   THE MODULE CONSISTS OF SEVEN CONTROL SECTIONS                     *\n*   IEX50000 - INITIALIZATION AND SUBROUTINES                         *\n*   IEX50001 - DECICION MATRIXES                                      *\n*   IEX50002 - COMPILER PROGRAMS HANDLING FOR-STATEMENTS AND SUBSCRIPT*\n*              OPTIMIZATION                                           *\n*   IEX50003 - COMPILER PROGRAMS HANDLING BEGIN AND END OF COMPOUND   *\n*              STATEMENTS AND BLOCKS, PROCEDURE DECLARATIONS, ARRAY   *\n*              DECLARATIONS, SWITCH DECLARATIONS, GOTO STATEMENTS,    *\n*              SUBSCRIPTED VARIABLES AND SWITCH DESIGNATORS,          *\n*              SEMICOLON COUNTER.                                     *\n*   IEX50004 - COMPILER PROGRAMS HANDLING ASSIGNMENTS,                *\n*              PROCEDURE CALLS, STANDARD PROCEDURE CALLS.             *\n*   IEX50005 - COMPILER PROGRAMS HANDLING ERRONEOUS CASES, BOOLEAN    *\n*              OPERATIONS, ARITHMETIC MINUS, IF, THEN, ELSE.          *\n*   IEX50006 - COMPILER PROGRAM HANDLING ARITHMETICAL OPERATIONS.     *\n*                                                                     *\n*ENTRY POINT                                                          *\n*        IEX50000 - COMPILATION PHASE   XCTL EP=IEX50.                *\n*   THE MODULE IS ENTERED FROM IEX40                                  *\n*                                                                     *\n*INPUT  THE SOURCE PROGRAM IS READ FROM SYSUT2.                       *\n*   OPTAB IS READ FROM SYSUT3.                                        *\n*                                                                     *\n*OUTPUT  THE MAIN PART OF THE OBJECT MODULE IS PUT OUT ON SYSLIN AND/ *\n*   OR SYSPUNCH IF THE OPTIONS 'LOAD' AND/OR 'DECK' ARE SPECIFIED.    *\n*                                                                     *\n*EXTERNAL ROUTINES  N/A                                               *\n*                                                                     *\n*EXIT-NORMAL  IF NO TERMINATING ERROR HAS OCCURRED, CONTROL IS GIVEN  *\n*   TO THE TERMINATING MODULE BY MEANS OF  XCTL EP=IEX51000.          *\n*                                                                     *\n*EXIT-ERROR  IF A TERMINATING ERROR HAS OCCURED, CONTROL IS GIVEN TO  *\n*   THE TERMINATING MODULE BY MEANS OF  XCTL EP=IEX51ER1.             *\n*                                                                     *\n*TABLES/WORKAREAS                                                     *\n*   SCPTAB   - COMPILER PROGRAM ADDRESS TABLE USED BY ROUTINE COMP    *\n*   TXTT     - INFORMATION FOR TXT-RECORDS USED BY ROUTINE GENERATE   *\n*   RLDT     - INFORMATION FOR RLD-RECORDS USED BY ROUTINE GENERATE   *\n*   DECAREA  - DECISION MATRIXES USED BY ROUTINE COMP                 *\n*                                                                     *\n*   THE PART OF COMMON WORKAREA STARTING AT DCBUT1 IS INITIALIZED BY  *\n*   THE PRECEDING LOAD MODULE AND USED BY THIS AND THE NEXT LOAD      *\n*   MODULE.                                                           *\n*                                                                     *\n*ATTRIBUTES  NONE.                                                    *\n*                                                                     *\n*CHARACTER CODE DEPENDENCE  THE OPERATION OF THE ROUTINE GENERATE     *\n*   DEPENDS UPON AN INTERNAL REPRESENTATION OF THE EXTERNAL CHARACTER *\n*   SET WHICH IS EQUIVALENT TO THE ONE USED AT ASSEMBLY TIME.         *\n*                                                                     *\n*   THIS MODULE IS ONLY INTENDED TO BE EXECUTED IN CONNECTION         *\n*   WITH THE OTHER MODULES OF THE ALGOL COMPILER. IN PARTICULAR IT    *\n*   REQUIRES THE COMMON WORKAREA.                                     *\n*\n         EJECT\nIEX50000 CSECT\n* RELEASE 19 CHANGES\n* 090620-090740                                                  A28233\n*C090200,090250                                                  A32978\n         SPACE\n         SPACE\n*        COMPILETIME REGISTER DEFINITIONS\n         SPACE\nR0       EQU   0                   *\nR1       EQU   1                   *\nR2       EQU   2                   *\nR3       EQU   3                   *   VARIABLE USE\nR4       EQU   4                   *\nWRK      EQU   4                   *\nSBR      EQU   5                   ADDRESSES SUBROUTINE POOL\nPRPOINT  EQU   6                   CONTAINS REL ADDRESS IN OBJ PROGRAM\nP        EQU   7                   CONTAINS DISP IN OBJECT TIME STACK\nSOURCE   EQU   8                   SOURCE PROGRAM POINTER\nOPDK     EQU   9                   OPERAND STACK POINTER\nOPTK     EQU   10                  OPERATOR STACK POINTER\nRCCT     EQU   11                  INDICATES CURRENT CONTEXT\nCCT      EQU   11                             - '' -\nBASE     EQU   12                  CONTAINS BASE ADDR OF COMP PROGRAMS\nWAREG    EQU   13                  ADDRESSES COMMON WORKAREA\nGREG     EQU   14                   ARRAY IDENTIFIER COUNT\nR14      EQU   14                  VARIABLE\nR15      EQU   15                           USE\n         SPACE\n*        OBJECTTIME REGISTER DEFINITIONS\n         SPACE\nFPR0     EQU   0                   *\nFPR2     EQU   2                   *\nGPRA     EQU   3                   *   VARIABLE USE\nGPRB     EQU   5                   *\nGPRC     EQU   6                   *\nADR      EQU   8                   FOR TRANSFER OF ADDRESSES\nSTH      EQU   14                  FOR TEMPORARY USE\nCDSA     EQU   10                  ADDRESSES CURRENT DSA\nGDSA     EQU   9                   ADDRESSES GLOBAL DSA\nPBT      EQU   11                  ADDRESSES PROGRAM BLOCK TABLE\nLAT      EQU   12                  ADDRESSES LABEL ADDRESS TABLE\nFSA      EQU   13                  ADDRESSES FIXED STORAGE AREA\nENTRY    EQU   15                  ENTRY POINT OF LIBRARY SUBROUTINES\nBRR      EQU   15                  LINK REGISTER\n         EJECT\n*\n* INITIALIZATION    THIS ROUTINE PERFORMS THE REMAINING INITIALIZATION,\n*                   THE MAIN PART IS MADE IN IEX40001\n*\n         USING *,R15                    USE ENTRY POINT REG AS BASE\n         LA    SBR,SNOT                 LOAD BASE REG\n         USING SNOT,SBR                               FOR SNOT\n         SPACE\n         LA    WRK,CPERR1               PROVIDE DIRECTORY\n         ST    WRK,ERET(WAREG)          RETURN ADDRESS\n         SPACE\n         L     RCCT,DECAADD(SBR)        LOAD ADDR OF CCT\n         LA    WRK,JB3                  PROVIDE\n         ST    WRK,EODUT2(0,WAREG)              EOD ADDR\n         LA    WRK,NX4                                   FOR UT2\n         ST    WRK,EODUT3(0,WAREG)                               & UT3\n         DROP  R15\n         CNOP  0,8\n         TITLE 'IEX50, COMPILATION PHASE, SUBROUTINE POOL'\n*  SUBROUTINE POOL\n         SPACE\nSBRPOOL  EQU   *                   START OF SUBROUTINE POOL\nSNOT     EQU   SBRPOOL\nSBRSTRT  EQU   SNOT                     SUBROUTINE POOL START\n         SPACE 3\n* SCAN SOURCE INPUT TO NEXT OPERATOR\n         SPACE\nABB1     NI    HCOMPMOD(WAREG),X'FE'    OPERAND FLAG OFF\nABC1     CLI   1(SOURCE),X'2F'          TEST     SOURCE\n         BL    ABD3                     OPERATOR\n         BH    ABD1                     OPERAND\n         BAL   R4,JBUFFCH               BUFFERCHANGE\n         B     ABC1                     CONTINUE\nABD3     LA    SOURCE,1(0,SOURCE)       SOURCE REG INCREASE\n         B     ACB1                     CHOOSE CP\nABD1     OI    HCOMPMOD(WAREG),X'01'    OPERAND FLAG ON\n         SH    OPDK,CON5(0,SBR)         SOURCE OPERAND\n         CR    OPTK,OPDK                * TO\n         BNL   STERMERR                 * STACK\n         MVC   0(5,OPDK),1(SOURCE)      *\n         LA    SOURCE,5(0,SOURCE)       SOURCE REG INCREASE\n         B     ABC1                     CONTINUE\n         SPACE\n* AN OPERAND IS NOT ALLOWED IN SOURCE\n         SPACE\nSPEC     EQU   *-ABB1\nSNOTSP    EQU   SPEC\nABC3     CLI   1(SOURCE),X'2F'          SPECIAL TEST\n         BL    ABD3                     OPERATOR\n         BH    ABD5                     OPERAND\n         BAL   R4,JBUFFCH               BUFFER CHANGE\n         B     ABC3\nABD5     LA    SOURCE,6(SOURCE)              SOURCE REG INCREASE   0220\n         BAL   R4,SERR3(0,SBR)                                     0220\nERROR    DC    H'191'                                              0220\n         BCTR  SOURCE,0                      SOURCE REG MINUS ONE  0220\n         B     ABC3\n         SPACE\n* CHOOSE CP PROGRAM\n         SPACE\nCOMP     EQU   *-ABB1\nACB1     SR    R1,R1\n         LR    R2,R1\n         IC    R1,0(0,SOURCE)           FETCH SOURCE OPERATOR\n         IC    R1,0(R1,CCT)             COLUMN VECTOR\n         IC    R2,0(0,OPTK)             FETCH STACK OPERATOR\n         IC    R2,50(R2,CCT)            ROW VECTOR\n         AR    R1,R2\n         IC    R1,100(R1,CCT)\n         SLL   R1,2(0)                  COMPILER PROGRAM FROM MATRIX\n         L     BASE,SCPTAB(R1)          FIND BASE ADDRESS\n         BR    BASE                     BRANCH TO COMPILER PROGRAM\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*                                                                     *\n*        JBUFFER PERFORMS CHANGE OF INPUT BUFFER\n*                                                                     *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n* CALL   BAL   RETURN,JBUFFCH           ( FROM SNOT )                 *\n*        BAL   RETURN,JBUFFER(0,SBR)    ( FROM COMPILER PROGRAMS )    *\n         SPACE 2\n* REGISTER DEFINITIONS\n         SPACE\nRDCB     EQU   3                        ADDRESS OF DCB FOR UT2\nRCUR     EQU   2                        ADDRESS OF CURRENT BUFFER\nRREAD    EQU   SOURCE                   ADDRESS OF CURRENT INPUT BUFFER\nRWRK      EQU   RDCB                     WORKREG\n         SPACE 2\nJBUFFER  EQU   *-ABB1              CHANGE OF INPUT BUFFER\nJBUFFCH  L     RDCB,UT2ADD(0,WAREG)     GET DCB ADDRESS\n         L     RCUR,SOURCEB(0,WAREG)    GET ADDRESS OF CURRENT BUFFER\n         SPACE\nJB1      BC    15,JB2                   NO CHECK FIRST TIME\n         SPACE\n         CHECK SRCECO                   CHECK PREVIOUS READ\n         SPACE\nJB2      READ  SRCECO,SF,(RDCB),(RCUR)\n         SPACE\nJB3      L     RREAD,RSRCB(0,WAREG)     GET ADDRESS OF OLD READ BUFFER\n         ST    RCUR,RSRCB(0,WAREG)      CHANGE\n         ST    RREAD,SOURCEB(0,WAREG)          ADDRESSES\n         BCTR  RREAD,0                  GET START ADDRESS - 1\n         IC    RWRK,NUMBBL(0,WAREG)     STEP\n         LA    RWRK,1(0,RWRK)                RECORD\n         STC   RWRK,NUMBBL(0,WAREG)                 COUNTER\n         SPACE\n         MVI   JB1+1,X'00'              CHANGE BRANCH CONDITION\n         BR    RETURN                   RETURN\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*                                                                     *\n*        NXTOPT ACQUIRES NEXT ENTRY OF OPTAB\n*                                                                     *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n* CALL   BAL   RETURN,NXTOPT(0,SBR)                                   *\n         SPACE\n* REGISTER DEFINITIONS\n         SPACE\nRREL     EQU   3\n         SPACE 2\nNXTOPT   EQU   *-ABB1              GET NEXT ENTRY OF OPTAB\n         L     RCUR,OPBUFB(0,WAREG)     GET ADDR OF CURRENT BUFFER\n         L     RREL,OPREL               GET REL ADDR\n         LA    RREL,14(0,RREL)                       OF NEW ENTRY\n         C     RREL,OPTABS(0,WAREG)     IS ANEW BUFFER REQUIRED\n         BNL   NX1                      YES\n         SPACE\n         AR    RCUR,RREL                NO, STORE\n         ST    RCUR,AOPTABE(WAREG)      ADDRESS OF\n         B     NX3                                        NEW ENTRY\n         SPACE\nNX1      BC    15,NX2                   NO CHECK FIRST TIME\n         CHECK OPTCO                    CHECK PREVIOUS READ\n         SPACE\nNX2      L     RDCB,UT3ADD(0,WAREG)     GET DCB ADDRESS\n         READ  OPTCO,SF,(RDCB),(RCUR),'S'    READ OPTAB RECORD\n         SPACE\n         MVI   NX1+1,X'00'              CHANGE BRANCH CONDITION\nNX4      L     R1,ROPTB(0,WAREG)        GET ADDR OF OLD READ BUFFER\n         ST    R1,OPBUFB(0,WAREG)       CHANGE\n         ST    RCUR,ROPTB(0,WAREG)             ADDRESSES\n         ST    R1,AOPTABE(WAREG)        STORE\n         SR    RREL,RREL                      ADDRESSES OF\nNX3      ST    RREL,OPREL                                  NEW ENTRY\n         BR    RETURN                   RETURN\n         SPACE 2\nOPREL    DC    F'0'                     REL ADDRESS IN CURRENT BUFFER\n*  CONSTANTS LOCATED IN SUBROUTINE POOL\n         SPACE\nCON2     EQU   *-ABB1\n         DC    H'2'\nCON4     EQU   *-ABB1\n         DC    H'4'\nCON5     EQU   *-ABB1\n         DC    H'5'\nCON8     EQU   *-ABB1\n         DC    H'8'\nCON9     EQU   *-SBRPOOL\n         DC    H'9'\nCON10    EQU   *-ABB1\n         DC    H'10'\nCON15    EQU   *-ABB1\n         DC    H'15'\nCON20    EQU   *-ABB1\n         DC    H'20'\nCON290   EQU   *-ABB1\n         DC    H'290'\nCON324   EQU   *-ABB1\n         DC    H'324'\nCON614   EQU   *-ABB1\n         DC    H'614'\nAPI      EQU   *-ABB1                   ALL PURPOSE IDENTIFIER\n         DC    X'91FF01000000'\n         DS    0F\nTYPETEST EQU   *-ABB1                   TO EXTRACT TYPE BITS\n         DC    F'3'\nSWVAL    EQU   *-ABB1                   SWITCH FOR VALUE\n         DC    H'0'\nSWREL    EQU   *-SBRPOOL                SWITCH FOR VARIABLE USE\n         DC    H'0'\nGREGN    EQU   *-SBRPOOL                NUMBER OF ARRAY IDENTIFIERS-1\n         DC    H'0'\n         DS    0F\nDECAADD  EQU   *-SBRSTRT\n         DC    A(DECAREA)               ADDR OF DECISION AREA\nHEXFFF   EQU   *-SBRPOOL\n         DC    X'00000FFF'\nPRC      EQU   DECAADD                  ADDR OF PROG CONTEXT COL VECTOR\n         DC    A(ADRSTC)\nSTC      EQU   *-SBRPOOL-4              ADDR OF STATEM CONTEXT COL VECT\n         DC    A(ADREXC)\nEXC      EQU   *-SBRPOOL-4              ADDR OF EXPR CONTEXT COL VECTOR\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*                                                                     *\n*              COMPILER PROGRAM ADDRESS TABLE                         *\n*                                                                     *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         DS    0F\nDSCPTAB  EQU   *-ABB1\nSCPTAB   DC    A(CP0,CP1,CP84,CP3,CP4,CP84,CP6,CP7,CP8,CP84,CP84,CP84,CX\n               P12,CP84,CP84,CP84,CP16,CP17,CP18,CP19,CP20,CP21,CP22)\n         DC    A(CP23,CP24,CP25,CP26,CP27,CP28,CP29,CP30,CP31,CP84)\n         DC    A(CP33)\n         DC    A(CP34,CP84,CP36,CP84,CP38,CP84,CP40,CP41,CP84,CP43,CP84X\n               ,CP45,CP84,CP47,CP84,CP49,CP84,CP51,CP52,CP84,CP54)\n         DC    A(CP84,CP56,CP57,CP84,CP59,CP84,CP61,CP62,CP63,CP64,CP65X\n               )\n         DC    A(CP66,CP67,CP68,CP69,CP70,CP71,CP72,CP73,CP74,CP75,CP76X\n               ,CP77,CP78,CP79,CP80,CP81,CP84,CP83,CP84,CP85,CP86,CP87)\n         SPACE 3\n* LIST OF NOT EXISTING COMPILER PROGRAMS\n*\n*   CP2, CP5, CP9, CP10, CP11, CP13, CP14, CP15, CP32, CP35, CP37,\n*   CP39,\n*   CP42, CP44, CP46, CP48, CP50, CP53, CP55, CP58, CP60, CP82\n*\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*                                                                     *\n*        ERROR PATTERN GENERATION\n*                                                                     *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n* CALL   BAL   RETURN,SERRX(0,SBR)          X=1, 2, 3, 4, SP          *\n*        DC    H'N'                         N=MSG NR                  *\n         SPACE 2\n* REGISTER DEFINITIONS\n         SPACE\nSWORK    EQU   1\nSHERPIN  EQU   2\nSWITCH   EQU   3\nSRETURN  EQU   4\nRPOOL    EQU   15\n         SPACE 2\nSERR4    EQU   *-SBRPOOL           ENTRY BOTH OPERATORS\n         LA    SWITCH,2\n         LA    SHERPIN,6                GET LENGTH OF ENTRY\n         B     ER2\n         SPACE 2\nSERR2    EQU   *-SBRPOOL           ENTRY STACK OPERATOR\n         LA    SWITCH,3\n         B     ER1\n         SPACE 2\nSERR3    EQU   *-SBRPOOL           ENTRY SOURCE OPERATOR\n         LA    SWITCH,1\nER1      LA    SHERPIN,5                GET LENGTH OF ENTRY\nER2      L     RPOOL,NEXTERR(0,WAREG)   GET ADDRESS OF POOL ENTRY\n         STC   SHERPIN,0(0,RPOOL)       INSERT LENGTH OF ENTRY\n         SPACE\n         LA    SHERPIN,4                SET POINTER FOR OPERATOR INSERT\n         BCT   SWITCH,ER4               BRANCH IF STACK OR BOTH\n         SPACE\nER3      MVC   EP212+3(1),0(SOURCE)     GET SOURCE OP\n         OI    EP212+3,X'80'                          AND PUT A TAG\n         IC    SWORK,EP212+3            INSERT SOURCE OPERATOR\n         B     ER5\n         SPACE\nER4      IC    SWORK,0(0,OPTK)          FETCH STACK OPERATOR\nER5      STC   SWORK,0(SHERPIN,RPOOL)   INSERT OPERATOR\n         SPACE\n         LA    SHERPIN,1(0,SHERPIN)     INCREASE POINTER\n         BCT   SWITCH,ER6               BRANCH IF STACK OR SOURCE\n         B     ER3                      IF BOTH\n         SPACE 2\nSERRSP   EQU   *-SBRPOOL           SPECIAL ENTRY FOR MSG 214\n         L     RPOOL,NEXTERR(0,WAREG)   GET ADDR OF POOL ENTRY\n         LH    SWITCH,SPBNST(0,WAREG)   GET CURRENT PBN\n         CVD   SWITCH,ERDOUBLE          CONVERT\n         UNPK  ERDOUBLE(3),ERDOUBLE+6(2)        TO\n         MVZ   ERDOUBLE+2(1),ERDOUBLE              DECIMAL\n         MVC   4(3,RPOOL),ERDOUBLE      MOVE TO ERROR PATTERN\n         SPACE\n         LA    SHERPIN,7                GET LENGTH\n         STC   SHERPIN,0(0,RPOOL)                  OF ENTRY\n         B     ER6\n         SPACE\n         SPACE\nSERR1    EQU   *-SBRPOOL\n         L     RPOOL,NEXTERR(0,WAREG)   ENTRY NO OPERATOR\n         LA    SHERPIN,4                INSERT LENGTH\n         STC   SHERPIN,0(0,RPOOL)                     OF ENTRY\n         SPACE\nER6      MVC   2(2,RPOOL),SEMCNT(WAREG)     INSERT SEMICOLON COUNTER\n         IC    SWITCH,1(0,SRETURN)          INSERT\n         STC   SWITCH,1(0,RPOOL)                    ERROR NUMBER\n         SPACE\n         LA    RPOOL,0(SHERPIN,RPOOL)   UPDATE PTR\n         ST    RPOOL,NEXTERR(0,WAREG)              TO NEXT ENTRY\n         C     RPOOL,ENDPOOL(0,WAREG)   IS POOL FULL\n         BNH   ER7                      NO\n         SPACE\n         MVC   EP212+2(2),SEMCNT(WAREG)     YES, MOVE PATTERN\n         MVC   0(4,RPOOL),EP212                                FOR M212\n         LA    RPOOL,4(0,RPOOL)         UPDATE PTR TO\n         ST    RPOOL,NEXTERR(0,WAREG)                 NEXT ENTRY\n         B     CPERR1                   GO TO TERMINATION\n         SPACE\nER7      OI    HCOMPMOD(WAREG),X'80'    SET COMPILE MODE FALSE\n         LA    SWITCH,2                 STEP\n         AR    SRETURN,SWITCH                RETURN ADDRESS\n         BR    SRETURN                  RETURN TO CALLER\n         SPACE 2\nEP212    DC    X'04D40000'              ERROR PATTERN FOR MSG 212\nERDOUBLE DS    D\n         EJECT\n* OPERAND /OPERATOR STACK OVERFLOW    CALL IS B    STACKOFL(SBR)\n         SPACE\nSTACKOFL EQU   *-ABB1\nSTERMERR BAL   R4,SERR1(0,SBR)\n         DC    H'186'\n         B     CPERR1\n         SPACE 2\nCPEND    EQU   *                   NORMAL TERMINATION\n         TM    HCOMPMOD+2(WAREG),X'40'       SOURCE IN CORE        2846\n         BC    1,CPEND1                      YES                   2846\n         BAL   RETURN,JBUFFER(0,SBR)         NO   CHECK LAST READ  2846\nCPEND1   TM    NX1+1,X'F0'             OPTAB READ IN IEX50?      A32978\n         BC    1,CPEND2                NO                        A32978\n         BAL   RETURN,NXTOPT(0,SBR)          NO   CHECK LAST READ  2846\nCPEND2   XCTL  EP=IEX51000                   BRANCH TO NEXT MODULE 2846\n         SPACE\nCPERR1   EQU   *                   DIRECTORY RETURN ADDRESS\n         TM    JB1+1,X'F0'             READ TO INPUT BUFFERS     A28233\n         BC    1,CPERR10               NO                        A28233\n         CHECK SRCECO                  CHECK LAST READ           A28233\nCPERR10  TM    NX1+1,X'F0'             OPTAB READ                A28233\n         BC    1,CPERR11               NO                        A28233\n         CHECK OPTCO                   CHECK LAST READ           A28233\nCPERR11  EQU   *                                                 A28233\n         XCTL  EP=IEX51ER1              TO ERROR MSG EDITING AND TERM\n         EJECT\n         DS    0H\n         SPACE\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*                                                                     *\n*              CONVERTION INTEGER TO REAL                             *\n*                                                                     *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n* GENERATES CALL OF CONVERTION ROUTINE FROM INTEGER TO REAL AFTER\n* LOCATING THE OPERAND. RESERVES ONE OBJECT STACK TIME ENTRY SETS\n* RIR INTRODUCES OPERAND ADDRESSS INTO RUTR AND ADJUSTS OPERAND\n*                                                                     *\n* CALL   BAL   RETURN,TRINRE(0,SBR)\n*                                                                     *\n*                                                                     *\nTRINRE   EQU   *-SBRPOOL\n         ST    RETURN,RETADR(0,WAREG)       STORE RETURN ADDRESS\n         LA    RETURN,HQF21\n         BAL   R3,ROUTIN15(0,SBR)\n         SR   R1,R1\n         IC    R1,3(OPDK)                    PREPARE INSTRUCTION\n         SRL   R1,4\n         LA    R2,1\n         SLL   R2,0(R1)\n         STC   R2,HQD2+1\n         XI    HQD2+1,X'FF'\nHQD2     NI    RII+1(WAREG),X'00'\n         BAL   RETURN,ROUTINE8(0,SBR)        RELILO\n         MVN   HQG1+1(1),VPLACE(WAREG)\n         BAL   INFORM,GENTXT2(0,SBR)\nHQG1     LR    STH,0                         ***GENERATE***\nHQH1     TM    RIR+1(WAREG),X'01'            IS FPRO FREE\n         BZ    HQJ1                          BRANCH IF FREE\n         BAL   RETURN,ROUTIN14(0,SBR)        STFPR0\nHQJ1     TM    RII(WAREG),X'01'              IS ADR FREE\n         BZ    HQJ11\n         BAL   RETURN,ROUTIN10(0,SBR)\nHQJ11    BAL   INFORM,GENTXT4(0,SBR)         CALL CONVER. ROUTINE\n         BAL   ADR,CNVIRD(0,FSA)             ***GENERATE***\n         OI    0(OPDK),X'80'                ADJUST OPDK ENTRY\n         NI    0(OPDK),X'9F'\n         OI    1(OPDK),X'32'\n         NI    1(OPDK),X'FE'\n         MVC   2(1,OPDK),SPBNST+1(WAREG)\n         AH    P,ONEENTRY(0,WAREG)\n         STH   P,WORKPL(0,WAREG)\n         MVC   3(2,OPDK),WORKPL(WAREG)       INTRODUCE STACK ADD\n         ST    OPDK,RUTR(0,WAREG)           INTRODUCE OPDK ADD IN RUTR\n         OI    RIR+1(WAREG),X'01'            SET RIR TO ONE\n         MVI   CIR+1(WAREG),X'00'            CIR=0\n         L     RETURN,RETADR(0,WAREG)       LOAD RETURN ADDRESS\n         BR    RETURN\nHQF21    MVN   HQG2+1(1),VPLACE(WAREG)       PREPARE INSTRUCTION\n         MVC   HQG2+2(2),WPLACE(WAREG)\n         BAL   INFORM,GENTXT4(0,SBR)\nHQG2     L     STH,0(0,0)                    ***GENERATE***\n         B     HQH1\n         EJECT\n         DS    0H\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*                                                                     *\n*        CONVERSION REAL TO INTEGER                                   *\n*                                                                     *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n* CALL   BAL   RETURN,TRRE IN(SBR)\n*  AT OBJECT TIME THE INTEGER VALUE IS IN REGISTER STH AFTER CONVERSION\n         SPACE 2\n* BIT PATTERNS\n         SPACE\nOBJSTM   EQU   X'C0'                    OBJECT STACK MASK\nRADRFREM EQU   X'01'                    REG. ADR FREE MASK\nFPROOCM  EQU   X'01'                    FPR0 MASK\nOPDVALUM EQU   X'20'                    VALUE MASK\nOPDREGM  EQU   X'40'                    REGISTER MASK\nDISP     EQU   0\n         SPACE 2\nTRREIN   EQU   *-SBRSTRT           SUBROUTINE TO GENERATE CODE TO CALL\n*                                  REAL-INTEGER CONVERSION ROUTINE\n         ST    RETURN,SAVTRREI          SAVE RETURN ADDRESS\n         TM    RIR+1(WAREG),FPROOCM        FPR0 OCCUPIED\n         BZ    TRREIN1                  NO\n         C     OPDK,RUTR(0,WAREG)       IS OPERAND IN FRR0\n         BE    TRREIN8                  YES, REALEASE FPREG0\n         BAL   RETURN,ROUTIN14(0,SBR)     STORE FLOTING REGISTER 0\n         NI    RIR+1(WAREG),X'FE'\nTRREIN1  LA    R3,TRREIN4               ADDRESS IF VALUE IN REG\n         BAL   RETURN,ROUTIN15(SBR)     FIND DISPL    AND REG\nTRREIN2  MVN   TRREIN3+1(1),VPLACE(WAREG)     INSERT REGISTER AND\n         MVC   TRREIN3+2(2),WPLACE(WAREG)     DISPL. IN LOAD INSTR.\n         BAL   INFORM,GENTXTP4(0,SBR)     GENERATE A LOAD FPR0\nTRREIN3  LD    FPR0,DISP(0,0)           *INSTRUCTION,FLOATING POINT A.\nTRREIN6  TM    RII(WAREG),RADRFREM      REG. ADR FREE\n         BC    8,TRREIN9                YES\n         BAL   RETURN,ROUTIN10(0,SBR)   STORE ADR AND RETURN\n         NI    RII(WAREG),X'FE'\nTRREIN9  BAL   INFORM,GENTXT4(0,SBR)    GENERATE A CALL TO THE REAL-\n         BAL   ADR,CNVRDI(FSA,0)        *INTEGER CONVERSION ROUTINE\n         L     RETURN,SAVTRREI\n         BR    RETURN\nTRREIN4  MVN   TRREIN5+1(1),VPLACE(WAREG)\n         BAL   INFORM,GENTXTP2(0,SBR)     GENERATE A LOAD  FPR0\nTRREIN5  LDR   FPR0,0                   *INSTRUCTION,FLOATING POINT A.\nTRREIN8  BAL   RETURN,ROUTIN12(SBR)     RELEASE REG.CONTAINING OPD\n         B     TRREIN6\n         SPACE 2\nSAVTRREI DS    F                        SAVE AREA FOR RETURN\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*                                                                     *\n*        S U B R O U T I N E   G E N E R A T E                        *\n*                                                                     *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 3\n* GENERATE RLD-RECORDS\n* CALL   L     INFORM,                  VALUE OF PROGRAM POINTER\n*        BAL   LENGTH,GENRLD(SBR)\n*        DC    H' '                     LENGTH OF ADDRESS TABLE\n*        DC    H'  '                    ESID OF RELOCATION FACTOR R\n*        DC    H'  '                    ESID OF POSITION IDENTIFIER P\n*        ---                            RETURN AFTER CALL GENERATE\n*\n*\n* GENERATE TXT-RECORDS SIX DIFFERENT CALLS\n*        BAL   INFORM,GENTXT2(SBR)\n*        RR FORMAT INSTRUCTION OR DATA 2 BYTES LONG\n*        ---                            RETURN AFTER CALL GENERATE\n*\n*        BAL   INFORM,GENTXTP2(SBR)\n*        RR FORMAT FLOATING POINT LONG FORM INSTRUCTION\n*        ---                            RETURN AFTER CALL GENERATE\n*\n*        BAL   INFORM,GENTXT4(SBR)\n*        INSTRUCTION(S) OR DATA 4 BYTES LONG\n*        ---                            RETURN AFTER CALL GENERATE\n*\n*        BAL   INFORM,GENTXTP4(SBR)\n*        RX  FORMAT FLOATING POINT LONG FORM INSTRUCTION\n*        ---                            RETURN AFTER CALL GENERATE\n*\n*        BAL   INFORM,GENTXT6(SBR)\n*        INSTRUCTIONS OR DATA 6 BYTES LONG\n*        ---                            RETURN AFTER CALL GENERATE\n*\n*        LA    INFORM,        ADDRESS OF CODE TO BE GENERATED\n*        BAL   LENGTH,GENTXT8(SBR)\n*        DC    H'  '          LENGTH OF CODE IN BYTES\n*        ---                            RETURN AFTER CALL GENERATE\n         EJECT\n* REGISTER DEFINITIONS\nREG0     EQU   0                        VARIABLE USE\nOUTAREA  EQU   1                        OUTPUT RECORD POINTER\nINFORM   EQU   2                        ADDRESS OF INFORMATION\nTYPER    EQU   3                        TYPE OF RECORD TO BE GENERATED\nRETURN   EQU   4                        RETURN REGISTER\nLENGTH   EQU   14                       LENGTH OF INFORM. FROM CALL\nL        EQU   15                       LENGTH WITHIN RECORD\n         SPACE 2\n*ADDRESS DISPLACEMENTS\nRSTART   EQU   0                        START OF RECORD TYPE TABLE\nRTYP     EQU   1                        RECORD IDENTIFICATION\nRLEN     EQU   4                        INITIAL LENGTH 0 OR 4\nRESID    EQU   6                        ESID OR BLANKS\nRMAX     EQU   12                       MAXIMUM NUMBER OF BYTES IN REC\nRMOV     EQU   14                       START OF MOVE ROUTINE\nINFL     EQU   10                       LENGTH OF INFORM IN A RECORD\n         SPACE 2\n* BIT PATTERNS\nSDENTRY  EQU   X'00'                    SD-ENTRY IDENTIFICATION\nLDENTRY  EQU   X'01'                    LD-ENTRY IDENTIFICATION\nRLDFLAG  EQU   B'00001100'              FLAG USED IN RLD-ENTRY\n         SPACE 3\n         DS    0H\nGENRLD   EQU   *-ABB1              START OF GENERATE RLD-RECORDS\n         LA    RETURN,6(0,LENGTH)       COMPUTE RETURN ADDRESS\n         LA    TYPER,RLDT               INDICZTE RLD-CALL\n         LH    LENGTH,0(0,LENGTH)       LOAD LENGTH GIVEN IN CALL\n         SLL   LENGTH,1                 DOUBLE LENGTH\n         B     GEN1                     CONTINUE COMMON PART\n*\nGENTXTS  EQU   *-ABB1              START OF GENERATE TXT-RECORD,S\n         LA    RETURN,2(0,LENGTH)       COMPUTE RETURN ADDRESS\n         LH    LENGTH,0(0,LENGTH)       LOAD LENGTH GIVEN IN CALL\n         B     GEN2                     CONTINUE TXT-ENTRY\n*\n*\nGENTXTP4 EQU   *-SBRSTRT           GENERATE RX OR RS INST.,CHANGE PREC.\n         XI    GENTXT6+7(SBR),X'06'     MODIFY LENGTH INSTRUCTION\nGENTXTP2 EQU   *-SBRSTRT           GENERATE RR INST.,CHANGE PRECISION\n         OC    0(1,INFORM),PRECMASK(WAREG)     MODIFY INSTR. L OR S\nGENTXT2  EQU   *-ABB1              START OF GENERATE TXT-RECORD,2\n         XI    GENTXT6+7(SBR),X'06'     MODIFY LENGTH INSTRUCTION\n*\nGENTXT4  EQU   *-ABB1              START OF GENERATE TXT-RECORD,4\n         XI    GENTXT6+7(SBR),X'02'     MODIFY LENGTH INSTRUCTION\n*\nGENTXT6  EQU   *-ABB1              START OF GENERATE TXT-RECORD,6\n         ST    LENGTH,PLACE14(0,WAREG)           SAVE LENGTH REGISTER\n         LA    LENGTH,6                 LENGTH=2,4 OR 6\n         MVI   GENTXT6+7(SBR),X'06'     RESTORE MODIFIED INSTR.\n         LA    RETURN,0(INFORM,LENGTH)      COMPUTE RETURN ADDRESS\nGEN2     LA    TYPER,TXTT               INDICATE TXT-CALL\n         SPACE 3\nGEN1     L     OUTAREA,SAVOUTA(WAREG)     FETCH OLD OUTPUT RECORD ADD.\n         TM    HCOMPMOD+1(WAREG),X'60'     LOAD OR DECK SPECIFIED\n         BO    GEN4+6                   NO OUT OF GENERATE\n         TM    HCOMPMOD(WAREG),X'80'\n         BO    GEN4+6\n         CLC   RTYP(3,OUTAREA),RTYP(TYPER)     RECORD RIGTH TYPE\n         BNE   GEN3                     NO,CALL IOR NEW\n         CLC   INFL(2,OUTAREA),RMAX(TYPER)     RECORD FILLED\n         BNL   GEN3                     YES,CALL FOR NEW\nGEN6     EQU   *\n         LA    L,56\n         LH    REG0,INFL(0,OUTAREA)     REG0=LENGTH OF INFORM IN REC\n         SR    L,REG0                   L=EMPTY POS LEFT IN RECORD\n         CR    L,LENGTH                 ENOUTH SPACE LEFT\n         BL    *+6                      NO\n         LR    L,LENGTH                 YES L=LENGTH FROM CALL\n         AR    L,REG0\n         STH   L,INFL(0,OUTAREA)        INSERT NEW LENGTH INTO RECORD\n*\n         SR    L,REG0\n         AR    OUTAREA,REG0             START ADDRESS WITHIN RECORD\n         SR    LENGTH,L                 REMAINING LENGTH\n         B     RMOV(TYPER)              TO DIFFERENT MOVE ROUTINES\n*\nGEN4     LTR   LENGTH,LENGTH            MORE INFORMATION MUST BE MOVED\n         BH    GEN3                     YES\n         L     LENGTH,PLACE14(0,WAREG)           RESTORE REG LENGTH\n         BR    RETURN\n         SPACE 3\nGEN3     EQU   *                        CALL FOR NEW OUTPUT RECORD\nPUNCH    ST    LENGTH,SAVELT            SAVE LENGTH\n         TM    HCOMPMOD+1(WAREG),X'60'    BOTH LOAD AND DECK SPECIFIED\n         BZ    BOTH                     YES\n         TM    HCOMPMOD+1(WAREG),NDCK     ONLY DECK\n         L     OUTAREA,PCHADD(WAREG)    IF ONLY DECK\n         BZ    PUT1                     YES\n         L     OUTAREA,LINADD(WAREG)         SYSLIN OUTPUT\nPUT1     PUT   (OUTAREA)                PUT FOR SYSLIN AND SYSPUNCH IF\n         ST    OUTAREA,SAVOUTA(WAREG)      SYSPUNCH OR SYSLIN ADDRESS\n         L     LENGTH,SAVELT            RESTORE LENGTH\n         B     PUNCHOUT                 OUT OF ROUTINE PUNCH\nBOTH     L     LENGTH,OUTAREA2(WAREG)     COPY SYSLIN B. INTO SYSPUNCH\n         L     OUTAREA,SAVOUTA(WAREG)\n         MVC   0(80,LENGTH),0(OUTAREA)  BUFFER\nPUT2     L     OUTAREA,PCHADD(WAREG)\n         PUT   (OUTAREA)                PUT FOR SYSPUNCH WHEN BOTH HAS\n         ST    OUTAREA,OUTAREA2(WAREG)     *BEEN SPECIFIED\n         B     PUT1-4                   GO TO PUT SYSLIN\nPUNCHOUT EQU   *\n         MVC   0(4,OUTAREA),RSTART(TYPER)     INSERT FIRST 4 BYTES\n         MVI   4(OUTAREA),C' '          INSERT ONE BLANK\n         MVC   5(67,OUTAREA),4(OUTAREA)      BLANK OUTPUT RECORD\n         MVC   72(4,OUTAREA),PIDENT(WAREG)     INSERT PROGRAM IDENT\n         L     L,SEQU(WAREG)            STEP\n         LA    L,1(0,L)                      SEQUENCE\n         ST    L,SEQU(WAREG)                          NR\n         CVD   L,DBL                    CONVERT\n         UNPK  76(4,OUTAREA),DBL+5(3)           TO DECIMAL\n         MVZ   79(1,OUTAREA),76(OUTAREA)\n         MVC   10(2,OUTAREA),RLEN(TYPER)     INSERT INITIAL LENGTH\n         MVC   14(6,OUTAREA),RESID(TYPER)     INSERT ESID+R AND P\n         CLC   TXTT+1(3),RTYP(TYPER)    TXT-RECORD PROCESSED\n         BNE   GEN6                     NO\n         ST    PRPOINT,4(OUTAREA)       YES INSERT PRPOINT\n         MVI   4(OUTAREA),C' '\n         B     GEN6\n         SPACE 3\n* TABLES AND MOVE ROUTINES\n         SPACE 2\nTXTT     DS    0H                  START OF TXT-RECORD  TABLE\n         DC    X'02'                    CARD CODE\n         DC    C'TXT'                   IDENTIFICATION\n         DC    H'0'                     INITIAL LENGTH 0\n         DC    H'1'                     ESID\n         DC    C'    '\n         DC    H'56'                    MAXIMUM LENGTH\nGEN8     EQU   *                   MOVE TXT-INFORMATION TO OUTAREA\n         BCTR  L,0                      L=L-1\n         STC   L,*+5                    INSERT PROPER LENGTH TO MOVE\n         MVC   16(0,OUTAREA),0(INFORM)      MOVE INFORM TO OUTAREA\n         LA    PRPOINT,1(L,PRPOINT)     INCREASE PROGRAM POINTER\n         LA    INFORM,1(L,INFORM)       MODIFY DATA ADDRESS\n         B     GEN4                     OUT OF MOVE TXT ROUTINE\n         SPACE 3\nRLDT     DS    0H                  START OF RLD-RECORD TABLE\n         DC    X'02'                    CARD CODE\n         DC    C'RLD'                   IDENTIFICATION\n         DC    H'0'                     INITIAL LENGTH 0\n         DC    C'  '\nRANDP    DC    H'1',H'1'                R AND P ESID ARE 1 AT START\n         DC    H'56'                    MAXIMUM LENGTH IN RECORD\nGEN9     EQU   *                   MOVE RLD-INFORMATION TO OUTAREA\n         AR    L,OUTAREA                INDICATE LAST ENTRY\nGEN5     MVC   16(4,OUTAREA),RANDP\n         ST    INFORM,20(OUTAREA)       MOVE PROGRAM POINTER VALUE AND\n         MVI   20(OUTAREA),RLDFLAG      * FLAG TO OUTAREA\n         LA    OUTAREA,8(OUTAREA)       NEXT ENTRY\n         LA    INFORM,4(0,INFORM)       NEXT PROGRAM POINTER VALUE\n         CR    OUTAREA,L                LAST COLUMN FILLED\n         BL    GEN5                     NO,CONTINUE\n         B     GEN4                     OUT OF MOVE RLD ROUTINE\n         SPACE 3\n* VARIABLES AND CONSTANTS\n         SPACE\nDBL      DS    D                        FOR CONV OF SEQUENCE NR\nSAVELT   DS    F                       SAVE AREA FOR LENGTH\n         EJECT\n         DS    0H\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*                                                                     *\n*              SUBROUTINE CLEAR REGISTERS\n*                                                                     *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*                                                                     *\n* CALL   BAL   RETURN,CLEARRG(0,SBR)                                  *\n* GENERATES STORE INSTRUCTIONS FOR ALL REGISTERS THAT CONTAIN\n* VALID INFORMATION- SET CII,CIR,RII,RIR.\n*                                                                     *\n         SPACE 2\nCLEARRG  EQU   *-SBRPOOL\n         MVI   GPBN+1(WAREG),X'FF'      DESTROY GDSA\n         ST    RETURN,RETADR(0,WAREG)   STORE RETURN ADDRESS\n         SR    R14,R14\n         BCTR  R14,0\n         BCTR  R14,0\n         LH    R2,RIR(0,WAREG)\nKIF22    LA    R14,2(0,R14)\n         LTR   R2,R2\n         BZ    KIF21                    BRANCH IF YES\n         SRDL  R2,1\n         LTR   R3,R3\n         BC    10,KIF22                 BRANCH IF NO\n         ST    R2,RETADR+64(WAREG)\n         BAL   RETURN,ROUTIN13(0,SBR)\n         L     R2,RETADR+64(0,WAREG)\n         B     KIF22\nKIF21    MVI   CIR(WAREG),X'00'\n         MVI   CIR+1(WAREG),X'06'\n         MVC   RIR(2,WAREG),ZEROHW(WAREG)   CLEAR RIR\n         SR    R14,R14\n         BCTR  R14,0\n         LH    R2,RII(0,WAREG)\nKIF25    LA    R14,1(0,R14)\n         LTR   R2,R2\n         BZ    KIF24                    BRANCH IF YES\n         SRDL  R2,1\n         LTR   R3,R3\n         BC    10,KIF25                 BRANCH IF NO\n         ST    R2,RETADR+64(WAREG)\n         BAL   RETURN,ROUTINE9(0,SBR)\n         L     R2,RETADR+64(WAREG)\n         B     KIF25\nKIF24    MVI   CII(WAREG),X'00'\n         MVI   CII+1(WAREG),X'07'\n         MVC   RII(2,WAREG),ZEROHW(WAREG)   CLEAR RII\n         L     RETURN,RETADR(0,WAREG)   LOAD RETURN ADDRESS\n         BR    RETURN\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*                                                                     *\n*        O P E R A N D R E C O G N I Z E R                            *\n*                                                                     *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n* CALL   BAL   RETURN,OPDREC(SBR)\n* CHECK IF OPERAND IN STACK IS A FORMAL PARAMETER OR A PROCEDURE\n* WITHOUT PARAMETERS .OPDREC GENERATES AN ACTUAL PARAMETER OR A\n* PROCEDURE CALL .\n*  IF OPERAND IS A FORMAL PARAMETER CALLED BY VALUE LABEL OR ARRAY\n* OPDREC GENERATES  LOAD OF REGISTERS GDSA AND/OR ADR\n         SPACE 2\n* ADDRESS DISPLACEMENTS\nTYPS     EQU   1                        SECOND BYTE TYPE IN IDENTIFIER\nNUMP     EQU   3                        NR OF PARAMETERS IN IDENTIFIER\nPBNP     EQU   2                        DISP OF PBN IN IDENTIFIER\nTYPF     EQU   0                        FIRST BYTE TYPE IN IDENTIFIER\nRUTIADR  EQU   4*8                      ENTRY IN RUTI-TABLE FOR ADR\n         SPACE 2\n* BIT PATTERNS\nVARIAM   EQU   X'30'                    MASK FOR VARIABLE\nINTRVM   EQU   X'7F'                    INTERMIDIATE VALUE  IN STACK\nINTRRM   EQU   X'60'                    INTERMIDIATE VALUE ADDR.IN REG.\nDESTROY  EQU   X'FF'                    INDICATE THAT GDSA IS NOT VALID\nARRAYM   EQU   X'04'                    ARRAY IDENTIFIER MASK\nLABARRM  EQU   X'0C'                    LABEL OR ARRAY IDENTIFIER MASK\nNOTMIX   EQU   9\nRIIADRM  EQU   X'01'                    RII-MASK FOR RESERVATION OF ADR\nFORMPM   EQU   X'30'                    FORMAL PARAMETER MASK\nPROCM    EQU   X'C0'                    PROCEDURE MASK\nZERO     EQU   8\nNOTZERO  EQU   5\nSTPROCM  EQU   X'40'                    STANDARD PROCEDURE MASK\nPARAM    EQU   X'F0'                    NUMBER OF PARAMETER MASK\nFUNCPM   EQU   X'03'                    FUNCTION PROCEDURE MASK\nVALUEM   EQU   X'20'                    VALUE PARAMETER SPEC.\nREGADRM  EQU   ADR*16                   REGISTER ADR MASK\n         SPACE 2\n         DS    0H\nOPDREC EQU     *-SBRSTRT           START OF OPERAND RECOGNIZER IN SBR\n         TM    0(OPDK),X'C0'            IDENTIFIER FROM ITAB\n         BCR   12,RETURN                NO RETURN\n         TM    TYPS(OPDK),FORMPM        OPERAND FORMAL PARAMETER\n         ST    RETURN,SAVRT             SAVE RETURN ADDRESS\n         BM    OPDREC1                  YES,FORMAL\n         TM    TYPS(OPDK),PROCM         PROCEDURE IDENTIFIER\n         BCR   ZERO,RETURN              NO,RETURN\n         TM    TYPS(OPDK),STPROCM       STANDARD PROCEDURE\n         BCR   ZERO,RETURN              YES,RETURN\n         TM    NUMP(OPDK),PARAM         PARAMETERLESS PROCEDURE\n         BCR   NOTZERO,RETURN           NO,RETURN\n         SPACE 1\n*        EQU   *                   PARAMETERLESS PROCEDURE FOUND\n         BAL   RETURN,CLEARRG(0,SBR)      CLEAR ALL OBJ.TIME REGISTERS\n         MVC   PPCODE+2(2),NUMP(OPDK)     INSERT DISPL. OF LABEL\n         MVC   PPCODE+5(1),PBNP(OPDK)     INSERT PROGRAM BLOCK NR\n         LA    INFORM,PPCODE            GENERATE A PARAMETERLESS\n         BAL   LENGTH,GENTXTS(0,SBR)    *PROCEDURE\n         DC    H'12'                    *CALL\n         TM    TYPS(OPDK),FUNCPM        FUNCTION PROCEDURE\n         L     RETURN,SAVRT\n         BCR   ZERO,RETURN              NO,RETURN\n         SPACE 1\n*        EQU   *                   PARAMETERLESS FUNCTION PROC.FOUND\n         B     OPDREC4\nOPDREC1  EQU   *                   FORMAL PARAMETER FOUND\n         TM    TYPS(OPDK),VALUEM        CALLED BY NAME\n         BO    OPDREC3                  NO\n         SPACE 1\n*        EQU   *                   FORMAL PARAMETER CALLED BY NAME\n         BAL   RETURN,CLEARRG(0,SBR)      CLEAR ALL OBJ.TIME REGISTERS\n         SR    REGGEN,REGGEN\n         IC    REGGEN,PBNP(0,OPDK)      PROCEDURE PBN FROM IDENTIFIER\n         SLL   REGGEN,3                 DISPLACEMENT IN PBT\n         STH   REGGEN,CAP+4             *INSERTED IN CAP CODE\n         LH    REGGEN,SPBNST(0,WAREG)     CURRENT PBN\n         SLL   REGGEN,3                 *DISPLACEMENT IN PBT\n         STH   REGGEN,CAP+6             *INSERTED IN CAP CODE\n         MVC   CAP+10(2),NUMP(OPDK)     INSERT FORMAL PARAM. DISPL\n         LA    INFORM,CAP               GENERATE CALL ACTUAL PARAMETER\n         BAL   LENGTH,GENTXTS(0,SBR)     *CODE\n         DC    H'12'\n         TM    TYPS(OPDK),PROCM         PROCEDURE\n         BZ    OPDREC4                  NO\n         TM    PROCWPS(SBR),X'80'\n         BO    OPDREC4                  NOT PARAMETERLESS,SET IN CP57\n         LA    INFORM,OPDREC6           GENERATE\n         BAL   LENGTH,GENTXTS(SBR)      * CHECK FOR PARAMETERLESS\n         DC    H'10'                    *PROCEDURE\nOPDREC4  AH    P,ONEENTRY(0,WAREG)      RESERVE ONE ENTRY IN OBJ.STACK\n         STH   P,SPBNST+2(0,WAREG)      INSERT NEW DISPL. AND\n         MVC   PBNP(3,OPDK),SPBNST+1(WAREG)     *PBN IN INTERNAL NAME\n         XI    TYPF(OPDK),INTRRM        ADDRESS OF OPERAND IN REGISTER\n         OI    NUMP(OPDK),REGADRM       INDICATE REGISTER ADR\n         ST    OPDK,RUTI+RUTIADR(0,WAREG)     GPR CONTROL ENTRY RUTI\n         OI    RII(WAREG),RIIADRM       GPR CONTROL ENTRY RII\n         L     RETURN,SAVRT\n         TM    TYPS(OPDK),ARRAYM\n         BCR   1,RETURN\n         TM    TYPS(OPDK),X'03'\n         BCR   8,RETURN\n         MVI   PBNP(OPDK),X'00'         INDICATE SPECIAL ADDRESS.ADR\n*                                       MAY POINT TO FCTVALST IN FSA\n*                                       ROUTINE 9 CHECK THIS\n         BR    RETURN                   RETURN\n         SPACE 1\nOPDREC3  EQU   *                   FORMAL PARAMETER CALLED BY VALUE\n         TM    TYPS(OPDK),LABARRM       LABEL OR ARRAY IDENTIFIER\n         BCR   NOTMIX,RETURN            NO,RETURN\n         BAL   RETURN,ROUTINE3(0,SBR)   GENERATE LOAD ADR\n         AH    P,ONEENTRY(0,WAREG)      OBJECT TIME STACK NOT RELEASED\n         TM    TYPS(OPDK),ARRAYM        ARRAY IDENTIFIER\n         BO    OPDREC4                  YES,INTERNAL NAME AND REG.CONTR\n         LA    REGGEN,4\n         AH    REGGEN,GRD3+2            ADD 4 TO DISP,GRD3 IN ROUTINE3\n         STH   REGGEN,OPDREC5+2         INSERT DISP.+4(CDSA OR GDSA)\n         MVN   OPDREC5+1(1),GRD3+1        * IN LOAD GDSA INSTR.\n         BAL   INFORM,GENTXT4(0,SBR)    GENERATE A LOAD GDSA\nOPDREC5  L     GDSA,DISP+4              *INSTRUCTION\n         MVI   GPBN+1(WAREG),DESTROY      NOTE THAT GDSA IS DESTROYED\n         B     OPDREC4                  INTERNAL NAME AND REG.CONTROL\n         SPACE 3\n*CONSTANTS AND VARIABLES\n         SPACE\nPPCODE   L     ADR,DISP(LAT,0)          PARAMETERLESS PROCEDURE CALL\n         MVI   PROLPBN(FSA),DISP        *CODE,DISP INSERTED\n         BAL   BRR,PROLOG(0,FSA)        *CODE IS 12 BYTES\n         SPACE\n* CALL ACTUAL PARAMETER,GENERATED CODE,DISPL,PBNP AND PBNC INSERTED\nCAP      EQU   *                   CALL ACTUAL PARAMETER CODE\n         BAL   BRR,CAP1(0,FSA)          TO CAP SUBROUTINE FIRST PART\n         DS    H                        PBNP,PBN-DISP OF PROCEDURE\n         DS    H                        PBNC,PBN-DISP OF CURRENT BLOCK\n         L     ADR,DISP(CDSA,0)         THUNK-ADDR FROM PROCEDURE DSA\nOPDREC6   LA   STH,FCTVALST(FSA)        CHECK THAT ACTUAL\n         CR    STH,ADR                  *PARAMETER PROCEDURE\n         BNE   OERR21(FSA)              *IS PARAMETERLESS\n         SPACE\nSAVRT    DS    F                        SAVE AREA FOR RETURN\nPROCWPS  EQU   *-SBRSTRT                SWITCH TO AVOID PARAMETER-\n         DC    X'00'                    *LESS PROCEDURE CHECK\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*                                                                     *\n*        S U B R O U T I N E   M A X C H E C K                        *\n*                                                                     *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         DS    0H\nMAXCH    EQU   *-SBRSTRT           SUBROUTINE TO CHECK THAT OBJECT TIME\n*                                  STACK POINTER VALUE IS LESS THAN MAX\n*                                       VALUE PLACED IN WORKPL BY\n*                                       CALLING ROUTINE\n         SPACE 1\n* CALL   BAL   RETURN,MAXCH(SBR)\n*\n         SPACE\n* REGISTER DEFINITIONS\nREGGEN   EQU   3                        VARIABLE USE\nR        EQU   RETURN                   VARIABLE USE\nREGONE   EQU   15                       FIRST REG DESTROYED BY SERR1\n         SPACE\n* BIT PATTERNS\nSYNTCM   EQU   X'80'                    SYNTAX CHECK MODE MASK\n         SPACE 2\n         STM   REGONE,RETURN,MCHSAV     SAVE REGISTERS\n         LH    R,WORKPL(0,WAREG)        FETCH CHECKVALUE FROM WORKAREA\n         LH    REGGEN,SPBNST(0,WAREG)     CURRENT PBN FROM WORKAREA\n         SLL   REGGEN,2                 PBT-DISPLACEMENT\n         CH    R,PBTAB3(REGGEN,WAREG)       R LESS THAN MAX IN PBTAB3\n         BNH   MAXCH1                   YES,RETURN\n         STH   R,PBTAB3(REGGEN,WAREG)      INSERT R AS NEW MAX\n         CH    R,MAXOVERF(0,WAREG)      OVERFLOW OF OBJECT TIME STACK\n         BNH   MAXCH1                   NO,RETURN\n         CR    P,R                      HAS P ALREADY BEEN RESET\n         BL    MAXCH1                   YES, NO ERROR MSG\n         SR    P,P                      NO, RESET P TO ZERO\n         BAL   SRETURN,SERRSP(0,SBR)    ERROR PATTERN GENERATION\n         DC    H'214'                   ERROR 214\nMAXCH1   LM    REGONE,RETURN,MCHSAV     RESTORE REGISTERS\n         BR    RETURN                   RETURN\n         SPACE 2\n* VARIABLES AND CONSTANTS\n         SPACE\nMCHSAV    DS   6F                       SAVE AREA FOR REGISTERS\n         EJECT\n         DS    0H\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*                                                                     *\n*        SEMICOLON COUNTER HANDLING                                   *\n*                                                                     *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n* CALL   BAL RETURN,SCHDL(SBR)\n*              SET SEMICOLON COUNTER AND MOVE SOURCE POINTER\n*              IN SOURCE STRING\n* GENERATES SEMICOLON TRACE IF OPTION SPECIFIED\n*\n         SPACE 2\nSCHDL    EQU   *-SBRPOOL\n         ST    RETURN,SCHDLR(SBR)       SAVE RETURN ADDRESS\n         MVC   SCSC(2,WAREG),1(SOURCE)  STORE SEMICOLON NR\n         LA    SOURCE,2(SOURCE)         STEP SOURCE POINTER\n*\n*              GENERATE BRANCH TO TRACE-ROUTINE\n*\n         MVC   SCHDL1(2),SCSC(WAREG)    SC NR TO GENERATED CODE\n         TM    HCOMPMOD+2(WAREG),NOTEST\n         BO    SCHDL1+2                 NO SEMICOLON TRACE GEN\n         BAL   INFORM,GENTXT6(SBR)\n         BAL   BRR,TRACE(FSA)           **GENERATED CODE**\nSCHDL1   DC    H'0'                     **GENERATED CODE**\n         SPACE\n         L     RETURN,SCHDLR(SBR)\n         BR    RETURN\n         SPACE\n         DS    0F\nSCHDLR   EQU   *-SBRPOOL                TO SAVE RETURN ADDRESS\n         DS    F\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*                                                                     *\n*              ROUTINE NR. 1                                          *\n*                                                                     *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*                                                                     *\n*                                                                     *\n* LOAD IN W-PLACE THE DISPLACEMENT OF AN OPERAND THAT IS NOT AN ADDRESS\n* LOAD IN V-PLACE AA OR 99 DEPENDING ON WHERE THE VARIABLE,CONSTANT OR\n* INTERMEDIATE RESULT IS AND GENERATES A LOADING OF GDSA IF NECESSARY\n*                                                                     *\n*                                                                     *\n* CALL   BAL   RETURN,ROUTINE1(0,SBR)\n         SPACE\nROUTINE1 EQU   *-SBRPOOL\n         MVC   WPLACE(2,WAREG),3(OPDK)  MOVE DISPL OF LO TO W\nGPE2     MVI   VPLACE(WAREG),X'AA'      MOVE CDSA REG TO V\n         CLC   2(1,OPDK),SPBNST+1(WAREG)   IS PBN OF LO CDSA\n          BCR   8,RETURN                 RETURN IF CURRENT DSA\nGPE3     MVI   VPLACE(WAREG),X'99'      MOVE GLOBAL DSA REG TO V\n         CLI   GPBN+1(WAREG),X'FF'      IS C(GDSA) DESTROYED\n         BE    GPC3                     BRANCH IF DESTROYED\n         CLC   GPBN(1,WAREG),2(OPDK)    COMPARE GDSA WITH PBN OF LO\n         BCR   8,RETURN                RETURN IF EQUAL\nGPC31    SR    R1,R1                    CLEAR R1\n         ST    RETURN,RETADR+4(0,WAREG) STORE RETURN ADDRESS\n         MVC   GPBN(1,WAREG),2(OPDK)    KEEP NEW LOADED GDSA\n         IC    R1,2(0,OPDK)             LOAD IN R1 PBN OF LO\n         SLA   R1,3                     MULTIPLY BY 8\n         STH   R1,WORKPL(0,WAREG)      PREPARE INSTRUCTION\n         MVC   GPC4+2(2),WORKPL(WAREG)\n         BAL   INFORM,GENTXT4(0,SBR)    GENERATE\nGPC4     L     GDSA,0(PBT,0)\n         L     RETURN,RETADR+4(0,WAREG) LOAD RETURN ADDRESS\n         BR    RETURN                   RETURN\nGPC3     MVI   GPBN+1(WAREG),X'00'      RECONSTRUCT GDSA\n         B     GPC31\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*                                                                     *\n*              ROUTINE NR. 2                                          *\n*                                                                     *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*                                                                     *\n*                                                                     *\n* GENERATES A LOAD INSTRUCTION INTO THE FLOATING POINT REGISTER\n* SPECIFIED BY R14 OF AN OPERAND THAT IS AN ADDRESS- ADJUSTS THE\n* OPERAND, STORES OPERAND STACK ADDRESS INTO RUTR\n*                                                                     *\n*                                                                     *\n* CAL    BAL   RETURN,ROURINE2(0,SBR)\n         SPACE 2\nROUTINE2 EQU   *-SBRPOOL\n         ST    RETURN,RETADR+8(WAREG)        STORE RETURN ADDRESS\n         LA    OPDK,5(0,OPDK)                INCREASE OPDK\n         BAL   RETURN,ROUTINE3(0,SBR)        BRANCH TO ROUTINE NR.3\nGQE3     SLL   R14,1                         INTRODUCE OPDK ADD IN RUTR\n         ST    OPDK,RUTR(R14,WAREG)\n         SLL   R14,3                         PREPARE INSTRUCTION\n         STC   R14,GQD3+1\n         MVN   GQD3+1(1),VPLACE(WAREG)\n         MVC   GQD3+2(2),WPLACE(WAREG)\n         BAL   INFORM,GENTXTP4(0,SBR)\nGQD3     LD    0,0(0,0)                      ***GENERATE***\nGQF3     SRL   R14,4\n         SH    OPDK,CON5(0,SBR)              REDUCE OPDK\n         STH   P,WORKPL(0,WAREG)             INTROD. P INTO OPDK ENTRY\n         MVC   8(2,OPDK),WORKPL(WAREG)\n         MVZ   8(1,OPDK),GQD3+1              INTROD. REG. NUMBER\n         MVC   7(1,OPDK),SPBNST+1(WAREG)     INTROD. PBN\n         OI    5(OPDK),X'80'                 ADJUST OPDK ENTRY\n         NI    5(OPDK),X'9F'\n         L     RETURN,RETADR+8(WAREG)        LOAD RETURN ADDRESS\n         BR    RETURN\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*                                                                     *\n*              ROUTINE NR. 3\n*                                                                     *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*                                                                     *\n*                                                                     *\n* LOAD IN W-PLACE ZERO. LOAD IN V-PLACE 88. GENERATES A LOADING OF ADR\n* IF NECCESSARY, IN THIS CASE THE OPERAND IS AN ADDRESS\n*                                                                     *\n*                                                                     *\n* CALL   BAL   RETURN, ROUTINES3(0,SBR)\n         SPACE\nROUTINE3 EQU   *-SBRPOOL\n         ST    RETURN,RETADR+12(0,WAREG)   STORE RETURN ADDRESS\n         TM    0(OPDK),X'40'             IS ADDRESS OF LO IN ADR\n         BO    GRC3                      BRANCH IF NOT\n         MVI   RII(WAREG),X'00'          CLEAR RIT OF ADR\nGRE3     SH    P,ONEENTRY(0,WAREG)       REDUCE P BY 8\nGRG2     MVI   VPLACE(WAREG),X'88'       V EQUAL ADR\n         MVC   WPLACE(2,WAREG),ZEROHW(WAREG)  W EQUAL ZERO\n         L     RETURN,RETADR+12(0,WAREG)   LOAD RETURN ADDRESS\n         BR    RETURN                    RET\nGRC3     TM    RII(WAREG),X'01'          IS ADR FREE\n         BZ    GRD31                    BRANCH IF FREE\nGRC4     ST   R14,RETADR3\n         BAL   RETURN,ROUTIN10(0,SBR)\n         L     R14,RETADR3\nGRD31    BAL   RETURN,ROUTINE1(0,SBR)    BRANCH TO ROUTINE1\n         MVC   GRD3+2(2),WPLACE(WAREG)  MOVE DISPLACEMENT\n         MVN   GRD3+1(1),VPLACE(WAREG)   MOVE BASE REG\n         BAL   INFORM,GENTXT4(0,SBR)    GENERATE\nGRD3     L     ADR,0(0,0)               ***GENERATE***\n         ST    OPDK,RUTI+32(0,WAREG)                               5601\n         B     GRE3\n         DS    0F\nRETADR3  DS    F\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*                                                                     *\n*              ROUTINE NR. 4\n*                                                                     *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*                                                                     *\n*                                                                     *\n* GENERATES A LOAD INSTRUCTION INTO THE FLOATING POINT REGISTER\n* SPECIFIED BY R14 OF AN OPERAND THAT IS NOT AN ADDRESS- ADJUSTS THE\n* OPERAND AND STORES THE OPERAND STACK ADDRESS INTO RUTR\n*                                                                     *\n*                                                                     *\n* CALL   BAL   RETURN,ROUTINE4(0,SBR)\n         SPACE\nROUTINE4 EQU   *-SBRPOOL\n         ST    RETURN,RETADR+8(WAREG)        STORE RETURN ADDRESS\n         LA    OPDK,5(0,OPDK)                INCREASE OPDK\n         BAL   RETURN,ROUTINE1(0,SBR)        BRANCH TO ROUTINE NR1\n         OI    1(OPDK),X'30'                SET TO VARIABLE\n         B     GQE3                          BRANCH TO ROUTINE NR2\n         SPACE 2\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*                                                                     *\n*              ROUTINE NR. 5\n*                                                                     *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*                                                                     *\n*                                                                     *\n* GENERATES A LOAD INSTRUCTION INTO A GENERAL PURPOSE REGISTER\n* SPECIFIED BY R14 OF AN OPERAND THAT IS NOT AN ADDRESS- ADJUSTS THE\n* OPERAND AND STORES THE OPERAND STACK ADDRESS INTO RUTI\n*                                                                     *\n*                                                                     *\n* CALL   BAL   RETURN,ROUTINE5(0,SBR)\n         SPACE\nROUTINE5 EQU   *-SBRPOOL\n         ST    RETURN,RETADR+8(WAREG)        STORE RETURN  ADDRESS\n         LA    OPDK,5(0,OPDK)                INCREASE OPDK\n         BAL   RETURN,ROUTINE1(0,SBR)        BRANCH TO ROUTINE NR.1\n         OI    1(OPDK),X'30'                SET TO VARIABLE\nGTE3     SLL   R14,2                         INTRODUCE OPDK ADD IN RUTI\n         ST    OPDK,RUTI(R14,WAREG)\n         SLL   R14,2                         PREPARE INSTRUCTION\n         STC   R14,GTD3+1\n         STC   R14,GQD3+1\n         MVN   GTD3+1(1),VPLACE(WAREG)\n         MVC   GTD3+2(2),WPLACE(WAREG)\n         BAL   INFORM,GENTXT4(0,SBR)\nGTD3     L     0,0(0,0)                      ***GENERATE***\n         B     GQF3                          BRANCH TO ROUTINE NR.2\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*                                                                     *\n*              ROUTINE NR. 6\n*                                                                     *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*                                                                     *\n*                                                                     *\n* GENERATES A LOAD INSTRUCTION INTO A GENRAL PURPOSE REGISTER\n* SPECIFIED BY R14 OF AN OPERAND THAT IS AN ADDRESS- ADJUSTS THE\n* OPERAND AND STORES THE OPERAND STACK ADDRESS INTO RUTI.\n*                                                                     *\n*                                                                     *\n* CALL   BAL   RETURN,ROUTINE6(0,SBR)\n         SPACE\nROUTINE6 EQU   *-SBRPOOL\n         ST    RETURN,RETADR+8(WAREG)        STORE RETURN ADDRESS\n         LA    OPDK,5(0,OPDK)                INCREASE OPDK\n         BAL   RETURN,ROUTINE3(0,SBR)        BRANCH TO ROUTINE NR 3\n         B     GTE3                          BRANCH TO ROUTINE NR 5\n         SPACE\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*                                                                     *\n*              ROUTINE NR. 7\n*                                                                     *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*                                                                     *\n*                                                                     *\n* LOADS INTO R14 THE NUMBER OF THE NEXT GENERAL PURPOSE REGISTER TO BE\n* USED ACCORDING TO CII. IF IT IS OCCUPIED IT BRANCHES TO ROUTINE NR.\n* 9 THAT GENERATES A STORE INSTRUCTION. CII AND RII ARE SET. RESERVES\n* ONE OBJECT TIME STACK ENTRY.\n*                                                                     *\n*                                                                     *\n* CALL   BALL  RETURN,ROUTINE7(0,SBR)\n         SPACE\nROUTINE7 EQU   *-SBRPOOL\n         SR    R14,R14\n         CLI   CII+1(WAREG),X'07'            CHECK IF CII IS 7\n         BE    GVC2                          BRANCH IF CII IS 7\n         IC    R14,CII+1(0,WAREG)            INCREASE CII BY ONE\n         LA    R14,1(0,R14)\nGVC2     STC   R14,CII+1(0,WAREG)\n         LA    R15,1                         LOAD ONE INTO R15\n         SLL   R15,0(R14)                    GENERATE MASK\n         STC   R15,GVC21+1\nGVC21    TM    RII+1(WAREG),X'00'            IS GPR OCCUPIED\n         BZ    GVE2                          BRANCH IF NOT OCCUPIED\n         ST    RETURN,RETADR+28(0,WAREG)     STORE RETURN ADDRESS\n         BAL   RETURN,ROUTINE9(0,SBR)        STOPINT\n         L     RETURN,RETADR+28(0,WAREG)     LOAD RETURN ADDRESS\nGVE2     OC    RII+1(1,WAREG),GVC21+1        SET TO ONE RII\nGVF2     AH    P,ONEENTRY(0,WAREG)           INCREASE P\n         BR    RETURN\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*                                                                     *\n*              ROUTINE NR.8\n*                                                                     *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*                                                                     *\n*                                                                     *\n* THE LAST GENERAL PURPOSE REGISTER RESERVED IS RELEASED. CII AND RII\n* ARE SET. ONE OBJECT STACK ENTRY IS RELEASED\n*                                                                     *\n*                                                                     *\n* CALL   BAL   RETURN,ROUTINE8(0,SBR)\n         SPACE\nROUTINE8 EQU   *-SBRPOOL\n         SR    R14,R14                        CLEAR R14\n         IC    R14,CII+1(0,WAREG)            LOAD CII INTO R14\n         LA    R15,1                        CLEAR RII OF LO\n         SLL   R15,0(R14)\n         STC   R15,GWD51+1\n         XI    GWD51+1,X'FF'\nGWD51    NI    RII+1(WAREG),X'00'\n         SH    P,ONEENTRY(0,WAREG)           REDUCE P\nGWD5     CLI   CII+1(WAREG),X'00'            IS CII EQUAL TO ZERO\n         BZ    GWD3                          BRANCH IF YES\n         BCTR  R14,0                         REDUCE BY ONE\n         STC   R14,CII+1(0,WAREG)            STORE NEW CII\n         SRL   R15,1                   IS GPR INDICATED BY\nGWD6     STC   R15,GWD4+1                    CII FREE\nGWD4     TM    RII+1(WAREG),X'00'\n         BZ    GWD5                          BRANCH IF FREE\n         BR    RETURN                        RETURN\nGWD3     MVI   CII+1(WAREG),X'07'            MAKE CII = 7\n         LA    R14,7\n         CLI   RII+1(WAREG),X'00'            ARE ALL GPR FREE\n         BCR   8,RETURN                       RETURN IF ALL FREE\n         LA    R15,128                       LOAD MASK\n         B     GWD6\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*                                                                     *\n*              ROUTINE NR. 10\n*                                                                     *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*                                                                     *\n*                                                                     *\n* CLEARS RII OF ADR, LOADS 8 INTO R14 AND BRANCHES TO ROUTINE 9-\n*                                                                     *\n*                                                                     *\n* CALL   BAL   RETURN,ROUTIN10(0,SBR)\n         SPACE\nROUTIN10 EQU   *-SBRPOOL\n         MVI   RII(WAREG),X'00'\n         LH    R14,CON8(0,SBR)\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*                                                                     *\n*              ROUTINE NR. 9\n*                                                                     *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*                                                                     *\n*                                                                     *\n* GENERATES CODE TO STORE GENERAL PURPOSE REGISTER SPECIFIED BY 214\n* IF THE PBN IS NOT ZERO- IF THE PBN IS ZERO IT GENERATES A MOVE\n* INSTRUCTION- THE OPERAND IS ADJUSTED\n*                                                                     *\n*                                                                     *\n* CALL   BAL   RETURN,ROUTIN9(0,SBR)\n         SPACE\nROUTINE9 EQU   *-SBRPOOL\n         ST    RETURN,RETADR+36(0,WAREG)     STORE RETURN ADDRESS\n         SLL   R14,2                         MULTIPLY BY 4\n         LA    R15,RUTI(0,WAREG)             LOAD ADD OF RUTI\n         L     R15,0(R14,R15)                LOAD ADD OF OPD TO STORE\n         SLL   R14,2                         PREPARE INSTRUCTION\n         NI    3(R15),X'0F'\n         ST    R15,RETADR+48(WAREG)\n         TM    2(R15),X'FF'\n         BZ    GXC4\n         LA    R14,10(0,R14)\n         STC   R14,GXC3+1\n         MVC   GXC3+2(2),3(R15)              PREPARE INSTRUCTION\n         BAL   INFORM,GENTXT4(0,SBR)\nGXC3     ST    0,0(CDSA,0)                   ***GENERATE***\n         B     HBC2\nGXC4     MVC   GXC5+2(2),3(R15)\n         OI    GXC5+2,X'A0'\n         MVI   GXC5+1,X'07'\n         TM    HCOMPMOD(WAREG),X'02'\n         BO    GXC6\n         MVI   GXC5+1,X'03'\nGXC6     NI    0(R15),X'DF'\n         MVC   2(1,R15),SPBNST+1(WAREG)\n         BAL   INFORM,GENTXT6(0,SBR)\nGXC5     MVC   0(4,CDSA),0(ADR)\n         B     HBC2\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*                                                                     *\n*              ROUTINE NR. 11\n*                                                                     *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*                                                                     *\n*                                                                     *\n* LOADS INTO R14 THE NUMBER OF THE NEXT FLOATING POINT REGISTER TO BE\n* USED ACCORDING TO CIR, IF IT IS OCCUPIED IT BRANCHES TO ROUTINE\n* NR. 13  THAT GENERATES A STORE INSTRUCTION. CIR AND RIR ARE\n* SET. ONE OBJECT TIME ENTRY IS RESERVED\n*                                                                     *\n*                                                                     *\n* CALL   BAL   RETURN,ROUTIN11(0,SBR)\n         SPACE\nROUTIN11 EQU   *-SBRPOOL\n         SR    R14,R14                       CLEAR R14\n         CLI   CIR+1(WAREG),X'06'           CHECK IF CIR IS 6\n         BE    GZC2\n         IC    R14,CIR+1(WAREG)              LOAD CIR INTO R14\n         LA    R14,2(0,R14)                  INCREASE CIR BY 2\nGZC2     STH   R14,CIR(0,WAREG)              STORE NEW CIR\n         SRL   R14,1                         DIVIDE R14 BY 2\n         LA    R15,1                         LOAD ONE INTO R15\n         SLL   R15,0(R14)                    GENERATE MASK\n         SLL   R14,1\n         STC   R15,GZC21+1\nGZC21    TM    RIR+1(WAREG),X'00'            IS FPR OCCUPIED\n         BZ    GZE2                          BRANCH IF FPR FREE\n         ST    RETURN,RETADR+44(0,WAREG)     STORE RETURN ADDRESS\n         BAL   RETURN,ROUTIN13(0,SBR)        STOPREAL\n         L     RETURN,RETADR+44(0,WAREG)     LOAD  RETURN ADDRESS\nGZE2     OC    RIR+1(1,WAREG),GZC21+1\nGZF2     AH    P,ONEENTRY(0,WAREG)          INCREASE P\n         BR    RETURN\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*                                                                     *\n*              ROUTINE NR. 12\n*                                                                     *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*                                                                     *\n*                                                                     *\n* THE LAST FLOATING POINT REGISTER RESERVED IS RELEASED. CIR AND RIR\n* ARE SET. ONE OBJECT STACK ENTRY IS RELEASED\n*                                                                     *\n*                                                                     *\n* CALL   BAL   RETURN,ROUTIN12(0,SBR)\n         SPACE\nROUTIN12 EQU   *-SBRPOOL\n         LH    R14,CIR(0,WAREG)              LOAD INTO R14 CIR\n         LA    R15,1                         CLEAR RIR OF BLO\n         SRL   R14,1\n         SLL   R15,0(R14)\n         STC   R15,HAD4+1\n         XI    HAD4+1,X'FF'\nHAD4     NI    RIR+1(WAREG),X'00'\n         SH    P,ONEENTRY(0,WAREG)           REDUCE P\n         SLL   R14,1\nHAD1     CLI   CIR+1(WAREG),X'00'\n         BZ    HAD3                          BRANCH IF YES\n         SH    R14,CON2(0,SBR)\n         STC   R14,CIR+1(0,WAREG)\n         SRL   R15,1\nHAD0     STC   R15,HAD2+1\nHAD2     TM    RIR+1(WAREG),X'00'\n         BZ    HAD1\n         BR    RETURN\nHAD3     MVI   CIR+1(WAREG),X'06'            MAKE CIR=6\n         LH    R14,CIR(0,WAREG)\n         CLI   RIR+1(WAREG),X'00'\n         BCR   8,RETURN\n         LA    R15,8\n         B     HAD0\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*                                                                     *\n*              ROUTINE NR. 14\n*                                                                     *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*                                                                     *\n*                                                                     *\n* LOAD ZERO INTO R14\n*                                                                     *\n*                                                                     *\n* CALL   BAL   RETURN,ROUTIN14(0,SBR)\n         SPACE\nROUTIN14 EQU   *-SBRPOOL\n         SR    R14,R14\n         SPACE 2\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*                                                                     *\n*              ROUTINE NR. 13\n*                                                                     *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*                                                                     *\n*                                                                     *\n* GENERATES CODE TO STORE FLOATING POINT REGISTER SPECIFIED BY R14\n* THE OPERAND IS ADJUSTED\n*                                                                     *\n*                                                                     *\n         SPACE\nROUTIN13 EQU   *-SBRPOOL                STORE EPR INDICATED BY R14\n         ST    RETURN,RETADR+36(0,WAREG)     STORE RETURN ADDRESS\n         SLL   R14,1                    MULTIPLY R14 BY 2\n         LA    R15,RUTR(0,WAREG)         LOAD ADDRESS OF RUTR\n         L     R15,0(R14,R15)           LOAD OPDK ADDRESS OF OPERAND\n         SLL   R14,3                    SHIFT REG NR TO OREOARE INSTRUC\n         LA    R14,10(0,R14)            INTRODUCE CDSA\n         STC   R14,HBC3+1\n         NI    3(R15),X'0F'\n         MVC   HBC3+2(2),3(R15)\n         ST    R15,RETADR+48(WAREG)\n         BAL   INFORM,GENTXTP4(0,SBR)\nHBC3     STD   0,0(CDSA,0)\nHBC2     L     R15,RETADR+48(WAREG)\n         XI    0(R15),X'C0'\n         MVC   WORKPL(2,WAREG),3(R15)\n         BAL   RETURN,MAXCH(0,SBR)\n         SRL   R14,4\n         L     RETURN,RETADR+36(0,WAREG)\n         BR    RETURN                   RETURN\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*                                                                     *\n*              ROUTINE NR. 15\n*                                                                     *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*                                                                     *\n*                                                                     *\n* IF THE OPERAND IS AN ADDRESS IT BRANCHES TO ROUTINE NR.3   IF THE\n* OPERAND IS NOT AN ADDRESS AND IS IN A REGISTER IT GETS THE REGISTER\n* NUMBER TO V-PLACE, ELSE IT BRANCHES TO ROUTINE NR. 1\n*                                                                     *\n*                                                                     *\n* CALL   BAL   RETURN,ROUTIN15(0,SBR)\nROUTIN15 EQU   *-SBRPOOL\n         TM    0(OPDK),X'20'\n         BO    ROUTINE3(0,SBR)\n         TM    0(OPDK),X'40'\n         BZ    ROUT151\n         TM    0(OPDK),X'80'\n         BO    ROUTINE1(0,SBR)\n         SH    P,ONEENTRY(WAREG)\n         B     ROUTINE1(0,SBR)\nROUT151  IC    R15,3(OPDK)              GET\n         SRL   R15,4                        REG\n         STC   R15,VPLACE(WAREG)                NUMBER\n         MVZ   VPLACE(1,WAREG),3(OPDK)                 TO VPLACE\n         BR    R3                       RETURN\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*                                                                     *\n*              DECOMPOSE OPERAND BY MOVING ITS PARTS\n*              INTO LOW ENDS OF HALFWORDS\n*                                                                     *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n* CALL   BAL   RETURN,DECOMP(0,SBR)                                   *\n         SPACE 2\nDECOMP   EQU   *-SBRPOOL\n         MVC   OPDPBN+1(1,WAREG),2(OPDK)    MOVE PBN\n         MVC   OPDADR(2,WAREG),3(OPDK)      MOVE ADDRESS\n         LH    R1,OPDADR(WAREG)\n         N     R1,HEXFFF(SBR)\n         STH   R1,OPDLN(WAREG)              LABEL NUMBER\n         BR    RETURN\n         SPACE 3\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*                                                                     *\n*              STACK ALL PURPOSE IDENTIFIER (API)\n*                                                                     *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n* CALL   BAL   RETURN,STACKAPI(SBR)\n         SPACE\nSTACKAPI EQU   *-SBRPOOL\n         SH    OPDK,CON5(SBR)\n         CR    OPTK,OPDK\n         BNL   STACKOFL(SBR)\n         MVC   0(5,OPDK),API(SBR)\n         BR    RETURN\n         SPACE 3\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*                                                                     *\n*        PROGRAM BLOCK NUMBER HANDLING                                *\n*                                                                     *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n* CALL   BAL   RETURN,PBNHDL(SBR)\n* PROGRAM BLOCK NUMBER HANDLING INSERTS NEW PBN IN WORKAREA,SPBNST.\n* SAVES REGISTER P IN PBTAB2 AND INSERTS NEW OBJECT TIME STACK POINTER\n* VALUE TO P\n         SPACE\nPBNHDL   EQU   *-SBRPOOL\n         SR    R2,R2\n         IC    R2,3(SOURCE)\n         CLI   0(SOURCE),X'0D'          IS SOURCE OPERATOR BETA\n         BE    PBNHDL1(SBR)             YES\n         CLI   0(SOURCE),X'2A'          IS SOURCE OPERATOR EPSILON\n         BNE   PBNHDL2(SBR)             NO\n*                                       (=BRANCH IF OPTR IS PI OR PHI)\nPBNHDL1  EQU   *-SBRPOOL\n         IC    R2,1(SOURCE)             OPERATOR IS BETA OR EPSILON\n         LA    SOURCE,1(SOURCE)\nPBNHDL2  EQU   *-SBRPOOL\n         LH    R1,SPBNST(WAREG)         STORE\n         SLL   R1,1                           OLD\n         STH   P,PBTAB2(R1,WAREG)                 P-VALUE\n         STC   R2,SPBNST+1(WAREG)       INSERT NEW PBN\n         SLL   R2,1                     GET DISP IN PBTAB2\n         LH    P,PBTAB2(R2,WAREG)       LOAD NEW P-VALUE\n         TM    HCOMPMOD(WAREG),X'80'    CMT\n         BCR   1,RETURN                 FALSE\n         B     CLEARRG(SBR)             CLEAR REGISTERS RETURN DIRECT\n         SPACE 3\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*                                                                     *\n*              PARAMETERLESS PROCEDURE STATEMENT HANDLING\n*                                                                     *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n* CALL   BAL   RETURN,PLPRST(SBR)\n*  CHECKS THAT OPERAND IS A PARAMETERLESS PROCEDURE.\n*\n         SPACE\nPLPRST   EQU   *-SBRPOOL\n         ST    RETURN,STRETURN(WAREG)   SAVE RETURN ADDRESS\n         BAL   RETURN,DECOMP(SBR)       DECOMPOSE OPERAND\n         TM    1(OPDK),X'C0'            TEST IF PROCEDURE IDENTIFIER\n         BZ    PLPRST4(SBR)             ERROR IF NOT\n         LH    RETURN,OPDADR(WAREG)\n         SRL   RETURN,12                GET NR OF PARAMETERS\n         LTR   RETURN,RETURN            IS NR ZERO\n         BZ    PLPRST1(SBR)             YES\nPLPRST0  EQU   *-SBRPOOL\n         BAL   RETURN,SERR1(SBR)        ERROR\n         DC    H'187'\n         B     PLPRST3(SBR)\nPLPRST4  EQU   *-SBRPOOL\n         BAL   RETURN,SERR3(SBR)        ERROR\n         DC    H'183'\n         B     PLPRST3(SBR)\nPLPRST1  EQU   *-SBRPOOL\n         TM    HCOMPMOD(WAREG),X'80'    COMPILE MODE TEST\n         BO    PLPRST3(SBR)             BRANCH IF FALSE\n         BAL   RETURN,OPDREC(SBR)       OPERAND RECOGNIZER\n         TM    3(OPDK),REGADRM          OPERAND IN ADR\n         BZ    PLPRST3(SBR)             NO\n         SH    P,ONEENTRY(WAREG)        RELEASE STACK\n         XI    RII(WAREG),RIIADRM       ADR NOT OCCUPIED\nPLPRST3  EQU   *-SBRPOOL\n         L     RETURN,STRETURN(WAREG)   LOAD RETURN ADDRESS\n         BR    RETURN\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*                                                                     *\n*              SUBROUTINE 'LOAD VPLACE, WPLACE'\n*                                                                     *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n* CALL   BAL   RETURN,LDVWPLC(0,SBR)\n*\n         SPACE\nLDVWPLC  EQU   *-SBRPOOL\n         ST    RETURN,LDRET\n         BAL   RETURN,OPDREC(SBR)       OPERAND RECOGNIZER\n         TM    0(OPDK),X'20'            ADDRESS OR VALUE\n         BO    LDVW1                    ADDRESS\n         SPACE\n         TM    0(OPDK),X'40'            IS IT VALUE IN REG\n         BO    LDVW3                    NO\n         SR    R4,R4\n         IC    R4,3(OPDK)               GET REG\n         SRL   R4,4                             NR\n         SLL   R4,1                     DOUBLE IT\n         TM    1(OPDK),X'01'            IS VALUE INTEGER\n         BZ    LDVW4                    NO\n         SLL   R4,1                     YES, 4 TIMES REG NR\n         ST    OPDK,RUTI(R4,WAREG)      INTRODUCE CORRECT OPDK ADDR\n         B     LDVW3\nLDVW4    ST    OPDK,RUTR(R4,WAREG)      INTRODUCE CORRECT OPDK ADDR\nLDVW3    BAL   RETURN,CLEARRG(SBR)      CLEAR REGISTERS\n         BAL   RETURN,ROUTINE1(SBR)     USE ROUTINE 1 TO LOAD VW-PLACE\n         B     LDVWR\nLDVW1    CLI   2(OPDK),X'00'            FUNCTION VALUE IN FSA\n         BNE   *+16                                                0216\n         ST    OPDK,RUTI+32(WAREG)      INTRODUCE CORRECT OPDK ADD 0216\n         CLI   0(SOURCE),X'25'          SOURCE OPERATOR COMMA      0216\n         BE    LDVW3                    YES                        0216\n         SPACE\n         TM    0(OPDK),X'40'            IS ADDRESS IN STACK\n         BO    LDVW2                    YES\n         SPACE\n         MVI   VPLACE(WAREG),X'88'      ADDRESS IN REG ADR\n         MVC   WPLACE(2,WAREG),ZEROHW(WAREG)\n         B     LDVWR\n         SPACE\nLDVW2    MVI   VPLACE(WAREG),X'AA'      ADDRESS\n         MVC   WPLACE(2,WAREG),3(OPDK)          IN STACK\n         SPACE\nLDVWR    L     RETURN,LDRET\n         BR    RETURN\n         SPACE\nLDRET    DS    F\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*\n*               SUBROUTINES FOR MOVING STACK POINTERS\n*\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nMOVEOPTK EQU   *-SBRPOOL           ENTRY FOR MOVING OPERATOR STACK PTR\n          LA    OPTK,1(OPTK)\n          B     MOVERET(SBR)\nMOVEOPDK EQU    *-SBRPOOL          ENTRY FOR MOVING OPDSTACK POINTER\n          SH    OPDK,CON5(SBR)\nMOVERET   EQU   *-SBRPOOL\n         CR    OPTK,OPDK\n          BNL   STACKOFL(SBR)\n          BR    RETURN\n         SPACE 3\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*                                                                     *\n*        TARITHM                                                      *\n*                                                                     *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n* CALL   BAL   RETURN,TARITHM(SBR)    RETURN TO RETURN IF OPERAND\n* INTEGER OR REAL.OTHERWISE RETURN TO RETURN+4 AFTER ERROR MESSAGE\n* 163 IS GIVEN\n* CHECK ALSO FOR ARRAY OR PROCEDURE IDENTIFIER\n*\n         SPACE\nTARITHM  EQU   *-SBRPOOL           TEST IF OPERAND IS ARETHMETIC\n         TM    0(OPDK),APIMASK          API IN STACK               5603\n         BCR   1,RETURN                 YES ,RETURN NO ERROR\n         TM    1(OPDK),X'03'            OPERAND ARITHMETIC\n         BM    PROGARR                  YES CONTINUE CHECK\n         ST    RETURN,SAVTARIT          SAVE RETURN\n         BAL   RETURN,SERR2(SBR)\n         DC    H'163'                   ERROR 163\n         L     RETURN,SAVTARIT\n         B     4(RETURN)                RETURN ERROR MESSAGE 163 GIVEN\nPROGARR  LA    R1,4(RETURN)\n         ST    R1,SAVTARIT              ERROR RETURN FROM ARRTEST\n         B     ARRTEST1+4(SBR)          CHECK FOR PROCEDURE OR ARRAY\nSAVTARIT EQU   SAVTRREI                 SAVE AREA FOR RETURN\n         SPACE 3\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*                                                                     *\n*        LATRES                                                       *\n*                                                                     *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n* CALL   BAL   RETURN,LATRES(0,SBR)\n*              RESERVE ONE ENTRY IN LABEL ADDRESS TABLE\n*              AND CHECK IF OVERFLOW\n*\n         SPACE\nLATRES   EQU   *-SBRPOOL           RESERVE NEXT LAT-ENTRY\n         LH    R1,LN(0,WAREG)           GET CURRENT LN\n         LA    R1,4(0,R1)               ADD ONE ENTRY\n         STH   R1,LN(0,WAREG)           STORE NEW LN\n         SPACE\nLATOVFLO EQU   *-SBRPOOL           CHECK IF LAT-OVERFLOW\n         TM    LN(WAREG),X'F0'          IS LAT FULL\n         BCR   8,RETURN                 NO\n         ST    RETURN,LATRET            SAVE RETURN ADDRESS\n         BAL   RETURN,SERR1(SBR)        GENERATE ERROR PATTERN\n         DC    H'216'\n         SPACE\n         LA    R1,LATBEG                RESET POINTER\n         STH   R1,LN(0,WAREG)                         TO FIRST ENTRY\n         SPACE\n         L     RETURN,LATRET\n         BR    RETURN\n         SPACE\nLATRET   EQU   LDRET\n         SPACE 3\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*                                                                     *\n*        ARRAY AND PROCEDURE TEST                                     *\n*                                                                     *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n* CALL   BAL   RETURN,ARRTEST1(0,SBR)\n*\n         SPACE\nARRTEST1 EQU   *-SBRPOOL\n         ST    RETURN,SAVTARIT          SAVE RETURN\n         TM    0(OPDK),APIMASK          IS OPERAND API             5603\n         BCR   1,RETURN                 RETURN IF API\n         TM    1(OPDK),X'C0'                 PROCEDURE             0224\n         BC    9,*+12                                              0224\n         TM    1(OPDK),X'40'                 STANDARD PROCEDURE    0224\n         BZ    PROCTES1                      YES ERROR             0224\n         TM    0(OPDK),X'C0'            IDENTIFIER FROM ITAB\n         BCR   12,RETURN                NO RETURN\n         TM    1(OPDK),X'04'\n         BZ    PROCTEST                 NO ARRAY CONTINUE TEST\n         BAL   RETURN,SERR3(0,SBR)\n         DC    H'196'\nARRTEST3 L     RETURN,SAVTARIT          RESTORE RETURN\n         BR    RETURN\nPROCTEST  TM    1(OPDK),X'C0'           PROCEDURE\n         BCR   8,RETURN                 NO RETURN\n         TM    3(OPDK),X'F0'            PARAMETERLESS\n         BCR   8,RETURN                 YES RETURN\nPROCTES1 BAL   RETURN,SERR1(SBR)        ERROR 187\n         DC    H'187'\n         B     ARRTEST3\nARRTEST2 EQU   *-SBRPOOL\n         ST    RETURN,RETARR2\n         LA    OPDK,5(0,OPDK)\n         BCTR  OPTK,0\n         BAL   RETURN,ARRTEST1(0,SBR)\n         LA    OPTK,1(0,OPTK)\n         SH    OPDK,CON5(0,SBR)\n         L     RETURN,RETARR2\n         B     ARRTEST1(0,SBR)\n         SPACE\n         DS    0F\nRETARR2  DS    F\n         SPACE 3\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*                                                                     *\n*        OPERAND TEST                                                 *\n*                                                                     *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n* CALL   BAL   RETURN,OPDTESF(0,SBR)                                  *\n         SPACE 2\nOPDTESF  EQU   *-SBRPOOL           GIVE ERROR MESSAGE 162 IF OPERAND\n*                                  IS MISSING,STACK ALL PURPOUSE IDENT.\n*                                  AND RETURN VIA REG.RETURN IF NO\n*                                  ERROR RETURN VIA REG 3\nOPDTEST  EQU   OPDTESF\n         TM    HCOMPMOD(WAREG),X'01'     OPERAND PRESENT\n         BCR   1,R3                     YES,RETURN\n         ST    RETURN,STRETURN(WAREG)\n         BAL   RETURN,SERR4(SBR)        ERROR 162\n         DC    H'162'\n         L     RETURN,STRETURN(WAREG)\n         OI    HCOMPMOD(WAREG),X'01'    OPERAND SWITCH ON\n         B     STACKAPI(SBR)            STACK API RETURN DIRECT\nERR166   EQU   *-SBRPOOL\nBVB1     ST    RETURN,RETADR(0,WAREG)        STORE RETURN ADDRESS\n         TM    HCOMPMOD(WAREG),X'01'         OPDT\n         BZ    BYB2                          BRANCH IF FALSE\n         LA    OPDK,5(0,OPDK)                CLOPD\n         NI    HCOMPMOD(WAREG),X'FE'         OPDFL=FALSE\nBYB2     BAL   RETURN,SERR1(SBR)        ERROR 166\n         DC    H'166'\n         L     RETURN,RETADR(0,WAREG)        LOAD RETURN ADDRESS\n         BR    RETURN                        RETURN\n         TITLE 'IEX50, COMPILATION PHASE, DECISION MATRIXES'\nIEX50001 CSECT\n         SPACE\n*  DECISION MATRICIES\n         SPACE\nDECAREA  EQU   *                   START OF DECICION AREA\n         SPACE 2\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*                                                                     *\n*              PROGRAM CONTEXT COLUMN VECTOR                          *\n*                                                                     *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         DC    X'0A0A0A0A0A0A09120703030B000002020A0A0A0A0A0A080404'\n         DC    X'121212120512060A0A0A0A0A121201120C0D0E0F1110000000'\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*                                                                     *\n*              PROGRAM CONTEXT ROW VECTOR                             *\n*                                                                     *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         DC    X'ABABABABABABABABABAB853926131313ABABABABABAB72ABAB'\n         DC    X'ABABAB98ABABABABABABABAB00AB4C5FABABABABABAB000030'\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*                                                                     *\n*              PROGRAM CONTEXT MATRIX                                 *\n*                                                                     *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         DC    X'00010454545454545454545454545454540354'\n         DC    X'0001040407074B0707074B191810545453544B'\n         DC    X'00011D1D06084B290C404B191C54541054544B'\n         DC    X'00011A1A06084B290C404B171C17171754544B'\n         DC    X'00011A1A064B11290C404B121C12121254544B'\n         DC    X'00011A1A06084B290C404B121C12121254544B'\n         DC    X'1B1E1A1A1B131429151616141C14141454544B'\n         DC    X'5454545454545454555454541C545454545454'\n         DC    X'00011D1D06084B290C404B1A1C54515454544B'\n         DC    X'1F1E1F1F1F1F1F1F1F1F1F1F1C1F1F1F545416'\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*                                                                     *\n*              STATEMENT CONTEXT COLUMN VECTOR                        *\n*                                                                     *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nADRSTC   EQU   *\n         DC    X'090909090909010D030F0F0C0F0F0F0F0A0A0A0A0A0A060F0F'\n         DC    X'0708070B000F0C0A0A0A0A0A05020F040E0C0C0C0F0F000000'\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*                                                                     *\n*              STATEMENT CONTEXT ROW VECTOR                           *\n*                                                                     *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         DC    X'D0D0D0D0D0D0D0B03040D0D0D0D0D0D0D0D0D0D0D0D0D00060'\n         DC    X'8090A0D0D0D0D0D0D0D0D0D0D0D0D0D02050D0C07010000033'\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*                                                                     *\n*              STATEMENT CONTEXT MATRIX                               *\n*                                                                     *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         DC    X'22384B294B4B4B4B4B4B4B4B3E4B1C1B'\n         DC    X'22384B294B3B544B4B4B4B4B1B543B1B'\n         DC    X'224039294B394B4B4B21214B1B4B1C1B'\n         DC    X'22404B2926264B4B4B214B4B1B4B1C1B'\n         DC    X'5454543454345454545454541B543654'\n         DC    X'22403D294B3D4B4B4B21214B1B4B1C1B'\n         DC    X'4B4B4B294B4B284B4B4B4B1B1B4B1C1B'\n         DC    X'22404B294B2B4B2B4B214B2B1B4B1C1B'\n         DC    X'22404B294B4B4B4B2D214B1B1B4B1C1B'\n         DC    X'22404B294B2F4B4B4B214B2F1B4B1C1B'\n         DC    X'22404B294B314B4B4B2121311B4B1C1B'\n         DC    X'22404B2933334B4B4B214B4B1B4B1C1B'\n         DC    X'22404B294B4B544B4B214B4B1B241C1B'\n         DC    X'224B4B4B4B4B4B4B4B4B4B4B474B1C47'\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*                                                                     *\n*              EXPRESSION CONTEXT COLUMN VECTOR                       *\n*                                                                     *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nADREXC   EQU   *\n         DC    X'0B0B0C0C0C0D050F070F0F0F0F0F0F0F0E0E0E0E0E0E0F0F0F'\n         DC    X'0F0F0F0F08090A00020304010F060F0F0F0F0F0F0F0F000000'\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*                                                                     *\n*              EXPRESSION CONTEXT ROW VECTOR                          *\n*                                                                     *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         DC    X'A0A0B0B0B0C050E0E0E0E0E0E0E0E0E0D0D0D0D0D0D0E0E0E0'\n         DC    X'E0E0E0E06070800020304010E060E0E0E0E090E0E0E000003F'\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*                                                                     *\n*              EXPRESSION CONTEXT MATRIX                              *\n*                                                                     *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         DC    X'4B4D4D4D4D404D29494D4D424343434D'\n         DC    X'414C434343404C29494C4C424343434C'\n         DC    X'414C4C4343404C29494C4C424343434C'\n         DC    X'414C4C4C43404C29494C4C424343434C'\n         DC    X'414C4C4C4C404C29494C4C424343434C'\n         DC    X'4143434343404429501B1B424343431B'\n         DC    X'4143434343404B29414E56424343431B'\n         DC    X'4143434343404B29494B57424343431B'\n         DC    X'4143434343404F29414F48424343434F'\n         DC    X'4B3F3F3F3F403F29493F3F3F3F433F3F'\n         DC    X'4B454545454045294945454543434545'\n         DC    X'4B454545454045294945454545434545'\n         DC    X'4B454545454045294945454545454545'\n         DC    X'4B454545454045294945454243434A45'\n         DC    X'4143434343404629464B464243434346'\n         TITLE 'IEX50, COMPILATION PHASE, WORKAREA DSECT'\nCPWORKAR DSECT\n         SPACE\n* DUMMY CONTROL SECTION TO PROVIDE ADDRESSABILITY OF WORKAREA\n*        AUG 16 1966\n         SPACE\nWKST     EQU   *\n         DS    0F                       WORKAREA START\nSAVEAREA EQU   *-WKST                               ***\n         DS    F\n         DS    F         HIGHER LEVEL SAVEAREA ADDR   *\n         DS    F         LOWER LEVEL SAVEAREA ADDR    *\n         DS    F         RETURN ADDR                  *\n         DS    F         ENTRY POINT ADDR             *\nSVEREG0  EQU   *-WKST    ***                          *\n         DS    F\nSVEREG1  EQU   *-WKST      *                          *\n         DS    F\nSVEREG2  EQU   *-WKST      *                          *\n         DS    F\nSVEREG3  EQU   *-WKST      *                          *  SAVEAREA\n         DS    F\nSVEREG4  EQU   *-WKST      *                          *\n         DS    F\nSVEREG5  EQU   *-WKST      *                          *\n         DS    F\nSVEREG6  EQU   *-WKST      * SAVEAREA FOR REGISTERS   *\n         DS    F\nSVEREG7  EQU   *-WKST      *                          *\n         DS    F\nSVEREG8  EQU   *-WKST      *                          *\n         DS    F\nSVEREG9  EQU   *-WKST      *                          *\n         DS    F\nSVEREG10 EQU   *-WKST      *                          *\n         DS    F\nSVEREG11 EQU   *-WKST      *                          *\n         DS    F\nSVEREG12 EQU   *-WKST    ***                        ***\n         DS    A\n         SPACE\nLINADD   EQU   *-WKST    ***\n         DS    A\n         DS    A           *\n         DS    A           *\n         DS    A           *\nINADD    EQU   *-WKST      *  ADDRESSES OF DATA CONTROL BLOCKS\n         DS    A\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IEX51": {"ttr": 6153, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x98\\x01/\\x00\\x98\\x01/\\x16!\\x04N\\x04N\\x00\\x00\\xd6\\xf3\\xf6\\xf0`\\xf2\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1998-01-12T00:00:00", "modifydate": "1998-01-12T16:21:00", "lines": 1102, "newlines": 1102, "modlines": 0, "user": "O360-20"}, "text": " TITLE 'IEX51, TERMINATION OF COMPILATION'\n*                                                                     *\n*STATUS: CHANGE LEVEL 000                                             *\n*                                                                     *\n*FUNCTION/OPERATION:                                                  *\n*   CSECT IEX51000: THE TABLES NEEDED AT OBJECT TIME ARE PREPARED AND *\n*   INCLUDED IN THE OBJECT MODULE. THEY ARE PROGRAM BLOCK TABLE, LABEL*\n*   ADDRESS TABLE, AND DATA SET TABLE. ESD-CARDS FOR THE REQUIRED     *\n*   LIBRARY ROUTINES ARE GENERATED. THE INFORMATION REQUIRED TO START *\n*   THE EXECUTION, INCLUDING THE END-CARD, IS GENERATED. A TABLE      *\n*   CONTAINING THE DSA-SIZES FOR THE PROGRAM BLOCKS IS PREPARED AND   *\n*   TOGETHER WITH THE OBJECT MODULE SIZE PUT OUT TO SYSPRINT.         *\n*   CSECT IEX60000: THE ERROR PATTERNS GENERATED DURING COMPILATION   *\n*   PHASE ARE HANDLED AND THE CORRESPONDING DIAGNOSTIC MESSAGES ARE   *\n*   GENERATED.                                                        *\n*   CSECT IEX51002: ALL AREAS RESERVED ARE RELEASED AND THE DATA      *\n*   CONTROL BLOCKS NOT CLOSED EARLIER ARE CLOSED, THE ORIGINAL PICA IS*\n*   RESTORED, THE RETURN CODE IS FOUND, AND CONTROL IS GIVEN TO       *\n*   COMPILER DIRECTORY, IEX00.                                        *\n*                                                                     *\n*ENTRY POINTS:                                                        *\n*        IEX51000 - NORMAL END OF COMPILATION.    XCTL EP=IEX51000    *\n*   THE MODULE IS NORMALLY ENTERED FROM IEX40.                        *\n*        IEX51ER1 - ABNORMAL END OF COMPILATION.  XCTL EP=IEX51ER1    *\n*   IS USED BY IEX40 AND IEX50.                                       *\n*        IEX51ER2 - ABNORMAL END OF COMPILATION.  XCTL EP=IEX51ER2    *\n*   IS USED BY IEX40.                                                 *\n*        IEX51002 - ABNORMAL END OF COMPILATION.  XCTL EP=IEX51002    *\n*   IS USED BY IEX00, IEX21, AND IEX31.                               *\n*                                                                     *\n*INPUT: N/A                                                           *\n*                                                                     *\n*OUTPUT: PART OF THE OBJECT MODULE IS GENERATED AND PUT OUT ON SYSLIN *\n*   AND/OR SYSPUNCH.                                                  *\n*   STORAGE REQUIREMENTS AND DIAGNOSTIC MESSAGES ARE PUT OUT ON       *\n*   SYSPRINT.                                                         *\n*                                                                     *\n*EXTERNAL ROUTINES: THE PRINT ROUTINE IN IEX00 IS USED.               *\n*                                                                     *\n*EXIT-NORMAL: CONTROL IS GIVEN TO COMPILER DIRECTORY, IEX00, BY MEANS *\n*   OF THE RETURN MACRO INSTRUCTION AT LOCATION RETURN.               *\n*                                                                     *\n*EXIT-ERROR: AFTER PROGRAM INTERRUPTS AND I/O-ERRORS THE MODULE GETS  *\n*   CONTROL BACK AND EXITS NORMALLY.                                  *\n*                                                                     *\n*TABLES/WORKAREAS: THE MESSAGE TEXTS WITH CORRESPONDING ADDRESS TABLE *\n*   ARE IN THE LOAD MODULE IEX51M.                                    *\n*   THE ERROR MESSAGE EDITING ROUTINE, CSECT IEX60000, ALSO USES THE  *\n*   FOLLOWING TABLES:                                                 *\n*   WINTEBC   FOR TRANSLATION OF INTERNAL CHARACTERS TO EBCDIC        *\n*   WSYMBSRC  FOR TRANSLATION OF                                      *\n*   WSYMBSTK                     INTERNAL SYMBOLS TO EBCDIC           *\n*   WORDSEBC  FOR TRANSLATION OF COMPOUND SYMBOLS IF SOURCE IN EBCDIC *\n*   WORDSISO  FOR TRANSLATION OF COMPOUND SYMBOLS IF SOURCE IN ISOCODE*\n*   WEBCDIC   FOR TRANSLATION EBCDIC-EBCDIC                           *\n*   A WORKAREA OF 270 BYTES, WAREA, IS USED FOR BUILDING THE MESSAGES.*\n*                                                                     *\n*   FOR THE EXTERNAL REFERENCES TO THE LIBRARY ROUTINES ONE OF THE    *\n*   TABLES SHRTAB AND LNGTAB, CONTAINING THE MODULE NAMES, IS USED.   *\n*   THE GENERATE ROUTINE USES THREE TABLES, ESDT, TXTT, AND RLDT, FOR *\n*   GENERATION OF THE DIFFERENT TYPES OF OBJECT RECORDS.              *\n*                                                                     *\n*   THE PART OF COMMON WORKAREA STARTING AT DCBUT1 IS INITIALIZED BY  *\n*   THE LOAD MODULE IEX40 AND IS USED BY THIS AND THE PRECEDING LOAD  *\n*   MODULE.                                                           *\n*                                                                     *\n*ATTRIBUTES: NONE.                                                    *\n*                                                                     *\n*NOTES: CHARACTER CODE DEPENDENCE:                                    *\n*   CSECT IEX51000: THE OPERATION OF THE ROUTINES 'GENERATE' AND      *\n*   'PRINT STORAGE REQUIREMENTS' DEPENDS UPON AN INTERNAL REPRESENTA- *\n*   TION OF THE EXTERNAL CHARACTER SET WHICH IS EQUIVALENT TO THE ONE *\n*   USED AT ASSEMBLY TIME.                                            *\n*                                                                     *\n*   CSECT IEX60000: FOR THE BUILDING OF A MESSAGE (CODE PART BETWEEN  *\n*   COT03 AND COT12) THE FOLLOWING APPLIES:                           *\n*   IN CASE NO SOURCE INFORMATION IS TO BE INSERTED (COT31), OR IF    *\n*   THE INFORMATION IS EBCDIC-CHARACTERS (COT07), THE OPERATION OF    *\n*   CSECT IEX60000 DEPENDS UPON AN INTERNAL REPRESENTATION OF THE     *\n*   EXTERNAL CHARACTER SET WHICH IS EQUIVALENT TO THE ONE USED AT     *\n*   ASSEMBLY TIME.                                                    *\n*   IF THE SOURCE INFORMATION TO BE INSERTED IS INTERNAL CHARACTERS   *\n*   (COT33) THE OPERATION OF CSECT IEX60000 DEPENDS UPON A TRANSLATION*\n*   FROM THE INTERNAL REPRESENTATION TO THE EBCDIC CHARACTER SET BY   *\n*   MEANS OF THE TABLE 'WINTEBC'.                                     *\n*   IF THE SOURCE INFORMATION TO BE INSERTED IS INTERNAL ALGOL SYMBOLS*\n*   (COT10) THE OPERATION OF CSECT IEX60000 DEPENDS UPON A TRANSLATION*\n*   FROM THE INTERNAL REPRESENTATION TO THE EBCDIC CHARACTER SET BY   *\n*   MEANS OF THE TABLES 'WSYMBSTK'/'WSYMBSRC' AND 'WORDSISO'/         *\n*   'WORDSEBC'.                                                       *\n*   FOR THE OUTPUT OF A MESSAGE (CODE PART BETWEEN COT12 AND COT21)   *\n*   THE FOLLOWING APPLIES:                                            *\n*   WHEN A MESSAGE HAS BEEN BUILT IN EBCDIC, AN EBCDIC-EBCDIC TRANSLA-*\n*   TION IS PERFORMED BEFORE OUTPUT BY MEANS OF THE TABLE 'WEBCDIC'.  *\n*   THUS THE OUTPUT MAY BE MODIFIED BY MAKING CHANGES IN THIS TABLE.  *\n*                                                                     *\n*   THE OPERATION OF THE OTHER PARTS DOES NOT DEPEND UPON A PARTICULAR*\n*   INTERNAL REPRESENTATION OF THE EXTERNAL CHARACTER SET.            *\n*                                                                     *\n*   AT SYSTEM GENERATION THIS MODULE WILL BE LINKED TOGETHER WITH     *\n*   THE MODULE IEX51M TO FORM THE MODULE IEX51 IN LINKLIB.            *\n*                                                                     *\n*   THIS MODULE IS ONLY INTENDED TO BE EXECUTED IN CONNECTION         *\n*   WITH THE OTHER MODULES OF THE ALGOL COMPILER. IN PARTICULAR IT    *\n*   REQUIRES THE COMMON WORKAREA.                                     *\n*                                                                     *\n         EJECT\nIEX51000 CSECT\n*0057056200                                                        1511\n         SPACE 2\n* REGISTER DEFINITIONS\n         SPACE\nWRK      EQU   1\nRAREA    EQU   1\nRINFO    EQU   1                        ADDRESSES INFO FOR ERROR ED\nRCOT     EQU   2                        ADDRESSES ERROR ED ROUTINE\nWRK1     EQU   2\nWRK2     EQU   3\nWRK3     EQU   4\nWRK4     EQU   5\nRMDSN    EQU   5\nRPRPT    EQU   6\nWRK8     EQU   6\nRIO      EQU   7\nWRK5     EQU   7\nRZERO    EQU   8\nWRK9     EQU   8\nWRK6     EQU   9\nRBASE    EQU   10\nWRK7     EQU   11\nRWRKA    EQU   13\nRET      EQU   14\nRENTRY   EQU   15\n         SPACE 2\n* OTHER DEFINITIONS\n         SPACE\nRASLGT   EQU   2048                     LENGTH OF RETURN ADDRESS STACK\nLPGCF    EQU   28                       LENGTHOF PUT/GET CONTROL FIELD\n         SPACE 2\n* ENTRY POINTS\n         SPACE\n         ENTRY IEX51ER1\n         ENTRY IEX51ER2\n         EJECT\n         USING *,RBASE\n         USING WORKAREA,RWRKA\n         SPACE\n         LR    RBASE,RENTRY\n         SR    RZERO,RZERO\n         SPACE 2\nTRM1     EQU   *                   TEST MODE\n         LA    WRK1,TRMERR1             GIVE DIRECTORY\n         ST    WRK1,ERET                               RETURN ADDRESS\n         OI    HCOMPMOD+2,NOSC          INDICATE NO SC AVAILABLE\n         TM    HCOMPMOD,X'80'           COMPILE MODE\n         BO    TRM10                    NO, BYPASS ALL CODE GENERATION\n         TM    HCOMPMOD+1,X'60'         ARE NOLOAD AND NODECK SPECIFIED\n         BO    TRM10                    YES, NO CODE GENERATION\n         SPACE 2\nTRM8     EQU   *                   GENERATE LAT, TXT-CARDS\n         ST    RPRPT,PRPTAR             SET\n         TM    PRPTAR+3,X'02'               PRPOINTER\n         BZ    TRM4                                   TO\n         LA    WRK1,ZEROHW              FULL-\n         BAL   RET,GENTXTS                   WORD\n         DC    H'2'                               BOUNDARY\nTRM4     ST    RPRPT,ALAT               SAVE PRPOINTER AT LAT-BEGIN\n         SPACE\n         L     WRK1,LATAB               GET ADDRESS OF LAT\n         LH    WRK2,LN                  GET DISPLACEMENT OF LAST LABEL\n         LA    WRK2,4(0,WRK2)           LENGTH OF LAT\n         STH   WRK2,*+8\n         BAL   RET,GENTXTS              GENERATE TXT-CARDS\nTRM39    DC    H'0'                     LENGTH OF LAT\n         SPACE 2\nTRM40    EQU   *                   RLD-CARDS FOR LAT\n         LH    WRK2,TRM39               GET LENGTH OF LAT\n         LA    WRK3,LATBEG+4            GET LENGTH OF 1ST PART\n         SR    WRK2,WRK3                GET LENGTH OF LAST PART\n         BC    12,TRM42                 BRANCH IF NOT GRT ZERO\n         STH   WRK2,TRM41               STORE LENGTH OF LAST PART\n         SPACE\n         L     WRK1,ALAT                GET PRPOINTER AT LAT BEGIN\n         LA    WRK1,LATBEG+4(0,WRK1)    PRPOINTER AT LAST PART\n         BAL   RET,GENRLD               GENERATE RLD-CARD\nTRM41    DC    H'0'                     LENGTH OF LAST PART\n         DC    H'1'\n         DC    H'1'\n         SPACE 2\nTRM42    EQU   *                   ESD-CARDS FOR LAT\n         L     WRK4,LATAB               GET ADDRESS OF LAT\n         LA    WRK5,LATNR               GET NR OF ENTRIES FOR ST FUNCS\n         LA    WRK6,SHRTAB              ADDRESS TABLE FOR SHORT PREC\n         TM    HCOMPMOD,X'02'           TEST PRECISION\n         BZ    *+8                      SHORT\n         LA    WRK6,LNGTAB              LONG, CHANGE ADDRESS\n         SPACE\nTRM44    CLI   0(WRK4),X'00'            IS ROUTINE USED\n         BNE   TRM45                    NO\n         MVC   TRM43+3(5),0(WRK6)       YES, MOVE NAME TO ESD CALL\n         SPACE\n         BAL   WRK1,GENESD              GENERATE ESD-CARD\nTRM43    DC    CL8'IHI     '\n         DC    X'02'\n         SPACE\nTRM45    LA    WRK4,4(0,WRK4)           STEP\n         LA    WRK6,5(0,WRK6)                ADDRESSES\n         BCT   WRK5,TRM44               HANDLE NEXT ENTRY IF ANY\n         SPACE 2\nTRM46    EQU   *                   RLD-CARDS FOR ESD-ENTRIES IN LAT\n         L     WRK7,ALAT                GET PRPOINTER AT LAT BEGIN\n         L     WRK4,LATAB               GET ADDRESS OF LAT\n         LA    WRK5,LATNR               GET NR OF ENTRIES FOR ST FUNCS\n         LA    WRK6,1                   INIT REG FOR R-ESID FOR RLDCALL\n         SPACE\nTRM49    CLI   0(WRK4),X'00'            IS ROUTINE USED\n         BNE   TRM48                    NO\n         LA    WRK6,1(0,WRK6)           YES, GET ESID FOR R\n         STH   WRK6,TRM47               GIVE TO RLD-CALL\n         SPACE\n         LR    WRK1,WRK7\n         BAL   RET,GENRLD               GENERATE RLD-CARD\n         DC    H'4'                     LENGTH OF ADDRESS TABLE\nTRM47    DC    H'0'                     ESID OF RELOC FACTOR R\n         DC    H'1'                     ESID OF POSITION IDENTIFIER P\n         SPACE\nTRM48    LA    WRK7,4(0,WRK7)           STEP\n         LA    WRK4,4(0,WRK4)                ADDRESSES\n         BCT   WRK5,TRM49               HANDLE NEXT ENTRY IF ANY\n         SPACE 2\nTRM2     EQU   *                   GENERATE PBTAB, 4TH VERSION, TXTCRDS\n         ST    RPRPT,APBT               STORE PRPOINTER\n         LA    WRK2,PBTAB3+4            GET START-\n         L     WRK3,APBTAB4                       ADDRESSES\n         ST    RZERO,0(0,WRK3)          SET ZEROES\n         LH    WRK1,PBN                 GET NR OF PROGRAM BLOCKS\n         SPACE\n         LA    WRK3,4(0,WRK3)           STEP ADDRESS\n         MVC   0(4,WRK3),PIDENT         INSERT PROGRAM IDENTIFICATION\nTRM5     ST    RZERO,4(0,WRK3)          INSERT ZEROES\n         LA    WRK3,8(0,WRK3)           STEP ADDRESS\n         L     WRK7,0(0,WRK2)           TAKE PBTAB3 ENTRY\n         LH    WRK4,ONEENTRY            ADD\n         SLL   WRK4,16                      SIZE OF\n         AR    WRK7,WRK4                            ONE ENTRY\n         ST    WRK7,0(0,WRK3)                                 IN DSA\n         LA    WRK2,4(0,WRK2)           STEP ADDRESS\n         BCT   WRK1,TRM5                MOVE NEXT IF ANY\n         LA    WRK3,4(0,WRK3)\n         SPACE\n         LH    WRK1,KBN                 GET NUMBER\n         LTR   WRK1,WRK1                           OF LAST CONST BLOCK\n         BC    8,TRM7                   NO MORE BLOCK THAN NR ZERO\n         SPACE\n         SH    WRK1,PBN                 GET NR OF CONST BLKS EXCEPT 0\n         LH    WRK2,FOURK               GET LENGTH OF CONST BLOCK\n         LR    WRK4,WRK2\n         ST    RZERO,4(0,WRK3)          INSERT ZEROES\nTRM6     ST    WRK2,0(0,WRK3)           STORE DISP OF CONST BLOCK\n         LA    WRK3,8(0,WRK3)           STEP ADDRESS\n         AR    WRK2,WRK4                INCREASE DISPLACEMENT\n         BCT   WRK1,TRM6                STORE NEXT IF ANY\n         SPACE\nTRM7     L     WRK1,APBTAB4             GET ADDR OF PBTAB4\n         LR    WRK4,WRK3                COMPUTE\n         SR    WRK4,WRK1                        LENGTH OF\n         STH   WRK4,*+8                                   PBTAB4\n         BAL   RET,GENTXTS              GENERATE TXT-CARDS\n         DC    H'0'                     LENGTH OF PBTAB4\n         SPACE 2\nTRM52    EQU   *                   RLD-CARDS FOR PBTAB4\n         L     WRK5,APBT                GET PRPOINTER AT PBTAB4 BEGIN\n         B     TRM53                    GENERATE RLD-CARD\nTRM70    NI    TRM71+1,X'0F'            CHANGE BRANCH CONDITION\n         SPACE\n         LH    WRK4,KBN                 GET NR OF LAST CONST BLOCK\n         CR    RZERO,WRK4               IS IT ZERO\n         BE    TRM10                    YES\n         LH    WRK1,PBN                 NO, GET NR OF\n         SR    WRK4,WRK1                              CONST BLKS EXC 0\n         SLL   WRK1,3                   GET PRPOINTER\n         LA    WRK5,8(WRK1,WRK5)            AT 2ND CONST BLK       1511\n         SPACE\nTRM53    LR    WRK1,WRK5\n         BAL   RET,GENRLD\n         DC    H'4'\n         DC    H'1'\n         DC    H'1'\n         SPACE\nTRM71    BC    15,TRM70                 BRANCH AFTER FIRST CARD\n         LA    WRK5,8(0,WRK5)           STEP ADDRESS\n         BCT   WRK4,TRM53               HANDLE NEXT ENTRY IF ANY\n         SPACE 2\nTRM10    EQU   *                   CONSTRUCT DATA SET TABLE\n         LA    WRK1,DSTAB               GET ADDR OF DSTAB\n         ST    RPRPT,DSTABPRP           STORE PRPOINTER\n         LA    RIO,IOTAB                GET ADDR OF IOTAB\n         SPACE\n         LA    RMDSN,15                 LOAD MAX DS NUMBER\n         TM    16(RIO),X'FF'            HAS UNDET DS NR OCCURRED\n         BC    7,TRM12-2                YES, MDSN=15\n         LA    WRK2,15                      DETER-\n         LA    WRK7,1\nTRM11    LA    WRK3,0(WRK2,RIO)\n         CLI   0(WRK3),X'00'\n         BNE   *+12                                    MAX\n         BCTR  WRK2,0                                      DS\n         CR    WRK2,WRK7\n         BNE   TRM11\n         LR    RMDSN,WRK2                                     NR\n         STH   WRK2,MDSN                                         USED\n         BCTR  RMDSN,0                  GET MAX DS NR MINUS ONE\n         SPACE\nTRM12    LA    WRK2,36                  CALC\n         MH    WRK2,MDSN                     LGT OF DSTAB\n         LA    WRK2,40(0,WRK2)                            WITHOUT PGCF\n         STH   WRK2,DSTABLGT\n         LA    WRK2,0(WRK2,RPRPT)       STORE\n         ST    WRK2,0(0,WRK1)                 PGCF-POINTER\n         SPACE\n         SR    WRK7,WRK7                LOAD DS NR FOR ERROR PATTERN\n         TM    0(RIO),X'70'             CORRECT SPEC FOR SYSIN\n         LA    RET,TRM19                GET RETURN ADDR FOR ERROR RTN\n         BC    7,ERR188                 NO,GENERATE ERROR PATTERN\n         MVC   4(36,WRK1),DSTEM         YES, INSERT STANDARD MASK\n         LA    WRK7,1                   LOAD DS NR FOR ERROR PATTERN\n         TM    1(RIO),X'A0'             CORRECT SPEC FOR SYSPRINT\n         BC    7,ERR188                 NO, GENERATE ERROR PATTERN\n         MVC   40(36,WRK1),DSTEM        YES, INSERT STANDARD MASK\n         MVI   66(WRK1),X'02'           CHANGE DS FIELD\n         MVI   74(WRK1),X'02'\n         SPACE\nTRM19    LR    WRK2,RMDSN               GET MAX DS NR MINUS ONE\n         LTR   WRK2,WRK2                IS RESULT ZERO\n         BC    8,TRM22                  YES, BYPASS MANIP ON BYTES 2-15\n         NI    16(RIO),X'EF'            RESET SYSACT8 BIT\n         TM    16(RIO),X'01'            TEST IF PRE.COMP. PROCEDURE\n         BZ    TRM192                   NO\n         LA    WRK3,76(0,WRK1)          GET ADDR OF DS2 IN DSTAB\nTRM191   MVC   0(36,WRK3),DSTEM         MOVE STANDARD MASK\n         MVI   26(WRK3),X'42'           CHANGE DS FIELD\n         MVI   34(WRK3),X'42'\n         LA    WRK3,36(0,WRK3)          NEXT DS NR IN DSTAB\n         BCT   WRK2,TRM191\n         B     TRM22\nTRM192   TM    16(RIO),X'FF'            IS BYTE 16 ZERO\n         BZ    TRM15                    YES\nTRM14    LA    WRK3,1(WRK2,RIO)         NO, OR\n         TM    0(WRK3),X'10'                   BYTE 16\n         BO    *+10                                    INTO BYTES NOT\n         OC    0(1,WRK3),16(RIO)        CONTAINING\n         BCT   WRK2,TRM14                          SYSACT8 INDICATION\n         SPACE\nTRM15    LR    WRK2,RMDSN               GET MAX DS NR MINUS ONE\nTRM16    LA    WRK3,1(WRK2,RIO)         INDICATE\n         TM    0(WRK3),X'C0'                     SYSACT4/13\n         BC    14,*+8                                       IN BYTES\n         OI    0(WRK3),X'20'            WITH INPUT\n         BCT   WRK2,TRM16                          AND OUTPUT INDIC\n         SPACE\n         LR    WRK2,RMDSN               GET MAX DS NR MINUS ONE\nTRM17    LA    WRK3,1(WRK2,RIO)\n         LA    WRK7,1(0,WRK2)           LOAD DS NR FOR ERROR PATTERN\n         TM    0(WRK3),X'10'            IS SYSACT8 INDICATED\n         BZ    TRM18                    NO\n         TM    0(WRK3),X'A0'            YES, IS INPUTOR SYSACT4/13 IND\n         BZ    *+12                     NO\n         LA    RET,*+12                 YES, GENERATE\n         B     ERR188                                 ERROR PATTERN\n         NI    0(WRK3),X'F7'            RESET UNDET SYSACT BIT\nTRM18    BCT   WRK2,TRM17               EXAMINE NEXT BYTE IF ANY\n         SPACE\n         LR    WRK2,RMDSN               GET MAX DS NR MINUS ONE\n         LA    WRK3,76(0,WRK1)          GET ADDR OF DS2 IN DSTAB\n         LA    WRK,2(0,RIO)             GET ADDR OF 2ND BYTE IN IOTAB\nTRM20    MVC   0(36,WRK3),DSTEM         MOVE STANDARD MASK\n         TM    0(WRK),X'28'             IS SYSACT4/13 OR UND SA IND\n         BC    7,TRM21                  YES\n         TM    0(WRK),X'40'             NO, IS OUTPUT INDICATED\n         BZ    TRM211\n         MVI   26(WRK3),X'02'           YES, CHANGE DS FIELD\n         MVI   34(WRK3),X'02'\n         B     TRM211\nTRM21    TM    0(WRK),X'40'             IS OUTPUT INDICATED\n         BO    *+16                     YES\n         MVI   26(WRK3),X'40'           NO, CHANGE DS FIELD\n         MVI   34(WRK3),X'40'\n         B     *+12\n         MVI   26(WRK3),X'42'           CHANGE DS FIELD\n         MVI   34(WRK3),X'42'\nTRM211   LA    WRK3,36(0,WRK3)          NEXT DS NR IN DSTAB\n         LA    WRK,1(0,WRK)             NEXT BYTE IN IOTAB\n         BCT   WRK2,TRM20\n         SPACE\nTRM22    TM    17(RIO),X'FF'            IS BYTE 17 ZERO\n         BZ    TRM27                    YES\n         LH    WRK2,DSTABLGT            NO, GET ADDRESS\n         LA    WRK2,0(WRK2,WRK1)                        OF PGCFIELD\n         MVI   0(WRK2),X'00'            INSERT ZEROES\n         MVC   1(27,WRK2),0(WRK2)                     IN PGCF\n         LA    WRK3,2048                INITIATE\n         ST    WRK3,16(0,WRK2)                   BE-FIELD\n         B     TRM23\n         SPACE\nTRM27    MVI   0(WRK1),X'80'            INDICATE NO PUT/GET\n         SPACE 2\nTRM23    EQU   *                   GENERATE DSTABLE, TXT-CARDS\n         TM    HCOMPMOD,X'80'           IS IT COMPILE MODE\n         BO    TRM37                    NO, BYPASS CODE GENERATION\n         TM    HCOMPMOD+1,X'60'         ARE NOLOAD AND NODECK SPECIFIED\n         BO    TRM37                    YES, NO CODE GENERATION\n         TM    HCOMPMOD,PROC            IS IT PROCEDURE COMPILATION\n         BO    TRM24                    YES\n         SPACE\n         LH    WRK2,DSTABLGT            GET LGTH OF DSTAB WITHOUT PGCF\n         CLI   0(WRK1),X'80'            IS THERE A PGCF\n         BE    *+8                      NO\n         LA    WRK2,LPGCF(0,WRK2)       YES,  ADD PGCF-LENGTH\n         STH   WRK2,*+8                 STORE LENGTH IN CALLING SEQ\n         BAL   RET,GENTXTS              GENERATE TXT-CARDS\n         DC    H'0'                     LENGTH OF DSTAB\n         SPACE 2\nTRM32    EQU   *                   RLD-CARD FOR PGCF-ADDRESS IN DSTAB\n         L     WRK1,DSTABPRP            GET PRPOINTER AT DSTAB BEGIN\n         BAL   RET,GENRLD               GENERATE RLD-CARD\n         DC    H'4'                     LENGTH OF ADDRESS\n         DC    H'1'\n         DC    H'1'\n         SPACE 2\nTRM24    EQU   *                   GENERATE TXT-CARDS, ADR TABLE\n         MVC   ASTART(3),PRPT+1         GET PRPOINTER AT 1ST INSTR\n         TM    HCOMPMOD,X'02'           TEST PRECISION\n         BZ    *+8                      SHORT\n         MVI   SW,X'00'                 LONG, CHANGE MASK\n         ST    RPRPT,ADRPRP             STORE PRPOINTER AT ADR TABLE\n         LA    WRK1,APBT                GET ADDRESS OF TEXT\n         BAL   RET,GENTXTS\n         DC    H'12'                    LENGTH OF TEXT\n         SPACE 2\nTRM28    EQU   *                   ESD-CARD FOR FSA-ADDRESS\n         TM    HCOMPMOD,PROC            IS IT PROCEDURE COMPILATION\n         BO    TRM54                    YES\n         BAL   WRK1,GENESD              GENERATE ESD-CARD\nTRM29    DC    C'IHIFSAIN'\n         DC    X'0200'\n         SPACE 2\nTRM54    EQU   *                   RLD-CARDS FOR ADDRESS TABLE\n         L     WRK1,ADRPRP              GET PRPOINTER AT ADDRESS TABLE\n         BAL   RET,GENRLD               GENERATE RLD-CARDS\n         DC    H'12'\n         DC    H'1'\n         DC    H'1'\n         SPACE 2\nTRM25    EQU   *                   ESD-CARD, LD ENTRY, FOR ENTRY INFO\n         TM    HCOMPMOD,PROC            IS IT PROCEDURE COMPILATION\n         BO    TRM35                    YES, BYPASS NEXT TWO CARDS\n         SPACE\n         MVC   TRM26(3),ADRPRP+1        MOVE PRPOINTER TO CALL\n         BAL   WRK1,GENESD\n         DC    CL8'IHIENTIF'            NAME\n         DC    X'01'\nTRM26    DC    X'000000'                PRPOINTER\n         DC    C' '\n         DC    X'000001'\n         SPACE 2\nTRM56    EQU   *                   ESD-CARD, LD ENTRY, FOR DSTAB\n         MVC   TRM57(3),DSTABPRP+1      MOVE PRPOINTER TO CALL\n         BAL   WRK1,GENESD\n         DC    CL8'IHIDSTAB'            NAME\n         DC    X'01'\nTRM57    DC    X'000000'                PRPOINTER\n         DC    C' '\n         DC    X'000001'\n         SPACE 2\nTRM35    EQU   *                   GENERATE END-CARD\n         LA    TYPER,ENDATA             GIVE ADDRESS OF DATA\n         OI    GEN31+1,X'F0'            CHANGE BRANCH CONDITION\n         B     GEN3                     GENERATE END-RECORD\nTRM36    ST    RPRPT,28(0,OUTAREA)      STORE LENGTH OF CSECT IN ENDREC\n         TM    HCOMPMOD,PROC            IS IT PROCEDURE COMPILATION\n         BO    TRM34                    YES, MODIFY END-RECORD\n         MVC   16(8,OUTAREA),TRM29      STORE ENTRY POINT IN END RECORD\n         B     TRM33\nTRM34    MVC   5(3,OUTAREA),ADRPRP+1    ADDRESS TABLE IS ENTRY POINT\n         MVC   14(2,OUTAREA),TRM32+10   GET ESID FOR ENTRY POINT\nTRM33    TM    HCOMPMOD+1,X'60'         BOTH SYSLIN AND SYSPUNCH\n         BC    7,TRM51                  NO\n         L     WRK1,OUTAREA2            MOVE END-RECORD\n         MVC   0(80,WRK1),0(OUTAREA)                    TO PUNCH BUFFER\n         EJECT\nTRM51    EQU   *                   PRINT STORAGE REQUIREMENTS\n         MVI   PAGEHEAD+2,C' '          BLANK LIST-\n         MVC   PAGEHEAD+3(81),PAGEHEAD+2           HEADING 1\n         MVC   PAGEHEAD+35(30),HD       PUT HEADING 1\n         MVI   PAGEHEAD,X'01'           FOR LINE COUNT\n         MVI   PAGEHEAD+1,X'09'\n         MVI   PAGEHEAD+94,C' '         BLANK\n         MVC   PAGEHEAD+95(89),PAGEHEAD+94    HEADING 2\n         MVI   PAGEHEAD+186,X'FF'       NO HEADING 3\n         MVI   LINCNT,X'7F'             NEW PAGE\n         SPACE\n         CVD   RPRPT,DEC                CONVERT LENGTH OF OBJECT MODULE\n         BAL   RET,EDNR                 EDIT\n         SPACE\n         BAL   RET,PRINTT               OBTAIN OUTPUT BUFFER\n         BCTR  RAREA,0                  SPACE\n         MVI   0(RAREA),X'11'                 AFTER\n         LA    RAREA,1(0,RAREA)                     THIS LINE\n         MVC   0(19,RAREA),OBJ          MOVE FIRST TEXT PART\n         LA    WRK1,L'EDAREA            FIND\n         LA    WRK2,EDAREA                   FIRST\nTRM55    CLI   0(WRK2),C' '                        SIGNIFICANT\n         BNE   TRM58                                           DIGIT\n         LA    WRK2,1(0,WRK2)           TEST\n         BCT   WRK1,TRM55                    NEXT\n         MVI   19(RAREA),C'0'           IF NO SIGNIFICANT DIGIT FOUND\n         B     TRM59\nTRM58    BCTR  WRK1,0                   MOVE\n         STC   WRK1,*+5                      NUM-\n         MVC   19(0,RAREA),0(WRK2)               BER\nTRM59    LA    RAREA,1(WRK1,RAREA)      MOVE SECOND\n         MVC   19(7,RAREA),BYT                     TEXT PART\n          SPACE\n         BAL   RET,PRINTT               OBTAIN OUTPUT BUFFER\n         BCTR  RAREA,0                  SPACE\n         MVI   0(RAREA),X'11'                 ONE LINE\n         MVC   1(23,RAREA),DSA          SECOND PRINT LINE\n         BAL   RET,PRINTT               OBTAIN OUTPUT BUFFER\n         BCTR  RAREA,0                  SPACE\n         MVI   0(RAREA),X'11'                 ONE LINE\n         LA    WRK1,5                   GET NR OF ENTRIES IN ONE LINE\nTRM60    MVC   3(11,RAREA),BLBY         BUILD\n         LA    RAREA,18(0,RAREA)              THIRD\n         BCT   WRK1,TRM60                           PRINT LINE\n         SPACE\n         BAL   RET,PRINTT\n         SPACE\n         L     WRK2,APBTAB4             INITIATE\n         LH    WRK9,PBN                          REGISTERS\n         SR    WRK3,WRK3                                   FOR TABLE\nTRM62    LA    WRK1,5                   INITIATE FOR EACH PRINT LINE\n         SPACE\nTRM61    LA    WRK4,L'EDAREA            INITIATE\n         SR    WRK6,WRK6                         FOR\n         LA    WRK5,EDAREA                           EACH\n         LA    WRK3,1(0,WRK3)                             ENTRY\n         SPACE\n         CVD   WRK3,DEC                 CONVERT\n         UNPK  BLNR(3),DEC+6(2)                 AND MOVE\n         MVZ   BLNR+2(1),BLNR+1                          BLOCK\n         MVC   2(3,RAREA),BLNR                                 NUMBER\n         SPACE\n         LA    WRK2,8(0,WRK2)           GET PBTAB ENTRY\n         LH    WRK7,4(0,WRK2)           GET DSA SIZE\n         CVD   WRK7,DEC                 CONVERT TO DECIMAL\n         BAL   RET,EDNR                 EDIT\nTRM63    CLI   0(WRK5),C' '             FIND FIRST\n         BNE   TRM64                               SIGNIFICANT DIGIT\n         LA    WRK5,1(0,WRK5)           STEP FOR EVERY\n         LA    WRK6,1(0,WRK6)                          NON-SIGNIF ZERO\n         BCT   WRK4,TRM63\n         MVI   12(RAREA),C'0'           IF ONLY ZEROES\n         B     TRM65\nTRM64    LA    WRK8,0(WRK6,RAREA)       STEP NR OF NON-SIGNIF ZEROES\n         BCTR  WRK4,0                   STORE LENGTH\n         STC   WRK4,*+5                              IN MOVE INSTR\n         MVC   6(0,WRK8),0(WRK5)        MOVE EDITED NUMBER\n         SPACE\nTRM65    BCTR  WRK9,0                   ARE ALL PBTAB\n         LTR   WRK9,WRK9                              ENTRIES HANDLED\n         BC    8,TRM37                  YES\n         SPACE\n         LA    RAREA,18(0,RAREA)        MAKE NXT ENTRY\n         BCT   WRK1,TRM61                              IF LINE NOT FULL\n         SPACE\n         BAL   RET,PRINTT               OBTAIN PRINT BUFFER\n         B     TRM62\nPRINTT   EQU   *                   OBTAIN OUTPUT BUFFER AND BLANK IT\n         STM   RET,RENTRY,SV            SAVE REGS 14 AND 15\n         L     RENTRY,PRTRTADD          CALL\n         BALR  RET,RENTRY                    PRINT ROUTINE\n         LM    RET,RENTRY,SV            RESTORE REGS\n         SPACE\n         BR    RET\n         SPACE 2\nEDNR     EQU   *                   EDIT DECIMAL NUMBER\n         MVC   EDAREA(7),EDPTRN         MOVE PATTERN\n         ED    EDAREA-1(8),DEC+4        EDIT\n         BR    RET\n         EJECT\nTRMERR1  EQU   *                   DIRECTORY RETURN BEFORE FREEMAIN\nIEX51ER1 EQU   *                   FREEMAIN\nTRM37    L     WRK1,FREEMSIZ            GET INFO FOR\n         L     RAREA,FREEMADR                        AREA RELEASE\n         SPACE\n         FREEMAIN R,LV=(2),A=(1)        RELEASE AREA\n         SPACE\n         BALR  RENTRY,0                 LOAD NEW BASE REGISTER\n         SPACE 2\nIEX51ER2 EQU   *                   TERMINATION\n         USING *,RENTRY\n         SPACE\nTRM38    L     RCOT,=A(IEX60000)        ADDRESS IEX60000\n         L     RET,=A(IEX51002)         LOAD RETURN ADDRESS\n         LA    RINFO,ERRINFO            ADDRESS INFO FOR ERROR ED ROUT\n         BR    RCOT                     GO TO ERROR MESSAGE EDITING\n         SPACE\n         LTORG\n         SPACE\n         DROP  RENTRY\n         EJECT\nERR188   EQU   *                   GENERATE A PATTERN FOR ERROR MSG 188\n         SR    WRK6,WRK6\n         LA    WRK6,10                  IS DS NR\n         CR    WRK7,WRK6                         9 OR LOWER\n         BL    ER1                      YES\n         SPACE\n         SR    WRK7,WRK6                NO, SUBTRACT 10\n         STC   WRK7,EP188+11                            AND STORE\n         TR    EP188+11(1),NRTRA        CONVERT TO CHARACTER\n         MVI   EP188+10,C'1'            INSERT FIRST DIGIT\n         LA    WRK6,13                  GET LENGTH OF ENTRY\n         B     ER2\n         SPACE\nER1      STC   WRK7,EP188+10            STORE NUMBER\n         TR    EP188+10(1),NRTRA                     AND CONVERT IT\n         MVI   EP188+11,C'.'            INSERT PERIOD\n         LA    WRK6,12                  GET LENGTH OF ENTRY\n         SPACE\nER2      STC   WRK6,EP188               INSERT LENGTH OF ENTRY\n         OI    EP188,X'80'              PUT A TAG FOR BLANK SC\n         BCTR  WRK6,0                   DECREASE BY ONE\n         STC   WRK6,ER3+1               STORE LENGTH IN MOVE INSTR\n         SPACE\n         L     WRK7,NEXTERR             GET NEXT ENTRY IN POOL\nER3      MVC   0(0,WRK7),EP188          MOVE PATTERN\n         LA    WRK7,1(WRK6,WRK7)        UPDATE PTR TO\n         ST    WRK7,NEXTERR                           NEXT FREE ENTRY\n         C     WRK7,ENDPOOL             IS POOL FULL\n         BH    ER4                      YES\n         OI    HCOMPMOD,X'80'           NO, SET COMPILE MODE FALSE\n         BR    RET                      RETURN\n         SPACE\nER4      MVC   0(4,WRK7),EP0            MOVE PATTERN EP0\n         LA    WRK7,4(0,WRK7)           UPDATE PTR AND\n         ST    WRK7,NEXTERR                            STORE IT\n         B     TRM37                    TERMINATE COMPILATION\n         EJECT\n* CONSTANTS AND AREAS\n         SPACE\nPRPTAR   DS    F                        AREA TO HANDLE PRPOINTER\nDSTABPRP DS    F                        PRPOINTER AT DSTAB BEGIN\nAFSAPRP  DS    F                        PRPOINTER AT AFSA\nADRPRP   DS    F                        PRPOINTER AT APBT\nMDSN     DC    H'15'                    MAX DS NUMBER\nFOURK    DC    H'4096'                  LENGTH OF CONSTANT BLOCK\nDSTEM    DC    F'0'                     ADCB\n         DC    F'0'                     R\n         DC    F'0'                     RE\n         DC    F'0'                     NBB\n         DC    F'0'                     BB\n         DC    H'1'                     S\n         DC    H'80'                    P\n         DC    X'02'                    K\n         DC    X'00'                    Q\n         DC    H'00'                    DS\n         DC    F'0'                     NOTE ADDR\n         DC    F'0'                     BL+ TWO ARB\nDSTABLGT DS    H                        LENGTH OF DSTAB WITHOUT PGCF\nENDATA   DS    0H                  DATA TO BE INSERTED IN THE END-CARD\n         DC    X'02'                    CARD CODE\n         DC    C'END'                   IDENTIFICATION\n         DC    C'  '                    BLANKS\n         DC    C'  '                    BLANKS\n         DC    C'    '                  BLANKS\nAPBT     DC    A(0)                     ADDRESS OF PBT\nALAT     DC    A(0)                     ADDRESS OF LAT\nSW       DC    X'20'                    SWITCH FOR LONG/SHORT PREC\nASTART   DC    AL3(0)                   ADDRESS OF FIRST INSTRUCTION\n         SPACE\nHD       DC    C'STORAGE REQUIREMENTS (DECIMAL)'\nOBJ      DC    C'OBJECT MODULE SIZE '\nBYT      DC    C' BYTES.'\nDSA      DC    C'DATA STORAGE AREA SIZES'\nBLBY     DC    C'PBN   BYTES'\nDEC      DS    D                        FOR CONVERSION OF NUMBERS\nEDPTRN   DC    X'20202020202020'        PATTERN FOR EDITING\n         DC    C' '                     FILL CHARACTER\nEDAREA   DS    CL7                      FOR EDITING OF NUMBERS\nBLNR     DS    3C                       FOR CONVERSION OF BLOCK NUMBER\nSV       DS    2F                       SAVE AREA\n         SPACE\nEP188    DC    X'00BC0000'              ERROR PATTERN FOR\n         DC    C'DSN = 00.'                               MESSAGE 188\nEP0      DC    X'04000000'              ERROR PATTERN FOR MESSAGE 0\nNRTRA    DC    C'0123456789'            FOR TRANSL OF DS NUMBER\n         SPACE\nERRINFO  DC    V(IEX51M00)              ADDRESS OF MESSAGE TEXTS\n         DC    V(IEX51M01)              ADDRESS OF ADDRESS TABLE\n         DC    H'12'                    MODIFICATION NUMBER\n         SPACE 2\n         DS    0F\n         SPACE 2\nSHRTAB   EQU   *                   NAMES OF LIBRARY ROUTINES, SHORT\n         DC    C'SYSCT'\n         DC    C'SSQ  '\n         DC    C'SSCS '\n         DC    C'SSCC '\n         DC    C'SAT  '\n         DC    C'SLO  '\n         DC    C'SEX  '\n         DC    C'ISYMB'\n         DC    C'IDEIR'\n         DC    C'IDEII'\n         DC    C'IBOOL'\n         DC    C'IARRY'\n         DC    C'IARRT'\n         DC    C'IBARR'\n         DC    C'OSYMB'\n         DC    C'SOREL'\n         DC    C'OINTG'\n         DC    C'OBOOL'\n         DC    C'OARRY'\n         DC    C'OTARR'\n         DC    C'OBARR'\n         DC    C'OSTRG'\n         DC    C'GPRPT'\n         DC    C'GPRGT'\n         DC    C'FII  '\n         DC    C'FRI  '\n         DC    C'FRR  '\n         SPACE\nLNGTAB   EQU   *                   NAMES OF LIBRARY ROUTINES, LONG\n         DC    C'SYSCT'\n         DC    C'LSQ  '\n         DC    C'LSCS '\n         DC    C'LSCC '\n         DC    C'LAT  '\n         DC    C'LLO  '\n         DC    C'LEX  '\n         DC    C'ISYMB'\n         DC    C'IDEIR'\n         DC    C'IDEII'\n         DC    C'IBOOL'\n         DC    C'IARRY'\n         DC    C'IARRT'\n         DC    C'IBARR'\n         DC    C'OSYMB'\n         DC    C'LOREL'\n         DC    C'OINTG'\n         DC    C'OBOOL'\n         DC    C'OARRY'\n         DC    C'OTARR'\n         DC    C'OBARR'\n         DC    C'OSTRG'\n         DC    C'GPRPT'\n         DC    C'GPRGT'\n         DC    C'FII  '\n         DC    C'FDI  '\n         DC    C'FDD  '\n         EJECT\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n*                                                                     *\n*        S U B R O U T I N E   G E N E R A T E                        *\n*                                                                     *\n* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         SPACE 3\n* REGISTER DEFINITIONS\nREG0     EQU   0                        VARIABLE USE\nOUTAREA  EQU   1                        OUTPUT RECORD POINTER\nINFORM   EQU   2                        ADDRESS OF INFORMATION\nTYPER    EQU   3                        TYPE OF RECORD TO BE GENERATED\nRETURN   EQU   4                        RETURN REGISTER\nPRPOINT  EQU   6\nLENGTH   EQU   14                       LENGTH OF INFORM. FROM CALL\nL        EQU   15                       LENGTH WITHIN RECORD\n         SPACE 3\n*ADDRESS DISPLACEMENTS\nRSTART   EQU   0                        START OF RECORD TYPE TABLE\nRTYP     EQU   1                        RECORD IDENTIFICATION\nRLEN     EQU   4                        INITIAL LENGTH 0 OR 4\nRESID    EQU   6                        ESID OR BLANKS\nRMAX     EQU   12                       MAXIMUM NUMBER OF BYTES IN REC\nRMOV     EQU   14                       START OF MOVE ROUTINE\nINFL     EQU   10                       LENGTH OF INFORM IN A RECORD\n         SPACE 3\n* BIT PATTERNS\nSDENTRY  EQU   X'00'                    SD-ENTRY IDENTIFICATION\nLDENTRY  EQU   X'01'                    LD-ENTRY IDENTIFICATION\nRLDFLAG  EQU   B'00001100'              FLAG USED IN RLD-ENTRY\n         SPACE 3\nGENESD   EQU   *                   START OF GENERATE ESD-RECORDS\n         LA    LENGTH,16                LENGTH ALWAYS 16\n         LA    TYPER,ESDT               INDICATE ESD-CALL\n         B     GEN1\n*\nGENTXTS  EQU   *                   START OF GENERATE TXT-RECORD,S\n         LA    RETURN,2(0,LENGTH)       COMPUTE RETURN ADDRESS\n         LH    LENGTH,0(0,LENGTH)       LOAD LENGTH GIVEN IN CALL\nGEN2     LA    TYPER,TXTT               INDICATE TXT-CALL\n         B     GEN1                     CONTINUE COMMON PART\n*\n*\nGENRLD   EQU   *                   START OF GENERATE RLD-RECORDS\n         LA    RETURN,6(0,LENGTH)       COMPUTE RETURN ADDRESS\n         LA    TYPER,RLDT               INDICZTE RLD-CALL\n         MVC   RANDP(4),2(LENGTH)       INSERT NEW R AND P\n         LH    LENGTH,0(0,LENGTH)       LOAD LENGTH GIVEN IN CALL\n         SLL   LENGTH,1                 DOUBLE LENGTH\n         SPACE 3\nGEN1     L     OUTAREA,SAVOUTA         LOAD ADDRESS OF OUT RECORD\n         CLC   RTYP(3,OUTAREA),RTYP(TYPER)     RECORD RIGTH TYPE\n         BNE   GEN3                     NO,CALL IOR NEW\n         CLC   INFL(2,OUTAREA),RMAX(TYPER)     RECORD FILLED\n         BNL   GEN3                     YES,CALL FOR NEW\nGEN6     LA    L,56\n         LH    REG0,INFL(0,OUTAREA)     REG0=LENGTH OF INFORM IN REC\n         SR    L,REG0                   L=EMPTY POS LEFT IN RECORD\n         CR    L,LENGTH                 ENOUTH SPACE LEFT\n         BL    *+6                      NO\n         LR    L,LENGTH                 YES L=LENGTH FROM CALL\n         AR    L,REG0\n         STH   L,INFL(0,OUTAREA)        INSERT NEW LENGTH INTO RECORD\n*\n         SR    L,REG0\n         AR    OUTAREA,REG0             START ADDRESS WITHIN RECORD\n         SR    LENGTH,L                 REMAINING LENGTH\n         B     RMOV(TYPER)              TO DIFFERENT MOVE ROUTINES\n*\nGEN4     LTR   LENGTH,LENGTH            MORE INFORMATION MUST BE MOVED\n         BH    GEN3                     YES\n         BR    RETURN\n         SPACE 3\nGEN3     EQU   *                        CALL FOR NEW OUTPUT RECORD\nPUNCH    ST    LENGTH,SAVELT           SAVE LENGTH\n         TM    HCOMPMOD+1,X'60'    Q. BOTH DECK AND LOAD SPECIFIED\n         BZ    BOTH                     YES\n         TM    HCOMPMOD+1,NDCK         Q. ONLY DECK\n         L     OUTAREA,PCHADD           IF ONLY DECK\n         BZ    PUT1                     YES\n         L     OUTAREA,LINADD           ONLY SYSLIN\nPUT1     PUT   (OUTAREA)                PUT FOR SYSLIN AND SYSPUNCH IF\n         ST    OUTAREA,SAVOUTA          ONLY SYSPUNCH SPECIFIED\n         L     LENGTH,SAVELT           RESTORE LENGTH\n         B     PUNCHOUT\nBOTH     L     LENGTH,OUTAREA2         COPY SYSLIN BUFFER TO SYSPUNCH\n         L     OUTAREA,SAVOUTA\n         MVC   0(80,LENGTH),0(OUTAREA)  BUFFER\nPUT2     L     OUTAREA,PCHADD\n         PUT   (OUTAREA)                PUT FOR SYSPUNCH WHEN BOTH HAS\n         ST    OUTAREA,OUTAREA2         BEEN SPECIFIED\n         B     PUT1-4                   GO TO PUT SYSLIN\nPUNCHOUT EQU   *\n         MVC   0(4,OUTAREA),RSTART(TYPER)     INSERT FIRST 4 BYTES\n         MVI   4(OUTAREA),C' '          INSERT ONE BLANK\n         MVC   5(67,OUTAREA),4(OUTAREA)      BLANK OUTPUT RECORD\n         MVC   72(4,OUTAREA),PIDENT     INSERT PROGRAM IDENT\n         L     L,SEQU                   STEP\n         LA    L,1(0,L)                      SEQUENCE\n         ST    L,SEQU                                 NR\n         CVD   L,DBL                    CONVERT\n         UNPK  76(4,OUTAREA),DBL+5(3)           TO DECIMAL\n         MVZ   79(1,OUTAREA),76(OUTAREA)\n         MVC   10(2,OUTAREA),RLEN(TYPER)     INSERT INITIAL LENGTH\n         MVC   14(6,OUTAREA),RESID(TYPER)     INSERT ESID+R AND P\nGEN31    BC    0,TRM36                  RETURN AFTER GEN OF END CARD\n         CLC   TXTT+1(3),RTYP(TYPER)    TXT-RECORD PROCESSED\n         BNE   GEN6                     NO\n         ST    PRPOINT,4(OUTAREA)       YES INSERT PRPOINT\n         MVI   4(OUTAREA),C' '\n         B     GEN6\n         SPACE 3\n* TABLES AND MOVE ROUTINES\n         SPACE 3\nESDT     DS    0H                  START OF ESD-RECORD TABLE\n         DC    X'02'                    CARD CODE\n         DC    C'ESD'                   IDENTIFICATION\n         DC    H'0'                     INITIAL LENGTH 0\n         DC    C'      '\n         DC    H'48'                    MAXIMUM LENTH IN RECORD\nGEN7     EQU   *                   MOVE ESD-INFORMATION TO OUTAREA\n         MVC   16(16,OUTAREA),0(INFORM)     MOVE INFORM TO OUTAREA\n         CLI   8(INFORM),LDENTRY        LD ENTRY MOVED\n         BE    16(INFORM)               YES RETURNTO CALLING ROUTINE\n         MVC   25(7,OUTAREA),ESDCON     CHANGE LAST PART OF ENTRY\n         LH    TYPER,ESID               INCREASE\n         LA    TYPER,1(0,TYPER)         *AND STORE\n         STH   TYPER,ESID               *NEW ESID NUMBER\n         SR    OUTAREA,REG0\n         CLI   14(OUTAREA),C' '         FIRST SD OR ER ENTRY\n         BNE   10(INFORM)               NO, RETURNTO CALLING ROUTINE\n         STH   TYPER,14(OUTAREA)        YES INSERT ESID NUMBER\n         B     10(INFORM)               RETURN TO CALLING ROUTINE\n         SPACE 3\nTXTT     DS    0H                  START OF TXT-RECORD  TABLE\n         DC    X'02'                    CARD CODE\n         DC    C'TXT'                   IDENTIFICATION\n         DC    H'0'                     INITIAL LENGTH 0\n         DC    H'1'                     ESID\n         DC    C'    '\n         DC    H'56'                    MAXIMUM LENGTH\nGEN8     EQU   *                   MOVE TXT-INFORMATION TO OUTAREA\n         BCTR  L,0                      L=L-1\n         STC   L,*+5                    INSERT PROPER LENGTH TO MOVE\n         MVC   16(0,OUTAREA),0(INFORM)      MOVE INFORM TO OUTAREA\n         LA    PRPOINT,1(L,PRPOINT)     INCREASE PROGRAM POINTER\n         LA    INFORM,1(L,INFORM)       MODIFY DATA ADDRESS\n         B     GEN4                     OUT OF MOVE TXT ROUTINE\n         SPACE 3\nRLDT     DS    0H                  START OF RLD-RECORD TABLE\n         DC    X'02'                    CARD CODE\n         DC    C'RLD'                   IDENTIFICATION\n         DC    H'0'\n         DC    C'  '\nRANDP    DC    C'    '                  R AND P\n         DC    H'56'                    MAXIMUM LENGTH IN RECORD\nGEN9     EQU   *                   MOVE RLD-INFORMATION TO OUTAREA\n         AR    L,OUTAREA                INDICATE LAST ENTRY\nGEN5     MVC   16(4,OUTAREA),RANDP      INSERT R AND P\n         ST    INFORM,20(0,OUTAREA)     MOVE PROGRAM POINTER VALUE AND\n         MVI   20(OUTAREA),RLDFLAG      *FLAG TO OUTAREA\n         LA    OUTAREA,8(0,OUTAREA)     NEXT ENTRY\n         LA    INFORM,4(0,INFORM)       NEXT PROGRAM POINTER VALUE\n         CR    OUTAREA,L                LAST COLUMN FILLED\n         BL    GEN5                     NO,CONTINUE\n         B     GEN4                     OUT OF MOVE RLD ROUTINE\n         SPACE 3\n* VARIABLES AND CONSTANTS\nDBL      DS    D                        FOR CONV OF SEQUENCE NR\nSAVELT   DS    F                       SAVE AREA FOR LENGTH\nESID     DC    H'1'                    ESID VARIABLE 1 AT START\nESDCON   DC    X'000000'                ESD-\n         DC    C'    '                  *CONSTANT,7 BYTES\n         TITLE 'IEX51, TERMINATION OF COMPILATION, ERROR MSG EDITING'\n         COPY  IEX60000\n         TITLE  'IEX51, TERMINATION OF COMPILATION'\nIEX51002 CSECT\n         SPACE\n* REGISTER ASSIGNMENTS\n         SPACE\nR0       EQU   0\nBASE     EQU   2\nR3       EQU   3\nRA       EQU   4\nR8       EQU   8\nR9       EQU   9\nR13      EQU   13\nR15      EQU   15\n         SPACE 2\n         BALR  BASE,0\n         USING *,BASE\n         SPACE\n         OI    HCOMPMOD+1,TERM     INDICATE THIS ROUTINE IS ENTERED\n         LA    R0,CLOSE            PROVIDE DIRECTORY\n         ST    R0,ERET                               RETURN ADDRESS\n         SPACE 2\n* FREE THE STORAGE OF THE ERROR POOL AND SOURCE PROG BUFFER 1\n         SPACE\n         TM    HCOMPMOD+1,NOBUF\n         BO    RESTPGCT            IF NO GETMAIN FOR BUFFERS WAS 1SSUED\n         L     R0,POOLS            SIZE OF ERROR POOL\n         A     R0,SRCE1S           SIZE OF SOURCE PROG BUFFER 1\n         L     R1,ERRPOOL          ADDR OF ERROR POOL\n      FREEMAIN R,LV=(0),A=(1)\n         SPACE 2\n* RESTORE THE INVOKERS PAGE COUNT\n         SPACE\nRESTPGCT L     RA,HDING            POINTER TO INVOKERS HEADING INFO\n         LTR   RA,RA\n         BC    8,CLOSE             IF NO HEADING INFO PROVIDED\n         MVC   2(4,RA),PAGECNT\n         SPACE 2\n* CLOSE THE DATA CONTROL BLOCKS AND FREE THE BUFFER POOLS\n         SPACE\nCLOSE    BALR  BASE,0\n         USING *,BASE\n         LA    R0,SPIE             PROVIDE NEW DIR\n         ST    R0,ERET                             RETURN ADDRESS\n         LM    3,12,LINADD\n         USING IHADCB,R8\n         TM    DCBOFLGS,X'10'\n         DROP  R8\n         BO    *+8\n         OI    SWITCH+1,X'F0'\n         CLOSE ((3),,(8),,(9),,(11),,(12))\n         TM    HCOMPMOD+1,NLOAD\n         BO    FRPPCH              IF NOLOAD OPTION\n         LR    R1,R3\n      FREEPOOL (1)\nFRPPCH   TM    HCOMPMOD+1,NDCK\n         BO    FRPPRT              IF NODECK OPTION\n         LR    R1,R9\n      FREEPOOL (1)\nFRPPRT   LR    R1,R8\nSWITCH   BC    0,SPIE\n      FREEPOOL (1)\n         SPACE 2\n* EXECUTE SPIE MACRO\n         SPACE\nSPIE     BALR  BASE,0\n         USING *,BASE\n         L     4,OLDPICA\n         SPIE  MF=(E,(4))\n         SPACE 2\n* FIND THE RETURN CODE AND RETURN TO IEX00\n         SPACE\nRTNCODE  TM    HCOMPMOD,X'08'\n         BZ    NOTERM              IF NO TERMINAL ERROR\n         LH    R15,=H'16'\n         B     RETURNN\nNOTERM   TM    HCOMPMOD,X'10'\n         BZ    NOSER               IF NO SERIOUS ERROR\n         LH    R15,=H'8'\n         B     RETURNN\nNOSER    SR    R15,R15\n         TM    HCOMPMOD,X'20'\n         BZ    RETURNN\n         LH    R15,=H'4'\nRETURNN  L     R13,SAVEAREA+4\n        RETURN (14,12),RC=(15)\n         SPACE\n         LTORG\n EJECT\n* DUMMY CONTROL SECTION TO PROVIDE ADRESSABILITY OF DCB\n         SPACE\n         DCBD  DSORG=(PS)\n EJECT\nWORKAREA DSECT\n         COPY  WORKAREA\n         EJECT\n*\n* AREA USED BY COMPILATION PHASE\n*\n         SPACE\n         ORG   DCBUT1\n         SPACE\nRETADR   DS    17F                      SAVE AREA\nPLACE14  DS    F                           -''-\nRUTI     DS    9F                       GPR CONTROL\nRUTR     DS    4F                       FLREG CONTROL\nGPROLN   DS    H                        LABEL NR OF OBJ PRG ENTRY POINT\nKONSUM   DS    H                        WORKPLACE\nWORKPL   DS    F                        WORKPLACE\nIBUF1    EQU   SRCE1ADD                 ADDR OF FIRST SOURCE BUFFER\nIBUF2    DS    A                          -''  SECOND    -''-\nSOURCEB  DS    A                          -''  CURRENT   -''-\nRSRCB    DS    A                          -''  READ      -''-\nOPBUF1   DS    A                        ADDR OF FIRST OPTAB BUFFER\nOPBUF2   DS    A                          -''-  SECOND    -''-\nOPBUFB   DS    A                          -''-  CURRENT   -''-\nROPTB    DS    A                          -''-  READ      -''-\nAOPTABE  DS    A                        ADDRESS OF CURRENT OPTAB ENTRY\nLATAB    DS    A                        ADDR OF LABEL ADDRESS TABLE\nAPBTAB4  EQU   LATAB                    ADDRESS OF PBTAB4\nSUTABCA  DS    A                        ADDR OF LAST USED SUTAB ENTRY\nSTRETURN DS    F                        RETURN ADDRESS\nFREEMADR DS    A                       ADR FOR FREEMAIN IN 50000\nFREEMSIZ DS    F                        SIZE          -''-\n         SPACE\nPBTAB3   DS    1024C                    PROGRAM BLOCK TABLE, 3RD VERS\n         SPACE\nIOTAB    DC    18X'00'                  LIST OF DATA SETS\nCII      DC    H'0'                     REGISTER CONTROL\nCIR      DC    H'0'                          -''-\nRII      DC    H'0'                          -''-\nRIR      DC    H'0'                          -''-\nOPDPBN   DC    H'0'                     PROGRAM BLOCK NR (BYTE 2 OF OPD\nOPDADR   DC    H'0'                     BYTES 3 AND 4 OF OPERAND\nOPDLN    DC    H'0'                     LABEL NUMBER TIMES FOUR\nSCSC     EQU   SEMCNT                  SEMICOLON COUNTER\nZEROHW   DC    H'0'                     ZEROES\nCFSN     DC    X'00'                    CURRENT FS NUMBER\nMAXFSN   DC    X'FF'                    MAX FS NUMBER\nCLEARDIS DC    X'F000'                  FOR CLEARING OF DISPLACEM PART\nONEENTRY DC    H'4'                     SHORT, FOR INCR OF OT STACK PTR\n         ORG   ONEENTRY\n         DC    H'8'                     LONG            -''-\nPRECMASK DC    X'10'                    SHORT, TO MODIFY INSTRUCTIONS\n         ORG   PRECMASK\n         DC    X'00'                    LONG            -''-\nNUMBBL   DC    X'00'                    RECORD COUNTER\n         DS    H\nSPBNST   DC    H'0'                     CURRENT PBN\n         DS    H                                    AND DISPLACEMENT\nGPBN     DC    H'255'                   GLOBAL DSA CONTROL\nMAXOVERF DC    H'4092'                  SHORT, TO CHECK OT STACK OVERFL\n         ORG   MAXOVERF\n         DC    H'4088'                  LONG            -''-\nHALFW    DS    H                        WORKPLACE\nUSPEI2   DS    H                        FOR ARRAY DECLA-\nUSPEI4   DS    H                                        RATION HANDLING\nWPLACE   DS    H                        FOR INSTRUCTION GENERATION\nXPLACE   DS    H\nYPLACE   DS    H\nUPLACE   DS    H\nVPLACE   DS    C                                    -''-\nSTRDNAME DS    5C                       TO STORE OPERAND\nCBVTAB   DS    48C                      CALLED-BY-VALUE TABLE\nSUTABC   DS    768C\n         ORG   SUTABC\nDSTAB    DS    608C                     DATA SET TABLE\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IEX51M": {"ttr": 6663, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x98\\x01/\\x00\\x98\\x01/\\x16!\\x00\\xc7\\x00\\xc7\\x00\\x00\\xd6\\xf3\\xf6\\xf0`\\xf2\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1998-01-12T00:00:00", "modifydate": "1998-01-12T16:21:00", "lines": 199, "newlines": 199, "modlines": 0, "user": "O360-20"}, "text": " TITLE 'IEX51M, ERROR MESSAGE TEXT POOL 3'\n*                                                                     *\n*STATUS: CHANGE LEVEL 000.                                            *\n*                                                                     *\n*FUNCTION/OPERATION: THIS MODULE CONTAINS MESSAGE TEXTS FOR ALL       *\n*   ERRORS THAT MAY BE DETECTED BY IEX00,IEX50, AND IEX51, AND THE    *\n*   CORRESPONDING ADDRESS TABLE.                                      *\n*                                                                     *\n*ENTRY POINT: N/A.                                                    *\n*                                                                     *\n*INPUT: N/A.                                                          *\n*                                                                     *\n*OUTPUT: N/A.                                                         *\n*                                                                     *\n*EXTERNAL ROUTINES: N/A.                                              *\n*                                                                     *\n*EXITS-NORMAL: N/A.                                                   *\n*                                                                     *\n*EXITS-ERROR: N/A.                                                    *\n*                                                                     *\n*TABLES/WORKAREAS: N/A.                                               *\n*                                                                     *\n*ATTRIBUTES: N/A.                                                     *\n*                                                                     *\n*NOTES: AT SYSTEM GENERATION THIS MODULE WILL BE LINKED TOGETHER WITH *\n*   THE MODULE IEX51 TO FORM THE MODULE IEX51 IN LINKLIB.             *\n*                                                                     *\n         SPACE\nIEX51M00 CSECT\n         ENTRY IEX51M01\n         SPACE\nWEMPOOL3 EQU   *                   ERROR MESSAGE POOL 3\n         SPACE\nW160     DC    X'280500081244001B00001B45001C000C1C'\n         DC    CL24'SSEQUENCE   NOT ALLOWED.'\nW161     DC    X'300500081244001B00081B450024000C24'\n         DC    CL32'SSEQUENCE  OPERAND  NOT ALLOWED.'\nW162     DC    X'2F0500171244002A00042A45002F00002F'\n         DC    CL31'SOPERAND MISSING BETWEEN  AND .'\nW163     DC    X'3B0300110C44001E001D1E'\n         DC    CL49'SOPERAND FOLLOWING  MUST BE OF ARITHMETICAL TYPE.'\nW164     DC    X'3205001A1244002D00042D450032000032'\n         DC    CL34'SNO OPERAND ALLOWED BETWEEN  AND .'\nW165     DC    X'3500'\n         DC    CL52'SEXPRESSIONS BEFORE AND AFTER ''ELSE'' NOT COMPATIBX\n               LE.'\nW166     DC    X'2100'\n         DC    CL32'SDECLARATOR IN ILLEGAL POSITION.'\nW167     DC    X'3202440009002909'\n         DC    CL43'S AND OPERAND PRECEDING DECLARATOR ILLEGAL.'\nW168     DC    X'330300110C44001E00151E'\n         DC    CL41'SOPERAND PRECEDING  CANNOT POSSESS VALUE.'\nW169     DC    X'2403000F0C44001C00081C'\n         DC    CL26'SLABEL FOLLOWING  ILLEGAL.'\nW172     DC    X'2400'\n         DC    CL35'SDIFFERENT TYPES IN LEFT PART LIST.'\nW173     DC    X'3C00'\n         DC    CL59'TCOMPILATION UNSUCCESSFUL DUE TO COMPILER OR MACHINX\n               E ERROR.'\nW174     DC    X'3C00'\n         DC    CL59'SPARAMETERS NOT ALLOWED FOR TYPE PROCEDURE CALLED BX\n               Y VALUE.'\nW175     DC    X'360300120C44001E00181E'\n         DC    CL44'SOPERAND FOLLOWING  MUST BE LABEL OR SWITCH.'\nW176     DC    X'230300160C440023000023'\n         DC    CL25'SOPERAND MISSING BEFORE .'\nW177     DC    X'2703001A0C440027000027'\n         DC    CL29'SOPERAND NOT ALLOWED BEFORE .'\nW178     DC    X'3700'\n         DC    CL54'SILLEGAL OPERAND IN EXPRESSION BEFORE OR AFTER ''ELX\n               SE''.'\nW179     DC    X'6100'\n         DC    CL96'SNUMBER OF SUBSCRIPT EXPRESSIONS DIFFERS FROM DIMENX\n               SION IN ARRAY       DECLARATION FOR VARIABLE.'\nW180     DC    X'1C00'\n         DC    CL27'SINVALID SWITCH DESIGNATOR.'\nW181     DC    X'2800'\n         DC    CL39'SSWITCH DESIGNATOR IN ILLEGAL POSITION.'\nW182     DC    X'2E0300110C44001E00101E'\n         DC    CL36'SOPERAND FOLLOWING  MUST BE BOOLEAN.'\nW183     DC    X'3D0300110C44001E001F1E'\n         DC    CL51'SOPERAND PRECEDING  MUST BE A PROCEDURE IDENTIFIER.X\n               '\nW184     DC    X'440300110C44001E00261E'\n         DC    CL58'SOPERAND PRECEDING  MUST BE AN ARRAY OR SWITCH IDENX\n               TIFIER.'\nW185     DC    X'440300160C440023002123'\n         DC    CL58'SREAL OPERAND PRECEDING  NOT ALLOWED FOR INTEGER DIX\n               VISION.'\nW186     DC    X'3B00'\n         DC    CL58'TSYNTACTICAL STRUCTURE TOO COMPLICATED. INTERNAL OVX\n               ERFLOW.'\nW187     DC    X'2800'\n         DC    CL39'SINCORRECT NUMBER OF ACTUAL PARAMETERS.'\nW188     DC    X'3902003009800004'\n         DC    CL50'SINVALID ACTUAL PARAMETER FOR STANDARD PROCEDURE. '\nW189     DC    X'3D00'\n         DC    CL60'SDATA SET NUMBER OR FUNCTION OF SYSACT OUT OF ALLOWX\n               ED RANGE.'\nW190     DC    X'1A00'\n         DC    CL25'SASSIGNMENT NOT POSSIBLE.'\nW191     DC    X'2E0300200C44002D00012D'\n         DC    CL36'SNO OPERAND ALLOWED BETWEEN ) AND  .'\nW192     DC    X'2D00'\n         DC    CL44'SINVALID RIGHT PART IN ASSIGNMENT STATEMENT.'\nW193     DC    X'2D00'\n         DC    CL44'SINCOMPATIBLE TYPES IN ASSIGNMENT STATEMENT.'\nW194     DC    X'1502440009000C09'\n         DC    CL14'S NOT ALLOWED.'\nW195     DC    X'290300100C44001D000C1D'\n         DC    CL31'SSEQUENCE OPERAND  NOT ALLOWED.'\nW196     DC    X'3303001A0C440027000C27'\n         DC    CL41'SARRAY IDENTIFIER PRECEDING  NOT ALLOWED.'\n         SPACE\n*\n* DIRECTORY MESSAGES\n*\n         SPACE\nW209     EQU   *\nW197     DC    X'460400360FF00000840046000046'\n         DC    CL57'TCOMPILATION UNSUCCESSFUL DUE TO PROGRAM INTERRUPT.X\n                PSW .'\nW210     EQU   *\nW198     DC    X'300300270C840030000030'\n         DC    CL38'TUNRECOVERABLE I/O ERROR ON DATA SET .'\nW211     EQU   *\nW199     DC    CL56'PROGRAM INTERRUPT IN ERROR MESSAGE EDITING ROUTINE.X\n                PSW '\n         SPACE\n*\n* MESSAGES USED BY MORE THAN ONE PHASE\n*\n         SPACE\nW212     EQU   *\nW200     DC    X'1200'\n         DC    CL17'TTOO MANY ERRORS.'\nW213     EQU   *\nW201     DC    X'2800'\n         DC    CL39'TINTERNAL OVERFLOW OF IDENTIFIER TABLE.'\nW214     EQU   *\nW202     DC    X'3903002D0C84003A00003A'\n         DC    CL48'SDATA STORAGE AREA EXCEEDED, PROGRAM BLOCK NO. .'\nW215     EQU   *\nW203     DC    X'1A00'\n         DC    CL25'TSOURCE PROGRAM TOO LONG.'\nW216     EQU   *\nW204     DC    X'2600'\n         DC    CL37'STOO MANY LABELS. LABEL NUMBER RESET.'\n         EJECT\n         DS    0F\n         SPACE 2\nIEX51M01 EQU   *-640               ADDRESS TABLE FOR WEMPOOL3\n         SPACE\n         DC    A(W160)\n         DC    A(W161)\n         DC    A(W162)\n         DC    A(W163)\n         DC    A(W164)\n         DC    A(W165)\n         DC    A(W166)\n         DC    A(W167)\n         DC    A(W168)\n         DC    A(W169)\n         DS    F\n         DS    F\n         DC    A(W172)\n         DC    A(W173)\n         DC    A(W174)\n         DC    A(W175)\n         DC    A(W176)\n         DC    A(W177)\n         DC    A(W178)\n         DC    A(W179)\n         DC    A(W180)\n         DC    A(W181)\n         DC    A(W182)\n         DC    A(W183)\n         DC    A(W184)\n         DC    A(W185)\n         DC    A(W186)\n         DC    A(W187)\n         DC    A(W188)\n         DC    A(W189)\n         DC    A(W190)\n         DC    A(W191)\n         DC    A(W192)\n         DC    A(W193)\n         DC    A(W194)\n         DC    A(W195)\n         DC    A(W196)\n         DC    A(W197)\n         DC    A(W198)\n         DC    A(W199)\n         DC    A(W200)\n         DC    A(W201)\n         DC    A(W202)\n         DC    A(W203)\n         DC    A(W204)\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT309/FILE309.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT309", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}