{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012720000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 940576, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 10, "INMDSNAM": "CBT.V500.FILE749.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 940576, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 940576, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE749.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x10\\x06'", "DS1TRBAL": "b'e\\xde'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x05\\x1a\\x00\\n\\x05\\x1b\\x00\\x0b\\x00\\x11'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04U\\x00\\x08\\x01\\x12%\\x7f\\x01\\x12%\\x7f!\\x07\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf8\\xf5@@@'", "ispf": {"version": "04.85", "flags": 0, "createdate": "2012-09-13T00:00:00", "modifydate": "2012-09-13T21:07:08", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-485"}, "text": "REGULAR CBT TAPE - VERSION 485    FILE:  749\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT485.FILE749\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 27 MEMBERS COUNTED; CUMULATIVE SIZE IS 8,510 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   09/13/12    21:07:08    GMT-4:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$$COGSF": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x001\\x00\\x89\\x19_\\x01\\x12%\\x7f\\x10\"\\x00\\x1c\\x00\\x1e\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1989-07-14T00:00:00", "modifydate": "2012-09-13T10:22:31", "lines": 28, "newlines": 30, "modlines": 0, "user": "SBGOLOB"}, "text": "\n                         COPYRIGHT\n\n     These programs are Freeware and may be freely copied.\n     They may be freely distributed to any other party on condition\n     that no inducement beyond reasonable handling costs is offered\n     or accepted by either side for such distribution.\n\n                         DISCLAIMER\n\n     Gilbert Saint-Flour neither expresses nor implies any warranty\n     as to the fitness of these computer programs for any function.\n     The use of these programs or the results therefrom is entirely\n     at the risk of the user.  Consequently, the user may modify\n     these programs in any way he/she thinks fit.\n\n\n                     CONTACT INFORMATION\n\n     We would be interested to hear of comments and/or proposed\n     enhancements.  Please e-Mail to:\n\n              Carlos Aguilera <carlos@gsf-soft.com>\n                            or\n              Sam Golob (sbgolob@cbttape.org>\n\n     or visit our web site at http://gsf-soft.com/Freeware\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$$INDEX": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04I\\x00V\\x00\\x885\\x0f\\x01\\x12%\\x7f\\x10\"\\x01J\\x00\\x00\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "04.73", "flags": 0, "createdate": "1988-12-15T00:00:00", "modifydate": "2012-09-13T10:22:56", "lines": 330, "newlines": 0, "modlines": 0, "user": "SBGOLOB"}, "text": "\n                   .----------------------------.\n                   |      CBT Tape File 183     |\n                   |  Index of OSVS238J Member  |\n                   '----------------------------'\n\n                    http://gsf-soft.com/Freeware\n\n     ----------------- TSO and ISPF commands -------------------\n\n     CLS       A 5-line \"clear screen\" command for TSO\n\n     EXECPGM   TSO command - invoke a utility program or compiler\n               with an alternate ddname list, as follows:\n                  EXECPGM IEV90           +\n                    PARM(NOOBJECT,NODECK,NOXREF,NORLD) +\n                    SYSIN(TEMPWK2)        +\n                    SYSUT1(TEMPWK1)       +\n                    SYSLIB(ASMLIB)        +\n                    SYSPRINT(ASMH$PRT)    +\n                    STEPLIB(LINKLIST)\n\n     INITKSDS  Initialize a KSDS after it's been DEFINE'd\n\n               This program prevents OPEN from failing when\n               opening with MACRF=(IN,OUT) or STRNO=2 a KSDS\n               that has just been defined.  Can be invoked as\n               a batch program, a TSO command, or a sub-routine.\n\n     ------------------ Batch Programs --------------------------\n\n     BLKSIZE2  Scan a PDS and print the size of each block and\n               the track balance\n\n               This is a batch program, for people interested\n               in what a PDS looks like, from the inside.\n\n     BYPASSNQ  Assembler program.  Scratch or Rename a Data Set\n               without SYSDSN ENQ\n\n               BYPASSNQ is a driver that allows you to run any\n               utility program (such as IEHPROGM or IDCAMS) and\n               bypass dsname ENQ that is normally performed by\n               the DYNALLOC, SCRATCH and RENAME SVCs.\n\n     CANMSGCL  Purge current job's held output after a few hours.\n               Useful for those jobs that work OK 99% of the time\n               (must be authorized)\n\n               Example:\n\n                 //MYJOB    JOB ACCT#,CLASS=A,MSGCLASS=X\n                 //COPY1   EXEC PGM=IEBCOPY\n                 //...      DD   ...\n                 //CONDPURG EXEC PGM=CANMSGCL,PARM=2,\n                 //              COND=(0,NE,COPY1)\n\n                 The number in the parm is a number of hours.\n                 If the 'COPY1' step ends at 10:28 with a\n                 return code equal to zero, the 'CONDPURG' step\n                 executes and issues the following command:\n\n                   $TA,T=12.28,'$OJ01234,Q=X,CANCEL'\n\n     CLEANUP   Assembler program.  Automatically searches the MVS\n               catalog for non-GDG data sets that will be created\n               in subsequent steps of your job and deletes them.\n\n                     //MYJOB   JOB  acct#\n                     //*\n                     //CLEANUP EXEC PGM=CLEANUP\n                     //*\n                     //STEP1   EXEC PGM=MYPROG1\n                     //OUTDD    DD  DSN=MY.FILE1,DISP=(,CATLG)\n                     //STEP2   EXEC PGM=MYPROG2\n                     //OUTDD    DD  DSN=MY.FILE2,DISP=(,CATLG)\n\n               Can also be executed as the LAST step of a job to\n               delete non-GDG data sets that were created during\n               job execution.\n\n     CMDJ      Send a JES2 command with the current job's number\n               (must be authorized)\n\n               Example:\n\n                  //PURGEJOB EXEC PGM=CMDJES2,PARM=P\n\n               If the current job's number is JOB01234,\n               then the following command is issued:\n\n                     $PJ  01234\n\n     GSFLKED   Front-end to the linkage editor to recover\n               from SD37 on SYSLMOD (must be authorized)\n\n               This program may be invoked instead of the DFP\n               linkage editor. It calls the linkage editor and,\n               if an SD37 abend occurs, calls IEBCOPY to compress\n               the SYSLMOD PDS, then calls the linkage editor\n               again.\n\n               Another feature of this program is to\n               conditionally append a PDS member to SYSLIN,\n               if that member exists.\n\n     JOBRLSE   Release a job by number (must be authorized)\n\n               This program issues a $A command to release a job\n               previously submitted to JES2 with \"TYPRUN=HOLD\".\n\n               To prevent \"multiple jobs found\" conditions,\n               this program uses the sub-system interface\n               to inquire about the status of homonym jobs.\n               Then, it issues a $A command with the job\n               number of the first job found in the input\n               queue in held status (for example: $A J1234).\n\n               Sample execution JCL:\n\n                 //RLSENEXT EXEC PGM=JOBRLSE,PARM=PAYROL22\n\n     NOTCTLG3  Prolog step to prevent \"NOT CATLG 2\" and verify\n               VSAM data sets\n\n               This program may be executed at the beginning\n               of a batch job.  It scans the job's SWA to\n               locate JFCBs and does two things:\n\n               1. checks if any non-gdg data set with\n                  DISP=(NEW,CATLG) is already cataloged.\n                  If it finds at least one (i.e. a \"NOT\n                  CATLG 2\" is about to occur), it issues a\n                  message and abends the job\n\n               2. Checks if any VSAM data set has been left\n                  in OPEN status by an abending job.  Every\n                  data set in this case is opened and closed.\n                  The way this condition is detected is quite\n                  interesting, look at the code.\n\n     DONTFAIL  Prevent job failure caused by uncataloged data\n               sets (ESA only, must be authorized)\n\n               This program has been designed to prevent jobs\n               that accept multiple inputs from failing in the\n               middle of the night because of a \"typo\" in a data\n               set name.  When DONTFAIL detects that an input\n               data set is not cataloged, it converts it to a\n               null data set and allows the job to run with\n               partial input.\n\n     SYSMOVE   Unload a PDS to a sequential data set in\n               IEHMOVE format.\n\n     UNITAFF   Dynamically sets UNIT=AFF for input tape files\n               (must be authorized)\n\n               This program was originally designed to reduce\n               the number of tape drives used by user-submitted\n               SAS steps.  It scans the SWA for the next step\n               and changes some of the SIOT's fields to force\n               all input tape data sets to the same drive.\n\n               It must be executed immediately before the\n               step to process (SAS, SORT, or any other\n               program that reads a variable number of tape\n               files, one at a time).\n\n               Sample jcl:\n\n                 //UNITAFF EXEC PGM=UNITAFF\n                 //STEPLIB  DD  DSN=SYS2.AUTHLIB,DISP=SHR\n                 //*\n                 //STEP53  EXEC PGM=SAS\n                 //OSIN     DD DSN=USER1.X,DISP=SHR\n                 //         DD DSN=UPQE.DQE40530(-1),DISP=SHR\n                 //OSIN2    DD DSN=UPQR.DQR02150(0),DISP=SHR\n                 //OSIN3    DD DSN=USER1.X,DISP=SHR\n                 //         DD DSN=UPBG.DBGA0240(-1),DISP=SHR\n                 //OSIN4    DD DSN=USER1.X,DISP=SHR\n                 //         DD DSN=USER1.YY,DISP=SHR\n                 //         DD DSN=UPQR.DQR02140(-1),DISP=SHR\n\n               The program only supports cataloged data sets;\n               relative generation numbers are handled\n               correctly via the GDGNT.\n\n               Restriction: No distinction is made between 3420,\n               3480 or 3490 device types; this will cause\n               problems if the input to a step is mixed.\n\n\n     ------------------ Assembler Macros ------------------------\n\n     BUILDCDE  Make storage allocated with GETMAIN appear as a\n               load-module in a dump.\n\n               BUILDCDE uses the \"loader\" form of IDENTIFY to\n               create a major CDE and corresponding XL, then\n               issues a LOAD SVC to create an LLE and associate\n               the CDE with the current TCB.  Don't worry, you\n               don't have to understand how it works to use it.\n\n               EXAMPLE:\n\n                     GETMAIN RU,LV=20000\n                     BUILDCDE LENGTH=(0),ADDR=(1),EP=DYNAM20\n\n               The 20K storage area will appear in a dump\n               as a load-module called \"DYNAM20\".\n\n     EASYSORT  Invoke an internal SORT with OPEN/PUT/GET logic\n\n               Allows you to do internal sorts without any\n               knowledge of parameter lists or exit routine\n               linkage conventions.\n\n               Example:\n\n                         EASYSORT OPEN,\n                               FIELDS=(1,22,CH,A),\n                               TYPE=F,LENGTH=64,\n                               OPTION='EQUALS,RESINV=500K'\n                         .     .\n                 READ    GET   FILEIN\n                         EASYSORT PUT,(1)   pass record to SORT\n                         B     READ\n                         .     .\n                 REWRITE EASYSORT GET,      get sorted record\n                               SET=(R3),\n                               EODAD=ENDSORT\n                         PUT   FILEOUT,(R3)\n                         B     REWRITE\n                         .     .\n                 ENDSORT EASYSORT CLOSE\n\n     GETDIR    Read a directory sequentially with a BPAM DCB\n\n               This macro offers a simple way to read directory\n               entries and members with a single BPAM DCB.\n\n     STRING    Provides functions similar to PL/I's\n               PUT EDIT or COBOL's STRING.\n\n               This is the only non-IBM macro you need to\n               assemble the programs in this file.\n\n               This member contains the macro, a test job,\n               and the documentation.\n\n\n     ---------------------- Miscellaneous -----------------------\n\n     DEFGDGSR  Sub-routine - invokes SVC 26 to define a GDG base\n\n               May be invoked from a COBOL program, like this:\n\n                     05  DSNAME   PIC X(44) VALUE 'MY.DSNAME'.\n                     05  GDGLIMIT PIC   999 VALUE 027.\n\n                         CALL 'DEFGDGSR' USING DSNAME,\n                                               GDGLIMIT.\n\n     FILLDASD  Asm pgm to fill free DASD space with binary zeroes\n\n     HANDBOOK  Job - Creates an on-line copy of the DATA AREAS\n               (aka Debugging Handbook) manuals\n\n               This job assembles macros from SYS1.MACLIB and\n               SYS1.AMODGEN and stores the assembly listings\n               into PDS members.  It is set up for over 60\n               commonly used MVS control blocks (such as CVT,\n               TCB, JFCB, etc) and may be easily modified to\n               support other ones.\n\n               The assembly listing for each macro is stored\n               into the output PDS under the control block\n               name.  For example, the assembly listing for\n               \"IKJTCB\" is stored into the \"TCB\" member.\n\n               To conserve dasd space, the LMCOPY service of\n               ISPF/PDF is used to pack the output of the\n               assembler.\n\n     TCTDCTR   Sub-routine - Prints the EXCP count for each DD\n               in the job step\n\n               May be invoked at the end of a program for\n               debugging or tuning purposes.\n\n     TRIMMAC   Job - Creates a reduced-size MACLIB that may be\n               used instead of the SYS1.MACLIB/SYS1.AMODGEN\n               concatenation to improve the performance of the\n               assembler.\n\n               The \"TRIMMAC\" library is built as follows:\n\n               1. selected macros are read from ddname \"SYSLIB\",\n                  trimmed from PL/AS code and other comment\n                  lines, then written to a temporary data set.\n\n               2. the SORT utility is invoked to sort the macros\n                  in ascending sequence of their size.\n\n               3. the sorted macros are written to SYSPUNCH\n                  as an IEBUPDTE sysin stream.\n\n               4. IEBUPDTE is executed in the last step to\n                  load the macros into the \"TRIMMAC\" library,\n                  the smallest macros being loaded first.\n\n               You may customize the member list and the input\n               concatenation to add other macros and/or macro\n               libraries, as needed.\n\n               Use the \"TRIMMAC\" library instead of the\n               MACLIB/AMODGEN concatenation to assemble a\n               program and compare the before/after values for\n               the elapsed time, excp count and I/O connect\n               time.  Expect savings of 30 to 60 percent when\n               \"TRIMMAC\" is used.\n\n               My \"TRIMMAC\" PDS is currently allocated as\n               follows:\n\n                   UNIT=3390,SPACE=(CYL,(9,,18)),\n                   DCB=(RECFM=FB,LRECL=80,BLKSIZE=29720)\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@FILE749": {"ttr": 526, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04U\\x00\\x00\\x01\\x12%\\x7f\\x01\\x12%\\x7f!\\x07\\x01r\\x01r\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf8\\xf5@@@'", "ispf": {"version": "04.85", "flags": 0, "createdate": "2012-09-13T00:00:00", "modifydate": "2012-09-13T21:07:00", "lines": 370, "newlines": 370, "modlines": 0, "user": "CBT-485"}, "text": "//***FILE 749 is from Gilbert Saint-flour and contains programs     *   FILE 749\n//*           from his large collection of utilities on File 183,   *   FILE 749\n//*           which were reworked to be assembled with IFOX00 and   *   FILE 749\n//*           run under MVS 3.8 under Hercules.                     *   FILE 749\n//*                                                                 *   FILE 749\n//*           Unfortunately, Gilbert has passed on.  His software   *   FILE 749\n//*           support is being continued by Carlos Aguilera and     *   FILE 749\n//*           Sam Golob.                                            *   FILE 749\n//*                                                                 *   FILE 749\n//*           email:  carlos@gsf-soft.com                           *   FILE 749\n//*           email:  sbgolob@cbttape.org                           *   FILE 749\n//*                                                                 *   FILE 749\n//*                .----------------------------.                   *   FILE 749\n//*                |      CBT Tape File 183     |                   *   FILE 749\n//*                |  Index of OSVS238J Member  |                   *   FILE 749\n//*                '----------------------------'                   *   FILE 749\n//*                                                                 *   FILE 749\n//*           Gilbert's web site is being supported by Carlos       *   FILE 749\n//*           Aguilera:                                             *   FILE 749\n//*                                                                 *   FILE 749\n//*                 http://gsf-soft.com/Freeware                    *   FILE 749\n//*                                                                 *   FILE 749\n//*                         COPYRIGHT                               *   FILE 749\n//*                                                                 *   FILE 749\n//*     These programs are Freeware and may be freely copied.       *   FILE 749\n//*     They may be freely distributed to any other party on        *   FILE 749\n//*     condition that no inducement beyond reasonable handling     *   FILE 749\n//*     costs is offered or accepted by either side for such        *   FILE 749\n//*     distribution.                                               *   FILE 749\n//*                                                                 *   FILE 749\n//*                         DISCLAIMER                              *   FILE 749\n//*                                                                 *   FILE 749\n//*     Gilbert Saint-Flour neither expresses nor implies any       *   FILE 749\n//*     warranty as to the fitness of these computer programs for   *   FILE 749\n//*     any function.  The use of these programs or the results     *   FILE 749\n//*     therefrom is entirely at the risk of the user.              *   FILE 749\n//*     Consequently, the user may modify these programs in any     *   FILE 749\n//*     way he/she thinks fit.                                      *   FILE 749\n//*                                                                 *   FILE 749\n//*                     CONTACT INFORMATION                         *   FILE 749\n//*                                                                 *   FILE 749\n//*     We would be interested to hear of comments                  *   FILE 749\n//*     and/or proposed enhancements.  Please e-Mail to:            *   FILE 749\n//*                                                                 *   FILE 749\n//*              Carlos Aguilera <carlos@gsf-soft.com>              *   FILE 749\n//*                                                                 *   FILE 749\n//*     or visit the web site at http://gsf-soft.com/Freeware       *   FILE 749\n//*                                                                 *   FILE 749\n//*                                                                 *   FILE 749\n//*  ----------------- TSO and ISPF commands -------------------    *   FILE 749\n//*                                                                 *   FILE 749\n//*  CLS       A 5-line \"clear screen\" command for TSO              *   FILE 749\n//*                                                                 *   FILE 749\n//*  EXECPGM   TSO command - invoke a utility program or compiler   *   FILE 749\n//*            with an alternate ddname list, as follows:           *   FILE 749\n//*               EXECPGM IEV90           +                         *   FILE 749\n//*                 PARM(NOOBJECT,NODECK,NOXREF,NORLD) +            *   FILE 749\n//*                 SYSIN(TEMPWK2)        +                         *   FILE 749\n//*                 SYSUT1(TEMPWK1)       +                         *   FILE 749\n//*                 SYSLIB(ASMLIB)        +                         *   FILE 749\n//*                 SYSPRINT(ASMH$PRT)    +                         *   FILE 749\n//*                 STEPLIB(LINKLIST)                               *   FILE 749\n//*                                                                 *   FILE 749\n//*  INITKSDS  Initialize a KSDS after it's been DEFINE'd           *   FILE 749\n//*                                                                 *   FILE 749\n//*            This program prevents OPEN from failing when         *   FILE 749\n//*            opening with MACRF=(IN,OUT) or STRNO=2 a KSDS        *   FILE 749\n//*            that has just been defined.  Can be invoked as       *   FILE 749\n//*            a batch program, a TSO command, or a sub-routine.    *   FILE 749\n//*                                                                 *   FILE 749\n//*  ------------------ Batch Programs --------------------------   *   FILE 749\n//*                                                                 *   FILE 749\n//*  BLKSIZE2  Scan a PDS and print the size of each block and      *   FILE 749\n//*            the track balance                                    *   FILE 749\n//*                                                                 *   FILE 749\n//*            This is a batch program, for people interested       *   FILE 749\n//*            in what a PDS looks like, from the inside.           *   FILE 749\n//*                                                                 *   FILE 749\n//*  BYPASSNQ  Assembler program.  Scratch or Rename a Data Set     *   FILE 749\n//*            without SYSDSN ENQ                                   *   FILE 749\n//*                                                                 *   FILE 749\n//*            BYPASSNQ is a driver that allows you to run any      *   FILE 749\n//*            utility program (such as IEHPROGM or IDCAMS) and     *   FILE 749\n//*            bypass dsname ENQ that is normally performed by      *   FILE 749\n//*            the DYNALLOC, SCRATCH and RENAME SVCs.               *   FILE 749\n//*                                                                 *   FILE 749\n//*  CANMSGCL  Purge current job's held output after a few hours.   *   FILE 749\n//*            Useful for those jobs that work OK 99% of the time   *   FILE 749\n//*            (must be authorized)                                 *   FILE 749\n//*                                                                 *   FILE 749\n//*            Example:                                             *   FILE 749\n//*                                                                 *   FILE 749\n//*              //MYJOB    JOB ACCT#,CLASS=A,MSGCLASS=X            *   FILE 749\n//*              //COPY1   EXEC PGM=IEBCOPY                         *   FILE 749\n//*              //...      DD   ...                                *   FILE 749\n//*              //CONDPURG EXEC PGM=CANMSGCL,PARM=2,               *   FILE 749\n//*              //              COND=(0,NE,COPY1)                  *   FILE 749\n//*                                                                 *   FILE 749\n//*              The number in the parm is a number of hours.       *   FILE 749\n//*              If the 'COPY1' step ends at 10:28 with a           *   FILE 749\n//*              return code equal to zero, the 'CONDPURG' step     *   FILE 749\n//*              executes and issues the following command:         *   FILE 749\n//*                                                                 *   FILE 749\n//*                $TA,T=12.28,'$OJ01234,Q=X,CANCEL'                *   FILE 749\n//*                                                                 *   FILE 749\n//*  CLEANUP   Assembler program.  Automatically searches the MVS   *   FILE 749\n//*            catalog for non-GDG data sets that will be created   *   FILE 749\n//*            in subsequent steps of your job and deletes them.    *   FILE 749\n//*                                                                 *   FILE 749\n//*                  //MYJOB   JOB  acct#                           *   FILE 749\n//*                  //*                                            *   FILE 749\n//*                  //CLEANUP EXEC PGM=CLEANUP                     *   FILE 749\n//*                  //*                                            *   FILE 749\n//*                  //STEP1   EXEC PGM=MYPROG1                     *   FILE 749\n//*                  //OUTDD    DD  DSN=MY.FILE1,DISP=(,CATLG)      *   FILE 749\n//*                  //STEP2   EXEC PGM=MYPROG2                     *   FILE 749\n//*                  //OUTDD    DD  DSN=MY.FILE2,DISP=(,CATLG)      *   FILE 749\n//*                                                                 *   FILE 749\n//*            Can also be executed as the LAST step of a job to    *   FILE 749\n//*            delete non-GDG data sets that were created during    *   FILE 749\n//*            job execution.                                       *   FILE 749\n//*                                                                 *   FILE 749\n//*  CMDJ      Send a JES2 command with the current job's number    *   FILE 749\n//*            (must be authorized)                                 *   FILE 749\n//*                                                                 *   FILE 749\n//*            Example:                                             *   FILE 749\n//*                                                                 *   FILE 749\n//*               //PURGEJOB EXEC PGM=CMDJES2,PARM=P                *   FILE 749\n//*                                                                 *   FILE 749\n//*            If the current job's number is JOB01234,             *   FILE 749\n//*            then the following command is issued:                *   FILE 749\n//*                                                                 *   FILE 749\n//*                  $PJ  01234                                     *   FILE 749\n//*                                                                 *   FILE 749\n//*  GSFLKED   Front-end to the linkage editor to recover           *   FILE 749\n//*            from SD37 on SYSLMOD (must be authorized)            *   FILE 749\n//*                                                                 *   FILE 749\n//*            This program may be invoked instead of the DFP       *   FILE 749\n//*            linkage editor. It calls the linkage editor and,     *   FILE 749\n//*            if an SD37 abend occurs, calls IEBCOPY to compress   *   FILE 749\n//*            the SYSLMOD PDS, then calls the linkage editor       *   FILE 749\n//*            again.                                               *   FILE 749\n//*                                                                 *   FILE 749\n//*            Another feature of this program is to                *   FILE 749\n//*            conditionally append a PDS member to SYSLIN,         *   FILE 749\n//*            if that member exists.                               *   FILE 749\n//*                                                                 *   FILE 749\n//*  JOBRLSE   Release a job by number (must be authorized)         *   FILE 749\n//*                                                                 *   FILE 749\n//*            This program issues a $A command to release a job    *   FILE 749\n//*            previously submitted to JES2 with \"TYPRUN=HOLD\".     *   FILE 749\n//*                                                                 *   FILE 749\n//*            To prevent \"multiple jobs found\" conditions,         *   FILE 749\n//*            this program uses the sub-system interface           *   FILE 749\n//*            to inquire about the status of homonym jobs.         *   FILE 749\n//*            Then, it issues a $A command with the job            *   FILE 749\n//*            number of the first job found in the input           *   FILE 749\n//*            queue in held status (for example: $A J1234).        *   FILE 749\n//*                                                                 *   FILE 749\n//*            Sample execution JCL:                                *   FILE 749\n//*                                                                 *   FILE 749\n//*              //RLSENEXT EXEC PGM=JOBRLSE,PARM=PAYROL22          *   FILE 749\n//*                                                                 *   FILE 749\n//*  NOTCTLG3  Prolog step to prevent \"NOT CATLG 2\" and verify      *   FILE 749\n//*            VSAM data sets                                       *   FILE 749\n//*                                                                 *   FILE 749\n//*            This program may be executed at the beginning        *   FILE 749\n//*            of a batch job.  It scans the job's SWA to           *   FILE 749\n//*            locate JFCBs and does two things:                    *   FILE 749\n//*                                                                 *   FILE 749\n//*            1. checks if any non-gdg data set with               *   FILE 749\n//*               DISP=(NEW,CATLG) is already cataloged.            *   FILE 749\n//*               If it finds at least one (i.e. a \"NOT             *   FILE 749\n//*               CATLG 2\" is about to occur), it issues a          *   FILE 749\n//*               message and abends the job                        *   FILE 749\n//*                                                                 *   FILE 749\n//*            2. Checks if any VSAM data set has been left         *   FILE 749\n//*               in OPEN status by an abending job.  Every         *   FILE 749\n//*               data set in this case is opened and closed.       *   FILE 749\n//*               The way this condition is detected is quite       *   FILE 749\n//*               interesting, look at the code.                    *   FILE 749\n//*                                                                 *   FILE 749\n//*  DONTFAIL  Prevent job failure caused by uncataloged data       *   FILE 749\n//*            sets (ESA only, must be authorized)                  *   FILE 749\n//*                                                                 *   FILE 749\n//*            This program has been designed to prevent jobs       *   FILE 749\n//*            that accept multiple inputs from failing in the      *   FILE 749\n//*            middle of the night because of a \"typo\" in a data    *   FILE 749\n//*            set name.  When DONTFAIL detects that an input       *   FILE 749\n//*            data set is not cataloged, it converts it to a       *   FILE 749\n//*            null data set and allows the job to run with         *   FILE 749\n//*            partial input.                                       *   FILE 749\n//*                                                                 *   FILE 749\n//*  SYSMOVE   Unload a PDS to a sequential data set in             *   FILE 749\n//*            IEHMOVE format.                                      *   FILE 749\n//*                                                                 *   FILE 749\n//*  UNITAFF   Dynamically sets UNIT=AFF for input tape files       *   FILE 749\n//*            (must be authorized)                                 *   FILE 749\n//*                                                                 *   FILE 749\n//*            This program was originally designed to reduce       *   FILE 749\n//*            the number of tape drives used by user-submitted     *   FILE 749\n//*            SAS steps.  It scans the SWA for the next step       *   FILE 749\n//*            and changes some of the SIOT's fields to force       *   FILE 749\n//*            all input tape data sets to the same drive.          *   FILE 749\n//*                                                                 *   FILE 749\n//*            It must be executed immediately before the           *   FILE 749\n//*            step to process (SAS, SORT, or any other             *   FILE 749\n//*            program that reads a variable number of tape         *   FILE 749\n//*            files, one at a time).                               *   FILE 749\n//*                                                                 *   FILE 749\n//*            Sample jcl:                                          *   FILE 749\n//*                                                                 *   FILE 749\n//*              //UNITAFF EXEC PGM=UNITAFF                         *   FILE 749\n//*              //STEPLIB  DD  DSN=SYS2.AUTHLIB,DISP=SHR           *   FILE 749\n//*              //*                                                *   FILE 749\n//*              //STEP53  EXEC PGM=SAS                             *   FILE 749\n//*              //OSIN     DD DSN=USER1.X,DISP=SHR                 *   FILE 749\n//*              //         DD DSN=UPQE.DQE40530(-1),DISP=SHR       *   FILE 749\n//*              //OSIN2    DD DSN=UPQR.DQR02150(0),DISP=SHR        *   FILE 749\n//*              //OSIN3    DD DSN=USER1.X,DISP=SHR                 *   FILE 749\n//*              //         DD DSN=UPBG.DBGA0240(-1),DISP=SHR       *   FILE 749\n//*              //OSIN4    DD DSN=USER1.X,DISP=SHR                 *   FILE 749\n//*              //         DD DSN=USER1.YY,DISP=SHR                *   FILE 749\n//*              //         DD DSN=UPQR.DQR02140(-1),DISP=SHR       *   FILE 749\n//*                                                                 *   FILE 749\n//*            The program only supports cataloged data sets;       *   FILE 749\n//*            relative generation numbers are handled              *   FILE 749\n//*            correctly via the GDGNT.                             *   FILE 749\n//*                                                                 *   FILE 749\n//*            Restriction: No distinction is made between 3420,    *   FILE 749\n//*            3480 or 3490 device types; this will cause           *   FILE 749\n//*            problems if the input to a step is mixed.            *   FILE 749\n//*                                                                 *   FILE 749\n//*                                                                 *   FILE 749\n//*  ------------------ Assembler Macros ------------------------   *   FILE 749\n//*                                                                 *   FILE 749\n//*  BUILDCDE  Make storage allocated with GETMAIN appear as a      *   FILE 749\n//*            load-module in a dump.                               *   FILE 749\n//*                                                                 *   FILE 749\n//*            BUILDCDE uses the \"loader\" form of IDENTIFY to       *   FILE 749\n//*            create a major CDE and corresponding XL, then        *   FILE 749\n//*            issues a LOAD SVC to create an LLE and associate     *   FILE 749\n//*            the CDE with the current TCB.  Don't worry, you      *   FILE 749\n//*            don't have to understand how it works to use it.     *   FILE 749\n//*                                                                 *   FILE 749\n//*            EXAMPLE:                                             *   FILE 749\n//*                                                                 *   FILE 749\n//*                  GETMAIN RU,LV=20000                            *   FILE 749\n//*                  BUILDCDE LENGTH=(0),ADDR=(1),EP=DYNAM20        *   FILE 749\n//*                                                                 *   FILE 749\n//*            The 20K storage area will appear in a dump           *   FILE 749\n//*            as a load-module called \"DYNAM20\".                   *   FILE 749\n//*                                                                 *   FILE 749\n//*  EASYSORT  Invoke an internal SORT with OPEN/PUT/GET logic      *   FILE 749\n//*                                                                 *   FILE 749\n//*            Allows you to do internal sorts without any          *   FILE 749\n//*            knowledge of parameter lists or exit routine         *   FILE 749\n//*            linkage conventions.                                 *   FILE 749\n//*                                                                 *   FILE 749\n//*            Example:                                             *   FILE 749\n//*                                                                 *   FILE 749\n//*                      EASYSORT OPEN,                             *   FILE 749\n//*                            FIELDS=(1,22,CH,A),                  *   FILE 749\n//*                            TYPE=F,LENGTH=64,                    *   FILE 749\n//*                            OPTION='EQUALS,RESINV=500K'          *   FILE 749\n//*                      .     .                                    *   FILE 749\n//*              READ    GET   FILEIN                               *   FILE 749\n//*                      EASYSORT PUT,(1)   pass record to SORT     *   FILE 749\n//*                      B     READ                                 *   FILE 749\n//*                      .     .                                    *   FILE 749\n//*              REWRITE EASYSORT GET,      get sorted record       *   FILE 749\n//*                            SET=(R3),                            *   FILE 749\n//*                            EODAD=ENDSORT                        *   FILE 749\n//*                      PUT   FILEOUT,(R3)                         *   FILE 749\n//*                      B     REWRITE                              *   FILE 749\n//*                      .     .                                    *   FILE 749\n//*              ENDSORT EASYSORT CLOSE                             *   FILE 749\n//*                                                                 *   FILE 749\n//*  GETDIR    Read a directory sequentially with a BPAM DCB        *   FILE 749\n//*                                                                 *   FILE 749\n//*            This macro offers a simple way to read directory     *   FILE 749\n//*            entries and members with a single BPAM DCB.          *   FILE 749\n//*                                                                 *   FILE 749\n//*  STRING    Provides functions similar to PL/I's                 *   FILE 749\n//*            PUT EDIT or COBOL's STRING.                          *   FILE 749\n//*                                                                 *   FILE 749\n//*            This is the only non-IBM macro you need to           *   FILE 749\n//*            assemble the programs in this file.                  *   FILE 749\n//*                                                                 *   FILE 749\n//*            This member contains the macro, a test job,          *   FILE 749\n//*            and the documentation.                               *   FILE 749\n//*                                                                 *   FILE 749\n//*                                                                 *   FILE 749\n//*  ---------------------- Miscellaneous -----------------------   *   FILE 749\n//*                                                                 *   FILE 749\n//*  DEFGDGSR  Sub-routine - invokes SVC 26 to define a GDG base    *   FILE 749\n//*                                                                 *   FILE 749\n//*            May be invoked from a COBOL program, like this:      *   FILE 749\n//*                                                                 *   FILE 749\n//*                  05  DSNAME   PIC X(44) VALUE 'MY.DSNAME'.      *   FILE 749\n//*                  05  GDGLIMIT PIC   999 VALUE 027.              *   FILE 749\n//*                                                                 *   FILE 749\n//*                      CALL 'DEFGDGSR' USING DSNAME,              *   FILE 749\n//*                                            GDGLIMIT.            *   FILE 749\n//*                                                                 *   FILE 749\n//*  FILLDASD  Asm pgm to fill free DASD space with binary zeroes   *   FILE 749\n//*                                                                 *   FILE 749\n//*  HANDBOOK  Job - Creates an on-line copy of the DATA AREAS      *   FILE 749\n//*            (aka Debugging Handbook) manuals                     *   FILE 749\n//*                                                                 *   FILE 749\n//*            This job assembles macros from SYS1.MACLIB and       *   FILE 749\n//*            SYS1.AMODGEN and stores the assembly listings        *   FILE 749\n//*            into PDS members.  It is set up for over 60          *   FILE 749\n//*            commonly used MVS control blocks (such as CVT,       *   FILE 749\n//*            TCB, JFCB, etc) and may be easily modified to        *   FILE 749\n//*            support other ones.                                  *   FILE 749\n//*                                                                 *   FILE 749\n//*            The assembly listing for each macro is stored        *   FILE 749\n//*            into the output PDS under the control block          *   FILE 749\n//*            name.  For example, the assembly listing for         *   FILE 749\n//*            \"IKJTCB\" is stored into the \"TCB\" member.            *   FILE 749\n//*                                                                 *   FILE 749\n//*            To conserve dasd space, the LMCOPY service of        *   FILE 749\n//*            ISPF/PDF is used to pack the output of the           *   FILE 749\n//*            assembler.                                           *   FILE 749\n//*                                                                 *   FILE 749\n//*  TCTDCTR   Sub-routine - Prints the EXCP count for each DD      *   FILE 749\n//*            in the job step                                      *   FILE 749\n//*                                                                 *   FILE 749\n//*            May be invoked at the end of a program for           *   FILE 749\n//*            debugging or tuning purposes.                        *   FILE 749\n//*                                                                 *   FILE 749\n//*  TRIMMAC   Job - Creates a reduced-size MACLIB that may be      *   FILE 749\n//*            used instead of the SYS1.MACLIB/SYS1.AMODGEN         *   FILE 749\n//*            concatenation to improve the performance of the      *   FILE 749\n//*            assembler.                                           *   FILE 749\n//*                                                                 *   FILE 749\n//*            The \"TRIMMAC\" library is built as follows:           *   FILE 749\n//*                                                                 *   FILE 749\n//*            1. selected macros are read from ddname \"SYSLIB\",    *   FILE 749\n//*               trimmed from PL/AS code and other comment         *   FILE 749\n//*               lines, then written to a temporary data set.      *   FILE 749\n//*                                                                 *   FILE 749\n//*            2. the SORT utility is invoked to sort the macros    *   FILE 749\n//*               in ascending sequence of their size.              *   FILE 749\n//*                                                                 *   FILE 749\n//*            3. the sorted macros are written to SYSPUNCH         *   FILE 749\n//*               as an IEBUPDTE sysin stream.                      *   FILE 749\n//*                                                                 *   FILE 749\n//*            4. IEBUPDTE is executed in the last step to          *   FILE 749\n//*               load the macros into the \"TRIMMAC\" library,       *   FILE 749\n//*               the smallest macros being loaded first.           *   FILE 749\n//*                                                                 *   FILE 749\n//*            You may customize the member list and the input      *   FILE 749\n//*            concatenation to add other macros and/or macro       *   FILE 749\n//*            libraries, as needed.                                *   FILE 749\n//*                                                                 *   FILE 749\n//*            Use the \"TRIMMAC\" library instead of the             *   FILE 749\n//*            MACLIB/AMODGEN concatenation to assemble a           *   FILE 749\n//*            program and compare the before/after values for      *   FILE 749\n//*            the elapsed time, excp count and I/O connect         *   FILE 749\n//*            time.  Expect savings of 30 to 60 percent when       *   FILE 749\n//*            \"TRIMMAC\" is used.                                   *   FILE 749\n//*                                                                 *   FILE 749\n//*            My \"TRIMMAC\" PDS is currently allocated as           *   FILE 749\n//*            follows:                                             *   FILE 749\n//*                                                                 *   FILE 749\n//*                UNIT=3390,SPACE=(CYL,(9,,18)),                   *   FILE 749\n//*                DCB=(RECFM=FB,LRECL=80,BLKSIZE=29720)            *   FILE 749\n//*                                                                 *   FILE 749\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "BLKSIZE2": {"ttr": 774, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\x00\\x00\\x87\\x19\\x0f\\x01\\x06!\\x0f\\x108\\x00\\x9e\\x00d\\x00[\\xc3\\xc2\\xe3\\xf4\\xf7\\xf2@@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "1987-07-09T00:00:00", "modifydate": "2006-07-29T10:38:00", "lines": 158, "newlines": 100, "modlines": 91, "user": "CBT472"}, "text": "//GILBERTB JOB (ACCT#),DISPLAY.BLKSIZE,\n// CLASS=A,MSGCLASS=X,COND=(0,NE),\n// NOTIFY=&SYSUID,REGION=6M\n//*\n//ASMXF EXEC PGM=IFOX00,PARM=(OBJECT,NODECK,NOESD,NORLD,ALIGN,NOXREF)\n***********************************************************************\n**                                                                   **\n**       THIS PROGRAM SCANS A PDS AND PRINTS THE SIZE                **\n**       OF EACH DATA BLOCK, AS WELL AS THE NUMBER OF                **\n**       BYTES REMAINING AT THE END OF EACH TRACK.                   **\n**                                                                   **\n**       THIS PROGRAM WAS INITIALLY DESIGNED TO STUDY HOW            **\n**       CHANGING THE BLKSIZE OF A PDS AFFECTS SPACE USAGE.          **\n**                                                                   **\n***********************************************************************\nBLKSIZE  START X'0FC010'\n         SAVE  (14,12),,BLKSIZE.&SYSDATE\n         LR    R12,R15\n         USING BLKSIZE,R12\n         ST    R13,SAVEAREA+4\n         LA    R13,SAVEAREA\n         OPEN  MF=(E,OPENLIST)         OPEN SYSUT1/SYSPRINT\n         LTR   R15,R15\n         BNZ   ABEND16\n         LA    R8,SYSUT1\n         USING IHADCB,R8\n***********************************************************************\n******   READ A TRACK                                            ******\n***********************************************************************\n*LOOP\nLOOP21   L     R0,DCBRELAD             GET TTRN\n         L     R1,DCBDEBAD             DEB ADDRESS\n         LA    R2,MBBCCHHR             MBBCCHHR FIELD\n         STM   R8,R13,20(R13)          SAVE R8-R13\n         LR    R8,R13                  SAVE R8-R13\n         L     R15,16                  CVTPTR\n         L     R15,28(,R15)            CVTPCNVT\n         BALR  R14,R15                 COMPUTE MBBCCHHR\n         LM    R8,R13,20(R8)           RESTORE R8-R13\n         LTR   R15,R15                 SUCCESSFUL?\n         BNZ   CLOSEUT1                END OF EXTENT, CLOSE\n         EXCP  IOB1                    FULL TRACK READ\n         WAIT  1,ECB=ECB1\n***********************************************************************\n******   SCAN TRACK                                              ******\n***********************************************************************\n         LM    R3,R4,CCW4              FIRST BUFFER\n         USING COUNT,R3\n         LA    R3,0(,R3)               START OF BUFFER\n         LA    R5,0(R3,R4)             END OF BUFFER\n         SLR   R0,R0\n         ICM   R0,B'0011',IOB1+14      RESIDUAL COUNT\n         SLR   R5,R0\n         BCTR  R5,0                    LAST BYTE XFERED FROM TRACK\n         MVI   PRTAREA+43,C'T'         NEW TRACK\n         SLR   R6,R6                   CUMULATIVE LENGTH\n*--LOOP\nLOOP36C  TRKCALC FUNCTN=TRKBAL,DEVTAB=DCBDVTBL,RKDD=COUNTR,BALANCE=*\n         CVD   R0,DWD                  TRKBAL\n         OI    DWD+7,15\n         UNPK  PRTAREA+13(5),DWD\n         LH    R4,COUNTDL              DATA LENGTH\n         CVD   R4,DWD\n         OI    DWD+7,15\n         UNPK  PRTAREA+03(5),DWD\n         AR    R6,R4                   CUMULATIVE LENGTH\n         CVD   R6,DWD\n         OI    DWD+7,15\n         UNPK  PRTAREA+33(5),DWD\n*\n         UNPK  PRTAREA+50(9),COUNT(5)    SHOW CCHHRKDD IN HEX\n         TR    PRTAREA+50(9),TABHEX-240  SHOW CCHHRKDD IN HEX\n         UNPK  PRTAREA+58(9),COUNT+4(5)  SHOW CCHHRKDD IN HEX\n         TR    PRTAREA+58(9),TABHEX-240  SHOW CCHHRKDD IN HEX\n         MVI   PRTAREA+66,C' '           SHOW CCHHRKDD IN HEX\n*\n         PUT   SYSPRINT,PRTAREA        WRITE RECORD\n         MVI   PRTAREA+43,C' '         RESET \"START OF TRACK\" FLAG\n*\n         SLR   R1,R1\n         IC    R1,COUNTKL              KEY LENGTH\n         LA    R4,8(R1,R4)             8+KL+DL\n         BXLE  R3,R4,LOOP36C           PROCESS NEXT BLOCK\n*--ENDLOOP\n         MVC   PRTAREA+1(79),PRTAREA\n         PUT   SYSPRINT,PRTAREA\n         LA    R0,X'0001'              NEXT TRACK\n         AH    R0,DCBRELAD             TTRN NEXT TRACK\n         STH   R0,DCBRELAD             TTRN NEXT TRACK\n         B     LOOP21                  PROCESS NEXT TRACK\n*ENDLOOP\nCLOSEUT1 CLOSE MF=(E,OPENLIST)         CLOSE SYSUT1 & SYSPRINT\n         L     13,4(,13)\n         RETURN (14,12),RC=00\nABEND16  ABEND 0016\nTABHEX   DC    C'0123456789ABCDEF'\nOPENLIST OPEN  (SYSUT1,,SYSPRINT,OUTPUT),MF=L\nSYSUT1   DCB   MACRF=E,DDNAME=SYSUT1,IOBAD=IOB1\nSYSPRINT DCB   DSORG=PS,MACRF=PM,DDNAME=SYSPRINT,RECFM=FB,LRECL=80\n         CNOP  0,8 -------------------- IOB1 ---------------------\n         DC    CL4'IOB1'\nECB1     DC    A(0)                    ECB\nIOB1     DC    XL4'42000000'           FLAG1/2 SENSE1/2\n         DC    A(ECB1)                 ECBPTR\n         DC    X'00',XL7'00'           FLAG3 CSW\n         DC    A(CCW2)                 CCW ADDR\n         DC    A(SYSUT1)               DCBPTR\n         DC    2A(0)                   RESTR INCAM ERRCT\nMBBCCHHR DC    XL8'01'\n*                   ------------------ CCW'S -------------------\nCCW2     CCW   X'31',MBBCCHHR+3,X'40',5      SEARCH ID EQUAL\nCCW3     CCW   X'08',*-8,0,0                 TIC\nCCW4     CCW   X'5E',COUNT,X'20',65535       READ MULTIPLE, SLI\n*\nSAVEAREA DS    9D\nDWD      DS    1D\nPRTAREA  DC    CL80' '\n*\nCOUNT    DS    0D                      COUNT\nCOUNTCC  DS    H\nCOUNTHH  DS    H\nCOUNTR   DS    X\nCOUNTKL  DS    X\nCOUNTDL  DS    H\nKEY      DS    XL8                     KEY\nDATA     DS    65535X                  DATA\n         PRINT NOGEN\n         DCBD  DSORG=PS,DEVD=DA\n*        YREGS\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         END\n//SYSPRINT DD SYSOUT=*\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,15)\n//SYSUT2   DD UNIT=VIO,SPACE=(CYL,15)\n//SYSUT3   DD UNIT=VIO,SPACE=(CYL,15)\n//SYSGO    DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3120\n//*\n//GO      EXEC PGM=LOADER,PARM=NOPRINT\n//SYSLIN   DD DSN=*.ASMXF.SYSGO,DISP=(OLD,DELETE)\n//SYSUT1   DD DSN=GILBERT.TRIMMAC,DISP=SHR\n//SYSPRINT DD SYSOUT=*\n//SYSUDUMP DD SYSOUT=*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "BUILDCDE": {"ttr": 778, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x01\\x00\\x00\\x00\\x852_\\x01\\x06!\\x0f\\x10A\\x00\\xe1\\x00\\xe7\\x00\\x1c\\xc3\\xc2\\xe3\\xf4\\xf7\\xf2@@@@'", "ispf": {"version": "02.01", "flags": 0, "createdate": "1985-11-21T00:00:00", "modifydate": "2006-07-29T10:41:00", "lines": 225, "newlines": 231, "modlines": 28, "user": "CBT472"}, "text": "//GILBERTL JOB (ACCT#),BUILDCDE,\n// NOTIFY=&SYSUID,\n// CLASS=A,MSGCLASS=X,COND=(0,NE)\n//ASMXF EXEC PGM=IFOX00,PARM=(OBJECT,NODECK,NOESD,NORLD,ALIGN,NOXREF)\n***********************************************************************\n*                                                                     *\n* MACRO NAME = BUILDCDE                                               *\n*                                                                     *\n* DESCRIPTIVE NAME = BUILD A MAJOR CDE TO IDENTIFY A STORAGE AREA     *\n*                                                                     *\n* FUNCTION = MAKES A STORAGE AREA EASIER TO LOCATE IN A               *\n*            DUMP BY MAKING IT APPEAR AS A LOAD_MODULE.               *\n*                                                                     *\n* STATUS = R200                                                       *\n*                                                                     *\n* AUTHOR = GILBERT SAINT-FLOUR <carlos@gsf-soft.com>                  *\n*                                                                     *\n* ENVIRONMENT = SEE BELOW                                             *\n*                                                                     *\n*     SCP   = OS/VS2                                                  *\n*     KEY   = USER                                                    *\n*     MODE  = PROBLEM                                                 *\n*     APF   = OFF                                                     *\n*                                                                     *\n* OPERATION = BUILDCDE USES THE \"LOADER\" FORM OF IDENTIFY TO CREATE   *\n*             A MAJOR CDE AND CORRESPONDING XL, THEN ISSUES A LOAD    *\n*             SVC TO CREATE AN LLE AND ASSOCIATE THE CDE WITH THE     *\n*             CURRENT TCB.                                            *\n*                                                                     *\n* INVOCATION = SEE BELOW                                              *\n*                                                                     *\n*          (BEFORE)     GETMAIN RU,LV=20000                           *\n*                                                                     *\n*          (AFTER)      GETMAIN RU,LV=20000                           *\n*                       BUILDCDE LENGTH=(0),ADDR=(1),EP=DYNAM         *\n*                                                                     *\n* NOTES = SEE BELOW                                                   *\n*                                                                     *\n*        BUILDCDE MAY BE ISSUED MORE THAN ONCE, PROVIDED THE EP       *\n*        KEY-WORD HAS A DIFFERENT VALUE EACH TIME.                    *\n*                                                                     *\n*        IF STORAGE WAS ALLOCATED IN SUB-POOL ZERO (SP=0 IS           *\n*        SPECIFIED OR DEFAULTED TO IN THE GETMAIN MACRO),             *\n*        THE DELETE MACRO MAY BE ISSUED AGAINST THE SPECIFIED EP      *\n*        TO DELETE THE CDE AND FREE UP THE STORAGE.                   *\n*                                                                     *\n*        IF GETMAIN SPECIFIES A NON-ZERO SUBPOOL, THE DELETE MACRO    *\n*        DELETES THE CDE BUT DOES NOT FREE UP THE STORAGE:  YOU       *\n*        MUST ISSUE FREEMAIN YOURSELF.                                *\n*                                                                     *\n*        IN A MAJOR CDE CREATED BY THE \"LOADER\" FORM OF IDENTIFY,     *\n*        THE \"RENT\" AND \"REUS\" ATTRIBUTES ARE OFF.  THIS MEANS        *\n*        THAT YOU MAY NOT ISSUE LOAD AGAINST THE EP NAME (BUILDCDE    *\n*        HAS ALREADY ISSUED LOAD), BUT YOU MAY ISSUE LINK, ATTACH     *\n*        OR XCTL IF YOU WANT TO (ONCE ONLY).  YOU MAY ALSO ISSUE      *\n*        THE STANDARD FORM OF IDENTIFY TO DEFINE SECONDARY ENTRY      *\n*        POINTS WHICH HAVE THE \"RENT\" ATTRIBUTE.                      *\n*                                                                     *\n*        IF THIS MACRO IS USED BY AN AUTHORIZED PROGRAM, THEN         *\n*        A S306 ABEND WILL OCCUR (THE CDE CREATED HAS ITS CDSYSLIB    *\n*        BIT OFF).  LOOK FOR A SECOND VERSION OF THE MACRO THAT MAY   *\n*        BE USED IN AN AUTHORIZED PROGRAM AT THE END OF THIS JOB.     *\n*                                                                     *\n*        THE IDENTIFY MACRO SUPPLIED IN SYS1.MACLIB SUPPORTS THE      *\n*        \"LOADER\" FORM, BUT THE FORMAT OF THE PARAMETER LIST IS       *\n*        NOT DOCUMENTED, AS FAR AS I KNOW.  THE RETURN CODES X'18'    *\n*        OR X'1C' MAY BE RETURNED IN R15 WHEN THE PARAMETER LIST      *\n*        IS INVALID.  THESE RETURN CODES ARE DOCUMENTED ALONG WITH    *\n*        THE IDENTIFY MACRO.                                          *\n*                                                                     *\n*        WHEN THE LOAD-LIST IS EMPTY (I.E. NO LOAD HAS BEEN ISSUED    *\n*        FOR THIS TCB YET), IDENTIFY FAILS WITH A RETURN CODE 12.     *\n*        THIS CAN BE CIRCUMVENTED BY ISSUING THE FOLLOWING SEQUENCE:  *\n*                                                                     *\n*                       LOAD    EP=IEFBR14                            *\n*                       GETMAIN RU,LV=20000                           *\n*                       BUILDCDE LENGTH=(0),ADDR=(1),EP=DYNAM         *\n*                       DELETE  EP=IEFBR14                            *\n*                                                                     *\n*        I'VE NOTICED THAT ON MVS SYSTEMS PRIOR TO MVS/ESA 4.3, THE   *\n*        \"LOADER\" FORM OF IDENTIFY RETURNS THE ADDRESS OF THE CDE IT  *\n*        CREATED IN REG1.  IN MVS/ESA 4.3 THIS IS NO LONGER TRUE.     *\n*                                                                     *\n***********************************************************************\n         MACRO\n&REF     BUILDCDE &LENGTH=,&ADDR=,&EP=\n         LCLC   &EP8                   XF\n&EP8     SETC  '&EP          '(1,8)\n&REF     IHBINNRA &ADDR,&LENGTH        SET R0,R1\n         ST    R1,0(,R1)               STORE ENTRY-POINT ADDRESS\n         MVC   4(8,R1),=C'&EP8'        CDNAME\n         XC    12(4,R1),12(R1)         CLEAR BYTES 12-15\n         LA    R14,16                  LENGTH OF PSEUDO XL\n         LA    R15,1                   NUMBER OF RELOCATION FACTORS\n         STM   R14,R1,16(R1)           FORMAT BYTES 16-31\n         MVI   24(R1),X'80'            END OF LIST\n         MNOTE *,'       IDENTIFY MF=(E,(R1))'\n         SLR   R0,R0                   LOADER-TYPE IDENTIFY\n         SVC   41                      ISSUE IDENTIFY SVC\n         LR    R14,R1                  PASS CDE ADDRESS\n         MNOTE *,'       LOAD EP=&EP,DCB=0'\n         LA    R0,=C'&EP8'             POINT TO EP NAME\n         SLR   R1,R1                   NO DCB FOR LOAD\n         SVC   8                       ISSUE LOAD SVC\n         LR    R1,R0                   EP ADDRESS IN R1\n         SLR   R0,R0\n         ICM   R0,B'0111',25(R1)       LENGTH IN R0\n         MEND\n***********************************************************************\n********* TEST PROGRAM ************************************************\n***********************************************************************\nTEMPNAME CSECT\n         BALR  R3,0\n         USING *,R3\n         OPEN  (SNAPDD,OUTPUT)\n*\n         GETMAIN R,LV=3333\n         BUILDCDE LENGTH=(0),ADDR=(1),EP=DYNAM/24\n         LR    R4,R14\n         LR    R5,R15\n         LR    R6,R0\n         LR    R7,R1\n*\n         GETMAIN RU,LV=5678\n         BUILDCDE LENGTH=(0),ADDR=(1),EP=DYNAM/31\n         LR    R8,R14\n         LR    R9,R15\n         LR    R10,R0\n         LR    R11,R1\n*\n         SNAP  DCB=SNAPDD,SDATA=CB,PDATA=(REGS,JPA)\n*\n         MVC   0(8,R7),=X'0A23,0A03'   SVC 35 (WTO) AND SVC 3 (EXIT)\n         LA    R1,WTOL                 POINT TO WTO PARM LIST\n         LINK  EP=DYNAM/24             GO EXECUTE SVC35\n*\n         SNAP  DCB=SNAPDD,SDATA=CB     SHOW UPDATED CDE\n*\n         SVC   3                       EXIT\n*\nWTOL     WTO   'BUILDCDE - LINK WORKED!',ROUTCDE=11,MF=L\n*\nSNAPDD   DCB   DSORG=PS,MACRF=W,DDNAME=SNAPDD,                         X\n               RECFM=VBA,LRECL=125,BLKSIZE=882\n*        YREGS\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         END\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,15)\n//SYSUT2   DD UNIT=VIO,SPACE=(CYL,15)\n//SYSUT3   DD UNIT=VIO,SPACE=(CYL,15)\n//SYSGO    DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3120\n//SYSPRINT DD SYSOUT=*\n//*\n//GO      EXEC PGM=LOADER,PARM=NOPRINT\n//SYSLIN   DD DSN=*.ASMXF.SYSGO,DISP=(OLD,DELETE)\n//SNAPDD   DD SYSOUT=*\n//SYSUDUMP DD SYSOUT=*\n***********************************************************************\n********* AUTHORIZED VERSION OF THE BUILDCDE MACRO ********************\n***********************************************************************\n         MACRO (AUTHORIZED VERSION)\n&REF     BUILDCDE &RU,&LENGTH=,&SP=0,&WORKREG=,                        X\n               &BNDRY=DBLWD,&EP=BUILDCDE,&LOC=\n      MNOTE *,'       GETMAIN &RU,LV=&LENGTH,SP=&SP,BNDRY=&BNDRY,&LOC='\n&REF     GETMAIN &RU,LV=&LENGTH,SP=&SP,BNDRY=&BNDRY,&LOC=\n         ST    R1,0(,R1)               ENTRY POINT\n         MVC   4(8,R1),=CL8'&EP'       CDNAME\n         XC    12(4,R1),12(R1)         CLEAR BYTES 12-15\n         LA    R14,016                 LENGTH OF PSEUDO XL\n         LA    R15,001                 NUMBER OF RELOCATION FACTORS\n         STM   R14,R1,16(R1)           FORMAT SVC41 PARM\n         MVI   24(R1),X'80'            END OF LIST\n         LR    R14,R1                  SAVE ADDRESS ACROSS SVC 41\n         MNOTE *,'       IDENTIFY EPLOC=0,ENTRY=(R1)'\n         SLR   R0,R0                   LOADER-TYPE IDENTIFY\n         SVC   41                      ISSUE IDENTIFY SVC\n&LABEL   SETC  'IHB&SYSNDX'\n&R       SETC  '&WORKREG(1)'           SHORT FORM\n         AIF   (T'&WORKREG NE 'O').WKREG2\n         MNOTE 4,'WORKREG OPERAND OMITTED, WORKREG=(R2) ASSUMED'\n&R       SETC  'R2'\n.WKREG2  L     &R,540(,0)              PSATOLD (MY TCB)\n         L     &R,TCBJSCB-TCB(,&R)     MY JSCB\n         USING IEZJSCB,&R\n         TM    JSCBOPTS,JSCBAUTH       CHECK AUTHORIZATION\n         BZ    &LABEL.N                JUMP IF NOT AUTHORIZED\n         MODESET KEY=ZERO              SWITCH TO KEY ZERO\n         NI    JSCBOPTS,255-JSCBAUTH   TURN APF FLAG OFF\n         SYNCH &LABEL.L                EXECUTE ROUTINE WITH TCB KEY\n         OI    JSCBOPTS,JSCBAUTH       TURN APF FLAG BACK ON\n         DROP  &R\n         LR    &R,R0                   SAVE EP ADDRESS\n         MODESET KEY=NZERO             SWITCH TO TCB KEY\n         LR    R0,&R                   EP ADDRESS\n         B     &LABEL.X\n&LABEL.I EQU   &R-2                    WORKREG MUST BE R2-R13\n&LABEL.J EQU   13-&R                   WORKREG MUST BE R2-R13\n&LABEL.N LA    R14,&LABEL.X            RETURN ADDRESS\n         MNOTE *,'       LOAD EP=&EP,DCB=0'\n&LABEL.L LA    R0,=CL8'&EP'            POINT TO EP NAME\n         SLR   R1,R1                   NO DCB FOR LOAD\n         SVC   8                       ISSUE LOAD SVC\n         BR    R14\n&LABEL.X LR    R1,R0                   ADDRESS IN R1\n         SLR   R0,R0\n         ICM   R0,B'0111',25(R1)       LENGTH IN R0\n         MEND\n         IEZJSCB\n         IKJTCB\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "BYPASSNQ": {"ttr": 1027, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x03\\x00\\x00\\x00\\x87$\\x7f\\x01\\x06!\\x0f\\x11(\\x01)\\x00\\x19\\x00a\\xc3\\xc2\\xe3\\xf4\\xf7\\xf2@@@@'", "ispf": {"version": "02.03", "flags": 0, "createdate": "1987-09-04T00:00:00", "modifydate": "2006-07-29T11:28:00", "lines": 297, "newlines": 25, "modlines": 97, "user": "CBT472"}, "text": "//GILBERTQ JOB (ACCT#),BYPASSNQ,\n// NOTIFY=GILBERT,\n//*RESTART=CREATE,\n// CLASS=A,MSGCLASS=X,COND=(0,NE)\n//ASMXF EXEC PGM=IFOX00,PARM=(OBJECT,NODECK,NOESD,NORLD,ALIGN,NOXREF)\n***********************************************************************\n*                                                                     *\n* MODULE NAME = BYPASSNQ                                              *\n*                                                                     *\n* DESCRIPTIVE NAME = SCRATCH/RENAME A DATA SET WITHOUT ENQ            *\n*                                                                     *\n* STATUS = R203                                                       *\n*                                                                     *\n* FUNCTION = This program was designed for systems programmers        *\n*            who install a new version of MVS or another software     *\n*            product.  They sometimes face a situation where they     *\n*            have to delete or rename a data set not currently        *\n*            allocated to anyone but which they can't delete          *\n*            because it has the same name as another data set         *\n*            which (1) exists on a different disk volume and          *\n*            (2) is currently allocated to a long-running task.       *\n*                                                                     *\n*            BYPASSNQ is a driver that allows you to run any          *\n*            utility program (such as IEHPROGM or IDCAMS) and         *\n*            bypass dsname ENQ that is normally performed by          *\n*            the DYNALLOC, SCRATCH and RENAME SVCs.                   *\n*            This technique allows data sets to be deleted or         *\n*            renamed using standard MVS services and is fully         *\n*            compatible with indexed VTOCs and SMS.                   *\n*                                                                     *\n* AUTHOR = Gilbert Saint-Flour <carlos@gsf-soft.com>                  *\n*                                                                     *\n* ENVIRONMENT = SEE BELOW                                             *\n*                                                                     *\n*    DEPENDENCIES: OS/VS2                                             *\n*                                                                     *\n* MODULE TYPE = PROCEDURE, (CSECT TYPE)                               *\n*                                                                     *\n*    PROCESSOR = Assembler XF                                         *\n*                                                                     *\n*    MODULE SIZE = 2K                                                 *\n*                                                                     *\n*    ATTRIBUTES = REENTERABLE, RMODE ANY, AMODE 31                    *\n*                 SUPERVISOR STATE, KEY 8                             *\n*                 APF AUTHORIZATION: YES                              *\n*                                                                     *\n* SYNTAX = SEE BELOW                                                  *\n*                                                                     *\n*          The name of the utility program is passed in the PARM      *\n*                                                                     *\n*          Examples:                                                  *\n*                                                                     *\n*               //SCRATCH EXEC PGM=BYPASSNQ,PARM=IEHPROGM             *\n*               //DD1      DD UNIT=3390,VOL=SER=OS39R3,DISP=OLD       *\n*               //SYSPRINT DD SYSOUT=*                                *\n*                 RENAME DSNAME=GILBERT.TEST29,VOL=3390=OS39R3,      X*\n*                              NEWNAME=GILBERT.TEST29B                *\n*                SCRATCH DSNAME=GILBERT.TEST29B,VOL=3390=OS39R3       *\n*                                                                     *\n*               //ALTER   EXEC PGM=BYPASSNQ,PARM=IDCAMS               *\n*               //SYSPRINT DD SYSOUT=*                                *\n*                 ALTER IBMUSER.TEST29 NEWNAME(IBMUSER.TEST29B)       *\n*                 DELETE IBMUSER.TEST29B                              *\n*                                                                     *\n* OPERATION = SEE BELOW                                               *\n*                                                                     *\n*            1. Retrieve the name of the utility program              *\n*               from the PARM field.                                  *\n*            2. Fix myself in memory                                  *\n*            3. Set up an SVC screening environment to intercept      *\n*               ENQ and DEQ SVC requests                              *\n*            4. Issue XCTL to pass control to the utility program     *\n*                                                                     *\n*         Note: Each time it is invoked, the SVC screening routine    *\n*               checks the first QNAME in the ENQ/DEQ parm list.      *\n*               If it is equal to SYSDSN, it changes it to SYSNOENQ.  *\n*                                                                     *\n*         Credits: The idea of using SVC screening to bypass          *\n*                  DSN ENQ was borrowed from the SYSIEH               *\n*                  utility (author unknown).                          *\n*                                                                     *\n* ABENDS = See below                                                  *\n*                                                                     *\n*            U1001  Invalid Parm                                      *\n*                                                                     *\n* CHANGE ACTIVITY                                                     *\n*                                                                     *\n*  $100 INITIAL RELEASE                                               *\n*  $101 Use ASMH and ISGPEL macro                                     *\n*  $102 Issue PGFIX before setting TCBSVCS                            *\n*  $203 OS/VS2 Version                                                *\n*                                                                     *\n***********************************************************************\nBYPASSNQ CSECT\n         DC    C'GSF UTILITIES - BYPASSNQ R203 '\nBEGIN    LR    R10,R15\n         USING BEGIN,R10\n         LR    R11,R1                  SAVE PARM ADDRESS\n         USING FSA,R13\n         MODESET MODE=SUP              SUPERVISOR MODE\n*\n*        Check that the user has update authority to SYS1.PARMLIB\n*\n*        Retrieve the name of the utility program from the parm\n*\n         L     R2,0(,R11)              addr of the PARM\n         LH    R3,0(,R2)               parm length\n         LTR   R3,R3                   parm missing?\n         BNP   ABEND1                  yes, abend\n         CH    R3,=H'8'                parm too long?\n         BH    ABEND1                  yes, abend\n         LA    R14,PGMNAME             \"to\" addr\n         LA    R15,L'PGMNAME           \"to\" length\n         LA    R2,2(,R2)               \"from\" address\n         ICM   R3,B'1000',=C' '        padding\n         MVCL  R14,R2                  move pgm name\n*\n*        Make sure I don't disappear\n*\n         PGFIX R,                      PREVENT S07C ABEND              X\n               A=SVCA2,                FROM                            X\n               EA=SVCARRAY+255,        TO                              X\n               LONG=Y,                                                 X\n               ECB=0\n         LOAD  EP=BYPASSNQ             bump my own use count for XCTL\n*\n*        Set up the SVC screening environment\n*\n         MODESET EXTKEY=ZERO\n         L     R4,X'21C'               A(TCB) from PSATOLD\n         USING TCB,R4\n         LA    R0,SVCA2                ADDR OF SVC SCREENING ROUTINE\n         ST    R0,TCBSVCA2\n         OI    TCBFLGS7,TCBSVCS        SVC SCREENING ON\n         MODESET KEY=NZERO,MODE=PROB\n*\n*        XCTL to utility program with PARM=''\n*\n         LR    R1,R11                  restore R1\n         L     R2,0(,R1)               addr of the PARM\n         MVI   1(R2),0                 zero parm length\n         XCTL  EPLOC=PGMNAME,SF=(E,XCTLL)\n*\nABEND1   ABEND 1001                    bad parm\n***********************************************************************\n*                                                                     *\n*        SVC SCREENING ARRAY                                          *\n*                                                                     *\n***********************************************************************\n         DC    0D'0'\n         EXTRN SCREEN\nSVCA2    DC    A(SCREEN+X'80000000')\n         DC    X'80,00',X'0000'        SVC TYPE, LOCKS\nSVCARRAY DC    256X'80'                SVC ARRAY\n         ORG   SVCARRAY+48\n         DC    X'00'                   DEQ\n         ORG   SVCARRAY+56\n         DC    X'00'                   ENQ\n         ORG\n***********************************************************************\n*        Work area (First Save Area)                                  *\n***********************************************************************\nFSA      DSECT\n         DS    3F                      first 3 words of FSA\nPGMNAME  DS    CL8                     name of utility program\nXCTLL    XCTL  EPLOC=PGMNAME,SF=L\n*\n         IKJTCB DSECT=YES\n         YREGS\n         END   BEGIN\n***********************************************************************\n*                                                                     *\n*        SVC SCREENING ROUTINE                                        *\n*                                                                     *\n*        This routine is invoked as a T3-SVC each time                *\n*        the ENQ or DEQ SVCs are issued.                              *\n*                                                                     *\n***********************************************************************\nSCREEN   RSECT\nSCREEN   RMODE ANY\n         USING CVTMAP,R3               CVT\n         USING TCB,R4                  TCB\n         USING RBBASIC,R5              SVRB\n         USING SCREEN,R6               Local Base\n**       USING ASCB,R7                 ASCB\n         LR    R9,R1                   point to ENQ/DEQ parm list\n         USING PELBASIC,R9\n*---------------------------------------------------------------------*\n*                                                                     *\n*        If the first QNAME in the ENQ/DEQ parm list is \"SYSDSN\",     *\n*        change it to \"SYSNOENQ\".                                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MODESET EXTKEY=RBT234,WORKREG=2 SWITCH TO CALLER'S KEY\n         L     R2,PELMAJA              ADDR OF THE QNAME\n         CLC   OLDQNAME,0(R2)          QNAME=SYSDSN?\n         BNE   SCREEN45                NO, IGNORE\n         LA    R2,NEWQNAME             NEW QNAME\n         ST    R2,PELMAJA              UPDATE ADDR OF THE QNAME\nSCREEN45 EQU   *\n*---------------------------------------------------------------------*\n*                                                                     *\n*        XCTL TO SVC ROUTINE                                          *\n*                                                                     *\n*              1. LOCATE SVC ENTRY IN SVC TABLE                       *\n*              2. RESTORE R15,R0,R1                                   *\n*              3. BRANCH TO SVC ROUTINE                               *\n*                                                                     *\n*---------------------------------------------------------------------*\n         L     R8,CVTABEND             SECONDARY CVT\n         USING SCVTSECT,R8\n         LA    R2,RBBASIC-RBINTCOD     offset to interrupt code\n         LNR   R2,R2                   make it negative\n         AL    R2,RBLINK               point at RBINTCOD in the PRB\n         LH    R9,0(,R2)               Interrupt code (SVC num: 48,56)\n         SLL   R9,3                    MULT BY 8\n         AL    R9,SCVTSVCT             ADD ORIGIN OF SVC TABLE\n         USING SVCENTRY,R9\n*\n         L     R6,SVCEP                GET EP ADDR OF SVC RTNE\n         DROP  R6                      MAIN BASE REG\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Exit to the ENQ/DEQ SVC Routine                              *\n*                                                                     *\n*---------------------------------------------------------------------*\n         MODESET EXTKEY=ZERO           switch back to key=zero\n         L     R14,CVTEXP1             ADDR OF EXIT PROLOGUE\n         L     R15,RBGRS15             Restore R15 from SVRB\n         LM    R0,R1,RBGRS0            Restore R0,R1 from SVRB\n         BSM   0,R6                    GO TO THE SVC ROUTINE\n*\nOLDQNAME DC    CL8'SYSDSN'             OLD QNAME\nNEWQNAME DC    CL8'SYSNOENQ'           NEW QNAME\n         PRINT NOGEN\nPRINT    OPSYN ANOP\n         CVT   DSECT=YES\n         IHASCVT DSECT=YES,LIST=NO     SECONDARY CVT\n         IHASVC                        SVC TABLE ENTRY\n         IKJTCB DSECT=YES\n         IKJRB DSECT=YES\n*MVS/SP  ISGPEL                        Parameter Element List\nPELBASIC DSECT\nPELLAST  DS    X                  FLAG BYTE 1\nPELMILEN DS    X                  RNAME LENGTH\nPELFLAG  DS    X                  FLAG BYTE 2\nPELRET   DS    X                  RETURN CODE AREA IN USER PEL\nPELMAJA  DS    A                  ADDRESS OF QNAME - NOT USED WHEN\nPELMINA  DS    A                  ADDRESS OF RNAME - NOT USED WHEN\n*        YREGS\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         END\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//         DD DSN=SYS1.AMODGEN,DISP=SHR\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,15)\n//SYSUT2   DD UNIT=VIO,SPACE=(CYL,15)\n//SYSUT3   DD UNIT=VIO,SPACE=(CYL,15)\n//SYSGO    DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3120\n//SYSPRINT DD SYSOUT=*\n//*\n//LKED    EXEC PGM=HEWLKED,PARM='MAP,RENT,AC=1'\n//SYSLIN   DD DSN=*.ASMXF.SYSGO,DISP=(OLD,DELETE)\n//SYSLMOD  DD DSN=SYS1.P390.LINKLIB(BYPASSNQ),DISP=SHR\n//SYSPRINT DD SYSOUT=*\n//*\n//CREATE EXEC PGM=IEHMOVE\n//SYSUT1 DD DISP=OLD,UNIT=SYSALLDA,VOL=SER=Z5RES1\n//DD1    DD DSN=GILBERT.X80,DISP=SHR\n//DD2    DD DISP=OLD,UNIT=SYSALLDA,VOL=SER=Z5RES1\n//SYSPRINT DD SYSOUT=*\n     COPY      DSNAME=GILBERT.X80,                                     X\n               TO=3390=Z5RES1,                                         X\n               RENAME=GILBERT.TEST29\n//*\n//GO      EXEC PGM=BYPASSNQ,PARM=IEHPROGM\n//STEPLIB  DD DSN=SYS1.P390.LINKLIB,DISP=SHR\n//SYSPRINT DD SYSOUT=*\n  RENAME DSNAME=IBMUSER.TEST29,VOL=3390=Z5RES1,NEWNAME=GILBERT.TEST29B\n SCRATCH DSNAME=IBMUSER.TEST29B,VOL=3390=Z5RES1\n//DD1      DD UNIT=3390,VOL=SER=Z5RES1,DISP=OLD\n//ABNLTERM DD SYSOUT=*\n//SYSUDUMP DD SYSOUT=*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CANMSGCL": {"ttr": 1033, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x88$/\\x01\\x06!\\x0f\\x12Y\\x00\\x86\\x00P\\x002\\xc3\\xc2\\xe3\\xf4\\xf7\\xf2@@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1988-08-29T00:00:00", "modifydate": "2006-07-29T12:59:00", "lines": 134, "newlines": 80, "modlines": 50, "user": "CBT472"}, "text": "//GILBERTC JOB (ACCT#),CANMSGCL,\n// NOTIFY=&SYSUID,\n// CLASS=A,MSGCLASS=X,COND=(0,NE)\n//ASMXF EXEC PGM=IFOX00,PARM=(OBJECT,NODECK,NOESD,NORLD,ALIGN,NOXREF)\n***********************************************************************\n*                                                                     *\n*              CANCEL JOB'S MSGCLASS AFTER NN HOURS                   *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n*        THIS PROGRAM ALLOWS YOU TO PURGE THE OUTPUT ASSOCIATED       *\n*        WITH THE MSGCLASS OF THE JOB AFTER A CERTAIN NUMBER OF       *\n*        HOURS THAT YOU SPECIFY IN THE PARM FIELD OF THE EXEC         *\n*        STATEMENT.                                                   *\n*                                                                     *\n*        EXAMPLE:                                                     *\n*                                                                     *\n*            //MYJOB    JOB ACCT#,CLASS=A,MSGCLASS=X                  *\n*            //COPY1   EXEC PGM=IEBCOPY                               *\n*            //...      DD   ...                                      *\n*            //CONDPURG EXEC PGM=CANMSGCL,PARM=2,COND=(0,NE,COPY1)    *\n*                                                                     *\n*        IF THE 'COPY1' STEP ENDS AT 10:28 AM WITH A RETURN CODE      *\n*        EQUAL TO ZERO, THE 'CONDPURG' STEP EXECUTES AND ISSUES       *\n*        THE FOLLOWING COMMAND:                                       *\n*                                                                     *\n*               $TA,T=12.28,'$OJ01234,Q=X,CANCEL'                     *\n*                                                                     *\n*        NOTES:                                                       *\n*                                                                     *\n*           1. THE PROGRAM MUST BE APF-AUTHORIZED.                    *\n*                                                                     *\n*           2. THE MSGCLASS MUST BE HELD.                             *\n*                                                                     *\n*           3. THE NUMBER OF OUTSTANDING AUTOMATIC COMMANDS IS        *\n*              LIMITED BY THE 'AUTOCMD' PARAMETER IN JES2PARM.        *\n*              IF EXCEEDED, THE COMMAND IS IGNORED.                   *\n*                                                                     *\n*           4. THE PROGRAM WORKS WITH 5-DIGIT JOB NUMBERS.            *\n*                                                                     *\n***********************************************************************\nCANMSGCL CSECT\n         SAVE  (14,12),,'GSF UTILITIES - CANMSGCL R107'\n         BALR  R12,0\n         USING *,R12\n         L     R2,0(,R1)               PARM ADDRESS\n         LH    R14,0(,R2)              PARM LENGTH\n         BCTR  R14,0\n         PACK  DELAY,2(*-*,R2)         PACK NUMBER OF HOURS\n         EX    R14,*-6                 EXECUTE PACK INSTRUCTION\n*\n*        GET JOB NUMBER FROM SSIB\n*\n         L     R4,540(,0)              PSATOLD\n         L     R5,TCBJSCB-TCB(,R4)     PTR TO JSCB\n         USING IEZJSCB,R5\n         L     R6,JSCBSSIB             PTR TO SSIB\n         USING SSIB,R6\n         MVC   JOBID+0(1),SSIBJBID+0   J\n         MVC   JOBID+1(5),SSIBJBID+3    01234\n         L     R8,JSCBJCT              PTR TO JCT\n         USING JCT,R8\n         MVC   MSGCLASS,JCTJMGPO       MSGCLASS\n         DROP  R5,R6,R8                JSCB, SSIB, JCT\n*\n*        GET CURRENT TIME, MOVE IT TO \"HHMM\" FIELD\n*\n         TIME  DEC                     HHMMSS00\n         SRL   R0,12(0)                000HHMM0\n         ST    R0,SYSTIME              000HHMM0\n         OI    SYSTIME+3,15            000HHMMF\n         UNPK  HHMM+3(2),SYSTIME+2(2)  MOVE MM\n         OI    SYSTIME+2,15            000HHF??\n         AP    SYSTIME+1(2),DELAY      ADD HOURS FROM PARM\n         OI    SYSTIME+2,15            000HHF??\n         UNPK  HHMM+0(2),SYSTIME+1(2)  MOVE HH\n         MVI   HHMM+2,C'.'             HH.MM\n         MODESET KEY=ZERO,MODE=SUP\n         SLR   R0,R0                   DUMMY CONSOLE ID\n         MGCR  MGCR1L                  ISSUE COMMAND\n         RETURN  (14,12),RC=00         GO BACK TO SYSTEM\n*\nMGCR1L   WTO   '$TA,T=HH.MM,''$OJ01234,Q=$,CANCEL''',MF=L\nHHMM     EQU   MGCR1L+10               HH.MM\nJOBID    EQU   MGCR1L+19,6             JOB ID\nMSGCLASS EQU   MGCR1L+28,1             MESSAGE CLASS\nDELAY    DS    P'24'                   NUMBER OF HOURS, FROM PARM\nSYSTIME  DS    F                       CURRENT SYSTEM TIME\n*\n         IKJTCB LIST=NO                TCB DSECT\n*\n         IEZJSCB                       JSCB DSECT\n*\nJCT      DSECT\n         DS    4F                      JCT PREFIX\n         IEFAJCTB                      JCT DSECT\n*\n         IEFJSSIB                      SSIB DSECT\n*\n*        YREGS\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         END\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,15)\n//SYSUT2   DD UNIT=VIO,SPACE=(CYL,15)\n//SYSUT3   DD UNIT=VIO,SPACE=(CYL,15)\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//         DD DSN=SYS1.AMODGEN,DISP=SHR\n//SYSGO    DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3120\n//SYSPRINT DD SYSOUT=*\n//*\n//LKED    EXEC PGM=HEWL,PARM='MAP,REUS,AC=1'\n//SYSLIN   DD DSN=*.ASMXF.SYSGO,DISP=(OLD,DELETE)\n//SYSPRINT DD SYSOUT=*\n//SYSLMOD  DD DSN=SYS2.AUTHLIB(CANMSGCL),DISP=SHR\n//*\n//GO      EXEC PGM=CANMSGCL,PARM=2\n//STEPLIB  DD DSN=SYS2.AUTHLIB,DISP=SHR\n//SYSUDUMP DD SYSOUT=*\n//ABNLNODP DD DUMMY\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CLEANUP": {"ttr": 1036, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04\\x06\\x00\\x00\\x00\\x81\\x03\\x7f\\x01\\x06!\\x0f\\x13\\x13\\x01\\xa3\\x00\\xdf\\x00\\x93\\xc3\\xc2\\xe3\\xf4\\xf7\\xf2@@@@'", "ispf": {"version": "04.06", "flags": 0, "createdate": "1981-02-06T00:00:00", "modifydate": "2006-07-29T13:13:00", "lines": 419, "newlines": 223, "modlines": 147, "user": "CBT472"}, "text": "//GILBERTC JOB (ACCT#),CLEANUP,\n//*RESTART=HMIG,\n// NOTIFY=&SYSUID,\n// CLASS=A,MSGCLASS=X,COND=(1,LT)\n//ASMXF EXEC PGM=IFOX00,PARM=(OBJECT,NODECK,NOESD,NORLD,ALIGN,NOXREF)\n***********************************************************************\n*                                                                     *\n* MODULE NAME = CLEANUP                                               *\n*                                                                     *\n* DESCRIPTIVE NAME = Data Set Clean-up Utility (OS/VS2)               *\n*                                                                     *\n* FUNCTION = The \"CLEANUP\" program deletes existing data sets         *\n*            created and/or used in your job.  It has three modes     *\n*            of operation:  Job restart, Job Clean-up, Never-open.    *\n*                                                                     *\n* STATUS = R506                                                       *\n*                                                                     *\n* AUTHOR = Gilbert Saint-Flour <carlos@gsf-soft.com>                  *\n*                                                                     *\n* NOTES = SEE BELOW                                                   *\n*                                                                     *\n*    DEPENDENCIES = OS/VS2                                            *\n*                                                                     *\n*    AUTHORIZATION = NONE                                             *\n*                                                                     *\n*    RESTRICTIONS = NONE                                              *\n*                                                                     *\n* MODULE TYPE = PROCEDURE, (BATCH PROGRAM)                            *\n*                                                                     *\n*    PROCESSOR = IBM ASSEMBLER XF                                     *\n*                                                                     *\n*    MODULE SIZE = 4K                                                 *\n*                                                                     *\n*    ATTRIBUTES = REUSABLE, PROBLEM STATE, KEY 8                      *\n*                                                                     *\n* OPERATION = See Below                                               *\n*                                                                     *\n*        1. Job restart                                               *\n*                                                                     *\n*            When executed at the beginning of the job you're         *\n*            re-starting or re-running, CLEANUP deletes non-gdg       *\n*            data sets that were created by a previous run of the     *\n*            same job.  This prevents Job failures that would         *\n*            result from \"NOT CATLG 2\" and IGD17001I messages.        *\n*                                                                     *\n*            Sample JCL :                                             *\n*                                                                     *\n*              //MYJOB   JOB (ACCT#),'JOHN DOE', . . .                *\n*              //*                                                    *\n*              //CLEANUP EXEC PGM=CLEANUP                             *\n*              //*                                                    *\n*              //STEP1   EXEC PROC=MYPROC, . . .                      *\n*                                                                     *\n*            Notes:                                                   *\n*                                                                     *\n*              o  no DD statements, control cards or PARM are         *\n*                 necessary.  CLEANUP automatically retrieves data    *\n*                 set names from in-storage images of the job's JCL.  *\n*                                                                     *\n*              o  CLEANUP may be executed more than once in a job.    *\n*                 Each execution will consider data sets created      *\n*                 in subsequent steps.                                *\n*                                                                     *\n*              o  If PARM=RECALL is specified, CLEANUP invokes        *\n*                 the RECALL utility after it has completed its       *\n*                 clean-up work.                                      *\n*                                                                     *\n*        2. Job clean-up                                              *\n*                                                                     *\n*            When executed as the very last step of a job,            *\n*            CLEANUP deletes non-gdg data sets that were created      *\n*            during the job's execution.                              *\n*                                                                     *\n*            Sample JCL :                                             *\n*                                                                     *\n*              //MYJOB   JOB (ACCT#),'JOHN DOE', . . .                *\n*              //*                                                    *\n*              //STEP1   EXEC PROC=MYPROC, . . .                      *\n*              //*                                                    *\n*              //CLEANUP EXEC PGM=CLEANUP                             *\n*              //                                                     *\n*                                                                     *\n*        3. Never-OPEN                                                *\n*                                                                     *\n*            When executed with PARM=NEVEROPEN, CLEANUP deletes       *\n*            data sets that have been allocated but have not been     *\n*            opened for output by any program.  DD statements must    *\n*            be explicitely specified in CLEANUP's step for the       *\n*            data sets to delete.                                     *\n*                                                                     *\n*            Sample JCL :                                             *\n*                                                                     *\n*              //MYJOB   JOB (ACCT#),'JOHN DOE', . . .                *\n*              //*                                                    *\n*              //STEP1   EXEC PGM=MYPROG1, . . .                      *\n*              //OUTDD    DD  DSN=SELDOM.OPEN1(+1),DISP=(,CATLG)      *\n*              //*                                                    *\n*              //STEP2   EXEC PGM=MYPROG2, . . .                      *\n*              //OUTDD    DD  DSN=SELDOM.OPEN2,DISP=(,CATLG)          *\n*              //*                                                    *\n*              //CLEANUP EXEC PGM=CLEANUP,PARM=NEVEROPEN              *\n*              //DD1      DD  DSN=SELDOM.OPEN1(+1),DISP=OLD           *\n*              //DD2      DD  DSN=SELDOM.OPEN2,DISP=OLD               *\n*                                                                     *\n* Method of Operation (functions 1 & 2)                               *\n*                                                                     *\n*         o  CLEANUP scans the SWA control blocks of every step       *\n*            of your job for non-GDG data sets that will be           *\n*            (function 1) or have been (function 2) created           *\n*            with DISP=(NEW,CATLG) or DISP=(MOD,CATLG).               *\n*                                                                     *\n*         o  Any of these data sets currently catalogued are          *\n*            dynamically allocated and deleted.                       *\n*                                                                     *\n* PARAMETERS = PARM=NEVEROPEN indicates that CLEANUP should only      *\n*              delete those data sets that are allocated in its own   *\n*              step and have a null BLKSIZE (i.e. have never been     *\n*              OPEN'd for output).                                    *\n*                                                                     *\n* Return codes = See below                                            *\n*                                                                     *\n*            00     Normal end                                        *\n*            16     Parm is invalid                                   *\n*                                                                     *\n* Messages = See below                                                *\n*                                                                     *\n*            PARM FIELD IS INVALID, when the PARM specifies           *\n*              something other than NEVEROPEN.                        *\n*                                                                     *\n*            CLEANUP - data-set-name DELETED (volser)                 *\n*              for each data set deleted                              *\n*                                                                     *\n*            CLEANUP - data-set-name DELETED (MIGRAT)                 *\n*              for each migrated data set deleted with HDELETE        *\n*                                                                     *\n* Change Activity                                                     *\n*                                                                     *\n*04.02   XCTL to PGM=RECALL at EOJ if PARM=RECALL                     *\n*04.03   IGNORE DISP=(MOD,DELETE) DATA SETS WITH PARM=NEVEROPEN       *\n*04.04   Increase message length to 80 characters.                    *\n*04.05   Pass PARM='' to RECALL program                               *\n*05.06   OS/VS2                                                       *\n***********************************************************************\n         LCLC  &STR\nCLEANUP  CSECT\n         SAVE  (14,12),,'GSF Utilities - CLEANUP R506'\n         LR    R12,R15\n         USING CLEANUP,R12\n         GETMAIN R,LV=DYNAML\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LM    R13,R1,8(R13)\n         USING DYNAM,R13\n         L     R9,0(,R1)               SAVE THE PARM ADDR\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Set up SWA scan from first step after our own.               *\n*                                                                     *\n*        If we're the last step of the job, set up scan               *\n*        from beginning of job.                                       *\n*                                                                     *\n*---------------------------------------------------------------------*\nINIT50   L     R3,540(,0)              MY TCB (PSATOLD-PSA)\n         L     R4,TCBJSCB-TCB(,R3)     MY JSCB\n         USING IEZJSCB,R4\n         L     R5,JSCSCT               CURRENT STEP'S SCT PREFIX\n         USING SCT,R5\n         MVI   MODE,C'F'               processing mode is \"FIRST\"\n         ICM   R1,B'0111',SCTANSCT     last step of this job?\n         BNZ   INIT59                  no, jump\n         L     R1,JSCBJCT              yes, point to JCT\n         ICM   R5,B'0111',JCTSDKAD-JCT(R1) SCT of first step to be run\n         MVI   MODE,C'L'               processing mode is \"LAST\"\n*\nINIT59   SLR   R10,R10                 SET RC=00 (NOTHING DELETED)\n*---------------------------------------------------------------------*\n*                                                                     *\n*        FIND RESTART STEP, IF SPECIFIED IN THE PARM                  *\n*                                                                     *\n*---------------------------------------------------------------------*\nINIT60   LTR   R9,R9                   PARM FROM JCL OR CPPL\n         BNM   LOOPSCT                 no parm or TMP-INVOKED\n         CLI   1(R9),0                 PARM=\"\"\n         BE    LOOPSCT                 yes, jump\nINIT64   CLI   1(R9),9                 PARM=NEVEROPEN?\n         BNE   BADPARM                 no, parm is invalid\n         CLC   =C'NEVEROPEN',2(R9)     PARM=NEVEROPEN?\n         BNE   BADPARM                 no, parm is invalid\n         MVI   MODE,C'O'               processing mode is \"OPEN\"\n         L     R5,JSCSCT               CURRENT STEP'S SCT PREFIX\n         B     LOOPSCT\n*\nBADPARM  WTO   'CLEANUP - Parm Field is invalid',ROUTCDE=(2,11)\n         LA    R10,16                  RC=16\n         B     GOBACK\n***********************************************************************\n*                                                                     *\n*        SCAN SCT/SIOT CHAINS                                         *\n*                                                                     *\n*           1. SELECT NON-GDG DATA SETS THAT HAVE DISP=(NEW,CATLG)    *\n*              OR DISP=(MOD,CATLG)                                    *\n*                                                                     *\n*           2. ALLOCATE SELECTED DATA SETS WITH DISP=(OLD,DELETE)     *\n*                                                                     *\n*           3. UNALLOCATE DATA SETS THAT WERE SUCCESSFULLY ALLOCATED  *\n*              TO DELETE THEM                                         *\n*                                                                     *\n***********************************************************************\n*LOOP\nLOOPSCT  ICM   R1,B'0111',SCTFSIOT     SVA OF 1ST SIOT\n         BZ    NEXTSTEP                NO DD STATEMENTS, TRY NEXT SCT\n*--LOOP\nLOOPSIOT LA    R6,16(,R1)              PASS SIOT ADDRESS\n         USING INDMSIOT,R6\n         ICM   R1,B'0111',SCTPJFCB     SVA OF JFCB\n         LA    R7,16(,R1)              LOAD JFCB ADDRESS\n         USING INFMJFCB,R7\n*\n*        Set-up message\n*\nSETUPMSG MVC   DSNAME,JFCBDSNM         MOVE DSN TO UNPROTECTED STORAGE\n         MVC   WTO1TEXT,WTO1TEXT-1     clear work area\n         MVC   WTO1TEXT(L'DSNAME),DSNAME  move dsname\n         LA    R2,WTO1TEXT             start of dsname\n         LA    R2,1(,R2)             - BUMP POINTER\n         CLI   0(R2),C' '            - END OF MSG?\n         BNE   *-8                   - NOT YET, TRY NEXT CHARACTER\n         MVC   1(7,R2),=C'deleted'     action taken\n         CLI   MODE,C'O'               PARM=NEVEROPEN?\n         BE    NOOPEN                  yes, bypass filters\n*\n*        Filter data sets: DSN=A.B.C(+1),DISP=(,CATLG)\n*\nFILTER   TM    SCTSDISP,SIOTCTLG       DISP=(,CATLG) ?\n         BNO   NEXTSIOT                NO, JUMP\n         TM    SCTSBYT3,SCTSNEW+SCTSMOD   DISP=NEW/MOD ?\n         BZ    NEXTSIOT                NO, JUMP\n         TM    JFCBIND1,JFCGDG         CHECK FOR (+1)\n         BO    NEXTSIOT                JUMP, THIS IS A GDG\n         CLI   MODE,C'L'               MODE=LAST?\n         BE    ALLOC                   yes, bypass catalog search\n*\n*        Look-up data set name in the catalog\n*\nLOCATE   LM    R14,R1,CAMLST26         MODEL CAMLST\n         SLR   R0,R0                   no CVOL ptr\n         LA    R1,WORK265              WORK AREA\n         STM   R14,R1,CAMLST2          UPDATE CAMLST IN DYNAMIC STRGE\n         LOCATE CAMLST2                GET VOLSER\n         LTR   R15,R15                 IS IT CATALOGED?\n         BNZ   NEXTSIOT                NO, IGNORE\n         MVI   09(R2),C'('             surround volser with parentheses\n         MVC   10(6,R2),WORK265+6      yes, move volser\n         MVI   16(R2),C')'             surround volser with parentheses\n         B     ALLOC\n*\n*        PARM=NEVEROPEN\n*\nNOOPEN   TM    SCTSDISP,SIOTDLET       DISP=(,DELETE)?\n         BO    NEXTSIOT                YES, JUMP\n         LM    R14,R1,CAMLST28         MODEL CAMLST\n         LA    R0,JFCBVOLS             volser\n         LA    R1,DS1FMTID             WORK AREA\n         STM   R14,R1,CAMLST2          UPDATE CAMLST IN DYNAMIC STRGE\n         OBTAIN CAMLST2                GET F1-DSCB\n         LTR   R15,R15                 found on disk?\n         BNZ   NEXTSIOT                NO, IGNORE\n         OC    DS1BLKL,DS1BLKL         BLKSIZE=0?\n         BNZ   NEXTSIOT                NO, IGNORE\n         MVC   09(12,R2),=C'(Never OPEN)'\n*\n*        ALLOCATE\n*\nALLOC    MVI   S99RB+1,1               FUNCTION=ALLOC\n         NI    S99TUPTR,255-X'80'      USE ALL OF THE KEYS\n         LA    1,=A(S99RB+VL)          SVC99 REQUEST BLOCK\n         SVC   99                      ALLOCATE THE DATA SET\n         LTR   R15,R15                 ALLOC OK?\n         BNZ   NEXTSIOT                NO, JUMP\n*\n*        UNALLOCATE\n*\n         MVI   S99RB+1,2               FUNCTION=UNALLOC\n         OI    S99TUPTR,X'80'          KEEP ONLY THE DDNAME KEY\n         LA    1,=A(S99RB+VL)          SVC99 REQUEST BLOCK\n         SVC   99                      ALLOCATE THE DATA SET\n*\n&STR     SETC  (80)' '\nWTO1     WTO   'CLEANUP - &STR',ROUTCDE=11\nWTO1TEXT EQU   WTO1+18,80\n*\nNEXTSIOT ICM   R1,B'0111',SCTPSIOT     NEXT SIOT'S PREFIX\n         BNZ   LOOPSIOT                PROCESS NEXT DD CARD IN STEP\n*--ENDLOOP\nNEXTSTEP CLI   MODE,C'O'               PARM=NEVEROPEN?\n         BE    GOBACK                  yes, we're done\n         ICM   R5,B'0111',SCTANSCT     NEXT SCT PREFIX\n         BNZ   LOOPSCT                 PROCESS NEXT STEP\n*ENDLOOP\n         DROP  R5,R6,R7                SCT, SIOT, JFCB\n*\nGOBACK   EQU   *\n         L     R13,4(,R13)             CALLER'S SAVE AREA\n         LR    R15,R10                 RETURN CODE\n         RETURN (14,12),RC=(15)\n*---------------------------------------------------------------------*\n*                                                                     *\n*        DATA, WORK AREAS                                             *\n*                                                                     *\n*---------------------------------------------------------------------*\nVL       EQU   X'80000000'\nS99RB    DC    A(X'14010000',0,S99TUPTR,0,0)\nS99TUPTR DC    A(S99TU01,S99TU02,S99TU04,S99TU05,S99TU6C+VL)\nS99TU01  DC    AL2(X'01',1,L'DDNAME)   DDNAME KEY\nDDNAME   DC    C'$CLEANUP'\nS99TU02  DC    AL2(X'02',1,L'DSNAME)   DSNAME KEY\nDSNAME   DS    CL44\nS99TU04  DC    AL2(X'04',1,1),X'01'    STATUS=OLD\nS99TU05  DC    AL2(X'05',1,1),X'04'    DISP=DELETE\nS99TU6C  DC    AL2(X'6C',0)            UNIT=(,,DEFER)\nCAMLST26 CAMLST NAME,DSNAME,,*-*       CAMLST FOR LOCATE MACRO\nCAMLST28 CAMLST SEARCH,DSNAME,*-*,*-*  CAMLST FOR OBTAIN MACRO\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Dynamic storage                                              *\n*                                                                     *\n*---------------------------------------------------------------------*\nDYNAM    DSECT\n         DS    18F\nMODE     DS    C'F'                    FIRST/LAST/OPEN\nCAMLST2  CAMLST NAME,DSNAME,,WORK265   CAMLST FOR LOCATE MACRO\nWORK265  DS    CL265                   LOCATE macro\n         IECSDSL1 1                    F1-DSCB\n         DS    5X                      CCHHR\nDYNAML   EQU   *-DYNAM\n*---------------------------------------------------------------------*\n*                                                                     *\n*        DSECTS FOR VARIOUS MVS CONTROL BLOCKS                        *\n*                                                                     *\n*---------------------------------------------------------------------*\n         PRINT NOGEN\n         IKJTCB LIST=NO                SYS1.AMODGEN\n         IEZJSCB ,                     SYS1.AMODGEN\nJCT      DSECT                         Job Control Table\n         DS    4F                      Prefix\n         IEFAJCTB ,                    SYS1.AMODGEN\nSCT      DSECT                         Step Control Table\n         DS    4F                      Prefix\n         IEFASCTB ,                    SYS1.AMODGEN\nSIOT     DSECT                         Step I/O Table\nSIOTDLET EQU   4                       BIT 5 - DELETE DATA SET\nSIOTCTLG EQU   2                       BIT 6 - CATALOG THE DATA\nSCTSNEW  EQU   4                       BIT 5 - NEW DATA SET\nSCTSMOD  EQU   2                       BIT 6 - MODIFIED DATA SET\nSCTSOLD  EQU   1                       BIT 7 - OLD DATA SET\n         DS    4F                      Prefix\n         IEFASIOT ,                    SYS1.AMODGEN\nJFCB     DSECT                         Job File Control Block\n         DS    4F                      Prefix\n         IEFJFCBN ,                    SYS1.AMODGEN\n         CVT   LIST=NO,DSECT=YES       COMMUNICATION VECTOR TABLE\n**       IEFJESCT TYPE=DSECT           JES CONTROL TABLE\n*        YREGS                         SYS1.MACLIB\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         END\n//SYSLIB   DD DSN=SYS1.AMODGEN,DISP=SHR\n//         DD DSN=SYS1.MACLIB,DISP=SHR\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,15)\n//SYSUT2   DD UNIT=VIO,SPACE=(CYL,15)\n//SYSUT3   DD UNIT=VIO,SPACE=(CYL,15)\n//SYSGO    DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3120\n//SYSPRINT DD SYSOUT=*\n//\n//*\n//LKED    EXEC PGM=IEWL,PARM=(MAP,REUS)\n//SYSLIN   DD DSN=*.ASMXF.SYSGO,DISP=(OLD,DELETE)\n//SYSLMOD  DD DSN=GSFSOFT.PRISM-CS.LOAD(CLEANUP),DISP=SHR\n//SYSPRINT DD SYSOUT=*\n//*\n//NEVROPEN EXEC PGM=CLEANUP,PARM=NEVEROPEN\n//STEPLIB  DD DSN=GSFSOFT.PRISM-CS.LOAD(CLEANUP),DISP=SHR\n//NODSORG  DD DSN=GILBERT.CLEANUP2,DISP=(,CATLG),\n// UNIT=VIO,SPACE=(TRK,1)\n//*SORGPS  DD DSN=GILBERT.CLEANUP,DISP=(,CATLG),\n//*UNIT=VIO,SPACE=(TRK,1),DSORG=PS\n//SYSDEBUG DD SYSOUT=*\n//SYSUDUMP DD SYSOUT=*\n//*\n//GO      EXEC PGM=CLEANUP\n//STEPLIB  DD DSN=GSFSOFT.PRISM-CS.LOAD(CLEANUP),DISP=SHR\n//SYSDEBUG DD SYSOUT=*\n//SYSUDUMP DD SYSOUT=*\n//*\n//STEP1   EXEC PGM=IEFBR14\n//TAPEOUT  DD DSN=GILBERT.CLEANUP,DISP=(,CATLG),\n// UNIT=VIO,SPACE=(TRK,1)\n//*TEP2   EXEC PGM=IEFBR14\n//*APEOUT  DD DSN=GILBERT.CLEANUP,DISP=(OLD,DELETE)\n//*\n//HMIG    EXEC PGM=IKJEFT01\n//SYSTSPRT DD SYSOUT=*\n//SYSTSIN  DD *\nHMIG 'IBMUSER.CLEANUP' WAIT\n//*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CLS": {"ttr": 1286, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x03\\x00\\x00\\x00\\x00\\x90\\x07\\x9f\\x01\\x06!\\x0f\\x11\\t\\x00\\x1b\\x00\\x03\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf7\\xf2@@@@'", "ispf": {"version": "03.00", "flags": 0, "createdate": "1990-03-20T00:00:00", "modifydate": "2006-07-29T11:09:00", "lines": 27, "newlines": 3, "modlines": 0, "user": "CBT472"}, "text": "//GILBERTK JOB (ACCT#),CLS,\n// NOTOFY=GILBERT,\n// CLASS=A,MSGCLASS=X,COND=(0,NE)\n//ASMXF EXEC PGM=IFOX00,PARM=(OBJECT,NODECK,NOESD,NORLD,ALIGN,NOXREF)\n*---------------------------------------------------------------------*\n*        TSO \"CLEAR SCREEN\" COMMAND - OS/VS2                          *\n*---------------------------------------------------------------------*\nCLEARSCR CSECT\n         STFSMODE ON,INITIAL=YES       CLEAR SCREEN\n         BALR  15,0\n         USING *,15\n         STIMER WAIT,BINTVL=AWHILE     WAIT FOR A WHILE\n         STFSMODE OFF                  CLEAR SCREEN\n         BR    14                      GOBACK\nAWHILE   DC    FL4'25'                 25/100 OF A SECOND\n         END\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,15)\n//SYSUT2   DD UNIT=VIO,SPACE=(CYL,15)\n//SYSUT3   DD UNIT=VIO,SPACE=(CYL,15)\n//SYSGO    DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3120\n//SYSPRINT DD SYSOUT=*\n//*\n//LKED    EXEC PGM=HEWL,PARM=(MAP,RENT)\n//SYSLIN   DD DSN=*.ASMXF.SYSGO,DISP=(OLD,DELETE)\n//SYSLMOD  DD DSN=GSFSOFT.PRISM-CS.LOAD(CLS),DISP=SHR\n//SYSPRINT DD SYSOUT=*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CMDJ": {"ttr": 1288, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x81\\x01o\\x01\\x06!\\x0f\\x13\\x18\\x00K\\x00\"\\x00\\x1b\\xc3\\xc2\\xe3\\xf4\\xf7\\xf2@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1981-01-16T00:00:00", "modifydate": "2006-07-29T13:18:00", "lines": 75, "newlines": 34, "modlines": 27, "user": "CBT472"}, "text": "//GILBERTC JOB (ACCT#),CMDJ,\n// NOTIFY=&SYSUID,\n// CLASS=A,MSGCLASS=X,COND=(0,NE)\n//ASMXF EXEC PGM=IFOX00,PARM=(OBJECT,NODECK,NOESD,NORLD,ALIGN,NOXREF)\n***********************************************************************\n*                                                                     *\n*        SEND A JES2 COMMAND FOR CURRENT JOB                          *\n*                                                                     *\n*        EXAMPLE:                                                     *\n*                                                                     *\n*           //PURGE   EXEC PGM=CMDJES2,PARM=P       PURGE THE JOB     *\n*                                                                     *\n*           SENDS A $PJ#### COMMAND TO JES2, WHERE #### IS THE        *\n*           JOB'S OWN JOB NUMBER.                                     *\n*                                                                     *\n***********************************************************************\nCMDJES2  CSECT\n         SAVE  (14,12),,'GSF UTILITIES - CMDJ R101'\n         LR    R12,R15\n         USING CMDJES2,R12\n         L     R10,0(,R1)           PARM ADDRESS\n         LH    R14,0(,R10)          PARM LENGTH\n         CH    R14,=Y(L'CMD1CMD)    TOO LONG?\n         BH    RC12                 YES, QUIT\n         BCTR  R14,0\n         EX    R14,*+4\n         MVC   CMD1CMD(*-*),2(R10)  MOVE COMMAND\n         L     R3,X'21C'            PSATOLD (CURRENT TCB)\n         L     R4,X'0B4'(,R3)       JSCB\n         L     R5,X'13C'(,R4)       SSIB\n         MVC   CMD1JOBI,X'00C'(R5)  SSIBJBID=JOB01234\n         MVI   CMD1JOBI+1,C' '      O\n         MVI   CMD1JOBI+2,C' '      B\n         MODESET KEY=ZERO,MODE=SUP\n         SLR   R0,R0\n         MGCR  CMD1              <- ISSUE $P CMD\n         MODESET KEY=NZERO,MODE=PROB\n         STIMER WAIT,BINTVL==A(500) WAIT 5 SECONDS\n         RETURN (14,12),RC=0\nRC12     RETURN (14,12),RC=12       PARM IS TOO LONG\nCMD1     WTO   '$                                     ',MF=L\nCMD1CMD  EQU   CMD1+5,24   P\nCMD1JOBI EQU   CMD1+6,8    JOB03210\n*        YREGS\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         END\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,15)\n//SYSUT2   DD UNIT=VIO,SPACE=(CYL,15)\n//SYSUT3   DD UNIT=VIO,SPACE=(CYL,15)\n//SYSGO    DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3120\n//SYSPRINT DD SYSOUT=*\n//*\n//LKED    EXEC PGM=IEWL,PARM='MAP,AC=1'\n//SYSLIN   DD DSN=*.ASMXF.SYSGO,DISP=(OLD,DELETE)\n//SYSPRINT DD SYSOUT=*\n//SYSLMOD  DD DSN=SYS1.P390.LINKLIB(CMDJES2),DISP=SHR\n//*\n//GO      EXEC PGM=CMDJES2,PARM=P                     PURGE THE JOB\n//STEPLIB  DD DSN=SYS1.P390.LINKLIB,DISP=SHR\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DEFGDGSR": {"ttr": 1291, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x00\\x00\\x00\\x00\\x87)\\x0f\\x01\\x06!\\x0f\\x13&\\x01\\x07\\x00!\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf7\\xf2@@@@'", "ispf": {"version": "02.00", "flags": 0, "createdate": "1987-10-17T00:00:00", "modifydate": "2006-07-29T13:26:00", "lines": 263, "newlines": 33, "modlines": 0, "user": "CBT472"}, "text": "//GILBERTD JOB (ACCT#),DEFGDGSR,                                 OS/VS2\n// NOTIFY=GILBERT,\n// CLASS=A,MSGCLASS=X,COND=(0,NE)\n//ASMXF EXEC PGM=IFOX00,PARM=(OBJECT,NODECK,NOESD,NORLD,ALIGN,NOXREF)\n***********************************************************************\n*                                                                     *\n*        DEFINE GDG                 GSF - OCTOBER 1987                *\n*                                                                     *\n*        THIS SUBROUTINE MAY BE CALLED BY THE CZXG0DFP PDB EXIT       *\n*        TO DEFINE THE GDGS.  IT REQUIRES TWO PARAMETERS:             *\n*                                                                     *\n*        1. A 44-BYTE FIELD, CONTAINING THE DSNAME WHICH MUST BE      *\n*           LEFT-JUSTIFIED AND PADDED WITH BLANKS.                    *\n*                                                                     *\n*        2. A 3-DIGIT FIELD, CONTAINING THE NUMBER OF GENERATIONS     *\n*           AS AN UNPACKED DECIMAL NUMBER IN THE RANGE 001 TO 255.    *\n*                                                                     *\n*        SAMPLE CALLING SEQUENCE:                                     *\n*                                                                     *\n*            CALL 'DEFGDG' USING XF-EDMDSNAM, XF-EDMGDGNB.            *\n*                                                                     *\n*        A RETURN CODE IS PASSED IN REGISTER 15.  A COBOL CALLING     *\n*        PROGRAM MAY CHECK THE CONTENT OF THE \"RETURN-CODE\" FIELD,    *\n*        A NON-ZERO VALUE INDICATING THAT AN ERROR HAS OCCURED.       *\n*                                                                     *\n*                                                                     *\n*        THIS SUB-ROUTINE DOESN'T CALL IDCAMS, BUT DIRECTLY           *\n*        INVOKES THE MVS CATALOG MANAGEMENT SERVICES TO PERFORM       *\n*        THE FOLLOWING:                                               *\n*                                                                     *\n*        1. LISTCAT THE ENTRY TO CHECK IF THE GDG ALREADY EXISTS      *\n*           AND, IF THIS IS THE CASE, WHAT THE CURRENT LIMIT IS.      *\n*           THIS REQUEST IS EQUIVALENT TO THE IDCAMS COMMAND:         *\n*              'LISTCAT MYDSN GDG ALL '.                              *\n*                                                                     *\n*        2. DELETE THE EXISTING GDG BASE IF THE LIMIT IS DIFFERENT    *\n*           FROM THE PASSED GDGNB.  IF THE GDG BASE IS NOT EMPTY,     *\n*           DELETE WILL FAIL AND DEFINE WILL NOT BE ATTEMPTED.        *\n*           THIS REQUEST IS EQUIVALENT TO THE IDCAMS COMMAND:         *\n*              'DELETE MYDSN GDG '.                                   *\n*                                                                     *\n*        3. DEFINE THE GDG WITH THE SCRATCH OPTION AND THE NUMBER     *\n*           OF GENERATIONS PASSED IN THE SECOND PARAMETER.            *\n*           THIS REQUEST IS EQUIVALENT TO THE IDCAMS COMMAND:         *\n*              'DEFINE GDG(NAME(MYDSN) LIMIT(GDGNB) SCRATCH)'.        *\n*                                                                     *\n*        NOTES:                                                       *\n*                                                                     *\n*        THE PROGRAM IS REUSABLE, WHICH MEANS THAT IT MAY BE LOADED   *\n*        ONCE AND CALLED SEVERAL TIMES, AS DURING A TSO SESSION,      *\n*        A JOBSET COMPILATION OR A FILE MASS-COMPILATION.             *\n*                                                                     *\n*        THE PROGRAM DOESN'T DEFINE A GDG IN THE FOLLOWING CASES:     *\n*                                                                     *\n*        1. A '//NODEFGDG DD DUMMY' STATEMENT IS PRESENT IN THE JCL   *\n*           OR THE EQUIVALENT \"ALLOCATE\" COMMAND HAS BEEN ISSUED      *\n*           UNDER TSO.                                                *\n*                                                                     *\n*        2. THE FIRST LEVEL QUALIFIER OF THE DSNAME HAS NOT BEEN      *\n*           DEFINED AS AN ALIAS.                                      *\n*                                                                     *\n*        3. THE SECOND PARAMETER IS ZERO.  IN THAT CASE, IF A GDG     *\n*           BASE EXISTS FOR THAT ENTRY AND IS EMPTY, IT IS DELETED.   *\n*                                                                     *\n*$200 SET GDG BASE'S OWNER TO INVOKER'S RACF USER ID                  *\n***********************************************************************\nDEFGDG   CSECT\n         SAVE  (14,12),,'GSF UTILITIES - DEFGDGSR R200'\n         LR    R12,R15\n         USING DEFGDG,R12\n         LM    R3,R4,0(R1)             GDGNAME, GDGLIMIT\n*LA R3,=CL44'GILBERT.GDG' ###TEST###\n*LA R4,=C'032'            ###TEST###\n         GETMAIN RU,LV=DYNL            GET DYNAMIC STORAGE AREA\n         LR    R9,R1                   KEEP ITS ADDRESS\n         USING DYN,R9\n         DEVTYPE =C'NODEFGDG',WORK265  CHECK DDNAME\n         LTR   R15,R15                 CHECK DEVTYPE RETURN CODE\n         BZ    RETURN                  DD PRESENT, QUIT.\n         LA    R14,DYN                 CLEAR DYNAMIC STORAGE\n         LA    R15,DYNL                CLEAR DYNAMIC STORAGE\n         SLR   R1,R1                   CLEAR DYNAMIC STORAGE\n         MVCL  R14,R0                  CLEAR DYNAMIC STORAGE\n*---------------------------------------------------------------------\n*        CHECK FOR AN EXISTING ALIAS\n*---------------------------------------------------------------------\nP1ALIAS  MVI   WORK265+C'.',C'.'       BUILD TABLE FOR TRT\n         TRT   0(9,R3),WORK265         FIND FIRST PERIOD\n         BZ    RETURN                  ERROR IF NO PERIOD FOUND\n         LR    R0,R3                   POINT TO GDG NAME\n         SLR   R1,R0                   COMPUTE LENGTH OF 1ST QUALIFIER\n         ICM   R1,B'1000',=C' '        PADDING CHARACTER\n         LA    R14,CATNAME             \"TO\" FIELD\n         ST    R14,LOCALIAS+4          UPDATE CAMLST\n         ST    R14,CTGCAT              UPDATE CTGPL\n         LA    R15,L'CATNAME           LENGTH\n         MVCL  R14,R0                  MOVE ALIAS TO CATNAME FIELD\n         LA    R0,WORK265              GET ADDRESS OF WORK AREA\n         ST    R0,LOCALIAS+12          UPDATE CAMLST\n         ST    R0,CTGWKA               UPDATE CTGPL\n         LOCATE LOCALIAS               FIND UCAT NAME\n         LTR   R15,R15                 CHECK SVC 26 RETURN CODE\n         BNZ   RETURN                  NO ALIAS, QUIT.\n         PACK  DWD,0(3,R4)             PACK 3-DIGIT GDGLIMIT\n         OI    DWD+7,X'0F'             PREVENT S0C7 IF ALL SPACES\n         CVB   R0,DWD                  CONVERT TO BINARY, GET S0C7\n         STC   R0,GDGLIMIT             KEEP GDG LIMIT\n*---------------------------------------------------------------------\n*        LISTCAT\n*---------------------------------------------------------------------\nP2LISTC  ST    R3,CTGENT               GDGNAME\n         MVC   WORK265(4),=Y(L'WORK265,0) FORMAT WORK AREA HEADER\n         MVI   CTGOPTNS,CTGLTCAT       FUNCTION = LISTCAT\n         CATALOG CTGPL                 IS GDG DEFINED ALREADY?\n         LTR   R15,R15                 CHECK SVC 26 RETURN CODE\n         BNZ   P3ZERO                  GDG ISN'T DEFINED, GO DO IT.\n*---------------------------------------------------------------------\n*        DELETE GDG IF CURRENT LIMIT IS DIFFERENT FROM THE ONE REQ'D\n*---------------------------------------------------------------------\nP3DELETE L     R1,CTGFLPT              POINTER TO RETURNED GDGLIMIT\n         CLC   GDGLIMIT,0(R1)          COMPARE WITH PASSED VALUE\n         BE    RETURN                  GDG OK ALREADY, RETURN.\n         MVI   CTGOPTNS,CTGDELET       FUNCTION = DELETE\n         CATALOG CTGPL                 DELETE EXISTING GDG\n         LTR   R15,R15                 CHECK SVC 26 RETURN CODE\n         BNZ   RETURN                  DELETE FAILED, RETURN\nP3ZERO   CLI   GDGLIMIT,0              CHECK GDGLIMIT\n         BE    RETURN                  QUIT IF GDGLIMIT=0\n*---------------------------------------------------------------------\n*        RETRIEVE USERID FROM ACEE                                @200\n*---------------------------------------------------------------------\n         L     R1,PSAAOLD-PSA          MY ASCB\n         L     R1,ASCBASXB-ASCB(,R1)   MY ASXB\n         L     R1,ASXBSENV-ASXB(,R1)   MY ACEE\n         LTR   R1,R1\n         BNP   P4DEFINE                NO ACEE, NO OWNER\n         MVC   OWNERID,ACEEUSRI-ACEE(R1)  MY RACF USER ID\n         LA    R0,CTGFL2               CTGFL FOR OWNER ID\n         ST    R0,CTGFV+28             SET POINTER TO OWNER ID\n*---------------------------------------------------------------------\n*        DEFINE GDG WITH SCRATCH OPTION.\n*---------------------------------------------------------------------\nP4DEFINE LA    R1,CTGFV                ADDR OF CTGFV\n         ST    R1,CTGFVT               STORE CTGFV ADDRESS INTO CTGPL\n         MVI   CTGFV+00,C'B'           SET TYPE TO \"GDG BASE\"\n         ST    R3,CTGFV+20             ADDR OF DSNAME\n         LA    R14,GDGLIMIT            GDG LIMIT\n         LA    R15,GDGATTR             GDG ATTRIBUTES\n         STM   R14,R15,CTGFV+72        SET POINTERS TO GDGLIMIT/GDGATTR\n         MVI   CTGOPTNS,CTGDEFIN       FUNCTION = DEFINE\n         CATALOG CTGPL                 DEFINE GDG\n*---------------------------------------------------------------------\nRETURN   SAVE  15                      STORE RETURN CODE\n         FREEMAIN RU,LV=DYNL,A=(R9)    FREE DYNAMIC STORAGE AREA\n         RETURN (14,12)                RETURN, PASS RETURN CODE.\n*---------------------------------------------------------------------\n*\n*        CATALOG MANAGEMENT CONTROL BLOCKS: CTGPL, CTGFL\n*\n*        FOR INFORMATION ON CATALOG MANAGEMENT REQUESTS AND\n*        CONTROL BLOCKS, REFER TO A DFP/370 OR DFP 2.X\n*        \"DIAGNOSIS REFERENCE\" MANUALS.  IF YOU FIND IT IN THE\n*        DFP 3.X DOCUMENTATION, PLEASE LET ME KNOW.\n*\n*---------------------------------------------------------------------\nCTGPL    DS    0F\nCTGOPTN1 DC    AL1(CTGNAME+CTGCNAME)   FIRST OPTION BYTE:\nCTGNAME  EQU   X'04'                     CTGENT POINTS TO ENTRY NAME\nCTGCNAME EQU   X'02'                     CTGCAT POINTS TO CATALOG NAME\n         DC    B'0'\nCTGFUNC  DC    AL1(CTGCMS+CTGAM0)      CALLER-REQUESTED FUNCTION\nCTGCMS   EQU   X'80'                     REQUEST IS IN CTGOPTNS\nCTGAM0   EQU   X'01'                     OS/VS2 CTGPL, NOT A CAMLST\n         DC    B'0'\nCTGFVT   DS    0A(*-*)                 ADDRESS OF CTGFV FOR DEFINE\nCTGENT   DC    A(*-*)                  ADDRESS OF ENTRY NAME\nCTGCAT   DC    A(*-*)                  ADDRESS OF CATALOG DSNAME\nCTGWKA   DC    A(*-*)                  ADDRESS OF CALLER'S WORK AREA\nCTGOPTNS DC    AL1(CTGLTCAT)           REQUEST:\nCTGLTCAT EQU   X'20' 0010 0...           LISTCAT\nCTGDELET EQU   X'18' 0001 1...           DELETE\nCTGDEFIN EQU   X'08' 0000 1...           DEFINE\n         DC    B'0'\nCTGTYPE  DC    C'B'                    TYPE OF CAT. RECORD (GDG BASE)\nCTGNOFLD DC    FL1'1'                  NUMBER OF POINTERS IN CTGFIELD\nCTGFDBK  DC    XL2'0'                  FEEDBACK AREA\nCTGFBFLG DC    B'0'\n         DC    X'00'                   ERROR CODE\nCTGPSWD  DC    A(0)                    PASSWORD ADDRESS\nCTGFIELD DC    A(CTGFL)                POINTER(S) TO CTGFL(S)\n*\nCTGFL    DS    0F                   +0 FIELD DESCRIPTOR\nCTGFLDNO DC    FL1'1',5X'00'        +0 NUMBER OF FIELDS\nCTGFLDNM DC    A(FLDNM1,0)          +8 PTR TO FIELD NAME\nCTGFLNG  DC    F'0'                +16 LENGTH OF RETURNED DATA\nCTGFLPT  DC    A(*-*)              +20 ADDRESS OF RETURNED DATA\n*\nFLDNM1   DC    C'GDGLIMIT'             FIELD NAME\nGDGATTR  DC    B'01000000'             GDG ATTRIBUTES: SCRATCH, NOEMPTY\nGDGLIMIT DC    FL1'0'                  BINARY GDG LIMIT\nLOCALIAS CAMLST NAME,*-*,,*-*          LOCATE ALIAS\n*\nCTGFL2   DS    0F                   +0 FIELD DESCRIPTOR\n         DC    FL1'1',5X'00'        +0 NUMBER OF FIELDS\n         DC    A(FLDNM2,0)          +8 PTR TO FIELD NAME\n         DC    F'8'                +16 LENGTH OF RETURNED DATA\nCTGFL2PT DC    A(OWNERID)          +20 ADDRESS OF RETURNED DATA\n*\nFLDNM2   DC    C'OWNERID '             FIELD NAME\nOWNERID  DC    C'XXXXXXXX'             VALUE\n*---------------------------------------------------------------------\n*        DYNAMIC STORAGE, BASED WITH R9.\n*---------------------------------------------------------------------\nDYN      DSECT\nCATNAME  DS    CL44' '                 CATALOG DSNAME\nCTGFV    DS    32F                     128-BYTE CTGFV\nDWD      DS    D                       WORK\nWORK265  DS    XL265                   WORK AREA FOR LISTCAT, DELETE.\nDYNL     EQU   *-DYN\n         PRINT NOGEN\n         IHAPSA DSECT=YES\n         IHAASCB DSECT=YES\n         IHAASXB\n         IHAACEE\n*        YREGS                         SYS1.MACLIB\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         END\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//         DD DSN=SYS1.AMODGEN,DISP=SHR\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,15)\n//SYSUT2   DD UNIT=VIO,SPACE=(CYL,15)\n//SYSUT3   DD UNIT=VIO,SPACE=(CYL,15)\n//SYSGO    DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3120\n//SYSPRINT DD SYSOUT=*\n//*\n//LKED    EXEC PGM=IEWL,PARM=REUS\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD DSN=*.ASMXF.SYSGO,DISP=(OLD,PASS)\n//SYSLMOD  DD DSN=GILBERT.LOAD4(DEFGDGSR),DISP=SHR\n//*\n//GO      EXEC PGM=LOADER,PARM=NOPRINT\n//SYSLIN   DD DSN=*.ASMXF.SYSGO,DISP=(OLD,PASS)\n//SYSUDUMP DD SYSOUT=*\n//*\n//AMS     EXEC PGM=IDCAMS\n//SYSPRINT DD SYSOUT=*\n LISTC ENT('GILBERT.GDG') ALL\n/* DELETE    'GILBERT.GDG'\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DONTFAIL": {"ttr": 1539, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x07\\x00\\x00\\x00\\x90!o\\x01\\x06!\\x0f\\x12\\x11\\x02\\x1f\\x01e\\x00\\x80\\xc3\\xc2\\xe3\\xf4\\xf7\\xf2@@@@'", "ispf": {"version": "02.07", "flags": 0, "createdate": "1990-08-04T00:00:00", "modifydate": "2006-07-29T12:11:00", "lines": 543, "newlines": 357, "modlines": 128, "user": "CBT472"}, "text": "//GILBERTF JOB (ACCT#),DONTFAIL,\n// NOTIFY=&SYSUID,\n// CLASS=A,MSGCLASS=X,COND=(0,NE)\n//ASMXF EXEC PGM=IFOX00,PARM=(OBJECT,NODECK,NOESD,NORLD,ALIGN,NOXREF)\n         LCLC  &REL,&WTO1,&DSNAME\n***********************************************************************\n*                                                                     *\n* MODULE NAME = DONTFAIL                                              *\n*                                                                     *\n* DESCRIPTIVE NAME = DUMMY OUT NEXT STEP'S UNCATALOGED DATA SETS      *\n*                                                                     *\n* FUNCTION = This program has been designed to prevent jobs that      *\n*            accept multiple inputs from failing in the middle        *\n*            of the night because of a \"typo\" in a data set name.     *\n*            When DONTFAIL detects that an input data set is not      *\n*            cataloged, it converts it to a null data set and         *\n*            allows the job to run with partial input.                *\n*                                                                     *\n* STATUS = R207                                                       *\n*                                                                     *\n* AUTHOR = Gilbert Saint-Flour <carlos@gsf-soft.com>                  *\n*                                                                     *\n* NOTES = SEE BELOW                                                   *\n*                                                                     *\n*    DEPENDENCIES = MVS/ESA                                           *\n*                   STRING macro R507                                 *\n*                                                                     *\n*    AUTHORIZATION = APF                                              *\n*                                                                     *\n*    RESTRICTIONS = NONE                                              *\n*                                                                     *\n* MODULE TYPE = PROCEDURE, (Batch Program)                            *\n*                                                                     *\n*    PROCESSOR = IBM OS/ASSEMBLER H VERSION 2 OR                      *\n*                IBM HIGH LEVEL ASSEMBLER/MVS                         *\n*                                                                     *\n*    MODULE SIZE = 4K                                                 *\n*                                                                     *\n*    ATTRIBUTES = REENTERABLE, RMODE ANY, AMODE 31,                   *\n*                 SUPERVISOR STATE, KEY 1                             *\n*                                                                     *\n* OPERATION = see below                                               *\n*                                                                     *\n*            DONTFAIL must be executed immediately before the job     *\n*            step to \"protect\", as shown in the following example:    *\n*                                                                     *\n*              //DONTFAIL EXEC PGM=DONTFAIL                           *\n*              //*                                                    *\n*              //SORT53    EXEC PGM=SORT                              *\n*              //SORTIN     DD DSN=USER.INPUT1,DISP=SHR               *\n*              //           DD DSN=USER.INPUT2,DISP=SHR               *\n*                                                                     *\n*            If any input data set in step SORT52 in not cataloged,   *\n*            DONTFAIL will make it a null data set, preventing the    *\n*            job from failing with a DATA SET NOT FOUND error.        *\n*                                                                     *\n*            To detect uncataloged data sets and correct them,        *\n*            DONTFAIL proceeds as follows:                            *\n*                                                                     *\n*            1. scan the SWA control blocks that represent            *\n*               the following step's DD statements for input          *\n*               data sets (i.e. DISP=OLD or DISP=SHR)                 *\n*            2. check the catalog status of each input data set       *\n*            3. modify SWA control blocks to convert each             *\n*               non-cataloged data set to a null data set             *\n*            4. set DCB attributes (optional, see below)              *\n*                                                                     *\n*            NOTES:                                                   *\n*                                                                     *\n*              a. DONTFAIL must be executed once for every            *\n*                 job step that needs to be protected.                *\n*                                                                     *\n*              B. Prior to using DONTFAIL, you must allocate and      *\n*                 catalog an empty disk data set and specify its      *\n*                 name in the SETC instruction below.  You can use    *\n*                 an already-defined pattern DSCB if it has been      *\n*                 created with RECFM=,LRECL=0,BLKSIZE=0.              *\n*                                                                     *\n*              C. The last DD in a concatenation (or the only DD      *\n*                 of a non-concatenated data set) is changed to       *\n*                 DD DUMMY; for other DD statements, the DSN          *\n*                 is changed to &DSNAME                               *\n*                                                                     *\n&DSNAME SETC 'SYS2.DONTFAIL'      <=== DSN of the empty data set\n*                                                                     *\n*            DCB ATTRIBUTES                                           *\n*                                                                     *\n*              When changing the DSN of a data set in a concate-      *\n*              nation, DONTFAIL also carries DCB attributes (RECFM,   *\n*              LRECL, BLKSIZE) from DDs previously concatenated to    *\n*              the same DDname. This prevents utility programs such   *\n*              as SORT or IDCAMS REPRO from failing when the empty    *\n*              data set has incompatible DCB attributes or no DCB     *\n*              attributes at all.                                     *\n*                                                                     *\n*              Example:                                               *\n*                                                                     *\n*                //COPY53  EXEC PGM=IDCAMS                            *\n*                //DD1      DD DSN=USER.INPUT1,DISP=SHR,              *\n*                //            RECFM=FB,LRECL=124                     *\n*                //         DD DSN=USER.INPUT2,DISP=SHR               *\n*                //         DD DSN=USER.INPUT3,DISP=SHR               *\n*                //DD2      DD DSN=USER.INPUT4,DISP=SHR,              *\n*                //            RECFM=FB,LRECL=124                     *\n*                                                                     *\n*                In this example, if USER.INPUT2 is not cataloged,    *\n*                it is changed to DSN=&DSNAME, and                    *\n*                RECFM=FB,LRECL=124,BLKSIZE=124 are added also.       *\n*                If BLKSIZE is not specified, it is set equal to      *\n*                LRECL+4 if RECFM=VB was specified, otherwise,        *\n*                BLKSIZE is set equal to LRECL.  In this example      *\n*                also, if USER.INPUT3 or USER.INPUT4 are not          *\n*                cataloged, they are changed to DD DUMMY.             *\n*                                                                     *\n* CHANGE ACTIVITY                                                     *\n*                                                                     *\n*   $100 Program rewritten for MVS/ESA                                *\n*   $101 Ignore data sets with VOL=REF to a DISP=NEW DD               *\n*   $102 Force SDATA=(LSQA,SWA) in case of an abend                   *\n*   $103 Change to DSN=&DSNAME instead of DD DUMMY                    *\n*        if JCL specifies FREE=CLOSE                                  *\n*   $104 Ignore temporary data sets                                   *\n*   $105 Invoke PGM=RECALL if it's been linked with DONTFAIL          *\n*   $106 Change STRING GENERATE to STRING 507 format                  *\n*   $207 OS/VS2                                                       *\n*                                                                     *\n***********************************************************************\n&REL     SETC  '207'\nDONTFAIL CSECT\n         DC    C'GSF UTILITIES - DONTFAIL R&REL '\nBEGIN    LR    R12,R15\n         USING BEGIN,R12\n         LR    R5,R1                   JCL PARM\n         MODESET MODE=SUP              SWITCH TO SUPERVISOR MODE\n         ESTAE DUMPOPT,CT\n         GETMAIN RU,LV=DYNAML,SP=230,KEY=1,BRANCH=YES\n         ST    R1,8(,R13)              chain save areas\n         MODESET EXTKEY=JES            SWITCH TO KEY=1\n         ST    R13,4(,R1)              chain save areas\n         LR    R13,R1                  ADDRESS OF DYNAMIC STORAGE AREA\n         USING DYNAM,R13\n         LA    R0,DYNAM+72             CLEAR WORKING STORAGE TO X'00'\n         LA    R1,DYNAML-72            CLEAR WORKING STORAGE TO X'00'\n         SLR   R15,R15                 CLEAR WORKING STORAGE TO X'00'\n         MVCL  R0,R14                  CLEAR WORKING STORAGE TO X'00'\n         ST    R5,PARMADDR             addr of JCL PARM\n***********************************************************************\n*                                                                     *\n*        LOCATE TCB, JSCB, GDGNT.                                     *\n*        LOCATE SCT AND 1ST SIOT FOR NEXT STEP.                       *\n*                                                                     *\n***********************************************************************\n         L     R1,540(,0)              PSATOLD\n         L     R3,TCBJSCB-TCB(,R1)     GET THE ADDRESS OF MY JSCB\n         USING IEZJSCB,R3\n         L     R4,JSCBJCT              Address of JCT prefix\n         USING INJMJCT-16,R4\n*\n         ICM   R1,B'0111',JCTGDGNT     3-BYTE SVA OF GDG NAME TABLE\n         BZ    OWNSCT                  JUMP IF THERE IS NO GDGN TABLE\n         LA    R1,16(,R1)              CONVERT SVA TO 24-BIT ADDRESS\n         ST    R1,GDGNTPTR             KEEP ADDRESS OF GDG NAMES TABLE\n*\nOWNSCT   SLR   R5,R5\n         ICM   R5,B'0111',JSCSCTP      3-BYTE SVA OF CURRENT STEP'S SCT\n         USING INSMSCT-16,R5\n*\nNEXTSCT  ICM   R5,B'0111',SCTANSCT     LOAD 3-BYTE SVA OF NEXT SCT\n         BZ    RETURN                  RETURN IF THERE IS NO NEXT STEP\n         ICM   R1,B'0111',SCTFSIOT     LOAD 3-BYTE SVA OF 1ST SIOT\n         BZ    RETURN                  NO DD CARDS, RETURN\n***********************************************************************\n*                                                                     *\n*        LOOP THRU THE SIOT BLOCKS                                    *\n*                                                                     *\n***********************************************************************\n*LOOP\nLOOPSIOT LA    R6,16(,R1)              ADDRESS OF SIOT\n         USING SIOT,R6\n         IC    R1,SEQNO                INCREMENT CURRENT SEQNO\n         LA    R1,1(,R1)               INCREMENT CURRENT SEQNO\n         STC   R1,SEQNO                INCREMENT CURRENT SEQNO\n         TM    SCTSBYT1,SIOTCCAT       CHECK FOR CONCATENATION\n         BO    TESTDISP                JUMP IF NO DDNAME\n         MVC   DDNAME,SCTDDNAM         KEEP DDNAME\n         MVI   SEQNO,0                 RESET DDSEQ\n         SLR   R0,R0\n         STCM  R0,B'0001',RECFM        zero DCB attributes\n         STCM  R0,B'0011',LRECL        zero DCB attributes\n         STCM  R0,B'0011',BLKSIZE      zero DCB attributes\n*\nTESTDISP TM    SCTSBYT3,SCTSOLD        Check for DISP=OLD (or SHR)\n         BNO   NEXTSIOT                JUMP IF NOT DISP=OLD\n         CLI   SCTUTYPE,C' '           CHECK UNIT NAME\n         BH    NEXTSIOT                JUMP IF THERE IS A UNIT NAME\n*\n*        Ignore DD with VOL=REF to a DISP=NEW data set\n*\n         ICM   R1,B'0111',SIOTVRSB     LOAD 3-BYTE SVA OF VOL=REF SIOT\n         BZ    LOCJFCB                 NO VOL=REF, JUMP\n         LA    R1,16(,R1)              CONVERT SVA TO 24-BIT ADDRESS\n         TM    SCTSBYT3-SIOT(R1),SCTSNEW   VOL=REF DD has DISP=NEW?\n         BO    NEXTSIOT                yes, ignore current DD\n*\nLOCJFCB  ICM   R1,B'0111',SCTPJFCB     LOAD 3-BYTE SVA OF JFCB\n         LA    R7,16(,R1)              ADDRESS OF JFCB\n         USING JFCB,R7\n         TM    JFCBIND2,JFCTEMP        temporary data set?\n         BO    NEXTSIOT                yes, ignore current DD\n         CLI   JFCBELNM,C'+'           DSNAME(+1)  ?\n         BE    NEXTSIOT                YES, IGNORE\n         MVC   DSNAME,JFCBDSNM         MOVE DSN TO UNPROTECTED STORAGE\n*\nSAVEDCB  ICM   R0,B'0001',JFCRECFM     RECFM present on this DD?\n         BZ    SAVEDCB2                no, jump\n         STCM  R0,B'0001',RECFM        save non-zero DCB attributes\nSAVEDCB2 ICM   R0,B'0011',JFCLRECL     LRECL present on this DD?\n         BZ    SAVEDCB8                no, jump\n         STCM  R0,B'0011',LRECL        save non-zero DCB attributes\n         ICM   R0,B'0001',JFCRECFM     RECFM present on this DD?\n         BNZ   SAVEDCB8                yes, jump\n         MVI   RECFM,JFCFIX+JFCRFB     if LRECL is present but RECFM   +\n                                       is not, assume RECFM=FB\nSAVEDCB8 ICM   R0,B'0011',JFCBLKSI     LRECL present on this DD?\n         BZ    *+8                     no, jump\n         STCM  R0,B'0011',BLKSIZE      save non-zero DCB attributes\n*--------------------------------------------------------------------*\n*                                                                    *\n*        IF THE CURRENT DATA SET IS A GDG, SCAN THE GDG NAMES TABLE  *\n*        FOR THE CURRENT APPARENT GEN (0), IF ANY.                   *\n*                                                                    *\n*--------------------------------------------------------------------*\nGDG000   TM    JFCBIND1,JFCGDG         CHECK GDG INDICATOR\n         BNO   GDG099                  JUMP IF NOT GDG\n         ICM   R1,B'1111',GDGNTPTR     LOAD ADDR OF GDG NAMES TABLE\n         BZ    GDG080                  JUMP IF NO GDGNT\n         USING GDGNTABL,R1\n*--loop\nGDG010   SLR   R14,R14                 PREPARE IC\n         IC    R14,GDGNNO              GET NUMBER OF ENTRIES\n*----loop\nGDG015   CLC   GDGNGDG,DSNAME          COMPARE TABLE ENTRY W/ DSNAME\n         BE    GDG040                  JUMP IF NOT THE SAME\n         LA    R1,GDGNGDG2             BUMP UP TO NEXT ENTRY IN BLOCK\n         BCT   R14,GDG015              LOOP UNTIL END OF BLOCK\n*----endloop\n         ICM   R1,B'1111',GDGNNEXT     LOAD ADDR OF NEXT GDGNT BLOCK\n         BNZ   GDG010                  PROCESS NEXT BLOCK\n*--endloop\n         NI    CTGOPTN3,255-CTGGDGL    CTGWAGB IS NOT SET\n         B     GDG080                  EXIT GDGNT SCAN LOOP\n*\nGDG040   LA    R0,GDGNGDGZ             GET PTR TO APPARENT GEN(0)\n         ST    R0,CTGWAGB              SET POINTER IN SVC 26 WORK AREA\n         OI    CTGOPTN3,CTGGDGL        SHOW CTGWAGB IS SET\n         DROP  R1                      GDGNTABL\n*\n*        append relative gen number to end of data set name\n*\nGDG080   STRING (JFCBDSNM,,T),'(',(JFCBELNM,,T),')',INTO=DSNAME\nGDG099   EQU   *\n*--------------------------------------------------------------------*\n*                                                                    *\n*        GET DEVICE TYPE INFORMATION FROM THE CATALOG.               *\n*                                                                    *\n*--------------------------------------------------------------------*\nLOCATE   LA    R0,DSNAME               DATA SET NAME\n         ST    R0,CTGENT               ENTRY ADDRESS\n         OI    CTGOPTN1,CTGNAME        CTGENT POINTS TO ENTRY NAME\n         LA    R0,CTGWA                WORK AREA FOR SUPERLOCATE\n         ST    R0,CTGWKA               WORK AREA FOR SUPERLOCATE\n         OI    CTGOPTN3,CTGSUPLT       SUPER LOCATE\n         OI    CTGOPTN3,CTGAM0         OS/VS2 CATALOG MGMT REQUEST\n         LA    R0,CTGVL                GET ADDR OF VOLUME LIST\n         ST    R0,CTGWAVL              UPDATE PTR\n         LA    R0,CTGVLLEN             GET LENGTH OF VOLUME LIST\n         STH   R0,CTGWALV              UPDATE LENGTH\n         LOCATE CTGPL                  ISSUE SUPERLOCATE\n         LTR   R15,R15                 DATA SET cataloged?\n         BZ    NEXTSIOT                yes, ignore it\n*---------------------------------------------------------------------*\n*                                                                     *\n*        If this data set is not cataloged, modify the SIOT & JFCB    *\n*                                                                     *\n*          1.  if the DD has other DDs concatenated behind it,        *\n*              or the DD has FREE=CLOSE,                              *\n*                set DSNAME to \"&DSNAME\"                              *\n*              else                                                   *\n*                set DD DUMMY flag in SIOT                            *\n*          2.  carry DCB attributes from previous DD in               *\n*              concatenation                                          *\n*          3.  Issue message to operator                              *\n*                                                                     *\n*---------------------------------------------------------------------*\nMSG00    MVC   WTO1L(WTO1LL),WTO1M     move model to dynamic\n         STRING '&DSNAME',INTO=DSNAME\n*\n         ICM   R1,B'0111',SCTPSIOT     SVA OF NEXT SIOT\n         BZ    MSG12                   last DD, jump\n         LA    R1,16(,R1)              CONVERT SVA TO 24-BIT ADDRESS\n         TM    SCTSBYT1-INDMSIOT(R1),SIOTCCAT   concatenated DD?\n         BO    MSG20                   yes, jump\n         TM    SCTSBYT2,SIOCLUNL       FREE=CLOSE?\n         BO    MSG20                   yes, jump\n*\nMSG12    STRING 'DD DUMMY',INTO=DSNAME\n         OI    SCTSBYT1,SCTDUMMY       DD DUMMY\n*\nMSG20    STRING 'DONTFAIL - ',                                         +\n               (JFCBDSNM,,T),' changed to ',(DSNAME,,T),               +\n               '  (DDN=',DDNAME,       do not close parenthesis        +\n               INTO=WTO1TEXT\n         CLI   SEQNO,0                 first DD in concat?\n         BE    MSG80                   yes, jump\n         STRING (WTO1TEXT,,T),'+',(SEQNO,FL1,L),                       +\n               INTO=WTO1TEXT\n*\nMSG80    CLC   =C'DD ',DSNAME          changed to DD DUMMY ?\n         BE    MSG81                   yes, do not change JFCB\n         MVC   JFCBDSNM,DSNAME         move new dsname\n*\n*        Carry DCB attributes from previous DD\n*\nMSG81    ICM   R0,B'0001',JFCRECFM     RECFM specified in JCL?\n         BNZ   MSG88L                  yes, jump\n         MVC   JFCRECFM,RECFM          no, carry from previous DD\nMSG88L   ICM   R0,B'0011',JFCLRECL     LRECL specified in JCL?\n         BNZ   MSG88B                  yes, jump\n         MVC   JFCLRECL,LRECL          no, carry from previous DD\nMSG88B   ICM   R1,B'0011',JFCBLKSI     BLKSIZE specified in JCL?\n         BNZ   MSG90                   yes, exit\n         ICM   R1,B'0011',BLKSIZE      BLKSIZE on previous DD?\n         BNZ   MSG88B4                 yes, use it\n         ICM   R1,B'0011',LRECL        LRECL on previous DD?\n         BZ    MSG90                   no, exit\n         TM    JFCRECFM,JFCVAR         RECFM=V ?\n         BZ    MSG88B4                 no, set BLKSIZE=LRECL\n         LA    R1,4(,R1)               yes, set BLKSIZE=LRECL+4\nMSG88B4  STCM  R1,B'0011',JFCBLKSI     update BLKSIZE\n*\n*        Issue message to operator\n*\nMSG90    STRING (WTO1TEXT,,T),',DCB=',(JFCRECFM,,X),'/',               X\n               (JFCLRECL,H,L),'/',(JFCBLKSI,H,L),')',INTO=WTO1TEXT\n         WTO   MF=(E,WTO1L)            NOTIFY PROGRAMMER\n*\nNEXTSIOT ICM   R1,B'0111',SCTPSIOT     SVA OF NEXT SIOT\n         BNZ   LOOPSIOT                PROCESS NEXT DD CARD IN STEP\n*ENDLOOP\n         DROP  R5,R6,R7                SCT, SIOT, JFCB\n***********************************************************************\n*                                                                     *\n*        CLEAN-UP, RETURN TO CALLER.                                  *\n*                                                                     *\n***********************************************************************\nRETURN   LR    R1,R13                  addr of work area\n         L     R5,PARMADDR             addr of JCL PARM\n         L     R13,4(,R13)             caller's save area\n         FREEMAIN RU,LV=DYNAML,A=(R1),SP=230,KEY=1,BRANCH=YES\n*\n*        invoke PGM=RECALL\n*\n         WXTRN RECALL                  optional\n         MODESET KEY=NZERO,MODE=PROB\n         ICM   R15,B'1111',=A(RECALL)  get addr of RECALL pgm\n         BZ    RETURN99                not available, jump\n         LR    R1,R5                   restore parm address\n         BALR  R14,R15              <- invoke PGM=RECALL\n*\n         SLR   R15,R15                 RC=00\nRETURN99 EQU   *\n         SVC   3                       GOBACK\n*\n&WTO1    SETC  (120)' '\nWTO1M    WTO   '&WTO1',MF=L,ROUTCDE=11\n*---------------------------------------------------------------------\n*        ESTAE routine: changed dump options\n*---------------------------------------------------------------------\n         USING SDWA,R1\nDUMPOPT  OI    SDWASDA0,SDWALSQA+SDWASWA dump LSQA and SWA\n         OI    SDWADPFS,SDWADLST       DUMP OPTIONS VALID\n         BR    R14\n*---------------------------------------------------------------------\n*        DYNAMIC STORAGE AREA, BASED BY R13.\n*---------------------------------------------------------------------\nDYNAM    DSECT\n         DS    18F                     STANDARD SAVE AREA\nGDGNTPTR DS    A(GDGNTABL)             POINTER TO GDG NAMES TABLE\nPARMADDR DS    A                       JCL PARM\nTAPE1    DS    XL2                     INTERNAL DD# FOR 1ST TAPE DD\nDDNAME   DS    CL8                     DDNAME\nRECFM    DS    X                       RECFM\nLRECL    DS    H                       LRECL\nBLKSIZE  DS    H                       BLKSIZE\nSEQNO    DS    FL1                     SEQNO (concatenation)\nDSNAME   DS    CL44                    MODIFIABLE DSNAME\nWTO1L    WTO   '&WTO1',MF=L,ROUTCDE=11\nWTO1LL   EQU   *-WTO1L\nWTO1TEXT EQU   WTO1L+4,120\n*---------------------------------------------------------------------*\n*        CATALOG PARAMETER LIST\n*---------------------------------------------------------------------*\nCTGPL    DS    0D\nCTGOPTN1 DS    B              FIRST OPTION BYTE:\nCTGNAME  EQU   X'04' .... .1..  CTGENT CONTAINS DSNAME OR SERIAL ADDR\nCTGOPTN2 DS    B              SECOND OPTION BYTE\nCTGOPTN3 DS    B     XXX. ....  SPECIFIES THE CALLER-REQUESTED FUNCTION\nCTGSUPLT EQU   X'10' ...1 ....  SUPERLOCATE FUNCTION\nCTGGDGL  EQU   X'08' .... 1...  GDG LOCATE - CALLER SUPPLIED BASE LEVEL\nCTGAM0   EQU   X'01' .... ...1  OS/VS2 CATALOG MANAGMENT REQUEST\nCTGOPTN4 DS    B              FOURTH OPTION BYTE\nCTGLBASE EQU   X'80' 1... ....  LOCATE BASE LEVEL (SUPERLOCATE GDG)\nCTGENT   DS    A              ADDRESS OF CATALOG RECORD IDENTIFIER\nCTGCAT   DS    A              ADDRESS OF CATALOG DSNAME OR ACB\nCTGWKA   DS    A              ADDRESS OF CALLER'S WORK AREA\nCTGOPTNS DS    B              CATALOG MANAGMENT SERVICES REQUEST OPTION\n         DS    B              RESERVED\nCTGTYPE  DS    C              TYPE OF CATALOG RECORD\nCTGNOFLD DS    FL1            NUMBER OF ENTRIES IN CTGFIELD\nCTGFDBK  DS    XL2            FEEDBACK AREA (IF NOT SUPERLOCATE)\nCTGFBFLG DS    B              FLAGS (SUPERLOCATE)\nCTGPAR   EQU   X'80' 1... ....  PARALLEL MOUNT\nCTGKEEP  EQU   X'40' .1.. ....  FORCED KEEP\nCTGGDGB  EQU   X'20' ..1. ....  GDG BASE LOCATED\nCTGNGDSN EQU   X'10' ...1 ....  GDG DSNAME GENERATED (DSNAME.GXXXXVYY)\n         DS    B              RESERVED (SUPERLOCATE)\nCTGPSWD  DS    A              ADDRESS OF CALLER-SUPPLIED PASSWORD\n*---------------------------------------------------------------------*\n*        CATALOG WORK AREA\n*---------------------------------------------------------------------*\nCTGWA    DS    0D\nCTGWAVL  DS    A                       PTR TO CTGVL (VOLUME LIST)\nCTGWALV  DS    H                       LENGTH OF THE VOLUME LIST\nCTGWAVCT DS    H                       # OF VOLSERS RETURNED IN VL\nCTGWAUCT DS    H                       MINIMUM # OF VOLS TO BE MOUNTED\nCTGWAGCT DS    H                       # OF GENERATIONS CATALOGED\nCTGWAGB  DS    A                       PTR TO APPARENT GEN(0)\n*---------------------------------------------------------------------*\n*        CATALOG VOLUME LIST\n*---------------------------------------------------------------------*\nCTGVL    DS    0D\nCTGVLVOL DS    CL6                     VOLUME SERIAL\nCTGVLDEV DS    XL4                     DEVICE TYPE\nCTGVLSEQ DS    H                       FILE SEQNO\nCTGVLX   DS    19XL12                  VOLUME LIST EXTENSION\nCTGVLLEN EQU   *-CTGVL                 LENGTH OF VOLUME LIST\nDYNAML   EQU   *-DYNAM\n*---------------------------------------------------------------------\n*        GDG NAMES TABLE MAPPING (USING IEFZB902 AS A MODEL)\n*---------------------------------------------------------------------\nGDGNTABL DSECT\nGDGNQSVA DS    XL3                     SVA OF NEXT GDGNT RECORD\nGDGNTID  DS    X'23'                   GDGNT ID X'23'\nGDGNNEXT DS    A                       IN-CORE ADDRESS OF NEXT RECORD\nGDGNGDG  DS    CL35                    GDG BASE\nGDGNGDGZ DS    C'1234'                 APPARENT (0) GENERATION\nGDGNGDG2 DS    CL35,C'1234'            2ND GDG NAME\n         DS    CL35,C'1234'            3RD GDG NAME\n         DS    CL35,C'1234'            4TH GDG NAME\nGDGNNO   DS    FL1                     NUMBER OF ENTRIES\n         DS    XL15                    FILLER\nGDGNLEN  EQU   GDGNTABL+176\n*---------------------------------------------------------------------\n*        MAPPING MACROS\n*---------------------------------------------------------------------\n         PRINT NOGEN\n         IKJTCB LIST=NO                TASK CONTROL BLOCK\n         IEZJSCB                       JOB STEP CONTROL BLOCK\nJCT      DSECT\n         IEFAJCTB                      JOB CONTROL BLOCK\nSCT      DSECT\n         IEFASCTB                      STEP CONTROL BLOCK\nSCTSNEW  EQU   4                       BIT 5 - NEW DATA SET\nSCTSOLD  EQU   1                       BIT 7 - OLD DATA SET\nSIOT     DSECT\n         IEFASIOT                      STEP I/O TABLE\nJFCB     DSECT\n         IEFJFCBN LIST=YES             JOB FILE CONTROL BLOCK\n         CVT   DSECT=YES               COMMUNICATION VECTOR TABLE\n         IHASDWA                       ESTAE\n         STRING GENERATE               Generate CSECT\n*        YREGS                         REGISTER EQUATES\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         END   BEGIN\n//SYSLIB   DD DSN=SYS1.AMODGEN,DISP=SHR\n//         DD DSN=SYS1.MACLIB,DISP=SHR\n//         DD DSN=GILBERT.FILE183.PDS,DISP=SHR      STRING macro\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,15)\n//SYSUT2   DD UNIT=VIO,SPACE=(CYL,15)\n//SYSUT3   DD UNIT=VIO,SPACE=(CYL,15)\n//SYSGO    DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3120\n//SYSPRINT DD SYSOUT=*\n//*\n//LKED    EXEC PGM=IEWL,PARM='RENT,AC=1'\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD DSN=*.ASMXF.SYSGO,DISP=(OLD,DELETE)\n//         DD *\n CHANGE @STRING(@STRING2)\n INCLUDE SYSLMOD(RECALL)\n//SYSLMOD  DD DSN=SYS2.AUTHLIB(DONTFAIL),DISP=SHR\n//*\n//NULLFIL1 EXEC PGM=DONTFAIL\n//SYSUDUMP DD SYSOUT=*\n//ABNLIGNR DD DUMMY\n//*\n//REPRO1   EXEC PGM=IDCAMS\n//SYSPRINT DD SYSOUT=*\n//INDD     DD DSN=GILBERT.UNCAT1,LRECL=80,DISP=SHR  ,RECFM=FB\n//         DD DSN=GILBERT.X80,DISP=SHR\n//         DD DSN=IBMUSER.UNCAT2,DISP=SHR\n//OUTDD    DD DUMMY,BLKSIZE=800\n REPRO IFILE(INDD) OFILE(OUTDD)\n//DISPMOD  DD UNIT=SYSDA,SPACE=(TRK,0),DSN=&&REFMOD,DISP=MOD\n//VOLREF1  DD VOL=REF=*.DISPMOD,DSN=*.DISPMOD,DISP=OLD\n//DISPNEW  DD UNIT=SYSDA,SPACE=(TRK,0),DSN=&&REFNEW,DISP=NEW\n//VOLREF2  DD VOL=REF=*.DISPNEW,DSN=*.DISPNEW,DISP=OLD\n//*\n//NULLFIL2 EXEC PGM=DONTFAIL\n//SYSUDUMP DD SYSOUT=*\n//ABNLIGNR DD DUMMY\n//*\n//SORT2   EXEC PGM=SORT\n//SYSOUT   DD SYSOUT=*\n//SORTIN   DD DSN=GILBERT.UNCAT1,LRECL=80,DISP=SHR  ,RECFM=FB\n//         DD DSN=GILBERT.X80,DISP=SHR\n//         DD DSN=GILBERT.UNCAT2,DISP=SHR\n//SORTOUT  DD DUMMY,BLKSIZE=800\n SORT FIELDS=(1,8,CH,A)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "EASYSORT": {"ttr": 1793, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x04\\x00\\x00\\x00\\x81\\x10\\x1f\\x01\\x06!\\x0f\\x12I\\x00\\xb8\\x00\\xb7\\x00\\x96\\xc3\\xc2\\xe3\\xf4\\xf7\\xf2@@@@'", "ispf": {"version": "02.04", "flags": 0, "createdate": "1981-04-11T00:00:00", "modifydate": "2006-07-29T12:49:00", "lines": 184, "newlines": 183, "modlines": 150, "user": "CBT472"}, "text": "//GILBERTE JOB (ACCT#),EASYSORT,\n// NOTIFY=&SYSUID,\n// CLASS=A,MSGCLASS=X,COND=(0,NE)\n//ASMXF EXEC PGM=IFOX00,PARM=(OBJECT,NODECK,NOESD,NORLD,ALIGN,NOXREF)\n         MACRO\n&REF     EASYSORT &FUNC,&WORKA,&EODAD=,&SET=(R1),                      X\n               &TYPE=F,&LENGTH=80,&FIELDS=(1,80,CH,A)\n.**********************************************************************\n.*                                                                    *\n.*   USAGE:                                                           *\n.*                                                                    *\n.*       SORT  OPEN,TYPE=F,LENGTH=64,FIELDS=(1,22,CH,A)               *\n.*       SORT  PUT,(1)                                                *\n.*       SORT  GET,SET=(R3),EODAD=ENDSORT                             *\n.*                                                                    *\n.**********************************************************************\n         GBLB  &EASYSRT\n         LCLC  &LABEL,&LQ\n&LABEL   SETC  'IHB&SYSNDX'\n         AIF   ('&FUNC' EQ 'OPEN').OPEN\n         AIF   ('&FUNC' EQ 'PUT').PUT\n         AIF   ('&FUNC' EQ 'GET').GET\n         MNOTE 8,'INVALID FUNCTION REQUESTED &FUNC'\n&REF     DS    0H\n         MEXIT\n.OPEN    ANOP  ,  ====== OPEN ========\n&REF     L     R15,=A(SORT$OPN)        .\n         LA    R1,=A(&LABEL.P+X'80000000') PARM LIST ADDRESS\n         BALR  R14,R15                 OPEN SORT\nSORT$XXX CSECT\n.**********************************************************************\n         AIF   (&EASYSRT).NOOPN        JUMP IF NOT FIRST OPEN\n&EASYSRT SETB  1\nSORT$OPN STM   R14,R12,12(R13)         SAVE REGISTERS\n         USING SORT$OPN,R15\n         ST    R13,SORT$SAV+4          BACKWARD CHAIN\n         LA    R13,SORT$SAV            SORT SAVE AREA\n         MVI   0(R13),C'0'             PHASE 0 ENTERED\n*        LINK  SF=(E,SORT$LNK)         LINK EP=SORT,SF=L\n         LINK  SF=(E,SORT$LNK)         LINK EP=SORT,SF=L\n         L     R13,4(,R13)             RELOAD PROGRAM'S SAVE AREA ADDR.\n         LM    R14,R12,12(R13)         RESTORE REGISTERS (GET)\n         SLR   R1,R1                   INVALIDATE RECORD POINTER\n         BR    R14                     GOBACK TO PROGRAM (GET)\nSORT$E15 STM   R14,R12,12(R13)         SAVE REGISTERS FROM SORT\n         USING SORT$E15,R15\n.*       ST    R13,SORT$SAV+8          ESTABLISH CHAIN FOR PUT\n         L     R13,SORT$SAV+4          PROGRAM'S SAVE AREA\n         MVI   SORT$SAV,C'1'           PHASE 1 STARTED\n         LM    R14,R12,12(R13)         RESTORE PROGRAM'S REGISTERS\n         BR    R14                     GOBACK TO PROGRAM (PUT)\nSORT$PUT STM   R14,R12,12(R13)         SAVE PROGRAM'S REGISTERS\n         USING SORT$OPN,R15\n         L     R13,SORT$SAV+8          SAVE AREA FOR E15\n         LM    R14,R0,12(R13)          RESTORE SORT R14-R0\n         LA    R15,0012(0)             INSERT RECORD REQUEST\n         LM    R2,R12,28(R13)          RESTORE SORT R2-R12\n         BR    R14                     GOBACK TO SORT (E15)\nSORT$E35 STM   R14,R12,12(R13)         SAVE REGISTERS FROM SORT\n         USING SORT$E35,R15\n         ICM   R1,B'1111',0(R1)        ADDR OF SORTED RECORD\n         BZ    SORT$E36                NO MORE RECORDS, TERMINATE E35\n.*       ST    R13,SORT$SAV+8          ESTABLISH CHAIN FOR GET\n         L     R13,SORT$SAV+4          PROGRAM'S SAVE AREA\n         LM    R14,R0,12(R13)          RESTORE PROGRAM'S R14-R0\n         LM    R2,R12,28(R13)          RESTORE PROGRAM'S R2-R12\n         BR    R14                     GOBACK TO PROGRAM, PASS R1\nSORT$E36 LA    R15,0008(0)             \"QUIT\" RETURN CODE\n         BR    R14                     GOBACK TO SORT, TERMINATE E35\nSORT$GET STM   R14,R12,12(R13)         SAVE PROGRAM'S REGISTERS\n         USING SORT$OPN,R15\n         L     R13,SORT$SAV+8          SAVE AREA FOR E15/E35\n         CLI   SORT$SAV,C'3'           CHECK PHASE 3 ENTERED\n         BE    &LABEL.3                JUMP IF E35 STARTED ALREADY\n         MVI   SORT$SAV,C'3'           SHOW PHASE 3 ENTERED\n         LM    R14,R12,12(R13)         RESTORE SORT REGISTERS\n         LA    R15,0008(0)             END OF E15 REQUEST\n         BR    R14                     GOBACK TO SORT (E15)\n&LABEL.3 LM    R14,R12,12(R13)         RESTORE REGISTERS\n         LA    R15,0004(0)             DELETE RECORD\n         BR    R14                     GOBACK TO SORT (E35)\n         DROP  R15\nSORT$LNK LINK  EP=SORT,SF=L            PARAMETER LIST FOR LINK SVC\nSORT$SAV DS    18F                     SAVE AREA FOR SORT\n.NOOPN   CNOP  2,4\n&LQ      SETC  'L'''\n&LABEL.P DC    Y(&LABEL.S-(*+2))       LENGTH OF PARM LIST\n         DC    A(&LABEL.S,&LABEL.S+&LQ&LABEL.S-1)\n         DC    A(&LABEL.R,&LABEL.R+&LQ&LABEL.R-1)\n         DC    A(SORT$E15,SORT$E35)\n&LABEL.S DC    C' SORT FIELDS=&FIELDS,DYNALLOC=3380 '\n&LABEL.R DC    C' RECORD TYPE=&TYPE,LENGTH=&LENGTH ',0H'0'\n&SYSECT  CSECT\n         MEXIT\n.**********************************************************************\n.*       PUT\n.**********************************************************************\n.PUT     AIF   ('&WORKA'(1,1) EQ '(').PUTREG\n&REF     LA    R1,&WORKA               GET RECORD ADDRESS\n         AGO   .PUTCOMM\n.PUTREG  AIF   ('&WORKA' EQ '(1)' OR '&WORKA' EQ '(R1)').PUTREG1\n&REF     LR    R1,&WORKA(1)            GET RECORD ADDRESS\n         AGO   .PUTCOMM\n.PUTREG1 ANOP\n&REF     L     R15,=A(SORT$OPN)        POINT TO SORT CSECT\n         AGO   .PUTBALR\n.PUTCOMM L     R15,=A(SORT$OPN)        POINT TO SORT CSECT\n.PUTBALR BAL   R14,SORT$PUT-SORT$OPN(,R15) CALL PUT ROUTINE\n         MEXIT\n.**********************************************************************\n.*       GET\n.**********************************************************************\n.GET     ANOP\n&REF     L     R15,=A(SORT$OPN)        POINT TO SORT CSECT\n         BAL   R14,SORT$GET-SORT$OPN(,R15) CALL GET ROUTINE\n         LTR   &SET(1),R1              CHECK RECORD ADDRESS\n         BZ    &EODAD                  END OF DATA\n.MEND    MEND\n***********************************************************************\n*\n*        TEST PROGRAM\n*\n***********************************************************************\n         EJECT\nEASYSORT CSECT\n         SAVE  (14,12),,TEST-EASYSORT-&SYSDATE\n         BALR  R12,0                   BASE REGISTER\n         USING *,R12\n         ST    R13,SAVEAREA+4          CALLER'S SAVE AREA\n         LA    R13,SAVEAREA            MY OWN SAVE AREA\n***********************************************************************\n         OPEN  SYSIN\n         EASYSORT OPEN,TYPE=F,LENGTH=32,FIELDS=(1,12,CH,A)\nGET1     GET   SYSIN                   GET A SYSIN RECORD\n         EASYSORT PUT,(R1)             PASS RECORD TO THE SORT (E15)\n         B     GET1                    GET NEXT RECORD\nEOD1     CLOSE SYSIN                   CLOSE INPUT FILE\n         FREEPOOL SYSIN                FREE BUFFERS\n***********************************************************************\n         OPEN  (SYSPRINT,EXTEND)\nPUT2     EASYSORT GET,SET=R0,EODAD=EOD2 GET SORTED RECORD (E35)\n         PUT   SYSPRINT,(0)            PRINT RECORD\n         B     PUT2                    LOOP UNTIL LAST RECORD RETURNED\nEOD2     CLOSE SYSPRINT                CLOSE OUTPUT FILE\n         FREEPOOL SYSPRINT             FREE BUFFERS\n         L     R13,4(,R13)             CALLER'S SAVE AREA\n         RETURN (14,12),RC=00\n***********************************************************************\nSYSIN    DCB   DSORG=PS,MACRF=GL,DDNAME=SYSIN,EODAD=EOD1\nSYSPRINT DCB   DSORG=PS,MACRF=PM,DDNAME=SYSPRINT,RECFM=FB,LRECL=32\nSAVEAREA DS    9D\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         END\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,15)\n//SYSUT2   DD UNIT=VIO,SPACE=(CYL,15)\n//SYSUT3   DD UNIT=VIO,SPACE=(CYL,15)\n//SYSGO    DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3120\n//SYSPRINT DD SYSOUT=*\n//*\n//GO      EXEC PGM=LOADER,PARM=NOPRINT\n//SYSLIN   DD DSN=*.ASMXF.SYSGO,DISP=(OLD,DELETE)\n//SORTWK01 DD UNIT=3380,SPACE=(CYL,1)\n//SYSOUT   DD SYSOUT=*\n//SYSPRINT DD SYSOUT=*\n//SYSIN    DD *\n555555555\n444444444444\n333333333333\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "EXECPGM": {"ttr": 1797, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x12\\x06\\x00\\x00\\x00\\x852o\\x01\\x06!\\x0f\\x11@\\x01u\\x01\\xac\\x00\\x97\\xc3\\xc2\\xe3\\xf4\\xf7\\xf2@@@@'", "ispf": {"version": "18.06", "flags": 0, "createdate": "1985-11-22T00:00:00", "modifydate": "2006-07-29T11:40:00", "lines": 373, "newlines": 428, "modlines": 151, "user": "CBT472"}, "text": "//GILBERTE JOB (ACCT#),EXECPGM,\n// NOTIFY=&SYSUID,\n// CLASS=A,MSGCLASS=X,COND=(0,NE)\n//*\n//ASMXF EXEC PGM=IFOX00,PARM=(OBJECT,NODECK,NOESD,NORLD,ALIGN,NOXREF)\n***********************************************************************\n*                                                                     *\n*        EXECPGM - COMMAND PROCESSOR TO INVOKE A COMPILER WITH        *\n*                  AN ALTERNATE DDN LIST - OS/VS2 VERSION             *\n*                                                                     *\n*        EXAMPLE:                                                     *\n*                                                                     *\n*          EXECPGM ASMA90      +                                      *\n*            PARM('NOOBJECT,NODECK,NOXREF,NORLD,ALIGN')       +       *\n*            STEPLIB(LINKLIST)     +                                  *\n*            SYSIN(TEMPWK2)        +                                  *\n*            SYSUT1(TEMPWK1)       +                                  *\n*            SYSLIB(#ASMLIB)       +                                  *\n*            SYSPRINT(ASMPRINT)                                       *\n*                                                                     *\n*1804 INVOKE THE DEBUGGING ROUTINE AS AN ESTAI                        *\n*1805 BUMP OWN USE COUNT IF DEBUGGING ROUTINE IS INVOKED              *\n*     TO PREVENT S0C1 WHEN PGM INVOKED VIA XCTL ABENDS                *\n*1806 OS/VS2                                                          *\n***********************************************************************\n         MACRO                                                    MACRO\n        @MVCL  &TO,&FROM,&DD                                      MACRO\n         TM    &FROM+6,X'80'           CHECK SUBPARAMETER         MACRO\n         BZ    $&SYSNDX+2              JUMP IF NOT SPECIFIED      MACRO\n         AIF   (T'&DD EQ 'O').MVC                                 MACRO\n         MVI   PARMDDNL+1,8*&DD        LENGTH OF DDN LIST         MACRO\n.MVC     LA    R14,&TO                 44-BYTE AREA               MACRO\n         LA    R15,L'&TO               GET LENGTH                 MACRO\n         ICM   R0,B'1111',&FROM        GET ADDRESS                MACRO\n         LH    R1,&FROM+4              ACTUAL LENGTH OF &MBR      MACRO\n         ICM   R1,B'1000',=CL8' '      PADDING                    MACRO\n$&SYSNDX MVCL  R14,R0                  MOVE DATA SET NAME         MACRO\n         MEND                                                     MACRO\n***********************************************************************\nEXECPGM  CSECT\n         SAVE  (14,12),,'GSF UTILITIES - EXECPGM 18.06'\n         LR    R12,R15\n         USING EXECPGM,R12\n         GETMAIN R,LV=DYNAML           GET DYNAMIC STORAGE\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LA    R14,72(,R1)             CLEAR WORKING STORAGE\n         LA    R15,DYNAML-72           CLEAR WORKING STORAGE\n         SR    R1,R1                   CLEAR WORKING STORAGE\n         MVCL  R14,R0                  CLEAR WORKING STORAGE\n         LM    R13,R1,8(R13)           SET R13, RELOAD R14-R1\n         USING DYNAM,R13\n         LR    R9,R1                   POINT AT CPPL.\n         USING CPPL,R9\n*\n*        SET UP RECOVERY ENVIRONMENT (OPTIONAL)\n*\n         WXTRN SYSDEBUG                OPTIONAL DEBUGGING ROUTINE\n         ICM   R15,B'1111',=A(SYSDEBUG)  DEBUGGING ROUTINE\n         BZ    PARSE000                NOT PRESENT, EXIT\n         BALR  R14,R15                 SET UP RECOVERY ENVIRONMENT\n         STM   R15,R0,ESTAIPRM         SAVE PARAMETERS FOR ATTACH\n         L     R1,540(,0)              PSATOLD (MY TCB)\n         L     R1,0(,R1)               TCBRBP (MY PRB)\n         L     R1,12(,R1)              RBCDE (MY CDE)\n         LOAD  EPLOC=8(,R1)            BUMP MY OWN USE COUNT\n***********************************************************************\n*                                                                     *\n*        BUILD PARSE PARM LIST, CALL IKJPARS                          *\n*                                                                     *\n***********************************************************************\nPARSE000 LA    R1,DYNPPL               POINT TO PPL\n         USING PPL,R1                  SET UP ADDRESSABILITY TO PPL\n         L     R0,CPPLUPT              USER PROFILE TABLE\n         ST    R0,PPLUPT               STORE UPT ADDRESS IN PPL\n         L     R0,CPPLECT              ENVIRONMENT CONTROL TABLE\n         ST    R0,PPLECT               STORE ECT IN PPL\n         LA    R0,DYNECB               EVENT CONTROL BLOCK\n         ST    R0,PPLECB               STORE ECB IN PPL\n         MVC   PPLPCL,=A(PCLCSECT)     STORE PCL ADDR INTO PPL\n         LA    R0,DYNANSWR             ANSWER AREA\n         ST    R0,PPLANS               STORE ANSWER ADDRESS IN PPL\n         L     R0,CPPLCBUF             COMMAND BUFFER\n         ST    R0,PPLCBUF              STORE BUFFER ADDRESS IN PPL\n         LA    R14,=C'IKJPARS '        NAME OF PARSE ROUTINE\n         L     R15,0016(0)             CVTPTR\n         L     R15,0008(,R15)          CVTLINK\n         STM   R14,R15,DWD             BUILD LINK PARMLIST\n         LINK  SF=(E,DWD)              CALL THE PARSE ROUTINE\n         LTR   R15,R15                 CHECK FOR ZERO PARSE RETURN\n         BNZ   ABEND33                 GO AWAY UPSET\n         DROP  R1                      WAS PPL\n***********************************************************************\n*                                                                     *\n*        PROCESS PARSED PARAMETERS                                    *\n*                                                                     *\n***********************************************************************\n         L     R8,DYNANSWR             LOAD PDL ADDRESS\n         USING IKJPARMD,R8             SET UP ADDRESSABILITY TO PDL\n         LA    R14,PARM256             256-BYTE AREA\n         LA    R2,PARMPCE2             FIRST SUB-LIST ITEM\n         TM    6(R2),X'80'             DO WE HAVE A PARM?\n         BZ    ENDPARM                 NO, JUMP\n*LOOP\nMAKEPARM LH    R15,4(,R2)              LENGTH OF SUB_ITEM\n         L     R0,0(,R2)               GET ADDRESS\n         LR    R1,R15                  PASS LENGTH\n         ICM   R1,B'1000',=CL8' '      PADDING\n         MVCL  R14,R0                  MOVE DATA SET NAME\n         MVI   0(R14),C','             ADD COMMA\n         LA    R14,1(,R14)             INCREMENT POINTER\n         ICM   R2,B'1111',8(R2)        IS THIS THE LAST OPERAND?\n         BP    MAKEPARM                NO, LOOP\n*ENDLOOP\n         BCTR  R14,0                   LAST COMMA\nENDPARM  LA    R0,PARM256              256-BYTE AREA\n         SR    R14,R0                  USED LENGTH\n         STH   R14,PARM256L            USED LENGTH\n*\n         MVC   DCBDDNAM,=CL8' '        BLANK OUT DDNAME\n*\n        @MVCL  PGMNM,PGMPCE            PROGRAM NAME\n        @MVCL  DCBDDNAM,LOADPCE2       STEPLIB DDNAME\n        @MVCL  PARMDD1,LINPCE2,1       SYSLIN\n        @MVCL  PARMDD2,MBRPCE2,2       MEMBER NAME\n        @MVCL  PARMDD3,MODPCE2,3       SYSLMOD\n        @MVCL  PARMDD4,LIBPCE2,4       SYSLIB\n        @MVCL  PARMDD5,INPCE2,5        SYSIN\n        @MVCL  PARMDD6,PRTPCE2,6       SYSPRINT\n        @MVCL  PARMDD7,PUNPCE2,7       SYSPUNCH\n        @MVCL  PARMDD8,UT1PCE2,8       SYSUT1\n        @MVCL  PARMDD9,UT2PCE2,9       SYSUT2\n        @MVCL  PARMDD10,UT3PCE2,10     SYSUT3\n        @MVCL  PARMDD11,UT4PCE2,11     SYSUT4\n        @MVCL  PARMDD12,TRMPCE2,12     SYSTERM\nPARSE999 IKJRLSA DYNANSWR              RELEASE PDL\n*\nATTACH   LA    R14,PARM256L            JCLPARM\n         LA    R15,PARMDDNL            DDN LIST\n         STM   R14,R15,PARMLIST        BUILD PARM\n         OI    PARMLIST+4,X'80'        END OF LIST (WITH DDN LIST)\n*\n         CLI   PARMDDNL+1,00           ANY ALTERNATE DDN?\n         BNE   ATTACH3                 YES, JUMP\n         OI    PARMLIST+0,X'80'        END OF LIST (NO DDN LIST)\n*\nATTACH3  CLI   DCBDDNAM,C' '           STEPLIB SPECIFIED?\n         BNH   XCTL1                   NO, SKIP OPEN\n*\n         L     R2,0016                 CVTPTR\n         L     R2,0008(,R2)            CVTLINK\n         CLC   =C'LINKLIST',DCBDDNAM   STEPLIB(LINKLIST)?\n         BE    ATTACH4L                YES, JUMP\n         CLC   =C'SYSTEM  ',DCBDDNAM   STEPLIB(SYSTEM)?\n         BE    ATTACH4L                YES, JUMP\n**       MVI   DCBDSORG,X'02'          DSORG=PO\n         MVI   DCBMACR1,X'D0'          MACRF=E\n         MVI   DCBMACR2,X'08'          MACRF=E\n         MVI   DCBOFLGS,X'02'          DCB FREE FOR USE\n         LA    R2,IHADCB               BUILD OPEN PARM LIST\n         ST    R2,OPENLIST             BUILD OPEN PARM LIST\n         MVI   OPENLIST,X'80'          BUILD OPEN PARM LIST\n         OPEN  MF=(E,OPENLIST)         OPEN TASKLIB\n*---------------------------------------------------------------------*\n*                                                                     *\n*        ATTACH THE PROGRAM                                           *\n*                                                                     *\n*---------------------------------------------------------------------*\nATTACH4L LA    R1,PARMLIST             MOD PARM ADDRESS\n         LM    R3,R4,ESTAIPRM          ESTAI ADDR, PARM\n         LTR   R3,R3                   ESTAI=0 ?\n         BZ    ATTACH4I                YES, JUMP\n         ATTACH EPLOC=PGMNM,                                           X\n               TASKLIB=(R2),                                           X\n               ESTAI=((R3),(R4)),      DEBUGGING ROUTINE               X\n               ECB=ECB1,                                               X\n               SF=(E,ATTACHL)\n         B     ATTACH4S\nATTACH4I ATTACH EPLOC=PGMNM,                                           X\n               TASKLIB=(R2),                                           X\n               ECB=ECB1,                                               X\n               SF=(E,ATTACHL)\nATTACH4S ST    R1,ECB1+4               SAVE TCB ADDRESS\n         WAIT  1,ECB=ECB1              WAIT FOR COMPLETION\n         DETACH ECB1+4                 DETACH SUBTASK\n         TM    DCBOFLGS,X'10'          DCB OPEN?\n         BZ    GOBACK                  NO, JUMP\n         CLOSE MF=(E,OPENLIST)         CLOSE TASKLIB\n*\nGOBACK   LR    R1,R13\n         LH    R2,ECB1+2               PICK UP RETURN CODE\n         L     R13,4(,R13)\n         FREEMAIN RU,LV=DYNAML,A=(R1),SP=0\n         LR    R15,R2                  PASS RETURN CODE\n         RETURN (14,12),RC=(15)\nABEND33  ABEND 33                      IKJPARS FAILED\n*\n*---------------------------------------------------------------------*\n*        INVOKE PROGRAM VIA XCTL IF NO TASKLIB SPECIFIED              *\n*---------------------------------------------------------------------*\n*\nXCTL1    LA    R15,DWD                 XCTL SF=L\n         LA    R1,PARMLIST             MOD PARM ADDRESS\n         LA    R2,PGMNM                POINT TO PROGRAM NAME\n         SR    R3,R3                   NO DCB\n         STM   R2,R3,0(R15)            XCTL SF=L\n         L     R13,4(,R13)             CALLER'S SAVE AREA\n         XCTL  (2,12),SF=(E,(15))      PASS CONTROL TO SPECIFIED PGM\n*\n*---------------------------------------------------------------------*\n*        DEFINE INPUT PARAMETERS FOR IKJPARS                          *\n*---------------------------------------------------------------------*\n*\nPCLCSECT IKJPARM\nPGMPCE   IKJPOSIT DSNAME,PROMPT='PROGRAM NAME'\nPARMPCE  IKJKEYWD\n         IKJNAME 'PARM',SUBFLD=PARMSUBF\nLOADPCE  IKJKEYWD\n         IKJNAME 'STEPLIB',SUBFLD=LOADSUBF,ALIAS=('TASKLIB')\nLINPCE   IKJKEYWD\n         IKJNAME 'SYSLIN',SUBFLD=LINSUBF\nMBRPCE   IKJKEYWD\n         IKJNAME 'MEMBER',SUBFLD=MBRSUBF,ALIAS=('MBR')\nMODPCE   IKJKEYWD\n         IKJNAME 'SYSLMOD',SUBFLD=MODSUBF\nLIBPCE   IKJKEYWD\n         IKJNAME 'SYSLIB',SUBFLD=LIBSUBF\nINPCE    IKJKEYWD\n         IKJNAME 'SYSIN',SUBFLD=INSUBF\nPRTPCE   IKJKEYWD\n         IKJNAME 'SYSPRINT',SUBFLD=PRTSUBF\nPUNPCE   IKJKEYWD\n         IKJNAME 'SYSPUNCH',SUBFLD=PUNSUBF\nUT1PCE   IKJKEYWD\n         IKJNAME 'SYSUT1',SUBFLD=UT1SUBF\nUT2PCE   IKJKEYWD\n         IKJNAME 'SYSUT2',SUBFLD=UT2SUBF\nUT3PCE   IKJKEYWD\n         IKJNAME 'SYSUT3',SUBFLD=UT3SUBF\nUT4PCE   IKJKEYWD\n         IKJNAME 'SYSUT4',SUBFLD=UT4SUBF\nTRMPCE   IKJKEYWD\n         IKJNAME 'SYSTERM',SUBFLD=TRMSUBF\n*\nPARMSUBF IKJSUBF\nPARMPCE2 IKJIDENT 'PARM',CHAR,LIST\nLOADSUBF IKJSUBF\nLOADPCE2 IKJIDENT 'STEPLIB',MAXLNTH=8,FIRST=ALPHA,OTHER=ALPHANUM\nLINSUBF  IKJSUBF\nLINPCE2  IKJIDENT 'SYSLIN',MAXLNTH=8,FIRST=ALPHA,OTHER=ALPHANUM\nMBRSUBF  IKJSUBF\nMBRPCE2  IKJIDENT 'MEMBER',MAXLNTH=8,FIRST=ALPHA,OTHER=ALPHANUM\nMODSUBF  IKJSUBF\nMODPCE2  IKJIDENT 'SYSLMOD',MAXLNTH=8,FIRST=ALPHA,OTHER=ALPHANUM\nLIBSUBF  IKJSUBF\nLIBPCE2  IKJIDENT 'SYSLIB',MAXLNTH=8,FIRST=ALPHA,OTHER=ALPHANUM\nINSUBF   IKJSUBF\nINPCE2   IKJIDENT 'SYSIN',MAXLNTH=8,FIRST=ALPHA,OTHER=ALPHANUM\nPRTSUBF  IKJSUBF\nPRTPCE2  IKJIDENT 'SYSPRINT',MAXLNTH=8,FIRST=ALPHA,OTHER=ALPHANUM\nPUNSUBF  IKJSUBF\nPUNPCE2  IKJIDENT 'SYSPUNCH',MAXLNTH=8,FIRST=ALPHA,OTHER=ALPHANUM\nUT1SUBF  IKJSUBF\nUT1PCE2  IKJIDENT 'SYSUT1',MAXLNTH=8,FIRST=ALPHA,OTHER=ALPHANUM\nUT2SUBF  IKJSUBF\nUT2PCE2  IKJIDENT 'SYSUT2',MAXLNTH=8,FIRST=ALPHA,OTHER=ALPHANUM\nUT3SUBF  IKJSUBF\nUT3PCE2  IKJIDENT 'SYSUT3',MAXLNTH=8,FIRST=ALPHA,OTHER=ALPHANUM\nUT4SUBF  IKJSUBF\nUT4PCE2  IKJIDENT 'SYSUT4',MAXLNTH=8,FIRST=ALPHA,OTHER=ALPHANUM\nTRMSUBF  IKJSUBF\nTRMPCE2  IKJIDENT 'SYSTERM',MAXLNTH=8,FIRST=ALPHA,OTHER=ALPHANUM\n         IKJENDP\n***********************************************************************\n*                                                                     *\n*        DYNAMIC STORAGE AREA                                         *\n*                                                                     *\n***********************************************************************\nDYNAM    DSECT\n         DS    18F                     SAVE AREA\nDWD      DS    D                       WORK AREA\nDYNECB   DS    F                       ECB FOR IKJPARS\nDYNANSWR DS    F                       WORKA FOR IKJPARS\nDYNPPL   DS    8F                      PPL FOR IKJPARS\nESTAIPRM DS    A(R15,R0)               DEBUGGING ROUTINE PARAMETERS\n*\n*---------------------------------------------------------------------*\n*        PARAMETER LIST AND DDNAME LIST                               *\n*---------------------------------------------------------------------*\n*\nPARMLIST DS    A(PARM256L,PARMDDNL)\nPGMNM    DS    C'ASMA90  '             NAME OF PROGRAM TO BE INVOKED\nECB1     DS    F,A                     ATTACH ECB, TCB ADDR\nPARM256L DS    Y(L'PARM256)            LENGTH OF PARM\nPARM256  DS    CL256                   PARM\n         CNOP  6,8\nPARMDDNL DS    Y(8*12)                 LENGTH OF PARM LIST\nPARMDD1  DS    C'SYSLIN  '         #1  SYSLIN\nPARMDD2  DS    C'TEMPNAME'         #2  MEMBER NAME (LKED)\nPARMDD3  DS    C'SYSLMOD '         #3  SYSLMOD     (LKED)\nPARMDD4  DS    C'SYSLIB  '         #4  SYSLIB\nPARMDD5  DS    C'SYSIN   '         #5  SYSIN\nPARMDD6  DS    C'SYSPRINT'         #6  SYSPRINT (OR SYSLOUT)\nPARMDD7  DS    C'SYSPUNCH'         #7  SYSPUNCH\nPARMDD8  DS    C'SYSUT1  '         #8  SYSUT1\nPARMDD9  DS    C'SYSUT2  '         #9  SYSUT2\nPARMDD10 DS    C'SYSUT3  '         #10 SYSUT3\nPARMDD11 DS    C'SYSUT4  '         #11 SYSUT4\nPARMDD12 DS    C'SYSTERM '         #12 SYSTERM\nDDNAME13 DS    C'SYSUT5  '         +96 SYSUT5\nDDNAME14 DS    C'SYSUT6  '        +104 SYSUT6    SYSCIN\nDDNAME15 DS    C'SYSUT7  '        +112 SYSUT7\nDDNAME16 DS    C'DBRMLIB '        +120 DBRMLIB\n*\n*---------------------------------------------------------------------*\n*        TASKLIB DCB AND ITS OPEN LIST                                *\n*---------------------------------------------------------------------*\n*\nOPENLIST OPEN  IHADCB,MF=L\nIHADCB   DS    13F                     MINI EXCP DCB\nDCBDDNAM EQU   IHADCB+40,8             DDNAME\nDCBOFLGS EQU   IHADCB+48,1             OPEN FLAGS\nDCBMACR1 EQU   IHADCB+50,1             MACRF=E\nDCBMACR2 EQU   IHADCB+51,1             MACRF=E\nATTACHL  ATTACH SF=L\nDYNAML   EQU   *-DYNAM\n         IKJPPL                        PARSE PARAMETER LIST\n         IKJCPPL                       COMMAND PROCESSOR PARM LIST\n*        YREGS                         REGISTER EQUATES\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         END   EXECPGM\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,15)\n//SYSUT2   DD UNIT=VIO,SPACE=(CYL,15)\n//SYSUT3   DD UNIT=VIO,SPACE=(CYL,15)\n//SYSGO    DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3120\n//SYSPRINT DD SYSOUT=*\n//*\n//LKED    EXEC PGM=IEWL,PARM='MAP,RENT'\n//SYSLIN   DD DSN=*.ASMXF.SYSGO,DISP=(OLD,PASS)\n//SYSLMOD  DD UNIT=VIO,SPACE=(1,(1,,1)),DSN=&&LOADMOD(EXECPGM),\n//  DISP=(,PASS)\n//SYSPRINT DD SYSOUT=*\n//*\n//GO      EXEC PGM=IKJEFT01\n//STEPLIB  DD DSN=&&LOADMOD(EXECPGM),DISP=(OLD,PASS)\n//         DD DSN=GSFSOFT.PRISM-CS.LOAD,DISP=SHR\n//SYSTSPRT DD SYSOUT=*\n//SYSTSIN  DD *\nEXECPGM PDSUTIL PARM(RESET,OUTDD=TEMPDD,DCBS)\n//SYSPRINT DD SYSOUT=*\n//TEMPDD   DD UNIT=VIO,SPACE=(1,(1,,1)),RECFM=U,BLKSIZE=300\n//SYSUDUMP DD SYSOUT=*\n//*\n//LKED    EXEC PGM=IEWL,PARM='MAP,RENT'\n//SYSLIN   DD DSN=*.ASMXF.SYSGO,DISP=(OLD,PASS)\n//SYSLMOD  DD DSN=GSFSOFT.PRISM-CS.LOAD(EXECPGM),DISP=SHR\n//SYSPRINT DD SYSOUT=*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "FILLDASD": {"ttr": 2049, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x02\\x00\\x00\\x00\\x88\\x08\\x7f\\x01\\x06!\\x0f\\x133\\x00\\xf3\\x000\\x00U\\xc3\\xc2\\xe3\\xf4\\xf7\\xf2@@@@'", "ispf": {"version": "02.02", "flags": 0, "createdate": "1988-03-27T00:00:00", "modifydate": "2006-07-29T13:33:00", "lines": 243, "newlines": 48, "modlines": 85, "user": "CBT472"}, "text": "//GILBERTF JOB (ACCT#),FILLDASD,\n// NOTIFY=&SYSUID,\n// CLASS=A,MSGCLASS=X,COND=(0,NE)\n//ASMXF EXEC PGM=IFOX00,PARM=(OBJECT,NODECK,NOESD,NORLD,ALIGN,NOXREF)\n***********************************************************************\n*                                                                     *\n* MODULE NAME = FILLDASD                                              *\n*                                                                     *\n* DESCRIPTIVE NAME = Fill free DASD space with binary zeroes (OS/VS2) *\n*                                                                     *\n* STATUS = R202                                                       *\n*                                                                     *\n* FUNCTION = This assembler program fills the free space that exists  *\n*            on DASD volumes with binary zeroes.                      *\n*            FILLDASD uses DYNALLOC to allocate temporary data sets   *\n*            and fills the tracks with binary zeroes.                 *\n*            If a volume serial is specified in the PARM, then only   *\n*            the free space of the specified volume is cleared.       *\n*            Otherwise, FILLDASD tries to allocate space on all the   *\n*            available volumes (i.e. PUBLIC, STORAGE, or SMS-managed).*\n*                                                                     *\n* AUTHOR = Gilbert Saint-Flour <carlos@gsf-soft.com>                  *\n*                                                                     *\n* NOTES = SEE BELOW                                                   *\n*                                                                     *\n*    DEPENDENCIES = STRINGXF macro                                    *\n*                                                                     *\n*    AUTHORIZATION = NONE                                             *\n*                                                                     *\n*    RESTRICTIONS = NONE                                              *\n*                                                                     *\n* MODULE TYPE = PROCEDURE, (CSECT TYPE)                               *\n*                                                                     *\n*    PROCESSOR = IBM Assembler XF                                     *\n*                                                                     *\n*    MODULE SIZE = 2K                                                 *\n*                                                                     *\n*    ATTRIBUTES = NOREUS, PROBLEM STATE, KEY 8                        *\n*                                                                     *\n* OPERATION = See Examples below:                                     *\n*                                                                     *\n*   Clear free space on TEMP01                                        *\n*                                                                     *\n*     //FILLDASD EXEC PGM=FILLDASD,PARM=TEMP01                        *\n*     //SYSPRINT DD SYSOUT=*                                          *\n*                                                                     *\n*   Clear free space on all available packs:                          *\n*                                                                     *\n*     //FILLDASD EXEC PGM=FILLDASD                                    *\n*     //SYSPRINT DD SYSOUT=*                                          *\n*                                                                     *\n* PARAMETERS = None                                                   *\n*                                                                     *\n* RETURN-CODES = SEE BELOW                                            *\n*                                                                     *\n*        0       OK                                                   *\n*        8       OPEN or CLOSE failed                                 *\n*                                                                     *\n* CHANGE LOG = SEE BELOW                                              *\n*                                                                     *\n*201 SYNAD                                                            *\n*202 OS/VS2                                                           *\n***********************************************************************\nFILLDASD CSECT\n         DC    C'GSF Utilities - FILLDASD R202 ',0H'0'\nBEGIN    LR    R12,R15                 BASE REG\n         USING BEGIN,R12\n         L     R2,0(,R1)               A(JCLPARM)\n*\n*        Retrieve optional volume serial from the parm\n*\n         LH    R3,0(,R2)               L'JCLPARM\n         LTR   R3,R3                   VOLSER SPECIFIED IN THE PARM?\n         BZ    OPENPRT                 NO, JUMP\n         STRING (2(R2),(R3)),INTO=VOLSER SAVE VOLUME SERIAL\n         MVC   RTVOL,=AL2(DALVLSER)    VOLUME SERIAL IS KNOWN\n*\n*        Print title line\n*\nOPENPRT  OPEN  (SYSPRINT,OUTPUT)\n         LTR   R15,R15                 OPEN OK?\n         BNZ   EOJ                     NO, EXIT\n         TIME  DEC                     GET DATE & TIME\n         STM   R0,R1,TIMEDATE          SAVE TIME AND DATE\n         STRING '1GSF Utilities - FILLDASD R200 - PARM=''',            X\n               (2(R2),(R3)),''' ',(TIMEDATE+4,P,YYYY-MM-DD),           X\n               1X,(TIMEDATE+0,1,X),'.',(TIMEDATE+1,1,X),INTO=PRTLINE\n         PUT   SYSPRINT,PRTLINE        WRITE TITLE LINE\n*\n*        Set up DYNALLOC request block\n*\n         LA    R8,S99RB1               DYNALLOC REQUEST BLOCK\n         USING S99RB,R8\n         MVI   S99RBLN,S99RBEND-S99RB  LENGTH\n         MVI   S99VERB,S99VRBAL        ALLOCATE\n         LA    R0,=A(WKUNIT,TRK,PRIME,RTVOL,RTDDN,CONTIG+VL)\n         ST    R0,S99TXTPP             TEXT UNIT POINTERS\n*---------------------------------------------------------------------*\n*        Main Loop: Allocate temporary DASD data sets                 *\n*        and fill them up with X'00'                                  *\n*---------------------------------------------------------------------*\n*LOOP\nALLOC    LA    R1,=A(S99RB1+VL)        S99RBPTR\n         DYNALLOC\n         LTR   R15,R15                 dynalloc ok?\n         BNZ   HALVE                   no, try smaller size\n         MVC   DCBDISK+40(8),DDNAME    MOVE DDNAME INTO DCB\n         OPEN  (DCBDISK,OUTPUT)        OPEN TEMP DATA SET\n         LTR   R15,R15                 OPEN OK?\n         BNZ   EOJ                     NO, EXIT\n         L     R1,DCBDISK+44           DEB\n         LH    R3,046(,R1)             # of tracks actually allocated\n         STRING 1X,%TIME,'ALLOCATED DDN=',DDNAME,                      X\n               ' VOL=',VOLSER,                                         X\n               ' TRACKS=',((R3),,L),                                   X\n               INTO=PRTLINE\n         PUT   SYSPRINT,PRTLINE        WRITE A PRINT LINE\n         LR    R0,R3                   TALLY TRACKS\n         AL    R0,TOTTRKS              TALLY TRACKS\n         ST    R0,TOTTRKS              TALLY TRACKS\n         ALR   R3,R3                   # OF BLOCKS\n         SLR   R0,R0\n         LH    R1,DCBDISK+62           BLKSIZE\n         LH    R2,DCBDISK+82           LRECL\n         DR    R0,R2                   RECORDS/BLOCK\n         MR    R2,R1                   # OF RECORDS\n*--LOOP\nPUTDISK  PUT   DCBDISK                 LOCATE A DISK RECORD\n         BCT   R3,PUTDISK              FILL UP THE TRACKS\n*--LOOP\n         CLOSE DCBDISK                 CLOSE DISK DCB\n         FREEPOOL DCBDISK              free buffer pool\n         B     ALLOC\nHALVE    SLR   R2,R2\n         ICM   R2,B'0111',PRIMEQTY     # OF TRACKS\n         SRL   R2,1                    HALVE\n         STCM  R2,B'0111',PRIMEQTY     # OF TRACKS\n         LTR   R2,R2                   ZERO?\n         BP    ALLOC                   NO, CONTINUE\n*ENDLOOP\n         STRING '0',%TIME,'TOTAL TRACKS WRITTEN: ',(TOTTRKS,F,L),      X\n               INTO=PRTLINE\n         PUT   SYSPRINT,PRTLINE        WRITE LAST PRINT LINE\n         CLOSE SYSPRINT                CLOSE PRINT DCB\nEOJ      SVC   3                       EOJ\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Error routine to trap hardware errors (EQC)                  *\n*                                                                     *\n*        //DD1 DD DSN=SYS1.VDATA33.CYL-01EF.TRK-000B,DISP=(,CATLG),   *\n*        //  DSORG=PSU,RECFM=F,BLKSIZE=80,                            *\n*        //  UNIT=3390,VOL=SER=DATA33,SPACE=(ABSTR,(1,7436))          *\n*                                                                     *\n*---------------------------------------------------------------------*\nSYNAD1   LR    R10,R14                 return address\n         SYNADAF ACSMETH=QSAM          get error message\n         LR    R2,R1                   addr of SYNAD message\n         STRING '0',%TIME,(50(R2),128-50),INTO=PRTLINE\n         PUT   SYSPRINT,PRTLINE        WRITE SYNAD MESSAGE\n**       STRING '0',%TIME,(DCBDISK+8,4,X),INTO=PRTLINE\n         LA    R0,8                    L'CCCCHHHH\n         LA    R1,111(,R2)             CCCCHHHH\n*LOOP\nSYNAD2   CLI   0(R1),C'F'              A-F ?\n         BH    SYNAD2N                 NO, ITERATE\n         IC    R14,0(,R1)              yes, X'C1' -> X'CA'\n         LA    R14,9(,R14)             yes, X'C1' -> X'CA'\n         STC   R14,0(,R1)              yes, X'C1' -> X'CA'\nSYNAD2N  LA    R1,1(,R1)               BUMP INDEX UP\n         BCT   R0,SYNAD2               ITERATE\n*ENDLOOP\n         PACK  DWD(3),111(5,R2)        CCCC..\n         LH    R4,DWD                  CCCC\n         MH    R4,=H'15'               cylinders -> tracks\n         PACK  DWD+2(3),111+4(5,R2)    HHHH..\n         AH    R4,DWD+2                add tracks\n         STRING '0',%TIME,'Bad track at CCHH=',(DWD,4,X),              X\n               ' VOL=SER=',VOLSER,',SPACE=(ABSTR,(1,',((R4),,L),'))',  X\n               INTO=PRTLINE\n         PUT   SYSPRINT,PRTLINE        WRITE CCHH\n         SYNADRLS                      free error message and save area\n         BR    R10                     goback to PUT macro\n*---------------------------------------------------------------------*\n*        CONSTANTS AND DATA                                           *\n*---------------------------------------------------------------------*\nWKUNIT   DC    AL2(DALUNIT,1,8),CL8'SYSALLDA'\nTRK      DC    AL2(DALTRK,0)\nPRIME    DC    AL2(DALPRIME,1,L'PRIMEQTY)\nPRIMEQTY DC    FL3'10000'\nRTVOL    DC    AL2(DALRTVOL,1,L'VOLSER)\nVOLSER   DC    C'123456'\nRTDDN    DC    AL2(DALRTDDN,1,L'DDNAME)\nDDNAME   DC    CL8' '\nCONTIG   DC    AL2(DALSPFRM,1,1),X'08'\nDWD      DS    D\nDCBDISK  DCB   DSORG=PS,MACRF=PL,DDNAME=*,RECFM=FB,LRECL=80,BUFNO=10,  X\n               SYNAD=SYNAD1\nSYSPRINT DCB   DSORG=PS,MACRF=PM,DDNAME=SYSPRINT,RECFM=FBA,LRECL=121\nS99RB1   DC    XL20'00'              XL(S99RBEND-S99RB)'00'\nTIMEDATE DS    2F                    TIME MACRO\nTOTTRKS  DS    F\nPRTLINE  DS    CL121\nVL       EQU   X'80000000'           END OF LIST\n         IEFZB4D0                    S99RB\n         IEFZB4D2                    KEY TABLE\n         STRING GENERATE\n*        YREGS\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         END   BEGIN\n//SYSPRINT DD SYSOUT=*\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//         DD DSN=GILBERT.FILE999.PDS,DISP=SHR       STRINGXF\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,15)\n//SYSUT2   DD UNIT=VIO,SPACE=(CYL,15)\n//SYSUT3   DD UNIT=VIO,SPACE=(CYL,15)\n//SYSGO    DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3120\n//*\n//*       clear free space on VOL=OS39M1\n//*\n//GO      EXEC PGM=LOADER,PARM='NOPRINT/OS39M1'\n//SYSLIN   DD DSN=*.ASMXF.SYSGO,DISP=(OLD,PASS)\n//SYSPRINT DD SYSOUT=*\n//*\n//*       clear free space on public and storage volumes\n//*\n//GO      EXEC PGM=LOADER,PARM='NOPRINT'\n//SYSLIN   DD DSN=*.ASMXF.SYSGO,DISP=(OLD,PASS)\n//SYSPRINT DD SYSOUT=*\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "GETDIR": {"ttr": 2054, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x82 \\x9f\\x01\\x06!\\x0f\\x13A\\x00\\x8c\\x00\\x04\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf7\\xf2@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1982-07-28T00:00:00", "modifydate": "2006-07-29T13:41:00", "lines": 140, "newlines": 4, "modlines": 0, "user": "CBT472"}, "text": "//GILBERTG JOB (ACCT#),GETDIR,\n// NOTIFY=&SYSUID,\n// CLASS=A,MSGCLASS=H,COND=(0,NE)\n//ASMXF EXEC PGM=IFOX00,PARM=(OBJECT,NODECK,NOESD,NORLD,ALIGN,NOXREF)\n*\n*    THE \"GETDIR\" MACRO ALLOWS YOU TO READ A PDS DIRECTORY\n*    SEQUENTIALLY, AS FOLLOWS:\n*\n*        IT WORKS IN \"LOCATE\" MODE; AFTER EACH INVOCATION, THE\n*        ADDRESS OF A DIRECTORY ENTRY (MEMBER NAME, TTR, ETC) IS\n*        RETURNED IN R1.\n*\n*        IT USES A BPAM DCB (DSORG=PO,MACRF=R), NOT A QSAM DCB\n*        (WHICH WOULD HAVE DSORG=PS).  THIS ALLOWS YOU TO READ THE\n*        DIRECTORY AND THE MEMBERS WITH THE SAME DCB.\n*\n*        R1 IS SET TO ZERO WHEN THE END OF THE DIRECTORY IS REACHED.\n*        THE \"EODAD\" KEY-WORD OF THE \"GETDIR\" MACRO MAY BE USED TO\n*        SPECIFY THE ADDRESS OF THE END-OF-DIRECTORY ROUTINE.\n*        THE EODAD KEY-WORD OF THE DCB IS ONLY USED AT END-OF-MEMBER.\n*\n*        THE \"GETDIR\" MACRO ONLY PROCESSES THE FIRST PDS IN A\n*        CONCATENATION, AND WILL NOT WORK WITH A PDSE.\n*\n         MACRO\n&NAME    GETDIR &DCB,&EODAD=\n         GBLB  &GETDIRB\n&NAME    IHBINNRA &DCB\n         L     R15,=A(@GETDIR)         ADDR OF \"GETDIR\" RTNE\n         BALR  R14,R15                 GET A DIRECTORY ENTRY\n         AIF   (T'&EODAD EQ 'O').GEN\n         LTR   R1,R1                   END OF DIRECTORY?\n         BZ    &EODAD                  YES, GO AWAY\n.GEN     AIF   (&GETDIRB).MEND\n&GETDIRB SETB  1\n.**********************************************************************\n.*\n.*       GETDIR SUB-ROUTINE\n.*\n.**********************************************************************\n@GETDIR  CSECT\n         SAVE  (14,12),,'GETDIR 840510'\n         BALR  R2,0\n         USING *,R2\n         LR    R3,R1                   ADRESSE DU DCB\n         ST    R13,@GETDSAV+4\n         LA    R13,@GETDSAV\n         LA    R5,X'000100'            TT=00, R=1, N=0\n         ICM   R1,B'1111',@GETDR1      CURRENT POS IN BUFFER\n         BZ    @GETD22                 PICK UP PARM LIST OFFSET\n         LA    R14,X'1F'               MASQUE POUR \"AND\"\n         IC    R0,11(,R1)              \"C\" BYTE\n         NR    R14,R0                  NOMBRE DE HALFWORDS\n         LA    R14,12(R14,R14)         LONGUEUR DU POSTE DANS R14\n         LH    R15,@GETDBUF            LONGUEUR UTILISEE\n         LA    R15,@GETDBUF-1(R15)     ADRESSE DERNIER OCTET UTILISE\n         BXLE  R1,R14,@GETD24\n         AL    R5,@GETDR5              INCREMENTER LE NUMERO D'ENREG\n@GETD22  ST    R5,@GETDR5              TTRN DU BLOC SUIVANT\n         POINT (R3),@GETDR5            POINTER SUR LE BON BLOC\n         LH    R4,62(,R3)              SAUVER DCBBLKSI\n         MVI   62(R3),1                BLKSIZE=256\n         MVI   63(R3),0                BLKSIZE=256\n         READ  @GETDECB,SF,(R3),@GETDBUF,'S'\n         STH   R4,62(,R3)              RESTAURER DCBBLKSI\n         CHECK @GETDECB\n         LA    R1,@GETDBUF+2           1ER POSTE\n@GETD24  CLI   0(R1),X'FF'             FIN DE BLOC?\n         BNE   @GETD29                 NON, RENDRE L'ADRESSE\n         SLR   R1,R1                   FIN-DE-REPERTOIRE\n@GETD29  ST    R1,@GETDR1              GARDER L'ADRESSE\n         L     R13,4(,R13)\n         L     R14,12(,R13)            ADRESSE DE RETOUR\n         LM    R2,R12,28(R13)          R2-R3\n         BR    R14\n@GETDR1  DS    A(@GETDBUF+2)           POINTEUR COURANT DANS LE BUFFER\n@GETDR5  DS    F                       TTRN DU BLOC COURANT\n@GETDSAV DS    18F\n@GETDBUF DS    H,254X\n&SYSECT  CSECT\n.MEND    MEND\n**********************************************************************\n**********************************************************************\n********* TEST PROGRAM FOR THE 'GETDIR' MACRO ************************\n**********************************************************************\n**********************************************************************\nTESTPGM  START 0\n         BALR  R12,0\n         USING *,R12\n         OPEN  (SYSLIB,,SYSPRINT,OUTPUT)\n*LOOP\nGETD     GETDIR SYSLIB,EODAD=EOJ\n         MVC   WORK80(11),0(R1)         SAVE MEMBER NAME AND TTR\n         PUT   SYSPRINT,WORK80\n         FIND  SYSLIB,WORK80+8,C        FIND WITH TTR0\n         READ  DECB1,SF,SYSLIB,BUFF1    READ FIRST BLOCK\n         CHECK DECB1\n         L     R6,=A(BUFF1)\n         PUT   SYSPRINT,(R6)            WRITE FIRST LINE\n         B     GETD\n*ENDLOOP\nEOJ      SLR   R15,R15\n         SVC   3                        GOBACK\nSYSPRINT DCB   DSORG=PS,DDNAME=SYSPRINT,MACRF=PM,RECFM=FB,LRECL=80\nSYSLIB   DCB   DSORG=PO,DDNAME=SYSLIB,MACRF=R,EODAD=EOJ\nWORK80   DS    XL80\nBUFF1    CSECT\n         DS    32760X\n*        YREGS\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         END\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,15)\n//SYSUT2   DD UNIT=VIO,SPACE=(CYL,15)\n//SYSUT3   DD UNIT=VIO,SPACE=(CYL,15)\n//SYSGO    DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3120\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//SYSPRINT DD SYSOUT=*\n//*\n//GO      EXEC PGM=LOADER,PARM=NOPRINT\n//SYSLIN   DD DSN=*.ASMXF.SYSGO,DISP=(OLD,DELETE)\n//SYSLIB   DD DSN=SYS1.PROCLIB,DISP=SHR\n//SYSPRINT DD SYSOUT=*,OUTLIM=666\n//ABNLTERM DD SYSOUT=*\n//ABNLDUMP DD DUMMY\n//SYSUDUMP DD SYSOUT=*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GSFLKED": {"ttr": 2057, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x82\\x01\\x9f\\x01\\x06!\\x0f\\x11\\x18\\x00\\xa3\\x00%\\x00\\x1d\\xc3\\xc2\\xe3\\xf4\\xf7\\xf2@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1982-01-19T00:00:00", "modifydate": "2006-07-29T11:18:00", "lines": 163, "newlines": 37, "modlines": 29, "user": "CBT472"}, "text": "//GILBERTL JOB (ACCT#),GSFLKED,\n// NOTIFY=&SYSUID,\n// CLASS=A,MSGCLASS=X,COND=(0,NE)\n//ASMXF EXEC PGM=IFOX00,PARM=(OBJECT,NODECK,NOESD,NORLD,ALIGN,NOXREF)\n***********************************************************************\n*                                                                     *\n*    THIS PROGRAM IS A FRONT-END TO THE LINKAGE-EDITOR WHICH          *\n*    PROVIDES THE FOLLOWING FACILITIES:                               *\n*                                                                     *\n*    1. IF THERE IS AN //INCLUDE DD THAT POINTS TO AN EXISTING        *\n*       PDS MEMBER, THEN THIS MEMBER IS APPENDED TO THE SYSLIN FILE.  *\n*                                                                     *\n*    2. IF THERE IS A //COMPRESS DD IN THE STEP AND THE LINK-EDIT     *\n*       ABENDS WITH SD37-04, THEN IEBCOPY IS INVOKED TO COMPRESS      *\n*       THE SYSLMOD DATA SET AFTER WHICH THE LINK-EDIT IS INVOKED     *\n*       AGAIN.  THE COMPRESS DD MUST CONTAIN THE IEBCOPY SYSIN,       *\n*       AS FOLLOWS:                                                   *\n*                                                                     *\n*            //COMPRESS DD *                                          *\n*              COPY I=SYSLMOD,O=SYSLMOD                               *\n*                                                                     *\n*    3. IF THERE IS AN //RC0 DD DUMMY CARD IN THE STEP'S JCL,         *\n*       THE RETURN CODE OF THE STEP WILL BE RESET TO ZERO.            *\n*                                                                     *\n***********************************************************************\nGSFLKED  CSECT\n         SAVE  (14,12),,'GSF UTILITIES - GSFLKED'\n         BALR  R12,0\n         USING *,R12\n         LR    R14,R13\n         LA    R13,=CL72'APPEL LINK-EDIT AVEC CODE RETOUR A ZERO'\n         ST    R14,4(,R13)\n         ST    R13,8(,R14)\n         ST    R1,@PARM\n*\n*        TEST FOR THE //INCLUDE DD CARD.\n*        IF PRESENT, TEST FOR AN EXISTING MEMBER.\n*          IF MEMBER EXISTS, APPEND IT TO SYSLIN DD\n*\n         RDJFCB MF=(E,OPLPO)             SI PRESENTE,\n         LTR   R15,R15                      CARTE DD 'INCLUDE'\n         BNZ   LINK0\n         OPEN  MF=(E,OPLPO)               CHERCHER SI LE\n         MVC   BLDLIST+4(8),EXL1+4+44      MEMBRE EST\n         BLDL  INPO,BLDLIST                 PRESENT\n         LR    R2,R15\n         CLOSE MF=(E,OPLPO)\n         LTR   R2,R2                       SI PRESENT,\n         BNZ   LINK0                      LIRE SON CONTENU\n         OPEN  MF=(E,OPLPS)                ET LE\nGETPS    GET   INCLUDE                      REECRIRE\n         PUTX  SYSLIN,INCLUDE                 SUR 'SYSLIN'\n         B     GETPS\nFINPS    CLOSE MF=(E,OPLPS)\n         FREEPOOL INCLUDE\n         FREEPOOL SYSLIN\n*\n*        INVOKE THE LINKAGE-EDITOR\n*\n*          1. AS A SUB-TASK IF //COMPRESS DD PRESENT\n*\n*          2. VIA \"LINK\" IF //COMPRESS DD  IS NOT PRESENT\n*\nLINK0    DEVTYPE =C'COMPRESS',16(,13)    COMPRESS PREVU ?\n         LTR   R15,R15                      SI NON,\n         BNZ   LINK8                       PAS DE 'ATTACH'\n         L     R1,@PARM                   EXEC DU LKED\n         ATTACH EP=IEWL,ECB=ECB1          COMME 'SUBTASK'\n         ST    R1,ECB1+4                    POUR PIEGER\n         WAIT  ECB=ECB1                     LES ABENDS\n         DETACH ECB1+4\n         L     R1,ECB1                   SI LE CODE-RETOUR\n         N     R1,=X'00FFF000'             EST ZERO,\n         BZ    RETURN                       RETURN\n         CL    R1,=X'00D37000'           SI ABEND\n         BNE   ABENDR1                    CODE 'SD37'\n*\n*        COMPRESS SYSLMOD PDS\n*\n         MVC   INPO+40(8),=C'SYSLMOD '     PROTECTION\n         RDJFCB MF=(E,OPLPO)                DU PDS\n         ENQ   MF=(E,@ENQL1)                 ET COMPRESS\n         LINK  EP=IEBCOPY,PARAM=(PARM0,COPYDD),VL=1\n         DEQ   MF=(E,@ENQL1)\n*\nLINK8    L     R1,@PARM\n         LINK  EP=IEWL                  EXECUTION DU LINK-EDIT\n         ST    R15,ECB1                 RETURN CODE\n*\nRETURN   DEVTYPE =CL8'RC0',16(,R13)\n         LTR   R15,R15                  '//RC0   DD DUMMY'\n         BNZ   RETURN2\n         XC    ECB1,ECB1                IF //RC0 PRESENT, RC=0\n*\nRETURN2  L     R15,ECB1                 RETURN CODE\n         L     R13,4(,R13)\n         RETURN (14,12),RC=(15)\nABENDR1  ABEND (1)\n*\n         PRINT NOGEN\nINPO     DCB   DSORG=PO,MACRF=E,DDNAME=INCLUDE,EXLST=EXL1\nINCLUDE  DCB   DSORG=PS,MACRF=GL,DDNAME=INCLUDE,EODAD=FINPS\nSYSLIN   DCB   DSORG=PS,MACRF=PM,DDNAME=SYSLIN,LRECL=80,RECFM=FB\nOPLPO    OPEN  MF=L,INPO\nOPLPS    OPEN  MF=L,(INCLUDE,,SYSLIN,EXTEND)\nEXL1     DC    A(X'87000004'+*),CL176' '\nBLDLIST  DC    Y(1,14),CL14' '\nPARM0    DC    Y(0)               PARM VIDE\nCOPYDD   DC    Y(8*11)\n         DC    XL8'00'            1   UNUSED\n         DC    XL8'00'            2   UNUSED\n         DC    XL8'00'            3   UNUSED\n         DC    XL8'00'            4   UNUSED\nCOPYDDK  DC    CL8'COMPRESS'      5   SYSIN\n         DC    XL8'00'            6   UNUSED\n         DC    XL8'00'            7   UNUSED\n         DC    XL8'00'            8   UNUSED\n         DC    XL8'00'            9   UNUSED\n         DC    CL8'SYSUT1  '     10   SYSUT3\n         DC    XL8'00'           11   UNUSED\nQLKED    DC    C'SYSIEWLP'\n@ENQL1   ENQ   (QLKED,EXL1+4,E,44,SYSTEMS, LKED / SHARED               X\n               QLKED,EXL1+4,E,44,SYSTEM), LKED / NON SHARED            X\n               MF=L\n@PARM    DS    A\nECB1     DS    2A\n*        YREGS\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         END\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,15)\n//SYSUT2   DD UNIT=VIO,SPACE=(CYL,15)\n//SYSUT3   DD UNIT=VIO,SPACE=(CYL,15)\n//SYSGO    DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3120\n//SYSPRINT DD SYSOUT=*\n//*\n//LKED    EXEC PGM=HEWL,PARM='MAP,REUS,AC=1'\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD DSN=*.ASMXF.SYSGO,DISP=(OLD,PASS)\n//SYSLMOD  DD DSN=GILBERT.LOAD2(GSFLKED),DISP=SHR\n//*\n//GO      EXEC PGM=GSFLKED,PARM=(LIST,XREF)\n//STEPLIB  DD DSN=GILBERT.LOAD2,DISP=SHR\n//SYSLIN   DD DSN=*.ASMXF.SYSGO,DISP=(OLD,DELETE)\n//SYSLMOD  DD DISP=(,PASS),UNIT=VIO,SPACE=(TRK,(1,,1))\n//SYSPRINT DD SYSOUT=*\n//COMPRESS DD *\n COPY INDD=SYSLMOD,OUTDD=SYSLMOD,LIST=NO\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "HANDBOOK": {"ttr": 2305, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01'\\x00\\x00\\x00\\x884\\x7f\\x01\\x06!\\x0f\\x11\\x12\\x01^\\x00,\\x01\\x1d\\xc3\\xc2\\xe3\\xf4\\xf7\\xf2@@@@\"", "ispf": {"version": "01.39", "flags": 0, "createdate": "1988-12-12T00:00:00", "modifydate": "2006-07-29T11:12:00", "lines": 350, "newlines": 44, "modlines": 285, "user": "CBT472"}, "text": "//GILBERTH JOB (ACCT#),HANDBOOK,                                 OS/VS2\n// NOTIFY=&SYSUID,\n// CLASS=A,MSGCLASS=X,COND=(0,NE)\n//*\n//*    THIS JOB ASSEMBLES MVS CONTROL BLOCK MACROS FROM\n//*    SYS1.MACLIB AND SYS1.AMODGEN AND STORES OUTPUT\n//*    LISTINGS INTO PDS MEMBERS FOR ON-LINE VIEWING.\n//*\n//CLEANUP EXEC PGM=IEFBR14\n//SYSPRINT DD DSN=GILBERT.HANDBOOK.OSVS2,\n// DISP=(MOD,DELETE),UNIT=SYSALLDA,SPACE=(TRK,0)\n//*\n//ALLOCATE EXEC PGM=IEFBR14\n//SYSPRINT DD DSN=GILBERT.HANDBOOK.OSVS2,\n// DISP=(NEW,CATLG,DELETE),\n// UNIT=SYSALLDA,\n// SPACE=(TRK,(50,15,5),RLSE),\n// DCB=(RECFM=FBM,LRECL=121,BLKSIZE=12100)\n//SYSUT1   DD DSN=&&SYSUT1,DISP=(,PASS),UNIT=VIO,SPACE=(CYL,20)\n//SYSUT2   DD DSN=&&SYSUT2,DISP=(,PASS),UNIT=VIO,SPACE=(CYL,20)\n//SYSUT3   DD DSN=&&SYSUT3,DISP=(,PASS),UNIT=VIO,SPACE=(CYL,20)\n//*\n//ASMMAC PROC MBR=\n//TMP     EXEC PGM=IFOX00,REGION=5M,\n// PARM='NOESD,NORLD,NOOBJECT,NODECK,LINECOUNT(120),TERM'\n//SYSTSPRT DD SYSOUT=*\n//SYSTSIN  DD DUMMY\n//*\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//         DD DSN=SYS1.AMODGEN,DISP=SHR\n//SYSUT1   DD DSN=&&SYSUT1,DISP=(OLD,PASS)\n//SYSUT2   DD DSN=&&SYSUT2,DISP=(OLD,PASS)\n//SYSUT3   DD DSN=&&SYSUT3,DISP=(OLD,PASS)\n//SYSTERM  DD SYSOUT=*\n//*\n//SYSPRINT DD DSN=GILBERT.HANDBOOK.OSVS2(&MBR),DISP=OLD\n//        PEND\n//*\n//ACB    EXEC ASMMAC,MBR=ACB\n         IFGACB\n         END\n//ACEE   EXEC ASMMAC,MBR=ACEE\n         IHAACEE\n         END\n  //AMVT   EXEC ASMMAC,MBR=ASMVT\n           ILRASMVT\n           END\n//ASCB   EXEC ASMMAC,MBR=ASCB\n         IHAASCB DSECT=YES\n         END\n//ASVT   EXEC ASMMAC,MBR=ASVT\n         IHAASVT DSECT=YES\n         END\n  //ASSB   EXEC ASMMAC,MBR=ASSB\n           IHAASSB LIST=YES\n           END\n//ASXB   EXEC ASMMAC,MBR=ASXB\n         IHAASXB DSECT=YES\n         END\n  //ATTACH EXEC ASMMAC,MBR=ATTACH\n           IEZATTCH LIST=YES\n           END\n//BASEA  EXEC ASMMAC,MBR=BASEA\n         IEEBASEA\n         END\n//CDE    EXEC ASMMAC,MBR=CDE\n         IHACDE\n         END\n//CSCB   EXEC ASMMAC,MBR=CSCB\n         IEECHAIN\n         END\n  //CSD    EXEC ASMMAC,MBR=CSD\n           IHACSD DSECT=YES\n           END\n  //CTXT   EXEC ASMMAC,MBR=CTXT\n           IEZVX100 DSECT=YES\n           END\n//CVT    EXEC ASMMAC,MBR=CVT\n         CVT DSECT=YES,LIST=YES,PREFIX=YES\n         END\n//DCB    EXEC ASMMAC,MBR=DCB\n         DCBD  DSORG=PS\n         END\n//DCBDA  EXEC ASMMAC,MBR=DCBDA\n         DCBD  DSORG=DA\n         END\n//DCE    EXEC ASMMAC,MBR=DCE\n         IECDDCE\n         END\n//DECB   EXEC ASMMAC,MBR=DECB\n         IHADECB DSECT=YES\n         END\n//DSAB   EXEC ASMMAC,MBR=DSAB\n         IHADSAB\n         END\n//DSCB1  EXEC ASMMAC,MBR=DSCB1\n         IECSDSL1 1\n         END\n//DSCB4  EXEC ASMMAC,MBR=DSCB4\n         DS    44X'04'\n         IECSDSL1 4\n         END\n//DYNALL EXEC ASMMAC,MBR=DYNALLOC\n*STATUS      OLD=01   MOD=02    NEW=04    SHR=08\n*DISP    UNCATLG=01 CATLG=02 DELETE=04   KEEP=08\n*SPACE                ALX=02   MXIG=04 CONTIG=08\n*LABEL        NL=01    SL=02    NSL=04            SUL=0A\n*             BLP=10  LTM=21     AL=40    AUL=48\n         IEFZB4D0\n         IEFZB4D2\n         END\n//DEB    EXEC ASMMAC,MBR=DEB\n         IEZDEB LIST=YES\n         END\n//DVA    EXEC ASMMAC,MBR=DVA\n         IHADVA DSECT=YES\n         END\n//DVCT   EXEC ASMMAC,MBR=DVCT\n         IHADVCT DSECT=YES\n         END\n//ECT    EXEC ASMMAC,MBR=ECT\n         IKJECT\n         END\n//GDA    EXEC ASMMAC,MBR=GDA\n         IHAGDA\n         END\n//IOB    EXEC ASMMAC,MBR=IOB\n         IEZIOB DSECT=YES\n         END\n//IOCOM  EXEC ASMMAC,MBR=IOCOM\n         IECDIOCM\n         END\n//JCT    EXEC ASMMAC,MBR=JCT\nJCT      DSECT\n         IEFAJCTB\n         END\n//JCTX   EXEC ASMMAC,MBR=JCTX\nJCTX     DSECT\n         IEFJCTX\n         END\n//JESCT  EXEC ASMMAC,MBR=JESCT\n         IEFJESCT\n         END\n//JFCB   EXEC ASMMAC,MBR=JFCB\nJFCB     DSECT\n         IEFJFCBN LIST=YES\n         END\n//JMR    EXEC ASMMAC,MBR=JMR\n         IEFJMR\n         END\n  //JSAB   EXEC ASMMAC,MBR=JSAB\n           IAZJSAB LIST=YES\n           END\n//JSCB   EXEC ASMMAC,MBR=JSCB\n         IEZJSCB\n         END\n//JSCVT  EXEC ASMMAC,MBR=JSCVT\n         IEFJSCVT\n         END\n//LCCA   EXEC ASMMAC,MBR=LCCA\n         IHALCCA DSECT=YES\n         END\n//LCT    EXEC ASMMAC,MBR=LCT\n         IEFALLCT\n         END\n//LDA    EXEC ASMMAC,MBR=LDA\n         IHALDA\n         END\n//LLE    EXEC ASMMAC,MBR=LLE\n         IHALLE\n         END\n//LPDE   EXEC ASMMAC,MBR=LPDE\n         IHALPDE\n         END\n  //LWA    EXEC ASMMAC,MBR=LWA\n           IKJEFLWA\n           END\n//OCE    EXEC ASMMAC,MBR=OCE\n         IECDSECS\n         IECDSECT\n         END\n//ORE    EXEC ASMMAC,MBR=ORE\n         IHAORE DSECT=YES\n         END\n//OUCB   EXEC ASMMAC,MBR=OUCB\n         IRAOUCB DSECT=YES\n         END\n//OUXB   EXEC ASMMAC,MBR=OUXB\n         IHAOUXB DSECT=YES\n         IEZBITS\n         END\n  //PCCA   EXEC ASMMAC,MBR=PCCA\n           IHAPCCA DSECT=YES\n           END\n//PDS2   EXEC ASMMAC,MBR=PDS2\n         IHAPDS DSECT=YES,PDSBLDL=YES\n         END\n//PSA    EXEC ASMMAC,MBR=PSA\n         IHAPSA DSECT=YES\n         END\n//PSCB   EXEC ASMMAC,MBR=PSCB\n         IKJPSCB\n         END\n  //RAX    EXEC ASMMAC,MBR=RAX\n           IARRAX                 RSM ADDR SPC BLOCK EXTENSION\n           END\n  //RCE    EXEC ASMMAC,MBR=RCE\n           IARRCE                 RSM CONTROL AND ENUMERATION AREA\n           END\n//RCVT   EXEC ASMMAC,MBR=RCVT\n         ICHPRCVT               RACF CVT\n         END\n  //RD     EXEC ASMMAC,MBR=RD\n           IHARD                  REGION DESCRIPTOR\n           END\n  //RMCT   EXEC ASMMAC,MBR=RMCT\n           IRARMCT DSECT=YES      RESOURCE MANAGET CONTROL TABLE\n           END\n*/SAMB   EXEC ASMMAC,MBR=SAMB\n*        IGGSAMB DSECT=YES\n*        END\n//RB     EXEC ASMMAC,MBR=RB\n         IKJRB DSECT=YES\n         END\n  //RIB    EXEC ASMMAC,MBR=RIB\n           ISGRIB\n           END\n//RPL    EXEC ASMMAC,MBR=RPL\n         IFGRPL\n         IDARMRCD ,                RECORD MGMT ERROR CODES\n         END\n//SCA    EXEC ASMMAC,MBR=SCA\n         IHASCA\n         END\n//SCB    EXEC ASMMAC,MBR=SCB\n         IHASCB DSECT=YES\n         END\n  //SCCB   EXEC ASMMAC,MBR=SCCB\n           IHASCCB\n           END\n//SCT    EXEC ASMMAC,MBR=SCT\nSCT      DSECT\n         IEFASCTB\n         END\n  //SCTX   EXEC ASMMAC,MBR=SCTX\n           IEFSCTX DSECT=YES\n           END\n//SCVT   EXEC ASMMAC,MBR=SCVT\n         IHASCVT DSECT=YES,LIST=YES\n         END\n//SDWA   EXEC ASMMAC,MBR=SDWA\n         IHASDWA DSECT=YES\n         END\n//SIOT   EXEC ASMMAC,MBR=SIOT\nSIOT     DSECT\n         IEFASIOT\n         END\n  //SIOTX  EXEC ASMMAC,MBR=SIOTX\n           IEFSIOTX\n           END\n//SMCA   EXEC ASMMAC,MBR=SMCA\n         IEESMCA\n         END\n//SNAP   EXEC ASMMAC,MBR=SNAP\n         IHASNAP DSECT=YES\n         END\n//SPIE   EXEC ASMMAC,MBR=SPIE\n         IHASCA                 SPIE/ESPIE CONTROL AREA\n*        IHAPIE                 PROGRAM INTERRUPT ELEMENT\n*        IHAPICA                PROGRAM INTERRUPTION CONTROL AREA\n         END\n//SPQE   EXEC ASMMAC,MBR=SPQE\n         IHASPQE                SP Q ELEMENT\n*        IHAFBQE                FREE BLOCK\n*        IHASPQA                SP Q DESCRIPTOR\n*        IHADQE                 DESCRIPTOR Q ELEMENT\n*        IHAFQE                 FREE Q ELEMENT\n*        IHASPT                 CSA\n         END\n//SRB    EXEC ASMMAC,MBR=SRB\n         IHASRB\n         END\n//SSCT   EXEC ASMMAC,MBR=SSCT\n         IEFJSCVT\n         END\n//SSOB   EXEC ASMMAC,MBR=SSOB\n         IEFJSSOB (AL,SO)\n         END\n//SSIB   EXEC ASMMAC,MBR=SSIB\n         IEFJSSIB\n         END\n//SSVT   EXEC ASMMAC,MBR=SSVT\n         IEFJSSVT\n         END\n  //STCB   EXEC ASMMAC,MBR=STCB\n           IHASTCB LIST=YES\n           END\n  //SVT    EXEC ASMMAC,MBR=SVT\n           IHASVT LIST=YES\n           END\n  //SWB    EXEC ASMMAC,MBR=SWB\n           IEFSWB\n           END\n//TAXE   EXEC ASMMAC,MBR=TAXE\n         IKJTAXE\n         END\n//TCAS   EXEC ASMMAC,MBR=TCAS\n         IKTTCAST DSECT=YES\n         END\n//TCB    EXEC ASMMAC,MBR=TCB\n         IKJTCB DSECT=YES,LIST=YES\n         END\n//TCT    EXEC ASMMAC,MBR=TCT\n         IEFTCT\n         END\n//TIOT   EXEC ASMMAC,MBR=TIOT\nTIOT     DSECT\n         IEFTIOT1\n         END\n//TMPWA  EXEC ASMMAC,MBR=TMPWA\n         IKJTMPWA\n         END\n//TPC    EXEC ASMMAC,MBR=TPC\n         IEAVVTPC\n         END\n  //TQE    EXEC ASMMAC,MBR=TQE\n           IHATQE\n           END\n//TSB    EXEC ASMMAC,MBR=TSB\n         IKJTSB LIST=YES,EXT=YES\n         END\n  //TSVT   EXEC ASMMAC,MBR=TSVT\n           IKJTSVT\n           END\n//UCB    EXEC ASMMAC,MBR=UCB\n**       IEFUCBOB LIST=YES,PREFIX=YES,SSMD=YES\n         IEFUCBOB LIST=YES,PREFIX=YES\n         END\n//UCM    EXEC ASMMAC,MBR=UCM\n         IEECUCM DSECT=YES\n         END\n//UPT    EXEC ASMMAC,MBR=UPT\n         IKJUPT\n         END\n//WQE    EXEC ASMMAC,MBR=WQE\n         IHAWQE\n         END\n//XL     EXEC ASMMAC,MBR=XL\n         IHAXTLST\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "INITKSDS": {"ttr": 2311, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x06\\x00\\x00\\x00\\x83$?\\x01\\x06!\\x0f\\x124\\x02\\x88\\x00$\\x01\\x82\\xc3\\xc2\\xe3\\xf4\\xf7\\xf2@@@@'", "ispf": {"version": "02.06", "flags": 0, "createdate": "1983-08-31T00:00:00", "modifydate": "2006-07-29T12:34:00", "lines": 648, "newlines": 36, "modlines": 386, "user": "CBT472"}, "text": "//GILBERTI JOB (ACCT#),INITKSDS,\n// NOTIFY=&SYSUID,\n//*RESTART=GO,\n// CLASS=A,MSGCLASS=X,COND=(0,NE)\n//ASMXF EXEC PGM=IFOX00,PARM=(OBJECT,NODECK,NOESD,NORLD,ALIGN,NOXREF)\n***********************************************************************\n*                                                                     *\n* MODULE NAME = INITKSDS                                              *\n*                                                                     *\n* DESCRIPTIVE NAME = Initialize a KSDS                                *\n*                                                                     *\n* FUNCTION = INITKSDS switches an empty VSAM KSDS from \"create\" mode  *\n*            to \"update\" mode.  INITKSDS may be invoked as a TSO      *\n*            command, a batch program, or a subroutine.               *\n*                                                                     *\n* STATUS = R206                                                       *\n*                                                                     *\n* AUTHOR = Gilbert Saint-Flour <carlos@gsf-soft.com>                  *\n*                                                                     *\n* NOTES = SEE BELOW                                                   *\n*                                                                     *\n*    DEPENDENCIES = OS/VS2                                            *\n*                                                                     *\n*    AUTHORIZATION = NONE                                             *\n*                                                                     *\n*    RESTRICTIONS = NONE                                              *\n*                                                                     *\n* MODULE TYPE = PROCEDURE, (TSO Command Processor)                    *\n*                                                                     *\n*    PROCESSOR = IBM ASSEMBLER XF                                     *\n*                                                                     *\n*    MODULE SIZE = 4K                                                 *\n*                                                                     *\n*    ATTRIBUTES = REENTERABLE, PROBLEM STATE, KEY 8                   *\n*                                                                     *\n* OPERATION = See Below                                               *\n*                                                                     *\n*        A KSDS is in create mode from the time it is DEFINEd         *\n*        until a record is written into it.  If a program OPENs       *\n*        for input, I-O or with STRNO=2 a KSDS in create mode,        *\n*        OPEN fails with R15=8,ERROR=160.  \"Create\" mode is also      *\n*        called \"load\" mode.                                          *\n*                                                                     *\n*        To change its status from \"create\" mode to \"non-create\"      *\n*        mode, a KSDS must be OPEN'd for output, a record must be     *\n*        written into it, then it must be CLOSEd.  From that point    *\n*        on, the KSDS may be OPEN'd without restriction.              *\n*                                                                     *\n*        INITKSDS proceeds as follows:                                *\n*                                                                     *\n*        1. Dynamically ALLOCATE the data set with DISP=SHR           *\n*           (unless the OLD key-word is specified in which case       *\n*           DISP=OLD is used).                                        *\n*                                                                     *\n*        2. OPEN the data set for output (MACRF=OUT) and check        *\n*           that it really is a KSDS                                  *\n*                                                                     *\n*        3. check that the KSDS contains no records                   *\n*                                                                     *\n*        4. WRITE a dummy record                                      *\n*                                                                     *\n*        5. CLOSE the data set                                        *\n*                                                                     *\n*        6. OPEN the data set again for I-O with MACRF=(IN,OUT)       *\n*                                                                     *\n*        7. DELETE the dummy record                                   *\n*                                                                     *\n*        8. CLOSE the data set and FREE it up                         *\n*                                                                     *\n*        If the RESET option is specified, INITKSDS proceeds          *\n*        as follows:                                                  *\n*                                                                     *\n*        1. ALLOCATE the data set and OPENs it for I-O                *\n*                                                                     *\n*        2. DELETE all of the records, one by one                     *\n*           (this can take a while if the KSDS is big)                *\n*                                                                     *\n*        3. CLOSE the data set (which is now empty and in             *\n*           non-create mode).                                         *\n*                                                                     *\n* SYNTAX = See Below                                                  *\n*                                                                     *\n*        INITKSDS may be invoked as a TSO command using the           *\n*        following syntax:                                            *\n*                                                                     *\n*            INITKSDS 'data-set-name'                                 *\n*                      RESET/NORESET/ERASE/DELETE                     *\n*                      SHR/OLD                                        *\n*                                                                     *\n*            'data-set-name' is the data set name of the KSDS.        *\n*                                                                     *\n*            'NORESET' specifies that the KSDS has just been          *\n*            DEFINEd, contains no records, and must be converted to   *\n*            \"non-create\" mode by adding/deleting a dummy record.     *\n*            This is the default.                                     *\n*                                                                     *\n*            'RESET' specifies that the KSDS contains records and     *\n*            that these records should be deleted.  RESET can be      *\n*            used instead of DELETE/DEFINE/INITKSDS to create an      *\n*            empty KSDS in non-create mode.  ERASE or DELETE are      *\n*            equivalent to RESET.                                     *\n*                                                                     *\n*            'OLD' specifies that the data-set(s) should be           *\n*            allocated with DISP=OLD instead of SHR, which is the     *\n*            default.                                                 *\n*                                                                     *\n*        INITKSDS may be invoked as a batch program, using the        *\n*        following JCL:                                               *\n*                                                                     *\n*            //MYJOB   JOB (ACCT#),'JOHN DOE', . . .                  *\n*            //*                                                      *\n*            //INITKSDS EXEC PGM=INITKSDS                             *\n*            //INITKSDS  DD  DSN=my.new.vsam.ksds,DISP=SHR            *\n*                                                                     *\n*                                                                     *\n*        INITKSDS may be also be invoked from an assembler program,   *\n*        as follows:                                                  *\n*                                                                     *\n*                      LA    R1,MYACB                                 *\n*                      LINK  EP=INITKSDS                              *\n*            .  .  .  .  .  .  .  .  .  .                             *\n*            MYACB     ACB   DDNAME=MYDDNAME,MACRF=(IN, . .           *\n*                                                                     *\n*          If the VSAM data set is allocated with FREE=CLOSE,         *\n*          INITKSDS re-allocates it dynamically to initialize it.     *\n*                                                                     *\n* RETURN CODES                                                        *\n*                                                                     *\n*        RC=0     Successful Completion                               *\n*        RC=4     IKJPARS error                                       *\n*        RC=8     Data set is not a KSDS                              *\n*        RC=12    DYNALLOC error                                      *\n*                 OPEN error                                          *\n*                 Data set is not empty                               *\n*                 ERASE macro failed                                  *\n*        RC=16    invalid PARM field                                  *\n*                                                                     *\n* CHANGE ACTIVITY                                                     *\n*                                                                     *\n*   $102 INITKSDS may be invoked as a PGM with R1 pointing to an ACB  *\n*   $103 Use alternate DDname when the data set has FREE=CLOSE        *\n*   $104 Complete FREE=CLOSE enhancement, fix others errors.          *\n*   $105 RESET/NORESET can now be specified in the JCL PARM           *\n*   $206 OS/VS2 Version                                               *\n*                                                                     *\n***********************************************************************\nINITKSDS CSECT\n         SAVE  (14,12),,'GSF UTILITIES - INITKSDS R206'\n         LR    R12,R15                 BASE REGISTER\n         USING INITKSDS,R12\n***********************************************************************\n*        ALLOCATE DYNAMIC STORAGE AREA                                *\n***********************************************************************\n         GETMAIN R,LV=DYNAML           ACQUIRE DYNAMIC STORAGE\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LM    R13,R1,8(R13)\n         USING DYNAM,R13\n         LR    R11,R1                  POINT AT CPPL.\n         USING CPPL,R11\n         LA    R14,DYNAM+72            clear dynamic storage\n         LA    R15,DYNAML-72           clear dynamic storage\n         SLR   R1,R1                   clear dynamic storage\n         MVCL  R14,R0                  clear dynamic storage\n         MVC   IFGACB(MODACBLL),MODELACB\n         MVC   IFGRPL(MODLRPLL),MODELRPL\n         MVI   RESET,C'N'              DEFAULT IS 'NORESET'\n         TM    CPPL,X'80'              AM I INVOKED AS A PROGRAM?\n         BO    PGM00                   YES, JUMP\n***********************************************************************\n*        BUILD PARAMETER LIST FOR IKJEFF02                            *\n***********************************************************************\n         ST    R11,MTCPPLP             STORE CPPL ADDRESS IN MTPL\n         LA    R0,MTCSECTP             MESSAGE SECTION\n         ST    R0,MTPLPTR              STORE ADDR IN MTPL\n         LA    R0,DYNECB               EVENT CONTROL BLOCK\n         ST    R0,MTECBP               STORE ECB IN MTPL\n         L     R0,=A(MSGCSECT)         MESSAGE CSECT\n         ST    R0,MTCSECTP             STORE ECT IN PPL\n         OI    MTSW1,MTPUTLSW          PUTLINE IS NEEDED\n         OI    MTSW1,MTNHEXSW          XLATE TO DECIMAL\n***********************************************************************\n*        BUILD PARSE PARM LIST, CALL IKJPARS                          *\n***********************************************************************\nPARSE000 LA    R1,WORKAREA             POINT TO PPL\n         USING PPL,R1                  SET UP ADDRESSABILITY TO PPL\n         L     R0,CPPLUPT              USER PROFILE TABLE\n         ST    R0,PPLUPT               STORE UPT ADDRESS IN PPL\n         L     R0,CPPLECT              ENVIRONMENT CONTROL TABLE\n         ST    R0,PPLECT               STORE ECT IN PPL\n         LA    R0,DYNECB               EVENT CONTROL BLOCK\n         ST    R0,PPLECB               STORE ECB IN PPL\n         MVC   PPLPCL,=A(PCLCSECT)     STORE PCL ADDR INTO PPL\n         LA    R0,WORD1                ANSWER AREA\n         ST    R0,PPLANS               STORE ANSWER ADDRESS IN PPL\n         L     R0,CPPLCBUF             COMMAND BUFFER\n         ST    R0,PPLCBUF              STORE BUFFER ADDRESS IN PPL\n         L     R15,CVTPTR              CVTPTR\n         L     R15,CVTPARS-CVTMAP(,R15) address of IKJPARS\n         SYNCH (R15)                   call IKJPARS\n         LTR   R2,R15                  CHECK FOR ZERO PARSE RETURN\n         BNZ   FINISH                  GO AWAY UPSET\n         DROP  R1                      WAS PPL\n***********************************************************************\n*        PROCESS PARSED PARAMETERS                                    *\n***********************************************************************\n         MVI   PGMCMD,C'C'             MODE=CMD\n         L     R8,WORD1                LOAD PDL ADDRESS\n         USING IKJPARMD,R8             SET UP ADDRESSABILITY TO PDL\nPARSE100 LA    R14,DSNAME              44-BYTE AREA\n         LA    R15,L'DSNAME            GET LENGTH\n         L     R0,DSNPCE               GET ADDRESS\n         LH    R1,DSNPCE+4             ACTUAL LENGTH OF DSN\n         ICM   R1,B'1000',=C' '        PADDING\n         MVCL  R14,R0                  MOVE DATA SET NAME\nPARSE200 MVC   STATUS(8),=AL2(DALSTATS,1,1,X'0800') DISP=SHR KEY\n         CLI   STATPCE+1,2             CHECK FOR 2ND IKJPNAME\n         BNE   PARSE300                JUMP IF NOT THE 2ND\n         MVI   STATUS+6,X'01'          DISP=OLD KEY\nPARSE300 EQU   *\n         CLI   RSTPCE+1,2              CHECK FOR 2ND IKJPNAME\n         BNE   PARSE999                JUMP IF NOT THE 2ND\n         MVI   RESET,C'R'              2ND IS 'RESET'\n         MVI   STATUS+6,X'01'          DISP=OLD KEY\nPARSE999 IKJRLSA WORD1                 RELEASE PDL\n         B     ALLOC000                allocate and open\n***********************************************************************\n*        INITKSDS IS INVOKED AS A PROGRAM                             *\n***********************************************************************\nPGM00    MVI   PGMCMD,C'P'             MODE=PGM\n         CLC   ACBID,CPPL              R1 POINTS TO AN ACB?\n         BE    PGM50                   yes, jump\n*\n*        Check PARM when invoked in a JCL step\n*\n         L     R2,CPPL                 parm address\n         CLI   0(R2),0                 parm OK?\n         BNE   BADPARM                 no, error\n         CLI   1(R2),0                 PARM=''?\n         BE    PGM21                   yes, continue\n         CLI   1(R2),7                 PARM=NORESET?\n         BNE   PGM15                   no, jump\n         CLC   =C'NORESET',2(R2)       PARM=NORESET?\n         BE    PGM21                   no, jump\nPGM15    CLI   1(R2),5                 PARM=RESET?\n         BNE   BADPARM                 no, bad parm\n         CLC   =C'RESET',2(R2)         PARM=RESET?\n         BNE   BADPARM                 no, bad parm\n*\nPGM20    MVI   RESET,C'R'              PARM='RESET'\nPGM21    BAL   R14,GETDSN           <- retrieve dsname\n         B     OPEN                    continue\n***********************************************************************\n*        INITKSDS was invoked as a sub-routine with                   *\n*        the address of an ACB in R1                                  *\n*                                                                     *\n*        If the data set was allocated with FREE=CLOSE,               *\n*        reallocate it for our own processing.                        *\n***********************************************************************\nPGM50    MVC  ACBDDNM,ACBDDNM-IFGACB+CPPL MOVE DDNAME FROM CALLER'S ACB\n         BAL   R14,GETDSN           <- retrieve dsname\n         LTR   R15,R15                 DD missing?\n         BNZ   OPEN                    yes, fail\n         L     R1,DSAB1                addr of the DSAB\n         TM    DSABFLG2-DSAB(R1),DSABUNAL FREE=CLOSE?\n         BZ    OPEN                    no, jump\n***********************************************************************\n*        Allocate the VSAM data set                                   *\n***********************************************************************\nALLOC000 LA    R2,WORKAREA             S99RB\n         ST    R2,DFS99RBP             S99RBPTR\n         OI    DFS99RBP,X'80'          S99RBPND\n         LA    R0,=AL1(0,DFSVC99)      PUTLINE ONLY, SVC99\n         ST    R0,DFIDP                BUILD PARML FOR DAIRFAIL\n         ST    R11,DFCPPLP             ADDR OF CPPL\n*\n         LA    R0,DSNAME               RETURN CODE\n         ST    R0,MTINSRT              ADDRESS OF INSERT\n         MVI   MTLEN,L'DSNAME          LENGTH OF INSERT\n*\n         USING S99RB,R2\n         XC    S99RB(S99RBEND-S99RB),S99RB  CLEAR DYNALLOC WORK SPACE\n         MVI   S99RBLN,S99RBEND-S99RB  RB LENGTH\n         MVI   S99VERB,S99VRBAL        VERB IS \"ALLOCATE\"\n         LA    R0,S99RBEND             END OF RB, START OF T.U. PTRS\n         ST    R0,S99TXTPP             TEXT UNIT POINTERS\n*\n         OI    S99FLG11,S99NOCNV       DO NOT USE EXISTING DD\n         OI    S99FLG11,S99NOMNT       DO NOT MOUNT VOLUMES\n         LA    R14,TU55DDN             DDNAME TEXT UNIT\n         MVC   0(6,R14),=AL2(DALRTDDN,1,L'DDNAME) RETURN DDNAME KEY\n         LA    R15,TU02DSN             DSNAME TEXT UNIT\n         MVC   0(6,R15),=AL2(DALDSNAM,1,L'DSNAME) DSNAME KEY\n         LA    R0,STATUS               ADDRESS OF STATUS KEY\n         LA    R1,TU57ORG              RETURN DSORG\n         MVC   0(6,R1),=AL2(DALRTORG,1,L'DSORG)  DSORG\n         STM   R14,R1,S99RBEND+00      FIRST TO THIRD TEXT UNIT PTRS\n         OI    S99RBEND+12,X'80'       END OF LIST\n*\n         LA    R1,DFS99RBP             S99RBPTR\n         DYNALLOC ,                    ISSUE SVC 99 (ALLOCATE)\n         LTR   R15,R15\n         BNZ   MSG99                   ALLOCATION FAILED, EXIT\n         DROP  R2                      WAS S99RB\n         CLC   DSORG,=AL2(ACBDORGA)    DSORG=VS?\n         BNE   MSG99NVS                NOT A VSAM DATA SET\n         MVC   ACBDDNM,DDNAME          MOVE THE RETURNED DDNAME\n***********************************************************************\n*        OPEN THE VSAM DATA SET                                       *\n***********************************************************************\nOPEN     LA    R2,IFGACB               POINT TO ACB\n         ST    R2,OPENLIST             MAKE OPEN LIST\n         ST    R2,RPLDACB              SET UP RPL\n         MVI   OPENLIST,X'80'          FREE=CLOSE OPTION\n         OPEN  MF=(E,OPENLIST)         OPEN THE ACB\n         CH    R15,=H'4'               OPEN OK?\n         BH    MSGOPEN                 NO, QUIT\n*\n         TESTCB ACB=(R2),ATRB=KSDS,    IS THIS A KSDS?                 X\n               MF=(G,WORKAREA,TESTCBL)\n         BNE   MSG99NVS                NOT A VSAM DATA SET\n*\n         SHOWCB ACB=(R2),AREA=(S,MAXRECNO),LENGTH=08,                  X\n               FIELDS=(NLOGR,LRECL),MF=(G,WORKAREA,SHOWCBL)\n***********************************************************************\n*        PROCESS THE OPEN'D DATA SET                                  *\n***********************************************************************\n         L     R0,MAXLRECL             get lrecl\n         ST    R0,RPLRLEN              RECORD LENGTH\n         GETMAIN RU,LV=(0)             allocate record area\n         ST    R0,RPLBUFL              BUFFER LENGTH\n         ST    R1,RPLAREA              SET UP THE RPL\n         ST    R1,RPLARG               SET UP THE RPL\n         CLI   RESET,C'R'              OPTION RESET SPECIFIED?\n         BE    RESET00                 YES, JUMP\n***********************************************************************\n*        ADD/DELETE A DUMMY RECORD\n***********************************************************************\nADDDEL   ICM   R0,B'1111',MAXRECNO     DATA SET EMPTY?\n         BNZ   MSGFULL                 NO, ERROR\n         MVC   REQUEST,=C'PUT  '       SET REQUEST FOR MESSAGE\n         PUT   RPL=IFGRPL              ADD A DUMMY RECORD\n         LTR   R15,R15                 PUT OK?\n         BNZ   MSGREQ                  NO, QUIT\nADDDEL9  CLOSE MF=(E,OPENLIST)         CLOSE THE ACB\n         OPEN  MF=(E,OPENLIST)         RE-OPEN THE ACB\n         LTR   R15,R15                 OPEN OK?\n         BNZ   MSGOPEN                 NO, QUIT\n***********************************************************************\n*        PROCESS THE 'RESET' FUNCTION (DELETE ALL OF THE RECORDS      *\n***********************************************************************\n*LOOP\nRESET00  MVC   REQUEST,=C'GET  '       SET REQUEST FOR MESSAGE\n         OI    RPLOPT2,RPLUPD          OPTCD=UPD\n         GET   RPL=IFGRPL              READ THE FIRST RECORD\n         LTR   R15,R15                 GET OK?\n         BNZ   MSGREQ                  NO, QUIT\nRESET20  MVC   REQUEST,=C'ERASE'       SET REQUEST FOR MESSAGE\n         ERASE RPL=IFGRPL              DELETE THE FIRST RECORD\n         LTR   R15,R15                 ERASE OK?\n         BNZ   MSGREQ                  NO, QUIT\n         B     RESET00\n*ENDLOOP\n***********************************************************************\n*        ISSUE MESSAGES                                               *\n***********************************************************************\nMSG99    MVC   MTMSGID,=C'99  '        DYNALLOC ERROR\n         CLI   PGMCMD,C'P'             MODE=PGM ?\n         BE    ISSUEMSG                YES, DO NOT CALL DAIRFAIL\n         ST    R15,RETCODE             RETURN CODE\n         LA    R0,RETCODE              RETURN CODE\n         ST    R0,DFRCP                RETURN CODE\n         LA    R0,=A(0)                NO ADDR FOR IKJEFF02\n         ST    R0,DFJEFF02             RETURN CODE\n         LA    R1,DFPARMS              DAIRFAIL PARM LIST\n         LINK  EP=IKJEFF18             Call the DAIRFAIL routine\n         LA    R2,12                   RETURN-CODE\n         B     ISSUEMSG                ISSUE MESSAGE\n*\nMSG99NVS MVC   MTMSGID,=C'NVS '        NON-KSDS\n         LA    R2,8                    RETURN-CODE = 8\n         B     ISSUEMSG                ISSUE MESSAGE\n*\nMSGOPEN  MVC   MTMSGID,=C'OPEN'        \"OPEN FAILED\" MESSAGE\n         ST    R15,RETCODE             RETURN CODE\n*\n**       LA    R0,L'RETCODE            LENGTH OF INSERT           (2)\n**       ST    R0,MTLEN+08             LENGTH OF INSERT\n**       OI    MTHIGHL+08,X'80'        XLATE TO DECIMAL\n**       ST    R0,MTADDR+08            ADDRESS OF INSERT\n         LA    R0,RETCODE              RETURN CODE\n         ST    R0,MTINSRT+04           ADDRESS OF INSERT\n         OI    MTHIGHL+04,X'80'        XLATE TO DECIMAL\n         LA    R2,12                   RETURN-CODE\n         B     ISSUEMSG                ISSUE MESSAGE\n*\nMSGFULL  MVC   MTMSGID,=C'FULL'        NON-EMPTY\n         LA    R2,12                   RETURN-CODE\n         B     ISSUEMSG                ISSUE MESSAGE\n*\nMSGREQ   MVC   MTMSGID,=C'REQ '        \"ERASE FAILED\" MESSAGE\n         ST    R15,RETCODE             RETURN CODE\n*\n         LA    R0,REQUEST              RETURN CODE                (1)\n         ST    R0,MTINSRT+00           ADDRESS OF INSERT\n         MVI   MTLEN+00,L'REQUEST      LENGTH OF INSERT\n*\n         LA    R0,DSNAME               DSNAME                     (2)\n         ST    R0,MTINSRT+04           ADDRESS OF INSERT\n         MVI   MTLEN+00,L'DSNAME       LENGTH OF INSERT\n*\n         LA    R0,RPLFDBK              RETURN CODE                (3)\n         ST    R0,MTINSRT+08           ADDRESS OF INSERT\n         OI    MTHIGHL+08,X'80'        XLATE NUMERIC\n         OI    MTSW1,MTHEXSW           XLATE TO HEX\n         LA    R2,12                   RETURN-CODE\n         B     ISSUEMSG                ISSUE MESSAGE\n***********************************************************************\n*        End-of-file on VSAM data set                                 *\n***********************************************************************\nCLOSE    LTR   R15,R15                 CLOSE OK?\n***      BNZ   MSGCLOS                 NO, QUIT\n         MVC   MTMSGID,=C'00  '        INITKSDS SUCCESSFUL\n         LA    R2,0                    RC=0\n*\nISSUEMSG CLI   PGMCMD,C'P'             MODE=PGM ?\n         BE    FINISH                  YES, IGNORE MESSAGE\n         L     R15,CVTPTR              ADDR OF CVT\n         L     R15,CVTEFF02-CVTMAP(,R15) ADDR OF IKJEFF02\n         LA    R1,MTPARML              POINT TO PPL\n         SYNCH (R15)                   CALL THE MESSAGE ISSUER\n         B     FINISH                  GO AWAY UPSET\n***********************************************************************\n*        CLOSE THE ACB, CLEAN UP, RETURN.                             *\n***********************************************************************\nBADPARM  LA    R2,16                   RC=16: bad parm\n*\nFINISH   TM    ACBOFLGS,ACBOPEN        ACB OPEN?\n         BZ    FINISH2                 NO, JUMP\n         CLC   DSORG,=AL2(ACBDORGA)    DD allocated dynamically?\n         BNE   FINISH1                 NO, JUMP\n         OI    OPENLIST,X'20'          yes, FREE=CLOSE\nFINISH1  CLOSE MF=(E,OPENLIST)         CLOSE/FREE\nFINISH2  ICM   R1,B'1111',RPLAREA      buffer address\n         BZ    FINISH8                 NO, JUMP\n         L     R0,RPLBUFL              BUFFER LENGTH\n         FREEMAIN RU,LV=(0),A=(1)      FREE RECORD AREA\nFINISH8  LR    R1,R13                  ADDRESS OF DYNAMIC AREA\n         L     R13,4(,R13)             CALLER'S SAVE AREA\n         FREEMAIN RU,LV=DYNAML,A=(1)   FREE DYNAMIC STORAGE AREA\n         LR    R15,R2                  PASS RETURN CODE\n         RETURN (14,12),RC=(15)        GOBACK TO CALLER\n***********************************************************************\n*        Retrieve dsname from the JFCB                                *\n***********************************************************************\nGETDSN   EQU   *\n         L     R2,540(,0)              PSATOLD\n         USING TCB,R2                  PSATOLD\n         L     R2,TCBJSCB              current JSCB\n         USING IEZJSCB,R2\n         L     R2,JSCDSABQ             DSAB QDB\n         USING DSABQDB,R2\n         ICM   R2,B'1111',DSQFRSTP     FIRST DSAB ON CHAIN\n         BZ    GETDSN2X                empty, quit\n         USING DSAB,R2\n*loop\nGETDSN2  L     R1,DSABTIOT             TIOT entry\n         USING TIOENTRY,R1\n         CLC   TIOEDDNM,ACBDDNM        SAME DDNAME?\n         BE    GETDSN3                 yes, leave\n         ICM   R4,B'1111',DSABFCHN     NEXT DSAB\n         BNZ   GETDSN2                 NOT YET, LOOP THROUGH TIOT\n*ENDLOOP\nGETDSN2X LA    R15,8                   DDNAME NOT FOUND\n         BR    R14\n*\nGETDSN3  ICM   R1,B'0111',TIOEJFCB     JFCB SVA\n         MVC   DSNAME,16(R1)           move dsname from JFCB\n         BR    R14\n         DROP  R1,R2                   TIOENTRY,DSAB\n***********************************************************************\n*        MODEL CONTROL BLOCKS, MOVED TO DYNAMIC STORAGE               *\n***********************************************************************\nMODELACB ACB DDNAME=INITKSDS,MACRF=(ADR,SEQ,IN,OUT),EXLST=EXLST1\nMODACBLL EQU *-MODELACB\nMODELRPL RPL ACB=*-*,OPTCD=(KEY,SEQ,MVE),AREA=*-*,AREALEN=*-*,ARG=*-*\nMODLRPLL EQU *-MODELRPL\nEXLST1   EXLST EODAD=CLOSE\n***********************************************************************\n*        DEFINE MESSAGES TO BE ISSUED VIA IKJEFF02                    *\n***********************************************************************\nMSGCSECT IKJTSMSG ('MSG000 ',,' SUCCESSFULLY INITIALIZED.'),00\n         IKJTSMSG ('MSG008 OPEN FAILED FOR ',,                         X\n               ', RETURN CODE IS ',,'.'),OPEN\n         IKJTSMSG ('MSG012 ',,' REQUEST FAILED FOR ',,                 X\n               ', FDBK=',,'.'),REQ\n         IKJTSMSG ('MSG021 ',,' IS NOT A VSAM KSDS.'),NVS\n         IKJTSMSG ('MSG034 ',,' IS NOT AN EMPTY VSAM DATA SET.'),FULL\n         IKJTSMSG ('MSG099 DYNALLOC FAILED FOR ',,'.'),99\n         IKJTSMSG\n***********************************************************************\n*        DEFINE INPUT PARAMETERS FOR IKJPARS                          *\n***********************************************************************\nPCLCSECT IKJPARM\nDSNPCE   IKJPOSIT DSNAME,USID,PROMPT='DATA SET NAME'\nRSTPCE   IKJKEYWD\n         IKJNAME 'NORESET'\n         IKJNAME 'RESET',ALIAS=('ERASE','DELETE')\nSTATPCE  IKJKEYWD\n         IKJNAME 'SHR'\n         IKJNAME 'OLD'\n         IKJENDP\n***********************************************************************\n*        DYNAMIC STORAGE AREA                                         *\n***********************************************************************\nDYNAM    DSECT\n         DS    18F                     SAVE AREA\nWORD1    DS    F                       ANSWER AREA\nDYNECB   DS    A                       ECB for parse, IKJEFF02\nRETCODE  DS    F                       RETURN CODE\nDSAB1    DS    A(DSAB)                 addr of the DSAB\nPGMCMD   DS    C                       P=PGM C=CMD\nRESET    DS    C                       R=RESET N=NORESET\n*\nSTATUS   DS    AL2(DALSTATS,1,1,X'0800') STATUS KEY, SHR OR OLD\nTU02DSN  DS    AL2(DALDSNAM,1,44)   +0 DATA SET NAME KEY\nDSNAME   DS    CL44                 +6 DATA SET NAME\nTU55DDN  DS    AL2(DALRTDDN,1,8)    +0 RETURN DDNAME\nDDNAME   DS    C'SYS45678'          +6 DDNAME\nTU57ORG  DS    AL2(DALRTORG,1,2)    +0 RETURN DSORG\nDSORG    DS    X'0000'              +6 VDSORG\n*\nREQUEST  DS    C'ERASE'                VSAM REQUEST\nMAXRECNO DS    F'12345678'          +0 MAX RECORD NUMBER       (SHOWCB)\nMAXLRECL DS    F'32760'             +4 MAX LRECL               (SHOWCB)\n         IKJEFFMT MTDSECT=NO\n         IKJEFFDF DFDSECT=NO,DFDSEC2=NO\nOPENLIST OPEN   IFGACB,MF=L            OPEN LIST\n         IFGACB DSECT=NO\n         IFGRPL DSECT=NO\n*\nWORKAREA DS    8D                      All-purpose work area\nDYNAML   EQU   *-DYNAM                 LENGTH OF WORK AREA\n*\n*              MACROS FROM SYS1.MACLIB\n*\n         IKJPPL                        PARSE PARAMETER LIST\n         IKJCPPL                       COMMAND PROCESSOR PARM LIST\n         IKJTCB                        Task Control Block\n         IEZJSCB                       Job Step Control Block\n         IEFZB4D0                      DYNALLOC REQUEST BLOCK\n         IEFZB4D2                      DYNALLOC TEXT UNIT KEYS\n         IEFJESCT TYPE=DSECT           JES CONTROL TABLE\n         IEFTIOT1                      TIOT DSECT\n         CVT DSECT=YES,LIST=NO\n         IHADSAB                       DATA SET ASSOCIATION BLOCK\n*        IEFZB4D5\nDSABQDB  DSECT                         DSAB QUEUE DESCRIPTOR BLOCK\nDSQDBID  DS    C'DSAB'                 ACRONYM\nDSQATTRS DS    XL2                     ATTRIBUTES\nDSQQDBLN DS    H'32'                   QDB LENGTH\nDSQNELMS DS    F                       NUMBER OF ELEMENTS ON QUEUE\nDSQFRSTP DS    A(DSAB)                 FIRST DSAB\nDSQLASTP DS    A(DSAB)                 LAST DSAB\n*        YREGS                         REGISTER EQUATES\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         END   INITKSDS\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//         DD DSN=SYS1.AMODGEN,DISP=SHR\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,15)\n//SYSUT2   DD UNIT=VIO,SPACE=(CYL,15)\n//SYSUT3   DD UNIT=VIO,SPACE=(CYL,15)\n//SYSGO    DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3120\n//SYSPRINT DD SYSOUT=*\n//*\n//LKEDTEMP EXEC PGM=IEWL,PARM=(LIST,MAP,RENT)\n//SYSLIN   DD DSN=*.ASMXF.SYSGO,DISP=(OLD,DELETE)\n//SYSLMOD  DD DSN=&&TEMPLOAD(INITKSDS),DISP=(,PASS),\n// UNIT=VIO,SPACE=(TRK,(1,,1))\n//SYSPRINT DD SYSOUT=*\n//\n//\n//*\n//GOPGM   EXEC PGM=INITKSDS\n//STEPLIB  DD DSN=&&TEMPLOAD,DISP=(OLD,PASS)\n//*NITKSDS DD SPACE=(TRK,100),RECORG=ES,LRECL=100\n//INITKSDS DD SPACE=(TRK,100),RECORG=KS,KEYLEN=12,LRECL=100\n//*\n//GOCMD   EXEC PGM=IKJEFT01\n//STEPLIB  DD DSN=&&TEMPLOAD,DISP=(OLD,PASS)\n//SYSTSIN  DD *\nDEF CL(NAME(CL)    IX)\nREPRO ODS(CL) IFILE(STEPLIB) COUNT(1) REPLACE\nINITKSDS CL RESET\nINITKSDS CL NORESET\nREPRO ODS(CL) IFILE(STEPLIB) COUNT(1)\nINITKSDS CL\nINITKSDS CL RESET\nDELETE CL\n//SYSTSPRT DD SYSOUT=*\n//SYSPRINT DD SYSOUT=*\n//ABNLIGNR DD DUMMY\n//SYSUDUMP DD SYSOUT=*\n//*\n//HLASM2 EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD,NOXREF)\nTESTPGM  CSECT\n         BASR  12,0\n         USING *,12\n         LA    1,ACB1\n         LINK  EP=INITKSDS\n         SVC   3\nACB1     ACB   DDNAME=KSDS1\n         END\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3200\n//*\n//LKED2   EXEC PGM=HEWLKED\n//SYSLIN   DD DSN=*.HLASM2.SYSLIN,DISP=(OLD,PASS)\n//SYSLMOD  DD DSN=&&TEMPLOAD(TESTPGM),DISP=(MOD,PASS)\n//SYSPRINT DD SYSOUT=*\n//*\n//GO      EXEC PGM=TESTPGM,REGION=4M\n//STEPLIB  DD DSN=&&TEMPLOAD,DISP=(OLD,PASS)\n//KSDS1    DD SPACE=(TRK,100),RECORG=KS,KEYLEN=12,LRECL=100\n//SYSDEBUG DD SYSOUT=*\n//SYSUDUMP DD SYSOUT=*\n//*\n//LKED    EXEC PGM=IEWL,PARM=(LIST,MAP,RENT)\n//SYSLIN   DD DSN=*.HLASM.SYSLIN,DISP=(OLD,PASS)\n//SYSLMOD  DD DSN=GSFSOFT.PRISM-CS.LOAD(INITKSDS),DISP=SHR\n//SYSPRINT DD SYSOUT=*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "JOBRLSE": {"ttr": 2568, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x833o\\x01\\x06!\\x0f\\x13D\\x00\\xb7\\x00F\\x00\\x00\\xc3\\xc2\\xe3\\xf4\\xf7\\xf2@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1983-12-02T00:00:00", "modifydate": "2006-07-29T13:44:00", "lines": 183, "newlines": 70, "modlines": 0, "user": "CBT472"}, "text": "//GILBERTJ JOB (ACCT#),JOBRLSE,\n// NOTIFY=&SYSUID,\n//*RESTART=EXEC,\n// CLASS=A,MSGCLASS=X,COND=(0,NE)\n//*\n//ASMXF EXEC PGM=IFOX00,PARM=(OBJECT,NODECK,NOESD,NORLD,ALIGN,NOXREF)\n***********************************************************************\n*                                                                     *\n*                       JOB RELEASE (JES2)                            *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n*        THIS PROGRAM ALLOWS YOU TO ISSUE A $A COMMAND TO RELEASE     *\n*        A JOB PREVIOUSLY SUBMITTED WITH \"TYPRUN=HOLD\".               *\n*                                                                     *\n*        TO PREVENT \"MULTIPLE JOBS FOUND\" PROBLEMS, THIS PROGRAM      *\n*        USES THE SUB-SYSTEM INTERFACE TO INQUIRE ABOUT THE STATUS    *\n*        OF HOMONYM JOBS.  IT THEN ISSUES A $A COMMAND WITH THE JOB   *\n*        NUMBER (FOR EXAMPLE: $A JOB01234) OF THE FIRST JOB FOUND     *\n*        IN THE INPUT QUEUE IN HELD STATUS.                           *\n*                                                                     *\n*        SAMPLE EXECUTION JCL:                                        *\n*                                                                     *\n*          //RLSENEXT EXEC PGM=JOBRLSE,PARM=JOBNAME                   *\n*                                                                     *\n*        WARNING !!! THIS PROGRAM MUST BE APF-AUTHORIZED.             *\n*                                                                     *\n***********************************************************************\nJOBRLSE  CSECT\nMAXJOBS  EQU   200                     MAX NUMBER OF HOMONYM JOBS\n         SAVE  (14,12),,'GSF UTILITIES - JOBRLSE R100'\n         LR    R12,R15\n         USING JOBRLSE,R12\n         ST    R13,SAVEAREA+4\n         LA    R13,SAVEAREA\n*\n*        VALIDATE JCL PARM\n*\n         L     R2,0(,R1)               JCL PARM ADDRESS\n         LH    R3,0(,R2)               PICK UP LENGTH\n         LTR   R3,R3\n         BNP   RETURN16                INVALID PARM LENGTH\n         CH    R3,=H'8'\n         BH    RETURN16                INVALID PARM LENGTH\n*\n*        ALLOCATE A SSOB AND BUILD IT.\n*\n         LA    R0,SSOBHSIZ+SSCSELSZ*MAXJOBS+256\n         GETMAIN RU,LV=(0)\n         ST    R1,SSOBPTR1\n         OI    SSOBPTR1,X'80'\n         LR    R11,R1\n         USING SSOB,R11\n         XC    SSOB(SSOBHSIZ),SSOB     BUILD THE SSOB\n         LA    R0,SSOBHSIZ\n         STH   R0,SSOBLEN\n         MVC   SSOBID,=C'SSOB'\n         LA    R0,SSOBSTAT\n         STH   R0,SSOBFUNC             FUNCTION CODE: CANCEL/STATUS\n         LA    R0,SSOBGN\n         ST    R0,SSOBINDV\n         LA    R0,SSCSIZE\n         STH   R0,SSCSLEN\n         MVI   SSCSFLGS,0\n         MVI   SSCSULEN,0\n         MVC   SSCSJOBN,SPACES         INITIALIZE THE FIELD\n         BCTR  R3,0\n         EX    R3,*+4\n         MVC   SSCSJOBN(*-*),2(R2)     MOVE JOBNAME FROM PARM\n         MVC   SSCSJOBI,SPACES         JOB ID\n         LA    R0,SSCSELSZ*MAXJOBS\n         STH   R0,SSCSDIMP\n*\n*        CALL JES2 VIA THE SUBSYSTEM INTERFACE\n*\n         MODESET KEY=ZERO,MODE=SUP\n         LA    R1,SSOBPTR1\n         IEFSSREQ  ,                   <==== CALL JES2\n         LTR   R2,R15                  COPY/TEST RETURN CODE\n         BZ    MODESET2                RC=0, CONTINUE\n         ABEND 2001,DUMP               IEFSSREQ ERROR\nMODESET2 MODESET KEY=NZERO,MODE=PROB\n         ICM   R15,B'1111',SSOBRETN    PICK UP RETURN-CODE\n         BZ    LOOKUP                  RC=0, CONTINUE\n         ABEND 2002,DUMP               RETURNED LENGTH IS ZERO\n*\n*        LOOK UP JOB ID\n*\nLOOKUP   LA    R3,SSCSARBG             START OF ARRAY\n         LA    R4,SSCSELSZ             ELEMENT SIZE\n         LH    R5,SSCSDIMR             LENGTH OF ARRAY (IN BYTES)\n         BCTR  R5,0\n         ALR   R5,R3                   END OF ARRAY\n         SLR   R3,R4                   1ST ENTRY\n         USING SSCSARAY,R3\n*LOOP\nLOOP1    BXH   R3,R4,RETURN04          SCAN JOB NAMES\n         TM    SSCSFLG1,SSCSEXCQ+SSCSHOLD\n         BNO   LOOP1                   TRY NEXT JOB\n*ENDLOOP\n         MVC   CMDJOBI,SSCSARID        JOB NUMBER: 'JOB01234'\n         MODESET KEY=ZERO,MODE=SUP\n         SLR   R0,R0                   CONSOLE ID\n         MGCR  CMD                     ISSUE 'RELEASE' COMMAND\n         MODESET KEY=NZERO,MODE=PROB\n         SLR   R2,R2                   RC=00\n         B     FREEMAIN\n*\n*        CLEAN UP, RETURN\n*\nRETURN04 LA    R2,0004(0)              NO JOB FOUND: RC=04\n*\nFREEMAIN LA    R0,SSOBHSIZ+SSCSELSZ*MAXJOBS+256\n         FREEMAIN RU,LV=(0),A=(R11)    FREE DYNAMIC AREA\n         LR    R15,R2                  PASS RETURN CODE\n         B     RETURN20\n*\nRETURN16 LA    R15,0016                PARM ERROR: RC16\nRETURN20 L     R13,4(,R13)\n         RETURN (14,12),RC=(15)        GOBACK TO SYSTEM\n*----------------------------------------------------------------------\n*\n*        WORK AREA\n*\n*----------------------------------------------------------------------\nSPACES   DC    CL8' '\nCMD      DC    Y(CMDL,0),C'$A '\nCMDJOBI  DS    CL8' '\nCMDL     EQU   *-CMD\nSSOBPTR1 DS    A\nSAVEAREA DS    18A\n*----------------------------------------------------------------------\n*\n*        CONTROL BLOCK DEFINITIONS\n*\n*----------------------------------------------------------------------\n         IEFJSSOB CS\n         CVT   DSECT=YES,PREFIX=NO\n         IEFJESCT\n*        YREGS\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         END\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//         DD DSN=SYS1.AMODGEN,DISP=SHR\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,15)\n//SYSUT2   DD UNIT=VIO,SPACE=(CYL,15)\n//SYSUT3   DD UNIT=VIO,SPACE=(CYL,15)\n//SYSGO    DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3120\n//SYSPRINT DD SYSOUT=*\n//*\n//LKED    EXEC PGM=IEWL,PARM='MAP,REUS,AC=1'\n//SYSLIN   DD DSN=*.ASMXF.SYSGO,DISP=(OLD,DELETE)\n//SYSPRINT DD SYSOUT=*\n//SYSLMOD  DD DSN=GILBERT.LOAD(JOBRLSE),DISP=SHR    <== APF LOADLIB\n//*\n//*       TEST STEP\n//*\n//EXEC    EXEC PGM=JOBRLSE,PARM=GILBERTH\n//STEPLIB  DD DSN=*.LKED.SYSLMOD,DISP=SHR\n//EXEC    EXEC PGM=JOBRLSE,PARM=GILBERTH\n//STEPLIB  DD DSN=*.LKED.SYSLMOD,DISP=SHR\n//EXEC    EXEC PGM=JOBRLSE,PARM=GILBERTH\n//STEPLIB  DD DSN=*.LKED.SYSLMOD,DISP=SHR\n//SYSUDUMP DD SYSOUT=*\n//\n//GILBERTH JOB (ACCT#),GILBERT,TYPRUN=HOLD,       TARGET JOB\n// CLASS=A,MSGCLASS=X                             TARGET JOB\n//TGT EXEC PGM=IEFBR14                            TARGET JOB\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "NOTCTLG3": {"ttr": 2817, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x02\\x00\\x00\\x00\\x82(\\x0f\\x01\\x06!\\x0f\\x14R\\x00\\xe1\\x01\\xde\\x009\\xc3\\xc2\\xe3\\xf4\\xf7\\xf2@@@@'", "ispf": {"version": "02.02", "flags": 0, "createdate": "1982-10-07T00:00:00", "modifydate": "2006-07-29T14:52:00", "lines": 225, "newlines": 478, "modlines": 57, "user": "CBT472"}, "text": "//GILBERTN JOB (ACCT#),NOTCTLG3,\n//*RESTART=EXECPROC.FROM,\n// NOTIFY=GILBERT,\n// CLASS=A,MSGCLASS=X\n//ASMXF EXEC PGM=IFOX00,PARM=(OBJECT,NODECK,NOESD,NORLD,ALIGN,NOXREF)\n***********************************************************************\n*                                                                     *\n*        REPLACEMENT FOR CZX3PSRC                              OS/VS2 *\n*                                                                     *\n*        1.  PREVENTS \"NOT CATLG 2\" CONDITIONS                        *\n*                                                                     *\n*        WARNING: The detection of NOT CATLG 2 situations only        *\n*        occurs when the program's own STEP name is \"FROM\".           *\n*                                                                     *\n***********************************************************************\n         LCLC  &STR\nNOTCTLG3 CSECT\n         SAVE  (14,12),,'GSF UTILITIES - NOTCTLG3 R202'\n         BALR  R11,0\n         USING *,R11\n         L     R2,0(,R1)               PARM FROM JCL\n         GETMAIN R,LV=DYNL             ALLOCATE DYNAMIC STORAGE\n         ST    R13,4(,R1)              SAVE SAVE AREA ADDRESS\n         LR    R13,R1                  NEW SAVE AREA\n         USING DYN,R13\n*\n*        PROCESS PARM (GET RETURN CODE VALUE IN BINARY)\n*\n         LH    R15,0(,R2)              PARM LENGTH\n         BCTR  R15,0\n         PACK  RETCODE,2(*-*,R2)       RETURN CODE\n         EX    R15,*-6                 EXECUTE PACK INSTRUCTION\n         CVB   R10,RETCODE             GET RETCODE, CHECK FOR A S0C7\n*\n         L     R1,540(,0)              MY TCB (PSATOLD-PSA)\n         L     R4,TCBJSCB-TCB(,R1)     MY JSCB\n         USING IEZJSCB,R4\n         L     R5,JSCBJCT              GET JCT ADDRESS\n         USING JCT,R5\n         L     R6,JSCSCT               CURRENT STEP'S SCT PREFIX\n         USING SCT,R6\n**       CLC   =C'FROM ',SCTSCLPC      PROCSTEP\n**       BE    LOOPSCT\n         CLC   =C'FROM ',SCTSNAME      STEP=FROM?\n         BNE   RETURN                  IT'S NOT THE RIGHT STEP, I QUIT\n*LOOP\nLOOPSCT  CLC   SCTSDPSA,JSCSCT+1       COND MUST REFER TO MY STEP\n         BNE   NEXTSTEP                IT'S NOT THE CASE, TRY NEXT STEP\n         CH    R10,SCTSDPCD            COND=(54,LT,FROM)\n         BH    NEXTSTEP                STEP TO BE BYPASSED\n         ICM   R1,B'0111',SCTFSIOT     PREFIX OF 1ST SIOT\n         BZ    NEXTSTEP                NO MORE DDS, TRY NEXT SCT\n*--LOOP\nLOOPSIOT EQU   *\n         LA    R7,16(,R1)              PASS SIOT ADDRESS\n         USING SIOT,R7\n         ICM   R1,B'0111',SCTPJFCB     JFCB PREFIX\n         LA    R8,16(,R1)              PASS JFCB ADDRESS\n         USING JFCB,R8                 DSNAME FROM JFCB\n         MVC   DSNAME,JFCBDSNM         MOVE DSN TO UNPROTECTED STORAGE\n*\n         TM    SCTSDISP,2              DISP=(,CATLG) ?\n         BNO   NEXTSIOT                JUMP, DISP IS NOT CATLG\n         TM    SCTSBYT3,4              DISP=NEW\n         BO    DISPOK                  JUMP IF DISP=NEW\n         TM    SCTSBYT3,2              DISP=MOD\n         BNO   NEXTSIOT                EXIT IF NOT NEW OR MOD\nDISPOK   TM    JFCBIND1,JFCGDG         CHECK FOR (+1)\n         BO    NEXTSIOT                JUMP, THIS IS A GDG\n         LOCATE CAML26\n         LTR   R15,R15\n         BNZ   NEXTSIOT                DATA SET NOT CATALOGED\n         CLI   MSG2DSN,C' '            CHECK DSNAME\n         BNE   NOTFIRST                NOT FIRST ERROR, JUMP\n         WTO   MF=(E,BLANKLNE)         BLANK LINE\n         WTO   MF=(E,BLANKLNE)         BLANK LINE\nNOTFIRST MVC   MSG2STEP,SCTSNAME       STEPNAME\n         MVC   MSG2DDN,SCTDDNAM        DDNAME\n         MVC   MSG2DSN,JFCBDSNM        DSNAME\n         WTO   MF=(E,MSG2)             ISSUE \"ALREADY CATALOGED\" MSG\n*\nNEXTSIOT ICM   R1,B'0111',SCTPSIOT     NEXT SIOT'S PREFIX\n         BNZ   LOOPSIOT                PROCESS NEXT DD CARD IN STEP\n*--ENDLOOP\n         DROP  R7,R8                   WERE SIOT, JFCB\nNEXTSTEP ICM   R6,B'0111',SCTANSCT     NEXT SCT PREFIX\n         BNZ   LOOPSCT                 PROCESS NEXT STEP\n*ENDLOOP\nENDSCT   CLI   MSG2DSN,C' '            CHECK FOR AN ERROR\n         BE    RETURN                  NO ERRORS, RETURN.\n         WTO   MF=(E,BLANKLNE)         BLANK LINE\n         WTO   MF=(E,BLANKLNE)         BLANK LINE\n*\n*        IF THE STEP IS AUTHORIZED, SET THE \"JOB FAILED\" BIT ON\n*        IN THE JCT.  IF THE STEP ISN'T AUTHORIZED, ISSUE AN ABEND.\n*        THE ADVANTAGE OF A \"JOB FAILED\" IS THAT COND=EVEN STEPS\n*        ARE NOT EXECUTED.\n*\n         TM    JSCBOPTS,JSCBAUTH       TEST AUTHORIZATION\n         BZ    ABEND88                 JUMP IF NOT AUTHORIZED.\n         MODESET KEY=ZERO              CHANGE TO KEY 0\n         OI    JCTJSTAT,INCMSTS        TURN ON \"JOB FAILED\" BIT\n*\nRETURN   LR    R1,R13                  PASS ADDR FOR FREEMAIN\n         L     R13,4(,R13)\n         FREEMAIN R,LV=DYNL,A=(1)      FREE DYNAMIC STORAGE\n         LR    R15,R10                 RETURN CODE FROM PARM\n         RETURN (14,12),RC=(15)\nABEND88  ABEND 2088                    AT LEAST 1 CATALOGED DATA SET\n*---------------------------------------------------------------------*\n*                                                                     *\n*        WORK AREAS FOR NOT-CATLG 2 FUNCTION                          *\n*                                                                     *\n*---------------------------------------------------------------------*\nBLANKLNE WTO   '****',ROUTCDE=14,MF=L  BLANK LINE FOR READABILITY\n&STR     SETC  (44)' '\nMSG2     WTO   '**** ALREADY CATALOGED: SSSSSSSS DDDDDDDD &STR',       X\n               ROUTCDE=(11,14),MF=L\nMSG2STEP EQU   MSG2+28+00,8            STEPNAME\nMSG2DDN  EQU   MSG2+28+09,8            DDNAME\nMSG2DSN  EQU   MSG2+28+18,44           DSNAME\nCAML26   CAMLST NAME,DSNAME,,*-*\n*---------------------------------------------------------------------*\n*                                                                     *\n*        DYNAMIC ALLOCATION OF A VSAM DATA SET                        *\n*                                                                     *\n*---------------------------------------------------------------------*\nS99RB    DC    A(X'14010000',0,S99TUPL,0,0)\nS99TUPL  DC    A(S99T1,S99T2,S99T4+VL)\nS99T1    DC    XL2'55,1,8',C'$$VERIFY' DDNAME\nS99T2    DC    AL2(2,1,44),CL44' '     DSNAME\nDSNAME   EQU   S99T2+6,44\nS99T4    DC    AL2(4,1,1),X'08'        DISP=SHR\n*---------------------------------------------------------------------*\n*                                                                     *\n*        DYNAMIC STORAGE AREA                                         *\n*                                                                     *\n*---------------------------------------------------------------------*\nDYN      DSECT\nSAVEAREA DS    18F\nRETCODE  DS    D\nDYNL     EQU   (((*-DYN+4095)/4096)*4096)\n*---------------------------------------------------------------------*\n*                                                                     *\n*        DSECTS FOR SWA/LSQA CONTROL BLOCKS                           *\n*                                                                     *\n*---------------------------------------------------------------------*\nVL       EQU   X'80000000'\n**       IEFJESCT TYPE=DSECT           JES CONTROL TABLE\n         IKJTCB LIST=NO                SYS1.AMODGEN\n         IEZJSCB ,                     SYS1.AMODGEN\nJCT      DSECT\n         DS    XL16                    PREFIX\n         IEFAJCTB ,                    SYS1.AMODGEN\nSCT      DSECT\n         DS    XL16                    PREFIX\n         IEFASCTB ,                    SYS1.AMODGEN\nSIOT     DSECT\n         DS    XL16                    PREFIX\n         IEFASIOT ,                    SYS1.AMODGEN\nJFCB     DSECT\n         DS    XL16                    PREFIX\n         IEFJFCBN ,                    SYS1.AMODGEN\n         CVT   LIST=NO,DSECT=YES       COMMUNICATION VECTOR TABLE\n*        YREGS                         SYS1.MACLIB\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         END\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//         DD DSN=SYS1.AMODGEN,DISP=SHR\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,15)\n//SYSUT2   DD UNIT=VIO,SPACE=(CYL,15)\n//SYSUT3   DD UNIT=VIO,SPACE=(CYL,15)\n//SYSGO    DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3120\n//SYSPRINT DD SYSOUT=*\n//*\n//LKED    EXEC PGM=HEWL,PARM='MAP,AC=1',COND=(0,NE,ASMXF)\n//SYSLIN   DD DSN=*.ASMXF.SYSGO,DISP=(OLD,DELETE)\n//SYSLMOD  DD DSN=GILBERT.LOAD2(CZX3PSRC),DISP=SHR\n//SYSPRINT DD SYSOUT=*\n//*\n//DD2## DD DISP=(MOD,DELETE),DSN=GILBERT.NOTCTLG2,UNIT=3380,SPACE=(1,0)\n//DD2   DD DISP=(,CATLG),DSN=GILBERT.NOTCTLG2,UNIT=3380,SPACE=(1,0)\n//DD3   DD DISP=(MOD,DELETE),DSN=GILBERT.NOTCTLG3,UNIT=3380,SPACE=(1,0)\n//*\n//PROC    PROC\n//FROM    EXEC PGM=CZX3PSRC,PARM=54\n//STEPLIB  DD DSN=GILBERT.LOAD2,DISP=SHR\n//ABNLTERM DD SYSOUT=*\n//SYSUDUMP DD SYSOUT=*\n//*\n//STEP53  EXEC PGM=IEFBR14,COND=(53,LT,FROM)\n//DDCAT2 DD DISP=(,CATLG),DSN=GILBERT.NOTCTLG2,UNIT=3380,SPACE=(1,0)\n//*\n//STEP54  EXEC PGM=IEFBR14,COND=(54,LT,FROM)\n//DDCAT2 DD DISP=(,CATLG),DSN=GILBERT.NOTCTLG2,UNIT=3380,SPACE=(1,0)\n//*\n//STEP55  EXEC PGM=IEFBR14,COND=(55,LT,FROM)\n//DDCAT5 DD DISP=(,CATLG),DSN=GILBERT.NOTCTLG3,UNIT=3380,SPACE=(1,0)\n//*\n//STEP56  EXEC PGM=IEFBR14,COND=(56,LT,FROM)\n//DD6A DD DISP=(,CATLG),DSN=GILBERT.NOTCTLG2(+1),UNIT=3380,SPACE=(1,0)\n//DD6B DD DISP=(MOD,CATLG),DSN=GILBERT.NOTCTLG2(MM),\n// UNIT=3380,SPACE=(1,0)\n//VFY  DD DSN=PPV.VFY,DISP=SHR\n//*\n//STEP57  EXEC PGM=IEFBR14,COND=(57,LT,FROM)\n//VFY  DD DSN=GILBERT.VFY2,AMP='AMORG',DISP=SHR\n//        PEND\n//*\n//EXECPROC EXEC PROC\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "STRING": {"ttr": 2822, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00x#\\x9f\\x01\\x06!\\x0f\\t9\\x04\\x97\\x00\\x19\\x00m\\xc3\\xc2\\xe3\\xf4\\xf7\\xf2@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1978-08-27T00:00:00", "modifydate": "2006-07-29T09:39:00", "lines": 1175, "newlines": 25, "modlines": 109, "user": "CBT472"}, "text": "*/GILBERTF JOB (ACCT#),STRINGXF,\n*/ NOTIFY=&SYSUID,\n*/ CLASS=A,MSGCLASS=X,COND=(0,NE)\n*/XFASM EXEC PGM=IFOX00,PARM=(OBJECT,NODECK,ESD,NORLD,NOXREF)\n*/STEPLIB DD DSN=GSFSOFT.XFASM.LOAD,DISP=SHR\n***********************************************************************\n*                                                                     *\n* MACRO NAME = STRING                                                 *\n*                                                                     *\n* DESCRIPTIVE NAME = STRING Macro Instruction for Assembler XF        *\n*                                                                     *\n* FUNCTION = Provide capabilities similar to PUT EDIT (of PL/I)       *\n*            or STRING (of COBOL) to assembler programs.              *\n*                                                                     *\n* STATUS = R101                                                       *\n*                                                                     *\n* AUTHOR = Gilbert Saint-Flour <carlos@gsf-soft.com>                  *\n*                                                                     *\n* ENVIRONMENT = SEE BELOW                                             *\n*                                                                     *\n*    AMODE  = ANY                                                     *\n*    RMODE  = ANY                                                     *\n*     SCP   = S/360 OS, OS/VS, MVS/370                                *\n* Processor = Assembler XF, Assembler H, High-Level Assembler         *\n*     KEY   = ANY                                                     *\n*     MODE  = ANY                                                     *\n*     APF   = ANY                                                     *\n*                                                                     *\n* OPERATION = SEE DOCUMENTATION AT THE END OF THIS FILE               *\n*                                                                     *\n* INVOCATION = SEE DOCUMENTATION AT THE END OF THIS FILE              *\n*                                                                     *\n* NOTES = SEE DOCUMENTATION AT THE END OF THIS FILE                   *\n*                                                                     *\n* CHANGE ACTIVITY                                                     *\n*                                                                     *\n* $101 ASM XF version of STRING R514                                  *\n***********************************************************************\n         MACRO\n&NAME    STRING &INTO=,&PRINT=NOGEN\n         GBLA  &$$LIT\n         GBLB  &$$FEAT(16)             FEATURES\n.*                                       1 LITERALS\n.*                                       2 REGISTER (BIN)\n.*                                       3 REGISTER (HEX)\n.*                                       4 PACKED\n.*                                       5 JDATE\n.*                                       6 BINARY\n.*                                       7 HEX\n.*                                       8 NUMERIC\n.*                                       9 LEFT JUST (NUMERIC)\n.*                                       10 LEADING ZEROES\n.*                                       11 TRUNCATE (CHAR STRING)\n.*                                       12 %TIME\n         GBLC  &MACVERS\n         GBLC  &$$LITS(9999)           LITERALS\n         LCLA  &I,&J,&L,&N,&FLAG,&LEN2,&BLANKS\n         LCLB  &LAST,&BIN,&HEX,&REG,&PACKED,&LEFT,&ZERO,&TRUNC,&NUMERIC\n         LCLC  &LABEL,&LQ,&STR,&TO1,&TO2,&P1S,&P2C,&P2L,&P3C,&P3L\n         LCLC  &LIT,&ALLFEAT\n&MACVERS SETC '101'                    current version\n         AIF   ('&PRINT' EQ 'NOGEN').NOGEN\n         PUSH  PRINT\n         PRINT GEN\n.NOGEN   ANOP\n         AIF   (T'&INTO EQ 'O' AND N'&SYSLIST EQ 1                     X\n               AND '&SYSLIST(1)' EQ 'GENERATE').GENL\n&LABEL   SETC  'IHB&SYSNDX'            STEM FOR LOCAL LABELS\n&LQ      SETC  'L'''                   LENGTH ATTRIBUTE\n&STR     SETC  ' R&MACVERS XF '\n&NAME    L     R15,=A(@STR002)&STR     Routine Address\n         BALR  R14,R15                 CALL @STRING Routine\n         AIF   (N'&SYSLIST EQ 0).ERR1  NO POSITIONAL OPERANDS, ERROR\n         AIF   (T'&INTO EQ 'O').ERR2   NO RECEIVING FIELD, ERROR\n         AIF   (N'&INTO GT 2).ERR2     INTO=(A,32,BLURB)\n         DC    AL2((&LABEL.P-@STRING)/2) OFFSET TO FIELD DESCRIPTORS\n@STRING  CSECT                         NON-ADDRESSABLE CONSTANTS\n&TO1     SETC  '&INTO(1)'\n&TO2     SETC  '&LQ&INTO'\n         AIF   (N'&INTO EQ 1).PUNTO8            JUMP IF INTO=XXX\n         AIF   ('&INTO(1)'(1,1) NE '(').PUNTO3  JUMP IF INTO=(XXX,44)\n&TO1     SETC  '0&INTO(1)'                              INTO=((R3),44)\n.PUNTO3  ANOP\n&TO2     SETC  '&INTO(2)'                               INTO=(XXX,LL)\n         AIF   ('&INTO(2)'(1,1) NE '(').PUNTO8  JUMP IF INTO=(XXX,44)\n&TO2     SETC  '0&INTO(2)'                              INTO=(XXX,(R1))\n.PUNTO8  ANOP\n&LABEL.P DC    S(&TO1,&TO2)\n.*--------------------------------------------------------------------*\n.*-------      FIELDS       ------------------------------------------*\n.*--------------------------------------------------------------------*\n&I       SETA  1\n.*LOOP\n.LOOP1   ANOP\n         ACTR  200                            SYSDEBUG/DIAG055\n         AIF   (N'&SYSLIST(&I) GT 3).FLD990   TOO MANY SUB-OPERANDS\n&LAST    SETB  (&I EQ N'&SYSLIST)                LOOP\n         AIF   ('&SYSLIST(&I)'(1,1) EQ '''').LIT00\n         AIF   ('&SYSLIST(&I)'(K'&SYSLIST(&I),1) EQ '''').LIT01\n.*--------------------------------------------------------------------*\n.*       PROCESS FIRST SUBPARAMETER (ADDRESS)                         *\n.*--------------------------------------------------------------------*\n&P1S     SETC  '&SYSLIST(&I,1)'\n&P2L     SETC  '0'                     INPUT LENGTH\n&P3L     SETC  '0'                     OUTPUT LENGTH\n         AIF   ('&SYSLIST(&I)'(1,1) GE '0').FLD180 SPACES\n         AIF   ('&SYSLIST(&I)' EQ '%TIME').FLD190 %TIME\n         AIF   ('&SYSLIST(&I,1)'(1,1) NE '(').FLD115 (R2)\n         AIF   (T'&SYSLIST(&I,2) EQ 'O').FLD250\n&P1S     SETC  '0&SYSLIST(&I,1)'       CHANGE (R1) TO 0(R1)\n.FLD115  ANOP\n.*\n         AIF   (T'&SYSLIST(&I,2) NE 'O').FLD200\n.*\n.*       EXTRACT RBCDE FROM PRB.RBCDE (HLASM)\n.*\n&L       SETA  1\n.*--LOOP\n.FLD131  AIF   ('&P1S'(&L,1) EQ '.').FLD133\n&L       SETA  &L+1\n         AIF   (&L LT K'&P1S).FLD131\n.*--ENDLOOP\n&P2L     SETC  '&P1S'                    ABCDEF FROM ABCDEF\n         AGO   .FLD134\n.FLD133  ANOP\n&P2L     SETC  '&P1S'(&L+1,K'&P1S-&L)    RBCDE FROM PRB.RBCDE\n.FLD134  ANOP\n.*\n.*XF     AIF   (NOT D'&P2L).FLD140\n&P2C     SETC  T'&P2L\n.*MNOTE *,'&P1 &P2C'\n         AIF   ('&P2C' EQ 'F' OR '&P2C' EQ 'H' OR '&P2C' EQ 'P').FLD220\n         AIF   ('&P2C' EQ 'G').FLD210  FL2\n.FLD140  ANOP\n.*\n.*       EXTRACT PSATOLD FROM PSATOLD-PSA\n.*\n&L       SETA  1\n.*--LOOP\n.FLD141  AIF   ('&P2L'(&L,1) EQ '-').FLD143\n         AIF   ('&P2L'(&L,1) EQ '+').FLD143\n&L       SETA  &L+1\n         AIF   (&L LT K'&P2L).FLD141\n.*--ENDLOOP\n&P2L     SETC  '&LQ&P2L'               L'ABCDEF\n         AGO   .FLD300\n.FLD143  ANOP\n&P2L     SETC  '&LQ'.'&P2L'(1,&L-1)    L'PSATOLD FROM PSATOLD-PSA\n         AGO   .FLD300\n.*\n.FLD180  AIF   ('&SYSLIST(&I)'(K'&SYSLIST(&I),1) NE 'X').FLD800\n&P2L     SETC  '&SYSLIST(&I)'(1,K'&SYSLIST(&I)-1) 12\n         AIF   (&LAST).FLD186\n         DC    X'60',AL1(&P2L)         BLANKS\n         AGO   .LIT90\n.FLD186  DC    X'E0',AL1(&P2L),0S(0)   BLANKS\n         AGO   .LIT90\n.*\n.FLD190  ANOP                          %TIME\n&P1S     SETC  '1(14)'                 %TIME\n&$$FEAT(12) SETB 1                     %TIME\n         AGO   .FLD800\n.*--------------------------------------------------------------------*\n.*       PROCESS SECOND SUBPARAMETER (LENGTH/TYPE)                    *\n.*--------------------------------------------------------------------*\n.FLD200  AIF   (T'&SYSLIST(&I,2) EQ 'O').FLD300 NO LENGTH SPECIFIED\n&P2C     SETC  '&SYSLIST(&I,2)'\n         AGO   .FLD220\n.*T'&P1=G\n.FLD210  ANOP\n&L       SETA  L'&SYSLIST(&I)          T'&P1 = 'G'\n&P2C     SETC  'FL&L'                  T'&P1 = 'G'\n.*\n.FLD220  ANOP\n&P2L     SETC  '0&P2C'                 (R2) LENGTH\n         AIF   ('&P2C'(1,1) EQ '(').FLD300\n&P2L     SETC  '&P2C'                  3(R2) LENGTH\n         AIF   ('&P2C'(K'&P2C,1) EQ ')').FLD300\n&P2L     SETC  '0'\n&PACKED  SETB  ('&P2C' EQ 'P')\n         AIF   (&PACKED).FLD290\n&P2L     SETC  '1'\n         AIF   ('&P2C' EQ 'FL1').FLD240\n&P2L     SETC  '3'\n         AIF   ('&P2C' EQ 'FL2' OR '&P2C' EQ 'H').FLD240\n&P2L     SETC  '7'\n         AIF   ('&P2C' EQ 'FL3').FLD240\n&P2L     SETC  '15'\n         AIF   ('&P2C' EQ 'F').FLD240\n&P2L     SETC  '&P2C'                  IMMEDIATE LENGTH, FIELD\n         AGO   .FLD300\n.*\n.FLD240  ANOP                          BINARY VARIABLE\n&BIN     SETB  1\n         AGO   .FLD300\n.*\n.FLD250  ANOP                          REGISTER CONTENT\n&REG     SETB  1\n         AGO   .FLD300\n.*\n.FLD290  ANOP                          PACKED\n&P2L     SETC  '1'\n.*--------------------------------------------------------------------*\n.*       PROCESS THIRD SUBPARAMETER (OUTPUT FORMAT)                   *\n.*--------------------------------------------------------------------*\n.FLD300  AIF   (T'&SYSLIST(&I,3) EQ 'O').FLD800\n&HEX     SETB  ('&SYSLIST(&I,3)' EQ 'X') HEXADECIMAL\n&TRUNC   SETB  ('&SYSLIST(&I,3)' EQ 'T') TRUNCATE\n         AIF   (&HEX OR &TRUNC).FLD800\n.*\n&P3C     SETC  '&SYSLIST(&I,3)'\n&P3L     SETC  '248'\n         AIF   ('&P3C' EQ 'YYYY-MM-DD' AND &PACKED).FLD308\n&P3L     SETC  '249'\n         AIF   ('&P3C' EQ 'YYYYMMDD' AND &PACKED).FLD308\n&P3L     SETC  '250'\n         AIF   ('&P3C' EQ 'YY/MM/DD' AND &PACKED).FLD308\n&P3L     SETC  '251'\n         AIF   ('&P3C' EQ 'DD/MM/YY' AND &PACKED).FLD308\n&P3L     SETC  '252'\n         AIF   ('&P3C' EQ 'MM/DD/YY' AND &PACKED).FLD308\n&P3L     SETC  '253'\n         AIF   ('&P3C' EQ 'YYMMDD'   AND &PACKED).FLD308\n&P3L     SETC  '0'\n         AIF   (T'&SYSLIST(&I,2) NE 'N').FLD310\n         MNOTE 8,'EDIT PATTERN NOT ALLOWED WITH CHARACTER STRING'\n         AGO   .FLD310\n.FLD308  ANOP\n&$$FEAT(5) SETB 1                      JDATE\n         AGO   .FLD800\n.*--LOOP\n.FLD310  AIF   ('&P3C'(1,1) EQ 'R').FLD318       DEFAULT\n         AIF   ('&P3C'(1,1) EQ 'B').FLD318       DEFAULT\n         AIF   ('&P3C'(1,1) NE 'L').FLD311\n&LEFT    SETB  1\n         AGO   .FLD318\n.FLD311  AIF   ('&P3C'(1,1) NE 'Z').FLD312\n&ZERO    SETB  1\n         AGO   .FLD318\n.FLD312  AIF   ('&P3C'(1,1) LT '0').FLD993       nn in RnnB is not num\n         AIF   ('&P3C'(1,1) GT '9').FLD993       nn in RnnB is not num\n&P3L     SETC  '&P3L'.'&P3C'(1,1)\n.FLD318  ANOP\n.*MNOTE *,'&SYSLIST(&I) P3C=/&P3C/ P3L=/&P3L/'\n&P3C     SETC  '&P3C '(2,K'&P3C-1)     STRIP OFF FIRST CHARACTER\n         AIF   (K'&P3C GT 0).FLD310\n.*--ENDLOOP\n         AIF   (&P3L GT 16).FLD993               nn in RnnB is too big\n.*--------------------------------------------------------------------*\n.FLD800  ANOP\n&NUMERIC SETB  (&BIN OR &PACKED OR (&REG AND NOT &HEX))\n&TRUNC   SETB  (&TRUNC OR (&LEFT AND NOT &NUMERIC))\n&LEFT    SETB  (&LEFT AND &NUMERIC)\n         AIF   (NOT &NUMERIC).FLD810\n         AIF   (&LEFT OR '&P3L' NE '0').FLD810\n&P3L     SETC  '7'                     DEFAULT OUTPUT LENGTH ((R3))\n         AIF   (&REG).FLD810\n&P3L     SETC  '3'                     DEFAULT OUTPUT LENGTH\n         AIF   ('&P2C' EQ 'FL1').FLD810\n&P3L     SETC  '5'                     DEFAULT OUTPUT LENGTH\n         AIF   ('&P2C' EQ 'H' OR '&P2C' EQ 'FL2').FLD810\n&P3L     SETC  '7'                     DEFAULT OUTPUT LENGTH\n.FLD810  ANOP\n&FLAG    SETA  &HEX*8+&BIN*4+&PACKED*2+&REG*1\n&LEN2    SETA  &TRUNC*128+&LEFT*128+&ZERO*64+&P3L\n&$$FEAT(2) SETB (&$$FEAT(2) OR (&REG AND NOT &HEX))   REGISTER (BIN)\n&$$FEAT(3) SETB (&$$FEAT(3) OR (&REG AND &HEX))       REGISTER (HEX)\n&$$FEAT(4) SETB (&$$FEAT(4) OR &PACKED)               PACKED\n&$$FEAT(6) SETB (&$$FEAT(6) OR &BIN)                  BINARY\n&$$FEAT(7) SETB (&$$FEAT(7) OR (&HEX AND NOT &REG))   HEX\n&$$FEAT(8) SETB (&$$FEAT(8) OR &NUMERIC)              BIN,PACKED\n&$$FEAT(9) SETB (&$$FEAT(9) OR (&LEFT AND &NUMERIC))\n&$$FEAT(10) SETB (&$$FEAT(10) OR &ZERO)\n&$$FEAT(11) SETB (&$$FEAT(11) OR &TRUNC)\n&BIN     SETB  0                    RESET FLAGS\n&HEX     SETB  0                    RESET FLAGS\n&REG     SETB  0                    RESET FLAGS\n&PACKED  SETB  0                    RESET FLAGS\n&LEFT    SETB  0                    RESET FLAGS\n&ZERO    SETB  0                    RESET FLAGS\n&TRUNC   SETB  0                    RESET FLAGS\n         AIF   (&FLAG GE 10).FLD995\n         AIF   (&LAST).FLD816\n         DC    X'0&FLAG',AL1(&LEN2),SL2(&P1S,&P2L)\n         AGO   .LIT99\n.FLD816  DC    X'8&FLAG',AL1(&LEN2),SL2(&P1S,&P2L),0S(0)\n         AGO   .LIT99\n.FLD990  MNOTE 12,'OPERAND &I HAS TOO MANY SUB-OPERANDS'\n         AGO   .LIT99\n.FLD993  MNOTE 8,'THIRD SUBPARAMETER IS INVALID: ''&SYSLIST(&I,3)'''\n         AGO   .LIT99\n.FLD995  MNOTE 8,'Invalid Combination of Attributes: &SYSLIST(&I)'\n         AGO   .LIT99\n.*--------------------------------------------------------------------*\n.*------------ LITERALS ----------------------------------------------*\n.*--------------------------------------------------------------------*\n.LIT00   ANOP\n&LIT     SETC  'C&SYSLIST(&I)'\n         AGO   .LIT09\n.LIT01   ANOP\n&LIT     SETC  '&SYSLIST(&I)'\n.LIT09   ANOP                              calculate length of literal\n&J       SETA  3\n&L       SETA  0\n         ACTR  K'&LIT+K'&LIT+100\n         AIF   ('&LIT'(1,1) EQ 'X').LIT11X\n.*LOOP\n.LIT11C AIF ('&LIT'(&J,1) NE '''' AND '&LIT'(&J,1) NE '&&'(1,1)).LIT12C\n&J       SETA  &J+1\n.LIT12C  ANOP\n&J       SETA  &J+1\n&L       SETA  &L+1\n         AIF   (&J LT K'&LIT).LIT11C\n.*ENDLOOP\n         AGO   .LIT15\n.*LOOP\n.LIT11X  AIF   ('&LIT'(&J,1) EQ ',').LIT12X\n&L       SETA  &L+1\n.LIT12X  ANOP\n&J       SETA  &J+1\n         AIF   (&J LT K'&LIT).LIT11X\n.*ENDLOOP\n&L       SETA  (&L+1)/2\n.LIT15   ANOP                               generate in-line literal\n         AIF   (&L GT 5).LIT40\n         AIF   (&LAST).LIT16\n         DC    X'4&L',&LIT\n         AGO   .LIT90\n.LIT16   DC    X'C&L',&LIT,0S(0)\n         AGO   .LIT90\n.LIT40   ANOP                                  check literal table\n         AIF   (&$$LIT EQ 0).LIT50\n&N       SETA  1\n         ACTR  &$$LIT*3+200\n.LIT41   AIF   ('&LIT' EQ '&$$LITS(&N)').LIT80       LOOP\n&N       SETA  &N+1                                  LOOP\n         AIF   (&N LE &$$LIT).LIT41                  LOOP\n.LIT50   ANOP\n&$$LIT   SETA  &$$LIT+1\n&$$LITS(&$$LIT) SETC '&LIT'\n&N       SETA  &$$LIT\n.LIT80   ANOP                               generate remote literal\n&N       SETA  &N+1000\n         AIF   (&LAST).LIT86\n         DC    X'40',AL1(&L),AL2($LIT&N-*)\n         AGO   .LIT90\n.LIT86   DC    X'C0',AL1(&L),AL2($LIT&N-*),0S(0)\n.LIT90   ANOP\n&$$FEAT(1) SETB 1                      LITERAL\n.LIT99   ANOP\n.*--------------------------------------------------------------------*\n&I       SETA  1+&I                              LOOP\n         AIF   (&I LE N'&SYSLIST).LOOP1          LOOP\n.*ENDLOOP\n&SYSECT  CSECT\n         AGO   .MEND\n.ERR1    MNOTE 12,'AT LEAST ONE INPUT FIELD MUST BE SPECIFIED'\n         AGO   .MEND\n.ERR2    MNOTE 12,'INVALID OUTPUT AREA SPECIFICATION'\n         AGO   .MEND\n.**********************************************************************\n.*       GENERATE: GENERATE LITERALS AND PROCESSING ROUTINE           *\n.**********************************************************************\n.GENL    ANOP\n&ALLFEAT SETC  '&$$FEAT(1)&$$FEAT(2)&$$FEAT(3)&$$FEAT(4)'\n&ALLFEAT SETC  '&ALLFEAT&$$FEAT(5)&$$FEAT(7)&$$FEAT(6)&$$FEAT(8)'\n&ALLFEAT SETC  '&ALLFEAT&$$FEAT(9)&$$FEAT(10)&$$FEAT(11)&$$FEAT(12)'\n&BLANKS  SETA  2\n         MNOTE *,'STRING R&MACVERS - FEATURES GENERATED: &ALLFEAT'\n@STRING  CSECT\n         AIF   (&$$LIT EQ 0).GENL3\n.GENL2   ANOP                                LOOP\n&N       SETA  &N+1                          LOOP\n&I       SETA  &N+1000                       LOOP\n$LIT&I   DC    &$$LITS(&N)\n         AIF   (&N LT &$$LIT).GENL2          LOOP\n.GENL3   DC    0H'0'\n.**********************************************************************\n.*                                                                    *\n.*       STRING SUB-ROUTINE                                           *\n.*                                                                    *\n.*             CAUTION: BYTES 49-72 OF THE CALLER'S SAVE AREA         *\n.*                      (R7-R12 SLOTS) ARE USED AS WORK SPACE         *\n.*                                                                    *\n.**********************************************************************\n@00      EQU   0                       WORK REGISTER\n@01      EQU   1                       WORK REGISTER\n@02      EQU   2                       WORK REGISTER\n@03      EQU   3                       WORK REGISTER\n@04      EQU   4                       WORK REGISTER\n@05      EQU   5                       WORK REGISTER\n@06      EQU   6                       WORK REGISTER\n@13      EQU   13                      CALLER'S SAVE AREA\n@14      EQU   14                      WORK REGISTER\n@15      EQU   15                      BASE REG\n         USING @STR002,@15\n         USING @STRSAVE,@13\n@STR002  B     @STR011                 BRANCH AROUND EYE-CATCHER\n         DC    AL1(@STR003-*),C'@STRING/XF R&MACVERS &ALLFEAT',0H'0'\n@STR003  DC    Y(@STR002-@STRING)      Offset to @STRING\n@STR011  STM   @14,@06,12(@13)         Save caller's registers\n         SLR   @06,@06                 R6=0\n         ICM   @06,B'0011',0(@14)      PICK UP PARM-LIST 1/2 OFFSET\n         ALR   @06,@06                 PICK UP PARM-LIST OFFSET\n         ALR   @06,@15                 R6 NOW POINTS TO PARM LIST\n         SH    @06,@STR003             R6 NOW POINTS TO PARM LIST\n         USING @STRSCON,@06\n         LA    @02,@STRSCON            RESOLVE FIRST SCON (ADDR)\n         BAL   @14,@STRS2A             GET ADDRESS IN R2\n         LA    @04,0(,@02)             KEEP ADDRESS OF \"INTO\" FIELD\n         L     @14,12(,@13)            RESTORE ADDR OF STRING MACRO\n         OI    0(@04),0                GET CLEAN S0C4 IF ADDRESS IS BAD\n         LA    @02,@STRFLEN            RESOLVE SECOND S-CON (LEN)\n         BAL   @14,@STRS2A             GET LENGTH IN R2\n         LR    @05,@02                 KEEP LENGTH OF \"INTO\" FIELD\n         CR    @05,@04                 END ADDRESS?\n         BL    @STR282                 NO, JUMP\n         SR    @05,@04                 CALCULATE LENGTH\n@STR282  ST    @04,8(,@13)             SAVE ADDRESS FOR LATER\n.**********************************************************************\n.*       MOVE FIELDS TO OUTPUT AREA                                   *\n.**********************************************************************\n         LA    @06,@STRNEXT            POINT TO 1ST FIELD DESC\n         USING @STRPARM,@06\n.*LOOP\n@STR310  EQU   *\n         AIF   (NOT &$$FEAT(1)).FEAT1A\n         TM    @STRFLAG,@STRLIT        IS THIS A LITERAL?\n         BO    @STR372                 YES, JUMP\n.FEAT1A  ANOP\n         AIF   (NOT &$$FEAT(2) AND NOT &$$FEAT(3)).FEAT23A\n         TM    @STRFLAG,@STRREG        REGISTER?\n         BO    @STR323                 YES, JUMP\n.FEAT23A ANOP\n         AIF   (NOT &$$FEAT(12)).FEAT12A\n         CLI   @STRSCON,X'E0'          IS IT %TIME ?\n         BE    @STR378                 YES, JUMP\n.FEAT12A ANOP\n.*\n.*       IT'S A FIELD (SCON)\n.*\n         LA    @02,@STRFLEN            RESOLVE SECOND S-CON (LEN)\n         BAL   @14,@STRS2A             GET LENGTH IN R2\n         AIF   (&$$FEAT(9)).FEAT9E1    (LEFT JUSTIFICATION, NUMERIC)\n         LTR   @03,@02                 KEEP/TEST LENGTH\n         BZ    @STR398                 ZERO LENGTH, DO NOT EDIT\n         AGO   .FEAT9E2\n.FEAT9E1 LTR   @03,@02                 KEEP/TEST LENGTH\n         BP    @STR313                 LENGTH POSITIVE, JUMP\n         TM    @STRLEN2,@STRLEFT       LEFT JUSTIFICATION?\n         BNO   @STR398                 NO, ZERO LENGTH IS NOT OK\n@STR313  EQU   *\n.FEAT9E2 ANOP\n         LA    @02,@STRSCON            RESOLVE FIRST SCON (ADDR)\n         BAL   @14,@STRS2A             GET ADDRESS IN R2\n         L     @14,12(,@13)            RESTORE ADDR OF STRING MACRO\n         CLI   0(@02),0                GET CLEAN S0C4 IF ADDRESS IS BAD\n         CR    @03,@02                 END ADDRESS?\n         BL    @STR314                 NO, JUMP\n         LA    @00,X'0080'             PSA ADDRESS\n         CLR   @02,@00                 PSA REFERENCE?\n         BL    @STR314                 YES, JUMP\n         SR    @03,@02                 CALCULATE LENGTH\n@STR314  EQU   *\n         AIF   (NOT &$$FEAT(6)).FEAT6A\n         TM    @STRFLAG,@STRBIN        BINARY FIELD?\n         BO    @STR328                 YES, JUMP\n.FEAT6A  ANOP\n         AIF   (NOT &$$FEAT(4)).FEAT4A\n         TM    @STRFLAG,@STRPACK       PACKED FIELD?\n         BO    @STR351                 YES, JUMP\n.FEAT4A  ANOP\n         AIF   (NOT &$$FEAT(7)).FEAT7A\n         TM    @STRFLAG,@STRHEX        EDIT IN HEX?\n         BO    @STR376                 YES, JUMP\n.FEAT7A  ANOP\n.*\n.*       TRUNCATE CHARACTER STRING\n.*\n         AIF   (NOT &$$FEAT(11)).FEAT11A\n         CLI   @STRLEN2,@STRLEFT       CHECK JUSTIFICATION, OUTPUT LEN\n         BNE   @STR390                 NO STRING TRUNCATION, JUMP\n         LA    @01,0(@03,@02)          FIRST BYTE AFTER FIELD\n@STR318  BCTR  @01,0                   DOWN 1 BYTE                 LOOP\n         CLI   0(@01),C' '             IS IT A SPACE ?             LOOP\n         BNE   @STR390                 LAST NON-BLANK BYTE         LOOP\n         BCT   @03,@STR318             LOOP UNTIL 1ST NON-BLANK    LOOP\n         B     @STR398                 BLANK FIELD, DO NOT EDIT\n         AGO   .FEAT11B\n.FEAT11A ANOP\n         AIF (&$$FEAT(2)+&$$FEAT(3)+&$$FEAT(4)+&$$FEAT(6) EQ 0).FEAT11B\n         B     @STR390                 EDIT\n.FEAT11B ANOP\n.*\n.*       REGISTER (R0-R13)\n.*\n         AIF   (NOT &$$FEAT(2) AND NOT &$$FEAT(3)).FEAT23B\n@STR323L LR    @00,*-*                 COPY VALUE FOR EDIT\n@STR323  LH    @01,@STRSCON            REG NUMBER IN BITS 28-31\n         EX    @01,@STR323L            COPY R7-R13 INTO R0\n         CLI   @STRSCON+1,@06+1        IS THIS R7-R13?\n         BNL   @STR323T                YES, JUMP\n         SLL   @01,2                   R1= 000000BB BASE * 4\n         L     @00,20(@01,@13)         PICK UP VALUE FOR R0-R6\n@STR323T EQU   *\n         AIF   (NOT &$$FEAT(3)).FEAT3R REG,HEX\n         AIF   (NOT &$$FEAT(2)).FEAT2H REG,BIN\n         TM    @STRFLAG,@STRHEX        EDIT IN HEX?\n         BNO   @STR330                 NO, EDIT FWD\n.FEAT2H  ANOP\n         STCM  @00,B'1111',@STRDWD-1   STORE IT FOR CVD/UNPK\n         LA    @03,8                   OUTPUT LENGTH\n         B     @STR376X                EDIT IN HEX\n.FEAT3R  ANOP\n         AIF   (NOT &$$FEAT(6)).FEAT23B\n         B     @STR330                 EDIT R0\n.FEAT23B ANOP\n.*\n.*       BINARY VARIABLE: @03 CONTAINS THE ICM MASK (1 3 7 F)\n.*\n         AIF   (NOT &$$FEAT(6)).FEAT6B\n@STR328M ICM   @00,*-*,0(@02)          **EXECUTED INSTRUCTION**\n@STR328  SLR   @00,@00\n         EX    @03,@STR328M            LOAD THE BINARY VARIABLE\n.FEAT6B  ANOP\n.*\n         AIF   (NOT &$$FEAT(2) AND NOT &$$FEAT(6)).FEAT6C\n@STR330  CVD   @00,@STRDWD             CONVERT VALUE TO DECIMAL\n         AIF   (NOT &$$FEAT(4)).FEAT6C\n         B     @STR361                 EDIT DWD\n.FEAT6C  ANOP\n.*\n.*       PACKED FIELD\n.*\n         AIF   (NOT &$$FEAT(4)).FEAT4B\n@STRZAP  ZAP   @STRDWD,0(*-*,@02)      MOVE TO @STRDWD\n@STR351  LA    @03,0(,@02)             FIRST BYTE OF PACKED FIELD\n         BALR  @14,0\n         TM    0(@03),X'0C'            IS THIS THE SIGN BYTE?\n         LA    @03,1(,@03)              (NEXT BYTE)\n         BNOR  @14                     NO, LOOP MORE\n         SLR   @03,@02                 GET LENGTH OF PACKED FIELD\n         BCTR  @03,0\n         EX    @03,@STRZAP             EXECUTE ZAP\n         AIF   (NOT &$$FEAT(5)).FEAT4B\n         CLI   @STRLEN2,248            JULIAN-TO-YYMMDD CONV?\n         BNL   @STR375                 YES, JUMP\n.FEAT4B  ANOP                          PACKED\n.*\n.*       EDIT @STRDWD (BIN, REG, PACKED)\n.*\n         AIF   (NOT &$$FEAT(8)).FEAT8B\n@STR361  IC    @00,@STRLEN2            OUTPUT LENGTH\n         LA    @03,X'003F'             MASK FOR \"AND\"\n         NR    @03,@00                 OUTPUT LENGTH\n         MVC   @STRWK16(16),@STRMASK   EDIT MASK\n.*\n.*       LEFT-JUSTIFICATION (NUMERIC)\n.*\n         AIF   (NOT &$$FEAT(9)).FEAT9B\n         TM    @STRLEN2,@STRLEFT       LEFT JUSTIFICATION?\n         BNO   @STR367                 NO, JUMP\n         LA    @01,@STRWK16+15         PREVENT BAD R1\n         EDMK  @STRWK16(16),@STRDWD    ZONED DECIMAL\n         LA    @02,0(,@01)             FIRST STRING POSITION\n         LTR   @03,@03                 CHECK OUTPUT LENGTH\n         BNZ   @STR363                 JUMP IF NOT ZERO\n.*       L0    (LEFT JUSTIFIED, NO PADDING)\n         LA    @03,@STRWK16+16         FIRST POSITION AFTER STRING\n         SR    @03,@02                 COMPUTE STRING LENGTH\n         B     @STR390                 MOVE FIELD TO OUTPUT LINE\n.*       L1-L63 (LEFT JUSTIFIED, PADDING)\n@STR363  CR    @03,@05                 COMPARE LENGTH TO REMAINING LEN\n         BNH   @STR364                 LARGE ENOUGH, JUMP\n         LR    @03,@05                 TOO BIG, TRUNCATE TO REM. LEN.\n@STR364  SR    @05,@03                 COMPUTE REMAINING LENGTH\n         LR    @00,@04                 POINTER IN OUTPUT LINE\n         LR    @01,@03                 LENGTH WITH PADDING\n         LA    @03,@STRWK16+16         FIRST POSITION AFTER STRING\n         SR    @03,@02                 COMPUTE STRING LENGTH\n         B     @STR392                 MOVE FIELD TO OUTPUT LINE\n@STR367  EQU   *\n.FEAT9B  ANOP\n         AIF   (NOT &$$FEAT(10)).FEAT10B\n         TM    @STRLEN2,@STRZERO       LEADING ZEROES REQ'D?\n         BNO   @STR368                 NO, JUMP\n         MVI   @STRWK16,C'0'           YES, CHANGE X'40' TO C'0'\n@STR368  EQU   *\n.FEAT10B ANOP\n         ED    @STRWK16(16),@STRDWD    ZONED DECIMAL\n         LA    @02,@STRWK16+16         FIRST POSITION AFTER STRING\n         SR    @02,@03                 FIRST STRING POSITION\n.FEAT8B  ANOP\n.*\n.*       LITERAL (@STRSCON IS A 16-BIT OFFSET)\n.*       Short Literal (low-order 4 bits of @STRFLAG contains length)\n.*       BLANKS  (@STRSCON=ZERO)\n.*\n         AIF   (NOT &$$FEAT(1)).FEAT1B\n         B     @STR390                 MOVE STRING TO OUTPUT LINE\n@STR372  LA    @01,7                   mask for NR\n         LA    @02,@STRLEN2            1st byte of short literal\n         IC    @03,@STRFLAG            pick up flags+length\n         NR    @03,@01                 R3 has length of short literal\n         BNZ   @STR390                 short literal, go move it\n         SLR   @02,@02                 Clear Address Register\n         IC    @03,@STRLEN2            GET LITERAL LENGTH\n         TM    @STRFLAG,@STRX40        string of spaces?\n         BO    @STR390                 yes, go move them\n         ICM   @02,B'0011',@STRSCON    LOAD LITERAL OFFSET\n         LA    @02,@STRSCON(@02)       CONVERT OFFSET TO FULL ADDRESS\n.FEAT1B  ANOP\n.*\n.*       CONVERT JULIAN DATE TO YYMMDD\n.*\n         AIF   (NOT &$$FEAT(5)).FEAT5F\n         B     @STR390                 MOVE STRING TO OUTPUT LINE\n@STR375  LA    @00,248                 MASK FOR 'SLR'\n         SLR   @01,@01\n         IC    @01,@STRLEN2            248-255\n         SLR   @01,@00                 000-007\n         LA    @00,12                  L'@STR375W\n         MR    @00,@00                 COMPUTE OFFSET\n         LA    @01,@STR375W(@01)       ENTRY IN \"TR\" MASK TABLE\n         SLR   @03,@03\n         IC    @03,0(,@01)             LENGTH OF DATE (6, 8 OR 10)\n         ZAP   @STRDWD,@STRDWD         DATE=0000000?               @JDT\n         BNZ   @STR375B                NO, JUMP                    @JDT\n@STR375Z LA    @02,@BLANKS             WORK AREA\n&BLANKS  SETA  10                      WE NEED AT LEAST 10 BLANKS\n         B     @STR390                 MOVE FIELD TO OUTPUT LINE\n@STR375W DC    AL1(10,C'-',0,1,2,3,8,4,5,8,6,7) YYYY-MM-DD   248\n         DC    AL1(8,C' ',0,1,2,3,4,5,6,7,8,8)  YYYYMMDD//   249\n         DC    AL1(8,C'/',2,3,8,4,5,8,6,7,8,8)  YY/MM/DD//   250\n         DC    AL1(8,C'/',6,7,8,4,5,8,2,3,8,8)  DD/MM/YY//   251\n         DC    AL1(8,C'/',4,5,8,6,7,8,2,3,8,8)  MM/DD/YY//   252\n         DC    AL1(6,C' ',2,3,4,5,6,7,8,8,8,8)  YYMMDD       253\n.*       DC    AL1(6,C' ',6,7,4,5,2,3,8,8,8,8)  DDMMYY       254\n.*       DC    AL1(6,C' ',4,5,6,7,2,3,8,8,8,8)  MMDDYY       255\n@STR375T DC    P'59,31,29,31,30,31,30,31,31,30,31,30,31'\n         DC    P'999'                  Prevent S0C7 with 90366\n@STR375B CLI   @STRDWD+4,X'01'         YEAR 2000 OR ABOVE?\n         BH    @STR375C                CC>01, JUMP (MUST BE 19 OR 20)\n         MVI   @STRDWD+4,X'20'         CC=01, CHANGE TO CC=20\n         BE    @STR375C                CC=01, USE CC=20\n         CLI   @STRDWD+4+1,X'50'       YY<50?\n         BL    @STR375C                YES, USE CC=20\n         MVI   @STRDWD+4,X'19'         NO, FORCE CC=19\n@STR375C UNPK  @STRWK16(5),@STRDWD+4(3) CCYY?\n         ZAP   @STRDWD+1(2),@STR375T+9(1) INIT MONTH COUNTER\n         LA    @02,@STR375T            TABLE OF MONTHS (NUMBER OF DAYS)\n         TM    @STRDWD+4+1,X'01'       ODD YEARS\n         BO    @STR375N                  AREN'T LEAP YEARS\n         TM    @STRDWD+4+1,X'12'       ZEROES IN 1980, ALL ONES IN 1992\n         BNM   @STR375L                MIXED IN 1982/1990\n.*       IF IT'S NOT A LEAP YEAR AND DDD>59, THEN ADD 1 TO DDD\n@STR375N CP    @STRDWD+4+2(2),@STR375T ARE WE PAST FEB 28 (DDD>59) ?\n         BNH   @STR375L                NO, JUMP\n         AP    @STRDWD+4+2(2),@STR375T+3(1) ADD 1 (FROM 31) TO DDD\n.*--LOOP WHILE DDD > 0\n@STR375L AP    @STRDWD+1(2),@STR375T+3(1)   ADD 1 (FROM 31) TO MONTH\n         LA    @02,2(,@02)             NEXT ENTRY IN \"MONTHS\" TABLE\n         SP    @STRDWD+4+2(2),0(2,@02) SUB DAYS-IN-MONTH FROM DDD\n         BP    @STR375L\n.*--ENDLOOP\n         AP    @STRDWD+4+2(2),0(2,@02) UNDO LAST \"SP\" INSTRUCTION\n         UNPK  @STRWK16+4(2),@STRDWD+1(2) FYFYFYFY,FMCM??\n         UNPK  @STRWK16+6(2),@STRDWD+6(2) FYFYFYFY,FMCMFDCD\n         MVZ   @STRWK16+1(7),@STRWK16     FYFYFYFY,FMCMFDCD\n         MVC   @STRWK16+8(1),1(@01)    SEPARATOR\n         LA    @02,@STRWK16+9          WORK AREA\n         MVC   0(10,@02),2(@01)        MOVE CORRESPONDING MASK\n         TR    0(10,@02),@STRWK16      CONVERT DATE TO THE RIGHT FORMAT\n.FEAT5F  ANOP                          JDATE\n.*\n.*       HEX STRING\n.*\n         AIF   (NOT &$$FEAT(7)).FEAT7B\n         B     @STR390                 MOVE STRING TO OUTPUT LINE\n@STR376M MVC   @STRDWD-1(*-*),0(@02)   PREVENT S0C4 IN UNPK\n@STR376  LA    @00,8                   MAX LENGTH\n         CLR   @03,@00                 CHECK LENGTH\n         BNH   @STR376B                JUMP IF LE 8\n         LR    @03,@00                 TRUNCATE TO MAXIMUM LENGTH\n@STR376B LR    @01,@03                 INPUT LENGTH\n         BCTR  @01,0\n         EX    @01,@STR376M            MOVE DATA TO SAFE STORAGE\n         ALR   @03,@03                 OUTPUT LENGTH\n         AGO   .FEAT37B\n.FEAT7B  ANOP\n         AIF   (NOT &$$FEAT(3)).FEAT37C\n         B     @STR390                 MOVE STRING TO OUTPUT LINE\n.FEAT37B ANOP\n@STR376X LA    @02,@STRWK16            WORK AREA\n         UNPK  0(9,@02),@STRDWD-1(5)   EXPAND SOURCE BYTES FOR \"TR\"\n         UNPK  8(9,@02),@STRDWD+3(5)   EXPAND SOURCE BYTES FOR \"TR\"\n         TR    0(16,@02),@STRHEXT-240  =C'0123456789ABCDEF'\n.FEAT37C ANOP\n.*\n.*       %TIME\n.*\n         AIF   (NOT &$$FEAT(12)).FEAT12B\n         B     @STR390                 MOVE STRING TO OUTPUT LINE\n@STRTIME DC    X'4021207A20207A20207A20204000'    0X.XX.XX.XX\n@STR378  LR    @02,@15                 SAVE BASE REG\n         TIME  DEC                     GET HHMMSSHH\n         LR    @15,@02                 RESTORE BASE REG\n         ST    @00,@STRDWD             STORE HHMMSSHH\n         MVC   @STRWK16(13),@STRTIME   MOVE EDIT MASK\n         ED    @STRWK16(13),@STRDWD    EDIT HH:MM:SS:HH\n         LA    @02,@STRWK16+1          WORK AREA\n         LA    @03,12                  HH:MM:SS:HH+ SPACE\n.FEAT12B ANOP\n.*MOVE\n@STR390  CR    @03,@05                 COMPARE LENGTH TO REMAINING LEN\n         BNH   @STR391                 LARGE ENOUGH, JUMP\n         LR    @03,@05                 TOO BIG, TRUNCATE TO REM. LEN.\n@STR391  SR    @05,@03                 COMPUTE REMAINING LENGTH\n         LR    @00,@04                 POINTER IN OUTPUT LINE\n         LR    @01,@03                 PASS REMAINING LENGTH\n         LTR   @02,@02                 BLANKS?\n         BNZ   @STR392                 NO, JUMP\n         SLR   @03,@03                 YES, ZERO LENGTH\n@STR392  ICM   @03,B'1000',@BLANKS     PAD WITH BLANKS\n         MVCL  @00,@02                 MOVE FIELD TO OUTPUT LINE\n         LR    @04,@00                 NEW POINTER IN OUTPUT LINE\n@STR398  TM    @STRFLAG,@STRLAST       TEST LAST-ENTRY INDICATOR\n         BO    @STR399                 Done, exit\n         AIF   (NOT &$$FEAT(1)).FEAT1C\n         TM    @STRFLAG,@STRLIT+@STRX40 literal or spaces?\n         BM    @STR398L                Literal, not spaces\n         BZ    @STR398X                Neither literal nor spaces\n         LA    @06,@STRSCON            2-byte entry for blank spaces\n         B     @STR310                 PROCESS NEXT ENTRY\n@STR398L LA    @01,7                   mask for NR\n         IC    @03,@STRFLAG            pick up flags+length\n         NR    @03,@01                 R3 has length of short literal\n         BZ    @STR398T                not an in-line literal, jump\n         LA    @06,@STRLEN2(@03)       Skip VL parm for in-line literal\n         B     @STR310                 PROCESS NEXT ENTRY\n@STR398T LA    @06,@STRFLEN            4-byte parm for remote literal\n         B     @STR310                 PROCESS NEXT ENTRY\n.FEAT1C  ANOP\n@STR398X LA    @06,@STRNEXT            BUMP UP TO NEXT ENTRY\n         B     @STR310                 PROCESS NEXT ENTRY\n.*ENDLOOP\n.*\n.*       END-OF-LINE PROCESSING - PAD WITH BLANKS\n.*\n@STR399  SLR   @01,@01                 SET UP R1 FOR PADDING\n         ICM   @01,B'1000',@BLANKS     SET UP R1 FOR PADDING\n.***     DROP  @06,@13,@15\n         LA    @14,2                   INCREMENT\n         AL    @14,12(,@13)            RETURN ADDRESS\n         LR    @15,@04                 CURRENT POINTER IN OUTPUT FIELD\n         SL    @15,8(,@13)             CALCULATE LENGTH USED\n         MVCL  @04,@00                 PAD WITH BLANKS\n         LM    @00,@06,20(@13)         RESTORE WORK REGISTERS\n         STM   @06+1,@13-1,48(@13)     MAKE SAVE AREA LOOK NORMAL\n         OI    15(@13),1               SIMULATE \"T\" OPTION OF RETURN\n         BR    @14                     RETURN TO CALLER\n.*\n         AIF   (NOT (&$$FEAT(3) OR &$$FEAT(7))).FEAT37T\n@STRHEXT DC    C'0123456789ABCDEF'     HEX-TO-EBCDIC CONVERSION\n.FEAT37T ANOP\n         AIF   (NOT &$$FEAT(8)).FEAT8T\n@STRMASK DC    X'4020202020202020,2020202020202120'\n.FEAT8T  ANOP\n.**********************************************************************\n.*       Convert S-con to address                                     *\n.*             Input: GPR2 points to an S-CON in the remote parm list *\n.*             Output: GPR2 contains the address                      *\n.**********************************************************************\n@STRS2A  SLR   @00,@00\n         ICM   @00,B'0011',0(@02)      R0 = 0000BDDD\n         SRDL  @00,12                  R0 = 0000000B, R1= DDD.....\n         SRL   @01,20                  R1 = 00000DDD (DISPLACEMENT)\n         CLI   0(@02),@06*16+15        R7-R13?\n         BH    @STRS2A3                YES, JUMP\n.*BASE REG IS R0-R6\n         LTR   @02,@00                 IS R0 THE BASE REG?\n         BNZ   @STRS2A2                NO, JUMP\n         LTR   @02,@01                 IS THIS A PSA ADDRESS?\n         BNZR  @14                     YES, GOBACK\n@STRS2A2 SLL   @02,2                   R2= 000000BB BASE * 4\n         L     @02,20(@02,@13)         PICK UP BASE REG VALUE\n         LA    @02,0(@02,@01)          ADD BASE REG VALUE TO DISPL\n         BR    @14\n.*BASE REG IS R7-R13\n@STRS2A3 LR    @02,@00                 R2= 0000000B (BASE REG NUMBER)\n         EX    @02,@STRS2A4            ADD BASE REG VALUE TO DISPL\n         BR    @14\n@STRS2A4 LA    @02,0(*-*,@01)          ADD BASE REG VALUE TO DISPL\n@BLANKS  DC    CL((((*+&BLANKS+7-@STRING)/8)*8)-(*-@STRING))' '\n@STRSIZE EQU   *-@STRING               SIZE OF GENERATED CSECT\n         DROP  @06,@13,@15\n.**********************************************************************\n.*       WORK AREA (CALLER'S SAVE AREA)                               *\n.**********************************************************************\n@STRSAVE DSECT                         24-BYTE WORK AREA\n         DS    A(0,@STRSAVE,@STRSAVE,14,15,0,1,2,3,4,5,6)\n@STRWK16 DS    F'7,8,9,10'             WORK AREA\n@STRDWD  DS    D'1112'                 WORK AREA\n@STRPARM DSECT\n@STRFLAG DS    B                   +0  FORMAT, FLAGS\n@STRLAST EQU   X'80'                     LAST ENTRY\n@STRLIT  EQU   X'40'                     LITERAL, @STRSCON IS AN OFFSET\n@STRX40  EQU   X'20'                   String of Spaces\n.*             X'0F'                   CONVERSION REQUIRED\n.*                                     or length of short literal\n@STRHEX  EQU   X'08'                     HEXADECIMAL\n@STRBIN  EQU   X'04'                     BINARY\n@STRPACK EQU   X'02'                     PACKED\n@STRREG  EQU   X'01'                     REGISTER\n@STRLEN2 DS    B                   +1  FORMAT, OUTPUT LENGTH\n.*                                     or start of short literal\n@STRLEFT EQU   X'80'                     LEFT JUSTIFICATION\n@STRZERO EQU   X'40'                     LEADING ZEROES\n.*             X'3F'                     OUTPUT LENGTH, 0 MEANS TRUNC.\n@STRSCON DS    S                   +2  FIELD ADDRESS\n@STRFLEN DS    S                   +4  FIELD LENGTH\n@STRNEXT EQU   *                   +6\n.MEND    AIF   ('&PRINT' EQ 'NOGEN').MEND99\n         POP   PRINT\n.MEND99  MEND\n         EJECT\n**********************************************************************\n**********************************************************************\n********* TEST PROGRAM FOR THE 'STRING' MACRO ************************\n**********************************************************************\n**********************************************************************\n         MACRO                                            JDATE MACRO\n        @JDATE &DATE                                      JDATE MACRO\n         LA    R1,=P'&DATE'                               JDATE MACRO\n*** STRING ((R1),P),2X,((R1),P),INTO=XXX                  JDATE MACRO\n         STRING ((R1),P),2X,((R1),P,YYMMDD),INTO=XXX,     JDATE MACRO  X\n               3X,((R1),P,YY/MM/DD),                      JDATE MACRO  X\n               3X,((R1),P,DD/MM/YY),                      JDATE MACRO  X\n               3X,((R1),P,MM/DD/YY),                      JDATE MACRO  X\n               3X,((R1),P,YYYYMMDD),                      JDATE MACRO  X\n               3X,((R1),P,YYYY-MM-DD)                     JDATE MACRO\n         PUT   SYSPRINT,XXX                               JDATE MACRO\n         MEND                                             JDATE MACRO\n**********************************************************************\n         LCLC  &SYSVER,&SYSDATC\n&SYSVER  SETC  'XF'\n&SYSDATC SETC  '20'.'&SYSDATE'(7,2)'&SYSDATE'(1,2)'&SYSDATE'(4,2)\nTESTPGM  START X'015000'\n         BALR  R12,0\n         USING *,R12\n*LOAD EP=SYSDEBUG\n*LR R15,R0\n*BASSM R14,R15\n*STRING 1X,INTO=XXX\n*RC8     STRING ((R1),,R**B),((R1),,R22Z),((R1),,R16B),INTO=XXX\n         OPEN  (SYSPRINT,OUTPUT)\n         STRING 'Assembler is &SYSVER, DATE is &SYSDATC',INTO=XXX\n         PUT   SYSPRINT,XXX\n         STRING 'AMPERSAND=&& AND APOSTROPHE='' ',INTO=XXX\n         PUT   SYSPRINT,XXX\nRBPREFIX EQU   *\nRBINTCOD EQU   *+6,2,C'H'\n         L     R1,PSATOLD-PSA(0,0)\n         L     R1,0(,R1)               TCBRBP\n         L     R2,PSAAOLD-PSA(0,0)     ASCB\n         STRING 'SVC',(RBINTCOD-RBPREFIX(R1),H,R3Z),                   X\n               1X,(WWWW,,T),' - ',     VV.MM OF SVC RTNE               X\n               ((R8),,X),1X,           COM-REG ADDR                    X\n               'ASID=',(ASCBASID-ASCB(R2),,X),1X,                      X\n               PARM1,1X,               MAIN PGM NAME                   X\n               INTO=XXX\n         PUT   SYSPRINT,XXX\n*\n         LA    R2,XXX\n         STRING 1X,INTO=((R2),8)\n        @JDATE 90058\n        @JDATE 91059\n        @JDATE 93060\n        @JDATE 94365\n        @JDATE 80058\n        @JDATE 84059\n        @JDATE 88060\n        @JDATE 92061\n        @JDATE 00366\n         LA    R2,1234\n         STRING 'CVTPTR=X''',(CVTPTR,4,X),'''',INTO=XXX,               X\n               ' 1234=',((R2),,R4Z)\n         PUT   SYSPRINT,XXX\n         L     R1,CVTPTR(0,0)\n         STRING 'CVTDATE=',(56(R1),P,YYMMDD),INTO=XXX\n         PUT   SYSPRINT,XXX\n         LA    R0,1000\n         LA    R3,0033\n         STRING 'D1=/',D1,'/,WWWW=/',WWWW,'/',                         X\n               ((R3),,L),'/',((R3),,X),'/',((R0),,L),'/',              X\n               ((R3),,R9B),'/',INTO=XXX\n         LR    R4,R15                   LENGTH USED\n         PUT   SYSPRINT,XXX\n         STRING WWWW,                                                  X\n               (4(R13),4,X),'''',(4(R13),F),'''',                      X\n               (4(R13),F,L),'''',                                      X\n               (4(R13),F,L11),'''',                                    X\n               (4(R13),F,Z9),'''',                                     X\n               8X,'R4=',((R4),,L),      LENGTH USED                    X\n               INTO=XXX\n         PUT   SYSPRINT,XXX\n         STRING %TIME,D1,'B12345678B',5X,(CTR1,P),1X,PARM1,1X,PARM2,   X\n               INTO=XXX\n         PUT   SYSPRINT,XXX\n         LA    R3,17\n         STRING INTO=XXX,'CCC1234A',(D1,(R3)),'.',(CTR1,P,R7Z)\n         PUT   SYSPRINT,XXX\n         STRING C'DDN2(',(D1,,T),')',X'40C1C2,C3C4',                   +\n               ' PSATOLD=',(PSATOLD-PSA,,X),                           +\n               INTO=XXX\n         PUT   SYSPRINT,XXX\n         BALR  R0,0\n         STRING 'R0=',((R0),,X),'   16(R0)=',(16(R0),4,X),INTO=XXX\n         PUT   SYSPRINT,XXX\n         STRING 'R0=',((R0),,X),'   CTR1=',(CTR1,P,R5B),INTO=XXX\n         PUT   SYSPRINT,XXX\n         SLR   R0,R0\n         STRING 'R0=',((R0),,X),'   CTR1=',(CTR1,P,R5B),INTO=XXX\n         PUT   SYSPRINT,XXX\n*\nEXIT     SLR   R15,R15\n         SVC   3                       GOBACK\nD1       DC    C'D1-----D1    '\nWWWW     DC    C'WWWW'\nCTR1     DC    P'1'\nPARM1    DC    C'<-PARM1->'\nPARM2    DC    C'<-PARM2->'\nXXX      DS    CL132\nCVTPTR   EQU   0016,4,C'A'\nSYSPRINT DCB   DSORG=PS,DDNAME=SYSPRINT,MACRF=PM,RECFM=FB,LRECL=121\n         STRING GENERATE\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\nPSA      DSECT\nPSATOLD  EQU   *+X'21C',4,C'A'\nPSAAOLD  EQU   *+X'224',4,C'A'\nASCB     DSECT\nASCBASID EQU   *+36,2,C'X'\n         END\n//SYSPRINT DD SYSOUT=*\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSUT2   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSUT3   DD UNIT=VIO,SPACE=(CYL,2)\n//SYSGO    DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3120\n//*\n//GO      EXEC PGM=LOADER,PARM=PRINT,TIME=(,2)\n//SYSLIN   DD DSN=*.XFASM.SYSGO,DISP=(OLD,DELETE)\n//SYSLOUT  DD SYSOUT=*\n//SYSPRINT DD SYSOUT=*\n//ABNLTERM DD SYSOUT=*\n//ABNLIGNR DD DUMMY\n//SYSDEBUG DD SYSOUT=*\n//SYSUDUMP DD SYSOUT=*\n\n          +----------------------------------------+\n          +                                        +\n          +  Documentation for the STRINGXF macro  +\n          +                                        +\n          +       Last update: 30 July 2006        +\n          +                                        +\n          +----------------------------------------+\n\n  The STRING macro is functionally similar to the COBOL DISPLAY\n  or PL/I PUT EDIT instructions.\n\n  Using STRING, the assembler programmer can concatenate\n  any number of fields, edit each of them if necessary,\n  and receive the result in the specified work area.\n\n  Formats:\n\n    (1) label  STRING {field_specification1}\n                      {,field_specification2}...\n                      ,INTO=workarea|(workarea,length)\n                      {,PRINT=GEN|NOGEN}\n\n    (2) label  STRING GENERATE\n                      {,PRINT=GEN|NOGEN}\n\n\n  field_specification\n\n    Each field to be printed is described as a positional\n    operand.  Each operand specifies the field address, its\n    length, and its formatting requirements.\n\n    Four field description formats are supported:\n\n      1.   symbol\n      2.   (symbol,length,format)\n      3.   (d(r)|(r),length,format)\n      4.   ((r),,format)\n      5.   'character string'\n\n  Symbol specifies the field address.  It must be an\n    S-type (relocatable) address.\n\n  d(r) may be used to specify the field address in S/370\n    base-displacement format.  If d is zero, it may be omitted.\n    If d(r) or (r) is used, length must also be specified.  R14\n    and R15 may not be used.  If d(0) is used, it is handled the\n    way the assembler does, i.e. R0 as a base register is assumed\n    to contain zero: 16(0) is equivalent to 16, CVTPTR or, X'10'.\n\n  ((r),,format) specifies that (r) contains the value\n    itself, not an address.  R14 and R15 may not be used.\n\n  'character string' specifies a literal enclosed in single quotes\n    as specified in a DC instruction.  Hex strings or character\n    strings are supported.  The following expressions are equivalent:\n    'ABC' C'ABC' X'C1C2C3'\n\n  Length specifies the length and/or the type of the input field.\n    It may be specified as an integer, a symbol, a register, or a\n    constant.  When used with symbol, it overrides the assembled\n    length and/or type.  Length is required if field is specified\n    as d(r) or (r).  If a zero length is specified, the field is\n    ignored.\n\n        nn   field length in bytes\n        H    half-word\n        F    full-word\n        FL1  1-byte binary integer\n        FL3  3-byte binary integer\n        P    packed field\n        (r)  length of character string (R0 thru R12)\n        d(r) length of character string (R1 thru R12)\n\n  Notes:  If the field address is specified as a symbol that\n          has been defined previously in the program, the symbol\n          type is known and there is no need to specify it.\n\n          If the length is specified as (r) or d(r) and the value\n          is greater than the address itself, (r) or d(r) is\n          considered to be the end address +1 instead of the length.\n\n          The length is not specified for packed fields.  The\n          @STRING subroutine scans the field left-to-right until it\n          finds a byte with a valid sign in the low-order 4 bits.\n\n          If symbol is an arithmetic expression and no length is coded,\n          the implicit length will be that of the first symbol in the\n          expression;  for example, if symbol is coded as PSATOLD-PSA,\n          then the implicit length will be L'PSATOLD.\n\n          All numeric items are assumed positive.\n\n  format  optionally indicates editing options that must\n          be applied to a field.\n\n      L        left justified\n      R        right justified\n      nn       output length\n      0        adjust length\n      Z        leading zeroes\n      B        leading/trailing blanks\n      T        truncate character string after last non-blank\n      X        display in hexadecimal\n      YYMMDD   convert julian date to YYMMDD\n      YY/MM/DD convert julian date to YY/MM/DD\n      DD/MM/YY convert julian date to DD/MM/YY\n      MM/DD/YY convert julian date to MM/DD/YY\n      YYYYMMDD convert julian date to YYYYMMDD\n      YYYY-MM-DD convert julian date to YYYY-MM-DD\n\n    The default format depends on the field type:\n\n        Type                   Default Format\n\n        character string             L\n        FL1                          R3B\n        H or FL2                     R5B\n        other numeric fields         R7B\n\n    Note: L0 and T are equivalent for character strings.\n\n  'character string' is any character string enclosed in\n  single quotes.  Blank spaces may be specified as nnX,\n  where nn is the number of X'40' bytes you want to be\n  inserted in the output line.  %TIME may be specified to\n  obtain the current time in hh.mm.ss.hh format.\n\nINTO=workarea|(workarea,length)\n\n  INTO indicates the address and length of the output work area\n  into which the result of the concatenation should be placed\n  (left justified).  If the work area is too small, truncation\n  will occur.  If it is too large, it is padded with blanks.\n\n  The address may be a symbol, d(r) (S-type address) or (r).\n\n  The length may be specified as an integer, a symbol, a register,\n  or a constant; it is required if the address is coded as d(r) or\n  (r).  If length is not specified for a symbol-type address, the\n  assembled length of the symbol is used.\n\n  Upon return from STRING, R15 contains the length actually used\n  in the output work area (before padding).\n\nPRINT=GEN|NOGEN\n\n  This operand allows you to temporarily override the PRINT\n  specification (GEN or NOGEN).\n\nGENERATE (format 2)\n\n  The GENERATE format must be specified once at the end of the\n  program.  It generates the @STRING sub-routine as well as all\n  the literals specified in previous invocations of the macro.\n\n  The GENERATE format is specified as follows:\n\n         STRING GENERATE\n\nExamples:\n\n     STRING 'ERROR===>',LINE1,'<=== POS ',((R6),,L0),INTO=WORKAREA\n\n     STRING 8X,C'ERRORS FOUND: ',(ERRORS,,L0),INTO=((R7),44)\n\n     STRING 'CVT ADDR IS ',(CVTPTR,4,X),X'40C1C2C3C4',INTO=LINE\n\n     LA    R5,WORK+16              end addr +1\n     STRING 'R4=',((R4),,X),INTO=(WORK,(R5)),PRINT=GEN\n\n     STRING '//JOBLIB DD DSN=',(DSN1,,T),',DISP=SHR',INTO=((R2),72)\n\n     PUT   SYSLIN                  PUT Locate\n     LH    R0,SYSLIN+82            LRECL\n     STRING '   NAME  ',(4(R3),8,T),'(R)',INTO=((R1),(R0))\n\n     STRING GENERATE         Generate literals and sub-routine\n\n\nProgramming Notes:\n\n  A STRING macro generates only 8 bytes that need to be covered by\n  base registers.  More code is generated at the beginning of the\n  @STRING CSECT, but this code does not require addressability.\n  This is particularly useful when STRING calls specify a large\n  number of literals.\n\n  Additionally, STRING does not use A-type constants (ACON), but\n  S-type constants (SCON) which require symbols to be addressable\n  at the point in the program where STRING is issued.\n\n  While these addressing techniques reduce the number of base\n  registers required to cover the program's code and make it easier\n  to write reentrant programs, they will produce assembly errors in\n  the following situations:\n\n  a.  the CSECT in which STRING is used is longer than 64K\n\n  b.  symbols are not addressable at the point in the program\n      where STRING is issued\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SYSMOVE": {"ttr": 3333, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x06\\x00\\x00\\x00y\\x08o\\x01\\x06!\\x0f\\x13U\\x03\\x1c\\x01\\xb3\\x01]\\xc3\\xc2\\xe3\\xf4\\xf7\\xf2@@@@'", "ispf": {"version": "05.06", "flags": 0, "createdate": "1979-03-27T00:00:00", "modifydate": "2006-07-29T13:55:00", "lines": 796, "newlines": 435, "modlines": 349, "user": "CBT472"}, "text": "//GILBERTM JOB (ACCT#),SYSMOVE,\n// NOTIFY=&SYSUID,\n// CLASS=A,MSGCLASS=X,COND=(0,NE)\n//ASMXF EXEC PGM=IFOX00,PARM=(OBJECT,NODECK,NOESD,NORLD,ALIGN,NOXREF)\n***********************************************************************\n*                                                                     *\n* MODULE NAME = SYSMOVE                                               *\n*                                                                     *\n* DESCRIPTIVE NAME = Unload a PDS in IEHMOVE format                   *\n*                                                                     *\n* FUNCTION = The SYSMOVE program unloads a PDS to a sequential        *\n*        data set in IEHMOVE format.  The resulting data set          *\n*        (which is DSORG=PS,RECFM=FB,LRECL=80) can be written to      *\n*        disk or tape, and later used as input to IEHMOVE to          *\n*        reload the original PDS.                                     *\n*                                                                     *\n* STATUS = R506                                                       *\n*                                                                     *\n* AUTHOR = Gilbert Saint-Flour <carlos@gsf-soft.com>                  *\n*                                                                     *\n* NOTES = SEE BELOW                                                   *\n*                                                                     *\n*    DEPENDENCIES = STRING Macro                                      *\n*                                                                     *\n*    AUTHORIZATION = NONE                                             *\n*                                                                     *\n*    RESTRICTIONS = NONE                                              *\n*                                                                     *\n* MODULE TYPE = PROCEDURE, (BATCH PROGRAM)                            *\n*                                                                     *\n*    PROCESSOR = IBM OS/ASSEMBLER H VERSION 2 OR                      *\n*                IBM HIGH LEVEL ASSEMBLER/MVS                         *\n*                                                                     *\n*    MODULE SIZE = 4K                                                 *\n*                                                                     *\n*    ATTRIBUTES = REUSABLE, RMODE 24, AMODE 24,                       *\n*                 PROBLEM STATE, KEY 8                                *\n*                                                                     *\n* OPERATION = See Below                                               *\n*                                                                     *\n*        Sample invocation JCL:                                       *\n*                                                                     *\n*            //UNLOAD EXEC PGM=SYSMOVE                                *\n*            //SYSPRINT DD SYSOUT=*                                   *\n*            //SYSUT1   DD DSN=INPUT.PDS,DISP=SHR                     *\n*            //SYSUT2   DD DSN=OUTPUT.FLAT,DISP=(,CATLG),             *\n*            // UNIT=SYSDA,SPACE=(TRK,(50,50),RLSE)                   *\n*                                                                     *\n*        Notes:                                                       *\n*                                                                     *\n*          1. SYSMOVE is fully compatible with SMS (which is not the  *\n*             case with IEHMOVE).                                     *\n*                                                                     *\n*          2. SYSMOVE imposes no restriction on the BLKSIZE of SYSUT2 *\n*             which can be any multiple of 80 you choose.  However,   *\n*             in order for IEHMOVE to reload it successfully, the     *\n*             BLKSIZE of the unloaded data set must be 800.           *\n*                                                                     *\n*          3. SYSMOVE does not support NOTE lists (as created by the  *\n*             linkage editor for load-modules in overlay format).     *\n*                                                                     *\n*          4. SYSMOVE can unload a full PDS or a single member.       *\n*             If you want to unload several PDS's and/or selected     *\n*             members, use the merge/selection capabilities of        *\n*             IEBCOPY to create a temporary PDS, then run SYSMOVE     *\n*             to unload it.                                           *\n*                                                                     *\n*          5. SYSMOVE is a convenient way to distribute a PDS         *\n*             via a network; see \"usage notes\", below.                *\n*                                                                     *\n*          6. SYSMOVE can be used recursively to distribute several   *\n*             PDSs as a single FB/80 file: unload each PDS with       *\n*             SYSMOVE into a temporary FB/80, unload the temporary    *\n*             PDS with SYSMOVE, and ship the resulting sequential     *\n*             data set.  The receiver can use IEBGENER to copy each   *\n*             member to a sequential data set and feed it to          *\n*             IEHMOVE to reload each of the initial PDSs.             *\n*                                                                     *\n*          7. unloaded PDS's in IEHMOVE format can be processed       *\n*             in CMS with the TAPEMAC and TAPPDS commands.            *\n*                                                                     *\n*                                                                     *\n* ABENDS:     U0013 OPEN Failed, probably because a DD is missing     *\n*                                                                     *\n* USAGE NOTES: See below                                              *\n*                                                                     *\n*    Using SYSMOVE to distribute a PDS on PC diskettes.               *\n*                                                                     *\n*        SYSMOVE provides a convenient way to distribute a PDS via    *\n*        PC diskette, using the following procedure:                  *\n*                                                                     *\n*          1. unload the PDS with SYSMOVE                             *\n*                                                                     *\n*          2. download the unloaded data set to a PC in EBCDIC        *\n*             using the \"RECEIVE\" command:                            *\n*                                                                     *\n*                 RECEIVE pc_file_name unloaded_data_set_name         *\n*                                                                     *\n*          3. pack the PC file with PKZIP (or equivalent)             *\n*                                                                     *\n*          4. copy the packed file to a diskette                      *\n*                                                                     *\n*          5. send the diskette out; whoever you send it to           *\n*             does not need SYSMOVE to process it.                    *\n*                                                                     *\n*       On the receiving MVS system, re-create the PDS as follows:    *\n*                                                                     *\n*          1. unpack the diskette file (if it's been packed)          *\n*                                                                     *\n*          2. upload the unpacked file in EBCDIC                      *\n*             using the \"SEND\" command:                               *\n*                                                                     *\n*                 SEND pc_file_name unloaded_data_set_name            *\n*                      recfm(fb) lrecl(80) blksize(800)               *\n*                                                                     *\n*          3. load the uploaded data set into a PDS                   *\n*             using IEHMOVE:                                          *\n*                                                                     *\n*             //RELOAD EXEC PGM=IEHMOVE,PARM='POWER=4',REGION=2M      *\n*             //SYSUT1 DD DISP=OLD,UNIT=SYSALLDA,VOL=SER=nonsms       *\n*             //DD1    DD DSN=GILBERT.UNLOAD,DISP=SHR   INPUT VOLUME  *\n*             //DD2    DD DISP=OLD,UNIT=SYSALLDA,VOL=SER=nonsms       *\n*             //SYSPRINT DD SYSOUT=*                                  *\n*                COPY      DSNAME=GILBERT.UNLOAD,                    X*\n*                          TO=3380=nonsms,                           X*\n*                          RENAME=GILBERT.MYPDS,                     X*\n*                          CATLG                                      *\n*                                                                     *\n*       NOTE:  You may NOT specify SMS-managed volumes for either     *\n*              SYSUT1 (work files) or the output volume (DD2 in       *\n*              this example).  IEHMOVE uses SVC 32 (REALLOC), not     *\n*              dynamic allocation, and SVC 32 does not support        *\n*              SMS-managed volumes.                                   *\n*                                                                     *\n*CHANGE ACTIVITY                                                      *\n*                                                                     *\n*$401 Build DIRTABLE and process ALIAS entries like IEHMOVE:          *\n*        1. If an ALIAS has no corresponding member, turn off         *\n*           the ALIAS indicator in the directory entry                *\n*        2. Do not write the data pointed to by ALIAS entries,        *\n*           instead, write the directory entries immediately          *\n*           after the corresponding main member's data.               *\n*$402 Print number of records and bytes written to SYSUT2             *\n*$403 If a member name is specified on SYSUT1, unload only this member*\n*$404 Change date format to yyyy-mm-dd                                *\n*$405 Zero last reference date in F1-DSCB                             *\n*$506 OS/VS2                                                          *\n***********************************************************************\n         LCLC  &REL\n&REL     SETC  '506'                   Current version/release\nSYSMOVE  CSECT\n         SAVE  (14,12),,'GSF UTILITIES - SYSMOVE R&REL'\n         LR    R12,R15\n         USING SYSMOVE,R12\n         GETMAIN R,LV=DYNAML           GET DYNAMIC STORAGE\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LA    R14,72(,R1)             CLEAR WORKING STORAGE\n         LA    R15,DYNAML-72           CLEAR WORKING STORAGE\n         SLR   R1,R1                   CLEAR WORKING STORAGE\n         MVCL  R14,R0                  CLEAR WORKING STORAGE\n         LM    R13,R1,8(R13)\n         USING DYNAM,R13\n         L     R2,0(,R1)               point to PARM field\n*\n         OPEN  MF=(E,OPENLIST)         OPEN DATA SETS\n         LTR   R15,R15                 OPEN OK?\n         BZ    TITLE1                  YES, JUMP\n         ABEND 13                   <- OPEN failed\n***********************************************************************\n*                                                                     *\n*        Print the Title Line on SYSPRINT                             *\n*                                                                     *\n***********************************************************************\nTITLE1   TIME  DEC                     get time, date\n         STM   R0,R1,DWD               R0=HHMMSSHH,R1=00YYDDDF\n         LH    R3,0(,R2)               parm length\n         STRING '1GSF Utilities - SYSMOVE R&REL  ',                    X\n               (DWD+4,P,YYYY-MM-DD),2X,      YYYY-MM-DD                X\n               (DWD+0,1,X),':',(DWD+1,1,X),  HH:MM                     X\n               '  PARM=''',(2(R2),(R3)),'''',                          X\n               INTO=LINE\n         PUT   SYSPRINT,LINE           print title line\n*\n         LA    R0,JFCB1                JFCB IN DYNAMIC STORAGE\n         STCM  R0,B'0111',EXL1+1       UPDATE EXIT LIST\n         RDJFCB SYSUT2                 READ THE JFCB (SYSUT2)\n         MVC   JFCB2,JFCB1             save the SYSUT2 JFCB\n*\n         RDJFCB MF=(E,OPENDIRL)        READ THE JFCB (SYSUT1)\n*\n*        Save the member name specified on the SYSUT1 DD\n*\n         MVI   UT1MBR,FF               no member\n         TM    JFCBIND1,JFCPDS         member name specified on sysut1?\n         BNO   PASS1                   no, jump\n         NI    JFCBIND1,FF-JFCPDS      NO MEMBER\n         MVC   UT1MBR,JFCBELNM         SAVE MEMBER NAME\n***********************************************************************\n*                                                                     *\n*        READ THE DIRECTORY                                           *\n*                                                                     *\n*           1. READ SYSUT1 DIRECTORY                                  *\n*           2. COUNT DIRECTORY ENTRIES                                *\n*           3. COUNT DIRECTORY BLOCKS AFTER LOGICAL END OF DIRECTORY  *\n*                                                                     *\n***********************************************************************\nPASS1    OPEN  MF=(E,OPENDIRL),TYPE=J  OPEN DIRECTORY\n         USING PDS2,R6\n*LOOP\nPASS1A   BAL   R9,GETDIR            <- GET DIRECTORY ENTRY\n         CLI   PDS2,FF                 LOGICAL END OF DIRECTORY?\n         BE    PASS1F                  YES, EXIT\n         AL    R0,DIRTABLE             tally directory entry sizes\n         ST    R0,DIRTABLE             tally directory entry sizes\n         TM    PDS2INDC,PDS2ALIS       is this an alias?\n         BO    PASS1AL                 yes, jump\n         LA    R0,1                    COUNT MEMBERS\n         AL    R0,MEMBERS              COUNT MEMBERS\n         ST    R0,MEMBERS              COUNT MEMBERS\n         B     PASS1A\nPASS1AL  LA    R0,1                    COUNT ALIASES\n         AL    R0,ALIASES              COUNT ALIASES\n         ST    R0,ALIASES              COUNT ALIASES\n         B     PASS1A\n*ENDLOOP\n*LOOP\nPASS1F   GET   SYSUT1D              <- READ NEXT DIRECTORY BLOCK\n         LTR   R1,R1                   PHYSICAL END OF DIRECTORY?\n         BZ    PASS1EOD                YES, EXIT\n         LA    R0,1                    COUNT DIRECTORY BLOCKS\n         AL    R0,DIRBLKS              COUNT DIRECTORY BLOCKS\n         ST    R0,DIRBLKS              COUNT DIRECTORY BLOCKS\n         B     PASS1F\n*ENDLOOP\nPASS1EOD CLOSE MF=(E,OPENDIRL)         CLOSE DIRECTORY\n***********************************************************************\n*                                                                     *\n*        WRITE HEADER RECORDS                                         *\n*                                                                     *\n*           1. read the JFCB and the F1-DSCB                          *\n*           2. calculate the data set size                            *\n*           3. write UNLOAD header records                            *\n*                                                                     *\n***********************************************************************\n         LA    R0,78                   LENGTH OF HEADER RECORD\n         LA    R1,HDR1REC              ADDR OF HEADER RECORD\n         BAL   R9,WRITE                WRITE FIRST RECORD\n         MVC   DS1DSNAM,JFCBDSNM       MOVE DSNAME\n         MVC   DS1DSSN,JFCBVOLS        MOVE VOLSER\n         OBTAIN CAML26                 READ F1-DSCB\n         DEVTYPE DCBDDNAM-IHADCB+SYSUT1D,DVAREA,DEVTAB\n*\n         MVC   UNLDDIR,DIRBLKS+2       NUMBER OF DIRECTORY BLOCKS\n         MVI   UNLDFLAG,X'40'          AVG BLK\n         SLR   R1,R1\n         ICM   R1,B'0011',DS1LSTAR     LAST TRACK USED\n         LA    R1,1(,R1)               NUMBER OF TRACKS USED\n         ST    R1,TRKSUSED             NUMBER OF TRACKS USED\n         SLR   R2,R2\n         ICM   R2,B'0011',DVATRKLN     TRACK LENGTH\n         MR    R0,R2                   TRACKS * TRKLN\n         STCM  R1,B'1111',UNLDSIZE     STORE RESULT\n*\n         XC    DS1REFD,DS1REFD         ZERO THE LAST REF DATE\n*\n         TM    DS1SCALO,X'80'          ALLOC IN CYLINDERS OR TRACKS?\n         BZ    HDR1DEVT                NO, SET SSIZ=0\n         SLR   R1,R1\n         ICM   R1,B'0111',DS1SCAL3     LOAD NO OF CYLS IN R1\n         TM    DS1SCALO,X'40'          AVERAGE LENGTH?\n         BZ    HDR1SQTY                NO, JUMP\n         MH    R1,DVATRK               MULTIPLY BY NO OF CYL PER TRK\nHDR1SQTY MR    R0,R2                   TRACKS * TRKLN\n         STCM  R1,B'1111',UNLDSSIZ     SECONDARY SPACE IN BYTES\n*\nHDR1DEVT MVC   UNLDDEVT,DVAUCBTY       UCB TYPE\n         LA    R0,HDR2LEN              LENGTH\n         LA    R1,HDR2REC              BACK END\n         BAL   R9,WRITE                WRITE RECORD SEGMENT\n***********************************************************************\n*                                                                     *\n*        Print Characteristics of SYSUT1 & SYSUT2                     *\n*                                                                     *\n*          INPUT PDS:                                                 *\n*            DSNAME=GILBERT.LOAD,VOL=3380=SYS157                      *\n*            RECFM=U,LRECL=0,BLKSIZE=32760                            *\n*            DIRECTORY_BLOCKS=11,MEMBERS=24,ALIASES=2                 *\n*            TRACKS_USED=22,EXTENTS_ALLOCATED=2                       *\n*                                                                     *\n*          OUTPUT SDS:                                                *\n*            DSNAME=GILBERT.UNLOAD,VOL=SER=STR319                     *\n*            RECFM=FB,LRECL=80,BLKSIZE=800                            *\n*            RECORDS=100,BYTES=8000                                   *\n*                                                                     *\n***********************************************************************\nPRT10    STRING '0INPUT PDS:',INTO=LINE\n         PUT   SYSPRINT,LINE           print message\n         STRING '0  DSNAME=',(JFCBDSNM,,T),                            X\n               ',VOL=SER=',(JFCBVOLS,6),                               X\n               INTO=LINE\n         MVC   UNITNAME+8,DVAUCBTY     move device type\n         LINK  EP=IEFEB4UV,                                            X\n               PARAM=(UNITNAME,        work area                       X\n               =X'0100'),              function flags  \"7\"             X\n               MF=(E,DWD),VL=1\n         LTR   R15,R15                 OK?\n         BNZ   PRT13                   no, jump\n         LINK  EP=IEFEB4UV,                                            X\n               PARAM=(UNITNAME,        work area                       X\n               =X'2000'),              function flags  \"2\"             X\n               MF=(E,DWD),VL=1\n         LTR   R15,R15                 OK?\n         BNZ   PRT13                   no, jump\n         STRING '0  DSNAME=',(JFCBDSNM,,T),                            X\n               ',VOL=',(UNITNAME,,T),'=',(JFCBVOLS,6),                 X\n               INTO=LINE\nPRT13    PUT   SYSPRINT,LINE           print message\n         LA    R1,RECFM                RECFM for SYSUT1\n         BAL   R14,#RECFM1             B'11111111' -> C'VBSA'\n         STRING '   RECFM=',(RECFM,,T),                                X\n               ',LRECL=',(DS1LRECL,H,L),                               X\n               ',BLKSIZE=',(DS1BLKL,H,L),                              X\n               INTO=LINE\n         PUT   SYSPRINT,LINE           print message\n         STRING '   Directory_blocks=',(DIRBLKS,F,L),                  X\n               ',Members=',(MEMBERS,F,L),                              X\n               ',Aliases=',(ALIASES,F,L),                              X\n               INTO=LINE\n         PUT   SYSPRINT,LINE           print message\n         STRING '   Tracks_used=',(TRKSUSED,F,L),                      X\n               ',Extents_allocated=',(DS1NOEPV,FL1,L),                 X\n               INTO=LINE\n         PUT   SYSPRINT,LINE           print message\n*\n         STRING '0OUTPUT SDS:',INTO=LINE\n         PUT   SYSPRINT,LINE           print message\n         STRING '0  DSNAME=',(JFCBDSNM-INFMJFCB+JFCB2,,L),             X\n               ',VOL=SER=',(JFCBVOLS-INFMJFCB+JFCB2,,L),               X\n               INTO=LINE\n         PUT   SYSPRINT,LINE           print message\n         LA    R1,RECFM                RECFM for SYSUT1\n         BAL   R14,#RECFM1             B'11111111' -> C'VBSA'\n         STRING '   RECFM=FB,LRECL=80',                                X\n               ',BLKSIZE=',(DCBBLKSI-IHADCB+SYSUT2,H,L),               X\n               INTO=LINE\n         PUT   SYSPRINT,LINE           print message\n***********************************************************************\n*                                                                     *\n*        BUILD TABLE OF DIRECTORY ENTRIES                             *\n*                                                                     *\n***********************************************************************\n         LA    R0,1                    Room for X'FF' at end of table\n         AL    R0,DIRTABLE             SIZE OF DIRECTORY ENTRIES\n         GETMAIN RU,LV=(0),BNDRY=PAGE  GET STORAGE FOR DIRECTRY ENTRIES\n         STM   R0,R1,DIRTABLE          len/addr of dir entries\n         LR    R4,R1                   point to start of table\n         OPEN  MF=(E,OPENDIRL)         re-open DIRECTORY\n         MVI   DIRENTRY,FF             FIRST TIME SWITCH FOR \"GETDIR\"\n*LOOP\nBLDTBL1  BAL   R9,GETDIR            <- GET DIRECTORY ENTRY\n         CLI   PDS2,FF                 LOGICAL END OF DIRECTORY?\n         BE    BLDTBL9                 YES, EXIT\n         CLI   UT1MBR,FF               select a member ?\n         BE    BLDTBL6                 no, jump\n         CLC   PDS2NAME,JFCBELNM       IS IT MY MEMBER?\n         BE    BLDTBL6                 yes, jump\nBLDTBL5  ALR   R6,R0                   ignore this mbr\n         B     BLDTBL1                 next directory entry\nBLDTBL6  LR    R5,R0                   size of dir entry\n         LR    R7,R0                   size of dir entry\n         MVCL  R4,R6                   move directory entry to table\n         B     BLDTBL1                 next directory entry\n*ENDLOOP\nBLDTBL9  MVI   0(R4),FF                mark end of table\n         CLOSE MF=(E,OPENDIRL)         CLOSE DIRECTORY\n         FREEPOOL SYSUT1D              FREE BUFFERS\n         CL    R4,DIRTABLE+4           any member selected?\n         BE    EOJ                     no, exit\n***********************************************************************\n*                                                                     *\n*        Turn off ALIAS indicator in directory entries                *\n*        for which no main member is present.                         *\n*                                                                     *\n***********************************************************************\nUNALIAS  ICM   R0,B'1111',ALIASES      any ALIAS?\n         BZ    GETMBR                  no, exit\n         L     R6,DIRTABLE+4           first directory entry\n*LOOP\nUNALIAS1 TM    PDS2INDC,PDS2ALIS       is this an alias?\n         BNO   UNALIAS8                no, ignore it\n         L     R7,DIRTABLE+4           first directory entry\n         USING PDS2,R7\n*--loop\nUNALIAS2 TM    PDS2INDC,PDS2ALIS       is this an alias?\n         BO    UNALIAS3                yes, ignore it\n         CLC   PDS2TTRP,PDS2TTRP-PDS2(R6)   main mbr of my alias?\n         BE    UNALIAS8                yes, exit inner loop\nUNALIAS3 LA    R14,PDS2LUSR            MASK\n         N     R14,PDS2TTRP            SIZE OF USER DATA\n         ALR   R14,R14                 size of user data in bytes\n         LA    R7,PDS2USRD(R14)        NEXT DIRECTORY ENTRY\n         CLI   PDS2,FF                 LOGICAL END OF DIRECTORY?\n         BNE   UNALIAS2                NO, NEXT MEMBER\n*--endloop\n         DROP  R7                      was PDS2 (local only)\n         NI    PDS2INDC,FF-PDS2ALIS    turn off ALIAS indicator\n*\nUNALIAS8 LA    R14,PDS2LUSR            MASK\n         N     R14,PDS2TTRP            size of user data in half-words\n         ALR   R14,R14                 size of user data in bytes\n         LA    R6,PDS2USRD(R14)        NEXT DIRECTORY ENTRY\n         CLI   PDS2,FF                 LOGICAL END OF DIRECTORY?\n         BNE   UNALIAS1                NO, NEXT MEMBER\n*ENDLOOP\n***********************************************************************\n*                                                                     *\n*        PROCESS DIRECTORY ENTRIES AND MEMBER DATA                    *\n*                                                                     *\n*          1.  READ DIRECTORY ENTRIES FROM \"DIRTABLE\"                 *\n*          2.  READ MEMBERS FROM DDN=SYSUT1 USING BPAM                *\n*          3.  PASS RECORDS TO \"WRITE\" ROUTINE                        *\n*          4.  Write ALIAS entry after corresponding main member      *\n*                                                                     *\n***********************************************************************\nGETMBR   GETBUF SYSUT1M,(R3)           GET ADDR OF A BUFFER\n         ST    R3,DECB1+12             UPDATE BUFFER ADDR IN DECB\n         L     R6,DIRTABLE+4           first directory entry\n*LOOP\nGETMBR1  LA    R14,PDS2LUSR            MASK\n         N     R14,PDS2TTRP            SIZE OF USER DATA\n         LA    R0,12(R14,R14)          SIZE OF DIRECTORY ENTRY\n         TM    PDS2INDC,PDS2ALIS       is this an alias?\n         BO    GETMBR9                 yes, ignore it\n         STH   R0,DWD                  SIZE OF DIRECTORY ENTRY\n         MVI   DWD+2,X'C8'             THIS IS A DIRECTORY ENTRY\n         MVC   DWD+3(3),TTRN           TTRN OF PREVIOUS BLOCK\n         LA    R0,2+1+3                LENGTH,FLAGS,TTR\n         LA    R1,DWD                  002A,C8,00000A\n         BAL   R9,WRITE                WRITE RECORD SEGMENT\n         LH    R0,DWD                  SIZE OF DIRECTORY ENTRY\n         LA    R1,PDS2                 ADDR OF DIRECTORY ENTRY\n         BAL   R9,WRITE                WRITE RECORD SEGMENT\n         MVC   TTRN(3),8(R6)           TTR\n         FIND  SYSUT1M,TTRN,C          POINT TO MEMBER\n*--LOOP\nGETMBR2  READ  DECB1,SF,SYSUT1M,*-*,'S'\n         CHECK DECB1\n         MVC   DWD(2),DCBLRECL-IHADCB+SYSUT1M\n         MVI   DWD+2,X'E0'             DATA RECORD\n         NOTE  SYSUT1M                 GET TTR\n         STCM  R1,B'1110',DWD+3        SAVE TTR\n         LA    R0,2+1+3                LENGTH,FLAGS,TTR\n         LA    R1,DWD                  TTR\n         BAL   R9,WRITE                WRITE RECORD SEGMENT\n         LH    R0,DCBLRECL-IHADCB+SYSUT1M\n         L     R1,DECB1+12             BUFFER ADDR IN DECB\n         BAL   R9,WRITE                WRITE DATA\n         B     GETMBR2                 NEXT BLOCK\n*--ENDLOOP\n*\n*        Write ALIAS directory entries corresponding to the member\n*        just written\n*\nGETMBR8  ICM   R0,B'1111',ALIASES      any ALIAS?\n         BZ    GETMBR9                 no, jump\n         L     R7,DIRTABLE+4           first directory entry\n         USING PDS2,R7\n*--LOOP\nGETMBR8B LA    R14,PDS2LUSR            MASK\n         N     R14,PDS2TTRP            SIZE OF USER DATA\n         LA    R0,12(R14,R14)          SIZE OF DIRECTORY ENTRY\n         TM    PDS2INDC,PDS2ALIS       is this an alias?\n         BNO   GETMBR8N                no, ignore it\n         CLC   TTRN(3),PDS2TTRP        alias of member just written?\n         BNE   GETMBR8N                no, ignore it\n         STH   R0,DWD                  SIZE OF DIRECTORY ENTRY\n         MVI   DWD+2,X'C8'             THIS IS A DIRECTORY ENTRY\n         MVC   DWD+3(3),TTRN           TTRN OF PREVIOUS BLOCK\n         LA    R0,2+1+3                LENGTH,FLAGS,TTR\n         LA    R1,DWD                  002A,C8,00000A\n         BAL   R9,WRITE                WRITE RECORD SEGMENT\n         LH    R0,DWD                  SIZE OF DIRECTORY ENTRY\n         LA    R1,PDS2                 ADDR OF DIRECTORY ENTRY\n         BAL   R9,WRITE                WRITE RECORD SEGMENT\n         LH    R0,DWD                  SIZE OF DIRECTORY ENTRY\nGETMBR8N ALR   R7,R0                   NEXT DIRECTORY ENTRY\n         CLI   PDS2,FF                 LOGICAL END OF DIRECTORY?\n         BNE   GETMBR8B                NO, NEXT MEMBER\n*--ENDLOOP\n         DROP  R7                      was PDS2 (local only)\n*\nGETMBR9  LA    R14,PDS2LUSR            MASK\n         N     R14,PDS2TTRP            size of user data in half-words\n         ALR   R14,R14                 size of user data in bytes\n         LA    R6,PDS2USRD(R14)        NEXT DIRECTORY ENTRY\n         CLI   PDS2,FF                 LOGICAL END OF DIRECTORY?\n         BNE   GETMBR1                 NO, NEXT MEMBER\n*ENDLOOP\n***********************************************************************\n*                                                                     *\n*        END OF DIRECTORY                                             *\n*                                                                     *\n*          1.  WRITE AN EOF RECORD                                    *\n*          2.  CLOSE THE FILES                                        *\n*          3.  CLEAN UP                                               *\n*          4.  GOBACK                                                 *\n*                                                                     *\n***********************************************************************\nEOJ      LA    R0,3                    L'TTR\n         LA    R1,=X'0000,01'          LENGTH=0\n         BAL   R9,WRITE                WRITE EOF RECORD\n         LM    R4,R5,CURRENT           CURRENT ADDR & REMAINING LENGTH\n         SLR   R15,R15                 PADDING TO X'00'\n         MVCL  R4,R14                  PAD LAST RECORD\n*\nLASTMSG  LA    R1,80                   LRECL of SYSUT2 data set\n         M     R0,SEQNO                calculate number of bytes\n         STRING '   Records=',(SEQNO,F,L),',Bytes=',((R1),,L),INTO=LINE\n         PUT   SYSPRINT,LINE           print message\n*\nCLOSEALL CLOSE MF=(E,OPENLIST)         CLOSE ALL DATA SETS\n         FREEPOOL SYSUT1M              FREE BUFFERS\n         FREEPOOL SYSUT2               FREE BUFFERS\n         FREEPOOL SYSPRINT             FREE BUFFERS\n*\n         LM    R0,R1,DIRTABLE          len/addr of dir entries\n         FREEMAIN RU,LV=(0),A=(1)      free directory entry table\n*\nGOBACK   LR    R1,R13\n         L     R13,4(,R13)\n         FREEMAIN R,LV=DYNAML,A=(1)    FREE DYNAMIC STORAGE\n         RETURN (14,12),RC=00          GOBACK\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Read Directory Blocks from SYSUT1D and un-block them         *\n*                                                                     *\n*        Returns:                                                     *\n*                                                                     *\n*          R0 Length of the directory entry                           *\n*          R6 Address of the directory entry (8X'FF' at EOF)          *\n*                                                                     *\n*---------------------------------------------------------------------*\nGETDIR   ICM   R6,B'1111',DIRENTRY     CURRENT DIRECTORY ENTRY\n         BP    GETDIR4                 NOT FIRST TIME, JUMP\n*LOOP\nGETDIR1  GET   SYSUT1D                 READ DIRECTORY BLOCK\n         LA    R0,1                    COUNT DIRECTORY BLOCKS\n         AL    R0,DIRBLKS              COUNT DIRECTORY BLOCKS\n         ST    R0,DIRBLKS              COUNT DIRECTORY BLOCKS\n         LA    R6,2(,R1)               FIRST ENTRY IN THIS BLOCK\n         B     GETDIR9                 EXIT\n*--LOOP\nGETDIR4  LA    R14,PDS2LUSR            MASK\n         N     R14,PDS2TTRP            SIZE OF USER DATA\n         LA    R14,12(R14,R14)         SIZE OF DIRECTORY ENTRY\n         L     R15,DCBRECAD-IHADCB+SYSUT1D  1ST BYTE OF CURR DIR BLK\n         AH    R15,0(,R15)             LENGTH OF CURR DIR BLK\n         BCTR  R15,0                   LIMIT FOR BXH\n         BXH   R6,R14,GETDIR1          SIZE\n*--ENDLOOP\nGETDIR9  ST    R6,DIRENTRY             SAVE ADDR OF CURR DIR ENTRY\n         LA    R14,PDS2LUSR            MASK\n         N     R14,PDS2TTRP            SIZE OF USER DATA\n         LA    R0,12(R14,R14)          SIZE OF DIRECTORY ENTRY\n         BR    R9\n*---------------------------------------------------------------------*\n*                                                                     *\n*        Write Records to SYSUT2 in IEHMOVE format                    *\n*                                                                     *\n*---------------------------------------------------------------------*\nWRITE    LR    R2,R1                   ADDRESS\n         LR    R3,R0                   LENGTH\n         LM    R4,R5,CURRENT           CURRENT ADDR & REMAINING LENGTH\n*LOOP\nWRITE1   LTR   R5,R5                   ANY SPACE LEFT IN PREVIOUS RCD?\n         BP    WRITE2                  YES, JUMP\n         PUT   SYSUT2                  NO, LOCATE ANOTHER\n         LA    R0,1                    BUMP SEQNO\n         AL    R0,SEQNO                BUMP SEQNO\n         ST    R0,SEQNO                BUMP SEQNO\n         STH   R0,0(,R1)               BUMP SEQNO\n         LA    R4,2(,R1)               ADDRESS\n         LA    R5,78                   LENGTH\nWRITE2   LR    R14,R4                  \"TO\" ADDR\n         LR    R15,R5                  \"TO\" ADDR\n         CLR   R15,R3                  INREC TOO BIG?\n         BL    WRITE3                  NO, JUMP\n         LR    R15,R3                  YES, TRUNCATE\nWRITE3   ALR   R4,R15                  BUMP ADDR\n         SLR   R5,R15                  DECREASE LENGTH\n         MVCL  R14,R2                  FILL IN RECORD\n         LTR   R3,R3                   INPUT RECORD ALL MOVED?\n         BP    WRITE1                  NOT YET, KEEP ON MOVING\n*ENDLOOP\n         STM   R4,R5,CURRENT           CURRENT ADDR & REMAINING LENGTH\nWRITE99  BR    R9\n*---------------------------------------------------------------------*\n*                                                                     *\n*        RECFM Edit Routine                                           *\n*                                                                     *\n*---------------------------------------------------------------------*\n#RECFM1  MVC   RECFM,BLANKS            INITIALIZE RECFM AREA\n         MVI   0(R1),C'U'\n         TM    DS1RECFM,DS1RECFU       RECFM=U?\n         BO    #RECFM2                 YES, JUMP\n         MVI   0(R1),C'F'\n         TM    DS1RECFM,DS1RECFF       RECFM=F?\n         BO    #RECFM2                 YES, JUMP\n         MVI   0(R1),C'V'\n#RECFM2  TM    DS1RECFM,DS1RECFB       RECFM=.B ?\n         BNO   #RECFM3                 NO, JUMP\n         MVI   1(R1),C'B'              .B\n         LA    R1,1(,R1)\n#RECFM3  TM    DS1RECFM,DS1RECFS       RECFM=..S ?\n         BNO   #RECFM4                 NO, JUMP\n         MVI   1(R1),C'S'              ..S\n         LA    R1,1(,R1)\n#RECFM4  TM    DS1RECFM,DS1RECFA       RECFM=...A ?\n         BNO   #RECFM5                 NO, JUMP\n         MVI   1(R1),C'A'              ...A\n#RECFM5  TM    DS1RECFM,DS1RECMC       RECFM=...M ?\n         BNO   #RECFM6                 NO, JUMP\n         MVI   1(R1),C'M'              ...M\n#RECFM6  TM    DS1RECFM,DS1RECFT       RECFM=...T ?\n         BNOR  R14                     NO, JUMP\n         MVI   1(R1),C'T'              ...T\n         BR    R14\n***********************************************************************\n*                                                                     *\n*        DATA AREAS                                                   *\n*                                                                     *\n***********************************************************************\nOPENLIST OPEN  (SYSUT1M,,SYSUT2,OUTPUT,SYSPRINT,OUTPUT),MF=L\nOPENDIRL OPEN  (SYSUT1D),MF=L\nSYSUT1D  DCB   DSORG=PS,MACRF=GL,DDNAME=SYSUT1,EODAD=ENDOFDIR,         X\n               EXLST=EXL1,RECFM=U,BLKSIZE=256\nEXL1     DC    A(X'87000000')          DCB EXIT LIST (SYSUT1)\nENDOFDIR SLR   R1,R1\n         BR    R14\nSYSUT1M  DCB   DSORG=PO,MACRF=R,DDNAME=SYSUT1,EODAD=GETMBR8,           X\n               RECFM=U,BUFNO=1\nSYSUT2   DCB   DSORG=PS,MACRF=PL,DDNAME=SYSUT2,                        X\n               EXLST=EXL1,RECFM=FB,LRECL=80\nSYSPRINT DCB   DSORG=PS,MACRF=PM,DDNAME=SYSPRINT,                      X\n               RECFM=FBA,LRECL=121\nCAML26   CAMLST SEARCH,DS1DSNAM,DS1DSSN,DS1FMTID\nBLANKS   DC    CL6' '                  CL(L'RECFM)' '\nFF       EQU   X'FF'\n*\n*        HEADER RECORDS (IEHMVSSX/IEHMVSXY)\n*\nHDR1REC  DC    H'75',X'0E'             HEADER RECORD\n         DC    C'THIS IS AN UNLOADED DATA SET PRODUCED BY',X'80'\n         DC    C'THE IBM UTILITY, SYSMOVE.'\n         DC    C'OMMBRLDWB'            WHATEVER\n*\nHDR2REC  DC    AL2(HDR2LEN-3)          L'DSCB1 + 57\n         DC    X'00'                   NO FLAGS\n         IECSDSL1 1                    F1-DSCB\nDS1RECFU EQU   X'C0'\nDS1RECFF EQU   X'80'\nDS1RECFT EQU   X'20'\nDS1RECFB EQU   X'10'\nDS1RECFS EQU   X'08'\nDS1RECFA EQU   X'04'\nDS1RECMC EQU   X'02'\nDS1SCAL3 EQU   DS1SCALO+1,3\nUNLDDIR  DS    XL2                     DIRECTORY QUANTITY\nUNLDFLAG DS    XL1                     UNLOAD CONTROL FLAG\nUNLDSIZE DS    XL4                     PRIM ALLOC OF DS (IN BYTES)\nUNLDSSIZ DS    XL4                     SEC ALLOCATION OF DS (IN BYTES)\nUNLDSPAR DS    XL42                    UNUSED SPARE BYTES\nUNLDDEVT DS    XL4                     FROM DEVICE TYPE\nHDR2LEN  EQU   *-HDR2REC\n*---------------------------------------------------------------------*\n*                                                                     *\n*        DYNAMIC STORAGE AREA                                         *\n*                                                                     *\n*---------------------------------------------------------------------*\nDYNAM    DSECT\n         DS    18F                     SAVE AREA\nUT1MBR   DS    CL8                     SYSUT1 member\nDWD      DS    D\nUNITNAME DS    CL8,XL4,XL4,XL4,XL8     IEFEB4UV\nDIRENTRY DS    A                       DIRECTORY ENTRY\nDIRBLKS  DS    F                       NUMBER OF DIRECTORY BLOCKS\nMEMBERS  DS    F                       NUMBER OF MEMBERS\nALIASES  DS    F                       NUMBER OF ALIASES\nDIRTABLE DS    F,A                     addr/size of dir entry table\nTRKSUSED DS    F                       NUMBER OF tracks used\nCURRENT  DS    A,F                     OUTPUT ADDR, LENGTH\nTTRN     DS    F                       TTRN OF FIRST/CURRENT BLOCK\nSEQNO    DS    F                       SYSUT2 RECORD SEQUENCE NUMBER\nRECFM    DS    C'VBSAMT'               Record Format\nLINE     DS    CL121                   print line\n         DS    0F                      ALIGN DVAREA\n         IHADVA DSECT=NO               DEVTYPE AREA\n         ORG   ,                       ALIGN DVAREA\nJFCB1    DS    0F                      First JFCB for SYSUT1\n         IEFJFCBN                      JFCB for SYSUT1\nJFCB2    DS    XL(*-JFCB1)             JFCB for SYSUT2\nDYNAML   EQU   *-DYNAM\n*\n         DCBD  DSORG=PS,DEVD=DA\n*@@      IHAPDS DSECT=YES,PDSBLDL=NO\nPDS2     DSECT\nPDS2NAME DS    CL8                     member name\nPDS2TTRP DS    XL3                     TTR\nPDS2INDC DS    X                       flags, length of user data\nPDS2ALIS EQU   X'80'                   ALIAS entry\nPDS2LUSR EQU   X'1F'                   len of user data in half-words\nPDS2USRD DS    0C                      start of user data\n         STRING GENERATE               generate literals, routine\n*---------------------------------------------------------------------*\n*                                                                     *\n*        FORMAT OF IEHMOVE UNLOAD RECORDS (IEHMVSRA)                  *\n*                                                                     *\n*    (FOR DOCUMENTATION ONLY, THIS DSECT IS NOT USED IN THE PROGRAM)  *\n*                                                                     *\n*---------------------------------------------------------------------*\nBUFFER   DSECT\n         DC    H'1'                    RECORD SEQUENCE NUMBER\nRECLEN   DC    H'75'                   RECORD LENGTH\nRECTYPE  DC    X'0E'                   RECORD TYPE\nRTYPTTR    EQU X'80'                   3-BYTE TTR FOLLOWS\nRTYPPDS    EQU X'40'                   INPUT DATA SET IS A PDS\nRTYPDATA   EQU X'20'                   MEMBER DATA\nRTYPNOTE   EQU X'10'                   NOTE LIST\nRTYPDIR    EQU X'08'                   DIRECTORY ENTRY\nRTYPDMY    EQU X'04'                   DUMMY RECORD\nRTYPHDR    EQU X'02'                   HEADER RECORD\nRTYPEOF    EQU X'01'                   EOF RECORD\nRECTTR   DS    XL3                     TTR OF THIS RECORD\nRECDATA  DS    XL(BUFFER+800-*)        DATA\n*        YREGS\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         END\n//SYSPRINT DD SYSOUT=*\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//         DD DSN=GILBERT.FILE183.PDS,DISP=SHR            STRINGXL\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,15)\n//SYSUT2   DD UNIT=VIO,SPACE=(CYL,15)\n//SYSUT3   DD UNIT=VIO,SPACE=(CYL,15)\n//SYSGO    DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3120\n//\n//*\n//LKED    EXEC PGM=HEWL,PARM=REUS\n//SYSLIN   DD DSN=*.ASMXF.SYSGO,DISP=(OLD,DELETE)\n//SYSLMOD  DD DSN=GSFSOFT.PRISM-CS.LOAD(SYSMOVE),DISP=SHR\n//SYSPRINT DD SYSOUT=*\n//\n//\n//GO      EXEC PGM=LOADER,PARM=NOPRINT\n//STEPLIB  DD DSN=GSFSOFT.PRISM-CS.LOAD,DISP=SHR\n//SYSLIN   DD DSN=*.HLASM.SYSLIN,DISP=(OLD,PASS)\n//SYSPRINT DD SYSOUT=*\n//SYSUT1   DD DSN=GILBERT.LOAD(BLK0),DISP=SHR\n//SYSUT2   DD DSN=GILBERT.X80,BLKSIZE=800,DISP=SHR\n//SYSUDUMP DD SYSOUT=*\n//\n//*---------------------\n//DEL12 EXEC PGM=IEFBR14\n//DEL12 DD DSN=GILBERT.IEB12,DISP=(MOD,DELETE),SPACE=(1,0)\n//DEL12 DD DSN=GILBERT.IEB12,DISP=(OLD,DELETE),VOL=REF=SYS1.PARMLIB\n//RELOAD EXEC PGM=IEHMOVE,PARM='POWER=4'\n//SYSUT1 DD DSN=SYS1.PARMLIB,DISP=SHR\n//DD1    DD DSN=GILBERT.X80,DISP=SHR\n//DD2    DD DSN=SYS1.PARMLIB,DISP=SHR\n//SYSPRINT DD SYSOUT=*\n     COPY      DSNAME=GILBERT.X80,                                     X\n               TO=3380=TEST01,                                         X\n               RENAME=GILBERT.IEB12,                                   X\n               CATLG\n/*\n//*---------------------\n//CMPR    EXEC PGM=COMPAREX\n//SYSUT1   DD DSN=GILBERT.IEB11,DISP=SHR\n//SYSUT2   DD DSN=GILBERT.X80,DISP=SHR\n//SYSPRINT DD SYSOUT=*\n//SYSIN    DD DUMMY\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TCTDCTR": {"ttr": 3592, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x00\\x00\\x00\\x85\\x11\\x8f\\x01\\x06!\\x0f\\x14\\x10\\x01-\\x00~\\x00p\\xc3\\xc2\\xe3\\xf4\\xf7\\xf2@@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "1985-04-28T00:00:00", "modifydate": "2006-07-29T14:10:00", "lines": 301, "newlines": 126, "modlines": 112, "user": "CBT472"}, "text": "//GILBERTT JOB (ACCT#),TCTDCTR,\n// NOTIFY=&SYSUID,\n// CLASS=A,MSGCLASS=X,COND=(0,NE)\n//*\n//ASMXF EXEC PGM=IFOX00,PARM=(OBJECT,NODECK,NOESD,NORLD,ALIGN,NOXREF)\n*\n*\n*        EDITION DU NOMBRE D'EXCP SUR TOUS LES FICHIERS DU STEP\n*\n*        VERSION CHAPEAU DE TCTDCTR, XA 2.2\n*\n*\n$TCTDCTR START 0\n         SAVE  (14,12),,TCTDCTR-&SYSDATE.-&SYSTIME\n         BALR  R12,0                   LOAD BASE REGISTER\n         USING *,R12                   SPECIFY IT TO ASSEMBLER\n         LR    R14,R13                 SYSTEM SAVE-AREA\n         LA    R13,=18C'SAVE'          NEW SAVE-AREA\n         ST    R14,4(,R13)             FORWARD CHAIN\n         ST    R13,8(,R14)             BACKWARD CHAIN\n*\n         WXTRN MEMBER\n         ICM   R15,B'1111',=A(MEMBER)  PROGRAM TO BE TRACED\n         BZ    NOCALL                  NO PROGRAM TO CALL\n         BALR  R14,R15                 CALL PROGRAM TO BE TRACED\nNOCALL   STH   R15,RETCODE\n*\n         L     R4,540(,0)              PSATOLD\n         USING TCB,R4\n*=       C     RTCB,TCBJSTCB           CHECK IF I'M A BATCH PGM\n*=       BNE   GOBACK                  QUIT IF TSO\n*\n         LA    R1,=A(S99RB+X'80000000') SVC99 REQUEST BLOCK    HEADER\n         SVC   99                      ALLOCATE SYSDBOUT\n         OPEN  MF=(E,OPENL1)           OPEN SYSDBOUT\n         LTR   R15,R15                 CHECK OPEN RETURN CODE\n         BNZ   GOBACK                  QUIT IF OPEN FAILED\n         L     R5,TCBTIO               MY TIOT\n         USING TIOT1,R5\n         L     R6,X'0224'              MY ASCB\n         L     R6,ASCBOUCB-ASCB(,R6)   MY OUCB\n         USING OUCB,R6\n         L     R7,TCBJSCB              MY JSCB\n         USING IEZJSCB,R7\n         BAL   R11,PUTDCB2         <== LOCATE OUTPUT RECORD\n         STRING '1 JOB=',TIOCNJOB,'  STEP=',(TIOCSTEP+0,8),            X\n               '  PROCSTEP=',(TIOCSTEP+8,8),                           X\n               '  PGM=',JSCBPGMN,                                      X\n               '  PERFORM=',(OUCBNPG,H,L),                             X\n               INTO=((R1),121)\n         BAL   R11,PUTDCB2             WRITE BLANK LINE\n         BAL   R11,PUTDCB2\n         STRING '   DDNAME     DISP  VOLSER    EXCP   DATA SET NAME',  X\n               34X,'DEVICE     CUA    LABEL',                          X\n               INTO=((R1),121)\n         BAL   R11,PUTDCB2\n         MVI   1(R1),C'-'              LINE OF DASHES\n         MVC   2(109,R1),1(R1)         LINE OF DASHES\n*LOOP\nTIOT#GET CLI   TIOEDDNM,C' '           FREED DD?\n         BL    TIOT#NXT                YES, JUMP\n         ICM   R6,B'0111',TIOEJFCB     SVA OF THE JFCB\n         LA    R6,16(,R6)              ADDRESS OF JFCB\n         USING INFMJFCB,R6\n         MVC   WKCELL1,BLANKS          CLEAR WORK AREA\n         MVC   STATUS,BLANKS           CLEAR WORK AREA\n         MVC   UNITNAME,BLANKS         CLEAR WORK AREA\n         MVC   VOLSER,=C'JES     '     SYSIN/SYSOUT\n         SLR   R1,R1                   EXCP=0\n         SLR   R7,R7                   NO UCB\n         TM    TIOELINK,TIOESSDS       IS THIS A JES DATA SET?\n         BO    TIOT61                  YES, JUMP\n         MVC   VOLSER,=C'DUMMY   '     DUMMY DATA SET\n         ICM   R7,B'0111',TIOEFSRT     UCB ADDRESS\n         BZ    TIOT64                  NO UCB, SKIP TCT SCAN\n         USING UCBOB,R7\n         MVC   UNITNAME+8(4),UCBTYP    DEVICE TYPE\n         BAL   R14,GETUNIT         <== GET UNITNAME\n         MVC   VOLSER,=C'VIO     '     UNIT=VIO\n         TM    UCBOB,UCBVRDEV          IS THIS A VIO DATA SET?\n         BO    TIOT41                  YES, JUMP\n         MVC   VOLSER,JFCBVOLS         NO, MOVE FIRST VOLSER\n*\nTIOT41   BAL   R1,TIOT41IC\n         DC    C'NEW',AL1(JFCNEW)\n         DC    C'MOD',AL1(JFCMOD)\n         DC    C'SHR',AL1(JFCOLD+JFCSHARE)\n         DC    C'OLD',AL1(JFCOLD)\n         DC    C'???',0H'0'\nTIOT41TM TM    JFCBIND2,*-*            TEST LABEL TYPE FLAGS\n*--LOOP\nTIOT41IC IC    R15,3(,R1)              PICK UP MASK FOR \"TM\"\n         EX    R15,TIOT41TM\n         BO    TIOT41X\n         LA    R1,3+1(,R1)             BUMP TABLE PTR\n         CLI   0(R1),C'?'              END OF TABLE?\n         BNE   TIOT41IC                NEXT TABLE ENTRY\n*--ENDLOOP\nTIOT41X  MVC   STATUS,0(R1)            DISP\n*\nTIOT46   CLI   UCBTBYT3,UCB3TAPE       TAPE DEVICE?\n         BNE   TIOT61                  NO, JUMP\n         BAL   R1,TIOT46IC\n         DC    C'LTM',AL1(JFCBLTM)\n         DC    C'BLP',AL1(JFCBLP)\n         DC    C'SUL',AL1(JFCSUL)\n         DC    C'AUL',AL1(JFCSUL+JFCBAL)\n         DC    C'AL ',AL1(JFCBAL)\n         DC    C'NSL',AL1(JFCNSL)\n         DC    C'SL ',AL1(JFCSL)\n         DC    C'NL ',AL1(JFCNL)\n         DC    C'???',0H'0'\nTIOT46TM TM    JFCBLTYP,*-*            TEST LABEL TYPE FLAGS\n*--LOOP\nTIOT46IC IC    R15,3(,R1)              PICK UP MASK FOR \"TM\"\n         EX    R15,TIOT46TM\n         BO    TIOT46X\n         LA    R1,3+1(,R1)             BUMP TABLE PTR\n         CLI   0(R1),C'?'              END OF TABLE?\n         BNE   TIOT46IC                NEXT TABLE ENTRY\n*--ENDLOOP\nTIOT46X  LH    R0,JFCBFLSQ             PICK UP FILE SEQUENCE NUMBER\n         LTR   R0,R0                   LABEL=0?\n         BNZ   TIOT46Y                 NO, JUMP\n         LA    R0,0001                 YES, CHANGE TO LABEL=1\nTIOT46Y  STRING ((R0),,L),',',((R1),3),INTO=WKCELL1\n*\nTIOT61   LA    R0,TIOENTRY             POINT TO CURRENT TIOT ENTRY\n         SL    R0,TCBTIO               CHANGE ADDRESS TO OFFSET\n         BAL   R14,EXCP00          <== GET EXCP COUNT IN R1\n         STRING ((R1),,R5B),INTO=WKCELL2\n         CL    R1,=F'100000'           OVER 100K?\n         BL    TIOT64                  NO, JUMP\n         SLR   R0,R0                   YES, DIVIDE BY 1000\n         LA    R1,500(,R1)             YES, DIVIDE BY 1000\n         D     R0,=F'1000'             YES, DIVIDE BY 1000\n         STRING ((R1),,R4B),'K',INTO=WKCELL2\n*\nTIOT64   LTR   R7,R7                   DO WE HAVE AN UCB?\n         BNZ   TIOT#PRT                YES, JUMP\n         LA    R7,BLANKS               NO, POINT TO A DUMMY UCB\nTIOT#PRT BAL   R11,PUTDCB2         <== LOCATE OUTPUT RECORD\n         STRING $$$,TIOEDDNM,$$$,STATUS,$$$,                          XX\n               VOLSER,$$$,(WKCELL2,5),$$$,JFCBDSNM,$$$,               XX\n               UNITNAME,$$$,UCBNAME,$$$,WKCELL1,$$$,                  XX\n               INTO=((R1),121)\n*\nTIOT#NXT SLR   R0,R0                   PREPARE IC\n         IC    R0,TIOELNGH             LOAD LENGTH OF CURRENT ENTRY\n         ALR   R5,R0                   BUMP UP TO NEXT ENTRY\n         CLI   TIOELNGH,0              IS THIS THE END?\n         BNZ   TIOT#GET                NOT YET, LOOP THROUGH TIOT\n*ENDLOOP\n         BAL   R11,PUTDCB2             WRITE BLANK LINE\n         MVI   1(R1),C'-'              LINE OF DASHES\n         MVC   2(109,R1),1(R1)         LINE OF DASHES\n         BAL   R11,PUTDCB2             WRITE BLANK LINE\n         CLOSE MF=(E,OPENL1)           CLOSE SYSDBOUT (IF NECESSARY)\n         FREEPOOL DCB2\n*\nGOBACK   L     R13,4(,R13)\n         L     R14,12(,R13)            RESTORE REGISTERS\n         LH    R15,RETCODE\n         LM    R0,R12,20(R13)          RESTORE REGISTERS\n         BR    R14                     GOBACK TO CALLER\n*----------------------------------------------------------------------\n*        ISSUE PUT WITH AMODE=24                                      *\n*---------------------------------------------------------------------*\nPUTDCB2  PUT   DCB2                    WRITE SYSPRINT RECORD\n         MVI   0(R1),C' '              ALL SPACES\n         MVC   1(120,R1),0(R1)         ALL SPACES\n         BR    R11                     GOBACK, RESET AMODE\n*---------------------------------------------------------------------*\n*        EXCP00: RETRIEVE EXCP COUNT IN TCTIOTSD AREA                 *\n*---------------------------------------------------------------------*\nEXCP00   L     R1,540(,0)              MY TCB\n         L     R1,TCBTCT-TCB(,R1)      TCBTCT\n         L     R1,TCTIOTBL-SMFTCT(,R1) START OF I/O MEASUREMENT TABLE\n         LA    R1,TCTIODSP-TCTTIOT(,R1) FIRST DD ENTRY\n         USING TCTDCBTD,R1\n*LOOP\nEXCP11   CL    R0,TCTDCBTD             SAME TIOT OFFSET?\n         BE    EXCP21                  YES, EXIT LOOP\n         ICM   R15,B'1111',TCTDCBLE    END OF TABLE ?\n         LA    R1,TCTDCBLE             NEXT LOOKUP TABLE ENTRY\n         BNZ   EXCP11                  NOT YET, TRY NEXT DD ENTRY\n*ENDLOOP\n         SLR   R0,R0                   EXCP COUNT IS ZERO\n         B     EXCP99\n*\nEXCP21   LH    R1,TCTIOTSD             OFFSET IN I/O MEASURE. TABLE\n         L     R15,540(,0)             MY TCB\n         L     R15,TCBTCT-TCB(,R15)    MY TCT\n         A     R1,TCTIOTBL-SMFTCT(,R15) START OF I/O MEASUREMENT TABLE\n         USING TCTDDENT,R1\n         ICM   R0,B'1111',TCTDCTR      EXCP COUNT IN R0\nEXCP99   LR    R1,R0                   EXCP COUNT IN R1 TOO\n         BR    R14\n         DROP  R1\n*---------------------------------------------------------------------*\n*        CONVERT UCBTYP TO UNITNAME                                   *\n*---------------------------------------------------------------------*\nGETUNIT  ST    R14,TENWORDS+32         SAVE R14\n         MVI   TENWORDS+20,X'01'       RETURN A LOOK-UP VALUE (BIT7)\n         MVI   TENWORDS+21,X'00'       CLEAR UNUSED BYTE\n         LA    R14,UNITNAME            UNITNAME+DEVTYPE\n         LA    R15,TENWORDS+20         FLAGS\n         STM   R14,R15,TENWORDS\n         OI    TENWORDS+4,X'80'        END-OF-LIST FLAG\n         LA    R1,TENWORDS             PARM LIST ADDRESS\n         L     R14,CVTPTR              POINT TO CVT\n         L     R14,CVTLINK-CVTMAP(,R14) POINT TO LINKLIST DCB\n         LINK  SF=(E,IEFEB4UV),DCB=(R14)   GET UNIT NAME\n         LTR   R15,R15\n         BNZ   GETUNIT6                BAD RETURN CODE, QUIT\n         MVI   TENWORDS+20,X'20'       RETURN A UNIT NAME (BIT2)\n         LA    R1,TENWORDS             PARM LIST ADDRESS\n         LINK  SF=(E,IEFEB4UV)         GET UNIT NAME\n         LTR   R15,R15\n         BZ    GETUNIT9                GOOD RETURN CODE, GOBACK\nGETUNIT6 MVC   UNITNAME,BLANKS         CONVERSION DID NOT WORK\nGETUNIT9 L     R14,TENWORDS+32         RESTORE R14\n         BR    R14\n*---------------------------------------------------------------------*\n*        WORK AREAS                                                   *\n*---------------------------------------------------------------------*\nBLANKS   DC    CL40' '\n$$$      DC    C' | '\n         PRINT NOGEN\nIEFEB4UV LINK  EP=IEFEB4UV,SF=L\nDCB2     DCB   DSORG=PS,MACRF=PL,DDNAME=SYSDBOUT,RECFM=FBA,LRECL=121\nOPENL1   OPEN  (DCB2,OUTPUT),MF=L\nS99RB    DC    A(X'14010000',0,*+12,0,0)\n         DC    A(S99TXT01,X'80000000'+S99TXT18)\nS99TXT01 DC    AL2(X'01',1,8),CL8'SYSDBOUT '  DDNAME\nS99TXT18 DC    AL2(X'18',0)                   SYSOUT=*\nRETCODE  DS    H\nWKCELL1  DS    D\nWKCELL2  DS    D\nSTATUS   DS    C'OLD'\nVOLSER   DS    CL6\nUNITNAME DS    CL8,XL4\nTENWORDS DS    10F\n*-------------------------------------------------------------------\n*        DSECTS FOR MVS SYSTEM CONTROL BLOCKS\n*               SOME OF THESE MACRO INSTRUCTION WILL BE FOUND\n*               IN SYS1.AMODGEN INSTEAD OF SYS1.MACLIB.\n*-------------------------------------------------------------------\n         IKJTCB LIST=NO    TCB MAPPING       TASK CONTROL BLOCK\n         IEFTCT            TCT MAPPING       TIMING CONTROL TABLE\nTIOT     DSECT\n         IEFTIOT1          TIOT MAPPING      TASK INPUT-OUTPUT TABLE\n         IKJRB             PRB DSECT         PROGRAM REQUEST BLOCK\n         IHACDE            CDE DSECT         CONTENTS DIRECTORY ENTRY\n         IEFJFCBN                      JOB FILE CONTROL BLOCK\n**       IEFJESCT                      JES COMMUNICATION TABLE\n         IEZJSCB                       JOB STEP CONTROL BLOCK\n         CVT   DSECT=YES\n         IEFUCBOB LIST=NO,PREFIX=NO    UCB DSECT\n         IHAASCB                       ADDRESS SPACE CONTROL BLOCK\n         IRAOUCB                       SRM PARMS\n         STRING GENERATE\n*        YREGS             REGISTER EQUATES\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         END\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//         DD DSN=SYS1.AMODGEN,DISP=SHR\n//         DD DSN=GILBERT.FILE183.PDS,DISP=SHR          STRINGXF\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,15)\n//SYSUT2   DD UNIT=VIO,SPACE=(CYL,15)\n//SYSUT3   DD UNIT=VIO,SPACE=(CYL,15)\n//SYSGO    DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3120\n//SYSPRINT DD SYSOUT=*\n//*\n//GO      EXEC PGM=LOADER,PARM=NOPRINT\n//SYSPRINT DD SYSOUT=*\n//SYSUDUMP DD SYSOUT=*\n//SYSDBOUT DD SYSOUT=*\n//SYSLIN   DD DSN=*.ASMXF.SYSGO,DISP=(OLD,DELETE)\n//\n//\n//LKED    EXEC PGM=IEWL,PARM='MAP,REUS'\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD DSN=*.HLASM.SYSLIN,DISP=(OLD,PASS)\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,5)\n//SYSLMOD  DD DSN=GSFSOFT.PRISM-CS.LOAD(TCTDCTR),DISP=SHR\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TRIMMAC": {"ttr": 3844, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x0c\\x00\\x00\\x00\\x90\\x10/\\x01\\x06!\\x0f\\x147\\x01\\xf3\\x002\\x00\\xd4\\xc3\\xc2\\xe3\\xf4\\xf7\\xf2@@@@'", "ispf": {"version": "02.12", "flags": 0, "createdate": "1990-04-12T00:00:00", "modifydate": "2006-07-29T14:37:00", "lines": 499, "newlines": 50, "modlines": 212, "user": "CBT472"}, "text": "//GILBERTT JOB (ACCT#),TRIMMAC,                        OS/VS2\n// NOTIFY=&SYSUID,\n// CLASS=A,MSGCLASS=X,COND=(1,LT)\n//*\n//*     THIS PROGRAM CREATES A REDUCED-SIZE MACLIB THAT MAY BE\n//*     USED INSTEAD OF THE SYS1.MACLIB/SYS1.AMODGEN CONCATENATION\n//*     TO IMPROVE THE PERFORMANCE OF THE ASSEMBLER.\n//*\n//*     THE \"TRIMMAC\" LIBRARY IS BUILT AS FOLLOWS:\n//*\n//*        1. SELECTED MACROS ARE READ FROM DDNAME \"SYSLIB\",\n//*           TRIMMED FROM PL/AS CODE AND OTHER COMMENT LINES,\n//*           THEN COPIED TO A TEMPORARY DATA SET.\n//*\n//*        2. THE SORT UTILITY IS INVOKED TO SORT THE MACROS\n//*           IN ASCENDING SEQUENCE OF THEIR SIZE.\n//*\n//*        3. THE SORTED MACROS ARE WRITTEN TO SYSPUNCH\n//*           AS AN IEBUPDTE SYSIN STREAM.\n//*\n//*        4. IEBUPDTE IS EXECUTED IN THE LAST STEP TO\n//*           LOAD THE MACROS INTO THE \"TRIMMAC\" LIBRARY,\n//*           THE SMALLEST MACROS BEING LOADED FIRST.\n//*\n//*    YOU MAY CUSTOMIZE THE MEMBER LIST AND THE INPUT\n//*    CONCATENATION TO ADD OTHER MACROS AND/OR MACRO\n//*    LIBRARIES, AS NEEDED.\n//*\n//*    USE THE \"TRIMMAC\" LIBRARY INSTEAD OF THE MACLIB/AMODGEN\n//*    CONCATENATION TO ASSEMBLE A PROGRAM AND COMPARE THE\n//*    BEFORE/AFTER VALUES FOR THE ELAPSED TIME, EXCP COUNT AND\n//*    I/O CONNECT TIME.  EXPECT SAVINGS OF 30 TO 60 PERCENT WHEN\n//*    \"TRIMMAC\" IS USED.\n//*\n//*    MY OS/VS2 \"TRIMMAC\" PDS IS CURRENTLY ALLOCATED AS FOLLOWS:\n//*\n//*          UNIT=3390,SPACE=(CYL,(12,,12)),\n//*          DCB=(RECFM=FB,LRECL=80,BLKSIZE=27920)\n//*\n//ASMXF EXEC PGM=IFOX00,PARM=(OBJECT,NODECK,NOESD,NORLD,ALIGN,NOXREF)\nTRIMMAC  CSECT\n         SAVE  (14,12),,'TRIMMAC &SYSDATE '\n         LR    R12,R15\n         USING TRIMMAC,R12\n         GETMAIN R,LV=DYNAML\n         ST    R1,8(,R13)\n         ST    R13,4(,R1)\n         LM    R13,R1,8(R13)           SET R13, RELOAD R1\n         USING DYNAM,R13\n         XC    TRTBL,TRTBL             BUILD TRT TABLE (FIRST BLANK)\n         MVI   TRTBL+C' ',C' '         BUILD TRT TABLE (FIRST BLANK)\n         MVI   TRTNBL,1                BUILD TRT TABLE (1ST NON-BLANK)\n         MVC   TRTNBL+1(255),TRTNBL    BUILD TRT TABLE (1ST NON-BLANK)\n         MVI   TRTNBL+C' ',0           BUILD TRT TABLE (1ST NON-BLANK)\n***********************************************************************\n*\n*        SECTION 1\n*\n*              READ MACRO NAMES FROM DDNAME=MEMBERS\n*              READ MACRO TEXT FROM DDNAME=SYSLIB\n*              WRITE SELECTED LINES TO DDN=SORTIN\n*              BUILD TABLE WITH THE NUMBER OF LINES FOR EACH MEMBER\n*\n***********************************************************************\n         OPEN  (MEMBERS,,SYSLIB,,SORTIN,OUTPUT,SYSPRINT,OUTPUT)\n         GETBUF SYSLIB,(R3)            GET A BUFFER FROM POOL\n         ST    R3,DECB1+12             STORE ITS ADDRESS INTO DECB\n         LA    R8,TABLE                START OF TABLE\n*LOOP\nL1GET    GET   MEMBERS                 GET A MACRO NAME\n         CLI   0(R1),C'*'              IS THIS A COMMENT LINE?\n         BE    L1GET                   YES, IGNORE IT\n         MVC   BLDLIST(4),=Y(1,12)     HEADER\n         MVC   MEMBER,0(R1)            MEMBER NAME\n         BLDL  SYSLIB,BLDLIST          LOCATE MEMBER\n         LTR   R15,R15\n         BNZ   L1NOTF                  NOT FOUND, ERROR\n         ZAP   RECNO,=P'0'             RESET COUNTER\n         ZAP   DWD,=P'0'               INIT COUNTER & FLAGS\n         FIND  SYSLIB,TTRN,C           POINT TO START OF MEMBER\n*--LOOP\nL1GETB   READ  DECB1,SF,SYSLIB,*-*,'S' READ A BLOCK\n         CHECK DECB1\n         L     R3,DECB1+12             BUFFER ADDRESS FROM DECB\n*----LOOP\nL1GETR   AP    RECNO,=P'1'             COUNT INPUT RECORDS\n         BAL   R14,SELECT              SELECT/SKIP RECORDS\n         B     L1NEXTR              +0 RECORD SHOULD BE IGNORED\n         PUT   SORTIN               +4 RECORD SHOULD BE WRITTEN\n         MVC   0(72,R1),0(R3)          MOVE RECORD\n         MVC   72(8,R1),MEMBER         MOVE MEMBER NAME\n         AP    DWD+4(4),=P'1'          COUNT WRITTEN RECORDS\nL1NEXTR  LH    R14,SYSLIB+82           R14 CONTAINS RECORD LENGTH\n         L     R15,DECB1+12            ADDRESS OF BUFFER\n         AH    R15,SYSLIB+62           ADD BLKSIZE FROM DCB\n         L     R1,DECB1+16             IOB ADDRESS FROM DECB\n         SH    R15,14(,R1)             SUBTRACT RESIDUAL COUNT\n         SLR   R15,R14                 LAST BYTE OF CURRENT BLOCK\n         BXLE  R3,R14,L1GETR           LOOP UNTIL END-OF-BLOCK\n*----ENDLOOP\n         B     L1GETB                  NEXT BLOCK\n*--ENDLOOP\nL1EOM    ZAP   DWD,DWD                 ANY LINES SELECTED?\n         BZ    L1NOTF                  NO, IGNORE\n         MVC   MESSAGE+08(8),MEMBER    BUILD PRINT RECORD\n         OI    DWD+7,15                NO SIGN\n         UNPK  MESSAGE+29(5),DWD+5(3)  BUILD PRINT RECORD\n         OI    RECNO+3,15              NO SIGN\n         UNPK  MESSAGE+59(5),RECNO+1(3) BUILD PRINT RECORD\n         PUT   SYSPRINT,MESSAGE        WRITE PRINT RECORD\n         MVC   0(4,R8),DWD+4           MOVE NUMBER OF LINES TO TABLE\n         LA    R8,4(,R8)               BUMP POINTER\nL1NOTF   B     L1GET                   NEXT SYSIN RECORD (MACRO NAME)\n*ENDLOOP\nL1EOD    CLOSE (MEMBERS,,SYSLIB,,SORTIN)\n         FREEPOOL MEMBERS\n         FREEPOOL SYSLIB\n***********************************************************************\n*        SECTION 2: UPDATE RECORDS TO ADD MACRO SIZE IN POS 81-84\n***********************************************************************\n         OPEN  (SORTIN,UPDAT)\n         LA    R8,TABLE-4              START OF TABLE\n*LOOP\nL2GET    GET   SORTIN\n         LTR   R3,R1                   PASS RECORD ADDRESS\n         BZ    L2EOD                   EOJ, EXIT\n         CLC   DWD,72(R3)              SAME MEMBER?\n         BE    L2PUT                   YES, JUMP\n         MVC   DWD,72(R3)              NO, KEEP NAME\n         LA    R8,4(,R8)               NEXT ENTRY IN TABLE\nL2PUT    MVC   80(4,R3),0(R8)          NUMBER OF LINES\n         PUTX  SORTIN                  REWRITE RECORD\n         B     L2GET\n*ENDLOOP\nL2EOD    CLOSE SORTIN\n         FREEPOOL SORTIN\n***********************************************************************\n*        SECTION 3: SORT MACROS BY SIZE, WRITE IEBUPDTE INPUT\n***********************************************************************\n         LINK  EP=SORT,PARAM=H0,VL=1   SORT WORK DATA SET\n         OPEN  (SORTOUT,,SYSPUNCH,OUTPUT)\n         MVI   DWD,0                   FIRST TIME\n*LOOP\nL3GET    GET   SORTOUT\n         LTR   R3,R1                   PASS RECORD ADDRESS\n         BZ    L3EOD                   EOJ, EXIT\n         CLC   DWD,72(R1)              SAME MEMBER?\n         BE    L3PUT                   YES, JUMP\n         MVC   DWD,72(R1)              NO, KEEP NAME\n         PUT   SYSPUNCH\n         MVC   0(13,R1),=C'./ ADD NAME= '\n         MVC   13(67,R1),12(R1)        BLANK OUT REST OF RECORD\n         MVC   12(8,R1),DWD            MOVE MEMBER NAME\nL3PUT    PUT   SYSPUNCH\n         MVC   0(80,R1),0(R3)          MOVE RECORD\n         B     L3GET\n*ENDLOOP\nL3EOD    CLOSE (SORTOUT,,SYSPUNCH,,SYSPRINT)\n         L     R13,4(,R13)\n         RETURN (14,12),RC=00\n*\n*        RECORD SELECTION ROUTINE\n*\nSELECT   TM    DWD,1                   MEND CARD FOUND YET?\n         BOR   R14                     YES, SKIP TEXT AFTER MEND CARD\n         TM    DWD,2                   CHECK CONTINUATION FLAG\n         BO    L1SKIP                  JUMP IF CONTINUED COMMENT\n         TM    DWD,4                   CHECK CONTINUATION FLAG\n         BO    L1CONT                  JUMP IF CONTINUED INSTRUCTION\n         CLI   0(R3),C'*'              ASM COMMENT\n         BE    L1SKIP                  JUMP IF ASM COMMENT LINE\n         CLI   1(R3),C'*'              MACRO COMMENT\n         BE    L1SKIP                  JUMP IF MACRO COMMENT LINE\n         CLI   0(R3),C'/'              IS THIS A JCL LINE?\n         BE    L1SKIP                  YES, IGNORE IT\n*\n         TRT   0(16,R3),TRTBL          FIND FIRST BLANK\n         BZ    L1CONT                  FAILED, WRITE RECORD\n         TRT   0(64,R1),TRTNBL         FIND FIRST NON-BLANK\n         BZ    L1CONT                  FAILED, WRITE RECORD\n         CLC   =C'MEND ',0(R1)         CHECK OPCODE\n         BNE   L1SPACE                 JUMP IF NOT 'MEND'\n         OI    DWD,1                   REMEMBER \"MEND\" CARD FOUND\nL1SPACE  CLI   0(R3),C' '              ANY LABEL ON THIS LINE?\n         BNE   L1CONT                  YES, WRITE IT\n         CLC   =C'SPACE ',0(R1)        CHECK OPCODE\n         BE    L1SKIP                  JUMP IF 'SPACE'\n         CLC   =C'EJECT ',0(R1)        CHECK OPCODE\n         BNE   L1CONT                  RECORD SHOULD BE WRITTEN\n*\nL1SKIP   NI    DWD,255-2               RESET CONTINUATION FLAG\n         CLI   71(R3),C' '             CHECK FOR A CONTINUATION\n         BER   R14                     QUIT WITH RC4 IF NO CONTINUATION\n         OI    DWD,2                   SET CONTINUATION FLAG\n         BR    R14                     GOBACK\n*\nL1CONT   NI    DWD,255-4               RESET CONTINUATION FLAG\n         CLI   71(R3),C' '             CHECK FOR A CONTINUATION\n         BE    4(,R14)                 GOBACK, WRITE RECORD\n         OI    DWD,4                   SET CONTINUATION FLAG\n         B     4(,R14)                 GOBACK, WRITE RECORD\nH0       DC    H'0'\nMESSAGE  DC   C' MEMBER 12345678 PROCESSED - 12345 RECORDS SELECTED OUT+\n                OF 12345'\nMEMBERS  DCB   DSORG=PS,MACRF=GL,DDNAME=MEMBERS,EODAD=L1EOD\nSYSPRINT DCB   DSORG=PS,MACRF=PM,DDNAME=SYSPRINT,                      X\n               RECFM=FBA,LRECL=L'MESSAGE\nSYSPUNCH DCB   DSORG=PS,MACRF=PL,DDNAME=SYSPUNCH,RECFM=FB,LRECL=80\nSORTIN   DCB   DSORG=PS,MACRF=(GL,PL),DDNAME=SORTIN,EODAD=EOD11,       X\n               RECFM=FB,LRECL=72+8+4\nSORTOUT  DCB   DSORG=PS,MACRF=(GL,PL),DDNAME=SORTOUT,EODAD=EOD11\nEOD11    SLR   R1,R1\n         BR    R14\nSYSLIB   DCB   DSORG=PO,MACRF=R,DDNAME=SYSLIB,EODAD=L1EOM,             X\n               BUFNO=1,NCP=1,RECFM=FB,LRECL=80\nDYNAM    DSECT\n         DS    18F\nDWD      DS    D\nRECNO    DS    PL4\nBLDLIST  DS    Y(1,12),CL8,4X          BLDL/FIND\nMEMBER   EQU   BLDLIST+4,8             BLDL/FIND\nTTRN     EQU   MEMBER+8,4              BLDL/FIND\nTRTBL    DS    XL256                   TRT TABLE (FIND FIRST BLANK)\nTRTNBL   DS    XL256                   TRT TABLE (FIND FIRST NON-BLANK)\nTABLE    DS    999PL4                  RECORD NUMBERS\nDYNAML   EQU   *-DYNAM\n*        YREGS\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         END\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,15)\n//SYSUT2   DD UNIT=VIO,SPACE=(CYL,15)\n//SYSUT3   DD UNIT=VIO,SPACE=(CYL,15)\n//SYSGO    DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3120\n//SYSPRINT DD SYSOUT=*\n//*\n//GO      EXEC PGM=LOADER,PARM=NOPRINT\n//SYSLIN   DD DSN=*.ASMXF.SYSGO,DISP=(OLD,DELETE)\n//SYSPRINT DD SYSOUT=*\n//SYSOUT   DD SYSOUT=*\n//SORTIN   DD UNIT=SYSALLDA,SPACE=(CYL,20),DSN=&&SORTIN\n//SORTOUT  DD DSN=*.SORTIN,VOL=REF=*.SORTIN,DISP=(OLD,DELETE)\n//SORTWK01 DD UNIT=SYSALLDA,SPACE=(CYL,25),DSN=&&SORTWK01\n//SYSPUNCH DD UNIT=SYSALLDA,SPACE=(CYL,20),DISP=(,PASS)\n//SYSIN    DD *\n SORT FIELDS=(81,4,CH,A),EQUALS\n/*\n//SYSLIB   DD DSN=SYS1.MACLIB,DISP=SHR,           <== INPUT LIBRARY\n// UNIT=SYSALLDA,VOL=SER=Z5RES1\n//         DD DSN=SYS1.AMODGEN,DISP=SHR,          <== INPUT LIBRARY\n// UNIT=SYSALLDA,VOL=SER=Z5RES1\n//         DD DSN=SYS1.ATSOMAC,DISP=SHR,          <== INPUT LIBRARY\n// UNIT=SYSALLDA,VOL=SER=Z5RES1\n//         DD DSN=SYS1.SHASMAC,DISP=SHR           <== INPUT LIBRARY\n//* THESE ARE MY OWN LIBRARIES\n//         DD DSN=GILBERT.GSF.SOURCE,DISP=SHR     <== INPUT LIBRARY\n//MEMBERS  DD *\nABEND              MVS\nACB                DFP VSAM\nACBVS              DFP VSAM\nATTACH             MVS\nBLDL               DFP\nCALL               MVS\nCALLTSSR           TSO/E\nCAMLST             DFP\nCHECK              DFP\nCIRB               MVS\nCLOSE              DFP\nCVT                MVS\nDCB                DFP\nDCBD               DFP\nDEBCHK             DFP\nDELETE             MVS\nDEQ                MVS\nDETACH             MVS\nDEVTYPE            DFP\nDOM\nDYNALLOC           MVS\nENDREQ             DFP VSAM\nENQ                MVS\nERASE              DFP VSAM\nESTAE              MVS\nEXCP               DFP\nEXLST              DFP VSAM\nEXLVS              DFP VSAM\nEXTRACT            BCP\nFEOV               DFP\nFIND               DFP BPAM\nFREEMAIN           MVS\nFREEPOOL           DFP\nGET                DFP\nGETBUF             DFP\nGETLINE            TSO\nGETMAIN            MVS\nGTSIZE             TSO\nICHMM\nICHPRCVT           RACF\nICHSAFP            RACROUTE\nIDACBACB           DFP VSAM\nIDACB1             DFP VSAM\nIDACB2             DFP VSAM\nIDACB3             DFP VSAM\nIDAVSACB           DFP VSAM\nIDAVSCB3           DFP VSAM\nIDAVSOPT           DFP VSAM\nIDAVSRPL           DFP VSAM\nIDENTIFY           MVS\nIECDDCE            MVS IOS\nIECDIOCM           MVS IOS\nIECDPPL            DFP PURGE PARM LIST\nIECSDSL1           DFP\nIEEBASEA           MVS MASTER SCHED RES DATA AREA\nIEECHAIN           MVS CSCB\nIEECUCM            MVS UNIT CONTROL MODULE\nIEESMCA            SMF\nIEFAJCTB           DFP JOB CONTROL BLOCK + ACCOUNT TABLE\nIEFALLCT           MVS\nIEFASCTB           DFP STEP CONTROL BLOCK\nIEFASIOT           DFP STEP I/O TABLE\nIEFJCTX            MVS JCT EXTENSION\nIEFJESCT           MVS\nIEFJFCBN           DFP\nIEFJFCBX           DFP\nIEFJSCVT           MVS\nIEFJSSIB           MVS\nIEFJSSOB           MVS\nIEFJSSVT           MVS\nIEFQMNGR           MVS SWA MANAGER\nIEFSSCS            CANCEL/STATUS\nIEFSSOBH           MVS\nIEFSSREQ           MVS\nIEFTCT             SMF\nIEFTIOT1           MVS\nIEFUCBOB           MVS\nIEFZB4D0                      DYNALLOC REQUEST BLOCK\nIEFZB4D2                      DYNALLOC TEXT UNIT KEYS\nIEFZB505           DFP\nIEZATTCH           MVS\nIEZBITS            MVS BIT0-BIT7\nIEZDEB             DFP\nIEZIOB             DFP\nIEZJSCB            MVS\nIFGACB             DFP VSAM\nIFGACBVS           DFP VSAM\nIFGRPL             DFP VSAM\nIFGRPLVS           DFP VSAM\nIHAACEE            RACF\nIHAASCB            MVS\nIHAASVT            MVS\nIHAASXB            MVS\nIHACDE             MVS\nIHADECB            DFP\nIHADSAB            DFP\nIHADVA             DFP\nIHAGDA             MVS CSV\nIHALDA             MVS CSV\nIHALLE             MVS\nIHALPDE            MVS\nIHAOUXB            SRM\nIHAPDS             DFP\nIHAPSA             MVS\nIHARB              MVS\nIHARMPL            MVS (RESMGR)\nIHASCA             MVS SPIE/ESPIE CONTROL AREA\nIHASCB             MVS STAE CONTROL BLOCK\nIHASCVT            MVS\nIHASDWA            MVS\nIHASPQE            MVS\nIHAXTLST           MVS\nIHBERMAC           DFP\nIHBINNRA           MVS\nIHBINNRB           MVS\nIHBOPLST           MVS\nIHBRDWRD           DFP BSAM/BPAM\nIHBRDWRS           DFP BSAM/BPAM\nIHB01              DFP\nIKJCPPL            TSO/E\nIKJECT             TSO/E\nIKJEFFDF           TSO/E DAIRFAIL\nIKJEFFMT           TSO/E\nIKJENDP            TSO/E\nIKJGTPB            TSO/E\nIKJIDENT           TSO/E\nIKJIOPL            TSO/E\nIKJKEYWD           TSO/E\nIKJLSD             TSO/E\nIKJNAME            TSO/E\nIKJPARM            TSO/E\nIKJPOSIT           TSO/E\nIKJPPL             TSO/E\nIKJPSCB            TSO/E\nIKJRB              MVS\nIKJRLGB            TSO/E\nIKJRLSA            TSO/E\nIKJSUBF            TSO/E\nIKJTAXE            TSO/E\nIKJTCB             MVS\nIKJTMPWA           TSO/E\nIKJTPL             TSO/E\nIKJTSB             TSO/E\nIKJTSMSG           TSO/E\nIKJUPT             TSO/E\nIKTTCAST           TSO/VTAM\nIKTTSBX            TSO/VTAM\nIRAOUCB            MVS\nLINK               MVS\nLOAD               MVS\nLOCATE             DFP\nMGCR\nMODESET            MVS\nNOTE               DFP\nOBTAIN             DFP\nOPEN               DFP\nPOINT              DFP\nPOST               MVS\nPURGE              DFP\nPUT                DFP\nPUTLINE            TSO\nPUTX               DFP\nRACHECK            RACF\nRACINIT            RACF\nRACROUTE           MVS/SAF RACF\nRDJFCB             DFP\nREAD               DFP\nRELSE              DFP\nRESERVE            MVS\nRETURN             MVS\nRPL                DFP VSAM\nRPLVS              DFP VSAM\nSAVE               MVS\nSETLOCK            MVS\nSETRP              MVS\nSHOWCB             DFP VSAM\nSPIE               MVS\nSTACK              TSO/E\nSTAE               OS/360\nSTATUS             MVS\nSTAX               TSO/E\nSTCOM              TSO/E\nSTFSMODE           TSO/E\nSTIMER             MVS\nSTLINENO           TSO/E\nSTTMPMD            TSO/E\nSYNADAF            DFP\nSYNADRLS           DFP\nSYNCH              MVS\nSYSEVENT           SRM\nTCLEARQ            TSO/E\nTESTAUTH           MVS\nTESTCB             DFP VSAM\nTGET               TSO/E\nTIME               MVS\nTPUT               TSO/E\nTRKCALC            DFP\nTRUNC              DFP\nTTIMER             MVS\nWAIT               MVS\nWRITE              DFP\nWTO                MVS\nXCTL               MVS\n*\n*        THESE ARE MACROS FROM MY OWN LIBRARIES\n*\nSTRING             ---\n//*--------------------------------------------------------------------\n//LOADPROC PROC DS='GILBERT.TRIMMAC',            <== DSNAME\n//            UNIT=3390,                         <== UNIT NAME\n//          VOLSER=,                             <== VOL SER\n//         BLKSIZE=0                             <== BLOCK SIZE (SDB)\n//DELOLD  EXEC PGM=IEFBR14\n//DELOLD   DD DSN=&DS,UNIT=&UNIT,SPACE=(1,0),DISP=(MOD,DELETE)\n//*\n//LOAD    EXEC PGM=IEBUPDTE,PARM=NEW\n//SYSIN    DD DSN=*.GO.SYSPUNCH,DISP=(OLD,PASS)\n//SYSUT2   DD DSN=&DS,DISP=(,CATLG,DELETE),\n// UNIT=&UNIT,\n// SPACE=(CYL,(20,1,20),RLSE,CONTIG),\n// VOL=SER=&VOLSER,\n// DCB=(DSORG=PO,RECFM=FB,LRECL=80,BLKSIZE=&BLKSIZE)\n//SYSPRINT DD DUMMY\n//LOADPROC PEND\n//*--------------------------------------------------------------------\n//TRIMMAC  EXEC LOADPROC                          <== EXEC PROC\n//\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "UNITAFF": {"ttr": 4097, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x02\\x00\\x00\\x00\\x81\\x00_\\x01\\x06!\\x0f\\x11V\\x01]\\x00.\\x008\\xc3\\xc2\\xe3\\xf4\\xf7\\xf2@@@@'", "ispf": {"version": "02.02", "flags": 0, "createdate": "1981-01-05T00:00:00", "modifydate": "2006-07-29T11:56:00", "lines": 349, "newlines": 46, "modlines": 56, "user": "CBT472"}, "text": "//GILBERTA JOB (ACCT#),UNITAFF,\n// NOTIFY=&SYSUID,\n//*RESTART=UNITAFF,\n// CLASS=A,MSGCLASS=X,COND=(0,NE)\n//ASMXF EXEC PGM=IFOX00,PARM=(OBJECT,NODECK,NOESD,NORLD,ALIGN,NOXREF)\n***********************************************************************\n*                                                                     *\n* MODULE NAME = UNITAFF                                               *\n*                                                                     *\n* DESCRIPTIVE NAME = Dynamically set UNIT=AFF for input tape files    *\n*                                                                     *\n* FUNCTION = This program was originally designed to reduce the       *\n*            number of tape drives used by user-submitted SAS jobs.   *\n*            It scans the SWA of the next step and changes some of    *\n*            the SIOT pointers to force all input tape data sets to   *\n*            use the same drive.                                      *\n*                                                                     *\n* STATUS = R202                                                       *\n*                                                                     *\n* AUTHOR = Gilbert Saint-Flour <carlos@gsf-soft.com>                  *\n*                                                                     *\n* DEPENDENCIES = OS/VS2                                               *\n*                                                                     *\n* AUTHORIZATION = APF                                                 *\n*                                                                     *\n* MODULE TYPE = PROCEDURE, (BATCH PROGRAM)                            *\n*                                                                     *\n*    PROCESSOR = IBM OS/ASSEMBLER XF                                  *\n*                                                                     *\n*    MODULE SIZE = 3K                                                 *\n*                                                                     *\n*    ATTRIBUTES = NOREUS, PROBLEM STATE, KEY ZERO                     *\n*                                                                     *\n* OPERATION = UNITAFF must be executed immediately before the step    *\n*             to process (SAS, SORT, or any other program that reads  *\n*             a variable number of tape files, one at a time).        *\n*                                                                     *\n*             Sample JCL:                                             *\n*                                                                     *\n*               //UNITAFF EXEC PGM=UNITAFF                            *\n*               //STEPLIB  DD DSN=SYS2.AUTHLIB,DISP=SHR               *\n*               //*                                                   *\n*               //STEP53  EXEC PGM=SAS                                *\n*               //OSIN     DD DSN=USER1.X,DISP=SHR                    *\n*               //         DD DSN=UPQE.DQE40530(-1),DISP=SHR          *\n*               //OSIN2    DD DSN=UPQR.DQR02150(0),DISP=SHR           *\n*               //OSIN3    DD DSN=USER1.X,DISP=SHR                    *\n*               //         DD DSN=UPBG.DBGA0240(-1),DISP=SHR          *\n*               //OSIN4    DD DSN=USER1.X,DISP=SHR                    *\n*               //         DD DSN=USER1.YY,DISP=SHR                   *\n*               //         DD DSN=UPQR.DQR02140(-1),DISP=SHR          *\n*                                                                     *\n*             This program only supports cataloged data sets;         *\n*             relative generation numbers are handled                 *\n*             correctly via the GDGNT.                                *\n*                                                                     *\n*             No distinction is made between 3420 and 3480 types,     *\n*             which will cause incorrect results if the input to      *\n*             a step is mixed.                                        *\n*                                                                     *\n*Changes:                                                             *\n*$101 Fix SWA=BELOW bug                                               *\n*$202 OS/VS2                                                          *\n***********************************************************************\n         LCLC  &STR\nUNITAFF  CSECT\n         SAVE  (14,12),,'GSF UTILITIES - UNITAFF R202'\n         LR    R12,R15                 base reg\n         USING UNITAFF,R12\n         LA    R0,DYNL\n         GETMAIN R,LV=(0)\n         ST    R13,4(,R1)              CHAIN SAVE AREA\n         LR    R13,R1                  DYN ADDRESS\n         USING DYN,R13\n         LA    R0,DYN+72               CLEAR WORKING STORAGE TO X'00'\n         LA    R1,DYNL-72              CLEAR WORKING STORAGE TO X'00'\n         SLR   R15,R15                 CLEAR WORKING STORAGE TO X'00'\n         MVCL  R0,R14                  CLEAR WORKING STORAGE TO X'00'\n***********************************************************************\n*                                                                     *\n*        LOCATE TCB, JSCB, GDGNT.                                     *\n*        LOCATE SCT AND 1ST SIOT FOR NEXT STEP.                       *\n*                                                                     *\n***********************************************************************\n         L     R1,540(,0)              PSATOLD\n         L     R3,TCBJSCB-TCB(,R1)     GET THE ADDRESS OF MY JSCB\n         USING IEZJSCB,R3\n         L     R4,JSCBJCT              Address of JCT prefix\n         USING INJMJCT-16,R4\n         ICM   R1,B'0111',JCTGDGNT     3-BYTE SVA OF GDG NAME TABLE\n         BZ    NOGDGNT                 JUMP IF THERE IS NO GDGN TABLE\n         LA    R1,16(,R1)              CONVERT SVA TO 31-BIT ADDRESS\n         ST    R1,GDGNTPTR             KEEP ADDRESS OF GDG NAMES TABLE\n*\nNOGDGNT  ICM   R1,B'0111',JSCSCTP      3-BYTE SVA OF CURRENT STEP'S SCT\n         LA    R5,16(,R1)              CURRENT STEP'S SCT ADDRESS\n         USING SCT,R5\n*\nNEXTSTEP ICM   R1,B'0111',SCTANSCT     LOAD 3-BYTE SVA OF NEXT SCT\n         BZ    RETURN                  RETURN IF THERE IS NO NEXT STEP\n         LA    R5,16(,R1)              ADDRESS OF NEXT STEP'S SCT\n         ICM   R1,B'0111',SCTFSIOT     LOAD 3-BYTE SVA OF 1ST SIOT\n         BZ    RETURN                  NO DD CARDS, RETURN\n***********************************************************************\n*                                                                     *\n*        LOOP THRU THE SIOT BLOCKS                                    *\n*                                                                     *\n***********************************************************************\nLOOPSIOT LA    R6,16(,R1)              ADDRESS OF SIOT\n         USING SIOT,R6\n         AP    SEQ#,=P'1'              INCREMENT CURRENT SEQ#\n         TM    SCTSBYT1,SIOTCCAT       CHECK FOR CONCATENATION\n         BO    TESTDISP                JUMP IF NO DDNAME\n         MVC   DDNAME,SCTDDNAM         KEEP DDNAME\n         SP    SEQ#,SEQ#               RESET DDSEQ\nTESTDISP OI    SEQ#+L'SEQ#-1,X'0F'     SUPPRESS SIGN\n         TM    SCTSBYT3,1              CHECK DISP=OLD\n         BNO   NEXTSIOT                JUMP IF NOT DISP=OLD\n         CLI   SCTUTYPE,C' '           CHECK UNIT NAME\n         BH    NEXTSIOT                JUMP IF THERE IS A UNIT NAME\n         TM    SCTSBYT1,SCTUNAFF       TEST UNIT=AFF BIT\n         BO    NEXTSIOT                JUMP IF UNIT=AFF ALREADY THERE\n         ICM   R1,B'0111',SCTPJFCB     LOAD 3-BYTE SVA OF JFCB\n         LA    R7,16(,R1)              ADDRESS OF JFCB\n         USING JFCB,R7                 DSNAME FROM JFCB\n         MVC   DSNAME,JFCBDSNM         MOVE DSN TO UNPROTECTED STORAGE\n         TM    JFCBIND1,JFCGDG         CHECK GDG INDICATOR\n         BNO   LOCATE                  JUMP IF NOT GDG\n*--------------------------------------------------------------------*\n*        IF THE CURRENT DATA SET IS A GDG, SCAN THE GDG NAMES TABLE\n*        FOR THE CURRENT APPARENT GEN (0), IF ANY.\n*--------------------------------------------------------------------*\nGDG000   ICM   R1,B'1111',GDGNTPTR     LOAD ADDR OF GDG NAMES TABLE\n         BZ    GDG100                  JUMP IF NO GDGNT\n         USING GDGNTABL,R1\nGDG010   SLR   R14,R14                 PREPARE IC\n         IC    R14,GDGNNO              GET NUMBER OF ENTRIES\nGDG015   CLC   GDGNGDG,DSNAME          COMPARE TABLE ENTRY W/ DSNAME\n         BNE   GDG030                  JUMP IF NOT THE SAME\n         LA    R0,GDGNGDGZ             GET PTR TO APPARENT GEN(0)\n         ST    R0,CTGWAGB              SET POINTER IN SVC 26 WORK AREA\n         OI    CTGOPTN3,CTGGDGL        SHOW CTGWAGB IS SET\n         B     GDG100                  EXIT GDGNT SCAN LOOP\nGDG030   LA    R1,GDGNGDG2             BUMP UP TO NEXT ENTRY IN BLOCK\n         BCT   R14,GDG015              LOOP UNTIL END OF BLOCK\n         ICM   R1,B'1111',GDGNNEXT     LOAD ADDR OF NEXT GDGNT BLOCK\n         BNZ   GDG010                  PROCESS NEXT BLOCK\n         NI    CTGOPTN3,255-CTGGDGL    SHOW CTGWAGB IS SET\n         DROP  R1                      GDGNTABL\nGDG100   LA    R1,DSNAME               1ST BYTE OF DSNAME\nGDG120   LA    R1,1(,R1)               BUMP UP TO NEXT BYTE\n         CLI   0(R1),C' '              CHECK FOR A SPACE\n         BNE   GDG120                  LOOP UNTIL END OF DSNAME\n         MVI   0(R1),C'('              DSNAME(\n         MVC   1(4,R1),JFCBELNM        DSNAME(0\nGDG125   LA    R1,1(,R1)               BUMP UP TO NEXT BYTE\n         CLI   0(R1),C' '              CHECK FOR A SPACE\n         BNE   GDG125                  LOOP UNTIL END OF GEN. NO.\n         MVI   0(R1),C')'              DSNAME(0)\n*--------------------------------------------------------------------*\n*        GET DEVICE TYPE INFORMATION FROM THE CATALOG.\n*        KEEP RELATIVE DD# IF IT IS THE FIRST TAPE DD IN THE STEP.\n*--------------------------------------------------------------------*\nLOCATE   LA    R0,DSNAME               DATA SET NAME\n         ST    R0,CTGENT               ENTRY ADDRESS\n         OI    CTGOPTN1,CTGNAME        CTGENT POINTS TO ENTRY NAME\n         LA    R0,CTGWA                WORK AREA FOR SUPERLOCATE\n         ST    R0,CTGWKA               WORK AREA FOR SUPERLOCATE\n         OI    CTGOPTN3,CTGSUPLT       SUPER LOCATE\n         OI    CTGOPTN3,CTGAM0         OS/VS2 CATALOG MGMT REQUEST\n         LA    R0,CTGVL                GET ADDR OF VOLUME LIST\n         ST    R0,CTGWAVL              UPDATE PTR\n         LA    R0,CTGVLLEN             GET LENGTH OF VOLUME LIST\n         STH   R0,CTGWALV              UPDATE LENGTH\n         LOCATE CTGPL                  ISSUE SUPERLOCATE\n         LTR   R15,R15\n         BNZ   NEXTSIOT                JUMP IF DATA SET NOT CATALOGED\n         CLI   CTGVLDEV+2,X'80'        CHECK DEVICE CLASS\n         BNE   NEXTSIOT                JUMP IF NOT A TAPE\n         OC    TAPE1,TAPE1             CHECK 1ST TIME\n         BNZ   NOTFIRST                JUMP IF NOT 1ST TIME\n         MVC   TAPE1,SCTDDINO          KEEP DD# FOR 1ST TAPE DD\n         MVC   DDNAME1,DDNAME          KEEP DDNAME\n         UNPK  DDSEQ1,SEQ#             KEEP DDSEQ\n         B     NEXTSIOT                JUMP IF 1ST TAPE DD\n*--------------------------------------------------------------------*\n*        UPDATE THE SIOT IF THIS IS NOT THE FIRST TAPE IN THE STEP.\n*--------------------------------------------------------------------*\nNOTFIRST MODESET KEY=ZERO\n         MVC   SCTUSADD,TAPE1          MOVE DD# OF 1ST TAPE DD\n         OI    SCTSBYT1,SCTUNAFF       SET UNIT=AFF BIT\n         MODESET KEY=NZERO\n         UNPK  DDSEQ,SEQ#              MOVE DDSEQ\n         WTO   MF=(E,WTO1L)            NOTIFY PROGRAMMER\n*--------------------------------------------------------------------*\n*        LOCATE NEXT SIOT BLOCK, CHECK FOR LAST ONE.\n*--------------------------------------------------------------------*\nNEXTSIOT ICM   R1,B'0111',SCTPSIOT     SVA OF NEXT SIOT\n         BNZ   LOOPSIOT                PROCESS NEXT DD CARD IN STEP\n         DROP  R5,R6,R7                SCT, SIOT, JFCB\n***********************************************************************\n*                                                                     *\n*        CLEAN-UP, RETURN TO CALLER.                                  *\n*                                                                     *\n***********************************************************************\nRETURN   LA    R0,DYNL\n         LR    R1,R13                  DYN ADDRESS\n         L     R13,4(,R13)             CALLER'S SAVE AREA\n         FREEMAIN R,LV=(0),A=(1)      FREE DYNAMIC STORAGE\n         RETURN (14,12),RC=0\n***********************************************************************\n*        CONTROL BLOCKS FOR LOCATE & WTO.                             *\n***********************************************************************\n&STR     SETC  (126)' '\nWTO1L    WTO   '&STR',MF=L,ROUTCDE=14\n         ORG   WTO1L+4\n         DC    C'UNITAFF: '\nDDNAME   DC    CL8' ',C' +'            DDNAME FOR CURRENT TAPE DD\nDDSEQ    DS    C'000'                  DD SEQ# FOR CURRENT TAPE DD\n         DC    C' USES SAME UNIT AS '  DDNAME FOR 1ST TAPE DD\nDDNAME1  DC    CL8' ',C' +'            DDNAME FOR 1ST TAPE DD\nDDSEQ1   DC    C'000'                  DD SEQ# FOR 1ST TAPE DD\n         ORG   ,\nSEQ#     DC    P'000'                  SEQ#\n*---------------------------------------------------------------------\n*        DYNAMIC STORAGE AREA, BASED BY R13.\n*---------------------------------------------------------------------\nDYN      DSECT\n         DS    18F\nGDGNTPTR DS    F                       POINTER TO GDG NAMES TABLE\nTAPE1    DS    XL2                     INTERNAL DD# FOR 1ST TAPE DD\nDSNAME   DS    CL44                    MODIFIABLE DSNAME\n*---------------------------------------------------------------------*\n*        CATALOG PARAMETER LIST\n*---------------------------------------------------------------------*\nCTGPL    DS    0D\nCTGOPTN1 DS    B              FIRST OPTION BYTE:\nCTGNAME  EQU   X'04' .... .1..  CTGENT CONTAINS DSNAME OR SERIAL ADDR\nCTGOPTN2 DS    B              SECOND OPTION BYTE\nCTGOPTN3 DS    B     XXX. ....  SPECIFIES THE CALLER-REQUESTED FUNCTION\nCTGSUPLT EQU   X'10' ...1 ....  SUPERLOCATE FUNCTION\nCTGGDGL  EQU   X'08' .... 1...  GDG LOCATE - CALLER SUPPLIED BASE LEVEL\nCTGAM0   EQU   X'01' .... ...1  OS/VS2 CATALOG MANAGMENT REQUEST\nCTGOPTN4 DS    B              FOURTH OPTION BYTE\nCTGLBASE EQU   X'80' 1... ....  LOCATE BASE LEVEL (SUPERLOCATE GDG)\nCTGENT   DS    A              ADDRESS OF CATALOG RECORD IDENTIFIER\nCTGCAT   DS    A              ADDRESS OF CATALOG DSNAME OR ACB\nCTGWKA   DS    A              ADDRESS OF CALLER'S WORK AREA\nCTGOPTNS DS    B              CATALOG MANAGMENT SERVICES REQUEST OPTION\n         DS    B              RESERVED\nCTGTYPE  DS    C              TYPE OF CATALOG RECORD\nCTGNOFLD DS    FL1            NUMBER OF ENTRIES IN CTGFIELD\nCTGFDBK  DS    XL2            FEEDBACK AREA (IF NOT SUPERLOCATE)\nCTGFBFLG DS    B              FLAGS (SUPERLOCATE)\nCTGPAR   EQU   X'80' 1... ....  PARALLEL MOUNT\nCTGKEEP  EQU   X'40' .1.. ....  FORCED KEEP\nCTGGDGB  EQU   X'20' ..1. ....  GDG BASE LOCATED\nCTGNGDSN EQU   X'10' ...1 ....  GDG DSNAME GENERATED (DSNAME.GXXXXVYY)\n         DS    B              RESERVED (SUPERLOCATE)\nCTGPSWD  DS    A              ADDRESS OF CALLER-SUPPLIED PASSWORD\n*---------------------------------------------------------------------*\n*        CATALOG WORK AREA\n*---------------------------------------------------------------------*\nCTGWA    DS    0D\nCTGWAVL  DS    A                       PTR TO CTGVL (VOLUME LIST)\nCTGWALV  DS    H                       LENGTH OF THE VOLUME LIST\nCTGWAVCT DS    H                       # OF VOLSERS RETURNED IN VL\nCTGWAUCT DS    H                       MINIMUM # OF VOLS TO BE MOUNTED\nCTGWAGCT DS    H                       # OF GENERATIONS CATALOGED\nCTGWAGB  DS    A                       PTR TO APPARENT GEN(0)\n*---------------------------------------------------------------------*\n*        CATALOG VOLUME LIST\n*---------------------------------------------------------------------*\nCTGVL    DS    0D\nCTGVLVOL DS    CL6                     VOLUME SERIAL\nCTGVLDEV DS    XL4                     DEVICE TYPE\nCTGVLSEQ DS    H                       FILE SEQ#\nCTGVLX   DS    19XL12                  VOLUME LIST EXTENSION\nCTGVLLEN EQU   *-CTGVL                 LENGTH OF VOLUME LIST\nDYNL     EQU   *-DYN\n*---------------------------------------------------------------------\n*        GDG NAMES TABLE MAPPING (USING IEFZB902 AS A MODEL)\n*---------------------------------------------------------------------\n**       SYS1.AMODGEN(IEFZB429)\nGDGNTABL DSECT\nGDGNQSVA DS    XL3                     SVA OF NEXT GDGNT RECORD\nGDGNTID  DS    X'23'                   GDGNT ID X'23'\nGDGNNEXT DS    A                       IN-CORE ADDRESS OF NEXT RECORD\nGDGNGDG  DS    CL35                    GDG BASE\nGDGNGDGZ DS    C'1234'                 APPARENT (0) GENERATION\nGDGNGDG2 DS    CL35,C'1234'            2ND GDG NAME\n         DS    CL35,C'1234'            3RD GDG NAME\n         DS    CL35,C'1234'            4TH GDG NAME\nGDGNNO   DS    FL1                     NUMBER OF ENTRIES\n         DS    XL15                    FILLER\nGDGNLEN  EQU   GDGNTABL+176\n*---------------------------------------------------------------------\n*        MAPPING MACROS FROM SYS1.AMODGEN\n*---------------------------------------------------------------------\n         IKJTCB LIST=YES               TASK CONTROL BLOCK\n         IEZJSCB ,                     JOB STEP CONTROL BLOCK\nJCT      DSECT\n         IEFAJCTB ,                    JOB CONTROL BLOCK\nSCT      DSECT\n         IEFASCTB ,                    STEP CONTROL BLOCK\nSIOT     DSECT\n         IEFASIOT ,                    STEP I/O TABLE\nJFCB     DSECT\n         IEFJFCBN LIST=YES             JOB FILE CONTROL BLOCK\n         CVT   DSECT=YES               COMMUNICATION VECTOR TABLE\n*        YREGS                         REGISTER EQUATES\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         END\n//SYSLIB   DD DSN=SYS1.AMODGEN,DISP=SHR\n//         DD DSN=SYS1.MACLIB,DISP=SHR\n//SYSUT1   DD UNIT=VIO,SPACE=(CYL,15)\n//SYSUT2   DD UNIT=VIO,SPACE=(CYL,15)\n//SYSUT3   DD UNIT=VIO,SPACE=(CYL,15)\n//SYSGO    DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3120\n//SYSPRINT DD SYSOUT=*\n//*\n//LKED    EXEC PGM=HEWL,PARM='MAP,AC=1'\n//SYSPRINT DD SYSOUT=*\n//SYSLIN   DD DSN=*.ASMXF.SYSGO,DISP=(OLD,DELETE)\n//SYSLMOD  DD DSN=GILBERT.LOAD(UNITAFF),DISP=SHR\n//*\n//UNITAFF EXEC PGM=UNITAFF\n//STEPLIB  DD DSN=GILBERT.LOAD,DISP=SHR\n//SYSUDUMP DD SYSOUT=*\n//OSIN     DD DSN=GILBERT.UNITAFF1,DISP=SHR\n//*\n//STEP53  EXEC PGM=IEFBR14\n//OSIN     DD DSN=GILBERT.UNITAFF1,DISP=SHR\n//         DD DSN=GILBERT.UNITAFF2,DISP=SHR\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT749/FILE749.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT749", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}