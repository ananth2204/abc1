
  Structured Programming Macros User's Guide and Reference

Copyright (c) 1987-2011 Clemson University

Generated: 2005-09-20-04:00 12:11:10-04:00

------------------------------------------------------------------------

*Table of Contents*

Preface <#id477932>
I. Structured Macros User's Guide <#id421938>

1. Nesting Levels <#id420713>
2. Conditional Statements <##condch>

Standard Conditions <#id420432>
Coding Conditional Expressions <#id479304>
User-Defined Conditions <##ucond>

3. Blocks <#id480744>

The Program Block <#id480152>
The Inline Block <#id480866>
The Subroutine Block <#id480918>
The ErrExit Block <#id480993>

4. Program Environments <#id480697>

DC Environment <#id480675>

System Mode And User Mode <#id480689>
Reentrancy Under IDMS/DC <#id481323>
*NORENT <#id481357>
*NORENTSYS <#id481378>
*RENT <#id481394>
*RENTSYS <#id481416>
*PWA <#id481439>
*PWASYS <#id481470>

OS Environment <#id481498>

*NORENT <#id481518>
*RENT <#id481540>
*PWA <##ospwa>
*MAIN <#id481654>
*NOMAIN <#id481682>
*SRVPRC <#id481702>

PL/I Environment <#id481723>

*STDPLI <#id481743>

Other Environments <#id481784>
Subroutine Block Super Options <#id481843>

*SWA <#id481856>
*NOSUBOPTS <#id481886>

Conclusion <#id481913>

5. Program and Subroutine Work Areas <##pwaswa>

Program Work Areas <#id480591>
Reusable Program Work Areas <#id482608>
Subroutine Work Areas <#id482699>
SWA Placement <#id482794>
PSDs and SSDs <#id482826>

6. Large Program Management <##large>

PWAs and SWAs with Dynamic Storage Management <##dynpwa>

Recursive Subroutines with the DYN Option <#id483218>
Storage Calculations with the DYN Option <#id483252>
SWA Addressability with the DYN Option <#id483287>
Super Options Used with the DYN Option <#id483309>
Storage Optimization with the DYN Option <#id483370>

LONG and LOADBASE <#id483417>
Size Limitations <#id483502>
Conclusion <#id483547>

7. The IF Structure <##if>
8. Loops <#id484008>
9. CASEs and CASE Blocks <##case>
10. Parameter Lists and Standard Linkage <##parms>

Referencing Input Parameter Lists <#id484600>
Generating Parameter Lists <#id485185>
Automatic Parameter Lists <#id485428>
Permanent Parameter Lists <#id485470>
Calling Subroutines <#id485601>
Parameter Lists on CALLSUB and CALLX <#id485668>
Recommendations <#id485741>
Example Source <#id485850>

11. Location and Scope of Data Structures <##scope>

Local Scope within Subroutines <#id486795>

12. Miscellaneous Macros <#id487245>

Bit Manipulation <#id487260>
Testing A Register <#id486653>
Initializing Storage <#id486674>
Register Loading <#id486708>
Executing Instructions <#id487418>
Loading Control Block Addresses <#id487517>
Controlling Structured Macro Operation <#id487616>

13. Miscellaneous Examples <#id486553>

A Search Loop <#id486567>
Scanning Text <#id486365>
A DCB EODAD Exit <#id488214>
Returning R0 and R1 with ENDBLK <#id488268>

14. Structured Macros Listing Program <##listing>

Output of the Listing Program <#id487698>
Controlling Listing Program Operation <#id488666>

II. Structured Macro Reference <#id493194>

15. The BLOCK Macro <#id430569>

BLOCK <#id430575> - Structured macro used to start a block.

16. The CALLCASE Macro <#id497725>

CALLCASE <#id497731> - Structured macro used to call a subroutine based
on a case number.

17. The CALLSUB Macro <#id497511>

CALLSUB <#id497517> - Macro used to call an internal subroutine with
linkage provided by the Structured Macros. A parameter list can be
created for the call and its address loaded into register one, or
register one can be loaded with the address of a previously created list.

18. The CALLX Macro <#id499259>

CALLX <#id499265> - Macro used to call an external subroutine with
standard OS linkage. A parameter list can be created for the call and
its address loaded into register one, or register one can be loaded with
the address of a previously created list.

19. The CASE Macro <#id499737>

CASE <#id499743> - Structured macro used to start the code for a
particular case within a case block. This macro must be coded between a
CASEBLK and ENDCASE macro. The CASE macro is always associated with the
innermost CASEBLK.

20. The CASEBLK Macro <#id499729>

CASEBLK <#id499711> - Structured macro used to start a case block. Case
blocks can be nested up to twenty deep.

21. The DEFUCOND Macro <#id500418>

DEFUCOND <#id500425> - Structured macro used to define the name of a
user condition and to identify the macro that processes it. With
DEFUCOND the programmer can add special case conditions to the list of
standard conditions available in conditional expressions. For
information on writing a user condition macro, see User-Defined Conditions.

22. The ELSE Macro <#id498508>

ELSE <#id498514> - Structured macro used to start the else code for an
associated IF or ELSEIF macro. An ELSE macro is always associated with
the innermost IF structure.

23. The ELSEIF Macro <#id500623>

ELSEIF <#id500630> - Structured macro used to start the else code for an
associated IF or ELSEIF macro. An ELSEIF macro is always associated with
the innermost IF structure. An ELSEIF is like an ELSE macro followed by
an IF macro except that the IF nesting level stays the same.

24. The ENDBLK Macro <#id500933>

ENDBLK <#id500939> - Structured macro used to end a block structure.
Refer to the description of the BLOCK macro for more information.

25. The ENDCASE Macro <#id501360>

ENDCASE <#id501366> - Structured macro used to end a case block structure.

26. The ENDIF Macro <#id501300>

ENDIF <#id501306> - Structured macro used to end an IF structure.

27. The ENDLOOP Macro <#id501846>

ENDLOOP <#id501852> - Structured macro used to end a LOOP structure. For
more information, see The LOOP macro.

28. The ENDPSD Macro <#id501603>

ENDPSD <#id501610> - Macro used to define the end of the Program Static
Data (PSD). The ENDPSD macro is used to close either a partial PSD
within the program code, or the last PSD at the end of the program.

29. The ENDPWA Macro <#id500124>

ENDPWA <#id500130> - Macro used to define the end of the Program Work
Area (PWA) or to close a partial PWA. The ENDPWA macro defines the
PWAPLLEN tag to establish the length of the PWA. If the DYN option is
being used, ENDPWA uses the ##ORGS macro to reserve space for the SWAs.
If option NORENT is in effect, a DS instruction is generated to reserve
storage in the CSECT for the PWA.

30. The ENDSSD Macro <#id502472>

ENDSSD <#id502478> - Macro used to define the end of the Subroutine
Static Data (SSD). The ENDSSD macro is used to close either a partial
SSD within the subroutine code, or the last SSD at the end of the
subroutine.

31. The ENDSWA Macro <#id502778>

ENDSWA <#id502785> - Macro used to define the end of the Subroutine Work
Area (SWA). It is also used to end a partial SWA definition. The ENDSWA
macro establishes the length of the SWA for Dynamic Storage
calculations. ENDSWA insures double word alignment for anything that
follows the SWA.

32. The ERREXIT Macro <#id502394>

ERREXIT <#id502621> - Structured macro used to conditionally cause an
errexit block to be executed.

33. The EXI Macro <#id503129>

EXI <#id503135> - This is the EXecute Immediate macro. It is used to
generate an EX instruction and the instruction to be executed. This
allows the EXecuted statement to be defined at the same time the EX
instruction is defined, minimizing confusion. It also insures that the
USING environment is the same as that of the EX instruction. The
EXecuted instruction is generated in the PSD for the program (or SSD for
a subroutine) if the program has selected option LOCTR. Otherwise, it is
generated inline with a branch around it.

34. The FILL Macro <#id503422>

FILL <#id503428> - Macro used to fill an area of storage with a character.

35. The IBIT Macro <#id503730>

IBIT <#id503736> - Macro used to invert bit flags in a byte.

36. The IF Macro <#id504003>

IF <#id504009> - Structured macro used to start an IF structure.

37. The LCBA Macro <#id504561>

LCBA <#id504567> - This macro loads the address of certain control
blocks into a register. No registers are changed except for the register
specified. A zero condition is set if the control block cannot be
located. It is not necessary for the mapping macros for the control
blocks used internally by this macros to be included in the source program.

38. The LEAVE Macro <#id503410>

LEAVE <#id503416> - Structured macro used to leave a structure.

39. The LOOP Macro <##loopm>

LOOP <#id505094> - Structured macro used to start a loop structure. For
LOOP WHILE loops, tests are done at the start of the loop. For LOOP
UNTIL loops, tests are done at the bottom of the loop. If the ENDLOOP
specifies UNTIL,LEAVE, the loop will continue until a LEAVE macro is
used to leave the loop. BCT, BXH, and BXLE loop use the assembler
instruction by the same name. BXH instructions are generated at the top
of the loop and BXLE, and BCT instructions are generated at the bottom
of the loop.

40. The L8, L16, L24, L32 Macros <#id505508>

L8, L16, L24, L32 <#id504978> - Macros used to load a register with one,
two, three, or four bytes of data from non-aligned storage. This macro
clears the register and issues the appropriate ICM to accomplish this.

41. The PLIST Macro <#id505744>

PLIST <#id505750> - Macro used to generate or modify a parameter list.
The parameter list can be created in default parameter list storage or
routed to a specific location. Register one is also loaded with the
address of the completed list.

42. The PSD Macro <#id506149>

PSD <#id506155> - Macro used to define the beginning of the Program
Static Data (PSD). The PSD macro uses LOCTR to locate the static data
after the instructions for the program. The PSD should be defined just
before the PWA for a particular program block if there is one.

43. The PWA Macro <#id506790>

PWA <#id506796> - Macro used to define the beginning of the Program Work
Area (PWA). The PWA macro automatically reserves space for a standard OS
save area, the SMWA, and any parameter lists if it is appropriate for
the current environment. Also, if the DYN option is being used, PWA sets
up the dynamic storage pointers (NAB, EOS-64). The PWA should be defined
as the last thing associated with a particular program block.

44. The RBIT Macro <#id506750>

RBIT <#id506756> - Macro used to reset bit flags in a byte.

45. The SBIT Macro <#id503114>

SBIT <#id503120> - Macro used to set bit flags in a byte.

46. The SMCTRL Macro <#id503099>

SMCTRL <#id503105> - Macro used to set internal flags to affect the
operation of the Structured Macros.

47. The SMLIST Macro <#id507764>

SMLIST <#id507749> - Macro used to set options for the operation of the
Structured Macros Listing Program. This macro is processed by the
listing program and not the assembler.

48. The SMSYMS Macro <#id507932>

SMSYMS <#id507938> - This is not a macro, but is a copy member that must
be included at the beginning of any program that uses the structure
location symbols described in Location and Scope of Data Structures.

49. The SSD Macro <#id507458>

SSD <#id507464> - Macro used to define the beginning of the Subroutine
Static Data (SSD). The SSD macro uses LOCTR to locate the static data.
If the subroutine has selected the LOADBASE option, the static data is
placed immediately after the subroutine code in the object module. If
the subroutine is not using LOADBASE, the subroutine static data is
placed with the program static data. The SSD should be defined just
before the SWA for a particular subroutine block.

50. The STRSA Macro <#id508649>

STRSA <#id507155> - Macro used to store a register's value in the
Subroutine Work Area (SWA) save area. If an internal subroutine contains
an SWA, registers are automatically restored when the subroutine is
exited. If the internal subroutine needs to pass back the value of a
register, it can use this macro to save a register's current value in
the subroutine save area, so that it is not restored to the original
value when the subroutine returns.

51. The SWA Macro <#id508317>

SWA <#id508323> - Macro used to define the beginning of the Subroutine
Work Area (SWA). The SWA macro automatically reserves space for a
subroutine save area, a SMWA, any parameter lists used by the
subroutine, and the Dynamic Storage Management pointers if needed. The
SWA for a subroutine should be defined immediately after the ENDBLK for
that subroutine. The SWA macro insures that any fields specified within
the SWA are aligned properly.

52. The TBIT Macro <#id508184>

TBIT <#id508190> - Macro used to test bit flags in a byte.

53. The TREG Macro <#id508601>

TREG <#id508957> - Macro used to test a register for zero, positive, or
negative.

54. The ##COND Macro <#id508590>

##COND <#id508596> - This is an internal macro for use within other
macros and not in open code. The ##COND macro tests a conditional
expression and branches to the appropriate success or failure tags. This
macro is intended for use in user condition macros. For information
about writing a user condition macro, see User-Defined Conditions.

III. Appendices <#id519044>

A. Catalogued ASM Procedures At Clemson <##asmproc>
B. Internal Macros Error Messages <##interr>
C. Work Area Storage Layout <##dynform>

Work Area Layout with the DYN Option <#id523172>
Work Area Layout with NODYN and ENVIRON=DC <#id523607>
Work Area Layout with NODYN and ENVIRON=OS <#id523779>
Work Area Layout with NODYN and ENVIRON=PLI <#id523952>

D. Program Code and Static Data Layout <##codform>
E. Register Usage <#id524857>

Register Usage for ENVIRON=DC <#id524845>

IDMS/DC User Mode Registers And Linkage <#id524797>
IDMS/DC System Mode Registers And Linkage <#id525576>

Register Usage for ENVIRON=OS <#id525792>
Register Usage for ENVIRON=PLI <#id525943>

F. Summary of Amendments <#id526825>

Update November 6, 1989 <#id526837>
Update April 19, 1989 <#id526241>
Update October 1, 1987 <#id526986>
Update March 11, 1987 <#id527042>

*List of Tables*

C.1. Dynamic Storage Layout <#id523182>
C.2. Single PWA Format <#id523292>
C.3. Single SWA Format <#id523480>
C.4. NODYN and ENVIRON=DC Work Area Layout <#id523628>
C.5. SWA in NODYN ENVIRON=DC Format <#id523698>
C.6. NODYN and ENVIRON=OS Work Area Layout <#id523794>
C.7. SWA in NODYN ENVIRON=OS Format <#id523875>
C.8. NODYN and ENVIRON=PLI Work Area Layout <#id523974>
D.1. CSECT Layout <#id525014>

*List of Examples*

1.1. Unindented Assembler Source <#id421860>
1.2. Indented Assembler Source <#id478321>
3.1. Switching AMODE <#id480900>
7.1. Conditional Statement Using Assembler Compare Instructions <#id482305>
7.2. Compound Conditional Statement Using Assembler Compare Instructions
<#id484026>
7.3. Comparison Condition and Branch <#id484099>
7.4. Coding Only the Conditional Operator When Condition Code Is Known
To Exist <#id484140>
7.5. Using ELSEIF <#id484189>
8.1. Types of LOOP macros <#id482409>
9.1. The CASE Block <#id484874>
10.1. PLIST Macro <#id485214>
10.2. PLIST Macro with Constants <#id485282>
10.3. Parameter List Lengths <#id485397>
10.4. Using the DS Keyword <#id485546>
10.5. Combining Parameter Lists with Subroutine Calls <#id485689>
10.6. Creating the Parameter List Once <#id485725>
10.7. Parameter List Example <#id485864>
11.1. Using Tags <#id486850>
12.1. Setting Multiple Bits at Once <#id486305>
12.2. Default Target Bit Name <#id486617>
12.3. Loading Multiple Bytes into a Register <#id486722>
12.4. Register Loading Clearing the Register <#id487371>
12.5. Execute Instruction Using the EXI Macro <#id487489>
12.6. Loading the Control Bloack Address with LCBA <#id487598>
13.1. Search Loop Example <#id486584>
13.2. Text Scanning Example <#id488175>
13.3. EODAD Example <#id488234>
13.4. Returning R0 and R1 Example <#id488297>
14.1. Listing Program Output <#id487712>
14.2. Listing Program Output for Defective Program <#id488638>
14.3. Mixed Case Input <#id488721>
16.1. CALLCASE with USESSYMBOLS <#id497874>
16.2. CALLCASE without USESSYMBOLS <#id497895>
D.1. Structured Macros Use of Location Counters <#id524265>


    Preface

The Structured Programming Macros library is a programming tool
developed at Clemson University for internal use by the staff of the
Computer Center. However, after they were written, the decision was made
to release them to the public, since they are very useful to anyone who
is programming in System/370 Assembler language.

The macros were designed to make the programmer's job easier by handling
the often confusing but necessary code needed in any program. Things
like program linkage, subroutines, parameter lists, loops, and
conditional sections are handled easily by use of the macros. This
allows the user to concentrate on the program instead of the details,
and also helps make the code much easier to read and debug.

The Structured Programming Macros provide a means by which the Assembler
programmer can use logical programming structures normally available
only in high-level languages. Structures like DO WHILE, DO UNTIL,
IF-THEN-ELSE, and CASE are available directly through the macros. More
complex structures, such as SEARCH, may be coded simply through a
combination of the macros. In addition, some useful macros that perform
common functions (such as flipping bits and clearing storage) are
provided as a convenience.

The macros are packaged in a macro library which may be concatenated to
SYSLIB for Assembler H. (There are catalogued procedures available at
Clemson that concatenate this macro library to SYS1.MACLIB.)

Among other things, the Structured Programming Macros may be used to
handle addressing mode switching and linkage under MVS/XA. If you want
to use the 31-bit addressing features, you should be familiar with the
concepts described in /MVS/XA SPL: 31-Bit Addressing,/GC28-1158. Using
the macros, it becomes very simple to change and restore addressing
modes, both inline and for subroutine calls.

Since the Structured Programming Macros provide all of the needed
control structures, you should not have to code any branch instructions
(and associated statement labels) in a program. This makes the source
code much neater and easier to read.

This document serves as an introduction to the Structured Programming
Macros, and assumes that the reader is already familiar with the uses of
common structured programming techniques. While the Structured
Programming Macros serve as a programming aid, they are not meant to be
a substitute for a working knowledge of System/370 Assembler language
and System/370 architectures. When using these macros, the reader should
not arbitrarily assume that what the macros generate is some kind of
ômagic codeö. It's not: in fact, the code generated by the macros tends
to look a lot like what a competent programmer would write. When using
the macros, look at the macro expansions occasionally. Knowing a little
about how the macros work will help you to make better use of them.


      Note

In order to achieve the desired level of functionality within the
Structured Macros, they have been written in such a way as to require
the use of the Level H Assembler. Although some of the macros might not
currently require Assembler H, no guarantee is made that any of the
features described here will work with the Level F Assembler. Use of
these macros with anything other than Assembler H is /not/recommended.


  Part I. Structured Macros User's Guide

*Table of Contents*

1. Nesting Levels <#id420713>
2. Conditional Statements <##condch>

Standard Conditions <#id420432>
Coding Conditional Expressions <#id479304>
User-Defined Conditions <##ucond>

3. Blocks <#id480744>

The Program Block <#id480152>
The Inline Block <#id480866>
The Subroutine Block <#id480918>
The ErrExit Block <#id480993>

4. Program Environments <#id480697>

DC Environment <#id480675>

System Mode And User Mode <#id480689>
Reentrancy Under IDMS/DC <#id481323>
*NORENT <#id481357>
*NORENTSYS <#id481378>
*RENT <#id481394>
*RENTSYS <#id481416>
*PWA <#id481439>
*PWASYS <#id481470>

OS Environment <#id481498>

*NORENT <#id481518>
*RENT <#id481540>
*PWA <##ospwa>
*MAIN <#id481654>
*NOMAIN <#id481682>
*SRVPRC <#id481702>

PL/I Environment <#id481723>

*STDPLI <#id481743>

Other Environments <#id481784>
Subroutine Block Super Options <#id481843>

*SWA <#id481856>
*NOSUBOPTS <#id481886>

Conclusion <#id481913>

5. Program and Subroutine Work Areas <##pwaswa>

Program Work Areas <#id480591>
Reusable Program Work Areas <#id482608>
Subroutine Work Areas <#id482699>
SWA Placement <#id482794>
PSDs and SSDs <#id482826>

6. Large Program Management <##large>

PWAs and SWAs with Dynamic Storage Management <##dynpwa>

Recursive Subroutines with the DYN Option <#id483218>
Storage Calculations with the DYN Option <#id483252>
SWA Addressability with the DYN Option <#id483287>
Super Options Used with the DYN Option <#id483309>
Storage Optimization with the DYN Option <#id483370>

LONG and LOADBASE <#id483417>
Size Limitations <#id483502>
Conclusion <#id483547>

7. The IF Structure <##if>
8. Loops <#id484008>
9. CASEs and CASE Blocks <##case>
10. Parameter Lists and Standard Linkage <##parms>

Referencing Input Parameter Lists <#id484600>
Generating Parameter Lists <#id485185>
Automatic Parameter Lists <#id485428>
Permanent Parameter Lists <#id485470>
Calling Subroutines <#id485601>
Parameter Lists on CALLSUB and CALLX <#id485668>
Recommendations <#id485741>
Example Source <#id485850>

11. Location and Scope of Data Structures <##scope>

Local Scope within Subroutines <#id486795>

12. Miscellaneous Macros <#id487245>

Bit Manipulation <#id487260>
Testing A Register <#id486653>
Initializing Storage <#id486674>
Register Loading <#id486708>
Executing Instructions <#id487418>
Loading Control Block Addresses <#id487517>
Controlling Structured Macro Operation <#id487616>

13. Miscellaneous Examples <#id486553>

A Search Loop <#id486567>
Scanning Text <#id486365>
A DCB EODAD Exit <#id488214>
Returning R0 and R1 with ENDBLK <#id488268>

14. Structured Macros Listing Program <##listing>

Output of the Listing Program <#id487698>
Controlling Listing Program Operation <#id488666>


    Chapter 1. Nesting Levels

There are 4 major building blocks that can be nested. These are the
/block,/the /if// /elseif,/the /loop,/and the /case block./The
Structured Programming Macros support nesting to a depth of 20 for each
structure. The structures may be intermixed: for example, a BLOCK can
contain IF structures, and a LOOP may contain a CASE block, which may in
turn contain more LOOPs. Levels of nesting are opened and closed by the
use of complementary macros, like BLOCK/ENDBLK, LOOP/ENDLOOP, IF/ENDIF
and CASEBLK/ENDCASE.

The user of these macros might find it helpful to start indenting source
statements as nesting levels vary. Since no labels are required in the
program code, the user can code statements starting in column two and
indent while still leaving room for comments. Consider the following two
examples: in the first, operands are coded in fixed columns, as is
common practice.

*Example 1.1. Unindented Assembler Source*

BLOCK NAME=TEST
IF (condition1),THEN
LOOP WHILE,(condition2)
LEAVE   (condition3,),IF=*
ENDLOOP WHILE
ENDIF
ENDBLK


In the second example, the same instructions are indented based on the
nesting level of each. While this may look unusual to the hardened
Assembler programmer, it's easier to follow the nesting levels, and thus
the logical structure, by sight alone.

*Example 1.2. Indented Assembler Source*

BLOCK NAME=TEST
  IF    (condition1),THEN
    LOOP  WHILE,(condition2)
      LEAVE LOOP=*,(condition3)
    ENDLOOP WHILE
  ENDIF
ENDBLK


Since the macros require proper nesting of structures to generate tags
for branches and the like, correct pairing of complementary macros is
important. The structured assembler cataloged procedures in use at
Clemson include a pre-step that examines your source for nesting
problems and lists your program with a nesting-level report. This
pre-processor is described later in Chapter 14, <##listing>/Structured
Macros Listing Program/ <##listing>.

The nesting of structures provides a very specific path for the program
to follow. This can be interrupted where necessary by the use of the
LEAVE macro. This macro allows the program to leave a structure
prematurely either conditionally or unconditionally. By default, the
LEAVE macro leaves the innermost structure of the type specified.
However, it can be used to exit a structure from any depth. If you are
leaving from a deeply nested series of inline blocks, restoring
registers and AMODEs properly is a complicated task. The LEAVE macro can
handle this task nicely. The programmer should not have to worry about
this. You can leave an arbitrarily complex structure and LEAVE will
handle the details.


    Chapter 2. Conditional Statements

*Table of Contents*

Standard Conditions <#id420432>
Coding Conditional Expressions <#id479304>
User-Defined Conditions <##ucond>

Using the Structured Macros, conditional expressions are defined in
terms of the instruction(s) that will make the comparison. Conditional
expressions are mandatory on some macros (IF, ELSEIF, and some forms of
LOOP) and optional on others (LEAVE and ERREXIT). The syntax of a
conditional expression on each of these macros is identical.


    Standard Conditions

The format of a single condition can be any of the following:

  *

    (*CLC*,operand1,condition,operand2)

  *

    (*CR*,operand1,condition,operand2)

  *

    (*C*,operand1,condition,operand2)

  *

    (*CP*,operand1,condition,operand2)

  *

    (*CH*,operand1,condition,operand2)

  *

    (*CHI*,operand1,condition,operand2)

  *

    (*CLR*,operand1,condition,operand2)

  *

    (*CL*,operand1,condition,operand2)

  *

    (*CLI*,operand1,condition,operand2)

  *

    (*CLCL*,operand1,condition,operand2)

  *

    (*TM*,operand1,condition,operand2)

  *

    (*CLM*,operand1,mask,condition,operand2)

  *

    (*TREG*,operand1,condition)

  *

    (*TBIT*,[operand1,]operand2[,*ON|OFF|ANY|MIXED*]) default ON

  *

    ( *#TEST,*operand1[,*ON|OFF|ANY*]) default ON

where:

  *

    The first parameter is the machine or macro instruction that is to
    be used to perform the comparison. CLC, CR, C, CP, CH, CLR, CL, CLI,
    CLCL, TM and CLM are all S/370 machine instructions. TREG is a macro
    that tests a register for zero, positive, or negative. TBIT is
    another macro that is used for testing bits. As signified, the only
    conditions that can be specified for TBIT are ON, OFF, ANY and
    MIXED. #TEST supports the IDMS/DC #TEST macro. #TEST supports the
    conditions ON, OFF and ANY.

  *

    *operand1*is the first operand of the specified instruction or
    macro. Any valid form of the operand for the comparison being
    performed is allowed.

  *

    *operand2*is the second operand of the specified instruction or
    macro. Any valid form of the operand for the comparison being
    performed is allowed.

  *

    *mask*is the mask operand of the CLM instruction and can be any form
    that is valid in the instruction itself.

  *

    *condition*may be coded as one of the following:

    EQ
        Equal
    E
        Equal
    NE
        Not equal
    LT
        Less than
    GT
        Greater than
    LE
        Less than or equal
    GE
        Greater than or equal
    Z
        Zero
    NZ
        Not zero
    M
        Minus or mixed
    NM
        Not minus or not mixed
    P
        Positive
    NP
        Not positive
    O
        Ones or overflow
    NO
        Not ones or not overflow
    ON
        All flags on
    OFF
        All flags off
    ANY
        Any flags on
    MIXED
        Mixed
    CCnn
        Condition code, CC1 through CC14

The conditional expression coded expands using the comparison
instruction(s) provided and appropriate conditional branches. For
example, instead of the expression |IF A=B,THEN|, you code |IF
(CLC,A,EQ,B),THEN|, which would generate a |CLC A,B|and a
|BNE|instruction to the appropriate ELSE, ELSEIF or ENDIF macro.


    Coding Conditional Expressions

Boolean expressions and nested conditions are available when using the
Structured Macros. Using the Boolean operators AND, OR and NOT,
conditional expressions can be nested and/or concatenated on a single
macro. Under Assembler H (IEV90), the depth of nesting is limited to 255
characters within the outer parentheses. Multiple conditions are
evaluated following the normal precedence rules with expressions in
parentheses taking precedence and NOT being done before AND, and AND
being done before OR.

For example, you can code:

 IF   NOT,(CLC,A,EQ,B)


which is equivalent to:

 IF   (CLC,A,NE,B)


Multiple conditions can be coded together, as in this example:

 IF   ((CLC,A,EQ,B),OR,(CLC,C,EQ,D),AND,(CLC,E,EQ,D))


which is equivalent to:

 IF   ((CLC,A,EQ,B),OR,((CLC,C,EQ,D),AND,(CLC,E,EQ,D)))


The rules of Boolean algebra are followed by the Structured Macros. For
example, the Boolean expression |NOT (x AND y)|is equivalent to |NOT (x)
OR NOT (y)|. Similarly, the IF statement

 IF   (NOT,((CLC,A,EQ,B),AND,(CLC,C,EQ,D))),THEN


and the IF statement

 IF   (NOT,(CLC,A,EQ,B),OR,NOT,(CLC,C,EQ,D)),THEN


and the IF statement

 IF   ((CLC,A,NE,B),OR,(CLC,C,NE,D)),THEN


will all generate identical code.

Although parentheses and the precedence rules affect the meaning of the
expressions, the comparisons are always generated in the order that they
are coded. There are two cases where this is significant. Consider the
following example:

 IF   ((CLI,A,EQ,C'Y'),AND,(C,R3,EQ,B))


The second comparison will only be done if the first one succeeds. This
can be very useful if you only have addressability for the second
comparison if the first one is true. Another case where coding order is
important can be illustrated by the following two IF statements:

 IF   ((Z),OR,(CLC,A,EQ,B))

 IF   ((CLC,A,EQ,B),OR,(Z))


In the first example, the zero conditional test refers to the condition
code that exists from a previous instruction before the IF is
encountered. In the second example, the zero conditional test refers to
the result of the compare that precedes it. Because it is sometimes
difficult to determine which comparisons will actually be performed in a
particular multiple condition IF statement, it is usually a good
practice to put a condition test with no comparison only at the
beginning of an IF.


    User-Defined Conditions

Although the conditions supported by the Structured Macros cover most of
the standard types of comparisions, there are occasionally instances
where they are not sufficient. To avoid unpleasant side-effects, we have
decided that our conditions will never modify storage locations or
registers. Therefore, we do not have conditions for things like TRT
(Translate and Test), which modifies registers one and two. In addition,
many programs will have tests involving more than a simple compare that
they do repeatedly. It would be helpful to be able to code these tests
within a Structured Macros conditional expression.

Fortunately, there is a very easy way to get around both of these
situations. The Structured Macros provide a facility to allow you to
define your own conditional tests that can be placed within any
conditional expression. User-defined conditions are identified by a
percent sign (%) and may have any number of operands following them. For
example, suppose you wanted to be able to code something like this:

IF    ((TREG,R4,NZ),AND,(%TRT,0(8,R4),NE,PSDVALID))
  .
  .
  .
ENDIF


Before you can use the %TRT condition, you need to do two things. First,
you must define the condition name itself and identify the macro that
will process it. This is done with the DEFUCOND macro. Second, you must
code the macro itself. For our %TRT example, these two steps would look
like this:

   DEFUCOND NAME=TRT,MACRO=TRT_UCOND   | Define the condition name.
          MACRO
 &NAME    TRT_UCOND &EXPR,&S=,&F=,&L=  | Our TRT macro.
          AIF (N'&EXPR NE 4).ERR0001   | Were we called wrong?
 &NAME    TRT   &EXPR(2),&EXPR(4)      | Do TRT instruction.
          ##COND &EXPR(3),             | Test result and branch       +
                S=&S,F=&F,L=&L         |   as appropriate.
          MEXIT
 .ERR0001 MNOTE 8,'Wrong number of parameters in %TRT expr'
          MEND


There are several important requirements that all user-condition macros
must meet. When those are understood, writing these macros becomes quite
simple. First, the &NAME label is required and must identify the first
executable statement generated by your macro. The Structured Macros
generate a unique label for &NAME so that they can branch to your
condition when it is part of a compound conditional expression.

Next come the parameters that your macro will be called with. The first
parameter is positional and is the entire condition that invoked this
macro, including the condition name. For our previous example, this
would be |(%TRT,0(8,R4),NE,PSDVALID)|The individual fields within the
condition can be extracted by subscripting the expression. For example
&EXPR(3) for the third item in the expression (NE). The next three
keyword parameters (S=, F=, and L=) define the tag names that the macro
should branch to on success and failure and indicate the logic of this
conditional (P for positive and N for negative).

The Logic keyword (L=) needs a little explaining. Positive logic says
that the macro should branch to the success tag if the condition is true
and fall through to the following code if the condition is false.
Positive logic is used for things like ERREXIT and LEAVE. Negative logic
says to branch to the failure tag if the condition is false and fall
through if it is true. This is used in standard IF statements.

The ##COND macro is an internal macro that should only be used within
other macros. Its purpose is to evaluate a conditional expression and
properly process the S=, F=, and L= keywords. The expression passed to
##COND can be any valid conditional expression including Boolean
expressions, nested conditions, and other user-defined conditions. Most
user-defined condition macros will include a ##COND macro to perform the
actual test and process the S=, F=, and L= keywords. This greatly
simplifies the macro.

For another example, what if you wanted to be able to check the status
of ISPF like this?

IF    (%ISPFACT)
  .
  .
  .
ELSE
  .
  .
  .
ENDIF


Define the %ISPFACT condition like this:

   DEFUCOND NAME=ISPFACT,MACRO=ISPF_UCOND
          MACRO
 &NAME    ISPF_UCOND &EXPR,&S=,&F=,&L=
          AIF (N'&EXPR NE 1).ERR0001   | Check number of parms.
 &NAME    LINK  EP=ISPQRY              | Call ISPF status routine.
          ##COND (TREG,R15,Z),         | Check condition code.        +
                S=&S,F=&F,L=&L
          MEXIT
 .ERR0001 MNOTE 8,'Wrong number of parameters in %ISPFACT expr'
          MEND


There are several user-defined conditions provided in a copy member
called SMPUCOND. These should provide good examples of how to code user
conditions and may also be useful in programs. You can include them in
your programs by placing a |COPY SMPUCOND|statement at the start of your
program.


      Note

Be careful when using conditions that modifiy registers or storage
locations. When these conditions are used as part of a compound
conditional expression, they can affect the other conditions in the
expression. Be careful of your register usage in these cases and
remember that although some conditions in an expression may be skipped
because of the logic, conditions are always evaluated in the order they
are coded.


    Chapter 3. Blocks

*Table of Contents*

The Program Block <#id480152>
The Inline Block <#id480866>
The Subroutine Block <#id480918>
The ErrExit Block <#id480993>

There are 4 types of blocks available with the Structured Programming
Macros. These are: the /program/block, the /inline/block, the
/subroutine/block, and the /errexit/block. Each type of block can be
named, and this name can be used as a reference on the associated ENDBLK
macro and also on the LEAVE macro.


    The Program Block

The program block encloses the main body of a program and corresponds
roughly to a mainline. Program blocks can not be enclosed by any other
structure. They must be used at block level zero. The program block must
be the first block coded for a program. Options and the ENVIRON keyword
on the BLOCK TYPE=PROGRAM macro determine the type of linkage,
initialization and other program attributes to be established. The
associated ENDBLK macro will reverse the linkage when it is executed. A
LEAVE macro which either names the program block or is coded as BLOCK=*
at the program block's block level will cause a branch to the ENDBLK
macro, thus terminating the program.

When writing a program that uses both 24-bit and 31-bit addressing under
MVS/XA, a Structured Macro Workarea (SMWA) must be provided for the
macro's use. This is automatically provided by the SWA and PWA services,
or can be specified with a keyword on the block macro. The SMWA is a
doubleword of storage that is used to save work registers and addressing
modes, thus allowing an AMODE change without disturbing the registers.


    The Inline Block

Inline blocks are generally used to set off a procedure from neighboring
code. Inline blocks provide a structure that can be exited with the
LEAVE BLOCK=* macro. Inline blocks are placed within the other types of
blocks and can be nested within themselves. If desired, registers can be
saved and restored when entering and leaving an inline block by use of
the SAVE operand on the BLOCK macro.

When writing programs that will be run on MVS/XA, the inline block can
be used to switch addressing modes ôon the flyö. For example, the
following program section is running AMODE 31 and RMODE 24, but needs to
issue a PUT, which requires AMODE 24. These instructions generate the
correct sequence of instructions to save the current addressing mode,
switch to AMODE 24, and then restore the saved addressing mode at the
end of the block.

*Example 3.1. Switching AMODE*

-- AMODE 31 code --
   :
BLOCK  AMODE=24
 PUT   SYSPRINT,RECORD
ENDBLK
   :
-- AMODE 31 code --



    The Subroutine Block

Subroutine blocks contain code that is reached using the CALLSUB macro.
Subroutines coded in this manner must be at block level zero (i.e.
cannot be contained within any other block). Subroutine blocks should be
coded after the program block to which they belong. Subroutine blocks
are meant for internal subroutines, not for a called program that
follows standard OS linkage conventions.

A subroutine block is called by CALLSUB using |BAL R14,routine|or an
equivalent sequence. By using the SAVE operand, the subroutine can have
some or all of its registers saved and restored, although its use is
optional. If Subroutine Work Areas (SWAs) are used, registers R0-R14 are
automatically saved in the SWA and restored when the subroutine is
exited. In this case, the SAVE operand is invalid. The user can also
specify that the USING environment be saved and restored around the
subroutine. This prevents any USINGs within the subroutine from
affecting the rest of the program. Furthermore, a subroutine can request
that its AMODE be switched and restored on entry and exit by using the
AMODE operand.

The CALLSUB macro uses register 14 to link to the subroutine, but all
other registers have the same value on entry to the subroutine that they
had in the calling program. However, if Dynamic Storage Management or
the LONG program option is used, register 15 is also destroyed by the
CALLSUB linkage. For more information about dynamic storage, see Chapter
6, <##large>/Large Program Management/ <##large>.


    The ErrExit Block

The errexit block is executed whenever an ERREXIT macro that refers to
it is executed. Like the subroutine block, the errexit block must be
coded at block level zero. Errexit blocks should be coded with the
subroutine blocks after the program block to which they belong. The
ENDBLK macro associated with an errexit block generates a branch to the
program block's ENDBLK expansion, and also allows you to specify a
return code with which the program terminates. This return code
overrides any return code that might appear on the program block's
ENDBLK macro.


    Chapter 4. Program Environments

*Table of Contents*

DC Environment <#id480675>

System Mode And User Mode <#id480689>
Reentrancy Under IDMS/DC <#id481323>
*NORENT <#id481357>
*NORENTSYS <#id481378>
*RENT <#id481394>
*RENTSYS <#id481416>
*PWA <#id481439>
*PWASYS <#id481470>

OS Environment <#id481498>

*NORENT <#id481518>
*RENT <#id481540>
*PWA <##ospwa>
*MAIN <#id481654>
*NOMAIN <#id481682>
*SRVPRC <#id481702>

PL/I Environment <#id481723>

*STDPLI <#id481743>

Other Environments <#id481784>
Subroutine Block Super Options <#id481843>

*SWA <#id481856>
*NOSUBOPTS <#id481886>

Conclusion <#id481913>

There are several types of environments for which the Structured Macros
contain explicit support. These environments are selected with the
ENVIRON keyword of the program block macro. The environments are: the
/OS program environment/, which supports standard OS linkages; the /DC
program environment/, which supports Cullinet IDMS/DC linkage; and the
/PLI environment/, which supports the execution time environment of
release 5 of the OS Optimizing Compiler. Other types of environments can
be accommodated by coding your own linkage.

The options and keywords on the program and subroutine block macros
allow you to control virtually all phases of the program linkage as well
as the Structured Macros options. All of the major initialization and
termination functions are represented by their individual keywords.
However, there are certain program types that occur frequently. To cut
down on the number of options that need to be coded to represent these
program types, the /super options/can be used. They contain the correct
combination of options for the most common program types. The super
options for each environment are discussed in their corresponding
sections below.


    DC Environment

Specifying ENVIRON=DC generates support for programs to execute in the
IDMS/DC run-time environment. This support is relatively new and perhaps
does not support all of the functions required by its users: however, a
basic set of options and super options should satisfy most IDMS/DC
programmers' needs.


      System Mode And User Mode

IDMS/DC programs generally are called in either /system mode/or /user
mode/. As a rule, user-mode programs are called by a #LINK or #XCTL and
use #RETURN to return to their caller, while system-mode programs are
called by #CALL and return with #RTN, and also have a slightly different
set of register and linkage conventions. IDMS/DC applications whose
program names are invoked by a task code or called by #LINK or #XCTL are
almost always user mode programs, while DC numbered exits and map edit
routines are usually system mode programs. Both types are supported by
ENVIRON=DC.


      Reentrancy Under IDMS/DC

Since any IDMS/DC program can be in use by several users at any given
time, reentrancy in application programs and DC system routines is much
more valuable than under the standard MVS environment. The savings in
execution time gained by avoiding a #GETSTG/#FREESTG and management of a
reentrant program workarea are usually far outweighed by the program
pool savings and avoidance of program management overhead gained by
making a program truly reentrant. System mode programs, where speed and
efficiency are prime considerations, can take advantage of IDMS/DC's
#GETSTK service for ôfast storageö if their PWA storage requirements are
small.


      *NORENT

A non-reentrant user mode program in IDMS/DC terms means basically the
same as a non-reentrant program under the OS environment: IDMS/DC does
not allow users to share a copy of the program, but loads a new copy
each time a new user requests one. As a result, the program can contain
its variables within its CSECT without having to acquire storage from
IDMS/DC for them.


      *NORENTSYS

This super option defines a non-reentrant system mode program for
IDMS/DC. This option is provided for consistency: however, it is
recommended that any system mode program be assembled as reentrant,
using either the *RENTSYS or *PWASYS super option.


      *RENT

Reentrancy in an IDMS/DC user mode program allows IDMS/DC to share a
single copy of the program among multiple users, and also allows the
program to be loaded into the IDMS/DC reentrant program pool. The *RENT
super option causes reentrant linkage to occur, but does not acquire any
variable storage for the program.


      *RENTSYS

The *RENTSYS super option causes reentrant linkage to occur for an
IDMS/DC system mode routine. Like *RENT, *RENTSYS does not acquire any
variable storage for the program: thus, if local variable storage is not
needed, the overhead of #GETSTG/#FREESTG can be avoided.


      *PWA

The *PWA super option causes a #GETSTG and #FREESTG to be included in
the linkage and delinkage for the program, thus allowing reentrancy and
providing storage for variables. This process (except for actually
acquiring the storage) is basically the same as described in the *PWA
section under the section called ô*PWAö <##ospwa> .


      *PWASYS

This is generally the option that system mode programs would use if they
have any need for variable storage. If a small PWA (10 fullwords or
less) is all that's needed, the option GETSTK can be coded among the
program block's OPTIONS: this causes #GETSTK to be used to acquire
variable storage from the task's TCE stack, which is much faster than
calling #GETSTG and #FREESTG.


    OS Environment

The OS environment is the default environment and supports standard OS
linkage. By specifying different options, you can have the Structured
Macros do as little or as much of the linkage as desired. For most
situations, there are super options that pick the correct set of options
for you.


      *NORENT

If a program is non-reentrant, the system will load a fresh copy of it
every time the program is invoked. Because of this, the program is
allowed to modify itself. Data and work areas can be stored in the load
module itself. Most user programs can be non-reentrant. The *NORENT
super option will automatically define a save area in the program ID
section and perform non-reentrant linkage.


      *RENT

Since reentrant programs are not reloaded every time they are invoked,
they are not allowed to modify any fields within themselves. Any data
that might be modified must be copied into working storage that has been
GETMAINed, and modified there. This preserves the integrity of the load
module for other users. The *RENT super option provides the reentrant
linkage and automatically GETMAINs storage for a save area. No provision
is made for a Program Work Area (PWA). Any storage (other than the save
area) needed by the program must be acquired by the user. Because of
this, the *RENT super option is not very useful for new programs. *PWA
provides much better support for reentrant programs. *RENT was included
to provide support for those programs that already acquire their own
storage or that for some reason could not use the storage provided by *PWA.


      *PWA

*PWA provides all the functions of *RENT, plus it automatically GETMAINs
and FREEs a Program Work Area (PWA) for the user. The best way to
illustrate this is with an example:

 BLOCK NAME=MAINPROG,TYPE=PROGRAM,OPTIONS=(*PWA)
        :
        :
 ENDBLK BLOCK=MAINPROG
 PSD
        :
   Static Data
        :
 ENDPSD
 PWA
        :
   Work Area
        :
 ENDPWA


In the example above, the static data (constants and other data not
modified by the program) is placed at the end of the program in an area
called the PSD (Program Static Data) and included in the load module.
The PWA and ENDPWA macros define a DSECT for a block of storage acquired
for the user by the BLOCK macro and freed at the end of the program.
Space for the save area is automatically reserved in the PWA, so the
user does not need to worry about this. The user simply needs to define
any work area fields that the program needs between the PWA and ENDPWA
macros. After this storage is acquired by the BLOCK macro, it is cleared
for the user and addressability is set up using register 13. This super
option makes writing reentrant programs almost as easy as writing
non-reentrant ones. The bothersome details of computing storage
requirements, GETMAINing storage, keeping up with addresses, and
FREEMAINing the acquired storage are handled by the Structured
Programming Macros.

The *PWA option and the PWA macro also provide a variety of other
features that are described in more detail in Chapter 5,
<##pwaswa>/Program and Subroutine Work Areas/ <##pwaswa>.


      *MAIN

The *MAIN super option provides all of the features of *PWA and adds the
options DYN and MAIN. This allows SWAs to be allocated from dynamic
storage instead of being statically defined in the PWA. See Chapter 6,
<##large>/Large Program Management/ <##large>for more information on
dynamic storage. The *MAIN super option should be used on the program
block for any main program that uses dynamic storage.


      *NOMAIN

The *NOMAIN super option provides all of the features of *MAIN except
that it specifies option NOMAIN instead of MAIN. This super option
should be used on a program block that represents an external subroutine
called from another program that uses dynamic storage.


      *SRVPRC

The *SRVPRC super option is used by service processors. Refer to
/Clemson University Computer Center Service Processor User's Guide and
Reference/for more information on this super option.


    PL/I Environment

ENVIRON=PLI supports the execution time environment of release 5 of the
OS PL/I Optimizing Compiler. At the current time this support is
minimal, but it should satisfy the needs of most assembler programs that
run as subroutines to PL/I programs and use the PL/I environment.


      *STDPLI

This is the only PL/I environment super option and should always be
specified. The Structured Macros' support of PL/I is not as fully
developed as it is for the OS and DC environments. Specifying this
option will help insure future compatibility.

This super option provides the proper reentrant linkage for a majority
of assembler programs that run in an OS PL/I Optimizing Compiler
execution time environment. Storage is obtained for a PWA in the same
manner as a PL/I program obtains storage for its DSA. A DSA in PL/I
contains an OS save area, control information and program variables.


    Other Environments

If you want to use the Structured Macros in other than one of the
explicitly supported environments, you can code your own linkage or add
support for the environment with prolog and epilog macros.

If you want to code your own linkage, let the environment default to OS
and do not code any linkage-related options. Put your own linkage before
or after the program block macro and after the end block macro for the
program. If you do your own linkage you cannot use PWAs, SWAs, PSDs,
SSDs or anything related.

If the Structured Macros will be used often in this environment or if
you need to use PWAs, etc., it might be worth the time to add support
for the environment. Refer to the internals manual for the Structured
Macros for information on writing prolog and epilog macros if you would
like to take this approach.

Adding support for an environment requires a thorough understanding of
the internals of the Structured Macros and the support might have to be
updated each time the Structured Macros themselves are updated. If the
environment needed is of general interest, you might want to request
that it be added as a standard part of the Structured Macros and
supported as such.


    Subroutine Block Super Options

All environments use the same subroutine block options and super options.


      *SWA

In any program that uses the PWA option, the internal subroutines for
that program can each have an individual Subroutine Work Area (SWA). The
*SWA super option is specified on the subroutine block (or the SUBOPTS=
on the program block) to provide an SWA for a subroutine. There are SWA
and ENDSWA macros to delimit the SWA just as the PWA was delimited. The
details about the functions of an SWA and its relation to a PWA are
described in Chapter 5, <##pwaswa>/Program and Subroutine Work Areas/
<##pwaswa>.


      *NOSUBOPTS

This super option clears all the subroutine options to their ônoö state.
If the program block has specified a default set of subroutine options
with the SUBOPTS= keyword, this super option can be used on a subroutine
block to create a subroutine without those default options. For example,
a *NOSUBOPTS,CUSTOM might be coded to create a subroutine with just the
CUSTOM option.


    Conclusion

The environment support and super options make programming much easier,
since all of the tedious initialization and termination details are
taken care of with a minimum of effort. This allows you to worry about
program logic and not the linkage. They also do not lock you into only
these combinations of options. If you want to override any of the
options in a super option, simply code them after the super option on
the OPTIONS= keyword. For example:

BLOCK  TYPE=PROGRAM,NAME=PROG,OPTIONS=(*PWA,XA,NOREGEQU),ENVIRON=OS



    Chapter 5. Program and Subroutine Work Areas

*Table of Contents*

Program Work Areas <#id480591>
Reusable Program Work Areas <#id482608>
Subroutine Work Areas <#id482699>
SWA Placement <#id482794>
PSDs and SSDs <#id482826>

The Program and Subroutine Work Area (PWA and SWA) support built into
the Structured Programming Macros is a powerful tool that can be
invaluable to someone writing a complex program, and also provides
services that can be useful in even a relatively small program. Although
PWAs and SWAs are normally used in reentrant programs, even
non-reentrant programs can take advantage of the services they provide.
If option NORENT is in effect, the storage for the work areas is defined
in the load module instead of being dynamically obtained at execution time.


    Program Work Areas

The PWA option and PWA macro provide many services besides just defining
a block of storage to be obtained for the user. By specifying that the
program has a PWA, you allow the Structured Macros to automatically
perform many functions. For example, space for a SMWA for the main
program and one for each of the subroutines is reserved in the PWA
preventing you from having to code the SMWA= keyword on the program
block. If you want to override this and force the SMWA to a specific
location, the SMWA= keyword can still be used.

You can have parameter lists placed in the PWA without having to
explicitly define storage for them. The Structured Macros can compute
the largest parameter list in the program and reserve enough space in
the PWA. A separate parameter list area is reserved for the program and
each subroutine. This is required because the program parameter storage
might be in use when a subroutine is called. For more information on
parameter lists, see Chapter 10, <##parms>/Parameter Lists and Standard
Linkage/ <##parms>.

Option PWA allows you to define a Subroutine Work Area (SWA) for each
subroutine that contains any work area fields that are needed only while
the subroutine is executing. This SWA is analogous to the PWA for the
program.


    Reusable Program Work Areas

Under normal circumstances, the PWA for a program is allocated whenever
the program is called, and freed before the program terminates. However,
there are cases when a program is loaded into memory once and called
repeatedly to perform a particular function. Not only would it be
inefficient to repeatedly acquire and free storage for this program, it
might cause problems if the program is required to retain information
between calls.

This problem is solved by a mechanism known as Reusable PWAs. Using this
capabilility, the Structured Macros allocates a new PWA only when given
a start-up call and does not free the storage when the program
terminates. When the program detects that it is being called for the
final time, it can issue a macro to instruct the Structured Macros to
free the PWA storage at the termination of the current invocation.

When reusable PWAs are being used, the caller of the program must keep
track of the PWA address and pass it in the parameter list on every
call. The position of the PWA address in the parameter list is
customizable. If this address is binary zeros, the Structured Macros
allocates storage for a new PWA and stores its address back into the
parameter list. Otherwise, they use the passed value.

Alternatively, you can specify a parameter position for a function code
to be provided on every call and a value that means Start. With this
form, the Structured Macros allocate a new PWA on the Start call, and
use the passed PWA value in other cases.

When the program is in its final invocation (either because of an error
or when called to terminate), the SMCTRL macro is used to force the
Structured Macros to free the PWA at program termination.

This concept is used heavily at Clemson by what we call Service
Processors. These are programs that are started once and then called
repeatedly to perform a particular type of service for their invoker.
File handling, string manipulation, and symbol management are all
examples of functions that can be handled by service processors. For
more information about the workings of Service Processors, see /Clemson
University Computer Center Service Processor User's Guide and Reference/.


    Subroutine Work Areas

Any subroutine that uses an SWA should use the SWA and ENDSWA macros to
define its boundaries, just as the PWA and ENDPWA macros are used for
the program's PWA. There are options on the subroutine block to control
SWA usage, and a super option (*SWA) that provides the correct
combination of options for SWA usage.

SWAs provide useful functions for subroutines just as PWAs do for
programs. SMWAs and parameter lists for the subroutines are created as
part of the SWA instead of as PWA fields. R0-R14 are automatically saved
and restored for any subroutine that has an SWA. Space for this is
reserved by the SWA macro. You do not have to code the SAVE keyword, or
explicitly reserve the space. The registers are saved as R0-R14 so that
R15 is not restored and the subroutine can pass a return code back in
this register.

You should be aware of the implications of saving and restoring
registers. A subroutine can not pass back any values to its caller by
way of the registers. It would have to use the PWA to pass back any
information. To get around this problem, the STRSA macro was created.
STRSA stores the current value of a register in the SWA save area for
the current subroutine. Then when the subroutine ends, the register is
restored to the value it had when the STRSA macro was issued, instead of
the value it had when the subroutine was called. You can use the STRSA
macro to pass back any registers that the calling routine needs, while
allowing the other registers to be restored to their original values.

The CLEARPWA option on program blocks instructs the macros to clear the
PWA after it has been obtained. This option is included in all of the
super options that use PWAs so that you can count on the PWA being all
zeros on entry. However, there is not a similar option on the subroutine
block to clear the SWA. You should never count on the SWA contents
anytime a subroutine is entered. If the fields within the SWA need to be
set to a specific value, the subroutine must include code to initialize
these fields.

These functions of SWA usage can be a great help to the programmer, even
the subroutine does not need to have any of its own fields defined in
the SWA. If you select the SWA option, the Structured Macros generate an
SWA for internal use in saving registers, even if you do not code the
SWA and ENDSWA macros at the end of your subroutine.


    SWA Placement

With the *PWA option, these SWAs are included as part of the PWA for the
program to which they belong. They are placed in the PWA's partial area
and addressability is off of the PWA register (R13). This configuration
of PWAs and SWAs is changed in programs that use the Structured Macros'
dynamic storage management support. For more information on this, see
the section called ôPWAs and SWAs with Dynamic Storage Managementö
<##dynpwa>.


    PSDs and SSDs

The PSD and SSD macros (and their respective end macros) are used to
define the Program and Subroutine Static Data areas, just as PWA and SWA
are used to define the work areas. These macros are used in conjunction
with the LOCTR option on the program block to insure proper placement of
the program code and static data. They also allow fields to be defined
from within the program code that is placed with the static data when
the program is assembled. This facility is used by the EXI macro. These
data areas are addressed off of the same base registers as the program
and subroutine code.


    Chapter 6. Large Program Management

*Table of Contents*

PWAs and SWAs with Dynamic Storage Management <##dynpwa>

Recursive Subroutines with the DYN Option <#id483218>
Storage Calculations with the DYN Option <#id483252>
SWA Addressability with the DYN Option <#id483287>
Super Options Used with the DYN Option <#id483309>
Storage Optimization with the DYN Option <#id483370>

LONG and LOADBASE <#id483417>
Size Limitations <#id483502>
Conclusion <#id483547>

As a program becomes larger and contains more subroutines, certain
problems arise. The PWA (which contains an SWA for each subroutine) can
grow to an unmanageable size. Also, the program code along with the
subroutine code can become so long that it would take several base
registers to maintain addressability. The Structured Macros provide two
tools to help manage such large programs. They are Dynamic Storage
Management and the LONG and LOADBASE options. Dynamic Storage Management
is only available for program blocks that are using ENVIRON=OS.


    PWAs and SWAs with Dynamic Storage Management

If your program has a large number of internal subroutines that heavily
use SWA storage, the size of the PWA can easily grow to an unmanageable
size. If the fields defined in the SWA are really only necessary when
the subroutine is active, it is not necessary to allocate enough space
for all of the SWAs. Only enough storage to contain the PWA itself, and
the largest combination of active SWAs is required. If there were some
way to dynamically allocate and free SWA storage as subroutines were
entered and exited, a great savings in storage could be realized.

To solve this problem, the storage for an SWA could be GETMAINed as the
subroutine is entered and FREEd at the end, but this would slow down the
operation of the program greatly.

A much more efficient system is to obtain a large block of storage at
the beginning of the program, allocate the first part to the PWA, and
allocate the rest to SWAs as it is needed. This block of storage can be
much smaller than the size of the PWA plus all of the SWAs, since not
all of the subroutines will be active at once. Also, since new SWA
storage is allocated for a subroutine each time it is entered,
subroutines can be called recursively. With this system, a GETMAIN is
never done more than once for a single program. Enough storage is
allocated for all the program and subroutines' needs at the beginning,
and storage is assigned and taken back as subroutines are entered and
exited.

This is just what the Structured Macros' Dynamic Storage Management
does. The DYN option on the program block is used to turn on Dynamic
Storage Management. Dynamic Storage also allows subroutines to call
themselves, which adds more complexity. Also, there is hidden recursion,
such as when subroutine A calls subroutine B, and subroutine B in turn
calls subroutine A.


      Recursive Subroutines with the DYN Option

Recursive subroutines cause another problem. Since they are called again
without the previous invocation being ended, multiple copies of the
subroutine's SWA need to be allocated from dynamic storage. Since the
Structured Macros have no way of knowing how deep the recursion might
go, you need to supply this information. On any subroutine that will be
called recursively (this includes all the programs in a recursive loop
such as the one described above), you need to use the RECUR keyword to
tell the macros the maximum number of times the subroutine will be
called recursively. This keyword tells the macros how many copies of
that subroutines SWA could be active at once, and therefore how much
room to allocate. If you miscalculate on the RECUR keyword, the
Structured Macros will miscalculate on the space required. If you use
too big a number, the macros will allocate more space than is needed. If
you use too small a number, the macros will allocate too little space,
and a dynamic storage error will result. By default, the macros will
force an ABEND 0C1 when your program runs out of dynamic storage.
However, you can specify an error exit that will get control when this
happens with the DYNERR keyword on the program block.


      Storage Calculations with the DYN Option

The Structured Macros' algorithm is very comprehensive and will allocate
enough space for all known cases. It uses an internal macro called
##ORGS to trace the subroutine call structure of the program. From this,
it determines the subroutines that will be active together, and how big
their SWAs are. Using this information and the size of the PWA, the
macros determine how much space they will need to GETMAIN to accommodate
your program. This tracing of the subroutine structure is more difficult
than it may seem, since the main program and each subroutine might call
many other subroutines forming a very complex tree. However, there are
certain very complicated and unlikely combinations of subroutines that
can trick them into allocating more space than they need. If this ever
becomes a problem, it can be adjusted with the DYNSIZE keyword on the
program block. The DYNSIZE keyword is used to replace or adjust the
value for the amount of dynamic storage calculated by the macros. It can
be used in certain cases to fine-tune the dynamic storage requirements.
However, in most cases the macros themselves should calculate the
correct amount, and the DYNSIZE keyword should not be needed.


      SWA Addressability with the DYN Option

These SWAs are based off of register 11, while the subroutine itself is
addressed off of the program base, and the PWA base remains with
register 13. It should be noted that register 11 is in use in DYN
programs even when a subroutine has not been invoked.


      Super Options Used with the DYN Option

There are two program block super options for use with Dynamic Storage
Management. They are *MAIN and *NOMAIN. *MAIN contains all of the
options in *PWA plus the options DYN and MAIN. The MAIN option tells DYN
that this is a main program and that dynamic storage should always be
obtained when this program is entered. By contrast, *NOMAIN says that
this program is an external subroutine that will be called from a main
program that uses DYN. In a *NOMAIN program, the dynamic storage of its
caller is used if there is enough of it. Otherwise, more storage is
GETMAINed to accommodate the program and its subroutines. It should be
emphasized that a program compiled with option *NOMAIN should /only/be
called from a program that uses Dynamic Storage Management. Even if the
*NOMAIN program GETMAINs its own storage, it requires that registers and
storage areas be set up by the calling program.

Any *MAIN program that calls external subroutines with *NOMAIN might
need to use the DYNSIZE keyword to adjust its dynamic storage to allow
for what the *NOMAIN program uses. Since the *NOMAIN program will most
likely be compiled separately, there is no way for the Structured Macros
to calculate its requirements. However, since the *NOMAIN gets more
storage if it needs it, adjusting the storage on the *MAIN program only
affects performance by preventing an extra GETMAIN.


      Storage Optimization with the DYN Option

When using the DYN option, a short routine is added to the beginning of
each internal subroutine to obtain the new SWA. This is not a real
problem, but if the program has a large number of small subroutines,
this can significantly lengthen the load module. If the size of the load
module is critical, the OPTSTOR option can be used on the program block
to help remedy this. The OPTSTOR option will create a single copy of the
subroutine linkage code and have each subroutine branch to it. This
makes subroutine calls slower, but will reduce the size of the load
module. However, space is rarely this critical, so the OPTSTOR option is
not needed in most cases.


    LONG and LOADBASE

When a program gets to be very long with a lot of subroutines (such as a
server routine or a command processor), the CSECT can become so large
that it takes two, three, or even more base registers to maintain
addressability. It would be nice if there were some way to allow a
subroutine to have its own base register separate from the program's
base register. The LOADBASE option on subroutine blocks and the LONG
option on the program block provide this support.

The LOADBASE option on the subroutine block instructs the subroutine
linkage routines to establish a separate addressability to that
subroutine using the subroutine base register. This register defaults to
R10, but another register can be selected with the BASEREG= keyword. Any
subroutines coded in this manner are located at the end of the CSECT, so
that they do not interfere with the program's addressability.

If a program has any subroutines that use the LOADBASE option, the
program block must have the LONG option coded. This option causes
CALLSUB to generate the correct linkage for LOADBASE subroutines. Since
both of these options make use of partial PSDs, the LOCTR option is also
required when using these. However, LOCTR is included in all of the
super options, so usually you do not have to code it.

With this scheme, the macros always keep a base to the program and to
the current subroutine. Therefore, the program will be able to address
anything in the program and its PSD as well as the current subroutine
and its SSD. However, one subroutine cannot address anything in another
subroutine's SSD. If you have any static data that is shared among
subroutines, place it in the PSD.

Since a separate base register is kept for the program and the current
subroutine, this facility is only useful in programs that already need
two or more base registers. However, with these options the program base
register only needs to address the main program code and its static
data. If even this can not be done with a single base register, the main
program code can be moved to an internal subroutine with only a single
CALLSUB in the program block.


    Size Limitations

With the techniques described here, a very large program can be created
quite easily. Although most programmers will never exceed the Structured
Macros' limits, it may be useful to know just how large a program can
become. The only limitation on program length (and it's static data) is
the number of base registers you are willing to use to address it. But
with the LONG and LOADBASE options, this is not necessarily a problem.
PWAs can be up to 16M in size, but again you must maintain
addressibility on it. SWAs can be up to a maximum of 32K in size if DYN
is in effect. If the majority of one of your data or work areas is a
single very large data area that you only need to address the start of,
you can place it at the end of the data area. The user fields always go
after the fields generated by the Structured Macros.


    Conclusion

The long program management routines provide very useful support for
large or memory intensive programs. A great savings in GETMAINed storage
can be achieved in programs with large numbers of subroutines, and many
of the tedious details of subroutine linkage and program storage can be
automated. A savings in base registers can also be achieved in extremely
long programs. For more information on the actual layout of dynamic
storage, see Appendix C, <##dynform>/Work Area Storage Layout/
<##dynform>. For a description of program code and static data layout
with an example of how these options should be coded, see Appendix D,
<##codform>/Program Code and Static Data Layout/ <##codform>.


    Chapter 7. The IF Structure

There are four macros that are used to build IF structures: these are
/IF/, /ELSEIF/, /ELSE/, and /ENDIF/. Of these, conditions to govern
statements are coded on the IF and ELSEIF macros. Like the IF services
in many higher-level languages, there are Boolean operators available
(AND, OR, NOT) for building complex expressions; however, the
conditional statements themselves are coded using the actual assembler
compare instructions.

*Example 7.1. Conditional Statement Using Assembler Compare Instructions*

 IF    (CLC,TAG1(8),NE,6(R2)),THEN
         :
   -- success code --
         :
 ELSE
         :
   -- fail code --
         :
 ENDIF


Generates:

+         CLC   TAG1(8),6(R2)         generated by IF
+         BE    failtag               generated by IF
          :
  -- success code --
          :
+         B     endiftag              generated by ELSE
+failtag  DS    0H                    generated by ELSE
          :
  -- fail code --
          :
+endiftag DS    0H                    generated by ENDIF


*Example 7.2. Compound Conditional Statement Using Assembler Compare
Instructions*

 IF    ((CH,R1,EQ,A),OR,(CH,R1,EQ,B)),THEN
       :
   -- success code --
       :
 ENDIF


Generates:

+         CH    R1,A                  first comparison
+         BE    successtag            branch if test succeeds
+         CH    R1,B                  second comparison
+         BNE   failtag               branch if test fails
+successtag DS  0H                    generated by IF
          :
  -- success code --
          :
+failtag  DS    0H                    generated by ENDIF
+endiftag DS    0H                    generated by ENDIF


In these examples, one thing that you may have noticed is that the macro
expansions generate tags and branches to them as may be appropriate.
Although these tags are used only by the macros at assembly time, it is
very handy to have them available under TSO TEST.

The IF and ELSEIF macros allow you to specify conditions in a number of
ways, which are fully described in Chapter 2, <##condch>/Conditional
Statements/ <##condch>. Simply stated, the condition of the IF statement
provides the instruction that is used for the actual comparison and the
appropriate condition for the subsequent branch.

*Example 7.3. Comparison Condition and Branch*

 IF   (CLC,A(6),NE,3(R1)),THEN


Generates:

+         CLC   A(6),3(R1)
+         BE    failtag


Conditions can be combined on the IF statement using Boolean expressions
NOT, AND, and OR.

If a condition code is known to exist when an IF is executed, only the
desired conditional operator need be coded.

*Example 7.4. Coding Only the Conditional Operator When Condition Code
Is Known To Exist*

 TRT   TEXT,TABLE
 IF    Z,THEN
  MVC   MESSAGE(15),=CL15'TEXT NOT FOUND'
  PUT   SYSPRINT,MESSAGE
 ELSE
    :
    :
 ENDIF


In this example, the TRT instruction sets a zero condition code if the
translate-and-test operation fails. The subsequent IF statement is used
to generate a conditional branch without a compare instruction. This
form of the IF statement is useful for non-comparison instructions that
set a condition code, such as arithmetic and logical instructions. Avoid
mixing this form of condition with conditions that generate compare
instructions, though, because the order in which the instructions are
generated can cause the condition code to be changed prematurely.

The ELSEIF macro is similar to an ELSE macro followed by an IF macro,
except the IF nesting level is not changed. This allows you to test for
one condition out of a list of conditions.

*Example 7.5. Using ELSEIF*

 IF      (CLC,FUNC,EQ,=C'READ'),THEN
    :
    :
 ELSEIF  (CLC,FUNC,EQ,=C'WRITE'),THEN
    :
    :
 ELSEIF  (CLC,FUNC,EQ,=C'CLOSE'),THEN
    :
    :
 ENDIF


This is similar to the CASE structure, except that the CASE macro is
mainly used to select one out of a sequence of numerically ordered
items. For more information on the CASE macro, See Chapter 9,
<##case>/CASEs and CASE Blocks/ <##case>.


    Chapter 8. Loops

Variations of the /LOOP/and /ENDLOOP/macros can be used to create the
most commonly used loop structures. The types of loop available are as
follows:

  *

    *WHILE Loops: *Completion tests are performed at the top of the loop.

  *

    *UNTIL Loops: *Completion checking is done at the bottom of the loop.

  *

    *BCT and BXLE Loops: *Completion tests are performed at the end of
    the loop

  *

    *BXH Loops: *Completion checks are made at the top of the loop.

  *

    *Endless Loops: *Completion checks are made within the loop by the
    programmer's code.

The WHILE and UNTIL loops provide the Assembly language programmer with
the standard loop structures available in any high-level language and
the ability to control the loops with any condition that is legal in an
IF statement. See Chapter 2, <##condch>/Conditional Statements/
<##condch>for a complete description of the conditions that can be
specified with the Structured Macros. The BCT, BXH, and BXLE loop
provide support for the standard System/370 looping statements, while
preserving the structured nature of the code.

As in the other structures, the LEAVE macro can be used to exit a loop
if desired. In the case of an endless loop, a LEAVE macro is usually the
only way to exit the loop.

*Example 8.1. Types of LOOP macros *

   LOOP      WHILE,condition
     :
   ENDLOOP   WHILE


   LOOP      UNTIL
     :
   ENDLOOP   UNTIL,condition


   LOOP      UNTIL
     :
   ENDLOOP   UNTIL,LEAVE


   LOOP      BXH,r1,r2
     :
   ENDLOOP   BXH


   LOOP      BXLE
     :
   ENDLOOP   BXLE,r1,r2


   LOOP      BCT
     :
   ENDLOOP   BCT,reg



    Chapter 9. CASEs and CASE Blocks

The CASE structure can be used in place of the jump-table or
go-to-depending-on structure and serves the same function as the Pascal
CASE structure. The macros used to create the CASE structure are
CASEBLK, CASE and ENDCASE. The CASEBLK macro opens a case block and
generates code that selects a handler routine based on the contents of a
register. The ENDCASE macro denotes the end of a CASE block, and is
branched to at the end of each individual CASE. CASE macros within the
CASE block frame code that handles an individual case or occurrence.

A common example of the use of a CASE block might appear after a call to
some routine that can return one of several return codes, each of which
must be handled differently.

*Example 9.1. The CASE Block *

IF  (TREG,R15,NZ),THEN

  CASEBLK REG=R15,MULT=4

    CASE 4
    -- code handles return code 4

    CASE 12,16
    -- code handles return codes 12 and 16

    CASE OTHER
    -- code handles other return codes

  ENDCASE

ENDIF

Note that since the CASE and CASEBLK macros generate a series of
branches that are selected by the value in the CASEBLK register, they
should be used to select one value from a list of numerically ordered
choices. For comparing character data, or selecting from widely
separated values, the IF - ELSEIF structure should be used. For more
information on ELSEIF, see its description in Chapter 7, <##if>/The IF
Structure/ <##if>.


    Chapter 10. Parameter Lists and Standard Linkage

*Table of Contents*

Referencing Input Parameter Lists <#id484600>
Generating Parameter Lists <#id485185>
Automatic Parameter Lists <#id485428>
Permanent Parameter Lists <#id485470>
Calling Subroutines <#id485601>
Parameter Lists on CALLSUB and CALLX <#id485668>
Recommendations <#id485741>
Example Source <#id485850>

The Structured Macros provide excellent support for the main program
being called and for calling internal and external subroutines using
standard OS linkage conventions. A large part of this is handling
standard OS parameter lists. The standard form for these parameter lists
is a sequence of fullwords, each the address of a particular data item.
If a data item is missing, the address pointing to it is filled in with
a fullword of zeros. Upon entry to the routine, register 1 points to the
first fullword in the parameter list.

The handling of parameter lists consists of two parts. First, there must
be some way to reference input parameter lists. These lists are
processed by a program or subroutine block and are created by the
invoking program. Second, support is needed for generated parameter
lists. These are parameter lists that are created by a program or
subroutine block and then passed to an external routine or another
subroutine. These functions are intertwined, since a program that calls
an internal subroutine can create a generated parameter list that
becomes the input parameter list of the subroutine being called.


    Referencing Input Parameter Lists

The input parameter list for a program is referred to by the Structured
Macros as the Program Parameter List (PPL) The corresponding structure
for subroutines is the Subroutine Parameter List (SPL). The Structured
Macros provide a number of options to control the handling of input
parameter lists. These options are specified as sub-options of the PARMS
option.

The VL|NOVL parameter option identifies the input parameter list as
being either variable or fixed length.

The COPY parameter option instructs the macros to copy the input
parameter list into the current work area (PWA for programs and SWA for
subroutines). In this case, the PPL (or SPL for subroutines) is not the
original input parameter list, but a copy of the original made in
working storage. This has several uses. First, it prevents the program
from modifying the original parameter list. Modifying an input parameter
list is not allowed by the standard linkage rules. Second, by copying
the parameter list, it is addressed with the work area base register and
a separate parameter list register is not required. Last, the COPY
option makes it easier to determine which parameters were specified on a
variable length parameter list. The work area storage is always large
enough to hold the maximum length parameter list and is filled with
zeros before the input parameter list is copied there. Because of this,
the program only needs to test any parameter address for zero to see if
it was specified in the original parameter list. The COPY option
requires that the PWA option be specified for program blocks and that
the SWA option be specified on subroutine blocks.

The COPYERROR parameter option is required if the COPY option is used
with VL input parameter lists and is used to name the error exit that is
invoked if the input parameter list is too large to fit in the space
reserved for it in working storage. This happens if the parameter list
is larger than expected or if it is not a VL parameter list, which makes
it impossible for the Structured Macros to determine the last parameter.
Any error exit in the program can be specified, including the unnamed
error exit, and an exit code can be passed to the error exit identifing
the type of error, for a multi-purpose exit.

The COUNT parameter option specifies the location of a fullword into
which the Structured Macros place the number of parameters in a VL input
parameter list. This can be used to verify that the program is called
with the correct number of parameters.

The USING parameter option specifies a register to be loaded with the
starting address of the input parameter list. This is either the
original input parameter list, or an area within the current work area
(if COPY is also specified). After the register is loaded, a USING is
done to provide addressibility on the parameter list.

The PREFIX option instructs the macros to use a unique parameter list ID
when generating the tag names within the PPL or SPL. For more
information about how this is used, see Chapter 11, <##scope>/Location
and Scope of Data Structures/ <##scope>.

A description of the input parameter list must be provided in order to
make use of these options. There are two mutually exclusive keywords on
the BLOCK macro provided for this purpose.

If a mapping macro is already available for the input parameter list,
the PARMMAP keyword can be used to specify the Dsect name and length.
This provides a name for a USING on the parameter list and defines the
size of the area that must be reserved for a COPY.

If a mapping macro is not available, the PARMS keyword can be used to
specify a list of tags to be used to map the parameter list. These tag
names are either used to generate the parameter list Dsect or mapped to
the work area storage if COPY is being used.


      Note

Whether a parameter list is mapped by a supplied Dsect or tags generated
by the PARMS keyword, these tags do not refer to the parameters
themselves, but rather to the addresses of the parameters. This is not a
deficiency in the Structured Macros; it is simply the way that standard
OS parameters work.


    Generating Parameter Lists

Most external subroutines (and some internal ones) will require some
sort of parameter list to pass data between the calling program and the
subroutine.

The Structured Macros provide excellent support for building,
maintaining, and passing parameter lists. The PLIST macro is used to
create or modify a parameter list. It also loads register one with the
address of the completed list. The following example illustrates some of
the capabilities of the PLIST macro.

*Example 10.1. PLIST Macro*

  PLIST  (DATA1,,*DATA3,*),PL=(PARMSTOR,4)


This example statement builds a parameter list of four items at the
location pointed to by PARMSTOR. First is a simple data item whose
address is loaded into the parameter list. The second item in the list
is missing, so its address is filled in with a full word of zeros. The
third item in the list is filled in with the contents of DATA3 instead
of a pointer to DATA3. This form of indirect addressing is used when the
referenced storage contains a pointer to the actual parameter. The
asterisk in the fourth position tells the PLIST macro to skip over that
position in the list and leave the value there unchanged. This is useful
if you are modifying a parameter list that was created earlier, and you
only want to update certain fields. The fields that are not to be
changed can be marked with asterisks. Once the parameter list has been
built, PLIST loads register one with the address of PARMSTOR.

The PLIST macro allows the use of constants as well as labels when
defining parameter lists. Observe the following example:

*Example 10.2. PLIST Macro with Constants*

  PLIST (0,,'HELLO?',=X'FF')


which is equivalent to:

  PLIST (=F'0',,=C'HELLO?',=X'FF')


Both cases generate literal constants, and then fill in the parameter
list with the addresses of these constants. Any decimal self-defining
constant is treated as a full word literal and any character string in
quotes is treated as a character literal. Note that any other type of
literal (such as hex or binary) has to be coded as a literal. Since
decimal and character constants can be coded as constants instead of as
literals, the PLIST macro makes generating parameter lists even more
painless.

Note in the examples above the distinction between the first and second
parameter in each list. The first parameter is a decimal constant of
zero. The macros generate a full word of zero and fill in the first
position in the parameter list with the address of it. The second
parameter is missing, so the macros put a full word of zeros into the
parameter list itself. This is an important distinction to remember.

There are two main types of parameter lists: variable length (VL) and
fixed length (NOVL). In variable length parameter lists, the last
address in the list has its high bit set to one to mark it as the end of
the list. Since the length of fixed length parameter lists is known in
advance, the end does not need to be marked. The VL or NOVL option on
the program block macro is used to set up the default for all parameter
lists generated by the program or any of its internal subroutines. Note
that this is distinct from the VL parameter option (specified by the
PARMS option). The VL parameter option describes the input parameter
list. You can specify a VL (or NOVL) keyword on the PLIST macro to
override this default. Note that all of the super options specify VL so
that you get variable length parameter lists by default. If the PLIST
macro is generating a VL parameter list (either because of the VL option
on the program block or the VL keyword on the PLIST macro), the last
address in the parameter list has its high bit set to one. This occurs
even if the last parameter has been marked with an asterisk.

You have many choices as to where the parameter list itself gets built.
As you have already seen, you can use the PL= keyword to specify a tag
and a number of parameters for the parameter list. This number should
represent the size of the storage available for the parameter list. The
number is necessary because the PLIST macro verifies that there is
enough room to hold the parameter list. This prevents PLIST from running
over the parameter list storage into other data fields. If the tag has a
self-defining length attribute, the number field can be omitted.
However, because of the way the assembler interprets lengths, you need
to be careful. To illustrate this:

*Example 10.3. Parameter List Lengths*

PARMS1  DS  3F
PARMS2  DS  XL(3*4)


Both of the definitions above reserve enough space for a parameter list
at least three items long. However, the assembler views the first tag as
having a length of 4 since it is just a series of fullwords. Therefore,
PLIST will assume that this storage location can hold a parameter list
of only one item. The second example actually has a length of 12, which
is what PLIST requires if you try to build a parameter list of three
items here.


    Automatic Parameter Lists

If your program has a PWA, you can have storage for your generated
parameter lists automatically allocated within the PWA. Any parameter
lists that do not include a PL= keyword in their definitions are placed
in a special parameter list area in the PWA. This area is only big
enough to contain the single largest parameter list in the program and
is reused when a new parameter list is needed. For this reason, it is
most useful for parameter lists that are created, immediately used, and
then discarded.

A separate parameter list area is also created for any internal
subroutines that generate parameter lists themselves. This is because a
subroutine that generates a parameter list might have been called with
one and that one must remain even though the subroutine is generating
new ones. The subroutine parameter list area is created within the SWA
for the subroutine.

If your program does not have a PWA, you can achieve the same effect
with the PL= keyword on the block macro. This keyword is identical to
the PL= keyword on the PLIST, CALLSUB, and CALLX macros and defines a
default parameter list area for any parameter lists within that
enclosing block. This keyword can be used on any type block to create a
unique parameter list area for each program section.


    Permanent Parameter Lists

There are still cases where you would want to code PL= for a parameter
list. If your program requires that a subroutine will be called many
times with the same parameter list, it would help to be able to create
it just once, then refer to it as often as necessary. Also, it may be
desirable to create a parameter list and then modify it conditionally
before its use. In either of these cases, you can use PLIST with the PL=
keyword to create the list in its own unique location. This prevents the
list from being overwritten by the next parameter list. These lists can
be viewed as permanent since they remain until specifically written
over, while the automatic parameter lists only remain until the storage
is needed for the next list.

If a permanent parameter list is needed, you can code a PLIST macro with
the PL= keyword and define storage for the parameter list, most likely
in the PWA or SWA. However, this requires more upkeep than the other
types of parameter lists. You must make sure that enough storage has
been reserved to contain all the parameters in the list and if the
number of parameters is changed later, the storage definition must be
changed.

It would be nice if there was a way to get the Structured Macros to
generate the DS commands for you. That way, if the size of the parameter
list changed, the storage area would change with it. This would give the
advantages of the temporary lists while still allowing you to keep the
list around and refer to it by name for subroutine calls or
modifications to the list. There is such a mechanism in the macros. It
is done with the DS= keyword on the PLIST macro. With the DS= keyword,
you can instruct the macros to set aside storage for a particular
parameter list in the PWA or in an SWA (of course you can only specify
SWA if the parameter list is being built in a subroutine that has one.)

*Example 10.4. Using the DS Keyword*

  PLIST  (DATA1,DATA2,DATA3),PL=PARM1,DS=PWA

  PLIST  (DATA4,DATA5),PL=(PARM2,3),DS=SWA


When the DS= keyword is used, the PLIST macro counts the parameters in
the list and sets aside just enough storage for them with a label
supplied by the PL= keyword. You can also force the macro to allocate a
specific amount of space by including a number in the PL= keyword. After
a parameter list is created using the DS= keyword, it can be referred to
with just a PL=tag. One caution on using this keyword: Since the PLIST
macro actually defines the parameter list storage within a partial PWA,
the DS= keyword should appear on the first reference to the parameter
list that the assembler sees and no others. All other references to the
parameter list should just use PL= to specify the tag for that list.


    Calling Subroutines

Two macros are provided for calling subroutines. CALLSUB is used to call
an internal subroutine that is included as part of the assembly of the
main program. CALLX is used to call external routines that have been
linked with the main program or that are dynamically loaded. These
external routines may be other programs, or they can be IBM or vendor
supplied service routines.

The CALLSUB macro generates a BAL instruction (or BAS if the XA option
is being used) to jump to a subroutine that the program has direct
addressability to. The return address is in register 14. Otherwise, all
registers have the same value upon entry to the subroutine that they had
in the main program. CALLSUB also provides the necessary linkage for
Dynamic Storage Management if DYN is being used, and for subroutines
that use LOADBASE. In either of these cases, the contents of register 15
are also destroyed by the CALLSUB macro.

The CALLX macro is for external subroutines and generates a BALR
instruction (or BASR) with the return address in register 14 and the
subroutine address in register 15. This is the standard format for
external subroutines. Registers 14 and 15 are the only ones destroyed by
the CALLX macro. All others have the same value in the subroutine that
they had in the calling program.

CALLX also differs from CALLSUB in the way that the subroutine address
is specified. Since CALLSUB is used for internal subroutines, the name
of the subroutine is specified on the CALLSUB macro. To call an external
subroutine with CALLX, you specify the address in a register or give the
CALLX macro the address of a location that contains a pointer to the
external routine.


    Parameter Lists on CALLSUB and CALLX

If you are going to build a parameter list and then immediately issue a
CALLSUB or CALLX macro, you can combine these functions in a single
macro. The CALLSUB and CALLX macros can generate parameter lists just as
PLIST does, so you can have these macros build your parameter list for you.

*Example 10.5. Combining Parameter Lists with Subroutine Calls*

  CALLSUB SUBONE,(DATA1,*DATA2,100),PL=(PARMS1,3),NOVL

  CALLX   (R15),(DATA3,'ERROR')


This method of calling subroutines is very simple. However, it should be
noted that the parameter list is recreated every time the subroutine is
called. If you are going to make repeated calls to a subroutine with the
same parameter list, it would be better to create the parameter list
once and simply load the address of it before the subroutine call. This
can be done like this:

*Example 10.6. Creating the Parameter List Once*

  CALLX   (R15),PL=PARMSTOR



    Recommendations

To help you better understand the types of parameter lists and calls,
here are some general conventions to remember when using the Structured
Macros for parameter lists. These rules are not enforced by the macros,
but are good programming practice. When reading these rules, remember
the distinction between permanent lists that use the PL= keyword to
point to a specific location and automatic lists that are defined in
default parameter list storage.

  *

    If the PARMS keyword was used to describe the input parameter list,
    you will generally want a parameter option of either COPY or USING,
    but not both.

  *

    Since it frees a register that otherwise would be used to map the
    parameter list, COPY will probably be the most common option.

  *

    If the PARMMAP keyword was used to describe the input parameter
    list, you will generally want the USING parameter option. The COPY
    option may be specified if you want the functions it provides.

  *

    When using CALLSUB and CALLX, the PL= keyword is only really
    necessary when referring to a permanent list created by a previous
    PLIST macro.

  *

    The PLIST macro is only needed for creating and modifying permanent
    parameter lists or when the call must be done without CALLSUB or
    CALLX (With LINK for example).

  *

    Permanent parameter lists should only be created with PLIST.

  *

    The * notation for modifying parameters should only be used in
    permanent parameter lists.

  *

    Temporary parameter lists should only be created with CALLSUB or
    CALLX (Except when forced to use PLIST because the call cannot be
    made with CALLSUB or CALLX).


    Example Source

Here is an example to show you some of the various ways parameter lists
can be used.

*Example 10.7. Parameter List Example*

 BLOCK   TYPE=PROGRAM,NAME=PROG1,OPTIONS=(*PWA)
*  Call external routine and pass a parameter list
  LOAD   EP=PROG2
  CALLX  (R0),(MYDATA,'OPEN',),NOVL
 ENDBLK  BLOCK=PROG1

*  And under a separate assembly, you have
 BLOCK   TYPE=PROGRAM,NAME=PROG2,PARMS=(DATA,FUNCTION,OPT)             +
               OPTIONS=(*PWA,(PARMS,COPY,NOVL))
*  Copy actual parameter data to working storage
  L      R1,DATA               Get address of 1st parameter
  MVC    DATA1,0(R1)           Save data away
*  Create a permanent list for later use.  Note that FUNCTION contains
*  the address of the parameter we want to pass.
  PLIST  (DATA1,*FUNCTION,53),PL=PARM1,DS=PWA
*  Call subroutine using temporary list
  CALLSUB SUBONE,(DATA3,,'INIT')
*  Modify permanent list
  PLIST  (*,DATA5,*),PL=PARM1
*  Call subroutine using previous list
  CALLX  =V(EXTRSUB),PL=PARM1
 ENDBLK  BLOCK=PROG2

 BLOCK   TYPE=SUBROUTINE,NAME=SUBONE,PARMMAP=(SUBPARM,SUBPARML),       +
               OPTIONS=(*SWA,(PARMS,(USING,R9),VL))
*  Call subroutine using temporary list
*  This list will be created in SWA
  CALLX  (R15),(155,'NAME',=X'FF')
*  Create a permanent list within SWA
  PLIST  (DATA4,DATA5),PL=SWAPARM,DS=SWA
 ENDBLK  BLOCK=SUBONE
         SUBPARM DSECT=YES            Generate Dsect for input parms.
SUBPARML EQU   *-SUBPARM



    Chapter 11. Location and Scope of Data Structures

*Table of Contents*

Local Scope within Subroutines <#id486795>

Since the Structured Macros handle all of the implementation details of
PWAs, PSDs, SWAs, etc., a programmer should not have to reference any of
these data areas directly. However, on the rare occasions that it is
necessary, symbols are defined by the Structured Macros that contain
unique tags located at the beginning of these structures. These symbols
are listed below:

  *

    *&PWA: *Program Work Area

  *

    *&PSD: *Program Static Data

  *

    *&PPL: *Program Parameter List

  *

    *&SWA: *Subroutine Work Area

  *

    *&SSD: *Subroutine Static Data

  *

    *&SPL: *Subroutine Parameter List

To have these symbols available to your program, include an assembler
COPY statement at the beginning of your program for the member SMSYMS.
This is necessary because of the Assembler H requirement that all global
symbols be declared in open code and not from within macros.

These symbols can be used by any programs that needs to calculate
offsets within any of these structures. However, these symbols have a
much better use when used within subroutines.


    Local Scope within Subroutines

One of the nicer concepts of high-level languages is local scope within
subroutines. This isolates the working storage of the subroutine from
the main program, and helps to prevent the subroutine from affecting the
program's storage in unforseen ways. To some extent, Subroutine Work
Area accomplish this goal for assembler programs. By giving each
subroutine its own work area instead having to share work areas within
the PWA, the chance that two subroutines will overlay each other's
storage is greatly reduced.

Another very nice feature of local scope becomes evident when it comes
time to think up names for variables and work areas. In a language with
local scoping, you can name variables within a subroutine without any
regard for what the variables in other subroutines have been named. This
also makes it easier to copy a subroutine from one program to another,
since the new program does not have to be checked for variable name
conflicts.

Unfortunately, 370 assembler requires that every tag be unique and does
not allow for local scoping of names. However, the subroutine data area
symbols described above can be used to accomplish the same effect. They
contain the name of a tag at the beginning of a data area, but this can
also be thought of as a unique id that can be prefixed to tag names to
distinguish them from identically named tags in other subroutines. To
facilitate this use of the symbols, abbreviated versions of them were
created. The short versions are as follows:

   &SWA = &W
   &SSD = &S
   &SPL = &P


With these tags, you can write a subroutine like the following. Note the
use of the PREFIX parameter option to force the use of the &P. symbol in
the SPL.

*Example 11.1. Using Tags*

       .
       .
       .
  COPY    SMSYMS
       .
       .
       .
 EDITDATA    TITLE 'SUBROUTINE TO EDIT PASSED FULLWORD'
 *---------------------------------------------------------------------*
 *  SUBROUTINE  EDITDATA
 *
 *  ABSTRACT    THIS SUBROUTINE TAKES THE FULLWORD PASSED IN THE
 *              FIRST PARAMETER PASSED TO IT, EDIT IT INTO A WORK AREA,
 *              AND COPY THE RESULTS INTO THE AREA POINTED TO BY THE
 *              SECOND PARAMETER.
 *---------------------------------------------------------------------*
          SPACE 3
  BLOCK   NAME=EDITDATA,TYPE=SUBROUTINE,                               +
                OPTIONS=(*SWA,(PARMS,(USING,R9),PREFIX)),              +
                PARMS=(DATAPTR,RESULT)
   L      R1,&P.DATAPTR                | GET ADDR OF FULL WORD.
   L      R2,0(,R1)                    | LOAD FULL WORD TO CONVERT.
   CVD    R2,&W.DOUBL                  | CONVERT TO DECIMAL.
   MVC    &W.MASK,&S.MASK              | COPY EDIT MASK TO WORK AREA.
   EDIT   &W.MASK,&W.DOUBL             | EDIT DECIMAL NUMBER TO EBCDIC.
   L      R1,&P.RESULT                 | GET PTR TO RESULT STORAGE.
   MVC    0(11,R1),&W.MASK             | COPY RESULT.
  ENDBLK  BLOCK=EDITDATA
          SSD
 &S.MASK  DC    CL'4020202020202020202120'
          ENDSSD
          SWA
 &W.MASK  DC    CL'4020202020202020202120'
 &W.DOUBL DS    D
          ENDSWA


Although this may seem strange at first, most programmers find that the
advantages outweigh any inconveniences.


    Chapter 12. Miscellaneous Macros

*Table of Contents*

Bit Manipulation <#id487260>
Testing A Register <#id486653>
Initializing Storage <#id486674>
Register Loading <#id486708>
Executing Instructions <#id487418>
Loading Control Block Addresses <#id487517>
Controlling Structured Macro Operation <#id487616>

There are several macros packaged with the Structured Macros that, while
they are not true structured programming aids, perform commonly used
functions and relieve some coding effort.


    Bit Manipulation

There are macros provided that perform the 4 most common functions
performed on a bit: setting (OI), resetting (NI), inverting (XI), and
testing (TM). The macros that perform these tasks are /SBIT/, /RBIT/,
/IBIT/, and /TBIT/respectively. Each macro uses the appropriate
immediate instruction to operate on a single byte; however, multiple
bits within the target byte can be changed at once.

*Example 12.1. Setting Multiple Bits at Once*

  SBIT  FLAGBYTE,(BIT1,BIT2,BIT3)


Generates:

+          OI    FLAGBYTE,BIT1+BIT2+BIT3


There is also an optional naming convention. If the address of the
target byte is not provided, the macros assume that the target bit's tag
is the first 5 characters of the flag name.

*Example 12.2. Default Target Bit Name*

 IBIT  PWAF1OK


Assumes the flag was named PWAF1 and generates:

+         XI    PWAF1,PWAF1OK


The TBIT macro is valid as a ôcompareö instruction, allowing the use of
TBIT in conditional expressions on IF, LEAVE, LOOP and ERREXIT.


    Testing A Register

The TREG macro can be used in place of the LTR instruction. TREG always
issues a LTR that loads the target register from itself, thus setting
the condition code without modifying any registers. TREG is valid in a
conditional expressions.


    Initializing Storage

The FILL macro can be used to set areas of storage to a byte value, such
as spaces or low-values. There are three types of FILL which can be
done: short, the default, for 1 to 256 bytes; medium, for up to 4095
bytes, and long, for up to 16 megabytes. Medium FILL can use any length
constant that the LA instruction can handle, while a long FILL must have
its length in a register. Otherwise, medium and long FILL are identical.
A short FILL does not destroy any registers, as it uses MVI and MVC to
propagate its fill character, but medium and long FILL both use MVCL,
and destroys the contents of R14, R15, R0 and R1.


    Register Loading

Often it is necessary to load one, two, three, or four bytes of data
into a register from storage. The L8, L16, L24, and L32 macros allow
this to be easily accomplished.

*Example 12.3. Loading Multiple Bytes into a Register*

  L16   R4,DATA1


This loads the low-order two bytes of register four with the two bytes
at location DATA1 and clears the high-order two bytes of register four.
These macros clear the specified register, and issue an appropriate ICM
to load the required data.


      Important

Since all of these macros except L32 clear the register before doing the
ICM, they should never be used to load a register that is referred to in
the address being loaded from.

*Example 12.4. Register Loading Clearing the Register*

  L16   R2,10(R2)


Generates:

+         SLR   R2,R2                     CLEAR REGISTER
+         ICM   R2,B'0011',10(R2)         LOAD 16 BITS


In this example, register two is cleared to zero, then is loaded with
the two bytes at the location pointed to by ten off of the contents of
register two. But since register two has been zeroed, this loads from
/absolute location ten/. This type of problem can be very difficult to
debug because without looking at the macro expansion, it is difficult to
understand exactly what is going on.


    Executing Instructions

The EX instruction is a very powerful tool in System/370 assembly
language. There are many cases where it is the simplest method to
operate on a variable amount of data. However, there are problems with
using the EX instruction. Most of these stem from the placement of the
instruction to be EXecuted. The instruction can be placed inline, right
next to the EX instruction with a branch around it. This is convenient,
but wasteful because it requires unnecessary branch instructions. The
instruction can be placed with the static data, but this causes more
problems. First, the EX instruction is removed in the source from the
instruction being EXecuted, making the program harder to read. Second,
the USING environment of the EXecuted instruction can be completely
different from that of the EX instruction, making the coding of
meaningful labels difficult or impossible.

Perhaps the best solution is to use the LOCTR assembler instruction.
This instruction establishes a new location counter for whatever data
follows. Any data or instruction defined with a new location counter
will be collected and placed at the end of the load module. This way,
the EXecuted instruction can be defined inline with the current USING
environment, but will be placed at the end of the load module where no
branch is needed to skip over it.

However, all of these methods have one problem in common when used with
the Structured Macros. They all require you to code tags in the body of
the program. Since the Structured Macros eliminate the need for tags in
the rest of the program, this can upset the indentation scheme and make
the program look messy and difficult to read.

A solution to all of these problems is to provide a macro to generate
the EX instruction and its object, and to generate the tags
automatically. This way, the source can still be coded without the use
of any tags. The EXI macro is included with the Structured Macros to
provide this function. It can accept any register for the EX
instruction, and allows the user to specify any opcode and one to three
operands.

*Example 12.5. Execute Instruction Using the EXI Macro*

  EXI   R3,(MVC,DEST(0),0(R10))


This generates a MVC instruction with the operands specified and an EX
instruction using register 3 and the MVC.

If the LOCTR option was specified on the program block, the EXI macro
puts the EXecuted instruction in the PSD (or the SSD if it is within a
subroutine). If NOLOCTR was specified, EXI generates the instruction
inline with a branch around it.


    Loading Control Block Addresses

There are certain system control blocks that programmers find themselves
accessing often. The LCBA macro is provided to give you a standard way
of finding these control blocks. The LCBA macro locates the address of
the specified control block and places it in the specified register. The
mapping macros for any control blocks LCBA uses to find the desired
control block are not required. The LCBA macro can be used to load the
address of the following:

  *

    current ACEE

  *

    current ASCB

  *

    current ASXB

  *

    CVT

  *

    current TCB

  *

    UJT (Clemson dependent)

  *

    UVT (Clemson dependent)

*Example 12.6. Loading the Control Bloack Address with LCBA*

  LCBA   R8,ACEE
  IF     (Z)
    -- ACEE not found code --
  ENDIF
  USING  ACEE,R8
    -- Now have ACEE --



    Controlling Structured Macro Operation

There are times when a decision must be made in the middle of a program
that needs to affect the operation of the Structured Macros at a later
time. To provide for this capability, the SMCTRL macro was created to
set flags that are checked by other macros.

One example of this use is the reusable PWA support. You use SMCTRL to
inform the macros that the PWA should be freed when the current
invocation of the program is terminated.


    Chapter 13. Miscellaneous Examples

*Table of Contents*

A Search Loop <#id486567>
Scanning Text <#id486365>
A DCB EODAD Exit <#id488214>
Returning R0 and R1 with ENDBLK <#id488268>

This section provides some examples for pieces of code that programmers
find themselves writing often.


    A Search Loop

While search routines can be as different as the data structures they
are accessing, they are usually similar in their general structure. This
is an example of a sequential search routine that looks through a RACF
access list.

*Example 13.1. Search Loop Example*

  BLOCK NAME=SEARCH
*
*   Set up list pointer and count for search.
*
   LA   R2,ACL
   LH   R3,ACLCNT
*
*   Now loop through the access list (ACLCNT) times.
*
   LOOP BCT
    IF  (CLC,USERID(8),EQ,0(R2)),THEN
*
*   If compare succeeds, do success code and leave.
*
          :
     -- success code --
          :
     LEAVE BLOCK=SEARCH
    ENDIF
*
*  Point to next entry, try again.
*
    LA  R2,ACLLEN(,R2)
   ENDLOOP BCT,R3
*
*  Entire ACL searched without a hit, do fail code.
*
          :
    -- fail code --
          :
  ENDBLK BLOCK=SEARCH
          :



    Scanning Text

This routine (lifted from the nesting level pre-processor) uses a BXLE
and a BXH loop to scan a line of assembler source for its opcode.

*Example 13.2. Text Scanning Example*

*
*   Set up for BXLE loop:
*     R1 points to start of source code line
*     R14 contains increment for R1
*     R15 contains A(end of line) as limit for R1
*
  LA   R1,LINE                        R1 -> start of line
  LA   R14,1                          Set increment to 1
  LA   R15,LINE+L'LINE                R15 -> end of line

  LOOP  BXLE                          Skip past any tags in col. 1
   LEAVE LOOP=*,(CLI,0(R1),EQ,X'40')
  ENDLOOP BXLE,R1,R14

*
*   Now use remaining value in R1 as start for BXH loop.
*
  LOOP  BXH,R1,R14                    Now scan for opcode

   IF   (CLI,0(R1),NE,X'40')

    IF  (CLC,0(6,R1),EQ,=C'BLOCK ')     If 'BLOCK'
     IC R0,=C'B'                        Set type to 'B'
     CALLSUB NEST!Call NEST

    ELSEIF (CLC,0(7,R1),EQ,=C'ENDBLK ') Elseif 'ENDBLK'
     IC R0,=C'B'                         Set type to 'B'
     CALLSUB UNNEST                      Call UNNEST

    ELSEIF                              ( etc. )
       :
    ENDIF

*
*   If outer IF succeeded, line is processed, so leave.
*
    LEAVE  LOOP=*
   ENDIF

  ENDLOOP BXH                         End of search loop.



    A DCB EODAD Exit

One way to use a DCB EODAD exit (or SYNAD, EOV and other DCB exits) is
to fake out the macros by coding a tag at the place your end-of-file
code started and specifying EODAD=tag in the DCB. This, however, becomes
dangerous when running mixed-AMODE programs because the EODAD routine
must be the same AMODE as the routine where the GET is issued. To avoid
this, you can take advantage of the fact that R14 points to the
instruction following the GET or READ macro whenever a DCB exit is
called by using an implied CALLSUB, as follows:

*Example 13.3. EODAD Example*

  OPEN  DCB,INPUT

  LOOP  UNTIL              Do 'endless' loop

*
*  PWAF1EOF gets set if end-of-file was found.
*
   GET      DCB,RECORD
   LEAVE    LOOP=*,(TBIT,PWAF1EOF,ON)
   CALLSUB  EATREC

  ENDLOOP   UNTIL,LEAVE

  CLOSE DCB
         :
         :

  BLOCK NAME=EOF,TYPE=SUBROUTINE,OPTIONS=*NOSUBOPTS

   SBIT  PWAF1EOF
  ENDBLK BLOCK=EOF
         :
         :
PWAF1    DC    X'00'
PWAF1EOF EQU   X'80'
  :
DCB      DCB   EODAD=EOF,  ...


If this sample were bimodal, subroutine EOF would have to be the same
AMODE as the code that issues the GET macro.


    Returning R0 and R1 with ENDBLK

There are many programming situations where it is desirable to return
values or pointers to a calling program using registers zero and one.
Common examples are sort exits, lookup routines and user SVC's.

The Structured Macros provide a method for passing back R0 and/or R1
from a program block. You can use the RTNR0 and/or RTNR1 options on the
program block macro and specify the R0= and/or R1= keyword on the ENDBLK
for the program and all error exits.

*Example 13.4. Returning R0 and R1 Example*

 BLOCK NAME=TEST,TYPE=PROGRAM,OPTIONS=*PWA,RTNR0,RTNR1
       :
       :
 ENDBLK BLOCK=TEST,RC=0,R0=8,R1=PARMLIST
       :
 BLOCK NAME=ERR1,TYPE=ERREXIT
       :
 ENDBLK BLOCK=TEST,RC=8,R0=0,R1=0



If you are using an internal subroutine that has an SWA and would like
to have the subroutine return a register to its caller, you can use the
STRSA macro.


    Chapter 14. Structured Macros Listing Program

*Table of Contents*

Output of the Listing Program <#id487698>
Controlling Listing Program Operation <#id488666>

To aid the programmer, a listing program was written that will analyze
the nesting structure of a program and report on any problems. It also
provides a listing of the original program without the macro expansions
that tend to blur the structured nature of the program. After they have
gotten used to it, many programmers use this listing for most of their
work, and only refer to the assembler listing occasionally. JCL
procedures have been provided that run this listing program and then
feed the assembler source into the Level H Assembler. For more
information, see Appendix A, <##asmproc>/Catalogued ASM Procedures At
Clemson/ <##asmproc>.


    Output of the Listing Program

Below is an example of the output of the listing program. It displays
the original input source, along with the current nesting level depth,
and a diagram of the nesting type (Block, Loop, or If).

*Example 14.1. Listing Program Output*

LVL NESTING    SOURCE STATEMENT              MSC0150$ V1R4  15:43 89.117

001  B    | BLOCK NAME=TEST,TYPE=PROGRAM,OPTIONS=(*PWA) |
001  B    |*                                            |
002  BL   |  LOOP   WHILE,(CR,R4,LT,R5)                 |
003  BLI  |   IF    (C,R3,GE,XYZ)                       |
003  BLI  |    MVC  ABC,XYZ                             |
002  BL   |   ENDIF                                     |
001  B    |  ENDLOOP WHILE                              |
001  B    |  CALLSUB SUB1                               |
001  B    |*                                            |
000       | ENDBLK BLOCK=TEST                           |
000       |*                                            |
001  B    | BLOCK   NAME=SUB1,TYPE=SUBROUTINE           |
001  B    |  LR     R1,R2                               |
000       | ENDBLK  BLOCK=SUB1                          |
000       |*                                            |
000       |         PSD                                 |
000       |         LTORG                               |
000       |XYZ      DC    F'9'                          |
000       |ABC      DC    F'4'                          |
000       |         ENDPSD                              |
000       |*                                            |
000       |         PWA                                 |
000       |PWAFLAG  DS    18F                           |
000       |         ENDPWA                              |
000       |*                                            |
000       |         END                                 |


The Structured Macros Listing Program also points out any irregularities
in the nesting structure of the program. Below is the listing produced
by feeding an incorrect program into it.

*Example 14.2. Listing Program Output for Defective Program*

        LVL NESTING    SOURCE STATEMENT              MSC0150$ V1R4  15:43 89.117

001  B    | BLOCK NAME=TEST,TYPE=PROGRAM,OPTIONS=(*PWA) |
001  B    |*                                            |
002  BI   |  IF     (C,R3,GE,XYZ)                       |
002  BI   |*                                            |
002  BI   | ENDBLK BLOCK=TEST                           |>E-8 NESTING PROBLEM
002  BI   |*                                            |
002  BI   |         END                                 |

>E-8 ENDING STRUCTURAL LEVEL IS NON-ZERO



    Controlling Listing Program Operation

The SMLIST macro has been provided to control the operation of the
Structured Macros Listing Program. Parameters on this macro are
processed by the listing program itself, before the source statements
are sent to the assembler.

Currently, the only parameter available is CONVERT=YES/NO. CONVERT=YES
instructs the listing program to convert the input source to all
uppercase before feeding it to the assembler. This allows you to write
programs in upper and lower case. Many people find mixed case programs
and comments easier to read, and this parameter makes that easy to do.

Although the assembler requires that its input be in upper case, lower
case letters are allowed in text strings. To prevent the listing program
from converting your mixed case text strings to upper case, place them
in double quotes (") instead of single quotes ('). The listing programs
do not convert the text between double quotes and change the double
quotes back to single quotes before passing the line to the assembler.

With this facility, programmers can write programs like the one below.

*Example 14.3. Mixed Case Input*

 TRYLOWER    TITLE 'Example program for Structured Macros'
             SMLIST CONVERT=YES
 *---------------------------------------------------------------------*
 *  Program     TRYLOWER
 *
 *  Abstract    This illustrates the use of lower case in assembler
 *              source using the SMLIST CONVERT=YES function of the
 *              Structured Macros Listing Program.
 *---------------------------------------------------------------------*
          space 3
  block   name=trylower,type=program,options=(*pwa,xa),amode=any,
                rmode=any,r1save=r9
   l      r15,4(r9)                    | Get output routine address.
   la     r1,psdtext                   | Get pointer to text.
   balr   r14,r15                      | Call output routine.
  endblk  block=trylower
          psd
 psdtext  dc    cl80"This is a test that is true."
          endpsd
          pwa
          endpwa



  Part II. Structured Macro Reference

*Table of Contents*

15. The BLOCK Macro <#id430569>

BLOCK <#id430575> - Structured macro used to start a block.

16. The CALLCASE Macro <#id497725>

CALLCASE <#id497731> - Structured macro used to call a subroutine based
on a case number.

17. The CALLSUB Macro <#id497511>

CALLSUB <#id497517> - Macro used to call an internal subroutine with
linkage provided by the Structured Macros. A parameter list can be
created for the call and its address loaded into register one, or
register one can be loaded with the address of a previously created list.

18. The CALLX Macro <#id499259>

CALLX <#id499265> - Macro used to call an external subroutine with
standard OS linkage. A parameter list can be created for the call and
its address loaded into register one, or register one can be loaded with
the address of a previously created list.

19. The CASE Macro <#id499737>

CASE <#id499743> - Structured macro used to start the code for a
particular case within a case block. This macro must be coded between a
CASEBLK and ENDCASE macro. The CASE macro is always associated with the
innermost CASEBLK.

20. The CASEBLK Macro <#id499729>

CASEBLK <#id499711> - Structured macro used to start a case block. Case
blocks can be nested up to twenty deep.

21. The DEFUCOND Macro <#id500418>

DEFUCOND <#id500425> - Structured macro used to define the name of a
user condition and to identify the macro that processes it. With
DEFUCOND the programmer can add special case conditions to the list of
standard conditions available in conditional expressions. For
information on writing a user condition macro, see User-Defined Conditions.

22. The ELSE Macro <#id498508>

ELSE <#id498514> - Structured macro used to start the else code for an
associated IF or ELSEIF macro. An ELSE macro is always associated with
the innermost IF structure.

23. The ELSEIF Macro <#id500623>

ELSEIF <#id500630> - Structured macro used to start the else code for an
associated IF or ELSEIF macro. An ELSEIF macro is always associated with
the innermost IF structure. An ELSEIF is like an ELSE macro followed by
an IF macro except that the IF nesting level stays the same.

24. The ENDBLK Macro <#id500933>

ENDBLK <#id500939> - Structured macro used to end a block structure.
Refer to the description of the BLOCK macro for more information.

25. The ENDCASE Macro <#id501360>

ENDCASE <#id501366> - Structured macro used to end a case block structure.

26. The ENDIF Macro <#id501300>

ENDIF <#id501306> - Structured macro used to end an IF structure.

27. The ENDLOOP Macro <#id501846>

ENDLOOP <#id501852> - Structured macro used to end a LOOP structure. For
more information, see The LOOP macro.

28. The ENDPSD Macro <#id501603>

ENDPSD <#id501610> - Macro used to define the end of the Program Static
Data (PSD). The ENDPSD macro is used to close either a partial PSD
within the program code, or the last PSD at the end of the program.

29. The ENDPWA Macro <#id500124>

ENDPWA <#id500130> - Macro used to define the end of the Program Work
Area (PWA) or to close a partial PWA. The ENDPWA macro defines the
PWAPLLEN tag to establish the length of the PWA. If the DYN option is
being used, ENDPWA uses the ##ORGS macro to reserve space for the SWAs.
If option NORENT is in effect, a DS instruction is generated to reserve
storage in the CSECT for the PWA.

30. The ENDSSD Macro <#id502472>

ENDSSD <#id502478> - Macro used to define the end of the Subroutine
Static Data (SSD). The ENDSSD macro is used to close either a partial
SSD within the subroutine code, or the last SSD at the end of the
subroutine.

31. The ENDSWA Macro <#id502778>

ENDSWA <#id502785> - Macro used to define the end of the Subroutine Work
Area (SWA). It is also used to end a partial SWA definition. The ENDSWA
macro establishes the length of the SWA for Dynamic Storage
calculations. ENDSWA insures double word alignment for anything that
follows the SWA.

32. The ERREXIT Macro <#id502394>

ERREXIT <#id502621> - Structured macro used to conditionally cause an
errexit block to be executed.

33. The EXI Macro <#id503129>

EXI <#id503135> - This is the EXecute Immediate macro. It is used to
generate an EX instruction and the instruction to be executed. This
allows the EXecuted statement to be defined at the same time the EX
instruction is defined, minimizing confusion. It also insures that the
USING environment is the same as that of the EX instruction. The
EXecuted instruction is generated in the PSD for the program (or SSD for
a subroutine) if the program has selected option LOCTR. Otherwise, it is
generated inline with a branch around it.

34. The FILL Macro <#id503422>

FILL <#id503428> - Macro used to fill an area of storage with a character.

35. The IBIT Macro <#id503730>

IBIT <#id503736> - Macro used to invert bit flags in a byte.

36. The IF Macro <#id504003>

IF <#id504009> - Structured macro used to start an IF structure.

37. The LCBA Macro <#id504561>

LCBA <#id504567> - This macro loads the address of certain control
blocks into a register. No registers are changed except for the register
specified. A zero condition is set if the control block cannot be
located. It is not necessary for the mapping macros for the control
blocks used internally by this macros to be included in the source program.

38. The LEAVE Macro <#id503410>

LEAVE <#id503416> - Structured macro used to leave a structure.

39. The LOOP Macro <##loopm>

LOOP <#id505094> - Structured macro used to start a loop structure. For
LOOP WHILE loops, tests are done at the start of the loop. For LOOP
UNTIL loops, tests are done at the bottom of the loop. If the ENDLOOP
specifies UNTIL,LEAVE, the loop will continue until a LEAVE macro is
used to leave the loop. BCT, BXH, and BXLE loop use the assembler
instruction by the same name. BXH instructions are generated at the top
of the loop and BXLE, and BCT instructions are generated at the bottom
of the loop.

40. The L8, L16, L24, L32 Macros <#id505508>

L8, L16, L24, L32 <#id504978> - Macros used to load a register with one,
two, three, or four bytes of data from non-aligned storage. This macro
clears the register and issues the appropriate ICM to accomplish this.

41. The PLIST Macro <#id505744>

PLIST <#id505750> - Macro used to generate or modify a parameter list.
The parameter list can be created in default parameter list storage or
routed to a specific location. Register one is also loaded with the
address of the completed list.

42. The PSD Macro <#id506149>

PSD <#id506155> - Macro used to define the beginning of the Program
Static Data (PSD). The PSD macro uses LOCTR to locate the static data
after the instructions for the program. The PSD should be defined just
before the PWA for a particular program block if there is one.

43. The PWA Macro <#id506790>

PWA <#id506796> - Macro used to define the beginning of the Program Work
Area (PWA). The PWA macro automatically reserves space for a standard OS
save area, the SMWA, and any parameter lists if it is appropriate for
the current environment. Also, if the DYN option is being used, PWA sets
up the dynamic storage pointers (NAB, EOS-64). The PWA should be defined
as the last thing associated with a particular program block.

44. The RBIT Macro <#id506750>

RBIT <#id506756> - Macro used to reset bit flags in a byte.

45. The SBIT Macro <#id503114>

SBIT <#id503120> - Macro used to set bit flags in a byte.

46. The SMCTRL Macro <#id503099>

SMCTRL <#id503105> - Macro used to set internal flags to affect the
operation of the Structured Macros.

47. The SMLIST Macro <#id507764>

SMLIST <#id507749> - Macro used to set options for the operation of the
Structured Macros Listing Program. This macro is processed by the
listing program and not the assembler.

48. The SMSYMS Macro <#id507932>

SMSYMS <#id507938> - This is not a macro, but is a copy member that must
be included at the beginning of any program that uses the structure
location symbols described in Location and Scope of Data Structures.

49. The SSD Macro <#id507458>

SSD <#id507464> - Macro used to define the beginning of the Subroutine
Static Data (SSD). The SSD macro uses LOCTR to locate the static data.
If the subroutine has selected the LOADBASE option, the static data is
placed immediately after the subroutine code in the object module. If
the subroutine is not using LOADBASE, the subroutine static data is
placed with the program static data. The SSD should be defined just
before the SWA for a particular subroutine block.

50. The STRSA Macro <#id508649>

STRSA <#id507155> - Macro used to store a register's value in the
Subroutine Work Area (SWA) save area. If an internal subroutine contains
an SWA, registers are automatically restored when the subroutine is
exited. If the internal subroutine needs to pass back the value of a
register, it can use this macro to save a register's current value in
the subroutine save area, so that it is not restored to the original
value when the subroutine returns.

51. The SWA Macro <#id508317>

SWA <#id508323> - Macro used to define the beginning of the Subroutine
Work Area (SWA). The SWA macro automatically reserves space for a
subroutine save area, a SMWA, any parameter lists used by the
subroutine, and the Dynamic Storage Management pointers if needed. The
SWA for a subroutine should be defined immediately after the ENDBLK for
that subroutine. The SWA macro insures that any fields specified within
the SWA are aligned properly.

52. The TBIT Macro <#id508184>

TBIT <#id508190> - Macro used to test bit flags in a byte.

53. The TREG Macro <#id508601>

TREG <#id508957> - Macro used to test a register for zero, positive, or
negative.

54. The ##COND Macro <#id508590>

##COND <#id508596> - This is an internal macro for use within other
macros and not in open code. The ##COND macro tests a conditional
expression and branches to the appropriate success or failure tags. This
macro is intended for use in user condition macros. For information
about writing a user condition macro, see User-Defined Conditions.


    Chapter 15. The BLOCK Macro

*Table of Contents*

BLOCK <#id430575> - Structured macro used to start a block.


    Name

BLOCK ù Structured macro used to start a block.


    Syntax

|BLOCK [NAME=name][,TYPE=type][,ENVIRON=environ][,keyword[,keyword,...]] |


    Operands

name
    Name of block. This operand is required for program and subroutine
    blocks.
type
    Type of block. This keyword specifies the type of block. If this
    keyword is not specified, INLINE is assumed.
    The types of blocks are ERREXIT, INLINE, PROGRAM, and SUBROUTINE.
    An ERREXIT block contains code to be executed when an ERREXIT macro
    is executed. This type of block must be coded at block level zero.
    INLINE blocks are used to group a section of code into a logical
    structure.
    SUBROUTINE blocks contain code that is executed when a CALLSUB macro
    specifying its name is executed. A subroutine block must be coded at
    block level zero.
    A PROGRAM block is used to contain the main code body of a program.
    Program blocks can be specified only at block level zero.
environ
    Program environment. This keyword specifies the type of environment
    the program runs in. The currently supported environments are: OS
    for OS linkage, DC for IDMS/DC and PLI for the execution environment
    of the PL/I Optimizing Compiler. This keyword defaults to OS.
keyword
    Indicates linkage and initialization to be done. Using these
    keywords causes the associated ENDBLK to do the reverse linkage. The
    keywords allowed depend on the type of block being defined. (See the
    sections on the individual block types for more information on the
    keywords allowed.)


    Errors

  *

    Too many parameters specified on PL keyword

  *

    INLINE BLOCK must be contained within PROGRAM, SUBROUTINE, or
    ERREXIT BLOCK

  *

    PROGRAM BLOCK must be at block nesting level 1

  *

    PROGRAM BLOCK requires NAME keyword

  *

    SUBROUTINE BLOCK requires NAME keyword

  *

    ENVIRON must be less than 5 alphanumeric characters

  *

    SUBROUTINE BLOCK must follow ENDBLK for PROGRAM BLOCK and be at
    block level zero

  *

    ERREXIT BLOCK must follow ENDBLK for PROGRAM BLOCK and be at block
    level zero

  *

    Maximum nesting level for blocks is 20

  *

    Invalid BLOCK type <type>


    BLOCK TYPE=ERREXIT

The errexit block surrounds code to be performed after a fatal error is
detected. It is invoked by the ERREXIT macro. The ENDBLK macro
associated with an errexit block generates a branch to the ENDBLK code
of the most recent program block, and allows you to specify the return
code with which the program terminates. This return code overrides any
return code that appears on the program block's ENDBLK macro. One
errexit block without a name keyword can be associated with a program
block, in which case, a generated name is used. Therefore, if you have
only one errexit block, the NAME parameter can be left off of the BLOCK
and the ERREXIT macros and a name are automatically generated.


      Keywords

AMODE= 24 | 31 | ANY
    Specifies the addressing mode the block runs in. Amode switching
    code is generated if required. The default is AMODE=ANY, which
    specifies that the errexit runs in the amode in effect when it is
    invoked.
PL= tag|(tag,num)
    Defines the default place to build parameter lists generated within
    this block. Tag defines the label for the start of parameter list
    storage, and num is a self-defining term that represents the maximum
    number of parameter list entries that the storage at tag can hold.
    This must be large enough to contain the largest parameter list in
    the block. If num is not specified, the tag must have a length
    modifier that is a self-defining term.
SAVE= (r1[,r2],address)
    Requests that the register(s) named should be saved and restored.
    The address operand provides the address of a place to save the
    register(s). If more than one register is specified, a STM
    instruction is generated: therefore, specification of something like
    ôR14,R12,addressö is valid. The SAVE keyword can be used on errexit
    blocks to preserve some or all registers without requiring a
    standard OS save area. The SAVE operand is not valid on program
    blocks, and should not be confused with OPTIONS=SAVE.


      Errors

  *

    Refer to Appendix B, <##interr>/Internal Macros Error Messages/
    <##interr>for macros that start with ô##EPö.


    BLOCK TYPE=INLINE

The INLINE block is used to surround a section of code to be treated as
a single unit. With the inline block, AMODE can be changed at the
beginning of the block and restored at the end. Registers can also be
saved and restored. The inline block also allows the user to define a
logical group of code that can be exited with the LEAVE macro.


      Keywords

AMODE= 24 | 31 | ANY
    Specifies the addressing mode the block runs in. Amode switching
    code is generated if required. The default is AMODE=ANY, which
    specifies that the block runs in the amode in effect when it is entered.
PL= tag|(tag,num)
    Defines the default place to build parameter lists generated within
    this block. Tag defines the label for the start of parameter list
    storage, and num is a self-defining term that represents the maximum
    number of parameter list entries that the storage at tag can hold.
    This must be large enough to contain the largest parameter list in
    the block. If num is not specified, the tag must have a length
    modifier that is a self-defining term.
SAVE= (r1[,r2],address)
    Requests that the register(s) named should be saved and restored.
    The address operand provides the address of a place to save the
    register(s). If more than one register is specified, a STM
    instruction is generated: therefore, specification of something like
    ôR14,R12,addressö is valid. The SAVE keyword can be used on inline
    blocks to preserve some or all registers without requiring a
    standard OS save area. The SAVE operand is not valid on program
    blocks, and should not be confused with OPTIONS=SAVE.


      Errors

  *

    Refer to Appendix B, <##interr>/Internal Macros Error Messages/
    <##interr>for macros that start with ô##IPö.


    BLOCK TYPE=PROGRAM,ENVIRON=DC

The IDMS/DC program block, like the OS program block, surrounds the main
body of executable code. Options on the IDMS/DC program block determine
what type of IDMS/DC linkage is to be used, how IDMS/DC macros are to be
expanded, and end-of-task information for application programs (for
example, NEXT TASK CODE), as well as reentrancy, register equating, and
PWA allocation.


      Keywords

OPTIONS= option | (option[,option[,...]])
    *Regular Options: *These are the options for individually
    controlling each of the BLOCK macro's functions. The default value
    for each of these options is the negative form (NOCSECT, NOREGEQU,
    etc.), but note that many of the options are included in all of the
    super options.

CSECT|NOCSECT
    Indicates that a CSECT card is generated with the name of the block.
    If NOCSECT is specified, you must code a USING name,R15 before the
    BLOCK macro if the LOADBASE option is in effect.
ID|NOID
    Specifies that a DC should be generated at the start of the program,
    containing the program block name, assembly date, and assembly time.
    If the CPYRGHT keyword is specified, it is also DC'ed.
LOCTR|NOLOCTR
    Cause the macros to generate LOCTR instructions for the program,
    subroutines, and static data areas to ensure proper placement. This
    option must be selected if the program is using PSDs and SSDs or
    LONG and LOADBASE.
LONG|NOLONG
    Indicates that CALLSUBs generate a BALR (or equivalent) instead of a
    BAL to allow subroutines to establish a base register. This option
    is required if the program has any subroutines that use LOADBASE.
    The LOCTR option is required if this option is specified.
MODE|NOMODE
    Enables generation of AMODE and RMODE cards.
PWA|NOPWA
    Specifies that this program has a PWA. The PWA is acquired using
    #GETSTG and freed using #FREESTG if option RENT is in effect. If the
    NORENT option is in effect, the ENDPWA macro generates a DS
    instruction to reserve storage for the PWA within the CSECT. The PWA
    and ENDPWA macros should be used to define the limits of the PWA.
    This option is required if the program has subroutines that use SWAs.
REGEQU|NOREGEQU
    Specifies that register equates are to be generated.
RENT|NORENT
    Specifies that the program is reentrant and that the macros generate
    reentrant code wherever necessary.
RTNR0|NORTNR0
    Indicates that register zero is passed back to the caller. Use the
    R0= keyword on the ENDBLK macro for the program block and error
    exits to specify the value to be returned. This is only valid with
    OPTIONS=SYSTEM, unless the routine is handling its own delinkage and
    needs a value in R0 from within the program block.
RTNR1|NORTNR1
    Indicates that register one is passed back to the caller. Use the
    R1= keyword on the ENDBLK macro for the program block and error
    exits to specify the value to be returned. This is only valid with
    OPTIONS=SYSTEM, unless the routine is handling its own delinkage and
    needs a value in R1 from within the program block.
VL|NOVL
    Forces all generated parameter lists (PLIST, CALLSUB, CALLX) to
    default to VL unless overridden.
XA|NOXA
    Generates support for linkage using XA instructions. If neither XA
    or 370 is specified, 370 is the default.
370|NO370
    Generates support for linkage using 370 instructions. If OPTIONS=XA
    is also specified, OPTIONS=370 causes generation of code that
    determines whether the program is running under MVS/XA or not, and
    causes branches around XA-dependent instructions generated by the
    Structured Macros such as the amode switches.
DCMACPRT/NODCMACPRT
    Provides support for the #MOPT MACPRNT=ON/OFF operand for those
    IDMS/DC macros that make use of it.
DCPRGPRT/NODCPRGPRT
    Provides support for the #MOPT PRGPRNT=ON/OFF operand for those
    IDMS/DC macros that make use of it.
SYSTEM or (SYSTEM,module#) / NOSYSTEM
    Presence of the SYSTEM keyword causes IDMS/DC system-mode linkage to
    be generated.
#START/NO#START
    Causes a #START macro to be generated by the BLOCK macro. Valid only
    with the SYSTEM option.
#RTN/NO#RTN
    Causes a #RTN macro to be generated by the ENDBLK macro. Valid only
    with the SYSTEM option.
#RETURN/NO#RETURN
    Causes ENDBLK to generate a #RETURN macro. Valid only with NOSYSTEM
    option.
GETSTK
    Causes BLOCK to generate a #GETSTK instead of #GETSTG. Valid only
    with SYSTEM and PWA options.
(NXTTASK,taskcode)
    Specifies the IDMS/DC task code that should be initiated next. Valid
    only with #RETURN option.
(TYPE,returntype)
    Specifies the type of program termination (NORMAL, ABORT, or
    CONTINUE). This option is generally used only with IDMS/DC #STAE
    routines. Valid only with #RETURN option.
(RESINT,interval)
    Specifies the resource timeout interval for this task termination.
    Valid only with #RETURN option.
(RESPGM,pgmname)
    Specifies a resource timeout handler program that is called if the
    resource timeout interval is specified and reached. Valid only with
    #RETURN option.
(EP,entrypoint)
    Specifies an entry point name (other than the CSECT name) to be
    included on the #START macro. If this option is not coded, the entry
    point name is assumed to be ô#STö followed by the internal program
    block number (usually 1). Valid only with SYSTEM and #START options.

    If a type of regular option is specified more than once, the last
    occurrence (ie. PWA or NOPWA) is used.
    *Super Options: *These are provided as combinations of the most
    popular options. If one or more options is not needed, it should be
    specified as desired following the super option's specification.
    *NORENT - selects options CSECT, ID, LOCTR, MODE, REGEQU, VL, and
    #RETURN.
    *NORENTSYS - selects options CSECT, ID, LOCTR, MODE, REGEQU, VL,
    #START, #RTN, and SYSTEM.
    *RENT - selects options CSECT, ID, LOCTR, MODE, REGEQU, RENT, VL,
    and #RETURN.
    *RENTSYS - selects options CSECT, ID, LOCTR, MODE, REGEQU, RENT, VL,
    #START, #RTN, and SYSTEM.
    *PWA - selects options CSECT, ID, LOCTR, MODE, PWA, REGEQU, RENT,
    VL, and #RETURN.
    *PWASYS - selects options CSECT, ID, LOCTR, MODE, PWA, REGEQU, RENT,
    VL, #START, #RTN, and SYSTEM.
AMODE= 24 | 31 | ANY
    Specifies the addressing mode. This keyword causes an AMODE card to
    be generated by the assembler with the specified amode. If this
    keyword is not specified, no AMODE card is generated.
BASEREG= reg | (reg[,reg[,...]])
    Specifies the register or registers to be used for program
    addressability. The register cannot be R0, R1, R14, or R15. BASEREG
    defaults to R13 if the NORENT option is in effect and the SVAREA
    keyword is not specified; otherwise, it defaults to R12.
CPYRGHT= notice
    Specifies a quoted string that is DC'ed if the ID option is in effect.
PL= tag|(tag,num)
    Defines the default place to build parameter lists generated within
    this block. Tag defines the label for the start of parameter list
    storage and num is a self-defining term that represents the maximum
    number of parameter list entries that the storage at tag can hold.
    This must be large enough to contain the largest parameter list in
    the block. If num is not specified, the tag must have a length
    modifier that is a self-defining term.
PWAREG= R11 | (R11,[reg[,...]])
    Specifies the register or registers to be used for PWA addressability.
RMODE= 24 | ANY
    Specifies the residency mode.
R1SAVE= register
    The number of the register that register 1 is copied to. Program
    linkage (notably the use of #GETSTG or #GETSTK) sometimes destroys
    the contents of register 1 from entry. This keyword is useful for
    copying the contents of the parameter register to another register
    before it is destroyed.
SMWA= address
    Provides the address of a Structured Macro Workarea (SMWA). The SMWA
    is a doubleword of storage that is used to preserve addressing mode
    and a work register while performing AMODE switching. The SMWA
    keyword is valid only on a PROGRAM block, and is required when both
    the 370 and XA options are in effect, or when AMODE=ANY is
    specified. The SMWA can reside in the PWA. If the program has a PWA,
    space for the SMWA is automatically allocated in the PWA, and this
    keyword is not necessary.
SUBOPTS= (option,...)
    Can be used to specify a default set of options for all subroutine
    blocks associated with this program. Any options specified on
    subsequent subroutine blocks are in addition to these options. For a
    description of the valid subroutine block options, see the section
    called ôBLOCK TYPE=SUBROUTINEö <##subblk>.


      Errors

  *

    Refer to ##PPDC in Appendix B, <##interr>/Internal Macros Error
    Messages/ <##interr>.


    BLOCK TYPE=PROGRAM,ENVIRON=OS

The program block surrounds the main body of executable code. It can
perform a wide variety of linkage types and initializations, including
standard save area linkage, register equates, automatic allocation of
Program Work Area, and Dynamic Storage Management. If the program block
keywords and options are not used to establish linkage, the BLOCK macro
call should follow linkage code and the associated ENDBLK macro should
be followed by the reverse linkage.


      Keywords

OPTIONS= option | (option[,option[,...]])
    *Regular Options: *These are the options for individually
    controlling each of the BLOCK macro's functions. The default value
    for each of these options is the negative form (NOBR14, NOCSECT,
    etc.) but note that many of the options are included in all of the
    super options.

BR14|NOBR14
    Determines whether a program block's ENDBLK macro generates a BR 14
    instruction. The default is NOBR14, but note that BR14 is included
    in each super option.
CODEBASE|NOCODEBASE
    CODEBASE indicates that the BASEREG= gives addressability to the
    code and static data. NOCODEBASE specifies that BASEREG= only gives
    addressability to the static data. CODEBASE is the default if the
    IBM macro SYSSTATE has not been issued or if SYSSTATE has been
    issued with ARCHLVL=0 specified. Subroutine blocks can also specify
    CODEBASE/NOCODEBASE. They default to the setting for the program block.
CLEARPWA|NOCLEARPWA
    Specifies whether the PWA is cleared to zeros.
CLRDEBUG|NOCLRDEBUG
    Specifies whether the debug area in the ESV is cleared at entry to
    this program block. CLRDEBUG requires the ESV option.
CSECT|NOCSECT
    Indicates that a CSECT card is generated with the name of the block
    along with a USING name,R15. If NOCSECT is specified, you must code
    a USING name,R15 before the BLOCK macro if the LOADBASE option is in
    effect.
DYN|NODYN
    Indicates that Dynamic Storage Management is used. With this option,
    PWA and SWA storage is allocated from the dynamic storage area. When
    the DYN option is on, register 11 is used as a base for SWAs and
    cannot be used by the programmer.
ERRADDR|NOERRADDR
    Indicates that the ERREXIT macro uses a BAS instruction when
    branching to an errexit block. If a code is specified, it is defined
    in the halfword immediately following the BAS instruction. The
    affect of the ERRADDR option is that at entry to an errexit block,
    the CODEREG has the address of the invoking ERREXIT macro. If
    NOERRADDR is specified, a BCC instruction is generated by the
    ERREXIT macro to invoke an errexit block and the CODEREG is loaded
    with the code itself.
(ESV,[parmnum],[esvtag])|NOESV
    Specifies that an Environment Support Vector is present. The macros
    use the ESV to locate routines to do all environment dependent
    services. Parameter /|parmnum|/defaults to 3 and is the number of
    the parameter at input to the program block that contains a pointer
    to the ESV. If the FNCODE option is in effect, this parameter is
    only referenced on the ôstartupö call. Parameter /|esvtag|/defaults
    to PWAAESV and is the tag generated in the PWA for a word into which
    the program block macro stores the address of the ESV. The ESV
    option requires the PWA and RENT options. The NOESV option indicates
    that the macros call OS services directly.
(FNCODE,[parmnum],[startcode])|NOFNCODE
    Specifies that a function code is passed as a parameter to this
    program. Parameter /|parmnum|/defaults to 2 and is the number of the
    parameter at input to the program block that contains a pointer to
    the function code. Parameter /|startcode|/defaults to AL4(1) and is
    the value of the startup function code. This parameter can be any
    form that is valid to the right of a DC instruction. This option is
    ignored if option REUSPWA is not in effect.
ID|NOID
    Specifies that a DC should be generated at the start of the program,
    containing the program block name, assembly date, and assembly time.
    If the CPYRGHT keyword is specified, it is also DC'ed.
LOADBASE|NOLOADBASE
    Specifies that program base registers are loaded. LOADBASE is
    assumed if the BASEREG= keyword is specified.
LOCTR|NOLOCTR
    Cause the macros to generate LOCTR instructions for the program,
    subroutines, and static data areas to insure proper placement. This
    option must be selected if the program is using PSDs and SSDs or
    LONG and LOADBASE.
LONG|NOLONG
    Indicates that CALLSUBs generate a BALR (or equivalent) instead of a
    BAL to allow subroutines to establish a base register. This option
    is required if the program has any subroutines that use LOADBASE.
    The LOCTR option is required if this option is specified.
MAIN|NOMAIN
    Indicates that this is a main program. and dynamic storage is always
    obtained if Dynamic Storage Management is being used. If NOMAIN is
    specified, the storage already allocated by the calling program is
    used if it is sufficient, otherwise extra storage is obtained.
MODE|NOMODE
    Enables generation of AMODE and RMODE cards.
OPTSTOR|NOOPSTOR
    Turns on storage optimization to reduce the size of the load module.
    If your program has a large number of internal subroutines, this can
    save you a significant amount of storage, but slows down subroutine
    calls slightly. This option in only valid for programs with the DYN
    option.
(PARMS[,options...])|NOPARMS
    Indicates that this program has an input parameter list and
    therefore register one should be preserved during program linkage.
    This option is also used to specify options for handling the input
    parameter list. Any parameter option not specified takes on its
    default, ôNOö state. The available parameter options are:

COPY|NOCOPY
    Specifies that the input parameter list is copied to the PWA. An
    area large enough to contain the entire list is reserved and the
    entire parameter list is copied here at the start of the program.
    Any missing parameters (including those left off the end of a VL
    parameter list) contain an address of zero. Use of this option
    requires the PWA option.
(COPYERROR,errexit[,exitcode])|NOCOPYERROR
    Identifies an error exit and optionally an exit code that is invoked
    if the input parameter list overruns the space reserved for it in
    the PWA during a (PARMS,COPY,VL) operation. This suboption is
    required when (PARMS,COPY,VL) is specified. If specified, exitcode
    is passed in the default code register R14 and must follow the same
    restrictions as CODE= on the ERREXIT macro. If errexit is specified
    as a null string, e.g. (COPYERROR,), the unnamed error exit for this
    program block is invoked in case of a copy failure.
(COUNT,tag)|NOCOUNT
    Specifies that a count of the parameters actually specified in the
    input parameter list be made and that the result be placed in the
    fullword at location tag. The use of this option requires the VL
    suboption of PARMS.
PREFIX|NOPREFIX
    Specifies that the tags listed in the PARMS keyword for this block
    are prefixed with the &PPL symbol before placing them within the
    PPL. This gives all the tags within the PPL a unique prefix so there
    are not any collisions with tags within other structures. If this
    option is specified, any references to tags within the PPL from the
    program must be coded as |&PPL.||/tag/|.
(USING,reg)|NOUSING
    Specifies that reg should be used to establish addressibility on the
    input parameter list. The specified register is loaded with the
    contents of register one unless the COPY option is also specified.
    In this case, reg is loaded with the address of the input parameter
    list storage in the PWA.
VL|NOVL
    Specifies that the input parameter list is a variable length (VL)
    parameter list. For VL parameter lists, the COPY option loops
    through the parameters instead of doing a block copy. If the COPY
    option is being used, the high order bit in the last item of the
    copied parameter list is cleared.

PWA|NOPWA
    Specifies that this program has a PWA. The PWA is either GETMAINed
    or obtained from dynamic storage if option RENT is in effect. If the
    NORENT option is in effect, the ENDPWA macro generates a DS
    instruction to reserve storage for the PWA within the CSECT. The PWA
    and ENDPWA macros should be used to define the limits of the PWA.
    This option is required if the program has subroutines that use SWAs.
REGEQU|NOREGEQU
    Specifies that register equates are to be generated.
RENT|NORENT
    Specifies that the program is reentrant and that the macros generate
    reentrant code wherever necessary.
(REUSPWA,[parmnum])|NOREUSPWA
    Specifies that the same PWA storage is used on multiple calls to the
    program block. Parameter /|parmnum|/defaults to 1 and is the number
    of the parameter at input to the program block that contains a
    pointer to the PWA anchor. If the FNCODE option is in effect, the
    PWA is obtained and its address stored in the anchor on the
    ôstartupö call. If NOFNCODE is in effect, the PWA is obtained and
    its address stored when the anchor at entry contains binary zeros.
    The PWA is freed by the ENDBLK macro when the SMCTRL macro with
    FREEPWA=YES specified has been executed. REUSPWA requires the PWA,
    RENT and SAVE options. NOREUSPWA indicates that the PWA should be
    obtained and freed each time the program block is called.
RTNR0|NORTNR0
    Indicates that register zero is passed back to the caller. Use the
    R0= keyword on the ENDBLK macro for the program block and error
    exits to specify the value to be returned.
RTNR1|NORTNR1
    Indicates that register one is passed back to the caller. Use the
    R1= keyword on the ENDBLK macro for the program block and error
    exits to specify the value to be returned.
SAVE|NOSAVE
    Save R14-R12 in the standard save area pointed to by register 13.
SAVEAREA|NOSAVEAREA
    Obtain a save area, do forward and backward linking, and point R13
    to new save area. If NORENT is specified, the save area is obtained
    inline. If RENT is specified, the save area is GETMAINed or obtained
    from the PWA. SAVEAREA is assumed if the PWA option is specified.
VL|NOVL
    Forces all generated parameter lists (PLIST, CALLSUB, CALLX) to
    default to VL unless overridden.
XA|NOXA
    Generates support for linkage using XA instructions. If neither XA
    or 370 is specified, 370 is the default.
370|NO370
    Generates support for linkage using 370 instructions. If OPTIONS=XA
    is also specified, OPTIONS=370 causes generation of code that
    determines whether the program is running under MVS/XA or not, and
    causes branches around XA-dependent instructions generated by the
    Structured Macros such as the amode switches.

    If a type of regular option is specified more than once, the last
    occurrence (ie. PWA or NOPWA) is used.
    *Super options. *These are provided as combinations of the most
    popular options. If one or more options is not needed, it should be
    specified as desired following the super option's specification.
    *NORENT - selects options NOPWA, SAVE, BR14, SAVEAREA, NORENT, ID,
    CSECT, REGEQU, LOADBASE, MODE, VL, NODYN, NOMAIN, NOLONG, LOCTR,
    NORTNR0, NORTNR1, NOREUSPWA, NOFNCODE, NOESV, NOERRADDR, and NOCLRDEBUG.
    *RENT - selects options NOPWA, SAVE, BR14, SAVEAREA, RENT, ID,
    CSECT, REGEQU, LOADBASE, MODE, VL, NODYN, NOMAIN, NOLONG, LOCTR,
    NORTNR0, NORTNR1, NOREUSPWA, NOFNCODE, NOESV, NOERRADDR, and NOCLRDEBUG.
    *PWA - selects options PWA, CLEARPWA, SAVE, BR14, SAVEAREA, RENT,
    ID, CSECT, REGEQU, LOADBASE, MODE, VL, NODYN, NOMAIN, NOLONG, LOCTR,
    NORTNR0, NORTNR1, NOREUSPWA, NOFNCODE, NOESV, NOERRADDR, and NOCLRDEBUG.
    *MAIN - selects options PWA, CLEARPWA, SAVE, BR14, SAVEAREA, RENT,
    ID, CSECT, REGEQU, LOADBASE, MODE, VL, DYN, MAIN, NOLONG, LOCTR,
    NORTNR0, NORTNR1, NOREUSPWA, NOFNCODE, NOESV, NOERRADDR, and NOCLRDEBUG.
    *NOMAIN - selects options PWA, CLEARPWA, SAVE, BR14, SAVEAREA, RENT,
    ID, CSECT, REGEQU, LOADBASE, MODE, VL, DYN, NOMAIN, NOLONG, LOCTR,
    NORTNR0, NORTNR1, NOREUSPWA, NOFNCODE, NOESV, NOERRADDR, and NOCLRDEBUG.
    *SRVPRC - selects options PWA, CLEARPWA, SAVE, BR14, SAVEAREA, RENT,
    ID, CSECT, REGEQU, LOADBASE, MODE, XA, NO370, VL, NODYN, NOMAIN,
    NOLONG, LOCTR, NORTNR0, NORTNR1, (REUSPWA,1), (FNCODE,2,AL4(1)),
    (ESV,3,PWAAESV), ERRADDR, and CLRDEBUG.
AMODE= 24 | 31 | ANY
    Specifies the addressing mode. This keyword causes an AMODE card to
    be generated by the assembler with the specified amode. If this
    keyword is not specified, no AMODE card is generated.
BASEREG= reg | (reg[,reg[,...]])
    Specifies the register or registers to be used for program
    addressability. The register cannot be R0, R1, R14, or R15. BASEREG
    defaults to R13 if the NORENT option is in effect and the SVAREA
    keyword is not specified; otherwise, it defaults to R12.
CPYRGHT= notice
    Specifies a quoted string that is DC'ed if the ID option is in effect.
DYNERR= name
    Specifies the name of the dynamic storage error exit name. If DYNERR
    is not specified and a dynamic storage error occurs, an ABEND 0C1
    occurs.
DYNSIZE= [+|-]size
    Defines the amount of storage to be added to the PWA to be used for
    additional PWAs and SWAs. A ô+ö or ô-ö can be specified to indicate
    that the size is added or subtracted from the size calculated by the
    macros. If this keyword is not specified, the size calculated by the
    macros is used.
PARMMAP=(dsect[,len])
    Defines the Dsect used to map the input parameter list and its
    length. This keyword can be used if the input parameter list is too
    complicated to describe with the PARMS keyword or if the input
    parameter list is a standard form described by an existing Dsect.
    /|len|/is only required if COPY is specified with the PARMS option.
    This keyword is mutually exclusive with the PARMS keyword.
PARMS=(tag[,tag[,...]])
    Defines the tags used to map the input parameter list. These are
    used to generate the Program Parameter List (PPL) Dsect or to map
    the input parameter list storage in the PWA (if parameter option
    COPY was specified). This also defines the size of the input
    parameter list for the COPY option. This keyword is mutually
    exclusive with the PARMMAP keyword.
PL= tag|(tag,num)
    Defines the default place to build parameter lists generated within
    this block. /|Tag|/defines the label for the start of parameter list
    storage and /|num|/is a self-defining term that represents the
    maximum number of parameter list entries that the storage at
    /|tag|/holds. This must be large enough to contain the largest
    parameter list in the block. If num is not specified, the tag must
    have a length modifier that is a self-defining term.
PWAREG= R13 | (R13,[reg[,...]])
    Specifies the register or registers to be used for PWA addressability.
PWASP= number | symbol
    Specifies the number of the subpool in which the PWA is to be
    GETMAINed. PWASP can only be specified on PROGRAM blocks with PWA
    included among the OPTIONS. The default subpool is zero.
RMODE= 24 | ANY
    Specifies the residency mode.
R1SAVE= register
    The number of the register that register 1 is copied to. Program
    linkage sometimes destroys the contents of register 1 from entry.
    This keyword is useful for copying the contents of the parameter
    register to another register before it is destroyed.
SMWA= address
    Provides the address of a Structured Macro Workarea (SMWA). The SMWA
    is a doubleword of storage that is used to preserve addressing mode
    and a work register while performing AMODE switching. The SMWA
    keyword is valid only on a PROGRAM block, and is required when both
    the 370 and XA options are in effect, or when AMODE=ANY is
    specified. The SMWA can reside in the PWA. If the program has a PWA,
    space for the SMWA is automatically allocated in the PWA, and this
    keyword is not necessary.
SUBOPTS= (option,...)
    Can be used to specify a default set of options for all subroutine
    blocks associated with this program. Any options specified on
    subsequent subroutine blocks are in addition to these options. For a
    description of the valid subroutine block options, see the section
    called ôBLOCK TYPE=SUBROUTINEö <##subblk>.
SVAREA= tag
    Can be specified if the NORENT option is in effect and specifies a
    relocatable tag that is used to address the program save area.


      Errors

  *

    Refer to ##PPOS in Appendix B, <##interr>/Internal Macros Error
    Messages/ <##interr>.


    BLOCK TYPE=PROGRAM,ENVIRON=PLI

The program block surrounds the main body of executable code. If
ENVIRON=PLI is specified, options can be specified to do various
initialization and termination functions specific to the OS PL/I
Optimizing Compiler's execution time environment including obtaining and
freeing a DSA, doing register equates and automatically defining a DSA
within the Program Work Area.


      Keywords

OPTIONS= option | (option[,option[,...]])
    *Regular Options: *These are the options for individually
    controlling each of the BLOCK macro's functions. The default value
    for each of these options is the negative form (NOREGEQU, NOCSECT,
    etc.) but note that many of the options are included in all of the
    super options.

CLEARPWA|NOCLEARPWA
    Specifies whether the PWA is cleared to zeros.
ID|NOID
    Specifies that a DC is generated at the start of the program, to
    contain the program block name, assembly date, and assembly time. If
    the CPYRGHT keyword is specified, it is also DC'ed.
LOCTR|NOLOCTR
    Cause the macros to generate LOCTR instructions for the program,
    subroutines, and static data areas to insure proper placement. This
    option must be selected if the program is using PSDs and SSDs or
    LONG and LOADBASE.
LONG|NOLONG
    Indicates that CALLSUBs generate a BALR (or equivalent) instead of a
    BAL to allow subroutines to establish a base register. This option
    is required if the program has any subroutines that use LOADBASE.
    The LOCTR option is required if this option is specified.
MODE|NOMODE
    Enables generation of AMODE and RMODE cards.
PWA
    PWA can not be specified if ENVIRON=PLI is specified, but it is
    implied. ENVIRON=PLI programs have a PWA and can take advantage of
    all of a PWA's features. The PWA is obtained in the same manner as
    and has the same format as a Dynamic Storage Area that is obtained
    by PL/I. The PWA and ENDPWA macros should be used to define the
    limits of the PWA.
REGEQU|NOREGEQU
    Specifies that register equates are generated.
VL|NOVL
    Forces all generated parameter lists (PLIST, CALLSUB, CALLX) to
    default to VL unless overridden.
XA|NOXA
    Generates support for linkage using XA instructions. If neither XA
    or 370 is specified, 370 is the default.
370|NO370
    Generates support for linkage using 370 instructions. If OPTIONS=XA
    is also specified, OPTIONS=370 causes generation of code that
    determines whether the program is running under MVS/XA or not, and
    causes branches around XA-dependent instructions, such as the amode
    switches, generated by the Structured Macros.

    If a type of regular option is specified more than once, the last
    occurrence (ie. REGEQU or NOREGEQU) is used.
    *Super Option: *This is provided as a combination of the most
    popular options. If one or more options is not needed, it should be
    specified as desired following the super option's specification.
    *STDPLI - selects options CLEARPWA, ID, REGEQU, MODE, NOXA, NO370,
    VL, LOCTR, NOLONG.
BASEREG= R11 | (R11[,reg[,...]])
    Specifies the register or registers to be used for program
    addressability. The first register must be R11 and the other
    registers cannot be R0, R1, R12, R14, or R15. BASEREG defaults to R11.
CPYRGHT= notice
    Specifies a quoted string that is DC'ed if the ID option is in effect.
PL= tag|(tag,num)
    Defines the default place to build parameter lists generated within
    this block. If this keyword is not specified, the correct amount of
    storage is automatically reserved and used in the PWA.
    /|Tag|/defines the label for the start of parameter list storage and
    /|num|/is a self-defining term that represents the maximum number of
    parameter list entries that the storage at tag can hold. This must
    be large enough to contain the largest parameter list in the block.
    If num is not specified, the tag must have a length modifier that is
    a self-defining term.
PWAREG= R13 | (R13,[reg[,...]])
    Specifies the register or registers to be used for PWA addressability.
RMODE= 24 | ANY
    Specifies the residency mode.
SUBOPTS= (option,...)
    Can be used to specify a default set of options for all subroutine
    blocks associated with this program. Any options specified on
    subsequent subroutine blocks are in addition to these options. See
    the section called ôBLOCK TYPE=SUBROUTINEö <##subblk> for a
    description of the valid subroutine block options.


      Errors

  *

    Refer to ##PPPLI in Appendix B, <##interr>/Internal Macros Error
    Messages/ <##interr>.


    BLOCK TYPE=SUBROUTINE

The subroutine block contains code that is reached via the CALLSUB
macro. This block must be at block level zero. Subroutine blocks are
meant for internal subroutines, not for a called program that follows
standard OS linkage conventions.


      Keywords

OPTIONS= option | (option[,option[,...]])
    *Regular options. *These are the options for individually
    controlling each of the BLOCK macro's functions. The default value
    for each of these options is the negative form (NOSWA, NOCUSTOM, etc.).

CODEBASE|NOCODEBASE
    CODEBASE indicates that the BASEREG= gives addressability to the
    code and static data. NOCODEBASE specifies that BASEREG= gives
    addressability to only the static data. CODEBASE defaults to the
    setting for the program block.
CUSTOM|NOCUSTOM
    Specifies that the return instructions at the end of the subroutine
    block are not generated. This option should be used if you are going
    to handle all of the linkage details yourself. If this option is
    specified, no other option or keywords on the subroutine block can
    be specified.
LOADBASE|NOLOADBASE
    Indicates that a base register (or registers) should be loaded to
    establish separate addressability to this subroutine. The program
    base register is left intact providing addressability to the
    program's static data.
(PARMS[,options...])|NOPARMS
    Indicates that this subroutine has an input parameter list and
    therefore register one should be preserved during subroutine
    linkage. This option is also used to specify options for handling
    the input parameter list. Any parameter option not specified will
    take on its default, ôNOö state. The available parameter options are:

COPY|NOCOPY
    Specifies that the input parameter list should be copied to the SWA.
    An area large enough to contain the entire list is reserved and the
    entire parameter list is copied here at the start of the subroutine.
    Any missing parameters (including those left off the end of a VL
    parameter list) contain an address of zero. Use of this option
    requires the SWA option.
PREFIX|NOPREFIX
    Specifies that the tags listed in the PARMS keyword for this block
    should be prefixed with the &SPL symbol before placing them within
    the SPL. This gives all the tags within the SPL a unique prefix so
    there are no collisions with tags within other structures. If this
    option is specified, any references to tags within the SPL from the
    subroutine must be coded as &SPL./|tag|/or &P./|tag|/.
(USING,reg)|NOUSING
    Specifies that /|reg|/should be used to establish addressibility on
    the input parameter list. The specified register is loaded with the
    contents of register one unless the COPY option is also specified.
    In this case, /|reg|/is loaded with the address of the input
    parameter list storage in the SWA.
VL|NOVL
    Specifies that the input parameter list is a variable length (VL)
    parameter list. For VL parameter lists, the COPY option loops
    through the parameters instead of doing a block copy. If the COPY
    option is being used, the high order bit in the last item of the
    copied parameter list is cleared.

SAVEUSING|NOSAVEUSING
    Specifies that a PUSH USING be done before the subroutine and a POP
    USING be done after to save and restore the USING environment around
    the subroutine. This isolates any changes made to the USING
    environment in the subroutine from the rest of the program.
SWA|NOSWA
    Specifies that this subroutine has an SWA. The PWA option must be
    specified on the program block options to use this option. The SWA
    is obtained out of dynamic storage if the DYN option is being used,
    otherwise, it is allocated within the program's PWA. R0-R14 are
    automatically saved and restored if this option is specified. This
    option cannot be used with the SAVE= keyword.

    *Super options. *These are provided as combinations of the most
    popular options. If one or more options is not needed, it should be
    specified as desired following the super option's specification.
    *SWA - selects options SWA, SAVEUSING
    *NOSUBOPTS - selects options NOSWA, NOSAVEUSING, NOLOADBASE,
    NOCUSTOM, NOPARMS
AMODE= 24 | 31 | ANY
    Specifies the addressing mode the block runs in. Amode switching
    code is generated if required. The default is AMODE=ANY, which
    specifies that the subroutine runs in the amode of its caller.
    *Restriction. *AMODE 24 or 31 must be specified on a subroutine
    block if it contains inline blocks with AMODE 24 or 31 specified.
BASEREG= reg|(reg,...)
    Defines the base register(s) to be used to establish addressability
    to this subroutine. If this keyword is not specified, register 10 is
    used. The register(s) specified with this keyword are only used when
    LOADBASE is in effect.
PARMMAP=(dsect[,len])
    Defines the Dsect to be used to map the input parameter list and its
    length. This keyword can be used if the input parameter list is too
    complicated to describe with the PARMS keyword or if the input
    parameter list is a standard form described by an existing Dsect.
    /|Len|/is only required if COPY is specified with the PARMS option.
    This keyword is mutually exclusive with the PARMS keyword.
PARMS=(tag[,tag[,...]])
    Defines the tags used to map the input parameter list. These are
    used to generate the Subroutine Parameter List (SPL) Dsect or to map
    the input parameter list storage in the SWA (if parameter option
    COPY was specified). This also defines the size of the input
    parameter list for the COPY option. This keyword is mutually
    exclusive with the PARMMAP keyword.
PL= tag|(tag,num)
    Defines the default place to build parameter lists generated within
    this block. /|Tag|/defines the label for the start of parameter list
    storage and /|num|/is a self-defining term that represents the
    maximum number of parameter list entries that the storage at tag
    holds. This must be large enough to contain the largest parameter
    list in the block. If num is not specified, the tag must have a
    length modifier that is a self-defining term.
RECUR= number
    Specifies the maximum number of times the subroutine can be called
    recursively. This is used in Dynamic Storage Management to calculate
    the amount of space needed for SWAs. /|Number|/must be a
    self-defining term.
SAVE= (r1[,r2],address)
    Requests that the register(s) named be saved and restored. The
    /|address|/operand provides the address of a place to save the
    register(s). If more than one register is specified, a STM
    instruction is generated: therefore, specification of something like
    ôR14,R12,addressö is valid. The SAVE keyword can be used on
    subroutine blocks to preserve some or all registers without
    requiring a standard OS save area. The SAVE operand is not valid on
    program blocks, and should not be confused with OPTIONS=SAVE.
SWAREG= R11|(R11,reg...)
    Specifies the register or registers to be used for SWA
    addressability. The register(s) specified with this keyword are only
    used when DYN is in effect.


      Errors

  *

    Refer to Appendix B, <##interr>/Internal Macros Error Messages/
    <##interr>for macros that start with ô##SPö.


    Chapter 16. The CALLCASE Macro

*Table of Contents*

CALLCASE <#id497731> - Structured macro used to call a subroutine based
on a case number.


    Name

CALLCASE ù Structured macro used to call a subroutine based on a case
number.


    Syntax

|CASEBLK REG=reg,[USESYMBOLS,]case_numbers_and_subroutine_names
[OTHER,othersub|(ERREXIT[,[exitname][,exitcode])]
[,(parms)[,VL|NOVL]][,PL=tag|(tag,num)] |


    Operands

reg
    Specifies the register that contains the case number. An available
    register between R2 and R12 can be used.
case_numbers_and_subroutine_names
    When USESYMBOLS is specified, this is a list of subroutine names
    whose case number is stored in a GBLA symbol by the same name.
    When USESYMBOLS is not specified, this is a list of one or more case
    numbers, followed by the name of the subroutine to call, followed by
    more case numbers, followed by the subroutine name, and so on. If a
    name is specifed without a preceeding number, it is assigned a case
    of one more than the last number assigned. If no number is supplied
    before the first name, it is assigned case 0. A case number can only
    be assigned to one subroutine.
    Case numbers must not be negative. A table is built at the bottom of
    the PSD containing the maximum case number plus one entries. Large
    case numbers should not be used.

*Example 16.1. CALLCASE with USESSYMBOLS*

  CALLCASE REG=R3,USESYMBOLS,
      FI_OPEN,
      FI_TERMINATE,
      FI_READLINE,
      OTHER,(ERREXIT,,16)


*Example 16.2. CALLCASE without USESSYMBOLS*

  CALLCASE REG=R2,
      1,5,2,SUBA,
      4,3,SUBB,
      7,SUBC,SUBD,SUBE,
      OTHER,SUBERR,
      (x,y),VL


othersub
    Specifies the name of the subroutine to call if the case in reg is
    not assigned to a subroutine.
exitname
    Specifies the name of an ERREXIT to call if the case in reg is not
    assigned to a subroutine. If a name is not specified, the unnamed
    ERREXIT is called.
exitcode
    Specifies the value for the CODE= keyword if the ERREXIT is called.
parms
    A list of the parameters to be included in the parameter list that
    the subroutine is called with. A missing parameter causes zero to be
    filled in for the parameter address. An * causes the macro to skip
    over that parameter, reserving the space in the parameter list but
    not modifying the data there. An * before a tag causes the macro to
    load the parameter list with the contents of the storage referenced
    by the tag instead of the address of the tag. This provides a form
    of indirect addressing. Numeric and character constants can be coded
    and are converted to fullword and character literals respectively.
    If/|parms|/is missing, the CALLSUB macro loads register one with the
    address specified by PL=.
VL|NOVL
    VL specifies that this is a variable length parameter list and
    therefore the high bit of the last address in the list be set to
    one. NOVL specifies to not set the bit. NOVL is normally the
    default, but all of the super options establish VL as the default so
    that NOVL might be needed in certain cases.
tag
    Specifies the address of the parameter list to use for the call to
    this subroutine. Register one is loaded with the address of
    /|tag|/before the subroutine is entered. If a parameter list is
    being created for this subroutine, /|tag|/also specifies where to
    build it. If the PL= keyword is not specified, the parameter list is
    created in the default parameter list storage established by an
    enclosing BLOCK macro, or, if no other default was set up, in PWA or
    SWA storage.
num
    Specifies the maximum number of the parameters that the storage at
    /|tag|/can accommodate. If /|tag|/has a length attribute that is a
    self-defining term, this operand is not necessary. This is used to
    insure that the specified parameter list can fit into the storage at
    /|tag|/.


    Errors

  *

    Case number <num>, supplied by <sym> has already been assigned.

  *

    Case number <num> has already been assigned.

  *

    Parameter <num> is empty.

  *

    Expecting a subroutine name or ERREXIT following OTHER

  *

    <parm> is not expected as <num> parameter.

  *

    Negative case number <num> encountered in parameter <num> is not
    allowed.

  *

    <parm> is not valid.

  *

    REG= must be specified.


    Chapter 17. The CALLSUB Macro

*Table of Contents*

CALLSUB <#id497517> - Macro used to call an internal subroutine with
linkage provided by the Structured Macros. A parameter list can be
created for the call and its address loaded into register one, or
register one can be loaded with the address of a previously created list.


    Name

CALLSUB ù Macro used to call an internal subroutine with linkage
provided by the Structured Macros. A parameter list can be created for
the call and its address loaded into register one, or register one can
be loaded with the address of a previously created list.


    Syntax

|CALLSUB name[,(parms)][,VL|NOVL][,PL=tag|(tag,num)] |


    Operands

name
    Specifies the name of the internal subroutine to be called. The call
    is performed with a |BAL R14,||/name/|or equivalent instruction. If
    the program block option LONG has been selected, a |BAL R14,R15|is
    generated, destroying the contents of register 15. The contents of
    register 15 are also destroyed if DYN is used.
parms
    A list of the parameters to be included in the parameter list that
    the subroutine is called with. A missing parameter causes zero to be
    filled in for the parameter address. An * causes the macro to skip
    over that parameter, reserving the space in the parameter list but
    not modifying the data there. An * before a tag causes the macro to
    load the parameter list with the contents of the storage referenced
    by the tag instead of the address of the tag. This provides a form
    of indirect addressing. Numeric and character constants can be coded
    and are converted to fullword and character literals respectively.
    If /|parms|/is missing, the CALLSUB macro loads register one with
    the address specified by PL=.
VL|NOVL
    VL specifies that this is a variable length parameter list and
    therefore the high bit of the last address in the list be set to
    one. NOVL specifies to not set the bit. NOVL is normally the
    default, but all of the super options establish VL as the default so
    that NOVL might be needed in certain cases.
tag
    Specifies the address of the parameter list to used for the call to
    this subroutine. Register one is loaded with the address of
    /|tag|/before the subroutine is entered. If a parameter list is
    being created for this subroutine, /|tag|/also specifies where to
    build it. If the PL= keyword is not specified, the parameter list is
    created in the default parameter list storage established by an
    enclosing BLOCK macro, or, if no other default was set up, in PWA or
    SWA storage.
num
    Specifies the maximum number of the parameters that the storage
    at/|tag|/can accommodate. If/|tag|/has a length attribute that is a
    self-defining term, this operand is not necessary. This is used to
    insure that the specified parameter list can fit into the storage at
    /|tag|/.


    Errors

  *

    Cannot CALLSUB program block or subroutine in previous program block


    Chapter 18. The CALLX Macro

*Table of Contents*

CALLX <#id499265> - Macro used to call an external subroutine with
standard OS linkage. A parameter list can be created for the call and
its address loaded into register one, or register one can be loaded with
the address of a previously created list.


    Name

CALLX ù Macro used to call an external subroutine with standard OS
linkage. A parameter list can be created for the call and its address
loaded into register one, or register one can be loaded with the address
of a previously created list.


    Syntax

|CALLX addr[,(parms)][,VL|NOVL][,PL=tag|(tag,num)] |


    Operands

addr
    Specifies the address of the external subroutine. This address can
    be of the form: |(R15)|=V(name)|tag|If the /|tag|/form is used, tag
    must be the label of the address of the external subroutine. The
    call is performed with a |BALR R14,R15|or equivalent instruction.
parms
    A list of the parameters to be included in the parameter list that
    the subroutine is called with. A missing parameter causes zero to be
    filled in for the parameter address. An * causes the macro to skip
    over that parameter, reserving the space in the parameter list but
    not modifying the data there. An * before a tag causes the macro to
    load the parameter list with the contents of the storage referenced
    by the tag instead of the address of the tag. This provides a form
    of indirect addressing. Numeric and character constants can be coded
    and are converted to fullword and character literals respectively.
    If/|parms|/is missing, the CALLX macro loads register one with the
    address specified by PL=.
VL|NOVL
    VL specifies that this is a variable length parameter list and
    therefore the high bit of the last address in the list be set to
    one. NOVL specifies to not set the bit. NOVL is normally the
    default, but all of the super options establish VL as the default so
    that NOVL might be needed in certain cases.
tag
    Specifies the address of the parameter list to used for the call to
    this subroutine. Register one is loaded with the address of
    /|tag|/before the subroutine is entered. If a parameter list is
    being created for this subroutine, tag also specifies where to build
    it. If the PL= keyword is not specified, the parameter list is
    created in the default parameter list storage established by an
    enclosing BLOCK macro, or, if no other default was set up, in PWA or
    SWA storage.
num
    Specifies the maximum number of parameters that the storage at
    /|tag|/can accommodate. If tag has a length attribute that is a
    self-defining term, this operand is not necessary. This is used to
    insure that the specified parameter list can fit in the storage at tag.


    Errors

  *

    None


    Chapter 19. The CASE Macro

*Table of Contents*

CASE <#id499743> - Structured macro used to start the code for a
particular case within a case block. This macro must be coded between a
CASEBLK and ENDCASE macro. The CASE macro is always associated with the
innermost CASEBLK.


    Name

CASE ù Structured macro used to start the code for a particular case
within a case block. This macro must be coded between a CASEBLK and
ENDCASE macro. The CASE macro is always associated with the innermost
CASEBLK.


    Syntax

|CASE n[,n[,...]]|OTHER[,CASEBLK=name] |


    Operands

n
    Specifies the case number or numbers whose code follows the case
    statement.
OTHER
    Indicates all cases not associated with a particular case. The case
    number cannot be larger than the MULT= value on the associated
    CASEBLK macro times 100.
name
    Name specified on the associated CASEBLK macro.


    Errors

  *

    CASE <casenumber> already used

  *

    No operand was specified on CASE statement

  *

    OTHER has already been specified in this CASEBLK

  *

    CASE is not numeric

  *

    CASE number can not be larger then 'MULT' * 100

  *

    CASE number must be a multiple of 'MULT'

  *

    CASEBLK= does not match CASE name

  *

    CASE macro is not at same structural level as a CASEBLK macro


    Chapter 20. The CASEBLK Macro

*Table of Contents*

CASEBLK <#id499711> - Structured macro used to start a case block. Case
blocks can be nested up to twenty deep.


    Name

CASEBLK ù Structured macro used to start a case block. Case blocks can
be nested up to twenty deep.


    Syntax

|CASEBLK REG=reg[,WREG=wreg][,MULT=1|2|4|8][,NAME=name] |


    Operands

reg
    Specifies the register that contains the case number.
wreg
    Specifies the register that CASEBLK can use internally as a work
    register for address calculations. If WREG= is not specified, the
    REG= is used as a work register. This destroys the contents of REG.
    The work register cannot be register 0.
mult
    This keyword specifies that all the case numbers on the associated
    CASE macros are a multiple of 1, 2, 4, or 8. 1 is the default.
name
    Specifies the name of the case block.


    Errors

  *

    Invalid MULT= specified. Must be 1, 2, 4, or 8.

  *

    CASEBLK cannot be nested more than 20 deep

  *

    REG= must be specified


    Chapter 21. The DEFUCOND Macro

*Table of Contents*

DEFUCOND <#id500425> - Structured macro used to define the name of a
user condition and to identify the macro that processes it. With
DEFUCOND the programmer can add special case conditions to the list of
standard conditions available in conditional expressions. For
information on writing a user condition macro, see User-Defined Conditions.


    Name

DEFUCOND ù Structured macro used to define the name of a user condition
and to identify the macro that processes it. With DEFUCOND the
programmer can add special case conditions to the list of standard
conditions available in conditional expressions. For information on
writing a user condition macro, see the section called ôUser-Defined
Conditionsö <##ucond>.


    Syntax

|DEFUCOND NAME=name,MACRO=macro |


    Operands

name
    Name of the user condition being defined. This name is used in
    conditional expressions to invoke this condition.
macro
    Name of the macro that performs this user-defined conditional test.
    This macro is invoked by the Structured Macros whenever a
    conditional expression is encountered that contains the named condition.


    Errors

  *

    NAME= must be specified

  *

    MACRO= must be specified


    Chapter 22. The ELSE Macro

*Table of Contents*

ELSE <#id498514> - Structured macro used to start the else code for an
associated IF or ELSEIF macro. An ELSE macro is always associated with
the innermost IF structure.


    Name

ELSE ù Structured macro used to start the else code for an associated IF
or ELSEIF macro. An ELSE macro is always associated with the innermost
IF structure.


    Syntax

|ELSE [IF=name] |


    Operands

name
    Name of associated IF macro.


    Errors

  *

    IF nesting level is zero

  *

    ELSE already encountered for this IF

  *

    NAME= does not match corresponding IF

  *

    ELSE structural level is not the same as the corresponding IF


    Chapter 23. The ELSEIF Macro

*Table of Contents*

ELSEIF <#id500630> - Structured macro used to start the else code for an
associated IF or ELSEIF macro. An ELSEIF macro is always associated with
the innermost IF structure. An ELSEIF is like an ELSE macro followed by
an IF macro except that the IF nesting level stays the same.


    Name

ELSEIF ù Structured macro used to start the else code for an associated
IF or ELSEIF macro. An ELSEIF macro is always associated with the
innermost IF structure. An ELSEIF is like an ELSE macro followed by an
IF macro except that the IF nesting level stays the same.


    Syntax

|ELSEIF cond[,THEN][,IF=name] |


    Operands

cond
    Conditional expression. (See Chapter 2, <##condch>/Conditional
    Statements/ <##condch>)
name
    Name on associated IF macro.


    Errors

  *

    ELSEIF must be contained in IF structure

  *

    ELSE for this IF precedes ELSEIF

  *

    IF= does not match corresponding IF

  *

    ELSEIF structural level is not the same as corresponding IF

  *

    For possible condition errors, see Appendix B, <##interr>/Internal
    Macros Error Messages/ <##interr>.


    Chapter 24. The ENDBLK Macro

*Table of Contents*

ENDBLK <#id500939> - Structured macro used to end a block structure.
Refer to the description of the BLOCK macro for more information.


    Name

ENDBLK ù Structured macro used to end a block structure. Refer to the
description of the BLOCK macro for more information.


    Syntax

|ENDBLK [BLOCK=name][,RC=rc][,R0=r0][,R1=r1] |


    Operands

name
    Name on associated BLOCK macro.
rc
    Return code. The return code can be specified as a symbol or (Rn)
    where n is the number of a register. The default for RC is (R15).
    RC= is ignored on the ENDBLK macro of a program block that is using
    the PLI environment.
r0
    Value to be returned in register zero. This keyword requires the
    RTNR0 option to be in effect and is valid only on the ENDBLK for a
    program block and its error exits. This value can be specified as a
    symbol or (Rn) where n is the number of a register. The default for
    R0 is (R0).
r1
    Value to be returned in register one. This keyword requires the
    RTNR1 option to be in effect and is valid only on the ENDBLK for a
    program block and its error exits. This value can be specified as a
    symbol or (Rn) where n is the number of a register. The default for
    R1 is (R1).


    Errors

  *

    <RC> invalid on RC=

  *

    Block nesting level is already zero

  *

    BLOCK= does not match current block

  *

    Structural nesting level does not match level at entry to
    corresponding block

  *

    For macros that start with ##EE, ##IE, ##PE, or ##SE, see Appendix
    B, <##interr>/Internal Macros Error Messages/ <##interr>for other
    possible errors.


    Chapter 25. The ENDCASE Macro

*Table of Contents*

ENDCASE <#id501366> - Structured macro used to end a case block structure.


    Name

ENDCASE ù Structured macro used to end a case block structure.


    Syntax

|ENDCASE [CASEBLK=name] |


    Operands

name
    Name on associated CASEBLK macro.


    Errors

  *

    CASEBLK nesting level is zero

  *

    CASEBLK= does not match CASE name

  *

    Structural nesting level of ENDCASE is different from corresponding
    CASEBLK macro


    Chapter 26. The ENDIF Macro

*Table of Contents*

ENDIF <#id501306> - Structured macro used to end an IF structure.


    Name

ENDIF ù Structured macro used to end an IF structure.


    Syntax

|ENDIF [IF=name] |


    Operands

name
    Name on associated IF macro.


    Errors

  *

    IF nesting level is zero

  *

    IF= does not match corresponding IF

  *

    ENDIF is not at same structural level as corresponding IF


    Chapter 27. The ENDLOOP Macro

*Table of Contents*

ENDLOOP <#id501852> - Structured macro used to end a LOOP structure. For
more information, see The LOOP macro.


    Name

ENDLOOP ù Structured macro used to end a LOOP structure. For more
information, see Chapter 39, <##loopm>/The LOOP Macro/ <##loopm>.


    Syntax

|ENDLOOP [LOOP=name,] WHILE | UNTIL,cond | UNTIL,LEAVE | BCT,reg | BXH |
BXLE,reg,reg |


    Operands

name
    Name on associated LOOP macro.
cond
    Conditional expression. (See Chapter 2, <##condch>/Conditional
    Statements/ <##condch>)
reg
    Register to be used on associated instruction.


    Errors

  *

    Additional positional parameters cannot be specified on ENDLOOP <type>

  *

    Nesting level for loops is 0

  *

    LOOP= does not match corresponding LOOP

  *

    <type> does not match type on corresponding LOOP

  *

    Incorrect number of parameters specified for ENDLOOP <type>

  *

    LOOP type <type> is invalid

  *

    Incorrect number of parameters specified on ENDLOOP UNTIL,LEAVE

  *

    ENDLOOP structural level is not the same as the corresponding LOOP

  *

    For possible condition errors, see Appendix B, <##interr>/Internal
    Macros Error Messages/ <##interr>.


    Chapter 28. The ENDPSD Macro

*Table of Contents*

ENDPSD <#id501610> - Macro used to define the end of the Program Static
Data (PSD). The ENDPSD macro is used to close either a partial PSD
within the program code, or the last PSD at the end of the program.


    Name

ENDPSD ù Macro used to define the end of the Program Static Data (PSD).
The ENDPSD macro is used to close either a partial PSD within the
program code, or the last PSD at the end of the program.


    Syntax

|ENDPSD |


    Operands

None


    Errors

  *

    ENDPSD does not correspond to a PSD

  *

    ENDPSD is not at the same nesting level as PSD


    Chapter 29. The ENDPWA Macro

*Table of Contents*

ENDPWA <#id500130> - Macro used to define the end of the Program Work
Area (PWA) or to close a partial PWA. The ENDPWA macro defines the
PWAPLLEN tag to establish the length of the PWA. If the DYN option is
being used, ENDPWA uses the ##ORGS macro to reserve space for the SWAs.
If option NORENT is in effect, a DS instruction is generated to reserve
storage in the CSECT for the PWA.


    Name

ENDPWA ù Macro used to define the end of the Program Work Area (PWA) or
to close a partial PWA. The ENDPWA macro defines the PWAPLLEN tag to
establish the length of the PWA. If the DYN option is being used, ENDPWA
uses the ##ORGS macro to reserve space for the SWAs. If option NORENT is
in effect, a DS instruction is generated to reserve storage in the CSECT
for the PWA.


    Syntax

|ENDPWA |


    Operands

None


    Errors

None


    Chapter 30. The ENDSSD Macro

*Table of Contents*

ENDSSD <#id502478> - Macro used to define the end of the Subroutine
Static Data (SSD). The ENDSSD macro is used to close either a partial
SSD within the subroutine code, or the last SSD at the end of the
subroutine.


    Name

ENDSSD ù Macro used to define the end of the Subroutine Static Data
(SSD). The ENDSSD macro is used to close either a partial SSD within the
subroutine code, or the last SSD at the end of the subroutine.


    Syntax

|ENDSSD |


    Operands

None


    Errors

  *

    ENDSSD does not correspond to a SSD

  *

    ENDSSD is not at the same nesting level as SSD


    Chapter 31. The ENDSWA Macro

*Table of Contents*

ENDSWA <#id502785> - Macro used to define the end of the Subroutine Work
Area (SWA). It is also used to end a partial SWA definition. The ENDSWA
macro establishes the length of the SWA for Dynamic Storage
calculations. ENDSWA insures double word alignment for anything that
follows the SWA.


    Name

ENDSWA ù Macro used to define the end of the Subroutine Work Area (SWA).
It is also used to end a partial SWA definition. The ENDSWA macro
establishes the length of the SWA for Dynamic Storage calculations.
ENDSWA insures double word alignment for anything that follows the SWA.


    Syntax

|ENDSWA |


    Operands

None


    Errors

None


    Chapter 32. The ERREXIT Macro

*Table of Contents*

ERREXIT <#id502621> - Structured macro used to conditionally cause an
errexit block to be executed.


    Name

ERREXIT ù Structured macro used to conditionally cause an errexit block
to be executed.


    Syntax

|ERREXIT [cond][,CODE=code][,CODEREG=reg][,NAME=name] |


    Operands

name
    Name of errexit block to execute. If the name is omitted, the
    unnamed error exit block for the program is executed.
code
    Symbol representing a value from 0 to 4095. If specified, this code
    is passed to the error exit block in the CODEREG= register.
reg
    Register used for passing error code. The default is R14.
cond
    Conditional expression. (See Chapter 2, <##condch>/Conditional
    Statements/ <##condch>) If the expression is true, the error exit is
    taken. If an expression is not specified, the error exit is always
    taken.


    Errors

  *

    For possible condition errors, see Appendix B, <##interr>/Internal
    Macros Error Messages/ <##interr>.


    Chapter 33. The EXI Macro

*Table of Contents*

EXI <#id503135> - This is the EXecute Immediate macro. It is used to
generate an EX instruction and the instruction to be executed. This
allows the EXecuted statement to be defined at the same time the EX
instruction is defined, minimizing confusion. It also insures that the
USING environment is the same as that of the EX instruction. The
EXecuted instruction is generated in the PSD for the program (or SSD for
a subroutine) if the program has selected option LOCTR. Otherwise, it is
generated inline with a branch around it.


    Name

EXI ù This is the EXecute Immediate macro. It is used to generate an EX
instruction and the instruction to be executed. This allows the EXecuted
statement to be defined at the same time the EX instruction is defined,
minimizing confusion. It also insures that the USING environment is the
same as that of the EX instruction. The EXecuted instruction is
generated in the PSD for the program (or SSD for a subroutine) if the
program has selected option LOCTR. Otherwise, it is generated inline
with a branch around it.


    Syntax

|EXI reg,(opcode,op1[,op2[,op3]]) |


    Operands

reg
    Specifies the register to be used in the EX instruction.
opcode
    Defines the opcode to be used for the EXecuted instruction.
op1-3
    Defines the operands for the EXecuted instruction. There can be one,
    two, or three operands.


    Errors

None


    Chapter 34. The FILL Macro

*Table of Contents*

FILL <#id503428> - Macro used to fill an area of storage with a character.


    Name

FILL ù Macro used to fill an area of storage with a character.


    Syntax

|FILL op1[,op2][,LENGTH=len|(len,type)] |


    Operands

op1
    Provides the starting address of the storage to be cleared. This can
    be given as an RX-type address.
op2
    Provides a byte other than X'00' to propagate through the storage to
    be cleared. This can be specified in X'nn' or C'c' form (suitable
    for use by MVI). If not specified, X'00' is assumed.
len
    Provides the length of the storage area to be cleared. This can be a
    numeric value, a constant value or a register specification. The
    default is (L'op1,SHORT).
type
    Specifies the type of clearing operation to be performed: short,
    medium or long.


    Errors

  *

    FILL operation type invalid: Must be S)hort, M)edium, or L)ong

  *

    Long form FILL requires R-Form length

  *

    Length for FILL required but not specified

  *

    Unable to parse FILL destination


    Notes

If a tag is defined in a macro, FILL does not have L'/|tag|/resolved for
it and gets an assembly error. To correct this, code:

  FILL  tag,X'00',LENGTH=L'tag



    Chapter 35. The IBIT Macro

*Table of Contents*

IBIT <#id503736> - Macro used to invert bit flags in a byte.


    Name

IBIT ù Macro used to invert bit flags in a byte.


    Syntax

|IBIT [byte,]flag|(flag[,flag[,...]]) |


    Operands

byte
    Byte that contains bit(s) to be inverted. If this operand is
    omitted, the name of the byte is assumed to be the first five
    characters of the first flag name.
flag
    Byte mask with a binary one in the bit position of the mask that
    corresponds to the bit to be inverted in the byte.


    Errors

  *

    No more than eight flags can be specified

  *

    IBIT macro can have no more than two operands

  *

    If byte is not specified, flag name must be at least six characters long

  *

    If byte is not specified, the first five characters of all flags
    must match


    Chapter 36. The IF Macro

*Table of Contents*

IF <#id504009> - Structured macro used to start an IF structure.


    Name

IF ù Structured macro used to start an IF structure.


    Syntax

|IF cond[,THEN][,NAME=name]|


    Operands

name
    Name to be associated with IF structure.
cond
    Conditional expression. (See Chapter 2, <##condch>/Conditional
    Statements/ <##condch>)


    Errors

  *

    IFs can only be 20 deep

  *

    For possible condition errors, see Appendix B, <##interr>/Internal
    Macros Error Messages/ <##interr>.


    Chapter 37. The LCBA Macro

*Table of Contents*

LCBA <#id504567> - This macro loads the address of certain control
blocks into a register. No registers are changed except for the register
specified. A zero condition is set if the control block cannot be
located. It is not necessary for the mapping macros for the control
blocks used internally by this macros to be included in the source program.


    Name

LCBA ù This macro loads the address of certain control blocks into a
register. No registers are changed except for the register specified. A
zero condition is set if the control block cannot be located. It is not
necessary for the mapping macros for the control blocks used internally
by this macros to be included in the source program.


    Syntax

|LCBA reg,cb |


    Operands

reg
    This operand specifies the register to be loaded. The register must
    be specified as R1 through R15.
cb
    One of the following control blocks can be specified:

ACEE
    The address of the current RACF Accessor Environment Element is
    loaded. This address is the contents of the TCBSENV field of the
    current TCB if non-zero and present; otherwise, the address is the
    contents of the ASXBSENV field of the current ASXB.
ASCB
    The address of the current Address Space Control Block is loaded.
    This address is loaded from PSAAOLD.
ASXB
    The address of the current Address Space Extension Block is loaded.
    This address is loaded from ASCBASXB.
CVT
    The address of the Communications Vector Table is loaded. This
    address is loaded from location decimal 16.
TCB
    The address of the current Task Control Block is loaded. This
    address is loaded from PSATOLD.
UJT
    The address of the User Job Table is loaded. This control block is
    Clemson dependent. TCBUSER of the current TCB and its parents TCBs
    are searched to find the address of the UJT.
UVT
    The address of the User Communication Vector Table is loaded. This
    control block is Clemson dependent. This address is loaded from the
    three low order bytes of CVTUSER.


    Errors

  *

    <reg> is invalid. Register must be R1-R15.

  *

    <cb> is not a supported control block.


    Chapter 38. The LEAVE Macro

*Table of Contents*

LEAVE <#id503416> - Structured macro used to leave a structure.


    Name

LEAVE ù Structured macro used to leave a structure.


    Syntax

|LEAVE struc=name[,cond] |


    Operands

struc
    Type of structure to leave. This can be IF, LOOP, BLOCK, or CASEBLK.
name
    Name of the structure to leave. An * can be coded to indicate the
    current (innermost) structure of the specified type.
cond
    Conditional expression. (See Chapter 2, <##condch>/Conditional
    Statements/ <##condch>) If the expression is true, the structure is
    left. If an expression is not specified, the structure is left
    unconditionally.


    Errors

  *

    SMWA= keyword must be specified on program block macro

  *

    Only one keyword can be specified on LEAVE

  *

    Nesting level for <structure> is zero

  *

    <name> is not an active <structure> name

  *

    One keyword must be specified on LEAVE

  *

    For possible condition errors, see Appendix B, <##interr>/Internal
    Macros Error Messages/ <##interr>.


    Chapter 39. The LOOP Macro

*Table of Contents*

LOOP <#id505094> - Structured macro used to start a loop structure. For
LOOP WHILE loops, tests are done at the start of the loop. For LOOP
UNTIL loops, tests are done at the bottom of the loop. If the ENDLOOP
specifies UNTIL,LEAVE, the loop will continue until a LEAVE macro is
used to leave the loop. BCT, BXH, and BXLE loop use the assembler
instruction by the same name. BXH instructions are generated at the top
of the loop and BXLE, and BCT instructions are generated at the bottom
of the loop.


    Name

LOOP ù Structured macro used to start a loop structure. For LOOP WHILE
loops, tests are done at the start of the loop. For LOOP UNTIL loops,
tests are done at the bottom of the loop. If the ENDLOOP specifies
UNTIL,LEAVE, the loop will continue until a LEAVE macro is used to leave
the loop. BCT, BXH, and BXLE loop use the assembler instruction by the
same name. BXH instructions are generated at the top of the loop and
BXLE, and BCT instructions are generated at the bottom of the loop.


    Syntax

|LOOP [NAME=name,] WHILE,cond | UNTIL | BCT | BXH,reg,reg | BXLE |


    Operands

name
    Name to be associated with loop structure.
cond
    Conditional expression. (See Chapter 2, <##condch>/Conditional
    Statements/ <##condch>)
reg
    Register to be used on associated instruction.


    Errors

  *

    Additional positional parameters cannot be specified on LOOP <type>

  *

    LOOPs can only be nested 20 deep

  *

    Incorrect number of parameters specified for LOOP BXH

  *

    LOOP type <type> is invalid

  *

    For possible condition errors, see Appendix B, <##interr>/Internal
    Macros Error Messages/ <##interr>.


    Chapter 40. The L8, L16, L24, L32 Macros

*Table of Contents*

L8, L16, L24, L32 <#id504978> - Macros used to load a register with one,
two, three, or four bytes of data from non-aligned storage. This macro
clears the register and issues the appropriate ICM to accomplish this.


    Name

L8, L16, L24, L32 ù Macros used to load a register with one, two, three,
or four bytes of data from non-aligned storage. This macro clears the
register and issues the appropriate ICM to accomplish this.


    Syntax

|L||/n/||reg,addr |


    Operands

n
    Defines the size of the load operation in bits. /|n|/should be
    either 8, 16, 24 or 32 for single byte, half word, three byte, or
    full word load respectively.
reg
    Specifies the register to load.


      Warning

    Since this register is cleared before the load, it should not be
    used (directly or indirectly) to specify /|addr|/.

addr
    Specifies the address that register /|reg|/is loaded from.


    Errors

  *

    Invalid number of operands on L<n> instruction


    Chapter 41. The PLIST Macro

*Table of Contents*

PLIST <#id505750> - Macro used to generate or modify a parameter list.
The parameter list can be created in default parameter list storage or
routed to a specific location. Register one is also loaded with the
address of the completed list.


    Name

PLIST ù Macro used to generate or modify a parameter list. The parameter
list can be created in default parameter list storage or routed to a
specific location. Register one is also loaded with the address of the
completed list.


    Syntax

|PLIST [(parms)][,VL|NOVL][,PL=tag|(tag,num)][,DS=PWA|SWA] |


    Operands

parms
    A list of the parameters to be included in the parameter list. A
    missing parameter causes zero to be filled in for the parameter
    address. An * causes the macro to skip over that parameter,
    reserving the space in the parameter list but not modifying the data
    there. An * before a tag causes the macro to load the parameter list
    with the contents of the storage referenced by the tag instead of
    the address of the tag. This provides a form of indirect addressing.
    Numeric and character constants can be coded and are converted to
    fullword and character literals respectively. If /|parms|/is
    missing, the PLIST macro loads register one with the address
    specified by PL=.
VL|NOVL
    VL specifies that this is a variable length parameter list and
    therefore the high bit of the last address in the list should be set
    to one. NOVL says to not set the bit. NOVL is normally the default,
    but all of the super options establish VL as the default so that
    NOVL might be needed in certain cases.
tag
    Specifies the address of the parameter list to be created or
    modified. If the PL= keyword is not specified, the parameter list is
    created in the default parameter list storage established by an
    enclosing BLOCK macro, or in PWA or SWA storage if no other default
    was set up.
num
    Specifies the maximum number of the parameters that the storage at
    /|tag|/can accommodate. If /|tag|/has a length attribute that is a
    self-defining term, this operand is not necessary. This is used to
    insure that the specified parameter list will fit into the storage
    at /|tag|/.
DS=
    Specifies that space for this list is created in the PWA or SWA with
    a label of /|tag|/. The PL= keyword is required when using this
    operand. The size of /|parms|/is used to calculate the size of the
    storage created, unless /|num|/was specified on the PL= keyword. In
    this case, the size specified by /|num|/is used.


    Errors

  *

    First operand of PL keyword is required if DS keyword is specified

  *

    <ds> is not valid on the DS keyword

  *

    The PL keyword must be specified on this macro or on an enclosing
    BLOCK macro

  *

    <tag> is not large enough to contain parameter list

  *

    Invalid parameter <vl>

  *

    Too many parameters specified

  *

    Too many parameters on PL keyword


    Chapter 42. The PSD Macro

*Table of Contents*

PSD <#id506155> - Macro used to define the beginning of the Program
Static Data (PSD). The PSD macro uses LOCTR to locate the static data
after the instructions for the program. The PSD should be defined just
before the PWA for a particular program block if there is one.


    Name

PSD ù Macro used to define the beginning of the Program Static Data
(PSD). The PSD macro uses LOCTR to locate the static data after the
instructions for the program. The PSD should be defined just before the
PWA for a particular program block if there is one.


    Syntax

|PSD [TYPE=LAST|PARTIAL] |


    Operands

TYPE=
    Defines whether this is the PSD macro that defines the main body of
    the PSD at the end of the program (LAST), or a PSD macro that
    defines a portion of the PSD from within the body of the program
    (PARTIAL). If TYPE= is not specified, TYPE=LAST is assumed. The
    TYPE=PARTIAL option is included to allow macros within the body of
    the program to define fields in the PSD and have them placed with
    the static data.


    Errors

  *

    Nested PSD and SSD macros are not allowed


    Chapter 43. The PWA Macro

*Table of Contents*

PWA <#id506796> - Macro used to define the beginning of the Program Work
Area (PWA). The PWA macro automatically reserves space for a standard OS
save area, the SMWA, and any parameter lists if it is appropriate for
the current environment. Also, if the DYN option is being used, PWA sets
up the dynamic storage pointers (NAB, EOS-64). The PWA should be defined
as the last thing associated with a particular program block.


    Name

PWA ù Macro used to define the beginning of the Program Work Area (PWA).
The PWA macro automatically reserves space for a standard OS save area,
the SMWA, and any parameter lists if it is appropriate for the current
environment. Also, if the DYN option is being used, PWA sets up the
dynamic storage pointers (NAB, EOS-64). The PWA should be defined as the
last thing associated with a particular program block.


    Syntax

|PWA [TYPE=LAST|PARTIAL] |


    Operands

TYPE=
    Defines whether this is the PWA macro that defines the main body of
    the PWA at the end of the program (LAST), or a PWA macro that
    defines a portion of the PWA from within the body of the program
    (PARTIAL). If TYPE= is not specified, TYPE=LAST is assumed. The
    TYPE=PARTIAL option is included to allow macros within the body of
    the program to define fields in the PWA and also generate the code
    to initialize them. So far, this feature is only used by the PLIST
    macro, but can be used by any user macro.


    Errors

  *

    PWA option should be specified on the program block macro

  *

    Invalid TYPE <type> specified on PWA macro


    Chapter 44. The RBIT Macro

*Table of Contents*

RBIT <#id506756> - Macro used to reset bit flags in a byte.


    Name

RBIT ù Macro used to reset bit flags in a byte.


    Syntax

|RBIT [byte,]flag|(flag[,flag[,...]]) |


    Operands

byte
    Byte that contains bit(s) to be reset. If this operand is omitted,
    the name of the byte is assumed to be the first five characters of
    the first flag name.
flag
    Byte mask with a binary one in the bit position of the mask that
    corresponds to the bit to be reset in the byte.


    Errors

  *

    No more than eight flags can be specified

  *

    RBIT macro can have no more than two operands

  *

    If byte is not specified, flag name must be at least six characters long

  *

    If byte is not specified, the first five characters of all flags
    must match


    Chapter 45. The SBIT Macro

*Table of Contents*

SBIT <#id503120> - Macro used to set bit flags in a byte.


    Name

SBIT ù Macro used to set bit flags in a byte.


    Syntax

|SBIT [byte,]flag|(flag[,flag[,...]]) |


    Operands

byte
    Byte that contains bit(s) to be set. If this operand is omitted, the
    name of the byte is assumed to be the first five characters of the
    first flag name.
flag
    Byte mask with a binary one in the bit position of the mask that
    corresponds to the bit to be set in the byte.


    Errors

  *

    No more than eight flags can be specified

  *

    SBIT macro can have no more than two operands

  *

    If byte is not specified, flag name must be at least six characters long

  *

    If byte is not specified, the first five characters of all flags
    must match


    Chapter 46. The SMCTRL Macro

*Table of Contents*

SMCTRL <#id503105> - Macro used to set internal flags to affect the
operation of the Structured Macros.


    Name

SMCTRL ù Macro used to set internal flags to affect the operation of the
Structured Macros.


    Syntax

|SMCTRL FREEPWA=yesno |


    Operands

yesno
    Can be YES or NO to set an internal free PWA flag on or off. When
    this flag is on, the ENDBLK macro for the program block frees the
    PWA. This parameter in only valid if the REUSPWA option is in effect.


    Errors

  *

    The FREEPWA keyword is only valid if the REUSPWA option is in effect

  *

    FREEPWA=<value> is not valid


    Chapter 47. The SMLIST Macro

*Table of Contents*

SMLIST <#id507749> - Macro used to set options for the operation of the
Structured Macros Listing Program. This macro is processed by the
listing program and not the assembler.


    Name

SMLIST ù Macro used to set options for the operation of the Structured
Macros Listing Program. This macro is processed by the listing program
and not the assembler.


    Syntax

|SMLIST CONVERT=yesno |


    Operands

yesno
    Can be YES or NO to begin or end the automatic conversion of
    assembler source to upper case. All non-comment lines are converted
    to upper case with the exception of text between double quotes. This
    text remains unconverted and the double quotes (") are replaced with
    single quotes (') before passing the source on to the assembler.


    Errors

  *

    INVALID SMLIST STATEMENT


    Chapter 48. The SMSYMS Macro

*Table of Contents*

SMSYMS <#id507938> - This is not a macro, but is a copy member that must
be included at the beginning of any program that uses the structure
location symbols described in Location and Scope of Data Structures.


    Name

SMSYMS ù This is not a macro, but is a copy member that must be included
at the beginning of any program that uses the structure location symbols
described in Chapter 11, <##scope>/Location and Scope of Data
Structures/ <##scope>.


    Syntax

|COPY SMSYMS |


    Operands

None.


    Errors

None.


    Chapter 49. The SSD Macro

*Table of Contents*

SSD <#id507464> - Macro used to define the beginning of the Subroutine
Static Data (SSD). The SSD macro uses LOCTR to locate the static data.
If the subroutine has selected the LOADBASE option, the static data is
placed immediately after the subroutine code in the object module. If
the subroutine is not using LOADBASE, the subroutine static data is
placed with the program static data. The SSD should be defined just
before the SWA for a particular subroutine block.


    Name

SSD ù Macro used to define the beginning of the Subroutine Static Data
(SSD). The SSD macro uses LOCTR to locate the static data. If the
subroutine has selected the LOADBASE option, the static data is placed
immediately after the subroutine code in the object module. If the
subroutine is not using LOADBASE, the subroutine static data is placed
with the program static data. The SSD should be defined just before the
SWA for a particular subroutine block.


    Syntax

|SSD [TYPE=LAST|PARTIAL] |


    Operands

TYPE=
    Defines whether this is the SSD macro that defines the main body of
    the SSD at the end of the subroutine (LAST), or an SSD macro that
    defines a portion of the SSD from within the body of the subroutine
    (PARTIAL). If TYPE= is not specified, TYPE=LAST is assumed. The
    TYPE=PARTIAL option is included to allow macros within the body of
    the subroutine to define fields in the SSD and have them placed with
    the static data.


    Errors

  *

    Nested PSD and SSD macros are not allowed


    Chapter 50. The STRSA Macro

*Table of Contents*

STRSA <#id507155> - Macro used to store a register's value in the
Subroutine Work Area (SWA) save area. If an internal subroutine contains
an SWA, registers are automatically restored when the subroutine is
exited. If the internal subroutine needs to pass back the value of a
register, it can use this macro to save a register's current value in
the subroutine save area, so that it is not restored to the original
value when the subroutine returns.


    Name

STRSA ù Macro used to store a register's value in the Subroutine Work
Area (SWA) save area. If an internal subroutine contains an SWA,
registers are automatically restored when the subroutine is exited. If
the internal subroutine needs to pass back the value of a register, it
can use this macro to save a register's current value in the subroutine
save area, so that it is not restored to the original value when the
subroutine returns.


    Syntax

|STRSA reg |


    Operands

reg
    Defines the register to be saved. /|Reg|/must be one of the
    registers R0-R14.


    Errors

  *

    Invalid register specified - <reg>

  *

    This macro can only be used in subroutine blocks with the SWA option
    specified


    Chapter 51. The SWA Macro

*Table of Contents*

SWA <#id508323> - Macro used to define the beginning of the Subroutine
Work Area (SWA). The SWA macro automatically reserves space for a
subroutine save area, a SMWA, any parameter lists used by the
subroutine, and the Dynamic Storage Management pointers if needed. The
SWA for a subroutine should be defined immediately after the ENDBLK for
that subroutine. The SWA macro insures that any fields specified within
the SWA are aligned properly.


    Name

SWA ù Macro used to define the beginning of the Subroutine Work Area
(SWA). The SWA macro automatically reserves space for a subroutine save
area, a SMWA, any parameter lists used by the subroutine, and the
Dynamic Storage Management pointers if needed. The SWA for a subroutine
should be defined immediately after the ENDBLK for that subroutine. The
SWA macro insures that any fields specified within the SWA are aligned
properly.


    Syntax

|SWA [TYPE=LAST|PARTIAL] |


    Operands

TYPE=
    Defines whether this is the SWA macro that defines the main body of
    the SWA at the end of the subroutine (LAST), or an SWA macro that
    defines a portion of the SWA from within the body of the subroutine
    (PARTIAL). If TYPE= is not specified, TYPE=LAST is assumed. The
    TYPE=PARTIAL option is included to allow macros within the body of
    the subroutine to define fields in the SWA and also generate the
    code to initialize them. So far, this feature is only used by the
    PLIST macro, but can be used by any user macro.


    Errors

  *

    SWA option was not specified on the subroutine block macro or SWA
    already defined

  *

    Invalid TYPE <type> specified on SWA macro


    Chapter 52. The TBIT Macro

*Table of Contents*

TBIT <#id508190> - Macro used to test bit flags in a byte.


    Name

TBIT ù Macro used to test bit flags in a byte.


    Syntax

|TBIT [byte,]flag|(flag[,flag[,...]]) |


    Operands

byte
    Byte that contains bit(s) to be tested. If this operand is omitted,
    the name of the byte is assumed to be the first five characters of
    the first flag name.
flag
    Byte mask with a binary one in the bit position of the mask that
    corresponds to the bit to be tested in the byte.


    Errors

  *

    No more than eight flags can be specified

  *

    TBIT macro can have no more than two operands

  *

    If byte is not specified, flag name must be at least six characters long

  *

    If byte is not specified, the first five characters of all flags
    must match

  *

    This expression requires the Level H assembler


    Chapter 53. The TREG Macro

*Table of Contents*

TREG <#id508957> - Macro used to test a register for zero, positive, or
negative.


    Name

TREG ù Macro used to test a register for zero, positive, or negative.


    Syntax

|TREG reg |


    Operands

reg
    Register to be tested.


    Errors

  *

    TREG macro can have one and only one operand


    Chapter 54. The ##COND Macro

*Table of Contents*

##COND <#id508596> - This is an internal macro for use within other
macros and not in open code. The ##COND macro tests a conditional
expression and branches to the appropriate success or failure tags. This
macro is intended for use in user condition macros. For information
about writing a user condition macro, see User-Defined Conditions.


    Name

##COND ù This is an internal macro for use within other macros and not
in open code. The ##COND macro tests a conditional expression and
branches to the appropriate success or failure tags. This macro is
intended for use in user condition macros. For information about writing
a user condition macro, see the section called ôUser-Defined Conditionsö
<##ucond>.


    Syntax

|##COND expr,S=stag,F=ftag,L=logic |


    Operands

expr
    The conditional expression to be evaluated. This can be any valid
    conditional expression and can contain previously defined user
    conditions.
stag
    The name of the tag that marks the beginning of the code to be
    executed if the condition is true.
ftag
    The name of the tag that marks the beginning of the code to be
    executed if the condition is false.
logic
    Either P for positive logic (branch to success if condition is true)
    or N for negative logic (branch to failure, skipping over success
    code if condition is false). These last three operands are usually
    passed unchanged from the operands passed in on the user condition
    macro that is invoking ##COND.


    Errors

  *

    Invalid option <cond> for #TEST condition

  *

    Invalid or missing condition expression

  *

    Invalid number of parms for <op>

  *

    This expression requires the Level H assembler

  *

    Invalid condition <cond>

  *

    No more than 51 positional parameters can be specified in a condition


  Part III. Appendices

*Table of Contents*

A. Catalogued ASM Procedures At Clemson <##asmproc>
B. Internal Macros Error Messages <##interr>
C. Work Area Storage Layout <##dynform>

Work Area Layout with the DYN Option <#id523172>
Work Area Layout with NODYN and ENVIRON=DC <#id523607>
Work Area Layout with NODYN and ENVIRON=OS <#id523779>
Work Area Layout with NODYN and ENVIRON=PLI <#id523952>

D. Program Code and Static Data Layout <##codform>
E. Register Usage <#id524857>

Register Usage for ENVIRON=DC <#id524845>

IDMS/DC User Mode Registers And Linkage <#id524797>
IDMS/DC System Mode Registers And Linkage <#id525576>

Register Usage for ENVIRON=OS <#id525792>
Register Usage for ENVIRON=PLI <#id525943>

F. Summary of Amendments <#id526825>

Update November 6, 1989 <#id526837>
Update April 19, 1989 <#id526241>
Update October 1, 1987 <#id526986>
Update March 11, 1987 <#id527042>


    Appendix A. Catalogued ASM Procedures At Clemson

There are four catalogued procedures available at Clemson that provide
access to the Structured Macros: these are ASMP, ASMPC, ASMPCL, and
ASMPCLG. These procs perform a preprocess; preprocess and assemble;
preprocess, assemble, and link; or preprocess, assemble, link, and go
respectively.

The Structured Macro preprocessor (MSC0150$) does not change the source
input, but analyzes the use of the Structured Macros and produces a
nesting level report. After you have had some time to get used to it,
the nesting level report becomes very useful. Use //P.SYSIN to provide
iyour assembler source.

The assembly step executes the Level H Assembler with the options
XREF(SHORT), TERM and OBJECT. A //SYSTERM DD statement is included in
the procs, because it appears to be one of the more popular assembler
options. //SYSLIB concatenates SYS1.MACLIB and SYS2.STRUC.MACLIB. Note
that SYS2.MACLIB is not included, and must be included manually if desired.

The link-edit step follows the same conventions as the other Clemson
compile-and-link procs, in that link-edit control cards can be provided
via //L.SYSIN. Parms LIST and MAP are provided by the proc.

The three procs have the following keyword parameters available:

Keyword



In Procs



Default



Used For:

SYSOUT



All



A



Listing SYSOUT class

OBJECT



All but ASMP



DUMMY



ASM SYSPUNCH

COPT



All but ASMP



<null>



ASM parameters

LOPT



ASMPCL, ASMPCLG



<null>



Linkedit parameters

PDS



ASMPCL



<null>



Loadlib for L.SYSLMOD

NAME



ASMPCL



<null>



Load module name


    Appendix B. Internal Macros Error Messages

The following is a list of error messages that can be produced by
internal macros used by the Structured Macros. The character preceding
the message indicates: *-informational, 4-warning, and 8-error. Words
enclosed in angle brackets are replaced with the appropriate text when
the message is issued.

##COND

  *
        8-Invalid option <cond> for #TEST condition
  *
        8-Invalid or missing condition expression
  *
        8-Invalid number of parms for <op>
  *
        8-This expression requires the Level H assembler
  *
        8-Invalid condition <cond>
  *
        8-Invalid T=
  *
        8-No more than 51 positional parameters can be specified in a
        condition

##EESTD

  *
        8-R0 keyword can not be specified if option RTNR0 is not in effect
  *
        8-R1 keyword can not be specified if option RTNR1 is not in effect
  *
        8-SMWA= keyword needs to be specified on program block

##EPSTD

  *
        8-AMODE=<amode> is invalid on <type> block, keyword ignored
        :li-AMODE ignored unless XA option specified for program block
  *
        8-Invalid number of parameters in SAVE= keyword

##IESTD

  *
        8-SMWA= keyword needs to be specified on program block macro

##IGMSG

  *
        4-<kwdname>=<kwd> ignored

##IPSTD

  *
        8-AMODE=<amode> is invalid on <type> block, keyword ignored
        :li-AMODE ignored unless XA option specified for program block
  *
        8-AMODE 24 or 31 must be specified on containing subroutine
  *
        8-Invalid number of parameters in SAVE= keyword

##L

  *
        8-Decimal self-defining terms are the only type of self-defining
        terms allowed
  *
        8-WREG is required if R0,*ADDR is used

##LA

  *
        8-Decimal self-defining terms are the only type of self-defining
        terms allowed

##MREG

  *
        8-Register specification <reg> is invalid
  *
        8-Register <reg> specified multiple times
  *
        8-Register <reg> was not used - internal error
  *
        8-Invalid type of <type> on ##MREG macro - internal error

##ORGS
    *-For subroutine <subname> when called from subroutine <subname>
##PEDC

  *
        8-R0= invalid if option RTNR0 not specified
  *
        8-R1= invalid if option RTNR1 not specified

##PEOS

  *
        8-R0 keyword can not be specified if option RTNR0 is not in effect
  *
        8-R1 keyword can not be specified if option RTNR1 is not in effect

##PPDC

  *
        8-Invalid option <opt>
  *
        4-RMODE and AMODE ignored if MODE option not specified
  *
        4-RMODE and AMODE ignored if XA option not specified
        :li-SYSTEM-MODE GETSTG generated :li-#GETSTK generated: #GETSTK
        =(value)
  *
        8-#START option required if SYSTEM option specified
  *
        8-#RETURN-related operands not allowed with SYSTEM option
  *
        8-#START/#RTN options not allowed with NOSYSTEM option
  *
        8-#RETURN option not allowed with SYSTEM option
  *
        8-EP option not allowed with NOSYSTEM option
  *
        8-AMODE and RMODE requested are inconsistent
  *
        8-GETSTK option requires SYSTEM option
  *
        8-GETSTK option requires PWA option
  *
        8-MPMODE option requires SYSTEM and #START options

##PPOS

  *
        8-Invalid option &OPT
  *
        4-Option DYN assumed because of option MAIN
  *
        4-Option PWA assumed because of option DYN
  *
        4-DYNSIZE can not be specified without option DYN
  *
        8-Name required on program block macro
  *
        4-RMODE and AMODE ignored if MODE option not specified
  *
        4-RMODE and AMODE ignored if XA option not specified
  *
        4-SVAREA= ignored when PWA option specified
  *
        8-First PWAREG must be R13 :li-SAVEAREA option assumed because
        of PWA option
  *
        4-SVAREA= ignored when RENT and SAVEAREA option specified
        :li-SAVEAREA option assumed because of SVAREA= keyword
        :li-Assuming register 1 is saved
  *
        8-Option REUSPWA requires the PWA, RENT and SAVE options
  *
        4-Option FNCODE is ignored when the REUSPWA option is not in effect
  *
        8-Option ESV requires the PWA and RENT options
  *
        8-Option CLRDEBUG requires the ESV option

##PPPLI

  *
        8-Invalid option <opt>
  *
        8-With ENVIRON=PLI, first BASEREG must be R11
  *
        8-With ENVIRON=PLI, first PWAREG must be R13
  *
        8-Name required on program block macro
  *
        4-RMODE and AMODE ignored if MODE option not specified
  *
        4-RMODE and AMODE ignored if XA option not specified

##PRMOPT

  *
        8-USING option requires two parameters
  *
        8-COPYERROR option requires two or three parameters
  *
        8-<opt> is an invalid suboption of the PARMS option
  *
        8-PARMS and PARMMAP keywords require the PARMS option
  *
        8-PARMS and PARMMAP keywords are mutually exclusive
  *
        8-Too many parameters specified on PARMMAP keyword
  *
        8-Second parameter required on PARMMAP keyword if COPY PARMS
        option is specified
  *
        8-<type> is invalid
  *
        8-##PRMOPT does not support <opt> option
  *
        8-<process> is an invalid value for PROCESS keyword
  *
        8-The first parameter in PARM options must be PARMS

##SPSTD

  *
        8-SAVE= invalid if SWA option specified
  *
        8-SWA option requires PWA option on program block
  *
        8-SWAREG= can not be specified unless OPTION=SWA is specified
  *
        8-AMODE= invalid for custom subroutine blocks
  *
        8-SAVE= invalid for custom subroutine blocks
  *
        8-CUSTOM must be specified alone
  *
        8-AMODE=<amode> is invalid on subroutine block, keyword ignored
        :li-LOADBASE assumed because BASEREG= specified
  *
        8-BLOCK TYPE=SUBROUTINE requires NAME=
  *
        8-LOADBASE option requires LONG option on program block
  *
        8-RECUR keyword requires DYN option on program block
  *
        8-R11 must be the first register specified on the SWAREG=
        keyword :li-AMODE ignored unless XA option specified on program
        block
  *
        8-Invalid number of parameters in SAVE= keyword

##ST

  *
        8-*ADDR form of second operand requires WREG=

##SUBOPT

  *
        8-<opt> is an invalid option for subroutine block

##SWREG

  *
        8-SMWA= keyword is required on the program block macro to
        support this function

##UCOND

  *
        8-Invalid or undefined user condition name: <cond>

##UPSTD

  *
        8-SWA option was not specified on the subroutine block macro or
        SWA already defined
  *
        8-Invalid type <type> specified on SWA macro

##WESTD
    *-<subname> first from index is <num>
    *-<num> CALLSUB from <subname>(<num>) to <subname>(<num>)
##WPDC

  *
        8-PWA option should be specified on the program block macro
  *
        8-Invalid type <type> specified on PWA macro

##WPOS

  *
        8-PWA option should be specified on the program block macro
  *
        8-Invalid type <type> specified on PWA macro

##WPPLI

  *
        8-PWA option should be specified on the program block macro
  *
        8-Invalid type <type> specified on PWA macro


    Appendix C. Work Area Storage Layout

*Table of Contents*

Work Area Layout with the DYN Option <#id523172>
Work Area Layout with NODYN and ENVIRON=DC <#id523607>
Work Area Layout with NODYN and ENVIRON=OS <#id523779>
Work Area Layout with NODYN and ENVIRON=PLI <#id523952>

If you are using PWAs and SWAs (with or without the DYN option), the
Structured Macros automatically allocate many fields for you. Since the
macros also manage these fields, you rarely need to worry about them.
However, there may be some cases in which it would be useful to know the
layout of PWA and SWA storage. That is what this appendix describes.


    Work Area Layout with the DYN Option

The DYN option is only available for program blocks with ENVIRON=OS in
effect.

As described in Chapter 5, <##pwaswa>/Program and Subroutine Work Areas/
<##pwaswa>, the DYN option acquires a single large chunk of storage at
the beginning of the program and partitions it as it is needed for
internal subroutine SWAs. The layout of the dynamic storage follows.

*Table C.1. Dynamic Storage Layout*

PWA



SWA



SWA



. . .



PWA



SWA



. . .



NAB?Free



(EOS-64)?16 Words

The first thing in dynamic storage is the main program's PWA followed by
any SWAs that happen to be active for that program. If the main program
invokes an external subroutine that uses *NOMAIN, another PWA is
generated for that program, followed by its SWAs. At the end is free
storage waiting to be allocated. The current NAB (Next Available Byte)
contains a pointer to the beginning of free storage. See the following
to see how to find the current NAB.

While EOS (End Of Storage) actually marks the end of the block of
storage that was GETMAINed, a pointer is kept to EOS-64 instead. This
provides a 16 word (64 byte) ôsafety zoneö for use by the internal
subroutine linkage routines. These extra bytes insure that there are
always at least 16 words left in dynamic storage when a subroutine is
entered. Because of this buffer, the subroutine can save its registers
before it has to calculate remaining space and update the pointers.

Within dynamic storage, all PWAs and SWAs start on a double word
boundary. This is to insure that any fields defined within their DSECTs
as double words actually have that alignment.

The preceding diagram shows that dynamic storage is divided up into PWAs
and SWAs. The format of a single PWA is shown in the following.

*Table C.2. Single PWA Format*

R13?Save Area (18F)



EOS-64



Reserved



NAB



Partial PWA



SMWA ^[a <#ftn.id523338>]



PL ^[b <#ftn.id523350>]



User Defined

^[a <#id523338>] The SMWA is variable in length.

^[b <#id523350>] The PL storage is as large as required.

First is an 18 word, standard OS save area for this program. It is used
anytime the program calls an external subroutine. This could be either
an IBM service or a separately compiled module. By putting the save area
at the beginning of the PWA and pointing register 13 to it, we can use
this register to keep up with both the current save area and the
beginning of PWA storage.

Following the save area is a pointer to EOS-64. This field defines the
end of the block of dynamic storage that this PWA resides in. This field
is filled in even for a *NOMAIN PWA. The EOS-64 pointer is used in
subroutine linkages to determine if there is enough storage left for an
SWA. Following this pointer is a fullword reserved for future use.

Next comes the NAB (Next Available Byte) for this PWA. This NAB points
to the first byte after this PWA. If there are no active SWAs following
this PWA, the NAB points to the start of free storage. Otherwise, it
points to the first SWA following the PWA.

Following the NAB are any fields defined by a PWA TYPE=PARTIAL macro.
These fields might have been defined by user macros, or by the DS=PWA
keyword on the PLIST macro. These fields can be any length. Also in the
partial PWA are parameter list fields for any internal subroutines that
do not have SWAs.

Following the partial fields is the SMWA (Structured Macros Work Area).
Note that the SMWA can be variable in length or absent. If you specify a
relocatable address for the SMWA, one is not allocated automatically.

Next is any space reserved for dynamically defined parameter lists in
the program block. These lists are any that do not have a PL=tag coded
on the PLIST macro or any enclosing block. Note that only enough space
for the largest such list is reserved instead of for all the lists. All
of these dynamic lists are created in the same place. For more
information on PLIST processing, see Chapter 10, <##parms>/Parameter
Lists and Standard Linkage/ <##parms>. This field can also be variable
in length or missing.

Finally come any fields that you coded between the PWA and ENDPWA
macros. These continue until the end of the PWA.

A PWA remains in dynamic storage as long as its program is running. The
PWA is followed by any active SWAs for that program's internal
subroutines. The SWAs are created and destroyed as the subroutines are
entered and exited. The format of a single SWA is shown in the following.

*Table C.3. Single SWA Format*

R11?NAB



R0-R14 Save



Partial SWA



SMWA ^[a <#ftn.id523518>]



PL ^[b <#ftn.id523532>]



User Defined

^[a <#id523518>] The SMWA for subroutines is not used and is of zero length.

^[b <#id523532>] The PL storage is as large as required.

The SWA looks very much like a PWA with a few fields missing. The only
significant difference is the 15 word subroutine save area. Note that
this is an internal subroutine save area, and not a standard OS save
area. The NAB for a subroutine points to the first available byte after
that subroutine's SWA. If this is the last SWA currently in dynamic
storage, this NAB points to the beginning of free space. Otherwise, it
contains the address of the next SWA (or PWA) in dynamic storage.

R11 always points to the beginning (i.e. the NAB) of the currently
active subroutine. If there is no subroutine active, R11 points to the
NAB from the current PWA. Therefore, R11 not only provides us with a
base for our SWA, it always points to the most current NAB.

This storage scheme is very easy to maintain and perform linkages on.
When an internal subroutine is entered, it uses R15 (this is why R15 is
destroyed with the DYN option) to calculate where its SWA will go from
the current NAB (pointed to by R11). It then saves its registers in this
new SWA and calculates a new NAB. If there is enough room for this SWA,
the subroutine updates R11 to point to its NAB and the linkage is
complete. Adding a new PWA is a similar process. The reverse linkage is
even easier. Since the pointer to the current NAB is kept in a register,
the act of restoring registers at the end of a subroutine returns the
dynamic storage environment to the state it was in before the subroutine
was entered. The same holds true for eliminating a PWA when an *NOMAIN
program is exited.


    Work Area Layout with NODYN and ENVIRON=DC

The work area layout for an ENVIRON=DC program is nearly identical with
that of an ENVIRON=OS program: the only differences are that the PWA
does not contain an 18-word OS savearea, and the PWA in an ENVIRON=DC
program is addressed by some register other than R13 (usually R11).

*Table C.4. NODYN and ENVIRON=DC Work Area Layout*

R11?Partial PWA



SMWA ^[a <#ftn.id523659>]



PL ^[b <#ftn.id523671>]



User Defined

^[a <#id523659>] The SMWA is variable in length.

^[b <#id523671>] The PL storage is as large as required.

An SWA in a NODYN program is represented in the following. It is
identical to the SWA for an ENVIRON=OS program with the NODYN option.

*Table C.5. SWA in NODYN ENVIRON=DC Format*

^[a <#ftn.id523723>] R0-R14 Save



Partial SWA



SMWA ^[b <#ftn.id523741>]



PL ^[c <#ftn.id523755>]



User Defined

^[a <#id523723>] With NODYN, the SWA is addressed off of the PWA base.

^[b <#id523741>] The SMWA for subroutines is not used and is of zero length.

^[c <#id523755>] The PL storage is as large as required.

ENVIRON=DC does not support the DYN option.


    Work Area Layout with NODYN and ENVIRON=OS

If the DYN option is not being used, the program can still have a PWA.
If this is the case, the PWA is of the following format:

*Table C.6. NODYN and ENVIRON=OS Work Area Layout*

R13?Save Area (18F)



Partial PWA



SMWA ^[a <#ftn.id523829>]



PL ^[b <#ftn.id523841>]



User Defined

^[a <#id523829>] The SMWA is variable in length.

^[b <#id523841>] The PL storage is as large as required.

The PWA for a NODYN program looks very much like the PWA created in
dynamic storage, except that the pointers used to keep up with dynamic
storage are not there. Also, any SWAs defined by this program reside in
the partial PWA area.

An SWA in a NODYN program is represented below. Remember that this
storage is actually allocated within the PWA's partial field.

*Table C.7. SWA in NODYN ENVIRON=OS Format*

^[a <#ftn.id523900>] R0-R14 Save



Partial SWA



SMWA ^[b <#ftn.id523918>]



PL ^[c <#ftn.id523932>]



User Defined

^[a <#id523900>] With NODYN, the SWA is addressed off of the PWA base.

^[b <#id523918>] The SMWA for subroutines is not used and is of zero length.

^[c <#id523932>] The PL storage is as large as required.


    Work Area Layout with NODYN and ENVIRON=PLI

The work area layout for ENVIRON=PLI is the same as the layout for
ENVIRON=OS with option NODYN in effect with the exception that the save
area is replaced by a PL/I DSA. A DSA starts with an OS save area with
the first word used for PL/I housekeeping. The forward link in the save
area is not used. The save area is followed by other PL/I housekeeping
fields. The format of the DSA is described in detail in the execution
time logic manual for the PL/I Optimizing Compiler.

*Table C.8. NODYN and ENVIRON=PLI Work Area Layout*

R13?PL/I DSA



Partial PWA



SMWA ^[a <#ftn.id524008>]



PL ^[b <#ftn.id524021>]



User Defined

^[a <#id524008>] The SMWA is variable in length.

^[b <#id524021>] The PL storage is as large as required.


    Appendix D. Program Code and Static Data Layout

The use of the LOCTR instruction in the Level H Assembler allows the
Structured Macros to gather code under different location counters and
place them at the proper point in the load module. To preserve the
integrity of the structure that the macros produce, a program should be
coded in the manner shown below.

*Example D.1. Structured Macros Use of Location Counters*

 BLOCK  TYPE=PROGRAM,NAME=MAINPROG,OPTIONS=(*MAIN,LONG),
               SUBOPTS=(*SWA,LOADBASE)
       :
  CALLSUB SUBONE
       :
 ENDBLK BLOCK=MAINPROG

 BLOCK  TYPE=SUBROUTINE,NAME=SUBONE
       :
  CALLSUB SUBTWO
       :
 ENDBLK BLOCK=SUBONE
 SWA
  --- SWA Fields for SUBONE ---
 ENDSWA

 BLOCK  TYPE=SUBROUTINE,NAME=SUBTWO,RECUR=10
       :
  CALLSUB SUBTWO
       :
 ENDBLK BLOCK=SUBTWO
 SSD
  --- Subroutine Static Data for SUBTWO ---
 ENDSSD
 SWA
  --- SWA Fields for SUBTWO ---
 ENDSWA

 BLOCK  TYPE=SUBROUTINE,NAME=SUBTHREE,OPTIONS=(NOLOADBASE)
       :
  CALLSUB SUBTHREE
       :
 ENDBLK BLOCK=SUBTHREE
 SSD
  --- Subroutine Static Data for SUBTHREE ---
 ENDSSD

 PSD
  --- Program Static Data ---
 ENDPSD
 PWA
  --- PWA FIELDS ---
 ENDPWA


Note that not all programs require all of these options. If SUBTWO was
not recursive, we would not need Dynamic Storage Management. However, it
can still be of assistance in reducing storage needs. SWAs, SSDs, and
the PSD only need to be coded if there are fields to define there. If
these areas are needed by the macros, they create them if you have not.
However, /the PWA and ENDPWA macros must always be coded if the program
uses the PWA option./


      Note

If the NOLOCTR option has been selected, the macros do not generate
LOCTRs to arrange the code, and the CSECT is arranged as it was coded.

When the load module is actually created by the Assembler, the layout of
a single CSECT looks like the example in the following table.

*Table D.1. CSECT Layout*

Program Code ^[a <#ftn.id525040>]



Subroutine Code ^[b <#ftn.id525051>]



Partial PSD ^[c <#ftn.id525064>]



PSD User Fields ^[d <#ftn.id525084>]



Subroutine Code ^[e <#ftn.id525098>]



SSD ^[f <#ftn.id525111>]

^[a <#id525040>] First in the CSECT is the code from the program block
itself.

^[b <#id525051>] Following the program code is the code for any
subroutines that did not specify LOADBASE. This allows these subroutines
to be addressed off of the program's base register.

^[c <#id525064>] The partial PSD contains any PSD fields defined within
the body of the program. Also included here are the SSDs from the
subroutines without LOADBASE. The partial PSD along with the PSD user
fields are addressed off of the program's base register.

^[d <#id525084>] The PSD user fields are any static data coded between
the PSD and ENDPSD macros at the end of the program.

^[e <#id525098>] The subroutine code for any subroutines that use the
LOADBASE option is placed after the PSD. If there are no subroutines
that use LOADBASE, this area and the next one are missing.

^[f <#id525111>] Following the code for a LOADBASE subroutine is the
static data (SSD) for that subroutine. This data is addressed off of the
subroutine's base register. These last two areas can be repeated any
number of times, once for each subroutine that uses the LOADBASE option.


    Appendix E. Register Usage

*Table of Contents*

Register Usage for ENVIRON=DC <#id524845>

IDMS/DC User Mode Registers And Linkage <#id524797>
IDMS/DC System Mode Registers And Linkage <#id525576>

Register Usage for ENVIRON=OS <#id525792>
Register Usage for ENVIRON=PLI <#id525943>

With so many things being done by the macros, you might not be sure what
registers are available for general use. This topic describes the
registers used by the Structured Macros.


    Register Usage for ENVIRON=DC

User mode and system mode differ.


      IDMS/DC User Mode Registers And Linkage

User mode programs are invoked by the following:

  *

    A #LINK from RHDCTSKC (task create)

  *

    A #LINK or #XCTL from another program

User mode registers are used as follows.

R15
    Entry point address from caller; loaded into the specified program
    base register by the BLOCK TYPE=PROGRAM macro. Also used for
    subroutine linkage if the LONG option is used.
R14
    This is used for returning from subroutine blocks.
R13
    Not used.
R12
    Default program base register.
R11
    Default PWA base register.
R10
    Address of the IDMS/DC CSA on entry, although this register can be
    used for other things by the program.
R9
    Address of the IDMS/DC task's TCE on entry, although this register
    can be used for other things by the program.
R2-R8
    Not used.
R1
    Address of parameter list from calling program, if any
R0
    Not used.

Registers are always saved across requests for IDMS/DC services, except
for R14, R15, R0 and R1.

The assembler program should include an interface, either by coding a
#BALI macro among your constants somewhere, or by specifying INCLUDE
IDMSLIB(IDMSBALI) to the linkage editor.

User mode programs must return to IDMS/DC using the #RETURN macro. If
you use the NO#RETURN option, you must code a #RETURN yourself at some
point after the program block's ENDBLK macro.


      IDMS/DC System Mode Registers And Linkage

System mode programs are invoked by a #CALL from another system-mode
program. Should you want to call an external routine, use #CALL instead
of CALLX.

System mode registers are used as follows.

R15
    Entry point address from caller; loaded into the specified program
    base register by the BLOCK TYPE=PROGRAM macro. Also used for
    internal subroutine linkage if the LONG option is used.
R14
    This is used for returning from subroutine blocks.
R13
    Not used.
R12
    Program base register.
R11
    Default PWA base register, for PWA's obtained by either #GETSTG or
    #GETSTK.
R10
    Address of the IDMS/DC CSA. This should not be modified by the program.
R9
    Address of the IDMS/DC task's TCE. This should not be modified by
    the program.
R2-R8
    Not used.
R1
    Address of parameter list from calling program, if any
R0
    Not used.

Registers R13 and R15-R1 are never saved across #CALLs.

Registers R11, R12 and R14 are always saved in the current TCE's save
area stack.

The caller of a routine is responsible for specifying which of the
remaining registers (R2-R8) are to be saved. For example, |#CALL
pgmname,(R2-R8)|causes R2 through R8 to be saved on the TCE stack, along
with R11, R12 and R14.


    Register Usage for ENVIRON=OS

R15
    This register is used for the address of the subroutine when CALLSUB
    is used with the LONG Program Block option.
R14
    This register holds the return address from any subroutine block
    called by the macros.
R13
    This is the base register for the PWA. Although the PWA can have
    multiple base registers, the first one must always be R13 since the
    standard OS save area for the program is at the beginning of the
    PWA. If *NORENT is used and SVAREA= is not specified, R13 is the
    first program base as well as pointing to the OS save area.
R12
    This is normally the base register for the program itself along with
    any static data. If the NORENT option is being used and the SVAREA=
    keyword was not specified, R13 is used for the base register instead
    of R12. The BASEREG= keyword on the Program Block can be used to
    specify a different base register (or multiple base registers).
R11
    If the DYN option is specified on the Program Block, R11 is used to
    establish addressibility on the SWA of the current subroutine. This
    register is in use even when no subroutine is currently active.
    Although the Subroutine Block allows you to specify multiple base
    registers for the SWA, R11 must always be the first one.
R10
    If the LOADBASE options is specified on the Subroutine Block, R10 is
    used as the base register for the subroutine code. This register is
    only in use while the LOADBASE subroutine is currently active. The
    BASEREG= keyword on the Subroutine Block can be used to specify a
    different base register (or multiple base registers).


    Register Usage for ENVIRON=PLI

R15
    This register is used for the address of the subroutine when CALLSUB
    is used with the LONG Program Block option.
R14
    This register holds the return address from any subroutine block
    called by the macros.
R13
    This is the base register for the PWA. A PL/I DSA is contained in
    the first part of the PWA; therefore, R13 is also the base for the
    DSA. Although the PWA can have multiple base registers, the first
    one must always be R13 because PL/I requires that R13 contain a
    pointer to the DSA.
R12
    This is the pointer to PL/I's Task Communications Area (TCA) and
    should never be modified by a program.
R11
    This is the first program base register for the program itself along
    with any static data.
R10
    If the LOADBASE option is specified on the Subroutine Block, R10 is
    used as the base register for the subroutine code. This register is
    only in use while the LOADBASE subroutine is currently active. The
    BASEREG= keyword on the Subroutine Block can be used to specify a
    different base register (or multiple base registers).


    Appendix F. Summary of Amendments

*Table of Contents*

Update November 6, 1989 <#id526837>
Update April 19, 1989 <#id526241>
Update October 1, 1987 <#id526986>
Update March 11, 1987 <#id527042>

Amendments and changes made since initial development follow.


    Update November 6, 1989

 1.

    Two new macros (DEFUCOND and ##COND) are provided to allow the
    programmer to define new conditional tests that can be inserted into
    any conditional expression.

 2.

    The COPYERROR and COUNT suboptions have been added to the PARMS option.


    Update April 19, 1989

 1.

    The Structured Macros now require the Level H Assembler for correct
    operation. Do not use them with the Level F Assembler.

 2.

    Changes were made in the PLIST macro to allow more flexible
    specification of parameters. Most notably, indirect referencing is
    now supported.

 3.

    Symbols have been provided to allow the program to locate the start
    of major structures such as the PWA, PSD, SWA, and SSD.

 4.

    An automatic prefixing facility has been added to allow programmers
    to name storage tags in a subroutine without having to worry about
    what tags in other subroutines have been named.

 5.

    A SMLIST macro has been added to control the output of the
    Structured Macros listing program. Currently, the only option is to
    provide for automatic conversion of the program to uppercase before
    assembly.


    Update October 1, 1987

 1.

    Support was added for writing Service Processors with the Structured
    Macros. Service Processors are programs that are called repeatedly
    to process one of a variety of functions, and that retain their
    workarea between calls. To learn more about Service Processors, see
    /Clemson University Computer Center Service Processor User's Guide
    and Reference/. The Service Processor support includes new options
    and keywords on the BLOCK macro and a new super option.

 2.

    The SMCTRL macro was added to set internal flags that affect the
    operation of the Structured Macros. Currently, this is only used for
    Service Processor support.


    Update March 11, 1987

 1.

    An ENVIRON keyword was added to the BLOCK TYPE=PROGRAM macro to
    allow for the different linkage conventions in different program
    environments. Currently, the supported environments are: OS, DC, and
    PLI.

 2.

    Support was added for PWAs in non-reentrant programs.

 3.

    R0 and R1 keywords were added to the ENDBLK macro for programs to
    enable a program to pass back registers 0 and 1 to its caller.

 4.

    The error messages issued by internal macros have been moved to
    their own section.

 5.

    Minor editorial changes have been made.

