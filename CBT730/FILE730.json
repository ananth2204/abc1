{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012658000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 58786, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 6, "INMDSNAM": "CBT.V500.FILE730.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 58786, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 58786, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE730.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x02\\x0e'", "DS1TRBAL": "b'U\\xcc'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x04\\xfc\\x00\\r\\x04\\xfd\\x00\\x00\\x00\\x03'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04F\\x00\\x00\\x01\\x051?\\x01\\x051?\\x011\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf7\\xf0@@@'", "ispf": {"version": "04.70", "flags": 0, "createdate": "2005-11-09T00:00:00", "modifydate": "2005-11-09T01:31:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-470"}, "text": "REGULAR CBT TAPE - VERSION 470    FILE:  730\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT470.FILE730\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 4 MEMBERS COUNTED; CUMULATIVE SIZE IS 318 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   11/09/05    01:31:19    GMT-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$NOTE1": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x02\\x01\\x051\\x1f\\x01\\x051\\x1f\\x12S\\x00\\t\\x00\\t\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2005-11-07T00:00:00", "modifydate": "2005-11-07T12:53:02", "lines": 9, "newlines": 9, "modlines": 0, "user": "SBGOLOB"}, "text": "Good morning Sam\n\nI would like to submit a little program we are\nusing to run COBOL programs in a z/OS.e LPAR.  It is in\nproduction and seems to be working well.\n\nThanks!!\n\nHal Merritt\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "@FILE730": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04F\\x00\\x00\\x01\\x051?\\x01\\x051?\\x011\\x00=\\x00=\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf7\\xf0@@@'", "ispf": {"version": "04.70", "flags": 0, "createdate": "2005-11-09T00:00:00", "modifydate": "2005-11-09T01:31:00", "lines": 61, "newlines": 61, "modlines": 0, "user": "CBT-470"}, "text": "//***FILE 730 is from Hal Merritt, and contains a generalized       *   FILE 730\n//*           version of a sample IBM program which allows you to   *   FILE 730\n//*           run COBOL programs in batch under a z/OS.e LPAR.      *   FILE 730\n//*           A description of the program follows:                 *   FILE 730\n//*                                                                 *   FILE 730\n//*           email:  hal.merritt@att.net                           *   FILE 730\n//*                                                                 *   FILE 730\n//*      This routine or front end is the documented way to         *   FILE 730\n//*       run most any COBOL program in batch under z/OS.e.         *   FILE 730\n//*       There is no documented restriction as to version of       *   FILE 730\n//*       complier, but the COBOL program must be linked with       *   FILE 730\n//*       LE runtimes.                                              *   FILE 730\n//*                                                                 *   FILE 730\n//*      Orginal program from topic 6.3.5 of SC26-4818-05 IBM       *   FILE 730\n//*      Language Environment for MVS & VM Programming Guide        *   FILE 730\n//*      Release 5.                                                 *   FILE 730\n//*                                                                 *   FILE 730\n//*      There are two main modifications.  One, the return         *   FILE 730\n//*      code from the called program is percolated instead         *   FILE 730\n//*      of dropped.  Look for L R15,SUBRETC  near the label        *   FILE 730\n//*      DONE.                                                      *   FILE 730\n//*                                                                 *   FILE 730\n//*      The second is to call a program named in the               *   FILE 730\n//*      parm rather than from a hard coded entry. This             *   FILE 730\n//*      code starts near label PARM2.                              *   FILE 730\n//*                                                                 *   FILE 730\n//*      What happens is the program name is extracted from         *   FILE 730\n//*      the parm, then the parm pointers are adjusted so           *   FILE 730\n//*      that the called program is unaware anything is             *   FILE 730\n//*      unusual.  The program name is expected to be the           *   FILE 730\n//*      first one to eight bytes delimited by a comma or           *   FILE 730\n//*      blank.  The parm pointers are adjusted to the first        *   FILE 730\n//*      position past the delimiter.                               *   FILE 730\n//*                                                                 *   FILE 730\n//*      Of course, the maximum parm length usable by the           *   FILE 730\n//*      called program is reduced by the length of the             *   FILE 730\n//*      module name plus one.  Other than that, the called         *   FILE 730\n//*      program should not need any modifications.                 *   FILE 730\n//*                                                                 *   FILE 730\n//*      We call this routine PIPICALL, and stow it in a            *   FILE 730\n//*      linklist library.  The JCL modifications are:              *   FILE 730\n//*                                                                 *   FILE 730\n//*         Before =>                                               *   FILE 730\n//*      //MYSTEP   EXEC PGM=MYPROG,PARM=MYPARM                     *   FILE 730\n//*                                                                 *   FILE 730\n//*         After  =>                                               *   FILE 730\n//*      //MYSTEP  EXEC PGM=PIPICALL,PARM='MYPROG,MYPARM'           *   FILE 730\n//*                                                                 *   FILE 730\n//*       Function :  CEEPIPI - Initialize the PIPI                 *   FILE 730\n//*                             environment, call a PIPI HLL        *   FILE 730\n//*                             program, and terminate the          *   FILE 730\n//*                             environment.                        *   FILE 730\n//*                                                                 *   FILE 730\n//*     1.  Call CEEPIPI to initialize a subroutine environment     *   FILE 730\n//*         under LE.                                               *   FILE 730\n//*     2.  Call CEEPIPI to load and call a reentrant HLL           *   FILE 730\n//*         subroutine.                                             *   FILE 730\n//*     3.  Call CEEPIPI to terminate the LE PIPI environment.      *   FILE 730\n//*                                                                 *   FILE 730\n//*     Note:  PIPICALL is not reentrant.                           *   FILE 730\n//*                                                                 *   FILE 730\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "PIPICALL": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x001\\x01\\x051\\x1f\\x01\\x051\\x1f\\x11\\x13\\x00\\xec\\x00\\xed\\x00\\x00\\xd4\\xc5\\xd9\\xd9\\xc9\\xe3\\xe3@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2005-11-07T00:00:00", "modifydate": "2005-11-07T11:13:31", "lines": 236, "newlines": 237, "modlines": 0, "user": "MERRITT"}, "text": "//PIPICALL JOB ...\n//**************************************************************\n//S1  EXEC  ASMACL,MYMEM=PIPICALL\n//C.SYSLIB DD\n//         DD DSN=CEE.SCEEMAC,DISP=SHR\n//C.SYSIN DD  *\n***********************************************************************\n*  This routine or front end is the documented                        *\n*   way to run most any COBOL program in batch under                  *\n*   z/OS.e. There is no documented restriction as to version of       *\n*   complier, but the COBOL program                                   *\n*   program must be linked with LE  runtimes.                         *\n*                                                                     *\n***********************************************************************\n* Orginal program from topic 6.3.5 of SC26-4818-05                    *\n* IBM Language Environment for MVS & VM                               *\n* Programming Guide                                                   *\n* Release 5                                                           *\n*  There are two main modifications. One, the                         *\n*  return code from the called program is                             *\n*  percolated instead of dropped. Look for L                          *\n*  R15,SUBRETC  near the label DONE.                                  *\n*                                                                     *\n*  The second is to call a program named in the                       *\n*  parm rather than from a hard coded entry. This                     *\n*  code starts near label PARM2.                                      *\n*                                                                     *\n*  What happens is the program name is extracted                      *\n*  from the parm, then the parm pointers are                          *\n*  adjusted so that the called program is unaware                     *\n*  anything is unusual. The program name is                           *\n*  expected to be the first one to eight bytes                        *\n*  delimited by a comma or blank. The parm                            *\n*  pointers are adjusted to the first position past the               *\n*  delimiter.                                                         *\n*                                                                     *\n*  Of course, the maximum parm length usable by                       *\n*  the called program is reduced by the length of                     *\n*  the module name plus one. Other than that, the                     *\n*  called program should not need any                                 *\n*  modifications.                                                     *\n*                                                                     *\n*  We call this routine PIPICALL, and stow it in a                    *\n*  linklist library. The JCL modifications are:                       *\n*                                                                     *\n*  Before => //MYSTEP   EXEC PGM=MYPROG,PARM=MYPARM                   *\n*                                                                     *\n*  After  => //MYSTEP  EXEC PGM=PIPICALL,PARM='MYPROG,MYPARM'         *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n*                                                                     *\n*   Function :  CEEPIPI - Initialize the PIPI environment,            *\n*                         call a PIPI HLL program, and terminate      *\n*                         the environment.                            *\n*                                                                     *\n* 1.Call CEEPIPI to initialize a subroutine environment under LE.     *\n* 2.Call CEEPIPI to load and call a reentrant HLL subroutine.         *\n* 3.Call CEEPIPI to terminate the LE PIPI environment.                *\n*                                                                     *\n* Note:  PIPICALL is not reentrant.                                   *\n*                                                                     *\n***********************************************************************\n*\n* =====================================================================\n* Standard program entry conventions.\n* =====================================================================\nPIPICALL CSECT\n         STM   R14,R12,12(R13)    Save caller's registers\n         LR    R12,R15            Get base address\n         USING PIPICALL,R12       Identify base register\n         ST    R13,SAVE+4         Back-chain the save area\n         LA    R15,SAVE           Get addr of this routine's save area\n         ST    R15,8(R13)         Forward-chain in caller's save area\n         LR    R13,R15            R13 -> save area of this routine\n*\n*\n         L     R2,0(R1)           PICK UP PARM ADDR\n         LTR   R2,R2              IS IT ZERO?\n         BNZ   PARM2              HAVE GOOD ADDRESS\n*                                   No.. issue message & quit\nBADPARM  WTO   'PIPICALL : PARM INVALID OR MISSING.',ROUTCDE=11\n         L     R5,=F'16'\n         ABEND (R5),DUMP          ABEND WITH BAD RC AND DUMP MEMORY\n*                                   No.. issue message & quit\nPARM2    LA    R2,0(R2)           PICK UP PARM ADDR\n         BZ    BADPARM            ADDR IS ZERO\n         LH    R3,0(R2)           PARM LENGTH\n         LTR   R3,R3\n         BZ    BADPARM            LENGTH IS ZERO\n*                                   NO.. CONTINUE\n         LA    R4,PTY             POINT TO TARGET\n         MVC   0(8,R4),=C'        '  BLANK OUT TARGET\n         LA    R5,9(R4)           stopper address\nPARM3    MVC   0(1,R4),2(R2)          PROGRAM NAME\n         SH    R3,=H'1'           REDUCE BY 1\n         BZ    PARMDONE           NONE LEFT, EXIT\n         LA    R2,1(R2)           NEXT BYTE\n         LA    R4,1(R4)           NEXT BYTE\n         CR    R4,R5              end of target?\n         BNL   BADPARM            YES AND NO DELIMETER FOUND.\n         CLI   2(R2),C','         COMMA?\n         BE    PARM4              YES\n         CLI   2(R2),C' '         SPACE?\n         BNE   PARM3              NO\nPARM4    SH    R3,=H'1'           UNCOUNT DELIMITER\n         LA    R2,1(R2)           AND POINT PAST IT\n*\n*\nPARMDONE STH   R3,0(R2)           MOVE NEW LENGTH OVER\n         ST    R2,0(R1)           FIX ADDR POINTER\n         OI    0(R1),X'80'        SET HIGH BIT\n         ST    R1,PARMPTR         AND PASS TO CALLEE\n*\n* Load LE CEEPIPI service routine into main storage.\n*\n         LOAD  EP=CEEPIPI         Load CEEPIPI routine dynamically\n         ST    R0,PPRTNPTR        Save the addr of CEEPIPI routine\n*\n* Initialize an LE PIPI subroutine environment.\n*\nINIT_ENV EQU   *\n         LA    R5,PPTBL           Get address of PIPI Table\n         ST    R5,@CEXPTBL        Ceexptbl-addr -> PIPI Table\n         L     R15,PPRTNPTR       Get address of CEEPIPI routine\n*                                 Invoke CEEPIPI routine\n         CALL  (15),(INITSUB,@CEXPTBL,@SRVRTNS,RUNTMOPT,TOKEN)\n*                                 Check return code:\n         LTR   R2,R15               Is R15 = zero?\n         BZ    CSUB                 Yes (success).. go to next section\n*                                   No (failure).. issue message\n         WTO   'PIPICALL : call to CEEPIPI(INIT_SUB) failed',ROUTCDE=11\n         WTO   'PIPICALL : Program load failed',ROUTCDE=11\n         ABEND (R2),DUMP          Abend with bad RC and dump memory\n*  orphaned code -                  No.. issue message & quit\n         C     R2,=F'8'           Check for partial initialization\n         BE    TSUB                 Yes.. go do PIPI termination\n*                                   No.. issue message & quit\n         WTO   'PIPICALL : INIT_SUB failure RC is not 8.',ROUTCDE=11\n         ABEND (R2),DUMP          Abend with bad RC and dump memory\n*\n* Call the subroutine, which is loaded by LE\n*\nCSUB     EQU   *\n         L     R15,PPRTNPTR       Get address of CEEPIPI routine\n         CALL  (15),(CALLSUB,PTBINDEX,TOKEN,PARMPTR,                   X\n               SUBRETC,SUBRSNC,SUBFBC)   Invoke CEEPIPI routine\n*                                 Check return code:\n         LTR   R2,R15               Is R15 = zero?\n         BZ    TSUB                 Yes (success).. go to next section\n         C     R2,=F'28'          Check for program stop\n         BE    TSUB                 YES  GO TO NEXT SECTION\n*                                   No (failure).. issue message & quit\n         WTO   'PIPICALL : call to CEEPIPI(CALL_SUB) failed',ROUTCDE=11\n         ABEND (R2),DUMP          Abend with bad RC and dump memory\n*\n* Terminate the environment\n*\nTSUB     EQU   *\n         L     R15,PPRTNPTR       Get address of CEEPIPI routine\n         CALL  (15),(TERM,TOKEN,ENV_RC)  Invoke CEEPIPI routine\n*                                 Check return code:\n         LTR   R2,R15               Is R15 = zero ?\n         BZ    DONE                 Yes (success).. go to next section\n*                                   No (failure).. issue message & quit\n         WTO   'PIPICALL : call to CEEPIPI(TERM) failed',ROUTCDE=11\n         ABEND (R2),DUMP          Abend with bad RC and dump memory\n*\n* Standard exit code.\n*\nDONE     EQU   *\n         LA    R15,0                Passed return code for system\n         L     R15,SUBRETC          Passed return code from program\n         L     R13,SAVE+4           Get address of caller's save area\n         L     R14,12(R13)          Reload caller's register 14\n         LM    R0,R12,20(R13)       Reload caller's registers 0-12\n         BR    R14                  Branch back to caller\n*\n* =====================================================================\n* CONSTANTS and SAVE AREA.\n* =====================================================================\nSAVE     DC    18F'0'\nPPRTNPTR DS    A                  Save the address of CEEPIPI routine\n*\n* Parameters passed to a CEEPIPI(INIT_SUB) call.\n*\nINITSUB  DC    F'3'               Function code to initialize for subr\n@CEXPTBL DC    A(PPTBL)           Address of PIPI Table\n@SRVRTNS DC    A(0)               Addr of service-rtns vector, 0 = none\nRUNTMOPT DC    CL255' '           Fixed length string of runtime optns\nTOKEN    DS    F                  Unique value returned (output)\n*\n* Parameters passed to a CEEPIPI(CALL_SUB) call.\n*\nCALLSUB  DC    F'4'               Function code to call subroutine\nPTBINDEX DC    F'0'               The row number of PIPI Table entry\nPARMPTR  DC    A(0)               Pointer to @PARMLIST or zero if none\nSUBRETC  DS    F                  Subroutine return code (output)\nSUBRSNC  DS    F                  Subroutine reason code (output)\nSUBFBC   DS    3F                 Subroutine feedback token (output)\n*\n* Parameters passed to a CEEPIPI(TERM) call.\n*\nTERM     DC    F'5'               Function code to terminate\nENV_RC   DS    F                  Environment return code (output)\n*\n* =====================================================================\n* PIPI Table.\n* =====================================================================\nPPTBL    CEEXPIT  ,               PIPI Table with index\nPTY      CEEXPITY ASA2A40X,0      0 = DYNAMICALLY LOADED ROUTINE\n*\n         CEEXPITS ,               End of PIPI table\n*\n*\n         LTORG\nR0       EQU   0\nR1       EQU   1\nR2       EQU   2\nR3       EQU   3\nR4       EQU   4\nR5       EQU   5\nR6       EQU   6\nR7       EQU   7\nR8       EQU   8\nR9       EQU   9\nR10      EQU   10\nR11      EQU   11\nR12      EQU   12\nR13      EQU   13\nR14      EQU   14\nR15      EQU   15\n         END   PIPICALL\n//L.SYSLIB  DD  DSN=my.linklist,DISP=SHR\n//L.SYSLMOD  DD  DSN=my.linklist(&MYMEM),DISP=SHR\n//**************************************************************\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT730/FILE730.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT730", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}