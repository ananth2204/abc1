{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012259000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 117572, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 6, "INMDSNAM": "CBT.V500.FILE530.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 117572, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 117572, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE530.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x03\\t'", "DS1TRBAL": "b'G\\x0e'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x03\\xed\\x00\\x05\\x03\\xed\\x00\\x08\\x00\\x04'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x01\\x01'\\x8f\\x01\\x01'\\x8f\\x16G\\x00\\x0c\\x00\\x0c\\x00\\x00\\xe2\\xc8\\xc9\\xd7\\xc4\\xc1\\xe3@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-10-05T00:00:00", "modifydate": "2001-10-05T16:47:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "SHIPDAT"}, "text": "REGULAR CBT TAPE - VERSION 439    FILE:  530\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT439.FILE530\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    27920   PO\n\n   5 MEMBERS COUNTED; CUMULATIVE SIZE IS 947 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   10/05/01    16:47:38    GMT-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$$INST": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x06\\x01\\x01'\\x8f\\x01\\x01'\\x8f\\x12Y\\x00\\x08\\x00\\x08\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-10-05T00:00:00", "modifydate": "2001-10-05T12:59:06", "lines": 8, "newlines": 8, "modlines": 0, "user": "SBGOLOB"}, "text": "//*           Installation (if gotten from the CBT web site):       *   FILE 530\n//*           -------------                                         *   FILE 530\n//*                                                                 *   FILE 530\n//*           Standard CBT procedure is used; save it to your PC;   *   FILE 530\n//*           upload it to your mainframe in binary form without    *   FILE 530\n//*           EBCDIC conversion or CRLF; do a TSO RECEIVE on it     *   FILE 530\n//*           to create a PDS.                                      *   FILE 530\n//*                                                                 *   FILE 530\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "@FILE530": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x01\\x00G\\x01\\x01'\\x8f\\x01\\x01'\\x8f\\x16F\\x00\\x11\\x00\\x11\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@\"", "ispf": {"version": "01.01", "flags": 0, "createdate": "2001-10-05T00:00:00", "modifydate": "2001-10-05T16:46:47", "lines": 17, "newlines": 17, "modlines": 0, "user": "SBGOLOB"}, "text": "//***FILE 530 is from Roy Gardiner and is a program written in      *   FILE 530\n//*           PL/I to format PL/I programs, so they conform to a    *   FILE 530\n//*           site standard.                                        *   FILE 530\n//*                                                                 *   FILE 530\n//*           Code can be:  indented to a selectable number of      *   FILE 530\n//*           columns for DO/END SELECT/END; converted to lower     *   FILE 530\n//*           case; comments moved to be more vertically aligned.   *   FILE 530\n//*                                                                 *   FILE 530\n//*           The code is written in legal PL/I without the use of  *   FILE 530\n//*           pointers; it should thus be platform independent.     *   FILE 530\n//*                                                                 *   FILE 530\n//*           There are two members; some JCL to run the formatter  *   FILE 530\n//*           and the formatter source code.  Instructions for      *   FILE 530\n//*           parameters to the formatter are in the JCL.           *   FILE 530\n//*                                                                 *   FILE 530\n//*      Questions:   email   roy@roygardiner.com                   *   FILE 530\n//*                                                                 *   FILE 530\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "FORM01": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01\\x00\\x1f\\x01\\x01\\x00\\x1f\\x00\\x00\\x03h\\x00\\x00\\x00\\x00\\xe9\\xe9\\xe9\\xe9\\xe9\\xe9\\xe9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-01-01T00:00:00", "modifydate": "2001-01-01T00:00:00", "lines": 872, "newlines": 0, "modlines": 0, "user": "ZZZZZZZ"}, "text": "*process inc gs nolist;\n /* Reformat a PLI program                             version 0.1   */\n (subrg,strg,size):\n reform: proc(parm) options(main);\n\n\n /* Notes:                                                            */\n /* This program is NOT designed to demonstrate super-efficient or    */\n /* otherwise whizzy PLI.                                             */\n /*                                                                   */\n /* This program will be baffled by                                   */\n /* 1): condition code prefix and statement labels on an internal     */\n /*     procedure which span more than one line                       */\n /* 2): multiple block closure,   e.g. end x;   where the presence    */\n /*     of the label name adds more   end;  statements.               */\n /* 3): Code that is NOT in columns 2-72                              */\n /* 4): Pre-processor code                                            */\n /*                                                                   */\n /*_____________________ FILES _______________________________ d:f  _**/\n dcl source        file record input;\n dcl sourcen       file record output;\n /*_____________________ Builtin functions ___________________ d:bif_**/\n\n                             /* string handling                       */\n dcl (bit,bool,char,graphic,high,index,length,low,\n      mpstr,repeat,string,substr,translate,unspec,verify\n            )           builtin;\n                             /* arithmetic                            */\n dcl (abs,add,binary,ceil,complex,conjg,decimal,divide,fixed,\n      float,floor,imag,max,min,mod,multiply,precision,\n      real,round,sign\n            )           builtin;\n                             /* mathematical                          */\n dcl (acos,asin,atan,atand,atanh,cos,cosd,cosh,erf,erfc,exp,log,\n      log2,log10,sin,sind,sinh,sqrt,tan,tand,tanh\n            )           builtin;\n                             /* array handling                        */\n dcl (all,any,dim,hbound,lbound,poly,prod,sum\n            )           builtin;\n                             /* condition handling                    */\n dcl (datafield,onchar,oncode,oncount,onfile,onkey,onloc,onsource\n            )           builtin;\n                             /* storage control                       */\n dcl (addr,allocation,binaryvalue,currentstorage,empty,entryaddr,\n      null,offset,pointer,pointeradd,pointervalue,storage,sysnull\n            )           builtin;\n                             /* event, multitasking, I/O, others      */\n dcl (completion,status,count,lineno,samekey,date,datetime,pliretv,\n      time,plicanc,plickpt,plicommit,plidump,plirest,pliretc,\n      plisrta,plisrtb,plisrtc,plisrtd,plitest\n            )           builtin;\n\n /*_____________________ External entry ______________________ d:e  _**/\n\n dcl subword           entry(char(*),bin fixed(15),bin fixed(15))\n                                      returns(char(32767) var);\n dcl strip             entry(char(*)) returns(char(32767) var);\n /*_____________________ General declarations (aggregates)_____d:ag _**/\n dcl  (SourceL(*),\n       SourceU(*),\n       codeOnly(*),\n       commOnly(*),\n        OutPut(*))  char(80) ctl;\n dcl  char1            char(1)  def(sourceU(i)) pos(j);\n dcl  char2            char(2)  def(sourceU(i)) pos(j);\n dcl  char1mixed       char(1)  def(sourceL(i)) pos(j);\n dcl  char2mixed       char(2)  def(sourceL(i)) pos(j);\n dcl  commchar1        char(1)  def(commonly(i)) pos(j);\n dcl  commchar2        char(2)  def(commonly(i)) pos(j);\n dcl  codechar1        char(1)  def(codeonly(i)) pos(j);\n dcl  codechar2        char(2)  def(codeonly(i)) pos(j);\n dcl  Uline            char(80) def(sourceU(i));\n dcl  CodeLine         char(80) def(CodeOnly(i));\n dcl  CommLine         char(80) def(CommOnly(i));\n dcl  OutPutLine       char(80) def(  OutPut(i));\n\n dcl 1 properties(*) ctl,\n         2 (stmt_start,\n            stmt_end,\n            all_comment,\n            nest_change)      bit(1) aligned,\n         2 stmt_kwd           char(8),\n         2 stmt_kwd_pos       bin fixed(15),\n         2 nest               bin fixed(15);\n dcl 1 print,\n         2 line#              pic'zzz9b',\n         2 Properties,\n           3 (stmt_start,\n              stmt_end,\n              all_comment,\n              nest_change)      char(1),\n           3 nest               pic'zz9b',\n           3 stmt_kwd           char(9),\n         2 start              char(1) init('>'),\n         2 outline            char(80);\n                             /* We may want to put in PROC and        */\n                             /* BEGIN later, so make arrarys.         */\n dcl  kwd_l1(2)         char(11) var init ('DO',\n                                           'SELECT');\n dcl  kwd_l2(1)         char(11) var init ('END');\n                             /* delimiters that may appear before or  */\n                             /* after a PLI keyword                   */\n dcl dlm_b4            (5) char(1) init(' ',';',')','/',':');\n dcl dlm_af            (4) char(1) init(' ',';','(','/');\n dcl nest_kwds         (4) char(8) var\n                         init('DO','SELECT','BEGIN','END');\n dcl nest_chg_now      (4) bit(1) aligned init(\n                              '0'b,'0'b,'0'b,'1'b);\n dcl nest_value        (4) bin fixed(15) init(1,1,1,-1);\n dcl left_padding      (0:25) char(250) var;\n dcl left_padding_L    (0:25) bin fixed(15);\n /*_____________________ General declarations (elements)_______d:lm _**/\n\n dcl (i,j,k,l,m,n)      bin fixed(15) init(0);\n dcl (lines,\n      #keywords,\n      lastCode,\n      commE,\n      commL,\n      commS,\n      first_nb,\n      second_nb,\n      nest_level,\n      leadblanksL,\n      shift,\n      kwd_subsc,\n      MaxErr)           bin fixed(15) init(0);\n dcl  (commcharcount,\n       codecharcount)   dec fixed(7) init(0);\n dcl  NewP              pic'zzz9';\n dcl (eofSource,\n      linewritten,\n      xcomments)        bit(1) aligned init('0'b);\n dcl (Line,\n      TmpLine\n          )             char(80);\n dcl Longtext           char(32767) var init('');\n dcl (lower,\n      lowerc,\n      pm,\n      po,\n      pp,\n      pc,\n      pu)               char(3);\n dcl keyword            char(8) var;\n dcl datec              char(6);\n dcl timec              char(6);\n dcl asa                char(1);\n dcl (scol,\n      colrqd,\n      bc,\n      lc,\n      indent)           fixed(3) init(0);\n dcl (e0,\n      e4,\n      e8,\n      e12)              char(100) var ctl;\n dcl  parm              char(100) var;\n dcl  varstr            char(200) var;\n dcl  var8              char(8)   var;\n dcl  leadblanks        char(80)  var;\n dcl (lbox,\n      sbox,\n      ol1,\n      ol2 )             char(80);\n dcl (p1,\n      p2,\n      p3,\n      p4)               pic 'zzz9';\n                             /*****************************************/\n                             /* Line counts for each file             */\n                             /*****************************************/\n  datec = date();\n  timec = time();\n  put skip(1) edit('PLI reformatter Version 01 ' ||\n     substr(datec,1,2) || '/' ||\n     substr(datec,3,2) || '/' ||\n     substr(datec,5,2) || ' ' ||\n     substr(timec,1,2) || ':' ||\n     substr(timec,3,2) || ':' ||\n     substr(timec,5,2) || ' ')(a);\n\n  get string(parm) data(pm,pu,po,scol,indent,bc,lc,pp,pc,lower,lowerc);\n\n  on endfile(source) eofSource = '1'b;\n                             /* Determine number of source lines      */\n  open  file(source);\n  read file(source) into(Line);\n  do while(\u00aceofSource);\n     lines = lines+1;\n     read file(source) into(Line);\n  end;\n  eofSource = '0'b;\n  close file(source);\n\n  alloc SourceL(lines);\n  alloc SourceU(lines);\n  alloc  OutPut(lines);\n  alloc Properties(lines);\n  alloc codeOnly(lines);\n  alloc commOnly(lines);\n  Properties = '';\n  codeOnly   = '';\n  commOnly   = '';\n                             /* Initialise left_padding for each nest */\n                             /* level                                 */\n  call Emsg(2,0,'','Column Starts');\n  do i = lbound(left_padding,1) to hbound(left_padding,1);\n     left_padding(i)   = substr((100)' ',1,(scol-1)+(indent*i));\n     left_padding_L(i) = length(left_padding(i));\n     call Emsg(2,0,'','Nest:' || i || ' Column:' || left_padding_l(i));\n  end;\n                             /* Read source file into correctly sized */\n                             /* variable                              */\n  open  file(source);\n\n  call Emsg(1,0,'','Source');\n  do i = 1 to lines;\n     read file(source) into(SourceL(i));\n                             /* remove line numbers                   */\n     SourceL(i) = Substr(Sourcel(i),1,72);\n     OutPut(i) = SourceL(i);\n                             /* form upper-case version               */\n     SourceU(i) = translate(SourceL(i),'ABCDEFGHIJKLMNOPQRSTUVWXYZ',\n                                       'abcdefghijklmnopqrstuvwxyz');\n     if pm = 'YES'\n     then put skip(1) edit(i,SourceL(i))(f(5),a);\n  end;\n\n                             /* take out comments and literals in the */\n                             /* upper-case version                    */\n  do i = 1 to hbound(sourceU,1);\n                             /* assume PLI columns 1-72               */\n     do j = 1 to 72;\n                             /* blank out all comments                */\n        if char2 = '/*' then\n    comloop:\n        do i = i to hbound(SourceU,1);\n           do j = j to 72;\n              if char2 = '*/' then\n              do;\n                 commchar2 = char2mixed;\n                 codechar2 = '  ';\n                 char2     = '  ';\n                 j=j+2;\n                 leave comloop;\n              end;\n              if char1 \u00ac= '' & char2 \u00ac= '/*' & char1 \u00ac= '*'\n              then commcharcount = commcharcount+1;\n              commchar1 = char1mixed;\n              char1 = '';\n           end;\n           j = 1;\n        end;\n        if lower = 'YES'\n        then  codechar1 = translate(char1mixed,\n                                   'abcdefghijklmnopqrstuvwxyz',\n                                   'ABCDEFGHIJKLMNOPQRSTUVWXYZ');\n        else  codechar1 = char1mixed;\n                             /* null string special case              */\n        if char2 = '''''' then char2 = '  ';\n                             /* blank out all literal strings         */\n        if char1 = '''' then\n        litloop:\n        do i = i to hbound(SourceU,1);\n           codechar1 = char1mixed;\n           char1 = '';\n           do j = j+1 to 72;\n                             /* quote in the string!                  */\n              if char2 = '''''' then\n              do;\n                 codechar2 = char2mixed;\n                 char2 = '';\n              end;\n\n              if char1 = '''' then\n              do;\n                 codechar1 = char1mixed;\n                 char1 = '';\n                 leave litloop;\n              end;\n              codechar1 = char1mixed;\n              char1 = '';\n           end;\n           j = 1;\n        end;\n        if char1 \u00ac= '' then codecharcount = codecharcount+1;\n     end;\n  end;\n                             /* detect statement start/end and kwd    */\n  do i = 1 to hbound(sourceU,1)-1;\n     if rightmostNB(Uline) = ';' then\n     do;\n        properties.stmt_end(i)     = '1';\n        properties.stmt_start(i+1) = '1';\n     end;\n     if properties.stmt_start(i) = '1' then\n     do;\n                             /* make sure stmt-start is correct       */\n                             /* (comments blanked out at this point)  */\n        if Uline = '' then\n        do;\n           properties.stmt_end(i)     = '0';\n           properties.stmt_start(i+1) = '1';\n        end;\n                             /* pick out statement keyword            */\n        else call firstkw(i);\n     end;\n  end;\n                             /* determine the nest level of each line */\n  do i = 1 to hbound(sourceU,1)-1;\n     properties.nest(i) = nest_level;\n                             /* is there a statement keyword?         */\n     call change_level(SourceU(i),i);\n  end;\n                             /* Move the code about                   */\n\n  do i = 1 to hbound(CodeOnly,1);\n                             /* beginning of a statement?             */\n     if properties.stmt_kwd(i) \u00ac= '' then\n     do;\n                             /* stop ASA char messing up searches     */\n        asa = substr(codeLine,1,1);\n        substr(codeLine,1,1) = '';\n                             /* find where code starts                */\n        first_nb   = verify(CodeLine,' ');\n        shift      =  first_nb - (left_padding_L(properties(i).nest)+1);\n        leadblanks  =  left_padding(properties(i).nest);\n        leadblanksL =  length(leadblanks);\n                             /* restore ASA char to code line         */\n        substr(codeLine,1,1) = asa;\n        asa = '';\n                             /* line up the code                      */\n shift_statement:\n        do while(i < hbound(CodeOnly,1));\n           asa = substr(codeLine,1,1);\n           substr(codeLine,1,1) = '';\n\n           if shift > 0 then\n                             /* code must be shifted to the LEFT..    */\n           do j = 1 to shift\n                       while(substr(CodeLine,1,leadBlanksL+1) = ' ');\n              codeline = substr(codeLine,2);\n           end;\n           else\n           if shift < 0 then\n                             /* code must be shifted to the RIGHT.    */\n           do j = 1 to abs(shift) while(substr(CodeLine,72,1) = ' ');\n              codeline = ' ' || codeLine;\n           end;\n                             /* try and line up DO-END-SELECT         */\n           call line_up;\n                             /* restore ASA char to code line         */\n           substr(codeLine,1,1) = asa;\n           asa = '';\n\n           if properties(i+1).stmt_kwd \u00ac= '' then\n              leave shift_statement;\n           i = i+1;\n        end;\n     end;\n  end;\n                             /* reformat comment lines                */\n  longtext = '';\n  Lbox = repeat(' ',lc-1) || '/' || (80)'*';\n  substr(lbox,72) = '/';\n  Sbox = repeat(' ',bc-1) || '/' || (80)'*';\n  substr(sbox,72) = '/';\n\n  do i = 1 to hbound(CommOnly,1);\n                             /* optionally change comments in all     */\n                             /* upper case to all lower case          */\n     if   commLine \u00ac= ''    then\n     if   lowerc   =  'YES' then\n     if (translate(commline,\n         '                                                            '\n         || (10)' ',\n         '/*ABCDEFGHIJKLMNOPQRSTUVWXYZ\u00ac!\"$\u00a2%[&*()_+`-=\u00a3]{};''#:@\u00af<>,.\\|'\n         || '0123456789')\n        = ' ')\n     then commLine = translate(Commline,\n         'abcdefghijklmnopqrstuvwxyz',\n         'ABCDEFGHIJKLMNOPQRSTUVWXYZ');\n                             /* Check for single-line only            */\n     commS = index(commLine,'/*');\n     commE = index(commLine,'*/');\n                             /* Push it over to the right             */\n     if CommE \u00ac= 71 & CommE > 0 then\n     do;\n        do j = 1 to 80 while(substr(commline,72,1) = '');\n           commline = ' ' || commline;\n        end;\n     end;\n     commS = index(commLine,'/*');\n     commE = index(commLine,'*/');\n     commL = CommE - CommS + 2;\n\n     if   commLine \u00ac= ''\n                             /* Only reformat single-line comments    */\n       &   (commS \u00ac= 0 & commE > CommS)\n     then\n     do;\n                             /* rightmost code byte..                 */\n        do j = 72 to 2 by -1 while(substr(CodeLine,j,1) = '');\n        end;\n        lastCode = j+2;\n                             /* code & coment don't overlap           */\n        if   (lastCode < CommS)\n                             /* comment is not too long               */\n          &  (67-lc > CommL)\n        then\n        do;\n           varstr = substr(commline,CommS+2);\n           k = index(varstr,'*/');\n           varstr = substr(varstr,1,k-2);\n           Commline = repeat(' ',max(lc,lastcode)-2) || '/*' || varstr;\n           substr(commLine,71) = '*/';\n        end;\n     end;\n  end;\n /*********************************************************************/\n                             /* create new program lines              */\n  longtext = '';\n  do i = 1 to hbound(CodeOnly,1);\n\n     select;\n        when (CodeLine = '' &\n              CommLine = '')  OutPutLine = '';\n        when (CodeLine = '')  OutPutLine = Commline;\n        when (CommLine = '')  OutPutLine = Codeline;\n        otherwise\n        do;\n                             /* code and comment on the line          */\n           OutPutLine = CodeLine;\n                             /* rightmost code byte..                 */\n           do j = 72 to 2 by -1 while(substr(CodeLine,j,1) = '');\n           end;\n                             /* leftmost comment byte                 */\n           k = verify(commline,' ');\n           if k>j then\n           do;\n                             /* code does not overlap comment         */\n              Substr(OutPutLine,k) = Substr(Commline,k);\n           end;\n           else\n           do;\n                             /* code does overlap comment...          */\n              substr(OutPutLine,j+1) = Substr(commline,k);\n              if substr(OutPutLine,73,8) \u00ac= '' then\n              do;\n                             /* ...and there is truncation            */\n                 substr(OutPutLine,71) = '*/';\n                 call addtext(i);\n              end;\n           end;\n        end;\n     end;\n  end;\n  if length(longtext) > 0 then Call Emsg(3,4,'S',\n          'Comments truncated on these lines:' || longtext);\n /*********************************************************************/\n                             /* write output lines to file            */\n  do i = 1 to hbound(OutPut,1);\n     if i < hbound(OutPut,1) then\n     do;\n        if properties.nest(i+1) > properties.nest(i) then\n        do;\n           j = find_keyword(CodeOnly(i));\n           if j > left_padding_L(properties.nest(i)) then\n           do;\n                             /* line to be split                      */\n              ol1 = substr(codeOnly(i),1,j-1);\n              if CommOnly(i) \u00ac= '' then\n              do k = 1 to 72;\n                 if substr(codeOnly(i),k,1) = ''\n                 then substr(ol1,k,1) = substr(CommOnly(i),k,1);\n              end;\n              write file(sourceN) from(Ol1);\n\n              ol2 = left_padding(properties.nest(i)) ||\n                    substr(CodeOnly(i),j);\n              write file(sourceN) from(Ol2);\n              linewritten = '1'b;\n           end;\n        end;\n     end;\n     if \u00aclinewritten\n     then write file(sourceN) from(OutPutLine);\n     linewritten = '0'b;\n  end;\n                             /* print output lines                    */\n  if po = 'YES' then\n  do;\n     put skip(1) edit('   Line number (output)')(a);\n     put skip(1) edit('   | 1=Statement starts on this line')(a);\n     put skip(1) edit('   | |1=Statement ends  on this line')(a);\n     put skip(1) edit('   | ||1=Line is all comment')(a);\n     put skip(1) edit('   | |||1=Nest level change')(a);\n     put skip(1) edit('   | ||||  Nest level')(a);\n     put skip(1) edit('   | ||||  | statement keyword')(a);\n     put skip(1) edit('   | ||||  | |')(a);\n     do i = 1 to lines;\n        print.line#      = i;\n        print.properties = properties(i),by name;\n        print.outline    = OutPut(i);\n        put skip(1) edit(String(print))(a);\n     end;\n  end;\n                             /* print comment-only lines              */\n  if pc = 'YES' then\n  do;\n     put skip(1) edit('   Line number (Comments-only)')(a);\n     put skip(1) edit('   | 1=Statement starts on this line')(a);\n     put skip(1) edit('   | |1=Statement endss on this line')(a);\n     put skip(1) edit('   | ||1=Line is all comment')(a);\n     put skip(1) edit('   | |||1=Nest level change')(a);\n     put skip(1) edit('   | ||||  Nest level')(a);\n     put skip(1) edit('   | ||||  | statement keyword')(a);\n     put skip(1) edit('   | ||||  | |')(a);\n     do i = 1 to lines;\n        print.line#      = i;\n        print.properties = properties(i),by name;\n        print.outline    = commOnly(i);\n        put skip(1) edit(String(print))(a);\n     end;\n  end;\n                             /* print PLI-only lines                  */\n  if pp = 'YES' then\n  do;\n     put skip(1) edit('   Line number (Code-only)')(a);\n     put skip(1) edit('   | 1=Statement starts on this line')(a);\n     put skip(1) edit('   | |1=Statement endss on this line')(a);\n     put skip(1) edit('   | ||1=Line is all comment')(a);\n     put skip(1) edit('   | |||1=Nest level change')(a);\n     put skip(1) edit('   | ||||  Nest level')(a);\n     put skip(1) edit('   | ||||  | statement keyword')(a);\n     put skip(1) edit('   | ||||  | |')(a);\n     do i = 1 to lines;\n        print.line#      = i;\n        print.properties = properties(i),by name;\n        print.outline    = codeOnly(i);\n        put skip(1) edit(String(print))(a);\n     end;\n  end;\n                             /* print upper case, modified text       */\n  if pu = 'YES' then\n  do;\n     put skip(1) edit('   Line number (upper case)')(a);\n     put skip(1) edit('   | 1=Statement starts on this line')(a);\n     put skip(1) edit('   | |1=Statement endss on this line')(a);\n     put skip(1) edit('   | ||1=Line is all comment')(a);\n     put skip(1) edit('   | |||1=Nest level change')(a);\n     put skip(1) edit('   | ||||  Nest level')(a);\n     put skip(1) edit('   | ||||  | statement keyword')(a);\n     put skip(1) edit('   | ||||  | |')(a);\n     do i = 1 to lines;\n        print.line#      = i;\n        print.properties = properties(i),by name;\n        print.outline    = SourceU(i);\n        put skip(1) edit(String(print))(a);\n     end;\n  end;\n qquit:\n\n  if allocation(e0)  > 0 then call Prt(e0 ,'I');\n  if allocation(e4)  > 0 then call Prt(e4 ,'W');\n  if allocation(e8)  > 0 then call Prt(e8 ,'E');\n  if allocation(e12) > 0 then call Prt(e12,'S');\n\n  newp = maxErr;\n  call Emsg(1,0,'',newp || ' was maximum error code');\n  put skip(1) edit('PLI reformatter - complete')(a);\n  call pliretc(maxErr);\n /*********************************************************************/\n set_line: proc;\n  if length(varstr) >= 73 then\n  do while(substr(varstr,73) \u00ac= '');\n     varstr = substr(varstr,2);\n  end;\n  codeLine = varstr;\n end;\n /*********************************************************************/\n line_up: proc;\n  dcl non_blank   bin fixed(15);\n                             /* try and line up DO-END-SELECT         */\n  non_blank = verify(CodeLine,' ');\n  if non_blank > 0\n  then\n  if substr(codeLine,non_blank,2) = 'DO' |\n     substr(codeLine,non_blank,6) = 'SELECT' |\n     substr(codeLine,non_blank,3) = 'END'\n  then\n  do;\n     tmpLine = leadblanks || substr(CodeLine,non_blank);\n     if substr(tmpline,73) = ''\n     then codeline = tmpline;\n  end;\n end;\n /*********************************************************************/\n find_keyword: proc(kwline) returns(bin fixed(15));\n  dcl kwline      char(80);\n  dcl Fkeyword    char(11) var;\n\n  dcl xl_kwline   char(80);\n  dcl (i,j,k,l,m,n);\n\n  xl_kwline = translate(kwline,\n         'ABCDEFGHIJKLMNOPQRSTUVWXYZ',\n         'abcdefghijklmnopqrstuvwxyz');\n\n  l = 0;\n find:\n  do i = lbound(nest_kwds,1) to hbound(nest_kwds,1);\n     do j = lbound(dlm_b4,1) to hbound(dlm_b4,1);\n        do k = lbound(dlm_af,1) to hbound(dlm_af,1);\n\n           Fkeyword = dlm_b4(j) || nest_kwds(i) || dlm_af(k);\n           kwd_subsc = i;\n\n           l = index(xl_kwline,Fkeyword);\n           if l > 0 then\n           do;\n                             /* say where the actual keyword is       */\n              l = l+1;\n              leave find;\n           end;\n        end;\n     end;\n  end;\n  return(l);\n  end find_keyword;\n /*********************************************************************/\n change_level: proc(thisline,thisline#);\n  dcl thisline    char(80);\n  dcl thisline#   bin fixed(15);\n\n  dcl (i,j,k,l,m,n);\n\n                             /* find keyword with allowed delimiters  */\n  l = find_keyword(thisline);\n  if l > 0 then\n  do;\n     nest_level = nest_level + nest_value(kwd_subsc);\n     properties.stmt_kwd_pos(thisline#) = l;\n                    /* cater for procedure-ends              */\n     if nest_level < 0 then nest_level = 0;\n                    /* test whether the nest level changes   */\n                    /* on this statement or the next         */\n     if nest_chg_now(kwd_subsc) then\n         properties.nest(thisline#) = nest_level;\n  end;\n\n  end change_level;\n /*********************************************************************/\n firstkw: proc(lineno);\n /*********************************************************************/\n /* return 1st pli keyword                                            */\n /* As of March 2000 this subroutine assumes that:                    */\n /*                                                                   */\n /* (condition-code-prefixes):label: keyword                          */\n /*                                                                   */\n /* are all on the same line. This is a bold assumption.              */\n /*********************************************************************/\n  dcl kwstring char(80) var;\n  dcl xword    char(80) var;\n  dcl lineno   bin fixed(15);\n\n  kwstring = strip(uline);\n  if substr(kwstring,1,1) = '(' then\n  do;\n                             /* condition code prefix                 */\n                             /* (assume closed on this line)          */\n      j = index(kwstring,'):');\n      kwstring = substr(kwstring,j+1);\n  end;\n                             /* label (assume ONE ONLY - ooh missus)  */\n  xword = subword(kwstring,1,1);\n  if substr(xword,length(xword),1) = ':'\n  then kwstring = substr(kwstring,length(xword)+1);\n                             /* get 1st word of string                */\n  keyword = subword(kwstring,1,1);\n  if length(keyword) > 0 then\n  if substr(keyword,1,1) = '%' then keyword = '';\n                             /* keyword null, look on next line       */\n  if keyword \u00ac= ''\n  then properties.stmt_kwd(i) = keyword;\n  else\n  do;\n     properties.stmt_start(i)   = '0';\n     properties.stmt_start(i+1) = '1';\n  end;\n end;\n /*********************************************************************/\n                             /* find rightmost non-blank in 2-72      */\n rightmostNB: proc(str) returns(char(1));\n  dcl str char(80);\n  dcl (i,j,k,l,m,n);\n\n  do i = 72 to 2 by -1 while(substr(str,i,1) = '');\n  end;\n  if i<2\n  then return('');\n  else return(substr(str,i,1));\n end;\n /*********************************************************************/\n addtext: proc(i);\n dcl p1     pic '9';\n dcl p2     pic '99';\n dcl p3     pic '999';\n dcl p4     pic '9999';\n dcl i      bin fixed(15);\n\n  select;\n     when (i<10)\n     do;\n        p1 = i;\n        if longtext = ''\n        then longtext = char(p1);\n        else longtext = longtext || ',' || char(p1);\n     end;\n     when (i<100)\n     do;\n        p2 = i;\n        if longtext = ''\n        then longtext = char(p2);\n        else longtext = longtext || ',' || char(p2);\n     end;\n     when (i<1000)\n     do;\n        p3 = i;\n        if longtext = ''\n        then longtext = char(p3);\n        else longtext = longtext || ',' || char(p3);\n     end;\n     otherwise\n     do;\n        p4 = i;\n        if longtext = ''\n        then longtext = char(p4);\n        else longtext = longtext || ',' || char(p4);\n     end;\n  end;\n end;\n /*********************************************************************/\n prt: proc(echar,level);\n  dcl echar        char(*) var ctl;\n  dcl level        char(1);\n  dcl printline    char(80) var;\n                             /* array for error messages              */\n  dcl eback        char(*) var ctl;\n  dcl (i,j);\n  dcl linelen      bin fixed(15) init(70);\n  dcl first        bit(1) auto init('1'b);\n\n  put skip(1) edit(level || '-level messages')(a);\n\n  do i = allocation(echar) to 1 by -1;\n                             /* put error messages in reverse order   */\n     alloc eback char(10+length(echar)) init(echar);\n     free echar;\n  end;\n                             /* now print messages in correct order   */\n  do i = 1 to allocation(eback);\n                             /* some error lines may need multiple    */\n                             /* lines to print out in full            */\n printloop:\n     do k = 1 to 100 while(eback \u00ac= '');\n        if length(eback) <= linelen then\n        do;\n           put skip(1) edit((05)' ' || eback)(a);\n           leave printloop;\n        end;\n        do j = linelen to 1 by -1\n                       while(  substr(eback,j,1) \u00ac= ','\n                             & substr(eback,j,1) \u00ac= ' ');\n        end;\n        put skip(1) edit((05)' ' || substr(eback,1,j))(a);\n\n        eback =      substr(eback,j+1);\n     end;\n     if k > 100 then put skip(1) edit('Limit exceeded')(a);\n     free eback;\n  end;\n end prt;\n /*********************************************************************/\n Emsg: proc(Enum,Ecode,Estore,Etext);\n\n dcl Enum          pic'999';\n dcl Ecode         pic'99';\n dcl Estore        char(1);\n dcl etext         char(*);\n dcl vtext         char(10+length(etext)) var auto;\n dcl i;\n  vtext =  'PRF' || enum || ' ' || ecode || ' ' || etext;\n  i = length(vtext);\n  maxerr = max(maxerr,ecode);\n\n  if estore = ''\n  then\n     put skip(1) edit(vtext)(a);\n  else\n  do;\n\n     select(ecode);\n                             /* store error messages for each error   */\n                             /* level - there may be any number       */\n        when(0)\n        do;\n           alloc e0 char(i);\n           e0 =  vtext;\n        end;\n        when(4)\n        do;\n           alloc e4 char(i);\n           e4 =  vtext;\n        end;\n        when(8)\n        do;\n           alloc e8 char(i);\n           e8 =  vtext;\n        end;\n        when(12)\n        do;\n           alloc e12 char(i);\n           e12 =  vtext;\n        end;\n     end;\n  end;\n\n  end emsg;\n  END reform;\n*process gs nolist nomap noesd;\n strip:   proc (instring)  returns(char(32767) var);\n  dcl instring                 char(*);\n  dcl (i,j);\n  dcl (length,substr,string)   builtin;\n\n  do i = 1 to length(instring) while(substr(instring,i,1) = ' ');\n  end;\n  do j = length(instring) to 1 by -1 while(substr(instring,j,1) = ' ');\n  end;\n\n  return ( substr(instring,i,j - i+1)  );\n  end strip;\n*process gs nolist nomap;\n subword: proc (instring,wordno,words) returns(char(32767) var);\n  dcl instring        char(*);\n  dcl (wordno,words)  bin fixed(15);\n  dcl (i,j,k);\n  dcl start           bin fixed(15);\n  dcl (length,substr) builtin;\n  j = 1;\n  k = 0;\n  if words < 1 | wordno < 1 then return('');\n                             /* search until the wordcount is met     */\n  do i = 1 to length(instring) until (k = words);\n\n                             /* ignore intermediate blanks            */\n     do i = i to length(instring) while (substr(instring,i,1) = ' ');\n     end;\n                             /* store 1st relevant word's  position   */\n     if j = wordno then start = i;\n                             /* count the relevant words found        */\n     if j >= wordno then k = k + 1;\n                             /* count words found so far              */\n     j = j + 1;\n                             /* find the end of the current word      */\n     do i = i to length(instring) until (substr(instring,i,1)  = ' ');\n     end;\n  end;\n  return(substr(instring,start,i-start));\n  end subword;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FORM01Y": {"ttr": 776, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01\\x00\\x1f\\x01\\x01\\x00\\x1f\\x00\\x00\\x00&\\x00\\x00\\x00\\x00\\xe9\\xe9\\xe9\\xe9\\xe9\\xe9\\xe9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-01-01T00:00:00", "modifydate": "2001-01-01T00:00:00", "lines": 38, "newlines": 0, "modlines": 0, "user": "ZZZZZZZ"}, "text": "//* This job reformats PLI source\n//*\n//* PM     YES  Print out source code in mixed case, with line numbers\n//* PU     YES  Print source in upper case with comments and literals\n//*            removed (this is what the program works on)\n//* PO     YES  Print the reformatted lines\n//* SCOL    n   column in which new code should start\n//* INDENT  n   Indentation for DO and SELECT groups\n//* BC      n   Column for box comments (typically 2) 0 for don't check\n//* LC      n   and for line comments (typically 30) 0 for don't check\n//* PP     YES  Print the PLI only (comments removed)\n//* PC     YES  Print the comments only (PLI removed)\n//* LOWER  YES  Best of all, convert all code to lower case\n//* LOWERC YES  Change comments that are all upper case to all lower\n//*             (mixed-case comments are unaffected)\n//*\n//* ??? indicates stuff to change\n//*\n//*********************************************************************\n//* pli source to be reformatted\n//SOURCE   SET SOURCE=???\n//* HLQ to which you have alter access\n//USER     SET USER=???\n//*********************************************************************\n//* Only for OPC shops; pre-delete all DISP=NEW datasets\n//DELETE   EXEC PGM=EQQDELDS,REGION=4M\n//SYSPRINT DD SYSOUT=*\n//*******************************************************************\n//FORMAT  EXEC PGM=FORM01,\n//        PARM='PM=''NO '',PU=''NO '',PO=''YES'',SCOL=3,INDENT=3,BC=02,X\n//             LC=35,PP=''NO '',PC=''YES'',LOWER=''NO '',LOWERC=''YES''X\n//             ;'\n//STEPLIB  DD DISP=SHR,DSN=???\n//SOURCE   DD DSN=&SOURCE,DISP=SHR\n//SOURCEN  DD DSN=&USER..???,DISP=(,CATLG),DSORG=PS,\n//            SPACE=(CYL,(1,1)),DCB=(RECFM=FB,LRECL=80,BLKSIZE=800),\n//            UNIT=SYSDA\n//SYSPRINT DD SYSOUT=*\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT530/FILE530.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT530", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}