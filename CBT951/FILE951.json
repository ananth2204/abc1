{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220013551000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 176358, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 7, "INMDSNAM": "CBT.V500.FILE951.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 176358, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 176358, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE951.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x04\\x0b'", "DS1TRBAL": "b'b&'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xc0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xc0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\t\\xe2\\x00\\x02\\t\\xe2\\x00\\x06\\x00\\x05'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04a\\x00$\\x01\\x182\\x7f\\x01\\x182\\x7f\\x12@\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf7@@@'", "ispf": {"version": "04.97", "flags": 0, "createdate": "2018-11-23T00:00:00", "modifydate": "2018-11-23T12:40:24", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-497"}, "text": "REGULAR CBT TAPE - VERSION 497    FILE:  951\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT497.FILE951\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    27920   PO\n\n   PDS117I 9 MEMBERS COUNTED; CUMULATIVE SIZE IS 1,473 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   11/23/18    12:40:23    UTC-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$NOTE01": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x001\\x01\\x162\\x7f\\x01\\x162\\x7f\\x00H\\x00\\x19\\x00\\x19\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-11-22T00:00:00", "modifydate": "2016-11-22T00:48:31", "lines": 25, "newlines": 25, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:  CBT tape submission\nFrom:     Nick Light <nicklight031@gmail.com>\nDate:     10/6/2016 5:21 PM\nTo:       sbgolob@cbttape.org\n\nHi Sam,\n\nI created a REXX exec, with a couple panels and messages, to\nconvert a GDG to a GDG extended (GDGE).  Converting to a GDGE\nenables the GDG limit to increase from a maximum 255 generations\nto 999 generations.  It started out as a simple program to do\nthat conversion in batch, but at Lionel Dyck's prompting, it grew\nover several iterations into something that can be used, online\nor in batch, to create a new GDG base or modify an existing GDG\nbase.\n\nIf you think this is something that can be used, feel free to add\nit to the CBT tape.  I don't mind you including my contact info.\n\nAttached is a file in TSO XMIT format.\n\nNick Light\n\nPS  Thanks for all your help in the past!\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$$NOTE02": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x04\\x01\\x182\\x7f\\x01\\x182\\x7f\\x128\\x007\\x007\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2018-11-23T00:00:00", "modifydate": "2018-11-23T12:38:04", "lines": 55, "newlines": 55, "modlines": 0, "user": "SBGOLOB"}, "text": "Corrections to GDGP from Peter Glanzmann\n\nCorrection #1\n\nThe RECATALOG keyword got missing here. You will notice no errors\nduring \"normal\" work but you will get errors when trying to\ndelete a GDS or allocating new GDS's after  emptying\" the GDG.\nErrors like the following will happen:\n\nIEC614I SCRATCH FAILED - RC 008, DIAGNOSTIC INFORMATION IS (04060020)\n\nBefore\n\n000875 cat.j = cat.j 'DEVT('devtype')',\n000876 'VOL('substr(word(lgdg.i,1),19,6)'))'\n\nAfter\n\n000875 cat.j = cat.j 'DEVT('devtype')',\n000876 'VOL('substr(word(lgdg.i,1),19,6)') RECATALOG)'\n                         (Add the RECATALOG word here)\n\nCorrection #2\n\nThe current version does not allow to set a new limit containing\na zero (e.g. increase the limit from 25 to 50), because zero is\nhandled as invalid.\n\nBefore\n000616 /* Ensure each digit of the LIMIT is numeric: */\n000617 do i=1 to length(limit)\n000618 if substr(limit,i,1) < 1 ! substr(limit,i,1) > 9 then do\n000619 invalid_limit = 1\n000620 end\n000621 end\n\nAfter\n000616 /* Ensure each digit of the LIMIT is numeric: */\n000617 do i=1 to length(limit)\n000618 if substr(limit,i,1) < 0 ! substr(limit,i,1) > 9 then do\n000619 invalid_limit = 1\n000620 end\n000621 end\n                         (Change 1 to 0.)\n\n\nAs an alternative, the loop in the code could also be shortened to:\nif datatype(limit) <> \"NUM\" ,\nthen invalid_limit = 1\n\n(Indentations may not match the original code, but the corrections\n are here.)\n\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$DOC": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x06\\x01\\x16(\\x0f\\x01\\x16(\\x0f\\x15Q\\x00\\x83\\x00\\x83\\x00\\x00\\xc7\\xc4\\xc7\\xd7@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-10-06T00:00:00", "modifydate": "2016-10-06T15:51:06", "lines": 131, "newlines": 131, "modlines": 0, "user": "GDGP"}, "text": "-----------------------------------------------------------------------\n|  DISCLAIMER:                                                        |\n-----------------------------------------------------------------------\n\nThis software is provided for your use without any warranty or recourse\nshould it not perform or cause problems.  The author and others who\nhave contributed are not responsible for issues that arise, nor are\ntheir employers. Use this software at your own risk. Test and test\nagain before using in any productive capacity.\n\nThe complete source is provided and it is my hope that you will not\nfind any issues.  However if you do have issues please let me know\n(nicklight031@gmail.com) and if you do make changes/enhancements,\nplease let me know as well.\n\n-----------------------------------------------------------------------\n|  REQUIREMENTS:                                                      |\n-----------------------------------------------------------------------\n\nSTEMEDIT, on CBT file 895, is required to be installed if you wish\nto use the GDGP panel for online processing.\n\n-----------------------------------------------------------------------\n|  INSTALLATION INSTRUCTIONS:                                         |\n-----------------------------------------------------------------------\n\n- Copy GDGP to your SYSEXEC library.\n- Copy GDGPH and GDGPP to your ISPF panel library.\n- Copy GDGP00 to your ISPF message library.\n- Install STEMEDIT from CBT file 895.\n- Update the following statement in the GDGP exec to specify the\n  SYSEXEC library where you copied GDGP:\n\n     \"//SYSEXEC   DD DISP=SHR,DSN=dsn.where.GDGP.exists\"\n\n-----------------------------------------------------------------------\n|  HOW IT WORKS:                                                      |\n-----------------------------------------------------------------------\n\nThis REXX EXEC allows the user to do a couple of things:\n\n1.  Create a new GDG if the one specified by the user does not exist;\n    or,\n\n2.  If the GDG does exist, modify the base with the properties\n    specified by the user.\n\nTo modify an existing GDG, the EXEC processes as follows:\n\n1.  If the new limit specified is 255 or less, or the GDG is already\n    defined as NONEXTENDED, then the ALTER command is used to update\n    the GDG.\n\n2.  If the GDG is defined as NONEXTENDED and a limit of greater than\n    255 is requested, the following process is executed:\n\n    a.  Uncatalog each GDS, disassociating it with the base.\n    b.  Delete the GDG base and redefine it with the requested\n        specifications.\n    c.  Re-catalog each GDS, re-associating it with the base.\n\nNOTE:  This process will work with generations on either DASD or tape.\n       However, if the ALTER command cannot be used for the updates\n       (item 2 above is required for processing), this exec will not\n       work with one or more generations that have been archived.\n\nThis REXX EXEC can be run any of 4 ways:\n\n1.  Online displaying a panel.  The panel is displayed when TSO GDGP\n    is invoked without both the GDG base and limit specified.  If\n    either are specified, they will be displayed initially on the\n    panel.\n\n2.  Online without a panel.  If TSO GDGP is invoked with at least the\n    GDG base and limit specified, the panel will not be displayed and\n    and processing will occur with exactly the parameters specified\n    when GDGP was invoked.\n\n3.  In batch from the panel.  On the GDGP panel, specify B (for Batch),\n    and JCL will be displayed which can be submitted to execute the\n    process as a batch job.\n\n4.  As a batch job.  Simply submit the job from your JCL library.\n    Following is sample JCL:\n\n    //GDGP     EXEC PGM=IKJEFT01\n    //SYSEXEC   DD DISP=SHR,DSN=rexx.dsn\n    //SYSTSPRT  DD SYSOUT=*\n    //SYSTSIN   DD *\n    GDGP gdg.base.name limit nscr emp fifo purge\n\n-----------------------------------------------------------------------\n|  PARAMETERS:                                                        |\n-----------------------------------------------------------------------\n\nParameters passed to this program are as follows:\n\nThe following two parameters are required and positional:\n\nBase    1st parameter.  An existing GDG base to be converted or the\n        name of a GDG base to be created.\nLimit   2nd parameter.  The GDG limit for the converted/new GDG base.\n\n        On the panel only, if left blank and the specified GDG base\n        already exists, the current attributes are displayed on the\n        panel.\n\nThe following parameters are all optional and can be entered in any\norder (after the first two required parameters).  See DFSMS Access\nMethod Services Commands for detailed descriptions of each parameter.\n\nSCRATCH/NOSCRATCH  NOSCRATCH is the default.\nEMPTY/NOEMPTY      NOEMPTY is the default.\nFIFO/LIFO          LIFO is the default.\nPURGE/NOPURGE      NOPURGE is the default.  When NOSCRATCH is\n                   specified, NOPURGE is automatically set.\n\nFor new GDGs, the above defaults are taken when nothing is specified.\nFor existing GDGs, the value is not changed if not specified/\noverridden by the user.\n\n-----------------------------------------------------------------------\n|  MEMBERS OF THIS PDS:                                               |\n-----------------------------------------------------------------------\n\n$DOC   - You're reading it!\nGDGP   - The REXX exec\nGDGPH  - Help panel\nGDGPP  - Main panel\nGDGP00 - Messages\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@FILE951": {"ttr": 525, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04a\\x00\\x18\\x01\\x182\\x7f\\x01\\x182\\x7f\\x12@\\x00\\x15\\x00\\x15\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf7@@@'", "ispf": {"version": "04.97", "flags": 0, "createdate": "2018-11-23T00:00:00", "modifydate": "2018-11-23T12:40:18", "lines": 21, "newlines": 21, "modlines": 0, "user": "CBT-497"}, "text": "//***FILE 951 is from Nick Light and contains his tool written      *   FILE 951\n//*           in REXX to either create a new GDG or to modify       *   FILE 951\n//*           the characteristics of an existing GDG.               *   FILE 951\n//*                                                                 *   FILE 951\n//*           email:  nicklight031@gmail.com                        *   FILE 951\n//*                                                                 *   FILE 951\n//*     Short Background...                                         *   FILE 951\n//*                                                                 *   FILE 951\n//*     I created a REXX exec, with a couple of panels and          *   FILE 951\n//*     messages, to convert a GDG to a GDG extended (GDGE).        *   FILE 951\n//*     Converting to a GDGE enables the GDG limit to increase      *   FILE 951\n//*     from a maximum 255 generations to 999 generations.  It      *   FILE 951\n//*     started out as a simple program to do that conversion       *   FILE 951\n//*     in batch, but at Lionel Dyck's prompting, it grew over      *   FILE 951\n//*     several iterations into something that can be used,         *   FILE 951\n//*     online or in batch, to create a new GDG base or modify      *   FILE 951\n//*     an existing GDG base.                                       *   FILE 951\n//*                                                                 *   FILE 951\n//*     (A few corrections were made by Peter Glanzmann.  See       *   FILE 951\n//*     member $$NOTE02 for details.)                               *   FILE 951\n//*                                                                 *   FILE 951\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "GDGP": {"ttr": 527, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x08\\x01\\x16(\\x0f\\x01\\x182\\x7f\\x12%\\x04#\\x04\"\\x00\\x00\\xc7\\xc4\\xc7\\xd7@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2016-10-06T00:00:00", "modifydate": "2018-11-23T12:25:08", "lines": 1059, "newlines": 1058, "modlines": 0, "user": "GDGP"}, "text": " /*------------------------------REXX----------------------------------\n |                                                                    |\n |  PROGRAM ID:  GDGP (GDG Plus).                                     |\n |                                                                    |\n |  FUNCTION:    This REXX EXEC allows the user to do a couple of     |\n |               things:                                              |\n |                                                                    |\n |               1.  Create a new GDG if the one specified by the     |\n |                   user does not exist; or,                         |\n |                                                                    |\n |               2.  If the GDG does exist, modify the base with      |\n |                   the properties specified by the user.            |\n |                                                                    |\n |               To modify an existing GDG, the EXEC processes as     |\n |               follows:                                             |\n |                                                                    |\n |               1.  If the new limit specified is 255 or less, or    |\n |                   the GDG is already defined as NONEXTENDED, then  |\n |                   the ALTER command is used to update the GDG.     |\n |                                                                    |\n |               2.  If the GDG is defined as NONEXTENDED and a       |\n |                   limit of greater than 255 is requested, the      |\n |                   following process is executed:                   |\n |                                                                    |\n |                   a.  Uncatalog each GDS, disassociating it with   |\n |                       the base.                                    |\n |                   b.  Delete the GDG base and redefine it with     |\n |                       the requested specifications.                |\n |                   c.  Re-catalog each GDS, re-associating it with  |\n |                       the base.                                    |\n |                                                                    |\n |               NOTE:  This process will work with generations on    |\n |                      either DASD or tape.  However, if the ALTER   |\n |                      command cannot be used for the updates        |\n |                      (item 2 above is required for processing),    |\n |                      this EXEC will not work with one or more      |\n |                      generations that have been archived.          |\n |                                                                    |\n |               This REXX EXEC can be run any of 4 ways:             |\n |                                                                    |\n |               1.  Online displaying a panel.  The panel is         |\n |                   displayed when TSO GDGP is invoked without       |\n |                   both the GDG base and limit specified.  If       |\n |                   either are specified, they will be displayed     |\n |                   on the panel.                                    |\n |                                                                    |\n |               2.  Online without a panel.  If TSO GDGP is          |\n |                   invoked with at least the GDG base and limit     |\n |                   specified, the panel will not be displayed       |\n |                   and processing will occur with exactly the       |\n |                   parameters specified when GDGP was invoked.      |\n |                                                                    |\n |               3.  In batch from the panel.  On the GDGP panel,     |\n |                   specify B (for Batch), and JCL will be           |\n |                   displayed which can be submitted to execute      |\n |                   the process as a batch job.                      |\n |                                                                    |\n |               4.  As a batch job.  Simply submit the job from      |\n |                   your JCL library.  Following is sampel JCL:      |\n |                                                                    |\n |                   //GDGP     EXEC PGM=IKJEFT01                     |\n |                   //SYSEXEC   DD DISP=SHR,DSN=rexx.dsn             |\n |                   //SYSTSPRT  DD SYSOUT=*                          |\n |                   //SYSTSIN   DD *                                 |\n |                   GDGP gdg.base.name limit nscr emp fifo purge     |\n |                                                                    |\n |  INPUT:       N/A.  See Parameters below.                          |\n |                                                                    |\n |  PARAMETERS:  Parameters passed to this program are as follows:    |\n |                                                                    |\n |               The following two parameters are required and        |\n |               positional:                                          |\n |                                                                    |\n |               Base    1st parameter.  An existing GDG base to be   |\n |                       converted or the name of a GDG base to be    |\n |                       created.                                     |\n |               Limit   2nd parameter.  The GDG limit for the        |\n |                       converted/new GDG base.                      |\n |                                                                    |\n |                       On the panel only, if left blank and the     |\n |                       specified GDG base already exists, the       |\n |                       current attributes are displayed on the      |\n |                       panel.                                       |\n |                                                                    |\n |               The following parameters are all optional and can    |\n |               be entered in any order (after the first two         |\n |               required parameters).  See DFSMS Access Method       |\n |               Services Commands for detailed descriptions of       |\n |               each parameter.                                      |\n |                                                                    |\n |               SCRATCH/NOSCRATCH  NOSCRATCH is the default.         |\n |               EMPTY/NOEMPTY      NOEMPTY is the default.           |\n |               FIFO/LIFO          LIFO is the default.              |\n |               PURGE/NOPURGE      NOPURGE is the default.           |\n |                                  When NOSCRATCH is specified,      |\n |                                  NOPURGE is automatically set.     |\n |                                                                    |\n |               For new GDGs, the above defaults are taken when      |\n |               nothing is specified.  For existing GDGs, the        |\n |               value is not changed if not specified/overridden     |\n |               by the user.                                         |\n |                                                                    |\n |  OUTPUT:      Output from this exec is the converted/new GDG.      |\n |                                                                    |\n |--------------------------------------------------------------------|\n |  MAINTENANCE LOG:                                                  |\n |--------------------------------------------------------------------|\n |                                                                    |\n |  ID      DATE                     MODIFICATION                     |\n |  ---   --------   -----------------------------------------------  |\n |  nel   10/06/16   Created this REXX EXEC.                          |\n |        11/23/18   Errors fixed by Peter Glanzmann                  |\n |                                                                    |\n --------------------------------------------------------------------*/\n\n parse upper arg gdgbase limit parm.1 parm.2 parm.3 parm.4\n\n call CHECK_MSGID\n\n exitrc = 0      /*  Initialize EXITRC  */\n\n /*--------------------------------------------------------------------\n |  Determine if this is being run online or in batch.                |\n --------------------------------------------------------------------*/\n\n /*  PROCOPT (PROCessing OPTion).  Process...                        */\n /*       J - as a batch job                                         */\n /*       N - Online w/o panel (GDGBASE and LIMIT were provided)     */\n /*       O - Online after panel displayed                           */\n /*       B - In batch after panel displayed                         */\n\n online = sysvar(sysispf)\n\n /*  Invoked online in ISPF:  */\n if online = 'ACTIVE' then do\n\n     /*  If both of the required parameters are entered,  */\n     /*  then simply process the request.  However, if    */\n     /*  either parameter is missing, display the panel.  */\n     if gdgbase = '' | limit = '' then do\n\n         /*  Set default of \"Process Online\" on panel:  */\n         procopt = 'O'\n\n         do forever\n             \"ISPEXEC DISPLAY PANEL(GDGPP)\"\n\n             gdgbase_save = gdgbase\n\n             /*  If F3, then exit  */\n             if rc > 0 then do\n                 call EXIT_PROCESSING\n             end\n\n             call DATASET_CHECK\n\n             if exitrc \\= 8 then do\n\n                 /*  If user specified \"Batch\" on panel:  */\n                 if procopt = 'B' then do\n                     if scratch = '@DFL' then scratch = ''\n                     if empty   = '@DFL' then empty   = ''\n                     if fifo    = '@DFL' then fifo    = ''\n                     if purge   = '@DFL' then purge   = ''\n\n                     call PROCESS_IN_BATCH\n                 end\n                 else do\n                     call MAIN_PROCESSING\n                 end\n             end\n\n             /*  Re-initialize variables for next panel display:  */\n             if exitrc = 0 then do\n\n                 gdgbase = ''\n                 limit   = ''\n                 scratch = ''\n                 empty   = ''\n                 fifo    = ''\n                 purge   = ''\n             end\n             else do\n                 if scratch = '@DFL' then scratch = ''\n                 if empty   = '@DFL' then empty   = ''\n                 if fifo    = '@DFL' then fifo    = ''\n                 if purge   = '@DFL' then purge   = ''\n\n                 exitrc  = 0\n                 gdgbase = gdgbase_save\n             end\n         end\n     end\n\n     /*  Process online w/o panel:  */\n     else do\n         procopt = 'N'\n\n         /*  Clear the screen:  */\n         \"CLEAR 0\"\n     end\n end\n\n /*  Invoked in a batch job:  */\n else do\n     procopt = 'J'\n end\n\n /*  Processing for online w/o panel and invoked in a batch job:  */\n if exitrc \\= 8 then call DATASET_CHECK\n if exitrc \\= 8 then call PROCESS_PARMS\n if exitrc \\= 8 then call MAIN_PROCESSING\n\n call EXIT_PROCESSING\n\n /*--------------------------------------------------------------------\n |  Main Processing:  If executed by a batch job or processed online  |\n |                    from the panel.                                 |\n --------------------------------------------------------------------*/\n\n MAIN_PROCESSING:\n\n call INITIALIZE_REPORT_PROCESSING\n\n call CAPTURE_LISTCAT\n\n /*--------------------------------------------------------------------\n |  Validate the GDG passed to the EXEC.                              |\n |  1.  If the entry does not exist, create a new GDG base and        |\n |      end the program (RC 0).                                       |\n |  2.  If it is a valid dataset but not a GDG, write an error and    |\n |      end the program (RC 8).                                       |\n --------------------------------------------------------------------*/\n\n if word(lgdg.1,1) \u00ac= 'GDG' then do\n\n     /*  Alloc a new GDG base for a GDG  */\n     /*  that did not already exist:     */\n     if word(lgdg.1,1) = 'IDC3012I' then do\n         call CREATE_NEW_GDG\n     end\n\n     /*  ERROR - dataset specified is valid but not a GDG:  */\n     else do\n         if procopt = 'J' | procopt = 'N' then do\n             say\n             say '****************************************************'\n             say '*  DATASET MUST BE A GDG BASE!                     *'\n             say '****************************************************'\n             say\n         end\n\n         \"ISPEXEC SETMSG MSG(GDGP005)\"\n         exitrc = 8\n     end\n end\n\n /*--------------------------------------------------------------------\n |  The GDG passed to the EXEC is valid, keep processing...           |\n --------------------------------------------------------------------*/\n\n else do\n\n     /*----------------------------------------------------------------\n     |  Get the previously defined GDG base properties for the post-  |\n     |  processing report.                                            |\n     ----------------------------------------------------------------*/\n\n     gdsct = 0       /*  GDS counter     */\n     l     = 26      /*  report counter  */\n\n     do i=1 to lgdg.0\n         if substr(word(lgdg.i,1),1,5) = 'LIMIT' then do\n             report.11 = '  GDG base previously defined with the',\n                         'following properties:'\n             report.12 = '  ----------------------------------'||,\n                         '------------------------'\n             report.13 = '      ' gdgbase\n             report.14 = lgdg.i\n             report.15 = ''\n             report.16 = ''\n\n             extended = word(lgdg.i,6)\n         end\n\n         if word(lgdg.i,1) = 'NONVSAM' then do\n             gdsct = gdsct + 1\n\n             l = l + 1\n             report.l = '      ' left(word(lgdg.i,3),44)\n         end\n     end\n\n     l = l + 1\n     report.l = ''\n\n     report.0 = l\n\n     /*  Save the current attributes:  */\n     cur_limit   = strip(substr(word(report.14,1),23,3),'l','-')\n     cur_scratch = word(report.14,2)\n     cur_empty   = word(report.14,3)\n     cur_fifo    = word(report.14,4)\n     cur_purge   = word(report.14,5)\n\n     select\n\n         /*------------------------------------------------------------\n         |  If none of the attributes have changed, don't redefine    |\n         |  the GDG base.                                             |\n         ------------------------------------------------------------*/\n\n         when limit   = cur_limit                        &,\n              (scratch = cur_scratch | scratch = '@DFL') &,\n              (empty   = cur_empty   | empty   = '@DFL') &,\n              (fifo    = cur_fifo    | fifo    = '@DFL') &,\n              (purge   = cur_purge   | purge   = '@DFL') then do\n             if procopt = 'J' | procopt = 'N' then do\n                 say\n                 say '************************************************'\n                 say '*  No attributes have been changed.  GDG base  *'\n                 say '*  not modified.                               *'\n                 say '************************************************'\n                 say\n             end\n             else do\n                 \"ISPEXEC SETMSG MSG(GDGP007)\"\n             end\n\n             exitrc = 8\n         end\n\n         /*------------------------------------------------------------\n         |  If no LIMIT was specified (which can only happen from     |\n         |  the panel), display all of the current attributes on the  |\n         |  panel.                                                    |\n         ------------------------------------------------------------*/\n\n         when limit = '' then do\n             limit   = cur_limit\n             scratch = cur_scratch\n             empty   = cur_empty\n             fifo    = cur_fifo\n             purge   = cur_purge\n\n             exitrc = 8\n         end\n\n         /*------------------------------------------------------------\n         |  If the GDG limit specified is less than than the number   |\n         |  of existing generations, terminate processing.            |\n         ------------------------------------------------------------*/\n\n         when limit < gdsct then do\n             if procopt = 'J' | procopt = 'N' then do\n                 say\n                 say '************************************************'\n                 say '*  Specified limit is smaller than the number  *'\n                 say '*  of existing GDSs.  Request terminated.      *'\n                 say '************************************************'\n                 say\n             end\n             else do\n                 \"ISPEXEC SETMSG MSG(GDGP002)\"\n             end\n\n             exitrc = 8\n         end\n\n         /*------------------------------------------------------------\n         |  SHORTCUT:  If the specified LIMIT is 255 or less, or the  |\n         |  GDG base is already EXTENDED, just use ALTER.             |\n         ------------------------------------------------------------*/\n\n         when limit <= 255 | extended = 'EXTENDED' then do\n             call ALTER_GDG_BASE\n         end\n\n         /*------------------------------------------------------------\n         |  Unable to ALTER the GDG base, which means the GDG base    |\n         |  was defined as NONEXTENDED and the user wants a LIMIT of  |\n         |  more than 255.  We will need to uncatalog all of the      |\n         |  GDSs, delete the old GDG base, define it with the new     |\n         |  specifications, and re-catalog the GDSs, re-associating   |\n         |  them with the base.                                       |\n         ------------------------------------------------------------*/\n\n         otherwise do\n\n             call CREATE_STATEMENTS   /* To uncatalog & catalog GDSs */\n\n             if exitrc = 0 then do\n                 call UNCAT_GENERATION_DATASETS\n                 call CAPTURE_LISTCAT\n                 call DELETE_AND_REDEFINE_GDG_BASE\n                 call RECAT_GENERATION_DATASETS\n                 call WRITE_POST_PROCESSING_REPORT\n             end\n         end\n     end\n end\n\n return\n\n /*--------------------------------------------------------------------\n |  - - - - - - - - - -  INTERNAL REXX ROUTINES  - - - - - - - - - -  |\n --------------------------------------------------------------------*/\n\n /*--------------------------------------------------------------------\n |  Check the caller's TSO profile to see if MSGID/NOMSGID is set.    |\n |  If NOMSGID, then change to MSGID and and set USER_MSGID to FALSE  |\n |  (0).  This will be set back to NOMSGID when exiting the program.  |\n --------------------------------------------------------------------*/\n\n CHECK_MSGID:\n\n x = outtrap(\"lprof.\",\"*\",\"CONCAT\")\n \"PROFILE\"\n\n user_msgid = 1\n\n do i=1 to words(lprof.1)\n     if word(lprof.1,i) = 'NOMSGID' then do\n         user_msgid = 0\n         \"PROF MSGID\"\n     end\n end\n\n return\n\n /*--------------------------------------------------------------------\n |  Verify the validity of the GDG being processed.                   |\n --------------------------------------------------------------------*/\n\n DATASET_CHECK:\n\n /*  If dataset has quotes, strip them off and process  */\n /*  the dataset as it is.  If it has no quotes,        */\n /*  prepend the userid:                                */\n if left(gdgbase,1) = \"'\" then do\n     gdgbase = strip(gdgbase,b,\"'\")\n end\n else if sysvar('syspref')   \\= null    &,\n         substr(gdgbase,1,7) \\= sysvar('sysuid') then do\n     gdgbase = sysvar('syspref')||'.'||gdgbase\n end\n\n if length(gdgbase) > 35 then do\n     if procopt = 'O' then do\n         \"ISPEXEC SETMSG MSG(GDGP003)\"\n     end\n     else do             /*  procopt = 'N' | 'J'  */\n         say\n         say '****************************************************'\n         say '*  GDG BASE SPECIFIED EXCEEDS 35 CHARACTERS!       *'\n         say '****************************************************'\n         say\n     end\n\n     exitrc = 8\n end\n\n return\n\n /*--------------------------------------------------------------------\n |  The Batch option was selected from the online panel.  Do the      |\n |  following:                                                        |\n |                                                                    |\n |  1.  Create a temporary dataset with JCL for the user to submit.   |\n |  2.  When the user backs out of the JCL, free/delete the file.     |\n |  3.  Exit the program.                                             |\n |                                                                    |\n --------------------------------------------------------------------*/\n\n PROCESS_IN_BATCH:\n\n j = 0\n\n /*  Ensure dataset name is unique:  */\n do until i = 'DATASET NOT FOUND'\n     j = j + 1\n\n     dsn1 = userid()'.TMP@.G2GE00'j\n\n     i = sysdsn(\"'\"dsn1\"'\")\n end\n\n /*  Create and allocate the temp dataset:  */\n \"ALLOC DA('\"dsn1\"') FI(FILEI) SP(10 1) TR LRECL(80)\",\n \"BLKSIZE(6480) RECFM(F B) DSORG(PS) UNIT(SYSDA) REUSE\"\n\n /*  Write the JCL to the temporary dataset:  */\n queue '//JOBCARD HERE                                              '\n queue '//*                                                         '\n queue '//GDGP     EXEC PGM=IKJEFT01                                '\n queue '//SYSEXEC   DD DISP=SHR,DSN=dsn.where.GDGP.exists           '\n queue '//SYSTSPRT  DD SYSOUT=*                                     '\n queue '//SYSTSIN   DD *                                            '\n queue 'GDGP' gdgbase limit empty scratch fifo purge\n queue '//*                                                         '\n\n 'EXECIO' queued() 'DISKW FILEI (FINIS)'\n\n /*  Edit the JCL:  */\n \"ISPEXEC EDIT DATASET('\"dsn1\"')\"\n\n /*  Free/delete the temporary dataset:  */\n x = MSG(\"OFF\")\n\n \"FREE DSNAME('\"dsn1\"') DELETE\"\n if rc = 12 then do\n     \"DELETE '\"dsn1\"'\"\n end\n\n x = MSG(\"ON\")\n\n return\n\n /*--------------------------------------------------------------------\n |  Process parameters from processing other than from the panel.     |\n --------------------------------------------------------------------*/\n\n PROCESS_PARMS:\n\n /*  Default values of optional parms:  */\n empty   = '@DFL'\n fifo    = '@DFL'\n purge   = '@DFL'\n scratch = '@DFL'\n\n /*  Set flags to FALSE:  */\n eset = 0\n fset = 0\n pset = 0\n sset = 0\n\n /*  Validate parameters and assign values:  */\n do i=1 to 4 until exitrc = 8\n     select\n         when parm.i = '' then do\n             nop\n         end\n         when parm.i = 'EXTENDED' | parm.i = 'NOEXTENDED' then do\n             nop\n         end\n         when parm.i = 'EMPTY' | parm.i = 'NOEMPTY' then do\n             if eset then do\n                 say\n                 say '************************************************'\n                 say '*  EMPTY/NOEMPTY MAY ONLY BE SPECIFIED ONCE!   *'\n                 say '************************************************'\n                 say\n\n                 exitrc = 8\n             end\n\n             eset  = 1\n             empty = parm.i\n         end\n         when parm.i = 'FIFO' | parm.i = 'LIFO' then do\n             if fset then do\n                 say\n                 say '************************************************'\n                 say '*  FIFO/LIFO MAY ONLY BE SPECIFIED ONCE!       *'\n                 say '************************************************'\n                 say\n\n                 exitrc = 8\n             end\n\n             fset = 1\n             fifo = parm.i\n         end\n         when parm.i = 'PURGE' | parm.i = 'NOPURGE' then do\n             if pset then do\n                 say\n                 say '************************************************'\n                 say '*  PURGE/NOPURGE MAY ONLY BE SPECIFIED ONCE!   *'\n                 say '************************************************'\n                 say\n\n                 exitrc = 8\n             end\n\n             pset = 1\n             purge = parm.i\n         end\n         when parm.i = 'SCRATCH' | parm.i = 'NOSCRATCH' then do\n             if sset then do\n                 say\n                 say '************************************************'\n                 say '*  SCRATCH/NOSCR MAY ONLY BE SPECIFIED ONCE!   *'\n                 say '************************************************'\n                 say\n\n                 exitrc = 8\n             end\n\n             sset    = 1\n             scratch = parm.i\n         end\n         otherwise do\n             say\n             say '****************************************************'\n             say '*  INVALID PARAMETERS - ENDING PROGRAM!            *'\n             say '****************************************************'\n             say\n\n             exitrc = 8\n         end\n     end\n end\n\n /*  Initialize the INVALID_LIMIT flag to FALSE (0):  */\n invalid_limit = 0\n\n /*  Ensure each digit of the LIMIT is numeric:  */\n do i=1 to length(limit)\n     if substr(limit,i,1) < 0 | substr(limit,i,1) > 9 then do\n         invalid_limit = 1\n     end\n end\n\n /*  The limit can't be more than 3 digits (999):  */\n if length(limit) > 3 then do\n     invalid_limit = 1\n end\n\n /*  LIMIT must be 1-999:  */\n if invalid_limit & exitrc = 0 then do\n     say\n     say '****************************************************'\n     say '*  INVALID LIMIT PARAMETER - MUST BE 1-999!        *'\n     say '****************************************************'\n     say\n\n     exitrc = 8\n end\n\n /*  LIMIT must be an integer:  */\n if pos('.',limit) > 0 & exitrc = 0 then do\n     say\n     say '****************************************************'\n     say '*  LIMIT PARAMETER MUST BE AN INTEGER!             *'\n     say '****************************************************'\n     say\n\n     exitrc = 8\n end\n\n return\n\n /*--------------------------------------------------------------------\n |  Initialize the REPORT STEM variable.                              |\n --------------------------------------------------------------------*/\n\n INITIALIZE_REPORT_PROCESSING:\n\n drop report.\n\n curdate = date('u')\n curtime = time()\n\n report.1 = ''\n report.2 = ''\n report.3 = '                          GDGP Post-Processing Report',\n            '                ' curdate\n report.4 = '                          ---------------------------',\n            '                ' curtime\n report.5 = ''\n report.6 = '  Parameters:'\n report.7 = '  -----------'\n report.8 = '      ' gdgbase '' limit ' '\n\n if scratch \\= '@DFL' then report.8 = report.8||left(scratch,11)\n if empty   \\= '@DFL' then report.8 = report.8||left(empty,11)\n if fifo    \\= '@DFL' then report.8 = report.8||left(fifo,11)\n if purge   \\= '@DFL' then report.8 = report.8||left(purge,11)\n\n report.9  = ''\n report.10 = ''\n\n return\n\n /*--------------------------------------------------------------------\n |  Capture a LISTCAT of the GDG base in the LGDG stem variable.      |\n --------------------------------------------------------------------*/\n\n CAPTURE_LISTCAT:\n\n drop lgdg.\n\n x = outtrap(\"lgdg.\",'*',\"CONCAT\")\n \"LISTCAT ENT('\"gdgbase\"') ALL\"\n\n return\n\n /*--------------------------------------------------------------------\n |  Create a new GDG base - the one specified does not exist.         |\n --------------------------------------------------------------------*/\n\n CREATE_NEW_GDG:\n\n /*  Set the default values for the parameters  */\n /*  that were not explicitly specified:        */\n if empty   = '@DFL' then empty   = 'NOEMPTY'\n if fifo    = '@DFL' then fifo    = 'LIFO'\n if purge   = '@DFL' then purge   = 'NOPURGE'\n if scratch = '@DFL' then scratch = 'NOSCRATCH'\n\n /*  Check for LIMIT not passed to the program (this can only   */\n /*  occur from the panel).  If no limit, return to the panel   */\n /*  and display an error message:                              */\n if limit = '' then do\n     \"ISPEXEC SETMSG MSG(GDGP006)\"\n     exitrc = 8\n end\n else do\n     \"DEFINE GDG (NAME('\"gdgbase\"')\",\n     \"LIMIT(\"limit\")\",\n     \"EXTENDED\" empty fifo purge scratch\n\n     x = outtrap(\"lgdn.\",'*',\"CONCAT\")\n     \"LISTCAT ENT('\"gdgbase\"') ALL\"\n\n     do i=1 to lgdn.0\n         if substr(word(lgdn.i,1),1,5) = 'LIMIT' then do\n             report.11 = '  New GDG base defined as follows:'\n             report.12 = '  --------------------------------'\n             report.13 = '      ' gdgbase\n             report.14 = lgdn.i\n             report.15 = ''\n\n             report.0  = 15\n         end\n     end\n\n     if procopt = 'J' | procopt = 'N' then do\n         do i=1 to report.0\n             say report.i\n         end\n     end\n     else do\n         call STEMEDIT 'browse','report.'\n     end\n end\n\n return\n\n /*--------------------------------------------------------------------\n |  Use ALTER to update the GDG properties.                           |\n --------------------------------------------------------------------*/\n\n ALTER_GDG_BASE:\n\n /*  Set the default values for the parameters that were not     */\n /*  explicitly overridden with the values of the old GDG base:  */\n do i=1 to 10\n     if substr(word(lgdg.i,1),1,5) = 'LIMIT' then do\n         if scratch = '@DFL' then scratch = word(lgdg.i,2)\n         if empty   = '@DFL' then empty   = word(lgdg.i,3)\n         if fifo    = '@DFL' then fifo    = word(lgdg.i,4)\n         if purge   = '@DFL' then purge   = word(lgdg.i,5)\n     end\n end\n\n /*  ALTER does not allow NSCR to be specified if PURGE     */\n /*  is already specified.  Likewise, ALTER does not allow  */\n /*  PURGE to be specified if NSCR is already specified.    */\n /*  Since NOPURGE is set if NOSCRATCH is specified         */\n /*  regardless of the PURGE specification when defining a  */\n /*  new GDG, we're just going to do the same with ALTER:   */\n if scratch = 'NOSCRATCH' then do\n     purge = 'NOPURGE'\n end\n\n /*  Use IDCAMS to do the ALTER (it works better than   */\n /*  TSO).  Allocate the necessary files and write the  */\n /*  ALTER statement to SYSIN with EXECIO:              */\n 'ALLOC F(SYSPRINT) SPA(10,1) TR RECFM(F B)',\n       'LRECL(80) BLKSIZE(80) REUSE'\n 'ALLOC F(SYSIN) SPA(1,1) TR RECFM(F B)',\n       'LRECL(80) BLKSIZE(80) REUSE'\n\n si.1 = \" ALTER '\"gdgbase\"' LIMIT(\"limit\")\",\n        scratch empty fifo purge\n si.0 = 1\n\n 'EXECIO * DISKW SYSIN (FINIS STEM si.)'\n\n address linkmvs 'IDCAMS'\n\n /*  Set things back to the way they were:  */\n address\n 'FREE F(SYSPRINT)'\n 'FREE F(SYSIN)'\n\n call CAPTURE_LISTCAT\n\n l = 26\n\n do i=1 to lgdg.0\n     if substr(word(lgdg.i,1),1,5) = 'LIMIT' then do\n         report.17 = '  GDG base has been ALTERed with the following',\n                     'properties:'\n         report.18 = '  ------------------------------------------'||,\n                     '--------------'\n         report.19 = '      ' gdgbase\n         report.20 = lgdg.i\n         report.21 = ''\n         report.22 = ''\n     end\n\n     if word(lgdg.i,1) = 'NONVSAM' then do\n         l = l + 1\n         if word(report.l,1) = word(lgdg.i,3) then do\n             report.l = report.l||' - Still intact'\n         end\n     end\n end\n\n report.23 = '  Generations associated with ALTERed base:'\n report.24 = ''\n report.25 = '       Generations Prior to Processing'\n report.26 = '       --------------------------------------------'\n\n if procopt = 'J' | procopt = 'N' then do\n     do i=1 to report.0\n         say report.i\n     end\n end\n else do\n     call STEMEDIT 'browse','report.'\n end\n\n return\n\n /*--------------------------------------------------------------------\n |  Create statements to uncatalog (in the UNCAT stem variable) and   |\n |  catalog (in the CAT stem variable) each GDS.                      |\n --------------------------------------------------------------------*/\n\n CREATE_STATEMENTS:\n\n j = 0\n\n do i=1 to lgdg.0\n     if word(lgdg.i,1) = 'NONVSAM' then do\n         j = j + 1\n\n         uncat.j = \" DEL '\"word(lgdg.i,3)\"' NOSCRATCH\"\n         cat.j   = \" DEF NVSAM(NAME('\"word(lgdg.i,3)\"')\"\n     end\n\n     /*  Finish the statement to re-catalog the GDS:  */\n     if substr(word(lgdg.i,1),1,6) = 'VOLSER' then do\n         call GET_DEVICE_TYPE\n\n         if devtype = '????' then do\n             if procopt = 'J' | procopt = 'N' then do\n                 say\n                 say '************************************************'\n                 say '*  At least one GDS resides on an unsupported  *'\n                 say '*  device.  Request terminated.                *'\n                 say '************************************************'\n                 say\n             end\n             else do\n                 \"ISPEXEC SETMSG MSG(GDGP004)\"\n             end\n\n             exitrc = 8\n        /*   exitrc = 8; call EXIT_PROCESSING      */\n         end\n\n         cat.j = cat.j 'DEVT('devtype')',\n                       'VOL('substr(word(lgdg.i,1),19,6)') RECATALOG)'\n     end\n end\n\n uncat.0 = j\n cat.0   = j\n\n return\n\n /*--------------------------------------------------------------------\n |  Get the device type of a GDS.                                     |\n --------------------------------------------------------------------*/\n\n GET_DEVICE_TYPE:\n\n devtyp34 = substr(word(lgdg.i,2),20,4)\n\n select\n     when devtyp34 = '2004' then devtype = '9345'   /*  DISK  */\n     when devtyp34 = '200C' then devtype = '3375'   /*  DISK  */\n     when devtyp34 = '200E' then devtype = '3380'   /*  DISK  */\n     when devtyp34 = '200F' then devtype = '3390'   /*  DISK  */\n     when devtyp34 = '200A' then devtype = '3340'   /*  DISK  */\n     when devtyp34 = '2009' then devtype = '3330'   /*  DISK  */\n     when devtyp34 = '200D' then devtype = '3330-1' /*  DISK  */\n     when devtyp34 = '200B' then devtype = '3350'   /*  DISK  */\n     when devtyp34 = '2008' then devtype = '2314'   /*  DISK  */\n     when devtyp34 = '8003' then devtype = '3420'   /*  TAPE  */\n     when devtyp34 = '8003' then devtype = '3420'   /*  TAPE  */\n     when devtyp34 = '8003' then devtype = '3420'   /*  TAPE  */\n     when devtyp34 = '8003' then devtype = '3420'   /*  TAPE  */\n     when devtyp34 = '8080' then devtype = '3480'   /*  TAPE  */\n     when devtyp34 = '8080' then devtype = '3480X'  /*  TAPE  */\n     when devtyp34 = '8081' then devtype = '3490'   /*  TAPE  */\n     when devtyp34 = '8083' then devtype = '3590-1' /*  TAPE  */\n     otherwise  devtype = '????'\n end\n\n return\n\n /*--------------------------------------------------------------------\n |  Uncatalog all of the GDS datasets, seperating them from the GDG   |\n |  base.                                                             |\n --------------------------------------------------------------------*/\n\n UNCAT_GENERATION_DATASETS:\n\n if procopt = 'J' | procopt = 'N' then do\n     say 'Uncataloging the GDSs, separating them from the base...'\n end\n else do\n     _tmpgdg = gdgbase\n\n     /*  Display the In-Progress message while searching:  */\n     \"ISPEXEC CONTROL DISPLAY LOCK\"\n     \"ISPEXEC DISPLAY MSG(GDGP001) MSGLOC(PURGE)\"\n\n     gdgbase = _tmpgdg\n end\n\n /*  Uncatalog each of the GDSs:  */\n do i=1 to uncat.0\n     uncat.i\n end\n\n return\n\n /*--------------------------------------------------------------------\n |  Delete the existing GDG base and allocate a new one.              |\n --------------------------------------------------------------------*/\n\n DELETE_AND_REDEFINE_GDG_BASE:\n\n if procopt = 'J' | procopt = 'N' then do\n     say 'Deleting & Redefining the GDG base...'\n end\n\n /*  Set the default values for the parameters that were not     */\n /*  explicitly overridden with the values of the old GDG base:  */\n do i=1 to 10\n     if substr(word(lgdg.i,1),1,5) = 'LIMIT' then do\n         if scratch = '@DFL' then scratch = word(lgdg.i,2)\n         if empty   = '@DFL' then empty   = word(lgdg.i,3)\n         if fifo    = '@DFL' then fifo    = word(lgdg.i,4)\n         if purge   = '@DFL' then purge   = word(lgdg.i,5)\n     end\n end\n\n /*  Delete and redefine the GDG base:  */\n do i=1 to lgdg.0\n     if word(lgdg.i,2) = 'BASE' then do\n\n         /*  Delete the old GDG base:  */\n         \"DELETE '\"word(lgdg.i,4)\"' GDG FORCE\"\n\n         /*  Allocate the new GDG base:  */\n         \"DEFINE GDG (NAME('\"word(lgdg.i,4)\"')\",\n         \"LIMIT(\"limit\")\",\n         \"EXTENDED\" scratch empty fifo purge\n     end\n end\n\n return\n\n /*--------------------------------------------------------------------\n |  Re-catalog the GDS datasets, re-associating them with the GDG     |\n |  base.                                                             |\n --------------------------------------------------------------------*/\n\n RECAT_GENERATION_DATASETS:\n\n if procopt = 'J' | procopt = 'N' then do\n     say 'Re-cataloging the GDSs, re-associating them with the base...'\n end\n\n /*  Recatalog each of the GDSs:  */\n do i=1 to cat.0\n     cat.i\n end\n\n return\n\n /*--------------------------------------------------------------------\n |  Get the newly defined GDG base properties, wrap up the post-      |\n |  processing report, and write it out.                              |\n --------------------------------------------------------------------*/\n\n WRITE_POST_PROCESSING_REPORT:\n\n call CAPTURE_LISTCAT\n\n l = 26\n\n do i=1 to lgdg.0\n     if substr(word(lgdg.i,1),1,5) = 'LIMIT' then do\n         report.17 = '  GDG base has been redefined with the following',\n                     'properties:'\n         report.18 = '  --------------------------------------------'||,\n                     '--------------'\n         report.19 = '      ' gdgbase\n         report.20 = lgdg.i\n         report.21 = ''\n         report.22 = ''\n     end\n\n     if word(lgdg.i,1) = 'NONVSAM' then do\n         l = l + 1\n         if word(report.l,1) = word(lgdg.i,3) then do\n             report.l = report.l||' - Processed successfully'\n         end\n     end\n end\n\n report.23 = '  All generations have been successfully processed:'\n report.24 = ''\n report.25 = '       Generations Prior to Processing'\n report.26 = '       --------------------------------------------'\n\n if procopt = 'J' | procopt = 'N' then do\n     do i=1 to report.0\n         say report.i\n     end\n end\n else do\n     call STEMEDIT 'browse','report.'\n end\n\n return\n\n /*--------------------------------------------------------------------\n |  Exit Processing.                                                  |\n --------------------------------------------------------------------*/\n\n EXIT_PROCESSING:\n\n /*  If the user had NOMSGID specified on entry to this program,  */\n /*  then set their profile back to NOMSGID:                      */\n if user_msgid = 0 then do\n     \"PROF NOMSGID\"\n end\n\n exit exitrc\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "GDGPH": {"ttr": 1029, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x06\\x01\\x16(\\x0f\\x01\\x16(\\x0f\\x15Q\\x00<\\x00<\\x00\\x00\\xc7\\xc4\\xc7\\xd7@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-10-06T00:00:00", "modifydate": "2016-10-06T15:51:06", "lines": 60, "newlines": 60, "modlines": 0, "user": "GDGP"}, "text": ")Attr Default(%+_)\n\n     /*---------------------------------------------------------------\n     /*  Panel:        GDGPH                                         |\n     /*  Description:  GDG Plus help panel                           |\n     /*                                                              |\n     /*                                                              |\n     /*  History of Modifications:                                   |\n     /*                                                              |\n     /*  ID      DATE                   MODIFICATION                 |\n     /*  ---   --------   -----------------------------------------  |\n     /*  nel   09/27/16   Created this panel.                        |\n     /*                                                              |\n     /*---------------------------------------------------------------\n\n   # type(text)  color(green) skip(on)\n   $ type(text)  color(yellow)\n   @ type(input) intens(high)\n   ! area(scrl)   extend(on)\n   /*  \u00ac type(input) color(white) hilite(uscore)\n\n)Body expand(\u00ac\u00ac)\n+Tutorial  \u00ac-\u00ac  GDG Plus  \u00ac-\u00ac  Tutorial+\n%Command ===>@zcmd                                                             +\n+\n!area1 -----------------------------------------------------------------------!\n+\n+\n+                   When done viewing this panel, press$<F3>.\n)Area area1 depth(5)\n%  Create a new GDG or modify an existing GDG.\n+\n+  NOTE:  This process will work regardless of the device of the GDSs\n+         when a limit of 255 or less is specified%OR+the existing GDG\n+         is already EXTENDED.  However, for GDGs that are NONEXTENDED\n%         AND+a limit greater than 255 is specified, the process will\n+         terminate if one or more GDS is archived.\n+\n%  Required/positional parameters:\n+\n%  Base  + 1st parameter.  An existing GDG base to be converted or\n+          the name of a GDG base to be created.\n%  Limit + 2nd parameter.  The GDG limit for the converted/new GDG base.\n%          On the panel only,+if left blank and the specified GDG base\n+          already exists, the current attributes are displayed on the\n+          panel.\n+\n%  Optional parameters:\n+\n%  SCRATCH/NOSCRATCH +NOSCRATCH is the default.\n%  EMPTY/NOEMPTY     +NOEMPTY is the default.\n%  FIFO/LIFO         +LIFO is the default.\n%  PURGE/NOPURGE     +NOPURGE is the default.\n+                     When NOSCRATCH is specified,\n+                     NOPURGE is automatically set.\n+\n+  For new GDGs, the above defaults are taken when nothing is specified.\n+  For existing GDGs, the value is not changed if not specified/\n+       overridden by the user.\n)End\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "GDGPP": {"ttr": 1031, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x06\\x01\\x16(\\x0f\\x01\\x16(\\x0f\\x15Q\\x00X\\x00X\\x00\\x00\\xc7\\xc4\\xc7\\xd7@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-10-06T00:00:00", "modifydate": "2016-10-06T15:51:06", "lines": 88, "newlines": 88, "modlines": 0, "user": "GDGP"}, "text": ")Attr Default(%+_)\n\n     /*---------------------------------------------------------------\n     /*  Panel:        GDGPP (GDg Plus)                              |\n     /*  Description:  Panel displayed when the GDGP REXX EXEC       |\n     /*                is executed online                            |\n     /*                                                              |\n     /*  History of Modifications:                                   |\n     /*                                                              |\n     /*  ID      DATE                   MODIFICATION                 |\n     /*  ---   --------   -----------------------------------------  |\n     /*  nel   10/06/16   Created this panel with the GDGP           |\n     /*                   REXX exec.                                 |\n     /*                                                              |\n     /*---------------------------------------------------------------\n\n   \u00a6 type(text)   intens(high)   color(&tleclr)\n   + type(text)   color(blue)    skip(on)\n   $ type(text)   color(yellow)\n   # type(text)   color(green)   skip(on)\n   | type(input)  color(white)   caps(on)       pad(_)\n   @ type(input)  color(red)     caps(on)       pad(_)\n   _ type(input)  intens(high)\n\n)Body expand(**)\n%*-*  GDG Plus  *-*\n%Command ===>_gcmd                                                             +\n\n+GDG Base: |gdgbase                            +\n\n+GDG limit:|z  +                       (Maximum number of generations, 1-999)\n\n\u00a6Optional Parameters:\n\n$ SCRATCH\u00a6/$NOSCRATCH %===>|scratch  +\n\u00a6 -+SCRATCH:   Scratch dataset when uncataloged\n\u00a6 -+NOSCRATCH: Do not scratch dataset when uncataloged\n$ EMPTY\u00a6/$NOEMPTY     %===>|empty  +\n\u00a6 -+EMPTY:   Uncatalog all generations when the limit is reached\n\u00a6 -+NOEMPTY: Uncatalog the oldest generation when the limit is reached\n$ FIFO\u00a6/$LIFO         %===>|fifo+\n\u00a6 -+FIFO: Process oldest to newest\n\u00a6 -+LIFO: Process newest to oldest\n$ PURGE\u00a6/$NOPURGE     %===>|purge  +\n\u00a6 -+PURGE:   Override exp date when SCRATCH specified\n\u00a6 -+NOPURGE: Honor exp date when SCRATCH specified\n\n\u00a6Process Online or in Batch:@z+        (O = Online; B = Batch)\n\n)Init\n\n  .zvars = '(limit procopt)'\n\n  .cursor = gdgbase\n\n  .help = gdgph\n\n)Proc\n\n /*  Specify default values:  */\n &scratch = trans(trunc(&scratch,1) S,SCRATCH N,NOSCRATCH *,*)\n &empty   = trans(trunc(&empty,1) E,EMPTY N,NOEMPTY *,*)\n &fifo    = trans(trunc(&fifo,1) F,FIFO L,LIFO *,*)\n &purge   = trans(trunc(&purge,1) P,PURGE N,NOPURGE *,*)\n\n if (&scratch = '')\n     &scratch = '@DFL'\n if (&empty = '')\n     &empty = '@DFL'\n if (&fifo = '')\n     &fifo = '@DFL'\n if (&purge = '')\n     &purge = '@DFL'\n\n if (&procopt = '')\n     &procopt = 'O'\n\n /*  Verification checking:   */\n ver (&gdgbase,nb,dsnameq)\n ver (&limit,range,1,999)\n ver (&scratch,list,'SCRATCH','NOSCRATCH','@DFL')\n ver (&empty,list,'EMPTY','NOEMPTY','@DFL')\n ver (&fifo,list,'FIFO','LIFO','@DFL')\n ver (&purge,list,'PURGE','NOPURGE','@DFL')\n ver (&procopt,list,B,O)\n\n)End\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "GDGP00": {"ttr": 1034, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x06\\x01\\x16(\\x0f\\x01\\x16(\\x0f\\x15Q\\x00\\x16\\x00\\x16\\x00\\x00\\xc7\\xc4\\xc7\\xd7@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2016-10-06T00:00:00", "modifydate": "2016-10-06T15:51:06", "lines": 22, "newlines": 22, "modlines": 0, "user": "GDGP"}, "text": "GDGP001  '                        ' .HELP = * .TYPE=N .WINDOW=N NOKANA\n'******  Processing Request  ******'\n\nGDGP002  '                        '  .ALARM=YES  .WINDOW=LNORESP\n'The number of active generations must be <= specified GDG '    +\n'limit.  Request terminated.'\n\nGDGP003  '                        '  .ALARM=YES  .WINDOW=LNORESP\n'GDG base specified exceeds 35 characters.  Request terminated.'\n\nGDGP004  '                        '  .ALARM=YES  .WINDOW=LNORESP\n'At least one GDS resides on an unspported device.  Request terminated.'\n\nGDGP005  '                        '  .ALARM=YES  .WINDOW=LNORESP\n'Dataset must be a GDG base.  Request terminated.'\n\nGDGP006  '                        '  .ALARM=YES  .WINDOW=LNORESP\n'GDG is not currently defined.  Limit must be specified.'\n\nGDGP007  '                        '  .ALARM=YES  .WINDOW=LNORESP\n'No attributes have been changed.  GDG base not modified.'\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT951/FILE951.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT951", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}