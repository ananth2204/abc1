{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012032000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 1234506, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 24, "INMDSNAM": "CBT.V500.FILE438.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 1234506, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 1234506, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE438.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x15\\x16'", "DS1TRBAL": "b'9`'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x03+\\x00\\t\\x03-\\x00\\x00\\x00\\x16'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\x10_\\x01\\x02\\x10_!D\\x00\\x0c\\x00\\x0c\\x00\\x00\\xe2\\xc8\\xc9\\xd7\\xc4\\xc1\\xe3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-04-15T00:00:00", "modifydate": "2002-04-15T21:44:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "SHIPDAT"}, "text": "REGULAR CBT TAPE - VERSION 445    FILE:  438\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT445.FILE438\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 115 MEMBERS COUNTED; CUMULATIVE SIZE IS 10,785 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   04/15/02    21:44:20    GMT-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$$STRUC": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\x10_\\x01\\x02\\x10_!C\\x07&\\x07&\\x00\\x00\\xe2\\xe3\\xd9\\xc3\\xd4\\xc1\\xc3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-04-15T00:00:00", "modifydate": "2002-04-15T21:43:00", "lines": 1830, "newlines": 1830, "modlines": 0, "user": "STRCMAC"}, "text": "./ ADD NAME=$$$#DATE 0100-02105-02105-2142-00012-00012-00000-SHIPDAT\nREGULAR CBT TAPE - VERSION 445    FILE:  550\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT445.FILE550\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 34 MEMBERS COUNTED; CUMULATIVE SIZE IS 1,796 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   04/15/02    21:42:23    GMT-5:00\n\n./ ADD NAME=$$NOTE$$ 0101-01342-02046-1209-00008-00005-00000-SBGOLOB\n\n   These macros are a subset of Dan Snyder's macro collection,\n   which can be considered the \"structured macros\".  These macros\n   accomplish IF-THEN-ELSE and DO loop logic, in assembler programs.\n\n   Dan Snyder's \"more complete\" macro collection is on File 438\n   of the CBT Tape collection.\n\n./ ADD NAME=$$NOTE$1 0101-02058-02058-1340-00032-00036-00000-GENTR02\nSubject: structured macros\nDate: Mon, 18 Feb 2002 15:31:49 -0500\nFrom: \"Snyder, Dan\" <Dan_Snyder@stercomm.com>\nTo: \"Sam Golob (E-mail)\" <sbgolob@attglobal.net>\n\nWhen I was in the process of making this macro package work, I\nneeded a way to combine OR clauses together and them have them\nrelate as a group to an AND.  In COBOL a programmer can do it by\nnesting clauses within pairs of parentheses, so that's what I did\nwith this package.\n\nThe first character of a conditional phrase must be a '(',\nindicating the presence of subparameters.  If the second\ncharacter is another '(', then that implies the possibility of\nnested conditions.  The IF macro then splits the one or more\nconditional phrases contained within the double parentheses into\nindividual parameters which are then passed to a recursive call\nof the IF macro itself.  If you code:\n\n        IF      ((((((((CLC,FIELDA,FIELDB,E)))))))),THENDO\n\nthen IF will call itself recursively 7 times (note the macro\nlevel expressed in the line number field):\n\n          IF    ((((((((CLC,FIELDA,FIELDB,E)))))))),THENDO\n+         CLC   FIELDA,FIELDB       TWO OPERANDS - SET CONDITION CODE  08-000115\n+         JNE   $MDF0013            B AROUND IF-GROUP IF FALSE         01-000198\n            MVC   FIELDA,FIELDC\n          ENDIF ,\n+$MDF0013 DC    0H'0'               DEFINE END OF DO-GROUP             03-000330\n\nCool, isn't it?\n./ ADD NAME=$$READ$$ 0100-01331-01331-1329-00098-00098-00000-GENTR02\n                               STRUCTURED MACROS\n\n  THESE MACROS CAN HELP YOU CREATE NEW PROGRAMS AND MODIFY EXISTING CODE BY\n  SUPPORTING IF-THEN-ELSE LOGIC WHILE REQUIRING ONLY A SMALL LEARNING CURVE\n  FROM WHAT YOU ALREADY KNOW ABOUT S/390 ASSEMBLER (ASSUMING THAT YOU DO\n  KNOW IT ALREADY).  EACH 'IF' STATEMENT CAN BE ARBITRARILY COMPLEX, AND THE\n  'IF' STATEMENTS CAN BE NESTED AS MANY LEVELS AS YOU MIGHT NEED (CERTAINLY,\n  NO ONE WOULD NEED MORE THAN 255 LEVELS OF NESTING, WOULD SHE?).\n\n  EACH GROUP OF INSTRUCTIONS THAT YOU WANT CONDITIONALLY EXECUTED WOULD BE\n  HEADED BY AN 'IF' MACRO, AND TERMINATED BY AN 'ENDIF' MACRO.\n\n  IN ITS SIMPLIST FORM, THE OPERAND OF THE 'IF' MACRO CONSISTS OF AN OP-CODE,\n  THE FIRST OPERAND ADDRESS, THE SECOND OPERAND ADDRESS, AND A CONDITION. THESE\n  FOUR VALUES MUST BE ENCLOSED WITHIN PARENTHESES, AND FOLLOWING THE OPERANDS\n  MUST BE A COMMA AND THE STATEMENT TERMINATING TERM 'THENDO'.\n\n  THE OP-CODE MAY BE ANY VALID S/390 OP-CODE THAT SETS THE CONDITION CODE. THE\n  FIRST AND SECOND OPERANDS MAY BE ANY VALUES THAT ARE VALID FOR THE INSTRUCTION\n  BEING CREATED. THE CONDITION, SUCH AS 'E' OR 'NO, IS ANY VALUE THAT CAN BE\n  USED IN CREATING AN EXTENDED MNEMONIC BRANCH INSTRUCTION (SUCH AS 'BE' OR\n  'BNO').\n\n  IF YOU CHOOSE 'E' AS THE CONDITION, THEN THE GROUP OF INSTRUCTIONS BETWEEN THE\n  'IF' AND THE 'ENDIF' WILL BE EXECUTED ONLY IF THE CONDITION CODE SET BY THE\n  OP-CODE AND OPERANDS SPECIFIED IS A ZERO.\n\n  IN THE FOLLOWING EXAMPLES, THE HEADING WILL INDICATE THE\n  CONDITIONS IN WHICH THE DO-GROUP WILL BE EXECUTED. IN EACH CASE,\n  AN 'IF' STATEMENT DETERMINES THE CONDITIONS, AND AN 'ENDIF'\n  STATEMENT TERMINATES THE DO-GROUP. COMMENTS EITHER IN THE HEADING\n  OR ON THE APPROPRIATE INSTRUCTIONS WILL INDICATE THE DETAILS.\n       HERE IS AN EXAMPLE:\n\n         IF    (CLC,A,B,NE),THENDO\n\n  THE INSTRUCTIONS BETWEEN THIS 'IF' AND ITS MATCHING 'ENDIF' WILL BE EXECUTED\n  IF THE RESULT OF THE 'CLC' IS A 1 OR 2 (THE NOT-EQUAL CONDITION).\n\n       TO EXECUTE THE DO-GROUP IF EITHER ONE OF TWO CONDITIONS IS\n  TRUE, THE FORMAT IS:\n\n       IF    (CLC,A,B,NE),OR,(CLC,C,D,NE),THENDO\n\n       ALTERNATE FORMAT:\n                                                            72\n       IF    (CLC,A,B,NE),OR,                                C\n             (CLC,C,D,NE),THENDO\n\n       SINCE 'AND' TAKES PRECEDENCE OVER 'OR', IN THE FOLLOWING\n  EXAMPLE, THE DO-GROUP IS PERFORMED IF THE FIRST TEST IS TRUE, OR\n  IF BOTH THE SECOND AND THIRD ARE TRUE:\n\n       IF    (CLC,A,B,E),OR,                                 C\n             (CLC,C,D,E),AND,                                C\n             (CLC,E,F,E),THENDO\n\n       IF THE DO-GROUP IS TO BE PERFORMED IF THE THIRD IS TRUE AND\n  EITHER THE FIRST OR SECOND IS TRUE, INCLUDE THE TESTS CONNECTED\n  BY THE 'OR' WITHIN ADDITIONAL PARENTHESES:\n\n             * <-NESTING PARENTHESES -> *\n       IF    ((CLC,A,B,E),OR,(CLC,C,D,E)),AND,               C\n             (CLC,E,F,E),THENDO\n\n       ALTERNATE FORMAT:\n                                                            72\n       IF    ((CLC,A,B,E),OR,                                C\n             (CLC,C,D,E)),AND,                               C\n             (CLC,E,F,E),THENDO\n\n       GROUPS OF EXPRESSIONS MAY BE NESTED AS DEEPLY AS REQUIRED\n  TO DEFINE THE LOGIC DESIRED.\n       EACH DO-GROUP MUST BE TERMINATED WITH AN 'ENDIF' STATEMENT\n  OR AN 'ELSE' - 'ENDELSE' COMBINATION:\n\n       ENDIF ,\n                   - OR -\n       ELSE  ,\n       ... ADDITIONAL INSTRUCTIONS TO BE EXECUTED IF 'IF' FAILS\n       ENDELSE ,  (OR ENDIF - EITHER IS ACCEPTABLE AFTER AN 'ELSE')\n\n       ALTERNATIVELY, A DO-GROUP CAN BE TERMINATED AS FOLLOWS:\n\n       ELSEIF  (CLC,G,H,E),THENDO ...\n\n       ANY NUMBER OF 'ELSEIF' STATEMENTS CAN FOLLOW THE ORIGINAL\n       'IF' STATEMENT. THERE MAY BE (BUT NEED NOT BE) ONE AND ONLY\n       ONE 'ELSE' STATEMENT FOLLOWING THE FINAL 'ELSEIF'. THE ENTIRE\n       GROUP IS TERMINATED WITH ONE 'ENDIF' OR 'ENDELSE'.\n\n       IF    (...),THENDO            REQUIRED\n       ...\n       ELSEIF (...),THENDO           OPTIONAL (REPEATED AS REQUIRED)\n       ...\n       ELSE  ,                       OPTIONAL\n       ...\n       ENDIF ,                       REQUIRED (OR 'ENDELSE')\n./ ADD NAME=$MENDDO1\n         MACRO\n&NAME    $MENDDO1 &DOGROUP=\n         COPY  $MGBLDEF\n         LCLA  &J\n&$MDGERR SETA  0                   ASSUME NO ERROR\n&J       SETA  &$MDGLVL\n         AIF   (&J GT 0).OK02\n         MNOTE 8,'NO ACTIVE DO-GROUP TO TERMINATE'\n         MNOTE 0,' - MACRO GENERATION ABORTED'\n&$MDGERR SETA  4                   WARN OTHERS\n         MEXIT\n.OK02    AIF   ('&DOGROUP' EQ '').SKIP15\n         AIF   ('&DOGROUP' NE '*ALL*').TEST10 FALL THROUGH IF *ALL*\n&J       SETA  1                   END ALL BUT OUTERMOST DO-GROUP\n         AGO   .SKIP20             ENTER COMMON LOOP\n.TEST10  AIF   ('&DOGROUP' EQ '&$MDGNAM(&J)').SKIP20\n&J       SETA  &J-1\n         AIF   (&J GE 1).TEST10\n         MNOTE 8,'ATTEMPT TO END NON-EXISTANT DO-GROUP ''&DOGROUP'''\n         MNOTE 0,'ALL ACTIVE DO-GROUPS TERMINATED'\n&J       SETA  1\n         AGO   .SKIP20\n.SKIP15  AIF   ('&NAME' EQ '').ENDIT DO NOTHING IF ONLY 1 LEVEL\n&NAME    DC    0H'0'               WELL, MAYBE A TAG...\n         MEXIT\n.SKIP20  AIF   ('&NAME' EQ '').LOOP30\n&NAME    DC    0H'0'               DEFINE END OF DO-GROUP\n.LOOP30  AIF   (&J GE &$MDGLVL).ENDIT END 1 BEFORE LAST LEVEL\n         $MENDDO2                  END 1 LEVEL\n         AIF   (&$MDGERR NE 0).ENDIT QUIT IF ERROR OCCURRED\n         AIF   (&$MDGLVL LE 1).ENDIT\n         AGO   .LOOP30\n.ENDIT   MEND\n./ ADD NAME=$MENDDO2 0104-01331-02017-1452-00023-00022-00000-GENTR02\n         MACRO\n         $MENDDO2\n         COPY  $MGBLDEF\n         LCLC  &X\n&$MDGERR SETA  0                   RESET TO 0\n         AIF   (&$MDGLVL GT 0).AOK IF NOT GT 0 THEN NOTHING TO DO\n         MNOTE 8,'ATTEMPT TO END NON-EXISTENT DO-GROUP(S)'\n&$MDGERR SETA  8                   SHOW ERROR OCCURRED\n         MEXIT\n.AOK     AIF   ('&$MLTAG(&$MDGLVL)' EQ '').SKIP10\n         J     &$MLTAG(&$MDGLVL)   RETURN TO 'DO'\n&$MLTAG(&$MDGLVL) SETC ''          NULLIFY\n.SKIP10  ANOP\n&X       SETC  '$MD&$MIFELS(&$MDGLVL)&$MDGSEQ(&$MDGLVL)'\n&X       DC    0H'0'               DEFINE END OF CONDITIONAL GROUP\n&$MCVERB(&$MDGLVL) SETC ''\n         AIF   ('&$MFNBR(&$MDGLVL)' EQ '').SKIP30\n&X       SETC  '$MDF&$MFNBR(&$MDGLVL)'\n&$MFNBR(&$MDGLVL) SETC ''\n&X       DC    0H'0'               DEFINE TAG FOR 'ELSEIF' STATEMENTS\n.SKIP30  ANOP\n&$MDGLVL SETA  &$MDGLVL-1\n         MEND\n./ ADD NAME=$MGBLDEF 0134-01331-02095-1529-00104-00009-00000-GENTR02\n.*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\n.* THIS COPY MEMBER CONTAINS THE GLOBAL SET SYMBOLS REQUIRED BY THE  *\n.* MACROS IN THIS LIBRARY. AT IT'S FIRST INVOCATION WITHIN AN        *\n.* ASSEMBLY, IT COPIES 6 MACRO DEFINITIONS THAT ARE CALLED FROM      *\n.* WITHIN THE OTHER MACROS DEFINED IN THE LIBRARY.                   *\n.*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\n         GBLA  &$MDGLVL,&$MDGERR,&$MRECUR,&$MCPYSW,&$MBLATH,&$MAXRC\n         GBLC  &$MFNBR(31),&$MDGNAM(255),&$MDGSEQ(255),&$MNAME,&$MNC\n         GBLC  &$MIFELS(255),&$MLTAG(255),&$MPNAM1(31),&$MFNAM1(31)\n         GBLC  &$MCVERB(255),&$MC,&$MLOCTR\n         AIF   (&$MCPYSW EQ 1).END999 THIS HOOPLA IS JUST TO PREVENT\n&$MCPYSW SETA  (1)      THESE GUYS FROM APPEARING IN THE MEMBER LIST.\n         AIF   ('&$MLOCTR' NE '').SKIP010 DON'T OVERLAY\n&$MLOCTR SETC  '$$DATA$$'          DEFAULT VALUE FOR DATA LOCTR\n.SKIP010 PUSH  PRINT  *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\n         PRINT OFF    *=* COPY INTERNAL MACROS INTO THIS ASSEMBLY *=*\n         MACRO\n&NAME    $MENDDO1 &DOGROUP=\n         GBLA  &$MDGLVL,&$MDGERRR\n         GBLC  &$MDGNAM(255)\n         LCLA  &J\n&$MDGERR SETA  0                   ASSUME NO ERROR\n&J       SETA  &$MDGLVL\n         AIF   (&J GT 0).OK02\n   MNOTE 8,'NO ACTIVE CR-GROUP TO TERMINATE - MACRO GENERATION ABORTED'\n&$MDGERR SETA  4                   WARN OTHERS\n         MEXIT\n.OK02    AIF   ('&DOGROUP' EQ '').SKIP15\n         AIF   ('&DOGROUP' NE '*ALL*').TEST10 FALL THROUGH IF *ALL*\n&J       SETA  1                   END ALL BUT OUTERMOST DO-GROUP\n         AGO   .SKIP20             ENTER COMMON LOOP\n.TEST10  AIF   ('&DOGROUP' EQ '&$MDGNAM(&J)').SKIP20\n&J       SETA  &J-1\n         AIF   (&J GE 1).TEST10\n         MNOTE 8,'ATTEMPT TO END NON-EXISTANT DO-GROUP ''&DOGROUP'''\n         MNOTE 0,'ALL ACTIVE DO-GROUPS TERMINATED'\n&J       SETA  1\n         AGO   .SKIP20\n.SKIP15  AIF   ('&NAME' EQ '').ENDIT DO NOTHING IF ONLY 1 LEVEL\n&NAME    DC    0H'0'               WELL, MAYBE A TAG...\n         MEXIT\n.SKIP20  AIF   ('&NAME' EQ '').LOOP30\n&NAME    DC    0H'0'         *=*=* DEFINE END OF DO-GROUP *=*=*\n.LOOP30  AIF   (&J GE &$MDGLVL).ENDIT END 1 BEFORE LAST LEVEL\n         $MENDDO2                  END 1 LEVEL\n         AIF   (&$MDGERR NE 0).ENDIT QUIT IF ERROR OCCURRED\n         AIF   (&$MDGLVL LE 1).ENDIT\n         AGO   .LOOP30\n.ENDIT   MEND\n         MACRO\n         $MENDDO2\n         GBLA  &$MDGLVL,&$MDGERR\n         GBLC  &$MFNBR(31),&$MDGSEQ(255),&$MIFELS(255),&$MLTAG(255)\n         GBLC  &$MCVERB(255)\n         LCLC  &X\n&$MDGERR SETA  0                   RESET TO 0\n         AIF   (&$MDGLVL GT 0).AOK IF NOT GT 0 THEN NOTHING TO DO\n         MNOTE 4,'ATTEMPT TO END NON-EXISTENT DO-GROUP(S)'\n&$MDGERR SETA  4                   SHOW ERROR OCCURRED\n         MEXIT\n.AOK     AIF   ('&$MLTAG(&$MDGLVL)' EQ '').SKIP10\n         J     &$MLTAG(&$MDGLVL)   RETURN TO 'DO'\n&$MLTAG(&$MDGLVL) SETC ''          NULLIFY\n.SKIP10  ANOP\n&X       SETC  '$MD&$MIFELS(&$MDGLVL)&$MDGSEQ(&$MDGLVL)'\n&X       DC    0H'0'         *=*=* DEFINE END OF DO-GROUP *=*=*\n&$MCVERB(&$MDGLVL) SETC ''\n         AIF   ('&$MFNBR(&$MDGLVL)' EQ '').SKIP30\n&X       SETC  '$MDF&$MFNBR(&$MDGLVL)'\n&$MFNBR(&$MDGLVL) SETC ''\n&X       DC    0H'0'               DEFINE TAG FOR 'ELSEIF' STATEMENTS\n.SKIP30  ANOP\n&$MDGLVL SETA  &$MDGLVL-1\n         $MLVLMSG &$MDGLVL,NESTING\n         MEND\n         MACRO\n         $MGFNAME &DUMMY           CREATE A UNIQUE TAG FOR 'IF'\n         GBLA  &$MRECUR\n         GBLC  &$MFNAM1(31)\n&$MFNAM1(&$MRECUR) SETC  '$MDF&SYSNDX' COMPARE-FAILED TAG\n         MEND\n         MACRO\n         $MGFNBR &DUMMY            CREATE A UNIQUE TAG FOR 'ELSEIF'\n         GBLA  &$MDGLVL\n         GBLC  &$MFNBR(31)\n&$MFNBR(&$MDGLVL) SETC '&SYSNDX'   CREATE UNIQUE SEQUENCE NUMBER\n         MEND\n         MACRO\n         $MGPNAME &DUMMY           CREATE A UNIQUE TAG FOR 'IF'\n         GBLA  &$MRECUR\n         GBLC  &$MPNAM1(31)\n&$MPNAM1(&$MRECUR) SETC  '$MDP&SYSNDX' COMPARE-SUCCEEDED TAG\n         MEND\n         MACRO\n         $MLVLMSG &LVL,&TYPE       &TYPE MUST BE 'NESTING' OR\n.*                                 . 'RECURSION'\n         GBLA  &$MBLATH            USER CONTROLS MNOTES WITH THIS\n         AIF   (&$MBLATH LT 10).MEND999 NO MNOTE IF < 10\n         AIF   ('&TYPE' EQ 'NESTING').GEN010 ISSUE MNOTE IF EQUAL\n         AIF   (&$MBLATH LT 12).MEND999 NO 'RECURSION' IF < 12\n.GEN010  MNOTE '==> &LVL <== IS CURRENT &TYPE LEVEL'\n.MEND999 MEND\n         POP   PRINT  *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\n.END999  ANOP\n./ ADD NAME=$MGFNAME\n         MACRO\n         $MGFNAME &DUMMY           CREATE A UNIQUE TAG FOR 'IF'\n         COPY  $MGBLDEF\n&$MFNAM1(&$MRECUR) SETC  '$MDF&SYSNDX' COMPARE-FAILED TAG\n         MEND\n./ ADD NAME=$MGFNBR\n         MACRO\n         $MGFNBR &DUMMY            CREATE A UNIQUE TAG FOR 'ELSEIF'\n         COPY  $MGBLDEF            COPY IN ALL THE SYMBOLS\n&$MFNBR(&$MDGLVL) SETC '&SYSNDX'   CREATE UNIQUE SEQUENCE NUMBER\n         MEND\n./ ADD NAME=$MGPNAME\n         MACRO\n         $MGPNAME &DUMMY           CREATE A UNIQUE TAG FOR 'IF'\n         COPY  $MGBLDEF\n&$MPNAM1(&$MRECUR) SETC  '$MDP&SYSNDX' COMPARE-SUCCEEDED TAG\n         MEND\n./ ADD NAME=@FILE550 0103-02058-02058-1342-00036-00036-00000-GENTR02\n//***FILE 550 is the Structured Assembler Macros collection from    *   FILE 550\n//*           Dan Snyder.  If you have been tempted to use the      *   FILE 550\n//*           IBM HLASM Toolkit set of structured macros, but you   *   FILE 550\n//*           were afraid that you'd have to assemble your code     *   FILE 550\n//*           in a place that wasn't licensed for the Toolkit,      *   FILE 550\n//*           then you might try these macros as an alternative.    *   FILE 550\n//*                                                                 *   FILE 550\n//*           These macros (IF, DO, etc) are not interchangeable    *   FILE 550\n//*           with the IBM macros from the HLASM toolkit.  You      *   FILE 550\n//*           either use ALL THESE, or ALL THEIRS, but don't mix    *   FILE 550\n//*           them....                                              *   FILE 550\n//*                                                                 *   FILE 550\n//*           The advantage of using this set of structured macros  *   FILE 550\n//*           is that they are FREE and that they offer a powerful  *   FILE 550\n//*           method of nesting conditions. You can assemble with   *   FILE 550\n//*           them at any site....                                  *   FILE 550\n//*                                                                 *   FILE 550\n//*           For support, you may contact the author, Dan Snyder,  *   FILE 550\n//*           at:                                                   *   FILE 550\n//*                                                                 *   FILE 550\n//*           email:   dsnyder@elektro.cmhnet.org                   *   FILE 550\n//*                    Dan_Snyder@stercomm.com                      *   FILE 550\n//*                                                                 *   FILE 550\n//*     - - - - - - - - - - - - - - - - - - - - - - - - - - -       *   FILE 550\n//*                                                                 *   FILE 550\n//*     Names of the macros in the Structured Macro Set:            *   FILE 550\n//*                                                                 *   FILE 550\n//*         AFTER    BEGTEST  DO       DOCUMENT DOEXIT              *   FILE 550\n//*         ELSE     ELSEDO   ELSEIF   ENDAFTER ENDELSE             *   FILE 550\n//*         ENDEVERY ENDFIRST ENDIF    ENDO     ENDTEST             *   FILE 550\n//*         EVERY    EXECUTE  FIRST    IF       THENDO              *   FILE 550\n//*                                                                 *   FILE 550\n//*      and the auxiliary copy member to assist these:             *   FILE 550\n//*                                                                 *   FILE 550\n//*         $GBLDEF                                                 *   FILE 550\n//*                                                                 *   FILE 550\n./ ADD NAME=AFTER    0112-01257-02070-1317-00034-00039-00000-GENTR02\n         MACRO\n&NAME    AFTER &VAR\n         COPY  $MGBLDEF            BRING IN THE CLOWNS\n&LCLV    SETC  '&VAR'              SET TO COUNT\n         AIF   ('&VAR'(1,1) GE '0').OK30 GO IF SELF-DEFINING\n         MNOTE 8,'''&VAR'' NOT SELF-DEFINING: 'AFTER' GROUP WILL BE PROC\n               CESSED EACH PASS THROUGH THIS SECTION OF CODE'\n&LCLV    SETC  '0'                 DO EVERY TIME\n.OK30    ANOP\n&$MDGLVL SETA  &$MDGLVL+1          INCREMENT LEVEL\n         $MLVLMSG &$MDGLVL,NESTING\n&$MDGSEQ(&$MDGLVL) SETC '&SYSNDX'\n&$MIFELS(&$MDGLVL) SETC 'F'\n&$MDGNAM(&$MDGLVL) SETC '&NAME'\n&$MCVERB(&$MDGLVL) SETC 'AFTER'\n&X       SETC  '$MDV&SYSNDX'       MAKE IT PRETTY\n         AIF   ('&LCLV' NE '1').PACKED\n&NAME    TM    &X,X'01'            HAVE WE BEEN HERE BEFORE?\n         JO    *+12                SKIP OVER IS YES\n         OI    &X,X'01'            ELSE LEAVE TRACKS\n         J     $MDF&SYSNDX           AND BYPASS DO-GROUP\n         AGO   .DEFINE\n.PACKED  ANOP                      I GUESS WE'LL HAVE TO DO DECIMAL...\n&NAME    SP    &X,=P'1'            DECREMENT\n         JNM   $MDF&SYSNDX         B IF NOT YET TIME\n         PACK  &X,=Z'0'            DO EVERY TIME FROM NOW ON\n&$MLOCTR LOCTR                     SET UP WORK AREA\n         AIF   ('&LCLV' NE '1').PACKED2\n&X       DC    X'00'               SET TO X'01' FIRST TIME THROUGH\n         AGO   .INST\n.PACKED2 ANOP\n&X       DC    P'&LCLV'            FREQUENCY COUNTER\n&SYSECT  LOCTR                     BACK TO INSTRUCTION AREA\n         MEND\n./ ADD NAME=BEGTEST  0118-01330-02079-1022-00057-00064-00000-GENTR02\n         MACRO\n&NAME    BEGTEST &LVL,                                                 C\n               &PRINT=        CODE 'PRINT=NO' TO SUPPRESS SKIPPED STMTS\n.* OR 'PRINT=YES' TO PRINT SKIPPED STMTS OR CHANGE IT IN THIS MACRO\n.* DEFINITION TO CHANGE IT TO SAY '&PRINT=NO' TO MAKE 'NO' THE DEFAULT\n.*\n.*                              IN 'OPEN' CODE DO ONE OF THE FOLLOWING:\n         GBLA  &TESTLVL         1. SET TO > 0 TO ACTIVATE - OR -\n         GBLC  &$A,&$B,&$C,&$D  2. SET ONE OR MORE TO 'Y' TO ACTIVATE\n         GBLC  &$MPRSW          TO KEEP TRACK OF USER'S PREF\n         LCLA  &I,&J\n         LCLC  &TEXT\n         AIF   ('&PRINT' EQ '').SKIP005 GO IF NO PARM SPECIFIED\n&$MPRSW  SETC  '&PRINT'                SET GLOBAL TO USER'S VALUE\n.SKIP005 AIF   ('&NAME' EQ '').SKIP010\n&NAME    EQU   *\n.SKIP010 AIF   ('&LVL' NE '' AND '&LVL'(1,1) GT 'Z').TEST510\n         AIF   ('&LVL' NE 'A').TEST020 FALL THRU IF 'A'\n         AIF   ('&$A' EQ 'Y').MEND999  IF 'Y' THEN INCLUDE THRU ENDTEST\n         AGO   .LOOP520                IF NOT THEN EXCLUDE THRU ENDTEST\n.TEST020 AIF   ('&LVL' NE 'B').TEST030 FALL THRU IF 'B'\n         AIF   ('&$B' EQ 'Y').MEND999  IF 'Y' THEN INCLUDE THRU ENDTEST\n         AGO   .LOOP520                IF NOT THEN EXCLUDE THRU ENDTEST\n.TEST030 AIF   ('&LVL' NE 'C').TEST040 FALL THRU IF 'C'\n         AIF   ('&$C' EQ 'Y').MEND999  IF 'Y' THEN INCLUDE THRU ENDTEST\n         AGO   .LOOP520                IF NOT THEN EXCLUDE THRU ENDTEST\n.TEST040 AIF   ('&LVL' NE 'D').MSG050  FALL THRU IF 'D'\n         AIF   ('&$D' EQ 'Y').MEND999  IF 'Y' THEN INCLUDE THRU ENDTEST\n         AGO   .LOOP520                IF NOT THEN EXCLUDE THRU ENDTEST\n.MSG050  MNOTE *,' ---> INVALID CHAR OPERAND &LVL - OPT CODE INCLUDED'\n         AGO   .MEND999\n.TEST510 AIF   (&LVL LE &TESTLVL).MEND999 IF LE THEN INCL THRU ENDTEST\n.LOOP520 AIF   ('&$MPRSW' EQ 'YES').NEXT523 'DEFAULT' IS SUPPRESS\n&TEXT    AREAD NOPRINT            READ STMT AND SUPPRESS PRINT\n         AGO   .NEXT526\n.NEXT523 ANOP\n&TEXT    AREAD NOSTMT            READ AND PRINT STMT BUT NO LINE NUMBER\n.NEXT526 AIF   ('&TEXT'(1,1) EQ '*').LOOP520 SKIP COMMENT STMTS\n&J       SETA  &J+1                    COUNT THIS STMT\n&I       SETA  1                       GET READY TO INSPECT STMT\n.LOOP530 AIF   ('&TEXT'(&I,1) EQ ' ').NEXT540 SCAN PAST NAME FIELD\n&I       SETA  &I+1                    INCR PTR TO NEXT POS\n         AIF   (&I GT 65).LOOP520      GET NEXT STMT IF COL 65\n         AGO   .LOOP530                KEEP SCANNING NAME FIELD\n.NEXT540 AIF   ('&TEXT'(&I,1) NE ' ').NEXT550 SCAN PAST LEADING SPACES\n&I       SETA  &I+1                    INCR TO NEXT POS\n         AIF   (&I GT 65).LOOP520      GET NEXT STMT IF COL 65\n         AGO   .NEXT540                KEEP SCANNING SPACES\n.NEXT550 AIF   ('&TEXT'(&I,8) NE 'ENDTEST ').LOOP520 SECRET KEYWORD?\n&J       SETA  &J-1                    YES - DECREMENT IMAGE COUNT\n         AIF   (&J NE 1).MSG560        FORMAT NICELY\n         MNOTE *,' ===> ENDTEST STATEMENT ENCOUNTERED - 1 STATEMENT SKIX\n               PPED'\n         AGO   .MEND999\n.MSG560  MNOTE *,' ===> ENDTEST STATEMENT ENCOUNTERED - &J STATEMENTS SX\n               KIPPED'\n.MEND999 MEND\n./ ADD NAME=DO       0116-01331-02079-1254-00127-00124-00000-GENTR02\n         MACRO\n&NAME    DO    &VAR,&WHILE=,&UNTIL=,&TEST=BEFORE\n         COPY  $MGBLDEF            BRING IN THE CLOWNS\n         LCLA  &Y\n         LCLC  &X\n         AIF   ('&TEST' EQ 'BEFORE').TEST10\n         AIF   ('&TEST' EQ 'AFTER').TEST10\n         MNOTE 8,'''TEST=&TEST'' INVALID - ''BEFORE'' ASSUMED'\n.TEST10  AIF   ('&WHILE' NE '').TEST20 GO IF &WHILE SPECIFIED\n         AIF   ('&UNTIL' NE '').TEST22  GO IF &UNTIL SPECIFIED\n         AIF   ('&VAR' NE '').OK30 GO IF &VAR SPECIFIED\n         MNOTE 4,'NO ENDING CONDITION - POSSIBLE UNENDING LOOP'\n         AGO   .OK30               CONTINUE\n.TEST20  AIF   ('&UNTIL' NE '').ERR90 GO IF &UNTIL SPECIFIED\n.TEST22  AIF   ('&VAR' NE '').ERR90 GO IF &VAR SPECIFIED\n         AIF   ('&WHILE' NE '').CONT50\n.OK30    AIF   ('&UNTIL' NE '').CONT60\n&$MDGLVL SETA  &$MDGLVL+1          INCREMENT LEVEL\n         $MLVLMSG &$MDGLVL,NESTING\n&$MDGSEQ(&$MDGLVL) SETC '&SYSNDX'\n&$MIFELS(&$MDGLVL) SETC 'F'\n&$MDGNAM(&$MDGLVL) SETC '&NAME'\n&$MCVERB(&$MDGLVL) SETC 'DO'\n&$MNAME  SETC  '$MDG&SYSNDX'       SET TO SYNTHESIZED NAME\n&$MLTAG(&$MDGLVL) SETC '&$MNAME'   SET LOOP RETURN TAG\n         AIF   ('&VAR' EQ '').CLEAN99 GO IF NO &VAR SPECIFIED\n         AIF   ('&VAR'(1,1) GE '0').SELF40 GO IF SELF-DEFINING\n.*                                 - (MUST BE PACKED DECIMAL)\n         AIF   ('&VAR' NE 'FOREVER').NEXT32 GO IF NOT FOREVER\n         AIF   ('&NAME' EQ '').SKIP31\n&NAME    DS    0H                  FALL THRU TO BEGINNING OF DO-GROUP\n.SKIP31  ANOP\n&$MNAME  DS    0H                  BEGINNING OF DO-GROUP\n         AGO   .CLEAN99\n.NEXT32  ANOP\n&NAME    PACK  $MDV&SYSNDX,=Z'0'   START WITH 0 THEN ADD 1\n         ZAP   $MDM&SYSNDX,&VAR    PROTECT VARIABLE FROM CHANGE\n         AIF   ('&TEST' NE 'AFTER').SKIP35\n         EX    0,*+8               BUMP BY 1\n         J     $MDD&SYSNDX         SATISFY 'TEST=AFTER' CLAUSE\n.SKIP35  ANOP\n&$MNAME  AP    $MDV&SYSNDX,=P'1'   BUMP BY 1\n&$MNAME  SETC  ''                  SET NAME TO NULL\n&X       SETC  '$MDM&SYSNDX'       NAME FOR CELL FOR END VALUE\n         CP    $MDV&SYSNDX,&X      FINISHED?\n         JH    $MDF&SYSNDX         B IF YES\n&$MLOCTR LOCTR                     FOLLOWING CODE TO BE IN WORK AREA\n&Y       SETA  L'&VAR              MAKE SURE OUR VARIABLE IS BIG ENOUGH\n&X       DC    PL(&Y+1)'0'         CELL TO SAVE END VALUE\n&X       SETC  '$MDV&SYSNDX'       MAKE IT PRETTY\n&X       DC    PL(&Y+1)'0'         LOOP COUNTER\n&SYSECT  LOCTR                     RESUME INSTRUCTION AREA\n         AGO   .CLEAN99\n.SELF40  ANOP\n&NAME    PACK  $MDV&SYSNDX,=Z'0'   START WITH 0 THEN ADD 1\n         AIF   ('&TEST' NE 'AFTER').SKIP46\n         EX    0,*+8               BUMP BY 1\n         J     $MDD&SYSNDX         SATISFY 'TEST=AFTER' CLAUSE\n.SKIP46  ANOP\n&$MNAME  AP    $MDV&SYSNDX,=P'1'   BUMP BY 1\n&$MNAME  SETC  ''                  SET NAME TO NULL\n         CP    $MDV&SYSNDX,=P'&VAR' FINISHED?\n         JH    $MDF&SYSNDX         B IF YES\n&$MLOCTR LOCTR                     FOLLOWING CODE TO BE IN WORK AREA\n&X       SETC  '$MDV&SYSNDX'       MAKE IT PRETTY\n&X       DC    P'0&VAR'            LOOP COUNTER\n&SYSECT  LOCTR                     RESUME INSTRUCTION AREA\n         AGO   .CLEAN99\n.CONT50  ANOP  &WHILE OPTION WAS SPECIFIED\n&$MNAME  SETC  '&NAME'             SET TO GIVEN NAME\n         AIF   ('&NAME' NE '').CONT52 NO TAG -> NO DC\n&$MNAME  SETC  '$MDG&SYSNDX'       SET TO SYNTHESIZED NAME\n.CONT52  ANOP\n&Y       SETA  &$MDGLVL+1          SET TO NEXT HIGHER\n&$MLTAG(&Y) SETC '&$MNAME'         SET TO LOOP NAME\n         AIF   ('&TEST' NE 'AFTER').SKIP53\n         J     $MDD&SYSNDX         SATISFY 'TEST=AFTER' CLAUSE\n.SKIP53  AIF   ('&WHILE'(2,1) EQ '(').CONT54\n&$MCVERB(&$MDGLVL+1) SETC 'DO'     USED TO SUPRESS MNOTE IN 'IF'\n&$MNAME  IF    &WHILE,THENDO       PASS PARMS TO 'IF'\n         AGO   .CLEAN99            WRAP IT UP\n.CONT54  ANOP\n&$MCVERB(&$MDGLVL+1) SETC 'DO'     USED TO SUPRESS MNOTE IN 'IF'\n&$MNAME  IF    &WHILE(1),&WHILE(2),&WHILE(3),&WHILE(4),                C\n               &WHILE(5),&WHILE(6),&WHILE(7),&WHILE(8),                C\n               &WHILE(9),&WHILE(10),&WHILE(11),&WHILE(12),             C\n               &WHILE(13),&WHILE(14),&WHILE(15),&WHILE(16),            C\n               &WHILE(17),&WHILE(18),&WHILE(19),&WHILE(20),            C\n               &WHILE(21),&WHILE(22),&WHILE(23),&WHILE(24)\n         AGO   .CLEAN99\n.CONT60  ANOP  &UNTIL OPTION WAS SPECIFIED\n&$MNAME  SETC  '&NAME'             SET TO GIVEN NAME\n         AIF   ('&NAME' NE '').CONT62 NO TAG -> NO DC\n&$MNAME  SETC  '$MDG&SYSNDX'       SET TO SYNTHESIZED NAME\n.CONT62  ANOP\n&Y       SETA  &$MDGLVL+1          SET TO NEXT HIGHER\n&$MLTAG(&Y) SETC '&$MNAME'         SET TO LOOP NAME\n         AIF   ('&TEST' NE 'AFTER').SKIP63\n         J     $MDD&SYSNDX         SATISFY 'TEST=AFTER' CLAUSE\n.SKIP63  AIF   ('&UNTIL'(2,1) EQ '(').CONT64\n&$MCVERB(&$MDGLVL+1) SETC 'DO'     USED TO SUPRESS MNOTE IN 'IF'\n&$MNAME  IF    &UNTIL,THENDO       PASS PARMS TO 'IF'\n         J     $MDF&SYSNDX         CONDITION MET - EXIT LOOP\n&X       SETC  '$MDF&$MDGSEQ(&$MDGLVL)' PREV 'FAILED' TAG\n&X       DC    0H'0'               'UNTIL' FAILED - ENTER DO-GROUP\n&$MDGSEQ(&$MDGLVL) SETC '&SYSNDX'  NEW UNIQUE TAG\n         AGO   .CLEAN99            WRAP IT UP\n.CONT64  ANOP\n&$MCVERB(&$MDGLVL+1) SETC 'DO'     USED TO SUPRESS MNOTE IN 'IF'\n&$MNAME  IF    &UNTIL(1),&UNTIL(2),&UNTIL(3),&UNTIL(4),                C\n               &UNTIL(5),&UNTIL(6),&UNTIL(7),&UNTIL(8),                C\n               &UNTIL(9),&UNTIL(10),&UNTIL(11),&UNTIL(12),             C\n               &UNTIL(13),&UNTIL(14),&UNTIL(15),&UNTIL(16),            C\n               &UNTIL(17),&UNTIL(18),&UNTIL(19),&UNTIL(20),            C\n               &UNTIL(21),&UNTIL(22),&UNTIL(23),&UNTIL(24)\n         J     $MDF&SYSNDX         CONDITION MET - EXIT LOOP\n&X       SETC  '$MDF&$MDGSEQ(&$MDGLVL)' PREV 'FAILED' TAG\n&X       DC    0H'0'               'UNTIL' FAILED - ENTER DO-GROUP\n&$MDGSEQ(&$MDGLVL) SETC '&SYSNDX'  NEW UNIQUE TAG\n         AGO   .CLEAN99            WRAP IT UP\n.ERR90   MNOTE 12,'MUTUALLY EXCLUSIVE PARAMETERS - MACRO ABORTED'\n         AGO   .MEND990\n.CLEAN99 ANOP\n         AIF   ('&TEST' NE 'AFTER').MEND990\n&X       SETC  '&SYSNDX'           FOR ALIGNMENT PURPOSES ONLY\n$MDD&X   DC    0H'0'               BEGINNING OF DO-GROUP\n.MEND990 MEND\n./ ADD NAME=DOCUMENT 0129-01226-02072-1549-00707-01634-00000-GENTR02\nTHIS MEMBER IS AN INTRODUCTION TO THE MACRO DEFINITIONS WHICH COMPRISE\nTHE REMAINING MEMBERS OF THIS LIBRARY.  EACH OF THE MACROS HAS BEEN\nTESTED, FOUND TO OPERATE CORRECTLY, AND TO PROVIDE AT LEAST SOME\nMINIMUM AMOUNT OF DESIRABLE FUNCTIONALITY.  IF A PROBLEM CROPS UP,\nEITHER IN YOUR UNDERSTANDING HOW TO USE A PARTICULAR MACRO OR GROUP OF\nMACROS, OR WITH APPARENT PROGRAMMING PROBLEMS WITH THE PACKAGE, PLEASE\nFEEL FREE TO CONTACT THE AUTHOR (NOTE THESE MACROS ARE NOT COPYWRITED):\n\n          DAN SNYDER                  614-847-8212\n          COMPUWARE CORP              dsnyder@elektro.cmhnet.org\n          1103 SCHROCK ROAD, STE 205\n          COLUMBUS, OH 43229\n\nTHE FOLLOWING IS A DESCRIPTION OF THE CATEGORIES THAT THESE MACROS HAVE\nBEEN CLASSIFIED INTO:\n\nINTERNAL - THESE MACROS ARE TYPICALLY USED AS COMMON SERVICE ROUTINES\nBY OTHER MACROS WITHIN THIS LIBRARY.  THEY PROVIDE SERVICES THAT WOULD\nNOT NORMALLY BE CALLED FROM OPEN CODE. THEY ARE AUTOMATICALLY COPIED\nINTO THE ASSEMBLE THE FIRST TIME THAT $GBLDEF IS COPIED INTO A MACRO\nTHAT IS BEING EXPANDED.\n\nSTRUCTURED - MACROS THAT CONTROL THE CONDITIONAL OR REPETITIVE\nEXECUTION OF A GROUP OF INSTRUCTIONS FOLLOWING THE GROUP-INITIATION\nMACRO AND ENDING WITH A GROUP-TERMINATING MACRO. SEVERAL MACROS IN THIS\nFAMILY GENERATE A 'LOCTR' STATEMENT NAMED 'DATA' TO ALLOW THE OUT-OF-LINE\nGENERATION OF REQUIRED CONSTANTS AND VARIABLES.  THE NAME OF THE LOCTR\nCAN BE CHANGED TO LOCAL REQUIREMENTS IN THE $MGBLDEF MEMBER.\n\nDIAGNOSTIC - THE 'BEGTEST' AND 'ENDTEST' MACROS ALLOW YOU TO CONDITIONALLY\nINCLUDE OR EXCLUDE SECTIONS OF CODE FROM A PARTICULAR ASSEMBLY.  THE CODE\nCAN CONTINUE TO EXIST IN THE SOURCE MODULE. YOU COULD INCLUDE ONE\nSECTION OF CODE FOR MVS SYSTEMS, AND ANOTHER FOR VSE.  THIS FACILITY\nPROVIDES A 'STRUCTURED' EQUIVALENT OF HAVING 'AGO' OR 'AIF' STATEMENTS\nTARGETTING LABELLED 'ANOP' STATEMENTS WITHIN YOUR CODE.\n\nGENERAL - THE 'EXECUTE' MACRO ALLOWS THE PROGRAMMER TO CREATE AN 'EX'\nSTATEMENT ON ONE LINE OF CODE.  IT GENERATES A 'LOCTR' STATEMENT NAMED\n'DATA' TO ALLOW THE OUT-OF-LINE GENERATION OF THE 'EX'ECUTED INSTRUCTION.\nTHE NAME OF THE LOCTR AREA CAN BE CHANGED TO LOCAL REQUIREMENTS.\n\nIN EACH OF THE EXAMPLES, IF '<NAME>' IS DISPLAYED IN THE NAME FIELD\nOF A MACRO DEFINITION, THEN THE NAME FIELD IS A SUPPORTED OPTION FOR\nTHAT MACRO.\n\nWHAT FOLLOWS IS A MOSTLY ALPHABETICAL LISTING OF ALL OF THE MACRO\nDEFINITIONS INCLUDED IN THE PACKAGE, WITH ITS IDENTIFYING MACRO TYPE:\n\n$MGBLDEF  INTERNAL (GLOBAL SET SYMBOL DEFINITIONS AND INTERNAL MACROS)\nAFTER     STRUCTURED\nBEGTEST   DIAGNOSTIC\nDO        STRUCTURED\nDOEXIT    STRUCTURED\nDONEXT    STRUCTURED\nELSE      STRUCTURED\nELSEDO    STRUCTURED\nELSEIF    STRUCTURED\nENDAFTER  STRUCTURED\nENDELSE   STRUCTURED\nENDEVERY  STRUCTURED\nENDFIRST  STRUCTURED\nENDIF     STRUCTURED\nENDO      STRUCTURED\nENDTEST   DIAGNOSTIC\nEVERY     STRUCTURED\nEXECUTE   GENERAL\nFIRST     STRUCTURED\nIF        STRUCTURED\nTHENDO    STRUCTURED\n\n                            DIAGNOSTIC\n\nTHE MACROS IN THIS GROUP FURNISH VARIOUS AIDS THAT CAN BE USED IN\nDIAGNOSING THE EXECUTION OF A PROGRAM.  THE 'BEGTEST' AND 'ENDTEST'\nMACROS ALLOW MULTIPLE LINES OF CODE TO BE INCLUDED OR EXCLUDED FROM\nAN ASSEMBLY, BASED ON THE VALUE OF A GLOBAL SET SYMBOL.\n\nBEGTEST\nTHIS MACRO HEADS A GROUP OF INSTRUCTIONS THAT ARE CONDITIONALLY\nINCLUDED OR EXCLUDED FROM A PARTICULAR ASSEMBLY. THE GROUP MUST BE\nTERMINATED WITH AN 'ENDTEST' MACRO.  THE 'BEGTEST' REQUIRES ONE\nPOSITIONAL OPERAND.  IF THE OPERAND IS NUMERIC, THEN THAT VALUE IS\nCOMPARED WITH THE GLOBAL TYPE 'A' SET SYMBOL &TESTLVL.  IF THE OPERAND\nIS GREATER THAN &TESTLVL, THEN THE INSTRUCTIONS BETWEEN THE 'BEGTEST'\nAND 'ENDTEST' ARE EXCLUDED FROM THIS ASSEMBLY, OTHERWISE THEY ARE\nINCLUDED:\n\n          GBLA  &TESTLVL\n &TESTLVL SETA  10\n ...\n<NAME>    BEGTEST 5,PRINT=YES\n          WTO   'HELP'\n<NAME>    ENDTEST ,\n\nIN THIS CASE, THE 'WTO' STATEMENT WILL BE ASSEMBLED.  IF &TESTLVL HAD\nBEEN SET TO 0 (ZERO), THEN THE 'WTO' WOULD HAVE BEEN EXCLUDED FROM\nTHIS ASSEMBLY.  THE PARAMETER 'PRINT=YES' CAUSES EACH STATEMENT\nSKIPPED TO BE LISTED AS A COMMENT (A '-' IS PRINTED IN THE LISTING\nPRECEDING COLUMN 1 OF THE STATEMENT).\n\nBE VERY CAREFUL ABOUT GIVING A NAME TO THE 'ENDTEST' MACRO.  IF YOU\nCODE A BRANCH INSTRUCTION WITH THAT NAME AS THE OPERAND, AND THAT\n'ENDTEST' INSTRUCTION IS OMITTED FROM THE PROGRAM BECAUSE OF THE VALUE\nOF &TESTLVL, THEN YOU WILL GET AN ASSEMBLY ERROR.  IT WOULD BE SAFE TO\nHAVE A BRANCH TO THAT TAG ONLY WITHIN THE GROUP OF INSTRUCTIONS HEADED\nBY THE 'BEGTEST' MACRO.\n\nIF THE VALUE OF THE POSITIONAL OPERAND OF THE 'BEGTEST' IS 'A', 'B',\n'C', OR 'D', THEN THE LOGIC IS BASED ON THE SETTING OF THE GLOBAL TYPE\n'C' SET SYMBOL &$A, &$B, &$C OR &$D RESPECTIVELY:\n\n          GBLC  &$A\n&$A       SETC  'Y'     ANY OTHER VALUE CAUSES EXCLUSION\n...\n<NAME>    BEGTEST A,PRINT=NO\n          WTO   'OPT CODE INCLUDED'\n<NAME>    ENDTEST ,\n\nSINCE THE SET SYMBOL &$A WAS SET TO 'Y', THE 'WTO' WILL BE INCLUDED IN\nTHIS ASSEMBLY.  IF &$A HAD BEEN SET TO ANY OTHER VALUE THEN THE CODE\nWOULD NOT BE INCLUDED IN THIS ASSEMBLY.  THE 'PRINT=NO' PARAMETER\nPREVENTS THE SKIPPED STATEMENTS FROM BEING PRINTED.\n\n&$A       SETC  'N'     ONLY 'Y' CAUSES INCLUSION\n...\n<NAME>    BEGTEST A\n          WTO   'OPT CODE EXCLUDED'\n<NAME>    ENDTEST ,\n\nSINCE THE SET SYMBOL &$A WAS SET TO 'N', THE 'WTO' WILL BE EXCLUDED.\n\nNOTE: WHEN YOU CODE A 'PRINT=YES/NO' PARAMETER ON THE BEGTEST\nSTATEMENT, THAT OPTION REMAINS IN EFFECT FOR THE REMAINING 'BEGTEST'\nMACROS UNTIL ANOTHER 'PRINT=YES/NO' CLAUSE IS ENCOUNTERED. IF YOU\nPREFER TO CONTROL THE PRINTING OF SKIPPED INSTRUCTIONS AT THE\nBEGINNING OF YOUR PROGRAM, YOU MAY DO SO BY:\n\n         GBLC  &$MPRSW\n&$MPRSW  SETC  'NO'       TO SUPPRESS PRINTING SKIPPED INSTRUCTIONS\n&$MPRSW  SETC  'YES'      TO CAUSE THE PRINTING SKIPPED INSTRUCTIONS\n\nCHOOSE THE 'SETC' STATEMENT THAT PROVIDES THE OPTION THAT YOU WANT.\n\nENDTEST\nTHIS ONE NEEDS TO BE USED ONLY IN CONJUNCTION WITH THE 'BEGTEST'\nMACRO. IT IS USED TO END A GROUP OF CONDITIONALLY INCLUDED LINES OF\nCODE. PLEASE SEE THE DOCUMENTATION FOR 'BEGTEST'.\n\nEXECUTE\nTHIS ONE MAKES IT POSSIBLE TO CONSTRUCT AN 'EX' INSTRUCTION WITH ONE\nLINE OF CODE.  IF YOU'VE NEVER USED THE 'EX' INSTRUCTION, YOU'RE\nPROBABLY BETTER OFF SKIPPING THE REST OF THIS 'EXECUTE' DOCUMENTATION.\nIF YOU HAVE ALREADY USED IT, OR IF YOU'RE VERY BRAVE, THEN HERE GOES.\nIT REQUIRES THREE POSITIONAL OPERANDS. THE FIRST IS A GPR (IT DOESN'T\nHAVE TO BE WITHIN PARENTHESES, SINCE IT HAS TO BE A GPR), THE SECOND\nIS THE OP CODE FOR THE INSTRUCTION BEING 'EX'ECUTED, AND THE THIRD\nCONSISTS OF ALL OF THE OPERANDS OF THE INSTRUCTION BEING 'EX'ECUTED,\nAND THEY MUST BE ENCLOSED WITHIN PARENTHESES.\n\n <NAME>   EXECUTE R15,MVC,(FIELDA(0),FIELDB)\n+<NAME>   EX     R15,$EX1234         GENERATED\n+...\n+$EX1234  MVC   FIELDA(0),FIELDB     GENERATED\n\nNOTE THAT THE THIRD OPERAND IS GENERATED OUT-OF-LINE.\n\n                            INTERNAL\n\nTHESE MACRO DEFINITIONS ARE FURNISHED WITHIN THE COPY MEMBER '$MGBLDEF' AND\nARE INCLUDED INTO THE ASSEMBLY THE FIRST TIME THAT A COPY STATEMENT FOR THAT\nMEMBER IS ENCOUNTERED IN YOUR PROGRAM.  THUS THE FIRST 'IF' STATEMENT (OR\nOTHER STRUCTURED MACRO) WILL CAUSE THESE TO BE INCLUDED.\n\n                            STRUCTURED\n\nTHIS SET OF MACROS CAUSES A CONDITIONAL AND/OR REPETITIVE EXECUTION OF\nA GROUP OF ONE OR MORE INSTRUCTIONS.  FOR CONVENIENCE, LET'S CALL A\nGROUP OF INSTRUCTIONS THAT MIGHT OR MIGHT NOT BE EXECUTED ONE TIME, OR\nMULTIPLE TIMES, A 'CR-GROUP', FOR 'C'ONDITIONAL/'R'EPETITIVE.\n\nMNOTE STATEMENTS ARE ISSUED WHEN A POTENTIAL PROBLEM IS DETECTED. IF\nTHE MNOTE CODE IS 0 THEN IT REPRESENTS AN INFORMATIONAL MESSAGE. IF IT\nIS 4, THEN THE CODE GENERATED IS PROBABLY CORRECT, BUT SHOULD BE\nEXAMINED. IF IT IS 8, THEN A LIKELY ERROR EXISTS AND SHOULD BE\nCORRECTED.  IF IT IS 12, THEN THE CODE GENERATED WILL BE INCORRECT\nAND/OR INCOMPLETE, AND THE STATEMENT RESPONSIBLE MUST BE CORRECTED.\n\nIF\nTHIS IS THE HEART OF THE STRUCTURED MACROS. IT SUPPORTS THE\nCONDITIONAL EXECUTION OF A CR-GROUP BASED ON ONE OR MORE TESTS. EACH\nTEST PHRASE, CONTAINED WITHIN PARENTHESES, MUST CONSIST OF AN OP-CODE,\nA FIRST OPERAND, A SECOND OPERAND, AND A CONDITION. (NOTE OP-CODES\nWITH OTHER THAN TWO OPERANDS ARE SUPPORTED, BUT THE OP-CODE MUST\nALWAYS BE FIRST AND THE CONDITION MUST ALWAYS BE LAST WITHIN THE\nPHRASE.)  IN THE SIMPLE CASE, ONE CONDITIONAL PHRASE IS FOLLOWED BY\nA 'THENDO'.  IN COMPLEX CASES, EACH ODD-NUMBERED PARAMETER MUST\nCONTAIN THE INSTRUCTION SETTING THE CONDITION CODE AS SUBPARAMETERS\nWITHIN PARENTHESES, AND EACH EVEN-NUMBERED PARAMETER MUST BE AN\n'OR', AN 'AND', OR THE LAST PHRASE MUST BE A 'THENDO' (IF YOU OMIT\nTHE 'THENDO', THEN YOU WILL GET AN INFORMATIONAL MNOTE STATEMENT):\n\n <NAME>   IF    (CLC,FIELDA,FIELDB,E),THENDO\n            ...\n          ENDIF ,\n\n <NAME>   IF    (CLC,FIELDA,FIELDB,E),OR,                     X\n                (CLC,FIELDA,FIELDC,E),THENDO\n            ...\n          ENDIF ,\n\nNOTE THAT THE FORMAT OF THE CONDITIONAL PHRASE IS FIXED IN THAT:\n1. THE OP-CODE IS ALWAYS THE FIRST OPERAND\n2. THE CONDITION IS ALWAYS LAST\n3. THE OPERANDS ARE ALWAYS IN THEIR ORDINAL POSITIONS IN BETWEEN\n4. IF YOU SET GLOBAL TYPE A SET SYMBOL &$MBLATH TO A VALUE GREATER\n   THAN ZERO, THEN VARIOUS DIAGNOSTICS ARE MNOTED DURING THE MACRO\n   GENERATION PHASE. IF YOU SET IT TO 10, THEN NESTING IS NOTED\n   (SIMILAR TO COBOL IF-STATEMENT LEVELS LISTED TO THE LEFT OF THE\n   SOURCE STATEMENTS). IF YOU SET IT TO 12, THEN THE RECURSION\n   LEVEL OF THE 'IF' STATEMENT IS MNOTED. TO DO THIS, YOU HAVE TO\n   DEFINE THE SET SYMBOL IN OPEN CODE. THIS GIVES YOU THE\n   COMMUNICATION LINK TO THE SAME NAME DEFINED WITHIN THE MACRO\n   LIBRARY:\n\n         GBLA  &$MBLATH\n&$MBLATH SETA  10              SHOW NESTING LEVELS\n                     - OR -\n&$MBLATH SETA  12              SHOW NESTING AND RECURSION LEVELS\n\nEXAMPLES:\n\n         IF   (UPT,Z),THENDO          INST WITH ZERO OPERANDS\n+        UPT  ,\n+        JNZ   ...\n\n         IF   (SSCH,12,Z),THENDO                ONE OPERAND\n+        SSCH 12\n+        JNZ  ...\n\n         IF   (CLI,LCLSW,C'0',E),THENDO         TWO OPERANDS\n+        CLI  LCLSW,C'0'\n+        JNE  ...\n\n         IF   (SRP,PFIELD1,PFIELD2,5,Z),THENDO  THREE OPERANDS\n+        SRP  PFIELD1,PFIELD2,5\n+        JNZ  ...\n\nIF YOU CODE THE WRONG NUMBER OF PARAMETERS FOR A PARTICULAR OP-CODE,\nTHEN 'THE RESULTS ARE UNPREDICTABLE', ALTHOUGH GENERALLY THE MACRO\nWILL EXPAND WITHOUT NOTING THE ERROR AND YOU WILL GET AN ERROR ON\nTHE GENERATED INSTRUCTION.\n\nNOTE THAT THE OP-CODE 'CLC' WILL BE USED THROUGHOUT THESE EXAMPLES.\nWHEN YOU CODE YOUR PROGRAM, USE WHATEVER INSTRUCTION IS APPORPRIATE,\nSO LONG AS IT IS ONE THAT SETS THE PROCESSOR'S CONDITION CODE FIELD.\nIT COULD EVEN BE A MACRO STATEMENT, SO LONG AS THE CONDITION CODE\nIS SET BY ONE OF THE INSTRUCTIONS GENERATED BY THE MACRO EXPANSION SO\nTHAT IT CAN BE TESTED BY THE BRANCH-ON-CONDITION THAT FOLLOWS.\n\nIN THIS EXAMPLE, IF FIELDA IS EQUAL TO FIELDB, THEN THE CR-GROUP\nWILL BE EXECUTED.  THE CONDITION, CODED AS THE LAST POSITIONAL\nSUB-PARAMETER, CAN BE ANY OF THE EXTENDED BRANCH NMEMONICS:\n\n  E NE H NH L NL M NM O NO P NP Z NZ\n\nIN THE ABOVE EXAMPLE, THE MACRO EXPANDS INTO:\n\n <NAME>   IF    (CLC,FIELDA,FIELDB,E),THENDO\n+<NAME>   CLC   FIELDA,FIELDB    GENERATED\n+         BNE   $TAG             BRANCH AROUND 'IF' GROUP\n          ...                    YOUR INSTRUCTIONS\n          ENDIF ,\n+$TAG     DS    0H\n\nNOTE: IN THIS SIMPLE EXAMPLE, THE CONDITION 'E' STATES THAT THE IF-GROUP\nIS TO BE EXECUTED IF THE 'CLC' RESULTS IN AN 'EQUAL'.  TO CAUSE THIS\nLOGIC TO OCCUR, A BRANCH ON THE OPPOSITE CONDITION IS CREATED TO BYPASS\nTHE IF-GROUP, MEANING THAT PROGRAM EXECUTION 'FALLS THROUGH' INTO THE\nIF-GROUP WHEN THE SPECIFIED CONDITION IS MET.\n\nLIKEWISE, FOR THE PHRASE '(CLC,FIELDA,FIELDB,NE)', THE BYPASSING BRANCH\nINSTRUCTION GENERATED WOULD BE A 'BE    $TAG'.\n\nNOTE: '$TAG' INDICATES THAT THE MACRO GENERATION PROCESS WILL GENERATE\nAN UNIQUE TAG, WHOSE NAME BEGINS WITH '$', AND ENDS WITH A UNIQUE NUMBER\nOBTAINED FROM A SYSTEM COUNTER.\n\nIF YOU HAD CODED 'NE' AS THE CONDITION, THEN IT WOULD EXPAND TO:\n\n <NAME>   IF    (CLC,FIELDA,FIELDB,NE),THENDO\n+<NAME>   CLC   FIELDA,FIELDB    GENERATED\n+         BE    $TAG             BRANCH AROUND 'IF' GROUP\n          ...                    YOUR INSTRUCTIONS\n          ENDIF ,\n+$TAG     DS    0H\n\n     TO EXECUTE THE CR-GROUP IF EITHER ONE OF TWO CONDITIONS IS\nTRUE, THE FORMAT IS:\n\n <NAME>   IF    (CLC,A,B,NE),OR,(CLC,C,D,NE),THENDO\n\n     ALTERNATE FORMAT:\n                                                               72\n <NAME>   IF    (CLC,A,B,NE),OR,                                C\n           (CLC,C,D,NE),THENDO\n\n     NOTE THAT, AS SHOWN IN THE EXAMPLES, YOU NEED TO ENCLOSE THE\nCONDITIONAL PHRASES WITHIN PARENTHESES, AND THAT YOU DO NOT\nENCLOSE THE CONNECTING PHRASES ('OR' OR 'AND') OR THE FINAL\n'THENDO' WITHIN PARENTHESES.\n\n     SINCE 'AND' TAKES PRECEDENCE OVER 'OR', IN THE FOLLOWING\nEXAMPLE, THE CR-GROUP IS PERFORMED IF THE FIRST TEST IS TRUE, OR\nIF BOTH THE SECOND AND THIRD ARE TRUE:\n\n <NAME>   IF    (CLC,A,B,E),OR,                                 C\n                (CLC,C,D,E),AND,                                C\n                (CLC,E,F,E),THENDO\n\n     IF YOU NEED TO CREATE A SUB-GROUP OF PHRASES CONNECTED BY\n'OR' CONNECTORS, AND THEN CONNECT THIS SUB-GROUP VIA AN 'AND'\nWITH ANOTHER CONDITION (WHICH MAY ITSELF CONSIST OF ANOTHER\nSUB-GROUP OF CONDITIONS), THEN YOU NEED TO ENCLOSE THE ENTIRE\nSUB-GROUP WITHIN AN ADDITIONAL PAIR OF PARENTHESES:\n\n                * <-NESTING PARENTHESES -> *\n <NAME>   IF    ((CLC,A,B,E),OR,(CLC,C,D,E)),AND,               C\n                (CLC,E,F,E),THENDO\n\n     THE AUTHOR OF THESE MACROS PREFERS THE FORMAT:\n\n <NAME>   IF    ((CLC,A,B,E),OR,                                C\n                (CLC,C,D,E)),AND,                               C\n                (CLC,E,F,E),THENDO\n\n     I GUESS THE BOTTOM LINE IS THAT S/390 ASSEMBLER IS SOMEWHAT OF A\nPAIN, NO MATTER HOW YOU FORMAT THE STATEMENTS!\n\n     GROUPS OF EXPRESSIONS MAY BE NESTED AS DEEPLY AS REQUIRED\nTO DEFINE THE LOGIC DESIRED. THE LIMIT IS THE LENGTH OF A SINGLE\nOPERAND SUPPORTED BY THE ASSEMBLER BEING USED.\n\n     NOTE THAT THE CONDITIONAL PHRASES ARE EXECUTED IN THE ORDER\nTHAT THEY ARE WRITTEN.  THEREFORE, IF THERE ARE ONE OR MORE PHRASES\nTHAT MORE OFTEN THAN NOT WOULD RESULT IN AN ABBREVIATED PASS THRU THE\nCONSTRUCT, THEN YOU SHOULD CODE THOSE PHRASES FIRST (MAINTAINING THE\nLOGIC REQUIRED FOR THE DESIRED RESULT, OF COURSE!).\n\n     EACH CR-GROUP MUST BE TERMINATED WITH AN 'ENDO' STATEMENT\nOR AN 'ELSE' - 'ENDELSE' COMBINATION:\n\n          ENDIF ,\n                 - OR -\n          ELSE  ,\n     ... ADDITIONAL INSTRUCTIONS TO BE EXECUTED IF 'IF' FAILS\n          ENDELSE ,  (OR ENDIF - EITHER IS ACCEPTABLE AFTER AN 'ELSE')\n\n     ALTERNATIVELY, A CR-GROUP CAN BE TERMINATED AS FOLLOWS:\n\n          ELSEIF  (CLC,G,H,E),THENDO ...\n            ...\n          ELSEIF  (CLC,I,J,E),THENDO ...\n            ...\n          ELSE  ,\n            ...\n          ENDELSE ,\n\n     ANY NUMBER OF 'ELSEIF' STATEMENTS CAN FOLLOW THE ORIGINAL\n     'IF' STATEMENT. THERE MAY BE (BUT NEED NOT BE) ONE AND ONLY\n     ONE 'ELSE' STATEMENT FOLLOWING THE FINAL 'ELSEIF'. THE ENTIRE\n     GROUP IS TERMINATED WITH ONE 'ENDIF' OR 'ENDELSE'.\n\nTHE 'ELSEIF' IS THE AUTHOR'S CURRENT FEEBLE ATTEMPT AT PROVIDING THE\nFUNCTIONALITY OF THE 'CASE' (C/C++) OR 'EVALUATE' (COBOL).\n\nTHENDO\nTHE SIMPLIST OF THESE IS THE 'THENDO' MACRO THAT MUST BE TERMINATED BY\nAN 'ENDO':\n         CLC   FIELDA,FIELDB\n         THENDO E\n         ...\n         ENDO\n\nTHE STATEMENTS REPRESENTED BY THE '...' WILL BE EXECUTED ONLY IF THE\n'CLC' RESULTED IN AN 'E'. OPTIONALLY YOU MAY CODE AN 'ELSE' STATEMENT,\nAND/OR ONE OR MORE 'ELSEDO' STATEMENTS:\n\n         TRT   FIELDA,TABLE1\n         THENDO L       DO IF NON-ZERO FUNCTION AND NOT LAST ARG\n         ...\n         ELSEDO H       DO IF NON-ZERO FUNCTION AND LAST ARG\n         ...\n         ELSEDO E       DO IF ALL FUNCTION BYTES ZERO\n         ...\n         ENDO\n\nSINCE THE 'TRT' CAN ONLY GENERATE CC'S OF 0, 1, OR 2, THAT LAST\n'ELSEDO E' COULD HAVE BEEN REPLACED BY 'ELSE'.  AT ANY RATE, THIS IS\nA VIABLE WAY TO TEST VALUES OF THE CONDITION CODE THAT ARE SET BY ONE\nINSTRUCTION.  AS YOU WILL SEE WITH THE 'IF' STATEMENT, THE\nINSTRUCTION(S) THAT SET THE CC AND THE TEST FOR THE VALUE OF THE CC\nALL FORM PART OF THE SAME STATEMENT, SO THAT IT IS PROBABLY BETTER\nTO USE THE 'IF' AND 'ELSEIF' WITH INSTRUCTIONS THAT DO NOT MODIFY THEIR\nOPERANDS (SUCH AS 'CLC' OR 'TM' ETC.).\n\nEACH CR-GROUP MUST BE HEADED BY ONE OF THE FOLLOWING MACRO STATEMENTS:\n\n  AFTER      DO     EVERY      FIRST      IF        THENDO\n\nAND MUST BE TERMINATED BY ONE OF THE FOLLOWING:\n\n  ENDAFTER   ENDO   ENDEVERY   ENDFIRST   ENDIF\n\nIT IS SOMEWHAT OVERSIMPLIFYING TO SAY THAT ALL OF THE ENDXXXXX MACROS\nSIMPLY INVOKE 'ENDO', BUT THE TRUTH IS THAT THE INDIVIDUAL ENDXXXXX\nMACROS ARE MORE FOR PROGRAM DOCUMENTATION THAN THEY ARE FOR INTERNAL\nLOGIC DIFFERENCES. SO, IF YOU END AN CR-GROUP WITH AN 'ENDAFTER'\nMACRO, NO DIAGNOSTICS WILL BE ISSUED AND YOUR PROGRAM WILL WORK THE\nSAME AS IF YOU HAD CODED AN 'ENDIF'.\n\nCR-GROUPS MAY BE NESTED TO ANY DESIRED LEVEL:\n\n          IF    ...\n          ...\n            DO    ...\n            ...\n            ENDO  ,\n          ...\n          ENDIF ,\n\nYOU MAY FIND IT EFFECTIVE TO INDENT AT EACH LEVEL OF NESTING, BUT\nBEWARE - THE CONTINUATION COLUMN IS ALWAYS THE SAME (16 IS THE\nDEFAULT).\n\nTHERE ARE TWO ADDITIONAL SIGNIFICANT MACROS THAT CAN BE USED WITHIN\nTHIS PACKAGE OF STRUCTURED PROGRAMMING MACROS.  THE 'ELSEIF' MACRO CAN\nBE USED FOLLOWING AN 'IF' OR ANOTHER 'ELSEIF' MACRO, AND SUPPORTS THE\nSAME TYPES OF LOGIC THAT THE 'IF' MACRO SUPPORTS.  THE 'ELSE' MACRO\nCAN FOLLOW AN 'IF', 'ELSEIF', 'AFTER', 'EVERY' OR 'FIRST' MACRO, AND\nALLOWS ITS CR-GROUP TO BE EXECUTED IF ALL OF THE PRECEDING CR-GROUPS\nWERE NOT EXECUTED.\n\nIN GENERAL, I WOULD SUGGEST THAT YOU NOT CREATE A NAME FIELD FOR A MACRO\nTHAT ENDS A CR-GROUP. IT MIGHT BE PERMISSIBLE IF YOU NEED TO EXIT THE\nCR-GROUP FROM SOMEWHERE DEEP INSIDE IT, BUT AS SOON AS YOU START NAMING\nSTATEMENTS, IT SIGNALS EVEN MORE BAD HABITS TO COME.\n\nAFTER\nTHIS MACRO HEADS A CR-GROUP THAT WILL BE SKIPPED FOR THE FIRST 'N'\nPASSES THROUGH THIS SECTION OF CODE, AND THEN EXECUTED EVERY PASS\nTHROUGH THE CODE FROM THEN ON.  'N' MUST BE A NUMERIC SELF-DEFINING\nTERM. AN 'ELSE' CLAUSE IS OPTIONAL. SEE ALSO 'EVERY' AND 'FIRST'.\n\n <NAME>  AFTER 1000000\n            ...\n         ENDAFTER ,\n\nDO\nTHIS ONE PROVIDES REPETITIVE EXECUTION OF A CR-GROUP. THERE ARE\nSEVERAL OPTIONS: THE FIRST IS TO CODE A NUMERIC SELF-DEFINING TERM,\nWHICH CAUSES THE CR-GROUP TO BE EXECUTED THAT NUMBER OF TIMES:\n\n <NAME>   DO    5\n            ...\n          ENDO  ,\n\nA SLIGHT VARIATION IS TO CODE:\n\n <NAME>  DO    FOREVER\n           ...\n         ENDO  ,\n\nTHIS CAUSES THE CR-GROUP TO BE CONTINUOUSLY EXECUTED UNTIL SOMETHING\nEITHER WITHIN THE LOOP OR SOMETHING OUTSIDE THE PROGRAM (TIME\nEXCEEDED, ETC) CAUSES THE LOOP TO BE BROKEN.\n\nIF YOU CODE:\n\n <NAME>  DO    MYVARBL\n           ...\n         ENDO  ,\n\nTHEN 'MYVARBL' MUST BE A PACKED DECIMAL VARIABLE WHICH YOU HAVE\nALREADY INITIALIZED TO THE VALUE FOR THE NUMBER OF TIMES THAT YOU\nWANT THIS CR-GROUP REPEATED. BE VERY CAREFUL ABOUT MODIFYING THIS\nVARIABLE FROM WITHIN THE LOOP. ITS VALUE IS CAPTURED ONLY AT THE\nBEGINNING OF THE EXECUTION OF THE CR-GROUP, AND ANY CHANGE TO THE\nVALUE OF THE VARIABLE WILL TAKE EFFECT THE NEXT TIME THE 'DO'\nSTATEMENT IS ENCOUNTERED.\n\nIF YOU WANT TO REPEAT A CR-GROUP BASED ON ONE OR MORE CONDITIONS,\nTHEN YOU CAN USE EITHER ONE OF THE FOLLOWING:\n\n <NAME>  DO    UNTIL=(...)\n           ...\n         ENDO  ,\n\n         .. OR ..\n\n <NAME>  DO    WHILE=(...)\n           ...\n         ENDO  ,\n\nIN THE FIRST OF THESE TWO EXAMPLES, THE CR-GROUP WILL BE EXECUTED\nREPETITIVELY UNTIL ONE OR MORE OF THE CONDITIONS IS MET. IN THE\nSECOND, IT WILL BE EXECUTED SO LONG AS ONE OR MORE OF THE CONDITIONS\nIS MET.  IN BOTH OF THESE EXAMPLES, THE VALUES WITHIN THE PARENTHESES\nARE THE SAME AS FOR THE 'IF' MACRO. PLEASE SEE ITS DOCUMENTATION FOR\nTHE DETAILS.  THE ONLY DIFFERENCE BETWEEN THE OPERANDS HERE AND FOR\nTHE 'IF' MACRO IS THAT, IF THE CONDITION IS COMPLEX, THAT IS, IF IT\nCONSISTS OF MULTIPLE CONDITIONS CONNECTED WITH 'AND' AND/OR 'OR'\nCLAUSES, THEN THE ENTIRE OPERAND MUST BE ENCLOSED WITHIN ONE\nADDITIONAL LEVEL OF PARENTHESES:\n\n <NAME>   DO    UNTIL=((...),OR,(...))\n                      *              *  <== REQUIRED IF COMPLEX\n            ...\n          ENDO  ,\n\nONE ADDITIONAL KEYWORD OPERAND IS AVAILABLE:\n\n <NAME>   DO    UNTIL=(...),TEST=AFTER\n            ...\n          ENDO  ,\n\n          .. OR ..\n\n <NAME>   DO    WHILE=(...),TEST=AFTER\n            ...\n          ENDO  ,\n\nTHE 'TEST=AFTER' CAUSES THE CR-GROUP TO BE EXECUTED ONE TIME BEFORE\nTHE CONDITIONAL TESTS ARE MADE. DEFAULT IS 'TEST=BEFORE', WHERE THE\nCR-GROUP MIGHT NOT BE EXECUTED EVEN ONCE, DEPENDING ON THE INITIAL\nCONDITIONS.\n\nDOEXIT\nTHE 'DOEXIT' MACRO CAUSES EXECUTION TO TRANSFER TO THE FIRST INSTRUCTION\nFOLLOWING THE MATCHING 'ENDO' STATEMENT:\n\n <NAME>   DO    UNTIL=(...)\n            ...\n            DOEXIT ,\n            ...\n          ENDO  ,\n\nIF THERE IS NESTED LOGIC CONSISTING OF 'IF' STATEMENTS AND 'DO'\nSTATEMENTS, A 'DOEXIT' STATEMENT ALWAYS TRANSFERS CONTROL TO THE\nSTATEMENT FOLLOWING THE INNERMOST 'DO' STATEMENT:\n\n<NAME>    DO    UNTIL=(...)\n            ...\n            IF    (...),THENDO\n              ...\n              DOEXIT , TRANSFERS TO STATEMENT FOLLOWING .. |\n              ...                                          |\n              DO    WHILE=(...)                            |\n                ...                                        |\n                DOEXIT , TRANSFERS TO STMT FOLLOWING |     |\n                ...                                  |     |\n              ENDO  ,                 <---------------     |\n              ...                                          |\n            ENDIF ,                                        |\n            ...                                            |\n          ENDO  ,                     <---------------------\n\nDONEXT\nTHE 'DONEXT' MACRO TRANSFERS EXECUTION TO THE LOGIC CONTROLLING THE DO\nSTATEMENT FOR THE NEXT ITERATION. DEPENDING ON THE CONDITIONS BEING\nTESTED, THE CR-GROUP MIGHT OR MIGHT NOT BE EXECUTED AGAIN.\n\n <NAME>   DO    UNTIL=(...)\n            ...\n            DONEXT ,\n            ...\n          ENDO  ,\n\nIF THERE IS NESTED LOGIC CONSISTING OF 'IF' STATEMENTS AND 'DO'\nSTATEMENTS, A 'DONEXT' STATEMENT ALWAYS TRANSFERS CONTROL TO THE\nSTATEMENT FOLLOWING THE INNERMOST 'DO' STATEMENT:\n\n<NAME>    DO    UNTIL=(...)\n            ...\n            IF    (...),THENDO\n              ...\n              DONEXT , TRANSFERS TO STATEMENT FOLLOWING .. |\n              ...                                          |\n              DO    WHILE=(...)                            |\n                ...                                        |\n                DONEXT , TRANSFERS TO STMT FOLLOWING |     |\n                ...                                  |     |\n              ENDO  ,                 <---------------     |\n              ...                                          |\n            ENDIF ,                                        |\n            ...                                            |\n          ENDO  ,                     <---------------------\n\nELSE\nTHIS MACRO MAY BE CODED ONLY WITHIN A CR-GROUP HEADED BY AN 'AFTER',\n'ELSEIF', 'EVERY' OR 'FIRST' CR-GROUP HEADER.  IT CAUSES EXECUTION OF\nITS CR-GROUP IF ALL OF THE PREVIOUS CR-GROUPS HAVE BEEN BYPASSED:\n\n <NAME>   AFTER 1000000\n            ...             EXECUTED AFTER 1,000,000 PASSES\n          ELSE  ,\n            ...             EXECUTED FIRST 1,000,000 PASSES\n          ENDELSE ,\n\nELSEIF\nTHIS MACRO MAY FOLLOW ONLY ANOTHER 'ELSEIF' STATEMENT, OR AN 'IF'\nSTATEMENT. IT SUPPORTS ALL THE OPTIONS OF THE 'IF' STATEMENT. PLEASE\nSEE THE 'IF' STATEMENT FOR THE DETAILS.\n\n <NAME>   IF    (...),THENDO\n            ...\n          ELSEIF (...),THENDO\n            ...\n          ENDELSE ,\n\nENDAFTER\nENDELSE\nENDEVERY\nENDFIRST\nENDIF\nENDO\n\nTHESE MACROS ARE EQUIVALENT, AND SHOULD BE USED TO END THEIR\nRESPECTIVE TYPES OF CR-GROUPS. THE ONE 'INTERESTING' PARAMETER IS THE\n'DOGROUP=' KEYWORD.  IF YOU NAMED A PREVIOUS CR-GROUP HEADER MACRO (SUCH\nAS 'IF' OR 'DO'), AND YOU HAVE NESTED CR-GROUPS, THEN YOU MAY TERMINATE\nMULTIPLE CR-GROUPS WITH ONE 'ENDO' MACRO BY NAMING THE OUTERMOST GROUP\nTHAT YOU WANT TO TERMINATE, AND THEN NAMING THAT GROUP ON THE 'ENDO'\nMACRO:\n\n MAINGRP IF    (...),THENDO\n           ...\n           IF    (...),THENDO\n             ...\n         ENDIF DOGROUP=MAINGRP\n\nIF YOU WANT TO TERMINATE ALL CR-GROUPS, THEN CODE THE 'MAGIC' KEYWORD:\n\n MAINGRP IF    (...),THENDO\n           ...\n           IF    (...),THENDO\n             ...\n         ENDIF DOGROUP=*ALL*\n\nSINCE '*ALL*' IS NOT A VALID ASSEMBLER TAG, IT CAN BE SAFELY USED AS\nTHE FLAG TO INDICATE THAT ALL CURRENT CR-GROUPS ARE TO BE TERMINATED.\n\nEVERY\nTHIS MACRO HEADS A CR-GROUP THAT WILL BE EXECUTED EVERY 'N'TH PASS\nTHROUGH THIS SECTION OF CODE. 'N' MUST BE A NUMERIC SELF-DEFINING TERM.\nAN 'ELSE' CLAUSE IS OPTIONAL. SEE ALSO 'AFTER' AND 'FIRST'.\n\n <NAME>  EVERY 1000000\n            WTO   'ANOTHER 1,000,000 PASSES'\n         ENDEVERY ,\n\nFIRST\nTHIS MACRO HEADS A CR-GROUP THAT WILL BE EXECUTED FOR THE FIRST 'N'\nPASSES THROUGH THIS SECTION OF CODE, AND THEN SKIPPED EVERY PASS\nTHROUGH THE CODE FROM THEN ON.  'N' MUST BE A NUMERIC SELF-DEFINING\nTERM. AN 'ELSE' CLAUSE IS OPTIONAL. SEE ALSO 'AFTER' AND 'FIRST'.\n\n <NAME>  FIRST 1000000\n            ...\n         ENDAFTER ,\n\nITS DESIGNED USE IS TO DO STUFF ONLY ON THE FIRST PASS THROUGH A\nSECTION OF CODE\n\n <NAME>  FIRST 1\n           OPEN  (...)\n         ENDFIRST ,\n\nTHENDO\nTHIS WAS THE ORIGINAL STRUCTURED MACRO OF THIS PACKAGE.  IT IS NOT SO\nPOWERFUL AS THE NEWER ONES, BUT YOU MIGHT FIND SOME USE FOR IT. ITS ONLY\nPOSITIONAL PARAMETER MUST BE ONE OF THE CONDITIONS THAT YOU CAN APPEND\nTO THE 'B' TO CREATE ONE OF THE EXTENDED BRANCH INSTRUCTIONS, SUCH AS\n'E'.  PLEASE REFER TO THE DOCUMENTATION FOR THE 'IF' MACRO FOR A\nCOMPLETE LIST.\n\nTHIS MACRO DEPENDS ON A PREVIOUS INSTRUCTION IN THE PROGRAM, SUCH AS A\n'CLR', TO SET THE CONDITION CODE. ITS CR-GROUP WILL THEN BE EXECUTED IF\nTHE OPERAND SATISFIES THE SETTING OF THE CONDITION CODE:\n\n          CLR   R5,R6\n <NAME>   THENDO E\n            ...\n          ENDO  ,\n\n          -- OR --\n\n          CLC   R5,R6\n <NAME>   THENDO E\n            ...\n          ELSE  ,\n            ...\n          ENDO  ,\n\nIN THIS EXAMPLE, THE FIRST CR-GROUP WILL BE EXECUTED IF R5 = R6, AND\nTHE SECOND WILL BE EXECUTED IF THEY ARE UNEQUAL.\n\nTHAT'S IT, FOLKS. NO OTHER OPTIONS FOR 'THENDO' (OTHER THAN NESTING).\n./ ADD NAME=DOEXIT   0107-02015-02016-0915-00014-00013-00000-GENTR02\n         MACRO\n&NAME    DOEXIT &DUMMY             XFER OUT OF INNERMOST DO-GROUP\n         COPY  $MGBLDEF            BRING IN THE CLOWNS\n         LCLA  &I                  LOCAL INTEGER VARIABLE\n&I       SETA  &$MDGLVL            START AT CURRENT NESTING LEVEL\n.LOOP010 AIF   (&I GT 0).CONT020   CONTINUE IF NOT ALL DONE\n         MNOTE 8,'NO DO-GROUP TO EXIT FROM' OOPS...\n         AGO   .MEND040            ALL WAS FOR NAUGHT\n.CONT020 AIF   ('&$MCVERB(&I)' EQ 'DO').GEN030 IS THIS LEVEL A 'DO'?\n&I       SETA  &I-1                NO - BACK UP TO NEXT OUTER LEVEL\n         AGO   .LOOP010            PROCESS NEXT OUTER GROUP\n.GEN030  ANOP  ,                   DANG, GOT A LIVE ONE!\n&NAME    J     $MDF&$MDGSEQ(&I)    B TO INSTRUCTION FOLLOWING 'ENDO'\n.MEND040 MEND\n./ ADD NAME=DONEXT   0100-02028-02028-0854-00014-00014-00000-GENTR02\n         MACRO\n&NAME    DONEXT &DUMMY\n         COPY  $MGBLDEF\n         LCLA  &I                  LOCAL INTEGER VARIABLE\n&I       SETA  &$MDGLVL            START AT CURRENT NESTING LEVEL\n.LOOP010 AIF   (&I GT 0).CONT020   CONTINUE IF NOT ALL DONE\n         MNOTE 8,'NO DO-GROUP TO DO NEXT ITERATION' OOPS...\n         AGO   .MEND040            ALL WAS FOR NAUGHT\n.CONT020 AIF   ('&$MCVERB(&I)' EQ 'DO').GEN030 IS THIS LEVEL A 'DO'?\n&I       SETA  &I-1                NO - BACK UP TO NEXT OUTER LEVEL\n         AGO   .LOOP010            PROCESS NEXT OUTER GROUP\n.GEN030  ANOP  ,                   DANG, GOT A LIVE ONE!\n&NAME    J     &$MLTAG(&I)         RETURN TO 'DO' CONTROL\n.MEND040 MEND\n./ ADD NAME=ELSE     0109-02015-02067-1609-00028-00027-00000-GENTR02\n         MACRO\n&NAME    ELSE  &DOGROUP=,&MNAME=ELSE  END OF POSITIVE TEST, START OF\n         COPY  $MGBLDEF            . NEGATIVE\n         LCLC  &X                  SET TO 'IF-FAILED' TAG\n         AIF   (&$MDGLVL GT 0).OK02\n         MNOTE 8,'''&MNAME'' IS VALID ONLY WITHIN AN IF-GROUP'\n         MNOTE 0,' - MACRO GENERATION TERMINATED'\n         MEXIT\n.OK02    $MENDDO1 DOGROUP=&DOGROUP\n         AIF   (&$MDGERR NE 0).QUIT GIVE UP IF ERROR\n         AIF  ('&$MLTAG(&$MDGLVL)' EQ '').SKIP30\n         MNOTE 8,'''&MNAME'' INVALID FOR ''DO'' - ENDO ASSUMED'\n         $MENDDO2 ,                PRETEND NO 'ELSEDO'\n         MEXIT\n.SKIP30  AIF   ('&$MIFELS(&$MDGLVL)' NE 'S').SKIP40\n         MNOTE 8,'''&MNAME'' INVALID FOLLOWING ''&MNAME'' -'\n         MNOTE '''ENDO'' INVOKED'\n         $MENDDO2                 JUST LIKE NO 'ELSEDO'\n         MEXIT\n.SKIP40  J     $MDS&$MDGSEQ(&$MDGLVL) BRANCH AROUND ELSE-GROUP\n&X       SETC  '$MDF&$MDGSEQ(&$MDGLVL)' 'IF-FAILED' TAG\n         AIF   ('&NAME' EQ '').SKIP50\n&NAME    DC    0H'0'         *=*=* BEGINNING OF 'ELSE' GROUP *=*=*\n.SKIP50  ANOP\n&X       DC    0H'0'         *=*=* BEGINNING OF 'ELSE' GROUP *=*=*\n&$MIFELS(&$MDGLVL) SETC 'S'\n&$MCVVERB(&$MDGLVL) SETC '&$MCVVERB(&$MDGLVL).ELSE'\n.QUIT    MEND\n./ ADD NAME=ELSEDO   0116-01222-02067-1610-00029-00035-00000-GENTR02\n         MACRO\n&NAME    ELSEDO &COND\n         COPY  $MGBLDEF\n         LCLC  &X\n         AIF   (&$MDGLVL GT 0).OK02\n         MNOTE 8,'''ELSEDO'' IS VALID ONLY WITHIN A THENDO-GROUP'\n         MNOTE 0,' - MACRO GENERATION TERMINATED'\n         MEXIT\n.OK02    AIF   ('&$MIFELS(&$MDGLVL)' EQ 'F').OK04\n         MNOTE 8,'''ELSEDO'' INVALID FOLLOWING ''ELSE'' STATEMENT'\n         MNOTE 0,' - MACRO GENERATION TERMINATED'\n         MEXIT\n.OK04    AIF   ('&$MLTAG(&$MDGLVL)' EQ '').OK20\n         MNOTE 8,'''ELSEDO'' INVALID FOLLOWING ''DO'' STATEMENT'\n         MNOTE 0,' - MACRO GENERATION TERMINATED'\n         MEXIT\n.OK20    AIF   ('&$MFNBR(&$MDGLVL)' NE '').OK30\n         $MGFNBR  ,                GET A UNIQUE TAG\n.OK30    J     $MDF&$MFNBR(&$MDGLVL) BRANCH AROUND IF-GROUP\n&X       SETC  '$MDF&$MDGSEQ(&$MDGLVL)'\n         AIF   ('&NAME' EQ '').SKIP40\n&NAME    DC    0H'0'               DEFINE TAG\n.SKIP40  ANOP\n&X       DC    0H'0'               TAG FOR 'ELSE'\n&X       SETC  '&$MDGNAM(&$MDGLVL)'\n&$MDGLVL SETA  &$MDGLVL-1          SO 'THENDO' CAN BUMP IT UP AGAIN\n         THENDO &COND\n&$MDGNAM(&$MDGLVL) SETC '&X'\n         MEND\n./ ADD NAME=ELSEIF   0110-01222-02067-1610-00036-00035-00000-GENTR02\n         MACRO\n&NAME    ELSEIF &EXP\n         COPY  $MGBLDEF\n         LCLC  &X\n         AIF   (&$MDGLVL GT 0).OK02\n         MNOTE 12,'''ELSEIF'' IS VALID ONLY WITHIN AN IF-GROUP - MACRO C\n               GENERATION TERMINATED'\n         MEXIT\n.OK02    AIF   ('&$MIFELS(&$MDGLVL)' EQ 'F').OK04\n         MNOTE 12,'''ELSEIF'' INVALID FOLLOWING ''ELSE'' STATEMENT - MAC\n               CRO GENERATION TERMINATED'\n         MEXIT\n.OK04    AIF   ('&$MLTAG(&$MDGLVL)' EQ '').OK20\n         MNOTE 12,'''ELSEIF'' INVALID FOLLOWING ''DO'' STATEMENT - MACRC\n               O GENERATION TERMINATED'\n         MEXIT\n.OK20    AIF   ('&$MFNBR(&$MDGLVL)' NE '').OK30\n         $MGFNBR  ,                GET A UNIQUE TAG\n.OK30    J     $MDF&$MFNBR(&$MDGLVL) BRANCH AROUND ELSEIF-GROUP\n&X       SETC  '$MDF&$MDGSEQ(&$MDGLVL)'\n&$MDGLVL SETA  &$MDGLVL-1          SO 'IF' CAN BUMP IT UP AGAIN\n         $MLVLMSG &$MDGLVL,NESTING\n         AIF   ('&NAME' EQ '').SKIP40\n&NAME    DC    0H'0'         *=*=* BEGINNING OF 'ELSEIF' GROUP *=*=*\n.SKIP40  ANOP\n&X       IF    &SYSLIST(1),&SYSLIST(2),&SYSLIST(3),&SYSLIST(4),        C\n               &SYSLIST(5),&SYSLIST(6),&SYSLIST(7),&SYSLIST(8),        C\n               &SYSLIST(9),&SYSLIST(10),&SYSLIST(11),&SYSLIST(12),     C\n               &SYSLIST(13),&SYSLIST(14),&SYSLIST(15),&SYSLIST(16),    C\n               &SYSLIST(17),&SYSLIST(18),&SYSLIST(19),&SYSLIST(20),    C\n               &SYSLIST(21),&SYSLIST(22),&SYSLIST(23),&SYSLIST(24),    C\n               &SYSLIST(25),&SYSLIST(26),&SYSLIST(27),&SYSLIST(28),    C\n               &SYSLIST(29),&SYSLIST(30),&SYSLIST(31),&SYSLIST(32)\n&$MDGNAM(&$MDGLVL) SETC '&NAME'    SET NAME FOR 'ENDIF'\n&$MCVERB(&$MDGLVL) SETC 'ELSEIF'   SET NAME FOR 'ENDIF'\n         MEND\n./ ADD NAME=ENDAFTER 0104-02015-02067-1610-00018-00017-00000-GENTR02\n         MACRO\n&NAME    ENDAFTER &DOGROUP=        INTERCHANGEABLE WITH 'ENDO' EXCEPT\n         COPY  $MGBLDEF            . FOR 'ELSEDO' CLAUSE\n         AIF   (&$MDGLVL GT 0).OK02\n         MNOTE 8,'''ENDAFTER'' INVALID OUTSIDE DO-GROUP'\n         MNOTE 0,' - MACRO GENERATION TERMINATED'\n         MEXIT\n.OK02    ANOP\n         LCLC  &X\n&X       SETC  '&$MCVERB(&$MDGLVL)'\n         AIF   ('&X' EQ 'AFTER').CONT010\n         AIF   ('&X' EQ 'AFTERELSE').CONT010\n         MNOTE 4,'''ENDAFTER'' USED TO TERMINATE ''&X'' GROUP'\n.CONT010 ANOP  ,\n&NAME    $MENDDO1 DOGROUP=&DOGROUP END ALL BUT HIGHEST LEVEL\n         AIF   (&$MDGERR NE 0).QUIT GIVE UP EASILY\n         $MENDDO2                  END FINAL LEVEL\n.QUIT    MEND\n./ ADD NAME=ENDELSE  0101-02015-02046-1624-00018-00017-00000-GENTR02\n         MACRO\n&NAME    ENDELSE &DOGROUP=         INTERCHANGEABLE WITH 'ENDO' EXCEPT\n         COPY  $MGBLDEF            . FOR 'ELSEDO' CLAUSE\n         AIF   (&$MDGLVL GT 0).OK02\n         MNOTE 8,'''ENDELSE'' INVALID OUTSIDE DO-GROUP'\n         MNOTE 0,' - MACRO GENERATION TERMINATED'\n         MEXIT\n.OK02    ANOP\n         LCLC  &X\n&X       SETC  '&$MCVERB(&$MDGLVL)'\n         AIF   ('&X' EQ 'ELSE').CONT010\n         AIF   ('&X' EQ 'ELSEIF').CONT010\n         MNOTE 4,'''ENDELSE'' USED TO TERMINATE ''&X'' GROUP'\n.CONT010 ANOP  ,\n&NAME    $MENDDO1 DOGROUP=&DOGROUP END ALL BUT HIGHEST LEVEL\n         AIF   (&$MDGERR NE 0).QUIT GIVE UP EASILY\n         $MENDDO2                  END FINAL LEVEL\n.QUIT    MEND\n./ ADD NAME=ENDEVERY 0104-02015-02067-1611-00018-00017-00000-GENTR02\n         MACRO\n&NAME    ENDEVERY &DOGROUP=        INTERCHANGEABLE WITH 'ENDO' EXCEPT\n         COPY  $MGBLDEF            . FOR 'ELSEDO' CLAUSE\n         AIF   (&$MDGLVL GT 0).OK02\n         MNOTE 8,'''ENDEVERY'' INVALID OUTSIDE DO-GROUP'\n         MNOTE 0,' - MACRO GENERATION TERMINATED'\n         MEXIT\n.OK02    ANOP\n         LCLC  &X\n&X       SETC  '&$MCVERB(&$MDGLVL)'\n         AIF   ('&X' EQ 'EVERY').CONT010\n         AIF   ('&X' EQ 'EVERYELSE').CONT010\n         MNOTE 4,'''ENDEVERY'' USED TO TERMINATE ''&X'' GROUP'\n.CONT010 ANOP  ,\n&NAME    $MENDDO1 DOGROUP=&DOGROUP END ALL BUT HIGHEST LEVEL\n         AIF   (&$MDGERR NE 0).QUIT GIVE UP EASILY\n         $MENDDO2                  END FINAL LEVEL\n.QUIT    MEND\n./ ADD NAME=ENDFIRST 0104-02015-02067-1611-00018-00017-00000-GENTR02\n         MACRO\n&NAME    ENDFIRST &DOGROUP=        INTERCHANGEABLE WITH 'ENDO' EXCEPT\n         COPY  $MGBLDEF            . FOR 'ELSEDO' CLAUSE\n         AIF   (&$MDGLVL GT 0).OK02\n         MNOTE 8,'''ENDFIRST'' INVALID OUTSIDE DO-GROUP'\n         MNOTE 0,' - MACRO GENERATION TERMINATED'\n         MEXIT\n.OK02    ANOP\n         LCLC  &X\n&X       SETC  '&$MCVERB(&$MDGLVL)'\n         AIF   ('&X' EQ 'FIRST').CONT010\n         AIF   ('&X' EQ 'FIRSTELSE').CONT010\n         MNOTE 4,'''ENDFIRST'' USED TO TERMINATE ''&X'' GROUP'\n.CONT010 ANOP  ,\n&NAME    $MENDDO1 DOGROUP=&DOGROUP END ALL BUT HIGHEST LEVEL\n         AIF   (&$MDGERR NE 0).QUIT GIVE UP EASILY\n         $MENDDO2                  END FINAL LEVEL\n.QUIT    MEND\n./ ADD NAME=ENDIF    0106-02015-02067-1611-00013-00010-00000-GENTR02\n         MACRO\n&NAME    ENDIF &ELSE,&DOGROUP=\n         COPY  $MGBLDEF\n         LCLC  &X\n&X       SETC  '&$MCVERB(&$MDGLVL)'\n         AIF   ('&X' EQ 'IF').CONT010\n         AIF   ('&X' EQ 'IFELSE').CONT010\n         AIF   ('&X' EQ 'ELSEIF').CONT010\n         MNOTE 4,'''ENDIF'' USED TO TERMINATE ''&X'' GROUP'\n.CONT010 ANOP  ,\n&$MCVERB(&$MDGLVL) SETC 'DO'       FAKE OUT 'ENDO' MACRO\n&NAME    ENDO  &ELSE,DOGROUP=&DOGROUP\n         MEND\n./ ADD NAME=ENDO     0107-02015-02092-1009-00038-00034-00000-GENTR02\n         MACRO\n&NAME    ENDO  &ELSE,&DOGROUP=    INTERCHANGEABLE WITH 'ENDELSE' EXCEPT\n         COPY  $MGBLDEF           . FOR 'ENDELSE' CLAUSE\n         LCLC  &X                  SET TO 'IF-FAILED' TAG\n         AIF   (&$MDGLVL GT 0).OK02\n         MNOTE 8,'''ENDO'' INVALID OUTSIDE DO-GROUP - MACRO GENERATION C\n               TERMINATED'\n         MEXIT\n.OK02    ANOP\n&X       SETC  '&$MCVERB(&$MDGLVL)'\n         AIF   ('&X' EQ 'DO').OK03\n         MNOTE 4,'''ENDO'' USED TO TERMINATE ''&X'' GROUP'\n.OK03    ANOP  ,\n&NAME    $MENDDO1 DOGROUP=&DOGROUP\n         AIF   (&$MDGERR NE 0).QUIT GIVE UP IF ERROR\n         AIF   ('&ELSE' NE '').NEXT10 NO 'ELSE' - END LAST LEVEL\n         $MENDDO2                 LAST LEVEL FOR THIS PASS\n         MEXIT\n.NEXT10  AIF   ('&ELSE' EQ 'ELSEDO').NEXT20 GO IF LEGIT 'ELSEDO'\n         MNOTE *,'ERROR IN PARM ''&ELSE'' - PARM IGNORED'\n         $MENDDO2                 JUST LIKE NO '&ELSE'\n         MEXIT\n.NEXT20  ANOP\n         AIF  ('&$MLTAG(&$MDGLVL)' EQ '').SKIP30\n         MNOTE 8,'''ELSEDO'' INVALID FOR ''DO'' - IGNORED'\n         $MENDDO2                 JUST LIKE NO '&ELSE'\n         MEXIT\n.SKIP30  ANOP\n         AIF   ('&$MIFELS(&$MDGLVL)' NE 'S').SKIP40\n         MNOTE 8,'''ELSEDO'' INVALID FOLLOWING ''ELSEDO'' - ''ENDO'' INC\n               VOKED'\n         $MENDDO2                 JUST LIKE NO 'ELSEDO'\n         MEXIT\n.SKIP40  J     $MDS&$MDGSEQ(&$MDGLVL) BRANCH AROUND ELSE-GROUP\n&X       SETC  '$MDF&$MDGSEQ(&$MDGLVL)' 'IF-FAILED' TAG\n&X       DC    0H'0'              TAG FOR 'IF' FAILURE\n&$MIFELS(&$MDGLVL) SETC 'S'       SET FOR 'ENDELSE'\n.QUIT    MEND\n./ ADD NAME=ENDTEST\n         MACRO\n&NAME    ENDTEST &DUMMY\n         AIF   ('&NAME' EQ '').MEND999\n&NAME    DS    0H                  TAG GENERATED BY 'ENDTEST' MACRO\n.MEND999 MEND\n./ ADD NAME=EQUATE   0101-02067-02067-1444-00011-00008-00000-GENTR02\n         MACRO\n         EQUATE\n         PUSH  PRINT               *=*=*=*=*=*=*=*=*=*=*=*=*=*=*\n         PRINT NOGEN               *=* HIDE REGISTER EQUATES *=*\n&I       SETA  0\n.LOOP010 ANOP\nR&I      EQU   &I\n&I       SETA  &I+1\n         AIF   (&I LT 16).LOOP010\n         POP   PRINT               *=*=*=*=*=*=*=*=*=*=*=*=*=*=*\n         MEND\n./ ADD NAME=EVERY    0113-01331-02070-1321-00023-00024-00000-GENTR02\n         MACRO\n&NAME    EVERY &VAR\n         COPY  $MGBLDEF            BRING IN THE CLOWNS\n&LCLV    SETC  '&VAR'              SET TO COUNT\n         AIF   ('&VAR'(1,1) GE '0').OK30 GO IF SELF-DEFINING\n         MNOTE 8,'''&VAR'' NOT SELF-DEFINING: 'EVERY' GROUP WILL BE PROC\n               CESSED EACH PASS THROUGH THIS SECTION OF CODE'\n&LCLV    SETC  '1'                 DO EVERY TIME\n.OK30    ANOP\n&$MDGLVL SETA  &$MDGLVL+1          INCREMENT LEVEL\n         $MLVLMSG &$MDGLVL,NESTING\n&$MDGSEQ(&$MDGLVL) SETC '&SYSNDX'\n&$MIFELS(&$MDGLVL) SETC 'F'\n&$MDGNAM(&$MDGLVL) SETC '&NAME'\n&$MCVERB(&$MDGLVL) SETC 'EVERY'\n&X       SETC  '$MDV&SYSNDX'       MAKE IT PRETTY\n&NAME    SP    &X,=P'1'            DECREMENT\n         JP    $MDF&SYSNDX         B IF NOT YET TIME\n         MVC   &X,=P'&LCLV'        RESET\n&$MLOCTR LOCTR                     FOLLOWING CODE TO BE IN WORK AREA\n&X       DC    P'&LCLV'            FREQUENCY COUNTER\n&SYSECT  LOCTR                     RESUME INSTRUCTION AREA\n         MEND\n./ ADD NAME=EXECUTE  0112-01236-02078-1624-00015-00024-00000-GENTR02\n         MACRO\n&N       EXECUTE &DUMMY            OPERANDS ACCESSED VIA &SYSLIST(N)\n         COPY  $MGBLDEF            GET STANDARD NAME FOR LOCTR\n         LCLC  &TEMP,&X,&OP        LOCAL SCRATCHPAD VARIABLES\n&X       SETC  '&SYSNDX'           FOR UNIQUENESS\n&N       EX    &SYSLIST(1),$EX&X   DO THE 'EX'ECUTE\n&TEMP    SETC  ','                 THIS WILL ALWAYS WORK\n         AIF   (K'&SYSLIST(3) LT 3).CONT010 GO IF ZERO OPERANDS\n&TEMP    SETC  '&SYSLIST(3)'(2,K'&SYSLIST(3)-2) FAILS IF ZERO OPERANDS\n.CONT010 ANOP\n&OP      SETC  '&SYSLIST(2)'       FOR BREVITY\n&$MLOCTR LOCTR ,                   OUT-OF-LINE STORAGE AREA\n$EX&X    &OP   &TEMP               'EX'ECUTED INSTRUCTION\n&SYSECT  LOCTR ,                   INSTRUCTION AREA\n         MEND\n./ ADD NAME=FIRST    0115-01331-02070-1324-00033-00034-00000-GENTR02\n         MACRO\n&NAME    FIRST &VAR\n         COPY  $MGBLDEF            BRING IN THE CLOWNS\n&LCLV    SETC  '&VAR'              SET TO COUNT\n         AIF   ('&VAR'(1,1) GE '0').OK30 GO IF SELF-DEFINING\n         MNOTE 8,'''&VAR'' NOT SELF-DEFINING: 'FIRST' GROUP WILL BE PROC\n               CESSED ONLY THE FIRST TIME THROUGH THIS SECTION OF CODE'\n&LCLV    SETC  '1'                 DO EVERY TIME\n.OK30    ANOP\n&$MDGLVL SETA  &$MDGLVL+1          INCREMENT LEVEL\n         $MLVLMSG &$MDGLVL,NESTING\n&$MDGSEQ(&$MDGLVL) SETC '&SYSNDX'\n&$MIFELS(&$MDGLVL) SETC 'F'\n&$MDGNAM(&$MDGLVL) SETC '&NAME'\n&$MCVERB(&$MDGLVL) SETC 'FIRST'\n&X       SETC  '$MDV&SYSNDX'       MAKE IT PRETTY\n         AIF   ('&LCLV' NE '1').SKIP030\n&NAME    TM    &X,X'01'            HAVE WE BEEN HERE BEFORE?\n         JO    $MDF&SYSNDX         B IF YES\n         OI    &X,X'01'            LEAVE TRACKS\n&$MLOCTR LOCTR                     ENTER WORK AREA\n&X       DC    X'00'               SET TO X'01' FIRST PASS\n&SYSECT  LOCTR                     RESUME INSTRUCTION AREA\n         MEXIT\n.SKIP030 ANOP\n&X       SETC  '$MDV&SYSNDX'       MAKE IT PRETTY\n&NAME    CP    &X,=P'0'            FINISHED?\n         JNH   $MDF&SYSNDX         B IF YES\n         SP    &X,=P'1'            DECREMENT BY 1\n&$MLOCTR LOCTR                     FOLLOWING CODE TO BE IN WORK AREA\n&X       DC    P'&LCLV'            EXECUTION TIMES COUNTER\n&SYSECT  LOCTR                     RESUME INSTRUCTION AREA\n         MEND\n./ ADD NAME=IF       0126-02052-02102-1631-00155-00149-00000-GENTR02\n         MACRO\n&NAME    IF    &EXP                MULTIPLE OPERANDS VIA &SYSLIST\n         COPY  $MGBLDEF            BRING IN GLOBAL SET SYMBOLS\n         LCLA  &I,&J,&K            USED TO SCAN &SYSLIST OPERANDS, ETC\n         LCLC  &X,&Y,&OP,&OPND1,&OPND2,&OPND3,&C,&NC\n&$MRECUR SETA  &$MRECUR+1          INCREASE RECURSION COUNT\n         $MLVLMSG &$MRECUR,RECURSION CONDITIONALLY ISSUE MESSAGE\n&I       SETA  1                   SET TO FIRST POSITIONAL\n&$MNAME  SETC  '&NAME'             TAG FOR FIRST TEST\n.LOOP010 AIF   (N'&SYSLIST LT &I).FIN180 GO TO FINISH IF DONE\n         AIF   ('&SYSLIST(&I)'(1,1) NE '(').BADC120 MUST BE '('\n         AIF   ('&SYSLIST(&I)'(2,1) EQ '(').REC080 GO IF NESTED\n&OP      SETC  '&SYSLIST(&I,1)'    OP-CODE IS ALWAYS 1ST SUB-OPERAND\n&J       SETA  N'&SYSLIST(&I)      NUMBER OF SUBPARAMETERS FOR THIS ONE\n         AIF   (&J NE 2).TEST020   GO TEST FOR 1-OPERAND INST\n&$MNAME  &OP   ,                   ZERO OPERANDS - SET CONDITION CODE\n&$MC     SETC  '&SYSLIST(&I,2)'    CONDITION IS ALWAYS LAST SUB-OPERAND\n         AGO   .FING060            GO SET UP BRANCH INST\n.TEST020 ANOP  ,\n&OPND1   SETC  '&SYSLIST(&I,2)'    FIRST (ONLY?) OPERAND\n         AIF   (&J NE 3).TEST030   GO TEST FOR 2-OPERAND INST\n&$MNAME  &OP   &OPND1        ONE OPERAND - SET CONDITION CODE\n&$MC     SETC  '&SYSLIST(&I,3)'    CONDITION IS ALWAYS LAST SUB-OPERAND\n         AGO   .FING060            GO SET UP BRANCH INST\n.TEST030 ANOP  ,\n&OPND2   SETC  '&SYSLIST(&I,3)'    SECOND OPERAND\n         AIF   (&J NE 4).TEST040   GO TEST FOR 3-OPERAND INST\n&$MNAME  &OP   &OPND1,&OPND2 TWO OPERANDS - SET CONDITION CODE\n&$MC     SETC  '&SYSLIST(&I,4)'    CONDITION IS ALWAYS LAST SUB-OPERAND\n         AGO   .FING060            GO SET UP BRANCH INST\n.TEST040 ANOP  ,\n&OPND3   SETC  '&SYSLIST(&I,4)'    THIRD OPERAND\n         AIF   (&J NE 5).ERR050    GO ISSUE ERROR MESSAGE\n&$MNAME  &OP   &OPND1,&OPND2,&OPND3 THREE OPERANDS - SET CONDITION CODE\n&$MC     SETC  '&SYSLIST(&I,5)'    CONDITION IS ALWAYS LAST SUB-OPERAND\n         AGO   .FING060            GO SET UP BRANCH INST\n.ERR050  ANOP  ,\n&K       SETA  ((&I+1)/2)          GET SEQUENCE # OF PHRASE IN ERROR\n         MNOTE 08,'INVALID NUMBER OF PARMS (&J) IN CONDITIONAL PHRASE #*\n               &K &SYSLIST(&I); IT WILL BE OMITTED FROM THE MACRO EXPAN*\n               SION'\n&$MAXRC  SETA  8\n&$MNAME  CLC   *(1),*              PLACE HOLDER\n&$MNAME  SETC  ''                  NO DUPES\n         JNOP  *                   PLACE HOLDER\n&I       SETA  &I+2                INCREMENT\n         AGO   .LOOP010            BACK FOR MORE\n.FING060 ANOP                      COND CODE NOW SET - TEST IT\n&$MNAME  SETC  ''                  C'MON - NO DUPLICATE TAGS, PLEASE\n&$MNC    SETC  'N&$MC'             SET TO 'NOT'-CONDITION CODE\n         AIF   ('&$MC'(1,1) NE 'N').SKIP070 FALL THROUGH IF 'NE' ETC\n&$MNC    SETC  '&$MC'(2,1)         ORIG WAS 'NX' - SET TO 'X'\n.SKIP070 ANOP                       EXAMPLE 'NE' - SET TO 'E'\n         AIF   ('&SYSLIST(&I+2)' EQ '').FIN180 GO IF END OF STATEMENT\n         AIF   ('&SYSLIST(&I+1)' EQ 'OR').OR130 GO IF 'OR'\n         AIF   ('&SYSLIST(&I+1)' EQ 'AND').OR130 GO IF 'AND'\n         MNOTE 8,'TERM ''&SYSLIST(&I+1)'' ACCEPTED AS AN ''OR'' CLAUSE'\n&$MAXRC  SETA  8\n         AGO   .OR130              COMMON FOR 'AND' AND 'OR'\n.REC080  ANOP                      HERE FOR RECURSIVE CALL\n&$MNAME  IF    &SYSLIST(&I,1),&SYSLIST(&I,2),&SYSLIST(&I,3),           C\n               &SYSLIST(&I,4),&SYSLIST(&I,5),&SYSLIST(&I,6),           C\n               &SYSLIST(&I,7),&SYSLIST(&I,8),&SYSLIST(&I,9),           C\n               &SYSLIST(&I,10),&SYSLIST(&I,11),&SYSLIST(&I,12),        C\n               &SYSLIST(&I,13),&SYSLIST(&I,14),&SYSLIST(&I,15),        C\n               &SYSLIST(&I,16),&SYSLIST(&I,17),&SYSLIST(&I,18),        C\n               &SYSLIST(&I,19),&SYSLIST(&I,20),&SYSLIST(&I,21)\n         AIF   ('&$MFNAM1(&$MRECUR+1)' EQ '').REC100 GO IF NO FNAM1(+1)\n         AIF   ('&$MFNAM1(&$MRECUR)' EQ '').REC090 GO IF NO FNAM1\n&X       SETC  '&$MFNAM1(&$MRECUR+1)' TEMP FOR FNAM1(+1)\n&$MFNAM1(&$MRECUR+1) SETC ''       NULLIFY\n&X       EQU   &$MFNAM1(&$MRECUR)  EQUATE FOR NESTED LOGIC\n         AGO   .REC100             TEST PNAM1\n.REC090  ANOP\n&$MFNAM1(&$MRECUR) SETC '&$MFNAM1(&$MRECUR+1)' PROMOTE\n&$MFNAM1(&$MRECUR+1) SETC ''       NULLIFY\n.REC100  AIF   ('&$MPNAM1(&$MRECUR+1)' EQ '').REC110 GO IF NO PNAM1(+1)\n&$MNAME  SETC  '&$MPNAM1(&$MRECUR+1)' QUEUE FOR TEST INSTRUCTION\n&$MPNAM1(&$MRECUR+1) SETC ''       NULLIFY\n.REC110  AIF   ('&SYSLIST(&I+2)' EQ '').FIN180 GO IF END OF STATEMENT\n         AIF   ('&SYSLIST(&I+1)' EQ  'OR').OR130 GO IF 'OR'\n         AIF   ('&SYSLIST(&I+1)' EQ 'AND').OR130 GO IF 'AND'\n         AGO   .FIN180             NOT 'OR' OR 'AND' - ASSUME END\n.BADC120 MNOTE 12,'''&SYSLIST(&I)'' IS NOT A VALID CONDITIONAL PHRASE: C\n               EACH CONDITIONAL PHRASE MUST BE ENCLOSED WITHIN ONE OR MC\n               ORE PAIRS OF PARENTHESES. MACRO GENERATION ABORTED.'\n&$MAXRC  SETA  12\n         AGO   .FIN180             GO WRAP IT UP\n.OR130   ANOP                      COMMON FOR 'OR' AND 'AND'\n&NC      SETC  '&$MNC'             GEN LOCAL VARIABLES FOR\n&C       SETC  '&$MC'              . CONDITION CODE TESTS\n&$MNC    SETC  ''                  NULLIFY THE GLOBAL VARIABLES\n&$MC     SETC  ''                  . SINCE LOCALS WILL BE USED\n         AIF   ('&SYSLIST(&I+1)' EQ 'AND').AND160   GO IF 'AND'\n         AIF   ('&$MPNAM1(&$MRECUR)' NE '').OR140 SKIP IF NOT NEEDED\n         $MGPNAME                  GET A NEW 'PNAM1'\n.OR140   J&C   &$MPNAM1(&$MRECUR)  B IF TRUE TO 'PASS' TAG\n&I       SETA  &I+2                BUMP TO NEXT OPERAND\n         AIF   ('&$MNAME' EQ '').OR150 GO IF NO PNAM1 QUEUED\n&$MNAME  EQU   &$MPNAM1(&$MRECUR)  EQUATE FOR NESTED LOGIC\n.OR150   ANOP\n&$MNAME  SETC  '&$MFNAM1(&$MRECUR)' QUEUE TAG FOR 'AND' FAILED\n&$MFNAM1(&$MRECUR) SETC ''         NULLIFY TAG\n         AGO   .LOOP010            AND CONTINUE\n.AND160  AIF   ('&$MFNAM1(&$MRECUR)' NE '').AND170 SKIP IF NOT NEEDED\n         $MGFNAME                  GET A NEW 'FNAM1'\n.AND170  J&NC  &$MFNAM1(&$MRECUR)  B IF FALSE TO 'FAIL' TAG\n&I       SETA  &I+2                BUMP TO NEXT\n         AGO   .LOOP010            AND BACK\n.FIN180  AIF   (&$MRECUR GT 1).MEND260 EARLY EXIT FOR RECURSIVE CALL\n         AIF   ('&SYSLIST(&I+1)' EQ 'THENDO').FIN200 THIS IS EXPECTED\n         AIF   ('&$MCVERB(&$MDGLVL+1)' EQ 'DO').FIN200 FOR 'DO' MACRO\n         AIF   (&$MAXRC GT 4).FIN200 SKIP MESSAGE IF SERIOUS ERROR\n         AIF   ('&SYSLIST(&I+1)' EQ '').FIN190 GO ISSUE INFO MNOTE\n         MNOTE 4,'TERM ''&SYSLIST(&I+1)'' ACCEPTED AS END OF ''IF'' STAC\n               TEMENT'\n         AGO   .FIN200\n.FIN190  MNOTE 0,'''IF'' MACRO NOT TERMINATED BY ''THENDO'' CLAUSE; PREC\n               SENCE OF CLAUSE ASSUMED'\n.FIN200  ANOP\n&$MAXRC  SETA  0                   FOR FUTURE GENERATIONS\n&$MDGLVL SETA  &$MDGLVL+1          UP IF-GROUP LEVEL\n         $MLVLMSG &$MDGLVL,NESTING\n&$MDGSEQ(&$MDGLVL) SETC '&SYSNDX'  SET IF-GROUP SEQUENCE\n&$MIFELS(&$MDGLVL) SETC 'F'        FOR 'IF-FAILED' BRANCH\n&$MDGNAM(&$MDGLVL) SETC '&NAME'    SET NAME FOR 'ENDO'\n         AIF   ('&$MCVERB(&$MDGLVL)' NE '').SKIP210 ALREADY DEFINED?\n&$MCVERB(&$MDGLVL) SETC 'IF'       SHOW VERB BEING EXECUTED\n.SKIP210 ANOP\n&NC      SETC  '&$MNC'             SET LOCAL VARIABLE\n&X       SETC  '$MDF&$MDGSEQ(&$MDGLVL)' GET 'ENDO' TAG\n         AIF   ('&$MFNAM1(1)' NE '').FIN220 GO IF F-TAG NEEDED\n         AIF   ('&$MNC' EQ '').FIN240 SKIP IF B&NC NOT REQ'D\n         J&NC  &X                  B AROUND IF-GROUP IF FALSE\n&$MNC    SETC  ''                  FOR FUTURES\n         AGO   .FIN240             EXIT\n.FIN220  AIF   ('&$MC' EQ '').FIN230 SKIP IF B&C NOT REQ'D\n         J&NC  &X                  B AROUND IF-GROUP IF FALSE\n&$MNC    SETC  ''                  FOR FUTURES\n.FIN230  ANOP\n&X       SETC  '&$MFNAM1(1)'       GET 'FNAM1' FROM LEVEL 1\n&$MFNAM1(1) SETC ''                NOW NULLIFY IT\n&Y       SETC  '$MDF&$MDGSEQ(&$MDGLVL)' GET 'ENDO' TAG\n&X       EQU   &Y                  EQUATE FOR NESTED LOGIC\n.FIN240  AIF   ('&$MNAME' EQ '').FIN250 GO IF NO TAG QUEUED\n&$MNAME  DC    0H'0'         *=*=* BEGINNING OF CONDITIONAL GROUP *=*=*\n.FIN250  ANOP\n&X       SETC  '&$MPNAM1(1)'       GET 'PNAM1' FROM LEVEL 1\n         AIF   ('&X' EQ '').MEND260 GO IF NO 'PNAM1' FROM LEVEL 1\n&$MPNAM1(1) SETC  ''               NULLIFY\n&X       DC    0H'0'         *=*=* BEGINNING OF CONDITIONAL GROUP *=*=*\n.MEND260 ANOP                      STANDARD EXIT\n&$MRECUR SETA  &$MRECUR-1          REDUCE RECURSION COUNT\n         $MLVLMSG &$MRECUR,RECURSION CONDITIONALLY ISSUE MESSAGE\n         MEND\n./ ADD NAME=OMGBLDEF 0100-02017-02017-1017-00004-00004-00000-GENTR02\n         GBLA  &$MDGLVL,&$MDGERR,&$MRECUR,&$MBLATH\n         GBLC  &$MFNBR(31),&$MDGNAM(255),&$MDGSEQ(255),&$MNAME,&$MNC\n         GBLC  &$MIFELS(255),&$MLTAG(255),&$MPNAM1(31),&$MFNAM1(31)\n         GBLC  &$MCVERB(255),&$MC\n./ ADD NAME=THENDO   0112-01222-02067-1613-00020-00023-00000-GENTR02\n         MACRO\n&NAME    THENDO &COND '&COND' MUST BE CHAR(S) FOLLOWING 'B' OF EXTENDED\n.*             MNEMONICS, EG 'E' OF 'BE' OR 'NO' OF 'BNO', ETC\n         COPY  $MGBLDEF\n         LCLC  &X,&Y\n&Y       SETC  'N&COND'\n         AIF   ('&COND'(1,1) NE 'N').SKIP05\n&Y       SETC  '&COND'(2,1)\n.SKIP05  ANOP\n&$MDGLVL SETA  &$MDGLVL+1          UP DO-GROUP LEVEL\n         $MLVLMSG\n&$MDGSEQ(&$MDGLVL) SETC '&SYSNDX'  SET DO-GROUP SEQUENCE\n&$MDGNAM(&$MDGLVL) SETC '&NAME'    SET DO-GROUP NAME\n&$MIFELS(&$MDGLVL) SETC 'F'\n         AIF   ('&NAME' NE '').SKIP07\n&$MDGNAM(&$MDGLVL) SETC '$MDG&$MDGSEQ(&$MDGLVL)'\n.SKIP07  J&Y   $MDF&$MDGSEQ(&$MDGLVL) SKIP DO-GROUP IF REL NOT TRUE\n         AIF   ('&NAME' EQ '').SKIP10\n&NAME    DC    0H'0'              NAME OF DO-GROUP\n.SKIP10  MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$ALTDOC": {"ttr": 1283, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x995_\\x00\\x995_\\x16%\\x00\\xd8\\x00\\xc0\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1999-12-21T00:00:00", "modifydate": "1999-12-21T16:25:00", "lines": 216, "newlines": 192, "modlines": 0, "user": "SBGOLOB"}, "text": "This documentation was created from Dan Snyder's documentation by\nfolding the long lines with 'TF68' under ISPF EDIT.  Just makes it\na bit easier to read.                              (S.Golob  12/99)\n\nAuthor's Note:\n\n       The member SAMPLE is a demo of the power of the macros,\n       but it was written as a sort of automated test to make\n       sure I didn't mess anything up when I made a change. It\n       is a poor marketing tool. To see 'real life examples'\n       please look at the programs DATECONV, INTOFDTE, and\n       DTEOFINT (also members of 'MACLIB'). These are purposeful\n       programs that utilize the macros.\n\n                         STRUCTURED MACROS\n\n  THESE MACROS CAN HELP YOU CREATE NEW PROGRAMS AND MODIFY EXISTING\n  CODE BY SUPPORTING IF-THEN-ELSE LOGIC WHILE REQUIRING ONLY A SMALL\n  LEARNING CURVE FROM WHAT YOU ALREADY KNOW ABOUT S/390 ASSEMBLER\n  (ASSUMING THAT YOU DO KNOW IT ALREADY).  EACH 'IF' STATEMENT CAN\n  BE ARBITRARILY COMPLEX, AND THE 'IF' STATEMENTS CAN BE NESTED AS\n  MANY LEVELS AS YOU MIGHT NEED (CERTAINLY, NO ONE WOULD NEED MORE\n  THAN 255 LEVELS OF NESTING, WOULD HE?).\n\n  EACH GROUP OF INSTRUCTIONS THAT YOU WANT CONDITIONALLY EXECUTED\n  WOULD BE HEADED BY AN 'IF' MACRO, AND TERMINATED BY AN 'ENDIF'\n  MACRO.\n\n  IN ITS SIMPLIST FORM, THE OPERAND OF THE 'IF' MACRO CONSISTS OF AN\n  OP-CODE, THE FIRST OPERAND ADDRESS, THE SECOND OPERAND ADDRESS,\n  AND A CONDITION. THESE FOUR VALUES MUST BE ENCLOSED WITHIN\n  PARENTHESES, AND FOLLOWING THE OPERANDS MUST BE A COMMA AND THE\n  STATEMENT TERMINATING TERM 'THENDO'.\n\n  THE OP-CODE MAY BE ANY VALID S/390 OP-CODE THAT SETS THE CONDITION\n  CODE. THE FIRST AND SECOND OPERANDS MAY BE ANY VALUES THAT ARE\n  VALID FOR THE INSTRUCTION BEING CREATED. THE CONDITION, SUCH AS\n  'E' OR 'NO', IS ANY VALUE THAT CAN BE USED IN CREATING AN EXTENDED\n  MNEMONIC BRANCH INSTRUCTION (SUCH AS 'BE' OR 'BNO').\n\n  IF YOU CHOOSE 'E' AS THE CONDITION, THEN THE GROUP OF INSTRUCTIONS\n  BETWEEN THE 'IF' AND THE 'ENDIF' WILL BE EXECUTED ONLY IF THE\n  CONDITION CODE SET BY THE OP-CODE AND OPERANDS SPECIFIED IS A\n  ZERO.\n\n  IN THE FOLLOWING EXAMPLES, THE HEADING WILL INDICATE THE\n  CONDITIONS IN WHICH THE DO-GROUP WILL BE EXECUTED. IN EACH CASE,\n  AN 'IF' STATEMENT DETERMINES THE CONDITIONS, AND AN 'ENDIF'\n  STATEMENT TERMINATES THE DO-GROUP. COMMENTS EITHER IN THE HEADING\n  OR ON THE APPROPRIATE INSTRUCTIONS WILL INDICATE THE DETAILS.\n       HERE IS AN EXAMPLE:\n\n         IF    (CLC,A,B,NE),THENDO\n\n  THE INSTRUCTIONS BETWEEN THIS 'IF' AND ITS MATCHING 'ENDIF' WILL\n  BE EXECUTED IF THE RESULT OF THE 'CLC' IS A 1 OR 2 (THE NOT-EQUAL\n  CONDITION).\n\n       TO EXECUTE THE DO-GROUP IF EITHER ONE OF TWO CONDITIONS IS\n  TRUE, THE FORMAT IS:\n\n       IF    (CLC,A,B,NE),OR,(CLC,C,D,NE),THENDO\n\n       ALTERNATE FORMAT:\n                                                            72\n       IF    (CLC,A,B,NE),OR,                                C\n             (CLC,C,D,NE),THENDO\n\n       SINCE 'AND' TAKES PRECEDENCE OVER 'OR', IN THE FOLLOWING\n  EXAMPLE, THE DO-GROUP IS PERFORMED IF THE FIRST TEST IS TRUE, OR\n  IF BOTH THE SECOND AND THIRD ARE TRUE:\n\n       IF    (CLC,A,B,E),OR,                                 C\n             (CLC,C,D,E),AND,                                C\n             (CLC,E,F,E),THENDO\n\n       IF THE DO-GROUP IS TO BE PERFORMED IF THE THIRD IS TRUE AND\n  EITHER THE FIRST OR SECOND IS TRUE, INCLUDE THE TESTS CONNECTED\n  BY THE 'OR' WITHIN ADDITIONAL PARENTHESES:\n\n             * <-NESTING PARENTHESES -> *\n       IF    ((CLC,A,B,E),OR,(CLC,C,D,E)),AND,               C\n             (CLC,E,F,E),THENDO\n\n       ALTERNATE FORMAT:\n                                                            72\n       IF    ((CLC,A,B,E),OR,                                C\n             (CLC,C,D,E)),AND,                               C\n             (CLC,E,F,E),THENDO\n\n       GROUPS OF EXPRESSIONS MAY BE NESTED AS DEEPLY AS REQUIRED\n  TO DEFINE THE LOGIC DESIRED.\n       EACH DO-GROUP MUST BE TERMINATED WITH AN 'ENDIF' STATEMENT\n  OR AN 'ELSE' - 'ENDELSE' COMBINATION:\n\n       ENDIF ,\n                   - OR -\n       ELSE  ,\n       ... ADDITIONAL INSTRUCTIONS TO BE EXECUTED IF 'IF' FAILS\n       ENDELSE ,  (OR ENDIF - EITHER IS ACCEPTABLE AFTER AN 'ELSE')\n\n       ALTERNATIVELY, A DO-GROUP CAN BE TERMINATED AS FOLLOWS:\n\n       ELSEIF  (CLC,G,H,E),THENDO ...\n\n       ANY NUMBER OF 'ELSEIF' STATEMENTS CAN FOLLOW THE ORIGINAL\n       'IF' STATEMENT. THERE MAY BE (BUT NEED NOT BE) ONE AND ONLY\n       ONE 'ELSE' STATEMENT FOLLOWING THE FINAL 'ELSEIF'. THE ENTIRE\n       GROUP IS TERMINATED WITH ONE 'ENDIF' OR 'ENDELSE'.\n\n       IF    (...),THENDO            REQUIRED\n       ...\n       ELSEIF (...),THENDO           OPTIONAL (REPEATED AS REQUIRED)\n       ...\n       ELSE  ,                       OPTIONAL\n       ...\n       ENDIF ,                       REQUIRED (OR 'ENDELSE')\n\n  THE 'DO' MACRO HEADS A 'DO-GROUP' - A GROUP OF INSTRUCTIONS THAT\n  WILL BE EXECUTED ZERO OR MORE TIMES, DEPENDING ON THE OPERANDS OF\n  THE 'DO' STATEMENT.  IN ITS SIMPLIST FORM, AN INTEGER IS THE ONLY\n  OPERAND, SPECIFYING THE NUMBER OF TIMES TO REPEAT THE GROUP.\n  ALTERNATIVELY, EITHER THE 'UNTIL=' OR THE 'WHILE=' CLAUSE MAY BE\n  SPECIFIED.  THE FORM OF EACH OF THESE CLAUSES IS SIMILAR TO THE\n  REQUIREMENTS FOR THE 'IF' STATEMENT, WITH THE ADDITION THAT, IF\n  MORE THAN ONE SIMPLE TEST IS SPECIFIED, THEN ALL OF THE CONDITIONS\n  MUST BE ENCLOSED WITHIN AN ADDITIONAL LEVEL OF PARENTHESES:\n\n       DO    UNTIL=(CLC,FIELDA,FIELDB,E)\n       ...\n       ENDO  ,\n\n       DO    UNTIL=((CLC,FIELDA,FIELDB,E),RO,                          X\n             (CLR,R5,R6,NE))\n       ...\n       ENDO  ,\n\n  IN THE ABOVE EXAMPLES, THE TEST IS PERFORMED BEFORE THE GROUP IS\n  EXECUTED, SO IF THE TEST FAILS, THE GROUP WILL NOT BE PERFORMED\n  EVEN ONCE. IF YOU NEED TO EXECUTE THE GROUP ONCE, BEFORE THE\n  TESTING INSTRUCTIONS ARE PERFORMED, THEN ADD THE 'TEST=AFTER'\n  CLAUSE:\n\n       DO    UNTIL=(CLC,FIELDA,FIELDB,E),TEST=AFTER\n       ...\n       ENDO  ,\n\n  WHEN YOU USE THE 'UNTIL' CLAUSE, THE GROUP WILL BE EXECUTED\n  REPEATEDLY UNTIL SOME PART OF THE CONDITIONAL PHRASE EVALUATES AS\n  'TRUE'.  WHEN YOU USE THE 'WHILE' CLAUSE, THE GROUP WILL BE\n  EXECUTED REPEATEDLY AS LONG AS SOME PART OF THE CONDITIONAL PHRASE\n  EVALUATES AS TRUE.\n\n  THREE ADDITIONAL GROUP-DEFINING INSTRUCTIONS ARE PROVIDED FOR USE\n  AS 'FIRST TIME SWITCHES', ETC.  THEY ARE 'FIRST', 'AFTER', AND\n  'EVERY'.  EACH OF THESE REQUIRES, AS ITS ONLY OPERAND, AN INTEGER.\n\n  'FIRST N' HEADS A GROUP THAT WILL BE EXECUTED THE FIRST 'N' TIMES\n  THROUGH THAT SECTION OF CODE:\n\n       FIRST 1\n         OPEN  (SYSPRINT,OUTPUT)\n       ENDFIRST ,\n\n  'EVERY N' HEADS A GROUP THAT WILL BE EXECUTED ONLY EVERY N'TH PASS\n  THROUGH THAT SECTION OF CODE:\n\n       EVERY 10000\n          WTO   'ANOTHER 10000 PROCESSED'\n       ENDEVERY ,\n\n  'AFTER N' HEADS A GROUP THAT WILL BE EXECUTED AFTER 'N' PASSES\n  THROUGH THAT SECTION OF CODE:\n\n       AFTER 1000000\n         WTO   '1,000,000 PASSES - CHECK FOR LOGIC ERROR'\n       ENDAFTER ,\n\n  NOTE THAT THE ABOVE 'WTO' INSTRUCTION WILL BE EXECUTED ON EVERY\n  PASS THROUGH THAT CODE AFTER THE 1000000TH PASS.  TO ISSUE THE\n  MESSAGE JUST ONCE:\n\n       AFTER 1000000\n         FIRST 1\n           WTO   '1,000,000 PASSES - CHECK FOR LOGIC ERROR'\n         ENDFIRST ,\n       ENDAFTER ,\n\n  IF YOU NAME ONE OF THE CONDITIONAL INSTRUCTIONS ('IF' ETC) IN COLS\n  1-8, THEN THAT NAME MAY BE USED IN ANY OF THE 'END...' STATEMENTS\n  TO TERMINATE ALL OF THE NESTED LOGIC STATEMENTS UP TO THE ONE WITH\n  THAT NAME:\n\n  EXAMP1  IF    (CLC,FIELDA,FIELDB,E),THENDO\n             ...\n  LEVEL2     IF    (CLR,R5,R6,E),THENDO\n             ...\n               IF   (TM,FLAG1,X'80',O),THENDO\n                 ....\n             ENDIF DOGROUP=LEVEL2\n             ...\n           ENDIF ,                   ENDS 'EXAMP1'\n\n  IF YOU WANT TO END ALL OF THE NESTED GROUPS, YOU CAN CODE A\n  'MAGIC' VALUE FOR THE 'DOGROUP' KEYWORD:\n\n  EXAMP1  IF    (CLC,FIELDA,FIELDB,E),THENDO\n             ...\n  LEVEL2     IF    (CLR,R5,R6,E),THENDO\n             ...\n               IF   (TM,FLAG1,X'80',O),THENDO\n                 ....\n           ENDIF DOGROUP=*ALL*       ENDS ALL ACTIVE GROUPS\n\n  SINCE '*ALL*' IS NOT A VALID ASSEMBLER TAG VALUE, IT IS USED TO\n  CAUSE THE CLOSURE OF ALL EXISTING ACTIVE DO-GROUPS.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$$ARTCL1": {"ttr": 1288, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00\\x01\\x0f\\x01\\x00\\x01\\x0f\\x12\\x10\\x01K\\x01K\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-01-10T00:00:00", "modifydate": "2000-01-10T12:10:00", "lines": 331, "newlines": 331, "modlines": 0, "user": "SBGOLOB"}, "text": "                     Structured Macros\n                                             by Dan Snyder\n\nAs you well know, if you have ever programmed in S/390 Assembler,\nmany aspects of it are impediments to creating decent code, rather\nthan assists.  Creating a large complex program can become a real\nburden, just in accomplishing the necessary housekeeping.  And, just\nbecause of the nature of coding in Assembler, most programs resemble\nspaghetti code.  Since the programmer has to define a name to use as\na branch target for each piece of logic within the program, studying\nsomeone else's code and determining the meaning of the various name\nfields can be very frustrating.  Editing the source has its\nchallenges, but studying the Assembly listing can be even more\ndifficult.  What I longed for was just the simple Cobol IF-THEN-ELSE\nconstruct.\n\nWith the intention of creating an environment that maintained all\nthe reasons for coding in Assembler in the first place, such as the\nrich instruction set and the straightforward ability to access many\nfunctions not conveniently available to those programming in other\nlanguages, I started to work on a structured programming set of\nmacro definitions in the early 1970's.  This paper is not a\nblue-sky picture of what life might be like 'if only...', but\nrather is a treatise on the macro definitions that I created, which\nare available on the CBT tape..\n\nThe cornerstone of these macros is the IF.  It would head a group of\ninstructions (cr-group for conditional/repetitive) that would then\nbe terminated with an ENDIF.  My goal in writing the IF was to\nprovide a maximum of flexibility along with a short learning curve\nfor those who had already mastered programming in Assembler.  So,\nthe format for the operand of the IF became a comma-delimited string\nconsisting of the op-code that would set the system's condition code\nregister, the a-operand, the b-operand, and the condition which\nwould cause the cr-group to be either executed or not executed. The\nfirst operand of the IF must be one of these comma-delimited\nstrings, enclosed within parentheses.  For a simple condition,\nfollow this expression with 'THENDO':\n\n                PRINT GEN                   DISPLAY MACRO EXPANSIONS\n                IF      (CLC,FIELDA,FIELDB,E),THENDO\nMVC     OUTPUT(20),FIELDA   DO IF FIELDA = FIELDB\n                ENDIF ,\n\nIn this example, the Assembler listing would look like:\n\n                PRINT GEN                   DISPLAY MACRO EXPANSIONS\n                IF      (CLC,FIELDA,FIELDB,E),THENDO\n+               CLC     FIELDA,FIELDB\n+               BNE     $MDF0001\nMVC     OUTPUT(20),FIELDA  DO IF FIELDA = FIELDB\n                ENDIF ,\n+$MDF0001       DC      0H'0'\n\nFirst, a few observations.  The '+' at the left of some of the lines\nof code indicates that that line was generated by the Assembler's\nmacro pre-processor (I.E. it is part of what is termed the 'macro\nexpansion').  Also, the last 4 characters of the generated tag,\n'0001', is obtained from &SYSNDX, which is an internal Assembler\nregister that can be used to create uniqueness in generating tags\nrequired when the same macro is invoked multiple times within a\ngiven program.  In an actual Assembly, the four digits would\nrepresent the then current value for &SYSNDX.  Here, we'll just use\n0001.\n\nNote also that each macro supports the use of a NAME field,\nbeginning in column 1, but why would you want to?\n\nThe condition, which comprises the fourth sub-parameter, may be any\none or two letters that can be appended to a 'B' to create one of\nthe extended branch instructions, such as 'E' or 'NE' creating 'BE'\nor 'BNE'.  Thus, if the instruction created by the specified\nop-code, a-operand and b-operand results in an 'Equal', then the\ncr-group will be executed.\n\nAn optional 'ELSE' cr-group was also supported:\n\n                IF      (CLC,FIELDA,FIELDB,E),THENDO\nMVC     OUTPUT(20),FIELDA  DO IF FIELDA = FIELDB\n                ELSE ,\nMVC     OUTPUT(20),FIELDB  DO IF FIELDA NOT = FIELDB\n                ENDIF ,\n\nThis would generate:\n\n                IF      (CLC,FIELDA,FIELDB,E),THENDO\n+               CLC     FIELDA,FIELDB\n+               BNE     $MDF0001\nMVC     OUTPUT(20),FIELDA  DO IF FIELDA = FIELDB\n                ELSE ,\n+               B       $MDS0001\n+$MDF0001       DC      0H'0'\nMVC     OUTPUT(20),FIELDB  DO IF FIELDA NOT = FIELDB\n                ENDIF ,\n+$MDS0001       DC      0H'0'\n\nObviously, since the programmer is responsible for coding the\ninstructions that set the condition code (the operands of the IF\nmacro), and the macro package generates only branch on condition\ninstructions and tags for these branch instructions, the generated\ncode is as efficient as it would be without using the macro package.\n\nAdditional IF statements and their associated cr-groups may be\nnested to any required level (would anyone ever require more than\n255 levels of nesting?):\n\n                IF      (CLC,FIELDA,FIELDB),THENDO\n                        IF      (LTR,R15,R15,Z),THENDO\n                                ...\n                        ELSE  ,\n                                ...\n                        ENDIF ,\n                ENDIF ,\n\nIn creating the sub-fields representing a condition, the op-code\nmust be first and the condition must be last.  If you use an S/390\ninstruction that has more (such as SRP) or fewer (UPT and SSCH come\nto mind) operands than the two that most instructions have, then you\nshould code the op-code, followed by any required operands, and then\nthe condition:\n\n                IF      (SRP,PKDFLD1,64-3,0,NZ),THENDO\n                ...                     INSTRUCTIONS EXECUTED IF THE SHIFT\n                ...                     RESULTS IN A NON-ZERO CONDITION\n                ENDIF ,\n\nFor complex conditions, the comma-delimited conditions must\nalternate with an 'OR' or an 'AND', with the final conditional still\nfollowed by that required 'THENDO':\n\n                IF      (CLC,FIELDA,FIELDB,E),OR,\n                        (TM,ENDSW,X'80',O),THENDO\n                        ...\n                ENDIF ,\n\nDuring the initial phase of creating this package, I prepared a\n'proof of concept' version, and tested it (to my complete\nsatisfaction). Next was the preparation of the 'industrial strength'\nversion, that would permit multiple conditions connected with OR or\nAND clauses, and allowing additional parentheses to support the\ntypical situation where a cr-group would need to be executed if\neither of two conditions were true, AND a third was true:\n\n                IF      ((CLC,FIELDA,FIELDB,E),OR,\n                        (TM,ENDSW,X'80',O)),AND,\n                        (CP,COUNTER1,=P'1000000',L),THENDO\n                        ...\n                ENDIF ,\n\nPlease note the double parentheses at the left of the first\nconditional phrase and at the right of the second.  This causes the\ncr-group to be executed if the third condition results in a 'low',\nand if either the first results in an 'equal' or the second results\nin a 'ones'.   With this syntax it is possible to create an\narbitrarily complex condition to control the execution of the\nfollowing cr-group.\n\nThis version created correct code, so I started to do some\npathological testing, throwing all of the curves that I could think\nof, including (there are 10 pairs of parentheses - don't bother\ncounting!):\n\n                IF      ((((((((((CLC,FIELDA,FIELDB,E)))))))))),THENDO\n                        MVC     OUTLINE(20),FIELDA\n                ENDIF ,\n\nThe code that was generated produced correct output, but it looked\nlike:\n\n                IF      ((((((((((CLC,FIELDA,FIELDB,E)))))))))),THENDO\n+               CLC     FIELDA,FIELDB\n+               BNE     *+8\n+               B       *+8\n+               B       *+8\n+               B       *+8\n+               B       *+8\n+               B       *+8\n+               B       *+8\n+               B       *+8\n+               B       *+8\n+               B       *+8\n+               B       *+8\n+               B       *+8\n+               B       *+8\n+               B       *+8\n+               B       *+8\n+               B       *+8\n+               B       *+8\n+               B       *+8\n+               B       $MDF0001\n                        MVC     OUTLINE(20),FIELDA\n                ENDIF ,\n+$MDF0001       DC      0H'0'\n\nWell, even though the program worked correctly, the generated code\nwasn't too cool.  So, although I hadn't intended to create a 2nd\nproduction version, guess what?  I did.  When I fed the above\nprogram into this new version, here's what came out:\n\n                IF      ((((((((((CLC,FIELDA,FIELDB,E)))))))))),THENDO\n+               CLC     FIELDA,FIELDB\n+               BNE     $MDF0001\n                        MVC     OUTLINE(20),FIELDA\n                ENDIF ,\n+$MDF0001       DC      0H'0'\n\nSo at last we had the functionality and elegance that we needed.\nThe IF was complete, and what followed were additional macro\ndefinitions based on it.\n\nSince the CASE verb appears in just about every language (called\nEVALUATE in Cobol), a simple addition to this package provides\nsimilar functionality: the ELSEIF statement.  It has the same syntax\nas the IF, and one or more may be coded between the IF and its\ncr-group terminating ENDIF, or the ELSE, if one is needed:\n\nIF    (CLC,FIELDA,FIELDB,E),THENDO\n                        MVC   OUTPUT(20),FIELDA\n                        ELSEIF (CLC,FIELDA,FIELDC,E),THENDO\n                        MVC   OUTPUT(20),FIELDC\n                        ELSEIF (CLC,FIELDA,FIELDD,E),THENDO\n                        MVC   OUTPUT(20),FIELDD\n                        ELSE  ,\n                        MVC   OUTPUT(20),FIELDE\n                        ENDIF ,\n\n\n                IF    (CLC,FIELDA,FIELDB,E),THENDO\n+               CLC   FIELDA,FIELDB\n+               BNE   $MDF0001\n                        MVC   OUTPUT(20),FIELDA\n                        ELSEIF (CLC,FIELDA,FIELDC,E),THENDO\n+               B     $MDF0005\n+$MDF0001       CLC   FIELDA,FIELDC\n+               BNE   $MDF0006\n                        MVC   OUTPUT(20),FIELDC\n                        ELSEIF (CLC,FIELDA,FIELDD,E),THENDO\n+               B     $MDF0005\n+$MDF0006       CLC   FIELDA,FIELDD\n+               BNE   $MDF0010\n                        MVC   OUTPUT(20),FIELDD\n                        ELSE  ,\n+               B     $MDS0010\n+$MDF0010       DC      0H'0'\n                        MVC   OUTPUT(20),FIELDE\n                        ENDIF ,\n+$MDS0010 DC    0H'0'\n+$MDF0005 DC    0H'0'\n\nIn this example, I copied the SYSPRINT from an Assembly to\nillustrate the actual names that are generated.\n\nNext on the list of necessary functionality is the need to execute a\ncr-group repetitively.  This led to the creation of the DO macro.\nDO has several different formats.  The simplest is to execute a\ncr-group a specific number of times:\n\n        DO      5\n                WTO     '**** ERROR **** PGM TESTPGM TABLE OVERFLOW'\n        ENDO ,\n\nIn this form, the DO macro causes the statements between it and the\ncr-group terminating ENDO to be executed 'n' times, where 'n' is a\nnumeric, self defining integer.\n\nA second form is:\n\n        PACK    PKDFLD1,=Z'10'\n        DO      PKDFLD1\n                WTO     '2ND ERROR'\n        ENDO ,\n\nWhen you use this option, the operand of the DO must be a packed\ndecimal field, and its value must have been set before the DO is\nexecuted.  The DO macro makes a local copy of the value of the\nparameter, so that if its value is changed during the repetitive\nexecution of the cr-group, that change will not effect the current\nexecution, but it will control the number of loops  the next time it\nis executed.\n\nIf you need to create a never-ending loop, you would code:\n\n        DO      FOREVER\n                ...\n        ENDO    ,\n\nIn this case, something other than the DO statement would be\nresponsible for ending the loop, such as a branch instruction within\nthe loop (horror!), or a System 222, etc.\n\nIf you need to control the loop with a simple or complex condition,\nyou may code either the UNTIL= or the WHILE= parameter. If you need\na simple condition, then enclose the sub-parameters within single\nparentheses:\n\n        DO      UNTIL=(CLC,FIELDA,FIELDB,E)\n                ...\n                MVC     FIELDA,FIELDB\n        ENDO    ,\n\nAlthough the DO macro invokes the IF to do the actual processing of\nthe conditional phrases, you do not include the THENDO phrase here.\nHowever, if you code a complex conditional, including one or more OR\nor AND phrases, then you must enclose the entire set of conditions\nwithin an additional set of parentheses:\n\nDO      UNTIL=((CLC,FIELDA,FIELDB,E),AND,\n                (CLI,ENDFLAG,C'Y',NE))\n                        ...\n                        MVC     FIELDA,FIELDB\nENDO    ,\n\nYou may code either the WHILE or the UNTIL clause, but not both.  In\neither case, the cr-group will be executed zero or more times, based\non the evaluation of the conditions.  If you need the cr-group to be\nexecuted at least one time, then you can add the keyword parameter\nTEST=AFTER to either of the above two options:\n\n        DO      UNTIL=(CLI,ENDFLAG,C'Y',E),TEST=AFTER\n                ...\n                MVI     ENDFLAG,C'Y'\n        ENDO ,\n\nIf you don't specify TEST=AFTER, then the default TEST=BEFORE applies.\n\nIf you look at these macros on the CBT tape, you will see reference\nto a few other structured macros, and many other general purpose\nmacros, with some supporting subroutine creation and linkage.  But,\nalas, they will have to wait for another article.\n\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$$MACDOC": {"ttr": 1537, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00\\x00o\\x01\\x00\\x00o\\x18V\\x058\\x058\\x00\\x00\\xc4\\xc3\\xd6\\xc4\\xc8\\xe2\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-01-06T00:00:00", "modifydate": "2000-01-06T18:56:00", "lines": 1336, "newlines": 1336, "modlines": 0, "user": "DCODHS0"}, "text": "IN THE FOLLOWING LIST OF MACROS, EACH ONE IS ASSIGNED TO A CATEGORY\nACCORDING TO ITS INTENDED USE.  MOST OF THE TESTING ON THESE MACROS\nHAS BEEN DONE IN AN ENVIRONMENT CALLED 'VERSION 2', OR '2ND\nGENERATION'. THIS ENVIRONMENT PRESENTS A PROGRAMMER WITH A PSEUDO-COBOL\nWAY OF CODING, AND WAS CREATED IN THE EARLY 1990'S AS AN AID TO GETTING\nPROGRAMS GOING FASTER.  THE 'VERSION 1' OR '1ST GENERATION' ENVIRONMENT\nWAS CREATED IN THE MID 1970'S, AND IS SOMEWHAT MORE ORIENTED TOWARD\nSYSTEMS PROGRAMMING TYPES OF PROGRAMMING.\n\nIF A MACRO IS LISTED AS BEING 'GENERAL', OR GENERAL PURPOSE, THEN IT IS\nNOT PART OF EITHER VERSION 1 OR 2, BUT IT MIGHT NOT HAVE BEEN TESTED\nOUTSIDE ONE OF THESE ENVIRONMENTS.\n\nWHAT FOLLOWS IS A DESCRIPTION OF THE CATEGORIES THAT THESE MACROS HAVE\nBEEN CLASSIFIED INTO:\n\nDIAGNOSTIC - THE MACRO MAY BE USED IN EITHER VERSION 1 OR 2 PROGRAMS,\nAND IS INTENDED PRIMARILY AS A DIAGNOSTIC AID IN GETTING THE\nPROGRAM RUNNING CORRECTLY.  HOPEFULLY THE EFFORT EXPENDED IN\nUSING ONE OR MORE OF THESE DIAGNOSTIC MACROS WILL PAY OFF IN DIAGNOSING\nTHE PROGRESS OF YOUR PROGRAM.\n\nGENERAL - VARIOUS UTILITY MACROS THAT SHOULD PROVIDE SERVICES REQUIRED\nFOR TYPICAL PROGRAMS.\n\nINTERNAL - THESE MACROS ARE TYPICALLY USED AS COMMON SERVICE ROUTINES\nBY OTHER MACROS WITHIN THIS LIBRARY.  THEY USUALLY PROVIDE SERVICES\nTHAT WOULD NOT BE USEFUL FOR USE AS OPEN CODE MACROS (THOSE CODED\nWITHIN THE PROGRAM ITSELF).\n\nRUN-TIME-TOTALS - A SET OF GENERAL PURPOSE MACROS THAT MIGHT MAKE IT\nEASIER TO CREATE COUNTERS THAT CAN BE INCREMENTED AT EACH OF SEVERAL\nPLACES WITHIN A PROGRAM, AND THEN AT SOME POINT DURING PROGRAM\nEXECUTION (PRESUMABLY DURING THE FINALIZATION STEP OF THE PROGRAM),\nPRINT OUT ALL OF THE ACCUMULATED COUNTS WITH ONE EASY STATEMENT.\n\nSTRUCTURED - MACROS THAT CONTROL THE CONDITIONAL OR REPETITIVE\nEXECUTION OF A GROUP OF INSTRUCTIONS FOLLOWING THE GROUP-INITIATION\nMACRO AND ENDING WITH A GROUP-TERMINATING MACRO.\n\n1ST GENERATION - A SET OF MACROS THAT PROVIDE STANDARD MVS INTERFACE\nAND SUBROUTINE LINKAGE CONVENTIONS.\n\n2ND GENERATION - ANOTHER SET OF MVS INTERFACE AND SUBROUTINE LINKAGE\nMACROS.\n\nWHAT FOLLOWS IS AN ALPHABETIC LISTING OF ALL OF THE MACRO DEFINITIONS\nINCLUDED IN THE PACKAGE, WITH ITS IDENTIFYING MACRO TYPE:\n\n$AGOTO    INTERNAL\n$ASECT    INTERNAL\n$IA       INTERNAL\n$MENDDO1  INTERNAL\n$MENDDO2  INTERNAL\n$MGBLDEF  INTERNAL\n$MGFNAME  INTERNAL\n$MGPNAME  INTERNAL\n$WA       INTERNAL\nADDR      GENERAL\nAFTER     STRUCTURED\nAN        GENERAL\nBEGTEST   DIAGNOSTIC\nBHE       GENERAL\nBLE       GENERAL\nCOMBOX    GENERAL\nCONTINUE  GENERAL\nCPYPAR$E  INTERNAL\nCTE       TEXT SEARCH\nCTEB      TEXT SEARCH\nCVN       GENERAL\nCVXREGS   DIAGNOSTIC\nCVXWORD   DIAGNOSTIC\nDEFPGMID  INTERNAL\nDIAGMSG   INTERNAL\nDISPLAY   DIAGNOSTIC\nDIVISION  2ND GENERATION\nDO        STRUCTURED\nDTM       INTERNAL\nDUMPMAIN  DIAGNOSTIC\nDUMPREGS  DIAGNOSTIC\nEDIT      STRUCTURED\nELSE      STRUCTURED\nELSEDO    STRUCTURED\nELSEIF    STRUCTURED\nEM        GENERAL\nENDAFTER  STRUCTURED\nENDELSE   STRUCTURED\nENDFIRST  STRUCTURED\nENDIF     STRUCTURED\nENDO      STRUCTURED\nENDP      1ST GENERATION\nENDSECT   2ND GENERATION\nENDTEST   DIAGNOSTIC\nEPACK     GENERAL\nEQUATE    GENERAL\nEUNPK     GENERAL\nEVERY     STRUCTURED\nEXECUTE   GENERAL\nEXIT      2ND GENERATION\nFINAL     2ND GENERATION\nFIRST     STRUCTURED\nGO        1ST GENERATION\nGOBACK    2ND GENERATION\nGOTO      2ND GENERATION\nHEXRTN    DIAGNOSTIC (1ST GENERATION VERSION)\nHROUTINE  DIAGNOSTIC (2ND GENERATION VERSION)\nI         GENERAL\nIF        STRUCTURED\nIP        GENERAL\nLEVELMSG  INTERNAL\nMACBOX    GENERAL\nNEXT      STRUCTURED\nPAR$E     INTERNAL\nPCALL     1ST GENERATION\nPERFORM   2ND GENERATION\nPRDEF     GENERAL (1ST GENERATION VERSION)\nPRINTER   GENERAL (2ND GENERATION VERSION)\nPROC      1ST GENERATION\nPRTTABLE  RUN-TIME-TOTALS\nRETN      1ST OR 2ND GENERATION\nRTTBEG    RUN-TIME-TOTALS\nRTTEND    RUN-TIME-TOTALS\nRTTENT    RUN-TIME-TOTALS\nRTTINCR   RUN-TIME-TOTALS\nRTTPRT    RUN-TIME-TOTALS\nRTTRESET  RUN-TIME-TOTALS\nSECONDEP  2ND GENERATION\nSECTION   2ND GENERATION\nSETCSECT  INTERNAL\nSETDEF    INTERNAL\nSETRC     GENERAL\nSETUP     INTERNAL\nSTOP      1ST GENERATION\nSYSUT1    1ST GENERATION\nSYSUT2    1ST GENERATION\nTAG       GENERAL\nTHENDO    STRUCTURED\nTRACER    DIAGNOSTIC\nTRACER2   INTERNAL\nTRC       DIAGNOSTIC (1ST GENERATION ONLY)\nTRSP      GENERAL\nVAL       INTERNAL\nVERSION   INTERNAL\n\n                            DIAGNOSTIC\n\nTHE MACROS IN THIS GROUP FURNISH VARIOUS AIDS THAT CAN BE USED IN\nDIAGNOSING THE EXECUTION OF A PROGRAM.  THE 'BEGTEST' AND 'ENDTEST'\nMACROS ALLOW MULTIPLE LINES OF CODE TO BE INCLUDED OR EXCLUDED FROM\nAN ASSEMBLY, BASED ON THE VALUE OF A GLOBAL SET SYMBOL.\n\nBEGTEST\nTHIS MACRO HEADS A GROUP OF INSTRUCTIONS THAT ARE CONDITIONALLY\nINCLUDED OR EXCLUDED FROM A PARTICULAR ASSEMBLY. THE GROUP MUST BE\nTERMINATED WITH AN 'ENDTEST' MACRO.  THE 'BEGTEST' REQUIRES ONE\nPOSITIONAL OPERAND.  IF THE OPERAND IS NUMERIC, THEN THAT VALUE IS\nCOMPARED WITH THE GLOBAL TYPE 'A' SET SYMBOL &TESTLVL.  IF THE OPERAND\nIS GREATER THAN &TESTLVL, THEN THE INSTRUCTIONS BETWEEN THE 'BEGTEST'\nAND 'ENDTEST' ARE EXCLUDED FROM THIS ASSEMBLY, OTHERWISE THEY ARE\nINCLUDED:\n\n          GBLA  &TESTLVL\n &TESTLVL SETA  10\n ...\n          BEGTEST 5\n          WTO   'HELP'\n          ENDTEST ,\n\nIN THIS CASE, THE 'WTO' STATEMENT WILL BE ASSEMBLED.  IF &TESTLVL HAD\nBEEN SET TO 0 (ZERO), THEN THE 'WTO' WOULD HAVE BEEN EXCLUDED FROM\nTHIS ASSEMBLY.\n\nIF THE VALUE OF THE POSITIONAL OPERAND OF THE 'BEGTEST' IS 'A', 'B',\n'C', OR 'D', THEN THE LOGIC IS BASED ON THE SETTING OF THE GLOBAL TYPE\n'C' SET SYMBOL &$A, &$B, &$C OR &$D RESPECTIVELY:\n\n          GBLC  &$A\n&$A       SETC  'Y'     ANY OTHER VALUE CAUSES EXCLUSION\n...\n          BEGTEST A\n          WTO   'OPT CODE INCLUDED'\n          ENDTEST ,\n\nSINCE THE SET SYMBOL &$A WAS SET TO 'Y', THE 'WTO' WILL BE INCLUDED IN\nTHIS ASSEMBLY.  IF &$A HAD BEEN SET TO ANY OTHER VALUE THEN THE CODE\nWOULD NOT BE INCLUDED IN THIS ASSEMBLY.\n\nCVXREGS\nTHIS ONE CAUSES THE VALUES OF ALL 16 GPRS TO THE PRINTER. NO OPERANDS\nOTHER THAN THE NORMAL OPTIONAL NAME FIELD. IT REQUIRES THAT HEXRTN AND\nPRDEF (1ST GENERATION) OR HROUTINE AND PRINTER (2ND GENERATION) BE\nINCLUDED.\n\n          CVXREGS ,\n\nDISPLAY\nTHIS MACRO FUNCTIONS SIMILAR TO THE COBOL DISPLAY STATEMENT. IT\nREQUIRES THE HEX AND PRINT ROUTINES, AND ACCEPTS ONE OR MORE\nPOSITIONAL PARAMETERS. EACH OPERANT MUST BE ONE OF THE FOLLOWING:\nA PACKED DECIMAL FIELD (CONVERTED TO ZONED FOR PRINTING)\nA ZONED OR CHARACTER FIELD\nA GPR ENCLOSED WITHIN PARENTHESES\nA TEXT STRING ENCLOSED WITHIN QUOTES AND PRECEDED WITH A 'C'\n\n          DISPLAY C'DIAG INFO',FIELDA,(R15)\n\nDUMPMAIN\nTHIS ONE ACCEPTS PAIRS OF POSITIONAL OPERANDS, EACH OF WHICH MUST BE\nA MAIN STORAGE ADDRESS (NONE OF THAT GPR STUFF HERE, THANK YOU). THE\nFIRST OF EACH PAIR IS THE STARTING ADDRESS TO BE DUMPED, IN HEX, TO\nTHE PRINTER, AND THE SECOND IS THE LAST ADDRESS. MULTIPLE\nDISCONTIGUOUS GROUPS MAY BE SPECIFIED:\n\n          DUMPMAIN FIELDA,FIELDA+9,FIELDC,ENDFLDC\n\nENDTEST\nTHIS ONE NEEDS TO BE USED ONLY IN CONJUNCTION WITH THE 'BEGTEST'\nMACRO. IT IS USED TO END A GROUP OF CONDITIONALLY INCLUDED LINES OF\nCODE. PLEASE SEE THE DOCUMENTATION FOR 'BEGTEST'.\n\nHEXRTN\nHROUTINE\nTHESE MACLIB MEMBERS ARE NOT MACROS, BUT COPIED CODE. THEY PROVIDE\nVARIOUS HEXADECIMAL PRINTING SERVICES FOR OTHER DIAGNOSTIC ROUTINES.\nIF THE DEFINITION OF A DIAGNOSTIC MACRO THAT YOU WANT TO USE SPECIFIES\nTHE REQUIREMENT FOR ONE OF THESE ROUTINES, THEN CODE ONE OF THE\nFOLLOWING STATEMENTS NEAR THE END OF YOUR PROGRAM:\n\n          COPY HEXRTN             FOR VERSION 1 PROGRAMS ONLY\n          COPY HROUTINE           FOR VERSION 2 PROGRAMS ONLY\n\nTRACER\nTHIS MACRO IS SIMILAR TO 'DISPLAY', WITH THE DIFFERENCES THAT:\n1. IT WRITES ITS OUTPUT TO A FILE WITH DDNAME 'TRACER'\n2. IT REQUIRES THE INCLUSION OF OBJECT MODULE 'TRACER' AT LINK EDIT\n   TIME\n3. IT ALLOWS THE OPTIONAL INCLUSION OF A NUMERIC FIRST PARAMETER,\n   WHERE ITS VALUE IS COMPARED WITH THE GLOBAL TYPE A SET SYMBOL\n   &TESTLVL. IF THIS VALUE IS <= &TESTLVL, THEN THE TRACER CODE IS\n   GENERATED. IF IT IS > &TESTLVL, THEN IT IS TREATED AS A 'NOP'.\n   PLEASE SEE 'BEGTEST' FOR A MORE COMPLETE DESCRIPTION OF THE USE OF\n   &TESTLVL.\n\nTRC\nTHIS IS AN EARLIER VERSION OF THE TRACER MACRO, AND IS CONTINUED FOR\nCOMPATIBILITY PURPOSES.\n\n                            GENERAL\n\nADDR\nTHIS ONE COPIES THE ADDRESS OF A VARIABLE INTO A SPECIFIED REGISTER.\nIT REQUIRES TWO POSITIONAL OPERANDS. THE FIRST MUST BE A GPR. IF THE\nSECOND OPERAND IS ENCLOSED IN PARENTHESES, THEN IT IS ASSUMED TO BE A\nGPR AND IS COPIED INTO THE FIRST.  OTHERWISE, A 'LOAD ADDRESS (LA)'\nINSTRUCTION IS GENERATED. NOTE THAT IF THE SECOND OPERAND SPECIFIES\nTHE SAME GPR AS THE FIRST, THEN A 'NOP' IS GENERATED.\n\n         ADDR  R1,(R6)\n+        LR    R1,R6                GENERATED\n\n         ADDR  R14,ADDCON\n+        LA    R14,ADDCON           GENERATED\n\nAN\n'ADD NUMERIC' MIGHT SIMPLIFY SOME ADD OPERATIONS. IT REQUIRES TWO\nPOSITIONAL PARAMETERS. EACH CAN BE A GPR (THE OPERAND MUST BE ENCLOSED\nWITHIN PARENTHESES), A PACKED DECIMAL FIELD, OR A ZONED DECIMAL FIELD.\nTHE VALUE OF THE SECOND OPERAND IS ADDED TO THE VALUE OF THE FIRST,\nAND THE RESULT IS STORED IN THE FIRST OPERAND.\nNOTES: 1. WORK AREAS ARE GENERATED AS REQUIRED\n       2. PACKED FIELDS MAY BE FROM 1 THRU 16 BYTES LONG\n       3. ZONED FIELDS MAY BE FROM 1 THRU 31 BYTES LONG. IF A ZONED\n          FIELD IS LONGER THAN 16 BYTES, THEN MULTIPLE 'PACK'\n          INSTRUCTIONS ARE GENERATED TO CREATE THE CORRECT PACKED\n          RESULT.\n\n         AN    FIELD1,FIELD2\n+        AP    FIELD1,FIELD2     GENERATED IF BOTH ARE PACKED\n\n         AN    ZONED1,ZONED2\n+        PACK  WS_PL16A,ZONED1\n+        PACK  WS_PL16B,ZONED2\n+        AP    WS_PL16A,WS_PL16B\n+        UNPK  ZONED1,WS_PL16A\n\nBHE\nADDS ONE MORE 'EXTENDED MNEMONIC BRANCH' INSTRUCTION - BRANCH HIGH OR\nEQUAL. IT GENERATES A 'BNL' INSTRUCTION:\n\n         BHE   SKIPONE\n+        BNL   SKIPONE          GENERATED\n\nBLE\nADDS ONE MORE 'EXTENDED MNEMONIC BRANCH' INSTRUCTION - BRANCH LOW OR\nEQUAL. IT GENERATES A 'BNH' INSTRUCTION:\n\n         BLE   SKIPONE\n+        BNH   SKIPONE          GENERATED\n\nCOMBOX\nTHIS MEMBER OF MACLIB CAN BE USED DURING A TSO EDIT SESSION TO COPY A\nPRE-FORMATTED COMMENT BOX INTO YOUR CODE. IT IS NOT A MACRO.\n\nCONTINUE\nTHIS STATEMENT IS MEANT TO GIVE COBOL PROGRAMMERS A 'WARM FUZZY'\nWITHIN A STRUCTURED PROGRAM. IT GENERATES A 'NOP' INSTRUCTION:\n\n HERE1    CONTINUE ,\n+HERE1    DS    0H              GENERATED\n\nCVN\nTHIS 'CONVERT TO NUMERIC' MACRO REQUIRES TWO POSITIONAL OPERANDS, AND\nALLOWS A THIRD POSITIONAL AND A KEYWORD 'LEADING=' OPERAND. THE\nNUMERIC DIGITS OF THE SECOND ARE MOVED, RIGHT JUSTIFIED, TO THE FIRST.\nIF THE THIRD OPERAND IS SPECIFIED, IT MUST BE A GPR ENCLOSED WITHIN\nPARENTHESES, OR A PACKED DECIMAL FIELD. IT WILL CONTAIN THE NUMBER OF\nDIGITS DETECTED WITHIN THE SECOND OPERAND. THE DEFAULT VALUE FOR\n'LEADING=' IS 0 (ZERO), WHICH CAUSES LEADING ZEROS TO BE LOADED INTO\nTHE FIRST OPERAND. ITS OPTIONAL VALUE IS 'B' (FOR BLANK), WHICH CAUSES\nLEADING BLANKS TO BE LOADED.\n\n          CVN   FIELDA,FIELDB,(R1),LEADING=B\n\nCVXWORD\nTHIS MACRO REQUIRES TWO POSITIONAL OPERANDS. THE SECOND MUST BE 4\nBYTES LONG, AND IT IS MOVED AND EXPANDED INTO THE 8 BYTE FIRST\nOPERAND. EACH BYTE OF THE FIRST OPERAND WILL BE THE PRINTABLE\nEQUIVALENT OF THE HEXADECIMAL VALUE OF THE CORRESPONDING HALF-BYTE OF\nTHE SECOND OPERAND.\n\n          CVXWORD MYDOUBLE,MYFULL\n\nEM\nTHIS MACRO WAS INTENDED TO MAKE THE USE OF THE S/390 ED OR EDMK\nINSTRUCTIONS EASIER. I'M NOT SURE IT DOES. BUT, NONETHELESS, HERE\nIT IS:\n         SPACE 2\n\n'EM' UTILIZES 'ED' OR 'EDMK' TO EDIT USER FIELD TO USER'S SPECS\nTHE FIRST OPERAND SPECIFIES THE RECEIVING FIELD\nTHE SECOND IS THE SENDING FIELD AND MUST BE VALID DECIMAL DATA\n  (IF THE DATA IS ZONED, IT IS CONVERTED TO PACKED)\nTHE (OPTIONAL) THIRD FIELD (A NUMERIC SELF-DEFINING TERM)\n  SPECIFIES THE TOTAL NUMBER OF DIGITS TO THE RIGHT OF THE DECIMAL\n  - IF THIS PARAMETER IS OMITTED, THE SCALING VALUE OF THE SOURCE\n  OPERAND IS USED (EG: DC    PL4'12345.67' WOULD HAVE A SCALING\n  VALUE OF 2)\nFLOAT=X SPECIFIES THE FILL CHARACTER TO PRECEED THE\n  FIRST NUMERIC DIGIT (BLANK IS DEFAULT) (X IS ANY NON-BLANK CHAR)\nINSERT=X SPECIFIES THE SINGLE CHARACTER TO IMMEDIATELY PRECEED THE\n  FIRST NUMERIC DIGIT (BLANK IS DEFAULT) (X IS ANY NON-BLANK CHAR)\nEX: IF FLOAT=* AND INSERT=$ THEN THE RESULT COULD APPEAR:\n        *******$1,225.00\nCOMMA=NO CAUSES NO COMMAS TO BE INSERTED IN THE RESULT. LEAVING\n  PARAMETER OUT OR SPECIFYING ANY VALUE OTHER THAN 'NO' CAUSES\n  COMMAS TO BE INSERTED BETWEEN EACH THREE DIGITS\nMASK=HEXDIGITS ALLOWS USER TO SPECIFY HER/HIS OWN EDIT MASK\nDB=X ALLOWS USER TO SPECIFY TYPE OF NOTATION FOR +/- VALUES. IF\n  NOT SPECIFIED, NEGATIVE VALUES ARE INDICATED BY A '-' IN THE\n  HIGH ORDER POSITION (IMMEDIATELY PRECEDING THE MOST SIGNIFICANT\n  DIGIT.\n  SUPPORTED VALUES FOR THIS PARAMETER ARE:\n  DB=- OR DB=(-,LEFT/RIGHT)\n  DB=DB\n  DB=PARENS\n  DB=CR\n  DB=+ OR DB=(+,LEFT/RIGHT)\n  WHEN -, DB, OR PARENS IS SPECIFIED. INDICATION IS PROVIDED\n  FOR NEGATIVE VALUES ONLY. WHEN CR OR + IS SPECIFIED, AN\n  EXPLICIT INDICATION IS PROVIDED FOR POSITIVE OR NEGATIVE VALUES\n  (I.E. DB FOR NEGATIVE AND CR FOR POSITIVE).\n  FOR + AND - ONLY, A SECOND POSITIONAL SUBPARAMETER IS\n  SUPPORTED WHICH ALLOWS PLACEMENT OF THE SIGN TO THE LEFT OF THE\n  MOST SIGNIFICANT DIGIT, WITH NO BLANK POSITIONS BETWEEN THE SIGN\n  AND THE DIGIT. DEFAULT IS 'RIGHT', AGAIN WITH NO BLANK POSITIONS\n  BETWEEN THE RIGHTMOST DIGIT AND THE SIGN.\n  WHEN DB OR CR IS SPECIFIED, ONE BLANK POSITION IS PROVIDED\n  BETWEEN THE RIGHTMOST DIGIT AND THE CR OR DB INDICATOR.\nTHE FIRST TWO OPERANDS CAN BE SPECIFIED IN THE FOLLOWING WAYS:\n   DATANAME   - OR - DATANAME(LENGTH)   - OR -\n   DATANAME(,BASEREG)  - OR - DATANAME(LENGTH,BASEREG)  - OR -\n   NUMERIC(LENGTH,BASEREG)\nTHE LENGTH PARAMETER FOR EACH OPERAND DEFAULTS TO THE LENGTH\nATTRIBUTE OF THE VARIABLE NAME (IF ANY - THE LENGTH IS SET TO 1\nFOR EXPRESSIONS WHICH DO NOT BEGIN WITH A DATA NAME). THE LENGTH\nOF 'TARGET' MUST BE BETWEEN 1 AND 255. IF THE SOURCE ITEM IS\nZONED DECIMAL, ITS LENGTH MUST BE BETWEEN 1 AND 31. IF IT IS NOT\nZONED DECIMAL, THEN IT IS ASSUMED TO BE PACKED DECIMAL, AND ITS\nLENGTH MUST BE BETWEEN 1 AND 16 (16 IS THE MAXIMUM NUMBER OF BYTES\nIN A PACKED DECIMAL FIELD).\n\n         SPACE 2\n\nEPACK\nTHIS ONE (EXTENDED-PACK) REQUIRES TWO POSITIONAL PARAMETERS. IT COPIES\nTHE SECOND (FROM 1 TO 31 BYTES) INTO THE FIRST (FROM 1 TO 16 BYTES).\nIF THE SECOND IS LESS THAN 17 BYTES LONG, 1 PACK INSTRUCTION IS\nGENERATED. IF THE SECOND IS GREATER THAN 16 BYTES LONG, THEN MULTIPLE\nOVERLAPPING PACK INSTRUCTIONS ARE GENERATED AS REQUIRED. YOU MAY USE\nANY OF THE FORMS OF OPERAND FORMAT SUPPORTED BY THE PACK\nINSTRUCTION - IE IMPLICIT VS EXPLICIT DEFINITION OF THE LENGTH AND/OR\nBASE REGISTER:\n\n          EPACK PACKED1,ZONED1\n          EPACK 9(12,R4),0(23,R5)\n\nEQUATE\nTHIS ONE REQUIRES NO OPERANDS, AND GENERATES AN 'EQU' STATEMENT FOR\nEACH OF THE 16 GPRS:\n\n          EQUATE ,\n+R0       EQU   0\n+...\n+R15      EQU   15\n\nEUNPK\nTHIS UNPACKS THE SECOND OPERAND (1 TO 16 BYTES) INTO THE\nFIRST (1 TO 31 BYTES):\n\n          EUNPK  MYZONED1,MYPACKD1\n\nEXECUTE\nTHIS ONE MAKES IT POSSIBLE TO CONSTRUCT AN 'EX' INSTRUCTION WITH ONE\nLINE OF CODE.  IF YOU'VE NEVER USED THE 'EX' INSTRUCTION, YOU'RE\nPROBABLY BETTER OFF SKIPPING THE REST OF THIS 'EXECUTE' DOCUMENTATION.\nIF YOU HAVE ALREADY USED IT, OR IF YOU'RE VERY BRAVE, THEN HERE GOES.\nIT REQUIRES THREE POSITIONAL OPERANDS. THE FIRST IS A GPR (IT DOESN'T\nHAVE TO BE WITHIN PARENTHESES, SINCE IT HAS TO BE A GPR), THE SECOND\nIS THE OP CODE FOR THE INSTRUCTION BEING 'EX'ECUTED, AND THE THIRD\nCONSISTS OF ALL OF THE OPERANDS OF THE INSTRUCTION BEING 'EX'ECUTED,\nAND THEY MUST BE ENCLOSED WITHIN PARENTHESES.\n\n          EXECUTE R15,MVC,(FIELDA(0),FIELDB)\n+         EX     R15,$EX1234         GENERATED\n+...\n+$EX1234  MVC   FIELDA(0),FIELDB     GENERATED\n\nNOTE THAT THE THIRD OPERAND IS GENERATED OUT-OF-LINE.  IF VERSION 1\nMACROS ARE BEING USED, THEN THE OUT-OF-LINE INSTRUCTION WILL BE IN THE\nDATAAREA CSECT. IF VERSION 2 MACROS ARE BEING USED, THEN IT WILL BE\nADDRESSED BY THE DATA LOCTR. IF NEITHER VERSION 1 OR 2 IS BEING USED,\nGOOD LUCK.\n\nI\nTHIS MACRO REQUIRES ONE POSITIONAL PARAMETER (A GPR, NOT ENCLOSED\nWITHIN PARENTHESES), AND ALLOWS A SECOND. IN THE ONE-PARAMETER OPTION,\nTHE GPR SPECIFIED IS INCREMENTED BY 1. IF A SECOND PARAMETER\nIS SPECIFIED, THEN THE GPR SPECIFIED IS INCREMENTED BY THE AMOUNT\nSPECIFIED:\n\n          I     R5\n          I     R6,7\n\nIN THE FIRST EXAMPLE, R5 WILL BE INCREMENTED BY 1. IN THE SECOND,\nR6 WILL BE INCREMENTED BY 7.\n\nIP\nTHIS PERFORMS THE SAME SERVICE FOR PACKED DECIMAL FIELDS THAT 'I'\nPERFORMS FOR BINARY VALUES IN GPR'S:\n\n          IP   PACKED1\n          IP   PACKED2,7\n\nMACBOX\nTHIS MEMBER OF MACLIB CAN BE USED DURING A TSO EDIT SESSION TO COPY A\nPRE-FORMATTED COMMENT BOX INTO YOU CODE. IT IS NOT A MACRO.\n\nPRDEF    (VERSION 1)\nPRINTER  (VERSION 2)\nTHESE MACROS BRING IN THE EXECUTABLE CODE, THE DCB, AND THE BUFFERS\nNEEDED TO CREATE AND USE A PRINT FILE. THE NAME FIELD SPECIFIED IN\nTHE MACRO STATEMENT WILL BE THE NAME USED TO CALL THE PRINT ROUTINE\n(PCALL IN VERSION 1 AND PERFORM IN VERSION 2), AND KEYWORD PARAMETERS\nARE USED TO FURTHER CUSTOMIZE THE CODE. IN THE FOLLOWING, IF A VALUE\nIS GIVEN FOR A KEYWORD, THEN THAT VALUE IS THE DEFAULT:\n\n  DDNAME=SYSPRINT  USED IN CREATING THE DCB\n  LRECL=133        USED IN CREATING THE DCB\n  BLKSIZE=133      USED IN CREATING THE DCB\n  OUTLINE=OUTLINE  NAME FOR 133 BYTE FIELD USED FOR CONSTRUCTION\n                   AN OUTPUT DATA LINE. GENERATED BY THIS MACRO. MUST\n                   BE UNIQUE WITHIN THIS ASSEMBLY.\n  CCCHAR=CCCHAR    NAME OF CARRIAGE CONTROL CHARACTER. GENERATED BY\n                   THIS MACRO. MUST BE UNIQUE WITHIN THIS ASSEMBLY.\n                   PRESUMABLY THE FIRST BYTE OF 'OUTLINE'.\n  HEADER1=HEADER1  HEADER LINE PRINTED BY THIS ROUTINE AT THE HEAD OF\n                   EACH PAGE. TO CUSTOMIZE ITS VALUE, ISSUE THE\n                   FOLLOWING STATEMENTS AT SOME POINT FOLLOWING THIS\n                   MACRO:\n\n         ORG   HEADER1\n ...    CUSTOMIZATION CODE TOTALLING UP TO 133 CHARACTERS\n         ORG   ,\n\n  HEADER2=      CODE A VALUE (SUCH AS HEADER2=HEADER2) HERE IF YOU\n                NEED MORE THAT ONE HEADER LINE. DEFAULT IS 1 HEADER\n                LINE. SEE INSTRUCTIONS FOR HEADER1 FOR CUSTOMIZING.\n\n  HEADER3=      CODE A VALUE (SUCH AS HEADER3=HEADER3) HERE IF YOU\n                NEED MORE THAT TWO HEADER LINES. DEFAULT IS 1 HEADER\n                LINE. SEE INSTRUCTIONS FOR HEADER1 FOR CUSTOMIZING.\n\n  SPACES=SPACES THIS NAME IS GENERATED BY THE MACRO, AND IS USED TO\n                BLANK OUT 'OUTLINE' AT THE END OF EACH CALL. IT MUST\n                BE UNIQUE WITHIN EACH ASSEMBLY.\n\n  LINECT=LINECT THE NAME OF A VARIABLE, GENERATED BY THIS MACRO,\n                USED TO CONTROL PAGE OVERFLOW. IN GENERAL, IT SHOULD\n                NOT BE DIRECTLY MANIPULATED FROM OPEN CODE. MUST BE\n                UNIQUE WITHIN AN ASSEMBLY.\n\n  PSIZE=60      NUMBER OF LINES THAT CAN BE PRINTED PER PAGE. WHEN\n                THIS NUMBER IS EXCEEDED, PAGE OVERFLOW OCCURS,\n                HEADERS ARE PRINTED, AND THE DATA LINE WILL BE\n                PRINTED ON THE FOLLOWING PAGE.\n\n  PCTR=PCTR     NAME OF A PACKED DECIMAL VARIABLE USED TO MAINTAIN\n                PAGE COUNT. GENERATED BY THIS MACRO. MUST BE\n                UNIQUE WITHIN AN ASSEMBLY.\n\n  PFIELD=       THE NAME OF A FIELD, PRESUMABLY DEFINED WITHIN\n                HEADER1, HEADER2, OR HEADER3, WHERE THE PAGE COUNT\n                WILL BE MOVED DURING EACH PAGE OVERFLOW OPERATION.\n                NO PAGE NUMBER WILL BE PRINTED IF A VALUE IS NOT\n                SUPPLIED FOR THIS VARIABLE.\n\n  DCBNAME=PRINTER THIS IS THE NAME USED THE THE DCB GENERATED BY THIS\n                MACRO. MUST BE UNIQUE WITHIN AN ASSEMBLY.\n\nSETRC\nTHIS MACRO IS USED TO SET THE STORAGE LOCATION FOR R15 TO SOME VALUE.\nIF YOU HAVE USED EITHER VERSION 1 OR 2 MACROS IN YOUR PROGRAM, THEN\nTHE LOCATION FOR R15 IS SET TO ZERO AT THE TIME THE PROGRAM BEGINS\nEXECUTION, AND THIS MACRO CAN CHANGE IT TO SOME OTHER VALUE.  THERE\nIS ONE REQUIRED POSITIONAL PARAMETER, AND A SECOND OPTIONAL PARAMETER.\nTHE FIRST IS THE VALUE FOR THE RETURN CODE. IF IT IS A NUMERIC\nSELF-DEFINING TERM, THEN ITS VALUE BECOMES THE RETURN CODE. IF THIS\nPARAMETER IS ENCLOSED WITHIN PARENTHESES, THEN IT MUST BE A GPR, AND\nTHE VALUE IN THE GPR BECOMES THE RETURN CODE.  ELSE IF THE TYPE\nATTRIBUTE OF THE FIRST OPERAND IS 'H', THEN THE VALUE OF THE HALFWORD\nOPERAND BECOMES THE RETURN CODE, ELSE THE OPERAND IS ASSUMED TO BE A\nFULLWORD, AND ITS VALUE BECOMES THE RETURN CODE.\n\nIF THE SECOND OPERAND IS SPECIFIED, AND ITS VALUE IS 'RESET', THEN\nTHE VALUE OF THE FIRST OPERAND BECOMES THE NEW RETURN CODE. IF NOT,\nTHEN THE VALUE OF THE FIRST OPERAND BECOMES THE RETURN CODE ONLY IF\nIT IS GREATER THAN THE CURRENT VALUE OF THE RETURN CODE.\n\n          SETRC 12\n ...\n          SETRC 0,RESET\n\nTAG\nUSING THIS MACRO IS A WAY TO ASSIGN A TAG TO AN INSTRUCTION WITHOUT\nCAUSING ANY CODE TO BE GENERATED. IF THE GLOBAL TYPE C SET SYMBOL\n&$MTRACE IS CURRENTLY SET TO 'YES', THEN A 'TRACER' MACRO IS ISSUED\nTO SHOW THAT THE INSTRUCTION LOGIC HAS PROCESSED THIS INSTRUCTION.\n\n HERENOW TAG   ,\n\nTRSP\n\n   'TRSP' WILL RETURN (IN REG 15) THE NUMBER OF TRAILING SPACES IN THE\n   OPERAND FIELD. THE LENGTH OF THE FIELD MAY BE FROM 1 TO 256 BYTES.\n   TO PROCESS THE FIELD USING THE LENGTH DEFINED FOR THE FIELD CODE:\n\n        TRSP  MYFIELD\n\n   WHERE 'MYFIELD' IS THE FIELD TO BE TESTED. IF YOU NEED TO SPECIFY A\n   LENGTH OTHER THAN THE DEFAULT, THEN CODE THE LENGTH WITHIN\n   PARENTHESES IMMEDIATELY FOLLOWING THE OPERAND:\n\n        TRSP  MYFIELD(30)\n\n   IF YOU NEED TO CODE THE OPERAND USING BASE+DISPLACEMENT, THEN CODE:\n\n        TRSP  12(30,R7)\n\n   WHERE 12 IS THE DISPLACEMENT (ANY VALUE FROM 0 TO 4095) AND R7 IS\n   ANY GPR OTHER THAN R0. IN THIS FORM, THERE IS NO DEFAULT LENGTH, SO\n   IT MUST BE EXPLICITLY CODED AS THE FIRST VALUE WITHIN THE\n   PARENTHESES.\n\n\n                            INTERNAL\n\n\n                            RUN-TIME-TOTALS\n\nTHIS FAMILY WAS CREATED TO MAKE IT EASIER TO COUNT THE NUMBER OF PASSES\nTHROUGH VARIOUS PARTS OF A PROGRAM, GIVE EACH COUNTER AN ASSOCIATED\nTEXT STRING, AND THEN PRINT OUT THE COUNTERS AND THE TEXT AT THE END OF\nTHE PROGRAM'S EXECUTION.\n\nWITHIN THIS LIBRARY, ANY MACRO NAME BEGINNING WITH 'RTT' IS PART OF THIS\nFAMILY.\n\nWITHIN THE DATA DIVISION PORTION OF THE PROGRAM, YOU MUST CODE ONE\nHEADER MACRO, ONE TRAILER MACRO, AND, BETWEEN THEM, ONE ENTRY MACRO FOR\nEACH COUNTER THAT YOU NEED.\n\nRTTBEG\nTHIS IS THE HEADER MACRO. IT MUST PRECEED THE ENTRY MACROS THAT DEFINE\nTHE COUNTERS BEING CREATED. IT SUPPORTS TWO OPTIONAL KEYWORD PARAMETERS:\n\n          RTTBEG  TEXTLEN=50,MAXVAL=9999999\n\nTEXTLEN DEFINES THE BYTE-LENGTH OF THE FIELD, CREATED FOR EACH ENTRY,\nTHAT WILL BE USED TO DESCRIBE THE COUNTER ON THE PRINTED REPORT. ITS\nDEFAULT VALUE IS 50.\n\nMAXVAL MUST BE THE LARGEST VALUE THAT YOU EXPECT ANY COUNTER TO ATTAIN.\nNOTE THAT THIS MUST BE THE SAME VALUE FOR ALL THE COUNTERS CREATED\nWITHIN ONE PROGRAM. ITS DEFAULT IS 7 DIGITS (9999999).\n\nRTTENT\nCODE ONE OF THESE MACROS FOR EACH COUNTER THAT YOU WILL NEED:\n\n          RTTBEG ,\nCOUNTER1  RTTENT 'VALUE FOR COUNTER1'\nCOUNTER2  RTTENT 'VALUE FOR COUNTER2'\n          RTTEND ,\n\nNOTE THAT EACH RTTENT STATEMENT HAS A NAME FIELD. THIS IS THE VALUE\nTHAT IS USED IN THE PROCEDURE DIVISION TO INCREMENT THE COUNTER. THE\nVALUE WITHIN THE QUOTES IS PRINTER ALONG WITH THE VALUE FOR THE COUNTER\nWHEN THE RTTPRT MACRO IS ISSUED.\n\nRTTEND\nTHIS MACRO MUST BE CODED IMMEDIATELY FOLLOWING THE LAST 'RTTENT'. IT\nHELPS CONTROL THE OPERATION OF THE 'RTTPRT' MACRO.\n\nRTTINCR\nTHIS MACRO IS USED IN THE EXECUTABLE PORTION TO INCREMENT ONE OF THE\nCOUNTERS THAT WAS DEFINED WITH THE 'RTTENT' MACRO. IT CAN BE USED TO\nINCREMENT THE COUNTER BY 1 (DEFAULT) OR BY SOME OTHER VALUE:\n\n          RTTINCR COUNTER1\n\n          -- OR --\n\n          RTTINCR COUNTER2,3\n\nIN THE FIRST EXAMPLE, 'COUNTER1' WILL BE INCREMENTED BY 1. IN THE\nSECOND, 'COUNTER2' WILL BE INCREMENTED BY 3.\n\nRTTPRT\nTHIS MACRO CAUSES THE VALUE FOR EACH COUNTER THAT WAS PREVIOUSLY\nDEFINED WITH AN RTTENT MACRO TO BE PRINTED, ALONG WITH THE VALUE FOR THE\nTEXT STRING ASSOCIATED WITH THE COUNTER.  IT REQUIRES THAT 'PRDEF' BE\nINCLUDED IN THE ASSEMBLY, AND IT DOES NOT RESET THE COUNTERS TO ZERO\nUNLESS YOU CODE:\n\n          RTTPRT RESET=YES\n\nOBVIOUSLY (?) 'RESET=NO' IS THE DEFAULT.\n\nRTTRESET\nYOU CAN USE THIS MACRO TO RESET THE ACCUMULATED VALUES FOR ALL OF THE\nCOUNTERS THAT WERE DEFINED WITH AN 'RTTENT' MACRO WITHOUT PRINTING\nTHEIR VALUES:\n\n          RTTRESET ,\n\nIN THIS EXAMPLE, ALL OF THE COUNTERS WILL BE RESET. IN THE FOLLOWING\nEXAMPLE, ONLY 'COUNTER1' WILL BE RESET:\n\n          RTTRESET COUNTER1\n\nHERE IS A TRADITIONAL 80-80 LIST PROGRAM THAT KEEPS A FEW COUNTERS. IT\nWILL MAKE USE OF 2ND GENERATION, STRUCTURED, GENERAL, AND RUN-TIME\nMACROS:\n\nIDENTIFICATION DIVISION PROGID=EIGHTY80\nDATA     DIVISION\nSYSIN    DCB   DDNAME=SYSIN,MACRF=GM,LRECL=80,EODAD=ENDSYSIN,          X\n               DSORG=PS,RECFM=FB\nIN_BUF   DS    CL80\nEOF_SW   DC    C'N'\n         RTTBEG ,\nIPTCOUNT RTTENT 'INPUT RECORDS READ'\nOPTCOUNT RTTENT 'OUTPUT RECORDS WRITTEN'\n         RTTEND ,\nPROCEDURE DIVISION\n         OPEN  (SYSIN)\n         PERFORM GETINPUT\n         DO    WHILE=(CLI,EOF_SW,C'Y',NE)\n           MVC   OUTLINE+1(80),IN_BUF\n           PERFORM PRINTRTN\n           RTTINCR OPTCOUNT\n           PERFORM GETINPUT\n         ENDO ,\n         RTTPRT ,\n         CLOSE (SYSIN,,PRINTER)\n         GOBACK ,\nGETINPUT SECTION ,\n         GET   SYSIN,IN_BUF\n         RTTINCR IPTCOUNT\n         RETN  ,\nENDSYSIN MVI   EOF_SW,C'Y'\n         ENDSECT ,\nPRINTRTN PRDEF  ,\n         FINAL  ,\n         END   EIGHTY80\n\n                            STRUCTURED\n\nTHIS SET OF MACROS CAUSES A CONDITIONAL AND/OR REPETITIVE EXECUTION OF\nA GROUP OF ONE OR MORE INSTRUCTIONS.  FOR CONVENIENCE, LET'S CALL A\nGROUP OF INSTRUCTIONS THAT MIGHT OR MIGHT NOT BE EXECUTED ONE TIME, OR\nMULTIPLE TIMES, A 'CR-GROUP', FOR 'C'ONDITIONAL/'R'EPETITIVE.\n\nEACH CR-GROUP MUST BE HEADED BY ONE OF THE FOLLOWING MACRO STATEMENTS:\n\n  AFTER      DO     EVERY      FIRST      IF\n\nAND MUST BE TERMINATED BY ONE OF THE FOLLOWING:\n\n  ENDAFTER   ENDO   ENDEVERY   ENDFIRST   ENDIF\n\nIT IS SOMEWHAT OVERSIMPLIFYING TO SAY THAT ALL OF THE ENDXXXXX MACROS\nSIMPLY INVOKE 'ENDO', BUT THE TRUTH IS THAT THE INDIVIDUAL ENDXXXXX\nMACROS ARE MORE FOR PROGRAM DOCUMENTATION THAN THEY ARE FOR INTERNAL\nLOGIC DIFFERENCES. SO, IF YOU END AN CR-GROUP WITH AN 'ENDAFTER'\nMACRO, NO DIAGNOSTICS WILL BE ISSUED AND YOUR PROGRAM WILL WORK THE\nSAME AS IF YOU HAD CODED AN 'ENDIF'.\n\nCR-GROUPS MAY BE NESTED TO ANY DESIRED LEVEL:\n\n          IF    ...\n          ...\n            DO    ...\n            ...\n            ENDO  ,\n          ...\n          ENDIF ,\n\nYOU MAY FIND IT EFFECTIVE TO INDENT AT EACH LEVEL OF NESTING, BUT\nBEWARE - THE CONTINUATION COLUMN IS ALWAYS THE SAME (16 IS THE\nDEFAULT).\n\nTHERE ARE TWO ADDITIONAL SIGNIFICANT MACROS THAT CAN BE USED WITHIN\nTHIS PACKAGE OF STRUCTURED PROGRAMMING MACROS.  THE 'ELSEIF' MACRO CAN\nBE USED FOLLOWING AN 'IF' OR ANOTHER 'ELSEIF' MACRO, AND SUPPORTS THE\nSAME TYPES OF LOGIC THAT THE 'IF' MACRO SUPPORTS.  THE 'ELSE' MACRO\nCAN FOLLOW AN 'IF', 'ELSEIF', 'AFTER', 'EVERY' OR 'FIRST' MACRO, AND\nALLOWS ITS CR-GROUP TO BE EXECUTED IF ALL OF THE PRECEDING CR-GROUPS\nWERE NOT EXECUTED.\n\nAFTER\nTHIS MACRO HEADS A CR-GROUP THAT WILL BE SKIPPED FOR THE FIRST 'N'\nPASSES THROUGH THIS SECTION OF CODE, AND THEN EXECUTED EVERY PASS\nTHROUGH THE CODE FROM THEN ON.  'N' MUST BE A NUMERIC SELF-DEFINING\nTERM.\n\n         AFTER 1000000\n            ...\n         ENDAFTER ,\n\nDO\nTHIS ONE PROVIDES REPETITIVE EXECUTION OF A CR-GROUP. THERE ARE\nSEVERAL OPTIONS: THE FIRST IS TO CODE A NUMERIC SELF-DEFINING TERM,\nWHICH CAUSES THE CR-GROUP TO BE EXECUTED THAT NUMBER OF TIMES:\n\n          DO    5\n            ...\n          ENDO  ,\n\nA SLIGHT VARIATION IS TO CODE:\n\n         DO    FOREVER\n           ...\n         ENDO  ,\n\nTHIS CAUSES THE CR-GROUP TO BE CONTINUOUSLY EXECUTED UNTIL SOMETHING\nEITHER WITHIN THE LOOP OR SOMETHING OUTSIDE THE PROGRAM (TIME\nEXCEEDED, ETC) CAUSES THE LOOP TO BE BROKEN.\n\nIF YOU CODE:\n\n         DO    MYVARBL\n           ...\n         ENDO  ,\n\nTHEN 'MYVARBL' MUST BE A PACKED DECIMAL VARIABLE WHICH YOU HAVE\nALREADY INITIALIZED TO THE VALUE FOR THE NUMBER OF TIMES THAT YOU\nWANT THIS CR-GROUP REPEATED. BE VERY CAREFUL ABOUT MODIFYING THIS\nVARIABLE FROM WITHIN THE LOOP. ITS VALUE IS CAPTURED ONLY AT THE\nBEGINNING OF THE EXECUTION OF THE CR-GROUP, AND ANY CHANGE TO THE\nVALUE OF THE VARIABLE WILL TAKE EFFECT THE NEXT TIME THE 'DO'\nSTATEMENT IS ENCOUNTERED.\n\nIF YOU WANT TO REPEAT A CR-GROUP BASED ON ONE OR MORE CONDITIONS,\nTHEN YOU CAN USE EITHER ONE OF THE FOLLOWING:\n\n         DO    UNTIL=(...)\n           ...\n         ENDO  ,\n\n         .. OR ..\n\n         DO    WHILE=(...)\n           ...\n         ENDO  ,\n\nIN THE FIRST OF THESE TWO EXAMPLES, THE CR-GROUP WILL BE EXECUTED\nREPETITIVELY UNTIL ONE OR MORE OF THE CONDITIONS IS MET. IN THE\nSECOND, IT WILL BE EXECUTED SO LONG AS ONE OR MORE OF THE CONDITIONS\nIS MET.  IN BOTH OF THESE EXAMPLES, THE VALUES WITHIN THE PARENTHESES\nARE THE SAME AS FOR THE 'IF' MACRO. PLEASE SEE ITS DOCUMENTATION FOR\nTHE DETAILS.  THE ONLY DIFFERENCE BETWEEN THE OPERANDS HERE AND FOR\nTHE 'IF' MACRO IS THAT, IF THE CONDITION IS COMPLEX, THAT IS, IF IT\nCONSISTS OF MULTIPLE CONDITIONS CONNECTED WITH 'AND' AND/OR 'OR'\nCLAUSES, THEN THE ENTIRE OPERAND MUST BE ENCLOSED WITHIN ONE\nADDITIONAL LEVEL OF PARENTHESES:\n\n          DO    UNTIL=((...),OR,(...))\n                      *              *  <== REQUIRED IF COMPLEX\n            ...\n          ENDO  ,\n\nONE ADDITIONAL KEYWORD OPERAND IS AVAILABLE:\n\n          DO    UNTIL=(...),TEST=AFTER\n            ...\n          ENDO  ,\n\n          .. OR ..\n\n          DO    WHILE=(...),TEST=AFTER\n            ...\n          ENDO  ,\n\nTHE 'TEST=AFTER' CAUSES THE CR-GROUP TO BE EXECUTED ONE TIME BEFORE\nTHE CONDITIONAL TESTS ARE MADE. DEFAULT IS 'TEST=BEFORE', WHERE THE\nCR-GROUP MIGHT NOT BE EXECUTED EVEN ONCE, DEPENDING ON THE INITIAL\nCONDITIONS.\n\nELSE\nTHIS MACRO MAY BE CODED ONLY WITHIN A CR-GROUP HEADED BY AN 'AFTER',\n'ELSEIF', 'EVERY' OR 'FIRST' CR-GROUP HEADER.  IT CAUSES EXECUTION OF\nITS CR-GROUP IF ALL OF THE PREVIOUS CR-GROUPS HAVE BEEN BYPASSED:\n\n          AFTER 1000000\n            ...             EXECUTED AFTER 1,000,000 PASSES\n          ELSE  ,\n            ...             EXECUTED FIRST 1,000,000 PASSES\n          ENDELSE ,\n\nELSEIF\nTHIS MACRO MAY FOLLOW ONLY ANOTHER 'ELSEIF' STATEMENT, OR AN 'IF'\nSTATEMENT. IT SUPPORTS ALL THE OPTIONS OF THE 'IF' STATEMENT. PLEASE\nSEE THE 'IF' STATEMENT FOR THE DETAILS.\n\n          IF    (...),THENDO\n            ...\n          ELSEIF (...),THENDO\n            ...\n          ENDELSE ,\n\nENDAFTER\nENDELSE\nENDEVERY\nENDFIRST\nENDIF\nENDO\nTHESE MACROS ARE EQUIVALENT, AND SHOULD BE USED TO END THEIR\nRESPECTIVE TYPES OF CR-GROUPS.\n\nEVERY\nTHIS MACRO HEADS A CR-GROUP THAT WILL BE EXECUTED EVERY 'N'TH PASS\nTHROUGH THIS SECTION OF CODE. 'N' MUST BE A NUMERIC SELF-DEFINING TERM.\n\n         EVERY 1000000\n            WTO   'ANOTHER 1,000,000 PASSES'\n         ENDEVERY ,\n\nFIRST\nTHIS MACRO HEADS A CR-GROUP THAT WILL BE EXECUTED FOR THE FIRST 'N'\nPASSES THROUGH THIS SECTION OF CODE, AND THEN SKIPPED EVERY PASS\nTHROUGH THE CODE FROM THEN ON.  'N' MUST BE A NUMERIC SELF-DEFINING\nTERM.\n\n         FIRST 1000000\n            ...\n         ENDAFTER ,\n\nITS DESIGNED USE IS TO DO STUFF ONLY ON THE FIRST PASS THROUGH A\nSECTION OF CODE\n\n         FIRST 1\n           OPEN  (...)\n         ENDFIRST ,\n\nIF\nTHIS IS THE HEART OF THE STRUCTURED MACROS. IT SUPPORTS THE\nCONDITIONAL EXECUTION OF A CR-GROUP BASED ON ONE OR MORE TESTS. EACH\nTEST PHRASE, CONTAINED WITHIN PARENTHESES, MUST CONSIST OF AN OP-CODE,\nA FIRST OPERAND, A SECOND OPERAND, AND A CONDITION. (NOTE OP-CODES\nWITH OTHER THAN TWO OPERANDS ARE SUPPORTED, BUT THE OP-CODE MUST\nALWAYS BE FIRST AND THE CONDITION MUST ALWAYS BE LAST WITHIN THE\nPHRASE.)  FOLLOWING THE LAST PHRASE, THE FINAL POSITIONAL PARAMETER\nMUST BE 'THENDO':\n\n          IF    (CLC,FIELDA,FIELDB,E),THENDO\n            ...\n          ENDIF ,\n\nNOTE THAT THE OP-CODE 'CLC' WILL BE USED THROUGHOUT THESE EXAMPLES.\nWHEN YOU CODE YOUR PROGRAM, USE WHATEVER INSTRUCTION IS APPORPRIATE,\nSO LONG AS IT IS ONE THAT SETS THE PROCESSOR'S CONDITION CODE FIELD.\n\nIN THIS EXAMPLE, IF FIELDA IS EQUAL TO FIELDB, THEN THE CR-GROUP\nWILL BE EXECUTED.  THE CONDITION, CODED AS THE LAST POSITIONAL\nSUB-PARAMETER, CAN BE ANY OF THE EXTENDED BRANCH NMEMONICS:\n\n  E NE H NH L NL M NM O NO P NP Z NZ\n\nIN THE ABOVE EXAMPLE, THE MACRO EXPANDS INTO:\n\n          IF    (CLC,FIELDA,FIELDB,E),THENDO\n+         CLC   FIELDA,FIELDB    GENERATED\n+         BNE   $TAG             BRANCH AROUND 'IF' GROUP\n          ...                    YOUR INSTRUCTIONS\n          ENDIF ,\n+$TAG     DS    0H\n\nNOTE: '$TAG' INDICATES THAT THE MACRO GENERATION PROCESS WILL GENERATE\nAN UNIQUE TAG, WHOSE NAME BEGINS WITH '$', AND ENDS WITH A UNIQUE NUMBER\nOBTAINED FROM A SYSTEM COUNTER.\n\nIF YOU HAD CODED 'NE' AS THE CONDITION, THEN IT WOULD EXPAND TO:\n\n          IF    (CLC,FIELDA,FIELDB,NE),THENDO\n+         CLC   FIELDA,FIELDB    GENERATED\n+         BE    $TAG             BRANCH AROUND 'IF' GROUP\n          ...                    YOUR INSTRUCTIONS\n          ENDIF ,\n+$TAG     DS    0H\n\n     TO EXECUTE THE CR-GROUP IF EITHER ONE OF TWO CONDITIONS IS\nTRUE, THE FORMAT IS:\n\n     IF    (CLC,A,B,NE),OR,(CLC,C,D,NE),THENDO\n\n     ALTERNATE FORMAT:\n                                                          72\n     IF    (CLC,A,B,NE),OR,                                C\n           (CLC,C,D,NE),THENDO\n\n     SINCE 'AND' TAKES PRECEDENCE OVER 'OR', IN THE FOLLOWING\nEXAMPLE, THE CR-GROUP IS PERFORMED IF THE FIRST TEST IS TRUE, OR\nIF BOTH THE SECOND AND THIRD ARE TRUE:\n\n     IF    (CLC,A,B,E),OR,                                 C\n           (CLC,C,D,E),AND,                                C\n           (CLC,E,F,E),THENDO\n\n     IF THE CR-GROUP IS TO BE PERFORMED IF THE THIRD IS TRUE AND\nEITHER THE FIRST OR SECOND IS TRUE, INCLUDE THE TESTS CONNECTED\nBY THE 'OR' WITHIN ADDITIONAL PARENTHESES:\n\n           * <-NESTING PARENTHESES -> *\n     IF    ((CLC,A,B,E),OR,(CLC,C,D,E)),AND,               C\n           (CLC,E,F,E),THENDO\n\n     THE AUTHOR OF THESE MACROS PREFERS THE FORMAT:\n\n     IF    ((CLC,A,B,E),OR,                                C\n           (CLC,C,D,E)),AND,                               C\n           (CLC,E,F,E),THENDO\n\n     I GUESS THE BOTTOM LINE IS THAT S/390 ASSEMBLER IS SOMEWHAT OF A\nPAIN, NO MATTER HOW YOU FORMAT THE STATEMENTS!\n\n     GROUPS OF EXPRESSIONS MAY BE NESTED AS DEEPLY AS REQUIRED\nTO DEFINE THE LOGIC DESIRED. THE LIMIT IS THAT ANY SINGLE\nPARAMETER IS LIMITED BY THE ASSEMBLER TO 255 CHARACTERS IN LENGTH.\n\n     EACH CR-GROUP MUST BE TERMINATED WITH AN 'ENDO' STATEMENT\nOR AN 'ELSE' - 'ENDELSE' COMBINATION:\n\n     ENDIF ,\n                 - OR -\n     ELSE  ,\n     ... ADDITIONAL INSTRUCTIONS TO BE EXECUTED IF 'IF' FAILS\n     ENDELSE ,  (OR ENDIF - EITHER IS ACCEPTABLE AFTER AN 'ELSE')\n\n     ALTERNATIVELY, A CR-GROUP CAN BE TERMINATED AS FOLLOWS:\n\n     ELSEIF  (CLC,G,H,E),THENDO ...\n        ...\n     ELSEIF  (CLC,I,J,E),THENDO ...\n        ...\n     ELSE  ,\n        ...\n     ENDELSE ,\n\n     ANY NUMBER OF 'ELSEIF' STATEMENTS CAN FOLLOW THE ORIGINAL\n     'IF' STATEMENT. THERE MAY BE (BUT NEED NOT BE) ONE AND ONLY\n     ONE 'ELSE' STATEMENT FOLLOWING THE FINAL 'ELSEIF'. THE ENTIRE\n     GROUP IS TERMINATED WITH ONE 'ENDIF' OR 'ENDELSE'.\n\nNEXT\nI WROTE THIS MACRO SO THAT AN ASSEMBLER PROGRAM COULD BE MADE TO LOOK\nEVEN MORE LIKE COBOL.  IT IS THE EQUIVALENT TO 'CONTINUE', AND ITS ONLY\n(REQUIRED) POSITIONAL PARAMETER IS 'SENTENCE':\n\n         IF    (TM,0(R1),X'80',O),THENDO\n            NEXT  SENTENCE\n         ENDIF ,\n\nTHENDO\nTHIS WAS THE ORIGINAL STRUCTURED MACRO OF THIS PACKAGE.  IT IS NOT SO\nPOWERFUL AS THE NEWER ONES, BUT YOU MIGHT FIND SOME USE FOR IT. ITS ONLY\nPOSITIONAL PARAMETER MUST BE ONE OF THE CONDITIONS THAT YOU CAN APPEND\nTO THE 'B' TO CREATE ONE OF THE EXTENDED BRANCH INSTRUCTIONS, SUCH AS\n'E'.  PLEASE REFER TO THE DOCUMENTATION FOR THE 'IF' MACRO FOR A\nCOMPLETE LIST.\n\nTHIS MACRO DEPENDS ON A PREVIOUS INSTRUCTION IN THE PROGRAM, SUCH AS A\n'CLR', TO SET THE CONDITION CODE. ITS CR-GROUP WILL THEN BE EXECUTED IF\nTHE OPERAND SATISFIES THE SETTING OF THE CONDITION CODE:\n\n          CLR   R5,R6\n          THENDO E\n            ...\n          ENDO  ,\n\n          -- OR --\n\n          CLC   R5,R6\n          THENDO E\n            ...\n          ELSE  ,\n            ...\n          ENDO  ,\n\nIN THIS EXAMPLE, THE FIRST CR-GROUP WILL BE EXECUTED IF R5 = R6, AND\nTHE SECOND WILL BE EXECUTED IF THEY ARE UNEQUAL.\n\nTHAT'S IT, FOLKS. NO OTHER OPTIONS FOR 'THENDO' (OTHER THAN NESTING).\n\n                            2ND GENERATION\n\nTHIS SET OF MACROS WAS INTENDED TO MAKE IT SOMEWHAT EASIER FOR COBOL\nPROGRAMMERS TO PICK UP S/390 ASSEMBLER. THE CODING CONVENTIONS ARE\nSTANDARD ASSEMBLER, BUT THE NAMES, OPERANDS, AND FUNCTIONS OF THE MACROS\nJUST MIGHT MAKE THE TRANSITION A LITTLE EASIER.\n\nTHE 'DIVISION' AND 'SECTION' MACROS GIVE THE PROGRAM AN APPEARANCE NOT\nTOO DIFFERENT FROM COBOL.  THE 'SECTION' MACRO CAN BE USED IN THE\n'DATA DIVISION' (FOR DOCUMENTATION), BUT ITS USE IN THE 'PROCEDURE\nDIVISION' IS USED TO DEFINE SUBROUTINES.\n\nWHEN YOU CREATE AN EXECUTABLE SECTION (THAT IS, A 'SECTION' MACRO\nWITHIN THE 'PROCEDURE DIVISION'), EXECUTION CAN BE TRANSFERRED IN ONE\nOF THREE WAYS:\n1. EXECUTION CAN FALL THROUGH INTO THE SECTION. IN THIS CASE, THE\n   SECTION CAN BE USED TO INCREASE THE SIZE OF THE PROGRAM BEYOND THE\n   4K LIMIT ON EXECUTABLE CODE WITHIN THE MAIN PORTION OF THE PROGRAM\n   WHICH IS IMPOSED BY THE USE OF ONLY ONE BASE REGISTER. WHEN\n   EXECUTION FALLS THROUGH INTO A SECTION, THEN EXECUTION 'FALLS OUT'\n   AT THE END. WHEN THE PROGRAM BEGINS EXECUTION, THE RETURN LOGIC\n   OF EACH SECTION IS PRE-SET TO FALL THROUGH TO THE NEXT SECTION, AND,\n   WHENEVER IT IS EXECUTED VIA FALL-THROUGH, THIS SAME EXIT IS RESET.\n2. A SECTION CAN BE EXECUTED BY THE 'PERFORM SECTNAME' MACRO. IN THIS\n   CASE, WHEN THE SECTION FINISHES, EXECUTION RETURNS TO THE STATEMENT\n   FOLLOWING THE 'PERFORM'. THIS LOGIC SETS THE RETURN OF THIS SECTION\n   TO BE TO THE STATEMENT FOLLOWING THE PERFORM.\n3. A SECTION CAN BE EXECUTED BY THE 'GOTO' STATEMENT.  THE 'GOTO' DOES\n   NOT CHANGE THE EXIT LOGIC FOR THE SECTION, SO BEWARE USING MORE THAN\n   ONE METHOD FOR SECTION EXECUTION. IF YOU USE ONLY FALL-THROUGH AND\n   'GOTO', THEN EXECUTION WILL ALWAYS FALL THROUGH TO THE FOLLOWING\n   SECTION. IF YOUR PROGRAM ALWAYS USES A 'PERFORM' FIRST, THEN A\n   'GOTO', THEN EXECUTION WILL ALWAYS RETURN TO THE STATEMENT FOLLOWING\n   THE 'PERFORM'.  IF YOU USE MULTIPLE 'PERFORMS' FOR A PARTICULAR\n   SECTION, AND/OR ALLOW EXECUTION TO FALL THROUGH INTO THE SECTION,\n   AND THEN YOU USE A 'GOTO' MACRO, AND YOU MAKE IT WORK CORRECTLY,\n   THEN YOU'RE A BETTER PROGRAMMER THAN I.\n\nA PROGRAM TO INCREMENT A COUNTER AND PRINT A LINE MIGHT LOOK LIKE:\n\nIDENTIFICATION DIVISION PROGID=PRINTPGM\nDATA     DIVISION\nWORKING_STORAGE SECTION\nCOUNTER  DC    PL2'0'\nPROCEDURE DIVISION ,\n         MVC   OUTLINE+1(09),=CL09'TEST DATA'\n         PERFORM COUNTRTN\n         PERFORM PRINTRTN\n         GOBACK ,\nCOUNTRTN SECTION ,\n         AP    COUNTER,=P'1'\n         UNPK  OUTLINE+11(3),COUNTER\n         IO    OUTLINE+13,C'0'\n         RETN  ,\n         ENDSECT ,\nPRINTRTN PRINTER ,\n         FINAL ,\n         END   PRINTPGM\n\nDIVISION\nTHIS MACRO PROVIDES THE HEADING FOR EACH OF THE MAIN SECTIONS OF A\nPROGRAM. THE NAME FIELD (BEGINNING IN COL 1) IS REQUIRED, AND, LIKE A\nCOBOL PROGRAM, THE DIVISIONS MUST OCCUR IN ORDER: IDENTIFICATION,\nDATA, THEN PROCEDURE (SORRY, NO 'ENVIRONMENT' DIVISION IS SUPPORTED).\n\nWHEN THE NAME FIELD IS 'IDENTIFICATION', THEN THE KEYWORD PARAMETER\n'PROGID=' IS REQUIRED, AND THIS NAME BECOMES THE NAME OF THE CSECT (OR\nPROGRAM) BEING CREATED:\n\nIDENTIFICATION DIVISION PROGID=MAINPROG\n\nTHE NEXT STATEMENT IMPORTANT TO THESE MACROS WOULD BE:\n\nDATA     DIVISION\n\nNO PARAMETERS FOR THIS ONE, THANK YOU. WHAT THIS ONE DOES IS TO CREATE\nTWO LOCATION COUNTERS (INST AND DATA), THEN CREATE A REGISTER SAVE AREA\nWITHIN THE 'DATA' LOCTR. WHEN YOU CODE STATEMENTS WITHIN THE DATA\nDIVISION, THEY MAY BE 'DC', 'DS', 'DCB', ETC.\n\nTHREE ADDITIONAL MACROS MAY BE INCLUDED WITHIN THE DATA DIVISION:\n\nFILE     SECTION ,\n\nWORKING_STORAGE SECTION ,\n\nLINKAGE  SECTION ,\n\nTHESE ARE FOR DOCUMENTATION PURPOSES ONLY. YOU MIGHT MAKE IT EASIER\nON FUTURE PROGRAMMERS WHO WORK ON YOUR CODE IF YOU CODE 'DCB' STATEMENTS\nWITHIN THE 'FILE SECTION', AND OTHER STATEMENTS THAT ACTUALLY ALLOCATE\nSTORAGE IN THE 'WORKING_STORAGE SECTION', AND MAPPING STATEMENTS SUCH AS\nDSECTS IN THE 'LINKAGE SECTION'.\n\nNEXT COMES THE:\n\nPROCEDURE DIVISION ,\n\nIT HAS AN OPTIONAL KEYWORD PARAMETER: INTRO=YES/NO. IF YOU CODE 'YES'\n(WHICH IS THE DEFAULT), THEN MESSAGES ARE WRITTEN TO THE LOG ABOUT WHEN\nTHE MODULE WAS COMPILED, AND WHEN IT IS BEING EXECUTED. IF YOU CODE\n'NO', THEN THE MESSAGES ARE NOT WRITTEN.\n\nA SECOND OPTIONAL KEYWORD, 'BASE=', ALLOWS YOU TO SPECIFY A BASE\nREGISTER. R12 IS THE DEFAULT.\n\nANOTHER OPTIONAL KEYWORD IS 'LINK='. THIS ALLOWS YOU TO SPECIFY A GPR\nTO BE USED IN LINKING TO INTERNAL SUBROUTINES (VIA THE 'PERFORM'\nMACRO). DEFAULT IS R14.\n\nAFTER THIS 'PROCEDURE DIVISION' MACRO IS EXECUTED, THE ENVIRONMENT\nPRESENTED TO YOU IS:\n\nR1 POINTS TO THE HALFWORD DESCRIBING THE PARAMETERS (IF ANY) PASSED TO\n   THIS PROGRAM\nR12 (DEFAULT) IS THE BASE REGISTER\nR13 POINTS TO THE REGISTER SAVE AREA (ALSO THE BEGINNING OF THE DATA\n    DIVISION)\n\nAT THIS POINT, YOU MAY START CODING 'NORMAL' EXECUTABLE INSTRUCTIONS.\n\nENDSECT\nTHIS STATEMENT MUST BE USED TO END THE CODE OF A 'SECTION' THAT YOU\nHAVE CREATED TO BE USED AS AN INTERNAL SUBROUTINE. IT GENERATES A\n'RETN' FUNCTION, SO THAT IF EXECUTION FALLS THROUGH TO THE 'ENDSECT'\nSTATEMENT, THE SUBROUTINE WILL RETURN CONTROL TO THE STATEMENT\nFOLLOWING THE 'PERFORM' THAT INVOKED THE SECTION.\n\nFINAL\nTHIS MACRO NEEDS TO BE CODED AS THE LAST STATEMENT BEFORE THE 'END'\nSTATEMENT FOR THE ASSEMBLY.  IT CORRELATES THE CREATION AND USAGE OF\nTHE 'SECTION' STATEMENTS IN THE PROGRAM, AND MAKES AS SURE AS POSSIBLE\nTHAT YOU HAVE USED THE 'PERFORM' AND 'SECTION' STATEMENTS CORRECTLY.\nIF YOU OMIT THIS MACRO, YOU WILL GET ERROR MESSAGES ABOUT\nUNDEFINED VARIABLES.\n\nGOBACK\nTHIS STATEMENT CAN BE USED WITHIN THE MAIN PORTION OF A PROGRAM, OR\nFROM WITHIN A 'PERFORMED' SECTION. IN EITHER CASE, IT SIGNALS THE\nCOMPLETION OF THIS PROGRAM AND RETURNS CONTROL TO THE OPERATING SYSTEM\n(OR TO THE CALLING PROGRAM, IF AN MVS 'CALL' MACRO WAS USED TO INVOKE\nTHE PROGRAM).\n\nITS ONE OPTIONAL KEYWORD PARAMETER IS:\n\n          GOBACK  RC=...\n\nIF THE PARAMETER IS ENCLOSED WITHIN PARENTHESES, THEN IT MUST BE A GPR\nWHICH CONTAINS THE VALUE TO BE USED AS A RETURN CODE. IF IT IS A\nNUMERIC SELF-DEFINING TERM, THEN THAT VALUE BECOMES THE RETURN CODE. IF\nIT IS THE NAME OF A HALFWORD OR FULLWORD IN STORAGE, THEN THE VALUE\nSTORED IN THAT VARIABLE BECOMES THE RETURN CODE.  IF THE PARAMETER IS\nNOT CODED, THEN THE RETURN CODE IS LEFT AS IT IS.  THIS VALUE IS SET TO\nZERO WHEN THE PROGRAM BEGINS EXECUTION (BY THE PROCEDURE DIVISION\nMACRO), AND CAN BE CHANGED VIA THE 'SETRC' MACRO.\n\nGOTO\nTHIS IS ONE OF THE METHODS OF TRANSFERRING EXECUTION TO A 'SECTION'.\nIT HAS ONE REQUIRED POSITIONAL PARAMETER, AND ONE OPTIONAL POSITIONAL\nPARAMETER. IN THE FIRST EXAMPLE, EXECUTION IS TRANSFERRED\nUNCONDITIONALLY TO THE SECTION:\n\n          GOTO  MYSECT\n\nIN THE SECOND EXAMPLE, EXECUTION IS TRANSFERRED CONDITIONALLY BASED ON\nTHE CURRENT SETTING OF THE CONDITION CODE (WHICH MUST HAVE BEEN SET BY\nA PREVIOUS STATEMENT):\n\n         CLC   FIELDA,FIELDB\n         GOTO  E,MYSECT\n\nIN THIS CASE, EXECUTION WOULD BE TRANSFERRED IF FIELDA = FIELDB,\nOTHERWISE EXECUTION WOULD PASS TO THE STATEMENT FOLLOWING THE 'GOTO'.\n\nPLEASE SEE THE DOCUMENTATION AT THE BEGINNING OF '2ND GENERATION' FOR\nA THOROUGH DESCRIPTION OF THE CAVEATS CONCERNING THE USE OF THE 'GOTO'\nMACRO.\n\nPERFORM\nTHIS MACRO CAUSES EXECUTION TO TRANSFER UNCONDITIONALLY TO THE SECTION\nIDENTIFIED BY ITS ONE REQUIRED POSITONAL PARAMETER:\n\n          PERFORM MYSECT\n\nWHEN THE SECTION FINISHES ITS EXECUTION, CONTROL IS RETURNED TO THE\nSTATEMENT FOLLOWING THE 'PERFORM'.\n\nRETN\nTHIS MACRO, WHEN USED WITHIN A SECTION, CAUSES CONTROL TO BE RETURNED\nTO THE STATEMENT IMMEDIATELY FOLLOWING THE 'PERFORM' STATEMENT, OR, IF\nTHE SECTION WAS ENTERED VIA FALL-THROUGH, TO THE FIRST STATEMENT OF THE\nSECTION IMMEDIATELY FOLLOWING THIS SECTION.\n\nITS ONE OPTIONAL POSITIONAL PARAMETER TESTS A CONDITION, WHICH MUST HAVE\nBEEN SET BY A PREVIOUS INSTRUCTION, UNDER WHICH A RETURN ACTION IS TO\nOCCUR. IF THE CONDITION IS FALSE, THEN THE INSTRUCTION FOLLOWING THE\n'RETN' WILL BE EXECUTED:\n\n         RETN  ,            UNCONDITIONAL RETURN\n\n         -- OR --\n\n         CLC   FIELDA,FIELDB\n         RETN  E            RETURN IF FIELDA = FIELDB\n         ...                OTHERWISE FALL THROUGH\n\nSECTION\nWHEN VARIATIONS OF THIS MACRO ARE CODED WITHIN THE 'DATA DIVISION'\n(PLEASE SEE THE DESCRIPTION OF THE 'DIVISION' MACRO), THEY HAVE A\nDIFFERENT MEANING THAN WHEN THEY ARE USED IN THE 'PROCEDURE DIVISION'.\n\nWHEN IT IS USED IN THE 'PROCEDURE DIVISION', THE 'SECTION' MACRO DEFINES\nA GROUP OF INSTRUCTIONS THAT CAN BE CALLED AS AN INTERNAL SUBROUTINE\nWITHIN THE PROGRAM BEING ASSEMBLED. IT CAN BE EXECUTED VIA FALL-THROUGH,\nTHE PERFORM MACRO, OR THE GOTO MACRO. BY DEFAULT, WHEN A SECTION BEGINS\nEXECUTION, REGS 2 - 11 ARE SAVED, AND THEY ARE RESTORED WHEN EXECUTION\nRETURNS TO THE CALLING STATEMENT.\n\nIF YOU DO NOT WANT THE REGISTERS RESORED AFTER A SECTION'S EXECUTION,\nTHEN CODE THE OPTIONAL KEYWORD PARAMETER:\n\nMYSECT   SECTION RESTORE=N\n\nIF YOU WANT SOME DIFFERENT SET OF REGISTERS TO BE RESTORED, THEN YOU\nCAN CODE:\n\nMYSECT   SECTION MAXREG=NN\n\nWHERE 'NN' IS THE NUMBER OF THE HIGHEST REGISTER THAT YOU WANT TO BE\nRESTORED. THE LOWEST WILL ALWAYS BE REG 2. SO, IF YOU CODE:\n\nMYSECT   SECTION MAXREG=8\n\nTHEN REGS 2 - 8 WILL BE RESTORED JUST BEFORE THE SECTION RETURNS CONTROL\nTO THE CALLING ROUTINE.\n\n                            1ST GENERATION\n\nI WROTE THIS 'SUB-PACKAGE' OF MACROS IN THE EARLY 1970'S, AND IT MAY\nOFFER MORE TOTAL VERSATILITY THAN THE 2ND GENERATION PACKAGE. THE MAIN\nPROGRAM RESIDES IN A CSECT WITH THE SAME NAME AS THE NAME FIELD THAT\nYOU SPECIFY ON YOUR 'GO' MACRO, IT USES A CSECT NAMED 'DATAAREA' TO\nHOLD CONSTANTS AND VARIABLES, AND CREATES AN ADDITIONAL CSECT FOR EACH\n'PROC' (SUBROUTINE) THAT YOU CREATE.  THE ORIGINAL INTENT WAS TO MAKE IT\nEASY TO CREATE RE-ENTRANT PROGRAMS, BUT THAT FACET HAS NOT BEEN\nCOMPLETED.\n\nITS MAIN ADVANTAGE OVER THE 2ND GENERATION MACROS IS THAT THE USE OF\nMULTIPLE BASE REGISTERS WITHIN EACH ROUTINE IS SUPPORTED, SO THAT IT\nIS CONVENIENT TO HAVE A MODULE SIZE OF 8K, 12K, OR 16K, DEPENDING ON\nTHE NUMBER OF REGISTERS THAT YOU CARE TO DEVOTE TO ADDRESSABILITY.\n\nPLEASE CONTACT THE AUTHOR FOR ADDITIONAL DOCUMENTATION.\n\nTHE FOLLOWING IS A ROUTINE THAT I USE TO CREATE ENTRIES IN A TRACE FILE\nDURING THE TESTING PHASE OF A PROGRAM.  THE CALLING PROGRAM MUST PASS,\nAS ITS ONLY PARAMETER, A 133 CHARACTER PRINT LINE (ASA CARRIAGE\nCONTROL). WHEN CALLED FOR THE FIRST TIME, TRACERTN WILL ISSUE AN 'OPEN'\nFOR THE FILE. AS THE CALLING PROGRAM IS TERMINATING, IT SHOULD CALL\nTRACERTN WITH '99999999' IN COLS 2-9 OF THE DATA LINE, CAUSING TRACERTN\nTO ISSUE A CLOSE FOR THE FILE.\n\n         PRINT NOGEN\nIDENTIFICATION DIVISION PROGID=TRACERTN\nDATA     DIVISION\nFILE     SECTION\nPRINTER  DCB   DDNAME=TRACER,DSORG=PS,MACRF=PM,RECFM=FBA,LRECL=133,    X\n               BLKSIZE=133\nWORKING_STORAGE SECTION\nSPACES   DC    CL133' '\nLINKAGE  SECTION\nPASSED   DSECT\nPASSED_DATA DS CL133\nPROCEDURE DIVISION INTRO=NO        DON'T ISSUE TIME-STAMP WTO\n         L     R11,0(,R1)          ADDRESS OF CALLER'S DATA\n         USING PASSED,R11          ASSEMBLER CONVENTION\n         FIRST 1                   FIRST TIME THRU...\n           IF   (CLC,=C'99999999',PASSED_DATA+1,E),THENDO CLOSE SIGNAL?\n             GOBACK ,              DON'T DO NOTHIN\n           ELSE  ,\n             OPEN  (PRINTER,OUTPUT)  . OPEN THE TRACER FILE\n           ENDIF ,\n         ENDO  ,                   .\n         IF    (CLC,=C'99999999',PASSED_DATA+1,E),THENDO CLOSE SIGNAL?\n           CLOSE PRINTER           . YES - DO IT\n         ELSE  ,\n           PUT   PRINTER,PASSED_DATA . ELSE PRINT THE LINE\n           MVC   PASSED_DATA,SPACES  AT YOUR SERVICE...\n         ENDIF ,                   .\n         GOBACK ,                  AMSCRAY\n         FINAL ,                   BOOKKEEPING\n         END\n\u001a\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$NOTE": {"ttr": 2052, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x996?\\x00\\x996?\\x11C\\x00\\x16\\x00\\x16\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-29T00:00:00", "modifydate": "1999-12-29T11:43:00", "lines": 22, "newlines": 22, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject: Macros\nDate: Wed, 29 Dec 1999 10:59:30 -0500\nFrom: \"Snyder, Dan\" <Dan_Snyder@Compuware.com>\nTo: \"'Sam Golob'\" <sbgolob@ibm.net>\n\nI'll be happy to send along all the macros that I've written, but\nfirst a few caveats:\n\n1.  I am the only person that has made much use of the macros.  I\n    know of no problems with them, but I use them within my own\n    knowledge of what they do and how they work. As we pass them on\n    to others for evaluation, I would guess that they are somewhere\n    around the 'alpha test' level.  I have coded error MNOTE\n    statements for some of the things that can be done wrong, but\n    I'm sure I haven't guessed at all the things that can be done\n    wrong.\n\n2.  There are two different levels of base register-subroutine call\n    macros that are incompatible with each other.  A given program\n    must be coded with one or the other.  I wrote the first version\n    in about 1974, and the second in 1993.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$READ$$": {"ttr": 2054, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x02\\x01\\x013\\x1f\\x01\\x013\\x1f\\x13)\\x00b\\x00b\\x00\\x00\\xc7\\xc5\\xd5\\xe3\\xd9\\xf0\\xf2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-11-27T00:00:00", "modifydate": "2001-11-27T13:29:02", "lines": 98, "newlines": 98, "modlines": 0, "user": "GENTR02"}, "text": "                               STRUCTURED MACROS\n\n  THESE MACROS CAN HELP YOU CREATE NEW PROGRAMS AND MODIFY EXISTING CODE BY\n  SUPPORTING IF-THEN-ELSE LOGIC WHILE REQUIRING ONLY A SMALL LEARNING CURVE\n  FROM WHAT YOU ALREADY KNOW ABOUT S/390 ASSEMBLER (ASSUMING THAT YOU DO\n  KNOW IT ALREADY).  EACH 'IF' STATEMENT CAN BE ARBITRARILY COMPLEX, AND THE\n  'IF' STATEMENTS CAN BE NESTED AS MANY LEVELS AS YOU MIGHT NEED (CERTAINLY,\n  NO ONE WOULD NEED MORE THAN 255 LEVELS OF NESTING, WOULD SHE?).\n\n  EACH GROUP OF INSTRUCTIONS THAT YOU WANT CONDITIONALLY EXECUTED WOULD BE\n  HEADED BY AN 'IF' MACRO, AND TERMINATED BY AN 'ENDIF' MACRO.\n\n  IN ITS SIMPLIST FORM, THE OPERAND OF THE 'IF' MACRO CONSISTS OF AN OP-CODE,\n  THE FIRST OPERAND ADDRESS, THE SECOND OPERAND ADDRESS, AND A CONDITION. THESE\n  FOUR VALUES MUST BE ENCLOSED WITHIN PARENTHESES, AND FOLLOWING THE OPERANDS\n  MUST BE A COMMA AND THE STATEMENT TERMINATING TERM 'THENDO'.\n\n  THE OP-CODE MAY BE ANY VALID S/390 OP-CODE THAT SETS THE CONDITION CODE. THE\n  FIRST AND SECOND OPERANDS MAY BE ANY VALUES THAT ARE VALID FOR THE INSTRUCTION\n  BEING CREATED. THE CONDITION, SUCH AS 'E' OR 'NO, IS ANY VALUE THAT CAN BE\n  USED IN CREATING AN EXTENDED MNEMONIC BRANCH INSTRUCTION (SUCH AS 'BE' OR\n  'BNO').\n\n  IF YOU CHOOSE 'E' AS THE CONDITION, THEN THE GROUP OF INSTRUCTIONS BETWEEN THE\n  'IF' AND THE 'ENDIF' WILL BE EXECUTED ONLY IF THE CONDITION CODE SET BY THE\n  OP-CODE AND OPERANDS SPECIFIED IS A ZERO.\n\n  IN THE FOLLOWING EXAMPLES, THE HEADING WILL INDICATE THE\n  CONDITIONS IN WHICH THE DO-GROUP WILL BE EXECUTED. IN EACH CASE,\n  AN 'IF' STATEMENT DETERMINES THE CONDITIONS, AND AN 'ENDIF'\n  STATEMENT TERMINATES THE DO-GROUP. COMMENTS EITHER IN THE HEADING\n  OR ON THE APPROPRIATE INSTRUCTIONS WILL INDICATE THE DETAILS.\n       HERE IS AN EXAMPLE:\n\n         IF    (CLC,A,B,NE),THENDO\n\n  THE INSTRUCTIONS BETWEEN THIS 'IF' AND ITS MATCHING 'ENDIF' WILL BE EXECUTED\n  IF THE RESULT OF THE 'CLC' IS A 1 OR 2 (THE NOT-EQUAL CONDITION).\n\n       TO EXECUTE THE DO-GROUP IF EITHER ONE OF TWO CONDITIONS IS\n  TRUE, THE FORMAT IS:\n\n       IF    (CLC,A,B,NE),OR,(CLC,C,D,NE),THENDO\n\n       ALTERNATE FORMAT:\n                                                            72\n       IF    (CLC,A,B,NE),OR,                                C\n             (CLC,C,D,NE),THENDO\n\n       SINCE 'AND' TAKES PRECEDENCE OVER 'OR', IN THE FOLLOWING\n  EXAMPLE, THE DO-GROUP IS PERFORMED IF THE FIRST TEST IS TRUE, OR\n  IF BOTH THE SECOND AND THIRD ARE TRUE:\n\n       IF    (CLC,A,B,E),OR,                                 C\n             (CLC,C,D,E),AND,                                C\n             (CLC,E,F,E),THENDO\n\n       IF THE DO-GROUP IS TO BE PERFORMED IF THE THIRD IS TRUE AND\n  EITHER THE FIRST OR SECOND IS TRUE, INCLUDE THE TESTS CONNECTED\n  BY THE 'OR' WITHIN ADDITIONAL PARENTHESES:\n\n             * <-NESTING PARENTHESES -> *\n       IF    ((CLC,A,B,E),OR,(CLC,C,D,E)),AND,               C\n             (CLC,E,F,E),THENDO\n\n       ALTERNATE FORMAT:\n                                                            72\n       IF    ((CLC,A,B,E),OR,                                C\n             (CLC,C,D,E)),AND,                               C\n             (CLC,E,F,E),THENDO\n\n       GROUPS OF EXPRESSIONS MAY BE NESTED AS DEEPLY AS REQUIRED\n  TO DEFINE THE LOGIC DESIRED.\n       EACH DO-GROUP MUST BE TERMINATED WITH AN 'ENDIF' STATEMENT\n  OR AN 'ELSE' - 'ENDELSE' COMBINATION:\n\n       ENDIF ,\n                   - OR -\n       ELSE  ,\n       ... ADDITIONAL INSTRUCTIONS TO BE EXECUTED IF 'IF' FAILS\n       ENDELSE ,  (OR ENDIF - EITHER IS ACCEPTABLE AFTER AN 'ELSE')\n\n       ALTERNATIVELY, A DO-GROUP CAN BE TERMINATED AS FOLLOWS:\n\n       ELSEIF  (CLC,G,H,E),THENDO ...\n\n       ANY NUMBER OF 'ELSEIF' STATEMENTS CAN FOLLOW THE ORIGINAL\n       'IF' STATEMENT. THERE MAY BE (BUT NEED NOT BE) ONE AND ONLY\n       ONE 'ELSE' STATEMENT FOLLOWING THE FINAL 'ELSEIF'. THE ENTIRE\n       GROUP IS TERMINATED WITH ONE 'ENDIF' OR 'ENDELSE'.\n\n       IF    (...),THENDO            REQUIRED\n       ...\n       ELSEIF (...),THENDO           OPTIONAL (REPEATED AS REQUIRED)\n       ...\n       ELSE  ,                       OPTIONAL\n       ...\n       ENDIF ,                       REQUIRED (OR 'ENDELSE')\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$AGOTO": {"ttr": 2057, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00\\x00o\\x01\\x00\\x00o\\x18S\\x00\\r\\x00\\r\\x00\\x00\\xc2\\xc3\\xd6\\xc4\\xc8\\xe2\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-01-06T00:00:00", "modifydate": "2000-01-06T18:53:00", "lines": 13, "newlines": 13, "modlines": 0, "user": "BCODHS0"}, "text": "         MACRO\n         $AGOTO &NAME,&SEQ\n         COPY  $MGBLDEF\n         VERSION 2\n&$GOTOC  SETA  &$GOTOC+1           BUMP TO NEXT CELL\n         AIF   (&$GOTOC LE &$GOTOM).ADDONE\n         MNOTE 8,'GOTO TABLE SPACE OF &$GOTOM EXCEEDED - MACRO ABORTED'\n&$GOTOC  SETA  &$GOTOC-1           BACK IT DOWN...\n         MEXIT\n.ADDONE  ANOP\n&$GOTO(&$GOTOC) SETC '&NAME'       NAME FOR FUTURE SEARCH\n&$GREF(&$GOTOC) SETC '&SEQ'        &SYSNDX FOR DIAGNOSTICS\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$ASECT": {"ttr": 2059, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00\\x00o\\x01\\x00\\x00o\\x18S\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc2\\xc3\\xd6\\xc4\\xc8\\xe2\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-01-06T00:00:00", "modifydate": "2000-01-06T18:53:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "BCODHS0"}, "text": "         MACRO\n         $ASECT &NAME\n         COPY  $MGBLDEF\n         VERSION 2\n&$SECTC  SETA  &$SECTC+1           BUMP TO NEXT AVAILABLE CELL\n         AIF   (&$SECTC LE &$SECTM).ADDONE\n     MNOTE 8,'SECTION TABLE SPACE OF &$SECTM EXCEEDED - MACRO ABORTED'\n&$SECTC  SETA  &$SECTC-1           BACK IT DOWN...\n         MEXIT\n.ADDONE  ANOP\n&$SECT(&$SECTC) SETC '&NAME'       SAVE SECTION NAME FOR FUTURE TEST\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$IA": {"ttr": 2061, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x995\\x0f\\x00\\x995\\x0f\\x10A\\x00\\x0f\\x00\\x0f\\x00\\x00\\xc2\\xc3\\xd6\\xc4\\xc8\\xe2\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-16T00:00:00", "modifydate": "1999-12-16T10:41:00", "lines": 15, "newlines": 15, "modlines": 0, "user": "BCODHS0"}, "text": "         MACRO\n&NAME    $IA   &DUMMY              RE-ENTER INSTRUCTION ZONE\n         COPY  $MGBLDEF            BRING IN THE CLOWNS (VERSIONS 1 & 2)\n         GBLC  &GSECT,&WSECT       PRESET NAMES (VERSION 2)\n         LCLC  &X                  SHORT FOR CSECT\n         AIF   ('&$MSECT(1)' EQ '').GENLOC ARE WE USING GO/STOP MACROS?\n&X       SETC  '&$MSECT(&$MPLVL)'  YES - SET TO NAME OF CSECT\n&X       CSECT                     BACK TO PREVIOUS CSECT\n         MEXIT                     WRAP IT UP, TONY\n.GENLOC  AIF   ('&GSECT' NE '').GEN2 GO IF ALREADY DEFINED\n&GSECT   SETC  'GSECT'             GIVE IT A VALUE - ANY VALUE...\n.GEN2    AIF   ('&$MLOCTR' EQ '&GSECT').MEND EXIT IF CODE NOT NEEDED\n&$MLOCTR SETC  '&GSECT'            SAVE FOR NEXT TIME\n&GSECT   LOCTR                     BACK TO INSTRUCTION TYPE LOCTR\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$MENDDO1": {"ttr": 2063, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&NAME    $MENDDO1 &DOGROUP=\n         COPY  $MGBLDEF\n         LCLA  &J\n&$MDGERR SETA  0                   ASSUME NO ERROR\n&J       SETA  &$MDGLVL\n         AIF   (&J GT 0).OK02\n         MNOTE 8,'NO ACTIVE DO-GROUP TO TERMINATE'\n         MNOTE 0,' - MACRO GENERATION ABORTED'\n&$MDGERR SETA  4                   WARN OTHERS\n         MEXIT\n.OK02    AIF   ('&DOGROUP' EQ '').SKIP15\n         AIF   ('&DOGROUP' NE '*ALL*').TEST10 FALL THROUGH IF *ALL*\n&J       SETA  1                   END ALL BUT OUTERMOST DO-GROUP\n         AGO   .SKIP20             ENTER COMMON LOOP\n.TEST10  AIF   ('&DOGROUP' EQ '&$MDGNAM(&J)').SKIP20\n&J       SETA  &J-1\n         AIF   (&J GE 1).TEST10\n         MNOTE 8,'ATTEMPT TO END NON-EXISTANT DO-GROUP ''&DOGROUP'''\n         MNOTE 0,'ALL ACTIVE DO-GROUPS TERMINATED'\n&J       SETA  1\n         AGO   .SKIP20\n.SKIP15  AIF   ('&NAME' EQ '').ENDIT DO NOTHING IF ONLY 1 LEVEL\n&NAME    DC    0H'0'               WELL, MAYBE A TAG...\n         MEXIT\n.SKIP20  AIF   ('&NAME' EQ '').LOOP30\n&NAME    DC    0H'0'               DEFINE END OF DO-GROUP\n.LOOP30  AIF   (&J GE &$MDGLVL).ENDIT END 1 BEFORE LAST LEVEL\n         $MENDDO2                  END 1 LEVEL\n         AIF   (&$MDGERR NE 0).ENDIT QUIT IF ERROR OCCURRED\n         AIF   (&$MDGLVL LE 1).ENDIT\n         AGO   .LOOP30\n.ENDIT   MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$MENDDO2": {"ttr": 2065, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00Q\\x01\\x013\\x1f\\x01\\x02\\x01\\x7f\\x14R\\x00\\x17\\x00\\x16\\x00\\x00\\xc7\\xc5\\xd5\\xe3\\xd9\\xf0\\xf2@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2001-11-27T00:00:00", "modifydate": "2002-01-17T14:52:51", "lines": 23, "newlines": 22, "modlines": 0, "user": "GENTR02"}, "text": "         MACRO\n         $MENDDO2\n         COPY  $MGBLDEF\n         LCLC  &X\n&$MDGERR SETA  0                   RESET TO 0\n         AIF   (&$MDGLVL GT 0).AOK IF NOT GT 0 THEN NOTHING TO DO\n         MNOTE 8,'ATTEMPT TO END NON-EXISTENT DO-GROUP(S)'\n&$MDGERR SETA  8                   SHOW ERROR OCCURRED\n         MEXIT\n.AOK     AIF   ('&$MLTAG(&$MDGLVL)' EQ '').SKIP10\n         J     &$MLTAG(&$MDGLVL)   RETURN TO 'DO'\n&$MLTAG(&$MDGLVL) SETC ''          NULLIFY\n.SKIP10  ANOP\n&X       SETC  '$MD&$MIFELS(&$MDGLVL)&$MDGSEQ(&$MDGLVL)'\n&X       DC    0H'0'               DEFINE END OF CONDITIONAL GROUP\n&$MCVERB(&$MDGLVL) SETC ''\n         AIF   ('&$MFNBR(&$MDGLVL)' EQ '').SKIP30\n&X       SETC  '$MDF&$MFNBR(&$MDGLVL)'\n&$MFNBR(&$MDGLVL) SETC ''\n&X       DC    0H'0'               DEFINE TAG FOR 'ELSEIF' STATEMENTS\n.SKIP30  ANOP\n&$MDGLVL SETA  &$MDGLVL-1\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$MGBLDEF": {"ttr": 2067, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\x01\\x7f\\x01\\x02\\x01\\x7f\\x10\\x17\\x00\\x04\\x00\\x04\\x00\\x00\\xc7\\xc5\\xd5\\xe3\\xd9\\xf0\\xf2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-01-17T00:00:00", "modifydate": "2002-01-17T10:17:00", "lines": 4, "newlines": 4, "modlines": 0, "user": "GENTR02"}, "text": "         GBLA  &$MDGLVL,&$MDGERR,&$MRECUR,&$MBLATH\n         GBLC  &$MFNBR(31),&$MDGNAM(255),&$MDGSEQ(255),&$MNAME,&$MNC\n         GBLC  &$MIFELS(255),&$MLTAG(255),&$MPNAM1(31),&$MFNAM1(31)\n         GBLC  &$MCVERB(255),&$MC\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$MGFNAME": {"ttr": 2069, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n         $MGFNAME &DUMMY           CREATE A UNIQUE TAG FOR 'IF'\n         COPY  $MGBLDEF\n&$MFNAM1(&$MRECUR) SETC  '$MDF&SYSNDX' COMPARE-FAILED TAG\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$MGFNBR": {"ttr": 2071, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n         $MGFNBR &DUMMY            CREATE A UNIQUE TAG FOR 'ELSEIF'\n         COPY  $MGBLDEF            COPY IN ALL THE SYMBOLS\n&$MFNBR(&$MDGLVL) SETC '&SYSNDX'   CREATE UNIQUE SEQUENCE NUMBER\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$MGPNAME": {"ttr": 2073, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n         $MGPNAME &DUMMY           CREATE A UNIQUE TAG FOR 'IF'\n         COPY  $MGBLDEF\n&$MPNAM1(&$MRECUR) SETC  '$MDP&SYSNDX' COMPARE-SUCCEEDED TAG\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$WA": {"ttr": 2075, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x995\\x0f\\x00\\x995\\x0f\\x10A\\x00\\x10\\x00\\x10\\x00\\x00\\xc2\\xc3\\xd6\\xc4\\xc8\\xe2\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-16T00:00:00", "modifydate": "1999-12-16T10:41:00", "lines": 16, "newlines": 16, "modlines": 0, "user": "BCODHS0"}, "text": "         MACRO\n&NAME    $WA   &DUMMY\n         COPY  $MGBLDEF            BRING IN THE CLOWNS (VERSIONS 1 & 2)\n         GBLC  &GSECT,&WSECT       PRESET NAMES (VERSION 2)\n         AIF   ('&$MSECT(1)' EQ '').GENLOC\nDATAAREA CSECT                     WORKING-STORAGE CSECT\n         MEXIT\n.GENLOC  AIF   ('&GSECT' NE '').GEN2 GO IF ALREADY DEFINED\n&GSECT   SETC  'GSECT'             GIVE IT A VALUE - ANY VALUE...\n&GSECT   LOCTR                     INSTRUCTION AREA LOCATION COUNTER\n.GEN2    AIF   ('&WSECT' NE '').GEN3 GO IF ALREADY DEFINED\n&WSECT   SETC  'WSECT'             GIVE IT A VALUE - ANY VALUE...\n.GEN3    AIF   ('&$MLOCTR' EQ '&WSECT').MEND\n&$MLOCTR SETC  '&WSECT'\n&WSECT   LOCTR                     WORKING-STORAGE LOCATION COUNTER\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "@FILE438": {"ttr": 2077, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00\"\\x00\\x99\\x08?\\x01\\x014_\\x10\\x18\\x00\\xf3\\x00\\x02\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "1999-03-24T00:00:00", "modifydate": "2001-12-11T10:18:22", "lines": 243, "newlines": 2, "modlines": 0, "user": "SBGOLOB"}, "text": "//***FILE 438 is from Dan Snyder of Columbus, Ohio and contains     *   FILE 438\n//*           his collection of structured assembler macros that    *   FILE 438\n//*           he developed for himself, over many years of coding.  *   FILE 438\n//*                                                                 *   FILE 438\n//*          email:   dsnyder@elektro.cmhnet.org                    *   FILE 438\n//*                   Dan_Snyder@stercomm.com                       *   FILE 438\n//*                                                                 *   FILE 438\n//*  -------------------------------------------------------------  *   FILE 438\n//*                                                                 *   FILE 438\n//*                       STRUCTURED MACROS                         *   FILE 438\n//*                                                                 *   FILE 438\n//*  >>> - - - - - - - - - - - - - - - - - - - - - - - - - - <<<    *   FILE 438\n//*  >>>  For structured macros alone, see member $$$STRUC.  <<<    *   FILE 438\n//*  >>> - - - - - - - - - - - - - - - - - - - - - - - - - - <<<    *   FILE 438\n//*                                                                 *   FILE 438\n//*      These macros can help you create new programs and          *   FILE 438\n//*      modify existing code by supporting IF-THEN-ELSE logic      *   FILE 438\n//*      while requiring only a small learning curve from what      *   FILE 438\n//*      you already know about S/390 Assembler (assuming that      *   FILE 438\n//*      you do know it already).  Each 'IF' statement can be       *   FILE 438\n//*      arbitrarily complex, and the 'IF' statements can be        *   FILE 438\n//*      nested as many levels as you might need. (Certainly,       *   FILE 438\n//*      no one would need more than 255 levels of nesting,         *   FILE 438\n//*      would he?)                                                 *   FILE 438\n//*                                                                 *   FILE 438\n//*      Each group of instructions that you want conditionally     *   FILE 438\n//*      executed would be headed by an 'IF' macro, and             *   FILE 438\n//*      terminated by an 'ENDIF' macro.                            *   FILE 438\n//*                                                                 *   FILE 438\n//*      In its simplest form, the operand of the 'IF' macro        *   FILE 438\n//*      consists of an op-code, the first operand address,         *   FILE 438\n//*      the second operand address, and a condition. These         *   FILE 438\n//*      four values must be enclosed within parentheses, and       *   FILE 438\n//*      following the operands must be a comma and the             *   FILE 438\n//*      statement terminating term 'THENDO'.                       *   FILE 438\n//*                                                                 *   FILE 438\n//*      The op-code may be any valid S/390 op-code that sets       *   FILE 438\n//*      the condition code. The first and second operands may      *   FILE 438\n//*      be any values that are valid for the instruction           *   FILE 438\n//*      being created. The condition, such as 'E' or 'NO', is      *   FILE 438\n//*      any value that can be used in creating an extended         *   FILE 438\n//*      mnemonic branch instruction (such as 'BE' or 'BNO').       *   FILE 438\n//*                                                                 *   FILE 438\n//*      If you choose 'E' as the condition, then the group of      *   FILE 438\n//*      instructions between the 'IF' and the 'ENDIF' will be      *   FILE 438\n//*      executed only if the condition code set by the             *   FILE 438\n//*      op-code and operands specified is a zero.                  *   FILE 438\n//*                                                                 *   FILE 438\n//*      In the following examples, the heading will indicate       *   FILE 438\n//*      the conditions in which the do-group will be               *   FILE 438\n//*      executed. In each case, an 'IF' statement determines       *   FILE 438\n//*      the conditions, and an 'ENDIF' statement terminates        *   FILE 438\n//*      the do-group. Comments either in the heading or on         *   FILE 438\n//*      the appropriate instructions will indicate the             *   FILE 438\n//*      details.                                                   *   FILE 438\n//*                                                                 *   FILE 438\n//*           Here is an example:                                   *   FILE 438\n//*                                                                 *   FILE 438\n//*             IF    (CLC,A,B,NE),THENDO                           *   FILE 438\n//*                                                                 *   FILE 438\n//*      The instructions between this 'IF' and its matching        *   FILE 438\n//*      'ENDIF' will be executed if the result of the 'CLC'        *   FILE 438\n//*      is a 1 or 2 (the not-equal condition).                     *   FILE 438\n//*                                                                 *   FILE 438\n//*           To execute the do-group if either one of two          *   FILE 438\n//*      conditions is true, the format is:                         *   FILE 438\n//*                                                                 *   FILE 438\n//*           IF    (CLC,A,B,NE),OR,(CLC,C,D,NE),THENDO             *   FILE 438\n//*                                                                 *   FILE 438\n//*           Alternate format:                                     *   FILE 438\n//*                                                        72       *   FILE 438\n//*           IF    (CLC,A,B,NE),OR,                        C       *   FILE 438\n//*                 (CLC,C,D,NE),THENDO                             *   FILE 438\n//*                                                                 *   FILE 438\n//*      (This will give you a small idea of what these macros      *   FILE 438\n//*      can do.  For information about the more complicated        *   FILE 438\n//*      capabilities of the structured macros in this package,     *   FILE 438\n//*      please see member $$ALTDOC.)                               *   FILE 438\n//*                                                                 *   FILE 438\n//* --------------------------------------------------------------- *   FILE 438\n//*                                                                 *   FILE 438\n//*      Dan initially submitted only the structured macros         *   FILE 438\n//*      that he wrote, to this tape.  He has now submitted many    *   FILE 438\n//*      more macros.  Below, we see the types of macros which      *   FILE 438\n//*      perform other categories of function, as well as the       *   FILE 438\n//*      ones which can be used to create structured assembler      *   FILE 438\n//*      programs.                                                  *   FILE 438\n//*                                                                 *   FILE 438\n//* --------------------------------------------------------------- *   FILE 438\n//*                                                                 *   FILE 438\n//*      In the following list of macros, each one is assigned to   *   FILE 438\n//*      a category according to its intended use.  Most of the     *   FILE 438\n//*      testing on these macros has been done in an environment    *   FILE 438\n//*      called 'Version 2', or '2nd Generation'.  This             *   FILE 438\n//*      environment presents a programmer with a pseudo-COBOL      *   FILE 438\n//*      way of coding, and was created in the early 1990's as an   *   FILE 438\n//*      aid to getting programs going faster.  The 'Version 1'     *   FILE 438\n//*      or '1st Generation' environment was created in the mid     *   FILE 438\n//*      1970's, and is somewhat more oriented toward Systems       *   FILE 438\n//*      Programming types of programming.                          *   FILE 438\n//*                                                                 *   FILE 438\n//*      If a macro is listed as being 'GENERAL', or general        *   FILE 438\n//*      purpose, then it is not part of either Version 1 or 2,     *   FILE 438\n//*      but it might not have been tested outside one of these     *   FILE 438\n//*      environments.                                              *   FILE 438\n//*                                                                 *   FILE 438\n//*      What follows is a description of the categories that       *   FILE 438\n//*      these macros have been classified into:                    *   FILE 438\n//*                                                                 *   FILE 438\n//*      DIAGNOSTIC - The macro may be used in either Version 1     *   FILE 438\n//*      or 2 programs, and is intended primarily as a diagnostic   *   FILE 438\n//*      aid in getting the program running correctly.  Hopefully   *   FILE 438\n//*      the effort expended in using one or more of these          *   FILE 438\n//*      diagnostic macros will pay off in diagnosing the           *   FILE 438\n//*      progress of your program.                                  *   FILE 438\n//*                                                                 *   FILE 438\n//*      GENERAL - Various utility macros that should provide       *   FILE 438\n//*      services required for typical programs.                    *   FILE 438\n//*                                                                 *   FILE 438\n//*      INTERNAL - These macros are typically used as common       *   FILE 438\n//*      service routines by other macros within this library.      *   FILE 438\n//*      They usually provide services that would not be useful     *   FILE 438\n//*      for use as open code macros (those coded within the        *   FILE 438\n//*      program itself).                                           *   FILE 438\n//*                                                                 *   FILE 438\n//*      RUN-TIME-TOTALS - A set of general purpose macros that     *   FILE 438\n//*      might make it easier to create counters that can be        *   FILE 438\n//*      incremented at each of several places within a program,    *   FILE 438\n//*      and then at some point during program execution            *   FILE 438\n//*      (presumably during the finalization step of the            *   FILE 438\n//*      program), print out all of the accumulated counts with     *   FILE 438\n//*      one easy statement.                                        *   FILE 438\n//*                                                                 *   FILE 438\n//*      STRUCTURED - Macros that control the conditional or        *   FILE 438\n//*      repetitive execution of a group of instructions            *   FILE 438\n//*      following the group-initiation macro and ending with a     *   FILE 438\n//*      group-terminating macro.                                   *   FILE 438\n//*                                                                 *   FILE 438\n//*      1st Generation - A set of macros that provice standard     *   FILE 438\n//*      MVS interface and subroutine linkage conventions.          *   FILE 438\n//*                                                                 *   FILE 438\n//*      2nd GENERATION - Another set of MVS interface and          *   FILE 438\n//*      subroutine linkage macros.                                 *   FILE 438\n//*                                                                 *   FILE 438\n//*      What follows is an alphabetic listing of all of the        *   FILE 438\n//*      macro definitions included in the package, with its        *   FILE 438\n//*      identifying macro type:                                    *   FILE 438\n//*                                                                 *   FILE 438\n//*                $AGOTO    INTERNAL                               *   FILE 438\n//*                $ASECT    INTERNAL                               *   FILE 438\n//*                $IA       INTERNAL                               *   FILE 438\n//*                $MENDDO1  INTERNAL                               *   FILE 438\n//*                $MENDDO2  INTERNAL                               *   FILE 438\n//*                $MGBLDEF  INTERNAL                               *   FILE 438\n//*                $MGFNAME  INTERNAL                               *   FILE 438\n//*                $MGPNAME  INTERNAL                               *   FILE 438\n//*                $WA       INTERNAL                               *   FILE 438\n//*                ADDR      GENERAL                                *   FILE 438\n//*                AFTER     STRUCTURED                             *   FILE 438\n//*                AN        GENERAL                                *   FILE 438\n//*                BEGTEST   DIAGNOSTIC                             *   FILE 438\n//*                BHE       GENERAL                                *   FILE 438\n//*                BLE       GENERAL                                *   FILE 438\n//*                COMBOX    GENERAL                                *   FILE 438\n//*                CONTINUE  GENERAL                                *   FILE 438\n//*                CPYPAR$E  INTERNAL                               *   FILE 438\n//*                CTE       TEXT SEARCH                            *   FILE 438\n//*                CTEB      TEXT SEARCH                            *   FILE 438\n//*                CVN       GENERAL                                *   FILE 438\n//*                CVXREGS   DIAGNOSTIC                             *   FILE 438\n//*                CVXWORD   DIAGNOSTIC                             *   FILE 438\n//*                DEFPGMID  INTERNAL                               *   FILE 438\n//*                DIAGMSG   INTERNAL                               *   FILE 438\n//*                DISPLAY   DIAGNOSTIC                             *   FILE 438\n//*                DIVISION  2ND GENERATION                         *   FILE 438\n//*                DO        STRUCTURED                             *   FILE 438\n//*                DTM       INTERNAL                               *   FILE 438\n//*                DUMPMAIN  DIAGNOSTIC                             *   FILE 438\n//*                DUMPREGS  DIAGNOSTIC                             *   FILE 438\n//*                EDIT      STRUCTURED                             *   FILE 438\n//*                ELSE      STRUCTURED                             *   FILE 438\n//*                ELSEDO    STRUCTURED                             *   FILE 438\n//*                ELSEIF    STRUCTURED                             *   FILE 438\n//*                EM        GENERAL                                *   FILE 438\n//*                ENDAFTER  STRUCTURED                             *   FILE 438\n//*                ENDELSE   STRUCTURED                             *   FILE 438\n//*                ENDFIRST  STRUCTURED                             *   FILE 438\n//*                ENDIF     STRUCTURED                             *   FILE 438\n//*                ENDO      STRUCTURED                             *   FILE 438\n//*                ENDP      1ST GENERATION                         *   FILE 438\n//*                ENDSECT   2ND GENERATION                         *   FILE 438\n//*                ENDTEST   DIAGNOSTIC                             *   FILE 438\n//*                EPACK     GENERAL                                *   FILE 438\n//*                EQUATE    GENERAL                                *   FILE 438\n//*                EUNPK     GENERAL                                *   FILE 438\n//*                EVERY     STRUCTURED                             *   FILE 438\n//*                EXECUTE   GENERAL                                *   FILE 438\n//*                EXIT      2ND GENERATION                         *   FILE 438\n//*                FINAL     2ND GENERATION                         *   FILE 438\n//*                FIRST     STRUCTURED                             *   FILE 438\n//*                GO        1ST GENERATION                         *   FILE 438\n//*                GOBACK    2ND GENERATION                         *   FILE 438\n//*                GOTO      2ND GENERATION                         *   FILE 438\n//*                HEXRTN    DIAGNOSTIC (1ST GENERATION VERSION)    *   FILE 438\n//*                HROUTINE  DIAGNOSTIC (2ND GENERATION VERSION)    *   FILE 438\n//*                I         GENERAL                                *   FILE 438\n//*                IF        STRUCTURED                             *   FILE 438\n//*                IP        GENERAL                                *   FILE 438\n//*                LEVELMSG  INTERNAL                               *   FILE 438\n//*                MACBOX    GENERAL                                *   FILE 438\n//*                NEXT      STRUCTURED                             *   FILE 438\n//*                PAR$E     INTERNAL                               *   FILE 438\n//*                PCALL     1ST GENERATION                         *   FILE 438\n//*                PERFORM   2ND GENERATION                         *   FILE 438\n//*                PRDEF     GENERAL (1ST GENERATION VERSION)       *   FILE 438\n//*                PRINTER   GENERAL (2ND GENERATION VERSION)       *   FILE 438\n//*                PROC      1ST GENERATION                         *   FILE 438\n//*                PRTTABLE  RUN-TIME-TOTALS                        *   FILE 438\n//*                RETN      1ST OR 2ND GENERATION                  *   FILE 438\n//*                RTTBEG    RUN-TIME-TOTALS                        *   FILE 438\n//*                RTTEND    RUN-TIME-TOTALS                        *   FILE 438\n//*                RTTENT    RUN-TIME-TOTALS                        *   FILE 438\n//*                RTTINCR   RUN-TIME-TOTALS                        *   FILE 438\n//*                RTTPRT    RUN-TIME-TOTALS                        *   FILE 438\n//*                RTTRESET  RUN-TIME-TOTALS                        *   FILE 438\n//*                SECONDEP  2ND GENERATION                         *   FILE 438\n//*                SECTION   2ND GENERATION                         *   FILE 438\n//*                SETCSECT  INTERNAL                               *   FILE 438\n//*                SETDEF    INTERNAL                               *   FILE 438\n//*                SETRC     GENERAL                                *   FILE 438\n//*                SETUP     INTERNAL                               *   FILE 438\n//*                STOP      1ST GENERATION                         *   FILE 438\n//*                SYSUT1    1ST GENERATION                         *   FILE 438\n//*                SYSUT2    1ST GENERATION                         *   FILE 438\n//*                TAG       GENERAL                                *   FILE 438\n//*                THENDO    STRUCTURED                             *   FILE 438\n//*                TRACER    DIAGNOSTIC                             *   FILE 438\n//*                TRACER2   INTERNAL                               *   FILE 438\n//*                TRC       DIAGNOSTIC (1ST GENERATION ONLY)       *   FILE 438\n//*                TRSP      GENERAL                                *   FILE 438\n//*                VAL       INTERNAL                               *   FILE 438\n//*                VERSION   INTERNAL                               *   FILE 438\n//*                                                                 *   FILE 438\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ADDR": {"ttr": 2308, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00\\x00o\\x01\\x00\\x00o\\x18S\\x00\\r\\x00\\r\\x00\\x00\\xc2\\xc3\\xd6\\xc4\\xc8\\xe2\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-01-06T00:00:00", "modifydate": "2000-01-06T18:53:00", "lines": 13, "newlines": 13, "modlines": 0, "user": "BCODHS0"}, "text": "         MACRO\n&NAME    ADDR  &REG,&ADDR          GET ADDRESS INTO REG\n         AIF   ('&ADDR'(1,1) NE '(').NOTGPR GO IF NOT GPR\n         AIF   ('&ADDR(1)' NE '&REG').DOLR FALL THROUGH IF LR NOT REQ'D\n         AIF   ('&NAME' EQ '').MEND\n&NAME    DC    0H'0'               DEFINE TAG\n         MEXIT\n.DOLR    ANOP\n&NAME    LR    &REG,&ADDR(1)       LOAD VALUE TO CORRECT REGISTER\n         MEXIT\n.NOTGPR  ANOP\n&NAME    LA    &REG,&ADDR(1)       LOAD VALUE INTO REGISTER\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "AFTER": {"ttr": 2310, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x07\\x00\\x15\\x01\\x01%\\x7f\\x01\\x02\\x01\\x7f\\x13\\x11\\x00(\\x00'\\x00\\x00\\xc7\\xc5\\xd5\\xe3\\xd9\\xf0\\xf2@@@\"", "ispf": {"version": "01.07", "flags": 0, "createdate": "2001-09-14T00:00:00", "modifydate": "2002-01-17T13:11:15", "lines": 40, "newlines": 39, "modlines": 0, "user": "GENTR02"}, "text": "         MACRO\n&NAME    AFTER &VAR\n.**=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\n.* AFTER 1 WILL CAUSE THE CODE FOLLOWING THIS MACRO TO BE EXECUTED ON *\n.*            EVERY PASS EXCEPT THE FIRST PASS.                       *\n.* AFTER N - EVERY PASS FOLLOWING THE N-TH PASS                       *\n.**=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\n         COPY  $MGBLDEF            BRING IN THE CLOWNS\n&LCLV    SETC  '&VAR'              SET TO COUNT\n         AIF   ('&VAR'(1,1) GE '0').OK30 GO IF SELF-DEFINING\n         MNOTE '''&VAR'' NOT SELF-DEFINING: DO-GROUP WILL BE PROCESSED C\n               WITH EACH PASS THROUGH THIS SECTION OF CODE'\n&LCLV    SETC  '0'                 DO EVERY TIME\n.OK30    ANOP\n&$MDGLVL SETA  &$MDGLVL+1          INCREMENT LEVEL\n&$MDGSEQ(&$MDGLVL) SETC '&SYSNDX'\n&$MIFELS(&$MDGLVL) SETC 'F'\n&$MDGNAM(&$MDGLVL) SETC '&NAME'\n&$MCVERB(&$MDGLVL) SETC 'AFTER'\n&X       SETC  '$MDV&SYSNDX'       MAKE IT PRETTY\n         AIF   ('&LCLV' NE '1').PACKED\n&NAME    TM    &X,X'01'            HAVE WE BEEN HERE BEFORE?\n         JO    *+12                SKIP OVER IS YES\n         OI    &X,X'01'            ELSE LEAVE TRACKS\n         J     $MDF&SYSNDX           AND BYPASS DO-GROUP\n         AGO   .DEFINE\n.PACKED  ANOP                      I GUESS WE'LL HAVE TO DO DECIMAL...\n&NAME    SP    &X,=P'1'            DECREMENT\n         JNM   $MDF&SYSNDX         B IF NOT YET TIME\n         PACK  &X,=Z'0'            DO EVERY TIME FROM NOW ON\n.DEFINE  ANOP\nDATA     LOCTR                     SET UP WORK AREA\n         AIF   ('&LCLV' NE '1').PACKED2\n&X       DC    X'00'               SET TO X'01' FIRST TIME THROUGH\n         AGO   .INST\n.PACKED2 ANOP\n&X       DC    P'&LCLV'            FREQUENCY COUNTER\n.INST    ANOP\n&SYSECT  LOCTR                     BACK TO INSTRUCTION AREA\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "AN": {"ttr": 2312, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x98%?\\x00\\x98%?\\x14$\\x00b\\x00a\\x00\\x00\\xc2\\xc3\\xd6\\xc4\\xc8\\xe2\\xf0@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1998-09-10T00:00:00", "modifydate": "1998-09-10T14:24:00", "lines": 98, "newlines": 97, "modlines": 0, "user": "BCODHS0"}, "text": "         MACRO\n&NAME    AN    &OP1,&OP2\n.*                                                                   *\n.*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\n.* ADD NUMERIC ANY FORMAT TO ANY OTHER                               *\n.*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\n.*                                                                   *\n         AIF   ('&OP1'(1,1) NE '(').TEST200 GO IF 1ST NOT GPR\n         AIF   ('&OP2'(1,1) NE '(').TEST100 GO IF 2ND NOT GPR\n&NAME    AR    &OP1(1),&OP2(1)    DO THE ADDITION\n         AGO   .MEND999\n.TEST100 AIF   (T'&OP2 NE 'P').TEST110\n&NAME    ZAP   WS_PL8,&OP2        PLACE INTO 8-BYTE WORK AREA\n         CVB   0,WS_PL8           CONVERT TO BINARY\n         AR    &OP1(1),0          DO THE ADDITION\n         AIF   (D'WS_PL8).MEND999\n         $WA   ,\n         DC    0D'0'\nWS_PL8   DC    PL8'0'\n         $IA   ,\n         AGO   .MEND999\n.TEST110 ANOP\n&NAME    PACK  WS_PL8,&OP2        PLACE INTO 8-BYTE WORK AREA\n         CVB   0,WS_PL8           CONVERT TO BINARY\n         AR    &OP1(1),0          DO THE ADDITION\n         AIF   (D'WS_PL8).MEND999\n         $WA   ,\n         DC    0D'0'\nWS_PL8   DC    PL8'0'\n         $IA   ,\n         AGO   .MEND999\n.TEST200 AIF   (T'&OP1 NE 'P').TEST300 GO IF 1ST NOP PACKED\n         AIF   ('&OP2'(1,1) NE '(').TEST210 GO IF 2ND NOT GPR\n&NAME    CVD   &OP2(1),WS_PL8\n         AP    &OP1,WS_PL8\n         AIF   (D'WS_PL8).MEND999\n         $WA   ,\n         DC    0D'0'\nWS_PL8   DC    PL8'0'\n         $IA   ,\n         AGO   .MEND999\n.TEST210 AIF   (T'&OP2 NE 'P').TEST220 GO IF 2ND NOT GPR\n&NAME    AP    &OP1,&OP2\n         AGO   .MEND999\n.TEST220 ANOP\n&NAME    PACK  WS_PL8,&OP2        PLACE INTO 8-BYTE WORK AREA\n         AP    &OP1,WS_PL8        DO THE ADDITION\n         AIF   (D'WS_PL8).MEND999\n         $WA   ,\n         DC    0D'0'\nWS_PL8   DC    PL8'0'\n         $IA   ,\n         AGO   .MEND999\n.TEST300 AIF   ('&OP2'(1,1) NE '(').TEST310\n         AIF   (D'WS_PL8).TEST301\n         $WA   ,\n         DC    0D'0'\nWS_PL8   DC    PL8'0'\n         $IA   ,\n         AGO   .MEND999\n.TEST301 AIF   (D'WS_PL16A).CONT302\n         $WA   ,\n         DC    0D'0'\nWS_PL16A DC    PL16'0'\n         $IA   ,\n.CONT302 ANOP\n&NAME    CVD   &OP2(1),WS_PL8\n         EPACK WS_PL16A,&OP1\n         AP    WS_PL16A,WS_PL8\n         UNPK  &OP1,WS_PL16A\n         AGO   .MEND999\n.TEST310 AIF   (T'&OP2 NE 'P').TEST320\n         AIF   (D'WS_PL16A).CONT315\n         $WA   ,\n         DC    0D'0'\nWS_PL16A DC    PL16'0'\n         $IA   ,\n.CONT315 ANOP\n&NAME    EPACK WS_PL16A,&OP1\n         AP    WS_PL16A,&OP2\n         UNPK  &OP1,WS_PL16A\n         AGO   .MEND999\n.TEST320 AIF   (D'WS_PL16A).TEST325\n         $WA   ,\n         DC    0D'0'\nWS_PL16A DC    PL16'0'\n         $IA   ,\n.TEST325 AIF   (D'WS_PL16B).CONT330\n         $WA   ,\n         DC    0D'0'\nWS_PL16B DC    PL16'0'\n         $IA   ,\n.CONT330 ANOP\n&NAME    EPACK WS_PL16A,&OP1\n         EPACK WS_PL16B,&OP2\n         AP    WS_PL16A,WS_PL16B\n         UNPK  &OP1,WS_PL16A\n.MEND999 MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "BEGTEST": {"ttr": 2315, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\x01\\x7f\\x01\\x02\\x01\\x7f\\x10\\x17\\x00U\\x00U\\x00\\x00\\xc7\\xc5\\xd5\\xe3\\xd9\\xf0\\xf2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-01-17T00:00:00", "modifydate": "2002-01-17T10:17:00", "lines": 85, "newlines": 85, "modlines": 0, "user": "GENTR02"}, "text": "         MACRO\n&N       BEGTEST &LVL\n         GBLA  &TESTLVL            SET TO > 0 TO ACTIVATE\n         GBLC  &$A,&$B,&$C,&$D     SET ONE OR MORE TO 'Y' TO ACTIVATE\n         LCLA  &I,&J\n         LCLC  &TEXT\n         AIF   ('&N' EQ '').SKIP010\n&N       EQU   *\n.SKIP010 ANOP\n         AIF   ('&LVL' NE '' AND '&LVL'(1,1) GT 'Z').TEST510\n.*\n.* OPTIONAL CODE (LOCATED BETWEEN 'BEGTEST' AND 'ENDTEST') IS INCLUDED\n.* OR EXCLUDED BASED ON VALUE SPECIFIED IN MACRO OPERAND AND VALUE\n.* OF CORRESPONDING SET SYMBOL. IN FOLLOWING DOC'N, EXAMPLE IS FOR\n.* OPERAND 'A' AND SET SYMBOL '&$A'. LOGIC IS IDENTICAL FOR B, C, & D.\n.*\n.*     SET SYMBOL &$A:  ------->     'Y'                NOT 'Y'\n.*                                ------------       ------------\n.*                         'A'    INCLUDE CODE       EXCLUDE CODE\n.*     MACRO OPERAND:  NOT 'A'  TEST NEXT LETTER    TEST NEXT LETTER\n.*\n.* EXAMPLE:\n.*\n.*          GBLC  &$A\n.* &$A      SETC  'Y'\n.*          BEGTEST A\n.*          ...   THIS CODE WILL BE ASSEMBLED\n.*          ENDTEST ,\n.* &$A      SETC  'N'   (ANY VALUE OTHER THAN 'Y')\n.*          BEGTEST A\n.*          ...  THIS CODE WILL NOT BE ASSEMBLED\n.*          ENDTEST\n.*\n.*          GBLA  &TESTLVL\n.* &TESTLVL SETA  10\n.*          BEGTEST 10  (ANY VALUE 0 - 10)\n.*          ... THIS CODE WILL BE ASSEMBLED\n.*          ENDTEST\n.*          BEGTEST 20  (ANY VALUE > 10)\n.*          ... THIS CODE WILL NOT BE ASSEMBLED\n.*          ENDTEST\n.*\n         AIF   ('&LVL' NE 'A').TEST020\n         AIF   ('&$A' EQ 'Y').MEND999\n         AGO   .LOOP520\n.TEST020 AIF   ('&LVL' NE 'B').TEST030\n         AIF   ('&$B' EQ 'Y').MEND999\n         AGO   .LOOP520\n.TEST030 AIF   ('&LVL' NE 'C').TEST040\n         AIF   ('&$C' EQ 'Y').MEND999\n         AGO   .LOOP520\n.TEST040 AIF   ('&LVL' NE 'D').MSG050\n         AIF   ('&$D' EQ 'Y').MEND999\n         AGO   .LOOP520\n.MSG050  MNOTE *,' ---> INVALID CHAR OPERAND &LVL - OPT CODE INCLUDED'\n         AGO   .MEND999\n.*\n.* IF MACRO OPERAND IS NUMERIC (> 0), THEN VALUE IS COMPARED WITH SET\n.* SYMBOL &TESTLVL, WHICH MUST BE PREVIOUSLY BE SET BY PROGRAMMER.\n.* IF MACRO OPERAND IS > &TESTLVL, THEN THE OPTIONAL CODE IS EXCLUDED.\n.* NOTE: THE DEFAULT VALUE FOR &TESTLVL IS 0.\n.*\n.TEST510 AIF   (&LVL LE &TESTLVL).MEND999\n.LOOP520 ANOP\n&TEXT    AREAD NOPRINT\n         AIF   ('&TEXT'(1,1) EQ '*').LOOP520\n&J       SETA  &J+1\n&I       SETA  1\n.LOOP530 AIF   ('&TEXT'(&I,1) EQ ' ').NEXT540 SCAN PAST NAME FIELD\n&I       SETA  &I+1\n         AIF   (&I GT 65).LOOP520\n         AGO   .LOOP530\n.NEXT540 AIF   ('&TEXT'(&I,1) NE ' ').NEXT550 SCAN PAST LEADING SPACES\n&I       SETA  &I+1\n         AIF   (&I GT 65).LOOP520\n         AGO   .NEXT540\n.NEXT550 AIF   ('&TEXT'(&I,8) NE 'ENDTEST ').LOOP520\n&J       SETA  &J-1\n         AIF   (&J NE 1).MSG560\n         MNOTE *,' ===> ENDTEST STATEMENT ENCOUNTERED - 1 STATEMENT SKIX\n               PPED'\n         AGO   .MEND999\n.MSG560  MNOTE *,' ===> ENDTEST STATEMENT ENCOUNTERED - &J STATEMENTS SX\n               KIPPED'\n.MEND999 MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "BHE": {"ttr": 2318, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00\\x00o\\x01\\x00\\x00o\\x18S\\x00\\x04\\x00\\x04\\x00\\x00\\xc2\\xc3\\xd6\\xc4\\xc8\\xe2\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-01-06T00:00:00", "modifydate": "2000-01-06T18:53:00", "lines": 4, "newlines": 4, "modlines": 0, "user": "BCODHS0"}, "text": "         MACRO\n&NAME    BHE   &ADDR\n&NAME    BNL   &ADDR\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "BLE": {"ttr": 2320, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00\\x00o\\x01\\x00\\x00o\\x18S\\x00\\x04\\x00\\x04\\x00\\x00\\xc2\\xc3\\xd6\\xc4\\xc8\\xe2\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-01-06T00:00:00", "modifydate": "2000-01-06T18:53:00", "lines": 4, "newlines": 4, "modlines": 0, "user": "BCODHS0"}, "text": "         MACRO\n&NAME    BLE   &ADDR\n&NAME    BNH   &ADDR\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "BWCDATE1": {"ttr": 2322, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x003\\x01\\x01&O\\x01\\x02\\x00/\\x15G\\x00\\x85\\x00\\x85\\x00\\x00\\xc7\\xc5\\xd5\\xe3\\xd9\\xf0\\xf2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2001-09-21T00:00:00", "modifydate": "2002-01-02T15:47:33", "lines": 133, "newlines": 133, "modlines": 0, "user": "GENTR02"}, "text": "*                                                                     *\n*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\n*                                                                     *\n* 'BWCDATE1' RETURNS GREGORIAN DATE YYYYMMDD, JULIAN DAY JJJ, AND     *\n* TIME HHMMSSTH. CODED TO BE REENTRANT (AND SERIALLY REUSABLE).       *\n*                                                                     *\n* OBTAIN CURRENT DATE AND TIME AND RETURN TO USER IN FORMAT:          *\n*                                                                     *\n* 01  DATE-TIME-VALUES.                                               *\n*     05  CURRENT-DATE            PIC 9(08).  ==> YYYYMMDD            *\n*     05  CURRENT-JULIAN          PIC 9(03).  ==> JJJ                 *\n*     05  CURRENT-TIME            PIC 9(08)   ==> HHMMSSTH            *\n*                                                                     *\n* IF THE SYSTEM CLOCK ROUTINE FAILS, THE VALUES RETURNED TO THE       *\n* CALLER WILL BE ALL ZEROS.                                           *\n*                                                                     *\n* THE RETURN CODE WILL ALWAYS BE SET TO ZERO.                         *\n*                                                                     *\n*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\n*                                                                     *\n*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\n* THE TWO MACROS 'SARE' AND 'DCRE' MAKE IT EASIER TO HAVE REENTRANT   *\n* CODE WITH INITIAL VALUES THAT CAN BE CHANGED DURING THE EXECUTION   *\n* OF THE ROUTINE. DCRE (STANDING FOR DEFINE CONSTANT - REENTRANT)     *\n* CREATES TWO COPIES OF EACH VARIABLE. ONE OCCUPIES STORAGE IN THIS   *\n* PROGRAM, AND IS USED TO INITIALIZE THE VALUE OF THE SECOND, WHICH   *\n* IS LOCATED IN A GETMAIN-ED AREA MAPPED BY THE DSECT WHICH CONTAINS  *\n* THE NAME OF THE VARIABLE BEING DEFINED.                             *\n*                                                                     *\n* SARE DEFINES THE REGISTER SAVE AREA WITHIN THE GETMAIN-ED AREA.     *\n*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\n*                                                                     *\n         MACRO\n&NAME    SARE &DUMMY               SAVEAREA REENTRANT\nSAVEAREA DSECT                     SAVEAREA DSECT\n         DS    9D                  SAVEAREA STORAGE\n&SYSECT  CSECT                     BACK TO PROGRAM CSECT\nINST     LOCTR                     . NOW INSTRUCTION ZONE\n         MEND\n         MACRO\n&NAME    DCRE  &DUMMY              DC - REENTRANT\n         LCLA  &I                  OLD FORTRAN CONVENTIONS DIE HARD\n         LCLC  &OPERAND            I'LL BUILD IT MYSELF\n&OPERAND SETC  '&SYSLIST(1)'       SET TO INITIAL VALUE\n&I       SETA  2                   START WITH 2ND POSITIONAL\n.LOOP100 AIF   (&I GT N'&SYSLIST).SKIP200 GO IF FINISHED\n&OPERAND SETC  '&OPERAND.,&SYSLIST(&I)' ADD THIS POSITIONAL\n&I       SETA  &I+1                BUMP INDEX\n         AGO   .LOOP100            BACK TO TRY AGAIN\n.SKIP200 ANOP                      TAG FOR LOOP END\nDATA     LOCTR                     ENTER DATA PORTION\n         DC    &OPERAND            DEFINE INITIAL VALUE\nSAVEAREA DSECT                     ENTER GETMAINED ZONE\n&NAME    DS    &OPERAND            DEFINE NAME OF FIELD\n&SYSECT  CSECT                     BACK TO PROGRAM CSECT\nINST     LOCTR                     . AND BACK TO INTRUCTION ZONE\n         MEND\n         PRINT GEN                 WHO WANTS TO SEE MACRO EXPANSIONS?\nBWCDATE1 AMODE 31                  BIG ADDRESSING MODE\nBWCDATE1 RMODE ANY                 BUT I'LL LIVE ANYWHERE\nBWCDATE1 CSECT                     DEFINE PROGRAM CONTROL SECTION\nINST     LOCTR                     DEFINE INSTRUCTION ZONE\n         USING BWCDATE1,R12        ENABLE BASE REG\n         STM   R14,R12,12(R13)     STANDARD SAVE\n         LR    R12,R15             PRIME BASE REG WITH VIRT ADDR\n         XC    16(4,R13),16(R13)   SET ZERO RETURN CODE\n         L     R11,0(,R1)          COPY ADDR OF USER PARMS\n         STORAGE OBTAIN,LENGTH=WSLENGTH+72 GET DYNAMIC WORKING STORAGE\n         ST    R1,8(,R13)          FORWARD CHAIN TO MY SAVE AREA\n         ST    R13,4(,R1)          BACK CHAIN TO CALLER'S SAVE AREA\n         LR    R13,R1              COPY MY SAVE AREA POINTER\n         USING SAVEAREA,R13        SET SECOND BASE REG\n         B     BEGIN               SKIP MARKERS\n         DC    C'****    '\n         DC    C'BWCDATE1 V1R1M0 COMPILED ON &SYSDATE AT &SYSTIME'\n         DC    C'    ****'\nBEGIN    MVC   SAVEAREA+72(WSLENGTH),WSBEG COPY INITIAL VALUES\n         TIME  DEC,TDAREA,LINKAGE=SYSTEM,DATETYPE=YYYYMMDD\n*                                                                     *\n*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\n* R15 IS SET BY THE TIME MACRO AS FOLLOWS:                            *\n*  0 ==> SUCCESSFUL COMPLETION                                        *\n*  4 ==> TOD CLOCKS ARE NOT INITIALIZED                               *\n*  8 ==> TOD CLOCK IS NOT USABLE                                      *\n* 12 ==> SYSTEM ERROR                                                 *\n* 16 ==> ADDRESS LIST IN NOT IN ADDRESSABLE STORAGE                   *\n*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\n*                                                                     *\n         LTR   R15,R15             DID DATE FUNCTION WORK?\n         BNZ   ERROR               B IF DIDN'T WORK\n*                                                                     *\n         UNPK  WORKZL9,DATE        EXPLODE DATE\n         MVC   ZDATE,WORKZL9       COPY THE EIGHT IMPORTANT BYTES\n         MVC   TDAREA+12(4),=F'0'  SET FOURTH WORD TO ZERO\n         TIME  DEC,TDAREA,LINKAGE=SYSTEM,DATETYPE=YYYYDDD\n         LTR   R15,R15             DID IT WORK THIS TIME?\n         BNZ   ERROR               B IF IT DIDN'T WORK\n         UNPK  WORKZL9,DATE        EXPLODE DATE\n         MVC   ZJULIAN,WORKZL9+5   COPY THE THREE IMPORTANT BYTES\n         UNPK  WORKZL9,TIME        EXPLODE TIME\n         MVC   ZTIME,WORKZL9       COPY THE EIGHT IMPORTANT BYTES\n         MVC   0(19,R11),ZDATE     GIVE THE ANSWER TO THE CALLER\n         B     RETURN              USE STANDARD RETURN\nERROR    MVC   0(19,R11),ZEROS     GIVE ERROR VALUE TO CALLER\nRETURN   LR    R1,R13              COPY ADDRESS OF DYNAMIC STORAGE\n         L     R13,4(,R13)         RESTORE SAVE POINTER\n         STORAGE RELEASE,LENGTH=WSLENGTH+72,ADDR=(1) GUESS?\n         LM    R14,R12,12(R13)     RESTORE REGS\n         BR    R14                 GOBACK\nZEROS    DC    19C'0'              USED TO SET INITIAL VALUE\n         SARE ,                    DYNAMIC WORKING STORAGE\nDATA     LOCTR                     DATA ZONE\nWSBEG    DC    0D'0'               BEGINNING OF INITIALIZED PORTION\nTDAREA   DCRE  0D'0',16X'00'\nTIME     EQU   TDAREA+0,5,C'P'     DEFINE 'HHMMSSTHX+'\nDATE     EQU   TDAREA+8,5,C'P'     DEFINE 'CCYYMMDDX+'\nWORKZL9  DCRE  ZL9'0'              RESULT EX: 'F1F9F9F8F1F1F1F5C0'\nZDATE    DCRE  ZL8'0'              SET TO YYYYMMDD (ZONED DECIMAL)\nZJULIAN  DCRE  ZL3'0'              SET TO JJJ\nZTIME    DCRE  ZL8'0'              SET TO HHMMSSTH\nDATA     LOCTR\nWSEND    DS    0C                  END OF WORKING-STORAGE\nWSLENGTH EQU   WSEND-WSBEG         LENGTH OF WORKING-STORAGE\n         PUSH  PRINT               SAVE CURRENT SETTINGS\n         PRINT OFF                 SKIP REGISTER EQUATES\n         LCLA  &R                  REGISTER VARIABLE\n&R       SETA  0                   WHERE ELSE SHOULD I START?\n.REGLOOP ANOP                      TAG FOR LOOP BACK\nR&R      EQU   &R                  REGISTER EQUATE\n&R       SETA  &R+1                BUMP TO NEXT REGISTER\n         AIF   (&R LT 16).REGLOOP  BACK IF NOT FINISHED\n         POP   PRINT               REESTABLISH PREVIOUS PRINT OPTIONS\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "COMBOX": {"ttr": 2325, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00\\x00o\\x01\\x00\\x00o\\x18S\\x00\\x05\\x00\\x05\\x00\\x00\\xc2\\xc3\\xd6\\xc4\\xc8\\xe2\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-01-06T00:00:00", "modifydate": "2000-01-06T18:53:00", "lines": 5, "newlines": 5, "modlines": 0, "user": "BCODHS0"}, "text": "*                                                                     *\n*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\n*                                                                     *\n*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\n*                                                                     *\n", "mimetype": "text/plain", "datatype": "us-ascii", "extension": ".txt"}, "CONTINUE": {"ttr": 2327, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x995\\x0f\\x00\\x995\\x0f\\x15\\x07\\x00\\x04\\x00\\x04\\x00\\x00\\xc2\\xc3\\xd6\\xc4\\xc8\\xe2\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-16T00:00:00", "modifydate": "1999-12-16T15:07:00", "lines": 4, "newlines": 4, "modlines": 0, "user": "BCODHS0"}, "text": "         MACRO\n&NAME    CONTINUE &DUMMY\n&NAME    DC    0H'0',0C' &DUMMY'\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CPYPAR$E": {"ttr": 2329, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x98!_\\x00\\x98!_\\x14 \\x00\\x0c\\x00\\x0c\\x00\\x00\\xc2\\xc3\\xd6\\xc4\\xc8\\xe2\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1998-08-03T00:00:00", "modifydate": "1998-08-03T14:20:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "BCODHS0"}, "text": ".*                      GLOBAL SYMBOLS FOR FIRST OPERAND\n         GBLC  &$PTAG1        DISPLACEMENT PORTION OF OPERAND\n         GBLA  &$PLEN1      EXPLICIT LENGTH IF SPECIFIED ELSE IMPLICIT\n         GBLC  &$PBASE1       EXPLICIT BASE IF SPECIFIED ELSE NULL\n         GBLC  &$PEB1         NULL IF NO EXPLICIT BASE ELSE (&$PBASE1)\n         GBLC  &$PELB1 (&$PLEN1) IF NO EXP BASE ELSE (&$PLEN1,&$PBASE1)\n.*                      GLOBAL SYMBOLS FOR SECOND OPERAND\n         GBLC  &$PTAG2        DISPLACEMENT PORTION OF OPERAND\n         GBLA  &$PLEN2      EXPLICIT LENGTH IF SPECIFIED ELSE IMPLICIT\n         GBLC  &$PBASE2       EXPLICIT BASE IF SPECIFIED ELSE NULL\n         GBLC  &$PEB2         NULL IF NO EXPLICIT BASE ELSE (&$PBASE2)\n         GBLC  &$PELB2 (&$PLEN2) IF NO EXP BASE ELSE (&$PLEN2,&$PBASE2)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CTE": {"ttr": 2561, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\n\\x00\\x00\\x00\\x98$O\\x00\\x98(/\\x13\\x04\\x00\\x19\\x00\\x08\\x00\\x00\\xc2\\xc3\\xd6\\xc4\\xc8\\xe2\\xf0@@@'", "ispf": {"version": "01.10", "flags": 0, "createdate": "1998-09-01T00:00:00", "modifydate": "1998-10-09T13:04:00", "lines": 25, "newlines": 8, "modlines": 0, "user": "BCODHS0"}, "text": "         MACRO\n&N       CTE   &OP\n.*                                                                   *\n.*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\n.* CTE - 'CREATE TABLE ENTRY'                                        *\n.*                                                                   *\n.* CREATE ONE OR MORE TABLE ENTRIES REPRESENTING STRINGS TO SEARCH   *\n.* FOR DURING SCAN. A 'HIT' WILL TERMINATE THE SCAN ROUTINE AND      *\n.* RETURN TO THE CALLING ROUTINE WITH A 'FOUND' CONDITION.           *\n.*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\n.*                                                                   *\n         LCLA  &SUB,&K\n         LCLC  &NAME\n&NAME    SETC  '&N'                BLANKED OUT AFTER 1ST GEN\n&SUB     SETA  1                   TO SCAN THROUGH &SYSLIST PARMS\n         AIF   ('&N' NE '').LOOP100 NAME MEANS 1ST STMT OF TABLE DEF\n         ORG   *-1                 NOT 1ST - BACK UP OVER X'FF'\n.LOOP100 ANOP                      PROCESS STRING\n&K       SETA  K'&SYSLIST(&SUB)-3  LENGTH FOR 'EX' OF 'CLC'\n&NAME    DC    AL1(&K,0),PL4'0',C&SYSLIST(&SUB) TABLE ENTRY\n&NAME    SETC  ''                  NULLIFY NAME FIELD\n&SUB     SETA  &SUB+1              BUMP TO NEXT INDEX\n         AIF   ('&SYSLIST(&SUB)' NE '').LOOP100 BACK IF NOT NULL\n         DC    X'FF'               DEFINE 'END OF TABLE'\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CTEB": {"ttr": 2563, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00\\x00\\x00\\x98(/\\x00\\x98(/\\x13\\x03\\x00\\x18\\x00\\x18\\x00\\x00\\xc2\\xc3\\xd6\\xc4\\xc8\\xe2\\xf0@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "1998-10-09T00:00:00", "modifydate": "1998-10-09T13:03:00", "lines": 24, "newlines": 24, "modlines": 0, "user": "BCODHS0"}, "text": "         MACRO\n&N       CTEB  &OP\n.*                                                                   *\n.*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\n.* CTEB - 'CREATE TABLE ENTRY BYPASS'                                *\n.*                                                                   *\n.* CREATE ONE OR MORE TABLE ENTRIES REPRESENTING STRINGS TO BYPASS   *\n.* DURING SCAN. EXAMPLE IS 'VALIDATE' WHEN SEARCHING FOR 'DATE'.     *\n.*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\n.*                                                                   *\n         LCLA  &SUB,&K\n         LCLC  &NAME\n&NAME    SETC  '&N'                BLANKED OUT AFTER 1ST GEN\n&SUB     SETA  1                   TO SCAN THROUGH &SYSLIST PARMS\n         AIF   ('&N' NE '').LOOP100 NAME MEANS 1ST STMT OF TABLE DEF\n         ORG   *-1                 NOT 1ST - BACK UP OVER X'FF'\n.LOOP100 ANOP                      PROCESS STRING\n&K       SETA  K'&SYSLIST(&SUB)-3  LENGTH FOR 'EX' OF 'CLC'\n&NAME    DC    AL1(&K,1),PL4'0',C&SYSLIST(&SUB) TABLE ENTRY\n&NAME    SETC  ''                  NULLIFY NAME FIELD\n&SUB     SETA  &SUB+1              BUMP TO NEXT INDEX\n         AIF   ('&SYSLIST(&SUB)' NE '').LOOP100 BACK IF NOT NULL\n         DC    X'FF'               DEFINE 'END OF TABLE'\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CVN": {"ttr": 2565, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00\\x00o\\x01\\x00\\x00o\\x18S\\x00K\\x00K\\x00\\x00\\xc2\\xc3\\xd6\\xc4\\xc8\\xe2\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-01-06T00:00:00", "modifydate": "2000-01-06T18:53:00", "lines": 75, "newlines": 75, "modlines": 0, "user": "BCODHS0"}, "text": "         MACRO\n&NAME    CVN   &TARGET,&SOURCE,&LENGTH,&LEADING=0\n         SPACE 1\n*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\n* MACRO CONVERTS FROM EDITTED NUMERIC (WITH SPACES, COMMAS, $, ETC)   *\n* TO NUMERIC, RIGHT JUSTIFIED. ALL CHARACTERS EXCEPT 0 - 9 ARE        *\n* REMOVED. IF LENGTH IS SPECIFIED (THIRD POSITIONAL PARAMETER), IT    *\n* MUST BE A VARIABLE, AND IT WILL CONTAIN THE NUMBER OF VALID DIGITS  *\n* IN THE OPERAND. IT CAN BE A GPR (EG (R4)), OR A PACKED DECIMAL      *\n* VARIBLE (EG DATA_NAME).                                             *\n* DEFAULT IS TO PAD TO THE LEFT WITH ZEROS. OPTIONALLY, YOU MAY       *\n* REQUEST PADDING WITH SPACES BY SPECIFYING 'LEADING=B' (FOR BLANKS). *\n*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\n         SPACE 1\n         GBLC  &$PTAG1,&$PTAG2\n         GBLA  &$PLEN1,&$PLEN2,&$MBLATH\n         GBLC  &$PBASE1,&$PBASE2,&$PEB1,&$PEB2,&$PELB1,&$PELB2\n         LCLC  &TAG1,&EB1,&ELB1,&LEAD,&REG,&OPCODE,&OPND\n         LCLA  &LEN1\n&LEAD    SETC  '0'                 OPERATING ASSUMPTION\n         AIF   ('&LEADING'(1,1) NE 'B').CONT00\n&LEAD    SETC  ' '                 LEADING SPACES\n.CONT00  PAR$E &TARGET,&SOURCE     BREAK OPNDS UP\n         AIF   (&$MBLATH LT 6).SKIP05\n DC 0C' $PTAG - $PLEN - $PBASE - $PEB - $PELB ' CVN DIAGNOSTIC - DESC.\n DC 0C'&$PTAG1-&$PLEN1-&$PBASE1-&$PEB1-&$PELB1' CVN DIAGNOSTIC - TARGET\n DC 0C'&$PTAG2-&$PLEN2-&$PBASE2-&$PEB2-&$PELB2' CVN DIAGNOSTIC - SOURCE\n.SKIP05  ANOP\n&TAG1    SETC  '&$PTAG1'\n&EB1     SETC  '&$PEB1'\n&ELB1    SETC  '&$PELB1'\n&LEN1    SETA  &$PLEN1\n         AIF   (T'&TARGET NE 'P').CONT10 GO IF CHARACTER\n&TAG1    SETC  '$PWK&SYSNDX'\n&EB1     SETC  ''\n&LEN1    SETA  2*&LEN1-1\n&ELB1    SETC  '(&LEN1)'\n         $WA\n&TAG1    DC    CL&LEN1.'0000000000000000000000000000000'\n         $IA\n.CONT10  ANOP\n&NAME    MVC   &TAG1&ELB1,=&LEN1.C'&LEAD'\n         AIF   ('&LENGTH' EQ '').SKIP40\n         AIF   ('&LENGTH'(1,1) NE '(').TEST20\n&REG     SETC  '&LENGTH(1)'\n         SLR   &REG,&REG\n&OPCODE  SETC  'AH'\n&OPND    SETC  '=H''1'''\n         AGO   .SKIP40\n.TEST20  AIF   (T'&LENGTH EQ 'P').CONT30\n         MNOTE 8,'INVALID LENGTH COUNTER &LENGTH - MACRO TERMINATED'\n         MEXIT\n.CONT30  PACK  &LENGTH,=Z'0'\n&OPCODE  SETC  'AP'\n&OPND    SETC  '=P''1'''\n&REG     SETC  '&LENGTH'\n.SKIP40  LA    R0,&TAG1&EB1\n         LA    R1,&$PTAG2&$PEB2\n         LA    R14,&TAG1+&LEN1-1&EB1\n         LA    R15,&$PTAG2+&$PLEN2-1&$PEB2\n         DO    UNTIL=((CLR,R14,R0,L),OR,                               C\n               (CLR,R15,R1,L))\n           IF    (CLI,0(R15),X'EF',H),AND,                             C\n               (CLI,0(R15),X'FA',L),THENDO\n             MVC   0(1,R14),0(R15)\n             BCTR  R14,0\n             AIF   ('&OPCODE' EQ '').SKIP50\n             &OPCODE &REG,&OPND\n.SKIP50      ANOP\n           ENDO  ,\n           BCTR  R15,0\n         ENDO  ,\n         AIF   (T'&TARGET NE 'P').MEND\n         EPACK &TARGET,&TAG1&ELB1\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CVXREGS": {"ttr": 2568, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x98\"O\\x00\\x98\"O\\x12\\x06\\x00\\x13\\x00\\x13\\x00\\x00\\xc2\\xc3\\xd6\\xc4\\xc8\\xe2\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1998-08-12T00:00:00", "modifydate": "1998-08-12T12:06:00", "lines": 19, "newlines": 19, "modlines": 0, "user": "BCODHS0"}, "text": "         MACRO\n&NAME    CVXREGS &DUMMY            CREATE HEX DUMP OF GPRS\n         GBLB  &$CVXRSW            DEFINE A SWITCH\n         GBLC  &SUBCALL            WHICH TYPE?\n&NAME    STM   R0,R15,$CVXSAVE     SAVE ALL 16\n         LA    R1,$CVXSAVE         ADDRESS OF REG 0\n         MVC   $CVXMSG,=CL10'REGS 0-7' FLAG DATA\n         MVI   CCCHAR,C'0'         DOUBLE SPACE FIRST LINE\n      &SUBCALL CVXLINE             DUMP FIRST 8\n         LA    R1,$CVXSAVE+32      ADDRESS OF REG 8\n         MVC   $CVXMSG,=CL10'REGS 8-15' FLAG DATA\n      &SUBCALL CVXLINE             DUMP LAST 8\n         LM    R0,R15,$CVXSAVE     RESTORE\n         AIF   (&$CVXRSW).MEND     SKIP IF ALREADY DEFINED\n&$CVXRSW SETB  (1)                 SHOW DEFINED\n         $WA\n$CVXSAVE DC    16F'0'              SAVE AREA FOR ALL 16\n         $IA                       RETURN TO PGM CSECT\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CVXWORD": {"ttr": 2570, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00\\x00o\\x01\\x00\\x00o\\x18S\\x00$\\x00$\\x00\\x00\\xc2\\xc3\\xd6\\xc4\\xc8\\xe2\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-01-06T00:00:00", "modifydate": "2000-01-06T18:53:00", "lines": 36, "newlines": 36, "modlines": 0, "user": "BCODHS0"}, "text": "         MACRO\n&NAME    CVXWORD &DBL,&FW          CONV 4 BYTES CHAR TO 8 BYTES HEX\n.*                            GLOBAL SYMBOLS FOR FIRST OPERAND\n         GBLC  &$PTAG1        DISPLACEMENT PORTION OF OPERAND\n         GBLA  &$PLEN1      EXPLICIT LENGTH IF SPECIFIED ELSE IMPLICIT\n         GBLC  &$PBASE1       EXPLICIT BASE IF SPECIFIED ELSE NULL\n         GBLC  &$PEB1         NULL IF NO EXPLICIT BASE ELSE (&$PBASE1)\n         GBLC  &$PELB1 (&$PLEN1) IF NO EXP BASE ELSE (&$PLEN1,&$PBASE1)\n.*                            GLOBAL SYMBOLS FOR SECOND OPERAND\n         GBLC  &$PTAG2        DISPLACEMENT PORTION OF OPERAND\n         GBLA  &$PLEN2      EXPLICIT LENGTH IF SPECIFIED ELSE IMPLICIT\n         GBLC  &$PBASE2       EXPLICIT BASE IF SPECIFIED ELSE NULL\n         GBLC  &$PEB2         NULL IF NO EXPLICIT BASE ELSE (&$PBASE2)\n         GBLC  &$PELB2 (&$PLEN2) IF NO EXP BASE ELSE (&$PLEN2,&$PBASE2)\n         GBLA  &$MBLATH       DOCUMENTATION CONTROL\n         LCLC  &X\n         PAR$E &DBL\n         AIF   (&$PLEN1 EQ 8).OK02\n         MNOTE 4,'LENGTH CODE OF FIRST OPERAND (&$PLEN1) FORCED TO 8'\n.OK02    ANOP\n&NAME    MVC   CVXFW,&FW           COPY TO 'SAFE' AREA\n         UNPK  CVXDBL(9),CVXFW(5)  EXPLODE INTO 1-BYTE 'NIBBLES'\n         MVZ   CVXDBL,CVXZEROS     SET HIGH NIBBLES TO ZERO\n         TR    CVXDBL,CVXTABLE     TR UNPRINTABLE GARBAGE TO PRINTABLE\n&X       SETC  ''                  ASSUME NO EXPLICIT BASE REGISTER\n         AIF   ('&$PBASE1' EQ '').SKIP10 WAS ASSUMPTION CORRECT?\n&X       SETC  '&$PBASE1'          ADD BASE REG SPECIFICATION\n.SKIP10  MVC   &$PTAG1.(8&X),CVXDBL COPY 8 BYTES TO CALLER'S RESULT\n         AIF   (D'CVXFW).MEND      DEFINE ONLY ONCE, THANK YOU\n         $WA                       ESTABLISH WORK AREA ADDRESSABILITY\nCVXFW    DC    CL4' ',C' '         FOUR (PLUS 1 TO FLIP SIGN)\nCVXDBL   DC    CL8' ',C' '         EIGHT (PLUS 1 TO FLIP SIGN)\nCVXZEROS DC    XL8'0F0F0F0F0F0F0F0F' FOR ZERO ZONES\nCVXTABLE DC    C'0123456789ABCDEF' MAGIC TABLE\n         $IA                       BACK TO EXECUTABLE ADDRESSABILITY\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DATECONV": {"ttr": 2572, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x007\\x01\\x01&\\x0f\\x01\\x02\\x08\\x0f\\x08@\\x01\\xfe\\x01\\xef\\x00\\x00\\xc7\\xc5\\xd5\\xe3\\xd9\\xf0\\xf2@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "2001-09-17T00:00:00", "modifydate": "2002-03-21T08:40:37", "lines": 510, "newlines": 495, "modlines": 0, "user": "GENTR02"}, "text": "DATECONV TITLE 'UNIVERSAL DATE CONVERTER'\n*                                                                     *\n*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\n* DATECONV REFORMATS A DATE FIELD PROVIDED BY THE CALLER (HENCEFORTH  *\n* CALLED THE 'FROM DATE') INTO AN OUTPUT FIELD ALSO PROVIDED BY THE   *\n* CALLER (THE 'TO DATE'). THIS MIRACULOUS TRANSFORMATION IS DRIVEN    *\n* BY FORMATS (ALSO PROVIDED BY THE CALLER) FOR THE 'FROM DATE' AND    *\n* THE 'TO DATE'.                                                      *\n*                                                                     *\n* DATECONV REQUIRES THE USER TO PROVIDE A FORMAT FOR THE 'FROM DATE', *\n* A VALUE FOR THE 'FROM DATE', AND A FORMAT FOR THE 'TO DATE'. THE    *\n* VALUE FOR THE 'FROM DATE' IS INTERPRETTED BASED ON THE FORMAT OF    *\n* THE 'FROM DATE'. THE VALUE FOR THIS DATE IS TRANSMORGRIFIED INTO A  *\n* COMMON FORMAT, AND IS THEN MOVED TO THE CALLER'S OUTPUT FIELD       *\n* DRIVEN BY THE FORMAT PROVIDED BY THE USER FOR THE 'TO DATE'.        *\n*                                                                     *\n* THE FIELDS THAT THE CALLER MUST PASS ARE DEFINED AS FOLLOWS:        *\n*                                                                     *\n* PASSED PARAMETER LIST:              SET BY CALLER   CHANGED BY      *\n* 01  PASSED-PARMS.                     AT 'CALL'?   THIS ROUTINE?    *\n*     05  WINDOW-VALUE      PIC 9(02).     YES (*)        NO          *\n*     05  RC-VALUE          PIC 9(02).      NO           YES          *\n*     05  FROM-FORMAT       PIC X(16).     YES            NO          *\n*     05  TO-FORMAT         PIC X(16).     YES            NO          *\n*     05  FROM-VALUE        PIC X(16).     YES            NO          *\n*     05  TO-VALUE          PIC X(16).      NO           YES          *\n*                                                                     *\n* EACH CHARACTER IN THE FROM-FORMAT FIELD CONTROLS THE                *\n* INTERPRETATION OF THE CORRESPONDING CHARACTER IN THE FROM-VALUE     *\n* FIELD (APPLIES TO THE TO- FIELDS ON OUTPUT). FOR EXAMPLE, IF 'YYYY' *\n* OCCURS IN POSITIONS 1-4 OF FROM-FORMAT, THEN POSITIONS 1-4 OF       *\n* FROM-VALUE MUST CONTAIN THE VALUE FOR 'YYYY' (EG '1998').           *\n*                                                                     *\n* EXCEPT FOR THE COBOL-TYPE DAY COUNT, ANY COMBINATION OF FORMAT      *\n* VALUES IS PERMITTED (FOR COBOL-TYPE DAY COUNT, NO OTHER VALUES ARE  *\n* PERMITTED). IN THE 'FROM DATE' FIELD, A COMPLETE DATE               *\n* MUST BE SPECIFIED ('DDDDDDD', OR 'YY', WITH AT LEAST ENOUGH         *\n* ADDITIONAL DATA TO DEFINE THE DAY OF THE YEAR, SUCH AS:             *\n* 'JJJ' OR           (JULIAN DAY OF YEAR)                             *\n* 'MM' AND 'DD' OR   (NUMERIC MONTH AND DAY)                          *\n* 'MMM' AND 'DD'     (ALPHA MONTH AND NUMERIC DAY)                    *\n*                                                                     *\n* IF 'YY' IS DEFINED IN THE 'FROM DATE', AND 'CC' IS NOT DEFINED,     *\n* THEN 'YY' WILL BE WINDOWED BASED ON THE PIVOT YEAR PROVIDED IN      *\n* THE FIRST PARAMETER, OR ON THE YEAR CALCULATED BY SUBTRACTING 50    *\n* FROM THE CURRENT YEAR (SYSTEM DATE). THE CENTURY VALUE USED WHEN    *\n* WINDOWING IS REQUIRED IS DETERMINED BY ADDING 50 TO THE CURRENT     *\n* YEAR TO GET THE 'NEXT' CENTURY, AND SUBTRACTING 50 FROM THE CURRENT *\n* YEAR TO DETERMINE THE 'PREVIOUS' CENTURY (IT'LL WORK PAST           *\n* THE YEAR 2049, SPORTS FANS! HOWEVER, WHEN WE GET TO THE YEAR 9949,  *\n* WE'LL HAVE A PROBLEM.)                                              *\n*                                                                     *\n* THE FOLLOWING LIST OF VALUES FOLLOWS THE PRECEDENCE USED IN         *\n* PROCESSING THE FORMAT. I.E., 'YYYY' IS TESTED BEFORE 'YY' SO THAT   *\n* A 4-DIGIT YEAR WILL BE CORRECTLY PROCESSED IF IT IS DEFINED, BUT    *\n* IF IT ISN'T DEFINED, THEN 'DATECONV' WILL TEST FOR A 2-DIGIT YEAR.  *\n*                                                                     *\n* VALID FORMAT VALUES (IN FROM-FORMAT OR TO-FORMAT):                  *\n* DDDDDDD - COBOL-TYPE DAY COUNT (01/01/1601 IS DAY 1)                *\n*           (IF THIS VALUE IS SPECIFIED, THEN NO OTHER VALUES MAY BE  *\n*           DEFINED IN THE SAME FORMAT FIELD)                         *\n* YYYY    - YEAR INCLUDING CENTURY (EQUIVALENT TO CCYY)               *\n* CCYY    - YEAR INCLUDING CENTURY (EQUIVALENT TO YYYY)               *\n* CC      - 2-DIGIT CENTURY                                           *\n* YY      - 2-DIGIT YEAR (NOT INCLUDING CENTURY)                      *\n* C       - 1-DIGIT CENTURY '0' FOR 20TH '1' FOR 21ST '2' FOR 22ND    *\n*           ETC. (WILL FAIL AFTER 12/31/2899)                         *\n* QQQ     - 3-CHAR QUARTER (E.G. 1ST 2ND 3RD 4TH) (IGNORED ON INPUT)  *\n* MMM     - ALPHABETIC MONTH SUCH AS 'JAN'                            *\n* MM      - 2-DIGIT NUMERIC MONTH                                     *\n* DDD     - 3-CHAR ALPHABETIC DAY OF WEEK (IGNORED ON INPUT)          *\n* JJJ     - 3-DIGIT JULIAN DAY OF YEAR                                *\n* DD      - 2-DIGIT GREGORIAN DAY OF MONTH                            *\n* ANY OTHER CHARACTER:                                                *\n*      FROM-FORMAT:    IGNORED                                        *\n*      TO-FORMAT:      COPIED TO OUTPUT DATE (TO-VALUE) AS-IS         *\n*      EXAMPLES OF POSSIBLE CHARACTERS: SLASH ('/') COMMA (',')       *\n*                                       SPACE (' ')                   *\n*                                                                     *\n* EXAMPLE OF CALL:                                                    *\n* 01  PASSED-PARMS.                                                   *\n*     05  WINDOW-VALUE         PIC 9(02) VALUE 80.                    *\n*     05  RC-VALUE             PIC 9(02).                             *\n*     05  FROM-FORMAT          PIC X(16) VALUE 'YYMMDD'.              *\n*     05  TO-FORMAT            PIC X(16) VALUE 'MMM DD, YYYY'.        *\n*     05  FROM-VALUE           PIC X(16) VALUE '970615'.              *\n*     05  TO-VALUE             PIC X(16).                             *\n*                                                                     *\n* NOTE THAT FROM-VALUE MATCHES, BYTE BY BYTE, FROM-FORMAT.            *\n* THE CALCULATED RESULT WILL BE 'JUN 15, 1997    '.                   *\n*                                                                     *\n* (*) IF VALID NUMERIC, THIS INPUT VALUE IS USED AS THE WINDOWING     *\n*     PIVOT YEAR. IF VALUE IS '80' THEN YEARS 81 - 99 ARE INTERPRETED *\n*     AS 20TH CENTURY AND 00 - 80 ARE INTERPRETED AS 21ST CENTURY.    *\n* ->  IF IT IS NOT VALID NUMERIC, THEN TODAY'S DATE MINUS 50 YEARS IS *\n*     USED AS A PIVOT YEAR.                                           *\n*                                                                     *\n* ->  IF YOU WANT THE ROUTINE TO USE A FLOATING PIVOT, CALCULATED BY  *\n*     SUBTRACTING 50 FROM THE CURRENT YEAR, THEN MOVE SOMETHING LIKE  *\n*     'XX' (OR SOME OTHER NON-NUMERIC VALUE) TO THIS FIELD BEFORE     *\n*     THE ROUTINE IS CALLED.                                          *\n*                                                                     *\n* ->  IF, FOR SOME IDIOTIC REASON, YOU WANT TO USE A FIXED PIVOT,     *\n*     OR MAYBE YOU WANT TO CALCULATE YOUR OWN FLOATING PIVOT, THEN    *\n*     YOU MUST MOVE THAT VALUE TO 'WINDOW-VALUE'.                     *\n*                                                                     *\n* ->  IF YOU WANT TO CHANGE THE FLOATING PIVOT CALCULATED WITHIN THIS *\n*     PROGRAM, THEN CHANGE THE CONSTANT USED IN THE INSTRUCTION       *\n*     TAGGED 'SETPIVOT' TO THE DESIRED INCREMENT.                     *\n*                                                                     *\n* ->  ON OUTPUT, 'RC-VALUE' IS SET TO ZERO IF NO ERRORS WERE DETECTED *\n*     OR TO A VALUE > 0 IF ONE OR MORE ERRORS WERE DETECTED:          *\n*   1 - JJJ WAS SPECIFIED IN FROM-FORMAT, BUT AN INVALID DATE         *\n*       WAS CREATED AND INTOFDAY RETURNED AN ERROR RETURN CODE        *\n*   2 - MM AND DD WERE SPECIFIED IN FROM-FORMAT, BUT AN INVALID DATE  *\n*       WAS CREATED AND INTOFDTE RETURNED AN ERROR RETURN CODE        *\n*   4 - MMM WAS SPECIFIED IN FROM-FORMAT BUT THE CORRESPONDING        *\n*       POSITIONS IN FROM-VALUE DID NOT CONTAIN JAN FEB MAR APR MAY   *\n*       JUN JUL AUG SEP OCT NOV OR DEC.                               *\n*   8 - A DATE OF GREATER THAN DEC 31, 9999 WAS CREATED FROM          *\n*       FROM-FORMAT AND FROM-VALUE.                                   *\n*  16 - DDDDDDD WAS NOT SPECIFIED, JJJ WAS NOT SPECIFIED, AND NO      *\n*       VALUE FOR MM WAS FOUND.                                       *\n*  32 - DDDDDDD WAS NOT SPECIFIED, JJJ WAS NOT SPECIFIED, AND NO      *\n*       VALUE FOR DD WAS FOUND.                                       *\n*                                                                     *\n* IF A NON-ZERO ERROR CODE OTHER THAN THOSE LISTED ABOVE IS RECEIVED, *\n* THEN REPETITIVELY DETERMINE THE LARGEST OF THE ABOVE LISTED CODES   *\n* THAT IS NOT GREATER THAN THE RECEIVED ERROR CODE, NOTE IT (I.E.,    *\n* THAT PARTICULAR EVENT WAS DETECTED), SUBTRACT THAT VALUE FROM THE   *\n* RECEIVED ERROR CODE, AND REPEAT THE PROCESS UNTIL THE REMAINING     *\n* VALUE IS ZERO.                                                      *\n*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\n*                                                                     *\n*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\n* GLOBAL SET SYMBOL CONTROLS INCLUSION OF DIAGNOSTIC CODE AND SET UP  *\n* NAMES FOR INSTRUCTION AND DATA AREA LOCATION COUNTERS               *\n*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\n         SPACE 1\n         GBLC  &GSECT,&WSECT,&$MLOCTR\n&GSECT   SETC  'GSECT'             THESE SYMBOLS ARE USED BY MACROS\n&WSECT   SETC  'WSECT'             . THAT GENERATE 'DC' INSTRUCTIONS\n&$MLOCTR SETC  'WSECT'             .\n         SPACE 1\n         PRINT   GEN\n         SPACE 1\n*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\n* SET UP PROGRAM CSECT AND LOCATION COUNTERS FOR INSTRUCTION AREA AND *\n* DATA AREA. DEFINE REGISTER SAVE AREA                                *\n*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\n         SPACE 1\nDATECONV CSECT\n&GSECT   LOCTR ,                   LADIES BEFORE GENTLEMEN, THANK YOU\n&WSECT   LOCTR ,                   NOW YOU, SIR\nSAVEAREA DC    18F'0'              STD REG SAVE AREA\n&GSECT   LOCTR ,                   AND NOW, BACK TO THE LADY\n         USING *,R12               INFORM ASSEMBLER\n         STM   R14,R12,12(R13)     SAVE REGS\n         LR    R12,R15             SET UP BASE REG\n         B     CONTINUE            SKIP AROUNT MARKERS\n         DC    C'********        '\n         DC    C'DATECONV ASSEMBLED ON '\n&S1      SETC  '&SYSDATC'(5,2)\n&S2      SETC  '&SYSDATC'(7,2)\n&S3      SETC  '&SYSDATC'(1,4)\n&T1      SETC  '&SYSTIME'(1,2)\n&T2      SETC  '&SYSTIME'(4,2)\n         DC    C'&S1/&S2/&S3 AT &T1:&T2'\n         DC    C'        ********'\nCONTINUE DS    0H\n         SLR   R15,R15             ASSUME R/C ZERO\n         ST    R15,16(,R13)        STUFF R/C BACK INTO SAVEAREA\n         LA    R14,SAVEAREA        POINT TO MY SAVE AREA\n         ST    R14,8(,R13)         FORWARD CHAIN\n         ST    R13,4(,R14)         BACK CHAIN\n         LR    R13,R14             SET UP MY SAVEAREA\n         SPACE 1\n         L     R11,0(,R1)          PASSED PARAMETERS\n         USING PASSED_PARAMETERS,R11 MAKE IT OFFICIAL\n         TIME  DEC,SYSTEM_DATE,DATETYPE=YYYYMMDD,LINKAGE=SYSTEM\n         UNPK  CURRENT_DATE(9),SYSTEM_DATE+8(5) VIZUALIZE YYYYMMDD\n         PACK  WS_PL3,CURRENT_DATE(4)         COPY SYSTEM DATE\nSETPIVOT AP    WS_PL3,=P'50'                  PLUS 50\n         IF    (CLI,WINDOW_VALUE+0,X'EF',H),AND,  MUST BE IN RANGE OF  X\n               (CLI,WINDOW_VALUE+0,X'FA',L),AND,  . 0 - 9              X\n               (CLI,WINDOW_VALUE+1,X'EF',H),AND,  . DITTO              X\n               (CLI,WINDOW_VALUE+1,X'FA',L),THENDO .\n           MVC   WINDOW_YY,WINDOW_VALUE         USE IT\n         ELSE  ,                   ELSE\n           UNPK  WINDOW_YY,WS_PL3  COPY SYS DATE YY MINUS 50\n           OI    WINDOW_YY+1,C'0'  AND FIX SIGN\n         ENDIF ,\n         UNPK  NEXT_CENT(4),WS_PL3   CAPTURE NEXT CENTURY ('20'?)\n         SP    WS_PL3,=P'100'        BACK UP TO PREV CENTURY ('19'?)\n         UNPK  PREV_CENT(4),WS_PL3   . AND CAPTURE IT\n         PACK  ERRORS,=Z'0'        SET DEFAULT RETURN CODE\n         UNPK  HOLD_JJJ,=X'0F'     SET WORK FIELD TO ZEROS\n         UNPK  CALLED_YYYYMMDD,=X'0F'  SET WORK FIELDS TO ZEROS\n         UNPK  CALLED_DAY_COUNT,=X'0F'   .\n         LA    R3,HOLD_FMT         GET READY TO BUMP THROUGH FIELD\n         LA    R4,FROM_VAL         .\n         MVC   HOLD_FMT(16),FROM_FMT COPY TO HOLDING TANK\n         DO    UNTIL=(CL,R3,=A(HOLD_FMT+15),H) SCAN ENTIRE STRING\n           IF    (CLC,=C'DDDDDDD',0(R3),E),THENDO DAYS SINCE 01/01/1601\n             MVC   CALLED_DAY_COUNT+1(7),0(R4) SAVE DDDDDDD\n             UNPK  CALLED_YYYYMMDD,=X'0F'  SET WORK FIELDS TO ZEROS\n             DOEXIT ,                      CALL IT QUITS\n           ELSEIF (CLC,=C'YYYY',0(R3),E),OR,    4-DIGIT YEAR           X\n               (CLC,=C'CCYY',0(R3),E),THENDO 4-DIGIT YEAR\n             MVC   CALLED_YYYYMMDD(4),0(R4)\n             LA    R3,4(,R3)\n             LA    R4,4(,R4)\n             DONEXT ,\n           ELSEIF (CLC,=C'CYY',0(R3),E),THENDO 3-DIGIT YEAR\n             PACK  WS_PL2,0(1,R4)      CAPTURE THE 'C' OF 'CYY'\n             AP    WS_PL2,=P'19'       COMPUTE TRUE CENTURY\n             UNPK  CALLED_YYYYMMDD(2),WS_PL2 COPY TO PERM WORK AREA\n             OI    CALLED_YYYYMMDD+1,C'0' FIX SIGN\n             MVC   CALLED_YYYYMMDD+2(2),1(R4) COPY YY VALUE\n             LA    R3,3(,R3)\n             LA    R4,3(,R4)\n             DONEXT ,\n           ELSEIF (CLC,=C'JJJ',0(R3),E),THENDO  JULIAN DAY OF YEAR\n             MVC   HOLD_JJJ,0(R4)  COPY JULIAN DAY OF YEAR\n             LA    R3,3(,R3)\n             LA    R4,3(,R4)\n             DONEXT ,\n           ELSEIF (CLC,=C'DDD',0(R3),E),THENDO  ALPHA DAY OF WEEK\n* IGNORE ON INPUT\n             LA    R3,3(,R3)\n             LA    R4,3(,R4)\n             DONEXT ,\n           ELSEIF (CLC,=C'MMM',0(R3),E),THENDO EX. 'JAN'\n* FIGURE OUT NUMERIC MONTH BASED ON ALPHA MONTH\n             LA    R5,1            GET SET TO SCAN TABLE\n             DO    UNTIL=(CL,R5,=F'12',H)\n               LR    R6,R5         COPY COUNTER\n               BCTR  R6,0          CHANGE TO OFFSET\n               MH    R6,=H'3'      EACH IS 3 CHARS LONG\n               LA    R6,MONTHS_DEF(R6) POINT TO ENTRY\n               IF    (CLC,0(3,R6),0(R4),E),THENDO MATCH?\n                 CVD   R5,DOUBLE   YES - GET MONTH COUNT\n                 UNPK  CALLED_YYYYMMDD+4(2),DOUBLE .\n                 OI    CALLED_YYYYMMDD+5,C'0'      .\n                 LA    R5,13       FORCE END-OF-LOOP\n               ENDIF ,\n               LA    R5,1(,R5)     BUMP TO NEXT MONTH NUMBER\n             ENDO  ,\n             IF    (CL,R5,=F'13',E),THENDO IF NOT-FOUND, THEN\n               MVC   CALLED_YYYYMMDD+4(2),CURRENT_DATE+4 SET TO CURRENT\n               AP    ERRORS,=P'04' AND FLAG ERROR\n             ENDIF ,\n             LA    R3,3(,R3)       BUMP PAST MMM ON FORMAT\n             LA    R4,3(,R4)       . AND DATA\n             DONEXT ,\n           ELSEIF  (CLC,=C'MM',0(R3),E),THENDO NUMERIC MONTH\n             IF    (CLI,1(R4),C'0',L),THENDO IF +1 NOT NUMERIC THEN...\n               MVC   CALLED_YYYYMMDD+5(1),0(R4) COPY ONLY 1 DIGIT\n               LA    R4,1(,R4)\n             ELSE  ,\n               MVC   CALLED_YYYYMMDD+4(2),0(R4) COPY 2 DIGITS\n               LA    R4,2(,R4)\n             ENDIF ,\n             LA    R3,2(,R3)\n             DONEXT ,\n           ELSEIF  (CLC,=C'CC',0(R3),E),THENDO 'CC' BUT NOT 'CCYY'\n             MVC   CALLED_YYYYMMDD(2),0(R4) COPY CC VALUE\n             LA    R3,2(,R3)\n             LA    R4,2(,R4)\n             DONEXT ,\n           ELSEIF  (CLC,=C'YY',0(R3),E),THENDO 'YY' BUT NOT 'YYYY'\n             MVC   CALLED_YYYYMMDD+2(2),0(R4) COPY YY VALUE\n             LA    R3,2(,R3)\n             LA    R4,2(,R4)\n             DONEXT ,\n           ELSEIF  (CLC,=C'DD',0(R3),E),THENDO 'DD' BUT NOT 'DDDDDDD'\n             IF    (CLI,1(R4),C'0',L),THENDO IF +1 NOT NUMERIC THEN...\n               MVC   CALLED_YYYYMMDD+7(1),0(R4) COPY 1 DIGIT\n               LA    R4,1(,R4)\n             ELSE  ,\n               MVC   CALLED_YYYYMMDD+6(2),0(R4) COPY 2 DIGITS\n               LA    R4,2(,R4)\n             ENDIF ,\n             LA    R3,2(,R3)\n             DONEXT ,\n           ELSEIF  (CLC,=C'C',0(R3),E),THENDO 1-DIGIT CENTURY BY ITSELF\n             PACK  WS_PL2,0(1,R4)  CAPTURE 'FUNNY' CENTURY\n             AP    WS_PL2,=P'19'   NORMALIZE IT\n             UNPK  CALLED_YYYYMMDD(2),WS_PL2 COPY TO OUTPUT FIELD\n             OI    CALLED_YYYYMMDD+1,C'0' FIX SIGN\n             LA    R3,1(,R3)\n             LA    R4,1(,R4)\n             DONEXT ,\n           ELSE  ,\n* JUST BUMP TO NEXT POSITION IN FORMAT AND VALUE FIELDS\n             LA    R3,1(,R3)\n             LA    R4,1(,R4)\n           ENDIF ,\n         ENDO  ,\n* IF DAY_COUNT IS ZEROS THEN PROCESS YYYYMMDD TYPE DATE\n         IF    (CLC,CALLED_DAY_COUNT,=C'00000000',E),THENDO\n* WINDOWING REQUIRED?\n           IF    (CLC,=CL2'00',CALLED_YYYYMMDD,E),THENDO\n             IF    (CLC,CALLED_YYYYMMDD+2(2),WINDOW_YY,H),THENDO\n               MVC   CALLED_YYYYMMDD(2),PREV_CENT '19' UNTIL AFTER 2049\n             ELSE  ,\n               MVC   CALLED_YYYYMMDD(2),NEXT_CENT '20' UNTIL AFTER 2049\n             ENDIF ,\n           ENDIF ,\n* NOW FIND A JJJ (1ST PRIORITY) OR MMDD\n           IF    (CLC,=C'000',HOLD_JJJ,E),THENDO IF NO JJJ THEN MMDD\n             IF    (CLC,=CL2'00',CALLED_YYYYMMDD+4,E),THENDO TEST MONTH\n               MVC   CALLED_YYYYMMDD+4(2),CURRENT_DATE+4\n               AP    ERRORS,=P'16'\n             ELSEIF  (CLC,=CL2'00',CALLED_YYYYMMDD+6,E),THENDO TEST DAY\n               MVC   CALLED_YYYYMMDD+6(2),CURRENT_DATE+6\n               AP    ERRORS,=P'32'\n             ELSE  ,\n               CALL  INTOFDTE,(CALLED_YYYYMMDD,CALLED_DAY_COUNT)\n               IF    (CLC,CALLED_DAY_COUNT,=C'00000000',E),THENDO\n                 AP    ERRORS,=P'2'\n               ENDIF ,\n             ENDIF ,\n           ELSE  ,\n             MVC   CALLED_YYYYMMDD+4(3),HOLD_JJJ\n             CALL  INTOFDAY,(CALLED_YYYYMMDD,CALLED_DAY_COUNT)\n             IF    (CLC,CALLED_DAY_COUNT,=C'00000000',E),THENDO\n               AP    ERRORS,=P'1'\n             ELSE  ,\n             ENDIF ,\n           ENDIF ,\n         ELSE  ,\n           IF    (CLC,CALLED_DAY_COUNT,=C'03067671',H),THENDO\n             AP    ERRORS,=P'8'\n           ENDIF ,\n         ENDIF ,\n         MVC   TO_VAL,SPACES       SET OUTPUT TO SPACES\n         UNPK  ERROR_CODE,ERRORS\n         OI    ERROR_CODE+1,C'0'\n         IF    (CP,ERRORS,=P'0',NE),THENDO\n           B     RETURN\n         ENDIF ,\n* AT THIS POINT WE FOR-SURE HAVE A VALID CALLED_DAY_COUNT\n* NOW GET GREGORIAN AND JULIAN DATES FROM CALLED_DAY_COUNT\n         IF    (CLC,TO_FMT+00(7),=C'DDDDDDD',NE),AND,                  X\n               (CLC,TO_FMT+09(7),=C'DDDDDDD',NE),THENDO\n* I ASSUME WE'LL NEED THE GREGORIAN DATE (BUT NOT JULIAN)\n           CALL  DTEOFINT,(CALLED_DAY_COUNT,CALLED_YYYYMMDD)\n           MVC   STD_DATE_YYYYMMDD,CALLED_YYYYMMDD\n         ENDIF ,\n* SET UP TO BUMP THROUGH OUTPUT FORMAT AND DATA\n         LA    R3,HOLD_FMT\n         LA    R4,TO_VAL\n         MVC   HOLD_FMT(16),TO_FMT\n* SLASH_SW, IF SET, ALLOWS THE OUTPUT OF SINGLE DIGIT DAYS AND MONTHS\n* WHEN THE VALUE IS < 10. IF NOT SET, THEN THE OUTPUT VALUE WILL BE\n* '01' ETC. IF SET, THIS ALLOWS A DATE TO BE OUTPUT AS '7/4/1998' OR\n* AS '07041998' DEPENDING ON THE VALUE FOR TO_FMT.\n         MVI   SLASH_SW,C' '       NULL\n         DO    UNTIL=(CL,R3,=A(HOLD_FMT+15),H) SCAN ALL 16 POSITIONS\n           IF    (CLC,=C'DDDDDDD',0(R3),E),THENDO DAY_COUNT\n             MVC   0(7,R4),CALLED_DAY_COUNT+1 COPY 7 D'S\n             DOEXIT ,              EXIT DO LOOP\n           ELSEIF (CLC,=C'YYYY',0(R3),E),OR,    4-DIGIT YEAR           X\n               (CLC,=C'CCYY',0(R3),E),THENDO 4-DIGIT YEAR\n             MVC   0(4,R4),STD_DATE_YYYYMMDD COPY 4-DIGIT YEAR\n             LA    R3,4(,R3)\n             LA    R4,4(,R4)\n           ELSEIF (CLC,=C'CYY',0(R3),E),THENDO 3-DIGIT YEAR\n             PACK  WS_PL2,STD_DATE_YYYYMMDD(2) CAPTURE 'CC'\n             SP    WS_PL2,=P'19'       CALCULATE ONE-DIGIT CENTURY\n             UNPK  0(1,R4),WS_PL2      COPY ONE-DIGIT 'C'\n             OI    0(R4),C'0'          FIX SIGN\n             MVC   1(2,R4),STD_DATE_YYYYMMDD+2 COPY 2-DIGIT YEAR\n             LA    R3,3(,R3)\n             LA    R4,3(,R4)\n           ELSEIF  (CLC,=C'QQQ',0(R3),E),THENDO 3-CHAR QUARTER\n             IF     (CLC,STD_DATE_YYYYMMDD+4(2),=C'09',H),THENDO\n               MVC   0(3,R4),=C'4TH'   SET 4TH QUARTER\n             ELSEIF (CLC,STD_DATE_YYYYMMDD+4(2),=C'06',H),THENDO\n               MVC   0(3,R4),=C'3RD'   SET 3RD QUARTER\n             ELSEIF (CLC,STD_DATE_YYYYMMDD+4(2),=C'03',H),THENDO\n               MVC   0(3,R4),=C'2ND'   SET 2ND QUARTER\n             ELSE  ,\n               MVC   0(3,R4),=C'1ST'   SET 1ST QUARTER\n             ENDIF ,\n             LA    R3,3(,R3)\n             LA    R4,3(,R4)\n           ELSEIF (CLC,=C'JJJ',0(R3),E),THENDO  JULIAN DAY OF YEAR\n* OK, OK, ALREADY - GET THE JULIAN...\n             CALL  DAYOFINT,(CALLED_DAY_COUNT,CALLED_YYYYMMDD)\n             MVC   STD_DATE_YYYYJJJ,CALLED_YYYYMMDD\n             MVC   0(3,R4),STD_DATE_YYYYJJJ+4 COPY DAY-OF-YEAR\n             LA    R3,3(,R3)\n             LA    R4,3(,R4)\n           ELSEIF (CLC,=C'DDD',0(R3),E),THENDO  ALPHA DAY OF WEEK\n             PACK  DIVIDEND,CALLED_DAY_COUNT COMPUTERIZE DAY_COUNT\n             DP    DIVIDEND,=PL2'7' GET INDEX INTO DAY_TABLE\n             ZAP   DOUBLE,REMAINDER VALUE RANGE IS 0 - 6\n             CVB   R5,DOUBLE        BINARY IT\n             MH    R5,=H'3'        NOW RANGE IS 0 - 18 FOR 3-CHAR TABLE\n             LA    R5,DAY_TABLE(R5)  GET LOC'N OF REQUIRED DAY\n             MVC   0(3,R4),0(R5)    COPY IT TO OUTPUT\n             LA    R3,3(,R3)\n             LA    R4,3(,R4)\n           ELSEIF (CLC,=C'MMM',0(R3),E),THENDO ALPHABETIC MONTH\n             PACK  DOUBLE,STD_DATE_YYYYMMDD+4(2) MONTH NUMBER\n             CVB   R5,DOUBLE       BINARY\n             MH    R5,=H'3'        OFFSET\n             LA    R5,MONTHS_DEF-3(R5) MONTH NAME LOC'N\n             MVC   0(3,R4),0(R5)   COPY IT TO OUTPUT\n             LA    R3,3(,R3)\n             LA    R4,3(,R4)\n           ELSEIF  (CLC,=C'CC',0(R3),E),THENDO 2-DIGIT CENTURY\n             MVC   0(2,R4),STD_DATE_YYYYMMDD COPY CC TO OUTPUT\n             LA    R3,2(,R3)\n             LA    R4,2(,R4)\n           ELSEIF  (CLC,=C'YY',0(R3),E),THENDO 2-DIGIT YEAR\n             MVC   0(2,R4),STD_DATE_YYYYMMDD+2 COPY YY TO OUTPUT\n             LA    R3,2(,R3)\n             LA    R4,2(,R4)\n           ELSEIF  (CLC,=C'MM',0(R3),E),THENDO NUMERIC MONTH\n             IF    ((CLI,2(R3),C',',E),OR, COMMA DELIMITED?            X\n               (CLI,SLASH_SW,C'Y',E),OR, SLASH ALREADY DETECTED?       X\n               (CLI,2(R3),C'/',E)),AND, SLASH DELIMITED?               X\n               (CLI,STD_DATE_YYYYMMDD+4,C'0',E),THENDO AND 1-DIGIY VAL?\n               MVC   0(1,R4),STD_DATE_YYYYMMDD+5 COPY 1-DIGIT MM\n               LA    R3,2(,R3)\n               LA    R4,1(,R4)\n             ELSE  ,\n               MVC   0(2,R4),STD_DATE_YYYYMMDD+4 COPY 2-DIGIT MM\n               LA    R3,2(,R3)\n               LA    R4,2(,R4)\n             ENDIF ,\n           ELSEIF  (CLC,=C'DD',0(R3),E),THENDO    DD\n             IF    ((CLI,2(R3),C',',E),OR, COMMA DELIMITED?            X\n               (CLI,SLASH_SW,C'Y',E),OR, SLASH ALREADY DETECTED?       X\n               (CLI,2(R3),C'/',E)),AND, SLASH DELIMITED                X\n               (CLI,STD_DATE_YYYYMMDD+6,C'0',E),THENDO\n               MVC   0(1,R4),STD_DATE_YYYYMMDD+7 COPY 1-DIGIT DD\n               LA    R3,2(,R3)\n               LA    R4,1(,R4)\n             ELSE  ,\n               MVC   0(2,R4),STD_DATE_YYYYMMDD+6 COPY 2-DIGIT DD\n               LA    R3,2(,R3)\n               LA    R4,2(,R4)\n             ENDIF ,\n           ELSEIF  (CLC,=C'C',0(R3),E),THENDO 1-DIGIT CENTURY\n             PACK  WS_PL2,STD_DATE_YYYYMMDD(2) CAPTURE CENTURY\n             SP    WS_PL2,=P'19'   CALCULATE 1-DIGIT CENTURY\n             UNPK  0(1,R4),WS_PL2  FLIP TO 'FUNNY' CENTURY\n             OI    0(R4),C'0'      FIX SIGN\n             LA    R3,1(,R3)\n             LA    R4,1(,R4)\n           ELSE  ,                 MOVE OTHER FORMATTING CHARACTER\n             IF    (CLI,0(R3),C'/',E),OR,                              X\n               (CLI,0(R3),C',',E),THENDO\n               MVI   SLASH_SW,C'Y'\n             ENDIF ,\n             MVC   0(1,R4),0(R3)   COPY TO-FMT CHAR TO OUTPUT DATE\n             LA    R3,1(,R3)\n             LA    R4,1(,R4)\n           ENDIF ,\n         ENDO  ,\nRETURN   DS    0H                  PROVIDE STD RETURN LINKAGE\n         L     R13,4(,R13)         BACK CHAIN\n         LM    R14,R12,12(R13)     RESTORE REGS\n         DROP  R12                 NEGATE ADDRESSABILITY\n         BR    R14                 RETURN\n&WSECT   LOCTR ,                   FINALLY - THE GENTLEMAN'S TURN\nDOUBLE   DC    D'0'\n         EJECT\n         SPACE 1\n*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\n* VARIABLES, CONSTANTS, DCB'S ETC.                                    *\n*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\n         SPACE 1\nDIVIDEND  DC    PL8'0'\nQUOTIENT  EQU   DIVIDEND,6,C'P'\nREMAINDER EQU   DIVIDEND+6,2,C'P'\nCALLED_YYYYMMDD DC CL8'00000000'   DTEOFINT CALCS THIS ONE\nCALLED_DAY_COUNT  DC CL8'00000000' DATECONV CALCS THIS ONE\n*                                  END OF PARAMETERS\nSTD_DATE_YYYYMMDD DC CL8'00000000' WORK AREA TO CREATE DATE\nSTD_DATE_YYYYJJJ  DC CL7'0000000'  USED WHEN FMT 'DDDDDDD' FOUNT\nHOLD_JJJ          DC CL3'000'      USED WHEN FMT 'JJJ' FOUND\nHOLD_FMT          DC CL24' '       USED SO COMPARES WON'T OVERFLOW\nSPACES            DC CL133' '\nMONTHS_DEF DC CL36'JANFEBMARAPRMAYJUNJULAUGSEPOCTNOVDEC'\nDAY_TABLE  DC CL21'SUNMONTUEWEDTHUFRISAT'\nWINDOW_YY           DC CL2'00'     SET TO WINDOWING VALUE\nPREV_CENT           DC CL2'00',2C' '\nNEXT_CENT           DC CL2'00',2C' '\nERRORS              DC PL2'0'      ACCUMULATE ERRORS\nWS_PL2              DC PL2'0'      TEMP CELL\nWS_PL3              DC PL4'0'         .\nSYSTEM_DATE DS   2F'0',X'19981109',F'0' WORK AREA FOR SYSTEM DATE\nCURRENT_DATE DC    CL8'19981109',C' ' HOLDS UNPACKED SYSTEM DATE\nSLASH_SW DC    C' '                FOR '/' OR ','\nLINKAGE  DSECT\nPASSED_PARAMETERS   DS    0D\nWINDOW_VALUE        DS    CL2      EX. '50' (WINDOWING VALUE)\nERROR_CODE          DS    CL2      EX. '00' (RETURN CODE - CALCULATED)\nFROM_FMT            DS    CL16     EX. 'YYYYMMDD        '\nTO_FMT              DS    CL16     EX. 'MMM DD, YYYY    '\nFROM_VAL            DS    CL16     EX. '19981110        '\nTO_VAL              DS    CL16     EX. 'NOV 11, 1998    ' (CALCULATED)\nDATECONV CSECT ,                   BACK TO MAIN\n         EQUATE ,                  REGISTER EQUATES\n         END   ,                   REQUIRED END STATEMENT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DEFPGMID": {"ttr": 2821, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00\\x00o\\x01\\x00\\x00o\\x18S\\x00\\x0f\\x00\\x0f\\x00\\x00\\xc2\\xc3\\xd6\\xc4\\xc8\\xe2\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-01-06T00:00:00", "modifydate": "2000-01-06T18:53:00", "lines": 15, "newlines": 15, "modlines": 0, "user": "BCODHS0"}, "text": "         MACRO\n         DEFPGMID    &DUMMY\n         COPY  $MGBLDEF\n         USING &SYSECT,&$BASE(1)   SET UP (1ST) BASE\n         B     $MSKDEF             SKIP AROUND DEFINITION\n         CNOP  0,8                 ALIGN\nPGMID    DC    CL08'&SYSECT ',C'>' DEFINE CSECT NAME\nASMDATE  DC    CL08'&SYSDATE',C'-' GUESS...\nASMTIME  DC    CL05'&SYSTIME',C'<' GUESS...\n$MSAVEAD DC    A(DATAAREA)         FOR CHAINING SAVE AREAS ETC.\nPARMLEN  DC    H'0'                LENGTH OF TEXT\nPARMVAL  DC    8CL24' '            TO SAVE PARM VALUE\nPARMMOVE MVC   PARMLEN(0),0(R1)    MOVE IN PARM LENGTH AND VALUE\n$MSKDEF  DC    0H'0'               FOR SKIP AROUND DEF\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DIAGMSG": {"ttr": 2823, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x994\\x9f\\x00\\x994\\x9f\\x15&\\x00\\x06\\x00\\x06\\x00\\x00\\xc2\\xc3\\xd6\\xc4\\xc8\\xe2\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-15T00:00:00", "modifydate": "1999-12-15T15:26:00", "lines": 6, "newlines": 6, "modlines": 0, "user": "BCODHS0"}, "text": "         MACRO\n         DIAGMSG &MSG              CONDITIONALLY INCL MSG IN ASSEMBLE\n         COPY  $MGBLDEF            BRING IN THE CLOWNS\n         AIF   (&$MBLATH LT 3).MEND BUT ONLY IF REQUESTED\n         DC    0C&MSG              FOR DIAGNOSTIC PURPOSES ONLY\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DISPLAY": {"ttr": 2825, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x98!_\\x00\\x996O\\x10W\\x00L\\x00G\\x00\\x00\\xc2\\xc3\\xd6\\xc4\\xc8\\xe2\\xf0@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1998-08-03T00:00:00", "modifydate": "1999-12-30T10:57:00", "lines": 76, "newlines": 71, "modlines": 0, "user": "BCODHS0"}, "text": "         MACRO\n&N       DISPLAY &DUMMY &NAMED=NO  DISPLAY LIST OF VARIABLES\n         COPY  CPYPAR$E            COPY UNIQUE PAR$E SYMBOLS\n         GBLA  &$CTR               FOR UNIQUE LITERAL NAMES\n         GBLC  &SUBCALL            WHICH TYPE?\n         LCLC  &TEMP,&NAME\n         LCLA  &I,&J,&K,&L\n         LCLB  &NSW                NAMED SWITCH\n&NSW     SETB  (0)                 ASSUME DEFAULT\n.*       AIF   ('&NAMED'(1,1) NE 'Y').SKIP010\n&NSW     SETB  (1)                 LET'S NAME THEM...\n.SKIP010 ANOP                      COME FROM *-2\n&I       SETA  1                   CYCLE THRU POSITIONAL PARAMETERS\n&J       SETA  1                   DISPLACEMENT ON PRINT LINE\n&NAME    SETC  '&N'                USED TO PREVENT DUPLICATE TAGS\n.LOOP100 AIF   ('&SYSLIST(&I)' EQ '').OUTP900 FINISH UP IF ALL DONE\n         AIF   ('&SYSLIST(&I)' NE '/').TEST105 NEW LINE CHARACTER?\n&I       SETA  &I+1                BUMP TO NEXT POSITIONAL PARAMETER\n         AGO   .OUTP900            GO FISH\n.TEST105 AIF   ('&SYSLIST(&I)'(1,2) EQ 'C''').LIT250 GO IF LITERAL\n         AIF   ('&SYSLIST(&I)'(1,1) EQ '(').REG300 GO IF GPR\n         AIF   (T'&SYSLIST(&I) NE 'P').PROC200 FALL THROUGH IF PACKED\n&K       SETA  2*L'&SYSLIST(&I)-1  FIRST GUESS AT OUTPUT LENGTH REQ'D\n&L       SETA  &J+&K               CHECK FOR PRINT LINE OVERFLOW\n         AIF   (&L GT 132).OUTP900 FINISHED IF NO ROOM\n&L       SETA  &K                  CALCULATE # OF OUTPUT BYTES REQ'D\n         AIF   (S'&SYSLIST(&I) EQ 0).TEST110 EXPLICIT DECIMAL POINT?\n&K       SETA  &K+1                YES - ALLOW FOR '.'\n&L       SETA  &L-S'&SYSLIST(&I)   REDUCE REMAINING DIGIT COUNT\n.TEST110 AIF   (&L LT 4).PROC120   GO IF NO MORE COMMAS REQ'D\n&K       SETA  &K+1                ALLOW FOR A COMMA\n&L       SETA  &L-3                REDUCE REMAINING DIGIT COUNT BY 3\n         AGO   .TEST110            . AND LOOP BACK\n.PROC120 ANOP                      ** ALMOST ** READY TO FORMAT NUMBER\n&K       SETA  &K+1                ALLOW FOR POSSIBLE MINUS SIGN\n&K       SETA  &K+&L               CALCULATE TOTAL BYTES REQ'D\n&L       SETA  &J+&K               CALCULATE NEW PRINT LINE SIZE\n         AIF   (&L GT 132).OUTP900 ALL FINISHED IF TOO BIG\n         DC    0C'OPND LENGTH ==> &K OPND ==> &SYSLIST(&I)'\n&NAME    EM    OUTLINE+&J.(&K),&SYSLIST(&I),DB=- FORMAT NUMBER\n         AGO   .INCR400            GO INCREMENT INDEXES\n.PROC200 PAR$E &SYSLIST(&I)        SPLIT INTO COMPONENT PARTS\n&K       SETA  &$PLEN1             STRAIGHTFORWARD BYTE COUNT\n&L       SETA  &J+&K               CHECK LENGTH\n         AIF   (&L GT 132).OUTP900 ALL FINISHED IF PRINT LINE TOO LONG\n&NAME    MVC   OUTLINE+&J.(&K),&$PTAG1&$PEB1 MOVE DATA TO PRINT LINE\n         AGO   .INCR400            GO INCREMENT INDEXES\n.LIT250  $WA                       SET UP DATA AREA\n&TEMP    SETC  '$LT&$CTR'          SET UP TAG FOR 'LITERAL'\n&TEMP    DC    &SYSLIST(&I)        DEFINE LITERAL\n         $IA                       ENTER INSTRUCTION ZONE\n&K       SETA  L'&TEMP             CALCULATE LENGTH OF LITERAL\n&NAME    MVC   OUTLINE+&J.(&K),&TEMP MOVE LITERAL TO PRINT LINE\n&$CTR    SETA  &$CTR+1             CREATE UNIQUE COUNTER FOR NEXT LIT\n         AGO   .INCR400            GO INCREMENT INDEXES\n.REG300  ANOP\n&K       SETA  K'&SYSLIST(&I,1)    CHARS IN REG NAME\n&L       SETA  &J+&K+9\n         AIF   (&L GT 132).OUTP900 GO IF NO ROOM AT THE INN\n&NAME    LR    R1,&SYSLIST(&I,1)   LOAD FIRST (AND ONLY) PARAMETER\n         &SUBCALL CVXWORD          GET (PRINTABLE) HEXADECIMAL\n         MVC   OUTLINE+&J.(&K),=C'&SYSLIST(&I,1)'\n&J       SETA  &J+&K+1             BUMP TO NEXT AVAIL LOC'N\n&K       SETA  0                   CAN'T COUNT IT TWICE...\n         STCM  R0,15,OUTLINE+&J    STORE 1ST 4 HEX CHARACTERS\n         STCM  R1,15,OUTLINE+&J+4  NOW LAST 4\n&J       SETA  &J+8                BUMP TO NEXT AVAIL LOC'N\n.INCR400 ANOP                      INCREMENT INDEXES\n&J       SETA  &J+&K+1             CALC NEW LOCATION ON PRINT LINE\n&I       SETA  &I+1                NEW SUBSCRIPT FOR POSITIONAL PARMS\n&NAME    SETC  ''                  PREVENT DUPLICATE TAGS\n         AGO   .LOOP100            BACK TO CHECK FOR MORE POSITIONALS\n.OUTP900 &SUBCALL PRINTRTN         PRINT THE LINE JUST FORMATTED\n&J       SETA  1                   RESET PRINTLINE LOC'N (JUST IN CASE)\n         AIF   ('&SYSLIST(&I)' NE '').LOOP100 BACK IF MORE TO DO\n         MEND                      GUESS?\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DIVISION": {"ttr": 2828, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x98\\x19_\\x00\\x98\\x19_\\x13\\x03\\x00s\\x00s\\x00\\x00\\xc2\\xc3\\xd6\\xc4\\xc8\\xe2\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1998-07-14T00:00:00", "modifydate": "1998-07-14T13:03:00", "lines": 115, "newlines": 115, "modlines": 0, "user": "BCODHS0"}, "text": "         MACRO\n&TYPE    DIVISION &PROGID=,&INST=,&DATA=,&BASE=,&LINK=,                C\n               &PARMS=YES,&INTRO=YES\n         COPY  $MGBLDEF\n         GBLC  &GSECT,&WSECT       SECTION NAMES\n         GBLC  &NSECT              SECTION NAME\n         GBLC  &GSAVE              SAVE AREA NAME\n         GBLC  &GPROG              SET TO CSECT NAME\n         GBLC  &PARM               INTERNAL USE ONLY\n         GBLC  &GBASE,&GLINK       DEFINE GLOBAL BASE AND LINK REGS\n         GBLC  &GRETN,&GSKIP       FOR SECTION MACRO\n         GBLB  &SEQSW              SEQUENCE SWITCH\n         LCLC  &X                  FOR ENTRY STATEMENT\n         SETCSECT &PROGID\n         SETREGS\n         VERSION 2\n&$GOTOM  SETA  4096\n&$SECTM  SETA  4096\n&X       SETC  '&SYSNDX'           SHORTHAND\n         AIF   ('&TYPE' EQ 'DATA').DATA\n         AIF   ('&TYPE' EQ 'PROCEDURE').DATA\n         AIF   ('&TYPE' EQ 'IDENTIFICATION').DATA\n         MNOTE 8,'INVALID DIVISION &TYPE - MACRO TERMINATED'\n         MEXIT\n.DATA    ANOP\n&PARM    SETC  '&GSECT'\n         SETDEF &INST,GSECT\n&GSECT   SETC  '&PARM'\n&PARM    SETC  '&WSECT'\n         SETDEF &DATA,WSECT\n&WSECT   SETC  '&PARM'\n&PARM    SETC  '&GBASE'\n         SETDEF &BASE,12\n&GBASE   SETC  '&PARM'\n&PARM    SETC  '&GLINK'\n         SETDEF &LINK,14\n&GLINK   SETC  '&PARM'\n&PARM    SETC  '&GPROG'\n         SETDEF &PROGID,MAIN\n&GPROG   SETC  '&PARM'\n         AIF   ('&TYPE' NE 'IDENTIFICATION').NOTID\n         MNOTE *,'SOURCE LIST FOR &PROGID'\n&DCBGEN  SETC  'NOGEN'                 ASSUME...\n         MEXIT\n.NOTID   ANOP\n&NSECT   SETC  '&GSECT'\n         AIF   (D'$REGSAVE).SKIP006 GO IF ALREADY IN CSECT\n&GPROG   CSECT                     BEGINNING OF PROGRAM\n&GSECT   LOCTR                     INSTRUCTIONS COME FIRST, THANK YOU\n&WSECT   LOCTR                     WORKING STORAGE LOCATION COUNTER\n&GSAVE   SETC  '$REGSAVE'          FOR UNIQUENESS\n&GSAVE   DC    18F'0'              REGISTER SAVE AREA\nPARMLEN  DC    H'0'                LENGTH OF PARM FIELD\nPARMVAL  DC    CL253' '            VALUE OF PARM\n         AIF   ('&TYPE' EQ 'DATA').MEND999\n.SKIP006 AIF   ('&TYPE' EQ 'PROCEDURE').PROC\n         AIF   ('&TYPE' NE 'DATA').MEND999\n&WSECT   LOCTR\n         MEXIT\n.PROC    ANOP\n$INTRO   WTO   '&GPROG EXECUTING ON 11/11/11 AT 00.00.00',MF=L,        C\n               ROUTCDE=(11)\n&TEMP    SETA  K'&GPROG\n         ORG   $INTRO+18+&TEMP     LOCATION FOR DATE INFO\n$EXDT    DC    CL8' '\n         ORG   $INTRO+30+&TEMP     LOCATION FOR TIME INFO\n$EXTM    DC    CL8' '\n         ORG   ,\n&GSECT   LOCTR                     BACK TO PROCDIV LOCTR\n         USING &GSECT,&GBASE       SET UP BASE REG\n         STM   14,12,12(13)        SAVE CALLER'S REGS\n         LR    &GBASE,15           LOAD BASE REG\n         XC    16(4,13),16(13)     SET ZERO RETURN CODE\n         L     14,=A(&GSAVE)       SAVE\n         ST    14,8(,13)           . AREA\n         ST    13,4(,14)           . CHAINING\n         LR    13,14               PRIME OUR SAVE POINTER\n         USING &GSAVE,13           SET UP A FREE BASE REG\n         AIF   ('&PARMS' EQ 'NO').SKIP010\n         L     14,0(,1)            POINTER TO PASSED PARAMETERS\n         IF    (LTR,14,14,M),THENDO DO IF ONLY ONE PARM\n             LH    15,0(,14)       LENGTH OF PARAMETER FIELD\n             LA    15,1(,15)       TO COVER LENGTH OF LENGTH\n             EX    15,*+4          MOVE IN PARAMETER\n             MVC   PARMLEN(0),0(14) ** EXECUTE **\n         ENDO  ,\n.SKIP010 ANOP\n&GRETN   SETC  'RETN&X'            UNIQUE TAG FOR EXIT\n         DC    0C'&&GRETN SET TO RETN&X'\n&GSKIP   SETC  'SKIP&X'            UNIQUE TAG FOR END OF SECTION\n         DC    0C'&&GSKIP SET TO SKIP&X'\n         B     STRT&X               . AND B TO SECTION PROPER\n         LTORG ,                   ENSURE ADDRESSABILITY\nRETN&X   L     &GLINK,LINK&X       RESTORE LINK REGISTER\n         B     8(,&GLINK)           AND RETURN\nLINK&X   DC    A(&GSKIP-8)         'EXIT' ADDRESS\n         $ASECT STRT&X             ADD TO THE LIST\nSTRT&X   DC    0H'0'               START OF SECTION\n         AIF   ('&INTRO' EQ 'NO').SKIP030\n         AIF   ('&INTRO' EQ 'YES').NEXT020\n         MNOTE 4,'''&INTRO'' IS AN INVALID VALUE FOR ''INTRO'' - '\n         MNOTE 0,'A VALUE OF ''YES'' IS FORCED'\n.NEXT020 FIRST 1\n           WTO   '&GPROG ASSEMBLED ON &SYSDATE AT &SYSTIME',           C\n               ROUTCDE=(11)\n           TIME  DEC               HEY, JOE, WHAT TIME IS IT?\n           DTM   $EXTM,$EXDT       FORMAT FOR EXECUTING MESSAGE\n           WTO   MF=(E,$INTRO),    SHOW DATE/TIME EXECUTING            C\n               ROUTCDE=(11)\n         ENDO  ,\n         L     1,4(,13)            BACK CHAIN\n         L     1,24(,1)            PREV VALUE FOR 1\n.SKIP030 AIF   (D'R0).MEND999\n         EQUATE\n.MEND999 MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DO": {"ttr": 2831, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x002\\x01\\x013\\x1f\\x01\\x02\\x01\\x7f\\x12\\x17\\x00~\\x00|\\x00\\x00\\xc7\\xc5\\xd5\\xe3\\xd9\\xf0\\xf2@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "2001-11-27T00:00:00", "modifydate": "2002-01-17T12:17:32", "lines": 126, "newlines": 124, "modlines": 0, "user": "GENTR02"}, "text": "         MACRO\n&NAME    DO    &VAR,&WHILE=,&UNTIL=,&TEST=BEFORE\n         COPY  $MGBLDEF            BRING IN THE CLOWNS\n         LCLA  &Y\n         LCLC  &X\n         AIF   ('&TEST' EQ 'BEFORE').TEST10\n         AIF   ('&TEST' EQ 'AFTER').TEST10\n         MNOTE 8,'''TEST=&TEST'' INVALID - ''BEFORE'' ASSUMED'\n.TEST10  AIF   ('&WHILE' NE '').TEST20 GO IF &WHILE SPECIFIED\n         AIF   ('&UNTIL' NE '').TEST22  GO IF &UNTIL SPECIFIED\n         AIF   ('&VAR' NE '').OK30 GO IF &VAR SPECIFIED\n MNOTE 4,'NO ENDING CONDITION SPECIFIED - POSSIBLE UNENDING LOOP'\n         AGO   .OK30               CONTINUE\n.TEST20  AIF   ('&UNTIL' NE '').ERR90 GO IF &UNTIL SPECIFIED\n.TEST22  AIF   ('&VAR' NE '').ERR90 GO IF &VAR SPECIFIED\n         AIF   ('&WHILE' NE '').CONT50\n.OK30    AIF   ('&UNTIL' NE '').CONT60\n&$MDGLVL SETA  &$MDGLVL+1          INCREMENT LEVEL\n&$MDGSEQ(&$MDGLVL) SETC '&SYSNDX'\n&$MIFELS(&$MDGLVL) SETC 'F'\n&$MDGNAM(&$MDGLVL) SETC '&NAME'\n&$MCVERB(&$MDGLVL) SETC 'DO'\n&$MNAME  SETC  '$MDG&SYSNDX'       SET TO SYNTHESIZED NAME\n&$MLTAG(&$MDGLVL) SETC '&$MNAME'   SET LOOP RETURN TAG\n         AIF   ('&VAR' EQ '').CLEAN99 GO IF NO &VAR SPECIFIED\n         AIF   ('&VAR'(1,1) GE '0').SELF40 GO IF SELF-DEFINING\n.*                                 - MUST BE PACKED DECIMAL\n         AIF   ('&VAR' NE 'FOREVER').NEXT32 GO IF NOT FOREVER\n         AIF   ('&NAME' EQ '').SKIP31\n&NAME    DS    0H                  FALL THRU TO BEGINNING OF DO-GROUP\n.SKIP31  ANOP\n&$MNAME  DS    0H                  BEGINNING OF DO-GROUP\n         AGO   .CLEAN99\n.NEXT32  ANOP\n&NAME    PACK  $MDV&SYSNDX,=Z'0'   START WITH 0 THEN ADD 1\n         ZAP   $MDM&SYSNDX,&VAR    PROTECT VARIABLE FROM CHANGE\n         AIF   ('&TEST' NE 'AFTER').SKIP35\n         EX    0,*+8               BUMP BY 1\n         J     $MDD&SYSNDX         EXECUTE GROUP AT LEAST ONE TIME\n.SKIP35  ANOP\n&$MNAME  AP    $MDV&SYSNDX,=P'1'   BUMP BY 1\n&$MNAME  SETC  ''                  SET NAME TO NULL\n&X       SETC  '$MDM&SYSNDX'       NAME FOR CELL FOR END VALUE\n         CP    $MDV&SYSNDX,&X      FINISHED?\n         JH    $MDF&SYSNDX         B IF YES\nDATA     LOCTR                     FOLLOWING CODE TO BE IN WORK AREA\n&Y       SETA  L'&VAR              MAKE SURE OUR VARIABLE IS BIG ENOUGH\n&X       DC    PL(&Y+1)'0'         CELL TO SAVE END VALUE\n&X       SETC  '$MDV&SYSNDX'       MAKE IT PRETTY\n&X       DC    PL(&Y+1)'0'         LOOP COUNTER\n&SYSECT  LOCTR                     RESUME INSTRUCTION AREA\n         AGO   .CLEAN99\n.SELF40  ANOP\n&NAME    PACK  $MDV&SYSNDX,=Z'0'   START WITH 0 THEN ADD 1\n         AIF   ('&TEST' NE 'AFTER').SKIP46\n         EX    0,*+8               BUMP BY 1\n         J     $MDD&SYSNDX         EXECUTE GROUP AT LEAST ONE TIME\n.SKIP46  ANOP\n&$MNAME  AP    $MDV&SYSNDX,=P'1'   BUMP BY 1\n&$MNAME  SETC  ''                  SET NAME TO NULL\n         CP    $MDV&SYSNDX,=P'&VAR' FINISHED?\n         JH    $MDF&SYSNDX         B IF YES\nDATA     LOCTR                     FOLLOWING CODE TO BE IN WORK AREA\n&X       SETC  '$MDV&SYSNDX'       MAKE IT PRETTY\n&X       DC    P'0&VAR'            LOOP COUNTER\n&SYSECT  LOCTR                     RESUME INSTRUCTION AREA\n         AGO   .CLEAN99\n.CONT50  ANOP  &WHILE OPTION WAS SPECIFIED\n&$MNAME  SETC  '&NAME'             SET TO GIVEN NAME\n         AIF   ('&NAME' NE '').CONT52 NO TAG -> NO DC\n&$MNAME  SETC  '$MDG&SYSNDX'       SET TO SYNTHESIZED NAME\n.CONT52  ANOP\n&Y       SETA  &$MDGLVL+1          SET TO NEXT HIGHER\n&$MLTAG(&Y) SETC '&$MNAME'         SET TO LOOP NAME\n         AIF   ('&TEST' NE 'AFTER').SKIP53\n         J     $MDD&SYSNDX         EXECUTE GROUP AT LEAST ONE TIME\n.SKIP53  AIF   ('&WHILE'(2,1) EQ '(').CONT54\n&$MCVERB(&$MDGLVL+1) SETC 'DO'     SHOW PROBABLE CAUSE\n&$MNAME  IF    &WHILE,THENDO       PASS PARMS TO 'IF'\n         AGO   .CLEAN99            WRAP IT UP\n.CONT54  ANOP\n&$MCVERB(&$MDGLVL+1) SETC 'DO'     SHOW PROBABLE CAUSE\n&$MNAME  IF    &WHILE(1),&WHILE(2),&WHILE(3),&WHILE(4),                C\n               &WHILE(5),&WHILE(6),&WHILE(7),&WHILE(8),                C\n               &WHILE(9),&WHILE(10),&WHILE(11),&WHILE(12),             C\n               &WHILE(13),&WHILE(14),&WHILE(15),&WHILE(16),            C\n               &WHILE(17),&WHILE(18),&WHILE(19),&WHILE(20),            C\n               &WHILE(21),&WHILE(22),&WHILE(23),&WHILE(24)\n         AGO   .CLEAN99\n.CONT60  ANOP  &UNTIL OPTION WAS SPECIFIED\n&$MNAME  SETC  '&NAME'             SET TO GIVEN NAME\n         AIF   ('&NAME' NE '').CONT62 NO TAG -> NO DC\n&$MNAME  SETC  '$MDG&SYSNDX'       SET TO SYNTHESIZED NAME\n.CONT62  ANOP\n&Y       SETA  &$MDGLVL+1          SET TO NEXT HIGHER\n&$MLTAG(&Y) SETC '&$MNAME'         SET TO LOOP NAME\n         AIF   ('&TEST' NE 'AFTER').SKIP63\n         J     $MDD&SYSNDX         EXECUTE GROUP AT LEAST ONE TIME\n.SKIP63  AIF   ('&UNTIL'(2,1) EQ '(').CONT64\n&$MCVERB(&$MDGLVL+1) SETC 'DO'     SHOW PROBABLE CAUSE\n&$MNAME  IF    &UNTIL,THENDO       PASS PARMS TO 'IF'\n         J     $MDF&SYSNDX         CONDITION MET - EXIT LOOP\n&X       SETC  '$MDF&$MDGSEQ(&$MDGLVL)' PREV 'FAILED' TAG\n&X       DC    0H'0'               'UNTIL' FAILED - ENTER DO-GROUP\n&$MDGSEQ(&$MDGLVL) SETC '&SYSNDX'  NEW UNIQUE TAG\n         AGO   .CLEAN99            WRAP IT UP\n.CONT64  ANOP\n&$MCVERB(&$MDGLVL+1) SETC 'DO'     SHOW PROBABLE CAUSE\n&$MNAME  IF    &UNTIL(1),&UNTIL(2),&UNTIL(3),&UNTIL(4),                C\n               &UNTIL(5),&UNTIL(6),&UNTIL(7),&UNTIL(8),                C\n               &UNTIL(9),&UNTIL(10),&UNTIL(11),&UNTIL(12),             C\n               &UNTIL(13),&UNTIL(14),&UNTIL(15),&UNTIL(16),            C\n               &UNTIL(17),&UNTIL(18),&UNTIL(19),&UNTIL(20),            C\n               &UNTIL(21),&UNTIL(22),&UNTIL(23),&UNTIL(24)\n         J     $MDF&SYSNDX         CONDITION MET - EXIT LOOP\n&X       SETC  '$MDF&$MDGSEQ(&$MDGLVL)' PREV 'FAILED' TAG\n&X       DC    0H'0'               'UNTIL' FAILED - ENTER DO-GROUP\n&$MDGSEQ(&$MDGLVL) SETC '&SYSNDX'  NEW UNIQUE TAG\n         AGO   .CLEAN99            WRAP IT UP\n.ERR90   MNOTE 12,'MUTUALLY EXCLUSIVE PARAMETERS - MACRO ABORTED'\n         AGO   .MEND\n.CLEAN99 ANOP\n         AIF   ('&TEST' NE 'AFTER').MEND\n&X       SETC  '&SYSNDX'           FOR ALIGNMENT PURPOSES ONLY\n$MDD&X   DC    0H'0'               BEGINNING OF DO-GROUP\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DOCUMENT": {"ttr": 2834, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0c\\x00\\x10\\x01\\x01\"o\\x01\\x02\\x01_\\x10 \\x02V\\x06b\\x00\\x00\\xc7\\xc5\\xd5\\xe3\\xd9\\xf0\\xf2@@@'", "ispf": {"version": "01.12", "flags": 0, "createdate": "2001-08-14T00:00:00", "modifydate": "2002-01-15T10:20:10", "lines": 598, "newlines": 1634, "modlines": 0, "user": "GENTR02"}, "text": "THIS MEMBER IS AN INTRODUCTION TO THE MACRO DEFINITIONS WHICH COMPRISE\nTHE REMAINING MEMBERS OF THIS LIBRARY.  EACH OF THE MACROS HAS BEEN\nTESTED, FOUND TO OPERATE CORRECTLY, AND TO PROVIDE AT LEAST SOME\nMINIMUM AMOUNT OF DESIRABLE FUNCTIONALITY.  IF A PROBLEM CROPS UP,\nEITHER IN YOUR UNDERSTANDING HOW TO USE A PARTICULAR MACRO OR GROUP OF\nMACROS, OR WITH APPARENT PROGRAMMING PROBLEMS WITH THE PACKAGE, PLEASE\nFEEL FREE TO CONTACT THE AUTHOR:\n\n          DAN SNYDER                  614-847-8212\n          COMPUWARE CORP\n          1103 SCHROCK ROAD, STE 205\n          COLUMBUS, OH 43229\n\nTHE FOLLOWING IS A DESCRIPTION OF THE CATEGORIES THAT THESE MACROS HAVE\nBEEN CLASSIFIED INTO:\n\nINTERNAL - THESE MACROS ARE TYPICALLY USED AS COMMON SERVICE ROUTINES\nBY OTHER MACROS WITHIN THIS LIBRARY.  THEY PROVIDE SERVICES THAT WOULD\nNOT NORMALLY BE CALLED FROM OPEN CODE.\n\nSTRUCTURED - MACROS THAT CONTROL THE CONDITIONAL OR REPETITIVE\nEXECUTION OF A GROUP OF INSTRUCTIONS FOLLOWING THE GROUP-INITIATION\nMACRO AND ENDING WITH A GROUP-TERMINATING MACRO.\n\nDIAGNOSTIC - THE 'BEGTEST' AND 'ENDTEST' MACROS ALLOW YOU TO CONDITIONALLY\nINCLUDE OR EXCLUDE SECTIONS OF CODE FROM A PARTICULAR ASSEMBLY.  THE CODE\nCAN CONTINUE TO EXIST IN THE SOURCE MODULE.\n\nGENERAL - THE 'EXECUTE' MACRO ALLOWS THE PROGRAMMER TO CREATE AN 'EX'\nSTATEMENT ON ONE LINE OF CODE.  IT GENERATES A 'LOCTR' STATEMEND NAMED\n'DATA' TO ALLOW THE OUT-OF-LINE GENERATION OF THE 'EX'ECUTED INSTRUCTION.\nTHE NAME OF THE LOCTR AREA CAN BE CHANGED TO LOCAL REQUIREMENTS.\n\nIN EACH OF THE EXAMPLES, IF '<NAME>' IS DISPLAYED IN THE NAME FIELD\nOF A MACRO DEFINITION, THEN THE NAME FIELD IS A SUPPORTED OPTION FOR\nTHAT MACRO.\n\nWHAT FOLLOWS IS A MOSTLY ALPHABETICAL LISTING OF ALL OF THE MACRO\nDEFINITIONS INCLUDED IN THE PACKAGE, WITH ITS IDENTIFYING MACRO TYPE:\n\n$MENDDO1  INTERNAL\n$MENDDO2  INTERNAL\n$MGBLDEF  INTERNAL\n$MGFNAME  INTERNAL\n$MGFNBR   INTERNAL\n$MGPNAME  INTERNAL\nAFTER     STRUCTURED\nBEGTEST   DIAGNOSTIC\nDO        STRUCTURED\nDOEXIT    STRUCTURED\nELSE      STRUCTURED\nELSEDO    STRUCTURED\nELSEIF    STRUCTURED\nENDAFTER  STRUCTURED\nENDELSE   STRUCTURED\nENDEVERY  STRUCTURED\nENDFIRST  STRUCTURED\nENDIF     STRUCTURED\nENDO      STRUCTURED\nENDTEST   DIAGNOSTIC\nEVERY     STRUCTURED\nEXECUTE   GENERAL\nFIRST     STRUCTURED\nIF        STRUCTURED\nTHENDO    STRUCTURED\n\n                            DIAGNOSTIC\n\nTHE MACROS IN THIS GROUP FURNISH VARIOUS AIDS THAT CAN BE USED IN\nDIAGNOSING THE EXECUTION OF A PROGRAM.  THE 'BEGTEST' AND 'ENDTEST'\nMACROS ALLOW MULTIPLE LINES OF CODE TO BE INCLUDED OR EXCLUDED FROM\nAN ASSEMBLY, BASED ON THE VALUE OF A GLOBAL SET SYMBOL.\n\nBEGTEST\nTHIS MACRO HEADS A GROUP OF INSTRUCTIONS THAT ARE CONDITIONALLY\nINCLUDED OR EXCLUDED FROM A PARTICULAR ASSEMBLY. THE GROUP MUST BE\nTERMINATED WITH AN 'ENDTEST' MACRO.  THE 'BEGTEST' REQUIRES ONE\nPOSITIONAL OPERAND.  IF THE OPERAND IS NUMERIC, THEN THAT VALUE IS\nCOMPARED WITH THE GLOBAL TYPE 'A' SET SYMBOL &TESTLVL.  IF THE OPERAND\nIS GREATER THAN &TESTLVL, THEN THE INSTRUCTIONS BETWEEN THE 'BEGTEST'\nAND 'ENDTEST' ARE EXCLUDED FROM THIS ASSEMBLY, OTHERWISE THEY ARE\nINCLUDED:\n\n          GBLA  &TESTLVL\n &TESTLVL SETA  10\n ...\n<NAME>    BEGTEST 5\n          WTO   'HELP'\n<NAME>    ENDTEST ,\n\nIN THIS CASE, THE 'WTO' STATEMENT WILL BE ASSEMBLED.  IF &TESTLVL HAD\nBEEN SET TO 0 (ZERO), THEN THE 'WTO' WOULD HAVE BEEN EXCLUDED FROM\nTHIS ASSEMBLY.\n\nBE VERY CAREFUL ABOUT GIVING A NAME TO THE 'ENDTEST' MACRO.  IF YOU\nCODE A BRANCH INSTRUCTION WITH THAT NAME AS THE OPERAND, AND THAT\n'ENDTEST' INSTRUCTION IS OMITTED FROM THE PROGRAM BECAUSE OF THE VALUE\nOF &TESTLVL, THEN YOU WILL GET AN ASSEMBLY ERROR.  IT WOULD BE SAFE TO\nHAVE A BRANCH TO THAT TAG ONLY WITHIN THE GROUP OF INSTRUCTIONS HEADED\nBY THE 'BEGTEST' MACRO.\n\nIF THE VALUE OF THE POSITIONAL OPERAND OF THE 'BEGTEST' IS 'A', 'B',\n'C', OR 'D', THEN THE LOGIC IS BASED ON THE SETTING OF THE GLOBAL TYPE\n'C' SET SYMBOL &$A, &$B, &$C OR &$D RESPECTIVELY:\n\n          GBLC  &$A\n&$A       SETC  'Y'     ANY OTHER VALUE CAUSES EXCLUSION\n...\n<NAME>    BEGTEST A\n          WTO   'OPT CODE INCLUDED'\n<NAME>    ENDTEST ,\n\nSINCE THE SET SYMBOL &$A WAS SET TO 'Y', THE 'WTO' WILL BE INCLUDED IN\nTHIS ASSEMBLY.  IF &$A HAD BEEN SET TO ANY OTHER VALUE THEN THE CODE\nWOULD NOT BE INCLUDED IN THIS ASSEMBLY.\n\nENDTEST\nTHIS ONE NEEDS TO BE USED ONLY IN CONJUNCTION WITH THE 'BEGTEST'\nMACRO. IT IS USED TO END A GROUP OF CONDITIONALLY INCLUDED LINES OF\nCODE. PLEASE SEE THE DOCUMENTATION FOR 'BEGTEST'.\n\nEXECUTE\nTHIS ONE MAKES IT POSSIBLE TO CONSTRUCT AN 'EX' INSTRUCTION WITH ONE\nLINE OF CODE.  IF YOU'VE NEVER USED THE 'EX' INSTRUCTION, YOU'RE\nPROBABLY BETTER OFF SKIPPING THE REST OF THIS 'EXECUTE' DOCUMENTATION.\nIF YOU HAVE ALREADY USED IT, OR IF YOU'RE VERY BRAVE, THEN HERE GOES.\nIT REQUIRES THREE POSITIONAL OPERANDS. THE FIRST IS A GPR (IT DOESN'T\nHAVE TO BE WITHIN PARENTHESES, SINCE IT HAS TO BE A GPR), THE SECOND\nIS THE OP CODE FOR THE INSTRUCTION BEING 'EX'ECUTED, AND THE THIRD\nCONSISTS OF ALL OF THE OPERANDS OF THE INSTRUCTION BEING 'EX'ECUTED,\nAND THEY MUST BE ENCLOSED WITHIN PARENTHESES.\n\n <NAME>   EXECUTE R15,MVC,(FIELDA(0),FIELDB)\n+<NAME>   EX     R15,$EX1234         GENERATED\n+...\n+$EX1234  MVC   FIELDA(0),FIELDB     GENERATED\n\nNOTE THAT THE THIRD OPERAND IS GENERATED OUT-OF-LINE.\n                            INTERNAL\n\nSINCE MOST OF THESE MACRO DEFINITIONS PROVIDE SERVICES FOR THE OTHER\nMACROS IN THIS PACKAGE, THEY ARE NOT INDIVIDUALLY DOCUMENTED HERE.\n\n                            STRUCTURED\n\nTHIS SET OF MACROS CAUSES A CONDITIONAL AND/OR REPETITIVE EXECUTION OF\nA GROUP OF ONE OR MORE INSTRUCTIONS.  FOR CONVENIENCE, LET'S CALL A\nGROUP OF INSTRUCTIONS THAT MIGHT OR MIGHT NOT BE EXECUTED ONE TIME, OR\nMULTIPLE TIMES, A 'CR-GROUP', FOR 'C'ONDITIONAL/'R'EPETITIVE.\n\nIF\nTHIS IS THE HEART OF THE STRUCTURED MACROS. IT SUPPORTS THE\nCONDITIONAL EXECUTION OF A CR-GROUP BASED ON ONE OR MORE TESTS. EACH\nTEST PHRASE, CONTAINED WITHIN PARENTHESES, MUST CONSIST OF AN OP-CODE,\nA FIRST OPERAND, A SECOND OPERAND, AND A CONDITION. (NOTE OP-CODES\nWITH OTHER THAN TWO OPERANDS ARE SUPPORTED, BUT THE OP-CODE MUST\nALWAYS BE FIRST AND THE CONDITION MUST ALWAYS BE LAST WITHIN THE\nPHRASE.)  FOLLOWING THE LAST PHRASE, THE FINAL POSITIONAL PARAMETER\nMUST BE 'THENDO':\n\n <NAME>   IF    (CLC,FIELDA,FIELDB,E),THENDO\n            ...\n          ENDIF ,\n\nNOTE THAT THE FORMAT OF THE CONDITIONAL PHRASE IS FIXED IN THAT:\n1. THE OP-CODE IS ALWAYS THE FIRST OPERAND\n2. THE CONDITION IS ALWAYS LAST\n3. THE OPERANDS ARE ALWAYS IN THEIR ORDINAL POSITIONS IN BETWEEN\n\nEXAMPLES:\n\n         IF   (UPT,Z),THENDO          INST WITH ZERO OPERANDS\n\n         IF   (SSCH,12,Z),THENDO                ONE OPERAND\n\n         IF   (CLI,LCLSW,C'0',E),THENDO         TWO OPERANDS\n\n         IF   (SRP,PFIELD1,PFIELD2,5,Z),THENDO  THREE OPERANDS\n\nNOTE THAT THE OP-CODE 'CLC' WILL BE USED THROUGHOUT THESE EXAMPLES.\nWHEN YOU CODE YOUR PROGRAM, USE WHATEVER INSTRUCTION IS APPORPRIATE,\nSO LONG AS IT IS ONE THAT SETS THE PROCESSOR'S CONDITION CODE FIELD.\nIT COULD EVEN BE A MACRO STATEMENT, SO LONG AS THE CONDITION CODE\nIS SET BY ONE OF THE INSTRUCTIONS GENERATED BY THE MACRO EXPANSION SO\nTHAT IT CAN BE TESTED BY THE BRANCH-ON-CONDITION THAT FOLLOWS.\n\nIN THIS EXAMPLE, IF FIELDA IS EQUAL TO FIELDB, THEN THE CR-GROUP\nWILL BE EXECUTED.  THE CONDITION, CODED AS THE LAST POSITIONAL\nSUB-PARAMETER, CAN BE ANY OF THE EXTENDED BRANCH NMEMONICS:\n\n  E NE H NH L NL M NM O NO P NP Z NZ\n\nIN THE ABOVE EXAMPLE, THE MACRO EXPANDS INTO:\n\n <NAME>   IF    (CLC,FIELDA,FIELDB,E),THENDO\n+<NAME>   CLC   FIELDA,FIELDB    GENERATED\n+         BNE   $TAG             BRANCH AROUND 'IF' GROUP\n          ...                    YOUR INSTRUCTIONS\n          ENDIF ,\n+$TAG     DS    0H\n\nNOTE: IN THIS SIMPLE EXAMPLE, THE CONDITION 'E' STATES THAT THE IF-GROUP\nIS TO BE EXECUTED IF THE 'CLC' RESULTS IN AN 'EQUAL'.  TO CAUSE THIS\nLOGIC TO OCCUR, A BRANCH ON THE OPPOSITE CONDITION IS CREATED TO BYPASS\nTHE IF-GROUP, MEANING THAT PROGRAM EXECUTION 'FALLS THROUGH' INTO THE\nIF-GROUP WHEN THE SPECIFIED CONDITION IS MET.\n\nLIKEWISE, FOR THE PHRASE '(CLC,FIELDA,FIELDB,NE)', THE BYPASSING BRANCH\nINSTRUCTION GENERATED WOULD BE A 'BE    $TAG'.\n\nNOTE: '$TAG' INDICATES THAT THE MACRO GENERATION PROCESS WILL GENERATE\nAN UNIQUE TAG, WHOSE NAME BEGINS WITH '$', AND ENDS WITH A UNIQUE NUMBER\nOBTAINED FROM A SYSTEM COUNTER.\n\nIF YOU HAD CODED 'NE' AS THE CONDITION, THEN IT WOULD EXPAND TO:\n\n <NAME>   IF    (CLC,FIELDA,FIELDB,NE),THENDO\n+<NAME>   CLC   FIELDA,FIELDB    GENERATED\n+         BE    $TAG             BRANCH AROUND 'IF' GROUP\n          ...                    YOUR INSTRUCTIONS\n          ENDIF ,\n+$TAG     DS    0H\n\n     TO EXECUTE THE CR-GROUP IF EITHER ONE OF TWO CONDITIONS IS\nTRUE, THE FORMAT IS:\n\n <NAME>   IF    (CLC,A,B,NE),OR,(CLC,C,D,NE),THENDO\n\n     ALTERNATE FORMAT:\n                                                               72\n <NAME>   IF    (CLC,A,B,NE),OR,                                C\n           (CLC,C,D,NE),THENDO\n\n     NOTE THAT, AS SHOWN IN THE EXAMPLES, YOU NEED TO ENCLOSE THE\nCONDITIONAL PHRASES WITHIN PARENTHESES, AND THAT YOU DO NOT\nENCLOSE THE CONNECTING PHRASES ('OR' OR 'AND') OR THE FINAL\n'THENDO' WITHIN PARENTHESES.\n\n     SINCE 'AND' TAKES PRECEDENCE OVER 'OR', IN THE FOLLOWING\nEXAMPLE, THE CR-GROUP IS PERFORMED IF THE FIRST TEST IS TRUE, OR\nIF BOTH THE SECOND AND THIRD ARE TRUE:\n\n <NAME>   IF    (CLC,A,B,E),OR,                                 C\n                (CLC,C,D,E),AND,                                C\n                (CLC,E,F,E),THENDO\n\n     IF YOU NEED TO CREATE A SUB-GROUP OF PHRASES CONNECTED BY\n'OR' CONNECTORS, AND THEN CONNECT THIS SUB-GROUP VIA AN 'AND'\nWITH ANOTHER CONDITION (WHICH MAY ITSELF CONSIST OF ANOTHER\nSUB-GROUP OF CONDITIONS), THEN YOU NEED TO ENCLOSE THE ENTIRE\nSUB-GROUP WITHIN AN ADDITIONAL PAIR OF PARENTHESES:\n\n                * <-NESTING PARENTHESES -> *\n <NAME>   IF    ((CLC,A,B,E),OR,(CLC,C,D,E)),AND,               C\n                (CLC,E,F,E),THENDO\n\n     THE AUTHOR OF THESE MACROS PREFERS THE FORMAT:\n\n <NAME>   IF    ((CLC,A,B,E),OR,                                C\n                (CLC,C,D,E)),AND,                               C\n                (CLC,E,F,E),THENDO\n\n     I GUESS THE BOTTOM LINE IS THAT S/390 ASSEMBLER IS SOMEWHAT OF A\nPAIN, NO MATTER HOW YOU FORMAT THE STATEMENTS!\n\n     GROUPS OF EXPRESSIONS MAY BE NESTED AS DEEPLY AS REQUIRED\nTO DEFINE THE LOGIC DESIRED. THE LIMIT IS THAT ANY SINGLE\nPARAMETER IS LIMITED BY THE ASSEMBLER TO 255 CHARACTERS IN LENGTH.\n\n     NOTE THAT THE CONDITIONAL PHRASES ARE EXECUTED IN THE ORDER\nTHAT THEY ARE WRITTEN.  THEREFORE, IF THERE ARE ONE OR MORE PHRASES\nTHAT MORE OFTEN THAN NOT WOULD RESULT IN AN ABBREVIATED PASS THRU THE\nCONSTRUCT, THEN YOU SHOULD CODE THOSE PHRASES FIRST (MAINTAINING THE\nLOGIC REQUIRED FOR THE DESIRED RESULT, OF COURSE!).\n\n     EACH CR-GROUP MUST BE TERMINATED WITH AN 'ENDO' STATEMENT\nOR AN 'ELSE' - 'ENDELSE' COMBINATION:\n\n          ENDIF ,\n                 - OR -\n          ELSE  ,\n     ... ADDITIONAL INSTRUCTIONS TO BE EXECUTED IF 'IF' FAILS\n          ENDELSE ,  (OR ENDIF - EITHER IS ACCEPTABLE AFTER AN 'ELSE')\n\n     ALTERNATIVELY, A CR-GROUP CAN BE TERMINATED AS FOLLOWS:\n\n          ELSEIF  (CLC,G,H,E),THENDO ...\n            ...\n          ELSEIF  (CLC,I,J,E),THENDO ...\n            ...\n          ELSE  ,\n            ...\n          ENDELSE ,\n\n     ANY NUMBER OF 'ELSEIF' STATEMENTS CAN FOLLOW THE ORIGINAL\n     'IF' STATEMENT. THERE MAY BE (BUT NEED NOT BE) ONE AND ONLY\n     ONE 'ELSE' STATEMENT FOLLOWING THE FINAL 'ELSEIF'. THE ENTIRE\n     GROUP IS TERMINATED WITH ONE 'ENDIF' OR 'ENDELSE'.\n\nTHENDO\nTHE SIMPLIST OF THESE IS THE 'THENDO' MACRO THAT MUST BE TERMINATED BY\nAN 'ENDO':\n         CLC   FIELDA,FIELDB\n         THENDO E\n         ...\n         ENDO\n\nTHE STATEMENTS REPRESENTED BY THE '...' WILL BE EXECUTED ONLY IF THE\n'CLC' RESULTED IN AN 'E'. OPTIONALLY YOU MAY CODE AN 'ELSE' STATEMENT,\nAND/OR ONE OR MORE 'ELSEDO' STATEMENTS:\n\n         TRT   FIELDA,TABLE1\n         THENDO L       DO IF NON-ZERO FUNCTION AND NOT LAST ARG\n         ...\n         ELSEDO H       DO IF NON-ZERO FUNCTION AND LAST ARG\n         ...\n         ELSEDO E       DO IF ALL FUNCTION BYTES ZERO\n         ...\n         ENDO\n\nSINCE THE 'TRT' CAN ONLY GENERATE CC'S OF 0, 1, OR 2, THAT LAST\n'ELSEDO E' COULD HAVE BEEN REPLACED BY 'ELSE'.  AT ANY RATE, THIS IS\nA VIABLE WAY TO TEST VALUES OF THE CONDITION CODE THAT ARE SET BY ONE\nINSTRUCTION.  AS YOU WILL SEE WITH THE 'IF' STATEMENT, THE\nINSTRUCTION(S) THAT SET THE CC AND THE TEST FOR THE VALUE OF THE CC\nALL FORM PART OF THE SAME STATEMENT, SO THAT IT IS PROBABLY BETTER\nTO USE THE 'IF' AND 'ELSEIF' WITH INSTRUCTIONS THAT DO NOT MODIFY THEIR\nOPERANDS (SUCH AS 'CLC' OR 'TM' ETC.).\n\nEACH CR-GROUP MUST BE HEADED BY ONE OF THE FOLLOWING MACRO STATEMENTS:\n\n  AFTER      DO     EVERY      FIRST      IF        THENDO\n\nAND MUST BE TERMINATED BY ONE OF THE FOLLOWING:\n\n  ENDAFTER   ENDO   ENDEVERY   ENDFIRST   ENDIF\n\nIT IS SOMEWHAT OVERSIMPLIFYING TO SAY THAT ALL OF THE ENDXXXXX MACROS\nSIMPLY INVOKE 'ENDO', BUT THE TRUTH IS THAT THE INDIVIDUAL ENDXXXXX\nMACROS ARE MORE FOR PROGRAM DOCUMENTATION THAN THEY ARE FOR INTERNAL\nLOGIC DIFFERENCES. SO, IF YOU END AN CR-GROUP WITH AN 'ENDAFTER'\nMACRO, NO DIAGNOSTICS WILL BE ISSUED AND YOUR PROGRAM WILL WORK THE\nSAME AS IF YOU HAD CODED AN 'ENDIF'.\n\nCR-GROUPS MAY BE NESTED TO ANY DESIRED LEVEL:\n\n          IF    ...\n          ...\n            DO    ...\n            ...\n            ENDO  ,\n          ...\n          ENDIF ,\n\nYOU MAY FIND IT EFFECTIVE TO INDENT AT EACH LEVEL OF NESTING, BUT\nBEWARE - THE CONTINUATION COLUMN IS ALWAYS THE SAME (16 IS THE\nDEFAULT).\n\nTHERE ARE TWO ADDITIONAL SIGNIFICANT MACROS THAT CAN BE USED WITHIN\nTHIS PACKAGE OF STRUCTURED PROGRAMMING MACROS.  THE 'ELSEIF' MACRO CAN\nBE USED FOLLOWING AN 'IF' OR ANOTHER 'ELSEIF' MACRO, AND SUPPORTS THE\nSAME TYPES OF LOGIC THAT THE 'IF' MACRO SUPPORTS.  THE 'ELSE' MACRO\nCAN FOLLOW AN 'IF', 'ELSEIF', 'AFTER', 'EVERY' OR 'FIRST' MACRO, AND\nALLOWS ITS CR-GROUP TO BE EXECUTED IF ALL OF THE PRECEDING CR-GROUPS\nWERE NOT EXECUTED.\n\nIN GENERAL, I WOULD SUGGEST THAT YOU NOT CREATE A NAME FIELD FOR A MACRO\nTHAT ENDS A CR-GROUP. IT MIGHT BE PERMISSIBLE IF YOU NEED TO EXIT THE\nCR-GROUP FROM SOMEWHERE DEEP INSIDE IT, BUT AS SOON AS YOU START NAMING\nSTATEMENTS, IT SIGNALS EVEN MORE BAD HABITS TO COME.\n\nAFTER\nTHIS MACRO HEADS A CR-GROUP THAT WILL BE SKIPPED FOR THE FIRST 'N'\nPASSES THROUGH THIS SECTION OF CODE, AND THEN EXECUTED EVERY PASS\nTHROUGH THE CODE FROM THEN ON.  'N' MUST BE A NUMERIC SELF-DEFINING\nTERM.\n\n <NAME>  AFTER 1000000\n            ...\n         ENDAFTER ,\n\nDO\nTHIS ONE PROVIDES REPETITIVE EXECUTION OF A CR-GROUP. THERE ARE\nSEVERAL OPTIONS: THE FIRST IS TO CODE A NUMERIC SELF-DEFINING TERM,\nWHICH CAUSES THE CR-GROUP TO BE EXECUTED THAT NUMBER OF TIMES:\n\n <NAME>   DO    5\n            ...\n          ENDO  ,\n\nA SLIGHT VARIATION IS TO CODE:\n\n <NAME>  DO    FOREVER\n           ...\n         ENDO  ,\n\nTHIS CAUSES THE CR-GROUP TO BE CONTINUOUSLY EXECUTED UNTIL SOMETHING\nEITHER WITHIN THE LOOP OR SOMETHING OUTSIDE THE PROGRAM (TIME\nEXCEEDED, ETC) CAUSES THE LOOP TO BE BROKEN.\n\nIF YOU CODE:\n\n <NAME>  DO    MYVARBL\n           ...\n         ENDO  ,\n\nTHEN 'MYVARBL' MUST BE A PACKED DECIMAL VARIABLE WHICH YOU HAVE\nALREADY INITIALIZED TO THE VALUE FOR THE NUMBER OF TIMES THAT YOU\nWANT THIS CR-GROUP REPEATED. BE VERY CAREFUL ABOUT MODIFYING THIS\nVARIABLE FROM WITHIN THE LOOP. ITS VALUE IS CAPTURED ONLY AT THE\nBEGINNING OF THE EXECUTION OF THE CR-GROUP, AND ANY CHANGE TO THE\nVALUE OF THE VARIABLE WILL TAKE EFFECT THE NEXT TIME THE 'DO'\nSTATEMENT IS ENCOUNTERED.\n\nIF YOU WANT TO REPEAT A CR-GROUP BASED ON ONE OR MORE CONDITIONS,\nTHEN YOU CAN USE EITHER ONE OF THE FOLLOWING:\n\n <NAME>  DO    UNTIL=(...)\n           ...\n         ENDO  ,\n\n         .. OR ..\n\n <NAME>  DO    WHILE=(...)\n           ...\n         ENDO  ,\n\nIN THE FIRST OF THESE TWO EXAMPLES, THE CR-GROUP WILL BE EXECUTED\nREPETITIVELY UNTIL ONE OR MORE OF THE CONDITIONS IS MET. IN THE\nSECOND, IT WILL BE EXECUTED SO LONG AS ONE OR MORE OF THE CONDITIONS\nIS MET.  IN BOTH OF THESE EXAMPLES, THE VALUES WITHIN THE PARENTHESES\nARE THE SAME AS FOR THE 'IF' MACRO. PLEASE SEE ITS DOCUMENTATION FOR\nTHE DETAILS.  THE ONLY DIFFERENCE BETWEEN THE OPERANDS HERE AND FOR\nTHE 'IF' MACRO IS THAT, IF THE CONDITION IS COMPLEX, THAT IS, IF IT\nCONSISTS OF MULTIPLE CONDITIONS CONNECTED WITH 'AND' AND/OR 'OR'\nCLAUSES, THEN THE ENTIRE OPERAND MUST BE ENCLOSED WITHIN ONE\nADDITIONAL LEVEL OF PARENTHESES:\n\n <NAME>   DO    UNTIL=((...),OR,(...))\n                      *              *  <== REQUIRED IF COMPLEX\n            ...\n          ENDO  ,\n\nONE ADDITIONAL KEYWORD OPERAND IS AVAILABLE:\n\n <NAME>   DO    UNTIL=(...),TEST=AFTER\n            ...\n          ENDO  ,\n\n          .. OR ..\n\n <NAME>   DO    WHILE=(...),TEST=AFTER\n            ...\n          ENDO  ,\n\nTHE 'TEST=AFTER' CAUSES THE CR-GROUP TO BE EXECUTED ONE TIME BEFORE\nTHE CONDITIONAL TESTS ARE MADE. DEFAULT IS 'TEST=BEFORE', WHERE THE\nCR-GROUP MIGHT NOT BE EXECUTED EVEN ONCE, DEPENDING ON THE INITIAL\nCONDITIONS.\n\nDOEXIT\nTHE 'DOEXIT' MACRO CAUSES EXECUTION TO TRANSFER TO THE FIRST INSTRUCTION\nFOLLOWING THE 'ENDO' STATEMEMT:\n\n <NAME>   DO    UNTIL=(...)\n            ...\n            DOEXIT ,\n            ...\n          ENDO  ,\n\nIF THERE IS NESTED LOGIC CONSISTING OF 'IF' STATEMENTS AND 'DO'\nSTATEMENTS, A 'DOEXIT' STATEMENT ALWAYS TRANSFERS CONTROL TO THE\nSTATEMENT FOLLOWING THE INNERMOST 'DO' STATEMENT:\n\n<NAME>    DO    UNTIL=(...)\n            ...\n            IF    (...),THENDO\n              ...\n              DOEXIT , TRANSFERS TO STATEMENT FOLLOWING .. |\n              ...                                          |\n              DO    WHILE=(...)                            |\n                ...                                        |\n                DOEXIT , TRANSFERS TO STMT FOLLOWING |     |\n                ...                                  |     |\n              ENDO  ,                 <---------------     |\n              ...                                          |\n            ENDIF ,                                        |\n            ...                                            |\n          ENDO  ,                     <---------------------\nELSE\nTHIS MACRO MAY BE CODED ONLY WITHIN A CR-GROUP HEADED BY AN 'AFTER',\n'ELSEIF', 'EVERY' OR 'FIRST' CR-GROUP HEADER.  IT CAUSES EXECUTION OF\nITS CR-GROUP IF ALL OF THE PREVIOUS CR-GROUPS HAVE BEEN BYPASSED:\n\n <NAME>   AFTER 1000000\n            ...             EXECUTED AFTER 1,000,000 PASSES\n          ELSE  ,\n            ...             EXECUTED FIRST 1,000,000 PASSES\n          ENDELSE ,\n\nELSEIF\nTHIS MACRO MAY FOLLOW ONLY ANOTHER 'ELSEIF' STATEMENT, OR AN 'IF'\nSTATEMENT. IT SUPPORTS ALL THE OPTIONS OF THE 'IF' STATEMENT. PLEASE\nSEE THE 'IF' STATEMENT FOR THE DETAILS.\n\n <NAME>   IF    (...),THENDO\n            ...\n          ELSEIF (...),THENDO\n            ...\n          ENDELSE ,\n\nENDAFTER\nENDELSE\nENDEVERY\nENDFIRST\nENDIF\nENDO\nTHESE MACROS ARE EQUIVALENT, AND SHOULD BE USED TO END THEIR\nRESPECTIVE TYPES OF CR-GROUPS. THE ONE 'INTERESTING' PARAMETER IS THE\n'DOGROUP=' KEYWORD.  IF YOU NAMED A PREVIOUS CR-GROUP HEADER MACRO (SUCH\nAS 'IF' OR 'DO'), AND YOU HAVE NESTED CR-GROUPS, THEN YOU MAY TERMINATE\nMULTIPLE CR-GROUPS WITH ONE 'ENDO' MACRO BY NAMING THE OUTERMOST GROUP\nTHAT YOU WANT TO TERMINATE, AND THEN NAMING THAT GROUP ON THE 'ENDO'\nMACRO:\n\n MAINGRP IF    (...),THENDO\n           ...\n           IF    (...),THENDO\n             ...\n         ENDIF DOGROUP=MAINGRP\n\nIF YOU WANT TO TERMINATE ALL CR-GROUPS, THEN CODE THE 'MAGIC' KEYWORD:\n\n MAINGRP IF    (...),THENDO\n           ...\n           IF    (...),THENDO\n             ...\n         ENDO  DOGROUP=*ALL*\n\nSINCE '*ALL*' IS NOT A VALID ASSEMBLER TAG, IT CAN BE SAFELY USED AS\nTHE FLAG TO INDICATE THAT ALL CURRENT CR-GROUPS ARE TO BE TERMINATED.\n\nEVERY\nTHIS MACRO HEADS A CR-GROUP THAT WILL BE EXECUTED EVERY 'N'TH PASS\nTHROUGH THIS SECTION OF CODE. 'N' MUST BE A NUMERIC SELF-DEFINING TERM.\n\n <NAME>  EVERY 1000000\n            WTO   'ANOTHER 1,000,000 PASSES'\n         ENDEVERY ,\n\nFIRST\nTHIS MACRO HEADS A CR-GROUP THAT WILL BE EXECUTED FOR THE FIRST 'N'\nPASSES THROUGH THIS SECTION OF CODE, AND THEN SKIPPED EVERY PASS\nTHROUGH THE CODE FROM THEN ON.  'N' MUST BE A NUMERIC SELF-DEFINING\nTERM.\n\n <NAME>  FIRST 1000000\n            ...\n         ENDAFTER ,\n\nITS DESIGNED USE IS TO DO STUFF ONLY ON THE FIRST PASS THROUGH A\nSECTION OF CODE\n\n <NAME>  FIRST 1\n           OPEN  (...)\n         ENDFIRST ,\n\nTHENDO\nTHIS WAS THE ORIGINAL STRUCTURED MACRO OF THIS PACKAGE.  IT IS NOT SO\nPOWERFUL AS THE NEWER ONES, BUT YOU MIGHT FIND SOME USE FOR IT. ITS ONLY\nPOSITIONAL PARAMETER MUST BE ONE OF THE CONDITIONS THAT YOU CAN APPEND\nTO THE 'B' TO CREATE ONE OF THE EXTENDED BRANCH INSTRUCTIONS, SUCH AS\n'E'.  PLEASE REFER TO THE DOCUMENTATION FOR THE 'IF' MACRO FOR A\nCOMPLETE LIST.\n\nTHIS MACRO DEPENDS ON A PREVIOUS INSTRUCTION IN THE PROGRAM, SUCH AS A\n'CLR', TO SET THE CONDITION CODE. ITS CR-GROUP WILL THEN BE EXECUTED IF\nTHE OPERAND SATISFIES THE SETTING OF THE CONDITION CODE:\n\n          CLR   R5,R6\n <NAME>   THENDO E\n            ...\n          ENDO  ,\n\n          -- OR --\n\n          CLC   R5,R6\n <NAME>   THENDO E\n            ...\n          ELSE  ,\n            ...\n          ENDO  ,\n\nIN THIS EXAMPLE, THE FIRST CR-GROUP WILL BE EXECUTED IF R5 = R6, AND\nTHE SECOND WILL BE EXECUTED IF THEY ARE UNEQUAL.\n\nTHAT'S IT, FOLKS. NO OTHER OPTIONS FOR 'THENDO' (OTHER THAN NESTING).\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DOEXIT": {"ttr": 3082, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\x01\\x7f\\x01\\x02\\x01\\x7f\\x10\\x17\\x00\\x0e\\x00\\x0e\\x00\\x00\\xc7\\xc5\\xd5\\xe3\\xd9\\xf0\\xf2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-01-17T00:00:00", "modifydate": "2002-01-17T10:17:00", "lines": 14, "newlines": 14, "modlines": 0, "user": "GENTR02"}, "text": "         MACRO\n&NAME    DOEXIT &DUMMY             XFER OUT OF INNERMOST DO-GROUP\n         COPY  $MGBLDEF            BRING IN THE CLOWNS\n         LCLA  &I                  LOCAL INTEGER VARIABLE\n&I       SETA  &$MDGLVL            START AT CURRENT NESTING LEVEL\n.LOOP010 AIF   (&I GT 0).CONT020   CONTINUE IF NOT ALL DONE\n         MNOTE 8,'NO DO-GROUP TO EXIT FROM' OOPS...\n         AGO   .MEND               ALL WAS FOR NAUGHT\n.CONT020 AIF   ('&$MCVERB(&I)' EQ 'DO').GEN030 IS THIS LEVEL A 'DO'?\n&I       SETA  &I-1                NO - BACK UP TO NEXT OUTER LEVEL\n         AGO   .LOOP010            PROCESS NEXT OUTER GROUP\n.GEN030  ANOP  ,                   DANG, GOT A LIVE ONE!\n&NAME    J     $MDF&$MDGSEQ(&I)    B TO INSTRUCTION FOLLOWING 'ENDO'\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DTEOFINT": {"ttr": 3084, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x002\\x01\\x01&O\\x01\\x02\\x00/\\x15I\\x00\\xac\\x00\\xac\\x00\\x00\\xc7\\xc5\\xd5\\xe3\\xd9\\xf0\\xf2@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2001-09-21T00:00:00", "modifydate": "2002-01-02T15:49:32", "lines": 172, "newlines": 172, "modlines": 0, "user": "GENTR02"}, "text": "DTEOFINT TITLE 'COMPUTE YYYYMMDD FROM DAY COUNT SINCE 01/01/1601'\n*\n* IF ROUTINE 'DTEOFINT' IS CALLED, THEN:\n* THE 'YYYYMMDD' CALCULATED BY THIS SUBROUTINE WILL MATCH THE\n* DATE PROVIDED BY THE COBOL FUNCTION 'DATE-OF-INTEGER'\n*\n* IF ROUTINE 'DAYOFINT' IS CALLED, THEN:\n* THE 'YYYYDDD' CALCULATED BY THIS SUBROUTINE WILL MATCH THE\n* DATE PROVIDED BY THE COBOL FUNCTION 'DAY-OF-INTEGER'\n*\n* CALLER MUST PASS: (IF DTEOFINT IS CALLED)\n* DAY_COUNT    DC     ZL8'00123456' PROVIDED BY CALLER\n* GREGDATE     DC     CL8'YYYYMMDD' SET BY THIS ROUTINE\n*\n* CALLER MUST PASS: (IF DAYOFINT IS CALLED)\n* DAY_COUNT    DC     ZL8'00123456' PROVIDED BY CALLER\n* JULDATE      DC     CL7'YYYYDDD' SET BY THIS ROUTINE\n* *                        END OF USER PROVIDED PARAMETERS\n*\n         PRINT NOGEN\n*\nDTEOFINT CSECT ,                   ENTRY FOR GREGORIAN PROCESSING\n         USING *,R15               INFORM ASSEMBLER\n         MVI   DATETYPE,C'G'       SET 'G'REGORIAN\n         B     CONTINUE            SKIP AROUNT MARKERS\nDAYOFINT DS    0H                  ENTRY FOR JULIAN PROCESSING\n         ENTRY DAYOFINT\n         USING *,R15               INFORM ASSEMBLER\n         MVI   DATETYPE,C'J'       SET 'J'ULIAN\n         B     CONTINUE            SKIP AROUNT MARKERS\n         DROP  R15                 FORGET IT\n         DC    C'********        '\n         DC    C'DTEOFINT ASSEMBLED ON '\n         DC    C'&SYSDATE AT &SYSTIME'\n         DC    C'        ********'\nCONTINUE DS    0H\n         STM   R14,R12,12(R13)     SAVE REGS\n         BASR  R12,0               COMMON BASE\n         USING *,R12               MAKE USEABLE\n         SLR   R15,R15             ASSUME R/C ZERO\n         ST    R15,16(,R13)        STUFF R/C BACK INTO SAVEAREA\n         LA    R14,SAVEAREA        POINT TO MY SAVE AREA\n         ST    R14,8(,R13)         FORWARD CHAIN\n         ST    R13,4(,R14)         BACK CHAIN\n         LR    R13,R14             SET UP MY SAVEAREA\n         LM    R10,R11,0(R1)       PASSED PARAMETERS\n         USING DAYCOUNT,R10        MAKE IT ADDRESSABLE\n         USING YYYYMMDD,R11        MAKE IT ADDRESSABLE\n         MVC   YYYYMMDD,=C'        ' SPACEOUT\n         MVC   TESTAREA,DAYCOUNT   COPY\n         TR    TESTAREA,VALIDTBL   CHECK EACH DIGIT FOR NUMERIC\n         IF    (CLC,TESTAREA,DAYCOUNT,NE),OR, IF NOT NUMERIC - OR -    X\n               (CLC,DAYCOUNT,=C'03067671',H),THENDO GT 12/31/9999 THEN\n           UNPK  YYYYMMDD,=X'0F'   SET CALLER AREA TO ZEROS\n           B     RETURN            . AND RETURN\n         ENDIF ,                   END OF INVALID DATE PROCESSING\n         MVI   ISITLEAP,C' '       SET 'NULL' TO START\n         PACK  DIVIDEND,DAYCOUNT   GET READY FOR DIVINE (SIC)\n         SP    DIVIDEND,=P'1'      GET OFFSET # OF DAYS\n         DP    DIVIDEND,=PL5'146097' # OF DAYS IN 400 YEARS\n         MVC   DV146097(10),QUOTIENT SAVE QUOTIENT AND REMAINDER\n         IF    (CP,RM146097,=P'145730',H),THENDO # OF DAYS IN 399 YEARS\n           MVI   ISITLEAP,C'L'     IT'S THE 400TH YEAR\n         ENDIF ,\n* IF THIS IS THE LAST DAY OF THE 400TH YEAR OF THE GROUP, THEN IT IS\n* 12/31/2000 OR 12/31/2400 ETC (WHICH ** IS ** A LEAP YEAR) AND WE\n* MUST OVERRIDE THE QUOTIENT (4) AND REMAINDER (0) THAT WOULD HAVE\n* BEEN CALCULATED IN THE NEXT STEP:\n         IF    (CP,RM146097,=P'146096',E),THENDO DAYS IN 400 YEARS - 1\n           PACK  DV036524,=Z'3'      FORCE # OF CENTURIES\n           PACK  RM036524,=Z'36524'  . AND REMAINING DAYS\n         ELSE  ,\n           ZAP   DIVIDEND,RM146097  CALC YEAR AND DAY COUNTS\n           DP    DIVIDEND,=PL5'036524' # OF DAYS IN 100 YEARS\n           MVC   DV036524(10),QUOTIENT SAVE ANSWERS\n         ENDIF ,\n         IF    (CLI,ISITLEAP,C' ',E),AND, IF NOT YET SET *AND*         X\n               (CP,RM036524,=P'36158',H),THENDO AT LEAST 99 YEARS THEN\n           MVI   ISITLEAP,C'S'     IT'S 100TH BUT NOT 400TH\n         ENDIF ,\n         ZAP   DIVIDEND,RM036524   HANDLE 4-YEAR TYPE LEAP YEARS\n         DP    DIVIDEND,=PL5'001461' # OF DAYS IN 4 YEARS\n         MVC   DV001461(10),QUOTIENT  SAVE ANSWERS\n         IF    (CLI,ISITLEAP,C' ',E),THENDO IF NOT YET SET THEN\n           IF    (CP,RM001461,=P'1094',H),THENDO # OF DAYS IN 3 YEARS\n             MVI   ISITLEAP,C'L'   IT'S 4TH BUT NOT 100TH OR 400TH\n           ELSE  ,\n             MVI   ISITLEAP,C'S'   OK ALREADY - SO ITS NOT A LEAP YEAR\n           ENDIF ,\n         ENDIF ,\n* IF THIS IS THE LAST DAY OF THE 4TH YEAR OF THE GROUP, THEN IT IS\n* 12/31/1992 OR 12/31/1996 ETC (WHICH ** IS ** A LEAP YEAR) AND WE\n* MUST OVERRIDE THE QUOTIENT (4) AND REMAINDER (0) THAT WOULD HAVE\n* BEEN CALCULATED IN THE NEXT STEP:\n         IF    (CP,RM001461,=P'1460',E),THENDO # OF DAYS IN 4 YEARS - 1\n           PACK  DV000365,=Z'3'    FORCE YEAR # 4 (RANGE IS 0 - 3)\n           PACK  RM000365,=Z'365'  . AND DAY # 365\n         ELSE  ,                   NOT LAST DAY OF RANGE\n           ZAP   DIVIDEND,RM001461 FIND YEAR #\n           DP    DIVIDEND,=PL5'365'  . AND DAY #\n           MVC   DV000365(10),QUOTIENT SAVE ANSWERS\n         ENDIF ,\n         AP    RM000365,=P'1'      GET BACK TO 'REAL' DATE\n* CALCULATE NUMBER OF YEARS SINCE 1601\n         MP    DV146097,=P'400'    # OF YEARS IN 400-YEAR GROUPT\n         MVC   QUOTIENT,DV146097   COPY # OF 400-YEAR GROUPS\n         MP    DV036524,=P'100'    # OF 100-YEAR GROUPS (0 - 3)\n         AP    QUOTIENT,DV036524   ADD IT IN\n         MP    DV001461,=P'4'      # OF 4-YEAR GROUPS (0 - 24)\n         AP    QUOTIENT,DV001461   ADD IT IN\n         AP    QUOTIENT,DV000365   ADD # OF YEARS (RANGE IS 0 - 3)\n         AP    QUOTIENT,=P'1601'   GET YYYY\n         UNPK  YYYYMMDD(4),QUOTIENT SMASH INTO OUTPUT FIELD\n         OI    YYYYMMDD+3,C'0'     FIX SIGN POSITION\n         IF    (CLI,DATETYPE,C'J',NE),THENDO IF NOT 'J'ULIAN THEN...\n           IF    (CLI,ISITLEAP,C'L',E),THENDO IF 'IS' LEAP THEN...\n             PACK  MONTHTBL+2(2),=Z'29' FIX FEBRUARY\n           ELSE  ,                 ELSE IF 'NOT' LEAP THEN...\n             PACK  MONTHTBL+2(2),=Z'28' FIX FEBRUARY\n           ENDIF ,\n           LA    R2,MONTHTBL       POINT TO TABLE\n* BUMP THROUGH DAYS-OF-MONTH TABLE, SUBTRACTING AS WE GO, UNTIL\n* THERE ARE FEWER DAYS LEFT THAN ARE IN 'THIS' MONTH\n           PACK  MONTH,=Z'1'       RUNNING COUNTER\n           DO    UNTIL=(CP,RM000365,0(2,R2),NH) BUMP THRU TABLE\n             SP    RM000365,0(2,R2) SUB DAYS IN 'THIS' MONTH\n             LA    R2,2(,R2)       INCREMENT\n             AP    MONTH,=P'1'     COUNT MONTH\n           ENDO  ,\n           UNPK  YYYYMMDD+4(2),MONTH SMASH MONTH INTO OUTPUT FIELD\n           OI    YYYYMMDD+5,C'0'   FIX SIGN\n           UNPK  YYYYMMDD+6(2),RM000365 SMASH DAY\n           OI    YYYYMMDD+7,C'0'   FIX SIGN\n         ELSE  ,\n           UNPK  YYYYMMDD+4(3),RM000365 FORMAT JULIAN DATE\n           OI    YYYYMMDD+6,C'0'        . AND FIX SIGN\n         ENDIF ,\nRETURN   DS    0H                  PROVIDE STD RETURN LINKAGE\n         L     R13,4(,R13)         BACK CHAIN\n         LM    R14,R12,12(R13)     RESTORE REGS\n         DROP  R12                 NEGATE ADDRESSABILITY\n         BR    R14                 RETURN\nSAVEAREA DC    18F'0'              STD REG SAVE AREA\nMONTHTBL DC    PL2'31,28,31,30,31,30,31,31,30,31,30,31'\nDV000365 DC    PL5'0'\nRM000365 DC    PL5'0'\nDV001461 DC    PL5'0'\nRM001461 DC    PL5'0'\nDV036524 DC    PL5'0'\nRM036524 DC    PL5'0'\nDV146097 DC    PL5'0'\nRM146097 DC    PL5'0'\nISITLEAP DC    C' '                LOGIC SETS TO 'L' OR 'S'\nDATETYPE DC    C' '                LOGIC SETS TO 'G' OR 'J'\n*\nDIVIDEND DC    0PL10'0' TOTAL DIVIDEND AREA -->|\\\nQUOTIENT EQU   DIVIDEND+0,5,C'P'            -->| > KEEP TOGETHER\nREMAINDER EQU  DIVIDEND+5,5,C'P'            -->|/\n*\nMONTH    DC    PL2'0'\nTESTAREA DC    CL8' '\nVALIDTBL DC    256AL1(0)           NUMERIC TEST TABLE\n         ORG   VALIDTBL+C'0'\n         DC    C'0123456789'\n         ORG   ,\nDSECTA   DSECT                     MAPPING DSECT\nDAYCOUNT DS    CL8                 USER-PROVIDED DAY COUNT\nDSECTB   DSECT                     MAPPING DSECT\nYYYYMMDD DS    CL8                 COMPUTED FOR CALLER\nDTEOFINT CSECT\n         EQUATE ,                  REGISTER EQUATES\n         END   ,                   REQUIRED END STATEMENT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DTM": {"ttr": 3332, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00\\x00o\\x01\\x00\\x00o\\x18S\\x00B\\x00B\\x00\\x00\\xc2\\xc3\\xd6\\xc4\\xc8\\xe2\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-01-06T00:00:00", "modifydate": "2000-01-06T18:53:00", "lines": 66, "newlines": 66, "modlines": 0, "user": "BCODHS0"}, "text": "         MACRO\n&NAME    DTM   &TIME,&DATE        ** ANOTHER ** DATE/TIME MACRO\n         GBLC  &GSECT,&WSECT      SECTION NAMES\n&NAME    STM   R0,R4,$DTMSAVE     SAVE WORK REGS\n         AIF   ('&TIME' EQ 'DUMMY').SKIP1 TIME IS OPTIONAL\n         ST    R0,$DTMWFWD        COPY TIME\n         MVO   $DTMWPL4,$DTMWFWD(3) DROP FRACTION, AND GET GET A SIGN\n         MVC   $DTMWCLA,=X'402120204B20204B2020' TIME MASK\n         ED    $DTMWCLA,$DTMWPL4  PRINTABLE\n         MVC   &TIME,$DTMWCLA+2   INTO RECORD AREA\n.SKIP1   AIF   ('&DATE' EQ 'DUMMY').SKIP2 SO IS DATE\n         ST    R1,$DTMWFWD        DATE\n         MVO   $DTMWPL4,$DTMWFWD+1(1) SHIFT PAST SIGN\n         MVC   $DTMBLDD+2(1),$DTMWFWD+1 ISOLATE YEAR\n         CVB   R1,$DTMDBL         BINARY\n         LR    R3,R1              COPY\n         SRL   R1,2               DIV BY 4\n         SLL   R1,2               MULT BY 4\n         IF    (CLR,R3,R1,E),THENDO IF = THEN LEAP YEAR\n           LA    R2,$DTMLMON      POINT TO LEAP\n           LA    R4,$DTMLADJ      . TABLES\n         ELSE ,\n           LA    R2,$DTMSMON      ELSE POINT TO STD\n           LA    R4,$DTMSADJ      . TABLES\n         ENDELSE ,\n         ZAP   $DTMWPL4,$DTMWFWD+2(2) DAY OF YEAR INTO WORK\n         CVB   R1,$DTMDBL          BINARY\n         LR    R0,R1               COPY\n         BCTR  R1,0                SET TO RANGE 0 - 364\n         IC    R3,0(R1,R2)         GET MONTH FOR THIS DAY\n         CVD   R3,$DTMDBL          DECIMAL\n         MVO   $DTMWXL2,$DTMDBL+6(2) ISOLATE MONTH\n         MVC   $DTMBLDD(1),$DTMWXL2 $DTMBLDD IS NOW MMXXYY\n         BCTR  R3,0                SET TO RANGE 0 - 11\n         LR    R1,R3               COPY\n         SLL   R3,1                DOUBLE FOR ADJ FACTOR\n         MH    R1,=H'30'           APPROX DAY# FOR 1ST OF MONTH\n         AH    R1,0(R3,R4)         EXACT DAY# FOR 1ST OF MONTH\n         SR    R0,R1               GET DAY OF MONTH\n         CVD   R0,$DTMDBL          DECIMAL\n         MVO   $DTMWXL2,$DTMDBL+6(2) ISOLATE DAY\n         MVC   $DTMBLDD+1(1),$DTMWXL2 $DTMBLDD IS NOW MMDDYY\n         MVC   $DTMWCLA,=X'40212020612020612020' MAKE IT PRETTY\n         MVO   $DTMWPL4,$DTMBLDD   SHIFT OVER PAST SIGN\n         ED    $DTMWCLA,$DTMWPL4   DO THE EDIT\n         MVC   &DATE,$DTMWCLA+2    INTO RECORD AREA\n.SKIP2   LM    R0,R4,$DTMSAVE      RESTORE WORK REGS\n         AIF   (D'$DTMSAVE).MEND   SKIP IF NOT FIRST TIME\n         $WA\n$DTMSAVE DC    5F'0'               FOR REGS 0 - 4\n$DTMDBL  DC    0D'0',F'0'          ALIGNMENT AND FIRST WORD FOR CVB/CVD\n$DTMWPL4 DC    PL4'0'              SECOND WORD FOR CVB/CVD\n$DTMWFWD DC    F'0'                WORK AREA FULLWORD\n$DTMWXL2 DC    XL2'0000'           WORK AREA HEX LENGTH 2\n$DTMWCLA DC    CL10' '             WORK AREA CHAR LENGTH 10\n$DTMBLDD DC    XL3'00'             BUILD AREA FOR DATE\n$DTMSMON DC    31AL1(1),28AL1(2),31AL1(3),30AL1(4)    MONTH ID\n         DC    31AL1(5),30AL1(6),31AL1(7),31AL1(8)    . FOR EACH\n         DC    30AL1(9),31AL1(10),30AL1(11),31AL1(12) . DAY\n$DTMSADJ DC    0H'0',AL2(0,1,65535,0,0,1,1,2,3,3,4,4) ADJUSTMENT\n$DTMLMON DC    31AL1(1),29AL1(2),31AL1(3),30AL1(4)    MONTH ID\n         DC    31AL1(5),30AL1(6),31AL1(7),31AL1(8)    . FOR LEAP\n         DC    30AL1(9),31AL1(10),30AL1(11),31AL1(12) . YEAR DAYS\n$DTMLADJ DC    0H'0',AL2(0,1,0,1,1,2,2,3,4,4,5,5)     ADJUSTMENT (LEAP)\n         $IA\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DUMPMAIN": {"ttr": 3334, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00\\x00o\\x01\\x00\\x00o\\x18S\\x00\\x19\\x00\\x19\\x00\\x00\\xc2\\xc3\\xd6\\xc4\\xc8\\xe2\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-01-06T00:00:00", "modifydate": "2000-01-06T18:53:00", "lines": 25, "newlines": 25, "modlines": 0, "user": "BCODHS0"}, "text": "         MACRO\n&NAME    DUMPMAIN &OPNDS\n         LCLA  &A,&B,&C\n         LCLC  &X,&Y\n&A       SETA  N'&SYSLIST\n         AIF   (&A EQ 2*(&A/2)).OK10\n         MNOTE 8,'OPERANDS NOT PAIRED - MACRO GENERATION TERMINATED'\n         MEXIT\n.OK10    ANOP\n         CNOP  0,4                 ALIGNMENT FOR ADDRESS CONSTANTS\n&NAME    STM   &R0,&R15,*+8        SAVE REGS AS-IS\n         BAS   &R1,*+72+&A*4       R1 WILL ADDRESS SAVE AREA\n         DC    16A(0)              SAVE ALL 16\n         DC    AL1(&A),AL3(0)      NUMBER OF OPERANDS\n&B       SETA  1                   LET'S START AT THE BEGINNING\n.LOOP20  ANOP\n&C       SETA  &B+1\n         DC    A(&SYSLIST(&B),&SYSLIST(&C))\n&B       SETA  &B+2\n         AIF   (&B LT &A).LOOP20\n         DC    V(DUMPREGS)         ADDRESS OF SUBROUTINE\n         L     &R15,*-4            COPY ADDRESS OF SUBROUTINE\n         BASR  &R14,&R15           TRANSFER TO SUBROUTINE\n         LM    0,15,*-78-&A*4      RESTORE REGS TO PRISTINE\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "EDIT": {"ttr": 3336, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00\\x00o\\x01\\x00\\x00o\\x18S\\x00?\\x00?\\x00\\x00\\xc2\\xc3\\xd6\\xc4\\xc8\\xe2\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-01-06T00:00:00", "modifydate": "2000-01-06T18:53:00", "lines": 63, "newlines": 63, "modlines": 0, "user": "BCODHS0"}, "text": "         MACRO\n&NAME    EDIT  &FIELD,&DOIF=FAIL\n         COPY  $MGBLDEF\n         LCLC  &X,&Y\n         AIF   ('&DOIF' EQ 'FAIL' OR '&DOIF' EQ 'PASS').DOIFOK\n         MNOTE 12,'''&DOIF'' INVALID - MACRO ABORTED'\n         AIF   ('&NAME' EQ '').MEND\n&NAME    DC    0H'0'               DEFINE TAG\n         MEXIT\n.DOIFOK  ANOP\n&$MDGLVL SETA  &$MDGLVL+1          UP DO-GROUP LEVEL\n&$MDGSEQ(&$MDGLVL) SETC '&SYSNDX'  SET DO-GROUP SEQUENCE\n&$MDGNAM(&$MDGLVL) SETC '&NAME'    SET DO-GROUP NAME\n&$MIFELS(&$MDGLVL) SETC 'F'\n&X       SETC  '&SYSNDX'           SHORTHAND\n&Y       SETC  '$MDF&$MDGSEQ(&$MDGLVL)' SHORTHAND\n         AIF   ('&NAME' NE '').SKIP07\n&$MDGNAM(&$MDGLVL) SETC '$MDG&$MDGSEQ(&$MDGLVL)'\n.SKIP07  AIF   ('&DOIF' EQ 'PASS').DOPASS GO IF PASS SPECIFIED\n&NAME    ST    R2,$MEDRSV          SAVE R2 (OK TO DESTROY R1?)\n         TRT   &FIELD.(L'&FIELD-1),$EDITTB1 ALL BUT LOW ORDER\n         L     R2,$MEDRSV          RESTORE R2 - CC IS UNCHANGED\n         BC    6,$MDP&X            EXECUTE DO-GROUP IF FAILED\n         TRT   &FIELD-1+L'&FIELD.(1),$EDITTB2 LOOK AT LOW ORDER\n         L     R2,$MEDRSV          RESTORE R2 - CC IS UNCHANGED\n         BC    8,&Y                SKIP DO-GROUP IF PASS\n$MDP&X   DC    0H'0'               START PROCESSING DO-GROUP\n         AGO   .TEST30\n.DOPASS  ANOP                      EXECUTE DO-GROUP IF PASS\n&NAME    ST    R2,$MEDRSV          SAVE R2 (OK TO DESTROY R1?)\n         TRT   &FIELD.(L'&FIELD-1),$EDITTB1 ALL BUT LOW ORDER\n         L     R2,$MEDRSV          RESTORE R2 - CC IS UNCHANGED\n         BC    6,&Y                SKIP DO-GROUP IF FAIL\n         TRT   &FIELD-1+L'&FIELD.(1),$EDITTB2 LOOK AT LOW ORDER\n         L     R2,$MEDRSV          RESTORE R2 - CC IS UNCHANGED\n         BC    2,&Y                SKIP DO-GROUP IF FAIL\n.TEST30  AIF   (D'$MEDRSV).MEND\n         $WA\n$MEDRSV  DC    F'0'\n$EDITTB1 DC    X'000000000000000000000A0B0C0D0E0F'\n         DC    X'000000000000000000001A1B1C1D1E1F'\n         DC    X'000000000000000000002A2B2C2D2E2F'\n         DC    X'000000000000000000003A3B3C3D3E3F'\n         DC    X'000000000000000000004A4B4C4D4E4F'\n         DC    X'000000000000000000005A5B5C5D5E5F'\n         DC    X'000000000000000000006A6B6C6D6E6F'\n         DC    X'000000000000000000007A7B7C7D7E7F'\n         DC    X'000000000000000000008A8B8C8D8E8F'\n         DC    X'000000000000000000009A9B9C9D9E9F'\n         DC    96AL1(*-$EDITTB1)\n$EDITTB2 DC    X'010102030405060708090A0B00000E00'\n         DC    X'101112131415161718191A1B00001E00'\n         DC    X'202122232425262728292A2B00002E00'\n         DC    X'303132333435363738393A3B00003E00'\n         DC    X'404142434445464748494A4B00004E00'\n         DC    X'505152535455565758595A5B00005E00'\n         DC    X'606162636465666768696A6B00006E00'\n         DC    X'707172737475767778797A7B00007E00'\n         DC    X'808182838485868788898A8B00008E00'\n         DC    X'909192939495969798999A9B00009E00'\n         DC    96AL1(*-$EDITTB2)\n         $IA\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ELSE": {"ttr": 3338, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\x01\\x7f\\x01\\x02\\x01\\x7f\\x10\\x17\\x00\\x1b\\x00\\x1b\\x00\\x00\\xc7\\xc5\\xd5\\xe3\\xd9\\xf0\\xf2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-01-17T00:00:00", "modifydate": "2002-01-17T10:17:00", "lines": 27, "newlines": 27, "modlines": 0, "user": "GENTR02"}, "text": "         MACRO\n&NAME    ELSE  &DOGROUP=,&MNAME=ELSE  END OF POSITIVE TEST, START OF\n         COPY  $MGBLDEF            . NEGATIVE\n         LCLC  &X                  SET TO 'IF-FAILED' TAG\n         AIF   (&$MDGLVL GT 0).OK02\n         MNOTE 8,'''&MNAME'' IS VALID ONLY WITHIN AN IF-GROUP'\n         MNOTE 0,' - MACRO GENERATION TERMINATED'\n         MEXIT\n.OK02    $MENDDO1 DOGROUP=&DOGROUP\n         AIF   (&$MDGERR NE 0).QUIT GIVE UP IF ERROR\n         AIF  ('&$MLTAG(&$MDGLVL)' EQ '').SKIP30\n         MNOTE 8,'''&MNAME'' INVALID FOR ''DO'' - ENDO ASSUMED'\n         $MENDDO2 ,                PRETEND NO 'ELSEDO'\n         MEXIT\n.SKIP30  AIF   ('&$MIFELS(&$MDGLVL)' NE 'S').SKIP40\n         MNOTE 8,'''&MNAME'' INVALID FOLLOWING ''&MNAME'' -'\n         MNOTE '''ENDO'' INVOKED'\n         $MENDDO2                 JUST LIKE NO 'ELSEDO'\n         MEXIT\n.SKIP40  J     $MDS&$MDGSEQ(&$MDGLVL) BRANCH AROUND ELSE-GROUP\n&X       SETC  '$MDF&$MDGSEQ(&$MDGLVL)' 'IF-FAILED' TAG\n         AIF   ('&NAME' EQ '').SKIP50\n&NAME    DC    0H'0'              DEFINE TAG\n.SKIP50  ANOP\n&X       DC    0H'0'              TAG FOR 'IF' FAILURE\n&$MIFELS(&$MDGLVL) SETC 'S'       SET FOR 'ENDELSE'\n.QUIT    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ELSEDO": {"ttr": 3340, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\x01\\x7f\\x01\\x02\\x01\\x7f\\x10\\x17\\x00\\x1e\\x00\\x1e\\x00\\x00\\xc7\\xc5\\xd5\\xe3\\xd9\\xf0\\xf2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-01-17T00:00:00", "modifydate": "2002-01-17T10:17:00", "lines": 30, "newlines": 30, "modlines": 0, "user": "GENTR02"}, "text": "         MACRO\n&NAME    ELSEDO &COND\n         COPY  $MGBLDEF\n         LCLC  &X\n         AIF   (&$MDGLVL GT 0).OK02\n         MNOTE 8,'''ELSEDO'' IS VALID ONLY WITHIN A THENDO-GROUP'\n         MNOTE 0,' - MACRO GENERATION TERMINATED'\n         MEXIT\n.OK02    AIF   ('&$MIFELS(&$MDGLVL)' EQ 'F').OK04\n         MNOTE 8,'''ELSEDO'' INVALID FOLLOWING ''ELSE'' STATEMENT'\n         MNOTE 0,' - MACRO GENERATION TERMINATED'\n         MEXIT\n.OK04    AIF   ('&$MLTAG(&$MDGLVL)' EQ '').OK20\n         MNOTE 8,'''ELSEDO'' INVALID FOLLOWING ''DO'' STATEMENT'\n         MNOTE 0,' - MACRO GENERATION TERMINATED'\n         MEXIT\n.OK20    AIF   ('&$MFNBR(&$MDGLVL)' NE '').OK30\n         $MGFNBR  ,                GET A UNIQUE TAG\n.OK30    J     $MDF&$MFNBR(&$MDGLVL) BRANCH AROUND IF-GROUP\n&X       SETC  '$MDF&$MDGSEQ(&$MDGLVL)'\n         AIF   ('&NAME' EQ '').SKIP40\n&NAME    DC    0H'0'               DEFINE TAG\n.SKIP40  ANOP\n&X       DC    0H'0'               TAG FOR 'ELSE'\n&X       SETC  '&$MDGNAM(&$MDGLVL)'\n&$MDGLVL SETA  &$MDGLVL-1          SO 'THENDO' CAN BUMP IT UP AGAIN\n         THENDO &COND\n&$MDGNAM(&$MDGLVL) SETC '&X'\n.*       DC    0C'$MDGLVL &$MDGLVL $MDGNAM &$MDGNAM(&$MDGLVL)'\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ELSEIF": {"ttr": 3342, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\x01\\x7f\\x01\\x02\\x01\\x7f\\x10\\x17\\x00#\\x00#\\x00\\x00\\xc7\\xc5\\xd5\\xe3\\xd9\\xf0\\xf2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-01-17T00:00:00", "modifydate": "2002-01-17T10:17:00", "lines": 35, "newlines": 35, "modlines": 0, "user": "GENTR02"}, "text": "         MACRO\n&NAME    ELSEIF &EXP\n         COPY  $MGBLDEF\n         LCLC  &X\n         AIF   (&$MDGLVL GT 0).OK02\n         MNOTE 8,'''ELSEIF'' IS VALID ONLY WITHIN AN IF-GROUP'\n         MNOTE 0,' - MACRO GENERATION TERMINATED'\n         MEXIT\n.OK02    AIF   ('&$MIFELS(&$MDGLVL)' EQ 'F').OK04\n         MNOTE 8,'''ELSEIF'' INVALID FOLLOWING ''ELSE'' STATEMENT'\n         MNOTE 0,' - MACRO GENERATION TERMINATED'\n         MEXIT\n.OK04    AIF   ('&$MLTAG(&$MDGLVL)' EQ '').OK20\n         MNOTE 8,'''ELSEIF'' INVALID FOLLOWING ''DO'' STATEMENT'\n         MNOTE 0,' - MACRO GENERATION TERMINATED'\n         MEXIT\n.OK20    AIF   ('&$MFNBR(&$MDGLVL)' NE '').OK30\n         $MGFNBR  ,                GET A UNIQUE TAG\n.OK30    J     $MDF&$MFNBR(&$MDGLVL) BRANCH AROUND ELSEIF-GROUP\n&X       SETC  '$MDF&$MDGSEQ(&$MDGLVL)'\n&$MDGLVL SETA  &$MDGLVL-1          SO 'IF' CAN BUMP IT UP AGAIN\n         AIF   ('&NAME' EQ '').SKIP40\n&NAME    DC    0H'0'               DEFINE TAG\n.SKIP40  ANOP\n&X       IF    &SYSLIST(1),&SYSLIST(2),&SYSLIST(3),&SYSLIST(4),        C\n               &SYSLIST(5),&SYSLIST(6),&SYSLIST(7),&SYSLIST(8),        C\n               &SYSLIST(9),&SYSLIST(10),&SYSLIST(11),&SYSLIST(12),     C\n               &SYSLIST(13),&SYSLIST(14),&SYSLIST(15),&SYSLIST(16),    C\n               &SYSLIST(17),&SYSLIST(18),&SYSLIST(19),&SYSLIST(20),    C\n               &SYSLIST(21),&SYSLIST(22),&SYSLIST(23),&SYSLIST(24),    C\n               &SYSLIST(25),&SYSLIST(26),&SYSLIST(27),&SYSLIST(28),    C\n               &SYSLIST(29),&SYSLIST(30),&SYSLIST(31),&SYSLIST(32)\n&$MDGNAM(&$MDGLVL) SETC '&NAME'    SET NAME FOR 'ENDO'\n.*       DC    0C'$MDGLVL &$MDGLVL $MDGNAM &$MDGNAM(&$MDGLVL)'\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "EM": {"ttr": 3344, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x990\\x0f\\x00\\x991O\\x13R\\x00\\xfa\\x00\\xf9\\x00\\x00\\xc2\\xc3\\xd6\\xc4\\xc8\\xe2\\xf0@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1999-10-27T00:00:00", "modifydate": "1999-11-10T13:52:00", "lines": 250, "newlines": 249, "modlines": 0, "user": "BCODHS0"}, "text": "         MACRO\n&NAME    EM    &TARGET,&SOURCE,&FORMAT,&FLOAT=,&INSERT=,&COMMA=,&MASK=,C\n               &DB=\n.*       SPACE 2\n.**=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\n.* 'EM' UTILIZES 'ED' OR 'EDMK' TO EDIT USER FIELD TO USER'S SPECS    *\n.* THE FIRST OPERAND SPECIFIES THE RECEIVING FIELD                    *\n.* THE SECOND IS THE SENDING FIELD AND MUST BE VALID DECIMAL DATA     *\n.*   (IF THE DATA IS ZONED, IT IS CONVERTED TO PACKED)                *\n.* THE (OPTIONAL) THIRD FIELD (A NUMERIC SELF-DEFINING TERM)          *\n.*   SPECIFIES THE TOTAL NUMBER OF DIGITS TO THE RIGHT OF THE DECIMAL *\n.*   - IF THIS PARAMETER IS OMITTED, THE SCALING VALUE OF THE SOURCE  *\n.*   OPERAND IS USED (EG: DC    PL4'12345.67' WOULD HAVE A SCALING    *\n.*   VALUE OF 2)                                                      *\n.* FLOAT=X SPECIFIES THE FILL CHARACTER TO PRECEED THE                *\n.*   FIRST NUMERIC DIGIT (BLANK IS DEFAULT) (X IS ANY NON-BLANK CHAR) *\n.* INSERT=X SPECIFIES THE SINGLE CHARACTER TO IMMEDIATELY PRECEED THE *\n.*   FIRST NUMERIC DIGIT (BLANK IS DEFAULT) (X IS ANY NON-BLANK CHAR) *\n.* EX: IF FLOAT=* AND INSERT=$ THEN THE RESULT COULD APPEAR:          *\n.*         *******$1,225.00                                           *\n.* COMMA=NO CAUSES NO COMMAS TO BE INSERTED IN THE RESULT. LEAVING    *\n.*   PARAMETER OUT OR SPECIFYING ANY VALUE OTHER THAN 'NO' CAUSES     *\n.*   COMMAS TO BE INSERTED BETWEEN EACH THREE DIGITS                  *\n.* MASK=HEXDIGITS ALLOWS USER TO SPECIFY HER/HIS OWN EDIT MASK        *\n.* DB=X ALLOWS USER TO SPECIFY TYPE OF NOTATION FOR +/- VALUES. IF    *\n.*   NOT SPECIFIED, NEGATIVE VALUES ARE INDICATED BY A '-' IN THE     *\n.*   HIGH ORDER POSITION (IMMEDIATELY PRECEDING THE MOST SIGNIFICANT  *\n.*   DIGIT.                                                           *\n.*   SUPPORTED VALUES FOR THIS PARAMETER ARE:                         *\n.*   DB=- OR DB=(-,LEFT/RIGHT)                                        *\n.*   DB=DB                                                            *\n.*   DB=PARENS                                                        *\n.*   DB=CR                                                            *\n.*   DB=+ OR DB=(+,LEFT/RIGHT)                                        *\n.*   WHEN -, DB, OR PARENS IS SPECIFIED. INDICATION IS PROVIDED       *\n.*   FOR NEGATIVE VALUES ONLY. WHEN CR OR + IS SPECIFIED, AN          *\n.*   EXPLICIT INDICATION IS PROVIDED FOR POSITIVE OR NEGATIVE VALUES  *\n.*   (I.E. DB FOR NEGATIVE AND CR FOR POSITIVE).                      *\n.*   FOR + AND - ONLY, A SECOND POSITIONAL SUBPARAMETER IS            *\n.*   SUPPORTED WHICH ALLOWS PLACEMENT OF THE SIGN TO THE LEFT OF THE  *\n.*   MOST SIGNIFICANT DIGIT, WITH NO BLANK POSITIONS BETWEEN THE SIGN *\n.*   AND THE DIGIT. DEFAULT IS 'RIGHT', AGAIN WITH NO BLANK POSITIONS *\n.*   BETWEEN THE RIGHTMOST DIGIT AND THE SIGN.                        *\n.*   WHEN DB OR CR IS SPECIFIED, ONE BLANK POSITION IS PROVIDED       *\n.*   BETWEEN THE RIGHTMOST DIGIT AND THE CR OR DB INDICATOR.          *\n.* THE FIRST TWO OPERANDS CAN BE SPECIFIED IN THE FOLLOWING WAYS:     *\n.*    DATANAME   - OR - DATANAME(LENGTH)   - OR -                     *\n.*    DATANAME(,BASEREG)  - OR - DATANAME(LENGTH,BASEREG)  - OR -     *\n.*    NUMERIC(LENGTH,BASEREG)                                         *\n.* THE LENGTH PARAMETER FOR EACH OPERAND DEFAULTS TO THE LENGTH       *\n.* ATTRIBUTE OF THE VARIABLE NAME (IF ANY - THE LENGTH IS SET TO 1    *\n.* FOR EXPRESSIONS WHICH DO NOT BEGIN WITH A DATA NAME). THE LENGTH   *\n.* OF 'TARGET' MUST BE BETWEEN 1 AND 255. IF THE SOURCE ITEM IS       *\n.* ZONED DECIMAL, ITS LENGTH MUST BE BETWEEN 1 AND 31. IF IT IS NOT   *\n.* ZONED DECIMAL, THEN IT IS ASSUMED TO BE PACKED DECIMAL, AND ITS    *\n.* LENGTH MUST BE BETWEEN 1 AND 16 (16 IS THE MAXIMUM NUMBER OF       *\n.* BYTES IN A PACKED DECIMAL FIELD).                                  *\n.**=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\n.*       SPACE 2\n         GBLC  &$MSECT(31)         TESTED FOR ENVIRONMENT\n         GBLC  &$PTAG1,&$PTAG2     PAR$E - TAG PORTION\n         GBLA  &$PLEN1,&$PLEN2     PAR$E - LENGTH\n         GBLC  &$PBASE1,&$PBASE2   PAR$E - BASE REGISTER PORTION\n         GBLC  &$PEB1,&$PEB2       '' OR '(R5)' ETC\n         GBLC  &$PELB1,&$PELB2     '(4)' OR '(4,R5)' ETC\n         GBLA  &$MBLATH            CONTROLS LISTING OF DIAGNOSTICS\n         LCLA  &DIG                NUMBER OF DIGITS TO EDIT\n         LCLA  &DEC                DIGITS TO RIGHT OF DECIMAL POINT\n         LCLA  &LN                 BYTE LENGTH OF PACKED FIELD\n         LCLA  &DCRMT              LOCATES BYTE PRECEDING X'21'\n         LCLA  &SCALE              # OF DIGITS RIGHT OF DECIMAL POINT\n         LCLA  &I,&J               WORK VARIABLES\n         LCLB  &GENDC              SET TO (1) TO GEN WORK CELL\n         LCLA  &M                  FOR LENGTH OF (OPT) MINUS SIGN\n         LCLC  &S                  NAME FOR GENERATED PACKED FIELD\n         LCLC  &U                  WORK VARIABLE\n         LCLC  &W                  WORK VARIABLE\n         LCLC  &X                  LOCAL FOR &SYSNDX\n         LCLC  &Y                  HOLDS EDIT MASK (BUILT OR MASK=)\n         LCLC  &Z                  WORK VARIABLE\n         LCLC  &N                  HOLDS &NAME - BLANKED OUT\n         LCLC  &INS                USER SPECIFIED INSERT CHARACTER\n         LCLC  &FLT                USER SPECIFIED FLOAT CHARACTER\n         LCLC  &COM                '6B' DEFAULT; '' IF 'COMMA=NO'\n&M       SETA  0                   ASSUME NO MINUS SIGN\n&SCALE   SETA  0                   ASSUME INTEGER\n         AIF   ('&SOURCE'(1,1) GE '0').TEST00 GO IF SELF-DEFINING\n         AIF   (T'&SOURCE NE 'P' AND T'&SOURCE NE 'Z').TEST00\n&SCALE   SETA  S'&SOURCE           SET TO IMPLICIT SCALING\n.TEST00  AIF   ('&FORMAT' EQ '').SKIP00 GO IF NO EXPLICIT SCALING\n&SCALE   SETA  &FORMAT             SET TO USER-SPECIFIED SCALING\n.SKIP00  PAR$E &TARGET,&SOURCE     BREAK UP INTO TAG-LENGTH-BASE\n&X       SETC  '&SYSNDX'           FOR BREVITY\n&N       SETC  '&NAME'             BLANK LATER\n&Z       SETC  '$WRK&X'            FOR BREVITY\n&COM     SETC  '6B'                ASSUME COMMA\n         AIF   ('&MASK' EQ '').TEST01 GO IF NO MASK SPECIFIED\n         AIF   ('&INSERT' EQ '' AND '&FLOAT' EQ '').DOMASK\n         MNOTE 8,'MASK AND INSERT/FLOAT MUTUALLY EXCLUSIVE - ABORTED'\n         MEXIT\n.DOMASK  ANOP                      USER SPECIFIED 'MASK=...'\n&Y       SETC  '&MASK'             SET SYMBOL TO USER VALUE\n         AGO   .OK05\n.TEST01  ANOP\n&FLT     SETC  ' '                 ASSUME BLANK\n         AIF   ('&FLOAT' EQ '').OK01 GO IF ASSUMPTION CORRECT\n&FLT     SETC  '&FLOAT'(1,1)       SET TO USER-SPECIFIED VALUE\n.OK01    AIF   ('&INSERT' EQ '').OK02\n&INS     SETC  '&INSERT'(1,1)      SET TO USER-SPECIFIED VALUE\n.OK02    ANOP\n&DEC     SETA  0                   DEFAULT 0 DIG TO RIGHT OF '.'\n         AIF   (&SCALE EQ 0).OK03\n&DEC     SETA  &SCALE              # OF USER SPEC. DIGITS RIGHT OF '.'\n.OK03    AIF   ('&COMMA' NE 'NO').OK05 IF NOT =, LEAVE IT AT '6B'\n&COM     SETC  ''                  SET TO NULL\n.OK05    AIF   ('&SOURCE'(1,1) GE '0').PACKED ASSUME PACKED\n         AIF   (T'&SOURCE NE 'Z').PACKED GO IF INPUT IS PACKED\n&DIG     SETA  &$PLEN2             SET ZONED DECIMAL LENGTH\n&LN      SETA  (&DIG+1)/2          REQUIRED LENGTH FOR PACKED\n&S       SETC  '$PWK&SYSNDX'       UNIQUE TAG\n         $WA                       DATA AREA\n&S       DC    PL&LN'0'            PACKED DECIMAL WORK CELL\n         $IA                       INSTRUCTION AREA\n         AIF   (&$MBLATH LT 6).SKIP06\n         DC    0C'&S-&$PTAG2-&$PELB2' EM DIAGNOSTIC - S - $PTAG - $PELB\n.SKIP06  ANOP\n&N       EPACK &S,&$PTAG2&$PELB2   COPY TO PACKED DECIMAL\n&N       SETC  ''                  ELIM DUP TAGS\n         PAR$E &TARGET,&SOURCE     RESCAN (KLUDGE)\n         AGO   .SKIP10\n.PACKED  ANOP\n&DIG     SETA  &$PLEN2*2-1         NUMBER OF DIGITS\n&LN      SETA  &$PLEN2             PACKED LENGTH (IN CASE &DEC >= &DIG)\n&S       SETC  '&$PTAG2&$PEB2'     ELIM POSSIBLE EXPLICIT LENGTH\n.SKIP10  AIF   (&DIG GT &DEC).OK20 GO IF AT LEAST 1 DIGIT LEFT OF '.'\n.LOOP12  ANOP              *****   ALL DIGITS ARE TO RIGHT OF '.' *****\n&Y       SETC  '20&Y'              CREATE ONE DIGIT SELECT\n&DEC     SETA  &DEC-1              . FOR EACH USER\n&DIG     SETA  &DIG-1              . SPECIFIED DIGIT\n         AIF   (&DIG GT 0).LOOP12  LOOP BACK UNTIL FINISHED\n.LOOP14  AIF   (&DEC EQ 0).SKIP16  GO IF WE HAVE LOCATED '.'\n&Y       SETC  'F0&Y'              ZERO FILL TO LEFT OF USER'S DIGITS\n&DEC     SETA  &DEC-1              DECREMENT DECIMAL COUNT\n         AGO   .LOOP14             BACK FOR TEST\n.SKIP16  ANOP              *****   HERE IS WHERE '.' GOES *****\n&Y       SETC  '21204B&Y'          MOVE IN '.' AND PRECEDING CHARS\n&S       SETC  '$PWK&SYSNDX'       TWO EXTRA DIGITS FOR '0.DDD'\n&GENDC   SETB  (1)                 SHOW DEFINE CONSTANT REQUIRED\n&LN      SETA  &LN+1               .\n&N       ZAP   &S,&$PTAG2&$PELB2   MOVE TO LARGER WORK CELL\n&N       SETC  ''                  NULLIFY NAME\n         AGO   .LAST50             GO ON TO NEXT STEP\n.OK20    ANOP\n         AIF   ('&MASK' NE '').LAST50 GO IF USER-DEFINED MASK\n&DCRMT   SETA  0                   DIGIT COUNT TO RIGHT OF X'21'\n         AIF   (&DIG GT 1).TEST2   FALL THROUGH IF 1 DIGIT\n&DCRMT   SETA  1                   SET LOC'N OF X'21' FROM RIGHT\n&Y       SETC  '202120'            SELECT 1 DIGIT\n&S       SETC  '$PWK&SYSNDX'       TWO EXTRA DIGITS FOR 'BBD'\n&GENDC   SETB  (1)                 SHOW DEFINE CONSTANT REQUIRED\n&LN      SETA  &LN+1               .\n&N       ZAP   &S,&$PTAG2&$PELB2   MOVE TO LARGER WORK CELL\n&N       SETC  ''                  NULLIFY NAME\n         AGO   .LAST50             GO ON TO NEXT STEP\n.TEST2   AIF   (&DEC EQ 0).INTEGER\n.LOOP22  ANOP\n&Y       SETC  '20&Y'\n&DCRMT   SETA  &DCRMT+1            COUNT DIGITS IN MASK\n&DEC     SETA  &DEC-1\n&DIG     SETA  &DIG-1\n         AIF   (&DEC GT 0).LOOP22\n&Y       SETC  '4B&Y'\n&DCRMT   SETA  &DCRMT+1            COUNT DIGITS IN MASK\n.INTEGER AIF   (&DIG GT 1).TEST24\n&Y       SETC  '21&Y'\n&FLT     SETC  '0'                 FLOOD WITH ZEROS\n         AGO   .LAST50\n.TEST24  AIF   (&DIG GT 2).TEST26  GO IF THREE OR MORE DIGITS\n&Y       SETC  '2120&Y'            2 DIGITS TO LEFT OF '.'\n&DCRMT   SETA  &DCRMT+1            COUNT DIGITS IN MASK\n         AGO   .LAST50             GO FISH\n.TEST26  ANOP\n&Y       SETC  '202120&Y'          SET FIRST 3 DIGITS TO LEFT OF '.'\n&DCRMT   SETA  &DCRMT+1            COUNT DIGITS IN MASK\n         AIF   (&DIG EQ 3).LAST50  GO IF DONE WITH DIGITS\n&DIG     SETA  &DIG-3              SUB THE THREE WE JUST DID\n.LOOP28  ANOP\n&Y       SETC  '20&COM&Y'          ONE MORE DIGIT SELECT\n         AIF   (&DIG EQ 1).LAST50  GO IF DONE WITH DIGITS\n&Y       SETC  '20&Y'              YET ANOTHER\n         AIF   (&DIG EQ 2).LAST50  GO IF DONE WITH DIGITS\n&Y       SETC  '20&Y'              YET ANOTHER\n&DIG     SETA  &DIG-3              SUB THE THREE WE JUST DID\n         AIF   (&DIG GT 0).LOOP28  BACK IF MORE ELSE FALL THROUGH\n.LAST50  ANOP\n         $WA                       WORK AREA\n         AIF   ('&MASK' NE '').DOMASK2\n$WRK&X   DC    X'40&Y'             WORK AREA FOR EDIT\n         AIF   ('&DB' EQ '').NEXT55\n         AIF   ('&DB' NE '-').NEXT55\n         DC    C' '                MINUS SIGN POSITION\n&M       SETA  1                   ALLOW FOR MINUS SIGN\n.NEXT55  ANOP\n$EDW&X   DC    C'&FLT',X'&Y'       EDIT MASK\n         AGO   .FIN1\n.DOMASK2 ANOP\n$WRK&X   DC    X'&Y'               WORK AREA FOR EDIT\n$EDW&X   DC    X'&Y'               EDIT MASK\n.FIN1    AIF   (NOT &GENDC).FIN2   GO IF NO PACKED CELL NEEDED\n&S       DC    PL&LN'0'            PACKED DECIMAL WORK CELL\n.FIN2    $IA                       INSTRUCTION AREA\n&N       MVC   $WRK&X,$EDW&X       COPY IN EDIT WORD\n         AIF   ('&DB' NE '').NEXT60 GO IF &DB WAS SPECIFIED\n         AIF   ('&INSERT' EQ '').SKIP62 GO IF NO INSERT - GEN 'ED'\n         AIF   ('&INSERT' EQ '&FLOAT').SKIP62 SAME AS FLOAT - GEN 'ED'\n.NEXT60  LA    R1,&Z+L'&Z-&DCRMT   DEFAULT POSITION FOR '$' ETC\n         EDMK  $WRK&X,&S           MAKE IT PRINTABLE\n         BCTR  R1,0                BACK UP TO 'REAL' LOCATION\n         AIF   ('&DB' EQ '').SKIP60Z\n         AIF   ('&DB' NE '-').SKIP64 FOR NOW...\n         THENDO M                  DO IF NEGATIVE RESULT\n           MVI   &Z+L'&Z,C'-'      SET MINUS SIGN\n         ENDO  ,\n         AGO   .SKIP64\n.SKIP60Z MVI   0(R1),C'&INS'       MOVE IN PROTECT CHARACTER\n         AGO   .SKIP64             SKIP AROUND 'ED'\n.SKIP62  ED    $WRK&X,&S           MAKE IT PRINTABLE\n.SKIP64  ANOP\n&U       SETC  '$WRK&X+1'          NAME OF WORK CELL\n&A       SETA  L'&Z                BYTE LENGTH OF WORK CELL\n&B       SETA  &$PLEN1             BYTE LENGTH OF TARGET CELL\n         AIF   (&$MBLATH LT 6).SKIP65\n         DC    0AL4(&A,&B)         EM DIAGNOSTIC - L'WORK, L'TARGET\n.SKIP65  ANOP\n         AIF   (&B GT &A).SECOND   GO IF L'TARGET > L'WORK\n&LW      SETA  &A-&B\n         AIF   ('&DB(1,1)' NE '-').NEXT70\n&LW      SETA  (&LW+1)             BUMP FOR POTENTIAL '-'\n.NEXT70  ANOP\n         MVC   &TARGET,$WRK&X+&LW  MOVE TO TARGET (TRUNCATE LEFTMOST)\n         AGO   .MEND\n.SECOND  ANOP                      L'TARGET < L'WORK\n&LW      SETA  &B-&A               EXCESS LENGTH TO LEFT\n&Y       SETC  '&$PTAG1.(&LW&$PBASE1)' CREATE OPERAND\n         MVC   &Y,=&LW.C'&FLT'     FLOOD LEFTMOST CHARACTERS\n&Y       SETC  '&$PTAG1+&LW.(&M+L''&Z&$PBASE1)' CREATE OPERAND\n         MVC   &Y,&U               COPY ANSWER (RIGHT JUSTIFIED)\n.MEND    AIF   ('&DB(1,1)' NE '-' OR '&DB(1,2)' EQ 'LEFT').OUT99\n         MVI   &Z+L'&Z,C' '        SET SIGN POSITION TO SPACE\n.OUT99   MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ENDAFTER": {"ttr": 3587, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\x01\\x7f\\x01\\x02\\x01\\x7f\\x10\\x17\\x00\\x11\\x00\\x11\\x00\\x00\\xc7\\xc5\\xd5\\xe3\\xd9\\xf0\\xf2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-01-17T00:00:00", "modifydate": "2002-01-17T10:17:00", "lines": 17, "newlines": 17, "modlines": 0, "user": "GENTR02"}, "text": "         MACRO\n&NAME    ENDAFTER &DOGROUP=        INTERCHANGEABLE WITH 'ENDO' EXCEPT\n         COPY  $MGBLDEF            . FOR 'ELSEDO' CLAUSE\n         AIF   (&$MDGLVL GT 0).OK02\n         MNOTE 8,'''ENDAFTER'' INVALID OUTSIDE DO-GROUP'\n         MNOTE 0,' - MACRO GENERATION TERMINATED'\n         MEXIT\n.OK02    ANOP\n         LCLC  &X\n&X       SETC  '&$MCVERB(&$MDGLVL)'\n         AIF   ('&X' EQ 'AFTER').CONT010\n         MNOTE 4,'''ENDAFTER'' USED TO TERMINATE ''&X'' GROUP'\n.CONT010 ANOP  ,\n&NAME    $MENDDO1 DOGROUP=&DOGROUP END ALL BUT HIGHEST LEVEL\n         AIF   (&$MDGERR NE 0).QUIT GIVE UP EASILY\n         $MENDDO2                  END FINAL LEVEL\n.QUIT    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ENDELSE": {"ttr": 3589, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\x01\\x7f\\x01\\x02\\x01\\x7f\\x10\\x17\\x00\\x11\\x00\\x11\\x00\\x00\\xc7\\xc5\\xd5\\xe3\\xd9\\xf0\\xf2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-01-17T00:00:00", "modifydate": "2002-01-17T10:17:00", "lines": 17, "newlines": 17, "modlines": 0, "user": "GENTR02"}, "text": "         MACRO\n&NAME    ENDELSE &DOGROUP=         INTERCHANGEABLE WITH 'ENDO' EXCEPT\n         COPY  $MGBLDEF            . FOR 'ELSEDO' CLAUSE\n         AIF   (&$MDGLVL GT 0).OK02\n         MNOTE 8,'''ENDELSE'' INVALID OUTSIDE DO-GROUP'\n         MNOTE 0,' - MACRO GENERATION TERMINATED'\n         MEXIT\n.OK02    ANOP\n         LCLC  &X\n&X       SETC  '&$MCVERB(&$MDGLVL)'\n         AIF   ('&X' EQ 'ELSE').CONT010\n         MNOTE 4,'''ENDELSE'' USED TO TERMINATE ''&X'' GROUP'\n.CONT010 ANOP  ,\n&NAME    $MENDDO1 DOGROUP=&DOGROUP END ALL BUT HIGHEST LEVEL\n         AIF   (&$MDGERR NE 0).QUIT GIVE UP EASILY\n         $MENDDO2                  END FINAL LEVEL\n.QUIT    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ENDEVERY": {"ttr": 3591, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\x01\\x7f\\x01\\x02\\x01\\x7f\\x10\\x17\\x00\\x11\\x00\\x11\\x00\\x00\\xc7\\xc5\\xd5\\xe3\\xd9\\xf0\\xf2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-01-17T00:00:00", "modifydate": "2002-01-17T10:17:00", "lines": 17, "newlines": 17, "modlines": 0, "user": "GENTR02"}, "text": "         MACRO\n&NAME    ENDEVERY &DOGROUP=        INTERCHANGEABLE WITH 'ENDO' EXCEPT\n         COPY  $MGBLDEF            . FOR 'ELSEDO' CLAUSE\n         AIF   (&$MDGLVL GT 0).OK02\n         MNOTE 8,'''ENDEVERY'' INVALID OUTSIDE DO-GROUP'\n         MNOTE 0,' - MACRO GENERATION TERMINATED'\n         MEXIT\n.OK02    ANOP\n         LCLC  &X\n&X       SETC  '&$MCVERB(&$MDGLVL)'\n         AIF   ('&X' EQ 'EVERY').CONT010\n         MNOTE 4,'''ENDEVERY'' USED TO TERMINATE ''&X'' GROUP'\n.CONT010 ANOP  ,\n&NAME    $MENDDO1 DOGROUP=&DOGROUP END ALL BUT HIGHEST LEVEL\n         AIF   (&$MDGERR NE 0).QUIT GIVE UP EASILY\n         $MENDDO2                  END FINAL LEVEL\n.QUIT    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ENDFIRST": {"ttr": 3593, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\x01\\x7f\\x01\\x02\\x01\\x7f\\x10\\x17\\x00\\x11\\x00\\x11\\x00\\x00\\xc7\\xc5\\xd5\\xe3\\xd9\\xf0\\xf2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-01-17T00:00:00", "modifydate": "2002-01-17T10:17:00", "lines": 17, "newlines": 17, "modlines": 0, "user": "GENTR02"}, "text": "         MACRO\n&NAME    ENDFIRST &DOGROUP=        INTERCHANGEABLE WITH 'ENDO' EXCEPT\n         COPY  $MGBLDEF            . FOR 'ELSEDO' CLAUSE\n         AIF   (&$MDGLVL GT 0).OK02\n         MNOTE 8,'''ENDFIRST'' INVALID OUTSIDE DO-GROUP'\n         MNOTE 0,' - MACRO GENERATION TERMINATED'\n         MEXIT\n.OK02    ANOP\n         LCLC  &X\n&X       SETC  '&$MCVERB(&$MDGLVL)'\n         AIF   ('&X' EQ 'FIRST').CONT010\n         MNOTE 4,'''ENDFIRST'' USED TO TERMINATE ''&X'' GROUP'\n.CONT010 ANOP  ,\n&NAME    $MENDDO1 DOGROUP=&DOGROUP END ALL BUT HIGHEST LEVEL\n         AIF   (&$MDGERR NE 0).QUIT GIVE UP EASILY\n         $MENDDO2                  END FINAL LEVEL\n.QUIT    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ENDIF": {"ttr": 3595, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x02\\x00'\\x01\\x02\\x01_\\x01\\x02\\x01\\x7f\\x13'\\x00\\x0b\\x00\\n\\x00\\x00\\xc7\\xc5\\xd5\\xe3\\xd9\\xf0\\xf2@@@\"", "ispf": {"version": "01.02", "flags": 0, "createdate": "2002-01-15T00:00:00", "modifydate": "2002-01-17T13:27:27", "lines": 11, "newlines": 10, "modlines": 0, "user": "GENTR02"}, "text": "         MACRO\n&NAME    ENDIF &ELSE,&DOGROUP=\n         COPY  $MGBLDEF\n         LCLC  &X\n&X       SETC  '&$MCVERB(&$MDGLVL)'\n         AIF   ('&X' EQ 'IF').CONT010\n         MNOTE 4,'''ENDIF'' USED TO TERMINATE ''&X'' GROUP'\n.CONT010 ANOP  ,\n&$MCVERB(&$MDGLVL) SETC 'DO' FAKE OUT 'ENDO' MACRO\n&NAME    ENDO  &ELSE,DOGROUP=&DOGROUP\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ENDO": {"ttr": 3597, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00A\\x01\\x02\\x01_\\x01\\x02\\x01\\x7f\\x13$\\x00\\'\\x00\"\\x00\\x00\\xc7\\xc5\\xd5\\xe3\\xd9\\xf0\\xf2@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2002-01-15T00:00:00", "modifydate": "2002-01-17T13:24:41", "lines": 39, "newlines": 34, "modlines": 0, "user": "GENTR02"}, "text": "         MACRO\n&NAME    ENDO  &ELSE,&DOGROUP=    INTERCHANGEABLE WITH 'ENDELSE' EXCEPT\n         COPY  $MGBLDEF           . FOR 'ENDELSE' CLAUSE\n         LCLC  &X                  SET TO 'IF-FAILED' TAG\n         AIF   (&$MDGLVL GT 0).OK02\n         MNOTE 8,'''ENDO'' INVALID OUTSIDE DO-GROUP'\n         MNOTE 0,' - MACRO GENERATION TERMINATED'\n         MEXIT\n.OK02    ANOP\n         LCLC  &Y\n&Y       SETC  '&$MCVERB(&$MDGLVL)'\n         AIF   ('&Y' EQ 'DO').CONT010\n         MNOTE 4,'''ENDO'' USED TO TERMINATE ''&Y'' GROUP'\n.CONT010 ANOP  ,\n&NAME    $MENDDO1 DOGROUP=&DOGROUP\n         AIF   (&$MDGERR NE 0).QUIT GIVE UP IF ERROR\n         AIF   ('&ELSE' NE '').NEXT10 NO 'ELSE' - END LAST LEVEL\n         $MENDDO2                 LAST LEVEL FOR THIS PASS\n         MEXIT\n.NEXT10  AIF   ('&ELSE' EQ 'ELSEDO').NEXT20 GO IF LEGIT 'ELSEDO'\n         MNOTE *,'ERROR IN PARM ''&ELSE'' - PARM IGNORED'\n         $MENDDO2                 JUST LIKE NO '&ELSE'\n         MEXIT\n.NEXT20  ANOP\n         AIF  ('&$MLTAG(&$MDGLVL)' EQ '').SKIP30\n         MNOTE 8,'''ELSEDO'' INVALID FOR ''DO'' - IGNORED'\n         $MENDDO2                 JUST LIKE NO '&ELSE'\n         MEXIT\n.SKIP30  ANOP\n         AIF   ('&$MIFELS(&$MDGLVL)' NE 'S').SKIP40\n         MNOTE 8,'''ELSEDO'' INVALID FOLLOWING ''ELSEDO'' -'\n         MNOTE '''ENDO'' INVOKED'\n         $MENDDO2                 JUST LIKE NO 'ELSEDO'\n         MEXIT\n.SKIP40  J     $MDS&$MDGSEQ(&$MDGLVL) BRANCH AROUND ELSE-GROUP\n&X       SETC  '$MDF&$MDGSEQ(&$MDGLVL)' 'IF-FAILED' TAG\n&X       DC    0H'0'              TAG FOR 'IF' FAILURE\n&$MIFELS(&$MDGLVL) SETC 'S'       SET FOR 'ENDELSE'\n.QUIT    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ENDP": {"ttr": 3599, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00\\x00o\\x01\\x00\\x00o\\x18S\\x00\\x14\\x00\\x14\\x00\\x00\\xc2\\xc3\\xd6\\xc4\\xc8\\xe2\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-01-06T00:00:00", "modifydate": "2000-01-06T18:53:00", "lines": 20, "newlines": 20, "modlines": 0, "user": "BCODHS0"}, "text": "         MACRO\n&NAME    ENDP  &PROC               MUST BE LAST STMT WITHIN A 'PROC'\n         COPY  $MGBLDEF\n         LCLC  &Y\n         VERSION 1\n&$MPCSV(&$MPLVL) SETA  0           SHOW 'NOT WITHIN PROC'\n&$PROCNM(&$MPLVL) SETC  ''         ERASE PROC NAME\n         AIF   (&$MDGLVL EQ 0).SKIP10 GO IF NO DO-GROUPS TO END\n         MNOTE 4,'&$MDGLVL DO-GROUP(S) ENDED'\n         ENDO  DOGROUP=*ALL*\n.SKIP10  ANOP\n&NAME    RETN  ,                   RETURN TO CALLER\n         DROP  &$USING(&$MPLVL)    DROP CURRENT BASE REG(S)\n&$MPLVL  SETA  &$MPLVL-1\n         LTORG\n&Y       SETC  '&$MSECT(&$MPLVL)'\n&Y       CSECT                     BACK TO PREV CSECT\n         AIF   ('&Y' EQ 'DATAAREA').MEND\n         USING &Y,&$USING(&$MPLVL) REESTABLISH ADDRESSABILITY\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ENDSECT": {"ttr": 3601, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00\\x00o\\x01\\x00\\x00o\\x18S\\x00\\x0f\\x00\\x0f\\x00\\x00\\xc2\\xc3\\xd6\\xc4\\xc8\\xe2\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-01-06T00:00:00", "modifydate": "2000-01-06T18:53:00", "lines": 15, "newlines": 15, "modlines": 0, "user": "BCODHS0"}, "text": "         MACRO\n&NAME    ENDSECT &DUMMY            ROUTINE TO END A SECTION\n         COPY  $MGBLDEF\n         GBLC  &GSECT,&WSECT       SECTION NAMES\n         GBLC  &GRETN,&GSKIP       RETRIEVE NAMES\n         VERSION 2\n         AIF   (&$MDGLVL EQ 0).SKIP10 GO IF NO DO-GROUPS TO END\n         MNOTE 4,'&$MDGLVL DO-GROUP(S) ENDED'\n         ENDO  DOGROUP=*ALL*\n.SKIP10  ANOP\n&NAME    B     &GRETN              RETURN TO CALLER\n         LTORG\n&GSKIP   DC    0H'0'               TAG FOR END OF SECTION\n&GRETN   SETC  ''                  SHOW SECTION HAS ENDED\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "ENDTEST": {"ttr": 3603, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&NAME    ENDTEST &DUMMY\n         AIF   ('&NAME' EQ '').MEND999\n&NAME    DS    0H                  TAG GENERATED BY 'ENDTEST' MACRO\n.MEND999 MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "EPACK": {"ttr": 3605, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00\\x00o\\x01\\x00\\x00o\\x18S\\x00,\\x00,\\x00\\x00\\xc2\\xc3\\xd6\\xc4\\xc8\\xe2\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-01-06T00:00:00", "modifydate": "2000-01-06T18:53:00", "lines": 44, "newlines": 44, "modlines": 0, "user": "BCODHS0"}, "text": "         MACRO\n&NAME    EPACK &TARGET,&SOURCE\n         GBLC  &$PTAG1,&$PTAG2\n         GBLA  &$PLEN1,&$PLEN2\n         GBLC  &$PBASE1,&$PBASE2\n         GBLA  &$MBLATH\n         LCLA  &LEN1,&LEN2,&DISP1,&DISP2\n         AIF   (&$MBLATH LT 6).SKIP00\n         DC    0C'&TARGET'         EPACK DIAGNOSTIC - &TARGET\n         DC    0C'&SOURCE'         EPACK DIAGNOSTIC - &SOURCE\n.SKIP00  ANOP\n         PAR$E &TARGET,&SOURCE     GET VALUES FOR TARGET AND SOURCE\n         AIF   (&$PLEN1 LT 17).TEST02\n         MNOTE 12,'PARM #1 LENGTH &$PLEN1 INVALID - MACRO ABORTED'\n         MEXIT\n.TEST02  AIF   (&$PLEN2 LT 32).TEST04\n         MNOTE 12,'PARM #2 LENGTH &$PLEN2 INVALID - MACRO ABORTED'\n         MEXIT\n.TEST04  AIF   (&$PLEN1 LT 16 OR &$PLEN2 LT 31).TEST10\n.* BOTH OPERANDS ARE MAX LENGTHS - GENERATE THREE OVERLAPPING PACKS\n&NAME    PACK  &$PTAG1.(2&$PBASE1),&$PTAG2.(3&$PBASE2)\n         PACK  &$PTAG1+1(8&$PBASE1),&$PTAG2+2(15&$PBASE2)\n         PACK  &$PTAG1+8(8&$PBASE1),&$PTAG2+16(15&$PBASE2)\n         MEXIT\n.TEST10  AIF   (&$PLEN2 GT 16).TEST20 WILL ONE PACK WORK? GO IF NO\n&NAME    PACK  &TARGET,&SOURCE\n         MEXIT\n.TEST20  AIF   (&$PLEN1 LE 8).NEXT50 GO GEN 1 PACK WITH ADJUSTMENTS\n.* TWO OVERLAPPING PACK INSTRUCTIONS ARE REQUIRED\n&DISP2   SETA  0                   OPERATING ASSUMPTION\n         AIF   (&$PLEN2 NE 31).CONT30 GO IF CORRECT\n&DISP2   SETA  2                   SET TO DISPLACEMENT\n.CONT30  ANOP\n&LEN1    SETA  &$PLEN1-7\n&LEN2    SETA  &$PLEN2-14-&DISP2\n&NAME    PACK  &$PTAG1.(&LEN1&$PBASE1),&$PTAG2+&DISP2.(&LEN2&$PBASE2)\n&DISP1   SETA  &$PLEN1-8\n&DISP2   SETA  &$PLEN2-15\n         PACK  &$PTAG1+&DISP1.(8&$PBASE1),&$PTAG2+&DISP2.(15&$PBASE2)\n         MEXIT\n.NEXT50  ANOP\n&DISP2   SETA  &$PLEN2-16\n&NAME    PACK  &TARGET,&$PTAG2+&DISP2.(16&$PBASE2)\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "EQUATE": {"ttr": 3607, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x994\\x9f\\x00\\x994\\x9f\\x15\\x04\\x00\\r\\x00\\r\\x00\\x00\\xc2\\xc3\\xd6\\xc4\\xc8\\xe2\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-15T00:00:00", "modifydate": "1999-12-15T15:04:00", "lines": 13, "newlines": 13, "modlines": 0, "user": "BCODHS0"}, "text": "         MACRO\n&NAME    EQUATE &DUMMY             EQUATE 16 GP REGISTERS\n         LCLA  &I                  DEFINE LOCAL\n         AIF   (D'R0).MEND         SKIP EQUATES IF R0 ALREADY DEFINED\n         PUSH  PRINT\n         PRINT NOGEN\n&I       SETA  0                   INITIALIZE\n.LOOP    ANOP                      LOOP BACK TO HERE\nR&I      EQU   &I                  DEFINE A REGISTER\n&I       SETA  &I+1                BUMP INDEX\n         AIF   (&I LT 16).LOOP     BACK IF MORE TO DO\n         POP   PRINT\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "EUNPK": {"ttr": 3609, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00\\x00o\\x01\\x00\\x00o\\x18S\\x00-\\x00-\\x00\\x00\\xc2\\xc3\\xd6\\xc4\\xc8\\xe2\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-01-06T00:00:00", "modifydate": "2000-01-06T18:53:00", "lines": 45, "newlines": 45, "modlines": 0, "user": "BCODHS0"}, "text": "         MACRO\n&NAME    EUNPK &TARGET,&SOURCE\n         GBLC  &$PTAG1,&$PTAG2\n         GBLA  &$PLEN1,&$PLEN2\n         GBLC  &$PBASE1,&$PBASE2\n         LCLA  &LEN1,&LEN2,&DISP1,&DISP2\n         PAR$E &TARGET,&SOURCE     GET VALUES FOR TARGET\n         AIF   (&$PLEN1 LT 32).TEST02\n         MNOTE 12,'PARM #1 LENGTH &$PLEN1 INVALID - MACRO ABORTED'\n         MEXIT\n.TEST02  AIF   (&$PLEN2 LT 17).TEST04\n         MNOTE 12,'PARM #2 LENGTH &$PLEN2 INVALID - MACRO ABORTED'\n         MEXIT\n.TEST04  AIF   (&$PLEN1 LT 31 OR &$PLEN2 LT 16).TEST10\n.* BOTH OPERANDS ARE MAX LENGTHS - GENERATE THREE OVERLAPPING UNPACKS\n&NAME    UNPK  &$PTAG1.(3&$PBASE1),&$PTAG2.(2&$PBASE2)\n         UNPK  &$PTAG1+2(15&$PBASE1),&$PTAG2+1(8&$PBASE2)\n         UNPK  &$PTAG1+16(15&$PBASE1),&$PTAG2+8(8&$PBASE2)\n         MEXIT\n.TEST10  AIF   (&$PLEN1 GT 16).TEST20 TEST SOME MORE\n&NAME    UNPK  &TARGET,&SOURCE\n         MEXIT\n.TEST20  AIF   (&$PLEN2 LE 8).NEXT50 GO GEN 1 UNPACK WITH ADJUSTMENTS\n.* TWO OVERLAPPING UNPACK INSTRUCTIONS ARE REQUIRED\n&DISP1   SETA  0                   OPERATING ASSUMPTION\n         AIF   (&$PLEN1 NE 31).CONT30 GO IF CORRECT\n&DISP1   SETA  2                   SET DISPLACEMENT\n.CONT30  ANOP\n&LEN1    SETA  &$PLEN1-14-&DISP1\n&LEN2    SETA  &$PLEN2-7\n&N       SETC  '&NAME'\n         AIF   (&DISP1 EQ 0).SKIP40\n&N       MVC   &$PTAG1.(&DISP1&$PBASE1),=15C'0'\n&N       SETC  ''\n.SKIP40  ANOP\n&N       UNPK  &$PTAG1+&DISP1.(&LEN1&$PBASE1),&$PTAG2.(&LEN2&$PBASE2)\n&DISP1   SETA  &$PLEN1-15\n&DISP2   SETA  &$PLEN2-8\n         UNPK  &$PTAG1+&DISP1.(15&$PBASE1),&$PTAG2+&DISP2.(8&$PBASE2)\n         MEXIT\n.NEXT50  ANOP\n&DISP1   SETA  &$PLEN1-16\n&NAME    MVC   &$PTAG1.(&DISP1&$PBASE1),=15C'0'\n         UNPK  &$PTAG1+&DISP1.(16&$PBASE1),&SOURCE\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "EVERY": {"ttr": 3611, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\x01\\x7f\\x01\\x02\\x01\\x7f\\x10\\x17\\x00\\x18\\x00\\x18\\x00\\x00\\xc7\\xc5\\xd5\\xe3\\xd9\\xf0\\xf2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-01-17T00:00:00", "modifydate": "2002-01-17T10:17:00", "lines": 24, "newlines": 24, "modlines": 0, "user": "GENTR02"}, "text": "         MACRO\n&NAME    EVERY &VAR\n         COPY  $MGBLDEF            BRING IN THE CLOWNS\n         GBLC  &TRACE              CONTROLS TRACING OUTPUT\n&LCLV    SETC  '&VAR'              SET TO COUNT\n         AIF   ('&VAR'(1,1) GE '0').NEXT010 GO IF SELF-DEFINING\n&LCLV    SETC  '1'                 DO EVERY TIME\n.NEXT010 ANOP\n&$MDGLVL SETA  &$MDGLVL+1          INCREMENT LEVEL\n&$MDGSEQ(&$MDGLVL) SETC '&SYSNDX'\n&$MIFELS(&$MDGLVL) SETC 'F'\n&$MDGNAM(&$MDGLVL) SETC '&NAME'\n&$MCVERB(&$MDGLVL) SETC 'EVERY'\n         AIF   ('&TRACE' NE 'YES').SKIP020\n         DC    0C'$MDGLVL &$MDGLVL $MDGNAM &$MDGNAM(&$MDGLVL)'\n.SKIP020 ANOP\n&X       SETC  '$MDV&SYSNDX'       MAKE IT PRETTY\n&NAME    SP    &X,=P'1'            DECREMENT\n         JP    $MDF&SYSNDX         B IF NOT YET TIME\n         MVC   &X,=P'&LCLV'        RESET\nDATA     LOCTR                     ENTER WORK AREA\n&X       DC    P'&LCLV'            FREQUENCY COUNTER\n&SYSECT  LOCTR                     RESUME INSTRUCTION AREA\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "EXECUTE": {"ttr": 3613, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\x01\\x7f\\x01\\x02\\x01\\x7f\\x10\\x17\\x00!\\x00!\\x00\\x00\\xc7\\xc5\\xd5\\xe3\\xd9\\xf0\\xf2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-01-17T00:00:00", "modifydate": "2002-01-17T10:17:00", "lines": 33, "newlines": 33, "modlines": 0, "user": "GENTR02"}, "text": "         MACRO\n&N       EXECUTE &DUMMY            OPERANDS ACCESSED VIA &SYSLIST(N)\n.*                                                                   *\n.*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\n.* INLINE 'EX' INSTRUCTION. EXAMPLE:                                 *\n.*                                                                   *\n.*         EXECUTE R1,MVC,(FIELDA(0),FIELDB)                         *\n.*                                                                   *\n.* THE RESULT WILL BE THE EQUIVALENT OF:                             *\n.*                                                                   *\n.*         EX    R1,EXNBR1                                           *\n.*         ...                                                       *\n.* EXNBR1  MVC   FIELDA(0),FIELDB                                    *\n.*                                                                   *\n.* THE ADVANTAGE IS THAT THE EXECUTABLE INSTRUCTION IS AUTOMATICALLY *\n.* GENERATED OUT-OF-LINE (IN THE 'WORKING_STORAGE SECTION').         *\n.*                                                                   *\n.*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\n.*                                                                   *\n         LCLC  &TEMP,&X,&OP\n&X       SETC  '&SYSNDX'\n&N       EX    &SYSLIST(1),$EX&X   DO THE 'EX'ECUTE\nDATA     LOCTR ,\n         AIF   (K'&SYSLIST(3) LT 3).CONT010\n&TEMP    SETC  '&SYSLIST(3)'(2,K'&SYSLIST(3)-2)\n         AGO   .CONT020\n.CONT010 ANOP\n&TEMP    SETC  ','\n.CONT020 ANOP\n&OP      SETC  '&SYSLIST(2)'\n$EX&X    &OP   &TEMP               'EX'ECUTED INSTRUCTION\n&SYSECT  LOCTR ,\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "EXIT": {"ttr": 3615, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00\\x00o\\x01\\x00\\x00o\\x18S\\x00\\x14\\x00\\x14\\x00\\x00\\xc2\\xc3\\xd6\\xc4\\xc8\\xe2\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-01-06T00:00:00", "modifydate": "2000-01-06T18:53:00", "lines": 20, "newlines": 20, "modlines": 0, "user": "BCODHS0"}, "text": "         MACRO\n&NAME    EXIT  &RC=\n         GBLC  &GSECT,&WSECT       LOCATION COUNTER NAMES\n         VERSION 2\n         AIF   ('&RC' NE '').SKIP10\n&NAME    SLR   15,15               SET ZERO RETURN CODE\n         AGO   .RETURN\n.SKIP10  AIF   ('&RC'(1,1) EQ '(').GPR\n&NAME    LA    15,&RC              SET USER SPECIFIED RETURN CODE\n         AGO   .RETURN\n.GPR     ANOP\n&NAME    LR    15,&RC(1)           SET USER SPECIFIED RETURN CODE\n.RETURN  L     13,4(,13)           BACK CHAIN\n         L     14,12(,13)          RESTORE 14\n         LM    0,12,20(13)         RESTORE REMAINING REGS\n         BR    14                  EXIT PROGRAM\n         LTORG\n         AIF   (D'R0).SKIP20       GENERATE EQUATE STATEMENTS\n         EQUATE ,                  . IF NECESSARY\n.SKIP20  MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "FINAL": {"ttr": 3841, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00\\x00o\\x01\\x00\\x00o\\x18S\\x00f\\x00f\\x00\\x00\\xc2\\xc3\\xd6\\xc4\\xc8\\xe2\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-01-06T00:00:00", "modifydate": "2000-01-06T18:53:00", "lines": 102, "newlines": 102, "modlines": 0, "user": "BCODHS0"}, "text": "         MACRO\n&NAME    FINAL &DUMMY\n.*                                                                    *\n.**=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\n.* THIS MACRO SHOULD BE CODED FOLLOWING ALL PERFORM STATEMENTS AND    *\n.* SECTION AND ENDSECT MACRO DEFINITIONS. IT IS REQUIRED TO GENERATE  *\n.* LABELS REFERRED TO IN PERFORM STATEMENTS. MNOTE ERRORS WILL BE     *\n.* GENERATED IF A 'PERFORM' OR A 'GOTO' MACRO HAS AS ITS OPERAND AN   *\n.* INSTRUCTION THAT IS NOT A SECTION NAME. THESE TWO MACROS *MUST*    *\n.* REFER ONLY TO LABELS THAT DEFINE SECTION MACROS. USING ASSEMBLER   *\n.* BRANCH-ON-CONDITION INSTRUCTIONS (SUCH AS 'B', 'BNE', 'BC', ETC.), *\n.* WITH SECTION NAMES WILL PRODUCE UNPREDICTABLE RESULTS.             *\n.**=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\n.*                                                                    *\n         COPY  $MGBLDEF\n         GBLC  &GRETN,&GSAVE\n         LCLC  &X,&LOCTR           SHORTHAND FOR 'REF&SYSNDX'\n         LCLA  &I,&J               SUBSCRIPTS\n&LOCTR   SETC  '&$MLOCTR'          SAVE CURRENT LOCTR NAME\n.*                                                                    *\n.**=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\n.* THIS MACRO IS VALID ONLY FOR VERSION 2 OF THE MACRO DEFINITIONS    *\n.**=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\n.*                                                                    *\n         VERSION 2\n.*                                                                    *\n.**=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\n.* INITIALIZE SUBSCRIPTS                                              *\n.**=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\n.*                                                                    *\n&I       SETA  1                   INITIALIZE\n&J       SETA  1                   .\n.*                                                                    *\n.**=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\n.* INCREASE ASSEMBLER LOOP LIMITER                                    *\n.**=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\n.*                                                                    *\n         ACTR  32767               .\n.*                                                                    *\n.**=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\n.* ISSUE ENDSECT IF STILL WITHIN A SECTION                            *\n.**=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\n.*                                                                    *\n         AIF   ('&GRETN' EQ '').LOOP10\n         ENDSECT ,\n.*                                                                    *\n.**=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\n.* EXIT IF NO GOTO OR PERFORM MACROS                                  *\n.**=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\n.*                                                                    *\n.LOOP10  AIF   (&$GOTOC EQ 0).MEND\n.*                                                                    *\n.**=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\n.* GO IF HIT ON NAMES                                                 *\n.**=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\n.*                                                                    *\n AIF ('&$SECT(&I)' EQ '&$GOTO(&J)' AND '&$SECT(&I)' NE '').NEXT30\n&I       SETA  &I+1                NO MATCH - BUMP POINTER\n         AIF   (&I LE &$SECTC).LOOP10 BACK IF MORE TO SCAN\n.*                                                                    *\n.**=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\n.* FALLING THROUGH TO HERE MEANS NO SECTION NAME WAS FOUND FOR GOTO OR\n.* PERFORM, WHICH MEANS NO DEFINE CONSTANT WILL BE CREATED FOR\n.* REF&SYSNDX, WHICH MEANS GOTO/PERFORM WILL GET UNDEFINED SYMBOL ERROR\n.**=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\n.*                                                                    *\n         MNOTE           8,'GOTO/PERFORM OBJECT &$GOTO(&J) (SEARCH FOR X\n               REF&$GREF(&J) IN LISTING)'\n      MNOTE 0,'(CONT''D) IS NOT A SECTION NAME - UNPREDICTABLE RESULTS'\n.*                                                                    *\n.**=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\n.* GO TO NEXT NAME                                                    *\n.**=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\n.*                                                                    *\n.NEXT20  ANOP\n&I       SETA  1                   REINITIALIZE\n&J       SETA  &J+1                BUMP\n         AIF   (&J LE &$GOTOC).LOOP10 BACK IF MORE TO DO\n         AGO   .MEND\n.*                                                                    *\n.**=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\n.* GETTING TO HERE IS A *VERY GOOD THING*. A GOTO OR A PERFORM        *\n.* REFERRED TO A SECTION, SO GENERATE THE ADCON TO SATISFY THE        *\n.* REFERENCE GENERATED IN THE GOTO/PERFORM MACRO.                     *\n.**=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\n.*                                                                    *\n.NEXT30  ANOP\n&X       SETC  'REF&$GREF(&J)'     NAME REFERRED TO IN GOTO/PERFORM\n&X       DC    0C'&$GOTO(&J) '     SHOW NAME IS ACTUALLY SECTION NAME\n         AGO   .NEXT20             CONTINUE WITH NEXT GOTO NAME\n.MEND    ANOP\n         PUSH  PRINT\n         PRINT GEN\n         $IA\nINST_LEN EQU   *-&SYSECT           LENGTH OF INSTRUCTION PORTION\n         $WA\nDATA_LEN EQU   *-&GSAVE            LENGTH OF DATA PORTION\nPROG_LEN EQU   (INST_LEN+DATA_LEN+7)/8*8 PROGRAM LENGTH\n         POP   PRINT\n         AIF   ('&LOCTR' EQ '&$MLOCTR').MEXIT SKIP UNNECESSARY CODE\n&LOCTR   LOCTR ,                   RESET LOCATION COUNTER\n.MEXIT   MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "FIRST": {"ttr": 3844, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\x01\\x7f\\x01\\x02\\x01\\x7f\\x10\\x17\\x00\"\\x00\"\\x00\\x00\\xc7\\xc5\\xd5\\xe3\\xd9\\xf0\\xf2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-01-17T00:00:00", "modifydate": "2002-01-17T10:17:00", "lines": 34, "newlines": 34, "modlines": 0, "user": "GENTR02"}, "text": "         MACRO\n&NAME    FIRST &VAR\n         COPY  $MGBLDEF            BRING IN THE CLOWNS\n         GBLC  &TRACE\n&LCLV    SETC  '&VAR'              SET TO COUNT\n         AIF   ('&VAR'(1,1) GE '0').NEXT010 GO IF SELF-DEFINING\n&LCLV    SETC  '1'                 DO FIRST TIME ONLY\n.NEXT010 ANOP\n&$MDGLVL SETA  &$MDGLVL+1          INCREMENT LEVEL\n&$MDGSEQ(&$MDGLVL) SETC '&SYSNDX'\n&$MIFELS(&$MDGLVL) SETC 'F'\n&$MDGNAM(&$MDGLVL) SETC '&NAME'\n&$MCVERB(&$MDGLVL) SETC 'FIRST'\n         AIF   ('&TRACE' NE 'YES').SKIP020\n         DC    0C'$MDGLVL &$MDGLVL $MDGNAM &$MDGNAM(&$MDGLVL)'\n.SKIP020 ANOP\n&X       SETC  '$MDV&SYSNDX'       MAKE IT PRETTY\n         AIF   ('&LCLV' NE '1').SKIP030\n&NAME    TM    &X,X'01'            HAVE WE BEEN HERE BEFORE?\n         JO    $MDF&SYSNDX         B IF YES\n         OI    &X,X'01'            LEAVE TRACKS\nDATA     LOCTR                     ENTER WORK AREA\n&X       DC    X'00'               SET TO X'01' FIRST PASS\n&SYSECT  LOCTR                     RESUME INSTRUCTION AREA\n         MEXIT\n.SKIP030 ANOP\n&X       SETC  '$MDV&SYSNDX'       MAKE IT PRETTY\n&NAME    CP    &X,=P'0'            FINISHED?\n         JNH   $MDF&SYSNDX         B IF YES\n         SP    &X,=P'1'            DECREMENT BY 1\nDATA     LOCTR                     ENTER WORK AREA\n&X       DC    P'&LCLV'            EXECUTION TIMES COUNTER\n&SYSECT  LOCTR                     RESUME INSTRUCTION AREA\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "GO": {"ttr": 3846, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x99$o\\x00\\x99$o\\x153\\x00\\x8e\\x00\\x8e\\x00\\x00\\xc2\\xc3\\xd6\\xc4\\xc8\\xe2\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-09-03T00:00:00", "modifydate": "1999-09-03T15:33:00", "lines": 142, "newlines": 142, "modlines": 0, "user": "BCODHS0"}, "text": "         MACRO\n&NAME    GO    &BASE=12,&LINK=14,&EQUATE=YES,&NBASE=,&ABEND=4,         C\n               &BLATHER=MUM,&ERROR=8,&INTRO=YES\n         COPY  $MGBLDEF\n         LCLA  &TEMP,&TEMP2,&TEMP3,&I\n         LCLC  &X,&Y,&Z,&PROGNAM\n         VERSION 1\n&PROGNAM SETC  '&NAME'\n&$MERROR SETA  &ERROR\n         AIF   ('&NAME' NE '').SKIPNAM\n         MNOTE 4,'NO MODULE NAME SPECIFIED - ''TEMPNAME'' ASSUMED'\n&PROGNAM SETC  'TEMPNAME'\n.SKIPNAM ANOP\n&$MABEND SETA  &ABEND              ABEND CODE FOR PROC ERROR\n&$LINK   SETC  '&LINK'             UNIVERSAL LINK REGISTER\n&$MPLVL  SETA  1                   PROC LEVEL\n&$MSECT(1) SETC '&PROGNAM'         MAIN CSECT\n&$MNBASE SETA  (N'&BASE)           MAX BASE REGS\n&$MBLATH SETA  0\n         AIF   ('&BLATHER' EQ 'NONE').CONT00\n&$MBLATH SETA  1\n         AIF   ('&BLATHER' EQ 'MUM').CONT00\n&$MBLATH SETA  2\n         AIF   ('&BLATHER' EQ 'QUIET').CONT00\n&$MBLATH SETA  3\n         AIF   ('&BLATHER' EQ 'MODERATE').CONT00\n&$MBLATH SETA  4\n         AIF   ('&BLATHER' EQ 'INFORMATIVE').CONT00\n&$MBLATH SETA  5\n         AIF   ('&BLATHER' EQ 'TALKATIVE').CONT00\n&$MBLATH SETA  6\n         AIF   ('&BLATHER' EQ 'SUBSTANTIAL').CONT00\n&$MBLATH SETA  7\n         AIF   ('&BLATHER' EQ 'GABBY').CONT00\n&$MBLATH SETA  8\n         AIF   ('&BLATHER' EQ 'VERBOSE').CONT00\n&$MBLATH SETA  9\n         AIF   ('&BLATHER' EQ 'PROLIFIC').CONT00\n&$MBLATH SETA  1\n.CONT00  ANOP\n&PROGNAM CSECT                     PUT INSTRUCTIONS FIRST\nDATAAREA CSECT                     DEFINE DATA AREA CSECT\nSAVEAREA DC    18F'0'              STANDARD SAVE AREA\n         AIF   ('&INTRO' EQ 'NO').SKINTR2\n$INTRO   WTO   '&PROGNAM EXECUTING ON 11/11/11 AT 00.00.00',MF=L\n&TEMP    SETA  K'&PROGNAM\n         ORG   $INTRO+18+&TEMP\n$EXDT    DC    CL8' '\n         ORG   $INTRO+30+&TEMP\n$EXTM    DC    CL8' '\n         ORG   ,\n.SKINTR2 ANOP\n&PROGNAM CSECT                     BACK TO EXECUTABLE CSECT\n         EQUATE\n&TEMP    SETA  1                   FOR SETTING UP BASE REGS\n         AIF   ('&NBASE' EQ '').LOOP01 OK IF NULL\n         AIF   (&NBASE LE N'&BASE).LOOP01 OK IF LE # OF BASE REGS\n&I       SETA  N'&BASE\n         MNOTE 4,'*    NUMBER OF BASE REGS REQUESTED (&NBASE) IS GREATEC\n               R THAN NUMBER'\n         MNOTE 0,'*    PROVIDED (&I); &I WILL BE INITIALIZED.'\n.LOOP01  AIF   ('&BASE(&TEMP)' EQ '0').ERR1\n         AIF   ('&BASE(&TEMP)' EQ 'R0').ERR1\n         AIF   ('&BASE(&TEMP)' EQ '1').ERR1\n         AIF   ('&BASE(&TEMP)' EQ 'R1').ERR1\n         AIF   ('&BASE(&TEMP)' EQ '13').ERR1\n         AIF   ('&BASE(&TEMP)' EQ 'R13').ERR1\n         AIF   ('&BASE(&TEMP)' EQ '14').ERR1\n         AIF   ('&BASE(&TEMP)' EQ 'R14').ERR1\n         AIF   ('&BASE(&TEMP)' EQ '15').ERR1\n         AIF   ('&BASE(&TEMP)' EQ 'R15').ERR1\n         AGO   .OK01\n.ERR1    MNOTE 12,'''&BASE(&TEMP)'' IS INVALID AS BASE REGISTER'\n         MNOTE *,'MACRO ABORTED'\n         MEXIT\n.OK01    ANOP\n&TEMP2   SETA  1\n.LOOP02  AIF   (&TEMP2 EQ &TEMP).OK02\n         AIF   ('&BASE(&TEMP)' EQ '&BASE(&TEMP2)').ERR1\n&TEMP2   SETA  &TEMP2+1\n         AGO   .LOOP02\n.OK02    ANOP\n&$BASE(&TEMP) SETC '&BASE(&TEMP)'  MOVE TO GLOBAL SET SYMBOL\n&TEMP    SETA  &TEMP+1             BUMP\n         AIF   (&TEMP LE &$MNBASE).LOOP01 BACK IF MORE TO DO\n&TEMP    SETA  (&$MNBASE)          SET TO MAX # OF BASE REGS\n         AIF   (&$MNBASE EQ 1).SKIP02\n         AIF   ('&NBASE' EQ '').SKIP02 SKIP IF NOT SPECIFIED\n&TEMP    SETA  (&NBASE)            SET TO NUMBER FOR MAIN CSECT\n         AIF   (N'&BASE GE &NBASE).SKIP02 SKIP IF OK\n&TEMP    SETA  (N'&BASE)           LIMIT TO NUMBER PROVIDED\n.SKIP02  ANOP\n&$BASE(1) SETC '&BASE(1)'          SET FIRST GLOBAL BASE\n         STM   R14,R12,12(R13)     SAVE CALLER'S REGS\n         AIF   (&TEMP EQ 1).SETUP1 GO IF ONLY 1 BASE REG\n         LR    &BASE(1),R15        SET UP FIRST BASE REGISTER\n         DEFPGMID ,                STD PROG ID DEFINITION\n&$USING(1)  SETC  '&BASE(1)'       MOVE IN FIRST REG\n         LA    &BASE(&TEMP),2048   SET UP AN INCREMENT\n&TEMP2   SETA  2                   SET TEMP2 TO SECOND BASE\n.BASELUP AIF   (&TEMP2 GE &TEMP).FINBASE BRANCH IF DONE\n&TEMP3   SETA  &TEMP2-1            POINT TO PREVIOUS BASE\n&X       SETC  '&BASE(&TEMP2)'\n&Y       SETC  '&BASE(&TEMP3)'\n&Z       SETC  '&BASE(&TEMP)'\n         LA    &X,2048(&Y,&Z)      INITIALIZE ANOTHER BASE\n&$USING(1)  SETC  '&$USING(1),&BASE(&TEMP2)' ADD ADDITIONAL REG\n&TEMP2   SETA  &TEMP2+1            BUMP TO NEXT BASE\n         AGO   .BASELUP\n.FINBASE ANOP\n&TEMP2   SETA   &TEMP2-1           BACK UP TO NEXT-TO-LAST REG\n&X       SETC  '&BASE(&TEMP)'\n&Y       SETC  '&BASE(&TEMP2)'\n         LA    &X,2048(&Y,&X)      INITIALIZE LAST BASE\n&$USING(1) SETC '&$USING(1),&X'    FINAL BASE INTO USING\n         USING &PROGNAM,&$USING(1) ADDRESSABILITY FOR MAIN CSECT\n         AGO   .DONEBAS            GO SAVE REGS\n.SETUP1  LR    &BASE,R15           SET UP ONE BASE\n         DEFPGMID ,                STD PROG ID DEFINITION\n&$USING(1)  SETC  '&BASE(1)'       MOVE IN FIRST REG\n.DONEBAS XC    16(4,R13),16(R13)   SET DEFAULT ZERO RETURN CODE\n         L     R14,$MSAVEAD        GET ADDRESS OF DATAAREA CSECT\n         L     R1,0(,R1)           POINT TO PARM\n         LH    R15,0(,R1)          PARM LENGTH\n         STH   R15,PARMLEN         SAVE PARM LENGTH\n         LA    R15,1(,R15)         INCLUDE LENGTH\n         EX    R15,PARMMOVE        DO THE DIRT\n         ST    R14,8(,R13)         CHAIN\n         ST    R13,4(,R14)         . SAVE\n         LR    R13,R14             . AREAS\n         USING DATAAREA,R13        SET UP SECONDARY BASE\n         AIF   ('&INTRO' EQ 'NO').SKINTRO\n         FIRST 1\n           WTO   '&PROGNAM ASSEMBLED ON &SYSDATE AT &SYSTIME'\n           TIME  DEC\n           DTM   $EXTM,$EXDT\n           WTO   MF=(E,$INTRO)\n         ENDO  ,\n.SKINTRO ANOP\n         L     R1,SAVEAREA+4       POINT TO PREV SAVE AREA\n         L     R1,24(,R1)          RESET R1 FOR PARM PASSING\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "GOBACK": {"ttr": 3850, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00\\x00o\\x01\\x00\\x00o\\x18S\\x00\\x13\\x00\\x13\\x00\\x00\\xc2\\xc3\\xd6\\xc4\\xc8\\xe2\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-01-06T00:00:00", "modifydate": "2000-01-06T18:53:00", "lines": 19, "newlines": 19, "modlines": 0, "user": "BCODHS0"}, "text": "         MACRO\n&NAME    GOBACK &RC=\n         GBLC  &GSECT,&WSECT       LOCATION COUNTER NAMES\n         GBLC  &N                  NAME\n&N       SETC  '&NAME'             SET TO USER DEFINED NAME\n         VERSION 2\n         AIF   ('&RC' EQ '').RETURN\n&N       SETRC &RC                 SET RETURN CODE\n&N       SETC  ''                  NULLIFY\n.RETURN  ANOP\n&N       L     13,4(,13)           BACK CHAIN\n         LM    14,12,12(13)        RESTORE 14 THRU 12\n         BR    14                  EXIT PROGRAM\n         $WA\n         LTORG\n         $IA\n         AIF   (D'R0).SKIP20       GENERATE EQUATE STATEMENTS\n         EQUATE ,                  . IF NECESSARY\n.SKIP20  MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "GOTO": {"ttr": 3852, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00\\x00o\\x01\\x00\\x00o\\x18S\\x00\\x18\\x00\\x18\\x00\\x00\\xc2\\xc3\\xd6\\xc4\\xc8\\xe2\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-01-06T00:00:00", "modifydate": "2000-01-06T18:53:00", "lines": 24, "newlines": 24, "modlines": 0, "user": "BCODHS0"}, "text": "         MACRO\n&NAME    GOTO  &COND,&SECTION\n         COPY  $MGBLDEF\n         GBLC  &GBASE,&GLINK       SET BY 'SECTION' MACRO OR USER\n         LCLC  &OPCD,&X            FOR CONDITIONAL BRANCH & &SYSNDX\n         VERSION 2\n&X       SETC  '&SYSNDX'\n         AIF   (N'&SYSLIST EQ 1).SECOND GO IF ONLY ONE OPERAND\n         DC    0AL4(REF&X)         ERROR IF MACRO PARM NOT SECTION NAME\n         $AGOTO &SECTION,&X\n&NAME    LA    &GLINK,*+10         LEAVE TRACKS...\n         L     15,=A(&SECTION-16) LOAD 'GO TO' ADDRESS\n&OPCD    SETC  'B&COND.R'          SET TO 'BER', 'BNER', ETC.\n         &OPCD  15                 CONDITIONAL BRANCH\n         MEXIT                     WE'RE ALL DONE, FOLKS\n.SECOND  CNOP  2,4                 ALIGN 2ND HALFWORD OF WORD\n.*'THE FOLLOWING INSTRUCTION WILL CAUSE AN ''UNDEFINED SYMBOL'''\n.*'(CONT''D) ERROR IF &COND IS NOT THE NAME OF A SECTION'\n         DC    0AL4(REF&X)         ERROR IF OBJECT NOT SECTION NAME\n         $AGOTO &COND,&X\n&NAME    L     15,*+6              LOAD 'GO TO' ADDRESS\n         BASR  &GLINK,15           BRANCH AND LEAVE TRACKS\n         DC    A(&COND-16)         'GO TO' ADDRESS\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "HEXRTN": {"ttr": 3854, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00\\x00o\\x01\\x00\\x00o\\x18S\\x00\\xc7\\x00\\xc7\\x00\\x00\\xc2\\xc3\\xd6\\xc4\\xc8\\xe2\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-01-06T00:00:00", "modifydate": "2000-01-06T18:53:00", "lines": 199, "newlines": 199, "modlines": 0, "user": "BCODHS0"}, "text": "         TITLE 'HEXADECIMAL CONVERSION ROUTINE'\n         SPACE 2\n*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\n*        CONVERT ONE WORD OF DATA FROM EBCDIC TO PRINTABLE HEX        *\n*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\n         SPACE 2\nCVXWORD  PROC  SAVE=LINK           ONE WORD TO THE WISE\n         SPACE\n*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\n*        WORD TO BE CONVERTED MUST BE IN R1                           *\n*        PRINTABLE HEX ANSWER IS RETURNED IN R0-R1                    *\n*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\n         SPACE\n         ST    R1,$CVXEB           STORE IN WORK AREA\n         UNPK  $CVXPR,$CVXEB       EXPLODE THE DIGITS\n         MVZ   $CVXPR(8),=XL8'00'  ZERO OUT THE ZONE BITS FOR TR\n         TR    $CVXPR(8),$CVXTBL   MAKE DIGITS PRINTABLE\n         LM    R0,R1,$CVXPR        GIVE BACK TO CALLER\n         RETN  ,                   KEEP CONSTANTS LOCAL\n         SPACE\n         DC    0D'0'               EFFICIENT BOUNDARY FOR TBL & EB\n$CVXTBL  DC    C'0123456789ABCDEF' IDENTITY TABLE FOR PRINTING\n$CVXEB   DC    PL5'0'              EXTRA BYTE IS FOR UNPK\n         DC    0F'0'               GET BACK ON A BOUNDARY\n$CVXPR   DC    ZL9'0'              EXTRA BYTE IS FOR UNPK\n         SPACE\n         ENDP  ,                    END OF CVXWORD\n         TITLE 'CONVERT A LINE TO HEX'\n         SPACE\n*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\n*        CALLER MUST PASS ADDRESS OF DATA IN R1 - OUTPUT TO OUTLINE   *\n*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\n         SPACE\nCVXLINE  PROC  SAVE=ALL            SAVE 2-14\n         SPACE\n*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\n*        ADDRESS OF LINE TO BE CONVERTED MUST BE IN R1                *\n*        HEX 'DUMP' MOVED TO OUTLINE                                  *\n*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\n         SPACE\n         LR    R10,R1              SAVE POINTER\n         PCALL CVXWORD             GET PRINTABLE FOR ADDRESS\n         STCM  R0,15,$CVXADDR      STORE FIRST 4 HEX CHARS\n         STCM  R1,15,$CVXADDR+4    . NOW SECOND 4\n         LA    R2,$CVX1ST          POINT TO OUTPUT AREA\n         IF    (CLC,=CL5'REGS ',$CVXMSG,NE),OR,                        C\n               ((CLC,=CL5'0-7  ',$CVXMSG+5,NE),AND,                    C\n               (CLC,=CL5'8-15 ',$CVXMSG+5,NE)),THENDO\n           MVC   $CVXTXT,0(R10)    MOVE IN AS-IS\n           TR    $CVXTXT,$CVXTBL2  USER MAY CHANGE TABLE\n         ELSE  ,\n           MVC   $CVXTXT,=CL32'                                '\n         ENDELSE ,\n         DO    2                   MAJOR LOOP COUNTER\n           DO    4                 MINOR LOOP COUNTER\n             ICM   R1,15,0(R10)    WORD TO CONVERT\n             PCALL CVXWORD         GO CONVERT IT\n             STCM  R0,15,0(R2)     STORE FIRST 4 HEX CHARS\n             STCM  R1,15,4(R2)     . NOW SECOND 4\n             I     R10,4           BUMP INPUT POINTER\n             I     R2,9            BUMP OUTPUT POINTER\n           ENDO  ,                 BACK FOR ANOTHER WORD\n           I     R2,2              2 EXTRA AFTER 4 WORDS\n         ENDO  ,                   BACK FOR NEXT 4 WORDS\n         MVC   OUTLINE+1(132),$CVXLINE DATA - NO CCCHAR\n         PCALL PRINTRTN             AND CALL PRINTER ROUTINE\n         MVC   $CVXMSG,=C'          ' RESET\n         RETN  ,                    RETURN TO CALLER\n         SPACE\nDATAAREA CSECT\n         SPACE\n$CVXLINE DC    C'  '\n$CVXADDR DC    CL8' ',C' '         ADDRESS OF THIS MESS\n$CVX1ST  DC    CL8' ',C' ',CL8' ',C' ',CL8' ',C' ',CL8' ',C'   '\n$CVX2ND  DC    CL8' ',C' ',CL8' ',C' ',CL8' ',C' ',CL8' ',C'   *'\n$CVXTXT  DC    CL32' ',C'* '\n$CVXMSG  DC    CL10' '             FOR USER\n$CVXTBL2 DC    CL16'................'    00 - 0F\n         DC    CL16'................'    10 - 1F\n         DC    CL16'................'    20 - 2F\n         DC    CL16'................'    30 - 3F\n         DC    CL16' .........\u00a2.<(+|'    40 - 4F\n         DC    CL16'&&.........!$*);\u00ac'   50 - 5F\n         DC    CL16'-/........|,%_>?'    60 - 6F\n         DC    CL16'.........`:#@''=\"'   70 - 7F\n         DC    CL16'...............+'    80 - 8F\n         DC    CL16'................'    90 - 9F\n         DC    CL16'................'    A0 - AF\n         DC    CL16'................'    B0 - BF\n         DC    CL16'{ABCDEFGHI......'    C0 - CF\n         DC    CL16'}JKLMNOPQR......'    D0 - DF\n         DC    CL16'..STUVWXYZ......'    E0 - EF\n         DC    CL16'0123456789......'    F0 - FF\n         SPACE\nCVXLINE  CSECT\n         SPACE\n         ENDP  , END OF CVXLINE\n         TITLE 'CONVERT A BLOCK TO HEX'\n         SPACE\n*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\n* R1 MUST POINT TO 2 ADCONS - THE FIRST IS THE BEGINNING OF THE       *\n* BLOCK TO BE PRINTED, AND THE SECOND IS THE LAST BYTE TO BE          *\n* PRINTED. RC16 IS SET IF THE FIRST ADDRESS IS GREATER THAN THE       *\n* SECOND.                                                             *\n*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\n         SPACE\nCVXBLOCK PROC  SAVE=ALL\n         LM    R2,R3,0(R1)         START/END ADDRESSES\n         IF    (CLR,R2,R3,NH),THENDO START MUST BE <= END\n           SLR   R15,R15           SET RETURN CODE TO ZERO\n           STM   R2,R3,$CVXST      SAVE\n           MVI   CCCHAR,C'0'       DOUBLE SPACE FIRST LINE\n           LR    R4,R2             DUPLICATE BEGIN POINTER\n           SRL   R2,5              GET ADDRESS OF PREV 32 BYTE\n           SLL   R2,5              . BOUNDARY\n           ST    R2,$CVX32         SAVE\n           LR    R3,R4             DUPLICATE\n           SLR   R3,R2             R3 IS INDEX INTO 32 BYTE UNIT\n           LA    R6,$CVXCHAR(R3)   STARTING POINT FOR AS-IS\n           SLL   R3,1              DOUBLE INDEX\n           LA    R5,$CVXHEX(R3)    STARTING POINT FOR HEX\n           L     R7,$CVX32         START 32 BYTE BOUNDARY\n           LA    R8,31(,R7)        LAST CHAR OF LINE\n           IF    (CL,R8,$CVXEND,H),THENDO R8 IS MINIMUM\n             L     R8,$CVXEND      . OF 31+$CVX32 AND $CVXEND\n           ENDO ,                  R7 IS NOW SET\n           DO    WHILE=(CL,R8,$CVXEND,NH) DO-GROUP FOR ENTIRE BLOCK\n             IF   (CL,R8,$CVXEND,L),AND, SEE IF WE CAN DO ONE          C\n               (CLR,R4,R7,E),THENDO . COMPLETE LINE (EFFICIENT)\n               LR    R1,R4         POINT TO THIS BLOCK\n               PCALL CVXLINE       . AND GO CONVERT 32\n               I     R4,32         BUMP INPUT POINTER\n               IF    (CL,R8,$CVXEND,E),THENDO WAS THIS LAST PASS?\n                 I     R8,32       FORCE PAST 'END'\n               ELSE  ,             NOT LAST - CONTINUE\n                 LA    R8,63(,R7)  LAST CHAR OF FOLLOWING LINE\n                 I     R7,32       BUMP TO NEXT 'LINE'\n                 IF    (CL,R8,$CVXEND,H),THENDO R7 IS MINIMUM\n                   L     R8,$CVXEND . OF 32+$CVX32 AND $CVXEND\n                 ENDO  ,           R7 IS NOW SET\n               ENDELSE ,           END OF LAST-PASS LOGIC\n             ELSE  ,               CAN ONLY DO PART OF THIS LINE\n               LR    R1,R7         FOR CVXWORD\n               PCALL CVXWORD       CONV TO HEX\n               STCM  R0,15,$CVXADDR FIRST WORD\n               STCM  R1,15,$CVXADDR+4 SECOND\n               DO    WHILE=(CLR,R4,R8,NH) DO THRU 'R8'\n                 MVC   $CVXPL1,0(R4) MOVE 1 CHAR\n                 UNPK  $CVXZL2(3),$CVXPL1(2) EXPLODE\n                 MVZ   $CVXZL2,=X'0000' SET ZONES TO '0'\n                 TR    $CVXZL2,$CVXTBL3 MAKE PRINTABLE\n                 MVC   0(2,R5),$CVXZL2 MOVE TWO HEX NIBBLES\n                 MVC   0(1,R6),0(R4) MOVE ORIG BYTE\n                 I     R4          BUMP INPUT POINTER\n                 I     R5,2        BUMP HEX OUTPUT POINTER\n                 I     R6          BUMP CHAR OUTPUT POINTER\n               ENDO  ,             END OF THIS OUTPUT LINE\n               LA    R5,$CVXHEX    POINTER FOR HEX MOVE\n               MVC   $CVXTXT,$CVXCHAR MOVE 32 BYTES AS-IS\n               TR    $CVXTXT,$CVXTBL2 USER MAY CHANGE TABLE\n               LA    R2,$CVX1ST    'TO' POINTER\n               DO    2             OUTER LOOD TWO TIMES\n                 DO    4           INNER LOOP 4 TIMES\n                   MVC   0(8,R2),0(R5) ONE WORD CONVERTED TO HEX\n                   I     R2,9      BUMP 'TO' POINTER\n                   I     R5,8      BUMP 'FROM' POINTER\n                 ENDO ,            END OF HALF-LINE\n                 I     R2,2        TWO EXTRA MID-LINE\n               ENDO ,              END OF LINE\n               MVC   OUTLINE+1(132),$CVXLINE LINE TO OUTPUT AREA\n               PCALL PRINTRTN      CALL PRINT ROUTINE\n               MVC   $CVXHEX(96),SPACES INITIALIZE LINE\n               LA    R5,$CVXHEX    RESET\n               LA    R6,$CVXCHAR   . POINTERS\n               IF    (CL,R8,$CVXEND,E) THENDO WAS THIS LAST PASS?\n                 I     R8,32       FORCE PAST 'END'\n               ELSE  ,             NOT LAST - CONTINUE\n                 LA    R8,63(,R7)  LAST CHAR OF FOLLOWING LINE\n                 I     R7,32       BUMP TO NEXT 'LINE'\n                 IF    (CL,R8,$CVXEND,H),THENDO R7 IS MINIMUM\n                   L     R8,$CVXEND . OF 32+$CVX32 AND $CVXEND\n                 ENDO ,            R7 IS NOW SET\n               ENDELSE ,           END OF LAST-PASS LOGIC\n             ENDELSE ,             END OF CVXLINE CALL\n           ENDO ,                  BACK TO TEST FOR END OF BLOCK\n         ELSE  ,                   END OF 'MAIN'\n           LA    R15,16            RC=16 -> BAD INPUT POINTERS\n         ENDELSE  ,                DONE WITH THIS CALL TO CVXBLOCK\n         RETN  ,\n$CVXST   DC    A(*)            START OF INPUT\n$CVXEND  DC    A(*)            END OF INPUT\n$CVX32   DC    A(*)            32 BYTE BOUNDARY\n$CVXHEX  DC    CL64' '         32 BYTES CONVERTED TO HEX\n$CVXCHAR DC    CL32' '         32 BYTES AS-IS\n$CVXPL1  DC    PL1'0',C' '     FOR UNPACK\n$CVXZL2  DC    ZL2'0',C' '     FOR UNPACK\n$CVXTBL3 DC    C'0123456789ABCDEF' MAKE PRINTABLE\n         ENDP  ,               END OF CVXBLOCK\n*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "HROUTINE": {"ttr": 4097, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x98\"_\\x00\\x994\\x8f\\x102\\x00\\xcf\\x00\\xcf\\x00\\x00\\xc2\\xc3\\xd6\\xc4\\xc8\\xe2\\xf0@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1998-08-13T00:00:00", "modifydate": "1999-12-14T10:32:00", "lines": 207, "newlines": 207, "modlines": 0, "user": "BCODHS0"}, "text": "         TITLE 'HEXADECIMAL CONVERSION ROUTINE'\n         SPACE 2\n*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\n*        CONVERT ONE WORD OF DATA FROM EBCDIC TO PRINTABLE HEX        *\n*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\n         SPACE 2\n         GBLC  &GCVXL,&WCVXL       'LOCAL' SYMBOLS DECLARED HERE SO\n* USER IS NOT REQUIRED TO DEFINE &GSECT AND &WSECT IN OPEN CODE\n         MACRO\n         GETCVX &DUMMY             GET SYMBOLS INTO OPEN CODE\n         GBLC  &GSECT,&WSECT,&GCVXL,&WCVXL\n&GCVXL   SETC  '&GSECT'\n&WCVXL   SETC  '&WSECT'\n         MEND\n         VERSION 2\n         GETCVX ,                  INVOKE MACRO\nCVXWORD  SECTION ,                 ONE WORD TO THE WISE\n         SPACE\n*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\n*        WORD TO BE CONVERTED MUST BE IN R1                           *\n*        PRINTABLE HEX ANSWER IS RETURNED IN R0-R1                    *\n*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\n         SPACE\n         ST    R1,$CVXEB           STORE IN WORK AREA\n         UNPK  $CVXPR,$CVXEB       EXPLODE THE DIGITS\n         MVZ   $CVXPR(8),=XL8'00'  ZERO OUT THE ZONE BITS FOR TR\n         TR    $CVXPR(8),$CVXTBL   MAKE DIGITS PRINTABLE\n         LM    R0,R1,$CVXPR        GIVE BACK TO CALLER\n         RETN   ,                  KEEP CONSTANTS LOCAL\n         SPACE\n         DC    0D'0'               EFFICIENT BOUNDARY FOR TBL & EB\n$CVXTBL  DC    C'0123456789ABCDEF' IDENTITY TABLE FOR PRINTING\n$CVXEB   DC    PL5'0'              EXTRA BYTE IS FOR UNPK\n         DC    0F'0'               GET BACK ON A BOUNDARY\n$CVXPR   DC    ZL9'0'              EXTRA BYTE IS FOR UNPK\n         SPACE\n         ENDSECT ,                  END OF CVXWORD\n         TITLE 'CONVERT A LINE TO HEX'\n         SPACE\n*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\n*        CALLER MUST PASS ADDRESS OF DATA IN R1 - OUTPUT TO OUTLINE   *\n*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\n         SPACE\nCVXLINE  SECTION ,                 SAVE 2-11 & 14\n         SPACE\n*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\n*        ADDRESS OF LINE TO BE CONVERTED MUST BE IN R1                *\n*        HEX 'DUMP' MOVED TO OUTLINE                                  *\n*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\n         SPACE\n         LR    R10,R1              SAVE POINTER\n         PERFORM CVXWORD           GET PRINTABLE FOR ADDRESS\n         STCM  R0,15,$CVXADDR      STORE FIRST 4 HEX CHARS\n         STCM  R1,15,$CVXADDR+4    . NOW SECOND 4\n         LA    R2,$CVX1ST          POINT TO OUTPUT AREA\n         IF    (CLC,=CL5'REGS ',$CVXMSG,NE),OR,                        C\n               ((CLC,=CL5'0-7  ',$CVXMSG+5,NE),AND,                    C\n               (CLC,=CL5'8-15 ',$CVXMSG+5,NE)),THENDO\n           MVC   $CVXTXT,0(R10)    MOVE IN AS-IS\n           TR    $CVXTXT,$CVXTBL2  USER MAY CHANGE TABLE\n         ELSE  ,\n           MVC   $CVXTXT,=CL32'                                '\n         ENDELSE ,\n         DO    2                   MAJOR LOOP COUNTER\n           DO    4                 MINOR LOOP COUNTER\n             ICM   R1,15,0(R10)    WORD TO CONVERT\n             PERFORM CVXWORD       GO CONVERT IT\n             STCM  R0,15,0(R2)     STORE FIRST 4 HEX CHARS\n             STCM  R1,15,4(R2)     . NOW SECOND 4\n             I     R10,4           BUMP INPUT POINTER\n             I     R2,9            BUMP OUTPUT POINTER\n           ENDO  ,                 BACK FOR ANOTHER WORD\n           I     R2,2              2 EXTRA AFTER 4 WORDS\n         ENDO  ,                   BACK FOR NEXT 4 WORDS\n         MVC   OUTLINE+1(132),$CVXLINE DATA - NO CCCHAR\n         CALL  TRACERTN,(OUTLINE)\n         MVC   $CVXMSG,=C'          ' RESET\n         RETN   ,                   RETURN TO CALLER\n         SPACE\n&WCVXL   LOCTR\n         SPACE\n$CVXLINE DC    C'  '\n$CVXADDR DC    CL8' ',C' '         ADDRESS OF THIS MESS\n$CVX1ST  DC    CL8' ',C' ',CL8' ',C' ',CL8' ',C' ',CL8' ',C'   '\n$CVX2ND  DC    CL8' ',C' ',CL8' ',C' ',CL8' ',C' ',CL8' ',C'   *'\n$CVXTXT  DC    CL32' ',C'* '\n$CVXMSG  DC    CL10' '             FOR USER\n$CVXTBL2 DC    CL16'................'    00 - 0F\n         DC    CL16'................'    10 - 1F\n         DC    CL16'................'    20 - 2F\n         DC    CL16'................'    30 - 3F\n         DC    CL16' .........\u00a2.<(+|'    40 - 4F\n         DC    CL16'&&.........!$*);\u00ac'   50 - 5F\n         DC    CL16'-/........|,%_>?'    60 - 6F\n         DC    CL16'.........`:#@''=\"'   70 - 7F\n         DC    CL16'...............+'    80 - 8F\n         DC    CL16'................'    90 - 9F\n         DC    CL16'................'    A0 - AF\n         DC    CL16'................'    B0 - BF\n         DC    CL16'{ABCDEFGHI......'    C0 - CF\n         DC    CL16'}JKLMNOPQR......'    D0 - DF\n         DC    CL16'..STUVWXYZ......'    E0 - EF\n         DC    CL16'0123456789......'    F0 - FF\n         SPACE\n&GCVXL   LOCTR\n         SPACE\n         ENDSECT , END OF CVXLINE\n         TITLE 'CONVERT A BLOCK TO HEX'\n         SPACE\n*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\n* R1 MUST POINT TO 2 ADCONS - THE FIRST IS THE BEGINNING OF THE       *\n* BLOCK TO BE PRINTED, AND THE SECOND IS THE LAST BYTE TO BE          *\n* PRINTED. RC16 IS SET IF THE FIRST ADDRESS IS GREATER THAN THE       *\n* SECOND.                                                             *\n*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\n         SPACE\nCVXBLOCK SECTION ,\n         LM    R2,R3,0(R1)         START/END ADDRESSES\n         IF    (CLR,R2,R3,NH),THENDO START MUST BE <= END\n           SLR   R15,R15           SET RETURN CODE TO ZERO\n           STM   R2,R3,$CVXST      SAVE\n           MVI   CCCHAR,C'0'       DOUBLE SPACE FIRST LINE\n           LR    R4,R2             DUPLICATE BEGIN POINTER\n           SRL   R2,5              GET ADDRESS OF PREV 32 BYTE\n           SLL   R2,5              . BOUNDARY\n           ST    R2,$CVX32         SAVE\n           LR    R3,R4             DUPLICATE\n           SLR   R3,R2             R3 IS INDEX INTO 32 BYTE UNIT\n           LA    R6,$CVXCHAR(R3)   STARTING POINT FOR AS-IS\n           SLL   R3,1              DOUBLE INDEX\n           LA    R5,$CVXHEX(R3)    STARTING POINT FOR HEX\n           L     R7,$CVX32         START 32 BYTE BOUNDARY\n           LA    R8,31(,R7)        LAST CHAR OF LINE\n           IF    (CL,R8,$CVXEND,H),THENDO R8 IS MINIMUM\n             L     R8,$CVXEND      . OF 31+$CVX32 AND $CVXEND\n           ENDO ,                  R7 IS NOW SET\n           DO    WHILE=(CL,R8,$CVXEND,NH) DO-GROUP FOR ENTIRE BLOCK\n             IF   (CL,R8,$CVXEND,L),AND, SEE IF WE CAN DO ONE          C\n               (CLR,R4,R7,E),THENDO . COMPLETE LINE (EFFICIENT)\n               LR    R1,R4         POINT TO THIS BLOCK\n               PERFORM CVXLINE     . AND GO CONVERT 32\n               I     R4,32         BUMP INPUT POINTER\n               IF    (CL,R8,$CVXEND,E),THENDO WAS THIS LAST PASS?\n                 I     R8,32       FORCE PAST 'END'\n               ELSE  ,             NOT LAST - CONTINUE\n                 LA    R8,63(,R7)  LAST CHAR OF FOLLOWING LINE\n                 I     R7,32       BUMP TO NEXT 'LINE'\n                 IF    (CL,R8,$CVXEND,H),THENDO R7 IS MINIMUM\n                   L     R8,$CVXEND . OF 32+$CVX32 AND $CVXEND\n                 ENDO  ,           R7 IS NOW SET\n               ENDELSE ,           END OF LAST-PASS LOGIC\n             ELSE  ,               CAN ONLY DO PART OF THIS LINE\n               LR    R1,R7         FOR CVXWORD\n               PERFORM CVXWORD     CONV TO HEX\n               STCM  R0,15,$CVXADDR FIRST WORD\n               STCM  R1,15,$CVXADDR+4 SECOND\n               DO    WHILE=(CLR,R4,R8,NH) DO THRU 'R8'\n                 MVC   $CVXPL1,0(R4) MOVE 1 CHAR\n                 UNPK  $CVXZL2(3),$CVXPL1(2) EXPLODE\n                 MVZ   $CVXZL2,=X'0000' SET ZONES TO '0'\n                 TR    $CVXZL2,$CVXTBL3 MAKE PRINTABLE\n                 MVC   0(2,R5),$CVXZL2 MOVE TWO HEX NIBBLES\n                 MVC   0(1,R6),0(R4) MOVE ORIG BYTE\n                 I     R4          BUMP INPUT POINTER\n                 I     R5,2        BUMP HEX OUTPUT POINTER\n                 I     R6          BUMP CHAR OUTPUT POINTER\n               ENDO  ,             END OF THIS OUTPUT LINE\n               LA    R5,$CVXHEX    POINTER FOR HEX MOVE\n               MVC   $CVXTXT,$CVXCHAR MOVE 32 BYTES AS-IS\n               TR    $CVXTXT,$CVXTBL2 USER MAY CHANGE TABLE\n               LA    R2,$CVX1ST    'TO' POINTER\n               DO    2             OUTER LOOD TWO TIMES\n                 DO    4           INNER LOOP 4 TIMES\n                   MVC   0(8,R2),0(R5) ONE WORD CONVERTED TO HEX\n                   I     R2,9      BUMP 'TO' POINTER\n                   I     R5,8      BUMP 'FROM' POINTER\n                 ENDO ,            END OF HALF-LINE\n                 I     R2,2        TWO EXTRA MID-LINE\n               ENDO ,              END OF LINE\n               MVC   OUTLINE+1(132),$CVXLINE LINE TO OUTPUT AREA\n               CALL  TRACERTN,(OUTLINE)\n               MVC   $CVXHEX(96),SPACES INITIALIZE LINE\n               LA    R5,$CVXHEX    RESET\n               LA    R6,$CVXCHAR   . POINTERS\n               IF    (CL,R8,$CVXEND,E) THENDO WAS THIS LAST PASS?\n                 I     R8,32       FORCE PAST 'END'\n               ELSE  ,             NOT LAST - CONTINUE\n                 LA    R8,63(,R7)  LAST CHAR OF FOLLOWING LINE\n                 I     R7,32       BUMP TO NEXT 'LINE'\n                 IF    (CL,R8,$CVXEND,H),THENDO R7 IS MINIMUM\n                   L     R8,$CVXEND . OF 32+$CVX32 AND $CVXEND\n                 ENDO ,            R7 IS NOW SET\n               ENDELSE ,           END OF LAST-PASS LOGIC\n             ENDELSE ,             END OF CVXLINE CALL\n           ENDO ,                  BACK TO TEST FOR END OF BLOCK\n         ENDO  ,                   END OF 'MAIN'\n         RETN  ,\n$CVXST   DC    A(*)            START OF INPUT\n$CVXEND  DC    A(*)            END OF INPUT\n$CVX32   DC    A(*)            32 BYTE BOUNDARY\n$CVXHEX  DC    CL64' '         32 BYTES CONVERTED TO HEX\n$CVXCHAR DC    CL32' '         32 BYTES AS-IS\n$CVXPL1  DC    PL1'0',C' '     FOR UNPACK\n$CVXZL2  DC    ZL2'0',C' '     FOR UNPACK\n$CVXTBL3 DC    C'0123456789ABCDEF' MAKE PRINTABLE\n         ENDSECT ,             END OF CVXBLOCK\n*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "I": {"ttr": 4101, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00\\x00o\\x01\\x00\\x00o\\x18S\\x00\\x08\\x00\\x08\\x00\\x00\\xc2\\xc3\\xd6\\xc4\\xc8\\xe2\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-01-06T00:00:00", "modifydate": "2000-01-06T18:53:00", "lines": 8, "newlines": 8, "modlines": 0, "user": "BCODHS0"}, "text": "         MACRO                                                  SOS  00\n&NAME    I     &REG,&INCR          BUMP REG &REG BY &INCR       SOS  00\n         AIF   ('&INCR' EQ '').ONEPARM GO IF BUMP BY 1          SOS  00\n&NAME    LA    &REG,&INCR.(,&REG)  BUMP BY INCREMENT            SOS  00\n         MEXIT                                                  SOS  00\n.ONEPARM ANOP  COME HERE IF INCREMENT BY 1                      SOS  00\n&NAME    LA    &REG,1(,&REG)       UP IT BY 1                   SOS  00\n         MEND                                                   SOS  00\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IF": {"ttr": 4103, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\x01\\x7f\\x01\\x02\\x01\\x7f\\x10\\x17\\x00\\x84\\x00\\x84\\x00\\x00\\xc7\\xc5\\xd5\\xe3\\xd9\\xf0\\xf2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-01-17T00:00:00", "modifydate": "2002-01-17T10:17:00", "lines": 132, "newlines": 132, "modlines": 0, "user": "GENTR02"}, "text": "         MACRO\n&NAME    IF    &EXP                MULTIPLE OPERANDS VIA &SYSLIST\n         COPY  $MGBLDEF            BRING IN GLOBAL SYMBOLS\n         LCLA  &I,&J,&K            USED TO SCAN &SYSLIST OPERANDS\n         LCLC  &X,&Y,&OP,&OPND1,&OPND2,&OPND3,&C,&NC\n&$MRECUR SETA  &$MRECUR+1          INCREASE RECURSION COUNT\n&I       SETA  1                   SET TO FIRST POSITIONAL\n&$MNAME  SETC  '&NAME'             TAG FOR FIRST TEST\n.LOOP10  AIF   (N'&SYSLIST LT &I).FINISH GO TO FINISH IF DONE\n         AIF   ('&SYSLIST(&I)'(1,1) NE '(').FATAL   MUST BE '('\n         AIF   ('&SYSLIST(&I)'(2,1) EQ '(').RECURS GO IF NESTED\n&OP      SETC  '&SYSLIST(&I,1)'    OP-CODE IS ALWAYS 1ST SUB-OPERAND\n&J       SETA  (N'&SYSLIST(&I))    NUMBER OF SUBPARAMETERS FOR THIS ONE\n         AIF   (&J NE 2).TEST1     GO TEST FOR 1-OPERAND INST\n&$MNAME  &OP   ,                   ZERO OPERANDS - SET CONDITION CODE\n&$MC     SETC  '&SYSLIST(&I,2)'    CONDITION IS ALWAYS LAST SUB-OPERAND\n         AGO   .FINGEN             GO SET UP BRANCH INST\n.TEST1   ANOP  ,\n&OPND1   SETC  '&SYSLIST(&I,2)'    FIRST (ONLY?) OPERAND\n         AIF   (&J NE 3).TEST2     GO TEST FOR 2-OPERAND INST\n&$MNAME  &OP   &OPND1              ONE OPERAND - SET CONDITION CODE\n&$MC     SETC  '&SYSLIST(&I,3)'    CONDITION IS ALWAYS LAST SUB-OPERAND\n         AGO   .FINGEN             GO SET UP BRANCH INST\n.TEST2   ANOP  ,\n&OPND2   SETC  '&SYSLIST(&I,3)'    SECOND OPERAND\n         AIF   (&J NE 4).TEST3     GO TEST FOR 3-OPERAND INST\n&$MNAME  &OP   &OPND1,&OPND2       TWO OPERANDS - SET CONDITION CODE\n&$MC     SETC  '&SYSLIST(&I,4)'    CONDITION IS ALWAYS LAST SUB-OPERAND\n         AGO   .FINGEN             GO SET UP BRANCH INST\n.TEST3   ANOP  ,\n&OPND3   SETC  '&SYSLIST(&I,4)'    THIRD OPERAND\n         AIF   (&J NE 5).ERROR1    GO ISSUE ERROR MESSAGE\n&$MNAME  &OP   &OPND1,&OPND2,&OPND3 THREE OPERANDS - SET CONDITION CODE\n&$MC     SETC  '&SYSLIST(&I,5)'    CONDITION IS ALWAYS LAST SUB-OPERAND\n         AGO   .FINGEN             GO SET UP BRANCH INST\n.ERROR1  ANOP  ,\n&K       SETA  ((&I+1)/2)          GET SEQUENCE # OF PHRASE IN ERROR\n         MNOTE 12,'INVALID NUMBER OF PARMS (&J) IN CONDITIONAL PHRASE #*\n               &K &SYSLIST(&I); IT WILL BE DELETED FROM THE MACRO EXPAN*\n               SION'\n&I       SETA  &I+2                INCREMENT\n         AGO   .LOOP10             BACK FOR MORE\n.FINGEN  ANOP                      COND CODE NOW SET - TEST IT\n&$MNC    SETC  'N&$MC'             SET TO 'NOT'-CONDITION CODE\n         AIF   ('&$MC'(1,1) NE 'N').SKIP12 FALL THROUGH IF 'NE' ETC\n&$MNC    SETC  '&$MC'(2,1)         ORIG WAS 'NX' - SET TO 'X'\n.SKIP12  ANOP\n&$MNAME  SETC  ''                  C'MON - NO DUPLICATE TAGS, PLEASE\n         AIF   ('&SYSLIST(&I+1)' EQ 'OR').OR10 GO IF 'OR'\n         AIF   ('&SYSLIST(&I+1)' EQ   'AND').OR10 GO IF 'AND'\n         AGO   .FINISH             NOT 'OR' OR 'AND' - ASSUME END\n.RECURS  ANOP                      HERE FOR RECURSIVE CALL\n&$MNAME  IF    &SYSLIST(&I,1),&SYSLIST(&I,2),&SYSLIST(&I,3),           C\n               &SYSLIST(&I,4),&SYSLIST(&I,5),&SYSLIST(&I,6),           C\n               &SYSLIST(&I,7),&SYSLIST(&I,8),&SYSLIST(&I,9),           C\n               &SYSLIST(&I,10),&SYSLIST(&I,11),&SYSLIST(&I,12),        C\n               &SYSLIST(&I,13),&SYSLIST(&I,14),&SYSLIST(&I,15),        C\n               &SYSLIST(&I,16),&SYSLIST(&I,17),&SYSLIST(&I,18),        C\n               &SYSLIST(&I,19),&SYSLIST(&I,20),&SYSLIST(&I,21)\n.REC10   AIF   ('&$MFNAM1(&$MRECUR+1)' EQ '').REC12 GO IF NO FNAM1(+1)\n         AIF   ('&$MFNAM1(&$MRECUR)' EQ '').REC11 GO IF NO FNAM1\n&X       SETC  '&$MFNAM1(&$MRECUR+1)' TEMP FOR FNAM1(+1)\n&$MFNAM1(&$MRECUR+1) SETC ''       NULLIFY\n&X       EQU   &$MFNAM1(&$MRECUR)  EQUATE FOR NESTED LOGIC\n         AGO   .REC12              TEST PNAM1\n.REC11   ANOP\n&$MFNAM1(&$MRECUR) SETC '&$MFNAM1(&$MRECUR+1)' PROMOTE\n&$MFNAM1(&$MRECUR+1) SETC ''       NULLIFY\n.REC12   AIF   ('&$MPNAM1(&$MRECUR+1)' EQ '').REC19 GO IF NO PNAM1(+1)\n&$MNAME  SETC  '&$MPNAM1(&$MRECUR+1)' QUEUE FOR TEST INSTRUCTION\n&$MPNAM1(&$MRECUR+1) SETC ''       NULLIFY\n.REC19   AIF   ('&SYSLIST(&I+1)' EQ  'OR').OR10 GO IF 'OR'\n         AIF   ('&SYSLIST(&I+1)' EQ 'AND').OR10 GO IF 'AND'\n         AGO   .FINISH             NOT 'OR' OR 'AND' - ASSUME END\n.FATAL   MNOTE 8,'MISSING PARENS AT &SYSLIST(&I) - TERMINATED'\n         AGO   .MEND\n.OR10    ANOP                      COMMON FOR 'OR' AND 'AND'\n&NC      SETC  '&$MNC'             GEN LOCAL VARIABLES FOR\n&C       SETC  '&$MC'              . CONDITION CODE TESTS\n&$MNC    SETC  ''                  NULLIFY THE GLOBAL VARIABLES\n&$MC     SETC  ''                  . SINCE LOCALS WILL BE USED\n         AIF   ('&SYSLIST(&I+1)' EQ 'AND').AND10    GO IF 'AND'\n         AIF   ('&$MPNAM1(&$MRECUR)' NE '').OR12 SKIP IF NOT NEEDED\n         $MGPNAME                  GET A NEW 'PNAM1'\n.OR12    J&C   &$MPNAM1(&$MRECUR)  B IF TRUE TO 'PASS' TAG\n&I       SETA  &I+2                BUMP TO NEXT OPERAND\n         AIF   ('&$MNAME' EQ '').OR20 GO IF NO PNAM1 QUEUED\n&$MNAME  EQU   &$MPNAM1(&$MRECUR)  EQUATE FOR NESTED LOGIC\n.OR20    ANOP\n&$MNAME  SETC  '&$MFNAM1(&$MRECUR)' QUEUE TAG FOR 'AND' FAILED\n&$MFNAM1(&$MRECUR) SETC ''         NULLIFY TAG\n         AGO   .LOOP10             AND CONTINUE\n.AND10   AIF   ('&$MFNAM1(&$MRECUR)' NE '').AND12 SKIP IF NOT NEEDED\n         $MGFNAME                  GET A NEW 'FNAM1'\n.AND12   J&NC  &$MFNAM1(&$MRECUR)  B IF FALSE TO 'FAIL' TAG\n&I       SETA  &I+2                BUMP TO NEXT\n         AGO   .LOOP10             AND BACK\n.FINISH  AIF   (&$MRECUR GT 1).MEND NO PROCESSING FOR NESTED\n&$MDGLVL SETA  &$MDGLVL+1          UP DO-GROUP LEVEL\n&$MDGSEQ(&$MDGLVL) SETC '&SYSNDX'  SET DO-GROUP SEQUENCE\n&$MIFELS(&$MDGLVL) SETC 'F'        FOR 'IF-FAILED' BRANCH\n&$MDGNAM(&$MDGLVL) SETC '&NAME'    SET NAME FOR 'ENDO'\n         AIF   ('&$MCVERB(&$MDGLVL)' NE '').SKIP01 ALREADY DEFINED?\n&$MCVERB(&$MDGLVL) SETC 'IF'       SHOW VERB BEING EXECUTED\n.SKIP01  ANOP\n&NC      SETC  '&$MNC'             SET LOCAL VARIABLE\n&X       SETC  '$MDF&$MDGSEQ(&$MDGLVL)' GET 'ENDO' TAG\n         AIF   ('&$MBLATH' NE 'PROLIFIC').FIN02\n         MNOTE *,'***     LOGIC NESTING LEVEL NOW &$MDGLVL'\n.FIN02   AIF   ('&$MFNAM1(1)' NE '').FIN05 GO IF F-TAG NEEDED\n         AIF   ('&$MNC' EQ '').FIN08 SKIP IF B&NC NOT REQ'D\n         J&NC  &X                  B AROUND DO-GROUP IF FALSE\n&$MNC    SETC  ''                  FOR FUTURES\n         AGO   .FIN08              EXIT\n.FIN05   AIF   ('&$MC' EQ '').FIN07 SKIP IF B&C NOT REQ'D\n         J&NC  &X                  B AROUND DO-GROUP IF FALSE\n&$MNC    SETC  ''                  FOR FUTURES\n.FIN07   ANOP\n&X       SETC  '&$MFNAM1(1)'       GET 'FNAM1' FROM LEVEL 1\n&$MFNAM1(&$MRECUR) SETC  ''        NULLIFY\n&Y       SETC  '$MDF&$MDGSEQ(&$MDGLVL)' GET 'ENDO' TAG\n&X       EQU   &Y                  EQUATE FOR NESTED LOGIC\n.FIN08   AIF   ('&$MNAME' EQ '').FIN10 GO IF NO TAG QUEUED\n&$MNAME  DC    0H'0'               ESTABLISH NAME AND ADDRESS\n.FIN10   ANOP\n&X       SETC  '&$MPNAM1(1)'       GET 'PNAM1' FROM LEVEL 1\n         AIF   ('&X' EQ '').MEND   GO IF NO 'PNAM1' FROM LEVEL 1\n&$MPNAM1(1) SETC  ''        NULLIFY\n&X       DC    0H'0'               ESTABLISH NAME AND ADDRESS\n.MEND    ANOP                      STANDARD EXIT\n&$MRECUR SETA  &$MRECUR-1          REDUCE RECURSION COUNT\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "INPUT1": {"ttr": 4106, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00\\x00o\\x01\\x00\\x00o\\x18S\\x00\\x95\\x00\\x95\\x00\\x00\\xc2\\xc3\\xd6\\xc4\\xc8\\xe2\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-01-06T00:00:00", "modifydate": "2000-01-06T18:53:00", "lines": 149, "newlines": 149, "modlines": 0, "user": "BCODHS0"}, "text": "         MACRO\n&NAME    INPUT1 &IOAREA=,&LRECL=\n         GBLC  &PREF,&DCBDSW,&DCBDGEN,&WAREA\n         GBLC  &GSECT,&WSECT       SECTION NAMES\n         VERSION 2\n&PREF    SETC  'UT1'\n         AIF   ('&NAME' EQ '').SKIP01\n&PREF    SETC  '&NAME'\n.SKIP01  ANOP\n&WAREA   SETC  '&IOAREA'\n         AIF   ('&IOAREA' NE '').SKIP02\n&WAREA   SETC  '&PREF.WORK'\n.SKIP02  ANOP\n         TITLE 'SYSUT1 INPUT ROUTINE'\n         SPACE 2\n***********************************************************************\n* 'UT1INPUT' READS EACH INPUT RECORD, AND AT EOF SETS UT1EOFSW        *\n***********************************************************************\n         SPACE\n&PREF.INPUT SECTION\n         FIRST 1                   CHECK OPEN FIRST TIME ONLY\n           IF    (TM,SYS&PREF+48,X'10',NO),THENDO OPENED?\n             PERFORM &PREF.PREP    SEE IF WE CAN GET IT OPENED\n             IF    (TM,SYS&PREF+48,X'10',NO),THENDO OPEN FAIL?\n               ABEND 16,DUMP       MIGHT AS WELL QUIT NOW\n             ENDO  , ** NOTE ** POSSIBLE TO ADD DYNALLOC CODE HERE TO\n           ENDO  ,   ** NOTE ** . FORCE ALLOCATION FOR PRINTER FILE.\n         ENDO\n         IF    (CLI,&PREF.EOFSW,C'Y',NE),THENDO DO IF NOT EOF\n           GET   SYS&PREF,&WAREA   READ NEXT INPUT RECORD\n           AP    &PREF.COUNT,=P'1' BUMP INPUT COUNTER\n         ELSE  ,                   ELSE IT IS EOF...\n           FIRST 5                 FIVE WARNINGS IN PLENTY\n             WTO  'READ PAST END-OF-FILE ON SYS&PREF' FLAG ERROR\n           ENDO  ,\n         ENDELSE ,\n         RETN ,                    AND RETURN\n&PREF._SET_EOF MVI &PREF.EOFSW,C'Y' SET EOFSW\n         ENDSECT ,                 AND RETURN\n         TITLE 'SYSUT1 FILE VERIFICATION ROUTINE AND DCB'\n         SPACE 2\n***********************************************************************\n* SYSUT1 VERIFICATION ROUTINE                                         *\n***********************************************************************\n         SPACE\n&PREF.PREP SECTION\n         SLR   R15,R15             SET ZERO RETURN CODE\n         RDJFCB MF=(E,&PREF.RJFCB)  CHECK IT OUT\n         IF    (LTR,R15,R15,NZ),THENDO DO IF FAILED\n           LA    R15,4            4 RETURN CODE\n           RETN ,                 RETURN TO CALLER\n         ENDO  ,\n         IF    (CLI,&PREF.JNVOL,X'00',E),THENDO DO IF NO VOLS ON JCL\n           LOCATE &PREF.LST        SEARCH THE CATALOG\n           IF    (LTR,R15,R15,NZ),OR,          IF LOCATE FAILED        C\n               (OC,&PREF.LNVOL,&PREF.LNVOL,Z),THENDO\n             LA    R15,8          8 RETURN CODE\n             RETN ,               RETURN TO CALLER\n           ENDO  ,\n           MVC   &PREF.VOL,&PREF.LVOL1 MOVE IN FIRST VOLUME FROM LOCATE\n         ELSE    ,                 VOL IS ON JCL\n           MVC   &PREF.VOL,&PREF.JVOLS MOVE IN FIRST VOLUME FROM JFCB\n         ENDELSE ,\n         OBTAIN &PREF.LST2         GET DSCB\n         IF    (LTR,R15,R15,NZ),THENDO DO IF OBTAIN FAILED\n           LA    R15,12            12 RETURN CODE\n           RETN ,                  RETURN TO CALLER\n         ENDO  ,\n         MVC   &PREF.DSNM(44),&PREF.JDSN COPY DATA SET NAME\n         IF    (CLI,&PREF.JMEM,C' ',NE),THENDO DO IF MEMBER PRESENT\n           LA    R2,&PREF.DSNM+43  LAST CHAR OF DSNAME\n           DO    UNTIL=(CLI,0(R2),C' ',NE) FIND LAST NON-BLANK\n             BCTR  R2,0            DECREMENT POINTER\n           ENDO  ,\n           MVI   1(R2),C'('        FOR '(MEMBER)'\n           LA    R3,&PREF.JMEM     1ST CHAR OF MEMBER\n           DO    8                 MOVE NO MORE THAN 8\n             IF    (CLI,0(R3),C' ',NE),THENDO DO IF NON-BLANK\n               MVC   2(1,R2),0(R3) MOVE 1 CHARACTER\n               I    R2             BUMP OUTPUT\n               I    R3             BUMP INPUT\n             ENDO  ,\n           ENDO  ,\n           MVI   2(R2),C')'        CLOSE PARENS\n         ENDO  ,\n         OPEN  ,TYPE=J,MF=(E,&PREF.RJFCB) OPEN THE SUCKER\n         IF   (TM,SYS&PREF.+DCBOFLGS-IHADCB,DCBOFOPN,NO),THENDO FAILED?\n           LA    R15,20            20 RETURN CODE\n         ENDO  ,\n         ENDSECT\n&WSECT   LOCTR\n&PREF.VOL DC   CL6' '              WILL HOLD VOL FROM JFCB OR CATALOG\n&PREF.DSNM DC  CL54' '             DATA.SET.NAME(MEMBER)\n         PUSH  PRINT\n         PRINT NOGEN\nSYS&PREF DCB   DDNAME=SYS&PREF,                                        C\n               DSORG=PS,                                               C\n               MACRF=GM,                                               C\n               EXLST=&PREF.EXIT,                                       C\n               EODAD=&PREF._SET_EOF\n         POP   PRINT\n&PREF.RJFCB RDJFCB SYS&PREF.,MF=L  LIST PORTION\n&PREF.EXIT DC  0F'0',X'87',AL3(&PREF.JFCB) ONLY INTERESTED IN JFCB\n&PREF.JFCB DC  0D'0'               JOB FILE CONTROL BLOCK\n&PREF.JDSN DC  CL44' '             DATA SET NAME\n&PREF.JMEM DC  CL8' ',65X'00'      MEMBER NAME\n&PREF.JNVOL DC X'00'               # OF VOLUMES\n&PREF.JVOLS DC 5XL6'00',28X'00'    UP TO 5 VOLSERS\n&PREF.LST2 CAMLST SEARCH,&PREF.JDSN,&PREF.VOL,&PREF.DSCB FOR 'OBTAIN'\n&PREF.DSCB DC  0D'0'               DATA SET CONTROL BLOCK\n         DC    38X'00'             - LOADED BY 'OBTAIN' MACRO\n&PREF.DSORG DC X'0000'\n&PREF.RECFM DC X'00'\n&PREF.OPTCD DC X'00'\n&PREF.BLKL DC  H'0'\n&PREF.LRECL DC H'0'\n         DC    50X'00'\n&PREF.LST CAMLST NAME,&PREF.JDSN,,&PREF.STBLK FOR 'LOCATE'\n&PREF.STBLK DC 0D'0'               ORIGIN OF LOCATE INFO\n&PREF.LNVOL DC H'0'                NUMBER OF VOLUMES\n&PREF.DEVT1 DC XL4'00'             DEVTYPE FOR VOL1\n&PREF.LVOL1 DC CL6' '              VOLSER FOR VOL1\n         DC    19XL12'00'\n         DC    10X'00'\n&PREF.TTR DC   XL3'00'             TTR FOR DSCB\n         DC    4X'00'\n         DC    CL6' '\n         AIF   ('&DCBDSW' EQ 'NO').SKIP50\n&DCBDSW  SETC  'NO'\n         PUSH  PRINT\n         AIF   ('&DCBDGEN' EQ 'GEN').GENOK\n&DCBDGEN SETC  'NOGEN'\n.GENOK   PRINT &DCBDGEN\n         DCBD  DSORG=PS\n&SYSECT  CSECT\n&WSECT   LOCTR\n         POP   PRINT\n.SKIP50  ANOP\n         SPACE\n&PREF.EOFSW DC C'N'                SET TO 'Y' AT &PREF.EOF\n         SPACE\n         AIF   ('&IOAREA' NE '').SKIP90\n&PREF.WORK DS  CL&LRECL\n.SKIP90  ANOP\n&PREF.COUNT DC PL8'0'\n         AIF   ('&WSECT' EQ '&SYSLOC').MEND\n&SYSECT  CSECT\n&GSECT   LOCTR\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "INTOFDTE": {"ttr": 4110, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x995\\x1f\\x00\\x995\\x1f\\t\\x01\\x00\\x9e\\x00\\x9e\\x00\\x00\\xc2\\xc3\\xd6\\xc4\\xc8\\xe2\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-17T00:00:00", "modifydate": "1999-12-17T09:01:00", "lines": 158, "newlines": 158, "modlines": 0, "user": "BCODHS0"}, "text": "INTOFDTE CSECT ,                   ENTRY POINT FOR GREGORIAN CONVERSION\n         USING *,R15               INFORM ASSEMBLER\n         MVI   DATETYPE,C'G'       SET TO PROCESS 'G'REGORIAN\n         B     CONTINUE            SKIP AROUNT MARKERS\n         ENTRY INTOFDAY\n         PRINT NOGEN\nINTOFDAY DS    0H                  ENTRY POINT FOR JULIAN CONVERSION\n         USING *,R15               INFORM ASSEMBLER\n         MVI   DATETYPE,C'J'       SET TO PROCESS 'J'ULIAN\n         B     CONTINUE            SKIP AROUNT MARKERS\n         DROP  R15                 FORGET IT\n         DC    C'********        '\n         DC    C'INTOFDTE ASSEMBLED ON '\n         DC    C'&SYSDATE AT &SYSTIME'\n         DC    C'        ********'\nCONTINUE DS    0H\n         STM   R14,R12,12(R13)     SAVE REGS\n         BASR  R12,0               COMMON BASE\n         USING *,R12               MAKE USEABLE\n         SLR   R15,R15             ASSUME R/C ZERO\n         ST    R15,16(,R13)        STUFF R/C BACK INTO SAVEAREA\n         LA    R14,SAVEAREA        POINT TO MY SAVE AREA\n         ST    R14,8(,R13)         FORWARD CHAIN\n         ST    R13,4(,R14)         BACK CHAIN\n         LR    R13,R14             SET UP MY SAVEAREA\n         LM    R10,R11,0(R1)       PARM POINTERS\n         USING YYYYMMDD,R10        INPUT PARM\n         USING USERDAYS,R11        CALCULATED\n         MVC   TESTAREA,YYYYMMDD   COPY\n         TR    TESTAREA,VALIDTBL   CHECK EACH DIGIT FOR NUMERIC\n         IF    (CLI,DATETYPE,C'J',E),THENDO IF 'J'ULIAN THEN\n           IF    (CLC,TESTAREA(7),YYYYMMDD,NE),THENDO TEST 7 POSITIONS\n             UNPK  USERDAYS,=Z'1'  FAILED - FLAG ERROR\n             B     ERREXIT         AND AMSCRAY\n           ENDIF ,\n         ELSE  ,                   MUST BE 'G'REGORIAN\n           IF    (CLC,TESTAREA(8),YYYYMMDD,NE),THENDO TEST 8 POSITIONS\n             UNPK  USERDAYS,=Z'2'  FAILED - FLAG ERROR\n             B     ERREXIT         AND AMSCRAY\n           ENDIF ,\n         ENDO  ,\n         IF    (CLC,YYYYMMDD(4),=C'1601',L),THENDO SAME AS COBOL\n           UNPK  USERDAYS,=Z'3'\n           B     ERREXIT         FLUNK IF NECESSARY\n         ENDIF ,\n         MVI   ISITLEAP,C' '       START WITH 'NULL'\n         PACK  DIVIDEND,YYYYMMDD(4) SLIP INTO SOMETHING COMFORTABLE\n         SP    DIVIDEND,=P'1601'   CALC OFFSET YEAR COUNT\n         DP    DIVIDEND,=PL3'400'  GET COUNT OF 400-YEAR GROUPS\n         ZAP   ANSWER,QUOTIENT     COPY TO ANSWER CELL\n         IF    (CP,REMAINDER,=P'399',E),THENDO EVERY 400TH\n           MVI   ISITLEAP,C'L'                 . IS A LEAP YEAR\n         ENDIF ,\n         PACK  DIVIDEND,YYYYMMDD(4) COPY\n         SP    DIVIDEND,=P'1601'    OFFSET\n         DP    DIVIDEND,=PL3'100'   GET COUNT OF 100-YEAR GROUPS\n         SP    ANSWER,QUOTIENT      ACCUMULATE\n         IF    (CLI,ISITLEAP,C' ',E),AND,        REMAINING 100TH       X\n               (CP,REMAINDER,=P'99',E),THENDO    . YEARS ARE\n           MVI   ISITLEAP,C'S'                   . NOT LEAP YEARS\n         ENDIF ,\n         PACK  DIVIDEND,YYYYMMDD(4) GET APPROX. COUNT OF\n         SP    DIVIDEND,=P'1601'    . LEAP YEARS SINCE\n         DP    DIVIDEND,=PL3'4'     . 1601\n         AP    ANSWER,QUOTIENT     ADD APPROX. LEAP YEAR ADJUSTMENT\n         IF    (CLI,ISITLEAP,C' ',E),THENDO      REMAINING 4TH YEARS\n           IF    (CP,REMAINDER,=P'3',E),THENDO   . ARE\n             MVI   ISITLEAP,C'L'                 . LEAP YEARS\n           ELSE  ,                               . BUT\n             MVI   ISITLEAP,C'S'                 . THE REST AREN'T\n           ENDIF ,\n         ENDIF ,\n         IF    (CLI,DATETYPE,C'J',E),THENDO IF 'J'ULIAN THEN...\n           IF    (CLI,ISITLEAP,C'S',E),AND, IF STD YEAR  *AND*         X\n               (CLC,YYYYMMDD+4(3),=C'365',H),OR, > 365 *OR*            X\n               (CLC,YYYYMMDD+4(3),=C'366',H),THENDO LEAP AND > 366 THEN\n             UNPK  USERDAYS,=Z'4'\n             B     ERREXIT      FLUNK IF BAD JULIAN DAY COUNT\n           ENDIF ,\n         ELSE  ,\n           IF  (CLC,YYYYMMDD+4(2),=C'00',E),OR,    MM CAN'T BE 00      X\n               (CLC,YYYYMMDD+4(2),=C'12',H),OR,    . OR > 12           X\n               (CLC,YYYYMMDD+6(2),=C'00',E),OR,    . DD CAN'T BE 00    X\n               (CLC,YYYYMMDD+6(2),=C'31',H),THENDO . OR > 31\n             UNPK  USERDAYS,=Z'5'\n             B     ERREXIT         FLUNK IF NECESSARY\n           ENDIF ,\n           IF    ((CLC,YYYYMMDD+4(2),=C'04',E),OR,   APRIL             X\n               (CLC,YYYYMMDD+4(2),=C'06',E),OR,    JUNE                X\n               (CLC,YYYYMMDD+4(2),=C'09',E),OR,    SEPTEMBER           X\n               (CLC,YYYYMMDD+4(2),=C'11',E)),AND,  AND NOVEMBER        X\n               (CLC,YYYYMMDD+6(2),=C'30',H),THENDO FOR > 30\n             UNPK  USERDAYS,=Z'6' TSK TSK TSK\n             B     ERREXIT        FLUNK IF 31 IN APR MAY SEP OR NOV\n           ENDIF ,\n           IF    (CLC,YYYYMMDD+4(2),=C'02',E),THENDO  IF MONTH IS FEB..\n             IF    (CLI,ISITLEAP,C'S',E),AND, IF STD YEAR  *AND*       X\n               (CLC,YYYYMMDD+6(2),=C'28',H),OR, > 28 *OR*              X\n               (CLC,YYYYMMDD+6(2),=C'29',H),THENDO  > 29 THEN...\n               UNPK  USERDAYS,=Z'7' TSK TSK TSK\n               B     ERREXIT      29 OR 30 IN STD OR 30 IN LEAP\n             ENDIF ,\n           ENDIF ,\n         ENDIF ,\n         PACK  DIVIDEND,YYYYMMDD(4) CONVERT\n         SP    DIVIDEND,=P'1601'   GET YEAR OFFSET\n         MP    DIVIDEND,=P'365'    GET DAY COUNT\n         AP    ANSWER,DIVIDEND     ACCUMULATE\n         IF    (CLI,DATETYPE,C'J',E),THENDO DO IF 'J'ULIAN SPECIFIED\n           PACK  WS_PL2,YYYYMMDD+4(3) GET JULIAN DAYS\n           AP    ANSWER,WS_PL2     AND ADD IT IN\n         ELSE  ,                   DARN !!! - MUST BE GREGORIAN\n           PACK  DOUBLE,YYYYMMDD+4(2)    GET MONTH COUNT\n           CVB   R2,DOUBLE         BINARY IT\n           SLL   R2,1              DOUBLE IT FOR 2-BYTE DAY COUNTS\n           IF    (CLI,ISITLEAP,C'L',E),THENDO DO IF LEAP YEAR\n             LA    R2,LEAPDAYS-2(R2) POINT TO ELEMENT IN LEAP TABLE\n           ELSE  ,                 DO IF NOT LEAP YEAR\n             LA    R2,STDDAYS-2(R2) POINT TO ELEMENT IN STD TABLE\n           ENDIF ,\n           AP    ANSWER,0(2,R2)    ADD IN DAY COUNT OF PRECEDING MONTHS\n           PACK  WS_PL2,YYYYMMDD+6(2) GET DAY COUNT\n           AP    ANSWER,WS_PL2        . AND ADD IT IN\n         ENDIF ,\n         OI    ANSWER+7,X'0F'      NORMALIZE SIGN\n         UNPK  USERDAYS,ANSWER     GIVE BACK TO CALLER\n         B     RETURN              COMMON EXIT\nERREXIT  DS    0H\n         UNPK  USERDAYS,=X'0F'     SET CALLER AREA TO ZEROS\nRETURN   DS    0H                  PROVIDE STD RETURN LINKAGE\n         L     R13,4(,R13)         BACK CHAIN\n         LM    R14,R12,12(R13)     RESTORE REGS\n         DROP  R12                 NEGATE ADDRESSABILITY\n         BR    R14                 RETURN\nSAVEAREA DC    18F'0'              STD REG SAVE AREA\nDOUBLE   DC    D'0'                WORK AREA FOR CVB\nLEAPDAYS DC    PL2'0,31,60,91,121,152,182,213,244,274,305,335'\nSTDDAYS  DC    PL2'0,31,59,90,120,151,181,212,243,273,304,334'\nISITLEAP DC    C' '                LOGIC SETS TO 'L'EAP OR 'S'TANDARD\nDATETYPE DC    C' '                'J' FOR JULIAN\nDIVIDEND DC    PL8'0' TOTAL DIVIDEND AREA  -->|\\\nQUOTIENT EQU   DIVIDEND+0,5,C'P'           -->| > KEEP TOGETHER\nREMAINDER EQU  DIVIDEND+5,3,C'P'           -->|/\nANSWER   DC    PL8'0'              ...\nWS_PL2   DC    PL2'0'              SCRATCHPAD\nTESTAREA DC    CL8' '\nVALIDTBL DC    256AL1(0)           NUMERIC TEST TABLE\n         ORG   VALIDTBL+C'0'\n         DC    C'0123456789'\n         ORG   ,\nSPACES   DC    CL133' '\nDSECT1   DSECT                     MAPPING DSECT\nYYYYMMDD DS    CL8                 USERS STARTING POINT\nDSECT2   DSECT                     MAPPING DSECT\nUSERDAYS DS    CL8                 CREATED FOR CALLER\nINTOFDTE CSECT                     BACK TO MAIN\n         EQUATE ,                  EQUATE REGISTERS\n         END   ,                   REQUIRED END STATEMENT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IP": {"ttr": 4356, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00\\x00o\\x01\\x00\\x00o\\x18S\\x00\\x08\\x00\\x08\\x00\\x00\\xc2\\xc3\\xd6\\xc4\\xc8\\xe2\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-01-06T00:00:00", "modifydate": "2000-01-06T18:53:00", "lines": 8, "newlines": 8, "modlines": 0, "user": "BCODHS0"}, "text": "         MACRO\n&NAME    IP    &VAR,&AMOUNT        INCREMENT PACKED COUNTER BY AMOUNT\n         AIF   ('&AMOUNT' EQ '').ONE '1' IS DEFAULT AMOUNT\n&NAME    AP    &VAR,=P'&AMOUNT'    INCR BY SPECIFIED AMOUNT\n         MEXIT\n.ONE     ANOP\n&NAME    AP    &VAR,=P'1'          INCR BY ONE\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "LEVELMSG": {"ttr": 4358, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x995\\x0f\\x00\\x995\\x0f\\x10@\\x00\\x06\\x00\\x06\\x00\\x00\\xc2\\xc3\\xd6\\xc4\\xc8\\xe2\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-16T00:00:00", "modifydate": "1999-12-16T10:40:00", "lines": 6, "newlines": 6, "modlines": 0, "user": "BCODHS0"}, "text": "         MACRO\n         LEVELMSG\n         COPY  $MGBLDEF\n         AIF   (&$MBLATH LT 3).MEND\n         MNOTE 'DO-GROUP LEVEL **** &$MDGLVL ****'\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "MACBOX": {"ttr": 4360, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x98(/\\x00\\x98(/\\x12V\\x00\\x05\\x00\\x05\\x00\\x00\\xc2\\xc3\\xd6\\xc4\\xc8\\xe2\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1998-10-09T00:00:00", "modifydate": "1998-10-09T12:56:00", "lines": 5, "newlines": 5, "modlines": 0, "user": "BCODHS0"}, "text": ".*                                                                   *\n.*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\n.*                                                                   *\n.*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\n.*                                                                   *\n", "mimetype": "text/plain", "datatype": "us-ascii", "extension": ".txt"}, "NEXT": {"ttr": 4362, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00\\x00o\\x01\\x00\\x00o\\x18S\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc2\\xc3\\xd6\\xc4\\xc8\\xe2\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-01-06T00:00:00", "modifydate": "2000-01-06T18:53:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "BCODHS0"}, "text": "         MACRO\n&NAME    NEXT  &SENT\n         COPY  $MGBLDEF\n         AIF   ('&SENT' EQ 'SENTENCE').SKIP010\n         MNOTE 8,'''SENTENCE'' IS THE ONLY VALID PARM - ''&SENT'' INVALC\n               ID; MACRO ABORTED'\n         MEXIT\n.SKIP010 AIF   (&$MDGLVL EQ 0).SKIP020\n&NAME    B     $MDF&$MDGSEQ(1)       B TO END OF OUTERMOST DO-GROUP\n         MEXIT\n.SKIP020 MNOTE *,'NEXT SENTENCE HAS NO FUNCTION IN OPEN CODE'\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "OMGBLDEF": {"ttr": 4364, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\x01\\x7f\\x01\\x02\\x01\\x7f\\x10\\x17\\x00\\x04\\x00\\x04\\x00\\x00\\xc7\\xc5\\xd5\\xe3\\xd9\\xf0\\xf2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-01-17T00:00:00", "modifydate": "2002-01-17T10:17:00", "lines": 4, "newlines": 4, "modlines": 0, "user": "GENTR02"}, "text": "         GBLA  &$MDGLVL,&$MDGERR,&$MRECUR,&$MBLATH\n         GBLC  &$MFNBR(31),&$MDGNAM(255),&$MDGSEQ(255),&$MNAME,&$MNC\n         GBLC  &$MIFELS(255),&$MLTAG(255),&$MPNAM1(31),&$MFNAM1(31)\n         GBLC  &$MCVERB(255),&$MC\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "OUTPUT1": {"ttr": 4366, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00\\x00o\\x01\\x00\\x00o\\x18S\\x00r\\x00r\\x00\\x00\\xc2\\xc3\\xd6\\xc4\\xc8\\xe2\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-01-06T00:00:00", "modifydate": "2000-01-06T18:53:00", "lines": 114, "newlines": 114, "modlines": 0, "user": "BCODHS0"}, "text": "         MACRO\n&NAME   OUTPUT1 &LRECL=80,&IOAREA=\n         GBLC  &PREF,&DCBDSW,&DCBDGEN,&WAREA\n         VERSION 2\n&PREF    SETC  'UT2'\n         AIF   ('&NAME' EQ '').SKIP01\n&PREF    SETC  '&NAME'\n.SKIP01  ANOP\n&WAREA   SETC  '&IOAREA'\n         AIF   ('&IOAREA' NE '').SKIP02\n&WAREA   SETC  '&PREF.WORK'\n.SKIP02  ANOP\n         TITLE 'SYSUT2 OUTPUT ROUTINE'\n         SPACE 2\n***********************************************************************\n* 'UT2OUTPT' WRITES EACH OUTPUT RECORD                                *\n***********************************************************************\n         SPACE\n&PREF.OUTPT SECTION\n           PUT   SYS&PREF,&WAREA   WRITE RECORD\n           AP    &PREF.COUNT,=P'1' BUMP OUTPUT COUNTER\n         ENDSECT ,                 AND RETURN\n         TITLE 'SYSUT2 FILE VERIFICATION ROUTINE AND DCB'\n         SPACE 2\n***********************************************************************\n* SYSUT2 VERIFICATION ROUTINE                                         *\n***********************************************************************\n         SPACE\n&PREF.PREP SECTION\n         SLR   R15,R15             SET ZERO RETURN CODE\n         RDJFCB MF=(E,&PREF.RJFCB)  CHECK IT OUT\n         IF    (LTR,R15,R15,NZ),THENDO DO IF FAILED\n           LA    R15,4            4 RETURN CODE\n           RETURN ,               RETURN TO CALLER\n         ENDO  ,\n         MVC   &PREF.DSNM(44),&PREF.JDSN COPY DATA SET NAME\n         IF    (CLI,&PREF.JMEM,C' ',NE),THENDO DO IF MEMBER PRESENT\n           LA    R2,&PREF.DSNM+43  LAST CHAR OF DSNAME\n           DO    UNTIL=(CLI,0(R2),C' ',NE) FIND LAST NON-BLANK\n             BCTR  R2,0            DECREMENT POINTER\n           ENDO  ,\n           MVI   1(R2),C'('        FOR '(MEMBER)'\n           LA    R3,&PREF.JMEM     1ST CHAR OF MEMBER\n           DO    8                 MOVE NO MORE THAN 8\n             IF    (CLI,0(R3),C' ',NE),THENDO DO IF NON-BLANK\n               MVC   2(1,R2),0(R3) MOVE 1 CHARACTER\n               I    R2             BUMP OUTPUT\n               I    R3             BUMP INPUT\n             ENDO  ,\n           ENDO  ,\n           MVI   2(R2),C')'        CLOSE PARENS\n         ENDO  ,\n         OPEN  (,OUTPUT),TYPE=J,MF=(E,&PREF.RJFCB) OPEN THE SUCKER\n         IF   (TM,SYS&PREF.+DCBOFLGS-IHADCB,DCBOFOPN,NO),THENDO FAILED?\n           LA    R15,20            20 RETURN CODE\n         ENDO  ,\n         ENDSECT\nWSECT    LOCTR\n&PREF.VOL DC   CL6' '              WILL HOLD VOL FROM JFCB OR CATALOG\n&PREF.DSNM DC  CL54' '             DATA.SET.NAME(MEMBER)\n         PUSH  PRINT\n         PRINT NOGEN\nSYS&PREF DCB   DDNAME=SYS&PREF,                                        C\n               LRECL=&LRECL,                                           C\n               DSORG=PS,                                               C\n               MACRF=PM,                                               C\n               EXLST=&PREF.EXIT\n         POP   PRINT\n&PREF.RJFCB RDJFCB SYS&PREF.,MF=L  LIST PORTION\n&PREF.EXIT DC  0F'0',X'87',AL3(&PREF.JFCB) ONLY INTERESTED IN JFCB\n&PREF.JFCB DC  0D'0'               JOB FILE CONTROL BLOCK\n&PREF.JDSN DC  CL44' '             DATA SET NAME\n&PREF.JMEM DC  CL8' ',65X'00'      MEMBER NAME\n&PREF.JNVOL DC X'00'               # OF VOLUMES\n&PREF.JVOLS DC 5XL6'00',28X'00'    UP TO 5 VOLSERS\n&PREF.LST2 CAMLST SEARCH,&PREF.JDSN,&PREF.VOL,&PREF.DSCB FOR 'OBTAIN'\n&PREF.DSCB DC  0D'0'               DATA SET CONTROL BLOCK\n         DC    38X'00'             - LOADED BY 'OBTAIN' MACRO\n&PREF.DSORG DC X'0000'\n&PREF.RECFM DC X'00'\n&PREF.OPTCD DC X'00'\n&PREF.BLKL DC  H'0'\n&PREF.LRECL DC H'0'\n         DC    50X'00'\n&PREF.LST CAMLST NAME,&PREF.JDSN,,&PREF.STBLK FOR 'LOCATE'\n&PREF.STBLK DC 0D'0'               ORIGIN OF LOCATE INFO\n&PREF.LNVOL DC H'0'                NUMBER OF VOLUMES\n&PREF.DEVT1 DC XL4'00'             DEVTYPE FOR VOL1\n&PREF.LVOL1 DC CL6' '              VOLSER FOR VOL1\n         DC    19XL12'00'\n         DC    10X'00'\n&PREF.TTR DC   XL3'00'             TTR FOR DSCB\n         DC    4X'00'\n         DC    CL6' '\n         AIF   ('&DCBDSW' EQ 'NO').SKIP50\n&DCBDSW  SETC  'NO'\n         PUSH  PRINT\n         AIF   ('&DCBDGEN' EQ 'GEN').GENOK\n&DCBDGEN SETC  'NOGEN'\n.GENOK   PRINT &DCBDGEN\n         DCBD  DSORG=PS\n&SYSECT  CSECT\nWSECT    LOCTR\n         POP   PRINT\n.SKIP50  ANOP\n         SPACE\n&PREF.EOFSW DC C'N'                SET TO 'Y' AT &PREF.EOF\n         SPACE\n         AIF   ('&IOAREA' NE '').SKIP90\n&PREF.WORK DC  CL&LRECL' '\n.SKIP90  ANOP\n&PREF.COUNT DC PL8'0'\nGSECT    LOCTR\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PAR$E": {"ttr": 4369, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00\\x00o\\x01\\x00\\x00o\\x18S\\x00\\x98\\x00\\x98\\x00\\x00\\xc2\\xc3\\xd6\\xc4\\xc8\\xe2\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-01-06T00:00:00", "modifydate": "2000-01-06T18:53:00", "lines": 152, "newlines": 152, "modlines": 0, "user": "BCODHS0"}, "text": "         MACRO\n         PAR$E &OPND1,&OPND2\n.*                      GLOBAL SYMBOLS FOR FIRST OPERAND\n         GBLC  &$PTAG1        DISPLACEMENT PORTION OF OPERAND\n         GBLA  &$PLEN1      EXPLICIT LENGTH IF SPECIFIED ELSE IMPLICIT\n         GBLC  &$PBASE1       EXPLICIT BASE IF SPECIFIED ELSE NULL\n         GBLC  &$PEB1         NULL IF NO EXPLICIT BASE ELSE (&$PBASE1)\n         GBLC  &$PELB1 (&$PLEN1) IF NO EXP BASE ELSE (&$PLEN1,&$PBASE1)\n.*                      GLOBAL SYMBOLS FOR SECOND OPERAND\n         GBLC  &$PTAG2        DISPLACEMENT PORTION OF OPERAND\n         GBLA  &$PLEN2      EXPLICIT LENGTH IF SPECIFIED ELSE IMPLICIT\n         GBLC  &$PBASE2       EXPLICIT BASE IF SPECIFIED ELSE NULL\n         GBLC  &$PEB2         NULL IF NO EXPLICIT BASE ELSE (&$PBASE2)\n         GBLC  &$PELB2 (&$PLEN2) IF NO EXP BASE ELSE (&$PLEN2,&$PBASE2)\n         GBLA  &$MBLATH       DOCUMENTATION CONTROL\n         LCLA  &I,&J,&END,&BEG,&LEN\n         LCLB  &ERRSW              FOR LENGTH ERROR DIAGNOSTIC\n         LCLC  &X\n&$PLEN1  SETA  1                   OPERATING ASSUMPTION\n&$PBASE1 SETC  ''                  OPERATING ASSUMPTION\n&END     SETA  K'&OPND1            NUMBER OF CHARS IN OPERAND\n&I       SETA  1                   1ST CHAR OF OPND\n         AIF   ('&OPND1'(1,1) GE '0').LOOP10 GO IF SELF-DEFINING\n         AIF   (D'&OPND1).OK08     GO IF ALREADY DEFINED\n&ERRSW   SETB  (1)                 SHOW EXPLICIT LENGTH REQUIRED\n         AGO   .LOOP10             SKIP SETA\n.OK08    ANOP\n&$PLEN1  SETA  L'&OPND1            SET TO LENGTH ATTRIBUTE\n.LOOP10  AIF   (&I EQ &END).NEXT15\n&J       SETA  &I+1                POTENTIAL '('\n         AIF   ('&OPND1'(&J,1) EQ '(').NEXT15\n&I       SETA  &J                  BUMP BY 1\n         AGO   .LOOP10             TRY, TRY AGAIN\n.NEXT15  ANOP                      PROCESS TAG\n&$PTAG1  SETC  '&OPND1'(1,&I)       SET TO TAG PORTION\n         AIF   (&$MBLATH LT 6).SKIP16\n         DC    0C'&$PTAG1',0AL4(1,&I) PAR$E DIAGNOSTIC - TAG1 PORTION\n.SKIP16  AIF   (&I NE &END).NEXT18 GO IF NOT FINISHED\n         AIF   (NOT &ERRSW).NEXT40 WE MUST HAVE A GOOD LENGTH\n&$PLEN1  SETA  L'&OPND1            DO FORWARD SCAN\n&ERRSW   SETB  (0)\n         AGO   .NEXT40\n.NEXT18  ANOP\n&I       SETA  &I+2                SKIP OVER '('\n         AIF   ('&OPND1'(&I,1) EQ ',').NEXT30 GO IF NO LENGTH\n&BEG     SETA  &I                  BEGINNING OF LENGTH PARAMETER\n.LOOP20  ANOP\n&I       SETA  &I+1                BUMP TO NEXT\n         AIF   (&I LE &END).TEST24\n         MNOTE 8,'INVALID PARAMETER - CHECK OPERANDS'\n         MEXIT\n.TEST24  AIF   ('&OPND1'(&I,1) NE ',' AND '&OPND1'(&I,1) NE ')').LOOP20\n&LEN     SETA  &I-&BEG             LENGTH OF LENGTH PORTION\n&X       SETC  '&OPND1'(&BEG,&LEN)  EXPLICIT LENGTH\n&$PLEN1  SETA  &X                   CONV TO SETA SYMBOL\n         AIF   (&$MBLATH LT 6).NEXT31\n         DC    0C'&$PLEN1',0AL4(&BEG,&LEN) PAR$E DIAGNOSTIC - LENGTH1\n         AGO   .NEXT31\n.NEXT30  AIF   (NOT &ERRSW).NEXT31 GO IF EXP LEN NOT REQ'D\n&$PLEN1  SETA  L'&OPND1            DO FORWARD SCAN\n&ERRSW   SETB  (0)\n.NEXT31  AIF   ('&OPND1'(&I,1) EQ ')').NEXT40 GO IF FINISHED\n&BEG     SETA  &I+1                SAVE FOR DESSERT\n.LOOP32  AIF   (&I LT &END).CONT34 GO IF OK\n         MNOTE 8,'ERROR IN BASE REGISTER PARM - CHECK OPERANDS'\n         AGO   .NEXT40\n.CONT34  ANOP\n&I       SETA  &I+1                BEG OF BASE REG PORTION\n         AIF   (&I LT &END AND '&OPND1'(&I,1) NE ')').LOOP32\n&LEN     SETA  &I-&BEG             LENGTH OF BASE REG PORTION\n&$PBASE1 SETC  '&OPND1'(&BEG,&LEN)  SET TO BASE PORTION\n         AIF   (&$MBLATH LT 6).NEXT40\n         DC   0C'&$PBASE1',0AL4(&BEG,&LEN) PAR$E DIAGNOSTIC - BASE REG1\n.NEXT40  ANOP\n&$PEB1   SETC  ''                  ASSUME NO EXPLICIT BASE REGISTER\n&$PELB1  SETC  '(&$PLEN1.)'        ASSUME NO EXPLICIT BASE REGISTER\n         AIF   ('&$PBASE1' EQ '').NEXT42\n&$PEB1   SETC  '(&$PBASE1.)'       SET TO '(R5)' ETC\n&$PBASE1 SETC  ',&$PBASE1'         ADD PRECEEDING COMMA\n&$PELB1  SETC  '(&$PLEN1&$PBASE1.)' SET LENGTH AND BASE\n.NEXT42  AIF   (&$MBLATH LT 6).SKIP44\n         DC 0C'&$PTAG1&$PEB1'   PAR$E DIAGNOSTIC - DISP1(BASE1)\n         DC 0C'&$PTAG1&$PELB1'  PAR$E DIAGNOSTIC - DISP1(LENGTH1,BASE1)\n.SKIP44  AIF   ('&OPND2' EQ '').MEND\n&$PTAG2  SETC  '&OPND2'            SET DEFAULT\n&$PLEN2  SETA  1                   OPERATING ASSUMPTION\n&$PBASE2 SETC  ''                  OPERATING ASSUMPTION\n&END     SETA  K'&OPND2            NUMBER OF CHARS IN OPERAND\n         AIF   ('&OPND2' EQ '').MEND\n&I       SETA  1                   1ST CHAR OF OPND\n         AIF   ('&OPND2'(1,1) GE '0').LOOP50 GO IF SELF-DEFINING\n         AIF   (D'&OPND2).OK48     GO IF ALREADY DEFINED\n&ERRSW   SETB  (1)                 SHOW EXPLICIT LENGTH REQUIRED\n         AGO   .LOOP50             SKIP SETA\n.OK48    ANOP\n&$PLEN2  SETA  L'&OPND2            SET TO LENGTH ATTRIBUTE\n.LOOP50  AIF   (&I EQ &END).NEXT55\n&J       SETA  &I+1                POTENTIAL '('\n         AIF   ('&OPND2'(&J,1) EQ '(').NEXT55\n&I       SETA  &J                  BUMP BY 1\n         AGO   .LOOP50             TRY, TRY AGAIN\n.NEXT55  ANOP                      PROCESS TAG\n&$PTAG2  SETC  '&OPND2'(1,&I)      SET TO TAG PORTION\n         AIF   (&$MBLATH LT 6).SKIP57\n         DC    0C'&$PTAG2',0AL4(1,&I) PAR$E DIAGNOSTIC - TAG2 PORTION\n.SKIP57  AIF   (&I NE &END).NEXT58 GO IF NOT FINISHED\n         AIF   (NOT &ERRSW).NEXT80 GO IF REALLY FINISHED\n&$PLEN2  SETA  L'&OPND2            DO FORWARD SCAN\n&ERRSW   SETB  (0)\n         AGO   .NEXT80\n.NEXT58  ANOP\n&I       SETA  &I+2                SKIP OVER '('\n         AIF   ('&OPND2'(&I,1) EQ ',').NEXT70 GO IF NO LENGTH\n&BEG     SETA  &I                  BEGINNING OF LENGTH PARAMETER\n.LOOP60  ANOP\n&I       SETA  &I+1                BUMP TO NEXT\n         AIF   (&I LE &END).TEST64\n         MNOTE 8,'INVALID PARAMETER - CHECK OPERANDS'\n         MEXIT\n.TEST64  AIF   ('&OPND2'(&I,1) NE ',' AND '&OPND2'(&I,1) NE ')').LOOP60\n&LEN     SETA  &I-&BEG             LENGTH OF LENGTH PORTION\n&X       SETC  '&OPND2'(&BEG,&LEN)  EXPLICIT LENGTH\n&$PLEN2  SETA  &X                   CONV TO SETA\n         AIF   (&$MBLATH LT 6).NEXT71\n         DC    0C'&$PLEN2',0AL4(&BEG,&LEN) PAR$E DIAGNOSTIC - LENGTH2\n         AGO   .NEXT71\n.NEXT70  AIF   (NOT &ERRSW).NEXT71\n&$PLEN2  SETA  L'&OPND2            DO FORWARD SCAN\n&ERRSW   SETB  (0)\n.NEXT71  AIF   ('&OPND2'(&I,1) EQ ')').NEXT80 GO IF FINISHED\n&BEG     SETA  &I+1                SAVE FOR DESSERT\n.LOOP72  AIF   (&I LT &END).CONT74 GO IF OK\n         MNOTE 8,'ERROR IN BASE REGISTER PARM - CHECK OPERANDS'\n         AGO   .NEXT80\n.CONT74  ANOP\n&I       SETA  &I+1                BEG OF BASE REG PORTION\n         AIF   (&I LT &END AND '&OPND2'(&I,1) NE ')').LOOP72\n&LEN     SETA  &I-&BEG             LENGTH OF BASE REG PORTION\n&$PBASE2 SETC  '&OPND2'(&BEG,&LEN)  SET TO BASE PORTION\n         AIF   (&$MBLATH LT 6).NEXT80\n         DC   0C'&$PBASE2',0AL4(&BEG,&LEN) PAR$E DIAGNOSTIC - BASE REG\n.NEXT80  ANOP\n&$PEB2   SETC  ''                  ASSUME NO EXPLICIT BASE REGISTER\n&$PELB2  SETC  '(&$PLEN2.)'        ASSUME NO EXPLICIT BASE REG\n         AIF   ('&$PBASE2' EQ '').NEXT82\n&$PEB2   SETC  '(&$PBASE2.)'       SET TO '(R5)' ETC\n&$PBASE2 SETC  ',&$PBASE2'         FINISH IT OFF\n&$PELB2  SETC  '(&$PLEN2&$PBASE2.)' SET LENGTH AND BASE\n.NEXT82  AIF   (&$MBLATH LT 6).MEND\n         DC 0C'&$PTAG2&$PEB2'   PAR$E DIAGNOSTIC - DISP2(BASE2)\n         DC 0C'&$PTAG2&$PELB2'  PAR$E DIAGNOSTIC - DIS2P(LENGTH2,BASE2)\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PCALL": {"ttr": 4373, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00\\x00o\\x01\\x00\\x00o\\x18S\\x002\\x002\\x00\\x00\\xc2\\xc3\\xd6\\xc4\\xc8\\xe2\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-01-06T00:00:00", "modifydate": "2000-01-06T18:53:00", "lines": 50, "newlines": 50, "modlines": 0, "user": "BCODHS0"}, "text": "         MACRO\n&NAME    PCALL  &PROC,&VAR,&WHILE=,&UNTIL=\n         COPY  $MGBLDEF\n         LCLB  &DOLOOP             FLAG TO CREATE 'ENDO'\n         LCLC  &N                  FOR NAME FIELD\n         VERSION 1\n&N       SETC  '&NAME'             SET TO USER SPECIFIED NAME\n         AIF   (&$MPCSV(&$MPLVL) EQ 0).AOK IF REGS SAVED, THEN OK\n         MNOTE 8,'''PCALL'' WITHIN PROC WITH NO REGS SAVED INVALID'\n         MNOTE *,'PROGRAM LOOP PROBABLE'\n.AOK     AIF   ('&SYSECT' NE 'DATAAREA').BOK\n         MNOTE 8,'''PCALL'' WITHIN CODE IN CSECT ''DATAAREA'' CAN CAUSEC\n                UNPREDICTABLE RESULTS - CONFLICT WITH BASE REG AND R13 C\n                - MOVEMENT OF CODE TO ANOTHER CSECT IS ADVISED'\n.BOK     AIF   ('&VAR' NE '').VAR10 GO IF VAR SPECIFIED\n         AIF   ('&WHILE' NE '').WHILE20 GO IF WHILE SPECIFIED\n         AIF   ('&UNTIL' NE '').UNTIL30 GO IF UNTIL SPECIFIED\n         AGO   .COK\n.VAR10   AIF   ('&WHILE' NE '').NOTOK\n         AIF   ('&UNTIL' NE '').NOTOK\n&N       DO    &VAR                CREATE DO-LOOP\n&N       SETC  ''                  NULLIFY NAME FIELD\n&DOLOOP  SETB  (1)                 SHOW 'ENDO' REQUIRED\n         AGO   .COK                CONTINUE WITH COMMON CODE\n.WHILE20 AIF   ('&UNTIL' NE '').NOTOK\n&N       DO    WHILE=&WHILE        CREATE DO-LOOP\n&N       SETC  ''                  NULLIFY NAME FIELD\n&DOLOOP  SETB  (1)                 SHOW 'ENDO' REQUIRED\n         AGO   .COK                CONTINUE WITH COMMON CODE\n.UNTIL30 AIF   ('&UNTIL' EQ '').COK GO IF NO DO-LOOP TO CREATE\n&N       DO    UNTIL=&UNTIL        CREATE DO-LOOP\n&N       SETC  ''                  NULLIFY NAME FIELD\n&DOLOOP  SETB  (1)                 SHOW 'ENDO' REQUIRED\n         AGO   .COK                CONTINUE WITH COMMON CODE\n.NOTOK   MNOTE 12,'MUTUALLY EXCLUSIVE PARAMETERS - MACRO ABORTED'\n         MEXIT\n.COK     AIF   ('&PROC'(1,1) NE '(').NOTREG\n&N       VAL   &$BASE(1),&PROC     CALLER'S REG INTO BASE\n         CNOP  2,4                 ALIGN ON HALFWORD\n         BASR  &$LINK,&$BASE(1)    BRANCH TO PROC\n         DC    A(0,&$MSECT(&$MPLVL)) LINKAGE ADDRESSES\n         AGO   .CLEANUP\n.NOTREG  ANOP\n         CNOP  2,4                 ALIGN ON HALFWORD\n&N       L     &$BASE(1),*+6       ADDRESSABILITY FOR PROC\n         BASR  &$LINK,&$BASE(1)    BRANCH TO PROC\n         DC    A(&PROC,&$MSECT(&$MPLVL)) LINKAGE ADDRESSES\n.CLEANUP AIF   (NOT &DOLOOP).MEND  CREATE 'ENDO' ONLY IF REQUESTED\n         ENDO  ,                   END OF PCALL LOOP\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PERFORM": {"ttr": 4375, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00\\x00o\\x01\\x00\\x00o\\x18S\\x00\\x18\\x00\\x18\\x00\\x00\\xc2\\xc3\\xd6\\xc4\\xc8\\xe2\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-01-06T00:00:00", "modifydate": "2000-01-06T18:53:00", "lines": 24, "newlines": 24, "modlines": 0, "user": "BCODHS0"}, "text": "         MACRO\n&NAME    PERFORM &SECTION          CALL A CO-ASSEMBLED SUBROUTINE\n         COPY  $MGBLDEF\n         GBLC  &GBASE,&GLINK       EXTRACT PRESET BASE AND LINK REGS\n         GBLC  &NSECT              EXTRACT SECTION NAME\n         LCLC  &N,&X               FOR NAME FIELD AND &SYSNDX\n         VERSION 2\n&N       SETC  '&NAME'             SET TO USER-SPECIFIED NAME\n&X       SETC  '&SYSNDX'           FOR UNIQUENESS\n         AIF   ('&SECTION'(1,1) NE '(').NOTREG GO IF NOT GPR\n         CNOP  0,4                 ALIGN ON WORD BOUNDARY\n&NAME    LR    15,&SECTION(1)      CALLER'S REG INTO 15\n         SL    15,*+6              DECREMENT TO BASR/ST INSTRUCTIONS\n         BASR  &GLINK,15           BRANCH TO SECTION\n         DC    A(6,&NSECT)         DECREMENT AND LINKAGE ADDRESS\n         AGO   .MEND\n.NOTREG  CNOP  2,4                 ALIGN ON HALFWORD\n         DC    0AL4(REF&X)         ERROR IF OBJECT NOT SECTION NAME\n         $AGOTO &SECTION,&X        ADD THE REFERENCE TO THE TABLE\n&NAME    L     15,*+6              SECTION ENTRY ADDRESS\n         BASR  &GLINK,15           BRANCH AND LINK TO SECTION\n         DC    A(&SECTION-6,&NSECT) LINKAGE ADDRESSES\n         L     &GBASE,4(,&GLINK)   RESTORE BASE REGISTER\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PRDEF": {"ttr": 4609, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00\\x00o\\x01\\x00\\x00o\\x18S\\x00\\x80\\x00\\x80\\x00\\x00\\xc2\\xc3\\xd6\\xc4\\xc8\\xe2\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-01-06T00:00:00", "modifydate": "2000-01-06T18:53:00", "lines": 128, "newlines": 128, "modlines": 0, "user": "BCODHS0"}, "text": "         MACRO\n&PROCN   PRDEF &DDNAME=SYSPRINT,   DEFAULT DDNAME                      C\n               &LRECL=133,         LOGICAL RECORD LENGTH               C\n               &BLKSIZE=133,       JES2 TAKES CARE OF BLOCKING         C\n               &OUTLINE=OUTLINE,   OUTPUT LINE NAME                    C\n               &CCCHAR=CCCHAR,     CARRIAGE CONTROL                    C\n               &HEADER1=HEADER1,   HEADER LINE NAME                    C\n               &HEADER2=,          HEADER LINE NAME                    C\n               &HEADER3=,          HEADER LINE NAME                    C\n               &SPACES=SPACES,     TO BLANK OUT OUTLINE                C\n               &LINECT=LINECT,     DEFAULT LINE COUNTER                C\n               &PAGECT=PAGECT,     DEFAULT PAGE COUNTER                C\n               &PSIZE=60,          DEFAULT PAGE SIZE                   C\n               &DCBNAME=PRINTER    DEFAULT DCB NAME\n         TITLE 'PRINT ROUTINE'\n         SPACE\n***********************************************************************\n*        STANDARD PRINT ROUTINE PRINTS FROM '&OUTLINE', AND PRINTS    *\n*        '&HEADER1' AT THE TOP OF EACH PAGE. IF '&HEADER2' OR         *\n*        '&HEADER3' IS DEFINED, THEY ARE PRINTED AS APPROPRIATE.      *\n***********************************************************************\n         SPACE\n         GBLC  &$MTRACE\n&SAVE    SETC  '&$MTRACE'\n&$MTRACE SETC  'NO'\n&PROCN   PROC\n         SPACE\n***********************************************************************\n*        MAKE SURE THAT THE DCB HAS BEEN OPENED.                      *\n***********************************************************************\n         SPACE\n         FIRST 1                   CHECK DCB FIRST CALL ONLY\n           SPACE\n           IF    (TM,&DCBNAME+48,X'10',NO),THENDO OPENED?\n             OPEN  (&DCBNAME,OUTPUT) DO IF NECESSARY\n             IF    (TM,&DCBNAME+48,X'10',NO),THENDO OPEN FAIL?\n               ABEND 16,DUMP       MIGHT AS WELL QUIT NOW\n             ENDO  , ** NOTE ** POSSIBLE TO ADD DYNALLOC CODE HERE TO\n           ENDO  ,   ** NOTE ** . FORCE ALLOCATION FOR PRINTER FILE.\n         ENDO  ,     ** NOTE ** . REQUESTS, ANYONE?\n         SPACE\n***********************************************************************\n*        KEEP TRACK OF LINECT, AND DO OVERFLOW PROCESSING WHEN        *\n*        REQUIRED.                                                    *\n***********************************************************************\n         SPACE\n         IF    (CLI,&CCCHAR,C' ',E),THENDO IS IT SINGLE?\n           AP   &LINECT,=P'1'      1 FOR SINGLE SPACING\n         ELSEIF (CLI,&CCCHAR,C'0',E),THENDO IS IT DOUBLE?\n           AP   &LINECT,=P'2'      BUMP FOR DOUBLE\n         ELSEIF (CLI,&CCCHAR,C'-',E),THENDO IS IT TRIPLE?\n           AP   &LINECT,=P'3'     BUMP FOR TRIPLE\n         ELSEIF (CLI,&CCCHAR,C'1',E),THENDO NEW PAGE?\n           PACK &LINECT,=Z'1'     'RESET' LINE COUNT\n         ELSEIF (CLI,&CCCHAR,C'C',E),THENDO CHANNEL 12?\n           PACK &LINECT,=Z'&PSIZE' FORCE OVERFLOW FOR NEXT CALL\n         ELSEIF (CLI,&CCCHAR,C'+',NE),THENDO DO IF NOT SUPPRESS\n           AP   &LINECT,=P'1'     ASSUME SINGLE\n         ENDELSE ,\n         CP   &LINECT,=P'&PSIZE'   FINISHED WITH PAGE?\n         THENDO H                  OVERFLOW IF NECESSARY\n          PUT   &DCBNAME,&HEADER1  PUT OUT HEADER LINE\n          PACK &LINECT,=Z'3'       ALLOW FOR HEADER & 1ST DOUBLE\n          AIF   ('&HEADER2' EQ '').SKIP10 SKIP IF NOT NECESSARY\n          IF   (CLC,&HEADER2,&SPACES,NE),THENDO DO IF 2ND IS PRESENT\n           PUT   &DCBNAME,&HEADER2 PUT OUT 2ND HEADER LINE\n           AP    &LINECT,=P'1'     BUMP LINE COUNT\n          ENDO  ,\n.SKIP10   AIF   ('&HEADER3' EQ '').SKIP20 SKIP IF NOT NECESSARY\n          IF    (CLC,&HEADER3,&SPACES,NE),THENDO DO IF 3RD IS PRESENT\n           PUT   &DCBNAME,&HEADER3 PUT OUT 3RD HEADER LINE\n           AP    &LINECT,=P'1'    BUMP LINE COUNT\n          ENDO  ,\n.SKIP20   ANOP\n          IF    (CLI,&CCCHAR,C' ',E),THENDO IF SINGLE THEN...\n            MVI  &CCCHAR,C'0'      FORCE FIRST DATA TO BE DOUBLE\n          ENDO  ,\n         ENDO\n         EJECT\n***********************************************************************\n*        ** FINALLY ** PRINT THE LINE IN QUESTION.                    *\n***********************************************************************\n         SPACE\n         PUT   &DCBNAME,&OUTLINE   PUT OUT LINE\n         SPACE\n         MVC   &OUTLINE,&SPACES    BLANK INCL&CCCHAR\n         SPACE\n         ENDP  ,\n         SPACE\n&PAGECT  DC    PL3'1'              START WITH PAGE # 1, THANK YOU\n&LINECT  DC    PL2'&PSIZE'         FORCE OVERFLOW ON 1ST CALL\n         SPACE\n***********************************************************************\n*        DEFINE PRINTER DCB                                           *\n***********************************************************************\n         SPACE\n         PUSH  PRINT\n         SPACE\n         PRINT NOGEN               CREATE DCB WITH NOGEN\n         SPACE\n&DCBNAME DCB   DDNAME=&DDNAME,                                         X\n               DSORG=PS,                                               X\n               MACRF=PM,                                               X\n               RECFM=FBA,                                              X\n               LRECL=&LRECL,                                           X\n               BLKSIZE=&BLKSIZE\n         SPACE\n         POP   PRINT\n         SPACE\n***********************************************************************\n*        DEFINE HEADER AND DATA AREAS                                 *\n***********************************************************************\n         SPACE\n&HEADER1 DC    CL&LRECL'1'         USER SHOULD MOVE IN DESIRED DATA\n         SPACE\n         AIF   ('&HEADER2' EQ '').SKIP30 SKIP IF NOT NECESSARY\n&HEADER2 DC    CL&LRECL' '         USER SHOULD MOVE IN DESIRED DATA\n         SPACE\n.SKIP30  AIF   ('&HEADER3' EQ '').SKIP40 SKIP IF NOT NECESSARY\n&HEADER3 DC    CL&LRECL' '         USER SHOULD MOVE IN DESIRED DATA\n         SPACE\n.SKIP40  ANOP\n&OUTLINE DC    0CL&LRECL' '        TOTAL DEFINITION OF LINE\n&CCCHAR  DC    C' ',CL(&LRECL-1)' ' CARRIAGE CONTROL, THEN DATA\n         SPACE\n&SPACES  DC    CL&LRECL' '         GUESS?\n&$MTRACE SETC  '&SAVE'\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PRINTER": {"ttr": 4612, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00\\x00o\\x01\\x00\\x00o\\x18S\\x00\\x95\\x00\\x95\\x00\\x00\\xc2\\xc3\\xd6\\xc4\\xc8\\xe2\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-01-06T00:00:00", "modifydate": "2000-01-06T18:53:00", "lines": 149, "newlines": 149, "modlines": 0, "user": "BCODHS0"}, "text": "         MACRO\n&PROCN PRINTER &DDNAME=SYSPRINT,   DEFAULT DDNAME                      C\n               &LRECL=133,         LOGICAL RECORD LENGTH               C\n               &BLKSIZE=133,       JES2 TAKES CARE OF BLOCKING         C\n               &OUTLINE=OUTLINE,   OUTPUT LINE NAME                    C\n               &CCCHAR=CCCHAR,     CARRIAGE CONTROL                    C\n               &HEADER1=HEADER1,   HEADER LINE NAME                    C\n               &HEADER2=,          HEADER LINE NAME                    C\n               &HEADER3=,          HEADER LINE NAME                    C\n               &SPACES=SPACES,     TO BLANK OUT OUTLINE                C\n               &LINECT=LINECT,     DEFAULT LINE COUNTER                C\n               &PSIZE=60,          DEFAULT PAGE SIZE                   C\n               &PCTR=PCTR,         PAGE COUNTER                        C\n               &PFIELD=,           FIELD FOR PAGE NUMBER               C\n               &DCBNAME=PRINTER    DEFAULT DCB NAME\n         GBLC  &GSECT,&WSECT\n         VERSION 2\n         TITLE 'PRINT ROUTINE'\n         SPACE\n***********************************************************************\n*        STANDARD PRINT ROUTINE PRINTS FROM '&OUTLINE', AND PRINTS    *\n*        '&HEADER1' AT THE TOP OF EACH PAGE. IF '&HEADER2' OR         *\n*        '&HEADER3' IS DEFINED, THEY ARE PRINTED AS APPROPRIATE.      *\n***********************************************************************\n         SPACE\n&PROCN   SECTION\n         SPACE\n***********************************************************************\n*        MAKE SURE THAT THE DCB HAS BEEN OPENED.                      *\n***********************************************************************\n         SPACE\n         FIRST 1                   CHECK DCB FIRST CALL ONLY\n           SPACE\n           IF    (TM,&DCBNAME+48,X'10',NO),THENDO OPENED?\n             OPEN  (&DCBNAME,OUTPUT) DO IF NECESSARY\n             IF    (TM,&DCBNAME+48,X'10',NO),THENDO OPEN FAIL?\n               ABEND 16,DUMP       MIGHT AS WELL QUIT NOW\n             ENDO  , ** NOTE ** POSSIBLE TO ADD DYNALLOC CODE HERE TO\n           ENDO  ,   ** NOTE ** . FORCE ALLOCATION FOR PRINTER FILE.\n         ENDO  ,     ** NOTE ** . REQUESTS, ANYONE?\n         SPACE\n***********************************************************************\n*        KEEP TRACK OF LINECT, AND DO OVERFLOW PROCESSING WHEN        *\n*        REQUIRED.                                                    *\n***********************************************************************\n         SPACE\n         IF    (CLI,&CCCHAR,C' ',E),THENDO IS IT SINGLE?\n           AP   &LINECT,=P'1'      1 FOR SINGLE SPACING\n         ELSEIF (CLI,&CCCHAR,C'0',E),THENDO IS IT DOUBLE?\n           AP   &LINECT,=P'2'      BUMP FOR DOUBLE\n         ELSEIF (CLI,&CCCHAR,C'-',E),THENDO IS IT TRIPLE?\n           AP   &LINECT,=P'3'     BUMP FOR TRIPLE\n         ELSEIF (CLI,&CCCHAR,C'1',E),THENDO NEW PAGE?\n           PACK &LINECT,=Z'1'     'RESET' LINE COUNT\n         ELSEIF (CLI,&CCCHAR,C'C',E),THENDO CHANNEL 12?\n           PACK &LINECT,=Z'&PSIZE' FORCE OVERFLOW FOR NEXT CALL\n         ELSEIF (CLI,&CCCHAR,C'+',NE),THENDO DO IF NOT SUPPRESS\n           AP   &LINECT,=P'1'     ASSUME SINGLE\n         ENDELSE ,\n         CP   &LINECT,=P'&PSIZE'   FINISHED WITH PAGE?\n         THENDO H                  OVERFLOW IF NECESSARY\n          AIF   ('&PFIELD' EQ '').SKIP02\n          AP    &PCTR,=P'1'        BUMP PAGE COUNTER\n          IF    (CP,&PCTR,=P'10',L),THENDO\n            EM2   0+&PFIELD.(1),0+&PCTR.(4)\n          ELSEIF (CP,&PCTR,=P'100',L),THENDO\n            EM2   0+&PFIELD.(2),0+&PCTR.(4)\n          ELSEIF (CP,&PCTR,=P'1000',L),THENDO\n            EM2   0+&PFIELD.(3),0+&PCTR.(4)\n          ELSEIF (CP,&PCTR,=P'10000',L),THENDO\n            EM2   0+&PFIELD.(5),0+&PCTR.(4)\n          ELSEIF (CP,&PCTR,=P'100000',L),THENDO\n            EM2   0+&PFIELD.(6),0+&PCTR.(4)\n          ELSE  ,\n            EM2   0+&PFIELD.(8),0+&PCTR.(4)\n          ENDIF  ,\n.SKIP02   ANOP\n          PUT   &DCBNAME,&HEADER1  PUT OUT HEADER LINE\n          PACK &LINECT,=Z'3'       ALLOW FOR HEADER & 1ST DOUBLE\n          AIF   ('&HEADER2' EQ '').SKIP10 SKIP IF NOT NECESSARY\n          IF   (CLC,&HEADER2,&SPACES,NE),THENDO DO IF 2ND IS PRESENT\n           PUT   &DCBNAME,&HEADER2 PUT OUT 2ND HEADER LINE\n           AP    &LINECT,=P'1'     BUMP LINE COUNT\n          ENDO  ,\n.SKIP10   AIF   ('&HEADER3' EQ '').SKIP20 SKIP IF NOT NECESSARY\n          IF    (CLC,&HEADER3,&SPACES,NE),THENDO DO IF 3RD IS PRESENT\n           PUT   &DCBNAME,&HEADER3 PUT OUT 3RD HEADER LINE\n           AP    &LINECT,=P'1'    BUMP LINE COUNT\n          ENDO  ,\n.SKIP20   ANOP\n          IF    (CLI,&CCCHAR,C' ',E),THENDO IF SINGLE THEN...\n            MVI  &CCCHAR,C'0'      FORCE FIRST DATA TO BE DOUBLE\n          ENDO  ,\n         ENDO\n         EJECT\n***********************************************************************\n*        ** FINALLY ** PRINT THE LINE IN QUESTION.                    *\n***********************************************************************\n         SPACE\n         PUT   &DCBNAME,&OUTLINE   PUT OUT LINE\n         SPACE\n         MVC   &OUTLINE,&SPACES    BLANK INCL&CCCHAR\n         SPACE\n&WSECT   LOCTR\n         SPACE\n&LINECT  DC    PL2'&PSIZE'         FORCE OVERFLOW ON 1ST CALL\n         SPACE\n***********************************************************************\n*        DEFINE PRINTER DCB                                           *\n***********************************************************************\n         SPACE\n         PUSH  PRINT\n         SPACE\n         PRINT NOGEN               CREATE DCB WITH NOGEN\n         SPACE\n&DCBNAME DCB   DDNAME=&DDNAME,                                         X\n               DSORG=PS,                                               X\n               MACRF=PM,                                               X\n               RECFM=FBA,                                              X\n               LRECL=&LRECL,                                           X\n               BLKSIZE=&BLKSIZE\n         SPACE\n         POP   PRINT\n         SPACE\n***********************************************************************\n*        DEFINE HEADER AND DATA AREAS                                 *\n***********************************************************************\n         SPACE\n&HEADER1 DC    CL&LRECL'1'         USER SHOULD MOVE IN DESIRED DATA\n         SPACE\n         AIF   ('&HEADER2' EQ '').SKIP30 SKIP IF NOT NECESSARY\n&HEADER2 DC    CL&LRECL' '         USER SHOULD MOVE IN DESIRED DATA\n         SPACE\n.SKIP30  AIF   ('&HEADER3' EQ '').SKIP40 SKIP IF NOT NECESSARY\n&HEADER3 DC    CL&LRECL' '         USER SHOULD MOVE IN DESIRED DATA\n         SPACE\n.SKIP40  ANOP\n&OUTLINE DC    0CL&LRECL' '        TOTAL DEFINITION OF LINE\n&CCCHAR  DC    C' ',CL(&LRECL-1)' ' CARRIAGE CONTROL, THEN DATA\n         SPACE\n         DC    C'0'                DOUBLE SPACE CTL CHAR\n         SPACE\n&SPACES  DC    CL&LRECL' '         GUESS?\n&PCTR    DC    PL4'0'\n         AIF   ('&GSECT' NE '&SYSLOC').SKIP50\n&GSECT   LOCTR\n.SKIP50  ANOP\n         ENDSECT\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PROC": {"ttr": 4616, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00\\x00o\\x01\\x00\\x00o\\x18S\\x00s\\x00s\\x00\\x00\\xc2\\xc3\\xd6\\xc4\\xc8\\xe2\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-01-06T00:00:00", "modifydate": "2000-01-06T18:53:00", "lines": 115, "newlines": 115, "modlines": 0, "user": "BCODHS0"}, "text": "         MACRO\n&NAME    PROC  &SAVE=LINK,&NBASE=1 SET &SAVE TO 'ALL' FOR R2 - R14\n         COPY  $MGBLDEF\n         GBLB  &VERROR             SET BY VERSION MACRO\n         LCLA  &TEMP,&TEMP2,&TEMP3\n         LCLC  &$MX\n         VERSION 1\n         AIF   (NOT &VERROR).OK02 TEST FOR VERSION ERROR\n         MEXIT                     GIVE UP ALL HOPE IF YES\n.OK02    AIF   ('&NAME' NE '').OK10 MUST HAVE NAME TO BE CALLABLE\n         MNOTE 8,'UNNAMED PROC - GENERATION SUPPRESSED'\n         MEXIT\n.OK10    ANOP\n&$MX     SETC  '&SYSNDX'           MAKE ASM LIST LOOK NICER\n         AIF   ('&SYSECT' EQ 'DATAAREA').OK12\n         B     $SKP&$MX            B AROUND LITERALS\n         LTORG                     GENERATE LITERALS FOR PREV CSECT\n$SKP&$MX DC    0H'0'\n.OK12    AIF   ('&$USING(&$MPLVL)' EQ '').SKIP01\n         DROP  &$USING(&$MPLVL)   DROP CURRENT BASE REG(S)\n.SKIP01  ANOP\n&$MPLVL  SETA  &$MPLVL+1           BUMP NESTING LEVEL\n&$MSECT(&$MPLVL) SETC '&NAME'      REMEMBER PROC NAME\n&$MPCSV(&$MPLVL) SETA  0           ASSUME REGS WILL BE SAVED\n&$PROCNM(&$MPLVL) SETC  '&NAME'    SAVE THIS NAME FOR ENDP\n         AIF   ('&NBASE' EQ '').SKIP00\n         AIF   (&NBASE NE 1).OK20\n.SKIP00  AIF   ('&SAVE' EQ 'YES' OR '&SAVE' EQ 'ALL').OK20\n         AIF   ('&SAVE' EQ 'LINK').OK30\n         AIF   ('&SAVE' EQ 'NO' OR '&SAVE' EQ 'NONE').OK40\n         MNOTE 4,'''&SAVE'' INVALID - ''LINK'' ASSUMED'\n         AGO   .OK30\n.OK20    ANOP\n&NAME    CSECT\n         USING *,&$BASE(1)         ADDRESSABILITY\n&$USING(&$MPLVL) SETC '&$BASE(1)'  INITIALIZE USING\n         IF    (TM,$MCL&$MX,X'80',O),THENDO DO IF PROC ACTIVE\n           ABEND &$MABEND,DUMP     REENTRANT NOT SUPPORTED\n         ENDO  ,\n         OI    $MCL&$MX,X'80'      FLAG PROC ACTIVE\n         STM   R2,R14,$MSV&$MX     SAVE ALL USER REGISTERS\n         AIF   ('&NBASE' EQ '').DONEBAS NONE SPECIFIED\n         AIF   (&NBASE EQ 1).DONEBAS 1 IS DEFAULT\n&TEMP    SETA  (&NBASE)            NUMBER OF BASE REGS FOR PROC\n         AIF   (&TEMP LE &$MNBASE).OK22 CAN'T BE > THAN GO MACRO\n         MNOTE 4,'MORE BASE REGS THAN SPECIFIED IN ''GO'' MACRO'\n         MNOTE *,'&$MNBASE REGS USED'\n&TEMP    SETA  (&$MNBASE)\n.OK22    LA    &$BASE(&TEMP),2048   INCREMENT FOR BASE REG(S)\n&TEMP2   SETA  2                    SECOND BASE\n.BASELUP AIF   (&TEMP2 GE &TEMP).FINBASE\n&TEMP3   SETA  &TEMP2-1             POINT TO PREV BASE\n&X       SETC  '&$BASE(&TEMP2)'\n&Y       SETC  '&$BASE(&TEMP3)'\n&Z       SETC  '&$BASE(&TEMP)'\n         LA    &X,2048(&Y,&Z)       INITIALIZE ANOTHER BASE\n&$USING(&$MPLVL) SETC '&$USING(&$MPLVL),&$BASE(&TEMP2)' BUILD USING\n&TEMP2   SETA  &TEMP2+1             NEXT BASE\n         AGO   .BASELUP             LOOP BACK\n.FINBASE ANOP                       DONE WITH BASE REG LOOP\n&TEMP2   SETA  &TEMP2-1             BACK TO NEXT-TO-LAST\n&X       SETC  '&$BASE(&TEMP)'\n&Y       SETC  '&$BASE(&TEMP2)'\n         LA    &X,2048(&Y,&X)       INITIALIZE LAST BASE\n&$USING(&$MPLVL) SETC '&$USING(&$MPLVL),&$BASE(&TEMP)' FINISH USING\n&X       SETC  '&$USING(&$MPLVL)'   SHORTHAND\n         USING  &NAME,&X            ESTABLISH ADDRESSABILITY\n.DONEBAS TRC   ,'PROC ''&NAME'' ENTERED'\n         B     $MSP&$MX             . AND B TO PROC PROPER\n         DC    CL8'&NAME.*******',CL10'-&SYSDATE ' FINGERPRINT\n$MEX&$MX NI    $MCL&$MX,X'7F'      FLAG PROC INACTIVE\n         TRC   ,'LEAVING PROC ''&NAME'''\n         LM    R2,R14,$MSV&$MX     RESTORE ALL USER REGS\n         L     &$BASE(1),4(,&$LINK) RESTORE BASE REGISTER\n         B     8(,&$LINK)           AND RETURN\nDATAAREA CSECT\n$MSV&$MX DC    13F'0'              SAVE AREA FOR 2 - 14\n$MCL&$MX DC    X'00'               SET TO X'80' WHEN EXECUTING\n&NAME    CSECT\n         AGO   .FINISH             SKIP TO STD CLEANUP\n.OK30    ANOP\n&NAME    CSECT\n         USING *,&$BASE(1)         ADDRESSABILITY\n&$USING(&$MPLVL) SETC '&$BASE(1)'  INITIALIZE USING\n         IF    (TM,$MCL&$MX,X'80',O),THENDO DO IF PROC ACTIVE\n           ABEND &$MABEND,DUMP     REENTRANT NOT SUPPORTED\n         ENDO  ,\n         OI    $MCL&$MX,X'80'      FLAG PROC ACTIVE\n         ST    &$LINK,$MSV&$MX     SAVE LINK REGISTER\n         TRC   ,'PROC ''&NAME'' ENTERED'\n         B     $MSP&$MX             AND B TO PROC PROPER\n         DC    CL8'&NAME.*******',CL10'-&SYSDATE ' FINGERPRINT\n$MEX&$MX NI    $MCL&$MX,X'7F'      FLAG PROC INACTIVE\n         TRC   ,'LEAVING PROC ''&NAME'''\n         L     &$LINK,$MSV&$MX     RESET LINK REGISTER\n         L     &$BASE(1),4(,&$LINK) RESTORE BASE REGISTER\n         B     8(,&$LINK)           AND RETURN\nDATAAREA CSECT\n$MSV&$MX DC    F'0'                SAVE AREA FOR LINK REG\n$MCL&$MX DC    X'00'               SET TO X'80' WHEN EXECUTING\n&NAME    CSECT\n         AGO   .FINISH             SKIP TO STD CLEANUP\n.OK40    ANOP\n&$MPCSV(&$MPLVL) SETA  1           SHOW NO REGS SAVED\n&NAME    CSECT\n         USING *,&$BASE(1)         ADDRESSABILITY\n&$USING(&$MPLVL) SETC '&$BASE(1)'  INITIALIZE USING\n         B     $MSP&$MX            B TO PROC PROPER\n         DC    CL8'&NAME.*******',CL10'-&SYSDATE ' FINGERPRINT\n$MEX&$MX L     &$BASE(1),4(,&$LINK) RESTORE BASE REGISTER\n         B     8(,&$LINK)          RETURN\n.FINISH  ANOP\n&$MENAME(&$MPLVL) SETC  '$MEX'.'&$MX'\n$MSP&$MX DC    0H'0'               START OF PROC\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PRTTBLE": {"ttr": 4619, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x00\\x00\\x98$_\\x00\\x984\\x8f\\x10B\\x00\\x18\\x00\\x15\\x00\\x18\\xc2\\xc3\\xd6\\xc4\\xc8\\xe2\\xf0@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1998-09-02T00:00:00", "modifydate": "1998-12-14T10:42:00", "lines": 24, "newlines": 21, "modlines": 24, "user": "BCODHS0"}, "text": "         MACRO\n&N       PRTTBLE &TABLE,&WREG=R3   DISPLAY SEARCH TABLE ON SYSPRINT\n         GBLC  &SUBCALL            PCALL/PERFORM DEPENDING ON VER 1/2\n&N       LA    &WREG,&TABLE        COPY BEGINNING OF TABLE TO REGISTER\n         MVC   OUTLINE(51),=CL51'0DEFINITION OF SCAN TABLE ''&TABLE'''\n         &SUBCALL PRINTRTN         PRINT 'HEADER' LINE\n         MVC   OUTLINE(51),=CL51' FLAGS     COUNT SCAN STRING'\n         &SUBCALL PRINTRTN         PRINT 'HEADER' LINE\n         MVI   CCCHAR,C'0'         NEXT LINE SHOULD BE DOUBLE SPACED\n         DO    UNTIL=(CLI,0(&WREG),255,E) STOP LOOP AT TABLE END\n           ICM   R1,3,0(&WREG)     GET TWO BYTES INTO REG 1\n           &SUBCALL CVXWORD        CONVERT ALL 4 BYTES TO HEX\n           STCM  R1,15,OUTLINE+2   COPY THE TWO BYTES WE WANT\n           ZAP   WS_PL4,2(4,&WREG) COPY COUNTER VALUE\n           EM    OUTLINE+6(10),WS_PL4 EDIT TO CHAR FORM\n           SLR   R1,R1             SET TO ZERO FOR MATH FUNCTION\n           IC    R1,0(,&WREG)      SET LOW ORDER BYTE TO LENGTH\n           EX    R1,*+4            COPY TEXT TO PRINT LINE\n           MVC   OUTLINE+17(0),6(&WREG) LAZY WAY OF DOING 'EX'\n           LA    &WREG,7(R1,&WREG) BUMP TO NEXT SEARCH STRING\n           &SUBCALL PRINTRTN       PRINT THE LINE JUST FORMATTED\n         ENDO  ,                   END OF PRINT LOOP\n         MVI   CCCHAR,C'0'         SET TO DOUBLE SPACE FOR NEXT PRINT\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RETN": {"ttr": 4621, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x994/\\x00\\x994/\\x14\\x01\\x00\\x18\\x00\\x18\\x00\\x00\\xc2\\xc3\\xd6\\xc4\\xc8\\xe2\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-08T00:00:00", "modifydate": "1999-12-08T14:01:00", "lines": 24, "newlines": 24, "modlines": 0, "user": "BCODHS0"}, "text": "         MACRO\n&NAME    RETN &COND\n         COPY  $MGBLDEF\n         GBLA  &VERSION            VERSION CONTROL\n         GBLC  &GRETN              RETRIEVE NAME OF EXIT ROUTINE\n         LCLA  &A\n         LCLC  &Y                  TO HOLD CONDITION\n         AIF   (&VERSION EQ 2).SKIP010\n         AIF   ('&SYSECT' NE '&$MSECT(1)').INPROC GO IF IN PROC\n         L     R13,4(,R13)         CHAIN BACK\n         LM    R14,R15,12(R13)     RESTORE EVERYTHING BUT\n         LM    R2,R12,28(R13)       ZERO AND ONE\n         BR    R14                 GOBACK\n         MEXIT\n.INPROC  ANOP\n         TRACER C'RETN EXECUTED IN PROC ''&$MSECT(&$MPLVL)'''\n&NAME    B     &$MENAME(&$MPLVL)   BRANCH TO COMMON EXIT ROUTINE\n.MEND    MEXIT\n.SKIP010 ANOP\n         AIF   (K'&COND GT 2).SKIP020 CAN'T BE VALID CONDITION...\n&Y       SETC  '&COND'             SET TO VALID(?) CONDITION\n.SKIP020 ANOP\n&NAME    B&Y   &GRETN              BRANCH TO COMMON EXIT ROUTINE\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RTTBEG": {"ttr": 4623, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00\\x00o\\x01\\x00\\x00o\\x18S\\x00\\x19\\x00\\x19\\x00\\x00\\xc2\\xc3\\xd6\\xc4\\xc8\\xe2\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-01-06T00:00:00", "modifydate": "2000-01-06T18:53:00", "lines": 25, "newlines": 25, "modlines": 0, "user": "BCODHS0"}, "text": "         MACRO\n         RTTBEG &TEXTLN=50,&MAXVAL=1234567\n         GBLA  &RTTTL,&RTTCL,&RTTTOTL,&RTTDEF LENGTHS & OCCURANCES\n         GBLB  &RTTODD             EVEN/ODD DIGIT COUNT FLAG\n         GBLC  &RTTNAME            NAME OF TABLE\n         AIF   (&RTTDEF EQ 0).NEXT010 GO IF FIRST EXAMPLE OF RTTBEG\n         MNOTE 8,'ONLY ONE RUN-TIME TABLE ALLOWED - SORRY'\n         MEXIT                     QUICK EXIT\n.NEXT010 ANOP                      CONTINUE\n&RTTDEF  SETA  1                   SHOW MACRO HAS BEEN CODED\n&RTTNAME SETC  'RTT&SYSNDX'        CREATE TABLE NAME\n&RTTNAME._DSECT DSECT              MAPPING DSECT\n&RTTTL   SETA  &TEXTLN             SET TO TEXT LENGTH\n&RTTODD  SETB  (1)                 ASSUME ODD NUMBER OF DIGITS\n&X       SETA  K'&MAXVAL           NUMBER OF DIGITS\n         AIF   (&X NE &X/2*2).NEXT030 GO IF ODD NUMBER OF DIGITS\n&RTTODD  SETB  (0)                 SHOW EVEN NUMBER\n.NEXT030 ANOP                      GET LENGTH FROM DIGIT COUNT:\n&RTTCL   SETA  (K'&MAXVAL+1)/2     CALCULATE PACKED LENGTH\n&RTTTOTL SETA  &RTTTL+&RTTCL       LENGTH OF EACH ENTRY\n&RTTNAME._COUNTER DC PL&RTTCL'0'   COUNTER MAP ENTRY\n&RTTNAME._TEXT DC  CL&RTTTL' '     TEXT MAP ENTRY\n&SYSECT  CSECT                     BACK TO CSECT\n&RTTNAME DC    0D'0'               BEGINNING OF TABLE ENTRIES\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RTTEND": {"ttr": 4625, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00\\x00o\\x01\\x00\\x00o\\x18S\\x00\\x10\\x00\\x10\\x00\\x00\\xc2\\xc3\\xd6\\xc4\\xc8\\xe2\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-01-06T00:00:00", "modifydate": "2000-01-06T18:53:00", "lines": 16, "newlines": 16, "modlines": 0, "user": "BCODHS0"}, "text": "         MACRO\n         RTTEND ,\n         GBLA  &RTTDEF\n         GBLC  &RTTNAME\n         AIF   (&RTTDEF NE 1).NEXT010 IT BETTER BE '1'...\n&RTTDEF  SETA  2                   SHOW END HAS OCCURED\n&RTTNAME._END DC 0C' '             DEFINE END OF TABLE\n         MEXIT\n.NEXT010 AIF   (&RTTDEF NE 0).NEXT020 0 -> NO RTTBEG CODED\n         MNOTE 8,'RTTEND MACRO INVALID BEFORE RTTBEG MACRO'\n         MNOTE 0,'PLEASE CORRECT AND RE-ASSEMBLE'\n         MEXIT\n.*                                 >1 -> RTTEND CODED\n.NEXT020 MNOTE 8,'RTTEND MACRO INVALID FOLLOWING ANOTHER RTTEND'\n         MNOTE 0,'PLEASE CORRECT AND RE-ASSEMBLE'\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RTTENT": {"ttr": 4627, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x995\\x0f\\x00\\x995\\x0f\\x14\\x00\\x00\\x1e\\x00\\x1e\\x00\\x00\\xc2\\xc3\\xd6\\xc4\\xc8\\xe2\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-16T00:00:00", "modifydate": "1999-12-16T14:00:00", "lines": 30, "newlines": 30, "modlines": 0, "user": "BCODHS0"}, "text": "         MACRO\n&NAME    RTTENT &TEXT=\n         GBLA  &RTTTL,&RTTCL,&RTTDEF\n         AIF   (&RTTDEF EQ 0).NEXT000  0 ==> RTTBEG NOT YET CODED\n         AIF   (&RTTDEF EQ 1).NEXT010  1 ==> A-OK - RTTBEG CODED\n         AIF   (&RTTDEF EQ 2).NEXT005  2 ==> RTTEND ALREADY CODED\n         MNOTE 8,'INVALID VALUE &RTTDEF FOR &&RTTDEF - PROBABLE MACRO LX\n               OGIC ERROR'\n         MEXIT\n.NEXT000 MNOTE 8,'RTTENT MACRO INVALID PRECEDING RTTBEG MACRO'\n         MNOTE 0,'PLEASE CORRECT AND RE-ASSEMBLE'\n         MEXIT\n.NEXT005 MNOTE 8,'RTTENT MACRO INVALID FOLLOWING RTTEND MACRO'\n         MNOTE 0,'PLEASE CORRECT AND RE-ASSEMBLE'\n         MEXIT\n.NEXT010 AIF   ('&NAME' NE '').NEXT015 MUST HAVE COUNTER NAME\n         MNOTE 8,'NAME MISSING FROM RTT ENTRY STATEMENT: COUNTER GENERAC\n               TION IMPOSSIBLE'\n         MEXIT\n.NEXT015 ANOP\n&NAME    DC    PL&RTTCL'0'         COUNTER\n         AIF   ('&TEXT' NE '').NEXT020\n*        MNOTE 0,'TEXT FOR COUNTER ASSUMED TO BE NAME OF COUNTER'\n         DC    CL&RTTTL'&NAME'     COUNTER NAME FOR TITLE\n         MEXIT\n.NEXT020 AIF   ('&TEXT'(1,1) EQ '''').NEXT030 GO IF QUOTED\n         DC    CL&RTTTL'&TEXT'     TITLE FOR AMOUNT TO BE PRINTED\n         MEXIT\n.NEXT030 DC    CL&RTTTL&TEXT       TITLE FOR AMOUNT TO BE PRINTED\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RTTINCR": {"ttr": 4629, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00\\x00o\\x01\\x00\\x00o\\x18S\\x00\\x04\\x00\\x04\\x00\\x00\\xc2\\xc3\\xd6\\xc4\\xc8\\xe2\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-01-06T00:00:00", "modifydate": "2000-01-06T18:53:00", "lines": 4, "newlines": 4, "modlines": 0, "user": "BCODHS0"}, "text": "         MACRO\n&NAME    RTTINCR &KEYWORD,&AMOUNT  FIND TABLE ENTRY THEN INCREMENT\n&NAME    IP    &KEYWORD,&AMOUNT    INCR BY SPECIFIED AMOUNT\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RTTPRT": {"ttr": 4865, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x98$O\\x00\\x995\\x0f\\x14\\x02\\x00\\x1d\\x00\\x1d\\x00\\x00\\xc2\\xc3\\xd6\\xc4\\xc8\\xe2\\xf0@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1998-09-01T00:00:00", "modifydate": "1999-12-16T14:02:00", "lines": 29, "newlines": 29, "modlines": 0, "user": "BCODHS0"}, "text": "         MACRO\n&NAME    RTTPRT &RESET=NO\n         COPY  $MGBLDEF\n         GBLA  &RTTTL,&RTTCL,&RTTTOTL\n         GBLB  &RTTODD              CONTROLS ZEROING OF HIGH DIGIT\n         GBLC  &RTTNAME,&SUBCALL\n&NAME    ST    R10,R10&SYSNDX\n         $WA                        SET LOCTR TO WORK AREA\nR10&SYSNDX DC    F'0'               SAVE AREA FOR WORK REGISTER\n         $IA                        SET LOCTR TO INSTRUCTION AREA\n         LA    R10,&RTTNAME         ADDR OF FIRST TABLE ENTRY\n         DO    UNTIL=(CL,R10,=A(&RTTNAME._END),NL) PRINT ENTIRE TABLE\n           USING &RTTNAME._DSECT,R10 SET ADDRESSABILITY\n&DIGITS    SETA  &RTTCL*2-1         NUMBER OF DIGITS TO PRINT\n&COMMAS    SETA  (&DIGITS+2)/3-1    NUMBER OF COMMAS REQUIRED\n&CHARS     SETA  &DIGITS+&COMMAS    NUMBER OF PRINT POSITIONS REQ'D\n           AIF   (&RTTODD).NEXT010  SKIP IF ODD NUMBER OF DIGITS\n           NI    &RTTNAME._COUNTER,X'0F' SET HIGH ORDER TO ZERO\n.NEXT010   ANOP\n           EM    OUTLINE+1(&CHARS),&RTTNAME._COUNTER FORMAT IT\n           MVC   OUTLINE+2+&CHARS.(&RTTTL),&RTTNAME._TEXT MOVE IN TITLE\n          &SUBCALL PRINTRTN         PRINT A LINE\n           AIF   ('&RESET' NE 'Y' AND '&RESET' NE 'YES').SKIP020\n           PACK  &RTTNAME._COUNTER,=Z'0' RESET TO ZERO\n           DROP  R10                DROP ADDRESSABILITY\n.SKIP020   I     R10,&RTTTOTL       INCREMENT ADDRESS TO NEXT ENTRY\n         ENDO  ,                    END OF PRINT LOOP\n         L     R10,R10&SYSNDX       RESTORE WORK REGISTER\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "RTTRESET": {"ttr": 4867, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00\\x00o\\x01\\x00\\x00o\\x18S\\x00\\x14\\x00\\x14\\x00\\x00\\xc2\\xc3\\xd6\\xc4\\xc8\\xe2\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-01-06T00:00:00", "modifydate": "2000-01-06T18:53:00", "lines": 20, "newlines": 20, "modlines": 0, "user": "BCODHS0"}, "text": "         MACRO\n&NAME    RTTRESET &KEYWORD         RESET ONE OR ALL COUNTERS\n         COPY  $MGBLDEF\n         GBLA  &RTTTL,&RTTCL,&RTTTOTL LENGTHS OF DATA ITEMS\n         GBLC  &RTTNAME            NAME OF TABLE\n         AIF   ('&KEYWORD' EQ '').NEXT010 GO IF ENTIRE TABLE REQUESTED\n&NAME    PACK  &KEYWORD,=Z'0'      SET COUNTER TO ZERO\n         AIF   ('&SYSLIST(2)' EQ '').MEND EXIT IF ONLY ONE\n&I       SETA  2                   START LOOP WITH 2ND NAME\n.LOOP000 PACK  &SYSLIST(&I),=Z'0'  SET REQUESTED COUNTER TO ZERO\n&I       SETA  &I+1                BUMP INDEX\n         AIF   ('&SYSLIST(&I)' NE '').LOOP000 BACK IF MORE TO DO\n         MEXIT\n.NEXT010 ANOP\n&NAME    LA    &R1,&RTTNAME\n         DO    UNTIL=(CL,&R1,=A(&RTTNAME._END),NL)\n           PACK  &RTTNAME._COUNTER-&RTTNAME._DSECT(,&R1),=Z'0'\n           I     &R1,&RTTTOTL\n         ENDO  ,\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SAMPLE": {"ttr": 4869, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x995\\x0f\\x00\\x995\\x0f\\x10D\\x02\\x82\\x02\\x82\\x00\\x00\\xc2\\xc3\\xd6\\xc4\\xc8\\xe2\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-16T00:00:00", "modifydate": "1999-12-16T10:44:00", "lines": 642, "newlines": 642, "modlines": 0, "user": "BCODHS0"}, "text": "SAMPLE   TITLE 'ASSEMBLER SAMPLE'\n*                                                                     *\n*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\n* ASSEMBLER SAMPLE SHOWING 'IF' AND RELATED MACRO USEAGE              *\n* 'INST' LOCTR USED FOR EXECUTABLE INSTRUCTIONS                       *\n* 'DATA' LOCTR USED FOR DATA                                          *\n*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\n*                                                                     *\n         SPACE 1\n*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\n* GLOBAL SET SYMBOL CONTROLS INCLUSION OF DIAGNOSTIC CODE AND SET UP  *\n* NAMES FOR INSTRUCTION AND DATA AREA LOCATION COUNTERS               *\n*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\n         SPACE 1\n         GBLC  &TESTSW,&GSECT,&WSECT\n&TESTSW  SETC  'NO'                SET TO 'YES' FOR DIAGNOSTIC HELP\n&GSECT   SETC  'INST'              THESE SYMBOLS ARE USED BY MACROS\n&WSECT   SETC  'DATA'              . THAT GENERATE 'DC' INSTRUCTIONS\n         SPACE 1\n         PRINT   GEN               SET PRINT GEN LEVEL\n         SPACE 1\n*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\n* SET UP PROGRAM CSECT AND LOCATION COUNTERS FOR INSTRUCTION AREA AND *\n* DATA AREA. DEFINE REGISTER SAVE AREA                                *\n*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\n         SPACE 1\nSAMPLE   CSECT ,\n         SPACE 1\nINST     LOCTR ,                   INSTRUCTION LOCATION COUNTER\nDATA     LOCTR ,                   DATA AREA LOCATION COUNTER\n         SPACE 1\nSAVEAREA DC    18F'0'              STD REG SAVE AREA\n         EJECT\n         SPACE 1\n*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\n* VARIABLES, CONSTANTS, DCB'S ETC.                                    *\n*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\n         SPACE 2\nADDRSAVE DC    A(SAVEAREA)\nA        DC    A(*)\nB        DC    A(*)\nC        DC    A(*)\nD        DC    A(*)\nE        DC    A(*)\nF        DC    A(*)\nG        DC    A(*)\nH        DC    A(*)\nI        DC    A(*)\nJ        DC    A(*)\nK        DC    A(*)\nL        DC    A(*)\nM        DC    A(*)\nN        DC    A(*)\nO        DC    A(*)\nP        DC    A(*)\nQ        DC    A(*)\nR        DC    A(*)\nS        DC    A(*)\nT        DC    A(*)\nU        DC    A(*)\nV        DC    A(*)\nW        DC    A(*)\nX        DC    A(*)\nY        DC    A(*)\nZ        DC    A(*)\nP1       DC    PL4'1234567'\n         EJECT\n         SPACE 1\n*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\n* HERE COME THE INSTRUCTIONS - SET UP BASE REGS -> ADDRESSABILITY     *\n*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\n         SPACE 1\nSAMPLE   CSECT\n         SPACE 1\nINST     LOCTR                     ENTER INSTRUCTION ZONE\n         USING *,R3,R4,R5          INFORM ASSEMBLER\n         STM   R14,R12,12(R13)     SAVE REGS\n         LR    R3,R15              PRIME BASE REG\n         LA    R5,2048             LOAD INCREMENT\n         LA    R4,2048(R5,R3)      SET UP BASE\n         LA    R5,2048(R5,R4)      SET UP BASE\n         L     R14,ADDRSAVE        POINT TO MY SAVE AREA\n         ST    R14,8(,R13)         FORWARD CHAIN\n         ST    R13,4(,R14)         BACK CHAIN\n         LR    R13,R14             SET UP MY SAVEAREA\n         LA    R12,2048            LOAD INCREMENT\n         LA    R12,2048(R12,R13)   SET UP BASE\n         USING SAVEAREA,R13,R12    WORK AREA BASE REGISTERS\n         SPACE 2\n***********************************************************************\n* IF A THENDO                                                         *\n***********************************************************************\n         SPACE 2\nTEST1    IF    (CLC,A,Z,E),THENDO\n         SPACE\n           L     R15,B             MOVE 'B' TO REGISTER 15\n           ST    R15,B             . THEN BACK TO ITSELF\n         SPACE\n         ENDIF ,\n         EJECT\n         SPACE 2\n***********************************************************************\n* IF A OR B THENDO - PLUS EXAMPLE OF 'ELSEIF'                         *\n***********************************************************************\n         SPACE 2\nTEST2    IF    (CLC,A,Z,E),OR,                                         C\n               (CLC,B,Z,E),THENDO\n         SPACE\n           L     R15,B             MOVE 'B' TO REGISTER 15\n           ST    R15,B             . THEN BACK TO ITSELF\n         SPACE\nTEST2A  ELSEIF (CLC,A,Z,E),OR,                                         C\n               (CLC,B,Z,E),THENDO\n         SPACE\n           L     R15,B             MOVE 'B' TO REGISTER 15\n           ST    R15,B             . THEN BACK TO ITSELF\n         SPACE\nTEST2B  ELSEIF (CLC,A,Z,E),OR,                                         C\n               (CLC,B,Z,E),THENDO\n         SPACE\n           L     R15,B             MOVE 'B' TO REGISTER 15\n           ST    R15,B             . THEN BACK TO ITSELF\n         SPACE\nTEST2C  ELSEIF (CLC,A,Z,E),OR,                                         C\n               (CLC,B,Z,E),THENDO\n         SPACE\n           L     R15,B             MOVE 'B' TO REGISTER 15\n           ST    R15,B             . THEN BACK TO ITSELF\n         SPACE\nTEST2D   ELSE\n         SPACE\n           L     R15,B             MOVE 'B' TO REGISTER 15\n           ST    R15,B             . THEN BACK TO ITSELF\n         SPACE\n         ENDIF ,\n         EJECT\n         SPACE 2\n***********************************************************************\n* IF A AND B THENDO - PLUS ERROR EXAMPLE OF 'ELSEIF'                  *\n***********************************************************************\n         SPACE 2\nTEST3    IF    (CLC,A,Z,E),AND,                                        C\n               (CLC,B,Z,E),THENDO\n         SPACE\n           L     R15,B             MOVE 'B' TO REGISTER 15\n           ST    R15,B             . THEN BACK TO ITSELF\n         SPACE\n         ELSE  ,\n         SPACE\n           L     R15,C             MOVE 'C' TO REGISTER 15\n           ST    R15,C             . THEN BACK TO ITSELF\n         SPACE\nTEST3A  ELSEIF (CLC,A,Z,E),AND,                                        C\n               (CLC,B,Z,E),THENDO\n         SPACE\n           L     R15,B             MOVE 'B' TO REGISTER 15\n           ST    R15,B             . THEN BACK TO ITSELF\n         SPACE\n         ENDELSE ,                 (OR COULD BE 'ENDIF')\n         SPACE\n         EJECT\n         SPACE 2\n***********************************************************************\n* 'DO' MACRO WITH ERROR EXAMPLE OF 'ELSEIF'                           *\n***********************************************************************\n         SPACE 2\nTEST3B   DO    5\n         SPACE\n           L     R15,B             MOVE 'B' TO REGISTER 15\n           ST    R15,B             . THEN BACK TO ITSELF\n         SPACE\nTEST3C  ELSEIF (CLC,A,Z,E),AND,                                        C\n               (CLC,B,Z,E),THENDO\n         SPACE\n           L     R15,B             MOVE 'B' TO REGISTER 15\n           ST    R15,B             . THEN BACK TO ITSELF\n         SPACE\n         ENDELSE ,\n         EJECT\n         SPACE 2\n***********************************************************************\n* IF A OR B OR C OR D OR E OR F THENDO                                *\n***********************************************************************\n         SPACE 2\nTEST4    IF    (CLC,A,Z,E),OR,                                         C\n               (CLC,B,Z,E),OR,                                         C\n               (CLC,C,Z,E),OR,                                         C\n               (CLC,D,Z,E),OR,                                         C\n               (CLC,E,Z,E),OR,                                         C\n               (CLC,F,Z,E),THENDO\n         SPACE\n           L     R15,B             MOVE 'B' TO REGISTER 15\n           ST    R15,B             . THEN BACK TO ITSELF\n         SPACE\n         ENDIF ,\n         EJECT\n         SPACE 2\n***********************************************************************\n* TEST ELSEIF AT SEVERAL LEVELS                                       *\n***********************************************************************\n         SPACE 2\nTEST4A   IF    (CLC,A,Z,E),THENDO\n           SPACE\n           L     R15,B             MOVE 'B' TO REGISTER 15\n           ST    R15,B             . THEN BACK TO ITSELF\n           SPACE\n         ELSEIF (CLC,A,Z,E),THENDO\n           SPACE\n           L     R15,B             MOVE 'B' TO REGISTER 15\n           ST    R15,B             . THEN BACK TO ITSELF\n           SPACE\n           IF    (CLC,A,Z,E),THENDO\n             SPACE\n             L     R15,B           MOVE 'B' TO REGISTER 15\n             ST    R15,B           . THEN BACK TO ITSELF\n             SPACE\n           ELSEIF (CLC,D,Z,E),THENDO\n             SPACE\n             L     R15,D           MOVE 'D' TO REGISTER 15\n             ST    R15,D           . THEN BACK TO ITSELF\n             SPACE\n           ENDELSE\n           SPACE\n         ENDIF ,\n         EJECT\n         SPACE 2\n***********************************************************************\n* IF A AND B AND C AND D AND E AND F THENDO                           *\n***********************************************************************\n         SPACE 2\nTEST5    IF    (CLC,A,Z,E),AND,                                        C\n               (CLC,B,Z,E),AND,                                        C\n               (CLC,C,Z,E),AND,                                        C\n               (CLC,D,Z,E),AND,                                        C\n               (CLC,E,Z,E),AND,                                        C\n               (CLC,F,Z,E),THENDO\n           SPACE\n           L     R15,B             MOVE 'B' TO REGISTER 15\n           ST    R15,B             . THEN BACK TO ITSELF\n           SPACE\n         ENDIF ,\n         EJECT\n         SPACE 2\n***********************************************************************\n* IF A OR B AND C OR D AND E OR F THENDO                              *\n***********************************************************************\n         SPACE 2\nTEST6    IF    (CLC,A,Z,E),OR,                                         C\n               (CLC,B,Z,E),AND,                                        C\n               (CLC,C,Z,E),OR,                                         C\n               (CLC,D,Z,E),AND,                                        C\n               (CLC,E,Z,E),OR,                                         C\n               (CLC,F,Z,E),THENDO\n           SPACE\n           L     R15,B             MOVE 'B' TO REGISTER 15\n           ST    R15,B             . THEN BACK TO ITSELF\n           SPACE\n         ENDIF ,\n         EJECT\n         SPACE 2\n***********************************************************************\n* IF A AND B OR C AND D OR E AND F THENDO                             *\n***********************************************************************\n         SPACE 2\nTEST7    IF    (CLC,A,Z,E),AND,                                        C\n               (CLC,B,Z,E),OR,                                         C\n               (CLC,C,Z,E),AND,                                        C\n               (CLC,D,Z,E),OR,                                         C\n               (CLC,E,Z,E),AND,                                        C\n               (CLC,F,Z,E),THENDO\n         SPACE\n           L     R15,B             MOVE 'B' TO REGISTER 15\n           ST    R15,B             . THEN BACK TO ITSELF\n         SPACE\n         ENDIF ,\n         EJECT\n         SPACE 2\n***********************************************************************\n* IF ((A OR B) AND (C OR D)) AND (E OR F) THENDO                      *\n***********************************************************************\n         SPACE 2\nTEST8    IF    (((CLC,A,B,E),OR,                                       C\n               (CLC,B,Z,E)),AND,                                       C\n               ((CLC,C,Z,E),OR,                                        C\n               (CLC,D,Z,E))),AND,                                      C\n               ((CLC,E,Z,E),OR,                                        C\n               (CLC,F,Z,E)),THENDO\n         SPACE\n           L     R15,B             MOVE 'B' TO REGISTER 15\n           ST    R15,B             . THEN BACK TO ITSELF\n         SPACE\n         ENDIF ,\n         EJECT\n         SPACE 2\n***********************************************************************\n* IF ((A)) THENDO                                                     *\n***********************************************************************\n         SPACE 2\nTEST9    IF    (((CLC,A,B,E))),THENDO\n         SPACE\n           L     R15,B             MOVE 'B' TO REGISTER 15\n           ST    R15,B             . THEN BACK TO ITSELF\n         SPACE\n         ENDO  ,\n         EJECT\n         SPACE 2\n***********************************************************************\n* IF ((A)) OR ((B)) THENDO                                            *\n***********************************************************************\n         SPACE 2\nTEST10   IF    (((CLC,A,B,E))),OR,                                     C\n               (((CLC,B,Z,E))),THENDO\n         SPACE\n           L     R15,B             MOVE 'B' TO REGISTER 15\n           ST    R15,B             . THEN BACK TO ITSELF\n         SPACE\n         ENDIF ,\n         EJECT\n         SPACE 2\n***********************************************************************\n* IF ((A)) AND ((B)) THENDO                                           *\n***********************************************************************\n         SPACE 2\nTEST11   IF    (((CLC,A,B,E))),AND,                                    C\n               (((CLC,B,Z,E))),THENDO\n         SPACE\n           L     R15,B             MOVE 'B' TO REGISTER 15\n           ST    R15,B             . THEN BACK TO ITSELF\n         SPACE\n         ENDIF ,\n         EJECT\n         SPACE 2\n***********************************************************************\n* IF A AND (B AND C OR D AND E) THENDO                                *\n***********************************************************************\n         SPACE 2\nTEST12   IF    (CLC,A,Z,E),AND,                                        C\n               ((CLC,B,Z,E),AND,                                       C\n               (CLC,C,Z,E),OR,                                         C\n               (CLC,D,Z,E),AND,                                        C\n               (CLC,E,Z,E)),THENDO\n         SPACE\n           L     R15,B             MOVE 'B' TO REGISTER 15\n           ST    R15,B             . THEN BACK TO ITSELF\n         SPACE\n         ENDIF ,\n         EJECT\n         SPACE 2\n***********************************************************************\n* IF (((((((((((((((((((A))))))))))))))))))) THENDO                   *\n***********************************************************************\n         SPACE 2\nTEST13   IF    ((((((((((((((((((((CLC,A,Z,E)))))))))))))))))))),      C\n               THENDO\n         SPACE\n           L     R15,B             MOVE 'B' TO REGISTER 15\n           ST    R15,B             . THEN BACK TO ITSELF\n         SPACE\n         ENDIF ,\n         EJECT\n         SPACE 2\n***********************************************************************\n* IF (((((((((((((((((((A)))))))))) OR B))))))))) THENDO              *\n***********************************************************************\n         SPACE 2\nTEST14   IF    ((((((((((((((((((((CLC,A,Z,E)))))))))),OR,             C\n               (CLC,B,Z,E))))))))))),THENDO\n         SPACE\n           L     R15,B             MOVE 'B' TO REGISTER 15\n           ST    R15,B             . THEN BACK TO ITSELF\n         SPACE\n         ENDIF ,\n         EJECT\n         SPACE 2\n***********************************************************************\n* IF (((((((((((((((((((A)))))))))) AND B))))))))) THENDO             *\n***********************************************************************\n         SPACE 2\nTEST15   IF    ((((((((((((((((((((CLC,A,Z,E)))))))))),AND,            C\n               (CLC,B,Z,E))))))))))),THENDO\n         SPACE\n           L     R15,B             MOVE 'B' TO REGISTER 15\n           ST    R15,B             . THEN BACK TO ITSELF\n         SPACE\n         ENDIF ,\n         EJECT\n         SPACE 2\n***********************************************************************\n* IF (((((((((((((((((((A))) OR B)) AND C)) OR D)) AND E)) OR F))     *\n* AND G)) OR H)) AND I)) THENDO                                       *\n***********************************************************************\n         SPACE 2\nTEST16   IF    ((((((((((((((((((((CLC,A,Z,E)))),OR,                   C\n               (CLC,B,Z,E))),AND,                                      C\n               (CLC,C,Z,E))),OR,                                       C\n               (CLC,D,Z,E))),AND,                                      C\n               (CLC,E,Z,E))),OR,                                       C\n               (CLC,F,Z,E))),AND,                                      C\n               (CLC,G,Z,E))),OR,                                       C\n               (CLC,H,Z,E))),AND,                                      C\n               (CLC,I,Z,E))),THENDO\n         SPACE\n           L     R15,B             MOVE 'B' TO REGISTER 15\n           ST    R15,B             . THEN BACK TO ITSELF\n         SPACE\n         ENDIF ,\n         EJECT\n         SPACE 2\n***********************************************************************\n* IF (((((((((((((((((((A))) AND B)) OR C)) AND D)) OR E)) AND F))    *\n* OR G)) AND H)) OR I)) THENDO                                        *\n***********************************************************************\n         SPACE 2\nTEST17   IF    ((((((((((((((((((((CLC,A,Z,E)))),AND,                  C\n               (CLC,B,Z,E))),OR,                                       C\n               (CLC,C,Z,E))),AND,                                      C\n               (CLC,D,Z,E))),OR,                                       C\n               (CLC,E,Z,E))),AND,                                      C\n               (CLC,F,Z,E))),OR,                                       C\n               (CLC,G,Z,E))),AND,                                      C\n               (CLC,H,Z,E))),OR,                                       C\n               (CLC,I,Z,E))),THENDO\n         SPACE\n           L     R15,B             MOVE 'B' TO REGISTER 15\n           ST    R15,B             . THEN BACK TO ITSELF\n         SPACE\n         ENDIF ,\n         EJECT\n         SPACE 2\n***********************************************************************\n* IF (A AND (B AND (C AND (D AND E) AND F) AND G) AND H) THENDO       *\n***********************************************************************\n         SPACE 2\nTEST18   IF    ((CLC,A,Z,E),AND,                                       C\n               ((CLC,B,Z,E),AND,                                       C\n               ((CLC,C,Z,E),AND,                                       C\n               ((CLC,D,Z,E),AND,                                       C\n               (CLC,E,Z,E)),AND,                                       C\n               (CLC,F,Z,E)),AND,                                       C\n               (CLC,G,Z,E)),AND,                                       C\n               (CLC,H,Z,E)),THENDO\n         SPACE\n           L     R15,B             MOVE 'B' TO REGISTER 15\n           ST    R15,B             . THEN BACK TO ITSELF\n         SPACE\nTEST18A ELSEIF ((CLC,A,Z,E),AND,                                       C\n               ((CLC,B,Z,E),AND,                                       C\n               ((CLC,C,Z,E),AND,                                       C\n               ((CLC,D,Z,E),AND,                                       C\n               (CLC,E,Z,E)),AND,                                       C\n               (CLC,F,Z,E)),AND,                                       C\n               (CLC,G,Z,E)),AND,                                       C\n               (CLC,H,Z,E)),THENDO\n         SPACE\n           L     R15,B             MOVE 'B' TO REGISTER 15\n           ST    R15,B             . THEN BACK TO ITSELF\n         SPACE\n         ENDIF ,\n         EJECT\n         SPACE 2\n***********************************************************************\n* IF (A OR (B OR (C OR (D OR E) OR F) OR G) OR H) THENDO              *\n***********************************************************************\n         SPACE 2\nTEST19   IF    ((CLC,A,Z,E),OR,                                        C\n               ((CLC,B,Z,E),OR,                                        C\n               ((CLC,C,Z,E),OR,                                        C\n               ((CLC,D,Z,E),OR,                                        C\n               (CLC,E,Z,E)),OR,                                        C\n               (CLC,F,Z,E)),OR,                                        C\n               (CLC,G,Z,E)),OR,                                        C\n               (CLC,H,Z,E)),THENDO\n         SPACE\n           L     R15,B             MOVE 'B' TO REGISTER 15\n           ST    R15,B             . THEN BACK TO ITSELF\n         SPACE\n         ENDIF ,\n         EJECT\n         SPACE 2\n***********************************************************************\n* IF A OR B AND (C OR D AND (E OR F AND G) AND H) AND                 *\n*    I OR J AND (K OR L AND (M OR N AND O) AND P) OR                  *\n*    Q OR R AND (S OR T AND (U OR V AND W) AND X) THENDO              *\n***********************************************************************\n         SPACE 2\nTEST20   IF    (CLC,A,Z,E),OR,                                         C\n               (CLC,B,Z,E),AND,                                        C\n               ((CLC,C,Z,E),OR,                                        C\n               (CLC,D,Z,E),AND,                                        C\n               ((CLC,E,Z,E),OR,                                        C\n               (CLC,F,Z,E),AND,                                        C\n               (CLC,G,Z,E)),AND,                                       C\n               (CLC,H,Z,E)),AND,                                       C\n               (CLC,I,Z,E),OR,                                         C\n               (CLC,J,Z,E),AND,                                        C\n               ((CLC,K,Z,E),OR,                                        C\n               (CLC,L,Z,E),AND,                                        C\n               ((CLC,M,Z,E),OR,                                        C\n               (CLC,N,Z,E),AND,                                        C\n               (CLC,O,Z,E)),AND,                                       C\n               (CLC,P,Z,E)),OR,                                        C\n               (CLC,Q,Z,E),OR,                                         C\n               (CLC,R,Z,E),AND,                                        C\n               ((CLC,S,Z,E),OR,                                        C\n               (CLC,T,Z,E),AND,                                        C\n               ((CLC,U,Z,E),OR,                                        C\n               (CLC,V,Z,E),AND,                                        C\n               (CLC,W,Z,E)),AND,                                       C\n               (CLC,X,Z,E)),THENDO\n         SPACE\n           L     R15,B             MOVE 'B' TO REGISTER 15\n           ST    R15,B             . THEN BACK TO ITSELF\n         SPACE\n         ENDIF ,\n         EJECT\n         SPACE 2\n***********************************************************************\n* SAME IF - DIFFERENT FORMAT                                          *\n***********************************************************************\n         SPACE 2\nTEST21   IF    (CLC,A,Z,E),OR,(CLC,B,Z,E),AND,((CLC,C,Z,E),OR,(CLC,D,Z,C\n               E),AND,((CLC,E,Z,E),OR,(CLC,F,Z,E),AND,(CLC,G,Z,E)),AND,C\n               (CLC,H,Z,E)),AND,(CLC,I,Z,E),OR,(CLC,J,Z,E),AND,((CLC,K,C\n               Z,E),OR,(CLC,L,Z,E),AND,((CLC,M,Z,E),OR,(CLC,N,Z,E),AND,C\n               (CLC,O,Z,E)),AND,(CLC,P,Z,E)),OR,(CLC,Q,Z,E),OR,(CLC,R,ZC\n               ,E),AND,((CLC,S,Z,E),OR,(CLC,T,Z,E),AND,((CLC,U,Z,E),OR,C\n               (CLC,V,Z,E),AND,(CLC,W,Z,E)),AND,(CLC,X,Z,E)),THENDO\n         SPACE\n           L     R15,B             MOVE 'B' TO REGISTER 15\n           ST    R15,B             . THEN BACK TO ITSELF\n         SPACE\n         ENDIF ,\n         EJECT\n         SPACE 2\n***********************************************************************\n* TEST VARYING INSTRUCTION TYPES - SRP & SSCH                         *\n***********************************************************************\n         SPACE 2\nTEST22   IF    (CLC,A,Z,E),AND,                                        C\n               (SRP,P1,64-3,5,M),AND,                                  C\n               (UPT,L),AND,                                            C\n               (SSCH,12,O),THENDO\n         SPACE\n           L     R15,B             MOVE 'B' TO REGISTER 15\n           ST    R15,B             . THEN BACK TO ITSELF\n         SPACE\n         ENDIF ,\n         EJECT\n         SPACE 2\n***********************************************************************\n* 'DO' STATEMENT                                                      *\n***********************************************************************\n         SPACE 2\nTEST23   DO    WHILE=(CLC,A,Z,E)\n         SPACE\n           L     R15,B             MOVE 'B' TO REGISTER 15\n           ST    R15,B             . THEN BACK TO ITSELF\n         SPACE\n         ENDO  ,\n         EJECT\n         SPACE 2\n***********************************************************************\n* 'DO' STATEMENT                                                      *\n***********************************************************************\n         SPACE 2\nTEST24   DO    WHILE=(CLC,A,Z,E),TEST=AFTER\n         SPACE\n           L     R15,B             MOVE 'B' TO REGISTER 15\n           ST    R15,B             . THEN BACK TO ITSELF\n         SPACE\n         ENDO  ,\n         EJECT\n         SPACE 2\n***********************************************************************\n* 'FIRST'                                                             *\n***********************************************************************\n         SPACE 2\nTEST25   FIRST 1                   GENERATE 'TM' TYPE LOGIC\n         SPACE\n           L     R15,B             MOVE 'B' TO REGISTER 15\n           ST    R15,B             . THEN BACK TO ITSELF\n         SPACE\n         ENDFIRST ,\n         EJECT\n         SPACE 2\n***********************************************************************\n* 'FIRST'                                                             *\n***********************************************************************\n         SPACE 2\nTEST25A  FIRST 2                   GENERATE PACKED DECIMAL TYPE LOGIC\n         SPACE\n           L     R15,B             MOVE 'B' TO REGISTER 15\n           ST    R15,B             . THEN BACK TO ITSELF\n         SPACE\n         ENDFIRST ,\n         EJECT\n         SPACE 2\n***********************************************************************\n* 'AFTER'                                                             *\n***********************************************************************\n         SPACE 2\nTEST26   AFTER 1234567890123456789012345678901 31 DIGITS\n         SPACE\n           L     R15,B             MOVE 'B' TO REGISTER 15\n           ST    R15,B             . THEN BACK TO ITSELF\n         SPACE\n         ENDAFTER ,\n         EJECT\n         SPACE 2\n***********************************************************************\n* 'EVERY'                                                             *\n***********************************************************************\n         SPACE 2\nTEST27   EVERY 1000000             1,000,000\n         SPACE\n           L     R15,B             MOVE 'B' TO REGISTER 15\n           ST    R15,B             . THEN BACK TO ITSELF\n         SPACE\n         ENDEVERY ,\n         EJECT\n         SPACE 2\nRETURN   EQU   *\n         L     R1,4(,R13)          BACK CHAIN TO SET R/C\n         SLR   R15,R15             ASSUME R/C ZERO\n         ST    R15,16(,R1)         STUFF R/C BACK INTO SAVEAREA\n         L     R13,4(,R13)         BACK CHAIN\n         LM    R14,R12,12(R13)     RESTORE REGS\n         BR    R14                 RETURN\n         PRINT OFF                 REGISTER EQUATES\n&X       SETA  0                   INDEX FOR EQUATES\n.LOOP    ANOP                      HEAD OF LOOP\nR&X      EQU   &X                  REGISTER EQUATE\n&X       SETA  &X+1                BUMP INDEX\n         AIF   (&X LE 15).LOOP     DO ALL 15\n         PRINT ON                  REGISTER EQUATES\nLEN_INST EQU   *-SAMPLE\nDATA     LOCTR\n         LTORG ,                   FORCE OUT LITERALS\nLEN_DATA EQU   *-SAVEAREA\nINST     LOCTR\nLEN_PROG EQU   (LEN_INST+LEN_DATA+7)/8*8\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SECONDEP": {"ttr": 5124, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00\\x00o\\x01\\x00\\x00o\\x18S\\x00&\\x00&\\x00\\x00\\xc2\\xc3\\xd6\\xc4\\xc8\\xe2\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-01-06T00:00:00", "modifydate": "2000-01-06T18:53:00", "lines": 38, "newlines": 38, "modlines": 0, "user": "BCODHS0"}, "text": "         MACRO\n&TYPE    SECONDEP &DUMMY,&PROGID=MAIN,&INST=,&DATA=,&BASE=,&LINK=\n         COPY  $MGBLDEF\n         GBLC  &GSECT,&WSECT       SECTION NAMES\n         GBLC  &NSECT              SECTION NAME\n         GBLC  &GSAVE              SAVE AREA NAME\n         GBLC  &GPROG              SET TO CSECT NAME\n         GBLC  &PARM               INTERNAL USE ONLY\n         GBLC  &GBASE,&GLINK       DEFINE GLOBAL BASE AND LINK REGS\n         GBLC  &GRETN,&GSKIP       FOR SECTION MACRO\n         GBLB  &SEQSW              SEQUENCE SWITCH\n         LCLC  &X                  FOR ENTRY STATEMENT\n         VERSION 2\n&X       SETC  '&SYSNDX'           SHORTHAND\n         USING *,R15               TEMPORARY BASE REGISTER\n         DROP  R12,R13             TEMPORARILY\n         STM   R14,R12,12(R13)     SAVE CALLER'S REGS\n         L     &GBASE,=A(&GSECT)   LOAD BASE REG\n         USING &GSECT,&GBASE       REESTABLISH\n         DROP  R15                 BACK TO STD BASE REG\n         XC    16(4,R13),16(R13)   SET ZERO RETURN CODE\n         L     R15,=A(&GSAVE)      SAVE\n         ST    R15,8(,R13)         . AREA\n         ST    R13,4(,R15)         . CHAINING\n         LR    R13,R15             PRIME OUR SAVE POINTER\n         USING &GSAVE,R13          REESTABLISH\n&GRETN   SETC  'RETN&X'            UNIQUE TAG FOR EXIT\n         DC    0C'&&GRETN SET TO RETN&X'\n&GSKIP   SETC  'SKIP&X'            UNIQUE TAG FOR END OF SECTION\n         DC    0C'&&GSKIP SET TO SKIP&X'\n         B     STRT&X               . AND B TO SECTION PROPER\nRETN&X   L     &GLINK,LINK&X       RESTORE LINK REGISTER\n         B     8(,&GLINK)           AND RETURN\nLINK&X   DC    A(&GSKIP-8)         'EXIT' ADDRESS\nSTRT&X   DC    0H'0'               START OF SECTION\n         AIF   (D'R0).SKIP\n         EQUATE\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SECTION": {"ttr": 5126, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x98\"\\x9f\\x00\\x993\\x7f\\x14I\\x00Z\\x00Y\\x00\\x00\\xc2\\xc3\\xd6\\xc4\\xc8\\xe2\\xf0@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1998-08-17T00:00:00", "modifydate": "1999-12-03T14:49:00", "lines": 90, "newlines": 89, "modlines": 0, "user": "BCODHS0"}, "text": "         MACRO\n&NAME    SECTION &DUMMY,           ALLOWS COMMENT ONLY                 C\n               &STDEXIT=,          SET TO 'NO' IF REQUIRED             C\n               &MAXREG=11,         REGS 2 - &MAXREG WILL BE RESTORED...C\n               &RESTORE=Y          . IF &RESTORE IS SET TO 'Y'\n*                                                                     *\n         GBLC  &GPROG              PROGRAM NAME\n         GBLC  &GSECT,&WSECT       LOCATION COUNTER NAMES\n         GBLC  &GBASE,&GLINK       EXTRACT PRESET BASE AND LINK REGS\n         GBLC  &GRETN,&GSKIP       RETURN AND SKIP TAGS\n         GBLC  &NSECT              SET NAME FOR POSSIBLE PERFORM STMT\n         GBLB  &VERROR             SET BY VERSION MACRO\n         LCLC  &X                  WORK CELL\n&X       SETC  '&SYSNDX'           FOR UNIQUE TAGS\n         VERSION 2\n         AIF   (NOT &VERROR).OK02 TEST FOR VERSION ERROR\n         MEXIT                     GIVE UP ALL HOPE IF YES\n.OK02    AIF   ('&NAME' NE 'FILE').TSTWS GO IF NOT FILE SECTION\n         DC    0D'0',C'*** &GPROG   **** FILE SECTION *'\n         MEXIT\n.TSTWS   AIF   ('&NAME' NE 'WORKING_STORAGE').TSTLS TEST FOR LINKAGE\n         DC    0D'0',C'*** &GPROG   **** WORKING-STORAGE SECTION '\n         MEXIT\n.TSTLS   AIF   ('&NAME' NE 'LINKAGE').PROC MUST BE SECTION IN PROC DIV\n         MEXIT\n.PROC    AIF   ('&GRETN' EQ '').SKIP010 GO IF NO SECTION TO TERMINATE\n         ENDSECT ,                 TERMINATE PREVIOUS SECTION\n.SKIP010 AIF   (K'&RESTORE EQ 1).SKIP020\n         MNOTE 8,'INVALID RESTORE VALUE ''&RESTORE'': MACRO TERMINATED'\n         MEXIT\n.SKIP020 ANOP\n&NSECT   SETC  '&NAME'             TAG FOR ADCON WITHIN PERFORM\n         AIF   ('&NSECT' NE '').SKIP20\n&NSECT   SETC  'SECT&X'            INTERNALLY GENERATED NAME\n.SKIP20  $ASECT &NSECT             ADD NAME TO LIST\n&GRETN   SETC  'RETN&X'            UNIQUE TAG FOR EXIT\n&GSKIP   SETC  'SKIP&X'            UNIQUE TAG FOR END OF SECTION\n         AIF   ('&STDEXIT' EQ 'NO').NOEXIT\n.**=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\n.* FALL THROUGH TO THIS ENTRANCE                                      *\n.**=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\n         BASR  &GBASE,0            INITIALIZE BASE REGISTER\n         USING *,&GBASE            TELL ASSEMBLER\n         MVI   $WITCH_&X,C'N'      DO NOT RESTORE REGS AT EXIT\n         L     &GLINK,$NEXT_&X     SET ADDR EXIT TO BEG OF NEXT SECTION\n         B     &NSECT              ENTER MAINLINE OF SECTION\n.**=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\n.* ENTRANCE FOR 'GOTO' MACRO                                          *\n.**=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\n         BASR  &GBASE,0            INITIALIZE BASE REGISTER\n         USING *,&GBASE            TELL ASSEMBLER\n         L     &GLINK,$AVE_&X      SET EXIT ADDR TO PREVIOUS EXIT\n         B     &NSECT              ENTER MAINLINE OF SECTION\n.**=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\n.* ENTRANCE FOR 'PERFORM' MACRO                                       *\n.**=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\n         BASR  &GBASE,0            INITIALIZE BASE REGISTER\n         USING *,&GBASE            TELL ASSEMBLER\n         MVI   $WITCH_&X,C'&RESTORE' DO/DO NOT RESTORE REGS AT EXIT Y/N\n&NSECT   DC    0H'0'               BEGINNING OF SECTION PROPER\n         USING &NSECT,&GBASE       SHOW BASE REG\n         BASR  &GBASE,0            INITIALIZE BASE REGISTER\n         BCTR  &GBASE,0            BACK IT UP ONE\n         BCTR  &GBASE,0            BACK IT UP ANOTHER\n         ST    &GLINK,$AVE_&X      SAVE LINK REGISTER\n         STM   2,11,REG$_&X        SAVE REGS 2 - 11\n         B     &NSECT._BEGIN        . AND B TO SECTION PROPER\nRETN&X   L     &GLINK,$AVE_&X      RESTORE LINK REGISTER\n         CLI   $WITCH_&X,C'Y'      DO IF WE NEED TO\n         BNE   8(,&GLINK)          RETURN IF WE DON'T\n         LM    2,&MAXREG,REG$_&X   RESTORE USER REGS\n         B     8(,&GLINK)           AND RETURN\n         $WA                       ESTABLISH WORKING_STORAGE\n$AVE_&X  DC    A(0)                SAVE AREA FOR LINK REGISTER\nREG$_&X  DC    10A(0)              SAVE AREA FOR REGS 2 - 11\n$NEXT_&X DC    A(&GSKIP-8)         DEFAULT EXIT ADDR (SET TO -8 SINCE\n*                                  . RETURN BRANCH IS TO +8)\n$WITCH_&X DC   C' '                CONTROLS RESTORING REGS\n         $IA                       ESTABLISH PROCEDURE DIVISION\n&NSECT._BEGIN DC 0H'0'             START OF SECTION\n         MEXIT\n.NOEXIT  BASR  &GBASE,0            INITIALIZE BASE REGISTER\n         USING *,&GBASE            TELL ASSEMBLER\n         NOP   *+4                 'FILLER' FOR COMPATIBILITY\n&NSECT   BASR  &GBASE,0            INITIALIZE BASE REGISTER\n         USING *,&GBASE            TELL ASSEMBLER\n         B     *+10                 . AND B TO SECTION PROPER\nRETN&X   LA    1,&SYSNDX           CREATE UNIQUE ABEND CODE\n         SVC   13                  ABEND THE SUCKER\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SETCSECT": {"ttr": 5129, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00\\x00o\\x01\\x00\\x00o\\x18S\\x00\\x06\\x00\\x06\\x00\\x00\\xc2\\xc3\\xd6\\xc4\\xc8\\xe2\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-01-06T00:00:00", "modifydate": "2000-01-06T18:53:00", "lines": 6, "newlines": 6, "modlines": 0, "user": "BCODHS0"}, "text": "         MACRO\n         SETCSECT &CSECT\n         AIF   ('&SYSECT' NE '').MEND\n         AIF   ('&CSECT' EQ '').MEND\n&CSECT   CSECT\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SETDEF": {"ttr": 5131, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00\\x00o\\x01\\x00\\x00o\\x18S\\x00\\t\\x00\\t\\x00\\x00\\xc2\\xc3\\xd6\\xc4\\xc8\\xe2\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-01-06T00:00:00", "modifydate": "2000-01-06T18:53:00", "lines": 9, "newlines": 9, "modlines": 0, "user": "BCODHS0"}, "text": "         MACRO\n         SETDEF &USER,&DEFAULT\n         GBLC  &PARM\n         VERSION 2\n         AIF   ('&PARM' NE '').MEND DONE IF ALREADY DEFINED\n&PARM    SETC  '&USER'             ASSUME USER-SPECIFIED\n         AIF   ('&PARM' NE '').MEND WAS ASSUMPTION CORRECT?\n&PARM    SETC  '&DEFAULT'          NO - SET TO DEFAULT\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SETRC": {"ttr": 5133, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00\\x00o\\x01\\x00\\x00o\\x18S\\x00\\r\\x00\\r\\x00\\x00\\xc2\\xc3\\xd6\\xc4\\xc8\\xe2\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-01-06T00:00:00", "modifydate": "2000-01-06T18:53:00", "lines": 13, "newlines": 13, "modlines": 0, "user": "BCODHS0"}, "text": "         MACRO\n&NAME    SETRC &RC,&RESET\n         COPY  $MGBLDEF\n&NAME    L     R14,4(,R13)         CHAIN BACK TO PREV SAVE AREA\n         VAL   R15,&RC             GET RETURN CODE INTO REG\n         AIF   ('&RESET' EQ 'RESET').RESET\n         IF    (CL,R15,16(,R14),H),THENDO DO IF NEW HIGH\n           ST    R15,16(,R14)      SAVE RETURN CODE\n         ENDO  ,\n         AGO   .MEND               QUIT\n.RESET   ANOP\n         ST    R15,16(,R14)        SET NEW RETURN CODE\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SETREGS": {"ttr": 5135, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x996O\\x00\\x996O\\x10A\\x00\\r\\x00\\r\\x00\\x00\\xc2\\xc3\\xd6\\xc4\\xc8\\xe2\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-30T00:00:00", "modifydate": "1999-12-30T10:41:00", "lines": 13, "newlines": 13, "modlines": 0, "user": "BCODHS0"}, "text": "         MACRO\n&NAME    SETREGS &DUMMY            EQUATE 16 GP REGISTERS\n         LCLA  &I                  DEFINE LOCAL\n         AIF   (D'R0).MEND         SKIP EQUATES IF R0 ALREADY DEFINED\n         PUSH  PRINT\n         PRINT NOGEN\n&I       SETA  0                   INITIALIZE\n.LOOP    ANOP                      LOOP BACK TO HERE\nR&I      EQU   &I                  DEFINE A REGISTER\n&I       SETA  &I+1                BUMP INDEX\n         AIF   (&I LT 16).LOOP     BACK IF MORE TO DO\n         POP   PRINT\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SETUP": {"ttr": 5137, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00\\x00o\\x01\\x00\\x00o\\x18S\\x00\\x06\\x00\\x06\\x00\\x00\\xc2\\xc3\\xd6\\xc4\\xc8\\xe2\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-01-06T00:00:00", "modifydate": "2000-01-06T18:53:00", "lines": 6, "newlines": 6, "modlines": 0, "user": "BCODHS0"}, "text": "         MACRO\n         SETUP  &SYMBOL\n         GBLC  &GSECT\n&SYMBOL  LOCTR\n&GSECT   SETC  '&SYMBOL'\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "STOP": {"ttr": 5139, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00\\x00o\\x01\\x00\\x00o\\x18S\\x00\\x1c\\x00\\x1c\\x00\\x00\\xc2\\xc3\\xd6\\xc4\\xc8\\xe2\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-01-06T00:00:00", "modifydate": "2000-01-06T18:53:00", "lines": 28, "newlines": 28, "modlines": 0, "user": "BCODHS0"}, "text": "         MACRO\n&NAME    STOP  &DUMMY,&RC=         TERMINATE MAINLINE OF PROG\n.* POSITIONAL PARAMETER '&DUMMY' ALLOWS A COMMENT FIELD WITHOUT\n.* COMMA IF NO PARMS ARE SPECIFIED IN MACRO CALL STATEMENT.\n         COPY  $MGBLDEF\n         LCLC  &X,&Y               FOR NAME\n         AIF   (&$MDGLVL EQ 0).SKIP03 GO IF NO DO-GROUPS TO END\n         MNOTE 4,'&$MDGLVL DO-GROUP(S) ENDED'\n         ENDO  DOGROUP=*ALL*\n.SKIP03  ANOP\n&X       SETC  '$STOP'             BLANK IF NECESSARY\n         AIF   ('&NAME' EQ '').SKIP05 NAME PRESENT...\n&NAME    DC    0H'0' .             GENERATE TAG\n.SKIP05  ANOP\n         AIF   ('&RC' EQ '').SKIP10\n&X       SETRC &RC .               SET USERS RETURN CODE\n&X       SETC  ''\n.SKIP10  ANOP\n&X       L     R13,4(,R13)         CHAIN BACK\n         LM    R14,R15,12(R13)     RESTORE EVERYTHING BUT\n         LM    R2,R12,28(R13)       ZERO AND ONE\n         BR    R14\n         DROP  &$USING(1)           DROP CURRENT BASE REG(S)\n&$USING(1) SETC ''                  DON'T DROP THEM AGAIN!\n         LTORG\n&$MSECT(1) SETC 'DATAAREA'\nDATAAREA CSECT                     DEFINE DATA AREA CSECT\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SYSUT1": {"ttr": 5141, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00\\x00o\\x01\\x00\\x00o\\x18S\\x00\\x8c\\x00\\x8c\\x00\\x00\\xc2\\xc3\\xd6\\xc4\\xc8\\xe2\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-01-06T00:00:00", "modifydate": "2000-01-06T18:53:00", "lines": 140, "newlines": 140, "modlines": 0, "user": "BCODHS0"}, "text": "         MACRO\n&NAME    SYSUT1 &IOAREA=,&LRECL=\n         GBLC  &PREF,&DCBDSW,&DCBDGEN,&WAREA\n&PREF    SETC  'UT1'\n         AIF   ('&NAME' EQ '').SKIP01\n&PREF    SETC  '&NAME'\n.SKIP01  ANOP\n&WAREA   SETC  '&IOAREA'\n         AIF   ('&IOAREA' NE '').SKIP02\n&WAREA   SETC  '&PREF.WORK'\n.SKIP02  ANOP\n         TITLE 'SYSUT1 INPUT ROUTINE'\n         SPACE 2\n***********************************************************************\n* 'UT1INPUT' READS EACH INPUT RECORD, AND AT EOF SETS UT1EOFSW        *\n***********************************************************************\n         SPACE\n&PREF.INPUT PROC ,\n         IF    (CLI,&PREF.EOFSW,C'Y',NE),THENDO DO IF NOT EOF\n           GET   SYS&PREF,&WAREA   READ NEXT INPUT RECORD\n           AP    &PREF.COUNT,=P'1' BUMP INPUT COUNTER\n         ELSE  ,                   ELSE IT IS EOF...\n           FIRST 5                 FIVE WARNINGS IN PLENTY\n             WTO  'READ PAST END-OF-FILE ON SYS&PREF' FLAG ERROR\n           ENDO  ,\n         ENDELSE ,\n         RETN  ,                   AND RETURN\n&PREF.EOF MVI  &PREF.EOFSW,C'Y'    SET EOFSW\n         ENDP  ,                   AND RETURN\n         TITLE 'SYSUT1 FILE VERIFICATION ROUTINE AND DCB'\n         SPACE 2\n***********************************************************************\n* SYSUT1 VERIFICATION ROUTINE                                         *\n***********************************************************************\n         SPACE\n&PREF.PREP PROC ,\n         SLR   R15,R15             SET ZERO RETURN CODE\n         RDJFCB MF=(E,&PREF.RJFCB)  CHECK IT OUT\n         IF    (LTR,R15,R15,NZ),THENDO DO IF FAILED\n           LA    R15,4            4 RETURN CODE\n           RETN  ,                RETURN TO CALLER\n         ENDO  ,\n         IF    (CLI,&PREF.JNVOL,X'00',E),THENDO DO IF NO VOLS ON JCL\n           LOCATE &PREF.LST        SEARCH THE CATALOG\n           IF    (LTR,R15,R15,NZ),OR,          IF LOCATE FAILED        C\n               (OC,&PREF.LNVOL,&PREF.LNVOL,Z),THENDO\n             OPEN  ,TYPE=J,MF=(E,&PREF.RJFCB) OPEN THE SUCKER\n             IF   (TM,SYS&PREF.+DCBOFLGS-IHADCB,DCBOFOPN,NO),THENDO\n               LA    R15,20        20 RETURN CODE\n             ELSE  ,\n               SLR   R15,R15        0 RETURN CODE (SYSIN DATA SET)\n             ENDELSE ,\n             RETN  ,              RETURN TO CALLER\n           ENDO  ,\n           MVC   &PREF.VOL,&PREF.LVOL1 MOVE IN FIRST VOLUME FROM LOCATE\n         ELSEDO  ,                 VOL IS ON JCL\n           MVC   &PREF.VOL,&PREF.JVOLS MOVE IN FIRST VOLUME FROM JFCB\n         ENDELSE ,\n         OBTAIN &PREF.LST2         GET DSCB\n         IF    (LTR,R15,R15,NZ),THENDO DO IF OBTAIN FAILED\n           LA    R15,12            12 RETURN CODE\n           RETN  ,                 RETURN TO CALLER\n         ENDO  ,\n         MVC   &PREF.DSNM(44),&PREF.JDSN COPY DATA SET NAME\n         IF    (CLI,&PREF.JMEM,C' ',NE),THENDO DO IF MEMBER PRESENT\n           LA    R2,&PREF.DSNM+43  LAST CHAR OF DSNAME\n           DO    UNTIL=(CLI,0(R2),C' ',NE) FIND LAST NON-BLANK\n             BCTR  R2,0            DECREMENT POINTER\n           ENDO  ,\n           MVI   1(R2),C'('        FOR '(MEMBER)'\n           LA    R3,&PREF.JMEM     1ST CHAR OF MEMBER\n           DO    8                 MOVE NO MORE THAN 8\n             IF    (CLI,0(R3),C' ',NE),THENDO DO IF NON-BLANK\n               MVC   2(1,R2),0(R3) MOVE 1 CHARACTER\n               I    R2             BUMP OUTPUT\n               I    R3             BUMP INPUT\n             ENDO  ,\n           ENDO  ,\n           MVI   2(R2),C')'        CLOSE PARENS\n         ENDO  ,\n         OPEN  ,TYPE=J,MF=(E,&PREF.RJFCB) OPEN THE SUCKER\n         IF   (TM,SYS&PREF.+DCBOFLGS-IHADCB,DCBOFOPN,NO),THENDO FAILED?\n           LA    R15,20            20 RETURN CODE\n         ENDO  ,\n         ENDP  ,\nDATAAREA CSECT\n&PREF.VOL DC   CL6' '              WILL HOLD VOL FROM JFCB OR CATALOG\n&PREF.DSNM DC  CL54'JES2/SYSIN'    DATA.SET.NAME(MEMBER)\n         PUSH  PRINT\n         PRINT NOGEN\nSYS&PREF DCB   DDNAME=SYS&PREF,                                        C\n               DSORG=PS,                                               C\n               MACRF=GM,                                               C\n               EXLST=&PREF.EXIT,                                       C\n               EODAD=&PREF.EOF\n         POP   PRINT\n&PREF.RJFCB RDJFCB SYS&PREF.,MF=L  LIST PORTION\n&PREF.EXIT DC  0F'0',X'87',AL3(&PREF.JFCB) ONLY INTERESTED IN JFCB\n&PREF.JFCB DC  0D'0'               JOB FILE CONTROL BLOCK\n&PREF.JDSN DC  CL44' '             DATA SET NAME\n&PREF.JMEM DC  CL8' ',65X'00'      MEMBER NAME\n&PREF.JNVOL DC X'00'               # OF VOLUMES\n&PREF.JVOLS DC 5XL6'00',28X'00'    UP TO 5 VOLSERS\n&PREF.LST2 CAMLST SEARCH,&PREF.JDSN,&PREF.VOL,&PREF.DSCB FOR 'OBTAIN'\n&PREF.DSCB DC  0D'0'               DATA SET CONTROL BLOCK\n         DC    38X'00'             - LOADED BY 'OBTAIN' MACRO\n&PREF.DSORG DC X'0000'\n&PREF.RECFM DC X'00'\n&PREF.OPTCD DC X'00'\n&PREF.BLKL DC  H'0'\n&PREF.LRECL DC H'0'\n         DC    50X'00'\n&PREF.LST CAMLST NAME,&PREF.JDSN,,&PREF.STBLK FOR 'LOCATE'\n&PREF.STBLK DC 0D'0'               ORIGIN OF LOCATE INFO\n&PREF.LNVOL DC H'0'                NUMBER OF VOLUMES\n&PREF.DEVT1 DC XL4'00'             DEVTYPE FOR VOL1\n&PREF.LVOL1 DC CL6' '              VOLSER FOR VOL1\n         DC    19XL12'00'\n         DC    10X'00'\n&PREF.TTR DC   XL3'00'             TTR FOR DSCB\n         DC    4X'00'\n         DC    CL6' '\n         AIF   ('&DCBDSW' EQ 'NO').SKIP50\n&DCBDSW  SETC  'NO'\n         PUSH  PRINT\n         AIF   ('&DCBDGEN' EQ 'GEN').GENOK\n&DCBDGEN SETC  'NOGEN'\n.GENOK   PRINT &DCBDGEN\n         DCBD  DSORG=PS\nDATAAREA CSECT\n         POP   PRINT\n.SKIP50  ANOP\n         SPACE\n&PREF.EOFSW DC C'N'                SET TO 'Y' AT &PREF.EOF\n         SPACE\n         AIF   ('&IOAREA' NE '').SKIP90\n&PREF.WORK DS  CL&LRECL\n.SKIP90  ANOP\n&PREF.COUNT DC PL8'0'\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SYSUT2": {"ttr": 5144, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00\\x00o\\x01\\x00\\x00o\\x18S\\x00o\\x00o\\x00\\x00\\xc2\\xc3\\xd6\\xc4\\xc8\\xe2\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-01-06T00:00:00", "modifydate": "2000-01-06T18:53:00", "lines": 111, "newlines": 111, "modlines": 0, "user": "BCODHS0"}, "text": "         MACRO\n&NAME    SYSUT2 &LRECL=80,&IOAREA=\n         GBLC  &PREF,&DCBDSW,&DCBDGEN,&WAREA\n&PREF    SETC  'UT2'\n         AIF   ('&NAME' EQ '').SKIP01\n&PREF    SETC  '&NAME'\n.SKIP01  ANOP\n&WAREA   SETC  '&IOAREA'\n         AIF   ('&IOAREA' NE '').SKIP02\n&WAREA   SETC  '&PREF.WORK'\n.SKIP02  ANOP\n         TITLE 'SYSUT2 OUTPUT ROUTINE'\n         SPACE 2\n***********************************************************************\n* 'UT2OUTPT' WRITES EACH OUTPUT RECORD                                *\n***********************************************************************\n         SPACE\n&PREF.OUTPT PROC ,\n           PUT   SYS&PREF,&WAREA   WRITE RECORD\n           AP    &PREF.COUNT,=P'1' BUMP OUTPUT COUNTER\n         ENDP  ,                   AND RETURN\n         TITLE 'SYSUT2 FILE VERIFICATION ROUTINE AND DCB'\n         SPACE 2\n***********************************************************************\n* SYSUT2 VERIFICATION ROUTINE                                         *\n***********************************************************************\n         SPACE\n&PREF.PREP PROC ,\n         SLR   R15,R15             SET ZERO RETURN CODE\n         RDJFCB MF=(E,&PREF.RJFCB)  CHECK IT OUT\n         IF    (LTR,R15,R15,NZ),THENDO DO IF FAILED\n           LA    R15,4            4 RETURN CODE\n           RETN  ,                RETURN TO CALLER\n         ENDO  ,\n         MVC   &PREF.DSNM(44),&PREF.JDSN COPY DATA SET NAME\n         IF    (CLI,&PREF.JMEM,C' ',NE),THENDO DO IF MEMBER PRESENT\n           LA    R2,&PREF.DSNM+43  LAST CHAR OF DSNAME\n           DO    UNTIL=(CLI,0(R2),C' ',NE) FIND LAST NON-BLANK\n             BCTR  R2,0            DECREMENT POINTER\n           ENDO  ,\n           MVI   1(R2),C'('        FOR '(MEMBER)'\n           LA    R3,&PREF.JMEM     1ST CHAR OF MEMBER\n           DO    8                 MOVE NO MORE THAN 8\n             IF    (CLI,0(R3),C' ',NE),THENDO DO IF NON-BLANK\n               MVC   2(1,R2),0(R3) MOVE 1 CHARACTER\n               I    R2             BUMP OUTPUT\n               I    R3             BUMP INPUT\n             ENDO  ,\n           ENDO  ,\n           MVI   2(R2),C')'        CLOSE PARENS\n         ENDO  ,\n         OPEN  (,OUTPUT),TYPE=J,MF=(E,&PREF.RJFCB) OPEN THE SUCKER\n         IF   (TM,SYS&PREF.+DCBOFLGS-IHADCB,DCBOFOPN,NO),THENDO FAILED?\n           LA    R15,20            20 RETURN CODE\n         ENDO  ,\n         ENDP  ,\nDATAAREA CSECT\n&PREF.VOL DC   CL6' '              WILL HOLD VOL FROM JFCB OR CATALOG\n&PREF.DSNM DC  CL54' '             DATA.SET.NAME(MEMBER)\n         PUSH  PRINT\n         PRINT NOGEN\nSYS&PREF DCB   DDNAME=SYS&PREF,                                        C\n               LRECL=&LRECL,                                           C\n               DSORG=PS,                                               C\n               MACRF=PM,                                               C\n               EXLST=&PREF.EXIT\n         POP   PRINT\n&PREF.RJFCB RDJFCB SYS&PREF.,MF=L  LIST PORTION\n&PREF.EXIT DC  0F'0',X'87',AL3(&PREF.JFCB) ONLY INTERESTED IN JFCB\n&PREF.JFCB DC  0D'0'               JOB FILE CONTROL BLOCK\n&PREF.JDSN DC  CL44' '             DATA SET NAME\n&PREF.JMEM DC  CL8' ',65X'00'      MEMBER NAME\n&PREF.JNVOL DC X'00'               # OF VOLUMES\n&PREF.JVOLS DC 5XL6'00',28X'00'    UP TO 5 VOLSERS\n&PREF.LST2 CAMLST SEARCH,&PREF.JDSN,&PREF.VOL,&PREF.DSCB FOR 'OBTAIN'\n&PREF.DSCB DC  0D'0'               DATA SET CONTROL BLOCK\n         DC    38X'00'             - LOADED BY 'OBTAIN' MACRO\n&PREF.DSORG DC X'0000'\n&PREF.RECFM DC X'00'\n&PREF.OPTCD DC X'00'\n&PREF.BLKL DC  H'0'\n&PREF.LRECL DC H'0'\n         DC    50X'00'\n&PREF.LST CAMLST NAME,&PREF.JDSN,,&PREF.STBLK FOR 'LOCATE'\n&PREF.STBLK DC 0D'0'               ORIGIN OF LOCATE INFO\n&PREF.LNVOL DC H'0'                NUMBER OF VOLUMES\n&PREF.DEVT1 DC XL4'00'             DEVTYPE FOR VOL1\n&PREF.LVOL1 DC CL6' '              VOLSER FOR VOL1\n         DC    19XL12'00'\n         DC    10X'00'\n&PREF.TTR DC   XL3'00'             TTR FOR DSCB\n         DC    4X'00'\n         DC    CL6' '\n         AIF   ('&DCBDSW' EQ 'NO').SKIP50\n&DCBDSW  SETC  'NO'\n         PUSH  PRINT\n         AIF   ('&DCBDGEN' EQ 'GEN').GENOK\n&DCBDGEN SETC  'NOGEN'\n.GENOK   PRINT &DCBDGEN\n         DCBD  DSORG=PS\nDATAAREA CSECT\n         POP   PRINT\n.SKIP50  ANOP\n         SPACE\n&PREF.EOFSW DC C'N'                SET TO 'Y' AT &PREF.EOF\n         SPACE\n         AIF   ('&IOAREA' NE '').SKIP90\n&PREF.WORK DC  CL&LRECL' '\n.SKIP90  ANOP\n&PREF.COUNT DC PL8'0'\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TAG": {"ttr": 5379, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00\\x00o\\x01\\x00\\x00o\\x18S\\x00\\x08\\x00\\x08\\x00\\x00\\xc2\\xc3\\xd6\\xc4\\xc8\\xe2\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-01-06T00:00:00", "modifydate": "2000-01-06T18:53:00", "lines": 8, "newlines": 8, "modlines": 0, "user": "BCODHS0"}, "text": "         MACRO\n&NAME    TAG   &TRACKS=YES TRACKS -> LOCAL CONTROL OF TRACING\n         GBLC  &$MTRACE            GLOBAL CONTROL OF TRACING\n&NAME    DC    0H'0'               DEFINE TAG\n         AIF   ('&TRACKS' NE 'YES').MEND      LOCAL AND GLOBAL MUST\n         AIF   ('&$MTRACE' NE 'YES').MEND     BOTH BE 'YES' TO TRACE\n         TRACER 'STATEMENT ''&NAME'' EXECUTED' GO TO IT...\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "THENDO": {"ttr": 5381, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02\\x01\\x7f\\x01\\x02\\x01\\x7f\\x10\\x17\\x00#\\x00#\\x00\\x00\\xc7\\xc5\\xd5\\xe3\\xd9\\xf0\\xf2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-01-17T00:00:00", "modifydate": "2002-01-17T10:17:00", "lines": 35, "newlines": 35, "modlines": 0, "user": "GENTR02"}, "text": "         MACRO\n&NAME    THENDO &COND '&COND' MUST BE CHAR(S) FOLLOWING 'B' OF EXTENDED\n.*             MNEMONICS, EG 'E' OF 'BE' OR 'NO' OF 'BNO', ETC\n.*                                                                    *\n.*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=**\n.* 'THENDO' GROUPS MUST BE ENDED WITH 'ENDO' STATEMENT, AND MAY BE    *\n.* NESTED AS DEEPLY AS NECESSARY (C'MON - WHO COULD EVER NEED MORE    *\n.* THAN 255 LEVELS OF NESTING???).                                    *\n.*                                                                    *\n.* NOTE: TESTS ARE NOT MADE ON OPERAND TO ALLOW INSTALLATION TO CREATE*\n.*       ADDITIONAL CONDITIONAL BRANCH INSTRUCTIONS VIA MACRO         *\n.*       DEFINITIONS. EXAMPLE: 'BGE' FOR 'BRANCH ON GREATER THAN OR   *\n.*       EQUAL TO' WHICH WOULD GENERATE THE SAME CODE AS 'BNL'.       *\n.*                                                                    *\n.*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=**\n.*                                                                    *\n         COPY  $MGBLDEF\n         LCLC  &X,&Y\n&Y       SETC  'N&COND'\n         AIF   ('&COND'(1,1) NE 'N').SKIP05\n&Y       SETC  '&COND'(2,1)\n.SKIP05  ANOP\n&$MDGLVL SETA  &$MDGLVL+1          UP DO-GROUP LEVEL\n&$MDGSEQ(&$MDGLVL) SETC '&SYSNDX'  SET DO-GROUP SEQUENCE\n&$MDGNAM(&$MDGLVL) SETC '&NAME'    SET DO-GROUP NAME\n.*       DC    0C'$MDGLVL &$MDGLVL $MDGNAM &$MDGNAM(&$MDGLVL)'\n&$MIFELS(&$MDGLVL) SETC 'F'\n         AIF   ('&NAME' NE '').SKIP07\n&$MDGNAM(&$MDGLVL) SETC '$MDG&$MDGSEQ(&$MDGLVL)'\n.*       DC    0C'$MDGLVL &$MDGLVL $MDGNAM &$MDGNAM(&$MDGLVL)'\n.SKIP07  J&Y   $MDF&$MDGSEQ(&$MDGLVL) SKIP DO-GROUP IF REL NOT TRUE\n         AIF   ('&NAME' EQ '').SKIP10\n&NAME    DC    0H'0'              NAME OF DO-GROUP\n.SKIP10  ANOP\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TRACER": {"ttr": 5383, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00\\x00\\x00\\x990\\x7f\\x00\\x994?\\x14\\x13\\x00\\x11\\x00K\\x00\\x11\\xc2\\xc3\\xd6\\xc4\\xc8\\xe2\\xf0@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "1999-11-03T00:00:00", "modifydate": "1999-12-09T14:13:00", "lines": 17, "newlines": 75, "modlines": 17, "user": "BCODHS0"}, "text": "         MACRO\n&N       TRACER &DUMMY             DISPLAY LIST OF VARIABLES\n         GBLA  &TESTLVL\n         AIF   ('&SYSLIST(1)'(1,1) GE '0').COND\n&N       TRACER2 &SYSLIST(1),&SYSLIST(2),&SYSLIST(3),&SYSLIST(4),      X\n               &SYSLIST(5),&SYSLIST(6),&SYSLIST(7),&SYSLIST(8),        X\n               &SYSLIST(9),&SYSLIST(10)\n         MEXIT\n.COND    ANOP\n         AIF   (&SYSLIST(1) LE &TESTLVL).GEN\n&N       DS    0H\n         MEXIT\n.GEN     ANOP\n&N       TRACER2 &SYSLIST(2),&SYSLIST(3),&SYSLIST(4),&SYSLIST(5),      X\n               &SYSLIST(6),&SYSLIST(7),&SYSLIST(8),&SYSLIST(9),        X\n               &SYSLIST(10),&SYSLIST(11)\n.MEND    MEND  ,\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TRACER2": {"ttr": 5385, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x994?\\x00\\x994\\x8f\\x10 \\x00K\\x00K\\x00\\x00\\xc2\\xc3\\xd6\\xc4\\xc8\\xe2\\xf0@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1999-12-09T00:00:00", "modifydate": "1999-12-14T10:20:00", "lines": 75, "newlines": 75, "modlines": 0, "user": "BCODHS0"}, "text": "         MACRO\n&N       TRACER2 &DUMMY            DISPLAY LIST OF VARIABLES\n         COPY  CPYPAR$E            COPY UNIQUE PAR$E SYMBOLS\n         GBLA  &$CTR               FOR UNIQUE LITERAL NAMES\n         GBLC  &SUBCALL            WHICH TYPE?\n         LCLC  &TEMP,&NAME\n         LCLA  &I,&J,&K,&L\n&I       SETA  1                   CYCLE THRU POSITIONAL PARAMETERS\n&J       SETA  1                   DISPLACEMENT ON PRINT LINE\n&NAME    SETC  '&N'                USED TO PREVENT DUPLICATE TAGS\n.LOOP100 AIF   ('&SYSLIST(&I)' EQ '').OUTP900 FINISH UP IF ALL DONE\n         AIF   ('&SYSLIST(&I)' NE '/').TEST105 NEW LINE CHARACTER?\n&I       SETA  &I+1                BUMP TO NEXT POSITIONAL PARAMETER\n         AGO   .OUTP900            GO FISH\n.TEST105 AIF   ('&SYSLIST(&I)'(1,2) EQ 'C''').LIT250 GO IF LITERAL\n         AIF   ('&SYSLIST(&I)'(1,1) EQ '(').REG300 GO IF GPR\n         AIF   (T'&SYSLIST(&I) NE 'P').PROC200 FALL THROUGH IF PACKED\n&K       SETA  2*L'&SYSLIST(&I)-1  FIRST GUESS AT OUTPUT LENGTH REQ'D\n&L       SETA  &J+&K               CHECK FOR PRINT LINE OVERFLOW\n         AIF   (&L GT 132).OUTP900 FINISHED IF NO ROOM\n&L       SETA  &K                  CALCULATE # OF OUTPUT BYTES REQ'D\n         AIF   (S'&SYSLIST(&I) EQ 0).TEST110 EXPLICIT DECIMAL POINT?\n&K       SETA  &K+1                YES - ALLOW FOR '.'\n&L       SETA  &L-S'&SYSLIST(&I)   REDUCE REMAINING DIGIT COUNT\n.TEST110 AIF   (&L LT 4).PROC120   GO IF NO MORE COMMAS REQ'D\n&K       SETA  &K+1                ALLOW FOR A COMMA\n&L       SETA  &L-3                REDUCE REMAINING DIGIT COUNT BY 3\n         AGO   .TEST110            . AND LOOP BACK\n.PROC120 ANOP                      ** ALMOST ** READY TO FORMAT NUMBER\n&K       SETA  &K+1                ALLOW FOR POSSIBLE MINUS SIGN\n&K       SETA  &K+&L               CALCULATE TOTAL BYTES REQ'D\n&L       SETA  &J+&K               CALCULATE NEW PRINT LINE SIZE\n         AIF   (&L GT 132).OUTP900 ALL FINISHED IF TOO BIG\n         DC    0C'OPND LENGTH ==> &K OPND ==> &SYSLIST(&I)'\n&NAME    EM    TRACELINE+&J.(&K),&SYSLIST(&I),DB=- FORMAT NUMBER\n         AGO   .INCR400            GO INCREMENT INDEXES\n.PROC200 PAR$E &SYSLIST(&I)        SPLIT INTO COMPONENT PARTS\n&K       SETA  &$PLEN1             STRAIGHTFORWARD BYTE COUNT\n&L       SETA  &J+&K               CHECK LENGTH\n         AIF   (&L GT 132).OUTP900 ALL FINISHED IF PRINT LINE TOO LONG\n&NAME    MVC   TRACELINE+&J.(&K),&$PTAG1&$PEB1 MOVE DATA TO PRINT LINE\n         AGO   .INCR400            GO INCREMENT INDEXES\n.LIT250  $WA                       SET UP DATA AREA\n&TEMP    SETC  '$LT&$CTR'          SET UP TAG FOR 'LITERAL'\n&TEMP    DC    &SYSLIST(&I)        DEFINE LITERAL\n         $IA                       ENTER INSTRUCTION ZONE\n&K       SETA  L'&TEMP             CALCULATE LENGTH OF LITERAL\n&NAME    MVC   TRACELINE+&J.(&K),&TEMP MOVE LITERAL TO PRINT LINE\n&$CTR    SETA  &$CTR+1             CREATE UNIQUE COUNTER FOR NEXT LIT\n         AGO   .INCR400            GO INCREMENT INDEXES\n.REG300  ANOP\n&K       SETA  K'&SYSLIST(&I,1)    CHARS IN REG NAME\n&L       SETA  &J+&K+9\n         AIF   (&L GT 132).OUTP900 GO IF NO ROOM AT THE INN\n&NAME    LR    R1,&SYSLIST(&I,1)   LOAD FIRST (AND ONLY) PARAMETER\n         &SUBCALL CVXWORD          GET (PRINTABLE) HEXADECIMAL\n         MVC   TRACELINE+&J.(&K),=C'&SYSLIST(&I,1)'\n&J       SETA  &J+&K+1             BUMP TO NEXT AVAIL LOC'N\n&K       SETA  0                   CAN'T COUNT IT TWICE...\n         STCM  R0,15,TRACELINE+&J  STORE 1ST 4 HEX CHARACTERS\n         STCM  R1,15,TRACELINE+&J+4 NOW LAST 4\n&J       SETA  &J+8                BUMP TO NEXT AVAIL LOC'N\n.INCR400 ANOP                      INCREMENT INDEXES\n&J       SETA  &J+&K+1             CALC NEW LOCATION ON PRINT LINE\n&I       SETA  &I+1                NEW SUBSCRIPT FOR POSITIONAL PARMS\n&NAME    SETC  ''                  PREVENT DUPLICATE TAGS\n         AGO   .LOOP100            BACK TO CHECK FOR MORE POSITIONALS\n.OUTP900 CALL  TRACERTN,(TRACELINE)  PRINT THE LINE JUST FORMATTED\n&J       SETA  1                   RESET PRINTLINE LOC'N (JUST IN CASE)\n         AIF   ('&SYSLIST(&I)' NE '').LOOP100 BACK IF MORE TO DO\n         AIF   (D'TRACELINE).MEND999\n         $WA    ,\nTRACELINE DC    CL133' '\n         $IA    ,\n.MEND999 MEND                      GUESS?\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TRC": {"ttr": 5388, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00\\x00o\\x01\\x00\\x00o\\x18S\\x00I\\x00I\\x00\\x00\\xc2\\xc3\\xd6\\xc4\\xc8\\xe2\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-01-06T00:00:00", "modifydate": "2000-01-06T18:53:00", "lines": 73, "newlines": 73, "modlines": 0, "user": "BCODHS0"}, "text": "         MACRO\n&NAME    TRC   &CTR,&TEXT\n         GBLC  &TRACE,&GSECT,&WSECT\n         GBLA  &VERSION\n         AIF   (&VERSION EQ 2).NEXT100\n         VERSION 1\n         AIF   ('&TRACE' EQ 'YES').NEXT010\n         AIF   ('&NAME' EQ '').LAST999\n&NAME    DC    0H'0'\n         AGO   .LAST999\n.NEXT010 ANOP\n&Z       SETC  '&SYSNDX'\nDATAAREA CSECT\n$TRS&Z   DC    4F'0'               SAVE REGS 14 - 1\n&Y       SETC  '&CTR'              MAKE ASSUMPTION\n         AIF   ('&CTR' NE '').SKIP020 GO IF ASSUMPTION WAS RIGHT\n&Y       SETC  '$MDC&SYSNDX'       MAKE IT PRETTY\n.SKIP020 ANOP\n         AIF   ('&TEXT' EQ '').SKIP030\n&X       SETC  '$MDT&SYSNDX'       MAKE IT PRETTY\n&X       DC    C&TEXT\n&L       SETA  L'&X\n.SKIP030 AIF   ('&CTR' NE '').SKIP040\n&Y       DC    PL2'1'              COUNTER\n.SKIP040 ANOP\n         MNOTE '&SYSNDX '&TEXT''\n&SYSECT  CSECT\n&NAME    STM   R14,R1,$TRS&Z       SAVE THE REGS\n         MVC   OUTLINE+1(4),=CL4'&SYSNDX' SEQUENCE STAMP\n         MVC   OUTLINE+6(4),=X'40202120' EDIT MASK\n         ED    OUTLINE+6(4),&Y     ITERATION COUNT\n         AIF   ('&TEXT' EQ '').SKIP050\n         MVC   OUTLINE+11(&L),&X   MOVE IN IDENTIFIER\n.SKIP050 ANOP\n         PCALL PRINTRTN            CALL ROUTINE TO PRINT\n         AP    &Y,=P'1'            BUMP\n         LM    R14,R1,$TRS&Z       RESTORE TO PRISTINE\n         MEXIT\n.NEXT100 VERSION 2\n         AIF   ('&TRACE' EQ 'YES').NEXT110\n         AIF   ('&NAME' EQ '').LAST999\n&NAME    DC    0H'0'\n         AGO   .LAST999\n.NEXT110 ANOP\n&Z       SETC  '&SYSNDX'\n&WSECT   LOCTR\n$TRS&Z   DC    4F'0'               SAVE REGS 14 - 1\n&GSECT   LOCTR\n&Y       SETC  '&CTR'              MAKE ASSUMPTION\n         AIF   ('&CTR' NE '').SKIP120 GO IF ASSUMPTION WAS RIGHT\n&Y       SETC  '$MDC&SYSNDX'       MAKE IT PRETTY\n.SKIP120 ANOP\n&WSECT   LOCTR\n         AIF   ('&TEXT' EQ '').SKIP130\n&X       SETC  '$MDT&SYSNDX'       MAKE IT PRETTY\n&X       DC    C&TEXT\n&L       SETA  L'&X\n.SKIP130 AIF   ('&CTR' NE '').SKIP140\n&Y       DC    PL2'1'              COUNTER\n.SKIP140 ANOP\n         MNOTE '&SYSNDX '&TEXT''\n&GSECT   LOCTR\n&NAME    STM   R14,R1,$TRS&Z       SAVE THE REGS\n         MVC   OUTLINE+1(4),=CL4'&SYSNDX' SEQUENCE STAMP\n         MVC   OUTLINE+6(4),=X'40202120' EDIT MASK\n         ED    OUTLINE+6(4),&Y     ITERATION COUNT\n         AIF   ('&TEXT' EQ '').SKIP150\n         MVC   OUTLINE+11(&L),&X   MOVE IN IDENTIFIER\n.SKIP150 ANOP\n         PERFORM PRINTRTN          CALL ROUTINE TO PRINT\n         AP    &Y,=P'1'            BUMP\n         LM    R14,R1,$TRS&Z       RESTORE TO PRISTINE\n.LAST999 MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TRSP": {"ttr": 5391, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x993\\x7f\\x00\\x993\\x7f\\x14P\\x00-\\x00-\\x00\\x00\\xc2\\xc3\\xd6\\xc4\\xc8\\xe2\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1999-12-03T00:00:00", "modifydate": "1999-12-03T14:50:00", "lines": 45, "newlines": 45, "modlines": 0, "user": "BCODHS0"}, "text": "         MACRO\n&NAME    TRSP  &FIELD                 FIND NUMBER OF TRAILING SPACES\n.**=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\n.* 'TRSP' WILL RETURN (IN REG 15) THE NUMBER OF TRAILING SPACES IN THE*\n.* OPERAND FIELD. THE LENGTH OF THE FIELD MAY BE FROM 1 TO 256 BYTES. *\n.* TO PROCESS THE FIELD USING THE LENGTH DEFINED FOR THE FIELD CODE:  *\n.*                                                                    *\n.*      TRSP  MYFIELD                                                 *\n.*                                                                    *\n.* WHERE 'MYFIELD' IS THE FIELD TO BE TESTED. IF YOU NEED TO SPECIFY A*\n.* LENGTH OTHER THAN THE DEFAULT, THEN CODE THE LENGTH WITHIN         *\n.* PARENTHESES IMMEDIATELY FOLLOWING THE OPERAND:                     *\n.*                                                                    *\n.*      TRSP  MYFIELD(30)                                             *\n.*                                                                    *\n.* IF YOU NEED TO CODE THE OPERAND USING BASE+DISPLACEMENT, THEN CODE:*\n.*                                                                    *\n.*      TRSP  12(30,R7)                                               *\n.*                                                                    *\n.* WHERE 12 IS THE DISPLACEMENT (ANY VALUE FROM 0 TO 4095) AND R7 IS  *\n.* ANY GPR OTHER THAN R0. IN THIS FORM, THERE IS NO DEFAULT LENGTH, SO*\n.* IT MUST BE EXPLICITLY CODED AS THE FIRST VALUE WITHIN THE          *\n.* PARENTHESES.                                                       *\n.**=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\n         GBLA  &$PLEN1                WILL BE SET TO LENGTH CODE\n         GBLC  &$PEB1,&$PELB1,&$PTAG1 OPERAND FRAGMENTS\n         LCLA  &Y                     LOCAL VARIABLE\n         LCLC  &X                     LOCAL VARIABLE\n&X       SETC  '&SYSNDX'              SET IT TO MACRO SEQUENCE NUMBER\n         PAR$E &FIELD                 FERRET OUT LENGTH PARM\n&Y       SETA  &$PLEN1                SET IT TO LENGTH OF USER'S FIELD\n&NAME    MVC   $WK&X,REVERSE+256-&Y   COPY MASK TO LOCAL VARIABLE\n         TR    $WK&X,&$PTAG1&$PEB1    COPY & REVERSE USER'S DATA\n         LA    R1,$WK&X+&Y            DEFAULT POINTER\n         TRT   $WK&X,NONBLANK         FIND FIRST (LAST) NON-BLANK\n         SL    R1,=A($WK&X)           SET R1 TO # OF TRAILING SPACES\n         LR    R15,R1                 COPY LENGTH TO STD RETURN REG\n         $WA                          ESTABLISH WORKING-STORAGE\n$WK&X    DC    CL&Y' '                LOCAL VARIABLE\n         AIF   (D'REVERSE).SKIP100    SKIP DEFS IF ALREADY DEFINED\n         DC    0D'0'                  ALIGNMENT FOR EFFICIENCY\nREVERSE  DC    256AL1(REVERSE+255-*)  REVERSING TABLE\nNONBLANK DC    64X'01',X'00',191X'01' NON-BLANK TABLE\n.SKIP100 $IA                          RE-ESTABLISH EXECUTABLE ENV\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TSWITCH": {"ttr": 5393, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00\\x00o\\x01\\x00\\x00o\\x18S\\x00\\x0f\\x00\\x0f\\x00\\x00\\xc2\\xc3\\xd6\\xc4\\xc8\\xe2\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-01-06T00:00:00", "modifydate": "2000-01-06T18:53:00", "lines": 15, "newlines": 15, "modlines": 0, "user": "BCODHS0"}, "text": "         MACRO\n&NAME    TSWITCH &SWITCH\n         LCLA  &I,&J\n         LCLC  &X\n&J       SETA  L'&SWITCH\n&X       SETC  '&J'\n&I       SETA  2\n.LOOP    AIF   ('&SYSLIST(&I)' EQ '').SKIP\n&J       SETA  L'&SYSLIST(&I)\n&X       SETC  '&X+&J'\n&I       SETA  &I+1\n         AGO   .LOOP\n.SKIP    ANOP\n&NAME    IF    (TM,&SWITCH,&X,O),THENDO\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "VAL": {"ttr": 5395, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x00\\x00o\\x01\\x00\\x00o\\x18S\\x00\\x13\\x00\\x13\\x00\\x00\\xc2\\xc3\\xd6\\xc4\\xc8\\xe2\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2000-01-06T00:00:00", "modifydate": "2000-01-06T18:53:00", "lines": 19, "newlines": 19, "modlines": 0, "user": "BCODHS0"}, "text": "         MACRO\n&NAME    VAL   &REG,&VAL           GET VALUE INTO REG\n         AIF   ('&VAL'(1,1) NE '(').NOTGPR\n         AIF   ('&VAL(1)' NE '&REG').DOLR\n         AIF   ('&NAME' EQ '').MEND NO USELESS STATEMENTS, PLEASE...\n&NAME    DC    0H'0'               TARGET AND SOURCE REGS IDENTICAL\n         MEXIT\n.DOLR    ANOP\n&NAME    LR    &REG,&VAL(1)        COPY VALUE TO CORRECT REGISTER\n         MEXIT\n.NOTGPR  AIF   (T'&VAL EQ 'H').DOHALF\n         AIF   ('&VAL'(1,1) GE '0').SELFDEF GO IF SELF-DEFINING\n&NAME    L     &REG,&VAL(1)        LOAD VALUE INTO REGISTER\n         MEXIT\n.DOHALF  LH    &REG,&VAL(1)        LOAD VALUE INTO REGISTER\n         MEXIT\n.SELFDEF ANOP\n&NAME    LA    &REG,&VAL           LOAD VALUE INTO REGISTER\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "VERSION": {"ttr": 5397, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x98!_\\x00\\x98!_\\x144\\x00\\x1c\\x00\\x1c\\x00\\x00\\xc2\\xc3\\xd6\\xc4\\xc8\\xe2\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1998-08-03T00:00:00", "modifydate": "1998-08-03T14:34:00", "lines": 28, "newlines": 28, "modlines": 0, "user": "BCODHS0"}, "text": "         MACRO\n         VERSION &VER\n.*                                                                    *\n.**=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\n.* SOME OF THE STRUCTURED MACROS ARE INCOMPATIBLE WITH OTHERS.        *\n.* VERSION 1 MACROS (PROC, PCALL, ENDP, GO AND STOP) CANNOT BE USED   *\n.* IN THE SAME PROGRAM AS VERSION 2 (DIVISION, SECTION, ENDSECT,      *\n.* PERFORM, AND GOBACK). THE 'VERSION' MACRO MAY BE USED IN OPEN CODE *\n.* TO SET THE STAGE. IT IS ALREADY USED WITHIN THE MACROS TO PREVENT  *\n.* CATASTROPHE.                                                       *\n.**=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\n.*                                                                    *\n         GBLA  &VERSION      FIRST CALL WILL SET THIS TO GLOBAL VERSION\n         GBLB  &VERROR       SET ON IF MISMATCH\n         GBLC  &SUBCALL      WHAT TO USE TO CALL A SUBROUTINE\n&VERROR  SETB  (0)                 ASSUME NO ERROR\n         AIF   (&VERSION EQ 0).SET 0 -> NOT YET SET: DO IT!\n         AIF   (&VERSION EQ &VER).SET   EQ -> OK: RESET\n         MNOTE 12,'SPECIFIED VERSION &VER INCOMPATIBLE WITH GLOBAL VERSC\n               ION &VERSION'\n&VERROR  SETB  (1)                 SHOW ERROR\n         MEXIT\n.SET     ANOP\n&VERSION SETA  &VER                SET TO VERSION OF THIS MACRO\n&SUBCALL SETC  'PCALL'             ASSUMPTION.\n         AIF   (&VERSION EQ 1).FINIS CORRECT?\n&SUBCALL SETC  'PERFORM'           FACT.\n.FINIS   MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT438/FILE438.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT438", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}