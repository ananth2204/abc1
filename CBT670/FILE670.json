{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012554000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 411502, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 9, "INMDSNAM": "CBT.V500.FILE670.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 411502, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 411502, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE670.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x07\\x15'", "DS1TRBAL": "b',\\xa0'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x04\\xbe\\x00\\t\\x04\\xbf\\x00\\x01\\x00\\x08'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04c\\x00#\\x01\\x195O\\x01\\x195O\\x08F\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf9@@@'", "ispf": {"version": "04.99", "flags": 0, "createdate": "2019-12-20T00:00:00", "modifydate": "2019-12-20T08:46:23", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-499"}, "text": "REGULAR CBT TAPE - VERSION 499    FILE:  670\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT499.FILE670\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 21 MEMBERS COUNTED; CUMULATIVE SIZE IS 3,358 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   12/20/19    08:46:23    UTC-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$NOTE01": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00H\\x01\\x195/\\x01\\x195/\\x101\\x00\\x1c\\x00\\x1c\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2019-12-18T00:00:00", "modifydate": "2019-12-18T10:31:48", "lines": 28, "newlines": 28, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:  File 670, CBT tape\nFrom:     Danny Companez <dcompanez@gmail.com>\nDate:     12/17/2019, 9:46 PM\nTo:       Sam Golob <sbgolob@cbttape.org>\n\nHi Sam,\n\nI have found an error in the FRAC function as submitted by Deru\non file 670.\n\nI have been in touch with him, and I have coded a fix to it. He\nsaid I should submit it back to CBT as long as I put my name in\nthe updates.\n\n\nThe fix to the FRAC function corrects the following error:\nfrac(1.65)= 0.625\n\nafter the fix it now returns\nfrac(1.65)= 0.649999976\n\nThe problem was with the use of an unnormalized result forcing a\nbad alignment when adding back to the original normalized value.\nI have added a normalized \"ADD of Zero\" to correct this.\n\nRegards\nDanny Companez\n(retired Z/os Sysprog)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$LOADLIB": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x02\\x004\\x01\\x04\\x06\\x8f\\x01\\x195?\\x00\\x03\\x00\\xf7\\x00\\xf7\\x00\\x00\\xc4\\xe7\\xc3\\xf0\\xf0@@@@@'", "ispf": {"version": "02.02", "flags": 0, "createdate": "2004-03-08T00:00:00", "modifydate": "2019-12-19T00:03:34", "lines": 247, "newlines": 247, "modlines": 0, "user": "DXC00"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}, "$README": {"ttr": 525, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00$\\x01\\x04\\x06\\x8f\\x01\\x19\\x01o\\x14\\x10\\x00\\x81\\x00\\x81\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2004-03-08T00:00:00", "modifydate": "2019-01-16T14:10:24", "lines": 129, "newlines": 129, "modlines": 0, "user": "SBGOLOB"}, "text": "Hi\n\nThis function package was originally DRXMATFN which is for VM/CMS.\nNo enhancement yet, except just to make it run on OS/390 or z/OS.\nHence, legacy HFP is still used which is low precision and\naccuracy, since the last touch was in 1993 on VM/ESA on ESA/370\nmachine.  Next plan is to convert it to BFP once I have enough\ntime.\n\nThis package can be used as a supplement to your rexx to provide\nseveral math functions such as sin(), cos(), tan() etc.   Hence,\nyour rexx will look like PL/1. Without such package, rexx doesn't\nsupport any math functions.   However, it just for availability.\nThere is no guarantee for the performance, since all rexx\nvariables are internally presented as text string.\n\nThis zip file consist of 2 XMI files:\nDRXMATH.SRC.XMI - Source library\nDRXMATH.LNK.XMI - Pre-generated load library\n\nFollow the explanation below to install this package into your OS/390\nsystem.\n\n\nRegards,\n_____________\nDeru Sudibyo\nemail:  \"Deru Sudibyo\" <deru.sudibyo@gmail.com>\n\n\nPre-generated Load Library\n==========================\n\nOriginal dsname is NIT.CBT.SRCLIB.  Please rename according to your\nnaming standard.  Since it was generated on OS/390 2.7, it should be\nokay to be directly used on any OS/390 level of V2R7 or above.\nIf you choose this way, you don't need to complete installation steps.\nAll you have to do are:\n\n(1) Upload this pre-generated loadlib to your OS/390 (binary mode).\n(2) Do TSO RECEIVE to restore the original loadlib.\n(3) Rename loadlib according to your naming standard.\n(4) Put its dataset name into your current LNKLST.\n(5) Re-activate your current LNKLST.\n(6) Do some necessary test using your own rexx program\n\n\n\n\nSource Library\n==============\n\nOriginal dsname is NIT.CBT.SRCLIB.  Please rename according to your\nnaming standard.   Using this source library, you can do complete\ninstallation your self.   Upload this as follow:\n\n(1) Upload this source loadlib to your OS/390 (binary mode).\n(2) Do TSO RECEIVE to restore the original loadlib.\n(3) Rename loadlib according to your naming standard.\n(4) Check the following detail...\n\nMember List\n===========\n  DRXFLOC  : Sourcecode of package & package directory\n  DRXMATH  : Sourcecode of package only module\n  @RXCSECT : Local macro\n  @RXENTRY : Local macro\n  @RXEXIT  : Local macro\n  @RXFDIR  : Local macro\n  DRXFUNC  : Local macro\n  ASSEMBLE : Assembling & linkeditor procedure\n  JDRXFLOC : Job to generate the package\n  JDRXTEST : Job for batch testing\n  TTEST0   : Rexx program for testing\n  TTEST1   : Rexx program for testing\n  TTEST2   : Rexx program for testing\n  TTEST3   : Rexx program for testing\n  TTEST5   : Rexx program for testing\n  TTEST6   : Rexx program for testing\n\nInstallation Instructions\n=========================\n\nA. Using Given Library - Everything in one library\n--------------------------------------------------\n\n  (1) Change LNKLIB name in JDRXFLOC job to your applicable loadlib\n      Make sure your loadlib is concatenated in your active LNKLST.\n\n  (2) Submit JDRXFLOC\n\n  (3) If error is encountered, review JDRXFLOC report, and contact\n      me (deru.sudibyo@gmail.com) if you think necessary.\n\n  (4) Submit JDRXTEST to verify the installation.  Please review\n      its report.\n\n\nB. Using Optimum Library Configuration\n--------------------------------------\n\n  (1) Allocate a local source library if one doesn't exist\n\n  (2) Allocate a local macro library if one doesn't exist\n\n  (3) Copy DRXFLOC and DRXMATH from this library into your local\n      sourcecode library\n\n  (4) Copy all these local macros from this library into your\n      local macro library\n\n  (5) Copy ASSEMBLE procedure into your local PROCLIB\n\n  (6) Copy JDRXFLOC and JDRXTEST into your local job library\n\n  (7) Copy all TTESTn into your local SYSEXEC library\n\n  (8) Customize JDRXFLOC and JDRXTEST to conform your library structure\n\n  (9) Run/submit JDRXFLOC to generate function package module\n\n  (10) If error is encountered, review JDRXFLOC report, and contact\n       me (deru.sudibyo@gmail.com) if you think necessary.\n\n  (11) Run/submit JDRXTEST to verify your installation.\n       IVP can also be done interactively on TSO using all TTESTx rexx\n       program, as long as concatenated into either SYSEXEC or SYSPROC.\n\n----------------------------End-of-document----------------------------\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@FILE670": {"ttr": 528, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04c\\x00\\x11\\x01\\x195O\\x01\\x195O\\x08F\\x00-\\x00-\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf9\\xf9@@@'", "ispf": {"version": "04.99", "flags": 0, "createdate": "2019-12-20T00:00:00", "modifydate": "2019-12-20T08:46:11", "lines": 45, "newlines": 45, "modlines": 0, "user": "CBT-499"}, "text": "//***FILE 670 is from Deru Sudibyo, and contains a REXX math        *   FILE 670\n//*           function package, similar to math functions for       *   FILE 670\n//*           PL/I.                                                 *   FILE 670\n//*                                                                 *   FILE 670\n//*           email:  \"Deru Sudibyo\" <deru.sudibyo@gmail.com>       *   FILE 670\n//*                                                                 *   FILE 670\n//*     Includes a fix to the FRAC function in the DRXMATH member.  *   FILE 670\n//*                                                                 *   FILE 670\n//*   A short description of this function package:                 *   FILE 670\n//*                                                                 *   FILE 670\n//*     This function package was originally DRXMATFN which is      *   FILE 670\n//*     for VM/CMS.  No enhancement yet, except just to make it     *   FILE 670\n//*     run on OS/390 or z/OS.  Hence, legacy HFP is still used     *   FILE 670\n//*     which is low precision and accuracy, since the last         *   FILE 670\n//*     touch was in 1993 on VM/ESA on ESA/370 machine.   Next      *   FILE 670\n//*     plan is to convert it to BFP once I have enough time.       *   FILE 670\n//*                                                                 *   FILE 670\n//*     This package can be used as a supplement to your REXX       *   FILE 670\n//*     to provide several math functions such as sin(), cos(),     *   FILE 670\n//*     tan() etc.   Hence, your REXX will look like PL/1.          *   FILE 670\n//*     Without such a package, REXX doesn't support any math       *   FILE 670\n//*     functions.   However, it just for availability.   There     *   FILE 670\n//*     is no guarantee for the performance, since all REXX         *   FILE 670\n//*     variables are internally presented as text strings.         *   FILE 670\n//*                                                                 *   FILE 670\n//*     Member Names                                                *   FILE 670\n//*     ============                                                *   FILE 670\n//*       $LOADLIB : Load library in TSO XMIT format                *   FILE 670\n//*       DRXFLOC  : Source code of package & package directory     *   FILE 670\n//*       DRXMATH  : Source code of package only module             *   FILE 670\n//*       @RXCSECT : Local macro                                    *   FILE 670\n//*       @RXENTRY : Local macro                                    *   FILE 670\n//*       @RXEXIT  : Local macro                                    *   FILE 670\n//*       @RXFDIR  : Local macro                                    *   FILE 670\n//*       DRXFUNC  : Local macro                                    *   FILE 670\n//*       ASSEMBLE : Assembling & linkage editor procedure          *   FILE 670\n//*       JDRXFLOC : Job to generate the package                    *   FILE 670\n//*       JDRXTEST : Job for batch testing                          *   FILE 670\n//*       TTEST0   : Rexx program for testing                       *   FILE 670\n//*       TTEST1   : Rexx program for testing                       *   FILE 670\n//*       TTEST2   : Rexx program for testing                       *   FILE 670\n//*       TTEST3   : Rexx program for testing                       *   FILE 670\n//*       TTEST5   : Rexx program for testing                       *   FILE 670\n//*       TTEST6   : Rexx program for testing                       *   FILE 670\n//*                                                                 *   FILE 670\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@RXCSECT": {"ttr": 530, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x03\\x00\\x14\\x01\\x04\\x06/\\x01\\x04\\x06_\\x03A\\x00:\\x00\\x14\\x00'\\xc4\\xc5\\xd9\\xe4@@@@@@\"", "ispf": {"version": "01.03", "flags": 0, "createdate": "2004-03-02T00:00:00", "modifydate": "2004-03-05T03:41:14", "lines": 58, "newlines": 20, "modlines": 39, "user": "DERU"}, "text": ".*================================================================*\n.*                                                                *\n.*   Module name -                                                *\n.*                 @RXCSECT                                       *\n.*                 Creates CSECT attributes                       *\n.*                                                                *\n.*   Description -                                                *\n.*                 Creates CSECT specification and attributes     *\n.*                                                                *\n.*   Type -                                                       *\n.*                 Assembly macro instruction                     *\n.*                                                                *\n.*   Syntax -                                                     *\n.*                  @RXCSECT                                      *\n.*                    ,amode=<31|24|any valid> default 31         *\n.*                    ,ramode=<any valid val>  default ANY        *\n.*                    ,runmode=<TRACE|PROD>    default PROD       *\n.*                                                                *\n.*   Author -                                                     *\n.*                 Deru Sudibyo                                   *\n.*                 Freelance consultant                           *\n.*                 Nusantara IT ProClub                           *\n.*                 Indonesia                                      *\n.*                                                                *\n.*                                                                *\n.*   Modification log -                                           *\n.*                                                                *\n.*  +----------+-------+---------+----------------------------+   *\n.*  |Date      | VRM   | Eng/Supp| Description                |   *\n.*  +----------+-------+---------+----------------------------+   *\n.*  |2004/03/05| 1.1.0 | Deru S. | First developed            |   *\n.*  |          |       |         |                            |   *\n.*  +----------+-------+---------+----------------------------+   *\n.*                                                                *\n.*                                                                *\n.*================================================================*\n         macro\n&label   @RXCSECT &amode=31,&rmode=ANY,&runmode=\n         gblb  &trace\n         aif  (t'&label eq 'O').erlabel\n         aif  (('&amode' ne '31') and ('&amode' ne '24')).eramode\n         aif  (('&rmode' ne 'ANY') and ('&rmode' ne '24')).errmode\n&label   CSECT\n&label   AMODE &amode\n&label   RMODE &rmode\n         aif  (t'&runmode eq 'O').end\n         aif  (('&runmode' ne 'TRACE') and ('&runmode' ne 'TEST')).end\n&trace   setb 1\n         mnote 4,'DRX111W This module will be generated in trace mode'\n         mexit\n.erlabel mnote 12,'DRX010E CSECT label is wrong or missed'\n         mexit\n.eramode mnote 12,'DRX011E Invalid AMODE=&amode'\n         mexit\n.errmode mnote 12,'DRX012E Invalid RMODE=&rmode'\n         mexit\n.end     anop\n         mend\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "@RXENTRY": {"ttr": 769, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01/\\x00\\x13\\x01\\x04\\x04o\\x01\\x04\\x06_\\x036\\x00\\xac\\x00\\x13\\x00\\xaa\\xc4\\xc5\\xd9\\xe4@@@@@@'", "ispf": {"version": "01.47", "flags": 0, "createdate": "2004-02-15T00:00:00", "modifydate": "2004-03-05T03:36:13", "lines": 172, "newlines": 19, "modlines": 170, "user": "DERU"}, "text": ".*================================================================*\n.*                                                                *\n.*   Module name -                                                *\n.*                 @RXENTRY                                       *\n.*                 Creates entrypoint and its prolog              *\n.*                                                                *\n.*   Description -                                                *\n.*                 Creates entrypoint and its housekeeping        *\n.*                 procedure                                      *\n.*                                                                *\n.*   Type -                                                       *\n.*                 Assembly macro instruction                     *\n.*                                                                *\n.*   Syntax -                                                     *\n.*                 @RXENTRY                                       *\n.*                    ,type=<EP|CSECT|NONE>    default EP         *\n.*                    ,basereg=<Rn|(Rm,Rn)>    default (R11,R12)  *\n.*                    ,parmreg=<Rn>            default R10        *\n.*                    ,workreg=<Rn>            default R8         *\n.*                    ,svreg=<Rn>              default R13        *\n.*                    ,argblok=<YES|NO>        default YES        *\n.*                    ,regequ=<YES|NO>         default YES        *\n.*                                                                *\n.*   Author -                                                     *\n.*                 Deru Sudibyo                                   *\n.*                 Freelance consultant                           *\n.*                 Nusantara IT ProClub                           *\n.*                 Indonesia                                      *\n.*                                                                *\n.*                                                                *\n.*   Modification log -                                           *\n.*                                                                *\n.*  +----------+-------+---------+----------------------------+   *\n.*  |Date      | VRM   | Eng/Supp| Description                |   *\n.*  +----------+-------+---------+----------------------------+   *\n.*  |2004/03/05| 1.1.0 | Deru S. | First developed            |   *\n.*  |          |       |         |                            |   *\n.*  +----------+-------+---------+----------------------------+   *\n.*                                                                *\n.*                                                                *\n.*================================================================*\n         macro\n&label   @RXENTRY &TYPE=EP,&BASEREG=(R11,R12),&PARMREG=R10,&WORKREG=R8,+\n               &WORKLEN=WORKSETL,&SVREG=R13,&SVAREA=SAVEAREA,          +\n               &LKREG=R14,&BASELBL=,&BASE=,&REGEQU=YES,&ARGBLOK=YES,   +\n               &ARGBLEN=ARGBLOKL,&ARGREG=R9\n         gblc  &wklen,&wkreg,&breg,&lbl\n         gblb  &equate,&getstor,&trace\n         lcla  &i,&nbreg\n         lclb  &arg\n         lclc  &usinglb,&breg2,&llbl\n&llbl    setc   'DER'.'&SYSNDX'\n&nbreg   seta  n'&BASEREG\n         aif   (&nbreg gt 1).breg1\n&breg    setc  '&BASEREG'\n&breg2   setc  'NO'\n         ago   .bregok\n.breg1   anop\n&breg    setc  '&BASEREG(1)'\n&breg2   setc  '&BASEREG(2)'\n.bregok  anop\n&wkreg   setc  '&WORKREG'\n&usinglb setc  ''\n         aif   ('&ARGBLOK' eq 'YES').addarg\n&wklen   setc  '&WORKLEN'\n         ago   .cont1\n.addarg  anop\n&wklen   setc  '&WORKLEN+&ARGBLEN'\n&arg     setb  1\n.cont1   AIF   (T'&label ne 'O').OK\n         mnote 8,'DRX004E Entry point name or label missing'\n         mexit\n.OK      AIF   ('&REGEQU' ne 'YES').endequ\n         aif   (&equate).endequ\n&lbl     setc   'DER'.'&SYSNDX'\n&i       seta  0\n.GRloop  aif   (&i gt 15).eqnext1\nR&i      equ   &i\n&i       seta  &i+1\n         ago   .GRloop\n.eqnext1 anop\n&i       seta  0\n.ARloop  aif   (&i gt 15).eqnext2\nA&i      equ   &i\n&i       seta  &i+1\n         ago   .ARloop\n.eqnext2 anop\n&i       seta  0\n.CRloop  aif   (&i gt 15).eqnext3\nC&i      equ   &i\n&i       seta  &i+1\n         ago   .CRloop\n.eqnext3 anop\nF0       equ   0\nF2       equ   2\nF4       equ   4\nF6       equ   6\n$PARMREG equ   &PARMREG\n$SAVEREG equ   &SVREG\n&equate  setb  1\n.endequ  AIF   ('&TYPE' eq 'EP').ep\n         AIF   ('&TYPE' eq 'CSECT').csect\n         ago   .skip\n.ep      anop\n         Entry &label\n.skip    anop\n         DS    0D\n&label   EQU   *\n         ago   .gohead\n.csect   anop\n&label   csect\n.gohead  aif   (T'&BASELBL eq 'O').goon\n&usinglb setc  '&BASELBL'\n.goon    anop\n         BAKR  &LKREG,0             Save regs, ARs etc\n         LR    &parmreg,R1          Save parmlist address\n         aif   (T'&BASE EQ 'O').ownbase\n         aif   (T'&BASELBL eq 'O').adjust\n         mnote 4,'DRX005W BASELBL=&BASELBL ignored for adjustable based+\n                program'\n.adjust  anop\n&llbl.a  equ   (&label-&BASE)/2\n         la    R1,&llbl.a\n         sll   R1,1\n.*       LAE   &breg,0(R15,0)\n         LR    &breg,R15\n         SLR   &breg,R1\n         ago   .breg2\n.ownbase anop\n.*       LAE   &breg,0(R15,0)       Base register\n         LR    &breg,R15\n&usinglb USING &label,&basereg\n.breg2   aif   (&nbreg eq 1).cknext\n         LAE   &breg2,1\n         LAE   &breg2,4095(&breg2,&breg)\n.cknext  aif   ('&wkreg' ne 'NO').getwks\n         ago   .trace\n.getwks  aif   (&getstor).getwks1\n.getwks1 anop\n.*       la    r0,&wklen\n.*       bas   r15,*+8\n.*       dc    A(&lbl.x)\n.*       l     r15,0(r15)\n.*       basr  &wkreg,r15\n         xr    r0,r0\n         bas   &wkreg,&lbl.x\n         LR    &svreg,R1\n         LR    &wkreg,R0\n         aif   (not &trace).trace01\n         icm   r0,b'1111',=x'11111111'\n.trace01 anop\n*        XC    0(&worklen,&svreg),0(&svreg)  zap workset\n         XC    0(worksave_length,&svreg),0(&svreg)  zap workset\n         St    &wkreg,savesize       save the size\n.*       LAE   &svreg,&svarea        save area addr in AR/R13\n         LAE   &svreg,0(&svreg)      save area addr in AR/R13\n         MVC   4(4,&svreg),=C'F1SA'  LS save area indicator\n         mvc   traceid,=cl8'&label'\n         aif   (not &arg).getstor\n         LA    &argreg,&worklen.(&svreg)\n.getstor aif   (&getstor).trace\n         b     &lbl.z\n&lbl.x   equ   *\n         STORAGE OBTAIN,LOC=(31,31),LENGTH=&wklen\n         br    &wkreg\n&lbl.z   equ   *\n&getstor setb  1\n.trace   aif   (not &trace).exit\n         WTO   'DRX0001I Prolog of &label was just passed',            +\n               routcde=(1,10)\n.exit    anop\n         mend\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "@RXEXIT": {"ttr": 773, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00H\\x01\\x04\\x04o\\x01\\x04\\x06_\\x03F\\x00B\\x00\\t\\x00?\\xc4\\xc5\\xd9\\xe4@@@@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "2004-02-15T00:00:00", "modifydate": "2004-03-05T03:46:48", "lines": 66, "newlines": 9, "modlines": 63, "user": "DERU"}, "text": ".*================================================================*\n.*                                                                *\n.*   Module name -                                                *\n.*                 @RXEXIT                                        *\n.*                 Creates exit procedure                         *\n.*                                                                *\n.*   Description -                                                *\n.*                 Creates exit epilog and housekeeping           *\n.*                 procedure                                      *\n.*                                                                *\n.*   Type -                                                       *\n.*                 Assembly macro instruction                     *\n.*                                                                *\n.*   Syntax -                                                     *\n.*                  @RXEXIT                                       *\n.*                    ,rc=<YES|NO>             default NO         *\n.*                    ,basereg=<KEEP|DROP>     default KEEP       *\n.*                    ,ltorg=<YES|NO>          default YES        *\n.*                                                                *\n.*   Author -                                                     *\n.*                 Deru Sudibyo                                   *\n.*                 Freelance consultant                           *\n.*                 Nusantara IT ProClub                           *\n.*                 Indonesia                                      *\n.*                                                                *\n.*                                                                *\n.*   Modification log -                                           *\n.*                                                                *\n.*  +----------+-------+---------+----------------------------+   *\n.*  |Date      | VRM   | Eng/Supp| Description                |   *\n.*  +----------+-------+---------+----------------------------+   *\n.*  |2004/03/05| 1.1.0 | Deru S. | First developed            |   *\n.*  |          |       |         |                            |   *\n.*  +----------+-------+---------+----------------------------+   *\n.*                                                                *\n.*                                                                *\n.*================================================================*\n         macro\n&label   @RXEXIT &RC=NO,&BASEREG=KEEP,&LTORG=YES,&TEMPREG=R2\n         gblc  &wklen,&wkreg,&breg\n         lclc  &llbl\n&label   DS    0h\n&llbl    setc  'DER'.'&SYSNDX'\n         AIF   ('&RC' eq 'NO').relstor\n         lr    &tempreg,r15\n.relstor anop\n         l     r0,savesize\n         ltr   r0,r0\n         bp    &llbl.a\n         la    r0,&wklen\n&llbl.a  equ   *\n         lr    &wkreg,$SAVEREG\n         STORAGE RELEASE,ADDR=(&wkreg),LENGTH=(0)\n         AIF   ('&RC' ne 'NO').setrc\n         SLR   R15,R15                      RC=0\n         ago   .return\n.setrc   anop\n         lr    R15,&tempreg\n.return  anop\n         PR                                 Return\n         aif  (('&BASEREG' ne 'DROP') and ('&BASEREG' ne 'RESET')).q1\n         DROP  &breg\n.q1      aif  ('&LTORG' ne 'YES').q2\n         LTORG ,\n.q2      anop\n         mend\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "@RXFDIR": {"ttr": 775, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x08\\x004\\x01\\x04\\x04\\x0f\\x01\\x04\\x06_\\x04\\x02\\x00T\\x00\\x19\\x00T\\xc4\\xc5\\xd9\\xe4@@@@@@'", "ispf": {"version": "01.08", "flags": 0, "createdate": "2004-02-09T00:00:00", "modifydate": "2004-03-05T04:02:34", "lines": 84, "newlines": 25, "modlines": 84, "user": "DERU"}, "text": ".*================================================================*\n.*                                                                *\n.*   Module name -                                                *\n.*                 @RXFDIR                                        *\n.*                 Creates rexx package directory entry           *\n.*                                                                *\n.*   Description -                                                *\n.*                 Creates rexx function package directory        *\n.*                 entry on IRXFLOC or IRXFUSER component         *\n.*                                                                *\n.*   Type -                                                       *\n.*                 Assembly macro instruction                     *\n.*                                                                *\n.*   Syntax -                                                     *\n.*                 (1)  Header                                    *\n.*                                                                *\n.*                   @RXFDIR                                      *\n.*                    ,start                                      *\n.*                    ,rows=nn                 number of entry    *\n.*                                                                *\n.*                                                                *\n.*                 (2)  Entry                                     *\n.*                                                                *\n.*                   @RXFDIR                                      *\n.*                    ,function                                   *\n.*                    ,name=<function name>                       *\n.*                    ,ep=<EP name>                               *\n.*                    ,dd=<DD name from which EP is loaded>       *\n.*                    ,addrtype=<A|V>                             *\n.*                                                                *\n.*                 (3)  Trailer                                   *\n.*                                                                *\n.*                   @RXFDIR                                      *\n.*                    ,<finish|end>  whether END mark is written  *\n.*                                                                *\n.*   Author -                                                     *\n.*                 Deru Sudibyo                                   *\n.*                 Freelance consultant                           *\n.*                 Nusantara IT ProClub                           *\n.*                 Indonesia                                      *\n.*                                                                *\n.*                                                                *\n.*   Modification log -                                           *\n.*                                                                *\n.*  +----------+-------+---------+----------------------------+   *\n.*  |Date      | VRM   | Eng/Supp| Description                |   *\n.*  +----------+-------+---------+----------------------------+   *\n.*  |2004/03/05| 1.1.0 | Deru S. | First developed            |   *\n.*  |          |       |         |                            |   *\n.*  +----------+-------+---------+----------------------------+   *\n.*                                                                *\n.*                                                                *\n.*================================================================*\n         macro\n&label   @rxfdir &cmd,&name=,&addrtype=A,&ep=,&dd=,&rows=\n         gbla &count\n         gblb &started\n         aif (t'&cmd eq 'O').nocmd\n         aif (('&cmd' eq 'start') or ('&cmd' eq 'begin')).start\n         aif ('&cmd' eq 'end').end\n         aif ('&cmd' eq 'finish').finish\n         aif (('&cmd' eq 'function') or ('&cmd' eq 'func')).func\n         MNOTE 8,'DRX0003 Illegal command ''&cmd'''\n         mexit\n.func    anop\n         DRXFUNC name=&name,addrtype=&addrtype,                        +\n               ep=&ep,dd=&dd\n         mexit\n.nocmd   aif  (&started).end\n.start   anop\n         aif   (t'row ne 'O').start1\n         MNOTE 8,'DRX0004 Invalid number directory rows'\n         mexit\n.start1  anop\n&started setb  1\n         DC    CL8'IRXFPACK'       String identifying directory\n         DC    FL4'24'             Length of header\n         DC    FL4'&rows'          Number of rows in directory\n         DC    FL4'0'              Word of zeros\n         DC    FL4'32'             Length of directory entry\n.finish  mexit\n.end     anop\n         end\n         mend\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ASSEMBLE": {"ttr": 778, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00(\\x01\\x04\\x03\\x9f\\x01\\x04\\x06/\\x168\\x00/\\x00.\\x00\\x00\\xc4\\xc5\\xd9\\xe4@@@@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2004-02-08T00:00:00", "modifydate": "2004-03-02T16:38:28", "lines": 47, "newlines": 46, "modlines": 0, "user": "DERU"}, "text": "//ASSEMBLE PROC MBR=,\n//          PROG=ASMA90,\n//          NAME=,\n//          APARM='OBJECT,NODECK,ALIGN',\n//          LPARM='REUS,RMODE(ANY)',\n//          SRCLIB='NIT.SRCLIB',\n//          LNKLIB='NIT.LOADLIB',\n//          MACLIB='NIT.MACLIB',\n//          SOUTC=X\n//*\n//*   +------------+\n//*   | ASSEMBLING |\n//*   +------------+\n//A        EXEC  PGM=&PROG,\n//            PARM=('&APARM')\n//SYSLIB   DD  DSN=&MACLIB,DISP=SHR,DCB=BLKSIZE=20000\n//         DD  DSN=&SRCLIB,DISP=SHR,DCB=BLKSIZE=20000\n//         DD  DSN=SYS1.MACLIB,DISP=SHR\n//         DD  DSN=SYS1.MODGEN,DISP=SHR\n//         DD  DSN=SYS1.SISTMAC1,DISP=SHR\n//         DD  DSN=SYS1.V2R10M0.SHASMAC,DISP=SHR\n//SYSIN    DD  DSN=&SRCLIB(&MBR),DISP=SHR\n//SYSPRINT DD  SYSOUT=(&SOUTC,A&MBR)\n//*YSPUNCH DD  UNIT=SYSALLDA,DISP=(,PASS),\n//*            SPACE=(6080,(50,20),RLSE),\n//*            DCB=(RECFM=FB,LRECL=80,BLKSIZE=3120)\n//SYSLIN   DD  DSN=&&OBJ,SPACE=(3040,(40,40),,,ROUND),\n//             UNIT=SYSALLDA,DISP=(MOD,PASS),\n//             DCB=(BLKSIZE=3040,LRECL=80,RECFM=FB,BUFNO=1)\n//SYSUT1   DD  DSN=&&SYSUT1,SPACE=(4096,(120,120),,,ROUND),\n//             UNIT=SYSALLDA,DCB=BUFNO=1\n//*\n//*   +--------------+\n//*   | LINK-EDITING |\n//*   +--------------+\n//L        EXEC  PGM=HEWL,\n//             PARM=('XREF,LIST','&LPARM'),\n//             COND=((4,LT,A))\n//SYSLIB   DD  DSN=&LNKLIB,DISP=(SHR),\n//             DCB=BLKSIZE=20000\n//*YSLIN   DD  DSN=*.ASM.SYSPUNCH,DISP=(OLD,DELETE)\n//SYSLIN   DD  DSN=&&OBJ,DISP=(OLD,DELETE)\n//         DD  DDNAME=SYSIN\n//SYSLMOD  DD  DSN=&LNKLIB(&NAME),DISP=(SHR)\n//SYSPRINT DD  SYSOUT=(&SOUTC,L&NAME)\n//SYSUT1   DD  DSN=&&SYSUT1,SPACE=(4096,(120,120),,,ROUND),\n//             UNIT=SYSALLDA,DCB=BUFNO=1\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DRXFLOC": {"ttr": 780, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0f\\x00\\x08\\x01\\x04\\x06\\x1f\\x01\\x04\\x06\\x8f\\x16\\x00\\x00`\\x07\\xd9\\x00K\\xc4\\xc5\\xd9\\xe4@@@@@@'", "ispf": {"version": "01.15", "flags": 0, "createdate": "2004-03-01T00:00:00", "modifydate": "2004-03-08T16:00:08", "lines": 96, "newlines": 2009, "modlines": 75, "user": "DERU"}, "text": "      TITLE 'LOCFN: REXX Local function package'\n*====================================================================*\n*                                                                    *\n*   MODULE NAME  -                                                   *\n*                   DRXFLOC                                          *\n*                   Rexx math function package directory             *\n*                                                                    *\n*   DESCRIPTION  -                                                   *\n*                   Establish directory of mathematical functions    *\n*                   in Rexx linked to external local program.        *\n*                                                                    *\n*   COMPONENT    -                                                   *\n*                   IRXFLOC, Rexx Local Function Packages            *\n*                                                                    *\n*   TYPE         -                                                   *\n*                   o  Non-executable load module                    *\n*                   o  Reentrant, reusable and refreshable           *\n*                                                                    *\n*   PROCESSOR    -                                                   *\n*                   Assembler H or HLASM                             *\n*                                                                    *\n*   ENVIRONMENT  -                                                   *\n*                   MVS, TSO and ISPF of OS/390                      *\n*                                                                    *\n*   INSTALLATION NOTES -                                             *\n*                                                                    *\n*        o     Bind all supporting mathematical function package     *\n*              modules in this module and inform all appropriate     *\n*              entrypoints to linkeditor to be generated as aliases  *\n*              in load library.                                      *\n*                                                                    *\n*        o     Include all supporting macros in the SYSLIB           *\n*                                                                    *\n*                                                                    *\n*                                                                    *\n*   Macros and Data areas -                                          *\n*                                                                    *\n*        @RXCSECT   - local lib: Generate CSECT attributes           *\n*        @RXFDIR    - local lib: Generate package directory entry    *\n*                                                                    *\n*                                                                    *\n*   AUTHOR AND COPYRIGHT -                                           *\n*                                                                    *\n*   Author        -  Ir. DERU SUDIBYO                                *\n*                    Freelance consultant                            *\n*                    Nusantara IT Pro Club                           *\n*                    Indonesia                                       *\n*                                                                    *\n*   Copyright     - (C) 1991-2004 Deru Sudibyo                       *\n*                                                                    *\n*                                                                    *\n*   MODIFICATION LOG -                                               *\n*                                                                    *\n*   ---------------------------------------------------------------  *\n*   No.| Date   |Level|   Engineer    | Description                  *\n*   ---------------------------------------------------------------  *\n*    6 |04/02/01|1.1.0| Deru Sudibyo  | 1st development,             *\n*      |        |     |               | to accommodate DRXMATFN      *\n*      |        |     |               | which is VM/CMS version      *\n*      |        |     |               |                              *\n*   ---------------------------------------------------------------  *\n*                                                                    *\n*====================================================================*\n         eject\nIRXFLOC  @RXCSECT amode=31,rmode=ANY,runmode=NORMAL\n         @rxfdir start,rows=23\n         @rxfdir function,name=SIN,ep=DRXSIN\n         @rxfdir function,name=COS,ep=DRXCOS\n         @rxfdir function,name=TAN,ep=DRXTAN\n         @rxfdir function,name=CSC,ep=DRXCSC\n         @rxfdir function,name=SEC,ep=DRXSEC\n         @rxfdir function,name=COT,ep=DRXCOT\n         @rxfdir function,name=SINH,ep=DRXSINH\n         @rxfdir function,name=COSH,ep=DRXCOSH\n         @rxfdir function,name=TANH,ep=DRXTANH\n         @rxfdir function,name=CSCH,ep=DRXCSCH\n         @rxfdir function,name=SECH,ep=DRXSECH\n         @rxfdir function,name=COTH,ep=DRXCOTH\n         @rxfdir function,name=LN,ep=DRXLN\n         @rxfdir function,name=LOG,ep=DRXLOG\n         @rxfdir function,name=EXP,ep=DRXEXP\n         @rxfdir function,name=RAD,ep=DRXRAD\n         @rxfdir function,name=FACT,ep=DRXFACT\n         @rxfdir function,name=FRAC,ep=DRXFRAC\n         @rxfdir function,name=COMB,ep=DRXCOMB\n         @rxfdir function,name=PERM,ep=DRXPERM\n         @rxfdir function,name=SQRT,ep=DRXSQRT\n         @rxfdir function,name=POWER,ep=DRXPOWER\n         @rxfdir function,name=ARGTEST,ep=DRXTARG\n         @rxfdir finish\n         eject\n*====================================================================*\n*  Rexx function package external modules                            *\n*                                                                    *\n*====================================================================*\n         copy  DRXMATH\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DRXFUNC": {"ttr": 783, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00W\\x01\\x04\\x04\\x0f\\x01\\x04\\x06_\\x04\\x08\\x00P\\x00\\x1b\\x00O\\xc4\\xc5\\xd9\\xe4@@@@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "2004-02-09T00:00:00", "modifydate": "2004-03-05T04:08:57", "lines": 80, "newlines": 27, "modlines": 79, "user": "DERU"}, "text": ".*================================================================*\n.*                                                                *\n.*   Module name -                                                *\n.*                 DRXFUNC                                        *\n.*                 Creates rexx package directory entry           *\n.*                                                                *\n.*   Description -                                                *\n.*                 Called by @RXFDIR macro to create function     *\n.*                 directory entry on IRXFLOC or IRXFUSER         *\n.*                 Note:  This macro is inner macro of @RXFDIR    *\n.*                                                                *\n.*                                                                *\n.*   Type -                                                       *\n.*                 Assembly macro instruction                     *\n.*                                                                *\n.*   Syntax -                                                     *\n.*                  DRXFUNC                                       *\n.*                    ,name=<function name>                       *\n.*                    ,ep=<EP name>                               *\n.*                    ,dd=<DD name from which EP is loaded>       *\n.*                    ,addrtype=<A|V>                             *\n.*                                                                *\n.*   Author -                                                     *\n.*                 Deru Sudibyo                                   *\n.*                 Freelance consultant                           *\n.*                 Nusantara IT ProClub                           *\n.*                 Indonesia                                      *\n.*                                                                *\n.*                                                                *\n.*   Modification log -                                           *\n.*                                                                *\n.*  +----------+-------+---------+----------------------------+   *\n.*  |Date      | VRM   | Eng/Supp| Description                |   *\n.*  +----------+-------+---------+----------------------------+   *\n.*  |2004/03/05| 1.1.0 | Deru S. | First developed            |   *\n.*  |          |       |         |                            |   *\n.*  +----------+-------+---------+----------------------------+   *\n.*                                                                *\n.*                                                                *\n.*================================================================*\n         macro\n&label   DRXFUNC &name=,&addrtype=A,&ep=,&dd=\n         lclc  &atype,&epname,&ddname,&addr\n         lclb  &epok\n         aif   (t'&name eq 'O').errname\n         aif  (t'&ep ne 'O').go1\n&epname  setc ' '\n         ago  .go2\n.go1     anop\n&epname  setc '&ep'\n&epok    setb 1\n.go2     aif  (t'&dd ne 'O').go3\n&ddname  setc ' '\n         ago  .go4\n.go3     anop\n&ddname  setc '&dd'\n.go4     anop\n         aif   (('&addrtype' eq 'A') or ('&addrtype' eq 'a')).atype\n         aif   (('&addrtype' eq 'V') or ('&addrtype' eq 'v')).vtype\n         ago   .errtype\n.atype   anop\n&atype   setc 'A'\n&addr    setc '0'\n         ago  .build\n.vtype   aif  (not &epok).errep\n&atype   setc 'V'\n&addr    setc '&epname'\n.build   anop\n         DC   CL8'&name'\n         DC   &atype.L4(&addr)\n         DC   FL4'0'\n         DC   CL8'&epname'\n         DC   CL8'&ddname'\n         mexit\n.errname MNOTE 8,'DRX0001 Illegal name of function'\n         mexit\n.errep   MNOTE 8,'DRX0009 Address type V must use entrypoint name.'\n         mexit\n.errtype MNOTE 8,'DRX0002 Wrong address type, neither A nor V'\n         mend\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "DRXMATH": {"ttr": 1025, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00Q\\x01\\x195/\\x01\\x195/#8\\x08o\\x08n\\x08o\\xc4\\xe7\\xc3\\xf0\\xf0@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2019-12-18T00:00:00", "modifydate": "2019-12-18T23:38:51", "lines": 2159, "newlines": 2158, "modlines": 2159, "user": "DXC00"}, "text": "DERU  TITLE 'LOCFN: REXX Local function package'\n         gblb  &trace\n*====================================================================*\n*                                                                    *\n*   MODULE NAME  -                                                   *\n*                   DRXMATH                                          *\n*                   Rexx mathematical function package               *\n*                                                                    *\n*   DESCRIPTION  -                                                   *\n*                   Provide some mathematical functions in Rexx      *\n*                   programming language.  It can be used as a       *\n*                   supplement to complete rexx capabilities.        *\n*                                                                    *\n*   COMPONENT    -                                                   *\n*                   IRXFLOC, Rexx Local Function Packages            *\n*                                                                    *\n*   TYPE         -                                                   *\n*                   o  Executable load module                        *\n*                   o  Reentrant, reusable and refreshable           *\n*                                                                    *\n*   PROCESSOR    -                                                   *\n*                   Assembler H or HLASM                             *\n*                                                                    *\n*   ENVIRONMENT  -                                                   *\n*                   MVS, TSO and ISPF of OS/390                      *\n*                                                                    *\n*   INSTALLATION NOTES -                                             *\n*                                                                    *\n*        o     Bind this module to appropriate IRXFLOC component     *\n*              and generate aliases for all entrypoints, as shown    *\n*              in the following example:                             *\n*                                                                    *\n*                //JDRXFLOC JOB (1,NIT),'ASSEMBLE IRXFLOC',          *\n*                //      CLASS=A,MSGCLASS=X,                         *\n*                //      REGION=4M,MSGLEVEL=(1,1),NOTIFY=&SYSUID     *\n*                //    JCLLIB ORDER=NIT.PROCLIB                      *\n*                //    EXEC ASSEMBLE,MBR=DRXFLOC,NAME=IRXFLOC,       *\n*                //         APARM='OBJECT,NODECK,ALIGN,RENT',        *\n*                //         LPARM='RENT,REUS,REFR,RMODE(ANY)'        *\n*                //L.SYSIN   DD *                                    *\n*                  ALIAS DRXEXP,                                     *\n*                        DRXSIN,                                     *\n*                        DRXCOS,                                     *\n*                        DRXTAN,                                     *\n*                        DRXCSC,                                     *\n*                        DRXSEC,                                     *\n*                        DRXCOT,                                     *\n*                        DRXSINH,                                    *\n*                        DRXCOSH,                                    *\n*                        DRXTANH,                                    *\n*                        DRXCSCH,                                    *\n*                        DRXSECH,                                    *\n*                        DRXCOTH,                                    *\n*                        DRXSQRT,                                    *\n*                        DRXLOG,                                     *\n*                        DRXRAD,                                     *\n*                        DRXLN,                                      *\n*                        DRXPOWER,                                   *\n*                        DRXFACT,                                    *\n*                        DRXFRAC,                                    *\n*                        DRXCOMB,                                    *\n*                        DRXPERM                                     *\n*                  NAME IRXFLOC(R)                                   *\n*                /*                                                  *\n*                                                                    *\n*        o     Include all supporting macros in the SYSLIB           *\n*                                                                    *\n*        o     The accuracy and precision still studied until some   *\n*              modification level in this release.   There is no     *\n*              accuracy and precision update until this release      *\n*              declared.                                             *\n*                                                                    *\n*        o     Some other functions such as arcsin(), arccos(), ect. *\n*              to be available in next release.                      *\n*                                                                    *\n*                                                                    *\n*   Macros and Data areas -                                          *\n*                                                                    *\n*        @RXCSECT  - local lib: Generate CSECT attributes            *\n*        @RXENTRY  - local lib: Generate entrypoint prolog procedure *\n*        @RXEXIT   - local lib: Generate exit epilog procedure       *\n*        WTO       - system lib (SYS1.MACLIB): Display console msg   *\n*        WORKSET   - inline savearea                                 *\n*        ARGBLOK   - inline argument analysis area                   *\n*        IRXARGTB  - system lib (SYS1.MACLIB): Argument table map    *\n*        IRXPARMB  - system lib (SYS1.MACLIB): Parameter table map   *\n*        IRXEVALB  - system lib (SYS1.MACLIB): Evaluation block map  *\n*        IRXEFPL   - system lib (SYS1.MACLIB): Extended parameter    *\n*        IHAEPIE   - system lib (SYS1.MACLIB): Program interrupt map *\n*                                                                    *\n*                                                                    *\n*   ENTRY POINTS -                                                   *\n*                                                                    *\n*        DRXMATFN   -  Package program                               *\n*        DRXEXP     -  EXP(x) function to return e**x                *\n*        DRXSIN     -  SIN(x) function to return sin x               *\n*        DRXCOS     -  COS(x) function to return cos x               *\n*        DRXTAN     -  TAN(x) function to return tan x               *\n*        DRXCSC     -  CSC(x) function to return csc x               *\n*        DRXSEC     -  SEC(x) function to return sec x               *\n*        DRXCOT     -  COT(x) function to return cot x               *\n*        DRXSINH    -  SINH(x) function to return sinh x             *\n*        DRXCOSH    -  COSH(x) function to return cosh x             *\n*        DRXTANH    -  TANH(x) function to return tanh x             *\n*        DRXCSCH    -  CSCH(x) function to return csch x             *\n*        DRXSECH    -  SECH(x) function to return sech x             *\n*        DRXCOTH    -  COTH(x) function to return coth x             *\n*        DRXSQRT    -  SQRT(x) function to return V x                *\n*        DRXLOG     -  LOG(x) function to return log x base 10       *\n*        DRXLN      -  LN(x)  function to return log x base e        *\n*        DRXPOWER   -  POWER(x,p) function to return x**p            *\n*        DRXFACT    -  FACT(x) function to return x!                 *\n*        DRXCOMB    -  COMB(N,x) function to return N!/(x! * (N-x)!) *\n*        DRXPERM    -  PERM(N,x) function to return N!/(N-x)!        *\n*                                                                    *\n*   AUTHOR AND COPYRIGHT -                                           *\n*                                                                    *\n*   Author        -  Ir. DERU SUDIBYO                                *\n*                    Freelance consultant                            *\n*                    Nusantara IT Pro Club                           *\n*                    Indonesia                                       *\n*                                                                    *\n*   Copyright     - (C) 1991-2004 Deru Sudibyo                       *\n*                                                                    *\n*                                                                    *\n*   MODIFICATION LOG -                                               *\n*                                                                    *\n*   ---------------------------------------------------------------  *\n*   No.| Date   |Level|   Engineer    | Description                  *\n*   ---------------------------------------------------------------  *\n*    1 |91/02/11|1.0.0| Deru Sudibyo  | 1st development              *\n*    2 |91/03/21|1.1.0| Deru Sudibyo  | Declare release 1            *\n*    3 |91/06/15|1.1.1| Deru Sudibyo  | implement ABNEXIT and SUBPOOL*\n*    4 |91/06/20|1.1.1| Deru Sudibyo  | implement prog. int. FLIH    *\n*    5 |93/10/20|1.1.2| Deru Sudibyo  | implement XA/ESA/XC adaptor  *\n*    6 |04/02/01|2.1.0| Deru Sudibyo  | Change version for OS/390    *\n*    7 |19/12/18|2.1.1| Danny Companez| Fix FRAC function            *\n*   ---------------------------------------------------------------  *\n*                                                                    *\n*====================================================================*\n         EJECT\nDRXMATH  @RXCSECT amode=31,rmode=ANY runmode=TRACE\n         using DRXMATH,R11,R12     Base addressability\n         using WORKSET,R13         Map workset & savearea\n         USING ARGBLOK,R9          Map argument parsing area\n         USING EFPL,R10            Map extended parm list\n         space 1\n*--------------------------------------------------------------------*\n*   FUNCTION CONSTANT SUPPORT COLLECTION                             *\n*   Constant that frequently used in several calculation.            *\n*   The main purpose is to reduce overhead instead of iterate        *\n*   process to find them.                                            *\n*--------------------------------------------------------------------*\n         space 1\nCONSTANT EQU   *\nPHI      DC    D'3.141592654'\nLN10     DC    D'2.302585093'\nEXP1     DC    D'2.718281828'\nZERRO    DC    D'0'\nONE      DC    D'1'\nCIRCLE   DC    D'360'\nUNNORMSG DC    X'4E00000100000000'\nUNNORM   DC    X'4E00000000000000'\nCONSTLEN EQU   *-CONSTANT\n         Eject\n*--------------------------------------------------------------------*\n*                                                                    *\n*  RADIAN:   CALCULATE DEGREE TO RADIAN CONVERSION                   *\n*                                                                    *\n*   - Perform Rad(X) = inverse of 2 pi from degree                   *\n*                                                                    *\n*--------------------------------------------------------------------*\n         SPACE 2\nDRXRAD   @rxentry type=EP,base=DRXMATH\n         mvc   function_address,=A(RADIAN)   assign RADIAN function\n         B     FUNCEXE     perform Rad(X)\n         SPACE 2\n*--------------------------------------------------------------------*\n*                                                                    *\n*  FRAC   :   EXTRACT FRACTION                                       *\n*                                                                    *\n*--------------------------------------------------------------------*\n         SPACE 2\nDRXFRAC  @rxentry type=EP,base=DRXMATH\n         MVC   Number_of_arg,=H'1'   Have 1 argument\n         bas   R14,Get_1st_arg       check arguments\n         LD    F0,ARGVALUE           get argument\n         LDR   F2,F0                 duplicated\n         AW    F2,#unnormal          unnormalized zero\n         ad    F2,#zero              normalize result            2.1.1\n         SDR   F0,F2                 subtract from the original  2.1.1\n         STD   F0,ARGRSULT           save the result\n         LA    R15,0                 Set good return code\n         b     PRINT                 finally, print the output\n         LTORG ,\n         SPACE 2\n*--------------------------------------------------------------------*\n*                                                                    *\n*  SIN   : CALCULATE SINUS FUNCTION                                  *\n*                                                                    *\n*     - Perform Sin(X) series computation                            *\n*                                                                    *\n*--------------------------------------------------------------------*\n         SPACE 2\nDRXSIN   @rxentry type=EP,base=DRXMATH\n         MVC   function_address,=A(SINE)  assign SINE function\n         MVI   Optional_arg_flag,Optional_arg_check  check option\n         B     FUNCEXE                    perform Sin(X)\n         SPACE 2\n*--------------------------------------------------------------------*\n*                                                                    *\n*   COS   : CALCULATE COSINUS FUNCTION                               *\n*                                                                    *\n*     - Perform Cos(X) series computation                            *\n*                                                                    *\n*--------------------------------------------------------------------*\n         SPACE 1\nDRXCOS   @rxentry type=EP,base=DRXMATH\n         mvc   function_address,=A(COSINE)  assign COSINE function\n         MVI   Optional_arg_flag,Optional_arg_check  check option\n         B     FUNCEXE                      perform Cos(X)\n         SPACE 2\n*--------------------------------------------------------------------*\n*                                                                    *\n*   TAN   : CALCULATE TANGEN FUNCTION                                *\n*                                                                    *\n*     - Perform Cos(X) series computation                            *\n*   - Perform Sin(X) series computation                              *\n*   - Calculate Tan(X) = Sin(X)/Cos(X)                               *\n*                                                                    *\n*--------------------------------------------------------------------*\n         SPACE 1\nDRXTAN   @rxentry type=EP,base=DRXMATH\n         MVC   function_address,=A(SINE)     assign SINE function\n         mvc   function2_address,=A(COSINE)  assign COSINE function\n         MVI   Optional_arg_flag,Optional_arg_check  check option\n         B     FUNCDIV                       perform Sin(X)/Cos(X)\n         SPACE 2\n*--------------------------------------------------------------------*\n*                                                                    *\n*   CSC   : CALCULATE COSECAN FUNCTION                               *\n*                                                                    *\n*   - Perform Sin(X) series computation                              *\n*   - Calculate Csc(X) = 1/Sin(X)                                    *\n*                                                                    *\n*--------------------------------------------------------------------*\n         SPACE 2\nDRXCSC   @rxentry type=EP,base=DRXMATH\n         MVC   function_address,=A(SINE)    assign SINE function\n         MVI   Optional_arg_flag,Optional_arg_check  check option\n         B     FUNCINV                      perform 1/Sin(X)\n         SPACE 2\n*--------------------------------------------------------------------*\n*                                                                    *\n*   SEC   : CALCULATE SECAN FUNCTION                                 *\n*                                                                    *\n*   - Perform Cos(X) series computation                              *\n*   - Calculate Sec(X) = 1/Cos(X)                                    *\n*                                                                    *\n*--------------------------------------------------------------------*\n         SPACE 1\nDRXSEC   @rxentry type=EP,base=DRXMATH\n         mvc   function_address,=A(COSINE)  assign COSINE function\n         MVI   Optional_arg_flag,Optional_arg_check  check option\n         B     FUNCINV                      perform 1/COS(X)\n         SPACE 2\n*--------------------------------------------------------------------*\n*                                                                    *\n*   COT   : CALCULATE COTANGEN FUNCTION                              *\n*                                                                    *\n*   - Perform Sin(X) series computation                              *\n*   - Perform Cos(X) series computation                              *\n*   - Calculate Cot(X) = Cos(X)/Sin(X)                               *\n*                                                                    *\n*--------------------------------------------------------------------*\n         SPACE 1\nDRXCOT   @rxentry type=EP,base=DRXMATH\n         mvc   function_address,=A(COSINE)  assign COSINE function\n         MVC   function2_address,=A(SINE)   assign SINE function\n         MVI   Optional_arg_flag,Optional_arg_check  check option\n         B     FUNCDIV                      perform Cos(X)/Sin(X)\n         SPACE 2\n*--------------------------------------------------------------------*\n*                                                                    *\n*   SINH : CALCULATE HYPERBOLIC SINE FUNCTION                        *\n*                                                                    *\n*   - Perform Sinh(X) computation                                    *\n*                                                                    *\n*--------------------------------------------------------------------*\n         SPACE 1\nDRXSINH  @rxentry type=EP,base=DRXMATH\n         MVC   function_address,=A(SINH)    assign SINH function\n         MVI   Optional_arg_flag,Optional_arg_check  check option\n         B     FUNCEXE                      perform Sinh(X)\n         SPACE 2\n*--------------------------------------------------------------------*\n*                                                                    *\n*   COSH : CALCULATE HYPERBOLIC COSINE FUNCTION                      *\n*                                                                    *\n*   - Perform Cosh(X) computation                                    *\n*                                                                    *\n*--------------------------------------------------------------------*\n         SPACE 1\nDRXCOSH  @rxentry type=EP,base=DRXMATH\n         MVC   function_address,=A(COSH)    assign COSH function\n         MVI   Optional_arg_flag,Optional_arg_check  check option\n         B     FUNCEXE                      perform Cosh(X)\n         SPACE 2\n*--------------------------------------------------------------------*\n*                                                                    *\n*   TANH : CALCULATE HYPERBOLIC TANGEN FUNCTION                      *\n*                                                                    *\n*   - Perform Cosh(X) computation                                    *\n*   - Perform Sinh(X) computation                                    *\n*   - Calculate Tanh(X) = Sinh(X)/Cosh(X)                            *\n*                                                                    *\n*--------------------------------------------------------------------*\n         SPACE 1\nDRXTANH  @rxentry type=EP,base=DRXMATH\n         MVC   function_address,=A(SINH)     assign SINH function\n         MVC   function2_address,=A(COSH)    assign COSH function\n         MVI   Optional_arg_flag,Optional_arg_check  check option\n         B     FUNCDIV                       perform Sinh(X)/Cosh(X)\n         SPACE 2\n*--------------------------------------------------------------------*\n*                                                                    *\n*   CSCH : CALCULATE HYPERBOLIC COSECAN FUNCTION                     *\n*                                                                    *\n*   - Perform Sinh(X) series computation                             *\n*   - Calculate Csch(X) = 1/Sinh(X)                                  *\n*                                                                    *\n*--------------------------------------------------------------------*\n         SPACE 2\nDRXCSCH  @rxentry type=EP,base=DRXMATH\n         MVC   function_address,=A(SINH)     assign SINH function\n         MVI   Optional_arg_flag,Optional_arg_check  check option\n         B     FUNCINV                       perform 1/Sinh(X)\n         SPACE 2\n*--------------------------------------------------------------------*\n*                                                                    *\n*   SECH : CALCULATE HYPERBOLIC SECAN FUNCTION                       *\n*                                                                    *\n*   - Perform Cosh(X) series computation                             *\n*   - Calculate Sech(X) = 1/Cosh(X)                                  *\n*                                                                    *\n*--------------------------------------------------------------------*\n         SPACE 1\nDRXSECH  @rxentry type=EP,base=DRXMATH\n         MVC   function_address,=A(COSH)    assign COSH function\n         MVI   Optional_arg_flag,Optional_arg_check  check option\n         B     FUNCINV                      perform 1/Cosh(X)\n         SPACE 2\n*--------------------------------------------------------------------*\n*                                                                    *\n*   COTH : CALCULATE HYPERBOLIC COTANGEN FUNCTION                    *\n*                                                                    *\n*   - Perform Sinh(X) computation                                    *\n*   - Perform Cosh(X) computation                                    *\n*   - Calculate Coth(X) = Cosh(X)/Sinh(X)                            *\n*                                                                    *\n*--------------------------------------------------------------------*\n         SPACE 1\nDRXCOTH  @rxentry type=EP,base=DRXMATH\n         MVC   function_address,=A(COSH)     assign COSH function\n         MVC   function2_address,=A(SINH)    assign SINH function\n         MVI   Optional_arg_flag,Optional_arg_check  check option\n         B     FUNCDIV                       perform Cosh(X)/Sinh(X)\n         SPACE 2\n*--------------------------------------------------------------------*\n*                                                                    *\n*   POWER : CALCULATE POWER                                          *\n*                                                                    *\n*   Power(X,P) - compute X**P = exp(P * ln(X))                       *\n*                                                                    *\n*--------------------------------------------------------------------*\n         SPACE 1\nDRXPOWER @rxentry type=EP,base=DRXMATH\n         MVC   Number_of_arg,=H'2'   Have 2 arguments\n         bas   R14,Get_1st_arg       check arguments\n         LD    F0,ARGVALUE           get 1st argument -- X\n         LTDR  F0,F0                 check\n         BZ    DRXPZERO              go here if 0\n         BM    ERRARGS               error if negative\n         STD   F0,ARGVSAVE           save 1st argument\n         MVC   ARGOVRSV,ARGOVRLY     save arg 1 overlay\n         BAS   R14,Get_2nd_arg       obtain 2nd argument - P\n         LD    F0,ARGVALUE           get 2nd argument  -- P\n         LTDR  F2,F0                 check\n         BZ    DRXPONE               if 0 then result must be 1\n         LD    F0,ARGVSAVE           restore X (1st argument)\n         STD   F2,ARGVSAVE           save p (2nd argument)\n         BAS   R14,LN                calculate Ln(X)\n         STD   F0,argrsult           save the result\n         L     R15,ARGOVRSV          get the original overflow\n         LTR   R15,R15               in case of there is\n         BZ    DRXPWEXP              skip if none\n         BAS   R14,FLOAT             if so, convert to fpoint\n         MD    F0,#ln10              multiply to Ln(10)\n         AD    F0,argrsult           :Ln(X * 1Enn) = Ln(X) + NN*Ln 10\nDRXPWEXP EQU   *\n         MD    F0,ARGVSAVE           calculate P * Ln(X)\n         STD   F0,ARGVALUE           save the result\n         BAS   R14,EXPON             now, compute exp(P * Ln(X))\nDRXPRTRN EQU   *\n         STD   F0,ARGRSULT           save the result\n         b     PRINT                 Final routine address\n         BR    R15                   Go there\nDRXPZERO EQU   *\n         LD    F0,=D'0'              zerro result\n         B     DRXPRTRN              return\nDRXPONE  EQU   *\n         LD    F0,#one               one result\n         B     DRXPRTRN              return\n         LTORG ,\n         SPACE 2\n*--------------------------------------------------------------------*\n*                                                                    *\n*  ATAN   : CALCULATE ARCUS TANGEN FUNCTION                          *\n*                                                                    *\n*   Atan(X)     - calculate arctan x, where                          *\n*                                 3    5              n-1  2n-1      *\n*                      -1        z    z           (-1)    z          *\n*                   tan  z = z - -- + -- -  ... + ------------ + ... *\n*                                3    5              2n - 1          *\n*                                                                    *\n*--------------------------------------------------------------------*\n         SPACE 1\nDRXATAN  @rxentry type=EP,base=DRXMATH\n         MVC   Number_of_arg,=H'1'   Have 1 argument\n         bas   R14,Get_1st_arg       check arguments\n         SDR   F0,F0                 clear\n         LD    F2,ARGVALUE           get argument\n         LD    F4,#one               subscript\nATANLOOP EQU   *\n         STD   F0,ARGRSULT           save\n         ADR   F0,F2\n         MD    F2,ARGVALUE\n         MD    F2,ARGVALUE           multiplied by X*X\n         AD    F4,#one               add 1 to get next fact term\n         DDR   F2,F4\n         AD    F4,#one               +1 again to get next fact term\n         DDR   F2,F4\n         LCDR  F2,F2                 change sign\n         CD    F0,ARGRSULT           is it any difference ?\n         BNE   ATANLOOP              loop\n         B     PRINT                 Final routine address\n         LTORG ,\n         SPACE 2\n*--------------------------------------------------------------------*\n*                                                                    *\n*   LN   : CALCULATE NATURAL LOGARITHM                               *\n*                                                                    *\n*   - Perform Ln(X) based on Ln(1+z) series where abs(Z) < 1         *\n*                                                                    *\n*--------------------------------------------------------------------*\n         SPACE 1\nDRXLN    @rxentry type=EP,base=DRXMATH\n         OI    Check_arg_flag,Arg_is_positive\n         bas   R14,Calc_ln         calculate ln\n         b     print\n         LTORG ,\n         SPACE 2\n*--------------------------------------------------------------------*\n*                                                                    *\n*   LOG   : CALCULATE DECIMAL LOGARITHM                              *\n*                                                                    *\n*   - Perform Ln(X) based on Ln(1+z) series                          *\n*   - Calculate Log(X) = Ln(X) / Ln(10)                              *\n*                                                                    *\n*--------------------------------------------------------------------*\n         SPACE 1\nDRXLOG   @rxentry type=EP,base=DRXMATH\n         OI    Check_arg_flag,Arg_is_positive\n         bas   R14,Calc_ln     calculate ln\n         LD    F0,ARGRSULT     restore\n         LD    F2,#ln10        ln(10)\n         DDR   F0,F2           calculate Ln(X)/Ln(10)\n         STD   F0,ARGRSULT     save the result\n         LA    R15,0           Set good return code\n         B     PRINT           Complete EVALBLOK & return\n         LTORG ,\n         SPACE 2\n*--------------------------------------------------------------------*\n*                                                                    *\n*   EXP   : CALCULATE NATURAL EXPONENTIAL                            *\n*                                                                    *\n*   Exp(X)    - compute e**X                                         *\n*   Absolute Floating point number range is .5E-78 to .7E+76         *\n*                                                                    *\n*   z  must be    -164.xxxx <= Z < 164.yyyy                          *\n*                                                                    *\n*    Input :  may be in form of X * 1Ennn (normally nnn = 0)         *\n*             where X in F0 and nnn an ARGOVRLY field                *\n*                                                                    *\n*             in this case, we should calculate exp(X * 10~Z),       *\n*             = (exp(X))~(10~Z)                                      *\n*                                                                    *\n*    References -                                                    *\n*                                                                    *\n*    Exp(A + B) = exp(A) * exp(B)                                    *\n*         ___         ___                                            *\n*    Exp( )   X  ) =  | | exp(X )                                    *\n*         ---  i               i                                     *\n*                                                                    *\n*--------------------------------------------------------------------*\n         SPACE 1\nDRXEXP   @rxentry type=EP,base=DRXMATH\n         MVC   Number_of_arg,=H'1'   Have 1 argument\n         bas   R14,Get_1st_arg       check arguments\nDRXEXPGO EQU   *\n         LD    F0,ARGVALUE           get argument\n         BAS   R14,EXPON             calculate exp(X)\n         STD   F0,ARGRSULT           hold the X fraction\n         B     PRINT                 finish\n         LTORG ,\n         SPACE 2\n*--------------------------------------------------------------------*\n*                                                                    *\n*   FACT : CALCULATE FACTORIAL                                       *\n*                                                                    *\n*       Fact(X)    - compute X!                                      *\n*                                                                    *\n*--------------------------------------------------------------------*\n         SPACE 1\nDRXFACT  @rxentry type=EP,base=DRXMATH\n         MVC   function_address,=A(FACT)  assign FACT function\n         OI    Check_arg_flag,Arg_is_integer+Arg_is_positive\n         B     FUNCEXE                    perform Fact(X)\n         SPACE 2\n*--------------------------------------------------------------------*\n*                                                                    *\n*   COMB : CALCULATE COMBINATION FACTOR                              *\n*                                                                    *\n*       Comb(X,Y)  - compute X! / (Y! * (X-Y)!)                      *\n*                                                                    *\n*--------------------------------------------------------------------*\n         SPACE 1\nDRXCOMB  @rxentry type=EP,base=DRXMATH\n         MVC   Number_of_arg,=H'2'  Have 2 arguments\n         OI    Check_arg_flag,Arg_is_integer+Arg_is_positive\n         bas   R14,Get_1st_arg      check arguments\n         LD    F0,ARGVALUE          get 1st argument\n         LTDR  F0,F0                check\n         BZ    DRXCRTRN             go here if 0\n         BO    DRXCRTRN             go here if 1\n         BM    ERRARGS              error if negative\n         STD   F0,ARGVSAVE          save 1st argument   -- X\n         MVC   ARGOVRSV,ARGOVRLY    save overflowed factor\n         BAS   R14,Get_2nd_arg      obtain 2nd argument\n         LD    F2,ARGVALUE          get 2nd argument -   Y\n         LD    F0,ARGVSAVE          restore X (1st argument)\n         LTDR  F6,F2                copy Y and check\n         BZ    DRXCZERO             go here if 0\n         BO    DRXCRTRN             go here if 1\n         BM    ERRARGS              error if negative\n         SDR   F0,F6                X - Y\n         LTDR  F0,F0                check if negative\n         BM    ERRARGS              error if negative\n         STD   F0,ARGVHOLD          save X-Y\n         L     R2,ARGOVRSV          get saved overflowed\n         MVC   ARGOVRSV,ARGOVRLY    save overflowed factor\n         ST    R2,ARGOVRLY          swap\n         LD    F0,ARGVSAVE          restore X (1st argument)\n         BAS   R14,FACT             calculate Fact(X)\n         LD    F2,ARGVALUE          2nd argument\n         MVC   ARGEXPSV,ARGEXPAN    save expansion factor\n         XC    ARGEXPAN,ARGEXPAN    CLEAR\n         MVC   ARGOVRLY,ARGOVRSV    restore overflowed factor\n         STD   F0,ARGVSAVE          save X! value\n         LDR   F0,F2                copy Y\n         BAS   R14,FACT             calculate Fact(Y)\n         LDR   F2,F0                result of Y!\n         LD    F0,ARGVSAVE          value of X!\n         DDR   F0,F2                value of X! / Y!\n         STD   F0,ARGVSAVE          save it\n         L     R2,ARGEXPSV          restore exp factor of X\n         S     R2,ARGEXPAN          reduced by exp factor of Y\n         ST    R2,ARGEXPSV          save\n         XC    ARGEXPAN,ARGEXPAN    clear\n         LD    F0,ARGVHOLD          X-Y\n         BAS   R14,FACT             calculate Fact(X-Y)\n         LDR   F2,F0                result of (X-Y)!\n         LD    F0,ARGVSAVE          value of X! /Y!\n         DDR   F0,F2                value of (X! /Y!) / (x-y)!\n         STD   F0,ARGRSULT          save the final result\n         L     R2,ARGEXPSV          restore exp factor of X\n         S     R2,ARGEXPAN          reduced by exp factor of Y\n         ST    R2,ARGEXPAN          save\nDRXCRTRN EQU   *\n         STD   F0,ARGRSULT          save the result\n         LA    R15,0                Set good return code\n         B     PRINT                Complete EVALBLOK & return\nDRXCZERO EQU   *\n         LD    F0,#one              zerro result\n         B     DRXCRTRN             return\n         SPACE 2\n*--------------------------------------------------------------------*\n*                                                                    *\n*   PERM : CALCULATE PERMUTATION FACTOR                              *\n*                                                                    *\n*       Perm(X,Y)  - compute X! / (X-Y)!                             *\n*                                                                    *\n*--------------------------------------------------------------------*\n         SPACE 1\nDRXPERM  @rxentry type=EP,base=DRXMATH\n         MVC   Number_of_arg,=H'2'    Have 2 arguments\n         OI    Check_arg_flag,Arg_is_integer+Arg_is_positive\n         bas   R14,Get_1st_arg        check arguments\n         LD    F0,ARGVALUE            get 1st argument\n         LTDR  F0,F0                  check\n         BZ    DRXPERMX               go here if 0\n         BO    DRXPERMX               go here if 0\n         BM    ERRARGS                error if negative\n         STD   F0,ARGVSAVE            save 1st argument   -- X\n         MVC   ARGOVRSV,ARGOVRLY      save overflowed factor\n         BAS   R14,Get_2nd_arg        obtain 2nd argument\n         LD    F0,ARGVALUE            get 2nd argument\n         LTDR  F0,F0                  X = val arg 1\n         BZ    DRXPERMO               go here if 0\n         BO    DRXPERMX               go here if 1\n         BM    ERRARGS                error if negative\n         LD    F2,ARGVSAVE            restore 1st argument\n         SDR   F2,F0                  X - Y\n         LTDR  F0,F2                  x-y must not < 0\n         BM    ERRARGS                error if negative\n*        std   f0,tempvar             hold it\n         L     R2,ARGOVRSV            get saved overflowed\n         MVC   ARGOVRSV,ARGOVRLY      save overflowed factor\n         ST    R2,ARGOVRLY            swap\n         BAS   R14,FACT               calculate Fact(X-Y)\n         LD    F2,ARGVSAVE            get X\n         MVC   ARGEXPSV,ARGEXPAN      save expansion factor\n         XC    ARGEXPAN,ARGEXPAN      clear\n         MVC   ARGOVRLY,ARGOVRSV      restore overflowed factor\n         STD   F0,ARGVSAVE            save (X-Y)! value\n         LDR   F0,F2                  get X\n         BAS   R14,FACT               calculate Fact(X)\n         DD    F0,ARGVSAVE            compute X! / (X-Y)!\n         L     R2,ARGEXPAN            get exp factor of X\n         S     R2,ARGEXPSV            reduced by exp factor of Y\n         ST    R2,ARGEXPAN            save\nDRXPERMX EQU   *\n         STD   F0,ARGRSULT            save the result\n         LA    R15,0                  Set good return code\n         B     PRINT                  Complete EVALBLOK & return\nDRXPERMO EQU   *\n         LD    F0,#one                zerro quit\n         B     DRXPERMX               return\n         SPACE 2\n*--------------------------------------------------------------------*\n*                                                                    *\n*   SQRT : CALCULATE SQUARE ROOT                                     *\n*                                                                    *\n*   Sqrt(X)    - compute X**0.5                                      *\n*                                                                    *\n*--------------------------------------------------------------------*\n         SPACE 1\nDRXSQRT  @rxentry type=EP,base=DRXMATH\n         MVC   function_address,=A(SQROOT)  assign SQROOT function\n         OI    Check_arg_flag,Arg_is_positive\n         B     FUNCEXE                      perform Sqrt(X)\n   EJECT\n*--------------------------------------------------------------------*\n*                                                                    *\n*   FUNCTION EXECUTION                                               *\n*                                                                    *\n*   R7   - Address of Function routine                               *\n*--------------------------------------------------------------------*\n         SPACE 1\n         DS    0D\nFUNCEXE  EQU   *\n         mvc   traceid,=cl8'FUNCEXE' set trace id\n         aif   (not &trace).trace02\n         icm   r0,b'1111',=x'22222222'\n.trace02 anop\n         MVC   Number_of_arg,=H'1'   Have 1 argument\n         BAS   R14,Get_1st_arg       check argument\n         aif   (not &trace).trace02a\n         WTO   'DRX0012I Begin to execute function (FUNCEXE)..',       +\n               routcde=(1,10)\n.trace02a anop\n         LD    F0,ARGVALUE          get argument\n         L     R15,function_address get function routine addrees\n         BASR  R14,R15              perform function routine\n         STD   F0,ARGRSULT          save the result\n         LA    R15,0                Set good return code\n         B     PRINT                Complete EVALBLOK & return\n         LTORG ,\n         SPACE 2\n*--------------------------------------------------------------------*\n*                                                                    *\n*   FUNCTION PER FUNCTION DIVISION WITH THE SAME VALUE               *\n*                                                                    *\n*   F0  <----  Func1(X) / Func2(X)                                   *\n*    R7   - Adress of Func1 routine                                  *\n*    R8   - Adress of Func2 routine                                  *\n*--------------------------------------------------------------------*\n         SPACE 1\n         DS    0D\nFUNCDIV  EQU   *\n         mvc   traceid,=cl8'FUNCDIV' set trace id\n         aif   (not &trace).trace03\n         icm   r0,b'1111',=x'33333333'\n.trace03 anop\n         MVC   Number_of_arg,=H'1'   Have 1 argument\n         BAS   R14,Get_1st_arg       check argument\n         aif   (not &trace).trace03a\n         WTO   'DRX0012I Begin to execute function 1 (FUNCDIV)..',     +\n               routcde=(1,10)\n.trace03a anop\n         LD    F0,ARGVALUE          get argument\n         L     R15,function2_address get function routine addrees\n         BASR  R14,R15              perform FUNCTION 2 computation\n         LTDR  F0,F0                check the result\n         BZ    ERRARGS              error if 0\n         STD   F0,ARGRSULT          save\n         LD    F0,ARGVALUE          get argument\n         MVC   ARGEXPSV,ARGEXPAN    save expansion factor\n         XC    ARGEXPAN,ARGEXPAN    clear\n         aif   (not &trace).trace03b\n         WTO   'DRX0012I Begin to execute function 2 (FUNCDIV)..',     +\n               routcde=(1,10)\n.trace03b anop\n         L     R15,function_address get function routine addrees\n         BASR  R14,R15              perform FUNCTION 1 computation\n         L     R15,ARGEXPAN         expansion factor\n         S     R15,ARGEXPSV         expansion factor division\n         ST    R15,ARGEXPAN\n         DD    F0,ARGRSULT          divided by FUNCTION 2\n         STD   F0,ARGRSULT          save result\n         LA    R15,0                Set good return code\n         B     PRINT                Complete EVALBLOK & return\n         LTORG ,\n         SPACE 2\n*--------------------------------------------------------------------*\n*                                                                    *\n*   FUNCTION INVERSION                                               *\n*                                                                    *\n*   F0  <----  1 / Func(X)                                           *\n*   R7   - Address of designated function routine                    *\n*--------------------------------------------------------------------*\n         SPACE 1\n         DS    0D\nFUNCINV  EQU   *\n         mvc   traceid,=cl8'FUNCINV' set trace id\n         aif   (not &trace).trace04\n         icm   r0,b'1111',=x'44444444'\n.trace04 anop\n         MVC   Number_of_arg,=H'1'   Have 1 argument\n         BAS   R14,Get_1st_arg       check argument\n         aif   (not &trace).trace04a\n         WTO   'DRX0012I Begin to execute function (FUNCINV)..',       +\n               routcde=(1,10)\n.trace04a anop\n         LD    F0,ARGVALUE           get argument\n         L     R15,function_address  get function routine addrees\n         BASR  R14,R15               perform FUNCTION\n         LTDR  F2,F0                 check\n         BZ    ERRARGS               error if 0\n         LD    F0,=D'1.0'\n         DDR   F0,F2                 calculate 1/Func(X)\n         STD   F0,ARGRSULT           save the result\n         LA    R15,0                 Set good return code\n         B     PRINT                 Complete EVALBLOK & return\n         LTORG ,\n         Space 1\n        EJECT\n*--------------------------------------------------------------*\n*                                                              *\n*   BASIC COMPUTATION SERVICE COLLECTION                       *\n*                                                              *\n*   1.   EXPONENTIAL series                                    *\n*   2.   SINE series                                           *\n*   3.   COSINE series                                         *\n*   4.   NATURAL LOGARITHM series                              *\n*   5.   FACTORIAL algorithm                                   *\n*   6.   SQUARE ROOT algorithm                                 *\n*   7.   HYPERBOLIC SINE computation                           *\n*   8.   HYPERBOLIC COSINE computation                         *\n*                                                              *\n*                                                              *\n*   Input    F0                                                *\n*   Output   F0                                                *\n*   Return ptr   R14                                           *\n*                                                              *\n*--------------------------------------------------------------*\n         ds   0d\n         space 1\n*--------------------------------------------------------------------*\n*                                                                    *\n*   Calculate ln(X)                                                  *\n*                                                                    *\n*   To reduce computing time of Ln(1+z) algorithm, here the          *\n*   value of X is converted to such Y * 1E+nn, where abs(Y) < 1      *\n*   then calculate Ln(Y) + nn * Ln(10).                              *\n*--------------------------------------------------------------------*\n         space\nCalc_ln  equ   *\n         stm   R14,R1,rexx_sysregs_save Save system work regs\n         MVC   Number_of_arg,=H'1'  Have 1 argument\n         bas   R14,Get_1st_arg      check arguments\n         LD    F0,ARGVALUE          get argument\n         LTDR  F0,F0                check\n         BNP   ERRARGS              error if not positive\n         BAS   R14,CALCEXP          separate the exponent\n         MD    F0,=D'10'            shift 1 digit to left\n         LR    R15,R0               get exponent\n         BCTR  R15,0                reduce 1 for compensation\n         A     R15,ARGEXPAN         correct .....\n         ST    R15,ARGEXPAN         .. the expansion factor\n         BAS   R14,LN               perform LN routine\n         STD   F0,ARGRSULT          save the result\n         L     R15,ARGOVRLY         get the original overflow\n         A     R15,ARGEXPAN         get the calculation overflow\n         ST    R15,ARGEXPSV         save it\n         XC    ARGEXPAN,ARGEXPAN    clear\n         LTR   R15,R15              check\n         BZ    Calc_ln_final        exit if nothing\n         MVC   ARGUNNOR,#unnormal   calculate power overflow\n         ST    R15,ARGUNLOW         hold value\n         LD    F0,ARGUNNOR          attempt to ...\n         MD    F0,#ln10             calculate z * Ln(10)\n         LTR   R15,R15              test the sign\n         BNM   Calc_ln_done         just quit if positive\n         LCDR  F0,F0                change the sign\nCalc_ln_done EQU *\n         AD    F0,ARGRSULT          correct the result\n         STD   F0,ARGRSULT          save the final result\nCalc_ln_final equ *\n         lm    R14,R1,rexx_sysregs_save restore system work regs\n         LA    R15,0\n         br    r14                  return\n         SPACE 2\n*--------------------------------------------------------------------*\n*                                                                    *\n*   Sin(X)     - calculate sin x, where                              *\n*                                                                    *\n*                                3    5              n-1  2n-1       *\n*                               z    z           (-1)    z           *\n*                   sin z = z - -- + -- -  ... + ------------ + ...  *\n*                               3!   5!            (2n - 1)!         *\n*                                                                    *\n*--------------------------------------------------------------------*\n   SPACE 2\n         DS    0D\nSINE     EQU   *\n         mvc   traceid,=cl8'SINE'   set trace id\n         CLI   Optional_arg,Arg_in_radian is arg in radian?\n         BE    SINRAD               Yes, skip conversion\n         ST    R14,ARGINADR\n         BAS   R14,RADIAN           convert to radian\n         L     R14,ARGINADR\nSINRAD   EQU   *\n         LTDR  F0,F0                so its mean the remainder\n         BZR   R14                  return if 0\n         LDR   F2,F0                get argument\n         LDR   F6,F0                get argument\n         MDR   F6,F2                calculate X**2\n         SDR   F0,F0                clear\n         LD    F4,#one              subscript\nSINLOOP  EQU   *\n         STD   F0,ARGTEMP           save T(i)\n         ADR   F0,F2                T(i)  <--- T(i-1) + S(i-1)\n         CD    F0,ARGTEMP           is it any difference ?\n         BE    SINEQU               no, return\n         MDR   F2,F6                S(i)  <--- S(i-1) * Z\n         AD    F4,#one              d <-- d + 1,  next fact term\n         DDR   F2,F4                enter menchanism\n         AD    F4,#one               .. of ....\n         DDR   F2,F4                S(i) <--- -1 * S(i) / (d*(d+1))\n         LCDR  F2,F2                change sign\n         B     SINLOOP              loop\nSINEQU   EQU   *\n         BR    R14                  and return\n         LTORG ,\n         SPACE 2\n*--------------------------------------------------------------------*\n*                                                                    *\n*   Cos(X)     - calculate cos x, where                              *\n*                                                                    *\n*                                2    4              n-1  2n-2       *\n*                               z    z           (-1)    z           *\n*                   cos z = 1 - -- + -- -  ... + ------------ + ...  *\n*                               2!   4!            (2n - 2)!         *\n*                                                                    *\n*--------------------------------------------------------------------*\n   SPACE 2\n         DS    0D\nCOSINE   EQU   *\n         mvc   traceid,=cl8'COSINE'    set trace id\n         CLI   Optional_arg,Arg_in_radian is arg in radian?\n         BE    COSRAD               Yes, skip conversion\n         ST    R14,ARGINADR\n         BAS   R14,RADIAN           convert to radian\n         L     R14,ARGINADR\nCOSRAD   EQU   *\n         LDR   F6,F0                get argument\n         MDR   F6,F0                obtain X**2\n         LD    F0,#one              initialize 1st sequence\n         LDR   F2,F0                initialize the sequence\n         SDR   F4,F4                initialize divisor\nCOSLOOP   EQU   *\n         STD   F0,ARGTEMP           save\n         MDR   F2,F6                multiplied by X**2\n         AD    F4,#one              add 1 to get next fact term\n         DDR   F2,F4\n         AD    F4,#one              +1 again to get next fact term\n         DDR   F2,F4\n         LCDR  F2,F2                change sign\n         ADR   F0,F2                add next sequence\n         CD    F0,ARGTEMP           is it any difference ?\n         BNE   COSLOOP              loop if so\n         BR    R14                  and return\n         LTORG ,\n         SPACE 2\n*--------------------------------------------------------------------*\n*                                                                    *\n*   Ln(X)      - compute Ln x, where                                 *\n*                                                                    *\n*                                  2    3              n-1 n         *\n*                                 z    z           (-1)   z          *\n*                   ln(1+z) = z - -- + -- -  ... + ---------         *\n*                                 2    3               n             *\n*                                                                    *\n*                   where abs(z) < 1                                 *\n*                                                                    *\n*--------------------------------------------------------------------*\n         DS    0D\n         SPACE 1\nLN       EQU   *\n         mvc   traceid,=cl8'LN'     set trace id\n         LTDR  F2,F0             duplicate and check\n         BNP   ERRARGS           error if not positive\n         BZ    ERRARGS           error if 0\n         LA    R3,1              initialize\n         ST    R14,ARGSAV14      save return address\n         std   f0,tempvar        save it for awhile\nLNROOT   EQU   *\n         CD    F0,=D'2.0'        is it > 2.0 ?\n         BL    LNCALC            No, go perform it\n         BAS   R14,SQROOT        calculate square root\n         LA    R3,1(R3)          incremented index\n         B     LNROOT            loop\nLNCALC   EQU   *\n         SD    F0,#one           reduce 1\n         LDR   F6,F0             save as sequence factor\n         LD    F2,#one           Y = 1\n         SDR   F4,F4             i = 0\n         SDR   F0,F0             S(0) = 0\nLNLOOP   EQU   *\n         STD   F0,ARGTEMP        save T(i)\n         MDR   F2,F6             Y  <--- Y * Z\n         AD    F4,#one           i  <--- i + 1\n         LDR   F0,F2\n         DDR   F0,F4             S(i) <--- Y/i\n         LCDR  F2,F2             Y <--- -1 * Y\n         AD    F0,ARGTEMP        T(i) <--- T(i-1) + (-1)~1 * S(i)\n         CD    F0,ARGTEMP        any differences ?\n         BNE   LNLOOP\nLNCORR   EQU   *\n         ld    f6,tempvar        restore saved value\n*        LPDR  F6,F6\n         CD    F6,#one           check against 1\n         BNL   LNPOSTVE          go there if GE\n         LNDR  F0,F0             change the sign to negative\n         B     LNREADY           and proceed\nLNPOSTVE EQU   *\n         LPDR  F0,F0             change the sign to positive\nLNREADY  EQU   *\n         LPDR  F6,F0             get absolute value\n         CD    F6,=D'1E75'       is it overflow ?\n         BL    LNCORR1           no, proceed\n         L     R15,ARGEXPAN      get expansion factor\n         LA    R15,75(R15)       expand it\n         ST    R15,ARGEXPAN      and save it\n         DD    F0,=D'1E75'       shift it\nLNCORR1   EQU   *\n         BCT   R3,LNFACT         factorize\n         L     R14,ARGSAV14      restore return address\n         BR    R14               return\nLNFACT   EQU   *\n         MD    F0,=D'2.0'        correct to original value\n         B     LNCORR            loop until perfict\n         LTORG ,\n         SPACE 2\n*--------------------------------------------------------------*\n*                                                              *\n*  FACTORIAL Calculation                                       *\n*                                                              *\n*     Fact(X)  =  1 * 2 * .... * X   where X integer           *\n*                                                              *\n*--------------------------------------------------------------*\n         DS    0D\n   SPACE 2\nFACT     EQU   *\n         mvc   traceid,=cl8'FACT'   set trace id\n         LTDR  F2,F0            check\n         BM    ERRARGS          error if < 0\n         BOR   R14              just return if 1\n         BNZ   FACTGO           proccess if > 1\n         LD    F0,#one          set to 1 if 0\n         BR    R14              .. return\nFACTGO   EQU   *\n         XC    ARGCORRC,ARGCORRC   prepare correction factor\n         AW    F2,#unnormal     unnormalized\n         LCDR  F2,F2            change the sign\n         ADR   F2,F0            added to origimal one\n         LTDR  F2,F2            check the delta\n         BNZ   ERRARGS          error if not integer\n         LDR   F2,F0            copy input\nFACTLOOP EQU   *\n         SD    F2,#one          subtract 1\n         LTDR  F2,F2            check the X-1\n         BZ    FACTEND          end if 0\n         MDR   F0,F2            multiply X * (X-1)\n         STD   F0,ARGEXLOG      it is a black box\n         B     FACTLOOP         loop\nFACTEND  EQU   *\n         L     R0,ARGCORRC      get correction factor if any\n         A     R0,ARGEXPAN      suppose overflowed\n         ST    R0,ARGEXPAN      record the overflow\n         BR    R14              else, return\n         LTORG ,\n         SPACE 2\n*-----------------------------------------------------------*\n*                                                           *\n*  SQUARE ROOT Calculation                                  *\n*                                                           *\n*  Formulae :                                               *\n*               X    = ( X  + A/X ) / 2                     *\n*                n+1      n      n                          *\n*                                                           *\n*-----------------------------------------------------------*\n         DS    0D\n         SPACE 2\nSQROOT   EQU   *\n         mvc   traceid,=cl8'SQROOT' set trace id\n         LTDR  F0,F0             .. CHECK\n         BM    ERRARGS           error if negative\n         BZR   R14               return if 0\n         LD    F4,#one           initiate F4\n         CD    F0,#one           categories\n         BH    SQRHIGH           high, handle it\nSQRLOW   EQU   *\n         CD    F0,=D'1E-2'       is it < 1/100 ?\n         BH    SQREXEC           no, proceed\n         DD    F0,=D'1E-2'       yes, multiplied by 100\n         DD    F4,=D'10'         save root of 1/100\n         B     SQRLOW            loop to recheck\nSQRHIGH  EQU   *\n         CD    F0,=D'1E2'        is it > 100 ?\n         BL    SQREXEC           no, proceed\n         DD    F0,=D'1E2'        yes, divided by 100\n         MD    F4,=D'10'         save the root of 100\n         B     SQRHIGH           loop to recheck\nSQREXEC  EQU   *\n         LDR   F6,F0             get input\n         LDR   F2,F0             .. CHECK\n         AD    F2,#one\n         HDR   F2,F2             halves\nSQLOOP   EQU   *\n         LDR   F0,F2             save previous term value\n         LDR   F2,F6             get input\n         DDR   F2,F0             divide by prev term\n         ADR   F2,F0             added by prev term value\n         HDR   F2,F2             halves\n         CDR   F2,F0             any differences ?\n         BL    SQLOOP            yes, loop\n         MDR   F0,F4             final\n         BR    R14               else, return\n         LTORG ,\n         SPACE 2\n*--------------------------------------------------------------*\n*                                                              *\n*    Sinh(X)   Calculation                                     *\n*                                                              *\n*   Sinh(X) = (exp(X) - exp(-X))/2                             *\n*                                                              *\n*--------------------------------------------------------------*\n         DS    0D\n   SPACE 2\nSINH     EQU   *\n         mvc   traceid,=cl8'SINH'  set trace id\n         ST    R14,ARGSAV14        save return address\n         CLI   Optional_arg,Arg_in_radian is arg in radian?\n         BE    SINHRAD             Yes, skip conversion\n         BAS   R14,RADIAN          convert to radian\nSINHRAD  EQU   *\n         STD   F0,ARGVSAVE         save argument\n         BAS   R14,EXPON           calculate Exp(X)\n         STD   F0,ARGVHOLD         hold the value\n         LD    F0,ARGVSAVE         get argument\n         LCDR  F0,F0               change sign\n         BAS   R14,EXPON           calculate Exp(-X)\n         LD    F2,ARGVHOLD         restore the held value\n         SDR   F2,F0               calculate exp(X) - exp(-X)\n         HDR   F0,F2               then halve it\n         L     R14,ARGSAV14        restore return address\n         BR    R14                 else, turn\n         LTORG ,\n         SPACE 2\n*--------------------------------------------------------------*\n*                                                              *\n*    Cosh(X)   Calculation                                     *\n*                                                              *\n*   Cosh(X) = (exp(X) + exp(-X))/2                             *\n*                                                              *\n*--------------------------------------------------------------*\n         DS    0D\n   SPACE 2\nCOSH     EQU   *\n         mvc   traceid,=cl8'COSH'  set trace id\n         ST    R14,ARGSAV14        save return address\n         CLI   Optional_arg,Arg_in_radian is arg in radian?\n         BE    COSHRAD             Yes, skip conversion\n         BAS   R14,RADIAN          convert to radian\nCOSHRAD  EQU   *\n         STD   F0,ARGVSAVE         save argument\n         BAS   R14,EXPON           calculate Exp(X)\n         STD   F0,ARGVHOLD         hold the value\n         LD    F0,ARGVSAVE         get argument\n         LCDR  F0,F0               change sign\n         BAS   R14,EXPON           calculate Exp(-X)\n         AD    F2,ARGVHOLD         calculate exp(X) + exp(-X)\n         HDR   F0,F0               then halve it\n         L     R14,ARGSAV14        restore return address\n         BR    R14                 else, turn\n         LTORG ,\n         SPACE 2\n*--------------------------------------------------------------------*\n*                           x                                        *\n*   Exp(X)     - calculate e  , where                                *\n*                                                                    *\n*                                2    3            n                 *\n*                   z           z    z            z                  *\n*                  e  = 1 + z + -- + -- +  ... + ---  + ...          *\n*                               2!   3!           n!                 *\n*                                                                    *\n*   Absolute Floating point number range is .5E-78 to .7E+76         *\n*   so,                                                              *\n*   z must be    -180.2948 <= Z < 174.6398                           *\n*                                                                    *\n*--------------------------------------------------------------------*\n         DS    0D\nEXPON    EQU   *\n         mvc   traceid,=cl8'EXPON'  set trace id\n         LA    R15,0              initialize R15, suppose t = 0\n         LPDR  F2,F0              abs(X)\n         BNZ   EXPCMPUT           compute if X not 0\n         LD    F0,#one            exp(0) = 1\n         BR    R14                then return\nEXPCMPUT EQU   *\n         CD    F2,=D'1E75'        is abs(X) > 1.0E+75 ?\n         BH    ERRARGS            error if so\n         CD    F2,=D'1E-75'       is abs(X) < 1.0E-75 ?\n         BL    ERRARGS            error if so\n         CD    F2,#one            is abs(X) > 1 ?\n         BNH   EXPNORM            no, normal way, Z = X\n         stm   R14,R1,work_sysregs_save Save system work regs\n         BAS   R14,CALCEXP        factorize into Z * 1.0Et\n         lm    R14,R15,work_sysregs_save restore system work regs\n         STD   F6,ARGTEMP         save exponentfactor 1.0Et\n         LR    R15,R0             get exponen, t\n         LM    R0,R1,ARGTEMP      save1.0Et on R0 and R1\nEXPNORM  EQU   *\n         XC    ARGCORRC,ARGCORRC  always prepare correction factor\n         LDR   F2,F0              S(1) = Z\n         LDR   F6,F0              save T(1)\n         SDR   F4,F4              i = 0\n         LD    F0,#one            T(0) = 1\nEXPLOOP  EQU   *\n         STD   F0,ARGTEMP         save T(i)\n         AD    F4,#one            i <-- i + 1\n         DDR   F2,F4              m(i) <--- m(i) / i\n         ADR   F0,F2              s(i) <--- s(i) + m(i)\n         CD    F0,ARGTEMP         is it any difference ?\n         BE    EXPLEAVE           no, leave the loop\n         MDR   F2,F6              m(i+1) <--- m(i) * Z\n         B     EXPLOOP            loop\nEXPLEAVE EQU   *\n         LTDR  F2,F0              check if 0\n         BZR   R14                return if exp(Z) = 0\n         STM   R0,R1,ARGTEMP\n         LD    F6,ARGTEMP         check exponentof argument\n         LTR   R15,R15            return if t = 0\n         BZR   R14                go ahead if it normal\n         BNM   EXPCORR\n         LD    F6,#one            inverse it\n         DD    F6,ARGTEMP\n         LD    F2,#one            inverse it\n         DDR   F2,F0\nEXPCORR   EQU   *\n         AW    F6,#unnormal       unnormalize\n         STD   F6,ARGUNNOR\n         LD    F0,#one\n         L     R1,ARGUNLOW        set loop index\nEXPFINAL EQU   *\n         MDR   F0,F2              powered\n         STD   F0,ARGEXLOG        save for blackbox\n         BCT   R1,EXPFINAL        loop\n         L     R0,ARGCORRC        powered\n         A     R0,ARGEXPAN        suppose overflowed\n         ST    R0,ARGEXPAN        record the overflow\n         BR    R14                return\n         LTORG ,\n         SPACE 2\n*--------------------------------------------------------------------*\n* RADIAN COMPUTATION METHOD                                          *\n*                                                                    *\n*   Z = Mod(X / 360) * 2 * pi                                        *\n*                                                                    *\n*                                                                    *\n*--------------------------------------------------------------------*\n         SPACE 2\n         DS    0D\nRADIAN   EQU   *\n         mvc   traceid,=cl8'RADIAN'  set trace id\n         LDR   F6,F0               get/save input\n         DD    F6,#360             divided by maximum circle degree\n         AW    F6,#unnormal        unnormalized\n         MD    F6,#360             multiply back\n         LCDR  F6,F6               change the sign\n         ADR   F0,F6               obtain the remainder of X/360\n         MD    F0,#pi              obtain radian value= 2 * X * PI\n         DD    F0,=D'180'\n         lpdr  f0,f0               get absolute value\n         BR    R14                 return\n         LTORG ,\n         SPACE 2\n*--------------------------------------------------------------------*\n*  CONCERT INTEGER INTO FLOATING POINT                               *\n*   Input - Fullword binary in R15                                   *\n*   Output - FPOINT in F0                                            *\n*--------------------------------------------------------------------*\n         DS    0D\n         SPACE 2\nFLOAT    EQU   *\n         mvc   traceid,=cl8'FLOAT'    set trace id\n         MVC   ARGUNNOR(4),#unnormsg  initialize f.point field\n         ST    R15,ARGUNLOW           store as low order unnormalized\n         LD    F0,ARGUNNOR            unnormalized f.point value\n         AD    F0,=D'0'               normalized\n         LTR   R3,R3                  check sign\n         BNMR  R14                    return if not negative\n         LCDR  F0,F0                  else, change sign\n         BR    R14                    return\n         LTORG ,\n         SPACE 2\n*--------------------------------------------------------------------*\n*  exponentcalculation handling                                      *\n*                                                                    *\n*--------------------------------------------------------------------*\n         DS    0D\nCALCEXP  EQU   *\n         mvc   traceid,=cl8'CALCEXP'   set trace id\n*        b     Calculate_Exponent      go to routine address\n         L     R15,=A(Calculate_Exponent) routine address\n         BR    R15                     Jump over there\n         ltorg ,\n         SPACE 2\n*--------------------------------------------------------------------*\n*  Result printing handling                                          *\n*                                                                    *\n*--------------------------------------------------------------------*\n         DS    0D\nPRINT    EQU   *\n         mvc   traceid,=cl8'PRINT'     set trace id\n*        b     Print_result            Go to the Routine address\n         L     R12,=A(Print_result)    Routine address\n         BR    R12                     Jump over there\n         ltorg ,\n         SPACE 2\n*--------------------------------------------------------------------*\n*  Error handling                                                    *\n*   return to the system with RC = 4                                 *\n*--------------------------------------------------------------------*\nERRARGS  EQU   *                Argument(s) are invalid\n         b     Wrong_arg\n*        L     R15,=A(Wrong_arg)\n*        BR    R15\n   EJECT\n   TITLE 'LOCFN: Common get ARGUMENT subroutine'\n*--------------------------------------------------------------*\n* This subroutine obtains an ARGUMENT from ARGLIST             *\n* The assumed input is :                                       *\n*   - R1 : Address of ARGUMENT in ARGLIST                      *\n*   - R14: return address                                      *\n*                                                              *\n* Argument string expected :                                   *\n*   'nnn.mmmmmmmE+ee'                                          *\n*   but sometimes can be ' - nn.mmmmmmmmmE-ee  '               *\n*                                                              *\n* Work (may distroyed)                                         *\n*   R3, R4, and R15                                            *\n*                                                              *\n* The output:                                                  *\n*   - ARGVALUE: argument in floating point form                *\n*   - R1 : point to storage consist of floating point form     *\n*   - R0 : amount of doublewords of storage                    *\n*   - other registers are unchanged.                           *\n*                                                              *\n* If storage is not available, an error message is displayed   *\n* and return is taken to the caller with a non-zero return     *\n* code.                                                        *\n*--------------------------------------------------------------*\n         DS    0D\n         SPACE 2\nGet_1st_arg EQU *\n         mvc   traceid,=cl8'GET1ARG' set trace id\n         using argtable_entry,r1   map argument table entry\n         l     r1,efplarg           access arg list\n         cli   0(r1),x'FF'           end of table ?\n         be    ERRARGS              yes, error\n         l     r15,argtable_argstring_length length of argument\n         l     r2,argtable_argstring_ptr pointer of argument\n         XC    ARGBLOK(ARGAREAL),ARGBLOK nullify\n         MVC   ARGCONST(ARGCONSL),CONSTANT constant collection\n         MVC   ARGUNNOR(4),#unnormal initialize f.point field\n         b     Check_option          check option\nGet_2nd_arg EQU *\n         mvc   traceid,=cl8'GET2ARG' set trace id\n         l     r1,efplarg\n         la    r1,argtable_next\n         cli   0(r1),x'FF'           end of table ?\n         be    ERRARGS              yes, error\n         l     r15,argtable_argstring_length length of argument\n         l     r2,argtable_argstring_ptr pointer of argument\n         b     Get_arg               begin to get argument\nCheck_option   EQU *\n         CLI   Optional_arg_flag,Optional_arg_check  need to check?\n         bne   Get_arg               no, begin to get argument\n         la    r1,argtable_next\n         CLC   Number_of_arg,=H'2'   Have 2 arguments ?\n         bl    Get_option            no, begin to get option\n         la    r1,argtable_next\nGet_option    EQU *\n         cli   0(r1),x'FF'           end of table ?\n         BE    Default_option        Yes, use default option\n         l     r1,argtable_argstring_ptr pointer of argument\n         OI    0(R1),X'40'           Make it uppercase\n         Cli   0(R1),Arg_in_radian   radian?\n         bne   Default_option        No, use default option instead\n         MVI   Optional_arg,Arg_in_radian Yes, set option = radian\n         b     Get_arg               Begin to get argument\nDefault_option EQU *\n         MVI   Optional_arg,Arg_in_degree default option = degree\nGet_arg  EQU *\n*        mvc   traceid,=cl8'GET_ARG' set trace id\n         st    r2,Arg_address        Save current arg address\n         st    r15,Arg_length         and current its length\n         aif   (not &trace).trace05\n         icm   r0,b'1111',=x'55555555'\n.trace05 anop\n         drop  r1\n         ST    R14,ARGSAV14          save linkage pointer\n         stm   R14,R1,work_sysregs_save Save system work regs\n         espie SET,ESPIE_exit,(12,13,15)  Set SLIH exit for pgm\n         lm    R14,R1,work_sysregs_save restore system work regs\n         XR    R4,R4                 clear integer length counter\n         XR    R3,R3                 clear mantissa length counter\nGETSTART EQU   *\n         aif   (not &trace).next1\n         lr    R8,R15\n         mvc   tracetxt(l'tracetxt1),tracetxt1\n         la    r1,tracetxt+l'tracetxt1\n         ex    r1,gettrace\n         la    r15,l'tracetxt1(R15)\n         sth   R15,tracemsg\n         WTO   'DRX0002I Parsing arguments in progress...',            +\n               routcde=(1,10)\n         la    r7,tracemsg\n         mvc   wtolist(wtolistl),tracewtol\n         la    r1,wtolist\n         wto   text=(r7),mf=(E,(r1))\n         lr    R15,R8\n         b     gettrc_ok\ngettrace mvc   tracetxt+l'tracetxt1(*-*),0(r2)\ntracewtol wto  text=,routcde=(1,10),mf=L\ntracetxt1 dc   C'Argument is: '\n          ds   0h\ngettrc_ok equ  *\n.next1   anop\n         lr    r1,r2                 argument address\n         XR    R2,R2                 clear exponentlength counter\nGETloop  EQU   *\n         CLI   0(R1),C' '            is it blank ?\n         BNE   GETINTGR              no, begin\n         LA    R1,1(R1)              next digit\n         BCT   R15,GETloop           loop\n         B     Wrong_arg             else, no argument\nGETINTGR EQU   *\n         MVC   ARGVINIT,=D'-1'       prepare ...\n         CLI   0(R1),C'-'            is it negative sign ?\n         BE    Check_minus_sign      Yes, check whether not allowed\n         MVC   ARGVINIT,#one         prepare ...\n         CLI   0(R1),C'+'            is it positif sign ?\n         BE    GETINSKP              YES, TAKE IT\nGETINTG1 EQU   *\n         CLI   0(R1),C' '            is it blank ?\n         BE    GETINSKP              yes, skip it\n         CLI   0(R1),C'0'            is it the smallest value ?\n         BNE   GETINTOK              NO, DO FURTHER CHECKING\nGETINSKP EQU   *\n         LA    R1,1(R1)              next digit\n         BCT   R15,GETINTG1          loop\n         B     GETFINIS              finish if no more\nCheck_minus_sign equ *\n         TM    Check_arg_flag,Arg_is_positive   Must it positive?\n         BO    Wrong_arg             Yes, wrong arg!\n         b     GETINSKP\nGETINTOK EQU   *\n         LA    R6,8                  maximum 8 digits\n         ST    R1,ARGINADR           save\nGETINNXT EQU   *\n         CLI   0(R1),C' '            is it blank ?\n         BE    GETFINIS              yes, finish\n         CLI   0(R1),C'.'            is it decimal point ?\n         BE    Check_dot_sign        yes, check whether must integer\n         CLI   0(R1),C'E'            is it EXPONential sign ?\n         BE    GETEXPON              yes, take exponential part\n         CLI   0(R1),C'e'            is it EXPONential sign ?\n         BE    GETEXPON              yes, take exponential part\n         CLI   0(R1),C'9'            is it the largest value ?\n         BH    Wrong_arg              > 9, error\n         CLI   0(R1),C'0'            is it the smallest value ?\n         BL    Wrong_arg              < 0, error\nGETINVAL EQU   *\n         LA    R4,1(R4)              count\n         LA    R1,1(R1)              next digit\n         BCT   R6,GETINVSQ\n         ST    R1,ARGFRADR           save\n         LTR   R8,R15\n         BZ    GETFINIS              finish if no more\nGETINOVR EQU   *\n         CLI   0(R1),C' '            is it blank ?\n         BE    GETINOV1              yes, finish\n         CLI   0(R1),C'.'            is it decimal point ?\n         BE    GETINOV2              yes, finish\n         CLI   0(R1),C'E'            is it EXPOential sign ?\n         BE    GETINOV1              yes, finish\n         CLI   0(R1),C'e'            is it EXPOential sign ?\n         BE    GETINOV1              yes, finish\n         LA    R1,1(R1)              next digit\n         L     R6,ARGOVRLY           overlay counter\n         LA    R6,1(R6)              count overlay\n         ST    R6,ARGOVRLY           save counter\n         BCT   R8,GETINOVR\nGETINOV1 EQU   *\n         L     R1,ARGFRADR           restore fraction start address\n         LA    R6,0                  maximum 9 digits\n         B     GETFRNXT              start fraction loop\nGETINOV2 EQU   *\n         MVC   0(1,R1),1(R1)         left shift per byte\n         LA    R1,1(R1)              next digit\n         BCT   R8,GETINOV2           loop\n         BCT   R15,GETINOV1          finish, attempt to exit\n         B     GETFINIS              else, finish\nGETINVSQ EQU   *\n         BCT   R15,GETINNXT          loop\n         B     GETFINIS              else, finish\nCheck_dot_sign equ *\n         TM    Check_arg_flag,Arg_is_integer  Must it integer?\n         BO    Wrong_arg             Yes, wrong arg!\nGETFRACT EQU   *\n         LA    R6,9                  maximum 9 digits\n         LA    R1,1(R1)              next digit\n         ST    R1,ARGFRADR           save\n         BCT   R15,GETFRNXT\nGETFRNXT EQU   *\n         CLI   0(R1),C' '            is it blank ?\n         BE    GETFINIS              yes, finish\n         CLI   0(R1),C'E'            is it EXPONential sign ?\n         BE    GETEXPON              yes, take exponential part\n         CLI   0(R1),C'e'            is it EXPONential sign ?\n         BE    GETEXPON              yes, take exponential part\n         CLI   0(R1),C'9'            is it the largest value ?\n         BH    Wrong_arg              > 9, error\n         CLI   0(R1),C'0'            is it the smallest value ?\n         BL    Wrong_arg              < 0, error\nGETFRVAL EQU   *\n         LA    R1,1(R1)              next digit\n         BCT   R6,GETFRVCK            trick\n         LA    R6,1                   .. to ..\n         BCT   R15,GETFRNXT             .. ignore the rest\n         B     GETFINIS              else, finish\nGETFRVCK EQU   *\n         LA    R3,1(R3)              count\n         BCT   R15,GETFRNXT          loop\n         B     GETFINIS              else, finish\nGETEXPON EQU   *\n         LA    R6,9                  maximum 9 digits\n         LA    R1,1(R1)              NEXT 2 DIGIT\n         ST    R1,ARGEXADR           save\n         BCTR  R15,0\n         CLI   0(R1),C'+'            is it positif sign ?\n         BE    GETEXVAL              yes, take it\n         CLI   0(R1),C'-'            is it negative sign ?\n         BE    GETEXVAL              yes, take it\n         BCTR  R6,0                  backward 1 digit\nGETEXNXT EQU   *\n         CLI   0(R1),C' '            is it decimal point ?\n         BE    GETFINIS              yes, finish\n         CLI   0(R1),C'9'            is it the largest value ?\n         BH    Wrong_arg              > 9, error\n         CLI   0(R1),C'0'            is it the smallest value ?\n         BL    Wrong_arg              < 0, error\nGETEXVAL EQU   *\n         LA    R1,1(R1)              next digit\n         BCT   R6,GETEXVCK\n         LA    R6,1\n         BCT   R15,GETEXNXT          LOOP\n         B     GETFINIS              else, finish\nGETEXVCK EQU   *\n         LA    R2,1(R2)              count\n         BCT   R15,GETEXNXT          loop\nGETFINIS EQU   *\n         ST    R4,ARGINLEN\n         ST    R3,ARGFRLEN\n         ST    R2,ARGEXLEN\n         SDR   F0,F0                 initialize argument value\n         STD   F0,ARGVALUE           save the value\n         LA    R3,1                  default factor\n         STH   R3,ARGINFAC            .... for integral\n         STH   R3,ARGEXFAC            .... for integral\nCONVINTG EQU   *\n         LM    R1,R2,ARGINADR        get integral val addr/length\n         LTR   R2,R2                 check the length\n         BNP   CONVFRAC              nothing, skip\n         stm   R14,R1,work_sysregs_save Save system work regs\n         BAS   R14,CONVFPNT          convert f.point value\n         lm    R14,R15,work_sysregs_save Restore system work regs\n         STH   R3,ARGINFAC           save integral factor\n         STD   F0,ARGVALUE           save the value\nCONVFRAC EQU   *\n         LM    R1,R2,ARGFRADR        get fraction val addr/length\n         LTR   R2,R2                 check the length\n         BNP   CONVEXPO              nothing, skip\n         MVC   ARGSOURC,=12C'0'\n         LTR   R2,R2                 check again\n         BNO   CONVFRGO              jump around if > 1\nCONVFR01 EQU   *\n         MVC   ARGSOURC(1),0(R1)\n         B     CONVFR02\nCONVFRGO EQU   *\n         BCTR  R2,0                  reduce for EX\n         EX    R2,MOVEARG            execute mover\n         LA    R1,ARGSOURC\nCONVFR02 EQU   *\n         LA    R2,9                  maximum 9 digits\n         BAS   R14,CONVFPNT          convert f.point value\n         DD    F0,=D'1E9'            scale fractional portion\n         AD    F0,ARGVALUE           add integral value\n         STD   F0,ARGVALUE           save the value\nCONVEXPO EQU   *\n         LM    R1,R2,ARGEXADR        get exponent val addr/length\n         LA    R3,1                  initialize factor\n         LNR   R3,R3                 negative factor\n         LTR   R2,R2                 check the length\n         BNP   GETVDONE              NOTHING, SKIP\n         CLI   0(R1),C'-'            is there '-' sign ?\n         BE    CONVEXSG              yes,, negative signed number\n         LPR   R3,R3                 positive factor\n         CLI   0(R1),C'+'            is there '+' sign ?\n         BNE   CONVEXCK              no, just proceed and assume '+'\nCONVEXSG EQU   *\n         LA    R1,1(R1)              skip the number\n         BCTR  R2,0                  so, reduce length as well\nCONVEXCK EQU   *\n         STH   R3,ARGEXFAC           corrected integral factor\n         BCTR  R2,0                  correct for EX\n         LTR   R2,R2                 check again\n         BM    CONVPOWR              IGNORE IF < 0\n         BP    CONVEXPC              proceed if > 0\n         PACK  ARGTEMP(8),0(1,R1)    special case\n         B     CONVEXGO              proceed\nCONVEXPC EQU   *\n         EX    R2,PACKARG\nCONVEXGO EQU   *\n         CVB   R2,ARGTEMP            convert to binary\nCONVPOWR EQU   *\n         A     R2,ARGOVRLY           overlaid counter added\n         MH    R2,ARGEXFAC           factorized the exponent\n         XC    ARGOVRLY,ARGOVRLY     clear\n         CH    R2,=H'75'             overflow ?\n         BL    GETVPOWU              no, continue\n         LR    R4,R2                 Exponent\n         LA    R2,75                 set R2 = 75\n         SR    R4,R2                 recalculate overflow factor\n         ST    R4,ARGOVRLY           and save it\n         B     GETVPOWF              continue\nGETVPOWU   EQU   *\n         CH    R2,=H'-76'            underflow ?\n         BH    GETVPOWF               no, continue\n         LR    R4,R2                 Exponent\n         LH    R2,=H'-76'            set R2 = -76\n         SR    R4,R2                 recalculate underflow factor\n         ST    R4,ARGOVRLY           and save it\nGETVPOWF EQU   *\n         LTR   R2,R2                 test the value\n         BZ    GETVDONE              zerro - done\n         LA    R4,POSVALS            exponential positive table\n         BP    GETVPOWX\n         LA    R4,NEGVALS            exponential negative table\nGETVPOWX EQU   *\n         LPR   R2,R2                 absolute\n         SRDA  R2,3                  exponent divided by 8\n         SRL   R3,29                 division remainder\n         SLL   R3,3                  index to power 10**J, J=0,1..7\n         LD    F2,0(R3,R4)           F2 = 10**X\n         SLA   R2,3                  8 + index to power 10**J\n         BZ    GETVPOW1              skip if 0\n         LA    R4,64(R4)             access 2nd part of table\n         MD    F2,56(R2,R4)          multiply to previous value\nGETVPOW1 EQU   *\n         MDR   F0,F2                 multiply scale factor\nGETVDONE EQU   *\n         MD    F0,ARGVINIT           correct with initial value\n         STD   F0,ARGVALUE           save the final value\n         aif   (not &trace).next2\n         WTO   'DRX0003I Parsing arguments completed.',                +\n               routcde=(1,10)\n.next2   anop\n         LA    R1,ARGVALUE           point to value field\n         L     R14,ARGSAV14          restore linkage pointer\n         BR    R14                   return to caller\n         SPACE\nCONVFPNT EQU   *\n         SDR   F0,F0                 initialize value\n         LA    R3,1                  initialize factor\n         LNR   R3,R3                 negative factor\n         CLI   0(R1),C'-'            is there '-' sign ?\n         BE    CONVFPSG              yes negative signed number\n         LPR   R3,R3                 positive factor\n         CLI   0(R1),C'+'            is there '+' sign ?\n         BNE   CONVFPCK              no, just proceed and assume '+'\nCONVFPSG EQU   *\n         LA    R1,1(R1)              skip the number\n         BCTR  R2,0                  so, reduce length as well\nCONVFPCK EQU   *\n         BCTR  R2,0                  reduce for EX instruction\n         LTR   R2,R2                 check adjusted length\n         BMR   R14                   just exit if negative\n         BP    CONVFPGO              proceed if > 0\n         PACK  ARGTEMP(8),0(1,R1)    otherwise (0), means 1 digit\n         B     CONVFBIN              and skip EX\nCONVFPGO EQU   *\n         EX    R2,PACKARG            pack to decimal\nCONVFBIN EQU   *\n         CVB   R2,ARGTEMP            convert to binary\n         LPR   R2,R2                 absolute value\n         MVC   ARGUNNOR,#unnormal    put floating point indicator\n         ST    R2,ARGUNLOW           store as low order unnormalized\n         LD    F0,ARGUNNOR           unnormalized f.point value\n         AD    F0,#zero              normalized\n         LTR   R3,R3                 check sign\n         BNMR  R14                   return if not negative\n         LCDR  F0,F0                 else, change sign\n         BR    R14                   return\nPACKARG  PACK  ARGTEMP(8),0(*-*,R1)   << EXECUTED >>\nMOVEARG  MVC   ARGSOURC(*-*),0(R1)    << EXECUTED >>\n         SPACE\nWrong_arg Equ  *\n         WTO   'DRX0011E Error/invalid argument is detected',          +\n               routcde=(1,10)\n         oi    Check_arg_flag,Arg_is_error  mark Arg in error\n         mvc   ARGRSULT,ARGVALUE\n         bas   r14,Print_Error\n         mvc   wtolist(wtolistl),errwtol\n         mvc   tracetxt(l'errtxt),errtxt\n         mvc   tracetxt+l'errtxt(l'traceid),traceid\n         mvc   tracetxt+l'errtxt+l'traceid(5),=cl5' is: '\n         mvc   tracetxt+l'errtxt+l'traceid+5(FPNTLEN),ARGSOURC\n         mvi   tracetxt+l'errtxt+l'traceid+5+FPNTLEN,c'/'\n         l     r7,Arg_address         current arg address\n         l     r1,Arg_length          and current its length\n         bctr  r1,0\n         ex    r1,errmvc              take the original arg\n         la    r15,l'errtxt+l'traceid+7+FPNTLEN total WTO length\n         la    R15,1(R1,R15)          adjust the value\n         sth   R15,tracemsg           put it in WTO area\n         la    r7,tracemsg            point to WTO msg\n         la    r1,wtolist             point to WTO list area\n         wto   text=(r7),mf=(E,(r1))  Issue WTO\n         xr    R15,r15                Zap RC\n         b     Quit_with_error        Quit\nerrwtol  wto  text=,routcde=(1,10),mf=L\nerrmvc mvc tracetxt+l'errtxt+l'traceid+7+FPNTLEN(*-*),0(r7)\nerrtxt   dc   C'DRX0111E Argument value at '\nQuit_with_error ds 0h\n         la    r15,4            set rc = 4\n         @rxexit rc=YES         return to the system\n         DS    0D\nPOSVALS  EQU   *\n         DC    D'1,1E1,1E2,1E3,1E4,1E5,1E6,1E7'\n         DC    D'1E8,1E16,1E24,1E36,1E40,1E48,1E56,1E64,1E72'\nNEGVALS  EQU   *\n         DC    D'1,1E-1,1E-2,1E-3,1E-4,1E-5,1E-6,1E-7'\n         DC    D'1E-8,1E-16,1E-24,1E-36,1E-40,1E-48,1E-56,1E-64,1E-72'\n         SPACE 1\nPrint_Error equ *\n         stm   R0,R15,tracesv               save all regs\n         l     r12,=A(Print_result)\n         br    r12\n*        b     Print_result\n         LTORG ,\n*        drop  r7\n         DS    0D\n         SPACE 1\n   EJECT\n   TITLE 'LOCFN: Common obtain EVALBLOK subroutine'\n*--------------------------------------------------------------*\n* OBTAIN AND PRODUCE FUNCTION VALUE                            *\n*                                                              *\n*   o   Convert function returned value in ARGBLOK             *\n*               into EBCDIC string                             *\n*   o   Reuse ARGBLOK as EVALBLOK, so no need to               *\n*               re obtain free storage                         *\n*   o   Fill in EBCDIC result into EVALBLOK                    *\n*   o   Chain EVALBLOK address in the return pointer           *\n*   o   The caller is responsible to cleanup EVALBLOK          *\n*                                                              *\n*--------------------------------------------------------------*\n         SPACE 2\n         DS    0D\n         drop  R11,r12\nPrint_result   EQU   *\n         using Print_result,r12      set local addressability\n         USING Evalblock,R7          Map of Evalblock\n         aif   (not &trace).next3\n         WTO   'DRX0004I Editing result in progress...',               +\n               routcde=(1,10)\n.next3   anop\n         aif   (not &trace).trace06\n         icm   r0,b'1111',=x'66666666'\n.trace06 anop\n         L     R7,EFPLEVAL           address of evalblock pointer\n         L     R7,0(,R7)             Obtain Evalblock\n         mvi   Evalblock_EVDATA,C' ' put a blank to be rolled up\n         mvc   Evalblock_EVDATA+1(FPNTLEN-1),Evalblock_EVDATA\n         MVI   FRACSIGN,PRINTPOS     default is positive sign\n         MVC   FRACINTG,=C'0.'\n         MVI   EXPOMARK,C'E'\n         LD    F0,ARGRSULT            result in long form\n         BAS   R14,Calculate_Exponent calculate exponentnumber\n         LTDR  F0,F0                 check the result\n         BZ    PRTZERO               go here if 0\n         BO    PRTONE                else, just print 1.0\n         LPDR  F4,F0                 absolute fraction base only\n         SDR   F0,F0\n         LRER  F0,F4\n         LPER  F4,F0                 short absolute fraction base\n         LR    R3,R0                 get exponentnumber\nPRTSCALE EQU   *\n         ME    F4,=E'1E9'            get 1st 9 digits\n         AW    F4,#unnormal          isolate 1st 9 digits\n         STD   F4,ARGUNNOR           save it\n         L     R6,ARGUNLOW           get integer form 1st 9 digits\n         LPR   R1,R6                 check\n         C     R1,=F'000100000'      is mantissa significant ?\n         BNL   PRTSCLGO              ya, go\n         ME    F0,=E'1000'           no, multiplied to 10,000\n         LPER  F4,F0                 absolute adjusted fraction\n         SH    R3,=H'3'              exponent reduced by factor of 4\n         B     PRTSCALE              rescaling\nPRTSCLGO   EQU   *\n         CVD   R6,ARGTEMP            convert to package decimal\n         OI    ARGTEMP+7,X'0F'       switch decimal offset\n         UNPK  FRACNUM,ARGTEMP       convert to EBCDIC\n         LA    R1,FRACLEN            data length w/o exponent part\n         A     R3,ARGEXPAN           add expansion factor\n         LTR   R3,R3                 check exponent\n         BZ    PRT_no_exp            ignore exponent if 0\n         BM    PRTEXNEG              no, check negative exponent\n         MVI   EXPOSIGN,PRINTPOS     positive exponent\n         B     PRTEXPON              process exponentprinting\nPRT_no_exp equ *\n         mvc   expomark(3),=3c' '    put blanks\n         B     PRTCHECK              continue to normal way\nPRTEXNEG EQU   *\n         MVI   EXPOSIGN,PRINTNEG     negative exponent\nPRTEXPON EQU   *\n         LPR   R3,R3                 get absolute value\n         CVD   R3,ARGTEMP            convert to packed decimal\n         OI    ARGTEMP+7,X'0F'       turn off dec offset\n         UNPK  EXPONUM,ARGTEMP       convert to EBCDIC\n         LA    R1,FPNTLEN            data length\n         LA    R3,EXPONUM            point to exponentnumber field\n         la    R4,l'exponum-1(R3)    end of exponentnumber\nPRTEXPLP EQU   *\n         CLI   0(R3),C'0'            is it 0\n         BNE   PRTCHECK              no, leave the loop\n         MVC   0(L'EXPONUM,R3),1(R3) yes, shift left\n         mvi   0(r4),C' '            put a blank at the end of field\n         bctr  r4,0                  backward 1 byte\n         BCT   R1,PRTEXPLP           loop\nPRTCHECK EQU   *\n         LD    F0,ARGRSULT           original return value\n         LTDR  F0,F0                 check\n         BNM   Final_checking        done if not negative\n         MVI   FRACSIGN,PRINTNEG     use negative sign\n         B     Final_checking\nPRTZERO  EQU   *\n         MVI   FRACINTG,C'0'         use val '0'\n         MVI   Evalblock_EVDATA,C'0'\n         B     Simple_result         simple way\nPRTONE   EQU   *\n         MVI   FRACINTG,C'1'         value = '1'\n         MVI   Evalblock_EVDATA,C'1'\nSimple_result  equ *\n         LA    R1,1                  data length\n         B     Final_result          Set output\n         SPACE 1\n*---------------------------------------------------------*\n*  Produce EVALBLOK reusing existing ARGBLOK area         *\n*   -  clear control area                                 *\n*   -  rebuild control area                               *\n*   -  capture part of ARGBLOK as EVALBLOK                *\n*           even larger EVALBLOK looked inefficient,      *\n*           but it usefull be DRXSTCFN statistical package*\n*           thats frequrntly call and need original       *\n*           result of ARGRSULT and ARGEXPAN in ARGBLOK.   *\n*---------------------------------------------------------*\n         SPACE 1\nFinal_checking equ *\n*        st    R1,Evalblock_EVLEN    set data length\n         la    r15,expomark-1\nWipe_trailing_0 equ *\n         cli   0(r15),c'.'                  is it dot sign w/o frac?\n         be    Shift_result                 yes, remove it\n         cli   0(r15),c'0'                  is it 0?\n         bne   Final_result                 no, just print it\nShift_result   equ *\n         mvc   0(fpntlen-fraclen,r15),1(r15) else, shift left 1\n         bctr  r15,0                        backward pointer\n         bct   r1,Wipe_trailing_0           reduce counter and loop\nFinal_result equ *\n         CLI   FRACSIGN,PRINTNEG            is it negative ?\n         BE    Put_result                   yes, go on\n         MVC   Evalblock_EVDATA(FPNTLEN-1),ARGSOURC+1 yes, avoid '+'\n         BCTR  R1,0                         reduce the length\n         B     Put_result_length            go print it\nPut_result EQU   *\n         MVC   Evalblock_EVDATA(FPNTLEN),ARGSOURC move whole data\nPut_result_length EQU   *\n         st    R1,Evalblock_EVLEN           set data length\n         tm    Check_arg_flag,Arg_is_error  Arg error?\n         bno   Return                       No, continue return\n         lm    R0,R15,tracesv               Yes, restore all regs\n         br    r14                          and return to caller\nReturn   EQU   *\n         aif   (not &trace).next4\n         WTO   'DRX0005I Editing result is completed.',                +\n               routcde=(1,10)\n         mvc   tracetxt(l'tracetxt2),tracetxt2\n         mvc   tracetxt+l'tracetxt2(FPNTLEN),ARGSOURC\n         la    r15,l'tracetxt2+FPNTLEN\n         sth   R15,tracemsg\n         la    r7,tracemsg\n         la    r1,wtolist\n         wto   text=(r7),mf=(E,(r1))\n         xr    R15,r15\n         b     prttrc_ok\ntracetxt2 dc   C'Result is: '\nprttrc_ok ds   0h\n.next4   anop\n         @rxexit rc=NO\n         SPACE 1\nPRINTPOS EQU   C'+'\nPRINTNEG EQU   C'-'\n         LTORG ,\n*        drop  r11,r12\n         drop  r12\n   EJECT\n   TITLE 'LOCFN: Common obtain EXPONEN number routine'\n*--------------------------------------------------------------*\n* OBTAIN BASE FRACTION AND EXPONEN NUMBER FROM GIVEN INPUT     *\n*                                                              *\n*   o   Input from F0 is full doubleword precision             *\n*                                                              *\n*   o   Output are:                                            *\n*               F0   -  Base fraction floatingpoint            *\n*               F6   -  exponentfactor                         *\n*               R0   -  exponentbinary number                  *\n*                                                              *\n*--------------------------------------------------------------*\n         SPACE 2\n         DS    0D\nCalculate_Exponent EQU   *\n         STM   R1,R12,ARGREGS           save all register\n         basr  r11,0                    set local base\n         using *,r11                    tell assembler\n         SDR   F6,F6                    clear F6\n         XR    R0,R0                    clear R0\n         XR    R15,R15                  clear R15\n         LTDR  F0,F0                    check the input\n         BZ    CALXEND                  end if 0\n         SDR   F2,F2                    zap all bits in F2\n         LPDR  F4,F0                    abslute long form\n         LRER  F2,F4                    round up into short form\n         CE    F2,=E'1'                 compare to 1.0\n         BH    CALXPOS                  if > 1.0\n         BE    CALXONE                  else, just print 1.0\n         CE    F2,=E'0.1'               compare to 1.0\n         BL    CALXNEG                  if < 1.0\n         LD    F6,XNEGTAB1              set to 1.0\n         B     CALXSCAL                 attempt to do conversion\nCALXPOS  EQU   *\n*---------------------------------------------------------*\n*  Find N such that 10**(N-1) <= X < 10**(N)              *\n*   in sequence of I = 10, 20, .. 80                      *\n*---------------------------------------------------------*\n         SPACE 1\n         LA    R15,1                    exponent = 1\n         SR    R6,R6                    init index\nCALXPOS1 EQU   *\n         CD    F2,XPOSTAB2+8(R6)        is it within range ?\n         BL    CALXPOSX                 yes, leave the loop\n         LA    R6,8(R6)                 else, next entry\n         LA    R15,10(R15)              incremented by 10\n         B     CALXPOS1                 loop\nCALXPOSX EQU   *\n         LD    F6,XPOSTAB2(R6)          get the entry\n         DDR   F2,F6                    adjust to obtain exp 1-9 range\n         SR    R6,R6                    clear table offset\nCALXPOS2 EQU   *\n         CD    F2,XPOSTAB1(R6)          is it within range ?\n         BL    CALXPOSZ                 yes, leave\n         LA    R6,8(R6)                 else, next entry\n         LA    R15,1(R15)               incremented by 1\n         B     CALXPOS2                 loop\nCALXPOSZ EQU   *\n         MD    F6,XPOSTAB1(R6)          multiplied with range limit\n         B     CALXSCAL                 attempt to convert to EBCDIC\nCALXNEG  EQU   *\n*---------------------------------------------------------*\n*  Find N such that 10**(-N) => X > 10**(-N-1)            *\n*   in sequence of I = 10, 20, .. 80                      *\n*---------------------------------------------------------*\n         SPACE 1\n         SR    R6,R6                   init index\nCALXNEG1 EQU   *\n         CD    F2,XNEGTAB2+8(R6)       is it within range ?\n         BH    CALXNEGX                yes, leave the loop\n         LA    R6,8(R6)                else, next entry\n         LA    R15,10(R15)             incremented by 10\n         B     CALXNEG1                loop\nCALXNEGX EQU   *\n         LD    F6,XNEGTAB2(R6)         get the entry\n         DDR   F2,F6                   adjust to obtain exp 1-9 range\n         SR    R6,R6                   clear table offset\nCALXNEG2 EQU   *\n         CD    F2,XNEGTAB1+8(R6)       is it within range\n         BH    CALXNEGZ                yes, leave\n         LA    R6,8(R6)                else, next entry\n         LA    R15,1(R15)              incremented by 1\n         B     CALXNEG2                loop\nCALXNEGZ EQU   *\n         LNR   R15,R15                 turn to negative value\n         MD    F6,XNEGTAB1(R6)         multiplied with range limit\nCALXSCAL EQU   *\n         DDR   F4,F6                   avoid exponent\n         LR    R0,R15                  store exponentnumber\n         LTDR  F0,F0                   check the sign\n         BM    CALXSWCT                switch if negative\n         LDR   F0,F4                   save\n         B     CALXEND                 end\nCALXSWCT EQU   *\n         LCDR  F0,F4                   switch sign and save\n         B     CALXEND                 end\nCALXONE  EQU   *\n         LA    R15,1                   set 1 for value\n         LR    R0,R15\n         DD    F2,XPOSTAB1             divided by 10\n         MDR   F0,F2                   produce output\nCALXEND  EQU   *\n         LM    R1,R12,ARGREGS          restore register\n         BR    R14                     return\nXPOSTAB1 DC    D'1E1,1E2,1E3,1E4,1E5,1E6,1E7,1E8,1E9,1E10'\nXPOSTAB2 DC    D'1,1E10,1E20,1E30,1E40,1E50,1E60,1E70'\n         DC    X'7FFFFFFFFFFFFFFF'\nXNEGTAB1 DC    D'1,1E-1,1E-2,1E-3,1E-4,1E-5,1E-6,1E-7,1E-8,1E-9'\nXNEGTAB2 DC    D'1,1E-10,1E-20,1E-30,1E-40,1E-50,1E-60,1E-70,0'\n         LTORG ,\n         drop  r11\n*        drop  r11,r12\n   EJECT\n   TITLE 'LOCFN: Program Interupt SLIH Exit'\n*------------------------------------------------------------*\n*    Program interrupt exit routine                          *\n*                                                            *\n*   REGISTERS  -                                             *\n*                                                            *\n*     R0 -  Used as a work register by the system.           *\n*     R1 -  Address of EPIE area                             *\n*     R2-12 - Unchanged                                      *\n*     R14 - Return address                                   *\n*     R15 - Address of the exit routine.                     *\n*                                                            *\n*       Check interrupt code whether should be handled,      *\n*        so let CMS handle it if we don't have               *\n*        responsibility for this interrupt                   *\n*                                                            *\n*------------------------------------------------------------*\n         DS    0D\nESPIE_exit equ *\n         using ESPIE_exit,R15         Exit addressability\n         using EPIE,r1\n         cli   EPIEICD1,X'0C'         exp overflow?\n         be    RCOVOVRF               yes, handle it!\n         cli   EPIEICD1,X'0D'         exp underflow?\n         be    RCOVUNDF               yes, handle it!\n         cli   EPIEICD1,X'0F'         f-point divide?\n         be    RCOVDVDX               yes, handle it!\n         br    r14                    otherwise just return\nRCOVOVRF LD    F0,ARGEXLOG            <<EXECUTED>>\n         DD    F0,=D'1E50'            <<EXECUTED>>\n         B     RXRCOVRY               go to provide solution\nRCOVUNDF LD    F0,ARGEXLOG            <<EXECUTED>>\n         MD    F0,=D'1E50'            <<EXECUTED>>\n         B     RXRCOVRY               go to provide solution\nRCOVDVDX LD    F0,#zero               <<EXECUTED>>\n         B     RXRCOVRY               go to provide solution\n         SPACE 1\nRXRCOVRY EQU   *\n         A     R0,ARGCORRC            get overflow/underflow exponent\n         ST    R0,ARGCORRC            save\n         aif   (not &trace).trace07\n         icm   r0,b'1111',=x'77777777'\n.trace07 anop\n         XR    R15,R15                clear R15\n         BR    R14                    Return to the system\n         LTORG ,\n         DS    0D                     Get to doublewords boundary\n*EXPONTB   EQU   *\n*        DC    D'1'\n*        DC    D'1E01,1E02,1E03,1E04,1E05,1E06,1E07,1E08,1E09,1E10'\n*        DC    D'1E11,1E12,1E13,1E14,1E15,1E16,1E17,1E18,1E19,1E20'\n*        DC    D'1E21,1E22,1E23,1E24,1E25,1E26,1E27,1E28,1E29,1E30'\n*        DC    D'1E31,1E32,1E33,1E34,1E35,1E36,1E37,1E38,1E39,1E40'\n*        DC    D'1E41,1E42,1E43,1E44,1E45,1E46,1E47,1E48,1E49,1E50'\n*        DC    D'1E51,1E52,1E53,1E54,1E55,1E56,1E57,1E58,1E59,1E60'\n*        DC    D'1E61,1E62,1E63,1E64,1E65,1E66,1E67,1E68,1E69,1E70'\n*                                     code.\n         Eject\n   Title 'LOCFN: Dummy Section Pool'\n*------------------------------------------------------*\n*   Working set areas                                  *\n*------------------------------------------------------*\n         space 1\nWORKSET  DSECT\nsavearea DS    18F\n         ORG   savearea+4\nsaveid   DS    F\n         org\nsavesize DS    F\nfunction_address   DS  A(*-*)      function routine address\nfunction2_address  DS  A(*-*)      2nd function routine address\nArg_address        DS  A(*-*)      Current arg address\nArg_length         DS  A(*-*)      Current arg length\nfinal_address      DS  A(*-*)      final routine address\nNumber_of_arg      DS  H           Number of args\nCheck_arg_flag     DS  X           Checking indicator\nArg_is_error       EQU B'10000000' Argument in error\nArg_is_integer     EQU B'00001000' Argument in degree\nArg_is_positive    EQU B'00000100' Argument in degree\nOptional_arg_flag  DS  X           Optional arg flag\nOptional_arg_check EQU C'Y'        Optional arg checking\nOptional_arg       DS  X           Optional argument\nArg_in_radian      EQU C'R'        Argument in radian\nArg_in_degree      EQU C'D'        Argument in degree\n                   DS  3X          reserved\nwork_sysregs_save  DS  4F          Savearea for R14, R15, R0 and R1\nrexx_sysregs_save  DS  4F          Savearea for R14, R15, R0 and R1\ntempvar  ds    d                   temporary variable\nworksave_length    equ  *-WORKSET\nwtolist  wto   text=,routcde=(1,10),mf=L\nwtolistl equ   *-wtolist\n         ds    0h\ntraceid  ds    cl8\ntracesv  ds    16F\ntracemsg ds    al2(*-*)\ntracetxt ds    cl78\nWORKSETL EQU   *-WORKSET\n         SPACE 2\n*--------------------------------------*\n*  ARGBLOK                             *\n*  Function argument control block     *\n*--------------------------------------*\n         SPACE 1\nARGBLOK  DSECT\nARGVALUE DS    D                        floatingpoint value of argument\nARGUNNOR DS    0D                       unnormalized value\n         DS    X'4E000000'              high order word\nARGUNLOW DC    F'0'                     low order word\nARGTEMP  DS    D                        temporary place\nARGVSAVE DS    D                        temporary palce for argument\nARGVHOLD DS    D                        temporary result holder\nARGVINIT DS    D                        initial value\nARGRSULT DS    D                        floatingpoint value of result\nARGSOURC DS    XL24                     initial C'00000000'\n         ORG   ARGSOURC\nFRACSIGN DC    C' '                     sign\nFRACINTG DC    C'0.'\nFRACNUM  DC    CL9' '                   MANTISSA\nFRACLEN  EQU   *-ARGSOURC\nEXPOMARK DC    C'E'\nEXPOSIGN DC    C' '\nEXPONUM  DC    CL8' '                   exponent\nFPNTLEN  EQU   *-ARGSOURC\n         ORG\nARGPTR   EQU   *\nARGINADR DS    A                        8 start address of integral\nARGINLEN DS    A                             .. its length\nARGFRADR DS    A                        9 start address of fractional\nARGFRLEN DS    A                             .. its length\nARGEXADR DS    A                       10 start address of exponential\nARGEXLEN DS    A                             .. its length\nARGINFAC DS    H                          integral factor\nARGEXFAC DS    H                       11 exponent factor\nARGOVRLY DS    F                       overlaid space for exponent\nARGEXPAN DS    F                       12 power expansion\nARGPTRL  EQU   *-ARGPTR\nARGSAV14 DS    A                       linkage pointer savearea\nARGOVRSV DS    F                       13 overlaid space for exponent\nARGEXPSV DS    F                       power expansion\nARGCORRC DS    F                       14 exponent correction factor\n         DS    F                       RESERVED\nARGCONST EQU   *\n#pi      DC    D'3.141592654'          15\n#ln10    DC    D'2.302585093'          16\n#e       DC    D'2.718281828'          17\n#zero    DC    D'0'                    18\n#one     DC    D'1'                    19\n#360     DC    D'360'                  20\n#unnormsg DC   X'4E00000100000000'     21\n#unnormal DC   X'4E00000000000000'     22\nARGCONSL EQU   *-ARGCONST\nARGREGS  DS    6D                      23-28\nARGAREAL EQU   *-ARGBLOK               size in bytes\nARGENVR  DS    12D                     environment save area\nARGPGPSW DS    D                       PROGRAM NEW PSW savearea\nARGSVPSW DS    D                       PROGRAM NEW PSW SAVEAREA\nARGEXLOG DS    D                       execution log (blackbox)\nARGPGGPR DS    16F                     registers at interruption\nARGBLOKL EQU   *-ARGBLOK               size in bytes\nARGBSIZE EQU   (ARGBLOKL+7)/8          size in doublewords\n         SPACE 2\n*--------------------------------------*\n*  REXX DATA AREA AND CONTROL BLOCK    *\n*--------------------------------------*\n         IRXARGTB\n         IRXPARMB                      Parameter block map\n         IRXEVALB                      Evalblock map\nEvalblock_length equ *-Evalblock\nEvalblock_dwords equ (*-Evalblock+7)/8\nEVCTLEN  EQU   Evalblock_EVDATA-Evalblock\n         IRXEFPL\n         IHAEPIE\n         END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "JDRXFLOC": {"ttr": 1798, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00H\\x01\\x04\\x06\\x1f\\x01\\x04\\x06\\x8f\"\\x15\\x00&\\x00\\r\\x00\\x00\\xc4\\xc5\\xd9\\xe4@@@@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "2004-03-01T00:00:00", "modifydate": "2004-03-08T22:15:48", "lines": 38, "newlines": 13, "modlines": 0, "user": "DERU"}, "text": "//JDRXFLOC JOB (1,NIT),'ASSEMBLE IRXFLOC',                              JOB00732\n//      CLASS=A,MSGCLASS=X,\n//      REGION=4M,MSGLEVEL=(1,1),NOTIFY=&SYSUID\n//* *******************************************************\n//*    THIS JOB FOR ASSEMBLE AND LINK ASSEMBLER PROGRAM   *\n//* *******************************************************\n//    JCLLIB ORDER=NIT.PROCLIB\n//    EXEC ASSEMBLE,MBR=DRXFLOC,NAME=IRXFLOC,\n//         SRCLIB='NIT.DRXMATH.PACKLIB',\n//         LNKLIB='NIT.DRXMATH.LINKLIB', <=== CHANGE THIS WITH YOURS\n//         MACLIB='NIT.DRXMATH.PACKLIB',\n//         APARM='OBJECT,NODECK,ALIGN,RENT',\n//         LPARM='RENT,REUS,REFR,RMODE(ANY)'\n//L.SYSIN   DD *\n  ALIAS DRXEXP,\n        DRXSIN,\n        DRXCOS,\n        DRXTAN,\n        DRXCSC,\n        DRXSEC,\n        DRXCOT,\n        DRXSINH,\n        DRXCOSH,\n        DRXTANH,\n        DRXCSCH,\n        DRXSECH,\n        DRXCOTH,\n        DRXSQRT,\n        DRXLOG,\n        DRXRAD,\n        DRXLN,\n        DRXPOWER,\n        DRXFACT,\n        DRXFRAC,\n        DRXCOMB,\n        DRXPERM\n  NAME IRXFLOC(R)\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "JDRXTEST": {"ttr": 1800, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\t\\x01\\x04\\x06_\\x01\\x04\\x06\\x8f\"\\x16\\x00\\x0e\\x00\\r\\x00\\x00\\xc4\\xc5\\xd9\\xe4@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2004-03-05T00:00:00", "modifydate": "2004-03-08T22:16:09", "lines": 14, "newlines": 13, "modlines": 0, "user": "DERU"}, "text": "//JDRXTEST JOB (1,NIT),'TSO BATCH',CLASS=T,                             JOB00713\n//   MSGCLASS=X,NOTIFY=&SYSUID\n//TSO    EXEC PGM=IKJEFT01,DYNAMNBR=20\n//STEPLIB  DD DISP=SHR,DSN=NIT.DRXMATH.LINKLIB\n//SYSTSPRT DD SYSOUT=A\n//SYSEXEC  DD DISP=SHR,DSN=NIT.DRXMATH.PACKLIB\n//SYSTSIN  DD *\n%TTEST0 3.65 2.5\n%TTEST1 25 18\n%TTEST2 60\n%TTEST3 3.75\n%TTEST5 12.75\n%TTEST6 30\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TTEST0": {"ttr": 1802, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x13\\x01\\x04\\x06O\\x01\\x04\\x06O\\x17H\\x00\\r\\x00\\x08\\x00\\x00\\xc4\\xc5\\xd9\\xe4@@@@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2004-03-04T00:00:00", "modifydate": "2004-03-04T17:48:13", "lines": 13, "newlines": 8, "modlines": 0, "user": "DERU"}, "text": "/* Test 1 */\n/* trace ALL */\narg a p\nsay \"Test 1 - Common Math functions\"\nsay \"Argument 1 =\" a \", argument 2 =\" p\nsay \" sqrt(\"a\")=\" sqrt(a)\nsay \" exp(\"a\")=\" exp(a)\nsay \" ln(\"a\")=\" ln(a)\nsay \" log(\"a\")=\" log(a)\nsay \" rad(\"a\")=\" rad(a)\nsay \" frac(\"a\")=\" frac(a)\nsay \" power(\"a\",\"p\")=\" power(a,p)\nsay;say\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TTEST1": {"ttr": 1804, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00G\\x01\\x04\\x06O\\x01\\x04\\x06O (\\x00\\n\\x00\\x0b\\x00\\x00\\xc4\\xc5\\xd9\\xe4@@@@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "2004-03-04T00:00:00", "modifydate": "2004-03-04T20:28:47", "lines": 10, "newlines": 11, "modlines": 0, "user": "DERU"}, "text": "/* Test 1 */\n/* trace ALL */\narg a p\nsay \"Test 2 - Common Math Integer functions\"\nsay \"Argument 1 =\" a \", argument 2 =\" p\nsay \" fact(\"a\")=\" fact(a)\nsay \" fact(\"p\")=\" fact(p)\nsay \" comb(\"a\",\"p\")=\" comb(a,p)\nsay \" perm(\"a\",\"p\")=\" perm(a,p)\nsay;say\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TTEST2": {"ttr": 1806, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00!\\x01\\x04\\x06O\\x01\\x04\\x06O\\x179\\x00\\x12\\x00\\x11\\x00\\x00\\xc4\\xc5\\xd9\\xe4@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-03-04T00:00:00", "modifydate": "2004-03-04T17:39:21", "lines": 18, "newlines": 17, "modlines": 0, "user": "DERU"}, "text": "/* Test 2 */\n/* trace ALL */\narg a\nsay \"Test 2 - Trigonometry functions\"\nsay \"Argument =\" a \" (degree base)\"\nsay \" sin(\"a\")=\" sin(a)\nsay \" cos(\"a\")=\" cos(a)\nsay \" tan(\"a\")=\" tan(a)\nsay \" csc(\"a\")=\" csc(a)\nsay \" sec(\"a\")=\" sec(a)\nsay \" cot(\"a\")=\" cot(a)\nsay \" sinh(\"a\")=\" sinh(a)\nsay \" cosh(\"a\")=\" cosh(a)\nsay \" tanh(\"a\")=\" tanh(a)\nsay \" csch(\"a\")=\" csch(a)\nsay \" sech(\"a\")=\" sech(a)\nsay \" coth(\"a\")=\" coth(a)\nsay;say\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TTEST3": {"ttr": 1808, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x001\\x01\\x04\\x06O\\x01\\x04\\x06O\\x179\\x00\\x12\\x00\\x11\\x00\\x00\\xc4\\xc5\\xd9\\xe4@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2004-03-04T00:00:00", "modifydate": "2004-03-04T17:39:31", "lines": 18, "newlines": 17, "modlines": 0, "user": "DERU"}, "text": "/* Test 3 */\n/* trace ALL */\narg a\nsay \"Test 3 - Trigonometry functions\"\nsay \"Argument =\" a \" (radian base)\"\nsay \" sin(\"a\",r)=\" sin(a,r)\nsay \" cos(\"a\",r)=\" cos(a,r)\nsay \" tan(\"a\",r)=\" tan(a,r)\nsay \" csc(\"a\",r)=\" csc(a,r)\nsay \" sec(\"a\",r)=\" sec(a,r)\nsay \" cot(\"a\",r)=\" cot(a,r)\nsay \" sinh(\"a\",r)=\" sinh(a,r)\nsay \" cosh(\"a\",r)=\" cosh(a,r)\nsay \" tanh(\"a\",r)=\" tanh(a,r)\nsay \" csch(\"a\",r)=\" csch(a,r)\nsay \" sech(\"a\",r)=\" sech(a,r)\nsay \" coth(\"a\",r)=\" coth(a,r)\nsay;say\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TTEST5": {"ttr": 1810, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00%\\x01\\x04\\x06O\\x01\\x04\\x06_\\x06\\x07\\x00\\t\\x00\\x07\\x00\\x00\\xc4\\xc5\\xd9\\xe4@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2004-03-04T00:00:00", "modifydate": "2004-03-05T06:07:25", "lines": 9, "newlines": 7, "modlines": 0, "user": "DERU"}, "text": "/* Test 5 */\narg a\nSay \"Test 5: Logarithm\"\nsay \" argument =\" a\nsay \" ln(\"a\") =\" ln(a)\nsay \" log(\"a\") =\" log(a)\nsay \" ln(10) =\" ln(10)\nsay \" ln(\"a\") / ln(10) =\" ln(a)/ln(10)\nsay;say\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TTEST6": {"ttr": 1812, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00D\\x01\\x04\\x06O\\x01\\x04\\x06_\\x06\\t\\x00\\x0f\\x00\\x0f\\x00\\x00\\xc4\\xc5\\xd9\\xe4@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2004-03-04T00:00:00", "modifydate": "2004-03-05T06:09:44", "lines": 15, "newlines": 15, "modlines": 0, "user": "DERU"}, "text": "/* Test 6 */\n/* trace ALL */\narg a\nsay \"Test 6 - Trigonometry\"\nsay \" argument =\" a\nsay \" sin(\"a\")=\" sin(a)\nsay \" cos(\"a\")=\" cos(a)\nsay \" tan(\"a\")=\" tan(a)\nsay \" sin(\"a\")/cos(\"a\") =\" sin(a)/cos(a)\nsay \" sin(\"a\")~2 + cos(\"a\")~2 =\" sin(a)**2 + cos(a)**2\nsay \" csc(\"a\")=\" csc(a)\nsay \" sec(\"a\")=\" sec(a)\nsay \" cot(\"a\")=\" cot(a)\nsay \" csc(\"a\")/sec(\"a\") =\" csc(a)/sec(a)\nsay;say\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT670/FILE670.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT670", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}