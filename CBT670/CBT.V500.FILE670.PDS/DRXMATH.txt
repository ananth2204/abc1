DERU  TITLE 'LOCFN: REXX Local function package'
         gblb  &trace
*====================================================================*
*                                                                    *
*   MODULE NAME  -                                                   *
*                   DRXMATH                                          *
*                   Rexx mathematical function package               *
*                                                                    *
*   DESCRIPTION  -                                                   *
*                   Provide some mathematical functions in Rexx      *
*                   programming language.  It can be used as a       *
*                   supplement to complete rexx capabilities.        *
*                                                                    *
*   COMPONENT    -                                                   *
*                   IRXFLOC, Rexx Local Function Packages            *
*                                                                    *
*   TYPE         -                                                   *
*                   o  Executable load module                        *
*                   o  Reentrant, reusable and refreshable           *
*                                                                    *
*   PROCESSOR    -                                                   *
*                   Assembler H or HLASM                             *
*                                                                    *
*   ENVIRONMENT  -                                                   *
*                   MVS, TSO and ISPF of OS/390                      *
*                                                                    *
*   INSTALLATION NOTES -                                             *
*                                                                    *
*        o     Bind this module to appropriate IRXFLOC component     *
*              and generate aliases for all entrypoints, as shown    *
*              in the following example:                             *
*                                                                    *
*                //JDRXFLOC JOB (1,NIT),'ASSEMBLE IRXFLOC',          *
*                //      CLASS=A,MSGCLASS=X,                         *
*                //      REGION=4M,MSGLEVEL=(1,1),NOTIFY=&SYSUID     *
*                //    JCLLIB ORDER=NIT.PROCLIB                      *
*                //    EXEC ASSEMBLE,MBR=DRXFLOC,NAME=IRXFLOC,       *
*                //         APARM='OBJECT,NODECK,ALIGN,RENT',        *
*                //         LPARM='RENT,REUS,REFR,RMODE(ANY)'        *
*                //L.SYSIN   DD *                                    *
*                  ALIAS DRXEXP,                                     *
*                        DRXSIN,                                     *
*                        DRXCOS,                                     *
*                        DRXTAN,                                     *
*                        DRXCSC,                                     *
*                        DRXSEC,                                     *
*                        DRXCOT,                                     *
*                        DRXSINH,                                    *
*                        DRXCOSH,                                    *
*                        DRXTANH,                                    *
*                        DRXCSCH,                                    *
*                        DRXSECH,                                    *
*                        DRXCOTH,                                    *
*                        DRXSQRT,                                    *
*                        DRXLOG,                                     *
*                        DRXRAD,                                     *
*                        DRXLN,                                      *
*                        DRXPOWER,                                   *
*                        DRXFACT,                                    *
*                        DRXFRAC,                                    *
*                        DRXCOMB,                                    *
*                        DRXPERM                                     *
*                  NAME IRXFLOC(R)                                   *
*                /*                                                  *
*                                                                    *
*        o     Include all supporting macros in the SYSLIB           *
*                                                                    *
*        o     The accuracy and precision still studied until some   *
*              modification level in this release.   There is no     *
*              accuracy and precision update until this release      *
*              declared.                                             *
*                                                                    *
*        o     Some other functions such as arcsin(), arccos(), ect. *
*              to be available in next release.                      *
*                                                                    *
*                                                                    *
*   Macros and Data areas -                                          *
*                                                                    *
*        @RXCSECT  - local lib: Generate CSECT attributes            *
*        @RXENTRY  - local lib: Generate entrypoint prolog procedure *
*        @RXEXIT   - local lib: Generate exit epilog procedure       *
*        WTO       - system lib (SYS1.MACLIB): Display console msg   *
*        WORKSET   - inline savearea                                 *
*        ARGBLOK   - inline argument analysis area                   *
*        IRXARGTB  - system lib (SYS1.MACLIB): Argument table map    *
*        IRXPARMB  - system lib (SYS1.MACLIB): Parameter table map   *
*        IRXEVALB  - system lib (SYS1.MACLIB): Evaluation block map  *
*        IRXEFPL   - system lib (SYS1.MACLIB): Extended parameter    *
*        IHAEPIE   - system lib (SYS1.MACLIB): Program interrupt map *
*                                                                    *
*                                                                    *
*   ENTRY POINTS -                                                   *
*                                                                    *
*        DRXMATFN   -  Package program                               *
*        DRXEXP     -  EXP(x) function to return e**x                *
*        DRXSIN     -  SIN(x) function to return sin x               *
*        DRXCOS     -  COS(x) function to return cos x               *
*        DRXTAN     -  TAN(x) function to return tan x               *
*        DRXCSC     -  CSC(x) function to return csc x               *
*        DRXSEC     -  SEC(x) function to return sec x               *
*        DRXCOT     -  COT(x) function to return cot x               *
*        DRXSINH    -  SINH(x) function to return sinh x             *
*        DRXCOSH    -  COSH(x) function to return cosh x             *
*        DRXTANH    -  TANH(x) function to return tanh x             *
*        DRXCSCH    -  CSCH(x) function to return csch x             *
*        DRXSECH    -  SECH(x) function to return sech x             *
*        DRXCOTH    -  COTH(x) function to return coth x             *
*        DRXSQRT    -  SQRT(x) function to return V x                *
*        DRXLOG     -  LOG(x) function to return log x base 10       *
*        DRXLN      -  LN(x)  function to return log x base e        *
*        DRXPOWER   -  POWER(x,p) function to return x**p            *
*        DRXFACT    -  FACT(x) function to return x!                 *
*        DRXCOMB    -  COMB(N,x) function to return N!/(x! * (N-x)!) *
*        DRXPERM    -  PERM(N,x) function to return N!/(N-x)!        *
*                                                                    *
*   AUTHOR AND COPYRIGHT -                                           *
*                                                                    *
*   Author        -  Ir. DERU SUDIBYO                                *
*                    Freelance consultant                            *
*                    Nusantara IT Pro Club                           *
*                    Indonesia                                       *
*                                                                    *
*   Copyright     - (C) 1991-2004 Deru Sudibyo                       *
*                                                                    *
*                                                                    *
*   MODIFICATION LOG -                                               *
*                                                                    *
*   ---------------------------------------------------------------  *
*   No.| Date   |Level|   Engineer    | Description                  *
*   ---------------------------------------------------------------  *
*    1 |91/02/11|1.0.0| Deru Sudibyo  | 1st development              *
*    2 |91/03/21|1.1.0| Deru Sudibyo  | Declare release 1            *
*    3 |91/06/15|1.1.1| Deru Sudibyo  | implement ABNEXIT and SUBPOOL*
*    4 |91/06/20|1.1.1| Deru Sudibyo  | implement prog. int. FLIH    *
*    5 |93/10/20|1.1.2| Deru Sudibyo  | implement XA/ESA/XC adaptor  *
*    6 |04/02/01|2.1.0| Deru Sudibyo  | Change version for OS/390    *
*    7 |19/12/18|2.1.1| Danny Companez| Fix FRAC function            *
*   ---------------------------------------------------------------  *
*                                                                    *
*====================================================================*
         EJECT
DRXMATH  @RXCSECT amode=31,rmode=ANY runmode=TRACE
         using DRXMATH,R11,R12     Base addressability
         using WORKSET,R13         Map workset & savearea
         USING ARGBLOK,R9          Map argument parsing area
         USING EFPL,R10            Map extended parm list
         space 1
*--------------------------------------------------------------------*
*   FUNCTION CONSTANT SUPPORT COLLECTION                             *
*   Constant that frequently used in several calculation.            *
*   The main purpose is to reduce overhead instead of iterate        *
*   process to find them.                                            *
*--------------------------------------------------------------------*
         space 1
CONSTANT EQU   *
PHI      DC    D'3.141592654'
LN10     DC    D'2.302585093'
EXP1     DC    D'2.718281828'
ZERRO    DC    D'0'
ONE      DC    D'1'
CIRCLE   DC    D'360'
UNNORMSG DC    X'4E00000100000000'
UNNORM   DC    X'4E00000000000000'
CONSTLEN EQU   *-CONSTANT
         Eject
*--------------------------------------------------------------------*
*                                                                    *
*  RADIAN:   CALCULATE DEGREE TO RADIAN CONVERSION                   *
*                                                                    *
*   - Perform Rad(X) = inverse of 2 pi from degree                   *
*                                                                    *
*--------------------------------------------------------------------*
         SPACE 2
DRXRAD   @rxentry type=EP,base=DRXMATH
         mvc   function_address,=A(RADIAN)   assign RADIAN function
         B     FUNCEXE     perform Rad(X)
         SPACE 2
*--------------------------------------------------------------------*
*                                                                    *
*  FRAC   :   EXTRACT FRACTION                                       *
*                                                                    *
*--------------------------------------------------------------------*
         SPACE 2
DRXFRAC  @rxentry type=EP,base=DRXMATH
         MVC   Number_of_arg,=H'1'   Have 1 argument
         bas   R14,Get_1st_arg       check arguments
         LD    F0,ARGVALUE           get argument
         LDR   F2,F0                 duplicated
         AW    F2,#unnormal          unnormalized zero
         ad    F2,#zero              normalize result            2.1.1
         SDR   F0,F2                 subtract from the original  2.1.1
         STD   F0,ARGRSULT           save the result
         LA    R15,0                 Set good return code
         b     PRINT                 finally, print the output
         LTORG ,
         SPACE 2
*--------------------------------------------------------------------*
*                                                                    *
*  SIN   : CALCULATE SINUS FUNCTION                                  *
*                                                                    *
*     - Perform Sin(X) series computation                            *
*                                                                    *
*--------------------------------------------------------------------*
         SPACE 2
DRXSIN   @rxentry type=EP,base=DRXMATH
         MVC   function_address,=A(SINE)  assign SINE function
         MVI   Optional_arg_flag,Optional_arg_check  check option
         B     FUNCEXE                    perform Sin(X)
         SPACE 2
*--------------------------------------------------------------------*
*                                                                    *
*   COS   : CALCULATE COSINUS FUNCTION                               *
*                                                                    *
*     - Perform Cos(X) series computation                            *
*                                                                    *
*--------------------------------------------------------------------*
         SPACE 1
DRXCOS   @rxentry type=EP,base=DRXMATH
         mvc   function_address,=A(COSINE)  assign COSINE function
         MVI   Optional_arg_flag,Optional_arg_check  check option
         B     FUNCEXE                      perform Cos(X)
         SPACE 2
*--------------------------------------------------------------------*
*                                                                    *
*   TAN   : CALCULATE TANGEN FUNCTION                                *
*                                                                    *
*     - Perform Cos(X) series computation                            *
*   - Perform Sin(X) series computation                              *
*   - Calculate Tan(X) = Sin(X)/Cos(X)                               *
*                                                                    *
*--------------------------------------------------------------------*
         SPACE 1
DRXTAN   @rxentry type=EP,base=DRXMATH
         MVC   function_address,=A(SINE)     assign SINE function
         mvc   function2_address,=A(COSINE)  assign COSINE function
         MVI   Optional_arg_flag,Optional_arg_check  check option
         B     FUNCDIV                       perform Sin(X)/Cos(X)
         SPACE 2
*--------------------------------------------------------------------*
*                                                                    *
*   CSC   : CALCULATE COSECAN FUNCTION                               *
*                                                                    *
*   - Perform Sin(X) series computation                              *
*   - Calculate Csc(X) = 1/Sin(X)                                    *
*                                                                    *
*--------------------------------------------------------------------*
         SPACE 2
DRXCSC   @rxentry type=EP,base=DRXMATH
         MVC   function_address,=A(SINE)    assign SINE function
         MVI   Optional_arg_flag,Optional_arg_check  check option
         B     FUNCINV                      perform 1/Sin(X)
         SPACE 2
*--------------------------------------------------------------------*
*                                                                    *
*   SEC   : CALCULATE SECAN FUNCTION                                 *
*                                                                    *
*   - Perform Cos(X) series computation                              *
*   - Calculate Sec(X) = 1/Cos(X)                                    *
*                                                                    *
*--------------------------------------------------------------------*
         SPACE 1
DRXSEC   @rxentry type=EP,base=DRXMATH
         mvc   function_address,=A(COSINE)  assign COSINE function
         MVI   Optional_arg_flag,Optional_arg_check  check option
         B     FUNCINV                      perform 1/COS(X)
         SPACE 2
*--------------------------------------------------------------------*
*                                                                    *
*   COT   : CALCULATE COTANGEN FUNCTION                              *
*                                                                    *
*   - Perform Sin(X) series computation                              *
*   - Perform Cos(X) series computation                              *
*   - Calculate Cot(X) = Cos(X)/Sin(X)                               *
*                                                                    *
*--------------------------------------------------------------------*
         SPACE 1
DRXCOT   @rxentry type=EP,base=DRXMATH
         mvc   function_address,=A(COSINE)  assign COSINE function
         MVC   function2_address,=A(SINE)   assign SINE function
         MVI   Optional_arg_flag,Optional_arg_check  check option
         B     FUNCDIV                      perform Cos(X)/Sin(X)
         SPACE 2
*--------------------------------------------------------------------*
*                                                                    *
*   SINH : CALCULATE HYPERBOLIC SINE FUNCTION                        *
*                                                                    *
*   - Perform Sinh(X) computation                                    *
*                                                                    *
*--------------------------------------------------------------------*
         SPACE 1
DRXSINH  @rxentry type=EP,base=DRXMATH
         MVC   function_address,=A(SINH)    assign SINH function
         MVI   Optional_arg_flag,Optional_arg_check  check option
         B     FUNCEXE                      perform Sinh(X)
         SPACE 2
*--------------------------------------------------------------------*
*                                                                    *
*   COSH : CALCULATE HYPERBOLIC COSINE FUNCTION                      *
*                                                                    *
*   - Perform Cosh(X) computation                                    *
*                                                                    *
*--------------------------------------------------------------------*
         SPACE 1
DRXCOSH  @rxentry type=EP,base=DRXMATH
         MVC   function_address,=A(COSH)    assign COSH function
         MVI   Optional_arg_flag,Optional_arg_check  check option
         B     FUNCEXE                      perform Cosh(X)
         SPACE 2
*--------------------------------------------------------------------*
*                                                                    *
*   TANH : CALCULATE HYPERBOLIC TANGEN FUNCTION                      *
*                                                                    *
*   - Perform Cosh(X) computation                                    *
*   - Perform Sinh(X) computation                                    *
*   - Calculate Tanh(X) = Sinh(X)/Cosh(X)                            *
*                                                                    *
*--------------------------------------------------------------------*
         SPACE 1
DRXTANH  @rxentry type=EP,base=DRXMATH
         MVC   function_address,=A(SINH)     assign SINH function
         MVC   function2_address,=A(COSH)    assign COSH function
         MVI   Optional_arg_flag,Optional_arg_check  check option
         B     FUNCDIV                       perform Sinh(X)/Cosh(X)
         SPACE 2
*--------------------------------------------------------------------*
*                                                                    *
*   CSCH : CALCULATE HYPERBOLIC COSECAN FUNCTION                     *
*                                                                    *
*   - Perform Sinh(X) series computation                             *
*   - Calculate Csch(X) = 1/Sinh(X)                                  *
*                                                                    *
*--------------------------------------------------------------------*
         SPACE 2
DRXCSCH  @rxentry type=EP,base=DRXMATH
         MVC   function_address,=A(SINH)     assign SINH function
         MVI   Optional_arg_flag,Optional_arg_check  check option
         B     FUNCINV                       perform 1/Sinh(X)
         SPACE 2
*--------------------------------------------------------------------*
*                                                                    *
*   SECH : CALCULATE HYPERBOLIC SECAN FUNCTION                       *
*                                                                    *
*   - Perform Cosh(X) series computation                             *
*   - Calculate Sech(X) = 1/Cosh(X)                                  *
*                                                                    *
*--------------------------------------------------------------------*
         SPACE 1
DRXSECH  @rxentry type=EP,base=DRXMATH
         MVC   function_address,=A(COSH)    assign COSH function
         MVI   Optional_arg_flag,Optional_arg_check  check option
         B     FUNCINV                      perform 1/Cosh(X)
         SPACE 2
*--------------------------------------------------------------------*
*                                                                    *
*   COTH : CALCULATE HYPERBOLIC COTANGEN FUNCTION                    *
*                                                                    *
*   - Perform Sinh(X) computation                                    *
*   - Perform Cosh(X) computation                                    *
*   - Calculate Coth(X) = Cosh(X)/Sinh(X)                            *
*                                                                    *
*--------------------------------------------------------------------*
         SPACE 1
DRXCOTH  @rxentry type=EP,base=DRXMATH
         MVC   function_address,=A(COSH)     assign COSH function
         MVC   function2_address,=A(SINH)    assign SINH function
         MVI   Optional_arg_flag,Optional_arg_check  check option
         B     FUNCDIV                       perform Cosh(X)/Sinh(X)
         SPACE 2
*--------------------------------------------------------------------*
*                                                                    *
*   POWER : CALCULATE POWER                                          *
*                                                                    *
*   Power(X,P) - compute X**P = exp(P * ln(X))                       *
*                                                                    *
*--------------------------------------------------------------------*
         SPACE 1
DRXPOWER @rxentry type=EP,base=DRXMATH
         MVC   Number_of_arg,=H'2'   Have 2 arguments
         bas   R14,Get_1st_arg       check arguments
         LD    F0,ARGVALUE           get 1st argument -- X
         LTDR  F0,F0                 check
         BZ    DRXPZERO              go here if 0
         BM    ERRARGS               error if negative
         STD   F0,ARGVSAVE           save 1st argument
         MVC   ARGOVRSV,ARGOVRLY     save arg 1 overlay
         BAS   R14,Get_2nd_arg       obtain 2nd argument - P
         LD    F0,ARGVALUE           get 2nd argument  -- P
         LTDR  F2,F0                 check
         BZ    DRXPONE               if 0 then result must be 1
         LD    F0,ARGVSAVE           restore X (1st argument)
         STD   F2,ARGVSAVE           save p (2nd argument)
         BAS   R14,LN                calculate Ln(X)
         STD   F0,argrsult           save the result
         L     R15,ARGOVRSV          get the original overflow
         LTR   R15,R15               in case of there is
         BZ    DRXPWEXP              skip if none
         BAS   R14,FLOAT             if so, convert to fpoint
         MD    F0,#ln10              multiply to Ln(10)
         AD    F0,argrsult           :Ln(X * 1Enn) = Ln(X) + NN*Ln 10
DRXPWEXP EQU   *
         MD    F0,ARGVSAVE           calculate P * Ln(X)
         STD   F0,ARGVALUE           save the result
         BAS   R14,EXPON             now, compute exp(P * Ln(X))
DRXPRTRN EQU   *
         STD   F0,ARGRSULT           save the result
         b     PRINT                 Final routine address
         BR    R15                   Go there
DRXPZERO EQU   *
         LD    F0,=D'0'              zerro result
         B     DRXPRTRN              return
DRXPONE  EQU   *
         LD    F0,#one               one result
         B     DRXPRTRN              return
         LTORG ,
         SPACE 2
*--------------------------------------------------------------------*
*                                                                    *
*  ATAN   : CALCULATE ARCUS TANGEN FUNCTION                          *
*                                                                    *
*   Atan(X)     - calculate arctan x, where                          *
*                                 3    5              n-1  2n-1      *
*                      -1        z    z           (-1)    z          *
*                   tan  z = z - -- + -- -  ... + ------------ + ... *
*                                3    5              2n - 1          *
*                                                                    *
*--------------------------------------------------------------------*
         SPACE 1
DRXATAN  @rxentry type=EP,base=DRXMATH
         MVC   Number_of_arg,=H'1'   Have 1 argument
         bas   R14,Get_1st_arg       check arguments
         SDR   F0,F0                 clear
         LD    F2,ARGVALUE           get argument
         LD    F4,#one               subscript
ATANLOOP EQU   *
         STD   F0,ARGRSULT           save
         ADR   F0,F2
         MD    F2,ARGVALUE
         MD    F2,ARGVALUE           multiplied by X*X
         AD    F4,#one               add 1 to get next fact term
         DDR   F2,F4
         AD    F4,#one               +1 again to get next fact term
         DDR   F2,F4
         LCDR  F2,F2                 change sign
         CD    F0,ARGRSULT           is it any difference ?
         BNE   ATANLOOP              loop
         B     PRINT                 Final routine address
         LTORG ,
         SPACE 2
*--------------------------------------------------------------------*
*                                                                    *
*   LN   : CALCULATE NATURAL LOGARITHM                               *
*                                                                    *
*   - Perform Ln(X) based on Ln(1+z) series where abs(Z) < 1         *
*                                                                    *
*--------------------------------------------------------------------*
         SPACE 1
DRXLN    @rxentry type=EP,base=DRXMATH
         OI    Check_arg_flag,Arg_is_positive
         bas   R14,Calc_ln         calculate ln
         b     print
         LTORG ,
         SPACE 2
*--------------------------------------------------------------------*
*                                                                    *
*   LOG   : CALCULATE DECIMAL LOGARITHM                              *
*                                                                    *
*   - Perform Ln(X) based on Ln(1+z) series                          *
*   - Calculate Log(X) = Ln(X) / Ln(10)                              *
*                                                                    *
*--------------------------------------------------------------------*
         SPACE 1
DRXLOG   @rxentry type=EP,base=DRXMATH
         OI    Check_arg_flag,Arg_is_positive
         bas   R14,Calc_ln     calculate ln
         LD    F0,ARGRSULT     restore
         LD    F2,#ln10        ln(10)
         DDR   F0,F2           calculate Ln(X)/Ln(10)
         STD   F0,ARGRSULT     save the result
         LA    R15,0           Set good return code
         B     PRINT           Complete EVALBLOK & return
         LTORG ,
         SPACE 2
*--------------------------------------------------------------------*
*                                                                    *
*   EXP   : CALCULATE NATURAL EXPONENTIAL                            *
*                                                                    *
*   Exp(X)    - compute e**X                                         *
*   Absolute Floating point number range is .5E-78 to .7E+76         *
*                                                                    *
*   z  must be    -164.xxxx <= Z < 164.yyyy                          *
*                                                                    *
*    Input :  may be in form of X * 1Ennn (normally nnn = 0)         *
*             where X in F0 and nnn an ARGOVRLY field                *
*                                                                    *
*             in this case, we should calculate exp(X * 10~Z),       *
*             = (exp(X))~(10~Z)                                      *
*                                                                    *
*    References -                                                    *
*                                                                    *
*    Exp(A + B) = exp(A) * exp(B)                                    *
*         ___         ___                                            *
*    Exp( )   X  ) =  | | exp(X )                                    *
*         ---  i               i                                     *
*                                                                    *
*--------------------------------------------------------------------*
         SPACE 1
DRXEXP   @rxentry type=EP,base=DRXMATH
         MVC   Number_of_arg,=H'1'   Have 1 argument
         bas   R14,Get_1st_arg       check arguments
DRXEXPGO EQU   *
         LD    F0,ARGVALUE           get argument
         BAS   R14,EXPON             calculate exp(X)
         STD   F0,ARGRSULT           hold the X fraction
         B     PRINT                 finish
         LTORG ,
         SPACE 2
*--------------------------------------------------------------------*
*                                                                    *
*   FACT : CALCULATE FACTORIAL                                       *
*                                                                    *
*       Fact(X)    - compute X!                                      *
*                                                                    *
*--------------------------------------------------------------------*
         SPACE 1
DRXFACT  @rxentry type=EP,base=DRXMATH
         MVC   function_address,=A(FACT)  assign FACT function
         OI    Check_arg_flag,Arg_is_integer+Arg_is_positive
         B     FUNCEXE                    perform Fact(X)
         SPACE 2
*--------------------------------------------------------------------*
*                                                                    *
*   COMB : CALCULATE COMBINATION FACTOR                              *
*                                                                    *
*       Comb(X,Y)  - compute X! / (Y! * (X-Y)!)                      *
*                                                                    *
*--------------------------------------------------------------------*
         SPACE 1
DRXCOMB  @rxentry type=EP,base=DRXMATH
         MVC   Number_of_arg,=H'2'  Have 2 arguments
         OI    Check_arg_flag,Arg_is_integer+Arg_is_positive
         bas   R14,Get_1st_arg      check arguments
         LD    F0,ARGVALUE          get 1st argument
         LTDR  F0,F0                check
         BZ    DRXCRTRN             go here if 0
         BO    DRXCRTRN             go here if 1
         BM    ERRARGS              error if negative
         STD   F0,ARGVSAVE          save 1st argument   -- X
         MVC   ARGOVRSV,ARGOVRLY    save overflowed factor
         BAS   R14,Get_2nd_arg      obtain 2nd argument
         LD    F2,ARGVALUE          get 2nd argument -   Y
         LD    F0,ARGVSAVE          restore X (1st argument)
         LTDR  F6,F2                copy Y and check
         BZ    DRXCZERO             go here if 0
         BO    DRXCRTRN             go here if 1
         BM    ERRARGS              error if negative
         SDR   F0,F6                X - Y
         LTDR  F0,F0                check if negative
         BM    ERRARGS              error if negative
         STD   F0,ARGVHOLD          save X-Y
         L     R2,ARGOVRSV          get saved overflowed
         MVC   ARGOVRSV,ARGOVRLY    save overflowed factor
         ST    R2,ARGOVRLY          swap
         LD    F0,ARGVSAVE          restore X (1st argument)
         BAS   R14,FACT             calculate Fact(X)
         LD    F2,ARGVALUE          2nd argument
         MVC   ARGEXPSV,ARGEXPAN    save expansion factor
         XC    ARGEXPAN,ARGEXPAN    CLEAR
         MVC   ARGOVRLY,ARGOVRSV    restore overflowed factor
         STD   F0,ARGVSAVE          save X! value
         LDR   F0,F2                copy Y
         BAS   R14,FACT             calculate Fact(Y)
         LDR   F2,F0                result of Y!
         LD    F0,ARGVSAVE          value of X!
         DDR   F0,F2                value of X! / Y!
         STD   F0,ARGVSAVE          save it
         L     R2,ARGEXPSV          restore exp factor of X
         S     R2,ARGEXPAN          reduced by exp factor of Y
         ST    R2,ARGEXPSV          save
         XC    ARGEXPAN,ARGEXPAN    clear
         LD    F0,ARGVHOLD          X-Y
         BAS   R14,FACT             calculate Fact(X-Y)
         LDR   F2,F0                result of (X-Y)!
         LD    F0,ARGVSAVE          value of X! /Y!
         DDR   F0,F2                value of (X! /Y!) / (x-y)!
         STD   F0,ARGRSULT          save the final result
         L     R2,ARGEXPSV          restore exp factor of X
         S     R2,ARGEXPAN          reduced by exp factor of Y
         ST    R2,ARGEXPAN          save
DRXCRTRN EQU   *
         STD   F0,ARGRSULT          save the result
         LA    R15,0                Set good return code
         B     PRINT                Complete EVALBLOK & return
DRXCZERO EQU   *
         LD    F0,#one              zerro result
         B     DRXCRTRN             return
         SPACE 2
*--------------------------------------------------------------------*
*                                                                    *
*   PERM : CALCULATE PERMUTATION FACTOR                              *
*                                                                    *
*       Perm(X,Y)  - compute X! / (X-Y)!                             *
*                                                                    *
*--------------------------------------------------------------------*
         SPACE 1
DRXPERM  @rxentry type=EP,base=DRXMATH
         MVC   Number_of_arg,=H'2'    Have 2 arguments
         OI    Check_arg_flag,Arg_is_integer+Arg_is_positive
         bas   R14,Get_1st_arg        check arguments
         LD    F0,ARGVALUE            get 1st argument
         LTDR  F0,F0                  check
         BZ    DRXPERMX               go here if 0
         BO    DRXPERMX               go here if 0
         BM    ERRARGS                error if negative
         STD   F0,ARGVSAVE            save 1st argument   -- X
         MVC   ARGOVRSV,ARGOVRLY      save overflowed factor
         BAS   R14,Get_2nd_arg        obtain 2nd argument
         LD    F0,ARGVALUE            get 2nd argument
         LTDR  F0,F0                  X = val arg 1
         BZ    DRXPERMO               go here if 0
         BO    DRXPERMX               go here if 1
         BM    ERRARGS                error if negative
         LD    F2,ARGVSAVE            restore 1st argument
         SDR   F2,F0                  X - Y
         LTDR  F0,F2                  x-y must not < 0
         BM    ERRARGS                error if negative
*        std   f0,tempvar             hold it
         L     R2,ARGOVRSV            get saved overflowed
         MVC   ARGOVRSV,ARGOVRLY      save overflowed factor
         ST    R2,ARGOVRLY            swap
         BAS   R14,FACT               calculate Fact(X-Y)
         LD    F2,ARGVSAVE            get X
         MVC   ARGEXPSV,ARGEXPAN      save expansion factor
         XC    ARGEXPAN,ARGEXPAN      clear
         MVC   ARGOVRLY,ARGOVRSV      restore overflowed factor
         STD   F0,ARGVSAVE            save (X-Y)! value
         LDR   F0,F2                  get X
         BAS   R14,FACT               calculate Fact(X)
         DD    F0,ARGVSAVE            compute X! / (X-Y)!
         L     R2,ARGEXPAN            get exp factor of X
         S     R2,ARGEXPSV            reduced by exp factor of Y
         ST    R2,ARGEXPAN            save
DRXPERMX EQU   *
         STD   F0,ARGRSULT            save the result
         LA    R15,0                  Set good return code
         B     PRINT                  Complete EVALBLOK & return
DRXPERMO EQU   *
         LD    F0,#one                zerro quit
         B     DRXPERMX               return
         SPACE 2
*--------------------------------------------------------------------*
*                                                                    *
*   SQRT : CALCULATE SQUARE ROOT                                     *
*                                                                    *
*   Sqrt(X)    - compute X**0.5                                      *
*                                                                    *
*--------------------------------------------------------------------*
         SPACE 1
DRXSQRT  @rxentry type=EP,base=DRXMATH
         MVC   function_address,=A(SQROOT)  assign SQROOT function
         OI    Check_arg_flag,Arg_is_positive
         B     FUNCEXE                      perform Sqrt(X)
   EJECT
*--------------------------------------------------------------------*
*                                                                    *
*   FUNCTION EXECUTION                                               *
*                                                                    *
*   R7   - Address of Function routine                               *
*--------------------------------------------------------------------*
         SPACE 1
         DS    0D
FUNCEXE  EQU   *
         mvc   traceid,=cl8'FUNCEXE' set trace id
         aif   (not &trace).trace02
         icm   r0,b'1111',=x'22222222'
.trace02 anop
         MVC   Number_of_arg,=H'1'   Have 1 argument
         BAS   R14,Get_1st_arg       check argument
         aif   (not &trace).trace02a
         WTO   'DRX0012I Begin to execute function (FUNCEXE)..',       +
               routcde=(1,10)
.trace02a anop
         LD    F0,ARGVALUE          get argument
         L     R15,function_address get function routine addrees
         BASR  R14,R15              perform function routine
         STD   F0,ARGRSULT          save the result
         LA    R15,0                Set good return code
         B     PRINT                Complete EVALBLOK & return
         LTORG ,
         SPACE 2
*--------------------------------------------------------------------*
*                                                                    *
*   FUNCTION PER FUNCTION DIVISION WITH THE SAME VALUE               *
*                                                                    *
*   F0  <----  Func1(X) / Func2(X)                                   *
*    R7   - Adress of Func1 routine                                  *
*    R8   - Adress of Func2 routine                                  *
*--------------------------------------------------------------------*
         SPACE 1
         DS    0D
FUNCDIV  EQU   *
         mvc   traceid,=cl8'FUNCDIV' set trace id
         aif   (not &trace).trace03
         icm   r0,b'1111',=x'33333333'
.trace03 anop
         MVC   Number_of_arg,=H'1'   Have 1 argument
         BAS   R14,Get_1st_arg       check argument
         aif   (not &trace).trace03a
         WTO   'DRX0012I Begin to execute function 1 (FUNCDIV)..',     +
               routcde=(1,10)
.trace03a anop
         LD    F0,ARGVALUE          get argument
         L     R15,function2_address get function routine addrees
         BASR  R14,R15              perform FUNCTION 2 computation
         LTDR  F0,F0                check the result
         BZ    ERRARGS              error if 0
         STD   F0,ARGRSULT          save
         LD    F0,ARGVALUE          get argument
         MVC   ARGEXPSV,ARGEXPAN    save expansion factor
         XC    ARGEXPAN,ARGEXPAN    clear
         aif   (not &trace).trace03b
         WTO   'DRX0012I Begin to execute function 2 (FUNCDIV)..',     +
               routcde=(1,10)
.trace03b anop
         L     R15,function_address get function routine addrees
         BASR  R14,R15              perform FUNCTION 1 computation
         L     R15,ARGEXPAN         expansion factor
         S     R15,ARGEXPSV         expansion factor division
         ST    R15,ARGEXPAN
         DD    F0,ARGRSULT          divided by FUNCTION 2
         STD   F0,ARGRSULT          save result
         LA    R15,0                Set good return code
         B     PRINT                Complete EVALBLOK & return
         LTORG ,
         SPACE 2
*--------------------------------------------------------------------*
*                                                                    *
*   FUNCTION INVERSION                                               *
*                                                                    *
*   F0  <----  1 / Func(X)                                           *
*   R7   - Address of designated function routine                    *
*--------------------------------------------------------------------*
         SPACE 1
         DS    0D
FUNCINV  EQU   *
         mvc   traceid,=cl8'FUNCINV' set trace id
         aif   (not &trace).trace04
         icm   r0,b'1111',=x'44444444'
.trace04 anop
         MVC   Number_of_arg,=H'1'   Have 1 argument
         BAS   R14,Get_1st_arg       check argument
         aif   (not &trace).trace04a
         WTO   'DRX0012I Begin to execute function (FUNCINV)..',       +
               routcde=(1,10)
.trace04a anop
         LD    F0,ARGVALUE           get argument
         L     R15,function_address  get function routine addrees
         BASR  R14,R15               perform FUNCTION
         LTDR  F2,F0                 check
         BZ    ERRARGS               error if 0
         LD    F0,=D'1.0'
         DDR   F0,F2                 calculate 1/Func(X)
         STD   F0,ARGRSULT           save the result
         LA    R15,0                 Set good return code
         B     PRINT                 Complete EVALBLOK & return
         LTORG ,
         Space 1
        EJECT
*--------------------------------------------------------------*
*                                                              *
*   BASIC COMPUTATION SERVICE COLLECTION                       *
*                                                              *
*   1.   EXPONENTIAL series                                    *
*   2.   SINE series                                           *
*   3.   COSINE series                                         *
*   4.   NATURAL LOGARITHM series                              *
*   5.   FACTORIAL algorithm                                   *
*   6.   SQUARE ROOT algorithm                                 *
*   7.   HYPERBOLIC SINE computation                           *
*   8.   HYPERBOLIC COSINE computation                         *
*                                                              *
*                                                              *
*   Input    F0                                                *
*   Output   F0                                                *
*   Return ptr   R14                                           *
*                                                              *
*--------------------------------------------------------------*
         ds   0d
         space 1
*--------------------------------------------------------------------*
*                                                                    *
*   Calculate ln(X)                                                  *
*                                                                    *
*   To reduce computing time of Ln(1+z) algorithm, here the          *
*   value of X is converted to such Y * 1E+nn, where abs(Y) < 1      *
*   then calculate Ln(Y) + nn * Ln(10).                              *
*--------------------------------------------------------------------*
         space
Calc_ln  equ   *
         stm   R14,R1,rexx_sysregs_save Save system work regs
         MVC   Number_of_arg,=H'1'  Have 1 argument
         bas   R14,Get_1st_arg      check arguments
         LD    F0,ARGVALUE          get argument
         LTDR  F0,F0                check
         BNP   ERRARGS              error if not positive
         BAS   R14,CALCEXP          separate the exponent
         MD    F0,=D'10'            shift 1 digit to left
         LR    R15,R0               get exponent
         BCTR  R15,0                reduce 1 for compensation
         A     R15,ARGEXPAN         correct .....
         ST    R15,ARGEXPAN         .. the expansion factor
         BAS   R14,LN               perform LN routine
         STD   F0,ARGRSULT          save the result
         L     R15,ARGOVRLY         get the original overflow
         A     R15,ARGEXPAN         get the calculation overflow
         ST    R15,ARGEXPSV         save it
         XC    ARGEXPAN,ARGEXPAN    clear
         LTR   R15,R15              check
         BZ    Calc_ln_final        exit if nothing
         MVC   ARGUNNOR,#unnormal   calculate power overflow
         ST    R15,ARGUNLOW         hold value
         LD    F0,ARGUNNOR          attempt to ...
         MD    F0,#ln10             calculate z * Ln(10)
         LTR   R15,R15              test the sign
         BNM   Calc_ln_done         just quit if positive
         LCDR  F0,F0                change the sign
Calc_ln_done EQU *
         AD    F0,ARGRSULT          correct the result
         STD   F0,ARGRSULT          save the final result
Calc_ln_final equ *
         lm    R14,R1,rexx_sysregs_save restore system work regs
         LA    R15,0
         br    r14                  return
         SPACE 2
*--------------------------------------------------------------------*
*                                                                    *
*   Sin(X)     - calculate sin x, where                              *
*                                                                    *
*                                3    5              n-1  2n-1       *
*                               z    z           (-1)    z           *
*                   sin z = z - -- + -- -  ... + ------------ + ...  *
*                               3!   5!            (2n - 1)!         *
*                                                                    *
*--------------------------------------------------------------------*
   SPACE 2
         DS    0D
SINE     EQU   *
         mvc   traceid,=cl8'SINE'   set trace id
         CLI   Optional_arg,Arg_in_radian is arg in radian?
         BE    SINRAD               Yes, skip conversion
         ST    R14,ARGINADR
         BAS   R14,RADIAN           convert to radian
         L     R14,ARGINADR
SINRAD   EQU   *
         LTDR  F0,F0                so its mean the remainder
         BZR   R14                  return if 0
         LDR   F2,F0                get argument
         LDR   F6,F0                get argument
         MDR   F6,F2                calculate X**2
         SDR   F0,F0                clear
         LD    F4,#one              subscript
SINLOOP  EQU   *
         STD   F0,ARGTEMP           save T(i)
         ADR   F0,F2                T(i)  <--- T(i-1) + S(i-1)
         CD    F0,ARGTEMP           is it any difference ?
         BE    SINEQU               no, return
         MDR   F2,F6                S(i)  <--- S(i-1) * Z
         AD    F4,#one              d <-- d + 1,  next fact term
         DDR   F2,F4                enter menchanism
         AD    F4,#one               .. of ....
         DDR   F2,F4                S(i) <--- -1 * S(i) / (d*(d+1))
         LCDR  F2,F2                change sign
         B     SINLOOP              loop
SINEQU   EQU   *
         BR    R14                  and return
         LTORG ,
         SPACE 2
*--------------------------------------------------------------------*
*                                                                    *
*   Cos(X)     - calculate cos x, where                              *
*                                                                    *
*                                2    4              n-1  2n-2       *
*                               z    z           (-1)    z           *
*                   cos z = 1 - -- + -- -  ... + ------------ + ...  *
*                               2!   4!            (2n - 2)!         *
*                                                                    *
*--------------------------------------------------------------------*
   SPACE 2
         DS    0D
COSINE   EQU   *
         mvc   traceid,=cl8'COSINE'    set trace id
         CLI   Optional_arg,Arg_in_radian is arg in radian?
         BE    COSRAD               Yes, skip conversion
         ST    R14,ARGINADR
         BAS   R14,RADIAN           convert to radian
         L     R14,ARGINADR
COSRAD   EQU   *
         LDR   F6,F0                get argument
         MDR   F6,F0                obtain X**2
         LD    F0,#one              initialize 1st sequence
         LDR   F2,F0                initialize the sequence
         SDR   F4,F4                initialize divisor
COSLOOP   EQU   *
         STD   F0,ARGTEMP           save
         MDR   F2,F6                multiplied by X**2
         AD    F4,#one              add 1 to get next fact term
         DDR   F2,F4
         AD    F4,#one              +1 again to get next fact term
         DDR   F2,F4
         LCDR  F2,F2                change sign
         ADR   F0,F2                add next sequence
         CD    F0,ARGTEMP           is it any difference ?
         BNE   COSLOOP              loop if so
         BR    R14                  and return
         LTORG ,
         SPACE 2
*--------------------------------------------------------------------*
*                                                                    *
*   Ln(X)      - compute Ln x, where                                 *
*                                                                    *
*                                  2    3              n-1 n         *
*                                 z    z           (-1)   z          *
*                   ln(1+z) = z - -- + -- -  ... + ---------         *
*                                 2    3               n             *
*                                                                    *
*                   where abs(z) < 1                                 *
*                                                                    *
*--------------------------------------------------------------------*
         DS    0D
         SPACE 1
LN       EQU   *
         mvc   traceid,=cl8'LN'     set trace id
         LTDR  F2,F0             duplicate and check
         BNP   ERRARGS           error if not positive
         BZ    ERRARGS           error if 0
         LA    R3,1              initialize
         ST    R14,ARGSAV14      save return address
         std   f0,tempvar        save it for awhile
LNROOT   EQU   *
         CD    F0,=D'2.0'        is it > 2.0 ?
         BL    LNCALC            No, go perform it
         BAS   R14,SQROOT        calculate square root
         LA    R3,1(R3)          incremented index
         B     LNROOT            loop
LNCALC   EQU   *
         SD    F0,#one           reduce 1
         LDR   F6,F0             save as sequence factor
         LD    F2,#one           Y = 1
         SDR   F4,F4             i = 0
         SDR   F0,F0             S(0) = 0
LNLOOP   EQU   *
         STD   F0,ARGTEMP        save T(i)
         MDR   F2,F6             Y  <--- Y * Z
         AD    F4,#one           i  <--- i + 1
         LDR   F0,F2
         DDR   F0,F4             S(i) <--- Y/i
         LCDR  F2,F2             Y <--- -1 * Y
         AD    F0,ARGTEMP        T(i) <--- T(i-1) + (-1)~1 * S(i)
         CD    F0,ARGTEMP        any differences ?
         BNE   LNLOOP
LNCORR   EQU   *
         ld    f6,tempvar        restore saved value
*        LPDR  F6,F6
         CD    F6,#one           check against 1
         BNL   LNPOSTVE          go there if GE
         LNDR  F0,F0             change the sign to negative
         B     LNREADY           and proceed
LNPOSTVE EQU   *
         LPDR  F0,F0             change the sign to positive
LNREADY  EQU   *
         LPDR  F6,F0             get absolute value
         CD    F6,=D'1E75'       is it overflow ?
         BL    LNCORR1           no, proceed
         L     R15,ARGEXPAN      get expansion factor
         LA    R15,75(R15)       expand it
         ST    R15,ARGEXPAN      and save it
         DD    F0,=D'1E75'       shift it
LNCORR1   EQU   *
         BCT   R3,LNFACT         factorize
         L     R14,ARGSAV14      restore return address
         BR    R14               return
LNFACT   EQU   *
         MD    F0,=D'2.0'        correct to original value
         B     LNCORR            loop until perfict
         LTORG ,
         SPACE 2
*--------------------------------------------------------------*
*                                                              *
*  FACTORIAL Calculation                                       *
*                                                              *
*     Fact(X)  =  1 * 2 * .... * X   where X integer           *
*                                                              *
*--------------------------------------------------------------*
         DS    0D
   SPACE 2
FACT     EQU   *
         mvc   traceid,=cl8'FACT'   set trace id
         LTDR  F2,F0            check
         BM    ERRARGS          error if < 0
         BOR   R14              just return if 1
         BNZ   FACTGO           proccess if > 1
         LD    F0,#one          set to 1 if 0
         BR    R14              .. return
FACTGO   EQU   *
         XC    ARGCORRC,ARGCORRC   prepare correction factor
         AW    F2,#unnormal     unnormalized
         LCDR  F2,F2            change the sign
         ADR   F2,F0            added to origimal one
         LTDR  F2,F2            check the delta
         BNZ   ERRARGS          error if not integer
         LDR   F2,F0            copy input
FACTLOOP EQU   *
         SD    F2,#one          subtract 1
         LTDR  F2,F2            check the X-1
         BZ    FACTEND          end if 0
         MDR   F0,F2            multiply X * (X-1)
         STD   F0,ARGEXLOG      it is a black box
         B     FACTLOOP         loop
FACTEND  EQU   *
         L     R0,ARGCORRC      get correction factor if any
         A     R0,ARGEXPAN      suppose overflowed
         ST    R0,ARGEXPAN      record the overflow
         BR    R14              else, return
         LTORG ,
         SPACE 2
*-----------------------------------------------------------*
*                                                           *
*  SQUARE ROOT Calculation                                  *
*                                                           *
*  Formulae :                                               *
*               X    = ( X  + A/X ) / 2                     *
*                n+1      n      n                          *
*                                                           *
*-----------------------------------------------------------*
         DS    0D
         SPACE 2
SQROOT   EQU   *
         mvc   traceid,=cl8'SQROOT' set trace id
         LTDR  F0,F0             .. CHECK
         BM    ERRARGS           error if negative
         BZR   R14               return if 0
         LD    F4,#one           initiate F4
         CD    F0,#one           categories
         BH    SQRHIGH           high, handle it
SQRLOW   EQU   *
         CD    F0,=D'1E-2'       is it < 1/100 ?
         BH    SQREXEC           no, proceed
         DD    F0,=D'1E-2'       yes, multiplied by 100
         DD    F4,=D'10'         save root of 1/100
         B     SQRLOW            loop to recheck
SQRHIGH  EQU   *
         CD    F0,=D'1E2'        is it > 100 ?
         BL    SQREXEC           no, proceed
         DD    F0,=D'1E2'        yes, divided by 100
         MD    F4,=D'10'         save the root of 100
         B     SQRHIGH           loop to recheck
SQREXEC  EQU   *
         LDR   F6,F0             get input
         LDR   F2,F0             .. CHECK
         AD    F2,#one
         HDR   F2,F2             halves
SQLOOP   EQU   *
         LDR   F0,F2             save previous term value
         LDR   F2,F6             get input
         DDR   F2,F0             divide by prev term
         ADR   F2,F0             added by prev term value
         HDR   F2,F2             halves
         CDR   F2,F0             any differences ?
         BL    SQLOOP            yes, loop
         MDR   F0,F4             final
         BR    R14               else, return
         LTORG ,
         SPACE 2
*--------------------------------------------------------------*
*                                                              *
*    Sinh(X)   Calculation                                     *
*                                                              *
*   Sinh(X) = (exp(X) - exp(-X))/2                             *
*                                                              *
*--------------------------------------------------------------*
         DS    0D
   SPACE 2
SINH     EQU   *
         mvc   traceid,=cl8'SINH'  set trace id
         ST    R14,ARGSAV14        save return address
         CLI   Optional_arg,Arg_in_radian is arg in radian?
         BE    SINHRAD             Yes, skip conversion
         BAS   R14,RADIAN          convert to radian
SINHRAD  EQU   *
         STD   F0,ARGVSAVE         save argument
         BAS   R14,EXPON           calculate Exp(X)
         STD   F0,ARGVHOLD         hold the value
         LD    F0,ARGVSAVE         get argument
         LCDR  F0,F0               change sign
         BAS   R14,EXPON           calculate Exp(-X)
         LD    F2,ARGVHOLD         restore the held value
         SDR   F2,F0               calculate exp(X) - exp(-X)
         HDR   F0,F2               then halve it
         L     R14,ARGSAV14        restore return address
         BR    R14                 else, turn
         LTORG ,
         SPACE 2
*--------------------------------------------------------------*
*                                                              *
*    Cosh(X)   Calculation                                     *
*                                                              *
*   Cosh(X) = (exp(X) + exp(-X))/2                             *
*                                                              *
*--------------------------------------------------------------*
         DS    0D
   SPACE 2
COSH     EQU   *
         mvc   traceid,=cl8'COSH'  set trace id
         ST    R14,ARGSAV14        save return address
         CLI   Optional_arg,Arg_in_radian is arg in radian?
         BE    COSHRAD             Yes, skip conversion
         BAS   R14,RADIAN          convert to radian
COSHRAD  EQU   *
         STD   F0,ARGVSAVE         save argument
         BAS   R14,EXPON           calculate Exp(X)
         STD   F0,ARGVHOLD         hold the value
         LD    F0,ARGVSAVE         get argument
         LCDR  F0,F0               change sign
         BAS   R14,EXPON           calculate Exp(-X)
         AD    F2,ARGVHOLD         calculate exp(X) + exp(-X)
         HDR   F0,F0               then halve it
         L     R14,ARGSAV14        restore return address
         BR    R14                 else, turn
         LTORG ,
         SPACE 2
*--------------------------------------------------------------------*
*                           x                                        *
*   Exp(X)     - calculate e  , where                                *
*                                                                    *
*                                2    3            n                 *
*                   z           z    z            z                  *
*                  e  = 1 + z + -- + -- +  ... + ---  + ...          *
*                               2!   3!           n!                 *
*                                                                    *
*   Absolute Floating point number range is .5E-78 to .7E+76         *
*   so,                                                              *
*   z must be    -180.2948 <= Z < 174.6398                           *
*                                                                    *
*--------------------------------------------------------------------*
         DS    0D
EXPON    EQU   *
         mvc   traceid,=cl8'EXPON'  set trace id
         LA    R15,0              initialize R15, suppose t = 0
         LPDR  F2,F0              abs(X)
         BNZ   EXPCMPUT           compute if X not 0
         LD    F0,#one            exp(0) = 1
         BR    R14                then return
EXPCMPUT EQU   *
         CD    F2,=D'1E75'        is abs(X) > 1.0E+75 ?
         BH    ERRARGS            error if so
         CD    F2,=D'1E-75'       is abs(X) < 1.0E-75 ?
         BL    ERRARGS            error if so
         CD    F2,#one            is abs(X) > 1 ?
         BNH   EXPNORM            no, normal way, Z = X
         stm   R14,R1,work_sysregs_save Save system work regs
         BAS   R14,CALCEXP        factorize into Z * 1.0Et
         lm    R14,R15,work_sysregs_save restore system work regs
         STD   F6,ARGTEMP         save exponentfactor 1.0Et
         LR    R15,R0             get exponen, t
         LM    R0,R1,ARGTEMP      save1.0Et on R0 and R1
EXPNORM  EQU   *
         XC    ARGCORRC,ARGCORRC  always prepare correction factor
         LDR   F2,F0              S(1) = Z
         LDR   F6,F0              save T(1)
         SDR   F4,F4              i = 0
         LD    F0,#one            T(0) = 1
EXPLOOP  EQU   *
         STD   F0,ARGTEMP         save T(i)
         AD    F4,#one            i <-- i + 1
         DDR   F2,F4              m(i) <--- m(i) / i
         ADR   F0,F2              s(i) <--- s(i) + m(i)
         CD    F0,ARGTEMP         is it any difference ?
         BE    EXPLEAVE           no, leave the loop
         MDR   F2,F6              m(i+1) <--- m(i) * Z
         B     EXPLOOP            loop
EXPLEAVE EQU   *
         LTDR  F2,F0              check if 0
         BZR   R14                return if exp(Z) = 0
         STM   R0,R1,ARGTEMP
         LD    F6,ARGTEMP         check exponentof argument
         LTR   R15,R15            return if t = 0
         BZR   R14                go ahead if it normal
         BNM   EXPCORR
         LD    F6,#one            inverse it
         DD    F6,ARGTEMP
         LD    F2,#one            inverse it
         DDR   F2,F0
EXPCORR   EQU   *
         AW    F6,#unnormal       unnormalize
         STD   F6,ARGUNNOR
         LD    F0,#one
         L     R1,ARGUNLOW        set loop index
EXPFINAL EQU   *
         MDR   F0,F2              powered
         STD   F0,ARGEXLOG        save for blackbox
         BCT   R1,EXPFINAL        loop
         L     R0,ARGCORRC        powered
         A     R0,ARGEXPAN        suppose overflowed
         ST    R0,ARGEXPAN        record the overflow
         BR    R14                return
         LTORG ,
         SPACE 2
*--------------------------------------------------------------------*
* RADIAN COMPUTATION METHOD                                          *
*                                                                    *
*   Z = Mod(X / 360) * 2 * pi                                        *
*                                                                    *
*                                                                    *
*--------------------------------------------------------------------*
         SPACE 2
         DS    0D
RADIAN   EQU   *
         mvc   traceid,=cl8'RADIAN'  set trace id
         LDR   F6,F0               get/save input
         DD    F6,#360             divided by maximum circle degree
         AW    F6,#unnormal        unnormalized
         MD    F6,#360             multiply back
         LCDR  F6,F6               change the sign
         ADR   F0,F6               obtain the remainder of X/360
         MD    F0,#pi              obtain radian value= 2 * X * PI
         DD    F0,=D'180'
         lpdr  f0,f0               get absolute value
         BR    R14                 return
         LTORG ,
         SPACE 2
*--------------------------------------------------------------------*
*  CONCERT INTEGER INTO FLOATING POINT                               *
*   Input - Fullword binary in R15                                   *
*   Output - FPOINT in F0                                            *
*--------------------------------------------------------------------*
         DS    0D
         SPACE 2
FLOAT    EQU   *
         mvc   traceid,=cl8'FLOAT'    set trace id
         MVC   ARGUNNOR(4),#unnormsg  initialize f.point field
         ST    R15,ARGUNLOW           store as low order unnormalized
         LD    F0,ARGUNNOR            unnormalized f.point value
         AD    F0,=D'0'               normalized
         LTR   R3,R3                  check sign
         BNMR  R14                    return if not negative
         LCDR  F0,F0                  else, change sign
         BR    R14                    return
         LTORG ,
         SPACE 2
*--------------------------------------------------------------------*
*  exponentcalculation handling                                      *
*                                                                    *
*--------------------------------------------------------------------*
         DS    0D
CALCEXP  EQU   *
         mvc   traceid,=cl8'CALCEXP'   set trace id
*        b     Calculate_Exponent      go to routine address
         L     R15,=A(Calculate_Exponent) routine address
         BR    R15                     Jump over there
         ltorg ,
         SPACE 2
*--------------------------------------------------------------------*
*  Result printing handling                                          *
*                                                                    *
*--------------------------------------------------------------------*
         DS    0D
PRINT    EQU   *
         mvc   traceid,=cl8'PRINT'     set trace id
*        b     Print_result            Go to the Routine address
         L     R12,=A(Print_result)    Routine address
         BR    R12                     Jump over there
         ltorg ,
         SPACE 2
*--------------------------------------------------------------------*
*  Error handling                                                    *
*   return to the system with RC = 4                                 *
*--------------------------------------------------------------------*
ERRARGS  EQU   *                Argument(s) are invalid
         b     Wrong_arg
*        L     R15,=A(Wrong_arg)
*        BR    R15
   EJECT
   TITLE 'LOCFN: Common get ARGUMENT subroutine'
*--------------------------------------------------------------*
* This subroutine obtains an ARGUMENT from ARGLIST             *
* The assumed input is :                                       *
*   - R1 : Address of ARGUMENT in ARGLIST                      *
*   - R14: return address                                      *
*                                                              *
* Argument string expected :                                   *
*   'nnn.mmmmmmmE+ee'                                          *
*   but sometimes can be ' - nn.mmmmmmmmmE-ee  '               *
*                                                              *
* Work (may distroyed)                                         *
*   R3, R4, and R15                                            *
*                                                              *
* The output:                                                  *
*   - ARGVALUE: argument in floating point form                *
*   - R1 : point to storage consist of floating point form     *
*   - R0 : amount of doublewords of storage                    *
*   - other registers are unchanged.                           *
*                                                              *
* If storage is not available, an error message is displayed   *
* and return is taken to the caller with a non-zero return     *
* code.                                                        *
*--------------------------------------------------------------*
         DS    0D
         SPACE 2
Get_1st_arg EQU *
         mvc   traceid,=cl8'GET1ARG' set trace id
         using argtable_entry,r1   map argument table entry
         l     r1,efplarg           access arg list
         cli   0(r1),x'FF'           end of table ?
         be    ERRARGS              yes, error
         l     r15,argtable_argstring_length length of argument
         l     r2,argtable_argstring_ptr pointer of argument
         XC    ARGBLOK(ARGAREAL),ARGBLOK nullify
         MVC   ARGCONST(ARGCONSL),CONSTANT constant collection
         MVC   ARGUNNOR(4),#unnormal initialize f.point field
         b     Check_option          check option
Get_2nd_arg EQU *
         mvc   traceid,=cl8'GET2ARG' set trace id
         l     r1,efplarg
         la    r1,argtable_next
         cli   0(r1),x'FF'           end of table ?
         be    ERRARGS              yes, error
         l     r15,argtable_argstring_length length of argument
         l     r2,argtable_argstring_ptr pointer of argument
         b     Get_arg               begin to get argument
Check_option   EQU *
         CLI   Optional_arg_flag,Optional_arg_check  need to check?
         bne   Get_arg               no, begin to get argument
         la    r1,argtable_next
         CLC   Number_of_arg,=H'2'   Have 2 arguments ?
         bl    Get_option            no, begin to get option
         la    r1,argtable_next
Get_option    EQU *
         cli   0(r1),x'FF'           end of table ?
         BE    Default_option        Yes, use default option
         l     r1,argtable_argstring_ptr pointer of argument
         OI    0(R1),X'40'           Make it uppercase
         Cli   0(R1),Arg_in_radian   radian?
         bne   Default_option        No, use default option instead
         MVI   Optional_arg,Arg_in_radian Yes, set option = radian
         b     Get_arg               Begin to get argument
Default_option EQU *
         MVI   Optional_arg,Arg_in_degree default option = degree
Get_arg  EQU *
*        mvc   traceid,=cl8'GET_ARG' set trace id
         st    r2,Arg_address        Save current arg address
         st    r15,Arg_length         and current its length
         aif   (not &trace).trace05
         icm   r0,b'1111',=x'55555555'
.trace05 anop
         drop  r1
         ST    R14,ARGSAV14          save linkage pointer
         stm   R14,R1,work_sysregs_save Save system work regs
         espie SET,ESPIE_exit,(12,13,15)  Set SLIH exit for pgm
         lm    R14,R1,work_sysregs_save restore system work regs
         XR    R4,R4                 clear integer length counter
         XR    R3,R3                 clear mantissa length counter
GETSTART EQU   *
         aif   (not &trace).next1
         lr    R8,R15
         mvc   tracetxt(l'tracetxt1),tracetxt1
         la    r1,tracetxt+l'tracetxt1
         ex    r1,gettrace
         la    r15,l'tracetxt1(R15)
         sth   R15,tracemsg
         WTO   'DRX0002I Parsing arguments in progress...',            +
               routcde=(1,10)
         la    r7,tracemsg
         mvc   wtolist(wtolistl),tracewtol
         la    r1,wtolist
         wto   text=(r7),mf=(E,(r1))
         lr    R15,R8
         b     gettrc_ok
gettrace mvc   tracetxt+l'tracetxt1(*-*),0(r2)
tracewtol wto  text=,routcde=(1,10),mf=L
tracetxt1 dc   C'Argument is: '
          ds   0h
gettrc_ok equ  *
.next1   anop
         lr    r1,r2                 argument address
         XR    R2,R2                 clear exponentlength counter
GETloop  EQU   *
         CLI   0(R1),C' '            is it blank ?
         BNE   GETINTGR              no, begin
         LA    R1,1(R1)              next digit
         BCT   R15,GETloop           loop
         B     Wrong_arg             else, no argument
GETINTGR EQU   *
         MVC   ARGVINIT,=D'-1'       prepare ...
         CLI   0(R1),C'-'            is it negative sign ?
         BE    Check_minus_sign      Yes, check whether not allowed
         MVC   ARGVINIT,#one         prepare ...
         CLI   0(R1),C'+'            is it positif sign ?
         BE    GETINSKP              YES, TAKE IT
GETINTG1 EQU   *
         CLI   0(R1),C' '            is it blank ?
         BE    GETINSKP              yes, skip it
         CLI   0(R1),C'0'            is it the smallest value ?
         BNE   GETINTOK              NO, DO FURTHER CHECKING
GETINSKP EQU   *
         LA    R1,1(R1)              next digit
         BCT   R15,GETINTG1          loop
         B     GETFINIS              finish if no more
Check_minus_sign equ *
         TM    Check_arg_flag,Arg_is_positive   Must it positive?
         BO    Wrong_arg             Yes, wrong arg!
         b     GETINSKP
GETINTOK EQU   *
         LA    R6,8                  maximum 8 digits
         ST    R1,ARGINADR           save
GETINNXT EQU   *
         CLI   0(R1),C' '            is it blank ?
         BE    GETFINIS              yes, finish
         CLI   0(R1),C'.'            is it decimal point ?
         BE    Check_dot_sign        yes, check whether must integer
         CLI   0(R1),C'E'            is it EXPONential sign ?
         BE    GETEXPON              yes, take exponential part
         CLI   0(R1),C'e'            is it EXPONential sign ?
         BE    GETEXPON              yes, take exponential part
         CLI   0(R1),C'9'            is it the largest value ?
         BH    Wrong_arg              > 9, error
         CLI   0(R1),C'0'            is it the smallest value ?
         BL    Wrong_arg              < 0, error
GETINVAL EQU   *
         LA    R4,1(R4)              count
         LA    R1,1(R1)              next digit
         BCT   R6,GETINVSQ
         ST    R1,ARGFRADR           save
         LTR   R8,R15
         BZ    GETFINIS              finish if no more
GETINOVR EQU   *
         CLI   0(R1),C' '            is it blank ?
         BE    GETINOV1              yes, finish
         CLI   0(R1),C'.'            is it decimal point ?
         BE    GETINOV2              yes, finish
         CLI   0(R1),C'E'            is it EXPOential sign ?
         BE    GETINOV1              yes, finish
         CLI   0(R1),C'e'            is it EXPOential sign ?
         BE    GETINOV1              yes, finish
         LA    R1,1(R1)              next digit
         L     R6,ARGOVRLY           overlay counter
         LA    R6,1(R6)              count overlay
         ST    R6,ARGOVRLY           save counter
         BCT   R8,GETINOVR
GETINOV1 EQU   *
         L     R1,ARGFRADR           restore fraction start address
         LA    R6,0                  maximum 9 digits
         B     GETFRNXT              start fraction loop
GETINOV2 EQU   *
         MVC   0(1,R1),1(R1)         left shift per byte
         LA    R1,1(R1)              next digit
         BCT   R8,GETINOV2           loop
         BCT   R15,GETINOV1          finish, attempt to exit
         B     GETFINIS              else, finish
GETINVSQ EQU   *
         BCT   R15,GETINNXT          loop
         B     GETFINIS              else, finish
Check_dot_sign equ *
         TM    Check_arg_flag,Arg_is_integer  Must it integer?
         BO    Wrong_arg             Yes, wrong arg!
GETFRACT EQU   *
         LA    R6,9                  maximum 9 digits
         LA    R1,1(R1)              next digit
         ST    R1,ARGFRADR           save
         BCT   R15,GETFRNXT
GETFRNXT EQU   *
         CLI   0(R1),C' '            is it blank ?
         BE    GETFINIS              yes, finish
         CLI   0(R1),C'E'            is it EXPONential sign ?
         BE    GETEXPON              yes, take exponential part
         CLI   0(R1),C'e'            is it EXPONential sign ?
         BE    GETEXPON              yes, take exponential part
         CLI   0(R1),C'9'            is it the largest value ?
         BH    Wrong_arg              > 9, error
         CLI   0(R1),C'0'            is it the smallest value ?
         BL    Wrong_arg              < 0, error
GETFRVAL EQU   *
         LA    R1,1(R1)              next digit
         BCT   R6,GETFRVCK            trick
         LA    R6,1                   .. to ..
         BCT   R15,GETFRNXT             .. ignore the rest
         B     GETFINIS              else, finish
GETFRVCK EQU   *
         LA    R3,1(R3)              count
         BCT   R15,GETFRNXT          loop
         B     GETFINIS              else, finish
GETEXPON EQU   *
         LA    R6,9                  maximum 9 digits
         LA    R1,1(R1)              NEXT 2 DIGIT
         ST    R1,ARGEXADR           save
         BCTR  R15,0
         CLI   0(R1),C'+'            is it positif sign ?
         BE    GETEXVAL              yes, take it
         CLI   0(R1),C'-'            is it negative sign ?
         BE    GETEXVAL              yes, take it
         BCTR  R6,0                  backward 1 digit
GETEXNXT EQU   *
         CLI   0(R1),C' '            is it decimal point ?
         BE    GETFINIS              yes, finish
         CLI   0(R1),C'9'            is it the largest value ?
         BH    Wrong_arg              > 9, error
         CLI   0(R1),C'0'            is it the smallest value ?
         BL    Wrong_arg              < 0, error
GETEXVAL EQU   *
         LA    R1,1(R1)              next digit
         BCT   R6,GETEXVCK
         LA    R6,1
         BCT   R15,GETEXNXT          LOOP
         B     GETFINIS              else, finish
GETEXVCK EQU   *
         LA    R2,1(R2)              count
         BCT   R15,GETEXNXT          loop
GETFINIS EQU   *
         ST    R4,ARGINLEN
         ST    R3,ARGFRLEN
         ST    R2,ARGEXLEN
         SDR   F0,F0                 initialize argument value
         STD   F0,ARGVALUE           save the value
         LA    R3,1                  default factor
         STH   R3,ARGINFAC            .... for integral
         STH   R3,ARGEXFAC            .... for integral
CONVINTG EQU   *
         LM    R1,R2,ARGINADR        get integral val addr/length
         LTR   R2,R2                 check the length
         BNP   CONVFRAC              nothing, skip
         stm   R14,R1,work_sysregs_save Save system work regs
         BAS   R14,CONVFPNT          convert f.point value
         lm    R14,R15,work_sysregs_save Restore system work regs
         STH   R3,ARGINFAC           save integral factor
         STD   F0,ARGVALUE           save the value
CONVFRAC EQU   *
         LM    R1,R2,ARGFRADR        get fraction val addr/length
         LTR   R2,R2                 check the length
         BNP   CONVEXPO              nothing, skip
         MVC   ARGSOURC,=12C'0'
         LTR   R2,R2                 check again
         BNO   CONVFRGO              jump around if > 1
CONVFR01 EQU   *
         MVC   ARGSOURC(1),0(R1)
         B     CONVFR02
CONVFRGO EQU   *
         BCTR  R2,0                  reduce for EX
         EX    R2,MOVEARG            execute mover
         LA    R1,ARGSOURC
CONVFR02 EQU   *
         LA    R2,9                  maximum 9 digits
         BAS   R14,CONVFPNT          convert f.point value
         DD    F0,=D'1E9'            scale fractional portion
         AD    F0,ARGVALUE           add integral value
         STD   F0,ARGVALUE           save the value
CONVEXPO EQU   *
         LM    R1,R2,ARGEXADR        get exponent val addr/length
         LA    R3,1                  initialize factor
         LNR   R3,R3                 negative factor
         LTR   R2,R2                 check the length
         BNP   GETVDONE              NOTHING, SKIP
         CLI   0(R1),C'-'            is there '-' sign ?
         BE    CONVEXSG              yes,, negative signed number
         LPR   R3,R3                 positive factor
         CLI   0(R1),C'+'            is there '+' sign ?
         BNE   CONVEXCK              no, just proceed and assume '+'
CONVEXSG EQU   *
         LA    R1,1(R1)              skip the number
         BCTR  R2,0                  so, reduce length as well
CONVEXCK EQU   *
         STH   R3,ARGEXFAC           corrected integral factor
         BCTR  R2,0                  correct for EX
         LTR   R2,R2                 check again
         BM    CONVPOWR              IGNORE IF < 0
         BP    CONVEXPC              proceed if > 0
         PACK  ARGTEMP(8),0(1,R1)    special case
         B     CONVEXGO              proceed
CONVEXPC EQU   *
         EX    R2,PACKARG
CONVEXGO EQU   *
         CVB   R2,ARGTEMP            convert to binary
CONVPOWR EQU   *
         A     R2,ARGOVRLY           overlaid counter added
         MH    R2,ARGEXFAC           factorized the exponent
         XC    ARGOVRLY,ARGOVRLY     clear
         CH    R2,=H'75'             overflow ?
         BL    GETVPOWU              no, continue
         LR    R4,R2                 Exponent
         LA    R2,75                 set R2 = 75
         SR    R4,R2                 recalculate overflow factor
         ST    R4,ARGOVRLY           and save it
         B     GETVPOWF              continue
GETVPOWU   EQU   *
         CH    R2,=H'-76'            underflow ?
         BH    GETVPOWF               no, continue
         LR    R4,R2                 Exponent
         LH    R2,=H'-76'            set R2 = -76
         SR    R4,R2                 recalculate underflow factor
         ST    R4,ARGOVRLY           and save it
GETVPOWF EQU   *
         LTR   R2,R2                 test the value
         BZ    GETVDONE              zerro - done
         LA    R4,POSVALS            exponential positive table
         BP    GETVPOWX
         LA    R4,NEGVALS            exponential negative table
GETVPOWX EQU   *
         LPR   R2,R2                 absolute
         SRDA  R2,3                  exponent divided by 8
         SRL   R3,29                 division remainder
         SLL   R3,3                  index to power 10**J, J=0,1..7
         LD    F2,0(R3,R4)           F2 = 10**X
         SLA   R2,3                  8 + index to power 10**J
         BZ    GETVPOW1              skip if 0
         LA    R4,64(R4)             access 2nd part of table
         MD    F2,56(R2,R4)          multiply to previous value
GETVPOW1 EQU   *
         MDR   F0,F2                 multiply scale factor
GETVDONE EQU   *
         MD    F0,ARGVINIT           correct with initial value
         STD   F0,ARGVALUE           save the final value
         aif   (not &trace).next2
         WTO   'DRX0003I Parsing arguments completed.',                +
               routcde=(1,10)
.next2   anop
         LA    R1,ARGVALUE           point to value field
         L     R14,ARGSAV14          restore linkage pointer
         BR    R14                   return to caller
         SPACE
CONVFPNT EQU   *
         SDR   F0,F0                 initialize value
         LA    R3,1                  initialize factor
         LNR   R3,R3                 negative factor
         CLI   0(R1),C'-'            is there '-' sign ?
         BE    CONVFPSG              yes negative signed number
         LPR   R3,R3                 positive factor
         CLI   0(R1),C'+'            is there '+' sign ?
         BNE   CONVFPCK              no, just proceed and assume '+'
CONVFPSG EQU   *
         LA    R1,1(R1)              skip the number
         BCTR  R2,0                  so, reduce length as well
CONVFPCK EQU   *
         BCTR  R2,0                  reduce for EX instruction
         LTR   R2,R2                 check adjusted length
         BMR   R14                   just exit if negative
         BP    CONVFPGO              proceed if > 0
         PACK  ARGTEMP(8),0(1,R1)    otherwise (0), means 1 digit
         B     CONVFBIN              and skip EX
CONVFPGO EQU   *
         EX    R2,PACKARG            pack to decimal
CONVFBIN EQU   *
         CVB   R2,ARGTEMP            convert to binary
         LPR   R2,R2                 absolute value
         MVC   ARGUNNOR,#unnormal    put floating point indicator
         ST    R2,ARGUNLOW           store as low order unnormalized
         LD    F0,ARGUNNOR           unnormalized f.point value
         AD    F0,#zero              normalized
         LTR   R3,R3                 check sign
         BNMR  R14                   return if not negative
         LCDR  F0,F0                 else, change sign
         BR    R14                   return
PACKARG  PACK  ARGTEMP(8),0(*-*,R1)   << EXECUTED >>
MOVEARG  MVC   ARGSOURC(*-*),0(R1)    << EXECUTED >>
         SPACE
Wrong_arg Equ  *
         WTO   'DRX0011E Error/invalid argument is detected',          +
               routcde=(1,10)
         oi    Check_arg_flag,Arg_is_error  mark Arg in error
         mvc   ARGRSULT,ARGVALUE
         bas   r14,Print_Error
         mvc   wtolist(wtolistl),errwtol
         mvc   tracetxt(l'errtxt),errtxt
         mvc   tracetxt+l'errtxt(l'traceid),traceid
         mvc   tracetxt+l'errtxt+l'traceid(5),=cl5' is: '
         mvc   tracetxt+l'errtxt+l'traceid+5(FPNTLEN),ARGSOURC
         mvi   tracetxt+l'errtxt+l'traceid+5+FPNTLEN,c'/'
         l     r7,Arg_address         current arg address
         l     r1,Arg_length          and current its length
         bctr  r1,0
         ex    r1,errmvc              take the original arg
         la    r15,l'errtxt+l'traceid+7+FPNTLEN total WTO length
         la    R15,1(R1,R15)          adjust the value
         sth   R15,tracemsg           put it in WTO area
         la    r7,tracemsg            point to WTO msg
         la    r1,wtolist             point to WTO list area
         wto   text=(r7),mf=(E,(r1))  Issue WTO
         xr    R15,r15                Zap RC
         b     Quit_with_error        Quit
errwtol  wto  text=,routcde=(1,10),mf=L
errmvc mvc tracetxt+l'errtxt+l'traceid+7+FPNTLEN(*-*),0(r7)
errtxt   dc   C'DRX0111E Argument value at '
Quit_with_error ds 0h
         la    r15,4            set rc = 4
         @rxexit rc=YES         return to the system
         DS    0D
POSVALS  EQU   *
         DC    D'1,1E1,1E2,1E3,1E4,1E5,1E6,1E7'
         DC    D'1E8,1E16,1E24,1E36,1E40,1E48,1E56,1E64,1E72'
NEGVALS  EQU   *
         DC    D'1,1E-1,1E-2,1E-3,1E-4,1E-5,1E-6,1E-7'
         DC    D'1E-8,1E-16,1E-24,1E-36,1E-40,1E-48,1E-56,1E-64,1E-72'
         SPACE 1
Print_Error equ *
         stm   R0,R15,tracesv               save all regs
         l     r12,=A(Print_result)
         br    r12
*        b     Print_result
         LTORG ,
*        drop  r7
         DS    0D
         SPACE 1
   EJECT
   TITLE 'LOCFN: Common obtain EVALBLOK subroutine'
*--------------------------------------------------------------*
* OBTAIN AND PRODUCE FUNCTION VALUE                            *
*                                                              *
*   o   Convert function returned value in ARGBLOK             *
*               into EBCDIC string                             *
*   o   Reuse ARGBLOK as EVALBLOK, so no need to               *
*               re obtain free storage                         *
*   o   Fill in EBCDIC result into EVALBLOK                    *
*   o   Chain EVALBLOK address in the return pointer           *
*   o   The caller is responsible to cleanup EVALBLOK          *
*                                                              *
*--------------------------------------------------------------*
         SPACE 2
         DS    0D
         drop  R11,r12
Print_result   EQU   *
         using Print_result,r12      set local addressability
         USING Evalblock,R7          Map of Evalblock
         aif   (not &trace).next3
         WTO   'DRX0004I Editing result in progress...',               +
               routcde=(1,10)
.next3   anop
         aif   (not &trace).trace06
         icm   r0,b'1111',=x'66666666'
.trace06 anop
         L     R7,EFPLEVAL           address of evalblock pointer
         L     R7,0(,R7)             Obtain Evalblock
         mvi   Evalblock_EVDATA,C' ' put a blank to be rolled up
         mvc   Evalblock_EVDATA+1(FPNTLEN-1),Evalblock_EVDATA
         MVI   FRACSIGN,PRINTPOS     default is positive sign
         MVC   FRACINTG,=C'0.'
         MVI   EXPOMARK,C'E'
         LD    F0,ARGRSULT            result in long form
         BAS   R14,Calculate_Exponent calculate exponentnumber
         LTDR  F0,F0                 check the result
         BZ    PRTZERO               go here if 0
         BO    PRTONE                else, just print 1.0
         LPDR  F4,F0                 absolute fraction base only
         SDR   F0,F0
         LRER  F0,F4
         LPER  F4,F0                 short absolute fraction base
         LR    R3,R0                 get exponentnumber
PRTSCALE EQU   *
         ME    F4,=E'1E9'            get 1st 9 digits
         AW    F4,#unnormal          isolate 1st 9 digits
         STD   F4,ARGUNNOR           save it
         L     R6,ARGUNLOW           get integer form 1st 9 digits
         LPR   R1,R6                 check
         C     R1,=F'000100000'      is mantissa significant ?
         BNL   PRTSCLGO              ya, go
         ME    F0,=E'1000'           no, multiplied to 10,000
         LPER  F4,F0                 absolute adjusted fraction
         SH    R3,=H'3'              exponent reduced by factor of 4
         B     PRTSCALE              rescaling
PRTSCLGO   EQU   *
         CVD   R6,ARGTEMP            convert to package decimal
         OI    ARGTEMP+7,X'0F'       switch decimal offset
         UNPK  FRACNUM,ARGTEMP       convert to EBCDIC
         LA    R1,FRACLEN            data length w/o exponent part
         A     R3,ARGEXPAN           add expansion factor
         LTR   R3,R3                 check exponent
         BZ    PRT_no_exp            ignore exponent if 0
         BM    PRTEXNEG              no, check negative exponent
         MVI   EXPOSIGN,PRINTPOS     positive exponent
         B     PRTEXPON              process exponentprinting
PRT_no_exp equ *
         mvc   expomark(3),=3c' '    put blanks
         B     PRTCHECK              continue to normal way
PRTEXNEG EQU   *
         MVI   EXPOSIGN,PRINTNEG     negative exponent
PRTEXPON EQU   *
         LPR   R3,R3                 get absolute value
         CVD   R3,ARGTEMP            convert to packed decimal
         OI    ARGTEMP+7,X'0F'       turn off dec offset
         UNPK  EXPONUM,ARGTEMP       convert to EBCDIC
         LA    R1,FPNTLEN            data length
         LA    R3,EXPONUM            point to exponentnumber field
         la    R4,l'exponum-1(R3)    end of exponentnumber
PRTEXPLP EQU   *
         CLI   0(R3),C'0'            is it 0
         BNE   PRTCHECK              no, leave the loop
         MVC   0(L'EXPONUM,R3),1(R3) yes, shift left
         mvi   0(r4),C' '            put a blank at the end of field
         bctr  r4,0                  backward 1 byte
         BCT   R1,PRTEXPLP           loop
PRTCHECK EQU   *
         LD    F0,ARGRSULT           original return value
         LTDR  F0,F0                 check
         BNM   Final_checking        done if not negative
         MVI   FRACSIGN,PRINTNEG     use negative sign
         B     Final_checking
PRTZERO  EQU   *
         MVI   FRACINTG,C'0'         use val '0'
         MVI   Evalblock_EVDATA,C'0'
         B     Simple_result         simple way
PRTONE   EQU   *
         MVI   FRACINTG,C'1'         value = '1'
         MVI   Evalblock_EVDATA,C'1'
Simple_result  equ *
         LA    R1,1                  data length
         B     Final_result          Set output
         SPACE 1
*---------------------------------------------------------*
*  Produce EVALBLOK reusing existing ARGBLOK area         *
*   -  clear control area                                 *
*   -  rebuild control area                               *
*   -  capture part of ARGBLOK as EVALBLOK                *
*           even larger EVALBLOK looked inefficient,      *
*           but it usefull be DRXSTCFN statistical package*
*           thats frequrntly call and need original       *
*           result of ARGRSULT and ARGEXPAN in ARGBLOK.   *
*---------------------------------------------------------*
         SPACE 1
Final_checking equ *
*        st    R1,Evalblock_EVLEN    set data length
         la    r15,expomark-1
Wipe_trailing_0 equ *
         cli   0(r15),c'.'                  is it dot sign w/o frac?
         be    Shift_result                 yes, remove it
         cli   0(r15),c'0'                  is it 0?
         bne   Final_result                 no, just print it
Shift_result   equ *
         mvc   0(fpntlen-fraclen,r15),1(r15) else, shift left 1
         bctr  r15,0                        backward pointer
         bct   r1,Wipe_trailing_0           reduce counter and loop
Final_result equ *
         CLI   FRACSIGN,PRINTNEG            is it negative ?
         BE    Put_result                   yes, go on
         MVC   Evalblock_EVDATA(FPNTLEN-1),ARGSOURC+1 yes, avoid '+'
         BCTR  R1,0                         reduce the length
         B     Put_result_length            go print it
Put_result EQU   *
         MVC   Evalblock_EVDATA(FPNTLEN),ARGSOURC move whole data
Put_result_length EQU   *
         st    R1,Evalblock_EVLEN           set data length
         tm    Check_arg_flag,Arg_is_error  Arg error?
         bno   Return                       No, continue return
         lm    R0,R15,tracesv               Yes, restore all regs
         br    r14                          and return to caller
Return   EQU   *
         aif   (not &trace).next4
         WTO   'DRX0005I Editing result is completed.',                +
               routcde=(1,10)
         mvc   tracetxt(l'tracetxt2),tracetxt2
         mvc   tracetxt+l'tracetxt2(FPNTLEN),ARGSOURC
         la    r15,l'tracetxt2+FPNTLEN
         sth   R15,tracemsg
         la    r7,tracemsg
         la    r1,wtolist
         wto   text=(r7),mf=(E,(r1))
         xr    R15,r15
         b     prttrc_ok
tracetxt2 dc   C'Result is: '
prttrc_ok ds   0h
.next4   anop
         @rxexit rc=NO
         SPACE 1
PRINTPOS EQU   C'+'
PRINTNEG EQU   C'-'
         LTORG ,
*        drop  r11,r12
         drop  r12
   EJECT
   TITLE 'LOCFN: Common obtain EXPONEN number routine'
*--------------------------------------------------------------*
* OBTAIN BASE FRACTION AND EXPONEN NUMBER FROM GIVEN INPUT     *
*                                                              *
*   o   Input from F0 is full doubleword precision             *
*                                                              *
*   o   Output are:                                            *
*               F0   -  Base fraction floatingpoint            *
*               F6   -  exponentfactor                         *
*               R0   -  exponentbinary number                  *
*                                                              *
*--------------------------------------------------------------*
         SPACE 2
         DS    0D
Calculate_Exponent EQU   *
         STM   R1,R12,ARGREGS           save all register
         basr  r11,0                    set local base
         using *,r11                    tell assembler
         SDR   F6,F6                    clear F6
         XR    R0,R0                    clear R0
         XR    R15,R15                  clear R15
         LTDR  F0,F0                    check the input
         BZ    CALXEND                  end if 0
         SDR   F2,F2                    zap all bits in F2
         LPDR  F4,F0                    abslute long form
         LRER  F2,F4                    round up into short form
         CE    F2,=E'1'                 compare to 1.0
         BH    CALXPOS                  if > 1.0
         BE    CALXONE                  else, just print 1.0
         CE    F2,=E'0.1'               compare to 1.0
         BL    CALXNEG                  if < 1.0
         LD    F6,XNEGTAB1              set to 1.0
         B     CALXSCAL                 attempt to do conversion
CALXPOS  EQU   *
*---------------------------------------------------------*
*  Find N such that 10**(N-1) <= X < 10**(N)              *
*   in sequence of I = 10, 20, .. 80                      *
*---------------------------------------------------------*
         SPACE 1
         LA    R15,1                    exponent = 1
         SR    R6,R6                    init index
CALXPOS1 EQU   *
         CD    F2,XPOSTAB2+8(R6)        is it within range ?
         BL    CALXPOSX                 yes, leave the loop
         LA    R6,8(R6)                 else, next entry
         LA    R15,10(R15)              incremented by 10
         B     CALXPOS1                 loop
CALXPOSX EQU   *
         LD    F6,XPOSTAB2(R6)          get the entry
         DDR   F2,F6                    adjust to obtain exp 1-9 range
         SR    R6,R6                    clear table offset
CALXPOS2 EQU   *
         CD    F2,XPOSTAB1(R6)          is it within range ?
         BL    CALXPOSZ                 yes, leave
         LA    R6,8(R6)                 else, next entry
         LA    R15,1(R15)               incremented by 1
         B     CALXPOS2                 loop
CALXPOSZ EQU   *
         MD    F6,XPOSTAB1(R6)          multiplied with range limit
         B     CALXSCAL                 attempt to convert to EBCDIC
CALXNEG  EQU   *
*---------------------------------------------------------*
*  Find N such that 10**(-N) => X > 10**(-N-1)            *
*   in sequence of I = 10, 20, .. 80                      *
*---------------------------------------------------------*
         SPACE 1
         SR    R6,R6                   init index
CALXNEG1 EQU   *
         CD    F2,XNEGTAB2+8(R6)       is it within range ?
         BH    CALXNEGX                yes, leave the loop
         LA    R6,8(R6)                else, next entry
         LA    R15,10(R15)             incremented by 10
         B     CALXNEG1                loop
CALXNEGX EQU   *
         LD    F6,XNEGTAB2(R6)         get the entry
         DDR   F2,F6                   adjust to obtain exp 1-9 range
         SR    R6,R6                   clear table offset
CALXNEG2 EQU   *
         CD    F2,XNEGTAB1+8(R6)       is it within range
         BH    CALXNEGZ                yes, leave
         LA    R6,8(R6)                else, next entry
         LA    R15,1(R15)              incremented by 1
         B     CALXNEG2                loop
CALXNEGZ EQU   *
         LNR   R15,R15                 turn to negative value
         MD    F6,XNEGTAB1(R6)         multiplied with range limit
CALXSCAL EQU   *
         DDR   F4,F6                   avoid exponent
         LR    R0,R15                  store exponentnumber
         LTDR  F0,F0                   check the sign
         BM    CALXSWCT                switch if negative
         LDR   F0,F4                   save
         B     CALXEND                 end
CALXSWCT EQU   *
         LCDR  F0,F4                   switch sign and save
         B     CALXEND                 end
CALXONE  EQU   *
         LA    R15,1                   set 1 for value
         LR    R0,R15
         DD    F2,XPOSTAB1             divided by 10
         MDR   F0,F2                   produce output
CALXEND  EQU   *
         LM    R1,R12,ARGREGS          restore register
         BR    R14                     return
XPOSTAB1 DC    D'1E1,1E2,1E3,1E4,1E5,1E6,1E7,1E8,1E9,1E10'
XPOSTAB2 DC    D'1,1E10,1E20,1E30,1E40,1E50,1E60,1E70'
         DC    X'7FFFFFFFFFFFFFFF'
XNEGTAB1 DC    D'1,1E-1,1E-2,1E-3,1E-4,1E-5,1E-6,1E-7,1E-8,1E-9'
XNEGTAB2 DC    D'1,1E-10,1E-20,1E-30,1E-40,1E-50,1E-60,1E-70,0'
         LTORG ,
         drop  r11
*        drop  r11,r12
   EJECT
   TITLE 'LOCFN: Program Interupt SLIH Exit'
*------------------------------------------------------------*
*    Program interrupt exit routine                          *
*                                                            *
*   REGISTERS  -                                             *
*                                                            *
*     R0 -  Used as a work register by the system.           *
*     R1 -  Address of EPIE area                             *
*     R2-12 - Unchanged                                      *
*     R14 - Return address                                   *
*     R15 - Address of the exit routine.                     *
*                                                            *
*       Check interrupt code whether should be handled,      *
*        so let CMS handle it if we don't have               *
*        responsibility for this interrupt                   *
*                                                            *
*------------------------------------------------------------*
         DS    0D
ESPIE_exit equ *
         using ESPIE_exit,R15         Exit addressability
         using EPIE,r1
         cli   EPIEICD1,X'0C'         exp overflow?
         be    RCOVOVRF               yes, handle it!
         cli   EPIEICD1,X'0D'         exp underflow?
         be    RCOVUNDF               yes, handle it!
         cli   EPIEICD1,X'0F'         f-point divide?
         be    RCOVDVDX               yes, handle it!
         br    r14                    otherwise just return
RCOVOVRF LD    F0,ARGEXLOG            <<EXECUTED>>
         DD    F0,=D'1E50'            <<EXECUTED>>
         B     RXRCOVRY               go to provide solution
RCOVUNDF LD    F0,ARGEXLOG            <<EXECUTED>>
         MD    F0,=D'1E50'            <<EXECUTED>>
         B     RXRCOVRY               go to provide solution
RCOVDVDX LD    F0,#zero               <<EXECUTED>>
         B     RXRCOVRY               go to provide solution
         SPACE 1
RXRCOVRY EQU   *
         A     R0,ARGCORRC            get overflow/underflow exponent
         ST    R0,ARGCORRC            save
         aif   (not &trace).trace07
         icm   r0,b'1111',=x'77777777'
.trace07 anop
         XR    R15,R15                clear R15
         BR    R14                    Return to the system
         LTORG ,
         DS    0D                     Get to doublewords boundary
*EXPONTB   EQU   *
*        DC    D'1'
*        DC    D'1E01,1E02,1E03,1E04,1E05,1E06,1E07,1E08,1E09,1E10'
*        DC    D'1E11,1E12,1E13,1E14,1E15,1E16,1E17,1E18,1E19,1E20'
*        DC    D'1E21,1E22,1E23,1E24,1E25,1E26,1E27,1E28,1E29,1E30'
*        DC    D'1E31,1E32,1E33,1E34,1E35,1E36,1E37,1E38,1E39,1E40'
*        DC    D'1E41,1E42,1E43,1E44,1E45,1E46,1E47,1E48,1E49,1E50'
*        DC    D'1E51,1E52,1E53,1E54,1E55,1E56,1E57,1E58,1E59,1E60'
*        DC    D'1E61,1E62,1E63,1E64,1E65,1E66,1E67,1E68,1E69,1E70'
*                                     code.
         Eject
   Title 'LOCFN: Dummy Section Pool'
*------------------------------------------------------*
*   Working set areas                                  *
*------------------------------------------------------*
         space 1
WORKSET  DSECT
savearea DS    18F
         ORG   savearea+4
saveid   DS    F
         org
savesize DS    F
function_address   DS  A(*-*)      function routine address
function2_address  DS  A(*-*)      2nd function routine address
Arg_address        DS  A(*-*)      Current arg address
Arg_length         DS  A(*-*)      Current arg length
final_address      DS  A(*-*)      final routine address
Number_of_arg      DS  H           Number of args
Check_arg_flag     DS  X           Checking indicator
Arg_is_error       EQU B'10000000' Argument in error
Arg_is_integer     EQU B'00001000' Argument in degree
Arg_is_positive    EQU B'00000100' Argument in degree
Optional_arg_flag  DS  X           Optional arg flag
Optional_arg_check EQU C'Y'        Optional arg checking
Optional_arg       DS  X           Optional argument
Arg_in_radian      EQU C'R'        Argument in radian
Arg_in_degree      EQU C'D'        Argument in degree
                   DS  3X          reserved
work_sysregs_save  DS  4F          Savearea for R14, R15, R0 and R1
rexx_sysregs_save  DS  4F          Savearea for R14, R15, R0 and R1
tempvar  ds    d                   temporary variable
worksave_length    equ  *-WORKSET
wtolist  wto   text=,routcde=(1,10),mf=L
wtolistl equ   *-wtolist
         ds    0h
traceid  ds    cl8
tracesv  ds    16F
tracemsg ds    al2(*-*)
tracetxt ds    cl78
WORKSETL EQU   *-WORKSET
         SPACE 2
*--------------------------------------*
*  ARGBLOK                             *
*  Function argument control block     *
*--------------------------------------*
         SPACE 1
ARGBLOK  DSECT
ARGVALUE DS    D                        floatingpoint value of argument
ARGUNNOR DS    0D                       unnormalized value
         DS    X'4E000000'              high order word
ARGUNLOW DC    F'0'                     low order word
ARGTEMP  DS    D                        temporary place
ARGVSAVE DS    D                        temporary palce for argument
ARGVHOLD DS    D                        temporary result holder
ARGVINIT DS    D                        initial value
ARGRSULT DS    D                        floatingpoint value of result
ARGSOURC DS    XL24                     initial C'00000000'
         ORG   ARGSOURC
FRACSIGN DC    C' '                     sign
FRACINTG DC    C'0.'
FRACNUM  DC    CL9' '                   MANTISSA
FRACLEN  EQU   *-ARGSOURC
EXPOMARK DC    C'E'
EXPOSIGN DC    C' '
EXPONUM  DC    CL8' '                   exponent
FPNTLEN  EQU   *-ARGSOURC
         ORG
ARGPTR   EQU   *
ARGINADR DS    A                        8 start address of integral
ARGINLEN DS    A                             .. its length
ARGFRADR DS    A                        9 start address of fractional
ARGFRLEN DS    A                             .. its length
ARGEXADR DS    A                       10 start address of exponential
ARGEXLEN DS    A                             .. its length
ARGINFAC DS    H                          integral factor
ARGEXFAC DS    H                       11 exponent factor
ARGOVRLY DS    F                       overlaid space for exponent
ARGEXPAN DS    F                       12 power expansion
ARGPTRL  EQU   *-ARGPTR
ARGSAV14 DS    A                       linkage pointer savearea
ARGOVRSV DS    F                       13 overlaid space for exponent
ARGEXPSV DS    F                       power expansion
ARGCORRC DS    F                       14 exponent correction factor
         DS    F                       RESERVED
ARGCONST EQU   *
#pi      DC    D'3.141592654'          15
#ln10    DC    D'2.302585093'          16
#e       DC    D'2.718281828'          17
#zero    DC    D'0'                    18
#one     DC    D'1'                    19
#360     DC    D'360'                  20
#unnormsg DC   X'4E00000100000000'     21
#unnormal DC   X'4E00000000000000'     22
ARGCONSL EQU   *-ARGCONST
ARGREGS  DS    6D                      23-28
ARGAREAL EQU   *-ARGBLOK               size in bytes
ARGENVR  DS    12D                     environment save area
ARGPGPSW DS    D                       PROGRAM NEW PSW savearea
ARGSVPSW DS    D                       PROGRAM NEW PSW SAVEAREA
ARGEXLOG DS    D                       execution log (blackbox)
ARGPGGPR DS    16F                     registers at interruption
ARGBLOKL EQU   *-ARGBLOK               size in bytes
ARGBSIZE EQU   (ARGBLOKL+7)/8          size in doublewords
         SPACE 2
*--------------------------------------*
*  REXX DATA AREA AND CONTROL BLOCK    *
*--------------------------------------*
         IRXARGTB
         IRXPARMB                      Parameter block map
         IRXEVALB                      Evalblock map
Evalblock_length equ *-Evalblock
Evalblock_dwords equ (*-Evalblock+7)/8
EVCTLEN  EQU   Evalblock_EVDATA-Evalblock
         IRXEFPL
         IHAEPIE
         END
