{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012727000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 176358, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 7, "INMDSNAM": "CBT.V500.FILE756.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 176358, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 176358, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE756.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x04\\x06'", "DS1TRBAL": "b'i\\xb8'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x05\\x1f\\x00\\r\\x05 \\x00\\x02\\x00\\x05'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x04J\\x00\\x00\\x01\\x07\\x07_\\x01\\x07\\x07_\\x16'\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf7\\xf4@@@\"", "ispf": {"version": "04.74", "flags": 0, "createdate": "2007-03-16T00:00:00", "modifydate": "2007-03-16T16:27:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-474"}, "text": "REGULAR CBT TAPE - VERSION 474    FILE:  756\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT474.FILE756\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 12 MEMBERS COUNTED; CUMULATIVE SIZE IS 1,379 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   03/16/07    16:27:39    GMT-4:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$DOC": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x06\\x01\\x07\\x07O\\x01\\x07\\x07O\\x154\\x01\\\\\\x01\\\\\\x00\\x00\\xc1\\xf0\\xf9\\xf5\\xf1\\xf9\\xf1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2007-03-15T00:00:00", "modifydate": "2007-03-15T15:34:06", "lines": 348, "newlines": 348, "modlines": 0, "user": "A095191"}, "text": "\nRXJCL - A JCL Rexx facility\n\n\nQuick Reference\nWritten by Daniel Gaeta\ndfgaeta@br.ibm.com\n\n\n\nWhat is this ?\n\nRXJCL is a tool created to improve repetitive process written.\nThe JCL preprocessor expands macro sentences in //* JCL cards.\n\n\nFor example :\n-------------\n\n   File  Edit  Edit_Settings  Menu  Utilities  Compilers  Test  Help\n sssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss\n EDIT       USBUILD.DFG.EXEC($GSDSMP7) - 01.02              Columns 00001 00072\n Command ===>                                                  Scroll ===> CSR\n ****** ***************************** Top of Data ******************************\n ==MSG> -Warning- The UNDO command is not available until you change\n ==MSG>           your edit profile using the command RECOVERY ON.\n 000001 //ERRORRPT JOB (ACCOUNTNBR),NAME,REGION=5M,MSGCLASS=H,NOTIFY=&SYSUID\n 000002 //SMP       EXEC PGM=GIMSMP,REGION=70M\n 000003 //SMPCSI    DD DSN=WWP115.GSD2006B.GLOBAL.CSI,DISP=SHR\n 000004 //SMPCNTL   DD *\n 000005   SET BDY(GLOBAL) .\n 000006 //*   %%SCAN SEQ USBUILD.DFG.EXEC(MYPRODS) LSTPROD\n 000007 //*   %%SET IDX=1\n 000008 //*   %%REPEAT LSTPROD.0\n 000009 //*    %%SET PRDCODE=STRIP(SUBSTR(LSTPROD.IDX,1,72))||'T'\n 000010   REPORT ERRSYSMODS\n 000011   ZONES(%%(PRDCODE)).\n 000012 //*    %%INC IDX\n 000013 //*   %%EREPEAT\n 000014 /*\n ****** **************************** Bottom of Data ****************************\n\n- all cards //* %%statement will be preprocessed before submit to JES\n\n- all cards, except //* will be written to JES without preprocess\n\n\nThe result after RXJCL is :\n\n  File  Edit  Edit_Settings  Menu  Utilities  Compilers  Test  Help\nsssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss\nEDIT       SYS06345.T165125.RA000.DFGAETA.R0156474         Columns 00001 00072\nCommand ===>                                                  Scroll ===> CSR\n****** ***************************** Top of Data ******************************\n==MSG> -Warning- The UNDO command is not available until you change\n==MSG>           your edit profile using the command RECOVERY ON.\n000001 //ERRORRPT JOB (ACCOUNTNBR),NAME,REGION=5M,MSGCLASS=H,NOTIFY=&SYSUID\n000002 //SMP       EXEC PGM=GIMSMP,REGION=70M\n000003 //SMPCSI    DD DSN=WWP115.GSD2006B.GLOBAL.CSI,DISP=SHR\n000004 //SMPCNTL   DD *\n000005   SET BDY(GLOBAL) .\n000006   REPORT ERRSYSMODS\n000007   ZONES(BPA210T).\n000008   REPORT ERRSYSMODS\n000009   ZONES(CML830T).\n000010   REPORT ERRSYSMODS\n000011   ZONES(CMR830T).\n000012   REPORT ERRSYSMODS\n000013   ZONES(DAE210T).\n000014   REPORT ERRSYSMODS\n000015   ZONES(DAO710T).\n000016   REPORT ERRSYSMODS\n\n\nA complex sample :\n------------------\n\nThis sample is a sentence that will generate a report grouping by\nproducts list in USBUILD.DFG.EXEC(MYPRODS) and\nlisting datasets by WWP115.GSD2006B.<prod>.*\n\n\n//*   %%OUT LST\n//*   %%SCAN SEQ USBUILD.DFG.EXEC(MYPRODS) LSTPROD\n//*   %%SET IDX=1\n//*   %%REPEAT LSTPROD.0\n//*    %%SET PRDCODE=STRIP(SUBSTR(LSTPROD.IDX,1,72))\n\n  PRODUCT : %%(PRDCODE)\n  ------------------\n//*    %%SET GSDNAME='WWP115.GSD2006B.'||PRDCODE\n//*    %%SCAN DSN %%GSDNAME DSNAME\n//*    %%SET IDX2=1\n//*    %%REPEAT DSNAME.0\n//*     %%SET DSN=DSNAME.IDX2\n       %%(DSN)\n//*     %%INC IDX2\n//*    %%EREPEAT\n//*    %%INC IDX\n//*   %%EREPEAT\n\n\nOther samples can be found in USBUILD.DFG.EXEC.\n\n\nHow can I run RXJCL :\n\nRXJCL is located in USBUILD.DFG.EXEC\nTo prepare the environ use RECONCAT command or run USBUILD.DFG.EXEC(#CONCAT).\n\nAfter #CONCAT step you can run RXJCL as follow :\n\n   Menu  Functions  Confirm  Utilities  Help\n ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss\n EDIT              USBUILD.DFG.EXEC                          Row 00001 of 00012\n Command ===>                                                  Scroll ===> CSR\n            Name     Prompt       Size   Created          Changed          ID\n _________ $GSDSMP1                 11  2006/11/14  2006/11/14 08:36:02  DFGAETA\n _________ $GSDSMP2                 18  2006/11/14  2006/11/14 10:54:47  DFGAETA\n _________ $GSDSMP3                  8  2006/11/14  2006/11/14 08:42:46  DFGAETA\n _________ $GSDSMP4                 12  2006/11/14  2006/11/14 10:10:02  DFGAETA\n _________ $GSDSMP5                  9  2006/11/14  2006/11/14 10:22:29  DFGAETA\n _________ $GSDSMP6                 11  2006/11/14  2006/11/14 10:37:45  DFGAETA\n rxjcl____ $GSDSMP7                 14  2006/12/11  2006/12/11 16:47:21  DFGAETA\n _________ #CONCAT                   3  2006/12/11  2006/12/11 16:30:40  DFGAETA\n _________ IEBCIN1                   2  2006/12/05  2006/12/05 07:25:09  HOSHIKA\n _________ IEBCOPY1                 18  2006/12/05  2006/12/11 16:33:50  DFGAETA\n _________ MYPRODS                  35  2006/12/11  2006/12/11 16:33:25  DFGAETA\n _________ RXJCL                   790  2006/11/13  2006/12/11 16:32:00  DFGAETA\n           **End**\n\n\n\n\nQuick Reference for RXJCL :\n\n\n- //*   %%OUT <LST|rdr>\n\n  This macro sends the JCL expanded to ISPF Edit or JES reader.\n  Default is LST.\n\n\n- //*   %%INFODSN <dataset>\n\n  This macro retrieves information about datasets (equivalent to\nREXX LISTDSI function).\n\n\n- //*   %%MODE STACK <ON|off>\n\n  This macro sends the content of object retrieved to STACK or record area.\n\n- //*   %%SAVE <%%var|dataset>\n\n  This macro saves the JCL output area to dataset or %%var value.\n  The %%SAVE macro is used to save output JCL preprocessed to many\ndifferent outputs.\n\n- //*   %%TSO <tsocommand>\n\n  This macro just executes TSO commands (equivalent to REXX ADDRESS TSO)\n\n- //*   %%EDIT <%%var|dataset>\n\n  This macro invokes EDIT ISPF service to edit datasets.\n\n- //*   %%BROWSE <%%var|dataset>\n\n  This macro invokes BROWSE ISPF service to edit datasets.\n\n- //*   %%TRIM <rexxvar>\n\n  This macro removes spaces from both sides of string.\n\n- //*   %%RX  <statemant>\n\n  This macro interprets REXX statement (equivalent to REXX INTERPRET statement)\n\n- //*   %%ISPF <statemant>\n\n  This macro interprets ISPF statement (equivalent to REXX ADDRESS ISPEXEC)\n\n- //*   %%DROP <rexxvar>\n\n  This macro deletes rexx variable of REXX Variable Global Pool.\n\n- //*   %%INC <rexxvar>\n\n  This macro increments in one numeric REXX variable. (equivalent to C\ninstruction var++)\n\n- //*   %%DEC <rexxvar>\n\n  This macro decrements in one numeric REXX variable. (equivalent to C\ninstruction var--)\n\n- //*   %%GET <rexxvar>\n\n  This macro pulls item of STACK area. (equivalent to REXX PULL statement)\n\n- //*   %%PUT <rexxvar>\n\n  This macro pushes item into STACK area. (equivalent to REXX QUEUE statement)\n\n- //*   %%PRINT <expression>\n\n  This macro writes expression to SYSPRINT file. (equivalent to REXX SAY\nstatement)\n\n- //*   %%SUB\n\n  This macro submits JCL expanded until the moment and clear data of\nJCL buffer to new cycle.\n  The %%SUB macro is used when we need to submit many JCL in the same process.\n\n- //*   %%SET <expression>\n\n  This macro evaluates REXX expression.\n  The %%SET macro can use any REXX expression including REXX functions\nand boolean expressions.\n\n  For example :\n    //*   %%SET  A=1\n    //*   %%SET  DS='USBUILD.GSD.CNTL'\n    //*   %%SET  ALIAS=SUBSTR(DS,1,7)\n\n\n- //*   %%IF  <expression>\n    jcl cards or RXJCL macro\n  //* < %%ELSE >\n    jcl cards or RXJCL macro\n  //*   %%ENDIF\n\nThis is a simple IF..ELSE..ENDIF sentence. (just one level of IF..ELSE..ENDIF ca\nbe used)\n\n- //*   %%SCAN DSN <%%var|dataset> <rexxvar>\n  //*   %%SCAN LIB <%%var|dataset> <rexxvar>\n  //*   %%SCAN SEQ <%%var|dataset> <rexxvar>\n\nThis macro reads a DSN, LIB or SEQ object from begin to end, putting data to STA\narea or array variable REXX.\nWhen we use array variable REXX the length of array will be put into rexxvar.0 i\nand each record readed will be put\ninto subsequent element.\nIf %%MODE STACK ON is selected all records will be put into STACK area and the n\nof elements readed can be retrieved\nusing QUEUED() Rexx function or rexxvar.0 element.\n\n\n- //*   %%REPEAT <rexxvar|literal>\n     jcl cards or RXJCL macro\n  //*   %%EREPEAT\n\n  This macro is a simple repetition flow. (equivalent to REXX DO..LOOP times)\n  The block between %%REPEAT and %%EREPEAT will be executed the number of times\ncontained in numeric rexxvar\n  or numeric literal.\n\n  For example :\n\n  //*  %%SET TT=3\n  //*  %%REPEAT TT\n  //*    %%PRINT 'REPEATING STRING...'\n  //*  %%EREPEAT\n\n  or\n\n  //*  %%REPEAT 3\n  //*    %%PRINT 'REPEATING STRING...'\n  //*  %%EREPEAT\n\n\n- //* %%BEGMAP mapname\n  //* %%M <map_line_definition>\n  //* %%ENDMAP\n  //* %%SHOW mapname\n\n  Theses macros define one or many maps to use in fullscreen panels.\n  The definitions are the same of ISPF panels. The attributes are fixed.\n  The process to create a map is simple, each %%M define a line of panel that\nwill be shown.\n\n  For example :\n\n  //* %%BEGMAP MAPA1\n  //* %%M\n  //* %%M   Dataset =>#dname                                      +\n  //* %%M\n  //* %%ENDMAP\n  //* %%SHOW MAPA1\n     ...\n     ...\n  //INPFILE  DD DISP=SHR,DSN=%%(DNAME)\n     ...\n\n\nMacro Variables :\n\n\n  Macro variable can be used in any JCL card. For example :\n\n\n  //OUTFILE   DD DISP=SHR,DSN=USBUILD.OUTPUT.D%%OSEQ\n  or\n  //FILEMOV   DD DISP=SHR,DSN=USBUILD.OUTPUT.D%%ODAYM%%OMONTH\n\n\n- %%OUSER\n\n  This is a macro-variable that contains userid of current session.\n\n- %%ODAY\n\n  This is a macro-variable that contains system current day.\n\n- %%OMONTH\n\n  This is a macro-variable that contains system current month.\n\n- %%OYEAR\n\n  This is a macro-variable that contains system current year.\n\n- %%ODATE\n\n  This is a macro-variable that contains system current date in format mm/dd/yyy\n\n- %%OSEQ\n\n  This is a macro-variable that contains a sequential number incremented\non each use.\n\n- %%(rexxvar)\n\n  This is a macro-variable that will be changed by data rexx variable.\n\n\n\n\nABOUT THIS DOCUMENT :\n\n  For additional help please contact me by SAMETIME or Notes (DFGAETA@BR.IBM.COM\n\n\n\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$GSDSMP1": {"ttr": 524, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "//*   %%OUT LST\n//*   %%SCAN DSN GSDP115.GSD2006B VDSNAME\n//*   %%SET IDX=1\n  TOTAL DATATSETS = %%(VDSNAME.0)\n  -------------------------------\n\n//*   %%REPEAT VDSNAME.0\n//*    %%SET VV=VDSNAME.IDX\n  SMPEOUT : %%(VV)\n//*    %%INC IDX\n//*   %%EREPEAT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$GSDSMP2": {"ttr": 526, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "//*   %%OUT LST\n//*   %%SCAN SEQ DFGAETA.LIST.PRODS LSTPROD\n//*   %%SET IDX=1\n//*   %%REPEAT LSTPROD.0\n//*    %%SET PRDCODE=STRIP(SUBSTR(LSTPROD.IDX,2,6))\n\n  PRODUCT : %%(PRDCODE)\n  ------------------\n//*    %%SET GSDNAME='WWP115.GSD2006B.'||PRDCODE\n//*    %%SCAN DSN %%GSDNAME DSNAME\n//*    %%SET IDX2=1\n//*    %%REPEAT DSNAME.0\n//*     %%SET DSN=DSNAME.IDX2\n       %%(DSN)\n//*     %%INC IDX2\n//*    %%EREPEAT\n//*    %%INC IDX\n//*   %%EREPEAT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$GSDSMP3": {"ttr": 528, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "//*   %%OUT LST\n//*   %%SCAN SEQ DFGAETA.SAM.PROD1 LSTPROD\n//*   %%SET IDX=1\n//*   %%REPEAT LSTPROD.0\n//*    %%SET PRDCODE=STRIP(SUBSTR(LSTPROD.IDX,1,72))\n  PRODUCT :%%(PRDCODE)\n//*    %%INC IDX\n//*   %%EREPEAT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$GSDSMP4": {"ttr": 530, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "//*       %%OUT LST\n//LISTPTF JOB (170419,F6MC,004),'JPS',NOTIFY=&SYSUID,\n//STEP01  EXEC PGM=IDCAMS\n//SYSPRINT  DD SYSOUT=*\n//SYSIN     DD *\n//*   %%OUT LST /\n//*   %%SCAN SEQ DFGAETA.SAM.PROD1\n//*   %%REPEAT QUEUED()\n//*    %%GET LSTPROD\n//*    %%SET PRDCODE=STRIP(SUBSTR(LSTPROD,1,72))\n  LISTCAT ENT(%%(PRDCODE)T) ALL\n//*   %%EREPEAT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$GSDSMP5": {"ttr": 532, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "//*   %%OUT LST\n//*   %%INPUT PROD\n//*   %%MODE STACK ON\n//*   %%SET LIBNAME='WWP115.GSD2006B.'||PROD||'.#SCRIPT'\n//*   %%SCAN LIB %%LIBNAME\n//*   %%REPEAT QUEUED()\n//*    %%GET MEMBER\n  MEMBROS :%%(MEMBER)\n//*   %%EREPEAT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$GSDSMP6": {"ttr": 534, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "//*   %%OUT LST\n//*   %%INPUT PROD\n//*   %%MODE STACK ON\n//*   %%SET LIBNAME='DFGAETA.GSD2006B.'||PROD||'.#SCRIPT'\n//*   %%SCAN LIB %%LIBNAME\n//*   %%REPEAT QUEUED()\n//*    %%GET MEMBER\n//*    %%TRIM MEMBER\n//*    %%SET LIBS=LIBNAME||\"(\"||MEMBER||\")\"\n//*    %%BROWSE %%LIBS\n//*   %%EREPEAT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$SMPUTL": {"ttr": 536, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "//$SMPUTL  JOB (010046,F6MC,052),RXJCL,MSGCLASS=H,NOTIFY=&SYSUID\n//* %%SET CSI='WWsrel.GSDyyyya.pppvrm.GLOBAL.CSI'\n//* %%SET ZONE='PPPVRMT'\n//* %%BEGMAP PP11\n//* %%M %DDDEF Input Panel+\n//* %%M\n//* %%M   CSI  =@csi                                         +\n//* %%M   Zone =@zone    +\n//* %%M\n//* %%M   Dataset     =@dsn                                         +\n//* %%M   DDNAME      =@ddn     +\n//* %%M\n//* %%M   Option @o+ %(A-DDDEF,B-ERRSYSMOD)                         +\n//* %%M\n//* %%M   PF3-CANCEL            ENTER-PROCESS\n//* %%M\n//* %%ENDMAP\n//* %%SHOW PP11\n//SMP      EXEC PGM=GIMSMP,REGION=7M,PARM='',TIME=1439\n//SMPCSI   DD DISP=SHR,DSN=%%(CSI)\n//SMPCNTL  DD *\n//* %%IF O='A'\n    SET BDY(%%(ZONE)).\n    UCLIN .\n    REP       DDDEF(%%(DDN))\n              DATASET(\n                    %%(DSN)\n              )\n              UNIT(SYSALLDA)\n              SHR\n    ENDUCL .\n//* %%ENDIF\n//* %%IF O='B'\n    SET BDY(GLOBAL) .\n    REPORT ERRSYSMODS\n    ZONES(%%(ZONE)).\n//* %%ENDIF\n/*\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "@FILE756": {"ttr": 538, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x04J\\x00\\x00\\x01\\x07\\x07_\\x01\\x07\\x07_\\x16'\\x00\\x07\\x00\\x07\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf7\\xf4@@@\"", "ispf": {"version": "04.74", "flags": 0, "createdate": "2007-03-16T00:00:00", "modifydate": "2007-03-16T16:27:00", "lines": 7, "newlines": 7, "modlines": 0, "user": "CBT-474"}, "text": "//***FILE 756 is from Daniel Gaeta and contains a REXX which is a   *   FILE 756\n//*           powerful JCL preprocessor.  This tool has rather      *   FILE 756\n//*           immense capabilities.  Please see member $$DOC for    *   FILE 756\n//*           a complete user guide and description.                *   FILE 756\n//*                                                                 *   FILE 756\n//*           email:  dfgaeta@br.ibm.com                            *   FILE 756\n//*                                                                 *   FILE 756\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "README": {"ttr": 769, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x02\\x01\\x07\\x07O\\x01\\x07\\x07O\\x151\\x00\\x08\\x00\\x08\\x00\\x00\\xc1\\xf0\\xf9\\xf5\\xf1\\xf9\\xf1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2007-03-15T00:00:00", "modifydate": "2007-03-15T15:31:02", "lines": 8, "newlines": 8, "modlines": 0, "user": "A095191"}, "text": "A simple format to run the tool :\n\nREADY\n rxjcl 'mylib.qual(jclsamp)'\n\nwhere :\n  mylib .. it would be your library with samples\n  jclsamp .. a jcl sample format\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "RXJCL": {"ttr": 771, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x1a\\x009\\x01\\x06%_\\x01\\x07\\x07O\\x15%\\x03\\x81\\x02\\x8a\\x00\\x00\\xc1\\xf0\\xf9\\xf5\\xf1\\xf9\\xf1@@@'", "ispf": {"version": "01.26", "flags": 0, "createdate": "2006-09-12T00:00:00", "modifydate": "2007-03-15T15:25:39", "lines": 897, "newlines": 650, "modlines": 0, "user": "A095191"}, "text": "/*                                 REXX                               */\n/* PROGRAM .... : RXJCL                                               */\n/* FUNCTION ... : JCL PRE-PROCESSOR AND LANGUAGE SUBSET               */\n/* AUTHOR ..... : DFGAETA (DFGAETA@BR.IBM.COM)                        */\n/*                                                                    */\nARG ZZPARM\n\n  ZZR = ISPF(\"ISPEXEC CONTROL DISPLAY REFRESH\")\n\n  IF ZZPARM = '' THEN DO\n     ZZLIBJCLI = 'GAETA.DATA'\n     ZZLIBJCLO = 'GAETA.DATA'\n     ZZMM = 'JCLTST6'\n     END\n  ELSE DO\n     PARSE VALUE ZZPARM WITH \"'\" ZTEMP \"'\"\n     PARSE VALUE ZTEMP WITH ZZLIBJCLI '(' ZZMM ')'\n     ZZLIBJCLO = ZZLIBJCLI\n     END\n\n\n  ZZRR = TSO(\"FREE F(JCLIN)\")\n  ZZRR = TSO(\"ALLOC F(JCLIN) DA('\"||ZZLIBJCLI||\"(\"||ZZMM||\")') SHR\")\n\n  CALL READ_JCL\n  CALL PROC_JCL\n  ZZOUTMODE = STRIP(ZZOUTMODE)\n  IF ZZOUTMODE = 'TSO' THEN DO\n     CALL PROC_JCL_TSO\n     END\n  IF ZZOUTMODE = 'LST' THEN DO\n     CALL PROC_JCL_LIST\n     END\n  IF ZZOUTMODE = 'RDR' THEN DO\n     CALL PROC_JCL_SUB\n     END\n\nRETURN\n\nREAD_JCL:\n\n  ZZRR = TSO(\"EXECIO * DISKR JCLIN (STEM ZZJCL. FINIS)\")\n  ZZJCLI = ZZJCL.0\n  IF RC \\= 0 THEN DO\n     SAY 'JCLE001: JCL LOAD ERROR'\n     END\n\nRETURN\n\nLIST_JCL:\n\n  DO I = 1 TO ZZJCLI\n    SAY '>>' ZZJCL.I\n  END\n\nRETURN\n\nPROC_JCL:\n\n  ZZJCLOI = 0\n  ZZI1 = 1\n  ZZI2 = 0\n  ZZINS = 0\n  ZZSEQTMP = 0\n  ZZOUTMODE = 'LST'\n  ZZILOOP = 0\n  ZZCOND = 0\n  ZZIF = 0\n  ZZ_SETOSEQ_ZEROS = 0\n  ZZDEBUG=0\n  ZZSTACK=0\n  ZZLLBL.0=0\n  ZZNLBL.0=0\n  ZZILBL=0\n\n  DO ZZILOOP = 1 TO 8\n    ZZRPTIDX.ZZILOOP  = 0\n    ZZRPTINC.ZZILOOP  = 0\n    ZZRPTLINE.ZZILOOP = 0\n  END\n  ZZILOOP = 0\n\n  ZVARNAME = ''\n  ZVARDATA = ''\n  ZZMAPI = 0\n  ZZSCR.1='C,2,28,X,H,* RXJCL - INPUT SCREEN *'\n  ZZLIN=4\n  ZZITEM=2\n  ZZVV=1\n  ZZFLAG=0\n  DO ZZI1 = 1 TO ZZJCLI\n    ZZS = ZZJCL.ZZI1\n    ZZS = SUBSTR(ZZS,1,72)\n    IF INDEX(ZZS,' %%INPUT ') > 0 THEN DO\n       ZZFLAG=1\n       ZZL0 = '%%INPUT'\n       ZZL1 = INDEX(ZZS,' %%INPUT ')\n       ZZP1 = SUBSTR(ZZS,1,ZZL1-1)\n       ZZP2 = ' '\n       ZZR1 = STRIP(SUBSTR(ZZS,ZZL1+9))\n       PARSE VALUE ZZR1 WITH ZZRR1 ZZRR2\n       ZZMAPI = ZZMAPI + 1\n       ZVARNAME = STRIP(ZZRR1)\n       IF ZZRR2\\='' THEN DO\n          ZZEXPR=ZVARNAME\"='\"||ZZRR2||\"'\"\n          INTERPRET ZZEXPR\n          END\n       ELSE DO\n          ZZEXPR=ZVARNAME||\"=''\"\n          INTERPRET ZZEXPR\n          END\n       ZVARDATA = ''\n       ZZSCR.ZZITEM='C,'||ZZLIN||',5,X,X,'||SUBSTR(ZVARNAME,1,10)||' ='\n       ZZITEM=ZZITEM+1\n       ZZSCR.ZZITEM='I,'||ZZLIN||',19,44,X,'||ZVARNAME\n       ZZITEM=ZZITEM+1\n       IF ZZITEM > 22 THEN DO\n          SAY 'JCLE002 : EXCEED MAX NUMBER OF FIELDS SCREEN'\n          RETURN 8\n          END\n       ZZLIN=ZZLIN+1\n       ZZVV=ZZVV+1\n    END\n  END\n  ZZITEM=ZZITEM-1\n  IF ZZFLAG=1 THEN DO\n     \"SENDMAP ZZSCR \"ZZITEM\" BEEP\"\n  END\n  ZZI1=1\n\n  ZZMMAP=0\n\n  ZZRR = TSO('ALLOC F(RRTEMP) REUSE NEW DEL DSO(PO) DIR(1) SP(1)' ,\n             'TRACK RECFM(F B) LRECL(80)')\n  ZZRR = ISPF('LIBDEF ISPPLIB LIBRARY ID(RRTEMP)')\n\nPROC_JCL_REPEAT:\n\n  IF ZZI1 > ZZJCLI THEN DO\n     SIGNAL PROC_JCL_REPEAT_EXIT\n     END\n\n  ZZS = ZZJCL.ZZI1\n  ZZS = SUBSTR(ZZS,1,72)\n\n  ZZIREXX = INDEX(ZZS,'##') + 2\n  ZZSRX = STRIP(SUBSTR(ZZS,ZZIREXX))\n  ZZB = ''\n\n  IF INDEX(ZZS,' %%EREPEAT ') > 0 THEN DO\n     ZZL0 = '%%EREPEAT'\n     ZZL1 = INDEX(ZZS,' %%EREPEAT ')\n     ZZRPTIDX.ZZILOOP = ZZRPTIDX.ZZILOOP + 1\n     IF ZZRPTIDX.ZZILOOP >= ZZRPTINC.ZZILOOP THEN DO\n        ZZRPTIDX.ZZILOOP  = 0\n        ZZRPTINC.ZZILOOP  = 0\n        ZZRPTLINE.ZZILOOP = 0\n        ZZILOOP = ZZILOOP - 1\n        END\n     ELSE DO\n        ZZI1 = ZZRPTLINE.ZZILOOP\n        SIGNAL PROC_JCL_REPEAT\n        END\n     ZZINS = 0\n     SIGNAL PROC_JCL_SKIP\n     END\n\n  IF INDEX(ZZS,' %%CANCEL ') > 0 THEN DO\n     ZZOUTMODE='NULL'\n     SIGNAL PROC_JCL_REPEAT_EXIT\n     END\n\n  IF INDEX(ZZS,' %%OUT ') > 0 THEN DO\n     ZZL0 = '%%OUT'\n     ZZL1 = INDEX(ZZS,' %%OUT ')\n     ZZP1 = SUBSTR(ZZS,1,ZZL1-1)\n     ZZP2 = STRIP(SUBSTR(ZZS,ZZL1+7))\n     IF ZZP2 = 'LST' THEN DO\n        ZZOUTMODE = 'LST'\n        END\n     IF ZZP2 = 'TSO' THEN DO\n        ZZOUTMODE = 'TSO'\n        END\n     IF ZZP2 = 'NULL' THEN DO\n        ZZOUTMODE = 'NULL'\n        END\n     IF ZZP2 = 'RDR' THEN DO\n        ZZOUTMODE = 'RDR'\n        END\n     ZZS = ''\n     ZZINS = 1\n     SIGNAL PROC_JCL_SKIP\n     END\n\n  IF INDEX(ZZS,' %%M ') > 0 THEN DO\n     ZZL0 = '%%M'\n     ZZL1 = INDEX(ZZS,' %%M ')\n     ZZP1 = SUBSTR(ZZS,ZZL1+5)\n     ZZIMAP = ZZIMAP + 1\n     ZZMMAP.ZZIMAP = STRIP(ZZP1,'T')\n     ZZS = ''\n     ZZINS = 1\n     SIGNAL PROC_JCL_SKIP\n     END\n\n  IF INDEX(ZZS,' %%BEGMAP ') > 0 THEN DO\n     ZZL0 = '%%BEGMAP'\n     ZZL1 = INDEX(ZZS,' %%BEGMAP ')\n     ZZP1 = SUBSTR(ZZS,ZZL1+10)\n     ZZMNMAP = STRIP(ZZP1)\n     ZZMMAP = 1\n     ZZMMAP.0 = 0\n     ZZIMAP = 0\n     ZZS = ''\n     ZZINS = 0\n     SIGNAL PROC_JCL_SKIP\n     END\n\n  IF INDEX(ZZS,' %%ENDMAP ') > 0 THEN DO\n     ZZS = ''\n     ZZMMAP = 2\n     CALL MAKEMAP\n     ZZS = ''\n     ZZINS = 0\n     SIGNAL PROC_JCL_SKIP\n     END\n\n  IF INDEX(ZZS,' %%SHOW ') > 0 THEN DO\n     ZZL0 = '%%SHOW'\n     ZZL1 = INDEX(ZZS,' %%SHOW ')\n     ZZP1 = STRIP(SUBSTR(ZZS,ZZL1+8))\n     ZZRR=ISPF(\"ADDPOP\")\n     IF ZZP1='' THEN DO\n        ZZRR=ISPF(\"DISPLAY PANEL(\"||ZZMNMAP||\")\")\n        END\n     ELSE DO\n        ZZRR=ISPF(\"DISPLAY PANEL(\"||ZZP1||\")\")\n        END\n     ZZRR=ISPF(\"REMPOP\")\n     ZZS = ''\n     ZZINS = 0\n     SIGNAL PROC_JCL_SKIP\n     END\n\n  IF INDEX(ZZS,' %%INFODSN ') > 0 THEN DO\n     ZZL0 = '%%INFODSN'\n     ZZL1 = INDEX(ZZS,' %%INFODSN ')\n     ZZP1 = SUBSTR(ZZS,1,ZZL1-1)\n     ZZP2 = STRIP(SUBSTR(ZZS,ZZL1+11))\n     INTERPRET \"ZZEXPR=\"||ZZP2\n     ZZEXPR = \"'\"||ZZEXPR||\"'\"\n     ZZRR = LISTDSI(ZZEXPR)\n     ZZS = ''\n     ZZINS = 0\n     SIGNAL PROC_JCL_SKIP\n     END\n\n  IF INDEX(ZZS,' %%MODE ') > 0 THEN DO\n     ZZL0 = '%%MODE'\n     ZZL1 = INDEX(ZZS,' %%MODE ')\n     ZZP1 = SUBSTR(ZZS,1,ZZL1-1)\n     ZZP2 = STRIP(SUBSTR(ZZS,ZZL1+8))\n     PARSE VALUE ZZP2 WITH ZZP21 ZZP22\n     IF ZZP21 = 'STACK' & ZZP22='ON' THEN ZZSTACK=1\n     IF ZZP21 = 'STACK' & ZZP22='OFF' THEN ZZSTACK=0\n     ZZS = ''\n     ZZINS = 0\n     SIGNAL PROC_JCL_SKIP\n     END\n\n  IF INDEX(ZZS,' %%LABEL ') > 0 THEN DO\n     ZZL0 = '%%LABEL'\n     ZZL1 = INDEX(ZZS,' %%LABEL ')\n     ZZP1 = SUBSTR(ZZS,1,ZZL1-1)\n     ZZP2 = STRIP(SUBSTR(ZZS,ZZL1+9))\n     ZZS = ''\n     ZZINS = 0\n     SIGNAL PROC_JCL_SKIP\n     END\n\n  IF INDEX(ZZS,' %%SAVE ') > 0 THEN DO\n     ZZL0 = '%%SAVE'\n     ZZL1 = INDEX(ZZS,' %%SAVE ')\n     ZZP1 = SUBSTR(ZZS,1,ZZL1-1)\n     ZZP2 = STRIP(SUBSTR(ZZS,ZZL1+8))\n     IF SUBSTR(STRIP(ZZP2),1,2) = '%%' THEN DO\n        INTERPRET \"ZZEXPR=\"||SUBSTR(STRIP(ZZP2),3)\n        END\n     ELSE DO\n        INTERPRET \"ZZEXPR='\"||ZZP2||\"'\"\n        END\n     ZZRR = TSO(\"ALLOC F(RXTEMP) DA('\"||ZZEXPR||\"') SHR\")\n     ZZJCLO.0 = ZZJCLOI\n     ZZRR = TSO(\"EXECIO \"ZZJCLOI\" DISKW RXTEMP (STEM ZZJCLO. FINIS\")\n     ZZRR = TSO(\"FREE F(RXTEMP)\")\n     ZZJCLOI = 0\n     DROP ZZJCLO.\n     ZZS = ''\n     ZZINS = 0\n     SIGNAL PROC_JCL_SKIP\n     END\n\n  IF INDEX(ZZS,' %%TSO ') > 0 THEN DO\n     ZZL0 = '%%TSO'\n     ZZL1 = INDEX(ZZS,' %%TSO ')\n     ZZP1 = SUBSTR(ZZS,1,ZZL1-1)\n     ZZP2 = STRIP(SUBSTR(ZZS,ZZL1+7))\n     ZZRR = OUTTRAP(ZZMSG.)\n     ADDRESS TSO ZZP2\n     ZZRR = OUTTRAP()\n     ZZS = ''\n     ZZINS = 0\n     SIGNAL PROC_JCL_SKIP\n     END\n\n  IF INDEX(ZZS,' %%EDIT ') > 0 THEN DO\n     ZZL0 = '%%EDIT'\n     ZZL1 = INDEX(ZZS,' %%EDIT ')\n     ZZP1 = SUBSTR(ZZS,1,ZZL1-1)\n     ZZP2 = STRIP(SUBSTR(ZZS,ZZL1+8))\n     IF SUBSTR(STRIP(ZZP2),1,2) = '%%' THEN DO\n        INTERPRET \"ZZEXPR=\"||SUBSTR(STRIP(ZZP2),3)\n        END\n     ELSE DO\n        INTERPRET \"ZZEXPR='\"||ZZP2||\"'\"\n        END\n     ZZR=ISPF(\"EDIT DATASET('\"||ZZEXPR||\"')\")\n     ZZS = ''\n     ZZINS = 0\n     SIGNAL PROC_JCL_SKIP\n     END\n\n  IF INDEX(ZZS,' %%BROWSE ') > 0 THEN DO\n     ZZL0 = '%%BROWSE'\n     ZZL1 = INDEX(ZZS,' %%BROWSE ')\n     ZZP1 = SUBSTR(ZZS,1,ZZL1-1)\n     ZZP2 = STRIP(SUBSTR(ZZS,ZZL1+10))\n     IF SUBSTR(STRIP(ZZP2),1,2) = '%%' THEN DO\n        INTERPRET \"ZZEXPR=\"||SUBSTR(STRIP(ZZP2),3)\n        END\n     ELSE DO\n        INTERPRET \"ZZEXPR='\"||ZZP2||\"'\"\n        END\n     ZZR=ISPF(\"BROWSE DATASET('\"||ZZEXPR||\"')\")\n     ZZS = ''\n     ZZINS = 0\n     SIGNAL PROC_JCL_SKIP\n     END\n\n  IF INDEX(ZZS,' %%TRIM ') > 0 THEN DO\n     ZZL0 = '%%TRIM'\n     ZZL1 = INDEX(ZZS,' %%TRIM ')\n     ZZP1 = SUBSTR(ZZS,1,ZZL1-1)\n     ZZP2 = STRIP(SUBSTR(ZZS,ZZL1+8))\n     ZZEXPR=ZZP2'=STRIP('ZZP2')'\n     INTERPRET ZZEXPR\n     ZZS = ''\n     ZZINS = 0\n     SIGNAL PROC_JCL_SKIP\n     END\n\n  IF INDEX(ZZS,' %%RX ') > 0 THEN DO\n     ZZL0 = '%%RX'\n     ZZL1 = INDEX(ZZS,' %%RX ')\n     ZZP1 = SUBSTR(ZZS,1,ZZL1-1)\n     ZZP2 = STRIP(SUBSTR(ZZS,ZZL1+6))\n     INTERPRET ZZP2\n     ZZS = ''\n     ZZINS = 0\n     SIGNAL PROC_JCL_SKIP\n     END\n\n  IF INDEX(ZZS,' %%ISPF ') > 0 THEN DO\n     ZZL0 = '%%ISPF'\n     ZZL1 = INDEX(ZZS,' %%ISPF ')\n     ZZP1 = SUBSTR(ZZS,1,ZZL1-1)\n     ZZP2 = STRIP(SUBSTR(ZZS,ZZL1+8))\n     ZZRR = OUTTRAP(ZZMSG.)\n     ADDRESS ISPEXEC ZZP2\n     ZZRR = OUTTRAP()\n     ZZS = ''\n     ZZINS = 0\n     SIGNAL PROC_JCL_SKIP\n     END\n\n  IF INDEX(ZZS,' %%DROP ') > 0 THEN DO\n     ZZL0 = '%%DROP'\n     ZZL1 = INDEX(ZZS,' %%DROP ')\n     ZZR1 = STRIP(SUBSTR(ZZS,ZZL1+7))\n     ZZJCLOI = 0\n     DROP ZZJCLO.\n     ZZINS = 0\n     ZZI1 = ZZI1 + 1\n     SIGNAL PROC_JCL_REPEAT\n     END\n\n  IF INDEX(ZZS,' %%INC ') > 0 THEN DO\n     ZZL0 = '%%INC'\n     ZZL1 = INDEX(ZZS,' %%INC ')\n     ZZP1 = SUBSTR(ZZS,1,ZZL1-1)\n     ZZP2 = STRIP(SUBSTR(ZZS,ZZL1+7))\n     INTERPRET ZZP2\"=\"ZZP2\"+1\"\n     ZZS = ''\n     ZZINS = 0\n     SIGNAL PROC_JCL_SKIP\n     END\n\n  IF INDEX(ZZS,' %%DEC ') > 0 THEN DO\n     ZZL0 = '%%DEC'\n     ZZL1 = INDEX(ZZS,' %%DEC ')\n     ZZP1 = SUBSTR(ZZS,1,ZZL1-1)\n     ZZP2 = STRIP(SUBSTR(ZZS,ZZL1+7))\n     INTERPRET ZZP2\"=\"ZZP2\"-1\"\n     ZZS = ''\n     ZZINS = 0\n     SIGNAL PROC_JCL_SKIP\n     END\n\n  IF INDEX(ZZS,' %%INPUT ') > 0 THEN DO\n     ZZS = ''\n     ZZINS = 0\n     SIGNAL PROC_JCL_SKIP\n     END\n\n  IF INDEX(ZZS,' %%SKIP ') > 0 THEN DO\n     ZZL0 = '%%DEC'\n     ZZL1 = INDEX(ZZS,' %%DEC ')\n     ZZP1 = SUBSTR(ZZS,1,ZZL1-1)\n     ZZP2 = STRIP(SUBSTR(ZZS,ZZL1+8))\n     INTERPRET \"ZZI1=ZZI1\" ZZP2\n     ZZS = ''\n     ZZINS = 0\n     SIGNAL PROC_JCL_REPEAT\n     END\n\n  IF INDEX(ZZS,' %%GET ') > 0 THEN DO\n     ZZL0 = '%%GET'\n     ZZL1 = INDEX(ZZS,' %%GET ')\n     ZZP1 = SUBSTR(ZZS,1,ZZL1-1)\n     ZZP2 = STRIP(SUBSTR(ZZS,ZZL1+7))\n     PULL ZZPULL\n     INTERPRET ZZP2\"='\"||ZZPULL||\"'\"\n     ZZS = ''\n     ZZINS = 0\n     SIGNAL PROC_JCL_SKIP\n     END\n\n  IF INDEX(ZZS,' %%PUT ') > 0 THEN DO\n     ZZL0 = '%%PUT'\n     ZZL1 = INDEX(ZZS,' %%PUT ')\n     ZZP1 = SUBSTR(ZZS,1,ZZL1-1)\n     ZZP2 = STRIP(SUBSTR(ZZS,ZZL1+7))\n     QUEUE ZZP2\n     ZZS = ''\n     ZZINS = 0\n     SIGNAL PROC_JCL_SKIP\n     END\n\n  IF INDEX(ZZS,'%%OUSER') > 0 THEN DO\n     ZZL0 = '%%OUSER'\n     ZZL1 = INDEX(ZZS,'%%OUSER')\n     ZZP1 = SUBSTR(ZZS,1,ZZL1-1)\n     ZZP2 = USERID()\n     ZZP3 = STRIP(SUBSTR(ZZS,ZZL1+7))\n     ZZB = ZZP1||ZZP2||ZZP3\n     ZZS = ZZB\n     ZZINS = 1\n     SIGNAL PROC_JCL_INSERT\n     END\n\n  IF INDEX(ZZS,'%%OMONTH') > 0 THEN DO\n     ZZL0 = '%%OMONTH'\n     ZZL1 = INDEX(ZZS,'%%OMONTH')\n     ZZP1 = SUBSTR(ZZS,1,ZZL1-1)\n     ZZP2 = DATE()\n     PARSE VALUE ZZP2 WITH ZZD1 ZZM1 ZZA1\n     UPPER ZZM1\n     ZZP2 = ZZM1\n     ZZP3 = STRIP(SUBSTR(ZZS,ZZL1+8))\n     ZZB = ZZP1||ZZP2||ZZP3\n     ZZS = ZZB\n     ZZINS = 1\n     SIGNAL PROC_JCL_INSERT\n     END\n\n  IF INDEX(ZZS,' %%REPEAT ') > 0 THEN DO\n     ZZL0 = '%%REPEAT'\n     ZZL1 = INDEX(ZZS,' %%REPEAT ')\n     ZZP1 = STRIP(SUBSTR(ZZS,ZZL1+10))\n     ZZEXPR = 0\n     INTERPRET \"ZZEXPR=\" ZZP1\n     ZZILOOP = ZZILOOP + 1\n     ZZRPTIDX.ZZILOOP = 0\n     ZZRPTINC.ZZILOOP = ZZEXPR\n     ZZRPTLINE.ZZILOOP = ZZI1 + 1\n     ZZINS = 0\n     SIGNAL PROC_JCL_SKIP\n     END\n\n  IF INDEX(ZZS,' %%SCAN ') > 0 THEN DO\n     ZZL0 = '%%SCAN'\n     ZZL1 = INDEX(ZZS,' %%SCAN ')\n     ZZP1 = STRIP(SUBSTR(ZZS,ZZL1+8))\n     PARSE VALUE ZZP1 WITH ZZP1_1 ZZP1_2 ZZP1_3\n     IF ZZP1_1 = 'DSN' THEN DO\n        CALL PROC_CMD_SCAN_DSN ZZP1_1,ZZP1_2,ZZP1_3\n        END\n     IF ZZP1_1 = 'LIB' THEN DO\n        CALL PROC_CMD_SCAN_LIB ZZP1_1,ZZP1_2,ZZP1_3\n        END\n     IF ZZP1_1 = 'SEQ' THEN DO\n        CALL PROC_CMD_SCAN_SEQ ZZP1_1,ZZP1_2,ZZP1_3\n        END\n     ZZINS = 0\n     SIGNAL PROC_JCL_SKIP\n     END\n\n  IF INDEX(ZZS,' %%IF ') > 0 THEN DO\n     ZZL0 = '%%IF'\n     ZZL1 = INDEX(ZZS,' %%IF ')\n     ZZP1 = STRIP(SUBSTR(ZZS,ZZL1+6))\n     ZZCOND = 0\n     ZZIF = 0\n     INTERPRET 'IF ' ZZP1 ' THEN ZZCOND = 1'\n     IF ZZCOND = 1 THEN DO\n        ZZINS = 0\n        ZZIF = 1\n        SIGNAL PROC_JCL_SKIP\n        END\n     ELSE DO\n        ZZIF = 2\n        ZZI1 = ZZI1 + 1\n        DO WHILE INDEX(ZZJCL.ZZI1,' %%ELSE ') = 0 & ,\n                 INDEX(ZZJCL.ZZI1,' %%ENDIF ') = 0\n          ZZI1 = ZZI1 + 1\n        END\n        END\n     ZZINS = 0\n     SIGNAL PROC_JCL_SKIP\n     END\n\n  IF INDEX(ZZS,' %%ENDIF ') > 0 THEN DO\n     ZZIF = 0\n     ZZINS = 0\n     SIGNAL PROC_JCL_SKIP\n     END\n\n  IF INDEX(ZZS,' %%ELSE ') > 0 THEN DO\n     IF ZZIF = 1 THEN DO\n        ZZI1 = ZZI1 + 1\n        DO WHILE INDEX(ZZJCL.ZZI1,' %%ENDIF ') = 0\n          ZZI1 = ZZI1 + 1\n        END\n        END\n     ZZINS = 0\n     ZZIF = 0\n     SIGNAL PROC_JCL_SKIP\n     END\n\n  IF INDEX(ZZS,'%%ODAY') > 0 THEN DO\n     ZZL0 = '%%ODAY'\n     ZZL1 = INDEX(ZZS,'%%ODAY')\n     ZZP1 = SUBSTR(ZZS,1,ZZL1-1)\n     ZZP2 = DATE()\n     PARSE VALUE ZZP2 WITH ZZD1 ZZM1 ZZA1\n     ZZP2 = ZZD1\n     ZZP3 = STRIP(SUBSTR(ZZS,ZZL1+6))\n     ZZB = ZZP1||ZZP2||ZZP3\n     ZZS = ZZB\n     ZZINS = 1\n     SIGNAL PROC_JCL_INSERT\n     END\n\n  IF INDEX(ZZS,' %%SET ') > 0 THEN DO\n     ZZL0 = '%%SET'\n     ZZL1 = INDEX(ZZS,' %%SET ')\n     ZZP1 = SUBSTR(ZZS,1,ZZL1-1)\n     ZZP2 = ' '\n     ZZR1 = STRIP(SUBSTR(ZZS,ZZL1+7))\n     INTERPRET ZZR1\n     ZZP3 = STRIP(SUBSTR(ZZS,ZZL1+6))\n     ZZB = ZZP1||ZZP2||ZZP3\n     ZZS = ZZB\n     ZZINS = 0\n     SIGNAL PROC_JCL_SKIP\n     END\n\n  IF INDEX(ZZS,' %%ENVSET ') > 0 THEN DO\n     ZZL0 = '%%SET'\n     ZZL1 = INDEX(ZZS,' %%ENVSET ')\n     ZZP1 = SUBSTR(ZZS,1,ZZL1-1)\n     ZZP2 = ' '\n     ZZR1 = STRIP(SUBSTR(ZZS,ZZL1+10))\n     IF SUBWORD(ZZR1,1,1) = 'OSEQ' THEN DO\n        ZZ_SETOSEQ_ZEROS = SUBWORD(ZZR1,2,1)\n        END\n     ZZP3 = STRIP(SUBSTR(ZZS,ZZL1+6))\n     ZZB = ZZP1||ZZP2||ZZP3\n     ZZS = ZZB\n     ZZINS = 0\n     SIGNAL PROC_JCL_SKIP\n     END\n\n  IF INDEX(ZZS,' %%PRINT ') > 0 THEN DO\n     ZZL0 = '%%OUT'\n     ZZL1 = INDEX(ZZS,' %%PRINT ')\n     ZZR1 = STRIP(SUBSTR(ZZS,ZZL1+9))\n     INTERPRET \"SAY \"||ZZR1\n     ZZS = ZZB\n     ZZINS = 0\n     SIGNAL PROC_JCL_SKIP\n     END\n\n  IF INDEX(ZZS,' %%SUB ') > 0 THEN DO\n     ZZL0 = '%%SUB'\n     ZZL1 = INDEX(ZZS,' %%SUB ')\n     ZZR1 = STRIP(SUBSTR(ZZS,ZZL1+7))\n     CALL PROC_JCL_SUB\n     ZZJCLOI = 0\n     DROP ZZJCLO.\n     ZZINS = 0\n     ZZI1 = ZZI1 + 1\n     SIGNAL PROC_JCL_REPEAT\n     END\n\n  IF INDEX(ZZS,' %%DROP ') > 0 THEN DO\n     ZZL0 = '%%DROP'\n     ZZL1 = INDEX(ZZS,' %%DROP ')\n     ZZR1 = STRIP(SUBSTR(ZZS,ZZL1+7))\n     ZZJCLOI = 0\n     DROP ZZJCLO.\n     ZZINS = 0\n     ZZI1 = ZZI1 + 1\n     SIGNAL PROC_JCL_REPEAT\n     END\n\n  DO WHILE INDEX(ZZS,'%%OYEAR') > 0\n  IF INDEX(ZZS,'%%OYEAR') > 0 THEN DO\n     ZZL0 = '%%OYEAR'\n     ZZL1 = INDEX(ZZS,'%%OYEAR')\n     ZZP1 = SUBSTR(ZZS,1,ZZL1-1)\n     ZZP2 = DATE()\n     PARSE VALUE ZZP2 WITH ZZD1 ZZM1 ZZA1\n     ZZP2 = ZZA1\n     ZZP3 = STRIP(SUBSTR(ZZS,ZZL1+7))\n     ZZB = ZZP1||ZZP2||ZZP3\n     ZZS = ZZB\n     ZZINS = 1\n     SIGNAL PROC_JCL_INSERT\n     END\n  END\n\n  DO WHILE INDEX(ZZS,'%%ODATE') > 0\n  IF INDEX(ZZS,'%%ODATE') > 0 THEN DO\n     ZZL0 = '%%ODATE'\n     ZZL1 = INDEX(ZZS,'%%ODATE')\n     ZZP1 = SUBSTR(ZZS,1,ZZL1-1)\n     ZZP2 = DATE('S')\n     ZZP3 = STRIP(SUBSTR(ZZS,ZZL1+7))\n     ZZB = ZZP1||ZZP2||ZZP3\n     ZZS = ZZB\n     ZZINS = 1\n     SIGNAL PROC_JCL_INSERT\n     END\n  END\n\n  DO WHILE INDEX(ZZS,'%%OSEQ') > 0\n  IF INDEX(ZZS,'%%OSEQ') > 0 THEN DO\n     ZZL0 = '%%OSEQ'\n     ZZL1 = INDEX(ZZS,'%%OSEQ')\n     ZZP1 = SUBSTR(ZZS,1,ZZL1-1)\n     ZZSEQTMP = ZZSEQTMP + 1\n     IF ZZ_SETOSEQ_ZEROS = 0 THEN DO\n        ZZP2 = ZZSEQTMP\n        END\n     ELSE DO\n        ZZP2 = TRANSLATE(FORMAT(ZZSEQTMP,ZZ_SETOSEQ_ZEROS),'0',' ')\n        END\n     ZZP3 = SUBSTR(ZZS,ZZL1+6)\n     ZZB = ZZP1||ZZP2||ZZP3\n     ZZS = ZZB\n     ZZINS = 0\n     END\n  END\n\n  DO WHILE INDEX(ZZS,'%%(') > 0\n  IF INDEX(ZZS,'%%(') > 0 THEN DO\n     ZZL0 = '%%'\n     ZZL1 = INDEX(ZZS,'%%(')\n     ZZP1 = SUBSTR(ZZS,1,ZZL1-1)\n     ZZP2 = STRIP(SUBSTR(ZZS,ZZL1+3,INDEX(ZZS,')')-ZZL1-3))\n     ZZP3 = SUBSTR(ZZS,INDEX(ZZS,')')+1)\n     INTERPRET \"ZZPX=\"||ZZP2\n     ZZB = ZZP1||ZZPX||ZZP3\n     ZZS = ZZB\n     ZZINS = 0\n     END\n  END\n\n  IF ZZINS = 1 THEN DO\n     SAY ZZB\n     ZZINS = 0\n     END\n\nPROC_JCL_INSERT:\n  ZZJCLOI = ZZJCLOI + 1\n  ZZJCLO.ZZJCLOI = STRIP(ZZS,'T')\n\nPROC_JCL_SKIP:\n  ZZI1 = ZZI1 + 1\n  SIGNAL PROC_JCL_REPEAT\n\nPROC_JCL_REPEAT_EXIT:\nRETURN\n\nINIT_JCL_VARS:\n  ZZVN.1 = '%%ODATE'\n  ZZVN.0 = 1\nRETURN\n\nPROC_JCL_LIST:\n  IF ZZJCLOI = 0 THEN DO\n     RETURN\n     END\n  ZZR = TSO(\"ALLOC F(TMPTMP) REUSE NEW DEL DSO(PS) SP(10) TRACK \",\n            \" RECFM(F B) LRECL(80)\")\n  ZZJCLO.0=ZZJCLOI\n  ZZR = TSO(\"EXECIO \"ZZJCLOI\" DISKW TMPTMP (STEM ZZJCLO. FINIS\")\n  ZZR = ISPF(\"LMINIT DATAID(ZDID1) DDNAME(TMPTMP) ENQ(SHR) ORG(PS)\")\n  ZZR = ISPF(\"EDIT DATAID(&ZDID1)\")\n  ZZR = ISPF(\"LMFREE DATAID(&ZDID1)\")\n  ZZR = TSO(\"FREE F(TMPTMP)\")\nRETURN\n\nPROC_JCL_TSO:\n  IF ZZJCLOI = 0 THEN DO\n     RETURN\n     END\n  DO ZZI=1 TO ZZJCLOI\n    SAY 'TSO: '||ZZJCLO.ZZI\n  END\nRETURN\n\nPROC_CMD_SCAN_DSN:\n  PARSE ARG ZZXP1,ZZXP2,ZZXP3\n\n  IF SUBSTR(STRIP(ZZXP2),1,2) = '%%' THEN DO\n     INTERPRET \"ZZEXPR=\"||SUBSTR(STRIP(ZZXP2),3)\n     END\n  ELSE DO\n     INTERPRET \"ZZEXPR='\"||ZZXP2||\"'\"\n     END\n  ZZR = ISPF(\"LMDINIT LISTID(ZZDLST) LEVEL(\"||ZZEXPR||\")\")\n  ZZIX = 0\n  ZZR = ISPF(\"LMDLIST LISTID(\"ZZDLST\") OPTION(LIST) DATASET(ZZL) ,\n             STATS(YES)\")\n  DO WHILE ZZR = 0\n    ZZIX = ZZIX + 1\n    IF ZZSTACK=0 THEN DO\n       ZZEXPR=ZZXP3||\".\"||ZZIX||\"='\"||ZZL||\"'\"\n       INTERPRET ZZEXPR\n       END\n    ELSE DO\n       QUEUE ZZL\n       END\n    ZZR = ISPF(\"LMDLIST LISTID(\"ZZDLST\") OPTION(LIST) DATASET(ZZL) ,\n               STATS(YES)\")\n  END\n  ZZR = ISPF(\"LMDFREE LISTID(\"ZZDLST\")\")\n  IF ZZSTACK=0 THEN DO\n     ZZEXPR=ZZXP3||\".0=\"||ZZIX\n     INTERPRET ZZEXPR\n     END\nRETURN\n\nPROC_JCL_SUB:\n  II = 0\n  DO II = 1 TO ZZJCLOI\n    IF ZZOUTMODE = 'LST' THEN DO\n       SAY SUBSTR(ZZJCLO.II,1,79)\n       END\n    IF ZZOUTMODE = 'RDR' THEN DO\n       QUEUE ZZJCLO.II\n       END\n  END\n  IF ZZOUTMODE = 'RDR' THEN DO\n     ZZRR = TSO(\"EXECIO \" ZZJCLOI \" DISKW INTRDR (FINIS\")\n     END\nRETURN\n\nPROC_CMD_SCAN_LIB:\n  PARSE ARG ZZXP1,ZZXP2,ZZXP3\n\n  IF SUBSTR(STRIP(ZZXP2),1,2) = '%%' THEN DO\n     INTERPRET \"ZZEXPR=\"||SUBSTR(STRIP(ZZXP2),3)\n     END\n  ELSE DO\n     INTERPRET \"ZZEXPR='\"||ZZXP2||\"'\"\n     END\n  \"ISPEXEC LMINIT DATAID(ID) DATASET('\"||ZZEXPR||\"') ORG(PO)\"\n  \"ISPEXEC LMOPEN DATAID(\"ID\")\"\n\n  ZZMOD = \"\"\n  ZZIX = 0\n  \"ISPEXEC LMMLIST DATAID(\"ID\") OPTION(LIST) MEMBER(ZZMOD)\"\n  DO WHILE RC = 0\n    ZZIX = ZZIX + 1\n    IF ZZSTACK=0 THEN DO\n       ZZEXPR=ZZXP3||\".\"||ZZIX||\"='\"||ZZMOD||\"'\"\n       INTERPRET ZZEXPR\n       END\n    ELSE DO\n       QUEUE ZZMOD\n       END\n    \"ISPEXEC LMMLIST DATAID(\"ID\") OPTION(LIST) MEMBER(ZZMOD)\"\n  END\n\n  \"ISPEXEC LMCLOSE DATAID(\"ID\")\"\n  IF ZZSTACK=0 THEN DO\n     ZZEXPR=ZZXP3||\".0=\"||ZZIX\n     INTERPRET ZZEXPR\n     END\n\nRETURN\n\nPROC_CMD_SCAN_SEQ:\n  PARSE ARG ZZXP1,ZZXP2,ZZXP3\n\n  IF SUBSTR(STRIP(ZZXP2),1,2) = '%%' THEN DO\n     INTERPRET \"ZZEXPR=\"||SUBSTR(STRIP(ZZXP2),3)\n     END\n  ELSE DO\n     INTERPRET \"ZZEXPR='\"||ZZXP2||\"'\"\n     END\n  ZZRR = TSO(\"ALLOC F(RXTMP) DA('\"||ZZEXPR||\"') SHR\")\n\n  IF ZZXP3 \\= '' THEN DO\n     ZZRR = TSO(\"EXECIO * DISKR RXTMP (STEM \"ZZXP3||\". FINIS\")\n     END\n  ELSE DO\n     ZZRR = TSO(\"EXECIO * DISKR RXTMP (FINIS\")\n     END\n  ZZRR = TSO(\"FREE F(RXTMP)\")\n\nRETURN\n\nTSO:\n  PARSE ARG XCMD\n  XMSG = OUTTRAP(ZZMSG.)\n  ADDRESS TSO XCMD\n  IF ZZDEBUG=1 THEN DO\n     SAY 'TSO('RC'):'XCMD\n     END\n  RRC = RC\n  XCMS = OUTTRAP()\nRETURN RRC\n\nISPF:\n  PARSE ARG XCMD\n  ADDRESS ISPEXEC XCMD\n  IF ZZDEBUG=1 THEN DO\n     SAY 'ISPF('RC'):'XCMD\n     END\n  RRC = RC\nRETURN RC\n\nMAKEMAP:\n  ZZR=ISPF(\"LMINIT DATAID(DDM) DDNAME(RRTEMP) ENQ(EXCLU)\")\n  ZZR=ISPF(\"LMOPEN DATAID(&DDM) OPTION(OUTPUT)\")\n  CALL LINEWRITE \")ATTR\"\n  CALL LINEWRITE \"+ TYPE(NT)\"\n  CALL LINEWRITE \"? TYPE(CH)\"\n  CALL LINEWRITE \"# TYPE(OUTPUT) JUST(ASIS) CAPS(OFF)\"\n  CALL LINEWRITE \"@ TYPE(INPUT) JUST(ASIS) CAPS(OFF) COLOR(GREEN)\"\n  CALL LINEWRITE \"_ TYPE(INPUT) JUST(ASIS) CAPS(OFF) COLOR(YELLOW)\"\n  CALL LINEWRITE \")BODY WINDOW(70,\"||ZZIMAP+2||\")\"\n  DO ZZIL = 0 TO ZZIMAP\n    CALL LINEWRITE ZZMMAP.ZZIL\n  END\n  CALL LINEWRITE \")INIT\"\n  CALL LINEWRITE \")REINIT\"\n  CALL LINEWRITE \" REFRESH(*)\"\n  CALL LINEWRITE \")PROC\"\n  CALL LINEWRITE \"  IF (.RESP = ENTER)\"\n  CALL LINEWRITE \"     &KEY = 'ENTER'\"\n  CALL LINEWRITE \"  ELSE\"\n  CALL LINEWRITE \"     &KEY = .PFKEY\"\n  CALL LINEWRITE \"  &ZCURSOR = .CURSOR\"\n  CALL LINEWRITE \")END\"\n  RRC=ISPF(\"LMMADD DATAID(&DDM) MEMBER(\"||ZZMNMAP||\")\")\n  RRC=ISPF(\"LMFREE DATAID(&DDM)\")\nRETURN\n\nLINEWRITE:\n  PARSE ARG ZZREC\n  RRC=ISPF(\"LMPUT DATAID(&DDM) MODE(INVAR) DATALOC(ZZREC) DATALEN(80)\")\nRETURN RRC\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT756/FILE756.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT756", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}