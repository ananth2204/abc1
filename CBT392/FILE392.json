{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220011918000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 4585308, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 42, "INMDSNAM": "CBT.V500.FILE392.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 4585308, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 4585308, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE392.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00J\\x14'", "DS1TRBAL": "b'[>'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x02\\xcf\\x00\\x06\\x02\\xd4\\x00\\x05\\x00K'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$$CPYR": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x009\\x00\\x893?\\x01\\x02\\x10\\x0f\\x061\\x00X\\x00X\\x00\\x0e\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1989-11-29T00:00:00", "modifydate": "2002-04-10T06:31:39", "lines": 88, "newlines": 88, "modlines": 14, "user": "SBGOLOB"}, "text": "***********************************************************************\n*                                                                     *\n*                *===================================*                *\n*                *  COPYRIGHT NOTICE AND DISCLAIMER  *                *\n*                *===================================*                *\n*                                                                     *\n*   Copyright (c) 1991, 1990, 1989 by Leonard D. Woren.               *\n*   All rights reserved, except as explicitly noted herein.  This     *\n*   program may be used, modified, and distributed, provided that     *\n*   all of the following conditions are met:                          *\n*                                                                     *\n*   (1)  This notice and all references to the original author(s)     *\n*        are retained forever in all copies and versions of the       *\n*        source.                                                      *\n*                                                                     *\n*   (2)  This program may be distributed via \"public domain\" mods     *\n*        tapes, such as the SHARE mods tape, the CBT (Connecticut     *\n*        Bank and Trust) tape, the LA MVSUG (Los Angeles MVS User's   *\n*        Group) tape, etc, etc.  Only versions of this program        *\n*        authorized by Leonard D. Woren may be placed on these        *\n*        tapes.  Distribution of modified versions of this program,   *\n*        via the above named tapes or via any method, is              *\n*        specifically prohibited.                                     *\n*                                                                     *\n*   (3)  Permission is specifically NOT given to distribute MODIFIED  *\n*        versions of this program.  Modified versions may be used     *\n*        only at the site making the mods.                            *\n*                                                                     *\n*   (4)  The only charge which may be made for distribution is to     *\n*        recover real costs, such as postage, or creating a tape.     *\n*                                                                     *\n*   (5)  The only charge for running the program which may be made    *\n*        is your normal charge for computer time.                     *\n*                                                                     *\n*                                                                     *\n*   The reason for the restrictions on distribution of modified       *\n*   versions is to try to prevent circulation of many different       *\n*   versions of the program, each with a few features that aren't     *\n*   in any other version.                                             *\n*                                                                     *\n*   Since everyone will benefit from this, please send all updates    *\n*   to me.  (Address below.)  I will try merge them in, if they       *\n*   have been made to a reasonably current version of the source,     *\n*   and if they are in keeping with the general design of the rest    *\n*   of the program.  Mods may be altered by me for this purpose.      *\n*   Any such mods which are incorporated into the program will then   *\n*   become governed by the restrictions specified here for the whole  *\n*   program, with appropriate credit to the contributor.              *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*   Although this program has been extensively tested, and is in use  *\n*   in a production environment (MVS/ESA release 3.1.0e, with DFP     *\n*   3.1.1), no guarantee is made of (or responsibility assumed for)   *\n*   correct or reliable operation.  I may try to help with problems.  *\n*   I do not assume any responsibility to distribute updates.         *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*   CONTACT:                                                          *\n*          Leonard D. Woren                                           *\n*        snail-mail:                                                  *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*        e-mail:                                                      *\n*          ldw@ldworen.net                                            *\n*                                                                     *\n*        web site:  http://ldworen.net                                *\n*                                                                     *\n*                                                                     *\n*                                                                     *\n*          I prefer electronic mail.  If you call me long distance    *\n*          and leave a msg because you didn't get me, there's a good  *\n*          chance that I won't call back.  Moral:  don't leave a      *\n*          message for me to call you back unless you're in 213,      *\n*          818, or 714.  Sorry.                                       *\n*                                                                     *\n*                                                                     *\n*          SHARE installation code:  USC                              *\n*          GUIDE installation code:  OUY  (membership lapsed)         *\n*                                                                     *\n***********************************************************************\n         EJECT ,\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$$INDEX": {"ttr": 519, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00\\x00\\x00\\x84!_\\x00\\x91\\x04/\\x00S\\x00a\\x00O\\x00\\x13\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "1984-08-02T00:00:00", "modifydate": "1991-02-11T00:53:00", "lines": 97, "newlines": 79, "modlines": 19, "user": "LDW"}, "text": "                Index to members of LDW.Q.ASM\n\n>>>>>>>>>>>>>>>>>>>>>>>> JCL and documentation <<<<<<<<<<<<<<<<<<<<<<<<\n\n$$$INDEX - this index\n$$$INST  - installation instructions\n$$ASM    - JCL to assemble 1 routine and relink main load module\n$$ASM#CT - JCL to assemble text module for 'CHANGES' subcommand\n$$ASM#HT - JCL to assemble text module for 'HELP' subcommand\n$$ASMALL - JCL to assemble all of QUEUE and create main load module\n$$ASMATH - JCL to assemble QAUTH -- needed for ISPF interface\n$$ASMDOC - JCL to assemble dsects only\n$$ASMISR - JCL to assemble ISRQ -- needed for ISPF intfc if ISPF < V3R2\n$INCLUDE - (see QUEUELNK proc) -- include for old load module\n$NULL    - (see QUEUELNK proc) -- null member to fool JCL\n$ORDER   - order cards for optimum load module structure\n$UFDOC   - copy of update listing for University of Florida version\n$UPDATES - list of updates done by Leonard Woren (LDW), Steve McGinty\n           (SDM), and Eric Schindler (EMS)\nISRQ     - interface module to support ISPF before V3R2\nOACFSORT - macro from UCLA/OAC for invoking OACFSORT program\nOACFSRT  - source from UCLA/OAC to in-storage sort program\nQAUTH    - APF authorized loophole program to support ISPF execution\nQCMDS    - ISPF commands table for QQ command\nQNEWCMD  - macro to return to main loop and execute a new QUEUE subcmd\nQPENTRY  - ISPF panel to invoke QUEUE with alternate options\nQPTBL    - ISPF panel for QUEUE table displays\nQUECMD   - clist to support ISPF mode QQ subcommand\nQUEUEASM - proc to assemble QUEUE...  copy to your proclib\nQUEUELNK - proc to link     QUEUE...  copy to your proclib\nSPFQUEUE - clist to support ISPF mode\n\n>>>>>>>>>>>>>>>>>>>>>>>>>>>> miscellaneous <<<<<<<<<<<<<<<<<<<<<<<<<<<<\n\nQ##ALL   - copy statements to assemble all routines\nQ##END   - end stmt\nQ##TITLE - title statement and copy for QGLOBALS\nQGLOBALS - QUEUE assembly time option variables\nQUEUE    - copy statements to assemble whole thing\n\n>>>>>>>>>>>>>>>>>>>>>>>>>>> Source routines <<<<<<<<<<<<<<<<<<<<<<<<<<<\n\nQ#AL     - Allocate\nQ#AT     - Attr\nQ#BL     - Blklist\nQ#CH     - Changes\nQ#CT     - actual screen image text constants for 'Changes'\nQ#CK     - Ckpt\nQ#CP     - CPU\nQ#DD     - Ddname\nQ#DF     - Datefmt\nQ#DY     - Display\nQ#FJ     - Findjob\nQ#FR     - Findrje\nQ#FM     - Format\nQ#HE     - Help\nQ#HT     - actual screen image text constants for 'Help'\nQ#HB     - Hexblk\nQ#HF     - Hexfmt\nQ#II     - Initial\nQ#IN     - Inits\nQ#JN     - Jesnews\nQ#JI     - Jobinfo\nQ#JS     - Jobsumm\nQ#LI     - List\nQ#LD     - Listds\nQ#MC     - Mcs\nQ#MO     - Mode\nQ#OC     - Opercmd\nQ#PA     - Parse\nQ#PF     - Pfkset\nQ#PR     - Print\nQ#QD     - QCOMMON Csect and all Dsects\nQ#QQ     - QUEUE mainline\nQ#RS     - Readspc\nQ#RP     - Repos\nQ#RL     - Rmtlist\nQ#SV     - Saveds\nQ#SR     - Search\nQ#SY     - Syslist\nQ#SL     - Syslog\nQ#SO     - Sysout\nQ#TC     - Tsocmd\n\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Macros <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n\n$JQT     - phony dsect to describe $QINDEX\nQ....... - macros to invoke JES2 or OS macros (i didn't have ASMH)\nQCALL    - call another QUEUE routine\nQCMDE    - define QUEUE subcommand parse table entry\nQCOMMON  - common area definition\nQDCB     - all DCBs for QCOMMON\nQITEM    - format an item (used by \"Jobinfo\")\nQNEXT    - pick up JQE or JOE offset\nQSTART   - housekeeping at entry to a routine\nQSVC     - invoke special services SVC\nQTILT    - display error message and abort current subcommand\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$$INST": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x1f\\x00\\x00\\x00\\x83\\x08?\\x00\\x92\\t\\x0f\" \\x01$\\x00E\\x01\\x1f\\xe2\\xc1\\xd4\\xc7@@@@@@'", "ispf": {"version": "01.31", "flags": 0, "createdate": "1983-03-24T00:00:00", "modifydate": "1992-03-30T22:20:00", "lines": 292, "newlines": 69, "modlines": 287, "user": "SAMG"}, "text": "#######################################################################\n#                                                                     #\n#  The standard SHARE mods disclaimer applies.  I am using this       #\n#  program.  It mostly works.  If it doesn't work for you, oh well.   #\n#  You can let me know, and I *may* try to fix it.  There are a lot   #\n#  of known bugs, but I haven't time recently to try to fix them.     #\n#  There are also a number of features which are not complete and/or  #\n#  have bugs.  I am continually improving QUEUE (fixing bugs, adding  #\n#  features, adding new bugs.)  I therefore request that I get a      #\n#  copy of any fixes/additions which are made so that I can           #\n#  integrate them back into my base.                                  #\n#                                                                     #\n#  I also request that modified versions of this version of QUEUE     #\n#  *NOT* be distributed.  Only unmodified copies of this version      #\n#  may be distributed (as it comes from me or on the SHARE JES2       #\n#  mods tape.)  I would like to avoid the problem with the previous   #\n#  version where there are many different versions of it floating     #\n#  around.  I would rather have all features in a single version.     #\n#  This will better serve all users.  (I will be providing in a       #\n#  future version \"exit points\" where installation local source       #\n#  code can be easily inserted without having to have it in the       #\n#  standard source modules.)                                          #\n#                                                                     #\n#                                                                     #\n#  NOTE:   As of this writing (July 1991, the HELP is close to        #\n#          complete, but the CHGS subcommand data is now very         #\n#          badly out of date.  I may try to update CHGS soon.         #\n#          There is also one major very annoying bug:                 #\n#          under some error conditions, you can get a message         #\n#          \"PRIMARY AND LINE COMMANDS MUTUALLY EXCLUSIVE\", and        #\n#          cannot get out.  It turns out that the only way out of     #\n#          this situation is to hit a PF key, like HELP.  I will      #\n#          try to have a fix for this A.S.A.P.  Sigh.  It seems that  #\n#          this got worse when I added the ISPF support.  You now     #\n#          have to attention out.  Maybe Guy Albertelli can fix this. #\n#                                                                     #\n#                                                                     #\n#          Leonard D. Woren                                           #\n#          University of Southern California                          #\n#                                                                     #\n#          (See $$$$CPYR for address and phone number.)               #\n#                                                                     #\n#######################################################################\n\n\nInstallation instructions for QUEUE:\n\n*** NOTE *** This (my) version of QUEUE is drastically reorganized from\n             other versions.\n\nIn late 1990 and early 1991, I incorporated much of Guy Albertelli's\n(B. F. Goodrich) mods to QUEUE.  This project is not finished at this\ntime.  Also, the ISPF interface still has some problems, but is\nbasically usable.\n\n\n\n 1) Reload the 3 libraries on this tape\n    FILE 1 - DSN=QUEUE.ASM       (This file)\n    FILE 2 - DSN=MACLIB          (File 179 on the CBT Tape)\n    FILE 3 - DSN=TSOCMDS.ASM     (File 180 on the CBT Tape)\n\n 2) It is strongly recommended that you create another library and do\n    all customizing described below into that library, so that if you\n    get a refresh copy of this library, you won't have to remember to\n    copy all your own members back again.  If this is done, you will\n    need to update the QUEUEASM proc and place the local dataset in\n    front of this dataset.  Specifically suggested:  all JCL members\n    that you use, the QUEUEASM and QUEUELNK procs if you use private\n    proclib support.\n\n 3) Update all values in MACLIB(@GLOBALS) and MACLIB(@GLOBALC)\n    appropriately for your shop.  (Data specific to QUEUE is described\n    below.)  These variables are so that programs like QUEUE that have\n    installation dependent settings don't need to be modified each\n    time a new version is obtained.\n    ***  All option variables have been moved from QGLOBALS to    ***\n    ***  @GLOBALS and @GLOBALC.                                   ***\n\n 4) Edit the JCL (jobcard, sysout, dsnames, especially MACLIBs)\n    in the following members:\n    $$ASM     - Use this to assemble and relink one routine without\n                needing to assemble the whole thing.  (Not needed if\n                you don't modify QUEUE.)\n    $$ASMALL  - JCL to assemble and link the main load module (QUEUE).\n    $$ASMATH  - JCL to asm/link the ISPF authorization module (QAUTH).\n    $$ASMISR  - JCL to asm/link the ISPF front-end module (ISRQ).\n                ISRQ is not used if you are running ISPF V3R2 or later.\n    $$ASM#CT  - JCL to a/l the text for the 'CHGS' subcmd (QCHGTXT).\n    $$ASM#HT  - JCL to a/l the text for the 'HELP' subcmd (QHLPTXT).\n    QUEUEASM  - The assembly proc.  If you don't have JES2 V4 or a mod\n                for user proclibs installed, copy this and QUEUELNK to\n                a system proclib.  If you do not have SYS1.MODGEN,\n                change SYS1.MODGEN to SYS1.AMODGEN .\n    QUEUELNK  - The linkedit proc.\n    *NOTE* -- If you don't have ASMH, you will probably get assembly\n                errors in $$ASM#CT and/or $$ASM#HT.  This is because\n                ASMFX only allows 2 continuation cards, and these\n                source members (Q#CT and Q#HT) are generated by a\n                program that reads an image file.  To get them to\n                assemble under FX, you will have to fix the handful\n                of places where FX says there are too many\n                continuations.  This affects so few people that it's\n                not worth my time to do something about it.  Get ASMH.\n\n 5a) Set installation options in MACLIB(@GLOBALS)\n    &@@QALTC - If you have installed the 'alternate comm char' JESMOD,\n               set this to the name of the $SVT field containing the\n               alt comm char.\n    &@@QCKNC - Set to the number of DECBs to be generated for reading\n               HASPCKPT.  This many READs will be issued before CHECK.\n               This is irrelevant when using APPLCOPY.\n    &@@QDOC  - Set to 'GEN' or 'NOGEN' to control expansion of JES2\n               and MVS DSECTS.\n    &@@QJOWN - If you have installed a mod that puts the submittor's\n               userid into the JQE, set this variable to the name of\n               that field.  Otherwise, set to null.  With JES2 3.1.3\n               or later, the mod is unnecessary and QSTART will\n               automatically set &@@QJOWN to JQEUSRID.\n    &@@QNJE  - Set to 1 only if you are running non-SP NJE JES2.\n               (HJE1104 or JJE1112).\n               *** See Note1 below regarding support. ***\n    &@@QPRNT - Set to 'GEN' or 'NOGEN' to control expansion of other\n               macros.\n    &@@QSFXC - Set to the suffix for your checkpoint dsname,\n               normally '.HASPCKPT'\n    &@@QSFXS - Set to the suffix for your haspace dsname,\n               normally '.HASPACE'\n    &@@QSTDF - Set to the name of your installation standard forms\n               (&STDFORM in JES2 parms).\n    &@@TMPSV - Set to 1 to use the TMPSRV/TMPMAC interface to attach\n               TSO commands from within QUEUE.  Also used if not APF\n               authorized for CANCEL, DELETE, and REQUEUE subcommands.\n    &@@QXKEY - Currently unused.\n    &QLEVEL  - Is now automatically set by QSTART:\n               (Note:  JES2 4.1 pre AZ27300 is no longer supported)\n               EJE1102 =  3 (4.1 + AZ27300)\n               EJE1103 =  3 (4.1 + AZ27300 + E3800)\n               JJE1112 =  3 (NJE 3.0)          (I think this works...)\n               HJE1104 =  3 (NJE 3.1 + E3800)  (I think this works...)\n               HJE2226 =  4 (SP1.3.0)\n               HJE2329 =  5 (SP1.3.3)\n               HJE2330 =  6 (SP1.3.4)\n               *** If you are running any of the above releases of\n               *** JES2, or 2.1.5, see Note1 below regarding support.\n               HJE1367 =  7 (SP1.3.6)\n               HJE2215 =  7 (SP2.1.5)\n               HJE2221 =  8 (SP2.2.0)\n               HJE3311 =  9 (SP3.1.1)\n               HJE3313 = 10 (SP3.1.3)\n               HJE4410 = 11 (SP4.1.0)\n               HJE4420 = 12 (SP4.2.0)\n\n    Note:  Generation of the ACF2 interface is now under control of\n               the &@@ACF2 variable in @GLOBALS.)\n               Note that this interface is not the one that\n               originally appeared in other people's versions of QUEUE.\n\n 5b) Set installation options in MACLIB(@GLOBALC)\n     * Be sure not to change the lengths of any constants *\n    At .QLCL - Set elements of this array to names that will be\n               treated as 'LOCAL' when looking for local output.\n               At another shop, this was used because we had local unit\n               routes to select printers with different features, but\n               want to see all the output when using the \"DO\" subcmd.\n    At .QJES - This is a table to support running the same QUEUE load\n               module on different JES2 systems, and also to support\n               secondary subsystems.  Each element consists of\n                 CL6'SYSRES_volser',CL4'JES_subsys_name'\n                 CL6'CHKPT_volser',CL44'CHKPT/HASPACE_prefix'\n               At QUEUE initialization, the current IPL volume and\n               current JES2 subsystem name are used as lookup keys into\n               this table.  When the correct entry is found, the CHKPT\n               volser and prefix are extracted.  (The default JES2 name\n               is the one you are logged on to.  I use a trick from\n               Keith Moe of Amdahl which allows me to LOGON to a\n               secondary JES2.)  If you want to select a non-default\n               JES2, enter (for example):\n                 QUEUE JES(JESA)\n    At .QPFK - Default PFK settings.  I strongly discourage changing\n               changing these defaults, particularly the ones which\n               are set up for compatibility with ISPF:\n               help, end, find, and the 4 scroll keys.\n               * Do not delete or insert any lines *\n    At .QSID - This is an array of pairs of ids.  The first in each\n               pair is the SMF id.  The second is what QUEUE will\n               display instead.  If you want your actual SMF system ids\n               to be displayed (recommended), omit these lines.  This\n               is used for lying to the end users -- for example, I had\n               a 3081 with SMFid=SCG3, and a 4341 with SMFid=SCG4,\n               .QSID  DC  CL4'SCG3',CL4'3081'\n                      DC  CL4'SCG4',CL4'4341'\n               so that the displays would show 3081 and 4341 instead\n               of SCG3 and SCG4.  This feature was needed because of\n               the code to pick up the SYSIDs from the QSE'S.\n\n 6) Submit jobs in members $$ASMALL, $$ASM#CT, $$ASM#HT.  If you want\n    to install the ISPF interface, also submit $$ASMATH and if your\n    ISPF is prior to V3R2, submit $$ASMISR.\n\n 7) Assemble member OACFSRT as load module OACFSORT and link into an\n    an appropriate library (RENT).  Sorry, no JCL provided yet.\n\n 8) If you are going to use it, assemble TMPSRV from the other source\n    library.  It needs SYS1.MACLIB, SYS1.MODGEN (use SYS1.AMODGEN if\n    you haven't installed the SPE that creates SYS1.MODGEN) and my\n    MACLIB.  It should be linked RENT/REUS/REFR.  If you have OACTMP\n    from UCLA, you can alias TMPSRV to OACTMP.\n\n 9) If you are going to use it, assemble CONS and TERMIO1,2,3,4,5 from\n    the other source library.  They need SYS1.MACLIB, SYS1.MODGEN (see\n    note in previous step) and my MACLIB.  Both should be linked\n    RENT/REUS/REFR.  LKED control for TERMIO is as follows:\n       ORDER TERMIO1,TERMIO2,TERMIO3,TERMIO4,TERMIO5\n       ENTRY TERMIO1\n       NAME  TERMIO(R)\n    (If you don't have the appropriate version of PVTMACS, you can\n    rename IEETDCM@ and IEERDCM@ to IEETDCM and IEERDCM in my MACLIB.\n    These are the non-SP (therefore, non-copyrighted) versions, but\n    CONS is not yet dependent on any of the new fields.  You should\n    get the current PVTMACS, though.  Future versions of CONS probably\n    will be dependent on new fields.\n\n10) Load module placement\n    QUEUE   - Can be placed in a LPA for performance reasons.\n    QAUTH   - Can go in LPA if desired.\n    ISRQ    - Can go in LPA if desired.\n    QHLPTXT - Linklist library recommended, due to size and\n              infrequent usage.  (Only loaded if needed.)\n    QCHGTXT - Same as QHLPTXT.\n    TMPSRV  - Same as QUEUE.\n    TERMIO  - Same as QUEUE.\n    OACFSORT- Same as QUEUE.\n\n    This version of QUEUE does not have a separate QCOMMON loadmod.\n\n11) ISPF support:\n    (a)  The QAUTH and ISRQ (ISPF < V3R2) modules must be installed.\n    (b)  QAUTH must be added to the list of APF authorized service\n         programs.  If you are running a current release of TSO/E,\n         this is in the AUTHTSF operand in SYS1.PARMLIB(IKJTSO00).\n         If you are running an obsolete release of TSO/E, it will be\n         be in CSECT IKJEFTAP (?).  If you're not running TSO/E, give\n         up now.\n    (c)  Copy members QPENTRY, QPTBL, and QPBRO to an ISPF panels\n         library.\n    (d)  Copy SPFQUEUE into a clist library.  If you are running TSO/E\n         V2 or later, you can use the Rexx version SPFQUEUX instead --\n         install it under the name SPFQUEUE.\n    (e)  Copy QCEDIMAC into a clist library.\n    (f)  Add the following into the &ZSEL TRANS statement in the )PROC\n         section of some ISPF menu, like ISR@PRIM:\n                Q,'CMD(%SPFQUEUE    ) NEWAPPL(Q) NEWPOOL'  /* USC */\n               QX,'CMD(%SPFQUEUE ALT) NEWAPPL(Q) NEWPOOL'  /* USC */\n         If you want one or both of these to be visible, you will also\n         have to add something in the )BODY section.\n    (g)  If you are running an ISPF older than V3R2 (actually I don't\n         know about V3R1), copy QCMDS into an ISPF tables library, and\n         copy QCQQ into a clist library.  If you are running TSO/E V2\n         or later, you can use the Rexx version QCQQX instead --\n         install it under the name QCQQ.\n         *** If you are running an ISPF older than V2R3, see Note1\n         *** below regarding support.\n\n\n Note1  It is likely that at some point in the not too distant future\n        I will remove all code from QUEUE which supports any of the\n        following.  If this will be a problem for you, please let me\n        know and I'll reconsider.\n        (a)  ISPF releases prior to V2R3.  Everyone should be running\n             at least Version 2, and if so, you can upgrade to V2R3.\n             V2R3 is the release which introduced the BRIF interface.\n        (b)  Non-SP NJE JES2.  (Indicated by setting &@@QNJE to 1.)\n             If you were willing to pay for this, you have probably\n             converted to SP long ago.\n        (c)  JES2 releases unsupported by IBM.  Specifically, QUEUE\n             support will be dropped for all releases except 1.3.6,\n             2.1.5, 2.2.0, 3.1.1, 3.1.3, 4.1, 4.2 .\n\n\n\n Note2  There are some members in the Q.ASM source dataset which may\n        have meaning only to me.  Ignore them.\n\n Note3  The linkedit of the main QUEUE load module will have some\n        unresolved external references.  CHGSTEXT and HELPTEXT are\n        weak externals, in case you don't want QHLPTXT and QCHGTXT\n        to be separate load modules.  The following unresolved\n        references are for features not yet written, and as such do\n        not represent errors:\n        SETUP, AT#KEYS, CB#KEYS, DQ#KEYS, CKPT$PC\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$$SPLIT": {"ttr": 528, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x12\\x00\\x00\\x00\\x86(\\x9f\\x00\\x91&_!V\\x01\\xc7\\x00\\t\\x01\\xc7\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.18", "flags": 0, "createdate": "1986-10-16T00:00:00", "modifydate": "1991-09-22T21:56:00", "lines": 455, "newlines": 9, "modlines": 455, "user": "LDW"}, "text": "//LDWQSPLT  JOB (ZSY11,4L00),'LEONARD D. WOREN',MSGCLASS=T,NOTIFY=LDW,\n//           CLASS=D,REGION=1024K\n/*JOBPARM L=100,F=SDB4\n//* JCL DSN ==> LDW.Q.ASM($$$SPLIT) <==\n//*---\n//* 10 WAY SPLIT TO SHIP OVER BITNET: (7-8 TRACK DATASETS ON 3380)\n//* 0:  BITBUCKET\n//*---\n//DELETE   EXEC PGM=IDCAMS\n//SYSPRINT  DD  SYSOUT=*\n//SYSIN     DD  *\n  DELETE  LDW.QSPLIT.*\n  SET MAXCC =  0\n/*\n//*---\n//IEBCOPY  EXEC PGM=PDSFAST\n//SYSPRINT  DD  SYSOUT=*\n//IN        DD  DISP=SHR,DSN=LDW.Q.ASM\n//MACLIB    DD  DISP=SHR,DSN=LDW.MACLIB\n//OUT00     DD  DISP=(NEW,CATLG),DSN=LDW.QSPLIT.PART00,\n//             UNIT=DATA,SPACE=(TRK,(15,5,10))\n//OUT01     DD  DISP=(NEW,CATLG),DSN=LDW.QSPLIT.PART01,\n//             UNIT=DATA,SPACE=(TRK,(7,1,35))\n//OUT02     DD  DISP=(NEW,CATLG),DSN=LDW.QSPLIT.PART02,\n//             UNIT=DATA,SPACE=(TRK,(7,1,10))\n//OUT03     DD  DISP=(NEW,CATLG),DSN=LDW.QSPLIT.PART03,\n//             UNIT=DATA,SPACE=(TRK,(7,1,10))\n//OUT04     DD  DISP=(NEW,CATLG),DSN=LDW.QSPLIT.PART04,\n//             UNIT=DATA,SPACE=(TRK,(7,1,10))\n//OUT05     DD  DISP=(NEW,CATLG),DSN=LDW.QSPLIT.PART05,\n//             UNIT=DATA,SPACE=(TRK,(7,1,10))\n//OUT06     DD  DISP=(NEW,CATLG),DSN=LDW.QSPLIT.PART06,\n//             UNIT=DATA,SPACE=(TRK,(7,1,10))\n//OUT07     DD  DISP=(NEW,CATLG),DSN=LDW.QSPLIT.PART07,\n//             UNIT=DATA,SPACE=(TRK,(7,1,10))\n//OUT08     DD  DISP=(NEW,CATLG),DSN=LDW.QSPLIT.PART08,\n//             UNIT=DATA,SPACE=(TRK,(7,1,10))\n//OUT09     DD  DISP=(NEW,CATLG),DSN=LDW.QSPLIT.PART09,\n//             UNIT=DATA,SPACE=(TRK,(7,1,10))\n//OUT10     DD  DISP=(NEW,CATLG),DSN=LDW.QSPLIT.PART10,\n//             UNIT=DATA,SPACE=(TRK,(7,1,15))\n//OUT11     DD  DISP=(NEW,CATLG),DSN=LDW.QSPLIT.PART11,\n//             UNIT=DATA,SPACE=(TRK,(7,1,15))\n//OUTMAC    DD  DISP=(NEW,CATLG),DSN=LDW.QSPLIT.MACLIB,\n//             UNIT=DATA,SPACE=(TRK,(7,1,10))\n//SYSIN     DD  *\n C I=IN,O=OUT01,L=NO\n   S M=$$$$CPYR\n   S M=$$$INDEX\n   S M=$$$INST\n   S M=$$$SPLIT\n   S M=$$ASM\n   S M=$$ASM#CT\n   S M=$$ASM#HT\n   S M=$$ASMALL\n   S M=$$ASMATH\n   S M=$$ASMCHK\n   S M=$$ASMDOC\n   S M=$$ASMISR\n   S M=$$ASMX\n   S M=$$IPOALL\n   S M=$$MAC\n   S M=$$NEWALL\n   S M=$$NEWASM\n   S M=$$NEWCHK\n   S M=$$NEWDOC\n   S M=$$NEWMAC\n   S M=$INCLUDE\n   S M=$INCLUDX\n   S M=$JQT\n   S M=$NULL\n   S M=$ORDER\n   S M=$UFDOC\n   S M=$UPDATES\n   S M=#MHELP\n   S M=C\n   S M=ISRQ\n   S M=OACFSORT\n   S M=OACFSRT\n   S M=Q$BUFFER\n   S M=Q$CHK\n   S M=Q$DAS\n   S M=Q$DCT\n C I=IN,O=OUT02,L=NO\n   S M=Q$HASB\n   S M=Q$HCCT\n   S M=Q$HCT\n   S M=Q$HDP\n   S M=Q$HFAME\n   S M=Q$HQR\n   S M=Q$HQT\n   S M=Q$IOT\n   S M=Q$JCT\n   S M=Q$JOE\n   S M=Q$JOT\n   S M=Q$JQE\n   S M=Q$JQT\n   S M=Q$KAC\n   S M=Q$KIT\n   S M=Q$LCK\n   S M=Q$LMT\n   S M=Q$LRC\n   S M=Q$MIT\n   S M=Q$NHD\n   S M=Q$PADDR\n   S M=Q$PCE\n   S M=Q$PDDB\n   S M=Q$PIT\n   S M=Q$QSE\n   S M=Q$RDT\n   S M=Q$SJB\n   S M=Q$SVT\n   S M=Q$TAB\n   S M=Q$TGM\n   S M=Q$TQE\n   S M=Q$XECB\n   S M=Q##ALL\n   S M=Q##END\n   S M=Q##MXREF\n   S M=Q##TITLE\n   S M=Q#AF\n   S M=Q#AL\n   S M=Q#AT\n   S M=Q#BL\n   S M=Q#CB\n C I=IN,O=OUT03,L=NO\n   S M=Q#CB#ACF\n   S M=Q#CB#HCT\n   S M=Q#CB#IOT\n   S M=Q#CB#JCT\n   S M=Q#CB#JOE\n   S M=Q#CB#JOT\n   S M=Q#CB#JQE\n   S M=Q#CB#PDB\n   S M=Q#CH\n   S M=Q#CK\n   S M=Q#CP\n   S M=Q#CT\n   S M=Q#DD\n C I=IN,O=OUT04,L=NO\n   S M=Q#DL\n   S M=Q#DY\n   S M=Q#FJ\n   S M=Q#FM\n C I=IN,O=OUT05,L=NO\n   S M=Q#FR\n   S M=Q#GR\n   S M=Q#GP\n   S M=Q#HB\n   S M=Q#HE\n   S M=Q#HT\n C I=IN,O=OUT06,L=NO\n   S M=Q#II\n   S M=Q#IN\n   S M=Q#JI\n   S M=Q#JN\n C I=IN,O=OUT07,L=NO\n   S M=Q#JS\n   S M=Q#KL\n   S M=Q#LD\n   S M=Q#LI\n   S M=Q#LT\n   S M=Q#MC\n   S M=Q#MO\n C I=IN,O=OUT08,L=NO\n   S M=Q#OC\n   S M=Q#PA\n   S M=Q#PF\n   S M=Q#PR\n   S M=Q#QC\n   S M=Q#QD\n   S M=Q#QI\n   S M=Q#QQ\n C I=IN,O=OUT09,L=NO\n   S M=Q#QS\n   S M=Q#RL\n   S M=Q#RP\n   S M=Q#RS\n   S M=Q#SF\n   S M=Q#SL\n   S M=Q#SO\n   S M=Q#SR\n C I=IN,O=OUT10,L=NO\n   S M=Q#SV\n   S M=Q#SY\n   S M=Q#TC\n   S M=Q#TG\n   S M=QAPF\n   S M=QAUTH\n   S M=QCALL\n   S M=QCBFE\n   S M=QCBLKNUM\n   S M=QCEDIMAC\n   S M=QCMDE\n   S M=QCMDS\n   S M=QCOMMON\n C I=IN,O=OUT11,L=NO\n   S M=QCQQ\n   S M=QCQQX\n   S M=QDCB\n   S M=QDEBUG\n   S M=QDSTAB\n   S M=QGLOBALS\n   S M=QHASPEQU\n   S M=QITEM\n   S M=QLCB\n   S M=QNEWCMD\n   S M=QNEXT\n   S M=QPBRO\n   S M=QPENTRY\n   S M=QPTBL\n   S M=QREGS\n   S M=QSORT\n   S M=QSTACK\n   S M=QSTART\n   S M=QTILT\n   S M=QUEUE\n   S M=QUEUEASM\n   S M=QUEUELNK\n   S M=QZACCVT\n   S M=QZACDSV\n   S M=QZACFJCB\n   S M=QZACFNJB\n   S M=QZACVALD\n   S M=QZASCB\n   S M=QZASVT\n   S M=QZCPPL\n   S M=QZCSCB\n   S M=QZCVT\n   S M=QZDCBD\n   S M=QZIHAETD\n   S M=QZJSCB\n   S M=QZMCS\n   S M=QZOUCB\n   S M=QZPSA\n   S M=QZRAX\n   S M=QZSSCT\n   S M=QZSSIB\n   S M=QZSSOB\n   S M=QZTCB\n   S M=QZTEXT\n   S M=QZTSVT\n   S M=QZDEB\n   S M=QZJESCT\n   S M=QZKEYS\n   S M=QZPSCB\n   S M=QZUCB\n   S M=QZZB505\n   S M=SPFQUEUE\n   S M=SPFQUEUX\n C I=IN,O=OUT00\n   E M=$$$$CPYR\n   E M=$$$INDEX\n   E M=$$$INST\n   E M=$$$SPLIT\n   E M=$$ASM\n   E M=$$ASM#CT\n   E M=$$ASM#HT\n   E M=$$ASMALL\n   E M=$$ASMATH\n   E M=$$ASMCHK\n   E M=$$ASMDOC\n   E M=$$ASMISR\n   E M=$$ASMX\n   E M=$$IPOALL\n   E M=$$MAC\n   E M=$$NEWALL\n   E M=$$NEWASM\n   E M=$$NEWCHK\n   E M=$$NEWDOC\n   E M=$$NEWMAC\n   E M=$INCLUDE\n   E M=$INCLUDX\n   E M=$JQT\n   E M=$NULL\n   E M=$ORDER\n   E M=$UFDOC\n   E M=$UPDATES\n   E M=#MHELP\n   E M=C\n   E M=ISRQ\n   E M=OACFSORT\n   E M=OACFSRT\n   E M=Q$BUFFER\n   E M=Q$CHK\n   E M=Q$DAS\n   E M=Q$DCT\n   E M=Q$HASB\n   E M=Q$HCCT\n   E M=Q$HCT\n   E M=Q$HDP\n   E M=Q$HFAME\n   E M=Q$HQR\n   E M=Q$HQT\n   E M=Q$IOT\n   E M=Q$JCT\n   E M=Q$JOE\n   E M=Q$JOT\n   E M=Q$JQE\n   E M=Q$JQT\n   E M=Q$KAC\n   E M=Q$KIT\n   E M=Q$LCK\n   E M=Q$LMT\n   E M=Q$LRC\n   E M=Q$MIT\n   E M=Q$NHD\n   E M=Q$PADDR\n   E M=Q$PCE\n   E M=Q$PDDB\n   E M=Q$PIT\n   E M=Q$QSE\n   E M=Q$RDT\n   E M=Q$SJB\n   E M=Q$SVT\n   E M=Q$TAB\n   E M=Q$TGM\n   E M=Q$TQE\n   E M=Q$XECB\n   E M=Q##ALL\n   E M=Q##END\n   E M=Q##MXREF\n   E M=Q##TITLE\n   E M=Q#AF\n   E M=Q#AL\n   E M=Q#AT\n   E M=Q#BL\n   E M=Q#CB\n   E M=Q#CB#ACF\n   E M=Q#CB#HCT\n   E M=Q#CB#IOT\n   E M=Q#CB#JCT\n   E M=Q#CB#JOE\n   E M=Q#CB#JOT\n   E M=Q#CB#JQE\n   E M=Q#CB#PDB\n   E M=Q#CH\n   E M=Q#CK\n   E M=Q#CP\n   E M=Q#CT\n   E M=Q#DD\n   E M=Q#DL\n   E M=Q#DY\n   E M=Q#FJ\n   E M=Q#FM\n   E M=Q#FR\n   E M=Q#GR\n   E M=Q#GP\n   E M=Q#HB\n   E M=Q#HE\n   E M=Q#HT\n   E M=Q#II\n   E M=Q#IN\n   E M=Q#JI\n   E M=Q#JN\n   E M=Q#JS\n   E M=Q#KL\n   E M=Q#LD\n   E M=Q#LI\n   E M=Q#LT\n   E M=Q#MC\n   E M=Q#MO\n   E M=Q#OC\n   E M=Q#PA\n   E M=Q#PF\n   E M=Q#PR\n   E M=Q#QC\n   E M=Q#QD\n   E M=Q#QI\n   E M=Q#QQ\n   E M=Q#QS\n   E M=Q#RL\n   E M=Q#RP\n   E M=Q#RS\n   E M=Q#SF\n   E M=Q#SL\n   E M=Q#SO\n   E M=Q#SR\n   E M=Q#SV\n   E M=Q#SY\n   E M=Q#TC\n   E M=Q#TG\n   E M=QAPF\n   E M=QAUTH\n   E M=QCALL\n   E M=QCBFE\n   E M=QCBLKNUM\n   E M=QCEDIMAC\n   E M=QCMDE\n   E M=QCMDS\n   E M=QCOMMON\n   E M=QCQQ\n   E M=QCQQX\n   E M=QDCB\n   E M=QDEBUG\n   E M=QDSTAB\n   E M=QGLOBALS\n   E M=QHASPEQU\n   E M=QITEM\n   E M=QLCB\n   E M=QNEXT\n   E M=QNEWCMD\n   E M=QPBRO\n   E M=QPENTRY\n   E M=QPTBL\n   E M=QREGS\n   E M=QSORT\n   E M=QSTACK\n   E M=QSTART\n   E M=QTILT\n   E M=QUEUE\n   E M=QUEUEASM\n   E M=QUEUELNK\n   E M=QZACCVT\n   E M=QZACDSV\n   E M=QZACFJCB\n   E M=QZACFNJB\n   E M=QZACVALD\n   E M=QZASCB\n   E M=QZASVT\n   E M=QZCPPL\n   E M=QZCSCB\n   E M=QZCVT\n   E M=QZDCBD\n   E M=QZDEB\n   E M=QZIHAETD\n   E M=QZJSCB\n   E M=QZJESCT\n   E M=QZKEYS\n   E M=QZMCS\n   E M=QZOUCB\n   E M=QZRAX\n   E M=QZPSA\n   E M=QZPSCB\n   E M=QZSSCT\n   E M=QZSSIB\n   E M=QZSSOB\n   E M=QZTCB\n   E M=QZTEXT\n   E M=QZTSVT\n   E M=QZUCB\n   E M=QZZB505\n   E M=SPFQUEUE\n   E M=SPFQUEUX\n C I=MACLIB,O=OUTMAC,L=NO\n   S M=@GLOBALC\n   S M=@GLOBALS\n   S M=DROPX\n   S M=HEX\n   S M=INUSE\n   S M=LC\n   S M=MONTHS\n   S M=TMPMAC\n   S M=TPUTX\n   S M=USNGX\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$ASM": {"ttr": 776, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05H\\x00\\x00\\x00\\x82#/\\x00\\x91\\x00o\\x02!\\x00\\t\\x002\\x00\\x08\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "05.72", "flags": 0, "createdate": "1982-08-20T00:00:00", "modifydate": "1991-01-06T02:21:00", "lines": 9, "newlines": 50, "modlines": 8, "user": "LDW"}, "text": "//LDWQ#??  JOB (ZSY11,4L00),'LEONARD D. WOREN',MSGCLASS=H,NOTIFY=LDW,\n//            COND=(0,NE),CLASS=C\n/*JOBPARM L=100,F=SDB4\n/*PROCLIB LDW.Q.PROCLIB\n//*Z OUTPUT JESDS=ALL,DEFAULT=Y,GROUPID=LDW,UCS=GT15,FCB=S8,DEST=LASER3\n//* JCL DSN ==> SYS5.Q.ASM($$ASM) <==\n//*---\n//ASM      EXEC QUEUEASM,M=Q#??   ,SYSIN='LDW.EMSI.Q.ASM'\n//LINK     EXEC QUEUELNK\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$ASM#CT": {"ttr": 778, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x10\\x00\\x00\\x00\\x83\\x05O\\x00\\x91\\x07O\"I\\x00\\n\\x00+\\x00\\t\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.16", "flags": 0, "createdate": "1983-02-23T00:00:00", "modifydate": "1991-03-15T22:49:00", "lines": 10, "newlines": 43, "modlines": 9, "user": "LDW"}, "text": "//LDWQ#CT  JOB (ZSY11,4L00),'LEONARD D. WOREN',MSGCLASS=H,NOTIFY=LDW,\n//            COND=(0,NE),CLASS=C\n/*JOBPARM L=100,F=SDB4\n/*PROCLIB LDW.Q.PROCLIB\n//*Z OUTPUT JESDS=ALL,DEFAULT=Y,GROUPID=LDW,UCS=GT15,FCB=S8,DEST=LASER3\n//* JCL DSN ==> SYS5.Q.ASM($$ASM#CT) <==\n//*---\n//ASM      EXEC QUEUEASM,M=Q#CT,XREF=FULL\n//LINK     EXEC QUEUELNK,INCLUDE=NULL,ORDER=NULL,MOD=QCHGTXT,\n//             PL='OL,RMODE=ANY'\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$ASM#HT": {"ttr": 780, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0f\\x00\\x00\\x00\\x83\\x05O\\x00\\x91\\x07O\"P\\x00\\n\\x00+\\x00\\t\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.15", "flags": 0, "createdate": "1983-02-23T00:00:00", "modifydate": "1991-03-15T22:50:00", "lines": 10, "newlines": 43, "modlines": 9, "user": "LDW"}, "text": "//LDWQ#HT  JOB (ZSY11,4L00),'LEONARD D. WOREN',MSGCLASS=H,NOTIFY=LDW,\n//            COND=(0,NE),CLASS=C\n/*JOBPARM L=100,F=SDB4\n/*PROCLIB LDW.Q.PROCLIB\n//*Z OUTPUT JESDS=ALL,DEFAULT=Y,GROUPID=LDW,UCS=GT15,FCB=S8,DEST=LASER3\n//* JCL DSN ==> SYS5.Q.ASM($$ASM#HT) <==\n//*---\n//ASM      EXEC QUEUEASM,M=Q#HT,XREF=FULL\n//LINK     EXEC QUEUELNK,INCLUDE=NULL,ORDER=NULL,MOD=QHLPTXT,\n//             PL='OL,RMODE=ANY'\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$ASMALL": {"ttr": 782, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x052\\x00\\x00\\x00\\x82#/\\x00\\x91\\x17\\x9f#3\\x00\\t\\x00-\\x00\\t\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "05.50", "flags": 0, "createdate": "1982-08-20T00:00:00", "modifydate": "1991-06-28T23:33:00", "lines": 9, "newlines": 45, "modlines": 9, "user": "LDW"}, "text": "//LDWQ$313 JOB (ZSY11,4L00),'LEONARD D. WOREN',MSGCLASS=H,NOTIFY=LDW,\n//            COND=(0,NE),CLASS=D\n/*JOBPARM L=100,F=SDB4\n/*PROCLIB LDW.Q.PROCLIB\n//*Z OUTPUT JESDS=ALL,DEFAULT=Y,GROUPID=LDW,UCS=GT15,FCB=S8,DEST=LASER3\n//* JCL DSN ==> LDW.Q.ASM($$ASMALL) <==\n//*---\n//ASM      EXEC QUEUEASM,M=Q##ALL    ,SYSIN='LDW.EMSI.Q.ASM'\n//LINK     EXEC QUEUELNK,INCLUDE=NULL\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$ASMATH": {"ttr": 784, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x91\\x03\\x0f\\x00\\x91\\x07O\"Q\\x00\\t\\x00\\t\\x00\\x01\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1991-01-30T00:00:00", "modifydate": "1991-03-15T22:51:00", "lines": 9, "newlines": 9, "modlines": 1, "user": "LDW"}, "text": "//LDWQAUTH JOB (ZSY11,4L00),'LEONARD D. WOREN',MSGCLASS=H,NOTIFY=LDW,\n//            COND=(0,NE),CLASS=C\n/*JOBPARM L=100,F=SDB4\n/*PROCLIB LDW.Q.PROCLIB\n//*Z OUTPUT JESDS=ALL,DEFAULT=Y,GROUPID=LDW,UCS=GT15,FCB=S8,DEST=LASER3\n//* JCL DSN ==> SYS5.Q.ASM($$ASMATH) <==\n//*---\n//ASM      EXEC QUEUEASM,M=QAUTH  ,SYSIN='LDW.EMSI.Q.ASM'\n//LINK     EXEC QUEUELNK,ORDER=NULL,INCLUDE=NULL,MOD=QAUTH$,PL='AC=1'\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$ASMCHK": {"ttr": 786, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x10\\x00\\x00\\x00\\x83\\x00O\\x00\\x91\\x00o\\x02!\\x008\\x00H\\x007\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.16", "flags": 0, "createdate": "1983-01-04T00:00:00", "modifydate": "1991-01-06T02:21:00", "lines": 56, "newlines": 72, "modlines": 55, "user": "LDW"}, "text": "//LDW$Q### JOB (ZSY11,4L00),'LEONARD D. WOREN',MSGCLASS=H,NOTIFY=LDW,\n//*           RESTART=Q#??.ASM,\n//            MSGLEVEL=(2,0),\n//            COND=(0,NE),CLASS=D\n/*JOBPARM L=100,F=SDB4\n//*Z OUTPUT JESDS=ALL,DEFAULT=Y,GROUPID=LDW,UCS=GT15,FCB=S8,DEST=LASER3\n//* JCL DSN ==> LDW.Q.ASM($$ASMCHK) <==\n//*---\n//Q#AF     EXEC  QUEUEASM,OBJ=NO,M=Q#AF\n//Q#AL     EXEC  QUEUEASM,OBJ=NO,M=Q#AL\n//Q#AT     EXEC  QUEUEASM,OBJ=NO,M=Q#AT\n//Q#BL     EXEC  QUEUEASM,OBJ=NO,M=Q#BL\n//Q#CH     EXEC  QUEUEASM,OBJ=NO,M=Q#CH\n//Q#CK     EXEC  QUEUEASM,OBJ=NO,M=Q#CK\n//Q#CP     EXEC  QUEUEASM,OBJ=NO,M=Q#CP\n//Q#CT     EXEC  QUEUEASM,OBJ=NO,M=Q#CT\n//Q#DD     EXEC  QUEUEASM,OBJ=NO,M=Q#DD\n//Q#DY     EXEC  QUEUEASM,OBJ=NO,M=Q#DY\n//Q#FJ     EXEC  QUEUEASM,OBJ=NO,M=Q#FJ\n//Q#FM     EXEC  QUEUEASM,OBJ=NO,M=Q#FM\n//Q#FR     EXEC  QUEUEASM,OBJ=NO,M=Q#FR\n//Q#GP     EXEC  QUEUEASM,OBJ=NO,M=Q#GP\n//Q#GR     EXEC  QUEUEASM,OBJ=NO,M=Q#GR\n//Q#HB     EXEC  QUEUEASM,OBJ=NO,M=Q#HB\n//Q#HE     EXEC  QUEUEASM,OBJ=NO,M=Q#HE\n//Q#HT     EXEC  QUEUEASM,OBJ=NO,M=Q#HT\n//Q#II     EXEC  QUEUEASM,OBJ=NO,M=Q#II\n//Q#IN     EXEC  QUEUEASM,OBJ=NO,M=Q#IN\n//Q#JI     EXEC  QUEUEASM,OBJ=NO,M=Q#JI\n//Q#JN     EXEC  QUEUEASM,OBJ=NO,M=Q#JN\n//Q#JS     EXEC  QUEUEASM,OBJ=NO,M=Q#JS\n//Q#LD     EXEC  QUEUEASM,OBJ=NO,M=Q#LD\n//Q#LI     EXEC  QUEUEASM,OBJ=NO,M=Q#LI\n//Q#LT     EXEC  QUEUEASM,OBJ=NO,M=Q#LT\n//Q#MC     EXEC  QUEUEASM,OBJ=NO,M=Q#MC\n//Q#MO     EXEC  QUEUEASM,OBJ=NO,M=Q#MO\n//Q#OC     EXEC  QUEUEASM,OBJ=NO,M=Q#OC\n//Q#PA     EXEC  QUEUEASM,OBJ=NO,M=Q#PA\n//Q#PF     EXEC  QUEUEASM,OBJ=NO,M=Q#PF\n//Q#PR     EXEC  QUEUEASM,OBJ=NO,M=Q#PR\n//Q#QC     EXEC  QUEUEASM,OBJ=NO,M=Q#QC\n//Q#QD     EXEC  QUEUEASM,OBJ=NO,M=Q#QD\n//Q#QI     EXEC  QUEUEASM,OBJ=NO,M=Q#QI\n//Q#QS     EXEC  QUEUEASM,OBJ=NO,M=Q#QS\n//Q#QQ     EXEC  QUEUEASM,OBJ=NO,M=Q#QQ\n//Q#RL     EXEC  QUEUEASM,OBJ=NO,M=Q#RL\n//Q#RP     EXEC  QUEUEASM,OBJ=NO,M=Q#RP\n//Q#RS     EXEC  QUEUEASM,OBJ=NO,M=Q#RS\n//Q#SF     EXEC  QUEUEASM,OBJ=NO,M=Q#SF\n//Q#SL     EXEC  QUEUEASM,OBJ=NO,M=Q#SL\n//Q#SO     EXEC  QUEUEASM,OBJ=NO,M=Q#SO\n//Q#SR     EXEC  QUEUEASM,OBJ=NO,M=Q#SR\n//Q#SV     EXEC  QUEUEASM,OBJ=NO,M=Q#SV\n//Q#SY     EXEC  QUEUEASM,OBJ=NO,M=Q#SY\n//Q#TC     EXEC  QUEUEASM,OBJ=NO,M=Q#TC\n//Q#TG     EXEC  QUEUEASM,OBJ=NO,M=Q#TG\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$ASMDOC": {"ttr": 788, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x84!_\\x00\\x91\\x00o\\x02!\\x00\\x08\\x00\\x07\\x00\\x07\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1984-08-02T00:00:00", "modifydate": "1991-01-06T02:21:00", "lines": 8, "newlines": 7, "modlines": 7, "user": "LDW"}, "text": "//LDWQ$DOC JOB (ZSY11,4L00),'LEONARD D. WOREN',MSGCLASS=H,NOTIFY=LDW,\n//            COND=(0,NE),CLASS=C\n/*JOBPARM L=100,F=SDB4\n/*PROCLIB LDW.Q.PROCLIB\n//*Z OUTPUT JESDS=ALL,DEFAULT=Y,GROUPID=LDW,UCS=GT15,FCB=S8,DEST=LASER3\n//* JCL DSN ==> LDW.Q.ASM($$ASMDOC) <==\n//*---\n//ASM      EXEC QUEUEASM,M=Q#QD,OBJ=NO,SYSPARM='DOC=GEN'\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$ASMISR": {"ttr": 790, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x91\\x03/\\x00\\x91\\x03/\\x18\\x14\\x00\\x08\\x00\\x08\\x00\\x00\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-02-01T00:00:00", "modifydate": "1991-02-01T18:14:00", "lines": 8, "newlines": 8, "modlines": 0, "user": "LDW"}, "text": "//LDWQISRQ  JOB (ZSY11,4L00),'LEONARD D. WOREN',NOTIFY=LDW,\n//           MSGCLASS=H,CLASS=D\n/*JOBPARM L=100,F=SDB4\n/*PROCLIB LDW.Q.PROCLIB\n//* JCL DSN ==> LDW.Q.($$ASMISR) <==\n//*---\n//ASM      EXEC QUEUEASM,M=ISRQ\n//LINK     EXEC QUEUELNK,ORDER=NULL,INCLUDE=NULL,MOD=ISRQ$\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$ASMO": {"ttr": 792, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x91\\x16\\x0f\\x00\\x91\\x16\\x0f\\x01\\x04\\x00\\n\\x00\\n\\x00\\x00\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-06-09T00:00:00", "modifydate": "1991-06-09T01:04:00", "lines": 10, "newlines": 10, "modlines": 0, "user": "LDW"}, "text": "//LDWQ$311 JOB (ZSY11,4L00),'LEONARD D. WOREN',MSGCLASS=H,NOTIFY=LDW,\n//            COND=(0,NE),CLASS=D\n/*JOBPARM L=100,F=SDB4\n/*PROCLIB LDW.Q.PROCLIB\n//*Z OUTPUT JESDS=ALL,DEFAULT=Y,GROUPID=LDW,UCS=GT15,FCB=S8,DEST=LASER3\n//* JCL DSN ==> SYS5.Q.ASM($$ASMO) <==\n//*---\n//ASM      EXEC QUEUEASM,M=Q##ALL,   ,SYSIN='LDW.EMSI.Q.ASM'\n//             RES=MVSAR1,DLIB=MVSAR1,JES2REL=311,ACFX=ACF510\n//LINK     EXEC QUEUELNK,INCLUDE=NULL\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$ASMO1": {"ttr": 1026, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x91\\x15\\x9f\\x00\\x91\\x16_\\x17\\x00\\x00\\n\\x00\\n\\x00\\x00\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-06-08T00:00:00", "modifydate": "1991-06-14T17:00:00", "lines": 10, "newlines": 10, "modlines": 0, "user": "LDW"}, "text": "//LDWQ#??  JOB (ZSY11,4L00),'LEONARD D. WOREN',MSGCLASS=H,NOTIFY=LDW,\n//            COND=(0,NE),CLASS=C\n/*JOBPARM L=100,F=SDB4\n/*PROCLIB LDW.Q.PROCLIB\n//*Z OUTPUT JESDS=ALL,DEFAULT=Y,GROUPID=LDW,UCS=GT15,FCB=S8,DEST=LASER3\n//* JCL DSN ==> SYS5.Q.ASM($$ASMOLD) <==\n//*---\n//ASM      EXEC QUEUEASM,M=Q#??,  ,SYSIN='LDW.EMSI.Q.ASM'\n//             RES=MVSAR1,DLIB=MVSAR1,JES2REL=311,ACFX=ACF510\n//LINK     EXEC QUEUELNK\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$ASMX": {"ttr": 1028, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x843/\\x00\\x86\\x05/\\x15 \\x00\\x0e\\x00\\x0c\\x00\\x04\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1984-11-27T00:00:00", "modifydate": "1986-02-21T15:20:00", "lines": 14, "newlines": 12, "modlines": 4, "user": "LDW"}, "text": "//LDW$Q#FJ JOB (1,SYS,AF0555,00,42,A9---),'WOREN, LEONARD      ',\n//            COND=(0,NE),\n//            NOTIFY=@@@@@@@,MSGCLASS=Y,CLASS=E\n/*JOBPARM K=0\n//ZZ OUTPUT JESDS=ALL,DEFAULT=Y,GROUPID=LDW,UCS=GT15,FCB=S8,DEST=LASER3\n//* JCL DSN ==> SYS5.Q.ASM($$ASM) <==\n//*---\n//ASM      EXEC QUEUEASM,M=Q#FJ\n//SYSIN     DD  DISP=SHR,DSN=SYS5.Q.ASM(#MHELP)\n//          DD  DISP=SHR,DSN=SYS5.Q.ASM(QSTART)\n//          DD  DISP=SHR,DSN=SYS5.Q.ASM(Q##TITLE)\n//          DD  DISP=SHR,DSN=SYS5.Q.ASM(&M)\n//          DD  DISP=SHR,DSN=SYS5.Q.ASM(Q##END)\n//LINK     EXEC QUEUELNK\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$IPOALL": {"ttr": 1030, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x85\\x02\\x1f\\x00\\x86\\x05/\\x15!\\x00\\x11\\x00\\x10\\x00\\x02\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1985-01-21T00:00:00", "modifydate": "1986-02-21T15:21:00", "lines": 17, "newlines": 16, "modlines": 2, "user": "LDW"}, "text": "//LDWQ$IPO JOB (1,SYS,AF0555,00,42,A9---),'WOREN, LEONARD      ',\n//            COND=(0,NE),\n//            NOTIFY=@@@@@@@,MSGCLASS=Y,CLASS=A\n/*JOBPARM K=0\n//ZZ OUTPUT JESDS=ALL,DEFAULT=Y,GROUPID=LDW,UCS=GT15,FCB=S8,DEST=LASER3\n//* JCL DSN ==> SYS5.Q.ASM($$IPOALL) <==\n//*---\n//ASM      EXEC QUEUEASM,M=Q##ALL,RES=MVSRS1,\n//             SYSPARM='QLEVEL=6,NOACF2,JQEOWN='  ,TEST=TEST\n//SYSLIB    DD\n//          DD  DISP=SHR,DSN=SYS1.SMPMTS\n//          DD\n//          DD\n//          DD\n//          DD\n//          DD  DISP=SHR,DSN=SYS3.MACLIB,UNIT=,VOL=SER=\n//LINK     EXEC QUEUELNK,INCLUDE=NULL,MOD=QX$  ,TEST=TEST\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$MAC": {"ttr": 1032, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x90&\\x9f\\x00\\x91\\x07O\"U\\x00 \\x00 \\x00\\x01\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1990-09-26T00:00:00", "modifydate": "1991-03-15T22:55:00", "lines": 32, "newlines": 32, "modlines": 1, "user": "LDW"}, "text": "//LDWQ#MAC JOB (ZSY11,4L00),'LEONARD D. WOREN',MSGCLASS=T,NOTIFY=LDW,\n//            COND=(0,NE),CLASS=D\n/*JOBPARM L=100,F=SDB4\n/*PROCLIB LDW.Q.PROCLIB\n//*Z OUTPUT JESDS=ALL,DEFAULT=Y,GROUPID=LDW,UCS=GT15,FCB=S8,DEST=LASER3\n//* JCL DSN ==> SYS5.Q.ASM($$ASM) <==\n//*---\n//ASM      EXEC QUEUEASM,M=Q##ALL\n//*            RES=NEW893  ,TEST=TEST\n//SYSIN     DD  DISP=SHR,DSN=LDW.Q.ASM(Q##MXREF)\n//*YSPRINT  DD  DISP=(NEW,PASS),DSN=&&LISTING,\n//*            UNIT=SYSDA,SPACE=(CYL,(5,2),RLSE),\n//SYSPRINT  DD  DISP=(NEW,CATLG),DSN=LDW.QUEUE.LISTING,\n//             UNIT=SYSDA,SPACE=(CYL,(8,2),RLSE),\n//             DCB=(RECFM=FBM,LRECL=121,BLKSIZE=6171)\n//*---\n//SORT     EXEC PGM=SORT,PARM='CORE=MAX'\n//* SYNCSORT MUST BE USED HERE...\n//SYSOUT    DD  SYSOUT=*\n//SORTIN    DD  DISP=SHR,DSN=LDW.QUEUE.LISTING\n//SORTOUT   DD  SYSOUT=*,\n//             DCB=(RECFM=FB,LRECL=8,BLKSIZE=6160)\n//*ORTWK01  DD  UNIT=SORT,SPACE=(CYL,(20),,,ROUND)\n//*ORTWK02  DD  UNIT=SORT,SPACE=(CYL,(20),,,ROUND)\n//*ORTWK03  DD  UNIT=SORT,SPACE=(CYL,(20),,,ROUND)\n//SYSIN     DD  *\n* SORT FIELDS=COPY\n  SORT FIELDS=(66,8,CH,A),DYNALLOC=(SYSDA,3)\n  INCLUDE COND=(42,24,CH,EQ,C'++//MHELP CALL TO MACRO')\n  OUTREC FIELDS=(66,8)\n  SUM    FIELDS=NONE\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$NEWALL": {"ttr": 1034, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0f\\x00\\x00\\x00\\x84!\\x9f\\x00\\x91\\x07O\"V\\x00\\x14\\x00\\x08\\x00\\x14\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.15", "flags": 0, "createdate": "1984-08-06T00:00:00", "modifydate": "1991-03-15T22:56:00", "lines": 20, "newlines": 8, "modlines": 20, "user": "LDW"}, "text": "//LDWQ$313 JOB (ZSY11,4L00),'LEONARD D. WOREN',MSGCLASS=H,NOTIFY=LDW,\n//            COND=(0,NE),CLASS=D\n/*JOBPARM L=100,F=SDB4\n/*PROCLIB LDW.Q.PROCLIB\n//*Z OUTPUT JESDS=ALL,DEFAULT=Y,GROUPID=LDW,UCS=GT15,FCB=S8,DEST=LASER3\n//* JCL DSN ==> LDW.Q.ASM($$NEWALL) <==\n//*---\n//*SM      EXEC QUEUEASM,M=Q##ALL,\n//ASM      EXEC QUEUEASM,M=Q##ALL,\n//             RES=MVSXR1,DLIB=MVSXR1   ,TEST=TEST\n//SYSLIB    DD\n//          DD\n//          DD\n//          DD\n//          DD\n//          DD\n//          DD\n//          DD\n//          DD  UNIT=,VOL=SER=          *ACFMAC*\n//LINK     EXEC QUEUELNK,INCLUDE=NULL,MOD=QX$  ,TEST=TEST\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$NEWASM": {"ttr": 1036, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\r\\x00\\x00\\x00\\x84!\\x9f\\x00\\x91\\x17\\x8f \\x00\\x00\\x13\\x00\\x08\\x00\\x12\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.13", "flags": 0, "createdate": "1984-08-06T00:00:00", "modifydate": "1991-06-27T20:00:00", "lines": 19, "newlines": 8, "modlines": 18, "user": "LDW"}, "text": "//LDWQ$??  JOB (ZSY11,4L00),'LEONARD D. WOREN',MSGCLASS=H,NOTIFY=LDW,\n//            COND=(0,NE),CLASS=C\n/*PROCLIB LDW.Q.PROCLIB\n/*JOBPARM L=100,F=SDB4\n//*Z OUTPUT JESDS=ALL,DEFAULT=Y,GROUPID=LDW,UCS=GT15,FCB=S8,DEST=LASER3\n//* JCL DSN ==> LDW.Q.ASM($$NEWALL) <==\n//*---\n//ASM      EXEC QUEUEASM,M=Q#??,\n//             RES=MVSXR1,DLIB=MVSXR1  ,TEST=TEST\n//SYSLIB    DD\n//          DD\n//          DD\n//          DD\n//          DD\n//          DD\n//          DD\n//          DD\n//          DD  UNIT=,VOL=SER=          *ACFMAC*\n//LINK     EXEC QUEUELNK,INCLUDE=INCLUDX,MOD=QX$\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$NEWCHK": {"ttr": 1038, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x87\\x01\\x7f\\x00\\x91\\x07O\"W\\x00h\\x006\\x00b\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1987-01-17T00:00:00", "modifydate": "1991-03-15T22:57:00", "lines": 104, "newlines": 54, "modlines": 98, "user": "LDW"}, "text": "//LDWQ$##  JOB (ZSY11,4L00),'LEONARD D. WOREN',MSGCLASS=H,NOTIFY=LDW,\n//*           RESTART=Q#??.ASM,\n//            MSGLEVEL=(2,0),\n//            COND=(0,NE),CLASS=D\n/*JOBPARM L=100,F=SDB4\n//*Z OUTPUT JESDS=ALL,DEFAULT=Y,GROUPID=LDW,UCS=GT15,FCB=S8,DEST=LASER3\n//* JCL DSN ==> LDW.Q.ASM($$NEWCHK) <==\n//*---\n//Q#AF     EXEC  QUEUEASM,OBJ=NO,M=Q#AF,\n//             RES=MVSXR1,DLIB=MVS220\n//Q#AL     EXEC  QUEUEASM,OBJ=NO,M=Q#AL,\n//             RES=MVSXR1,DLIB=MVS220\n//Q#AT     EXEC  QUEUEASM,OBJ=NO,M=Q#AT,\n//             RES=MVSXR1,DLIB=MVS220\n//Q#BL     EXEC  QUEUEASM,OBJ=NO,M=Q#BL,\n//             RES=MVSXR1,DLIB=MVS220\n//Q#CH     EXEC  QUEUEASM,OBJ=NO,M=Q#CH,\n//             RES=MVSXR1,DLIB=MVS220\n//Q#CK     EXEC  QUEUEASM,OBJ=NO,M=Q#CK,\n//             RES=MVSXR1,DLIB=MVS220\n//Q#CP     EXEC  QUEUEASM,OBJ=NO,M=Q#CP,\n//             RES=MVSXR1,DLIB=MVS220\n//Q#CT     EXEC  QUEUEASM,OBJ=NO,M=Q#CT,\n//             RES=MVSXR1,DLIB=MVS220\n//Q#DD     EXEC  QUEUEASM,OBJ=NO,M=Q#DD,\n//             RES=MVSXR1,DLIB=MVS220\n//Q#DY     EXEC  QUEUEASM,OBJ=NO,M=Q#DY,\n//             RES=MVSXR1,DLIB=MVS220\n//Q#FJ     EXEC  QUEUEASM,OBJ=NO,M=Q#FJ,\n//             RES=MVSXR1,DLIB=MVS220\n//Q#FM     EXEC  QUEUEASM,OBJ=NO,M=Q#FM,\n//             RES=MVSXR1,DLIB=MVS220\n//Q#FR     EXEC  QUEUEASM,OBJ=NO,M=Q#FR,\n//             RES=MVSXR1,DLIB=MVS220\n//Q#GP     EXEC  QUEUEASM,OBJ=NO,M=Q#GP,\n//             RES=MVSXR1,DLIB=MVS220\n//Q#GR     EXEC  QUEUEASM,OBJ=NO,M=Q#GR,\n//             RES=MVSXR1,DLIB=MVS220\n//Q#HB     EXEC  QUEUEASM,OBJ=NO,M=Q#HB,\n//             RES=MVSXR1,DLIB=MVS220\n//Q#HE     EXEC  QUEUEASM,OBJ=NO,M=Q#HE,\n//             RES=MVSXR1,DLIB=MVS220\n//Q#HT     EXEC  QUEUEASM,OBJ=NO,M=Q#HT,\n//             RES=MVSXR1,DLIB=MVS220\n//Q#II     EXEC  QUEUEASM,OBJ=NO,M=Q#II,\n//             RES=MVSXR1,DLIB=MVS220\n//Q#IN     EXEC  QUEUEASM,OBJ=NO,M=Q#IN,\n//             RES=MVSXR1,DLIB=MVS220\n//Q#JI     EXEC  QUEUEASM,OBJ=NO,M=Q#JI,\n//             RES=MVSXR1,DLIB=MVS220\n//Q#JN     EXEC  QUEUEASM,OBJ=NO,M=Q#JN,\n//             RES=MVSXR1,DLIB=MVS220\n//Q#JS     EXEC  QUEUEASM,OBJ=NO,M=Q#JS,\n//             RES=MVSXR1,DLIB=MVS220\n//Q#LD     EXEC  QUEUEASM,OBJ=NO,M=Q#LD,\n//             RES=MVSXR1,DLIB=MVS220\n//Q#LI     EXEC  QUEUEASM,OBJ=NO,M=Q#LI,\n//             RES=MVSXR1,DLIB=MVS220\n//Q#LT     EXEC  QUEUEASM,OBJ=NO,M=Q#LT,\n//             RES=MVSXR1,DLIB=MVS220\n//Q#MC     EXEC  QUEUEASM,OBJ=NO,M=Q#MC,\n//             RES=MVSXR1,DLIB=MVS220\n//Q#MO     EXEC  QUEUEASM,OBJ=NO,M=Q#MO,\n//             RES=MVSXR1,DLIB=MVS220\n//Q#OC     EXEC  QUEUEASM,OBJ=NO,M=Q#OC,\n//             RES=MVSXR1,DLIB=MVS220\n//Q#PA     EXEC  QUEUEASM,OBJ=NO,M=Q#PA,\n//             RES=MVSXR1,DLIB=MVS220\n//Q#PF     EXEC  QUEUEASM,OBJ=NO,M=Q#PF,\n//             RES=MVSXR1,DLIB=MVS220\n//Q#PR     EXEC  QUEUEASM,OBJ=NO,M=Q#PR,\n//             RES=MVSXR1,DLIB=MVS220\n//Q#QC     EXEC  QUEUEASM,OBJ=NO,M=Q#QC,\n//             RES=MVSXR1,DLIB=MVS220\n//Q#QD     EXEC  QUEUEASM,OBJ=NO,M=Q#QD,\n//             RES=MVSXR1,DLIB=MVS220\n//Q#QI     EXEC  QUEUEASM,OBJ=NO,M=Q#QI,\n//             RES=MVSXR1,DLIB=MVS220\n//Q#QS     EXEC  QUEUEASM,OBJ=NO,M=Q#QS,\n//             RES=MVSXR1,DLIB=MVS220\n//Q#QQ     EXEC  QUEUEASM,OBJ=NO,M=Q#QQ,\n//             RES=MVSXR1,DLIB=MVS220\n//Q#RL     EXEC  QUEUEASM,OBJ=NO,M=Q#RL,\n//             RES=MVSXR1,DLIB=MVS220\n//Q#RP     EXEC  QUEUEASM,OBJ=NO,M=Q#RP,\n//             RES=MVSXR1,DLIB=MVS220\n//Q#RS     EXEC  QUEUEASM,OBJ=NO,M=Q#RS,\n//             RES=MVSXR1,DLIB=MVS220\n//Q#SF     EXEC  QUEUEASM,OBJ=NO,M=Q#SF,\n//             RES=MVSXR1,DLIB=MVS220\n//Q#SL     EXEC  QUEUEASM,OBJ=NO,M=Q#SL,\n//             RES=MVSXR1,DLIB=MVS220\n//Q#SO     EXEC  QUEUEASM,OBJ=NO,M=Q#SO,\n//             RES=MVSXR1,DLIB=MVS220\n//Q#SR     EXEC  QUEUEASM,OBJ=NO,M=Q#SR,\n//             RES=MVSXR1,DLIB=MVS220\n//Q#SV     EXEC  QUEUEASM,OBJ=NO,M=Q#SV,\n//             RES=MVSXR1,DLIB=MVS220\n//Q#SY     EXEC  QUEUEASM,OBJ=NO,M=Q#SY,\n//             RES=MVSXR1,DLIB=MVS220\n//Q#TC     EXEC  QUEUEASM,OBJ=NO,M=Q#TC,\n//             RES=MVSXR1,DLIB=MVS220\n//Q#TG     EXEC  QUEUEASM,OBJ=NO,M=Q#TG,\n//             RES=MVSXR1,DLIB=MVS220\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$NEWDOC": {"ttr": 1041, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x00\\x00\\x00\\x84!\\x9f\\x00\\x91\\x17\\x8f#Q\\x00\\x12\\x00\\x07\\x00\\x11\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "1984-08-06T00:00:00", "modifydate": "1991-06-27T23:51:00", "lines": 18, "newlines": 7, "modlines": 17, "user": "LDW"}, "text": "//LDWQD410 JOB (ZSY11,4L00),'LEONARD D. WOREN',MSGCLASS=H,NOTIFY=LDW,\n//            COND=(0,NE),CLASS=C\n/*JOBPARM L=100,F=SDB4\n/*PROCLIB LDW.Q.PROCLIB\n//*Z OUTPUT JESDS=ALL,DEFAULT=Y,GROUPID=LDW,UCS=GT15,FCB=S8,DEST=LASER3\n//* JCL DSN ==> LDW.Q.ASM($$NEWDOC) <==\n//*---\n//ASM      EXEC QUEUEASM,M=Q#QD,OBJ=NO,\n//             RES=MVSXR1,DLIB=MVSXR1,SYSPARM='DOC=GEN'\n//SYSLIB    DD\n//          DD\n//          DD\n//          DD\n//          DD\n//          DD\n//          DD\n//          DD\n//          DD  UNIT=,VOL=SER=          *ACFMAC*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$NEWMAC": {"ttr": 1043, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x84\"\\x0f\\x00\\x864\\x8f\\x19W\\x00\"\\x00\\x1c\\x00\\x12\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1984-08-07T00:00:00", "modifydate": "1986-12-14T19:57:00", "lines": 34, "newlines": 28, "modlines": 18, "user": "LDW"}, "text": "//LDWQ@136 JOB (1,SYS,AF0555,00,42,A9---),'WOREN, LEONARD      ',\n//            COND=(0,NE),\n//            RESTART=SORT,\n//            NOTIFY=@@@@@@@,MSGCLASS=Y,CLASS=A\n/*JOBPARM K=0\n//ZZ OUTPUT JESDS=ALL,DEFAULT=Y,GROUPID=LDW,UCS=GT15,FCB=S8,DEST=LASER3\n//* JCL DSN ==> SYS5.Q.ASM($$136MAC) <==\n//*---\n//ASM      EXEC QUEUEASM,M=Q##ALL,\n//             RES=NEW893,SYSPARM='QLEVEL=7'  ,TEST=TEST\n//SYSIN     DD  DISP=SHR,DSN=SYS5.Q.ASM(Q##MXREF)\n//*YSPRINT  DD  DISP=(NEW,PASS),DSN=&&LISTING,\n//*            UNIT=SYSDA,SPACE=(CYL,(5,2),RLSE),\n//SYSPRINT  DD  DISP=(NEW,CATLG),DSN=LDW.QUEUE.LISTING,\n//             UNIT=SYSDA,SPACE=(CYL,(5,2),RLSE),\n//             DCB=(RECFM=FBM,LRECL=121,BLKSIZE=6171)\n//STEPLIB   DD  DISP=SHR,DSN=SYS2.ASMHV2.LINKLIB\n//*---\n//SORT     EXEC PGM=SORT,PARM='CORE=MAX'\n//* SYNCSORT MUST BE USED HERE...\n//SYSOUT    DD  SYSOUT=*,FCB=S8,UCS=GT15\n//SORTIN    DD  DISP=SHR,DSN=LDW.QUEUE.LISTING\n//SORTOUT   DD  SYSOUT=*,FCB=S8,UCS=GT15,\n//             DCB=(RECFM=FB,LRECL=8,BLKSIZE=6160)\n//*ORTWK01  DD  UNIT=SORT,SPACE=(CYL,(20),,,ROUND)\n//*ORTWK02  DD  UNIT=SORT,SPACE=(CYL,(20),,,ROUND)\n//*ORTWK03  DD  UNIT=SORT,SPACE=(CYL,(20),,,ROUND)\n//SYSIN     DD  *\n* SORT FIELDS=COPY\n  SORT FIELDS=(67,8,CH,A),DYNALLOC=(SORT,3)\n  INCLUDE COND=(42,25,CH,EQ,C'++//MHELP. CALL TO MACRO')\n  OUTREC FIELDS=(67,8)\n  SUM    FIELDS=NONE\n/*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$DBGFLGS": {"ttr": 1045, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x91\\x19_\\x00\\x91\\x19_\"#\\x00\\x02\\x00\\x02\\x00\\x00\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-07-14T00:00:00", "modifydate": "1991-07-14T22:23:00", "lines": 2, "newlines": 2, "modlines": 0, "user": "LDW"}, "text": "QDEBUG48 - QCOMMON call/return/tilt trace\nQDEBUG47 - CKPT logic\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$INCLUDE": {"ttr": 1047, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x84!_\\x00\\x84!_\\x17Y\\x00\\x03\\x00\\x03\\x00\\x00\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1984-08-02T00:00:00", "modifydate": "1984-08-02T17:59:00", "lines": 3, "newlines": 3, "modlines": 0, "user": "LDW"}, "text": "  INCLUDE  OLDLMOD(Q$)                  MAY CAUSE AN ERROR MESSAGE\n  INCLUDE  OLDLMOD(QUEUE)               DO NOT USE THESE 2 INCLUDES    X\n                                        WHEN ASSEMBLING ALL ROUTINES\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$INCLUDX": {"ttr": 1049, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x84!_\\x00\\x84!\\x9f A\\x00\\x03\\x00\\x03\\x00\\x02\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1984-08-02T00:00:00", "modifydate": "1984-08-06T20:41:00", "lines": 3, "newlines": 3, "modlines": 2, "user": "LDW"}, "text": "  INCLUDE  OLDLMOD(QX$)                 MAY CAUSE AN ERROR MESSAGE\n  INCLUDE  OLDLMOD(QX)                  DO NOT USE THESE 2 INCLUDES    X\n                                        WHEN ASSEMBLING ALL ROUTINES\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$JQT": {"ttr": 1051, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x0b\\x00\\x00\\x00\\x82#/\\x00\\x91\\x08_\\x15F\\x000\\x00\\x14\\x00+\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "05.11", "flags": 0, "createdate": "1982-08-20T00:00:00", "modifydate": "1991-03-26T15:46:00", "lines": 48, "newlines": 20, "modlines": 43, "user": "LDW"}, "text": "         MACRO -- JQT -- PHONY DSECT TO DESCRIBE FIRST CKPT REC\n         $JQT\n.*--------------------------------------------------------------------*\n.*                                                                    *\n.*  $JQT - Describe first CKPT rec                                    *\n.*                                                                    *\n.*  Updates:                                                          *\n.*     26Mar91  LDW  Add macro comments describing where to get info  *\n.*                      when updating for a new release of JES2       *\n.*     21Sep90  GLA  Add labels for RECEIVE and XMIT queues           *\n.*     12Jan87  LDW  SP1.3.6 changes                                  *\n.*     01/25/83 LDW  PUT IN SP1.3 SUPPORT                             *\n.*                                                                    *\n.*  This macro maps $JQHEADS in $HCT.  See HASPFMT2 for field order   *\n.*  (look for $QINDEX.)                                               *\n.*                                                                    *\n.*--------------------------------------------------------------------*\n         SPACE 3\n         GBLA  &QLEVEL\n         LCLC  &DS\nJQT      DSECT\nJQTDSECT EQU   JQT                      * TEMP *\n&DS      SETC  'H'                      ASSUME NON-SP\n         AIF   (&QLEVEL LT 4).LEVOK\n&DS      SETC  'F'                      SP\n.LEVOK   DS    &DS                      $PURGE\nJQTOUT   DS    &DS                      $HARDCPY - HDR FOR OUTPUT JQES\n         DS    &DS    JQTAWOUT          $OUTPUT\n         AIF   (&QLEVEL LT 4).NODUMPQ\n         AIF   (&QLEVEL GT 6).NODUMPQ\n         DS    &DS                      $DUMPQ\n.NODUMPQ ANOP\nJQTRECV  DS    &DS                      $RECEIVE\n         DS    &DS    JQTSETUP          $SETUP\nJQTXMIT  DS    &DS                      $XMIT\n         DS    &DS                      $INPUT - READING\nJQTCONV  DS    &DS    JQTXEQ            $XEQ - HDR FOR CONVERTER JQES\n         AIF   (&QLEVEL GE 4).NODUMMY\n         DS    &DS                      $DUMMY\n.NODUMMY ANOP\nJQTSTC   DS    &DS                      STC\nJQTTSU   DS    &DS                      TSU - HEADER FOR TSO USER JQES\nJQTCLSA  DS    &DS                      HEADER FOR CLASS A JQES\n         DS    35&DS                    B-Z, 0-9\nJQTQMAX  EQU   (*-JQT)/4                MAXIMUM NUMBER OF QUEUES\n         SPACE 1\n&SYSECT  CSECT\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$NULL": {"ttr": 1053, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x84!_\\x00\\x84!_\\x18\\x06\\x00\\x00\\x00\\x00\\x00\\x00\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1984-08-02T00:00:00", "modifydate": "1984-08-02T18:06:00", "lines": 0, "newlines": 0, "modlines": 0, "user": "LDW"}, "mimetype": "application/x-empty", "datatype": "binary", "extension": ".x-empty"}, "$ORDER": {"ttr": 1054, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0b\\x00\\x00\\x00\\x83\\x05_\\x00\\x903o\\x14S\\x00\\t\\x00\\x07\\x00\\x08\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.11", "flags": 0, "createdate": "1983-02-24T00:00:00", "modifydate": "1990-12-02T14:53:00", "lines": 9, "newlines": 7, "modlines": 8, "user": "LDW"}, "text": "  ORDER  QUEUE,AUTHFUNC,CKPT,DISPLAY,FINDJOB,PARSE,READSPC,GETREC\n  ORDER  DDNAME,LIST,LISTDS,REPOS,JOBSUMM,QSUBS,GETPDDB\n  ORDER  JESNEWS,MCS,SYSLOG,OPERCMD,INITS,TGPS\n  ORDER  SEARCH,FORMAT,FINDRJE,CPU,SYSOUT,SAVEDS,PRINT,SPFFUNC,JOBINFO\n  ORDER  MODE,QINNARDS,PFKSET,RMTLIST,SYSLIST,TSOCMD,BLKLIST,LISTTEXT\n  ORDER  LISTDAS,LISTKIT\n  ORDER  ATTR,HEXBLK,CBFMT,HELP,ALLOCATE,CHANGES,INITIAL,QCOMMON\n  ENTRY  QUEUE\n  SETCODE  AC(1)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$UFDOC": {"ttr": 1056, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x01\\x00\\x00\\x00\\x82#/\\x00\\x83\\x00?\\x121\\x00z\\x00o\\x00\\x0b\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "05.01", "flags": 0, "createdate": "1982-08-20T00:00:00", "modifydate": "1983-01-03T12:31:00", "lines": 122, "newlines": 111, "modlines": 11, "user": "LDW"}, "text": "*---------------------------------------------------------------------*\n*                                                                     *\n*  FOLLOWING IS A COPY OF THE UNIVERSITY OF FLORIDA UPDATES MEMBER    *\n*                                                                     *\n*  IT IS INCLUDED BECAUSE MANY OF THE CHANGES I (LDW) MADE WERE       *\n*  EITHER COPIED FROM OR INSPIRED BY CHANGES MADE BY JACK SCHUDEL     *\n*                                                                     *\n*  ****  CONTACT ME, NOT HIM, ABOUT THIS LEVEL OF THE SOURCE ****     *\n*  ****  SEE MEMBER $UPDATES FOR MY ADDRESS AND PHONE NUMBER ****     *\n*                                                                     *\n*---------------------------------------------------------------------*\n\nUF MODIFICATION DESCRIPTIONS\n\n\nFOR FURTHER INFORMATION ON THESE MODIFICATIONS PLEASE CONTACT:\n\nJACK SCHUDEL\nNORTHEAST REGIONAL DATA CENTER\n233 SSRB, UNIVERSITY OF FLORIDA\nGAINESVILLE, FLORIDA  32611\n(904) 392-4601\nSHARE CODE - UF\n\n\nTHIS VERSION OF QUEUE WAS DERIVED FROM FILE 278 OF THE CBT MODS TAPE,\nWHICH HAD BEEN OBTAINED FROM VERSION 18 OF THE SHARE JES2 PROJECT TAPE.\n\nUF001  ALLOW QUEUE COMMAND TO ASSEMBLE USING NJE3.1 SOURCE CODE.\n       A FEW EQUATES AND ADDITIONAL DSECTS WERE INCLUDED, WHICH SHOULD\n       BE OK FOR NON-NJE SOURCE AS WELL.\n\nUF002  ALLOW QCOMMON TO BE LINKED IN FOR TESTING.\n       WE RUN WITH SEVERAL DIFFERENT SPOOL PACK FORMATS DURING TEST,\n       AND IT IS CONVENIENT TO HAVE MULTIPLE VERSIONS OF QUEUE TO\n       SUPPORT THESE DIFFERENT TEST VERSIONS.\n       IT IS ALSO MUCH SIMPLER TO RUN UNDER TSO TEST.\n\nUF003  SUPPORT FOR 3278 MODELS 2, 4, AND 5.\n       WE HAVE A WIDE ASSORTMENT OF TERMINALS IN-HOUSE, SO QUEUE WAS\n       MODIFIED TO SUPPORT ALL TERMINAL TYPES AS BASIC MODEL 2, AND\n       TO ALLOW THE USER TO SWITCH TO THE LARGER SCREEN FORMAT AT ANY\n       TIME DURING HIS SESSION.\n       THIS CODE IS CURRENTLY RUNNING UNDER ACF/VTAM REL 2, BUT WAS\n       DEVELOPED UNDER ACF/VTAM REL 1, AND HAS ALSO RUN WITH TCAM AT\n       THE 8011 LEVEL.\n\nUF004  ADD A TITLE CARD FOR Q0 (QCOMMON).\n\nUF005  DO NOT CHECK FOR JOBNAME MATCHING TSO LOGON ID IF QXAUTH=1.\n       ALSO ALLOW READING DSID'S LESS THAN 101 IF QXAUTH=1.\n       DSID'S LESS THAN 101 ARE SOMETIMES USEFUL TO LOOK AT;  THE\n       INTERNAL TEXT FILE MAKES IT EASIER TO LOCATE THE PROPPER DSID\n       IN A SYSGEN WHERE ALL STEPNAMES ARE \"ASM\", AND IN A VM NETWORK\n       ENVIRONMENT IT IS COMMON TO HAVE OUTPUT DSID'S OF 1.\n\nUF006  ONLY READ THE CHECKPOINT IF THE INFORMATION IS NEEDED.\n       THE READ OF THE CHECKPOINT IS REMOVED FROM THE MAIN EXECUTION\n       LOOP, SINCE IT IS REALLY SILLY TO READ A LARGE CHECKPOINT DATASET\n       WHEN THE USER COMMAND IS TO JUST REPOSTITION WITHIN THE CURRENT\n       FILE.\n\nUF007  CHANGE COMMANDS \"DD *\" AND \"L * DSID\" TO USE THE LAST JOBNAME\n       IF A \"*\" IS SPECIFIED.  THIS MAKES IT EASIER TO TYPE, AND CODE\n       IS ADDED TO SKIP THE CHECKPOINT READ FOR PERFORMANCE REASONS.\n\nUF008  HAVE THE FINDPDDB ROUTINE START AT THE FIRST IOT IF PDDB IS NOT\n       FOUND.  A MIXTURE OF SPIN AND REGULAR PDDB'S USED TO CAUSE\n       THE ROUTINE TO SCAN TO THE END OF THE IOT'S AND STAY THERE WHILE\n       TRYING TO LOCATE THE FIRST REGULAR PDDB AFTER A SPUN ONE.\n\nUF009  ADD SYNAD ROUTINE AND ADDITIONAL CHECKING TO READSPC ROUTINE SO\n       THAT THE SYSTEM WILL NOT FAIL DURING XB PROCESSING.\n\nUF010  IF USER IS HAS TSO OPERATOR AUTHORITY, SET FLAG BIT IN QFLAG1,\n       AND FORCE QXAUTH ON.\n\nUF011  ADD MODULE HEXDUMP (Q28) WHICH WILL GENERATE AN ABEND FORMAT\n       DUMP OF THE DATA PASSED TO IT.\n\nUF012  CHANGE HEXBLK (Q9) TO USE HEXDUMP FOR FORMATTING THE READ\n       BUFFER.\n\nUF013  CHANGE HEXBLK (Q9) TO ALLOW ADDITIONAL INPUT PARAMETERS FOR\n       DUMPING CURRENT BLOCK, AND OFFSETS INTO THE REQUESTED BLOCK.\n       IF THE BLOCK ADDRESS PARAMETER IS \"+\", THE BUFFER CHAINED FROM\n       THE CURRENT BUFFER WILL BE DUMPED.\n\nUF014  CHANGE PARSE (Q16) TO USE 4 CHARACTER COMMAND NAMES, AND\n       CHANGE LOGIC FOR DETERMINING IF A COMMAND IN PRIVILEGED.\n\nUF015  ADD MODULE CJQE (Q29) TO DUMP JQE IN HEX.\n\nUF016  ADD MODULE CJCT (Q30) TO DUMP JCT IN HEX WITH OPTIONAL\n       OFFSET SPECIFIED.\n\nUF017  ADD MODULE CTSO (Q31) TO ALLOW ANY TSO COMMAND TO BE ISSUED\n       WHILE IN QUEUE.\n       NOTE:  THIS SHOULE NOT BE DONE IF QUEUE IS RUN AUTHORIZED.\n\nUF018  CHANGE DEFAULT STARTUP COMMAND TO \"HELP\" SO GET STARTED FASTER.\n\nUF019  ALLOW SYSPARM TO CHANGE &QXXX DEFAULTS.\n\nUF020  SUPPORT FOR SP2 LEVEL OF JES2.\n       NOTE: THERE ARE PROBABLY SOME BUGS IN THE DISPLAY COMMANDS AT\n             THIS LEVEL.  THEY ARE BEING FIXED AS THEY ARE DISCOVERED,\n             BUT SINCE THE NERDC DOES NOT NORMALLY USE THESE COMMANDS,\n             IT MAY TAKE SOME TIME TO DISCOVER THE ERRORS.\n             ONE KNOWN ERROR IS IN SEARCH (Q20) - ONLY JOES FOR OUTPUT\n             ROUTED TO LOCAL WILL BE DISPLAYED.  (THE JOT NOW CONTAINS\n             A PAIR OF POINTERS FOR EACH SYSOUT CLASS, ONE FOR LOCAL,\n             THE OTHER FOR REMOTE OUTPUT.  ONLY THE FIRST ONE IS BEING\n             PROCESSED AT THIS TIME.)\n             IT ALSO APPEARS THAT THERE ARE ALSO SOME OTHER BUGS IN\n             THE SEARCH ROUTINE WHERE SOME OF THE OUTPUT QUEUES ARE\n             NOT BEING SEARCHED AT ALL.\n\nUF021  SUPPORT FOR SP2 PTF UZ52546 (8110 LEVEL SET).\n\nUF022  ADD MODULE CHCT (Q32) TO DUMP HCT CHECKPOINTED AREA.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$UPDATES": {"ttr": 1283, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x1b\\x00\\x00\\x00\\x82#/\\x00\\x87\\x13\\x9f\\x19\\x17\\x01y\\x01\\x06\\x00\\xa7\\xc5\\xd4\\xe2@@@@@@@'", "ispf": {"version": "05.27", "flags": 0, "createdate": "1982-08-20T00:00:00", "modifydate": "1987-05-19T19:17:00", "lines": 377, "newlines": 262, "modlines": 167, "user": "EMS"}, "text": "***********************************************************************\n*                                                                     *\n*   THE QUEUE COMMAND WAS WRITTEN FOR YOUR AMUSEMENT AND AMAZEMENT BY *\n*     THE INTERGALACTIC MESSIANIC INDIVIDUAL GROUP THERAPY DIVISION   *\n*     OF TRW SYSTEMS, 1 SPACE PARK, REDONDO BEACH, CA. 90278          *\n*   THE ORIGINAL PROGRAMMING WAS DONE BY ANDY ZIDE, CHIEF PROGRAMMER  *\n*     AND RESIDENT FLAKE WHO HAS SINCE DEPARTED TRW TO PLAY WITH      *\n*     MICROCODE.                                                      *\n*                                                                     *\n*   ONCE UPON A TIME, THE FOLLOWING WAS TRUE:                         *\n*                                                                     *\n*   PLEASE ADDRESS ANY COMMENTS, SUGGESTIONS, COMPLAINTS, OR THREATS  *\n*     TO STEVEN ANDERSON (R3/1028)  (213) 535-0682  OR                *\n*        PAUL FELIX      (R3/1028)  (213) 535-0682                    *\n*                                                                     *\n*   SINCE STEVE ANDERSON HAS ALSO LEFT TRW, AND SINCE TRW WOULDN'T    *\n*      RECOGNIZE THIS VERSION OF QUEUE ANYWAY, ADDRESS ALL COMMENTS,  *\n*      SUGGESTIONS (ETC, SEE ABOVE) TO LDW (SEE BELOW).               *\n*                                                                     *\n***********************************************************************\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*   MAJOR CHANGES WERE MADE (AND GENERAL OVERHAUL DONE) BY            *\n*                                                                     *\n*            LEONARD D. WOREN                                         *\n*            HUGHES AIRCRAFT COMPANY                                  *\n*            BLDG S50 / MS X303                                       *\n*            P.O. BOX 92919                                           *\n*            LOS ANGELES, CA 90009                                    *\n*            (213) 647-8755                                           *\n*                                                                     *\n*   SHARE INSTALLATION CODE:  HAL                                     *\n*   GUIDE INSTALLATION CODE:  FMO                                     *\n*                                                                     *\n*                                                                     *\n*   >>> MY CHANGES ARE MUCH TOO EXTENSIVE TO FLAG IN THE SOURCE <<<   *\n*                                                                     *\n*   I WOULD VERY MUCH REQUEST THAT ANY CHANGES MADE TO THIS VERSION   *\n*   WHICH MIGHT BE OF USE TO OTHER INSTALLATIONS BE SENT TO ME, SO    *\n*   I CAN INCORPORATE THEM.  THE ORIGINAL AUTHOR WILL BE CREDITED,    *\n*   UNLESS OTHERWISE REQUESTED.                                       *\n*                                                                     *\n*                                                                     *\n*   MUCH RE-DESIGN AND DEVELOPMENT WAS DONE BY LEONARD WOREN AT       *\n*   GIBRALTAR SAVINGS AND LOAN IN BEVERLY HILLS, CALIFORNIA.          *\n*                                                                     *\n*   MORE DEVELOPMENT WAS DONE BY LEONARD WOREN AT                     *\n*   HARTFIELD-ZODYS IN LOS ANGELES, CALIFORNIA.                       *\n*                                                                     *\n*   MORE DEVELOPMENT WAS DONE BY LEONARD WOREN AT                     *\n*   TITLE INSURANCE IN LOS ANGELES, CALIFORNIA.                       *\n*                                                                     *\n*   MANY OF THE CHANGES INCORPORATED INTO THIS VERSION WERE WRITTEN   *\n*   BY OTHERS (IN SEPARATE AND DEFINITELY NOT EQUAL VERSIONS OF       *\n*   QUEUE.)  SOME OF THEIR CHANGES WERE COPIED INTO THIS VERSION      *\n*   VERBATUM; WITH SOME OTHERS, JUST THE CONCEPT WAS USED.            *\n*                                                                     *\n*                                                                     *\n*   METHOD OF INVOKING DSECTS TOTALLY REWORKED BY STEVE MCGINTY       *\n*                                                                     *\n*   CHANGES INCLUDE:                                                  *\n*      1) ELIMINATE SEPARATE LOAD MODULE \"QUEUECMN\"                   *\n*         (GETMAIN A WORK AREA INSTEAD)                               *\n*      2) IMPROVEMENTS TO \"DISPLAY\"                                   *\n*         A) FIX BUG IN TGET CODE DUE TO TCLEARQ                      *\n*         B) USE VTAM MACROS FOR FULLSCREEN SUPPORT (STFSMODE)        *\n*         C) REDESIGN SCREEN LAYOUT (NOW SIMILAR TO SPF)              *\n*         D) TO SAVE TIME ON LOW-SPEED REMOTES, TRAILING BLANKS ARE   *\n*            NOT WRITTEN                                              *\n*      3) IMPROVEMENTS TO \"PARSE\"                                     *\n*         A) GENERAL CLEANUP.  NOTE PARTICULARLY THAT PRIVILEGED      *\n*            COMMANDS NO LONGER MUST START WITH \"X\"                   *\n*         B) ALLOW \"*\" TO REFER TO LAST-REFERENCED JOBID.  ALLOW      *\n*            BLANK TO DO THE SAME FOR NON-ACTION COMMANDS.  (ONLY     *\n*            POSSIBLE IF NO OPERANDS ARE NEEDED AFTER THE JOBID.)     *\n*         C) INVALID COMMAND SAYS SO, RATHER THAN FORCING \"HELP\".     *\n*         D) FOR ANY SUBCOMMAND WHOSE FIRST OPERAND IS A <JOBID>,     *\n*            IF JUST A SINGLE CHARACTER IS ENTERED, THE USERID        *\n*            WILL BE PREFIXED TO THE SINGLE CHARACTER.  I.E., IF      *\n*            THE USERID IS \"USER1\", AND \"JL A\" IS ENTERED, IT         *\n*            ACTS LIKE \"JL USER1A\"                                    *\n*         E) PROVIDE FOR KEYWORD=VALUE OPERANDS                       *\n*         F) PROVIDE FOR RESERVED WORD OPERANDS (IF NOT PRECEDED BY   *\n*            A KEYWORD=VALUE OPERAND, A SLASH MUST BE ENTERED FIRST,  *\n*            UNLESS NO POSITIONAL OPERANDS ARE ALLOWED FOR THIS       *\n*            SUBCOMMAND, IN WHICH CASE THE SLASH IS OPTIONAL)         *\n*      4) ENHANCED \"FORMAT\" ROUTINE                                   *\n*         A) DISPLAY PROGRAMMER NAME IN SUBCOMMANDS: \"DA\",\"DS\",\"DT\".  *\n*         B) DISPLAY UCS, FCB, FORM, FLASH, RJE DEST SYMBOLIC NAME    *\n*         C) RECOGNIZE A JOB PRINTING ON THE EXTERNAL WRITER          *\n*         D) DETAIL THE HOLD TYPE (HELD/ALL/DUP).                     *\n*         E) DISPLAY INPUT DATE/TIME IN SUBCOMMANDS: \"DI\",\"HI\" IF     *\n*            \"TIME\" IS GIVEN AS A RESERVED WORD OPERAND, IE \"DI A /T\" *\n*         F) DISPLAY OUTPUT DATE/TIME IN SUBCOMMANDS: \"DO\",\"AO\" IF    *\n*            \"TIME\" IS GIVEN AS A RESERVED WORD OPERAND, IE \"DO A /T\" *\n*      5) IMPROVED ALLOCATION                                         *\n*         A) USE UNIT=SYSALLDA INSTEAD OF REQUIRING UNIT TO BE        *\n*            SPECIFIED IN QCOMMON MACRO.                              *\n*         B) RATHER THAN USING FIXED DDNAMES, THE HASPCKPT AND        *\n*            HASPACE DDCARDS WILL NOW BE RE-USED IF STILL             *\n*            ALLOCATED, AND NOT FREED AT EXIT.                        *\n*      6) NEW SUBCOMMANDS:                                            *\n*         A) OPERATOR COMMANDS IF AUTHORIZED (HJ, AJ, /, $)           *\n*         B) \"JOB\" AND \"JX\" SUBCOMMANDS FOR DETAILED JOB INFORMATION  *\n*         C) \"TSO\" SUBCOMMAND (LIKE IN IPCS)                          *\n*         D) \"LEFT\" AND \"RIGHT\" COMMANDS.  (PF10 & PF11 CHANGED)      *\n*         E) \"PURGE\" TO PURGE A JOB BY CANCELLING IT                  *\n*         F) \"ROUTE\" TO REROUTE A JOBS OUTPUT                         *\n*         G) \"*\" SUBCOMMAND TO REPROMPT THE LAST ENTERED SUBCOMMAND   *\n*         H) \"CONS\" SUBCOMMAND TO DISPLAY AN OPERATOR CONSOLE BUFFER  *\n*         I) \"DEV\" SUBCOMMAND TO DISPLAY JOBS ON DEVICES              *\n*         J) \"MODE\" SUBCOMMAND TO SET USER DEFAULTS                   *\n*            1) FANUM   - DISPLAY RECORD NUMBERS DURING \"FINDALL\"     *\n*            2) SHOWCC  - DISPLAY CARRIAGE CONTROL CHARACTERS         *\n*            3) BEEP    - SOUND AUDIBLE ALARM FOR ERROR MESSAGES      *\n*            4) DEST    - SET DEFAULT PRINT SYSOUT DESTINATION        *\n*            5) CLASS   - SET DEFAULT PRINT SYSOUT CLASS              *\n*            6) PAGE    - PROCESS OUTPUT IN PRINTED PAGE MODE         *\n*            7) DESTR   - SET DEFAULT ROUTE DESTINATION               *\n*            8) FCB     - SET DEFAULT PRINT FCB NAME                  *\n*            9) UCS     - SET DEFAULT PRINT UCS NAME                  *\n*           10) FORM    - SET DEFAULT PRINT FORM NAME                 *\n*           11) NOVERIFY- BYPASS VERIFY FOR ACTION SUBCOMMANDS        *\n*           12) STATUS  - SET DEFAULT SEARCH KEY FOR \"ST *\"           *\n*         K) \"JNEWS\" SUBCOMMAND TO DISPLAY JESNEWS                    *\n*         L) \"LSYS\" TO LIST STATUS OF ALL MULTI-ACCESS SPOOL SYSTEMS  *\n*         M) \"LRMT\" TO LIST ALL DESTINATION CODES IN A NETWORK        *\n*         N) \"ABEND\" FOR INSTANT 0C1                                  *\n*         O) \"DHX\" TO DISPLAY ALL JOBS ON $OUTPUT (\"DH\" SUPPRESSES    *\n*            JOBS WHICH DON'T CURRENTLY HAVE HELD OUTPUT)             *\n*         P) \"LBLK\" TO LIST MOST HASPACE RESIDENT CONTROL BLOCKS FOR  *\n*            A JOB                                                    *\n*         Q) \"DN\" TO DISPLAY ALL JOBS IN ALL QUEUES                   *\n*         R) \"QINT\" SUBCOMMAND TO DISPLAY AND SET INTERNAL QUEUE      *\n*            FUNCTIONS                                                *\n*            1) USER    - TURN OFF ALL PRIVILEGE FLAGS                *\n*            2) OPER    - TURN ON OPER PRIVILEGE FLAG                 *\n*            3) SYSP    - TURN ON SYSP PRIVILEGE FLAG                 *\n*            4) COMCHAR - SET JES2 COMMUNICATIONS CHARACTER           *\n*         S) CHGS SUBCOMMAND TO DISPLAY LIST OF UPDATES TO QUEUE CMD  *\n*         T) PFK SUBCOMMAND TO ALLOW USER DEFINED PF KEYS             *\n*         U) JCT SUBCOMMAND TO DISPLAY A JCT IN HEX                   *\n*         V) HCT SUBCOMMAND TO DISPLAY THE $SAVEAREA IN HEX           *\n*         W) REDISP SUBCMD TO RE-INVOKE LISTDS ON CURRENT DATASET     *\n*         X) QCMN SUBCMD TO DISPLAY QCOMMON WORK AREA IN HEX          *\n*         Y) CKPT SUBCMD TO DISPLAY CKPT DATA AREA IN HEX             *\n*         Z) LTXT SUBCMD TO DISPLAY INTERNAL TEXT IN HEX              *\n*        AA) EDIT AND BROWSE SUBCOMMANDS TO INTERFACE TO SPF          *\n*      7) MOVE CODE FOR \"JCL\", \"JLOG\", AND \"JMSG\" (Q11, Q12, Q13)     *\n*         INTO \"LIST\" (Q14)                                           *\n*      8) USE OF MORE PRIVATE MACROS (QCALL, QCMDE, QITEM, QDSECTS)   *\n*      9) \"XB\" IMPROVEMENTS                                           *\n*         A) \"XB *\" TO RE-DISPLAY BLOCK, \"X\" & \"C\" OPERANDS           *\n*         B) VALIDITY CHECK OPERAND                                   *\n*         C) RESTRICT TO SYSTEMS PROGRAMMERS, SINCE JCT'S CONTAIN     *\n*            RACF PASSWORDS                                           *\n*     10) \"XJ\" IMPROVEMENTS                                           *\n*         A) DISPLAY CHARACTERISTIC AND CHECKPOINT JOES ALSO          *\n*         B) DISPLAY EVERYTHING IN DUMP FORMAT (HEX AND CHAR)         *\n*     11) IMPROVEMENTS TO \"FINDJOB\"                                   *\n*         A) CENTRALIZED VALIDITY CHECKING OF ACCESS TO JOBS          *\n*         B) DISPLAY JOBNAME/NUMBER WHEN \"JOB NOT FOUND\"              *\n*     12) ENHANCED \"DD\" SUBCOMMAND                                    *\n*     13) ALLOW THIS MONSTER TO BE ASSEMBLED IN ONE PIECE, IF DESIRED *\n*     14) DSN() KEYWORD ON INVOKATION                                 *\n*     15) \"STATUS\" REMEMBERS SEARCH KEY                               *\n*     16) AUTOMATICALLY PRIVILEGE THE USER IF PSCBCTRL (OPERATOR)     *\n*         OR PSCBACCT (ACCOUNT)                                       *\n*     17) REPROMPT LAST INQUIRY COMMAND AFTER ACTION COMMANDS         *\n*     18) \"SAVE\" SUBCOMMAND ENHANCEMENTS                              *\n*         A) DISPOSITION AVAILABLE                                    *\n*         B) ALLOW FULLY QUALIFIED DSNAMES                            *\n*     19) CHANGE MUCH HARDCODED DATA TO SYMBOLICS FROM HASP DSECTS    *\n*     20) EXPANDED \"HELP\" SUBCOMMAND                                  *\n*     21) \"DQ\" IMPROVEMENTS                                           *\n*         A) COMBINE \"DQ\" AND \"DF\" INTO \"DQ\"                          *\n*         B) ADD % SPOOL AND NUMBER OF OUTPUT LINES TO DISPLAY.       *\n*         C) DISPLAY *ALL* QUEUES                                     *\n*         D) OPERANDS:  \"M\" - DISPLAY ONLY MISC QUEUE SUMMARY         *\n*                       \"I\" - DISPLAY ONLY INPUT QUEUE SUMMARY        *\n*                       \"O\" - DISPLAY ONLY OUTPUT QUEUE SUMMARY       *\n*                       \"X\" - COUNT ALL $OUTPUT JOBS                  *\n*     22) ALLOW DELIMITERS TO BE OMITTED FOR \"FIND\" IF FIRST CHAR IS  *\n*         ALPHANUMERIC AND NO BLANKS ARE IN THE STRING.               *\n*     23) ALLOW \"M\" AND \"H\" AS OPERANDS OF \"UP\" AND \"DOWN\" (LIKE IN   *\n*         SPF)                                                        *\n*     24) AO/DO IMPROVEMENTS                                          *\n*         A) FIX BUG SO \"AO\" NO LONGER DISPLAYS HELD JOBS.            *\n*         B) ADD R= OPERAND TO SELECT PRINT DESTINATION               *\n*            (DEFAULT IS LOGON DEST)                                  *\n*         C) CHANGE PF9 FROM \"DO\" TO \"AO\"                             *\n*     25) SYSLOG IMPROVEMENTS                                         *\n*         A) \"SL SYSLOG\" OR \"SL\" GETS THE ACTIVE SYSLOG               *\n*         B) \"SL SID\" WILL FIND THE ACTIVE SYSLOG FOR SYSTEM 'SID'    *\n*         C) DEFAULT COL IS 6 (START OF TIMESTAMP)                    *\n*     25) NOW CAN FIND JOBS ON MISCELLANEOUS QUEUES SUCH AS           *\n*         $INPUT (READING), AND THE PURGE QUEUE                       *\n*     26) \"DC\" SUBCOMMAND FIXED, AND I/O COUNT & ASID ADDED TO DISPLAY*\n*     27) HIGH INTENSITY \"END OF DATA\" INDICATOR                      *\n*     28) \"ENTER\" AT BOTTOM OF DS STAYS AT BOTTOM (USEFUL IN SYSLOG)  *\n*     29) \"ST *\" TO RESET SEARCH KEY TO CURRENT DEFAULT               *\n*     30) ST/DJ/XJ JOBNO                                              *\n*     31) QUEUE MAY NOW BE \"CALL\"ED.                                  *\n*     32) ALL REMAINING OPTIONS MOVED FROM QCOMMON TO QGLOBALS (COPY  *\n*         MEMBER).  ALSO, CONDITIONAL ASSEMBLY SWITCHES PUT HERE TO   *\n*         ALLOW ASSEMBLING ANY NUMBER (1 TO ALL) ROUTINES AT ONCE,    *\n*         AVOIDING DUPLICATE GBLB DEFINITIONS.                        *\n*     33) DCB'S SPLIT OUT OF QCOMMON (INTO QDCB, WHAT ELSE?) TO       *\n*         INCREASE SPEED OF SINGLE MODULE ASSEMBLY.                   *\n*     34) QDSECT MACRO DYNAMITED INTO ONE MACRO FOR EACH DSECT, SO    *\n*         THAT PEOPLE WITHOUT ASMH WON'T GET ALL MACROS EDITED IN     *\n*         FROM SYSLIB FOR EACH ASSEMBLY, WHETHER THEY ARE EXPANDED OR *\n*         NOT.                                                        *\n*     35) DSECT MACROS EXPAND PRE-REQ (HASP) DSECT MACROS.            *\n*     36) VALIDITY CHECK CONTROL BLOCK ID'S, TO INSURE WHAT WAS READ  *\n*         IS WHAT WAS EXPECTED.                                       *\n*     37) CHANGE MEMBER NAMES FROM QNN TO Q#XX, WHERE XX IS A         *\n*         MNEMONIC FOR THE ROUTINE NAME.  (ALSO, IT IS THE PREFIX     *\n*         FOR LABELS IN THAT ROUTINE.)                                *\n*     38) INITIALIZE SYSTEM ID'S FROM QSE'S.                          *\n*     39) ADD SUPPORT FOR NON-FULLSCREEN TERMINALS.                   *\n*     40) ONLY READ CKPT DATASET WHEN ACTUALLY NEEDED.  (CONCEPT      *\n*         STOLEN FROM OTHER VERSIONS OF QUEUE.)                       *\n*     41) DELETE \"XD\" COMMAND, ALLOW PRIVILEGED USERS TO USE \"L\" ON   *\n*         ALL DSID'S.  (Q22 - \"XDS\" - ROUTINE DELETED)                *\n*     42) RENAME \"ACTIVE\" TO \"CPU\".  CHANGE SUBCOMMAND NAME FROM \"DC\" *\n*         TO \"CPU\".                                                   *\n*     43) HANDLE DATASET RECORD NUMBER TABLE OVERFLOW.                *\n*     44) DON'T LET USER \"POSITION\" PAST END OF DATASET               *\n*     45) \"PRINT ON\" NOW ONLY ALLOCS AND OPENS PRINT FILE, DOES NOT   *\n*         PRINT SCREEN IMAGE                                          *\n*     46) ACF2 SUPPORT (I AM NOT THE FIRST ONE TO WRITE ACF2 SUPPORT  *\n*         FOR QUEUE, BUT I DIDN'T HAVE A VERSION WHICH HAD IT.)       *\n*     47) ADD SUPPORT FOR 3278-3, 3278-4                              *\n*     48) ADD DELAY TO KEEP FROM READING CHECKPOINT FILE TOO OFTEN    *\n*     49) TOTALLY REWRITTEN \"HELP\" ROUTINE                            *\n*     50) REDESIGNED \"HEXBLK\" ROUTINE                                 *\n*     51) DON'T READ CKPT DATA IF SELECTING SAME JOB AS PREVIOUS      *\n*         (THIS IS ANOTHER CONCEPT LIFTED FROM ANOTHER VERSION OF Q)  *\n*     52) SOUND AUDIBLE ALARM FOR ERROR MESSAGES                      *\n*     53) SYSTEM TABLE SO WE CAN TRY TO GET THE CORRECT CHKPT/PREFIX  *\n*     54) SUPPORT SECONDARY SUBSYSTEMS CORRECTLY (DON'T ALWAYS USE    *\n*         PRIMARY SSVT)                                               *\n*     55) JES(NAME) KEYWORD ON INVOCATION                             *\n*     56) ELIMINATION OF INDEPENDENTLY ADDRESSED WORKAREAS SO MOST    *\n*         ROUTINES DON'T HAVE TO PICK UP 3 POINTERS, DO 3 USINGS, AND *\n*         TIE UP 3 REGISTERS.  (THIS CHANGE SUGGESTED BY MIKE STEIN)  *\n*     57) BASIC SUPPORT FOR NJE (SDM)                                 *\n*     58) \"* F\" TO REPROMPT LAST FIND COMMAND                         *\n*     59) CAN NOW FIND JOBS ON \"PURGE\" QUEUE                          *\n*     60) FIX BUG IN COUNTING POSITION FOR \"STATUS\" SUBCOMMAND        *\n*     61) \"HO\" SUBCOMMAND RENAMED TO \"DH\"                             *\n*     62) QUEUE \"PROFILE\" SUPPORT.  IF DDNAME \"QPROF\" IS ALLOCATED    *\n*         AT INITIALIZATION TIME, SUBCOMMANDS ARE READ FROM THERE.    *\n*         IF NOT, DDNAME \"SYSPROC\" IS CHECKED FOR A MEMBER \"QPROF\",   *\n*         AND SUBCMDS ARE READ FROM THERE.  THESE SUBCOMMANDS ARE     *\n*         THEN EXECUTED BEFORE THE FIRST USER SPECIFIED ONE.  THESE   *\n*         SUBCMDS SHOULD ONLY BE \"IMMEDIATE\" TYPE SUBCOMMANDS (\"MODE\" *\n*         AND \"QINT\").  THE FIRST NON-IMMEDIATE SUBCMD IN A PROFILE   *\n*         WILL CAUSE ALL REMAINING PROFILE COMMANDS TO BE IGNORED.    *\n*         ALSO, AN ERROR IN ONE WILL CAUSE THE REST TO BE IGNORED.    *\n*                                                                     *\n***********************************************************************\n         EJECT\n***********************************************************************\n*                                                                     *\n*  CHANGES FROM THE FOLLOWING INDIVIDUALS HAVE, IN SOME FORM OR       *\n*  OTHER, FOUND THEIR WAY INTO THIS VERSION:                          *\n*                                                                     *\n*                                                                     *\n*  VILKO MACEK                                                        *\n*  INSURANCE CORPORATION OF BRITISH COLUMBIA                          *\n*  --> PFK SUPPORT <--                                                *\n*                                                                     *\n*                                                                     *\n*  TRW ISD                                                            *\n*  ANAHEIM, CALIFORNIA                                                *\n*  --> DISPLAY CPU TIME FOR BATCH, STC, AND TSO <--                   *\n*  --> DISPLAY INITIATORS <--                                         *\n*                                                                     *\n*                                                                     *\n*  KEN TRUE                                                           *\n*  FAIRCHILD CAMERA AND INSTRUMENT                                    *\n*  MOUNTAIN VIEW, CALIFORNIA                                          *\n*  --> ACF2 SUPPORT <--                                               *\n*  --> PRINT SCREEN SUPPORT <--                                       *\n*                                                                     *\n*                                                                     *\n*  STEVEN D. MCGINTY                                                  *\n*  TERADATA                                                           *\n*  INGLEWOOD, CALIFORNIA                                              *\n*  --> BASIC SUPPORT FOR NJE (NON-SP) <--                             *\n*                                                                     *\n*                                                                     *\n*  ERIC M. SCHINDLER                                                  *\n*  M.C.R.B. SERVICE BUREAU                                            *\n*  NORTH HOLLYWOOD, CALIFORNIA                                        *\n*  --> MISCELLANEOUS FIXES THRUOUT  <--                               *\n*                                                                     *\n*                                                                     *\n*  MICHAEL A. STEIN                                                   *\n*  UCLA OFFICE OF ACADEMIC COMPUTING (OAC)                            *\n*  LOS ANGELES, CALIFORNIA                                            *\n*  --> SOME METHODOLOGY FOR SP SUPPORT STOLEN FROM MAS'S VERSION <--  *\n*                                                                     *\n*                                                                     *\n*  JACK SCHUDEL                                                       *\n*  NORTHEAST REGIONAL DATA CENTER                                     *\n*  233 SSRB, UNIVERSIFY OF FLORIDA                                    *\n*  GAINSEVILLE, FLORIDA  32611                                        *\n*  (904) 392-4601                                                     *\n*  (JACK MADE MANY CHANGES, SOME OF WHICH I HAD ALREADY MADE IN MY    *\n*  VERSION, SO I LIST ONLY THE SIGNIFICANT ONES I LIFTED FROM HIS)    *\n*  --> ONLY READ CHECKPOINT IF IT IS NEEDED <--                       *\n*  --> ADD SYNAD ROUTINE TO READSPC <--                               *\n*  --> ADD NEW MODULE TO GENERATE ABEND FORMAT DUMP OF DATA <--       *\n*  --> ALLOW AUTHORIZED USERS TO LOOK AT DSID'S LESS THAN 101 <--     *\n*  --> CHANGE PARSE TO USE 4 CHARACTER COMMAND NAMES <--              *\n*  --> CHANGE HEXBLK TO USE HEXFMT FOR FORMATTING THE BUFFER <--      *\n*  JACK'S COMPLETE LIST OF CHANGES IS IN MEMBER $UFDOC, BUT REALIZE   *\n*  THAT $UFDOC IS A LIST OF CHANGES HE MADE TO HIS VERSION, NOT MINE. *\n*                                                                     *\n*  J. O. SKIP ROBINSON                                                *\n*  TRANSACTION TECHNOLOGY                                             *\n*  3100 OCEAN PARK BLVD.                                              *\n*  SANTA MONICA, CALIFORNIA 90405                                     *\n*  (213)  450-9111                                                    *\n*  (SKIP ALSO MADE MANY CHANGES, SOME OF WHICH I HAD ALSO MADE, MOST  *\n*  OF THE REST OF WHICH DID NOT FIT, BUT MANY OF WHICH I LIFTED THE   *\n*  IDEA.  THE STOLEN IDEAS ARE LISTED BELOW.  ALSO, HE IMPLEMENTED    *\n*  LINE COMMANDS, WHICH I HAD ALWAYS PLANNED ON DOING, BUT NEVER GOT  *\n*  TO IT.  I AM IMPLEMENTING THEM MY OWN WAY NOW.)                    *\n*  --> PRINT CURRENT DATASET <--                                      *\n*  --> SYSLOG SID <--                                                 *\n*  --> QTILT NOT CLEARING THE REST OF THE SCREEN <--                  *\n*  --> SPF EDIT AND BROWSE INTERFACE <--                              *\n*  --> SEPARATE ROUTINE (GETREC) FOR GET-NEXT-RECORD FROM HASPACE <-- *\n*                                                                     *\n***********************************************************************\n         SPACE 2\n***********************************************************************\n*\n*  THINGS TO ADD:\n*       EXPLANATION OF SCREENS TO HELP\n*       \"DF\" SUBCOMMAND\n*       RPRT, RPUN, RALL(=ROUTE) SUBCOMMANDS\n*       \"PROF XXX\" TO EXECUTE A NEW PROFILE LIST\n*       INTERNAL TRACE IF SYSUDUMP PRESENT\n*       LSYS - SHOW WHAT SYSTEM LAST DID COLDSTART\n*       SHOW WHAT SYS OWNS CKPT LOCK\n*       ADD TRANSLATE TO QITEM ?\n*       USE GTTERM INSTEAD OF GTSIZE IF VTAM\n*       CHECK FOR JES2CKPT DD CARD (INVOCATION PARM = CKPTDDN(XXX) )\n*          IF PRESENT, USE IT (EXTRACT PREFIX) & DON'T FREE UPON EXIT\n*          OTHERWISE, FREE HASPCKPT & HASPACE\n*       IF SP3, USE XM IF POSSIBLE\n*       LINK TO CONS AS SUBR\n*       ADD PARSE FLAGS SO MAINLINE CAN INVOKE CKPT OR FINDJOB IF REQ'D\n*       SUBCMD TO LIST ASM DATES FOR EACH SUBROUTINE\n*       HEXFMT SHOULD HANDLE MOD 5\n*       DISPLAY LOCAL NODE (SYSLIST AND/OR RMTLIST)\n*       CHANGE  DDNAME TO USE GETREC\n*       SUBCMD TO SHOW DDNAME, PDDB INFO\n*\n*\n*  THINGS TO FIX:\n*       COLUMN RESTRICTION SEEMS TO NOT WORK FOR \"FIND\"\n*       REDUCE SUBCMD TESTING OF \"QSUBNAME\"\n*       ATTN ON TWX???\n*       \"MODE PAGE\";\"B\" DOESN'T WORK RIGHT\n*       MODE PAGE; ENTER;ENTER;UP;ENTER;RIGHT GETS DIFFERENT RESULTS\n*           THAN   ENTER;ENTER;UP;DOWN; RIGHT\n*       DUE TO LIMITATIONS IN PARSE, CANNOT DO FIND FOR ANY STRING\n*           CONTAINING AN EQUAL SIGN, AND CANNOT USE / FOR DELIMITER\n*\n***********************************************************************\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "#MHELP": {"ttr": 1290, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x843/\\x00\\x843/\\x15U\\x00\\x0b\\x00\\x01\\x00\\n\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1984-11-27T00:00:00", "modifydate": "1984-11-27T15:55:00", "lines": 11, "newlines": 1, "modlines": 10, "user": "LDW"}, "text": "         MHELP 1+2                      MAC CALL TRC + MAC BRANCH TRACE\nIBMPRINT OPSYN PRINT\nPRINT    OPSYN\n         MACRO\n         IBMPRINT &OP1,&OP2\n         AIF   ('&OP1' EQ 'OFF' OR '&OP1' EQ 'NOGEN').A\n         IBMPRINT &OP1\n.A       AIF   ('&OP1' EQ '').B\n         AIF   ('&OP1' EQ 'OFF' OR '&OP1' EQ 'NOGEN').B\n         PRINT &OP2\n.B       MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "A24": {"ttr": 1292, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x90\\x16\\x7f\\x00\\x90\\x16\\x7f\"\\x04\\x00\\x01\\x00\\x01\\x00\\x01\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1990-06-16T00:00:00", "modifydate": "1990-06-16T22:04:00", "lines": 1, "newlines": 1, "modlines": 1, "user": "LDW"}, "text": "         BAL   R14,QAMODE24             change to AMODE 24\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "A31": {"ttr": 1294, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x90\\x16\\x7f\\x00\\x90\\x16\\x7f\"\\x04\\x00\\x01\\x00\\x01\\x00\\x01\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1990-06-16T00:00:00", "modifydate": "1990-06-16T22:04:00", "lines": 1, "newlines": 1, "modlines": 1, "user": "LDW"}, "text": "         BAL   R14,QAMODE31             resume AMODE 31\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "BOX": {"ttr": 1296, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x864\\x8f\\x00\\x864\\x8f!\\x16\\x00\\x07\\x00\\x07\\x00\\x00\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1986-12-14T00:00:00", "modifydate": "1986-12-14T21:16:00", "lines": 7, "newlines": 7, "modlines": 0, "user": "LDW"}, "text": ".*--------------------------------------------------------------------*\n.*                                                                    *\n.*  UPDATES:                                                          *\n.*     04/10/84 LDW  CHANGE TO MVS MACRO FOR MVS/SP JES2 133          *\n.*                                                                    *\n.*--------------------------------------------------------------------*\n.*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "C": {"ttr": 1298, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x83\\x03O\\x00\\x83\\x03O\\x134\\x00\\x01\\x00\\x01\\x00\\x00\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1983-02-03T00:00:00", "modifydate": "1983-02-03T13:34:00", "lines": 1, "newlines": 1, "modlines": 0, "user": "LDW"}, "text": "*---                                                               ---*\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "GLA": {"ttr": 1300, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x91\\x03/\\x00\\x91\\x03/\\x19C\\x00\\x01\\x00\\x01\\x00\\x00\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1991-02-01T00:00:00", "modifydate": "1991-02-01T19:43:00", "lines": 1, "newlines": 1, "modlines": 0, "user": "LDW"}, "text": "*      01Feb91  LDW  Integrate GLA fixes below:                       *\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ISRQ": {"ttr": 1302, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x02\\x00\\x00\\x00\\x90&\\x0f\\x00\\x91\\x03?!U\\x00z\\x00\\xac\\x00\\x1f\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "02.02", "flags": 0, "createdate": "1990-09-17T00:00:00", "modifydate": "1991-02-02T21:55:00", "lines": 122, "newlines": 172, "modlines": 31, "user": "LDW"}, "text": "         TITLE 'ISPF/PDF / QUEUE INTERFACE MODULE'                 LDW1\nISRQ     QSTART TYPE=MAIN               START ISRQ CSECT ASSEMBLY\n         USING WORK,R13                 OUR WORK AREA\n         PRINT GEN\n***********************************************************************\n*                                                                     *\n*  GET PARMS PASSED FROM ISPF                                         *\n*                                                                     *\n***********************************************************************\n         L     R3,0(,R2)                GET TLD ADDRESS\n         ST    R3,QPRM1                 SETUP PARM LIST\n         L     R6,4(,R2)                GET PARM ADDR              LDW2\n         SH    R6,=H'2'                 BACK UP TO PARM LENGTH     LDW2\n         LOAD  EPLOC==CL8'ISPLINK'                                 LDW1\n         ST    R0,QPRM2                 SAVE ADDRESS OF 'ISPLINK'  LDW1\n***********************************************************************\n*                                                                     *\n*  GET ADDRESS OF ORIGINAL CPPL AND BUILD OUR OWN COPY                *\n*                                                                     *\n***********************************************************************\n         USING PSA,R0\n         L     R2,PSATOLD               GET MY TCB ADDR\n         USING TCB,R2\n         L     R2,TCBOTC                GET MOTHER TASK (ISPF ITSELF)\n         L     R2,TCBFSA                GET ISPF FSA\n         L     R2,12+4+4+4(,R2)         GET R1 ON ENTRY TO ISPF (CPPL)\n         DROP  R2,R0\n         MVC   QCPPL(CPPLLEN),0(R2)     COPY CPPL\n         LA    R2,QCPPL                 POINT AT OURS\n         ST    R2,QPRM3                 SAVE ADDRESS OF CPPL\n***********************************************************************\n*                                                                     *\n*  RETRIEVE NAME OF QUEUE COMMMAND FROM SCREEN                        *\n*                                                                     *\n***********************************************************************\n         MVC   LENG,=F'8'               SET MAX LENGTH\n         L     R15,QPRM2                -> ISPLINK                 LDW1\n         CALL  (15),(VCOPY,VNM1,LENG,QNAME,VMOVE),VL,              LDW1$\n               MF=(E,VCALLST)\n***********************************************************************\n*                                                                     *\n*  BUILD A COMMAND BUFFER                                             *\n*                                                                     *\n***********************************************************************\n         USING CPPL,R2\n         LA    R1,ISRCBUF               GET ADDRESS OF FAKE CMD BUFFER\n         ST    R1,CPPLCBUF              POINT AT NEW BUFFER\n         MVC   0(4,R1),=AL2(0,0)        SET HEADER\n         MVC   4(72,R1),=CL72' '        SET BLANKS\n         MVC   4(8,R1),QNAME            MOVE IN COMMAND NAME\n         L     R3,LENG                  GET LENGTH OF NAME\n         STH   R3,ISRCBUF+2             SET OFFSET USED\n         LA    R3,4+1(R3,R1)            POINT TO FREE BYTE\n         LH    R15,0(,R6)               GET PARM LENGTH            LDW2\n         SH    R15,=H'1'                -1 FOR EX                  LDW2\n         BM    *+8                      SKIP MOVE IF NOTHING       LDW2\n         EX    R15,MVCPARM              MVC 0(*-*,R3),2(R6)        LDW2\n         LA    R5,1(R15,R3)             POINT PAST LAST BYTE       LDW2\n         SR    R5,R1                    GET LENGTH USED\n         STH   R5,ISRCBUF               SET LENGTH USED\n         DROP  R2\n***********************************************************************\n*                                                                     *\n*  INVOKE QUEUE                                                       *\n*                                                                     *\n***********************************************************************\n         XC    LINKSFL(LINKSFLL),LINKSFL  CLEAR LINK SF=L AREA     LDW2\n         MVC   QPRM0,=F'-1'             SET PARAMETER TO IND NOT CPPL\n         LA    R1,QPRM0                 POINT AT PARMS\n         LINK  EPLOC=QNAME,SF=(E,LINKSFL)  GO DO COMMAND           LDW2\n         DELETE  EPLOC==CL8'ISPLINK'                               LDW1\n*LDW1    QSTOP RC=0                     EXIT\n         L     R13,4(,R13)\n         LM    R14,R12,12(R13)\n         SR    R15,R15\n         BR    R14\n         SPACE 2\nMVCPARM  MVC   0(*-*,R3),2(R6)          << EXECUTED >>             LDW2\n***********************************************************************\n*                                                                     *\n*  MISCELLANY                                                         *\n*                                                                     *\n***********************************************************************\nVCOPY    DC    CL8'VCOPY'               VARIABLE SERIVCE NAMES\nVNM1     DC    CL8'QCMDNM'              ---\nVNM2     DC    CL8'QPRFX'               |\nVNM3     DC    CL8'QVLSR'               |   VARIABLE NAMES\nVNM4     DC    CL8'QUNIT'               |\nVNM5     DC    CL8'QSBS'                |\nVNM6     DC    CL8'QICMD'               ---\nVMOVE    DC    CL8'MOVE'\n***********************************************************************\n*                                                                     *\n*  GENERATE CONTROL BLOCK DSECTS                                      *\n*                                                                     *\n***********************************************************************\nSYMDEL   DSECT ,                        KILL SYM CARD GENERATION\nISRQ     CSECT ,\n*LDW1    QPRBGEN BEGIN                  SET PRINT FOR CNTL BLOCK GEN\n*LDW1    $HASPEQU\n         IHAPSA ,\n         IKJTCB ,\n         IKJCPPL ,\nCPPLLEN  EQU   *-CPPL                   LENGTH OF CPPL\n*LDW1    QPRBGEN DONE                   RESTORE NORMAL PRINT STATUS\nWORK     DSECT ,\nQCOMMON  EQU   WORK                     TO AVOID ERRORS\n         DS    CL72\nLINKSFL  LINK  SF=L                                                LDW2\nLINKSFLL EQU   *-LINKSFL                                           LDW2\nLENG     DS    F                        LEN OF VARIABLE DATA RETURNED\nQPRM0    DS    F       F'-1'            ***\nQPRM1    DS    A       TLD ADDR         *\nQPRM2    DS    A       V(ISPLINK)       * KEEP THESE RECORDS TOGETHER\nQPRM3    DS    A       A(QPPL)          ***\nQCPPL    DS    ((CPPLLEN+3)/4)F         CPPL SPACE\nVCALLST  DS    5F                       CPPL PARM LIST\nQNAME    DS    CL8                      ADDRESS OF Q LOAD MODULE NAME\n         DS    0F\nISRCBUF  DS    CL80                     FAKE COMMAND BUFFER\nSYMNODEL DSECT ,                        RESTORE SYM CARD GENERATION\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "OACFSORT": {"ttr": 1539, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "         MACRO\n&LABEL   OACFSORT &DSECT=YES,&PREFIX=FS#\n.* OAC FIXED RECORD SORT ROUTINE PARAMETER LIST (INCORE SORT)\n.*\n.*  NOTE THAT THE WORK AREA MUST BE LONG ENOUGH TO INCLUDE\n.*       ONE RECORD PLUS SORT WORKING STORAGE. (STACK)\n.*\n.*---------------------------------------------------------------------\n.*\n.*  FSORT - FIXED LENGTH RECORD SORT (IN STORAGE)\n.*\n.* ENTRY: R1 = @ P# LIST\n.*\n.* EXIT: R15 = RETURN CODE (CC SET)\n.*              0 - RECORDS SORTED (INPLACE)\n.*              4 - WORK AREA TOO SMALL\n.*\n.* THE WORK AREA LENGTH IS:\n.*  W#L + LENGTH OF ONE RECORD + STACK SPACE\n.*\n.*    COMPARE ROUTINE CALLED WITH:  R15 - ENTRY POINT\n.*                                  R14 - RETURN ADDRESS\n.*                                  R13 - @ 72 BYTE SAVE AREA\n.*                                  R1  - @ ELEMENT\n.*                                  R2  - @ ELEMENT\n.*                                  R3  - COMPARE ROUTINE PARM\n.*\n.* CONDITION CODE RETURNED FROM COMPARE ROUTINE DETERMINES ORDER,\n.*   IF HIGH THEN ELEMENT (R1) WILL APPEAR AFTER (R2),\n.*   IF LOW  THEN ELEMENT (R1) WILL APPEAR BEFORE (R2),\n.*   ELSE ORDER OF RECORDS IS UNDEFINED.\n.*\n.*  THE COMPARE ROUTINE MUST RESTORE *ALL* THE REGISTERS R0-R15.\n.*\n.*---------------------------------------------------------------------\n         LCLC  &LAB,&P\n&P       SETC  '&PREFIX'(1,3)     SET MAX PREFIX\n&LAB     SETC  '&P'               SET DEFAULT LABEL\n         AIF   ('&LABEL' EQ '').CK#DS BIF NO USER LABEL\n&LAB     SETC  '&LABEL'           SET USER'S LABEL\n.CK#DS   AIF   ('&DSECT' EQ 'YES').DSECT BIF DSECT GENERATION\n&LAB     DC    0D'0'              OACFSORT PARAMETER LIST\n         AGO   .GEN               BIF TO GENERATE DATA\n.DSECT   ANOP                     GENERATE DSECT HERE\n&LAB     DSECT ,                  OACFSORT PARAMETER LIST\n.GEN     ANOP\n&P.RECPT DC    A(0)               @ OF RECORDS\n&P.RECLN DC    F'0'               LENGTH OF EACH RECORD  (> 0)\n&P.RECNM DC    F'0'               NUMBER OF RECORDS      (>= 0)\n&P.CMPEP DC    A(0)               @ OF COMPARE ROUTINE\n&P.CMPPM DC    A(0)               PARM FOR COMPARE ROUTINE\n&P.WRKPT DC    A(0)               @ OF WORK AREA\n&P.WRKLN DC    F'0'               LENGTH OF WORK AREA    (>= 256)\n&P.L     EQU   *-&LAB             LENGTH OF PARAMETER LIST\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "OACFSRT": {"ttr": 1541, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x87&\\x0f\\x00\\x87&\\x0f\\x00\\x18\\x01\\x1d\\x01\\x1d\\x00\\x00\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-09-17T00:00:00", "modifydate": "1987-09-17T00:18:00", "lines": 285, "newlines": 285, "modlines": 0, "user": "LDW"}, "text": "Received: (from CSYSMAS@UCLAMVS for LDW@USCMVSA via NJE)\n         (CSYSMAS-9819;     290 LINES); Fri, 17 Apr 87 23:50:48 PDT\nDate:    Fri, 17 Apr 87 23:50 PDT\nTo:      LDW\nFrom:    CSYSMAS@UCLAMVS\n\nComment: converted from NETDATA format at USCMVSA\nYou need the OACFSORT macro from MSSMAC too... (+ MSS mac for asm)\n//CSYSMASP JOB NAS,MSGCLASS=A,COND=(0,NE),TIME=(,5)\n/*ROUTE PRINT WYLBUR\n//ASM EXEC ASMHCL\n//ASM.SYSLIB DD\n//           DD\n//           DD DISP=SHR,DSN=SYS5.MSSMAC\n//ASM.SYSIN    DD *\nOACFSORT CSECT ,\n*---------------------------------------------------------------------*\n*                                                                     *\n*   FSORT - FIXED LENGTH RECORD SORT (IN STORAGE)                     *\n*                                                                     *\n* ENTRY: R1 = @ P# LIST                                               *\n*                                                                     *\n* EXIT:  R15 = RETURN CODE (CC SET)                                   *\n*               0 - RECORDS SORTED (INPLACE)                          *\n*               4 - WORK AREA TOO SMALL                               *\n*                                                                     *\n*  THE WORK AREA LENGTH IS:                                           *\n*   W#L + LENGTH OF ONE RECORD + STACK SPACE                          *\n*                                                                     *\n*     COMPARE ROUTINE CALLED WITH:  R15 - ENTRY POINT                 *\n*                                   R14 - RETURN ADDRESS              *\n*                                   R13 - @ 72 BYTE SAVE AREA         *\n*                                   R1  - @ ELEMENT                   *\n*                                   R2  - @ ELEMENT                   *\n*                                   R3  - COMPARE ROUTINE PARM        *\n*                                                                     *\n*  CONDITION CODE RETURNED FROM COMPARE ROUTINE DETERMINES ORDER,     *\n*    IF HIGH THEN ELEMENT (R1) WILL APPEAR AFTER (R2),                *\n*    IF LOW  THEN ELEMENT (R1) WILL APPEAR BEFORE (R2),               *\n*    ELSE ORDER OF RECORDS IS UNDEFINED.                              *\n*                                                                     *\n*   THE COMPARE ROUTINE MUST RESTORE *ALL* THE REGISTERS R0-R15.      *\n*                                                                     *\n*   OACFSORT CURRENTLY USES PARTITION EXCHANGE.                       *\n*                                                                     *\n*   NOTE THAT THE RECORDS OUTSIDE OF THE AREA TO SORT ARE *NOT*       *\n*   REFERENCED AT ALL.                                                *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 1\n         OACFSORT PREFIX=P#\n         SPACE 1\nW#       DSECT ,\nW#SAVE   DC    18F'0'\nW#STKPT  DC    A(0)               @ STACK\nW#STKLM  DC    A(0)               STACK LIMIT PTR\nW#RECLS  DC    A(0)               @ LAST RECORD IN RECORD AREA\nW#REC    DC    0D'0'              TEMP RECORD AREA\nW#L      EQU   *-W#               MINIMUM WORK LENGTH\n         EJECT ,\nOACFSORT CSECT ,\n         STM   R14,R12,12(R13)\n         LR    R12,R15\n         OACUSING OACFSORT,R12\n         LR    R11,R1\n         OACUSING P#,R11\n         SPACE 1\n         L     R8,P#RECLN         RECORD LENGTH\n         LM    R1,R2,P#WRKPT      ADDR, LENGTH OF WORK AREA\n         LA    R0,W#L+4*8(R8)     W# LEN + RECORD LEN + ALIGN/MIN STACK\n         CR    R2,R0              WORK AREA TOO SHORT?\n         BL    ERR1               BIF WORK AREA TOO SHORT\n         ST    R13,4(,R1)\n         ST    R1,8(,R13)\n         LR    R13,R1\n         OACUSING W#,R13\n         LA    R0,0(R1,R2)        @ PAST END OF W# AREA SUPPLIED\n         SH    R0,=Y(8+7)         ALLOW 1 ENTRY + ALIGN FOR STACK\n         ST    R0,W#STKLM         INIT STACK LIMIT PTR\n         SPACE 1\n         L     R5,P#RECNM         NUMBER OF RECORDS\n         MR    R4,R8              # RECORDS * LENGTH RECORD\n         L     R2,P#RECPT         @ 1ST RECORD            (A)\n         LA    R5,0(R2,R5)        @ PAST LAST RECORD\n         SR    R5,R8              @ LAST RECORD           (B)\n         ST    R5,W#RECLS         SAVE @ LAST RECORD\n         SPACE 1\n         L     R3,P#CMPPM         PARM FOR COMPARE ROUTINE\n         L     R10,P#CMPEP        @ OF COMPARE ROUTINE\n         LA    R9,7(,R8)          RECORD LENGTH + 7\n         N     R9,=X'00FFFFF8'    RECORD LEN ROUNDED UP TO MUL OF 8\n         LA    R9,W#REC(R9)       @ OF START OF STACK\n         ST    R9,W#STKPT         SAVE @ OF STACK\n         EJECT ,\n*---------------------------------------------------------------------*\n*                                                                     *\n*  REGISTER USAGE --                                                  *\n* R0  - WORK                                                          *\n* R1  - @ RECORD (FOR COMPARE ROUTINE)  / WORK                        *\n* R2  - A   (@ LEFTMOST RECORD IN CURRENT GROUP)                      *\n* R3  - COMPARE ROUTINE PARM            / WORK                        *\n* R4  -                                                               *\n* R5  - B   (@ RIGHTMOST RECORD IN CURRENT GROUP)                     *\n* R6  - I   (LEFT TO RIGHT SCAN PTR)                                  *\n* R7  - J   (RIGHT TO LEFT SCAN PTR)                                  *\n* R8  - RECORD LENGTH                                                 *\n* R9  - STACK POINTER                                                 *\n* R10 - @ COMPARE ROUTINE                                             *\n* R11 - @ P#                                                          *\n* R12 - PGM BASE                                                      *\n* R13 - @ W#                                                          *\n* R14 - WORK                                                          *\n* R15 - WORK                                                          *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 1\n* CHECK FOR ONLY ONE RECORD TO SORT\nSORT     CR    R2,R5              A :: B\n         BNL   SORTUS             BIF A >= B (ONLY ONE RECORD)\n* I = A\n         LR    R6,R2              I = A\n* J = B + RECLN (@ PAST LAST RECORD IN GROUP)\n         LR    R7,R5              B\n         AR    R7,R8              + RECLN\n* PICK MEDIAN RECORD HERE AND SWAP WITH K(A)\n* SO THAT ORDERED INPUT IS NOT WORST CASE...\n*             (((B - A)/RECLN)/2)*RECLN\n         LR    R1,R5              B\n         SR    R1,R2              B - A\n         SR    R0,R0\n         DR    R0,R8              B-A/RECLN\n         SRL   R1,1               HALF THE RECORDS\n         CH    R1,=H'4'           < 4 RECORDS\n         BL    SORTL1             BIF < 4 RECORDS; SKIP MID SWAP\n         MR    R0,R8              OFFSET OF THE RECORD\n         AR    R1,R2              @ OF K(MID)\n         LR    R4,R1              SAVE @ K(MID)\n* SWAP K(A) & K(MID)\n         LR    R0,R4              @ K(MID)                (SOURCE)\n         LR    R1,R8              RECLN\n         LA    R14,W#REC          @ TEMP RECORD AREA      (TARGET)\n         LR    R15,R8             RECLN\n         MVCL  R14,R0             K(MID) TO TEMP AREA\n         LR    R0,R2              @ K(A)                  (SOURCE)\n         LR    R1,R8              RECLN\n         LR    R14,R4             @ K(MID)                (TARGET)\n         LR    R15,R8             RECLN\n         MVCL  R14,R0             K(A) TO K(MID)\n         LA    R0,W#REC           @ TEMP RECORD AREA      (SOURCE)\n         LR    R1,R8              RECLN\n         LR    R14,R2             @ K(A)                  (TARGET)\n         LR    R15,R8             RECLN\n         MVCL  R14,R0             K(MID) TO K(A) FROM TEMP AREA\n* FIND K(I) > K(A)\nSORTL1   AR    R6,R8              I = I + RECLN\n         CR    R6,R7              I :: J\n         BNL   SORTF              BIF I >= J\n         LR    R1,R6              K(I)\n         LR    R15,R10            @ COMPARE ROUTINE\n         BALR  R14,R15            COMPARE K(I) :: K(A)  <R2>\n         BNH   SORTL1             BIF K(I) <= K(A)\n         SPACE 1\n* FIND K(J) <= K(A)\nSORTL2   SR    R7,R8              J = J - RECLN\n         CR    R7,R6              J :: I\n         BNH   SORTF              BIF J <= I\n         LR    R1,R7              K(J)\n         LR    R15,R10            @ COMPARE ROUTINE\n         BALR  R14,R15            COMPARE K(J) :: K(A)  <R2>\n         BH    SORTL2             BIF K(J) > K(A)\n* HAVE K(I) > K(A) & K(J) <= K(A)\n* ALSO I < J SO ARE DIFFERENT RECORDS\n* SWAP K(I) AND K(J)\n         LR    R0,R6              @ K(I)                  (SOURCE)\n         LR    R1,R8              RECLN\n         LA    R14,W#REC          @ TEMP RECORD AREA      (TARGET)\n         LR    R15,R8             RECLN\n         MVCL  R14,R0             K(I) TO TEMP AREA\n         LR    R0,R7              @ K(J)                  (SOURCE)\n         LR    R1,R8              RECLN\n         LR    R14,R6             @ K(I)                  (TARGET)\n         LR    R15,R8             RECLN\n         MVCL  R14,R0             K(J) TO K(I)\n         LA    R0,W#REC           @ TEMP RECORD AREA      (SOURCE)\n         LR    R1,R8              RECLN\n         LR    R14,R7             @ K(J)                  (TARGET)\n         LR    R15,R8             RECLN\n         MVCL  R14,R0             K(I) TO K(J) FROM TEMP AREA\n         B     SORTL1              AND CONTINUE\n         SPACE 1\n* UNABLE TO FIND K(I) > K(A) AND K(J) <= K(A) FOR I < J\n*     (I = J HERE AND I = J MAY BE > B)\n* SO SWAP K(A) WITH K(J-1)\nSORTF    LR    R4,R7              @ K(J)\n         SR    R4,R8              @ K(J-1)\n         LR    R0,R4              @ K(J-1)                (SOURCE)\n         LR    R1,R8              RECLN\n         LA    R14,W#REC          @ TEMP RECORD AREA      (TARGET)\n         LR    R15,R8             RECLN\n         MVCL  R14,R0             K(J-1) TO TEMP AREA\n         LR    R0,R2              @ K(A)                  (SOURCE)\n         LR    R1,R8              RECLN\n         LR    R14,R4             @ K(J-1)                (TARGET)\n         LR    R15,R8             RECLN\n         MVCL  R14,R0             K(A) TO K(J-1)\n         LA    R0,W#REC           @ TEMP RECORD AREA      (SOURCE)\n         LR    R1,R8              RECLN\n         LR    R14,R2             @ K(A)                  (TARGET)\n         LR    R15,R8             RECLN\n         MVCL  R14,R0             K(J-1) TO K(A) FROM TEMP AREA\n* NOW SORT (A, J-2) AND (J, B)\n*          (R2, R4-R8) AND (R7, R5)\n*  (SOME MIGHT BE NULL - SORT SHORTEST FIRST, STACK OTHER)\n         SR    R4,R8              END ADDR OF GRP 1\n         LR    R0,R4\n         SR    R0,R2              LENGTH OF GRP 1\n         LR    R1,R5\n         SR    R1,R7              LENGTH OF GRP 2\n         CR    R0,R1              COMPARE GRP LENGTHS\n         BH    SORTGRP            BIF GRP 1 > GRP 2 (DO GRP 2 FIRST)\n         XR    R2,R7              SWAP GRP'S 1 AND 2\n         XR    R7,R2\n         XR    R2,R7\n         XR    R4,R5\n         XR    R5,R4\n         XR    R4,R5\n* STACK GROUP 1 TO BE SORTED LATER\nSORTGRP  C     R9,W#STKLM         ROOM FOR ANOTHER STACK ENTRY\n         BH    ERR2               BIF WORKAREA TOO SMALL\n         ST    R2,0(,R9)          @ 1ST RECORD IN GROUP\n         ST    R4,4(,R9)          @ LAST RECORD IN GROUP\n         LA    R9,8(,R9)          PUSH STACK\n* SET UP TO SORT GROUP 2 NOW\n         LR    R2,R7              @ 1ST REC IN GRP 2 (R5 ALREADY SET)\n         B     SORT\n         SPACE 1\n* REMOVE STACK ENTRY\nSORTUS   SH    R9,=H'8'\n         C     R9,W#STKPT\n         BL    SRTCK              BIF STACK EMPTY; DONE\n         L     R2,0(,R9)          @ 1ST RECORD OF GROUP\n         L     R5,4(,R9)            @ LAST RECORD IN GROUP\n         B     SORT\n         EJECT ,\n*---------------------------------------------------------------------*\n*                                                                     *\n*  SRTCK -- CHECK THAT RESULTS IS ACTUALLY SORTED.                    *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 1\nSRTCK    L     R2,P#RECPT         @ 1ST RECORD\n         L     R5,W#RECLS         @ LAST RECORD\n         SR    R2,R8              @ RECORD - 1\nSRTCKL   AR    R2,R8              @ NEXT RECORD\n         LR    R1,R2\n         AR    R1,R8              @ NEXT RECORD (IF ANY)\n         CR    R1,R5              ANY NEXT RECORD?\n         BH    RET0               BIF NO NEXT; ALL DONE\n         LR    R15,R10            @ COMPARE ROUTINE\n         BALR  R14,R15            COMPARE TWO RECORDS; CHECK SEQ\n         BNL   SRTCKL             BIF NOT SEQ ERROR\n         EX    0,*      *** SORT LOGIC ERROR ***\n         SPACE 1\nRET0     SR    R15,R15            RETURN CODE ZERO\nRET      L     R13,4(,R13)\nRETX     L     R14,12(,R13)\n         LM    R0,R12,12+8(R13)\n         LTR   R15,R15\n         BR    R14\n         SPACE 1\nERR1     LA    R15,4              RETURN CODE 4; WRKAREA TOO SMALL\n         B     RETX\nERR2     LA    R15,4              RETURN CODE 4; WRKAREA TOO SMALL\n         B     RET\n         SPACE 1\n         DC    0D'0'\n         LTORG ,\n         OACREGS ,\n         END\n//LKED.SYSLMOD DD DISP=SHR,DSN=SYS5.MSSLOAD,UNIT=,SPACE=\n//LKED.SYSIN   DD *\n    ENTRY OACFSORT\n    IDENTIFY OACFSORT('CS01462')\n    NAME OACFSORT(R)\n//\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "Q$BUFFER": {"ttr": 1547, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x84\"\\x0f\\x00\\x87\\x15o\\x158\\x00\"\\x00\\x0f\\x00\\x13\\xc5\\xd4\\xe2@@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1984-08-07T00:00:00", "modifydate": "1987-06-05T15:38:00", "lines": 34, "newlines": 15, "modlines": 19, "user": "EMS"}, "text": "         MACRO\n         Q$BUFFER\n.*--------------------------------------------------------------------*\n.*                                                                    *\n.*  Updates:                                                          *\n.*      5Jun87  EMS  fix for base level JES2                          *\n.*     16Jan87  LDW  SP136 changes:  EQUate BUFDSECT to BFPDSECT      *\n.*                      for prior level;  fake IFGRTL                 *\n.*                                                                    *\n.*--------------------------------------------------------------------*\n.*\n         GBLA  &QLEVEL\n         GBLB  &Q$BUFFR\n         GBLC  &QSECT                   NAME OF CURRENT ROUTINE\n.*\n&QSECT   CSECT                          RESUME FOR STUPID HASP MACROS\n.*\n         AIF   (&Q$BUFFR).MEND          IGNORE IF ALREADY GENERATED\n         AIF   (&QLEVEL LT 7).NODSECT\nIFGRPL   DSECT                          HAH!  FOOLED YOU TURKEYS AT IBM\n.NODSECT ANOP  ,\n*        $BUFFER\n         $BUFFER\n         AIF   (&QLEVEL GE 7).NEWNAME\nBFPDSECT EQU   BUFDSECT                 ALLOW USE OF NEW NAME WITH\n*                                          PRIOR JES2 LEVEL\n         AGO   .OLDNAME                 * TEMP *\n.NEWNAME ANOP\nBUFDSECT EQU   BFPDSECT                 * TEMP *\n.OLDNAME ANOP                           * TEMP *\n         SPACE 6\n&Q$BUFFR SETB 1                         SET \"ALREADY GENERATED\" FLAG\n.*\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "Q$CHK": {"ttr": 1549, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x85(?\\x00\\x892\\x7f\\x15\"\\x00\\x1a\\x00\\x11\\x00\\x0b\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1985-10-10T00:00:00", "modifydate": "1989-11-23T15:22:00", "lines": 26, "newlines": 17, "modlines": 11, "user": "LDW"}, "text": "         MACRO\n         Q$CHK\n.*--------------------------------------------------------------------*\n.*                                                                    *\n.*  Updates:                                                          *\n.*     23Nov89  LDW  Don't expand if &QLEVEL < 5                      *\n.*                                                                    *\n.*--------------------------------------------------------------------*\n.*\n         GBLA  &QLEVEL\n         GBLB  &$Q$CHK\n         GBLC  &QSECT                   NAME OF CURRENT ROUTINE\n.*\n&QSECT   CSECT                          RESUME FOR STUPID HASP MACROS\n.*\n         AIF   (&$Q$CHK).MEND           IGNORE IF ALREADY GENERATED\n&$Q$CHK  SETB  1                        SET \"ALREADY GENERATED\" FLAG\n         AIF   (&QLEVEL LT 5).BYPASS\n         SPACE 2\n*        $CHK\n         $CHK\n         SPACE 6\n.*\n         MEXIT\n.BYPASS  MNOTE *,'$CHK bypassed for this level of JES2.'\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "Q$DAS": {"ttr": 1551, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x84\\x15\\x7f\\x00\\x892\\x7f\\x14C\\x00\"\\x00\\x0f\\x00\\x14\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1984-06-05T00:00:00", "modifydate": "1989-11-23T14:43:00", "lines": 34, "newlines": 15, "modlines": 20, "user": "LDW"}, "text": "         MACRO\n         Q$DAS\n.*--------------------------------------------------------------------*\n.*                                                                    *\n.*  Updates:                                                          *\n.*     23Nov89  LDW  Don't expand if &QLEVEL < 5                      *\n.*     14DEC86  LDW  SP136 CHANGES:  EQUATE DASDSECT TO DAS FOR       *\n.*                      PRIOR LEVEL                                   *\n.*                                                                    *\n.*--------------------------------------------------------------------*\n.*\n         GBLA  &QLEVEL\n         GBLB  &$Q$DAS\n         GBLC  &QSECT                   NAME OF CURRENT ROUTINE\n.*\n&QSECT   CSECT                          RESUME FOR STUPID HASP MACROS\n.*\n         AIF   (&$Q$DAS).MEND           IGNORE IF ALREADY GENERATED\n&$Q$DAS  SETB  1                        SET \"ALREADY GENERATED\" FLAG\n         AIF   (&QLEVEL LT 5).BYPASS\n*        $DAS\n         $DAS\n         AIF   (&QLEVEL GE 7).NEWNAME\nDAS      EQU   DASDSECT                 ALLOW USE OF NEW NAME WITH\n*                                          PRIOR JES2 LEVEL\n         AGO   .OLDNAME                 * TEMP *\n.NEWNAME ANOP\nDASDSECT EQU   DAS                      * TEMP *\n.OLDNAME ANOP                           * TEMP *\n         SPACE 6\n.*\n         MEXIT\n.BYPASS  MNOTE *,'$DAS bypassed for this level of JES2.'\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "Q$DCT": {"ttr": 1553, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x00\\x00\\x83\\x00O\\x00\\x892\\x7f!\\x04\\x00\\x1a\\x00\\x0f\\x00\\x0c\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1983-01-04T00:00:00", "modifydate": "1989-11-23T21:04:00", "lines": 26, "newlines": 15, "modlines": 12, "user": "LDW"}, "text": "         MACRO\n         Q$DCT\n.*--------------------------------------------------------------------*\n.*                                                                    *\n.*  Updates:                                                          *\n.*     23Nov89  LDW  Invoke Q$XECB                                    *\n.*     21Feb87  LDW  $MAXPRDV equate moved to QHASPEQU                *\n.*     06/05/84 LDW  KLUDGE SP133 SUPPORT                             *\n.*     04/10/84 LDW  ADD SP133 SUPPORT                                *\n.*                                                                    *\n.*--------------------------------------------------------------------*\n.*\n         GBLB  &$Q$DCT\n         GBLC  &QSECT                   NAME OF CURRENT ROUTINE\n.*\n&QSECT   CSECT                          RESUME FOR STUPID HASP MACROS\n.*\n         AIF   (&$Q$DCT).MEND           IGNORE IF ALREADY GENERATED\n*        Q$XECB\n         Q$XECB\n*        $DCT\n         $DCT\n         SPACE 6\n&$Q$DCT  SETB  1                        SET \"ALREADY GENERATED\" FLAG\n.*\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "Q$HASB": {"ttr": 1555, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x89\\x14?\\x00\\x892\\x7f\\x15!\\x00\\x18\\x00\\x14\\x00\\x07\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1989-05-23T00:00:00", "modifydate": "1989-11-23T15:21:00", "lines": 24, "newlines": 20, "modlines": 7, "user": "LDW"}, "text": "         MACRO\n         Q$HASB\n.*--------------------------------------------------------------------*\n.*                                                                    *\n.*  Updates:                                                          *\n.*     23Nov89  LDW  Don't expand if &QLEVEL < 9                      *\n.*                                                                    *\n.*--------------------------------------------------------------------*\n.*\n         GBLA  &QLEVEL\n         GBLB  &$Q$HASB\n         GBLC  &QSECT                   NAME OF CURRENT ROUTINE\n.*\n&QSECT   CSECT                          RESUME FOR STUPID HASP MACROS\n.*\n         AIF   (&$Q$HASB).MEND          IGNORE IF ALREADY GENERATED\n&$Q$HASB SETB  1                        SET \"ALREADY GENERATED\" FLAG\n         AIF   (&QLEVEL LT 9).BYPASS\n         $HASB\n         SPACE 6\n.*\n         MEXIT\n.BYPASS  MNOTE *,'$HASB bypassed for this level of JES2.'\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "Q$HCCT": {"ttr": 1793, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x89\\x08\\x1f\\x00\\x91\\x03\\x1f\\x166\\x002\\x00\\x14\\x00\\r\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1989-03-22T00:00:00", "modifydate": "1991-01-31T16:36:00", "lines": 50, "newlines": 20, "modlines": 13, "user": "LDW"}, "text": "         MACRO\n         Q$HCCT\n.*--------------------------------------------------------------------*\n.*                                                                    *\n.*  Updates:                                                          *\n.*     31Jan91  LDW  Remove $IOTRBGN and $IOTRLMT EQU's per GLA       *\n.*                      since QHASPEQU now includes real $HASPEQU     *\n.*     23Nov89  LDW  Don't expand if &QLEVEL < 9                      *\n.*                                                                    *\n.*--------------------------------------------------------------------*\n.*\n         GBLA  &QLEVEL\n         GBLB  &$Q$HCCT\n         GBLC  &QSECT                   NAME OF CURRENT ROUTINE\n.*\n&QSECT   CSECT                          RESUME FOR STUPID HASP MACROS\n.*\n         AIF   (&$Q$HCCT).MEND          IGNORE IF ALREADY GENERATED\n&$Q$HCCT SETB  1                        SET \"ALREADY GENERATED\" FLAG\n         AIF   (&QLEVEL LT 9).BYPASS\n*        Q$HFAME\n         Q$HFAME\n*        Q$XECB\n         Q$XECB\n*        $HCCT\n         $HCCT\n         SPACE 2\n*  Allow use of new names with prior JES2 levels\n*  to perpetuate this abortion even further (who gets sicker fastest)\nSVTBFSIZ EQU   CCTBFSIZ,L'CCTBFSIZ      * TEMP *\nSVTCOMCH EQU   CCTCOMCH,L'CCTCOMCH      * TEMP *\nSVTDEB   EQU   CCTDEB,L'CCTDEB          * TEMP *\nSVTHAVT  EQU   CCTHAVT,L'CCTHAVT        * TEMP *\nSVTPIT   EQU   CCTPIT,L'CCTPIT          * TEMP *\nSVTRDT   EQU   CCTRDT,L'CCTRDT          * TEMP *\nSVTSID   EQU   CCTSID,L'CCTSID          * TEMP *\nSVTTONOD EQU   CCTTONOD,L'CCTTONOD      * TEMP *\n$SVBFSIZ EQU   CCTBFSIZ,L'CCTBFSIZ      * TEMP *\n$SVCOMCH EQU   CCTCOMCH,L'CCTCOMCH      * TEMP *\n$SVDEB   EQU   CCTDEB,L'CCTDEB          * TEMP *\n$SVHAVT  EQU   CCTHAVT,L'CCTHAVT        * TEMP *\n$SVPIT   EQU   CCTPIT,L'CCTPIT          * TEMP *\n$SVRDT   EQU   CCTRDT,L'CCTRDT          * TEMP *\n$SVSID   EQU   CCTSID,L'CCTSID          * TEMP *\n$SVTONOD EQU   CCTTONOD,L'CCTTONOD      * TEMP *\n         SPACE 6\n.*\n         MEXIT\n.BYPASS  MNOTE *,'$HCCT bypassed for this level of JES2.'\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "Q$HCT": {"ttr": 1795, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x15\\x00\\x00\\x00\\x82#/\\x00\\x91\\x17\\x9f\\x00\\x11\\x00O\\x00\\x1b\\x00?\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "05.21", "flags": 0, "createdate": "1982-08-20T00:00:00", "modifydate": "1991-06-28T00:11:00", "lines": 79, "newlines": 27, "modlines": 63, "user": "LDW"}, "text": "         MACRO\n         Q$HCT\n.*--------------------------------------------------------------------*\n.*                                                                    *\n.*  Updates:                                                          *\n.*     28Jun91  LDW  Add Q$XECB for 313                               *\n.*     28Nov90  EMS  SP410 changes: Q$LMT                             *\n.*     22Mar89  EMS  SP311 changes: &UVERS                            *\n.*     26Jun88  LDW  Remove condition logic for Q$PADDR (now done in  *\n.*                      Q$PADDR)                                      *\n.*     31Jan88  LDW  SP220 changes:  Q$PADDR                          *\n.*     21Feb87  LDW  Move misc equates to QHASPEQU                    *\n.*     16Jan87  LDW  Skip some equates if already done in Q$xxx       *\n.*     10JAN87  LDW  SP136 NEEDS DIFFERENT $MAXDA EQUATE              *\n.*     04JAN87  LDW  SP136 CHANGES:  MORE FAKE SYMBOL EQUATES         *\n.*     14DEC86  LDW  SP136 CHANGES:  EQUATE HCTDSECT TO HCT FOR       *\n.*                      PRIOR LEVEL; SET &SYSSPLV, DEFINE $DRTOTAL,   *\n.*                      $JOEDEF                                       *\n.*     11JUL86  LDW  DEFINE $X97INIT                                  *\n.*     22JUN86  LDW  DEFINE $MAXNODE                                  *\n.*     02/21/86 LDW  INVOKE Q$MIT IF SP133                            *\n.*     08/02/84 LDW  SP134 SUPPORT                                    *\n.*     06/05/84 LDW  KLUDGE SP133 SUPPORT                             *\n.*     04/10/84 LDW  ADD SP133 SUPPORT                                *\n.*     01/04/83 LDW  ADD SP & NJE COMPATIBILITY                       *\n.*                                                                    *\n.*--------------------------------------------------------------------*\n.*\n         GBLA  &QLEVEL\n         GBLB  &$Q$HCT,&$Q$DCT,&$Q$IOT,&$Q$JCT,&$Q$JOT,&$Q$SVT\n         GBLC  &QSECT                   NAME OF CURRENT ROUTINE\n.*\n&QSECT   CSECT                          RESUME FOR STUPID HASP MACROS\n.*\n         AIF   (&$Q$HCT).MEND           IGNORE IF ALREADY GENERATED\n         GBLC  &VERSION\n&VERSION SETC  '0'\n         GBLC  &MACSPLV\n&MACSPLV SETC  '1'                      %%%%%%%%%\n         GBLC  &UVERS                   user version\n&UVERS   SETC  '0'\n         AIF   (&QLEVEL LT 4).NOJQE\n         SPACE 2\n*        Q$JQE                          NEEDED FOR SP\n         Q$JQE\n         SPACE 2\n*        Q$PCE                          NEEDED FOR SP\n         Q$PCE\n*        Q$MIT                          NEEDED FOR SP133\n         Q$MIT\n*        Q$PADDR                        NEEDED FOR SP220\n         Q$PADDR\n*        Q$XECB                         NEEDED FOR SP313\n         Q$XECB\n         AIF   (&QLEVEL LT 11).NOJQE\n*        Q$LMT                          NEEDED FOR SP410\n         Q$LMT\nPDS2BLEN EQU   2                        fake it for a while???\n.NOJQE   SPACE 2\n*        $HCT\n         $HCT\n         AIF   (&QLEVEL GE 7).NEWNAME\nHCT      EQU   HCTDSECT                 ALLOW USE OF NEW NAME WITH\n*                                          PRIOR JES2 LEVEL\n$QSEMAX  EQU   $QSENO                   ALLOW USE OF NEW NAME WITH\n*                                          PRIOR JES2 LEVEL\n         AGO   .OLDNAME                 * TEMP *\n.NEWNAME ANOP\nHCTDSECT EQU   HCT                      * TEMP *\n$QSENO   EQU   $QSEMAX                  * TEMP *\n.OLDNAME ANOP                           * TEMP *\n         AIF   (&QLEVEL GE 4).OK\n         SPACE 1\n$JQHEADL EQU   2                        ALLOW USE OF NEW SYMBOL WITH\n*                                       OLD (NON-SP) JES2\n.OK      SPACE 6\n&$Q$HCT  SETB  1                        SET \"ALREADY GENERATED\" FLAG\n.*\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "Q$HDP": {"ttr": 1798, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x03O\\x00\\x90\\x05\\x7f\\x12\\x00\\x00\\x1a\\x00\\x0f\\x00\\x0c\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-02-03T00:00:00", "modifydate": "1990-02-26T12:00:00", "lines": 26, "newlines": 15, "modlines": 12, "user": "LDW"}, "text": "         MACRO\n         Q$HDP\n.*--------------------------------------------------------------------*\n.*                                                                    *\n.*  Updates:                                                          *\n.*     26Feb90  LDW  Change to expand if &QLEVEL=7 (1.3.6) per Doron  *\n.*     23Nov89  LDW  Don't expand if &QLEVEL < 8                      *\n.*                                                                    *\n.*--------------------------------------------------------------------*\n.*\n         GBLA  &QLEVEL\n         GBLB  &$Q$HDP\n         GBLC  &QSECT                   NAME OF CURRENT ROUTINE\n.*\n&QSECT   CSECT                          RESUME FOR STUPID HASP MACROS\n.*\n         AIF   (&$Q$HDP).MEND           IGNORE IF ALREADY GENERATED\n&$Q$HDP  SETB  1                        SET \"ALREADY GENERATED\" FLAG\n         AIF   (&QLEVEL LT 7).BYPASS\n*        $HDP\n         $HDP\n         SPACE 6\n.*\n         MEXIT\n.BYPASS  MNOTE *,'$HDP bypassed for this level of JES2.'\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "Q$HFAME": {"ttr": 1800, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x88\\x03\\x1f\\x00\\x892\\x7f\\x14\\x03\\x00\\x19\\x00\\x0f\\x00\\x0b\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1988-01-31T00:00:00", "modifydate": "1989-11-23T14:03:00", "lines": 25, "newlines": 15, "modlines": 11, "user": "LDW"}, "text": "         MACRO\n         Q$HFAME\n.*--------------------------------------------------------------------*\n.*                                                                    *\n.*  Updates:                                                          *\n.*     23Nov89  LDW  Standardize skipping expansion based on QLEVEL   *\n.*                                                                    *\n.*--------------------------------------------------------------------*\n.*\n         GBLA  &QLEVEL\n         GBLB  &$Q$HFAM\n         GBLC  &QSECT                   NAME OF CURRENT ROUTINE\n.*\n&QSECT   CSECT                          RESUME FOR STUPID HASP MACROS\n.*\n         AIF   (&$Q$HFAM).MEND          IGNORE IF ALREADY GENERATED\n&$Q$HFAM SETB  1                        SET \"ALREADY GENERATED\" FLAG\n         AIF   (&QLEVEL LT 8).BYPASS\n*        $HFAME\n         $HFAME\n         SPACE 6\n.*\n         MEXIT\n.BYPASS  MNOTE *,'$HFAME bypassed for this level of JES2.'\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "Q$HQR": {"ttr": 1802, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x82$/\\x00\\x892\\x7f\\x15\\x19\\x00\\x19\\x00\\x0f\\x00\\x0b\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1982-08-30T00:00:00", "modifydate": "1989-11-23T15:19:00", "lines": 25, "newlines": 15, "modlines": 11, "user": "LDW"}, "text": "         MACRO\n         Q$HQR\n.*--------------------------------------------------------------------*\n.*                                                                    *\n.*  Updates:                                                          *\n.*     23Nov89  LDW  Don't expand if &QLEVEL > 3                      *\n.*                                                                    *\n.*--------------------------------------------------------------------*\n.*\n         GBLA  &QLEVEL\n         GBLB  &$Q$HQR\n         GBLC  &QSECT                   NAME OF CURRENT ROUTINE\n.*\n&QSECT   CSECT                          RESUME FOR STUPID HASP MACROS\n.*\n         AIF   (&$Q$HQR).MEND           IGNORE IF ALREADY GENERATED\n&$Q$HQR  SETB  1                        SET \"ALREADY GENERATED\" FLAG\n         AIF   (&QLEVEL GT 3).BYPASS\n*        $HQR\n         $HQR\n         SPACE 6\n         MEXIT\n.BYPASS  MNOTE *,'$HQR bypassed for this level of JES2.'\n.*\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "Q$HQT": {"ttr": 1804, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x82$/\\x00\\x892\\x7f\\x15 \\x00\\x1c\\x00\\x0f\\x00\\x0e\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1982-08-30T00:00:00", "modifydate": "1989-11-23T15:20:00", "lines": 28, "newlines": 15, "modlines": 14, "user": "LDW"}, "text": "         MACRO\n         Q$HQT\n.*--------------------------------------------------------------------*\n.*                                                                    *\n.*  Updates:                                                          *\n.*     23Nov89  LDW  Don't expand if &QLEVEL > 3                      *\n.*     08/07/84 LDW  USE Q$BUFFER TO GENERATE BUFSTART & BUFDSECT     *\n.*                      EQUATES                                       *\n.*                                                                    *\n.*--------------------------------------------------------------------*\n.*\n         GBLA  &QLEVEL\n         GBLB  &$Q$HQT\n         GBLC  &QSECT                   NAME OF CURRENT ROUTINE\n.*\n&QSECT   CSECT                          RESUME FOR STUPID HASP MACROS\n.*\n         AIF   (&$Q$HQT).MEND           IGNORE IF ALREADY GENERATED\n&$Q$HQT  SETB  1                        SET \"ALREADY GENERATED\" FLAG\n         AIF   (&QLEVEL GT 3).BYPASS\n         Q$BUFFER                       NEED BUFSTART & BUFDSECT EQU'S\n*        $HQT\n         $HQT\n         SPACE 6\n.*\n         MEXIT\n.BYPASS  MNOTE *,'$HQT bypassed for this level of JES2.'\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "Q$IOT": {"ttr": 1806, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x05\\x00\\x00\\x00\\x82#/\\x00\\x892\\x7f V\\x001\\x00\\x1e\\x00\\x1b\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "05.05", "flags": 0, "createdate": "1982-08-20T00:00:00", "modifydate": "1989-11-23T20:56:00", "lines": 49, "newlines": 30, "modlines": 27, "user": "LDW"}, "text": "         MACRO\n         Q$IOT\n.*--------------------------------------------------------------------*\n.*                                                                    *\n.*  Updates:                                                          *\n.*     23Nov89  LDW  Invoke Q$PDDB (needed for SP)                    *\n.*     21Feb87  LDW  Move misc equates to QHASPEQU                    *\n.*     16Jan87  LDW  SP136 Changes:  EQUate $MAXDA if necessary       *\n.*     14DEC86  LDW  SP136 CHANGES:  EQUATE IOTDSECT TO IOT FOR       *\n.*                      PRIOR LEVEL; DON'T INVOKE $TGM                *\n.*     08/07/84 LDW  USE Q$BUFFER TO GENERATE BUFSTART & BUFDSECT     *\n.*                      EQUATES                                       *\n.*                                                                    *\n.*--------------------------------------------------------------------*\n.*\n         GBLA  &QLEVEL\n         GBLB  &$Q$IOT,&$Q$HCT,&$Q$JCT,&$Q$SVT\n         GBLC  &QSECT                   NAME OF CURRENT ROUTINE\n.*\n&QSECT   CSECT                          RESUME FOR STUPID HASP MACROS\n.*\n         AIF   (&$Q$IOT).MEND           IGNORE IF ALREADY GENERATED\n*        Q$PDDB\n         Q$PDDB\n*        Q$BUFFER                       NEED BUFSTART & BUFDSECT EQU'S\n         Q$BUFFER                       NEED BUFSTART & BUFDSECT EQU'S\n*        Q$TAB\n         Q$TAB\n         SPACE 3\n.*  FOR SOME STUPID REASON, $IOT WILL INVOKE $TGM.  SO, I MAY AS WELL\n.*  BEAT HIM TO IT.\n         AIF   (&QLEVEL GE 7).NO$TGM\n*        Q$TGM\n         Q$TGM\n         SPACE 3\n.NO$TGM  ANOP\n*        $IOT\n         $IOT\n         AIF   (&QLEVEL GE 7).NEWNAME\nIOT      EQU   IOTDSECT                 ALLOW USE OF NEW NAME WITH\n*                                          PRIOR JES2 LEVEL\n         AGO   .OLDNAME                 * TEMP *\n.NEWNAME ANOP\nIOTDSECT EQU   IOT                      * TEMP *\n.OLDNAME ANOP                           * TEMP *\n         SPACE 6\n&$Q$IOT  SETB  1                        SET \"ALREADY GENERATED\" FLAG\n.*\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "Q$JCT": {"ttr": 1808, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x04\\x00\\x00\\x00\\x82#/\\x00\\x87\\x05/ 3\\x00#\\x00\\x17\\x00\\x14\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "05.04", "flags": 0, "createdate": "1982-08-20T00:00:00", "modifydate": "1987-02-21T20:33:00", "lines": 35, "newlines": 23, "modlines": 20, "user": "LDW"}, "text": "         MACRO\n         Q$JCT\n.*--------------------------------------------------------------------*\n.*                                                                    *\n.*  Updates:                                                          *\n.*     21Feb87  LDW  Move misc equates to QHASPEQU                    *\n.*     16Jan87  LDW  SP136 Changes:  EQUate $MAXDA if necessary;      *\n.*                      Don't EQU 'JCT'                               *\n.*     08/07/84 LDW  USE Q$BUFFER TO GENERATE BUFSTART & BUFDSECT     *\n.*                      EQUATES                                       *\n.*                                                                    *\n.*--------------------------------------------------------------------*\n.*\n         GBLA  &QLEVEL\n         GBLB  &$Q$JCT,&$Q$HCT,&$Q$IOT,&$Q$SVT\n         GBLC  &QSECT                   NAME OF CURRENT ROUTINE\n.*\n&QSECT   CSECT                          RESUME FOR STUPID HASP MACROS\n.*\n         AIF   (&$Q$JCT).MEND           IGNORE IF ALREADY GENERATED\n         Q$BUFFER                       NEED BPFSTART & BFPDSECT EQU'S\n         AIF   (&QLEVEL GE 7).LEV7      SKIP IF IT'S NOW THE DSECT NAME\nJCT      EQU   0\n.LEV7    ANOP\n         SPACE 2\n*        $JCT\n         $JCT\n          AIF   (&QLEVEL GE 4).SP\n         SPACE 2\nJCTHDSCT EQU   JCTHQRCT,2,C'H'          ALLOW USE OF NEW SYMBOL WITH\n*                                       NON-SP JES2\n.SP      SPACE 6\n&$Q$JCT  SETB  1                        SET \"ALREADY GENERATED\" FLAG\n.*\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "Q$JOE": {"ttr": 1810, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x02\\x00\\x00\\x00\\x82#/\\x00\\x87\\x00O \\x07\\x00)\\x00\\x0f\\x00\\x1a\\xc5\\xc1\\xe8@@@@@@@'", "ispf": {"version": "05.02", "flags": 0, "createdate": "1982-08-20T00:00:00", "modifydate": "1987-01-04T20:07:00", "lines": 41, "newlines": 15, "modlines": 26, "user": "EAY"}, "text": "         MACRO\n         Q$JOE\n.*--------------------------------------------------------------------*\n.*                                                                    *\n.*  UPDATES:                                                          *\n.*     04Jan87  LDW  SP136 CHANGES:  more fake symbol equates         *\n.*     14DEC86  LDW  SP136 CHANGES:  EQUATE JOEDSECT TO JOE FOR       *\n.*                      PRIOR LEVEL                                   *\n.*                                                                    *\n.*--------------------------------------------------------------------*\n.*\n         GBLA  &QLEVEL\n         GBLB  &$Q$JOE\n         GBLC  &QSECT                   NAME OF CURRENT ROUTINE\n.*\n&QSECT   CSECT                          RESUME FOR STUPID HASP MACROS\n.*\n         AIF   (&$Q$JOE).MEND           IGNORE IF ALREADY GENERATED\n*        $JOE\n         $JOE\n         AIF   (&QLEVEL GE 7).NEWNAME\nJOE      EQU   JOEDSECT                 ALLOW USE OF NEW NAME WITH\n*                                          PRIOR JES2 LEVEL\nJOEFLAG1 EQU   JOEFLAG\nJOE1BUSY EQU   $JOEBUSY\nJOE1CKV  EQU   $JOECKV\nJOE1PRT  EQU   $JOEPRT\nJOE1PUN  EQU   $JOEPUN\n         AGO   .OLDNAME                 * TEMP *\n.NEWNAME ANOP\nJOEDSECT EQU   JOE                      * TEMP *\nJOEFLAG  EQU   JOEFLAG1                 * TEMP *\n$JOEBUSY EQU   JOE1BUSY                 * TEMP *\n$JOECKV  EQU   JOE1CKV                  * TEMP *\n$JOEPRT  EQU   JOE1PRT                  * TEMP *\n$JOEPUN  EQU   JOE1PUN                  * TEMP *\n.OLDNAME ANOP                           * TEMP *\n         SPACE 6\n&$Q$JOE  SETB  1                        SET \"ALREADY GENERATED\" FLAG\n.*\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "Q$JOT": {"ttr": 1812, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x05\\x04\\x00\\x00\\x00\\x82#/\\x00\\x91\\x15\\x9f!S\\x005\\x00\\x11\\x00'\\xd3\\xc4\\xe6@@@@@@@\"", "ispf": {"version": "05.04", "flags": 0, "createdate": "1982-08-20T00:00:00", "modifydate": "1991-06-08T21:53:00", "lines": 53, "newlines": 17, "modlines": 39, "user": "LDW"}, "text": "         MACRO\n         Q$JOT\n.*--------------------------------------------------------------------*\n.*                                                                    *\n.*  Updates:                                                          *\n.*     08Jun91  LDW/EMS  Add EQU's to simplify Q#SR                   *\n.*     21Feb87  LDW  Move misc equates to QHASPEQU                    *\n.*     14DEC86  LDW  SP136 CHANGES:  EQUATE JOTDSECT TO JOT FOR       *\n.*                      PRIOR LEVEL                                   *\n.*     22JUN86  LDW  DEFINE $MAXNODE ONLY IF $HCT NOT GENERATED       *\n.*                                                                    *\n.*--------------------------------------------------------------------*\n.*\n         GBLA  &QLEVEL\n         GBLB  &$Q$JOT,&$Q$HCT\n         GBLC  &QSECT                   NAME OF CURRENT ROUTINE\n.*\n&QSECT   CSECT                          RESUME FOR STUPID HASP MACROS\n.*\n         AIF   (&$Q$JOT).MEND           IGNORE IF ALREADY GENERATED\n*        $JOT\n         $JOT\n         AIF   (&QLEVEL GE 7).NEWNAME\nJOT      EQU   JOTDSECT                 ALLOW USE OF NEW NAME WITH\n*                                          PRIOR JES2 LEVEL\n         AGO   .OLDNAME                 * TEMP *\n.NEWNAME ANOP\nJOTDSECT EQU   JOT                      * TEMP *\n.OLDNAME ANOP                           * TEMP *\n         AIF   (&QLEVEL GE 11).TRIPLE\n         AIF   (&QLEVEL GE  4).DOUBLE\nJOT@OQN  EQU   1                        number of o/p queues / class\n         AGO   .OQNOK\n.DOUBLE  ANOP\nJOT@OQN  EQU   2                        number of o/p queues / class\n         AGO   .OQNOK\n.TRIPLE  ANOP\nJOT@OQN  EQU   3                        number of o/p queues / class\n.OQNOK   ANOP\n         AIF   (&QLEVEL GE  7).PLUSONE\n         AIF   (&QLEVEL GE  4).PLUSTWO\nJOT@XQN  EQU   0                        number of extra o/p queues\n         AGO   .XQNOK\n.PLUSTWO ANOP\nJOT@XQN  EQU   2                        number of extra o/p queues\n         AGO   .XQNOK\n.PLUSONE ANOP\nJOT@XQN  EQU   1                        number of extra o/p queues\n.XQNOK   ANOP\n         SPACE 6\n&$Q$JOT  SETB  1                        SET \"ALREADY GENERATED\" FLAG\n.*\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "Q$JQE": {"ttr": 1814, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x03\\x00\\x00\\x00\\x82#/\\x00\\x87\\x15o\\x10\\x15\\x00;\\x00\\x16\\x00&\\xc5\\xd4\\xe2@@@@@@@'", "ispf": {"version": "05.03", "flags": 0, "createdate": "1982-08-20T00:00:00", "modifydate": "1987-06-05T10:15:00", "lines": 59, "newlines": 22, "modlines": 38, "user": "EMS"}, "text": "         MACRO\n         Q$JQE\n.*--------------------------------------------------------------------*\n.*                                                                    *\n.*  Updates:                                                          *\n.*      5Jun87  EMS  Base fixes:  fix to fake symbols equated         *\n.*     16Jan87  LDW  SP136 Changes:  more fake symbols equated        *\n.*                                                                    *\n.*--------------------------------------------------------------------*\n.*\n         GBLA  &OWNERLN                 OSI SUPERWYLBUR\n         GBLA  &QLEVEL\n         GBLB  &$Q$JQE\n         GBLC  &QSECT                   NAME OF CURRENT ROUTINE\n.*\n&QSECT   CSECT                          RESUME FOR STUPID HASP MACROS\n.*\n         AIF   (&$Q$JQE).MEND           IGNORE IF ALREADY GENERATED\n&OWNERLN SETA  1                        SET TO AVOID ASSEMBLY ERROR\n*        $JQE\n         $JQE\n         AIF   (&QLEVEL GE 7).NEWNAME\n*  Allow use of new names with prior JES2 levels\n.*JQE    EQU   JQEDSECT                 IBM does this one!\nJQEFLAG1 EQU   JQEFLAGS\nJQE1HLDA EQU   QUEHOLDA\nJQE1HLD1 EQU   QUEHOLD1\nJQE1HLD2 EQU   QUEHOLD2\nJQE1BUSY EQU   QUEBUSY\nJQE1OCAN EQU   QUEOPCAN\nJQE2IND  EQU   QUEINDAF\nJQE2SAF  EQU   QUESYSAF\n         AIF   (&QLEVEL LE 3).OLDNAME\nJQE3JOB  EQU   QUEJOB\nJQE3STC  EQU   QUESTC\nJQE3TSU  EQU   QUETSU\n         AGO   .OLDNAME                 * TEMP *\n.NEWNAME ANOP\nJQEDSECT EQU   JQE                      * TEMP *\nJQEFLAGS EQU   JQEFLAG1                 * TEMP *\nQUEHOLDA EQU   JQE1HLDA                 * TEMP *\nQUEHOLD1 EQU   JQE1HLD1                 * TEMP *\nQUEHOLD2 EQU   JQE1HLD2                 * TEMP *\nQUEBUSY  EQU   JQE1BUSY                 * TEMP *\nQUEOPCAN EQU   JQE1OCAN                 * TEMP *\nQUEINDAF EQU   JQE2IND                  * TEMP *\nQUESYSAF EQU   JQE2SAF                  * TEMP *\nQUEJOB   EQU   JQE3JOB                  * TEMP *\nQUESTC   EQU   JQE3STC                  * TEMP *\nQUETSU   EQU   JQE3TSU                  * TEMP *\n.OLDNAME ANOP                           * TEMP *\n         AIF   (&QLEVEL GE 4).SKIP\n         SPACE 1\nJQENEXT  EQU   JQECHAIN,2,C'H'          ALLOW USE OF NEW SYMBOL\n*                                           WITH OLD JES2\n.SKIP    SPACE 6\n&$Q$JQE  SETB  1                        SET \"ALREADY GENERATED\" FLAG\n.*\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "Q$JQT": {"ttr": 1816, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x00\\x00\\x00\\x00\\x82#/\\x00\\x82#/\\x14R\\x00\\x0f\\x00\\x0f\\x00\\x00\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "05.00", "flags": 0, "createdate": "1982-08-20T00:00:00", "modifydate": "1982-08-20T14:52:00", "lines": 15, "newlines": 15, "modlines": 0, "user": "LDW"}, "text": "         MACRO\n         Q$JQT\n.*\n         GBLB  &$Q$JQT\n         GBLC  &QSECT                   NAME OF CURRENT ROUTINE\n.*\n&QSECT   CSECT                          RESUME FOR STUPID HASP MACROS\n.*\n         AIF   (&$Q$JQT).MEND           IGNORE IF ALREADY GENERATED\n*        $JQT\n         $JQT\n         SPACE 6\n&$Q$JQT  SETB  1                        SET \"ALREADY GENERATED\" FLAG\n.*\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "Q$KAC": {"ttr": 2049, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x89\\x11_\\x00\\x892\\x7f\\x15\\x18\\x00\\x19\\x00\\x14\\x00\\x08\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1989-04-25T00:00:00", "modifydate": "1989-11-23T15:18:00", "lines": 25, "newlines": 20, "modlines": 8, "user": "LDW"}, "text": "         MACRO\n         Q$KAC\n.*--------------------------------------------------------------------*\n.*                                                                    *\n.*  Updates:                                                          *\n.*     23Nov89  LDW  Don't expand if &QLEVEL < 8                      *\n.*                                                                    *\n.*--------------------------------------------------------------------*\n.*\n         GBLA  &QLEVEL\n         GBLB  &$Q$KAC\n         GBLC  &QSECT                   NAME OF CURRENT ROUTINE\n.*\n&QSECT   CSECT                          RESUME FOR STUPID HASP MACROS\n.*\n         AIF   (&$Q$KAC).MEND           IGNORE IF ALREADY GENERATED\n&$Q$KAC  SETB  1                        SET \"ALREADY GENERATED\" FLAG\n         AIF   (&QLEVEL LT 8).BYPASS\n*        $KAC\n         $KAC\n         SPACE 6\n         MEXIT\n.BYPASS  MNOTE *,'$KAC bypassed for this level of JES2.'\n.*\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "Q$KIT": {"ttr": 2051, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x86\\x16\\x7f\\x00\\x892\\x7f\\x14Q\\x00\"\\x00\\x0f\\x00\\x14\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1986-06-16T00:00:00", "modifydate": "1989-11-23T14:51:00", "lines": 34, "newlines": 15, "modlines": 20, "user": "LDW"}, "text": "         MACRO\n         Q$KIT\n.*--------------------------------------------------------------------*\n.*                                                                    *\n.*  Updates:                                                          *\n.*     23Nov89  LDW  Don't expand if &QLEVEL < 4                      *\n.*     14DEC86  LDW  SP136 CHANGES:  EQUATE KITDSECT TO KIT FOR       *\n.*                      PRIOR LEVEL                                   *\n.*                                                                    *\n.*--------------------------------------------------------------------*\n.*\n         GBLA  &QLEVEL\n         GBLB  &$Q$KIT\n         GBLC  &QSECT                   NAME OF CURRENT ROUTINE\n.*\n&QSECT   CSECT                          RESUME FOR STUPID HASP MACROS\n.*\n         AIF   (&$Q$KIT).MEND           IGNORE IF ALREADY GENERATED\n&$Q$KIT  SETB  1                        SET \"ALREADY GENERATED\" FLAG\n         AIF   (&QLEVEL LT 4).BYPASS\n*        $KIT\n         $KIT\n         AIF   (&QLEVEL GE 7).NEWNAME\nKIT      EQU   KITDSECT                 ALLOW USE OF NEW NAME WITH\n*                                          PRIOR JES2 LEVEL\n         AGO   .OLDNAME                 * TEMP *\n.NEWNAME ANOP\nKITDSECT EQU   KIT                      * TEMP *\n.OLDNAME ANOP                           * TEMP *\n         SPACE 6\n.*\n         MEXIT\n.BYPASS  MNOTE *,'$KIT bypassed for this level of JES2.'\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "Q$LCK": {"ttr": 2053, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x83\\x01O\\x00\\x83\\x01O\\x13\\x07\\x00\\x0f\\x00\\x0f\\x00\\x00\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1983-01-14T00:00:00", "modifydate": "1983-01-14T13:07:00", "lines": 15, "newlines": 15, "modlines": 0, "user": "LDW"}, "text": "         MACRO\n         Q$LCK\n.*\n         GBLB  &$Q$LCK\n         GBLC  &QSECT                   NAME OF CURRENT ROUTINE\n.*\n&QSECT   CSECT                          RESUME FOR STUPID HASP MACROS\n.*\n         AIF   (&$Q$LCK).MEND           IGNORE IF ALREADY GENERATED\n*        $LCK\n         $LCK\n         SPACE 6\n&$Q$LCK  SETB  1                        SET \"ALREADY GENERATED\" FLAG\n.*\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "Q$LMT": {"ttr": 2055, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x903/\\x00\\x905O\\x171\\x00\\x19\\x00\\x16\\x00\\x04\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1990-11-28T00:00:00", "modifydate": "1990-12-20T17:31:00", "lines": 25, "newlines": 22, "modlines": 4, "user": "LDW"}, "text": "         MACRO\n         Q$LMT\n.*--------------------------------------------------------------------*\n.*                                                                    *\n.*  Updates:                                                          *\n.*     28Nov90  EMS  created macro                                    *\n.*                                                                    *\n.*--------------------------------------------------------------------*\n.*\n         GBLA  &QLEVEL\n         GBLB  &$Q$LMT\n         GBLC  &QSECT                   NAME OF CURRENT ROUTINE\n.*\n&QSECT   CSECT                          RESUME FOR STUPID HASP MACROS\n.*\n         AIF   (&$Q$LMT).MEND           IGNORE IF ALREADY GENERATED\n&$Q$LMT  SETB  1                        SET \"ALREADY GENERATED\" FLAG\n         AIF   (&QLEVEL LT 4).BYPASS\n*        $LMT\n         $LMT\n.OK      SPACE 6\n         AGO   .MEND\n.*\n.BYPASS  MNOTE *,'$LMT bypassed for this level of JES2.'\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "Q$LRC": {"ttr": 2057, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x823_\\x00\\x864\\x8f\"3\\x00\\x1e\\x00\\x0f\\x00\\x0f\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1982-12-01T00:00:00", "modifydate": "1986-12-14T22:33:00", "lines": 30, "newlines": 15, "modlines": 15, "user": "LDW"}, "text": "         MACRO\n         Q$LRC\n.*--------------------------------------------------------------------*\n.*                                                                    *\n.*  UPDATES:                                                          *\n.*     14DEC86  LDW  SP136 CHANGES:  EQUATE LRCDSECT TO LRC FOR       *\n.*                      PRIOR LEVEL                                   *\n.*                                                                    *\n.*--------------------------------------------------------------------*\n.*\n         GBLA  &QLEVEL\n         GBLB  &$Q$LRC\n         GBLC  &QSECT                   NAME OF CURRENT ROUTINE\n.*\n&QSECT   CSECT                          RESUME FOR STUPID HASP MACROS\n.*\n         AIF   (&$Q$LRC).MEND           IGNORE IF ALREADY GENERATED\n*        $LRC\n         $LRC\n         AIF   (&QLEVEL GE 7).NEWNAME\nLRC      EQU   LRCDSECT                 ALLOW USE OF NEW NAME WITH\n*                                          PRIOR JES2 LEVEL\n         AGO   .OLDNAME                 * TEMP *\n.NEWNAME ANOP\nLRCDSECT EQU   LRC                      * TEMP *\n.OLDNAME ANOP                           * TEMP *\n         SPACE 6\n&$Q$LRC  SETB  1                        SET \"ALREADY GENERATED\" FLAG\n.*\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "Q$MIT": {"ttr": 2059, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x84\\x04\\x1f\\x00\\x892\\x7f#5\\x00\\x19\\x00\\x0f\\x00\\x0b\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1984-02-10T00:00:00", "modifydate": "1989-11-23T23:35:00", "lines": 25, "newlines": 15, "modlines": 11, "user": "LDW"}, "text": "         MACRO\n         Q$MIT\n.*--------------------------------------------------------------------*\n.*                                                                    *\n.*  Updates:                                                          *\n.*     23Nov89  LDW  Don't expand if &QLEVEL < 4                      *\n.*                                                                    *\n.*--------------------------------------------------------------------*\n.*\n         GBLA  &QLEVEL\n         GBLB  &$Q$MIT\n         GBLC  &QSECT                   NAME OF CURRENT ROUTINE\n.*\n&QSECT   CSECT                          RESUME FOR STUPID HASP MACROS\n.*\n         AIF   (&$Q$MIT).MEND           IGNORE IF ALREADY GENERATED\n&$Q$MIT  SETB  1                        SET \"ALREADY GENERATED\" FLAG\n         AIF   (&QLEVEL LT 4).BYPASS\n*        $MIT\n         $MIT\n         SPACE 6\n.*\n         MEXIT\n.BYPASS  MNOTE *,'$MIT bypassed for this level of JES2.'\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "Q$NHD": {"ttr": 2061, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x84\\x07\\x8f\\x00\\x892\\x7f\\x14T\\x00\"\\x00\\x0f\\x00\\x14\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1984-03-18T00:00:00", "modifydate": "1989-11-23T14:54:00", "lines": 34, "newlines": 15, "modlines": 20, "user": "LDW"}, "text": "         MACRO\n         Q$NHD\n.*--------------------------------------------------------------------*\n.*                                                                    *\n.*  Updates:                                                          *\n.*     23Nov89  LDW  Don't expand if &QLEVEL < 4                      *\n.*     14DEC86  LDW  SP136 CHANGES:  EQUATE NJHDSECT TO NJH FOR       *\n.*                      PRIOR LEVEL                                   *\n.*                                                                    *\n.*--------------------------------------------------------------------*\n.*\n         GBLA  &QLEVEL\n         GBLB  &$Q$NHD\n         GBLC  &QSECT                   NAME OF CURRENT ROUTINE\n.*\n&QSECT   CSECT                          RESUME FOR STUPID HASP MACROS\n.*\n         AIF   (&$Q$NHD).MEND           IGNORE IF ALREADY GENERATED\n&$Q$NHD  SETB  1                        SET \"ALREADY GENERATED\" FLAG\n         AIF   (&QLEVEL LT 4).BYPASS\n*        $NHD\n         $NHD\n         AIF   (&QLEVEL GE 7).NEWNAME\nNJH      EQU   NJHDSECT                 ALLOW USE OF NEW NAME WITH\n*                                          PRIOR JES2 LEVEL\n         AGO   .OLDNAME                 * TEMP *\n.NEWNAME ANOP\nNJHDSECT EQU   NJH                      * TEMP *\n.OLDNAME ANOP                           * TEMP *\n         SPACE 6\n.*\n         MEXIT\n.BYPASS  MNOTE *,'$NHD bypassed for this level of JES2.'\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "Q$NHSB": {"ttr": 2063, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x01\\x00\\x00\\x00\\x91'/\\x00\\x915O \\x03\\x00\\x19\\x00\\x1a\\x00\\x02\\xd3\\xc4\\xe6@@@@@@@\"", "ispf": {"version": "01.01", "flags": 0, "createdate": "1991-09-29T00:00:00", "modifydate": "1991-12-20T20:03:00", "lines": 25, "newlines": 26, "modlines": 2, "user": "LDW"}, "text": "         MACRO\n         Q$NHSB\n.*--------------------------------------------------------------------*\n.*                                                                    *\n.*  Updates:                                                          *\n.*     20Dec91  LDW  Comment box corrected                            *\n.*     29Sep91  GLA  Created                                          *\n.*                                                                    *\n.*--------------------------------------------------------------------*\n.*\n         GBLA  &QLEVEL\n         GBLB  &$Q$NHSB\n         GBLC  &QSECT                   NAME OF CURRENT ROUTINE\n.*\n&QSECT   CSECT                          RESUME FOR STUPID HASP MACROS\n.*\n         AIF   (&$Q$NHSB).MEND          IGNORE IF ALREADY GENERATED\n&$Q$NHSB SETB  1                        SET \"ALREADY GENERATED\" FLAG\n         AIF   (&QLEVEL LT 12).BYPASS\n*        $NHSB\n         $NHSB\n.*\n         MEXIT\n.BYPASS  MNOTE *,'$NHSB bypassed for this level of JES2.'\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "Q$PADDR": {"ttr": 2065, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x88\\x03\\x1f\\x00\\x88\\x17\\x8f\\x17F\\x00\\x11\\x00\\x0f\\x00\\x02\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1988-01-31T00:00:00", "modifydate": "1988-06-26T17:46:00", "lines": 17, "newlines": 15, "modlines": 2, "user": "LDW"}, "text": "         MACRO\n         Q$PADDR\n.*\n         GBLA  &QLEVEL\n         GBLB  &$Q$PADR\n         GBLC  &QSECT                   NAME OF CURRENT ROUTINE\n         AIF   (&QLEVEL LT 8).MEND      IGNORE IF BACKLEVEL JES2\n.*\n&QSECT   CSECT                          RESUME FOR STUPID HASP MACROS\n.*\n         AIF   (&$Q$PADR).MEND          IGNORE IF ALREADY GENERATED\n*        $PADDR\n         $PADDR\n         SPACE 6\n&$Q$PADR SETB  1                        SET \"ALREADY GENERATED\" FLAG\n.*\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "Q$PCE": {"ttr": 2067, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x83\\x00O\\x00\\x83\\x00O\\x13\\x07\\x00\\x16\\x00\\x0f\\x00\\x07\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1983-01-04T00:00:00", "modifydate": "1983-01-04T13:07:00", "lines": 22, "newlines": 15, "modlines": 7, "user": "LDW"}, "text": "         MACRO\n         Q$PCE\n.*--------------------------------------------------------------------*\n.*                                                                    *\n.*  UPDATES:                                                          *\n.*     01/04/83 LDW  MACRO CREATED                                    *\n.*                                                                    *\n.*--------------------------------------------------------------------*\n.*\n         GBLB  &$Q$PCE\n         GBLC  &QSECT                   NAME OF CURRENT ROUTINE\n.*\n&QSECT   CSECT                          RESUME FOR STUPID HASP MACROS\n.*\n         AIF   (&$Q$PCE).MEND           IGNORE IF ALREADY GENERATED\nSAVE     EQU   13                       NJE 3.0 AND SP\n*        $PCE\n         $PCE\n         SPACE 6\n&$Q$PCE  SETB  1                        SET \"ALREADY GENERATED\" FLAG\n.*\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "Q$PDDB": {"ttr": 2069, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x01\\x00\\x00\\x00\\x82#/\\x00\\x864\\x8f\"4\\x00\\x1e\\x00\\x0f\\x00\\x0f\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "05.01", "flags": 0, "createdate": "1982-08-20T00:00:00", "modifydate": "1986-12-14T22:34:00", "lines": 30, "newlines": 15, "modlines": 15, "user": "LDW"}, "text": "         MACRO\n         Q$PDDB\n.*--------------------------------------------------------------------*\n.*                                                                    *\n.*  UPDATES:                                                          *\n.*     14DEC86  LDW  SP136 CHANGES:  EQUATE PDBDSECT TO PDB FOR       *\n.*                      PRIOR LEVEL                                   *\n.*                                                                    *\n.*--------------------------------------------------------------------*\n.*\n         GBLA  &QLEVEL\n         GBLB  &$Q$PDDB\n         GBLC  &QSECT                   NAME OF CURRENT ROUTINE\n.*\n&QSECT   CSECT                          RESUME FOR STUPID HASP MACROS\n.*\n         AIF   (&$Q$PDDB).MEND          IGNORE IF ALREADY GENERATED\n*        $PDDB\n         $PDDB\n         AIF   (&QLEVEL GE 7).NEWNAME\nPDB      EQU   PDBDSECT                 ALLOW USE OF NEW NAME WITH\n*                                          PRIOR JES2 LEVEL\n         AGO   .OLDNAME                 * TEMP *\n.NEWNAME ANOP\nPDBDSECT EQU   PDB                      * TEMP *\n.OLDNAME ANOP                           * TEMP *\n         SPACE 6\n&$Q$PDDB SETB  1                        SET \"ALREADY GENERATED\" FLAG\n.*\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "Q$PIT": {"ttr": 2071, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x01\\x00\\x00\\x00\\x82#/\\x00\\x864\\x8f\"4\\x00\\x1e\\x00\\x0f\\x00\\x0f\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "05.01", "flags": 0, "createdate": "1982-08-20T00:00:00", "modifydate": "1986-12-14T22:34:00", "lines": 30, "newlines": 15, "modlines": 15, "user": "LDW"}, "text": "         MACRO\n         Q$PIT\n.*--------------------------------------------------------------------*\n.*                                                                    *\n.*  UPDATES:                                                          *\n.*     14DEC86  LDW  SP136 CHANGES:  EQUATE PITDSECT TO PIT FOR       *\n.*                      PRIOR LEVEL                                   *\n.*                                                                    *\n.*--------------------------------------------------------------------*\n.*\n         GBLA  &QLEVEL\n         GBLB  &$Q$PIT\n         GBLC  &QSECT                   NAME OF CURRENT ROUTINE\n.*\n&QSECT   CSECT                          RESUME FOR STUPID HASP MACROS\n.*\n         AIF   (&$Q$PIT).MEND           IGNORE IF ALREADY GENERATED\n*        $PIT\n         $PIT\n         AIF   (&QLEVEL GE 7).NEWNAME\nPIT      EQU   PITDSECT                 ALLOW USE OF NEW NAME WITH\n*                                          PRIOR JES2 LEVEL\n         AGO   .OLDNAME                 * TEMP *\n.NEWNAME ANOP\nPITDSECT EQU   PIT                      * TEMP *\n.OLDNAME ANOP                           * TEMP *\n         SPACE 6\n&$Q$PIT  SETB  1                        SET \"ALREADY GENERATED\" FLAG\n.*\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "Q$QSE": {"ttr": 2073, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x01\\x00\\x00\\x00\\x82#/\\x00\\x864\\x8f\"4\\x00\\x1e\\x00\\x0f\\x00\\x0f\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "05.01", "flags": 0, "createdate": "1982-08-20T00:00:00", "modifydate": "1986-12-14T22:34:00", "lines": 30, "newlines": 15, "modlines": 15, "user": "LDW"}, "text": "         MACRO\n         Q$QSE\n.*--------------------------------------------------------------------*\n.*                                                                    *\n.*  UPDATES:                                                          *\n.*     14DEC86  LDW  SP136 CHANGES:  EQUATE QSEDSECT TO QSE FOR       *\n.*                      PRIOR LEVEL                                   *\n.*                                                                    *\n.*--------------------------------------------------------------------*\n.*\n         GBLA  &QLEVEL\n         GBLB  &$Q$QSE\n         GBLC  &QSECT                   NAME OF CURRENT ROUTINE\n.*\n&QSECT   CSECT                          RESUME FOR STUPID HASP MACROS\n.*\n         AIF   (&$Q$QSE).MEND           IGNORE IF ALREADY GENERATED\n*        $QSE\n         $QSE\n         AIF   (&QLEVEL GE 7).NEWNAME\nQSE      EQU   QSEDSECT                 ALLOW USE OF NEW NAME WITH\n*                                          PRIOR JES2 LEVEL\n         AGO   .OLDNAME                 * TEMP *\n.NEWNAME ANOP\nQSEDSECT EQU   QSE                      * TEMP *\n.OLDNAME ANOP                           * TEMP *\n         SPACE 6\n&$Q$QSE  SETB  1                        SET \"ALREADY GENERATED\" FLAG\n.*\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "Q$RDT": {"ttr": 2075, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x03\\x00\\x00\\x00\\x82#/\\x00\\x91\\x18_\"S\\x00\"\\x00\\x0f\\x00\\x16\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "05.03", "flags": 0, "createdate": "1982-08-20T00:00:00", "modifydate": "1991-07-04T22:53:00", "lines": 34, "newlines": 15, "modlines": 22, "user": "LDW"}, "text": "         MACRO\n         Q$RDT\n.*--------------------------------------------------------------------*\n.*                                                                    *\n.*  UPDATES:                                                          *\n.*     14DEC86  LDW  SP136 CHANGES:  EQUATE RDTDSECT TO RDT FOR       *\n.*                      PRIOR LEVEL                                   *\n.*     01/03/83 LDW  ADD SP & NJE COMPATIBILITY                       *\n.*                                                                    *\n.*--------------------------------------------------------------------*\n.*\n         GBLA  &QLEVEL\n         GBLB  &$Q$RDT,&@@QNJE\n         GBLC  &QSECT                   NAME OF CURRENT ROUTINE\n.*\n&QSECT   CSECT                          RESUME FOR STUPID HASP MACROS\n.*\n         AIF   (&$Q$RDT).MEND           IGNORE IF ALREADY GENERATED\n*        $RDT\n         $RDT\n         AIF   (&QLEVEL GE 7).NEWNAME\nRDT      EQU   RDTDSECT                 ALLOW USE OF NEW NAME WITH\n*                                          PRIOR JES2 LEVEL\n         AGO   .OLDNAME                 * TEMP *\n.NEWNAME ANOP\nRDTDSECT EQU   RDT                      * TEMP *\n.OLDNAME ANOP                           * TEMP *\n         AIF   (&QLEVEL GE 4 OR &@@QNJE).OK\nRDTNODE  EQU   RDTSYS,1                 ALLOW USE OF NEW SYMBOL WITH\n*                                       OLD (NON-NJE) JES2\n.OK      SPACE 6\n&$Q$RDT  SETB  1                        SET \"ALREADY GENERATED\" FLAG\n.*\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "Q$SJB": {"ttr": 2077, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x03\\x00\\x00\\x00\\x82#/\\x00\\x894O#@\\x00%\\x00\\x0f\\x00\\x16\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "05.03", "flags": 0, "createdate": "1982-08-20T00:00:00", "modifydate": "1989-12-10T23:40:00", "lines": 37, "newlines": 15, "modlines": 22, "user": "LDW"}, "text": "         MACRO\n         Q$SJB\n.*--------------------------------------------------------------------*\n.*                                                                    *\n.*  Updates:                                                          *\n.*     10Dec89  LDW  Change QDEB to QZDEB                             *\n.*     23Nov89  LDW  Invoke QDEB macro for JES2 SP                    *\n.*                   Remove conditional assembly around Q$TQE         *\n.*     14DEC86  LDW  SP136 CHANGES:  EQUATE SJBDSECT TO SJB FOR       *\n.*                      PRIOR LEVEL;  INVOKE $TQE IF SP136            *\n.*                                                                    *\n.*--------------------------------------------------------------------*\n.*\n         GBLA  &QLEVEL\n         GBLB  &$Q$SJB\n         GBLC  &QSECT                   NAME OF CURRENT ROUTINE\n.*\n&QSECT   CSECT                          RESUME FOR STUPID HASP MACROS\n.*\n         AIF   (&$Q$SJB).MEND           IGNORE IF ALREADY GENERATED\n*        QZDEB\n         QZDEB\n*        Q$TQE\n         Q$TQE\n*        $SJB\n         $SJB\n         AIF   (&QLEVEL GE 7).NEWNAME\nSJB      EQU   SJBDSECT                 ALLOW USE OF NEW NAME WITH\n*                                          PRIOR JES2 LEVEL\n         AGO   .OLDNAME                 * TEMP *\n.NEWNAME ANOP\nSJBDSECT EQU   SJB                      * TEMP *\n.OLDNAME ANOP                           * TEMP *\n         SPACE 6\n&$Q$SJB  SETB  1                        SET \"ALREADY GENERATED\" FLAG\n.*\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "Q$SVT": {"ttr": 2305, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x0e\\x00\\x00\\x00\\x82#/\\x00\\x91\\x18_\"T\\x00F\\x00\\x0f\\x00:\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "05.14", "flags": 0, "createdate": "1982-08-20T00:00:00", "modifydate": "1991-07-04T22:54:00", "lines": 70, "newlines": 15, "modlines": 58, "user": "LDW"}, "text": "         MACRO\n         Q$SVT\n.*--------------------------------------------------------------------*\n.*                                                                    *\n.*  Updates:                                                          *\n.*     23Nov89  LDW  Don't expand if &QLEVEL > 8                      *\n.*                   Invoke prereq Q$XECB                             *\n.*     26Jun88  LDW  Remove condition logoc for Q$HFAME (now done in  *\n.*                      Q$HFAME)                                      *\n.*     31Jan88  LDW  SP220 update:  $HFAME                            *\n.*      5Jun87  EMS  Update to support base JES2                      *\n.*     21Feb87  LDW  Move misc equates to QHASPEQU                    *\n.*     15Jan87  LDW  SP136:  equate $DRTOTAL & $MAXDA if necessary    *\n.*     04Jan87  LDW  SP136 updates:  more fake symbol equates         *\n.*     14Dec86  LDW  SP136 updates:  define old field names           *\n.*     23AUG86  LDW  PUT IN FORGOTTEN SP133 TEST BEFORE $XECB GEN     *\n.*     02/21/86 LDW  INVOKE Q$XECB IF SP133                           *\n.*     04/10/84 LDW  ADD SP133 SUPPORT                                *\n.*                                                                    *\n.*--------------------------------------------------------------------*\n.*\n         GBLA  &QLEVEL\n         GBLB  &$Q$SVT,&@@QNJE\n         GBLC  &QSECT                   NAME OF CURRENT ROUTINE\n.*\n&QSECT   CSECT                          RESUME FOR STUPID HASP MACROS\n.*\n         AIF   (&$Q$SVT).MEND           IGNORE IF ALREADY GENERATED\n&$Q$SVT  SETB  1                        SET \"ALREADY GENERATED\" FLAG\n         AIF   (&QLEVEL GT 8).BYPASS\n*        Q$XECB\n         Q$XECB\n*        Q$HFAME\n         Q$HFAME\n*        $SVT\n         $SVT\n         AIF   (&QLEVEL GE 7).NEWNAME\n*  Allow use of new names with prior JES2 levels\nSVTBFSIZ EQU   $SVBFSIZ,L'$SVBFSIZ\nSVTCOMCH EQU   $SVCOMCH,L'$SVCOMCH\nSVTDEB   EQU   $SVDEB,L'$SVDEB\nSVTHAVT  EQU   $SVHAVT,L'$SVHAVT\nSVTPIT   EQU   $SVPIT,L'$SVPIT\nSVTRDT   EQU   $SVRDT,L'$SVRDT\nSVTRDTE  EQU   $SVRDTE,L'$SVRDTE\nSVTSID   EQU   $SVSID,L'$SVSID\nSVTLEN   EQU   SSVTLEN\n         AIF   (&QLEVEL LE 3).OLDNAME\nSVTTONOD EQU   $SVTONOD,L'$SVTONOD\n         AGO   .OLDNAME                 * TEMP *\n.NEWNAME ANOP\n$SVBFSIZ EQU   SVTBFSIZ,L'SVTBFSIZ      * TEMP *\n$SVCOMCH EQU   SVTCOMCH,L'SVTCOMCH      * TEMP *\n$SVDEB   EQU   SVTDEB,L'SVTDEB          * TEMP *\n$SVHAVT  EQU   SVTHAVT,L'SVTHAVT        * TEMP *\n$SVPIT   EQU   SVTPIT,L'SVTPIT          * TEMP *\n$SVRDT   EQU   SVTRDT,L'SVTRDT          * TEMP *\n$SVRDTE  EQU   SVTRDTE,L'SVTRDTE        * TEMP *\n$SVSID   EQU   SVTSID,L'SVTSID          * TEMP *\n$SVTONOD EQU   SVTTONOD,L'SVTTONOD      * TEMP *\n.OLDNAME ANOP                           * TEMP *\n         AIF   (&QLEVEL GE 4 OR &@@QNJE).OK\n         SPACE 1\n$SVTONOD EQU   $SVTOSYS,1,C'A'          ALLOW USE OF NEW SYMBOL WITH\n*                                       OLD JES2 (EJE1102, EJE1103)\n.OK      SPACE 6\n.*\n         MEXIT\n.BYPASS  MNOTE *,'$SVT bypassed for this level of JES2.'\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "Q$TAB": {"ttr": 2307, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x00\\x00\\x00\\x00\\x82#/\\x00\\x82#/\\x14R\\x00\\x0f\\x00\\x0f\\x00\\x00\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "05.00", "flags": 0, "createdate": "1982-08-20T00:00:00", "modifydate": "1982-08-20T14:52:00", "lines": 15, "newlines": 15, "modlines": 0, "user": "LDW"}, "text": "         MACRO\n         Q$TAB\n.*\n         GBLB  &$Q$TAB\n         GBLC  &QSECT                   NAME OF CURRENT ROUTINE\n.*\n&QSECT   CSECT                          RESUME FOR STUPID HASP MACROS\n.*\n         AIF   (&$Q$TAB).MEND           IGNORE IF ALREADY GENERATED\n*        $TAB\n         $TAB\n         SPACE 6\n&$Q$TAB  SETB  1                        SET \"ALREADY GENERATED\" FLAG\n.*\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "Q$TGM": {"ttr": 2309, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x01\\x00\\x00\\x00\\x82#/\\x00\\x892\\x7f\\x15\"\\x00\\x19\\x00\\x0f\\x00\\x0b\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "05.01", "flags": 0, "createdate": "1982-08-20T00:00:00", "modifydate": "1989-11-23T15:22:00", "lines": 25, "newlines": 15, "modlines": 11, "user": "LDW"}, "text": "         MACRO\n         Q$TGM\n.*--------------------------------------------------------------------*\n.*                                                                    *\n.*  Updates:                                                          *\n.*     23Nov89  LDW  Don't expand if &QLEVEL > 6                      *\n.*                                                                    *\n.*--------------------------------------------------------------------*\n.*\n         GBLA  &QLEVEL\n         GBLB  &$Q$TGM\n         GBLC  &QSECT                   NAME OF CURRENT ROUTINE\n.*\n&QSECT   CSECT                          RESUME FOR STUPID HASP MACROS\n.*\n         AIF   (&$Q$TGM).MEND           IGNORE IF ALREADY GENERATED\n&$Q$TGM  SETB  1                        SET \"ALREADY GENERATED\" FLAG\n         AIF   (&QLEVEL GT 6).BYPASS\n*        $TGM\n         $TGM\n         SPACE 6\n.*\n         MEXIT\n.BYPASS  MNOTE *,'$TGM bypassed for this level of JES2.'\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "Q$TQE": {"ttr": 2311, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x864\\x8f\\x00\\x892\\x7f\\x15#\\x00\\x19\\x00\\x0f\\x00\\x0b\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1986-12-14T00:00:00", "modifydate": "1989-11-23T15:23:00", "lines": 25, "newlines": 15, "modlines": 11, "user": "LDW"}, "text": "         MACRO\n         Q$TQE\n.*--------------------------------------------------------------------*\n.*                                                                    *\n.*  Updates:                                                          *\n.*     23Nov89  LDW  Don't expand if &QLEVEL < 7                      *\n.*                                                                    *\n.*--------------------------------------------------------------------*\n.*\n         GBLA  &QLEVEL\n         GBLB  &$Q$TQE\n         GBLC  &QSECT                   NAME OF CURRENT ROUTINE\n.*\n&QSECT   CSECT                          RESUME FOR STUPID HASP MACROS\n.*\n         AIF   (&$Q$TQE).MEND           IGNORE IF ALREADY GENERATED\n&$Q$TQE  SETB  1                        SET \"ALREADY GENERATED\" FLAG\n         AIF   (&QLEVEL LT 7).BYPASS\n*        $TQE\n         $TQE\n         SPACE 6\n.*\n         MEXIT\n.BYPASS  MNOTE *,'$TQE bypassed for this level of JES2.'\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "Q$XECB": {"ttr": 2313, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x84\\x04\\x1f\\x00\\x892\\x7f\\x15 \\x00\\x19\\x00\\x0f\\x00\\x0b\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1984-02-10T00:00:00", "modifydate": "1989-11-23T15:20:00", "lines": 25, "newlines": 15, "modlines": 11, "user": "LDW"}, "text": "         MACRO\n         Q$XECB\n.*--------------------------------------------------------------------*\n.*                                                                    *\n.*  Updates:                                                          *\n.*     23Nov89  LDW  Don't expand if &QLEVEL < 5                      *\n.*                                                                    *\n.*--------------------------------------------------------------------*\n.*\n         GBLA  &QLEVEL\n         GBLB  &$Q$XECB\n         GBLC  &QSECT                   NAME OF CURRENT ROUTINE\n.*\n&QSECT   CSECT                          RESUME FOR STUPID HASP MACROS\n.*\n         AIF   (&$Q$XECB).MEND          IGNORE IF ALREADY GENERATED\n&$Q$XECB SETB  1                        SET \"ALREADY GENERATED\" FLAG\n         AIF   (&QLEVEL LT 5).BYPASS\n*        $XECB\n         $XECB\n         SPACE 6\n.*\n         MEXIT\n.BYPASS  MNOTE *,'$XECB bypassed for this level of JES2.'\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "Q##ALL": {"ttr": 2315, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x13\\x00\\x00\\x00\\x82#/\\x00\\x903o\\x14T\\x00f\\x00J\\x00#\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "05.19", "flags": 0, "createdate": "1982-08-20T00:00:00", "modifydate": "1990-12-02T14:54:00", "lines": 102, "newlines": 74, "modlines": 35, "user": "LDW"}, "text": "         COPY  Q#QD               (00)  ALL DSECTS\n         SPACE 2\n         COPY  Q#QQ               (01)  QUEUE MAINLINE\n         SPACE 2\n         COPY  Q#AL               (02)  ALLOCATE\n         SPACE 2\n         COPY  Q#AF                     APF\n         SPACE 2\n         COPY  Q#AT                     ATTR\n         SPACE 2\n         COPY  Q#BL                     BLKLIST\n         SPACE 2\n         COPY  Q#CB                     CBFMT\n         SPACE 2\n         COPY  Q#CH                     CHANGES\n         SPACE 2\n         COPY  Q#CK               (03)  CKPT\n         SPACE 2\n         COPY  Q#CP               (24)  CPU\n         SPACE 2\n         COPY  Q#DD               (04)  DDNAME\n         SPACE 2\n         COPY  Q#DY               (05)  DISPLAY\n         SPACE 2\n         COPY  Q#FJ               (06)  FINDJOB\n         SPACE 2\n         COPY  Q#FR               (81)  FINDRJE\n         SPACE 2\n         COPY  Q#FM               (07)  FORMAT\n         SPACE 2\n         COPY  Q#GP                     GETPDDB\n         SPACE 2\n         COPY  Q#GR                     GETREC\n         SPACE 2\n         COPY  Q#HE               (08)  HELP\n         SPACE 2\n         COPY  Q#HB               (09)  HEXBLK\n         SPACE 2\n         COPY  Q#II               (10)  INITIAL\n         SPACE 2\n         COPY  Q#IN               (23)  INITS\n         SPACE 2\n         COPY  Q#JN               (82)  JESNEWS\n         SPACE 2\n         COPY  Q#JI               (83)  JOBINFO\n         SPACE 2\n         COPY  Q#JS                     JOBSUMM\n         SPACE 2\n         COPY  Q#KL                     LIST KIT\n         SPACE 2\n         COPY  Q#LI               (14)  LIST\n         SPACE 2\n         COPY  Q#DL               (15)  LISTDAS\n         SPACE 2\n         COPY  Q#LD               (15)  LISTDS\n         SPACE 2\n         COPY  Q#LT                     LISTTEXT\n         SPACE 2\n         COPY  Q#MC               (84)  MCS\n         SPACE 2\n         COPY  Q#MO               (85)  MODE\n         SPACE 2\n         COPY  Q#OC               (86)  OPERCMD\n         SPACE 2\n         COPY  Q#PA               (16)  PARSE\n         SPACE 2\n         COPY  Q#PF                     PFKEYS\n         SPACE 2\n         COPY  Q#PR               (27)  PRINT\n         SPACE 2\n         COPY  Q#QI                     QINNARDS\n         SPACE 2\n         COPY  Q#QS                     QSUBS\n         SPACE 2\n         COPY  Q#RS               (17)  READSPC\n         SPACE 2\n         COPY  Q#RP               (18)  REPOS\n         SPACE 2\n         COPY  Q#RL                     RMTLIST\n         SPACE 2\n         COPY  Q#SV               (19)  SAVE\n         SPACE 2\n         COPY  Q#SR               (20)  SEARCH\n         SPACE 2\n         COPY  Q#SF                     SPFFUNC\n         SPACE 2\n         COPY  Q#SY                     SYSLIST\n         SPACE 2\n         COPY  Q#SL               (21)  SYSLOG\n         SPACE 2\n         COPY  Q#SO               (26)  SYSOUT\n         SPACE 2\n         COPY  Q#TC               (88)  TSOCMD\n         SPACE 2\n         COPY  Q#TG               (88)  TGPS\n         TITLE '--- QUEUE--CROSS REFERENCE ---'\n         PRINT GEN\n         SPACE 2\n         QCALL TYPE=XREF\n         EJECT\n         QSTACK TYPE=XREF\n         SPACE 2\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "Q##END": {"ttr": 2318, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x00\\x00\\x00\\x00\\x82#/\\x00\\x82#/\\x14R\\x00\\x01\\x00\\x01\\x00\\x00\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "05.00", "flags": 0, "createdate": "1982-08-20T00:00:00", "modifydate": "1982-08-20T14:52:00", "lines": 1, "newlines": 1, "modlines": 0, "user": "LDW"}, "text": "         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "Q##MXREF": {"ttr": 2320, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x84\"\\x0f\\x00\\x84\"\\x0f \\'\\x00\\x04\\x00\\x04\\x00\\x00\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1984-08-07T00:00:00", "modifydate": "1984-08-07T20:27:00", "lines": 4, "newlines": 4, "modlines": 0, "user": "LDW"}, "text": "QUEUE    TITLE '-----  TSO COMMAND TO DISPLAY JES2 SPOOL INFO  -----'\n         COPY  QGLOBALS                 GET OPTION VARIABLES\n         MHELP 1\n         PRINT OFF\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "Q##TITLE": {"ttr": 2322, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x83\\x00?\\x00\\x91\\x18_#V\\x00\\x06\\x00\\x02\\x00\\x05\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1983-01-03T00:00:00", "modifydate": "1991-07-04T23:56:00", "lines": 6, "newlines": 2, "modlines": 5, "user": "LDW"}, "text": "QUEUE    TITLE '-----  TSO COMMAND TO DISPLAY JES2 SPOOL INFO  -----'\n         PUSH  PRINT                                           Q##TITLE\n*--->    COPY  QGLOBALS                 GET OPTION VARIABLES   Q##TITLE\n         PRINT OFF                                             Q##TITLE\n         COPY  QGLOBALS                 GET OPTION VARIABLES   Q##TITLE\n         POP   PRINT                                           Q##TITLE\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "Q#AF": {"ttr": 2324, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x17\\x00\\x00\\x00\\x83\\x01?\\x00\\x91\\x18_ 3\\x01\\xbc\\x00C\\x01\\xab\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.23", "flags": 0, "createdate": "1983-01-13T00:00:00", "modifydate": "1991-07-04T20:33:00", "lines": 444, "newlines": 67, "modlines": 427, "user": "LDW"}, "text": "         TITLE '--- QUEUE--AUTHFUNC -- CHANGE AUTHORIZED STATES ---'\n*---------------------------------------------------------------------*\n*                                                                     *\n*   AUTHFUNC - Test, set, reset APF authorization, switch PSW key     *\n*              or mode                                                *\n*                                                                     *\n*   Entry - R1 = 0 ==> invalid entry code                             *\n*              = 4 ==> get APF authorized if not                      *\n*              = 8 ==> reset APF if we set it                         *\n*              = 12 ==> switch to key zero                            *\n*              = 16 ==> switch to key non-zero                        *\n*              = 20 ==> switch to supervisor state                    *\n*              = 24 ==> switch to problem state                       *\n*         - If the entry code in R1 is negative, the function indi-   *\n*           cated by the complement of R1 is performed conditionally. *\n*                                                                     *\n*   Exit - R15 = 0 ==> success                                        *\n*              = 4 ==> unable to perform function                     *\n*                                                                     *\n*   Updates:                                                          *\n*      17Jun91  LDW  Check IKJEFTSR return code instead of QXAPFFL    *\n*                       silliness                                     *\n*      17Apr91  LDW  Don't use TSO/E service routine if TSO/E is not  *\n*                       installed (ref @GLOBALS).  (If you're running *\n*                       a release of JES2 such that QUEUE needs APF   *\n*                       authorization,  and you want to use the ISPF  *\n*                       interface, you're on your own.)               *\n*      14Apr91  LDW  Fix QXAPFFL logic so we don't S0C4 if QAUTH      *\n*                       doesn't exist (QAUTH also was changed)        *\n*      01Feb91  LDW  Change APF program name from ISRAUTH to QAUTH    *\n*      23Oct90  GLA  Don't invoke ikjeftsr if currently authorized    *\n*                    any way shape or form. Can get S378-14 otherwise.*\n*                    Things are getting crazier and crazier.          *\n*      11Oct90  GLA  Preserve current state in reset APF              *\n*      21Sep90  GLA  Merge into new base level of USC Queue.          *\n*      15May89  GLA  Previous scheme did not work. Since only 1 JSCB  *\n*                    exists for whole step (address space in this     *\n*                    case), when parallel structure was taken down    *\n*                    the JSCBAUTH bit was reset. So instead we will   *\n*                    reset the key in the PRB of the parallel         *\n*                    structure, thus returning in key 0.              *\n*                                                                     *\n*      13May89  GLA  Too much overhead in scheme below. Also did not  *\n*                    turn on APF authorization. Instead lets use the  *\n*                    IKJEFTSR invoked routine to set the JSCBAUTH     *\n*                    bit in the task running Q and then return. This  *\n*                    will allow ISPF services while authorized.       *\n*                    YES, this is an integrity exposure, but so was   *\n*                    the user SVC it replaces. Also there is no other *\n*                    way to invoke ISPF authorized.                   *\n*                                                                     *\n*  FISHHEADS FISHEADS,                                                *\n*       ROLLY POLLY FISHHEADS                                         *\n*  FISHHEADS FISHEADS,                                                *\n*       EAT THEM UP, YUMMMMMM                                         *\n*                                                                     *\n*      05May89  GLA  Try new tech for achieving APF authorization:    *\n*                    use the IKJEFTSR routine to invoke as authorized *\n*                    a small program that will return to the QUEUE    *\n*                    code using registers passed to it. This way      *\n*                    QUEUE will be authorized. Note however that no   *\n*                    ISPF services are available while authorized     *\n*                    because the ISPF tasks are \"STATUS STOPPED\".     *\n*                    When deauth req occurs, undo the IKJEFTSR task   *\n*                    structure and return to after the call of        *\n*                    IKJEFTSR. Then use regs saved on deauth request  *\n*                    to return to QUEUE as unauthorized.              *\n*      04Jun88  LDW  Add call types 12-24                             *\n*      24OCT86  EMS  FIX APF RESET CODE                               *\n*      03/30/86 LDW  USE &@@SCSVC INSTEAD OF &QAPFSVC                 *\n*      01/13/83 LDW  ROUTINE CREATED                                  *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 3\nAUTHFUNC QSTART WORKLEN=AF@WORKL                                21SEP90\n         USNGX WORK,R13                                         21SEP90\n         LR    R3,R1                    save entry code\n*                                                               26OCT90\n**       START DEBUGGING                                        26OCT90\n*                                                               26OCT90\n         MVC   WTPCMD(WTPCLEN-4),=CL80' '                       26OCT90\n         MVC   WTPL(4),=AL2(WTPCLEN,X'8000')                    26OCT90\n         MVC   WTPCMD,QDREPLY                                   26OCT90\n         MVC   WTPP1,QPARM1                                     26OCT90\n         MVC   WTPP2,QPARM2                                     26OCT90\n         MVC   WTPRTDSC(4),=AL2(0,X'0020')                      26OCT90\n         LPR   R1,R3          GET REAL CODE                     26OCT90\n         LA    R1,AF$TB(R1)   POINT AT STAT                     26OCT90\n         MVC   WTPSTAT,0(R1)  MOVE IN STATUS                    26OCT90\n         L     R1,4(,R13)                                       26OCT90\n         L     R1,12(,R1)     GET RETURN ADDRESS                26OCT90\n         SL    R1,=V(QUEUE)   GET OFFSET                        26OCT90\n         ST    R1,DUMCLST                                       26OCT90\n         UNPK  WTPOFFS(9),DUMCLST(5)                            26OCT90\n         MVI   WTPOFFS+8,C' '                                   26OCT90\n         TR    WTPOFFS(8),QHEXTAB                               26OCT90\n*        WTO   MF=(E,WTPL)                                      26OCT90\n         LR    R1,R3                                            26OCT90\n*                                                               26OCT90\n**       END DEBUGGING                                          26OCT90\n*                                                               26OCT90\n         LPR   R1,R1                    get a positive copy of code\n         CH    R1,=H'24'                TOO BIG?\n         BH    AF$ERR2                  YES - ABORT\n         B     *+4(R1)                  decode function request\n         B     AF$ERR1                  00 - obsolete entry code\n         B     AF$APF                   04 - set APF\n         B     AF$UNAPF                 08 - reset APF\n         B     AF$ZERO                  12 - switch to key zero\n         B     AF$NONZ                  16 - switch to key non-zero\n         B     AF$SUPR                  20 - switch to supervisor state\n         B     AF$PROB                  24 - switch to problem state\nAF$TB    DC    C'*BADAPF RAPFZEROKEY8SUPRPROB'                  26OCT90\n         SPACE 3\nAF$ZERO  TM    QXAUTH,QXSUPR            are we in supervisor state?\n         BZ    AF$Z$1                   no - try to get APF\n*\n         MODESET  EXTKEY=ZERO           do it the quick way\n*\n         B     QSTOP00\n         SPACE 1\nAF$Z$1   TM    QXAUTH,QXAPFSET          IS APF ALREADY SET      26OCT90\n         BZ    AF$Z$2                   NO SO SET IT            26OCT90\n         MODESET KEY=ZERO               USE MVS SINCE AUTH'ED   26OCT90\n         B     QSTOP00                  DONE                    26OCT90\n         SPACE 1                                                26OCT90\nAF$Z$2   LA    R1,4                     try to get APF authorized\n         LTR   R3,R3                    original request conditional?\n         BNM   *+6                      no - ok\n         LNR   R1,R1                    yes - make this conditional\n         QCALL AUTHFUNC                 recursive!\n         LTR   R15,R15                  ok?\n         BNZ   QSTOPRC                  no - return to caller\n*\n         MODESET  KEY=ZERO\n*\n         LA    R1,8                     unset it if necessary\n         QCALL AUTHFUNC                 recursive!\n         B     QSTOP00\n         SPACE 3\nAF$NONZ  TM    QXAUTH,QXSUPR            are we in supervisor state?\n         BZ    AF$N$1                   no - try to get APF\n*\n         MODESET  EXTKEY=&@@QXKEY       do it the quick way\n*\n         B     QSTOP00\n         SPACE 1\nAF$N$1   TM    QXAUTH,QXAPFSET          IS APF ALREADY SET      26OCT90\n         BZ    AF$N$2                   NO SO SET IT            26OCT90\n         MODESET KEY=NZERO              USE MVS SINCE AUTH'ED   26OCT90\n         B     QSTOP00                  DONE                    26OCT90\n         SPACE 1                                                26OCT90\nAF$N$2   LA    R1,4                     try to get APF authorized\n         LTR   R3,R3                    original request conditional?\n         BNM   *+6                      no - ok\n         LNR   R1,R1                    yes - make this conditional\n         QCALL AUTHFUNC                 recursive!\n         LTR   R15,R15                  ok?\n         BNZ   QSTOPRC                  no - return to caller\n*\n         MODESET  KEY=NZERO\n*\n         LA    R1,8                     unset it if necessary\n         QCALL AUTHFUNC                 recursive!\n         B     QSTOP00\n         SPACE 3\nAF$SUPR  TM    QXAUTH,QXSUPR            are we in supervisor state?\n         BNZ   QSTOP00                  yes - don't change anything\n         TM    QXAUTH,QXAPFSET          IS APF ALREADY SET      26OCT90\n         BZ    AF$S$2                   NO SO SET IT            26OCT90\n         MODESET MODE=SUP               USE MVS SINCE AUTH'ED   26OCT90\n         B     QSTOP00                  DONE                    26OCT90\n         SPACE 1                                                26OCT90\nAF$S$2   LA    R1,4                     try to get APF authorized\n         LTR   R3,R3                    original request conditional?\n         BNM   *+6                      no - ok\n         LNR   R1,R1                    yes - make this conditional\n         QCALL AUTHFUNC                 recursive!\n         LTR   R15,R15                  ok?\n         BNZ   QSTOPRC                  no - return to caller\n*\n         MODESET  MODE=SUP\n*\n         LA    R1,8                     unset it if necessary\n         QCALL AUTHFUNC                 recursive!\n         B     QSTOP00\n         SPACE 3\nAF$PROB  TM    QXAUTH,QXSUPR            did we start in supervisor st?\n         BNZ   QSTOP00                  yes - don't change back\n         TM    QXAUTH,QXAPFSET          IS APF ALREADY SET      26OCT90\n         BZ    AF$P$2                   NO SO SET IT            26OCT90\n         MODESET MODE=PROB              USE MVS SINCE AUTH'ED   26OCT90\n         B     QSTOP00                  DONE                    26OCT90\n         SPACE 1                                                26OCT90\nAF$P$2   LA    R1,4                     try to get APF authorized\n         LTR   R3,R3                    original request conditional?\n         BNM   *+6                      no - ok\n         LNR   R1,R1                    yes - make this conditional\n         QCALL AUTHFUNC                 recursive!\n         LTR   R15,R15                  ok?\n         BNZ   QSTOPRC                  no - return to caller\n*\n         MODESET  MODE=PROB\n*\n         LA    R1,8                     unset it if necessary\n         QCALL AUTHFUNC                 recursive!\n         B     QSTOP00\n         SPACE 3\nAF$APF   EQU   *\n**       TESTAUTH  FCTN=1               ASK MVS IF WE ARE APF AUTH\n         SPACE 1\n**       LTR   R15,R15                  ARE WE?\n**       BZ    QSTOPRC                  YES - RETURN WITH RC=0\n         TM    QXAUTH,QXAPFENT          are we running APF authorized?\n         BNZ   QSTOP00                  yes - return with RC=0\n*%%       AIF   (&@@SCSVC EQ 0).APF01    SKIP IF APF SVC NOT PROVIDED\n*%%      QAPF  SET                      ATTEMPT TO SET IT\n*%%      SPACE 1\n*%%      TESTAUTH  FCTN=1               SEE IF IT WORKED\n*%%      SPACE 1\n*%%      OI    QXAUTH,QXAPFSET          ASSUME IT WORKED\n*%%      LTR   R15,R15                  DID IT?\n*%%      BZ    QSTOPRC                  YES - RETURN WITH RC=0\n*%%      NI    QXAUTH,255-QXAPFSET      NO - RESET INDICATOR\n*%%F01    ANOP\n         B     APFTSR                   Use TSR to Authorize    21SEP90\n         LTR   R15,R3                   WHAT WAS REQUESTED FUNCTION?\n         BNZ   QSTOPRC                  RETURN WITH RC=4 FOR ENTRY=4\n         QTILT '*** QUEUE IS NOT RUNNING APF AUTHORIZED ***'\n         SPACE 2\nAF$UNAPF TESTAUTH  FCTN=1               CURRENTLY APF AUTHORIZED?\n         SPACE 1\n         LTR   R15,R15                  WELL?\n         BNZ   AF$ERR3                  NO - ERROR\n         TM    QXAUTH,QXAPFSET          DID WE SET IT ON?\n         BNO   QSTOPRC                  NO - LEAVE IT ON\n         B     APFTSRRS                 Use TSR to Authorize    21SEP90\n*%%       AIF   (&@@SCSVC EQ 0).APF02    SKIP IF APF SVC NOT PROVIDED\n*%%      QAPF  RESET                    TURN IT OFF\n*%%      SPACE 1\n*%%      TESTAUTH  FCTN=1               SEE IF IT WENT OFF\n*%%      SPACE 1\n*%%      LTR   R15,R15                  DID IT?\n*%%      BNZ   QSTOP                    YES - RETURN WITH RC=0\n*%%      L     R0,=C'AF4 '              SET LOGIC ERROR CODE\n*%%      L     R15,=V(LOGICERR)         -> ROUTINE\n*%%      BALR  R14,R15                  GO TO IT (NO RETURN)\n*%%      SPACE 2\n*%%       AGO   .APF03\n*%%F02    ANOP\n*%%      L     R0,=C'AF5 '              SET LOGIC ERROR CODE\n*%%      L     R15,=V(LOGICERR)         -> ROUTINE\n*%%      BALR  R14,R15                  GO TO IT (NO RETURN)\n*%%F03    ANOP\n         SPACE 2\nAF$ERR1  L     R0,=C'AF1 '              SET LOGIC ERROR CODE\n         L     R15,=V(LOGICERR)         -> ROUTINE\n         BALR  R14,R15                  GO TO IT (NO RETURN)\n         SPACE 2\nAF$ERR2  L     R0,=C'AF2 '              SET LOGIC ERROR CODE\n         L     R15,=V(LOGICERR)         -> ROUTINE\n         BALR  R14,R15                  GO TO IT (NO RETURN)\n         SPACE 2\nAF$ERR3  L     R0,=C'AF3 '              SET LOGIC ERROR CODE\n         L     R15,=V(LOGICERR)         -> ROUTINE\n         BALR  R14,R15                  GO TO IT (NO RETURN)\n         SPACE 2\n         LTORG ,\n***********************************************************************\n*                                                                     *\n*  INVOKE IKJEFTSR TO MAKE AUTHORIZED BY REENTERING AT APFTCB         *\n*                                                                     *\n***********************************************************************\nAPFTSR   DS    0H\n         TESTAUTH FCTN=0,STATE=NO,KEY=YES,RBLEVEL=1,BRANCH=NO   23OCT90\n         LTR   R15,R15                  Are we currently key=0  23OCT90\n         BZ    AF$JSET                  A. if yes just set APF  23OCT90\n*                                                               23OCT90\n**       We are definitely not KEY=0 here, so if SUPR state     23OCT90\n**       then don't invoke IKJEFTSR                             23OCT90\n*                                                               23OCT90\n         TESTAUTH FCTN=0,STATE=YES,KEY=NO,RBLEVEL=1,BRANCH=NO   23OCT90\n         LTR   R15,R15                  Are we supr state       23OCT90\n         BZ    AF$FUDG                  A. if yes fudge it      23OCT90\n*                                                               23OCT90\n**       At this point we are KEY=8 and PROB state, so use      23OCT90\n**       IKJEFTSR to get KEY=0 to set APF authorization.        23OCT90\n*                                                               23OCT90\n          AIF   (&@@TSOE NE 0).AF010\n         B     APF$FL                   go to APF failure routine\n          AGO   .AF020\n.AF010    ANOP\n         USNGX PSA,R0\n         L     R1,PSATOLD               get current TCB address\n         L     R1,TCBRBP-TCB(,R1)       get RB pointer\n         ST    R1,QAPFR13               save RB address\n         MVC   QNAME,=CL8'QAUTH'\n         MVC   QDUMHDR+2(2),=H'4'       set length\n         MVC   QPRMHDR+2(2),=AL2(QPRMLEN) set length\n         MVC   QDUM1,=F'-1'             set parm to show not CPPL\n         LA    R1,QDUMHDR+2             point at second parms\n         LA    R2,QPRMHDR+2             point at first parms\n         STM   R1,R2,DUMCLST            create parm list\n         OI    DUMCLST+4,X'80'          set end indicator\n         ST    R11,QPRM1                save addr of QCOMMON\n         LA    R1,APFTCB                get addr of routine\n         ST    R1,QPRM2                 save addr of return regs\n         L     R15,CVTPTR\n         L     R15,CVTTVT-CVT(,R15)\n         L     R15,TSVTASF-TSVT(,R15)\n         CALL  (15),                                                   X\n               (FLAGS,QNAME,BUFLEN,RETCODE,RSNCODE,ABNDCODE,DUMCLST),  X\n               VL,MF=(E,QAPFSV)\n         LTR   R15,R15                  did TSR or QAUTH fail?\n         BNZ   APF$FL                   yes - so issue msg or rtn\n** if successful then we are in key zero\n         L     R1,PSATOLD               get current TCB address\n         L     R1,TCBJSCB-TCB(,R1)      get the JSCB address\n         USNGX IEZJSCB,R1     BASE IT\n         OI    JSCBOPTS,JSCBAUTH        set authorization on\n         DROPX R1             BASE IT\n         MODESET KEY=NZERO,MODE=PROB\n         OI    QXAUTH,QXAPFSET          show we set auth on\n         B     QSTOP00                  now exit with rc=0\n.AF020    ANOP\n         SPACE 3\nAF$JSET  L     R1,PSATOLD               get current TCB address 23OCT90\n         L     R1,TCBJSCB-TCB(,R1)      get the JSCB address    23OCT90\n         USNGX IEZJSCB,R1     BASE IT                           23OCT90\n         OI    JSCBOPTS,JSCBAUTH        set authorization on    23OCT90\n         DROPX R1             BASE IT                           23OCT90\n         OI    QXAUTH,QXAPFSET          show we set auth on     23OCT90\n         B     QSTOP00                  now exit with rc=0      23OCT90\n         SPACE 3                                                23OCT90\nAF$FUDG  DS    0H                                               23OCT90\n         MODESET KEY=ZERO               set the key             23OCT90\n         L     R1,PSATOLD               get current TCB address 23OCT90\n         L     R1,TCBJSCB-TCB(,R1)      get the JSCB address    23OCT90\n         USNGX IEZJSCB,R1     BASE IT                           23OCT90\n         OI    JSCBOPTS,JSCBAUTH        set authorization on    23OCT90\n         DROPX R1             BASE IT                           23OCT90\n         MODESET KEY=NZERO              reset the key           23OCT90\n         OI    QXAUTH,QXAPFSET          show we set auth on     23OCT90\n         B     QSTOP00                  now exit with rc=0      23OCT90\n         SPACE 3                                                23OCT90\n***********************************************************************\n*                                                                     *\n*  TO DEAUTHORIZE, JUST TURN OFF BIT IN JFCB                          *\n*                                                                     *\n***********************************************************************\nAPFTSRRS DS    0H\n         TESTAUTH FCTN=0,STATE=YES,KEY=NO,RBLEVEL=1,BRANCH=NO   11OCT90\n         LR    R5,R15                                           11OCT90\n         TESTAUTH FCTN=0,STATE=NO,KEY=YES,RBLEVEL=1,BRANCH=NO   11OCT90\n         LR    R6,R15\n         MODESET KEY=ZERO,MODE=SUP\n         L     R1,PSATOLD               get current TCB address\n         L     R1,TCBJSCB-TCB(,R1)      get the JSCB address\n         USNGX IEZJSCB,R1     BASE IT\n         NI    JSCBOPTS,X'FF'-JSCBAUTH  set authorization off\n         DROPX R1             BASE IT\n         LTR   R5,R5                    need to reset mode ??   11OCT90\n         BZ    APFTSRR1                                         11OCT90\n         MODESET MODE=PROB              reset to problem mode   11OCT90\nAPFTSRR1 LTR   R6,R6                    need to reset key ??    11OCT90\n         BZ    APFTSRR2                                         11OCT90\n         MODESET KEY=NZERO              reset to tcb key        11OCT90\nAPFTSRR2 DS    0H                                               11OCT90\n*        MODESET KEY=NZERO,MODE=PROB\n         NI    QXAUTH,255-QXAPFSET      reset\n         B     QSTOP00                  now exit with rc=0\n         DROPX R0\n         SPACE 3\n***********************************************************************\n*                                                                     *\n*  IKJEFTSR failed to cause authorization, so issue message           *\n*                                                                     *\n***********************************************************************\nAPF$FL   DS    0H\n         NI    QXAUTH,255-QXAPFSET      reset flags\n         LTR   R15,R3                   check entry code\n         BNZ   QSTOPRC                  set rc if only checking\n         QTILT '*** QUEUE IS NOT RUNNING APF AUTHORIZED ***'\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*  This code is invoked by QAUTH and will set authorization on        *\n*                                                                     *\n***********************************************************************\nAPFTCB   BALR  R12,0\n         DROPX R12\n         USNGX *,R12\n         MODESET KEY=ZERO,MODE=SUP\n         L     R1,QAPFR13               get address of rb\n         NI    17(R1),X'0F'             set key to zero\n         RETURN (14,12),RC=0\n         SPACE 3\n***********************************************************************\n*                                                                     *\n*  MISCELLANY                                                         *\n*                                                                     *\n***********************************************************************\nFLAGS    DC    X'00000102'              Flags for IKJEFTSR\nBUFLEN   DC    F'8'                     Length of buffer\n         LTORG ,\n         DROPX R13                                              21SEP90\n         SPACE 3\n         QCOMMON\n***********************************************************************\n*                                                                     *\n*  GENERATE CONTROL BLOCK DSECTS                                      *\n*                                                                     *\n***********************************************************************\nWORK     DSECT\n         ORG   WORK+72\nQDUMHDR  DS    H,H     LENGTH      ***\nQDUM1    DS    F       F'-1'       *\nQPRMHDR  DS    H,H     LENGTH      *  keep together\nQPRM1    DS    A       QCOMMON     *\nQPRM2    DS    A       R13 APF CL  ***\nQPRMLEN  EQU   *-QPRM1             length of parms\nDUMCLST  DS    2F                  CALL PARM LIST\nRETCODE  DS    F                        Function return code\nRSNCODE  DS    F                        IKJEFTSR reason code\nABNDCODE DS    F                        IKJEFTSR abend code\nQNAME    DS    CL8                 ADDRESS OF Q LOAD MODULE NAME\n*                                                               26OCT90\n**       DEBUGGING WTP                                          26OCT90\n*                                                               26OCT90\nWTPL     DS    F                                                26OCT90\nWTPLINE  DS    0C                                               26OCT90\nWTPSTAT  DS    CL4,C                                            26OCT90\nWTPOFFS  DS    CL8,C                                            26OCT90\nWTPCMD   DS    CL8,C                                            26OCT90\nWTPP1    DS    CL8,C                                            26OCT90\nWTPP2    DS    CL8,C                                            26OCT90\nWTPCLEN  EQU   *-WTPL                                           26OCT90\nWTPRTDSC DS    AL4                                              26OCT90\nAF@WORKL EQU   *-WORK\n         QZCVT\n         QZTSVT\n         QZPSA\n         QZTCB\n         QZJSCB\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "Q#AF@@": {"ttr": 2566, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x08\\x00\\x00\\x00\\x83\\x01?\\x00\\x89\\x15_\"2\\x00\\xaf\\x00C\\x00\\x00\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.08", "flags": 0, "createdate": "1983-01-13T00:00:00", "modifydate": "1989-06-04T22:32:00", "lines": 175, "newlines": 67, "modlines": 0, "user": "LDW"}, "text": "         TITLE '--- QUEUE--AUTHFUNC -- CHANGE AUTHORIZED STATES ---'\n*---------------------------------------------------------------------*\n*                                                                     *\n*   AUTHFUNC - Test, set, reset APF authorization, switch PSW key     *\n*              or mode                                                *\n*                                                                     *\n*   Entry - R1 = 0 ==> invalid entry code                             *\n*              = 4 ==> get APF authorized if not                      *\n*              = 8 ==> reset APF if we set it                         *\n*              = 12 ==> switch to key zero                            *\n*              = 16 ==> switch to key non-zero                        *\n*              = 20 ==> switch to supervisor state                    *\n*              = 24 ==> switch to problem state                       *\n*         - If the entry code in R1 is negative, the function indi-   *\n*           cated by the complement of R1 is performed conditionally. *\n*                                                                     *\n*   Exit - R15 = 0 ==> success                                        *\n*              = 4 ==> unable to perform function                     *\n*                                                                     *\n*   Updates:                                                          *\n*      04Jun88  LDW  Add call types 12-24                             *\n*      24OCT86  EMS  FIX APF RESET CODE                               *\n*      03/30/86 LDW  USE &@@SCSVC INSTEAD OF &QAPFSVC                 *\n*      01/13/83 LDW  ROUTINE CREATED                                  *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 3\nAUTHFUNC QSTART\n         LR    R3,R1                    save entry code\n         LPR   R1,R1                    get a positive copy of code\n         CH    R1,=H'24'                TOO BIG?\n         BH    AF$ERR2                  YES - ABORT\n         B     *+4(R1)                  decode function request\n         B     AF$ERR1                  00 - obsolete entry code\n         B     AF$APF                   04 - set APF\n         B     AF$UNAPF                 08 - reset APF\n         B     AF$ZERO                  12 - switch to key zero\n         B     AF$NONZ                  16 - switch to key non-zero\n         B     AF$SUPR                  20 - switch to supervisor state\n         B     AF$PROB                  24 - switch to problem state\n         SPACE 3\nAF$ZERO  TM    QXAUTH,QXSUPR            are we in supervisor state?\n         BZ    AF$Z$1                   no - try to get APF\n*\n         MODESET  EXTKEY=ZERO           do it the quick way\n*\n         B     QSTOP00\n         SPACE 1\nAF$Z$1   LA    R1,4                     try to get APF authorized\n         LTR   R3,R3                    original request conditional?\n         BNM   *+6                      no - ok\n         LNR   R1,R1                    yes - make this conditional\n         QCALL AUTHFUNC                 recursive!\n         LTR   R15,R15                  ok?\n         BNZ   QSTOPRC                  no - return to caller\n*\n         MODESET  KEY=ZERO\n*\n         LA    R1,8                     unset it if necessary\n         QCALL AUTHFUNC                 recursive!\n         B     QSTOP00\n         SPACE 3\nAF$NONZ  TM    QXAUTH,QXSUPR            are we in supervisor state?\n         BZ    AF$N$1                   no - try to get APF\n*\n         MODESET  EXTKEY=&QEXKEY        do it the quick way\n*\n         B     QSTOP00\n         SPACE 1\nAF$N$1   LA    R1,4                     try to get APF authorized\n         LTR   R3,R3                    original request conditional?\n         BNM   *+6                      no - ok\n         LNR   R1,R1                    yes - make this conditional\n         QCALL AUTHFUNC                 recursive!\n         LTR   R15,R15                  ok?\n         BNZ   QSTOPRC                  no - return to caller\n*\n         MODESET  KEY=NZERO\n*\n         LA    R1,8                     unset it if necessary\n         QCALL AUTHFUNC                 recursive!\n         B     QSTOP00\n         SPACE 3\nAF$SUPR  TM    QXAUTH,QXSUPR            are we in supervisor state?\n         BNZ   QSTOP00                  yes - don't change anything\n         LA    R1,4                     try to get APF authorized\n         LTR   R3,R3                    original request conditional?\n         BNM   *+6                      no - ok\n         LNR   R1,R1                    yes - make this conditional\n         QCALL AUTHFUNC                 recursive!\n         LTR   R15,R15                  ok?\n         BNZ   QSTOPRC                  no - return to caller\n*\n         MODESET  MODE=SUP\n*\n         LA    R1,8                     unset it if necessary\n         QCALL AUTHFUNC                 recursive!\n         B     QSTOP00\n         SPACE 3\nAF$PROB  TM    QXAUTH,QXSUPR            did we start in supervisor st?\n         BNZ   QSTOP00                  yes - don't change back\n         LA    R1,4                     try to get APF authorized\n         LTR   R3,R3                    original request conditional?\n         BNM   *+6                      no - ok\n         LNR   R1,R1                    yes - make this conditional\n         QCALL AUTHFUNC                 recursive!\n         LTR   R15,R15                  ok?\n         BNZ   QSTOPRC                  no - return to caller\n*\n         MODESET  MODE=PROB\n*\n         LA    R1,8                     unset it if necessary\n         QCALL AUTHFUNC                 recursive!\n         B     QSTOP00\n         SPACE 3\nAF$APF   EQU   *\n**       TESTAUTH  FCTN=1               ASK MVS IF WE ARE APF AUTH\n         SPACE 1\n**       LTR   R15,R15                  ARE WE?\n**       BZ    QSTOPRC                  YES - RETURN WITH RC=0\n         TM    QXAUTH,QXAPFENT          are we running APF authorized?\n         BNZ   QSTOP00                  yes - return with RC=0\n          AIF   (&@@SCSVC EQ 0).APF01    SKIP IF APF SVC NOT PROVIDED\n         QAPF  SET                      ATTEMPT TO SET IT\n         SPACE 1\n         TESTAUTH  FCTN=1               SEE IF IT WORKED\n         SPACE 1\n         OI    QXAUTH,QXAPFSET          ASSUME IT WORKED\n         LTR   R15,R15                  DID IT?\n         BZ    QSTOPRC                  YES - RETURN WITH RC=0\n         NI    QXAUTH,255-QXAPFSET      NO - RESET INDICATOR\n.APF01    ANOP\n         LTR   R15,R3                   WHAT WAS REQUESTED FUNCTION?\n         BNZ   QSTOPRC                  RETURN WITH RC=4 FOR ENTRY=4\n         QTILT '*** QUEUE IS NOT RUNNING APF AUTHORIZED ***'\n         SPACE 2\nAF$UNAPF TESTAUTH  FCTN=1               CURRENTLY APF AUTHORIZED?\n         SPACE 1\n         LTR   R15,R15                  WELL?\n         BNZ   AF$ERR3                  NO - ERROR\n         TM    QXAUTH,QXAPFSET          DID WE SET IT ON?\n         BNO   QSTOPRC                  NO - LEAVE IT ON\n          AIF   (&@@SCSVC EQ 0).APF02    SKIP IF APF SVC NOT PROVIDED\n         QAPF  RESET                    TURN IT OFF\n         SPACE 1\n         TESTAUTH  FCTN=1               SEE IF IT WENT OFF\n         SPACE 1\n         LTR   R15,R15                  DID IT?\n         BNZ   QSTOP                    YES - RETURN WITH RC=0\n         L     R0,=C'AF4 '              SET LOGIC ERROR CODE\n         L     R15,=V(LOGICERR)         -> ROUTINE\n         BALR  R14,R15                  GO TO IT (NO RETURN)\n         SPACE 2\n          AGO   .APF03\n.APF02    ANOP\n         L     R0,=C'AF5 '              SET LOGIC ERROR CODE\n         L     R15,=V(LOGICERR)         -> ROUTINE\n         BALR  R14,R15                  GO TO IT (NO RETURN)\n.APF03    ANOP\n         SPACE 2\nAF$ERR1  L     R0,=C'AF1 '              SET LOGIC ERROR CODE\n         L     R15,=V(LOGICERR)         -> ROUTINE\n         BALR  R14,R15                  GO TO IT (NO RETURN)\n         SPACE 2\nAF$ERR2  L     R0,=C'AF2 '              SET LOGIC ERROR CODE\n         L     R15,=V(LOGICERR)         -> ROUTINE\n         BALR  R14,R15                  GO TO IT (NO RETURN)\n         SPACE 2\nAF$ERR3  L     R0,=C'AF3 '              SET LOGIC ERROR CODE\n         L     R15,=V(LOGICERR)         -> ROUTINE\n         BALR  R14,R15                  GO TO IT (NO RETURN)\n         SPACE 2\n         LTORG ,\n         SPACE 3\n         QCOMMON\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "Q#AFX": {"ttr": 2570, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x16\\x00\\x00\\x00\\x83\\x01?\\x00\\x91\\x17\\x0f!P\\x01\\xe3\\x00C\\x01\\xd2\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.22", "flags": 0, "createdate": "1983-01-13T00:00:00", "modifydate": "1991-06-19T21:50:00", "lines": 483, "newlines": 67, "modlines": 466, "user": "LDW"}, "text": "         TITLE '--- QUEUE--AUTHFUNC -- CHANGE AUTHORIZED STATES ---'\n*---------------------------------------------------------------------*\n*                                                                     *\n*   AUTHFUNC - Test, set, reset APF authorization, switch PSW key     *\n*              or mode                                                *\n*                                                                     *\n*   Entry - R1 = 0 ==> invalid entry code                             *\n*              = 4 ==> get APF authorized if not                      *\n*              = 8 ==> reset APF if we set it                         *\n*              = 12 ==> switch to key zero                            *\n*              = 16 ==> switch to key non-zero                        *\n*              = 20 ==> switch to supervisor state                    *\n*              = 24 ==> switch to problem state                       *\n*         - If the entry code in R1 is negative, the function indi-   *\n*           cated by the complement of R1 is performed conditionally. *\n*                                                                     *\n*   Exit - R15 = 0 ==> success                                        *\n*              = 4 ==> unable to perform function                     *\n*                                                                     *\n*   Updates:                                                          *\n*      19Jun91  LDW  Check IKJEFTSR return code instead of QXAPFFL    *\n*                       silliness                                     *\n*      17Apr91  LDW  Don't use TSO/E service routine if TSO/E is not  *\n*                       installed (ref @GLOBALS).  (If you're running *\n*                       a release of JES2 such that QUEUE needs APF   *\n*                       authorization,  and you want to use the ISPF  *\n*                       interface, you're on your own.)               *\n*      14Apr91  LDW  Fix QXAPFFL logic so we don't S0C4 if QAUTH      *\n*                       doesn't exist (QAUTH also was changed)        *\n*      01Feb91  LDW  Change APF program name from ISRAUTH to QAUTH    *\n*      23Oct90  GLA  Don't invoke ikjeftsr if currently authorized    *\n*                    any way shape or form. Can get S378-14 otherwise.*\n*                    Things are getting crazier and crazier.          *\n*      11Oct90  GLA  Preserve current state in reset APF              *\n*      21Sep90  GLA  Merge into new base level of USC Queue.          *\n*      15May89  GLA  Previous scheme did not work. Since only 1 JSCB  *\n*                    exists for whole step (address space in this     *\n*                    case), when parallel structure was taken down    *\n*                    the JSCBAUTH bit was reset. So instead we will   *\n*                    reset the key in the PRB of the parallel         *\n*                    structure, thus returning in key 0.              *\n*                                                                     *\n*      13May89  GLA  Too much overhead in scheme below. Also did not  *\n*                    turn on APF authorization. Instead lets use the  *\n*                    IKJEFTSR invoked routine to set the JSCBAUTH     *\n*                    bit in the task running Q and then return. This  *\n*                    will allow ISPF services while authorized.       *\n*                    YES, this is an integrity exposure, but so was   *\n*                    the user SVC it replaces. Also there is no other *\n*                    way to invoke ISPF authorized.                   *\n*                                                                     *\n*  FISHHEADS FISHEADS,                                                *\n*       ROLLY POLLY FISHHEADS                                         *\n*  FISHHEADS FISHEADS,                                                *\n*       EAT THEM UP, YUMMMMMM                                         *\n*                                                                     *\n*      05May89  GLA  Try new tech for achieving APF authorization:    *\n*                    use the IKJEFTSR routine to invoke as authorized *\n*                    a small program that will return to the QUEUE    *\n*                    code using registers passed to it. This way      *\n*                    QUEUE will be authorized. Note however that no   *\n*                    ISPF services are available while authorized     *\n*                    because the ISPF tasks are \"STATUS STOPPED\".     *\n*                    When deauth req occurs, undo the IKJEFTSR task   *\n*                    structure and return to after the call of        *\n*                    IKJEFTSR. Then use regs saved on deauth request  *\n*                    to return to QUEUE as unauthorized.              *\n*      04Jun88  LDW  Add call types 12-24                             *\n*      24OCT86  EMS  FIX APF RESET CODE                               *\n*      03/30/86 LDW  USE &@@SCSVC INSTEAD OF &QAPFSVC                 *\n*      01/13/83 LDW  ROUTINE CREATED                                  *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 3\nAUTHFUNC QSTART WORKLEN=AF@WORKL                                21SEP90\n         USNGX WORK,R13                                         21SEP90\n         LR    R3,R1                    save entry code\n*                                                               26OCT90\n**       START DEBUGGING                                        26OCT90\n*                                                               26OCT90\n         MVC   WTPCMD(WTPCLEN-4),=CL80' '                       26OCT90\n         MVC   WTPL(4),=AL2(WTPCLEN,X'8000')                    26OCT90\n         MVC   WTPCMD,QDREPLY                                   26OCT90\n         MVC   WTPP1,QPARM1                                     26OCT90\n         MVC   WTPP2,QPARM2                                     26OCT90\n         MVC   WTPRTDSC(4),=AL2(0,X'0020')                      26OCT90\n         LPR   R1,R3          GET REAL CODE                     26OCT90\n         LA    R1,AF$TB(R1)   POINT AT STAT                     26OCT90\n         MVC   WTPSTAT,0(R1)  MOVE IN STATUS                    26OCT90\n         L     R1,4(,R13)                                       26OCT90\n         L     R1,12(,R1)     GET RETURN ADDRESS                26OCT90\n         SL    R1,=V(QUEUE)   GET OFFSET                        26OCT90\n         ST    R1,DUMCLST                                       26OCT90\n         UNPK  WTPOFFS(9),DUMCLST(5)                            26OCT90\n         MVI   WTPOFFS+8,C' '                                   26OCT90\n         TR    WTPOFFS(8),QHEXTAB                               26OCT90\n*        WTO   MF=(E,WTPL)                                      26OCT90\n         LR    R1,R3                                            26OCT90\n*                                                               26OCT90\n**       END DEBUGGING                                          26OCT90\n*                                                               26OCT90\n         LPR   R1,R1                    get a positive copy of code\n         CH    R1,=H'24'                TOO BIG?\n         BH    AF$ERR2                  YES - ABORT\n         B     *+4(R1)                  decode function request\n         B     AF$ERR1                  00 - obsolete entry code\n         B     AF$APF                   04 - set APF\n         B     AF$UNAPF                 08 - reset APF\n         B     AF$ZERO                  12 - switch to key zero\n         B     AF$NONZ                  16 - switch to key non-zero\n         B     AF$SUPR                  20 - switch to supervisor state\n         B     AF$PROB                  24 - switch to problem state\nAF$TB    DC    C'*BADAPF RAPFZEROKEY8SUPRPROB'                  26OCT90\n         SPACE 3\nAF$ZERO  TM    QXAUTH,QXSUPR            are we in supervisor state?\n         BZ    AF$Z$1                   no - try to get APF\n*\n         MODESET  EXTKEY=ZERO           do it the quick way\n*\n         B     QSTOP00\n         SPACE 1\nAF$Z$1   TM    QXAUTH,QXAPFSET          IS APF ALREADY SET      26OCT90\n         BZ    AF$Z$2                   NO SO SET IT            26OCT90\n         MODESET KEY=ZERO               USE MVS SINCE AUTH'ED   26OCT90\n         B     QSTOP00                  DONE                    26OCT90\n         SPACE 1                                                26OCT90\nAF$Z$2   LA    R1,4                     try to get APF authorized\n         LTR   R3,R3                    original request conditional?\n         BNM   *+6                      no - ok\n         LNR   R1,R1                    yes - make this conditional\n         QCALL AUTHFUNC                 recursive!\n         LTR   R15,R15                  ok?\n         BNZ   QSTOPRC                  no - return to caller\n*\n         MODESET  KEY=ZERO\n*\n         LA    R1,8                     unset it if necessary\n         QCALL AUTHFUNC                 recursive!\n         B     QSTOP00\n         SPACE 3\nAF$NONZ  TM    QXAUTH,QXSUPR            are we in supervisor state?\n         BZ    AF$N$1                   no - try to get APF\n*\n         MODESET  EXTKEY=&QEXKEY        do it the quick way\n*\n         B     QSTOP00\n         SPACE 1\nAF$N$1   TM    QXAUTH,QXAPFSET          IS APF ALREADY SET      26OCT90\n         BZ    AF$N$2                   NO SO SET IT            26OCT90\n         MODESET KEY=NZERO              USE MVS SINCE AUTH'ED   26OCT90\n         B     QSTOP00                  DONE                    26OCT90\n         SPACE 1                                                26OCT90\nAF$N$2   LA    R1,4                     try to get APF authorized\n         LTR   R3,R3                    original request conditional?\n         BNM   *+6                      no - ok\n         LNR   R1,R1                    yes - make this conditional\n         QCALL AUTHFUNC                 recursive!\n         LTR   R15,R15                  ok?\n         BNZ   QSTOPRC                  no - return to caller\n*\n         MODESET  KEY=NZERO\n*\n         LA    R1,8                     unset it if necessary\n         QCALL AUTHFUNC                 recursive!\n         B     QSTOP00\n         SPACE 3\nAF$SUPR  TM    QXAUTH,QXSUPR            are we in supervisor state?\n         BNZ   QSTOP00                  yes - don't change anything\n         TM    QXAUTH,QXAPFSET          IS APF ALREADY SET      26OCT90\n         BZ    AF$S$2                   NO SO SET IT            26OCT90\n         MODESET MODE=SUP               USE MVS SINCE AUTH'ED   26OCT90\n         B     QSTOP00                  DONE                    26OCT90\n         SPACE 1                                                26OCT90\nAF$S$2   LA    R1,4                     try to get APF authorized\n         LTR   R3,R3                    original request conditional?\n         BNM   *+6                      no - ok\n         LNR   R1,R1                    yes - make this conditional\n         QCALL AUTHFUNC                 recursive!\n         LTR   R15,R15                  ok?\n         BNZ   QSTOPRC                  no - return to caller\n*\n         MODESET  MODE=SUP\n*\n         LA    R1,8                     unset it if necessary\n         QCALL AUTHFUNC                 recursive!\n         B     QSTOP00\n         SPACE 3\nAF$PROB  TM    QXAUTH,QXSUPR            did we start in supervisor st?\n         BNZ   QSTOP00                  yes - don't change back\n         TM    QXAUTH,QXAPFSET          IS APF ALREADY SET      26OCT90\n         BZ    AF$P$2                   NO SO SET IT            26OCT90\n         MODESET MODE=PROB              USE MVS SINCE AUTH'ED   26OCT90\n         B     QSTOP00                  DONE                    26OCT90\n         SPACE 1                                                26OCT90\nAF$P$2   LA    R1,4                     try to get APF authorized\n         LTR   R3,R3                    original request conditional?\n         BNM   *+6                      no - ok\n         LNR   R1,R1                    yes - make this conditional\n         QCALL AUTHFUNC                 recursive!\n         LTR   R15,R15                  ok?\n         BNZ   QSTOPRC                  no - return to caller\n*\n         MODESET  MODE=PROB\n*\n         LA    R1,8                     unset it if necessary\n         QCALL AUTHFUNC                 recursive!\n         B     QSTOP00\n         SPACE 3\nAF$APF   EQU   *\n         STM   R14,R1,AF@REGS           %debug\n         TPUTX '>>> af$apf'             %debug\n         LM    R14,R1,AF@REGS           %debug\n**       TESTAUTH  FCTN=1               ASK MVS IF WE ARE APF AUTH\n         SPACE 1\n**       LTR   R15,R15                  ARE WE?\n**       BZ    QSTOPRC                  YES - RETURN WITH RC=0\n         TM    QXAUTH,QXAPFENT          are we running APF authorized?\n         BNZ   QSTOP00                  yes - return with RC=0\n         STM   R14,R1,AF@REGS           %debug\n         TPUTX '>>> \u00acqxapfent'          %debug\n         LM    R14,R1,AF@REGS           %debug\n*%%       AIF   (&@@SCSVC EQ 0).APF01    SKIP IF APF SVC NOT PROVIDED\n*%%      QAPF  SET                      ATTEMPT TO SET IT\n*%%      SPACE 1\n*%%      TESTAUTH  FCTN=1               SEE IF IT WORKED\n*%%      SPACE 1\n*%%      OI    QXAUTH,QXAPFSET          ASSUME IT WORKED\n*%%      LTR   R15,R15                  DID IT?\n*%%      BZ    QSTOPRC                  YES - RETURN WITH RC=0\n*%%      NI    QXAUTH,255-QXAPFSET      NO - RESET INDICATOR\n*%%F01    ANOP\n         B     APFTSR                   Use TSR to Authorize    21SEP90\n         LTR   R15,R3                   WHAT WAS REQUESTED FUNCTION?\n         BNZ   QSTOPRC                  RETURN WITH RC=4 FOR ENTRY=4\n         QTILT '*** QUEUE IS NOT RUNNING APF AUTHORIZED ***'\n         SPACE 2\nAF$UNAPF TESTAUTH  FCTN=1               CURRENTLY APF AUTHORIZED?\n         SPACE 1\n         LTR   R15,R15                  WELL?\n         BNZ   AF$ERR3                  NO - ERROR\n         TM    QXAUTH,QXAPFSET          DID WE SET IT ON?\n         BNO   QSTOPRC                  NO - LEAVE IT ON\n         B     APFTSRRS                 Use TSR to Authorize    21SEP90\n*%%       AIF   (&@@SCSVC EQ 0).APF02    SKIP IF APF SVC NOT PROVIDED\n*%%      QAPF  RESET                    TURN IT OFF\n*%%      SPACE 1\n*%%      TESTAUTH  FCTN=1               SEE IF IT WENT OFF\n*%%      SPACE 1\n*%%      LTR   R15,R15                  DID IT?\n*%%      BNZ   QSTOP                    YES - RETURN WITH RC=0\n*%%      L     R0,=C'AF4 '              SET LOGIC ERROR CODE\n*%%      L     R15,=V(LOGICERR)         -> ROUTINE\n*%%      BALR  R14,R15                  GO TO IT (NO RETURN)\n*%%      SPACE 2\n*%%       AGO   .APF03\n*%%F02    ANOP\n*%%      L     R0,=C'AF5 '              SET LOGIC ERROR CODE\n*%%      L     R15,=V(LOGICERR)         -> ROUTINE\n*%%      BALR  R14,R15                  GO TO IT (NO RETURN)\n*%%F03    ANOP\n         SPACE 2\nAF$ERR1  L     R0,=C'AF1 '              SET LOGIC ERROR CODE\n         L     R15,=V(LOGICERR)         -> ROUTINE\n         BALR  R14,R15                  GO TO IT (NO RETURN)\n         SPACE 2\nAF$ERR2  L     R0,=C'AF2 '              SET LOGIC ERROR CODE\n         L     R15,=V(LOGICERR)         -> ROUTINE\n         BALR  R14,R15                  GO TO IT (NO RETURN)\n         SPACE 2\nAF$ERR3  L     R0,=C'AF3 '              SET LOGIC ERROR CODE\n         L     R15,=V(LOGICERR)         -> ROUTINE\n         BALR  R14,R15                  GO TO IT (NO RETURN)\n         SPACE 2\n         LTORG ,\n***********************************************************************\n*                                                                     *\n*  INVOKE IKJEFTSR TO MAKE AUTHORIZED BY REENTERING AT APFTCB         *\n*                                                                     *\n***********************************************************************\nAPFTSR   DS    0H\n         STM   R14,R1,AF@REGS           %debug\n         TPUTX '>>> apftsr'             %debug\n         LM    R14,R1,AF@REGS           %debug\n         TESTAUTH FCTN=0,STATE=NO,KEY=YES,RBLEVEL=1,BRANCH=NO   23OCT90\n         LTR   R15,R15                  Are we currently key=0  23OCT90\n         BZ    AF$JSET                  A. if yes just set APF  23OCT90\n*                                                               23OCT90\n**       We are definitely not KEY=0 here, so if SUPR state     23OCT90\n**       then don't invoke IKJEFTSR                             23OCT90\n*                                                               23OCT90\n         TESTAUTH FCTN=0,STATE=YES,KEY=NO,RBLEVEL=1,BRANCH=NO   23OCT90\n         LTR   R15,R15                  Are we supr state       23OCT90\n         BZ    AF$FUDG                  A. if yes fudge it      23OCT90\n*                                                               23OCT90\n**       At this point we are KEY=8 and PROB state, so use      23OCT90\n**       IKJEFTSR to get KEY=0 to set APF authorization.        23OCT90\n*                                                               23OCT90\n          AIF   (&@@TSOE NE 0).AF010\n         B     APF$FL                   no TSO/E - go to APF failure\n          AGO   .AF020\n.AF010    ANOP\n         USNGX PSA,R0\n         L     R1,PSATOLD               get current TCB address\n         L     R1,TCBRBP-TCB(,R1)       get RB pointer\n         ST    R1,QAPFR13               save RB address\n         MVC   QNAME,=CL8'QAUTH'\n         MVC   QDUMHDR+2(2),=H'4'       set length\n         MVC   QPRMHDR+2(2),=AL2(QPRMLEN) set length\n         MVC   QDUM1,=F'-1'             set parm to show not CPPL\n         LA    R1,QDUMHDR+2             point at second parms\n         LA    R2,QPRMHDR+2             point at first parms\n         STM   R1,R2,DUMCLST            create parm list\n         OI    DUMCLST+4,X'80'          set end indicator\n         ST    R11,QPRM1                save addr of QCOMMON\n         LA    R1,APFTCB                get addr of routine\n         ST    R1,QPRM2                 save addr of return regs\n         L     R15,CVTPTR\n         L     R15,CVTTVT-CVT(,R15)\n         L     R15,TSVTASF-TSVT(,R15)\n         STM   R14,R1,AF@REGS           %debug\n         TPUTX '>>> calling qauth'      %debug\n         MVC   QDMSG(14),=C'>>> qcommon @ '  %debug\n         HEX   QDMSG+14,QPRM1,LEN=4,HEXTAB=QHEXTAB  %debug\n         TPUTX QDMSG,22                 %debug\n         MVC   QDMSG,QBLANK             %debug\n         LM    R14,R1,AF@REGS           %debug\n         CALL  (15),                                                   X\n               (FLAGS,QNAME,BUFLEN,RETCODE,RSNCODE,ABNDCODE,DUMCLST),  X\n               VL,MF=(E,QAPFSV)\n         ST    R15,QNUMWORK             %debug\n         TPUTX '>>> back from qauth'    %debug\n         MVC   QDMSG(4),=C'r15='        %debug\n         HEX   QDMSG+4,QNUMWORK,LEN=4,HEXTAB=QHEXTAB  %debug\n         MVC   QDMSG+13(8),=C'retcode=' %debug\n         HEX   QDMSG+21,RETCODE,LEN=4   %debug\n         MVC   QDMSG+30(8),=C'rsncode=' %debug\n         HEX   QDMSG+38,RSNCODE,LEN=4   %debug\n         MVC   QDMSG+47(9),=C'abndcode=' %debug\n         HEX   QDMSG+56,ABNDCODE,LEN=4  %debug\n         TPUTX QDMSG,64                 %debug\n         MVC   QDMSG,QBLANK             %debug\n         L     R15,QNUMWORK             %debug - restore return code\n.AF020    ANOP\n         LTR   R15,R15                  did TSR or QAUTH fail?\n         BNZ   APF$FL                   yes - so issue msg or rtn\n         TPUTX '>>> qauth successful'   %debug\n** if successful then we are in key zero\n         L     R1,PSATOLD               get current TCB address\n         L     R1,TCBJSCB-TCB(,R1)      get the JSCB address\n         USNGX IEZJSCB,R1     BASE IT\n         OI    JSCBOPTS,JSCBAUTH        set authorization on\n         DROPX R1             BASE IT\n         MODESET KEY=NZERO,MODE=PROB\n         OI    QXAUTH,QXAPFSET          show we set auth on\n         TPUTX '>>> jscbauth set'       %debug\n         B     QSTOP00                  now exit with rc=0\n         SPACE 3\nAF$JSET  L     R1,PSATOLD               get current TCB address 23OCT90\n         STM   R14,R1,AF@REGS           %debug\n         TPUTX '>>> af$jset'            %debug\n         LM    R14,R1,AF@REGS           %debug\n         L     R1,TCBJSCB-TCB(,R1)      get the JSCB address    23OCT90\n         USNGX IEZJSCB,R1     BASE IT                           23OCT90\n         OI    JSCBOPTS,JSCBAUTH        set authorization on    23OCT90\n         DROPX R1             BASE IT                           23OCT90\n         OI    QXAUTH,QXAPFSET          show we set auth on     23OCT90\n         B     QSTOP00                  now exit with rc=0      23OCT90\n         SPACE 3                                                23OCT90\nAF$FUDG  DS    0H                                               23OCT90\n         STM   R14,R1,AF@REGS           %debug\n         TPUTX '>>> af$fudg'            %debug\n         LM    R14,R1,AF@REGS           %debug\n         MODESET KEY=ZERO               set the key             23OCT90\n         L     R1,PSATOLD               get current TCB address 23OCT90\n         L     R1,TCBJSCB-TCB(,R1)      get the JSCB address    23OCT90\n         USNGX IEZJSCB,R1     BASE IT                           23OCT90\n         OI    JSCBOPTS,JSCBAUTH        set authorization on    23OCT90\n         DROPX R1             BASE IT                           23OCT90\n         MODESET KEY=NZERO              reset the key           23OCT90\n         OI    QXAUTH,QXAPFSET          show we set auth on     23OCT90\n         B     QSTOP00                  now exit with rc=0      23OCT90\n         SPACE 3                                                23OCT90\n***********************************************************************\n*                                                                     *\n*  TO DEAUTHORIZE, JUST TURN OFF BIT IN JFCB                          *\n*                                                                     *\n***********************************************************************\nAPFTSRRS DS    0H\n         TESTAUTH FCTN=0,STATE=YES,KEY=NO,RBLEVEL=1,BRANCH=NO   11OCT90\n         LR    R5,R15                                           11OCT90\n         TESTAUTH FCTN=0,STATE=NO,KEY=YES,RBLEVEL=1,BRANCH=NO   11OCT90\n         LR    R6,R15\n         MODESET KEY=ZERO,MODE=SUP\n         L     R1,PSATOLD               get current TCB address\n         L     R1,TCBJSCB-TCB(,R1)      get the JSCB address\n         USNGX IEZJSCB,R1     BASE IT\n         NI    JSCBOPTS,X'FF'-JSCBAUTH  set authorization off\n         DROPX R1             BASE IT\n         LTR   R5,R5                    need to reset mode ??   11OCT90\n         BZ    APFTSRR1                                         11OCT90\n         MODESET MODE=PROB              reset to problem mode   11OCT90\nAPFTSRR1 LTR   R6,R6                    need to reset key ??    11OCT90\n         BZ    APFTSRR2                                         11OCT90\n         MODESET KEY=NZERO              reset to tcb key        11OCT90\nAPFTSRR2 DS    0H                                               11OCT90\n*        MODESET KEY=NZERO,MODE=PROB\n         NI    QXAUTH,255-QXAPFSET      reset\n         B     QSTOP00                  now exit with rc=0\n         DROPX R0\n         SPACE 3\n***********************************************************************\n*                                                                     *\n*  IKJEFTSR failed to cause authorization, so issue message           *\n*                                                                     *\n***********************************************************************\nAPF$FL   DS    0H\n         TPUTX '>>> apf$fl *****'       %debug\n         NI    QXAUTH,255-QXAPFSET      reset flags\n         LTR   R15,R3                   check entry code\n         BNZ   QSTOPRC                  set rc if only checking\n         QTILT '*** QUEUE IS NOT RUNNING APF AUTHORIZED ***'\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*  This code is invoked by QAUTH and will set authorization on        *\n*                                                                     *\n***********************************************************************\nAPFTCB   BALR  R12,0\n         DROPX R12\n         USNGX *,R12\n         MODESET KEY=ZERO,MODE=SUP\n         L     R1,QAPFR13               get address of rb\n         NI    17(R1),X'0F'             set key to zero\n         RETURN (14,12),RC=0\n         SPACE 3\n***********************************************************************\n*                                                                     *\n*  MISCELLANY                                                         *\n*                                                                     *\n***********************************************************************\nFLAGS    DC    X'00000102'              Flags for IKJEFTSR\nBUFLEN   DC    F'8'                     Length of buffer\n         LTORG ,\n         DROPX R13                                              21SEP90\n         SPACE 3\n         QCOMMON\n***********************************************************************\n*                                                                     *\n*  GENERATE CONTROL BLOCK DSECTS                                      *\n*                                                                     *\n***********************************************************************\nWORK     DSECT\n         ORG   WORK+72\nQDUMHDR  DS    H,H     LENGTH      ***\nQDUM1    DS    F       F'-1'       *\nQPRMHDR  DS    H,H     LENGTH      *  keep together\nQPRM1    DS    A       QCOMMON     *\nQPRM2    DS    A       R13 APF CL  ***\nQPRMLEN  EQU   *-QPRM1             length of parms\nDUMCLST  DS    2F                  CALL PARM LIST\nRETCODE  DS    F                        Function return code\nRSNCODE  DS    F                        IKJEFTSR reason code\nABNDCODE DS    F                        IKJEFTSR abend code\nQNAME    DS    CL8                      QAUTH load module name\n*                                                               26OCT90\n**       DEBUGGING WTP                                          26OCT90\n*                                                               26OCT90\nWTPL     DS    F                                                26OCT90\nWTPLINE  DS    0C                                               26OCT90\nWTPSTAT  DS    CL4,C                                            26OCT90\nWTPOFFS  DS    CL8,C                                            26OCT90\nWTPCMD   DS    CL8,C                                            26OCT90\nWTPP1    DS    CL8,C                                            26OCT90\nWTPP2    DS    CL8,C                                            26OCT90\nWTPCLEN  EQU   *-WTPL                                           26OCT90\nWTPRTDSC DS    AL4                                              26OCT90\nAF@WORKL EQU   *-WORK\nAF@REGS  DS    4F                       %debug\n         QZCVT\n         QZTSVT\n         QZPSA\n         QZTCB\n         QZJSCB\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "Q#AL": {"ttr": 2823, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x0b\\x00\\x00\\x00\\x82#_\\x00\\x91\\x07O\\x15\\x16\\x00\\xc9\\x00g\\x00\\x81\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "05.11", "flags": 0, "createdate": "1982-08-23T00:00:00", "modifydate": "1991-03-15T15:16:00", "lines": 201, "newlines": 103, "modlines": 129, "user": "LDW"}, "text": "         TITLE '--- QUEUE--ALLOCATE -- DATASET ALLOCATION ROUTINES ---'\n*---------------------------------------------------------------------*\n*                                                                     *\n*   ALLOCATE - INTERFACE TO DYNAMIC ALLOCATION                        *\n*                                                                     *\n*   ENTRY - FIELDS FILLED IN IN DAIR BLOCKS IN QCOMMON                *\n*                                                                     *\n*   Updates:                                                          *\n*      14Mar91  EMS  Fix for SWA=ABOVE                                *\n*                    Fix obscure bug in dsn alloc check               *\n*      17Jan86  LDW  Misc cleanup                                     *\n*      10Jan86  LDW  Display DDname and DSName in failure message     *\n*      08/30/84 LDW  USE HEX MACRO                                    *\n*      03/17/83 LDW  DISPLAY RETURN CODE WHEN ALLOCATION FAILS        *\n*      12/21/82 LDW  RE-INSTALL BIT TEST FOR \"SAVE\"                   *\n*      12/10/82 LDW  TEST FOR \"SAVEDS\" SKIP ROBINSON'S WAY            *\n*                       (\"SAVEDS\" USED TO BE NAMED \"SAVE\")            *\n*      12/08/82 LDW  PUT IN IMPROVED TEST FOR \"SAVE\"                  *\n*      11/11/82 EMS  CORRECT THE TEST FOR CURRENTLY ALLOCATED DSN     *\n*                    CORRECT THE TEST FOR CALLER = \"SAVE\"             *\n*      10/21/82 LDW  PUT IN EMS'S FIX FOR CHECKING TO SEE IF DSN IS   *\n*                       CURRENTLY ALLOCATED FOR ALL DATASETS, NOT     *\n*                       JUST HASPACE                                  *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 3\nALLOCATE QSTART  Q2,WORKLEN=AL@WORKL\n         USNGX WORK,R13                 LET ASSEMBLER KNOW ABOUT IT\n***********************************************************************\n*                                                                     *\n*   DETERMINE FUNCTION                                                *\n*                                                                     *\n***********************************************************************\n         CLI   DAIRFLAG,X'08'           IS THE FUNCTION ALLOCATE?\n         BE    AL$ALLOC                 YES. DO IT.\n         CLI   DAIRFLAG,X'18'           IS THE FUNCTION FREE?\n         BE    AL$FREE                  YES. DO IT.\n         CLI   DAIRFLAG,X'2C'           IS THE FUNCTION SET NOT_IN_USE?\n         BE    UNUSE                    YES. DO IT.\n         B     AL$FATAL                 INVALID FUNCTION. ABANDON SHIP.\n***********************************************************************\n*                                                                     *\n*   FREE DDNAME(XXXXXXXX)                                             *\n*                                                                     *\n***********************************************************************\nAL$FREE  LA    R1,DA18CD                LOAD ADDR OF FREE PARM LIST\n         BAL   R2,AL$CDAIR              CALL DAIR\n         B     QSTOP                    RETURN TO CALLER\n***********************************************************************\n*                                                                     *\n*   ALLOC DDNAME(XXXXXXXX) DSNAME(YYYYYYYY) SHR                       *\n*                                                                     *\n***********************************************************************\nAL$ALLOC LM    R4,R5,DA08UNIT           SAVE THE UNIT\n         L     R3,DA08PDSN              -> DSN WE ARE ALLOCATING\n         LH    R15,0(,R3)               GET LEN OF DATASET BEING ALLOC\n         BCTR  R15,0                    -1 FOR EX\n         L     R1,X'218'                -> TCB\n         L     R1,12(,R1)               -> TIOT\n         LA    R1,24(,R1)               -> DEVICE SECTION\nALLOC02  CLI   4(R1),C'A'               VALID DDNAME?\n         BL    ALLOC04                  NO - IGNORE THIS ENTRY\n         TM    1(R1),X'80'              TIOESTTA,TIOSLTYP (free entry?)\n         BO    ALLOC04                  yes - skip to next one\n         ICM   R14,B'0111',12(R1)       -> JFCB-16 !!!\n         BAL   R2,AL$GSVA               convert SVA addr\n         LTR   R14,R14                  ERRORS?\n         BZ    ALLOC04                  YES, TRY NEXT\n         EX    R15,ALLOCCLC             THIS THE DSN WE ARE ALLOCATING?\n         BNE   ALLOC04                  NO - TRY NEXT\n         CH    R15,=Y(44-1)             MAX DSN LEN?\n         BE    ALLOC03                  YES, THEN IT MUST OURS\n         LA    R6,1(R15,R14)            -> END OF DSN\n         CLI   0(R6),C' '               ANYTHING ELSE IN DSN?\n         BNE   ALLOC04                  YES - THIS AIN'T IT THEN\nALLOC03  CLC   DA08SER(6),QBLANK        ANY VOLSER SPEC?\n         BE    ALLOC06                  NO - USE THIS ONE THEN\n         CLC   DA08SER(6),118(R14)      YES - IS THIS THE RIGHT VOLUME?\n         BE    ALLOC06                  YES - USE IT\n*                                       NO - TRY NEXT\nALLOC04  SR    R0,R0                    CLEAR FOR IC\n         IC    R0,0(,R1)                GET ENTRY LENGTH\n         AR    R1,R0                    -> NEXT TIOT ENTRY\n         CLC   =F'0',0(R1)              END OF TIOT?\n         BNE   ALLOC02                  NO - KEEP LOOKING\n         B     ALLOC20                  YES - DO NORMAL ALLOCATE\nALLOCCLC CLC   2(*-*,R3),0(R14)         <<  EXECUTED  >>\nALLOC06  MVC   DA08DDN,4(R1)            MOVE DDNAME TO RETURN AREA\n         B     QSTOP                    AND PRETEND THAT WE ALLOCATED\nALLOC20  MVC   DA08DDN,QBLANK           BLANK THE DDNAME AREA\n         LA    R1,DA08CD                LOAD ADDR OF ALLOC PARM LIST\n         BAL   R2,AL$CDAIR              CALL DAIR - ALLOC THE DATASET\n         STM   R4,R5,DA08UNIT           RESTORE THE UNIT\n         B     QSTOP                    RETURN TO CALLER\n***********************************************************************\n*                                                                     *\n*   MARK DDNAME \"NOT IN USE\"                                          *\n*                                                                     *\n***********************************************************************\nUNUSE    LA    R1,DA2CCD                LOAD ADDR OF UNUSE PARM LIST\n         BAL   R2,AL$CDAIR              CALL DAIR - MARK \"NOT IN USE\"\n         B     QSTOP                    RETURN TO CALLER\n***********************************************************************\n*                                                                     *\n*   CALL DYNAMIC ALLOCATION INTERFACE ROUTINE (DAIR)                  *\n*                                                                     *\n***********************************************************************\nAL$CDAIR ST    R1,DAPLDAPB              SET PARM LIST ADDR IN CALL LIST\n         XC    DAIRECB,DAIRECB          CLEAR ECB\n         LA    R1,DAPLUPT               LOAD ADDR OF DAIR CALL LIST\n         LINK  EP=IKJEFD00              CALL DAIR\n         LTR   R15,R15                  IS RETURN CODE ZERO?\n         BZR   R2                       YES. RETURN.\n         CH    R15,=H'28'               IS DATASET ALREADY FREE?\n         BER   R2                       YES. RETURN.\n         ST    R15,QNUMWORK\n         MVC   QERRMSG(70),=C'*** DATASET ALLOCATION FAILED - R15=XXXXX$\n               XXX, DARC=XXXX, CTRC=XXXX ***'\n         HEX   QERRMSG+36,QNUMWORK,BYTE=C',',HEXTAB=QHEXTAB\n         HEX   QERRMSG+51,DA08DARC,BYTE=C',',LEN=2\n         HEX   QERRMSG+62,DA08CTRC,LEN=2\n         TM    QSCFLAG2,QSC2ALNA        NO ABEND?\n         BNO   AL$FATAL                 NO. ABEND.\n         QTILT *\n***********************************************************************\n*                                                                     *\n*   DAIR HAS FAILED. TAKE A PICTURE AND GO HOME.                      *\n*                                                                     *\n***********************************************************************\nAL$FATAL LA    R1,QERRMSG               -> MSG\n         LA    R0,L'QERRMSG             LENGTH\n         TPUT  (1),(0),R                TELL THEM A SAD STORY\n         CLI   DAIRFLAG,X'08'           IS IT ALLOC?\n         BNE   AL$ABEND                 NO - NO SECOND MESSAGE\n         MVC   QERRMSG,QBLANK           CLEAR THE ERROR MESSAGE AREA\n         MVC   QERRMSG(23),=C'*** UNIT=XXXXXXXX  VOL='\n         MVC   QERRMSG+09(8),DA08UNIT   FILL IN THE UNIT\n         MVC   QERRMSG+23(8),DA08SER    FILL IN THE VOLUME\n         LA    R1,QERRMSG               -> MSG\n         LA    R0,L'QERRMSG             LENGTH\n         TPUT  (1),(0),R                TELL THEM A SAD STORY\n         MVC   QERRMSG,QBLANK           CLEAR THE ERROR MESSAGE AREA\n         MVC   QERRMSG(25),=C'*** DDNAME=XXXXXXXX  DSN='\n         MVC   QERRMSG+11(8),DA08DDN    FILL IN THE DDNAME\n         L     R15,DA08PDSN             -> DSN WE ARE ALLOCATING\n         LH    R14,0(,R15)              GET LENGTH OF DSNAME\n         BCTR  R14,0                    -1 FOR EX\n         EX    R14,AL$ERMVC             MVC QERRMSG+25(*-*),2(R14)\n         LA    R1,QERRMSG               -> MSG\n         LA    R0,L'QERRMSG             LENGTH\n         TPUT  (1),(0),R                TELL THEM A SAD STORY\nAL$ABEND ABEND 99,DUMP                  ABEND THE JOB. USER CODE 0099.\nAL$ERMVC MVC   QERRMSG+25(*-*),2(R15)   << EXECUTED >>\n***********************************************************************\n*                                                                     *\n*   GET SVA ROUTINE                                                   *\n*                                                                     *\n***********************************************************************\nAL$GSVA  STM   R0,R15,AL@SVAR\n         N     R14,=X'00FFFFFF'         ISOLATE SVA\n         BZ    AL$SVAR                  NO SVA, GO RETURN\n         L     R15,CVTPTR               LOAD CVT ADDRESS\n         TM    CVTDCB-CVT(R15),CVTMVSE  MVS/XA?\n         BO    AL$GSVAQ                 YES\n         LA    R14,16(,R14)             SKIP OVER PREFIX\n         B     AL$SVAR                  RETURN\nAL$GSVAQ XC    AL@SEPA,AL@SEPA          ZERO OUT EPA\n         LA    R1,AL@SEPA               -> WORK AREA\n         ST    R1,AL@SEPAP              SAVE IN POINTER\n         STCM  R14,B'0111',SWVA-ZB505+AL@SEPA  SET SVA IN EPA\n         SWAREQ  FCODE=LA,EPA=AL@SEPAP,MF=(E,AL@SPLA),UNAUTH=YES\n         SLR   R14,R14                  ZERO OUT REGISTER\n         LTR   R15,R15                  SUCCESSFUL?\n         BNZ   AL$SVAR                  NO, GO RETURN\n         L     R14,SWBLKPTR-ZB505+AL@SEPA  LOAD SWA CONTROL BLOCK ADDR\nAL$SVAR  LM    R0,R13,AL@SVAR           RESTORE REGS\n         L     R15,R15*4+AL@SVAR        get R15 too\n         BR    R2                       RETURN TO CALLER\n         SPACE 3\n         DROPX R13                      WORK\n***********************************************************************\n*                                                                     *\n*   CONSTANTS AND ASSORTED GARBAGE                                    *\n*                                                                     *\n***********************************************************************\n         LTORG ,\n         SPACE 3\nWORK     DSECT ,\n         ORG   WORK+72\n* SRS -  SWA MANAGER REQUEST STORAGE AREA                             *\nAL@SPLA  DS    2A(0)                    REQUEST PARAMETER LIST\nAL@SEPAP DS    A(AL@SEPA)               EPA POINTER\nAL@SEPA  DS    XL28'00'                 EPA\nAL@SVAR  DS    16F                      SAVEAREA FOR SVA SUBROUTINE\nAL@WORKL EQU   *-WORK                   WORKAREA LEN\n         SPACE 3\n         QZCVT\n         QZJESCT\n         QZZB505\n         SPACE 3\n         QCOMMON\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "Q#AL@": {"ttr": 2827, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\n\\x00\\x00\\x00\\x82#_\\x00\\x87\\x01\\x8f 6\\x00\\x99\\x00g\\x00N\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "05.10", "flags": 0, "createdate": "1982-08-23T00:00:00", "modifydate": "1987-01-18T20:36:00", "lines": 153, "newlines": 103, "modlines": 78, "user": "LDW"}, "text": "         TITLE '--- QUEUE--ALLOCATE -- DATASET ALLOCATION ROUTINES ---'\n*---------------------------------------------------------------------*\n*                                                                     *\n*   ALLOCATE - INTERFACE TO DYNAMIC ALLOCATION                        *\n*                                                                     *\n*   ENTRY - FIELDS FILLED IN IN DAIR BLOCKS IN QCOMMON                *\n*                                                                     *\n*   Updates:                                                          *\n*      17Jan86  LDW  Misc cleanup                                     *\n*      10Jan86  LDW  Display DDname and DSName in failure message     *\n*      08/30/84 LDW  USE HEX MACRO                                    *\n*      03/17/83 LDW  DISPLAY RETURN CODE WHEN ALLOCATION FAILS        *\n*      12/21/82 LDW  RE-INSTALL BIT TEST FOR \"SAVE\"                   *\n*      12/10/82 LDW  TEST FOR \"SAVEDS\" SKIP ROBINSON'S WAY            *\n*                       (\"SAVEDS\" USED TO BE NAMED \"SAVE\")            *\n*      12/08/82 LDW  PUT IN IMPROVED TEST FOR \"SAVE\"                  *\n*      11/11/82 EMS  CORRECT THE TEST FOR CURRENTLY ALLOCATED DSN     *\n*                    CORRECT THE TEST FOR CALLER = \"SAVE\"             *\n*      10/21/82 LDW  PUT IN EMS'S FIX FOR CHECKING TO SEE IF DSN IS   *\n*                       CURRENTLY ALLOCATED FOR ALL DATASETS, NOT     *\n*                       JUST HASPACE                                  *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 3\nALLOCATE QSTART  Q2\n***********************************************************************\n*                                                                     *\n*   DETERMINE FUNCTION                                                *\n*                                                                     *\n***********************************************************************\n         CLI   DAIRFLAG,X'08'           IS THE FUNCTION ALLOCATE?\n         BE    AL$ALLOC                 YES. DO IT.\n         CLI   DAIRFLAG,X'18'           IS THE FUNCTION FREE?\n         BE    AL$FREE                  YES. DO IT.\n         CLI   DAIRFLAG,X'2C'           IS THE FUNCTION SET NOT_IN_USE?\n         BE    UNUSE                    YES. DO IT.\n         B     AL$FATAL                 INVALID FUNCTION. ABANDON SHIP.\n***********************************************************************\n*                                                                     *\n*   FREE DDNAME(XXXXXXXX)                                             *\n*                                                                     *\n***********************************************************************\nAL$FREE  LA    R1,DA18CD                LOAD ADDR OF FREE PARM LIST\n         BAL   R2,AL$CDAIR              CALL DAIR\n         B     QSTOP                    RETURN TO CALLER\n***********************************************************************\n*                                                                     *\n*   ALLOC DDNAME(XXXXXXXX) DSNAME(YYYYYYYY) SHR                       *\n*                                                                     *\n***********************************************************************\nAL$ALLOC LM    R4,R5,DA08UNIT           SAVE THE UNIT\n         L     R3,DA08PDSN              -> DSN WE ARE ALLOCATING\n         LH    R15,0(,R3)               GET LEN OF DATASET BEING ALLOC\n         BCTR  R15,0                    -1 FOR EX\n         L     R1,X'218'                -> TCB\n         L     R1,12(,R1)               -> TIOT\n         LA    R1,24(,R1)               -> DEVICE SECTION\nALLOC02  CLI   4(R1),C'A'               VALID DDNAME?\n         BL    ALLOC04                  NO - IGNORE THIS ENTRY\n         ICM   R14,B'0111',12(R1)       -> JFCB-16 !!!\n         EX    R15,ALLOCCLC             THIS THE DSN WE ARE ALLOCATING?\n         BNE   ALLOC04                  NO - TRY NEXT\n         CH    R15,=Y(44-1)             MAX DSN LEN?\n         BE    ALLOC06                  YES, THEN IT MUST OURS\n         LA    R6,16+1(R15,R14)         -> END OF DSN\n         CLI   0(R6),C' '               ANYTHING ELSE IN DSN?\n         BNE   ALLOC04                  YES - THIS AIN'T IT THEN\nALLOC03  CLC   DA08SER(6),QBLANK        ANY VOLSER SPEC?\n         BE    ALLOC06                  NO - USE THIS ONE THEN\n         CLC   DA08SER(6),16+118(R14)   YES - IS THIS THE RIGHT VOLUME?\n         BE    ALLOC06                  YES - USE IT\n*                                       NO - TRY NEXT\nALLOC04  SR    R0,R0                    CLEAR FOR IC\n         IC    R0,0(,R1)                GET ENTRY LENGTH\n         AR    R1,R0                    -> NEXT TIOT ENTRY\n         CLC   =F'0',0(R1)              END OF TIOT?\n         BNE   ALLOC02                  NO - KEEP LOOKING\n         B     ALLOC20                  YES - DO NORMAL ALLOCATE\nALLOCCLC CLC   2(*-*,R3),16+00(R14)     <<  EXECUTED  >>\nALLOC06  MVC   DA08DDN,4(R1)            MOVE DDNAME TO RETURN AREA\n         B     QSTOP                    AND PRETEND THAT WE ALLOCATED\nALLOC20  MVC   DA08DDN,QBLANK           BLANK THE DDNAME AREA\n         LA    R1,DA08CD                LOAD ADDR OF ALLOC PARM LIST\n         BAL   R2,AL$CDAIR              CALL DAIR - ALLOC THE DATASET\n         STM   R4,R5,DA08UNIT           RESTORE THE UNIT\n         B     QSTOP                    RETURN TO CALLER\n***********************************************************************\n*                                                                     *\n*   MARK DDNAME \"NOT IN USE\"                                          *\n*                                                                     *\n***********************************************************************\nUNUSE    LA    R1,DA2CCD                LOAD ADDR OF UNUSE PARM LIST\n         BAL   R2,AL$CDAIR              CALL DAIR - MARK \"NOT IN USE\"\n         B     QSTOP                    RETURN TO CALLER\n***********************************************************************\n*                                                                     *\n*   CALL DYNAMIC ALLOCATION INTERFACE ROUTINE (DAIR)                  *\n*                                                                     *\n***********************************************************************\nAL$CDAIR ST    R1,DAPLDAPB              SET PARM LIST ADDR IN CALL LIST\n         XC    DAIRECB,DAIRECB          CLEAR ECB\n         LA    R1,DAPLUPT               LOAD ADDR OF DAIR CALL LIST\n         LINK  EP=IKJEFD00              CALL DAIR\n         LTR   R15,R15                  IS RETURN CODE ZERO?\n         BZR   R2                       YES. RETURN.\n         CH    R15,=H'28'               IS DATASET ALREADY FREE?\n         BER   R2                       YES. RETURN.\n         ST    R15,QNUMWORK\n         MVC   QERRMSG(70),=C'*** DATASET ALLOCATION FAILED - R15=XXXXX$\n               XXX, DARC=XXXX, CTRC=XXXX ***'\n         HEX   QERRMSG+36,QNUMWORK,BYTE=C',',HEXTAB=QHEXTAB\n         HEX   QERRMSG+51,DA08DARC,BYTE=C',',LEN=2\n         HEX   QERRMSG+62,DA08CTRC,LEN=2\n         TM    QSCFLAG2,QSC2ALNA        NO ABEND?\n         BNO   AL$FATAL                 NO. ABEND.\n         QTILT *\n***********************************************************************\n*                                                                     *\n*   DAIR HAS FAILED. TAKE A PICTURE AND GO HOME.                      *\n*                                                                     *\n***********************************************************************\nAL$FATAL LA    R1,QERRMSG               -> MSG\n         LA    R0,L'QERRMSG             LENGTH\n         TPUT  (1),(0),R                TELL THEM A SAD STORY\n         CLI   DAIRFLAG,X'08'           IS IT ALLOC?\n         BNE   AL$ABEND                 NO - NO SECOND MESSAGE\n         MVC   QERRMSG,QBLANK           CLEAR THE ERROR MESSAGE AREA\n         MVC   QERRMSG(23),=C'*** UNIT=XXXXXXXX  VOL='\n         MVC   QERRMSG+09(8),DA08UNIT   FILL IN THE UNIT\n         MVC   QERRMSG+23(8),DA08SER    FILL IN THE VOLUME\n         LA    R1,QERRMSG               -> MSG\n         LA    R0,L'QERRMSG             LENGTH\n         TPUT  (1),(0),R                TELL THEM A SAD STORY\n         MVC   QERRMSG,QBLANK           CLEAR THE ERROR MESSAGE AREA\n         MVC   QERRMSG(25),=C'*** DDNAME=XXXXXXXX  DSN='\n         MVC   QERRMSG+11(8),DA08DDN    FILL IN THE DDNAME\n         L     R15,DA08PDSN             -> DSN WE ARE ALLOCATING\n         LH    R14,0(,R15)              GET LENGTH OF DSNAME\n         BCTR  R14,0                    -1 FOR EX\n         EX    R14,AL$ERMVC             MVC QERRMSG+25(*-*),2(R14)\n         LA    R1,QERRMSG               -> MSG\n         LA    R0,L'QERRMSG             LENGTH\n         TPUT  (1),(0),R                TELL THEM A SAD STORY\nAL$ABEND ABEND 99,DUMP                  ABEND THE JOB. USER CODE 0099.\nAL$ERMVC MVC   QERRMSG+25(*-*),2(R15)   << EXECUTED >>\n***********************************************************************\n*                                                                     *\n*   CONSTANTS AND ASSORTED GARBAGE                                    *\n*                                                                     *\n***********************************************************************\n         LTORG ,\n         SPACE 3\n         QCOMMON\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "Q#AT": {"ttr": 3076, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x14\\x00\\x00\\x00\\x86#\\x9f\\x00\\x92\\x03\\x8f\\x18\\x18\\x01a\\x01/\\x00\\xe5\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.20", "flags": 0, "createdate": "1986-08-27T00:00:00", "modifydate": "1992-02-07T18:18:00", "lines": 353, "newlines": 303, "modlines": 229, "user": "LDW"}, "text": "         TITLE '--- QUEUE--ATTR -- DISPLAY SPOOL DS ATTRIBUTES ---'\n*---------------------------------------------------------------------*\n*                                                                     *\n*   ATTR - Display attributes of a spooled dataset                    *\n*                                                                     *\n*   Entry - QPARM1 = jobid                                            *\n*         - QPARM2 = dsid                                             *\n*                                                                     *\n*   Updates:                                                          *\n*      07Feb92  LDW  Integrate GLA fix below:                         *\n*      19Dec91  GLA  Add Creator id and Seclabel to display           *\n*      08Jun91  LDW  Integrate EMS's SP42 updates below:              *\n*     (24Apr91) EMS  Update for SP420                                 *\n*      20Dec90  LDW  Correct typo in PSO flag display                 *\n*                    Display new flags from 4.1 PDBFLAG1              *\n*                    Fix flash count display                          *\n*      28Nov90  EMS  Update for SP410                                 *\n*      10Oct90  EMS  Fix lines/page display bug                       *\n*      31Jul90  EMS  Update for SP313                                 *\n*      25Dec89  LDW  QDCBD -> QZDCBD                                  *\n*      23Nov89  LDW  Remove unneeded Q$JCT                            *\n*      25Apr88  EMS  Update for SP311                                 *\n*      10Jan88  LDW  Update for QITEM macro (no more \"LC\")            *\n*       8Jul87  EMS  Update for QITEM macro                           *\n*                    Let default forms code be blank                  *\n*                    Update to assemble base JES2 code                *\n*                    Update for GETPDDB routine                       *\n*      22May87  EMS  Fix for JESNEWS                                  *\n*                    Fix Line 09 (leave attr bytes alone)             *\n*                    Add to description of DCBRECFM (add QDCBD)       *\n*                    Update for enhanced QITEM macro                  *\n*      21Mar87  LDW  Fix for DSID = 0 (from RSCS)                     *\n*      14Dec86  LDW  SP136 updates:  skip PDBCPU                      *\n*      28AUG86  LDW  WRITTEN                                          *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 3\nATTR     QSTART  Q??,STACK=X'40',WORKLEN=AT@WORKL\n         USNGX WORK,R13                 BASE REG FOR LOCAL WORK\n         QITEM RESET,PREFIX=AT          RESET GLOBAL ARRAY POINTER\n         QCALL FINDJOB                  LOCATE THE JQE, JCT, AND IOT\n***********************************************************************\n*                                                                     *\n*   CHECK AND CONVERT THE DATASET ID NUMBER FOR USER DSID\n*                                                                     *\n***********************************************************************\n         LH    R1,QLNG2                 GET LENGTH OF DSID OPERAND\n         SH    R1,=H'1'                 DATASET ID FIELD ZERO LENGTH?\n         BM    AT$USE                   YES - USE CURRENT DSID\n         CLC   =C'JL',QPARM2            WANT JOBLOG?\n         LA    R15,2                    DSID FOR JOBLOG\n         LA    R14,=CL4'JLOG'           GET FULL CHAR ID\n         BE    AT$ANYOK                 YES - USE IT\n         CLC   =C'JC',QPARM2            WANT JCL?\n         LA    R15,3                    DSID FOR JCL?\n         LA    R14,=CL4'JCL '           GET FULL CHAR ID\n         BE    AT$ANYOK                 YES - USE IT\n         CLC   =C'JM',QPARM2            WANT JOBMSG?\n         LA    R15,4                    DSID FOR JOBLOG\n         LA    R14,=CL4'JMSG'           GET FULL CHAR ID\n         BE    AT$ANYOK                 YES - USE IT\n         LA    R15,QPARM2               POINT TO PARM\n         BAL   R14,QNUMCONV             CONVERT IT\n         BNE   AT$TILT1                 QUIT IF NOT NUMERIC\n         TM    QXAUTH,QXAUTHX           PRIVILEGED USER?\n         BNZ   AT$ANYOK                 YES - SKIP NEXT VALIDITY CHECK\n         CH    R15,=H'101'              DATASET ID LESS THAN 101?\n         BL    AT$TILT1                 YES - TILT\n          AIF  (&QLEVEL GE 9).AT01\nAT$ANYOK STH   R15,QPDSID               STORE DATASET ID\n          AGO  .AT02\n.AT01     ANOP ,\nAT$ANYOK STCM  R15,B'1111',QPDSID       store dataset id\n.AT02     ANOP ,\n         OI    QFLAG2,Q2VALIDS          INDICATE VALIDITY FOR LISTDS\n         MVC   QDHDSID,QPARM2           SET DSID\n***********************************************************************\n*                                                                     *\n*   LOCATE PDDB FOR DATASET SPECIFIED IN QPDSID                       *\n*                                                                     *\n***********************************************************************\n*T$USE   OC    QPDSID,QPDSID            ANY DSID?\nAT$USE   TM    QFLAG2,Q2VALIDS          ANY DSID?\n         BNZ   AT$HAVE\n         QTILT '*** NO DSID SELECTED ***'\nAT$HAVE  OI    QSCFLAG1,QSC1JOB         PUT THE JOBID IN QDTOP\n         QCALL DISP80                   SWITCH TO 3278-2 MODE IF 3278-5\n         MVC   QDHLINE(79),=CL79'Attributes for DSID xxxxxxxx'\n         MVC   AT@HDSID,QDHDSID         AND FILL IN DSID\n         OI    QFLAG1,Q1MVHDR           REQUEST \"MOVE HEADER\"\n         MVI   QGPFLAG,QPFDIR           get specific pddb\n         QCALL GETPDDB                  locate pddb entry\n         LTR   R6,R1                    copy pddb addr\n         BNP   QSTOP                    if none, error msg already out\n         USNGX PDBDSECT,R6              BASE REG FOR PDDB\n         SPACE 2\n*---  LINE 01\n         SR    R5,R5                    CLEAR ATTR BYTE COUNTER\n         BAL   R14,QADDLINE             DISPLAY A BLANK LINE\n         SPACE 2\n*---  LINE 02\n         QITEM 0+00,'PDBFLAG1',2+10,HEX,PDBFLAG1,1\n         QITEM 2+20,'PDBFLAG2',4+30,HEX,PDBFLAG2,1\n          AIF   (&QLEVEL LT 4).AT03\n         QITEM 4+40,'PDBFLAG3',6+50,HEX,PDBFLAG3,1\n         QITEM 6+60,'PDBSTAT',8+70,HEX,PDBSTAT,1\n.AT03    ANOP  ,\n         QITEM ADDLINE                  SET ATTR NUM AND DISPLAY LINE\n         SPACE 2\n          AIF   (&QLEVEL GT 9).AT04\n         TM    PDBFLAG1,PDB1DSID        DSID IN PDBDSID/PDBWTRID FIELD?\n         BZ    *+10                     NO - SKIP\n         MVC   AT@LINE+05(4),=C'DSID'\n.AT04    ANOP  ,\n         TM    PDBFLAG1,PDB1NULL        NULL PDDB?\n         BZ    *+10                     NO - SKIP\n         MVC   AT@LINE+10(4),=C'NULL'\n         TM    PDBFLAG1,PDB1LOG         HASP JOB LOG?\n         BZ    *+10                     NO - SKIP\n         MVC   AT@LINE+15(4),=C'JLOG'\n          AIF   (&QLEVEL GE 12).ATX04A  (maybe should check pdbstat??)\n         TM    PDBFLAG1,PDB1MDES        FOLLOWED BY PDDBS FOR MULT DEST\n         BZ    *+10                     NO - SKIP\n         MVC   AT@LINE+20(4),=C'MDES'\n          AGO   .ATX04B\n.ATX04A   ANOP\n         TM    PDBFLAG1,PDB1MOC         FOLLOWED BY PDDBS FOR MULT DEST\n         BZ    *+10                     NO - SKIP\n         MVC   AT@LINE+20(4),=C'MOC '\n.ATX04B   ANOP\n         TM    PDBFLAG1,PDB1NSOT        NOT FOR SYSOUT?\n         BZ    *+10                     NO - SKIP\n         MVC   AT@LINE+25(4),=C'NSOT'\n         TM    PDBFLAG1,PDB1SPIN        SPIN DATASET?\n         BZ    *+10                     NO - SKIP\n         MVC   AT@LINE+30(4),=C'SPIN'\n          AIF   (&QLEVEL GE 11).AT05    (maybe should check pdbstat??)\n         TM    PDBFLAG1,PDB1HOLD        HELD DATASET?\n         BZ    *+10                     NO - SKIP\n         MVC   AT@LINE+35(4),=C'HELD'\n         TM    PDBFLAG1,PDB1PSO         ACCESSIBLE BY PSO?\n         BZ    *+10                     NO - SKIP\n         MVC   AT@LINE+40(4),=C'PSO '\n          AGO   .AT06\n.AT05     ANOP  ,\n         TM    PDBFLAG1,PDB1NEWS        JESNEWS DATASET?\n         BZ    *+10                     NO - SKIP\n         MVC   AT@LINE+35(4),=C'NEWS'\n         TM    PDBFLAG1,PDB1USER        user?\n         BZ    *+10                     NO - SKIP\n         MVC   AT@LINE+40(4),=C'USER'\n.AT06     ANOP\n         CLC   AT@LINE,QBLANK           ANYTHING HERE?\n         BE    *+8                      NO - SKIP\n         BAL   R14,QADDLINE             YES - DISPLAY LINE\n*---  LINE 03\n         MVC   AT@WORK,QBLANK           clear out field\n         LA    R1,AT@WORK               -> start of field\n         MVI   0(R1),C'U'               start with u\n         TM    PDBRECFM,DCBRECU\n         BO    AT$RECB                  got it\n         MVI   0(R1),C'F'               try f\n         TM    PDBRECFM,DCBRECF\n         BO    AT$RECB                  got it\n         MVI   0(R1),C'V'               must be v\n         TM    PDBRECFM,DCBRECV\n         BO    AT$RECB                  got it\n         MVI   0(R1),C'U'               well, say it's u after all\nAT$RECB  LA    R1,1(,R1)                -> next char\n         TM    PDBRECFM,DCBRECBR        blocked?\n         BZ    AT$RECS                  no\n         MVI   0(R1),C'B'                 yes, insert\n         LA    R1,1(,R1)\nAT$RECS  TM    PDBRECFM,DCBRECSB        spanned/standard?\n         BZ    AT$RECC\n         MVI   0(R1),C'S'               yes\n         LA    R1,1(,R1)\nAT$RECC  TM    PDBRECFM,DCBRECCC        control chars\n         BZ    AT$REC\n         MVI   0(R1),C'A'               assume asa\n         TM    PDBRECFM,DCBRECCA\n         BO    AT$REC\n         MVI   0(R1),C'M'               must be machine\nAT$REC   LA    R1,1(,R1)\n         MVI   1(R1),C'('               (\n         UNPK  2(3,R1),PDBRECFM(2)       ??\n         TR    2(2,R1),QHEXTAB             )\n         MVI   4(R1),C')'\n         QITEM 0+00,'RECFM',2+10,CHAR,AT@WORK,9\n         QITEM 2+20,'LRECL',4+30,DEC,PDBLRECL,2\n         QITEM ADDLINE                  SET ATTR NUM AND DISPLAY LINE\n         SPACE 2\n*---  LINE 04\n         QITEM 0+00,'PDBMTTR',2+10,HEX,PDBMTTR,4\n          AIF   (&QLEVEL LT 4).AT07\n         QITEM 2+20,'PDBMTTRL',4+30,HEX,PDBMTTRL,4\n.AT07    ANOP  ,\n         QITEM ADDLINE                  SET ATTR NUM AND DISPLAY LINE\n         SPACE 2\n*---  LINE 05\n         QITEM 0+00,'Class',2+10,CHAR,PDBCLASS,1\n         QITEM 2+20,'Copies',4+30,DEC,PDBCOPYS,1\n         QITEM ADDLINE                  SET ATTR NUM AND DISPLAY LINE\n         SPACE 2\n*---  LINE 06\n*%%      MVC   AT@LINE(4+4),AT#DEST     'DESTINATION'\n         LA    R1,PDBDEST               POINT TO DESTINATION FIELD\n         QCALL FINDRJE                  CONVERT TO RJE ID\n*%%      MVC   AT@LINE+2+10(8),0(R1)    MOVE DEST NAME TO DISPLAY LINE\n*%%      CLC   AT@LINE+2+10(8),QBLANK   BLANK? (LOCAL)\n*%%      BNE   *+10                     NO - KEEP IT\n*%%      MVC   AT@LINE+2+10(7),=C'(LOCAL)'  YES - SAY SO\n*%%      CLC   AT@DWD,QBLANK            BLANK? (LOCAL)\n*%%      BNE   *+10                     NO - KEEP IT\n*%%      MVC   AT@DWD(7),=C'(LOCAL)'    YES - SAY SO\n*%%      LA    R5,2(,R5)                BUMP NUMBER OF ATTR BYTES\n         MVC   AT@DWD,0(R1)             SAVE DEST NAME\n         QITEM 0+00,'Dest',2+10,CHAR,AT@DWD,8\n          AIF   (&QLEVEL LT 4).AT08\n         QITEM 2+20,'Dest Usr',4+30,CHAR,PDBUSER,8\n          AIF   (&QLEVEL LT 10).AT08\n         QITEM 4+40,'Creator',6+50,CHAR,PDBCRUID,8\n         QITEM 6+60,'Seclabel',8+70,CHAR,PDBSECLB,8\n.AT08    ANOP  ,\n          AIF   (&QLEVEL GE 7).AT09\n         QITEM 4+40,'PDBCPU',6+50,HEX,PDBCPU,1\n.AT09     ANOP\n*  % PDBSEC?\n         QITEM ADDLINE                  SET ATTR NUM AND DISPLAY LINE\n         SPACE 2\n*---  LINE 07\n         QITEM 0+00,'Records',2+10,DEC,PDBRECCT\n          AIF   (&QLEVEL LT 6).AT10\n         QITEM 2+25,'Pages',4+35,DEC,PDBPGCT\n         QITEM 4+50,'Bytes',6+60,DEC,PDBBYTCT\n.AT10    ANOP  ,\n         QITEM ADDLINE                  SET ATTR NUM AND DISPLAY LINE\n         SPACE 2\n*---  LINE 08\n          AIF   (&QLEVEL GT 4).AT11\n         QITEM 0+00,'Forms',2+10,CHAR,PDBFORMS,4\n          AGO   .AT12\n.AT11     ANOP\n         QITEM 0+00,'Forms',2+10,CHAR,PDBFORMS,8\n.AT12     ANOP\n         CLC   PDBFORMS,=CL8'&@@QSTDF'  default forms code?\n         BNE   *+10                     no, leave as is\n         MVC   AT@LINE+10+2(8),QBLANK   yes, clear it out\n         QITEM 2+20,'Fcb',4+30,CHAR,PDBFCB,4\n         QITEM 4+40,'Ucs',6+50,CHAR,PDBUCS,4\n          AIF   (&QLEVEL LT 6).AT13\n         QITEM 6+60,'Prmode',8+70,CHAR,PDBPRMD,8\n.AT13    ANOP  ,\n         QITEM ADDLINE                  SET ATTR NUM AND DISPLAY LINE\n         SPACE 2\n*---  LINE 09\n          AIF   (&QLEVEL LT 4).AT14\n         QITEM 0+00,'DDname',2+10,CHAR,PDBDDNAM,8\n         QITEM 2+20,'Proc Step',4+31,CHAR,PDBPNAME,8\n         QITEM 4+40,'Step Name',6+51,CHAR,PDBSNAME,8\n         QITEM ADDLINE                  SET ATTR NUM AND DISPLAY LINE\n         SPACE 2\n.AT14    ANOP  ,\n*---  LINE 10\n          AIF   (&QLEVEL GT 9).AT15\n         QITEM 0+00,'Dsid/Wtrid',2+30,CHAR,PDBDSID,8\n         AGO   .AT16\n.AT15    ANOP  ,\n         QITEM 0+00,'Wtrid',2+30,CHAR,PDBWTRID,8\n.AT16    ANOP  ,\n         QITEM 2+40,'PDBRBA',4+50,HEX,PDBRBA,4\n         QITEM                   ,,4+59,HEX,PDBRBA+4,4\n         QITEM ADDLINE                  SET ATTR NUM AND DISPLAY LINE\n         SPACE 2\n*---  LINE 11\n         QITEM 0+00,'Chars',2+10,CHAR,PDBCHAR1,4\n         MVC   AT@LINE+2+16(4),PDBCHAR2\n         MVC   AT@LINE+2+22(4),PDBCHAR3\n         MVC   AT@LINE+2+28(4),PDBCHAR4\n         QITEM 2+40,'Flash',4+50,CHAR,PDBFLASH,4\n         QITEM 4+60,'Modf',6+70,CHAR,PDBMODF,4\n         QITEM ADDLINE                  SET ATTR NUM AND DISPLAY LINE\n         SPACE 2\n*---  LINE 12\n         QITEM 0+00,'Flash Count',2+14,DEC,PDBFLSHC,1\n         QITEM 2+20,'TRC',4+30,CHAR,PDBMODFT,1\n         QITEM 4+40,'Copyg',6+50,HEX,PDBCOPYG,4\n         QITEM             ,,6+59,HEX,PDBCOPYG+4,4\n         QITEM ADDLINE                  SET ATTR NUM AND DISPLAY LINE\n         SPACE 2\n*---  LINE 13\n         QITEM 0+00,'Pages/Ckpt',2+12,DEC,PDBCKPTP,2\n         QITEM 2+20,'Lines/Ckpt',4+32,DEC,PDBCKPTL,2\n          AIF   (&QLEVEL LT 4).AT17\n         TM    PDBFLAG3,PDBLNCTF        lines/page specified?\n         BZ    AT$LN12                  no, skip output\n         QITEM 2+40,'Lines/Page',4+52,DEC,PDBLINCT,1\n.AT17    ANOP  ,\nAT$LN12  QITEM ADDLINE                  SET ATTR NUM AND DISPLAY LINE\n         SPACE 2\n          AIF   (&QLEVEL LT 4).AT18\n*---  LINE 14\n         QITEM 0+00,'Output Id',2+13,DEC,PDBID,2\n         QITEM 2+20,'Output Name',4+33,CHAR,PDBNAME,8\n         QITEM ADDLINE                  SET ATTR NUM AND DISPLAY LINE\n         SPACE 2\n*---  LINE 15\n         QITEM 0+00,'PDBCRTME',2+10,HEX,PDBCRTME,4\n         QITEM 2+20,'PDBPLIOT',4+30,HEX,PDBPLIOT,4\n         QITEM 4+40,'PDBPLOFF',6+50,HEX,PDBPLOFF,4\n         QITEM ADDLINE                  SET ATTR NUM AND DISPLAY LINE\n         SPACE 2\n.AT18    ANOP  ,\n         B     QSTOP\n         SPACE 3\n         DROPX R13,R6                   WORK, PDBDSECT\n         EJECT ,\nAT$TILT1 MVC   QERRMSG(14),=C'*** DATASET ID '\n         MVC   QERRMSG+15(8),QDHDSID    SHOW THE DSID\n         MVC   QERRMSG+24(11),=C'INVALID ***'\n         QTILT *,OPTIONS=REPROMPT\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*   MISCELLANY                                                        *\n*                                                                     *\n***********************************************************************\n         LTORG ,\n         SPACE 1\nAT#MASK  DC    X'402020',C',',X'202020',C',',X'202020',C',',X'202120'\nAT#MASKL EQU   *-AT#MASK\n         SPACE 1\n*%%  AT#DEST  DC    X'1DE8'                  OUTPUT, BRIGHT\n*%%      DC    C'Dest'\n*%%      DC    X'1D60'                  OUTPUT, NORMAL\n*%%      SPACE 1\n         QITEM GEN                      GEN ALL THE OTHER \"LITERALS\"\n         SPACE 3\nWORK     DSECT\n         ORG   WORK+72                  SKIP PAST SAVE AREA\nAT@DWD   DS    D\nAT@WORK  DS    2CL(AT#MASKL)\nAT@WORKL EQU   *-WORK\n         SPACE 3\n         QCOMMON\n         ORG   QDMSG\nAT@LINE  DS    CL(L'QDMSG)\n         ORG   QDHLINE\n         DS    C'ATTRIBUTES FOR DSID '\nAT@HDSID DS    CL8\n         SPACE 3\n         QZDCBD\n         Q$PDDB\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "Q#AT@": {"ttr": 3083, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x13\\x00\\x00\\x00\\x86#\\x9f\\x00\\x91\\x18_ B\\x01\\\\\\x01/\\x00\\xe0\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.19", "flags": 0, "createdate": "1986-08-27T00:00:00", "modifydate": "1991-07-04T20:42:00", "lines": 348, "newlines": 303, "modlines": 224, "user": "LDW"}, "text": "         TITLE '--- QUEUE--ATTR -- DISPLAY SPOOL DS ATTRIBUTES ---'\n*---------------------------------------------------------------------*\n*                                                                     *\n*   ATTR - Display attributes of a spooled dataset                    *\n*                                                                     *\n*   Entry - QPARM1 = jobid                                            *\n*         - QPARM2 = dsid                                             *\n*                                                                     *\n*   Updates:                                                          *\n*      08Jun91  LDW  Integrate EMS's SP42 updates below:              *\n*     (24Apr91) EMS  Update for SP420                                 *\n*      20Dec90  LDW  Correct typo in PSO flag display                 *\n*                    Display new flags from 4.1 PDBFLAG1              *\n*                    Fix flash count display                          *\n*      28Nov90  EMS  Update for SP410                                 *\n*      10Oct90  EMS  Fix lines/page display bug                       *\n*      31Jul90  EMS  Update for SP313                                 *\n*      25Dec89  LDW  QDCBD -> QZDCBD                                  *\n*      23Nov89  LDW  Remove unneeded Q$JCT                            *\n*      25Apr88  EMS  Update for SP311                                 *\n*      10Jan88  LDW  Update for QITEM macro (no more \"LC\")            *\n*       8Jul87  EMS  Update for QITEM macro                           *\n*                    Let default forms code be blank                  *\n*                    Update to assemble base JES2 code                *\n*                    Update for GETPDDB routine                       *\n*      22May87  EMS  Fix for JESNEWS                                  *\n*                    Fix Line 09 (leave attr bytes alone)             *\n*                    Add to description of DCBRECFM (add QDCBD)       *\n*                    Update for enhanced QITEM macro                  *\n*      21Mar87  LDW  Fix for DSID = 0 (from RSCS)                     *\n*      14Dec86  LDW  SP136 updates:  skip PDBCPU                      *\n*      28AUG86  LDW  WRITTEN                                          *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 3\nATTR     QSTART  Q??,STACK=X'40',WORKLEN=AT@WORKL\n         USNGX WORK,R13                 BASE REG FOR LOCAL WORK\n         QITEM RESET,PREFIX=AT          RESET GLOBAL ARRAY POINTER\n         QCALL FINDJOB                  LOCATE THE JQE, JCT, AND IOT\n***********************************************************************\n*                                                                     *\n*   CHECK AND CONVERT THE DATASET ID NUMBER FOR USER DSID\n*                                                                     *\n***********************************************************************\n         LH    R1,QLNG2                 GET LENGTH OF DSID OPERAND\n         SH    R1,=H'1'                 DATASET ID FIELD ZERO LENGTH?\n         BM    AT$USE                   YES - USE CURRENT DSID\n         CLC   =C'JL',QPARM2            WANT JOBLOG?\n         LA    R15,2                    DSID FOR JOBLOG\n         LA    R14,=CL4'JLOG'           GET FULL CHAR ID\n         BE    AT$ANYOK                 YES - USE IT\n         CLC   =C'JC',QPARM2            WANT JCL?\n         LA    R15,3                    DSID FOR JCL?\n         LA    R14,=CL4'JCL '           GET FULL CHAR ID\n         BE    AT$ANYOK                 YES - USE IT\n         CLC   =C'JM',QPARM2            WANT JOBMSG?\n         LA    R15,4                    DSID FOR JOBLOG\n         LA    R14,=CL4'JMSG'           GET FULL CHAR ID\n         BE    AT$ANYOK                 YES - USE IT\n         LA    R15,QPARM2               POINT TO PARM\n         BAL   R14,QNUMCONV             CONVERT IT\n         BNE   AT$TILT1                 QUIT IF NOT NUMERIC\n         TM    QXAUTH,QXAUTHX           PRIVILEGED USER?\n         BNZ   AT$ANYOK                 YES - SKIP NEXT VALIDITY CHECK\n         CH    R15,=H'101'              DATASET ID LESS THAN 101?\n         BL    AT$TILT1                 YES - TILT\n          AIF  (&QLEVEL GE 9).AT01\nAT$ANYOK STH   R15,QPDSID               STORE DATASET ID\n          AGO  .AT02\n.AT01     ANOP ,\nAT$ANYOK STCM  R15,B'1111',QPDSID       store dataset id\n.AT02     ANOP ,\n         OI    QFLAG2,Q2VALIDS          INDICATE VALIDITY FOR LISTDS\n         MVC   QDHDSID,QPARM2           SET DSID\n***********************************************************************\n*                                                                     *\n*   LOCATE PDDB FOR DATASET SPECIFIED IN QPDSID                       *\n*                                                                     *\n***********************************************************************\n*T$USE   OC    QPDSID,QPDSID            ANY DSID?\nAT$USE   TM    QFLAG2,Q2VALIDS          ANY DSID?\n         BNZ   AT$HAVE\n         QTILT '*** NO DSID SELECTED ***'\nAT$HAVE  OI    QSCFLAG1,QSC1JOB         PUT THE JOBID IN QDTOP\n         QCALL DISP80                   SWITCH TO 3278-2 MODE IF 3278-5\n         MVC   QDHLINE(79),=CL79'Attributes for DSID xxxxxxxx'\n         MVC   AT@HDSID,QDHDSID         AND FILL IN DSID\n         OI    QFLAG1,Q1MVHDR           REQUEST \"MOVE HEADER\"\n         MVI   QGPFLAG,QPFDIR           get specific pddb\n         QCALL GETPDDB                  locate pddb entry\n         LTR   R6,R1                    copy pddb addr\n         BNP   QSTOP                    if none, error msg already out\n         USNGX PDBDSECT,R6              BASE REG FOR PDDB\n         SPACE 2\n*---  LINE 01\n         SR    R5,R5                    CLEAR ATTR BYTE COUNTER\n         BAL   R14,QADDLINE             DISPLAY A BLANK LINE\n         SPACE 2\n*---  LINE 02\n         QITEM 0+00,'PDBFLAG1',2+10,HEX,PDBFLAG1,1\n         QITEM 2+20,'PDBFLAG2',4+30,HEX,PDBFLAG2,1\n          AIF   (&QLEVEL LT 4).AT03\n         QITEM 4+40,'PDBFLAG3',6+50,HEX,PDBFLAG3,1\n         QITEM 6+60,'PDBSTAT',8+70,HEX,PDBSTAT,1\n.AT03    ANOP  ,\n         QITEM ADDLINE                  SET ATTR NUM AND DISPLAY LINE\n         SPACE 2\n          AIF   (&QLEVEL GT 9).AT04\n         TM    PDBFLAG1,PDB1DSID        DSID IN PDBDSID/PDBWTRID FIELD?\n         BZ    *+10                     NO - SKIP\n         MVC   AT@LINE+05(4),=C'DSID'\n.AT04    ANOP  ,\n         TM    PDBFLAG1,PDB1NULL        NULL PDDB?\n         BZ    *+10                     NO - SKIP\n         MVC   AT@LINE+10(4),=C'NULL'\n         TM    PDBFLAG1,PDB1LOG         HASP JOB LOG?\n         BZ    *+10                     NO - SKIP\n         MVC   AT@LINE+15(4),=C'JLOG'\n          AIF   (&QLEVEL GE 12).ATX04A  (maybe should check pdbstat??)\n         TM    PDBFLAG1,PDB1MDES        FOLLOWED BY PDDBS FOR MULT DEST\n         BZ    *+10                     NO - SKIP\n         MVC   AT@LINE+20(4),=C'MDES'\n          AGO   .ATX04B\n.ATX04A   ANOP\n         TM    PDBFLAG1,PDB1MOC         FOLLOWED BY PDDBS FOR MULT DEST\n         BZ    *+10                     NO - SKIP\n         MVC   AT@LINE+20(4),=C'MOC '\n.ATX04B   ANOP\n         TM    PDBFLAG1,PDB1NSOT        NOT FOR SYSOUT?\n         BZ    *+10                     NO - SKIP\n         MVC   AT@LINE+25(4),=C'NSOT'\n         TM    PDBFLAG1,PDB1SPIN        SPIN DATASET?\n         BZ    *+10                     NO - SKIP\n         MVC   AT@LINE+30(4),=C'SPIN'\n          AIF   (&QLEVEL GE 11).AT05    (maybe should check pdbstat??)\n         TM    PDBFLAG1,PDB1HOLD        HELD DATASET?\n         BZ    *+10                     NO - SKIP\n         MVC   AT@LINE+35(4),=C'HELD'\n         TM    PDBFLAG1,PDB1PSO         ACCESSIBLE BY PSO?\n         BZ    *+10                     NO - SKIP\n         MVC   AT@LINE+40(4),=C'PSO '\n          AGO   .AT06\n.AT05     ANOP  ,\n         TM    PDBFLAG1,PDB1NEWS        JESNEWS DATASET?\n         BZ    *+10                     NO - SKIP\n         MVC   AT@LINE+35(4),=C'NEWS'\n         TM    PDBFLAG1,PDB1USER        user?\n         BZ    *+10                     NO - SKIP\n         MVC   AT@LINE+40(4),=C'USER'\n.AT06     ANOP\n         CLC   AT@LINE,QBLANK           ANYTHING HERE?\n         BE    *+8                      NO - SKIP\n         BAL   R14,QADDLINE             YES - DISPLAY LINE\n*---  LINE 03\n         MVC   AT@WORK,QBLANK           clear out field\n         LA    R1,AT@WORK               -> start of field\n         MVI   0(R1),C'U'               start with u\n         TM    PDBRECFM,DCBRECU\n         BO    AT$RECB                  got it\n         MVI   0(R1),C'F'               try f\n         TM    PDBRECFM,DCBRECF\n         BO    AT$RECB                  got it\n         MVI   0(R1),C'V'               must be v\n         TM    PDBRECFM,DCBRECV\n         BO    AT$RECB                  got it\n         MVI   0(R1),C'U'               well, say it's u after all\nAT$RECB  LA    R1,1(,R1)                -> next char\n         TM    PDBRECFM,DCBRECBR        blocked?\n         BZ    AT$RECS                  no\n         MVI   0(R1),C'B'                 yes, insert\n         LA    R1,1(,R1)\nAT$RECS  TM    PDBRECFM,DCBRECSB        spanned/standard?\n         BZ    AT$RECC\n         MVI   0(R1),C'S'               yes\n         LA    R1,1(,R1)\nAT$RECC  TM    PDBRECFM,DCBRECCC        control chars\n         BZ    AT$REC\n         MVI   0(R1),C'A'               assume asa\n         TM    PDBRECFM,DCBRECCA\n         BO    AT$REC\n         MVI   0(R1),C'M'               must be machine\nAT$REC   LA    R1,1(,R1)\n         MVI   1(R1),C'('               (\n         UNPK  2(3,R1),PDBRECFM(2)       ??\n         TR    2(2,R1),QHEXTAB             )\n         MVI   4(R1),C')'\n         QITEM 0+00,'RECFM',2+10,CHAR,AT@WORK,9\n         QITEM 2+20,'LRECL',4+30,DEC,PDBLRECL,2\n         QITEM ADDLINE                  SET ATTR NUM AND DISPLAY LINE\n         SPACE 2\n*---  LINE 04\n         QITEM 0+00,'PDBMTTR',2+10,HEX,PDBMTTR,4\n          AIF   (&QLEVEL LT 4).AT07\n         QITEM 2+20,'PDBMTTRL',4+30,HEX,PDBMTTRL,4\n.AT07    ANOP  ,\n         QITEM ADDLINE                  SET ATTR NUM AND DISPLAY LINE\n         SPACE 2\n*---  LINE 05\n         QITEM 0+00,'Class',2+10,CHAR,PDBCLASS,1\n         QITEM 2+20,'Copies',4+30,DEC,PDBCOPYS,1\n         QITEM ADDLINE                  SET ATTR NUM AND DISPLAY LINE\n         SPACE 2\n*---  LINE 06\n*%%      MVC   AT@LINE(4+4),AT#DEST     'DESTINATION'\n         LA    R1,PDBDEST               POINT TO DESTINATION FIELD\n         QCALL FINDRJE                  CONVERT TO RJE ID\n*%%      MVC   AT@LINE+2+10(8),0(R1)    MOVE DEST NAME TO DISPLAY LINE\n*%%      CLC   AT@LINE+2+10(8),QBLANK   BLANK? (LOCAL)\n*%%      BNE   *+10                     NO - KEEP IT\n*%%      MVC   AT@LINE+2+10(7),=C'(LOCAL)'  YES - SAY SO\n*%%      CLC   AT@DWD,QBLANK            BLANK? (LOCAL)\n*%%      BNE   *+10                     NO - KEEP IT\n*%%      MVC   AT@DWD(7),=C'(LOCAL)'    YES - SAY SO\n*%%      LA    R5,2(,R5)                BUMP NUMBER OF ATTR BYTES\n         MVC   AT@DWD,0(R1)             SAVE DEST NAME\n         QITEM 0+00,'Dest',2+10,CHAR,AT@DWD,8\n          AIF   (&QLEVEL LT 4).AT08\n         QITEM 2+20,'PDBUSER',4+30,CHAR,PDBUSER,8\n.AT08    ANOP  ,\n          AIF   (&QLEVEL GE 7).AT09\n         QITEM 4+40,'PDBCPU',6+50,HEX,PDBCPU,1\n.AT09     ANOP\n*  % PDBSEC?\n         QITEM ADDLINE                  SET ATTR NUM AND DISPLAY LINE\n         SPACE 2\n*---  LINE 07\n         QITEM 0+00,'Records',2+10,DEC,PDBRECCT\n          AIF   (&QLEVEL LT 6).AT10\n         QITEM 2+25,'Pages',4+35,DEC,PDBPGCT\n         QITEM 4+50,'Bytes',6+60,DEC,PDBBYTCT\n.AT10    ANOP  ,\n         QITEM ADDLINE                  SET ATTR NUM AND DISPLAY LINE\n         SPACE 2\n*---  LINE 08\n          AIF   (&QLEVEL GT 4).AT11\n         QITEM 0+00,'Forms',2+10,CHAR,PDBFORMS,4\n          AGO   .AT12\n.AT11     ANOP\n         QITEM 0+00,'Forms',2+10,CHAR,PDBFORMS,8\n.AT12     ANOP\n         CLC   PDBFORMS,=CL8'&@@QSTDF'  default forms code?\n         BNE   *+10                     no, leave as is\n         MVC   AT@LINE+10+2(8),QBLANK   yes, clear it out\n         QITEM 2+20,'Fcb',4+30,CHAR,PDBFCB,4\n         QITEM 4+40,'Ucs',6+50,CHAR,PDBUCS,4\n          AIF   (&QLEVEL LT 6).AT13\n         QITEM 6+60,'Prmode',8+70,CHAR,PDBPRMD,8\n.AT13    ANOP  ,\n         QITEM ADDLINE                  SET ATTR NUM AND DISPLAY LINE\n         SPACE 2\n*---  LINE 09\n          AIF   (&QLEVEL LT 4).AT14\n         QITEM 0+00,'DDname',2+10,CHAR,PDBDDNAM,8\n         QITEM 2+20,'Proc Step',4+31,CHAR,PDBPNAME,8\n         QITEM 4+40,'Step Name',6+51,CHAR,PDBSNAME,8\n         QITEM ADDLINE                  SET ATTR NUM AND DISPLAY LINE\n         SPACE 2\n.AT14    ANOP  ,\n*---  LINE 10\n          AIF   (&QLEVEL GT 9).AT15\n         QITEM 0+00,'Dsid/Wtrid',2+30,CHAR,PDBDSID,8\n         AGO   .AT16\n.AT15    ANOP  ,\n         QITEM 0+00,'Wtrid',2+30,CHAR,PDBWTRID,8\n.AT16    ANOP  ,\n         QITEM 2+40,'PDBRBA',4+50,HEX,PDBRBA,4\n         QITEM                   ,,4+59,HEX,PDBRBA+4,4\n         QITEM ADDLINE                  SET ATTR NUM AND DISPLAY LINE\n         SPACE 2\n*---  LINE 11\n         QITEM 0+00,'Chars',2+10,CHAR,PDBCHAR1,4\n         MVC   AT@LINE+2+16(4),PDBCHAR2\n         MVC   AT@LINE+2+22(4),PDBCHAR3\n         MVC   AT@LINE+2+28(4),PDBCHAR4\n         QITEM 2+40,'Flash',4+50,CHAR,PDBFLASH,4\n         QITEM 4+60,'Modf',6+70,CHAR,PDBMODF,4\n         QITEM ADDLINE                  SET ATTR NUM AND DISPLAY LINE\n         SPACE 2\n*---  LINE 12\n         QITEM 0+00,'Flash Count',2+14,DEC,PDBFLSHC,1\n         QITEM 2+20,'TRC',4+30,CHAR,PDBMODFT,1\n         QITEM 4+40,'Copyg',6+50,HEX,PDBCOPYG,4\n         QITEM             ,,6+59,HEX,PDBCOPYG+4,4\n         QITEM ADDLINE                  SET ATTR NUM AND DISPLAY LINE\n         SPACE 2\n*---  LINE 13\n         QITEM 0+00,'Pages/Ckpt',2+12,DEC,PDBCKPTP,2\n         QITEM 2+20,'Lines/Ckpt',4+32,DEC,PDBCKPTL,2\n          AIF   (&QLEVEL LT 4).AT17\n         TM    PDBFLAG3,PDBLNCTF        lines/page specified?\n         BZ    AT$LN12                  no, skip output\n         QITEM 2+40,'Lines/Page',4+52,DEC,PDBLINCT,1\n.AT17    ANOP  ,\nAT$LN12  QITEM ADDLINE                  SET ATTR NUM AND DISPLAY LINE\n         SPACE 2\n          AIF   (&QLEVEL LT 4).AT18\n*---  LINE 14\n         QITEM 0+00,'Output Id',2+13,DEC,PDBID,2\n         QITEM 2+20,'Output Name',4+33,CHAR,PDBNAME,8\n         QITEM ADDLINE                  SET ATTR NUM AND DISPLAY LINE\n         SPACE 2\n*---  LINE 15\n         QITEM 0+00,'PDBCRTME',2+10,HEX,PDBCRTME,4\n         QITEM 2+20,'PDBPLIOT',4+30,HEX,PDBPLIOT,4\n         QITEM 4+40,'PDBPLOFF',6+50,HEX,PDBPLOFF,4\n         QITEM ADDLINE                  SET ATTR NUM AND DISPLAY LINE\n         SPACE 2\n.AT18    ANOP  ,\n         B     QSTOP\n         SPACE 3\n         DROPX R13,R6                   WORK, PDBDSECT\n         EJECT ,\nAT$TILT1 MVC   QERRMSG(14),=C'*** DATASET ID '\n         MVC   QERRMSG+15(8),QDHDSID    SHOW THE DSID\n         MVC   QERRMSG+24(11),=C'INVALID ***'\n         QTILT *,OPTIONS=REPROMPT\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*   MISCELLANY                                                        *\n*                                                                     *\n***********************************************************************\n         LTORG ,\n         SPACE 1\nAT#MASK  DC    X'402020',C',',X'202020',C',',X'202020',C',',X'202120'\nAT#MASKL EQU   *-AT#MASK\n         SPACE 1\n*%%  AT#DEST  DC    X'1DE8'                  OUTPUT, BRIGHT\n*%%      DC    C'Dest'\n*%%      DC    X'1D60'                  OUTPUT, NORMAL\n*%%      SPACE 1\n         QITEM GEN                      GEN ALL THE OTHER \"LITERALS\"\n         SPACE 3\nWORK     DSECT\n         ORG   WORK+72                  SKIP PAST SAVE AREA\nAT@DWD   DS    D\nAT@WORK  DS    2CL(AT#MASKL)\nAT@WORKL EQU   *-WORK\n         SPACE 3\n         QCOMMON\n         ORG   QDMSG\nAT@LINE  DS    CL(L'QDMSG)\n         ORG   QDHLINE\n         DS    C'ATTRIBUTES FOR DSID '\nAT@HDSID DS    CL8\n         SPACE 3\n         QZDCBD\n         Q$PDDB\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "Q#BL": {"ttr": 3333, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x17\\x00\\x00\\x00\\x82$/\\x00\\x892\\x7f\\x19W\\x01+\\x00\\x7f\\x00\\xed\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.23", "flags": 0, "createdate": "1982-08-30T00:00:00", "modifydate": "1989-11-23T19:57:00", "lines": 299, "newlines": 127, "modlines": 237, "user": "LDW"}, "text": " TITLE '--- QUEUE--BLKLIST -- LIST A JOB''S HASPACE CONTROL BLOCKS ---'\n*---------------------------------------------------------------------*\n*                                                                     *\n*   BLKLIST - List all the control blocks for a job which are         *\n*             resident on HASPACE (IOT, PDDB, HQT, HQR)               *\n*                                                                     *\n*   Note - This subcommand is restricted to privileged users          *\n*                                                                     *\n*   Updates:                                                          *\n*      23Nov89  LDW  Remove conditional assembly around dsect         *\n*                       expansion (now done in Qxxx macros)           *\n*      26Apr89  EMS  Update for SP311                                 *\n*      10Jan88  LDW  Update for QITEM macro (no more \"LC\")            *\n*       8Jul87  EMS  Update for Qitem enhancements                    *\n*                    FIX for base jes2                                *\n*                    Update to call GETPDDB                           *\n*      22May87  EMS  Fix bug caused by fix of bug in QITEM macro      *\n*      21Mar87  LDW  Fix bug                                          *\n*      25Jan87  LDW  Pass READSPC the JQE addr in case of CB ID error *\n*      03/31/86 LDW  RE-DESIGN 3278-5 SUPPORT (THIRD TRY!)            *\n*      08/09/84 LDW  UPDATE FOR SP134 (USE IOTPDDB INSTEAD OF         *\n*                       QCPDDB1)                                      *\n*                    FIX BUG IN 'NO SPIN IOT' MESSAGE                 *\n*      04/11/84 LDW  JCTDSECT -> JCTSTART, IOTDSECT -> IOTSTART,      *\n*                       HQTDSECT -> HQTSTART (FOR $BUFFER)            *\n*                    USING/DROP -> USNGX/DROPX                        *\n*      04/10/84 LDW  ADD PRELIMINARY SP133 COMPATIBILITY              *\n*      01/17/84 LDW  ADD SUPPORT FOR COMMAND STACKING                 *\n*                    ADD SPECIAL MESSAGE FOR NO SPIN IOT CHAIN        *\n*      11/21/83 LDW  FIX BUG:  PDBFLAG2 COLUMN CONTAINED PDBFLAG1     *\n*      01/24/83 LDW  EXPAND IOT DISPLAY                               *\n*                    SKIP AROUND HQT/HQR CODE FOR SP                  *\n*      01/17/83 LDW  CHANGE FOR NEW QITEM USING \"LC\" & HIGH INTENSITY *\n*                    DISPLAY MTTR IN HQT TYPE PDDBS ALSO              *\n*      01/04/83 LDW  ADD WORKLEN=                                     *\n*                    CHANGE HEADER TO LOWER CASE                      *\n*      12/13/82 LDW  PICK UP FIRST HQT ADDR FROM JCT                  *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 3\nBLKLIST  QSTART  WORKLEN=BL@WORKL,STACK=X'30'\n         USNGX WORK,R13\n         QITEM RESET,PREFIX=BL          RESET GLOBAL ARRAY POINTER\n         MVI   BL@FLAG,0\n         QCALL FINDJOB                  LOCATE THE JOB'S JCT\n         QCALL DISP80                   SWITCH TO 3278-2 MODE IF 3278-5\n         MVC   QDHLINE(31),=C'HASPACE resident control blocks'\n         OI    QSCFLAG1,QSC1JOB         PUT JOBID IN QDTOP\n         L     R9,QCJCTA                -> JCT\n         USNGX JCTSTART,R9\n         BAL   R14,QADDLINE             PUT OUT A BLANK LINE\n         QITEM 0,'------------------ Regular IOT chain from JCTIOT (xxx$\n               xxxxx)  ------------------',2+50,HEX,JCTIOT,4\n         MVI   BL@LINE+2+58,C')'\n         QITEM ADDLINE                  drive out line\n***********************************************************************\n*                                                                     *\n*        RUN THE CHAIN OF REGULAR IOT'S, THEN SPIN IOT'S              *\n*                                                                     *\n***********************************************************************\n         MVI   QGPFLAG,QPFINIT+QPFNOSW  start, don't switch iot chains\nBL$LOOP1 QCALL GETPDDB                  get next pddb\n         LTR   R4,R1                    copy pddb addr\n         USNGX PDBDSECT,R4\n         BZ    BL$END1                  YES\n         TM    QGPFLAG,QPFNIOT          new iot?\n         BZ    BL$LOOP2                 no, just dump pddb\n         BAL   R14,QADDLINE             PUT OUT A BLANK LINE\n         L     R3,QCIOTA                -> current iot\n         USNGX IOTSTART,R3\n         QITEM 0+00,'IOTFLAG1,2',2+12,HEX,IOTFLAG1,2\n         QITEM 2+20,'IOTIOTTR',4+30,HEX,IOTIOTTR,4\n         QITEM 4+40,'IOTJQOFF',6+50,HEX,IOTJQOFF,4\n          AIF   (&QLEVEL GT 4).BL01\n         QITEM 6+60,'IOTSPIOT',8+70,HEX,IOTSPIOT,4\n.BL01     ANOP\n         QITEM ADDLINE                  DISPLAY THE LINE\n          AIF   (&QLEVEL GE 4).BL02\n         QITEM 0+00,'IOTHQT1',2+10,HEX,IOTHQT1,4\n         QITEM 2+20,'IOTHQT',4+30,HEX,IOTHQT,4\n         QITEM 4+40,'IOTHQRCT',6+50,HEX,IOTHQRCT,2\n         QITEM 6+60,'IOTPDDBP',8+70,HEX,IOTPDDBP,4\n          AGO   .BL05\n.BL02     ANOP\n         QITEM 0+20,'IOTJBKEY',2+30,HEX,IOTJBKEY,4\n          AIF   (&QLEVEL GT 4).BL03\n         QITEM 2+40,'IOTHDSCT',4+50,HEX,IOTHDSCT,2\n          AGO   .BL04\n.BL03     ANOP\n         QITEM 2+40,'IOTPDDB',4+50,HEX,IOTPDDB,4\n.BL04     ANOP\n         QITEM 4+60,'IOTPDDBP',6+70,HEX,IOTPDDBP,4\n.BL05     ANOP\n         QITEM ADDLINE                  DISPLAY THE LINE\n***********************************************************************\n*                                                                     *\n*        FORMAT EACH PDDB IN THIS IOT                                 *\n*                                                                     *\n***********************************************************************\n         MVC   BL@LINE(BL#HDR2L),BL#HDR2  'PDDBS IN THIS IOT'\n         MVI   QDATRNUM+1,2*1           DISPLAY THE LINE\n         BAL   R14,QADDLINE\n         MVC   BL@LINE(BL#HDR4L),BL#HDR4  PDDB HEADER\n         MVI   QDATRNUM+1,2*1           DISPLAY THE LINE\n         BAL   R14,QADDLINE\n*BL$LOOP2 EQU   *\nBL$LOOP2 QITEM ,,01,HEX,PDBFLAG1,1\n         QITEM ,,04,HEX,PDBRECFM,1\n         QITEM ,,07,HEX,PDBLRECL,2\n         QITEM ,,12,HEX,PDBMTTR,4\n          AIF  (&QLEVEL GE 9).BL12\n         QITEM ,,21,HEX,PDBDSKEY,2\n          AGO  .BL13\n.BL12     ANOP ,\n         QITEM ,,21,HEX,PDBDSKEY+2,2   kludge to show 2 bytes of data\n.BL13     ANOP ,\n         QITEM ,,26,CHAR,PDBCLASS,1\n         QITEM ,,28,HEX,PDBCOPYS,1\n         QITEM ,,31,HEX,PDBDEST,2\n         QITEM ,,36,HEX,PDBFLAG2,1\n         QITEM ,,39,HEX,PDBRECCT+1,3\n         QITEM ,,46,CHAR,PDBWTRID,8\n         QITEM ,,55,CHAR,PDBCHAR1,4\n         QITEM ,,60,CHAR,PDBCHAR2,4\n         QITEM ,,65,CHAR,PDBCHAR3,4\n         QITEM ,,70,CHAR,PDBCHAR4,4\n         QITEM ,,75,CHAR,PDBMODF,4\n         BAL   R14,QADDLINE             PUT OUT THIS LINE\n         B     BL$LOOP1                 and get next\n         DROPX R3,R4                    IOTSTART, PDBDSECT\n         SPACE 2\nBL$END1  TM    QGPFLAG,QPFSPIN          Running spin IOT chain?\n          AIF   (&QLEVEL GE 4).BL06\n         BO    BL$END1X                 Yes - done with all IOT'S\n          AGO   .BL07\n.BL06     ANOP\n         BO    QSTOP                    Yes - done with all IOT'S\n.BL07     ANOP\n         MVI   QGPFLAG,QPFINIT+QPFSPIN  Indicate running spin IOT's\n         BAL   R14,QADDLINE             PUT OUT A BLANK LINE\n         BAL   R14,QADDLINE             PUT OUT A BLANK LINE\n         CLC   JCTSPIOT,=F'0'           ANY SPIN IOT CHAIN?\n         BE    BL$NSPIN                 NO - SPECIAL MESSAGE\n         QITEM 0,'------------------  Spin IOT chain from JCTSPIOT (xxx$\n               xxxxx)  ------------------',                            $\n               2+50,HEX,JCTSPIOT,4\n         MVI   BL@LINE+2+58,C')'\n         QITEM ADDLINE                  DISPLAY THE LINE\n         B     BL$LOOP1                 PROCESS ALL SPIN IOT'S\n         SPACE 2\nBL$NSPIN MVC   BL@LINE(BL#NSPNL),BL#NSPIN  MOVE IN MESSAGE\n         MVI   QDATRNUM+1,2*1           NUMBER OF ATTR BYTES\n         BAL   R14,QADDLINE             DISPLAY THE LINE\n         BAL   R14,QADDLINE             ADD A BLANK LINE\n         MVI   BL@FLAG,255              INDICATE SPIN IOT CHAIN DONE\n         B     BL$END1                  CONTINUE PROCESSING\n         SPACE 2\n          AIF   (&QLEVEL GE 4).BL08\n***********************************************************************\n*                                                                     *\n*        RUN THE CHAIN OF HQT'S                                       *\n*                                                                     *\n***********************************************************************\nBL$END1X MVC   QCTRAK,JCTHQT            GET MTTR OF FIRST HQT\n         BAL   R14,QADDLINE             PUT OUT A BLANK LINE\n         BAL   R14,QADDLINE             PUT OUT A BLANK LINE\n         OC    QCTRAK,QCTRAK            ANY HQT CHAIN?\n         BZ    BL$NOHQT                 NO - SPECIAL MESSAGE\n         QITEM 0,'-----------------------  HQT chain starting at xxxxxx$\n               xx  ----------------------',2+47,HEX,JCTHQT,4\n         QITEM ADDLINE                  display the line\nBL$LOOP3 CLC   QCTRAK,=F'0'             END OF HQT CHAIN?\n         BE    QSTOP                    YES\n         BAL   R14,QADDLINE             PUT OUT A BLANK LINE\n         MVC   QCCBID,=C'HQT '          SAY WE WANT AN HQT\n         BAL   R8,BL$READ               READ IT\n         USNGX HQTSTART,R3\n         QITEM 0+00,'HQTFLAG1,2',2+12,HEX,HQTFLAG1,2\n         QITEM 2+21,'HQTHQT',4+29,HEX,HQTHQT,4\n         QITEM ADDLINE                  display the line\n***********************************************************************\n*                                                                     *\n*        FORMAT EACH HQR IN THIS HQT                                  *\n*                                                                     *\n***********************************************************************\n         MVC   BL@LINE(BL#HDR3L),BL#HDR3  'HQRS IN THIS HQT'\n         MVI   QDATRNUM+1,2*1           NUMBER OF ATTR BYTES IN LINE\n         BAL   R14,QADDLINE             DISPLAY THE LINE\n         LA    R4,HQTHQR                -> FIRST PDDB IN IOT\n         USNGX PDBDSECT-(HQRPDDB-HQRDSECT),R4\n         MVC   BL@LINE(BL#HDR5L),BL#HDR5  HQT TYPE PDDB HEADER\n         MVI   QDATRNUM+1,2*1           NUMBER OF ATTR BYTES IN LINE\n         BAL   R14,QADDLINE             DISPLAY THE LINE\nBL$LOOP4 QITEM ,,01,HEX,PDBFLAG1,1\n         QITEM ,,04,HEX,PDBRECFM,1\n         QITEM ,,07,HEX,PDBLRECL,2\n         QITEM ,,12,HEX,PDBMTTR,4\n         QITEM ,,21,HEX,PDBDSKEY,2\n         QITEM ,,26,CHAR,PDBCLASS,1\n         QITEM ,,28,HEX,PDBCOPYS,1\n         QITEM ,,31,HEX,PDBDEST,2\n         QITEM ,,36,HEX,PDBFLAG2,1\n         QITEM ,,39,HEX,PDBRECCT+1,3\n         QITEM ,,46,CHAR,PDBCHAR1,4\n         DROPX R4                       PDBDSECT\n         USNGX HQRDSECT,R4\n         QITEM ,,52,HEX,HQRIOT,4\n         QITEM ,,61,HEX,HQRIOTTR,4\n         QITEM ,,70,HEX,HQRSTAT,1\n         QITEM ,,73,HEX,HQRCRDT+1,3\n         BAL   R14,QADDLINE             PUT OUT THIS LINE\n         LA    R4,HQRLENG(,R4)          -> NEXT HQR\n         LR    R0,R3                    COPY ADDR OF HQT\n         A     R0,HQTHQRP               + OFFSET BEYOND HQT'S LAST HQR\n         SH    R0,=Y(HQRLENG)           WHY DO I NEED THIS????\n         CLR   R4,R0                    DONE LAST HQR IN THIS HQT?\n         BL    BL$LOOP4                 NO - DO NEXT\n         DROPX R4                       HQRDSECT\n         MVC   QCTRAK,HQTHQT            GET HQT CHAIN ADDRESS\n         B     BL$LOOP3                 PROCESS\n         DROPX R3                       HQTSTART\n         SPACE 2\nBL$NOHQT MVC   BL@LINE(BL#HDR6L),BL#HDR6  'NO HQT CHAIN'\n         MVI   QDATRNUM+1,2*1           NUMBER OF ATTR BYTES IN LINE\n         BAL   R14,QADDLINE             DISPLAY THE LINE\n         B     QSTOP\n.BL08     ANOP\n         SPACE 3\nBL$READ  LR    R1,R3                    SET FOR READSPC\n         L     R0,JCTJQE                GET JQE OFFSET\n         AL    R0,QCJQTA                -> JQE\n         QCALL READSPC                  READ THE BLOCK\n         BR    R8                       RETURN TO CALLER\n***********************************************************************\n*                                                                     *\n*        CONSTANTS                                                    *\n*                                                                     *\n***********************************************************************\n         LTORG\n         SPACE 1\nBL#HDR2  DC    X'1DE8'                  OUTPUT, BRIGHT\n         DC    C'--- PDDB''s in this IOT ---'\n         DC    X'1D60'                  OUTPUT, NORMAL\nBL#HDR2L EQU   *-BL#HDR2\n         SPACE 1\n          AIF   (&QLEVEL GE 4).BL09\nBL#HDR3  DC    X'1DE8'                  OUTPUT, BRIGHT\n         DC    C'--- HQR''s in this HQT ---'\n         DC    X'1D60'                  OUTPUT, NORMAL\nBL#HDR3L EQU   *-BL#HDR3\n.BL09     ANOP\n         SPACE 1\nBL#HDR4  DC    X'1DE8'                  OUTPUT, BRIGHT\n         DC    C'F1 RF  LR    MTTR  DSKEY C CY DEST FL2 RECCT WTRNAME  $\n               X1   X2   X3   X4   MODF'\n         DC    X'1D60'                  OUTPUT, NORMAL\nBL#HDR4L EQU   *-BL#HDR4\n         SPACE 1\n          AIF   (&QLEVEL GE 4).BL10\nBL#HDR5  DC    X'1DE8'                  OUTPUT, BRIGHT\n         DC    C'F1 RF  LR    MTTR  DSKEY C CY DEST FL2 RECCT X1     HQ$\n               RIOT  HQRIOTTR ST HQRCRDT'\n         DC    X'1D60'                  OUTPUT, NORMAL\nBL#HDR5L EQU   *-BL#HDR5\n         SPACE 1\nBL#HDR6  DC    X'1DE8'                  OUTPUT, BRIGHT\n         DC    '-------------------------------- No HQT Chain ---------$\n               -----------------------'\n         DC    X'1D60'                  OUTPUT, NORMAL\nBL#HDR6L EQU   *-BL#HDR6\n.BL10     ANOP\n         SPACE 1\nBL#NSPIN DC    X'1DE8'                  OUTPUT, BRIGHT\n         DC    C'------------------------------ No Spin IOT Chain -----$\n               ------------------------'\n         DC    X'1D60'                  OUTPUT, NORMAL\nBL#NSPNL EQU   *-BL#NSPIN\n         SPACE 1\n         QITEM GEN                      GEN ALL THE OTHER \"LITERALS\"\n         DROPX R13,R9                   WORK, JCTSTART\n***********************************************************************\n*                                                                     *\n*        DESCRIBE ALL THE DSECTS NEEDED BY THIS MODULE                *\n*                                                                     *\n***********************************************************************\nWORK     DSECT\n         ORG   WORK+72                  SKIP OVER SAVE AREA\nBL@FLAG  DS    X\nBL@WORKL EQU   *-WORK\n         SPACE 2\n         QCOMMON\n         ORG   QDMSG\nBL@LINE  DS    CL80\n         SPACE 3\n         Q$JCT\n         Q$PDDB\n         Q$IOT\n         Q$HQR\n         Q$HQT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "Q#CB": {"ttr": 3339, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x903\\x0f\\x00\\x904\\x8f\\x16A\\x02\\xba\\x04\\xdf\\x00\\x00\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-11-26T00:00:00", "modifydate": "1990-12-14T16:41:00", "lines": 698, "newlines": 1247, "modlines": 0, "user": "LDW"}, "text": "         TITLE '--- QUEUE--CBFMT -- FORMAT JES2 CONTROL BLOCKS ---'\n*---------------------------------------------------------------------*\n*                                                                     *\n*   CBFMT -  Format a JES2 control block                              *\n*                                                                     *\n*   Note - All subcommands are restrict ed to privileged users        *\n*                                                                     *\n*   Updates:                                                          *\n*      02Dec90  LDW  Created by copying \"DUMP\" routine from an old    *\n*                       copy of a different version of QUEUE          *\n*                       (Actually, this is a major rewrite, so *DMS*  *\n*                       flags have been removed)                      *\n*                    Use CHARTAB (in LISTDS) instead of TBL1,         *\n*                       QHEXTAB instead of TBL                        *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 3\nCBFMT    QSTART  ,WORKLEN=CB@WORKL      ,stack=x'??'\n         USNGX WORK,R13\n         XC    DALLREG,DALLREG          initialize\n         LH    R3,QCODEH                get subcommand code\n         LTR   R3,R3                    is it CB subcommand?\n         BZ    CB$CB                    yes - go handle it\n         QCALL CKPT                     read checkpoint data\n         B     *(R3)                    go to routine\n         EX    0,*    B  CB$QCMN        04 - QCMN\n         B     CB$CKPT                  08 - CKPT\n         B     CB$HCT                   12 - HCT\n         B     CB$JOT                   16 - JOT\n         EX    0,*    B  DIRJCT         20 - JCT\n         B     DIRJQE                   24 - JQE\n         B     DIRJOE                   28 - JOE\n***********************************************************************\n*                                                                     *\n*   Call FINDJOB to locate JQE, JCT, and IOT                          *\n*                                                                     *\n***********************************************************************\nCB$CB    QCALL FINDJOB                  routine to find job\n         OI    QSCFLAG1,QSC1JOB         put jobid in QDTOP\n         EJECT\n***********************************************************************\n*                                                                     *\n*   determine the control block to be formatted                       *\n*                                                                     *\n***********************************************************************\n         CLC   =C'ALL ',QPARM2          format all CBs for a job?\n         BE    CB$JALL                  yes. go process\n         CLC   =C'JQE ',QPARM2          dump the jqe?\n         BE    CB$JQE                   yes. go process\n         CLC   =C'JCT ',QPARM2          dump the jct?\n         BE    CB$JCT                   yes. go process\n         CLC   =C'JOE ',QPARM2          dump the joe?\n         BE    CB$JOE                   yes. go process\n         CLC   =C'IOT ',QPARM2          dump the iot?\n         BE    CB$IOT                   yes. go process\n         CLC   =C'PDDB ',QPARM2         dump the pddb?\n         BE    CB$PDDB                  yes. go process\n          AIF   (&@@ACF2 EQ 0).CB010\n         CLC   =C'ACF2 ',QPARM2         dump the acf2 njh?\n         BE    CB$ACF2                  yes. go process\n.CB010    ANOP\n         MVC   QERRMSG(49),=C'*** \"        \" IS AN UNKNOWN CONTROL BLOC$\n               K ID ***'\n         MVC   QERRMSG+5(8),QPARM2      fill in cb id\n         QTILT *,OPTIONS=REPROMPT\n         B     QSTOP\n***********************************************************************\n*                                                                     *\n*   dump all the control blocks for the job                           *\n*                                                                     *\n***********************************************************************\nCB$JALL  LA    R2,CB$FIRST              -> first cb to be formatted\n         ST    R2,DALLREG               save address\nCB$FIRST B     CB$JQE                   dump JQE\n         B     CB$JCT                   dump JCT\n          AIF   (&@@ACF2 EQ 0).CB020\n         B     CB$ACF2                  dump acf2 njh\n.CB020    ANOP\n         B     CB$JOE                   dump JOE\n         B     CB$IOT                   dump IOT\n         B     CB$PDDB                  dump PDDB\n         B     QSTOP                    exit\n***********************************************************************\n*                                                                     *\n*   format the jqe                                                    *\n*                                                                     *\n***********************************************************************\nCB$JQE   MVC   QDHLINE,QBLANK           clear the header line\n         MVC   QDHLINE(15),=C'===  J Q E  ==='\n         L     R2,=A(CB#D#JQE)          a(jqe description)\n         L     R4,QCJQEA                addr of input data\n         BAL   R3,CB$FMT                go format the jqe\n         B     CB$DONE                  exit\n***********************************************************************\n*                                                                     *\n*   format the joe                                                    *\n*                                                                     *\n***********************************************************************\nCB$JOE   MVC   QDHLINE,QBLANK           clear the header line\n         MVC   QDHLINE(15),=C'===  J O E  ==='\n         L     R1,QCJQEA                a(jqe)\n*%       USNGX JQEDSECT,R1              base reg for jqe\n         QNEXT R4,JQEJOE-JQE(R1)        joe offset\n*%       DROPX R1\nCB$JOELP LTR   R4,R4                    ?/joe present\n         BZ    CB$DONE                  no. exit\n         MVC   QDMSG(21),=C'***  Work  J O E  ***'\n         ST    R4,QNUMWORK              set offset\n         HEX   QDMSG+22,QNUMWORK+1,LEN=3,HEXTAB=QHEXTAB\n         BAL   R14,QADDLINE             add line to screen buffer\n         L     R1,QCJOTA                a(jot)\n         AR    R4,R1                    a(joe)\n         ST    R4,JOEADDR               save joe addr\n         L     R2,=A(CB#DWJOE)          a(work joe description)\n         BAL   R3,CB$FMT                branch to format routine\n*%       MVC   QDMSG,QBLANK             blank out the message area\n         BAL   R14,QADDLINE             add blank line to screen buffer\n         L     R4,JOEADDR               restore joe addr\n         USNGX JOEDSECT,R4              base reg for joe\n         QNEXT R5,JOECHAR,NONE=CB$NCHAR get address of char joe\n         MVC   QDMSG(21),=C'***  Char  J O E  ***'\n         ST    R5,QNUMWORK              set offset\n         HEX   QDMSG+22,QNUMWORK+1,LEN=3\n         BAL   R14,QADDLINE             add line to screen buffer\n         A     R5,QCJOTA                add offset\n         LR    R4,R5                    r4 - char joe offset\n         L     R2,=A(CB#DCJOE)          a(char joe description)\n         BAL   R3,CB$FMT                branch to format routine\n*%       MVC   QDMSG,QBLANK             blank out the message area\n         BAL   R14,QADDLINE             add blank line to screen buffer\n         L     R4,JOEADDR               restore joe addr\nCB$NCHAR QNEXT R5,JOEJQNXT              get next joe offset\n         LR    R4,R5                    r4 - work joe offset\n         B     CB$JOELP                 go thru the cycle again\n         DROPX R4\n         EJECT\n***********************************************************************\n*                                                                     *\n*   format the jct                                                    *\n*                                                                     *\n***********************************************************************\nCB$JCT   MVC   QDHLINE,QBLANK           clear the header line\n         MVC   QDHLINE(15),=C'===  J C T  ==='\n         LA    R2,CB@WDJCT              load address of work desc\n         L     R3,=A(CB#JCTDL)          load length  of jct  desc\n         L     R4,=A(CB#D#JCT)          load address of jct  desc\n         LR    R5,R3                    load length again\n         MVCL  R2,R4                    move desc to working storage\n         L     R4,QCJCTA                a(input data)\n         USNGX JCT,R4                   temp addressability to jct\n         CLI   JCTJOBID,C'J'            is this a job?\n         BE    CB$J                     yes  no change necessary\n         LA    R2,CB@WDJCT              get address\n         NI    PRTYTYP(R2),X'FF'-X'80'  don't display as character\n         DROPX R4                       drop addressability\nCB$J     DS    0H\n         LA    R2,CB@WDJCT              a(jct description)\n         L     R4,QCJCTA                a(input data)\n         BAL   R3,CB$FMT                go format the data\n         B     CB$DONE                  exit\n         EJECT\n          AIF   (&@@ACF2 EQ 0).CB030\n******************************************************************\n*\n*   format the acf2 jetwork job header.\n*\n******************************************************************\nCB$ACF2  MVC   QDHLINE,QBLANK           clear the header line\n         MVC   QDHLINE(27),=C'===  a c f 2     N J H  ==='\n         L     R2,=A(CB#D#ACF)          a(njh description)\n         L     R4,QCJCTA                a(input data)\n         USNGX JCT,R4                   temp address to jct\n*\n*   find the acf2 nhd (job network header).\n*   code taken from acf2 distributed source (acf2a1).\n*\n         LA    R8,JCTNJHDR              addr network job header\n         LH    R15,0(,R8)               get length of block\n         SH    R15,=H'4'                subtract the prefix\n         LA    R8,4(,R8)                point to first section\nCB$A2NJL CLC   2(6,R8),CB#A2ID          acf2 section?\n         BE    CB$A2FND                 br if yes\n         SH    R15,NJHGLEN-NJHG(,R8)    subtract length of sect\n         BNP   CB$NACF2                 no more rec - not acf job\n         AH    R8,NJHGLEN-NJHG(,R8)     bump to next section\n         B     CB$A2NJL\n         SPACE 1\nCB#A2ID  DC    B'11100000'\n         DC    B'00000001'\n         DC    CL4'ACF2'\n         SPACE 1\n         DROPX R4\nCB$A2FND DS    0H\n         LA    R4,ACFNJSEC-ACFNJBLK(,R8)    point after garbage\n         BAL   R3,CB$FMT                go format the data\nCB$NACF2 DS    0H\n         B     CB$DONE                  exit\n.CB030    ANOP\n***********************************************************************\n*                                                                     *\n*   format the iot                                                    *\n*                                                                     *\n***********************************************************************\nCB$IOT   MVC   QDHLINE,QBLANK           clear the header line\n         MVC   QDHLINE(15),=C'===  I O T  ==='\n         MVI   CB@SW,0\n         L     R4,QCIOTA                a(input data)\n         LTR   R4,R4                    ?/iot valid\n         BZ    CB$DONE                  no. exit\nCB$IOTLP ST    R4,IOTADDR               yes. save for later use\n         L     R2,=A(CB#D#IOT)          a(iot description)\n         BAL   R3,CB$FMT                go format the data\n         MVC   QDMSG,QBLANK             blank out the message area\n         BAL   R8,CB$DISP1              go display the blank line\n         L     R4,IOTADDR               restore iot addr\n         L     R4,IOTIOTTR-IOT(,R4)     get addr of next iot\nCB$IOT$2 LTR   R4,R4                    ?/next iot present\n         BZ    CB$SPIOT                 no. check spin iot's\n         BAL   R8,READ                  yes. read the iot in\n         B     CB$IOTLP\nCB$SPIOT TM    CB@SW,1                  ?/spin iot already searched\n         BO    CB$DONE                  yes. exit\n         OI    CB@SW,1                  no. indicate now being searched\n         L     R4,QCJCTA                a(jct)\n         L     R4,12(R4)                get addr of spin iot\n         B     CB$IOT$2                 go verify the iot is valid\n         EJECT\n***********************************************************************\n*                                                                     *\n*   format the pddb                                                   *\n*                                                                     *\n***********************************************************************\nCB$PDDB  MVC   QDHLINE,QBLANK           clear the header line\n         MVC   QDHLINE(17),=C'===  P D D B  ==='\n         MVI   CB@SW,0                  initialize switch\n         MVC   PDDBKEY,=H'0'            initialize dsid key\n         USNGX PDBDSECT,R2              base reg for pddb\n         USNGX IOTDSECT,R3              base reg for iot\n         CLI   QPARM3,C' '              was a specific pddb requested?\n         BNE   PDDBS                    yes  go get it\nSPDDB    L     R3,QCIOTA                load base reg\n         LR    R4,R3                    base of iot\nCB$PDDB2 A     R4,IOTPDDBP              offset beyond last pddb\n         SH    R4,=Y(BUFSTART-BUFDSECT) adjust for hasp buffer prefix\n         LR    R2,R3                    base of iot\n         A     R2,IOTPDDB               offset to first pddb in iot\n         SH    R2,=Y(BUFSTART-BUFDSECT) adjust for hasp buffer prefix\nCB$PDDB3 ST    R2,PDDBADDR              save addr of pddb\n         ST    R3,IOTADDR               save addr of iot\n         ST    R4,LASTPDDB              save addr of last pddb\n         LH    R4,PDDBKEY               load dsid key\n         LTR   R4,R4                    was a specific one requested?\n         BZ    CB$DPDDB                 no  skip test\n         CH    R4,PDBDSKEY              it this the correct one\n         BNE   CB$NPDDB                 no  skip to next one\nCB$DPDDB LR    R4,R2                    addr of input dataet?\n         L     R2,=A(CB#D#PDB)          a(pddb description)\n         BAL   R3,CB$FMT                go format the pddb\n         MVC   QDMSG,QBLANK             blank out the message area\n         BAL   R8,CB$DISP1              go display the blank line\nCB$NPDDB L     R2,PDDBADDR              restore addr of pddb\n         L     R3,IOTADDR               restore addr of iot\n         L     R4,LASTPDDB              restore addr of last pddb\n         LA    R2,PDBLENG(,R2)          no. look at next pddb.\n         CR    R2,R4                    gone past the last pddb?\n         BNL   CB$PDDB4                 yes. get next pddb\n         CLC   PDBDSKEY,=H'0'           ?/valid pddb\n         BNE   CB$PDDB3                 yes. go process\nCB$PDDB4 L     R4,IOTIOTTR              disk addr of next iot\nCB$PDDB5 LTR   R4,R4                    is there another iot?\n         BZ    CB$PDDB6                 no. try the spin iot?\n         BAL   R8,READ                  read the iot\n         B     CB$PDDB2                 search the next iot\n         USNGX JCT,R1                   base reg for jct\nCB$PDDB6 TM    CB@SW,1                  spin iot chain already done?\n         BO    CB$DONE                  yes. exit.\n         OI    CB@SW,1                  set switch\n         L     R1,QCJCTA                load base reg\n         L     R4,JCTSPIOT              disk addr of spin iot\n         B     CB$PDDB5                 search the spin iot chain\n         EJECT\n***********************************************************************\n*                                                                     *\n*   check if requesting a specific pddb                               *\n*                                                                     *\n***********************************************************************\nPDDBS    LH    R1,QLNG3                 length of dataset id field\n         SH    R1,=H'1'                 is dsid field zero length?\n         BM    PDBTILT                  yes. quit.\n         LA    R15,QPARM3               -> parm to be converted\n         BAL   R14,QNUMCONV             convert to decimal\n         BNE   PDBTILT                  complain if not decimal\n         STH   R15,PDDBKEY              store requested dsid key\n         B     SPDDB                    and return to caller\nPDBTILT  QTILT '*** illegal pddb number requested ***'\n         DROPX R1,R2,R3\n         EJECT\n***********************************************************************\n*                                                                     *\n*   format the hct                                                    *\n*                                                                     *\n***********************************************************************\nCB$HCT   MVC   QDHLINE,QBLANK           clear the header line\n         MVC   QDHLINE(36),=C'===  HCT checkpointed variables  ==='\n         L     R2,=A(CB#D#HCT)          a(hct description)\n         L     R4,QCJQTL                addr of input data\n         BAL   R3,CB$FMT                go format the hct\n         B     CB$DONE                  exit\n***********************************************************************\n*                                                                     *\n*   format the jot                                                    *\n*                                                                     *\n***********************************************************************\nCB$JOT   MVC   QDHLINE,QBLANK           clear the header line\n         MVC   QDHLINE(26),=C'===  Job Output Table  ==='\n         L     R2,=A(CB#D#JOT)          a(jot description)\n         L     R4,QCJOTA                addr of input data\n         BAL   R3,CB$FMT                go format the jot\n         B     CB$DONE                  exit\n***********************************************************************\n*                                                                     *\n*   format the checkpoint                                             *\n*                                                                     *\n***********************************************************************\nCB$CKPT  MVC   QDHLINE,QBLANK           clear the header line\n         MVC   QDHLINE(27),=C'===  Checkpoint  record ==='\n         L     R2,=F'4096'              length of ckpt records\n         L     R4,QCJQTL                a(first checkpoint record)\n         L     R6,QCJOTL                no. of checkpoint records\n         LA    R6,0(,R6)                purify the reg\n         SR    R5,R5                    clear offset register\n         B     CKPT010                  go format the data\n******************************************************************\n*\n*   format  jqe/joe for a given offset from jqt/jot\n*\n******************************************************************\nDIRJQE   DS    0H\n         BAL   R14,CB$COFF              convert offset from QPARM1\n*\n*  first of all, the offset should be a multiple of jqe length.\n*\n         LTR   R4,R4                    zero offset is invalid\n         BZ    DIRTILT\n         LH    R15,QCJQELEN             load jqe length.\n         LR    R1,R4\n         SLR   R0,R0\n         DR    R0,R15\n         LTR   R0,R0                    zero remainder ?\n         BNZ   DIRTILT                  no - tilt.\n*\n*  then, the offset should be within the jqt.\n*\n         L     R1,QCJQTL                get ckpt record.\n         LH    R1,$MAXJOBS-$SAVEBEG(,R1)   maxjobs from hct\n         MR    R0,R15                   maximum avl offset..\n         CLR   R4,R1                    what have you ?\n         BH    DIRTILT                  to high an offset.\n         AL    R4,QCJQTA                + jqt address is jqe.\n         L     R2,=A(CB#D#JQE)          description of jqe\n         BAL   R3,CB$FMT                format it.\n         MVC   QDHLINE,QBLANK           clear the header line\n         MVC   QDHLINE(15),=C'===  J Q E  ==='\n         B     CB$DONE\n*\nDIRJOE   DS    0H\n         BAL   R14,CB$COFF              convert offset from QPARM1\n*\n* validate divisability by joesize and being between jotjoes\n* and end of joes.\n*\n         LA    R15,JOESIZE              load joe length.\n         LR    R1,R4                    our offset.\n         SLR   R0,R0                    clear for divide.\n         DR    R0,R15\n         LTR   R0,R0                    zero remainder ?\n         BNZ   DIRTILT                  no - tilt.\n         CH    R4,=Y(JOTJOES-JOT)       before start of joes ?\n         BL    DIRTILT\n         L     R1,QCJQTL                get ckpt record.\n         LH    R1,$NUMJOES-$SAVEBEG(,R1)   numjoes from hct\n         MR    R0,R15                   maximum avl offset..\n         CLR   R4,R1                    what have you ?\n         BH    DIRTILT                  to high an offset.\n         AL    R4,QCJOTA                + jot address is joe.\n         USNGX JOEDSECT,R4              validate some fields.\n         L     R2,=A(CB#DCJOE)          load header+desc addr\n         MVC   QDHLINE,QBLANK           clear the header line\n         MVC   QDHLINE(21),=C'===  Char  J O E  ==='\n*??      CLI   JOETYPE,$JOECHAR         is it char joe ?\n         CLI   JOETYPE,JOECHARJ         is it char joe ?\n         BE    DIRJOEOK                 can't validate much more.\n         MVC   QDHLINE+5(4),=C'Work'    show type of joe\n         L     R2,=A(CB#DWJOE)\n*??      CLI   JOETYPE,$JOEWORK         is it ?\n         CLI   JOETYPE,JOEWORK          is it ?\n         BE    DIRJOEOK                 yes.\n         MVC   QDHLINE+5(4),=C'Free'    show type of joe\n*??      CLI   JOETYPE,$JOEFREE         free joe ?\n         CLI   JOETYPE,JOEFREE          free joe ?\n         BE    DIRJOEOK                 yes.\n         MVC   QDHLINE+5(4),=C'????'    show type of joe\n*                                       ... of w/joe\nDIRJOEOK DS    0H\n         BAL   R3,CB$FMT\n         B     CB$DONE\n*\n*  Subroutine to convert hex offset for direct control block display\n*\nCB$COFF  LH    R1,QLNG1                 get length of parm\n         LTR   R1,R1\n         BZ    DIRTILTO                 offset is required.\n         TR    QPARM1,TBLC2H            translate to binary.\n         EX    R1,CB$PACK1              PACK QNUMWORK(4+1),QPARM1(*-*)\n         L     R4,QNUMWORK              load translated offset.\n*?       LA    R4,0(,R4)                clear highest\n         BR    R14                      return to caller\n*\nDIRTILT  QTILT '*** requested offset is not a valid block ***'\nDIRTILTO QTILT '*** direct jqe/joe must specify an offset ***'\n         DROPX R4\n         EJECT\n***********************************************************************\n*                                                                     *\n*   format the data                                                   *\n*                                                                     *\n***********************************************************************\nCB$FMT   ST    R3,RETURN                save link address\n         MVC   CB@NMLEN,0(R2)           save field name length\n*%       SR    R5,R5                    offset register\n         LH    R5,2(,R2)                get initial offset\n         LA    R2,2+2(,R2)              skip over table prefix\n         B     *+8     >========+       skip around\n*                               |\nFMT000   BAL   R8,CB$DISP1      |       go display this line\n         LA    R3,QDMSG     <===+       a(display line)\n         LH    R6,QDCOLS                load length of line        mod5\n         AR    R6,R3                    a(end of display)          mod5\n         MVC   QDMSG,QBLANK             init the current line\n         ST    R5,QNUMWORK              set down offset\n         HEX   (0,R3),QNUMWORK+2,LEN=2,HEXTAB=QHEXTAB  convert to hex\n         MVI   0(R3),C'+'               indicate relative\n         LA    R3,5(,R3)                next location of display line\n*\nFMT010   CLI   0(R2),X'FF'              ?/all fields formatted\n         BE    CB$DISP                  go display the line\n         LH    R15,CB@NMLEN             get field name length\n         LA    R0,1(R15,R3)             current disp in display line\n         SR    R7,R7                    clear reg for insert\n         IC    R7,0(,R2)                get length of field\n         STH   R7,CB@FLEN               save for later\n         TM    1(R2),X'80'              ?/character field\n         BZ    DOUBLE                   ** no. double the length\n*%%%%%%% SRL   R7,1                     ** yes. cut length in half\n         B     NODOUBLE                 ** don't double\nDOUBLE   AR    R0,R7                    add length to displacement\nNODOUBLE AR    R0,R7                    double it\n         CR    R0,R6                    ?/enough room on display\n         BH    FMT000                   no - go display this line\n         CLI   CB@NMLEN+1,5             short field names?\n         BNH   NARROW                   yes - use narrow col width\n         LA    R1,18(,R3)               default for next offset\n         CH    R7,=H'4'                 ?/field length <= 4\n         BNH   FMT015                   yes. continue\n         LA    R1,18(,R1)               bump for next offset\n         CH    R7,=H'13'                ?/field length <= 13\n         BNH   FMT015                   yes. continue\n         LA    R1,18(,R1)               bump for next offset\n         CH    R7,=H'22'                ?/field length <= 22\n         BNH   FMT015                   yes. continue\n         LA    R1,18(,R1)               bump for next offset\n         CH    R7,=H'32'                ?/field length <= 32\n         BH    CB$FDERR                 no - error\n         B     FMT015                   skip around normal code\nNARROW   LA    R1,15(,R3)               default for next offset\n         CH    R7,=H'4'                 ?/field length <= 4\n         BNH   FMT015                   yes. continue\n         LA    R1,15(,R1)               bump for next offset\n         CH    R7,=H'11'                ?/field length <= 11\n         BNH   FMT015                   yes. continue\n         LA    R1,15(,R1)               bump for next offset\n         CH    R7,=H'19'                ?/field length <= 19\n         BNH   FMT015                   yes. continue\n         LA    R1,15(,R1)               bump for next offset\n         CH    R7,=H'32'                ?/field length <= 32\n         BNH   FMT015                   yes. continue\n*B$FDERR QTILT '** unable to format due to field description error **'\nCB$FDERR BAL   R14,QADDLINE             add any partial line to display\n         MVC   QDMSG(46),=C'** Formatting terminated due to QCBFE error$\n                at'\n         LH    R15,CB@NMLEN             get field name length\n         BCTR  R15,0                    -1 for ex\n         EX    R15,CB$FEMVC             show field name\n         MVC   QDMSG+56(2),=C'**'\n         BAL   R14,QADDLINE\n         B     QSTOP\nCB$FEMVC MVC   QDMSG+47(*-*),2(R2)      << executed >>\nCB$FNMVC MVC   0(*-*,R3),2(R2)          << executed >>\nFMT015   ST    R1,NEXTOSET              save next offset\n*  With the old design of this routine, the following wasn't done for\n*  wide field names.  Since I don't understand what the following\n*  check is for in the first place, we'll do it for wide also.\n*%       CLC   QDCOLS,=H'80'            is this a mod 2 screen\n*%       BE    MVENAME                  yes  move field name\n         CLI   2(R2),C' '               is the field name blank\n         BE    FMT020                   yes  do not move field name\nMVENAME  LH    R15,CB@NMLEN             get field name length\n         BCTR  R15,0                    -1 for ex\n         EX    R15,CB$FNMVC             move field name  0(R3),2(R2)\n         LA    R3,1+1(R15,R3)           update displacement\nFMT020   LH    R15,CB@FLEN              get field length\n         TM    1(R2),X'80'              ?/character field\n         BZ    FMT030                   no. go translate data to ebcdic\n         BCTR  R15,0                    decrement length for execute\n         EX    R15,MVECHAR              move data to display line\n         L     R14,=V(CHARTAB)          -> translate table\n         EX    R15,TRCHAR               insure data is printable\n         LA    R15,1(,R15)              reset length\n         AR    R3,R15                   add length to display line\n         AR    R4,R15                   add length to input data offset\n         AR    R5,R15                   add length to offset\n         B     FMT040                   go prepare for next field\nMVECHAR  MVC   0(*-*,R3),0(R4)          << executed >>\nTRCHAR   TR    0(*-*,R3),0(R14)         << executed >>\nFMT030   UNPK  0(2+1,R3),0(1+1,R4)\n         TR    0(2,R3),QHEXTAB\n         LA    R3,2(,R3)                update displacement\n         LA    R4,1(,R4)                point to next byte of data\n         LA    R5,1(,R5)                relative offset\n         BCT   R7,FMT030                do for length of field\n         MVI   0(R3),C' '               fix flip byte\nFMT040   L     R3,NEXTOSET              get next offset\n         AH    R2,CB@NMLEN              -> next field table ...\n         LA    R2,1+1(,R2)                 ... entry\n         B     FMT010                   process next field\nCB$DISP  BAL   R8,CB$DISP1              go display the last line\n         L     R3,RETURN                restore link address\n         BR    R3                       return to caller\nCB$DISP1 DS    0H\n         CLI   QCODE,8                  ?/checkpoint being dumped\n         BNE   CB$DISP2                 no. keep on trucking\n         L     R1,STARTADR         starting addr of data for this line\n         LR    R15,R4                ending addr of data for this line\n         SR    R15,R1                   length of data\n         BCTR  R15,0                    decrement by 1 for execute.\n*?       EX    R15,MOVE0                move the data to the work area\n*?       EX    R15,TRANSLTE             translate the data\n*?       EX    R15,MOVE1             move the data to the display line\n         EX    R15,CB$MVC1              copy data to the display line\n         L     R14,=V(CHARTAB)          -> translate table\n         EX    R15,CB$TR                translate data to printable\n         MVI   QDMSG+52,C'*'            fill in the rest\n         MVI   QDMSG+73,C'*'            of the data\nCB$DISP2 EQU   *\n         BAL   R14,QADDLINE             add line to screen buffer\n         BR    R8\n*?MOVE0  MVC   PLAY1(0),0(R1)           move data to work area\n*?MOVE1  MVC   QDMSG+53(0),PLAY1        move data to display line\n*?ANSLTE TR    PLAY1(0),TBL1            change the data to special fmt\nCB$MVC1  MVC   QDMSG+53(*-*),0(R1)      << executed >>\nCB$TR    TR    QDMSG+53(*-*),0(R14)     << executed >>\n         EJECT\n***********************************************************************\n*                                                                     *\n*   format the checkpoint data                                        *\n*                                                                     *\n***********************************************************************\nCKPT010  ST    R4,STARTADR              save line data start addr\n         LA    R3,QDMSG                 a(display line)\n         MVC   QDMSG,QBLANK             blank the current line\n         MVI   0(R3),C'+'               indicate relative\n         STH   R5,QNUMWORK              move offset to work area\n         HEX   (1,R3),QNUMWORK,LEN=2\n         LA    R3,6(,R3)                -> next area in display line\n         LA    R7,5                     no. of fields per display line\nCKPT020  HEX   (0,R3),(0,R4),LEN=4\n         LA    R5,4(,R5)                update the offset\n         LA    R3,9(,R3)                update display line location\n         LA    R4,4(,R4)                point at next 4 bytes of data\n         SH    R2,=H'4'                 decrement length by 4\n         BNP   CKPT030                  go display line if no data left\n         BCT   R7,CKPT020               yes, do another field if room\n         BAL   R8,CB$DISP1              no room. display this line\n         B     CKPT010                  go get another line\nCKPT030  BAL   R8,CB$DISP1              go display the line\n         L     R2,=F'4096'              length of ckpt records\n         BCT   R6,CKPT010               go format this buffer\n         B     CB$DONE                  no more buffers. go home\n         EJECT\n***********************************************************************\n*                                                                     *\n*   prepare to read the spool pack                                    *\n*                                                                     *\n***********************************************************************\nREAD     ST    R4,QCTRAK\n         L     R1,QCIOTA\n         QCALL READSPC\n         L     R4,QCIOTA                a(iot)\n         BR    R8\n         SPACE 4\n***********************************************************************\n*                                                                     *\n*   return to the caller                                              *\n*                                                                     *\n***********************************************************************\nCB$DONE  L     R2,DALLREG             restore reg to determine next cb\n         LTR   R2,R2                    ?/is it valid\n         BZ    QSTOP                    no. exit\n         LA    R2,4(,R2)                yes. update the pointer\n         ST    R2,DALLREG               save the pointer\n         QCALL DISPLAY                  display the screen now\n         BR    R2                       go to it\n         EJECT ,\n         LTORG ,\n         SPACE 3\n***********************************************************************\n*                                                                     *\n*   miscellaneous nuts, bolts, etc                                    *\n*                                                                     *\n***********************************************************************\nTBLC2H   DC    256X'F0'\n         ORG   TBLC2H+C'A'\n         DC    X'FAFBFCFDFEFF'\n         ORG   TBLC2H+C'0'\n         DC    X'F0F1F2F3F4F5F6F7F8F9'\n         ORG   ,\nCB$PACK1 PACK  QNUMWORK(4+1),QPARM1(*-*)  << executed >>\n         EJECT ,\n***********************************************************************\n*                                                                     *\n*   format of tables for jqe, joe, iot, pddb, jct, jot, jcb.          *\n*                                                                     *\n*        offset    length         description                         *\n*          0         5              field id tag.                     *\n*          5         1              x... ....  if on indicates the    *\n*                                              field is already in    *\n*                                              ebcdic format.         *\n*                                   ...x xxxx  length of field.       *\n*                                              maximum length is x'1a'*\n*                                                                     *\n***********************************************************************\n         COPY  Q#CB#JQE\n         EJECT\n         COPY  Q#CB#JOE\n         EJECT\n         COPY  Q#CB#JCT\n         EJECT\n          AIF   (&@@ACF2 EQ 0).NOACF2\n         COPY  Q#CB#ACF\n.NOACF2   ANOP\n         EJECT\n         COPY  Q#CB#IOT\n         EJECT\n         COPY  Q#CB#PDB\n         EJECT\n         COPY  Q#CB#JOT\n         EJECT\n***********************************************************************\n*                                                                     *\n*   format of table for hct variables.                                *\n*                                                                     *\n*        offset    length         description                         *\n*          0         8              field id tag.                     *\n*          8         1              x... ....  if on indicates the    *\n*                                              field is already in    *\n*                                              ebcdic format.         *\n*                                   ...x xxxx  length of field.       *\n*                                              maximum length is x'1e'*\n*                                                                     *\n***********************************************************************\n         COPY  Q#CB#HCT\n         EJECT\n         QCOMMON\nWORK     DSECT\n         ORG   WORK+72                  skip over save area\nDALLREG  DS    F\nCB@NMLEN DS    H                        field name length for this C.B.\nCB@FLEN  DS    H                        field length\nCB@SW    DS    C\nCB@WDJCT DS    CL(CB#JCTDL)             working copy of CB#D#JCT\nPDDBKEY  DS    H\nJOEADDR  DS    F\nIOTADDR  DS    F\nPDDBADDR DS    F\nLASTPDDB DS    F\nRETURN   DS    F\nNEXTOSET DS    F\nSTARTADR DS    F\nCB@WORKL EQU   *-WORK                   length of protected work area\n         Q$HCT\n         Q$JOT\n         Q$JQE\n         Q$JOE\n         Q$JCT\n         Q$IOT\n         Q$PDDB\n         Q$NHD\n         QZACFNJB\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "Q#CB#ACF": {"ttr": 3841, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x904/\\x00\\x904/\\x022\\x004\\x00&\\x00\\x00\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-12-08T00:00:00", "modifydate": "1990-12-08T02:32:00", "lines": 52, "newlines": 38, "modlines": 0, "user": "LDW"}, "text": "*        COPY  Q#CB#ACF\n***********************************************************************\n*\n*   Description of acf2 network job header in JCT -- copied into Q#CB\n*\n***********************************************************************\nCB#D#ACF QCBFE ,,,L=5\n*---  Fields from ACFNJBLK\n         QCBFE 'NJSEC',CHAR,4\n         QCBFE 'NJCPU',CHAR,4\n         QCBFE 'NJNXT',HEX,4\n         QCBFE 'NJCTA',HEX,4\n         QCBFE 'NJPCE',HEX,4\n         QCBFE 'NXECB',HEX,16\n         QCBFE 'NRSV1',HEX,4\n         QCBFE 'NRSV2',HEX,4\n         QCBFE 'NJFL5',HEX,1\n         QCBFE 'rsrvd',HEX,3\n         QCBFE 'NJU01',HEX,4\n         QCBFE 'NJU02',HEX,4\n         QCBFE 'NJU03',HEX,4\n         QCBFE 'NJU04',HEX,4\n         QCBFE 'NJU05',HEX,4\n         QCBFE 'NJFL1',HEX,1\n         QCBFE 'NJFL2',HEX,1\n         QCBFE 'NJFL3',HEX,1\n         QCBFE 'NJFL4',HEX,1\n*---  Following from ACVALD\n         QCBFE 'FCN  ',HEX,1\n         QCBFE 'SFCN ',HEX,1\n         QCBFE 'CNTL ',HEX,1\n         QCBFE 'RFLG ',HEX,1\n         QCBFE 'UCB  ',HEX,4\n         QCBFE 'MSG  ',HEX,4\n         QCBFE 'LID  ',CHAR,8\n         QCBFE 'PSWD ',CHAR,8\n         QCBFE 'NPSWD',CHAR,8\n         QCBFE 'SRCE ',CHAR,8\n         QCBFE 'JOBV ',CHAR,8\n         QCBFE 'SLID ',CHAR,8\n         QCBFE 'PATH ',CHAR,8\n         QCBFE 'APROG',CHAR,8\n         QCBFE 'RECB ',HEX,4\n         QCBFE 'RECL ',HEX,4\n         QCBFE 'UIDB ',HEX,4\n         QCBFE 'UIDL ',HEX,4\n         QCBFE 'QNAME',HEX,4\n         QCBFE 'CPUID',HEX,4\n         QCBFE 'AUTH ',HEX,4\n         QCBFE 'ACNTL',HEX,1\n         QCBFE 'ANFLG',HEX,1\n         DC    X'FF'\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "Q#CB#HCT": {"ttr": 3843, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x904/\\x00\\x91\\x17\\x8f\\x18\\x16\\x00o\\x00a\\x00\\n\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1990-12-08T00:00:00", "modifydate": "1991-06-27T18:16:00", "lines": 111, "newlines": 97, "modlines": 10, "user": "LDW"}, "text": "*        COPY  Q#CB#HCT\n***********************************************************************\n*                                                                     *\n*   Description of HCT variables -- copied into Q#CB                  *\n*                                                                     *\n***********************************************************************\nCB#D#HCT QCBFE ,,,L=8,OFFSET=0000,MIN=3,MAX=3    X'???'  pre-SP\nCB#D#HCT QCBFE ,,,L=8,OFFSET=0000,MIN=4,MAX=4    X'???'  1.3.0\nCB#D#HCT QCBFE ,,,L=8,OFFSET=0000,MIN=5,MAX=5    X'???'  1.3.3\nCB#D#HCT QCBFE ,,,L=8,OFFSET=0000,MIN=6,MAX=6    X'???'  1.3.4\nCB#D#HCT QCBFE ,,,L=8,OFFSET=0000,MIN=7,MAX=7    X'???'  1.3.6 / 2.1.5\nCB#D#HCT QCBFE ,,,L=8,OFFSET=0000,MIN=8,MAX=8    X'???'  2.2.0\nCB#D#HCT QCBFE ,,,L=8,OFFSET=3128,MIN=9,MAX=9    X'C38'  3.1.1\nCB#D#HCT QCBFE ,,,L=8,OFFSET=3168,MIN=10,MAX=10  X'C60'  3.1.3\nCB#D#HCT QCBFE ,,,L=8,OFFSET=3112,MIN=11,MAX=11  X'C28'  4.1.0\nCB#D#HCT QCBFE ,,,L=8,OFFSET=3152,MIN=12,MAX=12  X'C50'  4.2.0\n         QCBFE '$MSTRID ',CHAR,4,MIN=8\n         QCBFE '$MASTERL',HEX,4,MIN=4\n         QCBFE '$MSTRVER',HEX,1,MIN=8\n         QCBFE 'reserved',HEX,3,MIN=8\n         QCBFE '$CHLOGLN',HEX,4,MIN=8\n         QCBFE '$CKRECN ',HEX,2,MIN=4\n         QCBFE '$WCHECK ',HEX,1,MIN=4\n         QCBFE '$CKPTFLG',HEX,1,MIN=4\n         QCBFE '$CKPUSER',HEX,8,MIN=4\n         QCBFE '$NEWSJQE',HEX,4,MIN=5\n         QCBFE '$NEWSTTR',HEX,4,MAX=9\n         QCBFE '$NEWSIOT',HEX,4,MIN=10\n         QCBFE '$NEWSCLV',HEX,2,MIN=10\n         QCBFE '$NEWSLVL',HEX,2,MIN=10\n         QCBFE 'reserved',HEX,2,MIN=10\n         QCBFE '$JQEFREC',HEX,2,MIN=4\n         QCBFE 'slop!   ',HEX,2,MIN=4,MAX=9\n         QCBFE '$JQFREE ',HEX,4,MIN=4\n*  for MIN=4, $jqheads is 47AL4.  for MAX=3, $jqheads is ??AL2\n         QCBFE '$JQHEADS',HEX,30\n         QCBFE '        ',HEX,30\n         QCBFE '        ',HEX,30\n         QCBFE '        ',HEX,30\n         QCBFE '        ',HEX,30\n         QCBFE '        ',HEX,30\n         QCBFE '        ',HEX,8\n         QCBFE '$JQELEN ',HEX,2,MIN=7\n         QCBFE '$JQEMSKL',HEX,2,MIN=7\n         QCBFE '$JQEEXFR',HEX,2,MIN=7\n         QCBFE '$MAXEXSZ',HEX,2,MIN=7\n         QCBFE 'reserved',HEX,20,MIN=9\n         QCBFE '$JQHDCPY',HEX,4,MIN=9\n         QCBFE '$SCQJQE ',HEX,4,MIN=5\n*%       QCBFE '$SCQSPLS',HEX,28,MAX=??\n*%       QCBFE '$RESV2  ',HEX,30,MAX=??\n*%       QCBFE '        ',HEX,6,MAX=??\n         QCBFE '$SPLEXST',HEX,4,MAX=6\n         QCBFE '$SPLEXST',HEX,32,MIN=7\n         QCBFE '$SPLSLCT',HEX,4,MAX=6\n         QCBFE '$SPLSLCT',HEX,32,MIN=7\n         QCBFE '$SPLINAC',HEX,4,MAX=6\n         QCBFE '$SPLINAC',HEX,32,MIN=7\n         QCBFE '$TGALLOC',HEX,4,MIN=5\n         QCBFE '$TGTOTAL',HEX,4,MIN=9\n         QCBFE '$TGDEFND',HEX,4,MIN=7\n         QCBFE '$TGFREE ',HEX,4,MIN=7\n         QCBFE '$QSEMAX ',HEX,2,MIN=7\n         QCBFE '$QSENDEF',HEX,2,MIN=7\n         QCBFE '$KBYTS  ',HEX,4,MIN=5\n         QCBFE '$DASWRKQ',HEX,4,MIN=5\n         QCBFE '$DASTRKQ',HEX,4,MIN=5\n         QCBFE '$DATAKEY',HEX,4\n*%       QCBFE '$JOBNO  ',HEX,2,max=??\n*%       QCBFE '$JOBMIN ',HEX,2,max=??\n*%       QCBFE '$JOBMAX ',HEX,2,max=??\n         QCBFE '$HASPID ',CHAR,4\n*%       QCBFE '$CHKPT  ',CHAR,6,max=??\n*%       QCBFE '$CHKPT2 ',CHAR,6,max=??\n         QCBFE '$NDENAME',CHAR,8,MIN=10\n         QCBFE '$FLAG1  ',HEX,1,MIN=5\n         QCBFE '$FLAG2  ',HEX,1,MIN=9\n*%       QCBFE '$RESV3  ',HEX,5,max=??\n         QCBFE 'reserved',HEX,2,MIN=9\n         QCBFE '$OPSPJNO',HEX,4,MIN=9\n         QCBFE '$CLRECN ',HEX,2,MIN=8\n         QCBFE '-       ',CHAR,5,MIN=7  'JES2 '\n         QCBFE '$COLDVSN',CHAR,8,MIN=7\n         QCBFE '-       ',CHAR,11,MIN=7 ' COLDSTART '\n         QCBFE '$COLDSID',CHAR,5,MIN=7\n         QCBFE 'reserved',HEX,3,MIN=7\n         QCBFE 'slop!   ',HEX,2,MIN=7\n         QCBFE '$COLDDTM',HEX,8,MIN=7\n         QCBFE '$NUMNODE',HEX,2,MIN=5\n*%       QCBFE '$NUMRJE ',HEX,2,max=??\n         QCBFE '$SPOOL  ',CHAR,6,MAX=4\n         QCBFE '$SPOOL  ',CHAR,5,MIN=5\n         QCBFE '$SPLLEN ',HEX,1,MIN=7\n         QCBFE '$SPOLNUM',HEX,2,MIN=7\n         QCBFE '$BUFSIZE',HEX,2,MIN=7\n         QCBFE '$MAXJOBS',HEX,2,MIN=4\n*%       QCBFE '$NUMJBNO',HEX,2,max=??\n         QCBFE 'slop!   ',HEX,2,MIN=9\n         QCBFE '$NUMJOES',HEX,2,MAX=8   ??\n         QCBFE '$NUMJOES',HEX,4,MIN=9\n*%       QCBFE '$NUMTG  ',HEX,2,max=??\n*%       QCBFE '$TGSIZE ',HEX,2,max=??\n*%       QCBFE '$QSENO  ',HEX,2,max=??\n         QCBFE '$NODEID ',HEX,2,MIN=4\n         QCBFE '$RECINCR',HEX,1,MIN=9\n         QCBFE '$TCELSIZ',HEX,1\n         QCBFE '$NUMTG  ',HEX,4,MIN=7\n         QCBFE 'reserved',HEX,2,MIN=9\n         QCBFE 'slop!   ',HEX,2,MIN=9\n         QCBFE 'reserved',HEX,8,MIN=5\n         DC    X'FF'\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "Q#CB#IOT": {"ttr": 3846, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x904/\\x00\\x904/\\x004\\x00&\\x00\\x15\\x00\\x00\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-12-08T00:00:00", "modifydate": "1990-12-08T00:34:00", "lines": 38, "newlines": 21, "modlines": 0, "user": "LDW"}, "text": "*        COPY  Q#CB#IOT\n***********************************************************************\n*                                                                     *\n*   Description of IOT fields -- copied into Q#CB                     *\n*                                                                     *\n***********************************************************************\nCB#D#IOT QCBFE ,,,L=5\n         QCBFE 'ID   ',CHAR,4\n         QCBFE 'LENG ',HEX,2\n         QCBFE 'FLAG1',HEX,1\n         QCBFE 'FLAG2',HEX,1\n         QCBFE 'JBKEY',HEX,4,MAX=6\n         QCBFE 'TRACK',HEX,4\n         QCBFE 'IOTTR',HEX,4\n         QCBFE 'JCT  ',HEX,4\n         QCBFE 'IOT  ',HEX,4\n         QCBFE 'TGATR',HEX,4,MIN=7\n         QCBFE 'TGADR',HEX,4,MIN=7\n         QCBFE 'TQOFF',HEX,4,MIN=7\n         QCBFE 'JBNMB',HEX,2,MIN=7\n         QCBFE 'rsrvd',HEX,2,MIN=7\n         QCBFE 'JBNME',CHAR,8,MIN=7\n         QCBFE 'SJB  ',HEX,4\n         QCBFE 'PDDBP',HEX,4\n         QCBFE 'PDDB ',HEX,4\n         QCBFE 'JBKEY',HEX,4,MIN=7\n         QCBFE 'CKRC ',HEX,4,MIN=7\n         QCBFE 'rsrvd',HEX,4,MIN=7\n         QCBFE 'rsrvd',HEX,8,MIN=7\n***???   QCBFE 'MSTAB',HEX,26\n         QCBFE 'MSTAB',HEX,12,MIN=4     length is TABLNGTH (see $TAB)\n         QCBFE 'slop ',HEX,4,MIN=7\n         QCBFE 'CYMXM',HEX,4,MIN=7\n         QCBFE 'CELL ',HEX,4,MIN=7\n         QCBFE 'SPMSK',HEX,32,MIN=7     is length ok for all releases?\n         QCBFE 'SAMSK',HEX,32,MIN=7     is length ok for all releases?\n         QCBFE 'rsrvd',HEX,16,MIN=7\n         DC    X'FF'\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "Q#CB#JCT": {"ttr": 3848, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x904/\\x00\\x904/\\x01(\\x00\\xda\\x00\\xcc\\x00\\x00\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-12-08T00:00:00", "modifydate": "1990-12-08T01:28:00", "lines": 218, "newlines": 204, "modlines": 0, "user": "LDW"}, "text": "*        COPY  Q#CB#JCT\n***********************************************************************\n*                                                                     *\n*   DESCRIPTION OF JCT FIELDS                                         *\n*                                                                     *\n***********************************************************************\n*---  Offset is BUFSTART-BUFDSECT.  There's no way to get the right\n*---  number here automatically, so the offset is release sensitive.\nCB#D#JCT QCBFE ,,,L=5,OFFSET=104        X'68'\n         QCBFE 'ID   ',CHAR,4\n         QCBFE 'LENG ',HEX,2\n         QCBFE 'FLAG1',HEX,1\n         QCBFE 'JTFLG',HEX,1,MIN=7\n         QCBFE 'JBKEY',HEX,4\n         QCBFE 'JDVT ',CHAR,8,MIN=5\n         QCBFE 'TRAK ',HEX,4,MIN=7\n         QCBFE 'SPIOT',HEX,4,MIN=7\n         QCBFE 'IOT  ',HEX,4\n         QCBFE 'OCTTR',HEX,4\n         QCBFE 'XTRK ',HEX,4,MIN=4\n         QCBFE 'XBUFO',HEX,4,MIN=4\n         QCBFE 'JQE  ',HEX,4,MAX=8      ???\n         QCBFE 'SAMSK',HEX,16,MIN=7\n         QCBFE '     ',HEX,16,MIN=7\n         QCBFE 'PDDBK',HEX,2,MAX=8\n         QCBFE 'PDDBK',HEX,4,MIN=9\n         QCBFE 'PDDBO',HEX,2,MAX=8\n         QCBFE 'PDDBO',HEX,4,MIN=9\n         QCBFE 'CNVRC',HEX,4,MIN=4\n         QCBFE 'USER0',HEX,4,MIN=4\n*        AIF   (NOT &QBIU).CBNBIU2\n*        QCBFE 'UFLG1',HEX,1           MAPPING OF USER1-USER3\n*        QCBFE 'UTAPE',HEX,1\n*        QCBFE 'URSV ',HEX,2\n*        QCBFE 'UDX  ',HEX,2\n*        QCBFE 'UTX  ',HEX,2\n*        QCBFE 'UDBX ',HEX,2\n*        QCBFE 'URSV ',HEX,2\n*        AGO   .CBBIU1\n.CBNBIU2  ANOP\n         QCBFE 'USER1',HEX,4,MIN=4\n         QCBFE 'USER2',HEX,4,MIN=4\n         QCBFE 'USER3',HEX,4,MIN=4\n.CBBIU1   ANOP\n         QCBFE 'USER4',HEX,4,MIN=4\n         QCBFE 'USER5',HEX,4,MIN=4\n         QCBFE 'USER6',HEX,4,MIN=4\n         QCBFE 'USER7',HEX,4,MIN=4\n         QCBFE 'USER8',HEX,4,MIN=4\n         QCBFE 'USER9',HEX,4,MIN=4\n         QCBFE 'USERA',HEX,4,MIN=4\n         QCBFE 'USERB',HEX,4,MIN=4\n         QCBFE 'USERC',HEX,4,MIN=4\n         QCBFE 'USERD',HEX,4,MIN=4\n         QCBFE 'USERE',HEX,4,MIN=4\n         QCBFE 'USERF',HEX,4,MIN=4\nPRTY     QCBFE 'PRTY ',CHAR,2\n         QCBFE 'JSSTP',HEX,2\n         QCBFE 'FLAG2',HEX,1,MIN=7\n         QCBFE 'HDSCT',HEX,2,MAX=8      ?????\n         QCBFE 'NEXTQ',HEX,1\n         QCBFE 'JSFLG',HEX,1\n         QCBFE 'SMFLG',HEX,1\n         QCBFE 'JOBFL',HEX,1\n         QCBFE 'JBOPT',HEX,1\n         QCBFE 'slop!',HEX,2\n         QCBFE 'rsrvd',HEX,2,MAX=8\n         QCBFE 'JOBID',CHAR,8\n         QCBFE 'JNAME',CHAR,8\n         QCBFE 'PNAME',CHAR,20\n         QCBFE 'MCLAS',CHAR,1\n         QCBFE 'JCLAS',CHAR,1\n         QCBFE 'IPRIO',HEX,1\n         QCBFE 'PRIO ',HEX,1\n         QCBFE 'IOPRI',HEX,1\n         QCBFE 'OPRIO',HEX,1\n         QCBFE 'rsrvd',HEX,2,MAX=8\n         QCBFE 'rsrvd',HEX,1,MIN=9\n         QCBFE 'OFFSL',HEX,1,MIN=9\n         QCBFE 'RNODE',HEX,2,MAX=3\n         QCBFE 'RNODE',HEX,2,MIN=4\n         QCBFE 'RRMT ',HEX,2,MAX=3\n         QCBFE 'RRMT ',HEX,2,MIN=4\n         QCBFE 'INDEV',CHAR,8\n         QCBFE 'ACCTN',CHAR,4\n         QCBFE 'ROOMN',CHAR,4\n         QCBFE 'ETIME',HEX,4\n         QCBFE 'ESTLN',HEX,4\n         QCBFE 'ESTPU',HEX,4\n         QCBFE 'FORMS',CHAR,8\n         QCBFE 'rsrvd',HEX,1\n         QCBFE 'CPYCT',HEX,1\n         QCBFE 'rsrvd',HEX,1\n         QCBFE 'LINCT',HEX,1\n         QCBFE 'ESTPG',HEX,4\n         QCBFE 'ESTBY',HEX,4\n         QCBFE 'PRNOD',HEX,2\n         QCBFE 'PRRMT',HEX,2\n         QCBFE 'PUNOD',HEX,2\n         QCBFE 'PURMT',HEX,2\n         QCBFE 'PROCN',CHAR,8\n         QCBFE 'PASS ',CHAR,8\n         QCBFE 'NUPAS',CHAR,8\n         QCBFE 'GRPID',CHAR,8,MIN=10\n         QCBFE 'NOTUS',CHAR,8,MIN=10\n         QCBFE 'TSUAF',HEX,1,MIN=10\n         QCBFE 'UIDL ',HEX,1,MIN=10\n         QCBFE 'JUSID',CHAR,8,MIN=10\n         QCBFE 'ENCKY',CHAR,8,MIN=10\n         QCBFE 'rsrvd',HEX,2,MIN=10\n         QCBFE 'TOKEN',HEX,32,MIN=10    length is from $HASPGBL.$TKNLEN\n         QCBFE '     ',HEX,32,MIN=10    length is from $HASPGBL.$TKNLEN\n         QCBFE '     ',HEX,16,MIN=10    length is from $HASPGBL.$TKNLEN\n         QCBFE 'CNVON',HEX,4\n         QCBFE 'CDTON',HEX,4\n         QCBFE 'CNVOF',HEX,4\n         QCBFE 'CDTOF',HEX,4\n         QCBFE 'XEQON',HEX,4\n         QCBFE 'XDTON',HEX,4\n         QCBFE 'XEQOF',HEX,4\n         QCBFE 'XDTOF',HEX,4\n         QCBFE 'OUTON',HEX,4\n         QCBFE 'ODTON',HEX,4\n         QCBFE 'OUTOF',HEX,4\n         QCBFE 'ODTOF',HEX,4\n         QCBFE 'CARDS',HEX,4\n         QCBFE 'LINES',HEX,4\n         QCBFE 'PUNCH',HEX,4\n         QCBFE 'RDSID',CHAR,4\n         QCBFE 'CVSID',CHAR,4\n         QCBFE 'EXSID',CHAR,4\n         QCBFE 'OTSID',CHAR,4\n         QCBFE 'PAGES',HEX,4\n         QCBFE 'BYTES',HEX,4\n         QCBFE 'SPUNB',HEX,4,MIN=9\n         QCBFE 'XEQND',HEX,2\n         QCBFE 'XNODE',HEX,2\n         QCBFE 'NJSID',CHAR,4\n         QCBFE 'NJTON',HEX,4\n         QCBFE 'NDTON',HEX,4\n         QCBFE 'NJTOF',HEX,4\n         QCBFE 'NDTOF',HEX,4\n         QCBFE 'NACCT',CHAR,8\n         QCBFE 'NOJID',CHAR,8\n         QCBFE 'NNDEV',CHAR,8\n         QCBFE 'NONDE',CHAR,8\n         QCBFE 'NXNDE',CHAR,8\n         QCBFE 'NNNDE',CHAR,8\n         QCBFE 'NLNDE',CHAR,8\n         QCBFE 'ESOUT',HEX,4\n         QCBFE 'XOUT ',HEX,4\n         QCBFE 'TSUID',CHAR,7,MAX=9\n         QCBFE 'TSUAF',HEX,1,MAX=9\n         QCBFE 'PSN1 ',HEX,8\n         QCBFE 'PSN2 ',HEX,8\n*        QCBFE 'WORK ',HEX,26\n*        QCBFE '     ',HEX,26\n*        QCBFE '     ',HEX,26\n*        QCBFE '     ',HEX,26\n*        QCBFE '     ',HEX,26\n*        QCBFE '     ',HEX,14\n         QCBFE 'WORK ',HEX,32\n         QCBFE '     ',HEX,32\n         QCBFE '     ',HEX,32\n         QCBFE '     ',HEX,32\n         QCBFE '     ',HEX,16\n*        QCBFE 'XWRK ',HEX,26\n*        QCBFE '     ',HEX,26\n*        QCBFE '     ',HEX,26\n*        QCBFE '     ',HEX,2\n         QCBFE 'XWRK ',HEX,32\n         QCBFE '     ',HEX,32\n         QCBFE '     ',HEX,16\n         QCBFE 'JMRJN',CHAR,8\n         QCBFE 'RDRON',HEX,4\n         QCBFE 'RDTON',HEX,4\n         QCBFE 'CPUID',HEX,4\n         QCBFE 'USEID',CHAR,8\n         QCBFE 'STEP ',HEX,1\n         QCBFE 'INDC ',HEX,1\n         QCBFE 'JTCC ',HEX,1\n         QCBFE 'CLASS',HEX,1\n         QCBFE 'UCOM ',HEX,4\n         QCBFE 'UJVP ',HEX,4\n         QCBFE 'RDROF',HEX,4\n         QCBFE 'RDTOF',HEX,4\n         QCBFE 'JOBIN',HEX,4\n         QCBFE 'RDR  ',HEX,2\n         QCBFE 'JMOPT',HEX,1\n         QCBFE 'rsrvd',HEX,1\n         QCBFE 'XMASK',HEX,26\n         QCBFE '     ',HEX,6\n         QCBFE 'JQE  ',HEX,4,MIN=7\n         QCBFE 'NNODE',CHAR,8,MIN=9     OY17284\n         QCBFE 'rsrvd',HEX,8,MIN=9,MAX=10  OY17284\n         QCBFE 'CHNDX',HEX,2,MIN=10\n         QCBFE 'CHDRT',HEX,10,MIN=10\n         QCBFE 'rsrvd',HEX,16,MIN=7,MAX=8\n         QCBFE 'rsrvd',HEX,16,MIN=10\n          AIF   ('&@@ID' NE 'USC-UCS').NOUSC2\n          AIF   (&QLEVEL GT 9).NOUSC2\n         QCBFE 'USC01',HEX,26\n         QCBFE '     ',HEX,26\n         QCBFE '     ',HEX,26\n         QCBFE '     ',HEX,22\n         QCBFE 'PROC ',CHAR,26\n         QCBFE '     ',CHAR,18\n         QCBFE 'PROCV',CHAR,6\n         QCBFE 'USC02',CHAR,26\n         QCBFE '     ',CHAR,26\n         QCBFE '     ',CHAR,26\n         QCBFE '     ',CHAR,26\n         QCBFE '     ',CHAR,26\n         QCBFE '     ',CHAR,20\n.NOUSC2   ANOP\n         DC    X'FF'\nCB#JCTDL EQU   *-CB#D#JCT\nPRTYTYP  EQU   (PRTY-CB#D#JCT)+1\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "Q#CB#JOE": {"ttr": 3853, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x904/\\x00\\x91\\x17\\x9f\\x00G\\x00N\\x00F\\x00\\t\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1990-12-08T00:00:00", "modifydate": "1991-06-28T00:47:00", "lines": 78, "newlines": 70, "modlines": 9, "user": "LDW"}, "text": "*        COPY  Q#CB#JOE\n***********************************************************************\n*                                                                     *\n*   DESCRIPTION OF WORK JOE FIELDS                                    *\n*                                                                     *\n***********************************************************************\nCB#DWJOE QCBFE ,,,L=5\n         QCBFE 'TYPE ',HEX,1\n         QCBFE 'NEXTB',HEX,3\n         QCBFE 'CURCL',HEX,1\n         QCBFE 'PREVB',HEX,3\n         QCBFE 'FLAG1',HEX,1\n         QCBFE 'JQEB ',HEX,3\n         QCBFE 'FLAG2',HEX,1\n         QCBFE 'JQNXB',HEX,3\n         QCBFE 'SEC  ',HEX,1,MAX=6\n         QCBFE 'FLAG3',HEX,1,MIN=7\n         QCBFE 'CHARB',HEX,3\n         QCBFE 'CPU  ',HEX,1,MAX=6\n         QCBFE 'OFFSL',HEX,1,MIN=7\n         QCBFE 'CHNXB',HEX,3\n         QCBFE 'FLAG4',HEX,1,MIN=11\n         QCBFE 'rsrvd',HEX,1,MIN=11\n         QCBFE 'HOLD ',HEX,1,MIN=11\n         QCBFE 'HSRSN',HEX,1,MIN=11\n         QCBFE 'FSID ',HEX,4\n         QCBFE 'PRIO ',HEX,2\n         QCBFE 'JNEWS',HEX,2\n         QCBFE 'CPADR',HEX,4\n         QCBFE 'RECCT',HEX,4\n         QCBFE 'PGCT ',HEX,4\n         QCBFE 'WRECN',HEX,4\n         QCBFE 'WPAGN',HEX,4\n         QCBFE 'IOTTR',HEX,4\n         QCBFE 'DEVID',HEX,3\n         QCBFE 'FLAGT',HEX,1\n         QCBFE 'FLGT2',HEX,1,MIN=11\n         QCBFE 'RNODE',HEX,2\n         QCBFE 'REMOT',HEX,2\n         QCBFE 'PDBND',HEX,2,MAX=10\n         QCBFE 'PDBRT',HEX,2,MAX=10\n         QCBFE 'NAME ',CHAR,4,MAX=6\n         QCBFE 'NAME ',CHAR,8,MIN=7\n         QCBFE 'ID1  ',HEX,2\n         QCBFE 'ID2  ',HEX,2\n         QCBFE 'CRTME',HEX,4,MIN=7\n         QCBFE 'CRUID',CHAR,8,MIN=10\n         QCBFE 'rsrvd',HEX,4,MIN=7\n*%       QCBFE 'FLAG3',HEX,1,MAX=??\n*%       QCBFE 'RESV ',HEX,3,MAX=??\n         DC    X'FF'\n         EJECT\n***********************************************************************\n*                                                                     *\n*   DESCRIPTION OF CHARACTERISTIC JOE FIELDS                          *\n*                                                                     *\n***********************************************************************\nCB#DCJOE QCBFE ,,,L=5\n         QCBFE 'TYPE ',HEX,1\n         QCBFE 'NEXTC',HEX,3\n         QCBFE 'rsrvd',HEX,1\n         QCBFE 'PREVC',HEX,3\n         QCBFE 'rsrvd',HEX,1\n         QCBFE 'WKPTB',HEX,3\n         QCBFE 'FORM ',CHAR,8\n         QCBFE 'FCB  ',CHAR,4\n         QCBFE 'UCS  ',CHAR,4\n         QCBFE 'WTRID',CHAR,8\n         QCBFE 'USER ',CHAR,8,MIN=11\n         QCBFE 'FLASH',CHAR,4\n         QCBFE 'PRMD ',CHAR,8\n         QCBFE 'SECLB',CHAR,8,MIN=10\n         QCBFE 'FLAGC',HEX,1\n         QCBFE 'FLAGD',HEX,1\n         QCBFE 'rsrvd',HEX,2,MIN=9\n         QCBFE 'USE  ',HEX,2,MAX=8\n         QCBFE 'USE  ',HEX,4,MIN=9\n         DC    X'FF'\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "Q#CB#JOT": {"ttr": 3856, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x904/\\x00\\x904/\\x00!\\x00Y\\x00Y\\x00\\x00\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-12-08T00:00:00", "modifydate": "1990-12-08T00:21:00", "lines": 89, "newlines": 89, "modlines": 0, "user": "LDW"}, "text": "*        COPY  Q#CB#JOT\n***********************************************************************\n*                                                                     *\n*   DESCRIPTION OF JOT FIELDS                                         *\n*                                                                     *\n***********************************************************************\nCB#D#JOT QCBFE ,,,L=5\n         QCBFE 'ID   ',CHAR,4\n         QCBFE 'FREC ',HEX,2,MAX=8      %%\n         QCBFE 'FREC ',HEX,4,MIN=9      %%\n         QCBFE 'rsrvd',HEX,2,MAX=8      %%\n         QCBFE 'rsrvd',HEX,4,MIN=9      %%\n         QCBFE 'FREQ ',HEX,4\n         QCBFE 'CHRQ ',HEX,4\n         QCBFE 'DUMPQ',HEX,4,MAX=7\n         QCBFE 'NTWKQ',HEX,4\n         QCBFE 'LCL-A',HEX,4\n         QCBFE 'RMT-A',HEX,4\n         QCBFE 'LCL-B',HEX,4\n         QCBFE 'RMT-B',HEX,4\n         QCBFE 'LCL-C',HEX,4\n         QCBFE 'RMT-C',HEX,4\n         QCBFE 'LCL-D',HEX,4\n         QCBFE 'RMT-D',HEX,4\n         QCBFE 'LCL-E',HEX,4\n         QCBFE 'RMT-E',HEX,4\n         QCBFE 'LCL-F',HEX,4\n         QCBFE 'RMT-F',HEX,4\n         QCBFE 'LCL-G',HEX,4\n         QCBFE 'RMT-G',HEX,4\n         QCBFE 'LCL-H',HEX,4\n         QCBFE 'RMT-H',HEX,4\n         QCBFE 'LCL-I',HEX,4\n         QCBFE 'RMT-I',HEX,4\n         QCBFE 'LCL-J',HEX,4\n         QCBFE 'RMT-J',HEX,4\n         QCBFE 'LCL-K',HEX,4\n         QCBFE 'RMT-K',HEX,4\n         QCBFE 'LCL-L',HEX,4\n         QCBFE 'RMT-L',HEX,4\n         QCBFE 'LCL-M',HEX,4\n         QCBFE 'RMT-M',HEX,4\n         QCBFE 'LCL-N',HEX,4\n         QCBFE 'RMT-N',HEX,4\n         QCBFE 'LCL-O',HEX,4\n         QCBFE 'RMT-O',HEX,4\n         QCBFE 'LCL-P',HEX,4\n         QCBFE 'RMT-P',HEX,4\n         QCBFE 'LCL-Q',HEX,4\n         QCBFE 'RMT-Q',HEX,4\n         QCBFE 'LCL-R',HEX,4\n         QCBFE 'RMT-R',HEX,4\n         QCBFE 'LCL-S',HEX,4\n         QCBFE 'RMT-S',HEX,4\n         QCBFE 'LCL-T',HEX,4\n         QCBFE 'RMT-T',HEX,4\n         QCBFE 'LCL-U',HEX,4\n         QCBFE 'RMT-U',HEX,4\n         QCBFE 'LCL-V',HEX,4\n         QCBFE 'RMT-V',HEX,4\n         QCBFE 'LCL-W',HEX,4\n         QCBFE 'RMT-W',HEX,4\n         QCBFE 'LCL-X',HEX,4\n         QCBFE 'RMT-X',HEX,4\n         QCBFE 'LCL-Y',HEX,4\n         QCBFE 'RMT-Y',HEX,4\n         QCBFE 'LCL-Z',HEX,4\n         QCBFE 'RMT-Z',HEX,4\n         QCBFE 'LCL-0',HEX,4\n         QCBFE 'RMT-0',HEX,4\n         QCBFE 'LCL-1',HEX,4\n         QCBFE 'RMT-1',HEX,4\n         QCBFE 'LCL-2',HEX,4\n         QCBFE 'RMT-2',HEX,4\n         QCBFE 'LCL-3',HEX,4\n         QCBFE 'RMT-3',HEX,4\n         QCBFE 'LCL-4',HEX,4\n         QCBFE 'RMT-4',HEX,4\n         QCBFE 'LCL-5',HEX,4\n         QCBFE 'RMT-5',HEX,4\n         QCBFE 'LCL-6',HEX,4\n         QCBFE 'RMT-6',HEX,4\n         QCBFE 'LCL-7',HEX,4\n         QCBFE 'RMT-7',HEX,4\n         QCBFE 'LCL-8',HEX,4\n         QCBFE 'RMT-8',HEX,4\n         QCBFE 'LCL-9',HEX,4\n         QCBFE 'RMT-9',HEX,4\n         DC    X'FF'\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "Q#CB#JQE": {"ttr": 4099, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x904/\\x00\\x904/\\x018\\x009\\x007\\x00\\x00\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-12-08T00:00:00", "modifydate": "1990-12-08T01:38:00", "lines": 57, "newlines": 55, "modlines": 0, "user": "LDW"}, "text": "*        COPY  Q#CB#JQE\n***********************************************************************\n*                                                                     *\n*   description of jqe fields                                         *\n*                                                                     *\n***********************************************************************\nCB#D#JQE QCBFE ,,,L=5\n         QCBFE 'PRIO ',HEX,1\n         QCBFE 'TYPE ',HEX,1\n         QCBFE 'JOBNO',HEX,2\n         QCBFE 'FLAG1',HEX,1\n         QCBFE 'NEXTB',HEX,3,MIN=4\n         QCBFE 'FLAG2',HEX,1\n         QCBFE 'JOEB ',HEX,3,MIN=4\n         QCBFE 'FLAG3',HEX,1,MIN=4\n         QCBFE 'JCLAS',CHAR,1,MIN=4\n         QCBFE 'INJNO',HEX,2,MIN=4\n         QCBFE 'JBKEY',HEX,4\n         QCBFE 'TRAK ',HEX,4\n         QCBFE 'INPND',HEX,2,MIN=4\n         QCBFE 'XEQND',HEX,2,MIN=4\n         QCBFE 'PRNOD',HEX,2,MIN=4\n         QCBFE 'PRREM',HEX,2,MIN=4\n         QCBFE 'PUNOD',HEX,2,MIN=4\n         QCBFE 'PUREM',HEX,2,MIN=4\n         QCBFE 'HDSCT',HEX,3\n         QCBFE 'FLAG4',HEX,1\n         QCBFE 'JNAME',CHAR,8\n         QCBFE 'USRID',CHAR,8,MIN=10\n         QCBFE 'SECLB',CHAR,8,MIN=10\n         QCBFE 'JOEID',HEX,4\n*        AIF   (NOT &QBIU).CBNBIU1       SKIP IF NOT BAR ILAN.\n*        QCBFE 'IFLG1',HEX,1\n*        QCBFE 'ITAPE',HEX,1\n*        QCBFE 'IDXCP',HEX,2\n*        QCBFE 'ITXCP',HEX,2\n*        QCBFE 'ITIME',HEX,2\n.CBNBIU1  ANOP\n         QCBFE 'FLAG5',HEX,1\n         QCBFE 'OFFSL',HEX,1,MIN=7\n         QCBFE 'TGNUM',HEX,2,MIN=7\n         QCBFE 'FLAG6',HEX,1,MIN=9      OY20155\n         QCBFE 'rsrvd',HEX,3,MIN=9      OY20155\n          AIF   ('&@@ID' NE 'USC-UCS').NOUSC1\n*---  start of fields for Mellon Bank mods\n         QCBFE 'DNAME',CHAR,8           names from bef/aft/cntl cards\n         QCBFE '     ',CHAR,8           ...\n         QCBFE '     ',CHAR,8           ...\n         QCBFE '     ',CHAR,8           ...\n         QCBFE 'RESRT',HEX,4            resource routing bits\n         QCBFE 'MFLAG',HEX,1\n         QCBFE 'rsrvd',HEX,3\n*---  end   of fields for Mellon Bank mods\n         QCBFE 'SLID ',CHAR,8           submittor's logonid\n.NOUSC1   ANOP\n         QCBFE 'SUMSK',HEX,4,MIN=7\n         DC    X'FF'\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "Q#CB#PDB": {"ttr": 4101, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x904/\\x00\\x904/\\x01E\\x00O\\x00B\\x00\\x0c\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1990-12-08T00:00:00", "modifydate": "1990-12-08T01:45:00", "lines": 79, "newlines": 66, "modlines": 12, "user": "LDW"}, "text": "*        COPY  Q#CB#PDB\n***********************************************************************\n*                                                                     *\n*   Description of PDDB fields -- copied into Q#CB                    *\n*                                                                     *\n***********************************************************************\nCB#D#PDB QCBFE ,,,L=5\n         QCBFE 'FLAG1',HEX,1,MIN=5\n         QCBFE 'RECFM',HEX,1,MIN=5\n         QCBFE 'LRECL',HEX,2,MIN=5\n         QCBFE 'MTTR ',HEX,4,MIN=5\n         QCBFE 'MTTRL',HEX,4,MIN=5\n         QCBFE 'DSKEY',HEX,2,MAX=7      ???\n         QCBFE 'DSKEY',HEX,4,MIN=8      ???\n         QCBFE 'CLASS',CHAR,1,MIN=5\n         QCBFE 'COPYS',HEX,1,MIN=5\n         QCBFE 'DNODE',HEX,2,MIN=5\n         QCBFE 'DRMT ',HEX,2,MIN=5\n         QCBFE 'USER ',CHAR,8,MIN=5\n         QCBFE 'CPU  ',HEX,1,MAX=8      ???\n         QCBFE 'SEC  ',HEX,1,MAX=8      ???\n         QCBFE 'rsrvd',HEX,1,MIN=9      ???\n         QCBFE 'OFFSL',HEX,1,MIN=9      ???\n         QCBFE 'FLAG2',HEX,1,MIN=5\n         QCBFE 'CPTN ',HEX,1,MIN=5\n         QCBFE 'RECCT',HEX,4,MIN=5\n         QCBFE 'PGCT ',HEX,4,MIN=5\n         QCBFE 'BYTCT',HEX,4,MIN=5\n         QCBFE 'FORMS',CHAR,8,MIN=5\n         QCBFE 'FCB  ',CHAR,4,MIN=5\n         QCBFE 'UCS  ',CHAR,4,MIN=5\n         QCBFE 'DSID ',CHAR,8,MIN=5,MAX=9\n         QCBFE 'WTRID',CHAR,8,MIN=10\n         QCBFE 'RBA  ',HEX,8,MIN=5\n         QCBFE 'CHAR1',CHAR,4,MIN=5\n         QCBFE 'CHAR2',CHAR,4,MIN=5\n         QCBFE 'CHAR3',CHAR,4,MIN=5\n         QCBFE 'CHAR4',CHAR,4,MIN=5\n         QCBFE 'FLASH',CHAR,4,MIN=5\n         QCBFE 'MODF ',CHAR,4,MIN=5\n         QCBFE 'FLSHC',HEX,1,MIN=5\n         QCBFE 'MODFT',HEX,1,MIN=5\n         QCBFE 'COPYG',HEX,8,MIN=5\n         QCBFE 'CKPTP',HEX,2,MIN=5\n         QCBFE 'CKPTL',HEX,2,MIN=5\n         QCBFE 'FLAG3',HEX,1,MIN=5\n         QCBFE 'STAT ',HEX,1,MIN=5\n         QCBFE 'ID   ',CHAR,2,MIN=5\n         QCBFE 'NAME ',CHAR,8,MIN=5\n         QCBFE 'RESV ',HEX,2,MAX=8      ???\n         QCBFE 'CRTME',HEX,4,MIN=5\n         QCBFE 'PLIOT',HEX,4,MIN=5\n         QCBFE 'PLOFF',HEX,4,MIN=5\n         QCBFE 'SSOFM',CHAR,4,MIN=5\n         QCBFE 'PNAME',CHAR,8,MIN=5\n         QCBFE 'SNAME',CHAR,8,MIN=5\n         QCBFE 'DDNAM',CHAR,8,MIN=5\n         QCBFE 'PRMD ',CHAR,8,MIN=5\n         QCBFE 'TOKEN',CHAR,32,MIN=10   length is $HASPEQU.$TKNLEN\n         QCBFE '     ',CHAR,32,MIN=10\n         QCBFE '     ',CHAR,16,MIN=10\n         QCBFE 'CRUID',CHAR,8,MIN=10\n         QCBFE 'SECLB',CHAR,8,MIN=10\n         QCBFE 'LINCT',HEX,1,MIN=5\n         QCBFE 'INDEX',HEX,1,MIN=5\n         QCBFE 'FUNC ',HEX,1,MIN=5\n         QCBFE 'PRIO ',HEX,1,MIN=5\n         QCBFE 'FLAG4',HEX,1,MIN=5\n         QCBFE 'FLAG5',HEX,1,MIN=5\n         QCBFE 'RSVD ',HEX,2,MIN=5\n         QCBFE 'SWBOT',HEX,4,MIN=5\n         QCBFE 'OUTOK',HEX,8,MIN=5\n         QCBFE 'CPTNM',CHAR,8,MIN=5\n         QCBFE 'WTOKN',HEX,4,MIN=10\n         QCBFE 'rsrvd',HEX,16,MIN=5,MAX=10\n         QCBFE 'rsrvd',HEX,12,MIN=10\n         QCBFE 'DSNAM',CHAR,32,MIN=10\n         QCBFE '     ',CHAR,12,MIN=10\n         DC    X'FF'\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "Q#CH": {"ttr": 4104, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0c\\x00\\x00\\x00\\x825o\\x00\\x91\\x18_\"8\\x00S\\x00s\\x009\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.12", "flags": 0, "createdate": "1982-12-22T00:00:00", "modifydate": "1991-07-04T22:38:00", "lines": 83, "newlines": 115, "modlines": 57, "user": "LDW"}, "text": " TITLE '--- QUEUE--CHANGES -- DISPLAY RECENT QUEUE COMMAND CHANGES ---'\n*---------------------------------------------------------------------*\n*                                                                     *\n*   Changes - Display recent QUEUE command changes                    *\n*                                                                     *\n*   Updates:                                                          *\n*      04Jul91  LDW  Make CHGSTEXT a WXTRN                            *\n*      23Nov89  LDW  Eliminate usage of LC macro                      *\n*      03/31/86 LDW  RE-DESIGN 3278-5 SUPPORT (THIRD TRY!)            *\n*      01/17/84 LDW  ADD SUPPORT FOR COMMAND STACKING                 *\n*      06/16/83 LDW  FIX BUG THAT CAUSED 0C4 IF COMMAND RE-ENTERD     *\n*                       AFTER SEQUENCING PAST END OF DISPLAY          *\n*      02/23/83 LDW  MOVE ACTUAL CHANGES TEXT TO SEPARATE LOAD MODULE *\n*      02/10/83 LDW  ADD SUPPORT FOR ATTR BYTES IN CHANGES TEXT LINES *\n*      02/02/83 LDW  ONLY DISPLAY LIST OF INTERNAL CHANGES IF THE     *\n*                       KEYWORD \"INTERNAL\" IS ENTERED                 *\n*      01/04/83 LDW  NEW ROUTINE                                      *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 3\n         WXTRN CHGSTEXT\n         SPACE 3\nCHANGES  QSTART  STACK=X'C0'\n         QCALL DISP80                   SWITCH TO 3278-2 MODE IF 3278-5\n         MVC   QDHLINE(L'CH#HDR),CH#HDR MOVE HEADER\n         L     R1,=A(CHGSTEXT)          -> CSECT\n         LTR   R1,R1                    IS IT LINK EDITTED IN?\n         BNZ   CH$GO                    YES - USE IT\n         L     R1,QVCHGS                -> TEXT LOAD MODULE\n         LTR   R1,R1                    IS IT LOADED YET?\n         BNZ   CH$GO                    YES - USE IT\n         SPACE 1\n         LOAD  EPLOC==CL8'QCHGTXT',ERRET=CH$OOPS\n         SPACE 1\n         ST    R0,QVCHGS                SAVE ADDR FOR NEXT TIME\n         LR    R1,R0                    GET ADDR IN CORRECT REGISTER\n         SPACE 2\nCH$GO    L     R5,0(,R1)                -> FIRST LINE\n         CLI   QKEYWORD,C'I'            WANT LIST OF INTERNAL CHANGES?\n         BNE   CH$LOOP                  NO - GO START\n         MVC   QDHLINE(L'CH#HDRX),CH#HDRX  MOVE OTHER HEADER\n         L     R5,4(,R1)                -> FIRST LINE\n         SPACE 1\nCH$LOOP  SR    R7,R7                    CLEAR FOR IC\n         IC    R7,0(,R5)                GET LINE LENGTH-1\n         TM    1(R5),1                  LINE FOR AUTH USERS ONLY?\n         BNO   CH$NAUTH                 NO - CONTINUE\n         TM    QXAUTH,QXAUTHX           WELL, IS HE AUTHORIZED?\n         BZ    CH$SKIP                  NO - SKIP THIS LINE\nCH$NAUTH EX    R7,CH$MVC                MVC QDMSG(*-*),3(R5)\n         MVC   QDATRNUM+1(1),2(R5)      SET NUMBER OF ATTR BYTES\n         BAL   R14,QADDLINE             MOVE LINE TO SCREEN\nCH$SKIP  LA    R5,3+1(R7,R5)            -> NEXT LINE\n         CLI   0(R5),X'FF'              LAST LINE?\n         BNE   CH$LOOP                  NO - CONTINUE\n         SPACE 1\n         L     R1,=A(CHGSTEXT)          -> CSECT\n         LTR   R1,R1                    IS IT LINK EDITTED IN?\n         BNZ   QSTOP                    YES - NO DELETE REQUIRED\n         SPACE 1\n         DELETE  EPLOC==CL8'QCHGTXT'    GET RID OF MODULE\n         SPACE 1\n         XC    QVCHGS,QVCHGS            INDICATE MODULE NOT LOADED\n         B     QSTOP                    BAIL OUT\n***********************************************************************\n*                                                                     *\n*   MISCELLANY                                                        *\n*                                                                     *\n***********************************************************************\nCH$OOPS  QTILT '*** CHANGES MODULE UNAVAILABLE -- CONTACT SYSTEMS GROUP$\n                ***'\nCH$MVC   MVC   QDMSG(*-*),3(R5)         << EXECUTED >>\n         SPACE 1\n         LTORG\n         SPACE 1\nCH#HDR   DC    C'Change history of the QUEUE command:'\nCH#HDRX  DC    C'Internal change history of the QUEUE command:'\n         SPACE 1\n         ENTRY CH#KEYS\nCH#KEYS  DC    CL8'INTERNAL'\n         DC    X'FF'                    FLAG END OF TABLE\n         SPACE 3\n         QCOMMON\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "Q#CK": {"ttr": 4107, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\r\\x00\\x00\\x00\\x82#/\\x00\\x91\\x19_\"9\\x00\\xfd\\x00D\\x00\\xc9\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "05.13", "flags": 0, "createdate": "1982-08-20T00:00:00", "modifydate": "1991-07-14T22:39:00", "lines": 253, "newlines": 68, "modlines": 201, "user": "LDW"}, "text": "         TITLE '--- QUEUE--CKPT -- READ JES2 CKPT RECORDS ---'\n*---------------------------------------------------------------------*\n*                                                                     *\n*   CKPT - Read the JES2 checkpoint dataset into storage              *\n*                                                                     *\n*   Updates:                                                          *\n*      14Jul91  LDW  Do logic trace if QDEBUG47                       *\n*      25Sep90  LDW  Switch to 24 bit mode before POINT               *\n*      16Jun90  LDW  Use new QAMODE24/31 subroutines                  *\n*                    Since we now run in AMODE=31, change to AMODE 24 *\n*                       when doing I/O, and don't do other switching  *\n*      04Jun89  LDW  Use improved AUTHFUNC routine                    *\n*      31May89  LDW  Don't switch back to key NZERO if not APF!       *\n*                    Init flag byte to zero                           *\n*                    Copy applcopy even if it didn't change (temp?)   *\n*                    Bypass intentional delay if reading from         *\n*                       in-storage checkpoint                         *\n*      15May89  EMS  Copy from in core checkpoint optionally          *\n*      25Sep88  LDW  Fix bug:  don't read one extra block (this       *\n*                       sometimes caused Abend337-04)                 *\n*       5Jun87  EMS  fix for base level JES2                          *\n*      16Jan87  LDW  SP136 update                                     *\n*      03JUN86  LDW  IMPLEMENT CHAINED SCHEDULING                     *\n*      08/06/84 LDW  ALLOW FOR MASTER RECORD > 4K FOR SP              *\n*                       (SEE \"INITIAL\")                               *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 3\nCKPT     QSTART  Q3,WORKLEN=CK@WORKL\n         USING WORK,R13\n         QDEBUG QDEBUG47,'>>> at ckpt'\n         L     R15,QC##CKPT             GET CALL COUNTER\n         LA    R15,1(,R15)              INCREMENT\n         ST    R15,QC##CKPT             STORE UPDATED COUNTER\n         MVI   CK@FLAG,0                init flags\n         SPACE 2\n          AIF   (&QLEVEL LT 8).CK01\n***********************************************************************\n*                                                                     *\n*   Check to see if in core checkpoint is available                   *\n*                                                                     *\n***********************************************************************\n         TM    QXAUTH,QXAPFENT+QXSUPR   APF authorized or SUPR state?\n         BNZ   CK$APFOK                 yes - continue\n         QDEBUG QDEBUG47,'>>> ckpt needs apf'\n         LA    R1,4                     ask for auth\n         LNR   R1,R1                    make it conditional\n         QCALL AUTHFUNC                 try to get APF authorized\n         LTR   R15,R15                  did we get it?\n***      BNZ   CK$KC$SW                 branch if nogo\n         BNZ   CKPT$GO                  branch if nogo\n         QDEBUG QDEBUG47,'>>> ckpt got apf'\n         SPACE 1\nCK$APFOK ICM   R8,B'1111',QKACA         -> KAC area\n         BZ    CK$KC$SW                 if invalid, don't use\n         QDEBUG QDEBUG47,'>>> ck$apfok using kac'\n         USNGX KAC,R8\n         TM    QMODE2,QM2CKPT           use incore checkpoint?\n         BZ    CK$KC$SW                 no, read ckpt\n         LA    R1,12                    function code\n         QCALL AUTHFUNC                 go key zero\n         CLC   =C'KAC',KACIDENT         is it really a KAC?\n         BNE   CK$KC$SW                 no, read normally\n         TM    KACFLAG1,KAC1ECSA        in ECSA?\n         BZ    CK$KC$SW                 no, read ckpt\n         TM    KACFLAG1,KAC1GONE+KAC1BADC   unusable?\n         BNZ   CK$KC$SW                 yes, read ckpt\n         OI    CK@FLAG,CK@FCKPT         read from in core\nCK$KC$SW LA    R1,16                    function code\n         QCALL AUTHFUNC                 reset key\n         QDEBUG QDEBUG47,'>>> ck$kc$sw'\n         TM    CK@FLAG,CK@FCKPT         read from in core?\n         BNZ   CKPT$GO                  yes - skip delay\n.CK01     ANOP ,\n***********************************************************************\n*                                                                     *\n*   KEEP HIM FROM HITTING THE CHECKPOINT FILE TOO OFTEN               *\n*                                                                     *\n***********************************************************************\n         TM    QXAUTH,QXSYSP            SYSTEMS PROGRAMMER?\n         BO    CKPT$GO                  YES - NO DELAY\n         CLI   QCKPTIME,X'FF'           FIRST TIME HERE?\n         BE    CKPTMARK                 YES - NO WAIT\n         TIME  BIN                      GET CURRENT TIME\n         S     R0,QCKPTIME              COMPUTE ELAPSED TIME\n         BNM   *+8                      CONTINUE IF OK\n         A     R0,=A(24*60*60*100)      MIDNIGHT ADJUSTMENT\n         LA    R2,2*100                 ASSUME 2 SECOND DELAY\n         TM    QSCFLAG1,QSC1CPU         EXTRA SLOW COMMAND?\n         BNO   *+8                      NO - SKIP\n         SLL   R2,2                     YES - USE 8 SECOND DELAY\n         CR    R0,R2                    DIFFERENCE > DELAY?\n         BNL   CKPTMARK                 YES - NO WAIT\n         SR    R2,R0                    COMPUTE WAIT TIME\n         CH    R2,=H'50'                < .5 SECOND?\n         BL    CKPTMARK                 YES - SAVE SWAP OVERHEAD\n*  NOTE: IF YOU HAVE RTO OF 1.5 SECOND OR MORE, THE FOLLOWING WILL\n*        ALWAYS BE SKIPPED.\n         ST    R2,QNUMWORK              STORE DELAY\n         STIMER  WAIT,BINTVL=QNUMWORK   MAKE HIM WAIT\n         SPACE 2\nCKPTMARK TIME  BIN                      GET CURRENT TIME\n         ST    R0,QCKPTIME              SAVE\nCKPT$GO  EQU   *\n         QDEBUG QDEBUG47,'>>> ckpt$go'\n          AIF   (&QLEVEL LT 8).CK02\n         TM    CK@FLAG,CK@FCKPT         read from incore ckpt?\n         BZ    CK$RD                    no, do real i/o\n***********************************************************************\n*                                                                     *\n*   READ FROM IN CORE COPY OF CKPT                                    *\n*                                                                     *\n***********************************************************************\n         QDEBUG QDEBUG47,'>>> ckpt using in core'\n         LA    R1,12                    function code\n         QCALL AUTHFUNC                 go key zero\n*  The following may seem like a good idea, but since QUEUE modifies\n*  its copy of the checkpoint data, we have to skip this for now, or\n*  we get strange results if JES2 hasn't updated its copy!\n         CLC   QKACTUP,KACTUP           any update since last time?\n**       BE    CK$CY$SK                 no, skip read\n         NOP   CK$CY$SK                 no, skip read\n         L     R2,QCJQTL                -> area for master rec\n         L     R14,KACMSTRA             -> kac master rec\n         L     R3,$MASTERL-$SAVEBEG(,R14)  len of master rec\n         LR    R15,R3                   copy for mvcl\n         MVCL  R2,R14                   get master rec\n         L     R2,QCJQTL                -> master rec\n         L     R1,$MASTERL-$SAVEBEG(,R2)  get master record len\n         LA    R1,4095(,R1)             round\n         SRL   R1,12                    round to 4k\n         AH    R1,$CLRECN-$SAVEBEG(,R2) # number of change blocks\n         SLL   R1,12                    get back as mult of 4k\n         AR    R2,R1                    -> new target\n         L     R3,KACCLEN               len of copy\n         L     R14,KACCKPTA             -> to ckpt area\n         LR    R15,R3                   copy for mvcl\n         MVCL  R2,R14                   get ckpt area\n         MVC   QKACTUP,KACTUP           last update tod\n         LA    R1,16                    function code\n         QCALL AUTHFUNC                 reset key\n         B     CK$CY$EX                 and exit in 24 bit mode\n         SPACE 1\nCK$CY$SK LA    R1,1                     incr by 1\n         A     R1,QC#CKPT#              new count\n         ST    R1,QC#CKPT#              save it\n         SPACE 1\nCK$CY$EX LA    R1,8                     reset apf\n         QCALL AUTHFUNC                 do it only if we set it\n         B     QSTOP                    and exit\n.CK02     ANOP ,\n***********************************************************************\n*                                                                     *\n*   REPOSITION DATASET                                                *\n*                                                                     *\n***********************************************************************\nCK$RD    L     R1,QCCKPT                -> HASPCKPT\n         BAL   R14,QAMODE24             change to AMODE 24\n         QDEBUG QDEBUG47,'>>> ck$rd'\n         SPACE 1\n         POINT (1),=FS8'3'              POINT PAST SYNC RECORDS TO REC3\n         SPACE 1\n         L     R2,QCJQTL                -> IOAREA FOR CKPT MASTER REC\n         L     R3,QCJOTL                NUMBER OF RECS IN CKPT DATASET\n         L     R4,QCDECB1               -> DECB FOR HASPCKPT\n          AIF   (&QLEVEL LT 4).CK03\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*   READ MASTER RECORD                                                *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         READ  (R4),SF,,(R2),'S',MF=E   READ THE MASTER RECORD\n         SPACE 1\n         CHECK (R4)\n         SPACE 1\n         BAL   R14,QAMODE31             resume AMODE 31\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*   READ REMAINING CHECKPOINT BLOCKS                                  *\n*                                                                     *\n***********************************************************************\n         BCTR  R3,0                     adjust remaining record count\n         L     R1,$MASTERL-$SAVEBEG(,R2)  GET MASTER RECORD LENGTH\n         LA    R1,4095(,R1)             ROUND\n         SRL   R1,12                    ROUND TO 4K\n         SLL   R1,12                    GET BACK AS MULT OF 4K\n         AR    R2,R1                    -> IOAREA FOR NEXT CKPT BLOCK\n.CK03     ANOP ,\n***********************************************************************\n*                                                                     *\n*   READ CHECKPOINT DATASET                                           *\n*                                                                     *\n***********************************************************************\n         LH    R5,=H'4096'              LENGTH TO READ\n         SPACE 1\n         L     R7,QCCKPT                -> HASPCKPT DCB\n         MVI   CK@NCP,0                 CLEAR TOP OF HALFWORD\n         MVC   CK@NCP+1(1),DCBNCP-IHADCB(R7)  SAVE NCP VALUE\n         SPACE 1\nCKPT$LP1 LR    R6,R3                    COPY NUMBER OF RECORDS TO READ\n         CH    R6,CK@NCP                MORE THAN LIMIT?\n         BNH   *+8                      NO - OK\n         LH    R6,CK@NCP                YES - USE MAX\n         BAL   R10,CKPT$RD              READ \"N\" RECORDS\n         SH    R3,CK@NUM                SUBTRACT \"N\" RECORDS READ\n         BP    CKPT$LP1                 KEEP READING IF MORE TO GO\n         B     QSTOP                    RETURN TO CALLER\n         SPACE 3\n*---  SUBROUTINE TO READ A SPECIFIED NUMBER OF HASPCKPT RECORDS    ---*\nCKPT$RD  STH   R6,CK@NUM                SAVE NUMBER OF RECORDS TO READ\n         L     R4,QVCKDECB              -> FIRST HASPCKPT DECB\n         BAL   R14,QAMODE24             change to AMODE 24\n         SPACE 2\n*  REGISTER USAGE AT THIS POINT:\n*    R2 - IOAREA FOR NEXT RECORD\n*    R3 - USED BY OUTER LOOP - NUMBER OF REMAINING RECORDS TO READ\n*    R4 - DECB ADDRESS\n*    R5 - LENGTH TO READ\n*    R6 - NUMBER OF RECORDS TO READ THIS TIME\n*    R7 - HASPCKPT DCB ADDRESS\nCKPT$RL1 READ  (R4),SF,(R7),(R2),(R5),MF=E  READ A RECORD\n         SPACE 1\n         LA    R4,HDECB1L(,R4)          INCREMENT TO NEXT DECB\n         AR    R2,R5                    INCREMENT TO NEXT BUFFER\n         BCT   R6,CKPT$RL1              READ NEXT RECORD\n         SPACE 2\n         LH    R6,CK@NUM                GET NUMBER OF RECORDS READ\n         L     R4,QVCKDECB              -> FIRST HASPCKPT DECB\n         SPACE 2\nCKPT$RL2 CHECK (R4)                     CHECK A RECORD\n         SPACE 1\n         LA    R4,HDECB1L(,R4)          INCREMENT TO NEXT DECB\n         BCT   R6,CKPT$RL2              CHECK NEXT RECORD\n         BAL   R14,QAMODE31             resume AMODE 31\n         SPACE 1\n         BR    R10                      RETURN TO CALLER\n         SPACE 3\n         LTORG ,\n         SPACE 3\n         QCOMMON\n         QDCB  ,                        ADDED FOR DCB EQUATES\nWORK     DSECT\n         ORG   WORK+72                  PAST SAVE AREA\nCK@NCP   DS    H                        MAX NUMBER OF BUFFERS\nCK@NUM   DS    H                        NUMBER OF RECORDS TO READ NOW\nCK@FLAG  DS    X                        misc flags\nCK@FCKPT EQU   X'80'                    use incore ckpt\nCK@WORKL EQU   *-WORK                   len of ckpt workarea\n         Q$HCT ,\n         Q$KAC ,\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "Q#CP": {"ttr": 4112, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x16\\x00\\x00\\x00\\x82#/\\x00\\x91\\x03?\\x014\\x01\\x8f\\x00\\xe9\\x00\\xe0\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "05.22", "flags": 0, "createdate": "1982-08-20T00:00:00", "modifydate": "1991-02-02T01:34:00", "lines": 399, "newlines": 233, "modlines": 224, "user": "LDW"}, "text": "         TITLE '--- QUEUE--CPU -- LIST ACTIVE JOB CPU TIME ---'\n*---------------------------------------------------------------------*\n*                                                                     *\n*   CPU - Display address space data for jobs active on this CPU      *\n*                                                                     *\n*   Updates:                                                          *\n*      01Feb91  LDW  Integrate GLA fixes below:                       *\n*     (17Apr90) GLA  Support CPU for specific jobs and prefixs        *\n*     (05Jul89) GLA  Rearrange for 79 char line under ISPF            *\n*      16Dec90  LDW  Get frame count correctly under MVS/SP 3.1       *\n*      16Jun90  LDW  Remove mode switching since we now run AMODE 31  *\n*                    Oops, really did need Q$HCCT                     *\n*      25Dec89  LDW  Q$xxx -> QZxxx:  ASCB, ASVT, CSCB, CVT, SSCT     *\n*                    QOUCB -> QZOUCB                                  *\n*                    Remove unneeded Q$HCCT                           *\n*      23Nov89  LDW  Remove pre-req macros (now in Q$xxx)             *\n*      21Jun89  LDW  Correct display of CPU & SRB > 99,999.99S        *\n*      04Jun89  LDW  Use improved AUTHFUNC routine                    *\n*      23May89  EMS  SP311 changes:                                   *\n*      14Feb87  LDW  Fix for MVS/XA or JES2 2.1.5 or ???              *\n*      17Jan87  LDW  Eliminate \"LC\" macro usage                       *\n*      04Jan87  LDW  Use correct ASCB field for I/O count             *\n*               LDW  Use CVT instead of CVTDSECT (for XA?)            *\n*      14Dec86  LDW  SP136 updates:  change SVT field names           *\n*      17JUN86  LDW  FIX FOR MVS/XA                                   *\n*      03/31/86 LDW  RE-DESIGN 3278-5 SUPPORT (THIRD TRY!)            *\n*      04/10/84 LDW  SP133 COMPATIBILITY                              *\n*      01/17/84 LDW  ADD SUPPORT FOR COMMAND STACKING                 *\n*      03/02/83 LDW  CHANGE 'QTILT *' TO USE QERRMSG                  *\n*      01/24/83 LDW  ADD Q$DEB IN FRONT OF Q$SJB FOR SP               *\n*      01/07/83 LDW  DISPLAY QUEUE, JOBNUMBER, AND SLOTS IF \u00ac= 0 IN   *\n*                       HIGH INTENSITY                                *\n*      01/04/83 LDW  LOCAL WORK AREA SUPPORT                          *\n*                    SP SUPPORT                                       *\n*                    HEADER LINE TO LOWER CASE                        *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 3\nCPU      QSTART  Q24,WORKLEN=CP@WORKL,STACK=X'01'\n         USING WORK,R13\n         QCALL DISP80                   SWITCH TO 3278-2 MODE IF 3278-5\n         OI    QSCFLAG1,QSC1CPU         REQUEST EXTRA DELAY\n         QCALL CKPT                     READ CHECKPOINT DATA\n         MVI   CP@FLAG,CP@J+CP@S        ASSUME \"B\"\n         XC    CP@PLEN,CP@PLEN          clear length\n         CLI   QLNG1+1,1                Is this a flag\n         BH    CP$PF1                   No - may be prefix\n         CLI   QPARM1,C'A'              WANT ALL 3?\n         BNE   *+8                      NO - SKIP\n         OI    CP@FLAG,CP@T             YES - SET REMAINING FLAG\n         CLI   QPARM1,C'J'              WANT JUST JOBS?\n         BNE   *+8                      NO - SKIP\n         MVI   CP@FLAG,CP@J             YES - SET FLAG\n         CLI   QPARM1,C'S'              WANT JUST STCS?\n         BNE   *+8                      NO - SKIP\n         MVI   CP@FLAG,CP@S             YES - SET FLAG\n         CLI   QPARM1,C'T'              WANT JUST TSUS?\n         BNE   *+8                      NO - SKIP\n         MVI   CP@FLAG,CP@T             YES - SET FLAG\n         CLI   QLNG2+1,0                Any prefix?\n         BE    CP$PFX                   no so leave alone\n         MVC   CP@PFX,QPARM2            save parameter\n         MVC   CP@PLEN,QLNG2            save length\n         B     CP$PFX                   all done with prefix\nCP$PF1   DS    0H                       get prefix from parm 1\n         MVC   CP@PFX,QPARM1            save it\n         MVC   CP@PLEN,QLNG1            and the length\nCP$PFX   DS    0H\n         L     R1,16                    POINT TO CVT\n         USING CVT,R1\n***********************************************************************\n*                                                                     *\n*        FIND THE SSVT FOR THE SELECTED SUBSYSTEM                     *\n*                                                                     *\n***********************************************************************\n         L     R7,CVTASVT               POINT TO ASVT\n         USING ASVT,R7\n         L     R2,ASVTMAXU              LOAD THE MAX ASCBS\n         DROP  R1                       CVT\n         L     R1,QSSCT                 -> SSCT FOR CURRENT JES2\n         LTR   R1,R1                    VALID SUBSYSTEM?\n*%%%     QCALL GETSVT                   Go and get our SSVT\n*%%%     LTR   R8,R1                    Valid subsystem?\n         BZ    CP$TILT                  NO - CAN'T DO THIS SUBCOMMAND\n         USING SSCT,R1\n          AIF  (&QLEVEL GE 9).CP08\n         L     R8,SSCTSSVT              POINT TO SSVT\n         USING SSVT,R8\n          AGO  .CP09\n.CP08     ANOP ,\n         L     R8,SSCTSUS2              POINT TO HCCT\n         USING HCCT,R8\n         TM    QXAUTH,QXAPFENT+QXSUPR   APF authorized or SUPR state?\n         BNZ   CP$APFOK                 yes\n         LA    R1,4                     request auth\n         LNR   R1,R1                    make it conditional\n         QCALL AUTHFUNC                 get it\n         LTR   R15,R15                  well?\n         BNZ   CP$NAUTH                 then can't do command\nCP$APFOK LA    R1,12                    go keyzero for a while\n         QCALL AUTHFUNC\n.CP09     ANOP ,\n         DROP  R1                       SSCT\n         LTR   R8,R8                    ANY?\n         BZ    CP$TILT                  NO - CAN'T DO THIS SUBCOMMAND\n***********************************************************************\n*                                                                     *\n*        FIND THE SELECTED SUBSYSTEM'S HAVT                           *\n*                                                                     *\n***********************************************************************\n          AIF   (&QLEVEL GE 9).CP10A\n         USING SSVT,R8\n         L     R6,SVTHAVT               POINT TO HAVT\n         AGO   .CP10B\n.CP10A    ANOP\n         USING HCCT,R8\n         L     R6,CCTHAVT               Point to HAVT\n.CP10B    ANOP\n         LTR   R6,R6                    TEST IF ANY PITS\n         BZ    CP$NHAVT                 NO, IGNORE COMMAND\n         LA    R6,4(,R6)                POINT TO FIRST SJB POINTER\n         MVC   QDHLINE(79),=C'ASID -Q- Job# Jobname  Stepname Procstep $\n                Slots   TCB-Time   SRB-Time   I/O Cnt'\n***********************************************************************\n*                                                                     *\n*        BUILD THE MESSAGE(S) DESCRIBING THE JOBS                     *\n*                                                                     *\n***********************************************************************\nCP$BUILD MVC   QDMSG,QBLANK             BLANK THE AREA\n          AIF  (&QLEVEL GE 9).CP10\n         L     R5,0(,R6)                POINT TO SJB\n          AGO  .CP11\n.CP10     ANOP ,\n         ICM   R5,B'1111',0(R6)         -> HASB\n         BZ    CP$NXSJB                 if none here, skip entry\n         L     R5,HSBSJB-HASB(,R5)      -> SJB\n.CP11     ANOP ,\n         USING SJBDSECT,R5\n         LTR   R5,R5                    TEST FOR ANY\n         BZ    CP$NXSJB\n         L     R1,SJBASCBP              POINT TO ASCB\n         USING ASCB,R1\n         LH    R1,ASCBASID              GET THE ASID\n         DROP  R1                       ASCB\n         CH    R1,SJBASID               THIS THE CORRECT ASCB?\n         BNE   CP$NXSJB                 NO - IGNORE THIS SJB\n         SLL   R1,2                     MULTIPLY BY 4\n         LA    R1,ASVTENTY-4(R1)        -> ASVT ENTRY FOR THIS ASCB\n         TM    0(R1),ASVTAVAL           THIS ASID IN USE?\n         BO    CP$NXSJB                 NO - IGNORE THIS SJB\n         ICM   R4,B'1111',SJBSJB        IS IT A BATCH JOB?\n         BNZ   CP$JOBCK                 YES\n         L     R3,SJBJQOFF              LOAD JQE OFFSET\n         AL    R3,QCJQTA                ADD TO JQE ORIGIN\n         USING JQEDSECT,R3              BASE REG FOR JQE\n          AIF   (&QLEVEL GE 4).CP01\n         LH    R0,JQEJOBNO              GET JOB NO.\n         CH    R0,=H'20000'             TSO USER?\n         BNL   CP$TSOCK                 YES. GO PROCESS\n          AGO   .CP02\n.CP01     ANOP\n         TM    JQEFLAG3,QUETSU          TSO USER?\n         BO    CP$TSOCK                 YES. GO PROCESS\n.CP02     ANOP\n         B     CP$STCCK                 NO. GO PROCESS AS STC\n         SPACE 2\nCP$JOBCK TM    CP@FLAG,CP@J             DISPLAY JOBS?\n         BNO   CP$NXSJB                 NO. GET NEXT SJB\n         LR    R5,R4                    COPY THE SJB ADDRESS\n         L     R3,SJBJQOFF              POINT TO JQE OFFSET\n         LTR   R3,R3                    ANY JQE?\n         BZ    CP$NXSJB                 NO. GET NEXT SJB\n         AL    R3,QCJQTA                POINT TO THE JQE\n         MVI   CP@QUEUE,C'I'\n         MVC   CP@QUEUE+2(1),JQETYPE    SET THE QUEUE TYPE\n         OI    CP@QUEUE+2,X'80'         SET THE PRINTABLE QUEUE TYPE\n         B     CP$NOTSO                 GO TO COMMON ROUTINE\nCP$TSOCK TM    CP@FLAG,CP@T             DISPLAY TSUS?\n         BNO   CP$NXSJB                 NO. GET NEXT SJB ?\n         MVC   CP@QUEUE,=C'TSU'\n         B     CP$NOTSO\nCP$STCCK TM    CP@FLAG,CP@S             DISPLAY STCS?\n         BNO   CP$NXSJB                 NO. GET NEXT SJB.\n         MVC   CP@QUEUE,=C'STC'\nCP$NOTSO ICM   R14,3,CP@PLEN            get prefix len\n         BZ    CP$WJOB                  if no prefix then all jobs\n         BCTR  R14,0                    get machine length\n         EX    R14,CP$CK$JB             see if desired job\n         BNE   CP$NXSJB                 not desired one\n*\nCP$WJOB  L     R14,SJBASCBP             POINT TO ASCB\n         USING ASCB,R14\n         UNPK  CP@ASID(4+1),ASCBASID(2+1)  GET THE ASID\n         TR    CP@ASID(4),QHEXTAB       MAKE IT DISPLAYABLE\n         MVI   CP@ASID+4,C' '           REMOVE GARBAGE BYTE\n         LM    R0,R1,ASCBEJST           GET THE CPU TIME\n         SRDL  R0,12                    SKIP THE GARBAGE\n         D     R0,=F'10000'             GET THE VALUE IN .01 SECS\n         CVD   R1,QNUMWORK              GET THE DECIMAL VALUE\n         MVC   CP@TCBTM,=X'4020206B2021204B2020'  MOVE EDIT MASK\n         ED    CP@TCBTM,QNUMWORK+4      EDIT THE NUMBER\n         MVI   CP@TCB@S,C'S'\n         C     R1,=F'1E8'               did it fit?\n         BL    CP$CPUOK                 yes - skip\n         MVC   CP@TCBTM,=X'40206B2020206B202120'  different edit mask\n         ED    CP@TCBTM,QNUMWORK+3      EDIT THE NUMBER\nCP$CPUOK LM    R0,R1,ASCBSRBT           GET THE CPU TIME\n         SRDL  R0,12                    SKIP THE GARBAGE\n         D     R0,=F'10000'             GET THE VALUE IN .01 SECS\n         CVD   R1,QNUMWORK              GET THE DECIMAL VALUE\n         MVC   CP@SRBTM,=X'4020206B2021204B2020'  MOVE EDIT MASK\n         ED    CP@SRBTM,QNUMWORK+4      EDIT THE NUMBER\n         MVI   CP@SRB@S,C'S'\n         C     R1,=F'1E8'               did it fit?\n         BL    CP$SRBOK                 yes - skip\n         MVC   CP@SRBTM,=X'40206B2020206B202120'  different edit mask\n         ED    CP@SRBTM,QNUMWORK+3      EDIT THE NUMBER\nCP$SRBOK L     R1,ASCBIOSC              GET I/O COUNT\n         TM    QMISCFLG,QMFMVSE         RUNNING MVS/XA?\n         BO    CP$NOTXA                 YES - SKIP\n         L     R15,ASCBOUCB             -> OUCB (IRAOUCB)\n         A     R1,108(,R15)             GET SMF I/O COUNT  (OUCBIOSM)\nCP$NOTXA CVD   R1,QNUMWORK              CONVERT TO PACKED\n         C     R1,=F'1E8'               TOO BIG FOR FIELD?\n         BNL   CP$IOBIG                 YES - DISPLAY IN K\n         MVC   CP@IOREQ,=X'40206B2020206B202020'   MOVE EDIT MASK\n         ED    CP@IOREQ,QNUMWORK+4      CONVERT I/O TO PRINTABLE\n         B     CP$IO$OK                 CONTINUE\nCP$CK$JB CLC   SJBJOBNM(0),CP@PFX       ** see if desired job **\n*---  THE FOLLOWING \"ED\" IS CHEATING...  WE LOSE THE LAST 2 BYTES  ---*\n*---  OF THE PACKED FIELD, WHICH IS 3 DIGITS!!!                    ---*\nCP$IOBIG ED    CP@IOREQ,QNUMWORK+2      CONVERT I/O TO PRINTABLE\n         MVC   CP@IOREQ(L'CP@IOREQ-1),CP@IOREQ+1   SHIFT OVER\n         MVI   CP@IOREQ+L'CP@IOREQ-1,C'K'  AND INSTALL THE 'K'\nCP$IO$OK MVC   CP@JOBNM,SJBJOBNM        MOVE IN JOBNAME\n         LH    R0,JQEJOBNO              LOAD JOB NUMBER\n* %%%    LA    R15,C' '                 ASSUME JOB - LEAVE IT\n          AIF   (&QLEVEL GE 4).CP03\n         LH    R1,=H'10000'             GET RANGE SIZE\n         SR    R0,R1                    IS IT A JOB NUMBER?\n         BNP   CP$FMJNO                 YES\n* %%%    LA    R15,C'S'                 ASSUME STC\n         SR    R0,R1                    IS IT A STC NUMBER?\n         BNP   CP$FMJNO                 YES\n* %%%    LA    R15,C'T'                 ASSUME TSU\n         SR    R0,R1                    IS IT A TSU NUMBER?\n         BNP   CP$FMJNO                 YES\n         EX    0,*                      THIS BETTER NEVER HAPPEN\nCP$FMJNO AR    R0,R1                    RESTORE JOB NUMBER\n         MVC   CP@JOBNO(6),=X'402020202020'  PREPARE FOR EDIT\n          AGO   .CP04\n.CP03     ANOP\n         TM    JQEFLAG3,QUEJOB          IS IT A JOB?\n         BZ    CP$FMJNO                 YES\n         BM    *+8                      OK IF ONLY ONE SET\n         EX    0,*                      THIS BETTER NEVER HAPPEN\n* %%%    LA    R15,C'S'                 ASSUME STC\n         TM    JQEFLAG3,QUESTC          IS IT A STC?\n         BO    CP$FMJNO                 YES\n* %%%    LA    R15,C'T'                 ASSUME TSU\nCP$FMJNO MVC   CP@JOBNO(6),=X'402020202020'  PREPARE FOR EDIT\n.CP04     ANOP\n         CVD   R0,QNUMWORK              CONVERT TO DECIMAL\n*  DON'T NEED TO PRESET R1 FOR EDMK FAILURE SINCE JES2 WON'T CREATE\n*  JOB 0, STC 0, OR TSU 0.\n         ED    CP@JOBNO(6),QNUMWORK+5   EDIT HASP JOBNUMBER\n         MVC   CP@JOBNO(5),CP@JOBNO+1   move to correct location\n* %%%    EDMK  CP@JOBNO(6),QNUMWORK+5   EDIT HASP JOBNUMBER\n* %%%    BCTR  R1,0                     BACK UP TO BEFORE FIRST\n* %%%    STC   R15,0(,R1)               STORE ' ' OR 'S' OR 'T'\n         L     R15,16                   POINT TO CVT\n         USING CVT,R15\n         L     R15,CVTMSER              POINT TO ADDRESS OF FIRST CSCB\n         DROP  R15                      CVT\nCP$FCSCB ICM   R15,B'1111',0(R15)       POINT TO THE NEXT CSCB\n         BZ    CP$NXSJB                 NONE LEFT - IGNORE THIS SJB\n         USING CSCB,R15\n         CLC   ASCBASID,CHASID          CORRECT ASID?\n         BNE   CP$FCSCB                 NO - TRY NEXT CSCB\n         CLI   CHTRKID,CHTSID           IS THIS A TSU?\n         BE    CP$TSU                   YES - HANDLE IT\n         CL    R15,ASCBCSCB             THIS THE ASCB'S CSCB?\n         BE    CP$STC                   YES - IT MUST BE AN STC'S CSCB\n         CLC   CHKEY,JQEJNAME           TEST FOR RIGHT JOB\n         BE    CP$HCSCB                 YES\n         B     CP$FCSCB                 NO - TRY NEXT CSCB\nCP$STC   CLC   CHCLS,JQEJNAME           TEST FOR RIGHT STC\n         BNE   CP$FCSCB                 NOPE\n         MVC   CP@STEPN,CHKEY           SHOW JOBNAME AS STEPNAME\n         MVC   CP@PSTEP,CHPROCSN        AND PROCSTEP\n         B     CP$FMTK\nCP$TSU   MVC   CP@STEPN,CHCLS           MOVE IN STEPNAME\n         MVC   CP@PSTEP,QBLANK          AND NO PROCSTEP AVAILABLE\n         B     CP$FMTK\nCP$HCSCB MVC   CP@STEPN,CHSTEP          MOVE IN STEPNAME\n         MVC   CP@PSTEP,CHPROCSN        MOVE IN THE PROCSTEP NAME\n         DROP  R15                      CSCB\n          AIF  (&@@SPLVL GE 300).CP15\nCP$FMTK  LH    R0,ASCBFMCT              GET NUMBER OF SLOTS\n          AGO  .CP16\n.CP15     ANOP ,\n*CP$FMTK L     R15,ASCBOUCB\n*        ICM   R0,B'1111',OUCBSBFC-OUCB(R15)  get recent frame count\n*        BNZ   *+8                      if valid, use it\n*        L     R0,OUCBWSS-OUCB(,R15)    otherwise get last swapin count\nCP$FMTK  L     R15,ASCBRSME             -> RAX\n         L     R0,RAXFMCT-RAX(,R15)     get frame count\n.CP16     ANOP ,\n         SLL   R0,2                     GET NUMBER OF K\n         CVD   R0,QNUMWORK              GET THE DECIMAL VALUE\n         MVC   CP@SLOTS-1(6),=X'402020202120'  MOVE EDIT MASK\n         ED    CP@SLOTS-1(6),QNUMWORK+5      GET THE K\n         MVI   CP@SLOTS-1+6,C'K'             SET THE 'K'\n         MVC   CP@ATTR1,=X'1DE8'        SET OUTPUT, BRIGHT\n         MVC   CP@ATTR2,=X'1D60'        SET OUTPUT, NORMAL\n         MVC   CP@ATTR4,=X'1D60'        SET OUTPUT, NORMAL\n         MVC   CP@ATTR5,=X'1DE8'        SET OUTPUT, BRIGHT\n         CLC   =C' 0',CP@SLOTS+3        SWAPPED OUT?\n         BNE   *+10                     NO - OK\n         MVC   CP@ATTR5,=X'1D60'        SET SLOTS AS OUTPUT, NORMAL\n         MVC   CP@ATTR6,=X'1D60'        SET OUTPUT, NORMAL\n         MVI   QDATRNUM+1,5             SET # OF ATTR BYTES IN LINE\n         BAL   R14,QADDLINE             CALL THE ROUTINE\n***********************************************************************\n*                                                                     *\n*        INCREMENT TO NEXT ASID                                       *\n*                                                                     *\n***********************************************************************\nCP$NXSJB LA    R6,4(,R6)                POINT TO NEXT HAVT POINTER\n         DROP  R14,R5,R7                ASCB, SJBDSECT, ASVT\n         DROP  R13,R8,R3                WORK, SSVT, JQEDSECT\n         BCT   R2,CP$BUILD              TEST FOR NEXT HAVT POINTER\n          AIF  (&QLEVEL LT 9).CP13\n         LA    R1,16                    get out of key zero\n         QCALL AUTHFUNC\n         LA    R1,8                     reset apf if we set\n         QCALL AUTHFUNC                 go do it\n.CP13     ANOP ,\n         B     QSTOP                    END IT ALL\nCP$NHAVT QTILT '***** NO JOBS TO DISPLAY *****'\nCP$TILT  MVC   QERRMSG,QBLANK\n         MVC   QERRMSG(3),=C'***'\n         MVC   QERRMSG+4(4),QJESNAME\n         MVC   QERRMSG+9(13),=C'IS NOT UP ***'\n         QTILT *\n          AIF  (&QLEVEL LT 9).CP12\nCP$NAUTH QTILT '***** MUST BE RUNNING AUTHORIZED *****'\n.CP12     ANOP ,\n*%%%??? SET INTENSITY OF WHOLE LINE DEPENDING ON IN/OUT ???\n*%%%??? CPU PERCENT?\n         LTORG ,\n***********************************************************************\n*                                                                     *\n*        DESCRIBE ALL THE DSECTS NEEDED BY THIS MODULE                *\n*                                                                     *\n***********************************************************************\nWORK     DSECT\n         ORG   WORK+72                  SKIP OVER SAVE AREA\nCP@PLEN  DS    H                        Length of prefix\nCP@PFX   DS    CL8                      Job prefix for display\nCP@FLAG  DS    X\nCP@J      EQU   X'80'                   DISPLAY JOBS\nCP@S      EQU   X'40'                   DISPLAY STCS\nCP@T      EQU   X'20'                   DISPLAY TSUS\nCP@WORKL EQU   *-WORK\n         SPACE 2\n         QCOMMON\n         ORG   QDMSG\nCP@ASID  DS    CL4                      'XXXX'\nCP@ATTR1 DS    XL2\nCP@QUEUE DS    CL3                      'I Q' / 'O Q' / 'STC' / 'TSU'\nCP@JOBNO DS    CL5                      ' NNNN'\nCP@ATTR2 DS    XL2\nCP@JOBNM DS    CL8                      'XXXXXXXX'\nCP@ATTR4 DS    XL2\nCP@STEPN DS    CL8                      'XXXXXXXX'\n         DS    C\nCP@PSTEP DS    CL8                      'XXXXXXXX'\nCP@ATTR5 DS    XL2\nCP@SLOTS DS    CL6\nCP@ATTR6 DS    0XL2,X\nCP@TCBTM DS    CL10                     ' NN,NNN.NN'\nCP@TCB@S DC    C'S'\nCP@SRBTM DS    CL10                     ' NN,NNN.NN'\nCP@SRB@S DC    C'S'\nCP@IOREQ DS    CL10                     ' N,NNN,NNN'\n         SPACE 3\n         Q$SVT\n         Q$HCCT\n         Q$HASB\n         Q$SJB\n         Q$JQE\n         QZASCB\n         QZASVT\n         QZCSCB\n         QZCVT\n         QZOUCB\n         QZRAX\n         QZSSCT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "Q#CT": {"ttr": 4359, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "* GENQHELP was run on MONDAY     Jan 23, 1989  (89.023)  at 23:00:27\n* LDW.TEXT(QCHGS) - last updated 23Feb83\nCHGSTEXT CSECT\n         DC    A(CH#TEXT)\n         DC    A(CH#INT)\nCH#TEXT  DC    AL1(000,0,00),C' '\n         DC    AL1(080,0,02),X'1DE8',C'****** Feb83 *******************$\n               *********************************************',X'1D60'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(000,0,00),C' '\n         DC    AL1(041,0,02),C' Add held dataset count to',X'1DE8',C'\"D$\n               H\"',X'1D60',C'display.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(066,1,06),C' Delete',X'1DE8',C'\"DHX\"',X'1D60',C'subc$\n               ommand, replaced by',X'1DE8',C'\"ALL\"',X'1D60',C'keyword $\n               on',X'1DE8',C'\"DH\".',X'1D60'\n         DC    AL1(000,1,00),C' '\n         DC    AL1(034,1,02),C' Totally redesigned',X'1DE8',C'\"XJ\"',X'1$\n               D60',C'display.'\n         DC    AL1(000,1,00),C' '\n         DC    AL1(000,0,00),C' '\n         DC    AL1(000,0,00),C' '\n         DC    AL1(000,0,00),C' '\n         DC    AL1(080,0,02),X'1DE8',C'****** Oct82 to Jan83 **********$\n               *********************************************',X'1D60'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(000,0,00),C' '\n         DC    AL1(070,0,04),C' Add',X'1DE8',C'\"CHGS\"',X'1D60',C'subcom$\n               mand to list change history of the',X'1DE8',C'QUEUE',X'1$\n               D60',C'command.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(080,0,02),C' Headers and much information changed to$\n               ',X'1DE8',C'lower case',X'1D60',C'display (shows more cl$\n               ass).'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(068,0,00),C' Display jobid, dest, (and linecount if $\n               > 99999) in high intensity on'\n         DC    AL1(019,0,00),C'    status displays.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(059,0,02),C' Change',X'1DE8',C'\"JD\"',X'1D60',C'displ$\n               ay to use high intensity and lower case.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(071,0,02),C' Don''t clear the screen when displaying$\n                an',X'1DE8',C'error message,',X'1D60',C'because many'\n         DC    AL1(070,0,00),C'    times the information required to co$\n               rrectly re-enter the subcommand'\n         DC    AL1(037,0,00),C'    frequently is still on the screen.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(074,0,02),X'1DE8',C'\"DD\"',X'1D60',C'subcommand re-wr$\n               itten to be much more efficient when there are many'\n         DC    AL1(029,0,00),C'    sysout datasets for a job.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(047,1,02),C' Don''t skip any DSID''s if',X'1DE8',C'Q$\n               INT',X'1D60',C'DEBUG=80000000.'\n         DC    AL1(000,1,00),C' '\n         DC    AL1(072,0,02),C' Columns interchanged in',X'1DE8',C'\"DD\"$\n               ',X'1D60',C'subcommand display to put the most useful'\n         DC    AL1(065,0,00),C'    information on the left, and DSID di$\n               splayed in high intensity.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(049,0,04),C' Add',X'1DE8',C'TSO',X'1D60',C'operand t$\n               o',X'1DE8',C'\"*\"',X'1D60',C'(reprompt) subcommand.'\n         DC    AL1(066,1,06),C' Add',X'1DE8',C'CMD',X'1D60',C'operand t$\n               o reprompt last',X'1DE8',C'MVS',X'1D60',C'or',X'1DE8',C'$\n               JES2',X'1D60',C'command issued.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(055,0,04),C' Add support for',X'1DE8',C'keyword',X'1$\n               D60',C'and',X'1DE8',C'reserved word',X'1D60',C'operands.$\n               '\n         DC    AL1(000,0,00),C' '\n         DC    AL1(074,0,04),C' Allow',X'1DE8',C'\"SLOG sid\"',X'1D60',C'$\n               to select the active',X'1DE8',C'SYSLOG',X'1D60',C'for a $\n               different system in'\n         DC    AL1(032,0,00),C'    a multi-access-spool complex.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(057,1,02),C' Translate',X'1DE8',C'QSE',X'1D60',C'typ$\n               e sid''s to user-friendly system names.'\n         DC    AL1(000,1,00),C' '\n         DC    AL1(077,1,00),C' Check that checkpoint file in use is of$\n                the type the module is assembled for.'\n         DC    AL1(000,1,00),C' '\n         DC    AL1(061,1,02),C' Add',X'1DE8',C'\"LTXT\"',X'1D60',C'subcom$\n               mand to dump a job''s internal text in hex.'\n         DC    AL1(000,1,00),C' '\n         DC    AL1(073,1,04),C' Change',X'1DE8',C'\"CONS\"',X'1D60',C'sub$\n               command to link to',X'1DE8',C'DCMS CONS.',X'1D60',C' Thi$\n               s was necessary to'\n         DC    AL1(038,1,02),C'    support',X'1DE8',C'SP1.3',X'1D60',C'$\n               in a timely manner.'\n         DC    AL1(000,1,00),C' '\n         DC    AL1(055,0,04),X'1DE8',C'\"MODE\"',X'1D60',C' subcommand no$\n               w uses',X'1DE8',C'keyword=value',X'1D60',C'operands.'\n         DC    AL1(054,1,02),C'    Privileged things moved to new',X'1D$\n               E8',C'\"QINT\"',X'1D60',C'subcommand.'\n         DC    AL1(045,0,02),C'    Add',X'1DE8',C'STATUS=, FORM=, FCB=,$\n                UCS=',X'1D60',C'operands.'\n         DC    AL1(072,0,02),C'    Add',X'1DE8',C'NOVERIFY,',X'1D60',C'$\n               which will suppress the verify message for jobs owned'\n         DC    AL1(018,0,00),C'       by the user.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(078,0,08),C' Add interface to',X'1DE8',C'SPF EDIT',X$\n               '1D60',C'and',X'1DE8',C'BROWSE',X'1D60',C'if',X'1DE8',C'$\n               QUEUE',X'1D60',C'is invoked as a',X'1DE8',C'PGM',X'1D60'$\n               ,C'from'\n         DC    AL1(019,0,02),C'    an',X'1DE8',C'SPF panel.',X'1D60'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(067,0,02),C' Add',X'1DE8',C'\"REDISP\" (\"RD\")',X'1D60'$\n               ,C'subcommand to resume display of the currently'\n         DC    AL1(028,0,00),C'    selected spooled dataset.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(060,0,06),C' Add',X'1DE8',C'\"DN\"',X'1D60',C'subcomma$\n               nd to display',X'1DE8',C'ALL',X'1D60',C'jobs in',X'1DE8'$\n               ,C'ALL',X'1D60',C'queues.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(036,0,04),C' Change',X'1DE8',C'\"HO\"',X'1D60',C'subco$\n               mmand to',X'1DE8',C'\"DH\".',X'1D60'\n         DC    AL1(034,1,04),C'    And change',X'1DE8',C'\"XHO\"',X'1D60'$\n               ,C'to',X'1DE8',C'\"DHX\".',X'1D60'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(023,0,02),X'1DE8',C'\"PRINT\"',X'1D60',C'enhancements:$\n               '\n         DC    AL1(052,0,02),C'   ',X'1DE8',C'\"PRINT ON\"',X'1D60',C'no $\n               longer prints the current screen.'\n         DC    AL1(053,0,04),C'    Add',X'1DE8',C'UCS=, FCB=, FORM=',X'$\n               1D60',C'operands to',X'1DE8',C'\"PRINT ON\".',X'1D60'\n         DC    AL1(063,0,06),C'    Change',X'1DE8',C'dest',X'1D60',C'op$\n               erand from',X'1DE8',C'third positional',X'1D60',C'to',X'$\n               1DE8',C'keyword.',X'1D60'\n         DC    AL1(076,0,02),C'    Add',X'1DE8',C'\"COPY\" (\"CY\")',X'1D60$\n               ',C'subcommand to print all or part of a spooled dataset$\n               .'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(048,0,02),C' Display grand total of output lines for$\n               ',X'1DE8',C'\"DQ\".',X'1D60'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(050,1,04),C' Add',X'1DE8',C'HCT',X'1D60',C'subcomman$\n               d to hex dump the',X'1DE8',C'$SAVEAREA.',X'1D60'\n         DC    AL1(000,1,00),C' '\n         DC    AL1(067,1,02),C' ADD',X'1DE8',C'CKPT',X'1D60',C'subcomma$\n               nd to hex dump the whole checkpoint buffer area.'\n         DC    AL1(000,1,00),C' '\n         DC    AL1(045,1,04),C' Add',X'1DE8',C'QCMN',X'1D60',C'subcomma$\n               nd to hex dump',X'1DE8',C'QCOMMON.',X'1D60'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(000,0,00),C' '\n         DC    AL1(000,0,00),C' '\n         DC    AL1(080,0,02),X'1DE8',C'****** Jun81 to Sep82 **********$\n               *********************************************',X'1D60'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(000,0,00),C' '\n         DC    AL1(053,0,06),X'1DE8',C'\"DU\"',X'1D60',C'renamed to',X'1D$\n               E8',C'\"DEV\",',X'1D60',C'and, it',X'1DE8',C'FINALLY',X'1D$\n               60',C'works!!!'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(025,0,02),X'1DE8',C'\"MODE FANUM\"',X'1D60',C'now work$\n               s.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(071,0,02),C' Add support for',X'1DE8',C'attention',X$\n               '1D60',C'to interrupt currently executing subcommand'\n         DC    AL1(048,0,02),C'    without dropping all the way out of'$\n               ,X'1DE8',C'QUEUE.',X'1D60'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(043,0,02),C' Add support for',X'1DE8',C'non-fullscre$\n               en',X'1D60',C'terminals.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(029,0,04),X'1DE8',C'\"DQ\"',X'1D60',C'now gets',X'1DE8$\n               ',C'ALL',X'1D60',C'queues.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(061,0,06),C' Add job',X'1DE8',C'start date/time',X'1$\n               D60',C'and',X'1DE8',C'class',X'1D60',C'to',X'1DE8',C'ini$\n               tiator',X'1D60',C'display.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(043,0,02),C' Support',X'1DE8',C'3278-3, 3278-4, 3278$\n               -5',X'1D60',C'terminals.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(043,1,02),X'1DE8',C'\"XB\"',X'1D60',C'now uses hex dum$\n               p format by default.'\n         DC    AL1(000,1,00),C' '\n         DC    AL1(061,0,00),C' Expand DSID table if it''s too small an$\n               d storage is available.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(076,0,06),C' Change default column from',X'1DE8',C'1$\n               0',X'1D60',C'to',X'1DE8',C'3',X'1D60',C'for',X'1DE8',C'J$\n               CL,',X'1D60',C'to show statement numbers.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(053,0,02),C' Fix bugs in queue position for',X'1DE8'$\n               ,C'\"STATUS\"',X'1D60',C'subcommand.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(019,0,02),C' Add',X'1DE8',C'ACF2',X'1D60',C'support.$\n               '\n         DC    AL1(000,0,00),C' '\n         DC    AL1(086,0,08),C' Display',X'1DE8',C'STC',X'1D60',C'and',$\n               X'1DE8',C'TSU',X'1D60',C'jobnumbers with',X'1DE8',C'\"S\"'$\n               ,X'1D60',C'or',X'1DE8',C'\"T\"',X'1D60',C'in front, instea$\n               d of displaying'\n         DC    AL1(080,0,02),C'    JES2''s internal job number, which ($\n               for non-SP JES2) is',X'1DE8',C'10000+n or 20000+n.',X'1D$\n               60'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(062,0,02),C' Add support for user',X'1DE8',C'profile$\n               s',X'1D60',C'to set internal QUEUE options.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(058,0,02),C' Support default column number for',X'1D$\n               E8',C'\"COL\"',X'1D60',C'with no operand.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(071,0,02),C' Add',X'1DE8',C'\"PFK\"',X'1D60',C'subcomm$\n               and to display or change current PF key definitions.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(054,0,02),C' Add',X'1DE8',C'\"LRMT\"',X'1D60',C'subcom$\n               mand to list remote and node names.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(075,0,02),C' Change default column number for',X'1DE$\n               8',C'SYSLOG',X'1D60',C'from 1 to 6 (start of timestamp).$\n               '\n         DC    AL1(000,0,00),C' '\n         DC    AL1(048,0,02),C' Display total output lines per class in$\n               ',X'1DE8',C'\"DQ\".',X'1D60'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(076,1,04),C' Add',X'1DE8',C'\"LBLK\"',X'1D60',C'subcom$\n               mand to list',X'1DE8',C'HASPACE',X'1D60',C'resident cont$\n               rol blocks for a job.'\n         DC    AL1(000,1,00),C' '\n         DC    AL1(076,1,04),C' Add',X'1DE8',C'\"LSYS\"',X'1D60',C'subcom$\n               mand to list status of all systems in a',X'1DE8',C'M.A.S$\n               .',X'1D60',C'complex.'\n         DC    AL1(000,1,00),C' '\n         DC    AL1(000,0,00),C' '\n         DC    AL1(000,0,00),C' '\n         DC    AL1(080,0,02),X'1DE8',C'****** Sep80 to May81 **********$\n               *********************************************',X'1D60'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(000,0,00),C' '\n         DC    AL1(078,0,00),C' If a single character is entered in pla$\n               ce of a jobid, it is prefixed with your'\n         DC    AL1(082,0,04),C'    userid.  For example, if',X'1DE8',C'$\n               \"USER1\"',X'1D60',C'enters',X'1DE8',C'\"JLOG A\",',X'1D60',$\n               C'QUEUE will treat it as if'\n         DC    AL1(081,0,02),C'   ',X'1DE8',C'\"JLOG USER1A\"',X'1D60',C'$\n               was entered.  A consequence of this is that to reference$\n                a job'\n         DC    AL1(074,0,04),C'    by number whose number is',X'1DE8',C$\n               '1',X'1D60',C'thru',X'1DE8',C'9,',X'1D60',C'a leading ze$\n               ro must be entered.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(073,1,04),C' Add',X'1DE8',C'\"JX\"',X'1D60',C'subcomma$\n               nd to display additional',X'1DE8',C'JCT',X'1D60',C'field$\n               s (mostly in hex).'\n         DC    AL1(000,1,00),C' '\n         DC    AL1(053,1,02),C' Add',X'1DE8',C'\"MCS\"',X'1D60',C'subcomm$\n               and to display operator''s console.'\n         DC    AL1(000,1,00),C' '\n         DC    AL1(049,0,02),C' Add',X'1DE8',C'\"DU\"',X'1D60',C'subcomma$\n               nd to display jobs on devices.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(044,0,02),C' Add',X'1DE8',C'\"MODE\"',X'1D60',C'subcom$\n               mand to set option flags:'\n         DC    AL1(050,0,04),C'   ',X'1DE8',C'''FANUM''',X'1D60',C' - d$\n               isplay line numbers on',X'1DE8',C'FINDALL',X'1D60'\n         DC    AL1(040,0,02),C'   ',X'1DE8',C'''SHOWCC''',X'1D60',C'- d$\n               isplay carriage control'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(055,0,04),C' Add',X'1DE8',C'\"JNEWS\"',X'1D60',C'subco$\n               mmand to display current',X'1DE8',C'JESNEWS.',X'1D60'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(020,1,02),X'1DE8',C'\"XB\"',X'1D60',C'improvements:'\n         DC    AL1(049,1,02),C'   ',X'1DE8',C'''*''',X'1D60',C'operand $\n               to redisplay last selected block'\n         DC    AL1(056,1,02),C'   ',X'1DE8',C'''C''',X'1D60',C'operand $\n               to display block in pure character form'\n         DC    AL1(045,1,00),C'    Validity check operand to insure val$\n               id hex'\n         DC    AL1(015,1,02),C'   ',X'1DE8',C'SYNAD',X'1D60',C'exit'\n         DC    AL1(000,1,00),C' '\n         DC    AL1(020,1,02),X'1DE8',C'\"XJ\"',X'1D60',C'improvements:'\n         DC    AL1(053,1,02),C'    Also display characteristic and chec$\n               kpoint',X'1DE8',C'JOEs',X'1D60'\n         DC    AL1(049,1,00),C'    Display everything in dump format (c$\n               har + hex)'\n         DC    AL1(000,1,00),C' '\n         DC    AL1(039,0,02),C' Display jobid in',X'1DE8',C'\"not found\"$\n               ',X'1D60',C'message.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(070,0,02),C' Add second operand to',X'1DE8',C'\"AO\"/\"$\n               DO\"',X'1D60',C'to select destination.  (Default for'\n         DC    AL1(055,0,06),C'   ',X'1DE8',C'\"AO\"',X'1D60',C'is logon $\n               dest, default for',X'1DE8',C'\"DO\"',X'1D60',C'is',X'1DE8'$\n               ,C'ALL.)',X'1D60'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(041,0,06),C' Change',X'1DE8',C'PF9/PF21',X'1D60',C'f$\n               rom',X'1DE8',C'\"DO\"',X'1D60',C'to',X'1DE8',C'\"AO\".',X'1D$\n               60'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(057,0,04),C' Now can find jobs on',X'1DE8',C'misc qu$\n               eues,',X'1D60',C'such as',X'1DE8',C'\"READING\".',X'1D60'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(078,0,02),X'1DE8',C'\"Enter\"',X'1D60',C'at bottom of $\n               dataset stays at bottom (useful if dataset is currently'$\n\n         DC    AL1(034,0,00),C'    being written, such as SYSLOG).'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(048,0,04),X'1DE8',C'''ST *''',X'1D60',C'will reset s$\n               earch key to',X'1DE8',C'TSO userid.',X'1D60'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(045,0,02),X'1DE8',C'\"ST\"/\"DJ\"',X'1D60',C'now work wi$\n               th job number operand.'\n         DC    AL1(018,1,02),C'    (Also',X'1DE8',C'\"XJ\".)',X'1D60'\n         DC    AL1(000,1,00),C' '\n         DC    AL1(056,1,02),X'1DE8',C'\"XB\"',X'1D60',C'now displays the$\n                volser that the block came from.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(057,0,02),X'1DE8',C'\"SAVE\"',X'1D60',C'now says ''SAV$\n               ED'', instead of re-invoking LISTDS.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(076,0,04),C' Change',X'1DE8',C'\"B\"',X'1D60',C'operan$\n               d of',X'1DE8',C'\"DC\"',X'1D60',C'to display both batch jo$\n               bs and started tasks,'\n         DC    AL1(082,0,06),C'    add',X'1DE8',C'\"J\"',X'1D60',C'operan$\n               d to display only jobs.  Change default to',X'1DE8',C'\"B$\n               \"',X'1D60',C'(from',X'1DE8',C'\"A\").',X'1D60'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(025,0,02),C' Add I/O count to',X'1DE8',C'\"DC\".',X'1D$\n               60'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(072,0,00),C' Add print screen feature (actually, thi$\n               s was lifted from a later version'\n         DC    AL1(034,0,02),C'    of QUEUE obtained from',X'1DE8',C'TR$\n               W).',X'1D60'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(030,0,02),X'1DE8',C'NJE',X'1D60',C'now supported (so$\n               rt of).'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(000,0,00),C' '\n         DC    AL1(000,0,00),C' '\n         DC    AL1(080,0,02),X'1DE8',C'****** Jan80 to Aug80 **********$\n               *********************************************',X'1D60'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(000,0,00),C' '\n         DC    AL1(043,0,02),C' Screen layout redesigned to be like',X'$\n               1DE8',C'SPF.',X'1D60'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(062,0,02),X'1DE8',C'\"*\"',X'1D60',C'subcommand to rep$\n               rompt with the last entered subcommand.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(048,0,02),C' Use',X'1DE8',C'VTAM macros',X'1D60',C'f$\n               or correct screen management.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(032,0,02),C' Display',X'1DE8',C'SPUN',X'1D60',C'data$\n               sets on \"DD\".'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(053,1,02),C' Allow privileged users to issue',X'1DE8$\n               ',C'operator commands.',X'1D60'\n         DC    AL1(000,1,00),C' '\n         DC    AL1(069,0,02),X'1DE8',C'\"JI\"',X'1D60',C'subcommand to di$\n               splay detailed information for a specific job.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(057,0,02),X'1DE8',C'\"STatus\"',X'1D60',C'subcommand r$\n               emembers the last used search key.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(063,1,02),C' Automatically privilege the user if he $\n               has',X'1DE8',C'\"OPER\" authority.',X'1D60'\n         DC    AL1(000,1,00),C' '\n         DC    AL1(042,1,04),C' Add',X'1DE8',C'SYNAD',X'1D60',C'routine$\n                for',X'1DE8',C'\"XB\"',X'1D60',C'subcommand.'\n         DC    AL1(000,1,00),C' '\n         DC    AL1(076,0,02),C' Add',X'1DE8',C'\"TSO\"',X'1D60',C'subcomm$\n               and to allow any TSO command to be issued while in QUEUE$\n               .'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(060,0,00),C' Re-execute last inquiry subcommand afte$\n               r action subcommands.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(055,0,06),C' Add',X'1DE8',C'disposition',X'1D60',C'a$\n               nd',X'1DE8',C'\"NORLSE\"',X'1D60',C'options for',X'1DE8',C$\n               '\"SAVE\".',X'1D60'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(077,0,02),C' Don''t write trailing blanks, to improv$\n               e response time on',X'1DE8',C'remote terminals.',X'1D60'$\n\n         DC    AL1(000,0,00),C' '\n         DC    AL1(055,0,02),C' Greatly expanded',X'1DE8',C'\"HELP\",',X'$\n               1D60',C'including table of contents.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(077,0,08),C' Combine',X'1DE8',C'\"DQ\"',X'1D60',C'and'$\n               ,X'1DE8',C'\"DF\"',X'1D60',C'into',X'1DE8',C'\"DQ\".',X'1D60$\n               ',C' Add',X'1DE8',C'% spool',X'1D60',C'utilization to di$\n               splay.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(071,0,02),C' Allow',X'1DE8',C'\"*\"',X'1D60',C'or blan$\n               k to refer to last-referenced job (blank not allowed'\n         DC    AL1(024,0,00),C'    for action commands).'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(029,1,02),C' Improve',X'1DE8',C'\"XJ\"',X'1D60',C'scre$\n               en layout.'\n         DC    AL1(000,1,00),C' '\n         DC    AL1(065,0,02),C' Allow delimeters to be omitted for',X'1$\n               DE8',C'\"FIND\"',X'1D60',C'if first character is'\n         DC    AL1(055,0,00),C'    alphanumeric and no blanks are in th$\n               e search string.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(084,0,08),C' Add',X'1DE8',C'\"LEFT\"',X'1D60',C'and',X$\n               '1DE8',C'\"RIGHT\"',X'1D60',C'subcommands.  Change',X'1DE8$\n               ',C'PF10/22',X'1D60',C'and',X'1DE8',C'PF11/23',X'1D60',C$\n               'definitions.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(037,0,02),C' Add',X'1DE8',C'\"PJ\"',X'1D60',C'subcomma$\n               nd to purge a job.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(082,1,04),C' Add',X'1DE8',C'\"HJ\"',X'1D60',C'and',X'1$\n               DE8',C'\"AJ\"',X'1D60',C'subcommands (for privileged users$\n               ) to hold and release jobs.'\n         DC    AL1(000,1,00),C' '\n         DC    AL1(040,0,02),C' Add',X'1DE8',C'\"RO\"',X'1D60',C'subcomma$\n               nd to re-route a job.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(053,1,02),C' Add capability for using a different JE$\n               S2',X'1DE8',C'COMCHAR.',X'1D60'\n         DC    AL1(000,1,00),C' '\n         DC    AL1(059,0,00),C' Invalid subcommand now says so, instead$\n                of invoking \"HELP\".'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(071,0,10),C' Allow',X'1DE8',C'\"M\"',X'1D60',C'and',X'$\n               1DE8',C'\"H\"',X'1D60',C'as operands of',X'1DE8',C'\"UP\"',X$\n               '1D60',C'and',X'1DE8',C'\"DOWN\"',X'1D60',C'(like',X'1DE8'$\n               ,C'SPF).',X'1D60'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(058,0,02),C' Fix bug so',X'1DE8',C'\"AO\"',X'1D60',C'd$\n               oesn''t display held jobs (it used to!).'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(050,0,04),C' Display',X'1DE8',C'programmer name',X'1$\n               D60',C'for',X'1DE8',C'\"DA\", \"DS\", \"DT\".',X'1D60'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(033,0,02),C' Display output',X'1DE8',C'UCS, FCB, FOR$\n               M.',X'1D60'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(053,0,02),C' Display',X'1DE8',C'RJE dest',X'1D60',C'$\n               as a symbolic name, if one exists.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(044,0,02),C' Recognize the',X'1DE8',C'external write$\n               r',X'1D60',C'device type.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(039,0,02),C' Detail the hold type',X'1DE8',C'(HOLD/A$\n               LL/DUP).',X'1D60'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(080,0,04),C' Default to the active',X'1DE8',C'SYSLOG$\n               ',X'1DE8',C'if no operand is given for the',X'1DE8',C'\"S$\n               L\"',X'1D60',C'subcommand.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(050,0,02),C' Now can find jobs on conversion',X'1DE8$\n               ',C'(JCLHOLD)',X'1D60',C'queue.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(045,0,04),C' Display',X'1DE8',C'\"END OF DATA\"',X'1D6$\n               0',C'in',X'1DE8',C'high intensity.',X'1D60'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(072,0,04),C' Add fields to',X'1DE8',C'\"DD\"',X'1D60',$\n               C'display -',X'1DE8',C'PGMNAME, PROCNAME, STEPNAME, PROC$\n               STEP,',X'1D60'\n         DC    AL1(035,0,02),C'   ',X'1DE8',C'HOLD indicator, record co$\n               unt.',X'1D60'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(076,0,04),C' Display',X'1DE8',C'\"*MORE*\"',X'1D60',C'$\n               in upper right corner, instead of',X'1DE8',C'\"+\"',X'1D60$\n               ',C'near lower right.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(076,0,02),C' Identify output that is not actually pr$\n               inting because it was',X'1DE8',C'INTerrupted.',X'1D60'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(049,0,02),C' Display line count in',X'1DE8',C'\"K\"',X$\n               '1D60',C'if too big for field.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(056,1,04),C' Add',X'1DE8',C'\"X\"',X'1D60',C'option to$\n               ',X'1DE8',C'\"XB\"',X'1D60',C'to display block in pure hex$\n               .'\n         DC    AL1(000,1,00),C' '\n         DC    AL1(062,0,06),C' Change qualifier for',X'1DE8',C'\"SAVE\"'$\n               ,X'1D60',C'from',X'1DE8',C'''.DATA''',X'1D60',C'to',X'1D$\n               E8',C'''.OUTLIST''.',X'1D60'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(053,0,04),C' Change',X'1DE8',C'\"XI\"',X'1D60',C'to',X$\n               '1DE8',C'\"IN\"',X'1D60',C'and allow any user to use it.'\n         DC    AL1(067,1,00),C'    (For non-privileged users, sensitive$\n                information is suppressed -'\n         DC    AL1(051,1,00),C'    current jobclass settings, inactive $\n               initiators).'\n         DC    AL1(000,1,00),C' '\n         DC    AL1(064,0,02),C' Fix',X'1DE8',C'\"DC\"',X'1D60',C'so it wo$\n               rks right, add ASID and I/O count to display.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(050,0,00),C' Fix problems with sysout manipulation s$\n               ubcommands.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(066,0,02),C' Frame informational messages with',X'1D$\n               E8',C'''===''',X'1D60',C'to distinguish them from'\n         DC    AL1(029,0,02),C'    error messages',X'1DE8',C'(''***'').$\n               ',X'1D60'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(025,1,04),C' Change',X'1DE8',C'\"XD\"',X'1D60',C'to',X$\n               '1DE8',C'\"XL\".',X'1D60'\n         DC    AL1(000,1,00),C' '\n         DC    AL1(047,1,02),X'1DE8',C'\"XB\"',X'1D60',C'- display block $\n               address and HASPACE DSN.'\n         DC    AL1(000,1,00),C' '\n         DC    AL1(051,0,04),C' Display',X'1DE8',C'JCL, JOBLOG, JOBMSG'$\n               ,X'1D60',C'on',X'1DE8',C'\"DD\"',X'1D60',C'subcommand.'\n         DC    AL1(062,1,02),C'    (Others also for privileged users: '$\n               ,X'1DE8',C'JCLIN, JCLTXT, SWA).',X'1D60'\n         DC    AL1(000,0,00),C' '\n         DC    X'FF'                    Flag end of screen\n         EJECT ,\nCH#INT   DC    AL1(000,0,00),C' '\n         DC    AL1(080,0,02),X'1DE8',C'****** Internal changes made Feb$\n               83 ******************************************',X'1D60'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(000,0,00),C' '\n         DC    AL1(079,0,00),C' HELP and CHGS text moved to separate lo$\n               ad modules, and only loaded when needed.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(000,0,00),C' '\n         DC    AL1(000,0,00),C' '\n         DC    AL1(080,0,02),X'1DE8',C'****** Internal changes made fro$\n               m Oct82 to Jan83 ****************************',X'1D60'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(000,0,00),C' '\n         DC    AL1(075,0,02),C' Support for',X'1DE8',C'JES2/SP.',X'1D60$\n               ',C' Some of this support was lifted from other versions$\n               '\n         DC    AL1(047,0,00),C'    of QUEUE - Mike Stein''s, and Jack S$\n               chudel''s.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(078,0,02),X'1DE8',C'APF',X'1D60',C'routine added to $\n               test, and if an installation SVC is supplied, set/reset'$\n\n         DC    AL1(073,0,00),C'    APF authorization.  If the SVC is us$\n               ed, APF authorized subcommands may'\n         DC    AL1(066,0,00),C'    be executed even if QUEUE is not inv$\n               oked authorized.  Note that'\n         DC    AL1(070,0,02),C'    installation of the SVC results in a$\n                possible',X'1DE8',C'integrity',X'1D60',C'exposure,'\n         DC    AL1(032,0,02),C'    but it sure is',X'1DE8',C'convenient$\n               .',X'1D60'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(069,0,00),C' Add support for variable length workare$\n               as, to get some localized data'\n         DC    AL1(018,0,00),C'    out of QCOMMON.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(024,0,00),C' \u00ac\u00ac\u00ac More data goes here.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(000,0,00),C' '\n         DC    AL1(000,0,00),C' '\n         DC    AL1(080,0,02),X'1DE8',C'****** Internal changes made fro$\n               m Jun81 to Sep82 ****************************',X'1D60'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(000,0,00),C' '\n         DC    AL1(080,0,04),C' Pick up',X'1DE8',C'SIDs',X'1D60',C'from$\n               ',X'1DE8',C'QSE''s,',X'1D60',C'so that they don''t need $\n               to be specified in QCOMMON.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(076,0,04),C' Validity check',X'1DE8',C'JCT',X'1D60',$\n               C'and',X'1DE8',C'IOT',X'1D60',C'control block id''s, to $\n               make Mike Stein happy.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(075,0,00),C' Source split up into separate member fo$\n               r each routine, with mnemonic names.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(054,0,02),C' Use',X'1DE8',C'$LRC',X'1D60',C'Dsect to$\n                describe format of SPOOL datasets.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(064,0,00),C' Don''t let unprivileged users read the $\n               checkpoint file too often.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(075,0,02),C' Gather statistics on HASPCKPT/HASPACE I$\n               /O.  Display in',X'1DE8',C'\"MODE\"',X'1D60',C'subcommand.$\n               '\n         DC    AL1(041,0,00),C'    (Only displayed for privileged users$\n               .)'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(071,0,02),C' Make',X'1DE8',C'\"CPU\"',X'1D60',C'subcom$\n               mand real slow, because there are better ways to get'\n         DC    AL1(040,0,00),C'    this information than by using QUEUE$\n               .'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(063,0,02),C' Add',X'1DE8',C'HEXFMT',X'1D60',C'common$\n                routine to generate a hex dump of any data.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(068,0,00),C' Bypass HASPACE read if block to be read$\n                is a dataset block and it is'\n         DC    AL1(035,0,00),C'    the one currently in the buffer.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(024,0,00),C' \u00ac\u00ac\u00ac More data goes here.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(000,0,00),C' '\n         DC    AL1(000,0,00),C' '\n         DC    AL1(080,0,02),X'1DE8',C'****** Internal changes made fro$\n               m Sep80 to May81 ****************************',X'1D60'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(000,0,00),C' '\n         DC    AL1(074,0,04),C' Move code for',X'1DE8',C'\"JLOG\", \"JMSG\"$\n               , \"JCL\"',X'1D60',C'into',X'1DE8',C'\"LIST\",',X'1D60',C'el$\n               iminating 3 CSECTs.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(080,0,04),C' Restrict',X'1DE8',C'\"XB\"',X'1D60',C'to $\n               systems programmers, since JCTs may contain',X'1DE8',C'R$\n               ACF',X'1D60',C'passwords.'\n         DC    AL1(061,0,02),C'    (Buy',X'1DE8',C'ACF2',X'1D60',C'and $\n               you don''t have stupid problems like this!)'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(063,0,02),C' All check of access to jobs is now cent$\n               ralized in',X'1DE8',C'\"FINDJOB\".',X'1D60'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(061,0,00),C' QUEUE may now be \"called\" (useful when $\n               testing new versions).'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(036,0,00),C' Only expand blurb once per assembly.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(077,0,02),C' Drop support for all JES2''s before',X'$\n               1DE8',C'AZ27300',X'1D60',C'(QLEVEL=1 and QLEVEL=2 droppe$\n               d).'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(067,0,00),C' Display device id in hex if unable to d$\n               etermine actual device type.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(000,0,00),C' '\n         DC    AL1(000,0,00),C' '\n         DC    AL1(080,0,02),X'1DE8',C'****** Internal changes made fro$\n               m Jan80 to Aug80 ****************************',X'1D60'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(000,0,00),C' '\n         DC    AL1(072,0,02),C' Eliminate separate',X'1DE8',C'QUEUECMN'$\n               ,X'1D60',C'load module - getmain a work area instead.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(024,0,00),C' Use more private macros.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(033,0,00),C' Fix TGET code bug due to TCLEARQ.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(049,0,00),C' Allow QUEUE to assembled in one piece i$\n               f desired.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(054,0,00),C' Allow selection of alternate DSN prefix$\n                at invocation.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(079,0,00),C' Use UNIT=SYSALLDA so CKPT unit type doe$\n               s not need to be given in QCOMMON macro.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(071,0,00),C' Redesign HASPACE/HASPCKPT logic - mark $\n               \"not in use\" at exit, don''t free'\n         DC    AL1(057,0,00),C'    at entry, re-use if present.  Don''t$\n                use fixed DDNAMEs.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(055,0,00),C' Use HASP symbolics && DSECTs instead of$\n                much hardcoding.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(072,0,02),X'1DE8',C'PARSE',X'1D60',C'improvements, f$\n               or example, privileged subcommands no longer need'\n         DC    AL1(024,0,02),C'    to start with',X'1DE8',C'''X''.',X'1$\n               D60'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(066,0,02),X'1DE8',C'PFK',X'1D60',C'support is now st$\n               andard (no longer an assembly time option).'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(054,0,06),X'1DE8',C'XDS',X'1D60',C'routine (Q22) del$\n               eted by changing',X'1DE8',C'XD',X'1D60',C'to',X'1DE8',C'$\n               XL.',X'1D60'\n         DC    AL1(000,0,00),C' '\n         DC    X'FF'                    Flag end of screen\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "Q#DD": {"ttr": 4616, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x053\\x00\\x00\\x00\\x82#/\\x00\\x92\\x01O\\x19U\\x03\\xf7\\x02\\t\\x03^\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "05.51", "flags": 0, "createdate": "1982-08-20T00:00:00", "modifydate": "1992-01-14T19:55:00", "lines": 1015, "newlines": 521, "modlines": 862, "user": "LDW"}, "text": "         TITLE '--- QUEUE--DDNAME -- LIST DDNMS && DSIDS FOR A JOB ---'\n*---------------------------------------------------------------------*\n*                                                                     *\n*   DDNAME - List DDnames and DSIDs for a job                         *\n*                                                                     *\n*   Updates:                                                          *\n*      14Jan92  LDW  Fix bug inserted by previous update              *\n*                    Fix bug displaying spin stepnames                *\n*                    Fiddle with DD@ENT                               *\n*      06Jan92  LDW  Correct assembly error with PDB1PSO check under  *\n*                       JES2 V4                                       *\n*      05Aug91  LDW  Integrate GLA fixes below (with minor changes,   *\n*                       except for DSID=0 problem fixed my way)       *\n*     (17Jul91) GLA  Day one bug handling *.step.pstep.ddn            *\n*     (10Jul91) GLA  Handle DynAlloc sysout that is not spin          *\n*                    Eliminate problem doing PRINT/COPY/SPIN of       *\n*                       wrong dataset from commandline after DD       *\n*                       command issued                                *\n*                    Correct display of DSID=0 datasets               *\n*      15Mar91  LDW  Adjust Pgm= and PDBFLAG1 display lines for ISPF  *\n*      20Dec90  LDW  Simplify previous update                         *\n*      28Nov90  EMS  Updates for SP410                                *\n*       7Aug90  EMS  Updates for SP313                                *\n*      20Jun90  LDW  Display 6 digit DSID                             *\n*      26Feb90  LDW  Fix typo in conditional assembly                 *\n*      25Dec89  LDW  Q$KEYS -> QZKEYS,  Q$TEXT -> QZTEXT              *\n*      12Dec89  LDW  Make OACFSORT expansion conditional (for Doron)  *\n*      23Nov89  LDW  Remove unnecessary Q$JCT                         *\n*      27Apr89  EMS  Updates for SP311                                *\n*      30Jan88  LDW  Fix dsid table too small problem, possibly       *\n*                       introduced by 9 July 87 update                *\n*      31Dec87  LDW  Fix PRINT GEN/NOGEN screwup in previous update   *\n*       9Aug87  EMS  Fix for procname = proc bug                      *\n*                    Fix for OACFSORT 0C3 abends                      *\n*                    Update for TERM=TS,SYSOUT= for TSU's             *\n*                    Fix for SYSOUT override bug                      *\n*       9Jul87  EMS  Use new table (QDSTART instead of QCSTART)       *\n*                    Update for QSORT macro changes                   *\n*                    Fix for tweaked line commands after \"s\" ln cmd   *\n*                    Add calls to GETPDDB, GETREC routines.           *\n*      21May87  LDW  Add translate for forms code                     *\n*      20May87  EMS  Fix fix for DSID = 0                             *\n*                    add call to QSORT                                *\n*      21Mar87  LDW  Fix for DSID = 0 (from RSCS)                     *\n*      25Jan87  LDW  Pass READSPC the JQE addr in case of CB ID error *\n*      17Jan87  LDW  Eliminate \"LC\" macro usage                       *\n*                    Misc cleanup                                     *\n*      26Nov86  EMS  FIX FOR MULTI-LEN SYSIN/OUT DSIDS                *\n*      04/03/86 LDW  USE SPECIFIC BIT NAMES IN QDEBUG                 *\n*      03/31/86 LDW  RE-DESIGN 3278-5 SUPPORT (THIRD TRY!)            *\n*                    SIMPLIFY STD FORMS CHECK                         *\n*      02/07/85 EMS  MAKE DEFAULT STD FORM AN ASM TIME OPTION         *\n*      01/30/85 LDW  CHANGE 'SJ' TO DEFAULT TO ONLY NON-EMPTY         *\n*                       DATASETS; ADD 'ALL' KEYWORD                   *\n*      01/27/85 LDW  FIX BUG:  CLEAR PROC NAME WHEN HIT NON-PROC EXEC *\n*                    FIX LINE CMDS ON JES2 DATASETS FOR QLEVEL > 4    *\n*      09/10/84 LDW  FIX FORMS CODE FOR NON-SP134 FORMS CODE          *\n*      08/09/84 LDW  UPDATE FOR SP134 (USE IOTPDDB INSTEAD OF         *\n*                       QCPDDB1),                                     *\n*                    ALLOW FOR PDDB 5 NOT BEING IN FIRST IOT          *\n*                    RE-ARRANGE FIELDS TO ALLOW FOR SP134 8 CHAR FORM *\n*                    CHANGE DISPLAY OF UNKNOWN DSTYPE FROM '??????'   *\n*                       TO 'UNKNWN'                                   *\n*      04/11/84 LDW  JCTDSECT -> JCTSTART, IOTDSECT -> IOTSTART       *\n*      01/23/84 LDW  ADD SUPPORT FOR COMMAND STACKING                 *\n*                    ADD SUPPORT FOR 'SJ' AND 'NS' SUBCOMMANDS        *\n*                    USING/DROP -> USNGX/DROPX                        *\n*      06/21/83 LDW  REFORMAT DISPLAY -- PUT STEP ON SEPARATE LINE,   *\n*                       ADD MORE LINE INFO (LIKE FORMS, ETC)          *\n*      03/01/83 LDW  ADD SUPPORT FOR LINE COMMANDS                    *\n*      02/16/83 LDW  CHECK FOR MULTIPLE DSN= ON A SYSOUT DD, AND USE  *\n*                       THE LAST INSTEAD OF THE FIRST.  THIS SOLVES   *\n*                       THE PROBLEM OF GETTING GARBAGE IF THE JCL IS  *\n*                       EXECUTING A PROC WITH A TRUE DSN IN IT, BUT   *\n*                       AN OVERRIDE TO SYSOUT IN THE JCL.             *\n*      02/09/83 LDW  IF PDDB 5 NOT FOUND, PUT MSG TO SCREEN INSTEAD   *\n*                       OF QTILT, AND CONTINUE WITH THE LIMITED INFO  *\n*                       IN IOTS.  THIS IS NEEDED BECAUSE WITH SP      *\n*                       JES2, A SYSOUT JOB THAT IS DUMPED AND THEN    *\n*                       RELOADED WILL NOT HAVE ANY INTERNAL TEXT.     *\n*                       IBM STRIKES AGAIN!!!                          *\n*                    CHANGE PDBFLAG EXPLANATIONS TO LOWER CASE        *\n*      01/19/83 LDW  USE FIRST BIT OF QDEBUG INSTEAD OF QM1PDBFL      *\n*      01/14/83 LDW  PRE-SCAN IOT'S AND BUILD IN-STORAGE TABLE SO     *\n*                       THAT WE ONLY READ THE IOT CHAIN ONCE.  THIS   *\n*                       WILL GIVE (POSSIBLE DRASTIC) PERFORMANCE      *\n*                       IMPROVEMENT FOR JOBS WITH MANY SPIN AND/OR    *\n*                       HELD DATASETS                                 *\n*                    REMOVE CODE TO SQUEEZE OUT ATTR BYTES FOR        *\n*                       NON-TUBE, SINCE \"DISPLAY\" NOW DOES IT         *\n*      01/04/83 LDW  FIX MINOR BUG CREATED BY DISPLAYING PDBFLAG1     *\n*                       EXPLANATIONS (THIS BUG ONLY APPEARED IF       *\n*                       \"MODE PDBFLAG1\" AND LAST STEP HAD NO SYSOUT   *\n*                       DD STATEMENTS!!)                              *\n*                    ADD WORKLEN=                                     *\n*      12/20/82 LDW  RE-ARRANGE OUTPUT COLUMNS                        *\n*                    DISPLAY SYSOUT DSIDS IN HIGH INTENSITY           *\n*                    PROVIDE INPUT FIELDS FOR LINE COMMANDS           *\n*                    CHANGE HEADER AND SOME OTHER DATA TO LOWER CASE  *\n*                    DON'T SUPPRESS ANYTHING IF QMODE PDBFLAG1        *\n*      12/08/82 LDW  USE $LRC MACRO SYMBOLS                           *\n*      10/28/82 LDW  PUT JOBID ON TOP LINE (QDTOP)                    *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 3\nDDNAME   QSTART  Q4,WORKLEN=DD@WORKL\n         USNGX WORK,R13\n         L     R0,QDSTART               -> current table\n         A     R0,QDSIZE                current size\n         SH    R0,=Y(DD@ENTL)           fudge - can't use last entry\n         ST    R0,DD@TBLEE              -> end of table\n         QCALL DISP80                   SWITCH TO 3278-2 MODE IF 3278-5\n         MVC   DD@PROCN,=CL8'(none)'    THERE IS NO PROCEDURE IN EFFECT\n***********************************************************************\n*                                                                     *\n*   CALL FINDJOB TO LOCATE THE JQE, JCT, AND IOT                      *\n*                                                                     *\n***********************************************************************\n         QCALL FINDJOB                  FIND THE JOB\n         OI    QSCFLAG1,QSC1JOB         PUT JOBID IN QDTOP\n***********************************************************************\n*                                                                     *\n*   READ ALL PDDB'S AND SAVE INTERESTING INFORMATION                  *\n*                                                                     *\n***********************************************************************\n         L     R7,QDSTART               -> TABLE START\n         USNGX DD@ENT,R7\n         MVI   DD@FLAGS,0\n         MVI   QGPFLAG,QPFINIT          init for call\nDD$PDBLP QCALL GETPDDB                  get a pddb\n         LTR   R2,R1                    any left?\n         BZ    DD$SORT                  no, sort table\n         USNGX PDBDSECT,R2\n          AIF  (&QLEVEL GE 9).DD01\n         LH    R1,PDBDSKEY              GET DSID\n          AGO  .DD02\n.DD01     ANOP ,\n         L     R1,PDBDSKEY              get dsid\n.DD02     ANOP ,\n*%%      LTR   R1,R1                    NULL PDDB?\n*%%      BZ    DD$NXPDB                 YES - IGNORE IT\n*%%      TM    PDBFLAG1,PDB1NULL        NULL PDDB?\n*%%      BNZ   DD$NXPDB                 YES - IGNORE IT\n*---  SAVE USEFUL INFORMATION FROM PDDB IN OUR OWN TABLE           ---*\n         MVC   DD@FLAG1,PDBFLAG1        SAVE FLAG BYTE\n         MVC   DD@RECFM,PDBRECFM        SAVE RECORD FORMAT\n         MVC   DD@LRECL,PDBLRECL        SAVE MAXIMUM RECORD LENGTH\n         ST    R1,DD@DSKEY              SAVE BINARY DSKEY\n         MVC   DD@CLASS,PDBCLASS        SAVE SYSOUT CLASS\n         MVC   DD@RECCT,PDBRECCT        SAVE RECORD COUNT\n         MVC   DD@COPYS,PDBCOPYS        SAVE COPY COUNT\n         MVC   DD@DEST,PDBDEST          SAVE DEST (BINARY)\n**%%     MVC   DD@USER,PDBUSER          SAVE DEST USERID/RMTID\n         MVC   DD@FORMS,PDBFORMS        SAVE FORMS CODE\n         L     R15,=V(CHARTAB)          -> translate table\n         TR    DD@FORMS,0(R15)          translate to valid chars\n         CLC   DD@FORMS,=CL8'&@@QSTDF'  DEFAULT?\n         BNE   *+10                     NO - KEEP IT\n         MVC   DD@FORMS,QBLANK          YES - CLEAR IT\n         MVC   DD@FCB,PDBFCB            SAVE FCB ID\n         CLC   =C'****',DD@FCB          DEFAULT?\n         BNE   *+10                     NO - KEEP IT\n         MVC   DD@FCB,QBLANK            YES - CLEAR IT\n         MVC   DD@UCS,PDBUCS            SAVE UCS ID\n         CLC   =C'****',DD@UCS          DEFAULT?\n         BNE   *+10                     NO - KEEP IT\n         MVC   DD@UCS,QBLANK            YES - CLEAR IT\n**%%     MVC   DD@CHARS(4*4),PDBCHAR1   SAVE ALL 4 XLATE TAB NAMES\n         CLC   DD@UCS,QBLANK            ANYTHING HERE?\n         BNE   *+10                     YES - KEEP IT\n         MVC   DD@UCS,PDBCHAR1          NO - USE FIRST CHARS= NAME\n         CLC   =C'****',DD@UCS          DEFAULT?\n         BNE   *+10                     NO - KEEP IT\n         MVC   DD@UCS,QBLANK            YES - CLEAR IT\n**%%     MVC   DD@FLASH,PDBFLASH        SAVE FLASH ID\n**%%     MVC   DD@MODF,PDBMODF          SAVE COPY MOD IMAGE\n          AIF   (&QLEVEL LT 5).DD03\n         MVC   DD@PNAME,PDBPNAME        SAVE PROC STEP NAME\n         MVC   DD@SNAME,PDBSNAME        SAVE STEP NAME\n         MVC   DD@DDNAM,PDBDDNAM        SAVE DD NAME\n.DD03     ANOP\n         MVI   DD@XFLAG,0               CLEAR DISPLAY FLAG\n         MVC   DD@EYE,=C'DDE'           move in eyecatcher\n         LA    R7,DD@ENTL(,R7)          -> NEXT TABLE ENTRY\n         C     R7,DD@TBLEE              TABLE OVERFLOW?\n         BL    DD$NXLST                 no, continue\n***********************************************************************\n*                                                                     *\n*   DATASET RECORD NUMBER TABLE IS TOO SMALL.  TRY TO GET A BIGGER    *\n*   ONE, COPY THE INFORMATION, AND FREE THE OLD ONE.  WE WILL TRY     *\n*   FOR ONE 4 TIMES THE SIZE, SO WE WILL GO FROM THE ORIGINAL 8K TO   *\n*   32K.  IF THAT ONE IS TOO SMALL, WE WILL GO TO 256K.  IF THAT      *\n*   ONE IS TOO SMALL, YOU BETTER BE LOGGED ON IN A MONSTER REGION.    *\n*                                                                     *\n***********************************************************************\n         S     R7,QDSTART               get offset\n         STM   R14,R12,12(R13)          stash for a sec\n         L     R2,QDSIZE                get current size\n         LR    R7,R2                    copy for later\n         SLL   R2,2                     multiply by 4\n         GETMAIN  RC,LV=(R2),SP=1       get new workarea\n         LTR   R15,R15                  did it work?\n         BNZ   DD$TILT1                 no, exit stage right\n         LR    R6,R1                    mvcl - target addr\n         LR    R0,R1                    mvcl - target addr\n         LR    R1,R2                    mvcl - target length\n         LR    R15,R7                   mvcl - source length\n         L     R14,QDSTART              mvcl - source addr\n         MVCL  R0,R14                   copy table\n         LR    R0,R7                    point to old table\n         ICM   R0,B'1000',=AL1(1)       set subpool\n         L     R1,QDSTART               ditto addr\n         FREEMAIN  R,LV=(0),A=(1)       free old table\n         ST    R6,QDSTART               set\n         ST    R2,QDSIZE                   new\n         AR    R6,R2                          table\n         SH    R6,=Y(DD@ENTL)           fudge - can't use last entry\n         ST    R6,DD@TBLEE              save for later\n         LM    R14,R12,12(R13)          restore regs\n         A     R7,QDSTART               new addr\nDD$NXLST MVC   DD@DSKEY,=X'EEEEEEEE'    flag it as end of table\n         MVI   DD@FLAG1,0               clear flag\n         B     DD$PDBLP                 get next pddb\n         DROPX R7,R2                    DD@ENT, PDDB\nDD$SORT  QSORT ADDR=QDSTART,LEN==A(DD@ENTL),COMP==A(DD$CMP),OFFSET=R7, $\n               PREFIX=DD\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*   IF 'SJ' SUBCOMMAND, CREATE DSID TABLE FOR 'NS' SUBCOMMAND --LDW-- *\n*                                                                     *\n***********************************************************************\nDD$SJCHK CLI   QCODE,4                  SJ?\n         BNE   DD$SYSGO                 NO - CONTINUE NORMAL 'DD'\n         CLI   QKEYWORD,C'A'            'ALL' SPECIFIED?\n         BNE   *+8                      NO - SKIP\n         OI    DD@FLAGS,DD@FSJAL        YES - REMEMBER\n         L     R1,QCDDTBLA              -> CURRENT TABLE\n         S     R7,QDSTART               COMPUTE TABLE LENGTH\n         SR    R6,R6                    CLEAR FOR DIVIDE\n         D     R6,=A(DD@ENTL)           COMPUTE NUMBER OF ENTRIES\n         LA    R7,2(,R7)                ACCOUNT FOR START AND END\n         SLL   R7,2                     times entry length\n         C     R7,QCDDTBLL              NEED BIGGER THAN CURRENT?\n         BL    DD$SJ$02                 NO - OK\n         L     R0,QCDDTBLL              GET CURRENT LENGTH\n         LTR   R0,R0                    ANY CURRENT TABLE?\n         BZ    DD$SJ$01                 NO - DON'T FREEMAIN\n         SPACE 1\n         FREEMAIN  RU,LV=(0),A=(1),SP=3 FREE OLD TABLE\n         SPACE 2\nDD$SJ$01 GETMAIN  RU,LV=(R7),SP=3       GET A NEW TABLE\n         SPACE 1\n         ST    R7,QCDDTBLL              SAVE LENGTH OF NEW TABLE\n         ST    R1,QCDDTBLA              SAVE ADDR\n         ST    R1,QCDDTBLE              SET 'CURRENT ENTRY' POINTER\n         SPACE 2\nDD$SJ$02 MVC   0(2,R1),=C'*T'           INDICATE TOP\n         LA    R1,4(,R1)                -> NEXT ENTRY\n         L     R7,QDSTART               -> DDNAME'S DSID TABLE\n         USNGX DD@ENT,R7\n         SPACE 1\nDD$SJ$LP TM    DD@FLAG1,PDB1NSOT        'NOT FOR SYSOUT'?\n         BO    DD$SJNXT                 RIGHT - SKIP\n         TM    DD@FLAGS,DD@FSJAL        'ALL'?\n         BO    DD$SJ$SV                 YES - SAVE THIS ENTRY\n         TM    DD@FLAG1,PDB1NULL        'NULL PDDB'?\n         BNZ   DD$SJNXT                 YES - SKIP IT\nDD$SJ$SV MVC   0(4,R1),DD@DSKEY         SAVE BINARY DSKEY\n         LA    R1,4(,R1)                -> NEXT 'NS' TABLE ENTRY\nDD$SJNXT LA    R7,DD@ENTL(,R7)          -> NEXT 'DD' TABLE ENTRY\n         CLC   DD@DSKEY,=X'EEEEEEEE'    end of table?\n         BNE   DD$SJ$LP                 NO - CONTINUE LOOP\n         MVC   0(2,R1),=C'*E'           INDICATE END OF TABLE\n         MVC   QKEYWORD(16),=CL16'TOP'\n         MVI   QCODE,16                 SET \"NS\"\n         QCALL LIST                     GO DISPLAY THE FIRST DATASET\n         B     QSTOP                    LEAVE WHEN HE LEAVES\n         DROPX R7                       DD@ENT\n***********************************************************************\n*                                                                     *\n*   SHOW RECORD COUNTS FOR JES2 SPOOLED DATASETS              --LDW-- *\n*                                                                     *\n***********************************************************************\nDD$SYSGO QSTACK  X'20'                  PUT 'DD' SUBCOMMAND ON STACK\n         MVC   QDHLINE,=CL79'    DDname     DSid    DStype Records Cl  $\n               Dest   Copies Ucs  Fcb  Forms'\n         MVC   QDLCTBL,=V(PA#LC#DD)     SET ADDR OF LINE COMMANDS TABLE\n         MVC   QCDDTBLE,QCDDTBLA        INIT DSID TAB CURRENT ENT PTR\n         L     R7,QDSTART               -> IN-STORAGE DSID TABLE\n         USNGX DD@ENT,R7\n         SPACE 1\nDD$SYSLP CLC   =X'EEEEEEEE',DD@DSKEY    end of table?\n         BE    DDJOB                    YES - GO PROCESS NORMAL DSID'S\n         L     R1,DD@DSKEY              GET DSID\n         B     DD$SYOUT                 %%%%%%\n         TM    DD@FLAG1,PDB1NSOT        NOT FOR SYSOUT?\n         BZ    DD$SYOUT                 NO - IT'S FOR SYSOUT\n         CH    R1,=H'2'                 IT IS 2 THRU 4?\n         BL    DD$SYOUT                 NO - OK\n         CH    R1,=H'4'                 IT IS 2 THRU 4?\n         BNH   DD$SYSNX                 YES - IGNORE IT BECAUSE IT IS\n*                                       MARKED \"NOT FOR SYSOUT\" AND IS\n*                                       THE JOBLOG, JOBMSG, OR JCL DS,\n*                                       WHICH ARE DUPLICATED ON THE\n*                                       SPIN IOT WITHOUT THE \"NOT FOR\n*                                       SYSOUT\" FLAG SET.\n         SPACE 1\nDD$SYOUT CH    R1,=H'100'               A PROBLEM PROGRAM DATASET?\n         BH    DD$SYSNX                 YES - IGNORE ON THIS PASS\n         CH    R1,=H'1'                 INPUT JCL?\n         BE    DD$AUTH1                 YES - SHOW ONLY TO AUTH USERS\n         BL    DD$SYSNX                 ignore VM/VSE oddity this pass\n         CH    R1,=H'4'                 JOBLOG/JCL/JOBMSG?\n         BH    DD$AUTH1                 NO - SHOW ONLY TO AUTH USERS\n         MVC   DDATTR1,=X'1DC8'         SET INPUT, BRIGHT\n         MVC   DDATTR2,=X'1D60'         SET OUTPUT, NORMAL\n         MVC   DDATTR3,=X'1DE8'         SET OUTPUT, BRIGHT\n         B     DD$SYSDS                 CONTINUE\nDD$AUTH1 TM    QXAUTH,QXPSWD+QXSYSP     AUTHORIZED USER?\n         BZ    DD$SYSNX                 NO - DON'T DISPLAY THIS DSID\n         MVC   DDATTR1,=X'1DE8'         SET OUTPUT, BRIGHT\n         MVC   DDATTR2,=X'1D60'         SET OUTPUT, NORMAL\n         MVC   DDATTR3,=X'1D60'         SET OUTPUT, NORMAL\nDD$SYSDS MVC   DDATTR4,=X'1D60'         SET OUTPUT, NORMAL\n         MVI   QDATRNUM+1,4             SET # OF ATTR BYTES IN LINE\n         MVC   DDDSTYPE,=C'$$JES2'      MOVE IN SYSTEM DSTYPE\n*---  SAVE DATA IN ARRAY FOR LINE COMMANDS                         ---*\n         XC    DD@TPTR(LCBELEN),DD@TPTR INIT ARRAY ELEMENT\n         MVI   DD@ADDR1+3,DDSELECT-QDMSG  OFFSET INTO LINE OF 1ST FIELD\n         MVC   DD@FLD1(2+8),QBLANK\n         MH    R1,=H'6'                 MULTIPLY DSID BY entry length\n         LA    R1,DDCMDSYS-6(R1)        -> SUBCMD TO USE IF LINE SELECT\n         MVC   DD@ID,0(R1)              SAVE FOR DD@ID\n          AIF   (&QLEVEL GE 5).DD04\n         L     R1,DD@DSKEY              GET DSID\n         MH    R1,=H'6'                 ENTRIES ARE 6 BYTES EACH\n         LA    R1,DSIDTYPE-6(R1)        -> TYPE\n         MVC   DDDSTYPE,0(R1)           MOVE IN SYSTEM DSTYPE\n.DD04     ANOP\n         BAL   R8,DD$FMT                FMT DSID/RECCT/CLASS/HOLD/PRINT\n         TM    QXAUTH,QXPSWD+QXSYSP     AUTHORIZED USER?\n         BNZ   *+10                     YES - DISPLAY DSID\n         MVC   DDDSID,QBLANK            NO - CLEAR DSID FIELD\n         LA    R1,DD@TPTR               -> MY ARRAY ELEMENT\n         QCALL DISPADDX                 ADD THIS LINE TO SCREEN\nDD$SYSNX LA    R7,DD@ENTL(,R7)          -> NEXT DSID TABLE ENTRY\n         B     DD$SYSLP                 GO PROCESS\n         DROPX R7                       DD@ENTL\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*   LOCATE PDDB NUMBER 5                                              *\n*                                                                     *\n***********************************************************************\n          AIF  (&QLEVEL GE 9).DD05\nDDJOB    MVC   QPDSID,=H'5'             get it\n          AGO  .DD06\n.DD05     ANOP ,\nDDJOB    MVC   QPDSID,=F'5'             get it\n.DD06     ANOP ,\n         NI    QFLAG2,255-Q2VALIDS      MARK NO VALID DS\n         MVC   QDHDSID,=CL8'5'          set if needed\n         MVI   QGPFLAG,QPFDIR+QPFNMSG   this one, no msg\n         QCALL GETPDDB                  get it\n         LTR   R2,R1                    find it?\n         BP    DDFOUNDD                 yes, continue\n         USNGX PDBDSECT,R2\n******** QTILT '*** JOB DOES NOT HAVE DD TABLE ***'\n         OI    DD@FLAGS,DD@FNOTX        REMEMBER NO INTERNAL TEXT\n          AIF   (&QLEVEL GE 5).DD07\n         MVC   QDMSG(NOTXTMGL),NOTXTMSG DISPLAY MESSAGE TO THAT EFFECT\n         MVI   QDATRNUM+1,2             NUMBER OF ATTR BYTES IN LINE\n         BAL   R14,QADDLINE             PUT MESSAGE TO SCREEN\n.DD07     ANOP\n         B     DDSPIN                   GO FORMAT FROM IN-STORAGE TABLE\n         SPACE 2\nDDFOUNDD MVC   QCGRMTTR,PDBMTTR         DISK ADDR OF FIRST BLOCK\n         DROPX R2                       PDDB\n         MVI   QCRFLAG,QRFINIT          start at top of dataset\n***********************************************************************\n*                                                                     *\n*   PROCESS RECORDS                                                   *\n*                                                                     *\n***********************************************************************\n         USNGX LRCDSECT,R4\nDDNXTREC QCALL GETREC                   get a record\n         LTR   R4,R4                    eof?\n         BZ    DDSPIN                   yes, get spin datasets\n         TM    LRCFLAG1,LRC1SPAN        IS THIS A SPANNED RECORD?\n         BO    DDNXTREC                 yes, skip it.\n         TM    LRCTEXT+2,EXECSTR        IS THIS AN EXEC RECORD?\n         BO    DDEXEC                   YES. PROCESS IT.\n         TM    LRCTEXT+2,DDSTR          IS THIS A DD RECORD?\n         BO    DD$DD                    YES. PROCESS IT.\n         B     DDNXTREC                 otherwise, ignore record.\n***********************************************************************\n*                                                                     *\n*   PROCESS AN EXEC RECORD                                            *\n*                                                                     *\n***********************************************************************\nDDEXEC   CLI   LRCTEXT+STREKEY-TEXT,EXECK  IS THERE A STEPNAME?\n         BNE   DDNXTREC                 No, skip this record.\n         SR    R1,R1                    CLEAR FOR IC\n         IC    R1,LRCTEXT+STREKEY+2-TEXT  LENGTH OF PROCSTEP/STEPNAME\n         TM    LRCTEXT+STREINDC-TEXT,ETXPRCV  EXEC PROC=XXXX?\n         BO    DDEXPROC                 YES - HANDLE IT\n         TM    LRCTEXT+STREINDC-TEXT,ETXPROC  IN A PROC?\n         BO    *+10                     YES - KEEP PROC NAME\n         MVC   DD@PROCN,=CL8'(none)'    NO - CLEAR THE FIELD\n         MVC   QDMSG(2),=X'1DE8'        SET OUTPUT, BRIGHT\n         MVC   QDMSG+2(2),=C'- '        START THE SEPARATOR LINE\n         MVC   QDMSG+4(76),QDMSG+2      PROPAGATE THE SEPARATOR\n         MVC   QDMSG+80(2),=X'1D60'     SET OUTPUT, NORMAL\n         MVI   QDATRNUM+1,2             SET # OF ATTR BYTES IN LINE\n         STM   R14,R1,DD@REGSV          SAVE VOLATILE REGS TEMPORARILY\n         BAL   R14,QADDLINE             ADD THE SEPARATOR LINE\n         LM    R14,R1,DD@REGSV          RESTORE VOLATILE REGS\n         MVC   DDSTEPLN,DD#STHDR        MOVE IN HEADING\n         MVC   DDPROCN,DD@PROCN         MOVE IN PROCNAME\n*  ASSUME (FOR LACK OF KNOWLEDGE TO THE CONTRARY) THAT IT'S PGM=\n*---  ASSUME NOT IN PROC, SET UP ACCORDINGLY                       ---*\n         LA    R15,DDSTEPN              -> WHERE THE STEPNAME WILL GO\n         TM    LRCTEXT+STREINDC-TEXT,ETXPROC  IN A PROC?\n         BNO   DDEXNOPR                 NO - HANDLE IT\n*---  IN A PROC -- MUST FLOAT A '.' AND THE STEPNAME               ---*\n         MVC   DDSTEPN,DD@PSTEP         MOVE IN PROCSTEPNAME\n         LA    R15,1(,R15)              -> NEXT POSSIBLE POSITION\n         CLI   0(R15),C' '              END OF PROCSTEPNAME?\n         BNE   *-8                      NO - KEEP LOOKING\n         MVI   0(R15),C'.'              ADD THE SEPARATOR\n         LA    R15,1(,R15)              AND BUMP PAST IT\n         B     DDEXINPR                 CONTINUE\n         SPACE 1\nDDEXNOPR MVC   DD@PSTEP,=CL8'(none)'    THERE IS NO PROCEDURE IN EFFECT\n         SPACE 1\nDDEXINPR MVC   0(8,R15),=CL8'(none)'    CLEAR IT WITH ' (NONE) '\n         MVC   DDPGM,=CL8'(none)'       AND THIS TOO\n         SH    R1,=H'1'                 -1 FOR EX\n         BM    DDNSTEP1                 SKIP IF NO STEPNAME\n         MVC   0(8,R15),QBLANK          CLEAR THE FIELD FIRST\n         EX    R1,DDMVCST               MOVE THE STEPNAME\nDDNSTEP1 LA    R15,LRCTEXT+STREKEY+3-TEXT+1(R1) POINT TO PGMNAME KEY\n         CLI   0(R15),PGMEK             IS THIS THE PROGRAM NAME?\n         BNE   DDEXECOK                 NO - DONE WITH THIS RECORD\n***      CLI   2(R15),X'83'             IS THIS PGM=*.STEP.DDNAME?\n***      BE    DDEXSTAR                 YES - HANDLE IT\n         TM    2(R15),X'80'             IS THIS MANY PIECES?\n         BO    DDEXSTAR                 YES - must be PGM=*.S.PS.DDN\n         SR    R1,R1                    CLEAR FOR IC\n         IC    R1,2(,R15)               GET PGMNAME LENGTH\n         SH    R1,=H'1'                 -1 FOR EX\n         BM    DDEXECOK                 DONE - GO DISPLAY THIS STEP\n         MVC   DDPGM,QBLANK             CLEAR THE FIELD\n         EX    R1,DDMVCPGM              MOVE PGM NAME\n*     (  B     DDEXECOK  )              CONTINUE PROCESSING\n         SPACE 2\nDDEXECOK MVI   QDATRNUM+1,2             SET # OF ATTR BYTES IN LINE\n         QCALL DISPADD                  ADD THIS LINE TO SCREEN\n         B     DDNXTREC                 All done\n         SPACE 2\nDDMVCST  MVC   0(*-*,R15),LRCTEXT+STREKEY+3-TEXT << EXECUTED >>\nDDMVCPGM MVC   DDPGM(*-*),3(R15)        << EXECUTED >>\n         SPACE 1\nDDEXSTAR MVC   DDPGM,=C'*.DDNAME'       THE REAL WHOLE THING WON'T FIT\n         B     DDEXECOK                 IGNORE THE REST OF THE RECORD\n         SPACE 1\n*---  THIS INTERNAL TEXT RECORD IS FOR EXEC PROC=XXX.              ---*\n*---  SAVE THE INFO FOR DISPLAY BY REGULAR EXEC PGM= CODE.         ---*\nDDEXPROC MVC   DD@PROCN,=CL8'(none)'    CLEAR THE FIELD\n         MVC   DD@PSTEP,=CL8'(none)'    AND THIS ONE ALSO\n         SH    R1,=H'1'                 -1 FOR EX\n         BM    DDEXPR$1                 SKIP IF NONE\n         MVC   DD@PSTEP,QBLANK          BLANK THE FIELD\n         EX    R1,DDMVCPS               SAVE STEPNAME\nDDEXPR$1 LA    R15,LRCTEXT+STREKEY+3-TEXT+1(R1) -> PROCNAME OR NXT UNIT\n         CLI   LRCTEXT+STREKEY+1-TEXT,2 ARE THERE 2 POSITIONAL UNITS?\n         BE    DDEXPROX                 YES - GO PROCESS IT\n         CLI   0(R15),PROCEK            EXPLICIT EXEC PROC= ?\n         BNE   DDNXTREC                 No - get out\n         LA    R15,2(,R15)              POINT TO PROCNAME LENGTH\nDDEXPROX SR    R1,R1                    CLEAR FOR IC\n         IC    R1,0(,R15)               GET PROCNAME LENGTH\n         SH    R1,=H'1'                 -1 FOR EX\n         BM    DDNXTREC                 Ignore if none\n         MVC   DD@PROCN,QBLANK          BLANK THE FIELD\n         EX    R1,DDMVCPR               MOVE PROCNAME\n         B     DDNXTREC                 Done with this record\n         SPACE 2\nDDMVCPS  MVC   DD@PSTEP(*-*),LRCTEXT+STREKEY+3-TEXT << EXECUTED >>\nDDMVCPR  MVC   DD@PROCN(*-*),1(R15)     << EXECUTED >>\n***********************************************************************\n*                                                                     *\n*   PROCESS DD RECORDS                                                *\n*                                                                     *\n***********************************************************************\nDD$DD    TM    LRCTEXT+STRDINDC-TEXT,DTXSYSIN+DTXSYOUT SYSIN/SYSOUT DD?\n         BZ    DDNXTREC                 No. skip the record.\n         XC    DD@ADSNK,DD@ADSNK        NO DSN= TEXT UNIT YET\n         NI    DD@FLAGS,255-DD@FTS      reset bit\n         LA    R7,LRCTEXT+STRDKEY-TEXT  ADDR OF FIRST KEY\n         LR    R8,R6                    REMAINING LENGTH OF RECORD\n         SR    R15,R15                  CLEAR FOR IC\n         SR    R14,R14                  CLEAR FOR IC\n         SR    R1,R1                    CLEAR FOR IC\nDDTRYFLD CLI   0(R7),DSNAMEK            IS THIS THE DSNAME?\n         BE    DD$DSKEY                 YES. PROCESS IT.\n          AIF   (&QLEVEL GE 5).DD08      DON'T NEED TO FIND DDN IF 134\n         CLI   0(R7),DDK                IS THIS THE DDNAME?\n         BE    DDKEY                    YES. PROCESS IT.\n.DD08     ANOP\n         CLI   0(R7),TERMK              term=ts?\n         BE    DD$TERM                  YES. PROCESS IT.\nDDNXTFLD IC    R1,1(,R7)                NUMBER OF SUBFIELDS\n         LA    R7,2(,R7)                UPDATE LOCATION\n         SH    R8,=H'2'                 REMAINING COUNT\n         SR    R8,R1                    REMAINING COUNT\n         BNP   DDENDREC                 REC IS EXHAUSTED - CHK FOR DSN=\n         LTR   R1,R1                    ARE THERE ANY SUBFIELDS?\n         BZ    DDTRYFLD                 NO. TRY NEXT FIELD.\nDDLPFLD  TM    0(R7),X'80'              IS THIS A SUB-SUB-FIELD\n         BZ    DDNOSUB                  NO. CONTINUE.\n         IC    R14,0(,R7)               NUMBER OF SUB-SUB-FIELDS\n         N     R14,=A(X'7F')            CLEAR THE HEX 80 BIT\n         LA    R7,1(,R7)                UPDATE LOCATION\n         SH    R8,=H'1'                 REMAINING COUNT\n         SR    R8,R14                   REMAINING COUNT\n         BNP   DDNXTREC                 Record is exhausted\n         AR    R1,R14                   INCREASE NUMBER OF SUBFIELDS\n         B     DDYESSUB                 DECREMENT AND TRY AGAIN\nDDNOSUB  IC    R15,0(,R7)               SUBFIELD LENGTH\n         LA    R7,1(R15,R7)             ADD TO LOCATION\n         SR    R8,R15                   REMAINING COUNT\n         BNP   DDNXTREC                 Record is exhausted\nDDYESSUB BCT   R1,DDLPFLD               DO NEXT SUBFIELD\n         B     DDTRYFLD                 TRY NEXT FIELD\n          AIF   (&QLEVEL GE 5).DD09\nDDKEY    IC    R1,2(,R7)                LENGTH OF DDNAME\n         LTR   R1,R1                    IS THE LENGTH ZERO?\n         BZ    DDNXTFLD                 YES. SKIP THE FIELD.\n         BCTR  R1,0                     DECREMENT BY 1\n         EX    R1,DDMVCDDN              MOVE THE DDNAME\n         B     DDNXTFLD                 PROCESS NEXT FIELD\n.DD09     ANOP\nDD$TERM  OI    DD@FLAGS,DD@FTS          indicate presence of TERM=TS\n         B     DDNXTFLD                 GO PROCESS NEXT TEXT UNIT\nDD$DSKEY ST    R7,DD@ADSNK              SAVE PTR TO DSN= TEXT UNIT\n         B     DDNXTFLD                 GO PROCESS NEXT TEXT UNIT\nDDENDREC L     R7,DD@ADSNK              -> LAST DSN= TEXT UNIT, IF ANY\n         LTR   R7,R7                    ANY?\n         BZ    DDNXTREC                 No - go on to next record\n         CLC   =C'TSU',8(R7)            this a tsu?\n         BNE   *+4+4+4                  no, continue\n         TM    DD@FLAGS,DD@FTS          term=ts present?\n         BO    DDNXTREC                 yes, ignore dsn.\n*        MVC   DDDSID,19(R7)            MOVE THE DSID\n         XR    R1,R1                    CLEAR FOR IC\n         IC    R1,LRCLRECL-LRCDSECT(,R7) GET LEN OF DSN FIELD\n         LA    R1,LRCTEXT-LRCDSECT(R1,R7)  START OF NEXT FIELD\n          AIF   (&QLEVEL LT 10).DD10     dsn format changed at 313\n*        the following loop gets rid of the \"dataset type\" suffix\n         BCTR  R1,0                     back 1 char\n         CLI   0(R1),C'.'               qualifier delimiter?\n         BNE   *-4-2                    no, try again\n.DD10     ANOP\n         SH    R1,=Y(L'DDDSID)          LESS LEN OF OUTPUT FIELD\n         MVC   DDDSID,0(R1)             MOVE IN LAST PORTION OF DSID\n*        CLI   DDDSID,C'0'              LEADING 0?\n*        BNE   *+8                      NO - SKIP\n*        MVI   DDDSID,C' '              YES - MAKE IT A BLANK\n         PACK  DDN@DWD,DDDSID\n         MVC   DDN@TEMP,=X'4020202020202120'      ID\n         ED    DDN@TEMP,DDN@DWD+4\n         MVC   DDDSID,DDN@TEMP+2\n         CVB   R0,DDN@DWD               GET DSID IN BINARY\n         MVC   DDDSTYPE,=C'*ERROR'      INIT FIELD\n         TM    LRCTEXT+STRDINDC-TEXT,DTXSYOUT  SYSOUT?\n         BNO   *+10                     NO - SKIP\n         MVC   DDDSTYPE,=C'Sysout'      'SYSOUT'\n         TM    LRCTEXT+STRDINDC-TEXT,DTXSYSIN  SYSIN?\n         BNO   *+10                     NO - SKIP\n         MVC   DDDSTYPE,=C'Sysin '      'SYSIN '\n         TM    LRCTEXT+STRDINDC-TEXT,DTXSYOUT+DTXSYSIN  BOTH????\n         BNO   *+10                     NO - SKIP\n         MVC   DDDSTYPE,=C'ERROR*'\n         DROPX R4                       LRC\n***********************************************************************\n*   FIND IN-STORAGE TABLE ENTRY FOR THIS PDDB                         *\n*   EXTRACT RECORD COUNT, CLASS, HOLD, PRT, ETC                       *\n***********************************************************************\n         L     R7,QDSTART               -> IN-STORAGE TABLE\n         USNGX DD@ENT,R7\nDD$TBLLP CLC   =X'EEEEEEEE',DD@DSKEY    END OF TABLE?\n         BE    DD$TBLNF                 YES - NOT FOUND\n         C     R0,DD@DSKEY              THIS THE ENTRY?\n         BE    DD$TBLOK                 YES - GO FORMAT DATA\n         LA    R7,DD@ENTL(,R7)          -> NEXT TABLE ENTRY\n         B     DD$TBLLP                 KEEP LOOKING\nDD$TBLOK BAL   R8,DD$FMT2               FORMAT RECCT/CLASS/HOLD/PRINT\n         DROPX R7                       DD@ENT\n***********************************************************************\n*   BUILD THE OUTPUT LINE                                             *\n***********************************************************************\nDD$TBLNF MVC   DDATTR1,=X'1DC8'         SET INPUT, BRIGHT\n         MVC   DDATTR2,=X'1D60'         SET OUTPUT, NORMAL\n         MVC   DDATTR3,=X'1DE8'         SET OUTPUT, BRIGHT\n         CLC   =C'Sysout',DDDSTYPE      IS THIS A SYSOUT DATASET?\n         BE    *+8                      YES - OK\n         MVI   DDATTR3+1,X'60'          SET OUTPUT, NORMAL\n         MVC   DDATTR4,=X'1D60'         SET OUTPUT, NORMAL\n         MVI   QDATRNUM+1,4             SET # OF ATTR BYTES IN LINE\n*---  SAVE DATA IN ARRAY FOR LINE COMMANDS                         ---*\n         XC    DD@TPTR(LCBELEN),DD@TPTR INIT ARRAY ELEMENT\n         MVI   DD@ADDR1+3,DDSELECT-QDMSG  OFFSET INTO LINE OF 1ST FIELD\n         MVC   DD@ID,DDDSID             DSID\n         MVC   DD@FLD1(2+8),QBLANK\n         LA    R1,DD@TPTR               -> MY ARRAY ELEMENT\n         QCALL DISPADDX                 ADD THIS LINE TO SCREEN\n         B     DDNXTREC                 Process next record\n*%%DDTILT1  QTILT '*** DSID TABLE OVERFLOW ***'\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*   PROCESS SPUN OFF DATASETS                                         *\n*                                                                     *\n***********************************************************************\nDDSPIN   L     R7,QDSTART               -> IN-STORAGE PDDB TABLE\n         USNGX DD@ENT,R7\n         MVC   DD@PSTEP,=X'EFFEEFFE'    CLEAR\n         MVC   DD@STEP,=X'EFFEEFFE'     CLEAR\nDDSPIN10 CLC   =X'EEEEEEEE',DD@DSKEY    end of table?\n         BE    DDSPIN90                 YES - ALL DONE HERE\n         MVI   DD@STAR,C' '             ASSUME NOTHING WEIRD\n         TM    DD@FLAGS,DD@FNOTX        INTERNAL TEXT UNAVAILABLE?\n         BO    DDSPIN20                 YES - DISPLAY THIS ENTRY\n***      TM    DD@FLAG1,PDB1SPIN        SPIN DATASET?\n***      BO    DDSPIN20                 YES - DISPLAY IT\n*%        AIF   (&QLEVEL GE 11).DD15\n*%       TM    DD@FLAG1,PDB1SPIN+PDB1PSO  PROCESSABLE??\n*%        AGO   .DD16\n.DD15     ANOP\n*%       TM    DD@FLAG1,PDB1SPIN        PROCESSABLE?\n.DD16     ANOP\n*%       BNZ   DDSPIN20                 YES - DISPLAY IT\n         TM    DD@FLAG1,PDB1SPIN        SPIN DATASET?\n         BO    DDSPIN20                 YES - DISPLAY IT\n         TM    QDEBUG1,QDEBUG11         DEBUGGING?\n         BNO   DDSPIN50                 NO - SKIP THIS ENTRY\n         CLI   DD@XFLAG,255             THIS ENTRY ALREADY DISPLAYED?\n         BE    DDSPIN50                 YES - SKIP IT\n         MVI   DD@STAR,C'*'             NO - INDICATE IT WOULD HAVE\n*                                            HAVE BEEN SUPPRESSED\n         B     DDSPIN30                 CONTINUE\nDDSPIN20 CLI   DD@XFLAG,255             THIS ENTRY ALREADY DISPLAYED?\n         BNE   DDSPIN25                 NO - CONTINUE\n         TM    QDEBUG1,QDEBUG11         DEBUGGING?\n         BNO   DDSPIN50                 NO - SKIP IT\n         MVI   DD@STAR,C'<'             YES - FLAG SOMETHING FISHY HERE\n         B     DDSPIN30                 and, display it\nDDSPIN25 TM    DD@FLAG1,PDB1NULL+PDB1NSOT  null pddb entry?\n         BZ    DDSPIN30                 no, continue\n         TM    QDEBUG1,QDEBUG11         DEBUGGING?\n         BNO   DDSPIN50                 NO - SKIP IT\nDDSPIN30 EQU   *\n          AIF   (&QLEVEL LT 5).DD11\n         CLC   DD@PSTEP,DD@PNAME        DID PROCSTEPNAME CHANGE?\n         BNE   DDSPIN31                 yes - save new info\n         CLC   DD@STEP,DD@SNAME         DID STEPNAME CHANGE?\n         BE    DDSPIN40                 NO - SKIP\nDDSPIN31 MVC   DD@PSTEP,DD@PNAME        SAVE NEW PROCSTEPNAME\n         MVC   DD@STEP,DD@SNAME         SAVE NEW STEPNAME\n         MVC   QDMSG(2),=X'1DE8'        SET OUTPUT, BRIGHT\n         MVC   QDMSG+2(2),=C'- '        START THE SEPARATOR LINE\n         MVC   QDMSG+4(76),QDMSG+2      PROPAGATE THE SEPARATOR\n         MVC   QDMSG+80(2),=X'1D60'     SET OUTPUT, NORMAL\n         MVI   QDATRNUM+1,2             SET # OF ATTR BYTES IN LINE\n         BAL   R14,QADDLINE             ADD THE SEPARATOR LINE\n         MVC   DDSTEPLN,DD#STHDR        MOVE IN HEADING\n         MVC   DDPGM,=C'*UNKNOWN'       MOVE IN PGMNAME\n         MVC   DDPROCN,=C'*UNKNOWN'     MOVE IN PROCNAME\n         MVC   DDSTEPN,DD@PNAME         MOVE IN PROCSTEPNAME\n         CLC   DDSTEPN,QBLANK           ANY PROCSTEPNAME?\n         BE    DDSPIN37                 NO - PUT STEPNAME HERE\n         CLC   DD@SNAME,QBLANK          ANY STEPNAME?\n         BE    DDSPIN39                 NO - DON'T PUT IN THE DOT\n*---  FLOAT A '.' AND THE STEPNAME                                 ---*\n         LA    R15,DDSTEPN              -> START OF FIELD\n         LA    R15,1(,R15)              -> NEXT POSSIBLE POSITION\n         CLI   0(R15),C' '              END OF PROCSTEPNAME?\n         BNE   *-8                      NO - KEEP LOOKING\n         MVI   0(R15),C'.'              ADD THE SEPARATOR\n         MVC   1(8,R15),DD@SNAME        MOVE IN STEPNAME\n         B     DDSPIN39\nDDSPIN37 MVC   DDSTEPN,DD@SNAME         MOVE STEPNAME ONLY\nDDSPIN39 MVI   QDATRNUM+1,2             SET # OF ATTR BYTES IN LINE\n         QCALL DISPADD                  ADD THIS LINE TO SCREEN\nDDSPIN40 EQU   *\n.DD11     ANOP\n         MVC   DDDSIDFL,DD@STAR         COPY \"WEIRDNESS\" FLAG\n         MVC   DDDSTYPE,=C'<Spin>'      MOVE IN DATASET TYPE ('<SPIN>')\n         TM    DD@FLAG1,PDB1SPIN        SPIN DATASET?\n         BO    *+10                     YES - OK\n***      MVC   DDDSTYPE,=C'UNKNWN'      INDICATE DATASET TYPE\n         MVC   DDDSTYPE,=C'DynOut'      INDICATE FREE=END\n         MVC   DDATTR1,=X'1DC8'         SET INPUT, BRIGHT\n         MVC   DDATTR2,=X'1D60'         SET OUTPUT, NORMAL\n         MVC   DDATTR3,=X'1DE8'         SET OUTPUT, BRIGHT\n         MVC   DDATTR4,=X'1D60'         SET OUTPUT, NORMAL\n         MVI   QDATRNUM+1,4             SET # OF ATTR BYTES IN LINE\n         BAL   R8,DD$FMT                FMT DSID/RECCT/CLASS/HOLD/PRINT\n*---  SAVE DATA IN ARRAY FOR LINE COMMANDS                         ---*\n         XC    DD@TPTR(LCBELEN),DD@TPTR INIT ARRAY ELEMENT\n         MVI   DD@ADDR1+3,DDSELECT-QDMSG  OFFSET INTO LINE OF 1ST FIELD\n         MVC   DD@ID,DDDSID             DSID\n         MVC   DD@FLD1(2+8),QBLANK\n         LA    R1,DD@TPTR               -> MY ARRAY ELEMENT\n         QCALL DISPADDX                 ADD LINE TO DISPLAY\nDDSPIN50 LA    R7,DD@ENTL(,R7)          -> NEXT TABLE ENTRY\n         B     DDSPIN10                 GO DISPLAY THIS ONE\n         DROPX R7                       DD@ENTL\nDDSPIN90 TM    QDEBUG1,QDEBUG11         DEBUGGING?\n         BNO   QSTOP                    NO - ALL DONE\n         MVI   QDMSG,C'-'               INSERT A LINE ...\n         MVC   QDMSG+1(L'QDMSG-1),QDMSG ... OF DASHES\n         MVC   QDMSG+(80-DDDFPDBL)/2(DDDFPDBL),DDDEFPDB  WITH HEADER\n         MVI   QDATRNUM+1,2             2 ATTR BYTES HERE\n         BAL   R14,QADDLINE             DISPLAY THIS LINE\n         LA    R4,DDDEF80               -> first flag definition\n         LA    R5,DDDEF08               -> fifth flag definition\n         LA    R2,8/2                   number of times through loop\n         LA    R3,2*2                   number of attr bytes per line\n         TM    QISFLAG1,QIS1ISPF        running under ISPF?\n         BZ    DD$FL$LP                 no - use two column format\n         LA    R2,8                     yes - use single column format\n         LA    R3,2                     number of attr bytes per line\n*\nDD$FL$LP MVC   QDMSG,QBLANK             clear the line\n         MVC   QDMSG+20(DDDEFLEN),0(R4) copy one definition\n         TM    QISFLAG1,QIS1ISPF        running under ISPF?\n         BNZ   DD$FL$IS                 yes - skip other format\n         MVC   QDMSG(DDDEFLEN),0(R4)    copy left half\n         MVC   QDMSG+40(DDDEFLEN),0(R5) copy right half\nDD$FL$IS STC   R3,QDATRNUM+1            indicate number of attr bytes\n         BAL   R14,QADDLINE             DISPLAY THIS LINE\n         LA    R4,DDDEFLEN(,R4)         bump left ptr\n         LA    R5,DDDEFLEN(,R5)         bump right ptr\n         BCT   R2,DD$FL$LP              loop\n         BAL   R14,QADDLINE             DISPLAY A BLANK LINE\n         B     QSTOP                    ALL DONE\n***********************************************************************\n*                                                                     *\n*   FORMAT A LINE FOR 1 DSID                                          *\n*                                                                     *\n***********************************************************************\n         USNGX DD@ENT,R7\nDD$FMT   L     R0,DD@DSKEY              CONVERT\n         CVD   R0,DDN@DWD                  DATA SET\n         MVC   DDN@TEMP,=X'4020202020202120'      ID\n         ED    DDN@TEMP,DDN@DWD+4\n         MVC   DDDSID,DDN@TEMP+2\nDD$FMT2  MVI   DD@XFLAG,255             INDICATE THIS ENTRY DISPLAYED\n          AIF   (&QLEVEL LT 5).DD12\n         MVC   DDDDNAME,DD@DDNAM        MOVE IN DDNAME FROM PDDB\n.DD12     ANOP\n         L     R0,DD@RECCT              CONVERT\n         CVD   R0,DDN@DWD                  RECORD\n         MVC   DDDSRECS,=X'4020202020202120'     COUNT TO\n         ED    DDDSRECS,DDN@DWD+4                   PRINTABLE\n         MVC   DDDSCLS,DD@CLASS         MOVE IN SYSOUT CLASS\n         LA    R1,DD@DEST               -> BINARY DEST\n         QCALL FINDRJE                  GET A DISPLAYABLE NAME\n         MVC   DDDSDEST,0(R1)           DISPLAY THE RESULTS\n         SR    R0,R0                    CLEAR FOR IC\n         IC    R0,DD@COPYS              GET COPY COUNT\n         CH    R0,=H'1'                 DEFAULT?\n         BNH   DD$NOCPY                 YES - SKIP\n         CVD   R0,DDN@DWD\n         MVC   DDDSCPYS,=X'40202020'    GET EDIT MASK\n         ED    DDDSCPYS,DDN@DWD+6       FILL IN COPY COUNT\nDD$NOCPY MVC   DDDSFORM,DD@FORMS        MOVE IN FORMS CODE\n         MVC   DDSFCB,DD@FCB            MOVE IN FCB CODE\n         MVC   DDDSUCS,DD@UCS           MOVE IN UCS CODE\n         MVC   DDHELD,QBLANK            CLEAR FIELD\n          AIF   (&QLEVEL GE 11).DD13\n         TM    DD@FLAG1,PDB1HOLD        HELD DATASET?\n         BNO   *+10                     NO - SKIP\n         MVC   DDHELD,=C'H-'            YES - INDICATE THAT\n         TM    DD@FLAG1,PDB1SPIN        SPIN DATASET?\n         BNO   DD$NOTP                  NO - SKIP\n         TM    DD@FLAG1,PDB1PSO         AVAILABLE FOR SYSOUT?\n         BO    DD$NOTP                  YES - OK\n         MVC   DDHELD,=C'P-'            NO - INDIC. IT'S BEEN PRINTED\n.DD13     ANOP\nDD$NOTP  TM    QDEBUG1,QDEBUG11         WANT PDBFLAG DISPLAYED?\n         BZR   R8                       NO - DON'T DISPLAY PDBFLAG1\n         MVI   QDHLINE+78,C'F'          PUT IN COLUMN HEADER\n         UNPK  DDN@DWD(2+1),DD@FLAG1(1+1)\n         TR    DDN@DWD(2),QHEXTAB\n         MVC   DDPDBFLG,DDN@DWD\n         BR    R8                       RETURN TO CALLER\n         DROPX R7                       DD@ENT\n***********************************************************************\n*                                                                     *\n*   READ A BLOCK FROM HASPACE                                         *\n*                                                                     *\n***********************************************************************\nDD$READ  ST    R4,QCTRAK                STORE DISK ADDR\n         L     R0,QCJQEA                -> JQE\n         LR    R1,R5                    IOAREA ADDRESS\n         QCALL READSPC                  READ HASPACE\n         BR    R8                       RETURN TO CALLER\n         EJECT ,\n***********************************************************************\n*                                                                     *\n*   Sort Compare ROUTINE                                              *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         DROPX ,\n         USNGX DD$CMP,R15\n         USNGX DD@ENT,R1\n         USNGX WORK,R3\n         SPACE 2\nDD$CMP   MVI   DD@CFLAG,0               clear flags\n         CLC   DD@DSKEY,DD@DSKEY-DD@ENT(R2) Same DSID?\n         BNER  R14                      no, let sort do it\n         TM    DD@FLAG1,PDB1NULL        null?\n         BZ    *+8                      no, skip flag\n         OI    DD@CFLAG,DD@CFN1         yes, flag it\n         TM    DD@FLAG1-DD@ENT(R2),PDB1NULL  null?\n         BZ    *+8                      no, skip flag\n         OI    DD@CFLAG,DD@CFN2         yes, flag it\n         TM    DD@CFLAG,DD@CFN1+DD@CFN2 any nulls?\n         BNM   DD$CMPE                  zero/ones\nDD$CNULL TM    DD@CFLAG,DD@CFN1         first entry null?\n         BO    DD$CMPL                  yes, switch\n         TM    DD@CFLAG,DD@CFN2         second entry null?\n         BO    DD$CMPH                  no, continue\nDD$CMPL  CLC   =H'1',=H'2'              set cc low\n         BR    R14\nDD$CMPH  CLC   =H'2',=H'1'              set cc high\n         BR    R14\nDD$CMPE  CLC   =H'1',=H'1'              set cc equ\n         BR    R14\n         SPACE 2\n         DROPX R1,R3,R15\n         EJECT ,\n***********************************************************************\n*                                                                     *\n*   MISCELLANY                                                        *\n*                                                                     *\n***********************************************************************\n         USNGX DDNAME,R12\n         USNGX QCOMMON,R11\n         USNGX WORK,R13\n         SPACE 2\nDD$TILT1 QTILT '*** Dataset Table Limits Exceeded ***'\n         SPACE 3\n         LTORG ,\n         ENTRY SJ#KEYS\nSJ#KEYS  DC    CL8'ALL     ',CL8'A       '\n         DC    X'FF'                    END OF KEYWORD TABLE\n          AIF   (&QLEVEL GE 5).DD14\nDDMVCDDN MVC   DDDDNAME(*-*),3(R7)      << EXECUTED >>\n.DD14     ANOP\n          AIF   (&QLEVEL GE 5).DD91\nDSIDTYPE DC    C'JCLIN '                DSID=1\n         DC    C'JOBLOG'                DSID=2\n         DC    C'JCL   '                DSID=3\n         DC    C'JOBMSG'                DSID=4\n         DC    C'JCLTXT'                DSID=5\n         DC    C'SWA   '                DSID=6\n.DD91     ANOP\nDDCMDSYS DC    C'000001'                DSID=1\n         DC    C'JLOG  '                DSID=2\n         DC    C'JCL   '                DSID=3\n         DC    C'JMSG  '                DSID=4\n         DC    C'000005'                DSID=5\n         DC    C'000006'                DSID=6\n*D#STHDR DC    X'1DE8',CL(80-2)'** Pgm=          Proc=          Step='\nDD#STHDR DC    X'1DE8',CL18'******************'\n         DC    CL(80-2-18)'** Pgm=          Proc=          Step='\n         DC    X'1D60'                  SET OUTPUT, NORMAL\n         SPACE 1\n          AIF   (&QLEVEL GE 5).DD92\nNOTXTMSG DC    X'1DE8',C'************ DDname, Program, and Stepname inf$\n               ormation unavailable ***********',X'1D60'\nNOTXTMGL EQU   *-NOTXTMSG\n.DD92     ANOP\n         SPACE 1\nDDDEFPDB DC    X'1DE8',C'  PDBFLAG1 definition  ',X'1D60'\nDDDFPDBL EQU   *-DDDEFPDB\n         SPACE 1\nDDDEF80  DC X'1DE8',C'80=DSID',X'1D60',CL31'- DSID in PDBDSID/PDBWTRID'\nDDDEFLEN EQU   *-DDDEF80\n         DC X'1DE8',C'40=NULL',X'1D60',CL31'- This is a null PDDB     '\n         DC X'1DE8',C'20=LOG ',X'1D60',CL31'- PDDB for HASP Job Log   '\n         DC X'1DE8',C'10=MDES',X'1D60',CL31'- Mult-dest PDDBs follow  '\nDDDEF08  DC X'1DE8',C'08=NSOT',X'1D60',CL31'- Not for Sysout          '\n         DC X'1DE8',C'04=SPIN',X'1D60',CL31'- PDDB for Spin data set  '\n         DC X'1DE8',C'02=HOLD',X'1D60',CL31'- PDDB for Held data set  '\n         DC X'1DE8',C'01=PSO ',X'1D60',CL31'- Accessible by PSO       '\n         SPACE 3\n         QCOMMON\n         PUSH  PRINT\n         PRINT GEN                      get expansions back\n         ORG   QDMSG                    LINE FOR EACH DSID\nDDATTR1  DS    XL2\nDDSELECT DS    CL2\nDDATTR2  DS    XL2\nDDDDNAME DS    CL8\nDDATTR3  DS    XL2\nDDDSID   DS    CL6\nDDDSIDFL DS    C\nDDATTR4  DS    XL2\nDDHELD   DS    CL2                      'H-' OR 'P-' OR BLANK\nDDDSTYPE DS    CL6                      'SYSOUT', 'SYSIN ', OR '<SPIN>'\nDDDSRECS DS    CL8\n         DS    CL2\nDDDSCLS  DS    C\n         DS    CL2\nDDDSDEST DS    CL8\nDDDSCPYS DS    CL4\n         DS    CL2\nDDDSUCS  DS    CL4\n         DS    C\nDDSFCB   DS    CL4\n         DS    C\n          AIF   (&QLEVEL GE 5).DD93\nDDDSFORM DS    CL4\n          AGO   .DD94\n.DD93     ANOP\nDDDSFORM DS    CL8\n.DD94     ANOP\n         DS    CL4\nDDPDBFLG DS    CL2\n         ORG   QDMSG                    LINE FOR EACH STEP\nDDSTEPLN DS    0CL(2+78+2)\n         DS    X'1DE8',CL18,C'** PGM='\nDDPGM    DS    CL8\n         DS    C'  PROC='\nDDPROCN  DS    CL8\n         DS    C'  STEP='\nDDSTEPN  DS    CL8\n         DC    C'.'\n         DS    CL8\n         SPACE 3\nWORK     DSECT\n         ORG   WORK+72                  SKIP OVER SAVE AREA\nDDN@DWD  DS    D\nDD@PROCN DS    CL8\nDD@PSTEP DS    CL8\nDD@STEP  DS    CL8\nDD@ADSNK DS    A                        -> LAST DSN= INTERNAL TEXT UNIT\nDD@TBLEE DS    A                        -> end of dsid table\nDDN@TEMP DS    CL8\nDD@STAR  DS    C\nDD@WORK  DS    CL4\nDD@REGSV DS    4F                       TEMP REGISTER SAVE AREA\nDD@FLAGS DS    X\nDD@FSPIN EQU   X'01'                    THIS IS A SPIN DSID\nDD@FNOTX EQU   X'02'                    INTERNAL TEXT UNAVAILABLE\nDD@FTS   EQU   X'04'                    term=ts text key\nDD@FSJAL EQU   X'80'                    'ALL' OPERAND OF 'SJ' SUBCMD\n         SPACE 1\n         QLCB  PREFIX=DD@\n*D@TPTR  DS    A                        LCBTPTR\n*D@ADDR1 DS    A                        LCBADDR1\n*D@ADDR2 DS    A                        LCBADDR2\n*D@ID    DS    CL6                      LCBID (DSID)\n*D@FLD1  DS    CL2                      LCBFLD1\n*D@FLD2  DS    CL8                      LCBFLD2\n          AIF   ('&@@OACFS' EQ '').DD95\nDD@PARM  OACFSORT  PREFIX=DD@,DSECT=NO\n.DD95     ANOP\n         SPACE 1\nDD@CFLAG DS    X                        misc flags for compare rtn\nDD@CFN1  EQU   X'80'                    first dd entry null\nDD@CFN2  EQU   X'40'                    second dd entry null\nDD@WORKL EQU   *-WORK\nDD@SWRK  DS    XL512\n         SPACE 3\n*---  COMPRESSED COPY OF A PDDB                                    ---*\nDD@ENT   DSECT\nDD@EYE   DS    CL3'DDE'                 eyecatcher\nDD@XFLAG DS    X                        255 = ALREADY DISPLAYED\nDD@DSKEY DS    F                        SAVE FOR PDBDSKEY\nDD@RECCT DS    F                        SAVE FOR PDBRECCT\nDD@DEST  DS    CL4                      SAVE FOR PDBDEST\n          AIF   (&QLEVEL GE 5).DD96\nDD@FORMS DS    CL4                      SAVE FOR PDBFORMS\n          AGO   .DD97\n.DD96     ANOP\nDD@PNAME DS    CL8                      SAVE FOR PDBPNAME\nDD@SNAME DS    CL8                      SAVE FOR PDBSNAME\nDD@DDNAM DS    CL8                      SAVE FOR PDBDDNAM\nDD@FORMS DS    CL8                      SAVE FOR PDBFORMS\n.DD97     ANOP\nDD@FCB   DS    CL4                      SAVE FOR PDBFCB\nDD@UCS   DS    CL4                      SAVE FOR PDBUCS\nDD@LRECL DS    H                        SAVE FOR PDBLRECL\nDD@FLAG1 DS    B                        SAVE FOR PDBFLAG1\nDD@RECFM DS    X                        SAVE FOR PDBRECFM\nDD@CLASS DS    C                        SAVE FOR PDBCLASS\nDD@COPYS DS    AL1                      SAVE FOR PDBCOPYS\n         DS    0D                       make debugging easier\nDD@ENTL  EQU   *-DD@ENT\n         SPACE 3\n*%%      DROPX R13                      WORK\n         POP   PRINT\n         SPACE 3\n         Q$PDDB\n         Q$LRC\n         QZKEYS\n         QZTEXT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "Q#DD@": {"ttr": 5125, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x051\\x00\\x00\\x00\\x82#/\\x00\\x91!\\x7f\"\\x02\\x03\\xe8\\x02\\t\\x03O\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "05.49", "flags": 0, "createdate": "1982-08-20T00:00:00", "modifydate": "1991-08-05T22:02:00", "lines": 1000, "newlines": 521, "modlines": 847, "user": "LDW"}, "text": "         TITLE '--- QUEUE--DDNAME -- LIST DDNMS && DSIDS FOR A JOB ---'\n*---------------------------------------------------------------------*\n*                                                                     *\n*   DDNAME - List DDnames and DSIDs for a job                         *\n*                                                                     *\n*   Updates:                                                          *\n*      05Aug91  LDW  Integrate GLA fixes below (with minor changes,   *\n*                       except for DSID=0 problem fixed my way)       *\n*     (17Jul91) GLA  Day one bug handling *.step.pstep.ddn            *\n*     (10Jul91) GLA  Handle DynAlloc sysout that is not spin          *\n*                    Eliminate problem doing PRINT/COPY/SPIN of       *\n*                       wrong dataset from commandline after DD       *\n*                       command issued                                *\n*                    Correct display of DSID=0 datasets               *\n*      15Mar91  LDW  Adjust Pgm= and PDBFLAG1 display lines for ISPF  *\n*      20Dec90  LDW  Simplify previous update                         *\n*      28Nov90  EMS  Updates for SP410                                *\n*       7Aug90  EMS  Updates for SP313                                *\n*      20Jun90  LDW  Display 6 digit DSID                             *\n*      26Feb90  LDW  Fix typo in conditional assembly                 *\n*      25Dec89  LDW  Q$KEYS -> QZKEYS,  Q$TEXT -> QZTEXT              *\n*      12Dec89  LDW  Make OACFSORT expansion conditional (for Doron)  *\n*      23Nov89  LDW  Remove unnecessary Q$JCT                         *\n*      27Apr89  EMS  Updates for SP311                                *\n*      30Jan88  LDW  Fix dsid table too small problem, possibly       *\n*                       introduced by 9 July 87 update                *\n*      31Dec87  LDW  Fix PRINT GEN/NOGEN screwup in previous update   *\n*       9Aug87  EMS  Fix for procname = proc bug                      *\n*                    Fix for OACFSORT 0C3 abends                      *\n*                    Update for TERM=TS,SYSOUT= for TSU's             *\n*                    Fix for SYSOUT override bug                      *\n*       9Jul87  EMS  Use new table (QDSTART instead of QCSTART)       *\n*                    Update for QSORT macro changes                   *\n*                    Fix for tweaked line commands after \"s\" ln cmd   *\n*                    Add calls to GETPDDB, GETREC routines.           *\n*      21May87  LDW  Add translate for forms code                     *\n*      20May87  EMS  Fix fix for DSID = 0                             *\n*                    add call to QSORT                                *\n*      21Mar87  LDW  Fix for DSID = 0 (from RSCS)                     *\n*      25Jan87  LDW  Pass READSPC the JQE addr in case of CB ID error *\n*      17Jan87  LDW  Eliminate \"LC\" macro usage                       *\n*                    Misc cleanup                                     *\n*      26Nov86  EMS  FIX FOR MULTI-LEN SYSIN/OUT DSIDS                *\n*      04/03/86 LDW  USE SPECIFIC BIT NAMES IN QDEBUG                 *\n*      03/31/86 LDW  RE-DESIGN 3278-5 SUPPORT (THIRD TRY!)            *\n*                    SIMPLIFY STD FORMS CHECK                         *\n*      02/07/85 EMS  MAKE DEFAULT STD FORM AN ASM TIME OPTION         *\n*      01/30/85 LDW  CHANGE 'SJ' TO DEFAULT TO ONLY NON-EMPTY         *\n*                       DATASETS; ADD 'ALL' KEYWORD                   *\n*      01/27/85 LDW  FIX BUG:  CLEAR PROC NAME WHEN HIT NON-PROC EXEC *\n*                    FIX LINE CMDS ON JES2 DATASETS FOR QLEVEL > 4    *\n*      09/10/84 LDW  FIX FORMS CODE FOR NON-SP134 FORMS CODE          *\n*      08/09/84 LDW  UPDATE FOR SP134 (USE IOTPDDB INSTEAD OF         *\n*                       QCPDDB1),                                     *\n*                    ALLOW FOR PDDB 5 NOT BEING IN FIRST IOT          *\n*                    RE-ARRANGE FIELDS TO ALLOW FOR SP134 8 CHAR FORM *\n*                    CHANGE DISPLAY OF UNKNOWN DSTYPE FROM '??????'   *\n*                       TO 'UNKNWN'                                   *\n*      04/11/84 LDW  JCTDSECT -> JCTSTART, IOTDSECT -> IOTSTART       *\n*      01/23/84 LDW  ADD SUPPORT FOR COMMAND STACKING                 *\n*                    ADD SUPPORT FOR 'SJ' AND 'NS' SUBCOMMANDS        *\n*                    USING/DROP -> USNGX/DROPX                        *\n*      06/21/83 LDW  REFORMAT DISPLAY -- PUT STEP ON SEPARATE LINE,   *\n*                       ADD MORE LINE INFO (LIKE FORMS, ETC)          *\n*      03/01/83 LDW  ADD SUPPORT FOR LINE COMMANDS                    *\n*      02/16/83 LDW  CHECK FOR MULTIPLE DSN= ON A SYSOUT DD, AND USE  *\n*                       THE LAST INSTEAD OF THE FIRST.  THIS SOLVES   *\n*                       THE PROBLEM OF GETTING GARBAGE IF THE JCL IS  *\n*                       EXECUTING A PROC WITH A TRUE DSN IN IT, BUT   *\n*                       AN OVERRIDE TO SYSOUT IN THE JCL.             *\n*      02/09/83 LDW  IF PDDB 5 NOT FOUND, PUT MSG TO SCREEN INSTEAD   *\n*                       OF QTILT, AND CONTINUE WITH THE LIMITED INFO  *\n*                       IN IOTS.  THIS IS NEEDED BECAUSE WITH SP      *\n*                       JES2, A SYSOUT JOB THAT IS DUMPED AND THEN    *\n*                       RELOADED WILL NOT HAVE ANY INTERNAL TEXT.     *\n*                       IBM STRIKES AGAIN!!!                          *\n*                    CHANGE PDBFLAG EXPLANATIONS TO LOWER CASE        *\n*      01/19/83 LDW  USE FIRST BIT OF QDEBUG INSTEAD OF QM1PDBFL      *\n*      01/14/83 LDW  PRE-SCAN IOT'S AND BUILD IN-STORAGE TABLE SO     *\n*                       THAT WE ONLY READ THE IOT CHAIN ONCE.  THIS   *\n*                       WILL GIVE (POSSIBLE DRASTIC) PERFORMANCE      *\n*                       IMPROVEMENT FOR JOBS WITH MANY SPIN AND/OR    *\n*                       HELD DATASETS                                 *\n*                    REMOVE CODE TO SQUEEZE OUT ATTR BYTES FOR        *\n*                       NON-TUBE, SINCE \"DISPLAY\" NOW DOES IT         *\n*      01/04/83 LDW  FIX MINOR BUG CREATED BY DISPLAYING PDBFLAG1     *\n*                       EXPLANATIONS (THIS BUG ONLY APPEARED IF       *\n*                       \"MODE PDBFLAG1\" AND LAST STEP HAD NO SYSOUT   *\n*                       DD STATEMENTS!!)                              *\n*                    ADD WORKLEN=                                     *\n*      12/20/82 LDW  RE-ARRANGE OUTPUT COLUMNS                        *\n*                    DISPLAY SYSOUT DSIDS IN HIGH INTENSITY           *\n*                    PROVIDE INPUT FIELDS FOR LINE COMMANDS           *\n*                    CHANGE HEADER AND SOME OTHER DATA TO LOWER CASE  *\n*                    DON'T SUPPRESS ANYTHING IF QMODE PDBFLAG1        *\n*      12/08/82 LDW  USE $LRC MACRO SYMBOLS                           *\n*      10/28/82 LDW  PUT JOBID ON TOP LINE (QDTOP)                    *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 3\nDDNAME   QSTART  Q4,WORKLEN=DD@WORKL\n         USNGX WORK,R13\n         L     R0,QDSTART               -> current table\n         A     R0,QDSIZE                current size\n         SH    R0,=Y(DD@ENTL)           fudge - can't use last entry\n         ST    R0,DD@TBLEE              -> end of table\n         QCALL DISP80                   SWITCH TO 3278-2 MODE IF 3278-5\n         MVC   DD@PROCN,=CL8'(none)'    THERE IS NO PROCEDURE IN EFFECT\n***********************************************************************\n*                                                                     *\n*   CALL FINDJOB TO LOCATE THE JQE, JCT, AND IOT                      *\n*                                                                     *\n***********************************************************************\n         QCALL FINDJOB                  FIND THE JOB\n         OI    QSCFLAG1,QSC1JOB         PUT JOBID IN QDTOP\n***********************************************************************\n*                                                                     *\n*   READ ALL PDDB'S AND SAVE INTERESTING INFORMATION                  *\n*                                                                     *\n***********************************************************************\n         L     R7,QDSTART               -> TABLE START\n         USNGX DD@ENT,R7\n         MVI   DD@FLAGS,0\n         MVI   QGPFLAG,QPFINIT          init for call\nDD$PDBLP QCALL GETPDDB                  get a pddb\n         LTR   R2,R1                    any left?\n         BZ    DD$SORT                  no, sort table\n         USNGX PDBDSECT,R2\n          AIF  (&QLEVEL GE 9).DD01\n         LH    R1,PDBDSKEY              GET DSID\n          AGO  .DD02\n.DD01     ANOP ,\n         L     R1,PDBDSKEY              get dsid\n.DD02     ANOP ,\n*%%      LTR   R1,R1                    NULL PDDB?\n*%%      BZ    DD$NXPDB                 YES - IGNORE IT\n*%%      TM    PDBFLAG1,PDB1NULL        NULL PDDB?\n*%%      BNZ   DD$NXPDB                 YES - IGNORE IT\n*---  SAVE USEFUL INFORMATION FROM PDDB IN OUR OWN TABLE           ---*\n         MVC   DD@FLAG1,PDBFLAG1        SAVE FLAG BYTE\n         MVC   DD@RECFM,PDBRECFM        SAVE RECORD FORMAT\n         MVC   DD@LRECL,PDBLRECL        SAVE MAXIMUM RECORD LENGTH\n         ST    R1,DD@DSKEY              SAVE BINARY DSKEY\n         MVC   DD@CLASS,PDBCLASS        SAVE SYSOUT CLASS\n         MVC   DD@RECCT,PDBRECCT        SAVE RECORD COUNT\n         MVC   DD@COPYS,PDBCOPYS        SAVE COPY COUNT\n         MVC   DD@DEST,PDBDEST          SAVE DEST (BINARY)\n**%%     MVC   DD@USER,PDBUSER          SAVE DEST USERID/RMTID\n         MVC   DD@FORMS,PDBFORMS        SAVE FORMS CODE\n         L     R15,=V(CHARTAB)          -> translate table\n         TR    DD@FORMS,0(R15)          translate to valid chars\n         CLC   DD@FORMS,=CL8'&@@QSTDF'  DEFAULT?\n         BNE   *+10                     NO - KEEP IT\n         MVC   DD@FORMS,QBLANK          YES - CLEAR IT\n         MVC   DD@FCB,PDBFCB            SAVE FCB ID\n         CLC   =C'****',DD@FCB          DEFAULT?\n         BNE   *+10                     NO - KEEP IT\n         MVC   DD@FCB,QBLANK            YES - CLEAR IT\n         MVC   DD@UCS,PDBUCS            SAVE UCS ID\n         CLC   =C'****',DD@UCS          DEFAULT?\n         BNE   *+10                     NO - KEEP IT\n         MVC   DD@UCS,QBLANK            YES - CLEAR IT\n**%%     MVC   DD@CHARS(4*4),PDBCHAR1   SAVE ALL 4 XLATE TAB NAMES\n         CLC   DD@UCS,QBLANK            ANYTHING HERE?\n         BNE   *+10                     YES - KEEP IT\n         MVC   DD@UCS,PDBCHAR1          NO - USE FIRST CHARS= NAME\n         CLC   =C'****',DD@UCS          DEFAULT?\n         BNE   *+10                     NO - KEEP IT\n         MVC   DD@UCS,QBLANK            YES - CLEAR IT\n**%%     MVC   DD@FLASH,PDBFLASH        SAVE FLASH ID\n**%%     MVC   DD@MODF,PDBMODF          SAVE COPY MOD IMAGE\n          AIF   (&QLEVEL LT 5).DD03\n         MVC   DD@PNAME,PDBPNAME        SAVE PROC STEP NAME\n         MVC   DD@SNAME,PDBSNAME        SAVE STEP NAME\n         MVC   DD@DDNAM,PDBDDNAM        SAVE DD NAME\n.DD03     ANOP\n         MVI   DD@XFLAG,0               CLEAR DISPLAY FLAG\n         LA    R7,DD@ENTL(,R7)          -> NEXT TABLE ENTRY\n         C     R7,DD@TBLEE              TABLE OVERFLOW?\n         BL    DD$NXLST                 no, continue\n***********************************************************************\n*                                                                     *\n*   DATASET RECORD NUMBER TABLE IS TOO SMALL.  TRY TO GET A BIGGER    *\n*   ONE, COPY THE INFORMATION, AND FREE THE OLD ONE.  WE WILL TRY     *\n*   FOR ONE 4 TIMES THE SIZE, SO WE WILL GO FROM THE ORIGINAL 8K TO   *\n*   32K.  IF THAT ONE IS TOO SMALL, WE WILL GO TO 256K.  IF THAT      *\n*   ONE IS TOO SMALL, YOU BETTER BE LOGGED ON IN A MONSTER REGION.    *\n*                                                                     *\n***********************************************************************\n         S     R7,QDSTART               get offset\n         STM   R14,R12,12(R13)          stash for a sec\n         L     R2,QDSIZE                get current size\n         LR    R7,R2                    copy for later\n         SLL   R2,2                     multiply by 4\n         GETMAIN  RC,LV=(R2),SP=1       get new workarea\n         LTR   R15,R15                  did it work?\n         BNZ   DD$TILT1                 no, exit stage right\n         LR    R6,R1                    mvcl - target addr\n         LR    R0,R1                    mvcl - target addr\n         LR    R1,R2                    mvcl - target length\n         LR    R15,R7                   mvcl - source length\n         L     R14,QDSTART              mvcl - source addr\n         MVCL  R0,R14                   copy table\n         LR    R0,R7                    point to old table\n         ICM   R0,B'1000',=AL1(1)       set subpool\n         L     R1,QDSTART               ditto addr\n         FREEMAIN  R,LV=(0),A=(1)       free old table\n         ST    R6,QDSTART               set\n         ST    R2,QDSIZE                   new\n         AR    R6,R2                          table\n         SH    R6,=Y(DD@ENTL)           fudge - can't use last entry\n         ST    R6,DD@TBLEE              save for later\n         LM    R14,R12,12(R13)          restore regs\n         A     R7,QDSTART               new addr\nDD$NXLST MVC   DD@DSKEY,=X'EEEEEEEE'    flag it as end of table\n         MVI   DD@FLAG1,0               clear flag\n         B     DD$PDBLP                 get next pddb\n         DROPX R7,R2                    DD@ENT, PDDB\nDD$SORT  QSORT ADDR=QDSTART,LEN==A(DD@ENTL),COMP==A(DD$CMP),OFFSET=R7, $\n               PREFIX=DD\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*   IF 'SJ' SUBCOMMAND, CREATE DSID TABLE FOR 'NS' SUBCOMMAND --LDW-- *\n*                                                                     *\n***********************************************************************\nDD$SJCHK CLI   QCODE,4                  SJ?\n         BNE   DD$SYSGO                 NO - CONTINUE NORMAL 'DD'\n         CLI   QKEYWORD,C'A'            'ALL' SPECIFIED?\n         BNE   *+8                      NO - SKIP\n         OI    DD@FLAGS,DD@FSJAL        YES - REMEMBER\n         L     R1,QCDDTBLA              -> CURRENT TABLE\n         S     R7,QDSTART               COMPUTE TABLE LENGTH\n         SR    R6,R6                    CLEAR FOR DIVIDE\n         D     R6,=A(DD@ENTL)           COMPUTE NUMBER OF ENTRIES\n         LA    R7,2(,R7)                ACCOUNT FOR START AND END\n         SLL   R7,2                     times entry length\n         C     R7,QCDDTBLL              NEED BIGGER THAN CURRENT?\n         BL    DD$SJ$02                 NO - OK\n         L     R0,QCDDTBLL              GET CURRENT LENGTH\n         LTR   R0,R0                    ANY CURRENT TABLE?\n         BZ    DD$SJ$01                 NO - DON'T FREEMAIN\n         SPACE 1\n         FREEMAIN  RU,LV=(0),A=(1),SP=3 FREE OLD TABLE\n         SPACE 2\nDD$SJ$01 GETMAIN  RU,LV=(R7),SP=3       GET A NEW TABLE\n         SPACE 1\n         ST    R7,QCDDTBLL              SAVE LENGTH OF NEW TABLE\n         ST    R1,QCDDTBLA              SAVE ADDR\n         ST    R1,QCDDTBLE              SET 'CURRENT ENTRY' POINTER\n         SPACE 2\nDD$SJ$02 MVC   0(2,R1),=C'*T'           INDICATE TOP\n         LA    R1,4(,R1)                -> NEXT ENTRY\n         L     R7,QDSTART               -> DDNAME'S DSID TABLE\n         USNGX DD@ENT,R7\n         SPACE 1\nDD$SJ$LP TM    DD@FLAG1,PDB1NSOT        'NOT FOR SYSOUT'?\n         BO    DD$SJNXT                 RIGHT - SKIP\n         TM    DD@FLAGS,DD@FSJAL        'ALL'?\n         BO    DD$SJ$SV                 YES - SAVE THIS ENTRY\n         TM    DD@FLAG1,PDB1NULL        'NULL PDDB'?\n         BNZ   DD$SJNXT                 YES - SKIP IT\nDD$SJ$SV MVC   0(4,R1),DD@DSKEY         SAVE BINARY DSKEY\n         LA    R1,4(,R1)                -> NEXT 'NS' TABLE ENTRY\nDD$SJNXT LA    R7,DD@ENTL(,R7)          -> NEXT 'DD' TABLE ENTRY\n         CLC   DD@DSKEY,=X'EEEEEEEE'    end of table?\n         BNE   DD$SJ$LP                 NO - CONTINUE LOOP\n         MVC   0(2,R1),=C'*E'           INDICATE END OF TABLE\n         MVC   QKEYWORD(16),=CL16'TOP'\n         MVI   QCODE,16                 SET \"NS\"\n         QCALL LIST                     GO DISPLAY THE FIRST DATASET\n         B     QSTOP                    LEAVE WHEN HE LEAVES\n         DROPX R7                       DD@ENT\n***********************************************************************\n*                                                                     *\n*   SHOW RECORD COUNTS FOR JES2 SPOOLED DATASETS              --LDW-- *\n*                                                                     *\n***********************************************************************\nDD$SYSGO QSTACK  X'20'                  PUT 'DD' SUBCOMMAND ON STACK\n         MVC   QDHLINE,=CL79'    DDname     DSid    DStype Records Cl  $\n               Dest   Copies Ucs  Fcb  Forms'\n         MVC   QDLCTBL,=V(PA#LC#DD)     SET ADDR OF LINE COMMANDS TABLE\n         MVC   QCDDTBLE,QCDDTBLA        INIT DSID TAB CURRENT ENT PTR\n         L     R7,QDSTART               -> IN-STORAGE DSID TABLE\n         USNGX DD@ENT,R7\n         SPACE 1\nDD$SYSLP CLC   =X'EEEEEEEE',DD@DSKEY    end of table?\n         BE    DDJOB                    YES - GO PROCESS NORMAL DSID'S\n         L     R1,DD@DSKEY              GET DSID\n         B     DD$SYOUT                 %%%%%%\n         TM    DD@FLAG1,PDB1NSOT        NOT FOR SYSOUT?\n         BZ    DD$SYOUT                 NO - IT'S FOR SYSOUT\n         CH    R1,=H'2'                 IT IS 2 THRU 4?\n         BL    DD$SYOUT                 NO - OK\n         CH    R1,=H'4'                 IT IS 2 THRU 4?\n         BNH   DD$SYSNX                 YES - IGNORE IT BECAUSE IT IS\n*                                       MARKED \"NOT FOR SYSOUT\" AND IS\n*                                       THE JOBLOG, JOBMSG, OR JCL DS,\n*                                       WHICH ARE DUPLICATED ON THE\n*                                       SPIN IOT WITHOUT THE \"NOT FOR\n*                                       SYSOUT\" FLAG SET.\n         SPACE 1\nDD$SYOUT CH    R1,=H'100'               A PROBLEM PROGRAM DATASET?\n         BH    DD$SYSNX                 YES - IGNORE ON THIS PASS\n         CH    R1,=H'1'                 INPUT JCL?\n         BE    DD$AUTH1                 YES - SHOW ONLY TO AUTH USERS\n         BL    DD$SYSNX                 ignore VM/VSE oddity this pass\n         CH    R1,=H'4'                 JOBLOG/JCL/JOBMSG?\n         BH    DD$AUTH1                 NO - SHOW ONLY TO AUTH USERS\n         MVC   DDATTR1,=X'1DC8'         SET INPUT, BRIGHT\n         MVC   DDATTR2,=X'1D60'         SET OUTPUT, NORMAL\n         MVC   DDATTR3,=X'1DE8'         SET OUTPUT, BRIGHT\n         B     DD$SYSDS                 CONTINUE\nDD$AUTH1 TM    QXAUTH,QXPSWD+QXSYSP     AUTHORIZED USER?\n         BZ    DD$SYSNX                 NO - DON'T DISPLAY THIS DSID\n         MVC   DDATTR1,=X'1DE8'         SET OUTPUT, BRIGHT\n         MVC   DDATTR2,=X'1D60'         SET OUTPUT, NORMAL\n         MVC   DDATTR3,=X'1D60'         SET OUTPUT, NORMAL\nDD$SYSDS MVC   DDATTR4,=X'1D60'         SET OUTPUT, NORMAL\n         MVI   QDATRNUM+1,4             SET # OF ATTR BYTES IN LINE\n         MVC   DDDSTYPE,=C'$$JES2'      MOVE IN SYSTEM DSTYPE\n*---  SAVE DATA IN ARRAY FOR LINE COMMANDS                         ---*\n         XC    DD@TPTR(LCBELEN),DD@TPTR INIT ARRAY ELEMENT\n         MVI   DD@ADDR1+3,DDSELECT-QDMSG  OFFSET INTO LINE OF 1ST FIELD\n         MVC   DD@FLD1(2+8),QBLANK\n         MH    R1,=H'6'                 MULTIPLY DSID BY entry length\n         LA    R1,DDCMDSYS-6(R1)        -> SUBCMD TO USE IF LINE SELECT\n         MVC   DD@ID,0(R1)              SAVE FOR DD@ID\n          AIF   (&QLEVEL GE 5).DD04\n         L     R1,DD@DSKEY              GET DSID\n         MH    R1,=H'6'                 ENTRIES ARE 6 BYTES EACH\n         LA    R1,DSIDTYPE-6(R1)        -> TYPE\n         MVC   DDDSTYPE,0(R1)           MOVE IN SYSTEM DSTYPE\n.DD04     ANOP\n         BAL   R8,DD$FMT                FMT DSID/RECCT/CLASS/HOLD/PRINT\n         TM    QXAUTH,QXPSWD+QXSYSP     AUTHORIZED USER?\n         BNZ   *+10                     YES - DISPLAY DSID\n         MVC   DDDSID,QBLANK            NO - CLEAR DSID FIELD\n         LA    R1,DD@TPTR               -> MY ARRAY ELEMENT\n         QCALL DISPADDX                 ADD THIS LINE TO SCREEN\nDD$SYSNX LA    R7,DD@ENTL(,R7)          -> NEXT DSID TABLE ENTRY\n         B     DD$SYSLP                 GO PROCESS\n         DROPX R7                       DD@ENTL\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*   LOCATE PDDB NUMBER 5                                              *\n*                                                                     *\n***********************************************************************\n          AIF  (&QLEVEL GE 9).DD05\nDDJOB    MVC   QPDSID,=H'5'             get it\n          AGO  .DD06\n.DD05     ANOP ,\nDDJOB    MVC   QPDSID,=F'5'             get it\n.DD06     ANOP ,\n         NI    QFLAG2,255-Q2VALIDS      MARK NO VALID DS\n         MVC   QDHDSID,=CL8'5'          set if needed\n         MVI   QGPFLAG,QPFDIR+QPFNMSG   this one, no msg\n         QCALL GETPDDB                  get it\n         LTR   R2,R1                    find it?\n         BP    DDFOUNDD                 yes, continue\n         USNGX PDBDSECT,R2\n******** QTILT '*** JOB DOES NOT HAVE DD TABLE ***'\n         OI    DD@FLAGS,DD@FNOTX        REMEMBER NO INTERNAL TEXT\n          AIF   (&QLEVEL GE 5).DD07\n         MVC   QDMSG(NOTXTMGL),NOTXTMSG DISPLAY MESSAGE TO THAT EFFECT\n         MVI   QDATRNUM+1,2             NUMBER OF ATTR BYTES IN LINE\n         BAL   R14,QADDLINE             PUT MESSAGE TO SCREEN\n.DD07     ANOP\n         B     DDSPIN                   GO FORMAT FROM IN-STORAGE TABLE\n         SPACE 2\nDDFOUNDD MVC   QCGRMTTR,PDBMTTR         DISK ADDR OF FIRST BLOCK\n         DROPX R2                       PDDB\n         MVI   QCRFLAG,QRFINIT          start at top of dataset\n***********************************************************************\n*                                                                     *\n*   PROCESS RECORDS                                                   *\n*                                                                     *\n***********************************************************************\n         USNGX LRCDSECT,R4\nDDNXTREC QCALL GETREC                   get a record\n         LTR   R4,R4                    eof?\n         BZ    DDSPIN                   yes, get spin datasets\n         TM    LRCFLAG1,LRC1SPAN        IS THIS A SPANNED RECORD?\n         BO    DDNXTREC                 yes, skip it.\n         TM    LRCTEXT+2,EXECSTR        IS THIS AN EXEC RECORD?\n         BO    DDEXEC                   YES. PROCESS IT.\n         TM    LRCTEXT+2,DDSTR          IS THIS A DD RECORD?\n         BO    DD$DD                    YES. PROCESS IT.\n         B     DDNXTREC                 otherwise, ignore record.\n***********************************************************************\n*                                                                     *\n*   PROCESS AN EXEC RECORD                                            *\n*                                                                     *\n***********************************************************************\nDDEXEC   CLI   LRCTEXT+STREKEY-TEXT,EXECK  IS THERE A STEPNAME?\n         BNE   DDNXTREC                 No, skip this record.\n         SR    R1,R1                    CLEAR FOR IC\n         IC    R1,LRCTEXT+STREKEY+2-TEXT  LENGTH OF PROCSTEP/STEPNAME\n         TM    LRCTEXT+STREINDC-TEXT,ETXPRCV  EXEC PROC=XXXX?\n         BO    DDEXPROC                 YES - HANDLE IT\n         TM    LRCTEXT+STREINDC-TEXT,ETXPROC  IN A PROC?\n         BO    *+10                     YES - KEEP PROC NAME\n         MVC   DD@PROCN,=CL8'(none)'    NO - CLEAR THE FIELD\n         MVC   QDMSG(2),=X'1DE8'        SET OUTPUT, BRIGHT\n         MVC   QDMSG+2(2),=C'- '        START THE SEPARATOR LINE\n         MVC   QDMSG+4(76),QDMSG+2      PROPAGATE THE SEPARATOR\n         MVC   QDMSG+80(2),=X'1D60'     SET OUTPUT, NORMAL\n         MVI   QDATRNUM+1,2             SET # OF ATTR BYTES IN LINE\n         STM   R14,R1,DD@REGSV          SAVE VOLATILE REGS TEMPORARILY\n         BAL   R14,QADDLINE             ADD THE SEPARATOR LINE\n         LM    R14,R1,DD@REGSV          RESTORE VOLATILE REGS\n         MVC   DDSTEPLN,DD#STHDR        MOVE IN HEADING\n         MVC   DDPROCN,DD@PROCN         MOVE IN PROCNAME\n*  ASSUME (FOR LACK OF KNOWLEDGE TO THE CONTRARY) THAT IT'S PGM=\n*---  ASSUME NOT IN PROC, SET UP ACCORDINGLY                       ---*\n         LA    R15,DDSTEPN              -> WHERE THE STEPNAME WILL GO\n         TM    LRCTEXT+STREINDC-TEXT,ETXPROC  IN A PROC?\n         BNO   DDEXNOPR                 NO - HANDLE IT\n*---  IN A PROC -- MUST FLOAT A '.' AND THE STEPNAME               ---*\n         MVC   DDSTEPN,DD@PSTEP         MOVE IN PROCSTEPNAME\n         LA    R15,1(,R15)              -> NEXT POSSIBLE POSITION\n         CLI   0(R15),C' '              END OF PROCSTEPNAME?\n         BNE   *-8                      NO - KEEP LOOKING\n         MVI   0(R15),C'.'              ADD THE SEPARATOR\n         LA    R15,1(,R15)              AND BUMP PAST IT\n         B     DDEXINPR                 CONTINUE\n         SPACE 1\nDDEXNOPR MVC   DD@PSTEP,=CL8'(none)'    THERE IS NO PROCEDURE IN EFFECT\n         SPACE 1\nDDEXINPR MVC   0(8,R15),=CL8'(none)'    CLEAR IT WITH ' (NONE) '\n         MVC   DDPGM,=CL8'(none)'       AND THIS TOO\n         SH    R1,=H'1'                 -1 FOR EX\n         BM    DDNSTEP1                 SKIP IF NO STEPNAME\n         MVC   0(8,R15),QBLANK          CLEAR THE FIELD FIRST\n         EX    R1,DDMVCST               MOVE THE STEPNAME\nDDNSTEP1 LA    R15,LRCTEXT+STREKEY+3-TEXT+1(R1) POINT TO PGMNAME KEY\n         CLI   0(R15),PGMEK             IS THIS THE PROGRAM NAME?\n         BNE   DDEXECOK                 NO - DONE WITH THIS RECORD\n***      CLI   2(R15),X'83'             IS THIS PGM=*.STEP.DDNAME?\n***      BE    DDEXSTAR                 YES - HANDLE IT\n         TM    2(R15),X'80'             IS THIS MANY PIECES?\n         BO    DDEXSTAR                 YES - must be PGM=*.S.PS.DDN\n         SR    R1,R1                    CLEAR FOR IC\n         IC    R1,2(,R15)               GET PGMNAME LENGTH\n         SH    R1,=H'1'                 -1 FOR EX\n         BM    DDEXECOK                 DONE - GO DISPLAY THIS STEP\n         MVC   DDPGM,QBLANK             CLEAR THE FIELD\n         EX    R1,DDMVCPGM              MOVE PGM NAME\n*     (  B     DDEXECOK  )              CONTINUE PROCESSING\n         SPACE 2\nDDEXECOK MVI   QDATRNUM+1,2             SET # OF ATTR BYTES IN LINE\n         QCALL DISPADD                  ADD THIS LINE TO SCREEN\n         B     DDNXTREC                 All done\n         SPACE 2\nDDMVCST  MVC   0(*-*,R15),LRCTEXT+STREKEY+3-TEXT << EXECUTED >>\nDDMVCPGM MVC   DDPGM(*-*),3(R15)        << EXECUTED >>\n         SPACE 1\nDDEXSTAR MVC   DDPGM,=C'*.DDNAME'       THE REAL WHOLE THING WON'T FIT\n         B     DDEXECOK                 IGNORE THE REST OF THE RECORD\n         SPACE 1\n*---  THIS INTERNAL TEXT RECORD IS FOR EXEC PROC=XXX.              ---*\n*---  SAVE THE INFO FOR DISPLAY BY REGULAR EXEC PGM= CODE.         ---*\nDDEXPROC MVC   DD@PROCN,=CL8'(none)'    CLEAR THE FIELD\n         MVC   DD@PSTEP,=CL8'(none)'    AND THIS ONE ALSO\n         SH    R1,=H'1'                 -1 FOR EX\n         BM    DDEXPR$1                 SKIP IF NONE\n         MVC   DD@PSTEP,QBLANK          BLANK THE FIELD\n         EX    R1,DDMVCPS               SAVE STEPNAME\nDDEXPR$1 LA    R15,LRCTEXT+STREKEY+3-TEXT+1(R1) -> PROCNAME OR NXT UNIT\n         CLI   LRCTEXT+STREKEY+1-TEXT,2 ARE THERE 2 POSITIONAL UNITS?\n         BE    DDEXPROX                 YES - GO PROCESS IT\n         CLI   0(R15),PROCEK            EXPLICIT EXEC PROC= ?\n         BNE   DDNXTREC                 No - get out\n         LA    R15,2(,R15)              POINT TO PROCNAME LENGTH\nDDEXPROX SR    R1,R1                    CLEAR FOR IC\n         IC    R1,0(,R15)               GET PROCNAME LENGTH\n         SH    R1,=H'1'                 -1 FOR EX\n         BM    DDNXTREC                 Ignore if none\n         MVC   DD@PROCN,QBLANK          BLANK THE FIELD\n         EX    R1,DDMVCPR               MOVE PROCNAME\n         B     DDNXTREC                 Done with this record\n         SPACE 2\nDDMVCPS  MVC   DD@PSTEP(*-*),LRCTEXT+STREKEY+3-TEXT << EXECUTED >>\nDDMVCPR  MVC   DD@PROCN(*-*),1(R15)     << EXECUTED >>\n***********************************************************************\n*                                                                     *\n*   PROCESS DD RECORDS                                                *\n*                                                                     *\n***********************************************************************\nDD$DD    TM    LRCTEXT+STRDINDC-TEXT,DTXSYSIN+DTXSYOUT SYSIN/SYSOUT DD?\n         BZ    DDNXTREC                 No. skip the record.\n         XC    DD@ADSNK,DD@ADSNK        NO DSN= TEXT UNIT YET\n         NI    DD@FLAGS,255-DD@FTS      reset bit\n         LA    R7,LRCTEXT+STRDKEY-TEXT  ADDR OF FIRST KEY\n         LR    R8,R6                    REMAINING LENGTH OF RECORD\n         SR    R15,R15                  CLEAR FOR IC\n         SR    R14,R14                  CLEAR FOR IC\n         SR    R1,R1                    CLEAR FOR IC\nDDTRYFLD CLI   0(R7),DSNAMEK            IS THIS THE DSNAME?\n         BE    DD$DSKEY                 YES. PROCESS IT.\n          AIF   (&QLEVEL GE 5).DD08      DON'T NEED TO FIND DDN IF 134\n         CLI   0(R7),DDK                IS THIS THE DDNAME?\n         BE    DDKEY                    YES. PROCESS IT.\n.DD08     ANOP\n         CLI   0(R7),TERMK              term=ts?\n         BE    DD$TERM                  YES. PROCESS IT.\nDDNXTFLD IC    R1,1(,R7)                NUMBER OF SUBFIELDS\n         LA    R7,2(,R7)                UPDATE LOCATION\n         SH    R8,=H'2'                 REMAINING COUNT\n         SR    R8,R1                    REMAINING COUNT\n         BNP   DDENDREC                 REC IS EXHAUSTED - CHK FOR DSN=\n         LTR   R1,R1                    ARE THERE ANY SUBFIELDS?\n         BZ    DDTRYFLD                 NO. TRY NEXT FIELD.\nDDLPFLD  TM    0(R7),X'80'              IS THIS A SUB-SUB-FIELD\n         BZ    DDNOSUB                  NO. CONTINUE.\n         IC    R14,0(,R7)               NUMBER OF SUB-SUB-FIELDS\n         N     R14,=A(X'7F')            CLEAR THE HEX 80 BIT\n         LA    R7,1(,R7)                UPDATE LOCATION\n         SH    R8,=H'1'                 REMAINING COUNT\n         SR    R8,R14                   REMAINING COUNT\n         BNP   DDNXTREC                 Record is exhausted\n         AR    R1,R14                   INCREASE NUMBER OF SUBFIELDS\n         B     DDYESSUB                 DECREMENT AND TRY AGAIN\nDDNOSUB  IC    R15,0(,R7)               SUBFIELD LENGTH\n         LA    R7,1(R15,R7)             ADD TO LOCATION\n         SR    R8,R15                   REMAINING COUNT\n         BNP   DDNXTREC                 Record is exhausted\nDDYESSUB BCT   R1,DDLPFLD               DO NEXT SUBFIELD\n         B     DDTRYFLD                 TRY NEXT FIELD\n          AIF   (&QLEVEL GE 5).DD09\nDDKEY    IC    R1,2(,R7)                LENGTH OF DDNAME\n         LTR   R1,R1                    IS THE LENGTH ZERO?\n         BZ    DDNXTFLD                 YES. SKIP THE FIELD.\n         BCTR  R1,0                     DECREMENT BY 1\n         EX    R1,DDMVCDDN              MOVE THE DDNAME\n         B     DDNXTFLD                 PROCESS NEXT FIELD\n.DD09     ANOP\nDD$TERM  OI    DD@FLAGS,DD@FTS          indicate presence of TERM=TS\n         B     DDNXTFLD                 GO PROCESS NEXT TEXT UNIT\nDD$DSKEY ST    R7,DD@ADSNK              SAVE PTR TO DSN= TEXT UNIT\n         B     DDNXTFLD                 GO PROCESS NEXT TEXT UNIT\nDDENDREC L     R7,DD@ADSNK              -> LAST DSN= TEXT UNIT, IF ANY\n         LTR   R7,R7                    ANY?\n         BZ    DDNXTREC                 No - go on to next record\n         CLC   =C'TSU',8(R7)            this a tsu?\n         BNE   *+4+4+4                  no, continue\n         TM    DD@FLAGS,DD@FTS          term=ts present?\n         BO    DDNXTREC                 yes, ignore dsn.\n*        MVC   DDDSID,19(R7)            MOVE THE DSID\n         XR    R1,R1                    CLEAR FOR IC\n         IC    R1,LRCLRECL-LRCDSECT(,R7) GET LEN OF DSN FIELD\n         LA    R1,LRCTEXT-LRCDSECT(R1,R7)  START OF NEXT FIELD\n          AIF   (&QLEVEL LT 10).DD10     dsn format changed at 313\n*        the following loop gets rid of the \"dataset type\" suffix\n         BCTR  R1,0                     back 1 char\n         CLI   0(R1),C'.'               qualifier delimiter?\n         BNE   *-4-2                    no, try again\n.DD10     ANOP\n         SH    R1,=Y(L'DDDSID)          LESS LEN OF OUTPUT FIELD\n         MVC   DDDSID,0(R1)             MOVE IN LAST PORTION OF DSID\n*        CLI   DDDSID,C'0'              LEADING 0?\n*        BNE   *+8                      NO - SKIP\n*        MVI   DDDSID,C' '              YES - MAKE IT A BLANK\n         PACK  DDN@DWD,DDDSID\n         MVC   DDN@TEMP,=X'4020202020202120'      ID\n         ED    DDN@TEMP,DDN@DWD+4\n         MVC   DDDSID,DDN@TEMP+2\n         CVB   R0,DDN@DWD               GET DSID IN BINARY\n         MVC   DDDSTYPE,=C'*ERROR'      INIT FIELD\n         TM    LRCTEXT+STRDINDC-TEXT,DTXSYOUT  SYSOUT?\n         BNO   *+10                     NO - SKIP\n         MVC   DDDSTYPE,=C'Sysout'      'SYSOUT'\n         TM    LRCTEXT+STRDINDC-TEXT,DTXSYSIN  SYSIN?\n         BNO   *+10                     NO - SKIP\n         MVC   DDDSTYPE,=C'Sysin '      'SYSIN '\n         TM    LRCTEXT+STRDINDC-TEXT,DTXSYOUT+DTXSYSIN  BOTH????\n         BNO   *+10                     NO - SKIP\n         MVC   DDDSTYPE,=C'ERROR*'\n         DROPX R4                       LRC\n***********************************************************************\n*   FIND IN-STORAGE TABLE ENTRY FOR THIS PDDB                         *\n*   EXTRACT RECORD COUNT, CLASS, HOLD, PRT, ETC                       *\n***********************************************************************\n         L     R7,QDSTART               -> IN-STORAGE TABLE\n         USNGX DD@ENT,R7\nDD$TBLLP CLC   =X'EEEEEEEE',DD@DSKEY    END OF TABLE?\n         BE    DD$TBLNF                 YES - NOT FOUND\n         C     R0,DD@DSKEY              THIS THE ENTRY?\n         BE    DD$TBLOK                 YES - GO FORMAT DATA\n         LA    R7,DD@ENTL(,R7)          -> NEXT TABLE ENTRY\n         B     DD$TBLLP                 KEEP LOOKING\nDD$TBLOK BAL   R8,DD$FMT2               FORMAT RECCT/CLASS/HOLD/PRINT\n         DROPX R7                       DD@ENT\n***********************************************************************\n*   BUILD THE OUTPUT LINE                                             *\n***********************************************************************\nDD$TBLNF MVC   DDATTR1,=X'1DC8'         SET INPUT, BRIGHT\n         MVC   DDATTR2,=X'1D60'         SET OUTPUT, NORMAL\n         MVC   DDATTR3,=X'1DE8'         SET OUTPUT, BRIGHT\n         CLC   =C'Sysout',DDDSTYPE      IS THIS A SYSOUT DATASET?\n         BE    *+8                      YES - OK\n         MVI   DDATTR3+1,X'60'          SET OUTPUT, NORMAL\n         MVC   DDATTR4,=X'1D60'         SET OUTPUT, NORMAL\n         MVI   QDATRNUM+1,4             SET # OF ATTR BYTES IN LINE\n*---  SAVE DATA IN ARRAY FOR LINE COMMANDS                         ---*\n         XC    DD@TPTR(LCBELEN),DD@TPTR INIT ARRAY ELEMENT\n         MVI   DD@ADDR1+3,DDSELECT-QDMSG  OFFSET INTO LINE OF 1ST FIELD\n         MVC   DD@ID,DDDSID             DSID\n         MVC   DD@FLD1(2+8),QBLANK\n         LA    R1,DD@TPTR               -> MY ARRAY ELEMENT\n         QCALL DISPADDX                 ADD THIS LINE TO SCREEN\n         B     DDNXTREC                 Process next record\n*%%DDTILT1  QTILT '*** DSID TABLE OVERFLOW ***'\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*   PROCESS SPUN OFF DATASETS                                         *\n*                                                                     *\n***********************************************************************\nDDSPIN   L     R7,QDSTART               -> IN-STORAGE PDDB TABLE\n         USNGX DD@ENT,R7\n         MVC   DD@PSTEP,=X'EFFEEFFE'    CLEAR\n         MVC   DD@STEP,=X'EFFEEFFE'     CLEAR\nDDSPIN10 CLC   =X'EEEEEEEE',DD@DSKEY    end of table?\n         BE    DDSPIN90                 YES - ALL DONE HERE\n         MVI   DD@STAR,C' '             ASSUME NOTHING WEIRD\n         TM    DD@FLAGS,DD@FNOTX        INTERNAL TEXT UNAVAILABLE?\n         BO    DDSPIN20                 YES - DISPLAY THIS ENTRY\n***      TM    DD@FLAG1,PDB1SPIN        SPIN DATASET?\n***      BO    DDSPIN20                 YES - DISPLAY IT\n         TM    DD@FLAG1,PDB1SPIN+PDB1PSO  PROCESSABLE??\n         BNZ   DDSPIN20                 YES - DISPLAY IT\n         TM    QDEBUG1,QDEBUG11         DEBUGGING?\n         BNO   DDSPIN50                 NO - SKIP THIS ENTRY\n         CLI   DD@XFLAG,255             THIS ENTRY ALREADY DISPLAYED?\n         BE    DDSPIN50                 YES - SKIP IT\n         MVI   DD@STAR,C'*'             NO - INDICATE IT WOULD HAVE\n*                                            HAVE BEEN SUPPRESSED\n         B     DDSPIN30                 CONTINUE\nDDSPIN20 CLI   DD@XFLAG,255             THIS ENTRY ALREADY DISPLAYED?\n         BNE   DDSPIN25                 NO - CONTINUE\n         TM    QDEBUG1,QDEBUG11         DEBUGGING?\n         BNO   DDSPIN50                 NO - SKIP IT\n         MVI   DD@STAR,C'<'             YES - FLAG SOMETHING FISHY HERE\n         B     DDSPIN30                 and, display it\nDDSPIN25 TM    DD@FLAG1,PDB1NULL+PDB1NSOT  null pddb entry?\n         BZ    DDSPIN30                 no, continue\n         TM    QDEBUG1,QDEBUG11         DEBUGGING?\n         BNO   DDSPIN50                 NO - SKIP IT\nDDSPIN30 EQU   *\n          AIF   (&QLEVEL LT 5).DD11\n         CLC   DD@PSTEP,DD@PNAME        DID PROCSTEPNAME CHANGE?\n         BE    DDSPIN40                 NO - SKIP\n         CLC   DD@STEP,DD@SNAME         DID STEPNAME CHANGE?\n         BE    DDSPIN40                 NO - SKIP\n         MVC   DD@PSTEP,DD@PNAME        SAVE NEW PROCSTEPNAME\n         MVC   DD@STEP,DD@SNAME         SAVE NEW STEPNAME\n         MVC   QDMSG(2),=X'1DE8'        SET OUTPUT, BRIGHT\n         MVC   QDMSG+2(2),=C'- '        START THE SEPARATOR LINE\n         MVC   QDMSG+4(76),QDMSG+2      PROPAGATE THE SEPARATOR\n         MVC   QDMSG+80(2),=X'1D60'     SET OUTPUT, NORMAL\n         MVI   QDATRNUM+1,2             SET # OF ATTR BYTES IN LINE\n         BAL   R14,QADDLINE             ADD THE SEPARATOR LINE\n         MVC   DDSTEPLN,DD#STHDR        MOVE IN HEADING\n         MVC   DDPGM,=C'*UNKNOWN'       MOVE IN PGMNAME\n         MVC   DDPROCN,=C'*UNKNOWN'     MOVE IN PROCNAME\n         MVC   DDSTEPN,DD@PNAME         MOVE IN PROCSTEPNAME\n         CLC   DDSTEPN,QBLANK           ANY PROCSTEPNAME?\n         BE    DDSPIN37                 NO - PUT STEPNAME HERE\n         CLC   DD@SNAME,QBLANK          ANY STEPNAME?\n         BE    DDSPIN39                 NO - DON'T PUT IN THE DOT\n*---  FLOAT A '.' AND THE STEPNAME                                 ---*\n         LA    R15,DDSTEPN              -> START OF FIELD\n         LA    R15,1(,R15)              -> NEXT POSSIBLE POSITION\n         CLI   0(R15),C' '              END OF PROCSTEPNAME?\n         BNE   *-8                      NO - KEEP LOOKING\n         MVI   0(R15),C'.'              ADD THE SEPARATOR\n         MVC   1(8,R15),DD@SNAME        MOVE IN STEPNAME\n         B     DDSPIN39\nDDSPIN37 MVC   DDSTEPN,DD@SNAME         MOVE STEPNAME ONLY\nDDSPIN39 MVI   QDATRNUM+1,2             SET # OF ATTR BYTES IN LINE\n         QCALL DISPADD                  ADD THIS LINE TO SCREEN\nDDSPIN40 EQU   *\n.DD11     ANOP\n         MVC   DDDSIDFL,DD@STAR         COPY \"WEIRDNESS\" FLAG\n         MVC   DDDSTYPE,=C'<Spin>'      MOVE IN DATASET TYPE ('<SPIN>')\n         TM    DD@FLAG1,PDB1SPIN        SPIN DATASET?\n         BO    *+10                     YES - OK\n***      MVC   DDDSTYPE,=C'UNKNWN'      INDICATE DATASET TYPE\n         MVC   DDDSTYPE,=C'DynOut'      INDICATE FREE=END\n         MVC   DDATTR1,=X'1DC8'         SET INPUT, BRIGHT\n         MVC   DDATTR2,=X'1D60'         SET OUTPUT, NORMAL\n         MVC   DDATTR3,=X'1DE8'         SET OUTPUT, BRIGHT\n         MVC   DDATTR4,=X'1D60'         SET OUTPUT, NORMAL\n         MVI   QDATRNUM+1,4             SET # OF ATTR BYTES IN LINE\n         BAL   R8,DD$FMT                FMT DSID/RECCT/CLASS/HOLD/PRINT\n*---  SAVE DATA IN ARRAY FOR LINE COMMANDS                         ---*\n         XC    DD@TPTR(LCBELEN),DD@TPTR INIT ARRAY ELEMENT\n         MVI   DD@ADDR1+3,DDSELECT-QDMSG  OFFSET INTO LINE OF 1ST FIELD\n         MVC   DD@ID,DDDSID             DSID\n         MVC   DD@FLD1(2+8),QBLANK\n         LA    R1,DD@TPTR               -> MY ARRAY ELEMENT\n         QCALL DISPADDX                 ADD LINE TO DISPLAY\nDDSPIN50 LA    R7,DD@ENTL(,R7)          -> NEXT TABLE ENTRY\n         B     DDSPIN10                 GO DISPLAY THIS ONE\n         DROPX R7                       DD@ENTL\nDDSPIN90 TM    QDEBUG1,QDEBUG11         DEBUGGING?\n         BNO   QSTOP                    NO - ALL DONE\n         MVI   QDMSG,C'-'               INSERT A LINE ...\n         MVC   QDMSG+1(L'QDMSG-1),QDMSG ... OF DASHES\n         MVC   QDMSG+(80-DDDFPDBL)/2(DDDFPDBL),DDDEFPDB  WITH HEADER\n         MVI   QDATRNUM+1,2             2 ATTR BYTES HERE\n         BAL   R14,QADDLINE             DISPLAY THIS LINE\n         LA    R4,DDDEF80               -> first flag definition\n         LA    R5,DDDEF08               -> fifth flag definition\n         LA    R2,8/2                   number of times through loop\n         LA    R3,2*2                   number of attr bytes per line\n         TM    QISFLAG1,QIS1ISPF        running under ISPF?\n         BZ    DD$FL$LP                 no - use two column format\n         LA    R2,8                     yes - use single column format\n         LA    R3,2                     number of attr bytes per line\n*\nDD$FL$LP MVC   QDMSG,QBLANK             clear the line\n         MVC   QDMSG+20(DDDEFLEN),0(R4) copy one definition\n         TM    QISFLAG1,QIS1ISPF        running under ISPF?\n         BNZ   DD$FL$IS                 yes - skip other format\n         MVC   QDMSG(DDDEFLEN),0(R4)    copy left half\n         MVC   QDMSG+40(DDDEFLEN),0(R5) copy right half\nDD$FL$IS STC   R3,QDATRNUM+1            indicate number of attr bytes\n         BAL   R14,QADDLINE             DISPLAY THIS LINE\n         LA    R4,DDDEFLEN(,R4)         bump left ptr\n         LA    R5,DDDEFLEN(,R5)         bump right ptr\n         BCT   R2,DD$FL$LP              loop\n         BAL   R14,QADDLINE             DISPLAY A BLANK LINE\n         B     QSTOP                    ALL DONE\n***********************************************************************\n*                                                                     *\n*   FORMAT A LINE FOR 1 DSID                                          *\n*                                                                     *\n***********************************************************************\n         USNGX DD@ENT,R7\nDD$FMT   L     R0,DD@DSKEY              CONVERT\n         CVD   R0,DDN@DWD                  DATA SET\n         MVC   DDN@TEMP,=X'4020202020202120'      ID\n         ED    DDN@TEMP,DDN@DWD+4\n         MVC   DDDSID,DDN@TEMP+2\nDD$FMT2  MVI   DD@XFLAG,255             INDICATE THIS ENTRY DISPLAYED\n          AIF   (&QLEVEL LT 5).DD12\n         MVC   DDDDNAME,DD@DDNAM        MOVE IN DDNAME FROM PDDB\n.DD12     ANOP\n         L     R0,DD@RECCT              CONVERT\n         CVD   R0,DDN@DWD                  RECORD\n         MVC   DDDSRECS,=X'4020202020202120'     COUNT TO\n         ED    DDDSRECS,DDN@DWD+4                   PRINTABLE\n         MVC   DDDSCLS,DD@CLASS         MOVE IN SYSOUT CLASS\n         LA    R1,DD@DEST               -> BINARY DEST\n         QCALL FINDRJE                  GET A DISPLAYABLE NAME\n         MVC   DDDSDEST,0(R1)           DISPLAY THE RESULTS\n         SR    R0,R0                    CLEAR FOR IC\n         IC    R0,DD@COPYS              GET COPY COUNT\n         CH    R0,=H'1'                 DEFAULT?\n         BNH   DD$NOCPY                 YES - SKIP\n         CVD   R0,DDN@DWD\n         MVC   DDDSCPYS,=X'40202020'    GET EDIT MASK\n         ED    DDDSCPYS,DDN@DWD+6       FILL IN COPY COUNT\nDD$NOCPY MVC   DDDSFORM,DD@FORMS        MOVE IN FORMS CODE\n         MVC   DDSFCB,DD@FCB            MOVE IN FCB CODE\n         MVC   DDDSUCS,DD@UCS           MOVE IN UCS CODE\n         MVC   DDHELD,QBLANK            CLEAR FIELD\n          AIF   (&QLEVEL GE 11).DD13\n         TM    DD@FLAG1,PDB1HOLD        HELD DATASET?\n         BNO   *+10                     NO - SKIP\n         MVC   DDHELD,=C'H-'            YES - INDICATE THAT\n         TM    DD@FLAG1,PDB1SPIN        SPIN DATASET?\n         BNO   DD$NOTP                  NO - SKIP\n         TM    DD@FLAG1,PDB1PSO         AVAILABLE FOR SYSOUT?\n         BO    DD$NOTP                  YES - OK\n         MVC   DDHELD,=C'P-'            NO - INDIC. IT'S BEEN PRINTED\n.DD13     ANOP\nDD$NOTP  TM    QDEBUG1,QDEBUG11         WANT PDBFLAG DISPLAYED?\n         BZR   R8                       NO - DON'T DISPLAY PDBFLAG1\n         MVI   QDHLINE+78,C'F'          PUT IN COLUMN HEADER\n         UNPK  DDN@DWD(2+1),DD@FLAG1(1+1)\n         TR    DDN@DWD(2),QHEXTAB\n         MVC   DDPDBFLG,DDN@DWD\n         BR    R8                       RETURN TO CALLER\n         DROPX R7                       DD@ENT\n***********************************************************************\n*                                                                     *\n*   READ A BLOCK FROM HASPACE                                         *\n*                                                                     *\n***********************************************************************\nDD$READ  ST    R4,QCTRAK                STORE DISK ADDR\n         L     R0,QCJQEA                -> JQE\n         LR    R1,R5                    IOAREA ADDRESS\n         QCALL READSPC                  READ HASPACE\n         BR    R8                       RETURN TO CALLER\n         EJECT ,\n***********************************************************************\n*                                                                     *\n*   Sort Compare ROUTINE                                              *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         DROPX ,\n         USNGX DD$CMP,R15\n         USNGX DD@ENT,R1\n         USNGX WORK,R3\n         SPACE 2\nDD$CMP   MVI   DD@CFLAG,0               clear flags\n         CLC   DD@DSKEY,DD@DSKEY-DD@ENT(R2) Same DSID?\n         BNER  R14                      no, let sort do it\n         TM    DD@FLAG1,PDB1NULL        null?\n         BZ    *+8                      no, skip flag\n         OI    DD@CFLAG,DD@CFN1         yes, flag it\n         TM    DD@FLAG1-DD@ENT(R2),PDB1NULL  null?\n         BZ    *+8                      no, skip flag\n         OI    DD@CFLAG,DD@CFN2         yes, flag it\n         TM    DD@CFLAG,DD@CFN1+DD@CFN2 any nulls?\n         BNM   DD$CMPE                  zero/ones\nDD$CNULL TM    DD@CFLAG,DD@CFN1         first entry null?\n         BO    DD$CMPL                  yes, switch\n         TM    DD@CFLAG,DD@CFN2         second entry null?\n         BO    DD$CMPH                  no, continue\nDD$CMPL  CLC   =H'1',=H'2'              set cc low\n         BR    R14\nDD$CMPH  CLC   =H'2',=H'1'              set cc high\n         BR    R14\nDD$CMPE  CLC   =H'1',=H'1'              set cc equ\n         BR    R14\n         SPACE 2\n         DROPX R1,R3,R15\n         EJECT ,\n***********************************************************************\n*                                                                     *\n*   MISCELLANY                                                        *\n*                                                                     *\n***********************************************************************\n         USNGX DDNAME,R12\n         USNGX QCOMMON,R11\n         USNGX WORK,R13\n         SPACE 2\nDD$TILT1 QTILT '*** Dataset Table Limits Exceeded ***'\n         SPACE 3\n         LTORG ,\n         ENTRY SJ#KEYS\nSJ#KEYS  DC    CL8'ALL     ',CL8'A       '\n         DC    X'FF'                    END OF KEYWORD TABLE\n          AIF   (&QLEVEL GE 5).DD14\nDDMVCDDN MVC   DDDDNAME(*-*),3(R7)      << EXECUTED >>\n.DD14     ANOP\n          AIF   (&QLEVEL GE 5).DD91\nDSIDTYPE DC    C'JCLIN '                DSID=1\n         DC    C'JOBLOG'                DSID=2\n         DC    C'JCL   '                DSID=3\n         DC    C'JOBMSG'                DSID=4\n         DC    C'JCLTXT'                DSID=5\n         DC    C'SWA   '                DSID=6\n.DD91     ANOP\nDDCMDSYS DC    C'000001'                DSID=1\n         DC    C'JLOG  '                DSID=2\n         DC    C'JCL   '                DSID=3\n         DC    C'JMSG  '                DSID=4\n         DC    C'000005'                DSID=5\n         DC    C'000006'                DSID=6\n*D#STHDR DC    X'1DE8',CL(80-2)'** Pgm=          Proc=          Step='\nDD#STHDR DC    X'1DE8',CL18'******************'\n         DC    CL(80-2-18)'** Pgm=          Proc=          Step='\n         DC    X'1D60'                  SET OUTPUT, NORMAL\n         SPACE 1\n          AIF   (&QLEVEL GE 5).DD92\nNOTXTMSG DC    X'1DE8',C'************ DDname, Program, and Stepname inf$\n               ormation unavailable ***********',X'1D60'\nNOTXTMGL EQU   *-NOTXTMSG\n.DD92     ANOP\n         SPACE 1\nDDDEFPDB DC    X'1DE8',C'  PDBFLAG1 definition  ',X'1D60'\nDDDFPDBL EQU   *-DDDEFPDB\n         SPACE 1\nDDDEF80  DC X'1DE8',C'80=DSID',X'1D60',CL31'- DSID in PDBDSID/PDBWTRID'\nDDDEFLEN EQU   *-DDDEF80\n         DC X'1DE8',C'40=NULL',X'1D60',CL31'- This is a null PDDB     '\n         DC X'1DE8',C'20=LOG ',X'1D60',CL31'- PDDB for HASP Job Log   '\n         DC X'1DE8',C'10=MDES',X'1D60',CL31'- Mult-dest PDDBs follow  '\nDDDEF08  DC X'1DE8',C'08=NSOT',X'1D60',CL31'- Not for Sysout          '\n         DC X'1DE8',C'04=SPIN',X'1D60',CL31'- PDDB for Spin data set  '\n         DC X'1DE8',C'02=HOLD',X'1D60',CL31'- PDDB for Held data set  '\n         DC X'1DE8',C'01=PSO ',X'1D60',CL31'- Accessible by PSO       '\n         SPACE 3\n         QCOMMON\n         PUSH  PRINT\n         PRINT GEN                      get expansions back\n         ORG   QDMSG                    LINE FOR EACH DSID\nDDATTR1  DS    XL2\nDDSELECT DS    CL2\nDDATTR2  DS    XL2\nDDDDNAME DS    CL8\nDDATTR3  DS    XL2\nDDDSID   DS    CL6\nDDDSIDFL DS    C\nDDATTR4  DS    XL2\nDDHELD   DS    CL2                      'H-' OR 'P-' OR BLANK\nDDDSTYPE DS    CL6                      'SYSOUT', 'SYSIN ', OR '<SPIN>'\nDDDSRECS DS    CL8\n         DS    CL2\nDDDSCLS  DS    C\n         DS    CL2\nDDDSDEST DS    CL8\nDDDSCPYS DS    CL4\n         DS    CL2\nDDDSUCS  DS    CL4\n         DS    C\nDDSFCB   DS    CL4\n         DS    C\n          AIF   (&QLEVEL GE 5).DD93\nDDDSFORM DS    CL4\n          AGO   .DD94\n.DD93     ANOP\nDDDSFORM DS    CL8\n.DD94     ANOP\n         DS    CL4\nDDPDBFLG DS    CL2\n         ORG   QDMSG                    LINE FOR EACH STEP\nDDSTEPLN DS    0CL(2+78+2)\n         DS    X'1DE8',CL18,C'** PGM='\nDDPGM    DS    CL8\n         DS    C'  PROC='\nDDPROCN  DS    CL8\n         DS    C'  STEP='\nDDSTEPN  DS    CL8\n         DC    C'.'\n         DS    CL8\n         SPACE 3\nWORK     DSECT\n         ORG   WORK+72                  SKIP OVER SAVE AREA\nDDN@DWD  DS    D\nDD@PROCN DS    CL8\nDD@PSTEP DS    CL8\nDD@STEP  DS    CL8\nDD@ADSNK DS    A                        -> LAST DSN= INTERNAL TEXT UNIT\nDD@TBLEE DS    A                        -> end of dsid table\nDDN@TEMP DS    CL8\nDD@STAR  DS    C\nDD@WORK  DS    CL4\nDD@REGSV DS    4F                       TEMP REGISTER SAVE AREA\nDD@FLAGS DS    X\nDD@FSPIN EQU   X'01'                    THIS IS A SPIN DSID\nDD@FNOTX EQU   X'02'                    INTERNAL TEXT UNAVAILABLE\nDD@FTS   EQU   X'04'                    term=ts text key\nDD@FSJAL EQU   X'80'                    'ALL' OPERAND OF 'SJ' SUBCMD\n         SPACE 1\n         QLCB  PREFIX=DD@\n*D@TPTR  DS    A                        LCBTPTR\n*D@ADDR1 DS    A                        LCBADDR1\n*D@ADDR2 DS    A                        LCBADDR2\n*D@ID    DS    CL6                      LCBID (DSID)\n*D@FLD1  DS    CL2                      LCBFLD1\n*D@FLD2  DS    CL8                      LCBFLD2\n          AIF   ('&@@OACFS' EQ '').DD95\nDD@PARM  OACFSORT  PREFIX=DD@,DSECT=NO\n.DD95     ANOP\n         SPACE 1\nDD@CFLAG DS    X                        misc flags for compare rtn\nDD@CFN1  EQU   X'80'                    first dd entry null\nDD@CFN2  EQU   X'40'                    second dd entry null\nDD@WORKL EQU   *-WORK\nDD@SWRK  DS    XL512\n         SPACE 3\n*---  COMPRESSED COPY OF A PDDB                                    ---*\nDD@ENT   DSECT\nDD@FLAG1 DS    B                        SAVE FOR PDBFLAG1\nDD@RECFM DS    X                        SAVE FOR PDBRECFM\nDD@LRECL DS    H                        SAVE FOR PDBLRECL\nDD@CLASS DS    C                        SAVE FOR PDBCLASS\nDD@XFLAG DS    X                        255 = ALREADY DISPLAYED\nDD@DSKEY DS    F                        SAVE FOR PDBDSKEY\nDD@RECCT DS    F                        SAVE FOR PDBRECCT\nDD@DEST  DS    CL4                      SAVE FOR PDBDEST\n          AIF   (&QLEVEL GE 5).DD96\nDD@FORMS DS    CL4                      SAVE FOR PDBFORMS\n          AGO   .DD97\n.DD96     ANOP\nDD@PNAME DS    CL8                      SAVE FOR PDBPNAME\nDD@SNAME DS    CL8                      SAVE FOR PDBSNAME\nDD@DDNAM DS    CL8                      SAVE FOR PDBDDNAM\nDD@FORMS DS    CL8                      SAVE FOR PDBFORMS\n.DD97     ANOP\nDD@FCB   DS    CL4                      SAVE FOR PDBFCB\nDD@UCS   DS    CL4                      SAVE FOR PDBUCS\nDD@COPYS DS    AL1                      SAVE FOR PDBCOPYS\nDD@ENTL  EQU   *-DD@ENT\n         SPACE 3\n*%%      DROPX R13                      WORK\n         POP   PRINT\n         SPACE 3\n         Q$PDDB\n         Q$LRC\n         QZKEYS\n         QZTEXT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "Q#DL": {"ttr": 5633, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x00_\\x00\\x90\\x00_#8\\x00d\\x00d\\x00\\x00\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-01-05T00:00:00", "modifydate": "1990-01-05T23:38:00", "lines": 100, "newlines": 100, "modlines": 0, "user": "LDW"}, "text": "         TITLE '--- QUEUE--LISTDAS -- LIST ALL DAS CONTROL BLOCKS ---'\n*---------------------------------------------------------------------*\n*                                                                     *\n*   LISTDAS - Display information from DAS for all spool volumes      *\n*                                                                     *\n*   Note - This subcommand is restricted to privileged users          *\n*                                                                     *\n*   Updates:                                                          *\n*      05Jan90  LDW  Written                                          *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 3\nLISTDAS  QSTART  STACK=X'30'\n         QCALL CKPT                     read checkpoint data\n         QCALL DISP80                   switch to 3278-2 mode if 3278-5\n          AIF   (&QLEVEL GE 7).DL01\n         QTILT '*** LISTDAS not implemented for this level of JES2 ***'\n          AGO   .DL99\n.DL01     ANOP\n         MVC   QDHLINE(46),=C'VOLSER XN FL TGnum -Extents- T/G Status  $\n                MASK'\n         L     R9,QCJQTL                -> master ckpt record\n         USNGX $SAVEBEG,R9\n         L     R3,QCDASA                -> DAS area\n         LH    R4,$SPOLNUM              number of spool volumes allowed\n         USNGX DAS,R3\n***********************************************************************\n*                                                                     *\n*        Loop through all DASs, displaying interesting info           *\n*                                                                     *\n***********************************************************************\nDL$LOOP  EQU   *\n***      tm    dasflag,dasexsts         does volume exist?\n***      bz    dl$skip                  no - skip it\n         MVC   DL@VOLID,DASVOLID\n         HEX   DL@EXTNO,DASEXTNO,LEN=1,HEXTAB=QHEXTAB\n         HEX   DL@FLAG,DASFLAG,LEN=1\n         LH    R0,DASNOTGE              number of tg's in extent\n         CVD   R0,QNUMWORK\n         OI    QNUMWORK+7,X'0F'\n         MVC   DL@TGNUM,=X'2020202120'\n         ED    DL@TGNUM-1(L'DL@TGNUM+1),QNUMWORK+5\n         HEX   DL@LOTRK,DASLOTRK,LEN=2,BYTE=C'-'\n         HEX   DL@HITRK,DASUPTRK,LEN=2\n         LH    R0,DASNOTGP              number of tracks per group\n         CVD   R0,QNUMWORK\n         OI    QNUMWORK+7,X'0F'\n         MVC   DL@NOTGP,=X'202120'\n         ED    DL@NOTGP-1(L'DL@NOTGP+1),QNUMWORK+6\n         TM    DASFLAG,DASDRAIN\n         BZ    *+10\n         MVC   DL@STAT(8),=C'Draining'\n         TM    DASFLAG,DASHALT\n         BZ    *+10\n         MVC   DL@STAT(7),=C'Halting'\n         TM    DASFLAG,DASTART\n         BZ    *+10\n         MVC   DL@STAT(8),=C'Starting'\n         TM    DASFLAG,DASEXSTS\n         BNZ   *+10\n         MVC   DL@STAT(8),=C'nonexist'\n         TM    DASFLAG,DASACTIV\n         BNO   *+10\n         MVC   DL@STAT(8),=C'<Active>'\n         TM    DASFLAG,DASAVAIL\n         BNO   *+10\n         MVC   DL@STAT(7),=C'*Avail*'\n         HEX   DL@MASK,DASMASK,LEN=4\n         BAL   R14,QADDLINE             display the line\n         LA    R3,DASSIZ(,R3)           -> next DAS\n         BCT   R4,DL$LOOP               display them all\n         B     QSTOP                    all done\n***********************************************************************\n*                                                                     *\n*        CONSTANTS                                                    *\n*                                                                     *\n***********************************************************************\n         LTORG ,\n         SPACE 1\n         DROPX R9,R3                    WORK, $SAVEBEG, $DAS\n***********************************************************************\n*                                                                     *\n*        DESCRIBE ALL THE DSECTS NEEDED BY THIS MODULE                *\n*                                                                     *\n***********************************************************************\n         QCOMMON\n         ORG   QDMSG\nDL@VOLID DS    CL6,C\nDL@EXTNO DS    CL2,C\nDL@FLAG  DS    CL2,C\nDL@TGNUM DS    CL5,C\nDL@LOTRK DS    CL4,C\nDL@HITRK DS    CL4,C\nDL@NOTGP DS    CL3,C\nDL@STAT  DS    CL8,C\nDL@MASK  DS    CL8,C\n         SPACE 3\n         Q$HCT\n         Q$DAS\n.DL99     ANOP\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "Q#DY": {"ttr": 5636, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x1a\\x00\\x00\\x00\\x82#/\\x00\\x91\\x19\\x7f\\x11!\\x06\\x85\\x01\\x8a\\x05\\xce\\xe2\\xc1\\xd3\\xc2\\xc5\\xd9\\xe3@@@'", "ispf": {"version": "05.26", "flags": 0, "createdate": "1982-08-20T00:00:00", "modifydate": "1991-07-16T11:21:00", "lines": 1669, "newlines": 394, "modlines": 1486, "user": "SALBERT"}, "text": "         TITLE '--- QUEUE--DISPLAY -- 3270 DISPLAY ROUTINES ---'\n*---------------------------------------------------------------------*\n*                                                                     *\n*   DISPLAY - DISPLAY CURRENT SCREEN BUFFER                           *\n*                                                                     *\n*   Updates:                                                          *\n*      16Jul91  GLA  Fix handling of table display repositioning      *\n*      15Mar91  LDW  Correct DD#MDL for 6 char DSIDs                  *\n*      11Feb91  LDW  Move some ISPF stuff from QCOMMON to literals    *\n*                    Use DY@CALLP instead of TBLST and VCALLST        *\n*      01Feb91  LDW  Don't clear the screen for error messages        *\n*      31Jan91  LDW  Integrate GLA fixes below, with minor fiddling:  *\n*                       (Guy Albertelli really makes me look bad...   *\n*                       he fixed all (?) my ancient bugs.)            *\n*                    Rename QPRIMCMD macro to QNEWCMD                 *\n*     (15Jan91) GLA  Ignore data in second input field if it was sent *\n*     (17Apr90) GLA  Support ISPF =xxx commands in ISPF mode          *\n*                    Fix command line length in VCOPYs                *\n*     (06Jan89) GLA  Fix extra character left in header line          *\n*     (15Nov89) GLA  Fix reprompt code for ISPF                       *\n*     (20Sep89) GLA  Make blank command lines not real commands       *\n*                    Handle reprompts better by setting MDT           *\n*                    Fix cause of QQ1 error on both line and prim cmd *\n*                    Don't ignore line commands wanting validation    *\n*     (10Aug89) GLA  Adjust header line to be over correct columns    *\n*                    Correct DY3 problem in non-ISPF version          *\n*     (20Jul89) GLA  Change the interface for command issuance to     *\n*                       hopefully eliminate DY3 and QQ1 errors after  *\n*                       error messages                                *\n*     (11Jul89) GLA  Add prompt support to ISPF code                  *\n*     ( 5Jul89) GLA  Add CPU and Paging rate to non-ISPF display      *\n*     (16Jun89) GLA  Fix addressability problem causing 0C4           *\n*                    Add interface to support reexcution of           *\n*                       stacked primary commands                      *\n*     (22May89) GLA  Move things around for addressability            *\n*     (28Mar89) GLA  Add support for ISPF BROWSE and Tables           *\n*      08Feb87  LDW  Support command ring for RECALL                  *\n*      17Jan87  LDW  Remove \"*\" subcommand;  misc other cleanup       *\n*                    Remove \"LC\" macro usage                          *\n*      04/23/86 LDW  FIX BUGS                                         *\n*      03/31/86 LDW  RE-DESIGN 3278-5 SUPPORT (THIRD TRY!)            *\n*                    USE NEW COMMON LOGIC ERROR ROUTINE               *\n*      09/13/84 LDW  ALLOW FOR 24 PFKEYS IF \"MODE PFK24\"              *\n*      01/19/84 LDW  ADD SUPPORT FOR 'COLS' SUBCOMMAND                *\n*                    FIX BUG IN HEADER IF 'JESNEWS'                   *\n*      01/17/84 LDW  FIX ASM ERROR CAUSED BY EXPANSION OF QDSCREEN    *\n*      04/07/83 LDW  FIX LOOP CAUSED BY LEADING BLANK IN INPUT FIELD  *\n*                    FIX GLITCH IN \"RECALL\" CAUSED BY VTAM BUG        *\n*      03/15/83 LDW  PROCESS MULTIPLE INPUT FIELDS ON SCREEN          *\n*                    CHANGE USING/DROP TO USNGX/DROPX                 *\n*                    FIX TTY MODE OUTPUT                              *\n*                    CHANGE \"*\" SUBCOMMAND TO \"RECALL\" (\"RC\")         *\n*      02/03/83 LDW  ADD \"* I\" TO REPROMPT LAST INQUIRY SUBCOMMAND    *\n*      01/19/83 LDW  ADD WORKLEN= TO QSTART TYPE=ENTRY                *\n*      01/14/83 LDW  ADD REPROMPT TSO AND MVS                         *\n*      01/12/83 LDW  MOVE STARKEYS FROM \"PARSE\"                       *\n*      01/10/83 LDW  SQUEEZE OUT ATTR BYTES IN \"DY$TTY\"               *\n*                    HANDLE TCAM10 RESHOW (PA3)                       *\n*                    REDESIGN SCREEN BUFFER LOGIC SO THAT BUFF PTR IS *\n*                       ONLY RESET WHEN FIRST LINE IS TO BE STORED IN *\n*                       BUFFER (THIS IS SO THAT A MESSAGE FROM QTILT  *\n*                       CAN BE WRITTEN LEAVING THE REST OF THE        *\n*                       INTACT)                                       *\n*                    SUPPORT Q2SHORT WHICH INDICATES THAT ONLY THE    *\n*                       TOP 3 SCREEN LINES SHOULD BE WRITTEN          *\n*      01/06/83 LDW  FIX CLEAR LOGIC                                  *\n*      01/04/83 LDW  ADD WORKLEN=                                     *\n*                    HANDLE REPOSITIONING SUBCOMMAND DIRECTLY         *\n*      12/17/82 LDW  PUT IN SUPPORT FOR IMBEDDED ATTR BYTES IN LINE   *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 3\nDISPLAY  QSTART  Q5,WORKLEN=DY@WORKL\n         USNGX WORK,R13\n         LA    R9,2048(,R12)            Setup second base reg\n         LA    R9,2048(,R9)\n         USNGX DISPLAY+4096,R9          setup using\n         MVI   DY@FLAG,DY@IMM           SET FLAG TO \"IMMEDIATE DISPLAY\"\n         XC    DY@CURS,DY@CURS          INDICATE DEFAULT CURSOR POS\n         OI    QFLAG1,Q1PROFOK          INITIALIZATION PROFILE COMPLETE\n         BAL   R8,DY$SETOP              BUILD TOP SCREEN LINES (MAYBE)\n         BAL   R8,DY$SETTL              BUILD LINE OF DASHES\n         B     DY$WRITE                 bypass code below <**********\n*---  I specifically don't want the screen cleared on error messages\n         TM    QFLAG2,Q2NEWSCR          Any lines on scr yet?\n         BZ    DY$WRITE                 Yes,  then done\n         TM    QFLAG2,Q2SHORT           Short req (validation)?\n         BO    DY$WRITE                 Yes,  then done\n         MVC   QDNEXT,QVLINE1           Set addr of 1st line\n         XC    QDLINECT,QDLINECT        RESET LINE NUMBER\n         NI    QFLAG2,255-Q2NEWSCR      RESET FLAG\n         XC    QDENDPTR,QDENDPTR        KILL PTR TO IC AT END\n         B     DY$WRITE                 GO WRITE SCREEN\n         SPACE 3\n***********************************************************************\n*                                                                     *\n*   SUBROUTINE TO SWITCH TO MOD 2 SCREEN SIZE                         *\n*                                                                     *\n***********************************************************************\nDISP80   QSTART  TYPE=ENTRY\n         CLI   QDCOLS+1,80              ALREADY CORRECT?\n         BE    QSTOP                    YES - SKIP\n         MVC   QD3270OP,QDERASE         INSURE ERASE WRITE NEXT\n         MVI   QDCOLS+1,80              SET SCREEN WIDTH\n         MVI   QDROWS+1,24-3            SET SCREEN LENGTH (USABLE)\n         ZAP   QTPAGE,=P'21'            NUMBER OF USABLE ROWS\n         ZAP   QTHALF,=P'10'            SAME FOR HALF A SCREEN\n         ZAP   QTPAGEX,=P'20'           SAME AS ABOVE IF COLUMN ...\n         ZAP   QTHALFX,=P'10'           ... INDICATOR BEING DISPLAYED\n         OI    QTERMFLG,QTFSW2          TELL DISPLAY TO REBUILD HEADER\n         NI    QTERMFLG,255-QTFSW5      RESET OTHER FLAG\n         B     QSTOP                    RETURN TO CALLER\n         SPACE 3\n***********************************************************************\n*                                                                     *\n*   SUBROUTINE TO SWITCH TO MOD 5 SCREEN SIZE                         *\n*                                                                     *\n***********************************************************************\nDISP132  QSTART  TYPE=ENTRY\n         TM    QTERMFLG,QTFMOD5         MODEL 5?\n         BZ    QSTOP                    NO - DON'T DO ANYTHING\n         CLI   QDCOLS+1,132             ALREADY CORRECT?\n         BE    QSTOP                    YES - SKIP\n         MVC   QD3270OP,QDERASE         INSURE ERASE WRITE NEXT\n         MVI   QDCOLS+1,132             SET SCREEN WIDTH\n         MVI   QDROWS+1,27-3            SET SCREEN LENGTH (USABLE)\n         ZAP   QTPAGE,=P'24'            NUMBER OF USABLE ROWS\n         ZAP   QTHALF,=P'12'            SAME FOR HALF A SCREEN\n         ZAP   QTPAGEX,=P'23'           SAME AS ABOVE IF COLUMN...\n         ZAP   QTHALFX,=P'11'           ... INDICATOR IS DISPLAYED\n         OI    QTERMFLG,QTFSW5          TELL DISPLAY TO REBUILD HEADER\n         NI    QTERMFLG,255-QTFSW2      RESET OTHER FLAG\n         B     QSTOP                    RETURN TO CALLER\n         LTORG\n         SPACE 3\n*---------------------------------------------------------------------*\n*                                                                     *\n*   DISPADD - ADD A LINE TO SCREEN BUFFER, DISPLAY SCREEN IF FULL     *\n*                                                                     *\n*   ENTRY - LINE TO BE ADDED IN \"QDMSG\"                               *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 3\nDISPADD  QSTART  TYPE=ENTRY\n         LA    R9,2048(,R12)            Setup second base reg\n         LA    R9,2048(,R9)\n         XC    DY@TPTR,DY@TPTR          NO LINE CMD ELEMENT POINTER\n         B     DY$ADD00                 CONTINUE\n         SPACE 3\n*---------------------------------------------------------------------*\n*                                                                     *\n*   DISPADDX - SAME FUNCTION AS DISPADD                               *\n*                                                                     *\n*   ENTRY - LINE TO BE ADDED IN \"QDMSG\"                               *\n*         - R1 -> LINE COMMAND ELEMENT                                *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 3\nDISPADDX QSTART  TYPE=ENTRY\n         LA    R9,2048(,R12)            Setup second base reg\n         LA    R9,2048(,R9)\n         ST    R1,DY@TPTR               SAVE LINE CMD ELEMENT POINTER\n         SPACE 1\nDY$ADD00 MVI   DY@FLAG,0                SET FLAG TO \"ADD MSG\"\n         XC    DY@CURS,DY@CURS          INDICATE DEFAULT CURSOR POS\n         TM    QFLAG1,Q1IMMED           HERE ON \"IMMEDIATE\" COMMAND?\n         BNO   DY$ADD01                 NO - SKIP\n         NI    QFLAG1,255-Q1IMMED       RESET \"IMMEDIATE COMMAND\"\n         L     R0,=C'DY1 '              SET LOGIC ERROR CODE\n         L     R15,=V(LOGICERR)         -> ROUTINE\n         BALR  R14,R15                  GO TO IT (NO RETURN)\n***********************************************************************\n*                                                                     *\n*  QUICKIE DESCRIPTION OF \"DISPLAY\" LOGIC:                            *\n*    (1) IF ROOM ON SCREEN FOR MESSAGE, MOVE IT IN AND RETURN         *\n*    (2) IF NO ROOM, SHOW *MORE*, DISPLAY SCREEN, RESET POINTERS,     *\n*        GO TO (1)                                                    *\n***********************************************************************\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*   CHECK FOR ROOM ON SCREEN                                          *\n*                                                                     *\n***********************************************************************\nDY$ADD01 MVI   QDOVER,0                 RESET THE PAGE OVRFL INDICATOR\n         TM    QTERMFLG,QTFSW2+QTFSW5   NEED TO SWITCH?\n         BNZ   DY$ADD02                 YES - SKIP NEXT TEST\n         TM    QFLAG2,Q2NEWSCR          THIS OUTPUT FOR LINE 1?\n         BNO   DY$ADD03                 NO - SKIP\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*   BUILD SCREEN HEADER IF NECESSARY AFTER MOD2 <-> MOD5 SIZE SWITCH  *\n*                                                                     *\n***********************************************************************\nDY$ADD02 BAL   R8,DY$SETOP              BUILD TOP SCREEN LINES (MAYBE)\n         BAL   R8,DY$SETTL              BUILD LINE OF DASHES\n         MVC   QDNEXT,QVLINE1           SET ADDR OF FIRST OUTPUT LINE\n         XC    QDLINECT,QDLINECT        RESET LINE NUMBER\n         NI    QFLAG2,255-Q2NEWSCR      RESET FLAG\n         XC    QDENDPTR,QDENDPTR        KILL PTR TO IC AT END\n         SPACE 1\nDY$ADD03 LH    R1,QDLINECT              GET CURRENT LINE COUNT\n         LA    R1,1(,R1)                INCREMENT\n         TM    QISFLAG1,QIS1ISPF        Using ISPF DM for screen?\n         BO    DY$ADD3A                 yes, so handle different\n         CH    R1,QDROWS                SCREEN BUFFER FULL?\n         BH    DY$FULL                  YES - WRITE SCREEN.\nDY$ADD3A STH   R1,QDLINECT              SAVE UPDATED LINE COUNT\n         CH    R1,=H'1'                 IS THIS DATA LINE 1?\n         BNE   DY$ADD04                 NO - SKIP\n         OI    QFLAG1,Q1MVHDR           YES - REQUEST \"MOVE HEADER\"\n         TM    QFLAG2,Q2LISTDS+Q2COLIND IN 'LISTDS' AND WANT COL IND?\n         BNO   DY$ADD04                 NO - SKIP\n         L     R4,QDNEXT                -> NEXT LINE LOC\n         LH    R5,QDCOLS                GET LINE LENGTH\n         BCTR  R5,0                     -1 FOR EX\n         LA    R15,DY#SCALE             -> MY COLUMN SCALE\n         AH    R15,QPOFFSET             ADD COL-1\n         EX    R5,DY$SCMVC              MVC 0(*-*,R4),0(R15)\n         LA    R4,1(R5,R4)              -> NEXT LINE LOC\n         ST    R4,QDNEXT                UPDATE PTR TO NEXT LINE LOC\n         MVI   QDLINECT+1,2             SET LINE COUNT\n***********************************************************************\n*                                                                     *\n*   MOVE THE MESSAGE TO THE SCREEN                                    *\n*                                                                     *\n***********************************************************************\nDY$ADD04 L     R4,QDNEXT                -> NEXT LINE LOCATION\n         LH    R5,QDCOLS                GET LINE LENGTH\n         AH    R5,QDATRNUM              ADD # OF ATTR BYTES IN LINE\n         BCTR  R5,0                     -1 FOR EX\n         TM    QISFLAG1,QIS1ISPF        Using ISPF DM for screen?\n         BO    DY$A4ISP                 yes, so handle different\n         EX    R5,DY$ADD                MVC 0(*-*,R4),QDMSG\n         LA    R15,1(R5,R4)             -> NEXT LINE LOC\n         ST    R15,QDNEXT               SAVE FOR NEXT TIME\n         B     DY$ADD05                 handle line commands\n***********************************************************************\n*                                                                     *\n*   MOVE THE MESSAGE TO THE SCREEN       ISPF MODE                    *\n*                                                                     *\n***********************************************************************\nDY$A4ISP TM    QISFLAG1,QIS1TBOP        is table open?\n         BO    DY$A4I1                  yes - skip create\n***********************************************************************\n*                                                                     *\n*   DECIDE WHAT FORMAT TABLE LINES ARE FOR ISPF MODE DISPLAY          *\n*                                                                     *\n***********************************************************************\n         LA    R3,FM#MDL                Assume it is a SEARCH\n         CLC   QSUBCMD,=V(SEARCH)       did we come from SEARCH?\n         BNE   DY$A4I2A                 no - so check others\n         TM    QSCFLAG2,QSC2DJX         is this XJ?\n         BO    DY$A4I2Z                 yes - use zz model\n         CLC   QCODEH,=H'44'            is this DQ?\n         BE    DY$A4I2Z                 yes - use zz model\n         B     DY$A4I2                  otherwise use FM model\n*\nDY$A4I2A LA    R3,DD#MDL                Assume it is a DDNAME\n         CLC   QSUBCMD,=V(DDNAME)       did we come from DDNAME?\n         BE    DY$A4I2                  It is - Great\n         LA    R3,DC#MDL                Assume it is a CPU\n         CLC   QSUBCMD,=V(CPU)          did we come from CPU?\n         BE    DY$A4I2                  It is - Great\n*\nDY$A4I2Z LA    R3,ZZ#MDL                Otherwise use simple\n*\nDY$A4I2  ST    R3,QMDLPT                save model address\n         USNGX DY#MDL,R3\n         L     R15,ISPLNK               get address of ISPLNK\n         CALL  (15),(=CL8'TBCREATE',TBNAM,0,V8,=CL8'NOWRITE'),VL,      $\n               MF=(E,DY@CALLP)\n         L     R14,=V(ISPFERR)\n         CH    R15,=H'20'               severe error???\n         BL    *+6                      no skip call\n         BALR  R15,R14                  tell about it\n*\n         L     R15,ISPLNK               get address of ISPLNK\n         CALL  (15),(=CL8'VREPLACE',=CL8'QZVARS',=F'30',DY#MVAR),VL,   $\n               MF=(E,DY@CALLP)          panel will set ZVARS from this\n*\n         L     R15,ISPLNK               get address of ISPLNK\n         CALL  (15),(=CL8'VREPLACE',=CL8'QMDL',=F'80',DY#MLN),VL,      $\n               MF=(E,DY@CALLP)          set model line\n*\n         OI    QISFLAG1,QIS1TBOP        mark table open\n         DROPX R3\n***********************************************************************\n*                                                                     *\n*   ISPF Table is now open so add line to it for display              *\n*                                                                     *\n***********************************************************************\nDY$A4I1  LA    R3,1(,R5)                back out BCTR and move to mod\n         LA    R1,QDMSG                 POINT AT LINES\n*   R1 -> line to output\n*   R3 == length of line to output (w/ attr bytes)\n         LA    R7,VLEN8                 POINT AT LENGTH FIELDS\n         LA    R6,V8VAR                 POINT AT STRUCTURE\n         MVI   0(R6),C' '               BLANK OUT ALL VARS\n         MVC   1(256,R6),0(R6)\n         MVC   256+1(QF7+L'QF7-V8VAR-1-256,R6),256(R6)\n*\n*   save line command entry if any\n*\n         XC    DY@TRTAB(LCBELEN),DY@TRTAB  clear area\n         LA    R15,DY@TRTAB             point at dummy\n         OC    QDLCTBL,QDLCTBL          any line command table?\n         BZ    DY$ILCE                  nope - leave as dummy\n         OC    DY@TPTR,DY@TPTR          any input entry?\n         BZ    DY$ILCE                  nope - leave as dummy\n         L     R15,DY@TPTR              point at supplied entry\n*\nDY$ILCE  MVC   0(LCBELEN,R6),0(R15)     move in entry\n         LR    R2,R6                    save lcb addr\n         A     R6,0(,R7)                add in length\n         LA    R7,4(,R7)                point to next entry\n         USNGX LCBUFF,R2\n         L     R15,LCBADDR1             get offset\n         BAL   R8,DY$ILADR              update LCB address\n         ST    R15,LCBADDR1             set addr of variable\n         L     R15,LCBADDR2             get offset\n         BAL   R8,DY$ILADR              update LCB address\n         ST    R15,LCBADDR2             set addr of variable\n         DROPX R2\n*\n*   if current model is ZZ then force all segments into first\n*   variable\n*\n* at this point\n*   r1 -> line to output\n*   r3 == length of line to output (w/ attr bytes)\n*   r6 -> first line variable to output to\n*   r7 -> length array of each variable\n*\n         CLC   QMDLPT(4),=A(ZZ#MDL)     current model ZZ?\n         BNE   DY$MFLD                  no so split by set fields\n         SH    R3,QDATRNUM              get machine line length\n         LA    R3,1(,R3)                get true line length\n         C     R3,0(,R7)                check real len of field\n         BNH   *+8\n         L     R3,0(,R7)                get smaller length\n*\nDY$SF1   CLI   0(R1),X'1D'\n         BE    DY$SF3\n         MVC   0(1,R6),0(R1)            move in data\n*\nDY$SF2   LA    R1,1(,R1)                bump input pointer\n         LA    R6,1(,R6)                bump output pointer\n         BCT   R3,DY$SF1\n         B     DY$TBADD                 go add line to table\n*\nDY$SF3   MVI   0(R6),C' '               put in blank for attr\n         LA    R1,1(,R1)                bump input over start fld\n         B     DY$SF2                   go and try again\n*\n*   multi-field model line, does number of attrs in input line\n*         match number of fields in model?\n*\nDY$MFLD  DS    0H\n         L     R2,QMDLPT                point at model info\n         USNGX DY#MDL,R2\n         CLC   QDATRNUM,DY#MCNT+2       compare field counts\n         BE    DY$MFLDP                 yes - does match\n         CLI   0(R1),X'1D'              IS FIRST BYTE A SF\n         BNE   *+12     >=======+\n         LA    R1,2(,R1)        |       BUMP PAST FIRST SF,ATTR\n         SH    R3,=H'1'         |       CORRECT LENGTH\n         SH    R3,QDATRNUM    <=+       get machine line length\n         LA    R3,1(,R3)                get true line length\n         LR    R15,R6                   temp output addr reg\n         C     R3,0(,R7)                check real len of field\n         BNH   DY$MF1\n         L     R3,0(,R7)                get smaller length\n*\nDY$MF1   CLI   0(R1),X'1D'\n         BE    DY$MF3\n         MVC   0(1,R15),0(R1)           move in data\n*\nDY$MF2   LA    R1,1(,R1)                bump input pointer\n         LA    R15,1(,R15)              bump output pointer\n         BCT   R3,DY$MF1\n         B     DY$MF4                   go add line to table\n*\nDY$MF3   MVI   0(R15),C' '              put in blank for attr\n         LA    R1,1(,R1)                bump input over start fld\n         B     DY$MF2                   go and try again\n*\nDY$MF4   LA    R14,DY#MLEN              point at field lengths\n         LR    R15,R6                   get moving pointer\n         A     R15,0(,R14)              skip first variable\n         A     R6,0(,R7)                bump output string pointer\n         LA    R15,1(,R15)              skip over attr loc\n*\nDY$MF5   LA    R7,4(,R7)                bump pointer\n         LA    R14,4(,R14)              bump pointer\n         L     R2,0(,R14)               get next len\n         LTR   R2,R2                    all done?\n         BZ    DY$TBADD                 yes - exit\n         BCTR  R2,0                     get machine len\n         EX    R2,DY$MMVC               move in data\n         A     R6,0(,R7)                bump output var pointer\n         LA    R15,2(R2,R15)            bump input string ptr\n         B     DY$MF5                   keep going\n         DROPX R2\n*\n*   now parse input line into table variables\n*\nDY$MFLDP CLI   0(R1),X'1D'              IS FIRST BYTE A SF?\n         BNE   DY$ALP\n         LA    R1,2(,R1)                BUMP PAST FIRST SF,ATTR\n         SH    R3,=H'2'                 CORRECT LENGTH\n*\nDY$ALP   LR    R2,R1                    SET START ADDR\n*\nDY$LP    CLI   0(R2),X'1D'              IS THIS NEXT SF?\n         BE    DY$LP1\n         LA    R2,1(,R2)                BUMP INPUT ADDRESS\n         BCT   R3,DY$LP\n*\nDY$LP1   SR    R2,R1                    GET LENGTH TO NEXT SF\n         L     R5,0(,R7)                GET TRUE LENGTH\n         LR    R15,R2                   GET LENGTH OF DATA TO MOVE\n         CR    R15,R5                   IS IT TOO BIG?\n         BNH   DY$LP2\n         LR    R15,R5                   SET TO MAX IN FIELD\n*\nDY$LP2   BCTR  R15,0                    GET MACHINE LENGTH\n         EX    R15,DY$IMVC              MOVE IN DATA\n         LA    R6,0(R5,R6)              BUMP OUTPUT ADDRESS\n         LA    R7,4(,R7)                MOVE LENGTH POINTER\n         LA    R1,2(R2,R1)              BUMP INPUT ADDRESS\n         LR    R2,R1                    GET START ADDR\n         SH    R3,=H'2'                 ACCOUNT FOR SF,ATTR\n         BP    DY$LP\n         LA    R2,QLCBE                 POINT AT MY LCB BLOCK\n         USNGX LCBUFF,R2\n         ICM   R15,B'1111',LCBADDR1     Any value?\n         BZ    *+10                     No - skip\n         MVC   LCBFLD1,0(R15)           Move in orig data\n         ICM   R15,B'1111',LCBADDR2     Any value?\n         BZ    *+10                     No - skip\n         MVC   LCBFLD2,0(R15)           Move in orig data\n         DROPX R2                       LCBUFF\n*\n*  put in table\n*\nDY$TBADD L     R15,ISPLNK               -> ISPLINK\n         CALL  (15),(=CL8'TBADD',TBNAM),VL,                            $\n               MF=(E,DY@CALLP)\n         L     R14,=V(ISPFERR)\n         CH    R15,=H'20'               severe error???\n         BL    *+6                      no - skip call\n         BALR  R15,R14                  tell about it\n         MVC   QDMSG,QBLANK             CLEAR THE MSG WORK AREA\n         B     DY$NAUPD                 exit\n         SPACE 2\nDY$MMVC  MVC   0(0,R6),0(R15)           << executed >>\nDY$IMVC  MVC   0(0,R6),0(R1)            << executed >>\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*   Setup for possible line commands                                  *\n*      R4 ->  line address                                            *\n*      R5 ==  line length + number of attribute bytes                 *\n*                                                                     *\n***********************************************************************\nDY$ADD05 MVC   QDMSG,QBLANK             CLEAR THE MSG WORK AREA\n         OC    QDLCTBL,QDLCTBL          ANY LINE COMMANDS TABLE?\n         BZ    DY$NAUPD                 NO - SKIP ARRAY UPDATE\n         L     R15,DY@TPTR              GET SAVED POINTER\n         LTR   R15,R15                  ANYTHING?\n         BZ    DY$NAUPD                 NO - SKIP ARRAY UPDATE\n         LH    R1,QDLINECT              GET CURRENT LINE COUNT\n         BCTR  R1,0                     MAKE LINE COUNT ORIGIN 0\n         MH    R1,=Y(LCBELEN)           OFFSET OF ARRAY ELEMENT\n         AL    R1,QVLCBUF               -> ARRAY ELEMENT\n         USNGX LCBUFF,R1\n         MVC   0(LCBELEN,R1),0(R15)     SAVE THE ARRAY ELEMENT\n         ICM   R0,B'1111',LCBADDR1      GET OFFSET OF FIRST INPUT FIELD\n         BZ    *+10    >======+         SKIP IF NOT SUPPLIED\n         AR    R0,R4          |         RELOCATE\n         ST    R0,LCBADDR1    V         SAVE UPDATED ADDRESS\n         ICM   R0,B'1111',LCBADDR2      GET OFFSET OF SECOND INPUT FLD\n         BZ    *+10    >======+         SKIP IF NOT SUPPLIED\n         AR    R0,R4          |         RELOCATE\n         ST    R0,LCBADDR2    V         SAVE UPDATED ADDRESS\n         DROPX R1                       LCBUFF\n***********************************************************************\n*                                                                     *\n*   FINISH WITH ADD BY CHECKING IF NEW HEADER IS REQUESTED            *\n*                                                                     *\n***********************************************************************\nDY$NAUPD XC    QDATRNUM,QDATRNUM        NOW NO ATTR BYTES IN LINE\n         TM    QFLAG1,Q1MVHDR           \"MOVE HEADER\" REQUESTED?\n         BNO   QSTOP                    NO - SO DON'T\n         L     R1,QVHLINE               -> WHERE IT GOES\n         LH    R5,QDCOLS                GET LINE LENGTH\n         BCTR  R5,0                     get machine length\n         BCTR  R5,0                     END OF THIS LINE HAS ATTR BYTE\n         EX    R5,DY$MVHDR              MOVE IT TO SCREEN BUFFER\n         NI    QFLAG1,255-Q1MVHDR       RESET FLAG\n         TM    QISFLAG1,QIS1ISPF        Using ISPF DM for screen?\n         BZ    QSTOP                    no - all done\n         LA    R15,QDHLINE              Address of area\n         AH    R15,QDCOLS                Plus number of cols\n         BCTR  R15,0                    Go to last real column\n         MVI   0(R15),C' '              set to blank\n         LA    R15,ZZ#MDL               get addr of simple model\n         C     R15,QMDLPT               see if simple is current\n         BE    DY$ADJ                   yes, so adjust hdr\n         LA    R15,DC#MDL               get addr of DC/CPU model\n         C     R15,QMDLPT               see if this is current\n         BNE   QSTOP                    no, so all done\n*\nDY$ADJ   LA    R5,1(,R5)                update count\n         EX    R5,DY$MVHDR              move in data one way\n         EX    R5,DY$MVHD1              move in data the other\n         MVI   QDHLINE,C' '             blank out first char\n         B     QSTOP                    RETURN TO CALLER\n         SPACE 1\nDY$SCMVC MVC   0(*-*,R4),0(R15)         << EXECUTED >>\nDY$ADD   MVC   0(*-*,R4),QDMSG          << EXECUTED >>\nDY$MVHDR MVC   0(*-*,R1),QDHLINE        << EXECUTED >>\nDY$MVHD1 MVC   QDHLINE+1(*-*),0(R1)     << EXECUTED >>\n***********************************************************************\n*                                                                     *\n*   WRITE A FULL SCREEN, WAIT FOR REPLY                               *\n*                                                                     *\n***********************************************************************\nDY$FULL  LA    R15,QDTOP-8-7            -> AREA-LINELEN FOR ' *MORE'\n         AH    R15,QDCOLS               -> AREA FOR ' *MORE*'\n         MVC   0(7,R15),=C' *MORE*'     INDICATE SCREEN OVERFLOW\n         SPACE 2\nDY$WRITE TM    QISFLAG1,QIS1ISPF        in ISPF?\n         BO    Q5ISPF2                  yes\n         TM    QFLAG1,Q1MVHDR           \"MOVE HEADER\" REQUESTED?\n         BNO   DY$NMVHD                 NO - SKIP\n         L     R1,QVHLINE               -> WHERE IT GOES\n         LH    R14,QDCOLS               GET LINE LENGTH\n         BCTR  R14,0                    -1 FOR ATTR BYTE AT END OF LINE\n         BCTR  R14,0                    -1 FOR EX\n         EX    R14,DY$MVHDR             MVC 0(*-*,R1),QDHLINE\n         NI    QFLAG1,255-Q1MVHDR       RESET FLAG\n         SPACE 1\nDY$NMVHD CLI   QDHLINE,C'*'             ERROR MESSAGE?\n         BNE   DY$NALRM                 NO - SKIP\n         TM    QMODE1,QM1BEEP           WANT NOISE?\n         BNO   DY$NALRM                 NO - SKIP\n         OI    QDWCC,X'04'              YES - SET \"ALARM\"\n         SPACE 1\nDY$NALRM TM    QSCFLAG1,QSC1JOB         NEED JOBID ON TOP LINE?\n         BNO   DY$NOJOB                 NO - SKIP\n         MVI   QDTOP,C' '\n         MVC   QDTOP+1(L'QDHJOBID+1),QDHJOBID  'JOBNAMEX(JOBNNNNN) '\n         SPACE 1\nDY$NOJOB LA    R14,QDTOP-8-7-12         point at area\n         AH    R14,QDCOLS               space over line\n         MVC   0(13,R14),=C' C=XXX P=XXX ' set constant\n         L     R1,16                    -> CVT\n         TM    QMISCFLG,QMFMVSE         IS THIS MVS-XA?\n         BNO   DY$NXA8                  no - skip\n         L     R1,604(,R1)              -> RMCT\n         L     R1,228(,R1)              -> OF RCT\n***      A     R1,=A(56-64)             OFFSET FOR XA\n         LH    R15,56(,R1)              get RCTCPUA FIELD\n         LH    R0,66(,R1)\n         B     DY$YXA8\n*\nDY$NXA8  DS    0H\n         L     R1,604(,R1)              -> RMCT\n         L     R1,228(,R1)              -> RCT\n         LH    R15,64(,R1)              get RCTCPUA FIELD\n         LH    R0,74(,R1)\n*\nDY$YXA8  DS    0H\n***      LH    R15,64(,R1)              get RCTCPUA FIELD\n         SRL   R15,4                    GET VALUE\n         CVD   R15,QNUMWORK\n         UNPK  3(3,R14),QNUMWORK(8)\n         OI    5(R14),X'F0'\n***      LH    R15,74(,R1)\n         CVD   R0,QNUMWORK\n         UNPK  9(3,R14),QNUMWORK(8)\n         OI    11(R14),X'F0'\n         SPACE 1\n         L     R1,QVINPUT               -> input area on scr\n         BCTR  R1,0                     -> to attribute byte\n         MVI   0(R1),X'C8'              set to input, bright\n         TM    QSCFLAG1,QSC1PMPT        PROMPT WITH LAST INPUT COMMAND?\n         BNO   DY$NPMPT                 NO - SKIP\n         NI    QSCFLAG1,255-QSC1PMPT    YES - RESET FLAG\n         MVI   0(R1),X'C9'              set to input, bright,mdt\n         MVC   1(QDREPLYL,R1),QDPROMPT  MOVE IN LAST COMMAND\n         SPACE 1\nDY$NPMPT TM    QTERMFLG,QTFTTY          IS TERMINAL A VIDEO?\n         BO    DY$TTY                   NO - USE ALTERNATE ROUTINE\n*--- SEE IF RA OR SBA SUFFIX ALREADY EXISTS IN BUFFER              ---*\n         L     R1,QDENDPTR              -> PAST POSSIBLE IC AT END\n         LR    R0,R1                    COPY PTR\n         SH    R1,=H'4'                 BACK UP TO START OF SBA/IC SEQ\n         LTR   R0,R0                    ANY?\n         BNZ   DY$TPUT                  YES - ALL SET\n         L     R15,QDNEXT               -> NEXT OUTPUT LOC\n         CLC   QDLINECT,QDROWS          SCREEN FULL?\n         BNE   DY$BSCAN                 NO - BACKSCAN FOR BLANKS\n*--- LAST LINE OF SCREEN HAS DATA ON IT -- SEE IF ROOM FOR RA      ---*\n         LR    R1,R15                   COPY PTR PAST LAST CHAR\n         SH    R15,=H'4'                BACK UP\n         CLC   0(4,R15),QBLANK          LAST 4 CHARS BLANK?\n         BNE   DY$TPUT                  NO - LEAVE AS IS\n         SPACE 2\n*--- BACKSCAN FOR LAST NON-BLANK                                   ---*\nDY$BSCAN BCTR  R15,0                    BACK UP TO LAST CHAR USED\n         BALR  R14,0                    SET LOOP ADDR\n         CLI   0(R15),C' '  <==+        FIND NON-BLANK?\n         BNE   *+6     >=======|==+     YES - EXIT LOOP\n         BCTR  R15,R14   >=====+  V     NO - KEEP LOOKING\n         MVC   1(4,R15),=X'3C404000'    MOVE IN THE RA SEQUENCE\n         LA    R1,1+4(,R15)             SKIP OVER IT\n         SPACE 2\nDY$TPUT  TM    QISFLAG1,QIS1ISPF        in ISPF?\n         BO    Q5ISPF2                  yes\n         BAL   R8,DY$SETCP              SET SBA/IC SEQUENCE\n         ST    R1,QDENDPTR              -> SAVE PTR PAST IC\n         SPACE 2\nRESHOW   LA    R3,QDSCREEN              LOAD ADDRESS OF SCREEN BUFFER\n         L     R2,QDENDPTR              -> LAST BYTE+1 OF STREAM\n         SR    R2,R3                    COMPUTE TPUT LENGTH\n         B     RESHOW01                 SKIP AROUND\n         SPACE 1\nRESHOW00 MVC   QD3270OP,QDERASE         SET WRITE OP TO ERASE WRITE\n         TM    QTERMFLG,QTFVTAM         BUT IS IT A VTAM TERMINAL?\n         BO    RESHOW01                 YES - ERASE WRITE IS OK\n         MVI   QD3270OP,X'F1'           NO - TCAM REQUIRES NORMAL ...\n*                                       ... WRITE TO KEEP BMD'S ...\n*                                       ... ZAPPED TCAM FROM PUKING.\n*---  IF ACF/TCAM SUPPORTS LARGER SCREEN SIZES, THE CODE ABOVE     ---*\n*---  WILL PROBABLY NEED TO BE DISABLED.  I DON'T KNOW ANYTHING    ---*\n*---  ABOUT ACF/TCAM...                                            ---*\nRESHOW01 L     R1,QVINPUT               -> FIRST CHAR (BXH STOP ADDR)\n         LA    R15,QDREPLYL-1(,R1)      -> END OF REPLY INPUT AREA\n         SR    R0,R0                    BXH ...\n         BCTR  R0,0                     ... DECREMENT\n         SPACE 1\nRESHOW02 CLI   0(R15),C' '              FIND END?\n         BNE   RESHOW03                 YES - DISPLAY THE RESULT\n         MVI   0(R15),X'00'             CHANGE TRAILING BLANK TO NULL\n         BXH   R15,R0,RESHOW02          BACKSCAN THE WHOLE THING\n         SPACE 1\nRESHOW03 TM    QFLAG2,Q2SHORT           SHORT WRITE REQUESTED?\n         BNO   TPUTFULL                 NO - GO DO FULL WRITE\n         OI    DY@FLAG,DY@SHORT         in validation (short)\n         NI    QFLAG2,255-Q2SHORT       RESET FLAG\n         LA    R1,QDSCREEN              addressability probs\n         MVC   DY@TEMP(256),0(R1)       COPY ENOUGH OF THE SCREEN...\n         MVC   DY@TEMP+256(256),256(R1)       ...TO INSURE THAT WE ...\n*                                          ... HAVE THE FIRST 3 LINES\n         L     R1,QVLINE1               -> FIRST DATA LINE IN REAL BUFF\n         SR    R1,R3                    COMPUTE OFFSET OF 1ST DATA LINE\n         LA    R0,DY@TEMP               -> TPUT BUFFER FOR SHORT WRITE\n         AR    R1,R0                    OFFSET OF 1ST DATA LINE IN ...\n*                                       ... BUFFER FOR SHORT WRITE\n         SH    R1,=H'2'                 BACK UP OVER TRAILING ATTR BYTE\n         OC    DY@CURS,DY@CURS          ANY CURSOR POSITION SPECIFIED?\n         BNZ   RESHOW04                 YES - USE IT\n         LH    R14,QDCOLNOW             NO - PUT IT ON COL 14 OF LINE 2\n         LA    R14,14-1(,R14)           ... USING LINE LENGTH OF LAST\n         STH   R14,DY@CURS              ... SCREEN WRITTEN\n         SPACE 1\nRESHOW04 BAL   R8,DY$SETCP              SET SBA/IC SEQUENCE\n         SR    R1,R0                    COMPUTE SHORT TPUT LENGTH\n         LR    R15,R1                   MOVE LENGTH TO TEMP REG\n         LR    R1,R0                    MOVE ADDR TO CORRECT REG\n         LR    R0,R15                   MOVE LENGTH TO CORRECT REG\n         B     TPUT$NOW                 GO DO IT\n         SPACE 2\nTPUTFULL LR    R1,R3                    GET THE ADDRESS\n         LR    R0,R2                    GET THE LENGTH\n         SPACE 2\nTPUT$NOW ICM   R1,B'1000',=X'03'        GET FULLSCR FLAG\n         TPUT  (1),(0),R                WRITE SCREEN\n         MVI   QD3270OP,X'F1'           SET WRITE OPCODE TO STD WRITE\n         MVC   QDCOLNOW,QDCOLS          SHOW CURRENT SCREEN LINE LENGTH\n         LA    R14,DY@INPUT             -> INPUT BUFFER\n         LA    R15,L'DY@INPUT           LENGTH\n         L     R1,=X'40000000'          GET SOURCE LENGTH, PAD CHAR\n         MVCL  R14,R0                   FILL INPUT BUFFER WITH BLANKS\n         MVC   QDREPLY,QBLANK\n         MVC   QERRMSG,QBLANK\n         LA    R1,DY@INPUT              LOAD ADDRESS OF REPLY AREA\n         LA    R0,L'DY@INPUT            LENGTH OF INPUT BUFFER\n         SPACE 1\n         TGET  (1),(0),ASIS             WAIT FOR REPLY\n         CLI   DY@AID,X'6B'             PA3? (TCAM10 RESHOW)\n         BNE   *+8                      NO - SKIP\n         MVI   DY@AID,X'6E'             YES - CHANGE TO VTAM RESHOW\n         LR    R4,R1                    SAVE THE INPUT LENGTH\n         CH    R15,=H'8'                ATTN?\n         BE    RESHOW00                 YES\n         CLI   DY@AID,X'6E'             PA2? (RESHOW)\n         BE    DY$TCLRQ                 YES - GO FLUSH REST OF INPUT\n         SPACE 1\nTGET$CHK NI    QDWCC,255-X'04'          RESET \"ALARM\"\n         CH    R15,=H'12'               INPUT LONGER THAN BUFFER?\n         BNE   DY$NOCLR                 NO. CONTINUE.\n         SPACE 1\nDY$TCLRQ TCLEARQ INPUT                  CLEAR THE QUEUE\n         SPACE 1\n         CLI   DY@AID,X'6E'             PA2? (RESHOW)\n         BE    RESHOW00                 YES - RE-DISPLAY LAST SCREEN\n         SPACE 2\nDY$NOCLR OI    QFLAG2,Q2NEWSCR          INDICATE NEXT OUTPUT LINE IS 1\n         L     R1,QVINPUT               -> INPUT AREA ON SCREEN\n         XC    0(QDREPLYL,R1),0(R1)     CLEAR IT\n         LA    R15,DY@INPUT(R4)         -> PAST LAST INPUT CHAR\n         MVI   0(R15),X'11'             PUT IN PHONY ENDING TO STOP TRT\n         CLI   DY@INPUT+3,X'11'         DOES INPUT START WITH SBA?\n         BNE   DY$ERROR                 NO - SCREEN FORMAT ERROR\n         XC    DY@TRTAB,DY@TRTAB        CLEAR TRTAB\n         MVI   DY@TRTAB+X'11',4         SET TO STOP ON SBA\n         MVC   DY@PCMD,QBLANK           NO PRIMARY COMMAND YET\n         XC    DY@PCLEN,DY@PCLEN        ...\n         LA    R3,DY@INPUT+3+1          -> FIRST TEXT CHARACTER\n         SH    R4,=H'3'                 ACCOUNT FOR AID, CURPOS\n* %%%    BNP   DY$PC$GO                 NO INPUT\n         BNP   DY$LC$CZ                 see if old line cmds\n*---  FIXED LENGTH TRT IS OK BECAUSE NO INPUT FIELD IS LONGER THAN ---*\n*---  QDREPLY (66), AND WE WILL HIT THE EXTRA SBA PREVIOUSLY SET   ---*\n*---  DOWN.                                                        ---*\n         SR    R1,R1                    CLEAR FOR IC\nDY$FLOOP TRT   2(80,R3),DY@TRTAB        FIND AN SBA\n         BZ    DY$ERROR                 NONE???\n         MVC   DY@FIELD,QBLANK          CLEAR WORK FIELD\n         SR    R1,R3                    COMPUTE FIELD LENGTH\n         SH    R1,=H'3'                 -1 FOR EX, -2 FOR LOC\n         BM    *+8\n         EX    R1,DY$FMVC               MOVE TO DY@FIELD\n*---  LEFT JUSTIFY THE DATA IN DY@FIELD                            ---*\n         CLC   DY@FIELD,QBLANK          ANYTHING HERE AT ALL?\n         BE    DY$FNONE                 NO - SKIP\nDY$FLEFT CLI   DY@FIELD,C' '            LEFT JUSTIFIED?\n         BNE   DY$FNONE                 YES - CONTINUE\n         MVC   DY@FIELD(L'DY@FIELD-1),DY@FIELD+1   NO - SHIFT IT OVER\n         MVI   DY@FIELD+L'DY@FIELD-1,C' '  CLEAR THE OPENED UP HOLE\n         B     DY$FLEFT                 KEEP SHIFTING\n         SPACE 1\nDY$FNONE LA    R1,1(,R1)                GET FIELD LENGTH\n         NC    0(2,R3),=X'3F3F'         MAKE TWO 6-BIT BYTES\n         SR    R14,R14                  CLEAR FOR IC\n         IC    R14,0(,R3)               GET HIGH ORDER 6 BITS OF ADDR\n         SLL   R14,6                    ADJUST\n         SR    R15,R15                  CLEAR FOR IC\n         IC    R15,1(,R3)               GET LOW ORDER 6 BITS OF ADDR\n         OR    R15,R14                  GET FIELD LOCATION\n         SR    R14,R14                  CLEAR FOR DIVIDE\n         LH    R0,QDCOLS                GET LINE LENGTH\n         DR    R14,R0                   COMPUTE LINE NUMBER\n         CH    R15,=H'1'                SECOND SCREEN LINE?\n*%%%     BNE   DY$FSEL                  NO - MUST BE A SELECT LINE\n         BH    DY$FSEL                  NO - MUST BE A SELECT LINE\n         STH   R1,DY@PCLEN              SAVE LENGTH OF PRIMARY COMMAND\n         MVC   DY@PCMD,DY@FIELD         SAVE PRIMARY COMMAND\n         CLC   DY@FIELD,QBLANK          IS LINE BLANK??\n         BNE   DY$FNEXT                 NO - GO AND DO NEXT FLD\n         XC    DY@PCLEN,DY@PCLEN        SET LEN = 0 FOR BLANK\n         SPACE 2\nDY$FNEXT LA    R3,3(R1,R3)              -> PAST SBA OF NEXT FIELD\n         SR    R4,R1                    COMPUTE...\n         SH    R4,=H'3'                 ... REMAINING LENGTH\n         BP    DY$FLOOP                 PROCESS IT\n         SPACE 2\n*---  SEE IF ANY LINE COMMANDS PRESENT                             ---*\nDY$LC$CZ TM    DY@FLAG,DY@SHORT         in validation??\n         BO    DY$PC$GO                 yes - look at prim\n         L     R2,QVLCBUF               -> LINE COMMAND BUFFER\n         LA    R0,43-3                  NUMBER OF ARRAY ELEMENTS\n         USNGX LCBUFF,R2\nDY$LC$L1 CLI   LCBFLD1,C' '             ANYTHING HERE?\n         BH    DY$LC$EX                 YES - GO CHECK IT\n         LA    R2,LCBELEN(,R2)          -> NEXT BUFFER ARRAY ELEMENT\n         BCT   R0,DY$LC$L1              KEEP LOOKING\n*---  NO LINE COMMANDS ENTERED - EXECUTE PRIMARY COMMAND, IF ANY   ---*\n         MVC   QDREPLY,DY@PCMD          NO - GET PRIMARY LINE CMD\n         MVC   QDRLNG,DY@PCLEN          ... AND ITS LENGTH\n         B     DY$PC$GO                 GO EXECUTE IT\n         SPACE 1\n         DROPX R2                       LCBUFF\n         SPACE 1\nDY$FMVC  MVC   DY@FIELD(*-*),2(R3)      << EXECUTED >>\n         SPACE 3\n*---  STORE LINE COMMANDS                                          ---*\nDY$FSEL  LR    R0,R15                   COPY LINE NUMBER\n         SH    R15,=H'3'                ADJUST - FIRST IS ON LINE 4\n*                                       (R15 WAS ORIGIN 0)\n         BM    DY$ERR2                  LOGIC ERROR\n         MH    R15,=Y(LCBELEN)          OFFSET OF LINE CMD TABLE ENTRY\n         AL    R15,QVLCBUF              -> CORRECT ARRAY ELEMENT\n         USNGX LCBUFF,R15\n         CH    R14,=H'1'                FIELD AT LEFT SIDE OF SCREEN?\n         BE    DY$FCMD                  YES - MUST BE SUBCOMMAND NAME\n         MVC   LCBFLD2,DY@FIELD         SET OPERAND IN LINE CMD TABLE\n         OC    LCBFLD2,QBLANK           MAKE IT UPPER CASE\n         ICM   R14,B'1111',LCBADDR2     GET OPERAND LOC IN SCREEN BUFF\n         BZ    DY$FNEXT                 SKIP IF NOT SUPPLIED\n         MVC   0(8,R14),DY@FIELD        OPRND TO SCREEN IN CASE RESHOW\n         B     DY$FNEXT                 PROCESS NEXT INPUT FIELD\n         SPACE 1\nDY$FCMD  XC    LCBTPTR,LCBTPTR          CLEAR CMD TABLE ENTRY POINTER\n         MVC   LCBFLD1,DY@FIELD         SET CMDNAME IN LINE CMD TABLE\n         OC    LCBFLD1,QBLANK           MAKE IT UPPER CASE\n         ICM   R14,B'1111',LCBADDR1     GET CMDNAME LOC IN SCREEN BUFF\n         BZ    DY$FNEXT                 SKIP IF NOT SUPPLIED\n         MVC   0(2,R14),DY@FIELD        CMD TO SCREEN IN CASE RESHOW\n         B     DY$FNEXT                 PROCESS NEXT FIELD\n         SPACE 1\n         DROPX R15                      LCBUFF\n         SPACE 2\nDY$ERR2  L     R0,=C'DY2 '              SET LOGIC ERROR CODE\n         L     R15,=V(LOGICERR)         -> ROUTINE\n         BALR  R14,R15                  GO TO IT (NO RETURN)\n         SPACE 2\nDY$ERR3  L     R0,=C'DY3 '              SET LOGIC ERROR CODE\n         L     R15,=V(LOGICERR)         -> ROUTINE\n         BALR  R14,R15                  GO TO IT (NO RETURN)\n         SPACE 3\n*---  CHECK FOR PROBLEMS WITH LINE COMMANDS                        ---*\n         USNGX LCBUFF,R2\nDY$LC$EX OC    DY@PCLEN,DY@PCLEN        ANY PRIMARY COMMAND ENTERED?\n         BNZ   DY$LC$E1                 YES - GENERATE ERROR MSG\n         NI    DY@FLAG,255-DY@DCMD      NO DESTRUCTIVE CMD FOUND YET\n*---  FIND THE LINE COMMAND TABLE ENTRY                            ---*\nDY$LC$CK CLI   LCBFLD1,C' '             ANYTHING HERE?\n         BNH   DY$LC$L3                 NO - SKIP THIS ENTRY\n         L     R1,QDLCTBL               -> LINE CMD TABLE\n         LTR   R1,R1                    ANY?\n         BZ    DY$ERR3                  NO - ERROR\n         SPACE 1\n         USNGX LCTABLE,R1\nDY$LC$L2 CLC   LCBFLD1,LCTCMDNM         THIS IT?\n         BE    DY$LCGOT                 YES\n         LA    R1,LCTELEN(,R1)          -> NEXT TABLE ENTRY\n         CLI   0(R1),X'FF'              END OF TABLE?\n         BNE   DY$LC$L2                 NO - KEEP LOOKING\n         SPACE 1\n*---  LINE COMMAND IS INVALID                                      ---*\nDY$INVLC MVC   QDHLINE,QBLANK           CLEAR ERROR MSG AREA\n         MVC   QDHLINE(33),=C'*** LINE COMMAND \"XX\" INVALID ***'\n         MVC   QDHLINE+18(2),LCBFLD1    FILL IN BAD COMMAND NAME\n         SPACE 1\n*---  LINE COMMAND ERROR - SET CURSOR POSITION                     ---*\nDY$LC$ER LA    R14,43                   COMPUTE LINE NUMBER ...\n         SR    R14,R0                   ... OF BAD COMMAND\n         MH    R14,QDCOLS               MAKE IT SCREEN POSITION\n         LA    R14,1(,R14)              MAKE IT COLUMN 2\n         STH   R14,DY@CURS              SAVE FOR COMPUTE\n         OI    QFLAG1,Q1MVHDR           REQUEST \"MOVE HEADER\"\n         B     DY$WRITE                 GO RE-WRITE THE SCREEN\n         SPACE 1\nDY$LCGOT TM    LCTFLAGS,LCTFPRIV        PRIV CMD?\n         BNO   *+12     >========+      NO - OK\n         TM    QXAUTH,QXAUTHX    |      PRIV USER?\n         BZ    DY$INVLC          |      NO - SAY INVALID COMMAND\n         ST    R1,LCBTPTR   <====+      SAVE IN LINE CMD BUFFER\n         TM    LCTFLAGS,LCTFDCMD        IS THIS A DESTRUCTIVE COMMAND?\n         BNO   DY$LC$L3                 NO - SKIP\n         TM    DY@FLAG,DY@DCMD          ALREADY HIT DESTRUCTIVE CMD?\n         BO    DY$LC$E2                 YES - CONFLICT\n         OI    DY@FLAG,DY@DCMD          REMEMBER DESTRUCTIVE CMD FOUND\nDY$LC$L3 LA    R2,LCBELEN(,R2)          -> NEXT BUFFER ARRAY ELEMENT\n         BCT   R0,DY$LC$CK              CHECK ALL ELEMENTS\n         SPACE 2\n*---  RETURN TO MAINLINE TO EXECUTE LINE COMMANDS                  ---*\n         QNEWCMD  LINE                  from dispaly\n         SPACE 1\n         DROPX R2,R1                    LCBUFF, LCTABLE\n         SPACE 3\nDY$LC$E1 MVC   QDHLINE,QBLANK           CLEAR ERROR MSG AREA\n         MVC   QDHLINE(56),=C'*** PRIMARY AND LINE COMMANDS ARE MUTUALL$\n               Y EXCLUSIVE ***'\n         OI    QFLAG1,Q1MVHDR           REQUEST \"MOVE HEADER\"\n         OI    QSCFLAG1,QSC1PMPT        reprompt\n         MVC   QDPROMPT,DY@PCMD         set prompt as new prim\n         B     DY$WRITE                 GO RE-WRITE THE SCREEN\n         SPACE 2\nDY$LC$E2 MVC   QDHLINE,QBLANK           CLEAR ERROR MSG AREA\n         MVC   QDHLINE(29),=C'*** LINE COMMAND CONFLICT ***'\n         B     DY$LC$ER                 GO SET UP FOR RE-WRITE\n         SPACE 3\n*  REGISTER USAGE:\n*    R6 -> NEXT LOC IN QDREPLY\n*    R5  - LENGTH CURRENTLY IN QDREPLY\n*    R4  - LENGTH REMAINING IN INPUT STREAM\n*    R1  - LOW NIBBLE OF AID\nDY$PC$GO LH    R4,DY@PCLEN              GET LENGTH OF PRIMARY COMMAND\n         LA    R6,QDREPLY               %%%\n         XR    R5,R5                    INITIAL \"LENGTH IN QDREPLY\"\n         LA    R15,QDREPLYL-1           GET LENGTH TO MOVE (EX LEN)\n         IC    R1,DY@AID                GET AID\n         N     R1,=X'0000000F'          EXTRACT PF-KEY NUMBER\n         CH    R1,=H'12'\n         BH    DY$ENTER                 \"ENTER\" KEY\n         TM    QMODE1,QM1PFK24          24 UNIQUE PFKEYS IN USE?\n         BNO   DY$PFK12                 NO - KEEP AS 1-12\n         TM    DY@AID,B'00110000'       1-12 OR 13-24???\n         BO    DY$PFK12                 1-12, OK AS IS\n         LA    R1,12(,R1)               ADJUST FOR 13-24\nDY$PFK12 CH    R1,=H'4'                 PF4/16 (PRINT = SPF RETURN)\n         BNE   DY$NOTK4                 NO - CONTINUE\n         CLI   DY@PCMD,C'='             DOES HE THINK HE'S IN SPF?\n         BE    DY$ENTER                 YES - DON'T COMPOUND CONFUSION\nDY$NOTK4 BCTR  R1,0                     ADJUST ORIGIN\n         SLL   R1,6                     MULTIPLY BY 64\n         A     R1,QVPFKEYS              -> THIS PFK COMMAND\n         MVC   QDREPLY(64),0(R1)        MOVE PF-KEY VALUE\n         LA    R5,64                    LENGTH NOW IN QDREPLY\n         LA    R6,QDREPLY+3             SKIP OVER PF KEY COMMAND\n         SH    R15,=H'3'                ADJUST LENGTH LEFT TO MOVE\n*Y$ENTER SH    R4,=H'3' %%%             ADJUST REMAINING INPUT LENGTH\nDY$ENTER LTR   R4,R4    %%%             ANY INPUT REMAINING?\n         NOPR  0        %%%\n         BZ    DY$NOTXT                 SKIP IF NO OPERAND TO PFKEY\n         EX    R15,DY$TXMVC             MVC 0(*-*,R6),DY@PCMD\n         OC    DY@PCMD,QBLANK           TURN ALL HEX ZEROES TO BLANKS\n         CLC   DY@PCMD,QBLANK           ANYTHING BESIDES NULLS & BLNKS?\n         BNE   DY$3TEXT                 YES - PROCESS\n         SR    R4,R4                    NOTHING CURRENTLY IN QDREPLY\n         B     DY$NOTXT                 CONTINUE\n         SPACE 2\nDY$3TEXT LA    R5,3                     LNTH IN QDREPLY BEFORE NEW TEXT\n         SPACE 1\nDY$NOTXT LA    R4,0(R5,R4)              COMPUTE LENGTH IN QDREPLY\n         STH   R4,QDRLNG                STORE LENGTH OF REPLY\n         LTR   R4,R4                    RESPONSE FROM USER?\n         BNZ   DY$INTER                 YES. INTERRUPT PROCESSING.\n         MVI   QDOVER,1                 INDICATE PAGE OVERFLOW\n         BAL   R8,DY$SETTL              CLEAR THE SCREEN BUFFER\n         TM    DY@FLAG,DY@IMM           WAS REQUEST FOR IMMED WRITE?\n         BO    QSTOP                    YES - ALL DONE\n         OI    QFLAG1,Q1MVHDR           REQUEST \"MOVE HEADER\"\n         B     DY$ADD02                 NO - MOVE SAVED LINE TO SCREEN\n         SPACE 2\nDY$ERROR LA    R1,=C'*** SCREEN FORMAT ERROR ***'\n         LA    R0,27                    MSG LENGTH\n         SPACE 1\n         TPUT  (1),(0),R\n         B     RESHOW                   WRITE WHOLE SCREEN AGAIN\n         SPACE 2\nDY$INTER L     R8,QVSAVE                -> MY SAVE AREA\n         MVC   0(QSAVE1L,R8),QSAVE1     MOVE FIRST PART\n         MVC   QSAVE1L(QSAVE2L,R8),QSAVE2    SECOND PART\n         IC    R5,DY@AID                SAVE AID\n         QCALL PARSE                    PARSE THE INPUT\n         CLM   R5,B'0001',=X'7D'        ENTER?\n         BNE   DY$NOT7D                 NO - DON'T SAVE CMD IN RING BUF\n         L     R15,QSUBCMD              GET SUBCOMMAND EPA\n         CL    R15,=A(RECALL)           \"RECALL\" REQUEST?\n         BE    DY$NOT7D                 YES - NEVER SAVE IN RING BUFFER\n         LH    R14,QCMDNUM              GET CURRENT COMMAND NUMBER\n         LA    R14,1(,R14)              INCREMENT\n         STH   R14,QCMDNUM              SAVE UPDATED NUMBER\n         STH   R14,QRETNUM              SET NUMBER OF COMMAND TO RECALL\n         N     R14,=F'15'               COMPUTE NUMBER MODULE(16)\n         MH    R14,=Y(QDREPLYL)         GET OFFSET INTO RING BUFFER\n         AL    R14,QVRING               -> CURRENT SLOT IN RING\n         MVC   0(QDREPLYL,R14),QDREPLY  SAVE CURRENT COMMAND IN RING\nDY$NOT7D TM    QFLAG1,Q1IMMED           IMMEDIATE COMMAND?\n         BO    DY$IMMED                 YES - GO EXECUTE IT\n         SPACE 2\n*---  A NEW PRIMARY COMMAND HAS BEEN ENTERED - CLEAR ALL LINE CMDS ---*\nDY$ARRGH XC    QDLCTBL,QDLCTBL          NO LINE COMMANDS VALID NOW\n         L     R15,QVLCBUF              -> LINE CMD BUFFER\n         USNGX LCBUFF,R15\n         LA    R0,43-3                  NUMBER OF ENTRIES TO CLEAR\nDY$ARG01 XC    0(LCBELEN,R15),0(R15)    CLEAR AN ENTRY\n         MVI   LCBTPTR,X'80'            INDICATE NOTHING HERE\n         LA    R15,LCBELEN(,R15)        -> NEXT ENTRY\n         BCT   R0,DY$ARG01              CLEAR ALL ENTRIES\n         DROPX R15\n         MVC   QDPROMPT,QDREPLY         SAVE REPLY IN CASE REPROMPT\n         QNEWCMD  PRIMARY               from dispaly\n         SPACE 2\nDY$IMMED L     R15,QSUBCMD              GET SUBCOMMAND EPA\n         CL    R15,=A(RECALL)           \"RECALL\" REQUEST?\n         BE    RECALL                   YES - GO THERE\n         QCALL (R15)                    INVOKE IMMEDIATE SUBCOMMAND\n         TM    QFLAG1,Q1IMMED           DID SUBCMD RESET \"IMMEDIATE\"?\n         BNO   DY$ARRGH                 YES - LET MAINLINE RE-INVOKE IT\n         TM    QFLAG2,Q2REPOS           REPOSITIONING SUBCOMMAND?\n         MVC   QSAVE1(QSAVE1L),0(R8)    RESTORE FIRST PART\n         MVC   QSAVE2(QSAVE2L),QSAVE1L(R8)      SECOND PART\n         BO    DY$REPOS                 YES (REPOSITIONING SUBCOMMAND)\n         TM    QTERMFLG,QTFTTY          DISPLAY TERMINAL?\n         BNO   RESHOW                   YES - DISPLAY SCREEN AGAIN\n         B     DYTTYTG                  NO - GO BACK TO TTY INPUT\n         SPACE 2\nDY$REPOS TM    QFLAG2,Q2LISTDS          ARE WE IN LISTDS?\n         BO    DY$LSTDS                 YES - OK\n         L     R0,=C'DY4 '              SET LOGIC ERROR CODE\n         L     R15,=V(LOGICERR)         -> ROUTINE\n         BALR  R14,R15                  GO TO IT (NO RETURN)\n         SPACE 1\n*---  SIMULATE AN \"RD\" COMMAND (SORT OF)                           ---*\nDY$LSTDS MVC   QSUBCMD,=V(LISTDS)       FAKE THE SUBCOMMAND ADDRESS\n         MVI   QCODE,99                 INDICATE REPOSITIONING\n         QNEWCMD  PRIMARY               from dispaly\n         SPACE 2\n         ENTRY RECALL\n*ECALL   LA    R1,QDPROMPT              ASSUME REGULAR RECALL REQUEST\nRECALL   CLI   QKEYWORD,C' '            RECALL LAST?\n         BE    RECALL$1                 RIGHT - OK\n         CLI   QKEYWORD+16,C' '         A SECOND KEYWORD?\n         BNE   RECALLNO                 YES - NO GOOD\n         LA    R1,QFINDCMD              ASSUME RECALL LAST FIND CMD\n         CLI   QKEYWORD,C'F'            RECALL LAST FIND COMMAND?\n         BE    RECALLGO                 YES\n         LA    R1,QTSOCMD               ASSUME RECALL LAST TSO CMD\n         CLI   QKEYWORD,C'T'            RECALL LAST TSO COMMAND?\n         BE    RECALLGO                 YES\n         LA    R1,QINQCMD               ASSUME RECALL LAST INQUIRY\n         CLI   QKEYWORD,C'I'            RECALL LAST INQUIRY COMMAND?\n         BE    RECALLGO                 YES\n         LA    R1,QMVSCMD               ANYTHING ELSE MUST BE MVS\n         B     RECALLGO                 CONTINUE\n         SPACE 1\nRECALL$1 LH    R1,QRETNUM               GET COMMAND NUMBER TO RECALL\n         LR    R0,R1                    COPY FOR ADJUSTMENT\n         SH    R0,=H'1'                 BACK UP FOR NEXT RECALL\n         BNM   *+8                      SKIP IF NOT BACK TO START\n         LH    R0,QCMDNUM               ELSE RESET BACK TO TOP\n         STH   R0,QRETNUM               SAVE NBR OF NEXT CMD TO RECALL\n         N     R1,=F'15'                COMPUTE NUMBER MODULE(16)\n         MH    R1,=Y(QDREPLYL)          GET OFFSET INTO RING\n         AL    R1,QVRING                -> COMMAND TO RECALL\n         SPACE 1\nRECALLGO MVC   QSAVE1(QSAVE1L),0(R8)    RESTORE FIRST PART\n         MVC   QSAVE2(QSAVE2L),QSAVE1L(R8)      SECOND PART\n         OI    QFLAG2,Q2SHORT           INDICATE SHORT WRITE\n         TM    QTERMFLG,QTFTTY          DISPLAY TERMINAL?\n         BO    DY$TTYPM                 NO - ALTERNATE ROUTINE\n         L     R14,QVINPUT              -> INPUT AREA ON SCREEN\n         MVC   0(QDREPLYL,R14),0(R1)    COPY LAST COMMAND\n         B     RESHOW                   RE-DISPLAY SCREEN\n         SPACE 1\nRECALLNO MVC   QDHLINE,QBLANK           CLEAR ERROR MSG AREA\n         MVC   QDHLINE(27),=C'*** CONFLICTING OPTIONS ***'\n         SPACE 1\nDY$TILT  L     R1,QVINPUT               -> INPUT AREA ON SCREEN\n         MVC   0(QDREPLYL,R1),QDREPLY   MOVE IN LAST COMMAND\n         OI    QFLAG1,Q1MVHDR           REQUEST \"MOVE HEADER\"\n         B     DY$WRITE                 FAKE QTILT\n         SPACE 3\n*---  SUBROUTINE TO REBUILD TOP SCREEN LINE                        ---*\nDY$SETTL LH    R15,QDCOLS               GET SCREEN WIDTH\n         SH    R15,=H'9'                ADJUST FOR ' QUEUE -' & EXECUTE\n         EX    R15,DY$MVTOP             RESET TOP LINE TO DASHES\n         BR    R8                       RETURN TO CALLER\nDY$MVTOP MVC   QDTOP(*-*),QDTOP-1       << EXECUTED >>\n         SPACE 3\n*---  SUBROUTINE TO GENERATE 3270 CURSOR POSITION SEQUENCE         ---*\nDY$SETCP MVC   0(4,R1),=X'11000013'     PUT IN SBA/IC SEQUENCE\n         LH    R14,DY@CURS              GET CURSOR POSITION\n         XC    DY@CURS,DY@CURS          SET TO DEFAULT NEXT TIME\n         LTR   R14,R14                  ANY?\n         BNZ   *+12     >=======+       YES - OK\n         LA    R14,14-1         |       NO - USE COL 14 ...\n         AH    R14,QDCOLS       |       ... ON LINE 2\n         SRDL  R14,6     <======+       GET LOW ORDER SIX BITS IN R15\n         SRL   R15,32-6                 SHIFT TO LOW END OF REGISTER\n         STC   R14,1(,R1)               SET DOWN HI ORDER 6 BITS\n         STC   R15,2(,R1)               SET DOWN LO ORDER 6 BITS\n         TR    1(2,R1),DY#T3270         TRANSLATE TO VALID 3270 CHARS\n         LA    R1,4(,R1)                BUMP OUTPUT POINTER\n         BR    R8                       RETURN TO CALLER\n         SPACE 3\n***********************************************************************\n*                                                                     *\n*   WRITE A FULL SCREEN, WAIT FOR REPLY      ISPF MODE                *\n*                                                                     *\n***********************************************************************\nQ5ISPF2  EQU   *\n         L     R1,16                    -> CVT\n         TM    QMISCFLG,QMFMVSE         IS THIS MVS-XA?\n         BNO   NOXA3                    no - skip\n         L     R1,604(,R1)              -> RMCT\n         L     R1,228(,R1)              -> RCT\n***      A     R1,=A(56-64)   OFFSET FOR XA\n         LH    R15,56(,R1)              LOAD RCTCPUA FIELD\n         LH    R0,66(,R1)\n         B     YXA3\nNOXA3    DS    0H\n         L     R1,604(,R1)              LOAD ADDR OF RMCT\n         L     R1,228(,R1)              LOAD ADDR OF RCT\n         LH    R15,64(,R1)              LOAD RCTCPUA FIELD\n         LH    R0,74(,R1)\nYXA3     DS    0H\n***      LH    R15,64(,R1)              LOAD RCTCPUA FIELD\n         SRL   R15,4                    GET VALUE\n         CVD   R15,QNUMWORK\n         UNPK  QCPU(3),QNUMWORK(8)\n         OI    QCPU+2,X'F0'\n***      LH    R15,74(,R1)\n         CVD   R0,QNUMWORK\n         UNPK  QDPR(3),QNUMWORK(8)\n         OI    QDPR+2,X'F0'\n         MVC   QDHISFID(18),=18C'-'     fill with dashes\n         TM    QSCFLAG1,QSC1JOB         job id ok\n         BZ    DY$IDH                   no so leave as dashes\n         MVC   QDHISFID,QDHJOBID        set proper jobid\n*\n*\n*\nDY$IDH   L     R4,ISPLNK                -> ISPLINK\n         TM    QISFLAG1,QIS1TBOP        is table open?\n         BO    DY$DSPZ                  yes - skip create\n         LR    R15,R4                   -> ISPLINK\n         CALL  (15),(=CL8'TBCREATE',TBNAM,0,V8,=CL8'NOWRITE'),VL,      $\n               MF=(E,DY@CALLP)\n         L     R14,=V(ISPFERR)\n         CH    R15,=H'20'               severe error???\n         BL    *+6                      no - skip call\n         BALR  R15,R14                  tell about it\n         LA    R5,ZZ#MDL                Use simple for no adds\n         USNGX DY#MDL,R5\n         LA    R6,DY#MVAR               get address of ZVARS\n*  define ZVARS value\n         LR    R15,R4                   -> ISPLINK\n         CALL  (15),(=CL8'VREPLACE',=CL8'QZVARS',=F'30',(R6)),VL,      $\n               MF=(E,DY@CALLP)\n         LA    R6,DY#MLN                get address of model line\n*  define table line\n         LR    R15,R4                   -> ISPLINK\n         CALL  (15),(=CL8'VREPLACE',=CL8'QMDL',=F'80',(R6)),VL,        $\n               MF=(E,DY@CALLP)\n         OI    QISFLAG1,QIS1TBOP        mark table open\n         DROPX R5\n***********************************************************************\n*                                                                     *\n*        If we need to prompt, set cmd variable.                      *\n*                                                                     *\n***********************************************************************\nDY$DSPZ  TM    QSCFLAG1,QSC1PMPT        PROMPT WITH LAST INPUT\n         BNO   DY$DSPZA                 NO - SKIP\n         NI    QSCFLAG1,255-QSC1PMPT    YES - RESET FLAG\n         LA    R0,QDREPLYL              maximum length\n         ST    R0,DY@VLEN               set for VCOPY\n         LR    R15,R4                   -> ISPLINK\n         CALL  (15),(=CL8'VREPLACE',=CL8'QRPMT',DY@VLEN,QDPROMPT),VL,  $\n               MF=(E,DY@CALLP)\n         L     R14,=V(ISPFERR)\n         CH    R15,=H'20'               severe error???\n         BL    *+6                      no - skip call\n         BALR  R15,R14                  tell about it\n***********************************************************************\n*                                                                     *\n*        Now set table to top and display.                            *\n*                                                                     *\n***********************************************************************\nDY$DSPZA DS    0H                                             A-16JUL91\n         OC    QTBDROW,QTBDROW          Any row to repos to?? A-16JUL91\n         BNZ   DY$DSPZB                 Yes - go and do it    A-16JUL91\n         LR    R15,R4                   -> ISPLINK\n         CALL  (15),(=CL8'TBTOP',TBNAM),VL,                            $\n               MF=(E,DY@CALLP)\n         L     R14,=V(ISPFERR)\n         CH    R15,=H'20'               severe error???\n         BL    *+6                      no - skip call\n         BALR  R15,R14                  tell about it\n         B     DY$DSPZC                 continue w/ TBDISPL   A-16JUL91\nDY$DSPZB DS    0H                                             A-16JUL91\n         LR    R15,R4                                         A-16JUL91\n         CALL  (15),(=CL8'TBSKIP',TBNAM, skip to right row    A-16JUL91$\n               0,0,0,QTBDROW),VL,                             A-16JUL91$\n               MF=(E,DY@CALLP)                                A-16JUL91\n         L     R14,=V(ISPFERR)                                A-16JUL91\n         CH    R15,=H'20'               severe error ???      A-16JUL91\n         BL    *+6                      no - skip call        A-16JUL91\n         BALR  R15,R14                  tell about it         A-16JUL91\nDY$DSPZC DS    0H                                             A-16JUL91\n         LR    R15,R4                   -> ISPLINK\n         CALL  (15),(=CL8'TBDISPL',TBNAM,TBPNL),VL,                    $\n               MF=(E,DY@CALLP)\n         L     R14,=V(ISPFERR)\n         CH    R15,=H'20'               severe error???\n         BL    *+6                      no - skip call\n         BALR  R15,R14                  tell about it\n         ST    R15,DY@ITDRC\n         NI    DY@FLAG,255-DY@ILNCD-DY@DCMD  no line & no dest yet\n***********************************************************************\n*                                                                     *\n*        COPY IN THE ISPF VERB FOR \"RETURN\" TEST                      *\n*                                                                     *\n***********************************************************************\n         LA    R0,8                     maximum length\n         ST    R0,DY@VLEN               set for VCOPY\n         LR    R15,R4\n         CALL  (15),(=CL8'VCOPY',=CL8'ZVERB',DY@VLEN,QDREPLY,          $\n               =CL8'MOVE'),VL,                                         $\n               MF=(E,DY@CALLP)\n         L     R14,=V(ISPFERR)\n         CH    R15,=H'20'               severe error???\n         BL    *+6                      no - skip call\n         BALR  R15,R14                  tell about it\n         MVC   DY@ZVERB,QDREPLY         save verb\n***********************************************************************\n*                                                                     *\n*        COPY IN THE PRIMARY COMMAND VARIABLE                         *\n*                                                                     *\n***********************************************************************\n         LA    R0,QDREPLYL              maximum length\n         ST    R0,DY@VLEN               set for VCOPY\n         LR    R15,R4                   -> ISPLINK\n         CALL  (15),(=CL8'VCOPY',=CL8'ZCMD',DY@VLEN,QDREPLY,           $\n               =CL8'MOVE'),VL,                                         $\n               MF=(E,DY@CALLP)\n         L     R14,=V(ISPFERR)\n         CH    R15,=H'20'               severe error???\n         BL    *+6                      no - skip call\n         BALR  R15,R14                  tell about it\n         LA    R6,QDREPLY               POINT AT REPLY\n         L     R5,DY@VLEN               GET LENGTH OF REPLY\n         STH   R5,QDRLNG                STORE LENGTH OF REPLY\n***********************************************************************\n*                                                                     *\n*        IF A LINE COMMAND WAS SPECIFIED HANDLE IT                    *\n*                                                                     *\n***********************************************************************\nDY$DSPZ1 LR    R15,R4                   -> ISPLINK\n         MVC   DY@ISLN,=F'4'            set length\n         CALL  (15),(=CL8'VCOPY',=CL8'ZTDSELS',DY@ISLN,DY@PCMD,        $\n               =CL8'MOVE'),VL,                                         $\n               MF=(E,DY@CALLP)\n         L     R14,=V(ISPFERR)\n         CH    R15,=H'20'               severe error???\n         BL    *+6                      no - skip call\n         BALR  R15,R14                  tell about it\n         CLC   DY@PCMD(4),=CL4'0000'    selected entries zero?\n         BE    DY$DSPZ2                 yes so none selected\n         LA    R6,QLCBE                 point at LCB entry\n         USNGX LCBUFF,R6\n         ICM   R1,B'1111',LCBADDR1      any variable?\n         BZ    DY$ILCB1                 no - skip mvc\n         CLC   LCBFLD1,0(R1)            did value change?\n         BE    DY$ILCA2                 no - go blank it\n         MVC   LCBFLD1,0(R1)            save any value\n         B     DY$ILCB1\n*\nDY$ILCA2 MVC   LCBFLD1,QBLANK           clear data\n*\nDY$ILCB1 ICM   R1,B'1111',LCBADDR2      any variable?\n         BZ    DY$ILCEX                 no - skip mvc\n         CLC   LCBFLD2,0(R1)            did value change?\n         BE    DY$ILCB2                 no - go blank it\n         MVC   LCBFLD2,0(R1)            save any value\n         B     DY$ILCEX\n*\nDY$ILCB2 MVC   LCBFLD2,QBLANK           clear data\n*\nDY$ILCEX OC    QDRLNG,QDRLNG            ANY PRIME CMD ENTERED?\n         BNZ   DY$LC$E1                 YES - GENERATE ERROR MSG\n*---  FIND THE LINE COMMAND TABLE ENTRY\nDY$ILCCK CLI   LCBFLD1,C' '             ANYTHING HERE?\n         BNH   DY$ILCL3                 NO - SKIP THIS ENTRY\n         L     R1,QDLCTBL               -> LINE CMD TABLE\n         LTR   R1,R1                    ANY?\n         BZ    DY$ERR3                  NO - ERROR\n         SPACE 1\n         USNGX LCTABLE,R1\nDY$ILCL2 CLC   LCBFLD1,LCTCMDNM         THIS IT?\n         BE    DY$ILCGT                 YES\n         LA    R1,LCTELEN(,R1)          -> NEXT TABLE ENTRY\n         CLI   0(R1),X'FF'              END OF TABLE?\n         BNE   DY$ILCL2                 NO - KEEP LOOKING\n         SPACE 1\n*---  LINE COMMAND IS INVALID\nDY$INVLI MVC   QDHLINE,QBLANK           CLEAR ERROR MSG AREA\n         MVC   QDHLINE(33),=C'*** LINE COMMAND \"XX\" INVALID ***'\n         MVC   QDHLINE+18(2),LCBFLD1    FILL IN BAD COMMAND NAME\n         SPACE 1\n*---  LINE COMMAND ERROR - SET CURSOR POSITION\nDY$ILCER DS    0H\n         OI    QFLAG1,Q1MVHDR           REQUEST \"MOVE HEADER\"\n         B     DY$WRITE                 GO RE-WRITE THE SCREEN\n         SPACE 2\nDY$ILCE2 MVC   QDHLINE,QBLANK           CLEAR ERROR MSG AREA\n         MVC   QDHLINE(29),=C'*** LINE COMMAND CONFLICT ***'\n         B     DY$ILCER                 GO SET UP FOR RE-WRITE\n         SPACE 1\nDY$ILCGT TM    LCTFLAGS,LCTFPRIV        PRIV CMD?\n         BNO   *+12     >========+      NO - OK\n         TM    QXAUTH,QXAUTHX    |      PRIV USER?\n         BZ    DY$INVLI          |      NO - SAY INVALID COMMAND\n         ST    R1,LCBTPTR   <====+      SAVE IN LINE CMD BUFFER\n         OI    DY@FLAG,DY@ILNCD         indicate line command\n         TM    LCTFLAGS,LCTFDCMD        IS THIS A DEST. CMD?\n         BNO   DY$ILCL3                 NO - SKIP\n         TM    DY@FLAG,DY@DCMD          ALREADY HIT DEST. CMD?\n         BO    DY$ILCE2                 YES - CONFLICT\n         OI    DY@FLAG,DY@DCMD          REMEMBER DEST. CMD FOUND\n         DROPX R6,R1\n*---  put variables back\nDY$ILCL3 LR    R15,R4                   -> ISPLINK\n         CALL  (15),(=CL8'TBPUT',TBNAM),VL,                            $\n               MF=(E,DY@CALLP)\n         L     R14,=V(ISPFERR)\n         CH    R15,=H'20'               severe error???\n         BL    *+6                      no - skip call\n         BALR  R15,R14                  tell about it\n         CLC   DY@PCMD(4),=CL4'0001'    any left to process ?\n         BNH   DY$DSPZ2                 no - all done\n         LR    R15,R4                   -> ISPLINK\n*---  get next selected\n         CALL  (15),(=CL8'TBDISPL',TBNAM),VL,                          $\n               MF=(E,DY@CALLP)\n         L     R14,=V(ISPFERR)\n         CH    R15,=H'20'               severe error???\n         BL    *+6                      no - skip call\n         BALR  R15,R14                  tell about it\n         B     DY$DSPZ1                 go and reget\n*\nDY$DSPZ2 TM    DY@FLAG,DY@ILNCD         any line command occur?\n         BZ    ISPF1A                   no - process primary\n         SPACE 2                                              A-16JUL91\n         LR    R15,R4                                         A-16JUL91\n         MVC   DY@ISLN,=F'6'            set length            A-16JUL91\n         CALL  (15),(=CL8'VCOPY',=CL8'ZTDTOP',                A-16JUL91$\n               DY@ISLN,DY@PCMD,=CL8'MOVE'),VL,                A-16JUL91$\n               MF=(E,DY@CALLP)                                A-16JUL91\n         L     R14,=V(ISPFERR)                                A-16JUL91\n         CH    R15,=H'20'               severe error???       A-16JUL91\n         BL    *+6                      no - skip call        A-16JUL91\n         BALR  R15,R14                  tell about it         A-16JUL91\n         PACK  QNUMWORK,DY@PCMD(6)      convert to decimal    A-16JUL91\n         CVB   R15,QNUMWORK             make binary           A-16JUL91\n         ST    R15,QTBDROW              save it for TBSKIP    A-16JUL91\n         SPACE 2\n*---  RETURN TO MAINLINE TO EXECUTE LINE COMMANDS\n         QNEWCMD  LINE                  from dispaly\n         SPACE 2\n*---  PROCESS THE PRIMARY COMMAND\nISPF1A   L     R15,DY@ITDRC             get rc from orig display\n         CH    R15,=H'8'                WAS END OR RETURN CMD ENTERED?\n         BNE   ISPF2                    nope\n         CLC   DY@ZVERB,=CL8'RETURN'    is this a \"RETURN\" xit?\n         BNE   ISPF1B                   no - treat as \"END\"\n         MVC   QDREPLY(8),=CL8'RETURN'  yes - exit\n         MVC   QDRLNG,=H'6'             fake up length\n         B     ISPF2                    go and exit\n*\nISPF1B   MVC   QDREPLY,=C'END'          YES - FAKE UP END\n         MVC   QDRLNG,=H'3'             SET LENGTH\n*\nISPF2    MVC   QERRMSG,QBLANK           blank out error line\n         MVI   DY@AID,X'7D'             set to enter\n         LH    R4,QDRLNG                get length of reply\n         LTR   R4,R4                    any from user USER?\n         BNZ   DY$INTER                 yes. interrupt current wk\n         TM    DY@FLAG,DY@IMM           request for immed write?\n         BO    QSTOP                    yes - all done\n         OI    QFLAG2,Q2NEWSCR          flag as new screen\n         B     DY$INTER                 continue processing\n         SPACE 3\n***********************************************************************\n*                                                                     *\n*   ROUTINE TO HANDLE TERMINAL I/O FOR NON-VIDEO DISPLAY TERMINALS    *\n*                                                                     *\n***********************************************************************\nDY$TTY   TM    QDWCC,X'04'              ALARM?\n         BNO   DY$TTY$2                 NO - SKIP\n         LA    R1,=X'2F'                YES - GET VALUE FOR \"BELL\"\n         LA    R0,1                     LENGTH\n         ICM   R1,B'1000',=X'02'        SET \"CONTROL\"\n         TPUT  (1),(0),R                RING HIS CHIMES\n         SPACE 1\nDY$TTY$2 L     R1,QVHLINE               -> HEADER LINE\n         LH    R0,QDCOLS                LENGTH + 1\n         BCTR  R0,0                     LENGTH\n         TPUT  (1),(0),R\n         TM    QMISCFLG,QMFATTN         ATTN PRESSED?\n         BO    DYTTYTG                  YES - GO DIRECTLY TO TGET\n         L     R6,QVLINE1               -> FIRST DATA LINE\n         LH    R7,QDCOLS                LENGTH\n         LH    R3,QDROWS                NUMBER\n         LR    R5,R7                    COPY LINE LENGTH\n         BCTR  R5,0                     GET EX LENGTH\n         XC    DY@TRTAB,DY@TRTAB        INIT TRT TABLE TO ...\n         MVI   DY@TRTAB+X'1D',4         ... STOP ON \"START FIELD\"\n         MVI   DY@TRTAB+X'3C',8         ... AND \"REPEAT TO ADDR\"\n         SPACE 2\nDY$TTYLP EX    R5,DYTTYMVC              MOVE DATA TO OUR BUFFER\n         LA    R15,0(R5,R6)             -> END OF LINE\n         LR    R14,R5                   LENGTH TO TRT\n         LA    R1,DY@LINE               -> START OF LINE\n         MVI   TTY@BYTE,C' '            ASSUME WON'T FIND ANYTHING\n         SPACE 1\nDY$TRTLP EX    R14,DYTTYTRT             LOOK FOR SF OR RA\n         BZ    DY$TTYTP                 NONE FOUND - GO PUT THE LINE\n         MVC   TTY@BYTE,0(R1)           SAVE FOR END OF SCREEN TESTING\n         CLI   0(R1),X'3C'              IS THIS THE TRAILING \"RA\"?\n         BE    DY$TTYRA                 YES - SPECIAL HANDLING\n*---  REMOVE THE ATTR BYTE FROM THE LINE                           ---*\n         MVI   0(R1),C' '               KILL THE X'1D'\n         LA    R1,1(,R1)                SKIP OVER IT\n         LA    R14,DY@LINE(R5)          -> LAST CHAR OF LINE\n         SR    R14,R1                   EXECUTE LENGTH TO SHIFT OVER\n         LA    R15,1(,R15)              ADJUST END OF LINE POINTER\n         LA    R6,1(,R6)                ALSO, FIX PTR TO NEXT SCRN LINE\n         LR    R2,R15                   COMPUTE ADDRESS OF PART OF LINE\n         SR    R2,R14                   ... AFTER THE ATTR BYTE\n         EX    R14,DYTTYSHF             SHIFT REMAINDER OF LINE LEFT\n         B     DY$TRTLP                 LOOK FOR NEXT ATTR BYTE\n         SPACE 1\nDYTTYMVC MVC   DY@LINE(*-*),0(R6)       << EXECUTED >>\nDYTTYTRT TRT   0(*-*,R1),DY@TRTAB       << EXECUTED >>\nDYTTYSHF MVC   0(*-*,R1),0(R2)          << EXECUTED >>\nDYTTYCLC CLC   DY@LINE(*-*),QBLANK      << EXECUTED >>\n         SPACE 1\n*---  THE TRAILING \"RA\" SEQUENCE HAS BEEN FOUND.  REMOVE IT.       ---*\nDY$TTYRA MVC   0(132,R1),QBLANK         CLEAR REST OF PRINT LINE\n         SPACE 1\n*---  FINALLY, TPUT THE LINE IF IT'S NON-BLANK                     ---*\nDY$TTYTP EX    R5,DYTTYCLC              BLANK LINE?\n         BE    DY$TTYSK                 YES - SKIP IT\n         LA    R1,DY@LINE               -> OUTPUT LINE\n         TPUT  (1),(R7)                 PUT OUT THE LINE\nDY$TTYSK CLI   TTY@BYTE,X'3C'           END OF SCREEN? (RA)\n         BE    DYTTYTG                  YES - ALL DONE WITH SCREEN BUFF\n         TM    QMISCFLG,QMFATTN         ATTN PRESSED?\n         BO    DYTTYTG                  YES - GO DIRECTLY TO TGET\n         AR    R6,R7                    -> NEXT DATA LINE\n         BCT   R3,DY$TTYLP              DO THE WHOLE SCREEN\n         B     DYTTYTG                  AND REQUEST INPUT\n         SPACE 2\nDY$TTYPM LA    R0,QDREPLYL              GET LENGTH\n         TPUT  (1),(0),R                PUT IT OUT\n         B     DYTTYTG                  GET NEXT COMMAND\n         SPACE 2\nDYTTYTG  NI    QMISCFLG,255-QMFATTN     RESET IN CASE INTERRUPTED OUTPT\n         SPACE 1\nDYTTYTG2 LA    R1,=C'QUEUE: '\n         LA    R0,7\n         LA    R15,QDTOP-8-7            -> AREA-LINELEN FOR ' *MORE'\n         AH    R15,QDCOLS               -> AREA FOR ' *MORE*'\n         CLC   0(7,R15),=C' *MORE*'     IS THERE MORE?\n         BNE   *+12                     NO - KEEP IT\n         LA    R1,=C'*MORE* QUEUE: '\n         LA    R0,14\n         ICM   R1,B'1000',=X'01'        SET \"ASIS\"\n         TPUT  (1),(0),R\n         SPACE 1\n         LA    R1,DY@TEXT               -> INPUT LOC\n         LA    R0,QDREPLYL              MAX LENGTH\n         ICM   R1,B'1000',=X'80'        SET \"TGET\"\n         TGET  (1),(0),R\n         MVC   DY@INPUT(6),=X'7D4040114040'  FAKE OUT 3270 AID, ADDR,\n*                                            SBA, ADDR\n         LA    R4,6(,R1)                FAKE LENGTH FOR ABOVE\n         CH    R15,=H'8'                ATTN?\n         BNE   TGET$CHK                 NO - PROCESS INPUT\n         B     DYTTYTG2                 YES - READ AGAIN\n***********************************************************************\n*                                                                     *\n*   Internal suboutine to update LCB offset to ISPF variable addr     *\n*                                                                     *\n*      on input   R1  ->   line address                               *\n*                 R15 ==   offset from LCB entry                      *\n*                 R7  ->   table of variable lengths                  *\n*                 R6  ==   address of first variable                  *\n*                                                                     *\n***********************************************************************\nDY$ILADR LTR   R15,R15                  is offset zero?\n         BZR   R8                       yes - not needed\n         AR    R15,R1                   add start of line\n         SR    R14,R14                  counter\n*\nDY$IA1   CLI   0(R15),X'1D'             is this start field?\n         BNE   *+8                      no\n         LA    R14,1(,R14)              bump counter\n         BCTR  R15,0                    bump addr down\n         CR    R15,R1                   reached start?\n         BNL   DY$IA1                   loop till at start\n         SR    R15,R15                  clear reg\n         LTR   R14,R14                  any start fields found?\n         BZR   R8                       nope - skip everything\n         BCT   R14,DY$IA2               get 0 relative\n         B     DY$IA4                   if only 1 then at first\n*\nDY$IA2   SLL   R14,2                    times 4\n*\nDY$IA3   SH    R14,=H'4'                decrement offset\n         A     R15,0(R14,R7)            add in length\n         LTR   R14,R14                  any left to do?\n         BP    DY$IA3\n*\nDY$IA4   AR    R15,R6                   add in offset\n         BR    R8                       all done\n***********************************************************************\n*                                                                     *\n*   SUBROUTINE TO BUILD TOP SCREEN LINES IF NECESSARY                 *\n*                                                                     *\n***********************************************************************\nDY$SETOP TM    QTERMFLG,QTFSW2+QTFSW5   NEED TO SWITCH?\n         BZR   R8                       NO - JUST RETURN TO CALLER\n         BNO   *+8                      YES - CONTINUE\n         EX    0,*                      CAN'T USE 'LOGICERR' HERE...\n         NI    QTERMFLG,255-QTFSW2-QTFSW5  RESET REQUEST FLAGS\n         MVI   QDERASE,X'F5'            ASSUME MOD 2, SET ERASE WRITE\n         NI    QTERMFLG,255-QTFNOW5     ASSUME IN MOD 2 MODE\n         CLI   QDROWS+1,24-3            MODEL 2?\n         BE    *+12    >============+   YES - SKIP\n         MVI   QDERASE,X'7E'        |   NO - USE ERASE WRITE ALTERNATE\n         OI    QTERMFLG,QTFNOW5     |   AND REMEMBER WE ARE MOD 5 MODE\n         MVC   QD3270OP,QDERASE  <==+   FORCE ERASE WRITE ON NEXT WRITE\n         LA    R14,QDTOP+1-9            -> SECOND SCREEN LINE\n         AH    R14,QDCOLS               ...\n         MVC   0(14,R14),DY#CMD         'COMMAND ===>' & ATTR\n         LA    R14,14(,R14)             -> INPUT AREA\n         ST    R14,QVINPUT              SAVE ADDRESS\n         XC    0(QDREPLYL,R14),0(R14)   CLEAR IT\n         MVC   QDREPLYL(2,R14),=X'1DE8' ATTR - PROT BRIGHT\n         MVC   QDREPLYL+2(132-80,R14),QBLANK CLEAR THE REST J.I.C.\n         LH    R1,QDCOLS                GET SCREEN WIDTH\n         SH    R1,=H'80'                ADJUST FOR MIN WIDTH\n         LA    R14,QDREPLYL+2(R1,R14)   -> THIRD LINE (HEADER)\n         ST    R14,QVHLINE              SAVE ADDRESS\n         AH    R14,QDCOLS               -> FOURTH LINE (SORT OF)\n         BCTR  R14,0                    ADJUST FOR ATTRIBUTE BYTE\n         MVC   0(2,R14),=X'1D60'        ATTR - PROT NORM\n         LA    R14,2(,R14)              -> FIRST DATA LINE\n         ST    R14,QVLINE1              SAVE ADDRESS\n         ST    R14,QDNEXT               SET ADDRESS OF NEXT DATA LINE\n         LA    R0,QDSCREEN              -> START OF SCREEN BUFFER\n         SR    R14,R0                   COMPUTE LENGTH OF FIXED AREA\n         L     R1,=A(QDSCRLEN)          GET LENGTH OF WHOLE BUFFER\n         SR    R1,R14                   COMPUTE LENGTH REMAINING\n         ST    R1,QDCLEARL              SAVE LENGTH TO CLEAR\n         BR    R8                       RETURN TO CALLER\n***********************************************************************\n*                                                                     *\n*   MISCELLANY                                                        *\n*                                                                     *\n***********************************************************************\nDY$TXMVC MVC   0(*-*,R6),DY@PCMD        << EXECUTED >>\n         SPACE 1\nDY#CMD   DC    C'Command ===>'\n         DC    X'1DC8'                  ATTR - INPUT, BRIGHT\n         SPACE 2\n         ENTRY RC#KEYS\nRC#KEYS  DC    CL8'F',CL8'FIND'\n         DC    CL8'T',CL8'TSO'\n         DC    CL8'I',CL8'INQ',CL8'INQUIRY'\n*---  ANYTHING NOT ONE OF THE ABOVE WILL BE ASSUMED TO BE 'C'      ---*\n         DC    CL8'C',CL8'CMD'          MVS/JES2\n         DC    X'FF'                    END OF TABLE INDIC.\n         SPACE 2\nDY#SCALE DC    C'----+----1----+----2----+----3----+----4----+----5'\n         DC    C'----+----6----+----7----+----8----+----9----+---10'\n         DC    C'----+---11----+---12----+---13----+---14----+---15'\n         DC    C'----+---16----+---17----+---18----+---19----+---20'\n         DC    C'----+---21----+---22----+---23----+---24----+---25'\n         DC    C'----+---26----+---27----+---28----+---29----+---30'\n         DC    C'----+---31----+---32----+---33----+---34----+---35'\n         DC    C'----+---36----+---37----+---38----+---39----+---40'\n         SPACE 2\nDY#T3270 DC    0D'0'\n         DC    X'40C1C2C3C4C5C6C7C8C94A4B4C4D4E4F'\n         DC    X'50D1D2D3D4D5D6D7D8D95A5B5C5D5E5F'\n         DC    X'6061E2E3E4E5E6E7E8E96A6B6C6D6E6F'\n         DC    X'F0F1F2F3F4F5F6F7F8F97A7B7C7D7E7F'\n         SPACE 2\nFM#MDL   DC    F'7'                     number of fields\n         DC    F'2,18,5,3,5,32,8',F'0'\n         DC    CL30'(QF1 QF2 QF3 QF4 QF5 QF6 QF7)'\n DC C'_Z @Z                 #Z    @Z  @Z    @Z                         $\n                     _Z       '\n*     y12y123456789112345678y12345y123y12345y12345678911234567892123456\n*              789312y12345678'\n*  'y' are real attributes for:\n*          selection field (col 2)      input high\n*          qname           (col 5)      output low\n*          jobnumber       (col 23)     output high\n*          rest            (col 29)     output low\n*          device/args     (col 73)     input high\n         SPACE 2\nDD#MDL   DC    F'4'                     number of fields\n***      DC    F'2,8,5,61',4F'0'\n         DC    F'2,8,7,59',4F'0'\n         DC    CL30'(QF1 QF2 QF3 QF4)'\n*DC C'_Z @Z       #Z    @Z\n DC C'_Z @Z       #Z      @Z                                           $\n                              '\n*     y12y12345678y12345y1234567891123456789212345678931234567894123456\n*              789412345678961'\n*  'y' are real attributes for:\n*          selection field (col 2)      input high\n*          ddname          (col 5)      output low\n*          datasetid       (col 23)     output high\n*          rest            (col 29)     output low\n         SPACE 2\nDC#MDL   DC    F'6'                     number of fields\n         DC    F'4,8,8,17,6,32',F'0,0'\n         DC    CL30'(QF1 QF2 QF3 QF4 QF5 QF6)'\n DC C'@Z   #Z       @Z       @Z                #Z     @Z               $\n                             '\n*     y1234y123y12345678y12345y12345678911234567y123456y123456789112345\n*              678921234567893'\n*  'y' are real attributes for:\n*          asid            (col 5)      output low\n*          queue and type  (col 23)     output high\n*          jobnumber       (col 23)     output high\n*          jobname         (col 29)     output low\n*          step & proc     (col 29)     output low\n*          slots           (col 23)     output high\n*          usage data      (col 29)     output low\n         SPACE 2\nZZ#MDL   DC    F'1'                     number of fields\n         DC    F'79',7F'0'\n         DC    CL30'(QF1)'\n DC C'@Z                                                               $\n                              '\n*     y1234567891123456789212345678931234567894123456789512345678961234\n*              567897123456789'\n*  'y' are real attributes for:\n*          other data      (col 2)      output low\n         SPACE 2\n         LTORG\n         SPACE 3\n         DROPX R13\n         SPACE 3\n         QCOMMON\n         SPACE 2\nDY#MDL   DSECT ,                        ISPF table model lines descript\nDY#MCNT  DS    F                        number of fields\nDY#MLEN  DS    8F                       length of each field\nDY#MVAR  DS    CL30                     ZVARS string\nDY#MLN   DS    CL80                     model line value\n         SPACE 2\nWORK     DSECT\n         ORG   WORK+72\nDY@TPTR  DS    A                        LINE CMD ELEMENT PTR PARM\nDY@ITDRC DS    F                        rc from TBDISPL w/ panel\nDY@ISLN  DS    F                        length of ZTDSELS var\nDY@ZVERB DS    CL8                      ZVERB after TBDISPL w/\nDY@CURS  DS    H                        RELATIVE CURSOR POSITION\nDY@FLAG  DS    B\nDY@IMM   EQU   X'80'                    ENTRY IS FOR IMMEDIATE DISPLAY\nDY@DCMD  EQU   X'40'                    HIT DESTRUCTIVE BUFFER COMMAND\nDY@ILNCD EQU   X'20'                    line command occured\nDY@SHORT EQU   X'10'                    short write (in valid.)\nDY@WORKL EQU   *-WORK\nDY@VLEN  DS    F                        for VCOPY variable length\nDY@CALLP DS    5A                       CALL MF=L area\nTTY@BYTE DS    C\nDY@DWD   DS    0D\nDY@TRTAB DS    XL256\nDY@TEMP  DS    0CL512                   AREA FOR SHORT WRITES\nDY@LINE  DS    CL132                    OUT LINE WORK AREA FOR TTY\n         DS    CL150                    SLOP AREA (SEE DY$TTY CODE)\n         ORG   DY@TEMP+L'DY@TEMP\n         DS    0D                       ALIGN REPLY AREA\nDY@FIELD DS    CL(QDREPLYL)             WORK AREA TO EXTRACT 1 FIELD\nDY@PCMD  DS    CL(QDREPLYL)             PRIMARY LINE COMMAND\nDY@PCLEN DS    H                        ITS LENGTH\nDY@INPUT DS    0CL(3+3+QDREPLYL+(3+2+3+8)*40)\nDY@AID   DS    C\n         DS    CL2                      CURSOR ADDRESS\n         DS    C,CL2                    SBA, DATA ADDRESS\nDY@TEXT  EQU   *                        INPUT DATA\n         ORG   DY@INPUT+L'DY@INPUT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "Q#DY@LDW": {"ttr": 6154, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x14\\x00\\x00\\x00\\x82#/\\x00\\x87\\x03\\x9f!8\\x03\\x9f\\x01\\x8a\\x02\\xde\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "05.20", "flags": 0, "createdate": "1982-08-20T00:00:00", "modifydate": "1987-02-08T21:38:00", "lines": 927, "newlines": 394, "modlines": 734, "user": "LDW"}, "text": "         TITLE '--- QUEUE--DISPLAY -- 3270 DISPLAY ROUTINES ---'\n*---------------------------------------------------------------------*\n*                                                                     *\n*   DISPLAY - DISPLAY CURRENT SCREEN BUFFER                           *\n*                                                                     *\n*   Updates:                                                          *\n*      08Feb87  LDW  Support command ring for RECALL                  *\n*      17Jan87  LDW  Remove \"*\" subcommand;  misc other cleanup       *\n*                    Remove \"LC\" macro usage                          *\n*      04/23/86 LDW  FIX BUGS                                         *\n*      03/31/86 LDW  RE-DESIGN 3278-5 SUPPORT (THIRD TRY!)            *\n*                    USE NEW COMMON LOGIC ERROR ROUTINE               *\n*      09/13/84 LDW  ALLOW FOR 24 PFKEYS IF \"MODE PFK24\"              *\n*      01/19/84 LDW  ADD SUPPORT FOR 'COLS' SUBCOMMAND                *\n*                    FIX BUG IN HEADER IF 'JESNEWS'                   *\n*      01/17/84 LDW  FIX ASM ERROR CAUSED BY EXPANSION OF QDSCREEN    *\n*      04/07/83 LDW  FIX LOOP CAUSED BY LEADING BLANK IN INPUT FIELD  *\n*                    FIX GLITCH IN \"RECALL\" CAUSED BY VTAM BUG        *\n*      03/15/83 LDW  PROCESS MULTIPLE INPUT FIELDS ON SCREEN          *\n*                    CHANGE USING/DROP TO USNGX/DROPX                 *\n*                    FIX TTY MODE OUTPUT                              *\n*                    CHANGE \"*\" SUBCOMMAND TO \"RECALL\" (\"RC\")         *\n*      02/03/83 LDW  ADD \"* I\" TO REPROMPT LAST INQUIRY SUBCOMMAND    *\n*      01/19/83 LDW  ADD WORKLEN= TO QSTART TYPE=ENTRY                *\n*      01/14/83 LDW  ADD REPROMPT TSO AND MVS                         *\n*      01/12/83 LDW  MOVE STARKEYS FROM \"PARSE\"                       *\n*      01/10/83 LDW  SQUEEZE OUT ATTR BYTES IN \"DY$TTY\"               *\n*                    HANDLE TCAM10 RESHOW (PA3)                       *\n*                    REDESIGN SCREEN BUFFER LOGIC SO THAT BUFF PTR IS *\n*                       ONLY RESET WHEN FIRST LINE IS TO BE STORED IN *\n*                       BUFFER (THIS IS SO THAT A MESSAGE FROM QTILT  *\n*                       CAN BE WRITTEN LEAVING THE REST OF THE        *\n*                       INTACT)                                       *\n*                    SUPPORT Q2SHORT WHICH INDICATES THAT ONLY THE    *\n*                       TOP 3 SCREEN LINES SHOULD BE WRITTEN          *\n*      01/06/83 LDW  FIX CLEAR LOGIC                                  *\n*      01/04/83 LDW  ADD WORKLEN=                                     *\n*                    HANDLE REPOSITIONING SUBCOMMAND DIRECTLY         *\n*      12/17/82 LDW  PUT IN SUPPORT FOR IMBEDDED ATTR BYTES IN LINE   *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 3\nDISPLAY  QSTART  Q5,WORKLEN=DY@WORKL\n         USNGX WORK,R13\n         MVI   DY@FLAG,DY@IMM           SET FLAG TO \"IMMEDIATE DISPLAY\"\n         XC    DY@CURS,DY@CURS          INDICATE DEFAULT CURSOR POS\n         OI    QFLAG1,Q1PROFOK          INITIALIZATION PROFILE COMPLETE\n         BAL   R8,DY$SETOP              BUILD TOP SCREEN LINES (MAYBE)\n         BAL   R8,DY$SETTL              BUILD LINE OF DASHES\n         B     DY$WRITE                 GO WRITE SCREEN\n         SPACE 3\n*---------------------------------------------------------------------*\n*                                                                     *\n*   DISPADD - ADD A LINE TO SCREEN BUFFER, DISPLAY SCREEN IF FULL     *\n*                                                                     *\n*   ENTRY - LINE TO BE ADDED IN \"QDMSG\"                               *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 3\nDISPADD  QSTART  TYPE=ENTRY\n         XC    DY@TPTR,DY@TPTR          NO LINE CMD ELEMENT POINTER\n         B     DY$ADD00                 CONTINUE\n         SPACE 3\n*---------------------------------------------------------------------*\n*                                                                     *\n*   DISPADDX - SAME FUNCTION AS DISPADD                               *\n*                                                                     *\n*   ENTRY - LINE TO BE ADDED IN \"QDMSG\"                               *\n*         - R1 -> LINE COMMAND ELEMENT                                *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 3\nDISPADDX QSTART  TYPE=ENTRY\n         ST    R1,DY@TPTR               SAVE LINE CMD ELEMENT POINTER\n         SPACE 1\nDY$ADD00 MVI   DY@FLAG,0                SET FLAG TO \"ADD MSG\"\n         XC    DY@CURS,DY@CURS          INDICATE DEFAULT CURSOR POS\n         TM    QFLAG1,Q1IMMED           HERE ON \"IMMEDIATE\" COMMAND?\n         BNO   DY$ADD01                 NO - SKIP\n         NI    QFLAG1,255-Q1IMMED       RESET \"IMMEDIATE COMMAND\"\n         L     R0,=C'DY1 '              SET LOGIC ERROR CODE\n         L     R15,=V(LOGICERR)         -> ROUTINE\n         BALR  R14,R15                  GO TO IT (NO RETURN)\n***********************************************************************\n*                                                                     *\n*  QUICKIE DESCRIPTION OF \"DISPLAY\" LOGIC:                            *\n*    (1) IF ROOM ON SCREEN FOR MESSAGE, MOVE IT IN AND RETURN         *\n*    (2) IF NO ROOM, SHOW *MORE*, DISPLAY SCREEN, RESET POINTERS,     *\n*        GO TO (1)                                                    *\n***********************************************************************\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*   CHECK FOR ROOM ON SCREEN                                          *\n*                                                                     *\n***********************************************************************\nDY$ADD01 MVI   QDOVER,0                 RESET THE PAGE OVRFL INDICATOR\n         TM    QTERMFLG,QTFSW2+QTFSW5   NEED TO SWITCH?\n         BNZ   DY$ADD02                 YES - SKIP NEXT TEST\n         TM    QFLAG2,Q2NEWSCR          THIS OUTPUT FOR LINE 1?\n         BNO   DY$ADD03                 NO - SKIP\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*   BUILD SCREEN HEADER IF NECESSARY AFTER MOD2 <-> MOD5 SIZE SWITCH  *\n*                                                                     *\n***********************************************************************\nDY$ADD02 BAL   R8,DY$SETOP              BUILD TOP SCREEN LINES (MAYBE)\n         BAL   R8,DY$SETTL              BUILD LINE OF DASHES\n         MVC   QDNEXT,QVLINE1           SET ADDR OF FIRST OUTPUT LINE\n         XC    QDLINECT,QDLINECT        RESET LINE NUMBER\n         NI    QFLAG2,255-Q2NEWSCR      RESET FLAG\n         XC    QDENDPTR,QDENDPTR        KILL PTR TO IC AT END\n         SPACE 1\nDY$ADD03 LH    R1,QDLINECT              GET CURRENT LINE COUNT\n         LA    R1,1(,R1)                INCREMENT\n         CH    R1,QDROWS                SCREEN BUFFER FULL?\n         BH    DY$FULL                  YES - WRITE SCREEN.\n         STH   R1,QDLINECT              SAVE UPDATED LINE COUNT\n         CH    R1,=H'1'                 IS THIS DATA LINE 1?\n         BNE   DY$ADD04                 NO - SKIP\n         OI    QFLAG1,Q1MVHDR           YES - REQUEST \"MOVE HEADER\"\n         TM    QFLAG2,Q2LISTDS+Q2COLIND IN 'LISTDS' AND WANT COL IND?\n         BNO   DY$ADD04                 NO - SKIP\n         L     R4,QDNEXT                -> NEXT LINE LOC\n         LH    R5,QDCOLS                GET LINE LENGTH\n         BCTR  R5,0                     -1 FOR EX\n         LA    R15,DY#SCALE             -> MY COLUMN SCALE\n         AH    R15,QPOFFSET             ADD COL-1\n         EX    R5,DY$SCMVC              MVC 0(*-*,R4),0(R15)\n         LA    R4,1(R5,R4)              -> NEXT LINE LOC\n         ST    R4,QDNEXT                UPDATE PTR TO NEXT LINE LOC\n         MVI   QDLINECT+1,2             SET LINE COUNT\n***********************************************************************\n*                                                                     *\n*   MOVE THE MESSAGE TO THE SCREEN                                    *\n*                                                                     *\n***********************************************************************\nDY$ADD04 L     R4,QDNEXT                -> NEXT LINE LOCATION\n         LH    R5,QDCOLS                GET LINE LENGTH\n         AH    R5,QDATRNUM              ADD # OF ATTR BYTES IN LINE\n         BCTR  R5,0                     -1 FOR EX\n         EX    R5,DY$ADD                MVC 0(*-*,R4),QDMSG\n         MVC   QDMSG,QBLANK             CLEAR THE MSG WORK AREA\n         OC    QDLCTBL,QDLCTBL          ANY LINE COMMANDS TABLE?\n         BZ    DY$NAUPD                 NO - SKIP ARRAY UPDATE\n         L     R15,DY@TPTR              GET SAVED POINTER\n         LTR   R15,R15                  ANYTHING?\n         BZ    DY$NAUPD                 NO - SKIP ARRAY UPDATE\n         BCTR  R1,0                     MAKE LINE COUNT ORIGIN 0\n         MH    R1,=Y(LCBELEN)           OFFSET OF ARRAY ELEMENT\n         AL    R1,QVLCBUF               -> ARRAY ELEMENT\n         USNGX LCBUFF,R1\n         MVC   0(LCBELEN,R1),0(R15)     SAVE THE ARRAY ELEMENT\n         ICM   R0,B'1111',LCBADDR1      GET OFFSET OF FIRST INPUT FIELD\n         BZ    *+10    >======+         SKIP IF NOT SUPPLIED\n         AR    R0,R4          |         RELOCATE\n         ST    R0,LCBADDR1    V         SAVE UPDATED ADDRESS\n         ICM   R0,B'1111',LCBADDR2      GET OFFSET OF SECOND INPUT FLD\n         BZ    *+10    >======+         SKIP IF NOT SUPPLIED\n         AR    R0,R4          |         RELOCATE\n         ST    R0,LCBADDR2    V         SAVE UPDATED ADDRESS\n         DROPX R1                       LCBUFF\nDY$NAUPD LA    R4,1(R5,R4)              -> NEXT LINE LOC\n         ST    R4,QDNEXT                SAVE FOR NEXT TIME\n         SH    R5,QDATRNUM              ADJUST BACK TO LINELEN-1\n         XC    QDATRNUM,QDATRNUM        NOW NO ATTR BYTES IN LINE\n         TM    QFLAG1,Q1MVHDR           \"MOVE HEADER\" REQUESTED?\n         BNO   QSTOP                    NO - SO DON'T\n         L     R1,QVHLINE               -> WHERE IT GOES\n         BCTR  R5,0                     END OF THIS LINE HAS ATTR BYTE\n         EX    R5,DY$MVHDR              MOVE IT TO SCREEN BUFFER\n         NI    QFLAG1,255-Q1MVHDR       RESET FLAG\n         B     QSTOP                    RETURN TO CALLER\nDY$SCMVC MVC   0(*-*,R4),0(R15)         << EXECUTED >>\nDY$ADD   MVC   0(*-*,R4),QDMSG          << EXECUTED >>\nDY$MVHDR MVC   0(*-*,R1),QDHLINE        << EXECUTED >>\n***********************************************************************\n*                                                                     *\n*   WRITE A FULL SCREEN, WAIT FOR REPLY                               *\n*                                                                     *\n***********************************************************************\nDY$FULL  LA    R15,QDTOP-8-7            -> AREA-LINELEN FOR ' *MORE'\n         AH    R15,QDCOLS               -> AREA FOR ' *MORE*'\n         MVC   0(7,R15),=C' *MORE*'     INDICATE SCREEN OVERFLOW\n         SPACE 2\nDY$WRITE TM    QFLAG1,Q1MVHDR           \"MOVE HEADER\" REQUESTED?\n         BNO   DY$NMVHD                 NO - SKIP\n         L     R1,QVHLINE               -> WHERE IT GOES\n         LH    R14,QDCOLS               GET LINE LENGTH\n         BCTR  R14,0                    -1 FOR ATTR BYTE AT END OF LINE\n         BCTR  R14,0                    -1 FOR EX\n         EX    R14,DY$MVHDR             MVC 0(*-*,R1),QDHLINE\n         NI    QFLAG1,255-Q1MVHDR       RESET FLAG\n         SPACE 1\nDY$NMVHD CLI   QDHLINE,C'*'             ERROR MESSAGE?\n         BNE   DY$NALRM                 NO - SKIP\n         TM    QMODE1,QM1BEEP           WANT NOISE?\n         BNO   DY$NALRM                 NO - SKIP\n         OI    QDWCC,X'04'              YES - SET \"ALARM\"\n         SPACE 1\nDY$NALRM TM    QSCFLAG1,QSC1JOB         NEED JOBID ON TOP LINE?\n         BNO   DY$NOJOB                 NO - SKIP\n         MVI   QDTOP,C' '\n         MVC   QDTOP+1(L'QDHJOBID+1),QDHJOBID  'JOBNAMEX(JOBNNNNN) '\n         SPACE 1\nDY$NOJOB TM    QSCFLAG1,QSC1PMPT        PROMPT WITH LAST INPUT COMMAND?\n         BNO   DY$NPMPT                 NO - SKIP\n         NI    QSCFLAG1,255-QSC1PMPT    YES - RESET FLAG\n         L     R1,QVINPUT               -> INPUT AREA ON SCREEN\n         MVC   0(QDREPLYL,R1),QDPROMPT  MOVE IN LAST COMMAND\n         SPACE 1\nDY$NPMPT TM    QTERMFLG,QTFTTY          IS TERMINAL A VIDEO?\n         BO    DY$TTY                   NO - USE ALTERNATE ROUTINE\n*--- SEE IF RA OR SBA SUFFIX ALREADY EXISTS IN BUFFER              ---*\n         L     R1,QDENDPTR              -> PAST POSSIBLE IC AT END\n         LR    R0,R1                    COPY PTR\n         SH    R1,=H'4'                 BACK UP TO START OF SBA/IC SEQ\n         LTR   R0,R0                    ANY?\n         BNZ   DY$TPUT                  YES - ALL SET\n         L     R15,QDNEXT               -> NEXT OUTPUT LOC\n         CLC   QDLINECT,QDROWS          SCREEN FULL?\n         BNE   DY$BSCAN                 NO - BACKSCAN FOR BLANKS\n*--- LAST LINE OF SCREEN HAS DATA ON IT -- SEE IF ROOM FOR RA      ---*\n         LR    R1,R15                   COPY PTR PAST LAST CHAR\n         SH    R15,=H'4'                BACK UP\n         CLC   0(4,R15),QBLANK          LAST 4 CHARS BLANK?\n         BNE   DY$TPUT                  NO - LEAVE AS IS\n         SPACE 2\n*--- BACKSCAN FOR LAST NON-BLANK                                   ---*\nDY$BSCAN BCTR  R15,0                    BACK UP TO LAST CHAR USED\n         BALR  R14,0                    SET LOOP ADDR\n         CLI   0(R15),C' '  <==+        FIND NON-BLANK?\n         BNE   *+6     >=======|==+     YES - EXIT LOOP\n         BCTR  R15,R14   >=====+  V     NO - KEEP LOOKING\n         MVC   1(4,R15),=X'3C404000'    MOVE IN THE RA SEQUENCE\n         LA    R1,1+4(,R15)             SKIP OVER IT\n         SPACE 2\nDY$TPUT  BAL   R8,DY$SETCP              SET SBA/IC SEQUENCE\n         ST    R1,QDENDPTR              -> SAVE PTR PAST IC\n         SPACE 2\nRESHOW   LA    R3,QDSCREEN              LOAD ADDRESS OF SCREEN BUFFER\n         L     R2,QDENDPTR              -> LAST BYTE+1 OF STREAM\n         SR    R2,R3                    COMPUTE TPUT LENGTH\n         B     RESHOW01                 SKIP AROUND\n         SPACE 1\nRESHOW00 MVC   QD3270OP,QDERASE         SET WRITE OP TO ERASE WRITE\n         TM    QTERMFLG,QTFVTAM         BUT IS IT A VTAM TERMINAL?\n         BO    RESHOW01                 YES - ERASE WRITE IS OK\n         MVI   QD3270OP,X'F1'           NO - TCAM REQUIRES NORMAL ...\n*                                       ... WRITE TO KEEP BMD'S ...\n*                                       ... ZAPPED TCAM FROM PUKING.\n*---  IF ACF/TCAM SUPPORTS LARGER SCREEN SIZES, THE CODE ABOVE     ---*\n*---  WILL PROBABLY NEED TO BE DISABLED.  I DON'T KNOW ANYTHING    ---*\n*---  ABOUT ACF/TCAM...                                            ---*\nRESHOW01 L     R1,QVINPUT               -> FIRST CHAR (BXH STOP ADDR)\n         LA    R15,QDREPLYL-1(,R1)      -> END OF REPLY INPUT AREA\n         SR    R0,R0                    BXH ...\n         BCTR  R0,0                     ... DECREMENT\n         SPACE 1\nRESHOW02 CLI   0(R15),C' '              FIND END?\n         BNE   RESHOW03                 YES - DISPLAY THE RESULT\n         MVI   0(R15),X'00'             CHANGE TRAILING BLANK TO NULL\n         BXH   R15,R0,RESHOW02          BACKSCAN THE WHOLE THING\n         SPACE 1\nRESHOW03 TM    QFLAG2,Q2SHORT           SHORT WRITE REQUESTED?\n         BNO   TPUTFULL                 NO - GO DO FULL WRITE\n         NI    QFLAG2,255-Q2SHORT       RESET FLAG\n         MVC   DY@TEMP(256),QDSCREEN    COPY ENOUGH OF THE SCREEN...\n         MVC   DY@TEMP+256(256),QDSCREEN+256  ...TO INSURE THAT WE ...\n*                                          ... HAVE THE FIRST 3 LINES\n         L     R1,QVLINE1               -> FIRST DATA LINE IN REAL BUFF\n         SR    R1,R3                    COMPUTE OFFSET OF 1ST DATA LINE\n         LA    R0,DY@TEMP               -> TPUT BUFFER FOR SHORT WRITE\n         AR    R1,R0                    OFFSET OF 1ST DATA LINE IN ...\n*                                       ... BUFFER FOR SHORT WRITE\n         SH    R1,=H'2'                 BACK UP OVER TRAILING ATTR BYTE\n         OC    DY@CURS,DY@CURS          ANY CURSOR POSITION SPECIFIED?\n         BNZ   RESHOW04                 YES - USE IT\n         LH    R14,QDCOLNOW             NO - PUT IT ON COL 14 OF LINE 2\n         LA    R14,14-1(,R14)           ... USING LINE LENGTH OF LAST\n         STH   R14,DY@CURS              ... SCREEN WRITTEN\n         SPACE 1\nRESHOW04 BAL   R8,DY$SETCP              SET SBA/IC SEQUENCE\n         SR    R1,R0                    COMPUTE SHORT TPUT LENGTH\n         LR    R15,R1                   MOVE LENGTH TO TEMP REG\n         LR    R1,R0                    MOVE ADDR TO CORRECT REG\n         LR    R0,R15                   MOVE LENGTH TO CORRECT REG\n         B     TPUT$NOW                 GO DO IT\n         SPACE 2\nTPUTFULL LR    R1,R3                    GET THE ADDRESS\n         LR    R0,R2                    GET THE LENGTH\n         SPACE 2\nTPUT$NOW ICM   R1,B'1000',=X'03'        GET FULLSCR FLAG\n         TPUT  (1),(0),R                WRITE SCREEN\n         MVI   QD3270OP,X'F1'           SET WRITE OPCODE TO STD WRITE\n         MVC   QDCOLNOW,QDCOLS          SHOW CURRENT SCREEN LINE LENGTH\n         LA    R14,DY@INPUT             -> INPUT BUFFER\n         LA    R15,L'DY@INPUT           LENGTH\n         L     R1,=X'40000000'          GET SOURCE LENGTH, PAD CHAR\n         MVCL  R14,R0                   FILL INPUT BUFFER WITH BLANKS\n         MVC   QDREPLY,QBLANK\n         MVC   QERRMSG,QBLANK\n         LA    R1,DY@INPUT              LOAD ADDRESS OF REPLY AREA\n         LA    R0,L'DY@INPUT            LENGTH OF INPUT BUFFER\n         SPACE 1\n         TGET  (1),(0),ASIS             WAIT FOR REPLY\n         CLI   DY@AID,X'6B'             PA3? (TCAM10 RESHOW)\n         BNE   *+8                      NO - SKIP\n         MVI   DY@AID,X'6E'             YES - CHANGE TO VTAM RESHOW\n         LR    R4,R1                    SAVE THE INPUT LENGTH\n         CH    R15,=H'8'                ATTN?\n         BE    RESHOW00                 YES\n         CLI   DY@AID,X'6E'             PA2? (RESHOW)\n         BE    DY$TCLRQ                 YES - GO FLUSH REST OF INPUT\n         SPACE 1\nTGET$CHK NI    QDWCC,255-X'04'          RESET \"ALARM\"\n         CH    R15,=H'12'               INPUT LONGER THAN BUFFER?\n         BNE   DY$NOCLR                 NO. CONTINUE.\n         SPACE 1\nDY$TCLRQ TCLEARQ INPUT                  CLEAR THE QUEUE\n         SPACE 1\n         CLI   DY@AID,X'6E'             PA2? (RESHOW)\n         BE    RESHOW00                 YES - RE-DISPLAY LAST SCREEN\n         SPACE 2\nDY$NOCLR OI    QFLAG2,Q2NEWSCR          INDICATE NEXT OUTPUT LINE IS 1\n         L     R1,QVINPUT               -> INPUT AREA ON SCREEN\n         XC    0(QDREPLYL,R1),0(R1)     CLEAR IT\n         LA    R15,DY@INPUT(R4)         -> PAST LAST INPUT CHAR\n         MVI   0(R15),X'11'             PUT IN PHONY ENDING TO STOP TRT\n         CLI   DY@INPUT+3,X'11'         DOES INPUT START WITH SBA?\n         BNE   DY$ERROR                 NO - SCREEN FORMAT ERROR\n         XC    DY@TRTAB,DY@TRTAB        CLEAR TRTAB\n         MVI   DY@TRTAB+X'11',4         SET TO STOP ON SBA\n         MVC   DY@PCMD,QBLANK           NO PRIMARY COMMAND YET\n         XC    DY@PCLEN,DY@PCLEN        ...\n         LA    R3,DY@INPUT+3+1          -> FIRST TEXT CHARACTER\n         SH    R4,=H'3'                 ACCOUNT FOR AID, CURPOS\n         BNP   DY$PC$GO                 NO INPUT\n*---  FIXED LENGTH TRT IS OK BECAUSE NO INPUT FIELD IS LONGER THAN ---*\n*---  QDREPLY (66), AND WE WILL HIT THE EXTRA SBA PREVIOUSLY SET   ---*\n*---  DOWN.                                                        ---*\n         SR    R1,R1                    CLEAR FOR IC\nDY$FLOOP TRT   2(80,R3),DY@TRTAB        FIND AN SBA\n         BZ    DY$ERROR                 NONE???\n         MVC   DY@FIELD,QBLANK          CLEAR WORK FIELD\n         SR    R1,R3                    COMPUTE FIELD LENGTH\n         SH    R1,=H'3'                 -1 FOR EX, -2 FOR LOC\n         BM    *+8\n         EX    R1,DY$FMVC               MOVE TO DY@FIELD\n*---  LEFT JUSTIFY THE DATA IN DY@FIELD                            ---*\n         CLC   DY@FIELD,QBLANK          ANYTHING HERE AT ALL?\n         BE    DY$FNONE                 NO - SKIP\nDY$FLEFT CLI   DY@FIELD,C' '            LEFT JUSTIFIED?\n         BNE   DY$FNONE                 YES - CONTINUE\n         MVC   DY@FIELD(L'DY@FIELD-1),DY@FIELD+1   NO - SHIFT IT OVER\n         MVI   DY@FIELD+L'DY@FIELD-1,C' '  CLEAR THE OPENED UP HOLE\n         B     DY$FLEFT                 KEEP SHIFTING\n         SPACE 1\nDY$FNONE LA    R1,1(,R1)                GET FIELD LENGTH\n         NC    0(2,R3),=X'3F3F'         MAKE TWO 6-BIT BYTES\n         SR    R14,R14                  CLEAR FOR IC\n         IC    R14,0(,R3)               GET HIGH ORDER 6 BITS OF ADDR\n         SLL   R14,6                    ADJUST\n         SR    R15,R15                  CLEAR FOR IC\n         IC    R15,1(,R3)               GET LOW ORDER 6 BITS OF ADDR\n         OR    R15,R14                  GET FIELD LOCATION\n         SR    R14,R14                  CLEAR FOR DIVIDE\n         LH    R0,QDCOLS                GET LINE LENGTH\n         DR    R14,R0                   COMPUTE LINE NUMBER\n         CH    R15,=H'1'                SECOND SCREEN LINE?\n*%%%     BNE   DY$FSEL                  NO - MUST BE A SELECT LINE\n         BH    DY$FSEL                  NO - MUST BE A SELECT LINE\n         STH   R1,DY@PCLEN              SAVE LENGTH OF PRIMARY COMMAND\n         MVC   DY@PCMD,DY@FIELD         SAVE PRIMARY COMMAND\n         SPACE 2\nDY$FNEXT LA    R3,3(R1,R3)              -> PAST SBA OF NEXT FIELD\n         SR    R4,R1                    COMPUTE...\n         SH    R4,=H'3'                 ... REMAINING LENGTH\n         BP    DY$FLOOP                 PROCESS IT\n         SPACE 2\n*---  SEE IF ANY LINE COMMANDS PRESENT                             ---*\n         L     R2,QVLCBUF               -> LINE COMMAND BUFFER\n         LA    R0,43-3                  NUMBER OF ARRAY ELEMENTS\n         USNGX LCBUFF,R2\nDY$LC$L1 CLI   LCBFLD1,C' '             ANYTHING HERE?\n         BH    DY$LC$EX                 YES - GO CHECK IT\n         LA    R2,LCBELEN(,R2)          -> NEXT BUFFER ARRAY ELEMENT\n         BCT   R0,DY$LC$L1              KEEP LOOKING\n*---  NO LINE COMMANDS ENTERED - EXECUTE PRIMARY COMMAND, IF ANY   ---*\n         MVC   QDREPLY,DY@PCMD          NO - GET PRIMARY LINE CMD\n         MVC   QDRLNG,DY@PCLEN          ... AND ITS LENGTH\n         B     DY$PC$GO                 GO EXECUTE IT\n         SPACE 1\n         DROPX R2                       LCBUFF\n         SPACE 1\nDY$FMVC  MVC   DY@FIELD(*-*),2(R3)      << EXECUTED >>\n         SPACE 3\n*---  STORE LINE COMMANDS                                          ---*\nDY$FSEL  LR    R0,R15                   COPY LINE NUMBER\n         SH    R15,=H'3'                ADJUST - FIRST IS ON LINE 4\n*                                       (R15 WAS ORIGIN 0)\n         BM    DY$ERR2                  LOGIC ERROR\n         MH    R15,=Y(LCBELEN)          OFFSET OF LINE CMD TABLE ENTRY\n         AL    R15,QVLCBUF              -> CORRECT ARRAY ELEMENT\n         USNGX LCBUFF,R15\n         CH    R14,=H'1'                FIELD AT LEFT SIDE OF SCREEN?\n         BE    DY$FCMD                  YES - MUST BE SUBCOMMAND NAME\n         MVC   LCBFLD2,DY@FIELD         SET OPERAND IN LINE CMD TABLE\n         OC    LCBFLD2,QBLANK           MAKE IT UPPER CASE\n         ICM   R14,B'1111',LCBADDR2     GET OPERAND LOC IN SCREEN BUFF\n         BZ    DY$FNEXT                 SKIP IF NOT SUPPLIED\n         MVC   0(8,R14),DY@FIELD        OPRND TO SCREEN IN CASE RESHOW\n         B     DY$FNEXT                 PROCESS NEXT INPUT FIELD\n         SPACE 1\nDY$FCMD  XC    LCBTPTR,LCBTPTR          CLEAR CMD TABLE ENTRY POINTER\n         MVC   LCBFLD1,DY@FIELD         SET CMDNAME IN LINE CMD TABLE\n         OC    LCBFLD1,QBLANK           MAKE IT UPPER CASE\n         ICM   R14,B'1111',LCBADDR1     GET CMDNAME LOC IN SCREEN BUFF\n         BZ    DY$FNEXT                 SKIP IF NOT SUPPLIED\n         MVC   0(2,R14),DY@FIELD        CMD TO SCREEN IN CASE RESHOW\n         B     DY$FNEXT                 PROCESS NEXT FIELD\n         SPACE 1\n         DROPX R15                      LCBUFF\n         SPACE 2\nDY$ERR2  L     R0,=C'DY2 '              SET LOGIC ERROR CODE\n         L     R15,=V(LOGICERR)         -> ROUTINE\n         BALR  R14,R15                  GO TO IT (NO RETURN)\n         SPACE 2\nDY$ERR3  L     R0,=C'DY3 '              SET LOGIC ERROR CODE\n         L     R15,=V(LOGICERR)         -> ROUTINE\n         BALR  R14,R15                  GO TO IT (NO RETURN)\n         SPACE 3\n*---  CHECK FOR PROBLEMS WITH LINE COMMANDS                        ---*\n         USNGX LCBUFF,R2\nDY$LC$EX OC    DY@PCLEN,DY@PCLEN        ANY PRIMARY COMMAND ENTERED?\n         BNZ   DY$LC$E1                 YES - GENERATE ERROR MSG\n         NI    DY@FLAG,255-DY@DCMD      NO DESTRUCTIVE CMD FOUND YET\n*---  FIND THE LINE COMMAND TABLE ENTRY                            ---*\nDY$LC$CK CLI   LCBFLD1,C' '             ANYTHING HERE?\n         BNH   DY$LC$L3                 NO - SKIP THIS ENTRY\n         L     R1,QDLCTBL               -> LINE CMD TABLE\n         LTR   R1,R1                    ANY?\n         BZ    DY$ERR3                  NO - ERROR\n         SPACE 1\n         USNGX LCTABLE,R1\nDY$LC$L2 CLC   LCBFLD1,LCTCMDNM         THIS IT?\n         BE    DY$LCGOT                 YES\n         LA    R1,LCTELEN(,R1)          -> NEXT TABLE ENTRY\n         CLI   0(R1),X'FF'              END OF TABLE?\n         BNE   DY$LC$L2                 NO - KEEP LOOKING\n         SPACE 1\n*---  LINE COMMAND IS INVALID                                      ---*\nDY$INVLC MVC   QDHLINE,QBLANK           CLEAR ERROR MSG AREA\n         MVC   QDHLINE(33),=C'*** LINE COMMAND \"XX\" INVALID ***'\n         MVC   QDHLINE+18(2),LCBFLD1    FILL IN BAD COMMAND NAME\n         SPACE 1\n*---  LINE COMMAND ERROR - SET CURSOR POSITION                     ---*\nDY$LC$ER LA    R14,43                   COMPUTE LINE NUMBER ...\n         SR    R14,R0                   ... OF BAD COMMAND\n         MH    R14,QDCOLS               MAKE IT SCREEN POSITION\n         LA    R14,1(,R14)              MAKE IT COLUMN 2\n         STH   R14,DY@CURS              SAVE FOR COMPUTE\n         OI    QFLAG1,Q1MVHDR           REQUEST \"MOVE HEADER\"\n         B     DY$WRITE                 GO RE-WRITE THE SCREEN\n         SPACE 1\nDY$LCGOT TM    LCTFLAGS,LCTFPRIV        PRIV CMD?\n         BNO   *+12     >========+      NO - OK\n         TM    QXAUTH,QXAUTHX    |      PRIV USER?\n         BZ    DY$INVLC          |      NO - SAY INVALID COMMAND\n         ST    R1,LCBTPTR   <====+      SAVE IN LINE CMD BUFFER\n         TM    LCTFLAGS,LCTFDCMD        IS THIS A DESTRUCTIVE COMMAND?\n         BNO   DY$LC$L3                 NO - SKIP\n         TM    DY@FLAG,DY@DCMD          ALREADY HIT DESTRUCTIVE CMD?\n         BO    DY$LC$E2                 YES - CONFLICT\n         OI    DY@FLAG,DY@DCMD          REMEMBER DESTRUCTIVE CMD FOUND\nDY$LC$L3 LA    R2,LCBELEN(,R2)          -> NEXT BUFFER ARRAY ELEMENT\n         BCT   R0,DY$LC$CK              CHECK ALL ELEMENTS\n         SPACE 2\n*---  RETURN TO MAINLINE TO EXECUTE LINE COMMANDS                  ---*\n         L     R13,QFRSTSA              GO BACK TO MAIN MODULE\n         LM    R14,R12,12(R13)          RESTORE REGS FROM 1ST SAVEAREA\n         BR    R10                      -> INTERRUPT HANDLER IN QUEUE\n         SPACE 1\n         DROPX R2,R1                    LCBUFF, LCTABLE\n         SPACE 3\nDY$LC$E1 MVC   QDHLINE,QBLANK           CLEAR ERROR MSG AREA\n         MVC   QDHLINE(56),=C'*** PRIMARY AND LINE COMMANDS ARE MUTUALL$\n               Y EXCLUSIVE ***'\n         OI    QFLAG1,Q1MVHDR           REQUEST \"MOVE HEADER\"\n         B     DY$WRITE                 GO RE-WRITE THE SCREEN\n         SPACE 2\nDY$LC$E2 MVC   QDHLINE,QBLANK           CLEAR ERROR MSG AREA\n         MVC   QDHLINE(29),=C'*** LINE COMMAND CONFLICT ***'\n         B     DY$LC$ER                 GO SET UP FOR RE-WRITE\n         SPACE 3\n*  REGISTER USAGE:\n*    R6 -> NEXT LOC IN QDREPLY\n*    R5  - LENGTH CURRENTLY IN QDREPLY\n*    R4  - LENGTH REMAINING IN INPUT STREAM\n*    R1  - LOW NIBBLE OF AID\nDY$PC$GO LH    R4,DY@PCLEN              GET LENGTH OF PRIMARY COMMAND\n         LA    R6,QDREPLY               %%%\n         XR    R5,R5                    INITIAL \"LENGTH IN QDREPLY\"\n         LA    R15,QDREPLYL-1           GET LENGTH TO MOVE (EX LEN)\n         IC    R1,DY@AID                GET AID\n         N     R1,=X'0000000F'          EXTRACT PF-KEY NUMBER\n         CH    R1,=H'12'\n         BH    DY$ENTER                 \"ENTER\" KEY\n         TM    QMODE1,QM1PFK24          24 UNIQUE PFKEYS IN USE?\n         BNO   DY$PFK12                 NO - KEEP AS 1-12\n         TM    DY@AID,B'00110000'       1-12 OR 13-24???\n         BO    DY$PFK12                 1-12, OK AS IS\n         LA    R1,12(,R1)               ADJUST FOR 13-24\nDY$PFK12 CH    R1,=H'4'                 PF4/16 (PRINT = SPF RETURN)\n         BNE   DY$NOTK4                 NO - CONTINUE\n         CLI   DY@PCMD,C'='             DOES HE THINK HE'S IN SPF?\n         BE    DY$ENTER                 YES - DON'T COMPOUND CONFUSION\nDY$NOTK4 BCTR  R1,0                     ADJUST ORIGIN\n         SLL   R1,6                     MULTIPLY BY 64\n         A     R1,QVPFKEYS              -> THIS PFK COMMAND\n         MVC   QDREPLY(64),0(R1)        MOVE PF-KEY VALUE\n         LA    R5,64                    LENGTH NOW IN QDREPLY\n         LA    R6,QDREPLY+3             SKIP OVER PF KEY COMMAND\n         SH    R15,=H'3'                ADJUST LENGTH LEFT TO MOVE\n*Y$ENTER SH    R4,=H'3' %%%             ADJUST REMAINING INPUT LENGTH\nDY$ENTER LTR   R4,R4    %%%             ANY INPUT REMAINING?\n         NOPR  0        %%%\n         BZ    DY$NOTXT                 SKIP IF NO OPERAND TO PFKEY\n         EX    R15,DY$TXMVC             MVC 0(*-*,R6),DY@PCMD\n         OC    DY@PCMD,QBLANK           TURN ALL HEX ZEROES TO BLANKS\n         CLC   DY@PCMD,QBLANK           ANYTHING BESIDES NULLS & BLNKS?\n         BNE   DY$3TEXT                 YES - PROCESS\n         SR    R4,R4                    NOTHING CURRENTLY IN QDREPLY\n         B     DY$NOTXT                 CONTINUE\n         SPACE 2\nDY$3TEXT LA    R5,3                     LNTH IN QDREPLY BEFORE NEW TEXT\n         SPACE 1\nDY$NOTXT LA    R4,0(R5,R4)              COMPUTE LENGTH IN QDREPLY\n         STH   R4,QDRLNG                STORE LENGTH OF REPLY\n         LTR   R4,R4                    RESPONSE FROM USER?\n         BNZ   DY$INTER                 YES. INTERRUPT PROCESSING.\n         MVI   QDOVER,1                 INDICATE PAGE OVERFLOW\n         BAL   R8,DY$SETTL              CLEAR THE SCREEN BUFFER\n         TM    DY@FLAG,DY@IMM           WAS REQUEST FOR IMMED WRITE?\n         BO    QSTOP                    YES - ALL DONE\n         OI    QFLAG1,Q1MVHDR           REQUEST \"MOVE HEADER\"\n         B     DY$ADD02                 NO - MOVE SAVED LINE TO SCREEN\n         SPACE 2\nDY$ERROR LA    R1,=C'*** SCREEN FORMAT ERROR ***'\n         LA    R0,27                    MSG LENGTH\n         SPACE 1\n         TPUT  (1),(0),R\n         B     RESHOW                   WRITE WHOLE SCREEN AGAIN\n         SPACE 2\nDY$INTER L     R8,QVSAVE                -> MY SAVE AREA\n         MVC   0(QSAVE1L,R8),QSAVE1     MOVE FIRST PART\n         MVC   QSAVE1L(QSAVE2L,R8),QSAVE2    SECOND PART\n         IC    R5,DY@AID                SAVE AID\n         QCALL PARSE                    PARSE THE INPUT\n         CLM   R5,B'0001',=X'7D'        ENTER?\n         BNE   DY$NOT7D                 NO - DON'T SAVE CMD IN RING BUF\n         L     R15,QSUBCMD              GET SUBCOMMAND EPA\n         CL    R15,=A(RECALL)           \"RECALL\" REQUEST?\n         BE    DY$NOT7D                 YES - NEVER SAVE IN RING BUFFER\n         LH    R14,QCMDNUM              GET CURRENT COMMAND NUMBER\n         LA    R14,1(,R14)              INCREMENT\n         STH   R14,QCMDNUM              SAVE UPDATED NUMBER\n         STH   R14,QRETNUM              SET NUMBER OF COMMAND TO RECALL\n         N     R14,=F'15'               COMPUTE NUMBER MODULE(16)\n         MH    R14,=Y(QDREPLYL)         GET OFFSET INTO RING BUFFER\n         AL    R14,QVRING               -> CURRENT SLOT IN RING\n         MVC   0(QDREPLYL,R14),QDREPLY  SAVE CURRENT COMMAND IN RING\nDY$NOT7D TM    QFLAG1,Q1IMMED           IMMEDIATE COMMAND?\n         BO    DY$IMMED                 YES - GO EXECUTE IT\n         SPACE 2\n*---  A NEW PRIMARY COMMAND HAS BEEN ENTERED - CLEAR ALL LINE CMDS ---*\nDY$ARRGH XC    QDLCTBL,QDLCTBL          NO LINE COMMANDS VALID NOW\n         L     R15,QVLCBUF              -> LINE CMD BUFFER\n         USNGX LCBUFF,R15\n         LA    R0,43-3                  NUMBER OF ENTRIES TO CLEAR\nDY$ARG01 XC    0(LCBELEN,R15),0(R15)    CLEAR AN ENTRY\n         MVI   LCBTPTR,X'80'            INDICATE NOTHING HERE\n         LA    R15,LCBELEN(,R15)        -> NEXT ENTRY\n         BCT   R0,DY$ARG01              CLEAR ALL ENTRIES\n         DROPX R15\n         MVC   QDPROMPT,QDREPLY         SAVE REPLY IN CASE REPROMPT\n         L     R13,QFRSTSA              GO BACK TO MAIN MODULE\n         LM    R14,R12,12(R13)          RESTORE REGS FROM 1ST SAVEAREA\n         BR    R10                      -> INTERRUPT HANDLER IN QUEUE\n         SPACE 2\nDY$IMMED L     R15,QSUBCMD              GET SUBCOMMAND EPA\n         CL    R15,=A(RECALL)           \"RECALL\" REQUEST?\n         BE    RECALL                   YES - GO THERE\n         QCALL (R15)                    INVOKE IMMEDIATE SUBCOMMAND\n         TM    QFLAG1,Q1IMMED           DID SUBCMD RESET \"IMMEDIATE\"?\n         BNO   DY$ARRGH                 YES - LET MAINLINE RE-INVOKE IT\n         TM    QFLAG2,Q2REPOS           REPOSITIONING SUBCOMMAND?\n         MVC   QSAVE1(QSAVE1L),0(R8)    RESTORE FIRST PART\n         MVC   QSAVE2(QSAVE2L),QSAVE1L(R8)      SECOND PART\n         BO    DY$REPOS                 YES (REPOSITIONING SUBCOMMAND)\n         TM    QTERMFLG,QTFTTY          DISPLAY TERMINAL?\n         BNO   RESHOW                   YES - DISPLAY SCREEN AGAIN\n         B     DYTTYTG                  NO - GO BACK TO TTY INPUT\n         SPACE 2\nDY$REPOS TM    QFLAG2,Q2LISTDS          ARE WE IN LISTDS?\n         BO    DY$LSTDS                 YES - OK\n         L     R0,=C'DY4 '              SET LOGIC ERROR CODE\n         L     R15,=V(LOGICERR)         -> ROUTINE\n         BALR  R14,R15                  GO TO IT (NO RETURN)\n         SPACE 1\n*---  SIMULATE AN \"RD\" COMMAND (SORT OF)                           ---*\nDY$LSTDS MVC   QSUBCMD,=V(LISTDS)       FAKE THE SUBCOMMAND ADDRESS\n         MVI   QCODE,99                 INDICATE REPOSITIONING\n         L     R13,QFRSTSA              GO BACK TO MAIN MODULE\n         LM    R14,R12,12(R13)          RESTORE REGS FROM 1ST SAVEAREA\n         BR    R10                      -> INTERRUPT HANDLER IN QUEUE\n         SPACE 2\n         ENTRY RECALL\n*ECALL   LA    R1,QDPROMPT              ASSUME REGULAR RECALL REQUEST\nRECALL   CLI   QKEYWORD,C' '            RECALL LAST?\n         BE    RECALL$1                 RIGHT - OK\n         CLI   QKEYWORD+16,C' '         A SECOND KEYWORD?\n         BNE   RECALLNO                 YES - NO GOOD\n         LA    R1,QFINDCMD              ASSUME RECALL LAST FIND CMD\n         CLI   QKEYWORD,C'F'            RECALL LAST FIND COMMAND?\n         BE    RECALLGO                 YES\n         LA    R1,QTSOCMD               ASSUME RECALL LAST TSO CMD\n         CLI   QKEYWORD,C'T'            RECALL LAST TSO COMMAND?\n         BE    RECALLGO                 YES\n         LA    R1,QINQCMD               ASSUME RECALL LAST INQUIRY\n         CLI   QKEYWORD,C'I'            RECALL LAST INQUIRY COMMAND?\n         BE    RECALLGO                 YES\n         LA    R1,QMVSCMD               ANYTHING ELSE MUST BE MVS\n         B     RECALLGO                 CONTINUE\n         SPACE 1\nRECALL$1 LH    R1,QRETNUM               GET COMMAND NUMBER TO RECALL\n         LR    R0,R1                    COPY FOR ADJUSTMENT\n         SH    R0,=H'1'                 BACK UP FOR NEXT RECALL\n         BNM   *+8                      SKIP IF NOT BACK TO START\n         LH    R0,QCMDNUM               ELSE RESET BACK TO TOP\n         STH   R0,QRETNUM               SAVE NBR OF NEXT CMD TO RECALL\n         N     R1,=F'15'                COMPUTE NUMBER MODULE(16)\n         MH    R1,=Y(QDREPLYL)          GET OFFSET INTO RING\n         AL    R1,QVRING                -> COMMAND TO RECALL\n         SPACE 1\nRECALLGO MVC   QSAVE1(QSAVE1L),0(R8)    RESTORE FIRST PART\n         MVC   QSAVE2(QSAVE2L),QSAVE1L(R8)      SECOND PART\n         OI    QFLAG2,Q2SHORT           INDICATE SHORT WRITE\n         TM    QTERMFLG,QTFTTY          DISPLAY TERMINAL?\n         BO    DY$TTYPM                 NO - ALTERNATE ROUTINE\n         L     R14,QVINPUT              -> INPUT AREA ON SCREEN\n         MVC   0(QDREPLYL,R14),0(R1)    COPY LAST COMMAND\n         B     RESHOW                   RE-DISPLAY SCREEN\n         SPACE 1\nRECALLNO MVC   QDHLINE,QBLANK           CLEAR ERROR MSG AREA\n         MVC   QDHLINE(27),=C'*** CONFLICTING OPTIONS ***'\n         SPACE 1\nDY$TILT  L     R1,QVINPUT               -> INPUT AREA ON SCREEN\n         MVC   0(QDREPLYL,R1),QDREPLY   MOVE IN LAST COMMAND\n         OI    QFLAG1,Q1MVHDR           REQUEST \"MOVE HEADER\"\n         B     DY$WRITE                 FAKE QTILT\n         SPACE 3\n*---  SUBROUTINE TO REBUILD TOP SCREEN LINE                        ---*\nDY$SETTL LH    R15,QDCOLS               GET SCREEN WIDTH\n         SH    R15,=H'9'                ADJUST FOR ' QUEUE -' & EXECUTE\n         EX    R15,DY$MVTOP             RESET TOP LINE TO DASHES\n         BR    R8                       RETURN TO CALLER\nDY$MVTOP MVC   QDTOP(*-*),QDTOP-1       << EXECUTED >>\n         SPACE 3\n*---  SUBROUTINE TO GENERATE 3270 CURSOR POSITION SEQUENCE         ---*\nDY$SETCP MVC   0(4,R1),=X'11000013'     PUT IN SBA/IC SEQUENCE\n         LH    R14,DY@CURS              GET CURSOR POSITION\n         XC    DY@CURS,DY@CURS          SET TO DEFAULT NEXT TIME\n         LTR   R14,R14                  ANY?\n         BNZ   *+12     >=======+       YES - OK\n         LA    R14,14-1         |       NO - USE COL 14 ...\n         AH    R14,QDCOLS       |       ... ON LINE 2\n         SRDL  R14,6     <======+       GET LOW ORDER SIX BITS IN R15\n         SRL   R15,32-6                 SHIFT TO LOW END OF REGISTER\n         STC   R14,1(,R1)               SET DOWN HI ORDER 6 BITS\n         STC   R15,2(,R1)               SET DOWN LO ORDER 6 BITS\n         TR    1(2,R1),DY#T3270         TRANSLATE TO VALID 3270 CHARS\n         LA    R1,4(,R1)                BUMP OUTPUT POINTER\n         BR    R8                       RETURN TO CALLER\n         SPACE 3\n***********************************************************************\n*                                                                     *\n*   ROUTINE TO HANDLE TERMINAL I/O FOR NON-VIDEO DISPLAY TERMINALS    *\n*                                                                     *\n***********************************************************************\nDY$TTY   TM    QDWCC,X'04'              ALARM?\n         BNO   DY$TTY$2                 NO - SKIP\n         LA    R1,=X'2F'                YES - GET VALUE FOR \"BELL\"\n         LA    R0,1                     LENGTH\n         ICM   R1,B'1000',=X'02'        SET \"CONTROL\"\n         TPUT  (1),(0),R                RING HIS CHIMES\n         SPACE 1\nDY$TTY$2 L     R1,QVHLINE               -> HEADER LINE\n         LH    R0,QDCOLS                LENGTH + 1\n         BCTR  R0,0                     LENGTH\n         TPUT  (1),(0),R\n         TM    QMISCFLG,QMFATTN         ATTN PRESSED?\n         BO    DYTTYTG                  YES - GO DIRECTLY TO TGET\n         L     R6,QVLINE1               -> FIRST DATA LINE\n         LH    R7,QDCOLS                LENGTH\n         LH    R3,QDROWS                NUMBER\n         LR    R5,R7                    COPY LINE LENGTH\n         BCTR  R5,0                     GET EX LENGTH\n         XC    DY@TRTAB,DY@TRTAB        INIT TRT TABLE TO ...\n         MVI   DY@TRTAB+X'1D',4         ... STOP ON \"START FIELD\"\n         MVI   DY@TRTAB+X'3C',8         ... AND \"REPEAT TO ADDR\"\n         SPACE 2\nDY$TTYLP EX    R5,DYTTYMVC              MOVE DATA TO OUR BUFFER\n         LA    R15,0(R5,R6)             -> END OF LINE\n         LR    R14,R5                   LENGTH TO TRT\n         LA    R1,DY@LINE               -> START OF LINE\n         MVI   TTY@BYTE,C' '            ASSUME WON'T FIND ANYTHING\n         SPACE 1\nDY$TRTLP EX    R14,DYTTYTRT             LOOK FOR SF OR RA\n         BZ    DY$TTYTP                 NONE FOUND - GO PUT THE LINE\n         MVC   TTY@BYTE,0(R1)           SAVE FOR END OF SCREEN TESTING\n         CLI   0(R1),X'3C'              IS THIS THE TRAILING \"RA\"?\n         BE    DY$TTYRA                 YES - SPECIAL HANDLING\n*---  REMOVE THE ATTR BYTE FROM THE LINE                           ---*\n         MVI   0(R1),C' '               KILL THE X'1D'\n         LA    R1,1(,R1)                SKIP OVER IT\n         LA    R14,DY@LINE(R5)          -> LAST CHAR OF LINE\n         SR    R14,R1                   EXECUTE LENGTH TO SHIFT OVER\n         LA    R15,1(,R15)              ADJUST END OF LINE POINTER\n         LA    R6,1(,R6)                ALSO, FIX PTR TO NEXT SCRN LINE\n         LR    R2,R15                   COMPUTE ADDRESS OF PART OF LINE\n         SR    R2,R14                   ... AFTER THE ATTR BYTE\n         EX    R14,DYTTYSHF             SHIFT REMAINDER OF LINE LEFT\n         B     DY$TRTLP                 LOOK FOR NEXT ATTR BYTE\n         SPACE 1\nDYTTYMVC MVC   DY@LINE(*-*),0(R6)       << EXECUTED >>\nDYTTYTRT TRT   0(*-*,R1),DY@TRTAB       << EXECUTED >>\nDYTTYSHF MVC   0(*-*,R1),0(R2)          << EXECUTED >>\nDYTTYCLC CLC   DY@LINE(*-*),QBLANK      << EXECUTED >>\n         SPACE 1\n*---  THE TRAILING \"RA\" SEQUENCE HAS BEEN FOUND.  REMOVE IT.       ---*\nDY$TTYRA MVC   0(132,R1),QBLANK         CLEAR REST OF PRINT LINE\n         SPACE 1\n*---  FINALLY, TPUT THE LINE IF IT'S NON-BLANK                     ---*\nDY$TTYTP EX    R5,DYTTYCLC              BLANK LINE?\n         BE    DY$TTYSK                 YES - SKIP IT\n         LA    R1,DY@LINE               -> OUTPUT LINE\n         TPUT  (1),(R7)                 PUT OUT THE LINE\nDY$TTYSK CLI   TTY@BYTE,X'3C'           END OF SCREEN? (RA)\n         BE    DYTTYTG                  YES - ALL DONE WITH SCREEN BUFF\n         TM    QMISCFLG,QMFATTN         ATTN PRESSED?\n         BO    DYTTYTG                  YES - GO DIRECTLY TO TGET\n         AR    R6,R7                    -> NEXT DATA LINE\n         BCT   R3,DY$TTYLP              DO THE WHOLE SCREEN\n         B     DYTTYTG                  AND REQUEST INPUT\n         SPACE 2\nDY$TTYPM LA    R0,QDREPLYL              GET LENGTH\n         TPUT  (1),(0),R                PUT IT OUT\n         B     DYTTYTG                  GET NEXT COMMAND\n         SPACE 2\nDYTTYTG  NI    QMISCFLG,255-QMFATTN     RESET IN CASE INTERRUPTED OUTPT\n         SPACE 1\nDYTTYTG2 LA    R1,=C'QUEUE: '\n         LA    R0,7\n         LA    R15,QDTOP-8-7            -> AREA-LINELEN FOR ' *MORE'\n         AH    R15,QDCOLS               -> AREA FOR ' *MORE*'\n         CLC   0(7,R15),=C' *MORE*'     IS THERE MORE?\n         BNE   *+12                     NO - KEEP IT\n         LA    R1,=C'*MORE* QUEUE: '\n         LA    R0,14\n         ICM   R1,B'1000',=X'01'        SET \"ASIS\"\n         TPUT  (1),(0),R\n         SPACE 1\n         LA    R1,DY@TEXT               -> INPUT LOC\n         LA    R0,QDREPLYL              MAX LENGTH\n         ICM   R1,B'1000',=X'80'        SET \"TGET\"\n         TGET  (1),(0),R\n         MVC   DY@INPUT(6),=X'7D4040114040'  FAKE OUT 3270 AID, ADDR,\n*                                            SBA, ADDR\n         LA    R4,6(,R1)                FAKE LENGTH FOR ABOVE\n         CH    R15,=H'8'                ATTN?\n         BNE   TGET$CHK                 NO - PROCESS INPUT\n         B     DYTTYTG2                 YES - READ AGAIN\n***********************************************************************\n*                                                                     *\n*   SUBROUTINE TO BUILD TOP SCREEN LINES IF NECESSARY                 *\n*                                                                     *\n***********************************************************************\nDY$SETOP TM    QTERMFLG,QTFSW2+QTFSW5   NEED TO SWITCH?\n         BZR   R8                       NO - JUST RETURN TO CALLER\n         BNO   *+8                      YES - CONTINUE\n         EX    0,*                      CAN'T USE 'LOGICERR' HERE...\n         NI    QTERMFLG,255-QTFSW2-QTFSW5  RESET REQUEST FLAGS\n         MVI   QDERASE,X'F5'            ASSUME MOD 2, SET ERASE WRITE\n         NI    QTERMFLG,255-QTFNOW5     ASSUME IN MOD 2 MODE\n         CLI   QDROWS+1,24-3            MODEL 2?\n         BE    *+12    >============+   YES - SKIP\n         MVI   QDERASE,X'7E'        |   NO - USE ERASE WRITE ALTERNATE\n         OI    QTERMFLG,QTFNOW5     |   AND REMEMBER WE ARE MOD 5 MODE\n         MVC   QD3270OP,QDERASE  <==+   FORCE ERASE WRITE ON NEXT WRITE\n         LA    R14,QDTOP+1-9            -> SECOND SCREEN LINE\n         AH    R14,QDCOLS               ...\n         MVC   0(14,R14),DY#CMD         'COMMAND ===>' & ATTR\n         LA    R14,14(,R14)             -> INPUT AREA\n         ST    R14,QVINPUT              SAVE ADDRESS\n         XC    0(QDREPLYL,R14),0(R14)   CLEAR IT\n         MVC   QDREPLYL(2,R14),=X'1DE8' ATTR - PROT BRIGHT\n         MVC   QDREPLYL+2(132-80,R14),QBLANK CLEAR THE REST J.I.C.\n         LH    R1,QDCOLS                GET SCREEN WIDTH\n         SH    R1,=H'80'                ADJUST FOR MIN WIDTH\n         LA    R14,QDREPLYL+2(R1,R14)   -> THIRD LINE (HEADER)\n         ST    R14,QVHLINE              SAVE ADDRESS\n         AH    R14,QDCOLS               -> FOURTH LINE (SORT OF)\n         BCTR  R14,0                    ADJUST FOR ATTRIBUTE BYTE\n         MVC   0(2,R14),=X'1D60'        ATTR - PROT NORM\n         LA    R14,2(,R14)              -> FIRST DATA LINE\n         ST    R14,QVLINE1              SAVE ADDRESS\n         ST    R14,QDNEXT               SET ADDRESS OF NEXT DATA LINE\n         LA    R0,QDSCREEN              -> START OF SCREEN BUFFER\n         SR    R14,R0                   COMPUTE LENGTH OF FIXED AREA\n         L     R1,=A(QDSCRLEN)          GET LENGTH OF WHOLE BUFFER\n         SR    R1,R14                   COMPUTE LENGTH REMAINING\n         ST    R1,QDCLEARL              SAVE LENGTH TO CLEAR\n         BR    R8                       RETURN TO CALLER\n***********************************************************************\n*                                                                     *\n*   SUBROUTINE TO SWITCH TO MOD 2 SCREEN SIZE                         *\n*                                                                     *\n***********************************************************************\nDISP80   QSTART  TYPE=ENTRY\n         CLI   QDCOLS+1,80              ALREADY CORRECT?\n         BE    QSTOP                    YES - SKIP\n         MVC   QD3270OP,QDERASE         INSURE ERASE WRITE NEXT\n         MVI   QDCOLS+1,80              SET SCREEN WIDTH\n         MVI   QDROWS+1,24-3            SET SCREEN LENGTH (USABLE)\n         ZAP   QTPAGE,=P'21'            NUMBER OF USABLE ROWS\n         ZAP   QTHALF,=P'10'            SAME FOR HALF A SCREEN\n         ZAP   QTPAGEX,=P'20'           SAME AS ABOVE IF COLUMN ...\n         ZAP   QTHALFX,=P'10'           ... INDICATOR BEING DISPLAYED\n         OI    QTERMFLG,QTFSW2          TELL DISPLAY TO REBUILD HEADER\n         NI    QTERMFLG,255-QTFSW5      RESET OTHER FLAG\n         B     QSTOP                    RETURN TO CALLER\n***********************************************************************\n*                                                                     *\n*   SUBROUTINE TO SWITCH TO MOD 5 SCREEN SIZE                         *\n*                                                                     *\n***********************************************************************\nDISP132  QSTART  TYPE=ENTRY\n         TM    QTERMFLG,QTFMOD5         MODEL 5?\n         BZ    QSTOP                    NO - DON'T DO ANYTHING\n         CLI   QDCOLS+1,132             ALREADY CORRECT?\n         BE    QSTOP                    YES - SKIP\n         MVC   QD3270OP,QDERASE         INSURE ERASE WRITE NEXT\n         MVI   QDCOLS+1,132             SET SCREEN WIDTH\n         MVI   QDROWS+1,27-3            SET SCREEN LENGTH (USABLE)\n         ZAP   QTPAGE,=P'24'            NUMBER OF USABLE ROWS\n         ZAP   QTHALF,=P'12'            SAME FOR HALF A SCREEN\n         ZAP   QTPAGEX,=P'23'           SAME AS ABOVE IF COLUMN...\n         ZAP   QTHALFX,=P'11'           ... INDICATOR IS DISPLAYED\n         OI    QTERMFLG,QTFSW5          TELL DISPLAY TO REBUILD HEADER\n         NI    QTERMFLG,255-QTFSW2      RESET OTHER FLAG\n         B     QSTOP                    RETURN TO CALLER\n***********************************************************************\n*                                                                     *\n*   MISCELLANY                                                        *\n*                                                                     *\n***********************************************************************\nDY$TXMVC MVC   0(*-*,R6),DY@PCMD        << EXECUTED >>\n         SPACE 1\nDY#CMD   DC    C'Command ===>'\n         DC    X'1DC8'                  ATTR - INPUT, BRIGHT\n         SPACE 2\n         ENTRY RC#KEYS\nRC#KEYS  DC    CL8'F',CL8'FIND'\n         DC    CL8'T',CL8'TSO'\n         DC    CL8'I',CL8'INQ',CL8'INQUIRY'\n*---  ANYTHING NOT ONE OF THE ABOVE WILL BE ASSUMED TO BE 'C'      ---*\n         DC    CL8'C',CL8'CMD'          MVS/JES2\n         DC    X'FF'                    END OF TABLE INDIC.\n         SPACE 2\nDY#SCALE DC    C'----+----1----+----2----+----3----+----4----+----5'\n         DC    C'----+----6----+----7----+----8----+----9----+---10'\n         DC    C'----+---11----+---12----+---13----+---14----+---15'\n         DC    C'----+---16----+---17----+---18----+---19----+---20'\n         DC    C'----+---21----+---22----+---23----+---24----+---25'\n         DC    C'----+---26----+---27----+---28----+---29----+---30'\n         DC    C'----+---31----+---32----+---33----+---34----+---35'\n         DC    C'----+---36----+---37----+---38----+---39----+---40'\n         SPACE 2\nDY#T3270 DC    0D'0'\n         DC    X'40C1C2C3C4C5C6C7C8C94A4B4C4D4E4F'\n         DC    X'50D1D2D3D4D5D6D7D8D95A5B5C5D5E5F'\n         DC    X'6061E2E3E4E5E6E7E8E96A6B6C6D6E6F'\n         DC    X'F0F1F2F3F4F5F6F7F8F97A7B7C7D7E7F'\n         SPACE 2\n         LTORG\n         SPACE 3\n         DROPX R13\n         SPACE 3\n         QCOMMON\n         SPACE 2\nWORK     DSECT\n         ORG   WORK+72\nDY@TPTR  DS    A                        LINE CMD ELEMENT PTR PARM\nDY@CURS  DS    H                        RELATIVE CURSOR POSITION\nDY@FLAG  DS    B\nDY@IMM   EQU   X'80'                    ENTRY IS FOR IMMEDIATE DISPLAY\nDY@DCMD  EQU   X'40'                    HIT DESTRUCTIVE BUFFER COMMAND\nDY@WORKL EQU   *-WORK\nTTY@BYTE DS    C\nDY@DWD   DS    0D\nDY@TRTAB DS    XL256\nDY@TEMP  DS    0CL512                   AREA FOR SHORT WRITES\nDY@LINE  DS    CL132                    OUT LINE WORK AREA FOR TTY\n         DS    CL150                    SLOP AREA (SEE DY$TTY CODE)\n         ORG   DY@TEMP+L'DY@TEMP\n         DS    0D                       ALIGN REPLY AREA\nDY@FIELD DS    CL(QDREPLYL)             WORK AREA TO EXTRACT 1 FIELD\nDY@PCMD  DS    CL(QDREPLYL)             PRIMARY LINE COMMAND\nDY@PCLEN DS    H                        ITS LENGTH\nDY@INPUT DS    0CL(3+3+QDREPLYL+(3+2+3+8)*40)\nDY@AID   DS    C\n         DS    CL2                      CURSOR ADDRESS\n         DS    C,CL2                    SBA, DATA ADDRESS\nDY@TEXT  EQU   *                        INPUT DATA\n         ORG   DY@INPUT+L'DY@INPUT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "Q#FJ": {"ttr": 6662, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05 \\x00\\x00\\x00\\x82#/\\x00\\x915O 9\\x01\\xab\\x01\\x0e\\x01\\x1e\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "05.32", "flags": 0, "createdate": "1982-08-20T00:00:00", "modifydate": "1991-12-20T20:39:00", "lines": 427, "newlines": 270, "modlines": 286, "user": "LDW"}, "text": "         TITLE '--- QUEUE--FINDJOB -- LOC. JQE, JCT, IOT BY JOBNM ---'\n*---------------------------------------------------------------------*\n*                                                                     *\n*   FINDJOB - Locate JQE, validity check access to job, read JCT and  *\n*             first IOT                                               *\n*                                                                     *\n*   Entry - Jobname or jobid in \"QPARM1\"                              *\n*                                                                     *\n*   Exit - JQE address in \"QCJQEA\"                                    *\n*          Internal job number in \"QINTJBID\"                          *\n*          Jobname or number (as given) in \"QJOBID\"                   *\n*          Jobname in \"QJOBNAME\"                                      *\n*          Job id \"QEXTJBID\" (with blanks changed to zeroes)          *\n*          JCT in area pointed to by \"QCJCTA\"                         *\n*          JCTKBKEY in \"QPJOBID\"                                      *\n*                                                                     *\n*   Updates:                                                          *\n*      20Dec91  LDW  Integrate GLA update below:                      *\n*     (23Sep91) GLA  Support DSAUTH by delaying QTILT until in DSAUTH *\n*      08Jun91  EMS  For SP420:  support JCT NJE section in separate  *\n*                       haspace block(s)                              *\n*      25Dec89  LDW  QACxxx -> QZACxxx:  CVT, DSV, JCB, NJBLK, VALD   *\n*      23Nov89  LDW  Remove conditional assembly around Qxxx macros   *\n*      20Feb88  LDW  Reset Q3SYSLOG                                   *\n*      20May87  EMS  Fix for first call to avoid avoiding ckpt read   *\n*                    Update for lines/page data                       *\n*      25Jan87  LDW  Pass READSPC the JQE addr in case of CB ID error *\n*      22JUN86  LDW  USE &@@ACF2 INSTEAD OF &QACF2                    *\n*               LDW  UPDATE FOR ACF2 RELEASE 4.1                      *\n*      05/08/85 LDW  FIX BUG IN ACF2 CHECKING OF ACCESS TO STC'S      *\n*      03/25/85 LDW  FIX BUG IN ACF2 CALL                             *\n*      07/05/84 LDW  WHEN JOB IS FOUND, PUT ITS JOBID IN QPARM1,      *\n*                       AND SET Q1JOBID (THIS IS NOW SAFE, SINCE      *\n*                       WE NOW CHECK FOR DUPLICATE JOBNAME)           *\n*      05/31/84 LDW  SKIP CHECK FOR NOTIFY AND PASSWORD IF &QACF2=1   *\n*      04/11/84 LDW  JCTDSECT -> JCTSTART                             *\n*      03/27/84 LDW  CHANGE ACF2 SUPPORT OF JES2 SP13 TO ACF2 R314    *\n*                    SUPPORT &QJQEOWN                                 *\n*                    SIMPLIFY ACF2 CODE                               *\n*      01/19/84 LDW  CHECK FOR UNIQUE JOBID                           *\n*      12/06/83 LDW  CHANGE VOL IN ACF2 CHK FROM '*SPOOL' TO 'SPOOL?' *\n*                    FIX FOR ACF2 & SP                                *\n*      03/17/83 LDW  BYPASS CKPT READ IF THIS IS A LINE SUBCOMMAND    *\n*      03/02/83 LDW  CHANGE 'QTILT *' TO USE QERRMSG                  *\n*      01/25/83 LDW  CORRECT JOB NUMBER HANDLING FOR SP               *\n*      01/24/83 LDW  ACF2/SP SUPPORT                                  *\n*                    ADD ACVSLID CHECK TO ALSO ALLOW ACCESS           *\n*      01/19/83 LDW  USE QVSYSID TO POINT TO SYSTEM ID TABLE          *\n*      01/05/83 LDW  SUPPORT M.A.S. SYSLOG                            *\n*                    ADD SP SUPPORT                                   *\n*                    ADJUST FOR ALTERED $JQT MACRO                    *\n*                    SET FLAG FOR JOB OWNERSHIP (THIS REQUIRED A      *\n*                       MAJOR OVERHAUL OF THE JOB ACCESS CHECKING)    *\n*      12/20/82 LDW  CHANGE QTILT REPRMPT=YES TO OPTIONS=REPROMPT     *\n*      10/28/82 LDW  FIND CORRECT ACTIVE SYSLOG IN M.A.S. COMPLEXES   *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 3\nFINDJOB  QSTART  Q6\n         USNGX WORK,R13\n         NI    QFLAG3,255-Q3SYSLOG      assume not SYSLOG command\n         MVI   FJ@FLAGS,0               INITIALIZE LOCAL FLAGS\n         C     R1,=C'NTLT'              \"no tilt\" flag set?\n         BNE   *+8                      no - skip\n         OI    FJ@FLAGS,FJ@NTILT        yes - remember\n         L     R9,QCJCTA                ADDR OF IOAREA FOR JCT\n         TM    QSCFLAG2,QSC2CKPT        FORCE CKPT READ?\n         BO    FJ$CKPT                  YES - DO IT\n         TM    QSCFLAG2,QSC2LINE        HERE VIA LINE SUBCOMMAND?\n         BO    FJ$STAR                  YES - BYPASS CHECKPOINT READ\n         CLI   QLNG1+1,0                LENGTH OF FIRST OPERAND = 0?\n         BE    FJ$TILT1                 YES - HE HASN'T GIVEN JOBID YET\n         LA    R1,QDREPLY               -> REPLY AREA\n         LH    R0,QOFF1                 GET OFFSET OF FIRST OPERAND\n         LTR   R0,R0                    ANY?\n         BNP   FJ$STAR                  NO - SAME JOB\n         AR    R1,R0                    -> FIRST OPERAND\n         CLC   =C'* ',0(R1)             SAME JOB AS PREVIOUS?\n         BE    FJ$STAR                  YES - SKIP CHECKPOINT READ\n         CLI   0(R1),C' '               SAME JOB AS PREVIOUS?\n         BNH   FJ$STAR                  YES - SKIP CHECKPOINT READ\n         SPACE 1\nFJ$CKPT  QCALL CKPT                     READ CHECKPOINT DATA\n         B     FJ$CONT                  SKIP AROUND\n         SPACE 2\nFJ$STAR  CLC   QC##CKPT,=F'0'           any reads yet?\n         BE    FJ$CKPT                  no, do first one now\n         L     R15,QC#CKPT#             GET COUNT OF CKPT READS AVOIDED\n         LA    R15,1(,R15)              INCR\n         ST    R15,QC#CKPT#             STORE UPDATED COUNT\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*   DETERMINE WHETHER SEARCH IS BY JOBNUMBER OR BY JOBNAME            *\n*                                                                     *\n***********************************************************************\nFJ$CONT  NI    QFLAG1,255-Q1JOBID       ASSUME JOBNAME, NOT JOBID\n         LH    R1,QLNG1                 LENGTH OF PARAMETER FIELD\n         SH    R1,=H'1'                 IS THE LENGTH ZERO?\n         BM    FJ$TILT1                 YES. TILT.\n         LA    R15,QPARM1               POINT TO NUMBER TO CONVERT\n          AIF   (&QLEVEL GE 4).FJ01\n         SR    R5,R5                    GET JOB NUMBER BASE\n.FJ01     ANOP\n         CLI   QPARM1,C'0'              IS THE FIRST CHARACTER NUMERIC?\n         BNL   FJ$NUM                   YES - CONVERT NUMBER\n*---  SEE IF OPERAND IS JNNN/SNNN/TNNN.\n*---  IF SO, CONVERT TO JES2 INTERNAL NUMBER.\n         CLI   QPARM1,C'J'              JNNN?\n         BE    FJ$JST                   MAYBE\n          AIF   (&QLEVEL GE 4).FJ02\n         LH    R5,=H'10000'             GET STC NUMBER BASE\n.FJ02     ANOP\n         CLI   QPARM1,C'S'              SNNN?\n         BE    FJ$JST                   MAYBE\n          AIF   (&QLEVEL GE 4).FJ03\n         AR    R5,R5                    GET TSU NUMBER BASE (20000)\n.FJ03     ANOP\n         CLI   QPARM1,C'T'              TNNN?\n         BNE   FJ$JOBNM                 NOPE - TRY IT BY JOBNAME\nFJ$JST   LA    R15,QPARM1+1             POINT TO NUMBER TO CONVERT\n         SH    R1,=H'1'                 ADJUST PARM LENGTH FOR 1ST CHAR\n         BM    FJ$JOBNM                 TRY BY JOBNAME IF NOTHING LEFT\nFJ$NUM   BAL   R14,QNUMCONV             CONVERT NUMBER\n         BNE   FJ$JOBNM                 TRY BY JOBNAME IF NOT NUMERIC\n          AIF   (&QLEVEL GE 4).FJ04\n         AR    R5,R15                   GET INTERNAL JOB NUMBER\n          AGO   .FJ05\n.FJ04     ANOP\n         LR    R5,R15                   SAVE JES2 JOB NUMBER\n.FJ05     ANOP\n         OI    QFLAG1,Q1JOBID           REMEMBER JOBID WAS SUPPLIED\n***********************************************************************\n*                                                                     *\n*   LOCATE JQE                                                        *\n*                                                                     *\n***********************************************************************\nFJ$JOBNM L     R2,QCJQHEAD              LOAD ADDR OF JQT\n         LA    R0,$JQTYPES              MAXIMUM NUMBER OF QUEUES\n         TM    QSCFLAG2,QSC2SLOG        LOOKING FOR SYSLOG BY NAME?\n         BNO   FJ$JQT1                  NO - CONTINUE\n         LA    R2,JQTSTC-JQTDSECT(,R2)  YES - START AT EXEC STC QUEUE\n         LA    R0,1                     AND ONLY SEARCH THIS QUEUE\nFJ$JQT1  QNEXT R3,0(,R2),NONE=FJ$NXJQT  OFFSET TO FIRST JQE IN QUEUE\nFJ$NXJQE A     R3,QCJQTA                ADD BASE TO OFFSET\n         USNGX JQEDSECT,R3              BASE REG FOR JQE\n         TM    QFLAG1,Q1JOBID           IS SEARCH BY JOBNUMBER?\n         BNO   FJ$CLCNM                 NO. SEARCH BY JOBNAME.\n         CH    R5,JQEJOBNO              IS THIS THE RIGHT JOBNUMBER?\n         BNE   FJ$NEXTQ                 NO. TRY NEXT JQE.\n         B     FJ$FOUND                 YES. PROCESS IT.\nFJ$CLCNM CLC   QPARM1,JQEJNAME          IS THIS THE RIGHT JOBNAME?\n         BNE   FJ$NEXTQ                 NO - TRY NEXT\n         TM    QSCFLAG2,QSC2SLOG        LOOKING FOR SYSLOG BY NAME?\n         BNO   FJ$UJCHK                 NO - SEE IF UNIQUE JOB FOUND\n*  HAVE FOUND A SYSLOG ON THE STC QUEUE, AND WE ARE SEARCHING FOR IT\n*  BY NAME.  SEE IF IT'S THE ONE FOR THE SYSTEM WE ARE INTERESTED IN.\n*  (IN CASE OF M.A.S., WE MAY SEE OTHER ACTIVE SYSLOG'S FIRST...)\n         IC    R15,JQEFLAGS             PICK UP FLAG BYTE\n         N     R15,=A(QUEBUSY)          ISOLATE CPU BUSY VALUE\n         BZ    FJ$NEXTQ                 IGNORE IF NOT ACTIVE???\n         SLL   R15,3                    TIMES LENGTH OF QSYSID ENTRY\n         AL    R15,QVSYSID              -> SYSTEM ID ENTRY\n         CLC   QPARM3(4),0(R15)         FOUND SYSLOG FOR DESIRED SYS?\n         BE    FJ$FOUND                 YES - PROCESS IT\n         SPACE 2\nFJ$NEXTQ QNEXT R3,JQENEXT,NONE=FJ$NXJQT NO. TRY NEXT ENTRY.\n         B     FJ$NXJQE                 LOOP\nFJ$NXJQT LA    R2,$JQHEADL(,R2)         TRY NEXT QUEUE\n         BCT   R0,FJ$JQT1               LOOP IF NOT LAST QUEUE\n         TM    QFLAG1,Q1JOBID           WAS SEARCH BY JOBNUMBER?\n         BNO   FJ$JFCHK                 NO - SEE IF A JOB WAS FOUND\n         NI    QFLAG1,255-Q1JOBID       YES - TRY AGAIN BY ...\n         B     FJ$JOBNM                 ... JOBNAME\nFJ$JFCHK L     R3,QCJQEA                GET JQE ADDR, IF ANY\n         TM    FJ@FLAGS,FJ@FOUND        WAS A JOB FOUND?\n         BO    FJ$FOUND                 YES - PROCESS IT\n         MVC   QERRMSG,QBLANK           CLEAR THE AREA\n         MVC   QERRMSG(7),=C'*** JOB'\n         MVC   QERRMSG+8(8),QPARM1      WHAT HE ASKED FOR\n         MVC   QERRMSG+17(24),=C'NOT FOUND OR INVALID ***'\n         QTILT *,OPTIONS=REPROMPT       TELL HIM HE BLEW IT\nFJ$UJCHK ST    R3,QCJQEA                SAVE JQE ADDR\n         TM    FJ@FLAGS,FJ@FOUND        WAS THERE A PREVIOUS MATCH?\n         BO    FJ$TILT2                 YES - ERROR\n         OI    FJ@FLAGS,FJ@FOUND        NO - THERE IS NOW\n         B     FJ$NEXTQ                 KEEP SCANNING\nFJ$TILT1 QTILT '*** JOBID OPERAND NOT SPECIFIED ***',OPTIONS=REPROMPT\nFJ$TILT2 QTILT '*** DUPLICATE JOBNAME -- USE JOBNUMBER ***',           $\n               OPTIONS=REPROMPT\n***********************************************************************\n*                                                                     *\n*   READ JCT AND IOT                                                  *\n*                                                                     *\n***********************************************************************\nFJ$FOUND ST    R3,QCJQEA                SAVE THE ADDRESS\n         MVC   QINTJBID+2(2),JQEJOBNO   SAVE JES2 INTERNAL JOB NUMBER\n         MVC   QJOBID(2+8),QLNG1        SAVE JOBID AND LENGTH\n         MVC   QCTRAK,JQETRAK           DISK ADDR OF JCT\n         LR    R1,R9                    PARM FOR READSPC\n         MVC   QCCBID,=C'JCT '          SHOW WHAT WE WANT\n         LR    R0,R3                    -> JQE\n         QCALL READSPC                  READ HASPACE\n         USNGX JCTSTART,R9              BASE REG FOR JCT\n         MVC   QJOBNAME,JCTJNAME        SAVE JOB NAME\n         MVC   QEXTJBID,JCTJOBID        SAVE JES2 EXTERNAL JOB ID\n         OC    QEXTJBID+3(5),=C'00000'  JES2 TENDS TO LEAVE IN BLANKS\n         MVC   QPARM1(1),JCTJOBID       SET JOBID IN CASE...\n         MVC   QPARM1+1(5),QEXTJBID+3   ...JOB WAS ORIGINALLY...\n         MVC   QPARM1+6(2),QBLANK       ...\n         MVI   QLNG1+1,6                ...SELECTED BY NAME...\n         OI    QFLAG1,Q1JOBID           ...FLAG THAT WE NOW HAVE BY ID\n         MVC   QJOBID(2+8),QLNG1        ...SAVE JOBID AND LENGTH AGAIN\n         MVC   QPJOBID,JCTJBKEY         JOB IDENTIFICATION\n         MVC   QDHJOBID(8),QJOBNAME     'JOBNAMEX'\n         MVI   QDHJOBID+8,C'('          'JOBNAMEX('\n         MVC   QDHJOBID+9(8),QEXTJBID   'JOBNAMEX(JOBNNNNN'\n         MVI   QDHJOBID+17,C')'         'JOBNAMEX(JOBNNNNN)'\n         MVI   QDHJOBID+18,C' '         'JOBNAMEX(JOBNNNNN) '\n          AIF   (&QLEVEL LT 12).FJ11\n         MVC   QCTRAK,JCTNJHTR          mttr of job header\n         L     R1,QCJCTNJH              -> buffer area\n         MVC   QCCBID,=C'NHSB'          assume JCT for ctl block\n         QCALL READSPC                  read in job header\n.FJ11     ANOP\n         MVC   QCTRAK,JCTIOT            DISK ADDR OF IOT\n         MVC   QJLINECT,JCTLINCT        linect for job\n         L     R1,QCIOTA                -> IOAREA FOR IOT FOR READSPC\n         MVC   QCCBID,=C'IOT '          SHOW WHAT WE WANT\n         LR    R0,R3                    -> JQE\n         QCALL READSPC                  READ HASPACE\n***********************************************************************\n*                                                                     *\n*  SEE IF USER \"OWNS\" THIS JOB (AT LEAST FOR CURRENT SUBCOMMAND)      *\n*                                                                     *\n*  VALIDITY CHECK CURRENT USER'S ACCESS TO THIS JOB IF NOT OWNED      *\n*                                                                     *\n***********************************************************************\n         TM    QFLAG1,Q1VALJOB          DOES THIS SUBCMD NEED ACCESS?\n         BNO   QSTOP                    NO - ALL DONE HERE\n         OI    QFLAG2,Q2OWNJOB          ASSUME HE OWNS IT\n         CLI   JCTJOBID,C'S'            IS IT AN STC?\n          AIF   (&@@ACF2 NE 0).FJ06\n         BE    FJVALNOT                 YES - GO TURN OFF FLAG\n         TM    QFLAG1,Q1LSTCMD          IS THIS A LIST TYPE SUBCMD?\n         BNO   FJ$NLIST                 NO - SKIP NEXT TEST\n         TM    QXAUTH,QXPSWD            DOES HE KNOW THE PASSWORD?\n         BO    QSTOP                    YES - LET HIM LOOK\n         CLC   QLOGON,JCTTSUID          NOTIFY= THIS USER?\n         BE    QSTOP                    YES - ALLOW IT\nFJ$NLIST SR    R1,R1                    CLEAR FOR IC\n          AGO   .FJ07\n.FJ06     ANOP\n         BE    FJ$STC                   YES - GO TURN OFF FLAG\n         SR    R1,R1                    CLEAR FOR IC\n.FJ07     ANOP\n         IC    R1,QLOGONL               GET LENGTH OF USERID\n         BCTR  R1,0                     -1 FOR EX\n         EX    R1,FJ$V$CLC              DOES JOBNAME START WITH USERID?\n         BE    QSTOP                    YES - OK\n          AIF   ('&@@QJOWN' EQ '').FJ08\n         CLC   QLOGON,&@@QJOWN          DID THIS USER SUBMIT THIS JOB?\n         BE    QSTOP                    YES - OK\n.FJ08     ANOP\n         DROPX R3                       JQE\n         SPACE 2\n          AIF   (&@@ACF2 EQ 0).FJ10\nFJ$STC   MVC   FJ@DSN,QBLANK            ASSUME JOB'S LID NOT FOUND\n          AIF   (&QLEVEL LT 4).FJ09\n         SPACE 2\n*---  LOCATE THE ACF2 USER SECTION IN THE NETWORK JOB HEADER       ---*\n*---  SEE ACF2.R314.ACFJES(ACF2X1) AT LABEL #ACFNJH1               ---*\n*---  OR SKK PRIVATE MACRO ACF2LNJS                                ---*\n         LH    R0,NJHLEN-NJHDSECT+JCTNJHDR  GET LENGTH OF NJH BLOCK\n         SH    R0,=H'4'                 ADJUST LENGTH FOR THE PREFIX\n         LA    R1,4+JCTNJHDR            -> FIRST SECTION\n         USNGX NJHU,R1\n         SPACE 1\nFJ$NJ$LP CLC   NJHUTYPE(6),FJ#ACFID     IS THIS THE ACF2 USER SECTION?\n         BE    FJ$ACF2                  YES - CONTINUE\n         SH    R0,NJHULEN               SUBTRACT LENGTH OF SECTION\n         AH    R1,NJHULEN               -> NEXT SECTION\n         LTR   R0,R0                    ANY MORE SECTIONS?\n         BP    FJ$NJ$LP                 YES - CHECK NEXT\n         B     FJVALNOT                 NO ACF2 USER SECTION\n         DROPX R1                       NJHU\n         SPACE 1\nFJ$ACF2  LA    R1,ACFNJVLD-ACFNJBLK(,R1)  -> ACVALD BLK IN JCB\n         USNGX ACVALD,R1\n         MVC   FJ@DSN(8),ACVLID         SAVE LID THAT JOB RAN ON\n         CLC   QLOGON,ACVLID            DID JOB RUN ON THIS USER'S LID?\n         BE    QSTOP                    YES - OK\n         CLC   QLOGON,ACVSLID           DID USER SUBMIT THIS JOB?\n         BE    QSTOP                    YES - OK\n         DROPX R1                       ACVALD\n          AGO   .FJ10                   SKIP OLD CODE\n         ICM   R1,B'1111',&ACF2JCT      OFFSET OF ACF2 USER AREA\n         BZ    FJVALNOT                 SKIP NEXT 2 TESTS IF NOT VALID\n*---  THE FOLLOWING IS A KLUDGE.  THE REAL NUMBER SHOULD BE        ---*\n*---  'BUFSTART-BUFDSECT', BUT IF I CODE A $BUFFER MACRO, IT WILL  ---*\n*---  MESS UP USAGE OF $HQT, $IOT, AND $JCT.  THIS WILL HAVE TO BE ---*\n*---  STRAIGHTENED OUT SOMETIME IN THE FUTURE, WHEN I FEEL LIKE IT.---*\n         AR    R1,R9\n         SH    R1,=Y(X'58')             -> ACF2 USER AREA\n         USNGX #ACFJCTX,R1\n.FJ09     ANOP\n         CLC   =C'ACFJ',JCTACFJ         IS IT ANY GOOD?\n         BNE   FJVALNOT                 NO - SAY SO\n         MVC   FJ@DSN(8),ACVLID         SAVE LID THAT JOB RAN ON\n         CLC   QLOGON,LIDLID            DID JOB RUN ON THIS USER'S LID?\n         BE    QSTOP                    YES - OK\n         CLC   QLOGON,ACVSLID           DID USER SUBMIT THIS JOB?\n         BE    QSTOP                    YES - OK\n          AIF   (&QLEVEL LT 4).FJ10\n         DROPX R1                       #ACFJCTX\n.FJ10     ANOP\nFJVALNOT XI    QFLAG2,Q2OWNJOB          NO CRITERION MET - NOT OWNED\n         TM    QXAUTH,QXOPER+QXSYSP     OPERATOR OR SYSTEMS PGMR AUTH?\n         BNZ   QSTOP                    YES - ALLOW ACCESS TO ANY JOB\n          AIF  (&@@ACF2 EQ 0).FJ13      SKIP AROUND ACF2 CODE\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*  JOB IS NOT OWNED BY THE CURRENT UNPRIVILEGED USER - SEE IF ACCESS  *\n*  IS ALLOWED BY OWNER'S ACF2 RULES                                   *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n*---  NOTE:  RE-ASSEMBLE IF ACFINCVT MACRO CHANGES ********************\n         ACFINCVT  R7,NONE=QSTOP        FIND ACF2 CVT\n         SPACE 1\n         USNGX ACCVT,R7\n         LA    R8,FJ@ACPRM              -> PARMLIST WORK AREA\n         USNGX ACDSV,R8\n         XC    ACFSPARM(ACFSPRML),ACFSPARM  CLEAR PARMLIST\n         MVI   ACFSPREQ,ACFSPRAC        SETUP SVC INTERFACE\n         MVI   ACFSPID1,ACFSPIUR        INDICATE USER CALLER\n         MVI   ACFSPAC2,0               ...\n         MVI   ACFSPAC1,ACFSPAIN        ASSUME READ ACCESS?\n         TM    QFLAG1,Q1LSTCMD          IS IT?\n         BO    *+8                      YES - OK\n         MVI   ACFSPAC1,ACFSPAOT        NO - SET TO ALLOC ACCESS\n         TM    FJ@DSN,X'BF'             ANY LID FOUND?\n         BNZ   *+10                     YES - USE IT\n         MVC   FJ@DSN(8),=CL8'SYSTEM'   NO - USE \"SYSTEM\"\n         LA    R1,FJ@DSN+1              -> FIRST CHAR TO CHECK\nFJ$F$LID CLI   0(R1),C' '               FIND END OF LID?\n         BE    FJ$OKLID                 YES\n         LA    R1,1(,R1)                -> NEXT CHAR\n         B     FJ$F$LID                 KEEP LOOKING\nFJ$OKLID MVC   0(6,R1),=C'.@JOB.'       MIDDLE INDEX LEVEL\n         MVC   6(8,R1),JCTJNAME         LAST INDEX LEVEL = JOBNAME\n         LA    R14,FJ@DSN               -> DSNAME\n***      LA    R15,=C'SPOOL?'           -> VOLUME\n         LA    R15,=C'SYSTEM'           -> VOLUME (MUST BE SET UP IN\n*                                          ACF2 \"DSNAME PROTECTED\n*                                          VOLUMES\" LIST)\n         SR    R0,R0                    NO UCB PTR\n         SR    R1,R1                    NO ACUCB\n         LA    R2,QEXTJBID              -> MEMBER NAME = JOBID\n         LA    R3,QSUBNAME              -> \"DDNAME\"\n         SR    R4,R4                    NO INSTALLATION USER FIELDS\n         STM   R14,R4,ACFSPDSN          SAVE IN SVC PARMLIST\n         SPACE 1\n         ACFSVC  ACFSPARM,TYPE=S,CVT=HAVE\n         SPACE 1\n         LTR   R15,R15                  IS ACCESS VALID?\n         BZ    QSTOP                    YES\n         DROPX R7,R8                    ACCVT, ACDSV\n         TM    QXAUTH,QXOPER            NO, BUT IS USER AN OPERATOR?\n         BNO   FJ$NOPE2                 NO - IT'S OVER FOR SURE\n         TM    QFLAG1,Q1LSTCMD          YES - IS THIS A LIST COMMAND?\n         BNO   FJ$NOPE2                 NO - SEE COMMENT *-2\n         CLI   QSUBNAME,C'J'            YES - IS IT JCL/JLOG/JMSG?\n         BE    QSTOP                    YES - LET HIM LOOK\n*---  NOTE THAT THE VIOLATION MESSAGE HAS ALREADY BEEN ISSUED...\nFJ$NOPE2 TM    FJ@FLAGS,FJ@NTILT        should we do QTILT?\n         BNZ   QSTOP                    no - just exit\n         MVC   QERRMSG,QBLANK           CLEAR THE MSG AREA\n         MVC   QERRMSG(35),=C'*** NO ACF2 AUTHORITY TO ACCESS JOB'\n         MVC   QERRMSG+36(8),JCTJNAME   MOVE IN JOBNAME\n         MVI   QERRMSG+44,C'('\n         MVC   QERRMSG+45(8),JCTJOBID   MOVE IN JOBID\n         MVC   QERRMSG+53(5),=C') ***'\n         QTILT *\n.FJ13     ANOP\n         SPACE 2\nFJ$NOPE  TM    FJ@FLAGS,FJ@NTILT        should we do QTILT?\n         BNZ   QSTOP                    no - just exit\n         MVC   QERRMSG,QBLANK           CLEAR THE MSG AREA\n         MVC   QERRMSG(40),=C'*** YOU ARE NOT AUTHORIZED TO ACCESS JOB'\n         MVC   QERRMSG+41(8),JCTJNAME   MOVE IN JOBNAME\n         MVI   QERRMSG+49,C'('\n         MVC   QERRMSG+50(8),JCTJOBID   MOVE IN JOBID\n         MVC   QERRMSG+58(5),=C') ***'\n         QTILT *\n***********************************************************************\n*                                                                     *\n*   MISCELLANY                                                        *\n*                                                                     *\n***********************************************************************\nFJ$V$CLC CLC   QLOGON(*-*),JCTJNAME     << EXECUTED >>\nFJ#ACFID DC    B'11100000',B'00000001',C'ACF2'  TYPE, MOD, ID\n         LTORG\n         SPACE 3\n         DROPX R9,R13                   JCTSTART, WORK\n         SPACE 3\nWORK     DSECT\n         ORG   WORK+72                  PAST SAVE AREA\nFJ@FLAGS DS    B\nFJ@FOUND EQU   X'80'                    A MATCHING JOB WAS FOUND\nFJ@NTILT EQU   X'40'                    don't do QTILT here\nFJ@DSN   DS    CL44                     DSNAME WORK AREA\nFJ@ACPRM DS    0D                       PARMLIST WORK AREA\n         SPACE 3\n         QCOMMON\n         SPACE 3\n         Q$JQE\n         Q$JCT\n         Q$JQT\n         Q$HCT                          FOR $JQTYPES & $JQHEADL EQU'S\n         Q$NHD\n         QZACCVT\n         QZACDSV\n         QZACFJCB\n         QZACFNJB  ,                    GEN ACFNJBLK\n         QZACVALD\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "Q#FM": {"ttr": 6916, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x05@\\x00\\x00\\x00\\x82#/\\x00\\x92\\x01O\\x18'\\x04\\xd4\\x02\\x10\\x04\\x10\\xd3\\xc4\\xe6@@@@@@@\"", "ispf": {"version": "05.64", "flags": 0, "createdate": "1982-08-20T00:00:00", "modifydate": "1992-01-14T18:27:00", "lines": 1236, "newlines": 528, "modlines": 1040, "user": "LDW"}, "text": "         TITLE '--- QUEUE--FORMAT -- JQE AND JOE FORMAT ROUTINES ---'\n*---------------------------------------------------------------------*\n*                                                                     *\n*   FORMAT - generate a display line for selected job                 *\n*                                                                     *\n*   Entry - R9 = JQE address                                          *\n*           R8 = JOE address                                          *\n*           R1 = 0 --> Display JQE                                    *\n*              = 4 --> Display JOE                                    *\n*                                                                     *\n*   Updates:                                                          *\n*      14Jan92  LDW  Clear FM@FLAGS in a reasonable place to fix      *\n*                       various random unpredictable incorrect output *\n*      29Jun91  LDW  Fix SP410 held output to format JOE, not JQE     *\n*                    For SP410+, change 'HOUT' to 'H x'               *\n*      08Jun91  LDW  Integrate EMS's SP42 updates below:              *\n*     (24Apr91) EMS  Update for SP420                                 *\n*      27Apr91  LDW  05/10/84 didn't do it -- try again to            *\n*                       DISPLAY LNN.JTN DEVICE TYPES CORRECTLY        *\n*      25Apr91  LDW  Integrate GLA fixes below:                       *\n*     (10Aug89) GLA  Output WTRID in device field is field is blank.  *\n*                    Skip however if writer is requested.             *\n*               LDW  Don't do this if TIME requested!!!               *\n*     (12Jul89) GLA  Fix heading for DH command. Overlaid field.      *\n*               LDW  Still not right -- fiddled it some more          *\n*     ( 5Jul89) GLA  Fix timing problem formatting JOEs,              *\n*                    Occasionally CHK block not found on HASPACE      *\n*     (16Jun89) GLA  Fix loop problems in SLOG formating.             *\n*     (24Mar89) GLA  Fix JOE line cnt for lines left to do            *\n*                    Fix formating of STC SYSLOG (was missed as syslog*\n*      28Nov90  EMS  Update for SP410                                 *\n*      23May90  LDW  Add support for USERID operand                   *\n*                    Fix some other bugs in optional displays         *\n*      17Mar90  LDW  Correct display of OFFn.xx device type           *\n*      30Dec89  LDW  For date/time display, if job is from offload    *\n*                       device, try to find some other date stamp     *\n*                       and display it (flagged with '?') instead of  *\n*                       the \"off output\" date/time (which is the      *\n*                       reload time)                                  *\n*      23Nov89  LDW  Remove conditional assembly around Qxxx macros   *\n*                    Remove prereq macro Q$PDDB                       *\n*      09Jul89  LDW  Support spool percent display for jobs           *\n*      22Mar89  EMS  Update for SP311                                 *\n*      30May88  LDW  Add JQE & JOE subcommands                        *\n*      22Jul87  LDW  Fix for TG num used being in JQE extension       *\n*      19Jul87  EMS  Implement size operand for 1.3.6                 *\n*      15Jun87  EMS  update to use QITEM macro for date formatting    *\n*      15Feb87  LDW  Fix for 1.3.6 QUEUE type display (thanks, Doron) *\n*      25Jan87  LDW  Pass READSPC the JQE addr in case of CB ID error *\n*      17Jan87  LDW  Misc cleanup                                     *\n*      04Jan87  LDW  Don't look at $TGM for SP136                     *\n*                    Use QCJQELEN instead of JQELNGTH                 *\n*      14Dec86  LDW  Fix minor bug in previous update                 *\n*      29NOV86  LDW  Use DATEFMT subroutine                           *\n*                    Eliminate use of LC macro                        *\n*      05OCT86  LDW  SUPPORT QSC3WTRI                                 *\n*      03/31/86 LDW  RE-DESIGN 3278-5 SUPPORT (THIRD TRY!)            *\n*      02/23/86 LDW  DISPLAY OUTPUT PRIORITY CORRECTLY FOR SP133      *\n*                    HAVE \"XJ\" DISPLAY CKPTAREA ADDR OF JQE & JOE     *\n*                    SIMPLIFY STD FORMS CHECK                         *\n*      10/14/85 LDW  ADD SP133 CODE TO READ CHK FOR JOBS ON DEVICES   *\n*      02/07/85 EMS  ADD ASM TIME OPTION FOR DEFAULT STD FORM         *\n*      12/05/84 LDW  USE DIFFERENT HEADER LINE IF DI/AI/HI            *\n*                    FIX MINOR BUG THAT INCORRECTLY CAUSED 'STATUS    *\n*                       SYSLOG' DISPLAY FORMAT TO BE USED SOMETIMES   *\n*                       FOR OTHER THAN SYSLOG                         *\n*      08/30/84 LDW  USE HEX MACRO & QHEXTAB                          *\n*                    FIX BUG IN 'CHK' DISPLAY                         *\n*      07/24/84 LDW  DISPLAY SYSTEM AFFINITY FOR INPUT JOBS IN THE    *\n*                       'FORM/UCS,ETC' POSITION (IF NOT S=ALL)        *\n*      06/11/84 LDW  FIX FOR PRINTER# > 9                             *\n*      05/10/84 LDW  DISPLAY LNN.JTN DEVICE TYPES CORRECTLY           *\n*      04/12/84 LDW  JCTDSECT -> JCTSTART, IOTDSECT -> IOTSTART       *\n*                    FIX MINOR BUG IN QNAME DISPLAYED FOR STC/TSU     *\n*                    FIX BUG IN HEX DUMP OF WORK AND CHAR JOES        *\n*                    PRELIMINARY SP133 SUPPORT                        *\n*      01/19/84 LDW  FIX BUG IN PROCESSING LINE CMD FOR JOBNUM < 10   *\n*      12/20/83 LDW  ADD SUPPORT FOR 'SPACE' KEYWORD TO DISPLAY       *\n*                       SPOOL SPACE CURRENTLY ALLOCATED TO JOBS       *\n*      11/03/83 LDW  FIX 06/21/83 UPDATE FOR NON-SP                   *\n*      07/20/83 LDW  CLEAR R0 BEFORE DIVIDE FOR 'M' LINES             *\n*      07/19/83 LDW  DISPLAY SPECIAL INFO FOR SYSLOG IF \"STATUS\"      *\n*                    CHANGE USING/DROP TO USNGX/DROPX                 *\n*      06/21/83 LDW  FIGURE LINES REMAINING CORRECTLY                 *\n*      05/09/83 LDW  USE CORRECT JOE LENGTHS FOR \"XJ\"                 *\n*                    FIX FOR DEVICE NUMBER FOR SP                     *\n*      03/01/83 LDW  ADD JQE AND JOE OFFSET TO \"XJ\"                   *\n*      02/25/83 LDW  ADD SUPPORT FOR LINE COMMANDS                    *\n*      02/09/83 LDW  USE HEXFMT SUBROUTINE TO SUPPORT \"XJ\" SUBCOMMAND *\n*                    REMOVE QSC1DHX TESTS (NO LONGER NEEDED, SINCE    *\n*                       XHO WAS RENAMED TO DHX, AND \"DHX\" IS NOW      *\n*                       SUPPORTED AS THE \"ALL\" OPERAND OF \"DH\")       *\n*                    ADD HELD DS COUNT TO \"DH\" DISPLAY                *\n*                    CHECK NEW FLAG QSC2DJX INSTEAD OF QSUBNAME       *\n*      02/03/83 LDW  ADD SUPPORT FOR DUMPER AND LOADER DEVICE TYPES   *\n*                    PUT IN CHECK FOR UNKNOWN DEVICE TYPE             *\n*      02/02/83 LDW  DISPLAY DESTINATION NODE INSTEAD OF PRINT NODE   *\n*                       FOR JOBS ON THE 'XMIT' QUEUE                  *\n*      01/25/83 LDW  PUT IN 'S' OR 'T' INDICATOR FOR SP JOBNUMBERS    *\n*                    CORRECT Q NAMES FOR SP                           *\n*                    SET CLASS NAME FROM QCLSNAME INSTEAD OF QCLASS   *\n*      01/19/83 LDW  USE QVSYSID TO POINT TO SYSTEM ID TABLE          *\n*      01/10/83 LDW  REMOVE ALL CODE TO HANDLE TTY TYPE TERMINALS     *\n*                       (NOW DONE IN \"DISPLAY\")                       *\n*                    PUT IN BETTER COLUMN HEADER FOR \"XJ\"             *\n*      01/04/83 LDW  ADJUST FOR MODIFIED $JQT MACRO                   *\n*                    SP SUPPORT                                       *\n*                    DISPLAY HELD OUTPUT AS 'HOUT' INSTEAD OF 'H-O'   *\n*      11/20/82 LDW  SQUEEZE OUT ATTR BYTES IF NOT ON A 3270 TERMINAL *\n*      11/17/82 LDW  JUGGLE OUTPUT FIELDS TO PROVIDE FOR INPUT FIELD, *\n*                       HIGH INTENSITY LINE COUNT IF > 99K, HIGH      *\n*                       INTENSITY JOB NUMBER, LONGER CLASSNAME IF SP3 *\n*                    CHANGE 'RJE ID' IN HEADER TO 'NJE/RJE'           *\n*                    SUPPORT 'TIME' FOR JOBS ON OUTPUT QUEUE          *\n*                    CHANGE HEADER AND SOME OTHER DATA TO LOWER CASE  *\n*                    MISCELLANEOUS OTHER MINOR RELATED CHANGES        *\n*      11/15/82 LDW  CORRECT FOR FREE JQE'S ON PURGE QUEUE            *\n*      11/02/82 LDW  FIX FOR DOT MISSING IN \"RNN.RDN\"                 *\n*      10/21/82 LDW  CHANGE \"HO\" AND \"XHO\" TO \"DH\" AND \"DHX\"          *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 3\nFORMAT   QSTART  Q7,WORKLEN=FM@WORKL\n         USNGX WORK,R13                 BASE FOR LOCAL WORK AREA\n         USNGX JQEDSECT,R9              BASE REG FOR JQE DSECT\n         USNGX JOEDSECT,R8              BASE REG FOR JOE DSECT\n         MVI   FM@FLAGS,0               INIT FLAGS\n         CLI   QCODE,100                JQE subcommand?\n         BE    FM$JQE                   yes - process it\n         CLI   QCODE,104                JOE subcommand?\n         BE    FM$JOE                   yes - process it\n         MVC   QDLCTBL,=V(PA#LC#FM)     SET ADDR OF LINE COMMANDS TABLE\n*        MVI   QDATRNUM+1,2             ASSUME 2 ATTR BYTES IN LINE\n         MVC   FM@ATTR1,=X'1DC8'        SET INPUT, BRIGHT\n         MVC   FM@ATTR2,=X'1D60'        SET OUTPUT, NORMAL\n         MVI   QDATRNUM+1,7             BUT NOW 7 ATTR BYTES IN LINE\n         MVC   FM@ATTR3,=X'1DE8'        SET OUTPUT, BRIGHT\n         MVC   FM@ATTR4,=X'1D60'        SET OUTPUT, NORMAL\n         MVC   FM@ATTR5,=X'1D60'        SET OUTPUT, NORMAL\n         MVC   FM@ATTR6,=X'1D60'        SET OUTPUT, NORMAL\n         MVC   FM@ATTR7,=X'1DC8'        SET INPUT, BRIGHT\n***********************************************************************\n*                                                                     *\n*   BRANCH TO PROPER ROUTINE                                          *\n*                                                                     *\n***********************************************************************\n         LR    R2,R1                    SAVE ENTRY CODE\n         QITEM RESET,PREFIX=FM          init for qitem calls\n         QCALL DISP80                   SWITCH TO 3278-2 MODE IF 3278-5\n         MVC   QDHLINE,=CL80'   Queue  Pos Jobname   Job# Pri Lines Exe$\n               c Hld Form Fcb  Ucs  Device   Nje/Rje'\n*%%%  PROBABLY SHOULD HAVE A SPECIAL HEADER LINE IF \"STATUS SYSLOG\"\n*---  If user wants TIME, USERID, and WRITER, can't do it, so reset\n*---  TIME if he asked for all 3.\n         TM    QSCFLAG1,QSC1TIME        TIME requested?\n         BZ    FM$NOT3                  no - skip\n         TM    QSCFLAG3,QSC3USER+QSC3WTRI  USER and WRITER requested?\n         BNO   FM$NOT3                  no - skip\n         NI    QSCFLAG1,255-QSC1TIME    all 3, so reset TIME\nFM$NOT3  EQU   *\n         TM    QSCFLAG3,QSC3OUTG        OUTGRP requested?\n         BNO   *+10                     NO - SKIP\n         MVC   QDHLINE+FM@DEVNM-6-FM@CLEAR(7),=C'Out Grp'\n         TM    QSCFLAG1,QSC1SPC         FMT SPOOL SPC INSTEAD OF LINES?\n         BNO   *+10                     NO - SKIP\n         MVC   QDHLINE+FM@LINES-5-FM@CLEAR(5),=C'TGnum'\n         TM    QSCFLAG1,QSC1PCT         FMT SPOOL pct INSTEAD OF LINES?\n         BNO   *+10                     NO - SKIP\n         MVC   QDHLINE+FM@LINES-5-FM@CLEAR(5),=C' Pct '\n         TM    QSCFLAG1,QSC1TIME        FORMAT INPUT OR OUTPUT TIME?\n         BNO   *+8                      NO - SKIP\n         NI    QSCFLAG1,255-QSC1PGMR    YES - DON'T TRY FOR PGMR NAME\n         TM    QSCFLAG1,QSC1PGMR        FORMAT PROGRAMMER NAME?\n         BNO   FMT$STD1                 NO - SKIP\n         MVC   QDHLINE+FM@OVER-6-FM@CLEAR(FM@OVERL),FM#PNHDR 'PGMR NM'\n         B     FMT$STD2                 CONTINUE\nFMT$STD1 TM    QSCFLAG1,QSC1TIME+QSC1DH ANY OTHER SPECIAL REQUESTS?\n         BNZ   *+12                     YES - PROCESS\n         TM    QSCFLAG2,QSC2DI          ANY OTHER SPECIAL REQUESTS?\n         BZ    FMT$STD2                 NO - CONTINUE\n         MVC   QDHLINE+FM@OVER-6-FM@CLEAR(FM@OVERL),QBLANK CLEAR CHARS\n         TM    QSCFLAG1,QSC1TIME        FORMAT INPUT OR OUTPUT TIME?\n         BNO   *+10                     NO - SKIP\n         MVC   QDHLINE+FM@OVER-6-FM@CLEAR(15),=C' Date      Time'\n          AIF   (&QLEVEL GE 11).FM015\n         TM    QSCFLAG1,QSC1DH          IS THIS \"DH\"?\n         BNO   *+10                     NO - SKIP\n         MVC   QDHLINE+FM@OVER-6-FM@CLEAR+11+1+1(9),=C'Held DS #'\n.FM015    ANOP\n         TM    QSCFLAG2,QSC2DI          IS THIS \"DI\"?\n         BNO   *+10                     NO - SKIP\n         MVC   QDHLINE+FM@OVER-6-FM@CLEAR(6),=C'SysAff'\nFMT$STD2 TM    QSCFLAG3,QSC3FLSH        WANT FORM FLASH?\n         BNO   *+10                     NO - ALL SET AS IS\n         MVC   QDHLINE+FM@FLASH-7-FM@CLEAR(8),=CL8'Flash' YES - SET IT\n         TM    QSCFLAG3,QSC3USER        WANT userid?\n         BNO   *+10                     NO - ALL SET AS IS\n         MVC   QDHLINE+FM@USER-7-FM@CLEAR(8),=CL8'Userid' YES - SET IT\n         TM    QSCFLAG3,QSC3WTRI        WANT WRITER NAME?\n         BNO   FMT$STD3                 NO - ALL SET AS IS\n         TM    QSCFLAG1,QSC1TIME        FORMAT INPUT OR OUTPUT TIME?\n         BO    FMT$WTR                  YES - PUT WTRNAME IN RJE/NJE\n         MVC   QDHLINE+FM@WTRNM-6-FM@CLEAR(8),=C'Wtr/User'  SET IT UP\n         B     FMT$STD3                 CONTINUE\nFMT$WTR  NI    QSCFLAG3,255-QSC3FLSH    RESET \"SHOW FLASH\"\n         MVC   QDHLINE+FM@WTRNX-7-FM@CLEAR(8),=C'Wtr/User'  SET IT UP\nFMT$STD3 MVC   FQUEUE,QCLSNAME          CLASS NAME\n         CLI   QCLASS,12                IS THIS A MISC QUEUE?\n         BNE   FMT$NORM                 NO - LEAVE IT\n         S     R4,QCJQHEAD              OFFSET * $JQHEADL OF QUEUE HDR\n          AIF   (&QLEVEL GE 4).FM020\n         AR    R4,R4                    MISC DESCRIPTIONS ARE 4 CHARS\n.FM020    ANOP\n         LA    R4,FMTMISC(R4)           -> 4 CHAR DESCRIPTION\n         MVC   FM@QNAME(4),0(R4)        MOVE IN MISC DESC.\n         CLC   =C'RDR',FM@QNAME         READING?\n         BE    FMREADNG                 YES - NO RJE ID AVAILABLE YET\nFMT$NORM TM    QSCFLAG3,QSC3FLSH        WANT FORMS FLASH?\n         BNZ   FMREADNG                 YES - DON'T FORMAT REMOTE ID\n          AIF   (&QLEVEL LT 4 AND NOT &@@QNJE).FM040\n         LH    R0,JQEXEQND              GET INITIAL EXECUTION NODE\n         SLL   R0,16                    SET RMT=0\n         ST    R0,FMT@CONV              STORE FOR \"FINDRJE\"\n         LA    R1,FMT@CONV              POINT TO IT\n         CLC   FM#XMIT,FM@QNAME         IS THIS THE XMIT QUEUE?\n         BE    FMT$ROUT                 YES - FORMAT XMIT DEST\n         CLC   FM#RECV,FM@QNAME         IS THIS THE RECV QUEUE?\n         BE    FMT$ROUT                 YES - FORMAT RECV DEST\n.FM040    ANOP\n         LA    R1,JOEROUT               POINT TO REMOTE ID\n         LTR   R2,R2                    JQE OR JOE?\n         BNZ   FMT$ROUT                 JOE\n*        LA    R1,JQEPUNRT              POINT TO PUNCH ROUTE FIELD\n*        CLC   QCLOCAL,0(R1)            LOCAL?\n*        BNE   *+8                      NO - GO FORMAT IT\n          AIF   (&QLEVEL GE 12).FM044\n         LA    R1,JQEPRTRT              POINT TO PRINT ROUTE FIELD\n          AGO   .FM048\n.FM044    ANOP\n         LA    R1,JQEDRPRT              POINT TO PRINT ROUTE FIELD\n.FM048    ANOP\nFMT$ROUT QCALL FINDRJE                  GO DECODE DEST (ROUTE)\n         MVC   FM@REMOT,0(R1)           MOVE REMOTE ID TO PRINT LINE\n          AIF   ('&@@QJOWN' EQ '').FM060  USER not available\n         TM    QSCFLAG3,QSC3USER        WANT user?\n         BZ    *+10                     no - skip\n         MVC   FM@USER,&@@QJOWN         yes - show it\n.FM060    ANOP\nFMREADNG IC    R15,JQEFLAGS             GET SYSTEM NUMBER\n         N     R15,=A(QUEBUSY)          ZERO OUT UNWANTED BITS\n         BZ    FM$NBUSY                 SKIP IF NOT EXECUTING\n         SLL   R15,3                    MULTIPLY BY 8\n         AL    R15,QVSYSID              OBTAIN SYSTEM ID\n         MVC   FM@SYSID,0(R15)          MOVE SYSTEM ID TO DISPLAY\nFM$NBUSY CLI   QCLASS,0                 IS THIS THE TSO QUEUE?\n         BE    FM$L$TSO                 YES. DO IT.\n         CLI   QCLASS,4                 IS THIS THE STC QUEUE?\n         BE    FM$L$STC                 YES. DO IT.\n         CLI   QCLASS,8                 IS THIS THE HELD OUTPUT QUEUE?\n         BE    FM$L$DH                  YES. DO IT.\n         CLI   QCLASS,12                IS THIS A MISC QUEUE?\n         BE    FMT$JQE                  YES. Q IS ALREADY FULLY NAMED.\n         CLI   QCLASS,16                IS THIS THE \"PURGE\" QUEUE?\n         BE    FMT$JQE                  YES. Q IS ALREADY FULLY NAMED.\n         LTR   R2,R2                    IS REQUEST FOR JQE OR JOE?\n         BZ    FM$L$JQE                 JQE.\n***********************************************************************\n*                                                                     *\n*   FORMAT JOE                                                        *\n*                                                                     *\n***********************************************************************\n         MVI   FM@QNAME,C'O'            MOVE IN NAME OF QUEUE\n          AIF   (&QLEVEL LT 7).FM080\nFM$L$JOE TM    QSCFLAG3,QSC3OUTG        want OUTGRP?\n         BO    FM$OG                    yes - do it instead of device\n.FM080    ANOP\n         MVC   FM@DEVID,JOEDEVID        GET DEVICE ID TO FORMAT\n         BAL   R7,FMT$DEV               FORMAT IT\n          AIF   (&QLEVEL LT 7).FM100\n         B     FM$OG99                  skip around OUTGRP code\nFM$OG    MVC   FM@DEVNM,QBLANK          clear field\n         MVC   FM@OUTGP,QBLANK          clear field\n         MVC   FM@OUTGP(8),JOENAME      move in user part\n         LA    R7,FM@OUTGP\nFM$OG1   CLI   0(R7),C' '               any blank yet?\n         BE    FM$OG2                   yes - done\n         LA    R7,1(,R7)                bump to next\n         B     FM$OG1\nFM$OG2   MVI   0(R7),C'.'               set separator\n         LA    R7,1(,R7)                bump\n         LH    R1,JOEID1                get first id\n         CVD   R1,FMT@CONV              make decimal\n         MVC   FMT@CONV+8(6),=X'402020202120'\n         LA    R1,FMT@CONV+8+5          point at last real digit\n         EDMK  FMT@CONV+8(6),FMT@CONV+5 convert it\n         LA    R15,FMT@CONV+8+5         point at last byte\n         SR    R15,R1                   get length-1\n         EX    R15,FM$OG$M1             MVC 0(*-*,R7),0(R1)\n         LA    R7,1(R15,R7)\n         MVI   0(R7),C'.'               set separator\n         LA    R7,1(,R7)                bump\n         LH    R1,JOEID2                get first id\n         CVD   R1,FMT@CONV              make decimal\n         MVC   FMT@CONV+8(6),=X'402020202120'\n         LA    R1,FMT@CONV+8+5          point at last real digit\n         EDMK  FMT@CONV+8(6),FMT@CONV+5 convert it\n         LA    R15,FMT@CONV+8+5         point at last byte\n         SR    R15,R1                   get length-1\n         EX    R15,FM$OG$M1             MVC 0(*-*,R7),0(R1)\n         LA    R7,1(R15,R7)\n         LA    R15,FM@OUTGP             get start address\n         SR    R7,R15                   get length of fmted str\n         CH    R7,=H'8'                 do we need to overlay\n         BH    FM$OG3                   yes, go overlay\n         LA    R1,FM@DEVNM              point at first byte\n         B     FM$OG4\nFM$OG3   LA    R1,FM@DEVNM+L'FM@DEVNM   last usable byte\n         SR    R1,R7                    backup up\nFM$OG4   BCTR  R7,0                     get machine length\n         EX    R7,FM$OG$M2              MVC 0(*-*,R1),0(R15)\nFM$OG99  DS    0H\n.FM100    ANOP\n         L     R0,JOERECCT              NUMBER OF PRINT LINES\n          AIF   (&QLEVEL LT 5).FM102\n         S     R0,JOEWRECN              subtract recs printed so far\n.FM102    ANOP\n         TM    JOEFLAG,$JOEPRT+$JOEPUN  PRINTING OR PUNCHING? %%%\n         NOP   FMT$LNCT   (BZ)          NO - SKIP             %%%\n         TM    JOEFLAG,$JOECKV          IS THE CKPT VALID?\n         BZ    FMT$LNCT                 NO. SKIP IT.\n          AIF   (&QLEVEL GT 4).FM140\n         QNEXT R15,JOECKPT,NONE=FMT$LNCT  OFFSET TO CHECKPOINT JOE\n         AL    R15,QCJOTA               ADD BASE TO OFFSET\n          AIF   (&QLEVEL GE 4).FM120\n         S     R0,JOETLNC-JOEDSECT(,R15)   SUB RECS PRINTED FROM TOTAL\n          AGO   .FM160\n.FM120    ANOP\n         S     R0,JOECRECN-JOEDSECT(,R15)  SUB CURRENT REC# FROM TOTAL\n          AGO   .FM160\n.FM140    ANOP\n         MVC   QCTRAK,JOECPADR          DISK ADDR OF CHK\n         L     R5,QCBLKA                -> HASPACE BUFFER FOR READSPC\n         XC    QCBLKTTR,QCBLKTTR        FORCE REREAD\n         LR    R1,R5                    PARM FOR READSPC\n         LR    R0,R9                    -> JQE\n         MVC   QCCBID,=C'CHK '          SHOW WHAT WE NEED\n         QCALL READSPC                  READ HASPACE\n         L     R0,JOERECCT              NUMBER OF PRINT LINES\n         S     R0,CHKCRECN-CHKSTART(,R5)  SUB CURRENT REC# FROM TOTAL\n***%%%*% S     R0,JOEWRECN              SUBTRACT RECS PRINTED SO FAR\n.FM160    ANOP\nFMT$LNCT BAL   R14,FMT$LNES             GO FORMAT NUMBER OF PRINT LINES\n         TM    QSCFLAG3,QSC3WTRI        WANT WRITER NAME?\n         BNZ   FM$WTR1                  yes - output it\n         CLC   FM@DEVNM,QBLANK          is device blank?\n         BNE   FM$NOWTR                 no - don't overlay it w/ writer\nFM$WTR1  QNEXT R15,JOECHAR,NONE=FM$NOWTR  OFFSET TO CHARACTERISTICS JOE\n         AL    R15,QCJOTA               ADD BASE TO OFFSET\n         L     R14,=V(CHARTAB)          -> TRANSLATE TABLE\n         USNGX JOEDSECT,R15             TEMP FOR CHAR JOE\n         TM    QSCFLAG3,QSC3WTRI        writer name requested?\n         BNZ   FM$WTR$N                 yes - put in normal column\n         TM    QSCFLAG1,QSC1TIME        TIME requested?\n         BNZ   FM$NOWTR                 yes - no place for writer\n         MVC   FM@DEVNM,JOEWTRID        no - so put it in device column\n         TR    FM@DEVNM,0(R14)          GET RID OF GARBAGE\n         CLC   FM@DEVNM,QBLANK          is it blank?\n         BE    FM$NOWTR                 yes - ignore\n         MVI   FM@DEVNM-1,C'>'          flag as writer\n         B     FM$NOWTR                 continue\nFM$WTR$N TM    QSCFLAG1,QSC1TIME        FORMAT INPUT OR OUTPUT TIME?\n         BO    FM$WTR$A                 YES - PUT WTRNAME IN ALT FIELD\n         MVC   FM@WTRNM,JOEWTRID        YES - DISPLAY IT\n         TR    FM@WTRNM,0(R14)          GET RID OF GARBAGE\n         B     FM$NOWTR                 CONTINUE\nFM$WTR$A MVC   FM@WTRNX,JOEWTRID        DISPLAY WTRID IN ALT FIELD\n         TR    FM@WTRNX,0(R14)          GET RID OF GARBAGE\n         DROPX R15                      JOEDSECT\nFM$NOWTR TM    QSCFLAG1,QSC1TIME        INPUT OR OUTPUT TIME REQUESTED?\n         BO    FMT$LIST                 YES - DON'T FMT FORM/UCS/FCB/FL\n         CLI   QCODE,0                  IS THIS \"STATUS\" SUBCOMMAND?\n         BNE   FMT$NOSL                 NO - DISPLAY STANDARD DATA\n         CLC   =CL8'SYSLOG',JQEJNAME    YES - IS THIS A SYSLOG?\n         BNE   FMT$NOSL                 NO - DISPLAY STANDARD DATA\n         OI    FM@FLAGS,FM@SLOG         REMEMBER THIS IS \"ST SYSLOG\"\n         B     FMT$LIST                 DON'T DISPLAY STANDARD DATA\nFMT$NOSL QNEXT R15,JOECHAR,NONE=FMT$LIST  OFFSET TO CHARACTERISTICS JOE\n         AL    R15,QCJOTA               ADD BASE TO OFFSET\n         USNGX JOEDSECT,R15             TEMP FOR CHAR JOE\n*  FOLLOWING COMPARE ASSUMES THAT 'JOEFORM' HAS CORRECT LENGTH ATTR\n         CLC   JOEFORM,=CL8'&@@QSTDF'   IS IT STANDARD?\n         BE    *+10                     YES - DON'T DISPLAY IT\n         MVC   FM@FORM,JOEFORM          MOVE FORM NAME\n         CLC   =C'****',JOEUCS          IS IT STANDARD?\n         BE    *+10                     YES - DON'T DISPLAY IT\n         MVC   FM@UCS,JOEUCS            MOVE UCS NAME\n         CLC   =C'****',JOEFCB          IS IT STANDARD?\n         BE    *+10                     YES - DON'T DISPLAY IT\n         MVC   FM@FCB,JOEFCB            MOVE FCB NAME\n         CLC   FM@FLASH,QBLANK          ANYTHING ALREADY HERE? (RJE ID)\n         BNE   FMT$LIST                 YES - DON'T MOVE IN FLASH\n         CLC   =C'****',JOEFLASH        IS IT STANDARD?\n         BE    FMT$LIST                 YES - DON'T DISPLAY IT\n         MVC   FM@FLASH,JOEFLASH        MOVE 3800 FORMS FLASH\n         TM    QSCFLAG3,QSC3FLSH        WANT FLASH DISPLAYED?\n         BO    FMT$LIST                 YES - SET\n         MVC   FM@REMOT(2),=C'O='       INDICATE WE'RE BEING PERVERSE\n         MVC   FM@REMOT+2(4),JOEFLASH   AND SHOW THE FLASH\n         B     FMT$LIST                 FORMAT REST OF LINE\n         DROPX R15                      JOEDSECT\nFM$OG$M1 MVC   0(*-*,R7),0(R1)          << executed >>\nFM$OG$M2 MVC   0(*-*,R1),0(R15)         << executed >>\n***********************************************************************\n*                                                                     *\n*   FORMAT JQE                                                        *\n*                                                                     *\n***********************************************************************\nFM$L$TSO MVC   FM@QNAME(4),=C'TSU '     NAME OF QUEUE\n         B     FMT$JQE                  CONTINUE\nFM$L$STC MVC   FM@QNAME(4),=C'STC '     NAME OF QUEUE\n         B     FMT$JQE                  CONTINUE\n          AIF   (&QLEVEL GE 11).FM184\nFM$L$DH  MVC   FM@QNAME(4),=C'HOUT'     NAME OF QUEUE\n         B     FMT$JQE                  CONTINUE\n          AGO   .FM188\n.FM184    ANOP\nFM$L$DH  MVI   FM@QNAME,C'H'            NAME OF QUEUE\n         B     FM$L$JOE                 CONTINUE\n.FM188    ANOP\nFM$L$JQE MVI   FM@QNAME,C'I'            NAME OF QUEUE\n*---  IF SYSTEM AFFINITY IS NOT \"ALL\", DISPLAY IT                  ---*\n         CLI   JQEFLAG2,QUESYSAF        NON-IND AND S=ALL?\n         BE    FMT$JQE                  YES - SKIP\n         MVC   FM@FORM(2),=C'S='        SHOW WHAT THIS JUNK IS\n         LA    R14,FM@FORM+2            -> OUTPUT AREA\n         LA    R6,4                     MAX WE CAN FIT\n         TM    JQEFLAG2,QUEINDAF        INDEPENDENT MODE AFFINITY?\n         BNO   FM$N$IND                 NO - SKIP\n         MVC   0(3,R14),=C'IND'         YES - SHOW IT\n         LA    R14,3+1(,R14)            INCREMENT\nFM$N$IND TM    JQEFLAG2,QUESYSAF        S=ANY?\n         BO    FMT$JQE                  YES - DON'T SAY SO, FOR NOW\n         IC    R0,JQEFLAG2              GET SYSTEM AFFINITY FLAGS\n         N     R0,=A(QUESYSAF)          STRIP OFF GARBAGE\n         SR    R1,R1                    CLEAR FOR SRDL\n***      LA    R15,QSYSID               -> ZERO'TH SYSTEM ID\n         L     R15,QVSYSID              -> ZERO'TH SYSTEM ID\n         SPACE 1\nFM$AFFLP LA    R15,L'QSYSID(,R15)       -> NEXT SYSTEM ID\n         SRDL  R0,1                     SHIFT LOWEST BIT TO R1\n         LTR   R1,R1                    IS THIS BIT SET?\n         BZ    FM$AFFNO                 NO - SKIP\n         MVC   0(4,R14),0(R15)          MOVE SYSID TO DISPLAY LINE\n         LA    R14,4+1(,R14)            BUMP OUTPUT PTR\n         BCT   R6,FM$AFFNO              YES - CONTINUE IF ROOM FOR IT\nFM$AFFNO LTR   R0,R0                    ANY MORE BITS SET?\n         BNZ   FM$AFFLP                 YES - CONTINUE\n         SPACE 2\nFMT$JQE  CLI   JQETYPE,$FREE            FREE QUEUE?\n         BNE   *+10                     NO - SKIP\n         MVC   FM@QNAME(4),=C'FREE'     YES - SHOW WHAT IT REALLY IS\n**%%     MVI   FM@FLAGS,0               CLEAR FLAGS\n         CLC   =CL8'SYSLOG',JQEJNAME    IS THIS A SYSLOG?\n         BNE   *+8                      NO - DONT FLAG AS SUCH\n         OI    FM@FLAGS,FM@SLOG         REMEMBER - IS \"SYSLOG\"\n         TM    JQETYPE,$XEQ             EXECUTION QUEUE?\n         BO    FMT$LIST                 YES - NOT ON DEVICE\n         TM    JQETYPE,$INPUT+$RECEIVE+$XMIT  READING/TRANSMITTING?\n         BZ    FMT$LIST                 NO - NOT ON DEVICE\n         MVC   FM@DEVID,JQEDEVID        GET DEVICE ID TO FORMAT\n         BAL   R7,FMT$DEV               FORMAT IT\nFMT$LIST MVC   FMT@CONV(6),=X'402020202020'  PREPARE FOR EDIT\n         ED    FMT@CONV(6),QCOUNT       EDIT THE POSITION IN QUEUE\n         MVC   FM@COUNT(4),FMT@CONV+2   MOVE TO DISPLAY LINE\n         MVC   FM@JNAME,JQEJNAME        MOVE IN JOBNAME\n         MVC   FMT@WORK,=X'402020202020'  PREPARE FOR EDIT\n         LH    R0,JQEJOBNO              LOAD HASP JOBNUMBER\n         LA    R14,C' '                 ASSUME JOB - LEAVE IT BLANK\n          AIF   (&QLEVEL GE 4).FM180\n         LH    R1,=H'10000'             GET RANGE SIZE\n         SR    R0,R1                    IS IT A JOB NUMBER?\n         BNP   FMT$JBNO                 YES\n         LA    R14,C'S'                 ASSUME STC\n         SR    R0,R1                    IS IT A STC NUMBER?\n         BNP   FMT$JBNO                 YES\n         LA    R14,C'T'                 ASSUME TSU\n         SR    R0,R1                    IS IT A TSU NUMBER?\n         BNP   FMT$JBNO                 YES\n         EX    0,*                      THIS BETTER NEVER HAPPEN\nFMT$JBNO AR    R0,R1                    RESTORE JOB NUMBER\n         CVD   R0,FMT@CONV              CONVERT TO DECIMAL\n          AGO   .FM200\n.FM180    ANOP\n         TM    JQEFLAG3,QUEJOB          IS IT A JOB?\n         BZ    FMT$JBNO                 YES\n         BM    *+8                      CONTINUE IF ONLY 1 BIT SET\n         EX    0,*                      THIS BETTER NEVER HAPPEN\n         LA    R14,C'S'                 ASSUME STC\n         TM    JQEFLAG3,QUESTC          IS IT A STC?\n         BO    FMT$JBNO                 YES\n         LA    R14,C'T'                 ASSUME TSU\nFMT$JBNO CVD   R0,FMT@CONV              CONVERT TO DECIMAL\n.FM200    ANOP\n*  DON'T NEED TO PRESET R1 FOR EDMK FAILURE SINCE JES2 WON'T CREATE\n*  JOB 0, STC 0, OR TSU 0.\n         EDMK  FMT@WORK,FMT@CONV+5      EDIT HASP JOBNUMBER\n         BCTR  R1,0                     BACK UP TO BEFORE FIRST DIGIT\n         STC   R14,0(,R1)               SET THE J/S/T\n         MVC   FM@JOBID,FMT@WORK+1      MOVE HASP JOBNUMBER TO SCREEN\n         SR    R0,R0                    CLEAR FOR IC\n         IC    R0,JQEPRIO               LOAD JQE PRIORITY\n          AIF   (&QLEVEL LT 5).FM220\n         LTR   R2,R2                    IS REQUEST FOR JQE OR JOE?\n         BZ    *+8                      JQE - USE JQEPRIO\n         LH    R0,JOEPRIO               JOE - USE NEW STYLE JOE PRTY\n.FM220    ANOP\n         SRL   R0,4                     DIVIDE BY 16\n         CVD   R0,FMT@CONV              CONVERT TO DECIMAL\n         MVC   FMT@WORK(4),=X'40202021' PREPARE FOR EDIT\n         ED    FMT@WORK(4),FMT@CONV+6   EDIT JQE PRIORITY\n         MVC   FM@PRTY,FMT@WORK+1       MOVE JQE PRIORITY TO SCREEN\n*?       STC   R0,FMT@WORK              SAVE FOR UNPK\n*?       HEX   FMT@WORK+2,FMT@WORK,LEN=1,HEXTAB=QHEXTAB\n*?       CLI   FMT@WORK+2,C'0'          LEADING 0?\n*?       BNE   *+8                      NO - OK\n*?       MVI   FMT@WORK+2,C' '          YES - REMOVE IT\n*?       MVC   FM@PRTY,FMT@WORK+2       MOVE JQE PRIORITY TO SCREEN\n         SPACE 1\n         TM    JQEFLAGS,QUEHOLD2        HELD BECAUSE DUP JOB NAME?\n         BNO   *+10                     NO - SKIP\n         MVC   FM@HOLD,=C'DUP'          YES - FLAG IT\n         TM    JQEFLAGS,QUEHOLDA        HOLD ALL?\n         BNO   *+10                     NO\n         MVC   FM@HOLD,=C'ALL'          INDICATE JOB HELD FOR HOLD ALL\n         TM    JQEFLAGS,QUEHOLD1        THIS JOB HELD?\n         BNO   *+10                     NO - SKIP\n         MVC   FM@HOLD,=C'HLD'          YES - INDICATE IT\n         MVC   QCTRAK,JQETRAK           DISK ADDR OF JCT\n          AIF  (&QLEVEL GE 11).FM270\n         TM    QSCFLAG1,QSC1DH          IS THIS \"DH\"?\n         BNO   FMT$NDH                  NO - DON'T FORMAT HELD DS COUNT\n         SR    R0,R0                    CLEAR FOR ICM\n          AIF  (&QLEVEL GE 9).FM240\n         ICM   R0,B'0011',JQEHLDCT      GET HELD DATASET COUNT\n         SRL   R0,4                     SHIFT OUT GARBAGE\n          AGO  .FM260\n.FM240    ANOP ,\n         ICM   R0,B'0111',JQEHDSCT      get held dataset count\n.FM260    ANOP ,\n         MVC   FM@HLCNT,=X'402020202120'\n         CVD   R0,FMT@CONV\n         OI    FMT@CONV+7,X'0F'         REMOVE SIGN\n         ED    FM@HLCNT,FMT@CONV+5\n.FM270    ANOP ,\n         SPACE 1\nFMT$NDH  TM    FM@FLAGS,FM@SLOG         IS THIS \"STATUS SYSLOG\"?\n         BO    FM$RDJCT                 YES - READ THE JCT\n         TM    QSCFLAG1,QSC1PGMR+QSC1TIME+QSC1PCT+QSC1SPC  NEED JCT?\n         BZ    FMT$DONE                 NO - SAVE SOME I/O\nFM$RDJCT L     R3,QCJCTA                ADDR OF IOAREA FOR JCT\n         LR    R1,R3                    PARM FOR READSPC\n         MVC   QCCBID,=C'JCT '          SHOW WHAT WE NEED\n         LR    R0,R9                    -> JQE\n         QCALL READSPC                  READ HASPACE\n         USNGX JCTSTART,R3              DISPLAY PROGRAMMER NAME...\n          AIF   (&QLEVEL LT 4).FM280\n         TM    QSCFLAG1,QSC1PCT         SPOOL percent INSTEAD OF LINES?\n         BO    FM$PCT                   YES - GO READ IOT'S\n.FM280    ANOP\n         TM    QSCFLAG1,QSC1SPC         SPOOL SPACE INSTEAD OF LINES?\n         BO    FM$SPACE                 YES - GO READ IOT'S\n         CLC   =C'O ',FM@QNAME          IS THIS JOB ON OUTPUT QUEUE?\n         BE    FM$NLNES                 YES - DON'T DISPLAY JCT LINES\n          AIF   (&QLEVEL GE 11).FM285\n         CLC   =C'H ',FM@QNAME          is this job on held o/p queue?\n         BE    FM$NLNES                 YES - DON'T DISPLAY JCT LINES\n.FM285    ANOP\n         L     R0,JCTLINES              GET GENERATED LINE COUNT\n         BAL   R14,FMT$LNES             FORMAT IT\n         B     FM$NLNES                 CONTINUE\n          AIF   (&QLEVEL LT 4).FM300\nFM$PCT   LH    R1,JQETGNUM              get number of allocated TG's\n         TM    JQEFLAG5,JQE5XUSD        using extension for TG count?\n         BZ    FM$PCTOK                 no - all set\n         AL    R1,QCJQEXA               Add JQE extension base\n         LH    R1,0(,R1)                Get number of allocated TG's\nFM$PCTOK M     R1-1,=F'10000'           scale for nn.nn%, clear R0\n         L     R14,QCJQTL               -> mstr rec chkpt area\n         D     R0,$TGTOTAL-$SAVEBEG(,R14)  compute percent for this job\n         MVC   FMT@WORK(7),=X'402020214B2020'  PREPARE FOR EDIT\n         CVD   R1,FMT@CONV              CONVERT TO DECIMAL\n         ED    FMT@WORK(7),FMT@CONV+5   PRINT UPDATED LINE COUNT\n         MVC   FM@LINES,FMT@WORK+2      MOVE LINE COUNT TO SCREEN\n         C     R1,=F'0500'              > 5% of the spool?\n         BL    FM$NLNES                 no - ok\n         MVC   FM@ATTR5,=X'1DE8'        yes - set output, bright\n         B     FM$NLNES                 continue\n.FM300    ANOP\n          AIF   (&QLEVEL GE 7).FM320\n***********************************************************************\n*  READ ALL IOT'S AND COUNT UP THE TOTAL NUMBER OF TRACK GROUPS USED  *\n***********************************************************************\nFM$SPACE NI    FM@FLAGS,255-FM@SPIN     HAVEN'T DONE SPIN CHAIN YET\n         XR    R6,R6                    CLEAR ACCUMULATOR\n         MVC   QCTRAK,JCTIOT            DISK ADDR OF FIRST REGULAR IOT\n         L     R5,QCIOTA                ADDR OF IOAREA FOR IOT\n         SPACE 1\nFM$IOTLP LR    R1,R5                    PARM FOR READSPC\n         MVC   QCCBID,=C'IOT '          SHOW WHAT WE NEED\n         LR    R0,R9                    -> JQE\n         QCALL READSPC                  READ HASPACE\n         USNGX IOTSTART,R5\n         TM    IOTFLAG1,IOT1ALOC        IS THIS AN ALLOCATION IOT?\n         BNO   FM$NXIOT                 NO - TRY NEXT IOT\n         LA    R14,IOTTGMAP+TGMAP-TGMDSECT  -> START OF TG MAP\n         LH    R1,QCTGMLEN              GET # OF BYTES IN TG MAP\n         SR    R15,R15                  CLEAR FOR IC\n         SPACE 1\nFM$TG$LP IC    R15,0(,R14)              GET A BYTE OF TG MAP\n         IC    R15,FM#BITB(R15)         GET # OF 1'S IN THAT BYTE\n         AR    R6,R15                   ADD TO ACCUMULATED TOTAL\n         LA    R14,1(,R14)              -> NEXT TG MAP BYTE\n         BCT   R1,FM$TG$LP              PROCESS WHOLE TG MAP\n         SPACE 1\n*---  PREPARE TO PROCESS NEXT IOT                                  ---*\nFM$NXIOT MVC   QCTRAK,IOTIOTTR          DISK ADDR OF NEXT IOT\n         CLC   QCTRAK,=F'0'             ANY MORE IOT'S?\n         BNE   FM$IOTLP                 YES - PROCESS\n         TM    FM@FLAGS,FM@SPIN         DONE SPIN CHAIN YET?\n         BO    FM$GOTTG                 YES - FORMAT COUNT INTO LINE\n         OI    FM@FLAGS,FM@SPIN         INDICATE NOW DOING SPIN CHAIN\n         MVC   QCTRAK,JCTSPIOT          DISK ADDR OF FIRST SPIN IOT\n         CLC   QCTRAK,=F'0'             ANY SPIN IOT'S?\n         BNE   FM$IOTLP                 YES - PROCESS\n         DROPX R5                       IOTSTART\nFM$GOTTG LR    R0,R6                    GET NUMBER OF ALLOCATED TG'S\n          AGO  .FM340\n.FM320    ANOP ,\nFM$SPACE LH    R0,JQETGNUM              get number of allocated TG's\n         TM    JQEFLAG5,JQE5XUSD        using extension for TG count?\n         BZ    FM$TG$OK                 no - all set\n         LR    R14,R0                   yes - copy JQEEXT offset\n         AL    R14,QCJQEXA              Add JQE extension base\n         LH    R0,0(,R14)               Get number of allocated TG's\n.FM340    ANOP ,\nFM$TG$OK BAL   R14,FMT$LNES             FORMAT IT\n         SPACE 2\nFM$NLNES TM    FM@FLAGS,FM@SLOG         IS THIS \"STATUS SYSLOG\"?\n         BO    FM$SLOG1                 YES - FORMAT START DATE/TIME\n         TM    QSCFLAG1,QSC1PGMR        PROGRAMMER NAME REQUESTED?\n         BO    FMT$PGMR                 YES - DISPLAY IT\n         TM    QSCFLAG1,QSC1TIME        INPUT OR OUTPUT TIME REQUESTED?\n         BNO   FMT$DONE                 NO - ALL DONE\nFM$SLOG1 TM    FM@FLAGS,FM@SLOG         IS THIS \"STATUS SYSLOG\"?\n         BNO   FM$DATE                  NO - SKIP\n         LA    R4,JCTXEQON              -> START EXEC TIME\n         MVC   FM@SLID,JCTEXSID         SHOW THIS SYSLOG'S SYSTEM ID\n         B     FM$DATE2                 GO FORMAT START EXEC DATE/TIME\n*---  FORMAT THE INPUT OR OUTPUT DATE (FROM PACKED)\n*  WAS USING JCTCDTOF/JCTCNVOF\nFM$DATE  LA    R4,JCTRDRON              -> TIME/DATE ON READER\n         CLI   FM@QNAME,C'I'            IS THIS AN INPUT QUEUE?\n         BE    FM$DATE2                 YES - OK\n         LA    R4,JCTOUTOF              -> TIME/DATE OFF OUTPUT\n         CLC   =C'OFF',JCTINDEV         from a spool offload device?\n         BNE   FM$DATE2                 no - use \"off output\" date\n         LA    R4,JCTXEQOF              yes - use end exec date\n         CLC   =F'0',JCTXDTOF           but is it there?\n         BNE   FM$DATE2                 yes - use it\n         MVI   FM@DATE-1,C'>'           flag that we're guessing\n         MVI   FM@TIME+8,C'<'           here too\n         LA    R4,JCTXEQON              no (sys crash) - use xeq start\n         CLC   =F'0',JCTXEQON           but is it there?\n         BNE   FM$DATE2                 yes - use it\n         LA    R4,JCTRDRON              no (print file) - use rdr start\nFM$DATE2 QITEM ,,FM@DATE,DATE,4(R4),SKIP=FMT$DONE  format date\n*---  FORMAT THE TIME (FROM BINARY)\n         L     R1,0(,R4)                PICK UP BINARY TIME\n         SR    R0,R0                    CLEAR FOR DIVIDE\n         D     R0,=F'100'               CONVERT TO SECONDS\n         SR    R0,R0                    CLEAR FOR DIVIDE\n         D     R0,=F'60'                R0 = SECONDS, R1 = MINUTES\n         CVD   R0,FMT@CONV\n         OI    FMT@CONV+7,X'0F'         REMOVE SIGN\n         UNPK  FM@TIME+6(2),FMT@CONV\n         MVI   FM@TIME+5,C':'\n         SR    R0,R0                    CLEAR FOR DIVIDE\n         D     R0,=F'60'                R0 = MINUTES, R1 = HOURS\n         CVD   R0,FMT@CONV\n         OI    FMT@CONV+7,X'0F'         REMOVE SIGN\n         UNPK  FM@TIME+3(2),FMT@CONV\n         MVI   FM@TIME+2,C':'\n         CVD   R1,FMT@CONV\n         OI    FMT@CONV+7,X'0F'         REMOVE SIGN\n         UNPK  FM@TIME(2),FMT@CONV\n         B     FMT$DONE                 ALL DONE\nFMT$PGMR MVC   FM@PGMR,JCTPNAME         INSTEAD OF FORM/FCB/UCS/PRINT\n         MVC   FM@PGMR+L'JCTPNAME(FM@OVERL-L'JCTPNAME),QBLANK BLNK REST\n         DROPX R3                       JCTSTART\n         SPACE 2\n*---  SAVE DATA IN ARRAY FOR LINE COMMANDS                         ---*\nFMT$DONE XC    FM@TPTR(LCBELEN),FM@TPTR INIT ARRAY ELEMENT\n         MVI   FM@ADDR1+3,FM@SEL-QDMSG OFFSET OF FIRST INPUT FIELD\n         MVI   FM@ADDR2+3,FM@REMOT-QDMSG OFFSET OF SECOND INPUT FIELD\n         MVC   FM@ID(5),FM@JOBID        JOBID\n         CLI   FM@ID+3,C' '             ONE CHARACTER JOBNUMBER?\n         BNE   *+8                      NO - OK\n         MVI   FM@ID+3,C'0'             YES - MAKE IT TWO CHARACTERS\n         MVC   FM@FLD1(2+8),QBLANK\n         LA    R1,FM@TPTR               -> MY ARRAY ELEMENT\n         QCALL DISPADDX                 ADD LINE TO SCREEN\n         TM    QSCFLAG2,QSC2DJX         IS THE REQUEST FOR A HEX DUMP?\n         BNO   QSTOP                    NO - ALL DONE\n         B     FMHEXJQE                 GO DUMP JQE, AND MAYBE JOE(S)\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*   FORMAT DEVICE NAME SUBROUTINE                                     *\n*                                                                     *\n***********************************************************************\nFMT$DEV  TM    QSCFLAG1,QSC1TIME        INPUT OR OUTPUT TIME REQUESTED?\n         BOR   R7                       YES - JUST RETURN\n         LTR   R2,R2                    JOE?\n         BNZ   FMT$DEV1                 YES\n         CLC   QCLOCAL,FM@DEVID         ANYTHING?\n         BER   R7                       NO - JUST RETURN\n*---  GLA changed the test above to the following:\n*---     CLC   QCLNODE,FM@DEVID         ANYTHING but node num.\n*---  I'm not going to make that change until I understand why.\nFMT$DEV1 OC    FM@DEVID,FM@DEVID        ANYTHING HERE?\n         BZ    FM$NO$XD                 NO - DON'T DISPLAY IT\n         MVC   FM@DEVNM(3),=C'???'      ASSUME CAN'T FIGURE IT OUT\n         TM    QXAUTH,QXSYSP+QXPSWD     GOOD GUY?\n         BZ    FM$NO$XD                 NO - DON'T SHOW HIM HEX DEVID\n*%       UNPK  FM@DEVNM(2*L'FM@DEVID+1),FM@DEVID(L'FM@DEVID+1) SHOW HEX\n*%       TR    FM@DEVNM(2*L'FM@DEVID),QHEXTAB IN CASE ALL ELSE FAILS\n*%       MVI   FM@DEVNM+2*L'FM@DEVID,C' ' KILL FLIP BYTE\n*  IF ALL ELSE FAILS, DISPLAY THE DEVICE TYPE IN HEX\n          AIF   (&QLEVEL GE 4).FM360\n         HEX   FM@DEVNM,FM@DEVID,LEN=2,HEXTAB=QHEXTAB\nFM$NO$XD CLC   FM@DEVID,=X'0F00'        EXTERNAL WRITER?\n         BNE   FM$NXWTR                 NO - SKIP\n          AGO   .FM380\n.FM360    ANOP\n         HEX   FM@DEVNM,FM@DEVID,LEN=3,HEXTAB=QHEXTAB\nFM$NO$XD CLC   FM@DEVID,=X'0F0000'      EXTERNAL WRITER?\n         BE    FM$XWTR                  YES - PROCESS IT\n         TM    FM@DEVID,DCTXFRID X'0F'  SPOOL XFR DEVICE?\n         BNO   FM$NXWTR                 NO - SKIP\n         TM    FM@DEVID,X'40'           IS IT X'40' THRU X'70'?\n         BNO   FM$NXWTR                 NO - SKIP\n*%%%  DO WE NEED TO CHECK FOR INTERRUPTED JOB???\n         SR    R1,R1                    CLEAR FOR IC\n         IC    R1,FM@DEVID              GET LOCAL DEVICE TYPE\n         SRL   R1,4                     RIGHT JUSTIFY\n         SLL   R1,3                     TIMES LENGTH OF A DEVICE ENTRY\n         LA    R1,FM#DEVTB(R1)          -> DEVICE TYPE\n         MVC   FM@DEVNM(7),1(R1)        DEVICE TYPE TO PRINT LINE\n         MVC   FM@DEVNM+3(1),FM@DEVID+2 GET N OF DMPN OR LODN\n         OI    FM@DEVNM+3,X'F0'         make it displayable\n         BR    R7                       DONE - RETURN TO CALLER\n.FM380    ANOP\nFM$XWTR  MVC   FM@DEVNM(7),=C'Ext-Wtr'  YES\n         TM    JOEFLAG,$JOEBUSY         THIS OUTPUT ACTIVE?\n         BNZR  R7                       YES - OK\n         MVC   FM@DEVNM+4(3),=C'Int '   NO - IT MUST HAVE BEEN INT'D\n         BR    R7                       DONE\n*  NOTE THAT IF THE JOB IS ON THE EXTERNAL WRITER OR PRINTING/PUNCHING\n*  AT A REMOTE (AND NOT ALSO ON A REAL LOCAL PRINTER), THE FLAGS\n*  $JOEPRT & $JOEPUN WILL BE OFF.\nFM$NXWTR TM    FM@DEVID,DCTRMTID X'80'  PRINT/PUNCH ON REMOTE DEVICE?\n         BO    FMRMTDV                  YES - SPECIAL FORMAT ROUTINE\n         TM    FM@DEVID,X'40'           IS IT X'40' THRU X'70'?\n         BO    FM$LDEV                  yes - format Lnn.xxn device\n         LTR   R2,R2                    JOE?\n         BZ    FMT$DEV2                 NO - JQE\n         TM    JOEFLAG,$JOEPRT+$JOEPUN  PRINTING OR PUNCHING?\n         BZR   R7                       NO. SKIP.\n         MVC   FM@DEVNM(4),=C'Int '     ASSUME IT WAS $I'D\n         TM    JOEFLAG,$JOEBUSY         BUT WAS IT INTERRUPTED?\n         BZR   R7                       YES - OK\n         B     FMT$DEV3                 SKIP AROUND\n          AIF   (&QLEVEL GE 4).FM400\nFMT$DEV2 TM    JQETYPE,$INPUT           JOB ON INPUT QUEUE?\n         BZR   R7                       NO - JUST RETURN\n          AGO   .FM420\n.FM400    ANOP\nFMT$DEV2 TM    JQETYPE,$XMIT            JOB ON XMIT QUEUE?\n         BO    FMT$XMIT                 YES - SPECIAL HANDLING\n         TM    JQETYPE,$INPUT           JOB ON INPUT QUEUE?\n         BZR   R7                       NO - JUST RETURN\n.FM420    ANOP\nFMT$DEV3 SR    R1,R1                    CLEAR FOR IC\n         IC    R1,FM@DEVID              GET LOCAL DEVICE TYPE\n         SRL   R1,4                     RIGHT JUSTIFY\n         CH    R1,=H'3'                 UNKNOWN DEVICE TYPE?\n         BHR   R7                       YES - LEAVE IT FORMATTED IN HEX\n         SLL   R1,3                     TIMES LENGTH OF A DEVICE ENTRY\n         LA    R1,FM#DEVTB(R1)          -> DEVICE TYPE\n         MVC   FM@DEVNM(7),1(R1)        DEVICE TYPE TO PRINT LINE\n         CLI   FM@DEVID,DCTINRID        INTERNAL READER?\n         BER   R7                       YES - SAY NO MORE\n         SR    R14,R14                  CLEAR FOR IC\n         IC    R14,FM@DEVID+L'FM@DEVID-1  GET DEVICE NUMBER\n         SR    R15,R15                  CLEAR FOR IC\n         IC    R15,0(,R1)               GET LENGTH OF DEVICE NAME\n         LA    R1,FM@DEVNM(R15)         -> NEXT POSITION ON LINE\n         CH    R15,=H'7'                PRINTER?\n         BL    FM$DEVOK                 NO - SKIP\n         CH    R14,=H'9'                PRINTER NUMBER > 9?\n         BNH   FM$DEVOK                 NO - SKIP\n         BCTR  R1,0                     YES - BACK UP THE POINTER...\n         MVC   FM@DEVNM+5(1),FM@DEVNM+6 ... AND MAKE IT 'PRINTR##'\nFM$DEVOK CVD   R14,FMT@CONV             CONVERT DEVICE NUMBER\n         OI    FMT@CONV+7,X'0F'         REMOVE SIGN\n         UNPK  FMT@WORK(2),FMT@CONV     MAKE PRINTABLE\n         MVC   0(1,R1),FMT@WORK+1       ASSUME SINGLE DIGIT\n         CLI   FMT@WORK,C'0'            LEADING 0?\n         BER   R7                       YES - OK AS IS\n         MVC   0(2,R1),FMT@WORK         NO - MOVE BOTH DIGITS OVER\n         BR    R7                       ALL DONE HERE\n          AIF   (&QLEVEL LT 4).FM440\n***********************************************************************\n*   FORMAT JT/JR/ST/SR device types                                   *\n***********************************************************************\nFMT$XMIT TM    JQEFLAGS,QUEBUSY         THIS JOB NOW ON XMITTER?\n         BNZR  R7                       NO - LEAVE IT IT HEX FOR NOW\nFM$LDEV  MVI   FM@DEVNM,C'L'            DEVICE TYPE TO PRINT LINE\n**%%     SR    R14,R14                  CLEAR FOR IC\n**%%     IC    R14,FM@DEVID+L'FM@DEVID-1  GET DEVICE NUMBER\n         LH    R14,FM@DEVID+1           get line number\n         CVD   R14,FMT@CONV             CONVERT DEVICE NUMBER\n         OI    FMT@CONV+7,X'0F'         REMOVE SIGN\n         MVC   FMT@WORK,=X'402020202120'  GET EDIT MASK\n         MVC   FMT@WORK+6(10),QBLANK    CLEAR TRAILER\n         LA    R1,FMT@WORK+5            PRESET SIGNIFICANCE POINTER\n         EDMK  FMT@WORK,FMT@CONV+5      MAKE PRINTABLE\n         SR    R14,R14                  CLEAR FOR IC\n         IC    R14,FM@DEVID             GET LOCAL DEVICE TYPE\n         SRL   R14,4                    RIGHT JUSTIFY\n         SLL   R14,3                    TIMES LENGTH OF A DEVICE ENTRY\n         LA    R14,FM#DEVTB(R14)        -> DEVICE TYPE\n         MVC   FMT@WORK+6(3),4+1(R14)   GET THE '.JT'\n         MVC   FMT@WORK+9(1),FM@DEVID   GET THE TRANSMITTER NUMBER\n         OI    FMT@WORK+9,C'0'          MAKE IT DISPLAYABLE NUMERIC\n         MVC   FM@DEVNM+1(7),0(R1)      LEFT JUSTIFY THE LINE NUMBER\n         BR    R7                       ALL DONE HERE\n.FM440    ANOP\n***********************************************************************\n*   FORMAT REMOTE DEVICE NAME                                         *\n***********************************************************************\n          AIF   (&QLEVEL GE 4).FM460\nFMRMTDV  SR    R14,R14                  CLEAR FOR IC\n         IC    R14,FM@DEVID+1           GET THE REMOTE NUMBER\n          AGO   .FM480\n.FM460    ANOP\nFMRMTDV  LH    R14,FM@DEVID+1           GET THE REMOTE NUMBER\n.FM480    ANOP\n         MVI   FM@DEVNM,C'R'            INDICATE REMOTE\n         CVD   R14,FMT@CONV\n         OI    FMT@CONV+7,X'0F'         REMOVE SIGN\n         UNPK  FM@DEVNM+1(3),FMT@CONV   MAKE REMOTE NUMBER PRINTABLE\n         LA    R1,FM@DEVNM+4            ASSUME 3 DIGITS\n         CLI   FM@DEVNM+1,C'0'          LEADING 0?\n         BNE   *+12                     NO - SKIP\n         MVC   FM@DEVNM+1(3),FM@DEVNM+2 YES - SHIFT IT OVER\n         BCTR  R1,0                     BACK UP WHERE THE DOT GOES\n         CLI   FM@DEVNM+1,C'0'          LEADING 0?\n         BNE   *+12                     NO - SKIP\n         MVC   FM@DEVNM+1(3),FM@DEVNM+2 YES - SHIFT IT OVER\n         BCTR  R1,0                     BACK UP WHERE THE DOT GOES\n         MVI   0(R1),C'.'               PUT IN THE SEPARATOR\n         LTR   R2,R2                    JOE?\n         BZ    FMRMTDV2                 NO - JQE.\n         MVC   1(3,R1),=C'Int '         ASSUME INTERRUPTED\n         TM    JOEFLAG,$JOEBUSY         IS IT ACTIVE NOW?\n         BZR   R7                       NO - IT WAS INTERRUPTED\n         B     FMRMTDV3                 SKIP AROUND\nFMRMTDV2 TM    JQETYPE,$INPUT           JOB ON INPUT QUEUE?\n         BNOR  R7                       NO - JUST RETURN\nFMRMTDV3 SR    R15,R15                  CLEAR FOR IC\n         IC    R15,FM@DEVID             GET THE DEVICE TYPE\n         SRL   R15,3                    RIGHT JUSTIFY IT\n         CH    R15,=Y(3*2+DCTRMTID/8)   UNKNOWN DEVICE TYPE?\n         BHR   R7                       YES - LEAVE IT FORMATTED IN HEX\n         LA    R15,FM#RMDVS-DCTRMTID/8(R15) -> DEVICE TYPE\n         MVC   1(2,R1),0(R15)           MOVE REMOTE DEVICE TYPE\n         MVC   3(1,R1),FM@DEVID         MOVE THE DEVICE NUMBER\n         OI    3(R1),C'0'               MAKE IT PRINTABLE\n         BR    R7                       RETURN TO CALLER\n***********************************************************************\n*                                                                     *\n*   FORMAT LINE COUNT SUBROUTINE                                      *\n*                                                                     *\n***********************************************************************\nFMT$LNES SRDL  R0,32                    # LINES TO R1, CLEAR R0\n         MVC   FMT@WORK,=X'402020202020'  PREPARE FOR EDIT\n         C     R1,=F'100000'            TOO BIG?\n         BL    FMT$NOTK                 NO - SKIP\n         AH    R1,=H'500'               YES - SET TO ROUND\n         D     R1-1,=F'1000'            THEN SCALE IT\n         MVI   FM@LINES+L'FM@LINES-1,C'K' AND SHOW IT\n         C     R1,=F'10000'             STILL TOO BIG?\n         BL    FMT$NOTM                 NO - SKIP\n         AH    R1,=H'500'               YES - SET TO ROUND\n         SR    R0,R0                    CLEAR FOR DIVIDE\n         D     R1-1,=F'1000'            THEN SCALE IT\n         MVI   FM@LINES+L'FM@LINES-1,C'M' AND SHOW IT\nFMT$NOTM CVD   R1,FMT@CONV              CONVERT TO DECIMAL\n         ED    FMT@WORK,FMT@CONV+5      PRINT UPDATED LINE COUNT\n         MVC   FM@LINES(L'FM@LINES-1),FMT@WORK+2  LINE COUNT TO SCREEN\n         MVC   FM@ATTR5,=X'1DE8'        SET OUTPUT, BRIGHT\n         BR    R14                      RETURN TO CALLER\nFMT$NOTK CVD   R1,FMT@CONV              CONVERT TO DECIMAL\n         ED    FMT@WORK,FMT@CONV+5      PRINT UPDATED LINE COUNT\n         MVC   FM@LINES,FMT@WORK+1      MOVE LINE COUNT TO SCREEN\n         BR    R14                      RETURN TO CALLER\n***********************************************************************\n*                                                                     *\n*   TAKE HEX DUMP OF JQE                                              *\n*                                                                     *\n***********************************************************************\nFM$JQE   LH    R1,QLNG1                 get length of first operand\n         LTR   R1,R1                    any operand?\n         BP    FM$JQE$1                 yes - continue\nFM$JXERR QTILT '*** Operand required ***',OPTIONS=REPROMPT\nFM$PACK  PACK  QNUMWORK(4+1),FMT@HEXW(*-*)  << executed >>\nFM$JQE$1 MVC   FMT@HEXW,QPARM1          copy the parm\n         TR    FMT@HEXW(8),FMHEXTAB     make it halfway hex\n*  Note that length in R1 is not decremented for execute, but to pack\n*  hex, it's necessary to do an extra byte, so we're in great shape.\n         EX    R1,FM$PACK              PACK QNUMWORK(4+1),FMT@HEXW(*-*)\n         L     R9,QNUMWORK              pick up JQE offset\n         AL    R9,QCJQTA                -> JQE\n*---  \"XJ\" subcommand enters here\nFMHEXJQE LR    R3,R2                    SAVE ENTRY CODE\n         MVC   QDMSG(FM#JQEL),FM#JQE    '   HEX DUMP OF JQE AT OFFSET'\n         LR    R0,R9                    COPY JQE ADDR\n         SL    R0,QCJQTA                SUBTRACT BASE\n         ST    R0,FMT@CONV              STORE FOR UNPACK\n         HEX   QDMSG+31,FMT@CONV+1,LEN=3,HEXTAB=QHEXTAB\n         ST    R9,FMT@CONV              STORE FOR UNPACK\n         HEX   QDMSG+51,FMT@CONV+1,LEN=3,HEXTAB=QHEXTAB,BYTE=C')'\n         CLI   QCODE,100                is this the JQE subcommand?\n         BNE   FM$JQE$2                 no - use as is\n         MVC   QDHLINE(FM#JQEL-4),QDMSG+2  move detail hdr to main hdr\n         MVC   QDMSG,QBLANK             and clear line buffer\n         B     FM$JQE$3                 and don't add any line here\nFM$JQE$2 MVI   QDATRNUM+1,2             NUMBER OF ATTR BYTES\n         BAL   R14,QADDLINE             PUT HEADER TO SCREEN BUFFER\nFM$JQE$3 SR    R0,R0                    DISPLAY OFFSET\n         LR    R1,R9                    GET ADDRESS TO DUMP\n*        LA    R2,JQELNGTH              GET LENGTH TO DUMP\n         LH    R2,QCJQELEN              GET LENGTH TO DUMP\n         QCALL HEXFMT                   CONVERT JQE TO HEX\n         CLI   QCODE,100                is this the JQE subcommand?\n         BE    QSTOP                    yes - all done\n         MVI   QDMSG,C'-'               MAKE A LINE ...\n         MVC   QDMSG+1(L'QDMSG-1),QDMSG ... OF DASHES\n         BAL   R14,QADDLINE             ADD DASHES LINE\n         LTR   R3,R3                    JQE OR JOE?\n         BZ    QSTOP                    JQE - ALL DONE\n         B     FMHEXJOE                 skip \"JOE\" subcommand code\n***********************************************************************\n*                                                                     *\n*   TAKE HEX DUMP OF JOES                                             *\n*                                                                     *\n***********************************************************************\nFM$JOE   LH    R1,QLNG1                 get length of first operand\n         LTR   R1,R1                    any operand?\n         BNP   FM$JXERR                 no - error\n         MVC   FMT@HEXW,QPARM1          copy the parm\n         TR    FMT@HEXW(8),FMHEXTAB     make it halfway hex\n*  Note that length in R1 is not decremented for execute, but to pack\n*  hex, it's necessary to do an extra byte, so we're in great shape.\n         EX    R1,FM$PACK              PACK QNUMWORK(4+1),FMT@HEXW(*-*)\n         L     R8,QNUMWORK              pick up JOE offset\n         AL    R8,QCJOTA                -> JOE\nFMHEXJOE MVC   QDMSG(FM#JOEL),FM#JOE    '   HEX DUMP OF WORK JOE AT ..'\n         LR    R0,R8                    COPY WORK JOE ADDR\n         SL    R0,QCJOTA                SUBTRACT BASE\n         ST    R0,FMT@CONV              STORE FOR UNPACK\n         HEX   QDMSG+36,FMT@CONV+1,LEN=3,HEXTAB=QHEXTAB\n         ST    R8,FMT@CONV              STORE FOR UNPACK\n         HEX   QDMSG+56,FMT@CONV+1,LEN=3,HEXTAB=QHEXTAB,BYTE=C')'\n         CLI   QCODE,104                is this the JOE subcommand?\n         BNE   FM$JOE$2                 no - use as is\n         MVC   QDHLINE(17-2),QDMSG+2    move detail hdr to main hdr\n         MVC   QDHLINE(FM#JOEL-17-5-2),QDMSG+22  leaving out 'WORK '\n         MVC   QDMSG,QBLANK             and clear line buffer\n         B     FM$JOE$3                 and don't add any line here\nFM$JOE$2 MVI   QDATRNUM+1,2             NUMBER OF ATTR BYTES\n         BAL   R14,QADDLINE             PUT HEADER TO SCREEN BUFFER\nFM$JOE$3 SR    R0,R0                    DISPLAY OFFSET\n         LR    R1,R8                    GET ADDRESS TO DUMP\n         LA    R2,JOE1END-JOEDSECT      GET LENGTH TO DUMP\n         QCALL HEXFMT                   CONVERT JQE TO HEX\n         CLI   QCODE,104                is this the JOE subcommand?\n         BE    QSTOP                    yes - all done\n         MVI   QDMSG,C'-'               MAKE A LINE ...\n         MVC   QDMSG+1(L'QDMSG-1),QDMSG ... OF DASHES\n         BAL   R14,QADDLINE             ADD DASHES LINE\n         SPACE 1\n         QNEXT R6,JOECHAR,NONE=FM$CHKPT GET OFFSET OF CHAR JOE\n         ST    R6,FMT@CONV              STORE FOR UNPACK\n         A     R6,QCJOTA                ADD TO BASE\n         MVC   QDMSG(FM#JOEL),FM#JOE    '   HEX DUMP OF WORK JOE AT ..'\n         MVC   QDMSG+17(4),=C'Char'     '   HEX DUMP OF CHAR JOE AT ..'\n         HEX   QDMSG+36,FMT@CONV+1,LEN=3,HEXTAB=QHEXTAB\n         ST    R6,FMT@CONV              STORE FOR UNPACK\n         HEX   QDMSG+56,FMT@CONV+1,LEN=3,HEXTAB=QHEXTAB,BYTE=C')'\n         MVI   QDATRNUM+1,2             NUMBER OF ATTR BYTES\n         BAL   R14,QADDLINE             PUT HEADER TO SCREEN BUFFER\n         SR    R0,R0                    DISPLAY OFFSET\n         LR    R1,R6                    GET ADDRESS TO DUMP\n         LA    R2,JOE2END-JOEDSECT      GET LENGTH TO DUMP\n         QCALL HEXFMT                   CONVERT JQE TO HEX\n         MVI   QDMSG,C'-'               MAKE A LINE ...\n         MVC   QDMSG+1(L'QDMSG-1),QDMSG ... OF DASHES\n         BAL   R14,QADDLINE             ADD DASHES LINE\n         SPACE 1\n          AIF   (&QLEVEL GT 4).FM500\n         SPACE 2\nFM$CHKPT QNEXT R6,JOECKPT,NONE=QSTOP    GET OFFSET OF CKPT JOE\n         ST    R6,FMT@CONV              STORE FOR UNPACK\n         A     R6,QCJOTA                ADD TO BASE\n         MVC   QDMSG(FM#JOEL),FM#JOE    '   HEX DUMP OF WORK JOE AT ..'\n         MVC   QDMSG+17(4),=C'Ckpt'     '   HEX DUMP OF CKPT JOE AT ..'\n         HEX   QDMSG+36,FMT@CONV+1,LEN=3,HEXTAB=QHEXTAB\n         MVI   QDATRNUM+1,2             NUMBER OF ATTR BYTES\n         BAL   R14,QADDLINE             PUT HEADER TO SCREEN BUFFER\n         SR    R0,R0                    DISPLAY OFFSET\n         LR    R1,R6                    GET ADDRESS TO DUMP\n         LA    R2,JOE3END-JOEDSECT      GET LENGTH TO DUMP\n         QCALL HEXFMT                   CONVERT JQE TO HEX\n          AGO   .FM520\n.FM500    ANOP\n         SPACE 2\nFM$CHKPT TM    JOEFLAG,$JOECKV          IS THE CKPT VALID?\n         BZ    QSTOP                    NO - ALL DONE\n         MVC   QDMSG(FM#CKPTL),FM#CKPT  '   HEX DUMP OF CHK AT MTTR ..'\n         HEX   QDMSG+29,JOECPADR,HEXTAB=QHEXTAB\n         MVI   QDATRNUM+1,2             NUMBER OF ATTR BYTES\n         BAL   R14,QADDLINE             PUT HEADER TO SCREEN BUFFER\n         MVC   QCTRAK,JOECPADR          DISK ADDR OF CHK\n         L     R5,QCBLKA                -> HASPACE BUFFER AREA\n         LR    R1,R5                    PARM FOR READSPC\n         MVC   QCCBID,=C'CHK '          SHOW WHAT WE NEED\n         LR    R0,R9                    -> JQE\n         QCALL READSPC                  READ HASPACE\n         LA    R0,BUFSTART-BUFDSECT     DISPLAY OFFSET\n         LR    R1,R5                    GET ADDRESS TO DUMP\n         L     R15,QCDECB2              -> HASPACE DECB\n         LH    R2,6(,R15)               GET LENGTH TO DUMP ($BUFSIZE)\n         QCALL HEXFMT                   CONVERT JQE TO HEX\n.FM520    ANOP\n         MVI   QDMSG,C'-'               MAKE A LINE ...\n         MVC   QDMSG+1(L'QDMSG-1),QDMSG ... OF DASHES\n         BAL   R14,QADDLINE             ADD DASHES LINE\n         B     QSTOP                    ALL DONE\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*   MISCELLANY                                                        *\n*                                                                     *\n***********************************************************************\n         LTORG\n         SPACE 1\nFM#PNHDR DC    CL(FM@OVERL)'Programmer Name'\n         SPACE 1\nFM#JQE   DC    X'1DE8',C'   Hex dump of JQE at offset xxxxxx in JQT (ad$\n               dr xxxxxx)',X'1D60'\nFM#JQEL  EQU   *-FM#JQE\n         SPACE 1\nFM#JOE   DC    X'1DE8',C'   Hex dump of Work JOE at offset xxxxxx in JO$\n               T (addr xxxxxx)',X'1D60'\nFM#JOEL  EQU   *-FM#JOE\n         SPACE 1\n          AIF   (&QLEVEL LT 5).FM540\nFM#CKPT  DC    X'1DE8',C'   Hex dump of CHK at MTTR xxxxxxxx ',X'1D60'\nFM#CKPTL EQU   *-FM#CKPT\n.FM540    ANOP\n         SPACE 1\nFMTMISC  DC    C'Purg'                  PURGE QUEUE\n         DC    C'Hcpy'                  $HARDCPY  - SHOULD NEVER SHOW\n         DC    C'Outp'                  $OUTPUT   - AWAITING OUTPUT\n          AIF   (&QLEVEL GT 6).FM560\n          AIF   (&QLEVEL LT 4).FM560\n         DC    C'Dump'                  $DUMPQ\n.FM560    ANOP\nFM#RECV  DC    C'Recv'                  $RECEIVE\n         DC    C'Setu'                  $SETUP\nFM#XMIT  DC    C'Xmit'                  $XMIT\n         DC    C'Rdr '                  $INPUT\n         DC    C'I * '                  $XEQ      - CONVERTER\n          AIF   (&QLEVEL GE 4).FM580\n         DC    C'Dmy '                  $DUMMY\n.FM580    ANOP\n         SPACE 2\n*---  SEE DCTDEVID\nFM#DEVTB DC    AL1(6),C'Intrdr '\n         DC    AL1(6),C'Reader '\n         DC    AL1(7),C'Printer'\n         DC    AL1(5),C'Punch  '\n          AIF   (&QLEVEL LT 4).FMDEV1\n         DC    AL1(3),C'Dmpn.JT'\n         DC    AL1(3),C'Lodn.JR'\n         DC    AL1(3),C'Dmpn.ST'\n         DC    AL1(3),C'Lodn.SR'\n.FMDEV1   ANOP\nFM#RMDVS DC    C'**'\n         DC    C'Rd'\n         DC    C'Pr'\n         DC    C'Pu'\n         SPACE 2\nFMHEXTAB EQU   *-C'A'\n         DC    X'0A0B0C0D0E0F'\n         DC    (C'0'-C'F'-1)X'0F'       filler\n         DC    X'00010203040506070809'\n         SPACE 2\n*  TABLE OF NUMBER OF BITS IN A BYTE - SEE KNBITB IN HASPMISC\nFM#BITB  DC    AL1(0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4)\n         DC    AL1(1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5)\n         DC    AL1(1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5)\n         DC    AL1(2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6)\n         DC    AL1(1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5)\n         DC    AL1(2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6)\n         DC    AL1(2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6)\n         DC    AL1(3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7)\n         DC    AL1(1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5)\n         DC    AL1(2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6)\n         DC    AL1(2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6)\n         DC    AL1(3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7)\n         DC    AL1(2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6)\n         DC    AL1(3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7)\n         DC    AL1(3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7)\n         DC    AL1(4,5,5,6,5,6,6,7,5,6,6,7,6,7,7,8)\n         SPACE 2\n         QITEM GEN                      gen qitem table\n         SPACE 2\nWORK     DSECT\n         ORG   WORK+72                  SKIP OVER SAVE AREA\n         SPACE 1\nFM@FLAGS DS    B\nFM@SLOG  EQU   X'80'                    LINE IS FOR \"STATUS SYSLOG\"\nFM@SPIN  EQU   X'40'                    NOW RUNNING DOWN SPIN IOT CHAIN\n         SPACE 1\n*M@TPTR  DS    A                        LCBTPTR\n*M@ADDR1 DS    A                        LCBADDR1\n*M@ADDR2 DS    A                        LCBADDR2\n*M@ID    DS    CL6                      LCBID (JOBID)\n*M@FLD1  DS    CL2                      LCBFLD1\n*M@FLD2  DS    CL8                      LCBFLD2\n*        DS    CL4                      patch space\n         QLCB  PREFIX=FM@\n         SPACE 1\nFM@WORKL EQU   *-WORK                   LENGTH OF LOCAL WORK AREA\n          AIF   (&QLEVEL GE 4).FMDEV2\nFM@DEVID DS    H\n          AGO   .FMDEV3\n.FMDEV2   ANOP\n         DS    0H,X                     ALIGNMENT\nFM@DEVID DS    0XL3,X,H\n.FMDEV3   ANOP\nFMT@WORK DS    CL6,CL10                 CONVERT OUTPUT WORKAREA\nFMT@CONV DS    0D                       CONVERT WORK DOUBLEWORD\nFMT@HEXW DS    CL32                     HEX WORK AREA\nFM@OUTGP DS    CL20                     outgrp work area\n         SPACE 3\n         QCOMMON\n         ORG   QDMSG\nFM@CLEAR DS    0CL80                    FORMAT FOR QUEUE RECORDS\nFM@ATTR1 DS    XL2                      SF, ATTR\nFM@SEL   DS    CL2                      INPUT FIELD\nFM@ATTR2 DS    XL2                      SF, ATTR\nFM@QNAME DS    C                        NAME OF QUEUE (I,O,TSU,STC,H-O)\n         DS    C\nFQUEUE   DS    CL2                      CLASS NAME (IF FM@QNAME=I OR O)\n         DS    C\nFM@COUNT DS    CL4                      POSITION IN QUEUE\n         DS    C\nFM@JNAME DS    CL8                      JOBNAME\nFM@ATTR3 DS    XL2                      SF, ATTR\nFM@JOBID DS    CL5                      JES2 JOB NUMBER\nFM@ATTR4 DS    XL2                      SF, ATTR\nFM@PRTY  DS    CL3                      JOB PRIORITY\nFM@ATTR5 DS    XL2                      SF, ATTR\nFM@LINES DS    CL5                      NUMBER OF OUTPUT LINES\nFM@ATTR6 DS    XL2                      SF, ATTR\nFM@SYSID DS    CL4                      SYSTEM ID\n         DS    C\nFM@HOLD  DS    CL3                      JOB HOLD STATUS\n         DS    C\nFM@OVER  EQU   *\nFM@PGMR  DS    CL20                     PROGRAMMER NAME (DA/DS/DT)\n         ORG   FM@OVER                  BACK AGAIN\nFM@DATE  DS    CL7                      INPUT DATE\n         DS    CL2\nFM@TIME  DS    CL5                      INPUT TIME\n         DS    CL2\nFM@HLCNT DS    CL6\n         ORG   FM@HLCNT+2\nFM@SLID  DS    CL4\n         DS    C\n         ORG   FM@OVER                  BACK AGAIN\nFM@FORM  DS    CL4                      FORM NAME\n         DS    C\nFM@WTRNM DS    CL8                      WRITERNAME (OR USERID)\n         ORG   FM@WTRNM                 OVERLAY WTRNAME OVER FCB/UCS\nFM@FCB   DS    CL4                      FCB NAME\n         DS    C\nFM@UCS   DS    CL4                      UCS NAME\n         DS    C\nFM@DEVNM DS    CL8                      PRINTERN OR RNNN.PRN\n*  THE LAST OVERLAY MUST BE THE LONGEST (CAN'T DO ORG TO END)\nFM@OVERL EQU   *-FM@OVER                LENGTH OF OVERLAY SECTION\nFM@ATTR7 DS    XL2                      SF, ATTR\nFM@FLASH DS    0CL4                     FORMS FLASH\nFM@USER  DS    0CL8                     userid\nFM@WTRNX DS    0CL8                     ALTERNAME FIELD FOR WTRNAME\nFM@REMOT DS    CL8                      REMOTE JOB (RJE)\n         SPACE 3\n         DROPX R9,R8,R13                JQEDSECT, JOEDSECT, WORK\n         SPACE 3\nFORMAT   CSECT                          RESUME\n         SPACE 3\n         PRINT &@@QDOC\n         SPACE 2\n         Q$JCT\n         Q$JOE\n         Q$JQE\n         Q$DCT\n         Q$IOT\n         Q$TGM\n         Q$CHK\n         Q$HCT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "Q#FM@": {"ttr": 7428, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05:\\x00\\x00\\x00\\x82#/\\x00\\x903/\\x029\\x04`\\x02\\x10\\x03\\x9c\\xc5\\xe2\\xc3\\xc8\\xc9\\xd5\\xc4@@@'", "ispf": {"version": "05.58", "flags": 0, "createdate": "1982-08-20T00:00:00", "modifydate": "1990-11-28T02:39:00", "lines": 1120, "newlines": 528, "modlines": 924, "user": "ESCHIND"}, "text": "         TITLE '--- QUEUE--FORMAT -- JQE AND JOE FORMAT ROUTINES ---'\n*---------------------------------------------------------------------*\n*                                                                     *\n*   FORMAT - generate a display line for selected job                 *\n*                                                                     *\n*   Entry - R9 = JQE address                                          *\n*           R8 = JOE address                                          *\n*           R1 = 0 --> Display JQE                                    *\n*              = 4 --> Display JOE                                    *\n*                                                                     *\n*   Updates:                                                          *\n*      28Nov90  EMS  Update for SP410                                 *\n*      23May90  LDW  Add support for USERID operand                   *\n*                    Fix some other bugs in optional displays         *\n*      17Mar90  LDW  Correct display of OFFn.xx device type           *\n*      30Dec89  LDW  For date/time display, if job is from offload    *\n*                       device, try to find some other date stamp     *\n*                       and display it (flagged with '?') instead of  *\n*                       the \"off output\" date/time (which is the      *\n*                       reload time)                                  *\n*      23Nov89  LDW  Remove conditional assembly around Qxxx macros   *\n*                    Remove prereq macro Q$PDDB                       *\n*      09Jul89  LDW  Support spool percent display for jobs           *\n*      22Mar89  EMS  Update for SP311                                 *\n*      30May88  LDW  Add JQE & JOE subcommands                        *\n*      22Jul87  LDW  Fix for TG num used being in JQE extension       *\n*      19Jul87  EMS  Implement size operand for 1.3.6                 *\n*      15Jun87  EMS  update to use QITEM macro for date formatting    *\n*      15Feb87  LDW  Fix for 1.3.6 QUEUE type display (thanks, Doron) *\n*      25Jan87  LDW  Pass READSPC the JQE addr in case of CB ID error *\n*      17Jan87  LDW  Misc cleanup                                     *\n*      04Jan87  LDW  Don't look at $TGM for SP136                     *\n*                    Use QCJQELEN instead of JQELNGTH                 *\n*      14Dec86  LDW  Fix minor bug in previous update                 *\n*      29NOV86  LDW  Use DATEFMT subroutine                           *\n*                    Eliminate use of LC macro                        *\n*      05OCT86  LDW  SUPPORT QSC3WTRI                                 *\n*      03/31/86 LDW  RE-DESIGN 3278-5 SUPPORT (THIRD TRY!)            *\n*      02/23/86 LDW  DISPLAY OUTPUT PRIORITY CORRECTLY FOR SP133      *\n*                    HAVE \"XJ\" DISPLAY CKPTAREA ADDR OF JQE & JOE     *\n*                    SIMPLIFY STD FORMS CHECK                         *\n*      10/14/85 LDW  ADD SP133 CODE TO READ CHK FOR JOBS ON DEVICES   *\n*      02/07/85 EMS  ADD ASM TIME OPTION FOR DEFAULT STD FORM         *\n*      12/05/84 LDW  USE DIFFERENT HEADER LINE IF DI/AI/HI            *\n*                    FIX MINOR BUG THAT INCORRECTLY CAUSED 'STATUS    *\n*                       SYSLOG' DISPLAY FORMAT TO BE USED SOMETIMES   *\n*                       FOR OTHER THAN SYSLOG                         *\n*      08/30/84 LDW  USE HEX MACRO & QHEXTAB                          *\n*                    FIX BUG IN 'CHK' DISPLAY                         *\n*      07/24/84 LDW  DISPLAY SYSTEM AFFINITY FOR INPUT JOBS IN THE    *\n*                       'FORM/UCS,ETC' POSITION (IF NOT S=ALL)        *\n*      06/11/84 LDW  FIX FOR PRINTER# > 9                             *\n*      05/10/84 LDW  DISPLAY LNN.JTN DEVICE TYPES CORRECTLY           *\n*      04/12/84 LDW  JCTDSECT -> JCTSTART, IOTDSECT -> IOTSTART       *\n*                    FIX MINOR BUG IN QNAME DISPLAYED FOR STC/TSU     *\n*                    FIX BUG IN HEX DUMP OF WORK AND CHAR JOES        *\n*                    PRELIMINARY SP133 SUPPORT                        *\n*      01/19/84 LDW  FIX BUG IN PROCESSING LINE CMD FOR JOBNUM < 10   *\n*      12/20/83 LDW  ADD SUPPORT FOR 'SPACE' KEYWORD TO DISPLAY       *\n*                       SPOOL SPACE CURRENTLY ALLOCATED TO JOBS       *\n*      11/03/83 LDW  FIX 06/21/83 UPDATE FOR NON-SP                   *\n*      07/20/83 LDW  CLEAR R0 BEFORE DIVIDE FOR 'M' LINES             *\n*      07/19/83 LDW  DISPLAY SPECIAL INFO FOR SYSLOG IF \"STATUS\"      *\n*                    CHANGE USING/DROP TO USNGX/DROPX                 *\n*      06/21/83 LDW  FIGURE LINES REMAINING CORRECTLY                 *\n*      05/09/83 LDW  USE CORRECT JOE LENGTHS FOR \"XJ\"                 *\n*                    FIX FOR DEVICE NUMBER FOR SP                     *\n*      03/01/83 LDW  ADD JQE AND JOE OFFSET TO \"XJ\"                   *\n*      02/25/83 LDW  ADD SUPPORT FOR LINE COMMANDS                    *\n*      02/09/83 LDW  USE HEXFMT SUBROUTINE TO SUPPORT \"XJ\" SUBCOMMAND *\n*                    REMOVE QSC1DHX TESTS (NO LONGER NEEDED, SINCE    *\n*                       XHO WAS RENAMED TO DHX, AND \"DHX\" IS NOW      *\n*                       SUPPORTED AS THE \"ALL\" OPERAND OF \"DH\")       *\n*                    ADD HELD DS COUNT TO \"DH\" DISPLAY                *\n*                    CHECK NEW FLAG QSC2DJX INSTEAD OF QSUBNAME       *\n*      02/03/83 LDW  ADD SUPPORT FOR DUMPER AND LOADER DEVICE TYPES   *\n*                    PUT IN CHECK FOR UNKNOWN DEVICE TYPE             *\n*      02/02/83 LDW  DISPLAY DESTINATION NODE INSTEAD OF PRINT NODE   *\n*                       FOR JOBS ON THE 'XMIT' QUEUE                  *\n*      01/25/83 LDW  PUT IN 'S' OR 'T' INDICATOR FOR SP JOBNUMBERS    *\n*                    CORRECT Q NAMES FOR SP                           *\n*                    SET CLASS NAME FROM QCLSNAME INSTEAD OF QCLASS   *\n*      01/19/83 LDW  USE QVSYSID TO POINT TO SYSTEM ID TABLE          *\n*      01/10/83 LDW  REMOVE ALL CODE TO HANDLE TTY TYPE TERMINALS     *\n*                       (NOW DONE IN \"DISPLAY\")                       *\n*                    PUT IN BETTER COLUMN HEADER FOR \"XJ\"             *\n*      01/04/83 LDW  ADJUST FOR MODIFIED $JQT MACRO                   *\n*                    SP SUPPORT                                       *\n*                    DISPLAY HELD OUTPUT AS 'HOUT' INSTEAD OF 'H-O'   *\n*      11/20/82 LDW  SQUEEZE OUT ATTR BYTES IF NOT ON A 3270 TERMINAL *\n*      11/17/82 LDW  JUGGLE OUTPUT FIELDS TO PROVIDE FOR INPUT FIELD, *\n*                       HIGH INTENSITY LINE COUNT IF > 99K, HIGH      *\n*                       INTENSITY JOB NUMBER, LONGER CLASSNAME IF SP3 *\n*                    CHANGE 'RJE ID' IN HEADER TO 'NJE/RJE'           *\n*                    SUPPORT 'TIME' FOR JOBS ON OUTPUT QUEUE          *\n*                    CHANGE HEADER AND SOME OTHER DATA TO LOWER CASE  *\n*                    MISCELLANEOUS OTHER MINOR RELATED CHANGES        *\n*      11/15/82 LDW  CORRECT FOR FREE JQE'S ON PURGE QUEUE            *\n*      11/02/82 LDW  FIX FOR DOT MISSING IN \"RNN.RDN\"                 *\n*      10/21/82 LDW  CHANGE \"HO\" AND \"XHO\" TO \"DH\" AND \"DHX\"          *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 3\nFORMAT   QSTART  Q7,WORKLEN=FM@WORKL\n         USNGX WORK,R13                 BASE FOR LOCAL WORK AREA\n         USNGX JQEDSECT,R9              BASE REG FOR JQE DSECT\n         USNGX JOEDSECT,R8              BASE REG FOR JOE DSECT\n         CLI   QCODE,100                JQE subcommand?\n         BE    FM$JQE                   yes - process it\n         CLI   QCODE,104                JOE subcommand?\n         BE    FM$JOE                   yes - process it\n         MVC   QDLCTBL,=V(PA#LC#FM)     SET ADDR OF LINE COMMANDS TABLE\n*        MVI   QDATRNUM+1,2             ASSUME 2 ATTR BYTES IN LINE\n         MVC   FM@ATTR1,=X'1DC8'        SET INPUT, BRIGHT\n         MVC   FM@ATTR2,=X'1D60'        SET OUTPUT, NORMAL\n         MVI   QDATRNUM+1,7             BUT NOW 7 ATTR BYTES IN LINE\n         MVC   FM@ATTR3,=X'1DE8'        SET OUTPUT, BRIGHT\n         MVC   FM@ATTR4,=X'1D60'        SET OUTPUT, NORMAL\n         MVC   FM@ATTR5,=X'1D60'        SET OUTPUT, NORMAL\n         MVC   FM@ATTR6,=X'1D60'        SET OUTPUT, NORMAL\n         MVC   FM@ATTR7,=X'1DC8'        SET INPUT, BRIGHT\n***********************************************************************\n*                                                                     *\n*   BRANCH TO PROPER ROUTINE                                          *\n*                                                                     *\n***********************************************************************\n         LR    R2,R1                    SAVE ENTRY CODE\n         QITEM RESET,PREFIX=FM          init for qitem calls\n         QCALL DISP80                   SWITCH TO 3278-2 MODE IF 3278-5\n         MVC   QDHLINE,=CL80'   Queue  Pos Jobname   Job# Pri Lines Exe$\n               c Hld Form Fcb  Ucs  Device   Nje/Rje'\n*%%%  PROBABLY SHOULD HAVE A SPECIAL HEADER LINE IF \"STATUS SYSLOG\"\n*---  If user wants TIME, USERID, and WRITER, can't do it, so reset\n*---  TIME if he asked for all 3.\n         TM    QSCFLAG1,QSC1TIME        TIME requested?\n         BZ    FM$NOT3                  no - skip\n         TM    QSCFLAG3,QSC3USER+QSC3WTRI  USER and WRITER requested?\n         BNO   FM$NOT3                  no - skip\n         NI    QSCFLAG1,255-QSC1TIME    all 3, so reset TIME\nFM$NOT3  EQU   *\n         TM    QSCFLAG1,QSC1SPC         FMT SPOOL SPC INSTEAD OF LINES?\n         BNO   *+10                     NO - SKIP\n         MVC   QDHLINE+FM@LINES-5-FM@CLEAR(5),=C'TGnum'\n         TM    QSCFLAG1,QSC1PCT         FMT SPOOL pct INSTEAD OF LINES?\n         BNO   *+10                     NO - SKIP\n         MVC   QDHLINE+FM@LINES-5-FM@CLEAR(5),=C' Pct '\n         TM    QSCFLAG1,QSC1TIME        FORMAT INPUT OR OUTPUT TIME?\n         BNO   *+8                      NO - SKIP\n         NI    QSCFLAG1,255-QSC1PGMR    YES - DON'T TRY FOR PGMR NAME\n         TM    QSCFLAG1,QSC1PGMR        FORMAT PROGRAMMER NAME?\n         BNO   FMT$STD1                 NO - SKIP\n         MVC   QDHLINE+FM@OVER-6-FM@CLEAR(FM@OVERL),FM#PNHDR 'PGMR NM'\n         B     FMT$STD2                 CONTINUE\nFMT$STD1 TM    QSCFLAG1,QSC1TIME+QSC1DH ANY OTHER SPECIAL REQUESTS?\n         BNZ   *+12                     YES - PROCESS\n         TM    QSCFLAG2,QSC2DI          ANY OTHER SPECIAL REQUESTS?\n         BZ    FMT$STD2                 NO - CONTINUE\n         MVC   QDHLINE+FM@OVER-6-FM@CLEAR(FM@OVERL),QBLANK CLEAR CHARS\n         TM    QSCFLAG1,QSC1TIME        FORMAT INPUT OR OUTPUT TIME?\n         BNO   *+10                     NO - SKIP\n         MVC   QDHLINE+FM@OVER-6-FM@CLEAR(15),=C' Date      Time'\n         TM    QSCFLAG1,QSC1DH          IS THIS \"DH\"?\n         BNO   *+10                     NO - SKIP\n         MVC   QDHLINE+FM@OVER-6-FM@CLEAR+14+1+1(9),=C'Held DS #'\n         TM    QSCFLAG2,QSC2DI          IS THIS \"DI\"?\n         BNO   *+10                     NO - SKIP\n         MVC   QDHLINE+FM@OVER-6-FM@CLEAR(6),=C'SysAff'\nFMT$STD2 TM    QSCFLAG3,QSC3FLSH        WANT FORM FLASH?\n         BNO   *+10                     NO - ALL SET AS IS\n         MVC   QDHLINE+FM@FLASH-7-FM@CLEAR(8),=CL8'Flash' YES - SET IT\n         TM    QSCFLAG3,QSC3USER        WANT userid?\n         BNO   *+10                     NO - ALL SET AS IS\n         MVC   QDHLINE+FM@USER-7-FM@CLEAR(8),=CL8'Userid' YES - SET IT\n         TM    QSCFLAG3,QSC3WTRI        WANT WRITER NAME?\n         BNO   FMT$STD3                 NO - ALL SET AS IS\n         TM    QSCFLAG1,QSC1TIME        FORMAT INPUT OR OUTPUT TIME?\n         BO    FMT$WTR                  YES - PUT WTRNAME IN RJE/NJE\n         MVC   QDHLINE+FM@WTRNM-6-FM@CLEAR(8),=C'Wtr/User'  SET IT UP\n         B     FMT$STD3                 CONTINUE\nFMT$WTR  NI    QSCFLAG3,255-QSC3FLSH    RESET \"SHOW FLASH\"\n         MVC   QDHLINE+FM@WTRNX-7-FM@CLEAR(8),=C'Wtr/User'  SET IT UP\nFMT$STD3 MVC   FQUEUE,QCLSNAME          CLASS NAME\n         CLI   QCLASS,12                IS THIS A MISC QUEUE?\n         BNE   FMT$NORM                 NO - LEAVE IT\n         S     R4,QCJQHEAD              OFFSET * $JQHEADL OF QUEUE HDR\n          AIF   (&QLEVEL GE 4).FM01\n         AR    R4,R4                    MISC DESCRIPTIONS ARE 4 CHARS\n.FM01     ANOP\n         LA    R4,FMTMISC(R4)           -> 4 CHAR DESCRIPTION\n         MVC   FM@QNAME(4),0(R4)        MOVE IN MISC DESC.\n         CLC   =C'RDR',FM@QNAME         READING?\n         BE    FMREADNG                 YES - NO RJE ID AVAILABLE YET\nFMT$NORM TM    QSCFLAG3,QSC3FLSH        WANT FORMS FLASH?\n         BNZ   FMREADNG                 YES - DON'T FORMAT REMOTE ID\n          AIF   (&QLEVEL LT 4 AND NOT &QNJE).FM02\n         LH    R0,JQEXEQND              GET INITIAL EXECUTION NODE\n         SLL   R0,16                    SET RMT=0\n         ST    R0,FMT@CONV              STORE FOR \"FINDRJE\"\n         LA    R1,FMT@CONV              POINT TO IT\n         CLC   FM#XMIT,FM@QNAME         IS THIS THE XMIT QUEUE?\n         BE    FMT$ROUT                 YES - FORMAT XMIT DEST\n         CLC   FM#RECV,FM@QNAME         IS THIS THE RECV QUEUE?\n         BE    FMT$ROUT                 YES - FORMAT RECV DEST\n.FM02     ANOP\n         LA    R1,JOEROUT               POINT TO REMOTE ID\n         LTR   R2,R2                    JQE OR JOE?\n         BNZ   FMT$ROUT                 JOE\n*        LA    R1,JQEPUNRT              POINT TO PUNCH ROUTE FIELD\n*        CLC   QCLOCAL,0(R1)            LOCAL?\n*        BNE   *+8                      NO - GO FORMAT IT\n         LA    R1,JQEPRTRT              POINT TO PRINT ROUTE FIELD\nFMT$ROUT QCALL FINDRJE                  GO DECODE DEST (ROUTE)\n         MVC   FM@REMOT,0(R1)           MOVE REMOTE ID TO PRINT LINE\n          AIF   ('&QJQEOWN' EQ '').FM27 USER not available\n         TM    QSCFLAG3,QSC3USER        WANT user?\n         BZ    *+10                     no - skip\n         MVC   FM@USER,&QJQEOWN         yes - show it\n.FM27     ANOP\nFMREADNG IC    R15,JQEFLAGS             GET SYSTEM NUMBER\n         N     R15,=A(QUEBUSY)          ZERO OUT UNWANTED BITS\n         BZ    FM$NBUSY                 SKIP IF NOT EXECUTING\n         SLL   R15,3                    MULTIPLY BY 8\n         AL    R15,QVSYSID              OBTAIN SYSTEM ID\n         MVC   FM@SYSID,0(R15)          MOVE SYSTEM ID TO DISPLAY\nFM$NBUSY CLI   QCLASS,0                 IS THIS THE TSO QUEUE?\n         BE    FM$L$TSO                 YES. DO IT.\n         CLI   QCLASS,4                 IS THIS THE STC QUEUE?\n         BE    FM$L$STC                 YES. DO IT.\n         CLI   QCLASS,8                 IS THIS THE HELD OUTPUT QUEUE?\n         BE    FM$L$DH                  YES. DO IT.\n         CLI   QCLASS,12                IS THIS A MISC QUEUE?\n         BE    FMT$JQE                  YES. Q IS ALREADY FULLY NAMED.\n         CLI   QCLASS,16                IS THIS THE \"PURGE\" QUEUE?\n         BE    FMT$JQE                  YES. Q IS ALREADY FULLY NAMED.\n         LTR   R2,R2                    IS REQUEST FOR JQE OR JOE?\n         BZ    FM$L$JQE                 JQE.\n***********************************************************************\n*                                                                     *\n*   FORMAT JOE                                                        *\n*                                                                     *\n***********************************************************************\n         MVI   FM@QNAME,C'O'            MOVE IN NAME OF QUEUE\n         MVC   FM@DEVID,JOEDEVID        GET DEVICE ID TO FORMAT\n         BAL   R7,FMT$DEV               FORMAT IT\n         L     R0,JOERECCT              NUMBER OF PRINT LINES\n         TM    JOEFLAG,$JOEPRT+$JOEPUN  PRINTING OR PUNCHING? %%%\n         NOP   FMT$LNCT   (BZ)          NO - SKIP             %%%\n         TM    JOEFLAG,$JOECKV          IS THE CKPT VALID?\n         BZ    FMT$LNCT                 NO. SKIP IT.\n          AIF   (&QLEVEL GT 4).FM04\n         QNEXT R15,JOECKPT,NONE=FMT$LNCT  OFFSET TO CHECKPOINT JOE\n         AL    R15,QCJOTA               ADD BASE TO OFFSET\n          AIF   (&QLEVEL GE 4).FM03\n         S     R0,JOETLNC-JOEDSECT(,R15)   SUB RECS PRINTED FROM TOTAL\n          AGO   .FM05\n.FM03     ANOP\n         S     R0,JOECRECN-JOEDSECT(,R15)  SUB CURRENT REC# FROM TOTAL\n          AGO   .FM05\n.FM04     ANOP\n         MVC   QCTRAK,JOECPADR          DISK ADDR OF CHK\n         L     R5,QCBLKA                -> HASPACE BUFFER FOR READSPC\n         LR    R1,R5                    PARM FOR READSPC\n         LR    R0,R9                    -> JQE\n         MVC   QCCBID,=C'CHK '          SHOW WHAT WE NEED\n         QCALL READSPC                  READ HASPACE\n         L     R0,JOERECCT              NUMBER OF PRINT LINES\n         S     R0,CHKCRECN-CHKSTART(,R5)  SUB CURRENT REC# FROM TOTAL\n***%%%*% S     R0,JOEWRECN              SUBTRACT RECS PRINTED SO FAR\n.FM05     ANOP\nFMT$LNCT BAL   R14,FMT$LNES             GO FORMAT NUMBER OF PRINT LINES\n         TM    QSCFLAG3,QSC3WTRI        WANT WRITER NAME?\n         BZ    FM$NOWTR                 NO - SKIP\n         QNEXT R15,JOECHAR,NONE=FM$NOWTR  OFFSET TO CHARACTERISTICS JOE\n         AL    R15,QCJOTA               ADD BASE TO OFFSET\n         L     R14,=V(CHARTAB)          -> TRANSLATE TABLE\n         USNGX JOEDSECT,R15             TEMP FOR CHAR JOE\n         TM    QSCFLAG1,QSC1TIME        FORMAT INPUT OR OUTPUT TIME?\n         BO    FM$WTR$A                 YES - PUT WTRNAME IN ALT FIELD\n         MVC   FM@WTRNM,JOEWTRID        YES - DISPLAY IT\n         TR    FM@WTRNM,0(R14)          GET RID OF GARBAGE\n         B     FM$NOWTR                 CONTINUE\nFM$WTR$A MVC   FM@WTRNX,JOEWTRID        DISPLAY WTRID IN ALT FIELD\n         TR    FM@WTRNX,0(R14)          GET RID OF GARBAGE\n         DROPX R15                      JOEDSECT\nFM$NOWTR MVI   FM@FLAGS,0               INIT FLAGS\n         TM    QSCFLAG1,QSC1TIME        INPUT OR OUTPUT TIME REQUESTED?\n         BO    FMT$LIST                 YES - DON'T FMT FORM/UCS/FCB/FL\n         CLI   QCODE,0                  IS THIS \"STATUS\" SUBCOMMAND?\n         BNE   FMT$NOSL                 NO - DISPLAY STANDARD DATA\n         CLC   =CL8'SYSLOG',JQEJNAME    YES - IS THIS A SYSLOG?\n         BNE   FMT$NOSL                 NO - DISPLAY STANDARD DATA\n         OI    FM@FLAGS,FM@SLOG         REMEMBER THIS IS \"ST SYSLOG\"\n         B     FMT$LIST                 DON'T DISPLAY STANDARD DATA\nFMT$NOSL QNEXT R15,JOECHAR,NONE=FMT$LIST  OFFSET TO CHARACTERISTICS JOE\n         AL    R15,QCJOTA               ADD BASE TO OFFSET\n         USNGX JOEDSECT,R15             TEMP FOR CHAR JOE\n*  FOLLOWING COMPARE ASSUMES THAT 'JOEFORM' HAS CORRECT LENGTH ATTR\n         CLC   JOEFORM,=CL8'&QSTDFRM'   IS IT STANDARD?\n         BE    *+10                     YES - DON'T DISPLAY IT\n         MVC   FM@FORM,JOEFORM          MOVE FORM NAME\n         CLC   =C'****',JOEUCS          IS IT STANDARD?\n         BE    *+10                     YES - DON'T DISPLAY IT\n         MVC   FM@UCS,JOEUCS            MOVE UCS NAME\n         CLC   =C'****',JOEFCB          IS IT STANDARD?\n         BE    *+10                     YES - DON'T DISPLAY IT\n         MVC   FM@FCB,JOEFCB            MOVE FCB NAME\n         CLC   FM@FLASH,QBLANK          ANYTHING ALREADY HERE? (RJE ID)\n         BNE   FMT$LIST                 YES - DON'T MOVE IN FLASH\n         CLC   =C'****',JOEFLASH        IS IT STANDARD?\n         BE    FMT$LIST                 YES - DON'T DISPLAY IT\n         MVC   FM@FLASH,JOEFLASH        MOVE 3800 FORMS FLASH\n         TM    QSCFLAG3,QSC3FLSH        WANT FLASH DISPLAYED?\n         BO    FMT$LIST                 YES - SET\n         MVC   FM@REMOT(2),=C'O='       INDICATE WE'RE BEING PERVERSE\n         MVC   FM@REMOT+2(4),JOEFLASH   AND SHOW THE FLASH\n         B     FMT$LIST                 FORMAT REST OF LINE\n         DROPX R15                      JOEDSECT\n***********************************************************************\n*                                                                     *\n*   FORMAT JQE                                                        *\n*                                                                     *\n***********************************************************************\nFM$L$TSO MVC   FM@QNAME(4),=C'TSU '     NAME OF QUEUE\n         B     FMT$JQE                  CONTINUE\nFM$L$STC MVC   FM@QNAME(4),=C'STC '     NAME OF QUEUE\n         B     FMT$JQE                  CONTINUE\nFM$L$DH  MVC   FM@QNAME(4),=C'HOUT'     NAME OF QUEUE\n         B     FMT$JQE                  CONTINUE\nFM$L$JQE MVI   FM@QNAME,C'I'            NAME OF QUEUE\n*---  IF SYSTEM AFFINITY IS NOT \"ALL\", DISPLAY IT                  ---*\n         CLI   JQEFLAG2,QUESYSAF        NON-IND AND S=ALL?\n         BE    FMT$JQE                  YES - SKIP\n         MVC   FM@FORM(2),=C'S='        SHOW WHAT THIS JUNK IS\n         LA    R14,FM@FORM+2            -> OUTPUT AREA\n         LA    R6,4                     MAX WE CAN FIT\n         TM    JQEFLAG2,QUEINDAF        INDEPENDENT MODE AFFINITY?\n         BNO   FM$N$IND                 NO - SKIP\n         MVC   0(3,R14),=C'IND'         YES - SHOW IT\n         LA    R14,3+1(,R14)            INCREMENT\nFM$N$IND TM    JQEFLAG2,QUESYSAF        S=ANY?\n         BO    FMT$JQE                  YES - DON'T SAY SO, FOR NOW\n         IC    R0,JQEFLAG2              GET SYSTEM AFFINITY FLAGS\n         N     R0,=A(QUESYSAF)          STRIP OFF GARBAGE\n         SR    R1,R1                    CLEAR FOR SRDL\n***      LA    R15,QSYSID               -> ZERO'TH SYSTEM ID\n         L     R15,QVSYSID              -> ZERO'TH SYSTEM ID\n         SPACE 1\nFM$AFFLP LA    R15,L'QSYSID(,R15)       -> NEXT SYSTEM ID\n         SRDL  R0,1                     SHIFT LOWEST BIT TO R1\n         LTR   R1,R1                    IS THIS BIT SET?\n         BZ    FM$AFFNO                 NO - SKIP\n         MVC   0(4,R14),0(R15)          MOVE SYSID TO DISPLAY LINE\n         LA    R14,4+1(,R14)            BUMP OUTPUT PTR\n         BCT   R6,FM$AFFNO              YES - CONTINUE IF ROOM FOR IT\nFM$AFFNO LTR   R0,R0                    ANY MORE BITS SET?\n         BNZ   FM$AFFLP                 YES - CONTINUE\n         SPACE 2\nFMT$JQE  CLI   JQETYPE,$FREE            FREE QUEUE?\n         BNE   *+10                     NO - SKIP\n         MVC   FM@QNAME(4),=C'FREE'     YES - SHOW WHAT IT REALLY IS\n         TM    JQETYPE,$XEQ             EXECUTION QUEUE?\n         BO    FMT$LIST                 YES - NOT ON DEVICE\n         TM    JQETYPE,$INPUT+$RECEIVE+$XMIT  READING/TRANSMITTING?\n         BZ    FMT$LIST                 NO - NOT ON DEVICE\n         MVC   FM@DEVID,JQEDEVID        GET DEVICE ID TO FORMAT\n         BAL   R7,FMT$DEV               FORMAT IT\nFMT$LIST MVC   FMT@CONV(6),=X'402020202020'  PREPARE FOR EDIT\n         ED    FMT@CONV(6),QCOUNT       EDIT THE POSITION IN QUEUE\n         MVC   FM@COUNT(4),FMT@CONV+2   MOVE TO DISPLAY LINE\n         MVC   FM@JNAME,JQEJNAME        MOVE IN JOBNAME\n         MVC   FMT@WORK,=X'402020202020'  PREPARE FOR EDIT\n         LH    R0,JQEJOBNO              LOAD HASP JOBNUMBER\n         LA    R14,C' '                 ASSUME JOB - LEAVE IT BLANK\n          AIF   (&QLEVEL GE 4).FM06\n         LH    R1,=H'10000'             GET RANGE SIZE\n         SR    R0,R1                    IS IT A JOB NUMBER?\n         BNP   FMT$JBNO                 YES\n         LA    R14,C'S'                 ASSUME STC\n         SR    R0,R1                    IS IT A STC NUMBER?\n         BNP   FMT$JBNO                 YES\n         LA    R14,C'T'                 ASSUME TSU\n         SR    R0,R1                    IS IT A TSU NUMBER?\n         BNP   FMT$JBNO                 YES\n         EX    0,*                      THIS BETTER NEVER HAPPEN\nFMT$JBNO AR    R0,R1                    RESTORE JOB NUMBER\n         CVD   R0,FMT@CONV              CONVERT TO DECIMAL\n          AGO   .FM07\n.FM06     ANOP\n         TM    JQEFLAG3,QUEJOB          IS IT A JOB?\n         BZ    FMT$JBNO                 YES\n         BM    *+8                      CONTINUE IF ONLY 1 BIT SET\n         EX    0,*                      THIS BETTER NEVER HAPPEN\n         LA    R14,C'S'                 ASSUME STC\n         TM    JQEFLAG3,QUESTC          IS IT A STC?\n         BO    FMT$JBNO                 YES\n         LA    R14,C'T'                 ASSUME TSU\nFMT$JBNO CVD   R0,FMT@CONV              CONVERT TO DECIMAL\n.FM07     ANOP\n*  DON'T NEED TO PRESET R1 FOR EDMK FAILURE SINCE JES2 WON'T CREATE\n*  JOB 0, STC 0, OR TSU 0.\n         EDMK  FMT@WORK,FMT@CONV+5      EDIT HASP JOBNUMBER\n         BCTR  R1,0                     BACK UP TO BEFORE FIRST DIGIT\n         STC   R14,0(,R1)               SET THE J/S/T\n         MVC   FM@JOBID,FMT@WORK+1      MOVE HASP JOBNUMBER TO SCREEN\n         SR    R0,R0                    CLEAR FOR IC\n         IC    R0,JQEPRIO               LOAD JQE PRIORITY\n          AIF   (&QLEVEL LT 5).FM08\n         LTR   R2,R2                    IS REQUEST FOR JQE OR JOE?\n         BZ    *+8                      JQE - USE JQEPRIO\n         LH    R0,JOEPRIO               JOE - USE NEW STYLE JOE PRTY\n.FM08     ANOP\n         SRL   R0,4                     DIVIDE BY 16\n         CVD   R0,FMT@CONV              CONVERT TO DECIMAL\n         MVC   FMT@WORK(4),=X'40202021' PREPARE FOR EDIT\n         ED    FMT@WORK(4),FMT@CONV+6   EDIT JQE PRIORITY\n         MVC   FM@PRTY,FMT@WORK+1       MOVE JQE PRIORITY TO SCREEN\n*?       STC   R0,FMT@WORK              SAVE FOR UNPK\n*?       HEX   FMT@WORK+2,FMT@WORK,LEN=1,HEXTAB=QHEXTAB\n*?       CLI   FMT@WORK+2,C'0'          LEADING 0?\n*?       BNE   *+8                      NO - OK\n*?       MVI   FMT@WORK+2,C' '          YES - REMOVE IT\n*?       MVC   FM@PRTY,FMT@WORK+2       MOVE JQE PRIORITY TO SCREEN\n         SPACE 1\n         TM    JQEFLAGS,QUEHOLD2        HELD BECAUSE DUP JOB NAME?\n         BNO   *+10                     NO - SKIP\n         MVC   FM@HOLD,=C'DUP'          YES - FLAG IT\n         TM    JQEFLAGS,QUEHOLDA        HOLD ALL?\n         BNO   *+10                     NO\n         MVC   FM@HOLD,=C'ALL'          INDICATE JOB HELD FOR HOLD ALL\n         TM    JQEFLAGS,QUEHOLD1        THIS JOB HELD?\n         BNO   *+10                     NO - SKIP\n         MVC   FM@HOLD,=C'HLD'          YES - INDICATE IT\n         MVC   QCTRAK,JQETRAK           DISK ADDR OF JCT\n         TM    QSCFLAG1,QSC1DH          IS THIS \"DH\"?\n         BNO   FMT$NDH                  NO - DON'T FORMAT HELD DS COUNT\n         SR    R0,R0                    CLEAR FOR ICM\n          AIF  (&QLEVEL GE 11).FM24     (this needs work%%%%%)\n          AIF  (&QLEVEL GE 9).FM23\n         ICM   R0,B'0011',JQEHLDCT      GET HELD DATASET COUNT\n         SRL   R0,4                     SHIFT OUT GARBAGE\n          AGO  .FM24\n.FM23     ANOP ,\n         ICM   R0,B'0111',JQEHDSCT      get held dataset count\n.FM24     ANOP ,\n         MVC   FM@HLCNT,=X'402020202120'\n         CVD   R0,FMT@CONV\n         OI    FMT@CONV+7,X'0F'         REMOVE SIGN\n         ED    FM@HLCNT,FMT@CONV+5\n         SPACE 1\nFMT$NDH  TM    FM@FLAGS,FM@SLOG         IS THIS \"STATUS SYSLOG\"?\n         BO    FM$RDJCT                 YES - READ THE JCT\n         TM    QSCFLAG1,QSC1PGMR+QSC1TIME+QSC1PCT+QSC1SPC  NEED JCT?\n         BZ    FMT$DONE                 NO - SAVE SOME I/O\nFM$RDJCT L     R3,QCJCTA                ADDR OF IOAREA FOR JCT\n         LR    R1,R3                    PARM FOR READSPC\n         MVC   QCCBID,=C'JCT '          SHOW WHAT WE NEED\n         LR    R0,R9                    -> JQE\n         QCALL READSPC                  READ HASPACE\n         USNGX JCTSTART,R3              DISPLAY PROGRAMMER NAME...\n          AIF   (&QLEVEL LT 4).FM25\n         TM    QSCFLAG1,QSC1PCT         SPOOL percent INSTEAD OF LINES?\n         BO    FM$PCT                   YES - GO READ IOT'S\n.FM25     ANOP\n         TM    QSCFLAG1,QSC1SPC         SPOOL SPACE INSTEAD OF LINES?\n         BO    FM$SPACE                 YES - GO READ IOT'S\n         CLC   =C'O ',FM@QNAME          IS THIS JOB ON OUTPUT QUEUE?\n         BE    FM$NLNES                 YES - DON'T DISPLAY JCT LINES\n         L     R0,JCTLINES              GET GENERATED LINE COUNT\n         BAL   R14,FMT$LNES             FORMAT IT\n         B     FM$NLNES                 CONTINUE\n          AIF   (&QLEVEL LT 4).FM26\nFM$PCT   LH    R1,JQETGNUM              get number of allocated TG's\n         TM    JQEFLAG5,JQE5XUSD        using extension for TG count?\n         BZ    FM$PCTOK                 no - all set\n         AL    R1,QCJQEXA               Add JQE extension base\n         LH    R1,0(,R1)                Get number of allocated TG's\nFM$PCTOK M     R1-1,=F'10000'           scale for nn.nn%, clear R0\n         L     R14,QCJQTL               -> mstr rec chkpt area\n         D     R0,$TGTOTAL-$SAVEBEG(,R14)  compute percent for this job\n         MVC   FMT@WORK(7),=X'402020214B2020'  PREPARE FOR EDIT\n         CVD   R1,FMT@CONV              CONVERT TO DECIMAL\n         ED    FMT@WORK(7),FMT@CONV+5   PRINT UPDATED LINE COUNT\n         MVC   FM@LINES,FMT@WORK+2      MOVE LINE COUNT TO SCREEN\n         C     R1,=F'0500'              > 5% of the spool?\n         BL    FM$NLNES                 no - ok\n         MVC   FM@ATTR5,=X'1DE8'        yes - set output, bright\n         B     FM$NLNES                 continue\n.FM26     ANOP\n          AIF   (&QLEVEL GE 7).FM09\n***********************************************************************\n*  READ ALL IOT'S AND COUNT UP THE TOTAL NUMBER OF TRACK GROUPS USED  *\n***********************************************************************\nFM$SPACE NI    FM@FLAGS,255-FM@SPIN     HAVEN'T DONE SPIN CHAIN YET\n         XR    R6,R6                    CLEAR ACCUMULATOR\n         MVC   QCTRAK,JCTIOT            DISK ADDR OF FIRST REGULAR IOT\n         L     R5,QCIOTA                ADDR OF IOAREA FOR IOT\n         SPACE 1\nFM$IOTLP LR    R1,R5                    PARM FOR READSPC\n         MVC   QCCBID,=C'IOT '          SHOW WHAT WE NEED\n         LR    R0,R9                    -> JQE\n         QCALL READSPC                  READ HASPACE\n         USNGX IOTSTART,R5\n         TM    IOTFLAG1,IOT1ALOC        IS THIS AN ALLOCATION IOT?\n         BNO   FM$NXIOT                 NO - TRY NEXT IOT\n         LA    R14,IOTTGMAP+TGMAP-TGMDSECT  -> START OF TG MAP\n         LH    R1,QCTGMLEN              GET # OF BYTES IN TG MAP\n         SR    R15,R15                  CLEAR FOR IC\n         SPACE 1\nFM$TG$LP IC    R15,0(,R14)              GET A BYTE OF TG MAP\n         IC    R15,FM#BITB(R15)         GET # OF 1'S IN THAT BYTE\n         AR    R6,R15                   ADD TO ACCUMULATED TOTAL\n         LA    R14,1(,R14)              -> NEXT TG MAP BYTE\n         BCT   R1,FM$TG$LP              PROCESS WHOLE TG MAP\n         SPACE 1\n*---  PREPARE TO PROCESS NEXT IOT                                  ---*\nFM$NXIOT MVC   QCTRAK,IOTIOTTR          DISK ADDR OF NEXT IOT\n         CLC   QCTRAK,=F'0'             ANY MORE IOT'S?\n         BNE   FM$IOTLP                 YES - PROCESS\n         TM    FM@FLAGS,FM@SPIN         DONE SPIN CHAIN YET?\n         BO    FM$GOTTG                 YES - FORMAT COUNT INTO LINE\n         OI    FM@FLAGS,FM@SPIN         INDICATE NOW DOING SPIN CHAIN\n         MVC   QCTRAK,JCTSPIOT          DISK ADDR OF FIRST SPIN IOT\n         CLC   QCTRAK,=F'0'             ANY SPIN IOT'S?\n         BNE   FM$IOTLP                 YES - PROCESS\n         DROPX R5                       IOTSTART\nFM$GOTTG LR    R0,R6                    GET NUMBER OF ALLOCATED TG'S\n          AGO  .FM10\n.FM09     ANOP ,\nFM$SPACE LH    R0,JQETGNUM              get number of allocated TG's\n         TM    JQEFLAG5,JQE5XUSD        using extension for TG count?\n         BZ    FM$TG$OK                 no - all set\n         LR    R14,R0                   yes - copy JQEEXT offset\n         AL    R14,QCJQEXA              Add JQE extension base\n         LH    R0,0(,R14)               Get number of allocated TG's\n.FM10     ANOP ,\nFM$TG$OK BAL   R14,FMT$LNES             FORMAT IT\n         SPACE 2\nFM$NLNES TM    FM@FLAGS,FM@SLOG         IS THIS \"STATUS SYSLOG\"?\n         BO    FM$SLOG1                 YES - FORMAT START DATE/TIME\n         TM    QSCFLAG1,QSC1PGMR        PROGRAMMER NAME REQUESTED?\n         BO    FMT$PGMR                 YES - DISPLAY IT\n         TM    QSCFLAG1,QSC1TIME        INPUT OR OUTPUT TIME REQUESTED?\n         BNO   FMT$DONE                 NO - ALL DONE\nFM$SLOG1 TM    FM@FLAGS,FM@SLOG         IS THIS \"STATUS SYSLOG\"?\n         BNO   FM$DATE                  NO - SKIP\n         LA    R4,JCTXEQON              -> START EXEC TIME\n         MVC   FM@SLID,JCTEXSID         SHOW THIS SYSLOG'S SYSTEM ID\n         B     FM$DATE2                 GO FORMAT START EXEC DATE/TIME\n*---  FORMAT THE INPUT OR OUTPUT DATE (FROM PACKED)\n*  WAS USING JCTCDTOF/JCTCNVOF\nFM$DATE  LA    R4,JCTRDRON              -> TIME/DATE ON READER\n         CLI   FM@QNAME,C'I'            IS THIS AN INPUT QUEUE?\n         BE    FM$DATE2                 YES - OK\n         LA    R4,JCTOUTOF              -> TIME/DATE OFF OUTPUT\n         CLC   =C'OFF',JCTINDEV         from a spool offload device?\n         BNE   FM$DATE2                 no - use \"off output\" date\n         LA    R4,JCTXEQOF              yes - use end exec date\n         CLC   =F'0',JCTXDTOF           but is it there?\n         BNE   FM$DATE2                 yes - use it\n         MVI   FM@DATE-1,C'>'           flag that we're guessing\n         MVI   FM@TIME+8,C'<'           here too\n         LA    R4,JCTXEQON              no (sys crash) - use xeq start\n         CLC   =F'0',JCTXEQON           but is it there?\n         BNE   FM$DATE2                 yes - use it\n         LA    R4,JCTRDRON              no (print file) - use rdr start\nFM$DATE2 QITEM ,,FM@DATE,DATE,4(R4),SKIP=FMT$DONE  format date\n*---  FORMAT THE TIME (FROM BINARY)\n         L     R1,0(,R4)                PICK UP BINARY TIME\n         SR    R0,R0                    CLEAR FOR DIVIDE\n         D     R0,=F'100'               CONVERT TO SECONDS\n         SR    R0,R0                    CLEAR FOR DIVIDE\n         D     R0,=F'60'                R0 = SECONDS, R1 = MINUTES\n         CVD   R0,FMT@CONV\n         OI    FMT@CONV+7,X'0F'         REMOVE SIGN\n         UNPK  FM@TIME+6(2),FMT@CONV\n         MVI   FM@TIME+5,C':'\n         SR    R0,R0                    CLEAR FOR DIVIDE\n         D     R0,=F'60'                R0 = MINUTES, R1 = HOURS\n         CVD   R0,FMT@CONV\n         OI    FMT@CONV+7,X'0F'         REMOVE SIGN\n         UNPK  FM@TIME+3(2),FMT@CONV\n         MVI   FM@TIME+2,C':'\n         CVD   R1,FMT@CONV\n         OI    FMT@CONV+7,X'0F'         REMOVE SIGN\n         UNPK  FM@TIME(2),FMT@CONV\n         B     FMT$DONE                 ALL DONE\nFMT$PGMR MVC   FM@PGMR,JCTPNAME         INSTEAD OF FORM/FCB/UCS/PRINT\n         MVC   FM@PGMR+L'JCTPNAME(FM@OVERL-L'JCTPNAME),QBLANK BLNK REST\n         DROPX R3                       JCTSTART\n         SPACE 2\n*---  SAVE DATA IN ARRAY FOR LINE COMMANDS                         ---*\nFMT$DONE XC    FM@TPTR(LCBELEN),FM@TPTR INIT ARRAY ELEMENT\n         MVI   FM@ADDR1+3,FM@SEL-QDMSG OFFSET OF FIRST INPUT FIELD\n         MVI   FM@ADDR2+3,FM@REMOT-QDMSG OFFSET OF SECOND INPUT FIELD\n         MVC   FM@ID(5),FM@JOBID        JOBID\n         CLI   FM@ID+3,C' '             ONE CHARACTER JOBNUMBER?\n         BNE   *+8                      NO - OK\n         MVI   FM@ID+3,C'0'             YES - MAKE IT TWO CHARACTERS\n         MVC   FM@FLD1(2+8),QBLANK\n         LA    R1,FM@TPTR               -> MY ARRAY ELEMENT\n         QCALL DISPADDX                 ADD LINE TO SCREEN\n         TM    QSCFLAG2,QSC2DJX         IS THE REQUEST FOR A HEX DUMP?\n         BNO   QSTOP                    NO - ALL DONE\n         B     FMHEXJQE                 GO DUMP JQE, AND MAYBE JOE(S)\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*   FORMAT DEVICE NAME SUBROUTINE                                     *\n*                                                                     *\n***********************************************************************\nFMT$DEV  TM    QSCFLAG1,QSC1TIME        INPUT OR OUTPUT TIME REQUESTED?\n         BOR   R7                       YES - JUST RETURN\n         LTR   R2,R2                    JOE?\n         BNZ   FMT$DEV1                 YES\n         CLC   QCLOCAL,FM@DEVID         ANYTHING?\n         BER   R7                       NO - JUST RETURN\nFMT$DEV1 OC    FM@DEVID,FM@DEVID        ANYTHING HERE?\n         BZ    FM$NO$XD                 NO - DON'T DISPLAY IT\n         MVC   FM@DEVNM(3),=C'???'      ASSUME CAN'T FIGURE IT OUT\n         TM    QXAUTH,QXSYSP+QXPSWD     GOOD GUY?\n         BZ    FM$NO$XD                 NO - DON'T SHOW HIM HEX DEVID\n*%       UNPK  FM@DEVNM(2*L'FM@DEVID+1),FM@DEVID(L'FM@DEVID+1) SHOW HEX\n*%       TR    FM@DEVNM(2*L'FM@DEVID),QHEXTAB IN CASE ALL ELSE FAILS\n*%       MVI   FM@DEVNM+2*L'FM@DEVID,C' ' KILL FLIP BYTE\n*  IF ALL ELSE FAILS, DISPLAY THE DEVICE TYPE IN HEX\n          AIF   (&QLEVEL GE 4).FM11\n         HEX   FM@DEVNM,FM@DEVID,LEN=2,HEXTAB=QHEXTAB\nFM$NO$XD CLC   FM@DEVID,=X'0F00'        EXTERNAL WRITER?\n         BNE   FM$NXWTR                 NO - SKIP\n          AGO   .FM12\n.FM11     ANOP\n         HEX   FM@DEVNM,FM@DEVID,LEN=3,HEXTAB=QHEXTAB\nFM$NO$XD CLC   FM@DEVID,=X'0F0000'      EXTERNAL WRITER?\n         BE    FM$XWTR                  YES - PROCESS IT\n         TM    FM@DEVID,DCTXFRID X'0F'  SPOOL XFR DEVICE?\n         BNO   FM$NXWTR                 NO - SKIP\n         TM    FM@DEVID,X'40'           IS IT X'40' THRU X'70'?\n         BNO   FM$NXWTR                 NO - SKIP\n*%%%  DO WE NEED TO CHECK FOR INTERRUPTED JOB???\n         SR    R1,R1                    CLEAR FOR IC\n         IC    R1,FM@DEVID              GET LOCAL DEVICE TYPE\n         SRL   R1,4                     RIGHT JUSTIFY\n         SLL   R1,3                     TIMES LENGTH OF A DEVICE ENTRY\n         LA    R1,FM#DEVTB(R1)          -> DEVICE TYPE\n         MVC   FM@DEVNM(7),1(R1)        DEVICE TYPE TO PRINT LINE\n         MVC   FM@DEVNM+3(1),FM@DEVID+2 GET N OF DMPN OR LODN\n         OI    FM@DEVNM+3,X'F0'         make it displayable\n         BR    R7                       DONE - RETURN TO CALLER\n.FM12     ANOP\nFM$XWTR  MVC   FM@DEVNM(7),=C'Ext-Wtr'  YES\n         TM    JOEFLAG,$JOEBUSY         THIS OUTPUT ACTIVE?\n         BNZR  R7                       YES - OK\n         MVC   FM@DEVNM+4(3),=C'Int '   NO - IT MUST HAVE BEEN INT'D\n         BR    R7                       DONE\n*  NOTE THAT IF THE JOB IS ON THE EXTERNAL WRITER OR PRINTING/PUNCHING\n*  AT A REMOTE (AND NOT ALSO ON A REAL LOCAL PRINTER), THE FLAGS\n*  $JOEPRT & $JOEPUN WILL BE OFF.\nFM$NXWTR TM    FM@DEVID,DCTRMTID X'80'  PRINT/PUNCH ON REMOTE DEVICE?\n         BO    FMRMTDV                  YES - SPECIAL FORMAT ROUTINE\n         LTR   R2,R2                    JOE?\n         BZ    FMT$DEV2                 NO - JQE\n         TM    JOEFLAG,$JOEPRT+$JOEPUN  PRINTING OR PUNCHING?\n         BZR   R7                       NO. SKIP.\n         MVC   FM@DEVNM(4),=C'Int '     ASSUME IT WAS $I'D\n         TM    JOEFLAG,$JOEBUSY         BUT WAS IT INTERRUPTED?\n         BZR   R7                       YES - OK\n         B     FMT$DEV3                 SKIP AROUND\n          AIF   (&QLEVEL GE 4).FM13\nFMT$DEV2 TM    JQETYPE,$INPUT           JOB ON INPUT QUEUE?\n         BZR   R7                       NO - JUST RETURN\n          AGO   .FM14\n.FM13     ANOP\nFMT$DEV2 TM    JQETYPE,$XMIT            JOB ON XMIT QUEUE?\n         BO    FMT$XMIT                 YES - SPECIAL HANDLING\n         TM    JQETYPE,$INPUT           JOB ON INPUT QUEUE?\n         BZR   R7                       NO - JUST RETURN\n.FM14     ANOP\nFMT$DEV3 SR    R1,R1                    CLEAR FOR IC\n         IC    R1,FM@DEVID              GET LOCAL DEVICE TYPE\n         SRL   R1,4                     RIGHT JUSTIFY\n         CH    R1,=H'3'                 UNKNOWN DEVICE TYPE?\n         BHR   R7                       YES - LEAVE IT FORMATTED IN HEX\n         SLL   R1,3                     TIMES LENGTH OF A DEVICE ENTRY\n         LA    R1,FM#DEVTB(R1)          -> DEVICE TYPE\n         MVC   FM@DEVNM(7),1(R1)        DEVICE TYPE TO PRINT LINE\n         CLI   FM@DEVID,DCTINRID        INTERNAL READER?\n         BER   R7                       YES - SAY NO MORE\n         SR    R14,R14                  CLEAR FOR IC\n         IC    R14,FM@DEVID+L'FM@DEVID-1  GET DEVICE NUMBER\n         SR    R15,R15                  CLEAR FOR IC\n         IC    R15,0(,R1)               GET LENGTH OF DEVICE NAME\n         LA    R1,FM@DEVNM(R15)         -> NEXT POSITION ON LINE\n         CH    R15,=H'7'                PRINTER?\n         BL    FM$DEVOK                 NO - SKIP\n         CH    R14,=H'9'                PRINTER NUMBER > 9?\n         BNH   FM$DEVOK                 NO - SKIP\n         BCTR  R1,0                     YES - BACK UP THE POINTER...\n         MVC   FM@DEVNM+5(1),FM@DEVNM+6 ... AND MAKE IT 'PRINTR##'\nFM$DEVOK CVD   R14,FMT@CONV             CONVERT DEVICE NUMBER\n         OI    FMT@CONV+7,X'0F'         REMOVE SIGN\n         UNPK  FMT@WORK(2),FMT@CONV     MAKE PRINTABLE\n         MVC   0(1,R1),FMT@WORK+1       ASSUME SINGLE DIGIT\n         CLI   FMT@WORK,C'0'            LEADING 0?\n         BER   R7                       YES - OK AS IS\n         MVC   0(2,R1),FMT@WORK         NO - MOVE BOTH DIGITS OVER\n         BR    R7                       ALL DONE HERE\n          AIF   (&QLEVEL LT 4).FM15\n***********************************************************************\n*   FORMAT JT DEVICE TYPE                                             *\n***********************************************************************\nFMT$XMIT TM    JQEFLAGS,QUEBUSY         THIS JOB NOW ON XMITTER?\n         BNZR  R7                       NO - LEAVE IT IT HEX FOR NOW\n         MVI   FM@DEVNM,C'L'            DEVICE TYPE TO PRINT LINE\n         SR    R14,R14                  CLEAR FOR IC\n         IC    R14,FM@DEVID+L'FM@DEVID-1  GET DEVICE NUMBER\n         CVD   R14,FMT@CONV             CONVERT DEVICE NUMBER\n         OI    FMT@CONV+7,X'0F'         REMOVE SIGN\n         MVC   FMT@WORK,=X'402020202120'  GET EDIT MASK\n         MVC   FMT@WORK+6(10),QBLANK    CLEAR TRAILER\n         LA    R1,FMT@WORK+5            PRESET SIGNIFICANCE POINTER\n         EDMK  FMT@WORK,FMT@CONV+5      MAKE PRINTABLE\n         SR    R14,R14                  CLEAR FOR IC\n         IC    R14,FM@DEVID             GET LOCAL DEVICE TYPE\n         SRL   R14,4                    RIGHT JUSTIFY\n         SLL   R14,3                    TIMES LENGTH OF A DEVICE ENTRY\n         LA    R14,FM#DEVTB(R14)        -> DEVICE TYPE\n         MVC   FMT@WORK+6(3),4+1(R14)   GET THE '.JT'\n         MVC   FMT@WORK+9(1),FM@DEVID   GET THE TRANSMITTER NUMBER\n         OI    FMT@WORK+9,C'0'          MAKE IT DISPLAYABLE NUMERIC\n         MVC   FM@DEVNM+1(7),0(R1)      LEFT JUSTIFY THE LINE NUMBER\n         BR    R7                       ALL DONE HERE\n.FM15     ANOP\n***********************************************************************\n*   FORMAT REMOTE DEVICE NAME                                         *\n***********************************************************************\n          AIF   (&QLEVEL GE 4).FM16\nFMRMTDV  SR    R14,R14                  CLEAR FOR IC\n         IC    R14,FM@DEVID+1           GET THE REMOTE NUMBER\n          AGO   .FM17\n.FM16     ANOP\nFMRMTDV  LH    R14,FM@DEVID+1           GET THE REMOTE NUMBER\n.FM17     ANOP\n         MVI   FM@DEVNM,C'R'            INDICATE REMOTE\n         CVD   R14,FMT@CONV\n         OI    FMT@CONV+7,X'0F'         REMOVE SIGN\n         UNPK  FM@DEVNM+1(3),FMT@CONV   MAKE REMOTE NUMBER PRINTABLE\n         LA    R1,FM@DEVNM+4            ASSUME 3 DIGITS\n         CLI   FM@DEVNM+1,C'0'          LEADING 0?\n         BNE   *+12                     NO - SKIP\n         MVC   FM@DEVNM+1(3),FM@DEVNM+2 YES - SHIFT IT OVER\n         BCTR  R1,0                     BACK UP WHERE THE DOT GOES\n         CLI   FM@DEVNM+1,C'0'          LEADING 0?\n         BNE   *+12                     NO - SKIP\n         MVC   FM@DEVNM+1(3),FM@DEVNM+2 YES - SHIFT IT OVER\n         BCTR  R1,0                     BACK UP WHERE THE DOT GOES\n         MVI   0(R1),C'.'               PUT IN THE SEPARATOR\n         LTR   R2,R2                    JOE?\n         BZ    FMRMTDV2                 NO - JQE.\n         MVC   1(3,R1),=C'Int '         ASSUME INTERRUPTED\n         TM    JOEFLAG,$JOEBUSY         IS IT ACTIVE NOW?\n         BZR   R7                       NO - IT WAS INTERRUPTED\n         B     FMRMTDV3                 SKIP AROUND\nFMRMTDV2 TM    JQETYPE,$INPUT           JOB ON INPUT QUEUE?\n         BNOR  R7                       NO - JUST RETURN\nFMRMTDV3 SR    R15,R15                  CLEAR FOR IC\n         IC    R15,FM@DEVID             GET THE DEVICE TYPE\n         SRL   R15,3                    RIGHT JUSTIFY IT\n         CH    R15,=Y(3*2+DCTRMTID/8)   UNKNOWN DEVICE TYPE?\n         BHR   R7                       YES - LEAVE IT FORMATTED IN HEX\n         LA    R15,FM#RMDVS-DCTRMTID/8(R15) -> DEVICE TYPE\n         MVC   1(2,R1),0(R15)           MOVE REMOTE DEVICE TYPE\n         MVC   3(1,R1),FM@DEVID         MOVE THE DEVICE NUMBER\n         OI    3(R1),C'0'               MAKE IT PRINTABLE\n         BR    R7                       RETURN TO CALLER\n***********************************************************************\n*                                                                     *\n*   FORMAT LINE COUNT SUBROUTINE                                      *\n*                                                                     *\n***********************************************************************\nFMT$LNES SRDL  R0,32                    # LINES TO R1, CLEAR R0\n         MVC   FMT@WORK,=X'402020202020'  PREPARE FOR EDIT\n         C     R1,=F'100000'            TOO BIG?\n         BL    FMT$NOTK                 NO - SKIP\n         AH    R1,=H'500'               YES - SET TO ROUND\n         D     R1-1,=F'1000'            THEN SCALE IT\n         MVI   FM@LINES+L'FM@LINES-1,C'K' AND SHOW IT\n         C     R1,=F'10000'             STILL TOO BIG?\n         BL    FMT$NOTM                 NO - SKIP\n         AH    R1,=H'500'               YES - SET TO ROUND\n         SR    R0,R0                    CLEAR FOR DIVIDE\n         D     R1-1,=F'1000'            THEN SCALE IT\n         MVI   FM@LINES+L'FM@LINES-1,C'M' AND SHOW IT\nFMT$NOTM CVD   R1,FMT@CONV              CONVERT TO DECIMAL\n         ED    FMT@WORK,FMT@CONV+5      PRINT UPDATED LINE COUNT\n         MVC   FM@LINES(L'FM@LINES-1),FMT@WORK+2  LINE COUNT TO SCREEN\n         MVC   FM@ATTR5,=X'1DE8'        SET OUTPUT, BRIGHT\n         BR    R14                      RETURN TO CALLER\nFMT$NOTK CVD   R1,FMT@CONV              CONVERT TO DECIMAL\n         ED    FMT@WORK,FMT@CONV+5      PRINT UPDATED LINE COUNT\n         MVC   FM@LINES,FMT@WORK+1      MOVE LINE COUNT TO SCREEN\n         BR    R14                      RETURN TO CALLER\n***********************************************************************\n*                                                                     *\n*   TAKE HEX DUMP OF JQE                                              *\n*                                                                     *\n***********************************************************************\nFM$JQE   LH    R1,QLNG1                 get length of first operand\n         LTR   R1,R1                    any operand?\n         BP    FM$JQE$1                 yes - continue\nFM$JXERR QTILT '*** Operand required ***',OPTIONS=REPROMPT\nFM$PACK  PACK  QNUMWORK(4+1),FMT@HEXW(*-*)  << executed >>\nFM$JQE$1 MVC   FMT@HEXW,QPARM1          copy the parm\n         TR    FMT@HEXW(8),FMHEXTAB     make it halfway hex\n*  Note that length in R1 is not decremented for execute, but to pack\n*  hex, it's necessary to do an extra byte, so we're in great shape.\n         EX    R1,FM$PACK              PACK QNUMWORK(4+1),FMT@HEXW(*-*)\n         L     R9,QNUMWORK              pick up JQE offset\n         AL    R9,QCJQTA                -> JQE\n*---  \"XJ\" subcommand enters here\nFMHEXJQE LR    R3,R2                    SAVE ENTRY CODE\n         MVC   QDMSG(FM#JQEL),FM#JQE    '   HEX DUMP OF JQE AT OFFSET'\n         LR    R0,R9                    COPY JQE ADDR\n         SL    R0,QCJQTA                SUBTRACT BASE\n         ST    R0,FMT@CONV              STORE FOR UNPACK\n         HEX   QDMSG+31,FMT@CONV+1,LEN=3,HEXTAB=QHEXTAB\n         ST    R9,FMT@CONV              STORE FOR UNPACK\n         HEX   QDMSG+51,FMT@CONV+1,LEN=3,HEXTAB=QHEXTAB,BYTE=C')'\n         CLI   QCODE,100                is this the JQE subcommand?\n         BNE   FM$JQE$2                 no - use as is\n         MVC   QDHLINE(FM#JQEL-4),QDMSG+2  move detail hdr to main hdr\n         MVC   QDMSG,QBLANK             and clear line buffer\n         B     FM$JQE$3                 and don't add any line here\nFM$JQE$2 MVI   QDATRNUM+1,2             NUMBER OF ATTR BYTES\n         BAL   R14,QADDLINE             PUT HEADER TO SCREEN BUFFER\nFM$JQE$3 SR    R0,R0                    DISPLAY OFFSET\n         LR    R1,R9                    GET ADDRESS TO DUMP\n*        LA    R2,JQELNGTH              GET LENGTH TO DUMP\n         LH    R2,QCJQELEN              GET LENGTH TO DUMP\n         QCALL HEXFMT                   CONVERT JQE TO HEX\n         CLI   QCODE,100                is this the JQE subcommand?\n         BE    QSTOP                    yes - all done\n         MVI   QDMSG,C'-'               MAKE A LINE ...\n         MVC   QDMSG+1(L'QDMSG-1),QDMSG ... OF DASHES\n         BAL   R14,QADDLINE             ADD DASHES LINE\n         LTR   R3,R3                    JQE OR JOE?\n         BZ    QSTOP                    JQE - ALL DONE\n         B     FMHEXJOE                 skip \"JOE\" subcommand code\n***********************************************************************\n*                                                                     *\n*   TAKE HEX DUMP OF JOES                                             *\n*                                                                     *\n***********************************************************************\nFM$JOE   LH    R1,QLNG1                 get length of first operand\n         LTR   R1,R1                    any operand?\n         BNP   FM$JXERR                 no - error\n         MVC   FMT@HEXW,QPARM1          copy the parm\n         TR    FMT@HEXW(8),FMHEXTAB     make it halfway hex\n*  Note that length in R1 is not decremented for execute, but to pack\n*  hex, it's necessary to do an extra byte, so we're in great shape.\n         EX    R1,FM$PACK              PACK QNUMWORK(4+1),FMT@HEXW(*-*)\n         L     R8,QNUMWORK              pick up JOE offset\n         AL    R8,QCJOTA                -> JOE\nFMHEXJOE MVC   QDMSG(FM#JOEL),FM#JOE    '   HEX DUMP OF WORK JOE AT ..'\n         LR    R0,R8                    COPY WORK JOE ADDR\n         SL    R0,QCJOTA                SUBTRACT BASE\n         ST    R0,FMT@CONV              STORE FOR UNPACK\n         HEX   QDMSG+36,FMT@CONV+1,LEN=3,HEXTAB=QHEXTAB\n         ST    R8,FMT@CONV              STORE FOR UNPACK\n         HEX   QDMSG+56,FMT@CONV+1,LEN=3,HEXTAB=QHEXTAB,BYTE=C')'\n         CLI   QCODE,104                is this the JOE subcommand?\n         BNE   FM$JOE$2                 no - use as is\n         MVC   QDHLINE(17-2),QDMSG+2    move detail hdr to main hdr\n         MVC   QDHLINE(FM#JOEL-17-5-2),QDMSG+22  leaving out 'WORK '\n         MVC   QDMSG,QBLANK             and clear line buffer\n         B     FM$JOE$3                 and don't add any line here\nFM$JOE$2 MVI   QDATRNUM+1,2             NUMBER OF ATTR BYTES\n         BAL   R14,QADDLINE             PUT HEADER TO SCREEN BUFFER\nFM$JOE$3 SR    R0,R0                    DISPLAY OFFSET\n         LR    R1,R8                    GET ADDRESS TO DUMP\n         LA    R2,JOE1END-JOEDSECT      GET LENGTH TO DUMP\n         QCALL HEXFMT                   CONVERT JQE TO HEX\n         CLI   QCODE,104                is this the JOE subcommand?\n         BE    QSTOP                    yes - all done\n         MVI   QDMSG,C'-'               MAKE A LINE ...\n         MVC   QDMSG+1(L'QDMSG-1),QDMSG ... OF DASHES\n         BAL   R14,QADDLINE             ADD DASHES LINE\n         SPACE 1\n         QNEXT R6,JOECHAR,NONE=FM$CHKPT GET OFFSET OF CHAR JOE\n         ST    R6,FMT@CONV              STORE FOR UNPACK\n         A     R6,QCJOTA                ADD TO BASE\n         MVC   QDMSG(FM#JOEL),FM#JOE    '   HEX DUMP OF WORK JOE AT ..'\n         MVC   QDMSG+17(4),=C'Char'     '   HEX DUMP OF CHAR JOE AT ..'\n         HEX   QDMSG+36,FMT@CONV+1,LEN=3,HEXTAB=QHEXTAB\n         ST    R6,FMT@CONV              STORE FOR UNPACK\n         HEX   QDMSG+56,FMT@CONV+1,LEN=3,HEXTAB=QHEXTAB,BYTE=C')'\n         MVI   QDATRNUM+1,2             NUMBER OF ATTR BYTES\n         BAL   R14,QADDLINE             PUT HEADER TO SCREEN BUFFER\n         SR    R0,R0                    DISPLAY OFFSET\n         LR    R1,R6                    GET ADDRESS TO DUMP\n         LA    R2,JOE2END-JOEDSECT      GET LENGTH TO DUMP\n         QCALL HEXFMT                   CONVERT JQE TO HEX\n         MVI   QDMSG,C'-'               MAKE A LINE ...\n         MVC   QDMSG+1(L'QDMSG-1),QDMSG ... OF DASHES\n         BAL   R14,QADDLINE             ADD DASHES LINE\n         SPACE 1\n          AIF   (&QLEVEL GT 4).FM18\n         SPACE 2\nFM$CHKPT QNEXT R6,JOECKPT,NONE=QSTOP    GET OFFSET OF CKPT JOE\n         ST    R6,FMT@CONV              STORE FOR UNPACK\n         A     R6,QCJOTA                ADD TO BASE\n         MVC   QDMSG(FM#JOEL),FM#JOE    '   HEX DUMP OF WORK JOE AT ..'\n         MVC   QDMSG+17(4),=C'Ckpt'     '   HEX DUMP OF CKPT JOE AT ..'\n         HEX   QDMSG+36,FMT@CONV+1,LEN=3,HEXTAB=QHEXTAB\n         MVI   QDATRNUM+1,2             NUMBER OF ATTR BYTES\n         BAL   R14,QADDLINE             PUT HEADER TO SCREEN BUFFER\n         SR    R0,R0                    DISPLAY OFFSET\n         LR    R1,R6                    GET ADDRESS TO DUMP\n         LA    R2,JOE3END-JOEDSECT      GET LENGTH TO DUMP\n         QCALL HEXFMT                   CONVERT JQE TO HEX\n          AGO   .FM19\n.FM18     ANOP\n         SPACE 2\nFM$CHKPT TM    JOEFLAG,$JOECKV          IS THE CKPT VALID?\n         BZ    QSTOP                    NO - ALL DONE\n         MVC   QDMSG(FM#CKPTL),FM#CKPT  '   HEX DUMP OF CHK AT MTTR ..'\n         HEX   QDMSG+29,JOECPADR,HEXTAB=QHEXTAB\n         MVI   QDATRNUM+1,2             NUMBER OF ATTR BYTES\n         BAL   R14,QADDLINE             PUT HEADER TO SCREEN BUFFER\n         MVC   QCTRAK,JOECPADR          DISK ADDR OF CHK\n         L     R5,QCBLKA                -> HASPACE BUFFER AREA\n         LR    R1,R5                    PARM FOR READSPC\n         MVC   QCCBID,=C'CHK '          SHOW WHAT WE NEED\n         LR    R0,R9                    -> JQE\n         QCALL READSPC                  READ HASPACE\n         LA    R0,BUFSTART-BUFDSECT     DISPLAY OFFSET\n         LR    R1,R5                    GET ADDRESS TO DUMP\n         L     R15,QCDECB2              -> HASPACE DECB\n         LH    R2,6(,R15)               GET LENGTH TO DUMP ($BUFSIZE)\n         QCALL HEXFMT                   CONVERT JQE TO HEX\n.FM19     ANOP\n         MVI   QDMSG,C'-'               MAKE A LINE ...\n         MVC   QDMSG+1(L'QDMSG-1),QDMSG ... OF DASHES\n         BAL   R14,QADDLINE             ADD DASHES LINE\n         B     QSTOP                    ALL DONE\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*   MISCELLANY                                                        *\n*                                                                     *\n***********************************************************************\n         LTORG\n         SPACE 1\nFM#PNHDR DC    CL(FM@OVERL)'Programmer Name'\n         SPACE 1\nFM#JQE   DC    X'1DE8',C'   Hex dump of JQE at offset xxxxxx in JQT (ad$\n               dr xxxxxx)',X'1D60'\nFM#JQEL  EQU   *-FM#JQE\n         SPACE 1\nFM#JOE   DC    X'1DE8',C'   Hex dump of Work JOE at offset xxxxxx in JO$\n               T (addr xxxxxx)',X'1D60'\nFM#JOEL  EQU   *-FM#JOE\n         SPACE 1\n          AIF   (&QLEVEL LT 5).FM20\nFM#CKPT  DC    X'1DE8',C'   Hex dump of CHK at MTTR xxxxxxxx ',X'1D60'\nFM#CKPTL EQU   *-FM#CKPT\n.FM20     ANOP\n         SPACE 1\nFMTMISC  DC    C'Purg'                  PURGE QUEUE\n         DC    C'Hcpy'                  $HARDCPY  - SHOULD NEVER SHOW\n         DC    C'Outp'                  $OUTPUT   - AWAITING OUTPUT\n          AIF   (&QLEVEL GT 6).FM21\n          AIF   (&QLEVEL LT 4).FM21\n         DC    C'Dump'                  $DUMPQ\n.FM21     ANOP\nFM#RECV  DC    C'Recv'                  $RECEIVE\n         DC    C'Setu'                  $SETUP\nFM#XMIT  DC    C'Xmit'                  $XMIT\n         DC    C'Rdr '                  $INPUT\n         DC    C'I * '                  $XEQ      - CONVERTER\n          AIF   (&QLEVEL GE 4).FM22\n         DC    C'Dmy '                  $DUMMY\n.FM22     ANOP\n         SPACE 2\n*---  SEE DCTDEVID\nFM#DEVTB DC    AL1(6),C'Intrdr '\n         DC    AL1(6),C'Reader '\n         DC    AL1(7),C'Printer'\n         DC    AL1(5),C'Punch  '\n          AIF   (&QLEVEL LT 4).FMDEV1\n         DC    AL1(3),C'Dmpn.JT'\n         DC    AL1(3),C'Lodn.JR'\n         DC    AL1(3),C'Dmpn.ST'\n         DC    AL1(3),C'Lodn.SR'\n.FMDEV1   ANOP\nFM#RMDVS DC    C'**'\n         DC    C'Rd'\n         DC    C'Pr'\n         DC    C'Pu'\n         SPACE 2\nFMHEXTAB EQU   *-C'A'\n         DC    X'0A0B0C0D0E0F'\n         DC    (C'0'-C'F'-1)X'0F'       filler\n         DC    X'00010203040506070809'\n         SPACE 2\n*  TABLE OF NUMBER OF BITS IN A BYTE - SEE KNBITB IN HASPMISC\nFM#BITB  DC    AL1(0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4)\n         DC    AL1(1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5)\n         DC    AL1(1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5)\n         DC    AL1(2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6)\n         DC    AL1(1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5)\n         DC    AL1(2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6)\n         DC    AL1(2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6)\n         DC    AL1(3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7)\n         DC    AL1(1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5)\n         DC    AL1(2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6)\n         DC    AL1(2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6)\n         DC    AL1(3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7)\n         DC    AL1(2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6)\n         DC    AL1(3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7)\n         DC    AL1(3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7)\n         DC    AL1(4,5,5,6,5,6,6,7,5,6,6,7,6,7,7,8)\n         SPACE 2\n         QITEM GEN                      gen qitem table\n         SPACE 2\nWORK     DSECT\n         ORG   WORK+72                  SKIP OVER SAVE AREA\n         SPACE 1\nFM@FLAGS DS    B\nFM@SLOG  EQU   X'80'                    LINE IS FOR \"STATUS SYSLOG\"\nFM@SPIN  EQU   X'40'                    NOW RUNNING DOWN SPIN IOT CHAIN\n         SPACE 1\n*M@TPTR  DS    A                        LCBTPTR\n*M@ADDR1 DS    A                        LCBADDR1\n*M@ADDR2 DS    A                        LCBADDR2\n*M@ID    DS    CL6                      LCBID (JOBID)\n*M@FLD1  DS    CL2                      LCBFLD1\n*M@FLD2  DS    CL8                      LCBFLD2\n*        DS    CL4                      patch space\n         QLCB  PREFIX=FM@\n         SPACE 1\nFM@WORKL EQU   *-WORK                   LENGTH OF LOCAL WORK AREA\n          AIF   (&QLEVEL GE 4).FMDEV2\nFM@DEVID DS    H\n          AGO   .FMDEV3\n.FMDEV2   ANOP\n         DS    0H,X                     ALIGNMENT\nFM@DEVID DS    0XL3,X,H\n.FMDEV3   ANOP\nFMT@WORK DS    CL6,CL10                 CONVERT OUTPUT WORKAREA\nFMT@CONV DS    0D                       CONVERT WORK DOUBLEWORD\nFMT@HEXW DS    CL32                     HEX WORK AREA\n         SPACE 3\n         QCOMMON\n         ORG   QDMSG\nFM@CLEAR DS    0CL80                    FORMAT FOR QUEUE RECORDS\nFM@ATTR1 DS    XL2                      SF, ATTR\nFM@SEL   DS    CL2                      INPUT FIELD\nFM@ATTR2 DS    XL2                      SF, ATTR\nFM@QNAME DS    C                        NAME OF QUEUE (I,O,TSU,STC,H-O)\n         DS    C\nFQUEUE   DS    CL2                      CLASS NAME (IF FM@QNAME=I OR O)\n         DS    C\nFM@COUNT DS    CL4                      POSITION IN QUEUE\n         DS    C\nFM@JNAME DS    CL8                      JOBNAME\nFM@ATTR3 DS    XL2                      SF, ATTR\nFM@JOBID DS    CL5                      JES2 JOB NUMBER\nFM@ATTR4 DS    XL2                      SF, ATTR\nFM@PRTY  DS    CL3                      JOB PRIORITY\nFM@ATTR5 DS    XL2                      SF, ATTR\nFM@LINES DS    CL5                      NUMBER OF OUTPUT LINES\nFM@ATTR6 DS    XL2                      SF, ATTR\nFM@SYSID DS    CL4                      SYSTEM ID\n         DS    C\nFM@HOLD  DS    CL3                      JOB HOLD STATUS\n         DS    C\nFM@OVER  EQU   *\nFM@PGMR  DS    CL20                     PROGRAMMER NAME (DA/DS/DT)\n         ORG   FM@OVER                  BACK AGAIN\nFM@DATE  DS    CL7                      INPUT DATE\n         DS    CL2\nFM@TIME  DS    CL5                      INPUT TIME\n         DS    CL2\nFM@HLCNT DS    CL6\n         ORG   FM@HLCNT+2\nFM@SLID  DS    CL4\n         DS    C\n         ORG   FM@OVER                  BACK AGAIN\nFM@FORM  DS    CL4                      FORM NAME\n         DS    C\nFM@WTRNM DS    CL8                      WRITERNAME (OR USERID)\n         ORG   FM@WTRNM                 OVERLAY WTRNAME OVER FCB/UCS\nFM@FCB   DS    CL4                      FCB NAME\n         DS    C\nFM@UCS   DS    CL4                      UCS NAME\n         DS    C\nFM@DEVNM DS    CL8                      PRINTERN OR RNNN.PRN\n*  THE LAST OVERLAY MUST BE THE LONGEST (CAN'T DO ORG TO END)\nFM@OVERL EQU   *-FM@OVER                LENGTH OF OVERLAY SECTION\nFM@ATTR7 DS    XL2                      SF, ATTR\nFM@FLASH DS    0CL4                     FORMS FLASH\nFM@USER  DS    0CL8                     userid\nFM@WTRNX DS    0CL8                     ALTERNAME FIELD FOR WTRNAME\nFM@REMOT DS    CL8                      REMOTE JOB (RJE)\n         SPACE 3\n         DROPX R9,R8,R13                JQEDSECT, JOEDSECT, WORK\n         SPACE 3\nFORMAT   CSECT                          RESUME\n         PRINT &PRINT                   QCOMMON DOES PRINT NOGEN\n         SPACE 3\n         PRINT &DOC\n         SPACE 2\n         Q$JCT\n         Q$JOE\n         Q$JQE\n         Q$DCT\n         Q$IOT\n         Q$TGM\n         Q$CHK\n         Q$HCT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "Q#FR": {"ttr": 7937, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x10\\x00\\x00\\x00\\x82#/\\x00\\x91\\x16\\x7f!@\\x00\\xe1\\x00y\\x00\\x8e\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "05.16", "flags": 0, "createdate": "1982-08-20T00:00:00", "modifydate": "1991-06-16T21:40:00", "lines": 225, "newlines": 121, "modlines": 142, "user": "LDW"}, "text": "         TITLE '--- QUEUE--FINDRJE -- DETERMINE RJE ID ---'\n*---------------------------------------------------------------------*\n*                                                                     *\n*   FINDRJE - CONVERT INTERNAL ROUTE CODE TO DISPLAY FORMAT           *\n*                                                                     *\n*   ENTRY - R1 = ADDRESS OF 2 BYTE (NON-SP) OR 4 BYTE (SP) ROUTING    *\n*                CODE                                                 *\n*                                                                     *\n*   EXIT - R1 = ADDRESS OF 8 CHAR SYMBOLIC DESTID                     *\n*                                                                     *\n*   NOTE - DUAL (SP & NON-SP) SUPPORT IS DEPENDENT ON LENGTH ATTRS    *\n*          OF CERTAIN DATA ITEMS BEING APPROPRIATE FOR THE SELECTED   *\n*          SYSTEM                                                     *\n*                                                                     *\n*   Updates:                                                          *\n*      06Jun91  EMS  Fix check for primary/alternate JES's matching   *\n*      16Jun90  LDW  Remove mode switching since we now run AMODE 31  *\n*      25Dec89  LDW  Q$xxx -> QZxxx:  CVT, JESCT, SSCT                *\n*      23Nov89  LDW  Remove conditional assembly around Qxxx macros   *\n*      22Mar89  EMS  SP311 updates: no SVT                            *\n*      17Jan87  LDW  Misc cleanup                                     *\n*      12Jan87  LDW  Check for compatible SVT before using primary's  *\n*      04Jan87  LDW  Use CVT instead of CVTDSECT (for XA?)            *\n*      23AUG86  LDW  DELETE Q$XECB (DONE BY Q$SVT)                    *\n*      12/06/85 LDW  ADD Q$XECB FOR SP133 $SVT                        *\n*      06/21/83 LDW  DISPLAY U0 AS BLANK                              *\n*      01/27/83 LDW  DISPLAY N2R0 AS JUST N2                          *\n*      01/24/83 LDW  VALIDITY CHECK $SVSID IF TRYING TO USE THE       *\n*                       PRIMARY SUBSYSTEM'S RDT'S.  THIS IS TO AVOID  *\n*                       THE PROBLEM CASE OF MIXED PRIMARY/SECONDARY   *\n*                       JES'S (ONE SP, THE OTHER NOT).                *\n*      01/03/83 LDW  SP SUPPORT                                       *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 3\nFINDRJE  QSTART  Q81\n         USING WORK,R13                 LOCAL WORK AREA\n         LR    R6,R1                    PRESERVE INPUT ADDR\n         MVC   FR@RJEID,QBLANK          CLEAR RJE NAME\n         CLC   QCLOCAL,0(R6)            IS FILE FOR LOCAL?\n         BE    FR$LEAVE                 YES, LEAVE WITH BLANK NAME\n         CLC   0(L'QCLOCAL,R6),=F'0'    ANYTHING HERE AT ALL????\n         BE    FR$LEAVE                 NO - LEAVE WITH BLANK NAME\n         MVI   FR@RJEID,C'U'            ASSUME UNNN\n         LA    R2,FR@RJEID+1            -> LOCATION FOR NUMBER\n         OC    0(L'QCLNODE,R6),0(R6)    NODE = 0?\n         BZ    FR$NBR                   YES, GO FORMAT UNIT NUMBER\n         MVI   FR@RJEID,C'R'            NO, ASSUME RNNN\n         CLC   QCLNODE,0(R6)            IS FILE FOR OUR NODE?\n         BE    FR$NBR                   YES, GO FORMAT REMOTE NUMBER\n         MVI   FR@RJEID,C'N'            NO, FORMAT NODE NUMBER\n         LA    R3,0(,R6)                -> NODE NUMBER\n         BAL   R4,FR$CONV               CONVERT TO DISPLAY\n         CLC   L'QCLNODE(L'QCLNODE,R6),=H'0'  RMT 0 AT ANOTHER NODE?\n         BE    FR$RMT0                  YES - DON'T DISP AS NXXXR0\n         MVI   0(R2),C'R'               FORMATTED NODE, NOW REMOTE\n         LA    R2,1(,R2)                -> LOCATION FOR NUMBER\nFR$NBR   LA    R3,L'QCLNODE(,R6)        -> REMOTE NUMBER\n         BAL   R4,FR$CONV               FORMAT NUMBER\n         SPACE 1\nFR$RMT0  L     R15,QSSCT                -> SSCT OF SELECTED SUBSYSTEM\n         LTR   R15,R15                  DEFINED SUBSYSTEM?\n         BZ    FR$PRIM                  NO - TRY TO USE PRIMARY\n         USING SSCT,R15\n          AIF  (&QLEVEL GE 9).FR09\n         L     R15,SSCTSSVT             -> SSVT FOR IT\n         DROP  R15\n         USING SSVT,R15\n          AGO  .FR10\n.FR09     ANOP ,\n         L     R15,SSCTSUS2             -> HCCT FOR IT\n         DROP  R15\n         USING HCCT,R15\n.FR10     ANOP ,\n         LTR   R15,R15                  ANY?\n         BNZ   FR$SCAN                  YES - SCAN RDT'S\n         SPACE 1\n* SELECTED SUBSYSTEM IS NOT ACTIVE, TRY TO USE RDT'S FOR PRIMARY SUBSYS\nFR$PRIM  L     R15,CVTPTR               -> CVT\n         USING CVT,R15\n         L     R15,CVTJESCT             -> JESCT\n         USING JESCT,R15\n         L     R15,JESSSCT              -> SSCT\n         USING SSCT,R15\n          AIF  (&QLEVEL LT 8).FR19\n         L     R7,SSCTSUSE              -> HASPSSSM MIT version\n.FR19     ANOP ,\n          AIF  (&QLEVEL GE 9).FR11\n         L     R15,SSCTSSVT             -> SSVT\n         USING SSVT,R15\n          AGO  .FR12\n.FR11     ANOP ,\n         L     R15,SSCTSUS2             -> HCCT FOR IT\n         DROP  R15\n         USING HCCT,R15\n.FR12     ANOP ,\n         LTR   R15,R15                  ANY?\n         BZ    FR$LEAVE                 NO - PRIMARY SUBSYS IS NOT UP\n          AIF   (&QLEVEL GE 8).FR20\n*  IF NEITHER THE SELECTED SUBSYS OR THE PRIMARY SUBSYS ARE UP, WE WILL\n*  LEAVE THE DESTINATION FORMATTED AS NXXX.RXXX\n**%%     TM    $SVSID,X'80'             CRUMMY CHECK FOR VALID SID\n**%%     BNO   FR$LEAVE                 NOT VALID - MUST BE ADDR\n*---  THIS REALLY IS A MISERABLY LOUSY CHECK, BUT I CAN'T THINK OF ---*\n*---  ANY BETTER WAY AT THE MOMENT, SO IT'LL HAVE TO DO.  THIS IS  ---*\n*---  ONLY A PROBLEM WHEN WORKING WITH A SECONDARY JES OF A THE    ---*\n*---  WRONG TYPE, AND WHEN IT IS NOT UP                            ---*\n*\n*---  Check to see that the primary JES2's $SVT is the same length ---*\n*---  as the one that this load module is assembled for.           ---*\n         LR    R14,R15                  COPY $SVT PTR\n         SH    R14,=H'8'                BACK UP TO PREFIX\n          AIF  (&QLEVEL GE 9).FR17\n         CLC   =C'SSVT',0(R14)          IDENTIFIER CORRECT?\n         BNE   FR$LEAVE                 NO - SOMETHING'S VERY WRONG\n         CLC   =A(SVTLEN+8),4(R14)      LENGTH CORRECT?\n         BNE   FR$LEAVE                 NO - PRIMARY IS DIFFERENT REL\n          AGO  .FR18\n.FR17     ANOP ,\n         CLC   =C'HCCTU',0(R14)         IDENTIFIER CORRECT?\n         BNE   FR$LEAVE                 NO - SOMETHING'S VERY WRONG\n*%%      CLC   =A(CCTLEN+8),6(R14)      LENGTH CORRECT?\n*%%      BNE   FR$LEAVE                 NO - PRIMARY IS DIFFERENT REL\n          AGO   .FR18\n.FR20     ANOP\n         CLC   QJ2VERSN,0(R7)           correct JES2 level for us?\n         BNE   FR$LEAVE                 no, exit stage right\n.FR18     ANOP ,\n         SPACE 1\nFR$SCAN  L     R3,$SVRDT                -> FIRST RDT\n          AIF  (&QLEVEL GE 9).FR13\n         L     R5,$SVRDTE               -> LAST RDT\n.FR13     ANOP ,\n         DROP  R15\n         USING RDTDSECT,R3\n         LA    R4,RDTSIZ                LENGTH OF RDT (BXLE INCR)\n         SPACE 2\n*---  SINCE JES2 DOES NOT FILL IN INFORMATION INTO THE RDT WHICH   ---*\n*---  WAS NOT EXPLICITLY ON THE DESTID CARD, WE MUST NOW FIGURE    ---*\n*---  OUT THE FULL DESTINATION ID BY FACTORING IN THE ASSUMPTIONS  ---*\n*---  (IN OTHER WORDS, IF THE NODE NUMBER IS NOT IN THIS RDT,      ---*\n*---  USE OUR LOCAL NODE NUMBER.  IF THIS RDT DESCRIBES A UNIT,    ---*\n*---  FORCE THE NODE TO ZERO.)                                     ---*\n         SPACE 2\nFR$LOOP  MVC   FR@RDTID,QCLOCAL         ASSUME DEST=LOCAL\n         TM    RDTFLAG,RDTFLAGN         RDT SPECIFY NODE?\n         BNO   FR$L01                   NO, USE ASSUMED NODE\n         MVC   FR@NODE,RDTNODE          LOOK FOR SPECIFIED NODE\n         SPACE 1\nFR$L01   TM    RDTFLAG,RDTFLAGR+RDTFLAGU   RDT SPECIFY NUMBER?\n         BZ    FR$L02                   NO, USE ASSUMED NUMBER\n         MVC   FR@NBR,RDTRMTNO          LOOK FOR SPECIFIED NUMBER\n         TM    RDTFLAG,RDTFLAGU         IS NUMBER A UNIT?\n         BNO   FR$L02                   NO, NODE IS FINE\n         XC    FR@NODE,FR@NODE          FORCE TO DUMMY NODE\n         SPACE 1\nFR$L02   CLC   FR@RDTID,0(R6)           IS THIS THE RIGHT RDT?\n         BNE   FR$BXLE                  NO - SKIP THIS RDT\n         MVC   FR@RJEID,RDTNAME         GET THE UNIT NAME\n         B     FR$LEAVE                 ALL DONE\n         SPACE 1\n          AIF  (&QLEVEL GE 9).FR14\nFR$BXLE  BXLE  R3,R4,FR$LOOP            SCAN ALL RDT'S\n          AGO  .FR15\n.FR14     ANOP ,\nFR$BXLE  ICM   R3,B'1111',RDTRDT        scan all\n         BNZ   FR$LOOP                           RDT's\n.FR15     ANOP ,\n         SPACE 1\nFR$LEAVE LA    R1,FR@RJEID              PASS BACK ADDR OF REMOTE NAME\n         B     QSTOP                    BYE\n         SPACE 2\n* CONVERT NUMBER FOR DISPLAY\n* INPUT:   R2 -- -> THREE BYTE OUTPUT AREA\n          AIF   (&QLEVEL GE 4).FR01\n*          R3 -- -> ONE BYTE BINARY NUMBER\n          AGO   .FR02\n.FR01     ANOP\n*          R3 -- -> TWO BYTE BINARY NUMBER\n.FR02     ANOP\n*          R4 -- RETURN ADDRESS\n* OUTPUT:  R2 -- UPDATED -> OUTPUT AREA\n          AIF   (&QLEVEL GE 4).FR03\nFR$CONV  SR    R0,R0                    CLEAR FOR IC\n         IC    R0,0(,R3)                GET NNN\n          AGO   .FR04\n.FR03     ANOP\nFR$CONV  LH    R0,0(,R3)                GET NNN\n.FR04     ANOP\n         CVD   R0,FR@CONV               PREPARE TO PRINT\n         MVC   FR@CONV(6),=X'402021204040'  EDIT MASK\n         LA    R1,FR@CONV+3             INITIALIZE FOR EDMK\n         EDMK  FR@CONV(4),FR@CONV+6     EDIT NUMBER, SET R1\n         MVC   0(3,R2),0(R1)            MOVE DATA TO OUTPUT\n         LA    R0,FR@CONV+4             END OF DATA PLUS ONE\n         SR    R0,R1                    LENGTH OF DATA\n         AR    R2,R0                    UPDATE DATA POINTER\n         BR    R4                       RETURN TO CALLER\n         DROP  R13\n         SPACE 2\n         LTORG\n         SPACE 2\n         QCOMMON\nWORK     DSECT\n         ORG   WORK+72                  SKIP OVER SAVE AREA\nFR@RJEID DS    CL8                      OUTPUT AREA\n         SPACE 1\nFR@CONV  DS    0D                       WORK AREA\n          AIF   (&QLEVEL GE 4).FR05\nFR@RDTID DS    0XL2                     WORKING ID OF RDT\nFR@NODE  DS    X                        NODE OF RDTID\nFR@NBR   DS    X                        NUMBER OF RDTID\n          AGO   .FR06\n.FR05     ANOP\nFR@RDTID DS    0XL4                     WORKING ID OF RDT\nFR@NODE  DS    H                        NODE OF RDTID\nFR@NBR   DS    H                        NUMBER OF RDTID\n.FR06     ANOP\n         SPACE 2\n         Q$SVT\n         Q$HCCT\n         Q$RDT\n         QZCVT\n         QZJESCT\n         QZSSCT\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "Q#FR@": {"ttr": 7942, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x0f\\x00\\x00\\x00\\x82#/\\x00\\x90\\x16\\x7f#)\\x00\\xd8\\x00y\\x00\\x85\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "05.15", "flags": 0, "createdate": "1982-08-20T00:00:00", "modifydate": "1990-06-16T23:29:00", "lines": 216, "newlines": 121, "modlines": 133, "user": "LDW"}, "text": "         TITLE '--- QUEUE--FINDRJE -- DETERMINE RJE ID ---'\n*---------------------------------------------------------------------*\n*                                                                     *\n*   FINDRJE - CONVERT INTERNAL ROUTE CODE TO DISPLAY FORMAT           *\n*                                                                     *\n*   ENTRY - R1 = ADDRESS OF 2 BYTE (NON-SP) OR 4 BYTE (SP) ROUTING    *\n*                CODE                                                 *\n*                                                                     *\n*   EXIT - R1 = ADDRESS OF 8 CHAR SYMBOLIC DESTID                     *\n*                                                                     *\n*   NOTE - DUAL (SP & NON-SP) SUPPORT IS DEPENDENT ON LENGTH ATTRS    *\n*          OF CERTAIN DATA ITEMS BEING APPROPRIATE FOR THE SELECTED   *\n*          SYSTEM                                                     *\n*                                                                     *\n*   Updates:                                                          *\n*      16Jun90  LDW  Remove mode switching since we now run AMODE 31  *\n*      25Dec89  LDW  Q$xxx -> QZxxx:  CVT, JESCT, SSCT                *\n*      23Nov89  LDW  Remove conditional assembly around Qxxx macros   *\n*      22Mar89  EMS  SP311 updates: no SVT                            *\n*      17Jan87  LDW  Misc cleanup                                     *\n*      12Jan87  LDW  Check for compatible SVT before using primary's  *\n*      04Jan87  LDW  Use CVT instead of CVTDSECT (for XA?)            *\n*      23AUG86  LDW  DELETE Q$XECB (DONE BY Q$SVT)                    *\n*      12/06/85 LDW  ADD Q$XECB FOR SP133 $SVT                        *\n*      06/21/83 LDW  DISPLAY U0 AS BLANK                              *\n*      01/27/83 LDW  DISPLAY N2R0 AS JUST N2                          *\n*      01/24/83 LDW  VALIDITY CHECK $SVSID IF TRYING TO USE THE       *\n*                       PRIMARY SUBSYSTEM'S RDT'S.  THIS IS TO AVOID  *\n*                       THE PROBLEM CASE OF MIXED PRIMARY/SECONDARY   *\n*                       JES'S (ONE SP, THE OTHER NOT).                *\n*      01/03/83 LDW  SP SUPPORT                                       *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 3\nFINDRJE  QSTART  Q81\n         USING WORK,R13                 LOCAL WORK AREA\n         LR    R6,R1                    PRESERVE INPUT ADDR\n         MVC   FR@RJEID,QBLANK          CLEAR RJE NAME\n         CLC   QCLOCAL,0(R6)            IS FILE FOR LOCAL?\n         BE    FR$LEAVE                 YES, LEAVE WITH BLANK NAME\n         CLC   0(L'QCLOCAL,R6),=F'0'    ANYTHING HERE AT ALL????\n         BE    FR$LEAVE                 NO - LEAVE WITH BLANK NAME\n         MVI   FR@RJEID,C'U'            ASSUME UNNN\n         LA    R2,FR@RJEID+1            -> LOCATION FOR NUMBER\n         OC    0(L'QCLNODE,R6),0(R6)    NODE = 0?\n         BZ    FR$NBR                   YES, GO FORMAT UNIT NUMBER\n         MVI   FR@RJEID,C'R'            NO, ASSUME RNNN\n         CLC   QCLNODE,0(R6)            IS FILE FOR OUR NODE?\n         BE    FR$NBR                   YES, GO FORMAT REMOTE NUMBER\n         MVI   FR@RJEID,C'N'            NO, FORMAT NODE NUMBER\n         LA    R3,0(,R6)                -> NODE NUMBER\n         BAL   R4,FR$CONV               CONVERT TO DISPLAY\n         CLC   L'QCLNODE(L'QCLNODE,R6),=H'0'  RMT 0 AT ANOTHER NODE?\n         BE    FR$RMT0                  YES - DON'T DISP AS NXXXR0\n         MVI   0(R2),C'R'               FORMATTED NODE, NOW REMOTE\n         LA    R2,1(,R2)                -> LOCATION FOR NUMBER\nFR$NBR   LA    R3,L'QCLNODE(,R6)        -> REMOTE NUMBER\n         BAL   R4,FR$CONV               FORMAT NUMBER\n         SPACE 1\nFR$RMT0  L     R15,QSSCT                -> SSCT OF SELECTED SUBSYSTEM\n         LTR   R15,R15                  DEFINED SUBSYSTEM?\n         BZ    FR$PRIM                  NO - TRY TO USE PRIMARY\n         USING SSCT,R15\n          AIF  (&QLEVEL GE 9).FR09\n         L     R15,SSCTSSVT             -> SSVT FOR IT\n         DROP  R15\n         USING SSVT,R15\n          AGO  .FR10\n.FR09     ANOP ,\n         L     R15,SSCTSUS2             -> HCCT FOR IT\n         DROP  R15\n         USING HCCT,R15\n.FR10     ANOP ,\n         LTR   R15,R15                  ANY?\n         BNZ   FR$SCAN                  YES - SCAN RDT'S\n         SPACE 1\n* SELECTED SUBSYSTEM IS NOT ACTIVE, TRY TO USE RDT'S FOR PRIMARY SUBSYS\nFR$PRIM  L     R15,CVTPTR               -> CVT\n         USING CVT,R15\n         L     R15,CVTJESCT             -> JESCT\n         USING JESCT,R15\n         L     R15,JESSSCT              -> SSCT\n         USING SSCT,R15\n          AIF  (&QLEVEL GE 9).FR11\n         L     R15,SSCTSSVT             -> SSVT\n         USING SSVT,R15\n          AGO  .FR12\n.FR11     ANOP ,\n         L     R15,SSCTSUS2             -> HCCT FOR IT\n         DROP  R15\n         USING HCCT,R15\n.FR12     ANOP ,\n         LTR   R15,R15                  ANY?\n         BZ    FR$LEAVE                 NO - PRIMARY SUBSYS IS NOT UP\n*  IF NEITHER THE SELECTED SUBSYS OR THE PRIMARY SUBSYS ARE UP, WE WILL\n*  LEAVE THE DESTINATION FORMATTED AS NXXX.RXXX\n**%%     TM    $SVSID,X'80'             CRUMMY CHECK FOR VALID SID\n**%%     BNO   FR$LEAVE                 NOT VALID - MUST BE ADDR\n*---  THIS REALLY IS A MISERABLY LOUSY CHECK, BUT I CAN'T THINK OF ---*\n*---  ANY BETTER WAY AT THE MOMENT, SO IT'LL HAVE TO DO.  THIS IS  ---*\n*---  ONLY A PROBLEM WHEN WORKING WITH A SECONDARY JES OF A THE    ---*\n*---  WRONG TYPE, AND WHEN IT IS NOT UP                            ---*\n*\n*---  Check to see that the primary JES2's $SVT is the same length ---*\n*---  as the one that this load module is assembled for.           ---*\n         LR    R14,R15                  COPY $SVT PTR\n         SH    R14,=H'8'                BACK UP TO PREFIX\n          AIF  (&QLEVEL GE 9).FR17\n         CLC   =C'SSVT',0(R14)          IDENTIFIER CORRECT?\n         BNE   FR$LEAVE                 NO - SOMETHING'S VERY WRONG\n         CLC   =A(SVTLEN+8),4(R14)      LENGTH CORRECT?\n         BNE   FR$LEAVE                 NO - PRIMARY IS DIFFERENT REL\n          AGO  .FR18\n.FR17     ANOP ,\n         CLC   =C'HCCTU',0(R14)         IDENTIFIER CORRECT?\n         BNE   FR$LEAVE                 NO - SOMETHING'S VERY WRONG\n*%%      CLC   =A(CCTLEN+8),6(R14)      LENGTH CORRECT?\n*%%      BNE   FR$LEAVE                 NO - PRIMARY IS DIFFERENT REL\n.FR18     ANOP ,\n         SPACE 1\nFR$SCAN  L     R3,$SVRDT                -> FIRST RDT\n          AIF  (&QLEVEL GE 9).FR13\n         L     R5,$SVRDTE               -> LAST RDT\n.FR13     ANOP ,\n         DROP  R15\n         USING RDTDSECT,R3\n         LA    R4,RDTSIZ                LENGTH OF RDT (BXLE INCR)\n         SPACE 2\n*---  SINCE JES2 DOES NOT FILL IN INFORMATION INTO THE RDT WHICH   ---*\n*---  WAS NOT EXPLICITLY ON THE DESTID CARD, WE MUST NOW FIGURE    ---*\n*---  OUT THE FULL DESTINATION ID BY FACTORING IN THE ASSUMPTIONS  ---*\n*---  (IN OTHER WORDS, IF THE NODE NUMBER IS NOT IN THIS RDT,      ---*\n*---  USE OUR LOCAL NODE NUMBER.  IF THIS RDT DESCRIBES A UNIT,    ---*\n*---  FORCE THE NODE TO ZERO.)                                     ---*\n         SPACE 2\nFR$LOOP  MVC   FR@RDTID,QCLOCAL         ASSUME DEST=LOCAL\n         TM    RDTFLAG,RDTFLAGN         RDT SPECIFY NODE?\n         BNO   FR$L01                   NO, USE ASSUMED NODE\n         MVC   FR@NODE,RDTNODE          LOOK FOR SPECIFIED NODE\n         SPACE 1\nFR$L01   TM    RDTFLAG,RDTFLAGR+RDTFLAGU   RDT SPECIFY NUMBER?\n         BZ    FR$L02                   NO, USE ASSUMED NUMBER\n         MVC   FR@NBR,RDTRMTNO          LOOK FOR SPECIFIED NUMBER\n         TM    RDTFLAG,RDTFLAGU         IS NUMBER A UNIT?\n         BNO   FR$L02                   NO, NODE IS FINE\n         XC    FR@NODE,FR@NODE          FORCE TO DUMMY NODE\n         SPACE 1\nFR$L02   CLC   FR@RDTID,0(R6)           IS THIS THE RIGHT RDT?\n         BNE   FR$BXLE                  NO - SKIP THIS RDT\n         MVC   FR@RJEID,RDTNAME         GET THE UNIT NAME\n         B     FR$LEAVE                 ALL DONE\n         SPACE 1\n          AIF  (&QLEVEL GE 9).FR14\nFR$BXLE  BXLE  R3,R4,FR$LOOP            SCAN ALL RDT'S\n          AGO  .FR15\n.FR14     ANOP ,\nFR$BXLE  ICM   R3,B'1111',RDTRDT        scan all\n         BNZ   FR$LOOP                           RDT's\n.FR15     ANOP ,\n         SPACE 1\nFR$LEAVE LA    R1,FR@RJEID              PASS BACK ADDR OF REMOTE NAME\n         B     QSTOP                    BYE\n         SPACE 2\n* CONVERT NUMBER FOR DISPLAY\n* INPUT:   R2 -- -> THREE BYTE OUTPUT AREA\n          AIF   (&QLEVEL GE 4).FR01\n*          R3 -- -> ONE BYTE BINARY NUMBER\n          AGO   .FR02\n.FR01     ANOP\n*          R3 -- -> TWO BYTE BINARY NUMBER\n.FR02     ANOP\n*          R4 -- RETURN ADDRESS\n* OUTPUT:  R2 -- UPDATED -> OUTPUT AREA\n          AIF   (&QLEVEL GE 4).FR03\nFR$CONV  SR    R0,R0                    CLEAR FOR IC\n         IC    R0,0(,R3)                GET NNN\n          AGO   .FR04\n.FR03     ANOP\nFR$CONV  LH    R0,0(,R3)                GET NNN\n.FR04     ANOP\n         CVD   R0,FR@CONV               PREPARE TO PRINT\n         MVC   FR@CONV(6),=X'402021204040'  EDIT MASK\n         LA    R1,FR@CONV+3             INITIALIZE FOR EDMK\n         EDMK  FR@CONV(4),FR@CONV+6     EDIT NUMBER, SET R1\n         MVC   0(3,R2),0(R1)            MOVE DATA TO OUTPUT\n         LA    R0,FR@CONV+4             END OF DATA PLUS ONE\n         SR    R0,R1                    LENGTH OF DATA\n         AR    R2,R0                    UPDATE DATA POINTER\n         BR    R4                       RETURN TO CALLER\n         DROP  R13\n         SPACE 2\n         LTORG\n         SPACE 2\n         QCOMMON\nWORK     DSECT\n         ORG   WORK+72                  SKIP OVER SAVE AREA\nFR@RJEID DS    CL8                      OUTPUT AREA\n         SPACE 1\nFR@CONV  DS    0D                       WORK AREA\n          AIF   (&QLEVEL GE 4).FR05\nFR@RDTID DS    0XL2                     WORKING ID OF RDT\nFR@NODE  DS    X                        NODE OF RDTID\nFR@NBR   DS    X                        NUMBER OF RDTID\n          AGO   .FR06\n.FR05     ANOP\nFR@RDTID DS    0XL4                     WORKING ID OF RDT\nFR@NODE  DS    H                        NODE OF RDTID\nFR@NBR   DS    H                        NUMBER OF RDTID\n.FR06     ANOP\n         SPACE 2\n         Q$SVT\n         Q$HCCT\n         Q$RDT\n         QZCVT\n         QZJESCT\n         QZSSCT\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "Q#GP": {"ttr": 7947, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x87\\x15_\\x00\\x90!/\\x12$\\x00\\xa0\\x00d\\x00\\n\\xc5\\xd4\\xe2@@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1987-06-04T00:00:00", "modifydate": "1990-07-31T12:24:00", "lines": 160, "newlines": 100, "modlines": 10, "user": "EMS"}, "text": "    TITLE '--- QUEUE--GETPDDB -- GET A PDDB FROM CURRENT SPOOL IOT ---'\n*---------------------------------------------------------------------*\n*                                                                     *\n*   GETPDDB - GET EITHER NEXT OR A SPECIFIC PDDB FROM THE CURRENTLY   *\n*            SELECTED JOB                                             *\n*                                                                     *\n*   ENTRY - QGPFLAG set bits                                          *\n*           QPFINIT init to first pddb (seq processing)               *\n*           QPFDIR  get specific pddb id in QPDSID                    *\n*           QPFSPIN processing SPIN IOT chain (or start on for init)  *\n*           QPFNMSG suppress QTILT on not found                       *\n*           QPFSNUL suppress null PDDB's                              *\n*           QPFNOSW don't switch IOT chains                           *\n*           QPFNIOT just read a new IOT                               *\n*                                                                     *\n*   EXIT  - R1    -> new current PDDB                                 *\n*                                                                     *\n*   UPDATES:                                                          *\n*     31Jul90  EMS  Update for SP313                                  *\n*     17Jul87  EMS  Fix for first IOT in spin IOT chain               *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 3\nGETPDDB  QSTART  Q??,WORKLEN=GP@WORKL\n         USNGX WORK,R13\n         L     R3,QCIOTA                Load base reg\n         USNGX IOTSTART,R3              BASE REG FOR IOT\n         LR    R5,R3                    IOAREA FOR READ IOT BLOCK\n         MVI   GP@FLAGS,0               clear flags\n         NI    QGPFLAG,255-QPFNIOT      no new iot\n         TM    QGPFLAG,QPFINIT+QPFDIR   Init/Direct REQ?\n         BNZ   GP$FIOT                  yes - GO GET A PDDB\n         SPACE 1\n         LH    R6,QCPDBOFF              CURRENT PDDB OFFSET\n         AR    R6,R3                    -> LAST ONE PROCESSED\n         LR    R4,R3                    BASE OF IOT\n         A     R4,IOTPDDBP              OFFSET BEYOND LAST PDDB\n         SH    R4,=Y(BUFSTART-BUFDSECT) ACCOUNT FOR BUFFER PREFIX\n         B     GP$DS$NX                 GET NEXT ONE\n         SPACE 1\nGP$FIOT  MVC   QCCBID,=CL4'IOT'         REQ IOT\n         L     R4,QCJCTA                -> jct\n         L     R4,JCTIOT-JCTSTART(,R4)  GET MTTR\n         TM    QGPFLAG,QPFSPIN          start on spin iots?\n         BZ    GP$RIOT                  no, get first iot\n         L     R4,QCJCTA                -> jct\n         ICM   R4,B'1111',JCTSPIOT-JCTSTART(R4)  Get MTTR\n         BZ    GP$TILT2                 if none, exit now\nGP$RIOT  BAL   R8,GP$READ               GET FIRST IOT\n         OI    QGPFLAG,QPFNIOT          now got new iot\n***********************************************************************\n*                                                                     *\n*   LOCATE PDDB FOR DATASET SPECIFIED IN QPDSID                       *\n*                                                                     *\n***********************************************************************\nGP$NXIOT LR    R4,R3                    BASE OF IOT\n         A     R4,IOTPDDBP              OFFSET BEYOND LAST PDDB\n         SH    R4,=Y(BUFSTART-BUFDSECT) ACCOUNT FOR BUFFER PREFIX\n         LR    R6,R3                    BASE OF IOT\n          AIF   (&QLEVEL GE 5).GP01\n         A     R6,QCPDDB1               OFFSET TO FIRST PDDB IN IOT\n          AGO   .GP02\n.GP01     ANOP\n         A     R6,IOTPDDB               OFFSET TO FIRST PDDB IN IOT\n         SH    R6,=Y(BUFSTART-BUFDSECT) ACCOUNT FOR BUFFER PREFIX\n.GP02     ANOP\n         USNGX PDBDSECT,R6              BASE REG FOR PDDB\nGP$DS$LP TM    QGPFLAG,QPFDIR           direct request?\n         BZ    GP$FOUND                 no, return with PDDB addr\n         CLC   =C'$JESNEWS',QJOBNAME    IS THIS THE JESNEWS DATASET?\n         BE    GP$FOUND                 YES - JUST USE THE FIRST PDDB\n         CLC   QPDSID,PDBDSKEY          IS THIS THE DATASET?\n         BE    GP$FOUND                 YES. CONTINUE.\nGP$DS$NX LA    R6,PDBLENG(,R6)          NO. LOOK AT NEXT PDDB.\n         CR    R6,R4                    HAVE WE PAST THE LAST PDDB?\n         BL    GP$DS$LP                 NO. TRY AGAIN.\n         L     R4,IOTIOTTR              DISK ADDR OF NEXT IOT\nGP$SPIN  LTR   R4,R4                    IS THERE ANOTHER IOT?\n         BNZ   GP$RIOT                  yes - read it\n*  Fall through to search spin iot chain\nGP$SPIOT TM    QGPFLAG,QPFSPIN          SPIN IOT SEARCHED YET?\n         BO    GP$TILT2                 YES - TILT\n         TM    QGPFLAG,QPFNOSW          don't switch iot chains?\n         BO    GP$TILT2                 yes - tilt\n         OI    QGPFLAG,QPFSPIN          SET SWITCH\n         L     R1,QCJCTA                LOAD BASE REG\n         L     R4,JCTSPIOT-JCTSTART(,R1)  DISK ADDR OF SPIN IOT\n         B     GP$SPIN                  SEARCH THE SPIN IOT CHAIN\n         SPACE 1\nGP$TILT2 XR    R6,R6                    clear jic\n         TM    QGPFLAG,QPFDIR           direct req?\n         BZ    GP$EXIT                  no, exit now\n         LA    R6,GP@PDDB               -> null pddb\n         LNR   R6,R6                    indicate null\n         TM    GP@FLAGS,GP@FNULL        did we get one already?\n         BO    GP$EXIT                  yes, return with it\n         NI    QFLAG2,255-Q2VALIDS      NULLIFY VALIDITY FOR LISTDS\n         TM    QGPFLAG,QPFNMSG          suppress msg?\n         BO    GP$EXIT                  yes, skip it\n         MVC   QERRMSG,QBLANK           CLEAR THE MSG AREA\n         MVC   QERRMSG(14),=C'*** DATASET ID'\n         MVC   QERRMSG+15(8),QDHDSID    SHOW THE DSID\n         MVC   QERRMSG+24(13),=C'NOT FOUND ***'\n         QTILT *,OPTIONS=REPROMPT\n         SPACE 1\nGP$FOUND TM    QGPFLAG,QPFDIR           direct mode?\n         BZ    GP$TNULL                 no, exit\n         TM    PDBFLAG1,PDB1NULL        null pddb?\n         BZ    GP$EXIT                  no, use it\n          AIF   (&QLEVEL GE 10).GP03\n         MVC   GP@PDDB,PDBDSECT         save null pddb\n          AGO  .GP04\n.GP03     ANOP\n         MVC   GP@PDDB(256),PDBDSECT    save null pddb\n         MVC   GP@PDDB+256(L'GP@PDDB-256),PDBDSECT+256  get it all\n.GP04     ANOP\n         OI    GP@FLAGS,GP@FNULL        indicate we got it\n         B     GP$DS$NX                 and try again\nGP$TNULL TM    QGPFLAG,QPFSNUL          suppress null pddbs?\n         BZ    GP$EXIT                  no, exit\n         TM    PDBFLAG1,PDB1NULL        null pddb?\n         BZ    GP$EXIT                  no, use it\n         B     GP$DS$NX                 yes, try next one\nGP$EXIT  NI    QGPFLAG,255-QPFINIT-QPFDIR\n         LR    R1,R6                    copy addr for return\n         S     R6,QCIOTA                get offset into iot\n         STH   R6,QCPDBOFF              save for next pass\n         B     QSTOP\n         SPACE 3\n         DROPX R6,R13                   PDBDSECT,work\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*   READ A BLOCK FROM HASPACE                                         *\n*                                                                     *\n***********************************************************************\nGP$READ  ST    R4,QCTRAK                STORE DISK ADDR\n         LR    R1,R5                    IOAREA ADDRESS\n         QCALL READSPC                  READ HASPACE\n         BR    R8                       RETURN TO CALLER\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*   MISCELLANY                                                        *\n*                                                                     *\n***********************************************************************\n         LTORG ,\n         SPACE 3\nWORK     DSECT ,\n         ORG   WORK+72\nGP@FLAGS DS    X                        misc flags\nGP@FNULL EQU   X'80'                    found a null pddb (direct)\nGP@PDDB  DS    XL(PDBLENG)              save area for null pddb\nGP@WORKL EQU   *-WORK                   len of workarea\n         SPACE 3\n         QCOMMON\n         SPACE 3\n         Q$JCT\n         Q$IOT\n         Q$PDDB\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "Q#GR": {"ttr": 8194, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0c\\x00\\x00\\x00\\x825o\\x00\\x91\\x18\\x1f\\x00\\x01\\x01`\\x00\\xc5\\x01\\x1e\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.12", "flags": 0, "createdate": "1982-12-22T00:00:00", "modifydate": "1991-06-30T00:01:00", "lines": 352, "newlines": 197, "modlines": 286, "user": "LDW"}, "text": "    TITLE '--- QUEUE--GETREC -- GET A RECORD FROM CURRENT SPOOL DS ---'\n*---------------------------------------------------------------------*\n*                                                                     *\n*   GETREC - Get either next or a specific record from the currently  *\n*            selected spooled dataset                                 *\n*                                                                     *\n*   Entry - R4>0  -> current record (described by $LRC macro)         *\n*           R4=0 ==> start at top of dataset                          *\n*           R4<0 ==> start at record number in \"QPREC\"                *\n*                                                                     *\n*   Exit  - R4    -> new current record, or zero if end of dataset    *\n*           R6    =  record data length                               *\n*                                                                     *\n*   Note - Registers R4 and R5 must be preserved across calls         *\n*                                                                     *\n*   Updates:                                                          *\n*      29Jun91  LDW  Integrate GLA fixes below:                       *\n*     (10Jul90) GLA  Fix test for valid block after read              *\n*      15Dec90  EMS  Update for SP410                                 *\n*      25Dec89  LDW  QDCBD -> QZDCBD                                  *\n*      31May89  LDW  Do it without conditional assembly               *\n*      26Apr89  EMS  Update for SP311                                 *\n*       8Aug87  EMS  Add \"PAGE\" command support                       *\n*                    fix bug running off end of getrec table          *\n*       8Jul87  EMS  Fix more 0c7 abends (wierd sequences)            *\n*                    Delete QCEND                                     *\n*                    Update for GETPDDB  routine                      *\n*      22May87  EMS  Update to reload r6 across calls                 *\n*                    Fix misc 0c7 abends                              *\n*                    Add support for LISTDS                           *\n*                    Remove restrictions on regs during reentry       *\n*      01/27/83 LDW  FIX END OF DISK BLOCK PROCESSING                 *\n*      01/05/83 LDW  IDEA FOR THIS ROUTINE STOLEN FROM SKIP ROBINSON  *\n*                       (THIS CODE ADAPTED FROM LISTDS - SKIP GOT     *\n*                       HIS FROM SAVEDS)                              *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 3\nGETREC   QSTART  WORKLEN=GR@WORKL\n         SPACE 1\n         USNGX WORK,R13\n         SPACE 2\n         L     R2,QCSTART               -> start of table\n         A     R2,QCSIZE                + current size\n         SH    R2,=Y(GR@TBLL)           -> last usable entry in table\n         ST    R2,GR@CEND               save for later\n         ZAP   GR@PREC,QPREC            set to current\n         SP    GR@PREC,=P'1'            origin 0 now\n         XR    R1,R1\n         ICM   R1,B'0001',QPLINECT      pdblinct valid?\n         BNZ   GR$INICT\n         ICM   R1,B'0001',QJLINECT      jctlinct valid?\n         BNZ   GR$INICT\n         ICM   R1,B'0001',QSLINECT      $linect valid?\n         BNZ   GR$INICT\n         ICM   R1,B'0001',QMLINECT      Mode value valid?\n         BNZ   GR$INICT\n         LA    R1,60                    use 60 if all invalid\nGR$INICT CVD   R1,GR@DWD\n         ZAP   GR@LINCT,GR@DWD\n         L     R2,QCCPTR                -> CURRENT DISK ADDR TABLE ENT\n         L     R5,QCBLKA                -> buffer\n         USNGX BUFSTART,R5\n         TM    QCRFLAG,QRFINIT          req init?\n         BZ    GR$INITC                 no, continue\n         ZAP   QCHREC,=P'0'             clear high\n         MVC   QCHPTR,QCSTART                     wm\n         NI    QCRFLAG,255-QRFINIT-QRFEOF-QRFERR     clear flags\n         L     R2,QCSTART               -> head of table\n         USNGX GR@TBL,R2\n         MVC   GR@MTTR,QCGRMTTR         set starting mttr\n         B     GR$INT                   start at top\nGR$INITC LTR   R4,R4                    DETERMINE FUNCTION DESIRED\n         BP    GR$NXT                   continue with next record\n         BM    GR$REPOS                 START AT SPECIFIED RECORD NBR\n***********************************************************************\n*                                                                     *\n*   REPOSITION TO TOP OF DATASET                                      *\n*                                                                     *\n***********************************************************************\nGR$INT   L     R2,QCSTART               BEGINNING OF DISK ADDR TABLE\n         L     R4,GR@MTTR               DISK ADDR OF TOP OF DATASET\n         MVC   QCCREC(12),GR#LTOP       Zero current record no\n         TM    QCRECFM,DCBRECCC         control chars in dsid?\n         BO    *+10                     yes, skip update\n         ZAP   QCCPAGE,=P'1'            set to page 1\n         ST    R2,QCCPTR                BEGIN OF TBL\n**%%     ZAP   QCHREC,=P'0'             ZERO HIGH REC NO\n**%%     MVC   QCHPTR,QCSTART           BEGIN OF TBL\n         ZAP   QPREC,=P'1'              REPOSITION TO TOP OF DATASET\n         ZAP   QCRHOLD,=P'0'            clear out garbage\n         NI    QCRFLAG,255-QRFSKP1      here too.\n         B     GR$FIRST                 PROCESS DATASET\n***********************************************************************\n*                                                                     *\n*   PROCESS DATASET                                                   *\n*                                                                     *\n***********************************************************************\nGR$NXTBL L     R4,HDBNXTRK              DISK ADDR OF NEXT BLOCK\n         LA    R2,GR@TBLL(,R2)          -> next table entry\nGR$FIRST LTR   R4,R4                    IS THE DISK ADDR ZERO?\n         BZ    GR$END                   YES - END OF DATASET\n         ST    R4,GR@MTTR               STORE DISK ADDR IN TABLE\n***********************************************************************\n*                                                                     *\n*   READ A BLOCK FROM HASPACE                                         *\n*                                                                     *\n***********************************************************************\n         ST    R4,QCTRAK                STORE DISK ADDR\n         NI    QCRFLAG,255-QRFERR       Clear error indicator\n         LR    R1,R5                    -> ioarea\n         QCALL READSPC                  READ HASPACE\n         CLC   HDBKEY,QPJOBID           Does full jobid match?\n         BE    GR$OKBLK                 yes, use block\n         CLC   QPJOBID,HDBJBKEY         check jobid name\n         BNE   GR$ERR                   NO - block gone - error\n         CLC   =C'$JESNEWS',QJOBNAME    is it jesnews?\n         BNE   GR$ERR                   NO - block gone - error\nGR$OKBLK MVC   GR@REC(12),QCCREC        Store current rec nums in tbl\n         ST    R2,QCCPTR                STORE CURRENT TABLE ADDR\n         CP    QCCREC,QCHREC            IS CURRENT REC NO > HIGHEST?\n         BNH   *+4+6                    NO - SKIP\n         MVC   QCHREC(16),QCCREC        Replace hi rec cnts and ptr\n         LA    R4,HDBSTART              -> first record in block\n         C     R2,GR@CEND               IS THIS THE END OF TABLE?\n         BL    GR$REC1                  NO - OK\n***********************************************************************\n*                                                                     *\n*   DATASET RECORD NUMBER TABLE IS TOO SMALL.  TRY TO GET A BIGGER    *\n*   ONE, COPY THE INFORMATION, AND FREE THE OLD ONE.  WE WILL TRY     *\n*   FOR ONE 4 TIMES THE SIZE, SO WE WILL GO FROM THE ORIGINAL 64K TO  *\n*   256K.  IF THAT ONE IS TOO SMALL, WE WILL GO TO 1024K.  IF THAT    *\n*   ONE IS TOO SMALL, YOU BETTER BE LOGGED ON IN A MONSTER REGION.    *\n*                                                                     *\n***********************************************************************\n         L     R2,QCSIZE                get current size\n         LR    R7,R2                    copy for later\n         SLL   R2,2                     multiply by 4\n         GETMAIN  RC,LV=(R2),SP=1       get new workarea\n         LTR   R15,R15                  did it work?\n         BNZ   GR$TILT1                 no, exit stage right\n         LR    R6,R1                    set\n         LR    R0,R1                       up\n         LR    R1,R2                         regs\n         LR    R15,R7                            for\n         L     R14,QCSTART                          mvcl\n         MVCL  R0,R14                   copy table\n         LR    R0,R7                    point to old table\n         ICM   R0,B'1000',=AL1(1)       set subpool\n         L     R1,QCSTART               ditto addr\n         FREEMAIN  R,LV=(0),A=(1)       free old table\n         L     R1,QCCPTR                Get current record ptr\n         S     R1,QCSTART               get offset entry\n         AR    R1,R6                    set new addr\n         ST    R1,QCCPTR                save it\n         ST    R6,QCSTART               set\n         ST    R2,QCSIZE                   new\n         AR    R6,R2                          table\n         L     R2,QCCPTR                           ptrs\n         SH    R6,=Y(GR@TBLL)           -> last entry\n         ST    R6,GR@CEND               save for later\n         B     GR$REC1                  GO PROCESS FIRST RECORD IN BLK\n***********************************************************************\n*                                                                     *\n*   ADVANCE TO NEXT RECORD IN BLOCK                                   *\n*                                                                     *\n***********************************************************************\nGR$NXT   L     R4,QCGRPTR               -> current record\n         LH    R6,QCGRLEN               len of record\n         USING LRCDSECT,R4\nGR$NXREC TM    LRCFLAG1,LRC1SPAN        IS THIS A SPANNED RECORD?\n         BO    GR$SPAN                  YES - USE SPECIAL CODE\n         LA    R4,LRCTEXT(R6)           -> NEXT RECORD\n         B     GR$REC1                  PROCESS IT\nGR$SPAN  LH    R6,LRCSEGL               LENGTH OF SEGMENT\n         TM    LRCFLAG1,LRC1SBGN        IS THIS THE FIRST SEGMENT?\n         BO    GR$SPAN1                 YES - USE DIFFERENT HDR LENGTH\n         LA    R4,LRCSTEXT(R6)          UPDATE RECORD POSITION\n         B     GR$REC1                  PROCESS NEXT RECORD\nGR$SPAN1 LA    R4,LRCSFTXT(R6)          UPDATE RECORD POSITION\n*     (  B     GR$REC1   )              PROCESS NEXT RECORD\n***********************************************************************\n*                                                                     *\n*   PROCESS RECORDS                                                   *\n*                                                                     *\n***********************************************************************\nGR$REC1  CLI   LRCTLENG,LRCBFEND        IS LENGTH BYTE FF?\n         BE    GR$NXTBL                 YES - END OF BLOCK\n         SR    R6,R6                    CLEAR FOR IC\n         IC    R6,LRCTLENG              INSERT LENGTH\n         TM    LRCFLAG1,LRC1CCTL        IS CARRIAGE CONTROL SPECIFIED?\n         BZ    *+8                      NO - SKIP\n         LA    R6,1(,R6)                YES - BUMP RECORD LENGTH\n         TM    LRCFLAG1,LRC1INUL        IS THIS RECORD TO BE IGNORED?\n         BNZ   GR$NXREC                 YES - SKIP IT\n         AP    QCCREC,=P'1'             BUMP CURRENT REC NO\n         LA    R14,=PL1'1'              Default to 1 rec no\n         TM    LRCFLAG1,LRC1CCTL        any char ctl?\n         BZ    GR$INCLN                 no, add in line\n         TM    QCRFLAG,QRFSKP1          was last held skp 1\n         BO    GR$INCPG                 yes, do it now\n         LA    R14,=PL1'2'              try skip 1\n         CLI   3(R4),C'0'               true?\n         BE    GR$INCLN                 go do it\n         CLI   3(R4),X'13'              true?\n         BE    GR$INCLN                 go do it\n         LA    R14,=PL1'3'              try skip 2\n         CLI   3(R4),C'-'               true?\n         BE    GR$INCLN                 do it\n         CLI   3(R4),X'1B'              true?\n         BE    GR$INCLN                 go do it\n         LA    R14,=PL1'0'              assume imm cmd\n         CLI   3(R4),C'1'               check for new page\n         BE    GR$INCPG                 no, use next line\n         CLI   3(R4),X'8B'              check for new page\n         BE    GR$INCPG                 no, use next line\n         ZAP   QCRHOLD,=PL1'1'\n         CLI   3(R4),X'09'\n         BE    GR$INCLN\n         ZAP   QCRHOLD,=PL1'2'\n         CLI   3(R4),X'11'\n         BE    GR$INCLN\n         ZAP   QCRHOLD,=PL1'3'\n         CLI   3(R4),X'19'\n         BE    GR$INCLN\n         LA    R14,=PL1'1'\n         CLI   3(R4),X'89'\n         BNE   GR$INCLN\n         OI    QCRFLAG,QRFSKP1\n         LA    R14,=PL1'0'\n         B     GR$INCLN\nGR$INCPG CP    QCCREC,=P'1'             first rec?\n         BE    GR$RCHK                  yes, skip update\n         AP    QCCPAGE,=P'1'            BUMP PAGE NO\n         ZAP   QCRHOLD,=P'0'            clear held lines\n         NI    QCRFLAG,255-QRFSKP1      ditto pages\n         ZAP   QCCLINE,=P'1'            line 1\n         ZAP   QCCLINEA,=P'1'           line 1 here too.\n         B     GR$RCHK                  check for record no.\nGR$INCLN AP    QCCLINE,0(1,R14)         add in correct offset\n         AP    QCCLINE,QCRHOLD          add in held count\n         ZAP   QCRHOLD,=P'0'            clear out held lines\n         AP    QCCLINEA,=P'1'           BUMP ABS LINE OFFSET\n         TM    QCRECFM,DCBRECCC         and carriage ctl here?\n         BO    GR$RCHK                  yes, leave it alone\n         CP    QCCLINEA,GR@LINCT        over max?\n         BH    GR$INCPG                 yes, fake new page\n         SPACE 1\nGR$RCHK  LA    R1,QCCREC                REACHED THE RECORD WE WANT?\n         BAL   R14,GR$CP\n         BH    GR$NXREC                 NO - TRY NEXT RECORD\nGR$LEAVE CP    QCCREC,QCHREC            IS CURRENT REC NO > HIGHEST?\n         BNH   *+4+6                    NO - SKIP\n         MVC   QCHREC(16),QCCREC        Replace hi rec cnts and ptr\n         ST    R4,QCGRPTR               save ptr to record\n         STH   R6,QCGRLEN               save len too.\n         L     R15,4(,R13)              DECHAIN SAVEAREAS\n         ST    R4,36(,R15)              Pass back addr\n         ST    R6,44(,R15)              ...       len\n         B     QSTOP                    ALL DONE\n         DROP  R4\nGR$ERR   CL    R2,QCHPTR                Are at end of DS?\n         BH    GR$END                   YES - not error\n         OI    QCRFLAG,QRFERR           no - INDICATE ERROR ON DS\nGR$END   SR    R4,R4                    INDICATE END OF DATASET\n         OI    QCRFLAG,QRFEOF           eod reached\n         B     GR$LEAVE                 AND RETURN\n***********************************************************************\n*                                                                     *\n*   REPOSITION TO REQUESTED RECORD NUMBER                             *\n*                                                                     *\n***********************************************************************\nGR$REPOS NI    QCRFLAG,255-QRFSKP1      here too.\n         ZAP   QCRHOLD,=P'0'            and line cnt\n         LA    R1,QCHREC                is req no > highest read?\n         BAL   R14,GR$CP\n         BNL   GR$HI                    YES - GO FROM HI\n         LA    R1,QCCREC                is req no > current rec?\n         BAL   R14,GR$CP\n         BH    GR$UP                    YES - GO FROM CURRENT\n         LA    R1,GR#LTOP               -> top literal\n         BAL   R14,GR$CP                IS REQ FOR TOP OF DATASET?\n         BH    GR$DOWN                  NO - GO DOWN FROM CURRENT\nGR$TOP   L     R2,QCSTART               START AT TOP\nGR$RESUM L     R4,GR@MTTR               LOAD DISK ADDR\n         L     R5,QCBLKA                ADDR OF BLOCK IOAREA\n         MVC   QCCREC(12),GR@REC        Reset current rec nos\n         B     GR$FIRST                 RESUME PROCESSING\nGR$HI    ICM   R2,B'1111',QCHPTR        START AT HIGHEST SO FAR\n         BZ    GR$TOP                   if nothing, start at top\n         B     GR$DWNLP                 FIND CORRECT BLOCK\nGR$UP    L     R2,QCCPTR                CURRENT TABLE PTR\nGR$UPLP  LA    R1,GR@TBLL(,R2)          -> next table entry\n         CL    R1,QCHPTR                past end?\n         BH    GR$RESUM                 yes, go look for record\n         LA    R1,GR@REC+GR@TBLL        no, check next block\n         BAL   R14,GR$CP\n         BNH   GR$RESUM                 YES - PROCESS IT\n         LA    R2,GR@TBLL(,R2)          -> next entry\n         B     GR$UPLP                  AGAIN\nGR$DOWN  ICM   R2,B'1111',QCCPTR        CURRENT TABLE PTR\n         BZ    GR$END                   if nothing, return eof\nGR$DWNLP LA    R1,GR@REC                is req no > entry?\n         BAL   R14,GR$CP\n         BH    GR$RESUM                 YES - PROCESS IT\n         SH    R2,=Y(GR@TBLL)           Try previous entry\n         CL    R2,QCSTART               below start?\n         BL    GR$TOP                   yes, start at top\n         B     GR$DWNLP                 AGAIN\n         SPACE 3\n*%GR$CP  TM    QMODE1,QM1PAGE           page mode?\n*%       BZ    GR$CPL                   no, normal compare\nGR$CP    TM    QFLAG2,Q2LISTDS          from listds?\n         BZ    GR$CPL                   no, normal\n         CLI   QCODE,64                 \"PAGE\" command?\n         BNE   GR$CPL                   no, normal check\n         CP    QPPAGE,QPPAGE-QPREC(4,R1)  Check Page\n         BNER  R14\n         CP    QPLINE,QPLINE-QPREC(2,R1)            /Line\n         BR    R14\nGR$CPL   CP    QPREC,0(4,R1)            check rec no\n         BR    R14\n***********************************************************************\n*                                                                     *\n*   MISCELLANY                                                        *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nGR$TILT1 QTILT '*** Dataset Table Limits Exceeded ***'\n         SPACE 2\n         DC    0D'0'                    align stuff\nGR#LTOP  DC    PL4'0',PL4'0',2PL2'1'    rec 1; page 1,line 1,line 1\n         SPACE 3\n         LTORG ,\n         SPACE 3\nWORK     DSECT ,\n         ORG   WORK+72\nGR@DWD   DS    D                        misc dwd\nGR@CEND  DS    A                        -> last entry in table\nGR@PREC  DS    PL4                      adjusted desired rec no\nGR@LINCT DS    PL2                      linecount for this dsid\nGR@WORKL EQU   *-WORK\n         SPACE 3\n         DROPX R5,R13\n         SPACE 3\n         QDSTAB  PREFIX=GR@,DSECT=YES,MTTR=YES\n         SPACE 3\n         QCOMMON\n         SPACE 3\n         Q$BUFFER\n         Q$LRC\n         QZDCBD\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "Q#HB": {"ttr": 8201, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x0c\\x00\\x00\\x00\\x82#/\\x00\\x90\\x16\\x7f#\\x14\\x01L\\x00\\xaf\\x00\\xe7\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "05.12", "flags": 0, "createdate": "1982-08-20T00:00:00", "modifydate": "1990-06-16T23:14:00", "lines": 332, "newlines": 175, "modlines": 231, "user": "LDW"}, "text": "         TITLE '--- QUEUE--HEXBLK -- HEXADECIMAL DUMP OF A BLOCK ---'\n*---------------------------------------------------------------------*\n*                                                                     *\n*   HEXBLK - Display a block from HASPACE in dump or character forms  *\n*                                                                     *\n*   Entry - Block address in QPARM1                                   *\n*         - 'C' in QKEYWORD to request character form                 *\n*                                                                     *\n*   Updates:                                                          *\n*      16Jun90  LDW  Fix for running AMODE 31                         *\n*      23Nov89  LDW  Eliminate \"LC\" macro usage                       *\n*       1Jun87  EMS  Update for Starting/Draining spool volumes       *\n*      17Jan87  LDW  Misc cleanup                                     *\n*      03/31/86 LDW  RE-DESIGN 3278-5 SUPPORT (THIRD TRY!)            *\n*      11/15/84 LDW  FIX JCT OFFSET DISPLAY                           *\n*      01/23/84 LDW  ADD SUPPORT FOR COMMAND STACKING                 *\n*                    DISPLAY ADDRESS FOR QCMN, CKPT                   *\n*      01/06/83 LDW  CHANGE 'C' OPERAND FROM POSITIONAL-2 TO KEYWORD  *\n*                    ADD HCT, QCMN, CKPT SUBCOMMANDS                  *\n*                    ADD DISPLACEMENT AND OFFSET SUPPORT              *\n*      12/20/82 LDW  CHANGE QTILT REPRMPT=YES TO OPTIONS=REPROMPT     *\n*      12/08/82 LDW  CHANGE USAGE OF QPARM4 TO HBHEXIN (ADDED)        *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 3\nHEXBLK   QSTART  Q9\n         USING WORK,R13\n         QCALL DISP80                   SWITCH TO 3278-2 MODE IF 3278-5\n         LH    R15,QCODEH               GET ENTRY CODE\n         TM    QXAUTH,QXSYSP            SYSTEMS PROGRAMMER?\n         BO    HB$BRTAB(R15)            YES - ALLOW SUBCOMMAND\n         TM    QXAUTH,QXOPER+QXPSWD     OPERATOR PLUS KNOW PASSWORD?\n         BO    HB$BRTAB(R15)            YES - ALLOW SUBCOMMAND\n         QTILT '*** PRIVILEGED SUBCOMMAND ***'  THIS IS A SENSITIVE CMD\nHB$BRTAB B     HB$XB                    00 - XB\n         B     HB$JCT                   04 - JCT\n         B     HB$HCT                   08 - HCT\n         B     HB$QCMN                  12 - QCMN\n         B     HB$CKPT                  16 - CKPT\n***********************************************************************\n*                                                                     *\n*   VALIDATE AND CONVERT BLOCK ADDRESS                                *\n*                                                                     *\n***********************************************************************\nHB$XB    QSTACK  X'A0'\n         L     R2,QCBLKA                -> BUFFER\n         CLI   QPARM1,C'$'              REDISPLAY FROM CURRENT BUFFER?\n         BE    HB$STAR                  YES - USE IT\n         MVC   QCTRAK,QXBTRAK           COPY LAST MTTR\n         CLI   QPARM1,C'*'              USE LAST MTTR?\n         BE    HB$STAR                  YES - USE IT\n         CLI   QPARM1,C'+'              CHAIN FROM CURRENT BLOCK?\n         BNE   HB$NEW                   NO - GO CONVERT MTTR\n         OC    0(4,R2),0(R2)            ANY CHAIN MTTR?\n         BNZ   HB$CHAIN                 YES - USE IT\n         QTILT '*** BLOCK CHAIN FIELD IS ZERO ***'\nHB$CHAIN MVC   QCTRAK,0(R2)             SET MTTR TO READ\n         B     HB$STAR                  GO READ IT\nHB$NEW   LH    R15,QLNG1                LENGTH OF PARM\n         MVC   HBHEXIN,QPARM1           PARM\n         BAL   R8,HBGETHEX              CONVERT FROM HEX\n         B     HB$TILT                  TILT IF INVALID HEX\n         B     HB$TILT                  TILT IF NO OPERAND\n         MVC   QCTRAK,HBHEXOUT          SET MTTR TO READ\n         MVC   QXBTRAK,HBHEXOUT         SAVE FOR NEXT TIME\n***********************************************************************\n*                                                                     *\n*   READ THE BLOCK FROM HASPACE                                       *\n*                                                                     *\n***********************************************************************\nHB$STAR  LH    R1,QCHSBLK               HASPACE BLOCK SIZE\n         BCTR  R1,0                     SUBTRACT 1\n         N     R1,=F'-64'               ROUND TO PREV. 64 BYTE BOUNDARY\n         AR    R1,R2                    ADD BASE OF BUFFER\n         MVC   0(64,R1),QBLANK          BLANK LAST 64 BYTES OF BUFFER\n         LR    R1,R2                    PARM FOR READSPC\n         QCALL READSPC                  READ HASPACE\n***********************************************************************\n*                                                                     *\n*   PRINT THE BLOCK                                                   *\n*                                                                     *\n***********************************************************************\n         L     R6,=V(CHARTAB)           -> CHARACTER TRANSLATE TABLE\n         MVC   QDHLINE,QBLANK           BLANK THE TITLE LINE\n         MVC   QDHLINE(5),=C'BLOCK'\n         UNPK  QDHLINE+6(8+1),QCTRAK(4+1)\n         TR    QDHLINE+6(8),HB#TBL#H\n         MVC   QDHLINE+14(5),=C' FROM'\n         MVC   QDHLINE+20(17),QDSNSPC+2 MOVE IN DSNAME OF HASPSPC\n         MVC   QDHLINE+38(2),=C'ON'\n         SR    R1,R1                    CLEAR FOR IC\n         IC    R1,QCTRAKM               GET RELATIVE DCB NUMBER\n         L     R15,QCEXTMAP             -> extent map\n         IC    R1,0(R1,R15)             get correct dcb addr\n         SLL   R1,2                     MULTIPLY BY 4\n         L     R15,QCSPOOLS             -> Dcb table\n         L     R1,0(R1,R15)             -> DCB\n         L     R1,44(,R1)               -> DEB\n         L     R1,32(,R1)               -> UCB\n         N     R1,=X'00FFFFFF'          purify the address\n         MVC   QDHLINE+41(6),28(R1)     MOVE VOLSER TO TITLE\n         SR    R4,R4                    SET DEFAULT DISPLACEMENT\n         LH    R15,QLNG2                LENGTH OF PARM\n         MVC   HBHEXIN,QPARM2           COPY THE DISPLACEMENT OPERAND\n         BAL   R8,HBGETHEX              CONVERT IT\n         B     HB$TILT3                 TILT IF INVALID\n         B     *+8                      SKIP IF OMITTED\n         L     R4,HBHEXOUT              GET THE DISPLACEMENT\n         AR    R2,R4                    AND ADJUST STARTING ADDR\n         CLI   QKEYWORD,C'C'            WANT CHARACTER FORM?\n         BNE   HB$DUMP                  NO - DO HEX DUMP\n         USING HB@IN,R2                 BASE REG FOR RAW BLOCK\n         LA    R3,QDMSG                 -> MSG LINE\n         USING HB@OUT,R3                BASE REG FOR PRINTABLE LINES\nHB$LOOP  MVC   HBOLINE1,QBLANK          BLANK THE WORK AREA\n         MVC   HB@O1,HB@I1              MOVE RECORD TO PRINT LINE\n         MVC   HB@O2,HB@I2\n         MVC   HB@O3,HB@I3\n         MVC   HB@O4,HB@I4\n         MVC   HB@O5,HB@I5\n         MVC   HB@O6,HB@I6\n         MVC   HB@O7,HB@I7\n         MVC   HB@O8,HB@I8\n         STH   R4,QNUMWORK              STORE OFFSET\n         UNPK  HBOFFSET(5),QNUMWORK(3)  CONVERT TO HEX\n         TR    HBOFFSET,HB#TBL#H        TRANSLATE TO PRINTABLE\n         MVI   HBOFFSET+4,C' '          CLEAR GARBAGE BYTE\n         TR    HBODATA1,0(R6)           TRANSLATE OUT BAD CHARACTERS\n         BAL   R14,QADDLINE             DISPLAY THE LINE\n         LR    R1,R2                    SAVE ADDR OF RECORD\nHB$SKIP  LA    R2,64(,R2)               NEXT RECORD\n         LA    R4,64(,R4)               INCREMENT TO NEXT OFFSET\n         CH    R4,QCHSBLK               STILL IN THE BLOCK?\n         BNL   QSTOP                    NO. GO HOME.\n         CLC   0(64,R1),0(R2)           THIS RECORD THE SAME AS PREV?\n         BE    HB$SKIP                  YES. SKIP IT.\n         B     HB$LOOP                  PRINT NEXT RECORD\n         SPACE 2\nHB$DUMP  LR    R1,R2                    SET ADDR\n         LR    R0,R4                    SET OFFSET\n         LH    R2,QCHSBLK               SET LENGTH\n         QCALL HEXFMT                   GO DISPLAY IN CORE DUMP FORMAT\n         B     QSTOP                    ALL DONE\n***********************************************************************\n*                                                                     *\n*   DISPLAY JCT                                                       *\n*                                                                     *\n***********************************************************************\nHB$JCT   QSTACK  X'30'\n         LA    R4,BUFSTART-BUFDSECT     SET DEFAULT OFFSET\n         LH    R15,QLNG2                LENGTH OF PARM\n         MVC   HBHEXIN,QPARM2           COPY THE OFFSET OPERAND\n         BAL   R8,HBGETHEX              CONVERT IT\n         B     HB$TILT2                 TILT IF INVALID\n         B     *+8                      SKIP IF OMITTED\n         L     R4,HBHEXOUT              GET THE DISPLAY OFFSET\n         QCALL FINDJOB                  LOCATE THE JCT, ETC\n         OI    QSCFLAG1,QSC1JOB         PUT JOBID IN QDTOP\n         MVC   QDHLINE,QBLANK           CLEAR HEADER LINE\n         MVC   QDHLINE(L'HB#JCT),HB#JCT MOVE IN HEADER\n         L     R1,QCJCTA                -> JCT\n         LR    R0,R4                    SET OFFSET\n         LH    R2,QCHSBLK               SET LENGTH\n         QCALL HEXFMT                   GO DISPLAY IN CORE DUMP FORMAT\n         B     QSTOP                    ALL DONE\n***********************************************************************\n*                                                                     *\n*   DISPLAY HCT $SAVEAREA                                             *\n*                                                                     *\n***********************************************************************\nHB$HCT   QSTACK  X'B0'\n         QCALL CKPT                     READ CHECKPOINT DATA\n         LA    R4,$SAVEBEG-HCTDSECT  SET DEFAULT OFFSET\n         LH    R15,QLNG1                LENGTH OF PARM\n         MVC   HBHEXIN,QPARM1           COPY THE OFFSET OPERAND\n         BAL   R8,HBGETHEX              CONVERT IT\n         B     HB$TILT2                 TILT IF INVALID\n         B     *+8                      SKIP IF OMITTED\n         L     R4,HBHEXOUT              GET THE DISPLAY OFFSET\n         MVC   QDHLINE,QBLANK           CLEAR HEADER LINE\n         MVC   QDHLINE(L'HB#HCT),HB#HCT MOVE IN HEADER\n         L     R1,QCJQTL                -> HCT $SAVEAREA\n         LR    R0,R4                    SET OFFSET\n         LA    R2,$SAVELEN              SET LENGTH\n         QCALL HEXFMT                   GO DISPLAY IN CORE DUMP FORMAT\n         B     QSTOP                    ALL DONE\n***********************************************************************\n*                                                                     *\n*   DISPLAY QCOMMON WORK AREA                                         *\n*                                                                     *\n***********************************************************************\nHB$QCMN  QSTACK  X'B0'\n         SR    R4,R4                    SET DEFAULT OFFSET\n         LH    R15,QLNG1                LENGTH OF PARM\n         MVC   HBHEXIN,QPARM1           COPY THE DISPLACEMENT OPERAND\n         BAL   R8,HBGETHEX              CONVERT IT\n         B     HB$TILT3                 TILT IF INVALID\n         B     *+8                      SKIP IF OMITTED\n         L     R4,HBHEXOUT              GET THE DISPLACEMENT\n         MVC   QDHLINE,QBLANK           CLEAR HEADER LINE\n         MVC   QDHLINE(L'HB#QCMN),HB#QCMN  MOVE IN HEADER\n         ST    R11,HBHEXOUT             SAVE FOR UNPK\n         UNPK  QDHLINE+L'HB#QCMN(8+1),HBHEXOUT(4+1)\n         TR    QDHLINE+L'HB#QCMN(8),HB#TBL#H\n         MVI   QDHLINE+L'HB#QCMN+8,C')'\n         LA    R1,0(R4,R11)             -> QCOMMON\n         LR    R0,R4                    SET OFFSET\n         L     R2,QGETMAIN              SET LENGTH\n         SR    R2,R4                    ADJUST BY DISPLACEMENT\n         BNP   HB$TILT4                 ABORT IF DISPLACEMENT > LENGTH\n         QCALL HEXFMT                   GO DISPLAY IN CORE DUMP FORMAT\n         B     QSTOP                    ALL DONE\n***********************************************************************\n*                                                                     *\n*   DISPLAY CKPT DATA                                                 *\n*                                                                     *\n***********************************************************************\nHB$CKPT  QSTACK  X'B0'\n         QCALL CKPT                     READ CHECKPOINT DATA\n         SR    R4,R4                    SET DEFAULT DISPLACEMENT\n         LH    R15,QLNG1                LENGTH OF PARM\n         MVC   HBHEXIN,QPARM1           COPY THE DISPLACEMENT OPERAND\n         BAL   R8,HBGETHEX              CONVERT IT\n         B     HB$TILT3                 TILT IF INVALID\n         B     *+8                      SKIP IF OMITTED\n         L     R4,HBHEXOUT              GET THE DISPLACEMENT\n         MVC   QDHLINE,QBLANK           CLEAR HEADER LINE\n         MVC   QDHLINE(L'HB#CKPT),HB#CKPT  MOVE IN HEADER\n         UNPK  QDHLINE+L'HB#CKPT(8+1),QCJQTL(4+1)\n         TR    QDHLINE+L'HB#CKPT(8),HB#TBL#H\n         MVI   QDHLINE+L'HB#CKPT+8,C')'\n         L     R1,QCJQTL                -> CKPT DATA\n         AR    R1,R4                    ADJUST BY DISPLACEMENT\n         LR    R0,R4                    SET OFFSET\n         L     R2,QCJOTL                GET NUMBER OF CKPT BLOCKS\n         SLL   R2,12                    SET LENGTH TO DISPLAY\n         SR    R2,R4                    ADJUST BY DISPLACEMENT\n         BNP   HB$TILT4                 ABORT IF DISPLACEMENT > LENGTH\n         QCALL HEXFMT                   GO DISPLAY IN CORE DUMP FORMAT\n         B     QSTOP                    ALL DONE\n***********************************************************************\n*                                                                     *\n*   ERROR MESSAGES                                                    *\n*                                                                     *\n***********************************************************************\nHB$TILT  QTILT '*** BLOCK ADDRESS WAS OMITTED OR INVALID ***',         $\n               OPTIONS=REPROMPT\nHB$TILT2 QTILT '*** DISPLAY OFFSET IS INVALID ***',OPTIONS=REPROMPT\nHB$TILT3 QTILT '*** DISPLACEMENT IS INVALID ***',OPTIONS=REPROMPT\nHB$TILT4 QTILT '*** DISPLACEMENT IS GREATER THAN AREA LENGTH ***',     $\n               OPTIONS=REPROMPT\n***********************************************************************\n*                                                                     *\n*   SUBROUTINE TO CONVERT FROM INPUT HEX                              *\n*                                                                     *\n***********************************************************************\nHBGETHEX LTR   R14,R15                  COPY AND TEST LENGTH\n         BNP   4(,R8)                   RETURN IF NO OPERAND\n         BCTR  R14,0                    -1 FOR EX\n         EX    R14,HB$TRT               ALL VALID CHARACTERS?\n         BNZR  R8                       NO - RETURN\n         TR    HBHEXIN,HB#TBL#H         CONVERT TO HEX\n         EX    R15,HB$PACK              PACK INTO HBHEXOUT\n         B     8(,R8)                   RETURN\nHB$TRT   TRT   HBHEXIN(*-*),HB#TBL#V    << EXECUTED >>\nHB$PACK  PACK  HBHEXOUT(4+1),HBHEXIN(*-*)  << EXECUTED >>\n***********************************************************************\n*                                                                     *\n*   MISCELLANY                                                        *\n*                                                                     *\n***********************************************************************\n         ENTRY HB#KEYS\nHB#KEYS  DC    CL8'C',CL8'CHAR'\n         DC    X'FF'                    END OF KEYWORD TABLE\n         LTORG\nHB#JCT   DC    C'Hex dump of JCT'\nHB#HCT   DC    C'Hex dump of HCT $SAVEAREA'\nHB#QCMN  DC    C'Hex dump of QCOMMON ('\nHB#CKPT  DC    C'Hex dump of CKPT data ('\n* TABLE FOR HEX CONVERT/UNCONVERT\nHB#TBL#H EQU   *-C'A'\n         DC    X'0A0B0C0D0E0F',CL41' ',C'0123456789ABCDEF'\n* TABLE USED TO VERIFY HEX OPERAND\nHB#TBL#V DC    256X'FF'\n         ORG   HB#TBL#V+C'A'\n         DC    6X'00'\n         ORG   HB#TBL#V+C'0'\n         DC    10X'00'\n         ORG   ,\n* INPUT WORK AREA\nHB@IN    DSECT\nHB@I1    DS    CL8\nHB@I2    DS    CL8\nHB@I3    DS    CL8\nHB@I4    DS    CL8\nHB@I5    DS    CL8\nHB@I6    DS    CL8\nHB@I7    DS    CL8\nHB@I8    DS    CL8\n* OUTPUT WORK AREA\nHB@OUT   DSECT\nHBOLINE1 DS    0CL80\nHBOFFSET DS    CL4\n         DS    CL2\nHBODATA1 DS    0CL74\nHB@O1    DS    CL8\n         DS    C\nHB@O2    DS    CL8\n         DS    CL2\nHB@O3    DS    CL8\n         DS    C\nHB@O4    DS    CL8\n         DS    CL2\nHB@O5    DS    CL8\n         DS    C\nHB@O6    DS    CL8\n         DS    CL2\nHB@O7    DS    CL8\n         DS    C\nHB@O8    DS    CL8\n         SPACE 3\n         DROP  R2,R3\n         SPACE 3\nWORK     DSECT\n         ORG   WORK+72                  SKIP OVER THE SAVE AREA\nHBHEXIN  DS    CL8\nHBHEXOUT DS    XL4,X\n         SPACE 2\n         QCOMMON\n         SPACE 2\n         Q$HCT\n         Q$BUFFER\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "Q#HE": {"ttr": 8452, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x16\\x00\\x00\\x00\\x82#/\\x00\\x91\\x18_\"7\\x00\\x86\\x01\\xaf\\x00r\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "05.22", "flags": 0, "createdate": "1982-08-20T00:00:00", "modifydate": "1991-07-04T22:37:00", "lines": 134, "newlines": 431, "modlines": 114, "user": "LDW"}, "text": "         TITLE '--- QUEUE--HELP -- DISPLAY HELP ---'\n*---------------------------------------------------------------------*\n*                                                                     *\n*   HELP - Display help                                               *\n*                                                                     *\n*   Entry - Optional starting screen number in QPARM1                 *\n*                                                                     *\n*   Updates:                                                          *\n*      04Jul91  LDW  Make HELPTEXT a WXTRN                            *\n*      23Nov89  LDW  Eliminate \"LC\" macro usage                       *\n*      03/31/86 LDW  RE-DESIGN 3278-5 SUPPORT (THIRD TRY!)            *\n*      03/31/86 LDW  RE-DESIGN 3278-5 SUPPORT (THIRD TRY!)            *\n*      01/19/84 LDW  ADD SUPPORT FOR COMMAND STACKING                 *\n*      08/28/83 LDW  CHANGE OFFSETS TO 3 BYTES                        *\n*      03/10/83 LDW  ADD SUPPORT FOR \"HELP /ALL\"                      *\n*                    USE OFFSET INSTEAD OF ADCONS TO POINT TO SCREENS *\n*      03/08/83 LDW  DON'T DELETE HELP MODULE                         *\n*      03/02/83 LDW  CHANGE 'QTILT *' TO USE QERRMSG                  *\n*      02/24/83 LDW  CHANGE TO SUPPORT \"HELP SUBCMDNAME\" ONLY         *\n*                    MOVE HELP SCREENS TO SEPARATE LOAD MODULE        *\n*      02/10/83 LDW  ADD SUPPORT FOR ATTR BYTES IN HELP LINES         *\n*      01/28/83 LDW  DON'T MOVE HEADER LINE UNTIL AFTER FIRST LINE    *\n*                       OF A SCREEN IS MOVED (THIS IS TO FIX THE      *\n*                       BUG THAT CAUSED THE WRONG HEADING LINE TO     *\n*                       BE PRINTED WHEN USING PRINT SCREEN)           *\n*      01/05/83 LDW  MOVE ACTUAL SCREEN IMAGES TO NEW COPY MEMBER -   *\n*                       \"Q#HE#DC\" (UPDATES TO SCREENS THEMSELVES WILL *\n*                       NO LONGER BE FLAGGED, SO ALL UPDATE NOTES     *\n*                       BELOW HAVE BEEN DELETED)                      *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 3\n         WXTRN HELPTEXT\n         SPACE 3\nHELP     QSTART  Q8,STACK=X'C0'\n         QCALL DISP80                   SWITCH TO 3278-2 MODE IF 3278-5\n         CLI   QKEYWORD,C'A'            'ALL' KEYWORD GIVEN?\n         BE    HE$01                    YES - SKIP\n         CLI   QPARM1,C' '              ANY OPERAND?\n         BNE   *+10                     YES - USE IT\n         MVC   QPARM1,=CL8'COMMANDS'    NO - GIVE SUBCMD NAMES\n         SPACE 1\nHE$01    L     R8,=A(HELPTEXT)          -> HELP TEXT CSECT\n         LTR   R8,R8                    IS IT LINK EDITTED IN?\n         BNZ   HE$OK                    YES - USE IT\n         L     R8,QVHELP                -> TEXT LOAD MODULE\n         LTR   R8,R8                    IS IT LOADED YET?\n         BNZ   HE$OK                    YES - USE IT\n         SPACE 1\n         LOAD  EPLOC==CL8'QHLPTXT',ERRET=HE$OOPS\n         SPACE 1\n         ST    R0,QVHELP                SAVE ADDR FOR NEXT TIME\n         LR    R8,R0                    GET ADDR IN CORRECT REGISTER\n         SPACE 2\nHE$OK    LM    R3,R5,0(R8)              BXLE REGS FOR KEYWORD TABLE\n         CLI   QPARM1,C' '              ANYTHING HERE?\n         BE    HELP$GO                  NO - MUST BE \"HELP /ALL\"\n***********************************************************************\n*                                                                     *\n*   LOCATE REQUESTED HELP SCREEN                                      *\n*                                                                     *\n***********************************************************************\nHE$FIND  CLC   QPARM1,0(R3)             IS THIS IT?\n         BE    HELP$GO                  YES - DISPLAY IT\n         BXLE  R3,R4,HE$FIND            NO - KEEP LOOKING\n         MVC   QERRMSG(34),=C'*** NO HELP FOUND FOR 12345678 ***'\n         MVC   QERRMSG+22(8),QPARM1\n         QTILT *,OPTIONS=(REPROMPT,SET)\n***********************************************************************\n*                                                                     *\n*   PASS HELP SCREEN TO DISPLAY MODULE                                *\n*                                                                     *\n***********************************************************************\nHELP$GO  MVC   QDHLINE,QBLANK           CLEAR HEADER\n         MVC   QDHLINE(6),=C'HELP -'    SET UP HEADER\n         MVC   QDHLINE+7(8),0(R3)       SHOW WHICH HELP IS DISPLAYED\n         OI    QFLAG1,Q1MVHDR           TELL DISPLAY TO MOVE IT\n         SR    R6,R6                    CLEAR FOR ICM\n         ICM   R6,B'0111',9(R3)         GET OFFSET OF FIRST LINE\n         AR    R6,R8                    -> FIRST LINE (HEADER)\n         SR    R7,R7                    CLEAR FOR IC\n         IC    R7,0(,R6)                HEADER LINE LENGTH-1\n         LR    R1,R7                    COPY HEADER LENGTH\n         SH    R1,=H'20'                ADJUST FOR MISSING LEFT SIDE\n         BNP   *+8                      SKIP IF NOTHING LEFT\n         EX    R1,HE$MVCHD              MVC QDHLINE+20(*-*),20+3(R6)\n         LA    R6,3+1(R7,R6)            -> NEXT LINE\n         BAL   R14,QADDLINE             START WITH A BLANK LINE\n         SPACE 1\nHELP$LP  IC    R7,0(,R6)                HELP LINE LENGTH-1\n         TM    1(R6),1                  LINE FOR AUTH USERS ONLY?\n         BNO   HE$NAUTH                 NO - CONTINUE\n         TM    QXAUTH,QXAUTHX           WELL, IS HE AUTHORIZED?\n         BZ    HE$SKIP                  NO - SKIP THIS LINE\nHE$NAUTH EX    R7,HE$MVC                MVC QDMSG(*-*),3(R6)\n         MVC   QDATRNUM+1(1),2(R6)      SET NUMBER OF ATTR BYTES\n         BAL   R14,QADDLINE             MOVE LINE TO SCREEN\n         SPACE 2\nHE$SKIP  LA    R6,3+1(R7,R6)            -> NEXT LINE\n         CLI   0(R6),X'FF'              LAST LINE?\n         BNE   HELP$LP                  NO - CONTINUE\n         BAL   R14,QADDLINE             THROW IN A BLANK LINE\n         CLI   QKEYWORD,C'A'            'ALL' KEYWORD GIVEN?\n         BNE   QSTOP                    NO - ALL DONE\nHE$DUP   AR    R3,R4                    -> NEXT HELP SCREEN DESC\n         CLI   0(R3),X'FF'              END OF LIST?\n         BE    QSTOP                    YES - ALL DONE\n         TM    8(R3),X'80'              THIS SUBCOMMAND AN ALIAS?\n         BO    HE$DUP                   YES - SKIP IT\n         MVC   QDMSG(HE#NEXTL),HE#NEXT  SAY END OF SCREEN, MORE TO COME\n         MVI   QDATRNUM+1,2             NUMBER OF ATTR BYTES IN LINE\n         BAL   R14,QADDLINE             ADD MSG TO SCREEN\n         QCALL DISPLAY                  DISPLAY THE SCREEN NOW\n         B     HELP$GO                  AND DISPLAY THE NEXT SCREEN\n         SPACE 1\nHE$MVCHD MVC   QDHLINE+20(*-*),20+3(R6) << EXECUTED >>\nHE$MVC   MVC   QDMSG(*-*),3(R6)         << EXECUTED >>\n***********************************************************************\n*                                                                     *\n*   MISCELLANY                                                        *\n*                                                                     *\n***********************************************************************\nHE$OOPS  QTILT '*** HELP MODULE UNAVAILABLE -- CONTACT SYSTEMS GROUP **$\n               *'\nHE#NEXT  DC    X'1DE8'                  OUTPUT, BRIGHT\n         DC    C'>>> Press ENTER for next Help screen <<<'\n         DC    X'1D60'                  OUTPUT, NORMAL\nHE#NEXTL EQU   *-HE#NEXT\n         ENTRY HE#KEYS\nHE#KEYS  DC    CL8'A',CL8'ALL'\n         DC    X'FF'                    END OF HELP KEYS\n         LTORG\n         SPACE 3\n         QCOMMON\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "Q#HT": {"ttr": 8455, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "* GENQHELP was run on THURSDAY   Mar 19, 1992  (92.079)  at 21:32:59\n* LDW.TEXT(QHELP) - last updated 19Mar92\nHELPTEXT CSECT\n         DC    A(HELPTAB,HELPTABL,HELPEND-HELPTABL)    BXLE registers\n*---  The following table should be kept in ascending order to     ---*\n*---  allow a binary search to be implemented someday.             ---*\n*---  (The first entry will have to be an exception.)              ---*\n*  Flag byte definition:\n*    X'80' - This entry is an alias, and should be skipped when\n*            doing \"HELP /ALL\"\nHELPTAB  DC    CL8'GENERAL ',X'00',AL3(HE#GENL-HELPTEXT)\nHELPTABL EQU   *-HELPTAB                Length of an entry\n*%%%     DC    CL8'/       ',X'00',AL3(HE#SLASH-HELPTEXT)\n         DC    CL8'?       ',X'80',AL3(HE#HELP-HELPTEXT)\n         DC    CL8'@       ',X'80',AL3(HE#MD-HELPTEXT)\n*%%%     DC    CL8'ABEND   ',X'00',AL3(HE#ABEND-HELPTEXT)\n         DC    CL8'ADMIN   ',X'00',AL3(HE#ADMN-HELPTEXT)\n         DC    CL8'AI      ',X'80',AL3(HE#DI-HELPTEXT)\n         DC    CL8'AJ      ',X'00',AL3(HE#AJ-HELPTEXT)\n         DC    CL8'AT      ',X'80',AL3(HE#ATTR-HELPTEXT)\n         DC    CL8'ATTR    ',X'00',AL3(HE#ATTR-HELPTEXT)\n         DC    CL8'AO      ',X'80',AL3(HE#DO-HELPTEXT)\n         DC    CL8'B       ',X'80',AL3(HE#BOT-HELPTEXT)\n         DC    CL8'BOT     ',X'80',AL3(HE#BOT-HELPTEXT)\n         DC    CL8'BOTTOM  ',X'00',AL3(HE#BOT-HELPTEXT)\n*%%%     DC    CL8'BR      ',X'80',AL3(HE#BR-HELPTEXT)\n*%%%     DC    CL8'BROWSE  ',X'00',AL3(HE#BR-HELPTEXT)\n         DC    CL8'C       ',X'80',AL3(HE#COL-HELPTEXT)\n         DC    CL8'CAN     ',X'80',AL3(HE#CAN-HELPTEXT)\n         DC    CL8'CANCEL  ',X'00',AL3(HE#CAN-HELPTEXT)\n         DC    CL8'CHGS    ',X'00',AL3(HE#CHGS-HELPTEXT)\n         DC    CL8'CJ      ',X'80',AL3(HE#CAN-HELPTEXT)\n*%%%     DC    CL8'CKPT    ',X'00',AL3(HE#CKPT-HELPTEXT)\n         DC    CL8'CMDS    ',X'80',AL3(HE#CMDS-HELPTEXT)\n         DC    CL8'COL     ',X'80',AL3(HE#COL-HELPTEXT)\n         DC    CL8'COLS    ',X'00',AL3(HE#COLS-HELPTEXT)\n         DC    CL8'COLUMN  ',X'00',AL3(HE#COL-HELPTEXT)\n         DC    CL8'COMMANDS',X'00',AL3(HE#CMDS-HELPTEXT)\n*%%%     DC    CL8'CONS    ',X'00',AL3(HE#CONS-HELPTEXT)\n         DC    CL8'COPY    ',X'00',AL3(HE#COPY-HELPTEXT)\n         DC    CL8'CPU     ',X'00',AL3(HE#CPU-HELPTEXT)\n         DC    CL8'CY      ',X'80',AL3(HE#COPY-HELPTEXT)\n         DC    CL8'D       ',X'80',AL3(HE#DOWN-HELPTEXT)\n         DC    CL8'DA      ',X'00',AL3(HE#DA-HELPTEXT)\n*%%%     DC    CL8'DC      ',X'80',AL3(HE#CPU-HELPTEXT)   obsolete\n         DC    CL8'DD      ',X'00',AL3(HE#DD-HELPTEXT)\n         DC    CL8'DEL     ',X'80',AL3(HE#DEL-HELPTEXT)\n         DC    CL8'DELETE  ',X'00',AL3(HE#DEL-HELPTEXT)\n         DC    CL8'DEVICES ',X'00',AL3(HE#DEV-HELPTEXT)\n         DC    CL8'DEV     ',X'80',AL3(HE#DEV-HELPTEXT)\n         DC    CL8'DH      ',X'00',AL3(HE#DH-HELPTEXT)\n         DC    CL8'DI      ',X'00',AL3(HE#DI-HELPTEXT)\n         DC    CL8'DJ      ',X'00',AL3(HE#DJ-HELPTEXT)\n         DC    CL8'DN      ',X'00',AL3(HE#DN-HELPTEXT)\n         DC    CL8'DO      ',X'00',AL3(HE#DO-HELPTEXT)\n         DC    CL8'DOWN    ',X'00',AL3(HE#DOWN-HELPTEXT)\n         DC    CL8'DQ      ',X'00',AL3(HE#DQ-HELPTEXT)\n         DC    CL8'DS      ',X'00',AL3(HE#DS-HELPTEXT)\n         DC    CL8'DSS     ',X'00',AL3(HE#DSS-HELPTEXT)\n         DC    CL8'DT      ',X'00',AL3(HE#DT-HELPTEXT)\n         DC    CL8'E       ',X'80',AL3(HE#END-HELPTEXT)\n*%%%     DC    CL8'ED      ',X'80',AL3(HE#ED-HELPTEXT)\n*%%%     DC    CL8'EDIT    ',X'00',AL3(HE#ED-HELPTEXT)\n*%%%     DC    CL8'EJ      ',X'00',AL3(HE#EJ-HELPTEXT)\n         DC    CL8'ELIST   ',X'80',AL3(HE#ELIST-HELPTEXT)\n         DC    CL8'EL      ',X'80',AL3(HE#ELIST-HELPTEXT)\n         DC    CL8'END     ',X'00',AL3(HE#END-HELPTEXT)\n         DC    CL8'EXIT    ',X'00',AL3(HE#EXIT-HELPTEXT)\n         DC    CL8'F       ',X'80',AL3(HE#FIND-HELPTEXT)\n         DC    CL8'FA      ',X'80',AL3(HE#FALL-HELPTEXT)\n         DC    CL8'FALL    ',X'00',AL3(HE#FALL-HELPTEXT)\n         DC    CL8'FIND    ',X'00',AL3(HE#FIND-HELPTEXT)\n         DC    CL8'FT      ',X'80',AL3(HE#FTIME-HELPTEXT)\n         DC    CL8'FTIME   ',X'00',AL3(HE#FTIME-HELPTEXT)\n         DC    CL8'H       ',X'80',AL3(HE#HELP-HELPTEXT)\n         DC    CL8'HB      ',X'00',AL3(HE#HB-HELPTEXT)\n*%%%     DC    CL8'HCT     ',X'00',AL3(HE#HCT-HELPTEXT)\n         DC    CL8'HELP    ',X'00',AL3(HE#HELP-HELPTEXT)\n         DC    CL8'HF      ',X'00',AL3(HE#HF-HELPTEXT)\n         DC    CL8'HI      ',X'80',AL3(HE#DI-HELPTEXT)\n         DC    CL8'HJ      ',X'00',AL3(HE#HJ-HELPTEXT)\n         DC    CL8'HOLD    ',X'80',AL3(HE#HJ-HELPTEXT)\n*%%%     DC    CL8'IN      ',X'80',AL3(HE#INIT-HELPTEXT)\n*%%%     DC    CL8'INIT    ',X'00',AL3(HE#INIT-HELPTEXT)\n         DC    CL8'IOQ     ',X'00',AL3(HE#IOQ-HELPTEXT)\n         DC    CL8'J       ',X'80',AL3(HE#JSUMM-HELPTEXT)\n         DC    CL8'JC      ',X'80',AL3(HE#JCL-HELPTEXT)\n         DC    CL8'JCL     ',X'00',AL3(HE#JCL-HELPTEXT)\n*%%%     DC    CL8'JCT     ',X'00',AL3(HE#JCT-HELPTEXT)  line cmd = JT\n         DC    CL8'JD      ',X'00',AL3(HE#JD-HELPTEXT)\n*%%%     DC    CL8'JDX     ',X'00',AL3(HE#JDX-HELPTEXT)\n         DC    CL8'JL      ',X'80',AL3(HE#JLOG-HELPTEXT)\n         DC    CL8'JLOG    ',X'00',AL3(HE#JLOG-HELPTEXT)\n         DC    CL8'JM      ',X'80',AL3(HE#JMSG-HELPTEXT)\n         DC    CL8'JMSG    ',X'00',AL3(HE#JMSG-HELPTEXT)\n         DC    CL8'JN      ',X'80',AL3(HE#JNEWS-HELPTEXT)\n         DC    CL8'JNEWS   ',X'00',AL3(HE#JNEWS-HELPTEXT)\n         DC    CL8'JSUMM   ',X'00',AL3(HE#JSUMM-HELPTEXT)\n         DC    CL8'JS      ',X'80',AL3(HE#JSUMM-HELPTEXT)\n         DC    CL8'JOB     ',X'80',AL3(HE#JD-HELPTEXT)\n*%%%     DC    CL8'JOBX    ',X'80',AL3(HE#JDX-HELPTEXT)  line cmd = JX\n*%%%     DC    CL8'JOE     ',X'00',AL3(HE#JOE-HELPTEXT)\n*%%%     DC    CL8'JQE     ',X'00',AL3(HE#JQE-HELPTEXT)\n*%%%     DC    CL8'JX      ',X'00',AL3(HE#JDX-HELPTEXT)  line cmd = JX\n         DC    CL8'L       ',X'80',AL3(HE#LIST-HELPTEXT)\n*%%%     DC    CL8'LBLK    ',X'00',AL3(HE#LBLK-HELPTEXT)  line cmd = LB\n*%%%     DC    CL8'LDAS    ',X'00',AL3(HE#LDAS-HELPTEXT)\n         DC    CL8'LE      ',X'80',AL3(HE#LEFT-HELPTEXT)\n         DC    CL8'LEFT    ',X'00',AL3(HE#LEFT-HELPTEXT)\n         DC    CL8'LINECMDS',X'00',AL3(HE#LCMDS-HELPTEXT)\n         DC    CL8'LIST    ',X'00',AL3(HE#LIST-HELPTEXT)\n*%%%     DC    CL8'LKIT    ',X'00',AL3(HE#LKIT-HELPTEXT)\n*%%%     DC    CL8'LL      ',X'00',AL3(HE#LL-HELPTEXT) doesn't work yet\n         DC    CL8'LRMT    ',X'00',AL3(HE#LRMT-HELPTEXT)\n*%%%     DC    CL8'LSYS    ',X'00',AL3(HE#LSYS-HELPTEXT)\n*%%%     DC    CL8'LTXT    ',X'00',AL3(HE#LTXT-HELPTEXT)  line cmd = LT\n*%%%     DC    CL8'MCS     ',X'80',AL3(HE#CONS-HELPTEXT)\n         DC    CL8'MD      ',X'00',AL3(HE#MD-HELPTEXT)\n         DC    CL8'MODE    ',X'00',AL3(HE#MODE-HELPTEXT)\n         DC    CL8'NJ      ',X'00',AL3(HE#NJ-HELPTEXT)\n         DC    CL8'NS      ',X'00',AL3(HE#NS-HELPTEXT)\n         DC    CL8'P       ',X'80',AL3(HE#PAGE-HELPTEXT)\n         DC    CL8'PAGE    ',X'00',AL3(HE#PAGE-HELPTEXT)\n         DC    CL8'PB      ',X'00',AL3(HE#PB-HELPTEXT)\n*%%%     DC    CL8'PDDB    ',X'00',AL3(HE#PDDB-HELPTEXT)\n         DC    CL8'PF      ',X'00',AL3(HE#PF-HELPTEXT)\n         DC    CL8'PFK     ',X'00',AL3(HE#PFK-HELPTEXT)\n         DC    CL8'PJ      ',X'80',AL3(HE#PURGE-HELPTEXT)\n         DC    CL8'PR      ',X'80',AL3(HE#PRINT-HELPTEXT)\n         DC    CL8'PRINT   ',X'00',AL3(HE#PRINT-HELPTEXT)\n         DC    CL8'PRIV    ',X'80',AL3(HE#PRIV-HELPTEXT)\n         DC    CL8'PRIVCMDS',X'00',AL3(HE#PRIV-HELPTEXT)\n         DC    CL8'PS      ',X'00',AL3(HE#PS-HELPTEXT)\n         DC    CL8'PUR     ',X'80',AL3(HE#PURGE-HELPTEXT)\n         DC    CL8'PURGE   ',X'00',AL3(HE#PURGE-HELPTEXT)\n*%%%     DC    CL8'QCMN    ',X'00',AL3(HE#QCMN-HELPTEXT)\n         DC    CL8'QINT    ',X'00',AL3(HE#QINT-HELPTEXT)\n         DC    CL8'QPROF   ',X'00',AL3(HE#QPROF-HELPTEXT)\n         DC    CL8'QUIT    ',X'80',AL3(HE#EXIT-HELPTEXT)\n         DC    CL8'RD      ',X'80',AL3(HE#RD-HELPTEXT)\n         DC    CL8'RE      ',X'80',AL3(HE#RE-HELPTEXT)\n         DC    CL8'REDISP  ',X'00',AL3(HE#RD-HELPTEXT)\n         DC    CL8'REL     ',X'80',AL3(HE#AJ-HELPTEXT)\n         DC    CL8'RELEASE ',X'80',AL3(HE#AJ-HELPTEXT)\n         DC    CL8'REPOS   ',X'00',AL3(HE#REPOS-HELPTEXT)\n         DC    CL8'REQ     ',X'80',AL3(HE#REQ-HELPTEXT)\n         DC    CL8'REQUEUE ',X'00',AL3(HE#REQ-HELPTEXT)\n         DC    CL8'RET     ',X'80',AL3(HE#EXIT-HELPTEXT)\n         DC    CL8'RETRIEVE',X'00',AL3(HE#RE-HELPTEXT)\n         DC    CL8'RETURN  ',X'80',AL3(HE#EXIT-HELPTEXT)\n         DC    CL8'RI      ',X'80',AL3(HE#RIGHT-HELPTEXT)\n         DC    CL8'RIGHT   ',X'00',AL3(HE#RIGHT-HELPTEXT)\n         DC    CL8'RJ      ',X'80',AL3(HE#ROUTE-HELPTEXT)\n         DC    CL8'ROU     ',X'80',AL3(HE#ROUTE-HELPTEXT)\n         DC    CL8'ROUTE   ',X'00',AL3(HE#ROUTE-HELPTEXT)\n         DC    CL8'SAVE    ',X'00',AL3(HE#SAVE-HELPTEXT)\n         DC    CL8'S       ',X'80',AL3(HE#SJ-HELPTEXT)\n*%%%     DC    CL8'SETUP   ',X'00',AL3(HE#SETUP-HELPTEXT)\n         DC    CL8'SJ      ',X'00',AL3(HE#SJ-HELPTEXT)\n         DC    CL8'SL      ',X'80',AL3(HE#SLOG-HELPTEXT)\n         DC    CL8'SLOG    ',X'00',AL3(HE#SLOG-HELPTEXT)\n*%%%     DC    CL8'SPSP    ',X'00',AL3(HE#SPSP-HELPTEXT)\n         DC    CL8'ST      ',X'80',AL3(HE#STAT-HELPTEXT)\n         DC    CL8'STATUS  ',X'00',AL3(HE#STAT-HELPTEXT)\n         DC    CL8'STOP    ',X'80',AL3(HE#EXIT-HELPTEXT)\n*%%%     DC    CL8'SU      ',X'80',AL3(HE#SETUP-HELPTEXT)\n         DC    CL8'SYNTAX  ',X'00',AL3(HE#SYNT-HELPTEXT)\n         DC    CL8'T       ',X'80',AL3(HE#TOP-HELPTEXT)\n*%%%     DC    CL8'TGPS    ',X'80',AL3(HE#SPSP-HELPTEXT)\n*%%%     DC    CL8'TJ      ',X'00',AL3(HE#TJ-HELPTEXT)\n         DC    CL8'TOP     ',X'00',AL3(HE#TOP-HELPTEXT)\n         DC    CL8'TOPICS  ',X'00',AL3(HE#TOPIC-HELPTEXT)\n          AIF   (NOT &@@TMPSV).HE#NTS1\n         DC    CL8'TSO     ',X'00',AL3(HE#TSO-HELPTEXT)\n.HE#NTS1  ANOP\n         DC    CL8'U       ',X'80',AL3(HE#UP-HELPTEXT)\n         DC    CL8'UP      ',X'00',AL3(HE#UP-HELPTEXT)\n*%%%     DC    CL8'XB      ',X'80',AL3(HE#XBLK-HELPTEXT)\n*%%%     DC    CL8'XBLK    ',X'00',AL3(HE#XBLK-HELPTEXT)\n*%%%     DC    CL8'XJ      ',X'80',AL3(HE#XJ-HELPTEXT)  line cmd = XJ\n*%%%     DC    CL8'XP      ',X'00',AL3(HE#XP-HELPTEXT)\nHELPEND  DC    X'FFFFFFFFFFFFFFFFFFFFFFFF'\n         EJECT\nHE#ADMN  DC    AL1(060,0,00),C'                             << Administ$\n               rative subcommands >>'\n         DC    AL1(037,0,00),C'DELete    - Delete a job''s held output'$\n\n         DC    AL1(041,0,00),C'REQueue   - Change held output to non-he$\n               ld'\n         DC    AL1(055,0,00),C'CANcel|CJ - Cancel a job and optionally $\n               purge the output'\n         DC    AL1(034,0,00),C'ROUte|RJ  - Re-route a job''s output'\n          AIF   (NOT &@@TMPSV).HE#NTS2\n         DC    AL1(034,0,00),C'TSO       - Execute any TSO command'\n.HE#NTS2  ANOP\n         DC    AL1(061,0,00),C'MODE      - Display and set various QUEU$\n               E options and defaults'\n         DC    AL1(046,0,00),C'COLS      - Turn column scale display on$\n                or off'\n         DC    AL1(070,1,00),C'QINT      - Display and set various inte$\n               rnal QUEUE options and defaults'\n         DC    AL1(045,0,00),C'LRMT      - List JES2 remote destination$\n                names'\n         DC    AL1(049,0,00),C'*         - Recall a previously entered $\n               subcommand'\n         DC    AL1(033,0,00),C'Help|?    - Display help for QUEUE'\n         DC    AL1(061,0,00),C'CHGS      - List updates and enhancement$\n               s to the QUEUE command'\n         DC    AL1(055,0,00),C'End       - Return to next higher level $\n               QUEUE subcommand'\n         DC    AL1(034,0,00),C'EXIT|STOP|QUIT|RETURN - Leave QUEUE'\n         DC    AL1(047,0,00),C'SAVE      - Create a copy of the current$\n                dataset'\n         DC    AL1(060,0,00),C'PRint     - Open print file and/or print$\n                current screen image'\n         DC    AL1(078,0,00),C'COPY      - Copy all or part of the curr$\n               ently selected spooled dataset to print'\n         DC    X'FF'                    Flag end of screen\n         SPACE 3\nHE#AJ    DC    AL1(000,0,00),C' '\n         DC    AL1(035,0,00),C' The \"AJ\" subcommand releases a job.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(021,0,02),X'1DE8',C'Syntax',X'1D60',C'- AJ <jobid>'\n         DC    AL1(024,0,02),X'1DE8',C'Aliases',X'1D60',C'- RELEASE, RE$\n               L'\n         DC    AL1(068,0,04),C' From a status display,',X'1DE8',C'AJ',X$\n               '1D60',C'or',X'1DE8',C'A',X'1D60',C'may be entered as a $\n               line command.'\n         DC    AL1(081,0,02),C' (See',X'1DE8',C'\"Help LINECMDS\"',X'1D60$\n               ',C'for information on entering subcommands as line comm$\n               ands.)'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(012,0,02),X'1DE8',C'Operands',X'1D60',C'-'\n         DC    AL1(042,0,00),C'   <jobid> - The name or number of the j$\n               ob.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(073,0,04),X'1DE8',C'Note    ',X'1D60',C'- An asteris$\n               k',X'1DE8',C'(\"*\")',X'1D60',C'may be used in place of <j$\n               obid> to refer'\n         DC    AL1(045,0,00),C'            to the most recently selecte$\n               d job.'\n          AIF (&@@SCSVC NE 0 OR &@@TSOE GE 120).HE#AJ\n         DC    AL1(064,0,00),C'NOTE:  The \"AJ\" subcommand can only func$\n               tion if QUEUE was entered'\n         DC    AL1(060,0,00),C'       at the \"READY\" level (i.e., it ca$\n               nnot work inside SPF)'\n.HE#AJ    ANOP\n         DC    X'FF'                    Flag end of screen\n         SPACE 3\nHE#ATTR  DC    AL1(000,0,00),C' '\n         DC    AL1(062,0,00),C' The \"ATTR subcommand displays attribute$\n               s of a spooled dataset.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(030,0,02),X'1DE8',C'Syntax',X'1D60',C'- ATTR <jobid>$\n                <dsid>'\n         DC    AL1(013,0,02),X'1DE8',C' Alias',X'1D60',C'- AT'\n         DC    AL1(069,0,06),C' From the',X'1DE8',C'DDname',X'1D60',C'd$\n               isplay, line command',X'1DE8',C'AT',X'1D60',C'may be use$\n               d for',X'1DE8',C'ATTR.',X'1D60'\n         DC    AL1(081,0,02),C' (See',X'1DE8',C'\"Help LINECMDS\"',X'1D60$\n               ',C'for information on entering subcommands as line comm$\n               ands.)'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(012,0,02),X'1DE8',C'Operands',X'1D60',C'-'\n         DC    AL1(042,0,00),C'   <jobid> - The name or number of the j$\n               ob.'\n         DC    AL1(075,0,02),C'   <dsid>  - The DSID of the dataset, as$\n                displayed by the',X'1DE8',C'\"DD\"',X'1D60',C'subcommand.$\n               '\n         DC    AL1(000,0,00),C' '\n         DC    AL1(068,0,02),X'1DE8',C'Defaults',X'1D60',C'- If no oper$\n               ands are entered, attributes of the currently'\n         DC    AL1(054,0,00),C'            selected spooled dataset wil$\n               l be displayed.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(073,0,04),X'1DE8',C'Note    ',X'1D60',C'- An asteris$\n               k',X'1DE8',C'(\"*\")',X'1D60',C'may be used in place of <j$\n               obid> to refer'\n         DC    AL1(045,0,00),C'            to the most recently selecte$\n               d job.'\n         DC    X'FF'                    Flag end of screen\n         SPACE 3\nHE#BOT   DC    AL1(000,0,00),C' '\n         DC    AL1(069,0,00),C' The \"BOTTOM\" subcommand repositions the$\n                currently selected dataset to'\n         DC    AL1(011,0,00),C' the bottom.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(017,0,02),X'1DE8',C'Syntax',X'1D60',C'- BOTTOM'\n         DC    AL1(018,0,02),X'1DE8',C'Aliases',X'1D60',C'- BOT, B'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(018,0,02),X'1DE8',C'Operands',X'1D60',C'- None.'\n         DC    X'FF'                    Flag end of screen\n         SPACE 3\nHE#CHGS  DC    AL1(000,0,00),C' '\n         DC    AL1(068,0,00),C' The \"CHGS\" subcommand lists, in reverse$\n                chronological order, changes'\n         DC    AL1(066,0,00),C' which have been made to the QUEUE comma$\n               nd.  This display should be'\n         DC    AL1(070,0,00),C' checked periodically to see what''s new$\n               .  You only need to page through'\n         DC    AL1(061,0,00),C' until you come to the start of what you$\n                have previously seen.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(015,0,02),X'1DE8',C'Syntax',X'1D60',C'- CHGS'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(018,0,02),X'1DE8',C'Operands',X'1D60',C'- None.'\n         DC    AL1(068,1,00),C'            For privileged users, the fo$\n               llowing operand is available:'\n         DC    AL1(000,1,00),C' '\n         DC    AL1(062,1,00),C'   INTERNAL - Internal (design/logic) ch$\n               anges are to be listed.'\n         DC    X'FF'                    Flag end of screen\n         SPACE 3\nHE#CMDS  DC    AL1(051,0,00),C'                             << QUEUE su$\n               bcommands >>'\n         DC    AL1(074,0,00),C' AI  AO  ATtr  Bottom  BRowse  CANcel  C$\n               HGS  Col  COLumn  COPY  CPU  DA  DD'\n         DC    AL1(076,0,00),C' DELete  DEVices  DH  DI  DJ  DO  Down  $\n               DN  DQ  DS  DT  EDit  End  EXIT  Find'\n         DC    AL1(075,0,00),C' FAll  HB  Help  HF  HI  INit  JCl  JD  $\n               JLog  JMsg  JNews  Jsumm  LEft  List'\n         DC    AL1(073,0,00),C' LRMT  MD  MODE  NS  Page  PB  PF  PFK  $\n               PRint  PS  PURGE  REtrieve  REDISP'\n         DC    AL1(053,0,00),C' REQueue  RIght  ROUte  SAVE  SJ  STatus$\n                 Top  TSO  Up'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(081,1,02),X'1DE8',C'-------  The following subcomman$\n               ds are restricted to privileged users: -------',X'1D60'\n         DC    AL1(070,1,00),C' /  ABEND  AJ  CKPT  CONS  EJ  FTime  HC$\n               T  HJ  JCT  JDX  JQE  JOE  LBLK'\n         DC    AL1(070,1,00),C' LDAS  LKIT  LTXT  LSYS  PDDB  QCMN  QIN$\n               T  SLog  SPSP  TJ  XBlk  XJ  XP'\n         DC    AL1(000,1,00),C' '\n         DC    AL1(069,1,01),X'1DE8',C'*******  Many of the control blo$\n               ck display commands (privileged) are'\n         DC    AL1(068,1,01),X'1DE8',C'*******  being rewritten.  Some $\n               of the new commands don''t work yet.'\n         DC    AL1(068,1,01),X'1DE8',C'*******  If you get an S0C3 on o$\n               ne of these, the old command may be'\n         DC    AL1(064,1,01),X'1DE8',C'*******  available with an X pre$\n               fix.  For example, JCT -> XJCT.'\n         DC    AL1(000,1,00),C' '\n         DC    AL1(000,0,00),C' '\n         DC    AL1(062,0,04),C' For more information, enter',X'1DE8',C'$\n               HELP subcmdname',X'1D60',C'or',X'1DE8',C'HELP HELP.',X'1$\n               D60'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(076,0,02),C' In addition, HELP for other topics is a$\n               vailable, by entering',X'1DE8',C'HELP',X'1D60',C'followe$\n               d'\n         DC    AL1(051,0,02),C' by one of the keywords listed under',X'$\n               1DE8',C'HELP TOPICS.',X'1D60'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(057,0,02),X'1DE8',C'NOTE:',X'1D60',C' As of May 25, $\n               1989, help should now be complete.'\n         DC    AL1(038,1,00),C' Except for the privileged subcommands!'$\n\n         DC    X'FF'                    Flag end of screen\n         SPACE 3\nHE#CAN   DC    AL1(000,0,00),C' '\n         DC    AL1(068,0,00),C' The \"CANCEL\" subcommand cancels an inpu$\n               t or execution job, or purges'\n         DC    AL1(040,0,00),C' all output for a job on an output queue$\n               .'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(033,0,02),X'1DE8',C'Syntax',X'1D60',C'- CANCEL <jobi$\n               d> (PURGE)'\n         DC    AL1(019,0,02),X'1DE8',C'Aliases',X'1D60',C'- CAN, CJ'\n         DC    AL1(083,0,06),C' From a status display,',X'1DE8',C'CJ',X$\n               '1D60',C'or',X'1DE8',C'CA',X'1D60',C'may be entered as a$\n                line command for',X'1DE8',C'CANcel.',X'1D60'\n         DC    AL1(081,0,02),C' (See',X'1DE8',C'\"Help LINECMDS\"',X'1D60$\n               ',C'for information on entering subcommands as line comm$\n               ands.)'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(012,0,02),X'1DE8',C'Operands',X'1D60',C'-'\n         DC    AL1(042,0,00),C'   <jobid> - The name or number of the j$\n               ob.'\n         DC    AL1(071,0,00),C'   PURGE   - If PURGE is entered, all ou$\n               tput for the job will be purged.'\n         DC    AL1(071,0,00),C'             This operand is required if$\n                the job is on the output queue.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(073,0,04),X'1DE8',C'Note    ',X'1D60',C'- An asteris$\n               k',X'1DE8',C'(\"*\")',X'1D60',C'may be used in place of <j$\n               obid> to refer'\n         DC    AL1(045,0,00),C'            to the most recently selecte$\n               d job.'\n         AIF (&@@TMPSV OR &@@SCSVC NE 0 OR &@@TSOE GE 120).HE#CAN\n         DC    AL1(068,0,00),C'NOTE:  The \"CANCEL\" subcommand can only $\n               function if QUEUE was entered'\n         DC    AL1(060,0,00),C'       at the \"READY\" level (i.e., it ca$\n               nnot work inside SPF)'\n.HE#CAN   ANOP\n         DC    X'FF'                    Flag end of screen\n         SPACE 3\nHE#COL   DC    AL1(000,0,00),C' '\n         DC    AL1(073,0,00),C' The \"COLumn\" subcommand repositions the$\n                currently selected dataset to the'\n         DC    AL1(024,0,00),C' requested column number.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(023,0,02),X'1DE8',C'Syntax',X'1D60',C'- COLUMN <col>$\n               '\n         DC    AL1(019,0,02),X'1DE8',C' Aliases',X'1D60',C'- COL, C'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(012,0,02),X'1DE8',C'Operands',X'1D60',C'-'\n         DC    AL1(071,0,00),C'   <col> - The column which should be th$\n               e leftmost column on the screen.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(070,0,02),X'1DE8',C'Defaults',X'1D60',C'- The origin$\n               al column number specified or defaulted to when'\n         DC    AL1(044,0,00),C'            the current dataset was sele$\n               cted.'\n         DC    X'FF'                    Flag end of screen\n         SPACE 3\nHE#COLS  DC    AL1(000,0,00),C' '\n         DC    AL1(055,0,00),C' The \"COLS\" subcommand turns the column $\n               scale on or off.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(022,0,02),X'1DE8',C'Syntax',X'1D60',C'- COLS ON OFF'$\n\n         DC    AL1(000,0,00),C' '\n         DC    AL1(012,0,02),X'1DE8',C'Operands',X'1D60',C'-'\n         DC    AL1(044,0,00),C'   ON  - The column scale is to be displ$\n               ayed.'\n         DC    AL1(048,0,00),C'   OFF - The column scale is not to be d$\n               isplayed.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(039,0,02),X'1DE8',C'Default',X'1D60',C'- ON, if no o$\n               perand is given.'\n         DC    X'FF'                    Flag end of screen\n         SPACE 3\nHE#COPY  DC    AL1(000,0,00),C' '\n         DC    AL1(071,0,00),C' The \"COPY\" subcommand copies all or a p$\n               ortion of the currently selected'\n         DC    AL1(018,0,00),C' dataset to sysout.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(019,0,02),X'1DE8',C'Syntax',X'1D60',C'- COPY ALL'\n         DC    AL1(013,0,00),C'          -or-'\n         DC    AL1(027,0,00),C'          COPY <start> <end>'\n         DC    AL1(013,0,02),X'1DE8',C' Alias',X'1D60',C'- CY'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(012,0,02),X'1DE8',C'Operands',X'1D60',C'-'\n         DC    AL1(050,0,00),C'   ALL     - The complete dataset should$\n                be copied.'\n         DC    AL1(049,0,00),C'   <start> - The number of the first lin$\n               e to copy.'\n         DC    AL1(048,0,00),C'   <end>   - The number of the last line$\n                to copy.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(045,0,04),X'1DE8',C'Note:   ',X'1D60',C'- See also t$\n               he',X'1DE8',C'PRINT',X'1D60',C'subcommand.'\n         DC    X'FF'                    Flag end of screen\n         SPACE 3\nHE#CPU   DC    AL1(000,0,00),C' '\n         DC    AL1(062,0,00),C' The \"CPU\" subcommand displays CPU relat$\n               ed information for jobs'\n         DC    AL1(042,0,00),C' executing on the CPU you are logged on $\n               to.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(014,0,02),X'1DE8',C'Syntax',X'1D60',C'- CPU'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(012,0,02),X'1DE8',C'Operands',X'1D60',C'-'\n         DC    AL1(038,0,00),C'   J - Limit the display to batch jobs.'$\n\n         DC    AL1(041,0,00),C'   S - Limit the display to started task$\n               s.'\n         DC    AL1(037,0,00),C'   T - Limit the display to TSO users.'\n         DC    AL1(057,0,00),C'   B - Limit the display to batch jobs p$\n               lus started tasks.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(014,0,02),X'1DE8',C'Defaults',X'1D60',C'- B'\n         DC    X'FF'                    Flag end of screen\n         SPACE 3\nHE#DA    DC    AL1(000,0,00),C' '\n         DC    AL1(060,0,00),C' The \"DA\" subcommand displays currently $\n               executing batch jobs.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(018,0,02),X'1DE8',C'Syntax',X'1D60',C'- DA TIME'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(012,0,02),X'1DE8',C'Operands',X'1D60',C'-'\n         DC    AL1(049,0,00),C'   /TIME    - Display the start time for$\n                each job.'\n         DC    AL1(029,0,00),C'   /T       - Alias for /TIME.'\n         DC    AL1(067,1,00),C'   /PERCENT - Display the percent of spo$\n               ol space in use by each job.'\n         DC    AL1(032,1,00),C'   /PCT     - Alias for /PERCENT.'\n         DC    AL1(032,1,00),C'   /P       - Alias for /PERCENT.'\n         DC    AL1(066,1,00),C'   /SPACE   - Display the amount of spoo$\n               l space in use by each job.'\n         DC    AL1(030,1,00),C'   /SIZE    - Alias for /SPACE.'\n         DC    AL1(030,1,00),C'   /S       - Alias for /SPACE.'\n         DC    X'FF'                    Flag end of screen\n         SPACE 3\nHE#DD    DC    AL1(000,0,00),C' '\n         DC    AL1(078,0,00),C' The \"DD\" subcommand displays the DSID f$\n               or each SYSIN/SYSOUT dataset for a job.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(021,0,02),X'1DE8',C'Syntax',X'1D60',C'- DD <jobid>'\n         DC    AL1(075,0,04),C' From a status display,',X'1DE8',C'DD',X$\n               '1D60',C'may be entered as a line command for',X'1DE8',C$\n               'DDname.',X'1D60'\n         DC    AL1(081,0,02),C' (See',X'1DE8',C'\"Help LINECMDS\"',X'1D60$\n               ',C'for information on entering subcommands as line comm$\n               ands.)'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(012,0,02),X'1DE8',C'Operands',X'1D60',C'-'\n         DC    AL1(042,0,00),C'   <jobid> - The name or number of the j$\n               ob.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(069,0,02),X'1DE8',C'Defaults',X'1D60',C'- DSIDs for $\n               the previously selected job will be displayed.'\n         DC    X'FF'                    Flag end of screen\n         SPACE 3\nHE#DEL   DC    AL1(000,0,00),C' '\n         DC    AL1(058,0,00),C' The \"DELETE\" subcommand deletes the hel$\n               d sysout for a job.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(025,0,02),X'1DE8',C'Syntax',X'1D60',C'- DELETE <jobi$\n               d>'\n         DC    AL1(014,0,02),X'1DE8',C' Alias',X'1D60',C'- DEL'\n         DC    AL1(083,0,06),C' From a status display,',X'1DE8',C'DE',X$\n               '1D60',C'or',X'1DE8',C'DL',X'1D60',C'may be entered as a$\n                line command for',X'1DE8',C'DELete.',X'1D60'\n         DC    AL1(081,0,02),C' (See',X'1DE8',C'\"Help LINECMDS\"',X'1D60$\n               ',C'for information on entering subcommands as line comm$\n               ands.)'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(012,0,02),X'1DE8',C'Operands',X'1D60',C'-'\n         DC    AL1(042,0,00),C'   <jobid> - The name or number of the j$\n               ob.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(073,0,04),X'1DE8',C'Note    ',X'1D60',C'- An asteris$\n               k',X'1DE8',C'(\"*\")',X'1D60',C'may be used in place of <j$\n               obid> to refer'\n         DC    AL1(045,0,00),C'            to the most recently selecte$\n               d job.'\n        AIF (&@@TMPSV OR &@@SCSVC NE 0 OR &@@TSOE GE 120).HE#DEL\n         DC    AL1(068,0,00),C'NOTE:  The \"DELETE\" subcommand can only $\n               function if QUEUE was entered'\n         DC    AL1(060,0,00),C'       at the \"READY\" level (i.e., it ca$\n               nnot work inside SPF)'\n.HE#DEL   ANOP\n         DC    X'FF'                    Flag end of screen\n         SPACE 3\nHE#DEV   DC    AL1(000,0,00),C' '\n         DC    AL1(065,0,00),C' The \"DEVICES\" subcommand displays jobs $\n               currently on JES2 devices.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(018,0,02),X'1DE8',C'Syntax',X'1D60',C'- DEVICES'\n         DC    AL1(013,0,02),X'1DE8',C'Alias',X'1D60',C'- DEV'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(018,0,02),X'1DE8',C'Operands',X'1D60',C'- None.'\n         DC    X'FF'                    Flag end of screen\n         SPACE 3\nHE#DH    DC    AL1(000,0,00),C' '\n         DC    AL1(059,0,00),C' The \"DH\" subcommand displays jobs in th$\n               e held output queue.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(022,0,02),X'1DE8',C'Syntax',X'1D60',C'- DH TIME ALL'$\n\n         DC    AL1(000,0,00),C' '\n         DC    AL1(012,0,02),X'1DE8',C'Operands',X'1D60',C'-'\n         DC    AL1(050,0,00),C'   /TIME    - Display the ending time fo$\n               r each job.'\n         DC    AL1(065,0,00),C'   /ALL     - Display all jobs in the $O$\n               UTPUT queue, regardless of'\n         DC    AL1(056,0,00),C'              whether they actually have$\n                any held output.'\n         DC    AL1(067,1,00),C'   /PERCENT - Display the percent of spo$\n               ol space in use by each job.'\n         DC    AL1(032,1,00),C'   /PCT     - Alias for /PERCENT.'\n         DC    AL1(032,1,00),C'   /P       - Alias for /PERCENT.'\n         DC    AL1(066,1,00),C'   /SPACE   - Display the amount of spoo$\n               l space in use by each job.'\n         DC    AL1(030,1,00),C'   /SIZE    - Alias for /SPACE.'\n         DC    AL1(030,1,00),C'   /S       - Alias for /SPACE.'\n         DC    X'FF'                    Flag end of screen\n         SPACE 3\nHE#DI    DC    AL1(000,0,00),C' '\n         DC    AL1(053,0,00),C' The \"DI\" subcommand displays jobs in th$\n               e input queue.'\n         DC    AL1(062,0,00),C' The \"AI\" subcommand displays jobs in th$\n               e input queue which are'\n         DC    AL1(066,0,00),C'    available for execution (not held an$\n               d not currently executing).'\n         DC    AL1(068,0,00),C' The \"HI\" subcommand displays jobs in th$\n               e input queue which are held.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(041,0,02),X'1DE8',C'Syntax',X'1D60',C'- DI <classes>$\n                TIME SYSAFF=<sid>'\n         DC    AL1(039,0,00),C'        - AI <classes> TIME SYSAFF=<sid>$\n               '\n         DC    AL1(039,0,00),C'        - HI <classes> TIME SYSAFF=<sid>$\n               '\n         DC    AL1(000,0,00),C' '\n         DC    AL1(012,0,02),X'1DE8',C'Operands',X'1D60',C'-'\n         DC    AL1(062,0,00),C'   <classes> - A list of up to 8 input c$\n               lasses to be displayed.'\n         DC    AL1(050,0,00),C'   /TIME     - Display the input time fo$\n               r each job.'\n         DC    AL1(069,0,00),C'   /SYSAFF   - Only select jobs with aff$\n               inity to the specified system.'\n         DC    AL1(067,0,00),C'               (This keyword may be repe$\n               ated to select jobs for more'\n         DC    AL1(031,0,00),C'               than one system.)'\n         DC    AL1(032,0,00),C'   /S        - Alias for /SYSAFF.'\n         DC    AL1(066,0,00),C'   <sid>     - A valid system id in the $\n               M.A.S. complex.  \"*\" may be'\n         DC    AL1(063,0,00),C'               entered to denote the cur$\n               rent system (i.e., S=*).'\n         DC    AL1(068,1,00),C'   /PERCENT  - Display the percent of sp$\n               ool space in use by each job.'\n         DC    AL1(033,1,00),C'   /PCT      - Alias for /PERCENT.'\n         DC    AL1(033,1,00),C'   /P        - Alias for /PERCENT.'\n         DC    AL1(067,1,00),C'   /SPACE    - Display the amount of spo$\n               ol space in use by each job.'\n         DC    AL1(031,1,00),C'   /SIZE     - Alias for /SPACE.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(070,0,02),X'1DE8',C'Defaults',X'1D60',C'- All input $\n               classes will be displayed if none are selected.'\n         DC    AL1(063,0,00),C'            Jobs will be selected regard$\n               less of system affinity.'\n         DC    X'FF'                    Flag end of screen\n         SPACE 3\nHE#DJ    DC    AL1(000,0,00),C' '\n         DC    AL1(062,0,00),C' The \"DJ\" subcommand displays a specific$\n                job by name or number.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(029,0,02),X'1DE8',C'Syntax',X'1D60',C'- DJ <jobid> /$\n                OUT O'\n         DC    AL1(061,0,02),C' From a status display,',X'1DE8',C'DJ',X$\n               '1D60',C'may be entered as a line command.'\n         DC    AL1(081,0,02),C' (See',X'1DE8',C'\"Help LINECMDS\"',X'1D60$\n               ',C'for information on entering subcommands as line comm$\n               ands.)'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(012,0,02),X'1DE8',C'Operands',X'1D60',C'-'\n         DC    AL1(059,0,00),C'   <jobid>  - The name or number of the $\n               job to be displayed.'\n         DC    AL1(067,0,00),C'   /OUT     - Display output group names$\n                instead of the device name.'\n         DC    AL1(028,0,00),C'   /O       - Alias for /OUT.'\n         DC    AL1(067,1,00),C'   /PERCENT - Display the percent of spo$\n               ol space in use by each job.'\n         DC    AL1(032,1,00),C'   /PCT     - Alias for /PERCENT.'\n         DC    AL1(032,1,00),C'   /P       - Alias for /PERCENT.'\n         DC    AL1(066,1,00),C'   /SPACE   - Display the amount of spoo$\n               l space in use by each job.'\n         DC    AL1(030,1,00),C'   /SIZE    - Alias for /SPACE.'\n         DC    AL1(030,1,00),C'   /S       - Alias for /SPACE.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(059,0,02),X'1DE8',C'Defaults',X'1D60',C'- The previo$\n               usly selected job will be displayed.'\n         DC    X'FF'                    Flag end of screen\n         SPACE 3\nHE#DN    DC    AL1(000,0,00),C' '\n         DC    AL1(052,0,00),C' The \"DN\" subcommand displays all jobs i$\n               n all queues.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(021,0,02),X'1DE8',C'Syntax',X'1D60',C'- DN / OUT O'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(012,0,02),X'1DE8',C'Operands',X'1D60',C'-'\n         DC    AL1(068,0,00),C'   /OUT      - Display output group name$\n               s instead of the device name.'\n         DC    AL1(029,0,00),C'   /O        - Alias for /OUT.'\n         DC    AL1(067,1,00),C'   /PERCENT - Display the percent of spo$\n               ol space in use by each job.'\n         DC    AL1(032,1,00),C'   /PCT     - Alias for /PERCENT.'\n         DC    AL1(032,1,00),C'   /P       - Alias for /PERCENT.'\n         DC    AL1(066,1,00),C'   /SPACE   - Display the amount of spoo$\n               l space in use by each job.'\n         DC    AL1(030,1,00),C'   /SIZE    - Alias for /SPACE.'\n         DC    AL1(030,1,00),C'   /S       - Alias for /SPACE.'\n         DC    X'FF'                    Flag end of screen\n         SPACE 3\nHE#DO    DC    AL1(000,0,00),C' '\n         DC    AL1(054,0,00),C' The \"DO\" subcommand displays jobs in th$\n               e output queue.'\n         DC    AL1(063,0,00),C' The \"AO\" subcommand displays jobs in th$\n               e output queue which are'\n         DC    AL1(066,0,00),C'    available for printing, punching, or$\n                plotting (not held and not'\n         DC    AL1(028,0,00),C'    currently on any device).'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(062,0,02),X'1DE8',C'Syntax',X'1D60',C'- DO <classes>$\n                / TIME USER OUT O R=<dest> W=<wtrname>'\n         DC    AL1(060,0,00),C'        - AO <classes> / TIME USER OUT O$\n                R=<dest> W=<wtrname>'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(012,0,02),X'1DE8',C'Operands',X'1D60',C'-'\n         DC    AL1(063,0,00),C'   <classes> - A list of up to 8 output $\n               classes to be displayed.'\n         DC    AL1(069,0,00),C'   /TIME     - Display the time each job$\n                appeared on the output queue.'\n         DC    AL1(072,0,00),C'   /USER     - Display the submitter''s $\n               userid instead of the remote name.'\n         DC    AL1(068,0,00),C'   /OUT      - Display output group name$\n               s instead of the device name.'\n         DC    AL1(029,0,00),C'   /O        - Alias for /OUT.'\n         DC    AL1(075,0,00),C'   R=<dest>  - Select output jobs for <d$\n               est>.  If <dest> ends with ''*'', then'\n         DC    AL1(074,0,00),C'               all dests starting with <$\n               dest> (minus the ''*'') are selected.'\n         DC    AL1(054,0,00),C'   R=ALL     - Select output jobs for al$\n               l destinations.'\n         DC    AL1(067,0,00),C'   W=<wtrname> - Select output jobs with$\n                a writer name of <wtrname>.'\n         DC    AL1(070,0,00),C'               (If the job is destined f$\n               or a TSO user, the userid is in'\n         DC    AL1(037,0,00),C'               the writer name field.)'\n         DC    AL1(068,0,00),C'   W=ALL     - Select output jobs which $\n               have a non-blank writer name.'\n         DC    AL1(068,1,00),C'   /PERCENT  - Display the percent of sp$\n               ool space in use by each job.'\n         DC    AL1(033,1,00),C'   /PCT      - Alias for /PERCENT.'\n         DC    AL1(033,1,00),C'   /P        - Alias for /PERCENT.'\n         DC    AL1(067,1,00),C'   /SPACE    - Display the amount of spo$\n               ol space in use by each job.'\n         DC    AL1(031,1,00),C'   /SIZE     - Alias for /SPACE.'\n         DC    AL1(031,1,00),C'   /S        - Alias for /SPACE.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(071,0,02),X'1DE8',C'Defaults',X'1D60',C'- All output$\n                classes will be displayed if none are selected.'\n         DC    AL1(068,0,00),C'            Only output for your logon d$\n               estination will be displayed.'\n         DC    AL1(077,0,00),C'          - If W is entered with no oper$\n               and, no selection based on writer name'\n         DC    AL1(077,0,00),C'            will occur, but the writer n$\n               ame will be displayed instead of dest.'\n         DC    X'FF'                    Flag end of screen\n         SPACE 3\nHE#DOWN  DC    AL1(000,0,00),C' '\n         DC    AL1(071,0,00),C' The \"DOWN\" subcommand repositions the c$\n               urrently selected dataset toward'\n         DC    AL1(011,0,00),C' the bottom.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(019,0,02),X'1DE8',C'Syntax',X'1D60',C'- DOWN <#>'\n         DC    AL1(012,0,02),X'1DE8',C' Alias',X'1D60',C'- D'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(012,0,02),X'1DE8',C'Operands',X'1D60',C'-'\n         DC    AL1(070,0,00),C'   <#> - The number of records to go for$\n               ward from the current position.'\n         DC    X'FF'                    Flag end of screen\n         SPACE 3\nHE#DQ    DC    AL1(000,0,00),C' '\n         DC    AL1(070,0,00),C' The \"DQ\" subcommand displays the number$\n                of jobs in the various queues.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(013,0,02),X'1DE8',C'Syntax',X'1D60',C'- DQ'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(012,0,02),X'1DE8',C'Operands',X'1D60',C'-'\n         DC    AL1(028,0,00),C'   I - Limit to input queues.'\n         DC    AL1(029,0,00),C'   O - Limit to output queues.'\n         DC    AL1(036,0,00),C'   M - Limit to miscellaneous queues.'\n         DC    AL1(078,0,00),C'   X - Count all $OUTPUT jobs, regardles$\n               s of whether they have any held output.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(047,0,02),X'1DE8',C'Defaults',X'1D60',C'- All queue $\n               types will be displayed.'\n         DC    X'FF'                    Flag end of screen\n         SPACE 3\nHE#DS    DC    AL1(000,0,00),C' '\n         DC    AL1(063,0,00),C' The \"DS\" subcommand displays currently $\n               executing started tasks.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(018,0,02),X'1DE8',C'Syntax',X'1D60',C'- DS TIME'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(012,0,02),X'1DE8',C'Operands',X'1D60',C'-'\n         DC    AL1(047,0,00),C'   /TIME - Display the start time for ea$\n               ch task.'\n         DC    X'FF'                    Flag end of screen\n         SPACE 3\nHE#DSS   DC    AL1(063,0,00),C'                             << Dataset $\n               selection subcommands >>'\n         DC    AL1(019,0,00),C'JCl       - List JCL'\n         DC    AL1(027,0,00),C'JLog      - List JES2 joblog'\n         DC    AL1(031,0,00),C'JMsg      - List system messages'\n         DC    AL1(054,0,00),C'DD        - Display DSID''s of SYSIN and$\n                SYSOUT datasets'\n         DC    AL1(041,0,00),C'List      - List a SYSIN or SYSOUT datas$\n               et'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(048,0,00),C'SJ        - Select first SYSOUT dataset $\n               for a job'\n         DC    AL1(061,0,00),C'NS        - Select the next SYSOUT datas$\n               et (must use SJ first)'\n         DC    AL1(065,0,00),C'PS        - Select the previous SYSOUT d$\n               ataset (must use SJ first)'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(052,0,00),C'REDISP|RD - Resume display of selected s$\n               ysout dataset'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(037,0,00),C'JNews     - List the current JES2 news'\n         DC    AL1(047,1,00),C'SLog      - List the system log dataset $\n               (SYSLOG)'\n         DC    X'FF'                    Flag end of screen\n         SPACE 3\nHE#DT    DC    AL1(000,0,00),C' '\n         DC    AL1(059,0,00),C' The \"DT\" subcommand displays currently $\n               executing TSO users.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(018,0,02),X'1DE8',C'Syntax',X'1D60',C'- DT TIME'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(012,0,02),X'1DE8',C'Operands',X'1D60',C'-'\n         DC    AL1(054,0,00),C'   /TIME - Display the start time for ea$\n               ch TSO session.'\n         DC    X'FF'                    Flag end of screen\n         SPACE 3\nHE#ELIST DC    AL1(000,0,00),C' '\n         DC    AL1(066,0,00),C' The \"ELIST\" subcommand is similar to \"L$\n               IST\" but in ISPF mode ELIST'\n         DC    AL1(034,0,00),C'    invokes EDIT instead of BROWSE.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(031,0,02),X'1DE8',C'Syntax',X'1D60',C'- ELIST <jobid$\n               > <dsid>'\n         DC    AL1(013,0,02),X'1DE8',C' Alias',X'1D60',C'- EL'\n         DC    AL1(070,0,06),C' From the',X'1DE8',C'DDname',X'1D60',C'd$\n               isplay, line command',X'1DE8',C'EL',X'1D60',C'may be use$\n               d for',X'1DE8',C'ELIST.',X'1D60'\n         DC    AL1(081,0,02),C' (See',X'1DE8',C'\"Help LINECMDS\"',X'1D60$\n               ',C'for information on entering subcommands as line comm$\n               ands.)'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(012,0,02),X'1DE8',C'Operands',X'1D60',C'-'\n         DC    AL1(042,0,00),C'   <jobid> - The name or number of the j$\n               ob.'\n         DC    AL1(075,0,02),C'   <dsid>  - The DSID of the dataset, as$\n                displayed by the',X'1DE8',C'\"DD\"',X'1D60',C'subcommand.$\n               '\n         DC    AL1(000,0,00),C' '\n         DC    AL1(052,0,02),X'1DE8',C'Defaults',X'1D60',C'- <dsid> - t$\n               he previously selected <dsid>'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(073,0,04),X'1DE8',C'Note    ',X'1D60',C'- An asteris$\n               k',X'1DE8',C'(\"*\")',X'1D60',C'may be used in place of <j$\n               obid> to refer'\n         DC    AL1(045,0,00),C'            to the most recently selecte$\n               d job.'\n         DC    X'FF'                    Flag end of screen\n         SPACE 3\nHE#END   DC    AL1(000,0,00),C' '\n         DC    AL1(070,0,00),C' The \"END\" subcommand terminates the cur$\n               rent subcommand, and returns to'\n         DC    AL1(032,0,00),C' a higher level QUEUE subcommand.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(014,0,02),X'1DE8',C'Syntax',X'1D60',C'- END'\n         DC    AL1(011,0,02),X'1DE8',C'Alias',X'1D60',C'- E'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(018,0,02),X'1DE8',C'Operands',X'1D60',C'- None.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(072,0,02),X'1DE8',C'********************************$\n               *************************************',X'1D60'\n         DC    AL1(076,0,06),X'1DE8',C'*',X'1D60',C'Since QUEUE is now $\n               tree structure (sort of), the',X'1DE8',C'END',X'1D60',C'$\n               subcommand  ',X'1DE8',C'*',X'1D60'\n         DC    AL1(074,0,04),X'1DE8',C'*',X'1D60',C'no longer terminate$\n               s QUEUE immediately, unless you are currently ',X'1DE8',$\n               C'*',X'1D60'\n         DC    AL1(076,0,06),X'1DE8',C'*',X'1D60',C'at the top level.  $\n               The',X'1DE8',C'EXIT',X'1D60',C'subcommand may be used to$\n                leave      ',X'1DE8',C'*',X'1D60'\n         DC    AL1(074,0,04),X'1DE8',C'*',X'1D60',C'QUEUE regardless of$\n                the current level.                           ',X'1DE8',$\n               C'*',X'1D60'\n         DC    AL1(072,0,02),X'1DE8',C'********************************$\n               *************************************',X'1D60'\n         DC    X'FF'                    Flag end of screen\n         SPACE 3\nHE#EXIT  DC    AL1(000,0,00),C' '\n         DC    AL1(039,0,00),C' The \"EXIT\" subcommand terminates QUEUE.$\n               '\n         DC    AL1(000,0,00),C' '\n         DC    AL1(015,0,02),X'1DE8',C'Syntax',X'1D60',C'- EXIT'\n         DC    AL1(036,0,02),X'1DE8',C'Aliases',X'1D60',C'- EXIT, STOP,$\n                QUIT, RETURN'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(018,0,02),X'1DE8',C'Operands',X'1D60',C'- None.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(072,0,02),X'1DE8',C'********************************$\n               *************************************',X'1D60'\n         DC    AL1(076,0,06),X'1DE8',C'*',X'1D60',C'Since QUEUE is now $\n               tree structure (sort of), the',X'1DE8',C'END',X'1D60',C'$\n               subcommand  ',X'1DE8',C'*',X'1D60'\n         DC    AL1(074,0,04),X'1DE8',C'*',X'1D60',C'no longer terminate$\n               s QUEUE immediately, unless you are currently ',X'1DE8',$\n               C'*',X'1D60'\n         DC    AL1(076,0,06),X'1DE8',C'*',X'1D60',C'at the top level.  $\n               The',X'1DE8',C'EXIT',X'1D60',C'subcommand may be used to$\n                leave      ',X'1DE8',C'*',X'1D60'\n         DC    AL1(074,0,04),X'1DE8',C'*',X'1D60',C'QUEUE regardless of$\n                the current level.                           ',X'1DE8',$\n               C'*',X'1D60'\n         DC    AL1(072,0,02),X'1DE8',C'********************************$\n               *************************************',X'1D60'\n         DC    X'FF'                    Flag end of screen\n         SPACE 3\nHE#FIND  DC    AL1(000,0,00),C' '\n         DC    AL1(067,0,00),C' The \"FIND\" subcommand searches the curr$\n               ently selected dataset for a'\n         DC    AL1(077,0,00),C' character string, then repositions with$\n                that record at the top of the screen.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(041,0,02),X'1DE8',C'Syntax',X'1D60',C'- FIND ''<stri$\n               ng>'' COL(start,end)'\n         DC    AL1(012,0,02),X'1DE8',C' Alias',X'1D60',C'- F'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(012,0,02),X'1DE8',C'Operands',X'1D60',C'-'\n         DC    AL1(070,0,00),C'   <string> - The string to be located. $\n                The string must be enclosed in'\n         DC    AL1(068,0,00),C'              delimiters, unless it star$\n               ts with a letter or digit and'\n         DC    AL1(077,0,00),C'              contains no blanks.  The d$\n               elimiter may be any special character.'\n         DC    AL1(058,0,00),C'   <start>  - The starting column to sea$\n               rch for the string.'\n         DC    AL1(056,0,00),C'   <end>    - The ending column to searc$\n               h for the string.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(073,0,02),X'1DE8',C'Defaults',X'1D60',C'- The next o$\n               ccurrence of the previously entered string will be'\n         DC    AL1(019,0,00),C'            located.'\n         DC    AL1(041,0,01),C'         ',X'1D60',C'- All columns will $\n               be searched.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(044,0,04),X'1DE8',C'Notes   ',X'1D60',C'- See also t$\n               he',X'1DE8',C'FALL',X'1D60',C'subcommand.'\n         DC    AL1(069,0,01),C'         ',X'1D60',C'- If COL is specifi$\n               ed, both <start> and <end> are required.'\n         DC    X'FF'                    Flag end of screen\n         SPACE 3\nHE#FALL  DC    AL1(000,0,00),C' '\n         DC    AL1(067,0,00),C' The \"FALL\" subcommand searches the curr$\n               ently selected dataset for a'\n         DC    AL1(068,0,00),C' character string, displaying only recor$\n               ds which contain that string.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(041,0,02),X'1DE8',C'Syntax',X'1D60',C'- FALL ''<stri$\n               ng>'' COL(start,end)'\n         DC    AL1(013,0,02),X'1DE8',C' Alias',X'1D60',C'- FA'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(012,0,02),X'1DE8',C'Operands',X'1D60',C'-'\n         DC    AL1(070,0,00),C'   <string> - The string to be located. $\n                The string must be enclosed in'\n         DC    AL1(068,0,00),C'              delimiters, unless it star$\n               ts with a letter or digit and'\n         DC    AL1(077,0,00),C'              contains no blanks.  The d$\n               elimiter may be any special character.'\n         DC    AL1(058,0,00),C'   <start>  - The starting column to sea$\n               rch for the string.'\n         DC    AL1(056,0,00),C'   <end>    - The ending column to searc$\n               h for the string.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(073,0,02),X'1DE8',C'Defaults',X'1D60',C'- The next o$\n               ccurrence of the previously entered string will be'\n         DC    AL1(019,0,00),C'            located.'\n         DC    AL1(041,0,01),C'         ',X'1D60',C'- All columns will $\n               be searched.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(044,0,04),X'1DE8',C'Notes   ',X'1D60',C'- See also t$\n               he',X'1DE8',C'FIND',X'1D60',C'subcommand.'\n         DC    AL1(069,0,01),C'         ',X'1D60',C'- If COL is specifi$\n               ed, both <start> and <end> are required.'\n         DC    X'FF'                    Flag end of screen\n         SPACE 3\nHE#FTIME DC    AL1(000,0,00),C' '\n         DC    AL1(069,0,00),C' The \"FTIME\" subcommand searches the cur$\n               rently selected SYSLOG dataset'\n         DC    AL1(067,0,00),C' for the first record with a time stamp $\n               greater than or equal to the'\n         DC    AL1(015,0,00),C' requested time.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(023,0,02),X'1DE8',C'Syntax',X'1D60',C'- FTIME <time>$\n               '\n         DC    AL1(013,0,02),X'1DE8',C' Alias',X'1D60',C'- FT'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(012,0,02),X'1DE8',C'Operands',X'1D60',C'-'\n         DC    AL1(069,0,00),C'   <time> - The time (in the form HH.MM.$\n               SS or HH.MM) to reposition to.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(076,0,02),X'1DE8',C'Note    ',X'1D60',C'- If the tim$\n               e you specify is less than the time you are currently'\n         DC    AL1(077,0,00),C'            positioned at, no reposition$\n               ing will occur.  This will happen when'\n         DC    AL1(077,0,00),C'            the SYSLOG starts before mid$\n               night and you are searching for a time'\n         DC    AL1(072,0,00),C'            after midnight.  To get arou$\n               nd this problem, scroll down past'\n         DC    AL1(072,0,00),C'            midnight, then enter FTIME f$\n               or the desired time.  FTIME 23.59'\n         DC    AL1(078,0,00),C'            and then ENTER may be used t$\n               o accomplish this, if there is at least'\n         DC    AL1(079,0,00),C'            one and at most a screen ful$\n               l of records with a time stamp of 23.59.'\n         DC    X'FF'                    Flag end of screen\n         SPACE 3\nHE#GENL  DC    AL1(056,0,00),C'                             << General $\n               notes on QUEUE >>'\n         DC    AL1(069,0,02),C' When you see',X'1DE8',C'\"*MORE*\"',X'1D6$\n               0',C'in the upper right-hand corner of the screen,'\n         DC    AL1(071,0,02),C' it means that more information is waiti$\n               ng.  You may either hit',X'1DE8',C'ENTER',X'1D60'\n         DC    AL1(049,0,00),C' to view it, or enter a new subcommand t$\n               o skip it.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(073,0,02),X'1DE8',C'********************************$\n               **************************************',X'1D60'\n         DC    AL1(075,0,04),X'1DE8',C'*',X'1D60',C'  This version of Q$\n               UEUE is now \"tree structured\", like ISPF.  It  ',X'1DE8'$\n               ,C'*',X'1D60'\n         DC    AL1(075,0,04),X'1DE8',C'*',X'1D60',C'  is a primitive im$\n               plementation, and may not always get you to    ',X'1DE8'$\n               ,C'*',X'1D60'\n         DC    AL1(077,0,06),X'1DE8',C'*',X'1D60',C'  where you expect $\n               when you enter',X'1DE8',C'END.',X'1D60',C'  See Help for$\n                END and     ',X'1DE8',C'*',X'1D60'\n         DC    AL1(075,0,04),X'1DE8',C'*',X'1D60',C'  EXIT subcommands.$\n                                                              ',X'1DE8'$\n               ,C'*',X'1D60'\n         DC    AL1(073,0,02),X'1DE8',C'********************************$\n               **************************************',X'1D60'\n         DC    X'FF'                    Flag end of screen\n         SPACE 3\nHE#HB    DC    AL1(000,0,00),C' '\n         DC    AL1(069,0,00),C' The \"HB\" subcommand repositions the cur$\n               rently selected dataset toward'\n         DC    AL1(008,0,00),C' the top.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(017,0,02),X'1DE8',C'Syntax',X'1D60',C'- HB <#>'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(012,0,02),X'1DE8',C'Operands',X'1D60',C'-'\n         DC    AL1(076,0,00),C'   <#> - The number of half screens to g$\n               o backward from the current position.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(066,0,02),X'1DE8',C'Default',X'1D60',C'- <#> = 1.  T$\n               he dataset is scrolled up by half a screen.'\n         DC    X'FF'                    Flag end of screen\n         SPACE 3\nHE#HELP  DC    AL1(000,0,00),C' '\n         DC    AL1(030,0,02),X'1DE8',C'Syntax',X'1D60',C'- HELP subcomm$\n               andname'\n         DC    AL1(012,0,02),X'1DE8',C' Alias',X'1D60',C'- H'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(061,0,00),C' Note - A list of subcommand names may b$\n               e obtained by entering'\n         DC    AL1(040,0,04),C'       ',X'1DE8',C'HELP COMMANDS',X'1D60$\n               ',C'(or',X'1DE8',C'HELP CMDS)',X'1D60'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(069,0,00),C' Note - There are several other topics w$\n               hich may be viewed by entering'\n         DC    AL1(079,0,02),C'       ',X'1DE8',C'HELP other-topic',X'1$\n               D60',C'.  A list of these topics is given under \"HELP CM$\n               DS\".'\n         DC    X'FF'                    Flag end of screen\n         SPACE 3\nHE#HF    DC    AL1(000,0,00),C' '\n         DC    AL1(069,0,00),C' The \"HF\" subcommand repositions the cur$\n               rently selected dataset toward'\n         DC    AL1(011,0,00),C' the bottom.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(017,0,02),X'1DE8',C'Syntax',X'1D60',C'- HF <#>'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(012,0,02),X'1DE8',C'Operands',X'1D60',C'-'\n         DC    AL1(075,0,00),C'   <#> - The number of half screens to g$\n               o forward from the current position.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(068,0,02),X'1DE8',C'Default',X'1D60',C'- <#> = 1.  T$\n               he dataset is scrolled down by half a screen.'\n         DC    X'FF'                    Flag end of screen\n         SPACE 3\nHE#HJ    DC    AL1(000,0,00),C' '\n         DC    AL1(032,0,00),C' The \"HJ\" subcommand holds a job.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(021,0,02),X'1DE8',C'Syntax',X'1D60',C'- HJ <jobid>'\n         DC    AL1(015,0,02),X'1DE8',C' Alias',X'1D60',C'- HOLD'\n         DC    AL1(068,0,04),C' From a status display,',X'1DE8',C'HJ',X$\n               '1D60',C'or',X'1DE8',C'H',X'1D60',C'may be entered as a $\n               line command.'\n         DC    AL1(081,0,02),C' (See',X'1DE8',C'\"Help LINECMDS\"',X'1D60$\n               ',C'for information on entering subcommands as line comm$\n               ands.)'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(012,0,02),X'1DE8',C'Operands',X'1D60',C'-'\n         DC    AL1(042,0,00),C'   <jobid> - The name or number of the j$\n               ob.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(073,0,04),X'1DE8',C'Note    ',X'1D60',C'- An asteris$\n               k',X'1DE8',C'(\"*\")',X'1D60',C'may be used in place of <j$\n               obid> to refer'\n         DC    AL1(045,0,00),C'            to the most recently selecte$\n               d job.'\n          AIF   (&@@SCSVC NE 0 OR &@@TSOE GE 120).HE#HJ\n         DC    AL1(064,0,00),C'NOTE:  The \"HJ\" subcommand can only func$\n               tion if QUEUE was entered'\n         DC    AL1(060,0,00),C'       at the \"READY\" level (i.e., it ca$\n               nnot work inside SPF)'\n.HE#HJ    ANOP\n         DC    X'FF'                    Flag end of screen\n         SPACE 3\nHE#IOQ   DC    AL1(079,0,00),C'                             << Input/Ou$\n               tput queue display subcommand summary >>'\n         DC    AL1(046,0,00),C'STatus   - Display jobs matching a given$\n                prefix'\n         DC    AL1(035,0,00),C'DA       - Display jobs in execution'\n         DC    AL1(027,0,00),C'DT       - Display TSO users'\n         DC    AL1(030,0,00),C'DS       - Display system tasks'\n         DC    AL1(033,0,00),C'DEVices  - Display jobs on devices'\n         DC    AL1(047,0,00),C'CPU      - Display CPU time etc for acti$\n               ve tasks'\n         DC    AL1(028,0,00),C'DI       - Display input jobs'\n         DC    AL1(029,0,00),C'DO       - Display output jobs'\n         DC    AL1(039,0,00),C'DH       - Display jobs with held output$\n               '\n         DC    AL1(048,0,00),C'DQ       - Display summary of Input/Outp$\n               ut queues'\n         DC    AL1(052,0,00),C'AI       - Display input jobs available $\n               for execution'\n         DC    AL1(054,0,00),C'AO       - Display jobs available for pr$\n               inting/punching'\n         DC    AL1(033,0,00),C'HI       - Display held input jobs'\n         DC    AL1(040,0,00),C'DN       - Display all jobs in all queue$\n               s'\n         DC    AL1(045,0,00),C'DJ       - Display job by jobname or job$\n               number'\n         DC    AL1(050,0,00),C'JD       - Display detailed information $\n               about a job'\n         DC    X'FF'                    Flag end of screen\n         SPACE 3\nHE#JCL   DC    AL1(000,0,00),C' '\n         DC    AL1(045,0,00),C' The \"JCL\" subcommand lists the JCL for $\n               a job.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(031,0,02),X'1DE8',C'Syntax',X'1D60',C'- JCL <jobid> $\n               / EDIT E'\n         DC    AL1(013,0,02),X'1DE8',C' Alias',X'1D60',C'- JC'\n         DC    AL1(061,0,02),C' From a status display,',X'1DE8',C'JC',X$\n               '1D60',C'may be entered as a line command.'\n         DC    AL1(081,0,02),C' (See',X'1DE8',C'\"Help LINECMDS\"',X'1D60$\n               ',C'for information on entering subcommands as line comm$\n               ands.)'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(012,0,02),X'1DE8',C'Operands',X'1D60',C'-'\n         DC    AL1(042,0,00),C'   <jobid> - The name or number of the j$\n               ob.'\n         DC    AL1(070,0,00),C'   /EDIT   - (ISPF mode only) Invoke EDI$\n               T instead of BROWSE.  Note that'\n         DC    AL1(050,0,00),C'             changes cannot be saved bac$\n               k to spool.'\n         DC    AL1(028,0,00),C'   /E      - Alias for /EDIT.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(071,0,02),X'1DE8',C'Defaults',X'1D60',C'- The JCL fo$\n               r the previously selected job will be displayed.'\n         DC    X'FF'                    Flag end of screen\n         SPACE 3\nHE#JD    DC    AL1(000,0,00),C' '\n         DC    AL1(070,0,00),C' The \"JD\" subcommand displays detailed i$\n               nformation for a job, including'\n         DC    AL1(052,0,00),C' input, execution, and output times (whe$\n               n available).'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(021,0,02),X'1DE8',C'Syntax',X'1D60',C'- JD <jobid>'\n         DC    AL1(061,0,02),C' From a status display,',X'1DE8',C'JD',X$\n               '1D60',C'may be entered as a line command.'\n         DC    AL1(081,0,02),C' (See',X'1DE8',C'\"Help LINECMDS\"',X'1D60$\n               ',C'for information on entering subcommands as line comm$\n               ands.)'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(012,0,02),X'1DE8',C'Operands',X'1D60',C'-'\n         DC    AL1(058,0,00),C'   <jobid> - The name or number of the j$\n               ob to be displayed.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(059,0,02),X'1DE8',C'Defaults',X'1D60',C'- The previo$\n               usly selected job will be displayed.'\n         DC    X'FF'                    Flag end of screen\n         SPACE 3\nHE#JLOG  DC    AL1(000,0,00),C' '\n         DC    AL1(055,0,00),C' The \"JLOG\" subcommand lists the JES2 jo$\n               b log for a job.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(032,0,02),X'1DE8',C'Syntax',X'1D60',C'- JLOG <jobid>$\n                / EDIT E'\n         DC    AL1(013,0,02),X'1DE8',C' Alias',X'1D60',C'- JL'\n         DC    AL1(061,0,02),C' From a status display,',X'1DE8',C'JL',X$\n               '1D60',C'may be entered as a line command.'\n         DC    AL1(081,0,02),C' (See',X'1DE8',C'\"Help LINECMDS\"',X'1D60$\n               ',C'for information on entering subcommands as line comm$\n               ands.)'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(012,0,02),X'1DE8',C'Operands',X'1D60',C'-'\n         DC    AL1(042,0,00),C'   <jobid> - The name or number of the j$\n               ob.'\n         DC    AL1(070,0,00),C'   /EDIT   - (ISPF mode only) Invoke EDI$\n               T instead of BROWSE.  Note that'\n         DC    AL1(050,0,00),C'             changes cannot be saved bac$\n               k to spool.'\n         DC    AL1(028,0,00),C'   /E      - Alias for /EDIT.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(075,0,02),X'1DE8',C'Defaults',X'1D60',C'- The job lo$\n               g for the previously selected job will be displayed.'\n         DC    X'FF'                    Flag end of screen\n         SPACE 3\nHE#JMSG  DC    AL1(000,0,00),C' '\n         DC    AL1(060,0,00),C' The \"JMSG\" subcommand lists the JES2 jo$\n               b messages for a job.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(032,0,02),X'1DE8',C'Syntax',X'1D60',C'- JMSG <jobid>$\n                / EDIT E'\n         DC    AL1(013,0,02),X'1DE8',C' Alias',X'1D60',C'- JM'\n         DC    AL1(061,0,02),C' From a status display,',X'1DE8',C'JM',X$\n               '1D60',C'may be entered as a line command.'\n         DC    AL1(081,0,02),C' (See',X'1DE8',C'\"Help LINECMDS\"',X'1D60$\n               ',C'for information on entering subcommands as line comm$\n               ands.)'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(012,0,02),X'1DE8',C'Operands',X'1D60',C'-'\n         DC    AL1(042,0,00),C'   <jobid> - The name or number of the j$\n               ob.'\n         DC    AL1(070,0,00),C'   /EDIT   - (ISPF mode only) Invoke EDI$\n               T instead of BROWSE.  Note that'\n         DC    AL1(050,0,00),C'             changes cannot be saved bac$\n               k to spool.'\n         DC    AL1(028,0,00),C'   /E      - Alias for /EDIT.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(080,0,02),X'1DE8',C'Defaults',X'1D60',C'- The job me$\n               ssages for the previously selected job will be displayed$\n               .'\n         DC    X'FF'                    Flag end of screen\n         SPACE 3\nHE#JSUMM DC    AL1(000,0,00),C' '\n         DC    AL1(067,0,00),C' The \"JSUMM\" subcommand summarizes the r$\n               esults of a job''s execution.'\n         DC    AL1(071,0,00),C' A line is produced for each step showin$\n               g information such as completion'\n         DC    AL1(075,0,00),C' code, CPU time, etc.  In addition, erro$\n               r messages and some warning messages'\n         DC    AL1(067,0,02),C' (such as',X'1DE8',C'\"NOT CATALOGED\")',X$\n               '1D60',C' from the JOBMSG dataset are displayed.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(024,0,02),X'1DE8',C'Syntax',X'1D60',C'- JSUMM <jobid$\n               >'\n         DC    AL1(018,0,02),X'1DE8',C' Aliases',X'1D60',C'- JS, J'\n         DC    AL1(061,0,02),C' From a status display,',X'1DE8',C'JS',X$\n               '1D60',C'may be entered as a line command.'\n         DC    AL1(081,0,02),C' (See',X'1DE8',C'\"Help LINECMDS\"',X'1D60$\n               ',C'for information on entering subcommands as line comm$\n               ands.)'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(012,0,02),X'1DE8',C'Operands',X'1D60',C'-'\n         DC    AL1(042,0,00),C'   <jobid> - The name or number of the j$\n               ob.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(075,0,02),X'1DE8',C'Defaults',X'1D60',C'- The job lo$\n               g for the previously selected job will be displayed.'\n         DC    X'FF'                    Flag end of screen\n         SPACE 3\nHE#JNEWS DC    AL1(000,0,00),C' '\n         DC    AL1(049,0,00),C' The \"JNEWS\" subcommand lists the curren$\n               t JESNEWS.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(016,0,02),X'1DE8',C'Syntax',X'1D60',C'- JNEWS'\n         DC    AL1(013,0,02),X'1DE8',C' Alias',X'1D60',C'- JN'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(018,0,02),X'1DE8',C'Operands',X'1D60',C'- None.'\n         DC    X'FF'                    Flag end of screen\n         SPACE 3\nHE#LEFT  DC    AL1(000,0,00),C' '\n         DC    AL1(069,0,00),C' The \"LEFT\" subcommand repositions the c$\n               urrently selected dataset left'\n         DC    AL1(030,0,00),C' a specified number of columns.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(019,0,02),X'1DE8',C'Syntax',X'1D60',C'- LEFT <#>'\n         DC    AL1(013,0,02),X'1DE8',C' Alias',X'1D60',C'- LE'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(012,0,02),X'1DE8',C'Operands',X'1D60',C'-'\n         DC    AL1(044,0,00),C'   <#> - The number of columns to shift $\n               left.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(022,0,02),X'1DE8',C'Defaults',X'1D60',C'- <#> = 40.'$\n\n         DC    X'FF'                    Flag end of screen\n         SPACE 3\nHE#LIST  DC    AL1(000,0,00),C' '\n         DC    AL1(064,0,00),C' The \"LIST\" subcommand lists a SYSIN or $\n               SYSOUT dataset for a job.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(044,0,02),X'1DE8',C'Syntax',X'1D60',C'- LIST <jobid>$\n                <dsid> <col> /EDIT E'\n         DC    AL1(012,0,02),X'1DE8',C' Alias',X'1D60',C'- L'\n         DC    AL1(075,0,08),C' From the',X'1DE8',C'DDname',X'1D60',C'd$\n               isplay, line command',X'1DE8',C'L',X'1D60',C'or',X'1DE8'$\n               ,C'S',X'1D60',C'may be used for',X'1DE8',C'LIST.',X'1D60$\n               '\n         DC    AL1(081,0,02),C' (See',X'1DE8',C'\"Help LINECMDS\"',X'1D60$\n               ',C'for information on entering subcommands as line comm$\n               ands.)'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(012,0,02),X'1DE8',C'Operands',X'1D60',C'-'\n         DC    AL1(042,0,00),C'   <jobid> - The name or number of the j$\n               ob.'\n         DC    AL1(075,0,02),C'   <dsid>  - The DSID of the dataset, as$\n                displayed by the',X'1DE8',C'\"DD\"',X'1D60',C'subcommand.$\n               '\n         DC    AL1(058,0,00),C'   <col>   - The default column number f$\n               or the left margin.'\n         DC    AL1(070,0,00),C'   /EDIT   - (ISPF mode only) Invoke EDI$\n               T instead of BROWSE.  Note that'\n         DC    AL1(050,0,00),C'             changes cannot be saved bac$\n               k to spool.'\n         DC    AL1(028,0,00),C'   /E      - Alias for /EDIT.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(052,0,02),X'1DE8',C'Defaults',X'1D60',C'- <dsid> - t$\n               he previously selected <dsid>'\n         DC    AL1(019,0,01),C'         ',X'1D60',C'- <col>=1'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(073,0,04),X'1DE8',C'Note    ',X'1D60',C'- An asteris$\n               k',X'1DE8',C'(\"*\")',X'1D60',C'may be used in place of <j$\n               obid> to refer'\n         DC    AL1(045,0,00),C'            to the most recently selecte$\n               d job.'\n         DC    X'FF'                    Flag end of screen\n         SPACE 3\nHE#LCMDS DC    AL1(000,0,00),C' '\n         DC    AL1(073,0,04),C' Many',X'1DE8',C'QUEUE',X'1D60',C'subcom$\n               mands may be entered as line commands (as in',X'1DE8',C'$\n               ISPF).',X'1D60'\n         DC    AL1(069,0,02),C' Some are valid from',X'1DE8',C'status',$\n               X'1D60',C'type displays, and others are valid from'\n         DC    AL1(068,0,02),C' the',X'1DE8',C'DDname',X'1D60',C'displa$\n               y.  The Help screen for each subcommand will give'\n         DC    AL1(064,0,00),C' the one or two character command name t$\n               hat can be used as a line'\n         DC    AL1(067,0,00),C' command.  (Line commands are entered in$\n                the input field at the left'\n         DC    AL1(019,0,00),C' of a display line.)'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(069,0,00),C' If an operand in addition to the jobid $\n               is required, it may be entered'\n         DC    AL1(068,0,00),C' in the input field at the right of the $\n               display line.  (This field is'\n         DC    AL1(070,0,00),C' also used to display the destination, b$\n               ut if not overtyped, is treated'\n         DC    AL1(018,0,00),C' as if left blank.)'\n         DC    AL1(000,0,00),C' '\n         DC    X'FF'                    Flag end of screen\n         SPACE 3\nHE#LRMT  DC    AL1(000,0,00),C' '\n         DC    AL1(061,0,00),C' The \"LRMT\" subcommand lists the names a$\n               nd numbers of all JES2'\n         DC    AL1(020,0,00),C' remote destinations.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(015,0,02),X'1DE8',C'Syntax',X'1D60',C'- LRMT'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(018,0,02),X'1DE8',C'Operands',X'1D60',C'- None.'\n         DC    X'FF'                    Flag end of screen\n         SPACE 3\nHE#MD    DC    AL1(000,0,00),C' '\n         DC    AL1(069,0,00),C' The \"MD\" (move display) subcommand repo$\n               sitions the currently selected'\n         DC    AL1(039,0,00),C' dataset to the specified record number.$\n               '\n         DC    AL1(000,0,00),C' '\n         DC    AL1(017,0,02),X'1DE8',C'Syntax',X'1D60',C'- MD <#>'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(012,0,02),X'1DE8',C'Operands',X'1D60',C'-'\n         DC    AL1(067,0,00),C'   <#> - The record number to be display$\n               ed at the top of the screen.'\n         DC    X'FF'                    Flag end of screen\n         SPACE 3\nHE#MODE  DC    AL1(000,0,00),C' '\n         DC    AL1(068,0,00),C' The \"MODE\" subcommand is used to displa$\n               y and/or change various QUEUE'\n         DC    AL1(019,0,00),C' processing options.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(074,0,02),X'1DE8',C'The \"MODE\" subcommand may be use$\n               d in a QUEUE \"PROFILE\".',X'1D60',C' See HELP QPROF.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(043,0,02),X'1DE8',C'Syntax',X'1D60',C'- MODE option1$\n                option2 ... optionn'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(012,0,02),X'1DE8',C'Operands',X'1D60',C'-'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(053,0,00),C' (blank)         - Display current Queue$\n                mode settings#{\u00e2\n         DC    AL1(055,0,00),C' SHOWCC/NOSHOWCC - Display carriage cont$\n               rol when present'\n         DC    AL1(059,0,00),C' PAGE            - Format output display$\n               s by (printed) pages'\n         DC    AL1(060,0,00),C' LINE            - Format output display$\n               s by line number only'\n         DC    AL1(073,0,00),C' FANUM/NOFANUM   - \"FALL\" (find all) com$\n               mand should display record numbers'\n         DC    AL1(056,0,00),C' BEEP/NOBEEP     - Sound audible alarm f$\n               or error messages'\n         DC    AL1(055,0,00),C' PFK12           - Map PF13-PF24 to PF1-$\n               PF12 definitions'\n         DC    AL1(072,0,00),C' PFK24           - Allow PF13-PF24 to be$\n                defined separately from PF1-PF12'\n         DC    AL1(063,0,00),C' JDATE           - Display all dates in $\n               \"Julian\" (yy.ddd) format'\n         DC    AL1(067,0,00),C' GDATE           - Display all dates in $\n               \"Gregorian\" (nnmmmyy) format'\n         DC    AL1(076,0,00),C' VERIFY/NOVERIFY - Indicates whether act$\n               ion subcmds should verify before exec'\n         DC    AL1(074,0,00),C' STACK/NOSTACK   - Indicates whether PF3$\n                should pop the stack or exit QUEUE'\n         DC    AL1(072,0,00),C' RSCA/NORSCA     - Indicates whether to $\n               Reissue the Stacked Command After'\n         DC    AL1(033,0,00),C'                   action commands'\n         DC    AL1(051,0,00),C' STATUS=<prefix> - Set default search ke$\n               y for \"ST *\"'\n         DC    AL1(070,0,00),C' DESTR=<dest>    - Set default route des$\n               tination for \"ROUTE\" subcommand'\n         DC    AL1(071,0,00),C' DEST=<dest>     - Set default output de$\n               stination for \"PRint\" subcommand'\n         DC    AL1(065,0,00),C' CLASS=<class>   - Set default sysout cl$\n               ass for \"PRint\" subcommand'\n         DC    AL1(056,0,00),C' FCB=<fcb>       - Set default fcb for \"$\n               PRint\" subcommand'\n         DC    AL1(057,0,00),C' FORM=<form>     - Set default form for $\n               \"PRint\" subcommand'\n         DC    AL1(056,0,00),C' UCS=<ucs>       - Set default ucs for \"$\n               PRint\" subcommand'\n         DC    AL1(049,0,00),C' COLS            - Column scale is to be$\n                displayed'\n         DC    AL1(053,0,00),C' NOCOLS          - Column scale is not t$\n               o be displayed'\n         DC    AL1(050,0,00),C' LINECT          - Set linecount for pri$\n               nted output'\n         DC    AL1(069,0,03),C'*',X'1DE8',X'1DE8',X'1DE8',C' need to do$\n               cument privileged operands SLxxx && APPLCOPY/NOAPPCPY'\n         DC    X'FF'                    Flag end of screen\n         SPACE 3\nHE#NJ    DC    AL1(000,0,00),C' '\n         DC    AL1(064,0,00),C' The \"NJ\" subcommand displays jobs on th$\n               e network transmit queue.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(013,0,02),X'1DE8',C'Syntax',X'1D60',C'- NJ'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(018,0,02),X'1DE8',C'Operands',X'1D60',C'- None.'\n         DC    X'FF'                    Flag end of screen\n         SPACE 3\nHE#NS    DC    AL1(000,0,00),C' '\n         DC    AL1(070,0,00),C' The \"NS\" subcommand causes the next (or$\n                previous) sysout dataset to be'\n         DC    AL1(010,0,00),C' displayed.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(036,0,02),X'1DE8',C'Syntax',X'1D60',C'- NS NEXT PREV$\n                TOP BOTTOM *'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(012,0,02),X'1DE8',C'Operands',X'1D60',C'-'\n         DC    AL1(076,0,00),C'   NEXT   - The next sysout dataset is t$\n               o be displayed.  This is the default.'\n         DC    AL1(026,0,00),C'   N      - Alias for NEXT.'\n         DC    AL1(058,0,00),C'   PREV   - The previous sysout dataset $\n               is to be displayed.'\n         DC    AL1(026,0,00),C'   P      - Alias for PREV.'\n         DC    AL1(055,0,00),C'   TOP    - The first sysout dataset is $\n               to be displayed.'\n         DC    AL1(025,0,00),C'   T      - Alias for TOP.'\n         DC    AL1(054,0,00),C'   BOTTOM - The last sysout dataset is t$\n               o be displayed.'\n         DC    AL1(028,0,00),C'   B      - Alias for BOTTOM.'\n         DC    AL1(072,0,00),C'   *      - Display the next or previous$\n                sysout, depending on the current'\n         DC    AL1(031,0,00),C'            direction indicator.'\n         DC    AL1(017,0,02),X'1DE8',C'Default ',X'1D60',C'- NEXT'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(069,0,02),X'1DE8',C'Notes  ',X'1D60',C'- The job mus$\n               t first be selected using the \"SJ\" subcommand.'\n         DC    AL1(080,0,02),C'         - If using',X'1DE8',C'NS *',X'1$\n               D60',C'(the default PF6/PF18), when the end (or beginnin$\n               g) of'\n         DC    AL1(075,0,00),C'           the output is reached, enteri$\n               ng NS * again will cause the default'\n         DC    AL1(075,0,00),C'           direction to be changed for t$\n               he duration of this \"SJ\" subcommand.'\n         DC    AL1(058,0,02),C'         - See also the description of t$\n               he',X'1DE8',C'PS',X'1D60',C'subcommand.'\n         DC    X'FF'                    Flag end of screen\n         SPACE 3\nHE#PAGE  DC    AL1(000,0,00),C' '\n         DC    AL1(071,0,00),C' The \"PAGE\" subcommand repositions the c$\n               urrently selected dataset to the'\n         DC    AL1(022,0,00),C' specified page number.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(019,0,02),X'1DE8',C'Syntax',X'1D60',C'- PAGE <#>'\n         DC    AL1(011,0,02),X'1DE8',C'Alias',X'1D60',C'- P'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(012,0,02),X'1DE8',C'Operands',X'1D60',C'-'\n         DC    AL1(065,0,00),C'   <#> - The page number to be displayed$\n                at the top of the screen.'\n         DC    X'FF'                    Flag end of screen\n         SPACE 3\nHE#PB    DC    AL1(000,0,00),C' '\n         DC    AL1(069,0,00),C' The \"PB\" subcommand repositions the cur$\n               rently selected dataset toward'\n         DC    AL1(008,0,00),C' the top.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(017,0,02),X'1DE8',C'Syntax',X'1D60',C'- PB <#>'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(012,0,02),X'1DE8',C'Operands',X'1D60',C'-'\n         DC    AL1(071,0,00),C'   <#> - The number of screens to go bac$\n               kward from the current position.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(055,0,02),X'1DE8',C'Default',X'1D60',C'- <#> = 1.  T$\n               he previous screen is displayed.'\n         DC    X'FF'                    Flag end of screen\n         SPACE 3\nHE#PF    DC    AL1(000,0,00),C' '\n         DC    AL1(069,0,00),C' The \"PF\" subcommand repositions the cur$\n               rently selected dataset toward'\n         DC    AL1(011,0,00),C' the bottom.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(017,0,02),X'1DE8',C'Syntax',X'1D60',C'- PF <#>'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(012,0,02),X'1DE8',C'Operands',X'1D60',C'-'\n         DC    AL1(070,0,00),C'   <#> - The number of screens to go for$\n               ward from the current position.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(051,0,02),X'1DE8',C'Default',X'1D60',C'- <#> = 1.  T$\n               he next screen is displayed.'\n         DC    X'FF'                    Flag end of screen\n         SPACE 3\nHE#PFK   DC    AL1(000,0,00),C' '\n         DC    AL1(038,0,02),X'1DE8',C'The default PF Key definitions a$\n               re:',X'1D60'\n         DC    AL1(028,0,00),C' ____________________________'\n         DC    AL1(074,0,00),C' |PF1 /13 |PF2 /14 |PF3 /15 |       PF K$\n               eys 13-24 are mapped to perform the'\n         DC    AL1(067,0,06),C' |',X'1DE8',C' Help ',X'1D60',C'|',X'1DE$\n               8',C' RC   ',X'1D60',C'|',X'1DE8',C' End  ',X'1D60',C'| $\n                     same functions as PF 1-12.'\n         DC    AL1(028,0,00),C' |________|________|________|'\n         DC    AL1(077,0,00),C' |PF4 /16 |PF5 /17 |PF6 /18 |       To s$\n               pecify operands for any PF Key, key in'\n         DC    AL1(084,0,06),C' |',X'1DE8',C' PRint',X'1D60',C'|',X'1DE$\n               8',C' Find ',X'1D60',C'|',X'1DE8',C' NS * ',X'1D60',C'| $\n                     the value and press the appropriate PF Key.'\n         DC    AL1(028,0,00),C' |________|________|________|'\n         DC    AL1(070,0,00),C' |PF7 /19 |PF8 /20 |PF9 /21 |       PFK $\n               definitions may be displayed by'\n         DC    AL1(082,0,06),C' |',X'1DE8',C' Up   ',X'1D60',C'|',X'1DE$\n               8',C' Down ',X'1D60',C'|',X'1DE8',C' AO   ',X'1D60',C'| $\n                     entering the PFK command with no operand.'\n         DC    AL1(028,0,00),C' |________|________|________|'\n         DC    AL1(028,0,00),C' |PF10/22 |PF11/23 |PF12/24 |'\n         DC    AL1(034,0,06),C' |',X'1DE8',C' LEft ',X'1D60',C'|',X'1DE$\n               8',C' RIght',X'1D60',C'|',X'1DE8',C' ST   ',X'1D60',C'|'$\n\n         DC    AL1(028,0,00),C' |________|________|________|'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(046,0,00),C'The PFK definitions may be changed by en$\n               tering:'\n         DC    AL1(058,0,02),C'         ',X'1DE8',C'PFK <numb> <any QUE$\n               UE subcommand and operands>',X'1D60'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(073,0,02),X'1DE8',C'The \"PFK\" subcommand may be used$\n                in a QUEUE \"PROFILE\".',X'1D60',C' See HELP QPROF.'\n         DC    X'FF'                    Flag end of screen\n         SPACE 3\nHE#PRINT DC    AL1(000,0,00),C' '\n         DC    AL1(067,0,00),C' The \"PRINT\" subcommand prints the scree$\n               n image to a sysout dataset.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(072,0,02),X'1DE8',C'Syntax',X'1D60',C'- PRINT ON  <c$\n               lass> DEST=<dest> FCB=<fcb> FORM=<form> UCS=<ucs>'\n         DC    AL1(026,0,00),C'          PRINT OFF <class>'\n         DC    AL1(023,0,00),C'          PRINT OFF HOLD'\n         DC    AL1(018,0,00),C'          PRINT DEL'\n         DC    AL1(014,0,00),C'          PRINT'\n         DC    AL1(013,0,02),X'1DE8',C' Alias',X'1D60',C'- PR'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(012,0,02),X'1DE8',C'Operands',X'1D60',C'-'\n         DC    AL1(070,0,00),C'   ON      - The print file is to be ope$\n               ned with the specified options.'\n         DC    AL1(078,0,00),C'             ** The screen image will no$\n               t be printed if the operand is \"ON\". **'\n         DC    AL1(048,0,00),C'   <class> - The sysout class for the pr$\n               int file.'\n         DC    AL1(047,0,00),C'   <dest>  - The destination for the pri$\n               nt file.'\n         DC    AL1(039,0,00),C'   <fcb>   - The FCB for the print file.$\n               '\n         DC    AL1(046,0,00),C'   <form>  - The forms code for the prin$\n               t file.'\n         DC    AL1(039,0,00),C'   <ucs>   - The UCS for the print file.$\n               '\n         DC    AL1(061,0,00),C'   HOLD    - The sysout is to be marked $\n               \"HELD\" as it is freed.'\n         DC    AL1(040,0,00),C'   DEL     - The sysout is to be deleted$\n               .'\n         DC    AL1(046,0,00),C'   (blank) - The screen image is to be p$\n               rinted.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(081,0,02),X'1DE8',C'Defaults',X'1D60',C'- If PRINT i$\n               s entered with no operands and the print file is not ope$\n               n,'\n         DC    AL1(075,0,00),C'            it will be opened with all d$\n               efaults taken from values set by the'\n         DC    AL1(070,0,00),C'            \"MODE\" subcommand.  If not s$\n               et by \"MODE\", the defaults are:'\n         DC    AL1(077,0,00),C'            CLASS=A, DEST= your logon de$\n               st, no FCB, FORM, or UCS (installation'\n         DC    AL1(028,0,00),C'            standard output).'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(044,0,04),X'1DE8',C'Note:   ',X'1D60',C'- See also t$\n               he',X'1DE8',C'COPY',X'1D60',C'subcommand.'\n         DC    X'FF'                    Flag end of screen\n         SPACE 3\nHE#PRIV  DC    AL1(056,0,00),C'                             << Privileg$\n               ed subcommands >>'\n         DC    AL1(046,0,00),C'INit                 - Display initiator$\n                status'\n         DC    AL1(057,0,00),C'XJ       <jobid>     - Display uninterpr$\n               eted JQEs and JOEs'\n         DC    AL1(053,0,00),C'XBlk     <mttr>      - Display block fro$\n               m SYS1.HASPACE'\n         DC    AL1(062,0,00),C'JOBX|JDX <jobid>     - Display other inf$\n               o from JCT (mostly hex)'\n         DC    AL1(052,0,00),C'JCT <jobid> <offset> - Display JCT in he$\n               x dump format'\n         DC    AL1(062,0,00),C'LTXT <jobid>         - Display internal $\n               text in hex dump format'\n         DC    AL1(043,0,00),C'HCT  <displacement>  - Display HCT $SAVE$\n               AREA'\n         DC    AL1(047,0,00),C'QCMN <displacement>  - Display QCOMMON w$\n               ork area'\n         DC    AL1(039,0,00),C'CKPT <displacement>  - Display CKPT data$\n               '\n         DC    AL1(067,0,00),C'LBLK     <jobid>     - Format control bl$\n               ocks which reside on HASPACE'\n         DC    AL1(068,0,00),C'LSYS                 - Display names and$\n                status in Multi-Access Spool'\n          AIF   (&QLEVEL LT 8).HE#PRV1\n         DC    AL1(038,0,00),C'LDAS                 - Display all DASs'$\n\n         DC    AL1(047,0,00),C'LKIT                 - Display all KITs $\n               and HDPs'\n.HE#PRV1  ANOP\n          AIF   (&@@SCSVC NE 0 OR &@@TSOE GE 120).HE#PRV2\n         DC    AL1(000,0,00),C' '\n         DC    AL1(070,0,00),C'The following may only be executed if \"Q$\n               UEUE\" is running APF authorized'\n         DC    AL1(000,0,00),C' '\n.HE#PRV2  ANOP\n         DC    AL1(035,0,00),C'AJ/RELease <jobid>   - Release a job'\n         DC    AL1(032,0,00),C'HJ/HOLD    <jobid>   - Hold a job'\n         DC    AL1(053,0,00),C'EJ         <jobid>   - Hold, Restart, an$\n               d Cancel a job'\n         DC    AL1(072,0,00),C'TJ <jobid> C=? P=? S=?  - Set a job''s c$\n               lass, priority, or system affinity'\n         DC    AL1(051,0,00),C'/          <command> - Issue any MVS or $\n               JES2 command'\n         DC    AL1(079,0,00),C'           (JES2 commands for the select$\n               ed JES need not be preceeded by a slash)'\n         DC    AL1(076,0,00),C'CONS       <addr>    - Display MCS conso$\n               le buffer (default is master console)'\n         DC    X'FF'                    Flag end of screen\n         SPACE 3\nHE#PS    DC    AL1(000,0,00),C' '\n         DC    AL1(071,0,00),C' The \"PS\" subcommand causes the previous$\n                sysout dataset to be displayed.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(013,0,02),X'1DE8',C'Syntax',X'1D60',C'- PS'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(018,0,02),X'1DE8',C'Operands',X'1D60',C'- None.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(069,0,02),X'1DE8',C'Notes  ',X'1D60',C'- The job mus$\n               t first be selected using the \"SJ\" subcommand.'\n         DC    AL1(058,0,02),C'         - See also the description of t$\n               he',X'1DE8',C'NS',X'1D60',C'subcommand.'\n         DC    X'FF'                    Flag end of screen\n         SPACE 3\nHE#PURGE DC    AL1(000,0,00),C' '\n         DC    AL1(068,0,00),C' The \"PURGE\" subcommand purges (removes $\n               from the JES2 queue) an input'\n         DC    AL1(063,0,00),C' or output job, or all output if the job$\n                is currently executing.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(024,0,02),X'1DE8',C'Syntax',X'1D60',C'- PURGE <jobid$\n               >'\n         DC    AL1(013,0,02),X'1DE8',C' Alias',X'1D60',C'- PJ'\n         DC    AL1(061,0,02),C' From a status display,',X'1DE8',C'PJ',X$\n               '1D60',C'may be entered as a line command.'\n         DC    AL1(081,0,02),C' (See',X'1DE8',C'\"Help LINECMDS\"',X'1D60$\n               ',C'for information on entering subcommands as line comm$\n               ands.)'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(012,0,02),X'1DE8',C'Operands',X'1D60',C'-'\n         DC    AL1(042,0,00),C'   <jobid> - The name or number of the j$\n               ob.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(073,0,04),X'1DE8',C'Note    ',X'1D60',C'- An asteris$\n               k',X'1DE8',C'(\"*\")',X'1D60',C'may be used in place of <j$\n               obid> to refer'\n         DC    AL1(045,0,00),C'            to the most recently selecte$\n               d job.'\n          AIF   (&@@SCSVC NE 0 OR &@@TSOE GE 120).HE#PUR\n         DC    AL1(067,0,00),C'NOTE:  The \"PURGE\" subcommand can only f$\n               unction if QUEUE was entered'\n         DC    AL1(060,0,00),C'       at the \"READY\" level (i.e., it ca$\n               nnot work inside SPF)'\n.HE#PUR   ANOP\n         DC    X'FF'                    Flag end of screen\n         SPACE 3\nHE#QINT  DC    AL1(000,0,00),C' '\n         DC    AL1(070,0,00),C' The \"QINT\" subcommand is used to displa$\n               y internal QUEUE statistics and'\n         DC    AL1(071,0,00),C' operational data, and change some inter$\n               nal operational characteristics.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(074,0,02),X'1DE8',C'The \"QINT\" subcommand may be use$\n               d in a QUEUE \"PROFILE\".',X'1D60',C' See HELP QPROF.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(043,0,02),X'1DE8',C'Syntax',X'1D60',C'- QINT option1$\n                option2 ... optionn'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(012,0,02),X'1DE8',C'Operands',X'1D60',C'-'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(059,0,00),C' (blank)        - Display current Queue $\n               internal information'\n         DC    AL1(038,0,00),C' USERMODE|USER  - Reset privilege flags'$\n\n         DC    AL1(036,0,00),C' DEBUG=xxxxxxxx - Set debugging flags'\n         DC    AL1(079,0,00),C' SYSP/NOSYSP    - Set/Reset system progr$\n               ammer authorization (must have PSCBACCT)'\n         DC    AL1(070,0,00),C' OPER/NOPER     - Set/Reset operator aut$\n               horization (must have PSCBACCT)'\n         DC    AL1(077,0,00),C' COMCHAR|COMCHR=<char> - Set or change J$\n               ES2 communications char (for secondary'\n         DC    AL1(077,0,00),C'                   JES2) (Only affects t$\n               he \"AJ\", \"HJ\", \"RJ\", \"PJ\" subcommands)'\n         DC    AL1(055,0,00),C' SIDTRAN/NOSIDTRAN - Set/Reset translati$\n               on of system ids'\n         DC    X'FF'                    Flag end of screen\n         SPACE 3\nHE#QPROF DC    AL1(000,0,00),C' '\n         DC    AL1(068,0,00),C' QUEUE, during initialization, will opti$\n               onally execute a user-defined'\n         DC    AL1(070,0,00),C' list of QUEUE subcommands.  If DDNAME S$\n               YSPROC is allocated at entry to'\n         DC    AL1(071,0,02),C' QUEUE, and it contains a member named',$\n               X'1DE8',C'QPROF,',X'1D60',C'that member will be read'\n         DC    AL1(070,0,00),C' and then each subcommand it contains wi$\n               ll be executed.  QPROF may only'\n         DC    AL1(065,0,04),C' contain',X'1DE8',C'MODE',X'1D60',C'and'$\n               ,X'1DE8',C'PFK',X'1D60',C'subcommands.  If any other sub$\n               command is'\n         DC    AL1(065,0,00),C' encountered, it will be the last profil$\n               e command executed, and no'\n         DC    AL1(068,0,00),C' warning message will be given.  This wi$\n               ll also apply to MODE and PFK'\n         DC    AL1(037,0,00),C' subcommands entered with no operands.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(061,1,02),C' Privileged users may also supply',X'1DE$\n               8',C'QINT',X'1D60',C'subcommands in QPROF.'\n         DC    X'FF'                    Flag end of screen\n         SPACE 3\nHE#RE    DC    AL1(000,0,00),C' '\n         DC    AL1(074,0,00),C' The \"RETRIEVE\" subcommand recalls a pre$\n               vious subcommand to the input area.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(032,0,02),X'1DE8',C'Syntax',X'1D60',C'- RETRIEVE (F)$\n                (I)  (T)'\n         DC    AL1(012,0,02),X'1DE8',C'Alias',X'1D60',C'- RE'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(012,0,02),X'1DE8',C'Operands',X'1D60',C'-'\n         DC    AL1(066,0,00),C'   (blank) - The previous subcommand of $\n               any type is to be recalled.'\n         DC    AL1(055,0,00),C'   F       - The last FIND subcommand is$\n                to be recalled.'\n         DC    AL1(058,0,00),C'   I       - The last inquiry subcommand$\n                is to be recalled.'\n         DC    AL1(054,0,00),C'   T       - The last TSO subcommand is $\n               to be recalled.'\n         DC    AL1(062,1,00),C'   C       - The last MVS or JES2 subcom$\n               mand is to be recalled.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(053,0,02),X'1DE8',C'Note    ',X'1D60',C'- Only 1 ope$\n               rand may be entered at a time.'\n         DC    X'FF'                    Flag end of screen\n         SPACE 3\nHE#RD    DC    AL1(000,0,00),C' '\n         DC    AL1(069,0,00),C' The \"REDISP\" subcommand will list the m$\n               ost recently selected dataset,'\n         DC    AL1(028,0,00),C' at the last position viewed.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(017,0,02),X'1DE8',C'Syntax',X'1D60',C'- REDISP'\n         DC    AL1(013,0,02),X'1DE8',C' Alias',X'1D60',C'- RD'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(018,0,02),X'1DE8',C'Operands',X'1D60',C'- None.'\n         DC    X'FF'                    Flag end of screen\n         SPACE 3\nHE#REPOS DC    AL1(067,0,00),C'                             << Dataset $\n               repositioning subcommands >>'\n         DC    AL1(048,0,00),C'Find       - Find a character string in $\n               a dataset'\n         DC    AL1(044,0,00),C'FAll       - Find all occurrences of <st$\n               ring>'\n         DC    AL1(047,0,00),C'FTime      - Reposition system log to gi$\n               ven time'\n         DC    AL1(035,0,00),C'Column     - Reposition horizontally'\n         DC    AL1(039,0,00),C'LEft       - Reposition left <#> columns$\n               '\n         DC    AL1(040,0,00),C'Right      - Reposition right <#> column$\n               s'\n         DC    AL1(048,0,00),C'MD         - Reposition to specific reco$\n               rd number'\n         DC    AL1(041,0,00),C'Down       - Reposition forward in datas$\n               et'\n         DC    AL1(042,0,00),C'Up         - Reposition backward in data$\n               set'\n         DC    AL1(040,0,00),C'Top        - Reposition to top of datase$\n               t'\n         DC    AL1(043,0,00),C'Bottom     - Reposition to bottom of dat$\n               aset'\n         DC    AL1(044,0,00),C'PF, PB     - Page forward or back <#> sc$\n               reens'\n         DC    AL1(049,0,00),C'HF, HB     - Page forward or back <#> ha$\n               lf screens'\n         DC    AL1(053,0,00),C'REDISP|RD  - Resume display of selected $\n               sysout dataset'\n         DC    X'FF'                    Flag end of screen\n         SPACE 3\nHE#REQ   DC    AL1(000,0,00),C' '\n         DC    AL1(070,0,00),C' The \"REQUEUE\" subcommand changes the he$\n               ld sysout for a job to non-held'\n         DC    AL1(021,0,00),C' in a different class.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(034,0,02),X'1DE8',C'Syntax',X'1D60',C'- REQUEUE <job$\n               id> <class>'\n         DC    AL1(014,0,02),X'1DE8',C' Alias',X'1D60',C'- REQ'\n         DC    AL1(084,0,06),C' From a status display,',X'1DE8',C'RE',X$\n               '1D60',C'or',X'1DE8',C'RQ',X'1D60',C'may be entered as a$\n                line command for',X'1DE8',C'REQueue.',X'1D60'\n         DC    AL1(081,0,02),C' (See',X'1DE8',C'\"Help LINECMDS\"',X'1D60$\n               ',C'for information on entering subcommands as line comm$\n               ands.)'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(012,0,02),X'1DE8',C'Operands',X'1D60',C'-'\n         DC    AL1(042,0,00),C'   <jobid> - The name or number of the j$\n               ob.'\n         DC    AL1(033,0,00),C'   <class> - The new output class.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(069,0,04),X'1DE8',C'Default',X'1D60',C'- <class> def$\n               aults to the class specified via the',X'1DE8',C'\"MODE\"',$\n               X'1D60'\n         DC    AL1(063,0,02),C'           subcommand.  If not specified$\n                there, default is',X'1DE8',C'A.',X'1D60'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(073,0,04),X'1DE8',C'Note    ',X'1D60',C'- An asteris$\n               k',X'1DE8',C'(\"*\")',X'1D60',C'may be used in place of <j$\n               obid> to refer'\n         DC    AL1(045,0,00),C'            to the most recently selecte$\n               d job.'\n        AIF (&@@TMPSV OR &@@SCSVC NE 0 OR &@@TSOE GE 120).HE#REQ\n         DC    AL1(069,0,00),C'NOTE:  The \"REQUEUE\" subcommand can only$\n                function if QUEUE was entered'\n         DC    AL1(060,0,00),C'       at the \"READY\" level (i.e., it ca$\n               nnot work inside SPF)'\n.HE#REQ   ANOP\n         DC    X'FF'                    Flag end of screen\n         SPACE 3\nHE#RIGHT DC    AL1(000,0,00),C' '\n         DC    AL1(071,0,00),C' The \"RIGHT\" subcommand repositions the $\n               currently selected dataset right'\n         DC    AL1(030,0,00),C' a specified number of columns.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(020,0,02),X'1DE8',C'Syntax',X'1D60',C'- RIGHT <#>'\n         DC    AL1(012,0,02),X'1DE8',C' Alias',X'1D60',C'- R'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(012,0,02),X'1DE8',C'Operands',X'1D60',C'-'\n         DC    AL1(045,0,00),C'   <#> - The number of columns to shift $\n               right.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(022,0,02),X'1DE8',C'Defaults',X'1D60',C'- <#> = 40.'$\n\n         DC    X'FF'                    Flag end of screen\n         SPACE 3\nHE#ROUTE DC    AL1(000,0,00),C' '\n         DC    AL1(069,0,00),C' The \"ROUTE\" subcommand changes the prin$\n               t/punch destination for a job.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(031,0,02),X'1DE8',C'Syntax',X'1D60',C'- ROUTE <jobid$\n               > <dest>'\n         DC    AL1(019,0,02),X'1DE8',C'Aliases',X'1D60',C'- ROU, RJ'\n         DC    AL1(068,0,04),C' From a status display,',X'1DE8',C'RJ',X$\n               '1D60',C'or',X'1DE8',C'R',X'1D60',C'may be entered as a $\n               line command.'\n         DC    AL1(081,0,02),C' (See',X'1DE8',C'\"Help LINECMDS\"',X'1D60$\n               ',C'for information on entering subcommands as line comm$\n               ands.)'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(012,0,02),X'1DE8',C'Operands',X'1D60',C'-'\n         DC    AL1(042,0,00),C'   <jobid> - The name or number of the j$\n               ob.'\n         DC    AL1(039,0,00),C'   <dest>  - The new output destination.$\n               '\n         DC    AL1(000,0,00),C' '\n         DC    AL1(074,0,04),X'1DE8',C'Default',X'1D60',C'- <dest> defa$\n               ults to the destination specified via the',X'1DE8',C'\"MO$\n               DE\"',X'1D60'\n         DC    AL1(074,0,00),C'           subcommand.  If not specified$\n                there, default is your LOGON dest.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(073,0,04),X'1DE8',C'Note    ',X'1D60',C'- An asteris$\n               k',X'1DE8',C'(\"*\")',X'1D60',C'may be used in place of <j$\n               obid> to refer'\n         DC    AL1(045,0,00),C'            to the most recently selecte$\n               d job.'\n          AIF   (&@@SCSVC NE 0 OR &@@TSOE GE 120).HE#ROU\n         DC    AL1(067,0,00),C'NOTE:  The \"ROUTE\" subcommand can only f$\n               unction if QUEUE was entered'\n         DC    AL1(060,0,00),C'       at the \"READY\" level (i.e., it ca$\n               nnot work inside SPF)'\n.HE#ROU   ANOP\n         DC    X'FF'                    Flag end of screen\n         SPACE 3\nHE#SAVE  DC    AL1(000,0,00),C' '\n         DC    AL1(069,0,00),C' The \"SAVE\" subcommand writes a copy of $\n               the currently selected spooled'\n         DC    AL1(040,0,00),C' dataset (or a part) into a disk dataset$\n               .'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(067,0,02),X'1DE8',C'Syntax',X'1D60',C'- SAVE <dsname$\n               > / OLD MOD NEW NORLSE UNIT=<unit> VOL=<vol>'\n         DC    AL1(061,0,00),C'                          START=<start> $\n               STOP=<stop> END=<stop>'\n         DC    AL1(058,0,00),C'                          PRI=<pri> SEC=$\n               <sec> TRACK TRK CYL'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(012,0,02),X'1DE8',C'Operands',X'1D60',C'-'\n         DC    AL1(044,0,00),C'   <dsname> - The name of the output dat$\n               aset.'\n         DC    AL1(059,0,00),C'   /NEW     - The output dataset is to b$\n               e created (default).'\n         DC    AL1(047,0,00),C'   /OLD     - The output dataset already$\n                exists.'\n         DC    AL1(052,0,00),C'   /MOD     - The output dataset is to b$\n               e added onto.'\n         DC    AL1(070,0,00),C'   /NORLSE  - Unused space in the output$\n                dataset is not to be released.'\n         DC    AL1(051,0,00),C'              (Only applies to NEW outpu$\n               t datasets.)'\n         DC    AL1(067,0,00),C'   <unit>   - The unitname to use for al$\n               locating the output dataset.'\n         DC    AL1(065,0,00),C'   <vol>    - The volser to use for allo$\n               cating the output dataset.'\n         DC    AL1(043,0,00),C'   <start>  - The first line number to s$\n               ave.'\n         DC    AL1(042,0,00),C'   <stop>   - The last line number to sa$\n               ve.'\n         DC    AL1(064,0,00),C'   <pri>    - The amount of primary spac$\n               e for the output dataset.'\n         DC    AL1(066,0,00),C'   <sec>    - The amount of secondary sp$\n               ace for the output dataset.'\n         DC    AL1(046,0,00),C'   /TRACK   - The specified space is in $\n               tracks.'\n         DC    AL1(030,0,00),C'   /TRK     - Alias for /TRACK.'\n         DC    AL1(049,0,00),C'   /CYL     - The specified space is in $\n               cylinders.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(071,0,02),X'1DE8',C'Defaults',X'1D60',C'- If <dsname$\n               > is not a fully qualified name, it will be pre-'\n         DC    AL1(071,0,00),C'               fixed with your TSO prefi$\n               x, and suffixed with ''.OUTLIST''.'\n         DC    AL1(062,0,00),C'            If no disposition is specifi$\n               ed, the default is NEW.'\n         DC    AL1(064,0,00),C'            Default for <start> is the f$\n               irst line in the dataset.'\n         DC    AL1(062,0,00),C'            Default for <stop> is the la$\n               st line in the dataset.'\n         DC    AL1(042,0,00),C'            Default for <pri> is 10 trac$\n               ks.'\n         DC    AL1(042,0,00),C'            Default for <sec> is 50 trac$\n               ks.'\n         DC    X'FF'                    Flag end of screen\n         SPACE 3\nHE#SJ    DC    AL1(000,0,00),C' '\n         DC    AL1(075,0,04),C' The \"SJ\" subcommand selects a job for v$\n               iewing sysout via the',X'1DE8',C'NS',X'1D60',C'and',X'1D$\n               E8',C'PS',X'1D60'\n         DC    AL1(063,0,00),C' subcommands, and displays the first sys$\n               out dataset (usually the'\n         DC    AL1(008,0,00),C' JOBLOG.)'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(026,0,02),X'1DE8',C'Syntax',X'1D60',C'- SJ <jobid> /$\n               ALL'\n         DC    AL1(012,0,02),X'1DE8',C' Alias',X'1D60',C'- S'\n         DC    AL1(068,0,04),C' From a status display,',X'1DE8',C'SJ',X$\n               '1D60',C'or',X'1DE8',C'S',X'1D60',C'may be entered as a $\n               line command.'\n         DC    AL1(081,0,02),C' (See',X'1DE8',C'\"Help LINECMDS\"',X'1D60$\n               ',C'for information on entering subcommands as line comm$\n               ands.)'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(012,0,02),X'1DE8',C'Operands',X'1D60',C'-'\n         DC    AL1(042,0,00),C'   <jobid> - The name or number of the j$\n               ob.'\n         DC    AL1(070,0,00),C'   ALL     - All Sysout datasets will be$\n                selected, including those that'\n         DC    AL1(031,0,00),C'             appear to be empty.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(058,0,02),X'1DE8',C'Defaults',X'1D60',C'- The previo$\n               usly selected job will be selected.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(071,0,06),X'1DE8',C'Notes   ',X'1D60',C'- See also t$\n               he description of the',X'1DE8',C'NS',X'1D60',C'and',X'1D$\n               E8',C'PS',X'1D60',C'subcommands.'\n         DC    X'FF'                    Flag end of screen\n         SPACE 3\nHE#SLOG  DC    AL1(000,0,00),C' '\n         DC    AL1(058,0,00),C' The \"SLOG\" subcommand lists a system lo$\n               g (SYSLOG) dataset.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(029,0,02),X'1DE8',C'Syntax',X'1D60',C'- SLOG <jobid>$\n                <seq>'\n         DC    AL1(013,0,02),X'1DE8',C' Alias',X'1D60',C'- SL'\n         DC    AL1(061,0,02),C' From a status display,',X'1DE8',C'SL',X$\n               '1D60',C'may be entered as a line command.'\n         DC    AL1(081,0,02),C' (See',X'1DE8',C'\"Help LINECMDS\"',X'1D60$\n               ',C'for information on entering subcommands as line comm$\n               ands.)'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(012,0,02),X'1DE8',C'Operands',X'1D60',C'-'\n         DC    AL1(054,0,00),C'   <jobid> - The system id or job number$\n                of the SYSLOG.'\n         DC    AL1(073,0,00),C'   <seq>   - The number of datasets to b$\n               ack up, with 0 indicating current.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(069,0,02),X'1DE8',C'Defaults',X'1D60',C'- If <jobid>$\n                is omitted, the active SYSLOG for the current'\n         DC    AL1(035,0,00),C'            system will be selected.'\n         DC    AL1(068,0,00),C'          - If <seq> is omitted, the lat$\n               est (or only) dataset will be'\n         DC    AL1(045,0,00),C'            selected for the specified S$\n               YSLOG.'\n         DC    X'FF'                    Flag end of screen\n         SPACE 3\nHE#STAT  DC    AL1(000,0,00),C' '\n         DC    AL1(068,0,00),C' The \"STATUS\" subcommand displays all jo$\n               bs beginning with any prefix,'\n         DC    AL1(077,0,00),C' or with a writer name (target userid) e$\n               xactly equal to the operand of STATUS.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(041,0,02),X'1DE8',C'Syntax',X'1D60',C'- STATUS <pref$\n               ix> / OUT O TIME T'\n         DC    AL1(020,0,02),X'1DE8',C'Aliases',X'1D60',C'- STAT, ST'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(012,0,02),X'1DE8',C'Operands',X'1D60',C'-'\n         DC    AL1(033,0,00),C'   <prefix> - The partial jobname.'\n         DC    AL1(067,1,00),C'   /ALL     - All JCT''s will be read an$\n               d checked for a NOTIFY= which'\n         DC    AL1(070,1,00),C'              starts with <prefix>.  Thi$\n               s operand is not documented for'\n         DC    AL1(068,1,00),C'              unprivileged users, and ma$\n               y be made unavailable to them'\n         DC    AL1(068,1,00),C'              since it results in a very$\n                large number of I/O requests'\n         DC    AL1(059,1,00),C'              to the spool (one for each$\n                job in the system!)'\n         DC    AL1(067,1,00),C'   /PERCENT - Display the percent of spo$\n               ol space in use by each job.'\n         DC    AL1(032,1,00),C'   /PCT     - Alias for /PERCENT.'\n         DC    AL1(032,1,00),C'   /P       - Alias for /PERCENT.'\n         DC    AL1(066,1,00),C'   /SPACE   - Display the amount of spoo$\n               l space in use by each job.'\n         DC    AL1(030,1,00),C'   /SIZE    - Alias for /SPACE.'\n         DC    AL1(030,1,00),C'   /S       - Alias for /SPACE.'\n         DC    AL1(067,0,00),C'   /OUT     - Display output group names$\n                instead of the device name.'\n         DC    AL1(028,0,00),C'   /O       - Alias for /OUT.'\n         DC    AL1(078,0,00),C'   /TIME    - Display the input time (in$\n               put jobs) or output time (output jobs).'\n         DC    AL1(029,0,00),C'   /T       - Alias for /TIME.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(072,0,02),X'1DE8',C'Defaults',X'1D60',C'- The previo$\n               usly entered prefix will be used (initially, your'\n         DC    AL1(023,0,00),C'            TSO userid).'\n         DC    X'FF'                    Flag end of screen\n         SPACE 3\nHE#SYNT  DC    AL1(057,0,00),C'                             << QUEUE su$\n               bcommand syntax >>'\n         DC    AL1(052,0,00),C' There are 3 types of operands for QUEUE$\n                subcommands.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(073,0,02),X'1DE8',C'Positional',X'1D60',C'operands i$\n               mmediately follow the command, with no delimiters.'\n         DC    AL1(069,0,00),C' For example, \"JCL myjobname\".  Any posi$\n               tional operands specified must'\n         DC    AL1(049,0,00),C' appear before any operands of the next $\n               two types.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(072,0,02),X'1DE8',C'Keyword value',X'1D60',C'operand$\n               s are of the form KEYWORD=value.  For example, in'\n         DC    AL1(070,0,00),C' \"PRINT ON FCB=F002\", \"ON\" is a position$\n               al operand, and \"FCB=F002\" is a'\n         DC    AL1(022,0,00),C' keyword value operand.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(069,0,02),X'1DE8',C'Reserved word',X'1D60',C'operand$\n               s are special options.  To distinquish between'\n         DC    AL1(070,0,00),C' positional and reserved word operands, $\n               the first reserved word must be'\n         DC    AL1(064,0,00),C' preceeded by a slash, for example, \"DI $\n               /TIME\".  The slash may be'\n         DC    AL1(069,0,00),C' omitted if:  1) the subcommand does not$\n                allow any positional operands'\n         DC    AL1(069,0,00),C' (example:  \"DH TIME\") , or, 2) a keywor$\n               d=value operand appears before'\n         DC    AL1(054,0,00),C' the reserved word operand (example:  \"D$\n               O R=ALL TIME\").'\n         DC    X'FF'                    Flag end of screen\n         SPACE 3\nHE#TOP   DC    AL1(000,0,00),C' '\n         DC    AL1(066,0,00),C' The \"TOP\" subcommand repositions the cu$\n               rrently selected dataset to'\n         DC    AL1(008,0,00),C' the top.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(014,0,02),X'1DE8',C'Syntax',X'1D60',C'- TOP'\n         DC    AL1(013,0,02),X'1DE8',C'Aliases',X'1D60',C'- T'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(018,0,02),X'1DE8',C'Operands',X'1D60',C'- None.'\n         DC    X'FF'                    Flag end of screen\n         SPACE 3\nHE#TOPIC DC    AL1(059,0,00),C'                             << Miscella$\n               neous HELP Topics >>'\n         DC    AL1(079,0,02),C' HELP for various miscellaneous topics i$\n               s available, by entering',X'1DE8',C'HELP',X'1D60',C'foll$\n               owed'\n         DC    AL1(036,0,00),C' by one of the keywords listed below.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(054,0,02),C'   ',X'1DE8',C'ADMIN    ',X'1D60',C'- Su$\n               mmary of Administrative subcommands'\n         DC    AL1(028,0,02),C'   ',X'1DE8',C'COMMANDS ',X'1D60',C'- Th$\n               is screen'\n         DC    AL1(057,0,02),C'   ',X'1DE8',C'DSS      ',X'1D60',C'- Su$\n               mmary of Dataset selection subcommands'\n         DC    AL1(039,0,02),C'   ',X'1DE8',C'GENERAL  ',X'1D60',C'- Ge$\n               neral notes on QUEUE'\n         DC    AL1(066,0,02),C'   ',X'1DE8',C'IOQ      ',X'1D60',C'- Su$\n               mmary of Input/Output queue display subcommands'\n         DC    AL1(043,0,02),C'   ',X'1DE8',C'LINECMDS ',X'1D60',C'- Li$\n               ne subcommand processing'\n         DC    AL1(050,1,02),C'   ',X'1DE8',C'PRIVCMDS ',X'1D60',C'- Su$\n               mmary of privileged subcommands'\n         DC    AL1(058,0,02),C'   ',X'1DE8',C'QPROF    ',X'1D60',C'- Ho$\n               w to use a QUEUE initialization profile'\n         DC    AL1(061,0,02),C'   ',X'1DE8',C'REPOS    ',X'1D60',C'- Su$\n               mmary of Dataset repositioning subcommands'\n         DC    AL1(057,0,02),C'   ',X'1DE8',C'SYNTAX   ',X'1D60',C'- Sy$\n               ntax of QUEUE subcommands and operands'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(000,0,00),C' '\n         DC    AL1(041,0,02),C' For more information, enter',X'1DE8',C'$\n               HELP HELP.',X'1D60'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(078,0,02),X'1DE8',C'NOTE:',X'1D60',C' At this time, $\n               HELP is still incomplete.  I''m typing as fast as I can.$\n               '\n         DC    X'FF'                    Flag end of screen\n         SPACE 3\n          AIF   (NOT &@@TMPSV).HE#NTS3\nHE#TSO   DC    AL1(000,0,00),C' '\n         DC    AL1(071,0,00),C' The \"TSO\" subcommand allows most TSO co$\n               mmands and CLISTs to be executed'\n         DC    AL1(022,0,00),C' without leaving QUEUE.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(023,0,02),X'1DE8',C'Syntax',X'1D60',C'- TSO <tsocmd>$\n               '\n         DC    AL1(000,0,00),C' '\n         DC    AL1(012,0,02),X'1DE8',C'Operands',X'1D60',C'-'\n         DC    AL1(067,0,00),C'            <tsocmd> is any TSO command $\n               which may be executed at the'\n         DC    AL1(065,0,00),C'                     \"READY\" level, exce$\n               pt those which require APF'\n         DC    AL1(034,0,00),C'                     authorization.'\n         DC    X'FF'                    Flag end of screen\n         SPACE 3\n.HE#NTS3  ANOP\nHE#UP    DC    AL1(000,0,00),C' '\n         DC    AL1(069,0,00),C' The \"UP\" subcommand repositions the cur$\n               rently selected dataset toward'\n         DC    AL1(008,0,00),C' the top.'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(017,0,02),X'1DE8',C'Syntax',X'1D60',C'- UP <#>'\n         DC    AL1(012,0,02),X'1DE8',C' Alias',X'1D60',C'- U'\n         DC    AL1(000,0,00),C' '\n         DC    AL1(012,0,02),X'1DE8',C'Operands',X'1D60',C'-'\n         DC    AL1(067,0,00),C'   <#> - The number of records to back u$\n               p from the current position.'\n         DC    X'FF'                    Flag end of screen\n         SPACE 3\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "Q#II": {"ttr": 9473, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05A\\x00\\x00\\x00\\x82#_\\x00\\x91!\\x7f\"C\\x08O\\x03F\\x06\\x0f\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "05.65", "flags": 0, "createdate": "1982-08-23T00:00:00", "modifydate": "1991-08-05T22:43:00", "lines": 2127, "newlines": 838, "modlines": 1551, "user": "LDW"}, "text": "         TITLE '--- QUEUE--INITIAL -- INITIALIZATION ROUTINES ---'\n*---------------------------------------------------------------------*\n*                                                                     *\n*   INITIAL - Getmain and initialize all workareas, open all DCBs,    *\n*             perform profile processing                              *\n*                                                                     *\n*   Updates:                                                          *\n*      05Aug91  LDW  Integrate GLA fixes below:                       *\n*     (23Jul91) GLA  Always save address of HCCT/SVT                  *\n*      04Jul91  LDW  Update for tables moved to @GLOBALC              *\n*      06Jun91  EMS  Update for SP420, and fix JES2 version check     *\n*      26May91  LDW  VDEFINE QBRIFHDR                                 *\n*      15Apr91  LDW  Fix previous update                              *\n*      28Mar91  LDW  Don't use in-storage copy of checkpoint if       *\n*                       CKPT() or DSN() specified unless JES() also   *\n*      27Mar91  LDW  Allow QGLOBALS specification of dsn suffixes     *\n*      10Feb91  LDW  Rewrite ISPF detection to support direct         *\n*                       invocation under current releases of ISPF     *\n*                    Move some data out of QCOMMON to here            *\n*                    Use II@CALLP instead of TBLST and VCALLST        *\n*      30Jan91  LDW  Integrate selected GLA updates as follows:       *\n*     (02Aug90) GLA  Save addr of SVT/CCT for incore ckpt check       *\n*     (10Jul90) GLA  Add code to initialize PC routines to allow      *\n*                       easy access to in-core CKPT for 2.2 and 3.1   *\n*     (15Nov89) GLA  Fix support for SP3.1.1 for previous releases.   *\n*                    Add support for VERB TABLE variable.             *\n*     (16Jun89) GLA  Fix XA 0C4 due to clobbered register.            *\n*     (20Apr89) GLA  Fix JCT overlay on CKPT read. The setup of       *\n*                       JCT address in the buffer was off by 4K.      *\n*     (28Mar89) GLA  Add ISPF BROWSE & table support for ISPF V1.x    *\n*                       through 2.3                                   *\n*      29Jan91  LDW  Add QVPRNTWA to II#RELOC                         *\n*      22Dec90  LDW  Use EQU for SYSTABLE entry length                *\n*      27Nov90  EMS  Fix for longer dsn's                             *\n*      16Jun90  LDW  Run (mostly) in AMODE31 now                      *\n*      25Dec89  LDW  Q$xxx -> QZxxx:  CPPL, CVT, JESCT, PSCB, SSCT,   *\n*                                     SSIB, UCB                       *\n*      12Dec89  LDW  Use &@@OACFS for name of OACFSORT load module    *\n*                    Pick up following updates from Doron 21Nov89:    *\n*               DMS  Test &@@SYSP and &@@STAFF instead of hardcoded   *\n*                    Make use of OACFSORT conditional on &@@OACFS     *\n*                    Bypass KAC reference if &QLEVEL LT 8             *\n*      23Nov89  LDW  Remove conditional assembly around Qxxx macros   *\n*                    Remove prereq Q$PDDB                             *\n*      05Jun89  LDW  Set QXSUPR and QXAPFENT if appropriate           *\n*      25Apr89  EMS  SP311 changes, in core ckpt use                  *\n*      17Apr89  LDW  Change Q$UCB to QUCB                             *\n*      03Feb88  LDW  Adapt Jack Schudel's 2.2.0 mods for Lockheed's   *\n*                       QUEUE to this QUEUE                           *\n*       3Jun87  EMS  Add support for Starting/Draining Spool vols     *\n*                       and better checking for invalid mttr's        *\n*                    load OACFSORT                                    *\n*                    getmain separate table for DDNAME cmd            *\n*      13Feb87  LDW  Init QVRING                                      *\n*                    Use table to relocate adcons in QCOMMON          *\n*      17Jan87  LDW  Set QCNUMTGA = $NUMTG if QLEVEL < 5              *\n*                    Misc cleanup                                     *\n*      10Jan87  LDW  SP136:  Save $JQELEN, many changes in CKPT math  *\n*                    Use CVT instead of CVTDSECT (for XA?)            *\n*      04SEP86  LDW  USE DCB EXIT TO SET DEFAULT NCP                  *\n*      25AUG86  LDW  FIX BUGS IN PREVIOUS UPDATE (SP130 BROKE)        *\n*      17JUN86  LDW  SAVE INFO ON SECTIONS OF CKPT DATASET, TO ALLOW  *\n*                       READING ONLY NECESSARY DATA                   *\n*                    SET QMFMVSE IF RUNNING MVS/XA                    *\n*                    ADD SECOND BASE REG (PUKE!)                      *\n*      03JUN86  LDW  GETMAIN STORAGE FOR MULTIPLE HASPCKPT DECBS      *\n*      03/30/86 LDW  RE-DESIGN 3278-5 SUPPORT (THIRD TRY!)            *\n*                    STAX BLOCK MOVED FROM QCOMMON TO QUEUE LOCAL     *\n*                       WORKAREA                                      *\n*      08/30/84 LDW  GETMAIN A SCREEN BUFFER                          *\n*                    SAVE ALL GETMAINED ADDRESSES AND LENGTHS         *\n*      08/07/84 LDW  UPDATE FOR SP134 (DON'T COMPUTE QCPDDB1)         *\n*      08/06/84 LDW  IF SP:  FOR HASPCKPT BLKSIZE, USE MAX FOR        *\n*                       DEVICE, TO ACCOUNT FOR THE MASTER REC IN      *\n*                       JES2/SP BEING LARGER THAN 4K                  *\n*      06/05/84 LDW  UPDATES FOR SP133 FROM UF VERSION                *\n*      04/20/84 EMS  FIX FOR QPROF RECFM=FB                           *\n*      04/11/84 LDW  IOTDSECT -> IOTSTART                             *\n*                    USING/DROP -> USNGX/DROPX                        *\n*      04/10/84 LDW  SP133 COMPATIBILITY                              *\n*      01/23/83 LDW  RELOCATE QHDCBA AND QHDECBA                      *\n*      12/19/83 LDW  SET QCTGMLEN (FOR NEW 'SPACE' FEATURE)           *\n*      10/30/83 LDW  FIX TEST FOR RECALL (WAS 'REPROMPT')             *\n*      10/17/83 LDW  CORRECT SOME ADDREESSABILITY ERRORS CAUSED BY    *\n*                       ENLARGING 'SYSTABLE'                          *\n*      07/25/83 LDW  DON'T CALL ISPLINK UNLESS PARM STARTS WITH       *\n*                       'ISPF'                                        *\n*      04/19/83 LDW  FIX BUG IN ALLOCATING HASPACE IF JES2/SP         *\n*      03/18/83 LDW  RELOCATE QVSTACK, QVSTACKC                       *\n*                    MISC FIXES FOR ADDRESSABILITY                    *\n*      03/01/83 LDW  RELOCATE QVLCBUF                                 *\n*      02/04/83 LDW  SEE IF ISPLINK EXISTS BEFORE LINKING TO IT       *\n*      02/03/83 LDW  TO SUPPORT 3380'S:  REMOVE DEVICE TABLE, USE     *\n*                       DEVTYPE MACRO                                 *\n*                    OTHER MISC CLEANUP DONE IN THIS AREA             *\n*      02/02/83 LDW  CHANGE CONDITIONAL ASSEMBLY SO THAT IF SID TABLE *\n*                       IS GENERATED CORRECTLY IF &QSIDNUM = 0        *\n*      01/24/83 LDW  PICK UP LOCAL NODE ID FROM $SAVEAREA IF SP       *\n*                    ADD $PDDB IN FRONT OF $IOT IF SP                 *\n*      01/19/83 LDW  ADD OPTIONAL TRANSLATION OF SMF ID'S             *\n*                    ADD ANOTHER TEMPORARY BASE FOR QCOMMON           *\n*                    SET QTPAGEX, QTHALFX                             *\n*                    REMOVE TESTAUTH (NOW IN NEW ROUTINE \"APF\")       *\n*      01/14/83 LDW  ADD SP SUPPORT                                   *\n*      01/04/83 LDW  CHECK FOR SPF ENVIRONMENT                        *\n*                    RE-ENABLE MOD 5 SUPPORT                          *\n*                    SET QSTDEFKY                                     *\n*                    CHECK THAT CHKPT FILE IS THE ONE WE HAVE BEEN    *\n*                       ASSEMBLED FOR                                 *\n*                    USE NJE FIELD NAMES ($SVTONOD REPLACES $SVTOSYS) *\n*                    FIX BUG:  REPROMPT WITH INVOCATION CMD IF BAD    *\n*      12/10/82 LDW  ALLOW PROFILE COMMENTS AS '/*' OR ' /*'          *\n*      10/28/82 LDW  SAVE SYSTEM ID OF SELECTED JES2 IN QSYSID(0)     *\n*      10/14/82 EMS  ADD SUPPORT FOR RECFM V PROFILES                 *\n*                    FIX BUG IN PROCESSING OF MULTIPLE QSE'S          *\n*                    FIX BUG IN PARM PROCESSING                       *\n*                    ONLY USE 1 MODEL DCB FOR BOTH PS AND PO PROFILES *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 3\nINITIAL  QSTART  Q10,WORKLEN=II@WORKL\n         LA    R8,4095(,R12)            SET UP SECOND...\n         LA    R8,1(,R8)                ... BASE REGISTER\n         USNGX INITIAL+4096,R8          COMPLETE THE TRAVESTY\n         USNGX WORK,R13\n         USNGX PSA,R0\n         ST    R3,II@STAXA              SAVE ADDRESS OF STAX BLOCK\n         MVI   II@FLAGS,0               INIT FLAGS\n***********************************************************************\n*                                                                     *\n*   COPY AND INITIALIZE QCOMMON                                       *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n*  AT ENTRY (FROM \"QUEUE\" MAINLINE), R11 -> \"QCOMMON\" CSECT, SO WE MUST\n*  NOT STORE ANYTHING UNTIL AFTER WE HAVE CHANGED TO THE GETMAINED COPY\n         L     R10,QGETMAIN             GET LENGTH OF QCOMMON\n         GETMAIN  RU,LV=(R10),SP=44,BNDRY=PAGE  GET AN AREA FOR QCOMMON\n         SPACE 1\n* MOVE QCOMMON INTO WORKING STORAGE\n         LR    R0,R11                   -> QCOMMON (SOURCE ADDR)\n         LR    R14,R1                   -> GETMAIN AREA (DEST ADDR)\n         LR    R11,R1                   ADDRESS NEW QCOMMON\n         LR    R1,R10                   SOURCE LENGTH FOR MVCL\n         LR    R15,R1                   DEST LENGTH\n         MVCL  R14,R0                   COPY CSECT TO GETMAINED AREA\n*  NOW MUST INITIALIZE ALL THE ADCONS IN IT\n         MVC   QCCKPT,II#OPENI          INITIALIZE HASPCKPT OPEN LIST\n         MVC   QCSAVE,II#OPENO          INITIALIZE HASPSAVE OPEN LIST\n         MVC   QPPRNT,II#OPENO          INITIALIZE HASPPRNT OPEN LIST\n         MVI   QHDCBA,X'80'             MARK END OF OPEN LIST\n         LA    R1,II#RELOC              -> RELOCATION TABLE\nII$RL$LP LH    R14,0(,R1)               GET OFFSET OF POINTER\n         AR    R14,R11                  -> ADCON\n         LH    R15,2(,R1)               GET OFFSET OF DATA\n         AR    R15,R11                  -> VALUE\n         STCM  R15,B'0111',1(R14)       STORE RELOCATED DATA POINTER\n         LA    R1,4(,R1)                -> NEXT RELOCATION TABLE ENTRY\n         CLI   0(R1),X'FF'              END OF TABLE?\n         BNE   II$RL$LP                 NO - LOOP\n         SPACE 3\n         L     R1,4(,R13)               PREVIOUS SAVE AREA\n         ST    R11,64(,R1)              UPDATE R11 IN PREVIOUS S.A.\n         ST    R1,QFRSTSA               STORE @ FIRST S.A. IN QCOMMON\n***********************************************************************\n*                                                                     *\n*  If called via the ISRQ module (from ISPF) the following            *\n*     calling conventions will hold:                                  *\n*       R2 (orig R1)  =  Address of parm list (but non-CPPL fmt)      *\n*                           +0 = F'-1'   to distinguish from CPPL     *\n*                           +4 = TLD address                          *\n*                           +8 = address of 'ISPLINK'                 *\n*                           +12= address of CPPL                      *\n***********************************************************************\n         CLC   =F'-1',0(R2)             did call come from 'ISRQ'\n         BNE   VLDTSO                   if not then normal system call\n         LA    R3,4(,R2)                point at \"real\" parms from ISRQ\n         OI    QISFLAG1,QIS1ISPF        set called from ISPF flag\n         MVC   BRWEPARM,0(R3)           save addr of TLD\n         MVC   ISPLNK,4(R3)             save addr of ISPLINK program\n         L     R2,8(,R3)                get address of CPPL\n         B     IICPPLOK                 continue\n         SPACE 1\nVLDTSO   DS    0H\n***********************************************************************\n*                                                                     *\n*   Check out whether we are APF authorized or SUPR mode, remember    *\n*   for later.                                                        *\n*                                                                     *\n***********************************************************************\n         TESTAUTH  FCTN=1               see if we are APF authorized\n         SPACE 1\n         LTR   R15,R15                  are we?\n         BNZ   *+8                      no\n         OI    QXAUTH,QXAPFENT          yes\n         SPACE 2\n***      TESTAUTH  FCTN=0,STATE=YES     see if we are SUPR mode\n         SPACE 1\n***      LTR   R15,R15                  are we?\n***      BNZ   *+8                      no\n***      OI    QXAUTH,QXSUPR            yes\n*---  The TESTAUTH above results in abend S177.  Until this is\n*---  resolved, do it a different way.\n         L     R1,PSATOLD               -> TCB\n         L     R1,0(,R1)                TCB.RBP\n         N     R1,=X'00FFFFFF'          clean in case AMODE31\n         TM    10(R1),X'E0'             RB.STAB1,RBFTP  PRB?\n         BZ    *+8                      yes - can't be SUPR\n         OI    QXAUTH,QXSUPR            assume SVRB\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*   IF WE HAVE BEEN CALLED RATHER THEN INVOKED AS A CP,               *\n*   PHONY UP A CPPL                                                   *\n*                                                                     *\n***********************************************************************\n         USNGX CPPL,R2                  ADDR OF CPPL IS IN R2\n         L     R1,PSATOLD               -> TCB\n         L     R1,180(,R1)              -> JSCB\n         L     R1,264(,R1)              -> PSCB\n         TM    0(R2),X'80'              CALL?\n         BO    II$CALL1                 YES - GO PHONY UP SOME STUFF\n         CLM   R1,B'0111',CPPLPSCB+1    DOES IT LOOK ENOUGH LIKE CPPL?\n         BE    IICPPLOK                 YES - DO IT FOR REAL\n*  DARN.  IT'S CALL.  BUILD A PHONY CPPL.\nII$CALL1 OI    II@FLAGS,II@FCALL        REMEMBER THAT THIS IS \"CALL\"\n         LR    R4,R2                    PRESERVE PARM POINTER\n         LA    R2,II@CPPL               CHANGE POINTER TO PHONY ONE\n         XC    0(4*4,R2),0(R2)          ZERO IT FOR FUN\n         ST    R1,CPPLPSCB              SET PSCB ADDRESS IN PHONY CPPL\n         USNGX PSCB,R1\n         MVC   CPPLUPT,PSCBUPT          UPT ADDRESS TO CPPL\n         L     R1,PSCBRLGB              -> RELOGON BUFFER\n         DROPX R1                       PSCB\n         L     R1,256(,R1)              RLGB.ECT\n         ST    R1,CPPLECT               SET ECT ADDRESS IN PHONY CPPL\n***********************************************************************\n*                                                                     *\n*   MOVE PARMS FROM CPPL TO DAPL                                      *\n*                                                                     *\n***********************************************************************\nIICPPLOK MVC   DAPLUPT,CPPLUPT          USER PROFILE TABLE\n         MVC   DAPLPSCB,CPPLPSCB        PROTECTED STORAGE CNTL BLK\n         MVC   DAPLECT,CPPLECT          ENVIRONMENT CNTL TABLE\n***********************************************************************\n*                                                                     *\n*   LOCATE LOGON ID, SAVE FOR FUTURE REFERENCE                        *\n*                                                                     *\n***********************************************************************\n         L     R1,CPPLPSCB              -> PSCB\n         USNGX PSCB,R1\n         MVC   QLOGON(7+1),PSCBUSER     SAVE TSO USERID AND LENGTH\n         MVC   QSTKEY(7),QLOGON         SET SEARCH KEY FOR \"ST\"\n         MVC   QSTDEFKY,QSTKEY          SET DEFAULT FOR \"ST *\"\n         TM    &@@SYSP                  SYSTEMS PROGRAMMER?\n         BNO   *+8                      NO - SKIP\n         OI    QXAUTH,QXSYSP            YES - REMEMBER\n         TM    &@@STAFF                 OPERATOR COMMAND AUTHORITY?\n         BNO   *+8                      NO - SKIP\n         OI    QXAUTH,QXOPER            YES - REMEMBER\n         DROPX R1                       PSCB\n         SPACE 3\n         L     R1,PSATOLD               -> TCB\n         L     R1,TCBJSCB-TCB(,R1)      -> JSCB\n         L     R1,316(,R1)              -> SSIB  (JSCBSSIB-IEZJSCB)\n         USNGX SSIB,R1\n         MVC   QDEST,SSIBDEST           SAVE LOGON DEST\n         MVC   QPDEST,SSIBDEST          SET DEFAULT PRINT DEST\n         MVC   QJESNAME,SSIBSSNM        SAVE NAME OF JES2\n         DROPX R1                       SSIB\n         DROPX R0                       PSA\n***********************************************************************\n*                                                                     *\n*   MOVE COMMAND BUFFER TO REPLY BUFFER                               *\n*                                                                     *\n***********************************************************************\n         TM    II@FLAGS,II@FCALL        CP OR CALL?\n         BNO   II$CP                    NOT CALL\n         L     R4,0(,R4)                GET PARM ADDRESS\n         LH    R3,0(,R4)                GET OPERAND LENGTH\n         SH    R3,=H'1'                 DECR FOR EX\n         BM    II$SKPRM                 SKIP IF NO OPERAND\n         LA    R1,2(,R4)                -> PARM TEXT\n         B     II$CALL2                 CONTINUE\nII$CP    L     R1,CPPLCBUF              ADDR OF COMMAND BUFFER\n         DROPX R2                       CPPL\n         LH    R3,0(,R1)                LENGTH OF COMMAND BUFFER\n         LH    R4,2(,R1)                OFFSET TO FIRST DATA BYTE\n         LA    R1,4(R1,R4)              FIRST DATA BYTE\n         SR    R3,R4                    SUBTRACT OFFSET FROM LENGTH\n         SH    R3,=H'5'                 SUB OVERHEAD, PLUS 1 FOR EX\n         BM    II$SKPRM                 SKIP IF LENGTH ZERO\nII$CALL2 EX    R3,II$CMDOC              TRANSLATE TO UPPER CASE\nII$CKPRM CLI   0(R1),C' '               LEADING BLANK?\n         BNE   II$CKKEY                 NO, CHECK FOR KEYWORDS\n         LA    R1,1(,R1)                -> NEXT BYTE\n         BCT   R3,II$CKPRM              AND CHECK IT\n         B     II$SKPRM                 IF NONE LEFT, CONTINUE INIT\n         SPACE 1\nII$CKKEY CLC   =C'ISPF',0(R1)           IS DIALOG MANGLER TO BE USED?\n         BE    II$ISPF                  YES. SET FLAG.\n         CLC   =C'JES(',0(R1)           IS REQUEST FOR SELECT JES NAME?\n         BE    II$JESN                  YES. DO IT.\n         CLC   =C'CKPT(',0(R1)          IS REQUEST FOR CKPT?\n         BE    II$CKPT                  YES. DO IT.\n         CLC   =C'DSN(',0(R1)           IS REQUEST FOR DSN PREFIX?\n         BE    II$DSN                   YES. DO IT.\n         MVC   QDREPLY,QBLANK           BLANK THE REPLY LINE\n         CH    R3,=Y(QDREPLYL-1)        IS LENGTH OVER MAX?\n         BNH   *+8                      NO. USE IT.\n         LA    R3,QDREPLYL-1            USE MAXIMUM LENGTH\n         EX    R3,II$MVC1               MOVE THE DATA\n         MVC   QDPROMPT,QDREPLY         COPY TO THE PROMPT\n         LA    R3,1(,R3)                INCREMENT TO TRUE LENGTH\n         STH   R3,QDRLNG                STORE REPLY LENGTH\n***********************************************************************\n*                                                                     *\n*   DETERMINE WHICH JES2 CHECKPOINT VOLSER AND PREFIX TO USE          *\n*                                                                     *\n***********************************************************************\nII$SKPRM L     R1,CVTPTR                -> CVT\n          AIF   (&@@SPLVL LT 130).II010  SKIP IF BIT NOT DEFINED\n         TM    CVTDCB-CVT(R1),CVTMVSE   RUNNING MVS/XA?\n         BZ    II$NOTXA                 NO - SKIP\n         OI    QMISCFLG,QMFMVSE         YES - REMEMBER\n         SL    R1,=A(32)                -> FIELD CVTPRODI\n         CLC   1(4,R1),=C'BB22'         XA 2.2 or later?  JBB2220\n         BL    II$NOTXA                 no - skip setting flag\n         OI    QMISCFLG,QMFX22          yes - remember\nII$NOTXA L     R1,CVTPTR                reload cvt pointer\n.II010    ANOP\n         L     R1,CVTJESCT-CVT(,R1)     -> JESCT\n         L     R15,JESUNITS-JESCT(,R1)  -> SYSRES UCB\n         USNGX UCBOB,R15\n         LA    R1,SYSTABLE              -> SYSTEM TABLE\nII$SYSLP CLC   UCBVOLI,0(R1)            COMPARE SYSRES VS. TABLE ENTRY\n         BE    II$RES1                  FOUND ONE - GO CHECK JESNAME\n         DROPX R15                      UCBOB\nII$NXSYS LA    R1,SYSTBLL(,R1)          -> NEXT SYSTEM TABLE ENTRY\n         CLI   0(R1),X'FF'              END OF TABLE?\n         BNE   II$SYSLP                 NO - KEEP LOOKING\n         LA    R1,SYSTABLE              NOT FOUND - USE FIRST ENTRY\n         B     II$SAVE\nII$RES1  CLC   QJESNAME,6(R1)           RIGHT JES2?\n         BNE   II$NXSYS                 NO - KEEP LOOKING\n*---  WE HAVE LOCATED A TABLE ENTRY FOR THIS SYSRES/JES2 COMBINATION\nII$SAVE  CLI   QCKPTVOL,C' '            DID USER SPECIFY CKPT(XXXXXX)?\n         BNE   *+10                     YES - USE THE ONE HE WANTS\n         MVC   QCKPTVOL,10(R1)          SAVE CHKPT VOLSER\n         CLI   QCKPTPFX,C' '            DID USER SPECIFY DSN(XXXXXX)?\n         BNE   *+10                     YES - USE THE ONE HE WANTS\n         MVC   QCKPTPFX,16(R1)          SET DSN PREFIX\n***********************************************************************\n*                                                                     *\n*   LOCATE AND SAVE VARIOUS INFORMATION ABOUT THE SELECTED JES2       *\n*                                                                     *\n***********************************************************************\n*  FIND SSCT FOR PRIMARY SUBSYSTEM\n         L     R15,CVTPTR               -> CVT\n         L     R15,CVTJESCT-CVT(,R15)   -> JESCT\n         L     R15,JESSSCT-JESCT(,R15)  -> SSCT\n         USNGX SSCT,R15\n*  FIRST, SET LOCAL NODE FROM THE PRIMARY SUBSYSTEM, IF IT'S ACTIVE\n          AIF   (&QLEVEL GE 9).II020\n         L     R14,SSCTSSVT             -> SSVT\n         USNGX SSVT,R14\n         ST    R14,QSVT                 save for CKPT\n          AIF   (&QLEVEL LT 8).II030\n         L     R7,SVTKAC                -> KAC\n          AGO   .II030\n.II020    ANOP ,\n         L     R14,SSCTSUS2             -> HCCT\n         USNGX HCCT,R14\n         ST    R14,QCCT                 save for CKPT\n         L     R7,CCTKAC                -> KAC\n.II030    ANOP ,\n         LTR   R14,R14                  IS PRIMARY SYSTEM UP?\n         BZ    II$PDOWN                 NO - SKIP\n          AIF   (&QLEVEL GE 8).II031\n         TM    $SVSID,X'80'             DOES IT APPEAR TO BE A VALID\n*                                       SMF SYSTEM ID?\n         BNO   II$PDOWN                 NO - SKIP\n*---  FOR EXPLANATION OF THE CRUMMY TEST ABOVE, GO READ \"FINDRJE\"  ---*\n          AGO   .II032\n.II031    ANOP\n         L     R1,SSCTSUSE              -> SSSM module MIT\n         CLC   QJ2VERSN,0(R1)           QUEUE assembled for this JES2?\n         BNE   II$PDOWN                 no - exit stage left\n.II032    ANOP\n         MVC   QCLNODE,$SVTONOD         SAVE OUR NODE NUMBER\n         SPACE 1\n*  NOW, FIND THE SSVT FOR THE SYSTEM WE ACTUALLY ARE INTERESTED IN\nII$PDOWN CLC   SSCTSNAM,QJESNAME        DO WE WANT THE PRIMARY?\n         BE    II$PRIM                  YES - SAVE OTHER INFO\n         SPACE 1\nII$SSCT  L     R15,SSCTSCTA             -> NEXT SSCT\n         LTR   R15,R15                  END OF CHAIN?\n         BZ    II$JNOK                  YES - CONTINUE WITH DEFAULTS\n*                           FROM PRIMARY SUBSYS SINCE WE DIDN'T FIND\n*                           THE DESIRED SECONDARY SUBSYSTEM\n         CLC   SSCTSNAM,QJESNAME        IS THIS THE ONE WE WANT?\n         BNE   II$SSCT                  NO - KEEP LOOKING\n          AIF   (&QLEVEL GE 9).II050\n         L     R14,SSCTSSVT             -> SSVT\n         ST    R14,QSVT                 save for CKPT\n          AIF   (&QLEVEL LT 8).II060\n         L     R7,SVTKAC                -> KAC\n          AGO   .II060\n.II050    ANOP ,\n         L     R14,SSCTSUS2             -> HCCT\n         ST    R14,QCCT                 save for CKPT\n         L     R7,CCTKAC                -> KAC\n.II060    ANOP ,\n         LTR   R14,R14                  IS THIS SYSTEM UP?\n         BZ    II$JNOK                  NO - CONT WITH DFLT FROM PRIM\n         MVC   QCLNODE,$SVTONOD         OUR NODE NUMBER\n         SPACE 1\nII$PRIM  MVC   QCOMCHAR,$SVCOMCH        SAVE THE COMMUNICATIONS CHAR\n          AIF   ('&@@QALTC' EQ '').II070\n         MVC   QALTCHAR,&@@QALTC\n.II070    ANOP\n         MVC   QSMFID(4),$SVSID         SAVE OUR SYSTEM ID\nII$JNOK  ST    R15,QSSCT                SAVE SSCT ADDRESS\n          AIF   (&QLEVEL LT 8).IINOPC\n         EJECT\n***********************************************************************\n*                                                                     *\n*   Check for incore checkpoint from JES2                             *\n*                                                                     *\n***********************************************************************\n         LTR   R7,R7                    Any KAC?\n         BZ    II$NKAC                  No - no in-core copy\n         TM    II@FLAGS,II@JESNM        JES() specified?\n         BNZ   II$ISUSE                 yes - ok to use in-storage ckpt\n         TM    II@FLAGS,II@CKPT+II@DSN  CKPT() or DSN() specified?\n         BNZ   II$NKAC                  yes - don't use in-storage ckpt\nII$ISUSE EQU   *\n         USNGX KAC,R7\n***********************************************************************\n*                                                                     *\n*    Code to setup a PC routine - must run in supervisor state.       *\n*                                                                     *\n***********************************************************************\n         LA    R1,4                     Check if authorized\n         LNR   R1,R1                    Make conditional\n         QCALL AUTHFUNC\n         LTR   R15,R15                  Are we authorized\n         BNZ   II$NKAC                  Nope cant use incore\n*%%% AUTHFUNC needs an option to do the following:\n         MODESET KEY=ZERO,MODE=SUP      Get key=0\n         TM    KACFLAG1,KAC1BADC+KAC1GONE\n         BNZ   II$NKAC1                 No good in core copy\n         TM    KACFLAG1,KAC1ECSA        In CSA\n         BZ    II$NKAC1                 No good in core copy\n         ST    R7,QKACA                 save address of KAC\n*   GET A NON-SYSTEM LX\n         LA    R2,1\n         ST    R2,QPCLXCNT              REQUEST 1 LX\n         SPACE 2\nII$GLX   LXRES LXLIST=QPCLXL,RELATED=(II$FRLX,II$CONET)\n         SPACE 3\n*   CREATE PC ROUTINES\n         L     R2,=V(CKPT$PC)           get address\n          AIF   (&QLEVEL GE 9).IIPC3A\n*\n**       Build ET entry list\n*\n         LA    R3,QPCDESC               Point at list\n         USNGX ETD,R3\n         MVC   ETDNUM,=H'1'             Set number of elements\n         LA    R3,ETDEND                Point at first element\n         DROPX R3\n         USNGX ETDELE,R3\n         MVI   ETDEX,0                  Set index number\n         MVI   ETDFLG,ETDSUP            Set flags\n         ST    R2,ETDPRO2               Set address of routine\n         OI    ETDPRO2,ETDAMODE         Set entry to 31 bit\n         MVC   ETDAKM(4),=X'FFFFFFFF'   Set valid keys\n         ST    R11,ETDPAR               Set latent parameter\n         DROPX R3\n          AGO   .IIPC3B\n.IIPC3A   ANOP\n         ETDEF TYPE=SET,ETEADR=QPCETD1,ROUTINE=(2),SSWITCH=NO,         $\n               PARM1=(R11),                                            $\n               STATE=SUPERVISOR,AKM=(0:15),EKM=(0:15),EK=0,PKM=OR\n.IIPC3B   ANOP\nII$CET1  ETCRE ENTRIES=QPCDESC,                                        $\n               RELATED=(II$CONET,II$DISET,II$DESET)\n*\n         ST    R0,QPCTKVAL              SAVE RETURNED TOKEN\n         SPACE 3\n*  CREATE PC NUMBERS\n         L     R2,QPCLXVAL              LX = PC# WITH EX OF 0\n         LA    R2,0(,R2)                CONSTRUCT EX=0 PC#\n         ST    R2,QPCCKPT               SAVE NUMBER\n*        LA    R2,1(,R2)                CONSTRUCT EX=1 PC#\n*        ST    R2,SERV2PC               SAVE NUMBER\n         SPACE 3\n*   ESTABLISH ACCESS\n         LA    R2,1\n         ST    R2,QPCTKCNT              SET COUNT OF ETS TO CONN\n*\nII$CONET ETCON TKLIST=QPCTKL,LXLIST=QPCLXL,                            $\n               RELATED=(II$GLX,II$CET1)\n***********************************************************************\n*                                                                     *\n*   Now compute some values and go to normal                          *\n*                                                                     *\n***********************************************************************\n         OI    QKFLAG,QKFKAC            indicate good KAC\n         L     R1,KACCLEN               get length of copy\n         A     R1,KACCKPTA               less\n         S     R1,KACMSTRA                 length of master rcd\n         ST    R1,QCKMLEN               save length of incore\n         DROPX R7                       KAC\nII$NKAC1 DS    0H\n         MODESET KEY=NZERO,MODE=PROB    Out of supervisor state\n         LA    R1,8                     release authorization\n         QCALL AUTHFUNC\nII$NKAC  DS    0H\n.IINOPC   ANOP\n         EJECT\n***********************************************************************\n*                                                                     *\n*   SEE IF SPF DIALOG INTERFACE MODULE IS AVAILABLE                   *\n*                                                                     *\n***********************************************************************\n          AIF   (&@@ISPF LT 230).IINIS1 skip if no ISPQRY\n         CLC   ISPLNK,=F'0'             do we have ISPLINK address?\n         BE    II$ISQRY                 no - go query ISPF\n         OI    II@FLAGS,II@ISPF         yes - remember\n         B     II$ISPGO                 skip ISPQRY\n         SPACE 2\nII$ISQRY LINK  EP=ISPQRY                check ISPF environment\n*\n         LTR   R15,R15                  valid ISPF environment?\n         BNZ   II$NOSPF                 no - skip\n         OI    II@FLAGS,II@ISPF         yes - remember\n         OI    QISFLAG1,QIS1ISPF        set called from ISPF flag\n*\n         LOAD  EPLOC==CL8'ISPLINK'      find interface module\n*\n         ST    R0,ISPLNK                save address\n*\n          AGO   .IIXIS1\n.IINIS1   ANOP\n         TM    II@FLAGS,II@ISPF         WAS PARM=ISPF GIVEN?\n         BNO   II$NOSPF                 NO - DON'T EVEN TRY\n         L     R3,CVTPTR                -> CVT\n         LM    R0,R1,=CL8'ISPLINK'      CL8'ISPLINK'\n         L     R15,CVTLPDSR-CVTMAP(,R3) -> LPA SEARCH ROUTINE\n         STM   R2,R11,II@REGS           save some regs\n         BALR  R14,R15                  CALL IT\n         B     II$ISPLP                 +0 ==> FOUND IN LPA\n*                                       +4 ==> NOT FOUND\n         LM    R2,R11,II@REGS           reload regs after LPA search\n*---  DO BLDL FOR ISPLINK, TO AVOID TACKY 806 MESSAGE IF SPF IS    ---*\n*---  NOT INSTALLED                                                ---*\n         MVC   II@BLDL(4),=H'1,12'      SET NUMBER, LENGTH\n         MVC   II@BLDLN,=CL8'ISPLINK'   SET MEMBER NAME\n         SPACE 1\n         BLDL  0,II@BLDL                TRY TO FIND ISPLINK\n         SPACE 1\n         LTR   R15,R15                  IS IT AVAILABLE?\n         BNZ   II$NOSPF                 NO - SKIP\n*\n         LOAD  DE=II@BLDL+4             load ISPLINK\n*\n         ST    R0,ISPLNK                save address\n         B     II$ISPGO                 continue\n         SPACE 2\nII$ISPLP LM    R2,R11,II@REGS           reload regs after LPA search\n*\n         LOAD  EPLOC==CL8'ISPLINK'      ask MVS where it is\n*\n         ST    R0,ISPLNK                save address\n.IIXIS1   ANOP\n         SPACE 2\nII$ISPGO MVC   II@VLEN,=F'32'           set area length\n         L     R15,ISPLNK               get address\n         CALL  (15),(=CL8'VCOPY',=CL8'(ZENVIR)',II@VLEN,QPFIND,        $\n               =CL8'MOVE'),VL,                                         $\n               MF=(E,II@CALLP)\n         LTR   R15,R15                  is var defined and no trunc?\n         BZ    SP23A1       >========+  yes, so check version\n         CH    R15,=H'16'            |  did trunc occur?\n         BNE   II$XXSPF              |  no, so not found\nSP23A1   CLC   QPFIND(4),=C'ISPF'  <=+  does variable look ok?\n         BNE   II$XXSPF                 no - assume old ISPF\n         CLC   QPFIND+5(3),=C'2.3'      is envir ISPF 2.3 or higher?\n         BL    II$XXSPF                 no - is prior to version 2.3\n         OI    QISFLAG1,QIS1V23         yes - remember version 2.3\n         CLC   QPFIND+5(3),=C'3.2'      is envir ISPF 3.2 or higher?\n         BL    II$XXSPF                 no - is prior to version 3.2\n         OI    QISFLAG1,QIS1V32         yes - remember version 3.2\n         SPACE 2\nII$XXSPF CLC   BRWEPARM,=F'0'           do we have TLD address?\n         BNE   II$NOSPF                 yes - ok\n         TM    QISFLAG1,QIS1V32         no - do we need it?\n         BNZ   II$NOSPF                 no - ok\n         MVI   QISFLAG1,0               yes - can't use ISPF interface\n         SPACE 1\n         DROPX R15,R14                  SSCT, SSVT\n***********************************************************************\n*                                                                     *\n*   Load OACFSORT quicksort routine                                   *\n*                                                                     *\n***********************************************************************\nII$NOSPF DC    0H'0'\n          AIF   ('&@@OACFS' EQ '').II080\n         LOAD  EPLOC==CL8'&@@OACFS',ERRET=II$806  load sort routine\n         ST    R0,QVSORT                save ptr to sort\n.II080    ANOP\n         B     II$BLKTB                 continue\n         SPACE 1\nII$806   L     R1,=A(II#MSG10)          -> msg\n         TPUT  (1),L'II#MSG10           output it\n         ABEND 90                       die\n***********************************************************************\n*                                                                     *\n*   Obtain Block tables for LISTDS, and DDNAME                        *\n*                                                                     *\n***********************************************************************\nII$BLKTB L     R0,QCSIZE                GET TABLE SIZE\n         SPACE 1\n         GETMAIN  RC,LV=(0),SP=1        TRY TO GET BLOCK ADDR TABLE\n         SPACE 1\n         LTR   R15,R15                  DID I GET IT?\n         BNZ   II$SMALL                 NO - COMPLAIN AND LEAVE NO DUMP\n         ST    R1,QCSTART               STORE STARTING ADDR OF TABLE\n         L     R0,QDSIZE                GET TABLE SIZE\n         SPACE 1\n         GETMAIN  RC,LV=(0),SP=1        TRY TO GET BLOCK ADDR TABLE\n         SPACE 1\n         LTR   R15,R15                  DID I GET IT?\n         BNZ   II$SMALL                 NO - COMPLAIN AND LEAVE NO DUMP\n         ST    R1,QDSTART               STORE STARTING ADDR OF TABLE\n***********************************************************************\n*                                                                     *\n*   ALLOCATE HASPCKPT                                                 *\n*                                                                     *\n***********************************************************************\n         MVC   QDSNSPC+2(16),QBLANK     CLEAR DSN\n         MVC   QDSNCKPT+2(17),QBLANK    CLEAR DSN\n         LA    R1,QCKPTPFX              -> PREFIX\n         LA    R14,QDSNSPC+2            -> DEST\n         LA    R15,QDSNCKPT+2           -> DEST\n         LA    R0,44                    MAX NUMBER OF CHARS TO MOVE\n         SPACE 1\nII$MVPFX MVC   0(1,R14),0(R1)           MOVE 1 CHAR OF PREFIX\n         MVC   0(1,R15),0(R1)           ...\n         LA    R14,1(,R14)              BUMP PTR\n         LA    R15,1(,R15)              ...\n         LA    R1,1(,R1)                -> NEXT CHAR OF PREFIX\n         CLI   0(R1),C' '               END OF PREFIX?\n         BH    II$MVPFX                 NO - CONTINUE\n***      MVC   0(8,R14),=C'.HASPACE'    FINISH DSN\n         MVC   0(L'II#HSSFX,R14),II#HSSFX  FINISH DSN\n***      MVC   0(9,R15),=C'.HASPCKPT'   ...\n         MVC   0(L'II#CKSFX,R15),II#CKSFX  ...\n***      LA    R14,QDSNCKPT+2-9         COMPUTE LENGTH ...\n***      SR    R15,R14                  ... OF HASPCKPT DSN\n***      STH   R15,QDSNCKPT             SAVE FOR DAIR\n***      BCTR  R15,0                    COMPUTE LENGTH OF HASPACE DSN\n***      STH   R15,QDSNSPC              SAVE FOR DAIR\n         MVC   QDSNCKPT,=H'44'          tell DAIR the length\n         MVC   QDSNSPC,=H'44'           ...\n         SPACE 1\n         MVC   DA08SER(6),QCKPTVOL      MOVE IN HASPCKPT VOLSER\n         LA    R15,QDSNCKPT             -> DSNAME FOR ALLOCATE\n         ST    R15,DA08PDSN             SET IN DAIR BLOCK\n         MVI   DAIRFLAG,X'08'           REQUEST ALLOCATE FUNCTION\n          AIF   (&QLEVEL LT 8).II50A\n***%%%   TM    QKFLAG,QKFKAC            Doing incore\n***%%%   BO    II$KMST                  Yes so skip alloc\n.II50A    ANOP\n         QCALL ALLOCATE                 CALL DAIR\n***********************************************************************\n*                                                                     *\n*   OPEN HASPCKPT, READ FIRST BLOCK OF CHECKPOINT                     *\n*                                                                     *\n***********************************************************************\n         L     R3,QCCKPT                -> HASPCKPT DCB\n         USNGX IHADCB,R3\n          AIF   (&QLEVEL LT 4).II090\n         DEVTYPE  DA08DDN,DVAREA,DEVTAB,RPS  GET DEVICE TYPE INFO\n         SPACE 1\n         L     R0,DVAMAXRC              MAX BLKSIZE FOR DEVICE\n         STH   R0,DCBBLKSI              SET BLKSIZE IN CKPT DCB\n.II090    ANOP\n         MVC   DCBDDNAM,DA08DDN         GET DDNAME DAIR RETURNED\n         LA    R1,II#EXLST              -> DCB EXIT LIST\n         STCM  R1,B'0111',DCBEXLSA      SET INTO DCB\n         BAL   R14,QAMODE24             change to AMODE 24\n         SPACE 1\n         OPEN  MF=(E,QCCKPT)            OPEN HASPCKPT\n         SPACE 1\n         BAL   R14,QAMODE31             resume AMODE 31\n*  IT MIGHT BE NICE TO CHECK TO SEE THAT IT OPENED!!!!\n          AIF   (&QLEVEL LT 4).II110\n          AIF   (&QLEVEL LT 8).II100\n         SPACE 1\n*\n*        FORMAT OF CHECKPOINT MASTER RECORD\n*        $SAVEBEG - START OF HCT AREA\n*                   ($SAVELEN LONG)\n*        QSE1     - START OF QSE AREA\n*                   (QSELEN*$QSEMAX)\n*        $JQEEXT  - START OF JQE EXTENSION\n*                   ($MAXEXSZ)\n*        $DASEXT  - START OF DAS EXTENSIONS\n*                   (DASEXLEN*$SPOLNUM)\n*        $KITPTR  - POINTER TO CHECKPOINT INFO TABLES\n*                   ($KITNUM*KITLNGTH)\n*        $CTLB    - POINTER TO CHECKPT I/O CONTROL BYTES\n*\n         SPACE 1\n.II100    ANOP\n**??**?? LA    R2,DVATAB                -> DEVTYPE INFO FOR TRKCALC\n         SR    R2,R2                    CLEAR FOR ICM\n         ICM   R2,B'0111',DCBDVTBA      -> DEVTYPE INFO\n         L     R4,=X'01001000'          # OF 4K BLOCKS/TRK\n         XC    II@TRKCA(II@TRKCL),II@TRKCA  CLEAR MF=L AREA\n         SPACE 1\n         TRKCALC  FUNCTN=TRKCAP,DEVTAB=(R2),RKDD=(R4),REGSAVE=YES,     $\n               MF=(E,II@TRKCA)\n         SPACE 1\n         ST    R0,II@CKRT               SAVE # 4K BLKS/TRK ON CKPT\n.II110    ANOP\n         SPACE 1\n*---  GETMAIN DECB WORK AREA FOR CKPT ROUTINE                      ---*\n         SR    R0,R0                    CLEAR FOR IC\n         IC    R0,DCBNCP                GET NCP VALUE FROM DCB\n*%%%     LTR   R0,R0                    ANYTHING THERE?\n*%%%     BNZ   *+8                      YES - USE IT\n*%%%     LA    R0,&@@QCKNC              NO - USE GENNED DEFAULT VALUE\n         MH    R0,=Y(HDECB1L)           * LENGTH OF EACH DECB\n         ST    R0,QLCKDECB              SAVE LENGTH FOR FREEMAIN\n         ICM   R0,B'1000',=AL1(1)       SUBPOOL 1\n         GETMAIN  R,LV=(0)\n         ST    R1,QVCKDECB              SAVE ADDR (ALSO FOR FREEMAIN)\n         TM    QKFLAG,QKFKAC            Doing incore?\n         BO    II$KMST                  yes - skip disk READ\n         BAL   R14,QAMODE24             change to AMODE 24\n         SPACE 1\n         POINT (R3),=FS8'3'             POINT PAST SYNC RECORDS TO REC3\n         SPACE 1\n         L     R1,QCDECB1               -> HASPCKPT DECB\n         L     R2,QCSTART               USE TABLE AREA FOR IOAREA\n         SPACE 1\n         READ  (1),SF,,(R2),MF=E        READ FIRST RECORD\n         SPACE 1\n         L     R1,QCDECB1               -> HASPCKPT DECB\n         SPACE 1\n         CHECK (1)\n         SPACE 1\n         BAL   R14,QAMODE31             resume AMODE 31\n         SPACE 3\n         DROPX R3                       IHADCB\n         USNGX $SAVEBEG,R2              BASE REG FOR CHECKPOINT\n          AIF   (&QLEVEL LT 7).II120    %%%\n          AIF   (&QLEVEL LT 8).II50B\n         B     II$KMSTE                 skip over if using DASD\n*\n*\n*\nII$KMST  DS    0H                       Get Master from incore\n         LA    R1,4                     Get authorized\n         QCALL AUTHFUNC\n         MODESET KEY=ZERO,MODE=SUP      Get key=0\n         L     R2,QCSTART               get temp area\n         L     R3,QCKMLEN               get length\n         L     R1,QKACA                 get KAC address\n         L     R0,KACMSTRA-KAC(,R1)     get master record\n         LR    R1,R3\n         MVCL  R2,R0                    move in master\n         MODESET KEY=NZERO,MODE=PROB    Out of supervisor state\n         LA    R1,8                     release authorization\n         QCALL AUTHFUNC\n         L     R2,QCSTART               reload table area for mstr\nII$KMSTE DS    0H\n.II50B    ANOP\n         MVC   QCJQELEN,$JQELEN         SAVE JQE LENGTH\n          AGO   .II130                  %%%\n.II120    ANOP\n         MVC   QCJQELEN,=Y(JQELNGTH)    SET JQE LENGTH\n.II130    ANOP\n          AIF   (&QLEVEL LT 4).II140\n         MVC   QCLNODE,$NODEID          SAVE OUR LOCAL NODE NUMBER\n.II140    ANOP\n         CLC   =C'JES2',$HASPID         ID IN CORRECT PLACE?\n         BE    II$HIDOK                 YES - CONTINUE\n         L     R1,=A(II#MSG9)           -> MSG TEXT\n         TPUT  (1),L'II#MSG9            'WRONG VERSION'\n         ABEND 91\nII$HIDOK DC    0H'0'\n          AIF   (&QLEVEL LT 8).II150\n***********************************************************************\n*                                                                     *\n*   Compute size of track group maps on ckpt                          *\n*                                                                     *\n***********************************************************************\n         L     R5,$NUMTG                NUMBER OF TRACK GROUPS TOTAL\n         LA    R5,7(,R5)                round up!!                *LDW*\n         SRL   R5,3                     DIVIDE BY 8\n         LR    R1,R5                    SAVE LENGTH OF TRACK GROUP MAP\n         SLL   R1,1                     NUMBER OF BYTES * 2\n         LA    R1,BFPLEN(,R1)           ADD BUFFER PREFIX\n         LA    R1,4095(,R1)             PREPARE TO ROUND\n         SRL   R1,12                    DIVIDE BY 4K\n         STH   R1,QCTGML                NUMBER OF BLOCKS FOR TG MAPS\n          AGO   .II250\n.II150    ANOP\n***********************************************************************\n*                                                                     *\n*   COMPUTE OFFSET TO FIRST PDDB IN IOT                               *\n*                                                                     *\n***********************************************************************\n          AIF   (&QLEVEL GE 4).II160\n         LH    R5,$NUMTGV               NUMBER OF TRK GROUPS PER VOLUME\n         LA    R5,7(,R5)                ROUND UP TO MULTIPLE OF 8\n         SRL   R5,3                     DIVIDE BY 8\n         SR    R0,R0                    CLEAR FOR IC\n         IC    R0,$NUMDA                NUMBER OF SPOOL VOLUMES\n         MR    R4,R0                    LENGTH OF TRK GROUP MAP IN R5\n         MH    R0,$NUMTGV               * number of trk grps/vol\n         ST    R0,QCNUMTGA              save for later\n          AGO   .II170\n.II160    ANOP\n         LH    R5,$NUMTG                NUMBER OF TRK GROUPS PER VOLUME\n         LA    R5,7(,R5)                ROUND UP TO MULTIPLE OF 8\n         SRL   R5,3                     DIVIDE BY 8\n.II170    ANOP\n         STH   R5,QCTGMLEN              SAVE LENGTH OF TRACK GROUP MAP\n          AIF   (&QLEVEL GE 5).II180\n         LA    R5,IOTTGMAP-IOTSTART+TGMAP-TGMDSECT+3(,R5)   OFFSET\n         N     R5,=F'-4'                ROUND TO FULL WORD BOUNDARY\n         ST    R5,QCPDDB1               SAVE OFFSET TO 1ST PDDB IN IOT\n         SPACE 1\n          AIF   (&QLEVEL LT 4).II240\n         LH    R0,$NUMTG                GET TOTAL NUMBER OF TRK GROUPS\n         ST    R0,QCNUMTGA              SAVE AS NUMBER OF ACT TRK GRPS\n         SPACE 1\n.II180    ANOP\n***********************************************************************\n*                                                                     *\n*   COMPUTE SIZE OF DAS AREA ON CHECKPOINT                            *\n*                                                                     *\n***********************************************************************\n          AIF   (&QLEVEL LT 7).II190\n         LH    R15,$SPOLNUM             NUMBER OF SPOOL VOLUMES\n         MH    R15,=Y(DASSIZ)           * SIZE OF EACH DAS\n         QCBLKNUM  R15                  COMPUTE NUMBER OF CKPT RECORDS\n         ST    R15,QCDASL               SAVE # OF BLOCKS FOR DAS\n         L     R1,$NUMTG                NUMBER OF TRK GRPS PER VOLUME\n         SRL   R1,3                     DIVIDE BY 8 = LEN OF TG MAP\n.II190    ANOP\n***********************************************************************\n*                                                                     *\n*   COMPUTE NUMBER OF TRACK GROUP MAPS ON CKPT                        *\n*                                                                     *\n***********************************************************************\n          AIF   (&QLEVEL GE 7).II200\n         LH    R1,QCTGMLEN              GET LENGTH OF TRACK GROUP MAP\n.II200    ANOP\n         AR    R1,R1                    NUMBER OF BYTES * 2\n         QCBLKNUM  R1                   COMPUTE NUMBER OF CKPT RECORDS\n         STH   R1,QCTGML                NUMBER OF BLOCKS FOR TG MAPS\n*%%II%%1  ANOP\n***********************************************************************\n*                                                                     *\n*   COMPUTE NUMBER OF JIX BLOCKS ON CKPT                              *\n*                                                                     *\n***********************************************************************\n         LH    R5,$NUMJBNO              NUMBER OF JOB NUMBERS\n         LA    R5,1(,R5)                PLUS 1 FOR HEADER\n         AR    R5,R5                    TIMES LENGTH OF 2\n         QCBLKNUM  R5                   COMPUTE NUMBER OF CKPT RECORDS\n         STH   R5,QCJIXL                NUMBER OF BLOCKS FOR JIX\n***********************************************************************\n*                                                                     *\n*   FIND KIT AREA IN MASTER RECORD                                    *\n*                                                                     *\n***********************************************************************\n          AIF   (&QLEVEL GT 4).II210\n         L     R3,$MASTERL              LENGTH OF MASTER RECORD\n         AR    R3,R2                    -> PAST END OF MASTER RECORD\n         SH    R3,=Y(KITLNGTH)          -> LAST KIT\n         ST    R3,II@KITL               SAVE ADDR OF LAST KIT\n         USNGX KITDSECT,R3\nII$KIT1L CLC   KITORG,=F'0'             THIS FIRST KIT?\n         BE    II$KIT1F\n         SH    R3,=Y(KITLNGTH)          BACK UP ONE KIT\n         B     II$KIT1L\n         DROPX R3                       KITDSECT\nII$KIT1F ST    R3,II@KITF               SAVE ADDR FIRST KIT\n          AGO   .II230\n.II210   ANOP\n*  REFERENCE HASPIRDA\n          AIF   (&QLEVEL GE 7).II220\n         LA    R1,$SAVELEN(,R2)         -> FIRST QSE\n         LA    R0,QSELEN                LENGTH OF A QSE\n         MH    R0,$QSENO                TOTAL FOR ALL SYSTEMS\n         AR    R1,R0                    -> FIRST DAS\n         A     R1,=A(DASSIZ*$MAXDA)     -> FIRST KIT\n         ST    R1,II@KITF               SAVE ADDR FIRST KIT\n         AH    R1,=Y(KITLNGTH*(7-1))    -> LAST KIT   *KLUDGE*?\n         ST    R1,II@KITL               SAVE ADDR LAST KIT\n          AGO   .II230\n.II220    ANOP\n         LA    R1,$SAVELEN(,R2)         -> FIRST QSE\n         LA    R0,QSELEN                LENGTH OF A QSE\n         MH    R0,$QSENO                TOTAL FOR ALL SYSTEMS\n         AR    R1,R0                    -> JQE EXTENSION AREA\n         AH    R1,$MAXEXSZ              -> FIRST KIT\n         ST    R1,II@KITF               SAVE ADDR FIRST KIT\n         AH    R1,=Y(KITLNGTH*(8-1))    -> LAST KIT   *KLUDGE*?\n         ST    R1,II@KITL               SAVE ADDR LAST KIT\n.II230    ANOP\n         SPACE 1\n*---  FIND JQE TABLE BLOCK #; # OF BLOCKS                          ---*\n         L     R0,=CL4'JQE '            ID FOR JQE'S\n         BAL   R14,II$KITFD             SEARCH KIT FOR JQE SLOT\n         EX    0,*                      DIE IF SYSTEM HAS NO JQE'S\n         USNGX KITDSECT,R1\n         LH    R6,KITRECN               # OF BLOCKS OF JOE'S\n         ST    R6,QCJQENUM              SAVE # BLOCKS OF JQE'S\n         BAL   R14,II$CKTTR             COMPUTE TTR OF JQE'S\n         DROPX R1                       KITDSECT\n         ST    R1,QCJQETTR              SAVE TTR OF JQE'S\n         SPACE 1\n*---  FIND JOE TABLE BLOCK #; # OF BLOCKS                          ---*\n         L     R0,=CL4'JOE '            ID FOR JOE'S\n         BAL   R14,II$KITFD             SEARCH KIT FOR JQE SLOT\n         EX    0,*                      DIE IF SYSTEM HAS NO JQE'S\n         USNGX KITDSECT,R1\n         LH    R3,KITRECN               # OF BLOCKS OF JOE'S\n         ST    R3,QCJOENUM              SAVE # OF BLOCKS OF JOE'S\n         BAL   R14,II$CKTTR             COMPUTE TTR OF JOE'S\n         DROPX R1                       KITDSECT\n         ST    R1,QCJOETTR              SAVE TTR OF JOE'S\n         SPACE 1\n*%%%%%%%  AIF   (&QLEVEL LT 5).II%%2\n.II240    ANOP\n.II250    ANOP\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*   OBTAIN SYSTEM ID'S FROM QSE'S                                     *\n*                                                                     *\n***********************************************************************\n         LA    R15,$SAVEEND             -> FIRST QSE\n         USNGX QSEDSECT,R15\n         LA    R14,QSMFID               -> SYSTEM ID TABLE ZERO'TH ENT\n         LH    R0,$QSENO                NUMBER OF MEMBERS IN THIS NODE\n         SPACE 1\nII$QSELP LA    R14,L'QSMFID(,R14)       -> NEXT SYSTEM ID TABLE ENTRY\n         MVC   0(4,R14),QSESID          SAVE SYSTEM ID\n         LA    R15,QSELEN(,R15)         -> NEXT QSE\n         BCT   R0,II$QSELP              DO ALL QSE'S\n         DROPX R15                      QSEDSECT\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*   TRANSLATE SMF ID'S TO USER FRIENDLY NAMES                         *\n*                                                                     *\n***********************************************************************\n         MVC   QSYSID(L'QSYSID*8),QSMFID  COPY THE WHOLE TABLE\n         LA    R0,8                     NUMBER OF TABLE ENTRIES\n         LA    R14,QSYSID               -> FIRST ONE\nII$QSEL2 LA    R15,SMFTABLE             -> TRANSLATION TABLE\nII$QSEL3 CLI   0(R15),X'FF'             END OF TABLE?\n         BE    II$QSEN2                 YES - GIVE UP AND TRY NEXT ID\n         CLC   0(4,R14),0(R15)          THIS IT?\n         BNE   II$QSEN1                 NO - TRY NEXT TRANS TABLE ENTRY\n         MVC   0(4,R14),4(R15)          YES - USE USER FRIENDLY NAME\n         B     II$QSEN2                 AND PROCESS NEXT ID\nII$QSEN1 LA    R15,8(,R15)              -> NEXT TRANSLATION TABLE ENTRY\n         B     II$QSEL3                 KEEP LOOKING\nII$QSEN2 LA    R14,L'QSYSID(,R14)       -> NEXT SMF ID TO TRANSLATE\n         BCT   R0,II$QSEL2              DO IT\n         SPACE 1\n          AIF   (&QLEVEL GE 8).II310\n***********************************************************************\n*                                                                     *\n*   COMPUTE NUMBER OF JQE BLOCKS ON CKPT                              *\n*                                                                     *\n***********************************************************************\n         LH    R6,$MAXJOBS              NUMBER OF JQES\n         LA    R6,1(,R6)                PLUS 1 FOR EYE-CATCHER\n          AIF   (&QLEVEL GE 7).II260\n         MH    R6,=AL2(JQELNGTH)        MULTIPLY BY LENGTH OF JQE\n         QCBLKNUM  R6                   COMPUTE NUMBER OF CKPT RECORDS\n          AGO   .II270\n.II260    ANOP\n         MH    R6,=Y(JQEBLEN+4)         MULTIPLY BY LENGTH OF JQE\n*                                       ... ASSUMING 1 WORD FOR ...\n*                                       ... SPOOLS USED MASK %%%%%\n         QCBLKNUM  R6                   COMPUTE NUMBER OF CKPT RECORDS\n***********************************************************************\n*                                                                     *\n*   COMPUTE NUMBER OF PST BLOCKS IN CKPT                              *\n*                                                                     *\n***********************************************************************\n         LH    R15,$NUMJOES             NUMBER OF JOES\n         QCBLKNUM  R15                  COMPUTE NUMBER OF CKPT RECORDS\n         ST    R15,QCPSTL               SAVE                          \u00a2\n.II270    ANOP\n***********************************************************************\n*                                                                     *\n*   COMPUTE NUMBER OF JOT BLOCKS IN CKPT                              *\n*                                                                     *\n***********************************************************************\n         LH    R3,$NUMJOES              NUMBER OF JOES\n*  I THINK CL DID THIS WRONG... <LDW>   %%%%\n*%%       AIF   (&QLEVEL LT 7).II280\n*%%      LA    R3,NJOTPRFX(,R3)         ADJUSTED LENGTH OF JOT PREFIX\n.II280    ANOP\n         MH    R3,=AL2(JOESIZE)         MULTIPLY BY LENGTH OF JOE\n*  CL DIDN'T HAVE THIS INSTRUCTION:     %%%%\n         LA    R3,JOTJOES-JOTDSECT(,R3) ADD LENGTH OF JOT PREFIX AREA\n         QCBLKNUM  R3                   COMPUTE NUMBER OF CKPT RECORDS\n***********************************************************************\n*                                                                     *\n*   COMPUTE TOTAL LENGTH OF QSES                                      *\n*                                                                     *\n***********************************************************************\n         LA    R4,QSELEN                QSE LENGTH\n         MH    R4,$QSEMAX               LENGTH TIMES NUMBER OF QSES\n          AIF   (&QLEVEL GE 5).II300\n          AIF   (&QLEVEL LT 4).II290\n         ALR   R4,R5                    ADD ONE BYTE FOR EACH JIX BLOCK\n***********************************************************************\n*                                                                     *\n*   COMPUTE NUMBER OF MSQ BLOCKS ON CKPT                              *\n*                                                                     *\n***********************************************************************\n         LH    R1,$NUMRJE               NUMBER OF REMOTES\n         MH    R1,=Y(3)                 TIMES LENGTH OF 3\n         LA    R1,3(,R1)                PLUS HEADER LENGTH\n         LA    R1,4095(,R1)             PREPARE TO ROUND\n         SRL   R1,12                    DIVIDE BY 4096\n         ALR   R4,R1                    ADD 1 BYTE FOR EACH BLOCK\n***********************************************************************\n*                                                                     *\n*   COMPUTE NUMBER OF RSO BLOCKS ON CKPT                              *\n*                                                                     *\n***********************************************************************\n         LH    R1,$NUMRJE               NUMBER OF REMOTES\n         LA    R1,4095(,R1)             PREPARE TO ROUND\n         SRL   R1,12                    DIVIDE BY 4096\n         ALR   R4,R1                    ADD 1 BYTE FOR EACH BLOCK\n***********************************************************************\n*                                                                     *\n*   COMPUTE NUMBER OF LCK BLOCKS ON CKPT                              *\n*                                                                     *\n***********************************************************************\n*%%%%%   LH    R1,$NUMLCK               NUMBER OF LOAD CKPT ELEMENTS\n         LA    R1,9*7                   NUMBER OF LOAD CKPT ELEMENTS\n         MH    R1,=Y(LCKSIZE)           TIMES LENGTH OF EACH\n         LA    R1,4095(,R1)             PREPARE TO ROUND\n         SRL   R1,12                    DIVIDE BY 4096\n         ALR   R4,R1                    ADD 1 BYTE FOR EACH BLOCK\n.II290    ANOP\n         ALR   R4,R6                    ADD ONE BYTE FOR EACH JQE BLOCK\n         ALR   R4,R3                    ADD ONE BYTE FOR EACH JOT BLOCK\n.II300    ANOP\n.II310    ANOP\n***********************************************************************\n*                                                                     *\n*   COMPUTE HASPACE BUFFER SIZE                                       *\n*                                                                     *\n***********************************************************************\n         LH    R5,$BUFSIZE              BLKSIZE FOR HASPACE\n         L     R1,QCDECB2               -> HASPACE DECB\n         STH   R5,6(,R1)                STORE IN DECB\n         STH   R5,QCHSBLK               SAVE IN QCOMMON\n         LA    R5,63(,R5)               PREPARE TO ROUND\n         N     R5,=F'-64'               ROUND TO 64 BYTE BOUNDARY\n***********************************************************************\n*                                                                     *\n*   OBTAIN BUFFERS FOR HASPCKPT AND HASPACE                           *\n*                                                                     *\n***********************************************************************\n         LR    R14,R5                   HASPACE BUFFER SIZE\n         MH    R14,=H'3'                3 BUFFERS\n          AIF   (&QLEVEL GE 8).II330\n         LA    R1,1(R6,R3)              NUMBER OF BLOCKS IN CKPT DS\n          AIF   (&QLEVEL LT 4).II320\n         AH    R1,QCJIXL                ADD NUMBER OF JIX BLOCKS\n          AIF   (&QLEVEL LT 5).II320\n         AH    R1,QCTGML                ADD NUMBER OF TGM BLOCKS\n          AIF   (&QLEVEL LT 7).II320\n         A     R1,QCDASL                ADD NUMBER OF DAS BLOCKS      \u00a2\n         A     R1,QCPSTL                ADD NUMBER OF PST BLOCKS      \u00a2\n.II320    ANOP\n          AGO   .II340\n.II330    ANOP\n         LH    R1,$CKRECN               number of 4K records\n         LA    R1,1(,R1)                plus master record\n         AH    R1,$CLRECN               plus number of change log recs\n.II340    ANOP\n         ST    R1,QCJOTL                STORE RECORD COUNT\n         SLL   R1,12                    MULTIPLY BY 4096\n          AIF   (&QLEVEL LT 4).II350\n         L     R15,$MASTERL             GET LENGTH OF MASTER RECORD\n         LA    R15,4095(,R15)           PREPARE TO ROUND\n         SRL   R15,12                   ROUND TO 4K\n         SLL   R15,12                   GET BACK AS MULT OF 4K\n         ST    R15,QCSMLEN              SAVE FOR LATER\n         AR    R1,R15    %%%???%%%      INCREMENT SIZE TO GETMAIN     \u00a2\n          AGO   .II360\n.II350    ANOP\n         MVC   QCSMLEN,=F'4096'         SET MASTER RECORD LENGTH\n.II360    ANOP\n         LA    R7,256(R1,R14)           ADD CKPT & HASPACE BFRS, SLOP\n         ST    R7,QCKPTLEN              SAVE LENGTH FOR FREEMAIN\n         GETMAIN  RU,LV=(R7),SP=1       OBTAIN BUFFERS\n         ST    R1,QCJQTL                BUFFER FOR FIRST CKPT REC\n          AIF   (&QLEVEL LT 8).II370\n         QCALL CKPT                     read ckpt data\n         L     R1,QCJQTL                restore buffer address\n         LA    R4,QSELEN                QSE length\n         MH    R4,$QSEMAX               * number of QSEs\n.II370    ANOP\n          AIF   (&QLEVEL LT 7).II380\n         LR    R14,R1                   COMPUTE ADDR OF JQE EXTENSION\n         LA    R14,$SAVELEN(,R14)       ACCOUNT FOR CHECKPOINTED HCT\n         AR    R14,R4                   ACCOUNT FOR QSE'S\n         ST    R14,QCJQEXA              SAVE ADDR OF JQE EXTENSION\n.II380    ANOP\n          AIF   (&QLEVEL GT 3).II390\n         AH    R1,=H'4096'              INCREMENT\n          AGO   .II460\n.II390    ANOP\n         A     R1,QCSMLEN               ADD ROUNDED LENGTH OF MSTR REC\n          AIF   (&QLEVEL LT 8).II400\n*%%%     TM    QKFLAG,QKFKAC            If incore - no change blks\n*%%%     BO    II$NOCKB\n         LH    R15,$CLRECN              number of change log blks\n         SLL   R15,12                   * 4k\n         AR    R1,R15                   bump past change log\nII$NOCKB DS    0H\n*---\n         LA    R15,=CL4'TGM'            -> pool id\n         BAL   R14,II$CK$PI             check pool id\n         ST    R0,QCTGMA                buffer for TGM blocks\n*---\n         LA    R15,=CL4'JIX'            -> pool id\n         BAL   R14,II$CK$PI             check pool id\n         ST    R0,QCJIXA                buffer for JIX blocks\n*---\n         LA    R15,=CL4'JQE'            -> pool id\n         BAL   R14,II$CK$PI             check pool id\n         ST    R0,QCJQTA                buffer for JQE blocks\n*---\n         LA    R15,=CL4'PST'            -> pool id\n         BAL   R14,II$CK$PI             check pool id\n         ST    R0,QCPSTA                buffer for PST blocks\n*---\n         LA    R15,=CL4'JOE'            -> pool id\n         BAL   R14,II$CK$PI             check pool id\n         ST    R0,QCJOTA                buffer for JOE blocks\n*---\n         LA    R15,=CL4'RSO'            -> pool id\n         BAL   R14,II$CK$PI             check pool id\n**       ST    R0,                      buffer for RSO blocks\n*---\n         LA    R15,=CL4'LCK'            -> pool id\n         BAL   R14,II$CK$PI             check pool id\n**       ST    R0,                      buffer for LCK blocks\n*---\n         LA    R15,=CL4'DAS'            -> pool id\n         BAL   R14,II$CK$PI             check pool id\n         ST    R0,QCDASA                buffer for DAS blocks\n*---\n          AGO   .II510\n.II400    ANOP\n          AIF   (&QLEVEL LT 5).II430\n          AIF   (&QLEVEL GE 7).II410\n         ST    R1,QCTGMA                BUFFER FOR TGM BLOCKS\n          AGO   .II420\n.II410    ANOP\n         LA    R0,BFPLEN(,R1)           ADD BUFFER PREFIX\n         ST    R0,QCDASA                BUFFER FOR DAS BLOCKS\n         L     R15,QCDASL               NUMBER OF DAS BLOCKS\n         SLL   R15,12                   * 4096\n         AR    R1,R15                   INCREMENT\n         LA    R0,BFPLEN(,R1)           ADD BUFFER PREFIX\n         ST    R0,QCTGMA                BUFFER FOR TGM BLOCKS\n.II420    ANOP\n         LH    R15,QCTGML               NUMBER OF TGM BLOCKS\n         SLL   R15,12                   * 4K\n         AR    R1,R15                   INCREMENT\n.II430    ANOP\n          AIF   (&QLEVEL GE 7).II440\n         ST    R1,QCJIXA                BUFFER FOR JIX BLOCKS\n          AGO   .II450\n.II440    ANOP\n         LA    R0,BFPLEN(,R1)           ADD BUFFER PREFIX\n         ST    R0,QCJIXA                BUFFER FOR JIX BLOCKS\n.II450    ANOP\n         LH    R15,QCJIXL               NUMBER OF JIX BLOCKS\n         SLL   R15,12                   TIMES 4096\n         AR    R1,R15                   INCREMENT\n.II460    ANOP\n          AIF   (&QLEVEL GE 7).II470\n         ST    R1,QCJQTA                BUFFER FOR JQE BLOCKS\n          AGO   .II480\n.II470    ANOP\n         LA    R0,BFPLEN(,R1)           ADD BUFFER PREFIX\n         ST    R0,QCJQTA                BUFFER FOR JQE BLOCKS         \u00a2\n.II480    ANOP\n         SLL   R6,12                    MULTIPLY BY 4096\n         AR    R1,R6                    INCREMENT\n          AIF   (&QLEVEL GE 7).II490\n         ST    R1,QCJOTA                BUFFER FOR JOE BLOCKS\n          AGO   .II500\n.II490    ANOP\n         LA    R0,BFPLEN(,R1)           ADD BUFFER PREFIX\n         ST    R0,QCPSTA                BUFFER FOR PST BLOCKS\n         L     R15,QCPSTL               NUMBER OF PST BLOCKS          \u00a2\n         SLL   R15,12                   TIMES 4096\n         AR    R1,R15                   INCREMENT\n         LA    R0,BFPLEN(,R1)           ADD BUFFER PREFIX\n         ST    R0,QCJOTA                BUFFER FOR JOE BLOCKS\n.II500    ANOP\n         SLL   R3,12                    MULTIPLY BY 4096\n         LA    R3,1(,R3)                add in other from above\n         AR    R1,R3                    INCREMENT\n.II510    ANOP\n         ST    R1,QCJCTA                BUFFER FOR JCT\n         AR    R1,R5                    INCREMENT\n         ST    R1,QCIOTA                BUFFER FOR IOT\n         AR    R1,R5                    INCREMENT\n         ST    R1,QCBLKA                BUFFER FOR DATA BLOCKS\n         LA    R1,$JQHEADS-$SAVEBEG     OFFSET TO FIRST JQE HEADER\n         A     R1,QCJQTL                BASE OF FIRST CKPT REC\n         ST    R1,QCJQHEAD              ADDR OF FIRST JQE HEADER\n          AIF   (&QLEVEL LT 12).II511\n         GETMAIN  RU,LV=(R5),SP=1\n         ST    R1,QCJCTNJH              -> NJE sections\n         ST    R5,QLJCTNJH              save for freemain\n         MVC   QCJCTNJN,=H'1'           start with 1 buffer\n.II511    ANOP\n***********************************************************************\n*                                                                     *\n*   ALLOCATE AND OPEN HASPACE                                         *\n*                                                                     *\n***********************************************************************\n         LA    R15,QDSNSPC              -> DSNAME FOR ALLOCATE\n         ST    R15,DA08PDSN             SET IN DAIR BLOCK\n          AIF   (&QLEVEL GE 8).II550\n          AIF   (&QLEVEL GE 7).II540\n          AIF   (&QLEVEL EQ 4).II520\n         LA    R3,$SAVEEND(R4)          -> DA CKPT INFO IN MASTER REC\n          AIF   (&QLEVEL GE 4).II530\n         SR    R4,R4                    CLEAR FOR IC\n         IC    R4,$NUMDA                MAXIMUM NUMBER OF SPOOL VOLUMES\n          AGO   .II570\n.II520    ANOP\n         LH    R1,$QSENO                # OF QSE'S\n         MH    R1,=Y(QSELEN)            * LENGTH OF EACH QSE\n         AH    R1,$CKRECN               + TOTAL # 4K CKPT RECORDS\n         LA    R3,$SAVEEND(R1)          -> DA CKPT INFO IN MASTER REC\n.II530    ANOP\n         LA    R4,$MAXDA                MAXIMUM NUMBER OF SPOOL VOLUMES\n          AGO   .II570\n.II540    ANOP\n         L     R3,QCJQTL                -> IOAREA FOR CKPT RECORDS\n         A     R3,QCSMLEN               -> DAS INFO AREA\n         L     R1,QCDECB1               -> HASPCKPT DECB\n         BAL   R14,QAMODE24             change to AMODE 24\n         SPACE 1\n         READ  (1),SF,,(R3),MF=E        READ DAS\n         SPACE 1\n         L     R1,QCDECB1               -> HASPCKPT DECB\n         SPACE 1\n         CHECK (1)\n         SPACE 3\n         BAL   R14,QAMODE31             resume AMODE 31\n         LA    R3,BFPLEN(,R3)           SKIP OVER BUFFER PREFIX\n          AGO   .II560\n.II550    ANOP\n         L     R3,QCDASA                -> DAS area\n.II560    ANOP\n         LH    R4,$SPOLNUM              NUMBER OF SPOOL VOLUMES ALLOWED\n.II570    ANOP\n*        LA    R7,QCDCBL                LENGTH OF HASPACE DCB\n         LA    R7,QCDCBL+4+4+1          len of dcb + support tables\n         MR    R7-1,R4                  COMPUTE LENGTH OF DCB POOL\n         ST    R7,QLSPDCB               SAVE LENGTH FOR FREEMAIN\n         GETMAIN  RU,LV=(R7),SP=1       OBTAIN DCB POOL\n         ST    R1,QVSPDCB               SAVE ADDRESS FOR FREEMAIN\n*        LR    R7,R1                    SAVE ADDR OF DCB POOL\n*        LA    R5,QCSPOOLS-4            ADDR OF OPEN LIST\n         ST    R1,QCEXTMAP              -> Extent map table\n         MVI   0(R1),X'FF'              invalid entry\n         MVC   1(*-*,R1),0(R1)          prop 1 byte\n         EX    R4,*-6                   do it all (slop is ok)\n         AR    R1,R4                    -> Open list\n         LA    R1,3(,R1)                +3\n         N     R1,=A(X'FFFFFFFC')       round down to fw\n         ST    R1,QCSPOOLS              save it\n         LR    R5,R1                    copy ptr\n         LR    R7,R4                    copy number of entries\n         SLL   R7,2                     * entry len\n         AR    R1,R7                    -> tracks/cyl table\n         ST    R1,QCTRKCYL\n         AR    R7,R1                    -> DCB pool\n         SH    R5,=H'4'                 Back up 1 entry\n         SR    R6,R6                    ACTUAL NUMBER OF SPOOL VOLUMES\n          AIF   (&QLEVEL GE 7).II580\n         MVC   DA08SER(5),$SPOOL        PATTERN FOR VOLSER\n.II580    ANOP\n         DROPX R2                       $SAVEBEG\n         SPACE 1\n          AIF   (&QLEVEL GE 5).II590\nII$SPL1  CLI   0(R3),0                  IS THIS VOLUME UNUSED?\n         BE    II$SPL4                  YES. TRY NEXT.\n         CLI   0(R3),X'FF'      %%%     WAS THIS VOLUME REMOVED?\n         BE    II$SPL4          %%%     YES. TRY NEXT.\n          AGO   .II600\n.II590    ANOP\n         USNGX DASDSECT,R3\nII$SPL1  TM    DASFLAG,DASEXSTS         DOES VOLUME EXIST?\n         BZ    II$SPL4                  NO - SKIP THIS ONE\n         TM    DASFLAG2,DASINACT        IS IT INACTIVE?\n         BO    II$SPL4                  YES - SKIP IT\n          AIF   (&QLEVEL LT 5).II600\n         LH    R15,DASNOTGE             NUMBER OF TRACKS IN EXTENT\n         A     R15,QCNUMTGA             ACCUMULATE ACTIVE ...\n         ST    R15,QCNUMTGA             ... TRACK GROUP COUNT\n.II600    ANOP\n         LA    R5,4(,R5)                -> NEXT ENTRY IN OPEN LIST\n         MVC   DA08UNIT,=C'SYSALLDA'    MOVE UNIT NAME\n          AIF   (&QLEVEL GE 7).II620\n          AIF   (&QLEVEL GE 5).II610\n         MVC   DA08SER+5(1),1(R3)       LAST DIGIT OF VOLSER\n          AGO   .II630\n.II610    ANOP\n         MVC   DA08SER+5(1),DASVOLID+5  LAST DIGIT OF VOLSER\n          AGO   .II630\n.II620    ANOP\n         MVC   DA08SER(6),DASVOLID      VOLSER OF THIS SPOOL VOLUME\n.II630    ANOP\n         LA    R6,1(,R6)                INCREASE COUNT BY ONE\n         QCALL ALLOCATE                 CALL DAIR\n         L     R1,=A(HASPACE)           -> PATTERN DCB\n         MVC   0(QCDCBL,R7),0(R1)       MOVE PATTERN DCB TO POOL\n         MVC   40(8,R7),DA08DDN         UPDATE THE DDNAME\n         MVC   62(2,R7),QCHSBLK         SET THE BLKSIZE\n         ST    R7,0(,R5)                STORE DCB ADDR IN OPEN LIST\n*---  DETERMINE NUMBER OF TRKS/CYL FOR THIS DEVICE                 ---*\n         DEVTYPE  DA08DDN,DVAREA,DEVTAB,RPS  GET DEVICE TYPE INFO\n*        MVC   QCTRKCYL+2-QCSPOOLS(2,R5),DVATRK  SAVE TRKS/CYL\n         LR    R15,R5                   copy dcb ptr\n         S     R15,QCSPOOLS             get offset\n         LR    R14,R15                  save for a sec\n         A     R15,QCTRKCYL             -> correct entry\n         MVC   2(2,R15),DVATRK          copy trks/cyl\n         SRL   R14,2                    byte entry\n          AIF   (&QLEVEL GE 5).II640\n         LR    R15,R14                  copy for a sec\n          AGO   .II650\n.II640    ANOP ,\n         XR    R15,R15                  clear\n         IC    R15,DASEXTNO             get extent no\n.II650    ANOP ,\n         A     R15,QCEXTMAP             -> correct extent desc\n         STC   R14,0(,R15)              set correct ext no.\n         LA    R7,QCDCBL(,R7)           INCREMENT TO NEXT DCB\n          AIF   (&QLEVEL GE 5).II660\nII$SPL4  LA    R3,6(,R3)                NEXT VOLUME\n          AGO   .II670\n.II660    ANOP\nII$SPL4  LA    R3,DASSIZ(,R3)           NEXT VOLUME\n         DROPX R3                       DASDSECT\n.II670    ANOP\n         BCT   R4,II$SPL1               BRANCH IF MORE VOLUMES.\n         OI    0(R5),X'80'              INDICATE END OF OPEN LIST\n         BAL   R14,QAMODE24             change to AMODE 24\n         L     R1,QCSPOOLS              -> open list\n         OPEN  MF=(E,(1))               OPEN HASPACE\n         BAL   R14,QAMODE31             resume AMODE 31\n         TM    QISFLAG1,QIS1ISPF        are we in ispf ?\n         BZ    QQNSPF1                  if not do terminal stuff\n***********************************************************************\n*                                                                     *\n*        ISPF INITIALIZATION                                          *\n*                                                                     *\n***********************************************************************\n*\n**       DEFINE TABLE ROW VARIABLE\n*\n         L     R4,ISPLNK                -> ISPLINK\n         LR    R15,R4                   stupid CALL macro\n         CALL  (15),(=CL8'VDEFINE',V8,V8VAR,                           $\n               =8CL8'CHAR',VLEN8,=CL8'LIST'),VL,                       $\n               MF=(E,II@CALLP)\n*\n**       DEFINE PANEL HEADER LINE VARIABLE\n*\n         LR    R15,R4                   stupid CALL macro\n         CALL  (15),(=CL8'VDEFINE',=C'(QDHLINE)',QDHLINE,              $\n               =CL8'CHAR',=F'80'),VL,                                  $\n               MF=(E,II@CALLP)\n*\n**       DEFINE PANEL ERROR LINE VARIABLE\n*\n         LR    R15,R4                   stupid CALL macro\n         CALL  (15),(=CL8'VDEFINE',=CL8'(QERROR)',QERRMSG,             $\n               =CL8'CHAR',=F'64'),VL,                                  $\n               MF=(E,II@CALLP)\n*\n**       DEFINE PANEL CPU PERCENT VARIABLE\n*\n         LR    R15,R4                   stupid CALL macro\n         CALL  (15),(=CL8'VDEFINE',=CL8'(QC)',QCPU,                    $\n               =CL8'CHAR',=F'3'),VL,                                   $\n               MF=(E,II@CALLP)\n*\n**       DEFINE PANEL DEMAND PAGING RATE VARIABLE\n*\n         LR    R15,R4                   stupid CALL macro\n         CALL  (15),(=CL8'VDEFINE',=CL8'(QD)',QDPR,                    $\n               =CL8'CHAR',=F'3'),VL,                                   $\n               MF=(E,II@CALLP)\n*\n**       DEFINE ROWID VARIABLE\n*\n         LR    R15,R4                   stupid CALL macro\n         CALL  (15),(=CL8'VDEFINE',=CL8'QROWID',QROWID,                $\n               =CL8'FIXED',=F'4'),VL,                                  $\n               MF=(E,II@CALLP)\n*\n**       DEFINE PANEL TOP LINE VARIABLE\n*\n         LR    R15,R4                   stupid CALL macro\n         CALL  (15),(=CL8'VDEFINE',=CL8'QTITLE',QDHISFID,              $\n               =CL8'CHAR',=F'18'),VL,                                  $\n               MF=(E,II@CALLP)\n*\n**       define flag for LISTDS\n*\n         LR    R15,R4                   stupid CALL macro\n         CALL  (15),(=CL8'VDEFINE',=CL8'QBRIFHDR',QBRIFHDR,            $\n               =CL8'CHAR',=F'1'),VL,                                   $\n               MF=(E,II@CALLP)\n*\n**       Set VERB TABLE action to SETVERB (for getting just\n**       the parameters).\n*\n         LR    R15,R4                   stupid CALL macro\n         CALL  (15),(=CL8'VREPLACE',=C'(QQACT)',                       $\n               =F'8',=CL8'SETVERB'),VL,                                $\n               MF=(E,II@CALLP)\n*\n         B     IISTAX                   go do stax processing\n***********************************************************************\n*                                                                     *\n*   CHECK TERMINAL TYPE                                               *\n*                                                                     *\n***********************************************************************\nQQNSPF1  DS    0H\n         GTSIZE  ,\n         SPACE 1\n         LTR   R3,R0                    TEST NUMBER OF ROWS\n         BP    II$TUBE1                 NON-ZERO IMPLIES TUBE\n         OI    QTERMFLG,QTFTTY          ZERO ROWS -> TTY\n         LA    R3,24                    FAKE NUMBER OF LINES\n         CH    R1,=H'80'                TTY LINE LONG ENOUGH?\n         BNL   II$SETSZ                 YES - OK\n         L     R1,=A(II#MSG7)           -> MSG TEXT\n         TPUT  (1),L'II#MSG7            LINE LENGTH MUST BE > 80 ...\n         LA    R1,80                    SET LINE LENGTH\n         B     II$SETSZ\n         SPACE 2\nII$TUBE1 CH    R1,=H'80'                MOD 2, 3, OR 4?\n         BNE   II$TUBE2                 NO - SEE IF MOD 5\n         CH    R3,=H'24'                MOD 2?\n         BNH   II$SETSZ                 YES\n         CH    R3,=H'43'                TOO MANY LINES FOR MOD 4???\n         BH    II$TUBE3                 YES - ASSUME MOD 2\n         MVI   QDERASE,X'7E'            MOD 3 OR 4 - USE ...\n         MVI   QD3270OP,X'7E'           ... ERASE WRITE ALTERNATE\n         B     II$SETSZ\n         SPACE 1\nII$TUBE2 CH    R1,=H'132'               MOD 5?\n         BNE   II$TUBE3                 NO - FORCE MOD 2\n         CH    R3,=H'27'                MOD 5?\n         BNE   II$TUBE3                 NO - FORCE MOD 2\n         NOP   *+8                      %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n         OI    QTERMFLG,QTFMOD5         YES - SET FLAG\n         SPACE 1\nII$TUBE3 LA    R1,80                    SET LINE LENGTH\n         LA    R3,24                    SET NUMBER OF LINES\n         SPACE 1\nII$SETSZ STH   R1,QDCOLS                SAVE SCREEN WIDTH\n         STH   R3,QDLINES               SAVE SCREEN LENGTH\n         LR    R15,R3                   COPY NUMBER OF SCREEN LINES\n         SH    R15,=H'3'                ADJUST FOR FIXED OVERHEAD LINES\n         STH   R15,QDROWS\n         LR    R14,R15                  COPY NUMBER OF LINES / PAGE\n         BCTR  R14,0                    SUBTRACT 1 FOR COLUMN INDICATOR\n         CVD   R15,QNUMWORK             CONVERT NUMBER OF LINES / PAGE\n         ZAP   QTPAGE,QNUMWORK\n         CVD   R14,QNUMWORK             CONVERT NUMBER OF LINES / PAGE\n         ZAP   QTPAGEX,QNUMWORK\n         SRL   R15,1                    GET NUMBER LINES / HALF PAGE\n         CVD   R15,QNUMWORK             CONVERT\n         ZAP   QTHALF,QNUMWORK\n         SRL   R14,1                    GET HALF PAGE SIZE IF COLS ON\n         CVD   R14,QNUMWORK             CONVERT\n         ZAP   QTHALFX,QNUMWORK\n         LR    R0,R3                    COPY NUMBER OF SCREEN LINES\n         LA    R1,12(,R1)               ADJUST LINE LEN FOR ATTR BYTES\n         MR    R0,R1                    COMPUTE SCREEN BUFFER SIZE\n         LA    R0,50(,R3)               ADJUST FOR 3270 CONTROL HEADER\n         ST    R0,QLSCRBUF              SAVE LENGTH OF SCREEN BUFFER\n         GETMAIN  RU,LV=(0),SP=1        BUY A SCREEN BUFFER\n         ST    R1,QVSCRBUF              SAVE ADDRESS OF GOTTEN STORAGE\n***********************************************************************\n*                                                                     *\n*   TELL VTAM WE'RE HERE                                              *\n*                                                                     *\n***********************************************************************\n         STFSMODE  ON,INITIAL=YES\n         SPACE 1\n         CH    R15,=H'8'                VTAM TERMINAL?\n         BE    *+8                      NO - SKIP\n         OI    QTERMFLG,QTFVTAM         YES - SET FLAG\n***********************************************************************\n*                                                                     *\n*   ENABLE ATTN EXIT                                                  *\n*                                                                     *\n***********************************************************************\nIISTAX   DS    0H\n         L     R1,II@STAXA              GET ADDRESS OF STAX BLOCK\n         STAX  USADDR=(R11),MF=(E,(1))\n         SPACE 1\n         LTR   R2,R15                   DID IT WORK?\n         BZ    IISTAXOK                 YES\n         L     R1,=A(II#MSG8)           -> MSG TEXT\n         TPUT  (1),L'II#MSG8            'UNABLE TO ESTABLISH STAX EXIT'\n         ABEND 93\n***********************************************************************\n*                                                                     *\n*   READ IN THE QUEUE PROFILE COMMANDS                                *\n*                                                                     *\n***********************************************************************\nIISTAXOK LA    R0,II@DCB                -> PROFILE DCB AREA\n         ST    R0,II@OPEN               SET UP OPEN LIST\n         L     R1,=A(IIBSAM)            -> PATTERN DCB\n         MVC   II@DCB(IIBSAML),0(R1)    GET BSAM DCB\n         MVI   II@OPEN,X'80'            FLAG END OF LIST\n         MVC   II@DECB(II#DECBL),II#DECB  INITIALIZE DECB\n         L     R5,QCSTART               INIT COMMAND TABLE ADDR\n         SR    R2,R2                    INDICATE NO \"SYSPROC\" FOUND YET\n         L     R1,16                    -> CVT\n         L     R1,0(,R1)                -> DISPATCH\n         L     R1,4(,R1)                -> MY TCB\n         L     R1,12(,R1)               -> MY TIOT\n         SR    R0,R0                    CLEAR FOR IC\n         LA    R1,24(,R1)               -> DEVICE SECTION\n         SPACE 1\nIITIOTLP CLC   =F'0',0(R1)              END OF TIOT?\n         BE    IIPROF00                 YES\n         CLC   4(8,R1),=CL8'SYSPROC'    CLIST LIBRARY?\n         BE    IICLIST                  YES\n         CLC   4(8,R1),=CL8'QPROF'      MY PROFILE DATASET?\n         BE    IIQPROF                  YES\nIITIOTNX IC    R0,0(,R1)                GET TIOT ENTRY LENGTH\n         AR    R1,R0                    -> NEXT TIOT ENTRY\n         B     IITIOTLP                 KEEP LOOKING\n         SPACE 1\nIICLIST  LR    R2,R1                    SAVE PTR\n         B     IITIOTNX                 KEEP LOOKING FOR QPROF\n         SPACE 1\nIIQPROF  BAL   R14,QAMODE24             change to AMODE 24\n         OPEN  MF=(E,II@OPEN)           OPEN IT\n         BAL   R14,QAMODE31             resume AMODE 31\n         TM    II@DCB+48,X'10'          DID IT OPEN?\n         BNO   IIPARSE1                 NO - SKIP ALL, NO ERROR MSG\n         B     IIPROFCK                 START READING\n         SPACE 1\nIIPROF00 LTR   R2,R2                    WAS SYSPROC FOUND?\n         BZ    IIPARSE1                 NO - NO PROFILE EXISTS\n         MVC   II@DCB+DCBDDNAM-IHADCB(8),=CL8'SYSPROC'\n         MVI   II@DCB+DCBDSORG-IHADCB,DCBDSGPO   INDICATE PDS\n         BAL   R14,QAMODE24             change to AMODE 24\n         OPEN  MF=(E,II@OPEN)           OPEN IT\n         BAL   R14,QAMODE31             resume AMODE 31\n         TM    II@DCB+DCBOFLGS-IHADCB,DCBOFOPN  DID IT OPEN?\n         BNO   IIPARSE1                 NO - SKIP ALL, NO ERROR MSG\n         SPACE 1\n         FIND  II@DCB,=CL8'QPROF',D     FIND MY MEMBER THERE\n         LTR   R15,R15                  IS THERE ONE?\n         BZ    IIPROFCK                 YES - GO READ PROFILE COMMANDS\nIICLOSE  BAL   R14,QAMODE24             change to AMODE 24\n         CLOSE MF=(E,II@OPEN)           CLOSE THE DCB\n         BAL   R14,QAMODE31             resume AMODE 31\n         B     IIPARSE1                 AND SKIP ALL THIS, NO ERROR MSG\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*   READ THE PROFILE COMMANDS INTO MAIN STORAGE                       *\n*                                                                     *\n***********************************************************************\nIIPROFCK TM    II@DCB+DCBRECFM-IHADCB,DCBRECU  RECFM U?\n         BO    IICLOSE                  YES, TREAT AS INVALID\n         BZ    IICLOSE                  NO, RECFM? EVEN STRANGER\n         CLC   =H'255',II@DCB+DCBLRECL-IHADCB   LRECL OVER MAX?\n         BL    IICLOSE                  YES, IGNORE IT\n         LH    R6,II@DCB+DCBBLKSI-IHADCB  GET LEN OF BUFFER\n         LA    R6,7(,R6)                +7\n         SRL   R6,3                     /8\n         SLL   R6,3                     *8 ROUNDED UP TO DWD\n         AR    R6,R5                    -> START OF INT BUFFER\n         ST    R6,II@CMNDS              SAVE START OF COMMANDS\n         SPACE 1\nIIPROFLP BAL   R14,QAMODE24             change to AMODE 24\n         SPACE 1\n         READ  II@DECB,SF,II@DCB,(R5),MF=E  READ A PROFILE BLOCK\n         SPACE 1\n         CHECK II@DECB                  WAIT FOR IT\n         SPACE 1\n         BAL   R14,QAMODE31             resume AMODE 31\n         L     R1,II@DECB+16            -> IOB\n         LH    R15,II@DCB+DCBBLKSI-IHADCB  GET BLKSIZE\n         SH    R15,14(,R1)              MINUS RESIDUAL COUNT (IOBCSW+6)\n         AR    R15,R5                   -> END OF BUFFER\n         LR    R14,R5                   -> START OF BLOCK\n         TM    II@DCB+DCBRECFM-IHADCB,DCBRECF  RECFM F?\n         BZ    IIPROFV                  NO, GOTTA DO MORE WORK\nIIPROFFP LH    R1,II@DCB+DCBLRECL-IHADCB  GET RECORD LEN\n         BCTR  R1,0                     LEN TO MOVE -1\n         STH   R1,0(,R6)                SAVE IN BUFFER\n         EX    R1,IIPRFMVC              << MVC  2(*-*,R6),0(R14) >>\n         LA    R14,1(R1,R14)            -> NEXT POS IN INPUT BUFFER\n         LA    R6,3(R1,R6)              -> NEXT POS IN OUTPUT BUFF\n         CR    R14,R15                  PAST END YET?\n         BL    IIPROFFP                 NO, GET NEXT RECORD\n         B     IIPROFLP                 READ NEXT BLOCK\n         SPACE 2\nIIPROFV  LA    R14,4(,R14)              -> BDW\nIIPRFVP  LH    R1,0(,R14)               GET RDW LEN\n         SH    R1,=H'5'                 LEN OF DATA-1 FOR EX\nIIPRFV0  CLI   4(R14),C'0'              NUMERIC?\n         BL    IIPRFVM                  NO, TREAT AS NORMAL\n         LA    R14,1(,R14)              -> NEXT CHAR\n         BCT   R1,IIPRFV0               AND TRY THE NEXT ONE\n         B     IIPRFVP                  WHAT NONE LEFT? TRY NEXT\n         SPACE 1\nIIPRFVM  EX    R1,IIPRFMVV              << MVC 2(*-*,R6),4(R14) >>\n         STH   R1,0(,R6)                SAVE IN BUFFER\n         LA    R14,5(R1,R14)            -> NEXT INPUT RECORD\n         LA    R6,3(R1,R6)              -> NEXT OUTPUT POS\n         CR    R14,R15                  PAST END YET?\n         BL    IIPRFVP                  NO, GET NEXT RECORD\n         B     IIPROFLP                 READ NEXT BLOCK\n         SPACE 2\n*IIPEOF  BAL   R14,QAMODE24             change to AMODE 24\n*---  Don't need to switch modes since the READ was done in AMODE 24\nIIPEOF   CLOSE MF=(E,II@OPEN)           CLOSE PROFILE DCB\n         BAL   R14,QAMODE31             resume AMODE 31\n         XC    0(2,R6),0(R6)            ZERO LEN RECORD IS END\n         L     R6,II@CMNDS              -> FIRST PROFILE SUBCOMMAND\n         L     R2,QVSAVE                -> DISPLAY'S SAVE AREA\n***********************************************************************\n*                                                                     *\n*   EXECUTE THE PROFILE COMMANDS.                                     *\n*   NOTE THAT EXECUTION OF A NON-IMMEDIATE TYPE SUBCOMMAND WILL       *\n*   TERMINATE THE PROFILE SEQUENCE.  ALSO, OTHER TURKEY THINGS LIKE   *\n*   A \"*\" SUBCOMMAND WILL WREAK HAVOC.  LET THE BUYER BEWARE.         *\n*                                                                     *\n***********************************************************************\nIIPROFL2 LH    R1,0(,R6)                GET LEN OF COMMAND\n         LTR   R1,R1                    ANY LEFT?\n         BZ    IIPEND                   NO, END IT ALL HERE\n         CLI   2(R6),C'*'               COMMENT?\n         BE    IIPNEXT                  YES - SKIP IT\n         CLC   =C'/*',2(R6)             NEW STYLE COMMENT?\n         BE    IIPNEXT                  YES - SKIP IT\n         CLC   =C'/*',3(R6)             NEW STYLE COMMENT IN NEXT COL?\n         BE    IIPNEXT                  YES - SKIP IT\n         MVC   0(QSAVE1L,R2),QSAVE1     MOVE FIRST PART\n         MVC   QSAVE1L(QSAVE2L,R2),QSAVE2    SECOND PART\n         MVC   QDREPLY,QBLANK           CLEAR INPUT AREA\n         CH    R1,=Y(QDREPLYL)          OVER MAX\n         BL    IIPROF2M                 NO, MOVE THE COMMAND\n         LH    R1,=Y(QDREPLYL)          MAX LEN OF COMMAND\n         BCTR  R1,0                     -1 FOR EX\nIIPROF2M EX    R1,II$MVC2               << MVC QDREPLY(0),2(R6) >>\n         MVC   QDRLNG,=Y(QDREPLYL)      FAKE THE LENGTH\n         QCALL PARSE                    PARSE THE INPUT\n         TM    QFLAG1,Q1IMMED           IMMEDIATE COMMAND?\n         BNO   QSTOP                    NO - GO TO MAINLINE\n         L     R15,QSUBCMD              GET SUBCOMMAND EPA\n         QCALL (R15)                    INVOKE IMMEDIATE SUBCOMMAND\n         TM    QFLAG1,Q1IMMED           DID SUBCMD RESET \"IMMEDIATE\"?\n         BNO   QSTOP                    YES - LET MAINLINE RE-INVOKE IT\n         MVC   QSAVE1(QSAVE1L),0(R2)    RESTORE FIRST PART\n         MVC   QSAVE2(QSAVE2L),QSAVE1L(R2)      SECOND PART\nIIPNEXT  LH    R1,0(,R6)                -> LEN OF LAST PROF CMND\n         LA    R6,3(R1,R6)              -> NEXT COMMAND\n         OC    0(2,R6),0(R6)            ANY THERE?\n         BNZ   IIPROFL2                 YES - CONTINUE\nIIPEND   OI    QFLAG1,Q1PROFOK          PROFILE COMPLETE\n***********************************************************************\n*                                                                     *\n*   PARSE THE INITIAL COMMAND                                         *\n*                                                                     *\n***********************************************************************\nIIPARSE1 L     R2,QVSAVE                -> DISPLAY'S SAVE AREA\n         MVC   0(QSAVE1L,R2),QSAVE1     MOVE FIRST PART\n         MVC   QSAVE1L(QSAVE2L,R2),QSAVE2    SECOND PART\n         MVC   QDPROMPT,QDREPLY         SET WHAT TO REPROMPT IF ERROR\n         QCALL PARSE                    PARSE THE INPUT\n         TM    QFLAG1,Q1IMMED           IMMEDIATE COMMAND?\n         BNO   QSTOP                    NO - GO TO MAINLINE\n         L     R15,QSUBCMD              GET SUBCOMMAND EPA\n         CL    R15,=V(RECALL)           RECALL REQUEST?\n         BE    II$JUNK                  YES - HE CAN'T DO THAT HERE\n         QCALL (R15)                    INVOKE IMMEDIATE SUBCOMMAND\n         TM    QFLAG1,Q1IMMED           DID SUBCMD RESET \"IMMEDIATE\"?\n         BNO   QSTOP                    YES - LET MAINLINE RE-INVOKE IT\nII$JUNK  MVC   QSAVE1(QSAVE1L),0(R2)    RESTORE FIRST PART\n         MVC   QSAVE2(QSAVE2L),QSAVE1L(R2)      SECOND PART\n         MVC   QDPROMPT,QDREPLY         SET WHAT TO REPROMPT IF ERROR\n         B     QSTOP                    GO HOME\n***********************************************************************\n*                                                                     *\n*   PROCESS REQUEST FOR DIFFERENT VOLSER ON SYS1.HASPCKPT             *\n*                                                                     *\n***********************************************************************\n*\n*** FORMAT - QUEUE CKPT(VOLSER)\n*\n*  R1 -> 'CKPT('\n*  R3 -> LENGTH-1 OF WHOLE OPERAND\n*\nII$CKPT  MVC   QCKPTVOL,QBLANK          BLANK VOLSER FIELD\n         LA    R15,QCKPTVOL             START OF VOLSER FIELD\n         LA    R6,5(,R15)               -> END OF VOLSER FIELD\n         SH    R3,=H'4'                 SUBTRACT OVERHEAD FROM LENGTH\n         LA    R1,5(,R1)                -> FIRST OPERAND CHAR\nII$CKP1  CLI   0(R1),C')'               IS THIS THE END OF SER FIELD?\n         BE    II$CKPT2                 YES. PROCESS VOLSER NEXT.\n         CR    R15,R6                   DID WE GO TOO FAR?\n         BH    IIABORT2                 YES - GET OUT\n         MVC   0(1,R15),0(R1)           MOVE ONE BYTE OF UNIT NAME\n         LA    R15,1(,R15)              ADD 1 TO RECEIVING ADDR\n         LA    R1,1(,R1)                ADD 1 TO SENDING ADDR\n         BCT   R3,II$CKP1               BRANCH IF NOT EXHAUSTED.\n         B     IIABORT2                 INVALID PARAMETERS.\nII$CKPT2 CLI   QCKPTVOL,C' '            IS THERE A VOLSER?\n         BE    IIABORT2                 NO - ERROR\n         OI    II@FLAGS,II@CKPT         yes - remember it was specified\nII$CKPT3 BCT   R3,*+8                   -1 FOR ')'\n         B     II$SKPRM                 RESUME MAINLINE IF NO MORE PARM\n         LA    R1,1(,R1)                -> NEXT PARM CHAR\n         CLI   0(R1),C' '               FIND A NON-BLANK?\n         BE    II$CKPT3                 YES - KEEP LOOKING\n         BCT   R3,*+8                   -1 FROM COUNT\n         B     II$SKPRM                 INPUT EXHAUSTED\n         CH    R3,=H'5'                 ENOUGH LEFT TO BE INTERESTING?\n         BL    II$SKPRM                 NO\n**%%     BCTR  R3,0                     -1 FOR FINAL BLANK\n         B     II$CKPRM                 YES - PROCESS\nIIABORT2 L     R1,=A(II#MSG2)           -> MSG TEXT\n         TPUT  (1),L'II#MSG2            TELL THE USER\n         ABEND 97,DUMP                  QUIT\n***********************************************************************\n*                                                                     *\n*   PROCESS REQUEST FOR DIFFERENT DSNAME PREFIX                       *\n*                                                                     *\n***********************************************************************\n*\n*** FORMAT - QUEUE DSN(PREFIX)\n*\n*  R1 -> 'DSN('\n*  R3 -> LENGTH-1 OF WHOLE OPERAND\n*\nII$DSN   LA    R15,QCKPTPFX             -> START OF PREFIX FIELD\n         LA    R6,44-1(,R15)            -> PREFIX IS MAX 44 CHARS\n         SH    R3,=H'3'                 SUBTRACT OVERHEAD FROM LENGTH\n         LA    R1,4(,R1)                -> FIRST OPERAND CHAR\nII$DSN1  CLI   0(R1),C')'               IS THIS THE END OF THE PREFIX?\n         BE    II$DSN2                  YES. MOVE IN REST OF DSNAME\n         CR    R15,R6                   DID WE GO TOO FAR?\n         BH    IIABORT3                 YES - GET OUT\n         MVC   0(1,R15),0(R1)           MOVE ONE BYTE OF DSNAME\n         LA    R15,1(,R15)              ADD 1 TO RECEIVING ADDR\n         LA    R1,1(,R1)                ADD 1 TO SENDING ADDR\n         BCT   R3,II$DSN1               BRANCH IF NOT EXHAUSTED.\n         B     IIABORT3                 INVALID PARAMETERS.\nII$DSN2  CLI   QCKPTPFX,C' '            IS THERE A PREFIX?\n         BE    IIABORT3                 NO - ERROR\n         OI    II@FLAGS,II@DSN          yes - remember it was specified\nII$DSN3  BCT   R3,*+8                   -1 FOR ')'\n         B     II$SKPRM                 RESUME MAINLINE IF NO MORE PARM\n         LA    R1,1(,R1)                -> NEXT PARM CHAR\n         CLI   0(R1),C' '               FIND A NON-BLANK?\n         BE    II$DSN3                  YES - KEEP LOOKING\n         CH    R3,=H'5'                 ENOUGH LEFT TO BE INTERESTING?\n         BL    II$SKPRM                 NO\n         BCTR  R3,0                     -1 FOR FINAL BLANK\n         B     II$CKPRM                 YES - PROCESS\nIIABORT3 L     R1,=A(II#MSG3)           -> MSG TEXT\n         TPUT  (1),L'II#MSG3            TELL THE USER\n         ABEND 96,DUMP                  QUIT\n***********************************************************************\n*                                                                     *\n*   SET FLAG FOR ISPF DIALOG MANGLER                                  *\n*                                                                     *\n***********************************************************************\n*\n*  R1 -> 'ISPF'\n*  R3 -> LENGTH-1 OF WHOLE OPERAND\n*\nII$ISPF  OI    II@FLAGS,II@ISPF         REMEMBER FOR LATER\n         LA    R1,5(,R1)                -> PAST 'ISPF '\n         SH    R3,=H'5'                 ADJUST REMAINING LENGTH\n         BP    II$CKPRM                 GO FIND NEXT PARM ITEM\n         B     II$SKPRM                 NONE LEFT - CONTINUE INIT\n***********************************************************************\n*                                                                     *\n*   PROCESS REQUEST FOR NON-DEFAULT JES2 SUBSYSTEM                    *\n*                                                                     *\n***********************************************************************\n*\n*** FORMAT - QUEUE JES(NAME)\n*\n*  R1 -> 'JES('\n*  R3 -> LENGTH-1 OF WHOLE OPERAND\n*\nII$JESN  MVC   QJESNAME(4),QBLANK       BLANK SUBSYSTEM NAME FIELD\n         LA    R15,QJESNAME             -> START OF OUTPUT AREA\n         LA    R6,4-1(,R15)             -> SUBSYS NAME IS MAX 4 CHARS\n         SH    R3,=H'3'                 SUBTRACT OVERHEAD FROM LENGTH\n         LA    R1,4(,R1)                -> FIRST OPERAND CHAR\nII$JES1  CLI   0(R1),C')'               IS THIS THE END OF THE NAME?\n         BE    II$JES2                  YES. DONE\n         CR    R15,R6                   DID WE GO TOO FAR?\n         BH    IIABORT4                 YES - GET OUT\n         MVC   0(1,R15),0(R1)           MOVE ONE BYTE OF SUBSYS NAME\n         LA    R15,1(,R15)              ADD 1 TO RECEIVING ADDR\n         LA    R1,1(,R1)                ADD 1 TO SENDING ADDR\n         BCT   R3,II$JES1               BRANCH IF NOT EXHAUSTED.\n         B     IIABORT4                 INVALID PARAMETERS.\nII$JES2  CLI   QJESNAME,C' '            IS THERE A NAME?\n         BE    IIABORT4                 NO - ERROR\n         OI    II@FLAGS,II@JESNM        yes - remember it was specified\nII$JES3  BCT   R3,*+8                   -1 FOR ')'\n         B     II$SKPRM                 RESUME MAINLINE IF NO MORE PARM\n         LA    R1,1(,R1)                -> NEXT PARM CHAR\n         CLI   0(R1),C' '               FIND A NON-BLANK?\n         BE    II$JES3                  YES - KEEP LOOKING\n         CH    R3,=H'5'                 ENOUGH LEFT TO BE INTERESTING?\n         BL    II$SKPRM                 NO\n         BCTR  R3,0                     -1 FOR FINAL BLANK\n         B     II$CKPRM                 YES - PROCESS\nIIABORT4 L     R1,=A(II#MSG4)           -> MSG TEXT\n         TPUT  (1),L'II#MSG4            TELL THE USER\n         ABEND 94,DUMP                  QUIT\n***********************************************************************\n*                                                                     *\n*   UNSUPPORTED DEVICE TYPE. ABORT.                                   *\n*                                                                     *\n***********************************************************************\nIIABORT  L     R1,=A(II#MSG1)           -> MSG TEXT\n         TPUT  (1),L'II#MSG1            TELL THE USER\n         ABEND 98,DUMP                  QUIT.\n***********************************************************************\n*                                                                     *\n*   COULDN'T GET STORAGE FOR BLOCK ADDR TABLE                         *\n*                                                                     *\n***********************************************************************\nII$SMALL L     R1,=A(II#MSG5)           -> MSG TEXT\n         TPUT  (1),L'II#MSG5            TELL THE USER\n         ABEND 95                       QUIT.\n          AIF   (&QLEVEL LT 4).II690\n          AIF   (&QLEVEL LT 8).II680\n         EJECT ,\n***********************************************************************\n*                                                                     *\n*  II$CK$PI - Check ckpt pool id for '**xxx  POOL**'                  *\n*                                                                     *\n* ENTRY: R15 -> CL4'id'                                               *\n*        R1  -> checkpoint area to examine                            *\n*        R14 - RETURN ADDRESS                                         *\n*                                                                     *\n***********************************************************************\n         USING HDP,R1                   Control block Pool Header\nII$CK$PI CLC   HDPID+0(2),=C'**'        first part correct?\n         BNE   II$CK$P2                 nope\n         CLC   HDPID+2(4),0(R15)        name part correct?\n         BNE   II$CK$P2                 nope\n         CLC   HDPID+6(7),=C' POOL**'   last part correct?\n         BNE   II$CK$P2                 nope\n         LA    R0,HDPLNGTH(,R1)         add buffer prefix\n         ICM   R15,B'1111',HDPSIZE      size of area\n         AR    R1,R15                   bump\n         BR    R14                      return to mainline\n         DROP  R1                       HDP\n         SPACE 1\nII$CK$P2 MVC   QDMSG(L'II#MSG11),II#MSG11  'Unable to locate xxxx pool'\n         MVC   QDMSG+17(4),0(R15)       fill in pool id\n         LA    R1,QDMSG                 -> address\n         LA    R0,L'II#MSG11            length\n         TPUT  (1),(0),R\n         ABEND 89,DUMP\n          AGO   .II700\n.II680    ANOP\n         EJECT ,\n***********************************************************************\n*                                                                     *\n*  II$KITFD - FIND SELECTED KIT                                       *\n*                                                                     *\n* ENTRY: R0  - CHAR ID STRING (CL4 IN REG)                            *\n*        R14 - RETURN ADDRESS                                         *\n*                                                                     *\n* EXIT:  R1  -> KIT (IF RETURN 4(,R14); ELSE NOT FOUND)               *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nII$KITFD L     R1,II@KITF               -> FIRST KIT\n         USNGX KITDSECT,R1\nII$KITFL CL    R0,KITID\n         BE    4(,R14)                  RETURN IF SELECTED KIT FOUND\n         LA    R1,KITLNGTH(,R1)         -> NEXT KIT IF ANY\n         C     R1,II@KITL               -> LAST KIT\n         BNH   II$KITFL                 LOOP IF WAS NOT LAST KIT\n         BR    R14                      RETURN IF KIT NOT FOUND\n         DROPX R1                       KITDSECT\n         SPACE 3\n***********************************************************************\n*                                                                     *\n*  II$CKTTR - COMPUTE CKPT TTR OF GROUP OF BLOCKS FROM KITORG         *\n*                                                                     *\n* ENTRY: R1  - @ KITDSECT                                             *\n*        R14 - RETURN ADDRESS                                         *\n*                                                                     *\n* EXIT:  R1  - TTR0 OF THIS GROUP ON CKPT                             *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         USNGX KITDSECT,R1\nII$CKTTR L     R1,KITORG                GET ORI IN BYTES OF THIS GROUP\n         DROPX R1\n         SRL   R1,12                    ORG TO # OF BLOCKS\n         SR    R0,R0\n         D     R0,II@CKRT               / # 4K BLOCKS/TRK ON CKPT DEV\n         SLL   R1,8                     POSITION TT IN R1\n         OR    R1,R0                    BUILD TTR IN R1\n         AL    R1,=X'00000101'          SKIP 1ST TRK/RECORD ORIGIN 1\n         SLL   R1,8                     NOW TTR0\n         BR    R14\n.II690    ANOP\n.II700    ANOP\n         SPACE 3\n         PUSH  USING\n         DROP  ,\n         SPACE 1\n         USING *,R15\n         USING IHADCB,R1\nII#NCPEX CLI   DCBNCP,0                 NCP SPECIFIED?\n         BNER  R14                      YES - USE IT\n         MVI   DCBNCP,&@@QCKNC          NO - USE GENNED DEFAULT VALUE\n         BR    R14                      RETURN TO OPEN\n         SPACE 1\n         POP   USING\n         SPACE 3\n         EJECT\n***********************************************************************\n*                                                                     *\n*   MISCELLANY                                                        *\n*                                                                     *\n***********************************************************************\n         LTORG ,\n         SPACE 1\nII$CMDOC OC    0(*-*,R1),QBLANK         TRANSLATE COMMAND TO UPPER CASE\nII$MVC1  MVC   QDREPLY(*-*),0(R1)       MOVE DATA TO REPLY\nII$MVC2  MVC   QDREPLY(*-*),2(R6)       MOVE DATA TO REPLY\nIIPRFMVC MVC   2(*-*,R6),0(R14)         MOVE RECFM F DATA\nIIPRFMVV MVC   2(*-*,R6),4(R14)         MOVE RECFM V DATA\n         SPACE 2\n*---  TABLE OF ADCONS IN QCOMMON TO BE RELOCATED IN GETMAINED AREA\nII#RELOC DC    Y(QVSYSID-QCOMMON,QSYSID-QCOMMON)\n         DC    Y(QVPFKEYS-QCOMMON,QPFKAREA-QCOMMON)\n         DC    Y(QVTFD-QCOMMON,TFD-QCOMMON)\n         DC    Y(QVSAVE-QCOMMON,QDSAVE-QCOMMON)\n         DC    Y(QVLCBUF-QCOMMON,QDLCBUF-QCOMMON)\n         DC    Y(QVSTACK-QCOMMON,QDSTACK-QCOMMON)\n         DC    Y(QVSTACKC-QCOMMON,QDSTACK-QCOMMON)\n         DC    Y(DAPLECB-QCOMMON,DAIRECB-QCOMMON)\n         DC    Y(HDECB2+24-QCOMMON,QCDAD-QCOMMON)\n         DC    Y(QCCKPT-QCOMMON,HASPCKPT-QCOMMON)\n         DC    Y(HDECB1+8-QCOMMON,HASPCKPT-QCOMMON)\n         DC    Y(QCSAVE-QCOMMON,HASPSAVE-QCOMMON)\n         DC    Y(QPPRNT-QCOMMON,HASPPRNT-QCOMMON)\n         DC    Y(QCDECB1-QCOMMON,HDECB1-QCOMMON)\n         DC    Y(QCDECB2-QCOMMON,HDECB2-QCOMMON)\n         DC    Y(QHDCBA-QCOMMON,HELPDCB-QCOMMON)\n         DC    Y(QHDECBA-QCOMMON,HELPDECB-QCOMMON)\n         DC    Y(QVPRNTWA-QCOMMON,QPRNTWA-QCOMMON)\n         DC    Y(QVRING-QCOMMON,QCMDRING-QCOMMON)\n         DC    X'FF'                    END OF TABLE INDICATOR\n         SPACE 2\n         ENTRY SMFTABLE                 SO I CAN FIND IT WITH \"ZAP\"\nSMFTABLE DC    0D'0'\n*  CL4'smfid',CL4'sysname'\n         @GLOBALC  QUEUE,SMFTABLE       generate smfid/sysid table\n         DC    X'FF'                    END OF TABLE INDICATOR\n         SPACE 2\n         ENTRY SYSTABLE                 SO I CAN FIND IT WITH \"ZAP\"\nSYSTABLE DC    0D'0'\n*  CL6'sysres',CL4'JESn',CL6'chkptv',CL44'prefix'\n         @GLOBALC  QUEUE,JESTABLE       generate jes selection table\n         DC    X'FF'                    END OF TABLE INDICATOR\n         SPACE 3\nII#OPENO OPEN  (0,OUTPUT),MF=L\n         SPACE 1\nII#OPENI OPEN  (0),MF=L\n         SPACE 1\nII#EXLST DC    X'85',AL3(II#NCPEX)      -> DCB EXIT TO SET NCP\n         SPACE 1\n         READ  II#DECB,SF,MF=L\n         SPACE 1\nII#DECBL EQU   *-II#DECB\n         SPACE 3\n         DROPX R13                      WORK\n         SPACE 2\nII#CKSFX DC    C'&@@QSFXC'              '.HASPCKPT'\nII#HSSFX DC    C'&@@QSFXS'              '.HASPACE'\n         SPACE 2\n*                                                        ABEND CODES:\nII#MSG1  DC    C'UNSUPPORTED DEVICE TYPE SPECIFIED FOR SPOOL'  98\nII#MSG2  DC    C'INVALID PARAMETER SPECIFIED - CKPT(VOLSER)'   97\nII#MSG3  DC    C'INVALID PARAMETER SPECIFIED - DSN(PREF)'      96\nII#MSG4  DC    C'INVALID PARAMETER SPECIFIED - JES(NAME)'      94\nII#MSG5  DC    C'UNABLE TO OBTAIN 64K OF STORAGE FOR BLOCK ADDR TABLE'\n*                                                              95\nII#MSG7  DC    C'LINE LENGTH MUST BE AT LEAST 80, WILL USE 80' --\nII#MSG8  DC    C'*** UNABLE TO ESTABLISH STAX EXIT ***'        93\nII#MSG9  DC    C'*** WRONG VERSION OF QUEUE COMMAND FOR THIS CHKPT ($HA$\n               SPID \u00ac= ''JES2'') ***'                          91\nII#MSG10 DC    C'Sort routine (OACFSORT) load failure'         90\nII#MSG11 DC    C'Unable to locate xxxx pool'                   89\n         SPACE 6\nHASPACE  DCB   DDNAME=HASPACE1,DSORG=DA,MACRF=(RIC),OPTCD=A,RECFM=F\n         SPACE 2\nQCDCBL   EQU   *-HASPACE                LENGTH OF HASPACE DCB\n         SPACE 3\nIIBSAM   DCB   DDNAME=QPROF,DSORG=PS,MACRF=(RP),EODAD=IIPEOF\n         SPACE 2\nIIBSAML  EQU   *-IIBSAM\n         SPACE 6\nWORK     DSECT\n         ORG   WORK+72                  PAST MY SAVE AREA\nII@STAXA DS    A                        ADDRESS OF STAX BLOCK\nII@VLEN  DS    F                        length of area for VCOPY\nII@CPPL  DS    4A                       PHONY CPPL\nII@FLAGS DS    X                        MISC FLAG FOR INITIAL\nII@FCALL  EQU   X'80'                    ENVIRONMENT IS CALL\nII@ISPF   EQU   X'40'                    PARM=ISPF WAS SPECIFIED\nII@JESNM  EQU   X'20'                    JES() was specified\nII@CKPT   EQU   X'10'                    CKPT() was specified\nII@DSN    EQU   X'08'                    DSN() was specified\n          AIF   (&QLEVEL LT 4).IINOKIT\nII@CKRT  DS    F                        4K BLOCKS/TRK ON CKPT DEVICE\nII@KITF  DS    A                        -> FIRST KIT AT INIT TIME\nII@KITL  DS    A                        -> LAST  KIT AT INIT TIME\n.IINOKIT  ANOP\nII@CMNDS DS    A                        -> START OF COMMANDS\nII@OPEN  DS    A(II@DCB)                OPEN MF=L FOR PROFILE DCB\nII@TTRZ  DS    XL4                      TTRZ\nII@BLDL  DS    Y(1,12)\nII@BLDLN DS    CL8'ISPLINK'             MEMBER TO READ\nII@BLDLT DS    XL3,X                    TTR,Z OF MEMBER FOUND\n         READ  II@DECB,SF,MF=L          PROFILE DECB\n         SPACE 2\n         DS    0F                       STUPID MACRO...\n*  (THE DEBUGGING HANDBOOK DOCUMENTS THE FOLLOWING UNDER 'DVCT'!!!)\n         IHADVA  DSECT=NO               MAP DEVTYPE OUTPUT\n         SPACE 3\nII@DCB   DS    XL100                    SPACE FOR PROFILE DCB\n         ORG   II@DCB\nII@TRKCA TRKCALC  MF=L\n         SPACE 1\nII@TRKCL EQU   *-II@TRKCA\n         ORG   II@DCB+L'II@DCB          past end of dcb\nII@WORKL EQU   *-WORK                   len of initial workarea\nII@REGS  DS    (R11-R2+1)F              when calling LPA search\nII@CALLP DS    6A                       CALL MF=L area\n         SPACE 3\n         QCOMMON\n         QDCB\n         SPACE 3\n         Q$DAS\n         Q$MIT\n         Q$XECB\n         Q$HDP\n         Q$JOE\n         Q$JOT\n         Q$QSE\n         Q$KAC\n         Q$KIT\n         Q$LCK\n         Q$HCT\n         Q$PDDB\n         Q$IOT\n         Q$TGM\n         Q$JQE\n         Q$SVT\n         Q$HCCT\n         QZCPPL\n         QZPSA ,\n         QZTCB ,\n         QZCVT\n         QZJESCT\n         QZPSCB\n         QZSSCT\n         QZSSIB\n         QZUCB\n         QZIHAETD ,\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "Q#IIX": {"ttr": 10246, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05@\\x00\\x00\\x00\\x82#_\\x00\\x91\\x16\\x8f 3\\x08o\\x03F\\x06-\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "05.64", "flags": 0, "createdate": "1982-08-23T00:00:00", "modifydate": "1991-06-17T20:33:00", "lines": 2159, "newlines": 838, "modlines": 1581, "user": "LDW"}, "text": "         TITLE '--- QUEUE--INITIAL -- INITIALIZATION ROUTINES ---'\n*---------------------------------------------------------------------*\n*                                                                     *\n*   INITIAL - Getmain and initialize all workareas, open all DCBs,    *\n*             perform profile processing                              *\n*                                                                     *\n*   Updates:                                                          *\n*      06Jun91  EMS  Update for SP420, and fix JES2 version check     *\n*      26May91  LDW  VDEFINE QBRIFHDR                                 *\n*      15Apr91  LDW  Fix previous update                              *\n*      28Mar91  LDW  Don't use in-storage copy of checkpoint if       *\n*                       CKPT() or DSN() specified unless JES() also   *\n*      27Mar91  LDW  Allow QGLOBALS specification of dsn suffixes     *\n*      10Feb91  LDW  Rewrite ISPF detection to support direct         *\n*                       invocation under current releases of ISPF     *\n*                    Move some data out of QCOMMON to here            *\n*                    Use II@CALLP instead of TBLST and VCALLST        *\n*      30Jan91  LDW  Integrate selected GLA updates as follows:       *\n*     (02Aug90) GLA  Save addr of SVT/CCT for incore ckpt check       *\n*     (10Jul90) GLA  Add code to initialize PC routines to allow      *\n*                       easy access to in-core CKPT for 2.2 and 3.1   *\n*     (15Nov89) GLA  Fix support for SP3.1.1 for previous releases.   *\n*                    Add support for VERB TABLE variable.             *\n*     (16Jun89) GLA  Fix XA 0C4 due to clobbered register.            *\n*     (20Apr89) GLA  Fix JCT overlay on CKPT read. The setup of       *\n*                       JCT address in the buffer was off by 4K.      *\n*     (28Mar89) GLA  Add ISPF BROWSE & table support for ISPF V1.x    *\n*                       through 2.3                                   *\n*      29Jan91  LDW  Add QVPRNTWA to II#RELOC                         *\n*      22Dec90  LDW  Use EQU for SYSTABLE entry length                *\n*      27Nov90  EMS  Fix for longer dsn's                             *\n*      16Jun90  LDW  Run (mostly) in AMODE31 now                      *\n*      25Dec89  LDW  Q$xxx -> QZxxx:  CPPL, CVT, JESCT, PSCB, SSCT,   *\n*                                     SSIB, UCB                       *\n*      12Dec89  LDW  Use &@@OACFS for name of OACFSORT load module    *\n*                    Pick up following updates from Doron 21Nov89:    *\n*               DMS  Test &@@SYSP and &@@STAFF instead of hardcoded   *\n*                    Make use of OACFSORT conditional on &@@OACFS     *\n*                    Bypass KAC reference if &QLEVEL LT 8             *\n*      23Nov89  LDW  Remove conditional assembly around Qxxx macros   *\n*                    Remove prereq Q$PDDB                             *\n*      05Jun89  LDW  Set QXSUPR and QXAPFENT if appropriate           *\n*      25Apr89  EMS  SP311 changes, in core ckpt use                  *\n*      17Apr89  LDW  Change Q$UCB to QUCB                             *\n*      03Feb88  LDW  Adapt Jack Schudel's 2.2.0 mods for Lockheed's   *\n*                       QUEUE to this QUEUE                           *\n*       3Jun87  EMS  Add support for Starting/Draining Spool vols     *\n*                       and better checking for invalid mttr's        *\n*                    load OACFSORT                                    *\n*                    getmain separate table for DDNAME cmd            *\n*      13Feb87  LDW  Init QVRING                                      *\n*                    Use table to relocate adcons in QCOMMON          *\n*      17Jan87  LDW  Set QCNUMTGA = $NUMTG if QLEVEL < 5              *\n*                    Misc cleanup                                     *\n*      10Jan87  LDW  SP136:  Save $JQELEN, many changes in CKPT math  *\n*                    Use CVT instead of CVTDSECT (for XA?)            *\n*      04SEP86  LDW  USE DCB EXIT TO SET DEFAULT NCP                  *\n*      25AUG86  LDW  FIX BUGS IN PREVIOUS UPDATE (SP130 BROKE)        *\n*      17JUN86  LDW  SAVE INFO ON SECTIONS OF CKPT DATASET, TO ALLOW  *\n*                       READING ONLY NECESSARY DATA                   *\n*                    SET QMFMVSE IF RUNNING MVS/XA                    *\n*                    ADD SECOND BASE REG (PUKE!)                      *\n*      03JUN86  LDW  GETMAIN STORAGE FOR MULTIPLE HASPCKPT DECBS      *\n*      03/30/86 LDW  RE-DESIGN 3278-5 SUPPORT (THIRD TRY!)            *\n*                    STAX BLOCK MOVED FROM QCOMMON TO QUEUE LOCAL     *\n*                       WORKAREA                                      *\n*      08/30/84 LDW  GETMAIN A SCREEN BUFFER                          *\n*                    SAVE ALL GETMAINED ADDRESSES AND LENGTHS         *\n*      08/07/84 LDW  UPDATE FOR SP134 (DON'T COMPUTE QCPDDB1)         *\n*      08/06/84 LDW  IF SP:  FOR HASPCKPT BLKSIZE, USE MAX FOR        *\n*                       DEVICE, TO ACCOUNT FOR THE MASTER REC IN      *\n*                       JES2/SP BEING LARGER THAN 4K                  *\n*      06/05/84 LDW  UPDATES FOR SP133 FROM UF VERSION                *\n*      04/20/84 EMS  FIX FOR QPROF RECFM=FB                           *\n*      04/11/84 LDW  IOTDSECT -> IOTSTART                             *\n*                    USING/DROP -> USNGX/DROPX                        *\n*      04/10/84 LDW  SP133 COMPATIBILITY                              *\n*      01/23/83 LDW  RELOCATE QHDCBA AND QHDECBA                      *\n*      12/19/83 LDW  SET QCTGMLEN (FOR NEW 'SPACE' FEATURE)           *\n*      10/30/83 LDW  FIX TEST FOR RECALL (WAS 'REPROMPT')             *\n*      10/17/83 LDW  CORRECT SOME ADDREESSABILITY ERRORS CAUSED BY    *\n*                       ENLARGING 'SYSTABLE'                          *\n*      07/25/83 LDW  DON'T CALL ISPLINK UNLESS PARM STARTS WITH       *\n*                       'ISPF'                                        *\n*      04/19/83 LDW  FIX BUG IN ALLOCATING HASPACE IF JES2/SP         *\n*      03/18/83 LDW  RELOCATE QVSTACK, QVSTACKC                       *\n*                    MISC FIXES FOR ADDRESSABILITY                    *\n*      03/01/83 LDW  RELOCATE QVLCBUF                                 *\n*      02/04/83 LDW  SEE IF ISPLINK EXISTS BEFORE LINKING TO IT       *\n*      02/03/83 LDW  TO SUPPORT 3380'S:  REMOVE DEVICE TABLE, USE     *\n*                       DEVTYPE MACRO                                 *\n*                    OTHER MISC CLEANUP DONE IN THIS AREA             *\n*      02/02/83 LDW  CHANGE CONDITIONAL ASSEMBLY SO THAT IF SID TABLE *\n*                       IS GENERATED CORRECTLY IF &QSIDNUM = 0        *\n*      01/24/83 LDW  PICK UP LOCAL NODE ID FROM $SAVEAREA IF SP       *\n*                    ADD $PDDB IN FRONT OF $IOT IF SP                 *\n*      01/19/83 LDW  ADD OPTIONAL TRANSLATION OF SMF ID'S             *\n*                    ADD ANOTHER TEMPORARY BASE FOR QCOMMON           *\n*                    SET QTPAGEX, QTHALFX                             *\n*                    REMOVE TESTAUTH (NOW IN NEW ROUTINE \"APF\")       *\n*      01/14/83 LDW  ADD SP SUPPORT                                   *\n*      01/04/83 LDW  CHECK FOR SPF ENVIRONMENT                        *\n*                    RE-ENABLE MOD 5 SUPPORT                          *\n*                    SET QSTDEFKY                                     *\n*                    CHECK THAT CHKPT FILE IS THE ONE WE HAVE BEEN    *\n*                       ASSEMBLED FOR                                 *\n*                    USE NJE FIELD NAMES ($SVTONOD REPLACES $SVTOSYS) *\n*                    FIX BUG:  REPROMPT WITH INVOCATION CMD IF BAD    *\n*      12/10/82 LDW  ALLOW PROFILE COMMENTS AS '/*' OR ' /*'          *\n*      10/28/82 LDW  SAVE SYSTEM ID OF SELECTED JES2 IN QSYSID(0)     *\n*      10/14/82 EMS  ADD SUPPORT FOR RECFM V PROFILES                 *\n*                    FIX BUG IN PROCESSING OF MULTIPLE QSE'S          *\n*                    FIX BUG IN PARM PROCESSING                       *\n*                    ONLY USE 1 MODEL DCB FOR BOTH PS AND PO PROFILES *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 3\nINITIAL  QSTART  Q10,WORKLEN=II@WORKL\n         LA    R8,4095(,R12)            SET UP SECOND...\n         LA    R8,1(,R8)                ... BASE REGISTER\n         USNGX INITIAL+4096,R8          COMPLETE THE TRAVESTY\n         USNGX WORK,R13\n         USNGX PSA,R0\n         ST    R3,II@STAXA              SAVE ADDRESS OF STAX BLOCK\n         MVI   II@FLAGS,0               INIT FLAGS\n***********************************************************************\n*                                                                     *\n*   COPY AND INITIALIZE QCOMMON                                       *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n*  AT ENTRY (FROM \"QUEUE\" MAINLINE), R11 -> \"QCOMMON\" CSECT, SO WE MUST\n*  NOT STORE ANYTHING UNTIL AFTER WE HAVE CHANGED TO THE GETMAINED COPY\n         L     R10,QGETMAIN             GET LENGTH OF QCOMMON\n         GETMAIN  RU,LV=(R10),SP=44,BNDRY=PAGE  GET AN AREA FOR QCOMMON\n         SPACE 1\n* MOVE QCOMMON INTO WORKING STORAGE\n         LR    R0,R11                   -> QCOMMON (SOURCE ADDR)\n         LR    R14,R1                   -> GETMAIN AREA (DEST ADDR)\n         LR    R11,R1                   ADDRESS NEW QCOMMON\n         LR    R1,R10                   SOURCE LENGTH FOR MVCL\n         LR    R15,R1                   DEST LENGTH\n         MVCL  R14,R0                   COPY CSECT TO GETMAINED AREA\n*  NOW MUST INITIALIZE ALL THE ADCONS IN IT\n         MVC   QCCKPT,II#OPENI          INITIALIZE HASPCKPT OPEN LIST\n         MVC   QCSAVE,II#OPENO          INITIALIZE HASPSAVE OPEN LIST\n         MVC   QPPRNT,II#OPENO          INITIALIZE HASPPRNT OPEN LIST\n         MVI   QHDCBA,X'80'             MARK END OF OPEN LIST\n         LA    R1,II#RELOC              -> RELOCATION TABLE\nII$RL$LP LH    R14,0(,R1)               GET OFFSET OF POINTER\n         AR    R14,R11                  -> ADCON\n         LH    R15,2(,R1)               GET OFFSET OF DATA\n         AR    R15,R11                  -> VALUE\n         STCM  R15,B'0111',1(R14)       STORE RELOCATED DATA POINTER\n         LA    R1,4(,R1)                -> NEXT RELOCATION TABLE ENTRY\n         CLI   0(R1),X'FF'              END OF TABLE?\n         BNE   II$RL$LP                 NO - LOOP\n         SPACE 3\n         L     R1,4(,R13)               PREVIOUS SAVE AREA\n         ST    R11,64(,R1)              UPDATE R11 IN PREVIOUS S.A.\n         ST    R1,QFRSTSA               STORE @ FIRST S.A. IN QCOMMON\n***********************************************************************\n*                                                                     *\n*  If called via the ISRQ module (from ISPF) the following            *\n*     calling conventions will hold:                                  *\n*       R2 (orig R1)  =  Address of parm list (but non-CPPL fmt)      *\n*                           +0 = F'-1'   to distinguish from CPPL     *\n*                           +4 = TLD address                          *\n*                           +8 = address of 'ISPLINK'                 *\n*                           +12= address of CPPL                      *\n***********************************************************************\n         CLC   =F'-1',0(R2)             did call come from 'ISRQ'\n         BNE   VLDTSO                   if not then normal system call\n         LA    R3,4(,R2)                point at \"real\" parms from ISRQ\n         OI    QISFLAG1,QIS1ISPF        set called from ISPF flag\n         MVC   BRWEPARM,0(R3)           save addr of TLD\n         MVC   ISPLNK,4(R3)             save addr of ISPLINK program\n         L     R2,8(,R3)                get address of CPPL\n         B     IICPPLOK                 continue\n         SPACE 1\nVLDTSO   DS    0H\n***********************************************************************\n*                                                                     *\n*   Check out whether we are APF authorized or SUPR mode, remember    *\n*   for later.                                                        *\n*                                                                     *\n***********************************************************************\n         TESTAUTH  FCTN=1               see if we are APF authorized\n         SPACE 1\n         LTR   R15,R15                  are we?\n         BNZ   *+8                      no\n         OI    QXAUTH,QXAPFENT          yes\n         SPACE 2\n***      TESTAUTH  FCTN=0,STATE=YES     see if we are SUPR mode\n         SPACE 1\n***      LTR   R15,R15                  are we?\n***      BNZ   *+8                      no\n***      OI    QXAUTH,QXSUPR            yes\n*---  The TESTAUTH above results in abend S177.  Until this is\n*---  resolved, do it a different way.\n         L     R1,PSATOLD               -> TCB\n         L     R1,0(,R1)                TCB.RBP\n         N     R1,=X'00FFFFFF'          clean in case AMODE31\n         TM    10(R1),X'E0'             RB.STAB1,RBFTP  PRB?\n         BZ    *+8                      yes - can't be SUPR\n         OI    QXAUTH,QXSUPR            assume SVRB\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*   IF WE HAVE BEEN CALLED RATHER THEN INVOKED AS A CP,               *\n*   PHONY UP A CPPL                                                   *\n*                                                                     *\n***********************************************************************\n         USNGX CPPL,R2                  ADDR OF CPPL IS IN R2\n         L     R1,PSATOLD               -> TCB\n         L     R1,180(,R1)              -> JSCB\n         L     R1,264(,R1)              -> PSCB\n         TM    0(R2),X'80'              CALL?\n         BO    II$CALL1                 YES - GO PHONY UP SOME STUFF\n         CLM   R1,B'0111',CPPLPSCB+1    DOES IT LOOK ENOUGH LIKE CPPL?\n         BE    IICPPLOK                 YES - DO IT FOR REAL\n*  DARN.  IT'S CALL.  BUILD A PHONY CPPL.\nII$CALL1 OI    II@FLAGS,II@FCALL        REMEMBER THAT THIS IS \"CALL\"\n         LR    R4,R2                    PRESERVE PARM POINTER\n         LA    R2,II@CPPL               CHANGE POINTER TO PHONY ONE\n         XC    0(4*4,R2),0(R2)          ZERO IT FOR FUN\n         ST    R1,CPPLPSCB              SET PSCB ADDRESS IN PHONY CPPL\n         USNGX PSCB,R1\n         MVC   CPPLUPT,PSCBUPT          UPT ADDRESS TO CPPL\n         L     R1,PSCBRLGB              -> RELOGON BUFFER\n         DROPX R1                       PSCB\n         L     R1,256(,R1)              RLGB.ECT\n         ST    R1,CPPLECT               SET ECT ADDRESS IN PHONY CPPL\n***********************************************************************\n*                                                                     *\n*   MOVE PARMS FROM CPPL TO DAPL                                      *\n*                                                                     *\n***********************************************************************\nIICPPLOK MVC   DAPLUPT,CPPLUPT          USER PROFILE TABLE\n         MVC   DAPLPSCB,CPPLPSCB        PROTECTED STORAGE CNTL BLK\n         MVC   DAPLECT,CPPLECT          ENVIRONMENT CNTL TABLE\n***********************************************************************\n*                                                                     *\n*   LOCATE LOGON ID, SAVE FOR FUTURE REFERENCE                        *\n*                                                                     *\n***********************************************************************\n         L     R1,CPPLPSCB              -> PSCB\n         USNGX PSCB,R1\n         MVC   QLOGON(7+1),PSCBUSER     SAVE TSO USERID AND LENGTH\n         MVC   QSTKEY(7),QLOGON         SET SEARCH KEY FOR \"ST\"\n         MVC   QSTDEFKY,QSTKEY          SET DEFAULT FOR \"ST *\"\n         TM    &@@SYSP                  SYSTEMS PROGRAMMER?\n         BNO   *+8                      NO - SKIP\n         OI    QXAUTH,QXSYSP            YES - REMEMBER\n         TM    &@@STAFF                 OPERATOR COMMAND AUTHORITY?\n         BNO   *+8                      NO - SKIP\n         OI    QXAUTH,QXOPER            YES - REMEMBER\n         DROPX R1                       PSCB\n         SPACE 3\n         L     R1,PSATOLD               -> TCB\n         L     R1,TCBJSCB-TCB(,R1)      -> JSCB\n         L     R1,316(,R1)              -> SSIB  (JSCBSSIB-IEZJSCB)\n         USNGX SSIB,R1\n         MVC   QDEST,SSIBDEST           SAVE LOGON DEST\n         MVC   QPDEST,SSIBDEST          SET DEFAULT PRINT DEST\n         MVC   QJESNAME,SSIBSSNM        SAVE NAME OF JES2\n         DROPX R1                       SSIB\n         DROPX R0                       PSA\n***********************************************************************\n*                                                                     *\n*   MOVE COMMAND BUFFER TO REPLY BUFFER                               *\n*                                                                     *\n***********************************************************************\n         TM    II@FLAGS,II@FCALL        CP OR CALL?\n         BNO   II$CP                    NOT CALL\n         L     R4,0(,R4)                GET PARM ADDRESS\n         LH    R3,0(,R4)                GET OPERAND LENGTH\n         SH    R3,=H'1'                 DECR FOR EX\n         BM    II$SKPRM                 SKIP IF NO OPERAND\n         LA    R1,2(,R4)                -> PARM TEXT\n         B     II$CALL2                 CONTINUE\nII$CP    L     R1,CPPLCBUF              ADDR OF COMMAND BUFFER\n         DROPX R2                       CPPL\n         LH    R3,0(,R1)                LENGTH OF COMMAND BUFFER\n         LH    R4,2(,R1)                OFFSET TO FIRST DATA BYTE\n         LA    R1,4(R1,R4)              FIRST DATA BYTE\n         SR    R3,R4                    SUBTRACT OFFSET FROM LENGTH\n         SH    R3,=H'5'                 SUB OVERHEAD, PLUS 1 FOR EX\n         BM    II$SKPRM                 SKIP IF LENGTH ZERO\nII$CALL2 EX    R3,II$CMDOC              TRANSLATE TO UPPER CASE\nII$CKPRM CLI   0(R1),C' '               LEADING BLANK?\n         BNE   II$CKKEY                 NO, CHECK FOR KEYWORDS\n         LA    R1,1(,R1)                -> NEXT BYTE\n         BCT   R3,II$CKPRM              AND CHECK IT\n         B     II$SKPRM                 IF NONE LEFT, CONTINUE INIT\n         SPACE 1\nII$CKKEY CLC   =C'ISPF',0(R1)           IS DIALOG MANGLER TO BE USED?\n         BE    II$ISPF                  YES. SET FLAG.\n         CLC   =C'JES(',0(R1)           IS REQUEST FOR SELECT JES NAME?\n         BE    II$JESN                  YES. DO IT.\n         CLC   =C'CKPT(',0(R1)          IS REQUEST FOR CKPT?\n         BE    II$CKPT                  YES. DO IT.\n         CLC   =C'DSN(',0(R1)           IS REQUEST FOR DSN PREFIX?\n         BE    II$DSN                   YES. DO IT.\n         MVC   QDREPLY,QBLANK           BLANK THE REPLY LINE\n         CH    R3,=Y(QDREPLYL-1)        IS LENGTH OVER MAX?\n         BNH   *+8                      NO. USE IT.\n         LA    R3,QDREPLYL-1            USE MAXIMUM LENGTH\n         EX    R3,II$MVC1               MOVE THE DATA\n         MVC   QDPROMPT,QDREPLY         COPY TO THE PROMPT\n         LA    R3,1(,R3)                INCREMENT TO TRUE LENGTH\n         STH   R3,QDRLNG                STORE REPLY LENGTH\n***********************************************************************\n*                                                                     *\n*   DETERMINE WHICH JES2 CHECKPOINT VOLSER AND PREFIX TO USE          *\n*                                                                     *\n***********************************************************************\nII$SKPRM L     R1,CVTPTR                -> CVT\n          AIF   (&@@SPLVL LT 130).II010  SKIP IF BIT NOT DEFINED\n         TM    CVTDCB-CVT(R1),CVTMVSE   RUNNING MVS/XA?\n         BZ    II$NOTXA                 NO - SKIP\n         OI    QMISCFLG,QMFMVSE         YES - REMEMBER\n         SL    R1,=A(32)                -> FIELD CVTPRODI\n         CLC   1(4,R1),=C'BB22'         XA 2.2 or later?  JBB2220\n         BL    II$NOTXA                 no - skip setting flag\n         OI    QMISCFLG,QMFX22          yes - remember\nII$NOTXA L     R1,CVTPTR                reload cvt pointer\n.II010    ANOP\n         L     R1,CVTJESCT-CVT(,R1)     -> JESCT\n         L     R15,JESUNITS-JESCT(,R1)  -> SYSRES UCB\n         USNGX UCBOB,R15\n         LA    R1,SYSTABLE              -> SYSTEM TABLE\nII$SYSLP CLC   UCBVOLI,0(R1)            COMPARE SYSRES VS. TABLE ENTRY\n         BE    II$RES1                  FOUND ONE - GO CHECK JESNAME\n         DROPX R15                      UCBOB\nII$NXSYS LA    R1,SYSTBLL(,R1)          -> NEXT SYSTEM TABLE ENTRY\n         CLI   0(R1),X'FF'              END OF TABLE?\n         BNE   II$SYSLP                 NO - KEEP LOOKING\n         LA    R1,SYSTABLE              NOT FOUND - USE FIRST ENTRY\n         B     II$SAVE\nII$RES1  CLC   QJESNAME,6(R1)           RIGHT JES2?\n         BNE   II$NXSYS                 NO - KEEP LOOKING\n*---  WE HAVE LOCATED A TABLE ENTRY FOR THIS SYSRES/JES2 COMBINATION\nII$SAVE  CLI   QCKPTVOL,C' '            DID USER SPECIFY CKPT(XXXXXX)?\n         BNE   *+10                     YES - USE THE ONE HE WANTS\n         MVC   QCKPTVOL,10(R1)          SAVE CHKPT VOLSER\n         CLI   QCKPTPFX,C' '            DID USER SPECIFY DSN(XXXXXX)?\n         BNE   *+10                     YES - USE THE ONE HE WANTS\n         MVC   QCKPTPFX,16(R1)          SET DSN PREFIX\n***********************************************************************\n*                                                                     *\n*   LOCATE AND SAVE VARIOUS INFORMATION ABOUT THE SELECTED JES2       *\n*                                                                     *\n***********************************************************************\n*  FIND SSCT FOR PRIMARY SUBSYSTEM\n         L     R15,CVTPTR               -> CVT\n         L     R15,CVTJESCT-CVT(,R15)   -> JESCT\n         L     R15,JESSSCT-JESCT(,R15)  -> SSCT\n         USNGX SSCT,R15\n*  FIRST, SET LOCAL NODE FROM THE PRIMARY SUBSYSTEM, IF IT'S ACTIVE\n          AIF   (&QLEVEL GE 9).II020\n         L     R14,SSCTSSVT             -> SSVT\n         USNGX SSVT,R14\n          AIF   (&QLEVEL LT 8).II030\n         L     R7,SVTKAC                -> KAC\n          AGO   .II030\n.II020    ANOP ,\n         L     R14,SSCTSUS2             -> HCCT\n         USNGX HCCT,R14\n         L     R7,CCTKAC                -> KAC\n         STM   R14,R1,II@REGS           %debug\n         MVC   QDMSG(11),=C'>>> cctkac='   %debug\n         HEX   QDMSG+11,CCTKAC,LEN=4,HEXTAB=QHEXTAB  %debug\n         TPUTX QDMSG,19                 %debug\n         MVC   QDMSG,QBLANK             %debug\n         LM    R14,R1,II@REGS           %debug\n.II030    ANOP ,\n         LTR   R14,R14                  IS PRIMARY SYSTEM UP?\n         BZ    II$PDOWN                 NO - SKIP\n          AIF   (&QLEVEL GE 8).II031\n         TM    $SVSID,X'80'             DOES IT APPEAR TO BE A VALID\n*                                       SMF SYSTEM ID?\n         BNO   II$PDOWN                 NO - SKIP\n*---  FOR EXPLANATION OF THE CRUMMY TEST ABOVE, GO READ \"FINDRJE\"  ---*\n          AGO   .II032\n.II031    ANOP\n         L     R1,SSCTSUSE              -> SSSM module MIT\n         CLC   QJ2VERSN,0(R1)           QUEUE assembled for this JES2?\n         BNE   II$PDOWN                 no - exit stage left\n.II032    ANOP\n         MVC   QCLNODE,$SVTONOD         SAVE OUR NODE NUMBER\n         SPACE 1\n*  NOW, FIND THE SSVT FOR THE SYSTEM WE ACTUALLY ARE INTERESTED IN\nII$PDOWN CLC   SSCTSNAM,QJESNAME        DO WE WANT THE PRIMARY?\n         BE    II$PRIM                  YES - SAVE OTHER INFO\n         SPACE 1\nII$SSCT  L     R15,SSCTSCTA             -> NEXT SSCT\n         LTR   R15,R15                  END OF CHAIN?\n         BZ    II$JNOK                  YES - CONTINUE WITH DEFAULTS\n*                           FROM PRIMARY SUBSYS SINCE WE DIDN'T FIND\n*                           THE DESIRED SECONDARY SUBSYSTEM\n         CLC   SSCTSNAM,QJESNAME        IS THIS THE ONE WE WANT?\n         BNE   II$SSCT                  NO - KEEP LOOKING\n          AIF   (&QLEVEL GE 9).II050\n         L     R14,SSCTSSVT             -> SSVT\n         ST    R14,QSVT                 save for CKPT\n          AIF   (&QLEVEL LT 8).II060\n         L     R7,SVTKAC                -> KAC\n          AGO   .II060\n.II050    ANOP ,\n         L     R14,SSCTSUS2             -> HCCT\n         ST    R14,QCCT                 save for CKPT\n         L     R7,CCTKAC                -> KAC\n.II060    ANOP ,\n         LTR   R14,R14                  IS THIS SYSTEM UP?\n         BZ    II$JNOK                  NO - CONT WITH DFLT FROM PRIM\n         MVC   QCLNODE,$SVTONOD         OUR NODE NUMBER\n         SPACE 1\nII$PRIM  MVC   QCOMCHAR,$SVCOMCH        SAVE THE COMMUNICATIONS CHAR\n          AIF   ('&QALTCC' EQ '').II070\n         MVC   QALTCHAR,&QALTCC\n.II070    ANOP\n         MVC   QSMFID(4),$SVSID         SAVE OUR SYSTEM ID\nII$JNOK  ST    R15,QSSCT                SAVE SSCT ADDRESS\n          AIF   (&QLEVEL LT 8).IINOPC\n         EJECT\n***********************************************************************\n*                                                                     *\n*   Check for incore checkpoint from JES2                             *\n*                                                                     *\n***********************************************************************\n         LTR   R7,R7                    Any KAC?\n         BZ    II$NKAC                  No - no in-core copy\n         TM    II@FLAGS,II@JESNM        JES() specified?\n         BNZ   II$ISUSE                 yes - ok to use in-storage ckpt\n         TM    II@FLAGS,II@CKPT+II@DSN  CKPT() or DSN() specified?\n         BNZ   II$NKAC                  yes - don't use in-storage ckpt\nII$ISUSE EQU   *\n         STM   R14,R1,II@REGS           %debug\n         TPUTX '>>> ii$isuse'           %debug\n         LM    R14,R1,II@REGS           %debug\n         USNGX KAC,R7\n***********************************************************************\n*                                                                     *\n*    Code to setup a PC routine - must run in supervisor state.       *\n*                                                                     *\n***********************************************************************\n         LA    R1,4                     Check if authorized\n         LNR   R1,R1                    Make conditional\n         QCALL AUTHFUNC\n         LTR   R15,R15                  Are we authorized\n         BNZ   II$NKAC                  Nope cant use incore\n         STM   R14,R1,II@REGS           %debug\n         TPUTX '>>> auth for pc setup'  %debug\n         LM    R14,R1,II@REGS           %debug\n*%%% AUTHFUNC needs an option to do the following:\n         MODESET KEY=ZERO,MODE=SUP      Get key=0\n         TM    KACFLAG1,KAC1BADC+KAC1GONE\n         BNZ   II$NKAC1                 No good in core copy\n         TM    KACFLAG1,KAC1ECSA        In CSA\n         BZ    II$NKAC1                 No good in core copy\n         ST    R7,QKACA                 save address of KAC\n*   GET A NON-SYSTEM LX\n         LA    R2,1\n         ST    R2,QPCLXCNT              REQUEST 1 LX\n         SPACE 2\nII$GLX   LXRES LXLIST=QPCLXL,RELATED=(II$FRLX,II$CONET)\n         SPACE 3\n*   CREATE PC ROUTINES\n         L     R2,=V(CKPT$PC)           get address\n          AIF   (&QLEVEL GE 9).IIPC3A\n*\n**       Build ET entry list\n*\n         LA    R3,QPCDESC               Point at list\n         USNGX ETD,R3\n         MVC   ETDNUM,=H'1'             Set number of elements\n         LA    R3,ETDEND                Point at first element\n         DROPX R3\n         USNGX ETDELE,R3\n         MVI   ETDEX,0                  Set index number\n         MVI   ETDFLG,ETDSUP            Set flags\n         ST    R2,ETDPRO2               Set address of routine\n         OI    ETDPRO2,ETDAMODE         Set entry to 31 bit\n         MVC   ETDAKM(4),=X'FFFFFFFF'   Set valid keys\n         ST    R11,ETDPAR               Set latent parameter\n         DROPX R3\n          AGO   .IIPC3B\n.IIPC3A   ANOP\n         ETDEF TYPE=SET,ETEADR=QPCETD1,ROUTINE=(2),SSWITCH=NO,         $\n               PARM1=(R11),                                            $\n               STATE=SUPERVISOR,AKM=(0:15),EKM=(0:15),EK=0,PKM=OR\n.IIPC3B   ANOP\nII$CET1  ETCRE ENTRIES=QPCDESC,                                        $\n               RELATED=(II$CONET,II$DISET,II$DESET)\n*\n         ST    R0,QPCTKVAL              SAVE RETURNED TOKEN\n         SPACE 3\n*  CREATE PC NUMBERS\n         L     R2,QPCLXVAL              LX = PC# WITH EX OF 0\n         LA    R2,0(,R2)                CONSTRUCT EX=0 PC#\n         ST    R2,QPCCKPT               SAVE NUMBER\n*        LA    R2,1(,R2)                CONSTRUCT EX=1 PC#\n*        ST    R2,SERV2PC               SAVE NUMBER\n         SPACE 3\n*   ESTABLISH ACCESS\n         LA    R2,1\n         ST    R2,QPCTKCNT              SET COUNT OF ETS TO CONN\n*\nII$CONET ETCON TKLIST=QPCTKL,LXLIST=QPCLXL,                            $\n               RELATED=(II$GLX,II$CET1)\n***********************************************************************\n*                                                                     *\n*   Now compute some values and go to normal                          *\n*                                                                     *\n***********************************************************************\n         OI    QKFLAG,QKFKAC            indicate good KAC\n         L     R1,KACCLEN               get length of copy\n         A     R1,KACCKPTA               less\n         S     R1,KACMSTRA                 length of master rcd\n         ST    R1,QCKMLEN               save length of incore\n         DROPX R7                       KAC\nII$NKAC1 DS    0H\n         MODESET KEY=NZERO,MODE=PROB    Out of supervisor state\n         LA    R1,8                     release authorization\n         QCALL AUTHFUNC\n         STM   R14,R1,II@REGS           %debug\n         TPUTX '>>> ii$nkac1'           %debug\n         LM    R14,R1,II@REGS           %debug\nII$NKAC  DS    0H\n         STM   R14,R1,II@REGS           %debug\n         TPUTX '>>> ii$nkac'            %debug\n         LM    R14,R1,II@REGS           %debug\n.IINOPC   ANOP\n         EJECT\n***********************************************************************\n*                                                                     *\n*   SEE IF SPF DIALOG INTERFACE MODULE IS AVAILABLE                   *\n*                                                                     *\n***********************************************************************\n          AIF   (&@@ISPF LT 230).IINIS1 skip if no ISPQRY\n         CLC   ISPLNK,=F'0'             do we have ISPLINK address?\n         BE    II$ISQRY                 no - go query ISPF\n         OI    II@FLAGS,II@ISPF         yes - remember\n         B     II$ISPGO                 skip ISPQRY\n         SPACE 2\nII$ISQRY LINK  EP=ISPQRY                check ISPF environment\n*\n         LTR   R15,R15                  valid ISPF environment?\n         BNZ   II$NOSPF                 no - skip\n         OI    II@FLAGS,II@ISPF         yes - remember\n         OI    QISFLAG1,QIS1ISPF        set called from ISPF flag\n*\n         LOAD  EPLOC==CL8'ISPLINK'      find interface module\n*\n         ST    R0,ISPLNK                save address\n*\n          AGO   .IIXIS1\n.IINIS1   ANOP\n         TM    II@FLAGS,II@ISPF         WAS PARM=ISPF GIVEN?\n         BNO   II$NOSPF                 NO - DON'T EVEN TRY\n         L     R3,CVTPTR                -> CVT\n         LM    R0,R1,=CL8'ISPLINK'      CL8'ISPLINK'\n         L     R15,CVTLPDSR-CVTMAP(,R3) -> LPA SEARCH ROUTINE\n         STM   R2,R11,II@REGS           save some regs\n         BALR  R14,R15                  CALL IT\n         B     II$ISPLP                 +0 ==> FOUND IN LPA\n*                                       +4 ==> NOT FOUND\n         LM    R2,R11,II@REGS           reload regs after LPA search\n*---  DO BLDL FOR ISPLINK, TO AVOID TACKY 806 MESSAGE IF SPF IS    ---*\n*---  NOT INSTALLED                                                ---*\n         MVC   II@BLDL(4),=H'1,12'      SET NUMBER, LENGTH\n         MVC   II@BLDLN,=CL8'ISPLINK'   SET MEMBER NAME\n         SPACE 1\n         BLDL  0,II@BLDL                TRY TO FIND ISPLINK\n         SPACE 1\n         LTR   R15,R15                  IS IT AVAILABLE?\n         BNZ   II$NOSPF                 NO - SKIP\n*\n         LOAD  DE=II@BLDL+4             load ISPLINK\n*\n         ST    R0,ISPLNK                save address\n         B     II$ISPGO                 continue\n         SPACE 2\nII$ISPLP LM    R2,R11,II@REGS           reload regs after LPA search\n*\n         LOAD  EPLOC==CL8'ISPLINK'      ask MVS where it is\n*\n         ST    R0,ISPLNK                save address\n.IIXIS1   ANOP\n         SPACE 2\nII$ISPGO MVC   II@VLEN,=F'32'           set area length\n         L     R15,ISPLNK               get address\n         CALL  (15),(=CL8'VCOPY',=CL8'(ZENVIR)',II@VLEN,QPFIND,        $\n               =CL8'MOVE'),VL,                                         $\n               MF=(E,II@CALLP)\n         LTR   R15,R15                  is var defined and no trunc?\n         BZ    SP23A1       >========+  yes, so check version\n         CH    R15,=H'16'            |  did trunc occur?\n         BNE   II$XXSPF              |  no, so not found\nSP23A1   CLC   QPFIND(4),=C'ISPF'  <=+  does variable look ok?\n         BNE   II$XXSPF                 no - assume old ISPF\n         CLC   QPFIND+5(3),=C'2.3'      is envir ISPF 2.3 or higher?\n         BL    II$XXSPF                 no - is prior to version 2.3\n         OI    QISFLAG1,QIS1V23         yes - remember version 2.3\n         CLC   QPFIND+5(3),=C'3.2'      is envir ISPF 3.2 or higher?\n         BL    II$XXSPF                 no - is prior to version 3.2\n         OI    QISFLAG1,QIS1V32         yes - remember version 3.2\n         SPACE 2\nII$XXSPF CLC   BRWEPARM,=F'0'           do we have TLD address?\n         BNE   II$NOSPF                 yes - ok\n         TM    QISFLAG1,QIS1V32         no - do we need it?\n         BNZ   II$NOSPF                 no - ok\n         MVI   QISFLAG1,0               yes - can't use ISPF interface\n         SPACE 1\n         DROPX R15,R14                  SSCT, SSVT\n***********************************************************************\n*                                                                     *\n*   Load OACFSORT quicksort routine                                   *\n*                                                                     *\n***********************************************************************\nII$NOSPF DC    0H'0'\n          AIF   ('&@@OACFS' EQ '').II080\n         LOAD  EPLOC==CL8'&@@OACFS',ERRET=II$806  load sort routine\n         ST    R0,QVSORT                save ptr to sort\n.II080    ANOP\n         B     II$BLKTB                 continue\n         SPACE 1\nII$806   L     R1,=A(II#MSG10)          -> msg\n         TPUT  (1),L'II#MSG10           output it\n         ABEND 90                       die\n***********************************************************************\n*                                                                     *\n*   Obtain Block tables for LISTDS, and DDNAME                        *\n*                                                                     *\n***********************************************************************\nII$BLKTB L     R0,QCSIZE                GET TABLE SIZE\n         SPACE 1\n         GETMAIN  RC,LV=(0),SP=1        TRY TO GET BLOCK ADDR TABLE\n         SPACE 1\n         LTR   R15,R15                  DID I GET IT?\n         BNZ   II$SMALL                 NO - COMPLAIN AND LEAVE NO DUMP\n         ST    R1,QCSTART               STORE STARTING ADDR OF TABLE\n         L     R0,QDSIZE                GET TABLE SIZE\n         SPACE 1\n         GETMAIN  RC,LV=(0),SP=1        TRY TO GET BLOCK ADDR TABLE\n         SPACE 1\n         LTR   R15,R15                  DID I GET IT?\n         BNZ   II$SMALL                 NO - COMPLAIN AND LEAVE NO DUMP\n         ST    R1,QDSTART               STORE STARTING ADDR OF TABLE\n***********************************************************************\n*                                                                     *\n*   ALLOCATE HASPCKPT                                                 *\n*                                                                     *\n***********************************************************************\n         MVC   QDSNSPC+2(16),QBLANK     CLEAR DSN\n         MVC   QDSNCKPT+2(17),QBLANK    CLEAR DSN\n         LA    R1,QCKPTPFX              -> PREFIX\n         LA    R14,QDSNSPC+2            -> DEST\n         LA    R15,QDSNCKPT+2           -> DEST\n         LA    R0,44                    MAX NUMBER OF CHARS TO MOVE\n         SPACE 1\nII$MVPFX MVC   0(1,R14),0(R1)           MOVE 1 CHAR OF PREFIX\n         MVC   0(1,R15),0(R1)           ...\n         LA    R14,1(,R14)              BUMP PTR\n         LA    R15,1(,R15)              ...\n         LA    R1,1(,R1)                -> NEXT CHAR OF PREFIX\n         CLI   0(R1),C' '               END OF PREFIX?\n         BH    II$MVPFX                 NO - CONTINUE\n***      MVC   0(8,R14),=C'.HASPACE'    FINISH DSN\n         MVC   0(L'II#HSSFX,R14),II#HSSFX  FINISH DSN\n***      MVC   0(9,R15),=C'.HASPCKPT'   ...\n         MVC   0(L'II#CKSFX,R15),II#CKSFX  ...\n***      LA    R14,QDSNCKPT+2-9         COMPUTE LENGTH ...\n***      SR    R15,R14                  ... OF HASPCKPT DSN\n***      STH   R15,QDSNCKPT             SAVE FOR DAIR\n***      BCTR  R15,0                    COMPUTE LENGTH OF HASPACE DSN\n***      STH   R15,QDSNSPC              SAVE FOR DAIR\n         MVC   QDSNCKPT,=H'44'          tell DAIR the length\n         MVC   QDSNSPC,=H'44'           ...\n         SPACE 1\n         MVC   DA08SER(6),QCKPTVOL      MOVE IN HASPCKPT VOLSER\n         LA    R15,QDSNCKPT             -> DSNAME FOR ALLOCATE\n         ST    R15,DA08PDSN             SET IN DAIR BLOCK\n         MVI   DAIRFLAG,X'08'           REQUEST ALLOCATE FUNCTION\n          AIF   (&QLEVEL LT 8).II50A\n***%%%   TM    QKFLAG,QKFKAC            Doing incore\n***%%%   BO    II$KMST                  Yes so skip alloc\n.II50A    ANOP\n         QCALL ALLOCATE                 CALL DAIR\n***********************************************************************\n*                                                                     *\n*   OPEN HASPCKPT, READ FIRST BLOCK OF CHECKPOINT                     *\n*                                                                     *\n***********************************************************************\n         L     R3,QCCKPT                -> HASPCKPT DCB\n         USNGX IHADCB,R3\n          AIF   (&QLEVEL LT 4).II090\n         DEVTYPE  DA08DDN,DVAREA,DEVTAB,RPS  GET DEVICE TYPE INFO\n         SPACE 1\n         L     R0,DVAMAXRC              MAX BLKSIZE FOR DEVICE\n         STH   R0,DCBBLKSI              SET BLKSIZE IN CKPT DCB\n.II090    ANOP\n         MVC   DCBDDNAM,DA08DDN         GET DDNAME DAIR RETURNED\n         LA    R1,II#EXLST              -> DCB EXIT LIST\n         STCM  R1,B'0111',DCBEXLSA      SET INTO DCB\n         BAL   R14,QAMODE24             change to AMODE 24\n         SPACE 1\n         OPEN  MF=(E,QCCKPT)            OPEN HASPCKPT\n         SPACE 1\n         BAL   R14,QAMODE31             resume AMODE 31\n*  IT MIGHT BE NICE TO CHECK TO SEE THAT IT OPENED!!!!\n          AIF   (&QLEVEL LT 4).II110\n          AIF   (&QLEVEL LT 8).II100\n         SPACE 1\n*\n*        FORMAT OF CHECKPOINT MASTER RECORD\n*        $SAVEBEG - START OF HCT AREA\n*                   ($SAVELEN LONG)\n*        QSE1     - START OF QSE AREA\n*                   (QSELEN*$QSEMAX)\n*        $JQEEXT  - START OF JQE EXTENSION\n*                   ($MAXEXSZ)\n*        $DASEXT  - START OF DAS EXTENSIONS\n*                   (DASEXLEN*$SPOLNUM)\n*        $KITPTR  - POINTER TO CHECKPOINT INFO TABLES\n*                   ($KITNUM*KITLNGTH)\n*        $CTLB    - POINTER TO CHECKPT I/O CONTROL BYTES\n*\n         SPACE 1\n.II100    ANOP\n**??**?? LA    R2,DVATAB                -> DEVTYPE INFO FOR TRKCALC\n         SR    R2,R2                    CLEAR FOR ICM\n         ICM   R2,B'0111',DCBDVTBA      -> DEVTYPE INFO\n         L     R4,=X'01001000'          # OF 4K BLOCKS/TRK\n         XC    II@TRKCA(II@TRKCL),II@TRKCA  CLEAR MF=L AREA\n         SPACE 1\n         TRKCALC  FUNCTN=TRKCAP,DEVTAB=(R2),RKDD=(R4),REGSAVE=YES,     $\n               MF=(E,II@TRKCA)\n         SPACE 1\n         ST    R0,II@CKRT               SAVE # 4K BLKS/TRK ON CKPT\n.II110    ANOP\n         SPACE 1\n*---  GETMAIN DECB WORK AREA FOR CKPT ROUTINE                      ---*\n         SR    R0,R0                    CLEAR FOR IC\n         IC    R0,DCBNCP                GET NCP VALUE FROM DCB\n*%%%     LTR   R0,R0                    ANYTHING THERE?\n*%%%     BNZ   *+8                      YES - USE IT\n*%%%     LA    R0,&QCHKNCP              NO - USE GENNED DEFAULT VALUE\n         MH    R0,=Y(HDECB1L)           * LENGTH OF EACH DECB\n         ST    R0,QLCKDECB              SAVE LENGTH FOR FREEMAIN\n         ICM   R0,B'1000',=AL1(1)       SUBPOOL 1\n         GETMAIN  R,LV=(0)\n         ST    R1,QVCKDECB              SAVE ADDR (ALSO FOR FREEMAIN)\n         TM    QKFLAG,QKFKAC            Doing incore?\n         BO    II$KMST                  yes - skip disk READ\n         BAL   R14,QAMODE24             change to AMODE 24\n         SPACE 1\n         POINT (R3),=FS8'3'             POINT PAST SYNC RECORDS TO REC3\n         SPACE 1\n         L     R1,QCDECB1               -> HASPCKPT DECB\n         L     R2,QCSTART               USE TABLE AREA FOR IOAREA\n         SPACE 1\n         READ  (1),SF,,(R2),MF=E        READ FIRST RECORD\n         SPACE 1\n         L     R1,QCDECB1               -> HASPCKPT DECB\n         SPACE 1\n         CHECK (1)\n         SPACE 1\n         BAL   R14,QAMODE31             resume AMODE 31\n         SPACE 3\n         DROPX R3                       IHADCB\n         USNGX $SAVEBEG,R2              BASE REG FOR CHECKPOINT\n          AIF   (&QLEVEL LT 7).II120    %%%\n          AIF   (&QLEVEL LT 8).II50B\n         B     II$KMSTE                 skip over if using DASD\n*\n*\n*\nII$KMST  DS    0H                       Get Master from incore\n         LA    R1,4                     Get authorized\n         QCALL AUTHFUNC\n         MODESET KEY=ZERO,MODE=SUP      Get key=0\n         L     R2,QCSTART               get temp area\n         L     R3,QCKMLEN               get length\n         L     R1,QKACA                 get KAC address\n         L     R0,KACMSTRA-KAC(,R1)     get master record\n         LR    R1,R3\n         MVCL  R2,R0                    move in master\n         MODESET KEY=NZERO,MODE=PROB    Out of supervisor state\n         LA    R1,8                     release authorization\n         QCALL AUTHFUNC\n         L     R2,QCSTART               reload table area for mstr\nII$KMSTE DS    0H\n.II50B    ANOP\n         MVC   QCJQELEN,$JQELEN         SAVE JQE LENGTH\n          AGO   .II130                  %%%\n.II120    ANOP\n         MVC   QCJQELEN,=Y(JQELNGTH)    SET JQE LENGTH\n.II130    ANOP\n          AIF   (&QLEVEL LT 4).II140\n         MVC   QCLNODE,$NODEID          SAVE OUR LOCAL NODE NUMBER\n.II140    ANOP\n         CLC   =C'JES2',$HASPID         ID IN CORRECT PLACE?\n         BE    II$HIDOK                 YES - CONTINUE\n         L     R1,=A(II#MSG9)           -> MSG TEXT\n         TPUT  (1),L'II#MSG9            'WRONG VERSION'\n         ABEND 91\nII$HIDOK DC    0H'0'\n          AIF   (&QLEVEL LT 8).II150\n***********************************************************************\n*                                                                     *\n*   Compute size of track group maps on ckpt                          *\n*                                                                     *\n***********************************************************************\n         L     R5,$NUMTG                NUMBER OF TRACK GROUPS TOTAL\n         LA    R5,7(,R5)                round up!!                *LDW*\n         SRL   R5,3                     DIVIDE BY 8\n         LR    R1,R5                    SAVE LENGTH OF TRACK GROUP MAP\n         SLL   R1,1                     NUMBER OF BYTES * 2\n         LA    R1,BFPLEN(,R1)           ADD BUFFER PREFIX\n         LA    R1,4095(,R1)             PREPARE TO ROUND\n         SRL   R1,12                    DIVIDE BY 4K\n         STH   R1,QCTGML                NUMBER OF BLOCKS FOR TG MAPS\n          AGO   .II250\n.II150    ANOP\n***********************************************************************\n*                                                                     *\n*   COMPUTE OFFSET TO FIRST PDDB IN IOT                               *\n*                                                                     *\n***********************************************************************\n          AIF   (&QLEVEL GE 4).II160\n         LH    R5,$NUMTGV               NUMBER OF TRK GROUPS PER VOLUME\n         LA    R5,7(,R5)                ROUND UP TO MULTIPLE OF 8\n         SRL   R5,3                     DIVIDE BY 8\n         SR    R0,R0                    CLEAR FOR IC\n         IC    R0,$NUMDA                NUMBER OF SPOOL VOLUMES\n         MR    R4,R0                    LENGTH OF TRK GROUP MAP IN R5\n         MH    R0,$NUMTGV               * number of trk grps/vol\n         ST    R0,QCNUMTGA              save for later\n          AGO   .II170\n.II160    ANOP\n         LH    R5,$NUMTG                NUMBER OF TRK GROUPS PER VOLUME\n         LA    R5,7(,R5)                ROUND UP TO MULTIPLE OF 8\n         SRL   R5,3                     DIVIDE BY 8\n.II170    ANOP\n         STH   R5,QCTGMLEN              SAVE LENGTH OF TRACK GROUP MAP\n          AIF   (&QLEVEL GE 5).II180\n         LA    R5,IOTTGMAP-IOTSTART+TGMAP-TGMDSECT+3(,R5)   OFFSET\n         N     R5,=F'-4'                ROUND TO FULL WORD BOUNDARY\n         ST    R5,QCPDDB1               SAVE OFFSET TO 1ST PDDB IN IOT\n         SPACE 1\n          AIF   (&QLEVEL LT 4).II240\n         LH    R0,$NUMTG                GET TOTAL NUMBER OF TRK GROUPS\n         ST    R0,QCNUMTGA              SAVE AS NUMBER OF ACT TRK GRPS\n         SPACE 1\n.II180    ANOP\n***********************************************************************\n*                                                                     *\n*   COMPUTE SIZE OF DAS AREA ON CHECKPOINT                            *\n*                                                                     *\n***********************************************************************\n          AIF   (&QLEVEL LT 7).II190\n         LH    R15,$SPOLNUM             NUMBER OF SPOOL VOLUMES\n         MH    R15,=Y(DASSIZ)           * SIZE OF EACH DAS\n         QCBLKNUM  R15                  COMPUTE NUMBER OF CKPT RECORDS\n         ST    R15,QCDASL               SAVE # OF BLOCKS FOR DAS\n         L     R1,$NUMTG                NUMBER OF TRK GRPS PER VOLUME\n         SRL   R1,3                     DIVIDE BY 8 = LEN OF TG MAP\n.II190    ANOP\n***********************************************************************\n*                                                                     *\n*   COMPUTE NUMBER OF TRACK GROUP MAPS ON CKPT                        *\n*                                                                     *\n***********************************************************************\n          AIF   (&QLEVEL GE 7).II200\n         LH    R1,QCTGMLEN              GET LENGTH OF TRACK GROUP MAP\n.II200    ANOP\n         AR    R1,R1                    NUMBER OF BYTES * 2\n         QCBLKNUM  R1                   COMPUTE NUMBER OF CKPT RECORDS\n         STH   R1,QCTGML                NUMBER OF BLOCKS FOR TG MAPS\n*%%II%%1  ANOP\n***********************************************************************\n*                                                                     *\n*   COMPUTE NUMBER OF JIX BLOCKS ON CKPT                              *\n*                                                                     *\n***********************************************************************\n         LH    R5,$NUMJBNO              NUMBER OF JOB NUMBERS\n         LA    R5,1(,R5)                PLUS 1 FOR HEADER\n         AR    R5,R5                    TIMES LENGTH OF 2\n         QCBLKNUM  R5                   COMPUTE NUMBER OF CKPT RECORDS\n         STH   R5,QCJIXL                NUMBER OF BLOCKS FOR JIX\n***********************************************************************\n*                                                                     *\n*   FIND KIT AREA IN MASTER RECORD                                    *\n*                                                                     *\n***********************************************************************\n          AIF   (&QLEVEL GT 4).II210\n         L     R3,$MASTERL              LENGTH OF MASTER RECORD\n         AR    R3,R2                    -> PAST END OF MASTER RECORD\n         SH    R3,=Y(KITLNGTH)          -> LAST KIT\n         ST    R3,II@KITL               SAVE ADDR OF LAST KIT\n         USNGX KITDSECT,R3\nII$KIT1L CLC   KITORG,=F'0'             THIS FIRST KIT?\n         BE    II$KIT1F\n         SH    R3,=Y(KITLNGTH)          BACK UP ONE KIT\n         B     II$KIT1L\n         DROPX R3                       KITDSECT\nII$KIT1F ST    R3,II@KITF               SAVE ADDR FIRST KIT\n          AGO   .II230\n.II210   ANOP\n*  REFERENCE HASPIRDA\n          AIF   (&QLEVEL GE 7).II220\n         LA    R1,$SAVELEN(,R2)         -> FIRST QSE\n         LA    R0,QSELEN                LENGTH OF A QSE\n         MH    R0,$QSENO                TOTAL FOR ALL SYSTEMS\n         AR    R1,R0                    -> FIRST DAS\n         A     R1,=A(DASSIZ*$MAXDA)     -> FIRST KIT\n         ST    R1,II@KITF               SAVE ADDR FIRST KIT\n         AH    R1,=Y(KITLNGTH*(7-1))    -> LAST KIT   *KLUDGE*?\n         ST    R1,II@KITL               SAVE ADDR LAST KIT\n          AGO   .II230\n.II220    ANOP\n         LA    R1,$SAVELEN(,R2)         -> FIRST QSE\n         LA    R0,QSELEN                LENGTH OF A QSE\n         MH    R0,$QSENO                TOTAL FOR ALL SYSTEMS\n         AR    R1,R0                    -> JQE EXTENSION AREA\n         AH    R1,$MAXEXSZ              -> FIRST KIT\n         ST    R1,II@KITF               SAVE ADDR FIRST KIT\n         AH    R1,=Y(KITLNGTH*(8-1))    -> LAST KIT   *KLUDGE*?\n         ST    R1,II@KITL               SAVE ADDR LAST KIT\n.II230    ANOP\n         SPACE 1\n*---  FIND JQE TABLE BLOCK #; # OF BLOCKS                          ---*\n         L     R0,=CL4'JQE '            ID FOR JQE'S\n         BAL   R14,II$KITFD             SEARCH KIT FOR JQE SLOT\n         EX    0,*                      DIE IF SYSTEM HAS NO JQE'S\n         USNGX KITDSECT,R1\n         LH    R6,KITRECN               # OF BLOCKS OF JOE'S\n         ST    R6,QCJQENUM              SAVE # BLOCKS OF JQE'S\n         BAL   R14,II$CKTTR             COMPUTE TTR OF JQE'S\n         DROPX R1                       KITDSECT\n         ST    R1,QCJQETTR              SAVE TTR OF JQE'S\n         SPACE 1\n*---  FIND JOE TABLE BLOCK #; # OF BLOCKS                          ---*\n         L     R0,=CL4'JOE '            ID FOR JOE'S\n         BAL   R14,II$KITFD             SEARCH KIT FOR JQE SLOT\n         EX    0,*                      DIE IF SYSTEM HAS NO JQE'S\n         USNGX KITDSECT,R1\n         LH    R3,KITRECN               # OF BLOCKS OF JOE'S\n         ST    R3,QCJOENUM              SAVE # OF BLOCKS OF JOE'S\n         BAL   R14,II$CKTTR             COMPUTE TTR OF JOE'S\n         DROPX R1                       KITDSECT\n         ST    R1,QCJOETTR              SAVE TTR OF JOE'S\n         SPACE 1\n*%%%%%%%  AIF   (&QLEVEL LT 5).II%%2\n.II240    ANOP\n.II250    ANOP\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*   OBTAIN SYSTEM ID'S FROM QSE'S                                     *\n*                                                                     *\n***********************************************************************\n         LA    R15,$SAVEEND             -> FIRST QSE\n         USNGX QSEDSECT,R15\n         LA    R14,QSMFID               -> SYSTEM ID TABLE ZERO'TH ENT\n         LH    R0,$QSENO                NUMBER OF MEMBERS IN THIS NODE\n         SPACE 1\nII$QSELP LA    R14,L'QSMFID(,R14)       -> NEXT SYSTEM ID TABLE ENTRY\n         MVC   0(4,R14),QSESID          SAVE SYSTEM ID\n         LA    R15,QSELEN(,R15)         -> NEXT QSE\n         BCT   R0,II$QSELP              DO ALL QSE'S\n         DROPX R15                      QSEDSECT\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*   TRANSLATE SMF ID'S TO USER FRIENDLY NAMES                         *\n*                                                                     *\n***********************************************************************\n         MVC   QSYSID(L'QSYSID*8),QSMFID  COPY THE WHOLE TABLE\n         LA    R0,8                     NUMBER OF TABLE ENTRIES\n         LA    R14,QSYSID               -> FIRST ONE\nII$QSEL2 LA    R15,SMFTABLE             -> TRANSLATION TABLE\nII$QSEL3 CLI   0(R15),X'FF'             END OF TABLE?\n         BE    II$QSEN2                 YES - GIVE UP AND TRY NEXT ID\n         CLC   0(4,R14),0(R15)          THIS IT?\n         BNE   II$QSEN1                 NO - TRY NEXT TRANS TABLE ENTRY\n         MVC   0(4,R14),4(R15)          YES - USE USER FRIENDLY NAME\n         B     II$QSEN2                 AND PROCESS NEXT ID\nII$QSEN1 LA    R15,8(,R15)              -> NEXT TRANSLATION TABLE ENTRY\n         B     II$QSEL3                 KEEP LOOKING\nII$QSEN2 LA    R14,L'QSYSID(,R14)       -> NEXT SMF ID TO TRANSLATE\n         BCT   R0,II$QSEL2              DO IT\n         SPACE 1\n          AIF   (&QLEVEL GE 8).II310\n***********************************************************************\n*                                                                     *\n*   COMPUTE NUMBER OF JQE BLOCKS ON CKPT                              *\n*                                                                     *\n***********************************************************************\n         LH    R6,$MAXJOBS              NUMBER OF JQES\n         LA    R6,1(,R6)                PLUS 1 FOR EYE-CATCHER\n          AIF   (&QLEVEL GE 7).II260\n         MH    R6,=AL2(JQELNGTH)        MULTIPLY BY LENGTH OF JQE\n         QCBLKNUM  R6                   COMPUTE NUMBER OF CKPT RECORDS\n          AGO   .II270\n.II260    ANOP\n         MH    R6,=Y(JQEBLEN+4)         MULTIPLY BY LENGTH OF JQE\n*                                       ... ASSUMING 1 WORD FOR ...\n*                                       ... SPOOLS USED MASK %%%%%\n         QCBLKNUM  R6                   COMPUTE NUMBER OF CKPT RECORDS\n***********************************************************************\n*                                                                     *\n*   COMPUTE NUMBER OF PST BLOCKS IN CKPT                              *\n*                                                                     *\n***********************************************************************\n         LH    R15,$NUMJOES             NUMBER OF JOES\n         QCBLKNUM  R15                  COMPUTE NUMBER OF CKPT RECORDS\n         ST    R15,QCPSTL               SAVE                          \u00a2\n.II270    ANOP\n***********************************************************************\n*                                                                     *\n*   COMPUTE NUMBER OF JOT BLOCKS IN CKPT                              *\n*                                                                     *\n***********************************************************************\n         LH    R3,$NUMJOES              NUMBER OF JOES\n*  I THINK CL DID THIS WRONG... <LDW>   %%%%\n*%%       AIF   (&QLEVEL LT 7).II280\n*%%      LA    R3,NJOTPRFX(,R3)         ADJUSTED LENGTH OF JOT PREFIX\n.II280    ANOP\n         MH    R3,=AL2(JOESIZE)         MULTIPLY BY LENGTH OF JOE\n*  CL DIDN'T HAVE THIS INSTRUCTION:     %%%%\n         LA    R3,JOTJOES-JOTDSECT(,R3) ADD LENGTH OF JOT PREFIX AREA\n         QCBLKNUM  R3                   COMPUTE NUMBER OF CKPT RECORDS\n***********************************************************************\n*                                                                     *\n*   COMPUTE TOTAL LENGTH OF QSES                                      *\n*                                                                     *\n***********************************************************************\n         LA    R4,QSELEN                QSE LENGTH\n         MH    R4,$QSEMAX               LENGTH TIMES NUMBER OF QSES\n          AIF   (&QLEVEL GE 5).II300\n          AIF   (&QLEVEL LT 4).II290\n         ALR   R4,R5                    ADD ONE BYTE FOR EACH JIX BLOCK\n***********************************************************************\n*                                                                     *\n*   COMPUTE NUMBER OF MSQ BLOCKS ON CKPT                              *\n*                                                                     *\n***********************************************************************\n         LH    R1,$NUMRJE               NUMBER OF REMOTES\n         MH    R1,=Y(3)                 TIMES LENGTH OF 3\n         LA    R1,3(,R1)                PLUS HEADER LENGTH\n         LA    R1,4095(,R1)             PREPARE TO ROUND\n         SRL   R1,12                    DIVIDE BY 4096\n         ALR   R4,R1                    ADD 1 BYTE FOR EACH BLOCK\n***********************************************************************\n*                                                                     *\n*   COMPUTE NUMBER OF RSO BLOCKS ON CKPT                              *\n*                                                                     *\n***********************************************************************\n         LH    R1,$NUMRJE               NUMBER OF REMOTES\n         LA    R1,4095(,R1)             PREPARE TO ROUND\n         SRL   R1,12                    DIVIDE BY 4096\n         ALR   R4,R1                    ADD 1 BYTE FOR EACH BLOCK\n***********************************************************************\n*                                                                     *\n*   COMPUTE NUMBER OF LCK BLOCKS ON CKPT                              *\n*                                                                     *\n***********************************************************************\n*%%%%%   LH    R1,$NUMLCK               NUMBER OF LOAD CKPT ELEMENTS\n         LA    R1,9*7                   NUMBER OF LOAD CKPT ELEMENTS\n         MH    R1,=Y(LCKSIZE)           TIMES LENGTH OF EACH\n         LA    R1,4095(,R1)             PREPARE TO ROUND\n         SRL   R1,12                    DIVIDE BY 4096\n         ALR   R4,R1                    ADD 1 BYTE FOR EACH BLOCK\n.II290    ANOP\n         ALR   R4,R6                    ADD ONE BYTE FOR EACH JQE BLOCK\n         ALR   R4,R3                    ADD ONE BYTE FOR EACH JOT BLOCK\n.II300    ANOP\n.II310    ANOP\n***********************************************************************\n*                                                                     *\n*   COMPUTE HASPACE BUFFER SIZE                                       *\n*                                                                     *\n***********************************************************************\n         LH    R5,$BUFSIZE              BLKSIZE FOR HASPACE\n         L     R1,QCDECB2               -> HASPACE DECB\n         STH   R5,6(,R1)                STORE IN DECB\n         STH   R5,QCHSBLK               SAVE IN QCOMMON\n         LA    R5,63(,R5)               PREPARE TO ROUND\n         N     R5,=F'-64'               ROUND TO 64 BYTE BOUNDARY\n***********************************************************************\n*                                                                     *\n*   OBTAIN BUFFERS FOR HASPCKPT AND HASPACE                           *\n*                                                                     *\n***********************************************************************\n         LR    R14,R5                   HASPACE BUFFER SIZE\n         MH    R14,=H'3'                3 BUFFERS\n          AIF   (&QLEVEL GE 8).II330\n         LA    R1,1(R6,R3)              NUMBER OF BLOCKS IN CKPT DS\n          AIF   (&QLEVEL LT 4).II320\n         AH    R1,QCJIXL                ADD NUMBER OF JIX BLOCKS\n          AIF   (&QLEVEL LT 5).II320\n         AH    R1,QCTGML                ADD NUMBER OF TGM BLOCKS\n          AIF   (&QLEVEL LT 7).II320\n         A     R1,QCDASL                ADD NUMBER OF DAS BLOCKS      \u00a2\n         A     R1,QCPSTL                ADD NUMBER OF PST BLOCKS      \u00a2\n.II320    ANOP\n          AGO   .II340\n.II330    ANOP\n         LH    R1,$CKRECN               number of 4K records\n         LA    R1,1(,R1)                plus master record\n         AH    R1,$CLRECN               plus number of change log recs\n.II340    ANOP\n         ST    R1,QCJOTL                STORE RECORD COUNT\n         SLL   R1,12                    MULTIPLY BY 4096\n          AIF   (&QLEVEL LT 4).II350\n         L     R15,$MASTERL             GET LENGTH OF MASTER RECORD\n         LA    R15,4095(,R15)           PREPARE TO ROUND\n         SRL   R15,12                   ROUND TO 4K\n         SLL   R15,12                   GET BACK AS MULT OF 4K\n         ST    R15,QCSMLEN              SAVE FOR LATER\n         AR    R1,R15    %%%???%%%      INCREMENT SIZE TO GETMAIN     \u00a2\n          AGO   .II360\n.II350    ANOP\n         MVC   QCSMLEN,=F'4096'         SET MASTER RECORD LENGTH\n.II360    ANOP\n         LA    R7,256(R1,R14)           ADD CKPT & HASPACE BFRS, SLOP\n         ST    R7,QCKPTLEN              SAVE LENGTH FOR FREEMAIN\n         GETMAIN  RU,LV=(R7),SP=1       OBTAIN BUFFERS\n         ST    R1,QCJQTL                BUFFER FOR FIRST CKPT REC\n          AIF   (&QLEVEL LT 8).II370\n         TPUTX '>>> initial calling ckpt'  %debug\n         MVC   QDMSG(11),=C'>>> (qkaca='   %debug\n         HEX   QDMSG+11,QKACA,LEN=4,BYTE=C')',HEXTAB=QHEXTAB  %debug\n         TPUTX QDMSG,20                 %debug\n         MVC   QDMSG,QBLANK             %debug\n         QCALL CKPT                     read ckpt data\n         TPUTX '>>> initial back from ckpt'  %debug\n         L     R1,QCJQTL                restore buffer address\n         LA    R4,QSELEN                QSE length\n         MH    R4,$QSEMAX               * number of QSEs\n.II370    ANOP\n          AIF   (&QLEVEL LT 7).II380\n         LR    R14,R1                   COMPUTE ADDR OF JQE EXTENSION\n         LA    R14,$SAVELEN(,R14)       ACCOUNT FOR CHECKPOINTED HCT\n         AR    R14,R4                   ACCOUNT FOR QSE'S\n         ST    R14,QCJQEXA              SAVE ADDR OF JQE EXTENSION\n.II380    ANOP\n          AIF   (&QLEVEL GT 3).II390\n         AH    R1,=H'4096'              INCREMENT\n          AGO   .II460\n.II390    ANOP\n         A     R1,QCSMLEN               ADD ROUNDED LENGTH OF MSTR REC\n          AIF   (&QLEVEL LT 8).II400\n*%%%     TM    QKFLAG,QKFKAC            If incore - no change blks\n*%%%     BO    II$NOCKB\n         LH    R15,$CLRECN              number of change log blks\n         SLL   R15,12                   * 4k\n         AR    R1,R15                   bump past change log\nII$NOCKB DS    0H\n*---\n         LA    R15,=CL4'TGM'            -> pool id\n         BAL   R14,II$CK$PI             check pool id\n         ST    R0,QCTGMA                buffer for TGM blocks\n*---\n         LA    R15,=CL4'JIX'            -> pool id\n         BAL   R14,II$CK$PI             check pool id\n         ST    R0,QCJIXA                buffer for JIX blocks\n*---\n         LA    R15,=CL4'JQE'            -> pool id\n         BAL   R14,II$CK$PI             check pool id\n         ST    R0,QCJQTA                buffer for JQE blocks\n*---\n         LA    R15,=CL4'PST'            -> pool id\n         BAL   R14,II$CK$PI             check pool id\n         ST    R0,QCPSTA                buffer for PST blocks\n*---\n         LA    R15,=CL4'JOE'            -> pool id\n         BAL   R14,II$CK$PI             check pool id\n         ST    R0,QCJOTA                buffer for JOE blocks\n*---\n         LA    R15,=CL4'RSO'            -> pool id\n         BAL   R14,II$CK$PI             check pool id\n**       ST    R0,                      buffer for RSO blocks\n*---\n         LA    R15,=CL4'LCK'            -> pool id\n         BAL   R14,II$CK$PI             check pool id\n**       ST    R0,                      buffer for LCK blocks\n*---\n         LA    R15,=CL4'DAS'            -> pool id\n         BAL   R14,II$CK$PI             check pool id\n         ST    R0,QCDASA                buffer for DAS blocks\n*---\n          AGO   .II510\n.II400    ANOP\n          AIF   (&QLEVEL LT 5).II430\n          AIF   (&QLEVEL GE 7).II410\n         ST    R1,QCTGMA                BUFFER FOR TGM BLOCKS\n          AGO   .II420\n.II410    ANOP\n         LA    R0,BFPLEN(,R1)           ADD BUFFER PREFIX\n         ST    R0,QCDASA                BUFFER FOR DAS BLOCKS\n         L     R15,QCDASL               NUMBER OF DAS BLOCKS\n         SLL   R15,12                   * 4096\n         AR    R1,R15                   INCREMENT\n         LA    R0,BFPLEN(,R1)           ADD BUFFER PREFIX\n         ST    R0,QCTGMA                BUFFER FOR TGM BLOCKS\n.II420    ANOP\n         LH    R15,QCTGML               NUMBER OF TGM BLOCKS\n         SLL   R15,12                   * 4K\n         AR    R1,R15                   INCREMENT\n.II430    ANOP\n          AIF   (&QLEVEL GE 7).II440\n         ST    R1,QCJIXA                BUFFER FOR JIX BLOCKS\n          AGO   .II450\n.II440    ANOP\n         LA    R0,BFPLEN(,R1)           ADD BUFFER PREFIX\n         ST    R0,QCJIXA                BUFFER FOR JIX BLOCKS\n.II450    ANOP\n         LH    R15,QCJIXL               NUMBER OF JIX BLOCKS\n         SLL   R15,12                   TIMES 4096\n         AR    R1,R15                   INCREMENT\n.II460    ANOP\n          AIF   (&QLEVEL GE 7).II470\n         ST    R1,QCJQTA                BUFFER FOR JQE BLOCKS\n          AGO   .II480\n.II470    ANOP\n         LA    R0,BFPLEN(,R1)           ADD BUFFER PREFIX\n         ST    R0,QCJQTA                BUFFER FOR JQE BLOCKS         \u00a2\n.II480    ANOP\n         SLL   R6,12                    MULTIPLY BY 4096\n         AR    R1,R6                    INCREMENT\n          AIF   (&QLEVEL GE 7).II490\n         ST    R1,QCJOTA                BUFFER FOR JOE BLOCKS\n          AGO   .II500\n.II490    ANOP\n         LA    R0,BFPLEN(,R1)           ADD BUFFER PREFIX\n         ST    R0,QCPSTA                BUFFER FOR PST BLOCKS\n         L     R15,QCPSTL               NUMBER OF PST BLOCKS          \u00a2\n         SLL   R15,12                   TIMES 4096\n         AR    R1,R15                   INCREMENT\n         LA    R0,BFPLEN(,R1)           ADD BUFFER PREFIX\n         ST    R0,QCJOTA                BUFFER FOR JOE BLOCKS\n.II500    ANOP\n         SLL   R3,12                    MULTIPLY BY 4096\n         LA    R3,1(,R3)                add in other from above\n         AR    R1,R3                    INCREMENT\n.II510    ANOP\n         ST    R1,QCJCTA                BUFFER FOR JCT\n         AR    R1,R5                    INCREMENT\n         ST    R1,QCIOTA                BUFFER FOR IOT\n         AR    R1,R5                    INCREMENT\n         ST    R1,QCBLKA                BUFFER FOR DATA BLOCKS\n         LA    R1,$JQHEADS-$SAVEBEG     OFFSET TO FIRST JQE HEADER\n         A     R1,QCJQTL                BASE OF FIRST CKPT REC\n         ST    R1,QCJQHEAD              ADDR OF FIRST JQE HEADER\n          AIF   (&QLEVEL LT 11).II511\n         GETMAIN  RU,LV=(R5),SP=1\n         ST    R1,QCJCTNJH              -> NJE sections\n         ST    R5,QLJCTNJE              save for freemain\n         MVC   QCJCTNJN,=H'1'           start with 1 buffer\n.II511    ANOP\n***********************************************************************\n*                                                                     *\n*   ALLOCATE AND OPEN HASPACE                                         *\n*                                                                     *\n***********************************************************************\n         LA    R15,QDSNSPC              -> DSNAME FOR ALLOCATE\n         ST    R15,DA08PDSN             SET IN DAIR BLOCK\n          AIF   (&QLEVEL GE 8).II550\n          AIF   (&QLEVEL GE 7).II540\n          AIF   (&QLEVEL EQ 4).II520\n         LA    R3,$SAVEEND(R4)          -> DA CKPT INFO IN MASTER REC\n          AIF   (&QLEVEL GE 4).II530\n         SR    R4,R4                    CLEAR FOR IC\n         IC    R4,$NUMDA                MAXIMUM NUMBER OF SPOOL VOLUMES\n          AGO   .II570\n.II520    ANOP\n         LH    R1,$QSENO                # OF QSE'S\n         MH    R1,=Y(QSELEN)            * LENGTH OF EACH QSE\n         AH    R1,$CKRECN               + TOTAL # 4K CKPT RECORDS\n         LA    R3,$SAVEEND(R1)          -> DA CKPT INFO IN MASTER REC\n.II530    ANOP\n         LA    R4,$MAXDA                MAXIMUM NUMBER OF SPOOL VOLUMES\n          AGO   .II570\n.II540    ANOP\n         L     R3,QCJQTL                -> IOAREA FOR CKPT RECORDS\n         A     R3,QCSMLEN               -> DAS INFO AREA\n         L     R1,QCDECB1               -> HASPCKPT DECB\n         BAL   R14,QAMODE24             change to AMODE 24\n         SPACE 1\n         READ  (1),SF,,(R3),MF=E        READ DAS\n         SPACE 1\n         L     R1,QCDECB1               -> HASPCKPT DECB\n         SPACE 1\n         CHECK (1)\n         SPACE 3\n         BAL   R14,QAMODE31             resume AMODE 31\n         LA    R3,BFPLEN(,R3)           SKIP OVER BUFFER PREFIX\n          AGO   .II560\n.II550    ANOP\n         L     R3,QCDASA                -> DAS area\n.II560    ANOP\n         LH    R4,$SPOLNUM              NUMBER OF SPOOL VOLUMES ALLOWED\n.II570    ANOP\n*        LA    R7,QCDCBL                LENGTH OF HASPACE DCB\n         LA    R7,QCDCBL+4+4+1          len of dcb + support tables\n         MR    R7-1,R4                  COMPUTE LENGTH OF DCB POOL\n         ST    R7,QLSPDCB               SAVE LENGTH FOR FREEMAIN\n         GETMAIN  RU,LV=(R7),SP=1       OBTAIN DCB POOL\n         ST    R1,QVSPDCB               SAVE ADDRESS FOR FREEMAIN\n*        LR    R7,R1                    SAVE ADDR OF DCB POOL\n*        LA    R5,QCSPOOLS-4            ADDR OF OPEN LIST\n         ST    R1,QCEXTMAP              -> Extent map table\n         MVI   0(R1),X'FF'              invalid entry\n         MVC   1(*-*,R1),0(R1)          prop 1 byte\n         EX    R4,*-6                   do it all (slop is ok)\n         AR    R1,R4                    -> Open list\n         LA    R1,3(,R1)                +3\n         N     R1,=A(X'FFFFFFFC')       round down to fw\n         ST    R1,QCSPOOLS              save it\n         LR    R5,R1                    copy ptr\n         LR    R7,R4                    copy number of entries\n         SLL   R7,2                     * entry len\n         AR    R1,R7                    -> tracks/cyl table\n         ST    R1,QCTRKCYL\n         AR    R7,R1                    -> DCB pool\n         SH    R5,=H'4'                 Back up 1 entry\n         SR    R6,R6                    ACTUAL NUMBER OF SPOOL VOLUMES\n          AIF   (&QLEVEL GE 7).II580\n         MVC   DA08SER(5),$SPOOL        PATTERN FOR VOLSER\n.II580    ANOP\n         DROPX R2                       $SAVEBEG\n         SPACE 1\n          AIF   (&QLEVEL GE 5).II590\nII$SPL1  CLI   0(R3),0                  IS THIS VOLUME UNUSED?\n         BE    II$SPL4                  YES. TRY NEXT.\n         CLI   0(R3),X'FF'      %%%     WAS THIS VOLUME REMOVED?\n         BE    II$SPL4          %%%     YES. TRY NEXT.\n          AGO   .II600\n.II590    ANOP\n         USNGX DASDSECT,R3\nII$SPL1  TM    DASFLAG,DASEXSTS         DOES VOLUME EXIST?\n         BZ    II$SPL4                  NO - SKIP THIS ONE\n         TM    DASFLAG2,DASINACT        IS IT INACTIVE?\n         BO    II$SPL4                  YES - SKIP IT\n          AIF   (&QLEVEL LT 5).II600\n         LH    R15,DASNOTGE             NUMBER OF TRACKS IN EXTENT\n         A     R15,QCNUMTGA             ACCUMULATE ACTIVE ...\n         ST    R15,QCNUMTGA             ... TRACK GROUP COUNT\n.II600    ANOP\n         LA    R5,4(,R5)                -> NEXT ENTRY IN OPEN LIST\n         MVC   DA08UNIT,=C'SYSALLDA'    MOVE UNIT NAME\n          AIF   (&QLEVEL GE 7).II620\n          AIF   (&QLEVEL GE 5).II610\n         MVC   DA08SER+5(1),1(R3)       LAST DIGIT OF VOLSER\n          AGO   .II630\n.II610    ANOP\n         MVC   DA08SER+5(1),DASVOLID+5  LAST DIGIT OF VOLSER\n          AGO   .II630\n.II620    ANOP\n         MVC   DA08SER(6),DASVOLID      VOLSER OF THIS SPOOL VOLUME\n.II630    ANOP\n         LA    R6,1(,R6)                INCREASE COUNT BY ONE\n         QCALL ALLOCATE                 CALL DAIR\n         L     R1,=A(HASPACE)           -> PATTERN DCB\n         MVC   0(QCDCBL,R7),0(R1)       MOVE PATTERN DCB TO POOL\n         MVC   40(8,R7),DA08DDN         UPDATE THE DDNAME\n         MVC   62(2,R7),QCHSBLK         SET THE BLKSIZE\n         ST    R7,0(,R5)                STORE DCB ADDR IN OPEN LIST\n*---  DETERMINE NUMBER OF TRKS/CYL FOR THIS DEVICE                 ---*\n         DEVTYPE  DA08DDN,DVAREA,DEVTAB,RPS  GET DEVICE TYPE INFO\n*        MVC   QCTRKCYL+2-QCSPOOLS(2,R5),DVATRK  SAVE TRKS/CYL\n         LR    R15,R5                   copy dcb ptr\n         S     R15,QCSPOOLS             get offset\n         LR    R14,R15                  save for a sec\n         A     R15,QCTRKCYL             -> correct entry\n         MVC   2(2,R15),DVATRK          copy trks/cyl\n         SRL   R14,2                    byte entry\n          AIF   (&QLEVEL GE 5).II640\n         LR    R15,R14                  copy for a sec\n          AGO   .II650\n.II640    ANOP ,\n         XR    R15,R15                  clear\n         IC    R15,DASEXTNO             get extent no\n.II650    ANOP ,\n         A     R15,QCEXTMAP             -> correct extent desc\n         STC   R14,0(,R15)              set correct ext no.\n         LA    R7,QCDCBL(,R7)           INCREMENT TO NEXT DCB\n          AIF   (&QLEVEL GE 5).II660\nII$SPL4  LA    R3,6(,R3)                NEXT VOLUME\n          AGO   .II670\n.II660    ANOP\nII$SPL4  LA    R3,DASSIZ(,R3)           NEXT VOLUME\n         DROPX R3                       DASDSECT\n.II670    ANOP\n         BCT   R4,II$SPL1               BRANCH IF MORE VOLUMES.\n         OI    0(R5),X'80'              INDICATE END OF OPEN LIST\n         BAL   R14,QAMODE24             change to AMODE 24\n         L     R1,QCSPOOLS              -> open list\n         OPEN  MF=(E,(1))               OPEN HASPACE\n         BAL   R14,QAMODE31             resume AMODE 31\n         TM    QISFLAG1,QIS1ISPF        are we in ispf ?\n         BZ    QQNSPF1                  if not do terminal stuff\n***********************************************************************\n*                                                                     *\n*        ISPF INITIALIZATION                                          *\n*                                                                     *\n***********************************************************************\n*\n**       DEFINE TABLE ROW VARIABLE\n*\n         L     R4,ISPLNK                -> ISPLINK\n         LR    R15,R4                   stupid CALL macro\n         CALL  (15),(=CL8'VDEFINE',V8,V8VAR,                           $\n               =8CL8'CHAR',VLEN8,=CL8'LIST'),VL,                       $\n               MF=(E,II@CALLP)\n*\n**       DEFINE PANEL HEADER LINE VARIABLE\n*\n         LR    R15,R4                   stupid CALL macro\n         CALL  (15),(=CL8'VDEFINE',=C'(QDHLINE)',QDHLINE,              $\n               =CL8'CHAR',=F'80'),VL,                                  $\n               MF=(E,II@CALLP)\n*\n**       DEFINE PANEL ERROR LINE VARIABLE\n*\n         LR    R15,R4                   stupid CALL macro\n         CALL  (15),(=CL8'VDEFINE',=CL8'(QERROR)',QERRMSG,             $\n               =CL8'CHAR',=F'64'),VL,                                  $\n               MF=(E,II@CALLP)\n*\n**       DEFINE PANEL CPU PERCENT VARIABLE\n*\n         LR    R15,R4                   stupid CALL macro\n         CALL  (15),(=CL8'VDEFINE',=CL8'(QC)',QCPU,                    $\n               =CL8'CHAR',=F'3'),VL,                                   $\n               MF=(E,II@CALLP)\n*\n**       DEFINE PANEL DEMAND PAGING RATE VARIABLE\n*\n         LR    R15,R4                   stupid CALL macro\n         CALL  (15),(=CL8'VDEFINE',=CL8'(QD)',QDPR,                    $\n               =CL8'CHAR',=F'3'),VL,                                   $\n               MF=(E,II@CALLP)\n*\n**       DEFINE ROWID VARIABLE\n*\n         LR    R15,R4                   stupid CALL macro\n         CALL  (15),(=CL8'VDEFINE',=CL8'QROWID',QROWID,                $\n               =CL8'FIXED',=F'4'),VL,                                  $\n               MF=(E,II@CALLP)\n*\n**       DEFINE PANEL TOP LINE VARIABLE\n*\n         LR    R15,R4                   stupid CALL macro\n         CALL  (15),(=CL8'VDEFINE',=CL8'QTITLE',QDHISFID,              $\n               =CL8'CHAR',=F'18'),VL,                                  $\n               MF=(E,II@CALLP)\n*\n**       define flag for LISTDS\n*\n         LR    R15,R4                   stupid CALL macro\n         CALL  (15),(=CL8'VDEFINE',=CL8'QBRIFHDR',QBRIFHDR,            $\n               =CL8'CHAR',=F'1'),VL,                                   $\n               MF=(E,II@CALLP)\n*\n**       Set VERB TABLE action to SETVERB (for getting just\n**       the parameters).\n*\n         LR    R15,R4                   stupid CALL macro\n         CALL  (15),(=CL8'VREPLACE',=C'(QQACT)',                       $\n               =F'8',=CL8'SETVERB'),VL,                                $\n               MF=(E,II@CALLP)\n*\n         B     IISTAX                   go do stax processing\n***********************************************************************\n*                                                                     *\n*   CHECK TERMINAL TYPE                                               *\n*                                                                     *\n***********************************************************************\nQQNSPF1  DS    0H\n         GTSIZE  ,\n         SPACE 1\n         LTR   R3,R0                    TEST NUMBER OF ROWS\n         BP    II$TUBE1                 NON-ZERO IMPLIES TUBE\n         OI    QTERMFLG,QTFTTY          ZERO ROWS -> TTY\n         LA    R3,24                    FAKE NUMBER OF LINES\n         CH    R1,=H'80'                TTY LINE LONG ENOUGH?\n         BNL   II$SETSZ                 YES - OK\n         L     R1,=A(II#MSG7)           -> MSG TEXT\n         TPUT  (1),L'II#MSG7            LINE LENGTH MUST BE > 80 ...\n         LA    R1,80                    SET LINE LENGTH\n         B     II$SETSZ\n         SPACE 2\nII$TUBE1 CH    R1,=H'80'                MOD 2, 3, OR 4?\n         BNE   II$TUBE2                 NO - SEE IF MOD 5\n         CH    R3,=H'24'                MOD 2?\n         BNH   II$SETSZ                 YES\n         CH    R3,=H'43'                TOO MANY LINES FOR MOD 4???\n         BH    II$TUBE3                 YES - ASSUME MOD 2\n         MVI   QDERASE,X'7E'            MOD 3 OR 4 - USE ...\n         MVI   QD3270OP,X'7E'           ... ERASE WRITE ALTERNATE\n         B     II$SETSZ\n         SPACE 1\nII$TUBE2 CH    R1,=H'132'               MOD 5?\n         BNE   II$TUBE3                 NO - FORCE MOD 2\n         CH    R3,=H'27'                MOD 5?\n         BNE   II$TUBE3                 NO - FORCE MOD 2\n         NOP   *+8                      %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n         OI    QTERMFLG,QTFMOD5         YES - SET FLAG\n         SPACE 1\nII$TUBE3 LA    R1,80                    SET LINE LENGTH\n         LA    R3,24                    SET NUMBER OF LINES\n         SPACE 1\nII$SETSZ STH   R1,QDCOLS                SAVE SCREEN WIDTH\n         STH   R3,QDLINES               SAVE SCREEN LENGTH\n         LR    R15,R3                   COPY NUMBER OF SCREEN LINES\n         SH    R15,=H'3'                ADJUST FOR FIXED OVERHEAD LINES\n         STH   R15,QDROWS\n         LR    R14,R15                  COPY NUMBER OF LINES / PAGE\n         BCTR  R14,0                    SUBTRACT 1 FOR COLUMN INDICATOR\n         CVD   R15,QNUMWORK             CONVERT NUMBER OF LINES / PAGE\n         ZAP   QTPAGE,QNUMWORK\n         CVD   R14,QNUMWORK             CONVERT NUMBER OF LINES / PAGE\n         ZAP   QTPAGEX,QNUMWORK\n         SRL   R15,1                    GET NUMBER LINES / HALF PAGE\n         CVD   R15,QNUMWORK             CONVERT\n         ZAP   QTHALF,QNUMWORK\n         SRL   R14,1                    GET HALF PAGE SIZE IF COLS ON\n         CVD   R14,QNUMWORK             CONVERT\n         ZAP   QTHALFX,QNUMWORK\n         LR    R0,R3                    COPY NUMBER OF SCREEN LINES\n         LA    R1,12(,R1)               ADJUST LINE LEN FOR ATTR BYTES\n         MR    R0,R1                    COMPUTE SCREEN BUFFER SIZE\n         LA    R0,50(,R3)               ADJUST FOR 3270 CONTROL HEADER\n         ST    R0,QLSCRBUF              SAVE LENGTH OF SCREEN BUFFER\n         GETMAIN  RU,LV=(0),SP=1        BUY A SCREEN BUFFER\n         ST    R1,QVSCRBUF              SAVE ADDRESS OF GOTTEN STORAGE\n***********************************************************************\n*                                                                     *\n*   TELL VTAM WE'RE HERE                                              *\n*                                                                     *\n***********************************************************************\n         STFSMODE  ON,INITIAL=YES\n         SPACE 1\n         CH    R15,=H'8'                VTAM TERMINAL?\n         BE    *+8                      NO - SKIP\n         OI    QTERMFLG,QTFVTAM         YES - SET FLAG\n***********************************************************************\n*                                                                     *\n*   ENABLE ATTN EXIT                                                  *\n*                                                                     *\n***********************************************************************\nIISTAX   DS    0H\n         L     R1,II@STAXA              GET ADDRESS OF STAX BLOCK\n         STAX  USADDR=(R11),MF=(E,(1))\n         SPACE 1\n         LTR   R2,R15                   DID IT WORK?\n         BZ    IISTAXOK                 YES\n         L     R1,=A(II#MSG8)           -> MSG TEXT\n         TPUT  (1),L'II#MSG8            'UNABLE TO ESTABLISH STAX EXIT'\n         ABEND 93\n***********************************************************************\n*                                                                     *\n*   READ IN THE QUEUE PROFILE COMMANDS                                *\n*                                                                     *\n***********************************************************************\nIISTAXOK LA    R0,II@DCB                -> PROFILE DCB AREA\n         ST    R0,II@OPEN               SET UP OPEN LIST\n         L     R1,=A(IIBSAM)            -> PATTERN DCB\n         MVC   II@DCB(IIBSAML),0(R1)    GET BSAM DCB\n         MVI   II@OPEN,X'80'            FLAG END OF LIST\n         MVC   II@DECB(II#DECBL),II#DECB  INITIALIZE DECB\n         L     R5,QCSTART               INIT COMMAND TABLE ADDR\n         SR    R2,R2                    INDICATE NO \"SYSPROC\" FOUND YET\n         L     R1,16                    -> CVT\n         L     R1,0(,R1)                -> DISPATCH\n         L     R1,4(,R1)                -> MY TCB\n         L     R1,12(,R1)               -> MY TIOT\n         SR    R0,R0                    CLEAR FOR IC\n         LA    R1,24(,R1)               -> DEVICE SECTION\n         SPACE 1\nIITIOTLP CLC   =F'0',0(R1)              END OF TIOT?\n         BE    IIPROF00                 YES\n         CLC   4(8,R1),=CL8'SYSPROC'    CLIST LIBRARY?\n         BE    IICLIST                  YES\n         CLC   4(8,R1),=CL8'QPROF'      MY PROFILE DATASET?\n         BE    IIQPROF                  YES\nIITIOTNX IC    R0,0(,R1)                GET TIOT ENTRY LENGTH\n         AR    R1,R0                    -> NEXT TIOT ENTRY\n         B     IITIOTLP                 KEEP LOOKING\n         SPACE 1\nIICLIST  LR    R2,R1                    SAVE PTR\n         B     IITIOTNX                 KEEP LOOKING FOR QPROF\n         SPACE 1\nIIQPROF  BAL   R14,QAMODE24             change to AMODE 24\n         OPEN  MF=(E,II@OPEN)           OPEN IT\n         BAL   R14,QAMODE31             resume AMODE 31\n         TM    II@DCB+48,X'10'          DID IT OPEN?\n         BNO   IIPARSE1                 NO - SKIP ALL, NO ERROR MSG\n         B     IIPROFCK                 START READING\n         SPACE 1\nIIPROF00 LTR   R2,R2                    WAS SYSPROC FOUND?\n         BZ    IIPARSE1                 NO - NO PROFILE EXISTS\n         MVC   II@DCB+DCBDDNAM-IHADCB(8),=CL8'SYSPROC'\n         MVI   II@DCB+DCBDSORG-IHADCB,DCBDSGPO   INDICATE PDS\n         BAL   R14,QAMODE24             change to AMODE 24\n         OPEN  MF=(E,II@OPEN)           OPEN IT\n         BAL   R14,QAMODE31             resume AMODE 31\n         TM    II@DCB+DCBOFLGS-IHADCB,DCBOFOPN  DID IT OPEN?\n         BNO   IIPARSE1                 NO - SKIP ALL, NO ERROR MSG\n         SPACE 1\n         FIND  II@DCB,=CL8'QPROF',D     FIND MY MEMBER THERE\n         LTR   R15,R15                  IS THERE ONE?\n         BZ    IIPROFCK                 YES - GO READ PROFILE COMMANDS\nIICLOSE  BAL   R14,QAMODE24             change to AMODE 24\n         CLOSE MF=(E,II@OPEN)           CLOSE THE DCB\n         BAL   R14,QAMODE31             resume AMODE 31\n         B     IIPARSE1                 AND SKIP ALL THIS, NO ERROR MSG\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*   READ THE PROFILE COMMANDS INTO MAIN STORAGE                       *\n*                                                                     *\n***********************************************************************\nIIPROFCK TM    II@DCB+DCBRECFM-IHADCB,DCBRECU  RECFM U?\n         BO    IICLOSE                  YES, TREAT AS INVALID\n         BZ    IICLOSE                  NO, RECFM? EVEN STRANGER\n         CLC   =H'255',II@DCB+DCBLRECL-IHADCB   LRECL OVER MAX?\n         BL    IICLOSE                  YES, IGNORE IT\n         LH    R6,II@DCB+DCBBLKSI-IHADCB  GET LEN OF BUFFER\n         LA    R6,7(,R6)                +7\n         SRL   R6,3                     /8\n         SLL   R6,3                     *8 ROUNDED UP TO DWD\n         AR    R6,R5                    -> START OF INT BUFFER\n         ST    R6,II@CMNDS              SAVE START OF COMMANDS\n         SPACE 1\nIIPROFLP BAL   R14,QAMODE24             change to AMODE 24\n         SPACE 1\n         READ  II@DECB,SF,II@DCB,(R5),MF=E  READ A PROFILE BLOCK\n         SPACE 1\n         CHECK II@DECB                  WAIT FOR IT\n         SPACE 1\n         BAL   R14,QAMODE31             resume AMODE 31\n         L     R1,II@DECB+16            -> IOB\n         LH    R15,II@DCB+DCBBLKSI-IHADCB  GET BLKSIZE\n         SH    R15,14(,R1)              MINUS RESIDUAL COUNT (IOBCSW+6)\n         AR    R15,R5                   -> END OF BUFFER\n         LR    R14,R5                   -> START OF BLOCK\n         TM    II@DCB+DCBRECFM-IHADCB,DCBRECF  RECFM F?\n         BZ    IIPROFV                  NO, GOTTA DO MORE WORK\nIIPROFFP LH    R1,II@DCB+DCBLRECL-IHADCB  GET RECORD LEN\n         BCTR  R1,0                     LEN TO MOVE -1\n         STH   R1,0(,R6)                SAVE IN BUFFER\n         EX    R1,IIPRFMVC              << MVC  2(*-*,R6),0(R14) >>\n         LA    R14,1(R1,R14)            -> NEXT POS IN INPUT BUFFER\n         LA    R6,3(R1,R6)              -> NEXT POS IN OUTPUT BUFF\n         CR    R14,R15                  PAST END YET?\n         BL    IIPROFFP                 NO, GET NEXT RECORD\n         B     IIPROFLP                 READ NEXT BLOCK\n         SPACE 2\nIIPROFV  LA    R14,4(,R14)              -> BDW\nIIPRFVP  LH    R1,0(,R14)               GET RDW LEN\n         SH    R1,=H'5'                 LEN OF DATA-1 FOR EX\nIIPRFV0  CLI   4(R14),C'0'              NUMERIC?\n         BL    IIPRFVM                  NO, TREAT AS NORMAL\n         LA    R14,1(,R14)              -> NEXT CHAR\n         BCT   R1,IIPRFV0               AND TRY THE NEXT ONE\n         B     IIPRFVP                  WHAT NONE LEFT? TRY NEXT\n         SPACE 1\nIIPRFVM  EX    R1,IIPRFMVV              << MVC 2(*-*,R6),4(R14) >>\n         STH   R1,0(,R6)                SAVE IN BUFFER\n         LA    R14,5(R1,R14)            -> NEXT INPUT RECORD\n         LA    R6,3(R1,R6)              -> NEXT OUTPUT POS\n         CR    R14,R15                  PAST END YET?\n         BL    IIPRFVP                  NO, GET NEXT RECORD\n         B     IIPROFLP                 READ NEXT BLOCK\n         SPACE 2\n*IIPEOF  BAL   R14,QAMODE24             change to AMODE 24\n*---  Don't need to switch modes since the READ was done in AMODE 24\nIIPEOF   CLOSE MF=(E,II@OPEN)           CLOSE PROFILE DCB\n         BAL   R14,QAMODE31             resume AMODE 31\n         XC    0(2,R6),0(R6)            ZERO LEN RECORD IS END\n         L     R6,II@CMNDS              -> FIRST PROFILE SUBCOMMAND\n         L     R2,QVSAVE                -> DISPLAY'S SAVE AREA\n***********************************************************************\n*                                                                     *\n*   EXECUTE THE PROFILE COMMANDS.                                     *\n*   NOTE THAT EXECUTION OF A NON-IMMEDIATE TYPE SUBCOMMAND WILL       *\n*   TERMINATE THE PROFILE SEQUENCE.  ALSO, OTHER TURKEY THINGS LIKE   *\n*   A \"*\" SUBCOMMAND WILL WREAK HAVOC.  LET THE BUYER BEWARE.         *\n*                                                                     *\n***********************************************************************\nIIPROFL2 LH    R1,0(,R6)                GET LEN OF COMMAND\n         LTR   R1,R1                    ANY LEFT?\n         BZ    IIPEND                   NO, END IT ALL HERE\n         CLI   2(R6),C'*'               COMMENT?\n         BE    IIPNEXT                  YES - SKIP IT\n         CLC   =C'/*',2(R6)             NEW STYLE COMMENT?\n         BE    IIPNEXT                  YES - SKIP IT\n         CLC   =C'/*',3(R6)             NEW STYLE COMMENT IN NEXT COL?\n         BE    IIPNEXT                  YES - SKIP IT\n         MVC   0(QSAVE1L,R2),QSAVE1     MOVE FIRST PART\n         MVC   QSAVE1L(QSAVE2L,R2),QSAVE2    SECOND PART\n         MVC   QDREPLY,QBLANK           CLEAR INPUT AREA\n         CH    R1,=Y(QDREPLYL)          OVER MAX\n         BL    IIPROF2M                 NO, MOVE THE COMMAND\n         LH    R1,=Y(QDREPLYL)          MAX LEN OF COMMAND\n         BCTR  R1,0                     -1 FOR EX\nIIPROF2M EX    R1,II$MVC2               << MVC QDREPLY(0),2(R6) >>\n         MVC   QDRLNG,=Y(QDREPLYL)      FAKE THE LENGTH\n         QCALL PARSE                    PARSE THE INPUT\n         TM    QFLAG1,Q1IMMED           IMMEDIATE COMMAND?\n         BNO   QSTOP                    NO - GO TO MAINLINE\n         L     R15,QSUBCMD              GET SUBCOMMAND EPA\n         QCALL (R15)                    INVOKE IMMEDIATE SUBCOMMAND\n         TM    QFLAG1,Q1IMMED           DID SUBCMD RESET \"IMMEDIATE\"?\n         BNO   QSTOP                    YES - LET MAINLINE RE-INVOKE IT\n         MVC   QSAVE1(QSAVE1L),0(R2)    RESTORE FIRST PART\n         MVC   QSAVE2(QSAVE2L),QSAVE1L(R2)      SECOND PART\nIIPNEXT  LH    R1,0(,R6)                -> LEN OF LAST PROF CMND\n         LA    R6,3(R1,R6)              -> NEXT COMMAND\n         OC    0(2,R6),0(R6)            ANY THERE?\n         BNZ   IIPROFL2                 YES - CONTINUE\nIIPEND   OI    QFLAG1,Q1PROFOK          PROFILE COMPLETE\n***********************************************************************\n*                                                                     *\n*   PARSE THE INITIAL COMMAND                                         *\n*                                                                     *\n***********************************************************************\nIIPARSE1 L     R2,QVSAVE                -> DISPLAY'S SAVE AREA\n         MVC   0(QSAVE1L,R2),QSAVE1     MOVE FIRST PART\n         MVC   QSAVE1L(QSAVE2L,R2),QSAVE2    SECOND PART\n         MVC   QDPROMPT,QDREPLY         SET WHAT TO REPROMPT IF ERROR\n         QCALL PARSE                    PARSE THE INPUT\n         TM    QFLAG1,Q1IMMED           IMMEDIATE COMMAND?\n         BNO   QSTOP                    NO - GO TO MAINLINE\n         L     R15,QSUBCMD              GET SUBCOMMAND EPA\n         CL    R15,=V(RECALL)           RECALL REQUEST?\n         BE    II$JUNK                  YES - HE CAN'T DO THAT HERE\n         QCALL (R15)                    INVOKE IMMEDIATE SUBCOMMAND\n         TM    QFLAG1,Q1IMMED           DID SUBCMD RESET \"IMMEDIATE\"?\n         BNO   QSTOP                    YES - LET MAINLINE RE-INVOKE IT\nII$JUNK  MVC   QSAVE1(QSAVE1L),0(R2)    RESTORE FIRST PART\n         MVC   QSAVE2(QSAVE2L),QSAVE1L(R2)      SECOND PART\n         MVC   QDPROMPT,QDREPLY         SET WHAT TO REPROMPT IF ERROR\n         B     QSTOP                    GO HOME\n***********************************************************************\n*                                                                     *\n*   PROCESS REQUEST FOR DIFFERENT VOLSER ON SYS1.HASPCKPT             *\n*                                                                     *\n***********************************************************************\n*\n*** FORMAT - QUEUE CKPT(VOLSER)\n*\n*  R1 -> 'CKPT('\n*  R3 -> LENGTH-1 OF WHOLE OPERAND\n*\nII$CKPT  MVC   QCKPTVOL,QBLANK          BLANK VOLSER FIELD\n         LA    R15,QCKPTVOL             START OF VOLSER FIELD\n         LA    R6,5(,R15)               -> END OF VOLSER FIELD\n         SH    R3,=H'4'                 SUBTRACT OVERHEAD FROM LENGTH\n         LA    R1,5(,R1)                -> FIRST OPERAND CHAR\nII$CKP1  CLI   0(R1),C')'               IS THIS THE END OF SER FIELD?\n         BE    II$CKPT2                 YES. PROCESS VOLSER NEXT.\n         CR    R15,R6                   DID WE GO TOO FAR?\n         BH    IIABORT2                 YES - GET OUT\n         MVC   0(1,R15),0(R1)           MOVE ONE BYTE OF UNIT NAME\n         LA    R15,1(,R15)              ADD 1 TO RECEIVING ADDR\n         LA    R1,1(,R1)                ADD 1 TO SENDING ADDR\n         BCT   R3,II$CKP1               BRANCH IF NOT EXHAUSTED.\n         B     IIABORT2                 INVALID PARAMETERS.\nII$CKPT2 CLI   QCKPTVOL,C' '            IS THERE A VOLSER?\n         BE    IIABORT2                 NO - ERROR\n         OI    II@FLAGS,II@CKPT         yes - remember it was specified\nII$CKPT3 BCT   R3,*+8                   -1 FOR ')'\n         B     II$SKPRM                 RESUME MAINLINE IF NO MORE PARM\n         LA    R1,1(,R1)                -> NEXT PARM CHAR\n         CLI   0(R1),C' '               FIND A NON-BLANK?\n         BE    II$CKPT3                 YES - KEEP LOOKING\n         BCT   R3,*+8                   -1 FROM COUNT\n         B     II$SKPRM                 INPUT EXHAUSTED\n         CH    R3,=H'5'                 ENOUGH LEFT TO BE INTERESTING?\n         BL    II$SKPRM                 NO\n**%%     BCTR  R3,0                     -1 FOR FINAL BLANK\n         B     II$CKPRM                 YES - PROCESS\nIIABORT2 L     R1,=A(II#MSG2)           -> MSG TEXT\n         TPUT  (1),L'II#MSG2            TELL THE USER\n         ABEND 97,DUMP                  QUIT\n***********************************************************************\n*                                                                     *\n*   PROCESS REQUEST FOR DIFFERENT DSNAME PREFIX                       *\n*                                                                     *\n***********************************************************************\n*\n*** FORMAT - QUEUE DSN(PREFIX)\n*\n*  R1 -> 'DSN('\n*  R3 -> LENGTH-1 OF WHOLE OPERAND\n*\nII$DSN   LA    R15,QCKPTPFX             -> START OF PREFIX FIELD\n         LA    R6,44-1(,R15)            -> PREFIX IS MAX 44 CHARS\n         SH    R3,=H'3'                 SUBTRACT OVERHEAD FROM LENGTH\n         LA    R1,4(,R1)                -> FIRST OPERAND CHAR\nII$DSN1  CLI   0(R1),C')'               IS THIS THE END OF THE PREFIX?\n         BE    II$DSN2                  YES. MOVE IN REST OF DSNAME\n         CR    R15,R6                   DID WE GO TOO FAR?\n         BH    IIABORT3                 YES - GET OUT\n         MVC   0(1,R15),0(R1)           MOVE ONE BYTE OF DSNAME\n         LA    R15,1(,R15)              ADD 1 TO RECEIVING ADDR\n         LA    R1,1(,R1)                ADD 1 TO SENDING ADDR\n         BCT   R3,II$DSN1               BRANCH IF NOT EXHAUSTED.\n         B     IIABORT3                 INVALID PARAMETERS.\nII$DSN2  CLI   QCKPTPFX,C' '            IS THERE A PREFIX?\n         BE    IIABORT3                 NO - ERROR\n         OI    II@FLAGS,II@DSN          yes - remember it was specified\nII$DSN3  BCT   R3,*+8                   -1 FOR ')'\n         B     II$SKPRM                 RESUME MAINLINE IF NO MORE PARM\n         LA    R1,1(,R1)                -> NEXT PARM CHAR\n         CLI   0(R1),C' '               FIND A NON-BLANK?\n         BE    II$DSN3                  YES - KEEP LOOKING\n         CH    R3,=H'5'                 ENOUGH LEFT TO BE INTERESTING?\n         BL    II$SKPRM                 NO\n         BCTR  R3,0                     -1 FOR FINAL BLANK\n         B     II$CKPRM                 YES - PROCESS\nIIABORT3 L     R1,=A(II#MSG3)           -> MSG TEXT\n         TPUT  (1),L'II#MSG3            TELL THE USER\n         ABEND 96,DUMP                  QUIT\n***********************************************************************\n*                                                                     *\n*   SET FLAG FOR ISPF DIALOG MANGLER                                  *\n*                                                                     *\n***********************************************************************\n*\n*  R1 -> 'ISPF'\n*  R3 -> LENGTH-1 OF WHOLE OPERAND\n*\nII$ISPF  OI    II@FLAGS,II@ISPF         REMEMBER FOR LATER\n         LA    R1,5(,R1)                -> PAST 'ISPF '\n         SH    R3,=H'5'                 ADJUST REMAINING LENGTH\n         BP    II$CKPRM                 GO FIND NEXT PARM ITEM\n         B     II$SKPRM                 NONE LEFT - CONTINUE INIT\n***********************************************************************\n*                                                                     *\n*   PROCESS REQUEST FOR NON-DEFAULT JES2 SUBSYSTEM                    *\n*                                                                     *\n***********************************************************************\n*\n*** FORMAT - QUEUE JES(NAME)\n*\n*  R1 -> 'JES('\n*  R3 -> LENGTH-1 OF WHOLE OPERAND\n*\nII$JESN  MVC   QJESNAME(4),QBLANK       BLANK SUBSYSTEM NAME FIELD\n         LA    R15,QJESNAME             -> START OF OUTPUT AREA\n         LA    R6,4-1(,R15)             -> SUBSYS NAME IS MAX 4 CHARS\n         SH    R3,=H'3'                 SUBTRACT OVERHEAD FROM LENGTH\n         LA    R1,4(,R1)                -> FIRST OPERAND CHAR\nII$JES1  CLI   0(R1),C')'               IS THIS THE END OF THE NAME?\n         BE    II$JES2                  YES. DONE\n         CR    R15,R6                   DID WE GO TOO FAR?\n         BH    IIABORT4                 YES - GET OUT\n         MVC   0(1,R15),0(R1)           MOVE ONE BYTE OF SUBSYS NAME\n         LA    R15,1(,R15)              ADD 1 TO RECEIVING ADDR\n         LA    R1,1(,R1)                ADD 1 TO SENDING ADDR\n         BCT   R3,II$JES1               BRANCH IF NOT EXHAUSTED.\n         B     IIABORT4                 INVALID PARAMETERS.\nII$JES2  CLI   QJESNAME,C' '            IS THERE A NAME?\n         BE    IIABORT4                 NO - ERROR\n         OI    II@FLAGS,II@JESNM        yes - remember it was specified\nII$JES3  BCT   R3,*+8                   -1 FOR ')'\n         B     II$SKPRM                 RESUME MAINLINE IF NO MORE PARM\n         LA    R1,1(,R1)                -> NEXT PARM CHAR\n         CLI   0(R1),C' '               FIND A NON-BLANK?\n         BE    II$JES3                  YES - KEEP LOOKING\n         CH    R3,=H'5'                 ENOUGH LEFT TO BE INTERESTING?\n         BL    II$SKPRM                 NO\n         BCTR  R3,0                     -1 FOR FINAL BLANK\n         B     II$CKPRM                 YES - PROCESS\nIIABORT4 L     R1,=A(II#MSG4)           -> MSG TEXT\n         TPUT  (1),L'II#MSG4            TELL THE USER\n         ABEND 94,DUMP                  QUIT\n***********************************************************************\n*                                                                     *\n*   UNSUPPORTED DEVICE TYPE. ABORT.                                   *\n*                                                                     *\n***********************************************************************\nIIABORT  L     R1,=A(II#MSG1)           -> MSG TEXT\n         TPUT  (1),L'II#MSG1            TELL THE USER\n         ABEND 98,DUMP                  QUIT.\n***********************************************************************\n*                                                                     *\n*   COULDN'T GET STORAGE FOR BLOCK ADDR TABLE                         *\n*                                                                     *\n***********************************************************************\nII$SMALL L     R1,=A(II#MSG5)           -> MSG TEXT\n         TPUT  (1),L'II#MSG5            TELL THE USER\n         ABEND 95                       QUIT.\n          AIF   (&QLEVEL LT 4).II690\n          AIF   (&QLEVEL LT 8).II680\n         EJECT ,\n***********************************************************************\n*                                                                     *\n*  II$CK$PI - Check ckpt pool id for '**xxx  POOL**'                  *\n*                                                                     *\n* ENTRY: R15 -> CL4'id'                                               *\n*        R1  -> checkpoint area to examine                            *\n*        R14 - RETURN ADDRESS                                         *\n*                                                                     *\n***********************************************************************\n         USING HDP,R1                   Control block Pool Header\nII$CK$PI CLC   HDPID+0(2),=C'**'        first part correct?\n         BNE   II$CK$P2                 nope\n         CLC   HDPID+2(4),0(R15)        name part correct?\n         BNE   II$CK$P2                 nope\n         CLC   HDPID+6(7),=C' POOL**'   last part correct?\n         BNE   II$CK$P2                 nope\n         LA    R0,HDPLNGTH(,R1)         add buffer prefix\n         ICM   R15,B'1111',HDPSIZE      size of area\n         AR    R1,R15                   bump\n         BR    R14                      return to mainline\n         DROP  R1                       HDP\n         SPACE 1\nII$CK$P2 MVC   QDMSG(L'II#MSG11),II#MSG11  'Unable to locate xxxx pool'\n         MVC   QDMSG+17(4),0(R15)       fill in pool id\n         LA    R1,QDMSG                 -> address\n         LA    R0,L'II#MSG11            length\n         TPUT  (1),(0),R\n         ABEND 89,DUMP\n          AGO   .II700\n.II680    ANOP\n         EJECT ,\n***********************************************************************\n*                                                                     *\n*  II$KITFD - FIND SELECTED KIT                                       *\n*                                                                     *\n* ENTRY: R0  - CHAR ID STRING (CL4 IN REG)                            *\n*        R14 - RETURN ADDRESS                                         *\n*                                                                     *\n* EXIT:  R1  -> KIT (IF RETURN 4(,R14); ELSE NOT FOUND)               *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nII$KITFD L     R1,II@KITF               -> FIRST KIT\n         USNGX KITDSECT,R1\nII$KITFL CL    R0,KITID\n         BE    4(,R14)                  RETURN IF SELECTED KIT FOUND\n         LA    R1,KITLNGTH(,R1)         -> NEXT KIT IF ANY\n         C     R1,II@KITL               -> LAST KIT\n         BNH   II$KITFL                 LOOP IF WAS NOT LAST KIT\n         BR    R14                      RETURN IF KIT NOT FOUND\n         DROPX R1                       KITDSECT\n         SPACE 3\n***********************************************************************\n*                                                                     *\n*  II$CKTTR - COMPUTE CKPT TTR OF GROUP OF BLOCKS FROM KITORG         *\n*                                                                     *\n* ENTRY: R1  - @ KITDSECT                                             *\n*        R14 - RETURN ADDRESS                                         *\n*                                                                     *\n* EXIT:  R1  - TTR0 OF THIS GROUP ON CKPT                             *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         USNGX KITDSECT,R1\nII$CKTTR L     R1,KITORG                GET ORI IN BYTES OF THIS GROUP\n         DROPX R1\n         SRL   R1,12                    ORG TO # OF BLOCKS\n         SR    R0,R0\n         D     R0,II@CKRT               / # 4K BLOCKS/TRK ON CKPT DEV\n         SLL   R1,8                     POSITION TT IN R1\n         OR    R1,R0                    BUILD TTR IN R1\n         AL    R1,=X'00000101'          SKIP 1ST TRK/RECORD ORIGIN 1\n         SLL   R1,8                     NOW TTR0\n         BR    R14\n.II690    ANOP\n.II700    ANOP\n         SPACE 3\n         PUSH  USING\n         DROP  ,\n         SPACE 1\n         USING *,R15\n         USING IHADCB,R1\nII#NCPEX CLI   DCBNCP,0                 NCP SPECIFIED?\n         BNER  R14                      YES - USE IT\n         MVI   DCBNCP,&QCHKNCP          NO - USE GENNED DEFAULT VALUE\n         BR    R14                      RETURN TO OPEN\n         SPACE 1\n         POP   USING\n         SPACE 3\n         EJECT\n***********************************************************************\n*                                                                     *\n*   MISCELLANY                                                        *\n*                                                                     *\n***********************************************************************\n         LTORG ,\n         SPACE 1\nII$CMDOC OC    0(*-*,R1),QBLANK         TRANSLATE COMMAND TO UPPER CASE\nII$MVC1  MVC   QDREPLY(*-*),0(R1)       MOVE DATA TO REPLY\nII$MVC2  MVC   QDREPLY(*-*),2(R6)       MOVE DATA TO REPLY\nIIPRFMVC MVC   2(*-*,R6),0(R14)         MOVE RECFM F DATA\nIIPRFMVV MVC   2(*-*,R6),4(R14)         MOVE RECFM V DATA\n         SPACE 2\n*---  TABLE OF ADCONS IN QCOMMON TO BE RELOCATED IN GETMAINED AREA\nII#RELOC DC    Y(QVSYSID-QCOMMON,QSYSID-QCOMMON)\n         DC    Y(QVPFKEYS-QCOMMON,QPFKAREA-QCOMMON)\n         DC    Y(QVTFD-QCOMMON,TFD-QCOMMON)\n         DC    Y(QVSAVE-QCOMMON,QDSAVE-QCOMMON)\n         DC    Y(QVLCBUF-QCOMMON,QDLCBUF-QCOMMON)\n         DC    Y(QVSTACK-QCOMMON,QDSTACK-QCOMMON)\n         DC    Y(QVSTACKC-QCOMMON,QDSTACK-QCOMMON)\n         DC    Y(DAPLECB-QCOMMON,DAIRECB-QCOMMON)\n         DC    Y(HDECB2+24-QCOMMON,QCDAD-QCOMMON)\n         DC    Y(QCCKPT-QCOMMON,HASPCKPT-QCOMMON)\n         DC    Y(HDECB1+8-QCOMMON,HASPCKPT-QCOMMON)\n         DC    Y(QCSAVE-QCOMMON,HASPSAVE-QCOMMON)\n         DC    Y(QPPRNT-QCOMMON,HASPPRNT-QCOMMON)\n         DC    Y(QCDECB1-QCOMMON,HDECB1-QCOMMON)\n         DC    Y(QCDECB2-QCOMMON,HDECB2-QCOMMON)\n         DC    Y(QHDCBA-QCOMMON,HELPDCB-QCOMMON)\n         DC    Y(QHDECBA-QCOMMON,HELPDECB-QCOMMON)\n         DC    Y(QVPRNTWA-QCOMMON,QPRNTWA-QCOMMON)\n         DC    Y(QVRING-QCOMMON,QCMDRING-QCOMMON)\n         DC    X'FF'                    END OF TABLE INDICATOR\n         SPACE 2\n         ENTRY SMFTABLE                 SO I CAN FIND IT WITH \"ZAP\"\nSMFTABLE DC    0D'0'\n*  CL4'SMFID',CL4'ID_TO_DISPLAY'\n&QI      SETA  0\n.IILOOP1  AIF   (&QI GE &QSIDNUM).IIEND1  EXIT IF DONE\n&QI      SETA  &QI+1                    BUMP SUBSCRIPT\n         DC    CL8'&QSIDTBL(&QI)'\n         SPACE 1\n          AGO   .IILOOP1                LOOP\n.IIEND1  DC    X'FF'                    END OF TABLE INDICATOR\n         SPACE 2\n         ENTRY SYSTABLE                 SO I CAN FIND IT WITH \"ZAP\"\nSYSTABLE DC    0D'0'\n*  CL6'SYSRES',CL4'JESN',CL6'CHKPTV',CL8'PREFIX'\n&QI      SETA  0\n.IILOOP2  ANOP\n&QI      SETA  &QI+1                    BUMP SUBSCRIPT\n         DC    CL60'&QSYSTBL(&QI)'\n          AIF   (&QI NE 1).STNOT1       skip if not first table entry\nSYSTBLL  EQU   *-SYSTABLE               length of an entry\n.STNOT1   ANOP\n         SPACE 1\n          AIF   (&QI LT &QSYSNUM).IILOOP2  LOOP IF MORE\n         DC    X'FF'                    END OF TABLE INDICATOR\n         SPACE 3\nII#OPENO OPEN  (0,OUTPUT),MF=L\n         SPACE 1\nII#OPENI OPEN  (0),MF=L\n         SPACE 1\nII#EXLST DC    X'85',AL3(II#NCPEX)      -> DCB EXIT TO SET NCP\n         SPACE 1\n         READ  II#DECB,SF,MF=L\n         SPACE 1\nII#DECBL EQU   *-II#DECB\n         SPACE 3\n         DROPX R13                      WORK\n         SPACE 2\nII#CKSFX DC    C'&QSFXCK'               '.HASPCKPT'\nII#HSSFX DC    C'&QSFXHS'               '.HASPACE'\n         SPACE 2\n*                                                        ABEND CODES:\nII#MSG1  DC    C'UNSUPPORTED DEVICE TYPE SPECIFIED FOR SPOOL'  98\nII#MSG2  DC    C'INVALID PARAMETER SPECIFIED - CKPT(VOLSER)'   97\nII#MSG3  DC    C'INVALID PARAMETER SPECIFIED - DSN(PREF)'      96\nII#MSG4  DC    C'INVALID PARAMETER SPECIFIED - JES(NAME)'      94\nII#MSG5  DC    C'UNABLE TO OBTAIN 64K OF STORAGE FOR BLOCK ADDR TABLE'\n*                                                              95\nII#MSG7  DC    C'LINE LENGTH MUST BE AT LEAST 80, WILL USE 80' --\nII#MSG8  DC    C'*** UNABLE TO ESTABLISH STAX EXIT ***'        93\nII#MSG9  DC    C'*** WRONG VERSION OF QUEUE COMMAND FOR THIS CHKPT ($HA$\n               SPID \u00ac= ''JES2'') ***'                          91\nII#MSG10 DC    C'Sort routine (OACFSORT) load failure'         90\nII#MSG11 DC    C'Unable to locate xxxx pool'                   89\n         SPACE 6\nHASPACE  DCB   DDNAME=HASPACE1,DSORG=DA,MACRF=(RIC),OPTCD=A,RECFM=F\n         SPACE 2\nQCDCBL   EQU   *-HASPACE                LENGTH OF HASPACE DCB\n         SPACE 3\nIIBSAM   DCB   DDNAME=QPROF,DSORG=PS,MACRF=(RP),EODAD=IIPEOF\n         SPACE 2\nIIBSAML  EQU   *-IIBSAM\n         SPACE 6\nWORK     DSECT\n         ORG   WORK+72                  PAST MY SAVE AREA\nII@STAXA DS    A                        ADDRESS OF STAX BLOCK\nII@VLEN  DS    F                        length of area for VCOPY\nII@CPPL  DS    4A                       PHONY CPPL\nII@FLAGS DS    X                        MISC FLAG FOR INITIAL\nII@FCALL  EQU   X'80'                    ENVIRONMENT IS CALL\nII@ISPF   EQU   X'40'                    PARM=ISPF WAS SPECIFIED\nII@JESNM  EQU   X'20'                    JES() was specified\nII@CKPT   EQU   X'10'                    CKPT() was specified\nII@DSN    EQU   X'08'                    DSN() was specified\n          AIF   (&QLEVEL LT 4).IINOKIT\nII@CKRT  DS    F                        4K BLOCKS/TRK ON CKPT DEVICE\nII@KITF  DS    A                        -> FIRST KIT AT INIT TIME\nII@KITL  DS    A                        -> LAST  KIT AT INIT TIME\n.IINOKIT  ANOP\nII@CMNDS DS    A                        -> START OF COMMANDS\nII@OPEN  DS    A(II@DCB)                OPEN MF=L FOR PROFILE DCB\nII@TTRZ  DS    XL4                      TTRZ\nII@BLDL  DS    Y(1,12)\nII@BLDLN DS    CL8'ISPLINK'             MEMBER TO READ\nII@BLDLT DS    XL3,X                    TTR,Z OF MEMBER FOUND\n         READ  II@DECB,SF,MF=L          PROFILE DECB\n         SPACE 2\n         DS    0F                       STUPID MACRO...\n*  (THE DEBUGGING HANDBOOK DOCUMENTS THE FOLLOWING UNDER 'DVCT'!!!)\n         IHADVA  DSECT=NO               MAP DEVTYPE OUTPUT\n         SPACE 3\nII@DCB   DS    XL100                    SPACE FOR PROFILE DCB\n         ORG   II@DCB\nII@TRKCA TRKCALC  MF=L\n         SPACE 1\nII@TRKCL EQU   *-II@TRKCA\n         ORG   II@DCB+L'II@DCB          past end of dcb\nII@WORKL EQU   *-WORK                   len of initial workarea\nII@REGS  DS    (R11-R2+1)F              when calling LPA search\nII@CALLP DS    6A                       CALL MF=L area\n         SPACE 3\n         QCOMMON\n         QDCB\n         SPACE 3\n         Q$DAS\n         Q$MIT\n         Q$XECB\n         Q$HDP\n         Q$JOE\n         Q$JOT\n         Q$QSE\n         Q$KAC\n         Q$KIT\n         Q$LCK\n         Q$HCT\n         Q$PDDB\n         Q$IOT\n         Q$TGM\n         Q$JQE\n         Q$SVT\n         Q$HCCT\n         QZCPPL\n         QZPSA ,\n         QZTCB ,\n         QZCVT\n         QZJESCT\n         QZPSCB\n         QZSSCT\n         QZSSIB\n         QZUCB\n         QZIHAETD ,\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "Q#IN": {"ttr": 11018, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x18\\x00\\x00\\x00\\x82#/\\x00\\x90\\x16\\x7f\"\\x14\\x01L\\x00\\xb0\\x00\\xe9\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "05.24", "flags": 0, "createdate": "1982-08-20T00:00:00", "modifydate": "1990-06-16T22:14:00", "lines": 332, "newlines": 176, "modlines": 233, "user": "LDW"}, "text": "         TITLE '--- QUEUE--INITS -- LIST INITIATORS ---'\n*---------------------------------------------------------------------*\n*                                                                     *\n*   INITS - Display initiators and jobs in initiators                 *\n*                                                                     *\n*   Note - Unprivileged users are not shown drained initiators or     *\n*          class settings                                             *\n*                                                                     *\n*   Updates:                                                          *\n*      16Jun90  LDW  Remove mode switching since we now run AMODE 31  *\n*      09Jan90  EMS  fix len of SJB area to allow assembly pre 311    *\n*      27Dec89  LDW  Copy SJB to 24 bit storage *kludge* *kludge*     *\n*      25Dec89  LDW  Q$xxx -> QZxxx:  CVT, SSCT                       *\n*      23Nov89  LDW  Remove conditional assembly around Qxxx macros   *\n*                    Remove prereq macro Q$DEB                        *\n*      22Mar89  EMS  SP311 changes                                    *\n*                    Fix LDW's cheap fix for MVS/XA on non-XA mach    *\n*      14Feb87  LDW  Cheap fix for MVS/XA                             *\n*      25Jan87  LDW  Pass READSPC the JQE addr in case of CB ID error *\n*      17Jan87  LDW  Eliminate \"LC\" macro usage                       *\n*      04Jan87  LDW  SP136 updates                                    *\n*      30NOV86  LDW  FIX BUG IN DURATION DISPLAY IF > 1 DAY           *\n*      03SEP86  LDW  DISPLAY 'DAY ' INSTEAD OF 'DAYS' IF ONLY 1 DAY   *\n*      04/07/86 LDW  ADD 'START' ('S') KEYWORD TO DISPLAY START TIME  *\n*                    DISPLAY CURRENT DATE IN HEADER LINE IF 'START'   *\n*      04/03/86 LDW  DISPLAY ELAPSED TIME INSTEAD OF START TIME       *\n*      03/31/86 LDW  RE-DESIGN 3278-5 SUPPORT (THIRD TRY!)            *\n*      12/17/84 LDW  FIX BUG:  \"CLASSES\" WAS DISPLAYED IN HEADER      *\n*                       FOR UNPRIVILEGED USERS                        *\n*      04/11/84 LDW  JCTDSECT -> JCTSTART                             *\n*      01/19/84 LDW  ADD SUPPORT FOR COMMAND STACKING                 *\n*      03/18/83 LDW  CHANGE USING/DROP TO USNGX/DROPX                 *\n*      03/02/83 LDW  CHANGE 'QTILT *' TO USE QERRMSG                  *\n*      01/24/83 LDW  ADD Q$DEB IN FRONT OF Q$SJB FOR SP               *\n*      01/05/83 LDW  DISPLAY JOBNUMBER AND EXEC CLASS HIGH INTENSITY  *\n*                    DISPLAY STATUS HIGH INTENSITY IF ENDS WITH \"ING\" *\n*                    DON'T DISPLAY INACTIVE INITS FOR UNPRIV USERS    *\n*      12/22/82 LDW  CHANGE HEADER AND SOME OTHER DATA TO LOWER CASE  *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 3\nINITS    QSTART  Q23,WORKLEN=IN@WORKL,STACK=X'01'\n         USNGX WORK,R13                 BASE REG FOR LOCAL WORK AREA\n         QCALL CKPT                     READ CHECKPOINT DATA\n         QCALL DISP80                   SWITCH TO 3278-2 MODE IF 3278-5\n         TIME  BIN                      GET DATE & TIME IN JES2'S FMT\n         STM   R0,R1,IN@TIME            SAVE CURRENT TIME AND DATE\n***********************************************************************\n*                                                                     *\n*        FIND THE SSVT FOR THE SELECTED SUBSYSTEM                     *\n*                                                                     *\n***********************************************************************\n         L     R8,QSSCT                 -> SSCT\n         LTR   R8,R8                    VALID SUBSYSTEM?\n         BZ    IN$TILT                  NO - CAN'T DO THIS SUBCOMMAND\n         USNGX SSCT,R8\n          AIF  (&QLEVEL GE 9).IN08\n         L     R8,SSCTSSVT              -> SSVT\n         DROPX R8                       SSCT\n         USNGX SSVT,R8\n          AGO  .IN09\n.IN08     ANOP ,\n         L     R8,SSCTSUS2              -> HCCT\n         DROPX R8\n         USNGX HCCT,R8\n.IN09     ANOP ,\n         LTR   R8,R8                    IS IT UP?\n         BZ    IN$TILT                  NO - CAN'T DO THIS SUBCOMMAND\n***********************************************************************\n*                                                                     *\n*        FIND THE SUBSYSTEM'S PITS                                    *\n*                                                                     *\n***********************************************************************\n         L     R7,$SVPIT                POINT TO PITTABLE\n         LTR   R7,R7                    TEST IF ANY PITS\n         BZ    IN$NONE                  NO, IGNORE COMMAND\n          AIF   (&QLEVEL GE 7).IN01\n         SR    R6,R6                    ZERO FOR INSERT\n         IC    R6,$SVMAXCL              INSERT NUMBER OF CLASSES\n          AGO   .IN02\n.IN01     ANOP\n         LA    R6,L'PITCLASS            GET NUMBER OF CLASSES\n.IN02     ANOP\n         USNGX PITDSECT,R7\n         MVC   QDHLINE,=CL79'Jobname Number Cls  Elapsed time Init Stat$\n               us   Classes'\n         TM    QXAUTH,QXAUTHX           IS HE AUTHORIZED?\n         BNZ   *+10                     YES - SKIP\n         MVC   QDHLINE+IN@CLASS-4-QDMSG(7),QBLANK  NO - SKIP \"CLASSES\"\n         CLI   QKEYWORD,C'S'            WANT START TIMES?\n         BNE   IN$LOOP                  NO - DEFAULT IS ELAPSED TIME\n         MVC   QDHLINE+20(12),=C' Start time '  YES - ALTER HEADER LINE\n         UNPK  QDHLINE+L'QDHLINE-5(5),IN@DATE   GET TODAY'S YYDDD\n         MVC   QDHLINE+L'QDHLINE-6(2),QDHLINE+L'QDHLINE-5  SHIFT YY\n         MVI   QDHLINE+L'QDHLINE-4,C'.' MAKE IT YY.DDD\n***********************************************************************\n*                                                                     *\n*        BUILD THE MESSAGE(S) DESCRIBING THE PITS                     *\n*                                                                     *\n***********************************************************************\n*IN$LOOP TM    QMISCFLG,QMFMVSE         running MVS/XA?\n*%       BZ    IN$LPCK                  no, skip pit move\n*%       BAL   R14,QAMODE31             PITS ARE >16M UNDER MVS/XA\n*%       MVC   IN@PIT(PITLEN),0(R7)     SO COPY IT TO 24 BIT STORAGE\n*%       LA    R7,IN@PIT                AND FAKE THE PIT ADDRESS\n*%       BAL   R14,QAMODE24             back to the way we were\n         SPACE 1\n*IN$LPCK TM    QXAUTH,QXAUTHX           IS HE AUTHORIZED?\nIN$LOOP  TM    QXAUTH,QXAUTHX           IS HE AUTHORIZED?\n         BNZ   IN$BUILD                 YES - ALWAYS DISPLAY\n         TM    PITSTAT,PITBUSY          IS IT BUSY?\n         BO    IN$BUILD                 YES - ALWAYS DISPLAY\n         B     IN$NEXT   **********     UNPRIV USER - SKIP NON-BUSY PIT\n*  AT THIS POINT: USER IS NOT PRIVILEGED, AND THE INITIATOR IS NOT\n*  BUSY (SO IT CANNOT BE \"DRAINING\" OR \"HALTING\"), SO WE WON'T DISPLAY\n*  IT IF IT IS DRAINED OR HALTED.  (WHY ADVERTISE EXTRA INITIATORS???)\n         TM    PITSTAT,PITHOLDA+PITHOLD1+PITHALTA+PITHALT1 DRAIN/HALT?\n         BNZ   IN$NEXT                  YES - SKIP IT\nIN$BUILD MVI   QDATRNUM+1,4             NUMBER OF ATTR BYTES IN LINE\n         MVC   IN@ATTR1,=X'1DE8'        SET OUTPUT, BRIGHT\n         MVC   IN@ATTR2,=X'1D60'        SET OUTPUT, NORMAL\n         MVC   IN@ATTR3,=X'1D60'        SET OUTPUT, NORMAL\n         MVC   IN@ATTR4,=X'1D60'        SET OUTPUT, NORMAL\n         MVC   IN@INIT,PITPATID         MOVE IN PIT ID\n         TM    QXAUTH,QXAUTHX           IS HE AUTHORIZED?\n         BZ    IN$NOCLS                 NO - DON'T SHOW HIM CLASSES\n         LR    R1,R6                    COPY THE LENGTH\n         BCTR  R1,0                     SUBTRACT ONE FOR EXECUTE\n         CH    R1,=Y(INMAXCLS)          MORE THAN WE CAN DISPLAY?\n         BL    IN$CLSEX                 NO - DO EXECUTED MOVE\n         MVC   IN@CLASS(INMAXCLS),PITCLASS  MOVE MAX NUMBER OF CLASSES\n         CLI   PITCLASS+INMAXCLS,C' '   MORE THAN WILL FIT ON ONE LINE?\n         BE    IN$NOCLS                 NO - OK\n         MVI   IN@CLASS+INMAXCLS-1,C'+'  INDICATE WE LOST SOME.\nIN$CLSEX EX    R1,IN$MVCLS              MOVE THE CLASSES\nIN$NOCLS TM    PITFLAGS,PITSMVER        WAITING FOR MEMORY CREATE?\n         BO    IN$STING                 YES\n         TM    PITSTAT,PITHOLDA+PITHOLD1  TEST FOR DRAINED\n         BNZ   IN$DRAIN                 YES\n         TM    PITSTAT,PITHALTA+PITHALT1 TEST FOR HALTED\n         BNZ   IN$HALT                  YES\n         MVC   IN@STAT,=CL8'Active'\n         TM    PITSTAT,PITBUSY          TEST FOR BUSY\n         BO    IN$ACTIV                 YES\n         MVC   IN@STAT,=CL8'Inactive'\n         B     IN$DISP                  END OF MESSAGE LINE.\nIN$STING MVC   IN@STAT,=CL8'Starting'\n         MVC   IN@ATTR3,=X'1DE8'        SET OUTPUT, BRIGHT\n         B     IN$DISP\nIN$MVCLS MVC   IN@CLASS(*-*),PITCLASS   SET THE CLASSES\nIN$DRAIN MVC   IN@STAT,=CL8'Drained'\n         TM    PITSTAT,PITBUSY          TEST FOR BUSY\n         BZ    IN$DISP                  NO\n         MVC   IN@STAT+5(3),=C'ing'\n         MVC   IN@ATTR3,=X'1DE8'        SET OUTPUT, BRIGHT\n         B     IN$ACTIV                 YES\nIN$HALT  MVC   IN@STAT,=CL8'Halted'\n         TM    PITSTAT,PITBUSY          TEST FOR BUSY\n         BZ    IN$DISP                  NO\n         MVC   IN@STAT+4(3),=C'ing'\n         MVC   IN@ATTR3,=X'1DE8'        SET OUTPUT, BRIGHT\nIN$ACTIV L     R5,PITSJB                POINT TO THE SJB\n*%       TM    QMISCFLG,QMFMVSE         running MVS/XA?\n*%       BZ    IN$SJBOK                 no, skip pit move\n*%       BAL   R14,QAMODE31             SJBs are >16M under JES2 3.1.1\n*%       MVC   IN@SJB(256),0(R5)        so copy it to 24 bit storage\n*%       MVC   IN@SJB+256(SJBSIZE-256),256(R5)  ...\n*%       LA    R5,IN@SJB                and fake the SJB address\n*%       BAL   R14,QAMODE24             back to the way we were\n         USNGX SJBDSECT,R5\nIN$SJBOK L     R1,SJBJQOFF              POINT TO JOB QUEUE OFFSET\n         A     R1,QCJQTA                POINT TO THE JQE\n         USNGX JQEDSECT,R1\n         CLC   JQEJNAME,SJBJOBNM        TEST FOR RIGHT JOB\n         BNE   IN$DISP                  WRONG JOB - SKIP IT\n         LH    R0,JQEJOBNO              LOAD JOB NUMBER\n         CVD   R0,IN@DWD                GET THE DECIMAL VALUE\n         MVC   IN@TEMP,=X'402020202120'  MOVE IN EDIT MASK\n         ED    IN@TEMP,IN@DWD+5         GET THE CHARACTER VALUE\n         MVC   IN@JNUM,IN@TEMP+2        MOVE TO DISPLAY LINE\n         MVC   IN@JOBNM,SJBJOBNM        MOVE IN JOBNAME\n         MVC   IN@JCLAS,JQETYPE         GET JOB CLASS (SORT OF)\n         OI    IN@JCLAS,X'80'           MAKE IT DISPLAYABLE\n         MVC   QCTRAK,JQETRAK           DISK ADDR OF JCT\n         L     R3,QCJCTA                ADDR OF IOAREA FOR JCT\n         DROPX R1                       JQEDSECT\n         LR    R0,R1                    -> JQE\n         LR    R1,R3                    PARM FOR READSPC\n         MVC   QCCBID,=C'JCT '          SHOW WHAT WE NEED\n         QCALL READSPC                  READ HASPACE\n         USNGX JCTSTART,R3\n         OC    JCTXDTON,JCTXDTON        ANY START DATE?\n         BZ    IN$DISP                  NO - DON'T FORMAT START TIME\n         CLI   QKEYWORD,C'S'            WANT START TIMES?\n         BNE   IN$ELAPS                 NO - DEFAULT IS ELAPSED TIME\n         SPACE 2\n*---  FORMAT THE START DATE (FROM PACKED)\n         UNPK  IN@STDAT+1(5),JCTXDTON+1(3)  GET YYDDD\n         MVC   IN@STDAT(2),IN@STDAT+1   GET YYYDDD\n         MVI   IN@STDAT+2,C'.'          GET YY.DDD\n*---  FORMAT THE START TIME (FROM BINARY)\n         L     R1,JCTXEQON              PICK UP BINARY TIME\n         SR    R0,R0                    CLEAR FOR DIVIDE\n         D     R0,=F'100'               CONVERT TO SECONDS\n         SR    R0,R0                    CLEAR FOR DIVIDE\n         D     R0,=F'60'                R0 = SECONDS, R1 = MINUTES\n*        CVD   R0,IN@DWD\n*        OI    IN@DWD+7,X'0F'           REMOVE SIGN\n*        UNPK  IN@STTIM+6(2),IN@DWD\n*        MVI   IN@STTIM+5,C':'\n         SR    R0,R0                    CLEAR FOR DIVIDE\n         D     R0,=F'60'                R0 = MINUTES, R1 = HOURS\n         CVD   R0,IN@DWD\n         OI    IN@DWD+7,X'0F'           REMOVE SIGN\n         UNPK  IN@STTIM+3(2),IN@DWD\n         MVI   IN@STTIM+2,C':'\n         CVD   R1,IN@DWD\n         OI    IN@DWD+7,X'0F'           REMOVE SIGN\n         UNPK  IN@STTIM(2),IN@DWD\n         B     IN$DISP\n         SPACE 2\n*---  FORMAT THE ELAPSED TIME\nIN$ELAPS OC    JCTXDTON,JCTXDTON        ANYTHING HERE?\n         BZ    IN$DISP                  NO - DON'T GET AN 0C7\n         ZAP   IN@DNUM,IN@DATE          GET CURRENT DATE\n         SP    IN@DNUM,JCTXDTON         COMPUTE ELAPSED DAYS\n         L     R1,IN@TIME               GET CURRENT TIME\n         S     R1,JCTXEQON              COMPUTE ELAPSED TIME\n         BNM   IN$TIMOK                 CONTINUE IF SAME DAY\n         A     R1,=A(24*60*60*100)      NORMALIZE THE NUMBER\n         SP    IN@DNUM,=P'1'            AND FIX UP THE NUMBER OF DAYS\n         SPACE 1\nIN$TIMOK CP    IN@DNUM,=P'0'            > 24 HOURS?\n         BE    IN$NODAY                 NO - SKIP\n         OI    IN@DNUM+3,X'0F'          REMOVE SIGN\n         UNPK  IN@DAYS(2),IN@DNUM\n         MVC   IN@DAYS+3(4),=C'Days'    INDICATE DAYS\n         CP    IN@DNUM,=P'1'            1 DAY?\n         BNE   *+8                      NO - OK\n         MVI   IN@DAYS+3+4-1,C' '       YES - CHANGE 'DAYS' TO 'DAY '\n         CLI   IN@DAYS,C'0'             LEADING 0?\n         BNE   *+8                      NO - LEAVE IT\n         MVI   IN@DAYS,C' '             YES - CHEAPO EDIT\n         SPACE 2\nIN$NODAY SR    R0,R0                    CLEAR FOR DIVIDE\n         D     R0,=F'100'               CONVERT TO SECONDS\n         SR    R0,R0                    CLEAR FOR DIVIDE\n         AH    R1,=H'30'                ADD 1/2 MINUTE FOR ROUNDING\n         D     R0,=F'60'                R0 = SECONDS, R1 = MINUTES\n         LR    R15,R0                   SAVE SECONDS FOR NOW\n         SR    R0,R0                    CLEAR FOR DIVIDE\n         D     R0,=F'60'                R0 = MINUTES, R1 = HOURS\n         CVD   R0,IN@DWD\n         OI    IN@DWD+7,X'0F'           REMOVE SIGN\n         UNPK  IN@HOURS+3(2),IN@DWD\n         MVI   IN@HOURS+2,C':'\n         CVD   R1,IN@DWD\n         OI    IN@DWD+7,X'0F'           REMOVE SIGN\n         UNPK  IN@HOURS(2),IN@DWD\n         CP    IN@DNUM,=P'0'            > 24 HOURS?\n         BNE   IN$DISP                  YES - ALL DONE\n         MVC   IN@HOURS-3(5),IN@HOURS   NO - SHIFT HH:MM LEFT\n         CVD   R15,IN@DWD               AND PUT IN SECONDS\n         OI    IN@DWD+7,X'0F'           REMOVE SIGN\n         UNPK  IN@HOURS+3(2),IN@DWD\n         MVI   IN@HOURS+2,C':'\n***********************************************************************\n*                                                                     *\n*        SEND THE MESSAGE DESCRIBING THE PIT                          *\n*                                                                     *\n***********************************************************************\n         DROPX R5,R3                    SJBDSECT, JCTSTART\nIN$DISP  BAL   R14,QADDLINE             CALL THE ROUTINE\nIN$NEXT  ICM   R7,B'1111',PITNEXT       POINT TO NEXT PIT\n         BNZ   IN$LOOP                  DO NEXT IF IT EXISTS\n         B     QSTOP                    LEAVE IF NONE LEFT\nIN$NONE  QTILT '***** NO PITS TO DISPLAY *****'\nIN$TILT  MVC   QERRMSG,QBLANK\n         MVC   QERRMSG(3),=C'***'\n         MVC   QERRMSG+4(4),QJESNAME\n         MVC   QERRMSG+9(13),=C'IS NOT UP ***'\n         QTILT *\n         ENTRY IN#KEYS\nIN#KEYS  DC    CL8'START   ',CL8'S       '\n         DC    X'FF'                    END OF TABLE\n         LTORG ,\n***********************************************************************\n*                                                                     *\n*        DESCRIBE ALL THE DSECTS NEEDED BY THIS MODULE                *\n*                                                                     *\n***********************************************************************\n         SPACE 3\n         QCOMMON\n         ORG   QDMSG\nIN@JOBNM DS    CL8,C\nIN@ATTR1 DS    XL2\nIN@JNUM  DS    CL4,CL2\nIN@JCLAS DS    CL1,C\nIN@ATTR2 DS    XL2\nIN@DAYS  DS    0CL7\n         DS    C\nIN@STDAT DS    CL6,C\nIN@HOURS DS    0CL5\nIN@STTIM DS    CL5,CL2\nIN@INIT  DS    CL2,C\nIN@ATTR3 DS    XL2\nIN@STAT  DS    CL8\nIN@ATTR4 DS    XL2\nIN@CLASS DS    C\nINMAXCLS EQU   80-(IN@CLASS-QDMSG)      MAXIMUM CLASSES WE CAN DISPLAY\nWORK     DSECT\n         ORG   WORK+72                  SKIP OVER SAVE AREA\nIN@TIME  DS    F\nIN@DATE  DS    F\n*%IN@PIT DS    CL64                     COPY OF PIT FOR MVS/XA\n*%IN@SJB DS    CL320                    COPY OF SJB FOR MVS/XA\nIN@WORKL EQU   *-WORK\nIN@DWD   DS    D\nIN@DNUM  DS    PL4\nIN@TEMP  DS    CL6\n         DROPX R7,R8,R13                PITDSECT, SSVT, WORK\n         SPACE 3\n         Q$SVT\n         Q$HCCT\n         Q$PIT\n*%       DS    0CL(L'IN@PIT-PITLEN)     insure IN@PIT is long enough\n         Q$SJB\n*%       DS    0CL(L'IN@SJB-SJBSIZE)    insure IN@SJB is long enough\n         Q$JQE\n         Q$JCT\n         QZCVT\n         QZSSCT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "Q#JI": {"ttr": 11270, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x05(\\x00\\x00\\x00\\x82#/\\x00\\x91'/#\\x10\\x03\\x16\\x01o\\x02\\x96\\xe2\\xc1\\xd3\\xc2\\xc5\\xd9\\xe3@@@\"", "ispf": {"version": "05.40", "flags": 0, "createdate": "1982-08-20T00:00:00", "modifydate": "1991-09-29T23:10:00", "lines": 790, "newlines": 367, "modlines": 662, "user": "SALBERT"}, "text": "         TITLE '--- QUEUE--JOBINFO -- DISPLAY INFORMATION FROM JCT ---'\n*---------------------------------------------------------------------*\n*                                                                     *\n*   JOBINFO - Display JCT Fields                                      *\n*                                                                     *\n*   NOTE - \"JX\" subcommand is restricted to privileged users          *\n*                                                                     *\n*   Updates:                                                          *\n*      29Sep91  GLA  Fix loop in 4.2 access to JCT NJE section  29SEP91\n*      05Jun91  EMS  Update for SP420 (JCT NJE section)               *\n*      28Nov90  EMS  Update for SP410                                 *\n*      25Dec89  LDW  QACxxx -> QZACxxx:  CVT, JCB, NJBL, VALD         *\n*      23Nov89  LDW  Remove conditional assembly around Qxxx macros   *\n*      22Mar89  EMS  Update for SP311                                 *\n*      12Feb89  LDW  Add JCTBYTES and JCTESTBY                        *\n*      29Jun88  LDW  Add JCTNACCT to hex display                      *\n*      10Jan88  LDW  Update for QITEM macro (no more \"LC\")            *\n*      15Jun87  EMS  Update again for QITEM macro                     *\n*                    Update for base JES2                             *\n*      22May87  EMS  Update for enhanced QITEM macro                  *\n*      29Nov86  LDW  Use DATEFMT to format dates                      *\n*      26NOV86  LDW  ADD NJHGUSID, NJHGXEQU, NJHGPRTR,                *\n*                        NJH2USR, NJH2GRP, NJH2SUSR, NJH2SGRP         *\n*      08AUG86  EMS  FIX FOR ACF2 RELEASE PRE 4.1                     *\n*      22JUN86  LDW  USE &@@ACF2 INSTEAD OF &QACF2                    *\n*               LDW  UPDATE FOR ACF2 RELEASE 4.1                      *\n*               LDW  DISPLAY MSGS FOR SOME FLAGS IN ACFNJFL1, FL3     *\n*      05JUN86  LDW  SHOW STC FLAG & SUB AUTH FLAG FOR ACF2           *\n*      04/07/86 LDW  PUT TODAY'S JULIAN DATE IN HEADER LINE           *\n*      03/31/86 LDW  RE-DESIGN 3278-5 SUPPORT (THIRD TRY!)            *\n*      11/22/85 LDW  MOVE BUILDING DISPLAY;  ADD DEPARTMENT & NETACCT *\n*      11/17/85 LDW  USE JQEHLDCT INSTEAD OF JCTHDSCT, WHICH WAS      *\n*                       REMOVED BY UZ90341                            *\n*      02/06/85 LDW  DISPLAY BLDG                                     *\n*      04/11/84 LDW  JCTDSECT -> JCTSTART                             *\n*                    USING/DROP -> USNGX/DROPX                        *\n*      04/10/84 LDW  SP133 UPDATES                                    *\n*      03/27/84 LDW  UPDATE FOR JES2 SP13 WITH ACF2 R314              *\n*                    DISPLAY NETWORK FIELDS FOR JES2 SP13             *\n*                    MOVE FIELDS AROUND TO SAVE DISPLAY LINES         *\n*                    FIX NOTIFY AFFINITY BUG                          *\n*      01/19/84 LDW  ADD SUPPORT FOR COMMAND STACKING                 *\n*      10/12/83 LDW  FIX BUG IN 07/12/83 UPDATE                       *\n*                    FIX JCTXMASK DISPLAY                             *\n*      07/19/83 LDW  FIX MINOR BUG IN 07/12/83 UPDATE                 *\n*                    FIX MINOR BUG IN 10/20/82 UPDATE                 *\n*      07/12/83 LDW  DISPLAY AFFINITY FOR NOTIFY                      *\n*      04/11/83 LDW  FIX PROBLEM WITH BAD DROP IF SP & NOT ACF2       *\n*      01/26/83 LDW  ACF2 SP SUPPORT                                  *\n*                    VALIDITY CHECK JCTACFJ                           *\n*                    REPLACE JQEPRTRT & JQEPUNRT WITH JCTPROUT &      *\n*                       JCTPUOUT, REMOVE THOSE JCT FIELDS FROM JDX    *\n*                    REMOVE JCTPSN1 & JCTPSN2, SINCE THEY SEEM TO     *\n*                       ALWAYS BE BLANK ANYWAY                        *\n*      01/17/83 LDW  ADD ACVSRCE, ACVSLID, ACVAPROG, ACVPATH          *\n*                    CHANGE HEADER TO LOWER CASE                      *\n*                    REMOVE BLANK LINE AFTER 'INPUT AT' LINE          *\n*                    CHANGES FOR NEW QITEM MACRO (WHICH USES \"LC\")    *\n*                    ADD SECOND BASE REGISTER!!!                      *\n*      10/26/82 LDW  TRANSLATE ALL CHARACTER FIELDS                   *\n*      10/25/82 LDW  TRANSLATE JCTUSEID TO PRINTABLE, ALSO SHOW IN HEX*\n*      10/20/82 LDW  ADD SYSTEM AFFINITY TO DISPLAY                   *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 3\nJOBINFO  QSTART  Q83,WORKLEN=JI@WORKL,STACK=X'30'\n         USNGX WORK,R13\n         LA    R10,4095(,R12)           SET UP SECOND ...\n         LA    R10,1(,R10)              ... BASE REGISTER\n         USNGX JOBINFO+4096,R10\n         QITEM RESET,PREFIX=JI          RESET GLOBAL ARRAY POINTER\n         QCALL FINDJOB                  LOCATE THE JQE, JCT, IOT\n         L     R9,QCJCTA                -> JCT\n         USNGX JCTSTART,R9\n         L     R8,QCJQEA                -> JQE\n         USNGX JQEDSECT,R8\n         OI    QSCFLAG1,QSC1JOB         PUT JOBID IN QDTOP\n         QCALL DISP80                   SWITCH TO 3278-2 MODE IF 3278-5\n*---  HEADER LINE\n         CLI   QCODE,4                  IS THIS JX?\n         BE    JOBXINFO                 YES - GO THERE\n         MVC   QDHLINE(30),=C'Detailed Job Information for \"'\n         MVC   QDHLINE+30(18),QDHJOBID  MOVE JOBID TO TITLE LINE\n         MVI   QDHLINE+48,C'\"'\n*        TIME  BIN                      GET CURRENT DATE\n*        LR    R0,R1                    Set date for DATEFMT subroutine\n*        LA    R1,QDHLINE+L'QDHLINE-7   -> output area\n*        QCALL DATEFMT\n         QITEM              ,,QDHLINE+L'QDHLINE-7,DATE,0\n         SPACE 2\n*---  LINE 01\n         BAL   R14,QADDLINE             DISPLAY A BLANK LINE\n         SPACE 2\n*---  LINE 02\n**       QITEM 0+00,'Notify',2+16,CHAR,JCTTSUID,7\n         QITEM 0+00,'Notify',2+12,CHAR,JCTTSUID,7\n         MVC   JI@LINE+2+20(6),JI#ON    'ON'\n         IC    R0,JCTTSUAF              GET NOTIFY AFFINITY FLAGS\n         N     R0,=A(QUESYSAF)          STRIP OFF GARBAGE\n         BZ    JI$PGMR                  BAIL OUT IF NONE HERE\n         L     R15,QVSYSID              -> ZERO'TH SYSTEM ID\n         SPACE 1\nJI$NSLP  LA    R15,8(,R15)              -> NEXT TABLE ENTRY\n         SRDL  R0,1                     MOVE LOWEST BIT TO R1\n         LTR   R1,R1                    HIGH BIT SET?\n         BNM   JI$NSLP                  NO - GO CHECK NEXT\n         MVC   JI@LINE+4+24(4),0(R15)   MOVE IN NOTIFY SYSTEM ID\n         SPACE 2\nJI$PGMR  QITEM 4+30,'Programmer',6+45,CHAR,JCTPNAME,20\n         QITEM 6+69,'Room',8+75,CHAR,JCTROOMN,4\n         MVI   QDATRNUM+1,2*4           NUMBER OF ATTR BYTES IN LINE\n         BAL   R14,QADDLINE             DISPLAY LINE\n         SPACE 2\n*---  LINE 03\n         MVC   JI@LINE(4+11),JI#INPUT   'INPUT ROUTE'\n         LA    R1,JCTROUTE              POINT TO INPUT ROUTE FIELD\n         QCALL FINDRJE                  CONVERT TO RJE ID\n         MVC   JI@LINE+2+16(8),0(R1)    MOVE RJE ID TO DISPLAY LINE\n         CLC   JI@LINE+2+16(8),QBLANK   BLANK? (LOCAL)\n         BNE   *+10                     NO - KEEP IT\n         MVC   JI@LINE+2+16(7),=C'(LOCAL)'  YES - SAY SO\n         QITEM 2+30,'Input Class',4+45,CHAR,JCTJCLAS,1\n         CLI   JI@LINE+4+45,X'E0'       TSU?\n         BNE   *+8                      NO - SKIP\n         MVI   JI@LINE+4+45,C'@'        YES - SHOW JES2'S STYLE CLASS\n         CLI   JI@LINE+4+45,X'D0'       STC?\n         BNE   *+8                      NO - SKIP\n         MVI   JI@LINE+4+45,C'$'        YES - SHOW JES2'S STYLE CLASS\n         QITEM 4+55,'Copies',6+70,DEC,JCTCPYCT,1\n         MVI   QDATRNUM+1,2*3           NUMBER OF ATTR BYTES IN LINE\n         BAL   R14,QADDLINE             DISPLAY LINE\n         SPACE 2\n*---  LINE 04\n         QITEM 0+00,'Account',2+16,CHAR,JCTACCTN,4\n         QITEM 2+30,'Msgclass',4+45,CHAR,JCTMCLAS,1\n          AIF   (&QLEVEL GT 4).JI020\n         QITEM 4+55,'Forms',6+70,CHAR,JCTFORMS,4\n          AGO   .JI040\n.JI020    ANOP\n         QITEM 4+55,'Forms',6+70,CHAR,JCTFORMS,8\n.JI040    ANOP\n         MVI   QDATRNUM+1,2*3           NUMBER OF ATTR BYTES IN LINE\n         BAL   R14,QADDLINE             DISPLAY LINE\n         SPACE 2\n*---  LINE 05\n         BAL   R14,QADDLINE             DISPLAY LINE\n         SPACE 2\n*---  LINE 06\n         MVC   JI@LINE(4+12),JI#SYSAF   'SYS AFFINITY'\n         LA    R14,JI@LINE+2+16         -> WHERE THE FIRST WILL GO\n         TM    JQEFLAG2,QUESYSAF        SYSAFF=ANY?\n         BNO   NOT$ANY                  NO - SKIP\n         MVC   0(3,R14),=C'ANY'         YES - SHOW IT\n         LA    R14,5(,R14)              BUMP OUTPUT PTR\n         B     TEST$IND                 GO CHECK INDEPENDENT MODE\n         SPACE 1\nNOT$ANY  IC    R0,JQEFLAG2              GET SYSTEM AFFINITY FLAGS\n         N     R0,=A(QUESYSAF)          STRIP OFF GARBAGE\n         SR    R1,R1                    CLEAR FOR SRDL\n***      LA    R15,QSYSID               -> ZERO'TH SYSTEM ID\n         L     R15,QVSYSID              -> ZERO'TH SYSTEM ID\n         SPACE 1\nAFF$LOOP LA    R15,L'QSYSID(,R15)       -> NEXT SYSTEM ID\n         SRDL  R0,1                     SHIFT LOWEST BIT TO R1\n         LTR   R1,R1                    IS THIS BIT SET?\n         BZ    NOT$THIS                 NO - SKIP\n         MVC   0(4,R14),0(R15)          MOVE SYSID TO DISPLAY LINE\n         LA    R14,6(,R14)              BUMP OUTPUT PTR\nNOT$THIS LTR   R0,R0                    ANY MORE BITS SET?\n         BNZ   AFF$LOOP                 YES - CONTINUE\n         SPACE 1\nTEST$IND TM    JQEFLAG2,QUEINDAF        INDEPENDENT MODE?\n         BNO   *+10                     NO - SKIP\n         MVC   0(3,R14),=C'IND'         YES\n         QITEM 2+55,'Req Prty',4+70,CHAR,JCTPRTY,2\n         MVI   QDATRNUM+1,2*2           NUMBER OF ATTR BYTES IN LINE\n         BAL   R14,QADDLINE             DISPLAY LINE\n*---  LINE 07\n         QITEM 0+00,'Input Device',2+16,CHAR,JCTINDEV,8\n         QITEM 2+30,'Jes2 Proclib',4+45,CHAR,JCTPROCN,8\n         QITEM 4+55,'Exec Prty',6+70,HEX,JCTPRIO,1\n         MVI   QDATRNUM+1,2*3           NUMBER OF ATTR BYTES IN LINE\n         BAL   R14,QADDLINE             DISPLAY LINE\n         SPACE 2\n*---  LINE 08\n         QITEM 0+00,'Input Cards',2+16,DEC,JCTCARDS\n         QITEM 2+55,'Input Prty',4+70,HEX,JCTIPRIO,1\n         MVI   QDATRNUM+1,2*2           NUMBER OF ATTR BYTES IN LINE\n         BAL   R14,QADDLINE             DISPLAY LINE\n         SPACE 2\n*---  LINE 09\n         QITEM 0+00,'Input At',2+16,DATE,JCTCDTOF,SKIP=NO$INPUT\n         QITEM               ,,2+25,TIME,JCTCNVOF\nNO$INPUT QITEM 2+34,'On',4+39,CHAR,JCTRDSID,4\n         QITEM 4+55,'Est Time',6+70,DEC,JCTETIME\n         MVI   QDATRNUM+1,2*3           NUMBER OF ATTR BYTES IN LINE\n         BAL   R14,QADDLINE             DISPLAY LINE\n         SPACE 2\n*---  LINE 10\n         QITEM 0+00,'Start Exec',2+16,DATE,JCTXDTON,SKIP=NO$EXECS\n         QITEM                 ,,2+25,TIME,JCTXEQON\nNO$EXECS QITEM 2+34,'On',4+39,CHAR,JCTEXSID,4\n         OC    JCTXDTON,JCTXDTON        ANY DATE?\n         BNZ   JI$OPRTY                 YES - OK\n         MVC   JI@LINE+2(10),QBLANK     REMOVE 'START EXEC'\n         MVC   JI@LINE+2+34+2(2),QBLANK REMOVE 'ON'\n         MVC   JI@LINE+4+39(4),QBLANK   REMOVE SID\nJI$OPRTY QITEM 4+55,'Output Prty',6+70,HEX,JCTOPRIO,1\n         QITEM                  ,,6+75,HEX,JCTIOPRI,1\n         MVI   JI@LINE+6+74,C'('\n         MVI   JI@LINE+6+77,C')'\n         MVI   QDATRNUM+1,2*3           NUMBER OF ATTR BYTES IN LINE\n         BAL   R14,QADDLINE             DISPLAY LINE\n         SPACE 2\n*---  LINE 11\n         QITEM 0+00,'  End Exec',2+16,DATE,JCTXDTOF,SKIP=NO$EXECE\n         QITEM                 ,,2+25,TIME,JCTXEQOF\n         B     *+10                     SKIP AROUND\nNO$EXECE MVC   JI@LINE+2(10),QBLANK     REMOVE '  END EXEC'\n          AIF  (&QLEVEL GE 11).JI100    (this needs work%%%%)\n          AIF  (&QLEVEL GE 9).JI060\n         LH    R0,JQEHLDCT              GET HELD DATASET COUNT\n         SRL   R0,4                     SHIFT OUT GARBAGE\n          AGO  .JI080\n.JI060    ANOP ,\n         SR    R0,R0                    clear\n         ICM   R0,B'0111',JQEHDSCT      get held dataset count\n.JI080    ANOP ,\n         STH   R0,JI@DWD                SAVE TEMPORARILY\n         QITEM 2+55,'Held Datasets',4+70,DEC,JI@DWD,2\n         MVI   QDATRNUM+1,2*2           NUMBER OF ATTR BYTES IN LINE\n.JI100    ANOP ,\n         BAL   R14,QADDLINE             DISPLAY LINE\n         SPACE 2\n*---  LINE 12\n         BAL   R14,QADDLINE             DISPLAY LINE\n         SPACE 2\n*---  LINE 13\n         QITEM 0+00,'Output Lines',2+16,DEC,JCTLINES\n         QITEM 2+30,'Estimated',4+45,DEC,JCTESTLN\n         LA    R1,JCTPROUT              POINT TO PRINT ROUTE FIELD\n         BAL   R2,JI$RJE                FORMAT IT TO JI@LINE+2+70\n         MVI   QDATRNUM+1,2*3           NUMBER OF ATTR BYTES IN LINE\n         BAL   R14,QADDLINE             DISPLAY LINE\n         SPACE 2\n*---  LINE 14\n         QITEM 0+00,'Output Cards',2+16,DEC,JCTPUNCH\n         QITEM 2+30,'Estimated',4+45,DEC,JCTESTPU\n         LA    R1,JCTPUOUT              POINT TO PUNCH ROUTE FIELD\n         BAL   R2,JI$RJE                FORMAT IT TO JI@LINE+2+70\n         MVI   QDATRNUM+1,2*3           NUMBER OF ATTR BYTES IN LINE\n         BAL   R14,QADDLINE             DISPLAY LINE\n         SPACE 2\n          AIF  (&QLEVEL LT 5).JI120\n*---  LINE 15\n         QITEM 0+00,'Output Bytes',2+16,DEC,JCTBYTES\n         QITEM 2+30,'Estimated',4+45,DEC,JCTESTBY\n         MVI   QDATRNUM+1,2*2           NUMBER OF ATTR BYTES IN LINE\n         BAL   R14,QADDLINE             DISPLAY LINE\n.JI120    ANOP\n         SPACE 2\n*---  LINE 16\n         BAL   R14,QADDLINE             DISPLAY LINE\n         SPACE 2\n          AIF   (&QLEVEL LT 4).JI280\n         SPACE 2\n*---  LINE 17\n          AIF   (&QLEVEL GE 12).JI140\n         LA    R3,JCTNJHDR              -> NETWORK JOB HEADER\n          AGO   .JI160\n.JI140    ANOP\n         L     R3,QCJCTNJH              -> NETWORK JOB HEADER\n         LA    R3,NHSBDATA-NHSBSTRT(,R3) -> real data           29SEP91\n.JI160    ANOP\n         USNGX NJHDSECT,R3\n         QITEM 0+00,'Origin Node',2+16,CHAR,NJHGORGN,8\n         QITEM 2+30,'Exec Node',4+45,CHAR,NJHGXEQN,8\n         QITEM 4+55,'Print Node',6+70,CHAR,NJHGPRTN,8\n         MVI   QDATRNUM+1,2*3           NUMBER OF ATTR BYTES IN LINE\n         BAL   R14,QADDLINE             DISPLAY LINE\n         SPACE 2\n*---  LINE 17\n         QITEM 0+00,'Origin Userid',2+16,CHAR,NJHGUSID,8\n         QITEM 2+30,'Exec Userid',4+45,CHAR,NJHGXEQU,8\n         QITEM 4+55,'Print Remote',6+70,CHAR,NJHGPRTR,8\n         MVI   QDATRNUM+1,2*3           NUMBER OF ATTR BYTES IN LINE\n         BAL   R14,QADDLINE             DISPLAY LINE\n         SPACE 2\n*---  LINE 18\n         QITEM 0+00,'Building',2+16,CHAR,NJHGBLDG,8\n         QITEM 2+30,'Department',4+45,CHAR,NJHGDEPT,8\n         QITEM 4+55,'NetAcct',6+70,CHAR,NJHGACCT,8\n         MVI   QDATRNUM+1,2*3           NUMBER OF ATTR BYTES IN LINE\n         BAL   R14,QADDLINE             DISPLAY LINE\n         SPACE 2\n          AIF   (&QLEVEL LT 5).JI180    SKIP IF NO EARLYVERIFY SUPPORT\n**********  IF YOU HAVE JES2 RELEASE 1.3.4 WITHOUT THE EARLYVERIFY\n**********  SPE, YOU'RE ON YOUR OWN HERE...\n*---  LOCATE THE JES2 SECTION IN THE NETWORK JOB HEADER            ---*\n         LH    R0,NJHLEN                GET LENGTH OF BLOCK\n         SH    R0,=H'4'                 ADJUST LENGTH FOR THE PREFIX\n         LA    R6,4(,R3)                -> FIRST SECTION\n         USNGX NJH2,R6\n         SPACE 1\nJI$J2$LP CLC   NJH2TYPE(2),=AL1(NTYPJES2,NJH2$MOD)  THIS THE JES2 SECT?\n         BE    JI$JES2                  YES - CONTINUE\n         SH    R0,NJH2LEN               SUBTRACT LENGTH OF SECTION\n         AH    R6,NJH2LEN               -> NEXT SECTION\n         LTR   R0,R0                    ANY MORE SECTIONS?\n         BP    JI$J2$LP                 YES - CHECK NEXT\n         B     JI$NO$J2                 NO - SKIP\n         SPACE 1\n*---  LINE 19\nJI$JES2  QITEM 0+00,'JCL Userid',2+16,CHAR,NJH2USR,8\n         QITEM 2+30,'JCL Group',4+45,CHAR,NJH2GRP,8\n         MVI   QDATRNUM+1,2*2           NUMBER OF ATTR BYTES IN LINE\n         BAL   R14,QADDLINE             DISPLAY LINE\n         SPACE 2\n*---  LINE 20\n         QITEM 0+00,'Submitted by',2+16,CHAR,NJH2SUSR,8\n         QITEM 2+30,'Sub-by group',4+45,CHAR,NJH2SGRP,8\n         MVI   QDATRNUM+1,2*2           NUMBER OF ATTR BYTES IN LINE\n         BAL   R14,QADDLINE             DISPLAY LINE\n         SPACE 2\n         DROPX R6                       NJH2\nJI$NO$J2 EQU   *\n.JI180    ANOP\n          AIF   (&@@ACF2 EQ 0).JI280\n         SPACE 2\n         BAL   R14,QADDLINE             DISPLAY LINE\n         SPACE 2\n*---  LOCATE THE ACF2 USER SECTION IN THE NETWORK JOB HEADER       ---*\n*---  SEE ACF2.R314.ACFJES(ACF2X1) AT LABEL #ACFNJH1               ---*\n*---  OR SKK PRIVATE MACRO ACF2LNJS                                ---*\n         LH    R0,NJHLEN                GET LENGTH OF BLOCK\n         SH    R0,=H'4'                 ADJUST LENGTH FOR THE PREFIX\n         LA    R3,4(,R3)                -> FIRST SECTION\n         DROPX R3                       NJHDSECT\n         USNGX NJHU,R3\n         SPACE 1\nJI$NJ$LP CLC   NJHUTYPE(6),JI#ACFID     IS THIS THE ACF2 USER SECTION?\n         BE    JI$ACF2                  YES - CONTINUE\n         SH    R0,NJHULEN               SUBTRACT LENGTH OF SECTION\n         AH    R3,NJHULEN               -> NEXT SECTION\n         LTR   R0,R0                    ANY MORE SECTIONS?\n         BP    JI$NJ$LP                 YES - CHECK NEXT\n         MVC   JI@LINE(JI#ACF0L),JI#ACF0  'NO ACF2 USER SECTION'\n         MVI   QDATRNUM+1,2*1           NUMBER OF ATTR BYTES IN LINE\n         BAL   R14,QADDLINE             DISPLAY LINE\n         B     QSTOP\n         DROPX R3                       NJHU\n         USNGX ACFNJBLK,R3\n*---  LINE 20\nJI$ACF2  LA    R4,ACFNJVLD              -> ACVALD BLK IN JCB\n         USNGX ACVALD,R4\n         MVC   JI@DWD(8),=CL8'*ERROR*'  ASSUME UNKNOWN\n         TM    ACFNJFL1,ACFJES2         ORIGIN NODE JES2?\n         BZ    *+10                     NO - SKIP\n         MVC   JI@DWD(8),=CL8'JES2'     YES - REMEMBER\n         TM    ACFNJFL1,ACFJES3         ORIGIN NODE JES3?\n         BZ    *+10                     NO - SKIP\n         MVC   JI@DWD(8),=CL8'JES3'     YES - REMEMBER\n         TM    ACFNJFL1,ACFRSCS         ORIGIN NODE RSCS?\n         BZ    *+10                     NO - SKIP\n         MVC   JI@DWD(8),=CL8'RSCS'     YES - REMEMBER\n         QITEM 0+00,'ACF2 LogonID',2+16,CHAR,ACVLID,8\n         QITEM 2+30,'Org Node Type',4+45,CHAR,JI@DWD,8\n         MVI   QDATRNUM+1,2*2           NUMBER OF ATTR BYTES IN LINE\n         BAL   R14,QADDLINE             DISPLAY LINE\n         SPACE 2\n*---  LINE 21\n         QITEM 0+00,'Source',2+16,CHAR,ACVSRCE,8\n         QITEM 2+30,'Submitted By',4+45,CHAR,ACVSLID-2,10\n         QITEM                   ,,4+57,CHAR,ACVAPROG,8\n         QITEM                   ,,4+70,CHAR,ACVPATH,8\n         MVC   JI@LINE+4+45(2),QBLANK   CLEAR KLUDGED AREA\n         TM    ACVCNTL,ACVCPROC         IS ACVSLID AN STC PROC NAME?\n         BZ    JI$NSTC                  NO - SKIP\n         MVC   JI@LINE+4+45(2),=C'S-'   YES - FLAG IT\n         B     *+10                     SKIP AROUND\nJI$NSTC  MVC   JI@LINE+4+45(10),JI@LINE+4+47  SHIFT IT LEFT\n         TM    ACVCNTL,ACVCAUTH         SUBMITTING JOB/PGM APF AUTH?\n         BZ    JI$NAPF                  NO - SKIP\n         MVI   JI@LINE+4+56,C'*'        YES - FLAG IT\n         B     *+10                     SKIP AROUND\nJI$NAPF  MVC   JI@LINE+4+56(9),JI@LINE+4+57  SHIFT IT LEFT\n         MVI   QDATRNUM+1,2*2           NUMBER OF ATTR BYTES IN LINE\n         BAL   R14,QADDLINE             DISPLAY LINE\n         SPACE 2\n*---  LINE 22\n         TM    ACFNJFL1,ACFNOTSK        NO ACF2 READER SUBTASK ACTIVE?\n          AIF   (&@@ACF2 GE 410).JI200\n         BZ    QSTOP                    WRONG - SKIP\n          AGO   .JI220\n.JI200    ANOP\n         BZ    JI$ASTOK                 WRONG - SKIP\n.JI220    ANOP\n         MVC   JI@LINE(JI#ANSTL),JI#ANST  'NO ACF2 READER SUBTASK ACT'\n         MVI   QDATRNUM+1,2*1           NUMBER OF ATTR BYTES IN LINE\n         BAL   R14,QADDLINE             DISPLAY LINE\n          AIF   (&@@ACF2 LT 410).JI240\nJI$ASTOK TM    ACFNJFL3,ACFNFAIL        S/TSK FAILURE W/PROCESSING JOB?\n         BZ    QSTOP                    WRONG - SKIP\n         MVC   JI@LINE(JI#ASTFL),JI#ASTF  'S/TASK FAILURE'\n         MVI   QDATRNUM+1,2*1           NUMBER OF ATTR BYTES IN LINE\n         BAL   R14,QADDLINE             DISPLAY LINE\n.JI240    ANOP\n         B     QSTOP                    ALL DONE\n         SPACE 2\n         DROPX R3,R4                    ACFNJBLK, ACVALD\n          AGO   .JI280\n*---  LINE 16\n         BAL   R14,QADDLINE             DISPLAY LINE\n         SPACE 2\n*---  LINE 17\n          AIF   (&QLEVEL LT 4).JI260\n          AGO   .JI280                  *** FOR JES2 SP13 + ACF2 R314\n         ICM   R6,B'1111',&ACF2JCT      OFFSET OF ACF2 USER AREA\n         BZ    JI$XACF2                 SKIP IF NO GOOD\n*---  THE FOLLOWING IS A KLUDGE.  THE REAL NUMBER SHOULD BE        ---*\n*---  'BUFSTART-BUFDSECT', BUT IF I CODE A $BUFFER MACRO, IT WILL  ---*\n*---  MESS UP USAGE OF $HQT, $IOT, AND $JCT.  THIS WILL HAVE TO BE ---*\n*---  STRAIGHTENED OUT SOMETIME IN THE FUTURE, WHEN I FEEL LIKE IT.---*\n         AR    R6,R9\n         SH    R6,=Y(X'58')             -> ACF2 USER AREA\n         USNGX #ACFJCTX,R6\n          AGO   .JI260                  SKIP JES2 SP13 + ACF2 R314 CODE\n.JI260    ANOP\n         CLC   =C'ACFJ',JCTACFJ         IS IT ANY GOOD?\n         BNE   JI$XACF2                 NO - SAY SO\n         QITEM 0+00,'ACF2 LogonID',2+16,CHAR,LIDLID,8\n         QITEM 2+30,'User Name',4+45,CHAR,LIDNAME,20\n         MVI   QDATRNUM+1,2*2           NUMBER OF ATTR BYTES IN LINE\n         BAL   R14,QADDLINE             DISPLAY LINE\n         SPACE 2\n*---  LINE 18\n         QITEM 0+00,'User Phone',2+16,CHAR,LIDPHONE,12\n         MVC   JI@LINE+2+30(4+8),JI#ACFUI  'ACF2 UID'\n         SPACE 1\n         ACFINCVT  R2,NONE=JI$NACF2\n         SPACE 1\n         L     R2,ACCFDR-ACCVT(,R2)     -> FDR\n         L     R1,32(,R2)               -> FIRST UID ENTRY\n         L     R0,36(,R2)               UID ENTRY COUNT\n         LA    R14,JI@LINE+4+45         -> OUTPUT LOC\n         SPACE 1\nJI$ACFLP LH    R15,0(,R1)               GET FIELD OFFSET\n         LA    R2,LIDREC(R15)           -> LID FIELD\n         LH    R15,2(,R1)               LENGTH OF LID FIELD\n         BCTR  R15,0                    -1 FOR EX\n         EX    R15,*+4                  MOVE THIS FIELD\n         MVC   0(*-*,R14),0(R2)         << EXECUTED >>\n         LA    R1,4(,R1)                -> NEXT UID ENTRY\n         LA    R14,1(R15,R14)           -> NEXT OUTPUT LOC\n         BCT   R0,JI$ACFLP\n         TR    JI@LINE+4+45(24),0(R7)   KILL UNPRINTABLES IN UID STRING\n         MVI   QDATRNUM+1,2*2           NUMBER OF ATTR BYTES IN LINE\n         BAL   R14,QADDLINE             DISPLAY LINE\n         SPACE 2\n*---  LINE 19\nJI$ACF$S QITEM 0+00,'Source',2+16,CHAR,ACVSRCE,8\n         QITEM 2+30,'Submitted By',4+45,CHAR,ACVSLID,8\n         QITEM                   ,,4+55,CHAR,ACVAPROG,8\n         QITEM                   ,,4+65,CHAR,ACVPATH,8\n         MVI   QDATRNUM+1,2*2           NUMBER OF ATTR BYTES IN LINE\n         BAL   R14,QADDLINE             DISPLAY LINE\n         B     QSTOP                    ALL DONE\n         SPACE 2\nJI$NACF2 MVC   JI@LINE+4+45(JI#ACFNL),JI#ACFNA  '(NO ACF2 CVT AVAIL.)'\n         MVI   QDATRNUM+1,2*1           NUMBER OF ATTR BYTES IN LINE\n         BAL   R14,QADDLINE             DISPLAY LINE\n         B     JI$ACF$S                 DO REST OF ACF2 ITEMS\n         SPACE 2\nJI$XACF2 MVC   JI@LINE(JI#ACF0L),JI#ACF0\n         MVI   QDATRNUM+1,2*1           NUMBER OF ATTR BYTES IN LINE\n         BAL   R14,QADDLINE             DISPLAY LINE\n.JI280    ANOP\n         SPACE 2\n         B     QSTOP                    ALL DONE\n         SPACE 2\n***       AIF   (&QLEVEL LT 4 OR &@@ACF2 EQ 0).JI300\n          AGO   .JI300                  JES2 SP13 + ACF2 R314\n         DROPX R6                       #ACFJCTX\n.JI300    ANOP\n         SPACE 3\n*---  SPECIAL HEX FORMAT OF VARIOUS INTERESTING (MAYBE) FIELDS\nJOBXINFO MVC   QDHLINE(22),=C'Hex JCT and JQE fields'\n         SPACE 2\n*---  HEX LINE 1\n         QITEM 0+00,'JCTCDTOF',2+10,HEX,JCTCDTOF,4\n         QITEM 2+20,'JCTCDTON',4+30,HEX,JCTCDTON,4\n         QITEM 4+40,'JCTCLASS',6+50,HEX,JCTCLASS,1\n         QITEM 6+60,'JCTCNVON',8+70,HEX,JCTCNVON,4\n         MVI   QDATRNUM+1,2*4           NUMBER OF ATTR BYTES IN LINE\n         BAL   R14,QADDLINE             DISPLAY LINE\n         SPACE 2\n*---  HEX LINE 2\n         QITEM 0+00,'JCTCNVRC',2+10,HEX,JCTCNVRC,4\n         QITEM 2+20,'JCTCPUID',4+30,CHAR,JCTCPUID,4\n         QITEM 4+36,'JCTCVSID',6+46,CHAR,JCTCVSID,4\n         QITEM 6+52,'JCTESOUT',8+62,DEC,JCTESOUT,4\n         MVI   QDATRNUM+1,2*4           NUMBER OF ATTR BYTES IN LINE\n         BAL   R14,QADDLINE             DISPLAY LINE\n         SPACE 2\n*---  HEX LINE 3\n         QITEM 0+00,'JCTFLAG1',2+10,HEX,JCTFLAG1,1\n          AIF   (&QLEVEL GE 4).JI320\n         QITEM 2+20,'JCTHQT',4+30,HEX,JCTHQT,4\n          AGO   .JI340\n.JI320    ANOP\n         QITEM 2+20,'JCTSAMSK',4+30,HEX,JCTSAMSK,4\n.JI340    ANOP\n         QITEM 4+40,'JCTINDC',6+50,HEX,JCTINDC,1\n         QITEM 6+60,'JCTIOT',8+70,HEX,JCTIOT,4\n         MVI   QDATRNUM+1,2*4           NUMBER OF ATTR BYTES IN LINE\n         BAL   R14,QADDLINE             DISPLAY LINE\n         SPACE 2\n*---  HEX LINE 4\n         QITEM 0+00,'JCTJBKEY',2+10,HEX,JCTJBKEY,4\n         QITEM 2+20,'JCTJBOPT',4+30,HEX,JCTJBOPT,1\n          AIF   (&QLEVEL GT 4).JI360\n         QITEM 4+40,'JCTJLOGC',6+50,HEX,JCTJLOGC,4\n          AGO   .JI380\n.JI360    ANOP\n         QITEM 4+40,'JCTJDVT',6+50,CHAR,JCTJDVT,8\n.JI380    ANOP\n         QITEM 6+60,'JCTJMOPT',8+70,HEX,JCTJMOPT,1\n         MVI   QDATRNUM+1,2*4           NUMBER OF ATTR BYTES IN LINE\n         BAL   R14,QADDLINE             DISPLAY LINE\n         SPACE 2\n*---  HEX LINE 5\n         QITEM 0+00,'JCTJMRJN',2+10,CHAR,JCTJMRJN,8\n         QITEM 2+20,'JCTJOBFL',4+30,HEX,JCTJOBFL,1\n         QITEM 4+40,'JCTJOBIN',6+50,DEC,JCTJOBIN,4\n         QITEM 6+60,'JCTJQE',8+70,HEX,JCTJQE,4\n         MVI   QDATRNUM+1,2*4           NUMBER OF ATTR BYTES IN LINE\n         BAL   R14,QADDLINE             DISPLAY LINE\n         SPACE 2\n*---  HEX LINE 6\n         QITEM 0+00,'JCTJSFLG',2+10,HEX,JCTJSFLG,1\n         QITEM 2+20,'JCTJSSTP',4+30,HEX,JCTJSSTP,2\n         QITEM 4+40,'JCTJTCC',6+50,HEX,JCTJTCC,1\n         QITEM 6+60,'JCTJTFLG',8+70,HEX,JCTJTFLG,1\n         MVI   QDATRNUM+1,2*4           NUMBER OF ATTR BYTES IN LINE\n         BAL   R14,QADDLINE             DISPLAY LINE\n         SPACE 2\n*---  HEX LINE 7\n         QITEM 0+00,'JCTLINCT',2+10,HEX,JCTLINCT,1\n          AIF   (&QLEVEL GT 4).JI400\n         QITEM 2+20,'JCTMSGSC',4+30,HEX,JCTMSGSC,4\n          AGO   .JI420\n.JI400    ANOP\n         QITEM 2+20,'JCTNACCT',4+30,CHAR,JCTNACCT,8\n.JI420    ANOP\n         QITEM 4+40,'JCTOCTTR',6+50,HEX,JCTOCTTR,4\n         QITEM 6+60,'JCTODTOF',8+70,HEX,JCTODTOF,4\n         MVI   QDATRNUM+1,2*4           NUMBER OF ATTR BYTES IN LINE\n         BAL   R14,QADDLINE             DISPLAY LINE\n         SPACE 2\n*---  HEX LINE 8\n         QITEM 0+00,'JCTODTON',2+10,HEX,JCTODTON,4\n         QITEM 2+20,'JCTOTSID',4+30,CHAR,JCTOTSID,4\n         QITEM 4+40,'JCTOUTOF',6+50,HEX,JCTOUTOF,4\n         QITEM 6+60,'JCTOUTON',8+70,HEX,JCTOUTON,4\n         MVI   QDATRNUM+1,2*4           NUMBER OF ATTR BYTES IN LINE\n         BAL   R14,QADDLINE             DISPLAY LINE\n         SPACE 2\n*---  HEX LINE 9\n         QITEM 0+00,'JCTPDDBK',2+10,HEX,JCTPDDBK,2\n         QITEM 2+20,'JCTPDDBO',4+30,HEX,JCTPDDBO,2\n         QITEM 4+40,'JCTRDR',6+50,HEX,JCTRDR,2\n         QITEM 6+60,'JCTRDROF',8+70,HEX,JCTRDROF,4\n         MVI   QDATRNUM+1,2*4           NUMBER OF ATTR BYTES IN LINE\n         BAL   R14,QADDLINE             DISPLAY LINE\n         SPACE 2\n*---  HEX LINE 10\n         QITEM 0+00,'JCTRDRON',2+10,HEX,JCTRDRON,4\n         QITEM 2+20,'JCTRDTOF',4+30,HEX,JCTRDTOF,4\n         QITEM 4+40,'JCTRDTON',6+50,HEX,JCTRDTON,4\n         QITEM 6+60,'JCTROUTE',8+70,HEX,JCTROUTE,2\n         MVI   QDATRNUM+1,2*4           NUMBER OF ATTR BYTES IN LINE\n         BAL   R14,QADDLINE             DISPLAY LINE\n         SPACE 2\n*---  HEX LINE 11\n         QITEM 0+00,'JCTSMFLG',2+10,HEX,JCTSMFLG,1\n         QITEM 2+20,'JCTSPIOT',4+30,HEX,JCTSPIOT,4\n         QITEM 4+40,'JCTTSUAF',6+50,HEX,JCTTSUAF,1\n         QITEM 6+60,'JCTUCOM',8+70,HEX,JCTUCOM,4\n         MVI   QDATRNUM+1,2*4           NUMBER OF ATTR BYTES IN LINE\n         BAL   R14,QADDLINE             DISPLAY LINE\n         SPACE 2\n*---  HEX LINE 12\n         QITEM 0+00,'JCTUJVP',2+10,HEX,JCTUJVP,4\n         QITEM 2+20,'JCTUSEID',4+30,CHAR,JCTUSEID,8\n         MVI   JI@LINE+4+39,C'('\n         QITEM               ,,4+40,HEX,JCTUSEID,4\n         QITEM               ,,4+50,HEX,JCTUSEID+4,4\n         MVI   JI@LINE+4+58,C')'\n         QITEM 4+60,'JCTXOUT',6+70,DEC,JCTXOUT,4\n         MVI   QDATRNUM+1,2*3           NUMBER OF ATTR BYTES IN LINE\n         BAL   R14,QADDLINE             DISPLAY LINE\n         SPACE 2\n          AIF   (&QLEVEL LT 4).JI440\n*---  HEX LINE 13\n         QITEM 0+00,'JCTUSER0',2+10,HEX,JCTUSER0,4\n         QITEM 2+20,'JCTUSER1',4+30,HEX,JCTUSER1,4\n         QITEM 4+40,'JCTUSER2',6+50,HEX,JCTUSER2,4\n         QITEM 6+60,'JCTUSER3',8+70,HEX,JCTUSER3,4\n         MVI   QDATRNUM+1,2*4           NUMBER OF ATTR BYTES IN LINE\n         BAL   R14,QADDLINE             DISPLAY LINE\n         SPACE 2\n*---  HEX LINE 14\n         QITEM 0+00,'JCTUSER4',2+10,HEX,JCTUSER4,4\n         QITEM 2+20,'JCTUSER5',4+30,HEX,JCTUSER5,4\n         QITEM 4+40,'JCTUSER6',6+50,HEX,JCTUSER6,4\n         QITEM 6+60,'JCTUSER7',8+70,HEX,JCTUSER7,4\n         MVI   QDATRNUM+1,2*4           NUMBER OF ATTR BYTES IN LINE\n         BAL   R14,QADDLINE             DISPLAY LINE\n         SPACE 2\n*---  HEX LINE 15\n         QITEM 0+00,'JCTUSER8',2+10,HEX,JCTUSER8,4\n         QITEM 2+20,'JCTUSER9',4+30,HEX,JCTUSER9,4\n         QITEM 4+40,'JCTUSERA',6+50,HEX,JCTUSERA,4\n         QITEM 6+60,'JCTUSERB',8+70,HEX,JCTUSERB,4\n         MVI   QDATRNUM+1,2*4           NUMBER OF ATTR BYTES IN LINE\n         BAL   R14,QADDLINE             DISPLAY LINE\n         SPACE 2\n*---  HEX LINE 16\n         QITEM 0+00,'JCTUSERC',2+10,HEX,JCTUSERC,4\n         QITEM 2+20,'JCTUSERD',4+30,HEX,JCTUSERD,4\n         QITEM 4+40,'JCTUSERE',6+50,HEX,JCTUSERE,4\n         QITEM 6+60,'JCTUSERF',8+70,HEX,JCTUSERF,4\n         MVI   QDATRNUM+1,2*4           NUMBER OF ATTR BYTES IN LINE\n         BAL   R14,QADDLINE             DISPLAY LINE\n         SPACE 2\n.JI440    ANOP\n*---  HEX LINE 17\n         QITEM 0+00,'JCTWORK',2+10,HEX,JCTWORK+00,4\n         QITEM              ,,2+20,HEX,JCTWORK+04,4\n         QITEM              ,,2+30,HEX,JCTWORK+08,4\n         QITEM              ,,2+40,HEX,JCTWORK+12,4\n         QITEM              ,,2+50,HEX,JCTWORK+16,4\n         QITEM              ,,2+60,HEX,JCTWORK+20,4\n         QITEM              ,,2+70,HEX,JCTWORK+24,4\n         MVI   QDATRNUM+1,2*1           NUMBER OF ATTR BYTES IN LINE\n         BAL   R14,QADDLINE             DISPLAY LINE\n         SPACE 2\n*---  HEX LINE 18\n         QITEM              ,,00,HEX,JCTWORK+28,4\n         QITEM              ,,10,HEX,JCTWORK+32,4\n         QITEM              ,,20,HEX,JCTWORK+36,4\n         QITEM              ,,30,HEX,JCTWORK+40,4\n         QITEM              ,,40,HEX,JCTWORK+44,4\n         QITEM              ,,50,HEX,JCTWORK+48,4\n         QITEM              ,,60,HEX,JCTWORK+52,4\n         QITEM              ,,70,HEX,JCTWORK+56,4\n         BAL   R14,QADDLINE             DISPLAY LINE\n         SPACE 2\n          AIF   (&QLEVEL LT 4).JI460\n*---  HEX LINE 19\n         QITEM 0+00,'JCTXMASK',2+10,HEX,JCTXMASK+00,4\n         QITEM               ,,2+20,HEX,JCTXMASK+04,4\n         QITEM               ,,2+30,HEX,JCTXMASK+08,4\n         QITEM               ,,2+40,HEX,JCTXMASK+12,4\n         QITEM               ,,2+50,HEX,JCTXMASK+16,4\n         QITEM               ,,2+60,HEX,JCTXMASK+20,4\n         QITEM               ,,2+70,HEX,JCTXMASK+24,4\n         MVI   QDATRNUM+1,2*1           NUMBER OF ATTR BYTES IN LINE\n         BAL   R14,QADDLINE             DISPLAY LINE\n         SPACE 2\n*---  HEX LINE 20\n         QITEM               ,,0+20,HEX,JCTXMASK+28,4\n         BAL   R14,QADDLINE             DISPLAY LINE\n         SPACE 2\n*---  HEX LINE 21\n         QITEM 0+00,'JCTXWRK',2+10,HEX,JCTXWRK+00,4\n         QITEM              ,,2+20,HEX,JCTXWRK+04,4\n         QITEM              ,,2+30,HEX,JCTXWRK+08,4\n         QITEM              ,,2+40,HEX,JCTXWRK+12,4\n         QITEM              ,,2+50,HEX,JCTXWRK+16,4\n         QITEM              ,,2+60,HEX,JCTXWRK+20,4\n         QITEM              ,,2+70,HEX,JCTXWRK+24,4\n         MVI   QDATRNUM+1,2*1           NUMBER OF ATTR BYTES IN LINE\n         BAL   R14,QADDLINE             DISPLAY LINE\n         SPACE 2\n*---  HEX LINE 22\n         QITEM              ,,00,HEX,JCTXWRK+28,4\n         QITEM              ,,10,HEX,JCTXWRK+32,4\n         QITEM              ,,20,HEX,JCTXWRK+36,4\n         QITEM              ,,30,HEX,JCTXWRK+40,4\n         QITEM              ,,40,HEX,JCTXWRK+44,4\n         QITEM              ,,50,HEX,JCTXWRK+48,4\n         QITEM              ,,60,HEX,JCTXWRK+52,4\n         QITEM              ,,70,HEX,JCTXWRK+56,4\n         BAL   R14,QADDLINE             DISPLAY LINE\n.JI460    ANOP\n         SPACE 2\n         B     QSTOP                    ALL DONE HERE\n         SPACE 2\n         DROPX R8,R9                    JQEDSECT, JCTSTART\n         SPACE 3\n*---  SUBROUTINE TO FORMAT AN RJE ID\nJI$RJE   MVC   JI@LINE+2+64(4+5),JI#ROUTE  'ROUTE'\n         QCALL FINDRJE                  CONVERT TO RJE ID\n         MVC   JI@LINE+4+72(8),0(R1)    MOVE RJE ID TO DISPLAY LINE\n         CLC   JI@LINE+4+72(8),QBLANK   BLANK? (LOCAL)\n         BNER  R2                       NO - RETURN TO CALLER\n         MVC   JI@LINE+4+72(7),=C'(LOCAL)' YES - SAY SO\n         BR    R2                       RETURN TO CALLER\n         SPACE 2\n         DROPX R10,R13                  JOBINFO+4096, WORK\n         SPACE 2\n         LTORG\nJI#MASK  DC    X'402020',C',',X'202020',C',',X'202020',C',',X'202120'\nJI#MASKL EQU   *-JI#MASK\n         SPACE 1\nJI#INPUT DC    X'1DE8'                  OUTPUT, BRIGHT\n         DC    C'Input Route'\n         DC    X'1D60'                  OUTPUT, NORMAL\n         SPACE 1\nJI#ROUTE DC    X'1DE8'                  OUTPUT, BRIGHT\n         DC    C'Route'\n         DC    X'1D60'                  OUTPUT, NORMAL\n         SPACE 1\n          AIF   (&@@ACF2 EQ 0).JI500\n          AIF   (&QLEVEL GT 3).JI480\nJI#ACFUI DC    X'1DE8',C'ACF2 UID',X'1D60'\nJI#ACFNA DC    X'1DE8',C'(NO ACF2 CVT AVAILABLE)',X'1D60'\nJI#ACFNL EQU   *-JI#ACFNA\n         SPACE 1\nJI#ACF0  DC    X'1DE8',C'*** ACF2 INFORMATION UNAVAILABLE (JCTACFJ \u00ac= '$\n               'ACFJ'' ***',X'1D60'\nJI#ACF0L EQU   *-JI#ACF0\n          AGO   .JI500\n.JI480    ANOP\nJI#ACF0  DC    X'1DE8',C'*** ACF2 INFORMATION UNAVAILABLE (NO ACF2 USER$\n                SECTION IN NJH IN JCT) ***',X'1D60'\nJI#ACF0L EQU   *-JI#ACF0\n         SPACE 1\nJI#ANST  DC    X'1DE8',C'*** NO ACF2 READER SUBTASK ACTIVE WHEN JOB WAS$\n                INPUT ***',X'1D60'\nJI#ANSTL EQU   *-JI#ANST\n         SPACE 1\nJI#ASTF  DC    X'1DE8',C'*** ACF2 SUBTASK FAILURE PROCESSING JOB ***',X$\n               '1D60'\nJI#ASTFL EQU   *-JI#ASTF\n         SPACE 1\nJI#ACFID DC    B'11100000',B'00000001',C'ACF2'  TYPE, MOD, ID\n.JI500    ANOP\n         SPACE 1\nJI#SYSAF DC    X'1DE8'                  OUTPUT, BRIGHT\n         DC    C'Sys Affinity'\n         DC    X'1D60'                  OUTPUT, NORMAL\n         SPACE 1\nJI#ON    DC    X'1DE8'                  OUTPUT, BRIGHT\n         DC    C'On'\n         DC    X'1D60'                  OUTPUT, NORMAL\n         SPACE 1\n         QITEM GEN                      GEN ALL THE OTHER \"LITERALS\"\n         SPACE 3\nWORK     DSECT\n         ORG   WORK+72                  SKIP PAST SAVE AREA\nJI@DWD   DS    D\nJI@WORK  DS    2CL(JI#MASKL)\nJI@WORKL EQU   *-WORK\n         SPACE 3\n         QCOMMON\n         ORG   QDMSG\nJI@LINE  DS    CL(L'QDMSG)\n         SPACE 3\n*  JCT FIELDS CURRENTLY NOT DISPLAYED:\n*\n*  PASS (SECURE)  NUPAS (SECURE)\n*  PSN1 (BLANK)   PSN2  (BLANK)\n*\n*  JCTXEQND - INITIAL XEQ NODE\n*  JCTNJSID THRU JCTNLNDE\n*  NJH & NJT FIELDS (DONE:  NJHGUSID)\n*\n*  SP133:  JCTESTPG, JCTESTBY, JCTPAGES, JCTBYTES\n*\n         SPACE 3\n         Q$JCT\n         Q$NHD\n         Q$NHSB                                                 29SEP91\n         Q$JQE\n         QZACCVT\n         QZACFJCB\n         QZACFNJB  ,                    GEN ACFJNBLK\n         QZACVALD\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "Q#JN": {"ttr": 11529, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x05\\x00\\x00\\x00\\x82#/\\x00\\x87\\x12\\x8f\\x18G\\x00;\\x00\\x1c\\x00!\\xc5\\xd4\\xe2@@@@@@@'", "ispf": {"version": "05.05", "flags": 0, "createdate": "1982-08-20T00:00:00", "modifydate": "1987-05-08T18:47:00", "lines": 59, "newlines": 28, "modlines": 33, "user": "EMS"}, "text": "         TITLE '--- QUEUE--JESNEWS -- DISPLAY JESNEWS ---'\n*---------------------------------------------------------------------*\n*                                                                     *\n*   JESNEWS - DISPLAY THE CURRENT JESNEWS                             *\n*                                                                     *\n*   Updates:                                                          *\n*       8May87  EMS  Update for 1.3.4 level                           *\n*      25Jan87  LDW  Pass READSPC JQE addr = 0 in case of CB ID error *\n*      04/10/84 LDW  TEMPORARILY DISABLE FOR SP133                    *\n*      01/19/84 LDW  ADD SUPPORT FOR COMMAND STACKING                 *\n*                    FIX BUG IN HEADER LINE                           *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 3\nJESNEWS  QSTART  Q82,STACK=X'10'\n          AIF   (&QLEVEL LT 5).JN01\n          AIF   (&QLEVEL GE 6).JN02\n         QTILT '*** JESNEWS SUBCOMMAND NOT YET AVAILABLE FOR THIS VERSI$\n               ON OF JES2 ***'\n*  $NEWSTTR???\n          AGO   .JN04\n.JN01     ANOP\n         QCALL CKPT                     READ CHECKPOINT DATA\n         L     R2,QCJQTL                -> IOAREA FOR CKPT HDR RECORD\n         USING $SAVEBEG,R2\n         OC    $NEWSIOT,$NEWSIOT        ANY JESNEWS?\n         BZ    JN$OOPS                  NO - SAY SORRY\n         XC    QPOFFSET,QPOFFSET        CLEAR DISPLAY OFFSET\n         MVI   QCODE,0                  TELL LISTDS \"INITIAL POSIT'ING\"\n         L     R3,QCIOTA                -> IOT AREA\n         MVC   QCTRAK,$NEWSIOT          SET MTTR TO READ\n         DROP  R2\n         LR    R1,R3                    GET IOT AREA ADDR FOR READSPC\n         MVC   QCCBID,=C'IOT '          SAY WHAT WE WANT\n         SR    R0,R0                    NO JQE ADDR   %%%%%%\n         QCALL READSPC                  READ THE JESNEWS IOT\n         MVC   QJOBNAME,=C'$JESNEWS'    fake for listds\n         AGO   .JN03\n.JN02     ANOP ,\n         MVC   QPARM1,=C'$JESNEWS'      set jobname\n         MVC   QLNG1,=H'8'              len of jobname\n         QCALL FINDJOB                  find it\n.JN03     ANOP ,\n         MVC   QPJOBID(6),=C'$$NEWS'    ** FUDGE **\n         MVC   QDHJOBID(L'QDHJOBID+1),=C'JESNEWS -----------' SET JOBID\n         MVC   QDHDSID,QBLANK           KILL DSID\n         QCALL LISTDS                   DISPLAY IT\n         B     QSTOP                    LEAVE\n         SPACE 1\nJN$OOPS  QTILT '*** NO JESNEWS AVAILABLE ***'\n         SPACE 2\n.JN04     ANOP ,\n         LTORG ,\n         SPACE 3\n         QCOMMON\n         SPACE 2\n          AIF   (&QLEVEL GE 5).JN05\n         Q$HCT\n.JN05     ANOP ,\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "Q#JS": {"ttr": 11531, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x13\\x00\\x00\\x00\\x853\\x1f\\x00\\x905\\x1f\\x01E\\x01\\xc3\\x00\\xe6\\x01Q\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.19", "flags": 0, "createdate": "1985-11-27T00:00:00", "modifydate": "1990-12-17T01:45:00", "lines": 451, "newlines": 230, "modlines": 337, "user": "LDW"}, "text": "         TITLE '--- QUEUE--JOBSUMM -- SUMMARIZE JOB RUN RESULTS ---'\n*---------------------------------------------------------------------*\n*                                                                     *\n*   JOBSUMM - Summarize job run results by reading job messages and   *\n*             displaying selective information                        *\n*                                                                     *\n*   Updates:                                                          *\n*      17Dec90  LDW  Get I/O counts from Komand accounting boxes      *\n*      25Dec89  LDW  Q$KEYS -> QZKEYS, Q$TEXT -> QZTEXT               *\n*      26Apr89  LDW  Remove unneeded Q$JCT, Q$IOT                     *\n*      26Apr89  EMS  Update for SP311                                 *\n*      06Jan88  LDW  Fix for job starting one year, ending next year  *\n*       8Jul87  EMS  Update for GETREC, GETPDDB                       *\n*      21May87  EMS  Update for GETREC enhancements                   *\n*      21Mar87  LDW  Fix for DSID = 0 (from RSCS)                     *\n*      25Jan87  LDW  Pass READSPC the JQE addr in case of CB ID error *\n*      20Jan87  LDW  Fix for blank stepname                           *\n*                    Change lots of character constants to lower case *\n*      03Jan87  LDW  Fix problem of splitting summary lines when an   *\n*                       exceptional message is displayed              *\n*                    Don't use LC macro                               *\n*      27AUG86  LDW  SET QDHDSID (J.I.C.)                             *\n*      11JUL86  LDW  FIX BUG IN NON-HACSCG HEADER LINE                *\n*      04/20/86 LDW  DISPLAY SRB TIME CORRECTLY                       *\n*      04/08/86 LDW  DISPLAY ALL 'IEF' MESSAGES EXCEPT THOSE THAT     *\n*                       ARE KNOWN TO BE UN-INTERESTING                *\n*      04/07/86 LDW  FINISH WRITING FULL-BLOWN VERSION OF THIS CMD    *\n*      03/31/86 LDW  RE-DESIGN 3278-5 SUPPORT (THIRD TRY!)            *\n*      12/02/85 LDW  NEW ROUTINE                                      *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 3\nJOBSUMM  QSTART  WORKLEN=JS@WORKL,STACK=X'40'\n         USNGX WORK,R13                 LOCAL WORK AREA\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*   CALL FINDJOB TO LOCATE THE JQE, JCT, AND IOT                      *\n*                                                                     *\n***********************************************************************\n         QCALL FINDJOB                  FIND THE JOB\n         OI    QSCFLAG1,QSC1JOB         PUT JOBID IN QDTOP\n         QCALL DISP80                   SWITCH TO 3278-2 MODE IF 3278-5\n***********************************************************************\n*                                                                     *\n*   LOCATE PDDB NUMBER 4                                              *\n*                                                                     *\n***********************************************************************\n          AIF  (&QLEVEL GE 9).JS01\n         MVC   QPDSID,=H'4'             set requested dsid\n          AGO  .JS02\n.JS01     ANOP ,\n         MVC   QPDSID,=F'4'             set requested dsid\n.JS02     ANOP ,\n         MVI   QGPFLAG,QPFDIR+QPFNMSG   specific request\n         QCALL GETPDDB                  get pddb\n         LTR   R2,R1                    copy pddb addr\n         BP    JS$FOUND                 and use it\n         USNGX PDBDSECT,R2\n         QTILT '*** JOB DOES NOT HAVE JOB MESSAGES DATASET ***'\n         SPACE 2\nJS$FOUND MVI   QCRFLAG,QRFINIT          req init processing\n         MVC   QCGRMTTR,PDBMTTR         set starting mttr\n*JS$FOUND L     R1,QCSTART               BEGINNING OF DISK ADDR TABLE\n*        MVC   0(4,R1),PDBMTTR          SET STARTING DISK ADDR OF DS\n         MVC   QDHDSID,=CL8'JOBMSG'     SET DISPLAYABLE DSID (J.I.C.)\n*        SR    R4,R4                    TELL GETREC TO START AT TOP\n         MVC   QDHLINE,JS#HDR1          MOVE IN HEADING\n         MVC   JS@LINE,QBLANK           CLEAR THE OUTPUT LINE\n         DROPX R2                       PDDB\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*   READ JOB MESSAGES DATASET, EXTRACT AND DISPLAY INTERESTING STUFF  *\n*                                                                     *\n***********************************************************************\nJS$NXT   QCALL GETREC                   GET THE NEXT RECORD\n*  MUST NOT MODIFY R4,R5,R6 BETWEEN CALLS TO \"GETREC\"\n         LTR   R4,R4                    HAVE WE HIT BOTTOM?\n         BZ    QSTOP                    YES - ALL DONE\n         USNGX LRCDSECT,R4              R4 SET BY \"GETREC\"\n         TM    LRCFLAG1,LRC1SPAN        IS THIS A SPANNED RECORD?\n         BO    JS$NXT                   YES - CAN'T HANDLE THESE YET\n         LA    R2,LRCTEXT               -> START OF TEXT\n         LR    R3,R6                    COPY LENGTH\n         TM    LRCFLAG1,LRC1CCTL        IS CARRIAGE CONTROL SPECIFIED?\n         BNO   JS$GO                    NO - OK\n         LA    R2,1(,R2)                YES - SKIP OVER IT\n         BCTR  R3,0                     DECREMENT LENGTH\n         SPACE 2\nJS$GO    LA    R1,JS#TABLE              -> MESSAGE ID TABLE\n         SPACE 1\nJS$MSGLP CLC   0(7,R2),2(R1)            IS THIS AN INTERESTING MESSAGE?\n         BE    JS$LOOK                  YES - LOOK AT IT\n*---  MESSAGES FROM THE CONVERTER HAVE THE JCL STMT NUMBER IN FRONT---*\n         CLC   10(7,R2),2(R1)           IS THIS AN INTERESTING MESSAGE?\n         BE    JS$LOOK                  YES - LOOK AT IT\n          AIF   ('&@@ID' NE 'USC-UCS').JS03\n         CLC   3(12,R2),=C'EXCP TOTALS:'  Komand summary line?\n         BE    JS$KIO                   Yes - save I/O counts\n.JS03     ANOP\n         LA    R1,JS#TBLL(,R1)          -> NEXT TABLE ENTRY\n         CLI   0(R1),X'FF'              END OF TABLE?\n         BNE   JS$MSGLP                 NO - KEEP LOOKING\n         CLC   =C'IEF',0(R2)            OTHER JOB SCHEDULER MESSAGE?\n         BE    JS$CPY                   YES - DISPLAY IT\n         CLC   =C'IEF',10(R2)           OTHER CONVERTER MESSAGE?\n         BE    JS$CPY                   YES - DISPLAY IT\n         B     JS$NXT                   YES - NOT INTERESTING - IGNORE\n         DROPX R4                       LRCDSECT\n***********************************************************************\n*                                                                     *\n*   PROCESS AN INTERESTING RECORD                                     *\n*                                                                     *\n***********************************************************************\nJS$LOOK  LH    R15,0(,R1)               GET PROCESSING ROUTINE OFFSET\n         B     0(R12,R15)               GO TO IT\n         SPACE 2\n*  IEF201I JJJ SSS - JOB TERMINATED BECAUSE OF CONDITION CODES\n*  IEF212I JJJ SSS DDD - DATA SET NOT FOUND\n*  IEF253I JJJ SSS DDD - DUPLICATE NAME ON DIRECT ACCESS VOLUME\n*  IEF287I DSNAME DISP / VOL SER NOS =  ** ERROR DISP **\n*  IEF606I MISPLACED DD STATEMENT\n*  HAC220I (HAC JOB COST)\n*JS$CPY  CLC   JS@LINE,QBLANK           ANY PARTIAL LINE?\n*        BE    *+8                      NO - SKIP\n*        BAL   R8,JS$BUILD              YES - FIX IT UP AND PUT IT OUT\nJS$CPY   MVC   QDMSG(2),=X'1DE8'        SET OUTPUT, BRIGHT\n         MVC   QDMSG+2(5),=C'Msg->'     FLAG IT\n         MVC   QDMSG+7(2),=X'1D60'      SET OUTPUT, NORMAL\n         CH    R3,=H'73'                MESSAGE LINE TOO LONG?\n         BNH   *+8                      NO - USE LENGTH\n         LA    R3,73                    YES - USE MAX\n         BCTR  R3,0                     -1 FOR EX\n         EX    R3,JS$MVC                MVC QDMSG+7(*-*),0(R2)\n         MVI   QDATRNUM+1,2             SET # OF ATTR BYTES IN LINE\n         BAL   R14,QADDLINE             ADD THIS LINE TO SCREEN\n         B     JS$NXT                   PROCESS NEXT INPUT RECORD\nJS$MVC   MVC   QDMSG+9(*-*),0(R2)       << EXECUTED >>\n         SPACE 2\n***********************************************************************\n*   BUILD THE STANDARD OUTPUT LINE                                    *\n***********************************************************************\nJS$BUILD MVC   JS@ATTR1,=X'1DE8'        SET OUTPUT, BRIGHT\n         CLC   =C'0000',JS@CODE         RETURN CODE 0?\n         BNE   JS$NZERO                 NO - OK\n         MVI   JS@ATTR1+1,X'60'         YES - SET OUTPUT, NORMAL\n         MVC   JS@CODE,=C'zero'         AND MAKE IT SPECIAL\nJS$NZERO MVC   JS@ATTR2,=X'1D60'        SET OUTPUT, NORMAL\n         MVI   QDATRNUM+1,2             SET # OF ATTR BYTES IN LINE\n*---  PUT PREVIOUSLY BUILT OUTPUT LINE TO SCREEN                   ---*\n         MVC   QDMSG(JS@LINEL),JS@LINE  COPY TO LINE BUFFER AREA\n         BAL   R14,QADDLINE             ADD THIS LINE TO SCREEN\n         MVC   JS@LINE,QBLANK           CLEAR WORK LINE BUFFER\n         BR    R8                       RETURN TO CALLER\n         SPACE 3\n***********************************************************************\n*                                                                     *\n*   PROCESSING ROUTINES                                               *\n*                                                                     *\n***********************************************************************\n*  IEF142I JJJ SSS - STEP WAS EXECUTED - COND CODE NNNN\nJS$142   BAL   R8,JS$GNAME              GET STEPNAMES\nJS$142$L LA    R2,1(,R2)                -> BUMP INPUT PTR\n         CLC   =C'COND CODE',0(R2)      IS THIS IT?\n         BE    JS$142$S                 YES - SAVE IT\n         BCT   R3,JS$142$L              NO - KEEP LOOKING\n         B     JS$NXT                   %%%%%%%%%% LOGIC ERROR\nJS$142$S MVC   JS@CODE,10(R2)           SAVE CONDITION CODE\n         B     JS$NXT                   GO READ NEXT INPUT RECORD\n         SPACE 1\n*  IEF202I JJJ SSS - STEP WAS NOT RUN BECAUSE OF CONDITION CODES\nJS$202   MVC   JS@DAYS+2(49),=C'<< Step was not run because of conditio$\n               n codes >>'\n         B     JS$NXT                   GO READ NEXT INPUT RECORD\n         SPACE 1\n*  IEF272I JJJ SSS - STEP WAS NOT EXECUTED\nJS$272   BAL   R8,JS$GNAME              GET STEPNAMES\n         MVC   JS@CODE(5),=C'flush'     INDICATE STEP NOT EXECUTED\n         B     JS$NXT                   GO READ NEXT INPUT RECORD\n         SPACE 1\n*  IEF373I STEP START\n*%JS$373 PACK  JS@SDATE,30(5,R2)        SAVE STEP START DATE\nJS$373   PACK  JS@SYEAR,30(3,R2)        SAVE STEP START DATE (yyxx)\n         PACK  JS@SDATE,32(3,R2)        SAVE STEP START DATE (ddd)\n         PACK  JS@SHOUR,36(2,R2)        SAVE STEP START TIME (HH)\n         PACK  JS@SMINS,38(2,R2)        SAVE STEP START TIME (MM)\n         B     JS$NXT                   GO READ NEXT INPUT RECORD\n         SPACE 1\n*  IEF374I STEP STOP\n*  IEF376I JOB  STOP\nJS$374   CLC   JS@DAYS,QBLANK           ANY MESSAGE HERE ALREADY?\n         BNE   JS$HAVE                  YES - DON'T OVERLAY IT\n*%       PACK  JS@EDATE,30(5,R2)        SAVE STEP END DATE\n         PACK  JS@EDATE,32(3,R2)        SAVE STEP END DATE (ddd)\n         PACK  JS@EHOUR,36(2,R2)        SAVE STEP END TIME (HH)\n         PACK  JS@EMINS,38(2,R2)        SAVE STEP END TIME (MM)\n         SP    JS@EDATE,JS@SDATE        COMPUTE ELAPSED DAYS\n         BNM   JS$374$0                 skip if ok\n         AP    JS@EDATE,=P'365'         normalize 'ddd'\n         TM    JS@SYEAR,X'01'           leap year?\n         BO    JS$374$0                 no (odd year) - not leap\n         TM    JS@SYEAR,X'12'           divisible by 4?\n         BM    JS$374$0                 no - not leap year\n         AP    JS@SDATE,=P'1'           yes - account for leap year\n         SPACE 1\nJS$374$0 SP    JS@EMINS,JS@SMINS        COMPUTE ELAPSED TIME (MM)\n         BNM   JS$374$1                 SKIP IF OK\n         AP    JS@EMINS,=P'60'          NORMALIZE 'MM'\n         SP    JS@EHOUR,=P'1'           AND ADJUST NUMBER OF HOURS\n         SPACE 1\nJS$374$1 SP    JS@EHOUR,JS@SHOUR        COMPUTE ELAPSED TIME (HH)\n         BNM   JS$374$2                 SKIP IF OK\n         AP    JS@EHOUR,=P'24'          NORMALIZE 'HH'\n         SP    JS@EDATE,=P'1'           AND ADJUST NUMBER OF DAYS\n         SPACE 1\nJS$374$2 CP    JS@EDATE,=P'0'           > 24 HOURS?\n         BE    JS$374$3                 NO - SKIP DAYS DISPLAY\n         UNPK  JS@DAYS(2),JS@EDATE      SHOW NUMBER OF DAYS\n         OI    JS@DAYS+1,C'0'           FIX FLIP BYTE\n         CLI   JS@DAYS,C'0'             CHEAPO EDIT\n         BNE   *+8                      ...\n         MVI   JS@DAYS,C' '             ... SUPPRESS LEADING BLANK\n         MVC   JS@DAYS+3(4),=C'Days'    SHOW WHAT IT IS\n         SPACE 1\nJS$374$3 UNPK  JS@HOURS(2),JS@EHOUR     SHOW HH\n         OI    JS@HOURS+1,C'0'          FIX FLIP BYTE\n         MVI   JS@HOURS+2,C':'          PUT IN THE SEPARATOR\n         UNPK  JS@HOURS+3(2),JS@EMINS   SHOW MM\n         OI    JS@HOURS+4,C'0'          FIX FLIP BYTE\n         SPACE 1\n*---  TCB CPU TIME                                                 ---*\n         MVC   JS@TEMP(4),45(R2)        FILL IN MINUTES\n         MVI   JS@TEMP+4,C':'           SEPARATOR\n         MVC   JS@TEMP+5(5),53(R2)      FILL IN SECONDS\n         LA    R15,JS@TEMP+2            ASSUME < 100 MINUTES TCB TIME\n         CLC   JS@TEMP(2),QBLANK        > 99 MINUTES TCB TIME?\n         BE    *+12                     NO - KEEP FRACTIONAL SECONDS\n         LA    R15,JS@TEMP              USE COMPLETE MINUTES VALUE\n         MVI   JS@TEMP+7,C' '           AND KILL THE DOT\n         MVC   JS@TCB,0(R15)            MOVE TCB TIME TO DISPLAY LINE\n         SPACE 1\n*---  SRB CPU TIME                                                 ---*\n         MVC   JS@TEMP(4),66(R2)        FILL IN MINUTES\n         MVI   JS@TEMP+4,C':'           SEPARATOR\n         MVC   JS@TEMP+5(5),74(R2)      FILL IN SECONDS\n         LA    R15,JS@TEMP+2            ASSUME < 100 MINUTES SRB TIME\n         CLC   JS@TEMP(2),QBLANK        > 99 MINUTES SRB TIME?\n         BE    *+12                     NO - KEEP FRACTIONAL SECONDS\n         LA    R15,JS@TEMP              USE COMPLETE MINUTES VALUE\n         MVI   JS@TEMP+7,C' '           AND KILL THE DOT\n         MVC   JS@SRB,0(R15)            MOVE TCB TIME TO DISPLAY LINE\nJS$HAVE  EQU   *\n          AIF   ('&@@ID' EQ 'HAC SCG').JS04\n         BAL   R8,JS$BUILD              GO DISPLAY COMPLETED MESSAGE\n.JS04     ANOP\n         B     JS$NXT                   GO READ NEXT RECORD\n         SPACE 1\n*  IEF375I JOB START\n*%JS$375 PACK  JS@SDATE,30(5,R2)        SAVE JOB START DATE\nJS$375   PACK  JS@SYEAR,30(3,R2)        SAVE JOB START DATE (yyxx)\n         PACK  JS@SDATE,32(3,R2)        SAVE JOB START DATE (ddd)\n         PACK  JS@SHOUR,36(2,R2)        SAVE JOB START TIME (HH)\n         PACK  JS@SMINS,38(2,R2)        SAVE JOB START TIME (MM)\n         MVC   JS@STEPN(17),=C'***Job Summary***'\n         B     JS$NXT                   GO READ NEXT INPUT RECORD\n         SPACE 1\n*  IEF376I JOB STOP\nJS$376   EQU   JS$374,4,C'I'            IDENTICAL CODE!\n         SPACE 1\n*  IEF472I JJJ SSS COMPLETION CODE - SYSTEM=XXX USER=NNNN\nJS$472   BAL   R8,JS$GNAME              GET STEPNAMES\nJS$472$L LA    R2,1(,R2)                -> BUMP INPUT PTR\n         CLC   =C'SYSTEM=',0(R2)        IS THIS IT?\n         BE    JS$472$S                 YES - SAVE IT\n         BCT   R3,JS$472$L              NO - KEEP LOOKING\n         B     JS$NXT                   %%%%%%%%%% LOGIC ERROR\nJS$472$S MVI   JS@CODE,C'S'             INDICATE SYSTEM ABEND CODE\n         MVC   JS@CODE+1(3),7(R2)       SAVE ABEND CODE\n         CLC   =C'S000',JS@CODE         ANY SYSTEM ABEND CODE?\n         BNE   JS$NXT                   YES - DISPLAY AS IS\n         MVI   JS@CODE,C'U'             INDICATE USER ABEND CODE\n         MVC   JS@CODE+1(4),16(R2)      SAVE ABEND CODE\n         B     JS$NXT                   GO READ NEXT INPUT RECORD\n         SPACE 1\n          AIF   ('&@@ID' NE 'HAC SCG').JS05\n*  HAC110I HAC STEP END\nJS$110   CLC   JS@DISK,QBLANK           ANY MESSAGE HERE ALREADY?\n         BNE   JS$110$S                 YES - DON'T OVERLAY IT\n         LA    R2,39(,R2)               -> BEFORE DISK I/O FIELD\n         SH    R3,=H'39'                ADJUST REMAINING LENGTH\n         BAL   R14,JS$GWORD             GET DISK I/O COUNT\n         BAL   R14,JS$RIGHT             RIGHT JUSTIFY IT\n         MVC   JS@DISK,JS@WORD          MOVE INTO MESSAGE\n         LA    R2,4(,R2)                SKIP OVER 'TAPE'\n         SH    R3,=H'4'                 ADJUST REMAINING LENGTH\n         BAL   R14,JS$GWORD             GET TAPE I/O COUNT\n         BAL   R14,JS$RIGHT             RIGHT JUSTIFY IT\n         MVC   JS@TAPE,JS@WORD          MOVE INTO MESSAGE\nJS$110$S BAL   R8,JS$BUILD              GO DISPLAY COMPLETED MESSAGE\n         B     JS$NXT                   GO READ NEXT RECORD\n         SPACE 1\n*  HAC210I HAC JOB END\nJS$210   EQU   JS$110,4,C'I'            IDENTICAL CODE!\n         SPACE 1\n.JS05     ANOP\n         SPACE 1\n          AIF   ('&@@ID' NE 'USC-UCS').JS06\n*  Komand step and job summary boxes (summary line is same in both)\nJS$KIO   CLC   JS@DISK,QBLANK           ANY MESSAGE HERE ALREADY?\n         BNE   JS$NXT                   YES - DON'T OVERLAY IT\n         MVC   JS@DISK,33(R2)           MOVE INTO MESSAGE\n         MVC   JS@TAPE,63(R2)           MOVE INTO MESSAGE\n         B     JS$NXT                   GO READ NEXT RECORD\n         SPACE 1\n.JS06     ANOP\n         SPACE 2\n***********************************************************************\n*   SUBROUTINE TO GET STEPNAME AND PROCSTEP                           *\n***********************************************************************\nJS$GNAME LA    R2,7(,R2)                -> PAST MSGID\n         SH    R3,=H'7'                 ADJUST REMAINING LENGTH\n         BAL   R14,JS$GWORD             GET JOBNAME\n         MVC   JS@STEPN,QBLANK          CLEAR FIELD IN CASE NO STEPNAME\n         MVC   JS@PROCS,QBLANK          CLEAR FIELD IN CASE NO STEPNAME\n         CLI   1(R2),C'-'               ANY STEPNAME?\n         BER   R8                       NO - RETURN\n         BAL   R14,JS$GWORD             GET STEPNAME\n         MVC   JS@STEPN,JS@WORD         STEPNAME TO MSG\n         CLI   1(R2),C'-'               ANY PROCSTEP?\n         BER   R8                       NO - RETURN\n         BAL   R14,JS$GWORD             GET PROCSTEP\n         MVC   JS@PROCS,JS@WORD         PROCSTEP TO MSG\n         BR    R8                       RETURN TO CALLER\n         SPACE 2\n***********************************************************************\n*   SUBROUTINE TO SCAN FOR NEXT WORD                                  *\n***********************************************************************\nJS$GWORD MVC   JS@WORD,QBLANK           CLEAR OUTPUT AREA\n         LA    R1,JS@WORD               -> START OF OUTPUT AREA\n         LA    R0,8                     MAX LENGTH\n*  AT ENTRY, R2 -> BLANK IN FRONT OF THE WORD\n         LA    R2,1(,R2)                -> START OF WORD\n         BCT   R3,JS$GW$LP              DECR REMAINING LENGTH\n         BR    R14                      RETURN TO CALLER IF NO MORE\n         SPACE 1\nJS$GW$LP MVC   0(1,R1),0(R2)            MOVE 1 CHAR\n         LA    R1,1(,R1)                BUMP OUTPUT PTR\n         LA    R2,1(,R2)                -> NEXT CHAR OF WORD\n         BCT   R3,*+6   >======+        DECR REMAINING LENGTH\n         BR    R14             |        RETURN TO CALLER IF NO MORE\n         CLI   0(R2),C' '  <===+        END OF WORD?\n         BER   R14                      YES - RETURN TO CALLER\n         BCT   R0,JS$GW$LP              SAVE UP TO 8 CHARS\n         L     R0,=C'JS1 '              SET LOGIC ERROR CODE\n         L     R15,=V(LOGICERR)         -> ROUTINE\n         BALR  R14,R15                  GO TO IT (NO RETURN)\n         SPACE 2\n***********************************************************************\n*   SUBROUTINE TO RIGHT ADJUST A WORD                                 *\n***********************************************************************\nJS$RIGHT CLI   JS@WORD+7,C' '           IS IT ALL THE WAY TO THE RIGHT?\n         BNER  R14                      YES - RETURN TO CALLER\n         MVC   JS@DWD,JS@WORD           SAVE THE WORD\n         MVC   JS@WORD+1(7),JS@DWD      MOVE IT BACK, ONE TO THE RIGHT\n         MVI   JS@WORD,C' '             FILL IN THE SPACE OPENED UP\n         B     JS$RIGHT                 AND TRY AGAIN\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*   MISCELLANY                                                        *\n*                                                                     *\n***********************************************************************\n         LTORG\n          AIF   ('&@@ID' EQ 'USC-UCS').JS91\n          AIF   ('&@@ID' EQ 'HAC SCG').JS91\nJS#HDR1  DC    CL79'Stepname  Procstep  Code   Elapsed time  TCB time  $\n               SRB time'\n          AGO   .JS92\n.JS91     ANOP\nJS#HDR1  DC    CL79'Stepname  Procstep  Code   Elapsed time  TCB time  $\n               SRB time  Disk I/O  Tape I/O'\n.JS92     ANOP\n         SPACE 2\nJS#TABLE DC    Y(JS$142-JOBSUMM),CL8'IEF142I'  STEP WAS EXEC - COND ...\nJS#TBLL  EQU   *-JS#TABLE\n*>       DC    Y(JS$CPY-JOBSUMM),CL8'IEF201I'  JOB TERM DUE TO CC ...\n         DC    Y(JS$202-JOBSUMM),CL8'IEF202I'  STEP NOT DUE BECAUSE CC\n*>       DC    Y(JS$CPY-JOBSUMM),CL8'IEF212I'  DATA SET NOT FOUND\n         DC    Y(JS$NXT-JOBSUMM),CL8'IEF236I'  ALLOC FOR JJJ SSS\n         DC    Y(JS$NXT-JOBSUMM),CL8'IEF237I'  UUU ALLOCATED TO DDDDD\n*>       DC    Y(JS$CPY-JOBSUMM),CL8'IEF253I'  DUPLICATE DSN ON DASD\n         DC    Y(JS$272-JOBSUMM),CL8'IEF272I'  STEP WAS NOT EXECUTED\n         DC    Y(JS$NXT-JOBSUMM),CL8'IEF285I'  DISPOSITION OF DATASET\n*>       DC    Y(JS$CPY-JOBSUMM),CL8'IEF287I'  ERROR DISP OF DATASET\n         DC    Y(JS$373-JOBSUMM),CL8'IEF373I'  STEP START\n         DC    Y(JS$374-JOBSUMM),CL8'IEF374I'  STEP STOP\n         DC    Y(JS$375-JOBSUMM),CL8'IEF375I'  JOB START\n         DC    Y(JS$376-JOBSUMM),CL8'IEF376I'  JOB STOP\n         DC    Y(JS$472-JOBSUMM),CL8'IEF472I'  COMPLETION CODE (ABEND)\n         DC    Y(JS$NXT-JOBSUMM),CL8'IEF604I'  EXPDT ZERO DAYS VALUE\n*>       DC    Y(JS$CPY-JOBSUMM),CL8'IEF606I'  MISPLACED DD STATEMENT\n         DC    Y(JS$NXT-JOBSUMM),CL8'IEF648I'  INV. DISP - PASS SUB'D\n         DC    Y(JS$NXT-JOBSUMM),CL8'IEF653I'  SUBSTITUTION JCL\n         DC    Y(JS$NXT-JOBSUMM),CL8'IEF686I'  DDNAME NOT RESOLVED\n          AIF   ('&@@ID' NE 'HAC SCG').JS93\n         DC    Y(JS$110-JOBSUMM),CL8'HAC110I'  HAC STEP END\n         DC    Y(JS$210-JOBSUMM),CL8'HAC210I'  HAC JOB  END\n         DC    Y(JS$CPY-JOBSUMM),CL8'HAC220I'  HAC JOB COST\n.JS93     ANOP\n*> INDICATES MESSAGE WILL BE COPIED BY GENERAL 'IEF' SCAN\n         DC    X'FF'                    END OF TABLE\n         SPACE 3\n         QCOMMON\n         SPACE 3\nWORK     DSECT\n         ORG   WORK+72                  SKIP OVER SAVE AREA\nJS@SYEAR DS    PL2                      START year (yy..)\nJS@SDATE DS    PL3                      START DATE (ddd)\nJS@SHOUR DS    PL2                      START TIME (HH)\nJS@SMINS DS    PL2                      START TIME (MM)\nJS@EDATE DS    PL3                      END   DATE (ddd)\nJS@EHOUR DS    PL2                      END   TIME (HH)\nJS@EMINS DS    PL2                      END   TIME (MM)\nJS@LINE  DS    CL(79+2)\n         ORG   JS@LINE\nJS@STEPN DS    CL8,CL2\nJS@PROCS DS    CL8,CL1\nJS@ATTR1 DS    XL2\nJS@CODE  DS    CL4,CL1\nJS@ATTR2 DS    XL2\nJS@DAYS  DS    CL7,CL1\nJS@HOURS DS    CL5,CL2\nJS@TCB   DS    CL8,CL2\nJS@SRB   DS    CL8,CL2\nJS@DISK  DS    CL8,CL2\nJS@TAPE  DS    CL8\n         ORG   JS@LINE+L'JS@LINE\nJS@LINEL EQU   *-JS@LINE\n         SPACE 1\nJS@WORKL EQU   *-WORK\nJS@DWD   DS    D\nJS@WORD  DS    CL8\nJS@TEMP  DS    CL10\n         SPACE 3\n         DROPX R13                      WORK\n         SPACE 3\n         Q$PDDB\n         Q$LRC\n         QZKEYS\n         QZTEXT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "Q#KL": {"ttr": 11784, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x90\\x00\\x7f\\x00\\x90\\x00\\x9f!W\\x00\\x98\\x00\\x8d\\x00\\x0b\\xc5\\xd4\\xe2@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1990-01-07T00:00:00", "modifydate": "1990-01-09T21:57:00", "lines": 152, "newlines": 141, "modlines": 11, "user": "EMS"}, "text": "         TITLE '--- QUEUE--LISTKIT -- LIST ALL KIT CONTROL BLOCKS ---'\n*---------------------------------------------------------------------*\n*                                                                     *\n*   LISTKIT - Display information from all KITs                       *\n*                                                                     *\n*   Note - This subcommand is restricted to privileged users          *\n*                                                                     *\n*   Updates:                                                          *\n*      09Jan90  EMS  Updated for pre 311 JES2                         *\n*      07Jan90  LDW  Written                                          *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 3\nLISTKIT  QSTART  STACK=X'30'\n         QCALL CKPT                     read checkpoint data\n         QCALL DISP80                   switch to 3278-2 mode if 3278-5\n          AIF   (&QLEVEL GE 7).KL01\n         QTILT '*** LISTKIT not implemented for this level of JES2 ***'\n          AGO   .KL99\n.KL01     ANOP\n          AIF  (&QLEVEL LT 9).KL02\n         MVC   QDHLINE(78),=C'Id   Origin Ent1   Ctlb Ksiz   Klng R_n #$\n               Elems F1 C# Vr | HDPsiz Vr CBln CBnum'\n          AGO  .KL03\n.KL02     ANOP ,\n         MVC   QDHLINE(67),=C'Id   Origin Ent1   Ctlb Ksiz   Klng R_n #$\n               Elems F1 C# Vr | HDPsiz Vr'\n.KL03     ANOP\n         L     R9,QCJQTL                -> master ckpt record\n         USNGX $SAVEBEG,R9\n*%%% should add fields in QCOMMON and change INITIAL to use them\n*%%% instead of II@KITF and II@KITL.  Well, for now, just duplicate\n*%%% the code\n         LA    R3,$SAVEBEG+$SAVELEN     -> first QSE\n         LA    R0,QSELEN                length of a QSE\n*%%%     MH    R0,$QSENO                total for all systems\n         MH    R0,$QSEMAX               number of QSEs\n         AR    R3,R0                    -> JQE extension area\n         AH    R3,$MAXEXSZ              -> first KIT\n*%%% why doesn't INITIAL have the following 3 instructions???\n         LA    R0,DASEXLEN              DAS extension length\n         MH    R0,$SPOLNUM              length of all DAS extensions\n         AR    R3,R0                    -> KIT area\n         USNGX KIT,R3\n         LR    R6,R3                    save addr of first KIT for disp\n         LR    R4,R3\n         AH    R4,=Y(KITLNGTH*(8-1))    -> last kit  *kludge*?\n*%%% end of code duplicated from INITIAL\n         LR    R5,R9                    copy addr of $SAVEBEG\n         L     R14,$MASTERL             length of master record\n         LA    R14,4095(,R14)           round like INITIAL does\n         SRL   R14,12\n         SLL   R14,12\n         AR    R5,R14                   -> first change log block\n         LH    R15,$CLRECN              number of change log blks\n         SLL   R15,12                   * 4k\n         AR    R5,R15                   -> first HDP\n***********************************************************************\n*                                                                     *\n*        Loop through all KITs, displaying interesting info           *\n*                                                                     *\n***********************************************************************\nKL$LOOP  EQU   *\n         MVC   KL@ID,KITID\n         HEX   KL@ORG,KITORG+1,LEN=3,HEXTAB=QHEXTAB\n         HEX   KL@ENT1,KITENT1+1,LEN=3\n         HEX   KL@CTLB,KITCTLB+2,LEN=2\n         HEX   KL@KSIZ,KITKSIZ+1,LEN=3\n         HEX   KL@KLNG,KITKLNG+2,LEN=2\n         LH    R0,KITRECN\n         CVD   R0,QNUMWORK\n         OI    QNUMWORK+7,X'0F'         remove sign\n         MVC   KL@RECN,=X'202120'\n         ED    KL@RECN-1(L'KL@RECN+1),QNUMWORK+6\n         HEX   KL@NUMEN,KITNUMEN+1,LEN=3\n         HEX   KL@FLG1,KITFLG1,LEN=1\n         HEX   KL@CTNUM,KITCTNUM,LEN=1\n         HEX   KL@VER,KITVER,LEN=1\n         MVI   KL@BAR,C'|'\n         L     R7,KITORG                origin to pool\n         AR    R7,R5                    -> HDP for this KIT\n         USNGX HDP,R7\n         HEX   KL@SIZE,HDPSIZE+1,LEN=3\n         HEX   KL@HDPVR,HDPVRSN,LEN=1\n          AIF  (&QLEVEL LT 9).KL04\n         HEX   KL@CBLEN,HDPCBLEN,LEN=2\n         LH    R0,HDPCBNUM\n         CVD   R0,QNUMWORK\n         OI    QNUMWORK+7,X'0F'         remove sign\n         MVC   KL@CBNUM,=X'2020202120'\n         ED    KL@CBNUM-1(L'KL@CBNUM+1),QNUMWORK+5\n.KL04     ANOP ,\n         BAL   R14,QADDLINE             display the line\n         LA    R3,KITLNGTH(,R3)         -> next KIT\n         CLR   R3,R4                    past last one?\n         BNH   KL$LOOP                  no - display next\n         BAL   R14,QADDLINE             add a blank line\n*--- Show offset to first KIT\n         BAL   R14,QADDLINE             add a blank line\n         MVC   QDMSG(22),=C'Offset to first KIT = '\n         SR    R6,R9                    (first KIT) - $SAVEBEG\n         ST    R6,QNUMWORK\n         HEX   QDMSG+22,QNUMWORK,LEN=4\n         BAL   R14,QADDLINE             add line to screen\n*--- Show offset to first HDP\n         BAL   R14,QADDLINE             add a blank line\n         MVC   QDMSG(22),=C'Offset to first HDP = '\n         SR    R5,R9                    (first HDP) - $SAVEBEG\n         ST    R5,QNUMWORK\n         HEX   QDMSG+22,QNUMWORK,LEN=4\n         BAL   R14,QADDLINE             add line to screen\n         B     QSTOP                    all done\n***********************************************************************\n*                                                                     *\n*        CONSTANTS                                                    *\n*                                                                     *\n***********************************************************************\n         LTORG ,\n         SPACE 1\n         DROPX R9,R3,R7                 $SAVEBEG, $KIT, $HDP\n***********************************************************************\n*                                                                     *\n*        DESCRIBE ALL THE DSECTS NEEDED BY THIS MODULE                *\n*                                                                     *\n***********************************************************************\n         QCOMMON\n         ORG   QDMSG\nKL@ID    DS    CL4,C\nKL@ORG   DS    CL6,C\nKL@ENT1  DS    CL6,C\nKL@CTLB  DS    CL4,C\nKL@KSIZ  DS    CL6,C\nKL@KLNG  DS    CL4,C\nKL@RECN  DS    CL3,C\nKL@NUMEN DS    CL6,C\nKL@FLG1  DS    CL2,C\nKL@CTNUM DS    CL2,C\nKL@VER   DS    CL2,C\nKL@BAR   DS    C'|',C\nKL@SIZE  DS    CL6,C                    HDPSIZE\nKL@HDPVR DS    CL2,C                    HDPVRSN\n          AIF  (&QLEVEL LT 9).KL05\nKL@CBLEN DS    CL4,C                    HDPCBLEN\nKL@CBNUM DS    CL5,C                    HDPCBNUM\n.KL05     ANOP ,\n         SPACE 3\n         Q$HCT\n         Q$QSE\n         Q$DAS\n         Q$KIT\n         Q$HDP\n.KL99     ANOP\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "Q#LD": {"ttr": 11788, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x05&\\x00\\x00\\x00\\x82#/\\x00\\x91'/ 0\\x06\\x08\\x01\\xc3\\x05C\\xd3\\xc4\\xe6@@@@@@@\"", "ispf": {"version": "05.38", "flags": 0, "createdate": "1982-08-20T00:00:00", "modifydate": "1991-09-29T20:30:00", "lines": 1544, "newlines": 451, "modlines": 1347, "user": "LDW"}, "text": "         TITLE '--- QUEUE--LISTDS -- LIST A DS FROM THE SPOOL PACK ---'\n         LCLB  &LD#DBG                  %%%\n&LD#DBG  SETB  0                        %%%\n*---------------------------------------------------------------------*\n*                                                                     *\n*   LISTDS - Display selected dataset from job on spool               *\n*                                                                     *\n*   Entry - Dsid in \"QPDSID\"                                          *\n*                                                                     *\n*   Updates:                                                          *\n*      29Sep91  LDW  Yet another try to fix NS over empty datasets    *\n*                       in ISPF mode                                  *\n*      22Sep91  LDW  Change BRIF to use recfm=V/VA/VM instead of U    *\n*                    Kludge BRIF for lrecl=0                          *\n*                    Always pass CC to BRIF so user can control it    *\n*                       via DISPLAY CC/NOCC browse command            *\n*                    Add second base register (sigh)                  *\n*      29Jun91  LDW  Fix bug in handling of empty dataset under       *\n*                       ISPF V3R2                                     *\n*      26May91  LDW  Rewrite ISPF header line rebuild logic           *\n*      15Mar91  LDW  Handle subcommands for BRIF under ISPF V3R2      *\n*                       (QQ xxx is no longer required)                *\n*                    Display page and line number under BRIF          *\n*      12Mar91  LDW  Fix length allowed for VCOPY of ZPARM            *\n*      11Feb91  LDW  Move some ISPF data from QCOMMON to local area   *\n*                    Specify custom panel on BRIF invocation          *\n*                    Use local buffer instead of GETMAIN              *\n*      05Feb91  LDW  If running under ISPF 3.2, at EOF in read        *\n*                       routine, instead of rc=8, set rc=4 to         *\n*                       indicate \"temporary EOF\"                      *\n*                    Add jobid to BRIF header line                    *\n*                    Simplify logic above LD$NOCC                     *\n*      01Feb91  LDW  Since we now run all AMODE31, remove mode        *\n*                       switching in ISPF interface code GLA          *\n*                    Integrate GLA fixes below:                       *\n*     (15Jan91) GLA  Correct setting of QCLRECL under ISPF            *\n*     (21Sep90) GLA  Change access to TFD for addressability          *\n*     (02Aug90) GLA  Fix loop in LISTDS on purged job                 *\n*     (24Jan90) GLA  Fix handleing of Q cmd from BROWSE               *\n*     (15Nov89) GLA  Add support for VERB TABLE variable              *\n*     (20Sep89) GLA  Fix BROWSE header line                           *\n*     (05Jul89) GLA  Flip out of model 5 mode on empty dataset        *\n*                    If ISPF browsing open but empty ds, give msg     *\n*     (16Jun89) GLA  Fix multiple max support for BROWSE              *\n*     (29Mar89) GLA  Implement ISPF BROWSE support                    *\n*      18Mar90  LDW  Make it so that NIP msgs pass the format check   *\n*      10Mar90  LDW  Correct the check for continuation & MLWTO lines *\n*                       in SYSLOG                                     *\n*      31Dec89  LDW  Add square brackets to translate table (CHARTAB) *\n*      23Nov89  LDW  Remove unneeded Q$IOT, Q$JCT                     *\n*      05Apr88  EMS  Update for bi-modal syslog (370/XA 2.2.0)        *\n*                    Update FT command for XA syslog                  *\n*      03Apr88  LDW  Fix misc bugs in 20Feb88 Update                  *\n*      20Feb88  LDW  Implement field selection for SYSLOG             *\n*       9Aug87  EMS  Fix FA command w/mode FANUM                      *\n*                    Change layout of heading line per LDW            *\n*                    add \"PAGE\" command                               *\n*      16Jul87  EMS  Fix for ***end of data*** on top line            *\n*                    Add stepname/ddname to title                     *\n*                    Update for GETPDDB routine                       *\n*      21May87  EMS  Update for JESNEWS (1.3.4)                       *\n*                    Use Getrec routine                               *\n*                    Change title to include page no/line             *\n*      21Mar87  LDW  Fix for DSID = 0 (from RSCS)                     *\n*      03/31/86 LDW  RE-DESIGN 3278-5 SUPPORT (THIRD TRY!)            *\n*      08/09/84 LDW  UPDATE FOR SP134 (USE IOTPDDB INSTEAD OF         *\n*                       QCPDDB1)                                      *\n*      07/16/84 LDW  IF SEARCH UNSUCCESSFUL, SAY SO, RATHER THAN      *\n*                       JUST 'END OF DATA'                            *\n*      04/11/84 LDW  JCTDSECT -> JCTSTART, IOTDSECT -> IOTSTART       *\n*                    USING/DROP -> USNGX/DROPX                        *\n*      01/23/84 LDW  FIX MORE BUGS IN \"MODE PAGE\" (SOMEDAY...)        *\n*      07/05/83 LDW  FIX TO SAY \"DATASET IS EMPTY\" INSTEAD OF \"DSID   *\n*                       NOT FOUND\" IF PDB1NULL IS SET                 *\n*                    SHOW DSID IN \"DATASET IS EMPTY\" MSG              *\n*      05/12/83 LDW  CHECK FOR PDB1NULL AND IGNORE PDDB               *\n*      03/02/83 LDW  CHANGE 'QTILT *' TO USE QERRMSG                  *\n*      01/19/83 LDW  SET AND USE QTPAGEX, QTHALFX                     *\n*      01/03/83 LDW  SET Q2LISTDS                                     *\n*                    DON'T CHANGE SCREEN SIZE IF ALREADY CORRECT      *\n*                    ADD WORKLEN=                                     *\n*      12/20/82 LDW  CHANGE QTILT REPRMPT=YES TO OPTIONS=REPROMPT     *\n*      12/08/82 LDW  USE $LRC DSECT                                   *\n*      10/28/82 LDW  FIX A LOT OF THE BUGS IN \"MODE PAGE\"             *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 3\nLISTDS   QSTART  Q15,WORKLEN=LD@WORKL\n         USNGX WORK,R13                 BASE REG FOR LOCAL WORK\n         LA    R9,4095(,R12)            setup second ...\n         LA    R9,1(,R9)                ... base register\n         USNGX LISTDS+4096,R9           sigh\n         MVI   LD@FLAGS,0               INITIALIZE FLAGS\n         OI    QFLAG2,Q2LISTDS          TELL THE WORLD WHERE WE ARE\n         OI    QSCFLAG1,QSC1JOB         PUT THE JOBID IN QDTOP\n         QCALL DISP132                  CHANGE TO WIDE SCREEN (MAYBE)\n          AGO   .LDJUNK1                %%%%%\n         MVC   QDHLINE(L'LDHMLINE),LDHMLINE  MOVE IN HEADER LINE\n         OI    QFLAG1,Q1MVHDR           REQUEST \"MOVE HEADER\"\n         MVC   LDHDSID,QDHDSID          AND FILL IN DSID\n         LH    R1,QPOFFSET              GET CURRENT COLUMN NUMBER\n         LA    R1,1(,R1)                IT'S ORIGIN 0\n         CVD   R1,QNUMWORK\n         OI    QNUMWORK+7,X'0F'         REMOVE SIGN\n         UNPK  LDHCOL,QNUMWORK          PUT COLUMN NUMBER IN HEADER\n.LDJUNK1  ANOP                          %%%%%\n***********************************************************************\n*                                                                     *\n*   DETERMINE FUNCTION REQUESTED                                      *\n*                                                                     *\n***********************************************************************\n         CLI   QCODE,0                  IS REQUEST FOR REPOSITIONING?\n         BNE   LD$REPOS                 YES. DO IT.\n***********************************************************************\n*                                                                     *\n*   LOCATE PDDB FOR DATASET SPECIFIED IN QPDSID                       *\n*                                                                     *\n***********************************************************************\n         MVI   QGPFLAG,QPFDIR           req specific dsid\n         QCALL GETPDDB                  get req pddb\n         LTR   R2,R1                    copy to correct reg\n         BL    LD$EMPTY                 if null\n         USNGX PDBDSECT,R2              BASE REG FOR PDDB\nLD$FOUND MVC   QCRECFM,PDBRECFM         RECORD FORMAT FOR SAVE\n         MVC   QCLRECL,PDBLRECL         RECORD LENGTH FOR SAVE\n         MVI   QDLINECT,0               init to zero\n          AIF   (&QLEVEL LT 5).LD010\n         TM    PDBFLAG3,PDBLNCTF        valid linect?\n         BZ    *+10                     no, skip update\n         MVC   QDLINECT,PDBLINCT        set line count\n         MVC   QSTEPNAM,PDBSNAME        set stepname\n         MVC   QDDNAME,PDBDDNAM         and ddname\n.LD010    ANOP ,\n*        L     R4,QCSTART               BEGINNING OF DISK ADDR TABLE\n*        MVC   0(4,R4),PDBMTTR\n*        ZAP   QCHREC,=P'0'             ZERO HIGH REC NO\n*        MVC   QCHPTR,QCSTART           BEGIN OF TBL\n         MVI   QCRFLAG,QRFINIT          request initialization\n         MVC   QCGRMTTR,PDBMTTR         set starting mttr\n         DROPX R2                       PDBDSECT\n         TM    QISFLAG1,QIS1ISPF        are we in ISPF?\n         BZ    LD$FIRST                 process dataset\n***********************************************************************\n*                                                                     *\n*        Read the first data block to insure that dataset is not      *\n*        empty                                                        *\n*                                                                     *\n***********************************************************************\n         SR    R4,R4                    tell GETREC to read first rec\n         QCALL GETREC                   get\n         TM    QCRFLAG,QRFERR+QRFEOF    error reading blk, or eof?\n         BNZ   LD$EMPTY                 yes - say it's empty %%%%%%%%\n*%%??    LTR   R4,R4                    is the disk addr zero?\n*%%??    BZ    LD$EMPTY                 yes - it's empty\n***********************************************************************\n*                                                                     *\n*        SETUP ISPF/PDF BROWSE INTERFACE                              *\n*                                                                     *\n***********************************************************************\n*\n**       SETUP FIRST ENTRY IN TABLE\n*\n         ST    R13,BRWSAVE              SAVE CURRENT SAVEAREA PTR\n         ST    R4,0(,R2)                SAVE TTR OF FIRST BLOCK\n         MVC   4(4,R2),QCCREC           RECORD NUMBER IN BLOCK\n         L     R15,ISPLNK               CALL ISPF INTERFACE\n         CALL  (15),(=C'VREPLACE',=C'(QQACT) ',=F'26',                 $\n               =CL26'SELECT CMD(%QCQQ         )'),                     $\n               VL,MF=(E,LD@CALLP)\n*\n**       SEE IF WE CAN USE IBM DEFINED INTERFACE\n*\n         TM    QISFLAG1,QIS1V23         ARE WE V2.3 OR HIGHER?\n         BZ    QISPF22                  NO - USE KULTZY DCB IFACE\n***********************************************************************\n*                                                                     *\n**       ISPF V2.3 OR HIGHER - BRIF INTERFACE                         *\n*                                                                     *\n***********************************************************************\n*\n**       FORMAT HEADER TO IDENTIFY FILE\n*\n         MVC   BRWHDR,QBLANK\n         MVC   BRWHDR(8),QJOBNAME       move in jobname\n         LA    R15,BRWHDR+7             -> last char\nLD$ISLP1 CLI   0(R15),C' '              blank?\n         BNE   *+8                      no, done\n         BCT   R15,LD$ISLP1             yes, try prev\n         MVI   1(R15),C'('              delimeter\n         MVC   2(8,R15),QEXTJBID        move in jobid\n         OC    5(5,R15),=C'00000'       convert blanks to zeroes\n         MVI   10(R15),C')'             delimiter\n         MVI   11(R15),C'/'             delimeter\n         LA    R15,12(,R15)             -> last char\n***      MVI   1(R15),C'/'              delimeter\n***      LA    R15,2(,R15)              -> last char\n          AIF   (&QLEVEL LT 5).LD020\n         MVC   0(8,R15),QSTEPNAM        set stepname\n         LA    R15,7(,R15)              -> last char\n*\nLD$ISLP2 CLI   0(R15),C' '              blank?\n         BNE   *+8                      no, done\n         BCT   R15,LD$ISLP2             yes, try prev\n         MVI   1(R15),C'/'              delimeter\n         MVC   2(8,R15),QDDNAME         and ddname\n         LA    R15,2+7(,R15)            -> last char\n*\nLD$ISLP3 CLI   0(R15),C' '              blank?\n         BNE   *+8                      no, done\n         BCT   R15,LD$ISLP3             yes, try prev\n         LA    R15,1(,R15)              bump\n*\n.LD020    ANOP ,\n         MVI   0(R15),C'('              delimeter\n         LA    R15,1(,R15)              bump\n          AIF  (&QLEVEL GE 9).LD030\n         LH    R1,QPDSID                GET DSID NUMBER\n          AGO   .LD040\n.LD030    ANOP\n         ICM   R1,B'1111',QPDSID        DSID NUMBER\n.LD040    ANOP\n         CVD   R1,QNUMWORK              MAKE DECIMAL\n         MVC   LD@STPDD(8),=XL8'4020202020202120'\n         LA    R1,LD@STPDD+7            set for edmk\n         EDMK  LD@STPDD(8),QNUMWORK+4   put in number\n         LA    R14,LD@STPDD+8           get length of string\n         SR    R14,R1\n         BCTR  R14,0                    get machine length\n         EX    R14,LD$ISMVC             MVC 0(*-*,R15),0(R1)  move dsid\n         LA    R15,1(R14,R15)           bump past dsid\n         MVI   0(R15),C')'              and closing paren\n         LH    R2,QCLRECL               GET RECORD LENGTH\n         LTR   R2,R2                    anything?\n         BP    *+8                      yes - use it\n         LH    R2,=H'32760'             no - use max allowed\n         ST    R2,LD@BRLR               SAVE LENGTH IN FULL WORD\n         ST    R11,LD@BRQC              SAVE ADDR OF QCOM\n         MVC   QDHLINE,QBLANK           clear hdr line\n         MVI   QBRIFHDR,C'R'            request hdr line rebuild\n         L     R15,ISPLNK               CALL ISPF INTERFACE\n         CALL  (15),(=C'CONTROL ',=C'ERRORS  ',=C'RETURN  '),          $\n               VL,MF=(E,LD@CALLP)\n         L     R15,ISPLNK               CALL ISPF INTERFACE\n         TM    QSCFLAG3,QSC3EDIT        want edit instead of browse?\n         BNZ   LD$EDIF                  yes\n         LA    R2,=C'V '                assume no cc\n         TM    QCRECFM,DCBRECCA         asa control characters?\n         BZ    *+8                      no - skip\n         LA    R2,=C'VA '               yes - change recfm for BRIF\n         TM    QCRECFM,DCBRECCM         mch control characters?\n         BZ    *+8                      no - skip\n         LA    R2,=C'VM '               yes - change recfm for BRIF\n*\n*\n         CALL  (15),(=C'BRIF',BRWHDR,(R2),LD@BRLR,=A(ISPF23RD),        $\n               =A(LD$BRIFC),LD@BRQC,=CL8'QPBRO'),                      $\n               VL,MF=(E,LD@CALLP)\n*\n         B     LD$BREND\n*\n*\n*\nLD$EDIF  CALL  (15),(=C'EDIF ',BRWHDR,  data name                      $\n               =C'SPOOL ',              profile name                   $\n               =C'V ',LD@BRLR,          rec-format, rec-len            $\n               =A(LD$ED$RD),=A(LD$ED$WR),  read-routine, write-routine $\n               0,LD@BRQC,               cmd-routine, dialog-data       $\n               0,0,                     edit-len, panel-name           $\n               =C'QCEDIMAC'),           macro name                     $\n               VL,MF=(E,LD@CALLP)\n*\n*\nLD$BREND LR    R2,R15                   SAVE RETURN CODE\n         L     R15,ISPLNK               CALL ISPF INTERFACE\n         CALL  (15),(=C'CONTROL ',=C'ERRORS  ',=C'CANCEL  '),          $\n               VL,MF=(E,LD@CALLP)\n         B     LD$ISEND                 ALL DONE SO EXIT\nLD$ISMVC MVC   0(*-*,R15),0(R1)         << executed >>\n         EJECT\n***********************************************************************\n*                                                                     *\n**       ENTRY CODE FOR ISPF V1.X AND V2.0->V2.2                      *\n*                                                                     *\n***********************************************************************\nQISPF22  L     R8,BRWEPARM              POINT AT TLD\n         USNGX TLD,R8\n         L     R7,ISRNM                 POINT TO ISR SERVICE TABLE\n         USNGX ISRNAME,R7\n*\n**       NOW DETERMINE IF ISPF VERSION 1 OR 2\n*\n         NI    QISFLAG1,255-QIS1V2      SET VERSION 2 FLAG OFF\n         L     R1,ISRCBR                GET ADDRESS\n         CLC   =C'ISRCBR',5(R1)         IS THIS ISPF V1?\n         BE    HAVEISR                  YES\n         S     R7,=F'4'                 BACK UP BY 4 FOR V2\n         OI    QISFLAG1,QIS1V2          SET V2 FLAG ON\n         L     R1,ISRCBR                GET ADDRESS BACK\n         CLC   =C'ISRCBR',5(R1)         IS THIS ISPF V2?\n         BE    HAVEISR                  YES\n         EX    0,*                      ***UNKNOWN ISPF LEVEL****\n*\nHAVEISR  L     R6,ISPNM                 POINT TO ISP SERVICE TABLE\n         USNGX ISPNAME,R6\n*\n**       INITIALIZE BROWSE SERVICES\n*\n         L     R15,ISRCBS               GET MODULE ADDR\n         CALL  (15),((R8),BRWCBTP),VL,MF=(E,LD@CALLP)\n*\n**       CLEAR AND FORMAT TFD\n*\n         L     R3,QVTFD                 Get addr of TFD\n         XC    0(208,R3),0(R3)          CLEAR IT\n         MVC   0(4,R3),=C'TFD:'         SET EYEBALL\n         MVI   5(R3),X'7E'              SET FLAGS\n         MVI   6(R3),X'80'              SAY OPENED BY CDO\n         LA    R1,TFDMENUP              POINT AT VARIABLES\n         ST    R1,64(,R3)               SAVE POINTER\n         LA    R1,TFDDCB                POINT AT DCB\n         ST    R1,68(,R3)               SAVE POINTER\n         LA    R1,TFDDSN                POINT AT DSN\n         ST    R1,128(,R3)              SAVE POINTER\n         LH    R1,QCLRECL               GET MAX RECORD LENGTH\n         LA    R1,4(,R1)                ALLOW FOR RDW\n         CH    R1,=H'252'               IS IT TOO BIG?\n         BL    *+8                      NO - SKIP\n         LA    R1,252                   SET MAX LENGTH\n         STH   R1,40(,R3)               SET RECORD LENGTH\n         MVC   42(2,R3),=AL2(256)       SET BLKSIZE\n         MVI   48(R3),DCBRECV           MARK AS 'RECFM=V'\n         MVI   49(R3),X'40'             SET DSORG=PS\n         MVC   50(2,R3),=X'2400'        SET MACRF=(R)\n         MVI   52(R3),X'08'             SET STATUS\n         MVI   53(R3),X'08'             SET DISP\n         LA    R1,LD@BUF                GET LINE BUFFER ADDRESS\n         ST    R1,24(,R3)               SET BUFFER A ADDRESS\n*\n**       FILL IN DCB CODES\n*\n         LA    R2,TFDDCB                POINT AT DCB\n         XC    0(92,R2),0(R2)           CLEAR\n         USNGX IHADCB,R2\n         ST    R11,DCBDEBAD             ADDR OF OUR SAVE AREAS\n         MVC   DCBMACRF,=X'2400'        SET MACRF=(R)\n         MVI   DCBRECFM,DCBRECV         MARK AS 'RECFM=V'\n         MVC   DCBLRECL,40(R3)          SET LRECL\n         MVC   DCBBLKSI,=AL2(256)       SET BLKSIZE\n         MVC   DCBREAD(4),=A(LSDSREAD)  set READ routine address\n         MVC   DCBCHECK(4),=A(LSDSCHCK) set CHECK routine address\n         MVC   DCBPOINT(4),=A(LSDSPNT)  set POINT routine address\n         TM    QISFLAG1,QIS1V2          IS THIS V2 OF ISPF\n         BNO   ISPFV1              NOPE - SKIP V2 CODE AND DO it hard\n*\n**       PROCSSSING FOR ISPF VERSION 2\n*\n         LA    R1,TFDDSN                POINT AT DSN\n         ST    R1,132(,R3)              SAVE POINTER\n         ST    R1,136(,R3)              SAVE POINTER\n         ST    R1,140(,R3)              SAVE POINTER\n         L     R2,BRWCBTP               GET BROWSE TABLE PTR\n         MVC   709(8,R2),=C'ISRBROBF'   SET MENU NAME\n         MVC   717(8,R2),=CL8' '        SET BLANKS\n         XC    144(4,R2),144(R2)\n         MVI   616(R2),X'01'            SET DATASET NUMBER\n         MVC   TFDDSN+2(27),=CL27'JOB 12345678, DSID 12345678'\n         MVC   TFDDSN+2+4(8),QPARM1     SET JOBNAME\n          AIF   (&QLEVEL GE 9).LD050\n         LH    R1,QPDSID                GET DSID NUMBER\n          AGO   .LD060\n.LD050    ANOP\n         ICM   R1,B'1111',QPDSID        DSID NUMBER\n.LD060    ANOP\n         CVD   R1,QNUMWORK              MAKE DECIMAL\n         MVC   TFDDSN+2+4+8+7(8),=XL8'4020202020202120'  PATTERN\n         ED    TFDDSN+2+4+8+7(8),QNUMWORK+4  PUT IN NUMBER\n         MVC   TFDDSN(2),=H'27'         LENGTH OF DSN\n         B     CBR                      GO AND DO BROWSE\n*\n**       PROCSSSING FOR ISPF VERSION 1\n*\nISPFV1   DS    0H\n*\n**       SET OFF BROWSE RECURSIVE FLAG\n*\n         NI    TLD+237,X'FF'-X'04'\n*\n**       CALL ISPCMSG TO FORMAT SCREEN HEADER\n*\nCMSG     L     R15,ISPCMSG\n         CALL  (15),((R8),=C'B003',=F'2',BRWHDR,=F'72',                $\n               TFDDSN+2,BRWMEM,BRWSTAMP),VL,MF=(E,LD@CALLP)\n*\n**       INITIALIZE CBT FOR SCROLL HANDLER\n*\n         L     R2,BRWCBTP               POINT AT COMMON BROWSE TABLE\n         L     R2,8(,R2)                POINT AT EXTENSION\n         MVC   0(8,R2),=CL8'ISRBROB'    SET MENU\n         LA    R1,BRWHDR                POINT AT HEADER\n         ST    R1,8(,R2)                SAVE HEADER POINTER\n         MVC   12(4,R2),=F'72'          SET HEADER LENGTH\n*\n**       FORMAT HEADER TO IDENTIFY FILE\n*\n*                               123456789112345678921234567\n         MVC   BRWHDR(27),=CL27'JOB 12345678, DSID 12345678'\n         MVC   BRWHDR+4(8),QPARM1       SET JOBNAME\n          AIF  (&QLEVEL GE 9).LD070\n         LH    R1,QPDSID                GET DSID NUMBER\n          AGO   .LD080\n.LD070    ANOP\n         ICM   R1,B'1111',QPDSID        DSID NUMBER\n.LD080    ANOP\n         CVD   R1,QNUMWORK              MAKE DECIMAL\n         MVC   BRWHDR+4+8+7(8),=XL8'4020202020202120'  PATTERN\n         ED    BRWHDR+4+8+7(8),QNUMWORK+4  PUT IN NUMBER\n*\n**       CALL COMMON BROWSE SERVICE VERSION 1 AND 2\n*\nCBR      L     R15,ISRCBR               GET PROWSE ENTRY PONIT\n         L     R2,QVTFD                 Point at TFD\n         CALL  (15),((R8),(R2),BRWCBTP),VL,MF=(E,LD@CALLP)\n         L     R2,ISRRET                GET RETURN CODE\n*\n**       CALL COMMON BROWSE CLEANUP\n*\nCBC      L     R15,ISRCBC               GET PROWSE ENTRY PONIT\n         CALL  (15),((R8),BRWCBTP),VL,MF=(E,LD@CALLP)\n*\n*\n*\nLD$ISEND OI    QISFLAG1,QIS1BRCP        mark BROWSE complete\n         TM    LD@FLAGS,LD@BRCMD        do we have a new subcommand?\n         BNZ   *+10                     yes - don't kill it\n         XC    QDRLNG,QDRLNG            no - kill previous subcommand\n         TM    QISFLAG1,QIS1V32         running under ISPF V3.2?\n         BNZ   LD$ISE32                 yes - skip VREPLACE\n         L     R15,ISPLNK               CALL ISPF INTERFACE\n         CALL  (15),(=C'VREPLACE',=C'(QQACT) ',=F'8',=CL8'SETVERB'),   $\n               VL,MF=(E,LD@CALLP)       Reset VERB TABLE action\nLD$ISE32 LTR   R2,R2                    ANY ERROR?\n         BNZ   LD$EMPTY                 yes - issue EMPTY DS message\n***********************************************************************\n*                                                                     *\n*        Copy in the Q command variable if set                        *\n*                                                                     *\n***********************************************************************\n*%%% first should check fif ZVERB is 'RETURN' and if so\n*%%% dummy up 'EXIT' command.\n*%%% if not then get QCMD and see if Q command entered\n         LA    R0,32                    maximum length\n         ST    R0,LD@VLEN               set for VCOPY\n         L     R15,ISPLNK\n         CALL  (15),(=CL8'VCOPY',=CL8'QCMD',LD@VLEN,QDREPLY,           $\n               =CL8'MOVE'),VL,                                         $\n               MF=(E,LD@CALLP)\n         L     R0,LD@VLEN               GET LENGTH OF REPLY\n         STH   R0,QDRLNG                STORE LENGTH OF REPLY\n         OI    LD@FLAGS,LD@BRCMD        remember we have a new subcmd\n         L     R15,ISPLNK\n         CALL  (15),(=CL8'VERASE',=CL8'QCMD'),VL,                      $\n               MF=(E,LD@CALLP)\n         CLC   =C'QQ',QDREPLY           Is this proper flag?\n         BNE   QSTOP                    nope - done\n         LA    R0,QDREPLYL              maximum length\n         ST    R0,LD@VLEN               set for VCOPY\n         L     R15,ISPLNK\n         CALL  (15),(=CL8'VCOPY',=CL8'ZPARM',LD@VLEN,QDREPLY,          $\n               =CL8'MOVE'),VL,                                         $\n               MF=(E,LD@CALLP)\n         L     R0,LD@VLEN               GET LENGTH OF REPLY\n         STH   R0,QDRLNG                STORE LENGTH OF REPLY\n         B     QSTOP                    all done\n         DROPX R6,R7,R8,R2\n         EJECT\n***********************************************************************\n*                                                                     *\n*   PROCESS DATASET                                                   *\n*                                                                     *\n***********************************************************************\nLD$FIRST BAL   R14,LD$HEAD              fill in header stuff\nLD$TOP   EQU   LD$FIRST,,C'I'           Same as above\n         MVI   QBRIFHDR,C' '            header line built\n         TM    QISFLAG1,QIS1ISPF        Are we in ISPF?\n         BZ    *+10                     no - don't move header line now\n         MVC   QDHLINE(L'LDHMLINE),LDHMLINE  MOVE IN HEADER LINE\n         MVC   LDHREC,=CL8'1'           Set record nbr in header\n         MVC   LDHPAGEN,=CL8'1'         and Page nbr in header\n         MVC   LDHLINEN,=CL8'1'         and Line nbr in header\n         XR    R4,R4                    set to first record\n         TM    QISFLAG1,QIS1ISPF        Are we in ISPF?\n         BZ    LD$NXREC                 no - don't shift header\n         MVC   QDHLINE(LDHPAGEL),LDHPAGET  shift page and line nbr\n         MVC   QDHLINE+LDHPAGEL(L'QDHLINE-LDHPAGEL),QBLANK  clear rest\n         SPACE 1\nLD$NXREC QCALL GETREC                   get next record\n         TM    QCRFLAG,QRFERR           any error reading blk?\n         BO    LD$RERR                  YES - handle it\n         LTR   R4,R4                    IS THE DISK ADDR ZERO?\n         BZ    LD$END                   YES. END OF DATASET.\n***********************************************************************\n*                                                                     *\n*   PROCESS RECORDS                                                   *\n*                                                                     *\n***********************************************************************\n         USNGX LRCDSECT,R4\n         LR    R7,R6                    SAVE RECORD LENGTH\n         LR    R10,R4                   SAVE RECORD LOCATION\n         MVC   LD@BYTE1,LRCFLAG1        SAVE FLAG BYTE\n         DROPX R4                       LRCDSECT\n         TM    QMODE1,QM1PAGE           IN PAGE DISPLAY MODE?\n         BNO   LD$NOPG1                 NO - SKIP\n         B     LD$NOPG1                 %%%%%% until page mode works\n         CP    QCCPAGE,QPPAGE           Reached the record we want?\n         BL    LD$NXREC                 NO, try next record.\n         CP    QCCLINE,QPLINE           Reached the record we want?\n         BL    LD$NXREC                 NO, try next record.\n         B     LD$PGCOM                 Yes, use it\nLD$NOPG1 CP    QCCREC,QPREC             REACHED THE RECORD WE WANT?\n         BL    LD$NXREC                 NO. TRY NEXT RECORD.\nLD$PGCOM CLI   QCODE,4                  IS THE REQUEST FOR A FIND?\n         BE    LD$FIND                  YES. DO IT.\n         CLI   QCODE,8                  IS IT A FINDTIME REQUEST?\n         BE    LD$FTIME                 YES. DO IT.\n         SPACE 1\nLD$FIOFF CLC   =C'JOBLOG',QDHDSID       IS THIS THE JOBLOG?\n         BNE   LD$NOTJL                 NO - OK\n*  THE FOLLOWING WILL USUALLY BE RECORD 3 OF AN INPUT QUEUE JOB.\n         CLC   =C'******** JOB DELETED BY JES2 OR CANCELLED BY OPERATOR$\n                BEFORE EXECUTION ********',4(R10)   JES2 being STUPID?\n         BNE   LD$NOTJL\n         B     LD$END                   YES - TERMINATE JOBLOG DISPLAY\n*  ACTUALLY, THE CHECK ABOVE IS INCORRECT.  WHAT IT REALLY SHOULD BE IS\n*  A CHECK TO SEE IF THE JOB IS ON AN OUTPUT QUEUE.  IF SO, THEN THE\n*  JOB HAS BEEN CANCELLED OFF OF THE INPUT QUEUE, AND WE SHOULD DISPLAY\n*  THE JOBLOG.  BUT, I DON'T KNOW AT THE MOMENT AN EASY WAY TO CHECK\n*  THE JOB BEING ON THE OUTPUT QUEUE, SO THIS WILL HAVE TO DO.  IT'S\n*  STILL A WHOLE LOT BETTER THAN IT WAS.  (IT WOULD NEVER LET YOU LOOK\n*  AT THE JOBLOG FOR AN EXECUTING JOB.)\n         SPACE 1\n***      QTILT '*** JOBLOG IS EMPTY ***'\nLD$NOTJL TM    QMODE1,QM1PAGE           IN PAGE DISPLAY MODE?\n         BNO   LD$NOPG2                 NO - SKIP\n         TM    LD@BYTE1,LRC1CCTL        CARRIAGE CONTROL SPECIFIED?\n         BNO   LD$NOCC                  no - skip\n         CLI   3(R10),C'0'              ASA Double space?\n         BE    LD$SPC2                  YES - DO IT\n         CLI   3(R10),C'-'              ASA Triple space?\n         BE    LD$SPC3                  YES - DO IT\n         CLI   3(R10),C'1'              ASA new page?\n         BNE   LD$NOPG2                 NO - NOTHING STANDARD - SKIP\n         CP    QPREC,=P'1'              IS THIS TOP OF DATASET?\n         BE    LD$NOPG2                 YES - SKIP SEPARATOR LINE\n         BAL   R14,QADDLINE             PUT OUT A BLANK LINE\n*ems     AP    QPREC,=P'1'              BUMP RECORD COUNT\n         MVI   QDMSG,C'='               BUILD A ...\n         MVC   QDMSG+1(L'QDMSG-1),QDMSG ... SEPARATOR ...\n         MVC   QDMSG+30(13),=C' END OF PAGE '   ... LINE\n         BAL   R14,QADDLINE             PUT OUT SEPARATOR LINE\n         BAL   R14,QADDLINE             put out blank line\n         B     LD$NOPG2                 and output data line\n*ems     AP    QPREC,=P'1'              BUMP RECORD COUNT\n         SPACE 1\nLD$SPC3  BAL   R14,QADDLINE             PUT OUT BLANK LINE\n*ems     AP    QPREC,=P'1'              BUMP RECORD COUNT\n         SPACE 1\nLD$SPC2  BAL   R14,QADDLINE             PUT OUT BLANK LINE\n*ems     AP    QPREC,=P'1'              BUMP RECORD COUNT\n         SPACE 2\nLD$NOPG2 TM    LD@BYTE1,LRC1CCTL        is carriage control specified?\n         BZ    LD$NOCC                  NO. CONTINUE.\n         TM    QMODE1,QM1LCC            YES. DOES HE WANT TO SEE IT?\n         BNZ   LD$NOCC                  yes - display it\n         TM    QISFLAG1,QIS1ISPF        Are we in ISPF?\n         BNZ   LD$NOCC                  yes - always pass the CC\n*  This might need to be based on the release of PDF, but I don't\n*  remember when the DISP CC/NOCC command showed up...\n         BCTR  R7,0                     no - decrement length\n         LA    R10,1(,R10)              ... and skip over it\nLD$NOCC  EQU   *\n         TM    QFLAG3,Q3SYSLOG          is this the SYSLOG command?\n         BZ    LD$NOTSL                 no - skip\n         CLI   QSLFLDS,0                any fields selected?\n         BZ    LD$NOTSL                 no - skip\n         LA    R1,LD@REC                -> start of rebuild area\n***      CLC   QBLANK(40),2+3(R10)      is this a cont or mlwto line?\n*---  Check for blank timestamp\n         CLC   QBLANK(11),25+3(R10)     cont, mlwto, or nip line?\n         BE    LD$SLXA                  yes - reformat it (assume XA)\n         CLI   7+3(R10),C'.'            pre SP 2.2.0 syslog?\n         BE    LD$SL370                 yes, older format\n         CLI   27+3(R10),C':'           bizarre line?  (huh?)\n         BNE   LD$NOTSL                 yes - don't futz with it\n         CLI   30+3(R10),C':'           bizarre line?  (huh?)\n         BE    LD$SLXA                  no - use it\n*\nLD$SLXA  TM    QSLFLDS,QSLFLIND         want indicators?\n         BZ    *+4+6+4                  no - skip\n         MVC   0(2,R1),=AL1(1,2)        yes\n         LA    R1,2(,R1)\n*\n         TM    QSLFLDS,QSLFLRTC         want route codes?\n         BZ    *+4+6+4                  no - skip\n         MVC   0(7,R1),=AL1(3,4,5,6,7,8,9)  yes\n         LA    R1,7(,R1)\n*\n         TM    QSLFLDS,QSLFLIND+QSLFLRTC  either ind or rtc selected?\n         BZ    *+4+4+4  *diff offset*   no - skip\n         MVI   0(R1),0                  yes - select a blank\n         LA    R1,1(,R1)\n*\n         TM    QSLFLDS,QSLFLSID         want system id?\n         BZ    *+4+6+4                  no - skip\n         MVC   0(9,R1),=AL1(11,12,13,14,15,16,17,18,0)  yes\n         LA    R1,9(,R1)\n*\n         TM    QSLFLDS,QSLFLDAT         want date?\n         BZ    *+4+6+4                  no - skip\n         MVC   0(6,R1),=AL1(20,21,22,23,24,0)  yes\n         LA    R1,6(,R1)\n*\n         TM    QSLFLDS,QSLFLTIM         want time?\n         BZ    *+4+6+4                  no - skip\n         MVC   0(12,R1),=AL1(26,27,28,29,30,31,32,33,34,35,36,0)\n         LA    R1,12(,R1)\n*\n         TM    QSLFLDS,QSLFLJID         want jobid?\n         BZ    *+4+6+4                  no - skip\n         MVC   0(9,R1),=AL1(38,39,40,41,42,43,44,45,0)  yes\n         LA    R1,9(,R1)\n*\n         TM    QSLFLDS,QSLFLRFL         want request flags?\n         BZ    *+4+6+4                  no - skip\n         MVC   0(9,R1),=AL1(47,48,49,50,51,52,53,54,0)  yes\n         LA    R1,9(,R1)\n*\n         L     R15,=A(LD#SLTXA)         select columns 56-130\n         MVC   0(75,R1),0(R15)\n         XC    75(300-130,R1),75(R1)    pad with blanks\n         B     LD$SLCOM                 back to common code\n         SPACE 1\nLD$SL370 CLI   10+3(R10),C'.'           more time?\n         BNE   LD$NOTSL                 no, treat it normal\n         TM    QSLFLDS,QSLFLRTC         want route codes?\n         BZ    *+4+6+4                  no - skip\n         MVC   0(5,R1),=AL1(1,2,3,4,0)  yes\n         LA    R1,5(,R1)\n*\n         TM    QSLFLDS,QSLFLTIM         want time?\n         BZ    *+4+6+4                  no - skip\n         MVC   0(9,R1),=AL1(6,7,8,9,10,11,12,13,0)  yes\n         LA    R1,9(,R1)\n*\n         TM    QSLFLDS,QSLFLJID         want jobid?\n         BZ    *+4+6+4                  no - skip\n         MVC   0(9,R1),=AL1(15,16,17,18,19,20,21,22,0)  yes\n         LA    R1,9(,R1)\n*\n         L     R15,=A(LD#SLT37)         select columns 24-130\n         MVC   0(106,R1),0(R15)\n         XC    106(300-130,R1),106(R1)  pad with blanks\n         SPACE 1\nLD$SLCOM MVC   LD@SLREC,QBLANK          blank the target area\n         BCTR  R7,0                     -1 for ex\n         EX    R7,LD$MVCSL              mvc ld@slrec+1(*-*),3(r10)\n         TR    LD@REC(200),LD@SLREC\n         TR    LD@REC+200(100),LD@SLREC\n*\n         LA    R10,LD@REC-3             -> rebuilt record to display\n         LA    R7,L'LD@REC              and length\nLD$NOTSL EQU   *\n         AH    R10,QPOFFSET             Add offset to start of record\n         SH    R7,QPOFFSET              SUBTRACT OFFSET FROM LENGTH\n         BNP   LD$DISP                  NO DATA LEFT IN RECORD.\n         TM    QISFLAG1,QIS1ISPF        Are we in ISPF?\n         BO    LD$DISP                  If so then leave alone\n         CH    R7,QDCOLS                IS RECORD BIGGER THAN 80 CHARS?\n         BNH   *+8                      NO. USE RECORD LENGTH.\n         LH    R7,QDCOLS                YES. USE A LENGTH OF 80.\n         BCTR  R7,0                     -1 FOR EX\n         LA    R10,3(,R10)              OFFSET PAST REC HDR\n         EX    R7,LD$MVC                MOVE RECORD TO DISPLAY LINE\n         L     R1,=A(CHARTAB)           get address of table\n         EX    R7,LD$TR                 TRANSLATE OUT UNPRINTABLE CHARS\n         CLC   =C'FA',QSUBNAME          IS THIS FINDALL?\n         BNE   LD$DISP                  NO - SKIP\n         TM    QMODE1,QM1FANUM          WANT NUMBERS FOR FINDALL?\n         BNO   LD$DISP                  NO - SKIP\n         LA    R1,QDMSG-8\n         AH    R1,QDCOLS                -> LAST 8 CHARS OF SCREEN LINE\n         MVC   0(8,R1),LD#EDIT          Set edit mask\n         ED    0(8,R1),QCCREC           Move in current record no.\nLD$DISP  TM    QISFLAG1,QIS1ISPF        ARE WE IN ISPF?????\n         BZ    NISPF2                   NOPE - CONTINUE NORMALLY\n***********************************************************************\n*                                                                     *\n*        MOVE LINE BACK TO BROWSE  FOR ISPF V1.X -> V2.2              *\n*                                                                     *\n*              R7  ===  LENGTH                                        *\n*              R10+3 ->  DATA                                         *\n*                                                                     *\n***********************************************************************\n         LA    R10,3(,R10)              UPDATE TO REAL LINE\n         L     R8,4(,R13)               GET ORIG R13\n         L     R8,12+4+4+4(,R8)         GET DECB ADDRESS (R1 ON ENTRY)\n         TM    QISFLAG1,QIS1V23         IS THIS ISPF V2.3?\n         BO    QISPF23A                 YES - HANDLE\n          AIF   (&LD#DBG).LDJUNK2  %%%  if dbg, need the addressibility\n         USNGX DECSDECB,R8              SETUP ADDRESSABILITY FOR DECB\n         L     R15,DECAREA              POINT TO AREA\n         CH    R7,=H'248'               max line supported\n         BNH   *+8     >=====+          length ok\n         LA    R7,248        |          set to max\n         LA    R14,5(,R7) <==+          get RDW\n         STH   R14,4(R15)               set RDW\n         XC    6(2,R15),6(R15)          CLEAR REST OF RDW\n         LA    R14,4(R14)               get BDW\n         STH   R14,0(R15)               set BDW\n         XC    2(2,R15),2(R15)          CLEAR REST OF BDW\n         BCTR  R7,0                     -1 for EX\n         EX    R7,RECMOVE               move in data\n         AP    QPREC,=P'1'              SET NEXT ENTRY TO NEXT RECORD\n         B     SETIOB                   ALL DONE\n         DROPX R8\n.LDJUNK2  ANOP                          %%%%%\nRECMOVE  MVC   8(*-*,R15),0(R10)        << executed >>\n***********************************************************************\n*                                                                     *\n*        MOVE LINE BACK TO BROWSE  FOR ISPF V2.3 -> ??                *\n*                                                                     *\n*              R7  ===  LENGTH                                        *\n*              R8  -->  READ ROUTINE PARM LIST                        *\n*              R10 -->  DATA                                          *\n*                                                                     *\n***********************************************************************\nQISPF23A LA    R15,LD@BUF               POINT TO MY BUFFER\n         L     R2,0(,R8)                GET ADDR OF VARIABLE\n         ST    R15,0(,R2)               SET POINTER IN LINE VARIABLE\n         L     R2,4(,R8)                GET ADDR OF VARIABLE\n         CH    R7,=H'256'               max line supported\n         BNH   *+8      >=====+         length ok\n         LA    R7,256         |         set to max\n         ST    R7,0(,R2)  <===+         SET LENGTH IN PARM LIST\n         SL    R15,=F'8'                ADJUST FOR MVC OPERAND\n         BCTR  R7,0                     -1 for EX\n         EX    R7,RECMOVE               MOVE IN DATA\n         L     R15,4(,R13)              NOW SET THE CORRECT RETURN CD\n         XC    12+4(4,R15),12+4(R15)    SET TO 0\n         B     LSDSCKXT                 NOW EXIT\n***********************************************************************\n*                                                                     *\n*        MOVE LINE TO DISPLAY FOR NATIVE SCREEN CONTROL               *\n*                                                                     *\n*              QDMSG has DATA                                         *\n*                                                                     *\n***********************************************************************\nNISPF2   BAL   R14,QADDLINE\n         TM    QDOVER,1                 WAS THERE A PAGE OVERFLOW?\n         BNO   LD$NXREC                 NO. SKIP.\n         ZAP   QPREC,QCCREC             UPDATE THE REPOSITION NUMBER\n         ZAP   QPPAGE,QCCPAGE           set to current page\n         ZAP   QPLINE,QCCLINE           set to current line (cc)\n         ZAP   QPLINEA,QCCLINEA         set to current line (abs)\n         BAL   R14,LD$HEAD              insert heading\n         B     LD$NXREC                 and get next record\n         SPACE 1\n*---  Error on block read\nLD$RERR  ZAP   QCHREC,=P'0'             clear high rec on err\n         ZAP   QCCREC,=P'0'             clear current rec on err\n*                                       Handle rest like eof\n         SPACE 1\nLD$END   TM    QISFLAG1,QIS1ISPF        are we in ispf?\n         BO    LSDSCKEF                 yes - return to CHECK\n         CP    QCCREC,=P'0'             IS THE DATASET EMPTY?\n         BE    LD$EMPTY                 YES. QUIT.\n         CP    QPREC,QCCREC             REQUESTED POS > END?\n         BH    LD$BOTTM                 YES - FORCE HIM TO \"BOTTOM\"\n*%%%     CLC   =C'TT70710',QLOGON       ME?\n*%%%     BNE   *+4+6+6+6                NO - SKIP FOR NOW %%%%%%%%%%%\n*%%%     MVC   LDHEND,ENDLINE           TELL THEM THIS IS THE END\n*%%%     MVC   LDHREND,LD#EDIT          PATTERN FOR EDIT\n*%%%     ED    LDHREND,QCCREC           LAST REC NO\n         CLI   QCODE,32                 WAS REQUEST FOR BOTTOM?\n         BE    LD$BOTTM                 YES. BACK UP 20 LINES.\n         CLI   QCODE,4                  IS THE REQUEST FOR A FIND?\n         BE    LD$NOPE                  YES - SAY WE DIDN'T FIND IT\n         CLC   QDLINECT,QDROWS          is screen full?\n         BE    LD$DISPF                 no, repos to last screen\nLD$DEND  L     R1,=V(ENDDATA)           -> \"END OF DATA\" MSG\n         MVC   QDMSG(80),0(R1)\n         BAL   R14,QADDLINE             MOVE \"END OF DATA\" TO SCREEN\nLD$DISPF QCALL DISPLAY                  FLUSH THE SCREEN\n*LDW*    ZAP   QPREC,=P'1'              RECORD NUMBER 1\n*LDW*    B     LD$TOP                   START AT TOP OF DATASET\n         B     LD$REPOS                 JUST STAY RIGHT HERE      *LDW*\nLD$NOPE  CLI   QSUBNAME+1,C'A'          IS THE REQUEST FOR A FINDALL?\n         BNE   LD$NOPE2                 NO - SAY 'NOT FOUND'\n         TM    LD@FLAGS,LD@FOUND        DID WE FIND ANYTHING?\n         BO    LD$DEND                  YES - JUST SHOW END OF DATA\nLD$NOPE2 MVC   QERRMSG(26),=C'*** STRING NOT FOUND --> '''\n         LH    R1,QPLNG                 GET LENGTH-1 OF SEARCH STRING\n         CH    R1,=H'53'                TOO LONG?\n         BNH   *+8                      NO - OK\n         LH    R1,=H'53'                YES - USE MAX\n         EX    R1,LD$NOPEM              FILL IN THE SEARCH STRING\n         CLC   QPLNG,=H'53'             ENOUGH ROOM FOR ENDING QUOTE?\n         BNL   LD$NOPE3                 NO - SO DON'T PUT IT IN\n         LA    R1,QERRMSG+26+1(R1)      -> WHERE ENDING QUOTE GOES\n         MVI   0(R1),C''''              PUT IT IN\nLD$NOPE3 MVC   QDPROMPT,QFINDCMD        AND PROMPT WITH WHOLE FIND CMD\n         QTILT *,OPTIONS=REPROMPT\nLD$NOPEM MVC   QERRMSG+26(*-*),QPFIND   << EXECUTED >>\nLD$EMPTY MVC   QDHLINE,QBLANK           CLEAR THE MSG AREA\n         MVC   QDHLINE(11),=C'*** DATASET'\n         MVC   QDHLINE+12(8),QDHDSID    SHOW THE DSID\n         MVC   QDHLINE+21(12),=C'IS EMPTY ***'\n**LDW**  XC    QPDSID,QPDSID            MAKE USER SPECIFY A NEW DATASET\n**LDW**  NI    QFLAG2,255-Q2VALIDS      NULLIFY VALIDITY FOR LISTDS\n         QCALL DISP80\n         B     QSTOP\nLD$MVC   MVC   QDMSG(*-*),0(R10)        << EXECUTED >>\nLD$MVCSL MVC   LD@SLREC+1(*-*),3(R10)   << EXECUTED >>\nLD$TR    TR    QDMSG(*-*),0(R1)         << EXECUTED >>\n***********************************************************************\n*                                                                     *\n*   BOTTOM OF DATASET                                                 *\n*                                                                     *\n***********************************************************************\nLD$BOTTM XR    R4,R4                    zero\n         BCTR  R4,0                     negative\n         QCALL GETREC                   get last record in dataset\n         TM    QCRFLAG,QRFERR           any error reading blk?\n         BO    LD$RERR                  YES - handle it\n         ZAP   QPREC,QCHREC             LAST RECORD NUMBER\n         MVI   QCODE,0                  AVOID A LOOP\n         TM    QISFLAG1,QIS1ISPF        are we in ISPF?\n         BO    LSDSCKEF                 yes - return last record\n         LA    R1,QTPAGE                ASSUME COLUMN INDICATOR OFF\n         TM    QFLAG2,Q2COLIND          ON?\n         BNO   *+8                      NO - OK\n         LA    R1,QTPAGEX               YES - USE ALTERNATE NUMBER\n         SP    QPREC,0(L'QTPAGE,R1)     POINT TO TOP OF \"BOTTOM PAGE\"\n         AP    QPREC,=P'2'              FUDGE FACTOR\n         BNP   LD$TOP                   go to top if not positive\n         B     LD$SETR                  go to record\n***********************************************************************\n*                                                                     *\n*   REPOSITION TO REQUESTED RECORD NUMBER                             *\n*                                                                     *\n***********************************************************************\nLD$LAST  OI    LD@FLAGS,LD@MORE         restore saved position\n         SPACE 1\nLD$REPOS CLI   QCODE,64                 page command?\n         BE    LD$SETR                  yes, do it\n         CP    QPREC,=P'9999999'        is req for bottom.\n         BE    LD$BOTTM                 YES. GO FROM HI.\n         CP    QPREC,=P'1'              IS REQ FOR TOP OF DATASET?\n         BNH   LD$TOP                   YES, DO IT.\nLD$SETR  XR    R4,R4                    R4 negative tells GETREC to ...\n         BCTR  R4,0                     ... start at rec nbr in QPREC\n         QCALL GETREC                   get record to set page/line no\n         TM    QCRFLAG,QRFERR           any error reading blk?\n         BO    LD$RERR                  YES - handle it\n         LTR   R4,R4                    any record exists?\n         BZ    LD$END                   no - end of data\n         CLI   QCODE,64                 \"PAGE\"\n         BNE   *+8                      no, continue\n         MVI   QCODE,0                  reset\n         ZAP   QPREC,QCCREC             update starting record no\n         ZAP   QPPAGE,QCCPAGE           set to current page\n         ZAP   QPLINE,QCCLINE           set to current line (cc)\n         ZAP   QPLINEA,QCCLINEA         set to current line (abs)\n         BAL   R14,LD$HEAD              insert headings\n         XR    R4,R4                    zero\n         BCTR  R4,0                     SPECIFIC REC NO\n         B     LD$NXREC                 GO TO IT.\n          AIF   (&LD#DBG).LDJUNK3  %%%  if dbg, need the addressibility\n***********************************************************************\n*                                                                     *\n**       POINT AT IOB AND SET RESIDUAL LENGTH IN IOB                  *\n*                                                                     *\n***********************************************************************\nSETIOB   L     R8,4(,R13)               GET ORIG R13\n         L     R8,12+4+4+4(,R8)         GET DECB ADDRESS (ORIG R1)\n         USNGX DECSDECB,R8              SETUP ADDRESSABILITY FOR DECB\n         L     R1,DECAREA               POINT AT BUFFER\n         LA    R15,256                  SET BUFFER LENGTH\n         SH    R15,0(,R1)               GET RESIDUAL LENGTH\n         LA    R1,BRWIOB                POINT AT IOB\n         ST    R1,DECIOBPT              SAVE POINTER\n         STH   R15,14(,R1)              SET RESIDUAL COUNT\n         B     LSDSCKXT                 ALL DONE\n         DROPX R8\n.LDJUNK3  ANOP                          %%%%%\n***********************************************************************\n*                                                                     *\n**       SIGNAL EOF SINCE BEYOND LAST LINE TO BROWSE                  *\n*                                                                     *\n***********************************************************************\nLSDSCKEF L     R8,4(,R13)               GET ORIG R13\n         L     R8,12+4+4+4(,R8)         GET DECB ADDRESS (ORIG R1)\n         TM    QISFLAG1,QIS1V23         IS THIS ISPF V2.3?\n         BZ    QISPF22B                 NOPE - SKIP 2.3 CODE\n*\n**       FOR BRIF (ISPF V2.3) INTERFACE, RETURN MAX RECORD\n**       NUMBER AND A RETURN CODE OF 8.  If running under ISPF V3R2,\n**       set return code 4 instead to indicate temporary EOF.  If using\n**       EDIF, set a return code of 8.  BRIF doesn't support rc=4.\n*\n         OI    QMISCFLG,QMFRMAX         set need to reset max\n         ZAP   QNUMWORK,QCHREC          GET CURRENT (MAX) RECORD\n         CVB   R1,QNUMWORK              MAKE IT BINARY\n         L     R15,8(,R8)               GET VARIABLE ADDRESS\n         ST    R1,0(,R15)               SET MAXIMUM RECORD NUMBER\n         LA    R15,LD@BUF               POINT TO MY BUFFER\n         L     R2,0(,R8)                GET ADDRESS OF VARIABLE\n         ST    R15,0(,R2)               SAVE ADDRESS\n         L     R2,4(,R8)                GET ADDRESS OF VARIABLE\n         ST    R7,0(,R2)                SAVE LENGTH OF LAST RECORD\n         L     R15,4(,R13)              GET ORIGINAL SAVE AREA\n         TM    QSCFLAG3,QSC3EDIT        using EDIF?\n         BNZ   LD$EDRC8                 yes - set rc=8 for EOF\n         MVC   12+4(4,R15),=F'4'        set \"temporary EOF\" rc\n         TM    QISFLAG1,QIS1V32         IS THIS ISPF V3.2?\n         BNZ   LSDSCKXT                 yes - quit\nLD$EDRC8 MVC   12+4(4,R15),=F'8'        SET 'MAX REACHED' RETURN CODE\n         B     LSDSCKXT                 AND QUIT\n*\n**       FOR ISPF V1.X -> V2.2 USING THE DCB INTERFACE\n**       SETUP SO THE THE DCBEODAD ADDRESS IS CALLED\n**       ON RETURN\n*\n         USNGX DECSDECB,R8              SETUP ADDRESSABILITY FOR DECB\nQISPF22B L     R1,DECDCBAD              POINT AT DCB\n         L     R1,DCBEODAD-IHADCB(,R1)  GET EOD ADDR\n         L     R15,4(,R13)              GET OLD SAVEAREA POINTER\n         ST    R1,12(,R15)              SAVE RETURN ADDRESS\n         DROPX R8\n***********************************************************************\n*                                                                     *\n**       EXIT FROM CHECK                                              *\n*                                                                     *\n***********************************************************************\nLSDSCKXT L     R13,4(,R13)              GET OLD SAVEAREA POINTER\n         LM    R14,R12,12(R13)          RESTORE REGISTER\nLSDSCKND BR    R14                      exit\n***********************************************************************\n*                                                                     *\n*   FIND MATCHING RECORD ROUTINE                                      *\n*                                                                     *\n***********************************************************************\nLD$FIND  LH    R3,QPLNG                 LENGTH-1 OF COMPARE\n         LR    R15,R6                   GET RECORD LENGTH\n         BCTR  R15,0                    -1 FOR EX\n         EX    R15,LD$COPY              COPY RECORD TO WORK AREA\n         OC    LD@REC(132),QBLANK       UPPER CASE FIRST PART\n         OC    LD@REC+132(132),QBLANK   DITTO SECOND PART\n         LR    R14,R6                   LENGTH OF RECORD\n         SR    R14,R3                   NUMBER OF COMPARES\n         BNP   LD$NXREC                 RECORD IS TOO SMALL. SKIP IT.\n         LA    R15,LD@REC               FIRST BYTE OF RECORD\n         CLC   QOFFE,=H'0'              END RANGE FOR FIND SPECIFIED ?\n         BE    LD$FLOOP                 NO. BYPASS RANGE FOR FIND\n         AH    R15,QOFFS                YES. START ADDR FOR FIND\n         LH    R14,QOFFE                END ADDR FOR FIND\n         SH    R14,QOFFS                VALID RANGE ?\n         BP    LD$FLOOP                 YES. CONTINUE PROCESSING\n         EX    0,*                      %%% CHECKED IN \"REPOS\" %%%\n         QTILT '*** ERROR IN COLUMN SPECIFICATION ***'\nLD$FLOOP EX    R3,LD$CLC                DOES FIND DATA MATCH THE REC?\n         BE    LD$MATCH                 YES. DISCONTINUE SEARCH.\n         LA    R15,1(,R15)              INCREMENT TO NEXT BYTE\n         BCT   R14,LD$FLOOP             TRY NEXT BYTE\n         B     LD$NXREC                 SKIP THE RECORD. NO MATCH.\nLD$MATCH OI    LD@FLAGS,LD@FOUND        REMEMBER WE FOUND A MATCH\n         TM    LD@FLAGS,LD@FPREC        been here yet?\n         BO    LD$FALL                  yes, don't fall through\n         OI    LD@FLAGS,LD@FPREC        now been here\n         ZAP   QPREC,QCCREC             UPDATE THE REPOSITION NUMBER\n         ZAP   QPPAGE,QCCPAGE           set to current page\n         ZAP   QPLINE,QCCLINE           set to current line (cc)\n         ZAP   QPLINEA,QCCLINEA         set to current line (abs)\n         CLI   QSUBNAME+1,C'A'          IS THE REQUEST FOR A FINDALL?\n         BE    LD$FALL                  YES. DO NOT DISABLE SEARCH.\n         MVI   QCODE,0                  END THE SEARCH\nLD$FALL  BAL   R14,LD$HEAD              insert heading\n         B     LD$FIOFF                 CONTINUE\nLD$COPY  MVC   LD@REC(*-*),3(R4)        << EXECUTED >>\nLD$CLC   CLC   QPFIND(*-*),0(R15)       << EXECUTED >>\n***********************************************************************\n*                                                                     *\n*   FIND THE RECORD WHICH IS GREATER THAN OR EQUAL TO TIME            *\n*                                                                     *\n***********************************************************************\nLD$FTIME CLI   7(R4),C' '               old format syslog?\n         BNE   LD$FTXA                  no, must be new format\n         CLI   10(R4),C'.'              contain time?\n         BE    LD$FT370                 yes, do it\n         B     LD$NXREC                 no, skip it.\nLD$FTXA  CLI   27+3(R4),C':'            does this record have time?\n         BNE   LD$NXREC                 no, skip it.\n         CLI   30+3(R4),C':'            make sure enough time left\n         BNE   LD$NXREC                 no, skip it.\n         MVI   QPARM1+2,C':'            force correct syntax\n         CLI   QPARM1+5,C' '            any value here?\n         BE    *+8                      no, skip update\n         MVI   QPARM1+5,C':'            force correct syntax\n         CLC   QPARM1,28(R4)            is this the time we want?\n         BH    LD$NXREC                 no. skip it.\n         B     LD$MATCH                 end the search\nLD$FT370 CLI   13(R4),C'.'              does this record have time?\n         BNE   LD$NXREC                 NO. SKIP IT.\n         MVI   QPARM1+2,C'.'            force correct syntax\n         CLI   QPARM1+5,C' '            any value here?\n         BE    *+8                      no, skip update\n         MVI   QPARM1+5,C'.'            force correct syntax\n         CLC   QPARM1,8(R4)             IS THIS THE TIME WE WANT?\n         BH    LD$NXREC                 NO. SKIP IT.\n         B     LD$MATCH                 END THE SEARCH\n***********************************************************************\n*                                                                     *\n*   SET PAGE HEADING                                                  *\n*                                                                     *\n***********************************************************************\nLD$HEAD  TM    QISFLAG1,QIS1ISPF        are we in ISPF?\n         LR    R2,R14                   %%%%%\n         BZ    LD$HEAD1                 no - go build header\n          AIF   (NOT &LD#DBG).LDNDBG1   %%%%%\n         TPUTX '>>> LD$HEAD (QDHLINE follows)'  %%%%%\n         TPUTX QDHLINE,L'QDHLINE        %%%%%\n         LR    R14,R2                   %%%%%\n.LDNDBG1  ANOP                          %%%%%\n         CLI   QBRIFHDR,C'R'            need to build header?\n         BNER  R14                      no - do it once per screen\n         MVI   QBRIFHDR,C' '            reset the flag\nLD$HEAD1 DS    0H                       %%%%%%\n          AIF   (NOT &LD#DBG).LDNDBG2   %%%%%\n         TPUTX '>>> LD$HEAD - build'    %%%%%\n         LR    R14,R2                   %%%%%\n.LDNDBG2  ANOP                          %%%%%\n         MVC   QDHLINE(L'LDHMLINE),LDHMLINE  MOVE IN HEADER LINE\n         OI    QFLAG1,Q1MVHDR           REQUEST \"MOVE HEADER\"\n         MVC   LDHDSID,QDHDSID          AND FILL IN DSID\n         LH    R1,QPOFFSET              GET CURRENT COLUMN NUMBER\n         LA    R1,1(,R1)                IT'S ORIGIN 0\n         CVD   R1,QNUMWORK\n         OI    QNUMWORK+7,X'0F'         REMOVE SIGN\n         UNPK  LDHCOL,QNUMWORK          PUT COLUMN NUMBER IN HEADER\n          AIF  (&QLEVEL LT 5).LD090\n         MVI   LD@STPST,C'X'            stopper for bctr loop\n         MVC   LD@STPDD,QBLANK          clear field\n         MVC   LD@STPDD(8),QSTEPNAM     set stepname\n         LA    R15,LD@STPDD+7           -> last char\nLD$HBLP  CLI   0(R15),C' '              blank?\n         BNE   *+8                      no, done\n         BCT   R15,LD$HBLP              yes, try prev\n         MVI   1(R15),C'/'              delimeter\n         MVC   2(8,R15),QDDNAME         and ddname\n         CLC   =C'/ ',LD@STPDD          just a separator?\n         BNE   *+8                      no, leave it\n         MVI   LD@STPDD,C' '            yes, clear it\n         L     R1,=A(CHARTAB)           get table address\n         TR    LD@STPDD,0(R1)           translate to printable\n         MVC   LDHSTPDD,LD@STPDD        copy to print area\n.LD090    ANOP ,\n         MVC   LD@EDITW,LD#EDIT         prepare for edit\n         LA    R1,LD@EDIT+7             -> end of field\n         EDMK  LD@EDIT,QPREC            edit record no.\n         MVC   LDHREC,0(R1)             move in record number\n          AIF   (NOT &LD#DBG).LDNDBG3   %%%%%\n         TPUTX 'QPREC=',ASIS            %%%%%\n         TPUTX LDHREC,L'LDHREC          %%%%%\n.LDNDBG3  ANOP                          %%%%%\n         MVC   LD@EDITW,LD#EDIT\n         LA    R1,LD@EDIT+7             -> end of field\n         EDMK  LD@EDIT,QPPAGE           and page\n         MVC   LDHPAGEN,0(R1)           move in page number\n          AIF   (NOT &LD#DBG).LDNDBG4   %%%%%\n         TPUTX 'QPPAGE=',ASIS           %%%%%\n         TPUTX LDHPAGEN,L'LDHPAGEN      %%%%%\n.LDNDBG4  ANOP                          %%%%%\n         LA    R15,QPLINE               cc  line\n         TM    QMODE1,QM1PAGE\n         BNZ   *+4+4\n         LA    R15,QPLINEA              abs line\n         MVC   LD@EDITW,QBLANK          clear field\n         MVC   LD@EDIT(4),=X'40202120'  set edit mask\n         LA    R1,LD@EDIT+3             -> end of field\n         EDMK  LD@EDIT(4),0(R15)        edit number\n         MVC   LDHLINEN,0(R1)           insert it\n          AIF   (NOT &LD#DBG).LDNDBG5   %%%%%\n         TPUTX 'QPLINE=',ASIS           %%%%%\n         TPUTX LDHLINEN,L'LDHLINEN      %%%%%\n         TPUTX QDHLINE,L'QDHLINE        %%%%%\n.LDNDBG5  ANOP                          %%%%%\n         TM    QISFLAG1,QIS1ISPF        Are we in ISPF?\n         BZR   R14                      no - just return\n         MVC   QDHLINE(LDHPAGEL),LDHPAGET  shift page and line nbr\n         MVC   QDHLINE+LDHPAGEL(L'QDHLINE-LDHPAGEL),QBLANK  clear rest\n          AIF   (NOT &LD#DBG).LDNDBG6   %%%%%\n         TPUTX QDHLINE,L'QDHLINE        %%%%%\n         LR    R14,R2                   %%%%%\n.LDNDBG6  ANOP                          %%%%%\n         BR    R14                      and return\n         EJECT\n***********************************************************************\n*                                                                     *\n*   MISCELLANY                                                        *\n*                                                                     *\n***********************************************************************\n         LTORG ,\nLD#EDIT  DC    X'4020202020202120',CL8' '\nLDHMLINE DC    CL80' '\n         ORG   LDHMLINE\n          AIF  (&QLEVEL LT 5).LD100\n         DC    C'ssssssss/dddddddd',C' '\n.LD100    ANOP ,\n         DC    C'DSID xxxxxxxx  Col nnn '\n         DC    C'Rec xxxxxxxx '\nLDHLPAGE DC    C'Page xxxxxxxx Line xxx'\n         ORG   ,\n         SPACE 2\nLD#SLTXA DC    75AL1(56+*-LD#SLTXA)\nLD#SLT37 DC    106AL1(24+*-LD#SLT37)\n         SPACE 2\n         PUSH  USING\n         DROP  ,\n         EJECT\n***********************************************************************\n*                                                                     *\n*        READ MACRO CODE                                              *\n*                                                                     *\n*        INPUT                                                        *\n*              R1  -->  DECB                                          *\n*                                                                     *\n***********************************************************************\nLSDSREAD DS    0H\n*\n**       DO NOTHING HERE, LEAVE ALL WORK FOR\n**       CHECK ROUTINE\n*\n         BR    R14\n         EJECT\n***********************************************************************\n*                                                                     *\n*        POINT/NOTE MACRO CODE                                        *\n*                                                                     *\n*        INPUT                                                        *\n*              R1  -->  DCB                                           *\n*              R0  -->  TTRN IF POINT ENTRY (+4)                      *\n*                                                                     *\n*        OUTPUT                                                       *\n*              R1  ===  TTRN IF NOTE ENTRY (+0)                       *\n*                                                                     *\n*                                                                     *\n***********************************************************************\n         USING LSDSPNT,R15              SETUP TEMP ADDRESSABILITY\nLSDSPNT  DS    0H\n         B     LSDSNOT                  +0 ENTRY IS NOTE SO HANDLE\n*                                       +4 ENTRY IS POINT\n         DROP  R15\n*\n**       DO POINT\n**             FOR US THE TTR IS REALLY THE RELATIVE RECORD\n**             NUMBER OF THE LINE IN THE SPOOL FILE.\n**             SO JUST CONVERT IT AND SAVE IT IN QPREC.\n*\n         STM   R14,R12,12(R13)          SAVE REGISTERS\n         LR    R12,R15                  SETUP BASE REGISTER\n         USING LSDSPNT,R12              SETUP ADDRESSABILITY\n         LR    R5,R1                    SAVE DCB POINTER\n         USING IHADCB,R5                SETUP ADDRESSABILITY\n         L     R11,DCBDEBAD             POINT AT COMMON VECTOR TABLE\n         USING QCOMMON,R11              SETUP ADDRESSABILITY\n         LR    R15,R0                   MOVE POINTER\n         L     R1,0(,R15)               GET THE TTRN\n         SRL   R1,8                     GET TTR (REALLY REC #)\n         CVD   R1,QNUMWORK              CONVERT IT\n         ZAP   QPREC,QNUMWORK           SET DESIRED RECORD #\n         LM    R14,R12,12(R13)          RESTORE REGISTERS\n         SR    R15,R15                  SET RETURN CODE\n         BR    R14                      exit\n         DROP  ,                        KILL ADDRESSABILITY\n         SPACE 3\n*\n**       DO NOTE\n**             IN THIS CASE RETURN THE CURRENT RECORD NUMBER\n**             AS THE TTR.  BROWSE IS SO DEVICE INDEPENDENT\n**             HE'LL NEVER NOTICE.\n*\nLSDSNOT  STM   R14,R12,12(R13)          SAVE REGISTERS\n         LR    R12,R15                  SETUP BASE REGISTER\n         USING LSDSPNT,R12              SETUP ADDRESSABILITY\n         LR    R5,R1                    SAVE DCB POINTER\n         USING IHADCB,R5                SETUP ADDRESSABILITY\n         L     R11,DCBDEBAD             POINT AT COMMON VECTOR TABLE\n         USING QCOMMON,R11              SETUP ADDRESSABILITY\n         ZAP   QNUMWORK,QCCREC          GET CURRENT RECORD #\n         CVB   R1,QNUMWORK              MAKE IT BINARY\n         SLL   R1,8                     MAKE LOOK LIKE TTRN\nLSDSNOTX ST    R1,12+4+4+4(R13)         SAVE VALUE\n         LM    R14,R12,12(R13)          RESTORE REGISTERS\n         SR    R15,R15                  CLEAR RETURN CODE\n         BR    R14                      exit\n         DROP  ,\n         EJECT\n***********************************************************************\n*                                                                     *\n*        ISPF V2.3 BROWSE INTERFACE READ ROUTINE                      *\n*                                                                     *\n*        INPUT                                                        *\n*     R1  -->  +0  -->  F'0'  -  TO BE SET TO POINT AT DATA LINE      *\n*              +4  -->  F'0'  -  TO BE SET TO LENGTH OF LINE          *\n*              +8  -->  F'L'  -  THE REQUESTED LINE NUMBER            *\n*              +12 -->  A(QCOMMON) - ADDRESS PASSED FROM BRIF         *\n*                                                                     *\n***********************************************************************\nISPF23RD STM   R14,R12,12(R13)          SAVE REGISTERS\n         LR    R12,R15                  SETUP BASE REGISTER\n         USING ISPF23RD,R12             SETUP ADDRESSABILITY\n         LR    R8,R1                    SAVE PARM LIST POINTER\n         L     R11,12(,R8)              POINT AT COMMON VECTOR TABLE\n         L     R11,0(,R11)              POINT AT COMMON VECTOR TABLE\n         USING QCOMMON,R11              SETUP ADDRESSABILITY   **ORIG**\n         LR    R15,R13                  SAVE OLD SAVE AREA\n         L     R13,BRWSAVE              GET SAVE AREA ON INPUT\n         AH    R13,2(,R13)              ** see QCALL code in QCOMMON **\n         ST    R15,4(,R13)              SAVE OLD POINTER\n         ST    R13,8(,R15)              SAVE NEW POINTER\n         USING WORK,R13                 SETUP ADDRESSABILITY   **ORIG**\n         L     R2,QCCPTR                SET TO CURRENT TABLE POINTER\n         L     R1,8(,R8)                GET DESIRED RECORD NUMBER\n         L     R1,0(,R1)                GET DESIRED RECORD NUMBER\n         CVD   R1,QNUMWORK              GET IT IN DECIMAL\n         ZAP   QPREC,QNUMWORK           SET DESIRED RECORD NUMBER\n          AIF   (NOT &LD#DBG).LDNDBG7   %%%%%\n         TPUTX '>>> ISPF23RD  desired record number =',ASIS    %%%%%%\n         UNPK  QNUMWORK,QPREC           %%%%%\n         OI    QNUMWORK+7,C'0'          %%%%%\n         TPUTX QNUMWORK,8               %%%%%\n.LDNDBG7  ANOP                          %%%%%\n*---  The )PROC section of the panel sets QBRIFHDR to 'R' to\n*---  indicate that it should be rebuilt for the next panel display.\n*---  This way it contains info describing the top line of the display.\n         TM    QISFLAG1,QIS1V32         running under ISPF V3.2?\n         BNZ   I23RD$RP                 yes - skip this kludge\n         TM    QMISCFLG,QMFRMAX         need to reset max ind?\n         BZ    I23RD$RP                 no so go and use main\n         L     R1,4(,R13)               get prev r13 (entry here)\n         L     R1,4(,R1)                get r13 on entry to bird\n         L     R1,12+12(,R1)            get r1 on entry to bird\n         L     R1,4(,R1)                get browse parm list\n         MVC   X'68'(4,R1),=F'100000000'  set max number\n         NI    X'24D'(R1),255-X'20'     turn off max set\n         NI    QMISCFLG,255-QMFRMAX     reset indicator\n*\nI23RD$RP DC    0H'0'\n         L     R9,=A(LISTDS+4096)       and second base\n         L     R12,=A(LISTDS)           GET ORIG BASE ADDR\n         B     LD$REPOS-LISTDS(,R12)    GO AND REPOSITION\n         EJECT\n         DROP  ,\n***********************************************************************\n*                                                                     *\n*        CHECK MACRO CODE - USED BY ISPF V1.X -> V2.2                 *\n*                                                                     *\n*        INPUT                                                        *\n*              R1  -->  DECB                                          *\n*                                                                     *\n***********************************************************************\nLSDSCHCK STM   R14,R12,12(R13)          SAVE REGISTERS\n         LR    R12,R15                  SETUP BASE REGISTER\n         USING LSDSCHCK,R12             SETUP ADDRESSABILITY\n         LR    R8,R1                    SAVE DECB POINTER\n         USING DECSDECB,R8              SETUP ADDRESSABILITY\n         MVI   DECSDECB,X'7F'           POST IT\n         L     R15,DECDCBAD             POINT AT DCB\n         L     R11,DCBDEBAD-IHADCB(,R15)  POINT AT COMMON VECTOR TABLE\n         DROP  R8\n         USING QCOMMON,R11              SETUP ADDRESSABILITY   **ORIG**\n         USING WORK,R13                 SETUP ADDRESSABILITY   **ORIG**\n         LR    R15,R13                  SAVE OLD SAVE AREA\n         L     R13,BRWSAVE              GET SAVE AREA ON INPUT\n         AH    R13,2(,R13)              ** see QCALL code in QCOMMON **\n         ST    R15,4(,R13)              SAVE OLD POINTER\n         ST    R13,8(,R15)              SAVE NEW POINTER\n         L     R2,QCCPTR                SET TO CURRENT TABLE POINTER\n***********************************************************************\n*                                                                     *\n*   RESET EOF INDICATOR SO MAX WILL ALWAYS FIND NEW END               *\n*                                                                     *\n***********************************************************************\n         L     R1,BRWCBTP               GET COMMON BROWSE TABLE\n         TM    QISFLAG1,QIS1V2          IS THIS ISPF VERSION 2?\n         BNO   NOTIS2                   no - SKIP V2 CODE\n         NI    589(R1),X'DF'            SET EOF INDICATOR OFF *      *\n         MVC   104(4,R1),=F'100000000'  SET ORIG RECORD COUNT\n         B     DNIS2                    SKIP VERSION 1 CODE\n         SPACE 2\nNOTIS2   NI    621(R1),X'DF'            SET EOF INIDCATOR OFF\n         MVC   140(4,R1),=F'100000000'  SET ORIG RECORD COUNT\n         SPACE 2\nDNIS2    L     R9,=A(LISTDS+4096)       and second base\n         L     R12,=A(LISTDS)           GET ORIG BASE ADDR\n         B     LD$REPOS-LISTDS(,R12)    GO AND REPOSITION\n***********************************************************************\n*                                                                     *\n*   EDIF read routine                                                 *\n*                                                                     *\n*        INPUT                                                        *\n*     R1  -->  +0  -->  F'0'  -  TO BE SET TO POINT AT DATA LINE      *\n*              +4  -->  F'0'  -  TO BE SET TO LENGTH OF LINE          *\n*              +8  -->  F'c'  -  request code:  0=next rec, 1=first   *\n*              +12 -->  A(QCOMMON) - ADDRESS PASSED FROM EDIF         *\n*                                                                     *\n***********************************************************************\nLD$ED$RD STM   R14,R12,12(R13)          SAVE REGISTERS\n         LR    R12,R15                  copy base register\n         USING LD$ED$RD,R12             SETUP ADDRESSABILITY\n         LR    R8,R1                    SAVE PARM LIST POINTER\n         L     R11,12(,R8)              POINT AT COMMON VECTOR TABLE\n         L     R11,0(,R11)              POINT AT COMMON VECTOR TABLE\n         USING QCOMMON,R11              SETUP ADDRESSABILITY   **ORIG**\n         LR    R15,R13                  SAVE OLD SAVE AREA\n         L     R13,BRWSAVE              GET SAVE AREA ON INPUT\n         AH    R13,2(,R13)              ** see QCALL code in QCOMMON **\n         ST    R15,4(,R13)              SAVE OLD POINTER\n         ST    R13,8(,R15)              SAVE NEW POINTER\n         USING WORK,R13                 SETUP ADDRESSABILITY   **ORIG**\n         L     R2,QCCPTR                SET TO CURRENT TABLE POINTER\n         L     R1,8(,R8)                -> request code\n         L     R1,0(,R1)                GET DESIRED RECORD NUMBER\n         LTR   R1,R1                    is it a \"next rec\" request?\n         BZ    *+10                     yes - continue\n         ZAP   QPREC,=P'0'              no - set to first rec\n         AP    QPREC,=P'1'              increment record number\n          AIF   (NOT &LD#DBG).LDNDBG8   %%%%%\n         TPUTX '>>> LD$ED$RD  desired record number =',ASIS    %%%%%%\n         UNPK  QNUMWORK,QPREC           %%%%%\n         OI    QNUMWORK+7,C'0'          %%%%%\n         TPUTX QNUMWORK,8               %%%%%\n.LDNDBG8  ANOP                          %%%%%\n         L     R9,=A(LISTDS+4096)       and second base\n         L     R12,=A(LISTDS)           GET ORIG BASE ADDR\n         B     LD$REPOS-LISTDS(,R12)    and go do it\n***********************************************************************\n*                                                                     *\n*   EDIF write routine                                                *\n*                                                                     *\n***********************************************************************\nLD$ED$WR SR    R15,R15                  pretend that it worked\n         BR    R14                      and just return\n*%%%  Future??  setmsg 'no can do' and rc=16\n         POP   USING\n***********************************************************************\n*                                                                     *\n*   MISCELLANY                                                        *\n*                                                                     *\n***********************************************************************\n* TABLE OF PRINTABLE CHARACTERS\n         ENTRY CHARTAB\nCHARTAB  DC    256C'?'                  TRANSLATE ALL GARBAGE TO '?'\n*LDW*    ORG   CHARTAB+X'00'            funny blanks\n*LDW*    DC    C' '\n         ORG   CHARTAB+C' '             BLANK\n         DC    C' '\n         ORG   CHARTAB+C'\u00a2'             CENT\n         DC    C'\u00a2.<(+|&&'\n         ORG   CHARTAB+C'!'             EXCLAMATION\n         DC    C'!$*);\u00ac-/'\n         ORG   CHARTAB+C'\u00a6'             BROKEN BAR\n         DC    C'\u00a6,%_>?'\n         ORG   CHARTAB+C'`'             ACCENT GRAVE\n         DC    C'`:#@''=\"'\n         ORG   CHARTAB+C'A'-X'40'\n         DC    X'818283848586878889'\n         ORG   CHARTAB+C'J'-X'40'\n         DC    X'919293949596979899'\n         ORG   CHARTAB+C'S'-X'40'\n         DC    X'A2A3A4A5A6A7A8A9'\n         ORG   CHARTAB+X'AD'            left square bracket\n         DC    X'AD'\n         ORG   CHARTAB+X'BD'            right square bracket\n         DC    X'BD'\n         ORG   CHARTAB+C'A'\n         DC    C'ABCDEFGHI'\n         ORG   CHARTAB+C'J'\n         DC    C'JKLMNOPQR'\n         ORG   CHARTAB+C'S'\n         DC    C'STUVWXYZ'\n         ORG   CHARTAB+C'0'\n         DC    C'0123456789'\n         ORG   CHARTAB+C'{'             LEFT BRACE\n         DC    C'{'\n         ORG   CHARTAB+C'}'             RIGHT BRACE\n         DC    C'}'\n         ORG   CHARTAB+C'~'             TILDE\n         DC    C'~'\n         ORG   CHARTAB+C'\\'             BACKSLASH\n         DC    C'\\'\n         ORG   ,\n         SPACE 3\n***********************************************************************\n*                                                                     *\n*        ISPF V3.2 BROWSE INTERFACE COMMAND ROUTINE                   *\n*                                                                     *\n*        INPUT (Only when invoked under ISPF V3R2)                    *\n*     R1  -->  +0  -->  F'10' - Recursive Browse                      *\n*                  -->  F'20' - A command not recognized by Browse    *\n*              +4  -->  A(QCOMMON) - Address passed from BRIF         *\n*                                    (This is not documented except   *\n*                                     in the Cobarf example.)         *\n*                                                                     *\n***********************************************************************\nLD$BRIFC STM   R14,R12,12(R13)          SAVE REGISTERS\n         LR    R12,R15                  SETUP BASE REGISTER\n         USING LD$BRIFC,R12             SETUP ADDRESSABILITY\n         L     R15,4(,R1)               -> second parm\n         L     R11,0(,R15)              get second parm (@ QCOMMON)\n         USING QCOMMON,R11              SETUP ADDRESSABILITY   **ORIG**\n         LR    R15,R13                  SAVE OLD SAVE AREA\n         L     R13,BRWSAVE              GET SAVE AREA ON INPUT\n         AH    R13,2(,R13)              ** see QCALL code in QCOMMON **\n         ST    R15,4(,R13)              SAVE OLD POINTER\n         ST    R13,8(,R15)              SAVE NEW POINTER\n         USING WORK,R13                 SETUP ADDRESSABILITY   **ORIG**\n         TM    QISFLAG1,QIS1V32         running under ISPF V3.2?\n         BZ    LD$BRIF4                 no - just return\n         L     R15,0(,R1)               -> first parm\n         CLC   =F'20',0(R15)            is it \"cmd not recognized\"?\n         BE    LD$BRCMD                 yes - go process it\n*---  Must be recursive browse\n*\nLD$BRIF4 L     R13,4(,R13)              dechain save areas\n         RETURN  (14,12),RC=4           tell ISPF/PDF to process\n*\n*\n*---  Copy the command from ZCMD\nLD$BRCMD LA    R0,QDREPLYL              maximum length\n         ST    R0,LD@VLEN               set for VCOPY\n         L     R15,ISPLNK\n         CALL  (15),(=CL8'VCOPY',=CL8'ZCMD',LD@VLEN,QDREPLY,           $\n               =CL8'MOVE'),VL,                                         $\n               MF=(E,LD@CALLP)\n         L     R0,LD@VLEN               GET LENGTH OF REPLY\n         STH   R0,QDRLNG                STORE LENGTH OF REPLY\n         L     R1,BRWSAVE               -> LISTDS's work area\n         OI    LD@FLAGS-WORK(R1),LD@BRCMD remember we have a new subcmd\n*---  Set ZCMD to END to cause browse to terminate\n         L     R15,ISPLNK               CALL ISPF INTERFACE\n         CALL  (15),(=C'VREPLACE',=C'(ZCMD) ',=F'3',=CL8'END'),        $\n               VL,MF=(E,LD@CALLP)\n*\n         L     R13,4(,R13)              dechain save areas\n         LM    R14,R12,12(R13)          restore browse's registers\n         SR    R0,R0                    set rc\n         BR    R14                      return to browse\n         SPACE 2\n         LTORG ,\n         SPACE 3\nWORK     DSECT\n         ORG   WORK+72                  SKIP OVER SAVE AREA\nLD@VLEN  DS    F                        length for VCOPY\nLD@BRLR  DS    F                        lrecl for BRIF\nLD@BRQC  DS    A                        -> QCOMMON for BRIF exits\nLD@CALLP DS    8A                       CALL MF=L area\nLD@FLAGS DS    B\nLD@SPIN  EQU   X'80'                    SPIN IOTS HAVE BEEN SEARCHED\nLD@NULL  EQU   X'40'                    MATCHING PDDB FOUND W/ PDB1NULL\nLD@FOUND EQU   X'20'                    MATCHING RECORD FOUND\nLD@MORE  EQU   X'10'                    hanging more msg\nLD@FPREC EQU   X'08'                    qprec has been set by find\nLD@BRCMD EQU   X'04'                    have subcmd when exiting BROWSE\nLD@BYTE1 DS    C                        FLAG BYTE OF RECORD\nLD@STPST DC    C'X'                     stopper char\nLD@STPDD DS    C'ssssssss/dddddddd'     stepname/ddname\nLD@EDITW DS    CL16                     edit and mark workarea\nLD@EDIT  EQU   LD@EDITW,8,C'C'          edit len\nLD@BUF   DS    CL256                    BROWSE buffer\nLD@WORKL EQU   *-WORK\nLD@SLREC DS    CL131                    workarea for syslog records\nLD@REC   DS    CL300\n         SPACE 3\n         DROPX R13                      WORK\n         SPACE 3\n         QCOMMON\n         ORG   QDHLINE\n          AIF  (&QLEVEL LT 5).LD110\nLDHSTPDD DC    C'ssssssss/dddddddd',C' '\n.LD110    ANOP ,\n         DS    C'DSID '\nLDHDSID  DS    CL8\n         DS    C'  Col '\nLDHCOL   DS    CL3,C\n         DS    C'Rec '\nLDHREC   DS    CL8\nLDHPAGET DS    C' Page '\nLDHPAGEN DS    CL8\n         DS    C' Line '\nLDHLINEN DS    CL4\nLDHPAGEL EQU   *-LDHPAGET\n         SPACE 3\n         Q$LRC\n         Q$PDDB\n         QZDCBD  ,\n         IHADECB ,\n         EJECT\n*\n**       DEFINE POINTERS IN TLD DSECT\n*\nTLD      DSECT\n         ORG   TLD+16\nISRRET   DS    F\n         ORG   TLD+52\nISPNM    DS    F\n         ORG   TLD+64\nISRNM    DS    F\n*\n**       DEFINE ACCESS LIST FOR ISP NAMES\n*****\n*****            FOR ISPF VERSION 2 THE OFFSET IS 4 TOO BIG\n*****            CODE HAS BEEN ADDED TO FIX THIS DYNAMICALLY\n*****\n*\nISPNAME  DSECT\n         ORG   ISPNAME+184\nISPCMSG  DS    F\n*\n**       DEFINE ACCESS LIST FOR ISR NAMES\n*****\n*****            FOR ISPF VERSION 2 THE OFFSET IS 4 TOO BIG\n*****            CODE HAS BEEN ADDED TO FIX THIS DYNAMICALLY\n*****\n*\nISRNAME  DSECT\n         ORG   ISRNAME+32\nISRCBC   DS    F\n         ORG   ISRNAME+48\nISRCBR   DS    F\n         ORG   ISRNAME+52\nISRCBS   DS    F\n*\n         INUSE ,\n         DROPX ,\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "Q#LI": {"ttr": 12550, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x11\\x00\\x00\\x00\\x82#/\\x00\\x91&_!%\\x014\\x00\\x80\\x00\\xdb\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "05.17", "flags": 0, "createdate": "1982-08-20T00:00:00", "modifydate": "1991-09-22T21:25:00", "lines": 308, "newlines": 128, "modlines": 219, "user": "LDW"}, "text": "         TITLE '--- QUEUE--LIST -- PRINT A DS FROM SPOOL BY ID ---'\n*---------------------------------------------------------------------*\n*                                                                     *\n*   List - Prepare to display a dataset from a job on spool           *\n*                                                                     *\n*   Entry - If subcommand is \"LIST\":                                  *\n*         - QPARM1 = jobid                                            *\n*         - QPARM2 = dsid                                             *\n*         - QPARM3 = print column (default of blank => column 1)      *\n*                                                                     *\n*   Updates:                                                          *\n*      22Sep91  LDW  Make jobid/dsid optional for LIST subcommand     *\n*                    Support EL/ELIST subcommand                      *\n*                    Support /EDIT operand of LIST, JLOG, JCL, JMSG   *\n*                    Add missing end of table indicator to NS#KEYS    *\n*      20Jun90  LDW  Fix for DSID > 9999                              *\n*      23Nov89  LDW  Remove unneeded Q$IOT, comment Q$PDDB usage      *\n*      26Apr89  EMS  Update for SP311                                 *\n*       8Jul87  EMS  Update to use GETPDDB routine                    *\n*      21Mar87  LDW  Fix bug                                          *\n*      25Jan87  LDW  Pass READSPC the JQE addr in case of CB ID error *\n*               LDW  Fix for SJ on job with no displayable datasets   *\n*      08/09/84 LDW  UPDATE FOR SP134 (USE IOTPDDB INSTEAD OF         *\n*                       QCPDDB1)                                      *\n*      04/11/84 LDW  JCTDSECT -> JCTSTART, IOTDSECT -> IOTSTART       *\n*      01/27/84 LDW  ADD 'PS' SUBCOMMAND, CHANGE 'NS' TO ALWAYS GO    *\n*                       FORWARD, ADD 'NS *' TO GO BACK/FORWARD        *\n*      01/25/84 LDW  FIX BUG IN 'NS TOP' AND 'NS BOTTOM'              *\n*      01/23/84 LDW  ADD SUPPORT FOR COMMAND STACKING                 *\n*                    ADD SUPPORT FOR 'NS' SUBCOMMAND                  *\n*                    USING/DROP -> USNGX/DROPX                        *\n*      03/02/83 LDW  CHANGE 'QTILT *' TO USE QERRMSG                  *\n*      12/15/82 LDW  PUT IN DIFFERENT QTILT IF COLUMN IS BAD          *\n*                    FIX BUG IN COLUMN NUMBER CONVERSION              *\n*      12/08/82 LDW  CHANGE FROM PRINT OFFSETS TO PRINT COLUMNS       *\n*                    SAVE OFFSET IN QPOFFDEF FOR \"C\" WITH NO OPERAND  *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 3\nLIST     QSTART  Q14,STACK=(X'30','REDISP')\n         CLI   QCODE,16                 'NS'?\n         BE    LIST$NS                  YES\n***********************************************************************\n*                                                                     *\n*  CALL FINDJOB TO LOCATE THE JQE, JCT, AND IOT, VALIDITY CHK ACCESS  *\n*                                                                     *\n***********************************************************************\n         QCALL FINDJOB                  FIND THE JOB\n***********************************************************************\n*                                                                     *\n*   DECODE SUBCOMMAND                                                 *\n*                                                                     *\n***********************************************************************\n         LH    R1,QCODEH\n         B     *+4(R1)\n         B     LISTANY                  0\n         B     LISTJCL                  4\n         B     LISTJLOG                 8\n         B     LISTJMSG                 12\n         EX    0,*                      16 (checked above)\n         B     LISTEDIT                 20\n***********************************************************************\n*                                                                     *\n*   LIST THE JCL FOR A JOB                                            *\n*                                                                     *\n***********************************************************************\n          AIF  (&QLEVEL GE 9).LI01\nLISTJCL  MVC   QPDSID,=H'3'             DSID OF DATASET TO BE PRINTED\n          AGO  .LI02\n.LI01     ANOP ,\nLISTJCL  MVC   QPDSID,=F'3'             dsid of dataset to be printed\n.LI02     ANOP ,\n         MVC   QDHDSID,=CL8'JCL'        SET DSID\n         LA    R15,3  **LDW**  WAS 11   PRINT COLUMN FOR EACH RECORD\n         B     L$CALL                   GO CALL LISTDS\n***********************************************************************\n*                                                                     *\n*   LIST THE JOBLOG MESSAGES FOR A JOB                                *\n*                                                                     *\n*                                                                     *\n*   DETERMINE IF JOB LOG IS AVAILABLE                                 *\n*                                                                     *\n***********************************************************************\nLISTJLOG MVI   QGPFLAG,QPFDIR+QPFNMSG   dir, no msg\n          AIF  (&QLEVEL GE 9).LI03\n         MVC   QPDSID,=H'2'             ask for joblog\n          AGO  .LI04\n.LI03     ANOP ,\n         MVC   QPDSID,=F'2'             ask for joblog\n.LI04     ANOP ,\n         QCALL GETPDDB                  Go find it\n         LTR   R2,R1                    check if we got it\n         BNZ   JLFOUND\n***      USNGX PDBDSECT,R2\n         QTILT '*** JOBLOG IS NOT AVAILABLE ***'\nJLFOUND  MVC   QDHDSID,=CL8'JOBLOG'     SET DSID\n         LA    R15,1                    PRINT COLUMN FOR EACH RECORD\n         B     L$CALL                   GO CALL LISTDS\n*JL$TILT2 QTILT '*** JOBLOG IS EMPTY ***'\n***********************************************************************\n*                                                                     *\n*   LIST THE SYSTEM MESSAGES FOR A JOB                                *\n*                                                                     *\n***********************************************************************\n          AIF  (&QLEVEL GE 9).LI05\nLISTJMSG MVC   QPDSID,=H'4'             DSID OF DATASET TO BE PRINTED\n          AGO  .LI06\n.LI05     ANOP ,\nLISTJMSG MVC   QPDSID,=F'4'             dsid of dataset to be printed\n.LI06     ANOP ,\n         MVC   QDHDSID,=CL8'JOBMSG'     SET DSID\n         LA    R15,1                    PRINT COLUMN FOR EACH RECORD\n         B     L$CALL                   GO CALL LISTDS\n***********************************************************************\n*                                                                     *\n*   CHECK AND CONVERT THE DATASET ID NUMBER FOR USER DSID             *\n*                                                                     *\n***********************************************************************\nLISTEDIT OI    QSCFLAG3,QSC3EDIT        indicate EDIF instead of BRIF\nLISTANY  LH    R1,QLNG2                 LENGTH OF DATASET ID FIELD\n         SH    R1,=H'1'                 DATASET ID FIELD ZERO LENGTH?\n***      BM    LI$TILT                  YES. QUIT.\n         BM    LI$NDSID                 yes - try to use prev selected\n         LA    R15,QPARM2               POINT TO PARM\n         BAL   R14,QNUMCONV             CONVERT IT\n         BNE   LI$TILT                  QUIT IF NOT NUMERIC\n         TM    QXAUTH,QXAUTHX           PRIVILEGED USER?\n         BNZ   LISTX                    YES - SKIP NEXT VALIDITY CHECK\n         CH    R15,=H'101'              DATASET ID LESS THAN 101?\n         BL    LI$TILT                  YES. TILT.\n          AIF  (&QLEVEL GE 9).LI07\nLISTX    STH   R15,QPDSID               STORE DATASET ID\n          AGO  .LI08\n.LI07     ANOP ,\nLISTX    STCM  R15,B'1111',QPDSID       STORE DATASET ID\n.LI08     ANOP ,\n         MVC   QDHDSID,QPARM2           SET DSID\n***********************************************************************\n*                                                                     *\n*   CHECK AND CONVERT THE PRINT COLUMN                                *\n*                                                                     *\n***********************************************************************\n         LA    R15,1                    DEFAULT TO ONE\n         LH    R1,QLNG3                 LENGTH OF COLUMN FIELD\n         SH    R1,=H'1'                 COLUMN FIELD ZERO LENGTH?\n         BM    L$CALL                   YES. USE COLUMN 1\n         LA    R15,QPARM3               POINT TO PARM\n         BAL   R14,QNUMCONV             CONVERT IT\n         BZ    L$CALL                   CONTINUE IF OK\nL$BADCOL QTILT '*** COLUMN NUMBER INVALID ***',OPTIONS=REPROMPT\nL$CALL   SH    R15,=H'1'                CONVERT COLUMN INTO OFFSET\n         BM    L$BADCOL                 ABORT IF NFG\n         STH   R15,QPOFFSET             STORE OFFSET\n         STH   R15,QPOFFDEF             STORE DEFAULT OFFSET\n         OI    QFLAG2,Q2VALIDS          INDICATE VALIDITY FOR LISTDS\n***********************************************************************\n*                                                                     *\n*   Set flag for EDIF if /EDIT keyword specified                      *\n*                                                                     *\n***********************************************************************\nLI$NDSID TM    QFLAG2,Q2VALIDS          have a valid dsid?\n         BZ    LI$TILT                  no - quit\n         CLI   QKEYWORD,C'E'            /EDIT specified?\n         BNE   *+8                      no - skip\n         OI    QSCFLAG3,QSC3EDIT        indicate EDIF instead of BRIF\n         TM    QSCFLAG3,QSC3EDIT        want EDIF?\n         BZ    LI$CALL3                 no - ok\n         TM    QISFLAG1,QIS1ISPF        yes - running under ISPF?\n         BO    LI$ISPF                  yes - ok\n         QTILT '*** EDIT only valid under ISPF ***'\nLI$ISPF  TM    QISFLAG1,QIS1V23         are we V2.3 or higher?\n         BO    LI$CALL3                 yes - ok\n         QTILT '*** ISPF V2R3 or later required for EDIT ***'\n***********************************************************************\n*                                                                     *\n*   CALL LISTDS TO LIST THE DATASET                                   *\n*                                                                     *\n***********************************************************************\nLI$CALL3 MVI   QCODE,0                  TELL LISTDS \"INITIAL POSIT'ING\"\n         QCALL LISTDS\n         B     QSTOP\n***********************************************************************\n*                                                                     *\n*   TELL HIM HE REQUESTED SOMETHING DUMB                              *\n*                                                                     *\n***********************************************************************\nLI$TILT  OI    QSCFLAG1,QSC1JOB         PUT THE JOBID IN QDTOP\n         MVC   QERRMSG,QBLANK           CLEAR THE MESSAGE AREA\n         MVC   QERRMSG(14),=C'*** DATASET ID'\n         MVC   QERRMSG+15(8),QPARM2     SHOW WHAT HE ASKED FOR\n         MVC   QERRMSG+24(11),=C'INVALID ***'\n         QTILT *,OPTIONS=REPROMPT\n***********************************************************************\n*                                                                     *\n*   PROCESS 'NS' SUBCOMMAND                                           *\n*                                                                     *\n***********************************************************************\nLIST$NS  L     R14,QCDDTBLA             -> DSID TABLE\n         LTR   R14,R14                  ANY?\n         BZ    NS$TILT1                 NO - ABORT\n         CLI   QKEYWORD+8,C' '          MORE THAN ONE OPERAND?\n         BNE   NS$TILT2                 YES - ABORT\n*---  RE-READ THE FIRST IOT.  THIS IS REQUIRED SINCE SOME OTHER    ---*\n*---  SUBCOMMAND MAY HAVE CHAINED DOWN IOTS AND LEFT ONE OTHER     ---*\n*---  THAN THE FIRST IN STORAGE.                                   ---*\n         L     R1,QCJCTA                -> JCT\n         MVC   QCTRAK,JCTIOT-JCTSTART(R1)  GET MTTR OF FIRST IOT\n         MVC   QCCBID,=C'IOT '          SHOW WHAT WE WANT\n         L     R1,QCIOTA                -> IOAREA FOR IOT FOR READSPC\n         L     R0,QCJQEA                -> JQE\n         QCALL READSPC                  READ HASPACE\n         L     R14,QCDDTBLE             -> CURRENT TABLE ENTRY\n         CLI   QSUBNAME,C'P'            IS THIS 'PS' SUBCOMMAND?\n         BE    NS$PREV                  YES - SELECT PREVIOUS SYSOUT DS\n         CLI   QKEYWORD,C' '            NEXT? (DEFAULT)\n         BE    NS$NEXT                  YES\n         CLI   QKEYWORD,C'*'            SAME DIRECTION AS LAST TIME?\n         BNE   *+10                     NO - SKIP\n         MVC   QKEYWORD(1),QCNSDIR      YES - USE PREVIOUS DIRECTION\n         CLI   QKEYWORD,C'T'            TOP?\n         BE    NS$TOP                   YES\n         CLI   QKEYWORD,C'B'            BOTTOM?\n         BE    NS$BOTT                  YES\n         CLI   QKEYWORD,C'N'            NEXT?\n         BE    NS$NEXT                  YES\n         CLI   QKEYWORD,C'+'            NEXT?\n         BE    NS$NEXT                  YES\n         CLI   QKEYWORD,C'P'            PREVIOUS?\n         BE    NS$PREV                  YES\n         CLI   QKEYWORD,C'-'            PREVIOUS?\n         BE    NS$PREV                  YES\n         EX    0,*                      SHOULD BE IMPOSSIBLE\n         SPACE 2\nNS$TOP   MVI   QCNSDIR,C'N'             SET DIRECTION\n         L     R14,QCDDTBLA             -> DSID TABLE\n         LA    R14,4(,R14)              -> FIRST ENTRY\n         CLC   =C'*E',0(R14)            END OF TABLE?\n         BNE   NS$GO                    NO - GO PROCESS IT\nNS$TILT3 QTILT '*** NO DATASETS TO DISPLAY ***'\n         SPACE 2\nNS$BOTT  MVI   QCNSDIR,C'P'             SET DIRECTION\n         L     R14,QCDDTBLA             -> DSID TABLE\nNS$BLOOP LA    R14,4(,R14)              -> NEXT ENTRY\n         CLC   =C'*E',0(R14)            END OF TABLE?\n         BNE   NS$BLOOP                 NO - KEEP LOOKING\n         SH    R14,=H'4'                YES - BACK UP TO LAST ENTRY\n         CLC   =C'*T',0(R14)            START OF TABLE?\n         BNE   NS$GO                    NO - GO PROCESS IT\n         B     NS$TILT3                 YES - NOTHING TO DISPLAY\n         SPACE 2\nNS$NEXT  LA    R14,4(,R14)              -> NEXT ENTRY\n         CLC   =C'*E',0(R14)            END OF TABLE?\n         BNE   NS$GO                    NO - GO PROCESS\n         MVI   QCNSDIR,C'P'             CHANGE DIRECTION TO 'PREV'\n         QTILT '*** END OF OUTPUT REACHED -- ENTER \"NS *\" AGAIN TO GO B$\n               ACKWARD ***'\n         B     NS$GO                    GO PROCESS IT\n         SPACE 2\nNS$PREV  SH    R14,=H'4'                -> PREVIOUS ENTRY\n         CLC   =C'*T',0(R14)            START OF TABLE?\n         BNE   NS$GO                    NO - GO PROCESS\n         MVI   QCNSDIR,C'N'             CHANGE DIRECTION TO 'NEXT'\n         QTILT '*** TOP OF OUTPUT REACHED -- ENTER \"NS *\" AGAIN TO GO F$\n               ORWARD ***'\n         B     NS$GO                    GO PROCESS IT\n         SPACE 2\nNS$GO    ST    R14,QCDDTBLE             SAVE ADDR OF CURRENT ENTRY\n         CLC   =F'2',0(R14)             JLOG?\n         BE    LISTJLOG                 YES - GO LIST IT\n         CLC   =F'3',0(R14)             JCL?\n         BE    LISTJCL                  YES - GO LIST IT\n         CLC   =F'4',0(R14)             JMSG?\n         BE    LISTJMSG                 YES - GO LIST IT\n         MVC   QLNG2,=H'6'              SET LENGTH OF OPERAND\n         L     R0,0(,R14)               GET BINARY DSID\n         CVD   R0,QNUMWORK              CONVERT TO PACKED\n         OI    QNUMWORK+7,X'0F'         REMOVE SIGN\n         UNPK  QPARM2(6),QNUMWORK       MAKE PRINTABLE\n         XC    QLNG3,QLNG3              NO THIRD OPERAND\n         B     LISTANY                  AND GO DISPLAY THIS DATASET\n         SPACE 2\nNS$TILT1 QTILT '*** YOU MUST FIRST SELECT JOB WITH \"SJ\" SUBCOMMAND ***'\nNS$TILT2 QTILT '*** NS -- TOO MANY OPERANDS ***',OPTIONS=REPROMPT\n***********************************************************************\n*                                                                     *\n*   MISCELLANY                                                        *\n*                                                                     *\n***********************************************************************\n         LTORG\n         SPACE 2\n         ENTRY LI#KEYS\nLI#KEYS  DC    CL8'EDIT    ',CL8'E       '\n         DC    X'FF'                    end of table indicator\n         SPACE 2\n         ENTRY NS#KEYS\nNS#KEYS  DC    CL8'*       '\n         DC    CL8'N       ',CL8'NEXT    ',CL8'+       '\n         DC    CL8'P       ',CL8'PREV    ',CL8'-       '\n         DC    CL8'T       ',CL8'TOP     '\n         DC    CL8'B       ',CL8'BOTTOM  '\n         DC    X'FF'                    end of table indicator\n         SPACE 3\n***      DROPX R2                       PDBDSECT\n         SPACE 3\n         QCOMMON\n         SPACE 3\n         Q$JCT\n***      Q$PDDB\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "Q#LT": {"ttr": 12556, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0e\\x00\\x00\\x00\\x83\\x00o\\x00\\x895\\x9f#P\\x00\\x81\\x00k\\x00>\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.14", "flags": 0, "createdate": "1983-01-06T00:00:00", "modifydate": "1989-12-25T23:50:00", "lines": 129, "newlines": 107, "modlines": 62, "user": "LDW"}, "text": "        TITLE '--- QUEUE--LISTTEXT -- LIST INTERNAL TEXT FOR A JOB ---'\n*---------------------------------------------------------------------*\n*                                                                     *\n*   LISTTEXT - List internal text for a job                           *\n*                                                                     *\n*   Updates:                                                          *\n*      25Dec89  LDW  Q$TEXT -> QZTEXT                                 *\n*      23Nov89  LDW  Remove unneeded Q$JCT, Q$IOT                     *\n*                    Eliminate \"LC\" macro usage                       *\n*      26Apr89  EMS  Update for SP311                                 *\n*       8Jul87  EMS  Update for GETREC, GETPDDB                       *\n*      21May87  EMS  Update for GETREC enhancements                   *\n*      21Mar87  LDW  Fix for DSID = 0 (from RSCS)                     *\n*      25Jan87  LDW  Pass READSPC the JQE addr in case of CB ID error *\n*      03/31/86 LDW  RE-DESIGN 3278-5 SUPPORT (THIRD TRY!)            *\n*      08/09/84 LDW  UPDATE FOR SP134 (USE IOTPDDB INSTEAD OF         *\n*                       QCPDDB1)                                      *\n*      04/11/84 LDW  JCTDSECT -> JCTSTART, IOTDSECT -> IOTSTART       *\n*                    USING/DROP -> USNGX/DROPX                        *\n*      01/19/84 LDW  ADD SUPPORT FOR COMMAND STACKING                 *\n*      01/06/83 LDW  ROUTINE CREATED - ADAPTED FROM \"DDNAME\"          *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 3\nLISTTEXT QSTART  STACK=X'21'\n         MVC   QDHLINE(L'LT#HDR),LT#HDR MOVE IN HEADING\n***********************************************************************\n*                                                                     *\n*   CALL FINDJOB TO LOCATE THE JQE, JCT, AND IOT                      *\n*                                                                     *\n***********************************************************************\n         QCALL FINDJOB                  FIND THE JOB\n         OI    QSCFLAG1,QSC1JOB         PUT JOBID IN QDTOP\n         QCALL DISP80                   SWITCH TO 3278-2 MODE IF 3278-5\n***********************************************************************\n*                                                                     *\n*   LOCATE PDDB NUMBER 5                                              *\n*                                                                     *\n***********************************************************************\n          AIF  (&QLEVEL GE 9).LT01\n         MVC   QPDSID,=H'5'             req pddb # 5\n          AGO  .LT02\n.LT01     ANOP ,\n         MVC   QPDSID,=F'5'             req pddb # 5\n.LT02     ANOP ,\n         NI    QFLAG2,255-Q2VALIDS      NULLIFY VALIDITY FOR LISTDS\n         MVI   QGPFLAG,QPFDIR+QPFNMSG   req specific pddb\n         QCALL GETPDDB                  locate it\n         LTR   R2,R1                    set addr\n         BP    LT$FOUND                 yes, use it\n         USNGX PDBDSECT,R2              BASE REG FOR PDDB\n         QTILT '*** JOB DOES NOT HAVE INTERNAL TEXT ***'\n***********************************************************************\n*                                                                     *\n*  SET UP TO USE \"GETREC\" ROUTINE                                     *\n*                                                                     *\n***********************************************************************\nLT$FOUND MVI   QCRFLAG,QRFINIT          req init processing\n         MVC   QCGRMTTR,PDBMTTR         set starting mttr\n*LT$FOUND L     R15,QCSTART              -> TABLE AREA\n*        MVC   0(4,R15),PDBMTTR         SET DISK ADDR OF FIRST BLOCK\n*        SR    R4,R4                    TELL GETREC \"POSITION TO TOP\"\n*        ZAP   QCHREC,=P'0'             ZERO HIGH REC NBR\n*        MVC   QCHPTR,QCSTART           BEGIN OF TBL\n          AIF  (&QLEVEL GE 9).LT03\n         MVC   QPDSID,=H'5'             set dsid for GETREC val check\n          AGO  .LT04\n.LT03     ANOP ,\n         MVC   QPDSID,=F'5'             req pddb # 5\n.LT04     ANOP ,\n         DROPX R2                       PDBDSECT\n***********************************************************************\n*                                                                     *\n*   PROCESS RECORDS                                                   *\n*                                                                     *\n***********************************************************************\nLT$LOOP1 QCALL GETREC                   GET A TEXT RECORD\n         LTR   R4,R4                    END OF DATASET?\n         BZ    QSTOP                    YES - LEAVE\n         AP    QPREC,=P'1'              BUMP DESIRED NEXT RECORD NUMBER\n         MVC   QDMSG(2),=X'1DE8'        SET OUTPUT, BRIGHT\n         MVC   QDMSG+10(8),LT#REC       'RECORD #'\n         MVC   QDMSG+19(6),=X'20206B202120'\n         LA    R1,QDMSG+24              INIT FOR EDMK\n         EDMK  QDMSG+18(7),QCCREC+1     FILL IN CURRENT RECORD NUMBER\n         MVC   QDMSG+19(7),0(R1)        LEFT JUSTIFY IT\n         MVC   QDMSG+30(2),=X'1D60'     SET OUTPUT, NORMAL\n         MVI   QDATRNUM+1,2             SET # OF ATTR BYTES IN LINE\n         BAL   R14,QADDLINE\n         USNGX LRCDSECT,R4\n***********************************************************************\n*                                                                     *\n*   FORMAT THE TEXT RECORD                                            *\n*                                                                     *\n***********************************************************************\n         SR    R0,R0                    ZERO OFFSET\n         LR    R1,R4                    ADDRESS\n         LA    R2,LRCTEXT-LRCDSECT(,R6) LENGTH TO FORMAT\n         TM    LRCFLAG1,LRC1SPAN        IS THIS A SPANNED RECORD SEG?\n         BNO   LT$CALL                  NO - OK\n         LH    R2,LRCSEGL               YES - GET LENGTH OF SEGMENT\n         TM    LRCFLAG1,LRC1SBGN        IS THIS THE FIRST SEGMENT?\n         BO    LT$SPAN1                 YES - USE DIFFERENT HDR LENGTH\n         LA    R2,LRCSTEXT-LRCDSECT(,R2)  ACCOUNT FOR LONGER PREFIX\n         B     LT$CALL\nLT$SPAN1 LA    R2,LRCSFTXT-LRCDSECT(,R2)  ACCOUNT FOR LONGER PREFIX\n         DROPX R4                       LRCDSECT\n         SPACE 2\nLT$CALL  QCALL HEXFMT                   DUMP THIS RECORD\n         BAL   R14,QADDLINE             ADD A BLANK LINE\n         B     LT$LOOP1                 GO READ NEXT RECORD\n******** USNGX TEXT-(LRCTEXT-LRCDSECT),R4  THIS SHOULD GET YOU BUT GOOD\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*   MISCELLANY                                                        *\n*                                                                     *\n***********************************************************************\n         LTORG\nLT#HDR   DC    C'Internal Text Records'\nLT#REC   DC    C'Record #'\n         SPACE 3\n         QCOMMON\n*        ORG   QDMSG\n*LT@PFX  DS    CL8,C\n         SPACE 3\n         Q$PDDB\n         Q$LRC\n         QZTEXT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "Q#MC": {"ttr": 12803, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\r\\x00\\x00\\x00\\x82#/\\x00\\x895\\x9f#Q\\x00\\xcf\\x00\\xa8\\x00R\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "05.13", "flags": 0, "createdate": "1982-08-20T00:00:00", "modifydate": "1989-12-25T23:51:00", "lines": 207, "newlines": 168, "modlines": 82, "user": "LDW"}, "text": "         TITLE '--- QUEUE--MCS -- SPY ON THE OPERATOR''S CONSOLE ---'\n*---------------------------------------------------------------------*\n*                                                                     *\n*   MCS - Copy contents of an MCS console screen buffer               *\n*                                                                     *\n*   Entry - QPARM1 = console address (default = last console operand) *\n*                                                                     *\n*   Note - This subcommand is restricted to privileged users          *\n*                                                                     *\n*   Updates:                                                          *\n*      25Dec89  LDW  Q$xxx -> QZxxx:  CVT, MCS                        *\n*      04Jun89  LDW  Use improved AUTHFUNC routine                    *\n*      03/31/86 LDW  RE-DESIGN 3278-5 SUPPORT (THIRD TRY!)            *\n*      04/16/84 LDW  DON'T STACK THIS SUBCOMMAND (TEMP, UNTIL CONS    *\n*                       IS RE-INTEGRATED AS A TRUE SUBCOMMAND)        *\n*      01/19/84 LDW  ADD SUPPORT FOR COMMAND STACKING                 *\n*      03/24/83 LDW  AGO AROUND OLD CODE TO AVOID ASM ERRORS          *\n*      03/02/83 LDW  CHANGE 'QTILT *' TO USE QERRMSG                  *\n*      01/16/83 LDW  CALL APF SUBROUTINE                              *\n*      01/07/83 LDW  DO STFSMODE ON AFTER LINKING TO DCMS CONS        *\n*      01/05/83 LDW  ADD WORKLEN=                                     *\n*      12/22/82 LDW  LINK TO DCMS CONS FOR SP1.3 SUPPORT              *\n*      12/20/82 LDW  CHANGE QTILT REPRMPT=YES TO OPTIONS=REPROMPT     *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 3\nMCS      QSTART  Q84,WORKLEN=MC@WORKL   ,STACK=X'B0'\n         USING WORK,R13\n         LA    R1,4                     request apf authorization\n         QCALL AUTHFUNC\n         QCALL DISP80                   SWITCH TO 3278-2 MODE IF 3278-5\n*---  ASSUME WE HAVE TMPMAC AVAILABLE - IF NOT, \"CONS\" WILL NOT BE\n*---  GENERATED IN PARSE'S COMMAND TABLE\n         MVC   MCS@CMD,=C'CONS '        SET UP TSO COMMAND\n         CLI   QPARM1,C' '              ANY ADDRESS SPECIFIED?\n         BE    *+10                     NO - SKIP\n         MVC   QUCMNAME,QPARM1          YES - REMEMBER FOR LATER\n         MVC   MCS@ADDR,QUCMNAME        GET OPERAND (CONSOLE ADDRESS)\n         CLI   MCS@ADDR,C'*'            SWITCH TO MASTER CONSOLE?\n         BNE   *+10                     NO - OK\n         MVC   MCS@ADDR,QBLANK          YES - SET IT BLANK\n         TMPMAC  CMD=(MCS@CMD,8),MF=(E,MCTMPMAC)  DO IT\n         STFSMODE ON                    CONS WILL HAVE TURNED THIS OFF\n         LA    R1,8                     SET ENTRY CODE = 8\n         QCALL AUTHFUNC                 RESET APF IF WE SET IT\n         QTILT '=== DONE ==='           KLUDGE UNTIL I FIGURE OUT HOW\n*                                          TO DO IT RIGHT...\n          AGO   .MC01\n***********************************************************************\n*                                                                     *\n*  THIS CODE RIPPED OFF FROM THE DCMS \"CONS\" COMMAND                  *\n*                                                                     *\n***********************************************************************\n         MVC   QDHLINE,QBLANK           CLEAR TITLE LINE\n         MVI   MCS@FLAG,0               INIT FLAGS\n         MVC   QDHLINE(39),=C'SIMULATED CONSOLE USING 3270 CONSOLE AT'\n         LA    R1,12                    request key zero\n         QCALL AUTHFUNC                 HO HUM\n         L     R1,CVTPTR                -> CVT\n         L     R1,CVTCUCB-CVT(,R1)      -> UCM\n         USING UCM,R1\n         CLI   QUCMNAME,C'*'            SWITCH TO MASTER CONSOLE?\n         BNE   OLDWAY                   NO - SEARCH FOR REQUESTED CNSL\n         SPACE 2\n*  FIRST LET'S TRY TO FIND THE MASTER CONSOLE\nMCSMSTR  LR    R15,R1                   COPY FOR ADJUSTMENT\n         SH    R15,=H'4'                POINT TO MCS PREFIX ADDR\n         L     R15,0(,R15)              GET MCS PREFIX\n         LTR   R15,R15                  IS THERE ONE?\n         BZ    OLDWAY                   NO - SKIP\n         USING UCMPRFX,R15\n         L     R3,UCMMCENT              GET MASTER CONSOLE ENTRY\n         LTR   R3,R3                    IS THERE ONE?\n         BZ    OLDWAY                   NO - SKIP\n         DROP  R15\n         USING UCMLIST,R3\n         L     R10,UCMXB                GET DCM\n         LTR   R10,R10                  IS THERE ONE?\n         BZ    OLDWAY                   SKIP IF NONE/NOT GRAPHICS\n         USING DCMTSRT,R10              POINT TO THE DCM\n         L     R6,DCMADTRN              GET PAGEABLE DCM (TDCM)\n         LTR   R6,R6                    IS THERE ONE?\n         BZ    OLDWAY                   NO - SKIP\n         DROP  R10\n         USING DCMSTRT,R6               A LITTLE\n         CLI   DCMIONDX,X'10'           IS IT A 3270 ?\n         BE    MCS3270                  YES\n         CLI   DCMIONDX,X'04'           IS IT (COUGH) A 3066 ?\n         BNE   OLDWAY                   SKIP IF NOT NEITHER\n         OI    MCS@FLAG,MCS@3066        REMEMBER 3066 FOR LATER\n         SPACE 1\nMCS3270  L     R14,UCMUCB               GET UCB FOR THIS CONSOLE\n***      CLI   18(R14),X'10'            GRAPHICS?\n***      BNE   OLDWAY                   SKIP IF NOT\n         TM    UCMATR,UCMUF             IS IT ACTIVE ?\n         BO    GOTUCM                   YES - SAVE UCM ADDR\n         SPACE 2\n         DROP  R3,R6                    DITCH ALL MY REGISTERS\n         EJECT\n*---------------------------------------------------------------------*\n*                                                                     *\n*  COULDN'T FIND MSTCONS, SO NOW WE DO IT THE OLD WAY --              *\n*  JUST USE THE FIRST AVAILABLE GRAPHICS CONSOLE.                     *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 1\nOLDWAY   LM    R3,R5,UCMVEA             R3 -> TO THE FIRST UCME\n*                                         R4 CONTAINS UCME LENGTH\n*                                           R5 -> TO THE LAST UCME\n         DROP  R1\n         USING UCMLIST,R3\nDID0     L     R1,UCMUCB                SEARCH FOR SOMETHING USEFUL\n         MVC   QDHLINE+40(3),13(R1)     SAVE DEVICE ADDRESS\n         CLI   QUCMNAME,C'*'            LOOKING FOR SPECIFIC CONS?\n         BE    ANY                      NO - SKIP\n         CLC   QDHLINE+40(3),QUCMNAME   YES - THIS IT?\n         BNE   DID1                     NO - TRY NEXT\n***\nANY      TM    UCMATR,UCMUF             IS IT ACTIVE ?\n         BZ    DID1                     NO.. UNUSEABLE\n         L     R10,UCMXB                IS IT GRAPHICS ?\n         LTR   R10,R10                  ...\n         BZ    DID1                     NO.. USELESS\n         USING DCMTSRT,R10              POINT TO THE DCM\n         L     R6,DCMADTRN              FIND THE PAGEABLE DCM (TDCM)\n         LTR   R6,R6                    DOES IT EXIST ?\n         BZ    DID1                     NO...\n         DROP  R10\n         USING DCMSTRT,R6               A LITTLE\n         NI    MCS@FLAG,255-MCS@3066    ASSUME NOT ANCIENT DEVICE\n         CLI   DCMIONDX,X'10'           IS IT A 3270 ?\n         BE    GOTUCM                   YES BY DINGLES !\n*                                          DINGLES ?\n         OI    MCS@FLAG,MCS@3066        ASSUME 3066\n         CLI   DCMIONDX,X'04'           IS IT A 3066 ?\n         BE    GOTUCM                   YES - ARRGH\nDID1     BXLE  R3,R4,DID0               GET THE NEXT ENTRY\n         LA    R1,16                    get out of key zero\n         QCALL AUTHFUNC                 HO HUM\n         CLI   QUCMNAME,C'*'            LOOKING FOR SPECIFIC CONS?\n         BNE   NOTFOUND                 YES - DIDN'T FIND IT\n         QTILT '*** NO ACCEPTABLE (3270 OR 3066) CONSOLES FOUND ***'\nNOTFOUND MVC   QERRMSG,QBLANK           CLEAR THE AREA\n         MVC   QERRMSG(3),QUCMNAME      WHAT WE ARE LOOKING FOR\n         MVC   QERRMSG+3(24),=C' NOT FOUND OR NOT USABLE'\n         QTILT *,OPTIONS=REPROMPT       LEAVE THIS PLACE\n         SPACE 3\n*---------------------------------------------------------------------*\n*                                                                     *\n* A CONSOLE HAS BEEN FOUND COPY THE SCREEN AND DISPLAY IT FOR THE USER*\n*        R3 ->  UCME                                                  *\n*        R6 ->  TDCM                                                  *\n*                                                                     *\n*---------------------------------------------------------------------*\nGOTUCM   MVC   QUCMID,UCMID             SAVE UCM ID\n         L     R1,UCMUCB                -> UCB\n         MVC   QDHLINE+40(3),13(R1)     GET DEVICE ADDRESS\n         TM    UCMDISP1,UCMDISPA        MSTCONS?\n         BNO   *+10                     NO - SKIP\n         MVC   QDHLINE+50(9),=C'*MSTCONS*'   YES - SHOW WE'RE SMART\n         TM    MCS@FLAG,MCS@3066        SHADES OF 2250?\n         BNO   *+10                     NO - SKIP\n         MVC   QDHLINE+24(4),=C'3066'   YES - IT'S BEEN REINCARNATED...\n         LH    R2,DCMMSGAL              NUMBER OF LINES IN MSG AREA\n         L     R7,DCMASCRN              POINT TO THE FIRST INPUT LINE\nGOT1     MVC   QDMSG(80),0(R7)          MOVE A LINE\n         TM    MCS@FLAG,MCS@3066        3066?\n         BO    *+10                     YES - IT HAS 80 CHAR LINES\n         MVC   QDMSG+78(2),QBLANK       CLEAR THE END OF THE LINE\n*        MVI         ,X'F4'             MAKE IT LOW INTENSITY\n*        CLI   3(R7),C'*'               SYSTEM ACTION MESSAGE?\n*        BE    *+12                     YES - MAKE IT BRIGHT\n*        CLI   3(R7),C'@'               USER ACTION MESSAGE?\n*        BNE   *+8                      NO - LEAVE AS IS\n*        MVI         ,X'F8'             YES - MAKE IT BRIGHT\n         LA    R1,16                    get out of key zero\n         QCALL AUTHFUNC                 HO HUM\n         BAL   R14,QADDLINE             ADD LINE TO DISPLAY\n         LA    R7,80(,R7)               -> NEXT CONSOLE BUFFER LINE\n         TM    MCS@FLAG,MCS@3066        3066?\n         BO    *+8                      YES - OK\n         LA    R7,4(,R7)                3270 IS 78 BYTES + 6 CONTROL\n         LA    R1,12                    request key zero\n         QCALL AUTHFUNC                 HO HUM\n         BCT   R2,GOT1                  GET EM ALL\n         LA    R1,16                    get out of key zero\n         QCALL AUTHFUNC                 HO HUM\n         B     QSTOP                    ALL DONE HERE\n         DROP  R3,R6\n.MC01     ANOP\n         LTORG ,\n         DROP  R13\n         SPACE 3\n          AGO   .MC02\n         QZCVT\n         QZMCS\n.MC02     ANOP\n         QCOMMON\n         SPACE 2\nWORK     DSECT\n         ORG   WORK+72                  SKIP OVER SAVE AREA\nMCS@FLAG DS    X\nMCS@3066 EQU   X'80'                    SELECTED CONSOLE IS A 3066\nMC@WORKL EQU   *-WORK\nMCTMPMAC TMPMAC  MF=L\nMCS@CMD  DS    CL5                      'CONS '\nMCS@ADDR DS    CL3                      OPERAND FOR ABOVE\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "Q#MO": {"ttr": 12807, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x1a\\x00\\x00\\x00\\x82#_\\x00\\x915O\"\\x18\\x02\\x13\\x00\\xf9\\x01\\xd8\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "05.26", "flags": 0, "createdate": "1982-08-23T00:00:00", "modifydate": "1991-12-20T22:18:00", "lines": 531, "newlines": 249, "modlines": 472, "user": "LDW"}, "text": "         TITLE '--- QUEUE--MODE -- DISPLAY/CHANGE Q MODES ---'\n*---------------------------------------------------------------------*\n*                                                                     *\n*   MODE - Display and change various QUEUE parameters                *\n*                                                                     *\n*   Entry - QKEYWORDS = mode change (none = display only)             *\n*                                                                     *\n*   Note - This subcommand may be executed in a QUEUE profile         *\n*                                                                     *\n*   Updates:                                                          *\n*      20Dec91  LDW  Add support for RSCA                             *\n*      29Jan91  LDW  Use QVPRNTWA to access most PRINT fields         *\n*                    Change BAL QCLRSCR to QCALL CLEARSCR             *\n*      31May89  LDW  Change CKPT/NOCKPT to APPLCOPY/NOAPPCPY          *\n*                    Fix typo in LINECT= display                      *\n*       5May89  EMS  Add support in core CKPT selection               *\n*      20Feb88  LDW  Add support for SYSLOG field selection           *\n*      21May87  EMS  Update for page/line mode                        *\n*                    Add support for LINECT operand                   *\n*      21Mar87  LDW  Fix for DSID = 0 (from RSCS)                     *\n*      29Nov86  LDW  Add support for 'Jdate/Gdate'                    *\n*                    Eliminate LC macro, use real lower case          *\n*      03/31/86 LDW  RE-DESIGN 3278-5 SUPPORT (THIRD TRY!)            *\n*      08/30/84 LDW  ADD SUPPORT FOR 'STACK' OPERAND                  *\n*      01/19/84 LDW  ADD SUPPORT FOR COMMAND STACKING                 *\n*                    ADD SUPPORT FOR 'COLS' SUBCOMMAND                *\n*      03/08/83 LDW  FIX BUG IN NOT3270                               *\n*      03/02/83 LDW  ADD PFK24                                        *\n*                    CHANGE 'QTILT *' TO USE QERRMSG                  *\n*                    CHANGE HDR AND SOME DATA TO LOWER CASE           *\n*      02/03/83 LDW  ADD YES3270 AND NOT3270                          *\n*      01/07/83 LDW  STATUS:  ALSO SET QSTKEY                         *\n*      01/05/83 LDW  USE QKEYWORDS INSTEAD OF QPARM1                  *\n*                    ADD STATUS, FORM                                 *\n*      12/22/82 LDW  DELETE CODE WHICH IS NOW IN NEW RTN \"QINNARDS\"   *\n*                    ADD FCB AND UCS PRINT PARAMETERS                 *\n*                    FIX BUG IN PROCESSING \"DEST\"                     *\n*      12/20/82 LDW  CHANGE QTILT REPRMPT=YES TO OPTIONS=REPROMPT     *\n*      10/09/82 LDW  FIX BUGS CAUSED BY NOT PICKING UP PSCB ADDR      *\n*                       EARLY ENOUGH                                  *\n*      09/28/82 EMS  MAKE DEST='CENTRAL' USE BLANKS                   *\n*                    ADD 'DESTR' TO SET ROUTE DEFAULT DEST            *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 3\nMODE     QSTART  Q85,STACK=X'B0'\n         USNGX WORK,R13\n         L     R9,QVPRNTWA              -> PRINT workarea\n         USNGX QPRNTWA,R9\n         QCALL DISP80                   SWITCH TO 3278-2 MODE IF 3278-5\n         MVC   QDPROMPT,QDREPLY         SET UP WHAT TO REPROMPT\n         CLI   QCODE,4                  IS THIS 'COLS'?\n         BNE   MODEMODE                 NO\n         OI    QFLAG2,Q2COLIND          ASSUME 'ON'\n         CLC   =C'OFF',QKEYWORD         IS IT?\n         BNE   *+8                      YES - LEAVE IT ON\n         XI    QFLAG2,Q2COLIND          NO - TURN IT OFF\n*%%      CLC   QPDSID,=H'0'             IS THERE A VALID DATASET?\n         TM    QFLAG2,Q2VALIDS          IS THERE A VALID DATASET?\n         BNE   MODE$RP                  YES - GO REPOSITION\n         QTILT '=== OK ==='             PUNT\nMODE$RP  MVI   QCODE,60                 CODE FOR 'REDISP'\n         QCALL REPOS                    DO IT\n         B     QSTOP                    LEAVE\n         SPACE 3\nMODEMODE CLI   QKEYWORD,C' '            DISPLAY REQUEST?\n         BE    MODESTAR                 YES\n         TM    QFLAG1,Q1PROFOK+Q1IMMED  IMMED COMMAND AFTER INIT PROF?\n         BO    MODESTOP                 YES - CONVERT TO NON-IMMED\n         SPACE 1\n         LA    R5,QKEYWORD              -> FIRST KEYWORD OPERAND\n         LA    R6,QKEYLAST              -> PAST LAST ONE\n         SPACE 2\nMO$LOOP1 LA    R2,MO#KEYS               -> KEYWORDS TABLE\n         LR    R3,R2                    COPY\n         SPACE 1\nMO$LOOP2 CLC   0(8,R2),0(R5)            IS THIS IT?\n         BE    MO$FOUND                 YES\n         LA    R2,8(,R2)                -> NEXT TABLE ENTRY\n         CLI   0(R2),X'FF'              END OF TABLE?\n         BNE   MO$LOOP2                 NO - TRY NEXT\n         SPACE 1\nMODETILT MVC   QERRMSG(25),=C'*** UNKNOWN MODE CHANGE -'\n         MVC   QERRMSG+26(8),0(R5)      MOVE IN THE KEYWORD\n         MVC   QERRMSG+35(3),=C'***'\n         QTILT *,OPTIONS=REPROMPT\n         SPACE 2\nMO$NEXT  LA    R5,16(,R5)               -> NEXT QKEYWORD\n         CR    R5,R6                    PAST END?\n         BNL   MODE$SET                 YES - GO DISPLAY RESULTS\n         CLI   0(R5),C' '               ANYTHING HERE?\n         BE    MODE$SET                 NO - GO DISPLAY RESULTS\n         B     MO$LOOP1                 SEE WHAT THIS ONE IS\n         SPACE 3\nMO$FOUND LR    R15,R2                   COPY TABLE ENTRY ADDRESS\n         SR    R15,R3                   COMPUTE OFFSET INTO KEYWORD TBL\n         SRL   R15,1                    KEYWORDS ARE 8 BYTES, BR TABLE\n*                                       ENTRIES ARE 4 BYTES\n         B     *+4(R15)                 SELECT CORRECT ROUTINE\n*---  MUST HAVE A ONE-FOR-ONE CORRESPONDENCE BETWEEN TABLE BELOW AND\n*---  MO#KEYS\n         B     MO$SHWCC                 SHOWCC\n         B     MO$NSHCC                 NOSHOWCC\n         B     MO$PAGE                  PAGE\n         B     MO$LINE                  LINE\n         B     MO$FANUM                 FANUM\n         B     MO$NFANM                 NOFANUM\n         B     MO$BEEP                  BEEP\n         B     MO$NBEEP                 NOBEEP\n         B     MO$PFK12                 PFK12\n         B     MO$PFK24                 PFK24\n         B     MO$JDATE                 JDATE\n         B     MO$GDATE                 GDATE\n         B     MO$VFY                   VERIFY\n         B     MO$NOVFY                 NOVERIFY\n         B     MO$STACK                 STACK\n         B     MO$NSTCK                 NOSTACK\n         B     MO$RSCA                  RSCA\n         B     MO$NRSCA                 NORSCA\n         B     MO$CLASS                 CLASS=\n         B     MO$CLASS                 CLS=\n         B     MO$UCS                   UCS=\n         B     MO$FCB                   FCB=\n         B     MO$FORM                  FORM=\n         B     MO$DEST                  DEST=\n         B     MO$DESTR                 DESTR=\n         B     MO$STAT                  STATUS=\n         B     MO$Y3270                 YES3270\n         B     MO$N3270                 NOT3270\n         B     MO$COLS                  COLS\n         B     MO$NCOLS                 NOCOLS\n         B     MO$LINCT                 linect=\n         B     MO$SLOFF                 sloff\n         B     MO$SLIND                 slind\n         B     MO$SLRTC                 slrtc\n         B     MO$SLSID                 slsid\n         B     MO$SLDAT                 sldat\n         B     MO$SLTIM                 sltim\n         B     MO$SLJID                 sljid\n         B     MO$SLRFL                 slrfl\n          AIF  (&QLEVEL LT 8).MO01\n         B     MO$APCY                  ckpt in core\n         B     MO$NAPCY                 NOckpt in core\n.MO01     ANOP ,\n         SPACE 3\nMO$SHWCC OI    QMODE1,QM1LCC            REQUEST DISPLAY CARRIAGE CTL\n         B     MO$NEXT\n         SPACE 1\nMO$NSHCC NI    QMODE1,255-QM1LCC        TURN OFF FLAG\n         B     MO$NEXT\n         SPACE 1\nMO$PAGE  TM    QMODE1,QM1PAGE           ALREADY SET?\n         BO    MO$NEXT                  YES - SKIP\n         OI    QMODE1,QM1PAGE           NO - SET IT\n*%%      XC    QPDSID,QPDSID            AND NULLIFY RE-ENTRY TO LISTDS\n*ems     NI    QFLAG2,255-Q2VALIDS      NULLIFY VALIDITY FOR LISTDS\n         B     MO$NEXT\n         SPACE 1\nMO$LINE  TM    QMODE1,QM1PAGE           ALREADY NOT SET?\n         BNO   MO$NEXT                  YES - SKIP\n         NI    QMODE1,255-QM1PAGE       NO - RESET IT\n*%%      XC    QPDSID,QPDSID            AND NULLIFY RE-ENTRY TO LISTDS\n*ems     NI    QFLAG2,255-Q2VALIDS      NULLIFY VALIDITY FOR LISTDS\n         B     MO$NEXT\n         SPACE 1\nMO$FANUM OI    QMODE1,QM1FANUM          REQUEST REC NUMBERS ON FINDALL\n         B     MO$NEXT\n         SPACE 1\nMO$NFANM NI    QMODE1,255-QM1FANUM      TURN OFF FLAG\n         B     MO$NEXT\n         SPACE 1\nMO$BEEP  OI    QMODE1,QM1BEEP           REQUEST AUDIBLE ALARM ON ERRORS\n         B     MO$NEXT\n         SPACE 1\nMO$NBEEP NI    QMODE1,255-QM1BEEP       TURN OFF FLAG\n         B     MO$NEXT\n         SPACE 1\nMO$PFK12 NI    QMODE1,255-QM1PFK24      MAP PF13-24 TO PF1-12\n         B     MO$NEXT\n         SPACE 1\nMO$PFK24 OI    QMODE1,QM1PFK24          LET PF13-24 BE DIFFERENT\n         B     MO$NEXT\n         SPACE 1\nMO$JDATE OI    QMODE1,QM1JDATE          DISPLAY DATES AS JULIAN\n         B     MO$NEXT\n         SPACE 1\nMO$GDATE NI    QMODE1,255-QM1JDATE      DISPLAY DATES AS GREGORIAN\n         B     MO$NEXT\n         SPACE 1\nMO$VFY   NI    QMODE1,255-QM1NOVFY      TURN OFF \"NOVERIFY\"\n         B     MO$NEXT\n         SPACE 1\nMO$NOVFY OI    QMODE1,QM1NOVFY          TURN ON FLAG\n         B     MO$NEXT\n         SPACE 1\nMO$STACK OI    QMODE1,QM1STACK          TURN ON FLAG\n         B     MO$NEXT\n         SPACE 1\nMO$NSTCK NI    QMODE1,255-QM1STACK      TURN OFF \"STACK\"\n         B     MO$NEXT\n         SPACE 1\nMO$RSCA  OI    QMODE2,QM2RSCA           TURN ON FLAG\n         B     MO$NEXT\n         SPACE 1\nMO$NRSCA NI    QMODE2,255-QM2RSCA       TURN OFF \"RSCA\"\n         B     MO$NEXT\n         SPACE 1\nMO$CLASS MVC   QPCLASS,8(R5)            SAVE REQUESTED PRINT CLASS\n         B     MO$NEXT\n         SPACE 1\nMO$UCS   MVC   QPUCS,8(R5)              SAVE REQUESTED PRINT UCS\n         B     MO$NEXT\n         SPACE 1\nMO$FCB   MVC   QPFCB,8(R5)              SAVE REQUESTED PRINT FCB\n         B     MO$NEXT\n         SPACE 1\nMO$FORM  MVC   QPFORM,8(R5)             SAVE REQUESTED PRINT FORM\n         B     MO$NEXT\n         SPACE 1\nMO$DEST  MVC   QPDEST,8(R5)             SAVE REQUESTED PRINT DEST\n         CLC   QPDEST,=CL8'CENTRAL'     USER WISH CENTRAL DEST?\n         BNE   MO$NEXT                  NO - CONTINUE\n         MVC   QPDEST,QBLANK            YES - USE BLANKS INSTEAD\n         B     MO$NEXT\n         SPACE 1\nMO$DESTR MVC   QDEST,8(R5)              SAVE REQUESTED ROUTE DEST\n         CLC   QDEST,=CL8'CENTRAL'      USER WISH CENTRAL DEST?\n         BNE   MO$NEXT                  NO - CONTINUE\n         MVC   QDEST,QBLANK             YES - USE BLANKS INSTEAD\n         B     MO$NEXT\n         SPACE 1\nMO$STAT  MVC   QSTDEFKY,8(R5)           MOVE IN NEW DEFAULT SEARCH KEY\n         CLI   8(R5),C' '               ANY?\n         BNE   *+10                     YES - OK\n         MVC   QSTDEFKY(7),QLOGON       NO - RESET IT TSO LOGON ID\n         MVC   QSTKEY,QSTDEFKY          AND SET CURRENT SEARCH KEY\n         B     MO$NEXT\n         SPACE 1\nMO$Y3270 STLINENO  LINE=1,MODE=ON       TELL VTAM WE'RE BACK\n         SPACE 1\n         NI    QTERMFLG,255-QTFTTY      RESET TTY FLAG\n         B     MO$NEXT\n         SPACE 1\nMO$N3270 QCALL CLEARSCR                 ERASE THE SCREEN\n         OI    QTERMFLG,QTFTTY          SET TTY FLAG\n         B     MO$NEXT\n         SPACE 3\nMO$COLS  OI    QFLAG2,Q2COLIND          TURN ON 'COLS'\n         B     MO$NEXT\n         SPACE 3\nMO$NCOLS NI    QFLAG2,255-Q2COLIND      TURN OFF 'COLS'\n         B     MO$NEXT\n         SPACE 3\nMO$LINCT XR    R1,R1                    clear counter\n         LA    R0,3                     max digits\n         LA    R14,8(,R5)               -> data\nMO$LINLP CLI   0(R14),C' '              end of data?\n         BE    MO$LINSV                 yes, store ans\n         IC    R15,0(,R14)              get char\n         N     R15,=A(X'0F')            -> number\n         MH    R1,=H'10'                shift\n         AR    R1,R15                        add\n         LA    R14,1(,R14)              -> next char\n         BCT   R0,MO$LINLP              get it\nMO$LINSV CH    R1,=H'10'                >= 10?\n         BL    MO$LINIV                 no, invalid\n         CH    R1,=H'255'               > 255?\n         BH    MO$LINIV                 yes, invalid\n         STC   R1,QMLINECT              save final value\n         B     MO$NEXT\nMO$LINIV QTILT '*** invalid linect range (10-255) are valid ***'\n         SPACE 3\nMO$SLOFF MVI   QSLFLDS,0                reset all flags\n         B     MO$NEXT\n         SPACE 1\nMO$SLIND OI    QSLFLDS,QSLFLIND         request indicators\n         B     MO$NEXT\n         SPACE 1\nMO$SLRTC OI    QSLFLDS,QSLFLRTC         request route codes\n         B     MO$NEXT\n         SPACE 1\nMO$SLSID OI    QSLFLDS,QSLFLSID         request system id\n         B     MO$NEXT\n         SPACE 1\nMO$SLDAT OI    QSLFLDS,QSLFLDAT         request date\n         B     MO$NEXT\n         SPACE 1\nMO$SLTIM OI    QSLFLDS,QSLFLTIM         request time\n         B     MO$NEXT\n         SPACE 1\nMO$SLJID OI    QSLFLDS,QSLFLJID         request jobid\n         B     MO$NEXT\n         SPACE 1\nMO$SLRFL OI    QSLFLDS,QSLFLRFL         request request_flags\n         B     MO$NEXT\n         SPACE 1\n          AIF   (&QLEVEL LT 8).MO02\nMO$APCY  TM    QXAUTH,QXAUTHX           is user authorized?\n         BZ    MO$NEXT                  no, skip update\n         OI    QMODE2,QM2CKPT           request in core ckpt\n         B     MO$NEXT\n         SPACE 1\nMO$NAPCY TM    QXAUTH,QXAUTHX           is user authorized?\n         BZ    MO$NEXT                  no, skip update\n         NI    QMODE2,X'FF'-QM2CKPT     reset in core ckpt\n         B     MO$NEXT\n.MO02     ANOP ,\n         SPACE 3\nMODE$SET TM    QFLAG1,Q1PROFOK          INIT PROFILE COMPLETE?\n         BNO   QSTOP                    NO - DON'T GENERATE DISPLAY\n*  \"IMMED\" WILL HAVE BEEN TURNED OFF THE FIRST TIME IN\n         B     MODEDISP                 GO DISPLAY CURRENT OPTIONS\n         SPACE 3\nMODESTAR TM    QFLAG1,Q1IMMED           ARE WE HERE AS \"IMMEDIATE\"?\n         BNO   MODEDISP                 NO - GO GENERATE DISPLAY\n         SPACE 1\nMODESTOP NI    QFLAG1,255-Q1IMMED       YES - RESET FLAG\n         B     QSTOP                    RETURN TO \"DISPLAY\" TO BE\n*                                       RE-INVOKED BY QUEUE MAINLINE\n         SPACE 3\nMODEDISP MVC   QDHLINE(22),=C'Current mode settings:'\n         BAL   R14,QADDLINE             START WITH BLANK LINE\n         SPACE 1\n         MVC QDMSG(44),=C'Display Carriage Control -------------->  NO'\n         MVC   QDMSG+55(17),=C'(SHOWCC/NOSHOWCC)'\n         TM    QMODE1,QM1LCC            WELL?\n         BNO   *+10                     NO - SKIP\n         MVC   QDMSG+42(3),=C'YES'      YES\n         BAL   R14,QADDLINE             DISPLAY THIS LINE\n         SPACE 1\n         MVC QDMSG(46),=C'Handling of output displays ----------->  LIN$\n               E'\n         MVC   QDMSG+55(11),=C'(PAGE/LINE)'\n         TM    QMODE1,QM1PAGE           WELL?\n         BNO   *+10                     NO - SKIP\n         MVC   QDMSG+42(4),=C'PAGE'     YES\n         BAL   R14,QADDLINE             DISPLAY THIS LINE\n         SPACE 1\n         MVC QDMSG(44),=C'Display record numbers for FINDALL ---->  NO'\n         MVC   QDMSG+55(15),=C'(FANUM/NOFANUM)'\n         TM    QMODE1,QM1FANUM          WELL?\n         BNO   *+10                     NO - SKIP\n         MVC   QDMSG+42(3),=C'YES'      YES\n         BAL   R14,QADDLINE             DISPLAY THIS LINE\n         SPACE 1\n         MVC QDMSG(44),=C'Audible Alarm for error messages ------>  NO'\n         MVC   QDMSG+55(13),=C'(BEEP/NOBEEP)'\n         TM    QMODE1,QM1BEEP           WELL?\n         BNO   *+10                     NO - SKIP\n         MVC   QDMSG+42(3),=C'YES'      YES\n         BAL   R14,QADDLINE             DISPLAY THIS LINE\n         SPACE 1\n         MVC QDMSG(44),=C'PF13-24 different from PF1-12 --------->  NO'\n         MVC   QDMSG+55(13),=C'(PFK12/PFK24)'\n         TM    QMODE1,QM1PFK24          WELL?\n         BNO   *+10                     NO - SKIP\n         MVC   QDMSG+42(3),=C'YES'      YES\n         BAL   R14,QADDLINE             DISPLAY THIS LINE\n         SPACE 1\n         MVC QDMSG(48),=C'Format of displayed dates ------------->  Jul$\n               ian'\n         MVC   QDMSG+55(13),=C'(JDATE/GDATE)'\n         TM    QMODE1,QM1JDATE          WELL?\n         BO    *+10                     Julian - skip\n         MVC   QDMSG+42(9),=C'Gregorian'\n         BAL   R14,QADDLINE             DISPLAY THIS LINE\n         SPACE 1\n         MVC QDMSG(44),=C'Verify action requests before exec ---->  NO'\n         MVC   QDMSG+55(17),=C'(VERIFY/NOVERIFY)'\n         TM    QMODE1,QM1NOVFY          WELL?\n         BO    *+10                     NO - SKIP\n         MVC   QDMSG+42(3),=C'YES'      YES\n         BAL   R14,QADDLINE             DISPLAY THIS LINE\n         SPACE 1\n         MVC QDMSG(44),=C'Support cmd stack via \"END\" subcmd ---->  NO'\n         MVC   QDMSG+55(15),=C'(STACK/NOSTACK)'\n         TM    QMODE1,QM1STACK          WELL?\n         BNO   *+10                     NO - SKIP\n         MVC   QDMSG+42(3),=C'YES'      YES\n         BAL   R14,QADDLINE             DISPLAY THIS LINE\n         SPACE 1\n         MVC QDMSG(44),=C'Reissue stacked cmd after action cmd -->  NO'\n         MVC   QDMSG+55(13),=C'(RSCA/NORSCA)'\n         TM    QMODE2,QM2RSCA           WELL?\n         BNO   *+10                     NO - SKIP\n         MVC   QDMSG+42(3),=C'YES'      YES\n         BAL   R14,QADDLINE             DISPLAY THIS LINE\n         SPACE 1\n         MVC QDMSG(40),=C'Default lines/page -------------------->'\n         MVC   QDMSG+55(16),=C'(LINECT=(10-255)'\n         XR    R15,R15                  clear\n         IC    R15,QMLINECT             get lines/page\n         CVD   R15,MO@DWD               convert it\n         MVC   QDMSG+42(3),=X'202120'   edit mask\n         ED    QDMSG+41(4),MO@DWD+6     number\n         BAL   R14,QADDLINE             DISPLAY THIS LINE\n          AIF  (&QLEVEL LT 8).MO03\n         SPACE 1\n         TM    QXAUTH,QXAUTHX           is user authorized?\n         BZ    MO$NO$AC                 no, skip display\n         MVC QDMSG(44),=C'Use Applcopy Checkpoint --------------->  NO'\n         MVC   QDMSG+55(19),=C'(APPLCOPY/NOAPPCPY)'\n         TM    QMODE2,QM2CKPT           WELL?\n         BNO   *+10                     NO - SKIP\n         MVC   QDMSG+42(3),=C'YES'      YES\n         BAL   R14,QADDLINE             DISPLAY THIS LINE\nMO$NO$AC EQU   *\n.MO03     ANOP ,\n         BAL   R14,QADDLINE             ADD BLANK LINE\n         SPACE 1\n         MVC   QDMSG(31),=C'Sysout print defaults  ------->'\n         MVC   QDMSG+33(6),=C'CLASS='\n         MVC   QDMSG+39(L'QPCLASS),QPCLASS  DISPLAY THE CLASS\n         MVC   QDMSG+42(5),=C'DEST='\n         MVC   QDMSG+47(L'QPDEST),QPDEST  DISPLAY THE DEST\n         CLI   QPDEST,C' '              ANYTHING?\n         BH    *+10                     YES - KEEP IT\n         MVC   QDMSG+47(8),=CL8'CENTRAL'  NO - IT'S THEREFORE \"CENTRAL\"\n         BAL   R14,QADDLINE             DISPLAY THIS LINE\n         MVC   QDMSG+33(4),=C'UCS='\n         MVC   QDMSG+37(L'QPUCS),QPUCS  DISPLAY THE UCS\n         MVC   QDMSG+43(4),=C'FCB='\n         MVC   QDMSG+47(L'QPFCB),QPFCB  DISPLAY THE FCB\n         MVC   QDMSG+53(5),=C'FORM='\n         MVC   QDMSG+58(L'QPFORM),QPFORM  DISPLAY THE FORM\n         BAL   R14,QADDLINE             DISPLAY THIS LINE\n         SPACE 1\n         MVC   QDMSG(31),=C'Route default ---------------->'\n         MVC   QDMSG+33(6),=C'DESTR='\n         MVC   QDMSG+39(L'QDEST),QDEST  DISPLAY DESTINATION\n         CLI   QDEST,C' '               ANY SPECIAL LOC?\n         BH    *+10                     YES, USE IT\n         MVC   QDMSG+39(8),=CL8'CENTRAL' NO - IT'S THEREFORE \"CENTRAL\"\n         BAL   R14,QADDLINE             DISPLAY THIS LINE\n         SPACE 1\n         MVC   QDMSG(31),=C'Default \"STATUS\" search key -->'\n         MVC   QDMSG+33(7),=C'STATUS='\n         MVC   QDMSG+40(L'QSTDEFKY),QSTDEFKY  DISPLAY DFLT SEARCH KEY\n         BAL   R14,QADDLINE             DISPLAY THIS LINE\n         SPACE 1\n         TM    QXAUTH,QXAUTHX           privileged user?\n         BZ    MO$NO$SL                 no - skip\n         MVC   QDMSG(17),=C'SYSLOG fields -->'\n         LA    R1,QDMSG+19              -> output loc\n         LA    R14,MO#SLFLD             -> field descriptor table\nMO$SL$LP IC    R15,0(,R14)              get flag byte\n         EX    R15,MO$SL$TM             tm qslflds,*-*\n         BZ    MO$SL$NO\n         MVC   0(3,R1),1(R14)\n         LA    R1,5(,R1)\nMO$SL$NO LA    R14,1+3(,R14)            -> next table entry\n         CLI   0(R14),X'FF'             end of table?\n         BNE   MO$SL$LP                 no - continue\n         BAL   R14,QADDLINE             DISPLAY THIS LINE\n     MVC  QDMSG+33(44),=C'(SLxxx  xxx=OFF/IND/RTC/SID/DAT/TIM/JID/RFL)'\n         BAL   R14,QADDLINE             DISPLAY THIS LINE\nMO$NO$SL EQU   *\n         BAL   R14,QADDLINE             ADD BLANK LINE\n         SPACE 1\n         B     QSTOP                    ALL DONE\n         SPACE 1\nMO$SL$TM TM    QSLFLDS,*-*              << executed >>\n         SPACE 2\n         ENTRY MO#KEYS,COL#KEYS\n*---  MUST HAVE A ONE-FOR-ONE CORRESPONDENCE BETWEEN TABLE BELOW AND\n*---  BRANCH TABLE IN MO$FOUND\nMO#KEYS  DC    CL8'SHOWCC  '\n         DC    CL8'NOSHOWCC'\n         DC    CL8'PAGE    '\n         DC    CL8'LINE    '\n         DC    CL8'FANUM   '\n         DC    CL8'NOFANUM '\n         DC    CL8'BEEP    '\n         DC    CL8'NOBEEP  '\n         DC    CL8'PFK12   '\n         DC    CL8'PFK24   '\n         DC    CL8'JDATE   '\n         DC    CL8'GDATE   '\n         DC    CL8'VERIFY  '\n         DC    CL8'NOVERIFY'\n         DC    CL8'STACK   '\n         DC    CL8'NOSTACK '\n         DC    CL8'RSCA    '\n         DC    CL8'NORSCA  '\n         DC    CL8'CLASS   '\n         DC    CL8'CLS     '\n         DC    CL8'UCS     '\n         DC    CL8'FCB     '\n         DC    CL8'FORM    '\n         DC    CL8'DEST    '\n         DC    CL8'DESTR   '\n         DC    CL8'STATUS  '\n         DC    CL8'YES3270 '\n         DC    CL8'NOT3270 '\n         DC    CL8'COLS    '\n         DC    CL8'NOCOLS  '\n         DC    CL8'LINECT  '\n         DC    CL8'SLOFF   '\n         DC    CL8'SLIND   '\n         DC    CL8'SLRTC   '\n         DC    CL8'SLSID   '\n         DC    CL8'SLDAT   '\n         DC    CL8'SLTIM   '\n         DC    CL8'SLJID   '\n         DC    CL8'SLRFL   '\n         DC    CL8'APPLCOPY'\n         DC    CL8'NOAPPCPY'\n         DC    X'FF'                    END OF TABLE INDICATOR\n         SPACE 2\nCOL#KEYS DC    CL8'ON      '\n         DC    CL8'OFF     '\n         DC    X'FF'                    END OF TABLE INDICATOR\n         SPACE 2\nMO#SLFLD DC    AL1(QSLFLIND),C'Ind'\n         DC    AL1(QSLFLRTC),C'Rtc'\n         DC    AL1(QSLFLSID),C'Sid'\n         DC    AL1(QSLFLDAT),C'Dat'\n         DC    AL1(QSLFLTIM),C'Tim'\n         DC    AL1(QSLFLJID),C'Jid'\n         DC    AL1(QSLFLRFL),C'Rfl'\n         DC    X'FF'                    END OF TABLE INDICATOR\n         SPACE 3\n         DROPX R13,R9                   WORK, QPRNTWA\n         SPACE 3\n         LTORG ,\n         SPACE 3\nWORK     DSECT ,\n         ORG   WORK+72\nMO@DWD   DS    D\n         SPACE 3\n         QCOMMON\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "Q#OC": {"ttr": 13061, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x1b\\x00\\x00\\x00\\x82#_\\x00\\x915O\"$\\x01\\x9b\\x01\\x06\\x00\\xe3\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "05.27", "flags": 0, "createdate": "1982-08-23T00:00:00", "modifydate": "1991-12-20T22:24:00", "lines": 411, "newlines": 262, "modlines": 227, "user": "LDW"}, "text": "         TITLE '--- QUEUE--OPERCMD -- ISSUE SOME OPERATOR COMMAND ---'\n*---------------------------------------------------------------------*\n*                                                                     *\n*   OPERCMD - Issue various operator commands                         *\n*                                                                     *\n*   Entry - Dependent on subcommand                                   *\n*                                                                     *\n*   Note - Some subcommands are restricted to privileged users        *\n*                                                                     *\n*   Updates:                                                          *\n*      20Dec91  LDW  Check QM2RSCA before reissuing stacked command   *\n*      16Jul91  GLA  Reissue last stacked command if ok.              *\n*      26May91  LDW  Allow blank dest for ROUTE subcommand            *\n*      18Nov90  LDW  Validity check dest for ROUTE subcommand         *\n*      25Dec89  LDW  Q$SSCT -> QZSSCT                                 *\n*      04Jun89  LDW  Use improved AUTHFUNC routine                    *\n*      04/12/84 LDW  DON'T STACK THESE COMMANDS                       *\n*      04/11/84 LDW  JCTDSECT -> JCTSTART                             *\n*      01/23/84 LDW  ADD SUPPORT FOR COMMAND STACKING                 *\n*                    ALWAYS USE JOBID IF OPERAND WAS \"*\"              *\n*      11/29/83 LDW  ADD 'EJ' SUBCOMMAND                              *\n*      10/30/83 LDW  ADD 'TJ' SUBCOMMAND                              *\n*      05/25/83 LDW  FIX FOR QUOTED JOBNAMES (JES2/SP NEEDS TRAILING  *\n*                       QUOTE)                                        *\n*      03/15/83 LDW  SUPPORT LINE COMMANDS                            *\n*      03/02/83 LDW  CHANGE 'QTILT *' TO USE QERRMSG                  *\n*      02/07/83 LDW  DON'T SET Q1INQ1 ANYMORE                         *\n*                    CHANGE \"ROUTE\" SO PURE NUMERIC IS NO LONGER A    *\n*                       VALID DEST                                    *\n*      01/17/83 LDW  BYPASS WTO IF \"PJ\" OR \"RJ\" ON OWNED JOB          *\n*      01/14/83 LDW  SET QMVSCMD                                      *\n*      01/13/83 LDW  RE-INSTATE \"PURGE/PJ\" SUBCOMMANDS USING SVC 34   *\n*                       INSTEAD OF TMPMAC                             *\n*                    DETERMINE FUNCTION VIA QCODE INSTEAD OF QSUBNAME *\n*                    CALL APF SUBROUTINE                              *\n*                    ADD SUPPORT FOR \"MODE NOVERIFY\"                  *\n*                    ADD WORKLEN=                                     *\n*                    DO QTILT FOR SUCCESSFUL COMPLETION INSTEAD OF    *\n*                       SETTING \"RE-INVOKE LAST INQUIRY\" NOW THAT     *\n*                       QTILT DOESN'T CLEAR THE REST OF THE SCREEN    *\n*                    ADD REPROMPT=YES TO APPROPRIATE QTILT'S          *\n*                    DELETE &QSVC SUPPORT CODE                        *\n*      12/20/82 LDW  CHANGE QTILT REPRMPT=YES TO OPTIONS=REPROMPT     *\n*      12/08/82 LDW  DELETE \"PURGE\"/\"PJ\" SUBCOMMAND                   *\n*      10/28/82 SDM  FIX 'ROUTE' COMMAND DEFAULT DEST                 *\n*      09/27/82 EMS  USE DFLT ROUTE IN \"QDEST\" INSTEAD OF 'CENTRAL'   *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 3\nOPERCMD  QSTART  Q86,WORKLEN=OC@WORKL   ,STACK=X'F0'\n         USNGX WORK,R13\n         MVC   QDPROMPT,QDREPLY         SET WHAT TO REPROMPT\n         MVC   OC@MSG,QBLANK            CLEAR MESSAGE AREA\n         MVC   OCMDDESC(4),=Y(4+L'OCMDBUFF,0)  INITIALIZE RDW\n         MVC   OCMDBUFF,QBLANK          CLEAN MY WORK AREA\n         LH    R7,QCODEH                GET ENTRY CODE\n         CH    R7,=H'36'                TOO BIG?\n         BNH   OC$BR1(R7)               NO - SELECT CORRECT ROUTINE\n         QTILT '*** LOGIC ERROR IN OPERCMD ***'\nOC$BR1   B     OC$OPRCK                 00 - /\n         B     OC$OPRCK                 04 - |\n         B     OC$OPRCK                 08 - $\n         B     OC$FINDJ                 12 - RJ\n         B     OC$OPRCK                 16 - HJ\n         B     OC$OPRCK                 20 - AJ\n         B     OC$FINDJ                 24 - PJ\n         B     OC$OPRCK                 28 - // & ||\n         B     OC$OPRCK                 32 - TJ\n         B     OC$OPRCK                 36 - EJ\n         SPACE 2\nOC$OPRCK TM    QXAUTH,QXOPER            OPERATOR AUTHORITY?\n         BO    OC$OPER(R7)              YES - HE CAN DO ANYTHING\n         QTILT '*** YOU DO NOT HAVE OPERATOR COMMAND AUTHORITY ***'\nOC$OPER  B     OC$ANY1                  00 - /\n         B     OC$ANY1                  04 - |\n         B     OC$JES2                  08 - $\n         EX    0,*                      12 - RJ\n         B     OC$FINDJ                 16 - HJ\n         B     OC$FINDJ                 20 - AJ\n         EX    0,*                      24 - PJ\n         B     OC$ANY                   28 - // & ||\n         B     OC$FINDJ                 32 - TJ\n         B     OC$FINDJ                 36 - EJ\n***********************************************************************\n*                                                                     *\n*  CALL FINDJOB TO LOCATE THE JQE, JCT, AND IOT, VALIDITY CHK ACCESS  *\n*                                                                     *\n***********************************************************************\nOC$FINDJ QCALL FINDJOB                  FIND THE JOB\n***********************************************************************\n*                                                                     *\n*  DETERMINE PROCESSING ROUTINE                                       *\n*                                                                     *\n***********************************************************************\n         L     R9,QCJCTA                ADDR OF JCT\n         USNGX JCTSTART,R9              BASE REG FOR JCT\n         CLI   QCOMCHAR,X'EE'           COM CHAR DEFINED?\n         BZ    OC$DOWN                  NO - CAN'T DO $AJ/$HJ/$RJ\n         CLI   QCODE,24                 IS THIS PURGE?\n         BE    OC$PURGE                 YES - USE CANCEL JOBNAME PURGE\n         CLI   QCODE,12                 IS THIS ROUTE?\n         BE    OC$ROUTE                 YES - BUILD SPECIAL COMMAND\n*---  IF WE FALL THRU TO HERE, COMMAND IS AJ, HJ, EJ, OR TJ        ---*\n         SPACE 1\nOC$PRGGO MVC   OCMDBUFF(1),QCOMCHAR     MOVE IN THE JES2 COMM CHAR\n         MVI   OCMDBUFF+1,X'EE'         PREPARE FOR LOGIC ERROR\n         CLI   QCODE,16                 HJ?\n         BNE   OC$NOT$H                 NO\n         MVI   OCMDBUFF+1,C'H'          YES\n         MVC   QACTION,=CL8'*HELD*'     ASSUME IT WILL WORK\nOC$NOT$H CLI   QCODE,20                 AJ?\n         BNE   OC$NOT$A                 NO\n         MVI   OCMDBUFF+1,C'A'          YES\n         MVC   QACTION,=CL8'*RLSE''D*'  ASSUME IT WILL WORK\nOC$NOT$A CLI   QCODE,24                 PJ?\n         BNE   OC$NOT$P                 NO\n         MVI   OCMDBUFF+1,C'P'          YES\n         MVC   QACTION,=CL8'*PURGED*'   ASSUME IT WILL WORK\nOC$NOT$P CLI   QCODE,36                 EJ?\n         BNE   OC$NOT$E                 NO\n         MVI   OCMDBUFF+1,C'E'          YES\n         MVC   QACTION,=CL8'*E-H-C*'    ASSUME IT WILL WORK\nOC$NOT$E CLI   QCODE,32                 TJ?\n         BNE   OC$NOT$T                 NO\n         MVI   OCMDBUFF+1,C'T'          YES\n*  JOBID WILL BE ADDED AT OCMDBUFF+2, FOR LENGTH OF L'OC@JOBID\n         LA    R14,OCMDBUFF+2+L'OC@JOBID  -> FIRST LOC FOR OPERANDS\n         CLI   QKEYWORD,C' '            ANY OPERAND?\n         BE    OC$TILTT                 NO - ERROR\n         LA    R15,QKEYWORD             -> FIRST KEYWORD OPERAND\n         LA    R0,16                    LENGTH OF KEYWORD/OPERAND PAIR\n         LA    R1,QKEYLAST              -> LAST KEYWORD OPERAND\nOC$T$LP1 MVC   0(3,R14),=C',?='         PUT IN DELIMITER AND EQUALS\n         MVC   1(1,R14),0(R15)          SET OPERAND KEYWORD\n         MVC   3(8,R14),8(R15)          SET OPERAND VALUE\nOC$T$LP2 LA    R14,1(,R14)              -> NEXT POSITION\n         CLI   0(R14),C' '              HERE?\n         BNE   OC$T$LP2                 NO - KEEP LOOKING\n         BXLE  R15,R0,*+8   >=====+     YES - PROCESS ALL OPERANDS\n         B     OC$T$SET           |     NO - CONTINUE\n         CLI   0(R15),C' '  <=====+     ANY MORE OPERANDS?\n         BNE   OC$T$LP1                 YES - PROCESS\nOC$T$SET MVC   QACTION,=CL8'*SET*'      ASSUME IT WILL WORK\nOC$NOT$T CLI   OCMDBUFF+1,X'EE'         DID WE FIND SOMETHING?\n         BNE   *+8                      YES - CONTINUE\n         EX    0,*                      NO - LOGIC ERROR\n         BAL   R14,OC$BUILD             BUILD JOBID\n         MVC   OCMDBUFF+2(L'OC@JOBID),OC@JOBID  'JOBNAME' OR JN/SN/TN\n         CLI   OCMDBUFF+1,C'E'          IS THIS EJ?\n         BNE   OC$SVC34                 NO - OK\n*---  ADD ';HJ<JOBID>;CJ<JOBID>' TO COMMAND WE HAVE BUILT          ---*\n         MVC   OCMDBUFF+2+L'OC@JOBID(2),=C';H'  PUT IN DELIMITER & CMD\n         MVC   OCMDBUFF+4+L'OC@JOBID(L'OC@JOBID),OC@JOBID\n         MVC   OCMDBUFF+4+2*L'OC@JOBID(2),=C';C'  PUT IN DELIM & CMD\n         MVC   OCMDBUFF+6+2*L'OC@JOBID(L'OC@JOBID),OC@JOBID\nOC$SVC34 CLI   QCODE,04                 QUIET TYPE?\n         BE    OC$MGCR                  YES - BYPASS WTO\n         CLI   QCODE,24                 \"PJ\"?\n         BE    OC$OWNCK                 YES - SEE IF OWNED JOB\n         CLI   QCODE,12                 \"RJ\"?\n         BNE   OC$WTOGO                 NO - GO ISSUE WTO\nOC$OWNCK TM    QFLAG2,Q2OWNJOB          DOES HE OWN THIS JOB?\n         BO    OC$MGCR                  YES - BYPASS WTO\nOC$WTOGO MVC   OC@WTO(WTOMASKL),WTOMASK COPY PATTERN WTO\n         MVC   OC@WTO+4+4(7),QLOGON     MOVE IN TSO USERID\n         MVC   OC@WTO+4+16(L'OCMDBUFF),OCMDBUFF    MOVE COMMAND TO WTO\n*---  CHECK FOR A COMMAND OF 'REPLY' OR 'R'\n         LA    R1,OC@WTO+4+16           -> SAVED COMMAND\n         LA    R0,L'OCMDBUFF            LENGTH OF SAVED COMMAND\nOC$RL01  CLI   0(R1),C' '               LEADING BLANK?\n         BNE   OC$RL02                  NO, LOOK AT COMMAND\n         LA    R1,1(,R1)                INCREMENT POINTER\n         BCT   R0,OC$RL01               AND LOOP\nOC$RL02  CH    R0,=H'2'                 ENOUGH ROOM FOR R?\n         BL    OC$RL06                  NO, LOOK FOR NUMBER\n         CLC   =C'R ',0(R1)             'R' COMMAND?\n         BNE   OC$RL03                  NO, TEST ANOTHER\n         LA    R1,2(,R1)                SKIP COMMAND\n         SH    R0,=H'2'                 REDUCE LENGTH\n         B     OC$RL04                  AND GO SKIP BLANKS\nOC$RL03  CH    R0,=H'6'                 ENOUGH ROOM FOR REPLY?\n         BL    OC$RL06                  NO, LOOK FUR NUMBER\n         CLC   =C'REPLY ',0(R1)         'REPLY' COMMAND?\n         BNE   OC$RL06                  NO, LOOK FOR NUMBER\n         LA    R1,6(,R1)                SKIP COMMAND\n         SH    R0,=H'6'                 REDUCE LENGTH\nOC$RL04  LTR   R0,R0                    ANY MORE DATA?\n         BNP   OC$RL08                  NO, NOT A REPLY\nOC$RL05  CLI   0(R1),C' '               LEADING BLANK?\n         BNE   OC$RL06                  NO, LOOK FOR NUMBER\n         LA    R1,1(,R1)                INCREMENT POINTER\n         BCT   R0,OC$RL05               AND LOOP\nOC$RL06  LTR   R0,R0                    ANY MORE DATA?\n         BNP   OC$RL08                  NO, NOT A REPLY\n         TM    0(R1),X'F0'              NUMERIC ZONE?\n         BNO   OC$RL08                  NO, CAN'T BE REPLY\n         MVI   OC@RID,C'0'              ASSUME ONLY ONE DIGIT\n         MVC   OC@RID+1(1),0(R1)        SAVE REPLID FIRST DIGIT\n         CH    R0,=H'2'                 ROOM FOR SECOND DIGIT?\n         BL    OC$RL07                  NO, USE ONLY ONE DIGIT\n         TM    1(R1),X'F0'              NUMERIC ZONE?\n         BNO   OC$RL07                  NO, USE ONLY ONE DIGIT\n         MVC   OC@RID,0(R1)             SAVE BOTH DIGITS\nOC$RL07  MVC   OC@WTO+4+16(L'OCMDBUFF),QBLANK   CLEAR SAVED COMMAND\n         MVC   OC@WTO+4+16(6),=C'REPLY '        FORMAT REPLY MESSAGE\n         MVC   OC@WTO+4+16+6(2),OC@RID          MOVE IN REPLY NUMBER\nOC$RL08  SR    R0,R0                    CLEAR FOR IC\n         IC    R0,QUCMID                GET CONSOLE ID\n         WTO   MF=(E,OC@WTO)            NO - SO TELL THE OPERATOR\n         SPACE 1\nOC$MGCR  LA    R1,12                    get key zero\n         QCALL AUTHFUNC                 ...to pass SVC34 validity check\n         LA    R1,OCMDDESC              -> COMMAND\n         SR    R0,R0                    CLEAR FOR IC\n         IC    R0,QUCMID                GET CONSOLE UCM ID\n         SR    R15,R15                  PRESET R15 BECAUSE SVC 34 ...\n         BCTR  R15,0                    DOESN'T ALWAYS SET IT IF ERROR\n         SVC   34                       DO IT\n         LR    R2,R15                   SAVE RETURN CODE\n         LA    R1,16                    get out of key zero\n         QCALL AUTHFUNC\n         LTR   R2,R2                    DID SVC34 WORK?\n         BNZ   OC$BAD34                 NO\n         TM    QSCFLAG2,QSC2LINE        HERE VIA LINE COMMAND?\n         BO    QSTOP                    YES - RETURN TO MAINLINE\n*                                       (MESSAGE IN QACTION)\n         TM    QMODE2,QM2RSCA           reissue stacked command?\n         BNZ   OC$RSCA                  yes - do it Guy's way...\n         QTILT '=== Ok ==='\nOC$RSCA  QNEWCMD STACK,MSG==CL79'=== Ok ==='\nOC$BAD34 MVC   QACTION,=CL8'***RC\u00ac=0'   ASSUME LINE COMMAND\n         TM    QSCFLAG2,QSC2LINE        HERE VIA LINE COMMAND?\n         BO    QSTOP                    YES - RETURN TO MAINLINE\n         MVC   QERRMSG(L'OCMDBUFF),OCMDBUFF     SHOW HIM THE COMMAND\n         MVC   QERRMSG+44(35),=C'*** SVC 34 RETURN CODE NON-ZERO ***'\n         QTILT *,OPTIONS=REPROMPT\nOC$TILTT QTILT '*** MISSING OPERAND(S) ***',OPTIONS=REPROMPT\nOC$ANY   QTILT '*** // COMMAND DISCONTINUED (REPLACED WITH / COMMAND) *$\n               **',OPTIONS=REPROMPT\nOC$ANY1  LA    R1,QDREPLY               -> REPLY AREA\n         AH    R1,QOFF0                 -> COMMAND\n         CLC   0(1,R1),1(R1)            IS THIS // OR ||?\n         BE    OC$ANY                   YES - TELL HIM IT'S GONE\n         MVC   QMVSCMD,QDREPLY          SAVE FOR REPROMPTING\n         MVI   0(R1),C' '               KILL THE /\n         MVC   OCMDBUFF,QDREPLY+1       GET THE COMMAND\n         B     OC$SVC34                 DO IT\nOC$JES2  L     R14,QSSCT                -> SSCT FOR SELECTED JES2\n         LTR   R14,R14                  VALID SUBSYSTEM?\n         BZ    OC$DOWN                  NO - CAN'T DO THIS SUBCOMMAND\n         CLC   =F'0',SSCTSSVT-SSCT(R14) ANY SSVT POINTER?\n         BE    OC$DOWN                  NO - IT'S NOT UP - CAN'T DO\n         MVC   OCMDBUFF,QDREPLY         GET THE COMMAND\n         MVC   QMVSCMD,QDREPLY          SAVE FOR REPROMPTING\n         B     OC$SVC34                 DO IT\nOC$DOWN  MVC   QERRMSG,QBLANK\n         MVC   QERRMSG(3),=C'***'\n         MVC   QERRMSG+4(4),QJESNAME\n         MVC   QERRMSG+9(13),=C'IS NOT UP ***'\n         QTILT *\nOC$PURGE MVC   OC@MSG+4(5),=C'PURGE'    SHOW COMMAND TO VERIFY\n         BAL   R8,OC$VERFY              VERIFY REQUEST\n         B     OC$PRGGO                 AND GO DO IT VIA SVC34\nOC$ROUTE MVC   OC@MSG+4(5),=C'ROUTE'    SHOW COMMAND TO VERIFY\n         MVC   OC@MSG+31(5),=C'DEST='\n         MVC   OC@MSG+36(8),=CL8'CENTRAL'  DEFAULT DEST TO 'CENTRAL'\n         CLI   QPARM2,C' '              DID HE SAY WHERE TO?\n         BNE   OC$RT01                  YES - USE IT\n         CLI   QDEST,C' '               NO, DEFAULT DEST FROM TSO?\n         BNH   OC$RT02                  NO, USE 'CENTRAL'\n         MVC   QPARM2,QDEST             YES, USE IT\nOC$RT01  MVC   OC@MSG+36(8),QPARM2      SET DEST\n*---  Validity check destination\nOC$RT02  CLC   OC@MSG+36(8),=CL8'LOCAL' is it to local?\n         BE    OC$RTVFY                 yes - ok\n         CLC   OC@MSG+36(8),=CL8'CENTRAL'  default?\n         BNE   OC$RT04                  no - continue\n         CLI   QDEST,C' '               yes - is default blank?\n         BNH   OC$RTVFY                 yes - 'CENTRAL' is ok\nOC$RT04  CLI   OC@MSG+36,C'R'           maybe Rnnn?\n         BNE   OC$RTRDT                 no - must check RDTs\n         LA    R15,OC@MSG+37            -> first char to test\n         LA    R0,7                     max chars to check\nOC$RT03  CLI   0(R15),C' '              end of dest?\n         BE    OC$RTVFY                 yes - dest ok (Rnnn)\n         CLI   0(R15),C'0'              numeric?\n         BL    OC$RTRDT                 no - go check RDTs\n         LA    R15,1(,R15)              -> bump scan ptr\n         BCT   R0,OC$RT03\n         B     OC$RTVFY                 Rnnn - ok\n*---  See if this dest has an RDT\nOC$RTRDT L     R15,QSSCT                -> SSCT OF SELECTED SUBSYSTEM\n         LTR   R15,R15                  DEFINED?\n         BZ    OC$TILT4                 NO - CAN'T DO THIS SUBCOMMAND\n          AIF  (&QLEVEL GE 9).OC020\n         L     R15,SSCTSSVT-SSCT(,R15)  -> SSVT\n         USNGX SSVT,R15\n          AGO  .OC030\n.OC020    ANOP ,\n         L     R15,SSCTSUS2-SSCT(,R15)  -> HCCT\n         USNGX HCCT,R15\n.OC030    ANOP ,\n         LTR   R15,R15                  ACTIVE?\n         BZ    OC$TILT5                 NO - CAN'T DO THIS SUBCOMMAND\n         L     R3,$SVRDT                -> FIRST RDT\n          AIF  (&QLEVEL GE 9).OC040\n         LA    R4,RDTSIZ                LENGTH OF RDT (BXLE INCR)\n         L     R5,$SVRDTE               -> LAST RDT\n.OC040    ANOP ,\n         DROPX R15                      SSVT or HCCT\n         USNGX RDTDSECT,R3\n         SPACE 1\nOC$RT08  CLC   OC@MSG+36(8),RDTNAME     is this the dest?\n         BE    OC$RTVFY                 yes - dest ok\n          AIF  (&QLEVEL GE 9).OC050\n         BXLE  R3,R4,OC$RT08            check all RDTs\n          AGO  .OC060\n.OC050    ANOP ,\n         ICM   R3,B'1111',RDTRDT        check\n         BNZ   OC$RT08                        all RDTs\n.OC060    ANOP ,\n         QTILT '*** INVALID DESTINATION ***',OPTIONS=REPROMPT\n         DROPX R3                       RDT\n         SPACE 2\nOC$RTVFY BAL   R8,OC$VERFY              VERIFY REQUEST\n         MVC   OCMDBUFF(1),QCOMCHAR     MOVE IN JES2 COMM CHAR\n         MVC   OCMDBUFF+1(18),=C'RALL,D=LOCAL   ,J='\n         CLI   QPARM2,C' '              ANY DEST?\n         BE    *+10                     NO - ASSUME LOCAL\n         MVC   OCMDBUFF+8(8),QPARM2     YES - USE SPECIFIED ONE\n         BAL   R14,OC$BUILD             BUILD JOBID\n         MVC   OCMDBUFF+19(L'OC@JOBID),OC@JOBID  'JOBNAME' OR JN/SN/TN\n         MVC   QACTION,=CL8'*ROUTED*'   ASSUME IT WILL WORK\n         B     OC$SVC34                 GO EXECUTE IT\nOC$TILT4 QTILT '*** UNABLE TO VERIFY DESTINATION ***',OPTIONS=REPROMPT\nOC$TILT5 MVC   QERRMSG(22),=C'*** XXXX IS NOT UP ***'\n         MVC   QERRMSG+4(4),QJESNAME\n         QTILT *\n         SPACE 3\nOC$BUILD MVC   OC@JOBID(1),QEXTJBID     GET JOB TYPE (J/S/T)\n         MVC   OC@JOBID+1(5),QEXTJBID+3 GET JOB NUMBER\n         MVC   OC@JOBID+6(4),QBLANK     BLANK THE EXCESS\n         TM    QFLAG1,Q1JOBID           IS IT A JOBID?\n         BOR   R14                      YES - RETURN TO CALLER\n         LA    R1,QDREPLY               -> REPLY\n         AH    R1,QOFF1                 -> ACTUAL FIRST OPERAND\n         CLI   0(R1),C'*'               DID HE ACTUALLY SAY \"*\"?\n         BER   R14                      YES - USE THE JOBID\n         MVI   OC@JOBID,C''''           NO - SET UP FOR JOBNAME\n         MVC   OC@JOBID+1(8),QPARM1     MOVE IN JOBNAME\n         MVI   OC@JOBID+1+8,C''''       PUT IN TRAILING QUOTE (JES2/SP)\n         BR    R14                      RETURN TO CALLER\n         SPACE 3\nOC$VERFY TM    QMODE1,QM1NOVFY          MODE=NOVERIFY?\n         BNO   OC$VER1                  NO - CONTINUE\n         TM    QFLAG2,Q2OWNJOB          DOES HE OWN THIS JOB?\n         BOR   R8                       YES - BYPASS VERIFY MESSAGE\nOC$VER1  MVC   OC@MSG(3),=C'>>>'        GET HIS ATTENTION\n         MVC   OC@MSG+12(8),JCTJNAME    MOVE IN JOBNAME\n         LA    R1,QDREPLY               -> REPLY\n         AH    R1,QOFF1                 -> ACTUAL FIRST OPERAND\n         CLI   0(R1),C'*'               DID HE ACTUALLY SAY \"*\"?\n         BE    OC$VER2                  YES - USE THE NUMBER\n         TM    QFLAG1,Q1JOBID           DID HE GIVE NAME OR NUMBER?\n         BNO   OC$VER3                  NAME - DON'T USE THE NUMBER\nOC$VER2  MVI   OC@MSG+20,C'('\n         MVC   OC@MSG+21(8),JCTJOBID    JOB0NNNN/STC0NNNN/TSU0NNNN\n         OC    OC@MSG+24(5),=C'00000'   CHANGE LEADING BLANKS TO ZEROES\n         MVI   OC@MSG+29,C')'\nOC$VER3  MVC   OC@MSG+46(33),=C'<<<  HIT ENTER IF OK OR RESPECIFY'\n         MVC   QDHLINE,OC@MSG           MOVE PROMPT TO DISPLAY'S AREA\n         OI    QFLAG1,Q1MVHDR           REQUEST \"MOVE HEADER\"\n         OI    QFLAG2,Q2SHORT           WRITE ONLY FIRST 3 LINES\n         QCALL DISPLAY                  GO DISPLAY THE WARNING (NOW)\n*---  THE FOLLOWING IS NEEDED SO THAT THE VERIFY MESSAGE IS NOT    ---*\n*---  LEFT ON THE SCREEN WHEN LINE COMMAND PROCESS IS COMPLETED.   ---*\n         MVC   QDHLINE,QBLANK           CLEAR THE HEADER LINE\n         OI    QFLAG1,Q1MVHDR           REQUEST \"MOVE HEADER\"\n         BR    R8                       RETURN TO CALLER\n         SPACE 3\nWTOMASK  WTO   '*** USERIDX ==> 000000000011111111112222222222333333333$\n               34444444444555555555566666',                            $\n               MF=L,MCSFLAG=REG0\nWTOMASKL EQU   *-WTOMASK\n         SPACE 2\n         LTORG\n         SPACE 2\n         ENTRY TJ#KEYS\nTJ#KEYS  DC    CL8'S',CL8'P',CL8'C'\n         DC    X'FF'\n         SPACE 2\n         DROPX R9,R13                   JCTSTART, WORK\n         SPACE 3\n         QCOMMON\n         SPACE 3\n         Q$JCT\n         QZSSCT\n         Q$SVT\n         Q$HCCT\n         Q$RDT\n         SPACE 3\nWORK     DSECT\n         ORG   WORK+72                  SKIP OVER SAVE AREA\nOC@JOBID DS    CL10                     \"'JOBNAME'\" OR \"JN\"/\"SN\"/\"TN\"\nOC@RID   DS    CL2                      FORMATTED WTOR REPLY NUMBER\nOC@MSG   DS    CL(QDREPLYL)             VERIFY MSG WORK AREA\nOC@WTO   DS    0F,CL(WTOMASKL)          WTO WORK AREA\n         SPACE 1\nOCMDDESC DS    2H\nOCMDBUFF DS    CL65                     LENGTH MUST MATCH WTOMASK\nOC@WORKL EQU   *-WORK\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "Q#PA": {"ttr": 13313, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x052\\x00\\x00\\x00\\x82#/\\x00\\x91&_!B\\x02\\xc5\\x01\\t\\x02m\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "05.50", "flags": 0, "createdate": "1982-08-20T00:00:00", "modifydate": "1991-09-22T21:42:00", "lines": 709, "newlines": 265, "modlines": 621, "user": "LDW"}, "text": "         TITLE '--- QUEUE--PARSE -- COMMAND LINE PARSE ROUTINES ---'\n*---------------------------------------------------------------------*\n*                                                                     *\n*   PARSE - Parse the input subcommand                                *\n*                                                                     *\n*   Entry - New subcommand and operands in \"QDREPLY\"                  *\n*                                                                     *\n*   Exit - All kinds of fields filled in and bits set (in QCOMMON)    *\n*                                                                     *\n*   Updates:                                                          *\n*      22Sep91  LDW  Add \"ELIST/EL\" subcommand                        *\n*                    Add KEYS=LI#KEYS to LIST, JCL, JLOG, JMSG        *\n*                    Add EL line command to PA#LC#DD                  *\n*      26Mar91  LDW  Add \"LI\" as an alias for \"LIST\", because both    *\n*                       \"L\" and \"LIST\" don't get to us while in       *\n*                       BROWSE (BRIF) under ISPF                      *\n*      30Jan91  LDW  Retrofit GLA fixes below:                        *\n*     (22Jun90) GLA  Add new command \"NJ\".                            *\n*     (17Apr90) GLA  Add second parm to CPU command.                  *\n*     (06Jan90) GLA  Always generate MCS/CONS command                 *\n*                    Add \"?\" as a line command \"DD\" or \"S\"            *\n*     (15Nov89) GLA  Add SPIN command as part of PRINT.               *\n*                    Change 'END' to ignore operands                  *\n*     (20Sep89) GLA  Do not parse operator commands.                  *\n*     (24Apr89) GLA  Disable REPOS commands if in ISPF                *\n*      27Nov90  LDW  Change QCMN,  CKPT,  HCT,  JQE,  JOE,  JCT       *\n*                       to XQCMN, XCKPT, XHCT, XJQE, XJOE, XJCT       *\n*                       (X commands will be deleted once CBFMT is     *\n*                       finished, since all will have /X operand)     *\n*                    Add subcommands CB, QCMN, CKPT, HCT, JOT, JCT,   *\n*                       JQE, JOE                                      *\n*      05Jan90  LDW  Add LKIT and LDAS subcommands                    *\n*      15May89  EMS  Add WORKLEN to QSTART macro just in case         *\n*      25May89  LDW  Add DOWN command (just had D before!)            *\n*      30May88  LDW  Add JQE and JOE subcommands (like XJ, but by     *\n*                       offset)                                       *\n*      10Apr88  LDW  Fix PA$TOKEN bug when scanning for subcmd name   *\n*                    Correct PDDB entry                               *\n*      17Jul87  EMS  Add 'PAGE' (alias 'P')                           *\n*                    Add 'PDDB' command (per LDW)                     *\n*      17Jan87  LDW  ADD 'SPSP' (alias 'TGPS')                        *\n*      27AUG86  LDW  ADD 'ATTR'                                       *\n*      04/07/86 LDW  ADD 'RETRIEVE' & 'RE' AS ALIASES FOR 'RECALL'    *\n*                       FOR COMPATIBILITY WITH VM                     *\n*                    REMOVE '*' COMMAND (OLD 'RECALL')                *\n*                    ADD IN#KEYS                                      *\n*      04/03/86 LDW  USE SPECIFIC BIT NAMES IN QDEBUG                 *\n*      12/02/85 LDW  ADD J ALIAS FOR JS, ADD TO LINE COMMANDS TABLE   *\n*      01/30/85 LDW  ADD SJ#KEYS REFERENCE                            *\n*      08/30/84 LDW  SET &ZCMD INSTEAD OF &OPT IF '=AAA'              *\n*      03/27/84 LDW  MOVE CALL TO 'DISPCHG' TO 'QUEUE' MAINLINE       *\n*                    ADD 'JS' SUBCOMMAND                              *\n*      01/27/84 LDW  ADD 'PS' SUBCOMMAND                              *\n*      01/23/84 LDW  ADD 'SJ', 'NS', 'COLS' SUBCOMMANDS               *\n*      12/20/83 LDW  ADD KEYS= TO 'DJ'                                *\n*      11/29/83 LDW  ADD 'EJ' SUBCOMMAND (LINE CMD  'EJ')             *\n*      10/30/83 LDW  ADD 'TJ' SUBCOMMAND (LINE CMDS 'TJ' AND 'T')     *\n*      09/07/83 LDW  ADD 'S' AS LINE COMMAND ALIAS OF 'DD'            *\n*      03/17/83 LDW  ADD MORE ALIASES FOR \"STOP\"                      *\n*                    CHANGE \"END\" TO FUNC=04                          *\n*                    ADD \"RECALL\" (\"RC\") AS PRIMARY NAME FOR \"*\",     *\n*                       CHANGE REPROMPT, STARKEYS TO RECALL, RC#KEYS  *\n*                    ADD KEYS=SV#KEYS, CHANGE MAX POSITS TO 1         *\n*      03/09/83 LDW  ADD KEYS= TO \"HELP\"                              *\n*      03/02/83 LDW  CHANGE 'QTILT *' TO USE QERRMSG                  *\n*                    ENHANCED ERROR MESSAGES                          *\n*      02/24/83 LDW  ADD LINE COMMAND TABLES                          *\n*      02/09/83 LDW  MORE FIDDLING WITH =XXX CODE                     *\n*      02/08/83 LDW  DELETE \"DHX\", CHANGE \"DH\" TO KEYS=DH#KEYS,       *\n*                       CHANGE MAX POSIT OPERANDS FOR \"DH\" TO ZERO    *\n*      02/07/83 LDW  IF INVOKED FROM WITHIN SPF AND '=COMMAND' IS     *\n*                       ENTERED, SET &OPT AND FAKE OUT AN EXIT CMD    *\n*                       NOTE:  SINCE THIS DOESN'T WORK YET, IT IS     *\n*                       UNDER CONTROL OF A QDEBUG FLAG                *\n*      02/03/83 LDW  CHANGE \"RD\" FROM LISTDS TO REPOS                 *\n*                    CHANGE QDINQCMD TO QINQCMD, DELETE QDINQLEN      *\n*                    MAKE USE OPTIONS=SET ON QTILT                    *\n*                    FIX BUG WHICH CAUSED '/ABC      DEF=XYZ' TO FAIL *\n*      02/02/83 LDW  ADD KEYS= TO \"CHGS\"                              *\n*                    ADD \"COPY\"                                       *\n*      01/31/83 LDW  FIX 3278-3 & -4 HANDLING                         *\n*      01/19/83 LDW  SET QTPAGEX AND QTHALFX WHEN APPROPRIATE         *\n*      01/12/83 LDW  MOVE STARKEYS TO \"DISPLAY\"                       *\n*      01/06/83 LDW  ADD \"LTXT\"                                       *\n*                    FIX BUG WHICH CAUSED \"KEYWORDS NOT ALLOWED\" MSG  *\n*                       TO BE ISSUED INSTEAD OF \"TOO MANY POSITIONAL  *\n*                       OPERANDS\" MSG                                 *\n*      01/05/83 LDW  ALTER CHECK FOR LARGE SCREEN MODE                *\n*                    IMPROVE CHECKING FOR MVS AND JES2 COMMANDS       *\n*                    MORE FIXES TO \"DON'T CHECK OPERANDS\" CASE        *\n*                    ADD KEYS= TO MODE, QINT, XB                      *\n*                    CHANGE NBR OF POSITS ALLOWED TO 0 FOR MODE, QINT *\n*                    SET Q2REPOS IF REPOSITIONING SUBCOMMAND          *\n*                    ADD EDIT, BROWSE, REDISP, HCT, QCMN, CKPT        *\n*                    CHANGE 'F' OPERAND OF \"*\" TO KEYWORD             *\n*      12/21/82 LDW  ONLY GENERATE ENTRY FOR \"CONS\" IF &QTMPMAC=1     *\n*                    ADD \"QINT\"                                       *\n*                    IF NO POSITIONAL OPERANDS ALLOWED, MAKE SLASH    *\n*                       IN FRONT OF FIRST RESERVED WORD OPTIONAL      *\n*      12/17/82 LDW  CLEAR QDHLINE BEFORE MOVING IN ERROR MESSAGES    *\n*                    CHANGE NUMBER OF POSITIONAL OPERANDS ALLOWED TO  *\n*                       ZERO FOR DA, DS, DT (KEYWORDS NOW SUPPORTED)  *\n*      12/15/82 LDW  ADD SUPPORT FOR RESERVED WORD AND KEYWORD=VALUE  *\n*                       OPERANDS                                      *\n*                    CHECK FOR TOO MANY POSITIONAL OPERANDS FOR       *\n*                       GIVEN SUBCOMMAND                              *\n*                    RE-ARRANGE OPERANDS ON QCMDE MACRO               *\n*                    ADD \"DN\" AND \"CHGS\" SUBCOMMANDS                  *\n*                    PUT IN CHECK FOR SUBCOMMAND NOT EXISTING         *\n*      12/10/82 LDW  CHANGE \"SAVE\" TO \"SAVEDS\" TO AVOID ASSEMBLY      *\n*                       PROBLEMS WITH NJE                             *\n*      12/08/82 LDW  USE \"QPARMEND\" INSTEAD OF \"QOFF4+12\"             *\n*      10/21/82 LDW  CHANGE \"HO\" TO \"DH\", \"XHO\" TO \"DHX\"              *\n*      08/30/82 LDW  ADD \"LBLK\" SUBCOMMAND                            *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 3\nPARSE    QSTART  Q16,WORKLEN=PA@WORKL\n         USING WORK,R13                 BASE REG FOR LOCAL WORK AREA\n***********************************************************************\n*                                                                     *\n*   PARSE SUBCOMMAND NAME                                             *\n*                                                                     *\n***********************************************************************\n         LH    R2,QDRLNG                LENGTH OF REPLY LINE\n         LTR   R2,R2                    ANY INPUT?\n         BNP   QSTOP                    NO - SO LEAVE\n         MVC   PA@REPLY(QDREPLYL),QDREPLY  COPY THE INPUT COMMAND\n         OC    PA@REPLY(QDREPLYL),QBLANK   TRANSLATE TO UPPER CASE\n         CLC   PA@REPLY(QDREPLYL),QBLANK   IS THE ENTIRE REPLY BLANK?\n         BE    QSTOP                    YES - NOTHING TO DO HERE\n         XC    QSCFLAGS,QSCFLAGS        CLEAR SUBCOMMAND FLAGS\n         MVC   PA@FIELD,QBLANK          BLANK THE WORK FIELD\n         MVC   P@OFFSET(4),=F'0'        ZERO THE OFFSET AND LENGTH\n         MVC   QOFF0(12),P@OFFSET       INITIALIZE FIRST FIELD\n         MVC   QOFF1(QPARMEND-QOFF1),QOFF0  INIT THE REST\n         MVC   QKEYWORD+00(80),QBLANK   CLEAR KEYWORD/VALUE AREA\n         MVC   QKEYWORD+80(80),QBLANK   CLEAR KEYWORD/VALUE AREA\n         MVI   PA@FLAG,0                CLEAR MY FLAGS\n         SR    R5,R5                    INDICATE PROCESSING SUBCMD NAME\n         LA    R3,PA@REPLY              -> FIRST BYTE OF REPLY LINE\n         BAL   R10,PA$TOKEN             GET SUBCOMMAND NAME\n         EX    0,*                      THERE BETTER BE A SUBCMD NAME\n         MVC   QOFF0(12),P@OFFSET       SAVE OFFSET, LEN, SUBCMD NAME\n***********************************************************************\n*                                                                     *\n*   FIND THE PARSE TABLE ENTRY FOR THE SUB COMMAND                    *\n*                                                                     *\n***********************************************************************\n         LA    R9,PA#TABLE              START OF SUBCOMMAND TABLE\n         USING QCMDE,R9\nPA$NEXT1 SR    R0,R0                    CLEAR FOR IC\n         IC    R0,CMD@NUM               GET NUMBER OF SUBCMD NAMES\n         LA    R1,CMD@CMD               -> FIRST SUBCMD NAME\nPA$NEXT2 CLC   QSUBNAME(L'CMD@CMD),0(R1)  COMPARE COMMAND NAME\n         BE    PA$FOUND                 THIS IS THE ONE\n         LA    R1,L'CMD@CMD(,R1)        -> NEXT SUBCMD NAME\n         BCT   R0,PA$NEXT2              CHECK ALL NAMES\n*  INCREMENT TO NEXT SUBCMD ENTRY\n         LR    R9,R1                    -> NEXT TABLE ENTRY\n         CLI   0(R9),X'FF'              IS THIS THE END OF TABLE?\n         BNE   PA$NEXT1                 NO. TRY NEXT ENTRY.\n         LA    R9,PA#CMDJ               USE JES2 SUBCOMMAND ENTRY\n         CLC   QSUBNAME(1),QCOMCHAR     COULD THIS BE A JES2 COMMAND?\n         BE    PA$FOUND                 YES - CALL 'OPERCMD'\n         LA    R9,PA#CMD                USE '/' SUBCOMMAND ENTRY\n         CLI   QSUBNAME,C'/'            SHORT FORM FOR MVS COMMAND?\n         BE    PA$FOUND                 YES - CALL 'OPERCMD'\n         LA    R9,PA#CMDQ               USE '|' SUBCOMMAND ENTRY\n         CLI   QSUBNAME,C'|'            QUIET FORM FOR MVS COMMAND?\n         BE    PA$FOUND                 YES - CALL 'OPERCMD'\n         CLI   QSUBNAME,C'='            DOES HE THINK HE'S IN SPF?\n         BNE   PA$BOUNC                 NO - NORMAL ERROR MESSAGE\n         TM    QFLAG2,Q2SPF             ARE WE REALLY IN SPF???\n         BNO   PA$NOSPF                 NO - TELL HIM SORRY\n         TM    QDEBUG1,QDEBUG12         IS THIS REQUESTED?    %%%\n         BZ    PA$NOSPF                 NO - TELL HIM SORRY   %%%\n*---  WE ARE IN SPF AND USER HAS ENTERED '=XXX'.  SET &ZCMD AND    ---*\n*---  FAKE OUT THE COMMAND TO 'EXIT'.                              ---*\n         SPACE 1\n*        LINK  EPLOC=PA#ISPLK,MF=(E,PA@PARML),PARAM=(=CL8'VDEFINE',    $\n               =CL8'ZCMD',PA@REPLY,=CL8'CHAR',=A(QDREPLYL),=CL8'COPY'),$\n               VL=1\n         SPACE 1\n*        LTR   R15,R15\n*        BZ    PA$DEFOK\n         SPACE 1\n*        QTILT '*** VDEFINE RC \u00ac= 0 ***'\n*A$DEFOK LINK  EPLOC=PA#ISPLK,MF=(E,PA@PARML),PARAM=(=CL8'VPUT',       $\n               =CL8'ZCMD',=CL8'PROFILE'),VL=1\n         SPACE 1\n*        LTR   R15,R15\n*        BZ    PA$PUTOK\n*        QTILT '*** VPUT RC \u00ac= 0 ***'\n         SPACE 1\n         LINK  EPLOC=PA#ISPLK,MF=(E,PA@PARML),PARAM=(=CL8'VREPLACE',   $\n               =CL8'ZCMD',=A(QDREPLYL),PA@REPLY),VL=1\n         SPACE 1\n         LTR   R15,R15\n         BZ    PA$REPOK\n         QTILT '*** VREPLACE RC \u00ac= 0 ***'\n         SPACE 1\nPA$REPOK LINK  EPLOC=PA#ISPLK,MF=(E,PA@PARML),PARAM=(=CL8'VPUT',       $\n               =CL8'ZCMD',=CL8'SHARED  '),VL=1\n****???? SHOULD THIS BE THE FUNCTION POOL?\n         SPACE 1\n         LTR   R15,R15\n         BZ    PA$PUTOK\n         SH    R1,=H'8'                 BACK UP TO START OF TLD\n         CLC   =C'TLD',0(R1)            DID WE GET THE TLD?\n         BNE   PA$PUTNO                 NO - GIVE REGULAR ERROR MSG\n         MVC   X'28C'(24,R1),QDREPLY+1  YES - SET JUMP DESTINATION\n         B     PA$PUTOK                 AND LEAVE\nPA$PUTNO QTILT '*** VPUT RC \u00ac= 0 ***'\nPA$PUTOK LA    R9,PA#EXIT               USE 'EXIT' SUBCOMMAND ENTRY\n         B     PA$FOUND                 GO PROCESS 'EXIT' SUBCOMMAND\nPA$NOSPF QTILT '*** NOT IN SPF - SORRY...  TRY AGAIN ***'\nPA$BOUNC MVC   QERRMSG(62),=C'*** INVALID SUBCOMMAND \"XXXXXXXX\" - FOR H$\n               ELP, ENTER \"HELP\" ***'\n         MVC   QERRMSG+24(8),QSUBNAME\n         QTILT *,OPTIONS=(REPROMPT,SET)\nPA$FOUND TM    CMD@FLAG,P@P             PRIVILEGED SUBCOMMAND?\n         BNO   PA$ALL                   NO - CONTINUE\n         TM    QXAUTH,QXAUTHX           YES - IS HE AUTHORIZED?\n         BZ    PA$BOUNC                 NO - THE SUBCOMMAND IS INVALID\nPA$ALL   MVC   QCODE(1),CMD@CODE        SUBCMD CODE\n         MVC   QSUBCMD,CMD@ADDR         SUBCMD ADDRESS\n         TM    QISFLAG1,QIS1ISPF        are we in ISPF?\n         BZ    PA$ISPF                  nope - no concern\n         CLC   QSUBCMD,=V(REPOS)        is this reposition?\n         BE    PA$BOUNC                 yes - invalid with browse\nPA$ISPF  DS    0H\n         TM    CMD@FLAG,P@I             REPROMPTABLE INQUIRY COMMAND?\n         BNO   *+10                     NO - SKIP\n         MVC   QINQCMD,QDREPLY          YES - SAVE THE COMMAND LINE\n         NI    QFLAG1,255-Q1VALJOB-Q1LSTCMD-Q1IMMED  RESET FLAGS\n         TM    CMD@FLAG,P@X             EXECUTE THIS SUBCMD IMMED.?\n         BNO   *+8                      NO - SKIP\n         OI    QFLAG1,Q1IMMED           YES - SET FLAG\n*%%%     TM    CMD@FLAG,P@P+P@X         OPERATOR COMMAND ???\n*%%%     BO    PA$FINAL                 IF SO, IGNORE REST\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*  PARSE OUT AND SAVE OPERANDS                                        *\n*                                                                     *\n***********************************************************************\n         LA    R5,QOFF1                 -> FIRST OPERAND SLOT\n         LA    R6,QPARMEND              -> PAST LAST OPERAND SLOT\n         SR    R0,R0                    CLEAR FOR IC\n         IC    R0,CMD@POS               # OF POSIT. OPERANDS ALLOWED\n         SPACE 1\nPA$AGAIN LTR   R2,R2                    ANY MORE INPUT?\n         BNP   PA$VALCK                 NO - EXIT LOOP\n         BAL   R10,PA$TOKEN             GET THE NEXT TOKEN\n         B     PA$VALCK                 EXIT LOOP IF NO MORE OPERANDS\n         TM    PA@FLAG,PA@KEYS          KEYWORD OR RESERVED WORD?\n         BO    PA$KW$RW                 YES - SAVE IT\n*                                       NO - POSITIONAL\n         SH    R0,=H'1'                 COUNT 1 POSITIONAL OPERAND\n         BM    PA$2MANY                 ABORT IF THIS IS ONE TOO MANY\n         MVC   0(12,R5),P@OFFSET        MOVE POSITIONAL STUFF\n         LA    R5,12(,R5)               BUMP TO NEXT POSITIONAL\n         B     PA$MOVED                 CONTINUE\nPA$KW$RW CR    R5,R6                    IS THERE ROOM FOR ANOTHER?\n         BNL   PA$KMANY                 NO - GIVE ERROR MSG\n         MVC   0(8,R5),PA@FIELD         MOVE KEYWORD OR VALUE\n         LA    R5,8(,R5)                INCR TO NEXT FIELD\n         CLI   PA@DELIM,C'='            WAS THIS A KEYWORD= ?\n         BE    PA$KWEQ                  YES - SETUP FOR VALUE\n         TM    PA@FLAG,PA@VALUE         NO - WAS THIS THE KW VALUE?\n         BO    PA$KWOK                  YES - OK\n         LA    R5,8(,R5)                NO - RSRVD WORD - BUMP PAST VAL\n         B     PA$MOVED                 CONTINUE\nPA$KWEQ  TM    PA@FLAG,PA@VALUE         WAS THIS VALUE?\n         BO    PA$KWBAD                 YES - KEYWORD=VALUE= IS INVALID\n         OI    PA@FLAG,PA@VALUE         NO - SET FLAG \"EXPECTING VALUE\"\n         LA    R3,1(,R3)                SKIP OVER '='\n         BCT   R2,PA$MOVED              CONTINUE IF MORE INPUT\n         B     PA$VALCK                 VALIDITY CHECK KEYWORDS ENTERED\n*---  HE ENTERED KEYWORD=VALUE=\nPA$KWBAD MVC   QERRMSG(25),=C'*** SYNTAX ERROR -- VALUE'\n         SH    R5,=H'16'                BACK UP TO KEYWORD\n         MVC   QERRMSG+26(8),8(R5)\n         MVC   QERRMSG+35(10),=C'OF KEYWORD'\n         MVC   QERRMSG+46(8),0(R5)\n         MVC   QERRMSG+55(22),=C'MAY NOT HAVE VALUE ***'\n         QTILT *,OPTIONS=(REPROMPT,SET)\nPA$KWOK  NI    PA@FLAG,X'FF'-PA@VALUE   RESET \"VALUE\" FLAG\nPA$MOVED LTR   R2,R2                    IS THE REMAINING LENGTH ZERO?\n         BZ    PA$VALCK                 YES - VAL. CHECK KEYWDS ENTERED\n         MVC   PA@FIELD,QBLANK          BLANK THE WORK FIELD\n         MVC   P@OFFSET(4),=F'0'        ZERO OUT OFFSET AND LENGTH\n         CR    R5,R6                    WAS THAT THE LAST FIELD?\n         BL    PA$AGAIN                 NO. PROCESS NEXT FIELD.\n         CLI   CMD@POS,X'FF'            IGNORE ERRORS ON POSIT. FIELDS?\n         BE    PA$EXIST                 YES - NOTHING MORE I CAN DO\n         B     PA$AGAIN                 PROCESS NEXT OPERAND TOKEN\n*A$2MANY TM    PA@FLAG,PA@KEYS          ALREADY PROCESSING KEYWORDS?\n*%%%     BO    PA$PMANY                 YES - ERROR\nPA$2MANY CLI   CMD@POS,0                ANY POSITIONALS ALLOWED?\n         BNE   PA$PMANY                 YES - HE ENTERED TOO MANY\n         OI    PA@FLAG,PA@KEYS          NO - SO PROCESS KEYWORDS!\n         LA    R5,QKEYWORD              -> FIRST SLOT FOR KEYWORDS\n         LA    R6,QKEYLAST              -> PAST LAST SLOT\n         B     PA$KW$RW                 GO SAVE THIS KEYWORD\nPA$PMANY QTILT '*** TOO MANY POSITIONAL OPERANDS FOR SUBCOMMAND ***',  $\n               OPTIONS=(REPROMPT,SET)\nPA$KMANY QTILT '*** TOO MANY KEYWORD AND/OR RESERVED WORD OPERANDS ***'$\n               ,OPTIONS=(REPROMPT,SET)\n***********************************************************************\n*                                                                     *\n*   SUBROUTINE TO GET THE NEXT TOKEN FROM THE INPUT LINE              *\n*                                                                     *\n***********************************************************************\nPA$TOKEN MVC   PA@FIELD,QBLANK          CLEAR THE WORK FIELD\n         LA    R4,PA@FIELD              FIRST BYTE OF WORK FIELD\n         MVI   PA@DELIM,C' '            INIT IN CASE RUN OFF END OF INP\nPA$BLANK CLI   0(R3),C' '               FIND A NON BLANK YET?\n         BE    PA$SKIP                  NO - KEEP LOOKING\n         LTR   R5,R5                    DOING SUBCOMMAND NAME?\n         BZ    PA$FIRST                 YES - BYPASS '/' TEST\n         CLI   CMD@POS,X'FF'            IGNORE ERRORS IN POSIT OPRNDS?\n         BE    PA$FIRST                 YES - BYPASS '/' TEST\n         CLI   0(R3),C'/'               START OF RESERVED WORDS INDIC?\n         BNE   PA$FIRST                 NO. START OF FIELD.\n         TM    PA@FLAG,PA@KEYS          \"END OF POSITS\" ALREADY SET?\n         BO    PA$DBL                   YES - SYNTAX ERROR\n         OI    PA@FLAG,PA@KEYS          NO - SET IT NOW\n         LA    R5,QKEYWORD              -> FIRST SLOT FOR KEYWORDS\n         LA    R6,QKEYLAST              -> PAST LAST SLOT\nPA$SKIP  LA    R3,1(,R3)                YES. SKIP IT.\n         BCT   R2,PA$BLANK              TRY NEXT BYTE\n         BR    R10                      RETURN TO \"NOTHING FOUND\"\nPA$DBL   QTILT '*** SYNTAX ERROR - TWO SLASHES FOUND, OR SLASH AFTER KE$\n               YWORD ***',OPTIONS=(REPROMPT,SET)\nPA$FIRST LH    R1,QDRLNG                REPLY LENGTH\n         SR    R1,R2                    COMPUTE OFFSET TO FIELD START\n         STH   R1,P@OFFSET              STORE OFFSET\n         LR    R1,R2                    SAVE COUNT OF REMAINING BYTES\n         LTR   R5,R5                    DOING SUBCOMMAND NAME?\n         BZ    PA$CHAR                  YES - skip this other stuff\n         CLI   CMD@POS,X'FF'            IGNORE ERRORS IN POSIT OPERNDS?\n         BNE   PA$CHAR                  NO - CONTINUE\n         OC    QOFF1,QOFF1              ARE WE WORKING ON FIRST OPERND?\n         BNZ   PA$CHAR                  NO - SKIP\n         MVC   QOFF1,P@OFFSET           YES - SAVE ITS OFFSET\n         B     PA$CHAR                  CONTINUE\n         SPACE 1\nPA$LOOP  CLI   0(R3),C' '               IS THIS BYTE BLANK?\n         BE    PA$LAST                  YES. END OF FIELD.\n         CLI   0(R3),C'='               START OF KEYWORD VALUE?\n         BNE   PA$CHAR                  NO - MOVE THIS CHAR\n         TM    PA@FLAG,PA@KEYS          ALREADY PROCESSING KEYWORDS?\n         BO    PA$LAST                  YES - OK\n         CLI   CMD@POS,X'FF'            IGNORE ERRORS IN POSIT OPERNDS?\n         BE    PA$IGNOR                 YES - BAIL OUT\n         OI    PA@FLAG,PA@KEYS          INDICATE NOW PROCESSING KEYWDS\n         LA    R5,QKEYWORD              -> FIRST SLOT FOR KEYWORDS\n         LA    R6,QKEYLAST              -> PAST LAST SLOT\n         B     PA$LAST\nPA$IGNOR OC    QOFF1,QOFF1              ARE WE WORKING ON FIRST OPERND?\n         BNZ   PA$VALCK                 NO\n         MVC   QOFF1,P@OFFSET           YES - SAVE ITS OFFSET\n         B     PA$VALCK                 NO FURTHER OPERAND PROCESSING\nPA$CHAR  MVC   0(1,R4),0(R3)            MOVE ONE BYTE OF FIELD\n         LA    R3,1(,R3)                INCREMENT 'FROM'\n         LA    R4,1(,R4)                INCREMENT 'TO'\n         BCT   R2,PA$LOOP               TRY NEXT BYTE\n         B     *+10     >=======+       DON'T SAVE DELIM IF RUN OFF END\nPA$LAST  MVC   PA@DELIM,0(R3)   |       SAVE THE DELIM (BLANK OR SLASH)\n         SR    R1,R2    <=======+       COMPUTE FIELD LENGTH\n         CH    R1,=H'8'                 IS LENGTH GREATER THAN 8?\n         BNH   *+8                      NO. USE IT.\n         LA    R1,8                     YES. USE LENGTH OF EIGHT.\n         STH   R1,P@LENGTH              STORE FIELD LENGTH\n         B     4(,R10)                  RETURN TO CALLER\n***********************************************************************\n*                                                                     *\n*   VALIDITY CHECK KEYWORDS AND RESERVED WORDS ENTERED                *\n*                                                                     *\n***********************************************************************\nPA$VALCK CL    R12,QSUBCMD              POINT TO ME???\n         BE    PA$PSWD                  YES - MUST BE \"XP\" SUBCOMMAND\n         L     R2,CMD@KEYS              SUBCMD'S VALID KEYWORD TABLE\n         LTR   R2,R2                    ANY?\n         BZ    PA$VALNO                 NO - NONE ALLOWED\n         LA    R3,QKEYWORD              -> FIRST ONE ENTERED\n         LA    R4,QKEYLAST              -> PAST LAST ONE POSSIBLE\nPA$VALL1 CLI   0(R3),C' '               ANY WORD HERE?\n         BE    PA$FINAL                 NO - DONE HERE\n         CLC   0(8,R3),0(R2)            YES - IS IT VALID?\n         BE    PA$VALL2                 YES - CHECK NEXT\n         LA    R2,8(,R2)                -> NEXT VALID KEYWORD\n         CLI   0(R2),X'FF'              END OF TABLE?\n         BNE   PA$VALL1                 NO - SEE IF IT'S THIS ONE\n         MVC   QERRMSG(21),=C'*** INVALID KEYWORD -'\n         MVC   QERRMSG+22(8),0(R3)\n         MVC   QERRMSG+31(18),=C'- FOR SUBCOMMAND -'\n         MVC   QERRMSG+50(8),QSUBNAME\n         MVC   QERRMSG+59(3),=C'***'\n         QTILT *,OPTIONS=(REPROMPT,SET)\nPA$VALL2 LA    R3,16(,R3)               -> NEXT WORD TO CHECK\n         CR    R3,R4                    DONE CHECKING?\n         BNL   PA$FINAL                 YES - DONE\n         L     R2,CMD@KEYS              -> VALID KEYWORD TABLE\n         B     PA$VALL1                 CHECK NEXT KEYWORD\nPA$VALNO CLI   QKEYWORD,C' '            ANY KEYWORDS OR RESERVED WORDS?\n         BE    PA$FINAL                 NO - OK, DONE HERE\n         MVC   QERRMSG(54),=C'*** KEYWORDS NOT ALLOWED FOR \"XXXXXXXX\" S$\n               UBCOMMAND ***'\n         MVC   QERRMSG+30(8),QSUBNAME\n         QTILT *,OPTIONS=(REPROMPT,SET)\n***********************************************************************\n*                                                                     *\n*   DO FINAL PROCESSING OF OPERANDS IF REQUIRED                       *\n*                                                                     *\n***********************************************************************\nPA$FINAL NI    QFLAG2,255-Q2REPOS       ASSUME NOT REPOSITIONING SUBCMD\n         TM    CMD@FLAG,P@R             IS IT?\n         BNO   *+8                      NO - OK\n         OI    QFLAG2,Q2REPOS           YES - SET FLAG\n         TM    CMD@FLAG,P@J+P@A         IS PARM1 A <JOBID> ?\n         BZ    PA$EXIST                 NO - SKIP\n         TM    CMD@FLAG,P@V             SUBCMD REQUIRE ACCESS TO JOB?\n         BNO   *+8                      NO - SKIP\n         OI    QFLAG1,Q1VALJOB          YES - SET FLAG\n         TM    CMD@FLAG,P@L             LIST TYPE SUBCMD?\n         BNO   *+8                      NO - SKIP\n         OI    QFLAG1,Q1LSTCMD          YES - FLAG FOR LATER\n         CLC   =C'* ',QPARM1            REQUEST PREVIOUS JOB?\n         BE    USE$PREV                 YES - GO RESTORE IT\n         TM    CMD@FLAG,P@A             ACTION COMMAND?\n         BO    P$ACTION                 YES - DON'T ALLOW BLANK JOBNAME\n         CLC   QPARM1,QBLANK            ANOTHER WAY TO SELECT PREVIOUS?\n         BE    USE$PREV                 YES - GO RESTORE IT\nP$ACTION CLI   QLNG1+1,1                PARM LENGTH = 1?\n         BNE   PA$EXIST                 NO - DONE\n         IC    R15,QPARM1               YES - SAVE THE CHARACTER\n         MVC   QPARM1(7),QLOGON         MOVE IN USERID\n         SR    R1,R1                    CLEAR FOR IC\n         IC    R1,QLOGONL               GET LENGTH OF USERID\n         STC   R15,QPARM1(R1)           SET CHARACTER AT END OF USERID\n         LA    R1,1(,R1)                BUMP LENGTH\n         STH   R1,QLNG1                 SAVE NEW LENGTH\n         B     PA$EXIST                 DONE\nUSE$PREV MVC   QLNG1(2+8),QJOBID        RESTORE PREVIOUS JOBID & LENGTH\n         SPACE 2\nPA$EXIST CLC   =F'0',CMD@ADDR           IS SUBCOMMAND LINKED IN?\n         BNE   QSTOP                    YES - OK\n         MVC   QERRMSG(50),=C'*** \"XXXXXXXX\" SUBCOMMAND IS NOT YET AVAI$\n               LABLE ***'\n         MVC   QERRMSG+5(8),QSUBNAME\n         QTILT *,OPTIONS=(REPROMPT,SET)\n***********************************************************************\n*                                                                     *\n*   PROMPT FOR SECRET PASSWORD (\"XP\" SUBCOMMAND)                      *\n*                                                                     *\n***********************************************************************\nPA$PSWD  CLC   QPARM1,=C'PASSWORD'      DID THE USER SAY PASSWORD?\n         BNE   PA$BOUNC                 NO. REJECT.\n         SPACE 1\n         TPUT  WPASS,L'WPASS,FULLSCR\n         SPACE 1\n         LA    R1,RPASS                 REPLY ADDRESS\n         SPACE 1\n         TGET  (1),8\n         SPACE 1\n         CLC   RPASS,=C'YES SIR!'       IS THE PASSWORD CORRECT?\n         BNE   PA$BOUNC                 NO. REJECT.\n         XI    QXAUTH,QXPSWD            AUTHORIZE USER (OR UNDO IT)\n         QTILT '=== PASSWORD ACCEPTED ==='\n***********************************************************************\n*                                                                     *\n*   MISCELLANY                                                        *\n*                                                                     *\n***********************************************************************\nWPASS    DC    X'C1115D7F1140403C4040001D4C13'  *** SPF TCAM\nPA#ISPLK DC    CL8'ISPLINK'\n         LTORG\n         SPACE 2\nWORK     DSECT\n         ORG   WORK+72                  SKIP OVER SAVE AREA\nPA@FLAG  DS    X\nPA@KEYS  EQU   X'01'                    NOW PROCESSING KEYWORDS/RSRVD\nPA@VALUE EQU   X'02'                    NOW PROCESSING VALUE\nPA@DELIM DS    C\nP@OFFSET DS    H\nP@LENGTH DS    H\nPA@FIELD DS    CL8\n*---  BE CAREFUL PUTTING THINGS AFTER PA@FIELD BECAUSE THE TOKENIZER\n*---  DOESN'T STOP AT 8 CHARACTERS IF THE USER ENTERS MORE\nRPASS    DS    CL8\n*PA@REPLY DS   CL(QDREPLYL)\nPA@REPLY DS    CL66                     STUPID ASMF\n         SPACE 2\nPA@PARML DS    0A                       PARM LIST FOR ISPLINK CALL\nPA@SERVP DS    A                        -> SERVICE NAME\nPA@PARM1 DS    A                        -> 1ST PARM\nPA@PARM2 DS    A                        -> 2ND PARM\nPA@PARM3 DS    A                        -> 3RD PARM\nPA@PARM4 DS    A                        -> 3RD PARM\n         SPACE 1\nPA@OPTLN DS    F                        LENGTH OF CMD LINE INPUT\nPA@WORKL EQU   *-WORK                   length of PARSE's workarea\n         SPACE 2\n         DROP  R13,R9\n         EJECT\nQCMDE    DSECT\nCMD@ADDR DS    A                        V-CON OF SUBROUTINE\nCMD@KEYS DS    A                        V-CON OF KEYWORD/RSRVD WORD TBL\nCMD@FLAG DS    B                        FLAGS\nP@J       EQU   X'80'                    FIRST OPERAND IS JOBID\nP@A       EQU   X'40'                    SAME AS ABOVE FOR ACTION CMD\n*                                        (DO NOT ALLOW BLNK FOR ACTION)\nP@I       EQU   X'20'                    RE-EXECUTABLE INQUIRY COMMAND\nP@P       EQU   X'10'                    SUBCOMMAND IS PRIVILEGED\nP@V       EQU   X'08'                    VERIFY ACCESS TO JOB\nP@L       EQU   X'04'                    LIST TYPE SUBCMD (\"READ ONLY\")\nP@X       EQU   X'02'                    EXEC THIS SUBCMD IMMEDIATELY\n*                                        IN \"DISPLAY\" & RETURN TO PREV\nP@R       EQU   X'01'                    REPOSITIONING SUBCOMMAND\nCMD@POS  DS    AL1                      MAXIMUM NUMBER OF POSITIONALS\n*                                       X'FF' = DON'T CHECK\nCMD@CODE DS    AL1                      INTERNAL FUNC CODE FOR ROUTINE\nCMD@NUM  DS    AL1                      NUMBER OF SUBCMD NAMES HERE\nCMD@CMD  DS    CL4                      SUBCOMMAND NAME\n*---  CMD@CMD OCCURS CMD@NUM TIMES\nCMD@ENTL EQU   *-QCMDE                  LENGTH OF TABLE ENTRY\n         SPACE 3\n*---  FORMAT OF QCMDE ENTRIES:\n*  ROUTINE_NAME  QCMDE  FUNC_CODE,MAX_POSIT_OPRNDS,(CMD,ALIAS1,...),\n*                       F=FLAG1+FLAG2+...,KEYS=KEY_TABLE_NAME\n         SPACE 2\nPARSE    CSECT                          RESUME AFTER DSECT\nPA#TABLE DC    0D'0'\n         SPACE 2\nSEARCH   QCMDE 00,1,(STATUS,ST),F=P@I,KEYS=ST#KEYS\nSEARCH   QCMDE 04,0,DA,F=P@I,KEYS=DA#KEYS\nSEARCH   QCMDE 08,2,DI,F=P@I,KEYS=DI#KEYS\nSEARCH   QCMDE 12,2,DO,F=P@I,KEYS=DO#KEYS\nSEARCH   QCMDE 16,2,AI,F=P@I,KEYS=DI#KEYS\nSEARCH   QCMDE 20,2,AO,F=P@I,KEYS=DO#KEYS\nSEARCH   QCMDE 24,2,HI,F=P@I,KEYS=DI#KEYS\nSEARCH   QCMDE 28,0,DH,F=P@I,KEYS=DH#KEYS\nSEARCH   QCMDE 32,0,DT,F=P@I,KEYS=DA#KEYS\nSEARCH   QCMDE 36,1,DJ,F=P@I+P@J,KEYS=DJ#KEYS\nSEARCH   QCMDE 36,1,XJ,F=P@J+P@P\nSEARCH   QCMDE 40,0,DS,F=P@I,KEYS=DA#KEYS\nSEARCH   QCMDE 44,1,DQ,F=P@I,KEYS=DQ#KEYS\nSEARCH   QCMDE 48,0,(DEVICES,DEV),F=P@I\nSEARCH   QCMDE 52,0,DN,F=P@I,KEYS=DN#KEYS\nSEARCH   QCMDE 56,0,(NJE,NJ),F=P@I\nFORMAT   QCMDE 100,1,XJQE,F=P@P\nFORMAT   QCMDE 104,1,XJOE,F=P@P\nCPU      QCMDE   ,2,(CPU,DC),F=P@I\nSYSOUT   QCMDE 00,1,(DELETE,DEL),F=P@A+P@V\nSYSOUT   QCMDE 04,2,(REQUEUE,REQ),F=P@A+P@V\nSYSOUT   QCMDE 08,2,(CANCEL,CAN,CJ),F=P@A+P@V\nJOBINFO  QCMDE 00,1,(JOB,JD),F=P@J+P@I\nJOBINFO  QCMDE 04,1,(JOBX,JDX),F=P@J+P@I+P@P\nDDNAME   QCMDE 00,1,DD,F=P@J+P@V+P@L\nDDNAME   QCMDE 04,1,(SJ,S),F=P@J+P@V+P@L,KEYS=SJ#KEYS\nLISTTEXT QCMDE   ,1,LTXT,F=P@J+P@V+P@L+P@P\nLIST     QCMDE 00,3,(LIST,L,LI),F=P@J+P@V+P@L,KEYS=LI#KEYS\nLIST     QCMDE 04,1,(JCL,JC),F=P@J+P@V+P@L,KEYS=LI#KEYS\nLIST     QCMDE 08,1,(JLOG,JL),F=P@J,KEYS=LI#KEYS\nLIST     QCMDE 12,1,(JMSG,JM),F=P@J+P@V+P@L,KEYS=LI#KEYS\nLIST     QCMDE 16,0,NS,KEYS=NS#KEYS\nLIST     QCMDE 16,0,PS\n*%%%LIST QCMDE 16,1,LL\nLIST     QCMDE 20,3,(ELIST,EL),F=P@J+P@V+P@L\nATTR     QCMDE 00,2,(ATTR,AT),F=P@J,KEYS=AT#KEYS\nATTR     QCMDE 04,2,PDDB,F=P@J+P@P\nJOBSUMM  QCMDE   ,1,(JS,J,JSUMM),F=P@J\nJESNEWS  QCMDE 00,0,(JNEWS,JN)\nSAVEDS   QCMDE 04,1,SAVE,KEYS=SV#KEYS\nSYSLOG   QCMDE 00,2,(SLOG,SL),F=P@P\nINITS    QCMDE   ,0,(INIT,IN),F=P@I,KEYS=IN#KEYS\nRMTLIST  QCMDE   ,0,LRMT,F=P@I\nSYSLIST  QCMDE   ,0,LSYS,F=P@I+P@P\nBLKLIST  QCMDE   ,1,LBLK,F=P@I+P@P+P@J\nLISTDAS  QCMDE   ,0,LDAS,F=P@P\nLISTKIT  QCMDE   ,0,LKIT,F=P@P\nHEXBLK   QCMDE 00,2,(XBLK,XB),F=P@P,KEYS=HB#KEYS\nHEXBLK   QCMDE 04,2,XJCT,F=P@J+P@P\nHEXBLK   QCMDE 08,1,XHCT,F=P@P\nHEXBLK   QCMDE 12,1,XQCMN,F=P@P\nHEXBLK   QCMDE 16,1,XCKPT,F=P@P\nCBFMT    QCMDE 00,3,CB,F=P@P+P@J,KEYS=CB#KEYS\nCBFMT    QCMDE 04,1,QCMN,F=P@P,KEYS=CB#KEYS\nCBFMT    QCMDE 08,1,CKPT,F=P@P,KEYS=CB#KEYS\nCBFMT    QCMDE 12,1,HCT,F=P@P,KEYS=CB#KEYS\nCBFMT    QCMDE 16,0,JOT,F=P@P,KEYS=CB#KEYS\nCBFMT    QCMDE 20,2,JCT,F=P@P,KEYS=CB#KEYS\nCBFMT    QCMDE 24,1,JQE,F=P@P,KEYS=CB#KEYS\nCBFMT    QCMDE 28,1,JOE,F=P@P,KEYS=CB#KEYS\nREPOS    QCMDE 04,N,(FIND,F)\nREPOS    QCMDE 04,N,(FALL,FA)\nREPOS    QCMDE 08,1,(FTIME,FT)\nREPOS    QCMDE 12,1,(COLUMN,COL,C),F=P@R\nREPOS    QCMDE 16,1,(@,MD)\nREPOS    QCMDE 20,1,(+,DOWN,D),F=P@R\nREPOS    QCMDE 44,1,PF,F=P@R\nREPOS    QCMDE 48,1,HF,F=P@R\nREPOS    QCMDE 24,1,(-,UP,U),F=P@R\nREPOS    QCMDE 52,1,PB,F=P@R\nREPOS    QCMDE 56,1,HB,F=P@R\nREPOS    QCMDE 28,0,(TOP,T),F=P@R\nREPOS    QCMDE 32,0,(BOTTOM,BOT,B),F=P@R\nREPOS    QCMDE 36,1,(LEFT,LE),F=P@R\nREPOS    QCMDE 40,1,(RIGHT,RI),F=P@R\nREPOS    QCMDE 60,0,(REDISP,RD)\nREPOS    QCMDE 64,1,(PAGE,P),F=P@R\n          AIF   (NOT &@@TMPSV).PARSE01\nTSOCMD   QCMDE   ,N,TSO,F=P@X\n.PARSE01  ANOP\nMCS      QCMDE   ,1,(CONS,MCS),F=P@P+P@I\nMODE     QCMDE 00,0,MODE,F=P@X,KEYS=MO#KEYS\nMODE     QCMDE 04,0,COLS,KEYS=COL#KEYS\nQINNARDS QCMDE   ,0,QINT,F=P@X,KEYS=QI#KEYS\nPRINT    QCMDE 00,2,(PRINT,PR),F=P@X,KEYS=PR#KEYS\nPRINT    QCMDE 04,2,(COPY,CY),F=P@X,KEYS=PR#KEYS\nPRINT    QCMDE 08,2,SPIN,F=P@X,KEYS=PR#KEYS\nSETUP    QCMDE   ,1,(SETUP,SU),F=P@J\nOPERCMD  QCMDE 12,2,(ROUTE,ROU,RJ),F=P@V+P@A\nOPERCMD  QCMDE 16,1,(HOLD,HJ),F=P@P+P@A\nOPERCMD  QCMDE 20,1,(RELEASE,REL,AJ),F=P@P+P@A\nOPERCMD  QCMDE 24,1,(PURGE,PUR,PJ),F=P@V+P@A\nOPERCMD  QCMDE 32,1,TJ,F=P@P+P@A,KEYS=TJ#KEYS\nOPERCMD  QCMDE 36,1,EJ,F=P@P+P@A\nPA#CMDX  EQU   *\nOPERCMD  QCMDE 28,N,//,F=P@P+P@X\nOPERCMD  QCMDE 28,N,||,F=P@P+P@X\nTGPS     QCMDE   ,0,(SPSP,TGPS),F=P@P\nPFKSET   QCMDE   ,N,PFK,F=P@X\nHELP     QCMDE   ,1,(HELP,H,?),KEYS=HE#KEYS\nCHANGES  QCMDE   ,0,CHGS,KEYS=CH#KEYS\nPA#EXIT  EQU   *\nEXIT     QCMDE 04,N,(END,E)\nEXIT     QCMDE 00,0,(EXIT,STOP,QUIT,RETURN,RET,=X)\nRECALL   QCMDE   ,0,(RECALL,RC,RETRIEVE,RE),F=P@X,KEYS=RC#KEYS\nSPFFUNC  QCMDE 00,1,(ED,EDIT),F=P@X,KEYS=SF#KEYS\nSPFFUNC  QCMDE 04,1,(BR,BROWSE),F=P@X,KEYS=SF#KEYS\nABEND    QCMDE   ,0,ABEND\nPARSE    QCMDE   ,1,XP\n         DC    X'FF000000'              END OF COMMAND TABLE\n         SPACE 2\n*---  SPECIAL USE ENTRIES\nPA#CMD   EQU   *\nOPERCMD  QCMDE 00,N,/,F=P@P+P@X\nPA#CMDQ  EQU   *\nOPERCMD  QCMDE 04,N,|,F=P@P+P@X\nPA#CMDJ  EQU   *\nOPERCMD  QCMDE 08,N,$,F=P@P+P@X\n         EJECT\n*---  LINE COMMAND TABLES                                          ---*\n*---  FORMAT IS DESCRIBED BY LCTABLE DSECT IN QCOMMON MACRO        ---*\n         SPACE 1\n*---  TABLE FOR 'DD' DISPLAY SCREEN                                ---*\n         ENTRY PA#LC#DD\nPA#LC#DD DC    C'L ',C'LIST',AL1(LCTFDD+LCTFDCMD)\n         DC    C'S ',C'LIST',AL1(LCTFDD+LCTFDCMD)\n**??%%%  DC    C'? ',C'LIST',AL1(LCTFDD+LCTFDCMD)\n         DC    C'EL',C'ELIS',AL1(LCTFDD+LCTFDCMD)\n         DC    C'A ',C'ATTR',AL1(LCTFDD+LCTFDCMD)\n         DC    C'AT',C'ATTR',AL1(LCTFDD+LCTFDCMD)\n         DC    X'FF'                    END OF TABLE\n         SPACE 2\n*---  TABLE FOR 'FORMAT' DISPLAY SCREEN                            ---*\n         ENTRY PA#LC#FM\nPA#LC#FM DC    C'DJ',C'DJ  ',AL1(LCTFDCMD)\n         DC    C'XJ',C'XJ  ',AL1(LCTFDCMD+LCTFPRIV)\n         DC    C'JS',C'JS  ',AL1(LCTFDCMD)\n         DC    C'J ',C'JS  ',AL1(LCTFDCMD)\n         DC    C'DE',C'DEL ',AL1(0)\n         DC    C'DL',C'DEL ',AL1(0)\n         DC    C'RE',C'REQ ',AL1(0)\n         DC    C'RQ',C'REQ ',AL1(0)\n         DC    C'CA',C'CAN ',AL1(0)\n         DC    C'CJ',C'CAN ',AL1(0)\n         DC    C'JD',C'JOB ',AL1(LCTFDCMD)\n         DC    C'JX',C'JOBX',AL1(LCTFDCMD+LCTFPRIV)\n         DC    C'SJ',C'SJ  ',AL1(LCTFDCMD)\n         DC    C'S ',C'SJ  ',AL1(LCTFDCMD)\n         DC    C'DD',C'DD  ',AL1(LCTFDCMD)\n         DC    C'? ',C'DD  ',AL1(LCTFDCMD)\n         DC    C'LT',C'LTXT',AL1(LCTFDCMD+LCTFPRIV)\n         DC    C'L ',C'LIST',AL1(LCTFDCMD)\n         DC    C'JC',C'JCL ',AL1(LCTFDCMD)\n         DC    C'JL',C'JLOG',AL1(LCTFDCMD)\n         DC    C'JM',C'JMSG',AL1(LCTFDCMD)\n         DC    C'SL',C'SLOG',AL1(LCTFDCMD)\n         DC    C'LB',C'LBLK',AL1(LCTFDCMD+LCTFPRIV)\n         DC    C'JT',C'JCT ',AL1(LCTFDCMD+LCTFPRIV)\n         DC    C'SU',C'SETU',AL1(LCTFDCMD)\n         DC    C'R ',C'RJ  ',AL1(0)\n         DC    C'RJ',C'RJ  ',AL1(0)\n         DC    C'H ',C'HJ  ',AL1(0)\n         DC    C'HJ',C'HJ  ',AL1(0)\n         DC    C'A ',C'AJ  ',AL1(0)\n         DC    C'AJ',C'AJ  ',AL1(0)\n         DC    C'T ',C'TJ  ',AL1(0)\n         DC    C'TJ',C'TJ  ',AL1(0)\n         DC    C'PJ',C'PJ  ',AL1(0)\n         DC    C'EJ',C'EJ  ',AL1(0)\n         DC    X'FF'                    END OF TABLE\n         SPACE 2\n         QCOMMON\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "Q#PA@": {"ttr": 13572, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05-\\x00\\x00\\x00\\x82#/\\x00\\x90\\x00_\"\\x16\\x02\\x9b\\x01\\t\\x02B\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "05.45", "flags": 0, "createdate": "1982-08-20T00:00:00", "modifydate": "1990-01-05T22:16:00", "lines": 667, "newlines": 265, "modlines": 578, "user": "LDW"}, "text": "         TITLE '--- QUEUE--PARSE -- COMMAND LINE PARSE ROUTINES ---'\n*---------------------------------------------------------------------*\n*                                                                     *\n*   PARSE - Parse the input subcommand                                *\n*                                                                     *\n*   Entry - New subcommand and operands in \"QDREPLY\"                  *\n*                                                                     *\n*   Exit - All kinds of fields filled in and bits set (in QCOMMON)    *\n*                                                                     *\n*   Updates:                                                          *\n*      05Jan90  LDW  Add LKIT and LDAS subcommands                    *\n*      15May89  EMS  Add WORKLEN to QSTART macro just in case         *\n*      25May89  LDW  Add DOWN command (just had D before!)            *\n*      30May88  LDW  Add JQE and JOE subcommands (like XJ, but by     *\n*                       offset)                                       *\n*      10Apr88  LDW  Fix PA$TOKEN bug when scanning for subcmd name   *\n*                    Correct PDDB entry                               *\n*      17Jul87  EMS  Add 'PAGE' (alias 'P')                           *\n*                    Add 'PDDB' command (per LDW)                     *\n*      17Jan87  LDW  ADD 'SPSP' (alias 'TGPS')                        *\n*      27AUG86  LDW  ADD 'ATTR'                                       *\n*      04/07/86 LDW  ADD 'RETRIEVE' & 'RE' AS ALIASES FOR 'RECALL'    *\n*                       FOR COMPATIBILITY WITH VM                     *\n*                    REMOVE '*' COMMAND (OLD 'RECALL')                *\n*                    ADD IN#KEYS                                      *\n*      04/03/86 LDW  USE SPECIFIC BIT NAMES IN QDEBUG                 *\n*      12/02/85 LDW  ADD J ALIAS FOR JS, ADD TO LINE COMMANDS TABLE   *\n*      01/30/85 LDW  ADD SJ#KEYS REFERENCE                            *\n*      08/30/84 LDW  SET &ZCMD INSTEAD OF &OPT IF '=AAA'              *\n*      03/27/84 LDW  MOVE CALL TO 'DISPCHG' TO 'QUEUE' MAINLINE       *\n*                    ADD 'JS' SUBCOMMAND                              *\n*      01/27/84 LDW  ADD 'PS' SUBCOMMAND                              *\n*      01/23/84 LDW  ADD 'SJ', 'NS', 'COLS' SUBCOMMANDS               *\n*      12/20/83 LDW  ADD KEYS= TO 'DJ'                                *\n*      11/29/83 LDW  ADD 'EJ' SUBCOMMAND (LINE CMD  'EJ')             *\n*      10/30/83 LDW  ADD 'TJ' SUBCOMMAND (LINE CMDS 'TJ' AND 'T')     *\n*      09/07/83 LDW  ADD 'S' AS LINE COMMAND ALIAS OF 'DD'            *\n*      03/17/83 LDW  ADD MORE ALIASES FOR \"STOP\"                      *\n*                    CHANGE \"END\" TO FUNC=04                          *\n*                    ADD \"RECALL\" (\"RC\") AS PRIMARY NAME FOR \"*\",     *\n*                       CHANGE REPROMPT, STARKEYS TO RECALL, RC#KEYS  *\n*                    ADD KEYS=SV#KEYS, CHANGE MAX POSITS TO 1         *\n*      03/09/83 LDW  ADD KEYS= TO \"HELP\"                              *\n*      03/02/83 LDW  CHANGE 'QTILT *' TO USE QERRMSG                  *\n*                    ENHANCED ERROR MESSAGES                          *\n*      02/24/83 LDW  ADD LINE COMMAND TABLES                          *\n*      02/09/83 LDW  MORE FIDDLING WITH =XXX CODE                     *\n*      02/08/83 LDW  DELETE \"DHX\", CHANGE \"DH\" TO KEYS=DH#KEYS,       *\n*                       CHANGE MAX POSIT OPERANDS FOR \"DH\" TO ZERO    *\n*      02/07/83 LDW  IF INVOKED FROM WITHIN SPF AND '=COMMAND' IS     *\n*                       ENTERED, SET &OPT AND FAKE OUT AN EXIT CMD    *\n*                       NOTE:  SINCE THIS DOESN'T WORK YET, IT IS     *\n*                       UNDER CONTROL OF A QDEBUG FLAG                *\n*      02/03/83 LDW  CHANGE \"RD\" FROM LISTDS TO REPOS                 *\n*                    CHANGE QDINQCMD TO QINQCMD, DELETE QDINQLEN      *\n*                    MAKE USE OPTIONS=SET ON QTILT                    *\n*                    FIX BUG WHICH CAUSED '/ABC      DEF=XYZ' TO FAIL *\n*      02/02/83 LDW  ADD KEYS= TO \"CHGS\"                              *\n*                    ADD \"COPY\"                                       *\n*      01/31/83 LDW  FIX 3278-3 & -4 HANDLING                         *\n*      01/19/83 LDW  SET QTPAGEX AND QTHALFX WHEN APPROPRIATE         *\n*      01/12/83 LDW  MOVE STARKEYS TO \"DISPLAY\"                       *\n*      01/06/83 LDW  ADD \"LTXT\"                                       *\n*                    FIX BUG WHICH CAUSED \"KEYWORDS NOT ALLOWED\" MSG  *\n*                       TO BE ISSUED INSTEAD OF \"TOO MANY POSITIONAL  *\n*                       OPERANDS\" MSG                                 *\n*      01/05/83 LDW  ALTER CHECK FOR LARGE SCREEN MODE                *\n*                    IMPROVE CHECKING FOR MVS AND JES2 COMMANDS       *\n*                    MORE FIXES TO \"DON'T CHECK OPERANDS\" CASE        *\n*                    ADD KEYS= TO MODE, QINT, XB                      *\n*                    CHANGE NBR OF POSITS ALLOWED TO 0 FOR MODE, QINT *\n*                    SET Q2REPOS IF REPOSITIONING SUBCOMMAND          *\n*                    ADD EDIT, BROWSE, REDISP, HCT, QCMN, CKPT        *\n*                    CHANGE 'F' OPERAND OF \"*\" TO KEYWORD             *\n*      12/21/82 LDW  ONLY GENERATE ENTRY FOR \"CONS\" IF &QTMPMAC=1     *\n*                    ADD \"QINT\"                                       *\n*                    IF NO POSITIONAL OPERANDS ALLOWED, MAKE SLASH    *\n*                       IN FRONT OF FIRST RESERVED WORD OPTIONAL      *\n*      12/17/82 LDW  CLEAR QDHLINE BEFORE MOVING IN ERROR MESSAGES    *\n*                    CHANGE NUMBER OF POSITIONAL OPERANDS ALLOWED TO  *\n*                       ZERO FOR DA, DS, DT (KEYWORDS NOW SUPPORTED)  *\n*      12/15/82 LDW  ADD SUPPORT FOR RESERVED WORD AND KEYWORD=VALUE  *\n*                       OPERANDS                                      *\n*                    CHECK FOR TOO MANY POSITIONAL OPERANDS FOR       *\n*                       GIVEN SUBCOMMAND                              *\n*                    RE-ARRANGE OPERANDS ON QCMDE MACRO               *\n*                    ADD \"DN\" AND \"CHGS\" SUBCOMMANDS                  *\n*                    PUT IN CHECK FOR SUBCOMMAND NOT EXISTING         *\n*      12/10/82 LDW  CHANGE \"SAVE\" TO \"SAVEDS\" TO AVOID ASSEMBLY      *\n*                       PROBLEMS WITH NJE                             *\n*      12/08/82 LDW  USE \"QPARMEND\" INSTEAD OF \"QOFF4+12\"             *\n*      10/21/82 LDW  CHANGE \"HO\" TO \"DH\", \"XHO\" TO \"DHX\"              *\n*      08/30/82 LDW  ADD \"LBLK\" SUBCOMMAND                            *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 3\nPARSE    QSTART  Q16,WORKLEN=PA@WORKL\n         USING WORK,R13                 BASE REG FOR LOCAL WORK AREA\n***********************************************************************\n*                                                                     *\n*   PARSE SUBCOMMAND NAME                                             *\n*                                                                     *\n***********************************************************************\n         LH    R2,QDRLNG                LENGTH OF REPLY LINE\n         LTR   R2,R2                    ANY INPUT?\n         BNP   QSTOP                    NO - SO LEAVE\n         MVC   PA@REPLY(QDREPLYL),QDREPLY  COPY THE INPUT COMMAND\n         OC    PA@REPLY(QDREPLYL),QBLANK   TRANSLATE TO UPPER CASE\n         CLC   PA@REPLY(QDREPLYL),QBLANK   IS THE ENTIRE REPLY BLANK?\n         BE    QSTOP                    YES - NOTHING TO DO HERE\n         XC    QSCFLAGS,QSCFLAGS        CLEAR SUBCOMMAND FLAGS\n         MVC   PA@FIELD,QBLANK          BLANK THE WORK FIELD\n         MVC   P@OFFSET(4),=F'0'        ZERO THE OFFSET AND LENGTH\n         MVC   QOFF0(12),P@OFFSET       INITIALIZE FIRST FIELD\n         MVC   QOFF1(QPARMEND-QOFF1),QOFF0  INIT THE REST\n         MVC   QKEYWORD+00(80),QBLANK   CLEAR KEYWORD/VALUE AREA\n         MVC   QKEYWORD+80(80),QBLANK   CLEAR KEYWORD/VALUE AREA\n         MVI   PA@FLAG,0                CLEAR MY FLAGS\n         SR    R5,R5                    INDICATE PROCESSING SUBCMD NAME\n         LA    R3,PA@REPLY              -> FIRST BYTE OF REPLY LINE\n         BAL   R10,PA$TOKEN             GET SUBCOMMAND NAME\n         EX    0,*                      THERE BETTER BE A SUBCMD NAME\n         MVC   QOFF0(12),P@OFFSET       SAVE OFFSET, LEN, SUBCMD NAME\n***********************************************************************\n*                                                                     *\n*   FIND THE PARSE TABLE ENTRY FOR THE SUB COMMAND                    *\n*                                                                     *\n***********************************************************************\n         LA    R9,PA#TABLE              START OF SUBCOMMAND TABLE\n         USING QCMDE,R9\nPA$NEXT1 SR    R0,R0                    CLEAR FOR IC\n         IC    R0,CMD@NUM               GET NUMBER OF SUBCMD NAMES\n         LA    R1,CMD@CMD               -> FIRST SUBCMD NAME\nPA$NEXT2 CLC   QSUBNAME(L'CMD@CMD),0(R1)  COMPARE COMMAND NAME\n         BE    PA$FOUND                 THIS IS THE ONE\n         LA    R1,L'CMD@CMD(,R1)        -> NEXT SUBCMD NAME\n         BCT   R0,PA$NEXT2              CHECK ALL NAMES\n*  INCREMENT TO NEXT SUBCMD ENTRY\n         LR    R9,R1                    -> NEXT TABLE ENTRY\n         CLI   0(R9),X'FF'              IS THIS THE END OF TABLE?\n         BNE   PA$NEXT1                 NO. TRY NEXT ENTRY.\n         LA    R9,PA#CMDJ               USE JES2 SUBCOMMAND ENTRY\n         CLC   QSUBNAME(1),QCOMCHAR     COULD THIS BE A JES2 COMMAND?\n         BE    PA$FOUND                 YES - CALL 'OPERCMD'\n         LA    R9,PA#CMD                USE '/' SUBCOMMAND ENTRY\n         CLI   QSUBNAME,C'/'            SHORT FORM FOR MVS COMMAND?\n         BE    PA$FOUND                 YES - CALL 'OPERCMD'\n         LA    R9,PA#CMDQ               USE '|' SUBCOMMAND ENTRY\n         CLI   QSUBNAME,C'|'            QUIET FORM FOR MVS COMMAND?\n         BE    PA$FOUND                 YES - CALL 'OPERCMD'\n         CLI   QSUBNAME,C'='            DOES HE THINK HE'S IN SPF?\n         BNE   PA$BOUNC                 NO - NORMAL ERROR MESSAGE\n         TM    QFLAG2,Q2SPF             ARE WE REALLY IN SPF???\n         BNO   PA$NOSPF                 NO - TELL HIM SORRY\n         TM    QDEBUG1,QDEBUG12         IS THIS REQUESTED?    %%%\n         BZ    PA$NOSPF                 NO - TELL HIM SORRY   %%%\n*---  WE ARE IN SPF AND USER HAS ENTERED '=XXX'.  SET &ZCMD AND    ---*\n*---  FAKE OUT THE COMMAND TO 'EXIT'.                              ---*\n         SPACE 1\n*        LINK  EPLOC=PA#ISPLK,MF=(E,PA@PARML),PARAM=(=CL8'VDEFINE',    $\n               =CL8'ZCMD',PA@REPLY,=CL8'CHAR',=A(QDREPLYL),=CL8'COPY'),$\n               VL=1\n         SPACE 1\n*        LTR   R15,R15\n*        BZ    PA$DEFOK\n         SPACE 1\n*        QTILT '*** VDEFINE RC \u00ac= 0 ***'\n*A$DEFOK LINK  EPLOC=PA#ISPLK,MF=(E,PA@PARML),PARAM=(=CL8'VPUT',       $\n               =CL8'ZCMD',=CL8'PROFILE'),VL=1\n         SPACE 1\n*        LTR   R15,R15\n*        BZ    PA$PUTOK\n*        QTILT '*** VPUT RC \u00ac= 0 ***'\n         SPACE 1\n         LINK  EPLOC=PA#ISPLK,MF=(E,PA@PARML),PARAM=(=CL8'VREPLACE',   $\n               =CL8'ZCMD',=A(QDREPLYL),PA@REPLY),VL=1\n         SPACE 1\n         LTR   R15,R15\n         BZ    PA$REPOK\n         QTILT '*** VREPLACE RC \u00ac= 0 ***'\n         SPACE 1\nPA$REPOK LINK  EPLOC=PA#ISPLK,MF=(E,PA@PARML),PARAM=(=CL8'VPUT',       $\n               =CL8'ZCMD',=CL8'SHARED  '),VL=1\n****???? SHOULD THIS BE THE FUNCTION POOL?\n         SPACE 1\n         LTR   R15,R15\n         BZ    PA$PUTOK\n         SH    R1,=H'8'                 BACK UP TO START OF TLD\n         CLC   =C'TLD',0(R1)            DID WE GET THE TLD?\n         BNE   PA$PUTNO                 NO - GIVE REGULAR ERROR MSG\n         MVC   X'28C'(24,R1),QDREPLY+1  YES - SET JUMP DESTINATION\n         B     PA$PUTOK                 AND LEAVE\nPA$PUTNO QTILT '*** VPUT RC \u00ac= 0 ***'\nPA$PUTOK LA    R9,PA#EXIT               USE 'EXIT' SUBCOMMAND ENTRY\n         B     PA$FOUND                 GO PROCESS 'EXIT' SUBCOMMAND\nPA$NOSPF QTILT '*** NOT IN SPF - SORRY...  TRY AGAIN ***'\nPA$BOUNC MVC   QERRMSG(62),=C'*** INVALID SUBCOMMAND \"XXXXXXXX\" - FOR H$\n               ELP, ENTER \"HELP\" ***'\n         MVC   QERRMSG+24(8),QSUBNAME\n         QTILT *,OPTIONS=(REPROMPT,SET)\nPA$FOUND TM    CMD@FLAG,P@P             PRIVILEGED SUBCOMMAND?\n         BNO   PA$ALL                   NO - CONTINUE\n         TM    QXAUTH,QXAUTHX           YES - IS HE AUTHORIZED?\n         BZ    PA$BOUNC                 NO - THE SUBCOMMAND IS INVALID\nPA$ALL   MVC   QCODE(1),CMD@CODE        SUBCMD CODE\n         MVC   QSUBCMD,CMD@ADDR         SUBCMD ADDRESS\n         TM    CMD@FLAG,P@I             REPROMPTABLE INQUIRY COMMAND?\n         BNO   *+10                     NO - SKIP\n         MVC   QINQCMD,QDREPLY          YES - SAVE THE COMMAND LINE\n         NI    QFLAG1,255-Q1VALJOB-Q1LSTCMD-Q1IMMED  RESET FLAGS\n         TM    CMD@FLAG,P@X             EXECUTE THIS SUBCMD IMMED.?\n         BNO   *+8                      NO - SKIP\n         OI    QFLAG1,Q1IMMED           YES - SET FLAG\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*  PARSE OUT AND SAVE OPERANDS                                        *\n*                                                                     *\n***********************************************************************\n         LA    R5,QOFF1                 -> FIRST OPERAND SLOT\n         LA    R6,QPARMEND              -> PAST LAST OPERAND SLOT\n         SR    R0,R0                    CLEAR FOR IC\n         IC    R0,CMD@POS               # OF POSIT. OPERANDS ALLOWED\n         SPACE 1\nPA$AGAIN LTR   R2,R2                    ANY MORE INPUT?\n         BNP   PA$VALCK                 NO - EXIT LOOP\n         BAL   R10,PA$TOKEN             GET THE NEXT TOKEN\n         B     PA$VALCK                 EXIT LOOP IF NO MORE OPERANDS\n         TM    PA@FLAG,PA@KEYS          KEYWORD OR RESERVED WORD?\n         BO    PA$KW$RW                 YES - SAVE IT\n*                                       NO - POSITIONAL\n         SH    R0,=H'1'                 COUNT 1 POSITIONAL OPERAND\n         BM    PA$2MANY                 ABORT IF THIS IS ONE TOO MANY\n         MVC   0(12,R5),P@OFFSET        MOVE POSITIONAL STUFF\n         LA    R5,12(,R5)               BUMP TO NEXT POSITIONAL\n         B     PA$MOVED                 CONTINUE\nPA$KW$RW CR    R5,R6                    IS THERE ROOM FOR ANOTHER?\n         BNL   PA$KMANY                 NO - GIVE ERROR MSG\n         MVC   0(8,R5),PA@FIELD         MOVE KEYWORD OR VALUE\n         LA    R5,8(,R5)                INCR TO NEXT FIELD\n         CLI   PA@DELIM,C'='            WAS THIS A KEYWORD= ?\n         BE    PA$KWEQ                  YES - SETUP FOR VALUE\n         TM    PA@FLAG,PA@VALUE         NO - WAS THIS THE KW VALUE?\n         BO    PA$KWOK                  YES - OK\n         LA    R5,8(,R5)                NO - RSRVD WORD - BUMP PAST VAL\n         B     PA$MOVED                 CONTINUE\nPA$KWEQ  TM    PA@FLAG,PA@VALUE         WAS THIS VALUE?\n         BO    PA$KWBAD                 YES - KEYWORD=VALUE= IS INVALID\n         OI    PA@FLAG,PA@VALUE         NO - SET FLAG \"EXPECTING VALUE\"\n         LA    R3,1(,R3)                SKIP OVER '='\n         BCT   R2,PA$MOVED              CONTINUE IF MORE INPUT\n         B     PA$VALCK                 VALIDITY CHECK KEYWORDS ENTERED\n*---  HE ENTERED KEYWORD=VALUE=\nPA$KWBAD MVC   QERRMSG(25),=C'*** SYNTAX ERROR -- VALUE'\n         SH    R5,=H'16'                BACK UP TO KEYWORD\n         MVC   QERRMSG+26(8),8(R5)\n         MVC   QERRMSG+35(10),=C'OF KEYWORD'\n         MVC   QERRMSG+46(8),0(R5)\n         MVC   QERRMSG+55(22),=C'MAY NOT HAVE VALUE ***'\n         QTILT *,OPTIONS=(REPROMPT,SET)\nPA$KWOK  NI    PA@FLAG,X'FF'-PA@VALUE   RESET \"VALUE\" FLAG\nPA$MOVED LTR   R2,R2                    IS THE REMAINING LENGTH ZERO?\n         BZ    PA$VALCK                 YES - VAL. CHECK KEYWDS ENTERED\n         MVC   PA@FIELD,QBLANK          BLANK THE WORK FIELD\n         MVC   P@OFFSET(4),=F'0'        ZERO OUT OFFSET AND LENGTH\n         CR    R5,R6                    WAS THAT THE LAST FIELD?\n         BL    PA$AGAIN                 NO. PROCESS NEXT FIELD.\n         CLI   CMD@POS,X'FF'            IGNORE ERRORS ON POSIT. FIELDS?\n         BE    PA$EXIST                 YES - NOTHING MORE I CAN DO\n         B     PA$AGAIN                 PROCESS NEXT OPERAND TOKEN\n*A$2MANY TM    PA@FLAG,PA@KEYS          ALREADY PROCESSING KEYWORDS?\n*%%%     BO    PA$PMANY                 YES - ERROR\nPA$2MANY CLI   CMD@POS,0                ANY POSITIONALS ALLOWED?\n         BNE   PA$PMANY                 YES - HE ENTERED TOO MANY\n         OI    PA@FLAG,PA@KEYS          NO - SO PROCESS KEYWORDS!\n         LA    R5,QKEYWORD              -> FIRST SLOT FOR KEYWORDS\n         LA    R6,QKEYLAST              -> PAST LAST SLOT\n         B     PA$KW$RW                 GO SAVE THIS KEYWORD\nPA$PMANY QTILT '*** TOO MANY POSITIONAL OPERANDS FOR SUBCOMMAND ***',  $\n               OPTIONS=(REPROMPT,SET)\nPA$KMANY QTILT '*** TOO MANY KEYWORD AND/OR RESERVED WORD OPERANDS ***'$\n               ,OPTIONS=(REPROMPT,SET)\n***********************************************************************\n*                                                                     *\n*   SUBROUTINE TO GET THE NEXT TOKEN FROM THE INPUT LINE              *\n*                                                                     *\n***********************************************************************\nPA$TOKEN MVC   PA@FIELD,QBLANK          CLEAR THE WORK FIELD\n         LA    R4,PA@FIELD              FIRST BYTE OF WORK FIELD\n         MVI   PA@DELIM,C' '            INIT IN CASE RUN OFF END OF INP\nPA$BLANK CLI   0(R3),C' '               FIND A NON BLANK YET?\n         BE    PA$SKIP                  NO - KEEP LOOKING\n         LTR   R5,R5                    DOING SUBCOMMAND NAME?\n         BZ    PA$FIRST                 YES - BYPASS '/' TEST\n         CLI   CMD@POS,X'FF'            IGNORE ERRORS IN POSIT OPRNDS?\n         BE    PA$FIRST                 YES - BYPASS '/' TEST\n         CLI   0(R3),C'/'               START OF RESERVED WORDS INDIC?\n         BNE   PA$FIRST                 NO. START OF FIELD.\n         TM    PA@FLAG,PA@KEYS          \"END OF POSITS\" ALREADY SET?\n         BO    PA$DBL                   YES - SYNTAX ERROR\n         OI    PA@FLAG,PA@KEYS          NO - SET IT NOW\n         LA    R5,QKEYWORD              -> FIRST SLOT FOR KEYWORDS\n         LA    R6,QKEYLAST              -> PAST LAST SLOT\nPA$SKIP  LA    R3,1(,R3)                YES. SKIP IT.\n         BCT   R2,PA$BLANK              TRY NEXT BYTE\n         BR    R10                      RETURN TO \"NOTHING FOUND\"\nPA$DBL   QTILT '*** SYNTAX ERROR - TWO SLASHES FOUND, OR SLASH AFTER KE$\n               YWORD ***',OPTIONS=(REPROMPT,SET)\nPA$FIRST LH    R1,QDRLNG                REPLY LENGTH\n         SR    R1,R2                    COMPUTE OFFSET TO FIELD START\n         STH   R1,P@OFFSET              STORE OFFSET\n         LR    R1,R2                    SAVE COUNT OF REMAINING BYTES\n         LTR   R5,R5                    DOING SUBCOMMAND NAME?\n         BZ    PA$CHAR                  YES - skip this other stuff\n         CLI   CMD@POS,X'FF'            IGNORE ERRORS IN POSIT OPERNDS?\n         BNE   PA$CHAR                  NO - CONTINUE\n         OC    QOFF1,QOFF1              ARE WE WORKING ON FIRST OPERND?\n         BNZ   PA$CHAR                  NO - SKIP\n         MVC   QOFF1,P@OFFSET           YES - SAVE ITS OFFSET\n         B     PA$CHAR                  CONTINUE\n         SPACE 1\nPA$LOOP  CLI   0(R3),C' '               IS THIS BYTE BLANK?\n         BE    PA$LAST                  YES. END OF FIELD.\n         CLI   0(R3),C'='               START OF KEYWORD VALUE?\n         BNE   PA$CHAR                  NO - MOVE THIS CHAR\n         TM    PA@FLAG,PA@KEYS          ALREADY PROCESSING KEYWORDS?\n         BO    PA$LAST                  YES - OK\n         CLI   CMD@POS,X'FF'            IGNORE ERRORS IN POSIT OPERNDS?\n         BE    PA$IGNOR                 YES - BAIL OUT\n         OI    PA@FLAG,PA@KEYS          INDICATE NOW PROCESSING KEYWDS\n         LA    R5,QKEYWORD              -> FIRST SLOT FOR KEYWORDS\n         LA    R6,QKEYLAST              -> PAST LAST SLOT\n         B     PA$LAST\nPA$IGNOR OC    QOFF1,QOFF1              ARE WE WORKING ON FIRST OPERND?\n         BNZ   PA$VALCK                 NO\n         MVC   QOFF1,P@OFFSET           YES - SAVE ITS OFFSET\n         B     PA$VALCK                 NO FURTHER OPERAND PROCESSING\nPA$CHAR  MVC   0(1,R4),0(R3)            MOVE ONE BYTE OF FIELD\n         LA    R3,1(,R3)                INCREMENT 'FROM'\n         LA    R4,1(,R4)                INCREMENT 'TO'\n         BCT   R2,PA$LOOP               TRY NEXT BYTE\n         B     *+10     >=======+       DON'T SAVE DELIM IF RUN OFF END\nPA$LAST  MVC   PA@DELIM,0(R3)   |       SAVE THE DELIM (BLANK OR SLASH)\n         SR    R1,R2    <=======+       COMPUTE FIELD LENGTH\n         CH    R1,=H'8'                 IS LENGTH GREATER THAN 8?\n         BNH   *+8                      NO. USE IT.\n         LA    R1,8                     YES. USE LENGTH OF EIGHT.\n         STH   R1,P@LENGTH              STORE FIELD LENGTH\n         B     4(,R10)                  RETURN TO CALLER\n***********************************************************************\n*                                                                     *\n*   VALIDITY CHECK KEYWORDS AND RESERVED WORDS ENTERED                *\n*                                                                     *\n***********************************************************************\nPA$VALCK CL    R12,QSUBCMD              POINT TO ME???\n         BE    PA$PSWD                  YES - MUST BE \"XP\" SUBCOMMAND\n         L     R2,CMD@KEYS              SUBCMD'S VALID KEYWORD TABLE\n         LTR   R2,R2                    ANY?\n         BZ    PA$VALNO                 NO - NONE ALLOWED\n         LA    R3,QKEYWORD              -> FIRST ONE ENTERED\n         LA    R4,QKEYLAST              -> PAST LAST ONE POSSIBLE\nPA$VALL1 CLI   0(R3),C' '               ANY WORD HERE?\n         BE    PA$FINAL                 NO - DONE HERE\n         CLC   0(8,R3),0(R2)            YES - IS IT VALID?\n         BE    PA$VALL2                 YES - CHECK NEXT\n         LA    R2,8(,R2)                -> NEXT VALID KEYWORD\n         CLI   0(R2),X'FF'              END OF TABLE?\n         BNE   PA$VALL1                 NO - SEE IF IT'S THIS ONE\n         MVC   QERRMSG(21),=C'*** INVALID KEYWORD -'\n         MVC   QERRMSG+22(8),0(R3)\n         MVC   QERRMSG+31(18),=C'- FOR SUBCOMMAND -'\n         MVC   QERRMSG+50(8),QSUBNAME\n         MVC   QERRMSG+59(3),=C'***'\n         QTILT *,OPTIONS=(REPROMPT,SET)\nPA$VALL2 LA    R3,16(,R3)               -> NEXT WORD TO CHECK\n         CR    R3,R4                    DONE CHECKING?\n         BNL   PA$FINAL                 YES - DONE\n         L     R2,CMD@KEYS              -> VALID KEYWORD TABLE\n         B     PA$VALL1                 CHECK NEXT KEYWORD\nPA$VALNO CLI   QKEYWORD,C' '            ANY KEYWORDS OR RESERVED WORDS?\n         BE    PA$FINAL                 NO - OK, DONE HERE\n         MVC   QERRMSG(54),=C'*** KEYWORDS NOT ALLOWED FOR \"XXXXXXXX\" S$\n               UBCOMMAND ***'\n         MVC   QERRMSG+30(8),QSUBNAME\n         QTILT *,OPTIONS=(REPROMPT,SET)\n***********************************************************************\n*                                                                     *\n*   DO FINAL PROCESSING OF OPERANDS IF REQUIRED                       *\n*                                                                     *\n***********************************************************************\nPA$FINAL NI    QFLAG2,255-Q2REPOS       ASSUME NOT REPOSITIONING SUBCMD\n         TM    CMD@FLAG,P@R             IS IT?\n         BNO   *+8                      NO - OK\n         OI    QFLAG2,Q2REPOS           YES - SET FLAG\n         TM    CMD@FLAG,P@J+P@A         IS PARM1 A <JOBID> ?\n         BZ    PA$EXIST                 NO - SKIP\n         TM    CMD@FLAG,P@V             SUBCMD REQUIRE ACCESS TO JOB?\n         BNO   *+8                      NO - SKIP\n         OI    QFLAG1,Q1VALJOB          YES - SET FLAG\n         TM    CMD@FLAG,P@L             LIST TYPE SUBCMD?\n         BNO   *+8                      NO - SKIP\n         OI    QFLAG1,Q1LSTCMD          YES - FLAG FOR LATER\n         CLC   =C'* ',QPARM1            REQUEST PREVIOUS JOB?\n         BE    USE$PREV                 YES - GO RESTORE IT\n         TM    CMD@FLAG,P@A             ACTION COMMAND?\n         BO    P$ACTION                 YES - DON'T ALLOW BLANK JOBNAME\n         CLC   QPARM1,QBLANK            ANOTHER WAY TO SELECT PREVIOUS?\n         BE    USE$PREV                 YES - GO RESTORE IT\nP$ACTION CLI   QLNG1+1,1                PARM LENGTH = 1?\n         BNE   PA$EXIST                 NO - DONE\n         IC    R15,QPARM1               YES - SAVE THE CHARACTER\n         MVC   QPARM1(7),QLOGON         MOVE IN USERID\n         SR    R1,R1                    CLEAR FOR IC\n         IC    R1,QLOGONL               GET LENGTH OF USERID\n         STC   R15,QPARM1(R1)           SET CHARACTER AT END OF USERID\n         LA    R1,1(,R1)                BUMP LENGTH\n         STH   R1,QLNG1                 SAVE NEW LENGTH\n         B     PA$EXIST                 DONE\nUSE$PREV MVC   QLNG1(2+8),QJOBID        RESTORE PREVIOUS JOBID & LENGTH\n         SPACE 2\nPA$EXIST CLC   =F'0',CMD@ADDR           IS SUBCOMMAND LINKED IN?\n         BNE   QSTOP                    YES - OK\n         MVC   QERRMSG(50),=C'*** \"XXXXXXXX\" SUBCOMMAND IS NOT YET AVAI$\n               LABLE ***'\n         MVC   QERRMSG+5(8),QSUBNAME\n         QTILT *,OPTIONS=(REPROMPT,SET)\n***********************************************************************\n*                                                                     *\n*   PROMPT FOR SECRET PASSWORD (\"XP\" SUBCOMMAND)                      *\n*                                                                     *\n***********************************************************************\nPA$PSWD  CLC   QPARM1,=C'PASSWORD'      DID THE USER SAY PASSWORD?\n         BNE   PA$BOUNC                 NO. REJECT.\n         SPACE 1\n         TPUT  WPASS,L'WPASS,FULLSCR\n         SPACE 1\n         LA    R1,RPASS                 REPLY ADDRESS\n         SPACE 1\n         TGET  (1),8\n         SPACE 1\n         CLC   RPASS,=C'YES SIR!'       IS THE PASSWORD CORRECT?\n         BNE   PA$BOUNC                 NO. REJECT.\n         XI    QXAUTH,QXPSWD            AUTHORIZE USER (OR UNDO IT)\n         QTILT '=== PASSWORD ACCEPTED ==='\n***********************************************************************\n*                                                                     *\n*   MISCELLANY                                                        *\n*                                                                     *\n***********************************************************************\nWPASS    DC    X'C1115D7F1140403C4040001D4C13'  *** SPF TCAM\nPA#ISPLK DC    CL8'ISPLINK'\n         LTORG\n         SPACE 2\nWORK     DSECT\n         ORG   WORK+72                  SKIP OVER SAVE AREA\nPA@FLAG  DS    X\nPA@KEYS  EQU   X'01'                    NOW PROCESSING KEYWORDS/RSRVD\nPA@VALUE EQU   X'02'                    NOW PROCESSING VALUE\nPA@DELIM DS    C\nP@OFFSET DS    H\nP@LENGTH DS    H\nPA@FIELD DS    CL8\n*---  BE CAREFUL PUTTING THINGS AFTER PA@FIELD BECAUSE THE TOKENIZER\n*---  DOESN'T STOP AT 8 CHARACTERS IF THE USER ENTERS MORE\nRPASS    DS    CL8\n*PA@REPLY DS   CL(QDREPLYL)\nPA@REPLY DS    CL66                     STUPID ASMF\n         SPACE 2\nPA@PARML DS    0A                       PARM LIST FOR ISPLINK CALL\nPA@SERVP DS    A                        -> SERVICE NAME\nPA@PARM1 DS    A                        -> 1ST PARM\nPA@PARM2 DS    A                        -> 2ND PARM\nPA@PARM3 DS    A                        -> 3RD PARM\nPA@PARM4 DS    A                        -> 3RD PARM\n         SPACE 1\nPA@OPTLN DS    F                        LENGTH OF CMD LINE INPUT\nPA@WORKL EQU   *-WORK                   length of PARSE's workarea\n         SPACE 2\n         DROP  R13,R9\n         EJECT\nQCMDE    DSECT\nCMD@ADDR DS    A                        V-CON OF SUBROUTINE\nCMD@KEYS DS    A                        V-CON OF KEYWORD/RSRVD WORD TBL\nCMD@FLAG DS    B                        FLAGS\nP@J       EQU   X'80'                    FIRST OPERAND IS JOBID\nP@A       EQU   X'40'                    SAME AS ABOVE FOR ACTION CMD\n*                                        (DO NOT ALLOW BLNK FOR ACTION)\nP@I       EQU   X'20'                    RE-EXECUTABLE INQUIRY COMMAND\nP@P       EQU   X'10'                    SUBCOMMAND IS PRIVILEGED\nP@V       EQU   X'08'                    VERIFY ACCESS TO JOB\nP@L       EQU   X'04'                    LIST TYPE SUBCMD (\"READ ONLY\")\nP@X       EQU   X'02'                    EXEC THIS SUBCMD IMMEDIATELY\n*                                        IN \"DISPLAY\" & RETURN TO PREV\nP@R       EQU   X'01'                    REPOSITIONING SUBCOMMAND\nCMD@POS  DS    AL1                      MAXIMUM NUMBER OF POSITIONALS\n*                                       X'FF' = DON'T CHECK\nCMD@CODE DS    AL1                      INTERNAL FUNC CODE FOR ROUTINE\nCMD@NUM  DS    AL1                      NUMBER OF SUBCMD NAMES HERE\nCMD@CMD  DS    CL4                      SUBCOMMAND NAME\n*---  CMD@CMD OCCURS CMD@NUM TIMES\nCMD@ENTL EQU   *-QCMDE                  LENGTH OF TABLE ENTRY\n         SPACE 3\n*---  FORMAT OF QCMDE ENTRIES:\n*  ROUTINE_NAME  QCMDE  FUNC_CODE,MAX_POSIT_OPRNDS,(CMD,ALIAS1,...),\n*                       F=FLAG1+FLAG2+...,KEYS=KEY_TABLE_NAME\n         SPACE 2\nPARSE    CSECT                          RESUME AFTER DSECT\nPA#TABLE DC    0D'0'\n         SPACE 2\nSEARCH   QCMDE 00,1,(STATUS,ST),F=P@I,KEYS=ST#KEYS\nSEARCH   QCMDE 04,0,DA,F=P@I,KEYS=DA#KEYS\nSEARCH   QCMDE 08,2,DI,F=P@I,KEYS=DI#KEYS\nSEARCH   QCMDE 12,2,DO,F=P@I,KEYS=DO#KEYS\nSEARCH   QCMDE 16,2,AI,F=P@I,KEYS=DI#KEYS\nSEARCH   QCMDE 20,2,AO,F=P@I,KEYS=DO#KEYS\nSEARCH   QCMDE 24,2,HI,F=P@I,KEYS=DI#KEYS\nSEARCH   QCMDE 28,0,DH,F=P@I,KEYS=DH#KEYS\nSEARCH   QCMDE 32,0,DT,F=P@I,KEYS=DA#KEYS\nSEARCH   QCMDE 36,1,DJ,F=P@I+P@J,KEYS=DJ#KEYS\nSEARCH   QCMDE 36,1,XJ,F=P@J+P@P\nSEARCH   QCMDE 40,0,DS,F=P@I,KEYS=DA#KEYS\nSEARCH   QCMDE 44,1,DQ,F=P@I,KEYS=DQ#KEYS\nSEARCH   QCMDE 48,0,(DEVICES,DEV),F=P@I\nSEARCH   QCMDE 52,0,DN,F=P@I,KEYS=DN#KEYS\nFORMAT   QCMDE 100,1,JQE,F=P@P\nFORMAT   QCMDE 104,1,JOE,F=P@P\nCPU      QCMDE   ,1,(CPU,DC),F=P@I\nSYSOUT   QCMDE 00,1,(DELETE,DEL),F=P@A+P@V\nSYSOUT   QCMDE 04,2,(REQUEUE,REQ),F=P@A+P@V\nSYSOUT   QCMDE 08,2,(CANCEL,CAN,CJ),F=P@A+P@V\nJOBINFO  QCMDE 00,1,(JOB,JD),F=P@J+P@I\nJOBINFO  QCMDE 04,1,(JOBX,JDX),F=P@J+P@I+P@P\nDDNAME   QCMDE 00,1,DD,F=P@J+P@V+P@L\nDDNAME   QCMDE 04,1,(SJ,S),F=P@J+P@V+P@L,KEYS=SJ#KEYS\nLISTTEXT QCMDE   ,1,LTXT,F=P@J+P@V+P@L+P@P\nLIST     QCMDE 00,3,(LIST,L),F=P@J+P@V+P@L\nLIST     QCMDE 04,1,(JCL,JC),F=P@J+P@V+P@L\nLIST     QCMDE 08,1,(JLOG,JL),F=P@J\nLIST     QCMDE 12,1,(JMSG,JM),F=P@J+P@V+P@L\nLIST     QCMDE 16,0,NS,KEYS=NS#KEYS\nLIST     QCMDE 16,0,PS\n*%%%LIST QCMDE 16,1,LL\nATTR     QCMDE 00,2,(ATTR,AT),F=P@J,KEYS=AT#KEYS\nATTR     QCMDE 04,2,PDDB,F=P@J+P@P\nJOBSUMM  QCMDE   ,1,(JS,J,JSUMM),F=P@J\nJESNEWS  QCMDE 00,0,(JNEWS,JN)\nSAVEDS   QCMDE 04,1,SAVE,KEYS=SV#KEYS\nSYSLOG   QCMDE 00,2,(SLOG,SL),F=P@P\nINITS    QCMDE   ,0,(INIT,IN),F=P@I,KEYS=IN#KEYS\nRMTLIST  QCMDE   ,0,LRMT,F=P@I\nSYSLIST  QCMDE   ,0,LSYS,F=P@I+P@P\nBLKLIST  QCMDE   ,1,LBLK,F=P@I+P@P+P@J\nLISTDAS  QCMDE   ,0,LDAS,F=P@P\nLISTKIT  QCMDE   ,0,LKIT,F=P@P\nHEXBLK   QCMDE 00,2,(XBLK,XB),F=P@P,KEYS=HB#KEYS\nHEXBLK   QCMDE 04,2,JCT,F=P@J+P@P\nHEXBLK   QCMDE 08,1,HCT,F=P@P\nHEXBLK   QCMDE 12,1,QCMN,F=P@P\nHEXBLK   QCMDE 16,1,CKPT,F=P@P\nREPOS    QCMDE 04,N,(FIND,F)\nREPOS    QCMDE 04,N,(FALL,FA)\nREPOS    QCMDE 08,1,(FTIME,FT)\nREPOS    QCMDE 12,1,(COLUMN,COL,C),F=P@R\nREPOS    QCMDE 16,1,(@,MD)\nREPOS    QCMDE 20,1,(+,DOWN,D),F=P@R\nREPOS    QCMDE 44,1,PF,F=P@R\nREPOS    QCMDE 48,1,HF,F=P@R\nREPOS    QCMDE 24,1,(-,UP,U),F=P@R\nREPOS    QCMDE 52,1,PB,F=P@R\nREPOS    QCMDE 56,1,HB,F=P@R\nREPOS    QCMDE 28,0,(TOP,T),F=P@R\nREPOS    QCMDE 32,0,(BOTTOM,BOT,B),F=P@R\nREPOS    QCMDE 36,1,(LEFT,LE),F=P@R\nREPOS    QCMDE 40,1,(RIGHT,RI),F=P@R\nREPOS    QCMDE 60,0,(REDISP,RD)\nREPOS    QCMDE 64,1,(PAGE,P),F=P@R\n          AIF   (NOT &QTMPMAC).PARSE01\nTSOCMD   QCMDE   ,N,TSO,F=P@X\nMCS      QCMDE   ,1,(CONS,MCS),F=P@P+P@I\n.PARSE01  ANOP\nMODE     QCMDE 00,0,MODE,F=P@X,KEYS=MO#KEYS\nMODE     QCMDE 04,0,COLS,KEYS=COL#KEYS\nQINNARDS QCMDE   ,0,QINT,F=P@X,KEYS=QI#KEYS\nPRINT    QCMDE 00,2,(PRINT,PR),F=P@X,KEYS=PR#KEYS\nPRINT    QCMDE 04,2,(COPY,CY),F=P@X,KEYS=PR#KEYS\nSETUP    QCMDE   ,1,(SETUP,SU),F=P@J\nOPERCMD  QCMDE 12,2,(ROUTE,ROU,RJ),F=P@V+P@A\nOPERCMD  QCMDE 16,1,(HOLD,HJ),F=P@P+P@A\nOPERCMD  QCMDE 20,1,(RELEASE,REL,AJ),F=P@P+P@A\nOPERCMD  QCMDE 24,1,(PURGE,PUR,PJ),F=P@V+P@A\nOPERCMD  QCMDE 32,1,TJ,F=P@P+P@A,KEYS=TJ#KEYS\nOPERCMD  QCMDE 36,1,EJ,F=P@P+P@A\nPA#CMDX  EQU   *\nOPERCMD  QCMDE 28,N,//,F=P@P+P@X\nOPERCMD  QCMDE 28,N,||,F=P@P+P@X\nTGPS     QCMDE   ,0,(SPSP,TGPS),F=P@P\nPFKSET   QCMDE   ,N,PFK,F=P@X\nHELP     QCMDE   ,1,(HELP,H,?),KEYS=HE#KEYS\nCHANGES  QCMDE   ,0,CHGS,KEYS=CH#KEYS\nPA#EXIT  EQU   *\nEXIT     QCMDE 04,0,(END,E)\nEXIT     QCMDE 00,0,(EXIT,STOP,QUIT,RETURN,RET,=X)\nRECALL   QCMDE   ,0,(RECALL,RC,RETRIEVE,RE),F=P@X,KEYS=RC#KEYS\nSPFFUNC  QCMDE 00,1,(ED,EDIT),F=P@X,KEYS=SF#KEYS\nSPFFUNC  QCMDE 04,1,(BR,BROWSE),F=P@X,KEYS=SF#KEYS\nABEND    QCMDE   ,0,ABEND\nPARSE    QCMDE   ,1,XP\n         DC    X'FF000000'              END OF COMMAND TABLE\n         SPACE 2\n*---  SPECIAL USE ENTRIES\nPA#CMD   EQU   *\nOPERCMD  QCMDE 00,N,/,F=P@P+P@X\nPA#CMDQ  EQU   *\nOPERCMD  QCMDE 04,N,|,F=P@P+P@X\nPA#CMDJ  EQU   *\nOPERCMD  QCMDE 08,N,$,F=P@P+P@X\n         EJECT\n*---  LINE COMMAND TABLES                                          ---*\n*---  FORMAT IS DESCRIBED BY LCTABLE DSECT IN QCOMMON MACRO        ---*\n         SPACE 1\n*---  TABLE FOR 'DD' DISPLAY SCREEN                                ---*\n         ENTRY PA#LC#DD\nPA#LC#DD DC    C'L ',C'LIST',AL1(LCTFDD+LCTFDCMD)\n         DC    C'S ',C'LIST',AL1(LCTFDD+LCTFDCMD)\n         DC    C'A ',C'ATTR',AL1(LCTFDD+LCTFDCMD)\n         DC    C'AT',C'ATTR',AL1(LCTFDD+LCTFDCMD)\n         DC    X'FF'                    END OF TABLE\n         SPACE 2\n*---  TABLE FOR 'FORMAT' DISPLAY SCREEN                            ---*\n         ENTRY PA#LC#FM\nPA#LC#FM DC    C'DJ',C'DJ  ',AL1(LCTFDCMD)\n         DC    C'XJ',C'XJ  ',AL1(LCTFDCMD+LCTFPRIV)\n         DC    C'JS',C'JS  ',AL1(LCTFDCMD)\n         DC    C'J ',C'JS  ',AL1(LCTFDCMD)\n         DC    C'DE',C'DEL ',AL1(0)\n         DC    C'DL',C'DEL ',AL1(0)\n         DC    C'RE',C'REQ ',AL1(0)\n         DC    C'RQ',C'REQ ',AL1(0)\n         DC    C'CA',C'CAN ',AL1(0)\n         DC    C'CJ',C'CAN ',AL1(0)\n         DC    C'JD',C'JOB ',AL1(LCTFDCMD)\n         DC    C'JX',C'JOBX',AL1(LCTFDCMD+LCTFPRIV)\n         DC    C'SJ',C'SJ  ',AL1(LCTFDCMD)\n         DC    C'S ',C'SJ  ',AL1(LCTFDCMD)\n         DC    C'DD',C'DD  ',AL1(LCTFDCMD)\n         DC    C'LT',C'LTXT',AL1(LCTFDCMD+LCTFPRIV)\n         DC    C'L ',C'LIST',AL1(LCTFDCMD)\n         DC    C'JC',C'JCL ',AL1(LCTFDCMD)\n         DC    C'JL',C'JLOG',AL1(LCTFDCMD)\n         DC    C'JM',C'JMSG',AL1(LCTFDCMD)\n         DC    C'SL',C'SLOG',AL1(LCTFDCMD)\n         DC    C'LB',C'LBLK',AL1(LCTFDCMD+LCTFPRIV)\n         DC    C'JT',C'JCT ',AL1(LCTFDCMD+LCTFPRIV)\n         DC    C'SU',C'SETU',AL1(LCTFDCMD)\n         DC    C'R ',C'RJ  ',AL1(0)\n         DC    C'RJ',C'RJ  ',AL1(0)\n         DC    C'H ',C'HJ  ',AL1(0)\n         DC    C'HJ',C'HJ  ',AL1(0)\n         DC    C'A ',C'AJ  ',AL1(0)\n         DC    C'AJ',C'AJ  ',AL1(0)\n         DC    C'T ',C'TJ  ',AL1(0)\n         DC    C'TJ',C'TJ  ',AL1(0)\n         DC    C'PJ',C'PJ  ',AL1(0)\n         DC    C'EJ',C'EJ  ',AL1(0)\n         DC    X'FF'                    END OF TABLE\n         SPACE 2\n         QCOMMON\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "Q#PF": {"ttr": 13829, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x08\\x00\\x00\\x00\\x82#/\\x00\\x892\\x7f!U\\x00g\\x00K\\x00)\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "05.08", "flags": 0, "createdate": "1982-08-20T00:00:00", "modifydate": "1989-11-23T21:55:00", "lines": 103, "newlines": 75, "modlines": 41, "user": "LDW"}, "text": "         TITLE '--- QUEUE--PFKSET -- DISPLAY/CHANGE PFKEYS ---'\n*---------------------------------------------------------------------*\n*                                                                     *\n*   PFKSET - Display / alter user's PFK definitions                   *\n*                                                                     *\n*   Entry - PFK number in \"QPARM1\", PFK command starting at \"QOFF2\"   *\n*                                                                     *\n*   Exit - PFK table updated if requested                             *\n*                                                                     *\n*   Note - This subcommand may be executed in a QUEUE profile         *\n*                                                                     *\n*   Updates:                                                          *\n*      23Nov89  LDW  Eliminate \"LC\" macro usage                       *\n*      03/31/86 LDW  RE-DESIGN 3278-5 SUPPORT (THIRD TRY!)            *\n*      04/17/84 LDW  FIX FOR ENTER AFTER SET KILLING THE PFK JUST SET *\n*      01/19/84 LDW  ADD SUPPORT FOR COMMAND STACKING                 *\n*      03/09/83 LDW  ALLOW FOR 24 PFKEYS IF INDICATED BY \"QM1PFK24\"   *\n*                    CHANGE 'QTILT *' TO USE QERRMSG                  *\n*                    CHANGE HEADER TO LOWER CASE                      *\n*      12/20/82 LDW  CHANGE QTILT REPRMPT=YES TO OPTIONS=REPROMPT     *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 3\nPFKSET   QSTART  STACK=X'B0'\n         QCALL DISP80                   SWITCH TO 3278-2 MODE IF 3278-5\n         MVC   QDPROMPT,QDREPLY         SET WHAT TO REPROMPT WITH\n         TM    QFLAG1,Q1PROFOK+Q1IMMED  IMMED COMMAND AFTER PROFILE?\n         BO    PFKSTOP                  YES - TURN OFF IMMED; RECURSE\n*  IS THAT WHAT YOU DO WHEN YOU CURSE AT THE PROGRAM MORE THAN ONCE?\n         LA    R9,12                    ASSUME LIMIT IS 12\n         TM    QMODE1,QM1PFK24          ARE PF13-24 TO BE DIFFERENT?\n         BNO   *+8                      NO - SKIP\n         LA    R9,24                    YES - LIMIT IS 24\n         CLI   QPARM1,C' '              ANY OPERAND?\n         BE    PFKSTAR                  NO - JUST DISPLAY\n         CLI   QPARM1,C'*'              REQUEST FOR DISPLAY ONLY?\n         BE    PFKSTAR                  YES - DO IT\n*  CHANGE A PFKEY DEFINITION\n         LH    R1,QLNG1                 LENGTH OF QPARM1\n         SH    R1,=H'1'                 EX LEN OF QPARM1\n         BM    PFKTILT                  NO GOOD\n         LA    R15,QPARM1               ADDR OF OPERAND TO CONVERT\n         BAL   R14,QNUMCONV             CONVERT PF KEY NUMBER\n         BNE   PFKTILT                  BLOW IF NOT NUMERIC\n         LTR   R15,R15                  POSITIVE?\n         BNP   PFKTILT                  NO\n         CR    R15,R9                   KEY TO ALTER IN RANGE?\n         BH    PFKTILT                  NO\n         BCTR  R15,0                    ADJUST ORIGIN\n         SLL   R15,6                    MULTIPLY BY 64\n         A     R15,QVPFKEYS             -> APPROPRIATE PF KEY AREA\n         MVC   0(64,R15),QBLANK         CLEAR IT\n         LA    R1,QDREPLY               -> REPLY AREA\n         CLI   QPARM2,C' '              ANY OPERAND?\n         BE    PFKNOPER                 NO - SKIP\n         AH    R1,QOFF2                 -> OPERAND 2\n         LA    R14,QDREPLYL-1           MAX LENGTH-1 OF REPLY\n         SH    R14,QOFF2                LENGTH-1 OF OPERAND 2\n         EX    R14,PFKMVC               MVC 0(*-*,R15),0(R1)\n         MVI   QPARM1,C' '              PREVENT RECURSION\n         SPACE 2\nPFKNOPER TM    QFLAG1,Q1IMMED           IMMEDIATE SUBCOMMAND?\n         BO    QSTOP                    YES - ALL DONE HERE\n         B     PFKDISP                  NO - DISP CURRENT DEFINITIONS\n         SPACE 3\nPFKSTAR  TM    QFLAG1,Q1IMMED           ARE WE HERE AS \"IMMEDIATE\"?\n         BNO   PFKDISP                  NO - GO GENERATE DISPLAY\n         SPACE 1\nPFKSTOP  NI    QFLAG1,255-Q1IMMED       YES - RESET FLAG\n         B     QSTOP                    RETURN TO \"DISPLAY\" TO BE\n*                                       RE-INVOKED BY QUEUE MAINLINE\n         SPACE 2\nPFKDISP  MVC   QDHLINE(L'PF#HDR),PF#HDR 'CURRENT PFK DEFINITIONS:'\n         LA    R2,1                     KEY #\n         L     R3,QVPFKEYS              -> FIRST KEY AREA\n         BAL   R14,QADDLINE             PUT OUT A BLANK LINE\n         SPACE 2\nPFKLOOP  CVD   R2,QNUMWORK              CONVERT PFK NUMBER\n         MVC   QDMSG+5(3),=X'202020'    MOVE IN EDIT MASK\n         ED    QDMSG+4(4),QNUMWORK+6    SHOW PFK NUMBER\n         MVC   QDMSG+10(64),0(R3)       PFK TEXT\n         BAL   R14,QADDLINE\n         LA    R2,1(,R2)                INCR PFK #\n         LA    R3,64(,R3)               -> NEXT PFK AREA\n         CR    R2,R9                    DONE?\n         BNH   PFKLOOP                  NO - SHOW NEXT\n         B     QSTOP                    YES - LEAVE\n         SPACE 2\nPFKTILT  MVC   QERRMSG(7),=C'*** PFK'\n         MVC   QERRMSG+8(8),QPARM1\n         MVC   QERRMSG+17(11),=C'INVALID ***'\n         QTILT *,OPTIONS=REPROMPT\n         SPACE 3\n***********************************************************************\n*                                                                     *\n*   MISCELLANY                                                        *\n*                                                                     *\n***********************************************************************\nPFKMVC   MVC   0(*-*,R15),0(R1)         << EXECUTED >>\nPF#HDR   DC    C'Current PFK definitions:'\n         LTORG\n         SPACE 3\n         QCOMMON\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "Q#PR": {"ttr": 13832, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x0c\\x00\\x00\\x00\\x82#/\\x00\\x91\\x02\\x9f!\\x18\\x03!\\x02\\x15\\x01\\xa2\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "05.12", "flags": 0, "createdate": "1982-08-20T00:00:00", "modifydate": "1991-01-29T21:18:00", "lines": 801, "newlines": 533, "modlines": 418, "user": "LDW"}, "text": "         TITLE '--- QUEUE--PRINT -- PRINT SCREEN DISPLAY ---'\n*---------------------------------------------------------------------*\n*                                                                     *\n*   PRINT - CREATE HARDCOPY OF CURRENT SCREEN IMAGE                   *\n*                                                                     *\n*   Updates:                                                          *\n*      29Jan91  LDW  Use QVPRNTWA to access most PRINT fields         *\n*                    Change USING/DROP to USNGX/DROPX                 *\n*      16Jun90  LDW  Since we run (mostly) in AMODE31 now, switch to  *\n*                       AMODE24 to do I/O                             *\n*      17Apr89  LDW  Fix bug in printing LBLK screens                 *\n*      19May87  EMS  Change QPPAGE;QPPAGE# -> QPAGEN;QPAGEN#          *\n*      21Mar87  LDW  Fix for DSID = 0 (from RSCS)                     *\n*      02/02/83 LDW  CHANGE \"PRINT N N\" AND \"PRINT ALL\" TO \"COPY\"     *\n*      01/27/83 LDW  ADD PRINT DATASET CAPABILITY                     *\n*                    FIX UP 'HOLD' AND CLASS OPERANDS                 *\n*      01/07/83 LDW  FIX BUGS IN BUILDING DYNAMIC ALLOCATION PARMLIST *\n*                    CHANGE 'DEST=' FROM THIRD POSITIONAL TO KEYWORD  *\n*      12/23/82 LDW  ADD SUPPORT FOR UCS AND FCB AS KEYWORDS          *\n*                    DON'T PRINT SCREEN IF OPERAND IS 'ON' (THIS      *\n*                       ALLOWS PRINT TO BE TURNED ON FOR SPOOLING A   *\n*                       DATASET WITHOUT ALSO PRINTING A SCREEN IMAGE) *\n*                    SQUEEZE OUT EMBEDDED ATTR BYTES IN PRINT LINE    *\n*                    DELETE CODE TO OVERPRINT HIGH INTENSITY FIELDS   *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 3\nPRINT    QSTART  Q27,WORKLEN=PR@WORKL\n         USNGX WORK,R13                 BASE REG FOR LOCAL WORK AREA\n         L     R8,QVPRNTWA              -> my workarea\n         USNGX QPRNTWA,R8\n***********************************************************************\n*   DETERMINE WHETHER COMMAND IS \"PRINT\" OR \"COPY\"\n***********************************************************************\n         CLI   QCODE,0                  IS IT PRINT?\n         BE    PR$PRINT                 YES\n***********************************************************************\n*   PROCESS THE COPY COMMAND\n***********************************************************************\n         ZAP   PR@LAST,=P'9999999'      ASSUME ALL, SET MAX HIGH REC #\n         CLC   =C'ALL ',QPARM1          WANT WHOLE DATASET PRINTED?\n         BE    PR$COPY                  YES - GO DO IT\n         LH    R1,QLNG1                 GET LENGTH OF FIRST PARM\n         BCTR  R1,0                     -1 FOR EX\n         LA    R15,QPARM1               -> FIRST PARM (STARTING LINE)\n         BAL   R14,QNUMCONV             CONVERT OPERAND\n         BNE   PR$BAD1                  ABORT IF NOT NUMERIC\n         LTR   R15,R15                  ZERO?\n         BZ    PR$BAD1                  YES - INVALID\n         ZAP   PR@FIRST,QNUMWORK        SAVE STARTING NUMBER\n         LH    R1,QLNG2                 GET LENGTH OF SECOND PARM\n         SH    R1,=H'1'                 -1 FOR EX\n         BM    PR$BAD2                  ABORT IF MISSING\n         LA    R15,QPARM2               -> SECOND PARM (ENDING LINE)\n         BAL   R14,QNUMCONV             CONVERT OPERAND\n         BNE   PR$BAD2                  ABORT IF NOT NUMERIC\n         ZAP   PR@LAST,QNUMWORK         SAVE ENDING   NUMBER\n         CP    PR@FIRST,PR@LAST         FIRST > LAST?\n         BNH   PR$COPY                  NO - GO PRINT THE RANGE\n         QTILT '*** REVERSE RANGE INVALID ***',OPTIONS=(REPROMPT,SET)\nPR$BAD1  QTILT '*** STARTING RECORD NUMBER INVALID ***',               $\n               OPTIONS=(REPROMPT,SET)\nPR$BAD2  QTILT '*** ENDING RECORD NUMBER INVALID ***',                 $\n               OPTIONS=(REPROMPT,SET)\n***********************************************************************\n*   PROCESS THE PRINT COMMAND\n***********************************************************************\nPR$PRINT CLC   =C'ON',QPARM1            START PRINT REQUEST?\n         BE    STARTPRT                 YES...GO START IT\n         CLC   =C'OFF',QPARM1           STOP PRINT REQUEST?\n         BE    STOPPRT                  YES... GO STOP IT\n         CLC   =C'DEL',QPARM1           DELETE PRINT REQUEST?\n         BE    STOPPRT                  YES... GO STOP IT\n         CLI   QPARM1,C' '              ANY PARM?\n         BE    STARTPRT                 NO...ASSUME START\n         CLI   QPARM1,C'P'              PAGE EJECT?\n         BE    PR$EJECT                 NO - SKIP\n         QTILT '*** INVALID FIRST OPERAND ***',OPTIONS=(REPROMPT,SET)\nPR$EJECT MVI   QPHEAD1,C'0'             YES - SET UP FOR EJECT\n         B     QSTOP                    LEAVE\n         EJECT\n***********************************************************************\n*   START (OR CONTINUE) THE PRINT PROCESS\n***********************************************************************\nSTARTPRT BAL   R7,ALLOCHC               GO ALLOCATE / OPEN HARDCOPY\n         CLC   =C'ON',QPARM1            START PRINT REQUEST?\n         BE    QSTOP                    YES - ALL DONE\n         BAL   R7,GETTIME               GO GET DATE AND TIME\n         MVC   QPUSER,QLOGON            MOVE IN USERID\n         MVC   QPDATE,JDATE             MOVE IN DATE TIME INFO\n         MVC   QPAGEN#,QBLANK           Clear out Page # field\n         XI    QPHEAD1,X'01'            TOGGLE ASA FLAG 0-1 OR 1-0\n         CLC   QDROWS,=H'24'            MODEL 2?\n         BNH   *+8                      YES - OK\n         MVI   QPHEAD1,C'1'             NO - 1 SCREEN PER PAGE\n         CLI   QPHEAD1,C'1'             EJECT NOW SCHEDULED?\n         BNE   NOPAGE                   NO..SKIP PAGE SETTING\n*\n         AP    QPAGEN,=P'1'             Bump page count\n         MVC   QPAGEN#,=X'402020202021' Move in mask\n         ED    QPAGEN#,QPAGEN           Edit in page no\nNOPAGE   LA    R0,QPHEAD1               POINT TO TITLE LINE\n         BAL   R10,PR$PUT0              PUT IT OUT\n         LH    R5,QDCOLS\n         BCTR  R5,0                     -1 FOR EX\n         EJECT\n***********************************************************************\n*  PUT OUT RECONSTRUCTED SCREEN IMAGE                                 *\n***********************************************************************\n*---  LINE 1\n         MVI   PR@CC,C'-'               TRIPLE SPACE\n*  RECONSTRUCT LINE WITHOUT 3270 CONTROL CHARS\n         MVC   PR@LINE,QBLANK\n         MVC   PR@LINE(*-*),QDQUEUE-1   << EXECUTED >>\n         EX    R5,*-6\n         MVI   PR@LINE,C' '             KILL THE ATTRIBUTE BYTE\n         BAL   R10,PR$PUT\n*        MVI   PR@CC,C'+'               OVERPRINT THE HIGHLIGHTED FLDS\n*        BAL   R10,PR$PUT\n*        BAL   R10,PR$PUT\n*---  LINE 2\n         MVI   PR@CC,C' '               RESET CARRIAGE CONTROL\n         MVC   PR@LINE,QBLANK           CLEAR THE AREA\n         MVC   PR@LINE(12),PR#CMD       'COMMAND ===>'\n         MVC   PR@LINE+13(L'QDPROMPT),QDPROMPT   MOVE IN PREVIOUS CMD\n         BAL   R10,PR$PUT               PRINT IT\n         MVC   PR@LINE+13(L'QDPROMPT),QBLANK\n*        MVI   PR@CC,C'+'               SET FOR OVERPRINT\n*        BAL   R10,PR$PUT               PRINT IT\n*        BAL   R10,PR$PUT               PRINT IT\n*---  LINE 3\n         MVI   PR@CC,C' '               RESET CARRIAGE CONTROL\n         MVC   PR@LINE(*-*),QDHLINE     << EXECUTED >>\n         EX    R5,*-6\n         LA    R15,PR@LINE(R5)          -> LAST CHAR OF HEADER LINE\n         MVI   0(R15),C' '              KILL ATTRIBUTE BYTE\n         BAL   R10,PR$PUT               PRINT IT\n*        MVI   PR@CC,C'+'               SET FOR OVERPRINT\n*        BAL   R10,PR$PUT               PRINT IT\n*        BAL   R10,PR$PUT               PRINT IT\n         EJECT ,\n***********************************************************************\n*  PUT OUT ENTIRE SCREEN OF DETAIL LINES (BLANK OR NOT)               *\n***********************************************************************\n         XC    PR@TRTAB,PR@TRTAB        INIT TRTAB TO STOP ON\n         MVI   PR@TRTAB+X'1D',4         ... START FIELD\n         MVI   PR@TRTAB+X'3C',8         ... AND REPEAT TO ADDRESS\n         MVI   PR@CC,C' '               SINGLE SPACE\n         L     R6,QVLINE1               -> FIRST DATA LINE\n         LH    R3,QDROWS                NUMBER TO CRANK\nPUTLOOP  EX    R5,PRNT$MVC              MOVE INTO OUR BUFFER\n**       LA    R15,0(R5,R6)             -> END OF LINE\n         LR    R14,R5                   LENGTH TO TRT\n         LA    R6,1(R5,R6)              -> NEXT LINE\n         LA    R1,PR@LINE               -> START OF LINE\nPR$TRTLP SR    R2,R2                    CLEAR FOR TRT\n         EX    R14,PRNT$TRT             FIND A \"START FIELD\"\n         BZ    PRNTLINE                 NONE - GO PUT OUT THE LINE\n         CLI   0(R1),X'3C'              IS IT THE TRAILING \"RA\"?\n         BE    PR$RA                    YES - SPECIAL HANDLING\n         SPACE 2\n*---  REMOVE THE ATTR BYTE FROM THE PRINT LINE                     ---*\n         MVI   0(R1),C' '               KILL THE X'1D'\n         LA    R1,1(,R1)                SKIP OVER IT\n         LA    R14,PR@LINE(R5)          -> LAST CHAR OF LINE\n         MVC   1(1,R14),0(R6)           get another char for whole line\n**       LA    R15,1(,R15)              ADJUST END OF LINE POINTER\n         LA    R6,1(,R6)                ALSO, FIX PTR TO NEXT SCRN LINE\n         SR    R14,R1                   EXECUTE LENGTH TO SHIFT OVER\n         BM    PR$TRTLP                 continue if end of this line\n**       LR    R2,R15                   COMPUTE ADDRESS OF PART OF LINE\n**       SR    R2,R14                   ... AFTER THE ATTR BYTE\n         EX    R14,PR$SHIFT             SHIFT REMAINDER OF LINE LEFT\n         B     PR$TRTLP                 LOOK FOR NEXT ATTR BYTE\n         SPACE 2\n*---  THE TRAILING \"RA\" SEQUENCE HAS BEEN FOUND.  REMOVE IT, AND   ---*\n*---  PUT OUT ENOUGH BLANK LINES TO ACCOUNT FOR THE REST OF THE    ---*\n*---  SCREEN                                                       ---*\nPR$RA    MVC   0(132,R1),QBLANK         CLEAR REST OF PRINT LINE\n         BAL   R10,PR$PUT               PUT OUT THIS LINE\n         BCT   R3,*+8                   COUNT THIS LINE\n         B     PR$DONE                  EXIT LOOP IF WHOLE SCREEN DONE\n         MVC   PR@LINE,QBLANK           CLEAR THE PRINT LINE\n         BAL   R10,PR$PUT               PUT OUT A BLANK LINE\n         BCT   R3,*-4                   DO ENOUGH BLANK LINES\n         B     PR$DONE                  WHOLE SCREEN NOW DONE\n         SPACE 3\nPRNTLINE BAL   R10,PR$PUT               PUT DETAIL LINE OUT\n**       LA    R6,1(R5,R6)              -> NEXT LINE\n         BCT   R3,PUTLOOP               AND GRIND THE SCREEN THROUGH\n         EJECT ,\nPR$DONE  MVI   PR@CC,C'-'               TRIPLE SPACE A BLANK LINE\n         MVC   PR@LINE,QBLANK\n         CLI   QPHEAD1,C'1'             WAS THIS SECOND ON PAGE?\n         BNE   *+8                      YES - DON'T ADD BLANK LINE\n         BAL   R10,PR$PUT               AND PRINT IT\n         MVI   PR@CC,C' '               RESTORE TO SINGLE SPACE\n*\n         LA    R15,QDTOP-8-15+1(R5)     -> END OF TOP LINE\n         MVC   0(15,R15),=C' SCREEN PRINTED'\n         SPACE 1\nGOTMSG   SR    R1,R1                    SET A ZERO\n         L     R2,4(,R13)                   RETURN CODE\n         ST    R1,16(,R2)                     IN REGISTER 15 (SAVED)\n         B     QSTOP\n         SPACE 2\nPRNT$MVC MVC   PR@LINE(*-*),0(R6)       << EXECUTED >>\nPRNT$TRT TRT   0(*-*,R1),PR@TRTAB       << EXECUTED >>\n**$SHIFT MVC   0(*-*,R1),0(R2)          << EXECUTED >>\nPR$SHIFT MVC   0(*-*,R1),1(R1)          << EXECUTED >>\n         SPACE 3\n***********************************************************************\n*  PUT SUBROUTINE                                                     *\n***********************************************************************\nPR$PUT   LA    R0,PR@CC                 GET ADDRESS OF PRINT LINE BUFF\nPR$PUT0  BAL   R14,QAMODE24             change to AMODE 24\n         L     R1,QPPRNT                -> HASPPRNT DCB\n         PUT   (1),(0)                  PUT IT\n         BAL   R14,QAMODE31             resume AMODE 31\n         BR    R10                      return to caller\n         EJECT ,\n***********************************************************************\n*\n*   PRINT ALL OR A RANGE OF THE CURRENTLY SELECTED DATASET\n*\n***********************************************************************\n*R$COPY% OC    QPDSID,QPDSID            IS THERE A VALID DATASET?\nPR$COPY  TM    QFLAG2,Q2VALIDS          IS THERE A VALID DATASET?\n         BNZ   PR$CY$01                 YES - CONTINUE\n         QTILT '=== YOU ARE NOT PROCESSING A VALID DATASET ==='\nPR$CY$01 MVC   QPARM2,QBLANK            ALLOCHC USES THIS FOR ...\n         MVI   QLNG2+1,0                ... SYSOUT CLASS\n         BAL   R7,ALLOCHC               GO ALLOCATE / OPEN HARDCOPY\n         MVI   PR@FLAG,0                INIT FLAGS\n         L     R9,=V(CHARTAB)           -> TRANSLATE TABLE\n         SR    R4,R4                    ASSUME START AT TOP\n         CLC   =C'ALL',QPARM1           IS THIS 'COPY ALL'?\n         BE    PR$CY$LP                 YES - START AT TOP\n         ZAP   QPREC,PR@FIRST           NO - SET STARTING RECORD NUMBER\n         BCTR  R4,0                     R4 NEGATIVE ==> SPECIFIC START\n         SPACE 2\nPR$CY$LP QCALL GETREC                   GET THE NEXT REC FROM DATASET\n         LTR   R4,R4                    HAVE WE HIT BOTTOM?\n         BZ    PR$CYEND                 YES - END OF DATASET\n         USNGX LRCDSECT,R4\n         TM    LRCFLAG1,LRC1SPAN        IS THIS A SPANNED RECORD?\n         BO    PR$CY$LP                 YES - CAN'T HANDLE THESE YET\n         TM    PR@FLAG,PR@PRTED         HAVE WE PRINTED ANYTHING?\n         BO    PR$CY$GO                 YES - HEADER ALREADY PUT OUT\n*---  BUILD AND PRINT THE HEADING                                  ---*\n         MVI   PR@CC,C'1'               SET FOR PAGE EJECT\n         MVC   PR@LINE,QBLANK           CLEAR THE PRINT LINE\n         MVC   PR@LINE(57),=C'QUEUE SPOOL DATASET PRINT FOR JOB XXXXXXX$\n               X(JOB01234) DSID'\n         MVC   PR@LINE+34(18),QDHJOBID  JOB NAME / JOBID\n         MVC   PR@LINE+58(8),QDHDSID    DSID\n         CLC   =C'ALL',QPARM1           IS THIS 'COPY ALL'?\n         BE    PR$CY$02                 YES - BYPASS REC NBR LOGIC\n         MVC   PR@LINE+66(7),=C'RECORDS'\n         MVC   PR@EDWRK(15),=X'402020202020202040404040404040'\n         LA    R1,PR@EDWRK+7            PRESET IN CASE\n         EDMK  PR@EDWRK(8),PR@FIRST     EDIT START LINE NUMBER\n         MVC   PR@LINE+74(8),0(R1)      MOVE TO PRINT LINE\n         MVC   PR@LINE+84(4),=C'THRU'\n         MVC   PR@EDWRK(15),=X'402020202020202040404040404040'\n         LA    R1,PR@EDWRK+7            PRESET IN CASE\n         EDMK  PR@EDWRK(8),PR@LAST      EDIT END   LINE NUMBER\n         MVC   PR@LINE+89(8),0(R1)      MOVE TO PRINT LINE\n         SPACE 1\nPR$CY$02 BAL   R7,GETTIME               GO GET DATE/TIME FOR PRINT\n         MVC   PR@LINE+100(L'QPDATE),JDATE  DATE/TIME INFO\n         BAL   R10,PR$PUT               GO PRINT THE HEADING LINE\n         MVC   PR@LINE,QBLANK           BLANK THE PRINT LINE\n         MVI   PR@CC,C'-'               REQUEST TRIPLE SPACE\n         BAL   R10,PR$PUT               GO PRINT IT\n         SPACE 1\nPR$CY$GO LA    R0,LRCTEXT               -> DATA PORTION OF RECORD\n         LR    R1,R6                    GET DATA LENGTH\n         LA    R14,PR@CC                -> PRINT LINE CC CHAR\n         LA    R15,L'PR@LINE+1          GET DEST LENGTH\n         TM    LRCFLAG1,LRC1CCTL        IS CCTL SPECIFIED?\n         BO    PR$PAD                   YES - SKIP\n         MVI   PR@CC,C' '               SET FOR SINGLE SPACE\n         LA    R14,PR@LINE              DON'T OVERWRITE CC CHAR\nPR$PAD   ICM   R1,B'1000',QBLANK        INSERT PAD CHAR\n         MVCL  R14,R0                   MOVE RECORD TO PRINT LINE\n         TR    PR@LINE,0(R9)            TRANSLATE UNPRINTABLES\n         BAL   R10,PR$PUT               GO WRITE THE LINE\n         OI    PR@FLAG,PR@PRTED         REMEMBER WE PRINTED SOMETHING\n         CP    QCCREC,PR@LAST           REACH USER'S LIMIT?\n         BL    PR$CY$LP                 NO - CONTINUE\n         SPACE 2\n*---  END OF DATASET ENCOUNTERED                                   ---*\nPR$CYEND TM    PR@FLAG,PR@PRTED         DID WE PRINT ANYTHING?\n         BNO   PR$NOPRT                 NO - TELL USER SO\nPR$PRTED QTILT '=== PRINTED ==='\nPR$NOPRT QTILT '*** STARTING LINE NUMBER > SIZE OF DATASET ***',       $\n               OPTIONS=(REPROMPT,SET)\n         DROPX R4\n         EJECT ,\n***********************************************************************\n*   STOP PRINT PROCESS AND FREE HASPPRNT DDNAME\n***********************************************************************\nSTOPPRT  CLC   =C'HOLD ',QPARM2         WANT IT TO HELD SYSOUT?\n         BE    STOPPRT2                 YES - OK\n         CLC   QLNG2,=H'1'              CHECK SECOND OPERAND LENGTH\n         BH    CLASSBAD                 TOO LONG TO BE A SYSOUT CLASS\n         BL    STOPPRT2                 NONE - OK\n         CLI   QPARM2,C'A'              VALID?\n         BL    CLASSBAD                 NO\n         SPACE 1\nSTOPPRT2 TM    QPFLAG,HARDCPY           IS HARDCPY ON\n         BNO   QSTOP                    NOPE..NO WORK TO DO\n         BAL   R14,QAMODE24             change to AMODE 24\n         SPACE 1\n         CLOSE MF=(E,QPPRNT)            CLOSE OFF THE FILE\n         SPACE 1\n         BAL   R14,QAMODE31             resume AMODE 31\n         SR    R1,R1                    clear for ICM\n         ICM   R1,B'0111',QPPRNT+1      -> HASPPRNT\n         SPACE 1\n         FREEPOOL (1)                   FREE THE BUFFERS TOO\n         SPACE 1\n         MVC   DYNALLOC(F99LEN),F99PTR  COPY DYN FREE LIST\n         LA    R1,FREERB                RELOCATE THE LIST ADDRESSES.\n         STCM  R1,B'0111',FREEPTR+1     *\n         LA    R1,FREETXPT              *\n         ST    R1,FREETPTR              *\n         LA    R1,FREETU1               *\n         STCM  R1,B'0111',FREETXPT+1    *\n         LA    R1,FREETU2               *\n         STCM  R1,B'0111',FREETXPT+9    *\n         MVI   QDTOP+19,C'-'\n         MVC   QDTOP+20(37),QDTOP+19    CLEAR ANY PREVIOUS MESSAGE\n         LA    R14,QDTOP-8\n         AH    R14,QDCOLS               -> END+1 OF TOP LINE\n         SPACE 1\n         CLC   =C'DEL',QPARM1           FIRST OPERAND = DELETE?\n         BE    STOP$DEL                 YES - PROCESS\n         CLC   =C'HOLD',QPARM2          SECOND OPERAND = HOLD?\n         BE    STOPHOLD                 YES - PROCESS\n         CLI   QPARM2,C' '              SYSOUT CLASS SPECIFIED?\n         BE    STOP$STD                 NO - SKIP\n         EJECT ,\n*---  OVERRIDING SYSOUT CLASS SPECIFIED                            ---*\n         LR    R3,R14                   COPY END+1 ADDR\n         LA    R2,L'PRTSTP3             GET MSG LENGTH\n         SR    R3,R2                    GET MSG ADDR\n         MVC   0(L'PRTSTP3,R3),PRTSTP3  SET TITLE\n         MVC   L'PRTSTP3-1(1,R3),QPARM2 PUT SYSOUT CLASS IN TITLE\n         LA    R1,FREETU4               -> OVERRIDING CLASS TEXT UNIT\n         MVC   FREETU4+2+2+2(1),QPARM2  GET SYSOUT CLASS\n         B     STOPSPEC\n         SPACE 1\n*---  NO OVERRIDING CLASS OR 'HOLD' SPECIFIED                      ---*\nSTOP$STD LR    R3,R14                   COPY END+1 ADDR\n         LA    R2,L'PRTSTP1             GET MSG LENGTH\n         SR    R3,R2                    GET MSG ADDR\n         MVC   0(L'PRTSTP1,R3),PRTSTP1  STANDARD MESSAGE\n         B     STOP$GO                  GO PROCESS\n         SPACE 1\n*---  OVERRIDING 'HOLD' SPECIFIED                                  ---*\nSTOPHOLD LR    R3,R14                   COPY END+1 ADDR\n         LA    R2,L'PRTSTP2             GET MSG LENGTH\n         SR    R3,R2                    GET MSG ADDR\n         MVC   0(L'PRTSTP2,R3),PRTSTP2  SET TITLE\n         LA    R1,FREETU5               ASSUME OVERRIDING \"HOLD\"\n         B     STOPSPEC                 PROCESS\n         SPACE 1\n*---  DELETE REQUESTED                                             ---*\nSTOP$DEL LA    R1,FREETU3               -> TEXT UNIT FOR DISP=DELETE\n         LR    R3,R14                   COPY END+1 ADDR\n         LA    R2,L'PRTDEL              GET MSG LENGTH\n         SR    R3,R2                    GET MSG ADDR\n         MVC   0(L'PRTDEL,R3),PRTDEL    SET TITLE\n         SPACE 1\nSTOPSPEC STCM  R1,B'0111',FREETXPT+5    SAVE ADDR OF SPECIAL TEXT UNIT\nSTOP$GO  LA    R1,FREEPTR\n         DYNALLOC\n         NI    QPFLAG,255-HARDCPY       TURN OFF PRINT FLAG\n         TM    QTERMFLG,QTFTTY          DISPLAY TERMINAL?\n         BNO   GOTMSG                   YES - SKIP\n         LR    R0,R2                    GET MSG LENGTH\n         LR    R1,R3                    GET MSG ADDR\n         TPUT  (1),(0),R                NOT DISPLAY - PRINT MESSAGE\n         B     GOTMSG\n         SPACE 2\nPRTSTP1  DC    C' PRINT STOPPED; SYSOUT FREED FOR PRINT'\nPRTSTP2  DC    C' PRINT STOPPED; SYSOUT FREED TO HELD OUTPUT'\nPRTSTP3  DC    C' PRINT STOPPED; SYSOUT FREED FOR PRINTING IN CLASS=X'\nPRTDEL   DC    C' PRINT STOPPED; SYSOUT DELETED'\n         EJECT ,\n***********************************************************************\n* GET DATE/TIME FOR HEADING   ENTER WITH BAL R7,GETTIME\n* RETURNS WITH JDATE(LEN) = YY.DDD  HH:MM:SS DAY MTH DD,19YY\n*                           123456789.123456789.123456789.123\n*\n***********************************************************************\nGETTIME  TIME  DEC\n         ST    R1,DATE                  SAVE DATE FOR LATER\n***FORMAT THE PRESENT TIME (AS SET BY THE OPERATOR)\n         ST    R0,DBLWORK               CNVT PACKED TO DEC\n         MVC   MONMSK(MVCLEN),XMONMSK   MOVE IN AND INITIALIZE TBL/DAT\n         MVI   DBLWORK+4,X'0F'\n         UNPK  WORKWORD(9),DBLWORK(5)\n         MVC   TIMEHRS,WORKWORD         MOVE TIME TO MSG\n         MVC   TIMMINS,WORKWORD+2\n         MVC   TIMSECS,WORKWORD+4\n***FORMAT TODAY'S DATE INTO THE OUTPUT MSG\n         MVC   WORKWORD(4),DATE         MOVE DATE TO WORK AREA.\n         MVO   WORKWORD+1(3),WORKWORD(2)   MAKE 00YYDDDS INTO 00000YYS.\n         UNPK  CYR(2),WORKWORD+2(2)     FORMAT YEAR.\n         XC    DBLWORK,DBLWORK\n         MVC   DBLWORK+4(4),WORKWORD    CNVT YEAR TO BIN\n         CVB   R0,DBLWORK\n         ST    R0,BINYEAR               AND SAVE\n         TM    BINYEAR+3,X'03'          LEAP YEAR?\n         BNZ   MON1                     NO.\n         MVI   MONMSK+10,29             YES, CORRECT\nMON1     XC    DBLWORK,DBLWORK          CNVT DAYS TO BIN\n         MVC   DBLWORK+6(2),DATE+2\n         CVB   R2,DBLWORK\n         ST    R2,BINDAYS               SAVE FOR LATER\n         XR    R1,R1\n         LA    R15,11\nMON2     IC    R1,MONMSK(R15)           COMPUTE MON & DAY\n         SR    R2,R1\n         BNP   MONOVR\n         BCT   R15,MON2\n         B     *+6\nMONOVR   AR    R2,R1                    CORRECT OVERDRAW\n         CVD   R2,DBLWORK               FORMAT DAY\n         UNPK  CDAYN(2),DBLWORK+6(2)\n         OI    CDAYN+1,X'F0'            FIX UP SIGN\n         MH    R15,=H'3'                GET TABLE OFFSET\n         LA    R15,MONTAB(R15)          AND POINT AT MONTH\n         MVC   CMON(3),0(R15)           MOVE IT TO THE MSG\n         EJECT ,\n***DAY OF WEEK\n         L     R15,BINYEAR\n         SH    R15,=H'69'\n         BNP   OUTT                     MUST BE GREATER OR BAD\n         XR    R14,R14                  CLEAR DAY REG\n         D     R14,=F'4'\n         MH    R15,=H'5'\n         AR    R14,R15\n         A     R14,BINDAYS\n         SRDA  R14,32\n         D     R14,=F'7'                MODULO 7 FOR WEEK\n         MH    R14,=H'3'\n         LA    R14,DAYTAB(R14)          POINT AT TODAY\n         MVC   CDAY(3),0(R14)           INSERT IN MSG\n***\nMOVEJD   MVC   JDATE-1(7),=X'4020204B202020'\n         ED    JDATE-1(7),DATE+1\n*\nDATERTN  BR    R7                       RETURN TO MAINLINE\n*\nOUTT     MVC   CDAY(3),=CL3'???'\n         B     MOVEJD\n         SPACE 2\n***********************************************************************\n* LEAVE FIELDS TOGETHER.. INITIALIZED BY ONE MVC WITH VALUES\n*\nXMONMSK  DC    AL1(31,30,31,30,31,31,30,31,30,31,28,31)  L\n         DC    C' XX.XXX',C'  '                          E  F\n         DC    CL2' ',C':'                               A  I  T\n         DC    CL2' ',C':'                               V  E  O\n         DC    CL2' ',C' '                               E  L  G\n         DC    CL3' ',C' '                                  D  E\n         DC    CL3' ',C' '                                  S  T\n         DC    CL2' ',C',19'                                   H\n         DC    CL2'  ',C' '                                    E\n*                                                              R\n***********************************************************************\nMVCLEN   EQU   *-XMONMSK\n*\n***********************************************************************\nDAYTAB   DC    C'TUEWEDTHRFRISATSUNMON'\nMONTAB   DC    C'DECNOVOCTSEPAUGJULJUNMAYAPRMARFEBJAN'\n         DC    0H'0'\n         EJECT ,\n***********************************************************************\n*\n*  ALLOC HARDCOPY TO HASPPRNT DDNAME\n*\n***********************************************************************\nALLOCHC  TM    QPFLAG,HARDCPY           IS HARDCOPY ALREADY ON?\n         BOR   R7                       YES - JUST RETURN TO CALLER\n         ZAP   QPAGEN,=P'0'             Reset Page no\n         MVI   QPHEAD1,C'0'             ASA ON HEADING SO START FRESH\n         MVC   DYNALLOC(S99LENG),S99RBPTR COPY DYN ALLOCATION LIST.\n         LA    R1,P99RB                 RELOCATE THE LIST ADDRESSES.\n         STCM  R1,B'0111',P99RBPTR+1    *\n         LA    R1,P99PDDN               *\n         ST    R1,P99TXTPP              *\n         LA    R1,P99TDDN               *\n         ST    R1,P99PDDN               *\n         LA    R1,P99TCLAS              *\n         ST    R1,P99PCLAS              *\n         LA    R1,P99TDEST              *\n         ST    R1,P99PDEST              *\n***********************************************************************\n*  PROCESS PARMS..........\n***********************************************************************\n         MVC   P99CLASS,QPCLASS         SET DEFAULT PRINT CLASS\n         CLC   QLNG2,=H'1'              LENGTH OF SECOND PARM > 1?\n         BH    CLASSBAD                 YES - INVALID\n         BL    CLASSOK                  SKIP IF OMITTED\n         CLI   QPARM2,C'A'              IS IT ALPHA?\n         BL    CLASSBAD                 NO - INVALID\n         MVC   P99CLASS,QPARM2          MOVE IN PARM FOR SYSOUT CLASS\nCLASSOK  MVC   P99DEST,QPDEST           SET DEFAULT DEST\n         MVC   P99FCB,QPFCB             SET DEFAULT FCB\n         MVC   P99UCS,QPUCS             SET DEFAULT UCS\n         MVC   P99FORM,QPFORM           SET DEFAULT FORM\n         SPACE 2\n         LA    R14,QKEYWORD             -> FIRST KEYWORD\n         LA    R0,16                    ENTRY LENGTH\n         LA    R1,QKEYLAST              -> PAST LAST KEYWORD\n         SPACE 1\nPR$KEYLP CLI   0(R14),C' '              ANY KEYWORD HERE?\n         BE    PR$KEYSP                 NO - DONE WITH KEYWORDS\n         SPACE 1\n*---  CHECK FOR 'DEST='                                            ---*\n         BAL   R15,*+10                 SET INST ADDR\n         MVC   P99DEST,8(R14)           << EXECUTED >>\n         CLC   =C'DEST',0(R14)          IS THIS DEST?\n         BE    PR$GOTKY                 YES - GO SAVE OPERAND\n         SPACE 1\n*---  CHECK FOR 'UCS='                                             ---*\n         BAL   R15,*+10                 SET INST ADDR\n         MVC   P99UCS,8(R14)            << EXECUTED >>\n         CLC   =C'UCS',0(R14)           IS THIS UCS?\n         BE    PR$GOTKY                 YES - GO SAVE OPERAND\n         SPACE 1\n*---  CHECK FOR 'FCB='                                             ---*\n         BAL   R15,*+10                 SET INST ADDR\n         MVC   P99FCB,8(R14)            << EXECUTED >>\n         CLC   =C'FCB',0(R14)           IS THIS FCB?\n         BE    PR$GOTKY                 YES - GO SAVE OPERAND\n         SPACE 1\n*---  CHECK FOR 'FORM='                                            ---*\n         BAL   R15,*+10                 SET INST ADDR\n         MVC   P99FORM,8(R14)           << EXECUTED >>\n         CLC   =C'FORM',0(R14)          IS THIS FORM?\n         BE    PR$GOTKY                 YES - GO SAVE OPERAND\n         QTILT '*** LOGIC ERROR IN \"ALLOCHC\" ***'\nPR$GOTKY EX    0,0(,R15)                MOVE THE OPERAND\n         BXLE  R14,R0,PR$KEYLP          SCAN ALL KEYWORD SLOTS\n         SPACE 1\n*---  SET POINTERS TO OPTIONAL TEXT UNITS\nPR$KEYSP LA    R0,P99TDEST              -> TEXT UNIT\n         CLI   P99DEST,C' '             ANY DEST FROM EITHER SOURCE?\n         BNH   *+8                      NO - DON'T USE THIS TEXT KEY\n         ST    R0,P99PDEST              YES - SET TEXT UNIT POINTER\n         SPACE 1\n         LA    R0,P99TFCB               -> TEXT UNIT\n         CLI   P99FCB,C' '              IS THERE ANYTHING?\n         BE    *+8                      NO - DON'T USE THIS TEXT KEY\n         ST    R0,P99PFCB               YES - SET TEXT UNIT POINTER\n         SPACE 1\n         LA    R0,P99TUCS               -> TEXT UNIT\n         CLI   P99UCS,C' '              IS THERE ANYTHING?\n         BE    *+8                      NO - DON'T USE THIS TEXT KEY\n         ST    R0,P99PUCS               YES - SET TEXT UNIT POINTER\n         SPACE 1\n         LA    R0,P99TFORM              -> TEXT UNIT\n         CLI   P99FORM,C' '             IS THERE ANYTHING?\n         BE    *+8                      NO - DON'T USE THIS TEXT KEY\n         ST    R0,P99PFORM              YES - SET TEXT UNIT POINTER\n         SPACE 1\n*  DO THE ALLOCATE\n         LA    1,DYNALLOC               ADDR OF PARM LIST FOR DYNALLOC.\n         DYNALLOC\n         LTR   R15,R15                  CHK RETURN CODE\n         BNZ   CANTALLC                 NO CAN DO..POST MESSAGE\n         BAL   R14,QAMODE24             change to AMODE 24\n         OPEN  MF=(E,QPPRNT)            OPEN THE FILE\n         BAL   R14,QAMODE31             resume AMODE 31\n         SR    R1,R1                    clear for ICM\n         ICM   R1,B'0111',QPPRNT+1      -> HASPPRNT DCB\n         TM    48(R1),X'10'             CHECK FOR SUCCESSFUL OPEN.\n         BZ    PRNTBAD                  SKIP SWITCH SETTING IF BAD OPEN\n         OI    QPFLAG,HARDCPY           INDICATE HARDCPY FILE AVAILABLE\n         MVC   QDTOP+19(30),=C' PRINT STARTED; SYSOUT=X,DEST='\n         MVC   QDTOP+42(1),P99CLASS     MOVE IN SYSOUT CLASS\n         MVC   QDTOP+49(8),P99DEST\n         CLI   QDTOP+49,C' '            ANY DEST?\n         BHR   R7\n         MVC   QDTOP+49(8),QPDEST       SAY LOGON DEFAULT DEST\n         CLI   QPDEST,C' '              STILL BLANK?\n         BHR   R7                       NO - OK\n         MVC   QDTOP+49(8),=C'CENTRAL ' WHEN ALL ELSE FAILS...\n         BR    R7                       RETURN\n         SPACE 3\nPRNTBAD  QTILT '*** UNABLE TO ALLOC/OPEN HASPPRNT FOR HARDCOPY ***'\nCLASSBAD QTILT '*** INVALID SYSOUT CLASS (SECOND OPERAND) ***',        $\n               OPTIONS=(REPROMPT,SET)\n***********************************************************************\n*        FORMULATE TEXT FOR SVC99 ALLOCATE FAILURE\n***********************************************************************\n         SPACE 3\nCANTALLC CLC   P99ERROR,=X'046C'        WAS IT 'RMT NOT DEF TO JES2'?\n         BE    BADRMT                   YES..POST MSG AND EXIT\n*\n         MVC   QDTOP(L'MSGERR),MSGERR\n         CVD   R15,DBLWORK              CONVERT SVC 99 RETURN CODE\n         MVC   QDTOP+53(4),=X'40202020' TO NICE PRINTABLE DECIMAL\n         ED    QDTOP+53(4),DBLWORK+6\n*\n         UNPK  QDTOP+34(5),P99ERROR(3)  CONVERT DYNAM ALLOC ERR CODE\n         TR    QDTOP+34(4),QHEXTAB      TO PRINTABLE HEXADECIMAL\n         MVI   QDTOP+38,C' '\n*\n         UNPK  QDTOP+44(5),P99INFO(3)   CONVERT DYNAM ALLOC INFO\n         TR    QDTOP+44(4),QHEXTAB      CODE TO PRNTABLE HEX\n         MVI   QDTOP+48,C' '\n         B     GOTMSG                   AND GO POST THE MESSAGE\n*\nBADRMT   MVC   QDTOP(L'MSGNRMT),MSGNRMT    MOVE IN NO SUCH REMOTE MSG\n         MVC   QDTOP+7(8),P99DEST       MOVE IN REMOTE ASKED FOR\n         B     GOTMSG                   AND GO POST THE MESSAGE\n         SPACE 2\nPR#CMD   LC    '/COMMAND ===>'\nMSGNRMT  DC    C'REMOTE XXXXXXXX NOT DEFINED TO JES2; PRINT BYPASSED'\nMSGERR   DC    C'CANT ALLOC SYSOUT FOR PRINT; DARC=XXXX INFO=XXXX R15=X$\n               XXX '\n         SPACE 2\n         ENTRY PR#KEYS\nPR#KEYS  DC    CL8'DEST    '\n         DC    CL8'UCS     '\n         DC    CL8'FCB     '\n         DC    CL8'FORM    '\n*        DC    CL8'CHARS   '\n*        DC    CL8'HOLD    '\n*        DC    CL8'LINECNT '\n         DC    X'FF'                    END OF KEYWORD TABLE\n         EJECT ,\n         LTORG\n         EJECT ,\n         DC    0F'0'\n*                                       SVC 99 REQUEST BLOCK  PTR\nS99RBPTR DC    X'80',AL3(S99RB)\n*                                       SVC 99 REQUEST BLOCK\nS99RB    DC    0F'0'\nS99RBLN  DC    AL1(20)                  LENGTH=20 BYTES\nS99VERB  DC    X'01'                    VERB CODE=01 (DSNAME ALLOC)\nS99FLAG1 DC    X'1000'                  DONT USE EXISTING ALLOC\nS99ERROR DC    AL2(0)                           ERROR CODE\nS99INFO  DC    AL2(0)                           INFO  CODE\nS99TXTPP DC    A(S99PDDN)               POINTER TO TEXT UNIT POINTERS\nS99RSVD1 DC    A(0)                       RESERVED\nS99FLAG2 DC    A(0)                       FLAGS 2\nS99PDDN  DC    A(S99TDDN)               TEXT UNIT POINTERS\nS99PCLAS DC    A(S99TCLAS-S99TCLAS)     -> CLASS TEXT UNIT\nS99PFCB  DC    A(S99TFCB-S99TFCB)       -> FCB TEXT UNIT, OR ZERO\nS99PUCS  DC    A(S99TUCS-S99TUCS)       -> UCS TEXT UNIT, OR ZERO\nS99PFORM DC    A(S99TFORM-S99TFORM)     -> FORM TEXT UNIT, OR ZERO\nS99PDEST DC    A(S99TDEST-S99TDEST)     -> DEST TEXT UNIT, OR ZERO\n         DC    X'80000000'              LAST TEXT UNIT POINTER\nS99TDDN  DC    X'0001',AL2(1,8),C'HASPPRNT'  DDNAME=HASPPRNT\nS99TCLAS DC    X'0018',AL2(1,1)         SYSOUT=A\nS99CLASS DC    C'A'\nS99TFCB  DC    X'0025',AL2(1,4)         FCB=\nS99FCB   DC    CL4' '\nS99TUCS  DC    X'0029',AL2(1,4)         UCS=\nS99UCS   DC    CL4' '\nS99TFORM DC    X'001A',AL2(1,4)         FORM=\nS99FORM  DC    CL4' '\nS99TDEST DC    X'0058',AL2(1,8)         DEST=\nS99DEST  DC    CL8' '\n         DC    0D'0'\nS99LENG  EQU   *-S99RBPTR               LENGTH OF WHOLE MAGILLA\n         SPACE 3\n*.....................................................................*\n*.       DYNAMIC ALLOCATION REQUEST BLOCK TO FREE DDNAME HASPPRNT    .*\n*.....................................................................*\n         SPACE 3\n         DC    0F'0'                    GET FULLWORD BOUNDARY\nF99PTR   DC    X'80',AL3(F99RB)         THE POINTER TO THE MESS..\n*\nF99RB    DC    FL1'20'                  LENGTH OF RB IN BYTES = 20\n         DC    XL1'02'                  VERB CODE=X'02'..FREE BY DDN\n         DC    AL2(0)                   FLAGS1..NO OPTIONS\nF99RC    DC    XL2'0000'                ERROR CODE\nF99INFO  DC    XL2'0000'                INFO CODE\n         DC    AL4(F99TXPT)             ADDRESS OF TEXT UNITS\n         DC    XL4'00'                  RESERVED\n         DC    XL4'00'                  FLAGS2\n         SPACE 2\nF99TXPT  DC    AL4(F99TU1)              ADDR OF DSN TEXT UNIT\n         DC    AL4(0)                   -> T.U. FOR DEL, CLASS, OR HOLD\n         DC    X'80',AL3(F99TU2)        ADDR OF UNALLOC TEXT TU(LAST)\n         SPACE 2\nF99TU1   DC    X'0001',AL2(1,8),C'HASPPRNT'  DDNAME\nF99TU2   DC    X'0007',AL2(0)           UNALLOC EVEN IF PERM ALLOC\nF99TU3   DC    X'0005',AL2(1,1),X'04'   OVERRIDING DISP=DELETE\nF99TU4   DC    X'0018',AL2(1,1),C' '    OVERRIDING SYSOUT CLASS\nF99TU5   DC    X'0059',AL2(0)           OVERRIDING SYSOUT HOLD\nF99LEN   EQU   *-F99PTR                 LENGTH OF FILEDS\n         EJECT ,\n***********************************************************************\nWORK     DSECT\n         ORG   WORK+72                  SKIP OVER SAVE AREA\nPR@FIRST DS    PL4                      FIRST DS RECORD # TO PRINT\nPR@LAST  DS    PL4                      LAST  DS RECORD # TO PRINT\nPR@FLAG  DS    B\nPR@PRTED EQU   X'80'                    WE HAVE PRINTED SOMETHING\nPR@WORKL EQU   *-WORK\nDBLWORK  DS    D\nBINYEAR  DS    F\nBINDAYS  DS    F\nDATE     DS    F\nWORKWORD DS    2F,C\nPR@CC    DS    C                        ASA\nPR@LINE  DS    CL132\n         DS    CL150                    SLOP FACTOR (SEE PR$RA)\n         DS    0D\nPR@EDWRK DS    0CL20                    WORK AREA FOR EDMK\nPR@TRTAB DS    XL256\n***********************************************************************\n* LEAVE FIELDS TOGETHER.. INITIALIZED BY ONE MVC WITH VALUES\n*\nMONMSK   DC    AL1(31,30,31,30,31,31,30,31,30,31,28,31)\n         DC    CL1' '                                    L\nJDATE    DC    C'XX.XXX',C'  '                           E  F\nTIMEHRS  DC    CL2' ',C'.'                               A  I  T\nTIMMINS  DC    CL2' ',C'.'                               V  E  O\nTIMSECS  DC    CL2' ',C' '                               E  L  G\nCDAY     DC    CL3' ',C' '                                  D  E\nCMON     DC    CL3' ',C' '                                  S  T\nCDAYN    DC    CL2' ',C',19'                                   H\nCYR      DC    CL2'  ',C' '                                    E\n*                                                              R\n***********************************************************************\nLEN      EQU   *-JDATE\n         SPACE 2\n         DS    0F\nDYNALLOC DS    (S99LENG)XL1\n         ORG   DYNALLOC\n*                                       SVC 99 REQUEST BLOCK  PTR\nP99RBPTR DC    X'80',AL3(P99RB)\n*                                       SVC 99 REQUEST BLOCK\nP99RB    DC    0F'0'\nP99RBLN  DC    AL1(20)                  LENGTH=20 BYTES\nP99VERB  DC    X'01'                    VERB CODE=01 (DSNAME ALLOC)\nP99FLAG1 DC    X'1000'                  DONT USE EXISTING ALLOC\nP99ERROR DC    AL2(0)                           ERROR CODE\nP99INFO  DC    AL2(0)                           INFO  CODE\nP99TXTPP DC    A(P99PDDN)               POINTER TO TEXT UNIT POINTERS\nP99RSVD1 DC    A(0)                          RESERVED\nP99FLAG2 DC    A(0)                          FLAGS 2\nP99PDDN  DC    A(P99TDDN)               TEXT UNIT POINTERS\nP99PCLAS DC    A(P99TCLAS)              -> CLASS TEXT UNIT\nP99PFCB  DC    A(P99TFCB)               -> FCB TEXT UNIT, OR ZERO\nP99PUCS  DC    A(P99TUCS)               -> UCS TEXT UNIT, OR ZERO\nP99PFORM DC    A(P99TFORM)              -> FORM TEXT UNIT, OR ZERO\nP99PDEST DC    A(P99TDEST)              -> DEST TEXT UNIT, OR ZERO\n         DC    X'80000000'              LAST TEXT UNIT POINTER\nP99TDDN  DC    X'0001',AL2(1,8),C'HASPPRNT'  DDNAME=HASPPRNT\nP99TCLAS DC    X'0018',AL2(1,1)         SYSOUT=A\nP99CLASS DC    C'A'\nP99TFCB  DC    X'0025',AL2(1,4)         FCB=\nP99FCB   DC    CL4' '\nP99TUCS  DC    X'0029',AL2(1,4)         UCS=\nP99UCS   DC    CL4' '\nP99TFORM DC    X'001A',AL2(1,4)         FORM=\nP99FORM  DC    CL4' '\nP99TDEST DC    X'0058',AL2(1,8)         DEST=\nP99DEST  DC    CL8' '\n         SPACE 3\n         ORG   DYNALLOC\n         DC    0F'0'                    GET FULLWORD BOUNDARY\nFREEPTR  DC    X'80',AL3(FREERB)        THE POINTER TO THE MESS..\n*\nFREERB   DC    FL1'20'                  LENGTH OF RB IN BYTES = 20\n         DC    XL1'02'                  VERB CODE=X'02'..FREE BY DDN\n         DC    AL2(0)                   FLAGS1..NO OPTIONS\nFREERC   DC    XL2'0000'                ERROR CODE\nFREEINFO DC    XL2'0000'                INFO CODE\nFREETPTR DC    AL4(FREETXPT)            ADDRESS OF TEXT UNITS\n         DC    XL4'00'                  RESERVED\n         DC    XL4'00'                  FLAGS2\n         SPACE 2\nFREETXPT DC    AL4(FREETU1)             ADDR OF DSN TEXT UNIT\n         DC    AL4(0)                   -> T.U. FOR DEL, CLASS, OR HOLD\n         DC    X'80',AL3(FREETU2)       ADDR OF UNALLOC TEXT TU(LAST)\n         SPACE 2\nFREETU1  DC    X'0001',AL2(1,8),C'HASPPRNT'   DDNAME\nFREETU2  DC    X'0007',AL2(0)           UNALLOC EVEN IF PERM ALLOC\nFREETU3  DC    X'0005',AL2(1,1),X'04'   OVERRIDING DISP=DELETE\nFREETU4  DC    X'0018',AL2(1,1),C' '    OVERRIDING SYSOUT CLASS\nFREETU5  DC    X'0059',AL2(0)           OVERRIDING SYSOUT HOLD\n         ORG   ,\n         SPACE 1\n         DROPX R13,R8                   WORK, QPRNTWA\n         SPACE 1\n         QCOMMON\n         SPACE 2\n         Q$LRC\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "Q#QC": {"ttr": 14090, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x84!_\\x00\\x84!_ !\\x00\\x0c\\x00\\x0b\\x00\\x02\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1984-08-02T00:00:00", "modifydate": "1984-08-02T20:21:00", "lines": 12, "newlines": 11, "modlines": 2, "user": "LDW"}, "text": "         TITLE '--- QUEUE--COMMON AREA CSECT ---'\n*---------------------------------------------------------------------*\n*                                                                     *\n*   THIS MEMBER IS USED ONLY IF QCOMMON NEEDS TO BE RE-ASSEMBLED,     *\n*   AND FOR SOME REASON IT IS NOT NECESSARY TO RE-ASSEMBLE ALL OF     *\n*   QUEUE.  DON'T ASK ME WHY.                                         *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 3\nQUEUE    QSTART  TYPE=COMMON\n         QCOMMON  CSECT=YES\n         QDCB\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "Q#QD": {"ttr": 14092, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x17\\x00\\x00\\x00\\x82#/\\x00\\x91\\x18_ \\x14\\x00x\\x00+\\x00c\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "05.23", "flags": 0, "createdate": "1982-08-20T00:00:00", "modifydate": "1991-07-04T20:14:00", "lines": 120, "newlines": 43, "modlines": 99, "user": "LDW"}, "text": "         TITLE '--- QUEUE--COMMON AREA CSECT ---'\n*---------------------------------------------------------------------*\n*                                                                     *\n*   This member is provided to expand all DSECTs separately, so that  *\n*   you can run it once with PRINT GEN and store it, then do all the  *\n*   other assemblies with PRINT NOGEN (actually, &@@QDOC set to       *\n*   NOGEN)                                                            *\n*                                                                     *\n*   Updates:                                                          *\n*      30Jan91  LDW  Add QZIHAETD, QZJSCB, QZPSA, QZTCB, QZTSVT       *\n*      20Dec90  LDW  Add QZZB505, Q$LMT                               *\n*      16Dec90  LDW  Add QXRAX                                        *\n*      10Dec89  LDW  Change Qxxx MVS macros to QZxxx                  *\n*                    Add QZOUCB and QZDCBD (inadvertantly omitted)    *\n*      23Nov89  LDW  Remove most conditional assembly, since it has   *\n*                       has been added to the individual macros       *\n*                    Change Q$DEB to QDEB                             *\n*      25Apr89  EMS  Add Q$HCCT for SP311, skip Q$SVT if SP311        *\n*                       Q$KAC for incore ckpt                         *\n*      17Apr89  LDW  Change Q$UCB to QUCB                             *\n*      14DEC86  LDW  ADD Q$TQE FOR SP136, SKIP Q$TGM IF SP136         *\n*      22JUN86  LDW  INVOKE ACFNJBLK AND ACVALD INSTEAD OF ACFJCB IF  *\n*                       ACF2 RELEASE 4.1 OR LATER                     *\n*                    USE &@@ACF2 INSTEAD OF &QACF2                    *\n*      16JUN86  LDW  ADD $KIT                                         *\n*      10/10/85 LDW  ADD $CHK FOR SP133                               *\n*      08/30/84 LDW  INSERT DROPX IN FRONT OF DROP                    *\n*      08/02/84 LDW  INSERT QSTART TYPE=COMMON TO SCAN SYSPARM        *\n*      06/05/84 LDW  ADD $DAS FOR SP133                               *\n*      04/16/84 LDW  REMOVE QMCS                                      *\n*      04/10/84 LDW  ADD $MIT AND $XECB FOR SP133                     *\n*      03/27/84 LDW  ADD $NHD, #ACFJCB FOR ACF2 R314 WITH JES2 SP13   *\n*      01/24/83 LDW  SKIP $HQR & $HQT IF SP; ADD QACFJCTX FOR SP ACF2 *\n*                    ADD Q$DEB FOR SP                                 *\n*      01/04/83 LDW  ADD Q$PCE IF SP; MOVE Q$JQE FOR SP; ADD Q$DCT    *\n*                    ADD PREVIOUSLY OMITTED: Q$HQR, Q$HQT, Q$TAB,     *\n*                       Q$TGM                                         *\n*      12/01/82 LDW  ADD Q$LRC                                        *\n*                                                                     *\n*---------------------------------------------------------------------*\n         EJECT\n         QSTART  TYPE=COMMON\n         EJECT\n         QCOMMON  CSECT=YES\n         QDCB\n         SPACE 3\n         DROPX ,                        JUST IN CASE\n         DROP  ,                        JUST IN CASE\n         SPACE 3\n         PRINT &@@QDOC                  THE REST IS NOT INTERESTING\n         TITLE '--- QUEUE--JES2 AND MVS DSECTS ---'\nQUEUE    CSECT                          AVOID ZERO LENGTH PRIVATE CODE\n*  Generate all dsects here...\n         QZACCVT\n         QZACDSV\n         QZACFJCB\n         QZACFNJB\n         QZACVALD\n         QZASCB\n         QZASVT\n         Q$CHK\n         QZCPPL\n         QZCSCB\n         QZCVT\n         Q$DAS\n         QZDCBD\n         Q$DCT\n          AIF   (&QLEVEL LT 4).QDNODEB\n         QZDEB\n.QDNODEB  ANOP\n         Q$JQE                          MUST PRECEDE $HCT (FOR SP)\n          AIF   (&QLEVEL LT 4).QDNOPCE\n         Q$PCE                          MUST PRECEDE $HCT (FOR SP)\n.QDNOPCE  ANOP\n          AIF   (&QLEVEL LT 5).QDNOMIT\n         Q$MIT                          MUST PRECEDE $HCT (FOR SP133)\n.QDNOMIT  ANOP\n         Q$HCCT\n         Q$LMT\n         Q$HCT\n         Q$HQR\n         Q$HQT\n         Q$PDDB  ,                      MUST PRECEDE $IOT\n         QZIHAETD  ,                    (invoked by QCOMMON)\n         Q$IOT\n         Q$JCT ,                        NEEDS EQUS' IN Q$IOT\n         QZJESCT\n         Q$JOE ,                        MUST PRECEDE $JOT\n         Q$JOT\n         Q$JQT\n         QZJSCB  ,\n         Q$KAC\n         Q$KIT\n         QZKEYS\n         QZTEXT ,                       KEEP AFTER $KEYS   (TO SEE IT)\n         Q$LRC\n         Q$NHD\n         QZOUCB\n         Q$PIT\n         QZPSA ,\n         QZPSCB\n         Q$QSE\n         QZRAX\n         Q$RDT\n         Q$TQE                          MUST PRECEDE $SJB\n         Q$SJB\n         QZSSCT\n         QZSSIB\n         QZSSOB\n         Q$XECB                         MUST PRECEDE $SVT (FOR SP133)\n         Q$SVT\n         Q$TAB                          %%%% BEFORE WHAT????\n         Q$TGM                          %%%% BEFORE WHAT????\n         QZTCB ,\n         QZTSVT  ,\n         QZUCB\n******** QZMCS\n         QZZB505\n         SPACE 2\n         PRINT &@@QPRNT\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "Q#QI": {"ttr": 14339, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x12\\x00\\x00\\x00\\x825o\\x00\\x91\\x15\\x1f\\x18&\\x013\\x00\\xaf\\x00\\xdb\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.18", "flags": 0, "createdate": "1982-12-22T00:00:00", "modifydate": "1991-05-31T18:26:00", "lines": 307, "newlines": 175, "modlines": 219, "user": "LDW"}, "text": "  TITLE '--- QUEUE--QINNARDS -- DISPLAY/CHANGE INTERNAL Q CMD INFO ---'\n*---------------------------------------------------------------------*\n*                                                                     *\n*   QINNARDS - Display internal QUEUE statistics, display and change  *\n*              some other parameters and flags                        *\n*                                                                     *\n*   Entry - QKEYWORDS = mode change (none = display only)             *\n*                                                                     *\n*   Note - This subcommand may be executed in a QUEUE profile         *\n*                                                                     *\n*   Note - This subcommand is restricted to privileged users          *\n*                                                                     *\n*   Updates:                                                          *\n*      31May91  LDW  Don't display QCJQETTR, QCJOETTR, QCJQENUM,      *\n*                       QCJOENUM for inappropriate levels of JES2     *\n*      19May91  LDW  Rewrite APPLCPY/NOAPPCPY/KAC display logic       *\n*      29Mar91  LDW  Display indicator of in-storage ckpt use         *\n*      25Dec89  LDW  Q$PSCB -> QZPSCB                                 *\n*       3Jun87  EMS  Add QDSIZE Display                               *\n*                    Remove LC macro                                  *\n*      16JUN86  LDW  DISPLAY TTR & NUMBER OF JQE AND JOE CKPT AREAS   *\n*      03JUN86  LDW  DISPLAY HASPCKPT NCP                             *\n*      03/31/86 LDW  RE-DESIGN 3278-5 SUPPORT (THIRD TRY!)            *\n*      08/07/84 LDW  UPDATE FOR SP134 (DON'T DISPLAY QCPDDB1)         *\n*      01/19/84 LDW  ADD SUPPORT FOR COMMAND STACKING                 *\n*      03/02/83 LDW  CHANGE 'QTILT *' TO USE QERRMSG                  *\n*                    CHANGE HDR AND SOME DATA TO LOWER CASE           *\n*      02/02/83 LDW  PUT TRAILING ZEROS IN OPERAND OF DEBUG=          *\n*      01/19/83 LDW  ADD SIDTRAN/NOSIDTRAN AND DEBUG=                 *\n*      01/06/83 LDW  ADD QCSIZE DISPLAY                               *\n*      01/05/83 LDW  USE QKEYWORDS INSTEAD OF QPARM1                  *\n*                    CHANGE HEADER TO LOWER CASE                      *\n*      12/22/82 LDW  ROUTINE SPLIT OUT FROM \"MODE\"                    *\n*                    DISPLAY QCPDDB1                                  *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 3\nQINNARDS QSTART  STACK=X'B0'\n         USING WORK,R13\n         QCALL DISP80                   SWITCH TO 3278-2 MODE IF 3278-5\n         L     R1,X'218'                -> TCB\n         L     R1,180(,R1)              -> JSCB\n         L     R7,264(,R1)              -> PSCB\n         USING PSCB,R7\n         MVC   QDPROMPT,QDREPLY         SET UP WHAT TO REPROMPT\n         CLI   QKEYWORD,C' '            DISPLAY REQUEST?\n         BE    QI$STAR                  YES\n         TM    QFLAG1,Q1PROFOK+Q1IMMED  IMMED COMMAND AFTER INIT PROF?\n         BO    QI$STOP                  YES - CONVERT TO NON-IMMED\n         SPACE 1\n         LA    R5,QKEYWORD              -> FIRST KEYWORD OPERAND\n         LA    R6,QKEYLAST              -> PAST LAST ONE\n         SPACE 2\nQI$LOOP1 LA    R2,QI#KEYS               -> KEYWORDS TABLE\n         LR    R3,R2                    COPY\n         SPACE 1\nQI$LOOP2 CLC   0(8,R2),0(R5)            IS THIS IT?\n         BE    QI$FOUND                 YES\n         LA    R2,8(,R2)                -> NEXT TABLE ENTRY\n         CLI   0(R2),X'FF'              END OF TABLE?\n         BNE   QI$LOOP2                 NO - TRY NEXT\n         SPACE 1\nQI$TILT  MVC   QERRMSG(25),=C'*** UNKNOWN QINT CHANGE -'\n         MVC   QERRMSG+26(8),0(R5)      MOVE IN THE KEYWORD\n         MVC   QERRMSG+35(3),=C'***'\n         QTILT *,OPTIONS=REPROMPT\n         SPACE 2\nQI$NEXT  LA    R5,16(,R5)               -> NEXT QKEYWORD\n         CR    R5,R6                    PAST END?\n         BNL   QI$SET                   YES - GO DISPLAY RESULTS\n         CLI   0(R5),C' '               ANYTHING HERE?\n         BE    QI$SET                   NO - GO DISPLAY RESULTS\n         B     QI$LOOP1                 SEE WHAT THIS ONE IS\n         SPACE 3\nQI$FOUND LR    R15,R2                   COPY TABLE ENTRY ADDRESS\n         SR    R15,R3                   COMPUTE OFFSET INTO KEYWORD TBL\n         SRL   R15,1                    KEYWORDS ARE 8 BYTES, BR TABLE\n*                                       ENTRIES ARE 4 BYTES\n         B     *+4(R15)                 SELECT CORRECT ROUTINE\n*---  MUST HAVE A ONE-FOR-ONE CORRESPONDENCE BETWEEN TABLE BELOW AND\n*---  QI#KEYS\n         B     QI$DEBUG                 DEBUG\n         B     QI$SIDTR                 SIDTRAN\n         B     QI$NOSTR                 NOSIDTRAN\n         B     QI$USER                  USERMODE\n         B     QI$USER                  USER\n         B     QI$SYSP                  SYSP\n         B     QI$NSYSP                 NOSYSP\n         B     QI$OPER                  OPER\n         B     QI$NOPER                 NOPER\n         B     QI$COMCH                 COMCHAR=\n         B     QI$COMCH                 COMCHR=\n         SPACE 2\nQI$DEBUG XC    QDEBUG,QDEBUG            ASSUME NO OPERAND\n         CLI   8(R5),C' '               ANY OPERAND?\n         BE    QI$NEXT                  NO - DONE\n         LA    R1,8+7(,R5)              -> TAIL END\nQI$DBG$1 CLI   0(R1),C' '               TRAILING BLANK?\n         BNE   QI$DBG$2                 NO - CONTINUE\n         MVI   0(R1),C'0'               YES - CHANGE IT TO A ZERO\n         BCT   R1,QI$DBG$1              GET ALL TRAILING BLANKS\n         EX    0,*\nQI$DBG$2 TR    8(8,R5),QI#TRTAB         CONVERT TO PSEUDO HEX\n         PACK  QNUMWORK(4+1),8(8+1,R5)  CONVERT TO READ HEX\n         MVC   QDEBUG,QNUMWORK          AND SAVE IT IN CORRECT PLACE\n         B     QI$NEXT\n         SPACE 1\nQI$SIDTR LA    R0,QSYSID                -> TRANSLATED SYSTEM ID TABLE\n         ST    R0,QVSYSID               SET UP AS TABLE TO USE\n         B     QI$NEXT\n         SPACE 1\nQI$NOSTR LA    R0,QSMFID                -> SMF ID TABLE\n         ST    R0,QVSYSID               SET UP AS TABLE TO USE\n         B     QI$NEXT\n         SPACE 1\nQI$USER  NI    QXAUTH,255-QXAUTHX       TURN OFF ALL PRIV FLAGS\n         B     QI$NEXT\n         SPACE 1\nQI$SYSP  TM    PSCBATR1,PSCBACCT        SYSTEMS PROGRAMMER?\n         BNO   QI$TILT                  NO - PRETEND LIKE INVALID MODE\n         OI    QXAUTH,QXSYSP            YES - PRIVILEGE HIM AGAIN\n         B     QI$NEXT\n         SPACE 1\nQI$NSYSP NI    QXAUTH,255-QXSYSP        DE-PRIVILEGE\n         B     QI$NEXT\n         SPACE 1\nQI$OPER  TM    PSCBATR1,PSCBACCT        SYSTEMS PROGRAMMER?\n         BNO   QI$TILT                  NO - PRETEND LIKE INVALID MODE\n         OI    QXAUTH,QXOPER            YES - PRIVILEGE HIM\n         B     QI$NEXT\n         SPACE 1\nQI$NOPER NI    QXAUTH,255-QXOPER        DE-PRIVILEGE\n         B     QI$NEXT\n         SPACE 1\nQI$COMCH MVC   QCOMCHAR,8(R5)           SAVE REQUESTED COM CHAR\n         B     QI$NEXT\n         SPACE 3\nQI$SET   TM    QFLAG1,Q1PROFOK          INIT PROFILE COMPLETE?\n         BNO   QSTOP                    NO - DON'T GENERATE DISPLAY\n*  \"IMMED\" WILL HAVE BEEN TURNED OFF THE FIRST TIME IN\n         B     QI$DISP                  GO DISPLAY CURRENT OPTIONS\n         SPACE 3\nQI$STAR  TM    QFLAG1,Q1IMMED           ARE WE HERE AS \"IMMEDIATE\"?\n         BNO   QI$DISP                  NO - GO GENERATE DISPLAY\n         SPACE 1\nQI$STOP  NI    QFLAG1,255-Q1IMMED       YES - RESET FLAG\n         B     QSTOP                    RETURN TO \"DISPLAY\" TO BE\n*                                       RE-INVOKED BY QUEUE MAINLINE\n         SPACE 3\nQI$DISP  MVC   QDHLINE(22),=C'Current Qinnards info:'\n         BAL   R14,QADDLINE             START WITH BLANK LINE\n         SPACE 1\n         MVC   QDMSG(22),=C'Privilege flags ----->'\n         LA    R1,QDMSG+24              WHERE TO PUT THE FIRST ONE\n         TM    QXAUTH,QXSYSP            SYSTEMS PROGRAMMER (ACTIVELY)?\n         BNO   QI$PRV1                  NO - SKIP\n         MVC   0(7,R1),=C'Syspgmr'      YES - SAY SO\n         LA    R1,10(,R1)               -> NEXT POSITION\nQI$PRV1  TM    QXAUTH,QXOPER            OPERATOR (ACTIVELY)?\n         BNO   QI$PRV2                  NO - SKIP\n         MVC   0(8,R1),=C'Operator'     YES - SAY SO\n         LA    R1,11(,R1)               -> NEXT POSITION\nQI$PRV2  TM    QXAUTH,QXPSWD            ENTERED THE PASSWORD?\n         BNO   QI$PRV3                  NO - SKIP\n         MVC   0(4,R1),=C'Pswd'         YES - SAY SO\nQI$PRV3  MVC   QDMSG+55(24),=C'(NOSYSP/SYSP/NOPER/OPER)'\n         BAL   R14,QADDLINE             ADD LINE TO SCREEN\n         SPACE 1\n         MVC   QDMSG(22),=C'Selected subsystem -->'\n         MVC   QDMSG+24(4),QJESNAME\n         MVC   QDMSG+31(8),=C'ComChar='\n         MVC   QDMSG+39(1),QCOMCHAR\n         MVC   QDMSG+42(8),=C'CkptVol='\n         MVC   QDMSG+50(6),QCKPTVOL\n         MVC   QDMSG+58(10),=C'DsnPrefix='\n         MVC   QDMSG+68(11),QCKPTPFX\n         BAL   R14,QADDLINE             DISPLAY THIS LINE\n         SPACE 1\n         MVC   QDMSG(40),=C'Debugging options --------------------->'\n         HEX   QDMSG+42,QDEBUG,LEN=4,HEXTAB=QHEXTAB\n         BAL   R14,QADDLINE             DISPLAY THIS LINE\n         SPACE 1\n         MVC QDMSG(44),=C'Translate SMF id to user friendly id -->  NO'\n         LA    R0,QSMFID                -> SMF ID TABLE\n         CL    R0,QVSYSID               SET TO THIS?\n         BE    *+10                     YES - OK\n         MVC   QDMSG+42(3),=C'YES'      NO\n         MVC   QDMSG+55(19),=C'(SIDTRAN/NOSIDTRAN)'\n         BAL   R14,QADDLINE             DISPLAY THIS LINE\n         BAL   R14,QADDLINE             ADD BLANK LINE\n         SPACE 1\n         L     R0,QC##CKPT              GET NUMBER\n         BAL   R14,QI$EDNUM\n         MVC   QDMSG(7),QI@EDWRK+1\n         MVC   QDMSG+9(20),=C'entries to read Ckpt'\n         MVC   QDMSG+55(8),=C'Size=NNN'\n         L     R0,QCJOTL                GET NUMBER OF CKPT BLOCKS\n         BAL   R14,QI$EDNUM\n         MVC   QDMSG+60(3),QI@EDWRK+L'QI@EDWRK-3\n         MVC   QDMSG+71(6),=C'NCP=NN'\n         L     R1,QCCKPT                -> HASPCKPT DCB\n         SR    R0,R0                    CLEAR FOR IC\n         IC    R0,DCBNCP-IHADCB(,R1)    GET NCP VALUE\n         BAL   R14,QI$EDNUM\n         MVC   QDMSG+75(2),QI@EDWRK+L'QI@EDWRK-2\n         BAL   R14,QADDLINE             DISPLAY THIS LINE\n         SPACE 1\n         L     R0,QC#CKPT#              GET NUMBER OF AVOIDED\n         BAL   R14,QI$EDNUM\n         MVC   QDMSG(7),QI@EDWRK+1\n         MVC   QDMSG+9(18),=C'Ckpt reads avoided'\n         TM    QKFLAG,QKFKAC            KAC any good?\n         BNZ   QI$KAC                   yes - ok\n         MVC   QDMSG+55(22),=C'No valid KAC available'\n         B     QI$NKAC                  skip other stuff\nQI$KAC   MVC   QDMSG+49(15),=C'Using APPLCOPY;'\n         TM    QMODE2,QM2CKPT           ok to use APPLCOPY?\n         BNZ   *+10                     yes - ok\n         MVC   QDMSG+48(16),=C'(Mode NoAppCpy);'\n         MVC   QDMSG+65(6),=C'KAC @ '\n         HEX   QDMSG+71,QKACA,LEN=4     show KAC address\nQI$NKAC  BAL   R14,QADDLINE             DISPLAY THIS LINE\n         SPACE 1\n         L     R0,QC##RSPC              GET NUMBER\n         BAL   R14,QI$EDNUM\n         MVC   QDMSG(7),QI@EDWRK+1\n         MVC   QDMSG+9(23),=C'entries to read Haspace'\n         BAL   R14,QADDLINE             DISPLAY THIS LINE\n         SPACE 1\n         L     R0,QC#RSPC#              GET NUMBER\n         BAL   R14,QI$EDNUM\n         MVC   QDMSG(7),QI@EDWRK+1\n         MVC   QDMSG+9(21),=C'Haspace reads avoided'\n         BAL   R14,QADDLINE             DISPLAY THIS LINE\n         SPACE 1\n          AIF   (&QLEVEL GE 5).QI01\n         MVC   QDMSG(9),=C'QCPDDB1 ='\n         HEX   QDMSG+10,QCPDDB1,LEN=4   GET IT\n         BAL   R14,QADDLINE             DISPLAY THIS LINE\n.QI01     ANOP\n         SPACE 1\n         MVC   QDMSG(9),=C'QCSIZE  ='\n         HEX   QDMSG+10,QCSIZE,LEN=4    GET IT\n         MVC   QDMSG+25(9),=C'QDSIZE  ='\n         HEX   QDMSG+35,QDSIZE,LEN=4    GET IT\n         BAL   R14,QADDLINE             DISPLAY THIS LINE\n         SPACE 1\n          AIF   (&QLEVEL GE 4).QI02\n          AIF   (&QLEVEL LT 4).QI02\n         MVC   QDMSG(10),=C'QCJQETTR ='\n         HEX   QDMSG+12,QCJQETTR+1,LEN=3  GET IT\n         MVC   QDMSG+25(10),=C'QCJQENUM ='\n         L     R0,QCJQENUM              GET NUMBER\n         BAL   R14,QI$EDNUM\n         MVC   QDMSG+25+12(5),QI@EDWRK+L'QI@EDWRK-5\n         BAL   R14,QADDLINE             DISPLAY THIS LINE\n         SPACE 1\n         MVC   QDMSG(10),=C'QCJOETTR ='\n         HEX   QDMSG+12,QCJOETTR+1,LEN=3  GET IT\n         MVC   QDMSG+25(10),=C'QCJOENUM ='\n         L     R0,QCJOENUM              GET NUMBER\n         BAL   R14,QI$EDNUM\n         MVC   QDMSG+25+12(5),QI@EDWRK+L'QI@EDWRK-5\n         BAL   R14,QADDLINE             DISPLAY THIS LINE\n         SPACE 1\n.QI02     ANOP\n         SPACE 1\n         B     QSTOP                    ALL DONE\n         SPACE 3\nQI$EDNUM MVC   QI@EDWRK,=X'4020202020202120'  get edit mask\n         CVD   R0,QNUMWORK              get number in packed decimal\n         ED    QI@EDWRK,QNUMWORK+4      get it printable\n         BR    R14                      return to caller\n         SPACE 3\n         ENTRY QI#KEYS\n*---  MUST HAVE A ONE-FOR-ONE CORRESPONDENCE BETWEEN TABLE BELOW AND\n*---  BRANCH TABLE IN QI$FOUND\nQI#KEYS  DC    CL8'DEBUG   '\n         DC    CL8'SIDTRAN '\n         DC    CL8'NOSIDTRA'\n         DC    CL8'USERMODE'\n         DC    CL8'USER    '\n         DC    CL8'SYSP    '\n         DC    CL8'NOSYSP  '\n         DC    CL8'OPER    '\n         DC    CL8'NOPER   '\n         DC    CL8'COMCHAR '\n         DC    CL8'COMCHR  '\n         DC    X'FF'                    END OF TABLE INDICATOR\n         SPACE 2\nQI#TRTAB EQU   *-C'A'\n         DC    X'0A0B0C0D0E0F'\n         DC    (C'0'-C'G')X'00'\n         DC    X'00010203040506070809'\n         SPACE 3\n         DROP  R7,R13\n         SPACE 3\n         LTORG ,\n         SPACE 3\nWORK     DSECT ,\n         ORG   WORK+72                  skip over save area\nQI@EDWRK DS    CL8\n         SPACE 3\n         QCOMMON\n         QDCB\n         SPACE 3\n         QZPSCB\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "Q#QQ": {"ttr": 14345, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x1c\\x00\\x00\\x00\\x82#/\\x00\\x91!\\x7f\"\\x15\\x02\\xb2\\x00\\xaa\\x02:\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "05.28", "flags": 0, "createdate": "1982-08-20T00:00:00", "modifydate": "1991-08-05T22:15:00", "lines": 690, "newlines": 170, "modlines": 570, "user": "LDW"}, "text": "         TITLE '--- QUEUE--MAINLINE MODULE ---'\n*---------------------------------------------------------------------*\n*                                                                     *\n*   QUEUE - Entry point and mainline                                  *\n*                                                                     *\n*   Updates:                                                          *\n*      16Jul91  GLA  Fix handling of table display repositioning      *\n*                    Improve QNEWCMD entry to support message         *\n*      11Feb91  LDW  Use local area instead of global for CALL MF=L   *\n*                       (was TBLST and VCALLST in QCOMMON)            *\n*                    Move V9 from QCOMMON to =CL8'QROWID'             *\n*      31Jan91  LDW  Retrofit GLA's updates below (update flags       *\n*                       removed because this will now be considered   *\n*                       part of the base level code)                  *\n*                    KILLPCS routine integrated here instead of in    *\n*                       QSUBS (it's now time to move all the          *\n*                       termination code out of here... not today)    *\n*     (10Jul90) GLA  Add call to terminate PC access at end.          *\n*                    Fix attention handling for ISPF.                 *\n*     (20Sep89) GLA  Change logic when all line cmds are done to      *\n*                    reissue previously stacked command.              *\n*                    Handle reprompts from reissued stacked commands. *\n*     (20Jul89) GLA  Improve interface to eliminate DY3 and QQ1       *\n*                    errors after invalid command combinations        *\n*     (16Jun89) GLA  Add interface to redrive commands in stack as    *\n*                    results of terminations of other commands.       *\n*     (29Mar89) GLA  Add support for ISPF BROWSE and Tables.          *\n*      17Nov90  LDW  Fix bug in previous update which caused last     *\n*                       operand character to be ignored for line      *\n*                       commands with an 8 character operand          *\n*      20Jun90  LDW  Fix for 6 character DSID                         *\n*      10Dec89  LDW  Use name of OACFSORT from &@@OACFS               *\n*                    Pick up Doron's 21Nov89 mod:                     *\n*               DMS  Conditionally assemble out OACFSORT usage        *\n*       3Jun87  EMS  Add support for Starting/Draining Spool vols     *\n*                    Fix 0c3 if initial command invalid followed by   *\n*                       end.                                          *\n*                    Delete OACFSORT                                  *\n*      08Feb87  LDW  Save first command in QCMDRING                   *\n*      18Jan87  LDW  Display command in \"no data\" message             *\n*                    Eliminate use of \"LC\" macro                      *\n*      04/22/86 LDW  MOVE ATTN FLAG FROM QTERMFLG TO QMISCFLG         *\n*      03/31/86 LDW  RE-DESIGN 3278-5 SUPPORT (THIRD TRY!)            *\n*                    CREATE COMMON LOGIC ERROR ROUTINE                *\n*                    MOVE STAX MF=L FROM QCOMMON TO THIS ROUTINE'S    *\n*                       LOCAL WORKAREA                                *\n*      08/30/84 LDW  DON'T S0C3 IF ILLOGICAL LINE COMMAND SEQUENCE    *\n*                    SUPPORT QM1STACK                                 *\n*                    FREE ALL GETMAINED STORAGE                       *\n*      04/12/84 LDW  INITIALIZE THE COMMAND STACK WITH A 'STATUS' CMD *\n*      03/27/84 LDW  MOVE CALL TO 'DISPCHG' FROM 'PARSE'              *\n*      01/23/84 LDW  ADD SUPPORT FOR COMMAND STACKING                 *\n*                    DO NOT MOVE IN ***OK*** IF DESTRUCTIVE LINE CMD  *\n*      07/05/83 LDW  CHECK FOR NEW \"DATASET IS EMPTY\" MSG             *\n*      03/18/83 LDW  ADD SUPPORT FOR LINE COMMANDS                    *\n*                    CHANGE USING/DROP TO USNGX/DROPX                 *\n*      02/24/83 LDW  CLEAR QDLCTBL WHEN NECESSARY                     *\n*                    DELETE HELP AND CHANGES MODULES IF NECESSARY     *\n*      02/03/83 LDW  REMOVE ALL CODE RELATED TO REPROMPTING (Q1INQ#)  *\n*      02/02/83 LDW  SET QCODE TO ZERO WHEN INVOKING \"PRINT OFF\"      *\n*      01/19/83 LDW  ADD WORKLEN= TO QSTART TYPE=ENTRY                *\n*      01/06/83 LDW  ADD SPF SUPPORT                                  *\n*                    ADD SUPPORT FOR \"Q2LISTDS\"                       *\n*                    FREEMAIN BLOCK TABLE AT EXIT                     *\n*      01/03/83 LDW  ADD LOCAL WORK AREA                              *\n*      12/21/82 LDW  CHANGE SOME MESSAGES TO LOWER CASE               *\n*                    CLEAR # OF ATTR BYTES IN LINE FOR NEW SUBCMD     *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 3\nQUEUE    QSTART  Q1,TYPE=MAIN,WORKLEN=QQ@WORKL\n         USNGX WORK,R13\n         MVC   QQ@STAX(QQ#STAXL),QQ#STAX  COPY STAX MF=L\n         LA    R3,QQ@STAX               PASS ADDRESS TO 'INITIAL'\n         LA    R10,QQINTER              INTERRUPTED RETURN ADDRESS\n***********************************************************************\n*                                                                     *\n*   CALL - INITIALIZATION                                             *\n*                                                                     *\n***********************************************************************\n         L     R11,=V(QCOMMON)          POINT TO \"QCALL\" SUBROUTINE\n         QCALL INITIAL                  INITIALIZE\n         USNGX QCOMMON,R11              IT'S NOW VALID\n         L     R1,QVRING                -> RING COMMAND BUFFER\n         MVC   0(QDREPLYL,R1),QDREPLY   SAVE FIRST COMMAND\n         QSTACK  X'01','STATUS'         INITIALIZE THE STACK\n         B     QQLOOP                   enter main loop\n         EJECT\n***********************************************************************\n*                                                                     *\n*   ** INTERRUPT DISPLAY COMMAND PROCESSING ENTRY **                  *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nQQINTER  DS    0H                       Display Interupt Point\n*\n*  On entry (which is from the QNEWCMD macro), R15 has\n*  the entry code:\n*     0  from DISPLAY module - handle primary command\n*     4  from DISPLAY module - handle line command\n*     8  reexcute the current command in top of stack\n*    12  execute command passed in R1\n*\n*   R0 may contain either a 0 or address of message to issue.\n*\n         LTR   R14,R0                   check if message\n         BZ    *+10         ======+     no message so skip\n         MVC   QERRMSG,0(R14)     |     move in message\n         XC    QROWID,QROWID  <===+     indicate no row\n         CH    R15,=H'12'               check max code\n         BH    QQLOOP                   ignore\n         LTR   R15,R15                  check least code\n         BL    QQLOOP                   ignore\n         B     *+4(R15)                 use table\n         B     QQ$NPRI                  R15=0 normal prim cmd\n         B     QQLOOP                   R15=4 normal line cmd\n         B     QQ$REDRI                 R15=8 use top of stack\n         B     QQ$NCMD                  R15=C use cmd -> by R1\n         SPACE 2\nQQ$REDRI TM    QMODE1,QM1STACK          STACKING ENABLED?\n         BNO   QQLOOP                   NO - ignore\n         L     R2,QVSTACK               -> BOTTOM OF STACK\n         L     R3,QVSTACKC              -> TOP OF STACK\n         CLR   R3,R2                    PAST BOTTOM?\n         BL    QQLOOP                   YES - ignore\n         MVC   QDREPLY,2(R3)            RESTORE COMMAND LINE\n*\nQQ$RED1  MVC   QDRLNG,=Y(QDREPLYL)      FAKE LENGTH\n         MVC   QDPROMPT,QDREPLY         SAVE FOR REPROMPT\n         QCALL PARSE                    PARSE IT\n         MVI   QQ@FLAG,0                init flags\n         B     QQ$PARSE                 GO EXECUTE IT\n         SPACE 2\nQQ$NCMD  MVC   QDREPLY,0(R1)            move in command\n         B     QQ$RED1                  go process it\n         SPACE 2\nQQ$NPRI  MVI   QQ@FLAG,0                init flags\n         B     QQ$PARSE                 go and execute it\n         EJECT\n***********************************************************************\n*                                                                     *\n*   ** MAIN LOOP **                                                   *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nQQLOOP   MVI   QQ@FLAG,0                INIT FLAGS\n         TM    QISFLAG1,QIS1ISPF        are we in ISPF?\n         BZ    QQ$NISP1                 no - skip code\n         SPACE 1\n*---  SEE IF A LINE COMMAND TO EXECUTE                             ---*\n*---       ISPF mode                                               ---*\n         TM    QISFLAG1,QIS1TBOP        is table open?\n         BZ    QQ$PARSE                 no - no line commands\n         L     R15,ISPLNK               -> ISPLINK\n         CALL  (15),(=CL8'TBVCLEAR',TBNAM),VL,                         $\n               MF=(E,QQ@CALLP)\n         CH    R15,=H'20'               severe error ???\n         BNL   ISPFERR                  tell about  ???\n         XC    QLCBE+LCBTPTR-LCBUFF(L'LCBTPTR),QLCBE+LCBTPTR-LCBUFF\n         MVI   QLCBE+4,C'*'             fudge for now *%%%%\n         L     R15,ISPLNK               -> ISPLINK\n         CALL  (15),(=CL8'TBSARG',TBNAM,0,=CL8'NEXT',                  $\n               =C'(QLCBE,NE)'),VL,                                     $\n               MF=(E,QQ@CALLP)\n         CH    R15,=H'20'               severe error ???\n         BNL   ISPFERR                  tell about  ???\n         L     R15,ISPLNK               -> ISPLINK\n         CALL  (15),(=CL8'TBTOP',TBNAM),VL,                            $\n               MF=(E,QQ@CALLP)\n         CH    R15,=H'20'               severe error ???\n         BNL   ISPFERR                  tell about  ???\n         SPACE 2\nQQ$LCNXT TM    QISFLAG1,QIS1ISPF        are we in ispf\n         BZ    QQ$LCSTP                 if not go to self proc\n         TM    QQ@FLAG,QQ@DCMD          was a dest. cmd done?\n         BO    QQ$LCDNE                 yes - orig table gone\n*                                         and need to issue new\n         L     R15,ISPLNK               -> ISPLINK\n         CALL  (15),(=CL8'TBSCAN',TBNAM,0,0,=CL8'QROWID'),VL,          $\n               MF=(E,QQ@CALLP)\n         CH    R15,=H'20'               severe error ???\n         BNL   ISPFERR                  tell about  ???\n         CH    R15,=H'8'                error, end, or got one?\n         BE    QQ$LCDNE                 =8 so done\n         BNH   *+6                      SEVERE ERROR\n         DC    H'0'                     SEVERE ERROR BOMB\n         LA    R3,QLCBE                 point at LCB entry\n         B     QQ$LC$GO                 process line command\n         SPACE 1\n*---  SEE IF A LINE COMMAND TO EXECUTE                             ---*\n*---       non ISPF mode                                           ---*\nQQ$NISP1 L     R3,QVLCBUF               -> LINE CMD BUFFER\n         USNGX LCBUFF,R3\n         LA    R4,43-3                  MAX LINE COMMANDS\n*\nQQ$LC$L1 OC    LCBFLD1,LCBFLD1          UNUSED LINE?\n         BZ    QQ$LCSTP                 YES - SKIP THIS ENTRY\n         CLC   LCBFLD1,QBLANK           ANY LINE CMD HERE?\n         BNE   QQ$LC$GO                 YES - DO IT\n*\nQQ$LCSTP LA    R3,LCBELEN(,R3)          -> NEXT LINE CMD\n         BCT   R4,QQ$LC$L1              CHECK ALL LINE COMMANDS\n*\nQQ$LCDNE TM    QQ@FLAG,QQ@LCMD          DID WE EXECUTE ANY LINE CMDS?\n         BNO   QQ$PARSE                 NO - GO EXECUTE PRIMARY CMD\n         TM    QQ@FLAG,QQ@DCMD          YES - WAS IT A DESTRUCTIVE CMD?\n         BNO   QQ$LCEND                 NO - SAY PROCESSING COMPLETE\n         TM    QISFLAG1,QIS1ISPF        are we in ispf?\n         BO    QQLCDISP                 yes - do display\n         CLC   QDHLINE+21(12),=C'IS EMPTY ***'  IS DATASET EMPTY?\n         BE    QQLCDISP                 YES - SKIP\n         MVC   QDMSG(80),ENDDATA        MOVE IN \"END OF DATA\" MSG\n         MVI   QDATRNUM+1,2             INDICATE 2 ATTR BYTES IN LINE\n         BAL   R14,QADDLINE             MOVE TO SCREEN\n         B     QQLCDISP                 SKIP AROUND\nQQ$LCEND MVC   QDHLINE,QBLANK           CLEAR THE HEADER LINE\n         MVC   QDHLINE+03(36),=C'Line subcommand processing complete.'\n         OI    QFLAG1,Q1MVHDR           REQUEST MOVE HEADER\n         NI    QFLAG2,255-Q2NEWSCR      dont blank scr\n*                                       since was not dest. cmd\nQQLCDISP QCALL DISPLAY                  DISPLAY RESULTS OF LINE CMDS\n         B     QQ$REDRI                 redrive last stked. cmd\n         SPACE 2\nQQ$LC$GO ICM   R2,B'1111',LCBTPTR       -> LINE CMD TABLE ENTRY\n         BP    QQ$LC$EX                 GO EXECUTE IT IF VALID\n         L     R0,=C'QQ1 '              GET ERROR CODE\n         B     LOGICERR                 SHOW LOGIC ERROR\n         SPACE 2\n         USNGX LCTABLE,R2\nQQ$LC$EX MVC   QDREPLY,QBLANK           CLEAR THE COMMAND AREA\n         MVC   QDREPLY(4),LCTTRUNM      SET ACTUAL SUBCOMMAND NAME\n         MVC   QDREPLY+7(6),LCBID       JOBID OR DSID\n         OC    LCBFLD2,LCBFLD2          ANY SECOND OPERAND?\n         BZ    *+10                     NO - SKIP\n         MVC   QDREPLY+14(8),LCBFLD2    FILL IN OPERAND\n         TM    LCTFLAGS,LCTFDD          THIS 'DD' SUBCMD?\n         BNO   QQ$LC$PA                 NO - SKIP\n         MVI   QDREPLY+5,C'*'           YES - SELECT CURRENT JOB\n         CLI   QDREPLY+7,C'J'           IS THIS A SYSTEM DATASET?\n         BNE   QQ$LC$PA                 NO - OK\n         MVC   QDREPLY(4),QDREPLY+7     YES - USE THE DSID AS SUBCMD\n         MVC   QDREPLY+7(6),QBLANK      AND REMOVE FROM OPERAND AREA\n         SPACE 1\nQQ$LC$PA MVC   QDRLNG,=H'22'            SET REPLY LENGTH\n         MVC   LCBFLD1,QBLANK           CLEAR COMMAND FROM TABLE\n         ICM   R14,B'1111',LCBADDR1     GET ADDR OF SELECT FIELD\n         BZ    *+10                     SKIP IF NOT SUPPLIED\n         MVC   0(2,R14),QBLANK          BLANK IT - WE'RE EXECUTING IT\n         MVC   LCBFLD2,QBLANK           CLEAR OPERAND FROM TABLE\n         ICM   R14,B'1111',LCBADDR2     GET ADDR OF OPERAND FIELD\n         BZ    *+10                     SKIP IF NOT SUPPLIED\n         MVC   0(8,R14),QBLANK          BLANK IT - WE'RE EXECUTING IT\n         QCALL PARSE                    PARSE IT\n         MVC   QDMSG,QBLANK             CLEAR MSG WORK LINE\n         MVC   QDHLINE,QBLANK           CLEAR OUTPUT HEADER LINE\n         XC    QDATRNUM,QDATRNUM        NO ATTR BYTES CURRENTLY IN LINE\n         OI    QFLAG1,Q1MVHDR+Q1PROFOK  MOVE THE HEADER THE FIRST TIME\n*                                       AND PROFILE COMPLETE\n         NI    QFLAG2,255-Q2LISTDS      ASSUME NOT LISTDS\n         OI    QFLAG2,Q2NEWSCR          INDICATE NEXT OUTPUT TO LINE 1\n         MVC   QACTION,=CL8'***OK***'   ASSUME IT WILL WORK\n         TM    QISFLAG1,QIS1TBOP        is table open?\n         BZ    QQ$LC$CL                 no - skip\n         TM    LCTFLAGS,LCTFDCMD        destructive subcmd empty\n         BNO   QQ$LC$CL                   ISPF table\n         XC    QTBDROW,QTBDROW          clear saved row id\n         L     R15,ISPLNK               -> ISPLINK\n         CALL  (15),(=CL8'TBEND',TBNAM),VL,                            $\n               MF=(E,QQ@CALLP)\n         CH    R15,=H'20'               severe error ???\n         BNL   ISPFERR                  tell about  ???\n         NI    QISFLAG1,255-QIS1TBOP    mark table closed\n*\nQQ$LC$CL TM    QISFLAG1,QIS1TBOP        is table open\n         BZ    QQ$LC$SB                 no so do call\n         XC    LCBTPTR,LCBTPTR          indicate subcmd processed\n         L     R15,ISPLNK               -> ISPLINK\n         CALL  (15),(=CL8'TBPUT',TBNAM),VL,                            $\n               MF=(E,QQ@CALLP)\n         CH    R15,=H'20'               severe error ???\n         BNL   ISPFERR                  tell about  ???\n*\nQQ$LC$SB L     R15,QSUBCMD              GET SUBCMD ENTRY POINT\n         OI    QSCFLAG2,QSC2LINE        INDICATE IT'S A LINE SUBCMD\n         QCALL (R15)                    CALL IT\n         OI    QQ@FLAG,QQ@LCMD          WE EXECUTED A LINE CMD\n         TM    LCTFLAGS,LCTFDCMD        WAS THIS A DESTRUCTIVE SUBCMD?\n         BNO   QQ$LCNDS                 NO - SKIP\n         OI    QQ@FLAG,QQ@DCMD          YES - REMEMBER\n         B     QQ$LCFIN                 AND GO PROCESS NEXT LINE\nQQ$LCNDS DS    0H                       non destructive\n         TM    QISFLAG1,QIS1TBOP        is table open?\n         BZ    QQ$LCACT                 no so skip to set action\n         OC    QROWID,QROWID            any row?\n         BZ    QQ$LCACT                 no - so skip to set actn\n         L     R15,ISPLNK               re-access row in question\n         CALL  (15),(=CL8'TBSKIP',TBNAM,0,0,0,QROWID),VL,              $\n               MF=(E,QQ@CALLP)\n         CH    R15,=H'20'               severe error ???\n         BNL   ISPFERR                  tell about  ???\n*\nQQ$LCACT ICM   R14,B'1111',LCBADDR2     OPERAND FIELD ADDR\n         BZ    QQ$LCFIN                 SKIP IF NOT SUPPLIED\n         MVC   0(8,R14),QACTION         SHOW WHAT WE DID\n         SPACE 1\n* --  for ISPF update row in table to save status\nQQ$LCFIN TM    QISFLAG1,QIS1ISPF        are we in ispf?\n         BZ    QQ$LCNXT                 if not go process next\n         TM    QISFLAG1,QIS1BRCP        has browse finished ok?\n         BO    QQ$ISPXT                 yes - sim END command\n         TM    QISFLAG1,QIS1TBOP        is table open?\n         BZ    QQ$LCNXT                 no - skip\n         OC    QROWID,QROWID            any row\n         BZ    QQ$LCNXT                 no - skip to set actn\n         XC    LCBTPTR,LCBTPTR          indicate subcmd processed\n*                                       and save action code\n         L     R15,ISPLNK               -> ISPLINK\n         CALL  (15),(=CL8'TBPUT',TBNAM),VL,                            $\n               MF=(E,QQ@CALLP)\n         CH    R15,=H'20'               severe error ???\n         BNL   ISPFERR                  tell about  ???\n         XC    QROWID,QROWID            clear row pointer\n         B     QQ$LCNXT                 GO PROCESS NEXT LINE CMD\n         SPACE 1\n         DROPX R3,R2                    LCBUFF, LCTABLE\n***********************************************************************\n*                                                                     *\n*   CALL SUB-COMMAND MODULE SELECTED BY PARSE                         *\n*                                                                     *\n***********************************************************************\nQQ$PARSE MVC   QDMSG,QBLANK             CLEAR MSG WORK LINE\n         XC    QROWID,QROWID            clear row pointer\n         XC    QTBDROW,QTBDROW          clear saved row id\n         MVC   QDHLINE,QBLANK           CLEAR OUTPUT HEADER LINE\n         XC    QDATRNUM,QDATRNUM        NO ATTR BYTES CURRENTLY IN LINE\n         OI    QFLAG1,Q1MVHDR+Q1PROFOK  MOVE THE HEADER THE FIRST TIME\n*                                       AND PROFILE COMPLETE\n         NI    QFLAG2,255-Q2LISTDS      ASSUME NOT LISTDS\n         XC    QDLCTBL,QDLCTBL          NO LINE COMMANDS TABLE NOW\n         TM    QISFLAG1,QIS1TBOP        is table open?\n         BZ    QQ$PR$I1                 no so skip\n         L     R15,ISPLNK               ge-ISPF interface\n         CALL  (15),(=CL8'TBEND',TBNAM),VL,   kill current table       $\n               MF=(E,QQ@CALLP)\n         CH    R15,=H'20'               severe error ???\n         BNL   ISPFERR                  tell about  ???\n         NI    QISFLAG1,255-QIS1TBOP    mark table closed\n*\nQQ$PR$I1 DS    0H\n         L     R15,QSUBCMD              ADDR OF SUBCMD FROM QCOMMON\n         CL    R15,=A(EXIT)             IS THIS EXIT?\n         BE    EXIT                     YES - DON'T CALL IT, GO THERE\n         TM    QISFLAG1,QIS1ISPF        are we in ISPF?\n         BO    QQ$ISPF2                 yes\n**%%     TM    QFLAG2,Q2REPOS\n**%%     BO    ???\n**%%**%% **%%* *%%**%%**%%  CODE FROM \" PARSE\" GOES HERE\n         SPACE 1\n         QCALL (R15)                    GO TO IT\n         TM    QMISCFLG,QMFATTN         DID USER PRESS ATTENTION?\n         BO    QQATTN                   YES - LEAVE SCREEN AS IS\n         CLC   QDHLINE,QBLANK           WAS ANYTHING WRITTEN?\n         BE    QQNDATA                  NO - SKIP\n         CLC   QDHLINE+21(12),=C'IS EMPTY ***'  IS DATASET EMPTY?\n         BE    QQFINAL                  YES - SKIP\n         MVC   QDMSG(80),ENDDATA        MOVE IN \"END OF DATA\" MSG\n         MVI   QDATRNUM+1,2             INDICATE 2 ATTR BYTES IN LINE\n         BAL   R14,QADDLINE             MOVE TO SCREEN\n         B     QQFINAL                  SKIP AROUND\n         SPACE 2\n*  DO WE NEED TO DO ANYTHING WITH MOD5 STUFF HERE????    %%%%\nQQATTN   NI    QMISCFLG,255-QMFATTN     RESET FLAG\n         MVC   QD3270OP,QDERASE         SET WRITE OP TO ERASE WRITE\n         ZAP   QPREC,QCCREC             SET DESIRED LOC TO CURRENT LOC\n         SPACE 1\n         STFSMODE  ON                   ATTN TURNS OFF FULLSCR MODE\n         SPACE 1\n         B     QQFINAL                  CONTINUE\n         SPACE 2\nQQNDATA  MVC   QDHLINE(40),=C'No data is available for this request - '\n         MVC   QDHLINE+40(L'QDHLINE-40),QDREPLY  SHOW THE COMMAND\n         SPACE 2\nQQFINAL  QCALL DISPLAY                  WRITE LAST SCRN, GET NEXT INPUT\n         B     QQLOOP                   EXECUTE NEXT OR SAME SUBCOMMAND\n         SPACE 3\n*****************************************************************\n*\n*   CALL - SUB-COMMAND MODULE SELECTED BY PARSE    ISPF MODE\n*\n*****************************************************************\nQQ$ISPF2 L     R15,QSUBCMD              addr of command to do\n         QCALL (R15)                    go to it\n         TM    QMISCFLG,QMFATTN         Attention hit?\n         BO    QQ$IATTN                 yes - handle\n         TM    QISFLAG1,QIS1BRCP        has browse finished ok?\n         BO    QQ$ISPXT                 yes - sim END command\n         CLC   QDHLINE,QBLANK           was anything written?\n         BE    QQNDATA                  no - give message\n         B     QQFINAL                  go write screen\n         SPACE 1\n*---  PF3 from ISPF BROWSE - do END command\nQQ$ISPXT TM    QISFLAG1,QIS1TBOP        is table open?\n         BZ    QQ$ISBXT                 no - skip\n         L     R15,ISPLNK               -> ISPLINK\n         CALL  (15),(=CL8'TBEND',TBNAM),VL,                            $\n               MF=(E,QQ@CALLP)\n         CH    R15,=H'20'               severe error ???\n         BNL   ISPFERR                  tell about  ???\n         NI    QISFLAG1,255-QIS1TBOP    mark table closed\n*\nQQ$ISBXT NI    QISFLAG1,255-QIS1BRCP    off BROWSE flag\n         TM    QMODE1,QM1STACK          STACKING ENABLED?\n         BNO   QQ$ISBX2                 NO - TERMINATE PROCESSOR\n         L     R2,QVSTACK               -> BOTTOM OF STACK\n         L     R3,QVSTACKC              -> TOP OF STACK\n         SH    R3,=Y(QDSTACKL)          -> PREVIOUS STACK ELEMENT\n         CLR   R3,R2                    PAST TOP?\n         BNL   *+8                      NO - CONTINUE\n         B     QQ$ISBX2                 yes - exit now\n         ST    R3,QVSTACKC              SAVE NEW TOS POINTER\n         OC    QDRLNG,QDRLNG            any command back from br\n         BNZ   QQ$ISBX2                 command from browse\n         MVC   QDREPLY,2(R3)            RESTORE COMMAND LINE\n         MVC   QDRLNG,=Y(QDREPLYL)      FAKE LENGTH\n         MVC   QDPROMPT,QDREPLY         SAVE FOR REPROMPT\n*\nQQ$ISBX2 QCALL PARSE                    PARSE IT\n         B     QQ$PARSE                 GO EXECUTE IT\n         SPACE 2\nQQ$IATTN NI    QMISCFLG,255-QMFATTN     reset flag\n         L     R15,ISPLNK               -> ISPLINK\n         CALL  (15),(=CL8'CONTROL',=CL8'DISPLAY',=CL8'REFRESH'),VL,    $\n               MF=(E,QQ@CALLP)\n         CH    R15,=H'20'               severe error ???\n         BNL   ISPFERR                  tell about  ???\n         TM    QISFLAG1,QIS1BRCP        has browse finished ok?\n         BO    QQ$ISPXT                 yes - sim END command\n         B     QQFINAL                  Continue\n         SPACE 3\n***********************************************************************\n*                                                                     *\n*   CLEAN UP AND GO HOME                                              *\n*                                                                     *\n***********************************************************************\n         ENTRY EXIT\nEXIT     CLI   QCODE,4                  'END' COMMAND?\n         BNE   QQEXIT0                  NO - TERMINATE PROCESSOR\n         TM    QMODE1,QM1STACK          STACKING ENABLED?\n         BNO   QQEXIT0                  NO - TERMINATE PROCESSOR\n         L     R2,QVSTACK               -> BOTTOM OF STACK\n         L     R3,QVSTACKC              -> TOP OF STACK\n         SH    R3,=Y(QDSTACKL)          -> PREVIOUS STACK ELEMENT\n         CLR   R3,R2                    PAST TOP?\n         BNL   *+8                      NO - CONTINUE\n*%%%     EX    0,*                      YES - LOGIC ERROR\n         B     QQEXIT0                  yes - exit now\n         ST    R3,QVSTACKC              SAVE NEW TOP OF STACK POINTER\n         MVC   QDREPLY,2(R3)            RESTORE COMMAND LINE\n         MVC   QDRLNG,=Y(QDREPLYL)      FAKE LENGTH\n         MVC   QDPROMPT,QDREPLY         SAVE FOR REPROMPT\n         QCALL PARSE                    PARSE IT\n         B     QQ$PARSE                 GO EXECUTE IT\n         SPACE 2\nQQEXIT0  STAX  ,                        CANCEL STAX EXIT\n         SPACE 1\n*---  Kill the PC number authorization                             ---*\n          AIF   (&QLEVEL LT 8).QQ02\n         TM    QKFLAG,QKFKAC            Is KAC access active?\n         BZ    QSTOP                    no.. no need to kill\n         LA    R1,4                     Get authorized\n         QCALL AUTHFUNC\n         MODESET KEY=ZERO,MODE=SUP      Get key=0\n         SPACE 3\n*---  disconnect access                                            ---*\nQQ$DISET ETDIS TKLIST=QPCTKL,RELATED=II$CET1\n         SPACE 3\n*---  destroy the entry table                                      ---*\nQQ$DESET ETDES TOKEN=QPCTKVAL,RELATED=II$CET1\n         SPACE 3\n*---  free LX for reuse                                            ---*\nQQ$FRLX  LXFRE LXLIST=QPCLXL,RELATED=II$GLX\n         SPACE 3\n         MODESET KEY=NZERO,MODE=PROB    Out of supervisor state\n         LA    R1,8                     release authorization\n         QCALL AUTHFUNC\n.QQ02     ANOP\n         SPACE 3\n         TM    QISFLAG1,QIS1ISPF        are we in ISPF?\n         BO    QQEXIT1                  yes - terminate tables\n         TM    QTERMFLG,QTFVTAM         VTAM TERMINAL?\n         BO    QQEXIT2                  YES - SKIP\n         TM    QTERMFLG,QTFTTY          NON-FULLSCR TERMINAL?\n         BO    QQEXIT3                  YES - SKIP\n         SPACE 1\n         TPUT  QQCLEAR,L'QQCLEAR,FULLSCR,,HOLD  NO - CLEAR THE SCREEN\n         B     QQEXIT3                  SKIP\n         SPACE 2\n*---  exit after ISPF BROWSE/TABLE invocation\nQQEXIT1  TM    QISFLAG1,QIS1TBOP        is table open?\n         BZ    QQEXIT1A                 no - skip\n         L     R15,ISPLNK               -> ISPLINK\n         CALL  (15),(=CL8'TBEND',TBNAM),VL,   kill current table       $\n               MF=(E,QQ@CALLP)\n         CH    R15,=H'20'               severe error ???\n         BNL   ISPFERR                  tell about  ???\n         NI    QISFLAG1,255-QIS1TBOP    mark table closed\n*\nQQEXIT1A L     R15,ISPLNK               -> ISPLINK\n         CALL  (15),(=CL8'VDELETE',=CL8'(*)'),VL,MF=(E,QQ@CALLP)\n         CH    R15,=H'20'               severe error ???\n         BNL   ISPFERR                  tell about  ???\n         B     QQEXIT3                  continue with rest\n         SPACE 3\n*---  exit after regular VTAM invocation\n         SPACE 2\nQQEXIT2  STFSMODE  OFF                  TELL VTAM WE'RE DONE\n         SPACE 2\nQQEXIT3  CLOSE MF=(E,QCCKPT)            CLOSE HASPCKPT\n         SPACE 1\n         L     R1,QCSPOOLS              -> open list\n         CLOSE MF=(E,(1))               close haspace(s)\n         SPACE 2\n         TM    QPFLAG,HARDCPY           IS HARDCOPY INVOKED?\n         BNO   QQNOPRNT                   NO..SPLIT THIS STUFF\n         MVC   QPARM1,=CL8'OFF'             INVOKE PRINT TO FREE UP\n         MVC   QPARM2,QBLANK                  HARDCOPY SYSOUT FILE\n         XC    QCODEH,QCODEH            SET ENTRY CODE FOR PRINT\n         SPACE 2\nQQASKLP  TPUT  QQASKPRT,L'QQASKPRT,ASIS ASK IF HE REALLY WANTS IT\n         SPACE 1\n         LA    R1,QDREPLY               -> MY ANSWER AREA\n         TGET  (1),80\n         SPACE 1\n         OI    QDREPLY,C' '             MAKE IT UPPER CASE\n         CLI   QDREPLY,C'Y'             WANT IT?\n         BE    QQPRINT                  YES\n         CLI   QDREPLY,C'N'             WANT IT?\n         BNE   QQASKLP                  HUH?\n         MVC   QPARM1(3),=C'DEL'        NO - TELL \"PRINT\" TO DELETE\n         SPACE 1\nQQPRINT  QCALL PRINT                    PRINT OR DELETE HARDCOPY SYSOUT\n         SPACE 2\nQQNOPRNT OC    QVHELP,QVHELP            HELP LOADED?\n         BZ    QQNODEL1                 NO - SKIP\n         SPACE 1\n         DELETE  EPLOC==CL8'QHLPTXT'    GET RID OF IT\n         SPACE 2\nQQNODEL1 OC    QVCHGS,QVCHGS            CHGS LOADED?\n         BZ    QQNODEL2                 NO - SKIP\n         SPACE 1\n         DELETE  EPLOC==CL8'QCHGTXT'    GET RID OF IT\n         SPACE 2\nQQNODEL2 DC    0H'0'\n          AIF   ('&@@OACFS' EQ '').QQ01\n         DELETE  EPLOC==CL8'&@@OACFS'   get rid of sort\n.QQ01     ANOP\n         SPACE 2\n         TM    QFLAG2,Q2SPF             IN SPF?\n         BNO   QQFREEMN                 NO - SKIP\n         SPACE 1\n*---  TELL SPF TO REFRESH THE WHOLE SCREEN\n         LINK  EP=ISPLINK,PARAM=(QQ#CTL,QQ#DISP,QQ#REFR),VL=1\n         SPACE 1\n*---  USE STEINBACH'S GUIDELINE FOR SYSTEMS PROGRAMMING:  \"NEVER TEST\n*---  FOR AN ERROR CONDITION YOU DON'T KNOW HOW TO HANDLE.\"\n         SPACE 2\n*  FREE ALL GETMAINED STORAGE\nQQFREEMN OI    QLENLAST,X'80'           INDICATE END OF LIST\n         SPACE 1\n         FREEMAIN  LU,SP=1,A=QADDRS,LA=QLENGTHS,MF=(E,QFREEMFL)\n         SPACE 2\n         L     R0,QGETMAIN              GET LENGTH OF THE QCOMMON AREA\n         SPACE 1\n         FREEMAIN  RU,A=(R11),LV=(0),SP=44      FREE THE QCOMMON AREA\n         SPACE 1\n         L     R13,4(,R13)              DE-CHAIN SAVE AREAS\n         LM    R14,R12,12(R13)          RELOAD CALLER (SYSTEM) REGS\n         SR    R15,R15                  RC = 0 IS NICE, GUYS\n         BR    R14\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*   ABEND FOR DEBUGGING PURPOSES                                      *\n*                                                                     *\n***********************************************************************\nABEND    QSTART  TYPE=ENTRY\n         DC    X'00C1'                  GET AN 0C1\n         QTILT '*** OUCH ***'           IN CASE RESTARTED BY TSO \"TEST\"\n***********************************************************************\n*                                                                     *\n*   ATTENTION EXIT                                                    *\n*                                                                     *\n***********************************************************************\n         PUSH  USING\n         DROP  ,                        CAN'T DROPX UNTIL HAVE PUSHX\nSTAXEXIT LR    R12,R15\n         USING STAXEXIT,R12\n         L     R11,8(,R1)               GET USADDR FIELD\n         USING QCOMMON,R11\n         TM    QMISCFLG,QMFATTN         ATTN PREVIOUSLY PRESSED?\n         BO    QQDBLATN                 YES - ABEND AS REQUESTED\n         OI    QMISCFLG,QMFATTN         NO - INDICATE ATTN PRESSED\n         BR    R14                      AND RETURN\n         SPACE 2\n*  HOW ABOUT ASKING IF WANT TO ABEND????  %%%%%%\nQQDBLATN LR    R2,R14                   SAVE RETURN ADDRESS\n         LA    R1,=C'*** ABEND REQUESTED BY DOUBLE ATTENTION ***'\n         LA    R0,43                    LENGTH\n         SPACE 1\n         TPUT  (1),(0),R                TELL HIM WHY WE'RE ABENDING\n         SPACE 1\n         ABEND 1001                     AND DO IT\n         SPACE 1\n         BR    R2                       RETURN IF RESTARTED BY \"TEST\"\n         POP   USING\n         SPACE 3\n***********************************************************************\n*                                                                     *\n*   COMMON LOGIC ERROR ROUTINE                                        *\n*                                                                     *\n***********************************************************************\n         DROPX R12                      QUEUE\n         ENTRY LOGICERR\nLOGICERR BALR  R15,0\n         USNGX *,R15\n         MVC   QERRMSG(46),=C'*** INTERNAL QUEUE LOGIC ERROR, CODE = ??$\n               ? ***'\n         STCM  R0,B'1110',QERRMSG+39    SET LOGIC CODE INTO ERROR MSG\n         QTILT *\n         DROPX R15                      LOGICERR\n         SPACE 3\n***********************************************************************\n*                                                                     *\n*   COMMON ISPF FUNCTION ERROR ROUTINE                                *\n*                                                                     *\n***********************************************************************\n         ENTRY ISPFERR\nISPFERR  BALR  R10,0\n         USNGX *,R10                    setup base\n         LR    R2,R1                    save calling list\n         LA    R1,QQ#MSG1               get errmsg\n         LA    R0,L'QQ#MSG1             get length\n         TPUT  (1),(0),R\n         SR    R0,R0\n         IC    R0,4(,R12)               get entry pt len\n         LA    R1,5(,R12)               -> entry pt name\n         TPUT  (1),(0),R\n         L     R1,0(,R2)                get service id\n         LA    R0,8                     and length\n         TPUT  (1),(0),R\n         ABEND 13,DUMP\n         DROPX R10\n         SPACE 3\n***********************************************************************\n*                                                                     *\n*   CONSTANTS AND OTHER ODDITIES                                      *\n*                                                                     *\n***********************************************************************\n         LTORG\n         DROPX R13                      WORK\nQQCLEAR  DC    X'C1115D7E1140403C4040001DC813'  *** SPF TCAM\nQQASKPRT DC    C'SHOULD HARDCOPY BE QUEUED TO SYSOUT? (Y/N)'\n         SPACE 1\nQQ#CTL   DC    CL8'CONTROL'             SPF SERVICE\nQQ#DISP  DC    CL8'DISPLAY'             \"TYPE\"\nQQ#REFR  DC    CL8'REFRESH'             \"MODE\"\nQQ#MSG1  DC    C'ISPF SERVICE FUNCTION FAILED IN QUEUE:'\n         SPACE 1\n         ENTRY ENDDATA\nENDDATA  DC    X'1DE8'                  HIGH INTENSITY, PROTECTED\n         DC    CL72'                            *** End of Data ***'\n         DC    X'1D60'                  NORMAL INTENSITY, PROTECTED\n         DC    CL4' '\n         SPACE 2\nQQ#STAX  STAX  STAXEXIT,REPLACE=NO,MF=L\n         SPACE 1\nQQ#STAXL EQU   *-QQ#STAX                LENGTH OF STAX PARM BLOCK\n         SPACE 3\n         QCOMMON\n         SPACE 3\nWORK     DSECT\n         ORG   WORK+72\n         SPACE 1\nQQ@STAX  STAX  MF=L\n         SPACE 2\nQQ@FLAG  DS    B\nQQ@LCMD  EQU   X'80'                    A LINE COMMAND WAS EXECUTED\nQQ@DCMD  EQU   X'40'                    A DESTRUCTIVE LINE CMD WAS EX'D\nQQ@WORKL EQU   *-WORK                   LENGTH OF LOCAL WORK AREA\nQQ@CALLP DS    6A                       CALL MF=L area\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "Q#QS": {"ttr": 14601, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x863O\\x00\\x88\\x06O\\x13\\x10\\x01\\x18\\x00B\\x00\\xde\\xc5\\xe7\\xe2@@@@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1986-11-30T00:00:00", "modifydate": "1988-03-04T13:10:00", "lines": 280, "newlines": 66, "modlines": 222, "user": "EXS"}, "text": "         TITLE '--- QUEUE--FORMATING SUBROUTINES ---'\n*---------------------------------------------------------------------*\n*                                                                     *\n*   QUEUE FORMATING SUBROUTINES                                       *\n*                                                                     *\n*   QSUBS - Processing interface for QITEM macro                      *\n*                                                                     *\n*   HEXFMT - GENERATE HEX DUMP OF ANY DATA                            *\n*                                                                     *\n*   ENTRY - R0 = DISPLAY OFFSET OF FIRST BYTE                         *\n*         - R1 = ADDR OF DATA TO DUMP                                 *\n*         - R2 = LENGTH TO DUMP                                       *\n*                                                                     *\n*   UPDATES:                                                          *\n*      04Mar88  EMS  Fix turkey bug in leap-year calculation          *\n*                    Integrate DATEFMT into QSUBS (remove epa)        *\n*      15Jun87  EMS  rename to QSUBS from FMTSUBS                     *\n*                    Add HEXFMT as entrypoint to QSUBS                *\n*                    Update for new QITEM macro                       *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 3\nQSUBS    QSTART  WORKLEN=QS@WORKL\n         USNGX WORK,R13                 Base for local work area\n         MVI   QS@FLAGS,0               clear flags\n         MVC   QS@PMSG#,0(R14)          save id\n         L     R7,QCITEMS               -> item table\n         XR    R15,R15                  clear\n         LH    R0,QS@PMSG#              get msg no\n         SH    R0,=H'1'                 -1 (table origin 1)\n         BZ    QS$O1SET                 if zero, at entry\nQS$O1LP  IC    R15,0(,R7)               get entry len\n         AR    R7,R15                   -> next entry\n         BCT   R0,QS$O1LP               walk to our entry\nQS$O1SET MVC   QS@PEC(QS@PL),1(R7)      copy parms to safe place\n         SR    R4,R4                    clear for ic\n         IC    R4,QS@PEC                get entry code\n         CH    R4,=H'4'                 over max?\n         BH    QS$INVC                  yes, error\n         SLL   R4,2                     * 4 for branch table\n         SR    R6,R6                    clear\n         ICM   R6,B'0011',QS@POFF1      get offset 1\n         LA    R2,QCOMMON(R6)           -> target\n         ICM   R6,B'0011',QS@POFF2      get offset 2\n         LA    R3,QCOMMON(R6)           -> target\n         SR    R6,R6                    clear\n         IC    R6,QS@PLEN               get data len\n         TM    QS@PFLAG,QS@PFMSG        msg insert?\n         BO    QS$FUNC                  no, just do conversion\n         MVC   0(2,R2),=X'1DE8'         set first attr byte\n         IC    R15,0(,R7)               get entry len\n         SH    R15,=Y(QS@PL+2)          -8 (fixed len;-1 for ex)\n         EX    R15,QS#OMVC              move in data\n         LA    R2,2+1(R15,R2)           -> next attr bytes\n         MVC   0(2,R2),=X'1D60'         move in second set\n         LA    R5,2(,R5)                account for bytes\nQS$FUNC  LR    R2,R1                    copy source addr\n         B     *+4(R4)                  do function\n         B     QS$CHAR                  + 00\n         B     QS$HEX                   + 04\n         B     QS$TIME                  + 08\n         B     QS$DATE                  + 12\n         B     QS$DEC                   + 16\n         SPACE 1\nQS$CHAR  BCTR  R6,0                     -1 for len to move\n         EX    R6,QS#COC                anything here?\n         BZ    QS$EXIT                  no, leave\n         EX    R6,QS#CMVC               move data\n         L     R1,=V(CHARTAB)           -> chartab\n         EX    R6,QS#CTR                printable\n         B     QS$EXIT                  -> exit\n         SPACE 2\nQS$HEX   LR    R14,R6                   copy len\n         AR    R14,R14                  * 2\n         SLL   R14,4                    shift\n         OR    R14,R6                   combine for unpk\n         EX    R14,QS#HUNPK             do it\n         AR    R6,R6                    len * 2\n         BCTR  R6,0                     -1 for ex\n         EX    R6,QS#HTR                translate to char\n         LA    R3,1(R6,R3)              -> last byte\n         MVI   0(R3),C' '               clear\n         B     QS$EXIT\n         SPACE 2\nQS$DEC   XR    R1,R1                    clear\n         SLL   R6,2                     *2 for instruction offset\n         EX    0,QS#DIC(R6)             (get correct load instr)\n         CVD   R1,QS@TEMP               decimal\n         LA    R1,QS@WORK+L'QS@WORK-1   -> end of string\n         MVC   QS@WORK(15),QS#MASK      set edit mask\n         MVC   QS@WORK+15(15),QBLANK    clear junk\n         EDMK  QS@WORK(15),QS@TEMP+2    format; set r1\n         MVC   0(13,R3),0(R1)           move to output\n         B     QS$EXIT\n         SPACE 2\nQS$DATE  LTR   R2,R2                    any value?\n         BNZ   QS$DGET                  yes, use it\n         TIME  BIN                      get current time/date\n         ST    R1,QS@PDATE              Save current Jdate\n         B     QS$DGO                   call conv routine\nQS$DGET  MVC   QS@PDATE,0(R2)           Save packed input Jdate\n         OC    QS@PDATE,QS@PDATE        check for valid entry\n         BZ    QS$EXIT                  if none, exit\n         OI    QS@FLAGS,QS@FDATE        indicate valid date field\n         SPACE 2\nQS$DGO   MVC   QS@MNTHS(QS#DMTHL),QS#DMTHS  Copy days-in-month table\n         OI    QS@PDATE+3,X'0F'         Remove sign\n         UNPK  QS@WORK+1(5),QS@PDATE    Get ' yyddd'\n         MVC   QS@WORK(2),QS@WORK+1     Get 'yyyddd'\n         MVI   QS@WORK+2,C'.'           Make it 'yy.ddd'\n         MVI   QS@WORK+6,C' '           Blank the last character\n         TM    QMODE1,QM1JDATE          Want Julian format dates?\n         BO    QS$DEXIT                 Yes - all done\n         SPACE 3\n         TM    QS@PDATE+1,X'01'         Leap year?\n         BO    QS$DNLEP                 No (odd year) - not leap\n         TM    QS@PDATE+1,X'12'         Divisible by 4?\n         BM    QS$DNLEP                 No - not leap year\n         MVI   QS@MNTHS+7,29            Feb has 29 days this year\n         SPACE 1\nQS$DNLEP MVC   QS@TEMP+4(4),QS@PDATE    Copy 00yydddf\n         XC    QS@TEMP(6),QS@TEMP       Clear beginning, leave 0000dddf\n         CVB   R0,QS@TEMP               Get day of year in binary\n         LA    R15,QS@MNTHS             Point to table\n         SPACE 1\nQS$DLP   SH    R0,0(,R15)               Sub number of days this month\n         BNP   QS$DHER                  Have month\n         LA    R15,6(,R15)              Next table entry\n         B     QS$DLP                   Keep looking\n         SPACE 1\nQS$DHER  MVC   QS@WORK+2(3),2(R15)      Move name of month\n         AH    R0,0(,R15)               Get back correct residual\n         CVD   R0,QS@TEMP\n         OI    QS@TEMP+7,X'0F'          Remove sign\n         UNPK  QS@WORK+5(2),QS@TEMP+6(2)  Day of month\n         SPACE 1\nQS$DEXIT MVC   0(7,R3),QS@WORK          move to output\n         B     QS$EXIT\n         SPACE 2\nQS$TIME  L     R1,0(,R2)                get time\n         XR    R0,R0\n         D     R0,=F'100'               r0=hh;r1=secs\n         SR    R0,R0\n         D     R0,=F'60'                r0=secs;r1=min\n         CVD   R0,QS@TEMP\n         OI    QS@TEMP+7,X'0F'\n         UNPK  QS@WORK+6(2),QS@TEMP     set secs\n         MVI   QS@WORK+5,C':'\n         SR    R0,R0\n         D     R0,=F'60'                r0=min;r1=hours\n         CVD   R0,QS@TEMP\n         OI    QS@TEMP+7,X'0F'\n         UNPK  QS@WORK+3(2),QS@TEMP\n         MVI   QS@WORK+2,C':'\n         CVD   R1,QS@TEMP               save hours\n         OI    QS@TEMP+7,X'0F'\n         UNPK  QS@WORK(2),QS@TEMP\n         MVC   0(8,R3),QS@WORK\n         B     QS$EXIT\n         SPACE 3\nQS$EXIT  L     R15,4(,R13)              -> prev regs\n         L     R14,12(,R15)             restore r14\n         LA    R14,2(,R14)              normal offset\n         TM    QS@PFLAG,QS@PSKIP        trailing branch present?\n         BZ    *+16                     no, leave it\n         TM    QS@FLAGS,QS@FDATE        valid data?\n         BZ    *+8                      no, leave it\n         LA    R14,4(,R14)              yes, leapfrog it\n         ST    R14,12(,R15)             save it for qstop\n         ST    R5,40(,R15)              save new r5\n         B     QSTOP\n         EJECT ,\nHEXFMT   QSTART  TYPE=ENTRY\n         LA    R6,1(,R12)               PHONY UP A \"NO MATCH\" FOR PREV\n         LR    R3,R1                    SAVE ADDR\n         LR    R5,R0                    SAVE OFFSET\n         LA    R4,16                    HANDY CONSTANT\n         L     R8,=V(CHARTAB)           -> CHARACTER TRANSLATE TABLE\n         QCALL DISP80                   SWITCH TO 3278-2 MODE IF 3278-5\n         SPACE 2\nHF$LOOP  CR    R2,R4                    > 16 BYTES LEFT?\n         BNH   HF$SHORT                 NO\n         CLC   0(16,R3),0(R6)           SAME AS PREVIOUS LINE?\n         BE    HF$NEXT                  YES - SKIP IT\n         LR    R6,R3                    SAVE ADDRESS OF THIS DATA\n         MVC   HF@DATA(16),0(R3)        SAVE DATA\n         B     HF$CONT                  CONTINUE\n         SPACE 1\nHF$MVC   MVC   HF@DATA(*-*),0(R3)       << EXECUTED >>\nHF$SHORT LR    R14,R2                   COPY LENGTH\n         BCTR  R14,0                    -1 FOR EX\n         EX    R14,HF$MVC               SAVE THE DATA\n         SPACE 1\nHF$CONT  UNPK  HF@HEX+00(14+1),HF@DATA+00(7+1)\n         UNPK  HF@HEX+14(14+1),HF@DATA+07(7+1)\n         UNPK  HF@HEX+28(04+1),HF@DATA+14(2+1)\n         TR    HF@HEX(32),QHEXTAB       CONVERT TO DISPLAYABLE HEX\n         TR    HF@DATA(16),0(R8)        TRANSLATE OUT UNPRINTABLES\n         CR    R2,R4                    < 16 BYTES ON THIS LINE?\n         BNL   HF$DISP                  NO - GO DISPLAY IT\n*---  MUST BLANK TAIL END\n         LA    R15,HF@DATA(R2)          -> DATA TO BLANK\n         MVC   0(16,R15),QBLANK         BLANK OUT NON-EXISTANT DATA\n         LA    R15,HF@HEX(R2)\n         AR    R15,R2                   -> CHARS TO BLANK\n         MVC   0(32,R15),QBLANK         ...\n         SPACE 1\nHF$DISP  ST    R5,HF@WORK               STORE OFFSET\n         UNPK  QDMSG(6+1),HF@WORK+1(3+1)\n         TR    QDMSG(6),QHEXTAB         CONVERT OFFSET TO PRINTABLE\n         MVI   QDMSG+6,C' '             REMOVE FLIP BYTE\n         MVC   QDMSG+09(8),HF@HEX+00\n         MVC   QDMSG+18(8),HF@HEX+08\n         MVC   QDMSG+28(8),HF@HEX+16\n         MVC   QDMSG+37(8),HF@HEX+24\n         MVI   QDMSG+47,C'|'\n         MVC   QDMSG+48(8),HF@DATA+0\n         MVC   QDMSG+57(8),HF@DATA+8\n         MVI   QDMSG+65,C'|'\n         BAL   R14,QADDLINE\nHF$NEXT  AR    R5,R4                    BUMP OFFSET\n         AR    R3,R4                    BUMP ADDR\n         SR    R2,R4                    DECR LENGTH\n         BP    HF$LOOP                  CONTINUE IF MORE\n         B     QSTOP\n         SPACE 3\nQS$INVC  QTILT '*** INVALID/UNSUPPORTED CALL ***'\n         SPACE 3\n***********************************************************************\n*                                                                     *\n*   MISCELLANY                                                        *\n*                                                                     *\n***********************************************************************\n         SPACE 2\nQS#OMVC  MVC   2(0,R2),QS@PL+1(R7)\nQS#COC   OC    0(0,R2),0(R2)\nQS#CMVC  MVC   0(0,R3),0(R2)\nQS#CTR   TR    0(0,R3),0(R1)\nQS#HUNPK UNPK  0(0,R3),0(0,R2)\nQS#HTR   TR    0(0,R3),QHEXTAB\nQS#DIC   IC    R1,0(,R2)   **ORDER**\n         LH    R1,0(,R2)   **ORDER**\n         L     R1,0(,R2)   **ORDER**\n         SPACE 3\n         LTORG ,\nQS#MASK  DC    X'402020',C',',X'202020',C',',X'202020',C',',X'202120'\nQS#MASKL EQU   *-QS#MASK\n         SPACE 3\nQS#DMTHS MONTHS   LC=YES\nQS#DMTHL EQU   *-QS#DMTHS\n         SPACE 3\nWORK     DSECT\n         ORG   WORK+72                  SKIP OVER SAVE AREA\n         SPACE 1\nQS@TEMP  DS    D\nQS@PDATE DS    PL4\nQS@MNTHS DS    0F,CL(QS#DMTHL)\nQS@PMSG# DS    H\nQS@PEC   DS    AL1                      entry code\nQS@PFLAG DS    X'00'                    parm flags\nQS@PFMSG EQU   X'80'                    no msg to insert\nQS@PFDAT EQU   X'40'                    no data to move\nQS@PSKIP EQU   X'20'                    branch at end of call\nQS@PLEN  DS    AL1                      len of field 2\nQS@POFF1 DS    AL2                      offset for field 1\nQS@POFF2 DS    AL2                      offset for field 2\nQS@PL    EQU   *-QS@PEC\nQS@FLAGS DS    X'00'                    misc flags\nQS@FDATE EQU   X'80'                    date present\nQS@WORK  DS    2CL(QS#MASKL)\nQS@WORKL EQU   *-WORK\nHF@WORK  DS    F\nHF@DATA  DS    CL16\n         DS    CL16                     PAD FOR BLANKING PARTIAL DATA\nHF@HEX   DS    CL32\n         DS    CL32                     PAD FOR BLANKING PARTIAL DATA\n         SPACE 3\n         QCOMMON\n         SPACE 3\n         DROPX R13                      WORK\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "Q#RL": {"ttr": 14852, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\r\\x00\\x00\\x00\\x82#/\\x00\\x90\\x16\\x7f\"\\x15\\x00v\\x00@\\x00V\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "05.13", "flags": 0, "createdate": "1982-08-20T00:00:00", "modifydate": "1990-06-16T22:15:00", "lines": 118, "newlines": 64, "modlines": 86, "user": "LDW"}, "text": "         TITLE '--- QUEUE--RMTLIST -- LIST RJE/NJE NAMES ---'\n*---------------------------------------------------------------------*\n*                                                                     *\n*   RMTLIST - List symbolic remote destination names, with their      *\n*             internal numbers                                        *\n*                                                                     *\n*   Updates:                                                          *\n*      16Jun90  LDW  Remove mode switching since we now run AMODE 31  *\n*      03Jun90  LDW  Fix for EMS's $AMODE 24 in QSTOP routine         *\n*      25Dec89  LDW  Q$SSCT -> QZSSCT                                 *\n*      23Nov89  LDW  Remove conditional assembly around Qxxx macros   *\n*                    Eliminate \"LC\" macro usage                       *\n*      31May89  LDW  Fix for non-311                                  *\n*      22Mar89  EMS  SP311 changes                                    *\n*      03/31/86 LDW  RE-DESIGN 3278-5 SUPPORT (THIRD TRY!)            *\n*      01/19/84 LDW  ADD SUPPORT FOR COMMAND STACKING                 *\n*      03/02/83 LDW  CHANGE 'QTILT *' TO USE QERRMSG                  *\n*      01/10/83 LDW  SP SUPPORT                                       *\n*                    DISPLAY ROUTE DEST                               *\n*                    CHANGE HEADER TO LOWER CASE                      *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 3\nRMTLIST  QSTART  STACK=X'B0'\n         L     R15,QSSCT                -> SSCT OF SELECTED SUBSYSTEM\n         LTR   R15,R15                  DEFINED?\n         BZ    RL$TILT1                 NO - CAN'T DO THIS SUBCOMMAND\n          AIF  (&QLEVEL GE 9).RL12\n         L     R15,SSCTSSVT-SSCT(,R15)  -> SSVT\n         USING SSVT,R15\n          AGO  .RL13\n.RL12     ANOP ,\n         L     R15,SSCTSUS2-SSCT(,R15)  -> HCCT\n         USING HCCT,R15\n.RL13     ANOP ,\n         LTR   R15,R15                  ACTIVE?\n         BZ    RL$TILT2                 NO - CAN'T DO THIS SUBCOMMAND\n         L     R3,$SVRDT                -> FIRST RDT\n          AIF  (&QLEVEL GE 9).RL14\n         L     R5,$SVRDTE               -> LAST RDT\n.RL14     ANOP ,\n         DROP  R15\n         USING RDTDSECT,R3\n         LA    R4,RDTSIZ                LENGTH OF RDT (BXLE INCR)\n         QCALL DISP80                   SWITCH TO 3278-2 MODE IF 3278-5\n         MVC   QDHLINE+10(36),RL#HDR\n         TM    QXAUTH,QXAUTHX           PRIVILEGED USER?\n         BNZ   *+10                     YES - OK\n         MVC   QDHLINE+41(5),QBLANK     REMOVE 'FLAGS' FROM HEADER\n*%%%  SHOULD DISPLAY NAME AND NUMBER OF LOCAL NODE...\n         SPACE 2\nRL$LOOP  MVC   QDMSG+10(8),RDTNAME      DEST ID\n          AIF   (&QLEVEL GE 4).RL01\n         SR    R0,R0                    CLEAR FOR IC\n.RL01     ANOP\n         TM    RDTFLAG,RDTFLAGN         USE RDTNODE AS ROUTE BYTE 1?\n         BNO   RL$NNODE                 NO - SKIP\n         LA    R1,RDTNODE               -> SYSTEM (NODE) NUMBER\n         LA    R15,QDMSG+18             -> OUTPUT AREA\n         BAL   R8,RL$EDIT               EDIT IN THE NUMBER\n         SPACE 1\nRL$NNODE TM    RDTFLAG,RDTFLAGR+RDTFLAGU  REMOTE OR UNIT NUMBER?\n         BZ    RL$OK                    NO - SKIP\n         LA    R1,RDTRMTNO              -> REMOTE OR UNIT NUMBER\n         LA    R15,QDMSG+25             ASSUME REMOTE NUMBER\n         TM    RDTFLAG,RDTFLAGR         IS IT A REMOTE NUMBER?\n         BO    *+8                      YES\n         LA    R15,QDMSG+32             NO - UNIT\n         BAL   R8,RL$EDIT               EDIT IN THE NUMBER\n         SPACE 1\nRL$OK    TM    QXAUTH,QXAUTHX           PRIVILEGED USER?\n         BZ    RL$ADD                   NO - SKIP\n         UNPK  QDMSG+42(2+1),RDTFLAG(1+1)\n         TR    QDMSG+42(2),QHEXTAB\n         MVI   QDMSG+44,C' '\nRL$ADD   BAL   R14,QADDLINE             ADD THIS LINE\n          AIF  (&QLEVEL GE 9).RL15\n         BXLE  R3,R4,RL$LOOP            FORMAT ALL RDT'S\n          AGO  .RL16\n.RL15     ANOP ,\n         ICM   R3,B'1111',RDTRDT        format\n         BNZ   RL$LOOP                        all RDT'S\n.RL16     ANOP ,\n         B     QSTOP                    LEAVE WHEN DONE\n         SPACE 2\nRL$TILT1 MVC   QERRMSG(27),=C'*** XXXX IS NOT DEFINED ***'\n         MVC   QERRMSG+4(4),QJESNAME\n         QTILT *\nRL$TILT2 MVC   QERRMSG(22),=C'*** XXXX IS NOT UP ***'\n         MVC   QERRMSG+4(4),QJESNAME\n         QTILT *\n         SPACE 2\n*---  RL$EDIT - FORMAT A BINARY NODE OR REMOTE NUMBER              ---*\n*---    R1 -> 1 (NON-SP) OR 2 (SP) BYTE BINARY NUMBER (INPUT)      ---*\n*---    R8 -> RETURN                                               ---*\n*---    R15 -> 6 BYTE OUTPUT AREA                                  ---*\n          AIF   (&QLEVEL GE 4).RL08\n*---  ASSUME HIGH ORDER 3 BYTES OF R0 STILL CLEAR FROM ABOVE       ---*\nRL$EDIT  IC    R0,0(,R1)                GET INPUT NUMBER\n          AGO   .RL09\n.RL08     ANOP\nRL$EDIT  LH    R0,0(,R1)                GET INPUT NUMBER\n.RL09     ANOP\n         CVD   R0,QNUMWORK\n         MVC   1(5,R15),=X'2020202020'  MOVE IN EDIT MASK\n         ED    0(6,R15),QNUMWORK+5\n         BR    R8                       RETURN TO CALLER\n         SPACE 2\n         LTORG ,\n         SPACE 2\nRL#HDR   DC    C'Destid    Node  Remote  Unit   Flags'\n         SPACE 3\n         QCOMMON\n         SPACE 3\n         Q$SVT\n         Q$HCCT\n         Q$RDT\n         QZSSCT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "Q#RP": {"ttr": 14855, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x05\\n\\x00\\x00\\x00\\x82#/\\x00\\x87 \\x0f\\x19'\\x016\\x01\\x01\\x00h\\xc5\\xd4\\xe2@@@@@@@\"", "ispf": {"version": "05.10", "flags": 0, "createdate": "1982-08-20T00:00:00", "modifydate": "1987-07-19T19:27:00", "lines": 310, "newlines": 257, "modlines": 104, "user": "EMS"}, "text": "         TITLE '--- QUEUE--REPOS -- DATASET REPOSITIONING ROUTINES ---'\n*---------------------------------------------------------------------*\n*                                                                     *\n*   REPOS - CHANGE POSITION IN OUTPUT DATASET                         *\n*                                                                     *\n*   Updates:                                                          *\n*      19Jul87  EMS  Add \"PAGE(P)\" code(64)                           *\n*      21Mar87  LDW  Fix for DSID = 0 (from RSCS)                     *\n*      01/19/84 LDW  ADD SUPPORT FOR COMMAND STACKING                 *\n*      02/04/83 LDW  ADD \"REDISP\" (CODE 60)                           *\n*                    FIX \"FIND\" TO CORRECTLY HANDLE \"FIND /C=Q/\"      *\n*                       (PARSE WILL LEAVE QPARM1 BLANK, BUT QOFF1     *\n*                       WILL BE CORRECTLY SET)                        *\n*      01/19/83 LDW  USE QTPAGEX AND QTHALFX WHEN APPROPRIATE         *\n*      01/07/83 LDW  SET QDPROMPT (REPOS WILL BECOME \"IMMEDIATE\" CMD) *\n*                    FIX BUGS IN COL(N,N) PROCESSING (IT WASN'T FOUND *\n*                       IF ENTERED IN LOWER CASE OR IF STRING WAS     *\n*                       ENTERED WITHOUT DELIMITERS)                   *\n*                    MINOR INTERNAL CLEANUP                           *\n*      12/20/82 LDW  CHANGE QTILT REPRMPT=YES TO OPTIONS=REPROMPT     *\n*      12/08/82 LDW  DEFAULT \"COL\" WITH NO OPERAND TO PRESET VALUE    *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 3\nREPOS    QSTART  Q18,STACK=(X'30','REDISP')\n         USING WORK,R13\n***********************************************************************\n*                                                                     *\n*   BRANCH TO PROPER ROUTINE                                          *\n*                                                                     *\n***********************************************************************\n*%%%     CLC   QPDSID,=H'0'             IS THERE A VALID DATASET?\n*%%%     BNE   RP$GO                    YES. GO AHEAD.\n         TM    QFLAG2,Q2VALIDS          IS THERE A VALID DATASET?\n         BNZ   RP$GO                    YES. GO AHEAD.\n         MVC   QDPROMPT,QDREPLY         SET WHAT TO REPROMPT\n         QTILT '=== YOU ARE NOT PROCESSING A VALID DATASET ==='\nRP$GO    ZAP   RP@PAGE,QTPAGE           ASSUME COLUMN INDICATOR IS OFF\n         ZAP   RP@HALF,QTHALF           ...\n         TM    QFLAG2,Q2COLIND          IS IT?\n         BZ    RP$CIOFF                 YES - OK\n         ZAP   RP@PAGE,QTPAGEX          NO, ON - USE ALTERNATE ...\n         ZAP   RP@HALF,QTHALFX          ... SCROLL AMOUNTS\nRP$CIOFF LH    R1,QCODEH                LOAD FUNCTION CODE\n         CH    R1,=H'64'                IS THE FUNCTION SUPPORTED?\n         BNH   *+8(R1)                  YES - BRANCH TO ROUTINE\n         EX    0,*                      NO - QUEUE LOGIC ERROR\n         B     RP$TILT                  0 OFFSET\n         B     RP$FIND                  4\n         B     RP$FTIME                 8\n         B     RP$COL                   12\n         B     RP$AT                    16\n         B     RP$DOWN                  20\n         B     RP$UP                    24\n         B     RP$TOP                   28\n         B     RP$BOTTM                 32\n         B     RP$LEFT                  36\n         B     RP$RIGHT                 40\n         B     RP$PF                    44\n         B     RP$HF                    48\n         B     RP$PB                    52\n         B     RP$HB                    56\n         B     RP$RESUM                 60\n         B     RP$PAGE                  64\nRP$TILT  MVC   QDPROMPT,QDREPLY         SET WHAT TO REPROMPT\n         QTILT '*** PARAMETER IS INVALID OR OMITTED ***',              $\n               OPTIONS=REPROMPT\n***********************************************************************\n*                                                                     *\n*   REPOSITION VERTICALLY                                             *\n*                                                                     *\n***********************************************************************\n* SKIP FORWARD\nRP$DOWN  CLC   =C'M ',QPARM1            MAX?\n         BE    RP$BOTTM                 YES - DO A \"BOTTOM\"\n         BAL   R4,RP$NUMHP              VALIDATE & PACK PARAMETER\n         AP    QPREC,QNUMWORK           ADD COUNT TO CURRENT RECORD\n         B     RP$RESUM                 CALL LISTDS\n* SKIP BACKWARD\nRP$UP    CLC   =C'M ',QPARM1            MAX?\n         BE    RP$TOP                   YES - DO A \"TOP\"\n         BAL   R4,RP$NUMHP              VALIDATE & PACK PARAMETER\n         SP    QPREC,QNUMWORK           SUBTRACT COUNT FROM CURR REC\n         BP    RP$RESUM                 CALL LISTDS IF RESULT POSITIVE.\n         B     RP$TOP                   OTHERWISE JUST GO TO TOP\n* TOP OF DATASET\nRP$TOP   ZAP   QPREC,=P'1'              SET CURRENT RECORD TO TOP OF DS\n         SPACE 2\n* RESUME AT CURRENT RECORD\nRP$RESUM QCALL LISTDS\n         B     QSTOP\n         SPACE 2\n* BOTTOM OF DATASET\nRP$BOTTM ZAP   QPREC,=P'9999999'        SET CURRENT RECORD TO LARGEST\n         MVC   QSUBNAME(2),=C'B '       CHANGE COMMAND TO \"BOTTOM\"\n         MVI   QCODE,32                 CHANGE COMMAND TO \"BOTTOM\"\n         B     RP$RESUM                 CALL LISTDS\n* PAGE FORWARD\nRP$PF    BAL   R4,RP$NUM1               VALIDATE AND CONVERT OPERAND\n         MP    QNUMWORK,RP@PAGE         MULTIPLY BY PAGE SIZE\n         AP    QPREC,QNUMWORK           UPDATE RECORD POSITION\n         B     RP$RESUM                 RE-INVOKE LISTDS\n* HALF FORWARD\nRP$HF    BAL   R4,RP$NUM1               VALIDATE AND CONVERT OPERAND\n         MP    QNUMWORK,RP@HALF         MULTIPLY BY HALF SIZE\n         AP    QPREC,QNUMWORK           UPDATE RECORD POSITION\n         B     RP$RESUM                 RE-INVOKE LISTDS\n* PAGE BACKWARD\nRP$PB    BAL   R4,RP$NUM1               VALIDATE AND CONVERT OPERAND\n         MP    QNUMWORK,RP@PAGE         MULTIPLY BY PAGE SIZE\n         SP    QPREC,QNUMWORK           UPDATE RECORD POSITION\n         B     RP$RESUM                 RE-INVOKE LISTDS\n* HALF BACKWARD\nRP$HB    BAL   R4,RP$NUM1               VALIDATE AND CONVERT OPERAND\n         MP    QNUMWORK,RP@HALF         MULTIPLY BY PAGE SIZE\n         SP    QPREC,QNUMWORK           UPDATE RECORD POSITION\n         B     RP$RESUM                 RE-INVOKE LISTDS\n* POSITION TO THIS RECORD\nRP$AT    BAL   R4,RP$NUMX               VALIDATE PARAMETER\n         ZAP   QPREC,QNUMWORK           INDICATE REPOSITION NO\n         B     RP$RESUM                 CALL LISTDS\n* Position to this Page\nRP$PAGE  BAL   R4,RP$NUM1               Validate parameter\n         ZAP   QPPAGE,QNUMWORK          indicate page no\n         ZAP   QPLINE,=P'1'             set to line 1\n         MVI   QCODE,64                 set command to \"PAGE\"\n         B     RP$RESUM                 CALL LISTDS\n***********************************************************************\n*                                                                     *\n* CHECK THE PARAMETER FOR SPECIAL CASES\n*                                                                     *\n***********************************************************************\n*  DEFAULT = 1/2 SCREEN WIDTH\nRP$NUMC  LH    R15,QDCOLS               DEFAULT NUMBER OF COLUMNS...\n         SRL   R15,1                    ... IS HALF THE SCREEN WIDTH\n         CVD   R15,QNUMWORK             HERE TOO\n         B     RP$NUM\n*  DEFAULT = 1\nRP$NUM1  ZAP   QNUMWORK,=P'1'           ASSUME NEED DEFAULT\n         LA    R15,1                    HERE TOO\n         B     RP$NUM                   TEST AND CONVERT OPERAND\n*  HALF AND PAGE\nRP$NUMHP ZAP   QNUMWORK,RP@HALF         ASSUME HALF-PAGE\n         CLI   QPARM1,C'H'              IS IT?\n         BER   R4                       YES\n         ZAP   QNUMWORK,RP@PAGE         ASSUME PAGE\n         CLI   QPARM1,C'P'              IS IT?\n         BER   R4                       YES\n*  CHECK THE PARAMETER FOR VALID NUMERIC AND PACK IT\n*  (DEFAULT PREVIOUSLY SET)\nRP$NUM   CLI   QPARM1,C' '              ANY OPERAND?\n         BER   R4                       NO - USE DEFAULT\nRP$NUMX  LH    R1,QLNG1                 LENGTH OF PARM\n         SH    R1,=H'1'                 IS THE COUNT FIELD ZERO?\n         BM    RP$RESUM                 YES. RESUME FROM CURRENT POSIT\n         LA    R15,QPARM1               POINT TO PARM\n         BAL   R14,QNUMCONV             CONVERT IT\n         BNE   RP$TILT                  TILT IF NOT NUMERIC\n         BR    R4                       RETURN\n***********************************************************************\n*                                                                     *\n*   REPOSITION HORIZONTALLY                                           *\n*                                                                     *\n***********************************************************************\n*  SPECIFIC COLUMN\nRP$COL   LH    R15,QPOFFDEF             GET DEFAULT OFFSET\n         LA    R15,1(,R15)              ADJUST FOR COLUMN\n         BAL   R4,RP$NUM                VALIDATE PARAMETER\n         CH    R15,=H'255'              IS THE COUNT FIELD TOO BIG?\n         BH    RP$TILT                  YES. TILT.\n         SH    R15,=H'1'                CONVERT COLUMN NUMBER TO OFFSET\n         BM    RP$TILT                  INVALID. TILT.\n         STH   R15,QPOFFSET             STORE IN QPOFFSET\n         B     RP$RESUM                 CALL LISTDS\n*  MOVE LEFT\nRP$LEFT  BAL   R4,RP$NUMC               VALIDATE PARAMETER\n         SH    R15,QPOFFSET\n         LCR   R15,R15                  COMPUTE NEW COLUMN\n         BNM   *+6                      CONTINUE IF OK\n         SR    R15,R15                  GO TO LEFT MARGIN\n         STH   R15,QPOFFSET             SET NEW COLUMN NUMBER\n         B     RP$RESUM                 CALL LISTDS\n*  MOVE RIGHT\nRP$RIGHT BAL   R4,RP$NUMC               VALIDATE PARAMETER\n         AH    R15,QPOFFSET\n         CH    R15,=H'255'              TOO BIG?\n         BL    *+8                      NO - OK\n         LA    R15,255                  GO REAL FAR RIGHT\n         STH   R15,QPOFFSET             SET NEW COLUMN NUMBER\n         B     RP$RESUM                 CALL LISTDS\n***********************************************************************\n*                                                                     *\n*   LOCATE SPECIFIC RECORD                                            *\n*                                                                     *\n***********************************************************************\nRP$FIND  CLI   QSUBNAME+1,C'A'          IS THE REQUEST FOR FIND ALL?\n         BE    *+10                     YES. DO NOT UPDATE REC POINTER.\n         AP    QPREC,=P'1'              START SEARCH AT NEXT RECORD\n         LH    R15,QOFF1                OFFSET OF OPERANDS\n         LTR   R15,R15                  IS THERE A PARAMETER?\n         BZ    RP$RESUM                 NO. CONTINUE WITH PREV. FIND.\n         MVC   QFINDCMD,QDREPLY         SAVE THIS FIND COMMAND\n         MVC   RP@REPLY,QDREPLY         COPY IT\n         LA    R15,RP@REPLY(R15)        -> START OF OPERANDS\n         OC    RP@REPLY,QBLANK          MAKE THE COPY UPPER CASE\n         LA    R2,RP@REPLY+QDREPLYL-1   END OF USER REPLY\n         LA    R3,QDREPLYL-2            MAXIMUM LENGTH OF PARM\n         SH    R3,QOFF1                 OFFSET TO FIRST PARM\n         CLI   0(R15),C'A'              ANY DELIMITER?\n         BNL   RP$FINDX                 NO - USE THE FIRST WORD\n*---  LOOK FOR ENDING DELIMITER                                    ---*\nRP$LOOP  CLC   0(1,R2),0(R15)           IS THIS THE DELIMITER?\n         BE    RP$FOUND                 YES. CONTINUE.\n         BCTR  R2,0                     TRY THE PREVIOUS BYTE\n         BCT   R3,RP$LOOP               IS THE LENGTH FIELD EXHAUSTED?\n         B     RP$TILT                  YES. TILT.\nRP$FOUND BCTR  R3,0                     DECREMENT LENGTH BY 1\n         LA    R2,RP@REPLY+1            ADDR OF REPLY + 1\n         AH    R2,QOFF1                 ADDR OF FIRST BYTE OF PARM\n         EX    R3,RP$MVC                MOVE PARM TO QPFIND\n         STH   R3,QPLNG                 SAVE LENGTH-1 OF PARM\n         LA    R2,1+1+1(R2,R3)          PREPARE FOR NEXT FIELD\n*---  1 FOR EX, 1 FOR DELIM, 1 FOR REQUIRED BLANK                  ---*\n         B     RP$FICOL                 SEE IF COL(N,N) ENTERED\n*---  SAVE UN-DELIMITED STRING (JUST USE FIRST WORD OF OPERAND)    ---*\nRP$FINDX LA    R2,RP@REPLY              -> START\n         AH    R2,QOFF1                 -> FIRST NON-BLANK\n         LA    R1,1(,R2)                -> WHERE TO START SEARCH\n         BAL   R14,*+8                  SET LOOP ADDR, SKIP FIRST INCR\n         LA    R1,1(,R1)                -> NEXT CHAR\n         CLI   0(R1),C' '               FIND END OF WORD?\n         BE    *+6                      YES - STOP\n         BCTR  R3,R14                   NO - KEEP LOOKING\n         SR    R1,R2                    COMPUTE LENGTH OF WORD\n         BCTR  R1,0                     -1 FOR EX\n         EX    R1,RP$MVC                SAVE IT\n         STH   R1,QPLNG                 SAVE LENGTH-1 OF SEARCH KEY\n         LA    R2,1+1(R2,R1)            PREPARE FOR NEXT FIELD\n*---  1 FOR EX, 1 FOR REQUIRED BLANK                               ---*\n         B     RP$FICOL                 SEE IF COL(N,N) ENTERED\nRP$MVC   MVC   QPFIND(*-*),0(R2)        << EXECUTED >>\n***********************************************************************\n*                                                                     *\n*    COLUMN RANGE FOR FIND                                            *\n*                                                                     *\n***********************************************************************\nRP$FICOL XC    QOFFS,QOFFS              RESET COLUMN OFFSETS\n         XC    QOFFE,QOFFE\n         LA    R3,RP@REPLY+QDREPLYL-8   END OF USER REPLY\nRP$CLOOP CLC   =C'COL(',0(R2)           ?/COLUMN PARAMETER\n         BE    RP$CFND                  YES. GO PROCESS\n         LA    R2,1(,R2)                NO. LOOK AT NEXT FIELD\n         CR    R2,R3                    ?/END OF REPLY\n         BH    RP$RESUM                 YES. EXIT\n         B     RP$CLOOP                 NO. CHECK AGAIN\nRP$CFND  LA    R2,4(,R2)                NEXT FIELD\n         LA    R3,RP@REPLY+QDREPLYL-1   END OF REPLY\n         MVI   QDELIMIT,C','            LOOKING FOR DELIMETER = ','\n         BAL   R7,RP$CKDEL              GO CHECK THE DELIMETER\n         STH   R15,QOFFS                SAVE START COLUMN\n         LA    R2,1(,R2)                NEXT FIELD\n         MVI   QDELIMIT,C')'            LOOKING FOR DELIMETER = ')'\n         BAL   R7,RP$CKDEL              GO CHECK THE DELIMETER\n         STH   R15,QOFFE                SAVE END COLUMN\n         CLC   QOFFS,QOFFE              ?/ERROR IN COL SPECIFICATION\n         BNL   RP$COERR                 YES. DISREGARD COLUMN SEARCH\n         B     RP$RESUM                 NO. CONT WITH NORMAL PROCESSING\nRP$CKDEL LR    R5,R2                    SAVE START OF THIS FIELD\nRP$CKDL2 CLC   0(1,R2),QDELIMIT         ?/DELIMITER FOUND\n         BE    RP$CKDL3                 YES. GO PROCESS\n         LA    R2,1(,R2)                NO. LOOK AT NEXT FIELD\n         CR    R2,R3                    ?/END OF REPLY\n         BH    RP$COERR                 YES. EXIT\n         B     RP$CKDL2                 NO. CHECK AGAIN\nRP$CKDL3 LR    R1,R2                    SAVE DELIMITER ADDRESS\n         SR    R1,R5                    LENGTH OF SUB-PARM\n         CH    R1,=H'3'                 ?/LENGTH TO LONG\n         BNL   RP$COERR                 YES. DISREGARD COLUMN SEARCH\n         BCTR  R1,0                     LENGTH FOR EXEC INTRUCTION\n         LR    R15,R5                   GET ADDRESS OF NUMBER\n         BAL   R14,QNUMCONV             CONVERT TO BINARY\n         BNE   RP$TILT                  EXIT WITH ERMSG IF NOT NUMERIC\n         SH    R15,=H'1'                CONVERT COLUMN NUMBER TO OFFSET\n         BNMR  R7                       RETURN IF USER DIDN'T SAY 0\nRP$COERR XC    QOFFS,QOFFS              DISREGARD FIND\n         XC    QOFFE,QOFFE              BY COLUMN RANGE\n         MVC   QDPROMPT,QDREPLY         SET WHAT TO REPROMPT\n         QTILT '*** ERROR IN COLUMN SPECIFICATION ***',OPTIONS=REPROMPT\n***********************************************************************\n*                                                                     *\n*   REPOSITION IN SYSLOG DATASET BY TIME OF DAY                       *\n*                                                                     *\n***********************************************************************\nRP$FTIME CLI   QPARM1,C' '              IS THE PARM OMITTED?\n         BE    RP$TILT                  YES. TILT.\n         B     RP$RESUM                 CALL LISTDS\n***********************************************************************\n*                                                                     *\n*   MISCELLANY                                                        *\n*                                                                     *\n***********************************************************************\n         LTORG\n         SPACE 3\n         QCOMMON\n         SPACE 3\nWORK     DSECT\n         ORG   WORK+72\nRP@PAGE  DS    PL2\nRP@HALF  DS    PL2\nRP@REPLY DS    CL(QDREPLYL)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "Q#RS": {"ttr": 15105, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x0c\\x00\\x00\\x00\\x82#/\\x00\\x90\\x16\\x7f#\\x04\\x00\\xc5\\x00x\\x00\\x87\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "05.12", "flags": 0, "createdate": "1982-08-20T00:00:00", "modifydate": "1990-06-16T23:04:00", "lines": 197, "newlines": 120, "modlines": 135, "user": "LDW"}, "text": "         TITLE '--- QUEUE--READSPC -- READ A BLOCK FROM HASPACE ---'\n*---------------------------------------------------------------------*\n*                                                                     *\n*   READSPC - READ A BLOCK FROM HASPACE                               *\n*                                                                     *\n*   ENTRY - R1 = ADDRESS OF I/O AREA                                  *\n*           QCTRAK = MTTR TO READ                                     *\n*                                                                     *\n*   Updates:                                                          *\n*      16Jun90  LDW  Since we run (mostly) in AMODE31 now, switch to  *\n*                       AMODE24 to do I/O                             *\n*      25Dec89  LDW  QDCBD -> QZDCBD                                  *\n*      19Jul87  EMS  improve checking for invalid MTTR                *\n*       1Jun87  EMS  Add support for Starting/Draining Spool vols     *\n*                    improve checking for invalid MTTR                *\n*                    Add QDCBD for DCBSYNA                            *\n*      25Jan87  LDW  Use JQE addr passed in R0 for CBID error message *\n*      04/22/86 LDW  MOVE ATTN FLAG FROM QTERMFLG TO QMISCFLG         *\n*                    CHANGE SYNAD FLAG TO A SINGLE BIT                *\n*      08/30/84 LDW  FIX BUG IN 'EXPECTED XXX NOT READ...' MESSAGE    *\n*      08/07/84 LDW  SHOW MTTR IN MSG ABOUT ATTEMPT TO READ OUTSIDE   *\n*                       HASPACE EXTENTS                               *\n*                    FIX BUG IN SYNAD ROUTINE (MOVE ERROR TEXT TO     *\n*                       QERRMSG INSTEAD, NOT QDHLINE)                 *\n*                    INVALIDATE CURRENT BLK MTTR IF READ IS NOT       *\n*                       SUCCESSFUL                                    *\n*      03/02/83 LDW  CHANGE 'QTILT *' TO USE QERRMSG                  *\n*      01/07/83 LDW  FIX BUG IN READ AVOIDANCE LOGIC                  *\n*                    CHANGE METHOD OF CHECKING CONTROL BLOCK ID'S     *\n*                    MAKE BAD CB ID ERROR MSG A QTILT                 *\n*                    PUT MSG TO SCREEN BUFFER IF ATTN                 *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 3\nREADSPC  QSTART  Q17\n         USNGX WORK,R13\n         LR    R9,R0                    SAVE JQE ADDRESS\n         USNGX JQEDSECT,R9\n         TM    QMISCFLG,QMFATTN         ATTN PRESSED?\n         BO    RS$ATTN                  YES - EXIT BACK TO Q MAINLINE\n         L     R15,QC##RSPC             GET ENTRY COUNTER\n         LA    R15,1(,R15)              INCREMENT\n         ST    R15,QC##RSPC             STORE UPDATED COUNTER\n         CL    R1,QCBLKA                ARE WE READING A DATASET BLOCK?\n         BNE   RS$READ                  NO - CONTINUE\n         CLC   QCBLKTTR,QCTRAK          YES - DO WE HAVE THIS ONE?\n         MVC   QCBLKTTR,QCTRAK          SAVE ADDR OF BLOCK BEING READ\n         BNE   RS$READ                  NO - CONTINUE\n         L     R15,QC#RSPC#             GET \"READ AVOIDED\" COUNTER\n         LA    R15,1(,R15)              INCREMENT\n         ST    R15,QC#RSPC#             STORE UPDATED COUNTER\n         B     QSTOP                    ALL DONE\n         SPACE 2\nRS$READ  NI    QMISCFLG,255-QMFSYNAD    CLEAR SYNAD FLAG\n***********************************************************************\n*                                                                     *\n*   CONVERT MTTR TO MBBCCHHR                                          *\n*                                                                     *\n***********************************************************************\n         LR    R2,R1                    MOVE IOAREA ADDR TO R2\n         SR    R3,R3                    CLEAR FOR IC\n         IC    R3,QCTRAKM               RELATIVE DCB NUMBER\n         CH    R3,=Y($MAXDA)            GREATER THAN MAX?\n         BH    RS$TILT                  YES - ERROR\n         L     R15,QCEXTMAP             -> ext map\n         IC    R3,0(R3,R15)             -> correct dcb\n         CLM   R3,B'0001',=X'FF'        invalid?\n         BE    RS$TILT                  yes, say so\n         SLL   R3,2                     MULTIPLY BY 4\n         CLI   QCTRAKR,0                r0?\n         BE    RS$TILT                  yes, invalid\n         MVC   QCDADR,QCTRAKR           MOVE RECORD NUMBER\n         SR    R5,R5                    CLEAR FOR ICM\n         ICM   R5,B'0011',QCTRAKTT      LOAD RELATIVE TRACK NUMBER\n         SR    R4,R4                    CLEAR FOR DIVIDE\n         L     R15,QCTRKCYL             -> trk/cyl table\n*%%      C     R4,0(R3,R15)             ARE WE ABOUT TO DIVIDE BY ZERO?\n*%%      BNE   RS$DIV                   NO - CONTINUE\n         B     RS$DIV                   go divide\n         SPACE 1\nRS$TILT  MVC   QCBLKTTR,=X'FFFEEFFE'    INVALIDATE CURRENT BLOCK MTTR\n         MVC   QERRMSG(66),=C'*** ATTEMPTED READ OUTSIDE OF HASPACE EXT$\n               ENTS -- MTTR=XXXXXXXX ***'\n         HEX   QERRMSG+54,QCTRAK,HEXTAB=QHEXTAB\nRS$TILTX QTILT *\n         SPACE 2\nRS$DIV   D     R5-1,0(R3,R15)           DIVIDE TRACKS BY TRACKS PER CYL\n         STH   R4,QCDADHH               STORE HEAD NUMBER\n         STH   R5,QCDADCC               STORE CYLINDER NUMBER\n         L     R15,QCSPOOLS             -> DCB list\n         L     R3,0(R3,R15)             DCB ADDRESS\n         MVC   DCBSYNA-IHADCB(3,R3),=AL3(RS$SYNAD)  SET SYNAD ADDRESS\n         BAL   R14,QAMODE24             change to AMODE 24\n         L     R1,QCDECB2               -> DECB FOR HASPACE\n         SPACE 1\n         READ  (1),DI,(R3),(R2),MF=E\n         SPACE 1\n         L     R1,QCDECB2               -> DECB FOR HASPACE\n         SPACE 1\n         CHECK (1)\n         SPACE 1\n         BAL   R14,QAMODE31             resume AMODE 31\n         TM    QMISCFLG,QMFSYNAD        WAS THERE AN ERROR?\n         BNZ   QTILT                    YES - MSG ALREADY SET\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*  VALIDITY CHECK THE CONTROL BLOCK ID IN THE BLOCK JUST READ         *\n*                                                                     *\n***********************************************************************\n         CLI   QCCBID,C' '              ANY CB ID TO CHECK?\n         BE    QSTOP                    NO - JUST RETURN\n*---  ASSUME THAT ALL JES2 CONTROL BLOCK ID'S ARE IN THE FIRST     ---*\n*---  FOUR CHARACTERS OF THE BLOCK                                 ---*\n         CLC   QCCBID,0(R2)             CORRECT CONTROL BLOCK ID?\n         BNE   RS$OOPS                  NO\n         MVI   QCCBID,C' '              NULLIFY CB CHECK\n         B     QSTOP                    EXIT THIS ROUTINE\n         SPACE 2\nRS$OOPS  MVC   QERRMSG(76),=C'*** EXPECTED XXX NOT READ FOR XXXXXXXX(XX$\n               XXXXXX) -- LOGIC OR SPOOL ERROR ***'\n         MVC   QERRMSG+13(3),QCCBID     MOVE CB ID TO MESSAGE\n         MVI   QCCBID,C' '              NULLIFY CB CHECK\n**%%     MVC   QERRMSG+30(18),QDHJOBID  MOVE JOBNAME(JOBID) TO MESSAGE\n         LTR   R9,R9                    ANY JQE ADDR???\n         BZ    RS$TILTX                 NO - SKIP\n         MVC   QERRMSG+30(8),JQEJNAME   MOVE JOBNAME TO MESSAGE\n         MVI   QERRMSG+38,C'('          PUT IN DELIM\n         MVC   RS@WORK,=X'402020202020'   PREPARE FOR EDIT\n         LH    R0,JQEJOBNO              LOAD HASP JOBNUMBER\n         MVC   QERRMSG+39(3),=C'JOB'    ASSUME JOB\n          AIF   (&QLEVEL GE 4).RS01\n         LH    R1,=H'10000'             GET RANGE SIZE\n         SR    R0,R1                    IS IT A JOB NUMBER?\n         BNP   RS$JBNO                  YES\n         MVC   QERRMSG+39(3),=C'STC'    ASSUME STC\n         SR    R0,R1                    IS IT A STC NUMBER?\n         BNP   RS$JBNO                  YES\n         MVC   QERRMSG+39(3),=C'TSU'    ASSUME TSU\n         SR    R0,R1                    IS IT A TSU NUMBER?\n         BNP   RS$JBNO                  YES\n         EX    0,*                      THIS BETTER NEVER HAPPEN\nRS$JBNO  AR    R0,R1                    RESTORE JOB NUMBER\n         CVD   R0,QNUMWORK              CONVERT TO DECIMAL\n          AGO   .RS02\n.RS01     ANOP\n         TM    JQEFLAG3,QUEJOB          IS IT A JOB?\n         BZ    RS$JBNO                  YES\n         BM    *+8                      CONTINUE IF ONLY 1 BIT SET\n         EX    0,*                      THIS BETTER NEVER HAPPEN\n         MVC   QERRMSG+39(3),=C'STC'    ASSUME STC\n         TM    JQEFLAG3,QUESTC          IS IT A STC?\n         BO    RS$JBNO                  YES\n         MVC   QERRMSG+39(3),=C'TSU'    ASSUME TSU\nRS$JBNO CVD    R0,QNUMWORK              CONVERT TO DECIMAL\n.RS02     ANOP\n*  DON'T NEED TO PRESET R1 FOR EDMK FAILURE SINCE JES2 WON'T CREATE\n*  JOB 0, STC 0, OR TSU 0.\n         EDMK  RS@WORK,QNUMWORK+5       EDIT HASP JOBNUMBER\n         BCTR  R1,0                     BACK UP TO BEFORE FIRST DIGIT\n         MVC   QERRMSG+42(5),RS@WORK+1  MOVE HASP JOBNUMBER TO SCREEN\n         MVI   QERRMSG+47,C')'          AND CLOSING DELIM\n         B     RS$TILTX                 ABORT (\"QTILT *\")\n         SPACE 1\n         DROPX R9,R13                   JQEDSECT, WORK\n         SPACE 2\nRS$ATTN  MVC   QDMSG,QBLANK             CLEAR LINE BUFFER\n         MVC   QDMSG(RS#ATMSL),RS#ATMSG MOVE IN THE MESSAGE\n         MVI   QDATRNUM+1,2             NUMBER OF ATTR BYTES IN LINE\n         BAL   R14,QADDLINE             ADD MSG TO SCREEN BUFFER\n         L     R13,QFRSTSA              -> FIRST SAVE AREA\n         LM    R14,R12,12(R13)          RELOAD MAINLINE'S REGISTERS\n         BR    R14                      FAKE A NORMAL SUBCMD RETURN\n         SPACE 2\nRS$SYNAD SYNADAF  ACSMETH=BDAM          DECODE ERROR\n         SPACE 1\n         MVC   QERRMSG(78),50(R1)       GET MESSAGE TEXT\n         OI    QMISCFLG,QMFSYNAD        SET FLAG\n         MVC   QCBLKTTR,=X'FFFEEFFE'    INVALIDATE CURRENT BLOCK MTTR\n         SPACE 1\n         SYNADRLS  ,                    RELEASE WORK AREA\n         SPACE 1\n         BR    R14                      RETURN TO READSPC VIA SYSTEM\n         SPACE 2\n         LTORG ,\n         SPACE 2\nRS#ATMSG DC    X'1DE8'                  SF: OUTPUT, BRIGHT\n         DC    C'*** SUBCOMMAND TERMINATED BY ATTENTION KEY ***'\n         DC    X'1D60'                  SF: OUTPUT, NORMAL\nRS#ATMSL EQU   *-RS#ATMSG\n         SPACE 3\nWORK     DSECT\n         ORG   WORK+72                  SKIP OVER SAVE AREA\nRS@WORK  DS    CL6\n         QCOMMON\n         QZDCBD\n         Q$JQE\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "Q#SF": {"ttr": 15109, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x00\\x00\\x00\\x83\\x00o\\x00\\x86\\t\\x7f\\x13H\\x00~\\x00\\x83\\x00\"\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "1983-01-06T00:00:00", "modifydate": "1986-04-07T13:48:00", "lines": 126, "newlines": 131, "modlines": 34, "user": "LDW"}, "text": "         TITLE '--- QUEUE--SPFFUNC -- INVOKE SPF FUNCTION ---'\n*---------------------------------------------------------------------*\n*                                                                     *\n*   SPFFUNC - INTERFACE TO SPF SERVICES (EDIT AND BROWSE)             *\n*                                                                     *\n*   UPDATES:                                                          *\n*      04/07/86 LDW  USE NEW COMMON LOGIC ERROR ROUTINE               *\n*      04/16/84 LDW  DON'T STACK THIS SUBCOMMAND                      *\n*      01/19/84 LDW  ADD SUPPORT FOR COMMAND STACKING                 *\n*      05/02/83 LDW  FIX BUG IN ERROR MESSAGES                        *\n*      03/02/83 LDW  CHANGE 'QTILT *' TO USE QERRMSG                  *\n*      02/04/83 LDW  USE SOME LITERALS INSTEAD OF DC'S                *\n*                    LET 'LINK' MACRO BUILD PARM LIST                 *\n*      01/06/83 LDW  ROUTINE STOLEN FROM SKIP ROBINSON'S VERSION AND  *\n*                       ADAPTED TO THIS VERSION                       *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 3\nSPFFUNC  QSTART  WORKLEN=SF@WORKL       ,STACK=X'B0'\n         USING WORK,R13\n         TM    QFLAG2,Q2SPF             ARE WE IN SPF ENVIRONMENT?\n         BO    SF$START                 YES - CONTINUE\n         QTILT '*** SPF SERVICES NOT AVAILABLE IN THIS ENVIRONMENT ***'\n*---  FORCE EDIT/BROWSE FULL SCREEN WRITE\nSF$START LINK  EPLOC=SF#ISPLK,PARAM=(SF#CNTL,SF#DISP,SF#REFR),VL=1\n         SPACE 1\n         OC    QDREPLY,QBLANK           ENTIRE REPLY TO UPPER CASE\n         MVC   SF@VOL,QBLANK            INIT VOLUME FIELD\n*---  PROCESS DSN\n         LH    R1,QOFF1                 GET OFFSET TO DSN\n         LTR   R1,R1                    WAS A DSN GIVEN?\n         BP    SF$DSN2                  YES - CONTINUE\n         MVC   QDPROMPT,QDREPLY         SET WHAT TO PROMPT\n         QTILT '*** DATASET NAME MUST BE SPECIFIED FOR SPF SERVICE ***'$\n               ,OPTIONS=REPROMPT\nSF$DSN2  LA    R1,QDREPLY(R1)           POINT TO DSN\n         ST    R1,SF@PARM1              SET INTO PARM LIST\n*---  PROCESS KEYWORDS IF GIVEN\n         LA    R15,QKEYWORD             -> FIRST KEYWORD\n         LA    R0,16                    ENTRY LENGTH\n         LA    R1,QKEYLAST              -> PAST LAST ENTRY\nSF$KEYLP CLI   0(R15),C' '              ANY KEYWORD HERE?\n         BE    SF$GO                    NO - ALL KEYWORDS PROCESSED\n*---  THE FOLLOWING LAZY CODE RELIES ON THE FACT THAT ALL KEYWORDS\n*---  START WITH UNIQUE LETTERS\n         CLI   0(R15),C'V'              VOLUME?\n         BE    SF$VOL                   YES - PROCESS IT\n         CLI   0(R15),C'P'              PASSWORD?\n         BE    SF$PSWD                  YES - PROCESS IT\n         L     R0,=C'SF1 '              SET LOGIC ERROR CODE\n         L     R15,=V(LOGICERR)         -> ROUTINE\n         BALR  R14,R15                  GO TO IT (NO RETURN)\nSF$KWNXT BXLE  R15,R0,SF$KEYLP          PROCESS ALL KEYWORDS\n         B     SF$GO                    ALL KEYWORDS NOW PROCESSED\n         SPACE 2\nSF$VOL   MVC   SF@VOL,8(R15)            SAVE VOLUME OPERAND\n*---  THIS IS ALWAYS OK, SINCE SPF IGNORES A BLANK VOLUME\n         CLI   SF@VOL+6,C' '            IS VOLSER TOO LONG?\n         BE    SF$KWNXT                 NO - PROCESS NEXT KEYWORD\n         MVC   QDPROMPT,QDREPLY         SET WHAT TO PROMPT\n         QTILT '*** VOLSER IS TOO LONG ***',OPTIONS=REPROMPT\n         SPACE 2\nSF$PSWD  MVC   SF@PSWD,8(R15)           SAVE PASSWORD OPERAND\n         LA    R1,SF@PSWD               POINT TO PSWD\n         ST    R1,SF@PARM3              SET INTO PARM LIST\n         OI    SF@PARM3,X'80'           MARK END OF PARM LIST\n         B     SF$KWNXT                 GO PROCESS NEXT KEYWORD\n         SPACE 2\nSF$GO    LA    R1,SF@VOL                POINT TO VOL\n         ST    R1,SF@PARM2              SET INTO PARM LIST\n         CLI   SF@PSWD,C' '             ANY PASSWORD GIVEN?\n         BNE   *+8                      YES - OK\n         OI    SF@PARM2,X'80'           MARK END OF PARM LIST\n         LH    R1,QCODEH                GET FUNCTION CODE (SEE PARSE)\n         B     *+4(R1)                  TO APPRORIATE RTN\n         B     SF$EDIT                  00 - EDIT\n         B     SF$BRWS                  04 - BROWSE\nSF$EDIT  LA    R0,=CL8'EDIT'            POINT TO SERVICE NAME\n         B     SF$LINK                  GO DO IT\nSF$BRWS  LA    R0,=CL8'BROWSE'          POINT TO SERVICE NAME\nSF$LINK  LINK  EPLOC=SF#ISPLK,MF=(E,SF@PARML),PARAM=((R0))\n         CH    R15,=H'4'                WAS IT 'NORMAL COMPLETION'\n         BNH   QSTOP                    YES - EXIT\n*--- GET SPF'S 'LONG' ERROR MSG FOR QTILT\n         MVC   SF@MSGLN,=A(L'QERRMSG)   SET LENGTH OF OUTPUT FIELD\n*                                       (SPF WILL CHANGE THIS FIELD)\n         SPACE 1\n         LINK  EPLOC=SF#ISPLK,MF=(E,SF@PARML),PARAM=(=CL8'VCOPY',      $\n               =CL8'ZERRLM',SF@MSGLN,QERRMSG,=CL8'MOVE'),VL=1\n         SPACE 1\n         QTILT *,OPTIONS=(REPROMPT,SET) SPF ERROR MSG TO SCREEN\n         SPACE 2\n         LTORG\n         SPACE 2\n         DROP  R13\n         SPACE 2\nSF#ISPLK DC    CL8'ISPLINK'             SPF INTERFACE MODULE NAME\nSF#CNTL  DC    CL8'CONTROL'             SPF SERVICE NAME\nSF#DISP  DC    CL8'DISPLAY'             CONTROL TYPE\nSF#REFR  DC    CL8'REFRESH'             REQUEST ENTIRE SCREEN REWRITE\n         SPACE 2\n         ENTRY SF#KEYS\nSF#KEYS  DC    CL8'VOL',CL8'VOLUME'\n         DC    CL8'PSWD',CL8'PASSWORD',CL8'PASS'\n         DC    X'FF'                    END OF TABLE INDICATOR\n         SPACE 3\nWORK     DSECT\n         ORG   WORK+72                  SKIP OVER REG SAVE AREA\n         SPACE 1\nSF@VOL   DS    CL8\nSF@PSWD  DS    CL8\n         SPACE 1\nSF@PARML DS    0A                       PARM LIST FOR ISPLINK CALL\nSF@SERVP DS    A                        -> SERVICE NAME\nSF@PARM1 DS    A                        -> 1ST PARM\nSF@PARM2 DS    A                        -> 2ND PARM\nSF@PARM3 DS    A                        -> 3RD PARM\nSF@PARM4 DS    A                        -> 4TH PARM\n         SPACE 1\nSF@MSGLN DS    A                        LENGTH OF ERR MSG TEXT\nSF@WORKL EQU   *-WORK\n         SPACE 2\n         LTORG ,\n         SPACE 3\n         QCOMMON\n         SPACE 3\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "Q#SL": {"ttr": 15112, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x0e\\x00\\x00\\x00\\x82#/\\x00\\x90\\x01\\x7f\\x01P\\x00\\x80\\x00=\\x00\\x00\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "05.14", "flags": 0, "createdate": "1982-08-20T00:00:00", "modifydate": "1990-01-17T01:50:00", "lines": 128, "newlines": 61, "modlines": 0, "user": "LDW"}, "text": "         TITLE '--- QUEUE--SYSLOG -- PRINT THE SYSTEM LOG DATASET ---'\n*---------------------------------------------------------------------*\n*                                                                     *\n*   SYSLOG - DISPLAY THE SYSTEM LOG                                   *\n*                                                                     *\n*   Updates:                                                          *\n*      17Jan90  LDW  Finish the SP311 Update (with EMS)               *\n*      26Apr89  EMS  Update for SP311                                 *\n*      20Feb88  LDW  Set Q3SYSLOG                                     *\n*                    Change default column number to 0                *\n*      21Mar87  LDW  Fix for DSID = 0 (from RSCS)                     *\n*      04/11/84 LDW  JCTDSECT -> JCTSTART                             *\n*      02/01/84 LDW  CHANGE STACK LEVEL FROM X'10' TO X'30' TO MAKE   *\n*                       IT SO THAT FIRST 'END' DOESN'T RETURN TO \"SL\" *\n*      01/19/84 LDW  ADD SUPPORT FOR COMMAND STACKING                 *\n*      07/19/83 LDW  SET QDHDSID                                      *\n*      03/21/83 LDW  IF FIRST OPERAND IS '*', CHANGE TO BLANKS        *\n*      02/01/83 LDW  DON'T SET QSC2SLOG IF SEARCHING BY JOBID         *\n*      01/19/83 LDW  USE QVSYSID TO POINT TO SYSTEM ID TABLE          *\n*                    SET QPOFFDEF                                     *\n*      01/03/83 LDW  SUPPORT M.A.S. SPOOL                             *\n*      12/20/82 LDW  CHANGE QTILT REPRMPT=YES TO OPTIONS=REPROMPT     *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 3\nSYSLOG   QSTART  Q21,STACK=X'30'\n         OI    QSCFLAG2,QSC2CKPT        FORCE CHECKPOINT REFRESH\n         L     R10,QVSYSID              -> SYSTEM ID TABLE\n         CLC   =CL8'SYSLOG',QPARM1      DID HE SAY 'SYSLOG'\n         BE    SL$CURNT                 YES - USE CURRENT SYSTEM ID\n         CLI   QPARM1,C'*'              WANT LAST REFERENCED SYSLOG?\n         BE    SL$USE                   YES - SEE IF WE CAN DO IT\n         CLI   QPARM1,C' '              ANY OPERAND?\n         BNE   SL$CHECK                 YES - USE IT\nSL$USE   CLC   QJOBNAME,=CL8'SYSLOG'    IS CURRENT JOB 'SYSLOG'?\n         BNE   SL$CURNT                 NO - GO SELECT CURRENT SYSLOG\n         MVC   QLNG1,=H'5'              YES - FAKE OUT LENGTH AND ...\n         MVC   QPARM1(1),QEXTJBID       ... JOBID TO RESELECT THE ...\n         MVC   QPARM1+1(4),QEXTJBID+4   ... PREVIOUSLY SELECTED SYSLOG\n         B     SL$FINDJ                 AND GO PROCESS IT\nSL$CURNT MVC   QPARM1,QBLANK            CLEAR THE PARM\n         MVC   QPARM1(4),0(R10)         NO - DEFAULT TO CURRENT SYSTEM\n         MVI   QLNG1+1,4                     SET LENGTH\nSL$CHECK CLI   QLNG1+1,4                PARM TOO LONG FOR SYSTEM ID?\n         BH    SL$FINDJ                 YES - ASSUME IT'S A JOB NUMBER\n         LA    R14,L'QSYSID(,R10)       -> SYSTEM ID #1\n         LA    R15,7                    NUMBER OF SYSTEM IDS\nSL$LOOP  CLC   QPARM1(4),0(R14)         IS THIS IT?\n         BE    SL$SIDOK                 YES\n         LA    R14,L'QSYSID(,R14)       -> NEXT SYSTEM ID\n         BCT   R15,SL$LOOP              KEEP LOOKING\n         B     SL$FINDJ                 NOT FOUND - ASSUME IT'S JOBID\nSL$SIDOK MVC   QPARM3(4),QPARM1         MOVE THE SYSTEM ID\n         MVC   QPARM1,=CL8'SYSLOG'      AND LOOK FOR SYSLOG BY NAME\n         MVI   QLNG1+1,6                SET LENGTH\n         OI    QSCFLAG2,QSC2SLOG        TELL FINDJOB \"SYSLOG BY NAME\"\n***********************************************************************\n*                                                                     *\n*   CALL FINDJOB TO LOCATE THE JQE, JCT, AND IOT                      *\n*                                                                     *\n***********************************************************************\nSL$FINDJ QCALL FINDJOB                  FIND THE JOB\n***********************************************************************\n*                                                                     *\n*   CHECK JOBNAME EQUAL SYSLOG                                        *\n*                                                                     *\n***********************************************************************\n         L     R9,QCJCTA                ADDR OF IOAREA FOR JCT\n         USING JCTSTART,R9              BASE REG FOR JCT\n         CLC   JCTJNAME,=CL8'SYSLOG'    IS THIS SYSLOG?\n         BNE   SL$TILT                  NO. TILT.\n***********************************************************************\n*                                                                     *\n*   DETERMINE NUMBER OF DATASETS FROM CURRENT DATASET                 *\n*                                                                     *\n***********************************************************************\n         MVC   QDHDSID,QPARM2           SET DSID FOR HEADER LINE\n          AIF  (&QLEVEL GE 9).SL01\n         LH    R3,JCTPDDBK              HIGHEST DATASET ID NUMBER\n          AGO  .SL02\n.SL01     ANOP ,\n         L     R3,JCTPDDBK              HIGHEST DATASET ID NUMBER\n.SL02     ANOP ,\n         LH    R1,QLNG2                 LENGTH OF BACKUP PARM\n         SH    R1,=H'1'                 IS THE BACKUP PARM ZERO LENGTH?\n         BM    SL$CALST                 YES. SKIP.\n         CLI   QPARM2,C'-'              IS THERE A MINUS SIGN?\n         BNE   *+8                      NO. SKIP.\n         MVI   QPARM2,C'0'              CHANGE MINUS TO ZERO\n         LA    R15,QPARM2               POINT TO PARM\n         BAL   R14,QNUMCONV             CONVERT IT\n         BNE   SL$TILT                  QUIT IF NOT NUMERIC\n         SR    R3,R15                   BACK UP NUMBER OF DATASETS\n         CH    R3,=H'101'               IS THE NUMBER LESS THAN 101?\n         BL    SL$TILT                  YES. TILT.\n***********************************************************************\n*                                                                     *\n*   CALL LISTDS TO LIST THE DATASET                                   *\n*                                                                     *\n***********************************************************************\n          AIF  (&QLEVEL GE 9).SL03\nSL$CALST STH   R3,QPDSID                STORE DATASET ID\n          AGO  .SL04\n.SL03     ANOP ,\nSL$CALST STCM  R3,B'1111',QPDSID        STORE DATASET ID\n.SL04     ANOP ,\n         OI    QFLAG2,Q2VALIDS          INDICATE VALIDITY FOR LISTDS\n         OI    QFLAG3,Q3SYSLOG          tell LISTDS it's SYSLOG\n*  Q3SYSLOG is reset by FINDJOB\n**       MVC   QPOFFSET,=H'5'           PRINT OFFSET (WAS ZERO)\n**       MVC   QPOFFDEF,=H'5'           AND SET DEFAULT\n         MVC   QPOFFSET,=H'0'           PRINT OFFSET\n         MVC   QPOFFDEF,=H'0'           AND SET DEFAULT\n         QCALL LISTDS\n         B     QSTOP\nSL$TILT  QTILT '*** INVALID PARAMETER ***',OPTIONS=REPROMPT\n***********************************************************************\n*                                                                     *\n*   MISCELLANY                                                        *\n*                                                                     *\n***********************************************************************\n         LTORG ,\n         SPACE 3\n         DROP  R9                       JCTSTART\n         SPACE 3\n         QCOMMON\n         SPACE 3\n         Q$JCT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "Q#SO": {"ttr": 15115, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x10\\x00\\x00\\x00\\x82#_\\x00\\x915O\")\\x01\\xa1\\x01W\\x00\\xab\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "05.16", "flags": 0, "createdate": "1982-08-23T00:00:00", "modifydate": "1991-12-20T22:29:00", "lines": 417, "newlines": 343, "modlines": 171, "user": "LDW"}, "text": "         TITLE '--- QUEUE--SYSOUT -- MANIPULATE SYSOUT ---'\n*---------------------------------------------------------------------*\n*                                                                     *\n*   SYSOUT - Provide requeue, cancel, and delete functions for held   *\n*            output                                                   *\n*                                                                     *\n*   Updates:                                                          *\n*      20Dec91  LDW  Check QM2RSCA before reissuing stacked command   *\n*      20Dec91  LDW  Integrate GLA fixes below:                       *\n*     (16Jul91) GLA  Reissue previously stacked command afterwards    *\n*      25Dec89  LDW  Q$xxx -> QZxxx:  CVT, JESCT, SSOB                *\n*      04Jun89  LDW  Use improved AUTHFUNC routine                    *\n*      04/25/84 LDW  DON'T STACK THESE SUBCOMMANDS                    *\n*      01/20/84 LDW  ADD SUPPORT FOR COMMAND STACKING                 *\n*      03/16/83 LDW  SUPPORT LINE COMMANDS                            *\n*      01/16/83 LDW  CALL APF SUBROUTINE                              *\n*                    DON'T SET Q1INQ1 OR Q1INQ2 ANYMORE               *\n*      01/10/83 LDW  ADD SUPPORT FOR \"MODE NOVERIFY\"                  *\n*                    ADD WORKLEN=                                     *\n*                    DO QTILT FOR SUCCESSFUL COMPLETION INSTEAD OF    *\n*                       SETTING \"RE-INVOKE LAST INQUIRY\" NOW THAT     *\n*                       QTILT DOESN'T CLEAR THE REST OF THE SCREEN    *\n*                    REMOVE ALL \",STOP\" FROM QTILT FOR SAME REASON    *\n*                    ADD REPROMPT=YES TO APPROPRIATE QTILT'S          *\n*      11/05/82 LDW  SET FLAG TO REQUEST DISPLAY OF SSREQ ERROR MSGS  *\n*      09/21/82 EMS  USE QPCLASS FOR DEFAULT, INSTEAD OF 'A'          *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 3\nSYSOUT   QSTART  Q26,WORKLEN=SO@WORKL   ,STACK=X'F0'\n         USING WORK,R13\n         MVC   VCLEAR,QBLANK\n         MVC   VCLEAR(3),=C'>>>'\n***********************************************************************\n*                                                                     *\n*   TEST AUTHORIZATION OF QUEUE                                       *\n*                                                                     *\n***********************************************************************\n          AIF   (&@@TMPSV).SOUT03\n         LA    R1,4                     get APF authorized\n         QCALL AUTHFUNC                 try it\n*---  RESET IT NOW, IN CASE WE DON'T GET BACK FROM FINDJOB OR      ---*\n*---  FROM VERIFY QUESTION                                         ---*\n         LA    R1,8                     SET ENTRY CODE = 8\n         QCALL AUTHFUNC                 RESET IT IF WE JUST GOT IT\n.SOUT03   ANOP\n***********************************************************************\n*                                                                     *\n*  CALL FINDJOB TO LOCATE THE JQE, JCT, AND IOT, VALIDITY CHK ACCESS  *\n*                                                                     *\n***********************************************************************\n         QCALL FINDJOB                  FIND JOB\n***********************************************************************\n*                                                                     *\n*   VALIDATE THE FUNCTION CODE                                        *\n*                                                                     *\n***********************************************************************\n         LH    R1,QCODEH                GET FUNCTION CODE\n         CH    R1,=H'8'                 ?/VALID FUNCTION CODE\n         BNH   *+8                      YES - CONTINUE\n         EX    0,*                      NO - STOP\n***********************************************************************\n*                                                                     *\n*   BRANCH TO THE APPROPRIATE PROCESSOR                               *\n*                                                                     *\n***********************************************************************\n         LA    R7,SSOBHDR               ADDR FOR SUBSYSTEM OPTION BLOCK\n         USING SSOB,R7\n         B     *+4(R1)\n         B     DELETE                   0   DELETE REQUEST\n         B     REQUEUE                  4   REQUEUE REQUEST\n         B     CANCEL                   8   CANCEL REQUEST\n***********************************************************************\n*                                                                     *\n*   PROCESS CANCEL REQUEST                                            *\n*                                                                     *\n***********************************************************************\nCANCEL   LA    R5,SSCSBGN               A(CANCEL PARAMETER LIST)\n         BAL   R6,INITSSOB              GO INITIALIZE THE SSOB.\n         MVC   SSOBFUNC,=AL2(SSOBCANC)  SET THE FUNCTION\n         XC    SSCSBGN(SSCSIZE),SSCSBGN CLEAR PARM LIST\n         MVC   SSCSLEN,=AL2(SSCSIZE)    SET LENGTH OF CANCEL PARM LIST\n          AIF   (NOT &@@TMPSV).SOUT04    SKIP IF WE DON'T HAVE TMPSRV\n         MVC   SO@CMD,=C'CANCEL'        THE TSO COMMAND TO USE\n.SOUT04   ANOP\n         CLI   QPARM2,C'P'              ?/PURGE THE OUTPUT\n         BNE   CAN010                   NO. DON'T SET THE FLAG\n         OI    SSCSFLGS,SSCSCOUT        YES\n         MVC   VACTION(5),QPARM2        COPY THE OPERAND\n          AIF   (NOT &@@TMPSV).SOUT05    SKIP IF WE DON'T HAVE TMPSRV\n         MVC   SO@OPRND(5),=C'PURGE'\n.SOUT05   ANOP\nCAN010   MVC   SSCSJOBN,QJOBNAME        JOBNAME\n         MVC   SSCSDIMP,=H'16'          SET SIZE OF RESULT ARRAY\n         MVC   VCMD(6),=C'CANCEL'       MOVE IN REQUESTED COMMAND\n         MVC   QACTION,=CL8'*CANCEL*'   ASSUME IT WILL WORK\n         BAL   R6,VERREQ                VERIFY THE REQUEST\n         IC    R1,QLOGONL               GET LENGTH OF LOGONID\n         BCTR  R1,0                     -1 FOR EX\n         EX    R1,CANCLC                CLC QLOGON(*-*),QJOBNAME\n         BE    CAN020                   HIS OWN JOB - NO WTO\n         MVC   SO@WTO(WTOCNCLL),WTOCNCL COPY PATTERN WTO\n         MVC   SO@WTO+4+4(7),QLOGON     MOVE IN TSO USERID\n         MVC   SO@WTO+4+16(6),=C'CANCEL'  MOVE COMMAND TO WTO\n         MVC   SO@WTO+4+23(8),QJOBNAME    MOVE JOBNAME TO WTO\n         SPACE 1\n         SR    R0,R0                    CLEAR FOR IC\n         IC    R0,QUCMID                GET CONSOLE ID\n         WTO   MF=(E,SO@WTO)            SO TELL THE OPERATOR\n         SPACE 2\nCAN020   MVC   SSCSJOBI,VJOBID          GET THE FIXED UP JOBID IF ANY\n         BAL   R6,CALLSSI               GO CALL SUBSYSTEM INTERFACE RTN\n         L     R1,SSOBRETN              GET RC FOR CANCEL FUNCTION\n         LTR   R1,R1                    OK?\n         BZ    SYSOUTOK                 YES - LEAVE\n         TM    QSCFLAG2,QSC2LINE        HERE VIA LINE COMMAND?\n         BO    SO$LC$RC                 YES - SET ERMSG INTO QACTION\n         OI    QFLAG1,Q1MVHDR           REQUEST MOVE ERMSG TO HDR\n         B     *(R1)\n         B     TILTNOJB                 4 -  JOBNAME NOT FOUND\n         B     TILTBADI                 8 -  INV JOBNAME/JOB ID COMB.\n         B     TILTNCAN                 12 - JOB NOT CANC'D - DUP JOBN\n         B     TILTMALL                 16 - STATUS ARRAY TOO SMALL\n         B     TILTOUTP                 20 - JOB NOT CAN'D - ON OUT Q\n         B     TILTYNTX                 24 - JOBID WITH INVALID SYNTAX\n         B     TILTICAN                 28 - INVALID CANCEL REQUEST\nCANCLC   CLC   QLOGON(*-*),QJOBNAME     << EXECUTED >>\n***********************************************************************\n*                                                                     *\n*   PROCESS REQUEUE REQUEST                                           *\n*                                                                     *\n***********************************************************************\nREQUEUE  LA    R5,SSSOBGN               A(REQUEUE SYSOUT PARM LIST)\n         BAL   R6,INITSSOB              GO INITIALIZE THE SSOB\n         MVC   SSOBFUNC,=AL2(SSOBSOUT)  INDICATE SYSOUT IS THE FUNCTION\n         XC    SSSOBGN(SSSOSIZE),SSSOBGN CLEAR PARM LIST\n         MVC   SSSOLEN,=AL2(SSSOSIZE)   SET LENGTH OF SYSOUT PARM LIST\n         OI    SSSOUFLG,SSSOSETC+SSSORLSE   USE SSSOCLAS AS DISP\n*                                       RELEASE ALL SELECTED DATA SETS\n         OI    SSSOFLG1,SSSOHLD+SSSOSJBN  INCLUDE HELD SYSOUT DATA SETS\n*                                       JOB NAME IS PRESENT\n         OI    SSSOFLG2,SSSOCTRL        PROCESSING COMPLETED\n         MVC   SSSOJOBN,QJOBNAME        JOBNAME\n         CLI   QPARM2,C' '              ANY NEWCLASS GIVEN?\n         BNE   *+10                     YES - SKIP\n         MVC   QPARM2(1),QPCLASS        NO - SET DEFAULT\n         MVC   SSSOCLAS,QPARM2          NEWCLASS\n         MVC   VCMD(7),=C'REQUEUE'      MOVE IN REQUESTED COMMAND\n         MVC   VACTION(11),=C'NEWCLASS( )'\n         MVC   VCLASS(1),QPARM2         MOVE IN CLASS NAME\n          AIF   (NOT &@@TMPSV).SOUT06    SKIP IF WE DON'T HAVE TMPSRV\n         MVC   SO@CMD,=C'OUTPUT'        THE TSO COMMAND TO USE\n         MVC   SO@OPRND(11),VACTION     OPERAND: \"NEWCLASS(?)\"\n.SOUT06   ANOP\n         MVC   QACTION,=CL8'*REQ''D*'   ASSUME IT WILL WORK\n         BAL   R6,VERREQ                VERIFY THE REQUEST\n         CLI   VJOBID,C' '              USE JOBID?\n         BE    SO$COMMN                 NO - SKIP\n         MVC   SSSOJOBI,VJOBID          JOB ID\n         OI    SSSOFLG1,SSSOSJBI        JOB ID IS PRESENT\nSO$COMMN BAL   R6,CALLSSI               GO CALL SUBSYSTEM INTERFACE RTN\n         L     R1,SSOBRETN              GET RC FOR SYSOUT FUNCTION\n         LTR   R1,R1                    OK?\n         BZ    SYSOUTOK                 YES - LEAVE\n         TM    QSCFLAG2,QSC2LINE        HERE VIA LINE COMMAND?\n         BO    SO$LC$RC                 YES - SET ERMSG INTO QACTION\n         OI    QFLAG1,Q1MVHDR           REQUEST MOVE ERMSG TO HDR\n         B     *(R1)\n         B     TILTEODS                 4 -  NO MORE DS TO SELECT\n         B     TILTNJOB                 8 -  JOB NOT FOUND\n         B     TILTINVA                 12 - INVALID SEARCH ARGUMENTS\n         B     TILTUNAV                 16 - UNABLE TO PROCESS NOW\n         B     TILTDUPJ                 20 - DUPLICATE JOB NAMES\n         B     TILTINVJ                 24 - INVALID JOBN/JOBID COMBO\n         B     TILTIDST                 28 - INVALID DEST SPECIFIED\n***********************************************************************\n*                                                                     *\n*   PROCESS DELETE  REQUEST                                           *\n*                                                                     *\n***********************************************************************\nDELETE   LA    R5,SSSOBGN               A(DELETE SYSOUT PARM LIST)\n         BAL   R6,INITSSOB              GO INITIALIZE THE SSOB\n         MVC   SSOBFUNC,=AL2(SSOBSOUT)  INDICATE SYSOUT IS THE FUNCTION\n         XC    SSSOBGN(SSSOSIZE),SSSOBGN CLEAR PARM LIST\n         MVC   SSSOLEN,=AL2(SSSOSIZE)   SET LENGTH OF SYSOUT PARM LIST\n          AIF   (NOT &@@TMPSV).SOUT07    SKIP IF WE DON'T HAVE TMPSRV\n         MVC   SO@CMD,=C'OUTPUT'        THE TSO COMMAND TO USE\n         MVC   SO@OPRND(6),=C'DELETE'   AND ITS OPERAND\n.SOUT07   ANOP\n         OI    SSSOUFLG,SSSODELC        INDICATE DELETE REQUEST\n         OI    SSSOFLG1,SSSOHLD+SSSOSJBN   SELECTION INCLUDES HELD DS\n*                                       JOB NAME PRESENT\n         OI    SSSOFLG2,SSSOCTRL        PROCESSING COMPLETED\n         MVC   SSSOJOBN,QJOBNAME        JOBNAME\n         MVC   VCMD(6),=C'DELETE'       MOVE IN REQUESTED COMMAND\n         MVC   QACTION,=CL8'*DEL''D*'   ASSUME IT WILL WORK\n         BAL   R6,VERREQ                VERIFY THE REQUEST\n         CLI   VJOBID,C' '              USE JOBID?\n         BE    SO$COMMN                 NO - SKIP\n         OI    SSSOFLG1,SSSOSJBI        JES2 JOB ID PRESENT\n         MVC   SSSOJOBI,VJOBID          JES2 JOBID\n         B     SO$COMMN                 GO CALL SUBSYSTEM INTERFACE RTN\n***********************************************************************\n*                                                                     *\n*   INITIALIZE THE SUBSYSTEM OPTION BLOCK (SSOB)                      *\n*                                                                     *\n*        R5 - ADDRESS OF FUNCTION PARM LIST                           *\n*        R6 - RETURN ADDRESS                                          *\n*        R7 - A(SSOB)                                                 *\n*                                                                     *\n***********************************************************************\nINITSSOB XC    SSOBEGIN(SSOBHSIZ),SSOBEGIN CLEAR THE SSOB\n         MVC   SSOBID,=C'SSOB'\n         MVC   SSOBLEN,=AL2(SSOBHSIZ)   LENGTH OF SSOB HEADER\n         ST    R5,SSOBINDV              FUNCTION DEPENDENT AREA PTR\n         ST    R7,SSOBPTR               SAVE ADDR OF SSOB\n         OI    SSOBPTR,X'80'            REQUIRED FOR IEFSSREQ INTERFACE\n          AIF   (NOT &@@TMPSV).SOUT08    SKIP IF WE DON'T HAVE TMPSRV\n         MVC   SO@CMD(SO@CMDL),QBLANK   BLANK THE TSO COMMAND AREA\n.SOUT08   ANOP\n         BR    R6\n***********************************************************************\n*                                                                     *\n*   REMOVE EMBEDDED BLANKS IN JES2 JOB ID                             *\n*                                                                     *\n***********************************************************************\nFIXJOBID LA    R8,5                     MAX LENGTH OF SCAN\n         LA    R5,3(,R5)                START LOCATION FOR SCAN\nFIX000   CLI   0(R5),C' '               ?/EMBEDDED BLANK\n         BNE   FIX010                   NO. CONTINUE WITH THE SCAN\n         MVI   0(R5),C'0'               YES. REPLACE WITH 0\nFIX010   LA    R5,1(,R5)                POINT TO NEXT BYTE\n         BCT   R8,FIX000                GO DO IT AGAIN\n         BR    R6                       ALL OVER. RETURN TO CALLER\n***********************************************************************\n*                                                                     *\n*   TELL THE USER WHAT HE IS ABOUT TO DO                              *\n*                                                                     *\n***********************************************************************\nVERREQ   MVC   VJOBNAME(8),QJOBNAME\n         MVC   VJOBID,QBLANK            CLEAR JOB ID\n         LA    R1,QDREPLY               -> REPLY\n         AH    R1,QOFF1                 -> OPERAND\n         CLI   0(R1),C'*'               PREVIOUS JOB?\n         BE    VERREQ1                  YES - USE JOBID\n         TM    QFLAG1,Q1JOBID           JOBNAME OR JOBID?\n         BNO   VERREQ2                  JOBNAME\nVERREQ1  LR    R2,R6                    SAVE RETURN ADDR\n         LA    R5,VJOBID                A(JES JOB ID)\n         BAL   R6,FIXJOBID              INSURE NO IMBEDDED BLANKS\n         LR    R6,R2                    RESTORE RETURN ADDR\n         MVI   VJOBID-1,C'('\n         MVC   VJOBID(8),QEXTJBID       (FROM JCTJOBID)\n         MVI   VJOBID+8,C')'\nVERREQ2  MVC   VWARN,=C'<<<  HIT ENTER IF OK OR RESPECIFY'\n         TM    QMODE1,QM1NOVFY          MODE NOVERIFY?\n         BNO   VERREQ3                  NO - CONTINUE\n         TM    QFLAG2,Q2OWNJOB          DOES USER OWN THIS JOB?\n         BO    VERREQ4                  YES - DON'T VERIFY WITH USER\nVERREQ3  MVC   QDHLINE,VCLEAR           MOVE IN THE \"HEADER\"\n         OI    QFLAG1,Q1MVHDR           REQUEST \"MOVE HEADER\"\n         OI    QFLAG2,Q2SHORT           WRITE ONLY FIRST 3 LINES\n         QCALL DISPLAY                  GO DISPLAY THE WARNING (NOW)\n*---  THE FOLLOWING IS NEEDED SO THAT THE VERIFY MESSAGE IS NOT    ---*\n*---  LEFT ON THE SCREEN WHEN LINE COMMAND PROCESS IS COMPLETED.   ---*\n         MVC   QDHLINE,QBLANK           CLEAR THE HEADER LINE\n         OI    QFLAG1,Q1MVHDR           REQUEST \"MOVE HEADER\"\nVERREQ4  LA    R1,4                     request APF authorization\n          AIF   (NOT &@@TMPSV).SOUT09\n         LNR   R1,R1                    make it conditional\n.SOUT09   ANOP\n         QCALL AUTHFUNC                 TRY TO GET APF AUTHORIZATION\n         LTR   R15,R15                  ARE WE APF AUTHORIZED?\n         BZR   R6                       YES - RETURN TO CALL JES2\n          AIF   (&@@TMPSV).SOUT11\n         EX    0,*                      SHOULDN'T BE ABLE TO GET HERE\n          AGO   .SOUT12\n.SOUT11   ANOP\n*---  NOT APF AUTHORIZED, USE TMPMAC TO CALL THE APPROPRIATE       ---*\n*---  TSO COMMAND TO PERFORM THE REQUESTED FUNCTION                ---*\n         MVC   SO@JOB(8),VJOBNAME       MOVE IN JOBNAME\n         LA    R1,SO@JOB                -> FIRST POSSIBLE POSITION\nVERREQ5  CLI   0(R1),C' '               FIND END?\n         BE    VERREQ6                  YES - MOVE IN JOBID, IF ANY\n         LA    R1,1(,R1)                -> NEXT POSITION\n         B     VERREQ5                  KEEP LOOKING\nVERREQ6  MVC   0(10,R1),VJOBID-1        MOVE IN \"(JOBNNNNN)\" IF ANY\n         SPACE 1\n         TMPMAC  CMD=(SO@CMD,SO@CMDL),MF=(E,SOTMPMAC)  EXEC TSO COMMAND\n         SPACE 1\n         B     SYSOUTOK                 ALL DONE HERE\n.SOUT12   ANOP\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*   INTERFACE TO THE SUBSYSTEM                                        *\n*                                                                     *\n***********************************************************************\n         PUSH  PRINT\n         PRINT GEN\n         SPACE 1\nCALLSSI  LA    R1,20                    get supervisor state\n         QCALL AUTHFUNC\n         SPACE 2\n         LA    R1,SSOBPTR               ADDR OF PTR TO SSOB\n         IEFSSREQ ,                     CALL THE SUBSYSTEM\n         SPACE 2\n         LR    R2,R15                   SAVE RETURN CODE\n         LA    R1,24                    return to problem state\n         QCALL AUTHFUNC\n         SPACE 2\n         POP   PRINT\n         LA    R1,8                     reset APF if we set it\n         QCALL AUTHFUNC\n         L     R1,SSOBRETN              GET FUNCTION RETURN CODE\n         LTR   R2,R2                    SUCCESSFUL?\n         BZR   R6                       YES - RETURN\n         TM    QSCFLAG2,QSC2LINE        HERE VIA LINE COMMAND?\n         BO    SO$LC$RC                 YES - SET ERMSG INTO QACTION\n         OI    QFLAG1,Q1MVHDR           REQUEST MOVE ERMSG TO HDR\n         B     *(R2)                    ... AND DECODE RESPONSE\n         B     TILTNSUP                 4 -  UNSUPPORTED SS FUNCTION\n         B     TILTNTUP                 8 -  SS EXIST, BUT IS NOT UP\n         B     TILTNOSS                 12 - SS DOES NOT EXIST\n         B     TILTDIST                 16 - FUNCTION NOT SUPPORTED\n         B     TILTLERR                 20 - LOGICAL ERROR\n***********************************************************************\n*                                                                     *\n*   TELL THE USER THAT IT WORKED                                      *\n*                                                                     *\n***********************************************************************\nSYSOUTOK TM    QSCFLAG2,QSC2LINE        HERE VIA LINE COMMAND?\n         BO    QSTOP                    YES - RETURN TO MAINLINE\n*                                       (MESSAGE IN QACTION)\n         TM    QMODE2,QM2RSCA           reissue stacked command?\n         BNZ   SO$RSCA                  yes - do it Guy's way...\n         QTILT '=== Requested operation successfully completed ==='\nSO$RSCA  QNEWCMD  STACK,MSG==CL79'=== Requested operation successfully $\n               completed ==='\nSO$LC$RC MVC   QACTION,=CL8'***RC\u00ac=0'   SET LINE CMD ERROR MSG\n         B     QSTOP                    AND RETURN TO MAINLINE\n***********************************************************************\n*                                                                     *\n*   ERROR MESSAGES                                                    *\n*                                                                     *\n***********************************************************************\nTILTMALL EQU   *\nTILTYNTX EQU   *\nTILTINVA EQU   *\nTILTUNAV EQU   *\nTILTIDST EQU   *\nTILTNSUP EQU   *\nTILTNOSS EQU   *\nTILTLERR EQU   *\nSOUTTILT MVC   QERRMSG(69),=C'*** QUEUE LOGIC ERROR -- IEFSSREQ RC=XXXX$\n               XXXX  SSOBRETN=XXXXXXXX  ***'\n         ST    R2,SOUTWORK              SET DOWN SSREQ RC\n         UNPK  QERRMSG+37(8+1),SOUTWORK(4+1)\n         TR    QERRMSG+37(8),QHEXTAB    MAKE IT DISPLAYABLE\n         MVI   QERRMSG+45,C' '          FIX FLIP BYTE\n         UNPK  QERRMSG+56(8+1),SSOBRETN(4+1)\n         TR    QERRMSG+56(8),QHEXTAB    MAKE IT DISPLAYABLE\n         MVI   QERRMSG+64,C' '          FIX FLIP BYTE\n         QTILT *\nTILTNTUP QTILT '*** JES2 IS NOT UP ***'\nTILTDIST QTILT '*** DISASTROUS ERROR DURING PROCESSING ***'\nTILTNOJB EQU   *\nTILTNJOB QTILT '*** JOBNAME NOT FOUND ***',OPTIONS=REPROMPT\nTILTBADI EQU   *\nTILTINVJ QTILT '*** INVALID JOBNAME/JOB ID COMBINATION ***'\nTILTNCAN EQU   *\nTILTDUPJ QTILT '*** DUPLICATE JOBNAME AND NO JOBID GIVEN ***',         $\n               OPTIONS=REPROMPT\nTILTEODS QTILT '*** JOB HAS NO HELD DATA SETS ***',OPTIONS=REPROMPT\nTILTICAN QTILT '*** CANNOT CANCEL YOUR TSO SESSION OR A STARTED TASK **$\n               *'\nTILTOUTP QTILT '*** JOB NOT CANCELLED - JOB ON OUTPUT QUEUE ***',      $\n               OPTIONS=REPROMPT\n***********************************************************************\n*                                                                     *\n*   MISCELLANEOUS NUTS, BOLTS, ETC.                                   *\n*                                                                     *\n***********************************************************************\n         DROP  R7,R13\n         LTORG\n         SPACE 3\nWTOCNCL  WTO   '*** USERIDX ==> CANCEL JOBNAMEX',MF=L,MCSFLAG=REG0\nWTOCNCLL EQU   *-WTOCNCL\n         QCOMMON\n         SPACE 3\nWORK     DSECT\n         ORG   WORK+72                  SKIP OVER SAVE AREA\nSOUTWORK DS    0F                       CONVERT WORK AREA\nSO@WTO   DS    0F,CL(WTOCNCLL)          WTO WORK AREA\nSSOBPTR  DS    F\nSSOBHDR  DS    CL140\n          AIF   (NOT &@@TMPSV).SOUT13    SKIP IF WE DON'T HAVE TMPSRV\nSOTMPMAC TMPMAC  MF=L\n         SPACE 1\nSO@CMD   DS    C'OUTPUT',C\nSO@JOB   DS    C'JOBNAMEX(JOBNNNNN)',C\nSO@OPRND DS    C'NEWCLASS(X)'\nSO@CMDL  EQU   *-SO@CMD\n.SOUT13   ANOP\nVCLEAR   DS    0CL(L'QDHLINE)\n         DS    CL4\nVCMD     DS    CL7,C\nVJOBNAME DS    CL8,C\nVJOBID   DS    CL8,2C\nVACTION  DS    CL11,4C\nVCLASS   EQU   VACTION+9\nVWARN    DS    CL33\nSO@WORKL EQU   *-WORK\n         SPACE 3\n         QZCVT\n         QZJESCT\n         QZSSOB\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "Q#SR": {"ttr": 15366, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x053\\x00\\x00\\x00\\x82#/\\x00\\x915O 8\\x066\\x02\\xf3\\x04\\xf1\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "05.51", "flags": 0, "createdate": "1982-08-20T00:00:00", "modifydate": "1991-12-20T20:38:00", "lines": 1590, "newlines": 755, "modlines": 1265, "user": "LDW"}, "text": "         TITLE '--- QUEUE--SEARCH -- JQE AND JOE SEARCH AND FORMAT ---'\n*---------------------------------------------------------------------*\n*                                                                     *\n*   SEARCH - Search for desired subset of JQE's and JOE's             *\n*                                                                     *\n*   Updates:                                                          *\n*      20Dec91  LDW  Integrate GLA fixes below:                       *\n*     (11Aug91) GLA  SP410 uses JOEUSER instead of JOEWTRID for       *\n*                       userid of DEST (ie. XMIT command).            *\n*      29Jun91  LDW  Fix for SP410 held output                        *\n*      24May91  LDW/EMS  SP410 fixes                                  *\n*      28Jan91  EMS  Update for SP410 (merged by LDW on 31Jan91)      *\n*      30Jan91  LDW  Retrofit GLA fixes below:                        *\n*     (15Jan91) GLA  Add support for new option to display OUTGRP     *\n*     (22Jun90) GLA  Add \"NJ\" command to display NJE queues           *\n*     (10Aug89) GLA  Search for both alias and true RJE id            *\n*     (12Jul89) GLA  Fix bug in DO display, length of dest not set    *\n*     (24Mar89) GLA  Expand DA to show all active jobs (inc output)   *\n*      23May90  LDW  Add USER (U) operand to most status commands     *\n*      25Dec89  LDW  Q$xxx -> QZxxx:  ACFJCB, ACFNJB, ACVALD, SSCT    *\n*      23Nov89  LDW  Remove conditional assembly around Qxxx macros   *\n*      09Jul89  LDW  Add PERCENT option for spool util of each job    *\n*      22Mar89  EMS  Update for SP311                                 *\n*      31Dec87  LDW  Re-install 19Aug87 update:                       *\n*                    Upper case the jobname before compare            *\n*      25Sep87  EMS  Allow wild char in dest parm '*'                 *\n*      08Apr87  LDW  Display only all output with wtrid if DO W=ALL   *\n*      25Jan87  LDW  Pass READSPC the JQE addr in case of CB ID error *\n*      16Jan87  LDW  Fix bug in STTEST wtrname check                  *\n*      12Jan87  LDW  SP1.3.6 updates                                  *\n*                    Remove \"LC\" macro usage                          *\n*      18OCT86  LDW  SUPPORT \"DO W=XXX\"                               *\n*                    HAVE \"STATUS\" ALSO CHECK FOR MATCH ON WTRID      *\n*      05OCT86  LDW  ADD 'WTRNAME'('W') KEYWORD TO \"DO\"/\"AO\"          *\n*      17SEP86  LDW  FIX SO 'DI *' CORRECTLY DISPLAYS \"I *\"           *\n*      08AUG86  EMS  FIX FOR ACF2 RELEASE PRE 4.1                     *\n*      22JUN86  LDW  FIX BUGS IN \"DO\" DISPLAY                         *\n*                    USE &@@ACF2 INSTEAD OF &QACF2                    *\n*                    UPDATE FOR ACF2 RELEASE 4.1                      *\n*      04/07/86 LDW  USE NEW COMMON LOGIC ERROR ROUTINE               *\n*      03/31/86 LDW  RE-DESIGN 3278-5 SUPPORT (THIRD TRY!)            *\n*      02/21/86 LDW  FIX JOE OUTPUT PRIORITY SELECTION FOR SP133      *\n*      11/14/85 LDW  FIX KEYWORD OPERAND ANALYSIS FOR DN,DH,DA,DS,DT  *\n*      12/05/84 LDW  ADD SYSAFF= (S=) SUPPORT TO DI/AI/HI ('S' ALIAS  *\n*                       OF 'SPACE' DELETED)                           *\n*                    SET QSC2DI FLAG FOR 'FORMAT'                     *\n*                    COMBINE DI/AI/HI ROUTINES INTO ONE ROUTINE       *\n*      06/25/84 LDW  DISPLAY 4 DIGITS IN ALL 'DQ' FIELDS              *\n*      04/17/84 LDW  CHECK FOR DEFAULT DEST BEING IN THE LOCAL        *\n*                       EQUIVALENCY TABLE, USE BLANKS IF SO           *\n*      04/11/84 LDW  JCTDSECT -> JCTSTART                             *\n*      04/10/84 LDW  SP133 UPDATES                                    *\n*      03/27/84 LDW  CHANGE ACF2 SUPPORT OF JES2 SP13 TO ACF2 R314    *\n*      01/19/84 LDW  ADD SUPPORT FOR COMMAND STACKING                 *\n*                    ADD SECOND BASE REG (SAY WHAT?)                  *\n*      01/01/84 LDW  ADD SUPPORT FOR &QJQEOWN FIELD                   *\n*      12/20/83 LDW  ADD SUPPORT FOR 'SPACE' KEYWORD                  *\n*      10/25/83 LDW  FIX ADDRESSIBILITY ERROR FOR NON-SP              *\n*      07/19/83 LDW  ADD SUPPORT FOR &QLCLEQ TABLE                    *\n*                    CHANGE USING/DROP TO USNGX/DROPX                 *\n*      03/04/83 LDW  ADD 'ALL' AND 'TIME' OPERANDS TO \"STATUS\"        *\n*      03/02/83 LDW  CHANGE 'QTILT *' TO USE QERRMSG                  *\n*      02/08/83 LDW  ELIMINATE \"DHX\" - NOW HANDLED BY \"DH /ALL\"       *\n*                    HAVE \"XJ\" SET QSC2DJX                            *\n*      02/02/83 LDW  FIX BUG IN HANDLING LIST OF REMOTE OUTPUT QUEUES *\n*      01/27/83 LDW  CORRECT QUEUE AND JOBNUMBER HANDLING FOR SP      *\n*                       (SET QCLSNAME TO DISPLAYABLE CLASS NAME)      *\n*      01/10/83 LDW  ADD SUMMARY (GRAND TOTAL) LINES IN \"DQ\"          *\n*                    FIX BUGS IN PREVIOUS UPDATE (RESTORE USE OF      *\n*                       \"QCOUNT\")                                     *\n*                    CHANGE SOME DATA TO LOWER CASE                   *\n*                    MISC OTHER CLEANUP                               *\n*      01/07/83 LDW  ADD SP SUPPORT                                   *\n*                    ADD SUPPORT FOR QSTDEFKY                         *\n*                    ADD WORKLEN=                                     *\n*                    DELETE SOME CODE WHICH BECAME SUPERFLUOUS        *\n*                    CHANGE HEADERS AND SOME DATA TO LOWER CASE       *\n*                    MOVE SOME COUNTERS FROM QCOMMON TO LOCAL:        *\n*                       QCOUNT -> SR@TOTAL, QCOUNTE -> SR@EXEC,       *\n*                       QCOUNTA -> SR@WAIT, QCOUNTH -> SR@HELD        *\n*      01/03/83 LDW  ADJUST TO USE MODIFIED $JQT MACRO                *\n*      12/17/82 LDW  ADD TSU AND STC QUEUES TO \"DQ\" DISPLAY           *\n*                    FIX BUG IN COUNTING MISC QUEUE JOBS WAITING EXEC *\n*                    ADD SUPPORT FOR RESERVED WORDS                   *\n*      12/14/82 LDW  ADD \"DN\" SUBCOMMAND TO DISPLAY *ALL* JOBS        *\n*                       (CHANGE \"DHX\" FROM CODE=52 TO 56, SINCE IT    *\n*                       WILL EVENTUALLY BE DELETED)                   *\n*      11/15/82 LDW  DON'T FORMAT FREE JQES ON THE PURGE QUEUE        *\n*      10/21/82 LDW  CHANGE \"HO\" TO \"DH\", \"XHO\" TO \"DHX\"              *\n*      08/26/82 LDW  DISPLAY ALL MISC QUEUES FOR ALL SUBCOMMANDS      *\n*                    COMPUTE QUEUE POSITION CORRECTLY FOR \"STATUS\"    *\n*                    FIX MINOR BUGS IN \"DQ\"                           *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 3\nSEARCH   QSTART  Q20,WORKLEN=SR@WORKL,STACK=X'01'\n         LA    R10,4095(,R12)           SET UP ...\n         LA    R10,1(,R10)              ... SECOND BASE\n         USNGX SEARCH+4096,R10          ARRRGH\n         QCALL CKPT                     READ CHECKPOINT DATA\n         QCALL DISP80                   SWITCH TO 3278-2 MODE IF 3278-5\n         USNGX JQEDSECT,R9              BASE REG FOR JQE DSECT\n         USNGX JOEDSECT,R8              BASE REG FOR JOE DSECT\n         USNGX WORK,R13                 BASE REG FOR LOCAL WORK AREA\n         MVC   SR@PARM1,QPARM1          SAVE CLASS LIST\n         MVI   SR@JQNUM,0               CLEAR TOP BYTE\n         MVI   SR@FLAG,0                INIT FLAGS\n         MVI   SR@AFF,0                 INIT AFFINITY MASK\n         MVC   SR@WTRID,QBLANK          CLEAR WTRNAME SAVE AREA\n***********************************************************************\n*                                                                     *\n*   BRANCH TO PROPER ROUTINE                                          *\n*                                                                     *\n***********************************************************************\n         LH    R1,QCODEH                LOAD FUNCTION CODE INTO R1\n         CH    R1,=H'56'                Is the function code ok?\n         BNH   *+8(R1)                  YES - BRANCH TO ROUTINE\n         EX    0,*                      NO - QUEUE LOGIC ERROR\n         B     ST                       0 OFFSET\n         B     DA                       4\n         B     DI                       8\n         B     DO                       12\n         B     AI                       16\n         B     AO                       20\n         B     HI                       24\n         B     DH  (FORMERLY, \"HO\")     28\n         B     DT                       32\n         B     DJ                       36  ALSO \"XJ\" COMMAND\n         B     DS                       40\n         B     DQ                       44\n         B     DEV                      48\n         B     DN                       52\n         B     NJ                       56\n***********************************************************************\n*                                                                     *\n*   DJ - FIND A SPECIFIC JOB                                          *\n*                                                                     *\n***********************************************************************\nDJ       MVC   QJOBID(2+8),QLNG1        SAVE JOBID & LENGTH\n         BAL   R2,SR$STUP               ANALYZE 'S','T','U','P' opernds\n         CLI   QKEYWORD,C'O'            want OUTGRP?\n         BNE   *+8                      No - skip\n         OI    QSCFLAG3,QSC3OUTG        indicate want OUTGRP\n         CLC   =C'XJ',QSUBNAME          IS THIS \"XJ\"?\n         BNE   DJ$01                    NO - SKIP\n         OI    QSCFLAG2,QSC2DJX         YES - SET FLAG FOR \"FORMAT\"\n         B     DJ$01                    USE THE STATUS ROUTINES\n***********************************************************************\n*                                                                     *\n*   STATUS - FIND ALL JOBS THAT MATCH LEVEL                           *\n*                                                                     *\n***********************************************************************\nST       CLI   SR@PARM1,C' '            DID USER SPECIFY LEVEL?\n         BNE   *+10                     YES - SKIP\n         MVC   SR@PARM1,QSTKEY          NO - USE LAST SEARCH KEY\n         CLC   =C'* ',SR@PARM1          SELF?\n         BNE   *+10                     NO - SKIP\n         MVC   SR@PARM1,QSTDEFKY        YES - GET DEFAULT SEARCH KEY\n         MVC   QSTKEY,SR@PARM1          SAVE SEARCH KEY\n*---  ANALYZE KEYWORDS                                             ---*\n         LA    R15,QKEYWORD             -> FIRST KEYWORD SLOT\n         LA    R0,16                    ENTRY LENGTH (BXLE INCR)\n         LA    R1,QKEYLAST              -> PAST LAST KEYWORD SLOT\n         SPACE 1\nST$KW$LP CLI   0(R15),C' '              ANY KEYWORD HERE?\n         BE    ST$KW$OK                 NO - DONE WITH KEYWORDS\n         CLI   0(R15),C'T'              WANT TIME INSTEAD OF CHARS?\n         BE    ST$TIME                  YES - GO SET FLAG\n         CLI   0(R15),C'U'              WANT userid INSTEAD OF rmt?\n         BE    ST$USER                  YES - GO SET FLAG\n         CLI   0(R15),C'P'              WANT percent INSTEAD OF LINES?\n         BE    ST$PCT                   YES - GO SET FLAG\n         CLI   0(R15),C'S'              WANT SPACE INSTEAD OF LINES?\n         BE    ST$SPACE                 YES - GO SET FLAG\n         CLI   0(R15),C'A'              WANT ALL JOBS FOR THIS USER?\n         BE    ST$ALL                   YES - GO SET FLAG\n         CLI   0(R15),C'O'              want OUTGRP?\n         BE    ST$OUTG                  yes - go set flag\n         L     R0,=C'SR1 '              SET LOGIC ERROR CODE\n         L     R15,=V(LOGICERR)         -> ROUTINE\n         BALR  R14,R15                  GO TO IT (NO RETURN)\nST$TIME  OI    QSCFLAG1,QSC1TIME        INDICATE WANT INP OR OUTP TIME\n         B     ST$KWNXT                 PROCESS NEXT KEYWORD\nST$USER  OI    QSCFLAG3,QSC3USER        INDICATE WANT userid\n         B     ST$KWNXT                 PROCESS NEXT KEYWORD\nST$PCT   OI    QSCFLAG1,QSC1PCT         INDICATE WANT SPOOL percent\n         B     ST$KWNXT                 PROCESS NEXT KEYWORD\nST$SPACE OI    QSCFLAG1,QSC1SPC         INDICATE WANT SPOOL SPACE\n         B     ST$KWNXT                 PROCESS NEXT KEYWORD\nST$ALL   OI    SR@FLAG,SR@FALLJ         INDICATE WANT ALL JOBS\n         B     ST$KWNXT                 PROCESS NEXT KEYWORD\nST$OUTG  OI    QSCFLAG3,QSC3OUTG        indicate want OUTGRP\n         B     ST$KWNXT                 process next keyword\nST$KWNXT BXLE  R15,R0,ST$KW$LP\nST$KW$OK EQU   *,4,C'I'\n***********************************************************************\n*  PREPARE SEARCH DATA                                                *\n***********************************************************************\nDJ$01    LA    R6,7                     MAXIMUM LENGTH OF 8\n         LA    R15,SR@PARM1+7           -> END OF FIELD\nDJ$02    CLI   0(R15),C' '              END OF SEARCH KEY?\n         BNE   DJ$03                    YES - HAVE LENGTH\n         BCTR  R15,0                    DECR LENGTH\n         BCT   R6,DJ$02                 TRY PREVIOUS BYTE\nDJ$03    LR    R1,R6                    GET LENGTH-1 OF PARM\n         ICM   R6,B'1100',=X'EFEF'      INVALIDATE JOBNO FOR NOW\n         CLI   QCODE,0                  IS THIS \"STATUS\"?\n         BE    ST$00                    YES - SKIP\n         LA    R15,SR@PARM1             GET ADDRESS OF PARM\n         IC    R4,SR@PARM1              SAVE FIRST CHARACTER IN CASE\n          AIF   (&QLEVEL GE 4).SR020\n         SR    R0,R0                    ASSUME 'J' - SET BASE\n         CLI   SR@PARM1,C'J'            IS IT?\n         BE    DJ$04                    YES\n         LH    R0,=H'10000'             ASSUME 'S' - SET BASE\n         CLI   SR@PARM1,C'S'            IS IT?\n         BE    DJ$04                    YES\n         AR    R0,R0                    ASSUME 'T' - SET BASE (20000)\n         CLI   SR@PARM1,C'T'            IS IT?\n         BE    DJ$04                    YES\n         SR    R0,R0                    NO - ASSUME NUMBER - RESET BASE\n         B     DJ$05                    CONTINUE\n          AGO   .SR040\n.SR020    ANOP\n         CLI   SR@PARM1,C'J'            IS IT JOB?\n         BE    DJ$04                    YES\n         CLI   SR@PARM1,C'S'            IS IT STC?\n         BE    DJ$04                    YES\n         CLI   SR@PARM1,C'T'            IS IT TSU?\n         BNE   DJ$05                    NO - ASSUME NAME OR PURE NUMBER\n.SR040    ANOP\nDJ$04    MVI   SR@PARM1,C'0'            CHANGE J/S/T TO '0'\nDJ$05    BAL   R14,QNUMCONV             CONVERT PARM TO BINARY\n         BNE   DJ$06                    SKIP IF NOT NUMERIC\n         LTR   R15,R15                  IS IT POSITIVE?\n         BNP   DJ$06                    NO - TRY JOBNAME\n         CH    R15,=H'9999'             IS IT IN RANGE?\n         BH    DJ$06                    NO - TRY JOBNAME\n          AIF   (&QLEVEL GE 4).SR060\n         AR    R15,R0                   ADD BASE\n.SR060    ANOP\n         SLL   R15,16                   SHIFT TO TOP HALFWORD\n         N     R6,=X'0000FFFF'          REMOVE FLAG\n         OR    R6,R15                   SAVE JOBNO IN R6(0:15)\n         B     DJ$07                    SKIP AROUND\nDJ$06    STC   R4,SR@PARM1              RESTORE FIRST CHAR OF JOBNAME\nDJ$07    CLI   QCODE,36                 DJ/XJ?\n         BNE   *+8                      NO - SKIP\n         IC    R6,=AL1(8-1)             YES - COMPARE FOR LENGTH OF 8\n         B     DEV                      SKIP AROUND 'DN' KEYWORD CODE\nDN       BAL   R2,SR$STUP               ANALYZE 'S','T','U','P' opernds\nST$00    EQU   *,4,C'I'\nDEV      L     R4,QCJQHEAD              -> FIRST MISC QUEUE HEADER\n         MVI   QCLASS,12                INDICATE THIS IS A MISC QUEUE\nDJ$11    BAL   R2,SRCHJQE               SEARCH THE QUEUE\n         B     DJ$12                    END OF QUEUE\n         CLI   JQETYPE,$FREE            IS THIS A FREE JQE?\n         BE    SKIPJQE                  YES - SKIP IT\n         BAL   R14,STTEST               SEE IF WE WANT THIS JOB\n         B     SKIPJQE                  NO. SKIP THIS RECORD.\n         B     PRTJQE                   YES - PRINT THE RECORD\nDJ$12    LA    R4,$JQHEADL(,R4)         -> NEXT QUEUE HEADER\n         L     R1,QCJQHEAD              -> JQT\n         LA    R0,JQTOUT-JQTDSECT(,R1)  -> HELD OUTPUT QUEUE HEADER\n         CR    R4,R0                    NOW POINTING AT HELD OUTPUT Q?\n         BNE   *+8                      NO - OK\n         LA    R4,$JQHEADL(,R4)         YES - SKIP THEM (WILL DO LATER)\n         LA    R0,JQTSTC-JQTDSECT(,R1)  -> FIRST NON-MISC QUEUE HEADER\n         CR    R4,R0                    DONE ALL MISC QUEUES?\n         BL    DJ$11                    NO - DO NEXT\n***********************************************************************\n* SEARCH THE TSO QUEUE                                                *\n***********************************************************************\n         L     R1,QCJQHEAD              LOAD ADDR OF JQT\n         LA    R4,JQTTSU-JQTDSECT(,R1)  ADDR OF TSO QUEUE\n         MVI   QCLASS,0                 INDICATE THIS IS THE TSO QUEUE\n         BAL   R2,SRCHJQE               SEARCH THE QUEUE\n         B     DJ$30                    END OF QUEUE\n         BAL   R14,STTEST               SEE IF WE WANT THIS JOB\n         B     SKIPJQE                  NO. SKIP THIS RECORD.\n         B     PRTJQE                   YES - PRINT THE RECORD\n***********************************************************************\n* SEARCH THE SYSTEM QUEUE                                             *\n***********************************************************************\nDJ$30    L     R1,QCJQHEAD              LOAD ADDR OF JQT\n         LA    R4,JQTSTC-JQTDSECT(,R1)  ADDR OF STC QUEUE\n         MVI   QCLASS,4                 INDICATE THIS IS THE STC QUEUE\n         BAL   R2,SRCHJQE               SEARCH THE QUEUE\n         B     DJ$40                    END OF QUEUE\n         BAL   R14,STTEST               SEE IF WE WANT THIS JOB\n         B     SKIPJQE                  NO. SKIP THIS RECORD.\n         B     PRTJQE                   YES - PRINT THE RECORD\n***********************************************************************\n*  SEARCH FOR HELD OUTPUT                                             *\n***********************************************************************\nDJ$40    MVI   QCLASS,8                 INDICATE THIS IS THE HELD OUT Q\n          AIF  (&QLEVEL GE 11).SR120\n         L     R1,QCJQHEAD              LOAD ADDR OF JQT\n         LA    R4,JQTOUT-JQTDSECT(,R1)  ADDR OF $OUTPUT QUEUE\n         BAL   R2,SRCHJQE               SEARCH THE QUEUE\n         B     ST$30                    END OF QUEUE\n*---  BOTH MIKE STEIN AND JACK SCHUDEL, WHEN THEY CHANGED THIS FOR ---*\n*---  SP JES2, DID IT WRONG (EACH IN THEIR OWN WAY)                ---*\n          AIF  (&QLEVEL GE 9).SR080\n         LH    R0,JQEHLDCT              GET HELD DATASET COUNT\n         N     R0,=X'0000FFF0'          GET RID OF JUNK\n         BZ    REJJQE                   REJECT IF NO HELD DATASETS\n          AGO  .SR100\n.SR080    ANOP ,\n         CLC   JQEHDSCT,=F'0'           check held dataset count\n         BE    REJJQE                   reject if no held datasets\n.SR100    ANOP ,\n         BAL   R14,STTEST               SEE IF WE WANT THIS JOB\n         B     SKIPJQE                  NO. COUNT & SKIP THIS RECORD.\n         B     PRTJQE                   PRINT THIS RECORD\n          AGO  .SR140\n.SR120    ANOP ,\n         L     R1,QCJOTA                load addr of JOT\n         LA    R4,JOTHOLDQ-JOTDSECT(,R1)  -> held output queue\n         BAL   R2,SRCHJOE               search the queue\n         B     ST$30                 +0 END OF QUEUE\n         BAL   R14,STTEST            +4 SEE IF WE WANT THIS JOB\n         B     SKIPJOE               +0 NO. SKIP THIS RECORD.\n         B     PRTJOE$H              +4 print the record\n.SR140    ANOP ,\n***********************************************************************\n*  SEARCH INPUT QUEUES                                                *\n***********************************************************************\nST$30    MVI   QCLASS,C'I'              INDICATE INPUT QUEUES\n         MVI   SR@JQCLS,0               START WITH FIRST INPUT CLASS\nST$40    BAL   R2,NEXTJQT               FIND NEXT QUEUE\n         BAL   R2,SRCHJQE               SEARCH THE QUEUE\n         B     ST$40                    END OF QUEUE\n         BAL   R14,STTEST               SEE IF WE WANT THIS JOB\n         B     SKIPJQE                  NO. SKIP THIS RECORD.\n         B     PRTJQE                   YES - PRINT THE JQE\n***********************************************************************\n*  SEARCH OUTPUT QUEUES                                               *\n***********************************************************************\nST$50    MVI   QCLASS,C'O'              INDICATE OUTPUT QUEUES\n         MVI   SR@JQCLS,0               START WITH FIRST OUTPUT CLASS\nST$60    BAL   R2,NEXTJOT               DETERMINE NEXT QUEUE\n         BAL   R2,SRCHJOE               SEARCH A JQE QUEUE\n         B     ST$60                    END OF QUEUE\n         BAL   R14,STTEST               SEE IF WE WANT THIS JOB\n         B     SKIPJOE                  NO. SKIP THIS RECORD.\n         B     PRTJOE                   YES - PRINT THE RECORD\n***********************************************************************\n*  SUBROUTINE TO DETERMINE IF THIS JOB IS INTERESTING.                *\n***********************************************************************\nSTTEST   CLI   QCODE,52                 IS THIS \"DN\"?\n         BE    4(,R14)                  YES - RETURN TO \"YES\"\n         CLI   QCODE,48                 IS THIS \"DEV\"?\n         BE    DEVTEST                  YES\n         CLM   R6,B'1100',JQEJOBNO      IS IT THE RIGHT JOB NUMBER?\n         BE    4(,R14)                  YES - RETURN TO \"YES\"\n         MVC   SR@JOBNM,JQEJNAME        copy jobname\n         OC    SR@JOBNM,QBLANK          upper case it\n         EX    R6,STCLC1                DOES NAME START WITH PREFIX?\n         BE    4(,R14)                  YES - RETURN TO \"YES\"\n         CLI   JQETYPE,$HARDCPY         IS THE JOB ON OUTPUT QUEUE?\n         BNE   SR$NO$W1                 NO - SKIP\n         CL    R8,=X'F0000000'          ANY JOE PTR?  (INVALIDATED)\n         BE    SR$NO$W1                 NO - SKIP\n         QNEXT R15,JOECHAR,NONE=SR$NO$W1  OFFSET TO CHARACTERISTICS JOE\n         AL    R15,QCJOTA               ADD BASE TO OFFSET\n         CLC   SR@PARM1,JOEWTRID-JOEDSECT(R15)  WTRNAME = SEARCH KEY?\n         BE    4(,R14)                  YES - RETURN TO \"YES\"\n          AIF   (&QLEVEL LT 11).SR160\n         CLC   SR@PARM1,JOEUSER-JOEDSECT(R15)  USER = SEARCH KEY?\n         BE    4(,R14)                  YES - RETURN TO \"YES\"\n.SR160    ANOP\nSR$NO$W1 EQU   *\n          AIF   ('&@@QJOWN' EQ '').SR180\n         EX    R6,STCLC5                SUBMITTOR'S ID START WITH PFX?\n         BE    4(,R14)                  YES - RETURN TO \"YES\"\n.SR180    ANOP\n         TM    SR@FLAG,SR@FALLJ         WANT ALL JOBS CHECKED?\n         BZR   R14                      NO - RETURN TO \"NO\"\n*---  READ THE JCT FOR THIS JOB.  NOTE:  THIS WILL EFFECTIVELY     ---*\n*---  CAUSE THE JCT FOR EVERY JOB IN THE SYSTEM TO BE READ...      ---*\n*---  (MANY, MANY I/O REQUESTS)                                    ---*\n         MVC   QCTRAK,JQETRAK           DISK ADDR OF JCT\n         L     R1,QCJCTA                -> IOAREA FOR JCT\n         MVC   QCCBID,=C'JCT '          SHOW WHAT WE WANT\n         LR    R3,R14                   PRESERVE RETURN ADDR\n         LR    R0,R9                    -> JQE\n         QCALL READSPC                  READ HASPACE\n         LR    R14,R3                   RESTORE RETURN ADDR\n         L     R1,QCJCTA                -> IOAREA FOR JCT\n         USNGX JCTSTART,R1\n         EX    R6,STCLC2                DOES NOTIFY START WITH PREFIX?\n         BE    4(,R14)                  YES - RETURN TO \"YES\"\n          AIF   (&@@ACF2 EQ 0).SR240\n         SPACE 2\n*---  LOCATE THE ACF2 USER SECTION IN THE NETWORK JOB HEADER       ---*\n*---  SEE ACF2.R314.ACFJES(ACF2X1) AT LABEL #ACFNJH1               ---*\n*---  OR SKK PRIVATE MACRO ACF2LNJS                                ---*\n         LH    R0,NJHLEN-NJHDSECT+JCTNJHDR  GET LENGTH OF NJH BLOCK\n         SH    R0,=H'4'                 ADJUST LENGTH FOR THE PREFIX\n         LA    R1,4+JCTNJHDR            -> FIRST SECTION\n         DROPX R1                       JCTSTART\n         USNGX NJHU,R1\n         SPACE 1\nSR$NJ$LP CLC   NJHUTYPE(6),SR#ACFID     IS THIS THE ACF2 USER SECTION?\n         BE    SR$ACF2                  YES - CONTINUE\n         SH    R0,NJHULEN               SUBTRACT LENGTH OF SECTION\n         AH    R1,NJHULEN               -> NEXT SECTION\n         LTR   R0,R0                    ANY MORE SECTIONS?\n         BP    SR$NJ$LP                 YES - CHECK NEXT\n         BR    R14                      NO - RETURN TO 'NO'\n         DROPX R1                       NJHU\n         SPACE 1\nSR$ACF2  LA    R1,ACFNJVLD-ACFNJBLK(,R1)  -> ACVALD BLK IN JCB\n         USNGX ACVALD,R1\n          AGO   .SR220\n          AIF   (&QLEVEL LT 4).SR200\n         ICM   R0,B'1111',&ACF2JCT      OFFSET OF ACF2 USER AREA\n         BZR   R14                      SKIP NEXT 2 TESTS IF NOT VALID\n*---  THE FOLLOWING IS A KLUDGE.  THE REAL NUMBER SHOULD BE        ---*\n*---  'BUFSTART-BUFDSECT', BUT IF I CODE A $BUFFER MACRO, IT WILL  ---*\n*---  MESS UP USAGE OF $HQT, $IOT, AND $JCT.  THIS WILL HAVE TO BE ---*\n*---  STRAIGHTENED OUT SOMETIME IN THE FUTURE, WHEN I FEEL LIKE IT.---*\n         AR    R1,R0\n         SH    R1,=Y(X'58')             -> ACF2 USER AREA\n         DROPX R1                       JCTSTART\n         USNGX #ACFJCTX,R1\n.SR200    ANOP\n         CLC   =C'ACFJ',JCTACFJ         IS IT ANY GOOD?\n         BNER  R14                      NO - SKIP\n.SR220    ANOP\n         EX    R6,STCLC3                DID JOB RUN ON THIS USER'S LID?\n         BE    4(,R14)                  YES - RETURN TO \"YES\"\n         EX    R6,STCLC4                DID USER SUBMIT THIS JOB?\n         BE    4(,R14)                  YES - RETURN TO \"YES\"\n         DROPX R1                       #ACFJCTX OR ACVALD\n         USNGX JCTSTART,R1              FOR EXECUTED CLC'S\n.SR240    ANOP\n         BR    R14                      NO - RETURN TO \"NO\"\n         SPACE 1\n*STCLC1  CLC   SR@PARM1(*-*),JQEJNAME   << EXECUTED >>\nSTCLC1   CLC   SR@PARM1(*-*),SR@JOBNM   << EXECUTED >>\nSTCLC2   CLC   SR@PARM1(*-*),JCTTSUID   << EXECUTED >>\n         DROPX R1                       JCTSTART\n          AIF   (&@@ACF2 EQ 0).SR280\n          AIF   (&QLEVEL GT 3).SR260\n         USNGX #ACFJCTX,R1\nSTCLC3   CLC   SR@PARM1(*-*),LIDLID     << EXECUTED >>\nSTCLC4   CLC   SR@PARM1(*-*),ACVSLID    << EXECUTED >>\n         DROPX R1                       #ACFJCTX\n          AGO   .SR280\n.SR260    ANOP\n         USNGX ACVALD,R1\nSTCLC3   CLC   SR@PARM1(*-*),ACVLID     << EXECUTED >>\nSTCLC4   CLC   SR@PARM1(*-*),ACVSLID    << EXECUTED >>\n         DROPX R1                       ACVALD\n.SR280    ANOP\n          AIF   ('&@@QJOWN' EQ '').SR300\nSTCLC5   CLC   SR@PARM1(*-*),&@@QJOWN   << EXECUTED >>\n.SR300    ANOP\n         SPACE 2\nDEVTEST  CLI   QCLASS,12                DOING MISC QUEUES?\n         BE    DEV$JQE                  YES\n         CLI   QCLASS,C'O'              DOING OUTPUT QUEUES?\n         BNER  R14                      \"NO\"\n         TM    JOEFLAG,$JOEBUSY         IS JOE ACTIVE?\n         BZR   R14                      \"NO\"\n         B     4(,R14)                  \"YES\"\nDEV$JQE  TM    JQETYPE,$INPUT           READING?\n         BNOR  R14                      \"NO\"\n         B     4(,R14)                  \"YES\"\n***********************************************************************\n*                                                                     *\n*   DQ - PRINT SUMMARY OF ALL JOBS IN THE INPUT/OUTPUT QUEUES         *\n*                                                                     *\n***********************************************************************\nDQ       MVC   QDHLINE,=C'  Queue Class  Total Jobs   # Exec/Print    #$\n                Waiting     # Held   Output Lines'\n         CLI   SR@PARM1,C'I'            INPUT QUEUES ONLY?\n         BE    DQI                      YES - SKIP MISC QUEUE DISPLAY\n         CLI   SR@PARM1,C'O'            OUTPUT QUEUES ONLY?\n         BE    DQO$00                   YES - SKIP INPUT QUEUE DISPLAY\n***********************************************************************\n*  SUMMARIZE THE MISCELLANEOUS QUEUES                                 *\n***********************************************************************\n         L     R4,QCJQHEAD              ADDR OF FIRST MISCELLANEOUS Q\n         LA    R7,SR#MISC\n         ZAP   SR@GRAND,=P'0'           INIT GRAND TOTALS\n         ZAP   SR@TEXEC,=P'0'           ...\n         ZAP   SR@TWAIT,=P'0'           ...\n         ZAP   SR@THELD,=P'0'           ...\nDQI$10   ZAP   SR@EXEC,=P'0'            ZERO COUNT FOR EXECUTING JOBS\n         ZAP   SR@WAIT,=P'0'            ZERO COUNT FOR AWAITING JOBS\n         ZAP   SR@HELD,=P'0'            ZERO COUNT FOR HELD JOBS\n          AIF  (&QLEVEL LT 11).SR320\n         CLC   SR#HOUT,0(R7)            PROCESSING HELD-OUTPUT?\n         BE    DQI$40                   yes - skip it - it'll be done  $\n                                           as an OUTPUT queue\n.SR320    ANOP\n         BAL   R2,SRCHJQE               SEARCH THE QUEUE\n         B     DQI$30                   END OF QUEUE\n          AIF  (&QLEVEL GE 11).SR360\n         CLC   SR#HOUT,0(R7)            PROCESSING HELD-OUTPUT?\n         BNE   DQI$11                   NO - SKIP FUNNY HELD-OUT TESTS\n         CLI   SR@PARM1,C'X'            X OPTION GIVEN?\n         BE    DQI$11                   YES - SKIP FUNNY HELD-OUT TESTS\n          AIF  (&QLEVEL GE 9).SR340\n         LH    R0,JQEHLDCT              GET HELD DATASET COUNT\n         N     R0,=X'0000FFF0'          GET RID OF JUNK\n         BZ    REJJQE                   IGNORE THE RECORD IF NONE HELD\n          AGO  .SR360\n.SR340    ANOP ,\n         CLC   JQEHDSCT,=F'0'           check held dataset count\n         BE    REJJQE                   ignore the record if none held\n.SR360    ANOP ,\nDQI$11   TM    JQEFLAGS,QUEBUSY         IS THIS JOB EXECUTING?\n         BZ    DQI$12                   NO, NEXT TEST\n         AP    SR@EXEC,=P'1'            YES, BUMP COUNTER\n         B     DQI$20                   NEXT TEST\nDQI$12   TM    JQEFLAGS,QUEHOLDA+QUEHOLD1+QUEHOLD2  IS THIS A HELD JOB?\n         BZ    DQI$20                   NO, NEXT TEST\n         AP    SR@HELD,=P'1'            YES, BUMP COUNTER\n         B     SKIPJQE                  PROCESS NEXT JQE\nDQI$20   TM    JQEFLAGS,QUEBUSY         IS THIS JOB EXECUTING?\n         BNZ   SKIPJQE                  YES - PROCESS NEXT JQE\n         AP    SR@WAIT,=P'1'            COUNT AN AWAITING EXECUTION JOB\n         B     SKIPJQE                  PROCESS NEXT JQE\nDQI$30   CP    QCOUNT,=P'0'             IS THIS QUEUE EMPTY?\n         BE    DQI$40                   YES, TRY THE NEXT QUEUE\n         MVC   SR@ATTR,=X'1D60'         SET OUTPUT, NORMAL\n         MVI   QDATRNUM+1,1             NUMBER OF ATTR BYTES IN LINE\n         MVC   CLSTYPE(L'SR#MISC),0(R7) SET QUEUE TYPE\n         BAL   R2,SR$COUNT              # JOBS EX, AW EX, # HELD, TOTAL\n         AP    SR@GRAND,QCOUNT          ACCUMULATE TOTAL JOBS IN QUEUE\n         AP    SR@TEXEC,SR@EXEC         ACCUMULATE JOBS EXECUTING\n         AP    SR@TWAIT,SR@WAIT         ACCUMULATE JOBS WAITING\n         AP    SR@THELD,SR@HELD         ACCUMULATE JOBS HELD\n         BAL   R14,QADDLINE             GO DISPLAY THIS LINE\nDQI$40   LA    R7,L'SR#MISC(,R7)        -> NEXT MISC QUEUE TYPE DESCR\n         LA    R4,$JQHEADL(,R4)         -> NEXT MISC QUEUE HEADER\n         L     R1,QCJQHEAD              LOAD ADDR OF JQT\n         LA    R0,JQTTSU-JQTDSECT(,R1)  -> LAST MISC QUEUE HEADER\n         CR    R4,R0                    DONE WITH MISC QUEUES?\n         BNH   DQI$10                   NO - DO NEXT\n         ZAP   QCOUNT,SR@GRAND          GRAND TOTAL JOBS IN QUEUE\n         ZAP   SR@EXEC,SR@TEXEC         TOTAL JOBS EXECUTING\n         ZAP   SR@WAIT,SR@TWAIT         TOTAL JOBS WAITING\n         ZAP   SR@HELD,SR@THELD         TOTAL JOBS HELD\n         MVC   SR@ATTR,=X'1DE8'         SET OUTPUT, BRIGHT\n         MVI   QDATRNUM+1,1             NUMBER OF ATTR BYTES IN LINE\n         MVC   CLSTYPE(10),=C'Total Misc'\n         BAL   R2,SR$COUNT              FORMAT TOTALS LINE\n         BAL   R14,QADDLINE             DISPLAY THIS LINE\n         BAL   R14,QADDLINE             PUT IN BLANK LINE\n         CLI   SR@PARM1,C'M'            MISC QUEUES ONLY?\n         BE    SPOOLUTL                 YES - GO DIRECTLY TO DISP %UTIL\n***********************************************************************\n*  SUMMARIZE ALL INPUT QUEUES                                         *\n***********************************************************************\nDQI      MVI   QCLASS,C'I'              INDICATE INPUT QUEUES\n         MVI   SR@JQCLS,0               START WITH FIRST INPUT CLASS\n         ZAP   SR@GRAND,=P'0'           INIT GRAND TOTALS\n         ZAP   SR@TEXEC,=P'0'           ...\n         ZAP   SR@TWAIT,=P'0'           ...\n         ZAP   SR@THELD,=P'0'           ...\nDQI$50   BAL   R2,NEXTJQT               FIND NEXT QUEUE\n         ZAP   SR@EXEC,=P'0'            ZERO COUNT FOR EXECUTING JOBS\n         ZAP   SR@WAIT,=P'0'            ZERO COUNT FOR AWAITING JOBS\n         ZAP   SR@HELD,=P'0'            ZERO COUNT FOR HELD JOBS\n         BAL   R2,SRCHJQE               SEARCH THE QUEUE\n         B     DQI$80                   END OF QUEUE\n         TM    JQEFLAGS,QUEBUSY         IS THIS JOB EXECUTING\n         BZ    DQI$60                   NO, NEXT TEST\n         AP    SR@EXEC,=P'1'            YES, BUMP COUNTER\n         B     SKIPJQE                  PROCESS NEXT JQE\nDQI$60   TM    JQEFLAGS,QUEHOLDA+QUEHOLD1+QUEHOLD2  IS THIS A HELD JOB?\n         BZ    DQI$70                   NO, NEXT TEST\n         AP    SR@HELD,=P'1'            YES, BUMP COUNTER\n         B     SKIPJQE                  PROCESS NEXT JQE\nDQI$70   TM    JQEFLAGS,QUEBUSY         IS THIS JOB AWAITING EXECUTION?\n         BNZ   SKIPJQE                  NO, PROCESS NEXT JQE\n         AP    SR@WAIT,=P'1'            YES, BUMP COUNTER\n         B     SKIPJQE                  PROCESS NEXT JQE\nDQI$80   CP    QCOUNT,=P'0'             IS THIS QUEUE EMPTY\n         BE    DQI$50                   YES, TRY THE NEXT QUEUE\n         MVC   SR@ATTR,=X'1D60'         SET OUTPUT, NORMAL\n         MVI   QDATRNUM+1,1             NUMBER OF ATTR BYTES IN LINE\n         MVC   CLSTYPE,=C'Input '       SET QUEUE TYPE\n         MVC   CLASS,QCLSNAME           MOVE IN QUEUE CLASS\n         BAL   R2,SR$COUNT              # JOBS EX, AW EX, # HELD, TOTAL\n         AP    SR@GRAND,QCOUNT          ACCUMULATE TOTAL JOBS IN QUEUE\n         AP    SR@TEXEC,SR@EXEC         ACCUMULATE JOBS EXECUTING\n         AP    SR@TWAIT,SR@WAIT         ACCUMULATE JOBS WAITING\n         AP    SR@THELD,SR@HELD         ACCUMULATE JOBS HELD\n         BAL   R14,QADDLINE             GO DISPLAY THIS LINE\n         B     DQI$50                   PROCESS THE NEXT QUEUE\nDQI$90   ZAP   QCOUNT,SR@GRAND          GRAND TOTAL JOBS IN QUEUE\n         ZAP   SR@EXEC,SR@TEXEC         TOTAL JOBS EXECUTING\n         ZAP   SR@WAIT,SR@TWAIT         TOTAL JOBS WAITING\n         ZAP   SR@HELD,SR@THELD         TOTAL JOBS HELD\n         MVC   SR@ATTR,=X'1DE8'         SET OUTPUT, BRIGHT\n         MVI   QDATRNUM+1,1             NUMBER OF ATTR BYTES IN LINE\n         MVC   CLSTYPE(11),=C'Total Input'\n         BAL   R2,SR$COUNT              FORMAT TOTALS LINE\n         BAL   R14,QADDLINE             DISPLAY THIS LINE\n***********************************************************************\n*                                                                     *\n*   DQ - PRINT SUMMARY OF ALL JOBS IN THE OUTPUT QUEUES               *\n*                                                                     *\n***********************************************************************\nDQO      BAL   R14,QADDLINE             YES - PUT IN BLANK LINE\n         CLI   SR@PARM1,C'I'            INPUT QUEUES ONLY?\n         BE    SPOOLUTL                 YES - SKIP OUTPUT QUEUE DISPLAY\nDQO$00   ZAP   SR@GRAND,=P'0'           INIT GRAND TOTALS\n         ZAP   SR@TEXEC,=P'0'           ...\n         ZAP   SR@TWAIT,=P'0'           ...\n         ZAP   SR@THELD,=P'0'           ...\n         XC    SR@LINES,SR@LINES        ...\n          AIF   (&QLEVEL LT 11).SR380\n         SR    R6,R6                    CLEAR LINE COUNT\n         ZAP   SR@EXEC,=P'0'            ZERO COUNT FOR JOBS PRINTING\n         ZAP   SR@WAIT,=P'0'            ZERO COUNT FOR AWAITING JOBS\n         ZAP   SR@HELD,=P'0'            ZERO COUNT FOR HELD JOBS\n         L     R1,QCJOTA                load addr of JOT\n         LA    R4,JOTHOLDQ-JOTDSECT(,R1)  -> held output queue\n         BAL   R2,SRCHJOE               SEARCH THE QUEUE\n         B     DQH$80                +0 END OF QUEUE\n         A     R6,JOERECCT           +4 ADD LINES FOR THIS ELEMENT\n         TM    JOEFLAG,$JOEPRT+$JOEPUN  IS JOB PRINTING OR PUNCHING?\n         BZ    DQH$20                   NO, SEE IF HELD\n         AP    SR@EXEC,=P'1'            YES, BUMP COUNTER\n         B     SKIPJOE                  PROCESS NEXT JOE\n***DQH$20 TM   JOEFLAG,$JOEHOLD         HELD?\nDQH$20   TM    JQEFLAGS,QUEHOLDA+QUEHOLD1+QUEHOLD2  HELD JOB?\n         BNZ   DQH$30                   YES - COUNT IT\n         AP    SR@WAIT,=P'1'            NO - COUNT 1 AVAILABLE\n         B     SKIPJOE                  PROCESS NEXT JOE\nDQH$30   AP    SR@HELD,=P'1'            COUNT 1 HELD\n         B     SKIPJOE                  PROECESS NEXT JOE\nDQH$80   CP    QCOUNT,=P'0'             QUEUE EMPTY?\n         BE    DQO$01                   yes - do normal output queues\n         MVC   SR@ATTR,=X'1D60'         SET OUTPUT, NORMAL\n         MVI   QDATRNUM+1,1             NUMBER OF ATTR BYTES IN LINE\n         MVC   CLSTYPE(11),=C'Held Output'\n         BAL   R2,SR$COUNT              # JOBS EX, AW EX, # HELD, TOTAL\n         MVC   QTLINES,=X'402020206B2020206B202120'\n         CVD   R6,QNUMWORK              CONVERT LINES IN THIS CLASS\n         ED    QTLINES,QNUMWORK+3\n         AP    SR@GRAND,QCOUNT          ACCUMULATE TOTAL JOBS IN QUEUE\n         AP    SR@TEXEC,SR@EXEC         ACCUMULATE JOBS EXECUTING\n         AP    SR@TWAIT,SR@WAIT         ACCUMULATE JOBS WAITING\n         AP    SR@THELD,SR@HELD         ACCUMULATE JOBS HELD\n         A     R6,SR@LINES              ACCUMULATE PRINT LINES\n         ST    R6,SR@LINES              ...\n         BAL   R14,QADDLINE             GO DISPLAY THIS LINE\n.SR380    ANOP\nDQO$01   MVI   QCLASS,C'O'              INDICATE OUTPUT QUEUES\n         MVI   SR@JQCLS,0               START WITH FIRST OUTPUT CLASS\nDQO$10   BAL   R2,NEXTJOT               FIND NEXT QUEUE\n         SR    R6,R6                    CLEAR LINE COUNT\n         ZAP   SR@EXEC,=P'0'            ZERO COUNT FOR JOBS PRINTING\n         ZAP   SR@WAIT,=P'0'            ZERO COUNT FOR AWAITING JOBS\n         ZAP   SR@HELD,=P'0'            ZERO COUNT FOR HELD JOBS\n         BAL   R2,SRCHJOE               SEARCH THE QUEUE\n         B     DQO$80                   END OF QUEUE\n         A     R6,JOERECCT              ADD LINES FOR THIS ELEMENT\n         TM    JOEFLAG,$JOEPRT+$JOEPUN  IS JOB PRINTING OR PUNCHING?\n         BZ    DQO$20                   NO, SEE IF HELD\n         AP    SR@EXEC,=P'1'            YES, BUMP COUNTER\n         B     SKIPJOE                  PROCESS NEXT JOE\n***DQO$20 TM   JOEFLAG,$JOEHOLD         HELD?\nDQO$20   TM    JQEFLAGS,QUEHOLDA+QUEHOLD1+QUEHOLD2  HELD JOB?\n         BNZ   DQO$30                   YES - COUNT IT\n         AP    SR@WAIT,=P'1'            NO - COUNT 1 AVAILABLE\n         B     SKIPJOE                  PROCESS NEXT JOE\nDQO$30   AP    SR@HELD,=P'1'            COUNT 1 HELD\n         B     SKIPJOE                  PROECESS NEXT JOE\nDQO$80   CP    QCOUNT,=P'0'             QUEUE EMPTY\n         BE    DQO$10                   YES, TRY THE NEXT QUEUE\n         MVC   SR@ATTR,=X'1D60'         SET OUTPUT, NORMAL\n         MVI   QDATRNUM+1,1             NUMBER OF ATTR BYTES IN LINE\n         MVC   CLSTYPE,=C'Output'       SET QUEUE TYPE\n         MVC   CLASS,QCLSNAME           MOVE IN QUEUE CLASS\n         BAL   R2,SR$COUNT              # JOBS EX, AW EX, # HELD, TOTAL\n         MVC   QTLINES,=X'402020206B2020206B202120'\n         CVD   R6,QNUMWORK              CONVERT LINES IN THIS CLASS\n         ED    QTLINES,QNUMWORK+3\n         AP    SR@GRAND,QCOUNT          ACCUMULATE TOTAL JOBS IN QUEUE\n         AP    SR@TEXEC,SR@EXEC         ACCUMULATE JOBS EXECUTING\n         AP    SR@TWAIT,SR@WAIT         ACCUMULATE JOBS WAITING\n         AP    SR@THELD,SR@HELD         ACCUMULATE JOBS HELD\n         A     R6,SR@LINES              ACCUMULATE PRINT LINES\n         ST    R6,SR@LINES              ...\n         BAL   R14,QADDLINE             GO DISPLAY THIS LINE\n         B     DQO$10                   PROCESS NEXT QUEUE\nSR$COUNT MVC   FTCOUNT,=X'402020202020' MOVE IN\n         ED    FTCOUNT,SR@EXEC               NUMBER OF JOBS\n         MVC   QECOUNT,FTCOUNT+2                       IN EXECUTION\n         MVC   FTCOUNT,=X'402020202020' MOVE IN\n         ED    FTCOUNT,SR@WAIT               NUMBER OF JOBS\n         MVC   QACOUNT,FTCOUNT+2                   AWAITING EXECUTION\n         MVC   FTCOUNT,=X'402020202020' MOVE IN\n         ED    FTCOUNT,SR@HELD               NUMBER OF JOBS\n         MVC   QHCOUNT,FTCOUNT+2                   IN HELD STATUS\n         MVC   FTCOUNT,=X'402020202020' MOVE IN TOTAL NUMBER OF JOBS\n         ED    FTCOUNT,QCOUNT                IN THIS QUEUE\n         BR    R2                       RETURN TO CALLER\nDQO$DONE ZAP   QCOUNT,SR@GRAND          GRAND TOTAL JOBS IN QUEUE\n         ZAP   SR@EXEC,SR@TEXEC         TOTAL JOBS EXECUTING\n         ZAP   SR@WAIT,SR@TWAIT         TOTAL JOBS WAITING\n         ZAP   SR@HELD,SR@THELD         TOTAL JOBS HELD\n         MVC   SR@ATTR,=X'1DE8'         SET OUTPUT, BRIGHT\n         MVI   QDATRNUM+1,1             NUMBER OF ATTR BYTES IN LINE\n         MVC   CLSTYPE(12),=C'Total Output'\n         BAL   R2,SR$COUNT              FORMAT TOTALS LINE\n         L     R6,SR@LINES              GET GRAND TOTAL OF PRINT LINES\n         MVC   QTLINES,=X'402020206B2020206B202120'\n         CVD   R6,QNUMWORK              CONVERT LINES IN THIS CLASS\n         ED    QTLINES,QNUMWORK+3\n         BAL   R14,QADDLINE             DISPLAY THIS LINE\n         BAL   R14,QADDLINE             PUT IN BLANK LINE\n***********************************************************************\n*                                                                     *\n*   FORMAT PERCENT SPOOL UTILIZATION                                  *\n*                                                                     *\n          AIF   (&QLEVEL GT 4).SR440\n*   (FIND THE SSVT FOR THE SELECTED SUBSYSTEM)                        *\n*                                                                     *\n***********************************************************************\nSPOOLUTL L     R2,QSSCT                 -> SSCT\n         LTR   R2,R2                    VALID SUBSYSTEM?\n         BZ    QSTOP                    NO - DON'T TRY FOR % UTIL\n          AIF  (&QLEVEL GE 9).SR400\n         L     R2,SSCTSSVT-SSCT(,R2)    -> SSVT\n         USNGX SSVT,R2\n          AGO  .SR420\n.SR400    ANOP ,\n         L     R2,SSCTSUS2-SSCT(,R2)    -> HCCT\n         USNGX HCCT,R2\n.SR420    ANOP ,\n         LTR   R2,R2                    IS IT UP?\n         BZ    QSTOP                    NO - DON'T TRY FOR % UTIL\n         L     R1,$SVTGALC              GET ALLOCATED TRACK GROUPS\n         MH    R1,=H'1000'              SCALE FOR PERCENT * 10\n         SR    R0,R0                    CLEAR FOR DIVIDE\n         D     R1-1,$SVTGTOT            DIVIDE BY TOTAL TRACK GROUPS\n         DROPX R2\n          AGO   .SR460\n.SR440    ANOP\n*                                                                     *\n***********************************************************************\nSPOOLUTL L     R2,QCJQTL                -> MASTER RECORD CHKPT AREA\n         USNGX $SAVEBEG,R2\n         L     R1,$TGALLOC              GET AVAIL TGS ALLOCATED\n         M     R1-1,=F'1000'            SCALE FOR %*10\n         D     R1-1,$TGTOTAL            DIVIDE BY TOTAL TGS AVAILABLE\n         DROPX R2                       $SAVEBEG\n.SR460    ANOP\n         CVD   R1,QNUMWORK              CONVERT TO PACKED\n         MVC   SR@ATTR,=X'1D60'         SET OUTPUT, NORMAL\n         CH    R1,=H'800'               < 80% ?\n         BL    *+8                      YES - OK\n         MVI   SR@ATTR+1,X'E8'          NO - SET OUTPUT, BRIGHT\n         MVC   QDMSG+16(PERCENTL),PERCENT  MOVE IN MESSAGE\n         ED    QDMSG+16(7),QNUMWORK+5   FILL IN PERCENT\n         MVI   QDATRNUM+1,2             NUMBER OF ATTR BYTES IN LINE\n         BAL   R14,QADDLINE             DISPLAY THE LINE\n         B     QSTOP                    ALL DONE\n***********************************************************************\n*                                                                     *\n*   DI - PRINT ALL JOBS IN INPUT QUEUES                               *\n*   AI - PRINT JOBS IN INPUT QUEUES THAT ARE AVAILABLE FOR SELECTION  *\n*   HI - PRINT JOBS IN INPUT QUEUES THAT ARE HELD                     *\n*                                                                     *\n***********************************************************************\nHI       OI    SR@FLAG,SR@FHI           REMEMBER IT'S \"HI\"\n         B     *+8                      SKIP NEXT INSTR\nAI       OI    SR@FLAG,SR@FAI           REMEMBER IT'S \"AI\"\nDI       OI    QSCFLAG2,QSC2DI          TELL 'FORMAT' IT'S DI/AI/HI\n         LA    R15,QKEYWORD             -> FIRST KEYWORD SLOT\n         LA    R0,16                    ENTRY LENGTH (BXLE INCR)\n         LA    R1,QKEYLAST              -> PAST LAST KEYWORD SLOT\n         SPACE 1\nDI$KW$LP CLI   0(R15),C' '              ANY KEYWORD HERE?\n         BE    DI$KW$OK                 NO - DONE WITH KEYWORDS\n         CLI   0(R15),C'T'              WANT TIME?\n         BE    DI$TIME                  YES - GO SET FLAG\n         CLI   0(R15),C'U'              WANT userid?\n         BE    DI$USER                  YES - GO SET FLAG\n         CLI   0(R15),C'P'              WANT percent?\n         BE    DI$PCT                   YES - GO SET FLAG\n         CLC   =C'SI',0(R15)            WANT SIZE?\n         BE    DI$SPACE                 YES - GO SET FLAG\n         CLC   =C'SP',0(R15)            WANT SPACE?\n         BE    DI$SPACE                 YES - GO SET FLAG\n         CLC   =C'S ',0(R15)            WANT SYSAFF?\n         BE    DI$SYSAF                 YES - GO SET FLAG & SAVE IT\n         CLC   =C'SY',0(R15)            WANT SYSAFF?\n         BE    DI$SYSAF                 YES - GO SET FLAG & SAVE IT\n         L     R0,=C'SR2 '              SET LOGIC ERROR CODE\n         L     R15,=V(LOGICERR)         -> ROUTINE\n         BALR  R14,R15                  GO TO IT (NO RETURN)\nDI$TIME  OI    QSCFLAG1,QSC1TIME        INDICATE WANT INP OR OUTP TIME\n         B     DI$KWNXT                 PROCESS NEXT KEYWORD\nDI$USER  OI    QSCFLAG3,QSC3USER        INDICATE WANT userid\n         B     DI$KWNXT                 PROCESS NEXT KEYWORD\nDI$PCT   OI    QSCFLAG1,QSC1PCT         INDICATE WANT spool pct OF JOB\n         B     DI$KWNXT                 PROCESS NEXT KEYWORD\nDI$SPACE OI    QSCFLAG1,QSC1SPC         INDICATE WANT QUEUE SIZE OF JOB\n         B     DI$KWNXT                 PROCESS NEXT KEYWORD\nDI$SYSAF CLI   8(R15),C' '              ANY OPERAND?\n         BE    DI$AFFER                 NO - ERROR\n         CLI   8+4+1(R15),C' '          HOW LONG?\n         BNE   DI$AFFER                 TOO LONG - ERROR\n         CLC   =C'IND ',8(R15)          INDEPENDENT MODE?\n         BE    DI$AFIND                 YES - SET FLAG\n         CLI   8(R15),C'*'              CURRENT SYSTEM?\n         BNE   *+10                     NO - SKIP\n         MVC   8(4,R15),QSMFID          YES - CHANGE TO CURRENT SMFID\n         LA    R14,1                    SET LOW BIT FOR SYSTEM#1\n         L     R4,QVSYSID               -> ZERO'TH SYSTEM ID\nDI$AFFLP LA    R4,8(,R4)                -> NEXT TABLE ENTRY\n         CLC   0(4,R4),8(R15)           IS THIS THE RIGHT ONE?\n         BE    DI$AFFOK                 YES - 'OR' IN THIS BIT\n         SLL   R14,1                    NEXT SYSTEM ID\n         CH    R14,=Y(X'80')            CHECKED ALL YET?\n         BL    DI$AFFLP                 NO - KEEP LOOKING\nDI$AFFER QTILT '*** INVALID SYSTEM AFFINITY SPECIFICATION ***',        $\n               OPTIONS=REPROMPT\n         B     DI$KWNXT                 PROCESS NEXT KEYWORD\nDI$AFIND OI    SR@FLAG,SR@FIND+SR@FAFF  INDICATE INDEPENDENT MODE JOBS\n         B     DI$KWNXT                 PROCESS NEXT KEYWORD\nDI$AFFOK STC   R14,SR@BYTE              SET DOWN BYTE\n         OC    SR@AFF,SR@BYTE           COMBINE WITH PREVIOUS BITS\n         OI    SR@FLAG,SR@FAFF          INDICATE SYSAFF SELECTION\nDI$KWNXT BXLE  R15,R0,DI$KW$LP\nDI$KW$OK CLI   SR@PARM1,C' '            DID USER SPECIFY CLASS?\n         BNE   DI$50                    YES. LIMIT TO ONE QUEUE.\n***********************************************************************\n*  SEARCH THE CONVERTER QUEUE                                         *\n***********************************************************************\n*  SHOULD WE SKIP THE CONVERTER QUEUE IF \"AI\"???\n         L     R1,QCJQHEAD              LOAD ADDR OF JQT\n         LA    R4,JQTCONV-JQTDSECT(,R1) ADDR OF CONVERTER QUEUE\n         MVI   QCLASS,12                INDICATE THIS IS THE CONVERTR Q\n         BAL   R2,SRCHJQE               SEARCH THE QUEUE\n         B     DI$20                    END OF QUEUE\n         B     PRTJQE                   PRINT THE RECORD\n***********************************************************************\n*  SEARCH ALL QUEUES                                                  *\n***********************************************************************\nDI$20    MVI   QCLASS,C'I'              INDICATE INPUT QUEUES\n         MVI   SR@JQCLS,0               START WITH FIRST INPUT CLASS\nDI$21    BAL   R2,NEXTJQT               DETERMINE NEXT QUEUE\n         BAL   R2,SRCHJQE               SEARCH A JQE QUEUE\n         B     DI$21                    END OF QUEUE\n         TM    SR@FLAG,SR@FAI+SR@FHI    \"AI\" OR \"HI\"?\n         BZ    PRTJQE                   NO, \"DI\" - PRINT THE RECORD\n         TM    SR@FLAG,SR@FAI           \"AI\"?\n         BO    SR$AI$10                 YES - SEE IF AVAILABLE JOB\n*  MUST BE \"HI\" -- SEE IF HELD JOB\n         TM    JQEFLAGS,QUEHOLDA+QUEHOLD1+QUEHOLD2  IS THE JOB HELD?\n         BZ    REJJQE                   NO. SKIP IT.\n         B     PRTJQE                   PRINT THE RECORD\n*  \"AI\" -- SEE IF AVAILABLE FOR SELECTION\nSR$AI$10 CLI   JQEFLAGS,0               IS THE JOB BUSY OR HELD?\n         BNE   REJJQE                   YES. SKIP IT.\n         B     PRTJQE                   PRINT THE RECORD\n***********************************************************************\n* SEARCH SPECIFIC QUEUES                                              *\n***********************************************************************\nDI$50    MVI   QCLASS,C'I'              INDICATE INPUT QUEUES\n         MVC   SR@JQCLS,SR@PARM1        USER SPECIFIED CLASS\n*  SHOULD WE SKIP THE CONVERTER QUEUE IF \"AI\"???\n         CLI   SR@PARM1,C'*'            WANT CONVERTER QUEUE?\n         BE    DI$60                    YES - DO IT\n         BAL   R2,FIRSTJQT              FIND QUEUE\nDI$70    BAL   R2,SRCHJQE               SEARCH THE QUEUE\n         B     DI$80                    END OF QUEUE\n         TM    SR@FLAG,SR@FAI+SR@FHI    \"AI\" OR \"HI\"?\n         BZ    PRTJQE                   NO, \"DI\" - PRINT THE RECORD\n         TM    SR@FLAG,SR@FAI           \"AI\"?\n         BO    SR$AI$20                 YES - SEE IF AVAILABLE JOB\n*  MUST BE \"HI\" -- SEE IF HELD JOB\n         TM    JQEFLAGS,QUEHOLDA+QUEHOLD1+QUEHOLD2  IS THE JOB HELD?\n         BZ    REJJQE                   NO. SKIP IT.\n         B     PRTJQE                   PRINT THE RECORD\n*  \"AI\" -- SEE IF AVAILABLE FOR SELECTION\nSR$AI$20 CLI   JQEFLAGS,0               IS THE JOB BUSY OR HELD?\n         BNE   REJJQE                   YES. SKIP IT.\n         B     PRTJQE                   PRINT THE RECORD\nDI$60    L     R1,QCJQHEAD              POINT TO JQT\n         LA    R4,JQTCONV-JQTDSECT(,R1) POINT TO CONVERTER QUEUE\n         MVI   QCLASS,12                INDICATE THIS IS THE CONVERTR Q\n         B     DI$70                    GO FORMAT THIS QUEUE\nDI$80    BAL   R2,NEXT$CLS              SELECT NEXT CLASS, IF ANY\n         B     DI$50                    THERE WAS A NEXT - PROCESS IT\n***********************************************************************\n*                                                                     *\n*   AO - PRINT AVAILABLE JOBS IN THE OUTPUT QUEUE FOR USER'S DEST     *\n*   DO - PRINT ALL       JOBS IN THE OUTPUT QUEUE FOR USER'S DEST     *\n*                                                                     *\n***********************************************************************\nDO       EQU   *,4,C'I'\nAO       MVC   SR@DEST,QDEST            DEFAULT DEST IS LOGON DEST\n         MVC   SR@DESTL,=Y(8-1)         len to compare\n         CLC   SR@DEST,=CL8'LOCAL'      \"LOCAL\"\n         BE    DO$LOCAL                 YES - MAKE IT BLANK\n         CLI   SR@DEST,X'00'            IS IT HEX ZEROES?\n         BNE   *+10                     NO - OK\n         MVC   SR@DEST,QBLANK           YES - CHANGE TO BLANKS\n*---  SEE IF DEFAULT NAME IS AN ALIAS FOR 'LOCAL'\n         L     R15,=A(SR#LOCAL)         -> LOCAL EQUIVALENCE TABLE\nDO$LCLCK CLI   0(R15),X'FF'             END OF TABLE?\n         BE    DO$KW$CK                 yes - use dest as is\n         CLC   SR@DEST,0(R15)           DEFAULT DEST IN TABLE?\n         BE    DO$LOCAL                 YES - CHANGE TO BLANKS\n         LA    R15,8(,R15)              -> NEXT TABLE ENTRY\n         B     DO$LCLCK                 SEARCH WHOLE TABLE\nDO$LOCAL MVC   SR@DEST,QBLANK           USE BLANK = LOCAL SEARCH DEST\n*---  ANALYZE KEYWORDS                                             ---*\nDO$KW$CK LA    R15,QKEYWORD             -> FIRST KEYWORD SLOT\n         LA    R0,16                    ENTRY LENGTH (BXLE INCR)\n         LA    R1,QKEYLAST              -> PAST LAST KEYWORD SLOT\n         SPACE 1\nDO$KW$LP CLI   0(R15),C' '              ANY KEYWORD HERE?\n         BE    DO$KW$OK                 NO - DONE WITH KEYWORDS\n         CLI   0(R15),C'W'              WANT WTRID INSTEAD OF FCB/UCS?\n         BE    DO$WTRID                 YES - GO SET FLAG\n         CLI   0(R15),C'F'              WANT FLASH INSTEAD OF NJE/RJE?\n         BE    DO$FLASH                 YES - GO SET FLAG\n         CLI   0(R15),C'T'              WANT O/P TIME INSTEAD OF CHARS?\n         BE    DO$TIME                  YES - GO SET FLAG\n         CLI   0(R15),C'U'              WANT userid instead of rmt?\n         BE    DO$USER                  YES - GO SET FLAG\n         CLI   0(R15),C'P'              WANT SPOOL pct INSTEAD OF LNES?\n         BE    DO$PCT                   YES - GO SET FLAG\n         CLI   0(R15),C'S'              WANT SPOOL SPC INSTEAD OF LNES?\n         BE    DO$SPACE                 YES - GO SET FLAG\n         CLI   0(R15),C'D'              WANT DIFFERENT DEST?\n         BE    DO$DEST                  YES - GO SAVE IT\n         CLI   0(R15),C'R'              WANT DIFFERENT DEST? (REMOTE)\n         BE    DO$DEST                  YES - GO SAVE IT\n         CLI   0(R15),C'O'              want OUTGRP?\n         BE    DO$OUTG                  yes - go save it\n         L     R0,=C'SR3 '              SET LOGIC ERROR CODE\n         L     R15,=V(LOGICERR)         -> ROUTINE\n         BALR  R14,R15                  GO TO IT (NO RETURN)\nDO$WTRID OI    QSCFLAG3,QSC3WTRI        INDICATE WANT WRITER NAME\n         MVC   SR@WTRID,8(R15)          SAVE WTRNAME IF ANY\n         CLC   =C'ALL ',SR@WTRID        Want all and only wtrid stuff?\n         BE    DO$KWNXT                 Yes - display it in \"FORMAT\"\n         CLC   SR@WTRID,QBLANK          ANY WTRNAME SPECIFICATION?\n         BE    DO$KWNXT                 NO - DO DISPLAY IT IN \"FORMAT\"\n         XI    QSCFLAG3,QSC3WTRI        YES - NO NEED TO DISPLAY\n         B     DO$KWNXT                 PROCESS NEXT KEYWORD\nDO$FLASH OI    QSCFLAG3,QSC3FLSH        INDICATE WANT FORMS FLASH\n         B     DO$KWNXT                 PROCESS NEXT KEYWORD\nDO$TIME  OI    QSCFLAG1,QSC1TIME        INDICATE WANT OUTPUT TIME\n         B     DO$KWNXT                 PROCESS NEXT KEYWORD\nDO$USER  OI    QSCFLAG3,QSC3USER        INDICATE WANT userid\n         B     DO$KWNXT                 PROCESS NEXT KEYWORD\nDO$PCT   OI    QSCFLAG1,QSC1PCT         INDICATE WANT SPOOL percent\n         B     DO$KWNXT                 PROCESS NEXT KEYWORD\nDO$SPACE OI    QSCFLAG1,QSC1SPC         INDICATE WANT SPOOL SPACE\n         B     DO$KWNXT                 PROCESS NEXT KEYWORD\nDO$DEST  MVC   SR@DEST,8(R15)           SAVE REMOTE VALUE\nDO$WC$CK LA    R14,SR@DEST+7            max len\n         LA    R4,8-1                   len to scan (can't be all wild)\nDO$WC$LP CLI   0(R14),C'*'              wild char?\n         BE    DO$WC$GT                 yes - got one\n         BCTR  R14,0                    -> prev char\n         BCT   R4,DO$WC$LP              check all chars\n         B     DO$KWNXT                 none - use full len\nDO$WC$GT BCTR  R4,0                     -1 for ex.\n         STH   R4,SR@DESTL              save len to compare\n         B     DO$KWNXT                 PROCESS NEXT KEYWORD\nDO$OUTG  OI    QSCFLAG3,QSC3OUTG        indicate want OUTGRP\n         B     DO$KWNXT                 process next keyword\nDO$KWNXT BXLE  R15,R0,DO$KW$LP\n*---  DETERMINE IF DISPLAY IS ALL CLASSES, OR SPECIFIC LIST\nDO$KW$OK CLI   SR@PARM1,C' '            DID USER SPECIFY CLASS?\n         BNE   AO$40                    YES. LIMIT TO ONE QUEUE.\n***********************************************************************\n* SEARCH ALL QUEUES                                                   *\n***********************************************************************\n         MVI   QCLASS,C'O'              INDICATE OUTPUT QUEUES\n         MVI   SR@JQCLS,0               START WITH FIRST OUTPUT CLASS\nAO$20    BAL   R2,NEXTJOT               DETERMINE NEXT QUEUE\n         BAL   R2,SRCHJOE               SEARCH A JOE QUEUE\n         B     AO$20                    END OF QUEUE\n         B     AO$70                    SEE IF WE WANT THIS JOB\n***********************************************************************\n* SEARCH SPECIFIC QUEUES                                              *\n***********************************************************************\nAO$40    MVI   QCLASS,C'O'              INDICATE OUTPUT QUEUES\n         MVC   SR@JQCLS,SR@PARM1        USER SPECIFIED CLASS\n         BAL   R2,FIRSTJOT              FIND QUEUE\nAO$42    BAL   R2,SRCHJOE               SEARCH THE QUEUE\n         B     AO$50                    END OF QUEUE\n         B     AO$70                    SEE IF WE WANT THIS JOB\n          AIF   (&QLEVEL GE 4).SR480\nAO$50    BAL   R2,NEXT$CLS              SELECT NEXT CLASS, IF ANY\n          AGO   .SR520\n.SR480    ANOP\nAO$50    CLI   QCLASS,C'R'              DID WE JUST SEARCH RMT QUEUE?\n         BE    AO$51                    YES - DO NEXT OUTPUT CLASS\n          AIF   (&QLEVEL LT 11).SR500\n         CLI   QCLASS,C'U'              did we just search user queue?\n         BE    AO$RMT                   yes - now do remote queue\n         MVI   QCLASS,C'U'              INDICATE user OUTPUT QUEUES\n         BAL   R2,NEXTJOT               ADVANCE TO user OUTPUT QUEUE\n         B     AO$42                    SEARCH THE QUEUE\nAO$RMT   EQU   *\n.SR500    ANOP\n         MVI   QCLASS,C'R'              INDICATE REMOTE OUTPUT QUEUES\n         BAL   R2,NEXTJOT               ADVANCE TO REMOTE OUTPUT QUEUE\n         B     AO$42                    SEARCH THE QUEUE\nAO$51    BAL   R2,NEXT$CLS              SELECT NEXT CLASS, IF ANY\n.SR520    ANOP\n         B     AO$40                    THERE WAS A NEXT - PROCESS IT\n***********************************************************************\n*---  COMMON ROUTINE FOR AI/DI/AO/DO TO SELECT NEXT CLASS          ---*\n***********************************************************************\nNEXT$CLS MVC   SR@PARM1(L'SR@PARM1-1),SR@PARM1+1  SET UP GET NEXT CLASS\n         MVI   SR@PARM1+L'SR@PARM1-1,C' ' CLEAR OPENED POSITION\n         CLI   SR@PARM1,C' '            ANY MORE CLASSES GIVEN?\n         BNER  R2                       YES - RETURN TO CALLER\n         B     QSTOP                    NO - ALL DONE\n***********************************************************************\n*---  COMMON ROUTINE FOR AO/DO ALL CLASSES AND AO/DO SINGLE CLASS  ---*\n***********************************************************************\nAO$70    CLI   QCODE,12                 \"DO\"?\n         BE    AO$80                    YES - SEE IF CORRECT DEST\n         TM    JQEFLAGS,QUEHOLDA+QUEHOLD1+QUEHOLD2  NO (\"AO\") - HELD?\n         BNZ   SKIPJOE                  YES - REJECT IT\n*                                       NO - SEE IF CORRECT DEST\n*---  SELECT ONLY JOBS FOR CORRECT WTRID, IF REQUESTED\nAO$80    CLC   SR@WTRID,QBLANK          SELECT BY WTRNAME?\n         BE    AO$82                    NO - SKIP\n         QNEXT R15,JOECHAR,NONE=SKIPJOE OFFSET TO CHARACTERISTICS JOE\n         AL    R15,QCJOTA               ADD BASE TO OFFSET\n         CLC   =C'ALL ',SR@WTRID        Want all writerid output only?\n         BNE   AO$81                    No - go check for correct wtrid\n         CLI   JOEWTRID-JOEDSECT(R15),C' '  Yes - any wtrid?\n         BE    SKIPJOE                  No - don't display this output\n         B     PRTJOE                   Yes - display this one\nAO$81    CLC   SR@WTRID,JOEWTRID-JOEDSECT(R15)  CORRECT WTRNAME?\n         BNE   SKIPJOE                  NO - DON'T DISPLAY IT\n*---  SELECT ONLY JOBS FOR THIS USER'S DEST, UNLESS HE SAID R=ALL\nAO$82    CLC   =C'ALL ',SR@DEST         WANT ALL DESTS?\n         BE    PRTJOE                   YES - DISPLAY THIS JOB\n         LA    R1,JOEROUT               -> OUTPUT ROUTE FIELD\n         QCALL FINDRJE                  CONVERT TO PRINTABLE\n         LH    R15,SR@DESTL             len to compare\n         CLC   0(*-*,R1),SR@DEST        IS THIS THE DEST HE WANTS?\n         EX    R15,*-6                  check it all\n         BE    PRTJOE                   YES - DISPLAY THIS JOB\n         CLC   8(*-*,R1),SR@DEST        how about NnnnRnnn form?\n         EX    R15,*-6                  check it all\n         BE    PRTJOE                   yes - display this job\n         CLI   SR@DEST,C' '             DOES HE WANT JOBS FOR CENTRAL?\n         BNE   SKIPJOE                  NO - DON'T DISPLAY THIS JOB\n*---  SEE IF THIS JOB HAS AN OUTPUT DESTINATION THAT IS EQU'D TO   ---*\n*---  CENTRAL ('LOCAL')                                            ---*\n         L     R15,=A(SR#LOCAL)         -> LOCAL EQUIVALENCE TABLE\nAO$90    CLI   0(R15),X'FF'             END OF TABLE?\n         BE    SKIPJOE                  YES - DON'T DISPLAY THIS JOB\n         CLC   0(8,R15),0(R1)           THIS JOBS DEST IN TABLE?\n         BE    PRTJOE                   YES - DISPLAY THIS JOB\n         LA    R15,8(,R15)              -> NEXT TABLE ENTRY\n         B     AO$90                    SEARCH WHOLE TABLE\n***********************************************************************\n*                                                                     *\n*   NJ - LIST ALL JOBS IN NJE QUEUES                                  *\n*                                                                     *\n***********************************************************************\nNJ       L     R1,QCJQHEAD              Load addr of JQT\n         LA    R4,JQTRECV-JQTDSECT(,R1) Addr of $RECEIVE Queue\n         MVI   QCLASS,12                Indicate this is misc Q\n         BAL   R2,SRCHJQE               Search the queue\n         B     NJ$10                    End of queue\n         B     PRTJQE                   Print the record\nNJ$10    L     R1,QCJQHEAD              Load addr of JQT\n         LA    R4,JQTXMIT-JQTDSECT(,R1) Addr of $RECEIVE Queue\n         MVI   QCLASS,12                Indicate this is misc Q\n         BAL   R2,SRCHJQE               Search the queue\n         B     QSTOP                    End of queue\n         B     PRTJQE                   Print the record\n***********************************************************************\n*                                                                     *\n*   DH - LIST ALL JOBS WITH HELD OUTPUT   (FORMERLY, \"HO\" SUBCMD)     *\n*                                                                     *\n***********************************************************************\nDH       BAL   R2,SR$STUP               ANALYZE 'S','T','U','P' opernds\n         LA    R1,QKEYWORD              -> FIRST KEYWORD SLOT\n         LA    R14,16                   BXLE INCR\n         LA    R15,QKEYLAST-16          BXLE END\nDH$01    CLI   0(R1),C' '               ANY MORE KEYWORDS?\n         BE    DH$02                    NO - CONTINUE\n         CLI   0(R1),C'A'               DISPLAY ALL JOBS?\n         BNE   *+8                      NO - SKIP\n         OI    SR@FLAG,SR@FHALL         YES\n         BXLE  R1,R14,DH$01             PROCESS ALL KEYWORDS\nDH$02    MVI   QCLASS,8                 indicate this is the held o/p q\n          AIF   (&QLEVEL GE 11).SR580\n         OI    QSCFLAG1,QSC1DH          INDICATE THIS IS \"DH\"\n         L     R1,QCJQHEAD              LOAD ADDR OF JQT\n         LA    R4,JQTOUT-JQTDSECT(,R1)  ADDR OF $OUTPUT QUEUE\n         BAL   R2,SRCHJQE               SEARCH THE QUEUE\n         B     QSTOP                    END OF QUEUE\n         TM    SR@FLAG,SR@FHALL         \"ALL\" KEYWORD GIVEN?\n         BO    PRTJQE                   YES. PRINT THE RECORD\n*---  BOTH MIKE STEIN AND JACK SCHUDEL, WHEN THEY CHANGED THIS FOR ---*\n*---  SP JES2, DID IT WRONG (EACH IN THEIR OWN WAY)                ---*\n          AIF  (&QLEVEL GE 11).SR560\n          AIF  (&QLEVEL GE 9).SR540\n         LH    R0,JQEHLDCT              GET HELD DATASET COUNT\n         N     R0,=X'0000FFF0'          GET RID OF JUNK\n         BNZ   PRTJQE                   PRINT THE REC IF HELD DATASETS\n          AGO  .SR560\n.SR540    ANOP ,\n         CLC   JQEHDSCT,=F'0'           check held dataset count\n         BNE   PRTJQE                   print the rec if held datasets\n.SR560    ANOP ,\n         B     REJJQE                   REJECT THE RECORD\n          AGO   .SR600\n.SR580    ANOP\n         L     R1,QCJOTA                load addr of JOT\n         LA    R4,JOTHOLDQ-JOTDSECT(,R1)  -> held output queue\n         BAL   R2,SRCHJOE               search the queue\n         B     QSTOP                 +0 end of queue\n         B     PRTJOE$H              +4 print the record\n.SR600    ANOP\n***********************************************************************\n*                                                                     *\n*   DA - FIND ALL EXECUTING JOBS                                      *\n*                                                                     *\n***********************************************************************\nDA       OI    QSCFLAG1,QSC1PGMR        REQUEST \"FORMAT\" TO DISP PGMR\n         BAL   R2,SR$STUP               ANALYZE 'S','T','U','P' opernds\n         MVI   QCLASS,C'I'              INDICATE INPUT QUEUES\n         MVI   SR@JQCLS,0               START WITH FIRST INPUT CLASS\nDA$20    BAL   R2,NEXTJQT               DETERMINE NEXT QUEUE\n         BAL   R2,SRCHJQE               SEARCH THE QUEUE\n         B     DA$20                    END OF QUEUE\n         TM    JQEFLAGS,QUEBUSY         IS THE JOB EXECUTING?\n         BNZ   PRTJQE                   yes - PRINT THE RECORD\n         CLI   JQETYPE,$INPUT           this job on input queue?\n         BE    PRTJQE                   yes - print the record\n         CLI   JQETYPE,$RECEIVE         this job on receive queue?\n         BE    PRTJQE                   yes - print the record\n         B     REJJQE                   NO. REJECT IT.\nDA$30    MVI   QCLASS,C'O'              INDICATE OUTPUT QUEUES\n         MVI   SR@JQCLS,0               START WITH FIRST OUTPUT CLASS\nDA$40    BAL   R2,NEXTJOT               DETERMINE NEXT QUEUE\n         BAL   R2,SRCHJOE               SEARCH A JOE QUEUE\n         B     DA$40                    END OF QUEUE\n         TM    JOEFLAG,$JOEBUSY         IS THE JOB EXECUTING?\n         BZ    SKIPJOE                  NO. REJECT IT.\n         B     PRTJOE                   PRINT THE RECORD\n***********************************************************************\n*                                                                     *\n*   DS - LIST ALL SYSTEM STARTED TASKS                                *\n*                                                                     *\n***********************************************************************\nDS       OI    QSCFLAG1,QSC1PGMR        REQUEST \"FORMAT\" TO DISP PGMR\n         BAL   R2,SR$STUP               ANALYZE 'S','T','U','P' opernds\n         L     R1,QCJQHEAD              LOAD ADDR OF JQT\n         LA    R4,JQTSTC-JQTDSECT(,R1)  ADDR OF STC QUEUE\n         MVI   QCLASS,4                 INDICATE THIS IS THE STC QUEUE\n         BAL   R2,SRCHJQE               SEARCH THE QUEUE\n         B     QSTOP                    END OF QUEUE\n         B     PRTJQE                   PRINT THE RECORD\n***********************************************************************\n*                                                                     *\n*   DT - LIST ALL TSO USERS                                           *\n*                                                                     *\n***********************************************************************\nDT       OI    QSCFLAG1,QSC1PGMR        REQUEST \"FORMAT\" TO DISP PGMR\n         BAL   R2,SR$STUP               ANALYZE 'S','T','U','P' opernds\n         L     R1,QCJQHEAD              LOAD ADDR OF JQT\n         LA    R4,JQTTSU-JQTDSECT(,R1)  ADDR OF TSO QUEUE\n         MVI   QCLASS,0                 INDICATE THIS IS THE TSO Q\n         BAL   R2,SRCHJQE               SEARCH THE QUEUE\n         B     QSTOP                    END OF QUEUE\n         B     PRTJQE                   PRINT THE RECORD\n***********************************************************************\n*                                                                     *\n*   ANALYZE 'S', 'T', 'U', and 'P' OPERANDS                           *\n*                                                                     *\n***********************************************************************\nSR$STUP  LA    R1,QKEYWORD              -> FIRST KEYWORD SLOT\n         LA    R14,16                   BXLE INCR\n         LA    R15,QKEYLAST-16          BXLE END\nSR$S$T$1 CLI   0(R1),C'T'               DISPLAY TIME?\n         BNE   *+8                      NO - SKIP\n         OI    QSCFLAG1,QSC1TIME        YES - SET FLAG FOR \"FORMAT\"\n         CLI   0(R1),C'U'               DISPLAY userid?\n         BNE   *+8                      NO - SKIP\n         OI    QSCFLAG3,QSC3USER        YES - SET FLAG FOR \"FORMAT\"\n         CLI   0(R1),C'P'               DISPLAY percent?\n         BNE   *+8                      NO - SKIP\n         OI    QSCFLAG1,QSC1PCT         YES - SET FLAG FOR \"FORMAT\"\n         CLI   0(R1),C'S'               DISPLAY SPACE?\n         BNE   *+8                      NO - SKIP\n         OI    QSCFLAG1,QSC1SPC         YES - SET FLAG FOR \"FORMAT\"\n         CLI   0(R1),C'O'               want OUTGRP?\n         BNE   *+8                      No - skip\n         OI    QSCFLAG3,QSC3OUTG        indicate want OUTGRP\n         BXLE  R1,R14,SR$S$T$1          PROCESS ALL KEYWORDS\n         BR    R2                       RETURN TO CALLER\n***********************************************************************\n*                                                                     *\n*   SEARCH A JQE QUEUE                                                *\n*                                                                     *\n***********************************************************************\nSRCHJQE  ZAP   QCOUNT,=P'0'             ZERO THE QUEUE COUNT\n         L     R8,=X'F0000000'          INVALIDATE JOE PTR\n         QNEXT R9,0(,R4)                LOAD FIRST JQE OFFSET\nNEXTJQE  BZR   R2                       END OF QUEUE. RETURN.\n         A     R9,QCJQTA                ADD BASE TO OFFSET\n         TM    QSCFLAG2,QSC2DI          IS THIS DI/AI/HI?\n         BZ    4(,R2)                   NO - DETERMINE ELIGIBILITY\n         TM    SR@FLAG,SR@FAFF          SYSAFF SELECTION DESIRED?\n         BZ    4(,R2)                   NO - DETERMINE ELIGIBILITY\n         MVC   SR@BYTE,JQEFLAG2         COPY JOB'S AFFINITY\n         NI    SR@BYTE,QUESYSAF         ISOLATE SYSAFF BITS\n         TM    SR@FLAG,SR@FIND          WANT INDEPENDENT MODE JOBS?\n         BNO   *+12     >==========+    NO - SKIP IND CHECK\n         TM    JQEFLAG2,QUEINDAF   |    YES - IS JOB INDEPENDENT MODE?\n         BNO   SKIPJQE             |    NO - SKIP IT\n         CLI   SR@AFF,0   <========+    ANY NON-IND AFFINITY SPECIFIED?\n         BZ    4(,R2)                   NO - DETERMINE ELIGIBILITY\n         NC    SR@BYTE,SR@AFF           COMPARE DESIRED WITH ACTUAL\n         BNZ   4(,R2)                   OK - DETERMINE ELIGIBILITY\n         B     SKIPJQE                  NONE OF THOSE SELECTED - SKIP\n         SPACE 3\nPRTJQE   AP    QCOUNT,=P'1'             INCREMENT COUNT\n         SR    R1,R1                    INDICATE THIS IS A JQE\n         QCALL FORMAT                   PRINT THE JQE IN R9\n         B     REJJQE                   CONTINUE\nSKIPJQE  AP    QCOUNT,=P'1'             INCREMENT COUNT\nREJJQE   L     R8,=X'F0000000'          INVALIDATE JOE PTR\n         QNEXT R9,JQENEXT               LOAD OFFSET TO NEXT JQE\n         B     NEXTJQE                  GET THE NEXT JQE\n***********************************************************************\n*                                                                     *\n*   SEARCH A JOE QUEUE                                                *\n*                                                                     *\n***********************************************************************\nSRCHJOE  ZAP   QCOUNT,=P'0'             ZERO THE QUEUE COUNT\nFIRSTJOE QNEXT R8,0(,R4)                LOAD FIRST JOE OFFSET\n         BZR   R2                       RETURN TO CALLER IF QUEUE EMPTY\n         XC    SR@PRTY(12),SR@PRTY      ZERO OUT HIGHEST POINTERS\nNEXTJOE  A     R8,QCJOTA                ADD BASE TO OFFSET\n         QNEXT R9,JOEJQE                OFFSET TO JQE\n         BZ    TRYJOE                   THIS JOE ALREADY USED. TRY NEXT\n         A     R9,QCJQTA                ADD BASE TO OFFSET\n          AIF   (&QLEVEL GT 4).SR620\n         LA    R7,255                   PRESET MAXIMUM PRIORITY\n         TM    JQEPRIO,240              IS THIS JOB PRIORITY 15?\n         BO    HIGHJOE                  YES. PASS TO CALLER.\n         LA    R1,16                    PRESET PRIORITY ONE\n         CLI   JQETYPE,$HARDCPY         IS THE JOB EXECUTING?\n         BNE   *+8                      YES. USE PRIORITY ONE.\n         IC    R1,JQEPRIO               INSERT JQE PRIORITY\n         IC    R7,JOEPRIO               INSERT JOE PRIORITY\n         AR    R7,R1                    ADD PRIORITIES\n         SRL   R7,1                     'CUZ HASP DOES IT, THAT'S WHY\n          AGO   .SR640\n.SR620    ANOP\n         LH    R7,JOEPRIO               GET NEW FORMAT JOE PRIORITY\n*??????? SRL   R7,4                     JUSTIFY IT CORRECTLY\n.SR640    ANOP\nHIGHJOE  C     R7,SR@PRTY               THIS LESS THAN PREVIOUS HIGH?\n         BL    TRYJOE                   YES. TRY NEXT ONE.\n         STM   R7,R9,SR@PRTY            NO. REPLACE PREVIOUS HIGH.\nTRYJOE   QNEXT R8,JOENEXT               ADDR OF NEXT JOE\n         BNZ   NEXTJOE                  TRY NEXT JOE\n*---  END OF QUEUE.  PASS HIGHEST TO CALLER                        ---*\n         LM    R7,R9,SR@PRTY            LOAD ADDR OF HIGHEST JOE\n         LTR   R8,R8                    WAS THE QUEUE EMPTY?\n         BZR   R2                       YES. END OF QUEUE.\n          AIF   (&QLEVEL GE 4).SR660\n         MVC   JOEJQE,=H'0'             INDICATE THIS JOE USED\n          AGO   .SR680\n.SR660    ANOP\n         MVC   JOEJQEB,=FL3'0'          INDICATE THIS JOE USED\n.SR680    ANOP\n         B     4(,R2)                   DETERMINE ELIGIBILITY\n          AIF   (&QLEVEL LT 11).SR700\nPRTJOE$H MVC   QCLSNAME(1),JOECURCL     set held o/p class name ...\n         MVI   QCLSNAME+1,C' '          ... for 'FORMAT'\n.SR700    ANOP\nPRTJOE   LA    R1,4                     INDICATE THIS IS A JOE\n         AP    QCOUNT,=P'1'             INCREMENT COUNT\n         QCALL FORMAT                   PRINT THE JOE IN R9\n         B     FIRSTJOE                 GET THE NEXT JOE\nSKIPJOE  AP    QCOUNT,=P'1'             INCREMENT COUNT\n         B     FIRSTJOE                 CONTINUE\n***********************************************************************\n*                                                                     *\n*   DETERMINE INPUT QUEUE                                             *\n*                                                                     *\n***********************************************************************\nFIRSTJQT IC    R15,SR@JQCLS             SAVE CLASS NAME IN CASE INVALID\n         TR    SR@JQCLS,CLASSTBL        DETERMINE CLASS NUMBER\n         LH    R4,SR@JQNUM              PICK IT UP\n         CLI   SR@JQCLS,X'FF'           INVALID CLASS SPECIFIED?\n         BNE   NEXTJQT1                 NO - CONTINUE\nBADCLASS MVC   QERRMSG(25),=C'*** CLASS ''?'' INVALID ***'\n         STC   R15,QERRMSG+11           FILL IN INVALID CLASS NAME\n         QTILT *,OPTIONS=REPROMPT\nNEXTJQT  LH    R4,SR@JQNUM              LOAD CLASS NUMBER\n         CH    R4,=H'36'                IS THIS THE LAST CLASS?\n         BNL   NEXTJQT9                 YES. GO HOME.\n         LA    R4,1(,R4)                INCREMENT TO NEXT CLASS\n         STH   R4,SR@JQNUM              SAVE NEW CLASS NUMBER\n         BCTR  R4,0                     MAKE IT ORIGIN 0\nNEXTJQT1 LA    R1,NAMETBL(R4)           -> PRINTABLE CLASS\n         MVC   QCLSNAME(1),0(R1)        AND CREATE DISPLAYABLE ...\n         MVI   QCLSNAME+1,C' '          ... CLASS NAME\n         MH    R4,=Y($JQHEADL)          MULTIPLY BY LENGTH OF Q HEADER\n         L     R1,QCJQHEAD              LOAD ADDR OF JQT\n         LA    R4,JQTCLSA-JQTDSECT(R4,R1)  NEXT QUEUE\n         BR    R2                       RETURN TO CALLER\n*%%% SOMEDAY, AFTER WE SUPPORT VARIABLE SIZE LOCAL WORKAREAS, CHANGE\n*%%% THE FOLLOWING KLUDGE TO USE A STORED RETURN ADDR\nNEXTJQT9 CLI   QCODE,0                  IS THIS A STATUS REQUEST?\n         BE    ST$50                    YES. GO TO STATUS.\n         CLI   QCODE,36                 IS THIS A DJ REQUEST?\n         BE    ST$50                    YES. GO TO STATUS.\n         CLI   QCODE,44                 IS THIS DQ?\n         BE    DQI$90                   YES - RETURN TO HIM\n         CLI   QCODE,48                 IS THIS DEV?\n         BE    ST$50                    YES - RETURN TO HIM\n         CLI   QCODE,52                 IS THIS DN?\n         BE    ST$50                    YES - RETURN TO HIM\n         CLI   QCODE,4                  IS THIS DA?\n         BE    DA$30                    YES - RETURN TO HIM\n         B     QSTOP                    NO. GO HOME.\n***********************************************************************\n*                                                                     *\n*   DETERMINE OUTPUT QUEUE                                            *\n*                                                                     *\n***********************************************************************\nFIRSTJOT IC    R15,SR@JQCLS             SAVE CLASS NAME IN CASE INVALID\n         TR    SR@JQCLS,CLASSTBL        DETERMINE CLASS NUMBER\n         LH    R4,SR@JQNUM              PICK IT UP\n         MH    R4,=Y(JOT@OQN)           account for queues per class\n         LA    R4,JOT@XQN(,R4)          account for dump & network q's\n         CLI   SR@JQCLS,X'FF'           INVALID CLASS SPECIFIED?\n         BNE   NEXTJOT1                 NO - PROCESS\n         B     BADCLASS                 YES - GIVE ERROR MESSAGE\nNEXTJOT  LH    R4,SR@JQNUM              LOAD CLASS NUMBER\n         CH    R4,=Y(JOT@XQN+36*JOT@OQN)  IS THIS THE LAST QUEUE?\n         BNL   NEXTJOT9                 YES - END LOOP\nNEXTJOT1 LA    R0,1(,R4)                INCREMENT\n         STH   R0,SR@JQNUM              SAVE UPDATED VALUE\n          AIF   (&QLEVEL GE 4).SR720\n         LA    R1,NAMETBL(R4)           -> PRINTABLE CLASS NAME\n         MVC   QCLSNAME(1),0(R1)        SET FOR 'FORMAT'\n         MVI   QCLSNAME+1,C' '          ...\n         MH    R4,=Y($JQHEADL)          MULTIPLY BY LENGTH OF Q HEADER\n         L     R1,QCJOTA                LOAD ADDR OF JOT\n         LA    R4,JOTCLSQ-JOTDSECT(R4,R1)  NEXT QUEUE\n          AGO   .SR740\n.SR720    ANOP\n         LR    R1,R4                    get relative queue number\n         AR    R1,R1                    output class names are 2 char\n         LA    R1,OUTCLASS(R1)          -> PRINTABLE CLASS NAME\n         MVC   QCLSNAME,0(R1)           SET FOR 'FORMAT'\n         MH    R4,=Y($JQHEADL)          MULTIPLY BY LENGTH OF Q HEADER\n         L     R1,QCJOTA                LOAD ADDR OF JOT\n         LA    R4,JOTRDYWQ-JOTDSECT(R4,R1)  NEXT QUEUE\n.SR740    ANOP\n         BR    R2                       RETURN TO CALLER\nNEXTJOT9 CLI   QCODE,44                 IS THIS DQ?\n         BE    DQO$DONE                 YES - SHOW SPOOL UTILIZATION\n         B     QSTOP                    NO - GO HOME.\n***********************************************************************\n*                                                                     *\n*   TABLES FOR CLASS DETERMINATION                                    *\n*                                                                     *\n***********************************************************************\nNAMETBL  DC    C'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'\n          AIF   (&QLEVEL GT 6).SR760\n          AIF   (&QLEVEL LT 4).SR820\nOUTCLASS DC    C'DP'                    DUMP QUEUE\n         DC    C'NT'                    NETWORK QUEUE\n          AGO   .SR780\n.SR760    ANOP\nOUTCLASS DC    C'NT'                    NETWORK QUEUE\n.SR780    ANOP\n*---  DISPLAY '>' AFTER CLASSNAME IF REMOTE OUTPUT QUEUE           ---*\n*---  IDEA COURTESY OF MIKE STEIN                                  ---*\n          AIF   (&QLEVEL GE 11).SR800\n         DC    C'A A>'                  LOCAL A, REMOTE A\n         DC    C'B B>C C>D D>E E>F F>G G>H H>I I>J J>K K>L L>M M>N N>'\n         DC    C'O O>P P>Q Q>R R>S S>T T>U U>V V>W W>X X>Y Y>Z Z>'\n         DC    C'0 0>1 1>2 2>3 3>4 4>5 5>6 6>7 7>8 8>9 9>'\n          AGO   .SR820\n.SR800    ANOP\n*---  DISPLAY '<' AFTER CLASSNAME IF user OUTPUT QUEUE             ---*\n         DC    C'A A<A>'                LOCAL A, user A, REMOTE A\n         DC    C'B B<B>C C<C>D D<D>E E<E>F F<F>G G<G>H H<H>I I<I>'\n         DC    C'J J<J>K K<K>L L<L>M M<M>N N<N>O O<O>P P<P>Q Q<Q>'\n         DC    C'R R<R>S S<S>T T<T>U U<U>V V<V>W W<W>X X<X>Y Y<Y>'\n         DC    C'Z Z<Z>0 0<0>1 1<1>2 2<2>3 3<3>4 4<4>5 5<5>6 6<6>'\n         DC    C'7 7<7>8 8<8>9 9<9>'\n.SR820    ANOP\nCLASSTBL DC    256X'FF'\n         ORG   CLASSTBL+C'A'\n         DC    AL1(00,01,02,03,04,05,06,07,08)\n         ORG   CLASSTBL+C'J'\n         DC    AL1(09,10,11,12,13,14,15,16,17)\n         ORG   CLASSTBL+C'S'\n         DC    AL1(18,19,20,21,22,23,24,25)\n         ORG   CLASSTBL+C'0'\n         DC    AL1(26,27,28,29,30,31,32,33,34,35)\n         ORG   ,\n***********************************************************************\n*                                                                     *\n*   MISCELLANEOUS GARBAGE                                             *\n*                                                                     *\n***********************************************************************\nSR#ACFID DC    B'11100000',B'00000001',C'ACF2'  TYPE, MOD, ID\n         SPACE 2\nSR#MISC  DC    CL9'Purge'\nSR#HOUT  DC    CL9'Held-Out'            $HARDCPY\n         DC    CL9'Await-Out'           $OUTPUT\n          AIF   (&QLEVEL GT 6).SRMISC1\n          AIF   (&QLEVEL LT 4).SRMISC1\n         DC    CL9'$DUMPQ'\n.SRMISC1  ANOP\n         DC    CL9'$RECEIVE'\n         DC    CL9'$SETUP'\n         DC    CL9'$XMIT'\n         DC    CL9'Reading'             $INPUT\n         DC    CL9'Converter'           $XEQ\n          AIF   (&QLEVEL GE 4).SRMISC2\n         DC    CL9'$DUMMY'\n.SRMISC2  ANOP\n         DC    CL9'SYS Tasks'\n         DC    CL9'TSO Users'\n         SPACE 2\nPERCENT  DC    X'40202021204B20',C'%'\n         DC    X'1D60'                  OUTPUT, NORMAL\n         DC    C'Spool Utilization'\nPERCENTL EQU   *-PERCENT\n         SPACE 2\n         LTORG\n         SPACE 2\n         ENTRY DA#KEYS,DI#KEYS,DO#KEYS,DH#KEYS,ST#KEYS,DN#KEYS,DJ#KEYS\n         SPACE 1\nDA#KEYS  DC    CL8'T       ',CL8'TIME    '\n          AIF   ('&@@QJOWN' EQ '').SRKEY1  USER not available\n         DC    CL8'U       ',CL8'USER    ',CL8'USERID  '\n.SRKEY1   ANOP\n         DC    CL8'P       ',CL8'PERCENT ',CL8'PCT     '\n         DC    CL8'S       ',CL8'SPACE   ',CL8'SIZE    '\n         DC    X'FF'                    END OF TABLE INDICATOR\n         SPACE 1\nDI#KEYS  DC    CL8'T       ',CL8'TIME    '\n          AIF   ('&@@QJOWN' EQ '').SRKEY2  USER not available\n         DC    CL8'U       ',CL8'USER    ',CL8'USERID  '\n.SRKEY2   ANOP\n         DC    CL8'P       ',CL8'PERCENT ',CL8'PCT     '\n         DC    CL8'SIZE    ',CL8'SPACE   '\n         DC    CL8'S       ',CL8'SYSAFF  '\n         DC    X'FF'                    END OF TABLE INDICATOR\n         SPACE 1\nDO#KEYS  DC    CL8'T       ',CL8'TIME    '\n          AIF   ('&@@QJOWN' EQ '').SRKEY3  USER not available\n         DC    CL8'U       ',CL8'USER    ',CL8'USERID  '\n.SRKEY3   ANOP\n         DC    CL8'P       ',CL8'PERCENT ',CL8'PCT     '\n         DC    CL8'S       ',CL8'SPACE   ',CL8'SIZE    '\n         DC    CL8'R       ',CL8'RMT     ',CL8'REMOTE  '\n         DC    CL8'D       ',CL8'DEST    '\n         DC    CL8'F       ',CL8'FLASH   '\n         DC    CL8'W       ',CL8'WTRNAME '\n         DC    CL8'O       ',CL8'OUT     '\n         DC    X'FF'                    END OF TABLE INDICATOR\n         SPACE 1\nDH#KEYS  DC    CL8'T       ',CL8'TIME    '\n          AIF   ('&@@QJOWN' EQ '').SRKEY4  USER not available\n         DC    CL8'U       ',CL8'USER    ',CL8'USERID  '\n.SRKEY4   ANOP\n         DC    CL8'P       ',CL8'PERCENT ',CL8'PCT     '\n         DC    CL8'S       ',CL8'SPACE   ',CL8'SIZE    '\n         DC    CL8'A       ',CL8'ALL     '\n         DC    X'FF'                    END OF TABLE INDICATOR\n         SPACE 1\nDN#KEYS  DC    CL8'T       ',CL8'TIME    '\n          AIF   ('&@@QJOWN' EQ '').SRKEY5  USER not available\n.SRKEY5   ANOP\n         DC    CL8'U       ',CL8'USER    ',CL8'USERID  '\n         DC    CL8'P       ',CL8'PERCENT ',CL8'PCT     '\n         DC    CL8'S       ',CL8'SPACE   ',CL8'SIZE    '\n         DC    CL8'O       ',CL8'OUT     '\n         DC    X'FF'                    END OF TABLE INDICATOR\n         SPACE 1\nST#KEYS  DC    CL8'T       ',CL8'TIME    '\n          AIF   ('&@@QJOWN' EQ '').SRKEY6  USER not available\n         DC    CL8'U       ',CL8'USER    ',CL8'USERID  '\n.SRKEY6   ANOP\n         DC    CL8'P       ',CL8'PERCENT ',CL8'PCT     '\n         DC    CL8'S       ',CL8'SPACE   ',CL8'SIZE    '\n         DC    CL8'A       ',CL8'ALL     '\n         DC    CL8'O       ',CL8'OUT     '\n         DC    X'FF'                    END OF TABLE INDICATOR\n         SPACE 1\nDJ#KEYS  DC    CL8'T       ',CL8'TIME    '\n          AIF   ('&@@QJOWN' EQ '').SRKEY7  USER not available\n         DC    CL8'U       ',CL8'USER    ',CL8'USERID  '\n.SRKEY7   ANOP\n         DC    CL8'S       ',CL8'SPACE   ',CL8'SIZE    '\n         DC    CL8'P       ',CL8'PERCENT ',CL8'PCT     '\n         DC    CL8'O       ',CL8'OUT     '\n         DC    X'FF'                    END OF TABLE INDICATOR\n         SPACE 2\nSR#LOCAL DS    0CL8                     LOCAL ROUTE EQUIVALENCE TABLE\n         @GLOBALC  QUEUE,LCLEQ\n         DC    X'FF'                    END OF TABLE INDICATOR\n         SPACE 2\nWORK     DSECT\n         ORG   WORK+72                  SKIP OVER SAVE AREA\nSR@PARM1 DS    CL8\nSR@DEST  DS    CL8\nSR@WTRID DS    CL8\nSR@LINES DS    F                        GRAND TOTAL LINES\nSR@DESTL DS    H                        len -1 to compare dest for\nSR@GRAND DS    PL3                      TOTAL NUMBER OF JOBS IN QUEUES\nSR@TEXEC DS    PL3                      TOTAL NUMBER OF JOBS EXEC\nSR@TWAIT DS    PL3                      TOTAL NBR OF JOBS WAITING\nSR@THELD DS    PL3                      TOTAL NUMBER OF JOBS HELD\n*   FIELD QCOUNT IN QCOMMON IS USED FOR TOTAL NUMBER OF JOBS / THIS Q\nSR@EXEC  DS    PL3                      NUMBER OF JOBS EXEC / THIS Q\nSR@WAIT  DS    PL3                      NBR OF JOBS WAITING / THIS Q\nSR@HELD  DS    PL3                      NUMBER OF JOBS HELD / THIS Q\nSR@AFF   DS    B                        AFFINITY MASK\nSR@FLAG  DS    B\nSR@FHALL EQU   X'80'                    'ALL' OPERAND GIVEN ON \"DH\"\nSR@FALLJ EQU   X'40'                    'ALL' OPERAND GIVEN ON \"ST\"\nSR@FAFF  EQU   X'20'                    SYSAFF= OPERAND ON DI/AI/HI\nSR@FIND  EQU   X'10'                    SYSAFF=IND SPECIFIED\nSR@FAI   EQU   X'02'                    SUBCOMMAND IS \"AI\"\nSR@FHI   EQU   X'01'                    SUBCOMMAND IS \"HI\"\nSR@JQNUM DS    0H,X                     CURRENT CLASS NUMBER\nSR@JQCLS DS    C                        USER SUPPLIED CLASS NAME\nSR@WORKL EQU   *-WORK\nSR@PRTY  DS    3F\nSR@JOBNM DS    CL8                      work area to upper case jobname\nSR@BYTE  DS    B\n         SPACE 3\n         DROPX R10,R9,R8,R13\n         SPACE 3\n         QCOMMON\n         ORG   QDMSG\nSR@ATTR  DS    XL2\n         DS    C\nCLSTYPE  DS    CL6\n         DS    CL2\nCLASS    DS    CL2\n         DS    CL4\nFTCOUNT  DS    CL6\n         DS    CL11\nQECOUNT  DS    CL4\n         DS    CL10\nQACOUNT  DS    CL4\n         DS    CL8\nQHCOUNT  DS    CL4\n         DS    CL4\nQTLINES  DS    CL12\n         SPACE 3\n         Q$JQE\n         Q$JOE\n         Q$JOT\n         Q$JQT\n         Q$SVT\n         Q$HCCT\n         Q$HCT\n         Q$JCT\n         Q$NHD\n         QZACFJCB\n         QZACFNJB  ,                    GEN ACFNJBLK\n         QZACVALD  ,                    GEN ACVALD\n         QZSSCT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "Q#SV": {"ttr": 16129, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x16\\x00\\x00\\x00\\x82#_\\x00\\x92\\x03?\\x13H\\x01\\xf7\\x00\\xad\\x01\\xcd\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "05.22", "flags": 0, "createdate": "1982-08-23T00:00:00", "modifydate": "1992-02-02T13:48:00", "lines": 503, "newlines": 173, "modlines": 461, "user": "LDW"}, "text": "         TITLE '--- QUEUE--SAVEDS -- CREATE A COPY OF CURRENT DS ---'\n*---------------------------------------------------------------------*\n*                                                                     *\n*   SAVEDS - CREATE A DISK COPY OF CURRENTLY SELECTED DATASET         *\n*                                                                     *\n*   Updates:                                                          *\n*      02Feb92  LDW  Free output dataset instead of just marking it   *\n*                       \"not in use\"                                  *\n*      03May91  LDW  Only compute output blksize if DISP=NEW          *\n*       7Aug90  LDW  Fix EMS's fix                                    *\n*       7Aug90  EMS  Fix 26Jun90 in a better fashion                  *\n*      26Jun90  LDW  Fix S0C9 when very large lrecl & small ds        *\n*      16Jun90  LDW  Run (mostly) in AMODE31 now                      *\n*      23Aug89  LDW  Fix for LRECL=0 (like internal text)             *\n*      05Sep88  LDW  Add BLKSIZE operand (ignored unless disp=NEW)    *\n*                    Add BLK to keyword table so it can be used       *\n*      13Aug88  LDW  Fix various bugs caused by error in 17Jan88 updt *\n*      17Jan88  LDW  Fix problems with space calculations due to use  *\n*                       of integer arithmetic without taking into     *\n*                       account roundoff errors                       *\n*                    Only compute space quantities for disp=NEW to    *\n*                       avoid DAIR rc=4 (invalid parmlist)            *\n*      11Aug87  EMS  Add CYL, TRK keywords (default to blocks)        *\n*      21Mar87  LDW  Fix for DSID = 0 (from RSCS)                     *\n*      04/22/86 LDW  MOVE ATTN FLAG FROM QTERMFLG TO QMISCFLG         *\n*      04/26/84 LDW  USE GETREC ROUTINE TO READ INPUT DATASET, TO     *\n*                       ALLOW IMPLEMENTATION OF SAVE RANGE            *\n*                    ADD PRI=, SEC=, AND DIR= KEYWORDS                *\n*                    ADD START= AND STOP= (END=) KEYWORDS             *\n*                    SHOW RECORD COUNT SAVED                          *\n*      01/23/84 LDW  ADD SUPPORT FOR COMMAND STACKING                 *\n*                    FIX PROCESSING OF DSNAMES LONGER THAN 8 CHARS    *\n*                    DISPLAY DSNAME IN 'SAVED' MESSAGE                *\n*                    FIX ATTENTION PROCESSING                         *\n*      03/18/83 LDW  CHANGE DISP AND NORLSE TO RESERVED WORDS         *\n*                    ADD VOL= AND UNIT= KEYWORDS                      *\n*                    REWRITE DSNAME LENGTH LOGIC                      *\n*      12/21/82 LDW  SET NEW FLAG \"QSC2ALNA\" TO TELL ALLOC NOT TO     *\n*                       ABEND IF UNABLE TO ALLOCATE                   *\n*      12/20/82 LDW  CHANGE QTILT REPRMPT=YES TO OPTIONS=REPROMPT     *\n*      12/10/82 LDW  PUT IN FREEPOOL FOR HASPSAVE DCB.  THIS WILL     *\n*                       CORRECT A POTENTIAL PROBLEM CAUSED BY UPDATE  *\n*                       DATED 11/11/82, WHICH REMOVED BUFL=8192       *\n*                    DON'T SET \"QSC2SAVE\" - ALLOC WILL KNOW IT'S ME   *\n*                    CHANGE NAME OF THIS CSECT TO \"SAVEDS\" TO AVOID   *\n*                       ASSEMBLY PROBLEMS WITH NJE                    *\n*      12/08/82 LDW  USE $LRC DSECT                                   *\n*                    SET NEW FLAG \"QSC2SAVE\" SO \"ALLOC\" KNOWS IT'S ME *\n*      11/11/82 EMS  ALLOW FULLY QUALIFIED DATASET NAME               *\n*                    USE IHADCB SYMBOLS                               *\n*                    HANDLE RECFM=VB OUTPUT DATASET                   *\n*                    INSTALL DCB EXIT TO DO THINGS RIGHT              *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 3\nSAVEDS   QSTART  Q19,WORKLEN=SV@WORKL,STACK=X'F0'\n         USNGX WORK,R13                 LOCAL WORK AREA\n***********************************************************************\n*                                                                     *\n*   ALLOCATE OUTPUT DATASET                                           *\n*                                                                     *\n***********************************************************************\n*%%%     CLC   QPDSID,=H'0'             IS THERE A VALID DATASET?\n*%%%     BE    SV$TILT1                 NO. TELL THE USER.\n         TM    QFLAG2,Q2VALIDS          IS THERE A VALID DATASET?\n         BZ    SV$TILT1                 NO. TELL THE USER.\n         MVC   DSNAME+2(44),QBLANK      BLANK THE DSNAME\n         LA    R1,DSNAME                -> TEXT UNIT\n         ST    R1,DA08PDSN              SAVE IN DAIR PARM LIST\n**%%     MVC   SV@BLKSZ,=F'6233'        assume 1/3 3350\n         XC    SV@BLKSZ,SV@BLKSZ        initialize output blksize\n         LH    R2,QOFF1                 OFFSET OF DSNAME\n         LTR   R2,R2                    ANY OPERAND?\n         BZ    SV$TILT3                 NO - ERROR\n         LA    R2,QDREPLY(R2)           -> START OF DSNAME\n         LR    R1,R2                    COPY PTR TO START OF DSN\n         LA    R1,1(,R1)                -> NEXT CHAR OF DSN\n         CLI   0(R1),C' '               END?\n         BNE   *-8                      NO - KEEP LOOKING\n         SR    R1,R2                    COMPUTE LENGTH OF DSN\n         BCTR  R1,0                     -1 FOR EX\n         CLI   QPARM1,C''''             QUOTED DSN?\n         BNE   SAVE$Q1                  NO, CONT\n         LA    R2,1(,R2)                -> PAST QUOTE\n         SH    R1,=H'2'                 LESS SURROUNDING QUOTES\nSAVE$Q1  EX    R1,SAVE$OC               FOLD DSN INTO UPPER CASE\n         LA    R1,1(,R1)                TRUE LEN OF DSN\n         CLI   QPARM1,C''''             QUOTED DSN?\n         BE    SAVE$DSN                 YES, CONTINUE\n         LA    R2,DSNAME+2(R1)          -> PAST CURRENT DSN\n         MVC   0(8,R2),=C'.OUTLIST'     SUFFIX WITH OUTLIST\n         LA    R1,8(,R1)                NEW LEN\nSAVE$DSN STH   R1,DSNAME                STORE LENGTH OF DSNAME\n         SPACE 3\n         MVC   DA08DDN(72),ALLOCNEW     REMAINDER OF DISP=NEW PARM LIST\n         LA    R2,QKEYWORD              -> FIRST KEYWORD\n         LA    R4,16                    BXLE INCR\n         LA    R5,QKEYLAST-16           BXLE END\n         MVI   SV@FLAGS,0               INITIALIZE FLAGS\n         ZAP   SV@FIRST,=P'1'           INIT STARTING RECORD NUMBER\n         ZAP   SV@LAST,=P'9999999'      INIT ENDING   RECORD NUMBER\n         SPACE 1\nSV$KEYLP CLI   0(R2),C' '               ANY MORE KEYWORDS?\n         BE    SV$KEYOK                 NO - DONE\n         CLC   =C'NORLSE',0(R2)         NORLSE?\n         BE    SV$NRLSE                 YES - GO SET BIT\n         CLC   =C'NEW',0(R2)            DISP=NEW?\n         BE    SV$NEW\n         CLC   =C'OLD',0(R2)            DISP=OLD?\n         BE    SV$OLD\n         CLC   =C'MOD',0(R2)            DISP=OLD?\n         BE    SV$MOD\n         CLC   =C'UNIT',0(R2)           UNIT?\n         BE    SV$UNIT\n         CLC   =C'VOL',0(R2)            VOLSER?\n         BE    SV$VOL\n         CLC   =C'START',0(R2)          STARTING LINE NUMBER?\n         BE    SV$START\n         CLC   =C'END',0(R2)            ENDING LINE NUMBER?\n         BE    SV$STOP\n         CLC   =C'STOP',0(R2)           ENDING LINE NUMBER?\n         BE    SV$STOP\n         CLC   =C'PRI',0(R2)            PRIMARY?\n         BE    SV$PRI\n         CLC   =C'SEC',0(R2)            SECONDARY?\n         BE    SV$SEC\n         CLC   =C'DIR',0(R2)            DIRECTORY?\n         BE    SV$DIR\n         CLC   =C'TRK',0(R2)            tracks?\n         BE    SV$TRK\n         CLC   =C'TRACK',0(R2)          tracks?\n         BE    SV$TRK\n         CLC   =C'CYL',0(R2)            tracks?\n         BE    SV$CYL\n         CLC   =C'BLK ',0(R2)           blocks?\n         BE    SV$BLK\n         CLC   =C'BLKS',0(R2)           blksize/blksz?\n         BE    SV$BLKSZ\n         EX    0,*                      SAY WHAT???\nSV$NRLSE NI    DA08CTL,255-X'10'        TURN OFF RLSE BIT\n         B     SV$BXLE                  CHECK NEXT OPTION\nSV$NEW   TM    SV@FLAGS,SV@DISP         ANY PREVIOUS DISP?\n         BO    SV$ERR1                  YES - ERROR\n         OI    SV@FLAGS,SV@DISP         REMEMBER WE HAD A DISP\n         B     SV$BXLE                  CHECK NEXT OPTION\nSV$OLD   TM    SV@FLAGS,SV@DISP         ANY PREVIOUS DISP?\n         BO    SV$ERR1                  YES - ERROR\n         OI    SV@FLAGS,SV@DISP         REMEMBER WE HAD A DISP\n         MVC   DA08BLK(36),ALLOCOLD     MOVE IN DISP=OLD SETUP\n         B     SV$BXLE                  CHECK NEXT OPTION\nSV$MOD   TM    SV@FLAGS,SV@DISP         ANY PREVIOUS DISP?\n         BO    SV$ERR1                  YES - ERROR\n         OI    SV@FLAGS,SV@DISP         REMEMBER WE HAD A DISP\n         MVC   DA08BLK(36),ALLOCOLD     MOVE IN DISP=OLD SETUP\n         MVI   DA08DSP1,X'02'           CHANGE TO MOD\n         B     SV$BXLE                  CHECK NEXT OPTION\nSV$UNIT  MVC   DA08UNIT,8(R2)           SET UNIT NAME\n         B     SV$BXLE                  CHECK NEXT OPTION\nSV$VOL   MVC   DA08SER,8(R2)            SET VOLSER\n         B     SV$BXLE                  CHECK NEXT OPTION\nSV$START BAL   R3,SV$NUM                CONVERT NUMERIC OPERAND\n         ZAP   SV@FIRST,QNUMWORK        SAVE STARTING NUMBER\n         OI    SV@FLAGS,SV@RANGE        REMEMBER RANGE IN USE\n         B     SV$BXLE                  CHECK NEXT OPTION\nSV$STOP  BAL   R3,SV$NUM                CONVERT NUMERIC OPERAND\n         ZAP   SV@LAST,QNUMWORK         SAVE ENDING NUMBER\n         OI    SV@FLAGS,SV@RANGE        REMEMBER RANGE IN USE\n         B     SV$BXLE                  CONVERT NUMERIC OPERAND\nSV$PRI   BAL   R3,SV$NUM                CONVERT NUMERIC OPERAND\n         OI    SV@FLAGS,SV@SPC#         space qty\n         ST    R15,DA08PQTY             -> OUTPUT AREA (BINARY)\n         B     SV$BXLE                  CHECK NEXT OPTION\nSV$SEC   BAL   R3,SV$NUM                CONVERT NUMERIC OPERAND\n         ST    R15,DA08SQTY             -> OUTPUT AREA (BINARY)\n         OI    SV@FLAGS,SV@SPC#         space qty\n         B     SV$BXLE                  CHECK NEXT OPTION\nSV$DIR   BAL   R3,SV$NUM                CONVERT NUMERIC OPERAND\n         ST    R15,DA08DQTY             -> OUTPUT AREA (BINARY)\n         B     SV$BXLE                  CHECK NEXT OPTION\nSV$TRK   TM    SV@FLAGS,SV@SPACE        any prev space?\n         BO    SV$ERR2                  yes - error\n         OI    SV@FLAGS,SV@SPACE        remember we had a space\n         NI    DA08CTL,255-DA08CYLS     reset space\n         OI    DA08CTL,DA08TRKS         set tracks\n         B     SV$BXLE                  check next option\nSV$CYL   TM    SV@FLAGS,SV@SPACE        any prev space?\n         BO    SV$ERR2                  yes - error\n         OI    SV@FLAGS,SV@SPACE        remember we had a space\n         OI    DA08CTL,DA08CYLS         set cylinders\n         B     SV$BXLE                  check next option\nSV$BLK   TM    SV@FLAGS,SV@SPACE        any prev space?\n         BO    SV$ERR2                  yes - error\n         OI    SV@FLAGS,SV@SPACE        remember we had a space\n         NI    DA08CTL,255-DA08CYLS     reset space\n         OI    DA08CTL,DA08ABKL         set blocks\n         B     SV$BXLE                  check next option\nSV$BLKSZ BAL   R3,SV$NUM                CONVERT NUMERIC OPERAND\n         ST    R15,SV@BLKSZ             output blksize\n         B     SV$BXLE                  CHECK NEXT OPTION\nSV$NUM   CLI   8(R2),C' '               IS THERE AN OPERAND?\n         BE    SV$NUMER                 NO - ERROR\n         LA    R1,15(,R2)               -> LAST POSSIBLE DIGIT\n         CLI   0(R1),C' '   <====+      IS THIS THE END OF THE NUMBER?\n         BNE   *+12   >=======+  |      YES\n         BCT   R1,*-8   >=====|==+      FIND END OF NUMBER\n         EX    0,*            |\n         LA    R15,8(,R2)  <==+         -> START OF NUMBER\n         LR    R0,R15                   COPY ADDRESS\n         SR    R1,R0                    COMPUTE EX LENGTH OF NUMBER\n         BAL   R14,QNUMCONV             CONVERT THE NUMBER\n         BER   R3                       RETURN TO CALLER IF NUMERIC\nSV$NUMER MVC   QERRMSG(58),=C'*** INVALID OR MISSING OPERAND FOR KEYWOR$\n               D - XXXXXXXX ***'\n         MVC   QERRMSG+45(8),0(R2)      FILL IN KEYWORD\n         QTILT *,OPTIONS=(REPROMPT,SET)\nSV$ERR1  QTILT '*** CONFLICTING DISP KEYWORDS ***',                    $\n               OPTIONS=(REPROMPT,SET)\nSV$ERR2  QTILT '*** CONFLICTING SPACE KEYWORDS ***',                   $\n               OPTIONS=(REPROMPT,SET)\n         SPACE 1\nSV$BXLE  BXLE  R2,R4,SV$KEYLP           CHECK ALL KEYWORDS\n         SPACE 2\nSV$KEYOK MVI   DAIRFLAG,X'08'           INDICATE ALLOC FUNCTION\n         CLI   QPARM1,C''''             QUOTED DSN?\n         BNE   *+8                      NO, CONTINUE\n         NI    DA08CTL,X'FF'-X'20'      YES, TURN OFF DSN-PREFIX\n         OI    QSCFLAG2,QSC2ALNA        TELL ALLOC NOT TO ABEND ME\n*%%      MVC   DA08BLK,SV@BLKSZ         set max blksize\n         CLI   DA08DSP1,X'04'           disp=new?\n         BNE   SV$ALLOC                 no - don't compute space\n         OC    SV@BLKSZ,SV@BLKSZ        output blksize specified yet?\n         BNZ   *+10                     yes - don't set default\n         MVC   SV@BLKSZ,=F'6233'        assume 1/3 3350\n         MVC   DA08BLK,SV@BLKSZ         set max blksize\n         TM    SV@FLAGS,SV@SPACE+SV@SPC#  any overrides?\n         BNZ   SV$ALLOC                 yes, use them\n         MVI   QGPFLAG,QPFDIR           req current pddb!\n         QCALL GETPDDB                  go get it\n         USNGX PDBDSECT,R1\n         LH    R0,PDBLRECL              record len\n         LTR   R0,R0                    any?\n         BNZ   *+8                      yes - use it\n         LA    R0,255                   no - pick a default\n         XR    R14,R14                  clear\n         L     R15,SV@BLKSZ             use user-specified max blksize\n         SLDL  R14,8                    *256\n         DR    R14,R0                   get blocking factor (*256)\n*        LTR   R0,R15                   copy for later\n*        BP    *+8                      skip if ok\n*        LA    R0,1                     else use a default\n         LR    R0,R15                   move answer for later divide\n         XR    R14,R14                  clear again\n         L     R15,PDBRECCT             get number of records\n         DROPX R1\n         TM    SV@FLAGS,SV@RANGE        range to copy?\n         BZ    SV$ALL                   no, get record count\n         ZAP   SV@DWD,SV@LAST           get end\n         SP    SV@DWD,SV@FIRST          less beginning\n         CVB   R15,SV@DWD               binary\nSV$ALL   SLDL  R15-1,8                  *256\n         DR    R15-1,R0                 get number of blocks\n         LA    R15,1(,R15)              fudge just in case\n         ST    R15,DA08PQTY             save primary\n         LR    R14,R15                  copy\n         SRA   R14,3                    /8 for secondary\n         BP    *+8                      skip if >0\n         LA    R14,1                    else force a secondary of one\n         ST    R14,DA08SQTY             ditto secondary\nSV$ALLOC QCALL ALLOCATE                 CALL DAIR\n         MVI   QCSAVE,X'80'             INDICATE END OF LIST & purify\n         L     R3,QCSAVE                -> HASPSAVE DCB\n         USNGX IHADCB,R3                ADDRESS HASPSAVE DCB\n         MVC   DCBDDNAM,DA08DDN         GET RETURNED DDNAME\n         LA    R1,SAVE@DCB              -> DCB EXIT FOR SAVE DCB\n         STCM  R1,B'0111',DCBEXLSA      SAVE IN DCB\n         BAL   R14,QAMODE24             change to AMODE 24\n         SPACE 1\n         OPEN  (,OUTPUT),MF=(E,QCSAVE)  OPEN HASPSAVE DCB\n         SPACE 1\n         BAL   R14,QAMODE31             resume AMODE 31\n         SR    R4,R4                    ASSUME START AT TOP\n         SR    R7,R7                    ZERO RECORD COUNTER\n         ZAP   QPREC,SV@FIRST           SET STARTING RECORD NUMBER\n         TM    SV@FLAGS,SV@RANGE        WANT A RANGE?\n         BNO   SV$LOOP                  NO - GO LOOP FOR WHOLE DATASET\n         BCTR  R4,0                     R4 NEGATIVE ==> SPECIFIC START\n         CP    SV@FIRST,SV@LAST         FIRST > LAST?\n         BNH   SV$LOOP                  NO - GO LOOP FOR RANGE\n         QTILT '*** REVERSE RANGE INVALID ***',OPTIONS=(REPROMPT,SET)\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*   PROCESS RECORDS                                                   *\n*                                                                     *\n***********************************************************************\nSV$LOOP  TM    QMISCFLG,QMFATTN         USER PRESS ATTN?\n         BO    SAVE$END                 YES - CLOSE UP SHOP AND LEAVE\n         QCALL GETREC                   GET THE NEXT REC FROM DATASET\n         LTR   R4,R4                    HAVE WE HIT BOTTOM?\n         BZ    SAVE$END                 YES - CLOSE UP SHOP AND LEAVE\n         USNGX LRCDSECT,R4\n         TM    LRCFLAG1,LRC1SPAN        SPANNED RECORD?\n         BO    SV$NEXT                  YES - CAN'T HANDLE THESE YET\n         LA    R0,LRCTEXT               -> DATA PORTION OF RECORD\n         LR    R1,R6                    GET DATA LENGTH\n         LA    R14,BUFFER               -> OUTPUT RECORD AREA\n         LA    R15,L'BUFFER             GET DEST LENGTH\n         ICM   R1,B'1000',QBLANK        INSERT PAD CHAR\n         MVCL  R14,R0                   COPY RECORD TO OUTPUT BUFFER\n         LA    R0,BUFFER                ASSUME RECFM=F\n         TM    DCBRECFM,DCBRECV         IS IT RECFM V?\n         BNO   SV$PUT                   NO - PUT IT OUT NOW\n         LA    R1,4(,R6)                L'RECORD+RDW\n         CH    R1,DCBLRECL              OVER LRECL?\n         BNH   *+8                      NO, USE IT\n         LH    R1,DCBLRECL              YES, GET MAX LEN\n         SLL   R1,16                    ASSEMBLE RDW\n         ST    R1,BUFFRDW               SAVE IN BUFFER\n         LA    R0,BUFFRDW               -> OUTPUT RECORD\n         SPACE 1\nSV$PUT   BAL   R14,QAMODE24             change to AMODE 24\n         PUT   IHADCB,(0)\n         BAL   R14,QAMODE31             resume AMODE 31\nSV$NEXT  LA    R7,1(,R7)                COUNT A RECORD\n         CP    QCCREC,SV@LAST           REACH USER'S LIMIT?\n         BL    SV$LOOP                  NO - CONTINUE\n         DROPX R4                       LRCDSECT\n***********************************************************************\n*                                                                     *\n*   CLOSE UP SHOP AND GO HOME                                         *\n*                                                                     *\n***********************************************************************\nSAVE$END BAL   R14,QAMODE24             change to AMODE 24\n         CLOSE MF=(E,QCSAVE)            CLOSE HASPSAVE DCB\n         BAL   R14,QAMODE31             resume AMODE 31\n         SPACE 1\n         FREEPOOL  (R3)                 FREE ITS BUFFER POOL\n         SPACE 1\n***      MVC   DA2CDDN,DCBDDNAM         GET THE DDNAME\n         MVC   DA18DDN,DCBDDNAM         GET THE DDNAME\n         DROPX R3                       IHADCB (HASPSAVE)\n***      MVI   DAIRFLAG,X'2C'           INDICATE \"NOT_IN_USE\" FUNCTION\n         MVI   DAIRFLAG,X'18'           request \"FREE\" function\n         QCALL ALLOCATE                 CALL DAIR\n**LDW**  QCALL LISTDS                   GO BACK TO LISTDS\n**LDW**  B     QSTOP\n         TM    QMISCFLG,QMFATTN         USER PRESS ATTN?\n         BO    SAVEATTN                 YES - USE ALTERNATE MESSAGE\n         MVC   QERRMSG(3),=C'==='\n         CVD   R7,QNUMWORK              CONVERT NUMBER OF RECORDS SAVED\n         MVC   QERRMSG+4(11),=X'2020206B2020206B202120'\n         LA    R1,QERRMSG+3+12-1        PRESET SIGNIFICANCE POINTER\n         EDMK  QERRMSG+3(12),QNUMWORK+3 FILL IN NUMBER OF RECORDS SAVED\n         MVC   QERRMSG+4(12),0(R1)      SHIFT THE NUMBER OVER\n         LA    R15,QERRMSG+3+12         -> END OF NUMBER +1\n         SR    R15,R1                   COMPUTE LENGTH OF NUMBER\n         LA    R1,QERRMSG+4+1(R15)      -> LOC FOR NEXT PART OF MESSAGE\n         MVC   0(16,R1),=C'RECORDS SAVED IN'\n***      LA    R1,QERRMSG+13            -> WHERE DSNAME WILL GO\n         LA    R1,17(,R1)               -> WHERE DSNAME WILL GO\n         TM    DA08CTL,X'20'            WAS DSNAME ENTERED IN QUOTES?\n         BO    *+12                     NO - SKIP\n         MVI   0(R1),C''''              YES - PUT IN LEADING QUOTE\n         LA    R1,1(,R1)                AND BUMP OUTPUT PTR\n         MVC   0(44,R1),DSNAME+2        FILL IN DSNAME\n         AH    R1,DSNAME                -> PAST END OF DSNAME\n         TM    DA08CTL,X'20'            WAS DSNAME ENTERED IN QUOTES?\n         BO    *+12                     NO - SKIP\n         MVI   0(R1),C''''              YES - PUT IN LEADING QUOTE\n         LA    R1,1(,R1)                AND BUMP OUTPUT PTR\n         MVC   1(3,R1),=C'==='          END THE MESSAGE\n         QTILT *\nSAVEATTN NI    QMISCFLG,255-QMFATTN     RESET ATTN FLAG\n         QTILT '=== SAVE INCOMPLETE DUE TO ATTENTION ==='\nSV$TILT1 QTILT '=== YOU ARE NOT PROCESSING A VALID DATASET ==='\nSV$TILT3 QTILT '*** OUTPUT DSNAME MUST BE SPECIFIED ***',              $\n               OPTIONS=(REPROMPT,SET)\n         EJECT ,\n***********************************************************************\n*                                                                     *\n*   DCB EXIT FOR HASPSAVE DCB                                         *\n*                                                                     *\n***********************************************************************\n         PUSH  USING\n         DROP  ,\n         USING SAVE$DCB,R15\n         USING IHADCB,R1\n         USING QCOMMON,R11\nSAVE$DCB STM   R14,R12,12(R13)          SAVE OPEN'S REGS\n         LA    R6,1                     ASSUME PRE ALLOC DSN\n         CLI   DCBRECFM,0               ANY SPECIFIED?\n         BNE   SV$DCBGR                 YES, GOT RECFM\n         XR    R6,R6                    NEW DSN\n         MVC   DCBRECFM,QCRECFM         MOVE IN RECORD FORMAT\n         NI    DCBRECFM,DCBRECCC        TURN OFF EVERTHING BUT CCTL\n         OI    DCBRECFM,DCBRECF+DCBRECBR  SPECIFY RECFM = FB??\nSV$DCBGR LH    R2,DCBLRECL              ANY LRECL YET?\n         LTR   R2,R2                    SPECIFIED?\n         BNZ   SV$DCBGL                 YES, USE IT\n         XR    R6,R6                    MUST BE NEW DSN\n         LH    R2,QCLRECL               NO TRY RECORD LENGTH\n         LTR   R2,R2                    IS THE LRECL ZERO?\n         BNZ   SV$DCBGL                 NO. SKIP.\n         LA    R2,133                   YES. USE LRECL 133.\nSV$DCBGL STH   R2,DCBLRECL              STORE LRECL\n         LH    R5,DCBBLKSI              ANY BLOCKSIZE?\n         LTR   R5,R5                    IS IT A PREM DS?\n         BNZ   SV$DCBHB                 YES, GOT BLOCKSIZE\n         XR    R6,R6                    MUST BE NEW DSN\n*%       LH    R5,=H'6233'              DEFAULT TO 1/3 TRACK 3350\n         L     R5,DA08BLK               default to user-specified blksz\nSV$DCBHB TM    DCBRECFM,DCBRECU         RECFM=U?\n         BO    SV$DCBBL                 YES - JUST USE BLOCKSIZE\n         TM    DCBRECFM,DCBRECV         RECFM=V?\n         BO    SV$DCBRV                 YES, HANDLE IT\n         SR    R4,R4                    CLEAR FOR DIVIDE\n         DR    R4,R2                    DIVIDE BLKSIZE BY LRECL\n         MR    R4,R2                    MULTIPLY RESULT BY LRECL\n         B     SV$DCBBL\nSV$DCBRV LA    R2,4(,R2)                ADD IN SPACE FOR BDW\n         CR    R2,R5                    IS LRECL LARGER?\n         BNH   SV$DCBBL                 NO, THEN WE ARE OK\n         LTR   R6,R6                    WAS IT A PERM DS?\n         BNZ   SV$DCBBL                 YES, LEAVE AS ALLOCATED\n         OI    DCBRECFM,DCBRECSB        NO, MAKE SPANNED RECORDS\nSV$DCBBL STH   R5,DCBBLKSI              STORE BLKSIZE\n         LM    R14,R12,12(R13)          RESTORE OPEN'S REGS\n         XR    R15,R15                  CLEAR RET CODE\n         BR    R14                      RETURN TO CALLER\n         POP   USING\n         EJECT ,\n***********************************************************************\n*                                                                     *\n*   MISCELLANY                                                        *\n*                                                                     *\n***********************************************************************\nSAVE$OC  OC    DSNAME+2(*-*),0(R2)      << EXECUTED >>\n         SPACE 1\n         LTORG ,\n         DC    0F'0'\n         SPACE 1\nALLOCNEW DC    XL8'00'                  DDNAME\n         DC    2CL8' '                  UNIT & VOLSER\n         DC    F'6233,10,50,0'          BLKSIZE / PRI / SEC / DIR\n         DC    2CL8' '                  MEMBER & PASSWORD\n         DC    X'04'                    STAT=NEW\n         DC    2X'02'                   DISP=CATLG\n*        DC    X'B0'                    TRKS + PREFIX_USERID + RLSE\n         DC    X'70'                    blks + prefix_userid + rlse\n         DC    F'0',CL8' '              RESERVED + DSORG + ATTRLISTNAME\n         SPACE 1\nALLOCOLD DC    4F'0'                    BLKSIZE / PRI / SEC / DIR\n         DC    2CL8' '                  MEMBER & PASSWORD\n         DC    X'01'                    STAT=OLD\n         DC    2X'08'                   DISP=KEEP\n         DC    X'20'                    PREFIX_USERID TO DSNAME\n         SPACE 1\nSAVE@DCB DC    X'85',AL3(SAVE$DCB)      -> DCB EXIT FOR HASPSAVE\n         SPACE 2\n         ENTRY SV#KEYS\nSV#KEYS  DC    CL8'OLD     '\n         DC    CL8'MOD     '\n         DC    CL8'NEW     '\n         DC    CL8'NORLSE  '\n         DC    CL8'UNIT    '\n         DC    CL8'VOL     '\n         DC    CL8'START   '\n         DC    CL8'END     '\n         DC    CL8'STOP    '\n         DC    CL8'PRI     '\n         DC    CL8'SEC     '\n         DC    CL8'TRACK   ',CL8'TRK      '\n         DC    CL8'CYL     '\n         DC    CL8'BLK     '\n*%       DC    CL8'DIR'\n         DC    CL8'BLKSIZE ',CL8'BLKSZ    '\n         DC    X'FF'\n         SPACE 2\nWORK     DSECT\n         ORG   WORK+72                  SKIP OVER SAVE AREA\nSV@DWD   DS    D                        misc workarea\nSV@FIRST DS    PL4                      FIRST DS RECORD # TO SAVE\nSV@LAST  DS    PL4                      LAST  DS RECORD # TO SAVE\nSV@FLAGS DS    B\nSV@DISP  EQU   X'80'                    DISPOSITION FOUND\nSV@RANGE EQU   X'40'                    LINE NUMBER RANGE SPECIFIED\nSV@SPACE EQU   X'20'                    unit of space specified\nSV@SPC#  EQU   X'10'                    quantity of space specified\nSV@BLKSZ DS    F                        max blksize for NEW output ds\nDSNAME   DS    H\n         DS    CL44\nSV@WORKL EQU   *-WORK\n         DS    0F\nBUFFRDW  DS    2H                       OPTIONAL RDW\nBUFFER   DS    CL256                    OUTPUT BUFFER\n         SPACE 3\n         DROPX R13                      WORK\n         SPACE 3\n         QCOMMON\n         QDCB  ,                        ADDED FOR DCB EQUATES\n         SPACE 3\n         Q$LRC\n         Q$PDDB\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "Q#SV@": {"ttr": 16138, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x15\\x00\\x00\\x00\\x82#_\\x00\\x91\\x12?\\x17%\\x01\\xf3\\x00\\xad\\x01\\xc8\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "05.21", "flags": 0, "createdate": "1982-08-23T00:00:00", "modifydate": "1991-05-03T17:25:00", "lines": 499, "newlines": 173, "modlines": 456, "user": "LDW"}, "text": "         TITLE '--- QUEUE--SAVEDS -- CREATE A COPY OF CURRENT DS ---'\n*---------------------------------------------------------------------*\n*                                                                     *\n*   SAVEDS - CREATE A DISK COPY OF CURRENTLY SELECTED DATASET         *\n*                                                                     *\n*   Updates:                                                          *\n*      03May91  LDW  Only compute output blksize if DISP=NEW          *\n*       7Aug90  LDW  Fix EMS's fix                                    *\n*       7Aug90  EMS  Fix 26Jun90 in a better fashion                  *\n*      26Jun90  LDW  Fix S0C9 when very large lrecl & small ds        *\n*      16Jun90  LDW  Run (mostly) in AMODE31 now                      *\n*      23Aug89  LDW  Fix for LRECL=0 (like internal text)             *\n*      05Sep88  LDW  Add BLKSIZE operand (ignored unless disp=NEW)    *\n*                    Add BLK to keyword table so it can be used       *\n*      13Aug88  LDW  Fix various bugs caused by error in 17Jan88 updt *\n*      17Jan88  LDW  Fix problems with space calculations due to use  *\n*                       of integer arithmetic without taking into     *\n*                       account roundoff errors                       *\n*                    Only compute space quantities for disp=NEW to    *\n*                       avoid DAIR rc=4 (invalid parmlist)            *\n*      11Aug87  EMS  Add CYL, TRK keywords (default to blocks)        *\n*      21Mar87  LDW  Fix for DSID = 0 (from RSCS)                     *\n*      04/22/86 LDW  MOVE ATTN FLAG FROM QTERMFLG TO QMISCFLG         *\n*      04/26/84 LDW  USE GETREC ROUTINE TO READ INPUT DATASET, TO     *\n*                       ALLOW IMPLEMENTATION OF SAVE RANGE            *\n*                    ADD PRI=, SEC=, AND DIR= KEYWORDS                *\n*                    ADD START= AND STOP= (END=) KEYWORDS             *\n*                    SHOW RECORD COUNT SAVED                          *\n*      01/23/84 LDW  ADD SUPPORT FOR COMMAND STACKING                 *\n*                    FIX PROCESSING OF DSNAMES LONGER THAN 8 CHARS    *\n*                    DISPLAY DSNAME IN 'SAVED' MESSAGE                *\n*                    FIX ATTENTION PROCESSING                         *\n*      03/18/83 LDW  CHANGE DISP AND NORLSE TO RESERVED WORDS         *\n*                    ADD VOL= AND UNIT= KEYWORDS                      *\n*                    REWRITE DSNAME LENGTH LOGIC                      *\n*      12/21/82 LDW  SET NEW FLAG \"QSC2ALNA\" TO TELL ALLOC NOT TO     *\n*                       ABEND IF UNABLE TO ALLOCATE                   *\n*      12/20/82 LDW  CHANGE QTILT REPRMPT=YES TO OPTIONS=REPROMPT     *\n*      12/10/82 LDW  PUT IN FREEPOOL FOR HASPSAVE DCB.  THIS WILL     *\n*                       CORRECT A POTENTIAL PROBLEM CAUSED BY UPDATE  *\n*                       DATED 11/11/82, WHICH REMOVED BUFL=8192       *\n*                    DON'T SET \"QSC2SAVE\" - ALLOC WILL KNOW IT'S ME   *\n*                    CHANGE NAME OF THIS CSECT TO \"SAVEDS\" TO AVOID   *\n*                       ASSEMBLY PROBLEMS WITH NJE                    *\n*      12/08/82 LDW  USE $LRC DSECT                                   *\n*                    SET NEW FLAG \"QSC2SAVE\" SO \"ALLOC\" KNOWS IT'S ME *\n*      11/11/82 EMS  ALLOW FULLY QUALIFIED DATASET NAME               *\n*                    USE IHADCB SYMBOLS                               *\n*                    HANDLE RECFM=VB OUTPUT DATASET                   *\n*                    INSTALL DCB EXIT TO DO THINGS RIGHT              *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 3\nSAVEDS   QSTART  Q19,WORKLEN=SV@WORKL,STACK=X'F0'\n         USNGX WORK,R13                 LOCAL WORK AREA\n***********************************************************************\n*                                                                     *\n*   ALLOCATE OUTPUT DATASET                                           *\n*                                                                     *\n***********************************************************************\n*%%%     CLC   QPDSID,=H'0'             IS THERE A VALID DATASET?\n*%%%     BE    SV$TILT1                 NO. TELL THE USER.\n         TM    QFLAG2,Q2VALIDS          IS THERE A VALID DATASET?\n         BZ    SV$TILT1                 NO. TELL THE USER.\n         MVC   DSNAME+2(44),QBLANK      BLANK THE DSNAME\n         LA    R1,DSNAME                -> TEXT UNIT\n         ST    R1,DA08PDSN              SAVE IN DAIR PARM LIST\n**%%     MVC   SV@BLKSZ,=F'6233'        assume 1/3 3350\n         XC    SV@BLKSZ,SV@BLKSZ        initialize output blksize\n         LH    R2,QOFF1                 OFFSET OF DSNAME\n         LTR   R2,R2                    ANY OPERAND?\n         BZ    SV$TILT3                 NO - ERROR\n         LA    R2,QDREPLY(R2)           -> START OF DSNAME\n         LR    R1,R2                    COPY PTR TO START OF DSN\n         LA    R1,1(,R1)                -> NEXT CHAR OF DSN\n         CLI   0(R1),C' '               END?\n         BNE   *-8                      NO - KEEP LOOKING\n         SR    R1,R2                    COMPUTE LENGTH OF DSN\n         BCTR  R1,0                     -1 FOR EX\n         CLI   QPARM1,C''''             QUOTED DSN?\n         BNE   SAVE$Q1                  NO, CONT\n         LA    R2,1(,R2)                -> PAST QUOTE\n         SH    R1,=H'2'                 LESS SURROUNDING QUOTES\nSAVE$Q1  EX    R1,SAVE$OC               FOLD DSN INTO UPPER CASE\n         LA    R1,1(,R1)                TRUE LEN OF DSN\n         CLI   QPARM1,C''''             QUOTED DSN?\n         BE    SAVE$DSN                 YES, CONTINUE\n         LA    R2,DSNAME+2(R1)          -> PAST CURRENT DSN\n         MVC   0(8,R2),=C'.OUTLIST'     SUFFIX WITH OUTLIST\n         LA    R1,8(,R1)                NEW LEN\nSAVE$DSN STH   R1,DSNAME                STORE LENGTH OF DSNAME\n         SPACE 3\n         MVC   DA08DDN(72),ALLOCNEW     REMAINDER OF DISP=NEW PARM LIST\n         LA    R2,QKEYWORD              -> FIRST KEYWORD\n         LA    R4,16                    BXLE INCR\n         LA    R5,QKEYLAST-16           BXLE END\n         MVI   SV@FLAGS,0               INITIALIZE FLAGS\n         ZAP   SV@FIRST,=P'1'           INIT STARTING RECORD NUMBER\n         ZAP   SV@LAST,=P'9999999'      INIT ENDING   RECORD NUMBER\n         SPACE 1\nSV$KEYLP CLI   0(R2),C' '               ANY MORE KEYWORDS?\n         BE    SV$KEYOK                 NO - DONE\n         CLC   =C'NORLSE',0(R2)         NORLSE?\n         BE    SV$NRLSE                 YES - GO SET BIT\n         CLC   =C'NEW',0(R2)            DISP=NEW?\n         BE    SV$NEW\n         CLC   =C'OLD',0(R2)            DISP=OLD?\n         BE    SV$OLD\n         CLC   =C'MOD',0(R2)            DISP=OLD?\n         BE    SV$MOD\n         CLC   =C'UNIT',0(R2)           UNIT?\n         BE    SV$UNIT\n         CLC   =C'VOL',0(R2)            VOLSER?\n         BE    SV$VOL\n         CLC   =C'START',0(R2)          STARTING LINE NUMBER?\n         BE    SV$START\n         CLC   =C'END',0(R2)            ENDING LINE NUMBER?\n         BE    SV$STOP\n         CLC   =C'STOP',0(R2)           ENDING LINE NUMBER?\n         BE    SV$STOP\n         CLC   =C'PRI',0(R2)            PRIMARY?\n         BE    SV$PRI\n         CLC   =C'SEC',0(R2)            SECONDARY?\n         BE    SV$SEC\n         CLC   =C'DIR',0(R2)            DIRECTORY?\n         BE    SV$DIR\n         CLC   =C'TRK',0(R2)            tracks?\n         BE    SV$TRK\n         CLC   =C'TRACK',0(R2)          tracks?\n         BE    SV$TRK\n         CLC   =C'CYL',0(R2)            tracks?\n         BE    SV$CYL\n         CLC   =C'BLK ',0(R2)           blocks?\n         BE    SV$BLK\n         CLC   =C'BLKS',0(R2)           blksize/blksz?\n         BE    SV$BLKSZ\n         EX    0,*                      SAY WHAT???\nSV$NRLSE NI    DA08CTL,255-X'10'        TURN OFF RLSE BIT\n         B     SV$BXLE                  CHECK NEXT OPTION\nSV$NEW   TM    SV@FLAGS,SV@DISP         ANY PREVIOUS DISP?\n         BO    SV$ERR1                  YES - ERROR\n         OI    SV@FLAGS,SV@DISP         REMEMBER WE HAD A DISP\n         B     SV$BXLE                  CHECK NEXT OPTION\nSV$OLD   TM    SV@FLAGS,SV@DISP         ANY PREVIOUS DISP?\n         BO    SV$ERR1                  YES - ERROR\n         OI    SV@FLAGS,SV@DISP         REMEMBER WE HAD A DISP\n         MVC   DA08BLK(36),ALLOCOLD     MOVE IN DISP=OLD SETUP\n         B     SV$BXLE                  CHECK NEXT OPTION\nSV$MOD   TM    SV@FLAGS,SV@DISP         ANY PREVIOUS DISP?\n         BO    SV$ERR1                  YES - ERROR\n         OI    SV@FLAGS,SV@DISP         REMEMBER WE HAD A DISP\n         MVC   DA08BLK(36),ALLOCOLD     MOVE IN DISP=OLD SETUP\n         MVI   DA08DSP1,X'02'           CHANGE TO MOD\n         B     SV$BXLE                  CHECK NEXT OPTION\nSV$UNIT  MVC   DA08UNIT,8(R2)           SET UNIT NAME\n         B     SV$BXLE                  CHECK NEXT OPTION\nSV$VOL   MVC   DA08SER,8(R2)            SET VOLSER\n         B     SV$BXLE                  CHECK NEXT OPTION\nSV$START BAL   R3,SV$NUM                CONVERT NUMERIC OPERAND\n         ZAP   SV@FIRST,QNUMWORK        SAVE STARTING NUMBER\n         OI    SV@FLAGS,SV@RANGE        REMEMBER RANGE IN USE\n         B     SV$BXLE                  CHECK NEXT OPTION\nSV$STOP  BAL   R3,SV$NUM                CONVERT NUMERIC OPERAND\n         ZAP   SV@LAST,QNUMWORK         SAVE ENDING NUMBER\n         OI    SV@FLAGS,SV@RANGE        REMEMBER RANGE IN USE\n         B     SV$BXLE                  CONVERT NUMERIC OPERAND\nSV$PRI   BAL   R3,SV$NUM                CONVERT NUMERIC OPERAND\n         OI    SV@FLAGS,SV@SPC#         space qty\n         ST    R15,DA08PQTY             -> OUTPUT AREA (BINARY)\n         B     SV$BXLE                  CHECK NEXT OPTION\nSV$SEC   BAL   R3,SV$NUM                CONVERT NUMERIC OPERAND\n         ST    R15,DA08SQTY             -> OUTPUT AREA (BINARY)\n         OI    SV@FLAGS,SV@SPC#         space qty\n         B     SV$BXLE                  CHECK NEXT OPTION\nSV$DIR   BAL   R3,SV$NUM                CONVERT NUMERIC OPERAND\n         ST    R15,DA08DQTY             -> OUTPUT AREA (BINARY)\n         B     SV$BXLE                  CHECK NEXT OPTION\nSV$TRK   TM    SV@FLAGS,SV@SPACE        any prev space?\n         BO    SV$ERR2                  yes - error\n         OI    SV@FLAGS,SV@SPACE        remember we had a space\n         NI    DA08CTL,255-DA08CYLS     reset space\n         OI    DA08CTL,DA08TRKS         set tracks\n         B     SV$BXLE                  check next option\nSV$CYL   TM    SV@FLAGS,SV@SPACE        any prev space?\n         BO    SV$ERR2                  yes - error\n         OI    SV@FLAGS,SV@SPACE        remember we had a space\n         OI    DA08CTL,DA08CYLS         set cylinders\n         B     SV$BXLE                  check next option\nSV$BLK   TM    SV@FLAGS,SV@SPACE        any prev space?\n         BO    SV$ERR2                  yes - error\n         OI    SV@FLAGS,SV@SPACE        remember we had a space\n         NI    DA08CTL,255-DA08CYLS     reset space\n         OI    DA08CTL,DA08ABKL         set blocks\n         B     SV$BXLE                  check next option\nSV$BLKSZ BAL   R3,SV$NUM                CONVERT NUMERIC OPERAND\n         ST    R15,SV@BLKSZ             output blksize\n         B     SV$BXLE                  CHECK NEXT OPTION\nSV$NUM   CLI   8(R2),C' '               IS THERE AN OPERAND?\n         BE    SV$NUMER                 NO - ERROR\n         LA    R1,15(,R2)               -> LAST POSSIBLE DIGIT\n         CLI   0(R1),C' '   <====+      IS THIS THE END OF THE NUMBER?\n         BNE   *+12   >=======+  |      YES\n         BCT   R1,*-8   >=====|==+      FIND END OF NUMBER\n         EX    0,*            |\n         LA    R15,8(,R2)  <==+         -> START OF NUMBER\n         LR    R0,R15                   COPY ADDRESS\n         SR    R1,R0                    COMPUTE EX LENGTH OF NUMBER\n         BAL   R14,QNUMCONV             CONVERT THE NUMBER\n         BER   R3                       RETURN TO CALLER IF NUMERIC\nSV$NUMER MVC   QERRMSG(58),=C'*** INVALID OR MISSING OPERAND FOR KEYWOR$\n               D - XXXXXXXX ***'\n         MVC   QERRMSG+45(8),0(R2)      FILL IN KEYWORD\n         QTILT *,OPTIONS=(REPROMPT,SET)\nSV$ERR1  QTILT '*** CONFLICTING DISP KEYWORDS ***',                    $\n               OPTIONS=(REPROMPT,SET)\nSV$ERR2  QTILT '*** CONFLICTING SPACE KEYWORDS ***',                   $\n               OPTIONS=(REPROMPT,SET)\n         SPACE 1\nSV$BXLE  BXLE  R2,R4,SV$KEYLP           CHECK ALL KEYWORDS\n         SPACE 2\nSV$KEYOK MVI   DAIRFLAG,X'08'           INDICATE ALLOC FUNCTION\n         CLI   QPARM1,C''''             QUOTED DSN?\n         BNE   *+8                      NO, CONTINUE\n         NI    DA08CTL,X'FF'-X'20'      YES, TURN OFF DSN-PREFIX\n         OI    QSCFLAG2,QSC2ALNA        TELL ALLOC NOT TO ABEND ME\n*%%      MVC   DA08BLK,SV@BLKSZ         set max blksize\n         CLI   DA08DSP1,X'04'           disp=new?\n         BNE   SV$ALLOC                 no - don't compute space\n         OC    SV@BLKSZ,SV@BLKSZ        output blksize specified yet?\n         BNZ   *+10                     yes - don't set default\n         MVC   SV@BLKSZ,=F'6233'        assume 1/3 3350\n         MVC   DA08BLK,SV@BLKSZ         set max blksize\n         TM    SV@FLAGS,SV@SPACE+SV@SPC#  any overrides?\n         BNZ   SV$ALLOC                 yes, use them\n         MVI   QGPFLAG,QPFDIR           req current pddb!\n         QCALL GETPDDB                  go get it\n         USNGX PDBDSECT,R1\n         LH    R0,PDBLRECL              record len\n         LTR   R0,R0                    any?\n         BNZ   *+8                      yes - use it\n         LA    R0,255                   no - pick a default\n         XR    R14,R14                  clear\n         L     R15,SV@BLKSZ             use user-specified max blksize\n         SLDL  R14,8                    *256\n         DR    R14,R0                   get blocking factor (*256)\n*        LTR   R0,R15                   copy for later\n*        BP    *+8                      skip if ok\n*        LA    R0,1                     else use a default\n         LR    R0,R15                   move answer for later divide\n         XR    R14,R14                  clear again\n         L     R15,PDBRECCT             get number of records\n         DROPX R1\n         TM    SV@FLAGS,SV@RANGE        range to copy?\n         BZ    SV$ALL                   no, get record count\n         ZAP   SV@DWD,SV@LAST           get end\n         SP    SV@DWD,SV@FIRST          less beginning\n         CVB   R15,SV@DWD               binary\nSV$ALL   SLDL  R15-1,8                  *256\n         DR    R15-1,R0                 get number of blocks\n         LA    R15,1(,R15)              fudge just in case\n         ST    R15,DA08PQTY             save primary\n         LR    R14,R15                  copy\n         SRA   R14,3                    /8 for secondary\n         BP    *+8                      skip if >0\n         LA    R14,1                    else force a secondary of one\n         ST    R14,DA08SQTY             ditto secondary\nSV$ALLOC QCALL ALLOCATE                 CALL DAIR\n         MVI   QCSAVE,X'80'             INDICATE END OF LIST & purify\n         L     R3,QCSAVE                -> HASPSAVE DCB\n         USNGX IHADCB,R3                ADDRESS HASPSAVE DCB\n         MVC   DCBDDNAM,DA08DDN         GET RETURNED DDNAME\n         LA    R1,SAVE@DCB              -> DCB EXIT FOR SAVE DCB\n         STCM  R1,B'0111',DCBEXLSA      SAVE IN DCB\n         BAL   R14,QAMODE24             change to AMODE 24\n         SPACE 1\n         OPEN  (,OUTPUT),MF=(E,QCSAVE)  OPEN HASPSAVE DCB\n         SPACE 1\n         BAL   R14,QAMODE31             resume AMODE 31\n         SR    R4,R4                    ASSUME START AT TOP\n         SR    R7,R7                    ZERO RECORD COUNTER\n         ZAP   QPREC,SV@FIRST           SET STARTING RECORD NUMBER\n         TM    SV@FLAGS,SV@RANGE        WANT A RANGE?\n         BNO   SV$LOOP                  NO - GO LOOP FOR WHOLE DATASET\n         BCTR  R4,0                     R4 NEGATIVE ==> SPECIFIC START\n         CP    SV@FIRST,SV@LAST         FIRST > LAST?\n         BNH   SV$LOOP                  NO - GO LOOP FOR RANGE\n         QTILT '*** REVERSE RANGE INVALID ***',OPTIONS=(REPROMPT,SET)\n         SPACE 1\n***********************************************************************\n*                                                                     *\n*   PROCESS RECORDS                                                   *\n*                                                                     *\n***********************************************************************\nSV$LOOP  TM    QMISCFLG,QMFATTN         USER PRESS ATTN?\n         BO    SAVE$END                 YES - CLOSE UP SHOP AND LEAVE\n         QCALL GETREC                   GET THE NEXT REC FROM DATASET\n         LTR   R4,R4                    HAVE WE HIT BOTTOM?\n         BZ    SAVE$END                 YES - CLOSE UP SHOP AND LEAVE\n         USNGX LRCDSECT,R4\n         TM    LRCFLAG1,LRC1SPAN        SPANNED RECORD?\n         BO    SV$NEXT                  YES - CAN'T HANDLE THESE YET\n         LA    R0,LRCTEXT               -> DATA PORTION OF RECORD\n         LR    R1,R6                    GET DATA LENGTH\n         LA    R14,BUFFER               -> OUTPUT RECORD AREA\n         LA    R15,L'BUFFER             GET DEST LENGTH\n         ICM   R1,B'1000',QBLANK        INSERT PAD CHAR\n         MVCL  R14,R0                   COPY RECORD TO OUTPUT BUFFER\n         LA    R0,BUFFER                ASSUME RECFM=F\n         TM    DCBRECFM,DCBRECV         IS IT RECFM V?\n         BNO   SV$PUT                   NO - PUT IT OUT NOW\n         LA    R1,4(,R6)                L'RECORD+RDW\n         CH    R1,DCBLRECL              OVER LRECL?\n         BNH   *+8                      NO, USE IT\n         LH    R1,DCBLRECL              YES, GET MAX LEN\n         SLL   R1,16                    ASSEMBLE RDW\n         ST    R1,BUFFRDW               SAVE IN BUFFER\n         LA    R0,BUFFRDW               -> OUTPUT RECORD\n         SPACE 1\nSV$PUT   BAL   R14,QAMODE24             change to AMODE 24\n         PUT   IHADCB,(0)\n         BAL   R14,QAMODE31             resume AMODE 31\nSV$NEXT  LA    R7,1(,R7)                COUNT A RECORD\n         CP    QCCREC,SV@LAST           REACH USER'S LIMIT?\n         BL    SV$LOOP                  NO - CONTINUE\n         DROPX R4                       LRCDSECT\n***********************************************************************\n*                                                                     *\n*   CLOSE UP SHOP AND GO HOME                                         *\n*                                                                     *\n***********************************************************************\nSAVE$END BAL   R14,QAMODE24             change to AMODE 24\n         CLOSE MF=(E,QCSAVE)            CLOSE HASPSAVE DCB\n         BAL   R14,QAMODE31             resume AMODE 31\n         SPACE 1\n         FREEPOOL  (R3)                 FREE ITS BUFFER POOL\n         SPACE 1\n         MVC   DA2CDDN,DCBDDNAM         GET THE DDNAME\n         DROPX R3                       IHADCB (HASPSAVE)\n         MVI   DAIRFLAG,X'2C'           INDICATE \"NOT_IN_USE\" FUNCTION\n         QCALL ALLOCATE                 CALL DAIR\n**LDW**  QCALL LISTDS                   GO BACK TO LISTDS\n**LDW**  B     QSTOP\n         TM    QMISCFLG,QMFATTN         USER PRESS ATTN?\n         BO    SAVEATTN                 YES - USE ALTERNATE MESSAGE\n         MVC   QERRMSG(3),=C'==='\n         CVD   R7,QNUMWORK              CONVERT NUMBER OF RECORDS SAVED\n         MVC   QERRMSG+4(11),=X'2020206B2020206B202120'\n         LA    R1,QERRMSG+3+12-1        PRESET SIGNIFICANCE POINTER\n         EDMK  QERRMSG+3(12),QNUMWORK+3 FILL IN NUMBER OF RECORDS SAVED\n         MVC   QERRMSG+4(12),0(R1)      SHIFT THE NUMBER OVER\n         LA    R15,QERRMSG+3+12         -> END OF NUMBER +1\n         SR    R15,R1                   COMPUTE LENGTH OF NUMBER\n         LA    R1,QERRMSG+4+1(R15)      -> LOC FOR NEXT PART OF MESSAGE\n         MVC   0(16,R1),=C'RECORDS SAVED IN'\n***      LA    R1,QERRMSG+13            -> WHERE DSNAME WILL GO\n         LA    R1,17(,R1)               -> WHERE DSNAME WILL GO\n         TM    DA08CTL,X'20'            WAS DSNAME ENTERED IN QUOTES?\n         BO    *+12                     NO - SKIP\n         MVI   0(R1),C''''              YES - PUT IN LEADING QUOTE\n         LA    R1,1(,R1)                AND BUMP OUTPUT PTR\n         MVC   0(44,R1),DSNAME+2        FILL IN DSNAME\n         AH    R1,DSNAME                -> PAST END OF DSNAME\n         TM    DA08CTL,X'20'            WAS DSNAME ENTERED IN QUOTES?\n         BO    *+12                     NO - SKIP\n         MVI   0(R1),C''''              YES - PUT IN LEADING QUOTE\n         LA    R1,1(,R1)                AND BUMP OUTPUT PTR\n         MVC   1(3,R1),=C'==='          END THE MESSAGE\n         QTILT *\nSAVEATTN NI    QMISCFLG,255-QMFATTN     RESET ATTN FLAG\n         QTILT '=== SAVE INCOMPLETE DUE TO ATTENTION ==='\nSV$TILT1 QTILT '=== YOU ARE NOT PROCESSING A VALID DATASET ==='\nSV$TILT3 QTILT '*** OUTPUT DSNAME MUST BE SPECIFIED ***',              $\n               OPTIONS=(REPROMPT,SET)\n         EJECT ,\n***********************************************************************\n*                                                                     *\n*   DCB EXIT FOR HASPSAVE DCB                                         *\n*                                                                     *\n***********************************************************************\n         PUSH  USING\n         DROP  ,\n         USING SAVE$DCB,R15\n         USING IHADCB,R1\n         USING QCOMMON,R11\nSAVE$DCB STM   R14,R12,12(R13)          SAVE OPEN'S REGS\n         LA    R6,1                     ASSUME PRE ALLOC DSN\n         CLI   DCBRECFM,0               ANY SPECIFIED?\n         BNE   SV$DCBGR                 YES, GOT RECFM\n         XR    R6,R6                    NEW DSN\n         MVC   DCBRECFM,QCRECFM         MOVE IN RECORD FORMAT\n         NI    DCBRECFM,DCBRECCC        TURN OFF EVERTHING BUT CCTL\n         OI    DCBRECFM,DCBRECF+DCBRECBR  SPECIFY RECFM = FB??\nSV$DCBGR LH    R2,DCBLRECL              ANY LRECL YET?\n         LTR   R2,R2                    SPECIFIED?\n         BNZ   SV$DCBGL                 YES, USE IT\n         XR    R6,R6                    MUST BE NEW DSN\n         LH    R2,QCLRECL               NO TRY RECORD LENGTH\n         LTR   R2,R2                    IS THE LRECL ZERO?\n         BNZ   SV$DCBGL                 NO. SKIP.\n         LA    R2,133                   YES. USE LRECL 133.\nSV$DCBGL STH   R2,DCBLRECL              STORE LRECL\n         LH    R5,DCBBLKSI              ANY BLOCKSIZE?\n         LTR   R5,R5                    IS IT A PREM DS?\n         BNZ   SV$DCBHB                 YES, GOT BLOCKSIZE\n         XR    R6,R6                    MUST BE NEW DSN\n*%       LH    R5,=H'6233'              DEFAULT TO 1/3 TRACK 3350\n         L     R5,DA08BLK               default to user-specified blksz\nSV$DCBHB TM    DCBRECFM,DCBRECU         RECFM=U?\n         BO    SV$DCBBL                 YES - JUST USE BLOCKSIZE\n         TM    DCBRECFM,DCBRECV         RECFM=V?\n         BO    SV$DCBRV                 YES, HANDLE IT\n         SR    R4,R4                    CLEAR FOR DIVIDE\n         DR    R4,R2                    DIVIDE BLKSIZE BY LRECL\n         MR    R4,R2                    MULTIPLY RESULT BY LRECL\n         B     SV$DCBBL\nSV$DCBRV LA    R2,4(,R2)                ADD IN SPACE FOR BDW\n         CR    R2,R5                    IS LRECL LARGER?\n         BNH   SV$DCBBL                 NO, THEN WE ARE OK\n         LTR   R6,R6                    WAS IT A PERM DS?\n         BNZ   SV$DCBBL                 YES, LEAVE AS ALLOCATED\n         OI    DCBRECFM,DCBRECSB        NO, MAKE SPANNED RECORDS\nSV$DCBBL STH   R5,DCBBLKSI              STORE BLKSIZE\n         LM    R14,R12,12(R13)          RESTORE OPEN'S REGS\n         XR    R15,R15                  CLEAR RET CODE\n         BR    R14                      RETURN TO CALLER\n         POP   USING\n         EJECT ,\n***********************************************************************\n*                                                                     *\n*   MISCELLANY                                                        *\n*                                                                     *\n***********************************************************************\nSAVE$OC  OC    DSNAME+2(*-*),0(R2)      << EXECUTED >>\n         SPACE 1\n         LTORG ,\n         DC    0F'0'\n         SPACE 1\nALLOCNEW DC    XL8'00'                  DDNAME\n         DC    2CL8' '                  UNIT & VOLSER\n         DC    F'6233,10,50,0'          BLKSIZE / PRI / SEC / DIR\n         DC    2CL8' '                  MEMBER & PASSWORD\n         DC    X'04'                    STAT=NEW\n         DC    2X'02'                   DISP=CATLG\n*        DC    X'B0'                    TRKS + PREFIX_USERID + RLSE\n         DC    X'70'                    blks + prefix_userid + rlse\n         DC    F'0',CL8' '              RESERVED + DSORG + ATTRLISTNAME\n         SPACE 1\nALLOCOLD DC    4F'0'                    BLKSIZE / PRI / SEC / DIR\n         DC    2CL8' '                  MEMBER & PASSWORD\n         DC    X'01'                    STAT=OLD\n         DC    2X'08'                   DISP=KEEP\n         DC    X'20'                    PREFIX_USERID TO DSNAME\n         SPACE 1\nSAVE@DCB DC    X'85',AL3(SAVE$DCB)      -> DCB EXIT FOR HASPSAVE\n         SPACE 2\n         ENTRY SV#KEYS\nSV#KEYS  DC    CL8'OLD     '\n         DC    CL8'MOD     '\n         DC    CL8'NEW     '\n         DC    CL8'NORLSE  '\n         DC    CL8'UNIT    '\n         DC    CL8'VOL     '\n         DC    CL8'START   '\n         DC    CL8'END     '\n         DC    CL8'STOP    '\n         DC    CL8'PRI     '\n         DC    CL8'SEC     '\n         DC    CL8'TRACK   ',CL8'TRK      '\n         DC    CL8'CYL     '\n         DC    CL8'BLK     '\n*%       DC    CL8'DIR'\n         DC    CL8'BLKSIZE ',CL8'BLKSZ    '\n         DC    X'FF'\n         SPACE 2\nWORK     DSECT\n         ORG   WORK+72                  SKIP OVER SAVE AREA\nSV@DWD   DS    D                        misc workarea\nSV@FIRST DS    PL4                      FIRST DS RECORD # TO SAVE\nSV@LAST  DS    PL4                      LAST  DS RECORD # TO SAVE\nSV@FLAGS DS    B\nSV@DISP  EQU   X'80'                    DISPOSITION FOUND\nSV@RANGE EQU   X'40'                    LINE NUMBER RANGE SPECIFIED\nSV@SPACE EQU   X'20'                    unit of space specified\nSV@SPC#  EQU   X'10'                    quantity of space specified\nSV@BLKSZ DS    F                        max blksize for NEW output ds\nDSNAME   DS    H\n         DS    CL44\nSV@WORKL EQU   *-WORK\n         DS    0F\nBUFFRDW  DS    2H                       OPTIONAL RDW\nBUFFER   DS    CL256                    OUTPUT BUFFER\n         SPACE 3\n         DROPX R13                      WORK\n         SPACE 3\n         QCOMMON\n         QDCB  ,                        ADDED FOR DCB EQUATES\n         SPACE 3\n         Q$LRC\n         Q$PDDB\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "Q#SY": {"ttr": 16393, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x0b\\x00\\x00\\x00\\x82#/\\x00\\x896\\x0f\\x00\\x02\\x00\\xf6\\x00\\xc2\\x00W\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "05.11", "flags": 0, "createdate": "1982-08-20T00:00:00", "modifydate": "1989-12-26T00:02:00", "lines": 246, "newlines": 194, "modlines": 87, "user": "LDW"}, "text": "         TITLE '--- QUEUE--SYSLIST -- LIST M.A.S. SYSTEMS STATUS ---'\n*---------------------------------------------------------------------*\n*                                                                     *\n*   SYSLIST - Display information on each system in a multi-access    *\n*             complex                                                 *\n*                                                                     *\n*   Note - This subcommand is restricted to privileged users          *\n*                                                                     *\n*   Updates:                                                          *\n*      25Dec89  LDW  Q$CVT -> QZCVT                                   *\n*      23Nov89  LDW  Eliminate \"LC\" macro usage                       *\n*      03/31/86 LDW  RE-DESIGN 3278-5 SUPPORT (THIRD TRY!)            *\n*      12/04/84 EMS  DISPLAY JULIAN DATE IN ADDITION TO GREGORIAN DATE*\n*      01/19/83 LDW  DISPLAY BOTH TRUE SMF SYS ID AND TRANSLATED VALUE*\n*                    CHANGE HEADER AND OTHER MSGS TO LOWER CASE       *\n*                    USE QSENO INSTEAD OF QSELAST                     *\n*      12/23/82 LDW  CHANGE MANNER OF DISPLAYING SELECTED SYSTEM      *\n*      10/28/82 LDW  DISPLAY CURRENT TIME LAST INSTEAD OF FIRST       *\n*                    INDICATE WHICH SYSTEM IS THE SELECTED ONE        *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 3\nSYSLIST  QSTART  ,\n         USING WORK,R13\n         QCALL CKPT                     READ CHECKPOINT DATA\n         QCALL DISP80                   SWITCH TO 3278-2 MODE IF 3278-5\n         MVC   QDHLINE(L'SY#HDR),SY#HDR MOVE IN HEADER\n         L     R6,QCJQTL                -> I/O AREA\n         USING $SAVEBEG,R6\n         LA    R7,$SAVEEND              -> FIRST QSE\n         USING QSEDSECT,R7\n         LA    R9,QSYSID+L'QSYSID       -> SYSTEM ID TABLE\n         LH    R10,$QSENO               NUMBER OF QSE'S\n*---  IT'S AMAZING THAT A ROUTINE THIS SHORT COULD USE 16 REGISTERS!!!\n         SPACE 2\nSY$LOOP  MVC   SY@SMFID,QSESID          MOVE SMF ID\n         MVC   SY@SYS,0(R9)             MOVE TRANSLATED SYSTEM ID\n         MVC   SY@TOD,QSESITIM          GET TOD OF LAST CKPT\n         BAL   R8,SY$FMTOD              FORMAT IT\n         TM    QSESTAT,QSEACTIV         IS THIS SYSTEM ACTIVE?\n         BNO   *+10                     NO - SKIP\n         MVC   SY@STAT(6),SY#ACTIV      'ACTIVE'\n         TM    QSESTAT,QSEQUICK\n         BNO   *+10\n         MVC   SY@STAT+8(12),SY#WARM    'WARM STARTED'\n         IC    R1,QSESTAT\n         N     R1,=F'7'\n         SLA   R1,3                     LENGTH OF QSYSID\n         BZ    SY$NESYS\n         AL    R1,QVSYSID               -> SYSTEM ID DOING $ESYS\n         MVC   SY@STAT+21(4),0(R1)\n         MVC   SY@STAT+26(11),SY#ESYS   'DOING $ESYS'\n         CLI   QCOMCHAR,X'EE'           VALID COMCHAR?\n         BE    *+10                     NO - SKIP\n         MVC   SY@STAT+32(1),QCOMCHAR   YES - USE IT INSTEAD OF '$'\n         SPACE 1\nSY$NESYS BAL   R14,QADDLINE             DISPLAY THIS LINE\n         LA    R7,QSELEN(,R7)           -> NEXT QSE\n         LA    R9,L'QSYSID(,R9)         -> NEXT SYSTEM ID ENTRY\n         BCT   R10,SY$LOOP              PROCESS ALL QSE'S\n         SPACE 2\n         BAL   R14,QADDLINE             PUT OUT A BLANK LINE\n         MVC   SY@STAT(12),SY#CTIME     'CURRENT TIME'\n         STCK  SY@TOD\n         BZ    SY$TODOK                 SKIP IF GOOD\n         MVC   SY@DAY(18),SY#TODNU      'TOD CLOCK UNUSABLE'\n         B     SY$TODXX\n         SPACE 2\nSY$TODOK BAL   R8,SY$FMTOD              FORMAT CURRENT TIME\nSY$TODXX BAL   R14,QADDLINE             DISPLAY THIS LINE\n         BAL   R14,QADDLINE             AND A BLANK LINE\n         MVC   QDMSG(35),SY#ONMSG       'YOU ARE ON ...'\n         MVC   QDMSG+18(4),QSYSID       MOVE IN CURRENT TRANSLATED ID\n         MVC   QDMSG+30(4),QSMFID       MOVE IN CURRENT SMF SYSTEM ID\n         BAL   R14,QADDLINE             DISPLAY THIS LINE\n         B     QSTOP\n         SPACE 3\n*** TOD CLOCK CONVERT TO PRINTABLE ROUTINE FROM VM/CP\nSY$FMTOD LM    R0,R1,SY@TOD             GET TOD CLOCK VALUE\n         L     R15,16                   -> CVT\n         AL    R0,X'130'(,R15)          CVTTZ = TIME ZONE ADJUSTMENT\n         SRDL  R0,12                    CONVERT TO MICROSECONDS\n         D     R0,=F'8000000'           GET NUMBER OF SECONDS BY THE\n         LR    R3,R0                    FOLLOWING DOUBLE PRECISION\n*                                       DIVISION:\n         SLR   R2,R2                    X/Y=8*(X/(8*Y))+MOD(X,8*Y)/Y\n         D     R2,=F'1000000'           WHERE X = NUMBER OF MICRO-\n         SLR   R0,R0                              SECONDS SINCE EPOCH\n         SLDL  R0,3                           Y = 1000000\n         ALR   R1,R3                    ...\n         BC    12,*+8                   ...\n         A     R0,=F'1'                 R0 - R1 = # OF SECS SINCE EPOCH\n         D     R0,=F'86400'             R1 = # OF DAYS SINCE EPOCH     *\n                                        R0 = # OF SECONDS PAST MIDNIGHT\n         ST    R0,SY@MNSEC              SAVE SECONDS PAST MIDNIGHT\n         SPACE 1\n         LA    R3,365\n         CR    R1,R3                    IS DAYS .LT. 365 ?\n         BNL   SY$N1900                 NO\n         LR    R4,R1                    GET NUMBER OF DAYS HERE\n         SLR   R1,R1                    INDICATE YEAR = 00\n         B     SY$YRSET\n         SPACE 1\nSY$N1900 EQU   *                        HERE IF YEAR GREATER THAN 1900\n         SR    R1,R3                    SUBTRACT THE YEAR 1900 OUT\n         SLR   R0,R0                    CLEAR FOR DIVIDE\n         D     R0,=A(4*365+1)           DIVIDE BY # OF DAYS IN 4 YEARS\n         LR    R5,R0                    R5 = # OF DAYS SINCE LAST LEAP\n         SLR   R4,R4\n         DR    R4,R3\n         A     R4,=F'1'                 # OF DAYS SINCE START OF YEAR\n         C     R5,=F'4'                 EXACTLY A MULTIPLE OF 4 YEARS ?\n         BNE   SY$NQUAD                 NO\n         AR    R4,R3                    SET DAY .EQ. 366\n         L     R5,=F'3'                 ...\n         SPACE 1\nSY$NQUAD EQU   *\n         ALR   R1,R1\n         ALR   R1,R1\n         A     R1,=F'1'\n         AR    R1,R5\n         SPACE 1\nSY$YRSET EQU   *                   HERE WHEN YEAR HAS BEEN DETERMINED\n         CVD   R1,SY@TEMP               CONVERT DATE TO DECIMAL\n         UNPK  SY@DATE+6(2),SY@TEMP+6(2) UNPACK AND\n         OI    SY@DATE+7,X'F0'          FORMAT IT\n         CVD   R4,SY@TEMP               CONVERT DAY TO DECIMAL     EMS\n         UNPK  SY@DAYS,SY@TEMP+6(2)     UNPACK AND                 EMS\n         OI    SY@DAYS+2,C'0'           FORMAT IT                  EMS\n         MVI   SY@DOT,C'.'              INSERT DOT BETWEEN         EMS\n         SPACE 1\n*                                       HERE TO SET WEEKDAY\n         SLR   R2,R2                    CLEAR\n         LR    R14,R2\n         LR    R3,R1                    GET YEAR\n         BCTR  R3,0                     YEAR-1\n         LR    R15,R3                   YEAR-1\n         SRL   R15,2                    (YEAR-1)/4\n         N     R3,=F'3'                 (YEAR-1) MOD 4\n         MH    R15,=H'5'                ((YEAR-1)/4)*5)\n         AR    R15,R3                   ((YEAR-1)/4)*5)+(YEAR-1) MOD 4\n         AR    R15,R4                   ... + DAYS\n         D     R14,=F'7'                DIVIDE BY 7\n         MH    R14,=H'9'                INDEX INTO TABLE\n         LA    R14,SY#DAYS(R14)         ...\n         MVC   SY@DAY(9),0(R14)         SET NAME OF DAY\n         SPACE 1\n*              HERE TO CONVERT JULIAN DATE TO GREGORIAN\n         SPACE 1\n* THE FOLLOWING ALGORITHM TO CONVERT A JULIAN DATE TO GREGORIAN WAS\n* ADOPTED FROM AN ALGORITHM ENTITLED \"TABLELESS DATE CONVERSION\"\n* APPEARING IN \"COMMUNICATIONS OF THE ACM\", VOLUME 13, NUMBER 10,\n* OCTOBER 1970, P. 621, BY RICHARD A. STONE, WESTERN ELECTRIC COMPANY,\n* P.O. BOX 900, PRINCETON, NJ 08540.\n         N     R1,=F'3'                 YEAR MOD 4\n         BNZ   *+8                      BRANCH IF NOT A LEAP YEAR\n         LA    R2,1                     GET GREGORIAN DATE FROM JULIAN\n         LA    R1,59(,R2)               ...\n         CR    R4,R1                    ...\n         BNH   *+10                     ...\n         A     R4,=F'2'                 ...\n         SR    R4,R2                    ...\n         A     R4,=F'91'                ...\n         LR    R1,R4                    ...\n         M     R0,=F'100'               ...\n         D     R0,=F'3055'              ...\n         LR    R15,R1                   ...\n         M     R14,=F'3055'             ...\n         D     R14,=F'100'              ...\n         SR    R4,R15                   ...\n         BCTR  R1,0                     ...\n         BCTR  R1,0                     ...\n         CVD   R4,SY@TEMP               CONVERT DAY TO DECIMAL\n         UNPK  SY@DATE+3(2),SY@TEMP+6(2) UNPACK AND\n         OI    SY@DATE+4,X'F0'          FORMAT IT\n         MVI   SY@DATE+5,C'/'\n         CVD   R1,SY@TEMP               CONVERT MONTH TO DECIMAL\n         UNPK  SY@DATE(2),SY@TEMP+6(2) UNPACK AND\n         OI    SY@DATE+1,X'F0'          FORMAT IT\n         MVI   SY@DATE+2,C'/'\n* NOW THAT DAY AND DATE HAVE BEEN FORMATTED, LET'S FORMAT TIME OF DAY\n         L     R1,SY@MNSEC              SECONDS PAST MIDNIGHT\n         SR    R0,R0                    CLEAR FOR DIVIDE\n         D     R0,=F'3600'              GET # OF HOURS PAST MIDNIGHT\n         CVD   R1,SY@TEMP               CONVERT # OF HOURS TO DECIMAL\n         LA    R15,SY@TIME              POINT TO OUTPUT AREA\n         UNPK  0(4,R15),SY@TEMP+6(3)    UNPACK\n         MVI   2(R15),C':'              NEATEN UP\n         LR    R1,R0                    GET REMAINDER FROM LAST DIVIDE\n         SR    R0,R0                    CLEAR\n         D     R0,=F'60'                GET # OF MINUTES PAST THIS HOUR\n         CVD   R1,SY@TEMP               CONVERT # OF MINUTES TO DECIMAL\n         UNPK  3(4,R15),SY@TEMP+6(3)    UNPACK\n         MVI   5(R15),C':'              NEATEN UP\n         CVD   R0,SY@TEMP               CONVERT # OF SECONDS TO DECIMAL\n         UNPK  6(2,R15),SY@TEMP+6(2)    UNPACK\n         OI    7(R15),X'F0'           MAKE UP FOR HARDWARE DEFICIENCIES\n         BR    R8                       RETURN TO MAINLINE\n         SPACE 2\n         DROP  R13,R7,R6\n         SPACE 2\n         LTORG\n         SPACE 2\nSY#HDR   DC    C'SMFID SYS     Last Checkpoint Timestamp      Status'\n         SPACE 2\nSY#ACTIV DC    C'Active'\nSY#WARM  DC    C'Warm started'\nSY#ESYS  DC    C'Doing $ESYS'\nSY#CTIME DC    C'Current time'\nSY#TODNU DC    C'TOD clock unusable'\nSY#ONMSG DC    C'You are on system xxxx (SMFid=xxxx)'\n         SPACE 2\nSY#DAYS  DC    CL9'Monday'\n         DC    CL9'Tuesday'\n         DC    CL9'Wednesday'\n         DC    CL9'Thursday'\n         DC    CL9'Friday'\n         DC    CL9'Saturday'\n         DC    CL9'Sunday'\n         SPACE 3\nWORK     DSECT\n         ORG   WORK+72\nSY@TEMP  DS    D\nSY@TOD   DS    D\nSY@MNSEC DS    F                        SECONDS PAST MIDNIGHT\n         SPACE 2\n         QCOMMON\n         SPACE 1\n         ORG   QDMSG\nSY@SMFID DS    CL4\n         DS    CL2\nSY@SYS   DS    CL4\n         DS    CL2\nSY@DAY   DS    CL9\n         DS    C\nSY@DATE  DS    CL8'MM/DD/YY'\nSY@DOT   DC    C'.'                                                EMS\nSY@DAYS  DS    CL3'DDD'                                            EMS\n         DS    C\nSY@TIME  DS    CL8'HH:MM:SS'\n         DS    CL2\nSY@STAT  DS    CL37\n         SPACE 2\n         Q$HCT\n         Q$QSE\n         QZCVT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "Q#TC": {"ttr": 16644, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x0e\\x00\\x00\\x00\\x82#/\\x00\\x91\\x18_ G\\x00v\\x00#\\x00]\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "05.14", "flags": 0, "createdate": "1982-08-20T00:00:00", "modifydate": "1991-07-04T20:47:00", "lines": 118, "newlines": 35, "modlines": 93, "user": "LDW"}, "text": "         TITLE '--- QUEUE--TSOCMD -- ATTACH A TSO COMMAND ---'\n*---------------------------------------------------------------------*\n*                                                                     *\n*   TSOCMD - Execute a TSO command or CLIST without leaving QUEUE     *\n*                                                                     *\n*   Note - This subcommand may be executed in a QUEUE profile         *\n*                                                                     *\n*   Updates:                                                          *\n*      29Jan91  LDW  Move QCLRSCR from QCOMMON to here; rename it to  *\n*                       CLEARSCR                                      *\n*                    Move conditional assembly to insure CLEARSCR is  *\n*                       assembled                                     *\n*      05/01/85 LDW  REMOVE INITIAL=YES TO MAKE SESSION MANAGER HAPPY *\n*      06/12/84 LDW  PUT MORE INFO IN 'DONE' MSG                      *\n*      04/16/84 LDW  DON'T STACK THIS SUBCOMMAND                      *\n*      02/28/84 SDM  SCAN TRAILING BLANKS OFF OF COMMAND              *\n*      02/05/84 LDW  MAKE TCAM FAKE SIMATTN 'ASIS'                    *\n*      01/20/84 LDW  ADD SUPPORT FOR COMMAND STACKING                 *\n*                    IF TCAM, WAIT FOR RESPONSE, TO AVOID OVERWRITING *\n*                       LINE OUTPUT                                   *\n*      07/25/83 LDW  ADD INITIAL=YES TO STFSMODE, TO ACT LIKE ISPF    *\n*      01/14/83 LDW  SET QTSOCMD FOR REPROMPTING                      *\n*      01/10/83 LDW  PUT BACK QTILT NOW THAT IT DOESN'T CLEAR SCREEN  *\n*      01/06/83 LDW  CHANGE ERROR MESSAGE TEXT                        *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 3\nTSOCMD   QSTART  Q88      ,STACK=X'B0'\n          AIF   (NOT &@@TMPSV).TC01     SKIP IF DON'T HAVE TMPSRV\n         USING WORK,R13\n         SPACE 1\n         MVC   QDPROMPT,QDREPLY         SET WHAT TO REPROMPT WITH\n         LH    R4,QOFF1                 OFFSET OF FIRST BYTE OF PARM\n         LTR   R4,R4                    DID PARSE FIND ANYTHING?\n         BNP   TC$TILT                  NO - ABORT\n         MVC   QTSOCMD,QDREPLY          SAVE FOR REPROMPTING\n         BAL   R8,TC$CLEAR              ERASE THE SCREEN\n         LA    R2,QDREPLY               -> REPLY\n         AR    R2,R4                    -> FIRST BYTE OF PARM\n         LA    R3,QDREPLY+QDREPLYL-1    -> LAST CHARACTER\n         CLI   0(R3),C' '               TRAILING BLANK?\n         BNE   *+8                      NO, FOUND END OF COMMAND\n         BCT   R3,*-8                   YES, DECREMENT AND LOOP\n         LA    R3,1(,R3)                -> LAST CHARACTER + 1\n         SR    R3,R2                    LENGTH OF OPERAND\n         SPACE 1\n         TMPMAC  CMD=((R2),(R3)),MF=(E,TCTMPMAC)  DO IT\n         SPACE 1\n         STFSMODE  ON                   TELL VTAM WE'RE BACK\n         SPACE 1\n         TM    QTERMFLG,QTFVTAM         VTAM TERMINAL?\n         BO    TC$VTAM                  YES - SKIP\n         LA    R1,=C'***'               FAKE THE SIMATTN\n         TPUT  (1),3,ASIS               PUT IT OUT\n         LA    R1,TCTMPMAC              USE ANY OLD TGET AREA\n         LA    R0,1                     LENGTH IS IRRELEVANT\n         ICM   R1,B'1000',=X'80'        INDICATE TGET\n         TGET  (1),(0),R                WAIT FOR ENTER\n         TCLEARQ  INPUT                 AND FLUSH EXTRA INPUT\n         SPACE 2\nTC$VTAM  MVC   QERRMSG(43),=C'=== TSO COMMAND COMPLETE -- RC=XXXXXXXX =$\n               =='\n         L     R1,DAPLECT               -> ECT\n         HEX   QERRMSG+31,(0,R1),LEN=4,HEXTAB=QHEXTAB  ECTRCDF\n         QTILT *\n         SPACE 2\nTC$TILT  QTILT '*** TSO COMMAND REQUIRED AS OPERAND ***',              $\n               OPTIONS=REPROMPT\n         SPACE 2\n.TC01     ANOP\n***********************************************************************\n*                                                                     *\n*   CLEAR THE SCREEN (TCAM), OR LINES 3 TO END OF SCREEN (VTAM)       *\n*                                                                     *\n***********************************************************************\nCLEARSCR QSTART  TYPE=ENTRY\n         BAL   R8,TC$CLEAR              clear the screen\n         B     QSTOP                    all done\n         SPACE 3\nTC$CLEAR TM    QTERMFLG,QTFTTY          FULLSCREEN TERMINAL?\n         BOR   R8                       NO - JUST RETURN\n         LA    R1,TC#CLEAR              -> MESSAGE\n         LA    R0,TC#CLRL               LENGTH\n         MVC   QD3270OP,QDERASE         SET ERASE WRITE 3270 OPCODE\n         TM    QTERMFLG,QTFVTAM         VTAM TERMINAL?\n         BO    TC$CLR2                  YES - DO IT THAT WAY\n         ICM   R1,B'1000',=X'03'        SET FULLSCR FLAG\n         TPUT  (1),(0),R                CLEAR BOTTOM OF SCREEN\n         BR    R8                       RETURN TO CALLER\n         SPACE 2\nTC$CLR2  ICM   R1,B'1000',=X'0B'        SET FULLSCR & HOLD FLAGS\n         TPUT  (1),(0),R                CLEAR BOTTOM OF SCREEN\n         SPACE 1\n         STLINENO  LINE=3,MODE=OFF      TELL VTAM WE'RE TAKING A BREAK\n         SPACE 1\n         TCLEARQ  INPUT                 THROW AWAY SPURIOUS RESHOW CODE\n         SPACE 1\n         BR    R8                       RETURN TO CALLER\n         SPACE 1\n*  SPF TCAM SEQUENCE TO CLEAR FROM LINE 3 TO END OF SCREEN\nTC#CLEAR DC    X'C1'                    WCC: RESET MDT\n         DC    X'115D7E'                SPF-TCAM PREFIX -> LAST FULLSCR\n*                                       (INCLUDES NEXT SBA)\n         DC    X'11C260'                NEXT OUTPUT TO 3RD SCREEN LINE\n         DC    X'3C404000'              RA TO BEGINNING OF SCREEN\n         DC    X'11C260'                BACK TO 3RD SCREEN LINE\n         DC    X'13'                    DROP ANCHOR HERE\nTC#CLRL  EQU   *-TC#CLEAR               LENGTH OF THIS ROT\n         SPACE 3\n         DROP  R13\n         SPACE 3\n         LTORG ,\n         SPACE 3\n         QCOMMON\n         SPACE 3\nWORK     DSECT\n         ORG   WORK+72                  SKIP OVER SAVE AREA\nTCTMPMAC TMPMAC  MF=L\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "Q#TC@": {"ttr": 16647, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x0c\\x00\\x00\\x00\\x82#/\\x00\\x85\\x12\\x1f\\x12I\\x00M\\x00#\\x001\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "05.12", "flags": 0, "createdate": "1982-08-20T00:00:00", "modifydate": "1985-05-01T12:49:00", "lines": 77, "newlines": 35, "modlines": 49, "user": "LDW"}, "text": "          AIF   (NOT &QTMPMAC).TSOCMDX  SKIP IF DON'T HAVE TMPSRV\n         TITLE '--- QUEUE--TSOCMD -- ATTACH A TSO COMMAND ---'\n*---------------------------------------------------------------------*\n*                                                                     *\n*   TSOCMD - EXECUTE A TSO COMMAND OR CLIST WITHOUT LEAVING QUEUE     *\n*                                                                     *\n*   NOTE - THIS SUBCOMMAND MAY BE EXECUTED IN A QUEUE PROFILE         *\n*                                                                     *\n*   UPDATES:                                                          *\n*      05/01/85 LDW  REMOVE INITIAL=YES TO MAKE SESSION MANAGER HAPPY *\n*      06/12/84 LDW  PUT MORE INFO IN 'DONE' MSG                      *\n*      04/16/84 LDW  DON'T STACK THIS SUBCOMMAND                      *\n*      02/28/84 SDM  SCAN TRAILING BLANKS OFF OF COMMAND              *\n*      02/05/84 LDW  MAKE TCAM FAKE SIMATTN 'ASIS'                    *\n*      01/20/84 LDW  ADD SUPPORT FOR COMMAND STACKING                 *\n*                    IF TCAM, WAIT FOR RESPONSE, TO AVOID OVERWRITING *\n*                       LINE OUTPUT                                   *\n*      07/25/83 LDW  ADD INITIAL=YES TO STFSMODE, TO ACT LIKE ISPF    *\n*      01/14/83 LDW  SET QTSOCMD FOR REPROMPTING                      *\n*      01/10/83 LDW  PUT BACK QTILT NOW THAT IT DOESN'T CLEAR SCREEN  *\n*      01/06/83 LDW  CHANGE ERROR MESSAGE TEXT                        *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 3\nTSOCMD   QSTART  Q88      ,STACK=X'B0'\n         USING WORK,R13\n         SPACE 1\n         MVC   QDPROMPT,QDREPLY         SET WHAT TO REPROMPT WITH\n         LH    R4,QOFF1                 OFFSET OF FIRST BYTE OF PARM\n         LTR   R4,R4                    DID PARSE FIND ANYTHING?\n         BNP   TC$TILT                  NO - ABORT\n         MVC   QTSOCMD,QDREPLY          SAVE FOR REPROMPTING\n         BAL   R8,QCLRSCR               ERASE THE SCREEN\n         LA    R2,QDREPLY               -> REPLY\n         AR    R2,R4                    -> FIRST BYTE OF PARM\n         LA    R3,QDREPLY+QDREPLYL-1    -> LAST CHARACTER\n         CLI   0(R3),C' '               TRAILING BLANK?\n         BNE   *+8                      NO, FOUND END OF COMMAND\n         BCT   R3,*-8                   YES, DECREMENT AND LOOP\n         LA    R3,1(,R3)                -> LAST CHARACTER + 1\n         SR    R3,R2                    LENGTH OF OPERAND\n         SPACE 1\n         TMPMAC  CMD=((R2),(R3)),MF=(E,TCTMPMAC)  DO IT\n         SPACE 1\n         STFSMODE  ON                   TELL VTAM WE'RE BACK\n         SPACE 1\n         TM    QTERMFLG,QTFVTAM         VTAM TERMINAL?\n         BO    TC$VTAM                  YES - SKIP\n         LA    R1,=C'***'               FAKE THE SIMATTN\n         TPUT  (1),3,ASIS               PUT IT OUT\n         LA    R1,TCTMPMAC              USE ANY OLD TGET AREA\n         LA    R0,1                     LENGTH IS IRRELEVANT\n         ICM   R1,B'1000',=X'80'        INDICATE TGET\n         TGET  (1),(0),R                WAIT FOR ENTER\n         TCLEARQ  INPUT                 AND FLUSH EXTRA INPUT\n         SPACE 2\n*TC$VTAM QTILT '=== DONE ==='  ,STOP\n*        B     QSTOP\nTC$VTAM  MVC   QERRMSG(43),=C'=== TSO COMMAND COMPLETE -- RC=XXXXXXXX =$\n               =='\n         L     R1,DAPLECT               -> ECT\n         HEX   QERRMSG+31,(0,R1),LEN=4,HEXTAB=QHEXTAB  ECTRCDF\n         QTILT *\n         SPACE 2\nTC$TILT  QTILT '*** TSO COMMAND REQUIRED AS OPERAND ***',              $\n               OPTIONS=REPROMPT\n         SPACE 2\n         DROP  R13\n         SPACE 3\n         LTORG ,\n         SPACE 3\n         QCOMMON\n         SPACE 3\nWORK     DSECT\n         ORG   WORK+72                  SKIP OVER SAVE AREA\nTCTMPMAC TMPMAC  MF=L\n.TSOCMDX  ANOP\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "Q#TG": {"ttr": 16650, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x87\\x01\\x7f\\x00\\x892\\x7f\"\\x18\\x01$\\x01\\x05\\x00\\n\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1987-01-17T00:00:00", "modifydate": "1989-11-23T22:18:00", "lines": 292, "newlines": 261, "modlines": 10, "user": "LDW"}, "text": "         TITLE '--- QUEUE--TGPS -- LIST JOBS WITH MOST TRK GRPS  ---'\n*---------------------------------------------------------------------*\n*                                                                     *\n*   TGPS - List jobs with highest spool utilization                   *\n*                                                                     *\n*   Note - This subcommand is restricted to privileged users          *\n*                                                                     *\n*   Updates:                                                          *\n*      23Nov89  LDW  Remove conditional assembly around Qxxx macros   *\n*      22Jul87  LDW  Fix for TG num used being in JQE extension       *\n*      17Jan87  LDW  Ripped off from JESMODS.FILE53(TGPS)             *\n*                                                                     *\n*---------------------------------------------------------------------*\n         SPACE 3\nTGPS     QSTART  WORKLEN=TG@WORKL\n         USNGX WORK,R13                 LOCAL WORK AREA\n         QCALL CKPT                     READ CHECKPOINT DATA\n         QCALL DISP80                   SWITCH TO 3278-2 MODE IF 3278-5\n*\n         XC    TG@JQES(L'TG@JQES),TG@JQES  CLEAR JQE AREA\n         MVC   TG@TGS,TG#ACCUM          PRIME TRACK GROUPS ACCUMULATORS\n         XC    TG@TOTTG,TG@TOTTG        CLEAR ACCUMULATOR\n         XC    TG@TOTJB,TG@TOTJB        CLEAR ACCUMULATOR\n         L     R1,QCJQTL                POINT TO HCT SAVEAREA\n         USNGX $SAVEBEG,R1              SET ADDRESSING\n*%%      LA    R3,$JQHEADS-QUENEXT      POINT TO FIRST QHEAD\n         LA    R3,$JQHEADS-(JQENEXT-JQEDSECT)  POINT TO FIRST QHEAD\n         LA    R4,$JQHEADL              SIZE OF EACH QHEAD\n*%%      LA    R5,$JQHEADS-QUENEXT+($JQTYPES*$JQHEADL)-1 END OF HEADS\n         LA    R5,$JQHEADS-(JQENEXT-JQEDSECT)+($JQTYPES*$JQHEADL)-1\n         DROPX R1                       $SAVEBEG\nTG$NXQHD LR    R6,R3                    POINT TO NEXT QHEAD\n         USNGX JQEDSECT,R6\nTG$JQELP QNEXT R6,JQENEXT,NONE=TG$STEPQ GET CHAIN FIELD\n         LR    R2,R6                    SAVE OFFSET FOR TEST\n         A     R6,QCJQTA                CALCULATE FULL ADDRESS\n          AIF   (&QLEVEL GE 7).TG01\n         OC    JQETRAK,JQETRAK          ANY JCT/IOT?\n         BZ    TG$JQELP                 NO, SKIP THIS ONE\n***********************************************************************\n*                                                                     *\n*   READ JCT AND IOT                                                  *\n*                                                                     *\n***********************************************************************\n         ST    R6,QCJQEA                SAVE THE ADDRESS\n         MVC   QCTRAK,JQETRAK           DISK ADDR OF JCT\n         L     R1,QCJCTA                ADDR OF IOAREA FOR JCT\n         LR    R7,R1                    BASE FOR JCT\n         USNGX JCTSTART,R7              BASE REG FOR JCT\n*???     MVC   QCCBID,=C'JCT '          SHOW WHAT WE NEED\n         MVC   QCCBID,QBLANK            WE'LL TAKE ANYTHING???\n         QCALL READSPC                  ROUTINE TO READ HASPACE\n         CLC   JCTID,=C'JCT '           WAS A JCT READ FROM SPOOL ?\n         BNE   TG$JQELP                 NO, SKIP THIS JQE\n         C     R2,JCTJQE                DOES JCT POINT TO THIS JQE?\n         BNE   TG$JQELP                 NO, SKIP THIS JQE\n         SR    R2,R2                    CLEAR FOR COUNTER\n         MVC   QPJOBID,JCTJBKEY         JOB IDENTIFICATION\n         ICM   R15,15,JCTSPIOT          GET SPIN IOT ADDRESS\n         BZ    TG$IOTJB                 NONE, GET JOBS IOT\n         USNGX IOTSTART,R7              ADDRESSING FOR IOT\nTG$SPILP ST    R15,QCTRAK               SET ADDRESS FOR READSPC\n         BAL   R8,TG$PROCI              PROCESS THE IOT\n         ICM   R15,15,IOTIOTTR          POINT TO NEXT IOT\n         BNZ   TG$SPILP                 LOOP IF MORE IOTS\nTG$IOTJB L     R7,QCJCTA                RESTORE JCT ADDRESS\n         USNGX JCTSTART,R7              AND ADDRESSING\n         ICM   R15,15,JCTIOT            GET MAIN IOT ADDRESS\n         BZ    TG$TEST                  NONE, TEST COUNT OF TGPS\n         ST    R15,QCTRAK               SET ADDRESS FOR READSPC\n         BAL   R8,TG$PROCI              PROCESS THE IOT\n          AGO   .TG02\n.TG01     ANOP\n         LH    R2,JQETGNUM              NUMBER OF TRACK GROUPS\n         TM    JQEFLAG5,JQE5XUSD        using extension for TG count?\n         BZ    TG$TEST                  no - all set\n         AL    R2,QCJQEXA               Add JQE extension base\n         LH    R2,0(,R2)                Get number of allocated TG's\n.TG02     ANOP\nTG$TEST  LTR   R2,R2                    TEST FOR TGPS\n         BNP   TG$JQELP                 NONE, SKIP THIS JQE\n         LR    R14,R2                   NUMBER OF TRACK GROUPS\n         A     R14,TG@TOTTG             ADD TO ACCUMULATOR\n         ST    R14,TG@TOTTG             AND RESAVE\n         LA    R14,1                    BUMP TOTAL\n         A     R14,TG@TOTJB               NUMBER OF\n         ST    R14,TG@TOTJB                 JOBS\n         SPACE 1\n         LA    R14,TG@TGS+L'TG@TGS-8    POINT TO LAST ENTRY\n         LA    R15,L'TG@TGS/8           NUMBER OF ENTRIES\n         LA    R1,8                     SIZE OF AN ENTRY\nTG$TEST1 C     R2,0(,R14)               COMPARE TRK GRPS WITH SLOT SIZE\n         BNH   TG$TEST5                 YES, INSERT IT HERE\n         SR    R14,R1                   BACK UP TO PREV ENTRY\n         BCT   R15,TG$TEST1             LOOP THROUGH ELEMENTS\n         B     TG$TEST9                 NONE, SKIP INCREMENT\n         SPACE 1\nTG$TEST5 LA    R15,1                    SET FOR INCREMENT\n         A     R15,4(,R14)              INCREMENT COUNT\n         ST    R15,4(,R14)              AND SAVE NEW COUNT\n         SPACE 1\nTG$TEST9 DS    0H\n         LA    R14,TG@JQES+L'TG@JQES-8  POINT TO LAST ENTRY\n         LA    R15,L'TG@JQES/8          NUMBER OF ENTRIES\n         LA    R1,8                     SIZE OF AN ENTRY\nTG$SCAN  C     R2,4(,R14)               SEE IF NEW IS BIGGER\n         BNL   TG$INSRT                 YES, INSERT IT HERE\n         SR    R14,R1                   BACK UP TO PREV ENTRY\n         BCT   R15,TG$SCAN              LOOP THROUGH ELEMENTS\n         B     TG$JQELP                 GO TRY NEXT JQE\n         SPACE 1\nTG$INSRT BCTR  R15,0                    DROP BY ONE\n         SLL   R15,3                    TIMES 8 (LENGTH OF ENTRY)\n         BCTR  R15,0                    -1 FOR EXECUTE\n         LTR   R15,R15                  TEST FOR VALID\n         BNP   TG$NO$MV                 NO, JUST DO THE INSERT\n         EX    R15,TG$MVC               MOVE ENTRIES DOWN\nTG$NO$MV ST    R6,0(,R14)               SAVE JQE ADDRESS\n         ST    R2,4(,R14)               SAVE # OF TRACK GROUPS\n         B     TG$JQELP                 TRY NEXT JQE\n         SPACE 1\nTG$MVC   MVC   TG@JQES(*-*),TG@JQES+8   << EXECUTED >>\n         SPACE 1\nTG$STEPQ BXLE  R3,R4,TG$NXQHD           STEP TO NEXT QHEAD\n         DROPX R6                       DROP OLD JQE REG\n         SPACE 1\n         LA    R2,TG@JQES+L'TG@JQES-8   POINT TO LAST ENTRY\n         LA    R3,L'TG@JQES/8           NUMBER OF ENTRIES\n         LA    R4,8                     SIZE OF EACH ENTRY\n         MVC   QDHLINE,=CL79'   Jobid Jobname     TGPs   Pct           $\n                 |                TGPs    Jobs   Pct'\n         SPACE 1\nTG$PR$LP L     R5,0(,R2)                JQE ADDRESS\n         USNGX JQEDSECT,R5              ADDRESSING\n         MVC   QDMSG,QBLANK             BLANK THE TEXT AREA\n         LTR   R5,R5                    ANY ADDRESS?\n         BZ    TG$PR$SK                 NO, SKIP TRASH\n         LH    R0,JQEJOBNO              GET JOB NUMBER\n         CVD   R0,QNUMWORK              TO DECIMAL\n         MVC   TG@JOBID,=X'4020202020202120'  SET EDIT PATTERN\n         ED    TG@JOBID,QNUMWORK+4      SET JOB ID IN MESSAGE TEXT\n         MVC   TG@JNAME,JQEJNAME        MOVE JOB NAME TO MESSAGE\n         TM    JQEFLAG1,JQE1BUSY        IS JOB ACTIVE?\n         BZ    TG$PR$SK                 NO - SKIP\n         IC    R1,JQEFLAG1              GET SYSTEM BUSY FLAGS\n         N     R1,=A(JQE1BUSY)          STRIP\n         SLL   R1,3                     COMPUTE OFFSET INTO TABLE\n         A     R1,QVSYSID               -> SYSTEM ID\n         MVC   TG@SYSID,0(R1)           PUT INTO DISPLAY LINE\nTG$PR$SK DS    0H\n         L     R1,4(,R2)                NUMBER OF TRACK GROUPS\n         CVD   R1,QNUMWORK              TO DECIMAL\n         MVC   TG@NUMTG,=X'4020202020202120' SET EDIT PATTERN\n         ED    TG@NUMTG,QNUMWORK+4      SET IN MESSAGE\n         L     R15,QCNUMTGA             NUMBER OF ACTIVE TRACK GROUPS\n         M     R1-1,=F'1000'\n         DR    R1-1,R15                 DIVIDE TO GET PERCENT OF TOTAL\n         CVD   R1,QNUMWORK              TO DECIMAL\n         MVC   TG@TGPCT,=X'4020214B21'  SET EDIT MASK\n         ED    TG@TGPCT,QNUMWORK+6      SET PCT TO MESSAGE\n         L     R0,TG@TGS-TG@JQES(,R2)   TRACK GROUP ACCUMULATOR\n         CVD   R0,QNUMWORK              TO DECIMAL\n         MVC   TG@TGPS,=X'4020202020202120'  SET EDIT PATTERN\n         ED    TG@TGPS,QNUMWORK+4       SET IN MESSAGE TEXT\n         C     R0,TG#ACCUM              IS THIS THE MAX VALUE?\n         BNE   *+4+6                    NO SKIP NEXT\n         MVC   TG@TGPS,=C'     MAX'     SET MORE REASONABLE VALUE\n         L     R1,TG@TGS-TG@JQES+4(,R2) NUMBER OF JOBS\n         CVD   R1,QNUMWORK              TO DECIMAL\n         MVC   TG@JOBS,=X'4020202020202120' SET EDIT PATTERN\n         ED    TG@JOBS,QNUMWORK+4       SET IN MESSAGE TEXT\n         M     R1-1,=F'1000'\n         L     R15,TG@TOTJB             GET TOTAL NUMBER OF JOBS\n         DR    R1-1,R15                 DIVIDE TO GET PERCENT OF TOTAL\n         CVD   R1,QNUMWORK              TO DECIMAL\n         MVC   TG@PCT,=X'4020214B21'    SET EDIT MASK\n         ED    TG@PCT,QNUMWORK+6        SET PCT TO MESSAGE\n         MVI   TG@BAR,C'|'              PUT IN SEPARATOR\n         BAL   R14,QADDLINE             ADD LINE TO SCREEN BUFFER\n         SPACE 1\n         SR    R2,R4                    MOVE TO NEXT ENTRY\n         BCT   R3,TG$PR$LP              PRINT ALL ENTRIES\n         SPACE 1\n         MVC   QDMSG,QBLANK             BLANK THE TEXT AREA\n         MVC   TG@JNAME,=CL8'*TOTAL*'\n         L     R0,TG@TOTTG              TOTAL NUMBER OF TRACK GROUPS\n         CVD   R0,QNUMWORK              TO DECIMAL\n         MVC   TG@NUMTG,=X'4020202020202120' SET EDIT PATTERN\n         ED    TG@NUMTG,QNUMWORK+4      SET IN MESSAGE\n         L     R0,TG@TOTJB              TOTAL NUMBER OF JOBS\n         CVD   R0,QNUMWORK              TO DECIMAL\n         MVC   TG@JOBS,=X'4020202020202120' SET EDIT PATTERN\n         ED    TG@JOBS,QNUMWORK+4       SET IN MESSAGE\n         L     R15,QCJQTL               POINT TO HCT SAVE AREA\n         L     R15,QCNUMTGA             NUMBER OF ACTIVE TRACK GROUPS\n         L     R1,TG@TOTTG              TOTAL NUMBER OF TRACK GROUPS\n         M     R1-1,=F'1000'\n         DR    R1-1,R15                 DIVIDE TO GET PERCENT OF TOTAL\n         CVD   R1,QNUMWORK              TO DECIMAL\n         MVC   TG@PCT,=X'4020214B21'    SET EDIT MASK\n         ED    TG@PCT,QNUMWORK+6        SET PCT TO MESSAGE\n         MVI   TG@BAR,C'|'              PUT IN SEPARATOR\n         BAL   R14,QADDLINE             ADD LINE TO SCREEN BUFFER\n*???     QCALL DISPLAY                  DISPLAY THE COMPLETED SCREEN\n         B     QSTOP\n         SPACE 2\n          AIF   (&QLEVEL GE 7).TG03\n         SPACE 1\nTG$PROCI L     R1,QCIOTA                ADDR OF IOAREA FOR IOT\n         LR    R7,R1                    POINT TO IOT AREA\n         USNGX IOTSTART,R7              ADDRESSING FOR AREA\n         QCALL READSPC                  READ THE IOT\n         CLC   IOTID,=CL4'IOT'          WAS AN IOT READ FROM SPOOL ?\n         BNER  R8                       NO, SKIP THIS IOT\n         CLC   QPJOBID,IOTJBKEY         DOES JOB ID MATCH?\n         BNER  R8                       NO, SKIP THIS IOT\n         TM    IOTFLAG1,IOT1ALOC        IS THIS AN ALLOCATION IOT?\n         BNOR  R8                       NO, SKIP PROCESSING IT\n         LA    R1,IOTTGMAP              POINT TO ALLOCATION MAP\n         LA    R1,TGMAP-TGMDSECT(,R1)   POINT TO TRACK GROUP MAP\n*%       L     R15,QCJQTL               POINT TO HCT SAVE AREA\n*%       L     R15,QCNUMTGA             NUMBER OF ACTIVE TRACK GROUPS\n*%       LA    R15,7(,R15)              ROUND TO MULTIPLE OF 8\n*%       SRL   R15,3                    DIVIDE BY 8\n*%       LR    R0,R15                   TO R0 FOR OUR USE\n         LH    R0,QCTGMLEN              GET LENGTH OF TRACK GROUP MAP\n         SRL   R0,2                     WORDS / MAP\nTG$IOTC1 ICM   R15,15,0(R1)             TEST FOR ANY ALLOCATED\n         BNZ   TG$IOTC3                 YES, SEE HOW MANY\nTG$IOTC2 LA    R1,4(,R1)                TO NEXT WORD\n         BCT   R0,TG$IOTC1              LOOP FOR ALL WORDS\n         BR    R8                       RETURN TO CALLER\nTG$IOTC3 LA    R14,32                   BITS / WORD\nTG$IOTC4 LTR   R15,R15                  TEST SIGN BIT\n         BNM   *+8                      OFF, SKIP IT\n         LA    R2,1(,R2)                BUMP ACCUMULATOR\n         SLL   R15,1                    TRY NEXT BIT\n         BCT   R14,TG$IOTC4             LOOP FOR ALL BITS\n         B     TG$IOTC2                 TRY NEXT WORD\n         DROPX R7                       IOTSTART\n.TG03     ANOP\n         SPACE 1\n         LTORG ,\n         SPACE 1\n         DC    0F'0'                    ALIGNMENT\nTG#ACCUM DC    X'7FFFFFFF',F'0'\n         DC    F'150',F'0'\n         DC    F'100',F'0'\n         DC    F'080',F'0'\n         DC    F'060',F'0'\n         DC    F'050',F'0'\n         DC    F'040',F'0'\n         DC    F'030',F'0'\n         DC    F'020',F'0'\n         DC    F'015',F'0'\n         DC    F'010',F'0'\n         DC    F'009',F'0'\n         DC    F'008',F'0'\n         DC    F'007',F'0'\n         DC    F'006',F'0'\n         DC    F'005',F'0'\n         DC    F'004',F'0'\n         DC    F'003',F'0'\n         DC    F'002',F'0'\n         DC    F'001',F'0'\n         SPACE 1\nWORK     DSECT\n         ORG   WORK+72                  SKIP OVER SAVE AREA\nTG@TOTTG DS    F                        TOTAL TRACK GROUPS ALLOCATED\nTG@TOTJB DS    F                        TOTAL NUMBER OF JOBS PROCESSED\nTG@JQES  DS    XL(20*8)                 20 ENTRIES (JQEADDR, #TGPS)\nTG@TGS   DS    XL(20*8)                 20 ENTRIES (# TGPS, # JOBS)\nTG@WORKL EQU   *-WORK                   LENGTH OF LOCAL WORK AREA\n         QCOMMON\n         ORG   QDMSG                    BACK UP TO MESSAGE AREA\nTG@JOBID DS    CL8,X                    SPACE FOR JOBID\nTG@JNAME DS    CL8                      SPACE FOR JOBNAME\nTG@NUMTG DS    C' NNNNNNN',C            SPACE FOR NUMBER OF TRK GROUPS\nTG@TGPCT DS    C' NN.N',CL3             SPACE FOR % OF TOTAL TRK GROUPS\nTG@SYSID DS    CL4                      SYSTEM ID IF ACTIVE JOB\n         DS    CL6                      FILLER\nTG@BAR   DS    C'|'                     SEPARATOR\n         DS    CL12                     FILLER\nTG@TGPS  DS    C' NNNNNNN'              SPACE FOR NUMBER OF TRK GROUPS\nTG@JOBS  DS    C' NNNNNNN',C            SPACE FOR NBR OF JOBS W/ TGPS\nTG@PCT   DS    C' NN.N'                 SPACE FOR % OF JOBS\n         DROPX R13                      WORK\n         Q$JQE\n         Q$JCT\n         Q$HCT\n         Q$IOT\n         Q$TGM\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "QAPF": {"ttr": 16898, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x820\\x7f\\x00\\x86\\x08\\x9f\\x17W\\x00+\\x00(\\x00\\x0b\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1982-11-03T00:00:00", "modifydate": "1986-03-30T17:57:00", "lines": 43, "newlines": 40, "modlines": 11, "user": "LDW"}, "text": "         MACRO\n&NFS     QAPF  &FUNC\n.*--------------------------------------------------------------------*\n.*                                                                    *\n.*  QAPF - INVOKE INSTALLATION SVC TO SET OR RESET APF AUTHORIZATION  *\n.*                                                                    *\n.*  NOTE - THE EXISTANCE OF THIS SVC IS INDICATED BY THE SETTING OF   *\n.*         THE GBLA \"&@@SCSVC\".  THIS MACRO (QAPF) MAY NEED TO BE     *\n.*         EDITTED BY EACH INSTALLATION USING THE APF SVC.            *\n.*  NOTE - THE ACTUAL SVC USED IS INTENDED TO BE THE SVC MENTIONED IN *\n.*         THE SPF INSTALLATION MANUAL, WHICH SETS OR RESETS JSCBAUTH *\n.*         ON REQUEST IF THE CALLER IS IN LPA/CSA.  THIS MEANS THAT   *\n.*         IF QUEUE IS TO PASS THE VALIDITY CHECK, IT MUST BE IN      *\n.*         LPA OR MLPA.  YOU COULD ALSO MODIFY THE SVC TO WORK IF     *\n.*         THE CALLER IS A SYSTEMS PROGRAMMER, EVEN IF NOT IN LPA.    *\n.*  NOTE - INSTALLATION OF THE ABOVE MENTIONED SVC RESULTS IN A       *\n.*         POSSIBLE INTEGRITY EXPOSURE.  IF YOU EXPECT ME TO DESCRIBE *\n.*         IT HERE, YOU'RE CRAZY.                                     *\n.*                                                                    *\n.*  UPDATES:                                                          *\n.*     03/30/86 LDW  IF &@@SCSVC IS ZERO, GENERATE MNOTE              *\n.*     12/20/84 LDW  USE &@@SCSVC FOR SPFCOPY SVC NUMBER              *\n.*                                                                    *\n.*--------------------------------------------------------------------*\n.*\n         GBLA  &@@SCSVC\n         AIF   (&@@SCSVC NE 0).OK\n         MNOTE 12,'*** LOGIC ERROR IN CONDITIONAL ASSEMBLY -- QAPF MACR$\n               O INVOKED WITH &&@@SCSVC=0 ***'\n.OOPS    DC    2F'0'                    PATCH SPACE\n         MEXIT\n.OK      AIF   ('&FUNC' EQ 'SET').SET\n         AIF   ('&FUNC' EQ 'RESET').RESET\n         MNOTE 12,'&FUNC INVALID'\n         AGO   .OOPS\n.SET     ANOP\n&NFS     LA    R0,1                     INDICATE \"SET\"\n         AGO   .SVC\n.RESET   ANOP\n&NFS     LA    R0,0                     INDICATE \"RESET\"\n.*SVC    SVC   243\n.SVC     SVC   &@@SCSVC\n         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "QAUTH": {"ttr": 16900, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x91\\x03\\x0f\\x00\\x91\\x18\\x1f\\x01\\x15\\x00A\\x005\\x00\\x11\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1991-01-30T00:00:00", "modifydate": "1991-06-30T01:15:00", "lines": 65, "newlines": 53, "modlines": 17, "user": "LDW"}, "text": "         TITLE '--- QAUTH-- IKJEFTSR INTERFACE ---'\n*---------------------------------------------------------------------*\n*                                                                     *\n*    This module is invoked under a parallel TMP task structure       *\n*    set up by the IKJEFTSR call in Q#AF. It should be running        *\n*    authorized by virtue of being in the authorized programs         *\n*    list (either IKJERFAP or XA related parmlib member).             *\n*    The purpose is to set authorization on in the main Q task.       *\n*                                                                     *\n*  Updates:                                                           *\n*    30Jun91 LDW - Use label for qcommon id check location            *\n*    17Jun91 LDW - Set return code if didn't get APF auth; QXAPFFL    *\n*                     eliminated                                      *\n*                - Check QAUTHZ to insure that we are working with    *\n*                     a QUEUE module with a synchronized version of   *\n*                     QCOMMON so that I don't waste hours debugging   *\n*                     this junk when QCOMMON changes                  *\n*    14Apr91 LDW - Turn off QXAPFFL upon success instead of setting   *\n*                     it on failure                                   *\n*    30Jan91 LDW - Rename from ISRAUTH                                *\n*                - Miscellaneous cosmetic code changes                *\n*                                                                     *\n*---------------------------------------------------------------------*\nQAUTH    CSECT\n         SAVE  (14,12),,QAUTH_&SYSDATE._&SYSTIME\n         LR    R12,R15\n         USING QAUTH,R12\n         L     R2,0(,R1)                -> first parm\n*---  Validate that call came from QUEUE\n         CLC   =X'0004FFFFFFFF',0(R2)\n         BNE   ABEND1\n         L     R2,4(,R1)                -> second parm\n         L     R11,2(,R2)               -> QCOMMON\n         USING QCOMMON,R11\n         CLC   =CL11'****QCOMMON',QCMN#ID\n         BNE   ABEND2\n         CLC   =X'07FE',QAUTHZ+4        look ok?\n         BNE   ABEND3                   no\n***********************************************************************\n*                                                                     *\n*  SEE IF MVS THINKS WE ARE AUTHORIZED                                *\n*                                                                     *\n***********************************************************************\n         TESTAUTH  FCTN=1               ask MVS if auth exists\n         SPACE 1\n         LTR   R15,R15                  are we?\n         BZ    QAUTHZ                   yes - go make believe Q\n*                                       (set R13 and simulate QSTOP)\n***********************************************************************\n*                                                                     *\n*  AUTHORIZATION ATTEMPT FAILED - RETURN INDICATOR                    *\n*                                                                     *\n***********************************************************************\n         LA    R1,=C'QAUTH not auth'    point at msg\n         LA    R0,14                    length\n         TPUT  (1),(0),R                go invoke IKJEFTSR\n         RETURN (14,12),,RC=16\nABEND1   ABEND 1,DUMP,STEP\nABEND2   ABEND 2,DUMP,STEP\nABEND3   TPUTX '*** QAUTH - Wrong version of QCOMMON ***'\n         ABEND 3,DUMP,STEP\n         DROP  R12,R11\n         LTORG ,\n         QCOMMON\n         QREGS\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "QCALL": {"ttr": 16902, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x0f\\x00\\x00\\x00\\x82#/\\x00\\x91&_\\x17H\\x00\\xd0\\x00L\\x00\\xb9\\xe2\\xc1\\xd3\\xc2\\xc5\\xd9\\xe3@@@'", "ispf": {"version": "05.15", "flags": 0, "createdate": "1982-08-20T00:00:00", "modifydate": "1991-09-22T17:48:00", "lines": 208, "newlines": 76, "modlines": 185, "user": "SALBERT"}, "text": "         MACRO\n&NFS     QCALL &ROUTINE,&TYPE=\n.*--------------------------------------------------------------------*\n.*                                                                    *\n.*  QCALL - Invoke another QUEUE routine                              *\n.*                                                                    *\n.*  Note - Generated code intentionally shifted right 1 column        *\n.*                                                                    *\n.*  Updates:                                                          *\n.*     23Sep91  GLA  Add entry for DSAUTH                             *\n.*     29Jan91  LDW  Add entry for CLEARSCR                           *\n.*                   Integrate 21Sep90 GLA updates:                   *\n.*              GLA  Add entries for GETSVT and KILLPCS               *\n.*     04Jun89  LDW  Change APF to AUTHFUNC                           *\n.*     19Jul87  EMS  delete QSORT                                     *\n.*     10Jun87  EMS  Change FMTSUBS to QSUBS                          *\n.*                   Add GETPDDB                                      *\n.*     22May87  EMS  Add FMTSUBS,QSORT                                *\n.*                   Update to facilitate adding routines             *\n.*                   Fix bugs relating to continued lines             *\n.*     29Nov86  LDW  Add DATEFMT                                      *\n.*     03/31/86 LDW  CHANGE DISPCHG TO DISP80 & DISP132               *\n.*     01/20/84 LDW  FIX BUGS IN 01/13/83 CODE                        *\n.*     01/13/83 LDW  HANDLE CASE OF MORE CALLERS THAN FIT ON ONE LINE *\n.*     12/13/82 LDW  MOVE CODE FROM QXREF MACRO INTO QCALL.  (QXREF   *\n.*                      NOW DELETED.)  ADD TYPE=XREF TO PRINT XREF.   *\n.*                                                                    *\n.*--------------------------------------------------------------------*\n.*\n         GBLC  &QNAMES(400),&QSECT\n         LCLC  &TO,&FROM,&ENT\n         LCLA  &I\n         AIF   ('&ROUTINE' EQ '' AND '&TYPE' EQ '').ERR1\n         AIF   ('&ROUTINE' NE '' AND '&TYPE' NE '').ERR2\n         AIF   ('&ROUTINE' NE '').ROUTINE\n         AIF   ('&TYPE' EQ 'XREF').XREF\n         MNOTE 8,'TYPE=&TYPE INVALID - MACRO TERMINATED'\n         MEXIT\n.ERR1    MNOTE 8,'EITHER ROUTINE OR TYPE= MUST BE SPECIFIED'\n         MEXIT\n.ERR2    MNOTE 8,'ROUTINE AND TYPE MAY NOT BOTH BE SPECIFIED'\n         MEXIT\n.ROUTINE AIF   ('&ROUTINE' EQ '(R15)').R15\n&NFS      L     R15,=V(&ROUTINE)         FIND ROUTINE\n          BALR  R14,R11                  INVOKE \"QCALL\"\n.*\n.* UPDATE QCALL XREF TABLE FOR PRINTING AT END OF ASSEMBLY\n.*\n&TO      SETC  '&ROUTINE       '(1,8)\n&FROM    SETC  '&QSECT         '(1,8)\n         AIF   ('&SYSECT' NE 'QCOMMON').NOTQCMN\n&FROM    SETC  'QCOMMON '\n.NOTQCMN AIF   ('&QNAMES(1)' NE '').NAMESET  SKIP IF ALREADY SET\n&I       SETA  1\n&QNAMES(&I) SETC 'ALLOCATE --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'AUTHFUNC --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'CHANGES  --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'CKPT     --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'CLEARSCR --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'CPU      --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'DATEFMT  --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'DDNAME   --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'DISPADD  --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'DISPADDX --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'DISP132  --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'DISP80   --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'DISPLAY  --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'DSAUTH   --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'FINDJOB  --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'FINDRJE  --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'FORMAT   --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'GETPDDB  --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'GETREC   --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'GETSVT   --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'HELP     --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'HEXBLK   --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'HEXFMT   --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'INITIAL  --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'INITS    --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'JESNEWS  --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'JOBINFO  --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'KILLPCS  --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'LIST     --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'LISTDS   --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'LISTTEXT --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'MCS      --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'MODE     --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'OPERCMD  --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'PARSE    --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'PFKSET   --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'PRINT    --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'QINNARDS --- '\n&I       SETA  &I+1\n.*  QCOMMON AND QUEUE ARE NOT CALLED\n&QNAMES(&I) SETC 'QSUBS    --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'READSPC  --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'REPOS    --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'RMTLIST  --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'SAVE     --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'SEARCH   --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'SYSLIST  --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'SYSLOG   --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'SYSOUT   --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'TSOCMD   --- '\n&I       SETA  &I+1\n.*   48 Entires used\n.NAMESET ANOP\n&I       SETA  1\n.NAMELP1 ANOP\n         AIF   ('&QNAMES(&I)        '(1,8) EQ '&TO').FOUND1\n&I       SETA  &I+1\n         AIF   ('&QNAMES(&I)        '(1,8) NE '        ').NAMELP1\n         MNOTE 0,'\"&TO\" NOT FOUND IN XREF TABLE - CALLS NOT XREF''D'\n         AGO   .MEXIT\n.FOUND1  ANOP\n&ENT     SETC  '&QNAMES(&I)'\n         AIF   (K'&ENT GT 60).TRY2      SET UP A CONTINUATION LINE\n&QNAMES(&I) SETC '&ENT&FROM  '\n         AGO   .MEXIT\n.TRY2    ANOP\n&I       SETA  &I+50\n         AIF   (&I GT 400).ERR3\n         AIF   ('&QNAMES(&I)' NE '').FOUND1   SKIP IF ALREADY SET\n&QNAMES(&I) SETC '             '        INDENT CONTINUATION LINE\n         AGO   .FOUND1                  NOW GO SAVE THIS CALL\n.ERR3    MNOTE 0,'NO SPACE FOR CALL XREF (SEE \"QCALL\" MACRO)'\n         AGO   .MEXIT\n.R15     ANOP\n&NFS      BALR  R14,R11                  INVOKE \"QCALL\"\n.MEXIT   SPACE 1\n         MEXIT\n.*\n.*  DUMP THE XREF TABLE\n.*\n.XREF    SPACE 2\n         MNOTE '                    *** QUEUE SUBROUTINE CALLEE/CALLER $\n               XREF ***'\n         SPACE 2\n         MNOTE '  ROUTINE      CALLED BY'\n         MNOTE '  -------      ---------'\n         SPACE 1\n.LOOP    ANOP\n&I       SETA  &I+1\n         AIF   ('&QNAMES(&I)' EQ '').MEND\n         MNOTE '  &QNAMES(&I)'\n         AIF   ('&QNAMES(&I+50)' EQ '').NOCONT\n         MNOTE '  &QNAMES(&I+50)'\n         AIF   ('&QNAMES(&I+100)' EQ '').NOCONT\n         MNOTE '  &QNAMES(&I+100)'\n         AIF   ('&QNAMES(&I+150)' EQ '').NOCONT\n         MNOTE '  &QNAMES(&I+150)'\n         AIF   ('&QNAMES(&I+200)' EQ '').NOCONT\n         MNOTE '  &QNAMES(&I+200)'\n         AIF   ('&QNAMES(&I+250)' EQ '').NOCONT\n         MNOTE '  &QNAMES(&I+250)'\n         AIF   ('&QNAMES(&I+300)' EQ '').NOCONT\n         MNOTE '  &QNAMES(&I+300)'\n         AIF   ('&QNAMES(&I+350)' EQ '').NOCONT\n         MNOTE '  &QNAMES(&I+350)'\n.NOCONT  SPACE 1\n         AGO   .LOOP\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "QCALL@": {"ttr": 16906, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\r\\x00\\x00\\x00\\x82#/\\x00\\x89\\x15_#\\x17\\x00\\xc4\\x00L\\x00\\xad\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "05.13", "flags": 0, "createdate": "1982-08-20T00:00:00", "modifydate": "1989-06-04T23:17:00", "lines": 196, "newlines": 76, "modlines": 173, "user": "LDW"}, "text": "         MACRO\n&NFS     QCALL &ROUTINE,&TYPE=\n.*--------------------------------------------------------------------*\n.*                                                                    *\n.*  QCALL - Invoke another QUEUE routine                              *\n.*                                                                    *\n.*  Note - Generated code intentionally shifted right 1 column        *\n.*                                                                    *\n.*  Updates:                                                          *\n.*     04Jun89  LDW  Change APF to AUTHFUNC                           *\n.*     19Jul87  EMS  delete QSORT                                     *\n.*     10Jun87  EMS  Change FMTSUBS to QSUBS                          *\n.*                   Add GETPDDB                                      *\n.*     22May87  EMS  Add FMTSUBS,QSORT                                *\n.*                   Update to facilitate adding routines             *\n.*                   Fix bugs relating to continued lines             *\n.*     29Nov86  LDW  Add DATEFMT                                      *\n.*     03/31/86 LDW  CHANGE DISPCHG TO DISP80 & DISP132               *\n.*     01/20/84 LDW  FIX BUGS IN 01/13/83 CODE                        *\n.*     01/13/83 LDW  HANDLE CASE OF MORE CALLERS THAN FIT ON ONE LINE *\n.*     12/13/82 LDW  MOVE CODE FROM QXREF MACRO INTO QCALL.  (QXREF   *\n.*                      NOW DELETED.)  ADD TYPE=XREF TO PRINT XREF.   *\n.*                                                                    *\n.*--------------------------------------------------------------------*\n.*\n         GBLC  &QNAMES(400),&QSECT\n         LCLC  &TO,&FROM,&ENT\n         LCLA  &I\n         AIF   ('&ROUTINE' EQ '' AND '&TYPE' EQ '').ERR1\n         AIF   ('&ROUTINE' NE '' AND '&TYPE' NE '').ERR2\n         AIF   ('&ROUTINE' NE '').ROUTINE\n         AIF   ('&TYPE' EQ 'XREF').XREF\n         MNOTE 8,'TYPE=&TYPE INVALID - MACRO TERMINATED'\n         MEXIT\n.ERR1    MNOTE 8,'EITHER ROUTINE OR TYPE= MUST BE SPECIFIED'\n         MEXIT\n.ERR2    MNOTE 8,'ROUTINE AND TYPE MAY NOT BOTH BE SPECIFIED'\n         MEXIT\n.ROUTINE AIF   ('&ROUTINE' EQ '(R15)').R15\n&NFS      L     R15,=V(&ROUTINE)         FIND ROUTINE\n          BALR  R14,R11                  INVOKE \"QCALL\"\n.*\n.* UPDATE QCALL XREF TABLE FOR PRINTING AT END OF ASSEMBLY\n.*\n&TO      SETC  '&ROUTINE       '(1,8)\n&FROM    SETC  '&QSECT         '(1,8)\n         AIF   ('&SYSECT' NE 'QCOMMON').NOTQCMN\n&FROM    SETC  'QCOMMON '\n.NOTQCMN AIF   ('&QNAMES(1)' NE '').NAMESET  SKIP IF ALREADY SET\n&I       SETA  1\n&QNAMES(&I) SETC 'ALLOCATE --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'AUTHFUNC --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'CHANGES  --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'CKPT     --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'CPU      --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'DATEFMT  --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'DDNAME   --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'DISPADD  --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'DISPADDX --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'DISP132  --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'DISP80   --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'DISPLAY  --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'FINDJOB  --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'FINDRJE  --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'FORMAT   --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'GETPDDB  --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'GETREC   --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'HELP     --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'HEXBLK   --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'HEXFMT   --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'INITIAL  --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'INITS    --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'JESNEWS  --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'JOBINFO  --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'LIST     --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'LISTDS   --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'LISTTEXT --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'MCS      --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'MODE     --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'OPERCMD  --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'PARSE    --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'PFKSET   --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'PRINT    --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'QINNARDS --- '\n&I       SETA  &I+1\n.*  QCOMMON AND QUEUE ARE NOT CALLED\n&QNAMES(&I) SETC 'QSUBS    --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'READSPC  --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'REPOS    --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'RMTLIST  --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'SAVE     --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'SEARCH   --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'SYSLIST  --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'SYSLOG   --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'SYSOUT   --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'TSOCMD   --- '\n&I       SETA  &I+1\n.*   45 Entires used\n.NAMESET ANOP\n&I       SETA  1\n.NAMELP1 ANOP\n         AIF   ('&QNAMES(&I)        '(1,8) EQ '&TO').FOUND1\n&I       SETA  &I+1\n         AIF   ('&QNAMES(&I)        '(1,8) NE '        ').NAMELP1\n         MNOTE 0,'\"&TO\" NOT FOUND IN XREF TABLE - CALLS NOT XREF''D'\n         AGO   .MEXIT\n.FOUND1  ANOP\n&ENT     SETC  '&QNAMES(&I)'\n         AIF   (K'&ENT GT 60).TRY2      SET UP A CONTINUATION LINE\n&QNAMES(&I) SETC '&ENT&FROM  '\n         AGO   .MEXIT\n.TRY2    ANOP\n&I       SETA  &I+50\n         AIF   (&I GT 400).ERR3\n         AIF   ('&QNAMES(&I)' NE '').FOUND1   SKIP IF ALREADY SET\n&QNAMES(&I) SETC '             '        INDENT CONTINUATION LINE\n         AGO   .FOUND1                  NOW GO SAVE THIS CALL\n.ERR3    MNOTE 0,'NO SPACE FOR CALL XREF (SEE \"QCALL\" MACRO)'\n         AGO   .MEXIT\n.R15     ANOP\n&NFS      BALR  R14,R11                  INVOKE \"QCALL\"\n.MEXIT   SPACE 1\n         MEXIT\n.*\n.*  DUMP THE XREF TABLE\n.*\n.XREF    SPACE 2\n         MNOTE '                    *** QUEUE SUBROUTINE CALLEE/CALLER $\n               XREF ***'\n         SPACE 2\n         MNOTE '  ROUTINE      CALLED BY'\n         MNOTE '  -------      ---------'\n         SPACE 1\n.LOOP    ANOP\n&I       SETA  &I+1\n         AIF   ('&QNAMES(&I)' EQ '').MEND\n         MNOTE '  &QNAMES(&I)'\n         AIF   ('&QNAMES(&I+50)' EQ '').NOCONT\n         MNOTE '  &QNAMES(&I+50)'\n         AIF   ('&QNAMES(&I+100)' EQ '').NOCONT\n         MNOTE '  &QNAMES(&I+100)'\n         AIF   ('&QNAMES(&I+150)' EQ '').NOCONT\n         MNOTE '  &QNAMES(&I+150)'\n         AIF   ('&QNAMES(&I+200)' EQ '').NOCONT\n         MNOTE '  &QNAMES(&I+200)'\n         AIF   ('&QNAMES(&I+250)' EQ '').NOCONT\n         MNOTE '  &QNAMES(&I+250)'\n         AIF   ('&QNAMES(&I+300)' EQ '').NOCONT\n         MNOTE '  &QNAMES(&I+300)'\n         AIF   ('&QNAMES(&I+350)' EQ '').NOCONT\n         MNOTE '  &QNAMES(&I+350)'\n.NOCONT  SPACE 1\n         AGO   .LOOP\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "QCALL@2": {"ttr": 16910, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x0e\\x00\\x00\\x00\\x82#/\\x00\\x91\\x02\\x9f!Q\\x00\\xcd\\x00L\\x00\\xb6\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "05.14", "flags": 0, "createdate": "1982-08-20T00:00:00", "modifydate": "1991-01-29T21:51:00", "lines": 205, "newlines": 76, "modlines": 182, "user": "LDW"}, "text": "         MACRO\n&NFS     QCALL &ROUTINE,&TYPE=\n.*--------------------------------------------------------------------*\n.*                                                                    *\n.*  QCALL - Invoke another QUEUE routine                              *\n.*                                                                    *\n.*  Note - Generated code intentionally shifted right 1 column        *\n.*                                                                    *\n.*  Updates:                                                          *\n.*     29Jan91  LDW  Add entry for CLEARSCR                           *\n.*                   Integrate 21Sep90 GLA updates:                   *\n.*              GLA  Add entries for GETSVT and KILLPCS               *\n.*     04Jun89  LDW  Change APF to AUTHFUNC                           *\n.*     19Jul87  EMS  delete QSORT                                     *\n.*     10Jun87  EMS  Change FMTSUBS to QSUBS                          *\n.*                   Add GETPDDB                                      *\n.*     22May87  EMS  Add FMTSUBS,QSORT                                *\n.*                   Update to facilitate adding routines             *\n.*                   Fix bugs relating to continued lines             *\n.*     29Nov86  LDW  Add DATEFMT                                      *\n.*     03/31/86 LDW  CHANGE DISPCHG TO DISP80 & DISP132               *\n.*     01/20/84 LDW  FIX BUGS IN 01/13/83 CODE                        *\n.*     01/13/83 LDW  HANDLE CASE OF MORE CALLERS THAN FIT ON ONE LINE *\n.*     12/13/82 LDW  MOVE CODE FROM QXREF MACRO INTO QCALL.  (QXREF   *\n.*                      NOW DELETED.)  ADD TYPE=XREF TO PRINT XREF.   *\n.*                                                                    *\n.*--------------------------------------------------------------------*\n.*\n         GBLC  &QNAMES(400),&QSECT\n         LCLC  &TO,&FROM,&ENT\n         LCLA  &I\n         AIF   ('&ROUTINE' EQ '' AND '&TYPE' EQ '').ERR1\n         AIF   ('&ROUTINE' NE '' AND '&TYPE' NE '').ERR2\n         AIF   ('&ROUTINE' NE '').ROUTINE\n         AIF   ('&TYPE' EQ 'XREF').XREF\n         MNOTE 8,'TYPE=&TYPE INVALID - MACRO TERMINATED'\n         MEXIT\n.ERR1    MNOTE 8,'EITHER ROUTINE OR TYPE= MUST BE SPECIFIED'\n         MEXIT\n.ERR2    MNOTE 8,'ROUTINE AND TYPE MAY NOT BOTH BE SPECIFIED'\n         MEXIT\n.ROUTINE AIF   ('&ROUTINE' EQ '(R15)').R15\n&NFS      L     R15,=V(&ROUTINE)         FIND ROUTINE\n          BALR  R14,R11                  INVOKE \"QCALL\"\n.*\n.* UPDATE QCALL XREF TABLE FOR PRINTING AT END OF ASSEMBLY\n.*\n&TO      SETC  '&ROUTINE       '(1,8)\n&FROM    SETC  '&QSECT         '(1,8)\n         AIF   ('&SYSECT' NE 'QCOMMON').NOTQCMN\n&FROM    SETC  'QCOMMON '\n.NOTQCMN AIF   ('&QNAMES(1)' NE '').NAMESET  SKIP IF ALREADY SET\n&I       SETA  1\n&QNAMES(&I) SETC 'ALLOCATE --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'AUTHFUNC --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'CHANGES  --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'CKPT     --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'CLEARSCR --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'CPU      --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'DATEFMT  --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'DDNAME   --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'DISPADD  --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'DISPADDX --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'DISP132  --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'DISP80   --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'DISPLAY  --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'FINDJOB  --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'FINDRJE  --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'FORMAT   --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'GETPDDB  --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'GETREC   --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'GETSVT   --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'HELP     --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'HEXBLK   --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'HEXFMT   --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'INITIAL  --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'INITS    --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'JESNEWS  --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'JOBINFO  --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'KILLPCS  --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'LIST     --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'LISTDS   --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'LISTTEXT --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'MCS      --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'MODE     --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'OPERCMD  --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'PARSE    --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'PFKSET   --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'PRINT    --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'QINNARDS --- '\n&I       SETA  &I+1\n.*  QCOMMON AND QUEUE ARE NOT CALLED\n&QNAMES(&I) SETC 'QSUBS    --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'READSPC  --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'REPOS    --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'RMTLIST  --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'SAVE     --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'SEARCH   --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'SYSLIST  --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'SYSLOG   --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'SYSOUT   --- '\n&I       SETA  &I+1\n&QNAMES(&I) SETC 'TSOCMD   --- '\n&I       SETA  &I+1\n.*   48 Entires used\n.NAMESET ANOP\n&I       SETA  1\n.NAMELP1 ANOP\n         AIF   ('&QNAMES(&I)        '(1,8) EQ '&TO').FOUND1\n&I       SETA  &I+1\n         AIF   ('&QNAMES(&I)        '(1,8) NE '        ').NAMELP1\n         MNOTE 0,'\"&TO\" NOT FOUND IN XREF TABLE - CALLS NOT XREF''D'\n         AGO   .MEXIT\n.FOUND1  ANOP\n&ENT     SETC  '&QNAMES(&I)'\n         AIF   (K'&ENT GT 60).TRY2      SET UP A CONTINUATION LINE\n&QNAMES(&I) SETC '&ENT&FROM  '\n         AGO   .MEXIT\n.TRY2    ANOP\n&I       SETA  &I+50\n         AIF   (&I GT 400).ERR3\n         AIF   ('&QNAMES(&I)' NE '').FOUND1   SKIP IF ALREADY SET\n&QNAMES(&I) SETC '             '        INDENT CONTINUATION LINE\n         AGO   .FOUND1                  NOW GO SAVE THIS CALL\n.ERR3    MNOTE 0,'NO SPACE FOR CALL XREF (SEE \"QCALL\" MACRO)'\n         AGO   .MEXIT\n.R15     ANOP\n&NFS      BALR  R14,R11                  INVOKE \"QCALL\"\n.MEXIT   SPACE 1\n         MEXIT\n.*\n.*  DUMP THE XREF TABLE\n.*\n.XREF    SPACE 2\n         MNOTE '                    *** QUEUE SUBROUTINE CALLEE/CALLER $\n               XREF ***'\n         SPACE 2\n         MNOTE '  ROUTINE      CALLED BY'\n         MNOTE '  -------      ---------'\n         SPACE 1\n.LOOP    ANOP\n&I       SETA  &I+1\n         AIF   ('&QNAMES(&I)' EQ '').MEND\n         MNOTE '  &QNAMES(&I)'\n         AIF   ('&QNAMES(&I+50)' EQ '').NOCONT\n         MNOTE '  &QNAMES(&I+50)'\n         AIF   ('&QNAMES(&I+100)' EQ '').NOCONT\n         MNOTE '  &QNAMES(&I+100)'\n         AIF   ('&QNAMES(&I+150)' EQ '').NOCONT\n         MNOTE '  &QNAMES(&I+150)'\n         AIF   ('&QNAMES(&I+200)' EQ '').NOCONT\n         MNOTE '  &QNAMES(&I+200)'\n         AIF   ('&QNAMES(&I+250)' EQ '').NOCONT\n         MNOTE '  &QNAMES(&I+250)'\n         AIF   ('&QNAMES(&I+300)' EQ '').NOCONT\n         MNOTE '  &QNAMES(&I+300)'\n         AIF   ('&QNAMES(&I+350)' EQ '').NOCONT\n         MNOTE '  &QNAMES(&I+350)'\n.NOCONT  SPACE 1\n         AGO   .LOOP\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "QCBFE": {"ttr": 17156, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x903o\\x00\\x903\\x7f\\x00\\x03\\x00.\\x00\\x1e\\x00\\x00\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-12-02T00:00:00", "modifydate": "1990-12-03T00:03:00", "lines": 46, "newlines": 30, "modlines": 0, "user": "LDW"}, "text": "         MACRO\n&NFS     QCBFE &NAME,&TYPE,&LEN,&MIN=0,&MAX=999,&L=,&OFFSET=0\n.*--------------------------------------------------------------------*\n.*                                                                    *\n.*  QCBFE - Create a table entry for CBFMT routine.                   *\n.*                                                                    *\n.*  Updates:                                                          *\n.*     01Dec90  LDW  Written                                          *\n.*                                                                    *\n.*--------------------------------------------------------------------*\n.*\n         GBLA  &QCBFEL,&QCBFEOF,&QLEVEL\n         LCLA  &XDIGIT,&XREMAIN,&XDIVISR\n         LCLC  &FLAG,&COMMENT,&HEXOFF,&HEXCHAR\n         AIF   (&QLEVEL LT &MIN).MEND\n         AIF   (&QLEVEL GT &MAX).MEND\n&HEXCHAR SETC  '0123456789ABCDEF'\n         AIF   ('&L' EQ '').NOL\n&QCBFEL  SETA  &L\n&QCBFEOF SETA  &OFFSET\n&NFS     DC    Y(&L,&OFFSET)            name length, initial offset\n.NOL     ANOP\n         AIF   ('&NAME&TYPE&LEN' EQ '').MEND\n         AIF   ('&TYPE' EQ 'HEX' ).HEX\n         AIF   ('&TYPE' EQ 'CHAR').CHAR\n         MNOTE 8,'Unknown type -- &TYPE'\n.HEX     ANOP\n&FLAG    SETC  '000'\n         AGO   .TYPESET\n.CHAR    ANOP\n&FLAG    SETC  '128'\n.TYPESET ANOP\n&HEXOFF  SETC  ''\n&XREMAIN SETA  &QCBFEOF                 offset to convert\n&XDIVISR SETA  4096                     first divisor\n.HEXLOOP ANOP\n&XDIGIT  SETA  &XREMAIN/&XDIVISR\n.******  MNOTE *,'XREMAIN=&XREMAIN XDIVISR=&XDIVISR XDIGIT=&XDIGIT'\n&XREMAIN SETA  &XREMAIN-&XDIGIT*&XDIVISR\n&HEXOFF  SETC  '&HEXOFF'.'&HEXCHAR'(&XDIGIT+1,1)\n&XDIVISR SETA  &XDIVISR/16\n         AIF   (&XDIVISR NE 0).HEXLOOP\n&COMMENT SETC  '    offset = &QCBFEOF (&HEXOFF)'\n&NFS     DC    AL1(&LEN,&FLAG),CL&QCBFEL&NAME&COMMENT\n&QCBFEOF SETA  &QCBFEOF+&LEN\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "QCBLKNUM": {"ttr": 17158, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x87\\x01\\x0f\\x00\\x87\\x01\\x0f#D\\x00\\x15\\x00\\x15\\x00\\x00\\xc5\\xc1\\xe8@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-01-10T00:00:00", "modifydate": "1987-01-10T23:44:00", "lines": 21, "newlines": 21, "modlines": 0, "user": "EAY"}, "text": "         MACRO\n&NFS     QCBLKNUM  &REG\n.*--------------------------------------------------------------------*\n.*                                                                    *\n.*  QCBLKNUM - Compute number of checkpoint blocks for a segment      *\n.*                                                                    *\n.*  This macro exists mainly to reduce the amount of conditional      *\n.*  assembly in INITIAL.                                              *\n.*                                                                    *\n.*  Updates:                                                          *\n.*     10Jan87  LDW  Created                                          *\n.*                                                                    *\n.*--------------------------------------------------------------------*\n.*\n         GBLA  &QLEVEL\n&NFS     LA    &REG,4095(,&REG)         Prepare up to round\n         AIF   (&QLEVEL LT 7).NOPRFX    Skip if no buffer prefix\n         LA    &REG,BFPLEN(,&REG)       Add buffer prefix\n.NOPRFX  SRL   &REG,12                  Divide by 4096\n         SPACE 1\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "QCEDIMAC": {"ttr": 17160, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x91&_\\x00\\x91&_\"\\t\\x00\\x11\\x00\\x11\\x00\\x00\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-09-22T00:00:00", "modifydate": "1991-09-22T22:09:00", "lines": 17, "newlines": 17, "modlines": 0, "user": "LDW"}, "text": "PROC 0\n/* QCEDIMAC is an initial macro used by QUEUE when invoking EDIF     */\n/* for spool data.                                                   */\nISREDIT MACRO\nISREDIT RESET           /* kill the UNDO message */\nISREDIT DEFINE SAVE     DISABLED\nISREDIT DEFINE END      ALIAS CANCEL\nISREDIT (CAPS) = CAPS\nIF &CAPS = ON THEN ISREDIT CAPS OFF\nCONTROL ASIS\nISREDIT LINE_BEFORE .ZFIRST = MSGLINE 'Read-Only -- \"SAVE\" command +\n        disabled; \"END\" is alias for \"CANCEL\"'\nISREDIT LINE_BEFORE .ZFIRST = MSGLINE ' '\nISREDIT LINE_BEFORE .ZFIRST = MSGLINE '\"EDIT\" must be terminated +\n        before QUEUE subcommands may be entered'\nISREDIT LINE_BEFORE .ZFIRST = MSGLINE ' '\nIF &CAPS = ON THEN ISREDIT CAPS ON\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "QCMDE": {"ttr": 17162, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x03\\x00\\x00\\x00\\x82#/\\x00\\x83\\x07o\\x15X\\x00*\\x00\\x18\\x00\\x1e\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "05.03", "flags": 0, "createdate": "1982-08-20T00:00:00", "modifydate": "1983-03-17T15:58:00", "lines": 42, "newlines": 24, "modlines": 30, "user": "LDW"}, "text": "         MACRO\n&ROUTINE QCMDE &CODE,&POSMAX,&CMD,&F=,&KEYS=\n.*--------------------------------------------------------------------*\n.*                                                                    *\n.*  QCMDE - GENERATE PARSE TABLE ENTRY FOR A SUBCOMMAND AND ALL OF    *\n.*          ITS ALIASES                                               *\n.*                                                                    *\n.*  UPDATES:                                                          *\n.*     12/14/82 LDW  ADD SUPPORT FOR KEYWORD/RESERVED WORD TABLE      *\n.*                   ADD SUPPORT FOR MAXIMUM NUMBER OF POSITIONALS    *\n.*                   MOVE ROUTINE NAME FROM THIRD OPERAND TO NFS      *\n.*                   MOVE &CODE FROM SECOND OPERAND TO FIRST          *\n.*                   MAKE &XCODE A SETC (INSTEAD OF SETA)             *\n.*                                                                    *\n.*--------------------------------------------------------------------*\n.*\n         LCLA  &I,&NUM\n         LCLC  &FL,&XCODE\n&XCODE   SETC  '001'                    ASSUME CODE NOT SET\n&FL      SETC  '000'                    ASSUME FLAGS NOT SET\n&NUM     SETA  N'&CMD                   NUMBER OF SUBCMD NAMES\n***********************************************************************\n         AIF   ('&CODE' EQ '').CODE0    SKIP IF NO CODE GIVEN\n&XCODE   SETC  '&CODE'\n.CODE0   AIF   ('&F' EQ '').FLAG0       SKIP IF NO FLAGS GIVEN\n&FL      SETC  '&F'\n.FLAG0   AIF   ('&KEYS' EQ '').NOKEYS\n         DC    V(&ROUTINE,&KEYS)        -> ROUTINE; -> KEYWORD TABLE\n         AGO   .OKKEYS\n.NOKEYS  DC    V(&ROUTINE),A(0)         -> ROUTINE; NO KEYWORD TABLE\n.OKKEYS  AIF   ('&POSMAX' EQ 'N').NOCHECK\n         DC    AL1(&FL,&POSMAX)         FLAGS; MAX POSIT OPERANDS\n         AGO   .POSOK\n.NOCHECK DC    AL1(&FL),X'FF'           FLAGS; DON'T VALCK POSITIONALS\n.POSOK   DC    AL1(&XCODE,&NUM)         SUBCMD FCTN CODE; # OF NAMES\n.LOOP    ANOP\n&I       SETA  &I+1\n         DC    CL4'&CMD(&I)'            A SUBCOMMAND NAME\n         AIF   (&I LT N'&CMD).LOOP      DO ALL SUBCMD NAMES\n***********************************************************************\n         SPACE 1\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "QCMDS": {"ttr": 17164, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x00\\x00\\x00\\x00\\x90&\\x0f\\x00\\x90&\\x0f\\x142\\x00\\x03\\x00\\x03\\x00\\x00\\xc2\\xc1\\xe2\\xc5@@@@@@'", "ispf": {"version": "02.00", "flags": 0, "createdate": "1990-09-17T00:00:00", "modifydate": "1990-09-17T14:32:00", "lines": 3, "newlines": 3, "modlines": 0, "user": "BASE"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "QCOMMON": {"ttr": 17166, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05K\\x00\\x00\\x00\\x82#/\\x00\\x915O\"\\x12\\x04\\xc3\\x02+\\x03M\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "05.75", "flags": 0, "createdate": "1982-08-20T00:00:00", "modifydate": "1991-12-20T22:12:00", "lines": 1219, "newlines": 555, "modlines": 845, "user": "LDW"}, "text": "         MACRO\n         QCOMMON &CSECT=NO\n.*--------------------------------------------------------------------*\n.*                                                                    *\n.*  QCOMMON - Map the QUEUE command common data area                  *\n.*                                                                    *\n.*  Note - On subsequent invocations of this macro in the same        *\n.*.        assembly, only the DSECT (or CSECT) statement will be      *\n.*         generated.                                                 *\n.*                                                                    *\n.*  Updates:                                                          *\n.*     20Dec91  LDW  Add QM2RSCA                                      *\n.*     22Sep91  LDW  Add QSC3EDIT                                     *\n.*     05Aug91  LDW  Add QTBDROW per Guy Albertelli 16Jul91 update    *\n.*     29Jun91  LDW  Add trace (debug) logic to QCALL, QSTOP, QTILT   *\n.*     08Jun91  LDW  Misc minor cleanup; eliminate dup patch space    *\n.*     06Jun91  EMS  For 420:  Add QCJCTNJH, QLJCTNJH, QCJCTNJN,      *\n.*                      QJ2VERSN                                      *\n.*     26May91  LDW  Add QBRIFHDR                                     *\n.*     11Feb91  LDW  Move some ISPF areas to literals and local work  *\n.*                      areas in INITIAL, DISPLAY, LISTDS, and QUEUE  *\n.*                      (V2 VLEN2 V3 VLEN3 V4 VLEN4 V5 VLEN5 V6 VLEN6 *\n.*                       V7 VLEN7 V9 VLEN9 V10 VLEN10 BRWCLST BRWDBLW *\n.*                       MYFREE TBLST VCALLST)                        *\n.*                   Delete unused data (V1, VLEN1)                   *\n.*     01Feb91  LDW  Change table panel name from QNM2 to QPTBL       *\n.*     30Jan91  LDW  Don't generate ENTRY QLEVEL if dsect!            *\n.*     29Jan91  LDW  Shuffle QCJQELEN and QCJIXL in a feeble attempt  *\n.*                      to regain 2 bytes of addressability           *\n.*                   Add QVPRNTWA; move many QPxxx fields into new    *\n.*                      QPRNTWA to regain more addressability         *\n.*                   Move QCLRSCR subroutine to CLEARSCR in TSOCMD    *\n.*                   Retrofit GLA changes below:                      *\n.*    (15Jan91) GLA  Define flag to output OUTGRP instead of device   *\n.*    (21Sep90) GLA  Move things for addressability sake              *\n.*    (02Aug90) GLA  Fix loop in LISTDS after job purged and space    *\n.*                   reused - day one bug                             *\n.*                   Add field for saving addr of SVT/CCT             *\n.*    (10Jul90) GLA  Add items for JES2 Appl CKPT support             *\n.*                   Fix definition of QPJOBID and QPDSID             *\n.*    (17Apr90) GLA  Set correct length of ZCMD area                  *\n.*    (15Nov89) GLA  Change attributes of HASPPRNT and field of       *\n.*                      QPHEAD1                                       *\n.*                   Correct NUMCONV for length < 0                   *\n.*    (05May89) GLA  Add support of authorized under ISPF             *\n.*    (29Mar89) GLA  Add support for ISPF BROWSE and Tables           *\n.*     22Dec90  LDW  Add field QLEVEL                                 *\n.*     28Nov90  EMS  Enlarge fields for dsn prefix                    *\n.*     20Jun90  LDW  Use new QLCB macro for LCB                       *\n.*     16Jun90  LDW  Add QAMODE24 and QAMODE31 subroutines            *\n.*                   Remove $AMODE from QTILT and QSTOP since we      *\n.*                      now run (mostly) AMODE 31                     *\n.*     13Jun90  LDW  Add unstack code (like QSTOP) into QTILT to fix  *\n.*                      S0C4 problem after repeated immediate cmds    *\n.*                   Minor adjustment to $AMODE invocation in QSTOP   *\n.*     23May90  LDW  Add QSC3USER                                     *\n.*     09Jul89  LDW  Add QSC1PCT, change QSC1FLSH to QSC3FLSH         *\n.*     04Jun89  LDW  Add QXSUPR, QXAPFENT                             *\n.*     25Apr89  EMS  Add QKACA -> incore checkpoint copy              *\n.*                   Updates for SP311                                *\n.*                   QSTOP and friends reset to 24 bit mode           *\n.*     23Jan89  LDW  Set default PFKeys from QGLOBALS for EMS         *\n.*     10Apr88  LDW  Add QFFPREV                                      *\n.*     06Apr88  LDW  Swap PF2/14 (RC) and PF12/24 (ST) default        *\n.*                      definitions for ISPF 2.3 compatibility        *\n.*     20Feb88  LDW  Add QSLFLDS and Q3SYSLOG                         *\n.*     03Feb88  LDW  For 2.2.0, don't generate QCTGMLEN               *\n.*     11Aug87  EMS  Update for page mode with getrec routine         *\n.*                   Add more IKJDAP08 equates                        *\n.*      8Jul87  EMS  Fix for Starting/Draining spool volumes          *\n.*                   Add QCITEM for Qitem support                     *\n.*                   Delete QSORT fields, QCEND                       *\n.*                   Fix for base JES2                                *\n.*                   Update for GETPDDB routine                       *\n.*     22May87  EMS  Add QSORT req fields                             *\n.*                   Add fields to support Page mode; col GETREC flds *\n.*                   Rename fields QPPAGE;QPPAGE# -> QPAGEN;QPAGEN#   *\n.*                   Add QITEM entry point for enhanced QITEM macro   *\n.*     31Mar87  LDW  Add Q2VALIDS                                     *\n.*     07Feb87  LDW  Add QCMDNUM, QRETNUM, QCMDRING                   *\n.*     04Jan87  LDW  FOR 136:  ADD QCJQELEN                           *\n.*     14DEC86  LDW  FOR 136:  ADD QCNUMTGA, QCJQEXA, QCDASL, QCDASA, *\n.*                      QCPSTL, QCPSTA                                *\n.*     29NOV86  LDW  ADD QM1JDATE                                     *\n.*     05OCT86  LDW  ADD QSC3WTRI                                     *\n.*     23AUG86  LDW  CHANGE QCTGML GEN CHECK FROM SP133 TO SP130      *\n.*     17JUN86  LDW  ADD QCJQETTR, QCJQENUM, QCJOETTR, QCJOENUM,      *\n.*                      QMFMVSE                                       *\n.*     03JUN86  LDW  ADD QVCKDECB AND QLCKDECB                        *\n.*     04/22/86 LDW  MOVE ATTN FROM QTERMFLG TO QMISCFLG              *\n.*     04/03/86 LDW  ASSIGN INDIVIDUAL NAMES TO EACH BIT IN QDEBUG    *\n.*     03/31/86 LDW  ADD QTFSW2, QTFSW5, CHANGE QTFLARGE TO QTFWIDE   *\n.*                   ADD QDCOLNOW, DELETE QSTAX                       *\n.*     12/04/84 LDW  ADD QSC2DI, QSC2AFF                              *\n.*     08/30/84 LDW  ADD QSC2DBL, QM1STACK, QDLINES, QFREEMFL         *\n.*                   SUPPORT QM1STACK                                 *\n.*                   ADD DESCRIPTOR WORDS FOR GETMAINED STORAGE       *\n.*     08/07/84 LDW  ADD QALTCHAR                                     *\n.*                   UPDATE FOR SP134 (DON'T GENERATE QCPDDB1)        *\n.*     06/05/84 LDW  ADD QCTGML & QCTGMA FOR SP133                    *\n.*     01/27/84 LDW  CHANGE PF6/PF18 FROM 'NS' TO 'NS *'              *\n.*                   SET DEFAULT QCNSDIR TO 'N'                       *\n.*     01/23/84 LDW  FIX BUG IN QSTACK ROUTINE                        *\n.*                   ADD QFLAG4, QFFLAG, QHDCBA, QHDECBA              *\n.*                   ADD MORE SPARE SPACE IN VARIOUS PLACES           *\n.*                   EXPAND SCRN BUFF TO ALLOW FOR ATTR BYTES / LINE  *\n.*                   CHANGE SIZE OF BLOCK TABLE FROM 64K TO 32K       *\n.*                   ADD POINTERS TO DSID TABLE FOR 'NS' SUBCOMMAND   *\n.*                   EXPAND QDHJOBID TO ENABLE FIX FOR JESNEWS ID     *\n.*                   CHANGE DEFINITION OF PF6/18 FROM 'DI' TO 'NS'    *\n.*                   PUT 'EXIT' AT BOTTOM OF QDSTACK                  *\n.*     12/19/83 LDW  ADD QCTGMLEN, QSC1SPC                            *\n.*     10/28/83 SDM  FIX QCLRSCR FOR LARGER SCREENS                   *\n.*     03/18/83 LDW  PUT IN QSTACK SUBROUTINE                         *\n.*     03/16/83 LDW  CHANGE PF3/15 DEFINITION FROM \"*\" TO \"RC\"        *\n.*     03/11/83 LDW  CHANGE LCBUFF DSECT                              *\n.*                   ADD QSC2LINE, QM1PFK24, QERRMSG, QACTION,        *\n.*                      DEFINITIONS FOR PFK13-24                      *\n.*                   NEW QTILT ROUTINE:  MOVE MSG TEXT FROM QERRMSG   *\n.*     02/23/83 LDW  ADD QVHELP, QVCHGS, LCTABLE, LCBUFF              *\n.*     02/08/83 LDW  DELETE QSC1DHX                                   *\n.*     02/03/83 LDW  DELETE Q1INQ1, Q1INQ2, QINQLEN, DELETE QDINQCMD, *\n.*                      ADD QINQCMD                                   *\n.*     01/25/83 LDW  ADD QCLSNAME                                     *\n.*     01/19/83 LDW  ADD QSMFID, QVSYSID, QDLCTBL, QVLCBUF, QDLCBUF,  *\n.*                      QM2NTRAN, QDEBUG (REPLACES QM1PDBFL),         *\n.*                      QTPAGEX, QTHALFX, Q2COLIND                    *\n.*                   DELETE SOME OTHER (NO LONGER USED) FIELDS        *\n.*                   INCREASE SIZE OF SCREEN BUFFER TO ALLOW FOR      *\n.*                      EXTRA SPACE TAKEN BY ATTR BYTES               *\n.*     01/14/83 LDW  ADD QTSOCMD, QMVSCMD                             *\n.*     01/13/83 LDW  ADD QXAPFSET                                     *\n.*     01/10/83 LDW  ADD Q2SHORT, Q2NEWSCR, QDENDPTR                  *\n.*     01/03/83 LDW  ADD QSTDEFKY, Q2OWNJOB, Q2LISTDS, Q2REPOS,       *\n.*                      Q2SPF, QSC2CKPT, QTFLARGE, QTFFULL, QM1NOVFY, *\n.*                      QPFORM                                        *\n.*                   QSTOP - DON'T RESTORE R15, R0, R1                *\n.*                   QCALL - USE LOCAL WORK AREA SIZE                 *\n.*                   MORE SP SUPPORT                                  *\n.*                   CHANGE QCLRFLGS TO LITERALS                      *\n.*                   INCREASE LENGTH OF QBLANK FOR ATTR BYTES         *\n.*     12/23/82 LDW  ADD QPUCS, QPFCB, QPLINEPP, QLWASIZE, QHEXTAB,   *\n.*                      QSC2SLOG, QFLAG3, QSCFLAG4, QMODE2            *\n.*                   LENGTHEN QDMSG FOR POSSIBLE 7 ATTR BYTES         *\n.*     12/21/82 LDW  ADD QSC2ALNA                                     *\n.*     12/10/82 LDW  FIX REPROMPT BUG IN QTILT - DON'T RESTORE        *\n.*                      FIELDS FROM QSAVE1 AND QSAVE2                 *\n.*     12/08/82 LDW  DON'T CLEAR SCREEN BUFFER WHEN QTILT'ING         *\n.*                   ADD QFLAG2, QSCFLAG2, QSCFLAG3, QKEYWORD         *\n.*                   CHANGE QFLAGS TO QFLAG1, QFXXXXX TO Q1XXXXX      *\n.*                   ADD QPOFFDEF                                     *\n.*                                                                    *\n.*--------------------------------------------------------------------*\n.*\n.*  SUPPRESS COMMENTS AROUND GLOBALS\n         PRINT NOGEN\n.*  GET ALL GLOBAL VARIABLE DEFINITIONS AND SETTINGS\n         COPY  QGLOBALS\n         AIF   ('&@@QDOC &CSECT' EQ 'NOGEN NO').NOGEN1\n         PRINT GEN\n.NOGEN1   ANOP\n         GBLB  &QCOMMON                 QCOMMON WAS GENNED THIS ASM\n         GBLC  &QDTYPE                  CSECT OR DSECT FOR QCOMMON\n         GBLC  &QSECT                   CURRENT CSECT NAME\n         AIF   ('&QSECT' NE '').QSECTOK SKIP IF ALREADY SET\n&QSECT   SETC  '&SYSECT'                ELSE SET IT\n         AIF   ('&QSECT' NE '').QSECTOK SKIP IF ALREADY SET\n         AIF   ('&CSECT' NE 'YES').QSECTOK SKIP IF NOT GENERATING CSECT\n&QSECT   SETC  'QCOMMON'                TRY TO AVOID ZERO LENGTH PC\n         AIF   ('&@@QPRNT' EQ 'NO').QSECTOK\n         COPY  $UPDATES\n.QSECTOK AIF   (&QCOMMON).SKIP          SKIP BOX IF ALREADY GENERATED\n         TITLE '--- QUEUE--COMMON AREA DSECT ---'\n***********************************************************************\n*                                                                     *\n*   QUEUE COMMAND - COMMON AREA                                       *\n*                                                                     *\n***********************************************************************\n.SKIP    AIF   ('&CSECT' EQ 'YES').CSECT\n         AIF   ('&QDTYPE' EQ 'CSECT').CSECT   RESUME CSECT IF WAS CSECT\nQCOMMON  DSECT\n&QDTYPE  SETC  'DSECT'\n         AGO   .CONT\n.CSECT   ANOP\nQCOMMON  CSECT\n&QDTYPE  SETC  'CSECT'\n.CONT    AIF   (&QCOMMON).MEND          SKIP IF ALREADY GENERATED\n&QCOMMON SETB  1                        REMEMBER ALREADY GENERATED\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*   QCALL SUBROUTINE - INVOKED BY \"QCALL\" MACRO VIA \"BALR R14,R11\"    *\n*                                                                     *\n*   NOTE:  THIS IS THE MIKE STEIN GIMMICK OF HAVING EXECUTABLE CODE   *\n*        AT THE BEGINNING OF THE COMMON AREA, TO BE ABLE TO DO THE    *\n*        CALL WITH A BALR.  NOTE ALSO, TO CHANGE THE CALLING          *\n*        SEQUENCE, ALL MODIFICATIONS ARE NOW LOCALIZED TO THIS CODE   *\n*        AND \"QSTOP\" ROUTINE FURTHER DOWN IN QCOMMON.                 *\n*                                                                     *\n***********************************************************************\n         SPACE 1\n         PUSH  USING\n         USING QCOMMON,R11\n         SPACE 1\n         STM   R14,R12,12(R13)          SAVE CALLER'S REGISTERS\n         LR    R12,R15                  SET CALLED ROUTINE'S BASE\n         LR    R15,R13                  SAVE ADDR OF SAVE AREA\n         AH    R13,2(,R13)              -> NEXT SAVE AREA (INCLUDES A\n*                                       VARIABLE SIZE LOCAL WORK AREA)\n         ST    R13,8(,R15)              CHAIN FORWARD\n         ST    R15,4(,R13)              CHAIN BACKWARD\n         TM    QDEBUG4,QDEBUG48         want trace?\n         BZR   R12                      no - pass control to called rtn\n         LR    R14,R11                  copy qcommon address\n         AH    R14,=Y(QTRACEWA-QCOMMON) -> trace workarea\n         STM   R15,R3,0(R14)            save some registers\n         LR    R3,R14                   move trace work area address\n         MVC   20(17,R3),=C'trace... QCALL:  '\n         BAL   R2,QTRACE                set up caller & callee\n         MVC   20+25(4,R3),=C' -> '     show direction\n         TPUTX 20(R3),37                show caller -> callee\n         LM    R15,R3,0(R3)             restore clobbered registers\n         L     R15,4(,R13)              -> previous save area\n         L     R14,12(,R15)             restore clobbered register\n         BR    R12                      PASS CONTROL TO CALLED ROUTINE\n         SPACE 3\nQCMN#ID  DC    C'****QCOMMON &SYSDATE &SYSTIME'  GENERATE ID FIELD\n         SPACE 1\n         QREGS                          GENERATE REGISTERS\n         SPACE 3\n***********************************************************************\n*                                                                     *\n*   ADD DISPLAY LINE IN \"QDMSG\" TO SCREEN BUFFER                      *\n*                                                                     *\n***********************************************************************\n*QADDLINE QCALL DISPADD\nQADDLINE QCALL DISPADD\n         ORG   *-2                      BACK OVER THE BALR\n         BR    R11                      INVOKE \"QCALL\" WITH R14 INTACT\n         SPACE 3\n***********************************************************************\n*                                                                     *\n*   DISPLAY ERROR MESSAGE AND TERMINATE CURRENT ROUTINE               *\n*                                                                     *\n***********************************************************************\n         SPACE 1\nQTILT    TM    QDEBUG4,QDEBUG48         want trace?\n         BZ    QTILTNTR                 no - skip\n         TPUTX 'trace... QTILT'\nQTILTNTR TM    QISFLAG1,QIS1ISPF        are we in ISPF?\n         BO    *+10    >============+   yes - don't overlay hdr\n         MVC   QDHLINE,QERRMSG      |   COPY THE ERROR MESSAGE\n         TM    QFLAG1,Q1IMMED   <===+   ARE WE TILTING IN IMMED CMD?\n         BNO   QTILT$NI                 NO - CONTINUE\n*                                       YES - \"IMMED\" WILL BE OVERLAYED\n         TM    QSCFLAG1,QSC1PMPT        SET CC FOR \"REPROMPT REQUESTED\"\n         L     R8,QVSAVE                -> SAVE AREA FOR \"DISPLAY\"\n         MVC   QSAVE1(QSAVE1L),0(R8)    RESTORE FIRST PART\n         MVC   QSAVE2(QSAVE2L),QSAVE1L(R8)     SECOND PART\n         BNO   *+8                      SKIP IF NO REPROMPT\n         OI    QSCFLAG1,QSC1PMPT        SET FLAG AGAIN\nQTILT$NI TM    QISFLAG1,QIS1ISPF        are we in ISPF?\n         BO    *+8     >=============+  yes - don't overlay hdr\n         OI    QFLAG1,Q1MVHDR        |  REQUEST \"MOVE HEADER\"\n         TM    QXAUTH,QXAPFSET   <===+  are we authorized?\n         BZ    QTILTLP                  no - so all ok\n         TM    QISFLAG1,QIS1ISPF        are we auth and in ispf\n         BZ    QTILTLP                  no - so all ok\n         CLC   QERRMSG+39(2),=C'AP'     APF logic error\n         BNE   *+8                      no - ok\n         EX    0,*                      GOD HELP US\n         LA    R1,8                     req auth set off\n         QCALL AUTHFUNC                 reset apf auth\n         SPACE 1\nQTILTLP  TM    QDEBUG4,QDEBUG48         want trace?\n         BZ    QTILTLP1                 no - skip\n         TPUTX 'trace... QTILTLP'\n*QTILTLP1 QCALL DISPLAY                 DISPLAY THE ERROR MESSAGE\nQTILTLP1 QCALL DISPLAY                  DISPLAY THE ERROR MESSAGE\n         B     QTILTLP                  KEEP HIM HERE\n         SPACE 3\n***********************************************************************\n*                                                                     *\n*   HANDLE ENTRY FROM ISRAUTH                                         *\n*                                                                     *\n***********************************************************************\nQAUTHZ   DS    0H\n         L     R14,6(,R2)               get entry address\n         BR    R14                      go there\n         SPACE 3\n***********************************************************************\n*                                                                     *\n*   Mode switch subroutines                                           *\n*                                                                     *\n***********************************************************************\n          AIF   (&@@SPLVL GE 200).QAMODE1\nQAMODE24 BR    R14                      just return\nQAMODE31 EQU   QAMODE24                 just return\n          AGO   .QAMODE2\n.QAMODE1  ANOP\nQAMODE24 N     R14,=X'00FFFFFF'         strip BAL junk in case A=24 now\n         BSM   0,R14                    switch to AMODE 24 and return\n         SPACE 1\nQAMODE31 N     R14,=X'00FFFFFF'         strip BAL junk\n         O     R14,=X'80000000'         make it AMODE 31\n         BSM   0,R14                    switch to AMODE 31 and return\n.QAMODE2  ANOP\n         SPACE 3\n***********************************************************************\n*                                                                     *\n*   NUMERIC CONVERT ROUTINE                                           *\n*                                                                     *\n***********************************************************************\nQNUMCONV LTR   R1,R1                    check length\n         BMR   R14                      bad - return w/cc = \"ne\"\n         MVC   QFZONES,QFZONE           INIT FIELD\n         EX    R1,QMVZ                  COPY THE ZONES\n         CLC   QFZONES,QFZONE           ALL NUMBERS?\n         BNER  R14                      NO - RETURN WITH CC SET TO \"NE\"\n         EX    R1,QPACK                 PACK IT\n         CVB   R15,QNUMWORK             GET IT IN BINARY\n         BR    R14                      RETURN WITH CC SET TO \"EQ\"\n         SPACE 1\nQMVZ     MVZ   QFZONES(*-*),0(R15)      << EXECUTED >>\nQPACK    PACK  QNUMWORK,0(*-*,R15)      << EXECUTED >>\n         SPACE 3\n***********************************************************************\n*                                                                     *\n*   COMMON EXIT CODE (REPLACES \"QSTOP\" MACRO)                         *\n*                                                                     *\n***********************************************************************\nQSTOP00  SR    R15,R15                  SET RETURN CODE ZERO\nQSTOP    EQU   QSTOP00,2,C'I'           DEFAULT RC IS ZERO\nQSTOPRC  TM    QDEBUG4,QDEBUG48         want trace?\n         BZ    QSTOPNTR                 no - skip\n         LR    R14,R11                  copy qcommon address\n         AH    R14,=Y(QTRACEWA-QCOMMON) -> trace workarea\n         STM   R15,R3,0(R14)            save some registers\n         LR    R3,R14                   move trace work area address\n         MVC   20(17,R3),=C'trace... QSTOP:  '\n         BAL   R2,QTRACE                set up caller & callee\n         MVC   20+25(4,R3),=C' <- '     show direction\n         MVC   20+37(5,R3),=C'  R1='\n         HEX   (20+42,R3),(8,R3),LEN=4,HEXTAB=QHEXTAB  R1 in QTRACEWA\n         MVC   20+51(5,R3),=C' R15='\n         HEX   (20+56,R3),(0,R3),LEN=4  R15 saved in QTRACEWA\n         TPUTX 20(R3),64\n         LM    R15,R3,0(R3)             restore clobbered registers\nQSTOPNTR L     R13,4(,R13)              LOAD NEXT LOWER SAVE AREA SET\n***      RETURN  (R2,R13),T\n         L     R14,12(,R13)             STANDARD REGISTER RESTORE\n         LM    R2,R12,12+4*4(R13)       STANDARD REGISTER RESTORE\n         MVI   12(R13),X'FF'            FLAG SAVE AREA INACTIVE\n         BR    R14                      RETURN TO CALLER\n         SPACE 3\n***********************************************************************\n*                                                                     *\n*   Subroutine to extract caller & callee.  Called by QCALL & QSTOP.  *\n*                                                                     *\n***********************************************************************\nQTRACE   L     R1,4(,R13)               -> previous save area\n         L     R1,12+2*4+R12*4(,R1)     caller's R12\n         LA    R1,5(,R1)                -> csect name\n         LA    R15,20+18(,R3)           -> target\n         MVC   0(8,R15),QBLANK          clear target\n         BALR  R14,0                    set loop address\n         MVC   0(1,R15),0(R1)           move one char of csect name\n         LA    R1,1(,R1)                bump source\n         LA    R15,1(,R15)              bump target\n         CLI   0(R1),C'A'               end of csect name?\n         BNLR  R14                      no - loop\n         LA    R1,5(,R12)               -> csect name\n         LA    R15,20+29(,R3)           -> target\n         MVC   0(8,R15),QBLANK          clear target\n         BALR  R14,0                    set loop address\n         MVC   0(1,R15),0(R1)           move one char of csect name\n         LA    R1,1(,R1)                bump source\n         LA    R15,1(,R15)              bump target\n         CLI   0(R1),C'A'               end of csect name?\n         BNLR  R14                      no - loop\n         BR    R2                       return to QCALL or QSTOP\n         SPACE 3\n***********************************************************************\n*                                                                     *\n*   SUBROUTINE TO ADD CURRENT SUBCOMMAND TO STACK FOR 'END' FUNCTION  *\n*                                                                     *\n***********************************************************************\nQSTACK   TM    QMODE1,QM1STACK          SUPPORTED?\n         BNOR  R14                      NO - JUST RETURN\n         STM   R14,R12,12(R13)          SAVE SOME REGISTERS\n         L     R2,QVSTACK               -> BOTTOM OF STACK\n         L     R3,QVSTACKC              -> TOP OF STACK\n         LTR   R0,R0                    NEW LEVEL = 0?\n         BZ    QSTACK$2                 YES - PUT AT BOTTOM OF STACK\n         SPACE 1\nQSTACK$1 CLM   R0,B'0001',0(R2)         COMPARE NEW LEVEL WITH ELEMENT\n         BNH   QSTACK$2                 LEVEL:  NEW<=THIS, ADD HERE\n         LA    R2,QDSTACKL(,R2)         -> NEXT STACK ELEMENT\n         CLR   R2,R3                    PAST TOP (END) OF STACK?\n         BNH   QSTACK$1                 NO - KEEP LOOKING\n         SPACE 1\nQSTACK$2 CLC   0(QDREPLYL,R1),QBLANK    IS NEW BLANK?\n         BE    QSTACK$3                 Yes -  ignore\n         STC   R0,0(,R2)                SAVE NEW LEVEL\n         MVC   2(QDREPLYL,R2),0(R1)     SAVE NEW SUBCOMMAND\n         ST    R2,QVSTACKC              SAVE POINTER TO BOTTOM OF STACK\n*\nQSTACK$3 LM    R14,R12,12(R13)          RESTORE REGISTERS\n         BR    R14                      RETURN TO CALLER\n         SPACE 3\n***********************************************************************\n*                                                                     *\n*   Subroutine to call QITEM driver routine                           *\n*                                                                     *\n***********************************************************************\n*QITEM   QCALL QSUBS                    -> routine addr\nQITEM    QCALL QSUBS                    -> routine addr\n         ORG   *-2\n         BR    R11                      return to routine addr\n         SPACE 3\n*  GENERAL PATCH AREA - ADDRESSABLE FROM ALL ROUTINES\nQPATCH   DC    100S(*)                  TEMP PATCH SPACE\n         SPACE 3\n***********************************************************************\n*                                                                     *\n*   MISCELLANEOUS NUTS AND BOLTS                                      *\n*                                                                     *\n***********************************************************************\nQHEXTAB  EQU   *-C'0'\n         DC    C'0123456789ABCDEF'\nQFRSTSA  DC    A(0)                     ADDRESS OF FIRST SAVE AREA\n         SPACE 2\nQFREEMFL FREEMAIN  LU,SP=1,A=QADDRS-QADDRS,LA=QLENGTHS-QLENGTHS,MF=L\n         SPACE 2\nQADDRS   DC    0A(0)                    ADDRESSES OF GETMAINED STORAGE\nQCSTART  DC    A(0)                     ADDRESS OF TABLE START\nQDSTART  DC    A(0)                     -> Ddname table\nQCJQTL   DC    A(0)                     ADDRESS OF FIRST CKPT RECORD\nQVSCRBUF DC    A(0)                     ADDRESS OF SCREEN BUFFER\nQVSPDCB  DC    A(0)                     ADDRESS OF SPOOL DCBS AREA\nQVCKDECB DC    A(0)                     ADDRESS OF CHKPT DECBS AREA\n          AIF   (&QLEVEL LT 12).QCNJCTE\nQCJCTNJH DC    A(0)                     addr of NJE sections for SP420\n.QCNJCTE  ANOP  ,\n         DC    3A(0)                    SPARE\n         SPACE 1\nQLENGTHS DC    0F'0'                    LENGTHS OF GETMAINED STORAGE\nQCSIZE   DC    A(32*1024)               CURRENT SIZE OF TABLE\nQDSIZE   DC    A(8*1024)                CURRENT SIZE OF TABLE\nQCKPTLEN DC    A(0)                     LENGTH OF CHKPT BUFFER\nQLSCRBUF DC    A(0)                     LENGTH OF SCREEN BUFFER\nQLSPDCB  DC    A(0)                     LENGTH OF SPOOL DCBS AREA\nQLCKDECB DC    A(0)                     LENGTH OF CHKPT DECBS AREA\n          AIF   (&QLEVEL LT 12).QCNJCTL\nQLJCTNJH DC    A(0)                     len of NJE sections for SP420\n.QCNJCTL  ANOP  ,\nQLENLAST EQU   *-4                      ADDRESS OF LAST LENGTH WORD\n         DC    3A(0)                    SPARE\n         SPACE 3\nQHDCBA   DC    A(0)                     -> QHELP DCB\nQHDECBA  DC    A(0)                     -> QHELP DECB\nQDEBUG   DC    0XL4'00'                 MISC USE DEBUGGING FLAGS\nQDEBUG1  DC    X'00'                    ...\nQDEBUG11  EQU   X'80'\nQDEBUG12  EQU   X'40'\nQDEBUG13  EQU   X'20'\nQDEBUG14  EQU   X'10'\nQDEBUG15  EQU   X'08'\nQDEBUG16  EQU   X'04'\nQDEBUG17  EQU   X'02'\nQDEBUG18  EQU   X'01'\nQDEBUG2  DC    X'00'                       ...\nQDEBUG22  EQU   X'40'\nQDEBUG23  EQU   X'20'\nQDEBUG24  EQU   X'10'\nQDEBUG25  EQU   X'08'\nQDEBUG26  EQU   X'04'\nQDEBUG27  EQU   X'02'\nQDEBUG28  EQU   X'01'\nQDEBUG3  DC    X'00'                          ...\nQDEBUG32  EQU   X'40'\nQDEBUG33  EQU   X'20'\nQDEBUG34  EQU   X'10'\nQDEBUG35  EQU   X'08'\nQDEBUG36  EQU   X'04'\nQDEBUG37  EQU   X'02'\nQDEBUG38  EQU   X'01'\nQDEBUG4  DC    X'00'                             ...\nQDEBUG42  EQU   X'40'\nQDEBUG43  EQU   X'20'\nQDEBUG44  EQU   X'10'\nQDEBUG45  EQU   X'08'\nQDEBUG46  EQU   X'04'\nQDEBUG47  EQU   X'02'\nQDEBUG48  EQU   X'01'\nQDENDPTR DC    A(0)                     -> PAST IC AT END OF SCREEN\nQVSYSID  DC    A(QSYSID)                -> SYSTEM ID TABLE IN USE\nQVHELP   DC    A(*-*)                   -> HELP TEXT MODULE, IF LOADED\nQVCHGS   DC    A(*-*)                   -> CHGS TEXT MODULE, IF LOADED\nQVSORT   DC    A(*-*)                   -> sort routine\n          AIF   (&QLEVEL LT 8).NOPC\n*\n*        Areas needed to define PC routines\n*\n          AIF   (&QLEVEL GE 9).NEWETD\nQPCDESC  DC    0F'0',XL(ETDLEN+ETDELEN)'00'\n          AGO   .ETDDONE\n.NEWETD   ANOP\n*QPCDESC ETDEF TYPE=INITIAL\nQPCDESC  ETDEF TYPE=INITIAL\n*QPCETD1 ETDEF TYPE=ENTRY,ROUTINE=0,SSWITCH=NO,                        $\n               STATE=SUPERVISOR,AKM=(0:15),EKM=(0:15),EK=0,            $\n               PKM=OR\nQPCETD1  ETDEF TYPE=ENTRY,ROUTINE=0,SSWITCH=NO,                        $\n               STATE=SUPERVISOR,AKM=(0:15),EKM=(0:15),EK=0,            $\n               PKM=OR\n*        ETDEF TYPE=FINAL\n         ETDEF TYPE=FINAL\n.ETDDONE  ANOP\nQPCLXL   DC    0F'0'\nQPCLXCNT DC    F'0'                     NUMBER OF LXS REQUESTED\nQPCLXVAL DC    F'0'                     LX RETURNED BY LXRES\n*\nQPCTKL   DC    0F'0'                    TOKEN LIST\nQPCTKCNT DC    F'0'                     NUMBER OF ETS CREATED\nQPCTKVAL DC    F'0'                     TOKEN RETURNED BY ETCRE\nQPCCKPT  DC    A(0)                     PC NUMBER - CKPT\n.NOPC     ANOP\n         DC    3F'0'                    EXPANSION SPACE\n          AIF  (&QLEVEL GE 4).QCSPNOD   DIFFERENT FIELDS IF SP\nQCLNODE  DS    0HL1                     LOCAL SYSTEM NODE NUMBER\nQCLOCAL  DC    XL2'00'                  \"LOCAL\" OUTPUT DESTINATION ID\n          AGO  .QCOKNOD\n.QCSPNOD  ANOP\nQCLNODE  DS    0H                       LOCAL SYSTEM NODE NUMBER\nQCLOCAL  DC    XL4'00'                  \"LOCAL\" OUTPUT DESTINATION ID\n.QCOKNOD  ANOP\n*  THE FOLLOWING FIELD IS FILLED IN BY A BACK ORG IN QDCB.\nQGETMAIN DC    A(0)                     LENGTH OF QCOMMON FOR GETMAIN\nQJ2VERSN DC    CL8'&QJ2VERS'            JES2 version (SP N.N.N)\n*  THE FOLLOWING 6 FIELDS ARE DATA SPECIFIC TO THE JES SYSTEM WE ARE\n*      CURRENTLY LOOKING AT\nQJESNAME DC    CL4'JES2'                NAME OF JES SUBSYSTEM\nQSSCT    DC    A(0)                     -> SSCT\n          AIF  (&QLEVEL GE 9).NOSVT\nQSVT     DC    A(0)                     -> SSVT\n          AGO   .NOCCT\n.NOSVT    ANOP\nQCCT     DC    A(0)                     -> CCT\n.NOCCT    ANOP\nQCKPTVOL DC    CL6' '                   CHECKPOINT VOLSER\nQCKPTPFX DC    CL44' '                  PREFIX FOR HASPCKPT & HASPACE\nQCOMCHAR DC    X'EE'                    COMMUNICATIONS CHARACTER (\"$\")\nQALTCHAR DC    X'EE'                    ALTERNATE COMM CHAR, IF ANY\n         SPACE 1\nQLOGON   DC    CL7' '                   LOGON ID (PSCBUSER)\nQLOGONL  DC    AL1(0)                   LENGTH OF LOGON ID\nQDEST    DC    CL8' '                   DEFAULT LOGON PRINT ROUTE\nQXBTRAK  DC    XL4'00'                  LAST MTTR ENTERED FOR \"XB\"\n*---  QTPAGE AND QTHALF ARE USED IF THE COLUMN INDICATOR IS OFF    ---*\nQTPAGE   DC    P'21'                    # OF USABLE LINES ON SCREEN\nQTHALF   DC    P'10'                    SAME FOR HALF A SCREEN\n*---  QTPAGEX AND QTHALFX ARE USED IF THE COLUMN INDICATOR IS ON   ---*\nQTPAGEX  DC    P'20'                    # OF USABLE LINES ON SCREEN\nQTHALFX  DC    P'10'                    SAME FOR HALF A SCREEN\nQCLASSH  DC    0H'0',X'00'              HALFWORD BOUNDARY\nQCLASS   DC    C' '                     SEARCH CLASS\nQCLSNAME DC    CL2' '                   DISPLAYABLE CLASS\n         DC    XL2'00'                  CURRENTLY WASTED FOR ALIGNMENT\nQJOBID   DC    H'0',CL8' '              LAST JOBID (AND LENGTH)\nQINTJBID DC    F'0'                     JES2 INTERNAL JOB NUMBER\nQEXTJBID DC    CL8' '                   JES2 EXTERNAL JOB NUMBER\nQJOBNAME DC    CL8' '                   JOB NAME\n          AIF   (&QLEVEL LT 5).QCNPDB1\nQSTEPNAM DC    CL8' '                   stepname\nQDDNAME  DC    CL8' '                   ddname\n.QCNPDB1  ANOP\nQSTKEY   DC    CL8' '                   SEARCH KEY FOR \"ST\" SUBCMD\nQSTDEFKY DC    CL8' '                   DEFAULT FOR \"ST *\"\n         DC    XL40'00'                 SPARE\n         SPACE 1\nQXAUTH   DC    X'00'\nQXPSWD    EQU   X'01'                   HE ENTERED THE PASSWORD\nQXOPER    EQU   X'02'                   HE HAS THE OPER BIT\nQXSYSP    EQU   X'04'                   SYSTEMS PROGRAMMER\nQXAUTHX   EQU   QXPSWD+QXOPER+QXSYSP    AT LEAST ONE OF THEM\nQXSUPR    EQU   X'10'                   QUEUE entered SUPR (and key 0)\nQXAPFFL   EQU   X'20'                   Attempt to set APF fail\nQXAPFENT  EQU   X'40'                   QUEUE entered with APF auth\nQXAPFSET  EQU   X'80'                   WE SET APF AUTH ON VIA SVC\n         SPACE 1\nQMISCFLG DC    B'00000000'              MISC FLAGS\nQMFSYNAD  EQU   X'80'                    SYNAD FLAG\nQMFATTN   EQU   X'40'                    ATTN PRESSED\nQMFMVSE   EQU   X'20'                    RUNNING MVS/XA\nQMFX22    EQU   X'10'                    Running MVS/XA 2.2 or higher\nQMFAXS    EQU   X'08'                    AXSET was issued\nQMFIS31   EQU   X'04'                    ISPF running above line\nQMFRMAX   EQU   X'02'                    Reset max indicator\n*=====================================================================*\nQSAVE1   EQU   *                        START FIELDS SAVED IN DISPLAY |\n*  KEEP FIELDS QSAVE1 THRU QSAVE1L TOGETHER FOR MVC IN \"DISPLAY\"      |\nQCODEH   DC    H'0'                     HALFWORD BOUNDARY             |\nQCODE    EQU   QCODEH+1,1,C'X'          SEARCH FUNCTION CODE          |\nQSUBCMD  DC    V(SEARCH)                ADDR OF CURRENT SUBCOMMAND    |\nQCITEMS  DC    A(0)                     -> this command's Qitem table |\nQOFF0    DC    H'0'                     OFFSET TO SUBCOMMAND          |\n         DC    H'0'                     LENGTH OF SUBCOMMAND          |\nQSUBNAME DC    CL8' '                   NAME OF SUBCOMMAND            |\nQOFF1    DC    H'0'                     OFFSET TO QPARM1              |\nQLNG1    DC    H'0'                     LENGTH OF QPARM1              |\nQPARM1   DC    CL8' '                   USER SUPPLIED PARAMETER #1    |\nQOFF2    DC    H'0'                                                   |\nQLNG2    DC    H'0'                                                   |\nQPARM2   DC    CL8' '                                           #2    |\nQOFF3    DC    H'0'                                                   |\nQLNG3    DC    H'0'                                                   |\nQPARM3   DC    CL8' '                                           #3    |\nQPARMEND EQU   *                                                      |\n*                                                                     |\nQKEYWORD DC    (2*10)CL8' '             10 KEYWORD/VALUE PAIRS        |\nQKEYLAST EQU   *                                                      |\n*                                                                     |\nQFLAG1   DC    X'00'                    MISCELLANEOUS FLAGS           |\n.*        EQU   X'80'                                                 |\n.*        EQU   X'40'                                                 |\nQ1VALJOB  EQU   X'20'                    FINDJOB MUST CHK ACCSS TO JOB|\nQ1LSTCMD  EQU   X'10'                    SUBCMD NEEDS ONLY READ ACCESS|\nQ1JOBID   EQU   X'08'                    QPARM1 IS A JOBID, \u00ac JOBNAME |\nQ1MVHDR   EQU   X'04'                    DISPLAY: MOVE HDR TO SCRN BUF|\nQ1IMMED   EQU   X'02'                    EXEC THIS SUBCMD IMMEDIATELY |\nQ1PROFOK  EQU   X'01'                    INIT PROFILE COMPLETE        |\n*                                                                     |\nQFLAG2   DC    X'00'                    MISCELLANEOUS FLAGS           |\nQ2OWNJOB  EQU   X'80'                    USER \"OWNS\" THIS JOB (AT     |\n*                                        LEAST FOR ACTIVE SUBCMD)     |\nQ2LISTDS  EQU   X'40'                    LISTDS IN CONTROL            |\nQ2REPOS   EQU   X'20'                    SUBCMD IS REPOSITIONING TYPE |\nQ2SPF     EQU   X'10'                    RUNNING UNDER SPF ENVIRONMENT|\nQ2SHORT   EQU   X'08'                    WRITE ONLY TOP 3 LINES       |\nQ2NEWSCR  EQU   X'04'                    PUT NEXT LINE ON LINE 1      |\nQ2COLIND  EQU   X'02'                    DISPLAY COLUMN INDICATOR     |\nQ2VALIDS  EQU   X'01'                    QPDSID IS VALID              |\n*                                                                     |\nQFLAG3   DC    X'00'                    MISCELLANEOUS FLAGS           |\nQ3SYSLOG  EQU   X'80'                    SYSLOG command in use        |\n*                                                                     |\nQFLAG4   DC    X'00'                    MISCELLANEOUS FLAGS           |\n*                                                                     |\n*---  QSCFLAGS ARE CLEARED WHEN A NEW SUBCOMMAND IS PARSED            |\nQSCFLAGS DS    0XL4                     HANDLE FOR ALL SUBCMD FLAGS   |\n*                                                                     |\nQSCFLAG1 DC    X'00'                    MISC FLAGS FOR SUBCOMMANDS    |\nQSC1JOB   EQU   X'80'                    JOBID TO BE DISP'D IN QDTOP  |\nQSC1CPU   EQU   X'40'                    SUBCOMMAND IS \"CPU\"          |\nQSC1TIME  EQU   X'20'                    INPUT TIME TO BE FORMATTED   |\nQSC1PGMR  EQU   X'10'                    PGMRNAME TO BE FORMATTED     |\nQSC1PCT   EQU   X'08'                    SHOW SPOOL PCT, NOT LINES    |\nQSC1DH    EQU   X'04'                    THIS IS \"DH\" SUBCOMMAND      |\nQSC1SPC   EQU   X'02'                    SHOW SPOOL SPC, NOT LINES    |\nQSC1PMPT  EQU   X'01'                    REPROMPT LAST COMMAND ENTERED|\n*                                                                     |\nQSCFLAG2 DC    X'00'                    MISC FLAGS FOR SUBCOMMANDS    |\nQSC2ALNA  EQU   X'80'                    ALLOC SHOULD NOT ABEND IF ERR|\nQSC2SLOG  EQU   X'40'                    CURRENT SUBCOMMAND IS \"SLOG\" |\nQSC2CKPT  EQU   X'20'                    FORCE CKPT READ              |\nQSC2DJX   EQU   X'10'                    'HEX' OPERAND OF \"DJ\" GIVEN  |\nQSC2LINE  EQU   X'08'                    CURRENT SUBCMD IS A LINE S.C.|\nQSC2DBL   EQU   X'04'                    DOUBLE LINE OUTPUT FORMAT    |\nQSC2DI    EQU   X'02'                    SUBCOMMAND IS DI/AI/HI       |\nQSC2AFF   EQU   X'01'                    SYSTEM AFFINITY SELECTED     |\n*                                                                     |\nQSCFLAG3 DC    X'00'                    MISC FLAGS FOR SUBCOMMANDS    |\nQSC3WTRI  EQU   X'80'                    DISPLAY WTRID INSTEAD OF FCB |\nQSC3FLSH  EQU   X'40'                    DISPLAY FLASH INSTEAD OF RMT |\nQSC3USER  EQU   X'20'                    DISPLAY USERID INSTEAD OF RMT|\nQSC3OUTG  EQU   X'10'                    DISPLAY OUTGRP vs DEV        |\nQSC3EDIT  EQU   X'08'                    use EDIF instead of BRIF     |\n*                                                                     |\nQSCFLAG4 DC    X'00'                    MISC FLAGS FOR SUBCOMMANDS    |\n*                                                                     |\nQSAVE1L  EQU   *-QSAVE1                 LENGTH OF SAVED FIELDS        |\n*=====================================================================*\n         SPACE 1\nQTERMFLG DC    AL1(QTFSW2)              TERMINAL ORIENTED FLAGS\nQTFVTAM   EQU   X'80'                    VTAM TERMINAL\nQTFTTY    EQU   X'40'                    NON-VIDEO TERMINAL IN USE\nQTFMOD5   EQU   X'20'                    TERMINAL IS A MODEL 5\nQTFFULL   EQU   X'10'                    CURRENTLY IN FULLSCR MODE\nQTFNOW2   EQU   X'08'                    CURRENTLY IN MOD2 MODE\nQTFNOW5   EQU   X'04'                    CURRENTLY IN MOD5 MODE\nQTFSW2    EQU   X'02'                    SWITCH TO MOD2 MODE NEEDED\nQTFSW5    EQU   X'01'                    SWITCH TO MOD5 MODE NEEDED\n         SPACE 1\nQMODE1   DC    AL1(QM1BEEP+QM1STACK)    VARIOUS USER-SET MODE FLAGS\nQM1LCC    EQU   X'80'                    LISTDS - DISPLAY CARRIAGE CTL\nQM1FANUM  EQU   X'40'                    FINDALL SHOULD DISPLAY REC #'S\nQM1JDATE  EQU   X'20'                    FORMATTED DATES S/B JULIAN\nQM1BEEP   EQU   X'10'                    BEEP DESIRED FOR ERROR MSGS\nQM1PAGE   EQU   X'08'                    LISTDS - USE PRINT PAGE METHOD\nQM1NOVFY  EQU   X'04'                    ACTION SUBCMDS: BYPASS VERIFY\nQM1PFK24  EQU   X'02'                    ALLOW PF13-24 TO BE DIFFERENT\nQM1STACK  EQU   X'01'                    COMMAND STACK MODE\n         SPACE 1\nQMODE2   DC    AL1(QM2CKPT)             VARIOUS USER-SET MODE FLAGS\nQM2CKPT   EQU   X'80'                    use incore copy of ckpt\nQM2RSCA   EQU   X'40'                    reissue stacked cmd after act\n         SPACE 1\nQUCMID   DC    AL1(0)                   ID OF CURRENT CONSOLE UCM\nQUCMNAME DC    CL3'*'                   DISPLAYABLE ADDR OF CURR CONS\nQDSNCKPT DC    H'13',CL44'SYS1.HASPCKPT' DSNAME FOR HASPCKPT\nQDSNSPC  DC    H'12',CL44'SYS1.HASPACE'  DSNAME FOR HASPACE\nQBLANK   DC    CL(132+7*2)' '           HANDY CONSTANT\n         SPACE 1\nQNUMWORK DC    D'0'                     CONVERT WORK AREA\nQFZONE   DC    C'0'                     USED TO CLEAR QFZONES\nQFZONES  DC    C'00000000'              USED FOR NUMERIC CHECK\nQCOUNT   DC    PL3'0'                   NUMBER OF ELEMENTS IN QUEUE\nQDELIMIT DC    C' '                     DELIMITER\n         SPACE 1\nQFFLAG   DC    X'00'                    FLAGS FOR FIND\nQFFBOUND  EQU   X'80'                    BOUNDARY CHECK NEEDED\nQFFLEFT   EQU   X'40'                    LEFT BOUNDARY NEEDED\nQFFRIGHT  EQU   X'20'                    RIGHT BOUNDARY NEEDED\nQFFPREV   EQU   X'08'                    FIND PREVious\nQFFALL    EQU   X'04'                    FIND ALL MATCHES\nQFFASIS   EQU   X'02'                    DO NOT XLATE TO UPPER CASE\nQFFFOUND  EQU   X'01'                    A MATCH WAS FOUND\n         SPACE 1\nQSLFLDS  DC    AL1(QSLFLTIM+QSLFLJID)   Fields for SYSLOG\nQSLFLIND  EQU   X'80'                    indicators\nQSLFLRTC  EQU   X'40'                    route codes\nQSLFLSID  EQU   X'20'                    system id\nQSLFLDAT  EQU   X'10'                    date\nQSLFLTIM  EQU   X'08'                    time\nQSLFLJID  EQU   X'04'                    jobid\nQSLFLRFL  EQU   X'02'                    request flags\n*         EQU   X'01'\n         SPACE 1\nQISFLAG1 DC    X'00'                    ISPF flags\nQIS1ISPF  EQU   X'80'                    QUEUE INVOKED VIA ISPF\nQIS1V2    EQU   X'40'                    ISPF VERSION 2 RUNNING\nQIS1V23   EQU   X'20'                    ISPF V2.3 RUNNING (BRIF)\nQIS1V32   EQU   X'10'                    ISPF V3.2 RUNNING (BRIF works)\nQIS1TBOP  EQU   X'02'                   Table open\nQIS1BRCP  EQU   X'01'                   on if BROWSE complete\n         SPACE 1\nQKFLAG   DC    X'00'                    Application CKPT flags\nQKFKAC    EQU   X'80'                    KAC access valid\n         SPACE 1\n         DC    XL9'00'                  SPARE\nQOFFS    DC    H'0'                     START COLUMN FOR FIND\nQOFFE    DC    H'0'                     END COLUMN FOR FIND\n*  QPJOBID & QPDSID MUST BE CONTIG\nQPJOBID  DC    XL4'0'                   JOB ID FOR LISTDS\n          AIF  (&QLEVEL GE 9).DSID4\nQPDSID   DC    H'0'                     DATASET ID FOR LISTDS\n          AGO  .DSID2\n.DSID4    ANOP ,\nQPDSID   DC    XL4'0'                   dataset id for listds\n.DSID2    ANOP ,\nQPBFDKEY EQU   *-QPJOBID                Length of buffer key\nQPOFFSET DC    H'0'                     PRINT OFFSET FROM BEG. OF REC\nQPOFFDEF DC    H'0'                     DFLT PRINT OFFSET FOR THIS DSID\nQPLNG    DC    PL2'0'                   LEN OF COMPARE FIELD FOR FIND\nQPFIND   DC    CL64' '                  COMPARE FIELD FOR FIND\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*   ISPF WORK AREAS                                                   *\n*                                                                     *\n***********************************************************************\nTBNAM    DC    CL8'TBL1'                TABLE NAME\nTBPNL    DC    CL8'QPTBL'               TABLE DISPLAY PANEL NAME\nVLEN8    DC    A(LCBELEN,L'QF1,L'QF2,L'QF3,L'QF4,L'QF5,L'QF6,L'QF7)\nV8       DC    C'(QLCBE QF1 QF2 QF3 QF4 QF5 QF6 QF7)'\nQBRIFHDR DC    C' '                     flag for LISTDS to rebuild hdr\nISPLNK   DC    A(0)                     ADDRESS OF ISPLNK ROUTINE\nQROWID   DC    F'0'                     row id value\nQTBDROW  DC    F'0'                     TBDISPL row id\nQMDLPT   DC    F'0'                     current table model line\nQAPFR13  DC    F'0'                     save area for R13 across auth\nQAPFSV   DC    7F'0'                    parm list for IKJEFTSR call\n***********************************************************************\n*                                                                     *\n*   ISPF BROWSE INTERFACE                                             *\n*                                                                     *\n***********************************************************************\nQBROWSE  DC    0F'0'\nBRWSAVE  DC    F'0'                     ADDR OF LISTDS SAVEAREA\nBRWEPARM DC    F'0'                     ADDR OF TLD FROM INPUT\nBRWCBTP  DC    F'0'                     COMMON BROWSE TABLE POINTER\nQVTFD    DC    A(TFD)                   Point to block\nTFDMENUP DC    CL142' '                 BLANK VARs (V2ISPF LARGER)\nTFDDCB   DC    (92/4)F'0'               DUMMY DCB\nTFDDSN   DC    H'0',CL44' '             DUMMY DSN\nBRWHDR   DC    CL72' '                  HEADER LINE FOR BROWSE\nBRWMEM   DC    CL8' '                   MEMBER NAME\nBRWSTAMP DC    CL5' '                   LEVEL STAMP\nBRWIOB   DC    8F'0'                    DUMMY IOB\nLISTSW   DC    X'00'                    FLAG IN LISTDS\n*  SMF ID TABLE\n*---  (LOOK IN \"INITIAL\" TO SEE HOW QSYSID IS CREATED FROM QSMFID) ---*\nQSMFID   DC    CL8'????'                SMF ID OF SELECTED JES2\n         DC    CL8'SMF1'                SMF ID FOR SYSTEM 1\n         DC    CL8'SMF2'                                  2\n         DC    CL8'SMF3'                                  3\n         DC    CL8'SMF4'                                  4\n         DC    CL8'SMF5'                                  5\n         DC    CL8'SMF6'                                  6\n         DC    CL8'SMF7'                                  7\n         SPACE 2\n*  SYSTEM ID TABLE\nQSYSID   DC    CL8'????'                SYSTEM ID OF SELECTED JES2\n         DC    CL8'SID1'                SYSTEM ID FOR SYSTEM 1\n         DC    CL8'SID2'                                     2\n         DC    CL8'SID3'                                     3\n         DC    CL8'SID4'                                     4\n         DC    CL8'SID5'                                     5\n         DC    CL8'SID6'                                     6\n         DC    CL8'SID7'                                     7\n         SPACE 3\n         POP   USING\n         SPACE 1\n         LTORG ,                        SHOULD BE ONLY LITS FROM QCOMM\n         EJECT\n***********************************************************************\n*                                                                     *\n*   DATASET ALLOCATION FIELDS                                         *\n*      (ADAPTED FROM SYS1.MACLIB (IKJDAPL,IKJDAP08,18,2C))            *\n*                                                                     *\n***********************************************************************\nDAIRFLAG DC    X'00'                    FLAG FOR ALLOCATE SUBROUTINE\nDAIRECB  DC    F'0'                     ECB USED BY DAIR\n         DC    0D'0'                    ALIGNMENT\n***********************************************************************\n*    THE DYNAMIC ALLOCATION INTERFACE ROUTINE (DAIR) PARAMETER LIST   *\n*    (DAPL) IS A LIST OF ADDRESSES PASSED FROM THE INVOKER TO DAIR    *\n*    VIA REGISTER 1                                                   *\n***********************************************************************\nDAPLUPT  DC    A(0)                     PTR TO UPT\nDAPLECT  DC    A(0)                     PTR TO ECT\nDAPLECB  DC    A(DAIRECB)               PTR TO CP'S ECB\nDAPLPSCB DC    A(0)                     PTR TO PSCB\nDAPLDAPB DC    A(0)                     PTR TO DAIR PARAMETER BLOCK\n***********************************************************************\n*                                                                     *\n*   CHECK TO SEE IF A DSN IS ALLOCATED                                *\n*                                                                     *\n***********************************************************************\nDA00CD   DC    X'0008'                  DAIR ENTRY CODE\nDA00FLG  DC    X'00'                    FLAGS RETURNED\n         DC    X'00'                    RESERVED\nDA00PDSN DC    A(0)                     PTR TO DSN TO BE SRCHED IN DSE\nDA00DDN  DC    CL8' '                   DDNAME TO BE SEARCHED IN DSE\nDA00CTL  DC    X'00'                    FLAG BYTE\n         DC    XL2'0'                   RESERVED\nDA00DSO  DC    X'00'                    RETURNED DSORG\n***********************************************************************\n*                                                                     *\n*   ALLOCATE DDNAME(W) DSNAME(X) SHR UNIT(Y) VOLUME(Z)                *\n*                                                                     *\n***********************************************************************\nDA08CD   DC    X'0008'                  DAIR ENTRY CODE\nDA08FLG  DC    X'00'                    FLAGS SET BY DAIR\n         DC    X'00'\nDA08DARC DC    H'0'                     DYN ALLOC RETURN CODE\nDA08CTRC DC    H'0'                     CATALOG RETURN CODE\nDA08PDSN DC    A(0)                     PTR TO DSN TO BE SRCHED IN DSE\nDA08DDN  DC    CL8' '                   DDNAME TO BE SEARCHED IN DSE\nDA08UNIT DC    CL8'SYSALLDA'            UNIT FOR SYS1.HASPCKPT\nDA08SER  DC    CL8' '                   VOLSER FOR SYS1.HASPCKPT\nDA08BLK  DC    F'0'                     DATA SET AVERAGE REC LENGTH\nDA08PQTY DC    F'0'                     PRIMARY SPACE QUANTITY\nDA08SQTY DC    F'0'                     SECONDARY SPACE QUANTITY\nDA08DQTY DC    F'0'                     DIRECTORY BLOCK QUANTITY\nDA08MNM  DC    CL8' '                   MEMBER NAME\nDA08PSWD DC    CL8' '                   PASSWORD\nDA08DSP1 DC    X'08'                    STATUS FLAGS - SHR\nDA08DPS2 DC    X'08'                    DATA SET DISPOSITION - KEEP\nDA08DPS3 DC    X'08'                    DATA SET COND. DISP. - KEEP\nDA08CTL  DC    X'00'                    DAIR ACTION FLAGS\nDA08TRKS EQU   X'80'                    units are trks\nDA08ABKL EQU   X'40'                    units are blocks\nDA08CYLS EQU   X'C0'                    units are cyls\n         DC    XL3'0'                   RESERVED\nDA08DSO  DC    X'00'                    DSORG\nDA08ALN  DC    CL8' '                   ATTR-LIST-NAME           C99236\n***********************************************************************\n*                                                                     *\n*   FREE DDNAME(XXXXXXXX)                                             *\n*                                                                     *\n***********************************************************************\nDA18CD   DC    X'0018'                  DAIR ENTRY CODE\nDA18FLG  DC    X'00'                    FLAGS SET BY DAIR\n         DC    X'00'\nDA18DARC DC    H'0'                     DYNAMIC ALLOCATION RETURN CODE\nDA18CTRC DC    H'0'                     CATALOG RETURN CODE AREA\nDA18PDSN DC    A(0)                     PTR TO DSN TO BE SRCHED IN DSE\nDA18DDN  DC    CL8' '                   DDNAME TO BE SEARCHED IN DSE\nDA18MNM  DC    CL8' '                   MEMBER NAME\nDA18SCLS DC    CL2' '                   SYSOUT CLASS DESIRED WHEN\n*                                       UNALLOC'ING A SYSOUT DATA SET\nDA18DPS2 DC    X'08'                    DATA SET DISPOSITION - KEEP\nDA18CTL  DC    X'10'                    FLAGS FOR SPECIAL DAIR PROC'ING\nDA18JBNM DC    CL8' '                   IGNORED AS OF OS VS/2 RELEASE 2\n***********************************************************************\n*                                                                     *\n*   MARK A DATASET \"NOT IN USE\"                                       *\n*                                                                     *\n***********************************************************************\nDA2CCD   DC    X'002C'                  DAIR ENTRY CODE\nDA2CFLG  DC    X'0001'                  MARK SPECIFIC DDN \"NOT IN USE\"\nDA2CTCB  DC    XL4'00'                  UNUSED FOR THIS CALL TYPE\nDA2CDDN  DC    CL8' '                   DDNAME TO FLAG\n         EJECT\n***********************************************************************\n*                                                                     *\n*   CHECKPOINT WORK AREAS                                             *\n*                                                                     *\n***********************************************************************\nQCJQELEN DC    Y(0)                     $JQELEN\n          AIF  (&QLEVEL LT 4).QCNOJIX   SKIP IF NOT SP\nQCJIXL   DC    H'0'\nQCJIXA   DC    A(0)                     ADDRESS OF JIX IOAREA\n          AIF  (&QLEVEL LT 7).QCNOJIX   SKIP IF NOT SP136\nQCJQEXA  DC    A(0)                     -> JQE EXTENSIONS\nQCDASL   DC    A(0)                     NBR OF DAS CHKPT BLOCKS\nQCDASA   DC    A(0)                     -> FIRST DAS BLOCK\nQCPSTL   DC    A(0)                     NBR OF PST CHKPT BLOCKS\nQCPSTA   DC    A(0)                     -> FIRST PST BLOCK\n.QCNOJIX  ANOP\nQCNUMTGA DC    A(0)                     NBR OF TRK GRPS ON ACTIVE VOLS\n          AIF  (&QLEVEL GE 8).QCNOTGL   SKIP IF SP220\nQCTGMLEN DC    H'0'                     NUMBER OF BYTES IN 'TGMAP'\n.QCNOTGL  ANOP\nQCJCTA   DC    A(0)                     ADDRESS OF JCT IOAREA\nQCIOTA   DC    A(0)                     ADDRESS OF IOT IOAREA\nQCBLKA   DC    A(0)                     ADDRESS OF DATASET BLOCK IOAREA\nQCBLKTTR DC    F'0'                     MTTR OF QCBLKA -> BLOCK\nQCKMLEN  DC    F'0'                     length of master\nQCSMLEN  DC    F'0'                     rounded length of master\nQCHSBLK  DC    H'0'                     HASPACE BLOCK SIZE\nQCJCTNJN DC    H'0'                     number of haspace blocks alloc\n*                                          for NJE section (SP420 only)\nQCKPTIME DC    F'-1'                    TIME (BIN) CKPT LAST READ\nQC##CKPT DC    F'0'                     NUMBER OF CALLS TO \"CKPT\"\nQC#CKPT# DC    F'0'                     NUMBER OF TIMES READ AVOIDED\nQC##RSPC DC    F'0'                     NUMBER OF CALLS TO \"READSPC\"\nQC#RSPC# DC    F'0'                     NUMBER OF TIMES READ AVOIDED\n          AIF  (&QLEVEL LT 8).QCNOKAC   skip if before SP220\nQKACA    DC    A(0)                     -> KAC\nQKACTUP  DC    XL8'0'                   Time (stck) of last KAC update\n.QCNOKAC  ANOP\n          AIF   (&QLEVEL LT 4).NOTGM    SKIP IF NOT SP\n         DC    H'0'                     EXPANSION SPACE\nQCTGML   DC    H'0'                     NUMBER OF BLOCKS FOR TG MAPS\nQCTGMA   DC    A(0)                     ADDRESS OF TGM IOAREA\n.NOTGM    ANOP\n*  THE FOLLOWING 3 FIELDS MUST BE TOGETHER, IN ORDER\nQCJQTA   DC    A(0)   *ORDER*           ADDRESS OF JQE IOAREA\nQCJQETTR DC    F'0'   *ORDER*           TTR OF FIRST JQE CKPT BLOCK\nQCJQENUM DC    F'0'   *ORDER*           NUMBER OF JQE CKPT BLOCKS\n*  THE FOLLOWING 3 FIELDS MUST BE TOGETHER, IN ORDER\nQCJOTA   DC    A(0)   *ORDER*           ADDRESS OF JOE IOAREA\nQCJOETTR DC    F'0'   *ORDER*           TTR OF FIRST JOE CKPT BLOCK\nQCJOENUM DC    F'0'   *ORDER*           NUMBER OF JOE CKPT BLOCKS\n*\nQCJQEA   DC    A(0)                     ADDR OF CURRENT JQE\nQCJOTL   DC    F'0'                     COUNT OF RECORDS ON CKPT DS\n          AIF   (&QLEVEL GE 5).QCNPDB2\nQCPDDB1  DC    F'0'                     OFFSET IN IOT TO FIRST PDDB\n.QCNPDB2  ANOP\nQCCBID   DC    CL4' '                   CONTROL BLOCK ID TO READ\nQCTRAK   DC    0F'0'                    DISK ADDR IN THE FORM MTTR\nQCTRAKM  DC    X'0'                     EXTENT NUMBER\nQCTRAKTT DC    X'0000'                  ABSOLUTE TRACK NUMBER\nQCTRAKR  DC    X'0'                     RECORD NUMBER\n         DC    X'0'                     EXTRA SPACE NEEDED FOR HEX CONV\nQCDAD    DS    0XL8                     DISK ADDR IN THE FORM MBBCCHHR\n         DC    X'0',X'0000'             EXTENT NUMBER, BIN NUMBER\nQCDADCC  DC    X'0000'                  CYLINDER NUMBER\nQCDADHH  DC    X'0000'                  HEAD NUMBER\nQCDADR   DC    X'0'                     RECORD NUMBER\nQCRECFM  DC    X'0'                     RECFM FOR SAVE\nQCLRECL  DC    H'0'                     LRECL FOR SAVE\nQCJQHEAD DC    A(0)                     OFFSET TO JQE HEADERS\nQCDDTBLA DC    A(0)                     -> DSID TABLE FOR 'NS' SUBCMD\nQCDDTBLL DC    F'0'                     LENGTH OF EXISTING TABLE\nQCDDTBLE DC    A(0)                     ADDR OF CURRENT ENTRY\n*  FORMAT IS C'*T',H'DSID',H'DSID',...,C'*E'\nQCNSDIR  DC    C'N'                     'NS' SUBCMD CURRENT DIRECTION\n         DC    XL3'00'                  SPARE (OR WASTED)\nQCCKPT   DC    A(0)                     -> HASPCKPT DCB\nQCSAVE   DC    A(0)                     -> HASPSAVE DCB\nQCDECB1  DC    A(0)                     -> HASPCKPT DECB\nQCDECB2  DC    A(0)                     -> HASPACE DECB\nQCSPOOLS DC    A(0)                     -> dcblist for haspace\nQCTRKCYL DC    A(0)                     -> trk/cyl list for dcbs\nQCEXTMAP DC    A(0)                     -> map for extents -> dcb list\n         SPACE 10\n***********************************************************************\n*                                                                     *\n*   PRINT WORKAREA part 1                                             *\n*                                                                     *\n***********************************************************************\nQVPRNTWA DC    A(QPRNTWA)               -> most of print work area\n*  The rest of the PRINT fields below are referenced by other routines\nQPPRNT   DC    A(0)                     -> HASPPRNT DCB\nQPFLAG   DC    XL1'00'\nHARDCPY   EQU   X'80'\nQPCLASS  DC    C'A'                     PRINT OUTPUT CLASS\nQPDEST   DC    CL8' '                   PRINT OUTPUT DEST\n         EJECT ,\n***********************************************************************\n*                                                                     *\n*   GETREC, GETPDDB WORK FIELDS                                       *\n*                                                                     *\n***********************************************************************\nQCPDBOFF DC    H'0'                     offset of current pddb in iot\n         QDSTAB  PREFIX=QP\n         QDSTAB  PREFIX=QCC,PTR=YES\n         QDSTAB  PREFIX=QCH,PTR=YES\nQCGRMTTR DC    A(0)                     mttr for getrec to start at\nQCGRPTR  DC    A(0)                     -> current record\nQCGRLEN  DC    H'0'                     len of current record\nQMLINECT DC    AL1(60)                  qmode lines/page\nQSLINECT DC    AL1(0)                   jes2  lines/page\nQJLINECT DC    AL1(0)                   jct   lines/page\nQPLINECT DC    AL1(0)                   dsid  lines/page\nQCRHOLD  DC    PL1'0'                   hold for line count\nQCRFLAG  DC    X'00'                    flags for prev/next line\nQRFSKP1  EQU   X'80'                    prev cmd was skp ch 1\nQRFEOF   EQU   X'40'                    end of data reached\nQRFINIT  EQU   X'20'                    initialize to top of dataset\nQRFDIR   EQU   X'10'                    specific rec num request\nQRFERR   EQU   X'08'                    error occured reading b\nQGPFLAG  DC    X'00'                    getpddb flags\nQPFINIT  EQU   X'80'                    init to first pddb\nQPFDIR   EQU   X'40'                    get a specific pddb\nQPFSPIN  EQU   X'20'                    searching spin iot chain\nQPFSNUL  EQU   X'10'                    skip null pddbs\nQPFNMSG  EQU   X'08'                    return direct; \u00acfound\nQPFNOSW  EQU   X'04'                    don't go to spin iot chain\nQPFNIOT  EQU   X'02'                    new iot has been read\n         SPACE 5\n***********************************************************************\n*                                                                     *\n*   DISPLAY WORK FIELDS                                               *\n*                                                                     *\n***********************************************************************\nQVPFKEYS DC    A(QPFKAREA)              PTR TO PFK AREA\nQVSAVE   DC    A(QDSAVE)                PTR TO DISPLAY SAVE AREA\nQVSTACK  DC    A(QDSTACK)               PTR TO SUBCOMMAND STACK AREA\nQVSTACKC DC    A(QDSTACK)               PTR TO CURRENT TOP OF STACK\nQVRING   DC    A(QCMDRING)              PTR TO COMMAND RING FOR RECALL\nQCMDNUM  DC    H'0'                     CURRENT COMMAND NUMBER\nQRETNUM  DC    H'0'                     COMMAND NUMBER TO RECALL NEXT\nQVINPUT  DC    A(*-*)                   -> INPUT AREA IN SCREEN BUFFER\nQVHLINE  DC    A(*-*)                   -> HEADER LINE\nQVLINE1  DC    A(*-*)                   -> FIRST DATA LINE\nQDLCTBL  DC    A(*-*)                   -> VALID LINE COMMANDS TABLE\n*                                       (SEE DSECT IN FRONT OF QDLCBUF)\nQVLCBUF  DC    A(QDLCBUF)               -> LINE COMMAND WORK AREA\nQDCLEARL DC    F'0'                     LENGTH OF DATA AREA TO CLEAR\nQDNEXT   DC    A(0)                     -> NEXT LOC IN OUTPUT SCRN BUFF\nQDREPLYL EQU   66                       LENGTH OF REPLY AREA\nQACTION  DC    CL8'***OK***'            RESPONSE FROM LINE COMMAND\n*=====================================================================*\nQSAVE2   EQU   *                        START FIELDS SAVED IN DISPLAY |\n*  KEEP FIELDS QSAVE2 THRU QSAVE2L TOGETHER FOR MVC IN \"DISPLAY\"      |\nQDREPLY  DC    CL(QDREPLYL)'STATUS'     TERMINAL USER REPLY           |\nQDRLNG   DC    H'6'                     REPLY LENGTH                  |\nQSAVE2L  EQU   *-QSAVE2                 LENGTH OF SAVED FIELDS        |\n*=====================================================================*\nQERRMSG  DC    CL79' '                  ERROR MESSAGE, IF ANY\nQDPROMPT DC    CL(QDREPLYL)'STATUS'     USER'S PREVIOUS COMMAND\nQINQCMD  DC    CL(QDREPLYL)'STATUS'     LAST INQUIRY COMMAND\nQFINDCMD DC    CL(QDREPLYL)'FIND'       LAST \"FIND\" COMMAND\nQTSOCMD  DC    CL(QDREPLYL)'TSO'        LAST \"TSO\" COMMAND\nQMVSCMD  DC    CL(QDREPLYL)'/'          LAST \"/\" OR JES2 COMMAND\nQDMSG    DC    CL(132+7*2)' '           AREA FOR BUILDING OUTPUT LINE\nQCPU     DC    C'nnn'                   CPU PERCENTAGE\nQDPR     DC    C'nnn'                   DEMAND PAGE RATE\nQDHDSID  DC    CL8' '                   CURRENT DATASET ID\nQDHJOBID DC    C'JOBNAMEX(JOBNNNNN)',C' '\nQDHISFID DC    C'------------------'    Header for ISPF line\nQDCOLNOW DC    H'80'                    SCREEN WIDTH ON LAST WRITE\nQDLINES  DC    H'24'                    NUMBER OF ACTUAL DISPLAY LINES\nQDROWS   DC    H'21'                    NUMBER OF USABLE DISPLAY LINES\nQDCOLS   DC    H'80'                    LENGTH OF EACH DISPLAY LINE\nQDLINECT DC    H'0'                     CURRENT LINE NUMBER ON SCREEN\nQDATRNUM DC    H'0'                     NUMBER OF ATTR BYTES IN LINE\nQDOVER   DC    X'00'                    PAGE OVERFLOW INDICATOR\nQDERASE  DC    X'F5'                    ERASE WRITE OR ERASE WRITE ALT\nQDHLINE  DC    CL79' ',CL(132-80)' '    HEADING LINE\n         SPACE 1\nQDSCREEN DS    0C                       DISPLAY SCREEN BUFFER\n         DC    X'27'                    \"ESC\": 3270 COMMAND FOLLOWS\nQD3270OP DC    X'F5'                    3270 ERASE WRITE COMMAND\n*                                       X'F1' = 3270 NORMAL WRITE CMD\n*                                       X'7E' = 3270 ERASE WRITE ALT\nQDWCC    DC    X'C1'                    WCC:  RESET MDT\n         DC    X'115D7F'                SPF-TCAM PREFIX\n         DC    X'114040'                SBA TO TOP LEFT CORNER\n         DC    X'1DE8'                  ATTR - PROT BRIGHT\nQDQUEUE  DC    C'QUEUE -'               TITLE IN UPPER LEFT CORNER\nQDTOP    DC    CL72' '\n         DC    42CL(80+8*2)' ',CL20' '  REST OF SCREEN BUFFER\nQDSCRLEN EQU   *-QDSCREEN               LENGTH OF BUFFER\n         SPACE 2\n*  AREA FOR \"DISPLAY\" TO SAVE IMPORTANT THINGS WHICH \"PARSE\" CHANGES\nQDSAVE   DS    0XL(QSAVE1L+QSAVE2L)'00'\n         DC    (L'QDSAVE)X'00'          TO GET LENGTH ATTRIBUTE CORRECT\n         SPACE 2\n***********************************************************************\n*                                                                     *\n*   PRINT WORKAREA part 2 (not directly addressable)                  *\n*                                                                     *\n***********************************************************************\n*  Fields in this section are referenced only by PRINT\nQPRNTWA  DC    0F'0'\nQPHEAD0  DC    H'137,0'                 VBA length\nQPHEAD1  DC    CL1'1'\n*                   123456789.123456789.123456789.123456789.'\n         DC    CL40'QUEUE HARDCOPY LOG  USER=XXXXXXX   DATE='\n         DC    CL40'YY.DDD  HH:MM:SS DAY MON DD,19XX   XXXXX'\n         DC    CL52' '\n         ORG   QPHEAD1+26\nQPUSER   DC    CL7' '                   FOR USERID\n         ORG   QPHEAD1+41\nQPDATE   DC    CL32' '\n         ORG   QPHEAD1+75\nQPAGEN#  DC    CL6' '\n         ORG   ,\nQPAGEN   DC    PL3'1'\nQPUCS    DC    CL4' '                   PRINT OUTPUT UCS\nQPFCB    DC    CL4' '                   PRINT OUTPUT FCB\nQPFORM   DC    CL4' '                   PRINT OUTPUT FORM\n         SPACE 3\nLCTABLE  DSECT                          TABLE OF VALID LINE COMMANDS\nLCTCMDNM DS    CL2                      LINE COMMAND NAME\nLCTTRUNM DS    CL4                      TRUE COMMAND NAME\nLCTFLAGS DS    B\nLCTFDCMD  EQU   X'80'                   CMD MODIFIES SCREEN BUFFER\nLCTFPRIV  EQU   X'40'                   CMD IS PRIVILEGED\nLCTFDD    EQU   X'20'                   THIS IS \"DD\" SCREEN\nLCTELEN  EQU   *-LCTABLE                LENGTH OF A TABLE ENTRY\n         SPACE 2\nLCBUFF   DSECT                          LINE COMMANDS INPUT SAVE AREA\n         QLCB  ,\nLCBELEN  EQU   *-LCBUFF                 LENGTH OF A TABLE ENTRY\n         SPACE 2\nQCOMMON  &QDTYPE                        RESUME\n         SPACE 3\n*  WORK AREA TO SUPPORT LINE COMMANDS -- FORMAT IS LCBUFF DSECT\nQDLCBUF  DC    40XL(LCBELEN)'00'\n*\n*    VARIABLES FOR ISPF TABLES SUPPORT\n*\n         ORG   QDTOP\nV8VAR    DS    0F            --|\nQLCBE    DS    CL(LCBELEN)     |\nQF1      DS    CL79            |     must remain together\nQF2      DS    CL18            |     to allow a single\nQF3      DS    CL8             |     VDEFINE to work\nQF4      DS    CL61            |     and the code in DISPLAY\nQF5      DS    CL17            |\nQF6      DS    CL32            |     lengths must match VLEN8\nQF7      DS    CL30          --|\n         ORG   ,\n         SPACE 3\n***********************************************************************\n*                                                                     *\n*   ISPF BROWSE INTERFACE   -   independent addressability            *\n*            Initialized in LISTDS                                    *\n*                                                                     *\n***********************************************************************\n         DC    0F'0'\nTFD      DC    CL4'TFD:',XL204'00'\n         ORG   TFD+5\n         DC    X'7E'                    TFDSTAT2 (CDO/CDC STAT BITS)\n         ORG   TFD+50\n         DC    X'2400'                  TFDMACRF (READ POINT)\n         DC    X'08'                    TFDDSP1 (STATUS)\n         DC    X'08'                    TFDDSP2 (DISP)\n         ORG   TFD+64\n         DC    A(TFDMENUP)              POINTER TO VAR VALUES\n         DC    A(TFDDCB)                POINTER TO DCB\n         ORG   TFD+128\n         DC    A(TFDDSN)                PTR TO DSN\n         ORG   ,                        END OF TFD\n         SPACE 3\nQPFKAREA DC    0D'0'                    ADDRESSABLE VIA \"QVPFKEYS\"\n         @GLOBALC  QUEUE,PFKDFLT        generate default PFkeys\n         SPACE 3\nQDSTACK  DC    XL2'00',CL(QDREPLYL)'EXIT'  BOTTOM STACK ENTRY\nQDSTACKL EQU   *-QDSTACK                LENGTH OF A STACK ENTRY\n         DC    9XL(QDSTACKL)'00'        SPACE FOR 10 DEEP STACKING\n         SPACE 3\nQCMDRING DC    16CL(QDREPLYL)' '        COMMAND RING FOR RECALL\n         SPACE 3\nQTRACEWA DC    5F'0',CL80' '            QTRACE work area\n         SPACE 3\n         AIF   ('&CSECT' NE 'YES').NOLEVEL SKIP IF NOT GENERATING CSECT\n         ENTRY QLEVEL\n.NOLEVEL ANOP\nQLEVEL   DC    C'&&QLEVEL='             eyecatcher\n         AIF   (&QLEVEL GT 9).LEVEL2\n         DC    C' &QLEVEL'\n         AGO   .LEVELOK\n.LEVEL2  ANOP\n         DC    C'&QLEVEL'\n.LEVELOK ANOP\n         EJECT\n         QZIHAETD ,\n         EJECT\nQCOMMON  &QDTYPE ,\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "QCQQ": {"ttr": 17671, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x00\\x00\\x00\\x00\\x90&\\x0f\\x00\\x91\\x04\\x9f\\x02A\\x00\\x06\\x00\\x06\\x00\\x00\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "02.00", "flags": 0, "createdate": "1990-09-17T00:00:00", "modifydate": "1991-02-18T02:41:00", "lines": 6, "newlines": 6, "modlines": 0, "user": "LDW"}, "text": "PROC 0\nSET QCMD = QQ\nISPEXEC VPUT QCMD SHARED\nISPEXEC CONTROL NONDISPL END\nEXIT\n/*  PASS PARM INTO Q FROM BROWSE SCREEN */\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "QCQQX": {"ttr": 17673, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x91\\x04\\x9f\\x00\\x91\\x04\\x9f\\x02I\\x00\\x04\\x00\\x04\\x00\\x00\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-02-18T00:00:00", "modifydate": "1991-02-18T02:49:00", "lines": 4, "newlines": 4, "modlines": 0, "user": "LDW"}, "text": "/* Rexx exec to pass parm into QUEUE from browse screen */\nqcmd = 'QQ'\nAddress ISPEXEC \"VPUT QCMD SHARED\"\nAddress ISPEXEC \"CONTROL NONDISPL END\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "QDCB": {"ttr": 17675, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x0c\\x00\\x00\\x00\\x82#_\\x00\\x894O#A\\x00Z\\x00*\\x009\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "05.12", "flags": 0, "createdate": "1982-08-23T00:00:00", "modifydate": "1989-12-10T23:41:00", "lines": 90, "newlines": 42, "modlines": 57, "user": "LDW"}, "text": "         MACRO\n         QDCB\n.*--------------------------------------------------------------------*\n.*                                                                    *\n.*  QDCB - Expand DCB'S and DCB EQU'S                                 *\n.*                                                                    *\n.*  Updates:                                                          *\n.*     10Dec89  LDW  Change QDCBD to QZDCBD                           *\n.*     21May87  EMS  Split out dcb equates into QDCBD                 *\n.*     17JUN86  LDW  ADD DCBDVTBA                                     *\n.*     03JUN86  LDW  ADD DCBNCP AND HDECB1L                           *\n.*     08/06/84 LDW  IF SP, LEAVE OUT BLKSIZE FROM HASPCKPT DCB (IT   *\n.*                      WILL BE FILLED IN IN \"INITIAL\")               *\n.*                   IF SP, LEAVE OUT BLKSIZE FROM HDECB1 (NEED TO    *\n.*                      DO VARIABLE LENGTH READ FOR MASTER RECORD)    *\n.*                   CHANGE HELPDCB DDNAME FROM QHELP TO ISPPLIB      *\n.*                      (SOMEDAY, I'LL EVEN WRITE THE CODE TO USE IT) *\n.*     01/17/84 LDW  ADD HELPDCB, HELPDECB                            *\n.*     01/07/83 LDW  MISC MINOR CLEANUP                               *\n.*     11/11/82 EMS  ADD SOME DCB EQU'S FOR \"SAVE\"                    *\n.*                   REMOVE BUFL=8192 FROM HASPSAVE DCB, ADD EXLST=0  *\n.*                                                                    *\n.*--------------------------------------------------------------------*\n.*\n         GBLA  &QLEVEL\n         GBLB  &QDCB\n         AIF   (&QDCB).MEND\n&QDCB    SETB  1\n***********************************************************************\n*        FIRST, PUT THE LENGTH OF QCOMMON INTO QCOMMON FOR INIT'S     *\n*        GETMAIN.                                                     *\n***********************************************************************\n         SPACE 1\n         ORG   QGETMAIN\n         DC    A(QCOMMONL)\n         ORG   ,\n         SPACE 1\n***********************************************************************\n*        MISCELLANEOUS DCB DEFINITIONS                                *\n*        (THIS MUST FOLLOW THE QCOMMON EXPANSION)                     *\n***********************************************************************\n         SPACE 1\nQDCB     DC    0D'0'\n         SPACE 3\n         AIF   (&QLEVEL GE 3).QDCB01\n*HASPCKPT DCB  DDNAME=HASPCKPT,DSORG=PS,MACRF=(RCP),RECFM=U,           $\n               BLKSIZE=4096\nHASPCKPT DCB   DDNAME=HASPCKPT,DSORG=PS,MACRF=(RCP),RECFM=U,           $\n               BLKSIZE=4096\n         AGO   .QDCB02\n.QDCB01  ANOP\n*HASPCKPT DCB  DDNAME=HASPCKPT,DSORG=PS,MACRF=(RCP),RECFM=U\nHASPCKPT DCB   DDNAME=HASPCKPT,DSORG=PS,MACRF=(RCP),RECFM=U\n.QDCB02  ANOP\n         SPACE 5\n*HASPSAVE DCB  DDNAME=HASPSAVE,DSORG=PS,MACRF=(PM),EXLST=0\nHASPSAVE DCB   DDNAME=HASPSAVE,DSORG=PS,MACRF=(PM),EXLST=0\n         SPACE 5\n         AIF   (&QLEVEL GE 3).QDCB03\n*        READ  HDECB1,SF,,,4096,MF=L    HASPCKPT DECB\n         READ  HDECB1,SF,,,4096,MF=L    HASPCKPT DECB\n         AGO   .QDCB04\n.QDCB03  ANOP\n*        READ  HDECB1,SF,,,'S',MF=L     HASPCKPT DECB\n         READ  HDECB1,SF,,,'S',MF=L     HASPCKPT DECB\n.QDCB04  ANOP\nHDECB1L  EQU   *-HDECB1                 LENGTH OF ONE DECB\n         SPACE 3\n*        READ  HDECB2,DI,,,0,0,0,MF=L   HASPACE DECB\n         READ  HDECB2,DI,,,0,0,0,MF=L   HASPACE DECB\n         SPACE 6\n*  EODAD ADDRESS WILL BE FILLED IN AT OPEN TIME\n*HELPDCB DCB   DDNAME=ISPPLIB,DSORG=PS,MACRF=RCP,RECFM=FB,LRECL=80,    $\n               EODAD=*-*+1\nHELPDCB  DCB   DDNAME=ISPPLIB,DSORG=PS,MACRF=RCP,RECFM=FB,LRECL=80,    $\n               EODAD=*-*\n         SPACE 3\n*        READ  HELPDECB,SF,,,0,0,0,MF=L QHELP DECB\n         READ  HELPDECB,SF,,,0,0,0,MF=L QHELP DECB\n         SPACE 6\n*HASPPRNT DCB  DDNAME=HASPPRNT,DSORG=PS,MACRF=(PM),                    $\n               RECFM=FBA,LRECL=133,BLKSIZE=6118\nHASPPRNT DCB   DDNAME=HASPPRNT,DSORG=PS,MACRF=(PM),                    $\n               RECFM=FBA,LRECL=133,BLKSIZE=6118\n         SPACE 2\nQCOMMONL EQU   *-QCOMMON                LENGTH OF ENTIRE QCOMMON\n         SPACE 3\n*        QZDCBD ,\n         QZDCBD ,\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "QDEBUG": {"ttr": 17678, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x91\\x19_\\x00\\x91\\x19_\"4\\x00\\n\\x00\\n\\x00\\x00\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-07-14T00:00:00", "modifydate": "1991-07-14T22:34:00", "lines": 10, "newlines": 10, "modlines": 0, "user": "LDW"}, "text": "         MACRO\n&NFS     QDEBUG  &FLAG,&TEXT\n         LCLC  &BYTE,&IHBNX\n&BYTE    SETC  '&FLAG'(1,7)\n&IHBNX   SETC  'IHB&SYSNDX'\n&NFS     TM    &BYTE,&FLAG\n         BZ    &IHBNX\n         TPUTX &TEXT\n&IHBNX   EQU   *\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "QDSTAB": {"ttr": 17680, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x87\\x13\\x9f\\x00\\x87\\x14\\x0f\\x188\\x00\\x1b\\x00\\x17\\x00\\x00\\xc5\\xd4\\xe2@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1987-05-19T00:00:00", "modifydate": "1987-05-20T18:38:00", "lines": 27, "newlines": 23, "modlines": 0, "user": "EMS"}, "text": "         MACRO\n         QDSTAB  &PREFIX=,&DSECT=NO,&PTR=NO,&MTTR=NO,&ABS=YES\n.*--------------------------------------------------------------------*\n.*                                                                    *\n.*  UPDATES:                                                          *\n.*                                                                    *\n.*--------------------------------------------------------------------*\n         LCLC  &P\n&P       SETC  '&PREFIX'\n         AIF   ('&DSECT' EQ 'NO').NODSECT\n&P.TBL   DSECT ,\n         AGO   .LABELS\n.NODSECT DC    0F'0'                    Align to full word\n.LABELS  ANOP  ,\n         AIF   ('&MTTR' EQ 'NO').NOMTTR\n&P.MTTR  DC    F'0'                     mttr of record\n.NOMTTR  ANOP  ,\n&P.REC   DC    PL4'0'                   current line\n&P.PAGE  DC    PL4'0'                   current page\n&P.LINE  DC    PL2'0'                   current line in page (pg mode)\n         AIF   ('&ABS' EQ 'NO').NOABS\n&P.LINEA DC    PL2'0'                   current line in page (abs)\n.NOABS   AIF   ('&PTR' EQ 'NO').NOPTR\n&P.PTR   DC    A(0)                     -> current table addr\n.NOPTR   AIF   ('&DSECT' EQ 'NO').MEND\n&P.TBLL  EQU   *-&P.TBL                 len of dsect\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "QGLOBAL@": {"ttr": 17682, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05:\\x00\\x00\\x00\\x82#/\\x00\\x91\\x11?\\x19X\\x00\\xac\\x00:\\x00\\x94\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "05.58", "flags": 0, "createdate": "1982-08-20T00:00:00", "modifydate": "1991-04-23T19:58:00", "lines": 172, "newlines": 58, "modlines": 148, "user": "LDW"}, "text": "*\n*  GLOBAL ASSEMBLY OPTIONS FOR QUEUE COMMAND\n*\n*  Updates:\n*    23Apr91  LDW  HJE4420 - Level 12 - added\n*    27Mar91  LDW  Add &QSFXCK and &QSFXHS for Eric Schindler\n*    15Mar91  LDW  Automatically set &QJQEOWN to JQEUSRID if JES2 3.1.3\n*                  Generate warnings for support which may be dropped\n*    25Jan91  LDW  HJE4410 - Level 11 - added\n*    22Nov90  LDW  If &QLEVEL = 0, set it based on $HASPGBL &VERSION\n*                  (Remove &PRINT, since it's defined in $HASPGBL)\n*    31Jul90  EMS  HJE3313 - Level 10 - added (comment only)\n*    04Jun89  LDW  Add &QEXKEY - execution key\n*    25Apr89  EMS  HJE3311 - Level 9 - added (comment only)\n*    23Jan89  LDW  Add default PFK settings (&QPFK01 - &QPFK24)\n*    02Feb88  LDW  HJE2221 - Level 8 - added (comment only)\n*    17Jan87  LDW  &QALTCCH renamed to &QALTCC\n*    22JUN86  LDW  &QACF2 DELETED (NOW CONTROLLED BY @GLOBALS: &@@ACF2)\n*                  ALWAYS \"COPY @GLOBALS\"\n*\n         GBLC  &ACF2JCT                 FIELD NAME OF OFFSET OF ACF2\n*                                       JCT EXTENSION (SET BY #ACFJES2)\n         GBLC  &DOC                     PRINT OPTION FOR HASP AND OS\n*                                       DSECTS:  'GEN' OR 'NOGEN'\n***      GBLC  &PRINT                   PRINT OPTION FOR EXECUTABLE\n*                                       CODE:  'GEN' OR 'NOGEN'\n         GBLC  &QALTCC                  NAME OF $SVT FIELD FOR ALTCOMCH\n         GBLA  &QCHKNCP       03JUN86   NUMBER OF DECBS FOR CHKPT\n         GBLC  &QEXKEY        04Jun89   execution key (0-7)\n         GBLB  &QGBLSET                 GLOBAL OPTIONS SET SWITCH\n         LCLA  &QI                      LOOP VARIABLE\n         GBLC  &QJQEOWN                 NAME OF JOB OWNER FIELD IN JQE\n         LCLC  &QLCLEQ(3)               UNIT ROUTES TO CONSIDER LOCAL\n         LCLA  &QLCLEQN                 NUMBER OF ENTRIES IN &QLCLEQ\n         GBLA  &QLEVEL                  VERSION OF JES2 SUPPORTED\n*                         3 = EJE1102   JES2 4.1 WITH PTF AZ27300\n*                         3 = EJE1103   JES2 4.1 + AZ27300 + 3800E\n*                         3 = JJE1112   JES2 NJE 3.0\n*                         3 = HJE1104   JES2 NJE 3.1 + 3800E\n*                         4 = HJE2226   JES2 SP1.3.0 / SP2.1.0\n*                         5 = HJE2329   JES2 SP1.3.3 / SP2.1.1\n*                         6 = HJE2330   JES2 SP1.3.4 / SP2.1.2\n*                         7 = HJE1367   JES2 SP1.3.6\n*                         7 = HJE2215   JES2 SP2.1.5\n*                         8 = HJE2221   JES2 SP2.2.0\n*                         9 = HJE3311   JES2 SP3.1.1\n*                        10 = HJE3313   JES2 SP3.1.3\n*                        11 = HJE4410   JES2 SP4.1.0\n*                        12 = HJE4420   JES2 SP4.2.0\n         GBLB  &QNJE                    SET TO 1 ONLY FOR NON-SP NJE\n         GBLC  &QPFK01,&QPFK02,&QPFK03,&QPFK04,&QPFK05,&QPFK06\n         GBLC  &QPFK07,&QPFK08,&QPFK09,&QPFK10,&QPFK11,&QPFK12\n         GBLC  &QPFK13,&QPFK14,&QPFK15,&QPFK16,&QPFK17,&QPFK18\n         GBLC  &QPFK19,&QPFK20,&QPFK21,&QPFK22,&QPFK23,&QPFK24\n         LCLA  &QSIDNUM                 NUMBER OF ENTRIES IN &QSIDTBL\n         LCLC  &QSIDTBL(3)              SMFID/DISPLAYNAME\n         LCLC  &QSFXCK                  '.HASPCKPT'\n         LCLC  &QSFXHS                  '.HASPACE'\n         LCLA  &QSYSNUM                 NUMBER OF ENTRIES IN &QSYSTBL\n         LCLC  &QSYSTBL(99)             SYSRES/JESN/CHKPTV/PREFIX\n         LCLC  &QSTDFRM                 STANDARD FORM NAME\n         GBLB  &QTMPMAC                 TMPMAC SERVICE ROUTINE OPTION\n         COPY  @GLOBALS                 GET INSTALLATION GLOBALS\n         COPY  $HASPGBL                 for &VERSION\n         AIF   (&QGBLSET).QGBLSET       SKIP IF ALREADY SET\n&QGBLSET SETB  1                        OPTIONS NOW SET\n*\n*\n*\n*  THE SETTINGS BELOW WILL NEED TO BE MODIFIED WHEN ASSEMBLING QUEUE\n*  FOR YOUR INSTALLATION.\n*\n&DOC     SETC  'NOGEN'                  SUPPRESS DSECT EXPANSIONS\n&PRINT   SETC  'GEN'                    WASTE SOME PAPER\n&QALTCC  SETC  ''    '$SVALTCC'         NAME OF ALT COMCHR FIELD IN SVT\n&QCHKNCP SETA  10                       A 3380 TRACK WORTH\n&QEXKEY  SETC  'KEY4'                   execution key -- MODESET EXTKEY\n&QJQEOWN SETC  'JQESLID'                NAME OF JOB OWNER FIELD IN JQE\n&QLEVEL  SETA  0                        set based on $HASPGBL &VERSION\n         AIF   (&QLEVEL NE 0).GOTLVL    skip if &QLEVEL set\n&QLEVEL  SETA  12\n         AIF   ('&VERSION' EQ 'SP 4.2.0').GOTLVL  HJE4420\n&QLEVEL  SETA  11\n         AIF   ('&VERSION' EQ 'SP 4.1.0').GOTLVL  HJE4410\n&QLEVEL  SETA  10\n         AIF   ('&VERSION' EQ 'SP 3.1.3').GOTLVL  HJE3313\n&QLEVEL  SETA  9\n         AIF   ('&VERSION' EQ 'SP 3.1.1').GOTLVL  HJE3311\n&QLEVEL  SETA  8\n         AIF   ('&VERSION' EQ 'SP 2.2.0').GOTLVL  HJE2211\n&QLEVEL  SETA  7                        this version of JES2 is broken\n         AIF   ('&VERSION' EQ ''        ).GOTLVL  2.1.5 / 1.3.6\n         AIF   ('&VERSION' EQ 'SP 2.1.5').GOTLVL  HJE2215\n         AIF   ('&VERSION' EQ 'SP 1.3.6').GOTLVL  HJE1367\n         MNOTE 0,'*** QUEUE support for this level of JES2 may be.'\n         MNOTE 0,'*** discontinued.  Read Note1 in $$$INST.'\n&QLEVEL  SETA  6\n         AIF   ('&VERSION' EQ 'SP 1.3.4').GOTLVL  HJE2330 (also 2.1.2)\n&QLEVEL  SETA  5\n         AIF   ('&VERSION' EQ 'SP 1.3.3').GOTLVL  HJE2329 (also 2.1.1)\n&QLEVEL  SETA  4\n         AIF   ('&VERSION' EQ 'SP 1.3.0').GOTLVL  HJE2226 (also 2.1.0)\n&QLEVEL  SETA  3\n.*                                      EJE1102 EJE1103 JJE1112 HJE1104\n.GOTLVL  ANOP\n         AIF   (&QLEVEL LT 10).QGJQEOK  don't set QJQEOWN if < 3.1.3\n&QJQEOWN SETC  'JQEUSRID'               NAME OF JOB OWNER FIELD IN JQE\n.QGJQEOK ANOP\n&QNJE    SETB  0                        JES2/SP INCLUDES NJE\n&QPFK01  SETC  'H'\n&QPFK02  SETC  'ST'\n&QPFK03  SETC  'END'\n&QPFK04  SETC  'PR'\n&QPFK05  SETC  'F'\n&QPFK06  SETC  'NS *'\n&QPFK07  SETC  'U'\n&QPFK08  SETC  'D'\n&QPFK09  SETC  'AO'\n&QPFK10  SETC  'LE'\n&QPFK11  SETC  'RI'\n&QPFK12  SETC  'RC'\n&QPFK13  SETC  '&QPFK01'\n&QPFK14  SETC  '&QPFK02'\n&QPFK15  SETC  '&QPFK03'\n&QPFK16  SETC  '&QPFK04'\n&QPFK17  SETC  '&QPFK05'\n&QPFK18  SETC  '&QPFK06'\n&QPFK19  SETC  '&QPFK07'\n&QPFK20  SETC  '&QPFK08'\n&QPFK21  SETC  '&QPFK09'\n&QPFK22  SETC  '&QPFK10'\n&QPFK23  SETC  '&QPFK11'\n&QPFK24  SETC  '&QPFK12'\n&QSFXCK  SETC  '.HASPCKPT'              suffix for SYS1.HASPCKPT\n&QSFXHS  SETC  '.HASPACE'               suffix for SYS1.HASPACE\n&QSTDFRM SETC  'STD'                    STANDARD FORM NAME\n&QTMPMAC SETB  1                        TMPMAC IS SUPPORTED\n*\n*  OUTPUT DESTINATIONS WITH THE FOLLOWING NAMES ARE CONSIDERED TO BE\n*  'LOCAL' FOR PURPOSES OF DO/AO SUBCOMMANDS\n&QLCLEQ(01) SETC 'LASER'\n&QLCLEQ(02) SETC 'LASER1'\n&QLCLEQ(03) SETC 'LASER3'\n&QLCLEQN SETA  0  *********             NUMBER OF LOCAL EQUIVALENTS\n*\n*\n&QSIDNUM SETA  0  *********             NUMBER OF SMFID TABLE ENTRIES\n*  ONE ENTRY IS NEEDED FOR EACH SMFID TO BE DISPLAYED AS SOMETHING ELSE\n*\n&QSIDTBL(01) SETC 'SCG2'.'A084'\n&QSIDTBL(02) SETC 'SCG3'.'3090'\n&QSIDTBL(03) SETC 'SCG4'.'B084'\n&QSIDTBL(04) SETC 'SCG5'.'4381'\n*\n*\n&QSYSNUM SETA  10                       NUMBER OF SYSTEM TABLE ENTRIES\n*  ONE ENTRY IS NEEDED FOR EACH SYSRES/JES2 PAIR        SYSRES   JES2\n*                                                       ------   ----\n&QSYSTBL(01) SETC 'MVSAR1'.'JES2'.'MVSA13'.'SYS1    ' MVSA prod  prod\n&QSYSTBL(02) SETC 'MVSAR2'.'JES2'.'MVSA13'.'SYS1    ' MVSA prod  prod\n&QSYSTBL(03) SETC 'MVSAR1'.'JESA'.'MVSA13'.'SYS1    ' MVSA prod  shr\n&QSYSTBL(04) SETC 'MVSAR2'.'JESA'.'MVSA13'.'SYS1    ' MVSA prod  shr\n&QSYSTBL(05) SETC 'MVSAR1'.'JESB'.'MVSA11'.'SYS8.JB ' MVSA prod  test\n&QSYSTBL(06) SETC 'MVSAR2'.'JESB'.'MVSA11'.'SYS8.JB ' MVSA prod  test\n&QSYSTBL(07) SETC 'MVSAR1'.'JESC'.'MVSA15'.'SYS8.JC ' MVSA prod  test\n&QSYSTBL(08) SETC 'MVSAR2'.'JESC'.'MVSA15'.'SYS8.JC ' MVSA prod  test\n&QSYSTBL(09) SETC 'MVSBAK'.'JES2'.'MVSBAK'.'MVSBACK ' MVSZ bkup  bkup\n&QSYSTBL(10) SETC 'MVSXR1'.'JES2'.'MVSTST'.'MVSTEST ' MVST test  prod\n.QGBLSET ANOP\n*\n*  END OF QUEUE COMMAND GLOBALS\n*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "QGLOBALS": {"ttr": 17924, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05;\\x00\\x00\\x00\\x82#/\\x00\\x91\\x18_#I\\x00\\x18\\x00:\\x00\\x15\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "05.59", "flags": 0, "createdate": "1982-08-20T00:00:00", "modifydate": "1991-07-04T23:49:00", "lines": 24, "newlines": 58, "modlines": 21, "user": "LDW"}, "text": "*\n*  GLOBAL ASSEMBLY OPTIONS FOR QUEUE COMMAND\n*\n*  Updates:\n*    04Jul91  LDW  Most variables moved to @GLOBALS & @GLOBALC\n*    23Apr91  LDW  HJE4420 - Level 12 - added\n*    27Mar91  LDW  Add &QSFXCK and &QSFXHS for Eric Schindler\n*    15Mar91  LDW  Automatically set &QJQEOWN to JQEUSRID if JES2 3.1.3\n*                  Generate warnings for support which may be dropped\n*    25Jan91  LDW  HJE4410 - Level 11 - added\n*    22Nov90  LDW  If &QLEVEL = 0, set it based on $HASPGBL &VERSION\n*                  (Remove &PRINT, since it's defined in $HASPGBL)\n*    31Jul90  EMS  HJE3313 - Level 10 - added (comment only)\n*    04Jun89  LDW  Add &QEXKEY - execution key\n*    25Apr89  EMS  HJE3311 - Level 9 - added (comment only)\n*    23Jan89  LDW  Add default PFK settings (&QPFK01 - &QPFK24)\n*    02Feb88  LDW  HJE2221 - Level 8 - added (comment only)\n*    17Jan87  LDW  &QALTCCH renamed to &QALTCC\n*    22JUN86  LDW  &QACF2 DELETED (NOW CONTROLLED BY @GLOBALS: &@@ACF2)\n*                  ALWAYS \"COPY @GLOBALS\"\n*\n         GBLA  &QLEVEL                  level of JES2 for this QUEUE\n         GBLC  &QJ2VERS                 &VERSION saved here by QSTART\n         COPY  @GLOBALS\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "QHASPEQ@": {"ttr": 17926, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x87\\x05/\\x00\\x905O\\x17A\\x00M\\x00.\\x00\\x1d\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1987-02-21T00:00:00", "modifydate": "1990-12-20T17:41:00", "lines": 77, "newlines": 46, "modlines": 29, "user": "LDW"}, "text": "         MACRO\n         QHASPEQU\n.*--------------------------------------------------------------------*\n.*                                                                    *\n.*  Updates:                                                          *\n.*     28Nov90  EMS  misc equates for SP410                           *\n.*     31Jul90  EMS  $TKNLEN for SP313                                *\n.*     22Mar89  EMS  $MAXRJE, $MAXRCLN, $CSBPRFX for SP311            *\n.*     31Jan88  LDW  $MAXTINT added for SP220                         *\n.*                   $OPTSTD skipped for SP220                        *\n.*     21Feb87  LDW  Misc equates moved here from various Q$xxx macros*\n.*                                                                    *\n.*--------------------------------------------------------------------*\n.*\n         GBLA  &QLEVEL\n         GBLB  &$QJ2EQU\n         AIF   (&$QJ2EQU).MEND          SKIP IF ALREADY GENERATED\n&$QJ2EQU SETB  1                        REMEMBER WE'VE BEEN HERE\n.*\n$CMBDEF  EQU   0                        NEEDED FOR SP\n$CREATE  EQU   0                        for SP410\n$CSBPRFX EQU   8                        for SP311\n$DRAINED EQU   0                        NEEDED FOR SP134\n$DRTOTAL EQU   64\n$DUPVOLT EQU   0\n$JOEDEF  EQU   0\n$JQEDEF  EQU   0                        NEEDED FOR SP\n         AIF   (&QLEVEL GE 7).MAXDA1\n$MAXDA   EQU   32\n         AGO   .MAXDA2\n.MAXDA1  ANOP\n$MAXDA   EQU   253\n.MAXDA2  ANOP\n$MAXFORM EQU   8                        needed for SP410\n$MAXJBNO EQU   0\n$MAXNODE EQU   1000                     FOR SP133\n$MAXPRDV EQU   4                        FOR SP133\n$MAXRCLN EQU   10                       for SP311\n$MAXRJE  EQU   9999                     for SP311\n$MAXTINT EQU   500                      FOR SP220\n$MSGID   EQU   0\n         AIF   (&QLEVEL GE 8).OPTSTD\n$OPTSTD  EQU   0                        NEEDED FOR SP133\n.OPTSTD  ANOP\n$PRIOOPT EQU   0\n$PRTBOPT EQU   0\n$PRTRANS EQU   0\n.*PSVLENG  EQU   0                        NJE 3.0\n$QSONDA  EQU   0\n$RPS     EQU   0\n$SMFDEF  EQU   0\n$TGDEF   EQU   0\n$TKNLEN  EQU   80                       needed for SP313\n$USERSET EQU   0                        NEEDED FOR SP133\n$X97INIT EQU   0                        NEEDED FOR XJCF\nBASE1    EQU   0\nCATSTCCL EQU   0                        NEEDED FOR SP\nCATTSUCL EQU   0                        NEEDED FOR SP\nFF       EQU   255\nSCATLEN  EQU   1                        FOR SP133\n*---------------------------------------------------------------------*\n*        OUTPUT GROUP DISPOSITION COMMON EQUATES                      *\n*---------------------------------------------------------------------*\n         SPACE 1\n$ODPURGE EQU   B'00010000'              OUTDISP=PURGE\n$ODWRITE EQU   B'00001000'              OUTDISP=WRITE\n$ODHOLD  EQU   B'00000100'              OUTDISP=HOLD\n$ODKEEP  EQU   B'00000010'              OUTDISP=KEEP\n$ODLEAVE EQU   B'00000001'              OUTDISP=LEAVE\n$ODANY   EQU   $ODWRITE+$ODHOLD+$ODKEEP+$ODLEAVE\n*                                       TEST FOR OUTDISP W/O PURGE\n$ODANYWP EQU   $ODWRITE+$ODHOLD+$ODKEEP+$ODLEAVE+$ODPURGE\n*                                       TEST FOR OUTDISP WITH PURGE\n$SEGLMDF EQU   100                      DEFAULT SEGMENT LIMIT\nSDLTLEN  EQU   8                        LEN OF DIAG LEVEL TABLE ENTRY\n.*\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "QHASPEQU": {"ttr": 17929, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x00\\x00\\x00\\x00\\x90&\\x0f\\x00\\x90&\\x0f\\x142\\x00?\\x00?\\x00\\x00\\xc2\\xc1\\xe2\\xc5@@@@@@'", "ispf": {"version": "02.00", "flags": 0, "createdate": "1990-09-17T00:00:00", "modifydate": "1990-09-17T14:32:00", "lines": 63, "newlines": 63, "modlines": 0, "user": "BASE"}, "text": "         MACRO\n         QHASPEQU\n.*--------------------------------------------------------------------*\n.*                                                                    *\n.*  Updates:                                                          *\n.*     15Nov89  GLA  Correct SP3.1.1 support for earlier releases.    *\n.*     16Oct89  GLA  Support for SP3.1.1                              *\n.*     31Jan88  LDW  $MAXTINT added for SP220                         *\n.*                   $OPTSTD skipped for SP220                        *\n.*     21Feb87  LDW  Misc equates moved here from various Q$xxx macros*\n.*                                                                    *\n.*--------------------------------------------------------------------*\n.*\n         GBLA  &QLEVEL\n         GBLB  &$QJ2EQU,&QREGS\n         AIF   (&$QJ2EQU).MEND          SKIP IF ALREADY GENERATED\n&$QJ2EQU SETB  1                        REMEMBER WE'VE BEEN HERE\n         AIF   (&QLEVEL LT 9).HANDJOB\n&QREGS   SETB  1                        $HASPEQU will generate regs\n         COPY  $HASPGBL\n         $HASPEQU\n         $SCAT ,\n$X97INIT EQU   0                        NEEDED FOR XJCF\n         MEXIT\n.*\n.HANDJOB ANOP\n$CMBDEF  EQU   0                        NEEDED FOR SP\n$DRAINED EQU   0                        NEEDED FOR SP134\n$DRTOTAL EQU   64\n$DUPVOLT EQU   0\n$JOEDEF  EQU   0\n$JQEDEF  EQU   0                        NEEDED FOR SP\n         AIF   (&QLEVEL GE 7).MAXDA1\n$MAXDA   EQU   32\n         AGO   .MAXDA2\n.MAXDA1  ANOP\n$MAXDA   EQU   253\n.MAXDA2  ANOP\n$MAXJBNO EQU   0\n$MAXNODE EQU   1000                     FOR SP133\n$MAXPRDV EQU   4                        FOR SP133\n$MAXTINT EQU   500                      FOR SP220\n$MSGID   EQU   0\n         AIF   (&QLEVEL GE 8).OPTSTD\n$OPTSTD  EQU   0                        NEEDED FOR SP133\n.OPTSTD  ANOP\n$PRIOOPT EQU   0\n$PRTBOPT EQU   0\n$PRTRANS EQU   0\n.*PSVLENG  EQU   0                        NJE 3.0\n$QSONDA  EQU   0\n$RPS     EQU   0\n$SMFDEF  EQU   0\n$TGDEF   EQU   0\n$USERSET EQU   0                        NEEDED FOR SP133\n$X97INIT EQU   0                        NEEDED FOR XJCF\nBASE1    EQU   0\nCATSTCCL EQU   0                        NEEDED FOR SP\nCATTSUCL EQU   0                        NEEDED FOR SP\nFF       EQU   255\nSCATLEN  EQU   2                        FOR SP133              15NOV89\n.*\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "QITEM": {"ttr": 17931, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\r\\x00\\x00\\x00\\x82#/\\x00\\x88\\x01\\x0f\\x19H\\x00\\x9d\\x00,\\x00\\x95\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "05.13", "flags": 0, "createdate": "1982-08-20T00:00:00", "modifydate": "1988-01-10T19:48:00", "lines": 157, "newlines": 44, "modlines": 149, "user": "LDW"}, "text": "         MACRO\n&NFS     QITEM &OFF1,&DESC,&OFF2,&TYPE,&NAME,&LEN,&SKIP=,&PREFIX=\n.*--------------------------------------------------------------------*\n.*                                                                    *\n.*  QITEM - FORMAT A DATA FIELD FOR OUTPUT.  INPUT MAY BE HEX, DEC,   *\n.*          CHAR, DATE, or TIME.                                      *\n.*                                                                    *\n.*  UPDATES:                                                          *\n.*     10Jan88  LDW  Eliminate LC macro usage; eliminate CAPS=        *\n.*     22Jul87  EMS  Fix SKIP operand with non-numeric OFF2           *\n.*      8Jul87  EMS  More reorganization, and function enhancement    *\n.*                   Removed r7 requirement (set by reset operand)    *\n.*                   Removed routine name restriction.                *\n.*                   Clear r5 during RESET processing.                *\n.*     22May87  EMS  Fix name field support                           *\n.*                   Reorganized to use FMTSUBS routine, r7 must      *\n.*                      point to ??#items table                       *\n.*     29Nov86  LDW  Change to support DATEFMT subroutine             *\n.*     29AUG86  LDW  SUPPORT 'ATTR' ROUTINE                           *\n.*                   USE R5 FOR DYNAMICALLY COUNTING FIELDS           *\n.*                   ADD 'ADDLINE' FUNCTION TO SET ATTR NUM AND LINK  *\n.*                      TO QADDLINE                                   *\n.*     11/24/83 LDW  DON'T GENERATE LEADING ZERO IN NAME OF CONSTANT  *\n.*                      IF IT'S NUMBER IS > 99 (THIS WAS A BUG)       *\n.*                   INCREASE SIZE OF QITEM#T ARRAY                   *\n.*     01/17/83 LDW  CHANGE TO STORE HEADERS IN GLOBAL AREA FOR       *\n.*                      LATER EXPANSION USING \"LC\"                    *\n.*                   TRANSLATE CHARACTER FIELDS (R7 MUST -> TRTAB)    *\n.*     10/25/82 LDW  CHANGE &PREFIX.WORK TO &PREFIX.@WORK             *\n.*                                                                    *\n.*--------------------------------------------------------------------*\n.*\n.* NOTE: GENERATED CODE INTENTIONALLY SHIFTED RIGHT 1 COLUMN\n         GBLA  &QITEM#I\n         GBLC  &QITEM#P,&QITEM#T(200),&QITEMO1(200),&QITEMO2(200)\n         GBLA  &QITEM#F(200),&QITEM#L(200),&QITEM#O(200)\n         LCLA  &L,&I\n         LCLA  &FUNC,&FLAGS\n         LCLC  &O1,&O2\n         LCLC  &C\n         LCLC  &Z\n.START   AIF   ('&OFF1' EQ 'GEN').GEN\n         AIF   ('&OFF1' EQ 'ADDLINE').ADDLINE\n         AIF   ('&OFF1' NE 'RESET').GO\n         AIF   ('&PREFIX' NE '').RESET\n         MNOTE 12,'RESET option requires &&PREFIX to be specified'\n&QITEM#P SETC  '@@'                     set routine prefix name\n         MEXIT\n.RESET   ANOP  ,\n&QITEM#I SETA  0\n&QITEM#P SETC  '&PREFIX'                set routine prefix name\n         MVC   QCITEMS,=A(&QITEM#P.#ITEMS)  set table addr\n         SR    R5,R5                    clear attr byte counter\n         MEXIT\n.ADDLINE ANOP  ,\n&NFS      STC   R5,QDATRNUM+1            NUMBER OF ATTR BYTES IN LINE\n          SR    R5,R5                    CLEAR COUNTER FOR NEXT LINE\n          BAL   R14,QADDLINE             DISPLAY LINE\n         SPACE 2\n         MEXIT\n.GO      ANOP  ,\n&QITEM#I SETA  &QITEM#I+1               -> ARRAY ELEMENT\n&Z       SETC  '&QITEM#P.#&QITEM#I'     GET NAME OF SYMBOL\n         AIF   (&QITEM#I GT 99).ZOK1    &Z NULL IF 3 DIGITS\n&Z       SETC  '&QITEM#P.#0&QITEM#I'    1 LEADING ZERO IF 2 DIGITS\n         AIF   (&QITEM#I GT 9).ZOK1     1 LEADING ZERO IF 2 DIGITS\n&Z       SETC  '&QITEM#P.#00&QITEM#I'   2 LEADING ZEROES IF 2 DIGITS\n.ZOK1    ANOP\n&QITEM#T(&QITEM#I) SETC '&DESC'         set description\n         AIF   ('&DESC' EQ '').NODESC\n&C       SETC  '&OFF1'(1,1)\n         AIF   (T'&C EQ 'N').DESCN\n&O1      SETC  '&OFF1-QCOMMON'          set to offset\n         AGO   .OFF2\n.DESCN   ANOP  ,\n&O1      SETC  '&QITEM#P.@LINE+&OFF1-QCOMMON' set to offset\n         AGO   .OFF2\n.NODESC  ANOP  ,\n&O1      SETC  '0'                      if none, set to zero\n&FLAGS   SETA  128+&FLAGS               indicate no offset 1\n.OFF2    AIF   ('&OFF2' EQ '').NODATA\n&C       SETC  '&OFF2'(1,1)\n         AIF   (T'&C EQ 'N').OFF2N\n&O2      SETC  '&OFF2-QCOMMON'          set to offset\n         AGO   .SKIPT\n.OFF2N   ANOP  ,\n&O2      SETC  '&QITEM#P.@LINE+&OFF2-QCOMMON' set to offset\n         AGO   .SKIPT\n.NODATA  ANOP  ,\n&O2      SETC  '0'\n&FLAGS   SETA  64+&FLAGS                indicate no offset 2\n.SKIPT   ANOP  ,\n         AIF   (T'&SKIP EQ 'O').FUNC\n&FLAGS   SETA  32+&FLAGS                indicate skip= present\n.FUNC    ANOP  ,\n&L       SETA  &LEN\n         AIF   ('&TYPE' EQ 'CHAR').CHAR\n         AIF   ('&TYPE' EQ 'HEX' ).HEX\n         AIF   ('&TYPE' EQ 'TIME').TIME\n         AIF   ('&TYPE' EQ 'DATE').DATE\n         AIF   ('&TYPE' EQ 'DEC').DEC\n         MNOTE 8,'&TYPE IS INVALID TYPE'\n         AGO   .DONE\n.CHAR    ANOP  ,\n&FUNC    SETA  &FUNC+0                  char\n         AGO   .CONST\n.HEX     ANOP  ,\n&FUNC    SETA  &FUNC+1                  hex\n         AGO   .CONST\n.TIME    ANOP  ,\n&FUNC    SETA  &FUNC+2                  time\n         AGO   .CONST\n.DATE    ANOP  ,\n&FUNC    SETA  &FUNC+3                  date\n         AGO   .CONST\n.DEC     ANOP  ,\n&FUNC    SETA  &FUNC+4                  decimal\n         AIF   (&L EQ 1).DECL\n         AIF   (&L EQ 2).DECL\n&L       SETA  3\n.DECL    ANOP  ,\n&L       SETA  &L-1\n.CONST   ANOP  ,\n&NFS      LA   R1,&NAME                 -> source\n          BAL  R14,QITEM                invoke routine\n          DC   Y(&QITEM#I)              Table entry for literal\n&QITEM#F(&QITEM#I) SETA &FUNC\n&QITEM#O(&QITEM#I) SETA &FLAGS\n&QITEM#L(&QITEM#I) SETA &L\n&QITEMO1(&QITEM#I) SETC '&O1'\n&QITEMO2(&QITEM#I) SETC '&O2'\n.TYPE2   AIF   (T'&SKIP EQ 'O').DONE\n          B    &SKIP\n.DONE    SPACE 1\n         MEXIT\n.GEN     ANOP\n         AIF   ('&NFS' EQ '').GENHEAD\n         MNOTE 8,'Name field invalid with GEN specification'\n.GENHEAD ANOP  ,\n&QITEM#P.#ITEMS DC  0H'0'               head of table\n.GENLOOP ANOP  ,\n&I       SETA  &I+1\n&Z       SETC  ''                       NO LEADING ZEROES IF 3 DIGITS\n         AIF   (&I GT 99).ZOK2          &Z NULL IF 3 DIGITS\n&Z       SETC  '0'                      1 LEADING ZERO IF 2 DIGITS\n         AIF   (&I GT 9).ZOK2           1 LEADING ZERO IF 2 DIGITS\n&Z       SETC  '00'                     2 LEADING ZEROES IF 2 DIGITS\n.ZOK2    ANOP\n&QITEM#P.#&Z&I DC  AL1(&QITEM#P.#&Z&I.L) len of item\n         DC    AL1(&QITEM#F(&I),&QITEM#O(&I),&QITEM#L(&I))\n         DC    AL2(&QITEMO1(&I),&QITEMO2(&I))\n         AIF   (K'&QITEM#T(&I) EQ 0).GENLEN\n         DC    C&QITEM#T(&I)            def constant\n.GENLEN  ANOP  ,\n&QITEM#P.#&Z&I.L EQU *-&QITEM#P.#&Z&I\n         AIF   (&I LT &QITEM#I).GENLOOP\n         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "QITEM@": {"ttr": 17935, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\t\\x00\\x00\\x00\\x82#/\\x00\\x863O\\x04X\\x00w\\x00,\\x00^\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "05.09", "flags": 0, "createdate": "1982-08-20T00:00:00", "modifydate": "1986-11-30T04:58:00", "lines": 119, "newlines": 44, "modlines": 94, "user": "LDW"}, "text": "         MACRO\n&NFS     QITEM &OFF1,&DESC,&OFF2,&TYPE,&NAME,&LEN,&SKIP=,&CAPS=\n.*--------------------------------------------------------------------*\n.*                                                                    *\n.*  QITEM - FORMAT A DATA FIELD FOR OUTPUT.  INPUT MAY BE HEX, DEC,   *\n.*          CHAR, DATE, or TIME.                                      *\n.*                                                                    *\n.*  UPDATES:                                                          *\n.*     29Nov86  LDW  Change to support DATEFMT subroutine             *\n.*     29AUG86  LDW  SUPPORT 'ATTR' ROUTINE                           *\n.*                   USE R5 FOR DYNAMICALLY COUNTING FIELDS           *\n.*                   ADD 'ADDLINE' FUNCTION TO SET ATTR NUM AND LINK  *\n.*                      TO QADDLINE                                   *\n.*     11/24/83 LDW  DON'T GENERATE LEADING ZERO IN NAME OF CONSTANT  *\n.*                      IF IT'S NUMBER IS > 99 (THIS WAS A BUG)       *\n.*                   INCREASE SIZE OF QITEM#T ARRAY                   *\n.*     01/17/83 LDW  CHANGE TO STORE HEADERS IN GLOBAL AREA FOR       *\n.*                      LATER EXPANSION USING \"LC\"                    *\n.*                   TRANSLATE CHARACTER FIELDS (R7 MUST -> TRTAB)    *\n.*     10/25/82 LDW  CHANGE &PREFIX.WORK TO &PREFIX.@WORK             *\n.*                                                                    *\n.*--------------------------------------------------------------------*\n.*\n.* NOTE: GENERATED CODE INTENTIONALLY SHIFTED RIGHT 1 COLUMN\n         GBLA  &QITEM#I\n         GBLC  &QSECT,&QITEM#T(200)\n         LCLA  &L,&I\n         LCLC  &PREFIX,&Z\n         AIF   ('&QSECT' EQ 'JOBINFO').JOBINFO\n         AIF   ('&QSECT' EQ 'BLKLIST').BLKLIST\n         AIF   ('&QSECT' EQ 'ATTR').ATTR\n         MNOTE 12,'QITEM USED IN UNSUPPORTED CSECT - MACRO TERMINATED'\n         MEXIT\n.JOBINFO ANOP\n&PREFIX  SETC  'JI'\n         AGO   .START\n.BLKLIST ANOP\n&PREFIX  SETC  'BL'\n         AGO   .START\n.ATTR    ANOP\n&PREFIX  SETC  'AT'\n.START   AIF   ('&OFF1' EQ 'GEN').GEN\n         AIF   ('&OFF1' EQ 'ADDLINE').ADDLINE\n         AIF   ('&OFF1' NE 'RESET').GO\n&QITEM#I SETA  0\n         MEXIT\n.ADDLINE  STC   R5,QDATRNUM+1            NUMBER OF ATTR BYTES IN LINE\n          SR    R5,R5                    CLEAR COUNTER FOR NEXT LINE\n          BAL   R14,QADDLINE             DISPLAY LINE\n         SPACE 2\n         MEXIT\n.GO      AIF   ('&DESC' EQ '').NODESC\n         AIF   ('&CAPS' EQ 'YES').CAPS\n&QITEM#I SETA  &QITEM#I+1               -> ARRAY ELEMENT\n&QITEM#T(&QITEM#I) SETC '&DESC'\n&Z       SETC  '&PREFIX.#&QITEM#I'      GET NAME OF SYMBOL\n         AIF   (&QITEM#I GT 99).ZOK1    &Z NULL IF 3 DIGITS\n&Z       SETC  '&PREFIX.#0&QITEM#I'     1 LEADING ZERO IF 2 DIGITS\n         AIF   (&QITEM#I GT 9).ZOK1     1 LEADING ZERO IF 2 DIGITS\n&Z       SETC  '&PREFIX.#00&QITEM#I'    2 LEADING ZEROES IF 2 DIGITS\n.ZOK1    ANOP\n&NFS      MVC   &PREFIX.@LINE+&OFF1.(&Z.L),&Z\n         AGO   .SKIP\n.CAPS    ANOP\n&L       SETA  K'&DESC-2\n&NFS      MVC   &PREFIX.@LINE+&OFF1.(&L),=C&DESC\n.SKIP     LA    R5,2(,R5)                INCREMENT ATTR BYTE COUNT\n.NODESC  AIF   ('&TYPE' EQ 'CHAR').CHAR\n         AIF   ('&TYPE' EQ 'HEX' ).HEX\n         AIF   ('&TYPE' EQ 'TIME').TIME\n         AIF   ('&TYPE' EQ 'DATE').DATE\n         AIF   ('&TYPE' EQ 'DEC').DEC\n         MNOTE 8,'&TYPE IS INVALID TYPE'\n         AGO   .DONE\n.CHAR     OC    &NAME.(&LEN),&NAME\n          BZ    *+16\n          MVC   &PREFIX.@LINE+&OFF2.(&LEN),&NAME\n          TR    &PREFIX.@LINE+&OFF2.(&LEN),0(R7)\n         AGO   .DONE\n.HEX      UNPK  &PREFIX.@LINE+&OFF2.(2*&LEN+1),&NAME.(&LEN+1)\n          TR    &PREFIX.@LINE+&OFF2.(2*&LEN),QHEXTAB\n          MVI   &PREFIX.@LINE+&OFF2+2*&LEN,C' '\n         AGO   .DONE\n.TIME     L     R1,&NAME\n          BAL   R2,&PREFIX.$TIME\n          MVC   &PREFIX.@LINE+&OFF2.(8),&PREFIX.@WORK\n         AGO   .DONE\n.DATE     L     R0,&NAME\n          BAL   R2,&PREFIX.$DATE\n          B     &SKIP                   FIELD IS ALL ZERO\n          MVC   &PREFIX.@LINE+&OFF2.(7),&PREFIX.@WORK\n         AGO   .DONE\n.DEC     AIF   ('&LEN' EQ '').DEC$4\n         AIF   (&LEN EQ 2).DEC$2\n         AIF   (&LEN NE 1).DEC$4\n          SR    R0,R0\n          IC    R0,&NAME\n         AGO   .DEC$BAL\n.DEC$2    LH    R0,&NAME\n         AGO   .DEC$BAL\n.DEC$4    L     R0,&NAME\n.DEC$BAL  BAL   R2,&PREFIX.$DEC\n          MVC   &PREFIX.@LINE+&OFF2.(13),0(R1)\n.DONE    SPACE 2\n         MEXIT\n.GEN     ANOP\n&I       SETA  &I+1\n&Z       SETC  ''                       NO LEADING ZEROES IF 3 DIGITS\n         AIF   (&I GT 99).ZOK2          &Z NULL IF 3 DIGITS\n&Z       SETC  '0'                      1 LEADING ZERO IF 2 DIGITS\n         AIF   (&I GT 9).ZOK2           1 LEADING ZERO IF 2 DIGITS\n&Z       SETC  '00'                     2 LEADING ZEROES IF 2 DIGITS\n.ZOK2    ANOP\n&PREFIX.#&Z&I  DC  X'1DE8'\n         LC    &QITEM#T(&I)\n         DC    X'1D60'\n&PREFIX.#&Z&I.L EQU *-&PREFIX.#&Z&I\n         AIF   (&I LT &QITEM#I).GEN\n         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "QLCB": {"ttr": 17938, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x90\\x17\\x1f\\x00\\x90\\x17\\x1f\\x17\\x07\\x00\\x17\\x00\\x14\\x00\\x00\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-06-20T00:00:00", "modifydate": "1990-06-20T17:07:00", "lines": 23, "newlines": 20, "modlines": 0, "user": "LDW"}, "text": "         MACRO\n         QLCB  &PREFIX=LCB\n.*--------------------------------------------------------------------*\n.*                                                                    *\n.*  QLCB - Map a Line Command Buffer array element                    *\n.*                                                                    *\n.*  Updates:                                                          *\n.*    20Jun90 LDW - Created                                           *\n.*                - LCBID changed from CL5 to CL6 & patch space moved *\n.*                                                                    *\n.*--------------------------------------------------------------------*\n         LCLC  &P\n&P       SETC  '&PREFIX'\n.*\n&P.TPTR  DS    A                        -> LINE CMD TABLE ENTRY\n&P.ADDR1 DS    A                        -> FIRST INPUT FIELD\n&P.ADDR2 DS    A                        -> SECOND INPUT FIELD\n&P.ID    DS    CL6                      JOBID OR DSID\n&P.FLD1  DS    CL2                      INPUT FROM FIRST FIELD\n&P.FLD2  DS    CL8                      INPUT FROM SECOND FIELD\n         DC    XL4'00'                  PATCH SPACE\n         SPACE 2\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "QNEWCMD": {"ttr": 18178, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x91\\x03\\x1f\\x00\\x91\\x19\\x7f\\x14\\x10\\x003\\x00-\\x00\\x07\\xe2\\xc1\\xd3\\xc2\\xc5\\xd9\\xe3@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1991-01-31T00:00:00", "modifydate": "1991-07-16T14:10:00", "lines": 51, "newlines": 45, "modlines": 7, "user": "SALBERT"}, "text": "         MACRO\n&NAME    QNEWCMD  &P,&MSG=\n.*\n.*  Updates:\n.*    16Jul91  GLA  Add message support for command reissue.  B-16JUL91\n.*    31Jan91  LDW  Copy from GLA version, rename from QPRIMCMD to\n.*                     QNEWCMD because LINE commands are also handled,\n.*                     remove update flags as this is now part of\n.*                     the base\n.*                  Improve MNOTE text\n.*\n.*\n.*   This macro effects an interrupt to the normal processing\n.*   of the 'QUEUE' command by branching to the QQINTER routine\n.*   in the main QUEUE module.  This is done to request that\n.*   certain types of commands be handled.\n.*\n.*   Current operand values are:\n.*        PRIMARY    indicates to process new primary command\n.*        LINE       indicates to process new line command\n.*        STACK      indicates to reissue the cmd on the stack\n.*        ????       is address of command to run (unused)\n.*\n.*\n         AIF   ('&MSG' EQ '').CLR0                            B-16JUL91\n         LA    R0,&MSG                  point at message      B-16JUL91\n         AGO   .GR0                                           B-16JUL91\n.CLR0    SR    R0,R0                    indicate no msg       B-16JUL91\n.GR0     ANOP                                                 B-16JUL91\n         AIF   ('&P' EQ '').QPER1\n         AIF   ('&P' NE 'PRIMARY').NOTP\n&NAME    SR    R15,R15                  show entry from display\n         AGO   .DONE\n.NOTP    AIF   ('&P' NE 'LINE').SOME\n&NAME    LA    R15,4                    go run line command\n         AGO   .DONE\n.SOME    AIF   ('&P' NE 'STACK').OTHER\n&NAME    LA    R15,8                    go rerun stack command\n         AGO   .DONE\n.OTHER   ANOP                           HANDLE command\n         LA    R1,&P                    point to command\n         LA    R15,12                   show forced command\n.DONE    L     R13,QFRSTSA              get orig save area\n         L     R14,12(,R13)             restore registers\n         LM    R2,R12,12+16(R13)        reload rest\n         BR    R10                      -> interrupt handler in\n*                                          QUEUE MAINLINE\n         MEXIT\n.QPER1   MNOTE 8,'QNEWCMD requires an operand'\n&NAME    DS    0H                       define label\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "QNEXT": {"ttr": 18180, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x83\\x00?\\x00\\x83\\x00O\\x17X\\x00 \\x00 \\x00\\x02\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1983-01-03T00:00:00", "modifydate": "1983-01-04T17:58:00", "lines": 32, "newlines": 32, "modlines": 2, "user": "LDW"}, "text": "         MACRO\n&NFS     QNEXT &REG,&LOC,&NONE=\n.*--------------------------------------------------------------------*\n.*                                                                    *\n.*  QNEXT - PICK UP JQE OR JOE OFFSET.  THIS MACRO WAS CREATED TO     *\n.*          MINIMIZE THE AMOUNT OF CONDITIONAL ASSEMBLY IN OPEN CODE  *\n.*          REQUIRED TO IMPLEMENT SP/JES2 SUPPORT.                    *\n.*                                                                    *\n.*  NOTE - GENERATED CODE INTENTIONALLY SHIFTED RIGHT 1 COLUMN        *\n.*                                                                    *\n.*  UPDATES:                                                          *\n.*     01/04/83 LDW  MACRO CREATED                                    *\n.*                                                                    *\n.*--------------------------------------------------------------------*\n.*\n         GBLA  &QLEVEL                  LEVEL OF CHECKPOINT SUPPORTED\n         LCLC  &H,&MASK\n&MASK    SETC  '00FFFFFF'               ASSUME SP\n         AIF   (&QLEVEL GE 4).SP        SKIP IF SP (&H WILL BE NULL)\n&MASK    SETC  '0000FFFF'               \"AND\" MASK FOR NON-SP\n&H       SETC  'H'                      AND USE \"LH\" INSTEAD OF \"L\"\n.SP      AIF   ('&LOC' EQ '').NOLOC     SKIP IF ALREADY IN REGISTER\n&NFS      L&H   &REG,&LOC\n          N     &REG,=X'&MASK'\n         AGO   .CHKSLA\n.NOLOC   ANOP\n&NFS      N     &REG,=X'&MASK'\n.CHKSLA  AIF   (&QLEVEL GE 4).CHKNONE\n          SLA   &REG,2                   CONVERT OFFSET/4 INTO OFFSET\n.CHKNONE AIF   ('&NONE' EQ '').EXIT\n          BZ    &NONE\n.EXIT    MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "QPBRO": {"ttr": 18182, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x91\\x04/\\x00\\x91\\x14o!\\x13\\x004\\x00/\\x00\\x00\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1991-02-11T00:00:00", "modifydate": "1991-05-26T21:13:00", "lines": 52, "newlines": 47, "modlines": 0, "user": "LDW"}, "text": ")ATTR\n  _ TYPE(INPUT) CAPS(OFF) INTENS(HIGH) FORMAT(&MIXED)\n  | AREA(DYNAMIC) EXTEND(ON) SCROLL(ON)\n  + TYPE(TEXT) INTENS(LOW)\n  @ TYPE(OUTPUT) INTENS(LOW)  JUST(ASIS) CAPS(OFF)\n  $ TYPE(OUTPUT) INTENS(HIGH) JUST(ASIS) CAPS(OFF)\n  ! TYPE(OUTPUT) INTENS(HIGH) PAD(-)\n 01 TYPE(DATAOUT) INTENS(LOW)\n 02 TYPE(DATAOUT) INTENS(HIGH)\n 0B TYPE(DATAOUT) INTENS(HIGH) FORMAT(DBCS)\n 0C TYPE(DATAOUT) INTENS(HIGH) FORMAT(EBCDIC)\n 0D TYPE(DATAOUT) INTENS(HIGH) FORMAT(&MIXED)\n 10 TYPE(DATAOUT) INTENS(LOW)  FORMAT(DBCS)\n 11 TYPE(DATAOUT) INTENS(LOW)  FORMAT(EBCDIC)\n 12 TYPE(DATAOUT) INTENS(LOW)  FORMAT(&MIXED)\n)BODY WIDTH(&ZWIDTH) EXPAND(//)\n%QUEUE - &ZTITLE ------------------------------/-/---%Line!ZLINES  %Col!ZCOLUMS+\n%Command ===>_ZCMD                             / /            %Scroll ===>_Z   +\n$QDHLINE                                                     +CPU=@QC +DPR=@QD +\n|ZDATA ---------------------------------/ /------------------------------------|\n|                                       / /                                    |\n| --------------------------------------/-/------------------------------------|\n)INIT\n  .HELP = ISR10000         /* DEFAULT TUTORIAL NAME     */\n  .ZVARS = 'ZSCBR'         /* SCROLL AMT VARIABLE NAME  */\n  IF (&ZMEMB \u00ac= ' ')\n    &ZTITLE = '&ZDSNT(&ZMEMB)&ZLEVEL '       /* OZ91708 */\n  IF (&ZMEMB = ' ')\n    &ZTITLE = '&ZDSN&ZLEVEL '\n  &MIXED = MIX\n  IF (&ZPDMIX = N)         /* EBCDIC MODE REQUESTED     */\n    &MIXED = EBCDIC\n\n)REINIT\n  REFRESH(ZCMD,ZSCBR,ZDATA,ZLINES,ZCOLUMS,QDHLINE)\n  .ATTRCHAR(+) = 'INTENS(&ZINTEN)'\n\n)PROC\n  &ZCURSOR = .CURSOR\n  &ZCSROFF = .CSRPOS\n  &ZLVLINE = LVLINE(ZDATA)\n/*&QDHLINE = '<<REBUILD>>' */\n  &QDHLINE = ' '\n  &QBRIFHDR = 'R'\n  /* The following \"QQ\" junk is only required for ISPF < V3R2 */\n  &QCMD = TRANS(TRUNC(&ZCMD,' ') qq,QQ qQ,QQ Qq,QQ QQ,QQ *,'?')\n  IF (&QCMD = QQ)\n     &ZPARM = .TRAIL\n     VPUT (QCMD,ZPARM) SHARED\n     .RESP = END\n\n)END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "QPENTRY": {"ttr": 18184, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x91\\x03\\x0f\\x00\\x91\\x08\\x7f#R\\x00\\x11\\x00\\x11\\x00\\x00\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1991-01-30T00:00:00", "modifydate": "1991-03-28T23:52:00", "lines": 17, "newlines": 17, "modlines": 0, "user": "LDW"}, "text": "%-------------------  Queue Invocation Parameters  -----------------------------\n%OPTION  ===>_ZCMD                                                             +\n%\n+  Initial Queue Command ===>_QICMD                                   +\n+\n+  Name of production queue module ===>_QCMDNM  +\n+  JES2 Dataset Prefix             ===>_QPRFX        +\n+  JES2 Checkpoint Volume Serial   ===>_QVLSR +\n+  JES2 Subsystem Name             ===>_QSBS+\n+\n)INIT\n  .HELP = BFGTG000\n  .CURSOR = QICMD\n  &QCMDNM = 'Q$'\n)PROC\n  VPUT (QCMDNM,QPRFX,QVLSR,QSBS,QICMD) SHARED\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "QPTBL": {"ttr": 18186, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x91\\x03/\\x00\\x915O!G\\x00\\x1c\\x00\\x1a\\x00\\x00\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1991-02-01T00:00:00", "modifydate": "1991-12-20T21:47:00", "lines": 28, "newlines": 26, "modlines": 0, "user": "LDW"}, "text": ")ATTR DEFAULT(%+_)\n      /*  % TYPE(TEXT) INTENS(HIGH)      defaults displayed for      */\n      /*  + TYPE(TEXT) INTENS(LOW)       information only            */\n  _ TYPE(INPUT) INTENS(HIGH) CAPS(ON) JUST(LEFT)  PADC('''')\n  \u00ac TYPE(INPUT) INTENS(HIGH) CAPS(OFF) JUST(LEFT)\n  @ TYPE(OUTPUT) INTENS(LOW)  JUST(ASIS) CAPS(OFF)\n  # TYPE(OUTPUT) INTENS(HIGH) JUST(ASIS) CAPS(OFF)\n)BODY\n%QUEUE ---&QTITLE---------------------------------------------------------------\n%Command ===>\u00acZCMD                                            %Scroll%===>\u00acQAMT+\n#QERROR                                                      +CPU=@QC +DPR=@QD %\n&QDHLINE\n)MODEL\n&QMDL\n)INIT\n/*.HELP = BFTQU000 */               /* insert name of tutorial panel */\n  .ZVARS = &QZVARS\n  VGET (QSCRAMT) PROFILE\n  &QAMT = &QSCRAMT\n  IF (&QAMT = &Z) &QAMT = CSR\n  IF (&QRPMT \u00ac= ' ') &ZCMD = &QRPMT\n  &QRPMT = ' '\n)PROC\n  &QSCRAMT = &QAMT\n  VPUT (QSCRAMT) PROFILE\n)END\n******************************** Updates *******************************\n20Dec91 LDW - Add CAPS(OFF) to '#'\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "QREGS": {"ttr": 18188, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x01\\x00\\x00\\x00\\x82#/\\x00\\x824\\x7f\\x15\\x00\\x00(\\x00\\x1f\\x00\\x0b\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "05.01", "flags": 0, "createdate": "1982-08-20T00:00:00", "modifydate": "1982-12-13T15:00:00", "lines": 40, "newlines": 31, "modlines": 11, "user": "LDW"}, "text": "         MACRO\n         QREGS\n.*--------------------------------------------------------------------*\n.*                                                                    *\n.*  QREGS - GENERATE REGISTER EQUATES IF NOT PREVIOUSLY GENERATED     *\n.*          FOR THIS ASSEMBLY                                         *\n.*                                                                    *\n.*  UPDATES:                                                          *\n.*     00/00/00 LDW  (NONE)                                           *\n.*                                                                    *\n.*--------------------------------------------------------------------*\n.*\n         GBLB  &QREGS                   QSTART REGS FLAG\n.*\n         AIF   (&QREGS).MEND            SKIP IF ALREADY DONE\n&QREGS   SETB  1                        THEY WILL NOW BE DONE\n.*\n***********************************************************************\n*                                                                     *\n*   REGISTER USAGE TABLE                                              *\n*                                                                     *\n***********************************************************************\nR0       EQU   0                        TEMP WORK\nR1       EQU   1                        TEMP WORK\nR2       EQU   2                        WORK REG\nR3       EQU   3                        WORK REG\nR4       EQU   4                        WORK REG\nR5       EQU   5                        WORK REG\nR6       EQU   6                        WORK REG\nR7       EQU   7                        WORK REG\nR8       EQU   8                        WORK REG\nR9       EQU   9                        WORK REG\nR10      EQU   10                       WORK REG\nR11      EQU   11                       ADDRESS OF COMMON VECTOR TABLE\nR12      EQU   12                       BASE REGISTER\nR13      EQU   13                       SAVE AREA AND TEMP WORK AREA\nR14      EQU   14                       TEMP WORK\nR15      EQU   15                       TEMP WORK\n.*\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "QSORT": {"ttr": 18190, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x87\\x12\\x8f\\x00\\x894O#\\x05\\x009\\x00 \\x00$\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1987-05-08T00:00:00", "modifydate": "1989-12-10T23:05:00", "lines": 57, "newlines": 32, "modlines": 36, "user": "LDW"}, "text": "         MACRO\n&NAME    QSORT   &ADDR=,&NUM=,&LEN=,&COMP=,&OFFSET=,&WORK=,&PREFIX=\n.*--------------------------------------------------------------------*\n.*                                                                    *\n.*  QSORT  - Invoke QSORT routine                                     *\n.*                                                                    *\n.*  Updates:                                                          *\n.*     10Dec89 LDW  Bypass if &@@OACFS = ''                           *\n.*                  Don't use relative value to branch around QTILT   *\n.*      3Jun87 EMS  Update to invoke OACFSORT directly                *\n.*                                                                    *\n.*--------------------------------------------------------------------*\n.*\n         GBLC  &@@OACFS\n         LCLC  &IHBNX\n&IHBNX   SETC  'IHB'.'&SYSNDX'\n         AIF   ('&@@OACFS' NE '').OKSORT\n         MNOTE 0,'You really need OACFSORT for QUEUE to function correc$\n               tly.'\n&NAME    DC    0H'0'                    define name\n         MEXIT\n.*\n.OKSORT  ANOP\n&NAME    XC    &PREFIX.@PARM(&PREFIX.@L),&PREFIX.@PARM  clear entry\n         MVC   &PREFIX.@RECPT,&ADDR     Address of table start\n         MVC   &PREFIX.@RECLN,&LEN      Len of entry\n         MVC   &PREFIX.@CMPEP,&COMP     Compare routine addr\n         AIF   (T'&WORK EQ 'O').WORK13\n         MVC   &PREFIX.@CMPPM,&WORK     Set workarea addr\n         AGO   .ENTNUM\n.WORK13  ANOP  ,\n         ST    R13,&PREFIX.@CMPPM       Default to r13\n.ENTNUM  ANOP  ,\n         AIF   (T'&NUM EQ 'O').ENTCOMP\n         MVC   &PREFIX.@RECNM,&NUM      Set number of entries to sort\n         AGO   .SORT\n.ENTCOMP ANOP  ,\n         LR    R15,&OFFSET              Copy offset addr\n         S     R15,&PREFIX.@RECPT       Compute offset\n         XR    R14,R14                  clear\n         D     R14,&PREFIX.@RECLN       get number of entries\n         LA    R15,1(,R15)              add in last entry\n         ST    R15,&PREFIX.@RECNM       Save for sort\n.SORT    ANOP  ,\n         LA    R1,&PREFIX.@SWRK         -> sort workarea\n         ST    R1,&PREFIX.@WRKPT        save in parm list\n         MVC   &PREFIX.@WRKLN,=A(L'&PREFIX.@SWRK)  len of workarea\n         LA    R1,&PREFIX.@PARM         -> parm list\n         L     R15,QVSORT               -> sort routine\n         BALR  R14,R15                  invoke it\n         LTR   R15,R15                  ok?\n.*       BZ    *+4+6+4                  yes, continue\n         BZ    &IHBNX.A                 yes, continue\n*        QTILT '*** Sort failure ***'\n         QTILT '*** Sort failure ***'\n&IHBNX.A DC    0H'0'\n         MEND  ,\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "QSTACK": {"ttr": 18192, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x84\\x02?\\x00\\x84$?\"7\\x009\\x009\\x00\\x02\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1984-01-23T00:00:00", "modifydate": "1984-08-30T22:37:00", "lines": 57, "newlines": 57, "modlines": 2, "user": "LDW"}, "text": "         MACRO\n&NFS     QSTACK  &LVL,&CMD,&TYPE=\n.*--------------------------------------------------------------------*\n.*                                                                    *\n.*  QSTACK - ADD CURRENT COMMAND TO CORRECT POSITION IN STACK.        *\n.*                                                                    *\n.*  UPDATES:                                                          *\n.*     08/30/84 LDW  FIX BUG IN XREF DISPLAY                          *\n.*                                                                    *\n.*--------------------------------------------------------------------*\n.*\n         GBLC  &QSTACKC(50),&QSTACKL(50),&QSTACKN(50)\n         GBLA  &QSTACK#\n         LCLC  &C,&N,&L\n         LCLA  &I\n         AIF   ('&TYPE' EQ 'XREF').XREF\n&QSTACK# SETA  &QSTACK#+1\n         AIF   ('&CMD '(1,1) EQ '''').CQ\n&QSTACKC(&QSTACK#)  SETC  '&CMD'\n         AGO   .COK\n.CQ      ANOP\n&QSTACKC(&QSTACK#)  SETC  '''&CMD'''\n.COK     ANOP\n         AIF   ('&LVL'(1,2) NE 'X''' OR K'&LVL NE 5).LNOTHEX\n&L       SETC  '&LVL'(3,2)              EXTRACT 2 HEX CHARACTERS\n&QSTACKL(&QSTACK#)  SETC  'X''''&L'''''\n&L       SETC  'X''&L'''\n         AGO   .LOK\n.LNOTHEX ANOP\n&L       SETC  '&LVL'                   ASSUME LEVEL NOT HEX\n&QSTACKL(&QSTACK#)  SETC  '&LVL'\n.LOK     ANOP\n&QSTACKN(&QSTACK#)  SETC  '&NFS'\n         AIF   ('&NFS' NE '').NFSOK\n&QSTACKN(&QSTACK#)  SETC  '&SYSECT'\n.NFSOK   ANOP\n&NFS      LA    R0,&L\n         AIF   ('&CMD' EQ '').NOCMD\n          LA    R1,=CL66&CMD\n         AGO   .BAL\n.NOCMD    LA    R1,QDREPLY\n.BAL      BAL   R14,QSTACK\n         SPACE 1\n         MEXIT\n.XREF    SPACE 2\n         MNOTE '  LABEL     LEVEL  COMMAND'\n         MNOTE '  -----     -----  -------'\n&I       SETA  1\n.XRLOOP  ANOP\n&C       SETC  '&QSTACKC(&I)       '\n&L       SETC  '&QSTACKL(&I)    '(1,8)\n&N       SETC  '&QSTACKN(&I)       '(1,8)\n         MNOTE '  &N  &L  &C'\n&I       SETA  &I+1\n         AIF   (&I LE &QSTACK#).XRLOOP\n         SPACE 2\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "QSTART": {"ttr": 18194, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x1d\\x00\\x00\\x00\\x82#/\\x00\\x91\\x18_#R\\x00\\xf5\\x00>\\x00\\xde\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "05.29", "flags": 0, "createdate": "1982-08-20T00:00:00", "modifydate": "1991-07-04T23:52:00", "lines": 245, "newlines": 62, "modlines": 222, "user": "LDW"}, "text": "         MACRO\n&NAME    QSTART  &QNUM,&TYPE=,&WORKLEN=,&STACK=\n.*--------------------------------------------------------------------*\n.*                                                                    *\n.*  QSTART - Do O/S housekeeping at start of a routine                *\n.*                                                                    *\n.*  Note:  &QNUM is not used -- it is for historical purposes only    *\n.*                                                                    *\n.*  Updates:                                                          *\n.*     04Jul91  LDW  Update for variables moved to @GLOBALS/@GLOBALC  *\n.*                   Comment out SPLEVEL SET=1                        *\n.*     30Jun91  LDW  Generate entry name in id format for tracing     *\n.*     08Jun91  LDW  Move QHASPEQU so it's inside PRINT NOGEN for     *\n.*                      QCOMMON                                       *\n.*     31Jan91  LDW  Pick up GLA's updates to support new QHASPEQU    *\n.*     23Mar89  LDW  Move .ALL1 to ANOP to keep ASMF happy            *\n.*     21Feb87  LDW  Invoke new QHASPEQU macro to generate misc       *\n.*                      equates needed for JES2 macros                *\n.*     01Jan86  LDW  SPLEVEL SET=1 (If you don't have SPLEVEL, you'll *\n.*                      to create a dummy macro that does nothing)    *\n.*     30Nov86  LDW  Ok, Jack, I broke down and changed the _ to -    *\n.*                      in the id field                               *\n.*     22JUN86  LDW  Use &@@ACF2 instead of &QACF2                    *\n.*              LDW  Support PRINT=ALL for debugging                  *\n.*     03/30/86 LDW  Fix bug in 'ENTRY' creaded by previous update    *\n.*     02/23/86 LDW  Don't clobber R0 (sometimes used as a parm reg)  *\n.*     01/21/85 LDW  Correct asm errors for 'NOACF2' option           *\n.*     12/05/84 LDW  Set local workarea size via LA/ST instead of     *\n.*                      MVC, so don't get addressibility errors in    *\n.*                      large routines                                *\n.*     08/07/84 LDW  Drop all registers at start (needed because      *\n.*                      some stupid JES2/SP134 macros do USINGs)      *\n.*                   Add SYSPARM support for ALTCCH                   *\n.*     08/02/84 LDW  Add support for SYSPARM and TYPE=COMMON          *\n.*     01/17/84 LDW  Add support for command stacking                 *\n.*     03/04/83 LDW  Change USING/DROP to USNGX/DROPX, add INUSE      *\n.*     01/27/83 LDW  ACF2 SP support                                  *\n.*     01/19/83 LDW  Fix bug:  need WORKLEN= for TYPE=ENTRY also      *\n.*     01/04/83 LDW  Add support for WORKLEN=                         *\n.*     12/14/82 LDW  Skip blurb if &DOC=NOGEN                         *\n.*                                                                    *\n.*--------------------------------------------------------------------*\n.*\n.*  Suppress comments around QGLOBALS\n         AIF   ('&SYSPARM'(1,9) EQ 'PRINT=ALL').ALL1\n         PRINT OFF                                                    1\n.ALL1    ANOP\n         COPY  QGLOBALS\n         COPY  $HASPGBL                 for &VERSION\n&QJ2VERS SETC  '&VERSION'\n         AIF   ('&VERSION' NE '').VERSOK\n&QJ2VERS SETC  'SP1.3.6'                turkeys\n.VERSOK  ANOP\n.***     SPLEVEL  SET=1\n         PRINT ON,&@@QPRNT                                            2\n         GBLC  &ACF2JCT                 field name of offset of ACF2\n*                                       JCT extension (set by #ACFJES2)\n         GBLB  &QBLURB                  Blurb given for this assembly\n.*  set &QLEVEL based on $HASPGBL &VERSION\n&QLEVEL  SETA  12\n         AIF   ('&VERSION' EQ 'SP 4.2.0').GOTLVL  HJE4420\n&QLEVEL  SETA  11\n         AIF   ('&VERSION' EQ 'SP 4.1.0').GOTLVL  HJE4410\n&QLEVEL  SETA  10\n         AIF   ('&VERSION' EQ 'SP 3.1.3').GOTLVL  HJE3313\n&QLEVEL  SETA  9\n         AIF   ('&VERSION' EQ 'SP 3.1.1').GOTLVL  HJE3311\n&QLEVEL  SETA  8\n         AIF   ('&VERSION' EQ 'SP 2.2.0').GOTLVL  HJE2211\n&QLEVEL  SETA  7                        this version of JES2 is broken\n         AIF   ('&VERSION' EQ ''        ).GOTLVL  2.1.5 / 1.3.6\n         AIF   ('&VERSION' EQ 'SP 2.1.5').GOTLVL  HJE2215\n         AIF   ('&VERSION' EQ 'SP 1.3.6').GOTLVL  HJE1367\n         MNOTE 0,'*** QUEUE support for this level of JES2 may be.'\n         MNOTE 0,'*** discontinued.  Read Note1 in $$$INST.'\n&QLEVEL  SETA  6\n         AIF   ('&VERSION' EQ 'SP 1.3.4').GOTLVL  HJE2330 (also 2.1.2)\n&QLEVEL  SETA  5\n         AIF   ('&VERSION' EQ 'SP 1.3.3').GOTLVL  HJE2329 (also 2.1.1)\n&QLEVEL  SETA  4\n         AIF   ('&VERSION' EQ 'SP 1.3.0').GOTLVL  HJE2226 (also 2.1.0)\n&QLEVEL  SETA  3\n.*                                      EJE1102 = JES2 4.1 with AZ27300\n.*                                      EJE1103 = ... + AZ27300 + 3800E\n.*                                      JJE1112 = JES2 NJE 3.0\n.*                                      HJE1104 = JES2 NJE 3.0 + 3800E\n.GOTLVL  ANOP\n         AIF   (&QLEVEL LT 10).OWNOK    skip if < 3.1.3\n&@@QJOWN SETC  'JQEUSRID'               NAME OF JOB OWNER FIELD IN JQE\n.OWNOK   ANOP\n         GBLC  &QSECT                   Name of current routine\n         GBLC  &QSWRKLN                 Name of WORKLEN constant\n         LCLA  &IDL,&PARMLEN,&PARMPOS,&PARMPTR\n         LCLC  &ID,&IHBNX,&PARMKEY,&PARMVAL,&XPARM,&C1,&C2,&C3,&C4\n&IHBNX   SETC  'IHB&SYSNDX'\n         AIF   ('&TYPE' EQ 'ENTRY').ENTRY  Don't scan SYSPARM for ENTRY\n&QSWRKLN SETC  '&IHBNX.W'               Set name of WORKLEN constant\n         AIF   (K'&SYSPARM EQ 0).SPNONE    No SYSPARM\n         AIF   ('&SYSPARM' EQ '*').SPNONE  No SYSPARM\n         AIF   ('&SYSPARM' EQ ' ').SPNONE  No SYSPARM\n         MNOTE *,'SYSPARM IS ''&SYSPARM'' '\n&PARMLEN SETA  K'&SYSPARM\n&XPARM   SETC  '&SYSPARM'.','           Add trailing comma\n&PARMPTR SETA  1                        Starting pos of this key\n.PARMLP1 ANOP\n&PARMPOS SETA  &PARMPOS+1\n         AIF   ('&XPARM'(&PARMPOS,1) EQ ',').COMMA\n         AIF   ('&XPARM'(&PARMPOS,1) NE '=').PARMLP1\n&PARMKEY SETC  '&XPARM'(&PARMPTR,&PARMPOS-&PARMPTR+1)  Include the '='\n&PARMPTR SETA  &PARMPOS+1               Starting pos of this value\n.PARMLP2 ANOP\n&PARMPOS SETA  &PARMPOS+1\n         AIF   ('&XPARM'(&PARMPOS,1) NE ',').PARMLP2\n&PARMVAL SETC  '&XPARM'(&PARMPTR,&PARMPOS-&PARMPTR)\n         AGO   .PARMCHK\n.COMMA   ANOP\n&PARMKEY SETC  '&XPARM'(&PARMPTR,&PARMPOS-&PARMPTR)\n&PARMVAL SETC  '***NONE***'\n.PARMCHK ANOP\n&PARMPTR SETA  &PARMPOS+1               Starting pos of next key\n         AIF   ('&PARMKEY' EQ 'DOC='    ).SPDOC\n         AIF   ('&PARMKEY' EQ 'PRINT='  ).SPPRINT\n         AIF   ('&PARMKEY' EQ 'ACF2='   ).SPACF2\n         AIF   ('&PARMKEY' EQ 'ALTCCH=' ).SPALTCC\n         AIF   ('&PARMKEY' EQ 'QLEVEL=' ).SPQLVL\n         AIF   ('&PARMKEY' EQ 'JQEOWN=' ).SPJQE\n         AIF   ('&PARMKEY' EQ 'TMPMAC'  ).SPTMP\n         AIF   ('&PARMKEY' EQ 'NOTMPMAC').SPTMPNO\n         MNOTE 8,'Unsupported SYSPARM key -- &PARMKEY -- ignored'\n.PARMNXT AIF   (&PARMPTR LT &PARMLEN).PARMLP1\n         AGO   .SPEND\n.SPDOC   ANOP\n&@@QDOC  SETC  '&PARMVAL'\n         MNOTE *,'SYSPARM override -- &&@@QDOC=&@@QDOC'\n         AGO   .PARMNXT\n.SPPRINT ANOP\n&@@QPRNT SETC  '&PARMVAL'\n         MNOTE *,'SYSPARM override -- &&@@QPRNT=&@@QPRNT'\n         AIF   ('&@@QPRNT' NE 'ALL').PARMNXT\n&@@QPRNT SETC  'GEN'\n         AGO   .PARMNXT\n.SPACF2  ANOP\n&@@ACF2  SETA  &PARMVAL\n         MNOTE *,'SYSPARM override -- &&@@ACF2=&@@ACF2'\n         AGO   .PARMNXT\n.SPALTCC ANOP\n&@@QALTC SETC  '&PARMVAL'\n         MNOTE *,'SYSPARM override -- &&@@QALTC=&@@QALTC'\n         AGO   .PARMNXT\n.SPQLVL  ANOP\n&QLEVEL  SETA  &PARMVAL\n         MNOTE *,'SYSPARM override -- &&QLEVEL=&QLEVEL'\n         AGO   .PARMNXT\n.SPJQE   ANOP\n&@@QJOWN SETC  '&PARMVAL'\n         MNOTE *,'SYSPARM override -- &&@@QJOWN=&@@QJOWN'\n         AGO   .PARMNXT\n.SPTMP   ANOP\n&@@TMPSV SETB  1\n         MNOTE *,'SYSPARM override -- &&@@TMPSV=&@@TMPSV'\n         AGO   .PARMNXT\n.SPTMPNO ANOP\n&@@TMPSV SETB  0\n         MNOTE *,'SYSPARM override -- &&@@TMPSV=&@@TMPSV'\n         AGO   .PARMNXT\n.SPNONE  MNOTE *,'No overriding SYSPARM'\n.SPEND   AIF   (&QLEVEL LT 4 OR &@@ACF2 EQ 0).NACF2J2\n         AIF   ('&SYSPARM'(1,9) EQ 'PRINT=ALL').ALL2\n         PRINT OFF                                                    3\n.ALL2    #ACFJES2  ,                    Set &ACF2JCT\n         PRINT ON,&@@QPRNT                                            4\n.NACF2J2 AIF   ('&TYPE' EQ 'COMMON').COMMON1\n         AGO   .CSECT\n.ENTRY   ENTRY &NAME\n&NAME    B     4+1+8+1(R12)             skip around id\n         DC    AL1(8),CL8'&NAME',AL1(0) id\n         LA    R15,&NAME-&QSECT         Compute difference in bases\n         SR    R12,R15                  Adjust my base to that of CSECT\n         MVC   2(2,R13),&QSWRKLN        Set size of local workarea\n         AIF   ('&WORKLEN' EQ '').STACK Continue\n         MNOTE 0,'WORKLEN=&WORKLEN ignored for TYPE=ENTRY'\n         AGO   .STACK                   Continue\n.CSECT   AIF   ('&@@QPRNT' EQ 'GEN').CSECTX Skip double 'GEN'\n         PRINT GEN                      Show CSECT start addr         5\n.CSECTX  ANOP\n&NAME    CSECT\n&QSECT   SETC  '&NAME'                  Remember name of current rtn\n         AIF   ('&@@QDOC' EQ 'GEN').NOGEN2  Avoid 2 GEN's in a row\n         AIF   ('&SYSPARM'(1,9) EQ 'PRINT=ALL').NOGEN2\n         PRINT NOGEN                                                  6\n.NOGEN2  ANOP\n.COMMON1 QHASPEQU\n         DROPX ,                        DROP all previous base regs\n         DROP  ,                        Just to be sure        SP134\n         QREGS\n.*\n.*   reestablish real section\n.*\n&QSECT   CSECT\n         AIF   ('&@@QDOC' EQ 'NOGEN').OKBLURB  Skip blurb if &DOC=NOGEN\n         AIF   (&QBLURB).OKBLURB        Skip if already done\n&QBLURB  SETB  1                        Don't do it again\n         COPY  $UPDATES\n         SPACE 2\n.OKBLURB AIF   ('&@@QPRNT' EQ 'NOGEN').NOGEN3 Avoid 2 NOGEN's in a row\n         PRINT GEN                                                    7\n.NOGEN3  AIF   ('&TYPE' EQ 'COMMON').COMMON2\n&ID      SETC  '&NAME-&SYSDATE-&SYSTIME'\n&IDL     SETA  K'&ID                    Length of id\n         AIF   ('&TYPE' EQ 'MAIN').MAIN\n         USNGX QCOMMON,R11              Access to common vector table\n         USNGX &NAME,R12                Base register\n         B     &IHBNX.A                 Branch around id\n         DC    AL1(&IDL),C'&ID'\n         AIF   ('&WORKLEN' NE '').HAVELWA\n&QSWRKLN DC    Y(72+8)                  Default size of save area\n         AGO   .MVCWORK\n.HAVELWA ANOP\n&QSWRKLN DC    Y((&WORKLEN+7)/8*8)      Default size of local workarea\n.MVCWORK ANOP\n&IHBNX.A MVC   2(2,R13),&QSWRKLN        Set size of local workarea\n         AGO   .STACK\n.MAIN    USING *,R15                    Temp\n         B     &IHBNX.A                 Branch around id\n         DROP  R15\n         DC    AL1(&IDL),C'&ID'\n&QSWRKLN DC    Y((&WORKLEN+7)/8*8)      Default size of save area\n&IHBNX.A STM   R14,R12,12(R13)          Save caller's registers\n         LR    R12,R15                  Load base reg\n         USNGX &NAME,R12                Base register\n         LR    R2,R1                    Save parameter register\n*        GETMAIN R,LV=4096,SP=1         Get storage for savearea\n         GETMAIN R,LV=4096,SP=1         Get storage for savearea\n         ST    R1,8(,R13)               Forward pointer\n         ST    R13,4(,R1)               Backward pointer\n         LR    R13,R1                   Move addr of savearea stack\n.*       MVC   2(2,R13),=Y((&WORKLEN+7)/8*8) Set size of local workarea\n         MVC   2(2,R13),&QSWRKLN        Set size of local workarea\n.STACK   AIF   ('&STACK' EQ '').DONE\n         SPACE 2\n*        QSTACK  ...\n         QSTACK  &STACK(1),&STACK(2)\n.DONE    SPACE 2\n         INUSE ,\n.COMMON2 MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "QSTART$$": {"ttr": 18435, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x19\\x00\\x00\\x00\\x82#/\\x00\\x89\\x15\\x8f\"&\\x00\\xfb\\x00>\\x00\\xdf\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "05.25", "flags": 0, "createdate": "1982-08-20T00:00:00", "modifydate": "1989-06-07T22:26:00", "lines": 251, "newlines": 62, "modlines": 223, "user": "LDW"}, "text": "         MACRO\n&NAME    QSTART  &QNUM,&TYPE=,&WORKLEN=,&STACK=\n.*--------------------------------------------------------------------*\n.*                                                                    *\n.*  QSTART - Do O/S housekeeping at start of a routine                *\n.*                                                                    *\n.*  Note:  &QNUM is not used -- it is for historical purposes only    *\n.*                                                                    *\n.*  Updates:                                                          *\n.*     05Jun89  LDW  Utilize special LINK SVC to run SUPR mode        *\n.*     23Mar89  LDW  Move .ALL1 to ANOP to keep ASMF happy            *\n.*     21Feb87  LDW  Invoke new QHASPEQU macro to generate misc       *\n.*                      equates needed for JES2 macros                *\n.*     01Jan86  LDW  SPLEVEL SET=1 (If you don't have SPLEVEL, you'll *\n.*                      to create a dummy macro that does nothing)    *\n.*     30Nov86  LDW  Ok, Jack, I broke down and changed the _ to -    *\n.*                      in the id field                               *\n.*     22JUN86  LDW  Use &@@ACF2 instead of &QACF2                    *\n.*              LDW  Support PRINT=ALL for debugging                  *\n.*     03/30/86 LDW  Fix bug in 'ENTRY' creaded by previous update    *\n.*     02/23/86 LDW  Don't clobber R0 (sometimes used as a parm reg)  *\n.*     01/21/85 LDW  Correct asm errors for 'NOACF2' option           *\n.*     12/05/84 LDW  Set local workarea size via LA/ST instead of     *\n.*                      MVC, so don't get addressibility errors in    *\n.*                      large routines                                *\n.*     08/07/84 LDW  Drop all registers at start (needed because      *\n.*                      some stupid JES2/SP134 macros do USINGs)      *\n.*                   Add SYSPARM support for ALTCCH                   *\n.*     08/02/84 LDW  Add support for SYSPARM and TYPE=COMMON          *\n.*     01/17/84 LDW  Add support for command stacking                 *\n.*     03/04/83 LDW  Change USING/DROP to USNGX/DROPX, add INUSE      *\n.*     01/27/83 LDW  ACF2 SP support                                  *\n.*     01/19/83 LDW  Fix bug:  need WORKLEN= for TYPE=ENTRY also      *\n.*     01/04/83 LDW  Add support for WORKLEN=                         *\n.*     12/14/82 LDW  Skip blurb if &DOC=NOGEN                         *\n.*                                                                    *\n.*--------------------------------------------------------------------*\n.*\n.*  Suppress comments around QGLOBALS\n         AIF   ('&SYSPARM'(1,9) EQ 'PRINT=ALL').ALL1\n         PRINT OFF                                                    1\n.ALL1    ANOP\n         COPY  QGLOBALS\n         SPLEVEL  SET=1\n.***     AIF   (&QLEVEL LT 4 OR &@@ACF2 EQ 0).NACF2J2\n.***     #ACFJES2  ,                    Set &ACF2JCT\n.*** .NACF2J2 PRINT ON,&PRINT                                         2\n         PRINT ON,&PRINT                                              2\n         GBLB  &QBLURB                  Blurb given for this assembly\n         GBLC  &QSECT                   Name of current routine\n         GBLC  &QSWRKLN                 Name of WORKLEN constant\n         LCLA  &IDL,&PARMLEN,&PARMPOS,&PARMPTR\n         LCLC  &ID,&IHBNX,&PARMKEY,&PARMVAL,&XPARM,&C1,&C2,&C3,&C4\n&IHBNX   SETC  'IHB&SYSNDX'\n         AIF   ('&TYPE' EQ 'ENTRY').ENTRY  Don't scan SYSPARM for ENTRY\n&QSWRKLN SETC  '&IHBNX.W'               Set name of WORKLEN constant\n         AIF   (K'&SYSPARM EQ 0).SPNONE    No SYSPARM\n         AIF   ('&SYSPARM' EQ '*').SPNONE  No SYSPARM\n         AIF   ('&SYSPARM' EQ ' ').SPNONE  No SYSPARM\n         MNOTE *,'SYSPARM IS ''&SYSPARM'' '\n&PARMLEN SETA  K'&SYSPARM\n&XPARM   SETC  '&SYSPARM'.','           Add trailing comma\n&PARMPTR SETA  1                        Starting pos of this key\n.PARMLP1 ANOP\n&PARMPOS SETA  &PARMPOS+1\n         AIF   ('&XPARM'(&PARMPOS,1) EQ ',').COMMA\n         AIF   ('&XPARM'(&PARMPOS,1) NE '=').PARMLP1\n&PARMKEY SETC  '&XPARM'(&PARMPTR,&PARMPOS-&PARMPTR+1)  Include the '='\n&PARMPTR SETA  &PARMPOS+1               Starting pos of this value\n.PARMLP2 ANOP\n&PARMPOS SETA  &PARMPOS+1\n         AIF   ('&XPARM'(&PARMPOS,1) NE ',').PARMLP2\n&PARMVAL SETC  '&XPARM'(&PARMPTR,&PARMPOS-&PARMPTR)\n         AGO   .PARMCHK\n.COMMA   ANOP\n&PARMKEY SETC  '&XPARM'(&PARMPTR,&PARMPOS-&PARMPTR)\n&PARMVAL SETC  '***NONE***'\n.PARMCHK ANOP\n&PARMPTR SETA  &PARMPOS+1               Starting pos of next key\n         AIF   ('&PARMKEY' EQ 'DOC='    ).SPDOC\n         AIF   ('&PARMKEY' EQ 'PRINT='  ).SPPRINT\n         AIF   ('&PARMKEY' EQ 'ACF2='   ).SPACF2\n         AIF   ('&PARMKEY' EQ 'ALTCCH=' ).SPALTCC\n         AIF   ('&PARMKEY' EQ 'APFSVC'  ).SPAPF\n         AIF   ('&PARMKEY' EQ 'NOAPFSVC').SPAPFNO\n         AIF   ('&PARMKEY' EQ 'QLEVEL=' ).SPQLVL\n         AIF   ('&PARMKEY' EQ 'JQEOWN=' ).SPJQE\n         AIF   ('&PARMKEY' EQ 'TMPMAC'  ).SPTMP\n         AIF   ('&PARMKEY' EQ 'NOTMPMAC').SPTMPNO\n         AIF   ('&PARMKEY' EQ 'JES2='   ).SPTBL1\n         MNOTE 8,'Unsupported SYSPARM key -- &PARMKEY -- ignored'\n.PARMNXT AIF   (&PARMPTR LT &PARMLEN).PARMLP1\n         AGO   .SPEND\n.SPDOC   ANOP\n&DOC     SETC  '&PARMVAL'\n         MNOTE *,'SYSPARM override -- &&DOC=&DOC'\n         AGO   .PARMNXT\n.SPPRINT ANOP\n&PRINT   SETC  '&PARMVAL'\n         MNOTE *,'SYSPARM override -- &&PRINT=&PRINT'\n         AIF   ('&PRINT' NE 'ALL').PARMNXT\n&PRINT   SETC  'GEN'\n         AGO   .PARMNXT\n.SPACF2  ANOP\n&@@ACF2  SETA  &PARMVAL\n         MNOTE *,'SYSPARM override -- &&@@ACF2=&@@ACF2'\n         AGO   .PARMNXT\n.SPALTCC ANOP\n&QALTCCH SETC  '&PARMVAL'\n         MNOTE *,'SYSPARM override -- &&QALTCCH=&QALTCCH'\n         AGO   .PARMNXT\n.SPAPF   ANOP\n&QAPFSVC SETB  1\n         MNOTE *,'SYSPARM override -- &&QAPFSVC=&QAPFSVC'\n         AGO   .PARMNXT\n.SPAPFNO ANOP\n&QAPFSVC SETB  0\n         MNOTE *,'SYSPARM override -- &&QAPFSVC=&QAPFSVC'\n         AGO   .PARMNXT\n.SPQLVL  ANOP\n&QLEVEL  SETA  &PARMVAL\n         MNOTE *,'SYSPARM override -- &&QLEVEL=&QLEVEL'\n         AGO   .PARMNXT\n.SPJQE   ANOP\n&QJQEOWN SETC  '&PARMVAL'\n         MNOTE *,'SYSPARM override -- &&QJQEOWN=&QJQEOWN'\n         AGO   .PARMNXT\n.SPTMP   ANOP\n&QTMPMAC SETB  1\n         MNOTE *,'SYSPARM override -- &&QTMPMAC=&QTMPMAC'\n         AGO   .PARMNXT\n.SPTMPNO ANOP\n&QTMPMAC SETB  0\n         MNOTE *,'SYSPARM override -- &&QTMPMAC=&QTMPMAC'\n         AGO   .PARMNXT\n.SPTBL1  ANOP\n&QSYSTBL(1) SETC '&PARMVAL'\n         MNOTE *,'SYSPARM override which follows forces &&QSYSNUM=1'\n         MNOTE *,'SYSPARM override -- &&QSYSTBL(1)=&QSYSTBL(1)'\n&C1      SETC  '&PARMVAL'(1,6)\n&C2      SETC  '&PARMVAL'(7,4)\n&C3      SETC  '&PARMVAL'(11,6)\n&C4      SETC  '&PARMVAL'(17,8)\n         MNOTE *,'==> SYSRES=&C1, JES2 name=&C2, CKPTVOL=&C3, CKPTPFX=&$\n               C4'\n         AGO   .PARMNXT\n.SPNONE  MNOTE *,'No overriding SYSPARM'\n.SPEND   AIF   (&QLEVEL LT 4 OR &@@ACF2 EQ 0).NACF2J2\n         AIF   ('&SYSPARM'(1,9) EQ 'PRINT=ALL').ALL2\n         PRINT OFF                                                    3\n.ALL2    #ACFJES2  ,                    Set &ACF2JCT\n         PRINT ON,&PRINT                                              4\n.NACF2J2 AIF   ('&TYPE' EQ 'COMMON').COMMON1\n         AGO   .CSECT\n.ENTRY   ENTRY &NAME\n&NAME    LA    R15,&NAME-&QSECT         Compute difference in bases\n         SR    R12,R15                  Adjust my base to that of CSECT\n         MVC   2(2,R13),&QSWRKLN        Set size of local workarea\n         AIF   ('&WORKLEN' EQ '').STACK Continue\n         MNOTE 0,'WORKLEN=&WORKLEN ignored for TYPE=ENTRY'\n         AGO   .STACK                   Continue\n.CSECT   AIF   ('&PRINT' EQ 'GEN').CSECTX  Skip double 'GEN'\n         PRINT GEN                      Show CSECT start addr         5\n.CSECTX  ANOP\n&NAME    CSECT\n&QSECT   SETC  '&NAME'                  Remember name of current rtn\n         AIF   ('&DOC' EQ 'GEN').NOGEN2 Avoid 2 GEN's in a row\n         AIF   ('&SYSPARM'(1,9) EQ 'PRINT=ALL').NOGEN2\n         PRINT NOGEN                                                  6\n.NOGEN2  DROPX ,                        DROP all previous base regs\n         DROP  ,                        Just to be sure        SP134\n         QREGS\n.COMMON1 QHASPEQU\n         AIF   ('&DOC' EQ 'NOGEN').OKBLURB  Skip blurb if &DOC=NOGEN\n         AIF   (&QBLURB).OKBLURB        Skip if already done\n&QBLURB  SETB  1                        Don't do it again\n         COPY  $UPDATES\n         SPACE 2\n.OKBLURB AIF   ('&PRINT' EQ 'NOGEN').NOGEN3   Avoid 2 NOGEN's in a row\n         PRINT GEN                                                    7\n.NOGEN3  AIF   ('&TYPE' EQ 'COMMON').COMMON2\n&ID      SETC  '&NAME-&SYSDATE-&SYSTIME'\n&IDL     SETA  K'&ID                    Length of id\n         AIF   ('&TYPE' EQ 'MAIN').MAIN\n         USNGX QCOMMON,R11              Access to common vector table\n         USNGX &NAME,R12                Base register\n         B     &IHBNX.A                 Brance around id\n         DC    AL1(&IDL),C'&ID'\n         AIF   ('&WORKLEN' NE '').HAVELWA\n&QSWRKLN DC    Y(72+8)                  Default size of save area\n         AGO   .MVCWORK\n.HAVELWA ANOP\n&QSWRKLN DC    Y((&WORKLEN+7)/8*8)      Default size of local workarea\n.MVCWORK ANOP\n&IHBNX.A MVC   2(2,R13),&QSWRKLN        Set size of local workarea\n         AGO   .STACK\n.MAIN    USING *,R15                    Temp\n         B     &IHBNX.A                 Branch around id\n         DROP  R15\n         DC    AL1(&IDL),C'&ID'\n&QSWRKLN DC    Y((&WORKLEN+7)/8*8)      Default size of save area\n&IHBNX.A STM   R14,R12,12(R13)          Save caller's registers\n         LR    R12,R15                  Load base reg\n         USNGX &NAME,R12                Base register\n         LR    R2,R1                    Save parameter register\n          AIF   (&@@LKSVC EQ 0).NOSVC   skip if no special LINK SVC\n*\n*        TESTAUTH  FCTN=1               see if we're APF authorized\n         TESTAUTH  FCTN=1\n*\n         LTR   R15,R15                  are we?\n         BZ    &IHBNX.Z                 yes - can't use ISPF services\n*\n*        TESTAUTH  STATE=YES,RBLEVEL=1  see if we're SUPR state\n         TESTAUTH  STATE=YES,RBLEVEL=1\n*\n         LTR   R15,R15                  are we?\n         BZ    &IHBNX.Y                 yes - go change keys\n         L     R1,X'218'                PSA.TNEW\n         L     R1,0(,R1)                TCB.RBP\n         N     R1,=X'00FFFFFF'          clean in case AMODE31\n.*       TM    10(R1),X'E0'             RB.STAB1,RBFTP  PRB?\n.*       BNZ   &IHBNX.Y                 no, assume SVRB - go change key\n         L     R1,12(,R1)               RB.CDE\n         N     R1,=X'00FFFFFF'          clean in case AMODE31\n         LA    R0,8(,R1)                CDNAME\n         LR    R1,R2                    restore parm ptr\n         SVC   &@@LKSVC                 reinvoke myself SUPR, KEY 0\n*\n*        RETURN  (14,12),T,RC=(15)      exit from top level\n         RETURN  (14,12),T,RC=(15)      exit from top level\n*\n MNOTE '&IHBNX.Y MODESET  EXTKEY=&QEXKEY'\n&IHBNX.Y MODESET  EXTKEY=&QEXKEY\n*\n&IHBNX.Z EQU   *\n.NOSVC    ANOP\n*        GETMAIN R,LV=4096,SP=1         Get storage for savearea\n         GETMAIN R,LV=4096,SP=1\n         ST    R1,8(,R13)               Forward pointer\n         ST    R13,4(,R1)               Backward pointer\n         LR    R13,R1                   Move addr of savearea stack\n.*       MVC   2(2,R13),=Y((&WORKLEN+7)/8*8) Set size of local workarea\n         MVC   2(2,R13),&QSWRKLN        Set size of local workarea\n.STACK   AIF   ('&STACK' EQ '').DONE\n         SPACE 2\n*        QSTACK  ...\n         QSTACK  &STACK(1),&STACK(2)\n.DONE    SPACE 2\n         INUSE ,\n.COMMON2 MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "QTILT": {"ttr": 18440, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\n\\x00\\x00\\x00\\x82#/\\x00\\x83\\x06\\x8f\\x16\\t\\x00=\\x00\\x1d\\x008\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "05.10", "flags": 0, "createdate": "1982-08-20T00:00:00", "modifydate": "1983-03-09T16:09:00", "lines": 61, "newlines": 29, "modlines": 56, "user": "LDW"}, "text": "         MACRO\n&NFS     QTILT &MESSAGE,&LENGTH,&LENFIX=,&OPTIONS=\n.*--------------------------------------------------------------------*\n.*                                                                    *\n.*  QTILT - EXIT CURRENT ROUTINE WITH ERROR MESSAGE                   *\n.*                                                                    *\n.*  UPDATES:                                                          *\n.*     03/09/83 LDW  MOVE ERROR MESSAGE DIRECTLY TO 'QERRMSG'         *\n.*     02/25/83 LDW  REMOVE &STOP SUPPORT                             *\n.*     01/13/83 LDW  SUPPORT OPTIONS=SET (REQUIRES OPTIONS=REPROMPT)  *\n.*     12/22/82 LDW  REMOVE &REPRMPT= OPTION                          *\n.*     12/15/82 LDW  PUT IN MNOTE 0 IF REPRMPT SPECIFIED              *\n.*     12/13/82 LDW  ADD OPTIONS= KEYWORD TO SUPPORT MULTIPLE OPTIONS *\n.*                      LIKE REPROMPT, WHICH WILL BE DISCONTINUED     *\n.*     10/28/82 LDW  CHANGE &LENGTH TO &LENFIX AND HANDLE DIFFERENTLY *\n.*                      TO KEEP STUPID OLD (VERY OLD) ASMH HAPPY      *\n.*                                                                    *\n.*--------------------------------------------------------------------*\n.*\n.* NOTE: GENERATED CODE INTENTIONALLY SHIFTED RIGHT 1 COLUMN\n         LCLA  &L,&I\n         LCLB  &REPROMT,&SET\n         LCLC  &NAME\n&NAME    SETC  '&NFS'\n.OPTLOOP AIF   (&I GE N'&OPTIONS).OKOPTS\n&I       SETA  &I+1\n         AIF   ('&OPTIONS(&I)' EQ 'REPROMPT').OPTREPR\n         AIF   ('&OPTIONS(&I)' EQ 'SET'     ).OPTSET\n         MNOTE 4,'INVALID OPTION - &OPTIONS(&I) - IGNORED'\n         AGO   .OPTLOOP\n.OPTREPR ANOP\n&REPROMT SETB  1\n         AGO   .OPTLOOP\n.OPTSET  AIF   (&REPROMT).OPTSET2\n         MNOTE 4,'OPTIONS=SET REQUIRES OPTIONS=REPROMPT -- SET IGNORED'\n         AGO   .OPTLOOP\n.OPTSET2 ANOP\n&SET     SETB  1\n         AGO   .OPTLOOP\n.OKOPTS  AIF   ('&MESSAGE' EQ '*').COMMON\n         AIF   ('&MESSAGE'(1,1) EQ '''').QUOTE\n&NAME     MVC   QERRMSG(&LENGTH),&MESSAGE\n&NAME    SETC  ''\n         AGO   .COMMON\n.QUOTE   ANOP\n&L       SETA  K'&MESSAGE-2\n         AIF   ('&LENFIX' EQ '').OK\n&L       SETA  &L-&LENFIX\n         MNOTE 0,'* MESSAGE LENGTH IS &L *'\n.OK      ANOP\n&NAME     MVC   QERRMSG(&L),=C&MESSAGE\n&NAME    SETC  ''\n.COMMON  AIF   (NOT &REPROMT).BRANCH\n&NAME     OI    QSCFLAG1,QSC1PMPT        REQUEST COMMAND PROMPT\n&NAME    SETC  ''\n         AIF   (NOT &SET).BRANCH\n          MVC   QDPROMPT,QDREPLY         SET WHAT TO REPROMPT\n.BRANCH  ANOP\n&NAME     B     QTILT                    INVOKE QTILT SUBROUTINE\n         SPACE 2\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "QUEUE": {"ttr": 18442, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x05\\x02\\x00\\x00\\x00\\x82#/\\x00\\x83\\x00?\\x12\\x01\\x00\\x04\\x00\\x05\\x00\\x02\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "05.02", "flags": 0, "createdate": "1982-08-20T00:00:00", "modifydate": "1983-01-03T12:01:00", "lines": 4, "newlines": 5, "modlines": 2, "user": "LDW"}, "text": "         COPY  Q##TITLE                 GET TITLE AND OPTION VARIABLES\n         SPACE 5\n         COPY  Q##ALL                   ALL THE REST\n         END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "QUEUEASM": {"ttr": 18444, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0f\\x00\\x00\\x00\\x84!_\\x00\\x91\\x15\\x9f\"\\x16\\x00#\\x00\"\\x00\\x16\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.15", "flags": 0, "createdate": "1984-08-02T00:00:00", "modifydate": "1991-06-08T22:16:00", "lines": 35, "newlines": 34, "modlines": 22, "user": "LDW"}, "text": "//QUEUEASM PROC RES=,DLIB=,XREF=SHORT,OBJ=,SYSPARM=' ',TEST=,\n//             SYSIN='LDW.Q.ASM',ACFX=ACF520,JES2REL=313\n//*---\n//*SM      EXEC PGM=AFOX00,REGION=1024K,PARM=(&OBJ.OBJ,\n//ASM      EXEC PGM=IEV90,REGION=6M,PARM=(&OBJ.OBJECT,  LINECNT(85),\n//         'XREF(&XREF),NODECK,NORLD,TERM,&TEST,SYSPARM(&SYSPARM)')\n//*MACREF   DD  DUMMY             ** REQUEST MACRO NAME LISTING **\n//SYSIN     DD  DISP=(SHR,PASS),DSN=LDW.Q.ASM(Q##TITLE)\n//          DD  DISP=(SHR,PASS),DSN=&SYSIN(&M)\n//          DD  DISP=(SHR,PASS),DSN=LDW.Q.ASM(Q##END)\n//SYSLIB    DD  DISP=(SHR,PASS),DSN=&SYSIN\n//          DD  DISP=(SHR,PASS),DSN=LDW.Q.ASM\n//          DD  DISP=(SHR,PASS),DSN=SYS6.JES&JES2REL..ASM  <=======\n//          DD  DISP=(SHR,PASS),DSN=SYS1.SMPMTS,     <=======\n//             UNIT=SYSALLDA,VOL=SER=&RES\n//          DD  DISP=(SHR,PASS),DSN=SYS1.HASPSRC,\n//             UNIT=SYSALLDA,VOL=SER=&DLIB\n//          DD  DISP=(SHR,PASS),DSN=SYS1.MODGEN,     <=======\n//             UNIT=SYSALLDA,VOL=SER=&RES            <===\n//          DD  DISP=(SHR,PASS),DSN=SYS1.MACLIB,\n//             UNIT=SYSALLDA,VOL=SER=&RES\n//          DD  DISP=(SHR,PASS),DSN=LDW.MACLIB       <=======\n//          DD  DISP=(SHR,PASS),DSN=&ACFX..ACFMAC,   <=======\n//             UNIT=SYSALLDA,VOL=SER=&RES\n//******    DD  DISP=(SHR,PASS),DSN=SYS5.PVTMACS     <=======\n//SYSTERM   DD  SYSOUT=T,HOLD=YES                    <==== CHECK THIS\n//SYSPRINT  DD  SYSOUT=*\n//SYSUT1    DD  DSN=&&SYSUT1,UNIT=VIO,SPACE=(1700,(3000,500),,,ROUND)\n//*YSUT2    DD  DSN=&&SYSUT2,UNIT=VIO,SPACE=(1700,(300,50),,,ROUND)\n//*YSUT3    DD  DSN=&&SYSUT3,UNIT=VIO,SPACE=(1700,(300,50),,,ROUND)\n//*YSGO     DD  DSN=&&OBJSET,UNIT=VIO,DISP=(MOD,PASS),\n//*            SPACE=(2960,(200,50)),DCB=BLKSIZE=2960\n//SYSLIN    DD  DSN=&&OBJSET,UNIT=VIO,DISP=(MOD,PASS),\n//             SPACE=(2960,(200,50)),DCB=BLKSIZE=2960\n//*********************************************************************\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "QUEUELNK": {"ttr": 18446, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x08\\x00\\x00\\x00\\x84!_\\x00\\x91\\x07O\"H\\x00\\x15\\x00\\x15\\x00\\x07\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.08", "flags": 0, "createdate": "1984-08-02T00:00:00", "modifydate": "1991-03-15T22:48:00", "lines": 21, "newlines": 21, "modlines": 7, "user": "LDW"}, "text": "//QUEUELNK PROC INCLUDE=INCLUDE,ORDER=ORDER,MOD=Q$,TEST=,PL=\n//* LEONARD WOREN\n//*---\n//COPYLKED EXEC  PGM=IEBGENER\n//* THIS STEP IS TO GET AROUND THE LINKAGE EDITOR'S STUPID\n//* RESTRICTION THAT THE BLKSIZE FOR SYSLIN CAN'T BE OVER 3200.\n//SYSPRINT  DD  SYSOUT=Z\n//SYSIN     DD  DUMMY\n//SYSUT1    DD  DISP=SHR,DSN=LDW.Q.ASM($&INCLUDE)\n//          DD  DISP=SHR,DSN=LDW.Q.ASM($&ORDER)\n//SYSUT2    DD  DISP=MOD,DSN=&&OBJSET\n//*---\n//LKED     EXEC  PGM=IEWL,\n// PARM='NCAL,LET,LIST,XREF,RENT,REUS,REFR,&TEST,AMODE=31,&PL'\n//SYSLMOD   DD  DISP=SHR,DSN=LDW.CMD.LOAD(&MOD)\n//OLDLMOD   DD  DISP=SHR,DSN=LDW.CMD.LOAD\n//          DD  DISP=SHR,DSN=SYS3.LINKLIB\n//SYSUT1    DD  DSN=&&SYSUT1,UNIT=VIO,SPACE=(1024,(50,20),,,ROUND)\n//SYSPRINT  DD  SYSOUT=*\n//SYSLIN    DD  DSN=&&OBJSET,DISP=(OLD,DELETE)\n//*********************************************************************\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "QZACCVT": {"ttr": 18448, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x894O\\x00\\x894O#\\x03\\x00\\x17\\x00\\x17\\x00\\x00\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-12-10T00:00:00", "modifydate": "1989-12-10T23:03:00", "lines": 23, "newlines": 23, "modlines": 0, "user": "LDW"}, "text": "         MACRO\n         QZACCVT\n.*--------------------------------------------------------------------*\n.*                                                                    *\n.*  Updates:                                                          *\n.*     10Dec89  LDW  Rename from QACCVT to QZACCVT                    *\n.*     23Nov89  LDW  Don't expand if &@@ACF2 = 0                      *\n.*                                                                    *\n.*--------------------------------------------------------------------*\n.*\n         GBLA  &@@ACF2\n         GBLB  &$QZACVT\n.*\n         AIF   (&$QZACVT).MEND          IGNORE IF ALREADY GENERATED\n&$QZACVT SETB  1                        SET \"ALREADY GENERATED\" FLAG\n         AIF   (&@@ACF2 EQ 0).BYPASS\n*        ACCVT\n         ACCVT\n         SPACE 6\n.*\n         MEXIT\n.BYPASS  MNOTE *,'ACCVT bypassed due to &&@@ACF2 = 0.'\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "QZACDSV": {"ttr": 18450, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x894O\\x00\\x894O#\\x04\\x00\\x17\\x00\\x17\\x00\\x00\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-12-10T00:00:00", "modifydate": "1989-12-10T23:04:00", "lines": 23, "newlines": 23, "modlines": 0, "user": "LDW"}, "text": "         MACRO\n         QZACDSV\n.*--------------------------------------------------------------------*\n.*                                                                    *\n.*  Updates:                                                          *\n.*     10Dec89  LDW  Rename from QACDSV to QZACDSV                    *\n.*     23Nov89  LDW  Don't expand if &@@ACF2 = 0                      *\n.*                                                                    *\n.*--------------------------------------------------------------------*\n.*\n         GBLA  &@@ACF2\n         GBLB  &$QZACDV\n.*\n         AIF   (&$QZACDV).MEND          IGNORE IF ALREADY GENERATED\n&$QZACDV SETB  1                        SET \"ALREADY GENERATED\" FLAG\n         AIF   (&@@ACF2 EQ 0).BYPASS\n*        ACDSV DSECT=YES\n         ACDSV DSECT=YES\n         SPACE 6\n.*\n         MEXIT\n.BYPASS  MNOTE *,'ACDSV bypassed due to &&@@ACF2 = 0.'\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "QZACFJCB": {"ttr": 18452, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x894O\\x00\\x894O#\\x06\\x00\\x18\\x00\\x18\\x00\\x00\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-12-10T00:00:00", "modifydate": "1989-12-10T23:06:00", "lines": 24, "newlines": 24, "modlines": 0, "user": "LDW"}, "text": "         MACRO\n         QZACFJCB\n.*--------------------------------------------------------------------*\n.*                                                                    *\n.*  Updates:                                                          *\n.*     10Dec89  LDW  Rename from QACFJCB to QZACFJCB                  *\n.*     23Nov89  LDW  Don't expand if &@@ACF2 = 0 or &@@ACF2 >= 410    *\n.*                                                                    *\n.*--------------------------------------------------------------------*\n.*\n         GBLA  &@@ACF2\n         GBLB  &$QZACJC\n.*\n         AIF   (&$QZACJC).MEND          IGNORE IF ALREADY GENERATED\n&$QZACJC SETB 1                         SET \"ALREADY GENERATED\" FLAG\n         AIF   ((&@@ACF2 EQ 0) OR (&@@ACF2 GT 400)).BYPASS\n*        #ACFJCB\n         #ACFJCB\n         SPACE 6\n.*\n         MEXIT\n.BYPASS  MNOTE *,'ACFJCB bypassed due to &&@@ACF2 = 0 or &&@@ACF2 > 400$\n               .'\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "QZACFNJB": {"ttr": 18454, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x894O\\x00\\x903o\\x03\\x07\\x00\\x1a\\x00\\x17\\x00\\x03\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1989-12-10T00:00:00", "modifydate": "1990-12-02T03:07:00", "lines": 26, "newlines": 23, "modlines": 3, "user": "LDW"}, "text": "         MACRO\n         QZACFNJB\n.*--------------------------------------------------------------------*\n.*                                                                    *\n.*  Updates:                                                          *\n.*     01Dec90  LDW  Invoke QZACVALD                                  *\n.*     10Dec89  LDW  Rename from QACFJNBL to QZACFNJB                 *\n.*     23Nov89  LDW  Don't expand if &@@ACF2 < 410                    *\n.*                                                                    *\n.*--------------------------------------------------------------------*\n.*\n         GBLA  &@@ACF2\n         GBLB  &QZACFNB\n.*\n         AIF   (&QZACFNB).MEND          IGNORE IF ALREADY GENERATED\n&QZACFNB SETB 1                         SET \"ALREADY GENERATED\" FLAG\n*        QZACVALD\n         QZACVALD\n         AIF   (&@@ACF2 LT 410).BYPASS\n*        ACFNJBLK\n         ACFNJBLK\n         SPACE 6\n.*\n         MEXIT\n.BYPASS  MNOTE *,'ACFNJBL bypassed due to &&@@ACF2 < 410.'\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "QZACVALD": {"ttr": 18689, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x894O\\x00\\x90\\x00\\x9f!I\\x00\\x18\\x00\\x13\\x00\\x05\\xc5\\xd4\\xe2@@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1989-12-10T00:00:00", "modifydate": "1990-01-09T21:49:00", "lines": 24, "newlines": 19, "modlines": 5, "user": "EMS"}, "text": "         MACRO\n         QZACVALD\n.*--------------------------------------------------------------------*\n.*                                                                    *\n.*  Updates:                                                          *\n.*     09Jan90  EMS  Fix for non-ACF2 shops                           *\n.*     10Dec89  LDW  Rename from QACVALD to QZACVALD                  *\n.*     04/10/84 LDW  CHANGE TO MVS MACRO FOR MVS/SP JES2 133          *\n.*                                                                    *\n.*--------------------------------------------------------------------*\n.*\n         GBLA  &@@ACF2\n         GBLB  &QZACVLD\n.*\n         AIF   (&QZACVLD).MEND          IGNORE IF ALREADY GENERATED\n         AIF   (&@@ACF2 EQ 0).BYPASS\n*        ACVALD\n         ACVALD\n         SPACE 6\n&QZACVLD SETB  1                        SET \"ALREADY GENERATED\" FLAG\n.*\n         MEXIT\n.BYPASS  MNOTE *,'ACCVT bypassed due to &&@@ACF2 = 0.'\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "QZASCB": {"ttr": 18691, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x894O\\x00\\x894O\"C\\x00\\x16\\x00\\x16\\x00\\x00\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-12-10T00:00:00", "modifydate": "1989-12-10T22:43:00", "lines": 22, "newlines": 22, "modlines": 0, "user": "LDW"}, "text": "         MACRO\n         QZASCB\n.*--------------------------------------------------------------------*\n.*                                                                    *\n.*  Updates:                                                          *\n.*     10Dec89  LDW  Rename from Q$ASCB to QZASCB                     *\n.*     04/10/84 LDW  CHANGE TO MVS MACRO FOR MVS/SP JES2 133          *\n.*                                                                    *\n.*--------------------------------------------------------------------*\n.*\n         GBLB  &$QZASCB\n         GBLC  &QSECT                   NAME OF CURRENT ROUTINE\n.*\n&QSECT   CSECT                          RESUME FOR STUPID HASP MACROS\n.*\n         AIF   (&$QZASCB).MEND          IGNORE IF ALREADY GENERATED\n*        IHAASCB\n         IHAASCB\n         SPACE 6\n&$QZASCB SETB  1                        SET \"ALREADY GENERATED\" FLAG\n.*\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "QZASVT": {"ttr": 18693, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x894O\\x00\\x894O\"B\\x00\\x16\\x00\\x16\\x00\\x00\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-12-10T00:00:00", "modifydate": "1989-12-10T22:42:00", "lines": 22, "newlines": 22, "modlines": 0, "user": "LDW"}, "text": "         MACRO\n         QZASVT\n.*--------------------------------------------------------------------*\n.*                                                                    *\n.*  Updates:                                                          *\n.*     10Dec89  LDW  Rename from Q$ASVT to QZASVT                     *\n.*     04/10/84 LDW  CHANGE TO MVS MACRO FOR MVS/SP JES2 133          *\n.*                                                                    *\n.*--------------------------------------------------------------------*\n.*\n         GBLB  &$QZASVT\n         GBLC  &QSECT                   NAME OF CURRENT ROUTINE\n.*\n&QSECT   CSECT                          RESUME FOR STUPID HASP MACROS\n.*\n         AIF   (&$QZASVT).MEND          IGNORE IF ALREADY GENERATED\n*        IHAASVT\n         IHAASVT\n         SPACE 6\n&$QZASVT SETB  1                        SET \"ALREADY GENERATED\" FLAG\n.*\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "QZCPPL": {"ttr": 18695, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x894O\\x00\\x894O#\\x19\\x00\\x13\\x00\\x13\\x00\\x00\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-12-10T00:00:00", "modifydate": "1989-12-10T23:19:00", "lines": 19, "newlines": 19, "modlines": 0, "user": "LDW"}, "text": "         MACRO\n         QZCPPL\n.*--------------------------------------------------------------------*\n.*                                                                    *\n.*  Updates:                                                          *\n.*     10Dec89  LDW  Rename from QCPPL to QZCPPL                      *\n.*     04/10/84 LDW  CHANGE TO MVS MACRO FOR MVS/SP JES2 133          *\n.*                                                                    *\n.*--------------------------------------------------------------------*\n.*\n         GBLB  &$QZCPPL\n.*\n         AIF   (&$QZCPPL).MEND          IGNORE IF ALREADY GENERATED\n*        IKJCPPL\n         IKJCPPL\n         SPACE 6\n&$QZCPPL SETB  1                        SET \"ALREADY GENERATED\" FLAG\n.*\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "QZCSCB": {"ttr": 18697, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x894O\\x00\\x894O\"F\\x00\\x17\\x00\\x18\\x00\\x00\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-12-10T00:00:00", "modifydate": "1989-12-10T22:46:00", "lines": 23, "newlines": 24, "modlines": 0, "user": "LDW"}, "text": "         MACRO\n         QZCSCB\n.*--------------------------------------------------------------------*\n.*                                                                    *\n.*  Updates:                                                          *\n.*     10Dec89  LDW  Rename from Q$CSCB to QZCSCB                     *\n.*     04/10/84 LDW  CHANGE TO MVS MACRO FOR MVS/SP JES2 133          *\n.*                                                                    *\n.*--------------------------------------------------------------------*\n.*\n         GBLB  &$QZCSCB\n         GBLC  &QSECT                   NAME OF CURRENT ROUTINE\n.*\n&QSECT   CSECT                          RESUME FOR STUPID HASP MACROS\n.*\n         AIF   (&$QZCSCB).MEND          IGNORE IF ALREADY GENERATED\nCSCB     DSECT\n*        IEECHAIN\n         IEECHAIN\n         SPACE 6\n&$QZCSCB SETB 1                         SET \"ALREADY GENERATED\" FLAG\n.*\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "QZCVT": {"ttr": 18699, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x894O\\x00\\x894O\"B\\x00\\x17\\x00\\x17\\x00\\x00\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-12-10T00:00:00", "modifydate": "1989-12-10T22:42:00", "lines": 23, "newlines": 23, "modlines": 0, "user": "LDW"}, "text": "         MACRO\n         QZCVT\n.*--------------------------------------------------------------------*\n.*                                                                    *\n.*  Updates:                                                          *\n.*     10Dec89  LDW  Rename from Q$CVT to QZCVT                       *\n.*     04Jan87  LDW  Use DSECT=YES for SP136 (XA?)                    *\n.*     04/11/84 LDW  CHANGE TO MVS MACRO FOR MVS/SP JES2 133          *\n.*                                                                    *\n.*--------------------------------------------------------------------*\n.*\n         GBLB  &$QZCVT\n         GBLC  &QSECT                   NAME OF CURRENT ROUTINE\n.*\n&QSECT   CSECT                          RESUME FOR STUPID HASP MACROS\n.*\n         AIF   (&$QZCVT).MEND           IGNORE IF ALREADY GENERATED\n*        CVT   DSECT=YES,LIST=YES\n         CVT   DSECT=YES,LIST=YES\n         SPACE 6\n&$QZCVT  SETB  1                        SET \"ALREADY GENERATED\" FLAG\n.*\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "QZDCBD": {"ttr": 18701, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x894O\\x00\\x91\\x03/\\x19C\\x00>\\x003\\x00\\x0c\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1989-12-10T00:00:00", "modifydate": "1991-02-01T19:43:00", "lines": 62, "newlines": 51, "modlines": 12, "user": "LDW"}, "text": "         MACRO\n         QZDCBD\n.*--------------------------------------------------------------------*\n.*                                                                    *\n.*  Updates:                                                          *\n.*     01Feb91  LDW  Integrate GLA fixes below:                       *\n.*    (21Sep90) GLA  Add DCBREAD, DCBCHECK, DCBPOINT, DCBDEBAD,       *\n.*                      DCBMACRF                                      *\n.*     10Dec89  LDW  Rename from QDCBD to QZDCBD                      *\n.*      2JUN87  EMS   Add DCBSYNA                                     *\n.*                                                                    *\n.*--------------------------------------------------------------------*\n.*\n         GBLB  &$QZDCBD\n         GBLC  &QSECT                   NAME OF CURRENT ROUTINE\n.*\n&QSECT   CSECT                          RESUME FOR STUPID HASP MACROS\n.*\n         AIF   (&$QZDCBD).MEND          IGNORE IF ALREADY GENERATED\n&$QZDCBD SETB  1                        SET \"ALREADY GENERATED\" FLAG\n.*\n*        DCBD DSORG=PS,DEVD=DA\nIHADCB   DSECT ,\n         ORG   IHADCB+13\nDCBDVTBA DS    AL3                      ADDR OF DEV CHAR TABLE ENTRY\n         ORG   IHADCB+26\nDCBDSORG DS    0BL2                     DSORG\nDCBDSRG1 DS    B                        FIRST BYTE OF DCBDSORG\nDCBDSGPO EQU   X'02'                    DSORG PO\n         ORG   IHADCB+32\nDCBEODAD DS    A                        End of data address\nDCBRECFM DS    X\nDCBRECF  EQU   X'80'                    RECFM F\nDCBRECV  EQU   X'40'                    RECFM V\nDCBRECU  EQU   X'C0'                    RECFM U\nDCBRECBR EQU   X'10'                    BLOCKED RECORDS\nDCBRECSB EQU   X'08'                    STANDARD OR SPANNED\nDCBRECCC EQU   X'06'                    CONTROL CHARACTOR IND\nDCBRECCA EQU   X'04'                    CONTROL CHARACTOR IND - ASA\nDCBRECCM EQU   X'02'                    CONTROL CHARACTOR IND - MACH\nDCBEXLSA DS    AL3(0)                   EXIT LIST ADDR\n         ORG   IHADCB+40\nDCBDDNAM DS    CL8                      DDNAME OF DCB\nDCBOFLGS DS    X'00'                    OPEN FLAGS\nDCBOFOPN EQU   X'10'                    OPEN BIT\n         ORG   IHADCB+42\nDCBMACRF DS    H                        Macro reference\nDCBDEBAD DS    A                        DEB address\nDCBREAD  DS    A                        READ/WRITE routine addr.\n         ORG   IHADCB+52\nDCBCHECK DS    A                        CHECK routine address\n         ORG   IHADCB+57\nDCBSYNA  DS    AL3                      -> SYNAD EXIT ROUTINE\n         ORG   IHADCB+62\nDCBBLKSI DS    H                        BLKSIZE OF DCB\n         ORG   IHADCB+72\nDCBNCP   DS    AL1                      NUMBER OF CHANNEL PROGRAMS\n         ORG   IHADCB+82\nDCBLRECL DS    H                        LRECL OF DCB\nDCBPOINT DS    A                        POINT routine address\n         SPACE 3\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "QZDEB": {"ttr": 18703, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x894O\\x00\\x894O# \\x00\\x17\\x00\\x17\\x00\\x00\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-12-10T00:00:00", "modifydate": "1989-12-10T23:20:00", "lines": 23, "newlines": 23, "modlines": 0, "user": "LDW"}, "text": "         MACRO\n         QZDEB\n.*--------------------------------------------------------------------*\n.*                                                                    *\n.*  Updates:                                                          *\n.*     10Dec89  LDW  Rename from QDEB to QZDEB                        *\n.*     23Nov89  LDW  Rename from Q$DEB to QDEB for consistency        *\n.*     04/10/84 LDW  Change to MVS macro for MVS/SP JES2 133          *\n.*                                                                    *\n.*--------------------------------------------------------------------*\n.*\n         GBLB  &$QZDEB\n         GBLC  &QSECT                   NAME OF CURRENT ROUTINE\n.*\n&QSECT   CSECT                          RESUME FOR STUPID HASP MACROS\n.*\n         AIF   (&$QZDEB).MEND           IGNORE IF ALREADY GENERATED\n*        IEZDEB\n         IEZDEB\n         SPACE 6\n&$QZDEB  SETB  1                        SET \"ALREADY GENERATED\" FLAG\n.*\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "QZIHAETD": {"ttr": 18705, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x03\\x00\\x00\\x00\\x90&\\x0f\\x00\\x91\\x02\\x9f\\x19U\\x00\\x16\\x00\\x12\\x00\\x0c\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "02.03", "flags": 0, "createdate": "1990-09-17T00:00:00", "modifydate": "1991-01-29T19:55:00", "lines": 22, "newlines": 18, "modlines": 12, "user": "LDW"}, "text": "         MACRO\n         QZIHAETD\n.*--------------------------------------------------------------------*\n.*                                                                    *\n.*  Updates:                                                          *\n.*     29Jan91  LDW  Rename \"already generated\" flag for consistency  *\n.*                   Set it                                           *\n.*     21Sep90  GLA  Update to new base level of USC Queue.           *\n.*     10Jul90  GLA  New macro                                        *\n.*                                                                    *\n.*--------------------------------------------------------------------*\n.*\n         GBLA  &QLEVEL\n         GBLB  &$QZETD\n         AIF   (&QLEVEL LT 8).MEND\n         AIF   (&$QZETD).MEND\n&QETD    SETB  1\n*        IHAETD ,\n         IHAETD ,\n         SPACE 6\n&$QZETD  SETB  1                        SET \"ALREADY GENERATED\" FLAG\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "QZJESCT": {"ttr": 18707, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x894O\\x00\\x894O\"S\\x00\\x16\\x00\\x16\\x00\\x00\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-12-10T00:00:00", "modifydate": "1989-12-10T22:53:00", "lines": 22, "newlines": 22, "modlines": 0, "user": "LDW"}, "text": "         MACRO\n         QZJESCT\n.*--------------------------------------------------------------------*\n.*                                                                    *\n.*  Updates:                                                          *\n.*     10Dec89  LDW  Rename from Q$JESCT to QZJESCT                   *\n.*     04/10/84 LDW  CHANGE TO MVS MACRO FOR MVS/SP JES2 133          *\n.*                                                                    *\n.*--------------------------------------------------------------------*\n.*\n         GBLB  &$QZJESC\n         GBLC  &QSECT                   NAME OF CURRENT ROUTINE\n.*\n&QSECT   CSECT                          RESUME FOR STUPID HASP MACROS\n.*\n         AIF   (&$QZJESC).MEND          IGNORE IF ALREADY GENERATED\n*        IEFJESCT\n         IEFJESCT\n         SPACE 6\n&$QZJESC SETB  1                        SET \"ALREADY GENERATED\" FLAG\n.*\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "QZJSCB": {"ttr": 18709, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x02\\x00\\x00\\x00\\x90&\\x0f\\x00\\x91\\x03\\x0f\\x176\\x00\\x12\\x00\\x0c\\x00\\n\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "02.02", "flags": 0, "createdate": "1990-09-17T00:00:00", "modifydate": "1991-01-30T17:36:00", "lines": 18, "newlines": 12, "modlines": 10, "user": "LDW"}, "text": "         MACRO\n         QZJSCB\n.*--------------------------------------------------------------------*\n.*                                                                    *\n.*  Updates:                                                          *\n.*     01Jan91  LDW  Standardize \"already genned\" flag name           *\n.*                                                                    *\n.*--------------------------------------------------------------------*\n.*\n         GBLB  &$QZJSCB\n.*\n         AIF   (&$QZJSCB).MEND          IGNORE IF ALREADY GENERATED\n*        IEZJSCB\n         IEZJSCB\n         SPACE 6\n&$QZJSCB SETB  1                        SET \"ALREADY GENERATED\" FLAG\n.*\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "QZKEYS": {"ttr": 18711, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x894O\\x00\\x894O\"G\\x00\\x16\\x00\\x17\\x00\\x00\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-12-10T00:00:00", "modifydate": "1989-12-10T22:47:00", "lines": 22, "newlines": 23, "modlines": 0, "user": "LDW"}, "text": "         MACRO\n         QZKEYS\n.*--------------------------------------------------------------------*\n.*                                                                    *\n.*  Updates:                                                          *\n.*     10Dec89  LDW  Rename from Q$KEYS to QZKEYS                     *\n.*     04/10/84 LDW  CHANGE TO MVS MACRO FOR MVS/SP JES2 133          *\n.*                                                                    *\n.*--------------------------------------------------------------------*\n.*\n         GBLB  &$QZKEYS\n         GBLC  &QSECT                   NAME OF CURRENT ROUTINE\n.*\n&QSECT   CSECT                          RESUME FOR STUPID HASP MACROS\n.*\n         AIF   (&$QZKEYS).MEND          IGNORE IF ALREADY GENERATED\n*        IEFVKEYS\n         IEFVKEYS\n         SPACE 6\n&$QZKEYS SETB  1                        SET \"ALREADY GENERATED\" FLAG\n.*\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "QZMCS": {"ttr": 18713, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x894O\\x00\\x894O#$\\x00\\x19\\x00\\x19\\x00\\x00\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-12-10T00:00:00", "modifydate": "1989-12-10T23:24:00", "lines": 25, "newlines": 25, "modlines": 0, "user": "LDW"}, "text": "         MACRO\n         QZMCS\n.*--------------------------------------------------------------------*\n.*                                                                    *\n.*  Updates:                                                          *\n.*     10Dec89  LDW  Rename from QMCS to QZMCS                        *\n.*     04/10/84 LDW  CHANGE TO MVS MACRO FOR MVS/SP JES2 133          *\n.*                                                                    *\n.*--------------------------------------------------------------------*\n.*\n         GBLB  &$QZMCS\n.*\n         AIF   (&$QZMCS).MEND           IGNORE IF ALREADY GENERATED\n*        IEECUCM  FORMAT=NEW\n         IEECUCM  FORMAT=NEW\n         SPACE 4\n*        IEERDCM\n         IEERDCM\n         SPACE 4\n*        IEETDCM\n         IEETDCM\n         SPACE 6\n&$QZMCS  SETB  1                        SET \"ALREADY GENERATED\" FLAG\n.*\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "QZOUCB": {"ttr": 18715, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x894O\\x00\\x894O#%\\x00\\x15\\x00\\x15\\x00\\x00\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-12-10T00:00:00", "modifydate": "1989-12-10T23:25:00", "lines": 21, "newlines": 21, "modlines": 0, "user": "LDW"}, "text": "         MACRO\n         QZOUCB\n.*--------------------------------------------------------------------*\n.*                                                                    *\n.*  Updates:                                                          *\n.*     10Dec89  LDW  Rename from QOUCB to QZOUCB                      *\n.*     05May89  LDW  Change variable name for consistency             *\n.*                                                                    *\n.*--------------------------------------------------------------------*\n.*\n         GBLB  &$QZOUCB\n         GBLC  &QSECT                   NAME OF CURRENT ROUTINE\n.*\n&QSECT   CSECT                          RESUME FOR STUPID HASP MACROS\n.*\n         AIF   (&$QZOUCB).MEND          IGNORE IF ALREADY GENERATED\n         IRAOUCB\n         SPACE 6\n&$QZOUCB SETB  1                        SET \"ALREADY GENERATED\" FLAG\n.*\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "QZPSA": {"ttr": 18717, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x02\\x00\\x00\\x00\\x90&\\x0f\\x00\\x91\\x03\\x0f\\x176\\x00\\x12\\x00\\x0c\\x00\\n\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "02.02", "flags": 0, "createdate": "1990-09-17T00:00:00", "modifydate": "1991-01-30T17:36:00", "lines": 18, "newlines": 12, "modlines": 10, "user": "LDW"}, "text": "         MACRO\n         QZPSA\n.*--------------------------------------------------------------------*\n.*                                                                    *\n.*  Updates:                                                          *\n.*     01Jan91  LDW  Standardize \"already genned\" flag name           *\n.*                                                                    *\n.*--------------------------------------------------------------------*\n.*\n         GBLB  &$QZPSA\n.*\n         AIF   (&$QZPSA).MEND           IGNORE IF ALREADY GENERATED\n*        IHAPSA\n         IHAPSA\n         SPACE 6\n&$QZPSA  SETB  1                        SET \"ALREADY GENERATED\" FLAG\n.*\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "QZPSCB": {"ttr": 18719, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x894O\\x00\\x894O\"I\\x00\\x16\\x00\\x16\\x00\\x00\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-12-10T00:00:00", "modifydate": "1989-12-10T22:49:00", "lines": 22, "newlines": 22, "modlines": 0, "user": "LDW"}, "text": "         MACRO\n         QZPSCB\n.*--------------------------------------------------------------------*\n.*                                                                    *\n.*  Updates:                                                          *\n.*     10Dec89  LDW  Rename from Q$PSCB to QZPSCB                     *\n.*     04/10/84 LDW  CHANGE TO MVS MACRO FOR MVS/SP JES2 133          *\n.*                                                                    *\n.*--------------------------------------------------------------------*\n.*\n         GBLB  &$QZPSCB\n         GBLC  &QSECT                   NAME OF CURRENT ROUTINE\n.*\n&QSECT   CSECT                          RESUME FOR STUPID HASP MACROS\n.*\n         AIF   (&$QZPSCB).MEND          IGNORE IF ALREADY GENERATED\n*        IKJPSCB\n         IKJPSCB\n         SPACE 6\n&$QZPSCB SETB  1                        SET \"ALREADY GENERATED\" FLAG\n.*\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "QZRAX": {"ttr": 18721, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x905\\x0f\\x00\\x905\\x0f\\x18C\\x00\\x16\\x00\\x16\\x00\\x00\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1990-12-16T00:00:00", "modifydate": "1990-12-16T18:43:00", "lines": 22, "newlines": 22, "modlines": 0, "user": "LDW"}, "text": "         MACRO\n         QZRAX\n.*--------------------------------------------------------------------*\n.*                                                                    *\n.*  Updates:                                                          *\n.*     16Dec90  LDW  Created                                          *\n.*                                                                    *\n.*--------------------------------------------------------------------*\n.*\n         GBLA  &@@SPLVL\n         GBLB  &$QZRAX\n.*\n         AIF   (&$QZRAX).MEND           IGNORE IF ALREADY GENERATED\n&$QZRAX  SETB  1                        SET \"ALREADY GENERATED\" FLAG\n         AIF   (&@@SPLVL LT 300).BYPASS\n*        IARRAX\n         IARRAX\n         SPACE 6\n.*\n         MEXIT\n.BYPASS  MNOTE *,'IARRAX bypassed due to &&@@SPLVL < 300.'\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "QZSSCT": {"ttr": 18945, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x894O\\x00\\x894O\"T\\x00\\x16\\x00\\x16\\x00\\x00\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-12-10T00:00:00", "modifydate": "1989-12-10T22:54:00", "lines": 22, "newlines": 22, "modlines": 0, "user": "LDW"}, "text": "         MACRO\n         QZSSCT\n.*--------------------------------------------------------------------*\n.*                                                                    *\n.*  Updates:                                                          *\n.*     10Dec89  LDW  Rename from Q$TEXT to QZTEXT                     *\n.*     04/10/84 LDW  CHANGE TO MVS MACRO FOR MVS/SP JES2 133          *\n.*                                                                    *\n.*--------------------------------------------------------------------*\n.*\n         GBLB  &$QZSSCT\n         GBLC  &QSECT                   NAME OF CURRENT ROUTINE\n.*\n&QSECT   CSECT                          RESUME FOR STUPID HASP MACROS\n.*\n         AIF   (&$QZSSCT).MEND          IGNORE IF ALREADY GENERATED\n*        IEFJSCVT\n         IEFJSCVT\n         SPACE 6\n&$QZSSCT SETB  1                        SET \"ALREADY GENERATED\" FLAG\n.*\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "QZSSIB": {"ttr": 18947, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x894O\\x00\\x894O\"Q\\x00\\x16\\x00\\x16\\x00\\x00\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-12-10T00:00:00", "modifydate": "1989-12-10T22:51:00", "lines": 22, "newlines": 22, "modlines": 0, "user": "LDW"}, "text": "         MACRO\n         QZSSIB\n.*--------------------------------------------------------------------*\n.*                                                                    *\n.*  Updates:                                                          *\n.*     10Dec89  LDW  Rename from Q$SSIB to QZSSIB                     *\n.*     04/10/84 LDW  CHANGE TO MVS MACRO FOR MVS/SP JES2 133          *\n.*                                                                    *\n.*--------------------------------------------------------------------*\n.*\n         GBLB  &$QZSSIB\n         GBLC  &QSECT                   NAME OF CURRENT ROUTINE\n.*\n&QSECT   CSECT                          RESUME FOR STUPID HASP MACROS\n.*\n         AIF   (&$QZSSIB).MEND          IGNORE IF ALREADY GENERATED\n*        IEFJSSIB\n         IEFJSSIB\n         SPACE 6\n&$QZSSIB SETB  1                        SET \"ALREADY GENERATED\" FLAG\n.*\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "QZSSOB": {"ttr": 18949, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x894O\\x00\\x894O\"W\\x00\\x16\\x00\\x16\\x00\\x00\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-12-10T00:00:00", "modifydate": "1989-12-10T22:57:00", "lines": 22, "newlines": 22, "modlines": 0, "user": "LDW"}, "text": "         MACRO\n         QZSSOB\n.*--------------------------------------------------------------------*\n.*                                                                    *\n.*  Updates:                                                          *\n.*     10Dec89  LDW  Rename from Q$SSOB to QZSSOB                     *\n.*     04/10/84 LDW  CHANGE TO MVS MACRO FOR MVS/SP JES2 133          *\n.*                                                                    *\n.*--------------------------------------------------------------------*\n.*\n         GBLB  &$QZSSOB\n         GBLC  &QSECT                   NAME OF CURRENT ROUTINE\n.*\n&QSECT   CSECT                          RESUME FOR STUPID HASP MACROS\n.*\n         AIF   (&$QZSSOB).MEND          IGNORE IF ALREADY GENERATED\n*        IEFJSSOB  (SO,CS),CONTIG=YES\n         IEFJSSOB  (SO,CS),CONTIG=YES\n         SPACE 6\n&$QZSSOB SETB  1                        SET \"ALREADY GENERATED\" FLAG\n.*\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "QZTCB": {"ttr": 18951, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x02\\x00\\x00\\x00\\x90&\\x0f\\x00\\x91\\x03\\x0f\\x177\\x00\\x12\\x00\\x0c\\x00\\n\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "02.02", "flags": 0, "createdate": "1990-09-17T00:00:00", "modifydate": "1991-01-30T17:37:00", "lines": 18, "newlines": 12, "modlines": 10, "user": "LDW"}, "text": "         MACRO\n         QZTCB\n.*--------------------------------------------------------------------*\n.*                                                                    *\n.*  Updates:                                                          *\n.*     01Jan91  LDW  Standardize \"already genned\" flag name           *\n.*                                                                    *\n.*--------------------------------------------------------------------*\n.*\n         GBLB  &$QZTCB\n.*\n         AIF   (&$QZTCB).MEND           IGNORE IF ALREADY GENERATED\n*        IKJTCB\n         IKJTCB\n         SPACE 6\n&$QZTCB  SETB  1                        SET \"ALREADY GENERATED\" FLAG\n.*\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "QZTEXT": {"ttr": 18953, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x894O\\x00\\x894O\"H\\x00\\x16\\x00\\x16\\x00\\x00\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-12-10T00:00:00", "modifydate": "1989-12-10T22:48:00", "lines": 22, "newlines": 22, "modlines": 0, "user": "LDW"}, "text": "         MACRO\n         QZTEXT\n.*--------------------------------------------------------------------*\n.*                                                                    *\n.*  Updates:                                                          *\n.*     10Dec89  LDW  Rename from Q$TEXT to QZTEXT                     *\n.*     04/10/84 LDW  CHANGE TO MVS MACRO FOR MVS/SP JES2 133          *\n.*                                                                    *\n.*--------------------------------------------------------------------*\n.*\n         GBLB  &$QZTEXT\n         GBLC  &QSECT                   NAME OF CURRENT ROUTINE\n.*\n&QSECT   CSECT                          RESUME FOR STUPID HASP MACROS\n.*\n         AIF   (&$QZTEXT).MEND          IGNORE IF ALREADY GENERATED\n*        IEFTXTFT\n         IEFTXTFT\n         SPACE 6\n&$QZTEXT SETB  1                        SET \"ALREADY GENERATED\" FLAG\n.*\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "QZTSVT": {"ttr": 18955, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x04\\x00\\x00\\x00\\x90&\\x0f\\x00\\x91\\x16\\x0f\\x01%\\x00\\x16\\x00\\x0c\\x00\\x0e\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "02.04", "flags": 0, "createdate": "1990-09-17T00:00:00", "modifydate": "1991-06-09T01:25:00", "lines": 22, "newlines": 12, "modlines": 14, "user": "LDW"}, "text": "         MACRO\n         QZTSVT\n.*--------------------------------------------------------------------*\n.*                                                                    *\n.*  Updates:                                                          *\n.*     08Jun91  LDW  &@@TSOE is GBLA, not GBLB                        *\n.*     17Apr91  LDW  Don't expand if &@@TSOE = 0                      *\n.*     01Jan91  LDW  Standardize \"already genned\" flag name           *\n.*                                                                    *\n.*--------------------------------------------------------------------*\n.*\n         GBLA  &@@TSOE\n         GBLB  &$QZTSVT\n.*\n         AIF   (&$QZTSVT).MEND          IGNORE IF ALREADY GENERATED\n         AIF   (&@@TSOE EQ 0).MEND      ignore if no TSO/E\n*        IKJTSVT\n         IKJTSVT\n         SPACE 6\n&$QZTSVT SETB  1                        SET \"ALREADY GENERATED\" FLAG\n.*\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "QZUCB": {"ttr": 18957, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x894O\\x00\\x894O#%\\x00\\x17\\x00\\x17\\x00\\x00\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1989-12-10T00:00:00", "modifydate": "1989-12-10T23:25:00", "lines": 23, "newlines": 23, "modlines": 0, "user": "LDW"}, "text": "         MACRO\n         QZUCB\n.*--------------------------------------------------------------------*\n.*                                                                    *\n.*  Updates:                                                          *\n.*     10Dec89  LDW  Rename from QUCB to QZUCB                        *\n.*     17Apr89  LDW  Rename from Q$UCB to QUCB                        *\n.*     29Dec88  EMS  fix for ESA                                      *\n.*     04/10/84 LDW  CHANGE TO MVS MACRO FOR MVS/SP JES2 133          *\n.*                                                                    *\n.*--------------------------------------------------------------------*\n.*\n         GBLB  &$QZUCB\n.*\nUCB      DSECT ,                        Set to DSECT for UCB macro.\n.*\n         AIF   (&$QZUCB).MEND           IGNORE IF ALREADY GENERATED\n*        IEFUCBOB\n         IEFUCBOB\n         SPACE 6\n&$QZUCB  SETB  1                        SET \"ALREADY GENERATED\" FLAG\n.*\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "QZZB505": {"ttr": 18959, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x903?\\x00\\x91\\x07?\\x19\\x01\\x00\\x17\\x00\\x01\\x00\\x06\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1990-11-29T00:00:00", "modifydate": "1991-03-14T19:01:00", "lines": 23, "newlines": 1, "modlines": 6, "user": "LDW"}, "text": "         MACRO\n         QZZB505\n.*--------------------------------------------------------------------*\n.*                                                                    *\n.*  Updates:                                                          *\n.*     14Mar91  EMS  Add LOCEPAX=YES operand                          *\n.*     20Dec90  LDW  Don't expand if &@@SPLVL < 220                   *\n.*     29NOV90  EMS  created macro                                    *\n.*                                                                    *\n.*--------------------------------------------------------------------*\n.*\n         GBLA  &@@SPLVL\n         GBLB  &$QZB505\n.*\n.*\n         AIF   (&$QZB505).MEND          IGNORE IF ALREADY GENERATED\n         AIF   (&@@SPLVL LT 220).MEND\n*        IEFZB505  LOCEPAX=YES\n         IEFZB505  LOCEPAX=YES\n.OK      SPACE 6\n&$QZB505 SETB  1                        SET \"ALREADY GENERATED\" FLAG\n.*\n.MEND    MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SPFQUEUE": {"ttr": 18961, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x01\\x00\\x00\\x00\\x91\\x03\\x0f\\x00\\x91\\x07O#\\x16\\x00,\\x00\\x10\\x00\\x03\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "02.01", "flags": 0, "createdate": "1991-01-30T00:00:00", "modifydate": "1991-03-15T23:16:00", "lines": 44, "newlines": 16, "modlines": 3, "user": "LDW"}, "text": "PROC 0 ALT DEBUG\nIF &DEBUG = DEBUG THEN CONTROL SYMLIST CONLIST LIST\n/*\n/* This clist suppresses the display of the invocation panel (QPENTRY)\n/* for normal users.  Customize it appropriately for your site.\n/* At USC, the systems staff have another panels library, which\n/* contains a selection to invoke this clist with the ALT keyword.\n/*\n/* This allows the systems programming staff to use special operands,\n/* while limiting the users to access only the current production\n/* QUEUE, spool, and checkpoint.\n/* */\n\nSET &QPARMS =\nISPEXEC VGET (ZENVIR)\n/* In ISPF V3R2, we no longer need the TLD for anything, so it is */\n/* not necessary to use the interface module with prefix 'ISR'.   */\n/* Otherwise, in order to get the TLD address, we must make ISPF  */\n/* think we are part of it, hence the use of the ISRQ module.     */\nIF &SUBSTR(6:8,&STR(&ZENVIR)) >= 3.2 THEN SET &PGM = QUEUE\n                                     ELSE SET &PGM = ISRQ\n\n/*IF &SUBSTR(1:1,&SYSUID) = S      THEN DO\nIF &ALT = ALT                      THEN DO\n   ISPEXEC DISPLAY PANEL(QPENTRY)\n   IF &LASTCC \u00ac= 0 THEN EXIT\n/* ISPEXEC VGET (QPRFX QVLSR QSBS QICMD)\n   IF &QCMDNM = ISRQ THEN DO\n      CONTROL ASIS\n      WRITE That would be exceedingly stupid.\n      EXIT CODE(20)\n      END\n   IF &SUBSTR(6:8,&STR(&ZENVIR)) >= 3.2 THEN SET &PGM = &QCMDNM\n   IF &QPRFX \u00ac= &Z THEN SET &QPARMS = &STR(&QPARMS) DSN(&QPRFX)\n   IF &QVLSR \u00ac= &Z THEN SET &QPARMS = &STR(&QPARMS) CKPT(&QVLSR)\n   IF &QSBS  \u00ac= &Z THEN SET &QPARMS = &STR(&QPARMS) JES(&QSBS)\n   IF &QICMD \u00ac= &Z THEN SET &QPARMS = &STR(&QPARMS) &STR(&QICMD)\n   END\n                                   ELSE DO\n   SET &QCMDNM = QUEUE\n   ISPEXEC VPUT (QCMDNM)\n   END\n\nISPEXEC SELECT PGM(&PGM) PARM(&QPARMS)\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SPFQUEUX": {"ttr": 18963, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x01\\x00\\x00\\x00\\x91\\x07O\\x00\\x91\\x08?!\\x05\\x001\\x00-\\x00\\x05\\xd3\\xc4\\xe6@@@@@@@'", "ispf": {"version": "02.01", "flags": 0, "createdate": "1991-03-15T00:00:00", "modifydate": "1991-03-24T21:05:00", "lines": 49, "newlines": 45, "modlines": 5, "user": "LDW"}, "text": "/* Rexx */\nAddress ISPEXEC\nArg arrgh\nIf Index(arrgh, 'DEBUG') \u00ac= 0 Then Trace I\n/*\n   This exec suppresses the display of the invocation panel (QPENTRY)\n   for normal users.  Customize it appropriately for your site.\n   At USC, the systems staff have another panels library, which\n   contains a selection to invoke this clist with the ALT keyword.\n\n   This allows the systems programming staff to use special operands,\n   while limiting the users to access only the current production\n   QUEUE, spool, and checkpoint.\n*/\n\nqparms = ''\n\"VGET (ZENVIR)\"\n/* In ISPF V3R2, we no longer need the TLD for anything, so it is\n   not necessary to use the interface module with prefix 'ISR'.\n   Otherwise, in order to get the TLD address, we must make ISPF\n   think we are part of it, hence the use of the ISRQ module.     */\nIf Substr(zenvir,6,3) >= '3.2' Then pgm = 'QUEUE'\n                               Else pgm = 'ISRQ'\n\n/*If Substr(1:1,Sysvar(sysuid),1,1) = 'S' Then Do */\nIf Index(arrgh, 'ALT') \u00ac= 0 Then Do\n   \"DISPLAY PANEL(QPENTRY)\"\n   If Rc \u00ac= 0 Then Exit\n/* \"VGET (QPRFX QVLSR QSBS QICMD)\" */\n   If qcmdnm = 'ISRQ' Then Do\n      Say \"That would be exceedingly stupid.\"\n      Exit 20\n      End\n   If Substr(zenvir,6,3) >= '3.2' Then pgm = qcmdnm\n   If qprfx \u00ac= '' Then qparms = qparms \"DSN(\"qprfx\")\"\n   If qvlsr \u00ac= '' Then qparms = qparms \"CKPT(\"qvlsr\")\"\n   If qsbs  \u00ac= '' Then qparms = qparms \"JES(\"qsbs\")\"\n   If qicmd \u00ac= '' Then qparms = qparms qicmd\n   End\n                                 Else Do\n   qcmdnm = 'QUEUE'\n   \"VPUT (QCMDNM)\"\n   End\n\n/* Queue the command instead of executing it directly, so that the\n   Rexx interpreter is gone.  Otherwise, it tends to get control\n   for ATTNs.\n*/\nQueue \"ISPEXEC SELECT PGM(\"pgm\") PARM(\"qparms\")\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT392/FILE392.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT392", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}