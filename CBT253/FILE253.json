{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220011602000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 5055596, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 70, "INMDSNAM": "CBT.V500.FILE253.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 5055596, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 5055596, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE253.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00T\\x15'", "DS1TRBAL": "b'&\\x1e'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xa0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x01\\xbf\\x00\\x08\\x01\\xc5\\x00\\x02\\x00U'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$DOC": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x96\\x00O\\x00\\x96\\x00O\\x17\\x11\\x00\"\\x00\"\\x00\\x00\\xe2\\xc2\\xc7\\xc3\\xe2\\xc3@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1996-01-04T00:00:00", "modifydate": "1996-01-04T17:11:00", "lines": 34, "newlines": 34, "modlines": 0, "user": "SBGCSC"}, "text": "This is the EXEC library for Jeff Kaplan's collection of software.\n\nThis collection is currently in the condition of 'hodge-podge',\nhowever, there is much useful material here.\n\n    File 252 contains Jeff Kaplan's   SOURCE   library\n    File 253 contains Jeff Kaplan's   EXEC     library\n    File 254 contains Jeff Kaplan's   CNTL     library\n    File 255 contains Jeff Kaplan's   ISPPLIB  library\n    File 256 contains Jeff Kaplan's   ISPTLIB  library\n\nNothing is GUARANTEED to work anywhere else.  The user will have to\n-------\n              \"look and try\".......    However, there is much good\n              code in this collection, including numerous direct\n              calls to SVC 26.\n\n   I am (sort of) an intermediary between Jeff Kaplan and the public.\nHowever, his direct work phone is:  215-633-4614.\n\n   If you can't reach Jeff at work, please try:\n\n          Sam Golob\n          P.O. Box 423\n          Howell, New Jersey  07731-0423\n          908-901-0943\n          718-403-8666   daytime\n\nNote:  Jeff's CNTL library also contains Assembler Source and REXX\n       execs.  Please explore ALL files in this collection.  As of\n       this cut of the tape, I have not sifted through all of Jeff's\n       stuff and straightened it out.  There may also be some\n       duplication of source code or REXX execs.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$#DOC": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\x00\\x00\\x952_\\x00\\x96\\x00O\\x18$\\x00P\\x00%\\x00\\x00\\xe2\\xc2\\xc7\\xc3\\xe2\\xc3@@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "1995-11-21T00:00:00", "modifydate": "1996-01-04T18:24:00", "lines": 80, "newlines": 37, "modlines": 0, "user": "SBGCSC"}, "text": " This is a partial list of some of the things in this collection.\n\n\n     ABENDWTO  -  Somewhat shop-dependent code which shows how\n                  to scan for abends and return codes from\n                  previous steps in the same job.  Then, if\n                  there is a bad return code or abend, save all\n                  the temporary files.\n\n     ABINDEX   -  Shop-dependent.  Shows how to create hiperspace\n                  etc.\n\n     B2C       -  REXX binary-to-character conversion function.\n\n     CATEDIT   -  Update an ICF Catalog in-place using QSAM\n                  PUTX.  Purpose is to convert all files\n                  cataloged to 3480's or 3490's into 3490e's.\n                  (Interesting code.  Has to be authorized nowadays.)\n\n     DYNADSN   -  Dynamically alters dsnames in succeeding\n                  steps of a job.\n\n     DYNATEST  -  JCL to test DYNADSN.\n\n     FINDEXEC  -  EXEC to find where an EXEC is.\n\n     FINDLLIB  -  EXEC to find an ISPLLIB member.\n\n     FINDLOAD  -  EXEC to find a load module in the link list.\n\n     FINDMLIB  -  EXEC to find an ISPF message member.\n\n     FINDPLIB  -  Exec to find an ISPF panel.\n\n     FINDSLIB  -  Exec to find an ISPF skeleton.\n\n     FINDTLIB  -  Exec to find an ISPF table.\n\n     FREEALL   -  TSO Free All command\n\n     GRSUSER   -  TSO Command that can be used from an ISPF\n                  3.4 list to determine who has the file.\n\n     IGDACSMC  -  SMS ACS management class exit that can\n                  dynamically change ACS variables.\n\n     LINKLIST  -  Lists libraries in the link list.\n\n     LPAR      -  (Modify to work in another shop)\n                  Tells CPUID, etc.\n\n     RACFUSER  -  TSO Command to display some RACF user data.\n\n     RACFUSR1  -  Similar to RACFUSER.\n\n     SLEEPSRC  -  SLEEP command from REXX.\n\n     TIMEOUT   -  TSO/E Command to dynamically set TIME=1440\n                  for your id.\n\n     VMFCLEAR  -  TSO/E Clear Screen - like VM.\n\n     XDSL      -\n\n     XDSLSRC   -  External 3.4.  But shop dependent.  See\n                  catalog access code in this member.  Direct\n                  SVC 26 calls.\n\n     XLIBALLD  -  TSO doesn't support SUBSYS= accesses that JCL\n                  supports.  This allows these allocations in TSO.\n                  Used for allocation LIBRARIAN datasets on TSO.\n\n     XLIBALLS  -\n\n     XLIBMEML  -  \"Member Exists\" REXX function.\n\n     XLIBMEMX  -  \"Member Exists\" REXX function.\n\n     XLISTA    -  LISTALC with a better format.\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$CCFASMB": {"ttr": 521, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01Y\\x00\\x00\\x00\\x911\\x8f\\x00\\x95\\x06\\x7f\\x16'\\x00\\xfa\\x00\\x90\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf3@@@\"", "ispf": {"version": "01.89", "flags": 0, "createdate": "1991-11-14T00:00:00", "modifydate": "1995-03-08T16:27:00", "lines": 250, "newlines": 144, "modlines": 0, "user": "TECH103"}, "text": "/*  CA-LIBRARIAN LIB/CCF/ELIPS LIBRARIAN ASSEMBLE/COMPILE REXX EXEC\n    INTERFACE TO ISPF PANEL DIALOG - ( BATCH PROGRAMS - COBOL2 ).\n                                                                      */\n\nTRACE O\n/*     */\nHOUSE_KEEPING:\nADDRESS ISPEXEC\nCMPONLY = 'N'\nJCL.1 = 'CCFCOB2'\nJCL.2 = 'CCFDYL'\nJCL.3 = 'CCFASM'\nJCL.4 = 'CCFRPGIA'\nJCL.5 = 'CCFRPGII'\nJCL.6 = 'CCFOPTII'\nX = MSG(\"OFF\")\nTSOID = SYSVAR(SYSUID)\nACCTCCF = 5200010520000000\nCOBOPT = 'APOST,LIB,RENT,RES,DYNAM,OFFSET,CMPR2'\nPCOBOPT = 'APOST,LIB,RENT,RES,DYNAM,OFFSET,NOCMPR2'\nTSTCAOPT = 'DCR,MMA,MOF,MXR,FDC,PAR,SUB,PFL,XCO,XTI,WSI'\nPRDCAOPT = 'COPT,NOWSI,NODTE,NOFDC,NOMOF,NOPFL,NOSUB,NOXCO,NOXTI'\nACCTSW = 'NO'\nQACOMP = 'N'\nC1 = 1\nC2 = 2\nC3 = 4\nC4 = 5\nCOPYLIB.1 = 'SYS1.TESTCOPY.MASTER'\nCOPYLIB.2 = 'SYS1.TURNCOPY.MASTER'\nCOPYLIB.3 = 'SYS1.RJCTCOPY.MASTER'\nCOPYLIB.4 = 'SYS1.QACOPY.MASTER'\nCOPYLIB.5 = 'SYS1.PRODCOPY.MASTER'\nCOPYLIB.6 = 'SYS1.EMRGCOPY.MASTER'\nCCFLOAD = 'SYS1.TEST.BATCH.LOADLIB'\nEMRGID = SUBSTR(TSOID,1,6)\nIF EMRGID = 'TECH29' THEN DO\n   EMERGSW = 'YES'\n   C1 = 6\n   C2 = 5\n   C3 = 4\n   C4 = 2\n   CCFLOAD = 'SYS1.EMERGNCY.BATCH.LOADLIB'\nEND\n\"CONTROL ERRORS RETURN\"\n\"FTCLOSE\"\n\"VGET (ACCTCDE) PROFILE\"\nIF RC \u00ac= 0 THEN DO\n   ACCTSW = 'YES'\n   ACCTCDE = ACCTCCF\nEND\n\"VGET (CCOPT) PROFILE\"\nIF RC \u00ac= 0 THEN CCOPT = COBOPT\n\"VGET (CAOPT) PROFILE\"\nIF RC \u00ac= 0 THEN CAOPT = TSTCAOPT\n/*\n        M A I N   R O U T I N E   S E C T I O N      */\n/*     */\nDISPLAY_PANEL:\nDO FOREVER\n   ADDRESS ISPEXEC \"DISPLAY PANEL($CCFBPN1)\"\n   SRC = RC\n   IF SRC = 8 THEN LEAVE\n   IF SRC > 8 THEN DO\n      SAY '*** ERROR INVOKING ISPF DIALOG PANEL $CCFBPN1 - RC = 'SRC'.***'\n      EXIT SRC\n   END\n   MASTER = LIBPRJ||'.'||LIBGRP||'.'||LIBTYP\n   CALL CHECK_MASTER_MEMBER\n   IF MODSW = 'NO' THEN ITERATE\n   CTYP = COMPTYP\n   IF CTYP = 1 THEN DO\n      CALL CHECK_COBOL2_NATIVE_FLAG\n      CALL CHECK_OPTIMIZE_FLAG\n      C2P = CCOPT\n      CMPR = POS('NOCMPR2',C2P)\n      IF CMPR = 0 & NATIVE_SW = 'YES' THEN C2P = C2P||',NOCMPR2'\n      IF QACOMP = 'Y' & NATIVE_SW = 'YES' THEN C2P = PCOBOPT\n      IF QACOMP = 'Y' & NATIVE_SW = 'NO' THEN C2P = COBOPT\n   END\n   IF OPTIMIZE_SW = 'YES' THEN DO\n      CTYP = 6\n      C2P = CAOPT\n      IF QACOMP = 'Y' THEN C2P = PRDCAOPT\n   END\n   MVSSYS = 'SYSA'\n   CALL BUILD_COPYBOOK_SEARCH_CHAIN\n   CALL SELECT_COMPILE_JCL\n   IF SKELSW = 'ERROR' THEN ITERATE\n   CALL SELECT_JOB_MESSAGE_TEXT\n   CALL SUBMIT_COMPILE_JCL\n   COMPTYP = ''\n   MEMBER = ''\nEND\nADDRESS ISPEXEC\n\"VPUT (CCOPT) PROFILE\"\n\"VPUT (CAOPT) PROFILE\"\nIF ACCTSW = 'YES' THEN \"VPUT (ACCTCDE) PROFILE\"\nADDRESS TSO\n\"FREE F(\"LIBDD\")\"\n\"FREE F(\"MASTDD\")\"\nEXIT 0\n/*\n        S U B R O U T I N E   S E C T I O N      */\n/*     */\nCHECK_MASTER_MEMBER:\nADDRESS TSO\nMODSW = 'NO'\nLIBDSN = \"'\"MASTER\"(\"MEMBER\")'\"\nLIBDD = LIBALLOC(LIBDSN)\nIF LIBDD = \"ERROR\" THEN DO\n   SAY '*** ALLOCATION ERROR: ('MASTER'('MEMBER'). ***'\n   SAY '*** DYNAMIC ALLOCATION FAILED FOR THE MASTER DATASET - RETRY TASK. ***'\n   SAY '*** COMPB COMPILE SUBTASK CANCELLED. ***'\n   EXIT\nEND\nMASTDD = LIBALLOC(\"'\"MASTER\"'\")\nMASTMEM = XLIBEMEM(MASTDD,MEMBER)\n\"EXECIO 0 DISKR\" MASTDD \"(FINIS\"\nIF MASTMEM = \"\"  THEN DO\n   \"FREE F(\"LIBDD\")\"\n   \"FREE F(\"MASTDD\")\"\n   ADDRESS ISPEXEC\n   ZERRMSG = $CCFA007\n   \"SETMSG MSG($CCFA007)\"\n   RETURN\nEND\nMODSW = 'YES'\nRETURN\n/*     */\nCHECK_COBOL2_NATIVE_FLAG:\nADDRESS TSO\nNATIVE_SW = 'NO'\n\"EXECIO * DISKR\" LIBDD \"(STEM PROGDATA. FINIS\"\nDO I = 1 TO PROGDATA.0\n   NOCMPR2 = POS('NOCMPR2-FLAG',PROGDATA.I)\n   IF NOCMPR2 \u00ac= 0 THEN DO\n      NATIVE_SW = 'YES'\n      LEAVE\n   END\nEND\nRETURN\n/*     */\nCHECK_OPTIMIZE_FLAG:\nOPTIMIZE_SW = 'NO'\nDO I = 1 TO PROGDATA.0\n   OPTFLAG = POS('OPT2-FLAG',PROGDATA.I)\n   IF OPTFLAG \u00ac= 0 THEN DO\n      OPTIMIZE_SW = 'YES'\n      LEAVE\n   END\nEND\nRETURN\n/*     */\nBUILD_COPYBOOK_SEARCH_CHAIN:\nCOPYLB1 = COPYLIB.C1\nCOPYLB2 = COPYLIB.C2\nCOPYLB3 = COPYLIB.C3\nCOPYLB4 = COPYLIB.C4\nRETURN\n/*     */\nSELECT_COMPILE_JCL:\nSKELSW = 'OK'\nSKELJCL = JCL.CTYP\nMASTER = LIBPRJ||'.'LIBGRP||'.'LIBTYP\nLOADLIB = CCFLOAD\nIF EMERGSW = 'YES' THEN DO\n   MASTER = 'SYS1.EMRGSRCE.MASTER'\n   LOADLIB = 'SYS1.EMERGNCY.BATCH.LOADLIB'\n   IF CTYP = 6 THEN C2P = PRDCAOPT\nEND\nIF LOADLIB = 'SYS1.EMERGNCY.BATCH.LOADLIB' THEN DO\n   IF MASTER \u00ac= 'SYS1.EMRGSRCE.MASTER' THEN DO\n      SKELSW = 'ERROR'\n      EMRGMAST = 'SYS1.EMRGSRCE.MASTER'\n      ZERRMSG = $CCFA100\n      ADDRESS ISPEXEC \"SETMSG MSG($CCFA100)\"\n      RETURN\n   END\nEND\nIF CTYP = 1 & CMPONLY = 'Y' THEN SKELJCL = 'CCFCOB2O'\nIF CTYP = 6 & CMPONLY = 'Y' THEN SKELJCL = 'CCFOPTCO'\nIF LIBGRP = 'RJCTSRCE' THEN DO\n   LOADLIB = 'SYS1.REJECT.BATCH.LOADLIB'\n   QACOMP = 'Y'\n   CMPONLY = 'N'\n   IF CTYP = 1 THEN SKELJCL = 'CCFCOBR1'\n   IF CTYP = 6 THEN DO\n      SKELJCL = 'CCFCOBR2'\n      C2P = PRDCAOPT\n   END\nEND\nRETURN\n/*     */\nSELECT_JOB_MESSAGE_TEXT:\nSELECT\n   WHEN SKELJCL = 'CCFASM' THEN COMPMSG = TSOID||'.BAL.ASSEM'\n   WHEN SKELJCL = 'CCFCOB2' THEN COMPMSG = TSOID||'.BATCH.COBII'\n   WHEN SKELJCL = 'CCFCOB2O' THEN COMPMSG = TSOID||'.COBII.NOLINK'\n   WHEN SKELJCL = 'CCFOPTII' THEN COMPMSG = TSOID||'.COB2.OPTII'\n   WHEN SKELJCL = 'CCFOPTCO' THEN COMPMSG = TSOID||'.COBOPT.NOLNK'\n   WHEN SKELJCL = 'CCFDYL' THEN COMPMSG = TSOID||'.DYL280.COMP'\n   WHEN SKELJCL = 'CCFRPGIA' THEN COMPMSG = TSOID||'.RPGIAUTO'\n   WHEN SKELJCL = 'CCFRPGII' THEN COMPMSG = TSOID||'.RPGII.COMP'\n  OTHERWISE COMPMSG = TSOID||'.COMPILE.LINK'\nEND\nRETURN\n/*     */\nSUBMIT_COMPILE_JCL:\nADDRESS ISPEXEC\n\"FTOPEN TEMP\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   ZERRMSG = $CCFA001\n   \"SETMSG MSG($CCFA001)\"\n   RETURN\nEND\n\"FTINCL $CCFJOBC\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   ZERRMSG = $CCFA002\n   \"SETMSG MSG($CCFA002)\"\n   RETURN\nEND\n\"FTINCL\" SKELJCL\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   ZERRMSG = $CCFA003\n   \"SETMSG MSG($CCFA003)\"\n   RETURN\nEND\n\"FTCLOSE\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   ZERRMSG = $CCFA005\n   \"SETMSG MSG($CCFA005)\"\n   RETURN\nEND\n\"VGET ZTEMPF\"\nADDRESS TSO \"SUBMIT '\"ZTEMPF\"'\"\nSRC = RC\nADDRESS ISPEXEC\nIF SRC \u00ac= 0 THEN DO\n   ZERRMSG = $CCFA006\n   \"SETMSG MSG($CCFA006)\"\n   RETURN\nEND\nZERRMSG = $CCFA000\n\"SETMSG MSG($CCFA000)\"\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$CCFASMC": {"ttr": 526, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x1b\\x00\\x00\\x00\\x91\\x19?\\x00\\x95\\x06\\x1f\\x17\\x16\\x00\\xef\\x00w\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf3@@@'", "ispf": {"version": "01.27", "flags": 0, "createdate": "1991-07-12T00:00:00", "modifydate": "1995-03-02T17:16:00", "lines": 239, "newlines": 119, "modlines": 0, "user": "TECH103"}, "text": "/*  CA-LIBRARIAN LIB/CCF/ELIPS LIBRARIAN ASSEMBLE/COMPILE REXX\n    EXEC INTERFACE TO ISPF PANEL DIALOG - ( CICS PROGRAMS- COBOL2 ).\n    ASSEMBLE OR COMPILE FROM CA-LIBRARIAN MASTER DATASETS.            */\n\nTRACE O\n/*     */\nHOUSE_KEEPING:\nADDRESS TSO\nMAPONLY = 'Y'\nINTRTST = 'Y'\nQACOMP = 'N'\nACCTSW = 'NO'\nEMERGSW = 'NO'\nX = MSG(\"OFF\")\nACCTCCF = 5200010520000000\nTSOID = SYSVAR(SYSUID)\nJCL.1 = 'CCFASM'\nJCL.2 = 'CCFBMS'\nJCL.3 = 'CCFCICS2'\nJCL.4 = 'CCFDMS'\nJCL.5 = 'CCFCI2CO'\nJCL.6 = 'CCFTCIC2'\nJCL.7 = 'CCFBMSMO'\nJCL.8 = 'CCFICIC2'\nJCL.9 = 'CCFCICOP'\nJCL.10 = 'CCFCICOI'\nJCL.11 = 'CCFCICOQ'\nJCL.12 = 'CCFCICR1'\nJCL.13 = 'CCFCICR2'\nC1 = 1\nC2 = 2\nC3 = 4\nC4 = 5\nCOPYLIB.1 = 'SYS1.TESTCOPY.MASTER'\nCOPYLIB.2 = 'SYS1.TURNCOPY.MASTER'\nCOPYLIB.3 = 'SYS1.RJCTCOPY.MASTER'\nCOPYLIB.4 = 'SYS1.QACOPY.MASTER'\nCOPYLIB.5 = 'SYS1.PRODCOPY.MASTER'\nCOPYLIB.6 = 'SYS1.EMRGCOPY.MASTER'\nCPYMAST = 'SYS1.TESTCOPY.MASTER'\nEMRGID = SUBSTR(TSOID,1,6)\nIF EMRGID = 'TECH29' THEN DO\n   EMERGSW = 'YES'\n   C1 = 6\n   C2 = 5\n   C3 = 4\n   C4 = 2\n   CPYMAST = 'SYS1.EMRGCOPY.MASTER'\n   CCFLOAD = 'SYS1.EMERGNCY.CICS.LOADLIB'\nEND\nADDRESS ISPEXEC\n\"CONTROL ERRORS RETURN\"\n\"FTCLOSE\"\n\"VGET (ACCTCDE) PROFILE\"\nIF RC \u00ac= 0 THEN DO\n   ACCTSW = 'YES'\n   ACCTCDE = ACCTCCF\nEND\n\"VGET (CCFLOAD) PROFILE\"\nIF RC \u00ac= 0 THEN CCFLOAD = 'SYS1.XXXXX.CICS.LOADLIB'\n/*\n        M A I N   R O U T I N E   S E C T I O N      */\n/*     */\nDISPLAY_PANEL:\nDO FOREVER\n   ADDRESS ISPEXEC \"DISPLAY PANEL($CCFCPN1)\"\n   SRC = RC\n   IF SRC = 8 THEN LEAVE\n   IF SRC > 8 THEN DO\n      SAY '*** ERROR INVOKING ISPF DIALOG PANEL $CCFCPN1 - RC = 'SRC'.***'\n      EXIT SRC\n   END\n   MVSSYS = 'SYSA'\n   MASTER = LIBPRJ||'.'||LIBGRP||'.'||LIBTYP\n   CALL CHECK_MASTER_MEMBER\n   IF MODSW = 'NO' THEN ITERATE\n   CALL CHECK_OPTIMIZE_FLAG\n   CALL BUILD_COPYBOOK_SEARCH_CHAIN\n   CALL ASSIGN_SKELETON_JCL\n   CALL ASSIGN_SKELETON_VARIABLES\n   IF SKELSW = 'ERROR' THEN ITERATE\n   CALL SUBMIT_COMPILE_JCL\n   MEMBER = ''\n   COMPTYP = ''\nEND\nADDRESS ISPEXEC\nIF ACCTSW = 'YES' THEN \"VPUT (ACCTCDE) PROFILE\"\nIF EMERGSW = 'NO' THEN \"VPUT (CCFLOAD) PROFILE\"\nADDRESS TSO\n\"FREE F(\"LIBDD\")\"\n\"FREE F(\"MASTDD\")\"\nEXIT 0\n/*\n         S U B R O U T I N E   S E C T I O N     */\n/*     */\nCHECK_MASTER_MEMBER:\nADDRESS TSO\nMODSW = 'NO'\nLIBDSN = \"'\"MASTER\"(\"MEMBER\")'\"\nLIBDD = LIBALLOC(LIBDSN)\nIF LIBDD = \"ERROR\" THEN DO\n   SAY '*** ALLOCATION ERROR: ('MASTER'('MEMBER'). ***'\n   SAY '*** DYNAMIC ALLOCATION FAILED FOR THE MASTER DATASET - RETRY TASK. ***'\n   SAY '*** COMPC COMPILE SUBTASK CANCELLED. ***'\n   EXIT\nEND\nMASTDD = LIBALLOC(\"'\"MASTER\"'\")\nMASTMEM = XLIBEMEM(MASTDD,MEMBER)\n\"EXECIO 0 DISKR\" MASTDD \"(FINIS\"\nIF MASTMEM = \"\"  THEN DO\n   \"FREE F(\"LIBDD\")\"\n   \"FREE F(\"MASTDD\")\"\n   ADDRESS ISPEXEC\n   ZERRMSG = $CCFA007\n   \"SETMSG MSG($CCFA007)\"\n   RETURN\nEND\nMODSW = 'YES'\nRETURN\n/*     */\nCHECK_OPTIMIZE_FLAG:\nADDRESS TSO\nOPTIMIZE_SW = 'NO'\n\"EXECIO * DISKR\" LIBDD \"(STEM DATA. FINIS\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** EXECIO READ ERROR: ('MASTER'('MEMBER'). ***'\n   SAY '*** UNABLE TO READ/CHECK LIBRARIAN MASTER MEMBER - RETRY TASK. ***'\n   SAY '*** COMPC COMPILE SUBTASK CANCELLED. ***'\n   EXIT\nEND\nDO I = 1 TO DATA.0\n   OPTFLAG = POS('OPT2-FLAG',DATA.I)\n   IF OPTFLAG \u00ac= 0 THEN DO\n      OPTIMIZE_SW = 'YES'\n      LEAVE\n   END\nEND\nRETURN\n/*     */\nBUILD_COPYBOOK_SEARCH_CHAIN:\nCOPYLB1 = COPYLIB.C1\nCOPYLB2 = COPYLIB.C2\nCOPYLB3 = COPYLIB.C3\nCOPYLB4 = COPYLIB.C4\nRETURN\n/*     */\nASSIGN_SKELETON_JCL:\nCTYP = COMPTYP\nIF COMPTYP = 3 & QACOMP = 'Y' THEN DO\n   IF OPTIMIZE_SW = 'YES' THEN CTYP = 11\n   SKELJCL = JCL.CTYP\n   RETURN\nEND\nIF COMPTYP = 2 & MAPONLY = 'Y' THEN CTYP = 7\nIF COMPTYP = 3 & INTRTST = 'Y' & OPTIMIZE_SW = 'NO' THEN CTYP = 8\nIF COMPTYP = 3 & INTRTST = 'N' & OPTIMIZE_SW = 'YES' THEN CTYP = 9\nIF COMPTYP = 3 & INTRTST = 'Y' & OPTIMIZE_SW = 'YES' THEN CTYP = 10\nSKELJCL = JCL.CTYP\nRETURN\n/*     */\nASSIGN_SKELETON_VARIABLES:\nSKELSW = 'OK'\nLOADLIB = CCFLOAD\nIF EMERGSW = 'YES' THEN DO\n   MASTER = 'SYS1.EMRGSRCE.MASTER'\n   LOADLIB = 'SYS1.EMERGNCY.CICS.LOADLIB'\nEND\nIF LOADLIB = 'SYS1.EMERGNCY.CICS.LOADLIB' THEN DO\n   IF MASTER \u00ac= 'SYS1.EMRGSRCE.MASTER' THEN DO\n      SKELSW = 'ERROR'\n      EMRGMAST = 'SYS1.EMRGSRCE.MASTER'\n      ZERRMSG = $CCFA100\n      ADDRESS ISPEXEC \"SETMSG MSG($CCFA100)\"\n      RETURN\n   END\nEND\nIF LIBGRP = 'RJCTSRCE' THEN DO\n   CPYMAST = 'SYS1.RJCTCOPY.MASTER'\n   LOADLIB = 'SYS1.REJECT.CICS.LOADLIB'\n   IF COMPTYP = 3 THEN DO\n      CTYP = 12\n      IF OPTIMIZE_SW = 'YES' THEN CTYP = 13\n   END\n   SKELJCL = JCL.CTYP\nEND\nSELECT\n   WHEN SKELJCL = 'CCFASM' THEN COMPMSG = TSOID||'.BAL.ASSEM'\n   WHEN SKELJCL = 'CCFBMS' THEN COMPMSG = TSOID||'.BMSMAP.ASSEM'\n   WHEN SKELJCL = 'CCFBMSMO' THEN COMPMSG = TSOID||'.BMSMAP.ONLY'\n   WHEN SKELJCL = 'CCFCICS2' THEN COMPMSG = TSOID||'.CICS.COBII'\n   WHEN SKELJCL = 'CCFCI2CO' THEN COMPMSG = TSOID||'.CICS.COMPILE'\n   WHEN SKELJCL = 'CCFICIC2' THEN COMPMSG = TSOID||'.CICSCOB2.INT'\n   WHEN SKELJCL = 'CCFDMS' THEN COMPMSG = TSOID||'.DMSMAP.ASSEM'\n   WHEN SKELJCL = 'CCFTCIC2' THEN COMPMSG = TSOID||'.CICSCB2.TRN'\n   WHEN SKELJCL = 'CCFCICOP' THEN COMPMSG = TSOID||'.CICS.CMP.OPT'\n   WHEN SKELJCL = 'CCFCICOI' THEN COMPMSG = TSOID||'.CICS.INT.OPT'\n  OTHERWISE COMPMSG = TSOID||'.COMPILE.LINK'\nEND\nRETURN\n/*     */\nSUBMIT_COMPILE_JCL:\nADDRESS ISPEXEC \"FTOPEN TEMP\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   ZERRMSG = $CCFA001\n   ADDRESS ISPEXEC \"SETMSG MSG($CCFA001)\"\n   RETURN\n   END\nADDRESS ISPEXEC \"FTINCL $CCFJOBC\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   ZERRMSG = $CCFA002\n   ADDRESS ISPEXEC \"SETMSG MSG($CCFA002)\"\n   RETURN\n   END\nADDRESS ISPEXEC \"FTINCL\" SKELJCL\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   ZERRMSG = $CCFA003\n   ADDRESS ISPEXEC \"SETMSG MSG($CCFA003)\"\n   RETURN\n   END\nADDRESS ISPEXEC \"FTCLOSE\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   ZERRMSG = $CCFA005\n   RETURN\n   END\nADDRESS ISPEXEC \"VGET ZTEMPF\"\nADDRESS TSO \"SUBMIT '\"ZTEMPF\"'\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   ZERRMSG = $CCFA006\n   RETURN\n   END\nZERRMSG = $CCFA000\nADDRESS ISPEXEC \"SETMSG MSG($CCFA000)\"\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$CCFDB2B": {"ttr": 772, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01J\\x00\\x00\\x00\\x93\\x11/\\x00\\x953/\\x15\"\\x01\\xe8\\x00\\xfd\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf3@@@'", "ispf": {"version": "01.74", "flags": 0, "createdate": "1993-04-22T00:00:00", "modifydate": "1995-11-28T15:22:00", "lines": 488, "newlines": 253, "modlines": 0, "user": "TECH103"}, "text": "/*  REXX EXEC : ( $CCFDB2B ).\n    FUNCTION  : CALLED BY TSO COMMAND APPLICATION TABLE TASK ( DB2B )\n                TO PROVIDE AN ISPF DIALOG PANEL FOR DB2 COBOL2 AND\n                DYLAKOR PROGRAM COMPILE SERVICES FROM LIBRARIAN.\n                                                                      */\n\nTRACE O\n/*     */\nHOUSE_KEEPING:\nADDRESS ISPEXEC\nPACKG = 'Y'\nBIND = 'Y'\nEXPLN = 'YES'\nQACOMP = 'N'\nDB2TYPE = 'BATCH'\nDB2COLL = ''\nDB2OPT = ''\nDB2SYS = 'DSNY'\nDB2S = DB2SYS\nDB2QUAL = 'BUILD'\nDB2NODE = 'DB2Y'\nDB2LOC = 'DB2SYSY'\nDB2VERS = 'SYSS.DB2.V3R1M0.'\nDB2LIB = 'SYS1.DB2.V3R1M0.SDSNLOAD'\nX = MSG(\"OFF\")\nNOMEMB = 'MEMBER NOT FOUND'\nJCL.1 = 'CCFDB2B1'\nJCL.2 = 'CCFDB2B2'\nJCL.3 = 'CCFDB2B3'\nJCL.4 = 'CCFDB2B4'\nJCL.5 = 'CCFDB2B5'\nJCL.6 = 'CCFDB2B6'\nTSOID = SYSVAR(SYSUID)\nACCTCCF = 5200010520000000\nCOBOPT = 'APOST,LIB,RENT,RES,DYNAM,OFFSET,CMPR2'\nPCOBOPT = 'APOST,LIB,RENT,RES,DYNAM,OFFSET,NOCMPR2'\nTSTCAOPT = 'DCR,MMA,MOF,MXR,FDC,PAR,SUB,PFL,XCO,XTI,WSI'\nPRDCAOPT = 'COPT,NOWSI,NODTE,NOFDC,NOMOF,NOPFL,NOSUB,NOXCO,NOXTI'\nCLASS = 'C'\nMVS = 'SYSA'\nEMERGSW = 'NO'\nACCTSW = 'NO'\nASMLIB = 'SYSS.TESTCCF.DYLDB2.ASMLIB'\nDBRMLIB = TSOID'.USER.DBRMLIB'\nGRANTPDS = 'SYSS.TESTCCF.GRANT.CNTLLIB'\nPARMLIB = 'SYSS.TESTCCF.DB2.TURNOVER.PARMLIB'\nDB2CNTL = SYSDSN(\"'\"PARMLIB\"'\")\nIF DB2CNTL = 'DATASET NOT FOUND' THEN DO\n   SAY '*** PARMLIB ERROR: DATASET NOT FOUND FOR ('PARMLIB'). ***'\n   SAY '*** CCF DB2B EXEC TASK CANCELLED - RC = '028'. ***'\n   EXIT 028\nEND\nC1 = 1\nC2 = 2\nC3 = 4\nC4 = 5\nD1 = 1\nD2 = 2\nD3 = 4\nD4 = 5\nCOPYLIB.1 = 'SYS1.TESTCOPY.MASTER'\nCOPYLIB.2 = 'SYS1.TURNCOPY.MASTER'\nCOPYLIB.3 = 'SYS1.RJCTCOPY.MASTER'\nCOPYLIB.4 = 'SYS1.QACOPY.MASTER'\nCOPYLIB.5 = 'SYS1.PRODCOPY.MASTER'\nCOPYLIB.6 = 'SYS1.EMRGCOPY.MASTER'\nCCFLOAD = 'SYS1.TEST.BATCH.LOADLIB'\nEMRGID = SUBSTR(TSOID,1,6)\nIF EMRGID = 'TECH29' THEN DO\n   EMERGSW = 'YES'\n   EXPLN = 'NO'\n   CLASS = 'P'\n   MVS = 'SYSA'\n   C1 = 6\n   C2 = 5\n   C3 = 4\n   C4 = 2\n   D1 = 6\n   D2 = 5\n   D3 = 4\n   D4 = 2\n   DB2SYS = 'DSNA'\n   DB2S = DB2SYS\n   MASTER = 'SYS1.EMRGSRCE.MASTER'\n   DBRMLIB = 'SYSS.EMRG.BATCH.DBRMLIB'\n   CCFLOAD = 'SYS1.EMERGNCY.BATCH.LOADLIB'\nEND\n\"CONTROL ERRORS RETURN\"\n\"FTCLOSE\"\n\"VGET (ACCTCDE) PROFILE\"\nIF RC \u00ac= 0 THEN DO\n   ACCTSW = 'YES'\n   ACCTCDE = ACCTCCF\nEND\n\"VGET (DB2OPT) PROFILE\"\nIF RC \u00ac= 0 THEN DB2OPT = COBOPT\n\"VGET (CADOPT) PROFILE\"\nIF RC \u00ac= 0 THEN CADOPT = TSTCAOPT\n/*     */\nDISPLAY_MAIN_PANEL:\nDO FOREVER\n   ADDRESS ISPEXEC \"DISPLAY PANEL($CCFBPN2)\"\n   SRC = RC\n   IF SRC = 8 THEN LEAVE\n   IF SRC > 8 THEN DO\n      SAY '*** ERROR INVOKING ISPF DIALOG PANEL ( $CCFBPN2 ). ***'\n      SAY '*** CCF DB2B EXEC TASK CANCELLED - RC = 'SRC'. ***'\n      EXIT SRC\n   END\n   MASTER = LIBPRJ||'.'||LIBGRP||'.'||LIBTYP\n   CALL CHECK_MASTER_MEMBER\n   IF MODSW = 'NO' THEN ITERATE\n   DB2SYS = DB2S\n   IF DB2SYS = 'DB2T' | DB2SYS = 'DB2P' THEN DO\n      DB2NODE = DB2SYS\n      DB2VERS = 'SYSS.DB2.V2R3M0.'\n      DB2LIB = 'SYS1.DB2.V2R3M0.DSNLOAD'\n   END\n   DB2RUNLB = DB2VERS||DB2NODE'.RUNLIB.LOAD'\n   IF COMPTYP = 4 THEN DO\n      CALL DYLAKOR_COMPILE\n      IF QACOMP = 'Y' THEN DO\n         RECORD = MEMBER DB2PLAN DB2TYPE TSOID DB2SYS DB2QUAL DB2VERS DB2NODE\n         CALL BUILD_TURNOVER_PARMS\n         IF WOMSG = 'YES' THEN ITERATE\n         INTERPRET CALL LABEL\n         IF WRITESW = 'ERROR' THEN CALL PARMLIB_WRITE_ERROR\n      END\n      COMPTYP = ''\n      MEMBER = ''\n      ITERATE\n   END\n   CTYP = COMPTYP\n   DB2PLAN = DB2COLL\n   LOADLIB = CCFLOAD\n   MASTER = LIBPRJ||'.'||LIBGRP||'.'||LIBTYP\n   CALL CHECK_GRANT_CNTLLIB\n   IF CTYP = 1 THEN DO\n      CALL CHECK_COBOL2_NATIVE_FLAG\n      CALL CHECK_OPTIMIZE_FLAG\n      C2P = DB2OPT\n      CMPR = POS('NOCMPR2',C2P)\n      IF CMPR = 0 & NATIVE_SW = 'YES' THEN C2P = C2P||',NOCMPR2'\n      IF QACOMP = 'Y' & NATIVE_SW = 'YES' THEN C2P = PCOBOPT\n      IF QACOMP = 'Y' & NATIVE_SW = 'NO' THEN C2P = COBOPT\n   END\n   IF OPTIMIZE_SW = 'YES' THEN DO\n      CTYP = 6\n      C2P = CADOPT\n      IF QACOMP = 'Y' THEN C2P = PRDCAOPT\n   END\n   IF EMERGSW = 'YES' THEN QACOMP = 'N'\n   IF QACOMP = 'Y' THEN DO\n      RECORD = MEMBER DB2COLL DB2TYPE TSOID DB2SYS DB2QUAL DB2VERS DB2NODE\n      CALL BUILD_TURNOVER_PARMS\n      IF WOMSG = 'YES' THEN ITERATE\n      INTERPRET CALL LABEL\n      IF WRITESW = 'ERROR' THEN CALL PARMLIB_WRITE_ERROR\n   END\n   CALL BUILD_COPYBOOK_SEARCH_CHAIN\n   CALL SELECT_COMPILE_JCL\n   IF SKELSW = 'ERROR' THEN ITERATE\n   CALL SUBMIT_COMPILE_JCL\n   COMPTYP = ''\n   MEMBER = ''\n   DB2COLL = ''\nEND\nADDRESS ISPEXEC\n\"VPUT (DB2OPT) PROFILE\"\n\"VPUT (CADOPT) PROFILE\"\nIF ACCTSW = 'YES' THEN \"VPUT (ACCTCDE) PROFILE\"\nADDRESS TSO\n\"FREE F(\"LIBDD\")\"\n\"FREE F(\"MASTDD\")\"\nEXIT 0\n/*\n       S U B R O U T I N E    S E C T I O N     */\n/*     */\nCHECK_MASTER_MEMBER:\nADDRESS TSO\nMODSW = 'NO'\nLIBDSN = \"'\"MASTER\"(\"MEMBER\")'\"\nLIBDD = LIBALLOC(LIBDSN)\nIF LIBDD = \"ERROR\" THEN DO\n   SAY '*** ALLOCATION ERROR: ('MASTER'('MEMBER'). ***'\n   SAY '*** DYNAMIC ALLOCATION FAILED FOR THE MASTER DATASET - RETRY TASK. ***'\n   SAY '*** COMPC COMPILE SUBTASK CANCELLED. ***'\n   EXIT\nEND\nMASTDD = LIBALLOC(\"'\"MASTER\"'\")\nMASTMEM = XLIBEMEM(MASTDD,MEMBER)\n\"EXECIO 0 DISKR\" MASTDD \"(FINIS\"\nIF MASTMEM = \"\"  THEN DO\n   \"FREE F(\"LIBDD\")\"\n   \"FREE F(\"MASTDD\")\"\n   ADDRESS ISPEXEC\n   ZERRMSG = $CCFA007\n   \"SETMSG MSG($CCFA007)\"\n   RETURN\nEND\nMODSW = 'YES'\nRETURN\n/*     */\nDYLAKOR_COMPILE:\nLOADLIB = CCFLOAD\nSKELJCL = 'CCFDYLD1'\nCOMPMSG = TSOID||'.DYL.DB2.COMP'\nCALL GET_DYLAKOR_MODULE_NAMES\nIF ASMSW = 'NO' THEN CALL ASSEMBLE_NAME_ERROR\nIF RPTSW = 'NO' THEN CALL REPORT_NAME_ERROR\nIF LIBGRP = 'RJCTSRCE' THEN LOADLIB = 'SYS1.REJECT.BATCH.LOADLIB'\nIF EMERGSW = 'YES' THEN DO\n   SKELJCL = 'CCFDYLD2'\n   ASMLIB = 'SYSS.EMRG.CCF.DYLDB2.ASMLIB'\nEND\nCALL BUILD_COPYBOOK_SEARCH_CHAIN\nCALL SUBMIT_COMPILE_JCL\nRETURN\n/*     */\nGET_DYLAKOR_MODULE_NAMES:\nASMSW = 'NO'\nRPTSW = 'NO'\nADDRESS TSO \"EXECIO * DISKR\" LIBDD \"(FINIS STEM PROGDATA.\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** INVALID OR MISSING LIBRARIAN MEMBER NAME. ***'\n   SAY '*** CCF DB2B EXEC TASK CANCELLED - RC = '024'. ***'\n   EXIT\nEND\nDO I = 1 TO PROGDATA.0\n   KEY1 = POS('OPTION FREEZE',PROGDATA.I)\n   IF KEY1 \u00ac= 0 THEN DO\n      KEY2 = WORDPOS('FREEZE',PROGDATA.I)\n      INDEXKEY = KEY2 + 1\n      DYLMOD = WORD(PROGDATA.I,INDEXKEY)\n      RPTSW = 'YES'\n   END\n   KEY3 = POS('TSO_ATTACH PLANID',PROGDATA.I)\n   IF KEY3 \u00ac= 0 THEN DO\n      KEY4 = WORDPOS('PLANID',PROGDATA.I)\n      INDEXKEY = KEY4 + 1\n      ASMMOD = WORD(PROGDATA.I,INDEXKEY)\n      DB2PLAN = WORD(PROGDATA.I,INDEXKEY)\n      ASMSW = 'YES'\n   END\nEND\nRETURN\n/*     */\nASSEMBLE_NAME_ERROR:\nERC = 024\nSAY '*** SYNTAX REQUIREMENTS ERROR FOR ('MEMBER') PROGRAM. ***'\nSAY '*** ASSEMBLE MODULE NAME NOT FOUND FROM KEY SYNTAX DATA. ***'\nSAY '*** DB2B EXEC SUBTASK CANCELLED - RC = ('ERC'). ***'\nEXIT ERC\n/*     */\nREPORT_NAME_ERROR:\nERC = 024\nSAY '*** SYNTAX REQUIREMENTS ERROR FOR ('MEMBER') PROGRAM. ***'\nSAY '*** REPORTS MODULE NAME NOT FOUND FROM KEY SYNTAX DATA. ***'\nSAY '*** DB2B EXEC SUBTASK CANCELLED - RC = ('ERC'). ***'\nEXIT ERC\n/*     */\nCHECK_GRANT_CNTLLIB:\nIF EMERGSW = 'YES' THEN RETURN\nGRANT = 'Y'\nGMEMB = SYSDSN(\"'\"GRANTPDS\"(\"DB2PLAN\")'\")\nIF GMEMB = NOMEMB THEN RETURN\nADDRESS TSO\n\"ALLOC DA('\"GRANTPDS\"(\"DB2PLAN\")') F(PARMDD) SHR\"\n\"EXECIO * DISKR PARMDD (FINIS STEM GPARM.\"\n\"FREE F(PARMDD)\"\nDO I = 1 TO GPARM.0\n   IF GPARM.I = DB2SYS THEN GRANT = 'N'\nEND\nRETURN\n/*     */\nCHECK_COBOL2_NATIVE_FLAG:\nADDRESS TSO\nNATIVE_SW = 'NO'\n\"EXECIO * DISKR\" LIBDD \"(STEM PROGDATA. FINIS\"\nDO I = 1 TO PROGDATA.0\n   NOCMPR2 = POS('NOCMPR2-FLAG',PROGDATA.I)\n   IF NOCMPR2 \u00ac=0 THEN DO\n      NATIVE_SW = 'YES'\n      LEAVE\n   END\nEND\nRETURN\n/*     */\nCHECK_OPTIMIZE_FLAG:\nOPTIMIZE_SW = 'NO'\nDO I = 1 TO PROGDATA.0\n   OPTFLAG = POS('OPT2-FLAG',PROGDATA.I)\n   IF OPTFLAG \u00ac= 0 THEN DO\n      OPTIMIZE_SW = 'YES'\n      LEAVE\n   END\nEND\nRETURN\n/*     */\nBUILD_TURNOVER_PARMS:\nIF EMERGSW = 'YES' THEN RETURN\nADDRESS ISPEXEC\nWOMSG = 'NO'\nWOPRFX = SUBSTR(WORKORDR,1,2)\nIF WOPRFX \u00ac= 'WO' THEN DO\n   WOMSG = 'YES'\n   ZERRMSG = $CCFA008\n   \"SETMSG MSG($CCFA008)\"\n   RETURN\nEND\nWOLEN = LENGTH(WORKORDR)\nIF WOLEN < 8 THEN DO\n   WOMSG = 'YES'\n   ZERRMSG = $CCFA009\n   \"SETMSG MSG($CCFA009)\"\n   RETURN\nEND\nADDRESS TSO\nX = MSG(\"OFF\")\n\"FREE F(PARMDD)\"\nLABEL = 'PARMLIB_DATASET_ERROR'\nDSN = SYSDSN(\"'\"PARMLIB\"(\"WORKORDR\")'\")\nIF DSN = 'OK' THEN DO\n   \"ALLOC DA('\"PARMLIB\"(\"WORKORDR\")') F(PARMDD) SHR\"\n   \"EXECIO * DISKR PARMDD (FINIS STEM DATA.\"\n   LABEL = 'REWRITE_TURNOVER_PARMS'\nEND\nIF DSN = NOMEMB THEN DO\n   \"ALLOC DA('\"PARMLIB\"(\"WORKORDR\")') F(PARMDD) SHR\"\n   LABEL = 'WRITE_TURNOVER_PARMS'\nEND\nRETURN\n/*     */\nWRITE_TURNOVER_PARMS:\nIF EMERGSW = 'YES' THEN RETURN\nADDRESS TSO\nWRITESW = 'OK'\n\"DELSTACK\"\nQUEUE RECORD\n\"EXECIO 1 DISKW PARMDD (FINIS\"\nSRC = RC\n\"FREE F(PARMDD)\"\nIF SRC \u00ac= 0 THEN WRITESW = 'ERROR'\nRETURN\n/*     */\nREWRITE_TURNOVER_PARMS:\nIF EMERGSW = 'YES' THEN RETURN\nADDRESS TSO\nWRITESW = 'OK'\nMATCHSW = 'NO'\n\"DELSTACK\"\nDO D = 1 TO DATA.0\n   PMEMBER = WORD(DATA.D,1)\n   IF PMEMBER = MEMBER THEN DO\n      MATCHSW = 'YES'\n      QUEUE RECORD\n      ITERATE\n   END\n   QUEUE DATA.D\nEND\nRCDCNT = QUEUED()\nIF MATCHSW = 'NO' THEN DO\n   RCDCNT = RCDCNT + 1\n   QUEUE RECORD\nEND\n\"EXECIO\" RCDCNT \"DISKW PARMDD (FINIS\"\nSRC = RC\n\"FREE F(PARMDD)\"\nIF SRC \u00ac= 0 THEN WRITESW = 'ERROR'\nRETURN\n/*     */\nBUILD_COPYBOOK_SEARCH_CHAIN:\nCOPYLB1 = COPYLIB.C1\nCOPYLB2 = COPYLIB.C2\nCOPYLB3 = COPYLIB.C3\nCOPYLB4 = COPYLIB.C4\nDCLLIB1 = COPYLIB.D1\nDCLLIB2 = COPYLIB.D2\nDCLLIB3 = COPYLIB.D3\nDCLLIB4 = COPYLIB.D4\nRETURN\n/*     */\nSELECT_COMPILE_JCL:\nSKELSW = 'OK'\nSKELJCL = JCL.CTYP\nIF EMERGSW = 'YES' THEN DO\n   C2P = 'APOST,LIB,RENT,RES,DYNAM,CMPR2'\n   IF NATIVE_SW = 'YES' THEN C2P = 'APOST,LIB,RENT,RES,DYNAM,NOCMPR2'\n   SKELJCL = 'CCFDB2E1'\n   COMPMSG = TSOID||'.DB2E.PKG.BND'\n   IF OPTIMIZE_SW = 'YES' THEN DO\n      SKELJCL = 'CCFDB2E3'\n      COMPMSG = TSOID||'.DB2E.OPT.BND'\n   END\n   LOADLIB = 'SYS1.EMERGNCY.BATCH.LOADLIB'\n   RETURN\nEND\nIF LOADLIB = 'SYS1.EMERGNCY.BATCH.LOADLIB' THEN DO\n   IF MASTER \u00ac= 'SYS1.EMRGSRCE.MASTER' THEN DO\n      SKELSW = 'ERROR'\n      EMRGMAST = 'SYS1.EMRGSRCE.MASTER'\n      ZERRMSG = $CCFA100\n      ADDRESS ISPEXEC \"SETMSG MSG($CCFA100)\"\n      RETURN\n   END\nEND\nIF LIBGRP = 'RJCTSRCE' THEN DO\n   SKELJCL = 'CCFDB2R1'\n   QACOMP = 'N'\n   LOADLIB = 'SYS1.REJECT.BATCH.LOADLIB'\n   C2P = 'APOST,LIB,RENT,RES,DYNAM,CMPR2'\n   IF NATIVE_SW = 'YES' THEN C2P = 'APOST,LIB,RENT,RES,DYNAM,NOCMPR2'\n   COMPMSG = TSOID||'.DB2.RCMP.LNK'\n   RETURN\nEND\nIF CTYP = 1 THEN DO\n   IF GRANT = 'N' THEN SKELJCL = 'CCFDB2B4'\n   IF QACOMP = 'Y' THEN DO\n      C2P = 'APOST,LIB,RENT,RES,DYNAM,CMPR2'\n      IF NATIVE_SW = 'YES' THEN C2P = 'APOST,LIB,RENT,RES,DYNAM,NOCMPR2'\n   END\nEND\nIF CTYP = 3 & GRANT = 'N' THEN SKELJCL = 'CCFDB2B5'\nIF CTYP = 6 & GRANT = 'N' THEN SKELJCL = 'CCFDB2B7'\nSELECT\n   WHEN SKELJCL = 'CCFDB2B1' THEN COMPMSG = TSOID||'.DB2.LNK.PBND'\n   WHEN SKELJCL = 'CCFDB2B2' THEN COMPMSG = TSOID||'.DB2.PACKAGE'\n   WHEN SKELJCL = 'CCFDB2B3' THEN COMPMSG = TSOID||'.DB2.BIND'\n   WHEN SKELJCL = 'CCFDB2B4' THEN COMPMSG = TSOID||'.DB2.LNK.PBNG'\n   WHEN SKELJCL = 'CCFDB2B5' THEN COMPMSG = TSOID||'.DB2.BNDNG'\n   WHEN SKELJCL = 'CCFDB2B6' THEN COMPMSG = TSOID||'.DB2.OBNDG'\n   WHEN SKELJCL = 'CCFDB2B7' THEN COMPMSG = TSOID||'.DB2.OBNDNG'\n  OTHERWISE COMPMSG = TSOID||'.DB2.COMPILE'\nEND\nRETURN\n/*     */\nSUBMIT_COMPILE_JCL:\nADDRESS ISPEXEC\n\"FTOPEN TEMP\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   ZERRMSG = $CCFA001\n   \"SETMSG MSG($CCFA001)\"\n   RETURN\nEND\n\"FTINCL $CCFJOBD\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   ZERRMSG = $CCFA002\n   \"SETMSG MSG($CCFA002)\"\n   RETURN\nEND\n\"FTINCL\" SKELJCL\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   ZERRMSG = $CCFA003\n   \"SETMSG MSG($CCFA003)\"\n   RETURN\nEND\n\"FTCLOSE\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   ZERRMSG = $CCFA005\n   RETURN\nEND\n\"VGET ZTEMPF\"\nADDRESS TSO \"SUBMIT '\"ZTEMPF\"'\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   ZERRMSG = $CCFA006\n   RETURN\nEND\nZERRMSG = $CCFA000\nADDRESS ISPEXEC \"SETMSG MSG($CCFA000)\"\nRETURN\n/*     */\nPARMLIB_DATASET_ERROR:\nSAY '*** PARMLIB DATASET ERROR: 'DSN' ('PARMLIB'). ***'\nSAY '*** PARMLIB RECORD ENTRIES CANNOT BE WRITTEN. ***'\nSAY '*** DB2B EXEC TASK CANCELLED - RETURN CODE ('110'). ***'\nEXIT 110\n/*     */\nPARMLIB_WRITE_ERROR:\nSAY '*** PARMLIB WRITE ERROR: ('PARMLIB'('WORKORDR'). ***'\nSAY '*** PARMLIB RECORD ENTRIES NOT WRITTEN. ***'\nSAY '*** DB2B EXEC TASK CANCELLED - RETURN CODE ('SRC'). ***'\nEXIT SRC\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$CCFDB2C": {"ttr": 1025, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01+\\x00\\x00\\x00\\x93\\x11/\\x00\\x953/\\x15#\\x01\\x81\\x00\\xf5\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf3@@@'", "ispf": {"version": "01.43", "flags": 0, "createdate": "1993-04-22T00:00:00", "modifydate": "1995-11-28T15:23:00", "lines": 385, "newlines": 245, "modlines": 0, "user": "TECH103"}, "text": "/*  REXX EXEC : ( $CCFDB2C ).\n    FUNCTION  : CALLED BY TSO COMMAND APPLICATION TABLE TASK ( DB2C )\n                TO PROVIDE AN ISPF DIALOG PANEL FOR DB2 COBOL2 CICS\n                PROGRAM COMPILE SERVICES WITH CA-LIBRARIAN INTERFACE.\n                                                                      */\nTRACE O\n/*     */\nHOUSE_KEEPING:\nADDRESS TSO\nPACKG = 'Y'\nBIND = 'Y'\nQACOMP = 'N'\nINTRTST = 'Y'\nEXPLN = 'YES'\nDB2SYS = 'DSNY'\nDB2S = DB2SYS\nDB2LOC = 'DB2SYSY'\nDB2TYPE = 'CICS'\nDB2QUAL = 'BUILD'\nDB2NODE = 'DB2Y'\nDB2VERS = 'SYSS.DB2.V3R1M0.'\nDB2LIB = 'SYS1.DB2.V3R1M0.SDSNLOAD'\nDB2COLL = ''\nCLASS = 'C'\nMVS = 'SYSA'\nACCTSW = 'NO'\nEMERGSW = 'NO'\nRJCTSW = 'NO'\nX = MSG(\"OFF\")\nNOMEMB = 'MEMBER NOT FOUND'\nTSOID = SYSVAR(SYSUID)\nACCTCCF = 5200010520000000\nGRANTPDS = 'SYSS.TESTCCF.GRANT.CNTLLIB'\nPARMLIB = 'SYSS.TESTCCF.DB2.TURNOVER.PARMLIB'\nDB2CNTL = SYSDSN(\"'\"PARMLIB\"'\")\nIF DB2CNTL = 'DATASET NOT FOUND' THEN DO\n   SAY '*** PARMLIB ERROR: DATASET NOT FOUND FOR ('PARMLIB'). ***'\n   SAY '*** CCF DB2C EXEC TASK CANCELLED - RC = '028'. ***'\n   EXIT 028\nEND\nC1 = 1\nC2 = 2\nC3 = 4\nC4 = 5\nD1 = 1\nD2 = 2\nD3 = 4\nD4 = 5\nCOPYLIB.1 = 'SYS1.TESTCOPY.MASTER'\nCOPYLIB.2 = 'SYS1.TURNCOPY.MASTER'\nCOPYLIB.3 = 'SYS1.RJCTCOPY.MASTER'\nCOPYLIB.4 = 'SYS1.QACOPY.MASTER'\nCOPYLIB.5 = 'SYS1.PRODCOPY.MASTER'\nCOPYLIB.6 = 'SYS1.EMRGCOPY.MASTER'\nEMRGID = SUBSTR(TSOID,1,6)\nIF EMRGID = 'TECH29' THEN DO\n   EMERGSW = 'YES'\n   CLASS = 'P'\n   MVS = 'SYSA'\n   EXPLN = 'NO'\n   C1 = 6\n   C2 = 5\n   C3 = 4\n   C4 = 2\n   D1 = 6\n   D2 = 5\n   D3 = 4\n   D4 = 2\n   DB2SYS = 'DSNA'\n   DB2S = DB2SYS\n   MASTER = 'SYS1.EMRGSRCE.MASTER'\n   CPYMAST = 'SYS1.EMRGCOPY.MASTER'\n   CCFLOAD = 'SYS1.EMERGNCY.CICS.LOADLIB'\n   LOADLIB = 'SYS1.EMERGNCY.CICS.LOADLIB'\n   COMPMSG = TSOID'.EMRG.DB2.CIC'\n   SKELJCL = 'CCFDB2E2'\nEND\nADDRESS ISPEXEC\n\"CONTROL ERRORS RETURN\"\n\"FTCLOSE\"\n\"VGET (ACCTCDE) PROFILE\"\nIF RC \u00ac= 0 THEN DO\n   ACCTSW = 'YES'\n   ACCTCDE = ACCTCCF\nEND\n\"VGET (CCFLOAD) PROFILE\"\nIF RC \u00ac= 0 THEN CCFLOAD = 'SYS1.XXXXX.CICS.LOADLIB'\n/*\n        M A I N   R O U T I N E   S E C T I O N      */\n/*     */\nDISPLAY_PANEL:\nDO FOREVER\n   ADDRESS ISPEXEC \"DISPLAY PANEL($CCFCPN2)\"\n   SRC = RC\n   IF SRC = 8 THEN LEAVE\n   IF SRC > 8 THEN DO\n      SAY '*** ERROR INVOKING ISPF DIALOG PANEL ( $CCFCPN2 ).***'\n      SAY '*** DB2C EXEC TASK CANCELLED - RC = 'SRC'.***'\n      EXIT SRC\n   END\n   MASTER = LIBPRJ||'.'||LIBGRP||'.'||LIBTYP\n   CALL CHECK_MASTER_MEMBER\n   IF MODSW = 'NO' THEN ITERATE\n   DB2SYS = DB2S\n   IF DB2SYS = 'DB2T' | DB2SYS = 'DB2P' THEN DO\n      DB2NODE = DB2SYS\n      DB2VERS = 'SYSS.DB2.V3R1M0.'\n      DB2LIB = 'SYS1.DB2.V3R1M0.SDSNLOAD'\n   END\n   DB2RUNLB = DB2VERS||DB2NODE'.RUNLIB.LOAD'\n   CALL CHECK_OPTIMIZE_FLAG\n   CTYP = COMPTYP\n   DB2PLAN = DB2COLL\n   IF LIBGRP = 'RJCTSRCE' THEN DO\n      RJCTSW = 'YES'\n      SKELJCL = 'CCFDB2R2'\n      COMPMSG = TSOID'.RJCT.DB2.CIC'\n      CPYMAST = 'SYS1.RJCTCOPY.MASTER'\n      CCFLOAD = 'SYS1.REJECT.CICS.LOADLIB'\n      MASTER = 'SYS1.RJCTSRCE.MASTER'\n      LOADLIB = 'SYS1.REJECT.CICS.LOADLIB'\n   END\n   CALL CHECK_GRANT_CNTLLIB\n   IF QACOMP = 'Y' & EMERGSW = 'NO' THEN DO\n      RECORD = MEMBER DB2COLL DB2TYPE TSOID DB2SYS DB2QUAL DB2VERS DB2NODE\n      CALL BUILD_TURNOVER_PARMS\n      IF WOMSG = 'YES' THEN ITERATE\n      INTERPRET CALL LABEL\n      IF WRITESW = 'ERROR' THEN CALL PARMLIB_WRITE_ERROR\n   END\n   CALL BUILD_COPYBOOK_SEARCH_CHAIN\n   CALL SELECT_COMPILE_JCL\n   IF SKELSW = 'ERROR' THEN ITERATE\n   CALL SUBMIT_COMPILE_JCL\n   COMPTYP = ''\n   MEMBER = ''\n   DB2COLL = ''\nEND\nADDRESS ISPEXEC\nIF ACCTSW = 'YES' THEN \"VPUT (ACCTCDE) PROFILE\"\nIF EMERGSW = 'NO' THEN \"VPUT (CCFLOAD) PROFILE\"\nADDRESS TSO\n\"FREE F(\"LIBDD\")\"\n\"FREE F(\"MASTDD\")\"\nEXIT\n/*\n          S U B R O U T I N E   S E C T I O N        */\n/*     */\nCHECK_MASTER_MEMBER:\nADDRESS TSO\nMODSW = 'NO'\nLIBDSN = \"'\"MASTER\"(\"MEMBER\")'\"\nLIBDD = LIBALLOC(LIBDSN)\nIF LIBDD = \"ERROR\" THEN DO\n   SAY '*** ALLOCATION ERROR: ('MASTER'('MEMBER'). ***'\n   SAY '*** DYNAMIC ALLOCATION FAILED FOR THE MASTER DATASET - RETRY TASK. ***'\n   SAY '*** COMPB COMPILE SUBTASK CANCELLED. ***'\n   EXIT\nEND\nMASTDD = LIBALLOC(\"'\"MASTER\"'\")\nMASTMEM = XLIBEMEM(MASTDD,MEMBER)\n\"EXECIO 0 DISKR\" MASTDD \"(FINIS\"\nIF MASTMEM = \"\"  THEN DO\n   \"FREE F(\"LIBDD\")\"\n   \"FREE F(\"MASTDD\")\"\n   ADDRESS ISPEXEC\n   ZERRMSG = $CCFA007\n   \"SETMSG MSG($CCFA007)\"\n   RETURN\nEND\nMODSW = 'YES'\nRETURN\n/*     */\nCHECK_OPTIMIZE_FLAG:\nADDRESS TSO\nOPTIMIZE_SW = 'NO'\n\"EXECIO * DISKR\" LIBDD \"(STEM DATA. FINIS\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** EXECIO READ ERROR: ('MASTER'('MEMBER'). ***'\n   SAY '*** UNABLE TO READ/CHECK LIBRARIAN MASTER MEMBER - RETRY TASK. ***'\n   SAY '*** DB2C COMPILE SUBTASK CANCELLED. ***'\n   EXIT\nEND\nDO I = 1 TO DATA.0\n   OPTFLAG = POS('OPT2-FLAG',DATA.I)\n   IF OPTFLAG \u00ac= 0 THEN DO\n      OPTIMIZE_SW = 'YES'\n      LEAVE\n   END\nEND\nRETURN\n/*     */\nCHECK_GRANT_CNTLLIB:\nIF EMERGSW = 'YES' THEN RETURN\nGRANT = 'Y'\nGMEMB = SYSDSN(\"'\"GRANTPDS\"(\"DB2PLAN\")'\")\nIF GMEMB = NOMEMB THEN RETURN\nADDRESS TSO\n\"ALLOC DA('\"GRANTPDS\"(\"DB2PLAN\")') F(PARMDD) SHR\"\n\"EXECIO * DISKR PARMDD (FINIS STEM GPARM.\"\n\"FREE F(PARMDD)\"\nDO I = 1 TO GPARM.0\n   IF GPARM.I = DB2SYS THEN GRANT = 'N'\nEND\nRETURN\n/*     */\nBUILD_TURNOVER_PARMS:\nIF EMERGSW = 'YES' THEN RETURN\nADDRESS ISPEXEC\nWOMSG = 'NO'\nWOPRFX = SUBSTR(WORKORDR,1,2)\nIF WOPRFX \u00ac= 'WO' THEN DO\n   WOMSG = 'YES'\n   ZERRMSG = $CCFA008\n   \"SETMSG MSG($CCFA008)\"\n   RETURN\nEND\nWOLEN = LENGTH(WORKORDR)\nIF WOLEN < 8 THEN DO\n   WOMSG = 'YES'\n   ZERRMSG = $CCFA009\n   \"SETMSG MSG($CCFA009)\"\n   RETURN\nEND\nADDRESS TSO\nX = MSG(\"OFF\")\n\"FREE F(PARMDD)\"\nLABEL = 'PARMLIB_DATASET_ERROR'\nDSN = SYSDSN(\"'\"PARMLIB\"(\"WORKORDR\")'\")\nIF DSN = 'OK' THEN DO\n   \"ALLOC DA('\"PARMLIB\"(\"WORKORDR\")') F(PARMDD) SHR\"\n   \"EXECIO * DISKR PARMDD (FINIS STEM DATA.\"\n   LABEL = 'REWRITE_TURNOVER_PARMS'\nEND\nIF DSN = NOMEMB THEN DO\n   \"ALLOC DA('\"PARMLIB\"(\"WORKORDR\")') F(PARMDD) SHR\"\n   LABEL = 'WRITE_TURNOVER_PARMS'\nEND\nRETURN\n/*     */\nWRITE_TURNOVER_PARMS:\nIF EMERGSW = 'YES' THEN RETURN\nADDRESS TSO\nWRITESW = 'OK'\n\"DELSTACK\"\nQUEUE RECORD\n\"EXECIO 1 DISKW PARMDD (FINIS\"\nSRC = RC\n\"FREE F(PARMDD)\"\nIF SRC \u00ac= 0 THEN WRITESW = 'ERROR'\nRETURN\n/*     */\nREWRITE_TURNOVER_PARMS:\nIF EMERGSW = 'YES' THEN RETURN\nADDRESS TSO\nWRITESW = 'OK'\nMATCHSW = 'NO'\n\"DELSTACK\"\nDO D = 1 TO DATA.0\n   PMEMBER = WORD(DATA.D,1)\n   IF PMEMBER = MEMBER THEN DO\n      MATCHSW = 'YES'\n      QUEUE RECORD\n      ITERATE\n   END\n   QUEUE DATA.D\nEND\nRCDCNT = QUEUED()\nIF MATCHSW = 'NO' THEN DO\n   RCDCNT = RCDCNT + 1\n   QUEUE RECORD\nEND\n\"EXECIO\" RCDCNT \"DISKW PARMDD (FINIS\"\nSRC = RC\n\"FREE F(PARMDD)\"\nIF SRC \u00ac= 0 THEN WRITESW = 'ERROR'\nRETURN\n/*     */\nBUILD_COPYBOOK_SEARCH_CHAIN:\nCOPYLB1 = COPYLIB.C1\nCOPYLB2 = COPYLIB.C2\nCOPYLB3 = COPYLIB.C3\nCOPYLB4 = COPYLIB.C4\nDCLLIB1 = COPYLIB.D1\nDCLLIB2 = COPYLIB.D2\nDCLLIB3 = COPYLIB.D3\nDCLLIB4 = COPYLIB.D4\nRETURN\n/*     */\nSELECT_COMPILE_JCL:\nSKELSW = 'OK'\nIF EMERGSW = 'YES' | RJCTSW = 'YES' THEN RETURN\nMASTER = LIBPRJ||'.'LIBGRP||'.'LIBTYP\nCPYMAST = LIBPRJ||'.TESTCOPY.MASTER'\nLOADLIB = CCFLOAD\nIF LOADLIB = 'SYS1.EMERGNCY.CICS.LOADLIB' THEN DO\n   IF MASTER \u00ac= 'SYS1.EMRGSRCE.MASTER' THEN DO\n      SKELSW = 'ERROR'\n      EMRGMAST = 'SYS1.EMRGSRCE.MASTER'\n      ZERRMSG = $CCFA100\n      ADDRESS ISPEXEC \"SETMSG MSG($CCFA100)\"\n      RETURN\n   END\nEND\nIF CTYP = 1 & GRANT = 'Y' THEN DO\n   IF INTRTST = 'Y' & OPTIMIZE_SW = 'NO' THEN SKELJCL = 'CCFDB2C1'\n   IF INTRTST = 'Y' & OPTIMIZE_SW = 'YES' THEN SKELJCL = 'CCFDB2C8'\n   IF INTRTST = 'N' & OPTIMIZE_SW = 'NO' THEN SKELJCL = 'CCFDB2C2'\n   IF INTRTST = 'N' & OPTIMIZE_SW = 'YES' THEN SKELJCL = 'CCFDB2C9'\nEND\nIF CTYP = 1 & GRANT = 'N' THEN DO\n   IF INTRTST = 'Y' & OPTIMIZE_SW = 'NO' THEN SKELJCL = 'CCFDB2C3'\n   IF INTRTST = 'Y' & OPTIMIZE_SW = 'YES' THEN SKELJCL = 'CCFDB2CA'\n   IF INTRTST = 'N' & OPTIMIZE_SW = 'NO' THEN SKELJCL = 'CCFDB2C4'\n   IF INTRTST = 'N' & OPTIMIZE_SW = 'YES' THEN SKELJCL = 'CCFDB2CB'\nEND\nIF CTYP = 2 THEN SKELJCL = 'CCFDB2C5'\nIF CTYP = 3 THEN DO\n   IF GRANT = 'Y' THEN SKELJCL = 'CCFDB2C6'\n   IF GRANT = 'N' THEN SKELJCL = 'CCFDB2C7'\nEND\nSELECT\n   WHEN SKELJCL = 'CCFDB2C1' THEN COMPMSG = TSOID||'.DB2.CICS.IGT'\n   WHEN SKELJCL = 'CCFDB2C2' THEN COMPMSG = TSOID||'.DB2.CICS.GNI'\n   WHEN SKELJCL = 'CCFDB2C3' THEN COMPMSG = TSOID||'.DB2.CICS.ING'\n   WHEN SKELJCL = 'CCFDB2C4' THEN COMPMSG = TSOID||'.DB2.CICS.NGI'\n   WHEN SKELJCL = 'CCFDB2C5' THEN COMPMSG = TSOID||'.DB2.CICS.PKO'\n   WHEN SKELJCL = 'CCFDB2C6' THEN COMPMSG = TSOID||'.DB2.CICS.BGT'\n   WHEN SKELJCL = 'CCFDB2C7' THEN COMPMSG = TSOID||'.DB2.CICS.BNG'\n  OTHERWISE COMPMSG = TSOID||'.DB2.CICS.LNK'\nEND\nRETURN\n/*     */\nSUBMIT_COMPILE_JCL:\nADDRESS ISPEXEC\n\"FTOPEN TEMP\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   ZERRMSG = $CCFA001\n   \"SETMSG MSG($CCFA001)\"\n   RETURN\nEND\n\"FTINCL $CCFJOBD\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   ZERRMSG = $CCFA002\n   \"SETMSG MSG($CCFA002)\"\n   RETURN\nEND\n\"FTINCL\" SKELJCL\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   ZERRMSG = $CCFA003\n   \"SETMSG MSG($CCFA003)\"\n   RETURN\nEND\n\"FTCLOSE\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   ZERRMSG = $CCFA005\n   RETURN\nEND\n\"VGET ZTEMPF\"\nADDRESS TSO \"SUBMIT '\"ZTEMPF\"'\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   ZERRMSG = $CCFA006\n   RETURN\nEND\nZERRMSG = $CCFA000\nADDRESS ISPEXEC \"SETMSG MSG($CCFA000)\"\nRETURN\n/*     */\nPARMLIB_DATASET_ERROR:\nSAY '*** PARMLIB DATASET ERROR: 'DSN' ('PARMLIB'). ***'\nSAY '*** PARMLIB RECORD ENTRIES CANNOT BE WRITTEN. ***'\nSAY '*** DB2C EXEC TASK CANCELLED - RETURN CODE ('110'). ***'\nEXIT 110\n/*     */\nPARMLIB_WRITE_ERROR:\nSAY '*** PARMLIB WRITE ERROR: ('PARMLIB'('WORKORDR'). ***'\nSAY '*** PARMLIB RECORD ENTRIES NOT WRITTEN. ***'\nSAY '*** DB2C EXEC TASK CANCELLED - RETURN CODE ('SRC'). ***'\nEXIT SRC\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$CCFDB2P": {"ttr": 1032, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x951O\\x00\\x951O\\x162\\x00\\xbd\\x00\\xbc\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf3@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1995-11-10T00:00:00", "modifydate": "1995-11-10T16:32:00", "lines": 189, "newlines": 188, "modlines": 0, "user": "TECH103"}, "text": "/*  REXX EXEC : ( $CCFDB2P ).\n    FUNCTION  : CALLED BY TSO COMMAND APPLICATION TABLE TASK ( DB2PC )\n                TO PROVIDE AN ISPF DIALOG PANEL FOR DB2 COBOL2 BATCH\n                AND CICS APPLICATION PROGRAM COMPILE SERVICES FROM A\n                LIBRARIAN MASTER FOR QA AND PRODUCTION CONTROL.\n                                                                      */\n\nTRACE O\n/*     */\nHOUSE_KEEPING:\nADDRESS ISPEXEC\nX = MSG(\"OFF\")\nTSOID = SYSVAR(SYSUID)\nACCTCDE = 5302010530000000\nC2P = 'APOST,LIB,RENT,RES,DYNAM,OFFSET,NOCMPR2'\nEXPLN = 'NO'\nLIBPRJ = 'SYS1'\nLIBGRP = 'QASRCE'\nLIBTYP = 'MASTER'\nJCL.1 = 'CCFDB2Q1'                /* BATCH DB2 SKELETON JCL */\nJCL.2 = 'CCFDB2Q2'                /* CICS DB2 SKELETON JCL */\n/* ***  DB2SUBSYS = 'DSNX DSNA DSNA DB2Q DB2P DB2P' *** */\nDB2SUBSYS = 'DSNX DSNA DSNA DSNX DSNA DSNA'\nRUNLIB.1 = 'SYSS.DB2.V3R1M0.DB2X.RUNLIB.LOAD'\nRUNLIB.2 = 'SYSS.DB2.V2R3M0.RUNLIB.LOAD'\nRUNLIB.3 = 'SYSS.DB2.V2R3M0.RUNLIB.LOAD'\nRUNLIB.4 = 'SYSS.DB2.V3R1M0.DB2Q.RUNLIB.LOAD'\nRUNLIB.5 = 'SYSS.DB2.V3R1M0.DB2P.RUNLIB.LOAD'\nRUNLIB.6 = 'SYSS.DB2.V3R1M0.DB2P.RUNLIB.LOAD'\nDB2LOAD = 'SYS1.DB2.V2R3M0.DSNLOAD'\nAPSLIB = 'SYSS.APS.V5R2M1.COPYLIB'\nFCSLIB = 'SYSS.FCS.V4R5M0.COPYLIB'\nDBRMNODE = 'QA PROD EMRG QA PROD EMRG'\nCNTLNODE = 'QA PROD PROD QA PROD PROD'\nLOADNODE = 'QA PROD EMERGNCY QA PROD EMERGNCY'\nLOADTYPE = 'BATCH CICS'\nDB2QUAL = 'BUILD'\nCLASS = 'P'\nMVS = 'SYSA'\nCOPYLIB.1 = 'SYS1.QACOPY.MASTER'\nCOPYLIB.2 = 'SYS1.PRODCOPY.MASTER'\nCOPYLIB.3 = 'SYS1.TURNCOPY.MASTER'\nCOPYLIB.4 = 'SYS1.EMRGCOPY.MASTER'\n/*     */\nDISPLAY_MAIN_PANEL:\nDO FOREVER\n   ADDRESS ISPEXEC \"DISPLAY PANEL($CCFQPNL)\"\n   SRC = RC\n   IF SRC = 8 THEN LEAVE\n   IF SRC > 8 THEN DO\n      SAY '*** ERROR INVOKING ISPF DIALOG PANEL ( $CCFQPNL ). ***'\n      SAY '*** CCF DB2PC COMPILE MAIN TASK CANCELLED - RC = 'SRC'. ***'\n      EXIT SRC\n   END\n   MASTER = LIBPRJ||'.'||LIBGRP||'.'||LIBTYP\n   CALL CHECK_MASTER_MEMBER\n   IF MODSW = 'NO' THEN ITERATE\n   CTYP = COMPTYP\n   CALL ASSIGN_DB2_PARMS\n   LABEL = 'BUILD_COPYBOOK_SEARCH_CHAIN_'LNODE1\n   INTERPRET CALL LABEL\n   CALL SUBMIT_COMPILE_JCL\n   COMPTYP = ''\n   MEMBER = ''\nEND\nADDRESS TSO\n\"FREE F(\"LIBDD\")\"\n\"FREE F(\"MASTDD\")\"\nEXIT 0\n/*\n       S U B R O U T I N E    S E C T I O N     */\n/*     */\nCHECK_MASTER_MEMBER:\nADDRESS TSO\nMODSW = 'NO'\nLIBDSN = \"'\"MASTER\"(\"MEMBER\")'\"\nLIBDD = LIBALLOC(LIBDSN)\nIF LIBDD = \"ERROR\" THEN DO\n   SAY '*** ALLOCATION ERROR: ('MASTER'('MEMBER'). ***'\n   SAY '*** DYNAMIC ALLOCATION FAILED FOR THE MASTER DATASET - RETRY TASK. ***'\n   SAY '*** DB2PC COMPILE SUBTASK CANCELLED. ***'\n   EXIT\nEND\nMASTDD = LIBALLOC(\"'\"MASTER\"'\")\nMASTMEM = XLIBEMEM(MASTDD,MEMBER)\n\"EXECIO 0 DISKR\" MASTDD \"(FINIS\"\nIF MASTMEM = \"\"  THEN DO\n   \"FREE F(\"LIBDD\")\"\n   \"FREE F(\"MASTDD\")\"\n   ADDRESS ISPEXEC\n   ZERRMSG = $CCFA007\n   \"SETMSG MSG($CCFA007)\"\n   RETURN\nEND\nMODSW = 'YES'\nRETURN\n/*     */\nASSIGN_DB2_PARMS:\nSKELJCL = JCL.CTYP\nDB2SYS = WORD(DB2SUBSYS,LL)\nRUNLIB = RUNLIB.LL\nDNODE1 = WORD(DBRMNODE,LL)\nDNODE2 = WORD(LOADTYPE,CTYP)\nDBRMLIB = 'SYSS.'DNODE1'.'DNODE2'.DBRMLIB'\nCNODE1 = WORD(CNTLNODE,LL)\nBINDPDS = 'SYSS.'CNODE1'.CCF.DB2.BIND.CNTLLIB'\nPACKGPDS = 'SYSS.'CNODE1'.CCF.DB2.PACKAGE.CNTLLIB'\nGRANTPDS = 'SYSS.'CNODE1'.CCF.DB2.GRANT.CNTLLIB'\nLNODE1 = WORD(LOADNODE,LL)\nLNODE2 = WORD(LOADTYPE,CTYP)\nCOMPMSG = 'PC.DB2.'LNODE2'.COMPILE'\nLOADLIB = 'SYS1.'LNODE1'.'LNODE2'.LOADLIB'\nIF DB2SYS = 'DSNX' | DB2SYS = 'DB2Q' | DB2SYS = 'DB2P' THEN DO\n   DB2LOAD = 'SYS1.DB2.V3R1M0.SDSNLOAD'\nEND\nRETURN\n/*     */\nBUILD_COPYBOOK_SEARCH_CHAIN_QA:\nC1 = 1\nC2 = 2\nC3 = 3\nD1 = 1\nD2 = 2\nD3 = 3\nRETURN\n/*     */\nBUILD_COPYBOOK_SEARCH_CHAIN_PROD:\nC1 = 2\nC2 = 1\nC3 = 2\nD1 = 2\nD2 = 1\nD3 = 2\nRETURN\n/*     */\nBUILD_COPYBOOK_SEARCH_CHAIN_EMERGNCY:\nC1 = 4\nC2 = 2\nC3 = 1\nD1 = 4\nD2 = 2\nD3 = 1\nRETURN\n/*     */\nSUBMIT_COMPILE_JCL:\nADDRESS ISPEXEC\nCOPYLB1 = COPYLIB.C1\nCOPYLB2 = COPYLIB.C2\nCOPYLB3 = COPYLIB.C3\nDCLLIB1 = COPYLIB.D1\nDCLLIB2 = COPYLIB.D2\nDCLLIB3 = COPYLIB.D3\n\"FTOPEN TEMP\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   ZERRMSG = $CCFA001\n   \"SETMSG MSG($CCFA001)\"\n   RETURN\nEND\n\"FTINCL $CCFJOBD\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   ZERRMSG = $CCFA002\n   \"SETMSG MSG($CCFA002)\"\n   RETURN\nEND\n\"FTINCL\" SKELJCL\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   ZERRMSG = $CCFA003\n   \"SETMSG MSG($CCFA003)\"\n   RETURN\nEND\n\"FTCLOSE\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   ZERRMSG = $CCFA005\n   RETURN\nEND\n\"VGET ZTEMPF\"\nADDRESS TSO \"SUBMIT '\"ZTEMPF\"'\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   ZERRMSG = $CCFA006\n   RETURN\nEND\nZERRMSG = $CCFA000\nADDRESS ISPEXEC \"SETMSG MSG($CCFA000)\"\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@DRERPRF": {"ttr": 1281, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x911\\x1f\\x00\\x911\\x1f\\x14F\\x018\\x018\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-11-07T00:00:00", "modifydate": "1991-11-07T14:46:00", "lines": 312, "newlines": 312, "modlines": 0, "user": "TECH108"}, "text": "/* REXX **********************************************************/\n/*                                                               */\n/*     PROGRAM NAME: DRERPROF                                    */\n/*                                                               */\n/* DESCRIPTIVE NAME: SLR Dialog profile                          */\n/*                                                               */\n/* Read this before you start editing this profile:              */\n/*                                                               */\n/* - This is a REXX program and REXX syntax rules must be        */\n/*   followed.                                                   */\n/* - The format of each profile variable is:                     */\n/*   variable = value                                            */\n/*   -  Variable is a symbolic name for an option or data set.   */\n/*   -  Value is the value to assign to the profile variable. It */\n/*      can be one or more words, with or without quotes.        */\n/*   -  A value can be continued to the next line by using a     */\n/*      comma as the last character. Example:                    */\n/*      SLRSAMP = 'SLR.LOCAL.SLRSAMP' , /* Customized tables   */*/\n/*                'SLR.V3R3M0.SLRSAMP'  /* SLR delivered tables*/*/\n/* - Variables starting with SLRU are output data sets and       */\n/*   can only contain one data set name. The other variables     */\n/*   beginning with SLR can have up to three data sets specified.*/\n/*   Exception to this rule is the SLRFORM data set which is an  */\n/*   output data set for GDDM ICU formats.                       */\n/* - All data sets, except data base names, must exist before    */\n/*   the SLR dialog is started.                                  */\n/* - The data set names must be fully qualified.                 */\n/* - When you allocate the user data sets, model them after      */\n/*   the corresponding SLR data set.                             */\n/*                                                               */\n/* - Normally, you create one profile for the SLR specialist,    */\n/*   who will perform customization, and one for all other       */\n/*   users. Each user must use their own SLRUTLIB, it cannot     */\n/*   be shared but it can be the same data set as used for the   */\n/*   ISPTABL for example.                                        */\n/*   The SLR specialist should use a SLR specific SLRUTLIB data  */\n/*   set. This data set should be the first data set name set    */\n/*   to variable SLRTLIB. In this way, the end users will only   */\n/*   see the customized SLR ISPF tables and not the shipped ones.*/\n/*                                                        PL79091*/\n/* - Before you start the SLR dialog, you must ensure that the   */\n/*   SLR LINKLIB is in the system link list or allocated to      */\n/*   STEPLIB. The SLR SLREXEC data set must be allcoated to      */\n/*   SYSEXEC or SYSPROC. The SLR SLRCLIST data set must be       */\n/*   allocated to SYSPROC.                                PL79091*/\n/*                                                               */\n/* CHANGE ACTIVITY:                                              */\n/*    Created 90-07-26 for SLR V3R3M0 by UB                      */\n/*    Change 01 91-03-01 Wrong data set for variable ADMCFORM.   */\n/*                       ADMCFORM should be SLRFORM target lib.  */\n/*                       Some documentation added.               */\n/*                       APAR PL79091.                           */\n/*    Change 02 91-05-23 Save of GDDM variable was omitted.      */\n/*                       APAR PL85043.                           */\n/*                                                               */\n/*****************************************************************/\nSignal on syntax                    /* Trap REXX syntax errors   */\nParse Source . . module .           /* Module name               */\n\n/*AAA*************************************************************/\n/* Set data set prefix                                           */\n/* usrpre is the prefix for data sets allocated per user.        */\n/* syspre is the prefix for data sets allocated per SLR system.  */\n/*        Normally the same as usrpre when customizing.          */\n/* slrpre is the prefix for the SLR target data sets.            */\n/*****************************************************************/\nusrpre = Sysvar('SYSPREF')   /* User data set prefix (TSO prefix)*/\nsyspre = Sysvar('SYSPREF')   /* Customized SLR data set prefix   */\nslrpre = 'SYS1.SLR.V3R3M0'   /* SLR data set prefix              */\n\n/*****************************************************************/\n/* Set global options                                            */\n/*****************************************************************/\ndebug = 0                  /* 0 - No debug, 1 - Enable Debug     */\nlogo  = 0                  /* 0 - No SLR logo, 1 - Show SLR logo */\ngddm  = 1                  /* 0 - No GDDM used, 1 - GDDM used    */\n\n/*****************************************************************/\n/* Set language                                                  */\n/*****************************************************************/\nAddress \"ISPEXEC\"  \"VGET ZLANG\"     /* Get ISPF language         */\nIf Translate(zlang) = 'JAPANESE' Then\n  language = 'JAPANESE'             /* Japanese                  */\nElse\n  language = 'ENGLISH'              /* English (also default)    */\n\n/*****************************************************************/\n/* Output ISPF table data set. SLR will concatenate this         */\n/* data set before the SLRTABL data set when reading.            */\n/* Must be one per SLR user.                                     */\n/*****************************************************************/\nslrutlib = usrpre'.USER.CNTLLIB'    /* SLR ISPF tables           */\n\n/*****************************************************************/\n/* Data sets containing local modifications to SLR. They will    */\n/* be concatenated ahead of the corresponding SLR data sets.     */\n/*****************************************************************/\nslruslib = syspre'.SLRCNTL'         /* SLR ISPF skeletons        */\nslrusamp = syspre'.SLRSAMP'         /* User table definitions    */\nslruasm  = syspre'.SLRASM'          /* User table source         */\nslrumacs = syspre'.SLRMACS'         /* User macros               */\nslruclist= syspre'.SLRCLIST'        /* User clists               */\nslrucntl = syspre'.SLRCNTL'         /* User JCL                  */\nslrform  = syspre'.ADMCFORM'        /* User GDDM formats         */\n\n/*****************************************************************/\n/* SLR data bases. You can add your own data bases by adding     */\n/* a new unique data base symbolic name to the SLRDBS list and   */\n/* by assigning the new variable a name.                         */\n/* Note: do may not use MAINFILE as a data base name.            */\n/*****************************************************************/\nslrdbs   = 'REPORTDB SYSTEMDB WORKFILE',  /* List of data bases  */\n           'DEMODB ACCTDB FCASTDB PERFMDB NRDB'\nreportdb = slrpre'.REPORTDB'        /* SLR report data base      */\nsystemdb = slrpre'.SYSTEMDB'        /* SLR system data base      */\nworkfile = slrpre'.WORKFILE'        /* SLR Work data base        */\nacctdb   = slrpre'.ACCTDB'          /* SLR accounting data base  */\nfcastdb  = slrpre'.FCASTDB'         /* SLR forecasting data base */\nperfmdb  = slrpre'.PERFMDB'         /* SLR performance data base */\ndemodb   = slrpre'.DEMODB'          /* SLR demo data base        */\nnrdb     = slrpre'.NRDB'            /* SLR Network Report db     */\n\n/*****************************************************************/\n/* SLR GDDM data sets                                            */\n/*****************************************************************/\nadmgdf   = syspre'.ADMGDF'           /* SLR GDDM ADMGDF          */\nadmcdata = syspre'.ADMCDATA'         /* SLR GDDM ADMCDATA        */\nadmcform = slrpre'.SLRFORM'          /* SLR GDDM formats  PL79091*/\nadmdefs  = slrpre'.SLRCNTL(DREJGDPR)'  /* GDDM nicknames  PL79091*/\nadmsymbl = 'SYS1.GDDMSYM'            /* GDDM symbols      PL79091*/\n\n/*****************************************************************/\n/* SLR sort data sets                                            */\n/*****************************************************************/\nsortlib  = 'SYS1.SORTLIB'           /* SORT load library         */\nsortwsz  = 30                       /* Number of workfile cyls   */\nsortwu   = 'SYSDA'                  /* Workfile unit             */\nsysout   = 'DUMMY'                  /* SORT message output       */\n\n/*****************************************************************/\n/* JCL jobcards                                                  */\n/*****************************************************************/\njobcard1 = \"//\"Userid()\"S JOB (123456,NOBO),'SLR JCL',            \"\njobcard2 = \"//  NOTIFY=\"Userid()\",MSGCLASS=Q,CLASS=A,REGION=6500K \"\njobcard3 = \"//*\"\njobcard4 = \"//*\"\njobcard5 = \"//*\"\n\n/*****************************************************************/\n/* SLR ISPF data sets. Since each user must have their own       */\n/* ISPF table data set for SLR outputs, the customized SLR ISPF  */\n/* table data set should be concatenated to the SLRTLIB to make  */\n/* it available to all SLR users.                                */\n/* Up to three data sets can be concatenated.                    */\n/*****************************************************************/\nslrplib = slrpre'.SLRPANEL'         /* SLR ISPF panels           */\nslrmlib = slrpre'.SLRMLIB'          /* SLR ISPF messages         */\nslrslib = slrpre'.SLRSLIB'          /* SLR ISPF skeletons        */\nslrtlib = syspre'.USER.CNTLLIB' ,   /* Customized SLR ISPF tables*/\n          slrpre'.SLRTABL'          /* SLR ISPF tables           */\n\n/*****************************************************************/\n/* SLR data sets. Up to three data sets may be concatenated.     */\n/*                                                        PL79091*/\n/*****************************************************************/\nslrload = slrpre'.LINKLIB'          /* SLR load modules          */\nslrsamp = slrpre'.SLRSAMP'          /* SLR table & exits (load)  */\nslrmacs = slrpre'.SLRMACS'          /* SLR table macros          */\nslrasm  = slrpre'.SLRASM'           /* SLR table & exits (source)*/\nslrexec = slrpre'.SLREXEC'          /* SLR rexx programs         */\nslrcntl = slrpre'.SLRCNTL'          /* SLR cntl programs         */\nslrclist= slrpre'.SLRCLIST'         /* SLR clist programs        */\nslrdbt  = slrpre'.SLRDBT'           /* SLR data base table ref.  */\nslrdump = 'DUMMY'                   /* SLR dump file. Can be:    */\n                                    /* DUMMY  -  No output       */\n                                    /* *   - Output to terminal  */\n\n/*****************************************************************/\n/*                                                               */\n/*             END OF CUSTOMIZATION FOR SLR                      */\n/*                                                               */\n/*   The rest of the code should not be modified.                */\n/*BBB ************************************************************/\n\n/*****************************************************************/\n/* LIBDEF to table data set                                      */\n/*****************************************************************/\nAddress \"ISPEXEC\" \"CONTROL ERRORS RETURN\"\nCall libdef 'ISPTLIB' slrutlib slrtlib  /* Keylists, cmd tables  */\nCall libdef 'SLRTLIB' slrutlib slrtlib  /* SLR input ISPF tables */\nCall libdef 'SLRTABL' slrutlib          /* SLR output tables     */\n\n/*****************************************************************/\n/* Open Profile ISPF table. If it doesn't exist, create it.      */\n/* The DRETPROF table has one key (PROFVAR) and one data         */\n/* column (PROFVAL).                                             */\n/*****************************************************************/\nAddress \"ISPEXEC\"\n\"TBOPEN  DRETPROF SHARE WRITE LIBRARY(SLRTLIB)\"\n\n/*****************************************************************/\n/* Check return code from TBOPEN                                 */\n/*****************************************************************/\nSelect\n  /***************************************************************/\n  /* Table opened, no action                                     */\n  /***************************************************************/\n  When rc = 0 Then\n    Nop\n\n  /***************************************************************/\n  /* Table does not exist. Create it                             */\n  /***************************************************************/\n  When rc = 8 Then\n    Do\n      \"TBCREATE DRETPROF KEYS(PROFVAR) NAMES(PROFVAL)\",\n      \"  LIBRARY(SLRTABL) SHARE REPLACE\"\n      If debug > 0 Then\n        Call drertrc module' TBCREATE DRETPROF rc = 'rc\n      If rc > 8 Then\n        Do\n          Say 'Cannot create SLR table DRETPROD on data set' slrutlib\n          Say 'Program terminates.'\n          Say zerrlm\n          Exit rc\n        End\n    End\n\n  /***************************************************************/\n  /* Other errors. Issue message                                 */\n  /***************************************************************/\n  When rc > 8 Then\n    Do\n      Say 'Cannot open SLR table DRETPROD on data set' slrutlib slrtlib\n      Say 'Program terminates with rc = 'rc\n      Say zerrlm\n      Exit rc\n    End\n  Otherwise\n    Nop\nEnd\n\n/*****************************************************************/\n/* For all supported SLR variables, update DRETPROF table        */\n/*****************************************************************/\nvl = ,                                  /* GDDM added     PL85043*/\n  'SLRSAMP  SLRUSAMP SLRMACS   SLRUMACS SLRASM   SLRUASM ',\n  'SLRFORM  ADMCFORM ADMCDATA  ADMGDF   ADMDEFS  ADMSYMBL',\n  'SLREXEC  SLRCNTL  SLRUCNTL  SLRMLIB  SLRPLIB  SLRSLIB ',\n  'SLRTLIB  SLRUTLIB SLRMKLB   SLRPKLB  SLRTKLB  SLRSKLB ',\n  'JOBCARD1 JOBCARD2 JOBCARD3  JOBCARD4 JOBCARD5         ',\n  'SORTLIB  SYSOUT   SORTWSZ   SORTWU   GDDM             ',\n  'DEBUG    LANGUAGE SLRDUMP   LOGO     SLRUSLIB         ',\n  'SLRDBT   SLRCLIST SLRUCLIST SLRLOAD  SLRDBS 'slrdbs\n\nDo i = 1 To Words(vl)\n  profvar = Word(vl,i)\n  profval = Translate(Value(profvar))\n  \"TBMOD DRETPROF\"\nEnd\n\n/*****************************************************************/\n/* Save profile                                                  */\n/*****************************************************************/\n\"TBSAVE  DRETPROF LIBRARY(SLRTABL)\"\n\nExit 0\n\n/*****************************************************************/\n/* Handle LIBDEF calls                                           */\n/*                                                               */\n/* Called as:  LIBDEF  dd_name  dsn_names                        */\n/*   dd_name   -  Any name allowed by LIBDEF                     */\n/*   dsn_names -  Any data set names allowed by LIBDEF DATASET   */\n/*                                                               */\n/* If any return code from LIBDEF, issue message and terminate   */\n/*****************************************************************/\nLibdef:\n  Arg dd_name dsn_names\n  ds_names = ''\n  Do i = 1 To Words(dsn_names)\n    ds_names = ds_names \"'\"Word(dsn_names,i)\"'\"\n  End\n\n  Address \"ISPEXEC\" \"LIBDEF \"dd_name\" DATASET ID(\"ds_names\") UNCOND\"\n  If rc > 4 Then\n    Do\n      Say 'ISPF LIBDEF error in SLR DRERPROF exec when trying to'\n      Say 'libdef 'dd_name' to 'ds_names'. LIBDEF return code 'rc\n      Say 'and message 'zerrlm\n      Exit rc\n    End\n\nReturn\n\n/*****************************************************************/\n/* Syntax error discovered                                       */\n/*****************************************************************/\nSyntax:\n  Call drertrc module' Syntax error in 'module' line 'sigl\n  Call drertrc module' Error text: 'Errortext(rc)\n  Call drertrc module' Error line: 'Space(Sourceline(sigl))\n  Say 'Syntax error trapped in: 'module\n  Say 'REXX return code 'rc ' in line 'sigl': 'errortext(rc)\n  Say 'Lines before error line are:'\n  Do i = Max(sigl - 5,1) To sigl\n    Say Right(i,5,'0')': 'Space(Sourceline(i))\n  End\n  Say 'Report problem to your SLR specialist'\n  Exit 20\n\nReturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@EDITPDS": {"ttr": 1287, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x10\\x00\\x00\\x00\\x92(/\\x00\\x92(\\x7f\\x15\\x08\\x00\\x16\\x00\\x07\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf3@@@'", "ispf": {"version": "01.16", "flags": 0, "createdate": "1992-10-08T00:00:00", "modifydate": "1992-10-13T15:08:00", "lines": 22, "newlines": 7, "modlines": 0, "user": "TECH103"}, "text": "/* REXX EDIT PDS MEMBERS MACRO  */\nTRACE O\nADDRESS \"ISPEXEC\"\n\"ISREDIT MACRO\"\n\"VGET OLDSTR SHARED\"\n\"VGET NEWSTR SHARED\"\nIF RC \u00ac= 0 THEN DO\n   SAY '*** MISSING CHANGE FROM STRING OR TO STRING ON COMMAND LINE. ***'\n   SAY '*** EDIT PDS MEMBERS MACRO SUBTASK CANCELLED. ***'\n   EXIT 12\nEND\n\"ISREDIT FIND\" OLDSTR\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   \"ISREDIT CANCEL\"\n   EXIT SRC\nEND\n\"ISREDIT CHANGE\" OLDSTR NEWSTR \"ALL\"\nSRC = RC\n\"ISREDIT RESET\"\n\"ISREDIT END\"\nEXIT SRC\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@LBROWSE": {"ttr": 1289, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\n\\x00\\x00\\x00\\x91\\x16\\x1f\\x00\\x91\\x16O\\tC\\x00\\x0c\\x00\\x07\\x00\\x08\\xd1\\xc5\\xc6\\xc6\\xd2@@@@@'", "ispf": {"version": "01.10", "flags": 0, "createdate": "1991-06-10T00:00:00", "modifydate": "1991-06-13T09:43:00", "lines": 12, "newlines": 7, "modlines": 8, "user": "JEFFK"}, "text": "/* REXX LBBROWSE LAM Support */\naddress \"ISPEXEC\";\n\"ISREDIT MACRO\";\n\"ISREDIT DELETE .ZFIRST .ZLAST\"; /* lbbrowse only, if edit exist file*/\n\"VGET LIBDSN SHARED\";\n\"ISREDIT DEFINE SAVE ALIAS CANCEL\";\n\"ISREDIT DEFINE END  ALIAS CANCEL\";\n\"ISREDIT DEFINE CREATE ALIAS CANCEL\";\n\"ISREDIT DEFINE REPLACE ALIAS CANCEL\";\n\"ISREDIT LBFETCH\" libdsn;\nif RC\u00ac=0 then \"ISREDIT CANCEL\";\nexit 0;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@LIBEPRF": {"ttr": 1291, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x14\\x00\\x00\\x00\\x91\\x15\\x1f\\x00\\x91\\x16\\x1f\\x12&\\x00\\x11\\x00\\x11\\x00\\n\\xd1\\xc5\\xc6\\xc6\\xd2@@@@@'", "ispf": {"version": "01.20", "flags": 0, "createdate": "1991-05-31T00:00:00", "modifydate": "1991-06-10T12:26:00", "lines": 17, "newlines": 17, "modlines": 10, "user": "JEFFK"}, "text": "/* REXX SYS1.TECH.COMMON.EXECLIB LIBE Initial EDIT macro          */\naddress \"TSO\";\n/* Check lib dsnames being edited                                 */\naddress \"ISPEXEC\";\n\"ISREDIT MACRO\";\nif substr(USERID(),1,5) \u00ac= 'OPER5' then exit 0;\n\"VGET (LIBIPRJ,LIBILIB,LIBITYP) PROFILE\"; /* primary dsname */\n\"VGET (LIBIODSN) SHARED\"; /* secondary dsn */\ndsname = space(LIBIPRJ,0)\".\"space(LIBILIB,0)\".\"space(LIBITYP);\nif libiodsn \u00ac= '' then ,\n           dsname=substr(libiodsn,2,length(libiodsn)-2);\nif SUBSTR(dsname,1,13) \u00ac= 'BUILDING.PROD' & ,\n   SUBSTR(dsname,1,13) \u00ac= 'BUILDING.EMRG' then exit 0;\n/* Restrict PDF editor END and SAVE commands                      */\n\"ISREDIT DEFINE END  ALIAS CANCEL\";\n\"ISREDIT DEFINE SAVE ALIAS CANCEL\";\nexit 0;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@LISTALC": {"ttr": 1293, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x07\\x00\\x00\\x00\\x91\\x16O\\x00\\x91\\x16\\x8f\\t'\\x00\\x1b\\x00\\x18\\x00\\x06\\xd1\\xc5\\xc6\\xc6\\xd2@@@@@\"", "ispf": {"version": "01.07", "flags": 0, "createdate": "1991-06-13T00:00:00", "modifydate": "1991-06-17T09:27:00", "lines": 27, "newlines": 24, "modlines": 6, "user": "JEFFK"}, "text": "/* REXX LISTALC function */\naddress \"TSO\";\nparse upper arg ddname ; /* element name */\nif ddname = \"\" then return \"\"; /* exit */\ndummy = outtrap(\"listalc.\"); /* trap lista output */\n\"LISTALC STATUS\"; /* find dsnames per ddname */\ndsnlist = \"\";\ndo  i = 2 to listalc.0;\n       listalc.i = strip(listalc.i); /* remove filler */\nend;\ndo  i = 2 to listalc.0;\n      if listalc.i = \"TERMFILE\" then iterate;\n      if listalc.i = \"NULLFILE\" then iterate;\n      if substr(listalc.i,1,3)=\"JES\" then iterate; /* ignore */\n      if substr(listalc.i,1,4)=\"KEEP\" then iterate; /*status line */\n      statusline = i+1;\n      if word(listalc.statusline,1)=ddname then do;\n           dsnlist = dsnlist listalc.i;\n           do j = i+2 to listalc.0 by 2;\n                statusline = j+1;\n                if substr(listalc.statusline,1,4)\u00ac=\"KEEP\" then leave j;\n                dsnlist = dsnlist listalc.j; /* concat dsname */\n           end;\n           leave i;\n        end;\nend;\nreturn strip(dsnlist);\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@LOGPROF": {"ttr": 1295, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01/\\x00\\x00\\x00\\x91%o\\x00\\x95\\x02\\x1f\\x08F\\x00<\\x01s\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf5@@@'", "ispf": {"version": "01.47", "flags": 0, "createdate": "1991-09-13T00:00:00", "modifydate": "1995-01-21T08:46:00", "lines": 60, "newlines": 371, "modlines": 0, "user": "TECH105"}, "text": "/* REXX EXEC REF (SYS1.TECH.COMMON.EXECLIB)\n   Initiate ISPF/PDF\n   Set ISPF/PDF editor CAPS OFF when editing                        */\nparse upper arg parm;\n/* Address the TSO/E environment                                    */\naddress \"TSO\";\n/* Who are we ??                                                    */\nparse value SYSVAR('sysproc') with '@IKJ' usergroup;\n/* Check for noallocate                                             */\nif parm \u00ac= \"\" then signal restart;\n/* Initiate ISPF/PDF session                                        */\n/* i.e. ISPSTART PANEL(@PDFxxxx)                                    */\n/* NEWAPPL is not defined; use ISPCMDS                              */\nuid=userid();\npart_uid=substr(uid,1,5);\nincl_uid=\"SYSADM1 TECH318 TECH601 TECH262 TECH272 TECH275 TECH277 TECH278\n TECH282\";\n/*\ncvtptr = storage(\"00000010\",4); /* locate llt/smca from cvt */\ncvtsmca = storage(d2x(c2d(cvtptr)+196),4); /* mapping smca */\nsavehi=substr(c2x(cvtsmca),1,2); /* hi order bit is on */\nsmcasid = savehi||d2x(x2d(substr(c2x(cvtsmca),3))+16);\nsmcasid = storage(smcasid,4); /* SMF id */\nif smcasid=\"SYSB\" & part_uid\u00ac=\"TECH0\" & part_uid\u00ac=\"TECH6\" & ,\n    uid\u00ac=\"TECH318\" & uid\u00ac=\"DATA999\" & part_uid\u00ac=\"TECHT\" & ,\n    uid\u00ac=\"TECH321\" & ,\n    part_uid\u00ac=\"TECH1\" & part_uid\u00ac=\"TECH2\" & part_uid\u00ac=\"SYSAD\" then do;\n        \"LOGOFF\"; exit 0; end;\n*/\nif part_uid=\"TECH1\" | substr(uid,1,6)=\"TECH25\" | usergroup = \"IPCS\" then do;\n      \"TIMEOUT\";\n      end;\nno_timeout = wordpos(uid,incl_uid);\nif no_timeout \u00ac= 0 then do;\n      \"TIMEOUT\";\n      end;\nif usergroup = \"IPCS\" then do;\n      \"VMFCLEAR\";\n      say \"Upon receiving the TSOE ready prompt, type and enter\";\n      say \"                      IPCS                          \";\n      say \"Upon receiving the IPCS ready prompt, type and enter\";\n      say \"                     IPCSINIT                       \";\n      say \"After exiting IPCS and the screen is cleared, enter \";\n      say \"                     END                            \";\n      exit 0;\n      end;\nrestart:\nmsgstat = MSG('off');\n\"EXECUTIL HT\";\n\"ISPSTART PANEL(@PDF\"usergroup\")\";\n\"FREE ATTR(ATRLIST)\";\n\"FREE DDNAME(ISPLIST)\";\n\"ATTR ATRLIST RECFM(F B A) LRECL(133) BLKSIZE(1330)\";\n\"ALLOC F(ISPLIST) SYSOUT(T) USING(ATRLIST)\";\naddress \"TSO\" \"FREE F(NOALLOC)\";  /* dummy alloc by logoffon cmd */\nsaverc = rc; /* to reenter pdf */\nif saverc = 0 then signal restart;\n\"EXECUTIL RT\";\nmsgstat = MSG(msgstat);\nexit 0;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@LOGPRSV": {"ttr": 1297, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01,\\x00\\x00\\x00\\x91%o\\x00\\x94\\x13/\\x11S\\x004\\x01s\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf1\\xf0@@@'", "ispf": {"version": "01.44", "flags": 0, "createdate": "1991-09-13T00:00:00", "modifydate": "1994-05-12T11:53:00", "lines": 52, "newlines": 371, "modlines": 0, "user": "TECH110"}, "text": "/* REXX EXEC REF (SYS1.TECH.COMMON.EXECLIB)\n   Initiate ISPF/PDF\n   Set ISPF/PDF editor CAPS OFF when editing                        */\nparse upper arg parm;\n/* Address the TSO/E environment                                    */\naddress \"TSO\";\n/* Who are we ??                                                    */\nparse value SYSVAR('sysproc') with '@IKJ' usergroup;\n/* Check for noallocate                                             */\nif parm \u00ac= \"\" then signal restart;\n/* Initiate ISPF/PDF session                                        */\n/* i.e. ISPSTART PANEL(@PDFxxxx)                                    */\n/* NEWAPPL is not defined; use ISPCMDS                              */\nuid=userid();\npart_uid=substr(uid,1,5);\ncvtptr = storage(\"00000010\",4); /* locate llt/smca from cvt */\ncvtsmca = storage(d2x(c2d(cvtptr)+196),4); /* mapping smca */\nsavehi=substr(c2x(cvtsmca),1,2); /* hi order bit is on */\nsmcasid = savehi||d2x(x2d(substr(c2x(cvtsmca),3))+16);\nsmcasid = storage(smcasid,4); /* SMF id */\nif smcasid=\"SYSB\" & part_uid\u00ac=\"TECH0\" & part_uid\u00ac=\"TECH6\" & ,\n    uid\u00ac=\"TECH318\" & uid\u00ac=\"DATA999\" & part_uid\u00ac=\"TECHT\" & ,\n    part_uid\u00ac=\"TECH1\" & part_uid\u00ac=\"TECH2\" & part_uid\u00ac=\"SYSAD\" then do;\n        \"LOGOFF\"; exit 0; end;\nif part_uid=\"TECH1\" | uid=\"TECH601\" | uid=\"SYSADM1\" | uid=\"TECH318\" | ,\n   usergroup = \"IPCS\" | substr(uid,1,6)=\"TECH25\" then do;\n      \"TIMEOUT\";\n      end;\nif usergroup = \"IPCS\" then do;\n      \"VMFCLEAR\";\n      say \"Upon receiving the TSOE ready prompt, type and enter\";\n      say \"                      IPCS                          \";\n      say \"Upon receiving the IPCS ready prompt, type and enter\";\n      say \"                     IPCSINIT                       \";\n      say \"After exiting IPCS and the screen is cleared, enter \";\n      say \"                     END                            \";\n      exit 0;\n      end;\nrestart:\nmsgstat = MSG('off');\n\"EXECUTIL HT\";\n\"ISPSTART PANEL(@PDF\"usergroup\")\";\n\"FREE ATTR(ATRLIST)\";\n\"FREE DDNAME(ISPLIST)\";\n\"ATTR ATRLIST RECFM(F B A) LRECL(133) BLKSIZE(1330)\";\n\"ALLOC F(ISPLIST) SYSOUT(T) USING(ATRLIST)\";\naddress \"TSO\" \"FREE F(NOALLOC)\";  /* dummy alloc by logoffon cmd */\nsaverc = rc; /* to reenter pdf */\nif saverc = 0 then signal restart;\n\"EXECUTIL RT\";\nmsgstat = MSG(msgstat);\nexit 0;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@PROFILE": {"ttr": 1537, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01[\\x00\\x00\\x00\\x904\\x7f\\x00\\x91%\\x7f\\x16\\x19\\x01s\\x01\\x1f\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf1\\xf0@@@'", "ispf": {"version": "01.91", "flags": 0, "createdate": "1990-12-13T00:00:00", "modifydate": "1991-09-14T16:19:00", "lines": 371, "newlines": 287, "modlines": 0, "user": "TECH110"}, "text": "/* REXX EXEC REF (SYS1.TECH.COMMON.EXECLIB)\n   Allocate TSO/E ISPF/PDF datasets based upon user group\n   Use only with alias logon proc names @IKJ????\n   Set ISPF/PDF editor CAPS OFF when editing                        */\n/* Address the TSO/E environment                                    */\naddress \"TSO\";\n/* Who are we ??                                                    */\nparse value SYSVAR('sysproc') with '@IKJ' usergroup;\nif USERID() = \"IBMUSER\" then usergroup = \"SSUP\";\n/* If native TSO/E service then we are done                         */\nIf usergroup = 'TSOE' then exit 0;\n/* See if re-invocation                                             */\nparse upper arg parm ;\nif parm = \"NOALLOC\" & usergroup = 'TART' then exit 0;\n   else if parm = \"NOALLOC\" then signal noalloc;\n/* Build the usergp to program product cross reference tables       */\n/* Usergrp   product list                                           */\nuser.tart    = \"parth.common\";           /* native TSO/E and ARTH */\nuser.umnt    = \"tech.common\",            /* user table/writer*/\n               \"pdf.v230\",\n               \"ispf.v230\",\n               \"lib.v390\";\nuser.utbl    = \"tech.common\",            /* user table */\n               \"pdf.v230\",\n               \"ispf.v230\",\n               \"lib.v390\";\nuser.uwtr    = \"tech.common\",            /* user writer */\n               \"pdf.v230\",\n               \"ispf.v230\",\n               \"lib.v390\";\nuser.bpdf    = \"tech.common\",            /* basic ispf/pdf  */\n               \"pdf.v230\",\n               \"ispf.v230\",\n               \"sdsf.v110\",\n               \"lib.v390\";\nuser.bart    = \"tech.common\",            /* basic ispf/pdf/ARTH*/\n               \"pdf.v230\",\n               \"ispf.v230\",\n               \"parth.common\",\n               \"sdsf.v110\",\n               \"lib.v390\";\nuser.binf    = \"tech.common\",            /* basic ispf/pdf/INFO*/\n               \"pdf.v230\",\n               \"ispf.v230\",\n               \"info.common\",\n               \"sdsf.v110\",\n               \"lib.v390\";\nuser.xpdf    = \"tech.common\",            /*extended ispf/pdf*/\n               \"pdf.v230\",\n               \"ispf.v230\",\n               \"sdsf.v110\",\n               \"cai.common\",\n               \"libccf.v390\",\n               \"pappl.common\";\nuser.xart    = \"tech.common\",            /*extended ispf/pdf/ARTH*/\n               \"pdf.v230\",\n               \"ispf.v230\",\n               \"sdsf.v110\",\n               \"cai.common\",\n               \"libccf.v390\",\n               \"tarth.common\",\n               \"pappl.common\";\nuser.xinf    = \"tech.common\",            /*extended ispf/pdf/INFO*/\n               \"pdf.v230\",\n               \"ispf.v230\",\n               \"sdsf.v110\",\n               \"cai.common\",\n               \"libccf.v390\",\n               \"info.common\",\n               \"pappl.common\";\nuser.sopr    = \"tech.common\",            /* systems operatn */\n               \"pdf.v230\",\n               \"ispf.v230\",\n               \"sdsf.v110\",\n               \"cai.common\",\n               \"libccf.v390\",\n               \"zeke.v360\";\nuser.ssup    = \"tech.common\",            /* systems support */\n               \"pdf.v320\",\n               \"ispf.v320\",\n               \"sdsf.v131\",\n               \"smpe.v151\",\n               \"racf.v190\",\n               \"hcd.v410\",\n               \"hsm.v250\",\n               \"ismf.v32\",\n               \"rmf.v420\",\n               \"jsx.v220\",\n               \"slr.v320\",\n               \"ipcs.v220\";\n/*             \"cai.common\",\n               \"libccf.v390\",\n               \"budget.v110\",\n               \"xcomm.v221\",\n               \"zeke.v360\",\n               \"mht2.v361\",\n               \"cobolsf.v211\",\n               \"boole.v7a\", */\n/* Build the program product - DDNAME and DSNAME xref tables        */\n/* Product   DDNAMES  DSNAMES                                       */\ntech.common  = \"ISPPLIB  'SYS1.TECH.COMMON.ISPPPLIB'\",\n               \"ISPPLIB  'SYS1.TECH.COMMON.ISPPLIB'\",\n               \"ISPSLIB  'SYS1.TECH.COMMON.ISPSLIB'\",\n               \"ISPMLIB  'SYS1.TECH.COMMON.ISPMLIB'\",\n               \"ISPTLIB  'SYS1.TECH.COMMON.ISPTLIB'\",\n               \"SYSPROC  'SYS1.TECH.COMMON.EXECLIB'\";\n/*             \"ISPLLIB  'SYS1.TECH.COMMON.LOADLIB'\",    */\n/*             \"SYSPROC  'PD.CLIST.LIBRARY'\",   */\nispf.v320    = \"ISPPLIB  'SYS1.ISPF.V3R3M0.ISPPENU'\",\n               \"ISPSLIB  'SYS1.ISPF.V3R3M0.ISPSLIB'\",\n               \"ISPMLIB  'SYS1.ISPF.V3R3M0.ISPMENU'\",\n               \"SYSPROC  'SYS1.ISPF.V3R3M0.ISPEXEC'\",\n               \"ISPTLIB  'SYS1.ISPF.V3R3M0.ISPTENU'\";\n/*             \"ISPLLIB  'ISP.V3R2M0.ISPLOAD'\",  */\npdf.v320     = \"ISPPLIB  'SYS1.PDF.V3R3M0.ISRPENU'\",\n               \"ISPSLIB  'SYS1.PDF.V3R3M0.ISRSENU'\",\n               \"ISPMLIB  'SYS1.PDF.V3R3M0.ISRMENU'\",\n               \"ISPTLIB  'SYS1.PDF.V3R3M0.ISRTLIB'\",\n               \"SYSPROC  'SYS1.PDF.V3R3M0.ISRCLIB'\";\n/*             \"ISPLLIB  'ISR.V3R2M0.ISRLOAD'\", */\nsdsf.v131    = \"ISPPLIB  'SYS1.SDSF.V1R3M2.ISFPLIB'\",\n               \"ISPMLIB  'SYS1.SDSF.V1R3M2.ISFMLIB'\",\n               \"ISPTLIB  'SYS1.SDSF.V1R3M2.ISFTLIB'\";\n/*             \"ISPLLIB  'ISF.V1R3M1.ISFLOAD'\", */\nipcs.v220    = \"ISPPLIB  'SYS1.IPCS.V4R2M0.SBLSPNL0'\",\n               \"SYSPROC  'SYS1.IPCS.V4R2M0.SBLSCLI0'\",\n               \"ISPTLIB  'SYS1.IPCS.V4R2M0.SBLSTBL0'\",\n               \"ISPMLIB  'SYS1.IPCS.V4R2M0.SBLSMSG0'\";\nhsm.v250     = \"ISPPLIB  'SYS1.DFHSM.V2R6M0.DFQPLIB'\",\n               \"ISPMLIB  'SYS1.DFHSM.V2R6M0.DFQMLIB'\",\n               \"ISPTLIB  'SYS1.DFHSM.V2R6M0.DFQTLIB'\";\n/*             \"ISPLLIB  'SYS1.DFQLLIB'\", */\nslr.v320     = \"ISPPLIB  'SYS1.SLR.V3R2M0.SLRPANEL'\",\n               \"ISPMLIB  'SYS1.SLR.V3R2M0.SLRMLIB'\",\n               \"SYSPROC  'SYS1.SLR.V3R2M0.SLRCLIST'\";\njsx.v220     = \"ISPPLIB  'SYS1.JES328X.V2R2M0.ISPPLIB'\",\n               \"SYSPROC  'SYS1.JES328X.V2R2M0.CLIST'\";\nrmf.v420     = \"SYSPROC  'SYS1.RMF.V4R2M1.CLS'\";\nxcomm.v221   = \"ISPLLIB  'SYS3.XCOM.REL221.LOAD'\",\n               \"ISPPLIB  'SYS3.XCOM.REL221.ISPPLIB'\",\n               \"ISPMLIB  'SYS3.XCOM.REL221.ISPMLIB'\",\n               \"SYSPROC  'SYS3.XCOM.REL221.SYSPROC'\";\nmht2.v361    = \"ISPLLIB  'MHT2.MHTRAN2.VER361.LOADLIB'\",\n               \"ISPPLIB  'MHT2.MHTRAN2.VER361.ISPPLIB'\",\n               \"ISPSLIB  'MHT2.MHTRAN2.VER361.ISPSLIB'\",\n               \"ISPMLIB  'MHT2.MHTRAN2.VER361.ISPMLIB'\",\n               \"SYSPROC  'MHT2.MHTRAN2.VER361.CMDPROC'\";\ncai.common   = \"ISPLLIB  'CAI.DISP40.CAILIB'\",\n               \"ISPPLIB  'CAI.DISP40.CAIISPP'\",\n               \"ISPPLIB  'CAI.CAISRC'\",\n               \"ISPSLIB  'CAI.DISP40.CAIISPS'\",\n               \"ISPSLIB  'CAI.CAISRC'\",\n               \"ISPMLIB  'CAI.DISP40.CAIISPM'\",\n               \"SYSPROC  'CAI.DISP40.CAICLIB'\",\n               \"SYSPROC  'CAI.CAISRC'\";\nracf.v190    = \"ISPPLIB  'SYS1.RACF.V1R9M0.HRFPANL'\",\n               \"ISPSLIB  'SYS1.RACF.V1R9M0.HRFSKEL'\",\n               \"ISPMLIB  'SYS1.RACF.V1R9M0.HRFMSG'\",\n               \"SYSPROC  'SYS1.RACF.V1R9M0.HRFCLST'\";\nlibccf.v390  = \"ISPLLIB  'TECH.LIBR39.LOADLIB'\",\n               \"ISPPLIB  'BUILDING.LIBCCF.CCFPLIB'\",\n               \"ISPPLIB  'SYS3.ADRLIBR.REL39.CCFPLIB'\",\n               \"ISPPLIB  'SYS3.ADRLIBR.REL39.ELIPPLIB'\",\n               \"ISPSLIB  'BUILDING.LIBCCF.CCFSLIB'\",\n               \"ISPSLIB  'SYS3.ADRLIBR.REL39.CCFSLIB'\",\n               \"ISPMLIB  'BUILDING.LIBCCF.CCFMLIB'\",\n               \"ISPMLIB  'SYS3.ADRLIBR.REL39.CCFMLIB'\",\n               \"ISPMLIB  'SYS3.ADRLIBR.REL39.ELIPMLIB'\",\n               \"ISPTLIB  'SYS3.ADRLIBR.REL39.CCFTLIB'\",\n               \"ISPTLIB  'SYS3.ADRLIBR.REL39.ELIPTLIB'\",\n               \"SYSPROC  'BUILDING.LIBCCF.EXECLIB'\";\nlib.v390     = \"ISPLLIB  'TECH.LIBR39.LOADLIB'\",\n               \"ISPPLIB  'SYS3.ADRLIBR.REL39.ELIPPLIB'\",\n               \"ISPMLIB  'SYS3.ADRLIBR.REL39.ELIPMLIB'\",\n               \"ISPTLIB  'SYS3.ADRLIBR.REL39.ELIPTLIB'\";\nismf.v32     = \"ISPPLIB  'SYS1.ISMF.V3R3M0.DGTPLIB'\",\n               \"ISPMLIB  'SYS1.ISMF.V3R3M0.DGTMLIB'\",\n               \"ISPSLIB  'SYS1.ISMF.V3R3M0.DGTSLIB'\",\n               \"SYSPROC  'SYS1.ISMF.V3R3M0.DGTCLIB'\",\n               \"ISPTLIB  'SYS1.ISMF.V3R3M0.DGTTLIB'\";\n/*             \"ISPLLIB  'SYS1.DGTLLIB'\", */\nsmpe.v151    = \"ISPPLIB  'SYS1.SMPE.V1R5M0.SGIMPENU'\",\n               \"ISPSLIB  'SYS1.SMPE.V1R5M0.SGIMSENU'\",\n               \"ISPMLIB  'SYS1.SMPE.V1R5M0.SGIMMENU'\",\n               \"ISPTLIB  'SYS1.SMPE.V1R5M0.SGIMTENU'\";\n/*             \"ISPLLIB  'GIM.SGIMLMD0'\", */\nbudget.v110  = \"ISPPLIB  'SYS3.BUDR11.SPFLIB'\",\n               \"ISPMLIB  'SYS3.BUDR11.SPFLIB'\",\n               \"SYSPROC  'SYS3.BUDR11.SPFLIB'\";\ncobolsf.v211 = \"ISPLLIB  'COBOLSF.ECF.V2R1M1.ECFLMD1'\",\n               \"ISPPLIB  'COBOLSF.ECF.V2R1M1.ECFPNL1'\",\n               \"ISPSLIB  'COBOLSF.ECF.V2R1M1.ECFSKL1'\",\n               \"ISPMLIB  'COBOLSF.ECF.V2R1M1.ECFMSG1'\",\n               \"SYSPROC  'COBOLSF.ECF.V2R1M1.ECFCLB1'\";\nzeke.v360    = \"ISPPLIB  'SYS3.ZEKE.ISPPLIB'\",\n               \"ISPMLIB  'SYS3.ZEKE.ISPMLIB'\",\n               \"ISPTLIB  'SYS3.ZEKE.ISPTLIB'\";\nhcd.v410     = \"ISPMLIB  'SYS1.HCD.V4R2M0.SCBDMENU'\",\n               \"ISPPLIB  'SYS1.HCD.V4R2M0.SCBDPENU'\",\n               \"ISPTLIB  'SYS1.HCD.V4R2M0.SCBDTENU'\",\n               \"SYSPROC  'SYS1.HCD.V4R2M0.SCBDCLST'\";\n/*             \"ISPLLIB  'SYS1.SCBDHENU'\", */\n/*             \"ISPLLIB  'SYS1.NUCLEUS'\", */\nboole.v7a    = \"ISPLLIB  'SYS3.BABBAGE.VER7A.BBLOAD'\",\n               \"ISPPLIB  'SYS3.BABBAGE.VER7A.BBPLIB'\",\n               \"ISPSLIB  'SYS3.BABBAGE.VER7A.BBSLIB'\",\n               \"ISPMLIB  'SYS3.BABBAGE.VER7A.BBMLIB'\",\n               \"ISPTLIB  'SYS3.BABBAGE.VER7A.BBTLIB'\",\n               \"PMGTLIB  'SYS3.BABBAGE.VER7A.BBTLIB'\",\n               \"SYSPROC  'SYS3.BABBAGE.VER7A.BBCLIB'\";\npappl.common = \"ISPPLIB  'PAPPL.MIS.COMMON.ISPPPLIB'\",\n               \"ISPPLIB  'PAPPL.MIS.COMMON.ISPPLIB'\",\n               \"SYSPROC  'PAPPL.MIS.COMMON.EXECLIB'\",\n               \"ISPLLIB  'PAPPL.MIS.COMMON.ISPLLIB'\",\n               \"ISPMLIB  'PAPPL.MIS.COMMON.ISPMLIB'\",\n               \"ISPSLIB  'PAPPL.MIS.COMMON.ISPSLIB'\",\n               \"ISPTLIB  'PAPPL.MIS.COMMON.ISPTLIB'\",\n               \"STORAGE  'PAPPL.MIS.COMMON.JCLLIB'\";\nparth.common = \"ISPPLIB  'SYS3.ARTHUR.V252.ARTHUR@@.PANELS'\",\n               \"SYSPROC  'PARTH.ARTHUR@@.PARM'\",\n               \"SYSPROC  'SYS3.ARTHUR.V252.ARTHUR@@.LIB'\",\n               \"SYSPROC  'SYS3.ARTHUR.V252.ARTHUR@@.ADMINLIB'\",\n               \"SYSPROC  'SYS3.ARTHUR.V252.ARTHUR@@.UPDLIB'\",\n               \"SYSPROC  'SYS3.SYSTEMW.V211.WIZARD.CLIST'\",\n               \"SYSPROC  'SYS3.SYSTEMW.V211.WSBUILD.CNTL'\";\ntarth.common = \"ISPPLIB  'SYS3.ARTHUR.V260.ARTHUR@@.PANELS'\",\n               \"SYSPROC  'TARTH.ARTHUR@@.PARM'\",\n               \"SYSPROC  'SYS3.ARTHUR.V260.ARTHUR@@.LIB'\",\n               \"SYSPROC  'SYS3.ARTHUR.V260.ARTHUR@@.ADMINLIB'\",\n               \"SYSPROC  'SYS3.ARTHUR.V260.ARTHUR@@.UPDLIB'\",\n               \"SYSPROC  'SYS3.SYSTW.V2117.WIZARD.CLIST'\",\n               \"SYSPROC  'SYS3.SYSTW.V2117.WSBUILD.CNTL'\";\ninfo.common  = \"ISPPLIB  'INFO.REXX.PANLIB'\",\n               \"SYSPROC  'INFO.REXX.EXEC'\",\n               \"ISPMLIB  'INFO.REXX.MSGLIB'\",\n               \"ISPSLIB  'INFO.REXX.SKELIB'\",\n               \"ISPTLIB  'INFO.REXX.TBLLIB'\";\n/* Status                                                           */\n\"VMFCLEAR\"; /* reset screen and clear */\nsay \"Logon processing 25% complete.\";\n/* Build this users available products list                         */\nproduct_list  = user.usergroup;\n/* Build this users datasets list                                   */\nddname_list = '';\ndo while(product_list \u00ac= '');\n     parse var product_list product_name product_list;\n     specific_datasets = VALUE(product_name);\n     do while(specific_datasets \u00ac= '');\n          parse var specific_datasets ,\n                  ddname dsname specific_datasets;\n          if find(ddname_list,ddname) = 0 then do; /*new ddname*/\n                  ddname_list = ddname_list ddname;\n                  ddname.ddname = '';\n                  end;\n          ddname.ddname = ddname.ddname dsname;\n     end;\nend;\nalloc_ddname_list = ddname_list;\n/* Free all required DDNAMEs                                        */\nmsgstat = MSG('off');\n\"FREE DDNAME(\"ddname_list\")\";\nmsgstat = MSG(msgstat);\n/* Status                                                           */\nsay \"Logon processing 50% complete.\";\n/* Adjust datasets so that personal PDS is first in conct*/\n/* only if this is MIS user                              */\nif usergroup = \"XPDF\" | usergroup = \"XART\" | usergroup = \"XINF\" ,\n   usergroup = \"SOPR\" | usergroup = \"SSUP\" then do;\n      ddname.isptlib = \"'\"USERID()\".USER.CNTLLIB'\" ddname.isptlib;\n      ddname.ispplib = \"'\"USERID()\".USER.CNTLLIB'\" ddname.ispplib;\n      ddname.ispmlib = \"'\"USERID()\".USER.CNTLLIB'\" ddname.ispmlib;\n      ddname.ispslib = \"'\"USERID()\".USER.CNTLLIB'\" ddname.ispslib;\n      ddname.sysproc = \"'\"USERID()\".USER.CNTLLIB'\" ddname.sysproc;\n   end;\n/* Allocate required datasets                                       */\ndo while(ddname_list \u00ac= '');\n     parse var ddname_list ddname ddname_list;\n     msgstat = MSG('off');\n     \"ALLOCATE DDNAME(\"ddname\") DSNAME(\"ddname.ddname\") SHR\";\n     allocrc = rc; /* Save rc */\n     msgstat = MSG(msgstat);\n     if allocrc \\= 0 then do;\n          templist = '';\n          dsncount = WORDS(ddname.ddname);\n          do index = 1 to dsncount;\n               tempdsn = word(ddname.ddname,index);\n               listres = LISTDSI(tempdsn);\n               if listres <= 4 then do; /* dsn exists */\n                    templist = templist tempdsn;\n                    end;\n                  else do;\n                    say \"Unable to access dataset\" tempdsn;\n                    end;\n               end;\n               if templist \\= '' then do; /* ok to alloc again */\n                   ddname.ddname = templist;\n                   msgstat = MSG('off');\n                  \"ALLOC DDNAME(\"ddname\") DSNAME(\"ddname.ddname\") SHR\";\n                  allocrc = rc; /* Save rc */\n                  msgstat = MSG(msgstat);\n                  if allocrc \\= 0 then do;\n                       say \"Recursive allocation failure\";\n                       say \"DDNAME is\" ddname;\n                       say \"DSNAME is\" ddname.ddname;\n                       end;\n                  end;\n          end;\nend;\n/* Status                                                           */\nsay \"Logon processing 75% complete.\";\n/* Allocate ISPF user profile dataset                               */\nmsgstat = MSG('off');\n\"FREE DDNAME(ISPPROF)\";\nmsgstat = MSG(msgstat);\n\"ALLOCATE DDNAME(ISPPROF) DSNAME('\"USERID()\".USER.CNTLLIB') SHR\";\n/* Allocate ISPF and program product table output datasets          */\nif WORDPOS('ISPTABL',alloc_ddname_list) = 0 then do;\n    msgstat = MSG('off');\n    \"FREE DDNAME(ISPTABL)\";\n    msgstat = MSG(msgstat);\n    \"ALLOCATE DDNAME(ISPTABL) DSNAME('\"USERID()\".USER.CNTLLIB') SHR\";\nend;\n/* If native TSO/E service then we are done                         */\nIf usergroup = 'TART' then exit 0;\n/* If SSUP group then do some extra allocations                     */\nif usergroup = 'SSUP' then do;\n    msgstat = MSG('off');\n    \"FREE DDNAME(SMPTABL)\";\n    msgstat = MSG(msgstat);\n    \"ALLOCATE DDNAME(SMPTABL) DSNAME('\"USERID()\".USER.CNTLLIB') SHR\";\n    \"TIMEOUT\"; /* set TIME=1440 dynamically */\nend;\n/* Initiate ISPF/PDF session                                        */\n/* i.e. ISPSTART PANEL(@xxxxPRM)                                    */\n/* NEWAPPL is not defined; use ISPCMDS                              */\n/* Panels are @BPDFPRM, @XPDFPRM, @SOPRPRM, @SSUPPRM                */\nnoalloc:\nselect;\n   when usergroup = 'UMNT' then nop;\n   when usergroup = 'UTBL' then nop;\n   when usergroup = 'UWTR' then nop;\n   when usergroup = 'BPDF' then nop;\n   when usergroup = 'BART' then usergroup = 'BPDF';\n   when usergroup = 'BINF' then usergroup = 'BPDF';\n   when usergroup = 'XPDF' then nop;\n   when usergroup = 'XART' then usergroup = 'XPDF';\n   when usergroup = 'XINF' then usergroup = 'XPDF';\n   when usergroup = 'SOPR' then nop;\n   when usergroup = 'SSUP' then nop;\n   otherwise nop;\nend;\nmsgstat = MSG('off');\n\"EXECUTIL HT\";\nselect;\n   when (usergroup=\"UTBL\") then ,\n          \"ISPSTART PANEL(@\"usergroup\"PRM) OPT(UTBL)\";\n   when (usergroup=\"UWTR\") then ,\n          \"ISPSTART PANEL(@\"usergroup\"PRM) OPT(UWTR)\";\n   otherwise ,\n          \"ISPSTART PANEL(@PDF\"usergroup\")\";\nend;\n\"FREE ATTR(ATRLIST)\";\n\"FREE DDNAME(ISPLIST)\";\n\"ATTR ATRLIST RECFM(F B A) LRECL(133) BLKSIZE(1330)\";\n\"ALLOC F(ISPLIST) SYSOUT(T) USING(ATRLIST)\";\naddress \"TSO\" \"FREE F(NOALLOC)\";  /* dummy alloc by logoffon cmd */\nsaverc = rc; /* to reenter pdf */\nif saverc = 0 then signal noalloc;\n\"EXECUTIL RT\";\nmsgstat = MSG(msgstat);\nexit 0;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@UTBLMNT": {"ttr": 1544, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x00\\x00\\x00\\x91\\x17\\x9f\\x00\\x92\\x05\\x8f\\x16\\x12\\x00\\x1a\\x00\\x0b\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf3@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "1991-06-28T00:00:00", "modifydate": "1992-02-27T16:12:00", "lines": 26, "newlines": 11, "modlines": 0, "user": "TECH103"}, "text": "/* REXX User Table/Writer Maintenance Support */\ntrace o;\naddress \"ISPEXEC\";\n\"VGET (LIBIPRJ LIBILIB LIBITYP) PROFILE\"; /* vars */\nsrc = rc\nif src = 0 then do      /* save PROFILE vars for restore */\n   LIBPROJ = LIBIPRJ\n   LIBGRP = LIBILIB\n   LIBTYPE = LIBITYP\nend;\nlibiprj = \"SYS1\";      /* hlq */\nlibilib = \"TABLE\";     /* mlq */\nlibityp = \"MASTER\";    /* llq */\nlibislsl = \"Q\";        /* quick list */\nlibicdyn = \"Y\";        /* delete confirm */\n\"VPUT (LIBIPRJ LIBILIB LIBITYP LIBISLSL LIBICDYN) PROFILE\"; /* vars */\n\"CONTROL NONDISPL ENTER\";    /* skip first panel */\n\"SELECT PGM(ELIPS)\";         /* NEWAPPL(LIB@) NEWPOOL PARM(RETURN)\" */\n\"VPUT (LIBIPRJ LIBILIB LIBITYP LIBISLSL LIBICDYN) PROFILE\";\nif src = 0 then do           /* restore PROFILE vars if exist */\n   LIBIPRJ = LIBPROJ\n   LIBILIB = LIBGRP\n   LIBITYP = LIBTYPE\n   \"VPUT (LIBIPRJ LIBILIB LIBITYP) PROFILE\";\nend;\nexit 0;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@UWTRMNT": {"ttr": 1546, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x91\\x17\\x9f\\x00\\x92\\x05\\x8f\\x16\\x15\\x00\\x1a\\x00\\x0b\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf3@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1991-06-28T00:00:00", "modifydate": "1992-02-27T16:15:00", "lines": 26, "newlines": 11, "modlines": 0, "user": "TECH103"}, "text": "/* REXX User Table/Writer Maintenance Support */\ntrace o;\naddress \"ISPEXEC\";\n\"VGET (LIBIPRJ LIBILIB LIBITYP) PROFILE\"; /* vars */\nsrc = rc\nif src = 0 then do      /* save PROFILE vars for restore */\n   LIBPROJ = LIBIPRJ\n   LIBGRP = LIBILIB\n   LIBTYPE = LIBITYP\nend;\nlibiprj = \"SYS1\";      /* hlq */\nlibilib = \"WRITER\";     /* mlq */\nlibityp = \"MASTER\";    /* llq */\nlibislsl = \"Q\";        /* quick list */\nlibicdyn = \"Y\";        /* delete confirm */\n\"VPUT (LIBIPRJ LIBILIB LIBITYP LIBISLSL LIBICDYN) PROFILE\"; /* vars */\n\"CONTROL NONDISPL ENTER\";    /* skip first panel */\n\"SELECT PGM(ELIPS)\";         /* NEWAPPL(LIB@) NEWPOOL PARM(RETURN)\" */\n\"VPUT (LIBIPRJ LIBILIB LIBITYP LIBISLSL LIBICDYN) PROFILE\";\nif src = 0 then do           /* restore PROFILE vars if exist */\n   LIBIPRJ = LIBPROJ\n   LIBILIB = LIBGRP\n   LIBITYP = LIBTYPE\n   \"VPUT (LIBIPRJ LIBILIB LIBITYP) PROFILE\";\nend;\nexit 0;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ABRTLMS": {"ttr": 1548, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x95\\x17?\\x00\\x95\\x17?\\x15G\\x00\\x8b\\x00\\x8a\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf3@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1995-06-22T00:00:00", "modifydate": "1995-06-22T15:47:00", "lines": 139, "newlines": 138, "modlines": 0, "user": "TECH103"}, "text": "/*   REXX EXEC : ( ABRTLMS )\n     FUNCTION  : BUILDS THE SYSIN FOR THE TLMS VMF UPDATE TO SCRATCH\n                 TAPES HELD BY THE DAILY AND WEEKLY FDRABR SYSTEM\n                 DASD VOLUME BACKUPS.\n     INPUT     : ABRMAP OUTPUT DASD DATASET CREATED BY THE FDRABRCM\n                 UTILITY ( PURGE BACKUP SIMULATE ) COMMAND.\n     OUTPUT    : &USERID.USER.CNTLLIB:\n                 PDS MEMBER=(ABRTLMSI)  ---> INPUT TO ABRPURG4 JOB\n                 PDS MEMBER=(ABRERRLG)  ---> ERRLOG FROM ABRPURG2 JOB\n     REFERENCE : ALL JOBS TO BE SUBMITTED RESIDE IN THE FOLLOWING PDS:\n                 DSN=(SYSS.TECH.COMMON.CNTLLIB).\n                 JOB 1 = ABRPURG1    ( SIMULATE RUN )\n                 JOB 2 = ABRPURG2    ( EXECUTES THIS REXX EXEC )\n                 JOB 3 = ABRPURG3    ( PURGE ABR CATALOG ENTRIES )\n                 JOB 4 = ABRPURG4    ( UPDATES THE TLMS VMF ENTRIES ).\n                                                                      */\nTRACE O\n/*     */\nHOUSE_KEEPING:\nADDRESS TSO\nPARSE UPPER ARG ABRMAP .\nTSOID = SYSVAR(SYSUID)\nIF ABRMAP = '' THEN ABRMAP = TSOID'.FDRABR.ABRMAP'\nABRDSN = SYSDSN(\"'\"ABRMAP\"'\")\nIF ABRDSN = 'DATASET NOT FOUND' THEN DO\n   SAY '*** DATASET ERROR: DATASET NOT FOUND FOR ('ABRMAP'). ***'\n   SAY '*** ABRTLMS EXEC MAINTASK CANCELLED. ***'\n   EXIT 028\nEND\nE = 0\nT = 0\nX = MSG(\"OFF\")\n\"FREE FILE(ABRDD)\"\nOUTPDS = TSOID'.USER.CNTLLIB'\n/*\n       M A I N   R O U T I N E   S E C T I O N     */\n/*     */\nMAIN_ROUTINE:\nCALL READ_ABRMAP_DATASET\nDO I = 1 TO ABRDATA.0\n   DSNKEY = POS('FDRABR.V',ABRDATA.I)\n   IF DSNKEY = 0 THEN ITERATE\n   TAPEDSN = WORD(ABRDATA.I,1)\n   CALL LISTCAT_TAPE_DATASET\n   IF LSTSW = 'NO' THEN DO\n      CALL BUILD_ERRLOG_RECORD\n      ITERATE\n   END\n   CALL CHECK_DUPLICATE_TAPEVOL\nEND\nCALL BUILD_TLMS_SYSIN_RECORDS\nMEMBER = 'ABRTLMSI'\nCALL WRITE_PDS_MEMBER\nECNT = E\nIF ECNT > 0 THEN DO E = 1 TO ECNT\n   \"DELSTACK\"\n   MEMBER = 'ABRERRLG'\n   QUEUE LOGRCD.E\nEND\nIF ECNT > 0 THEN CALL WRITE_PDS_MEMBER\nEXIT 0\n/*\n       S U B R O U T I N E   S E C T I O N     */\n/*     */\nREAD_ABRMAP_DATASET:\n\"ALLOC DA('\"ABRMAP\"') FILE(ABRDD) SHR\"\n\"EXECIO * DISKR ABRDD (STEM ABRDATA. FINIS\"\nSRC = RC\n\"FREE FILE(ABRDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** EXECIO DATASET READ ERROR: ('ABRMAP'). ***'\n   SAY '*** ABRTLMS EXEC MAINTASK CANCELLED. ***'\n   EXIT SRC\nEND\nRETURN\n/*     */\nLISTCAT_TAPE_DATASET:\nLSTSW = 'NO'\nX = OUTTRAP(\"LSTCAT.\",\"*\",\"CONCAT\")\n\"LISTCAT ENT('\"TAPEDSN\"') VOL\"\nIF RC \u00ac= 0 THEN RETURN\nLSTSW = 'YES'\nDO L = 1 TO LSTCAT.0\n   VOLKEY = POS(\"VOLSER------------\",LSTCAT.L)\n   IF VOLKEY \u00ac= 0 THEN DO\n      STA = VOLKEY + 18\n      TAPEVOL = SUBSTR(LSTCAT.L,STA,6)\n      LEAVE\n   END\nEND\nRETURN\n/*     */\nBUILD_ERRLOG_RECORD:\nE = E + 1\nLOGRCD.E = TAPEDSN' : LISTCAT ERROR - DATASET NOT IN ICFCAT ***'\nRETURN\n/*     */\nCHECK_DUPLICATE_TAPEVOL:\nBYPASS = 'NO'\nIF T = 0 THEN DO\n   T = T + 1\n   TVOL.T = TAPEVOL\n   RETURN\nEND\nTAPECNT = T\nDO T = 1 TO TAPECNT\n   IF TAPEVOL = TVOL.T THEN BYPASS = 'YES'\nEND\nT = TAPECNT\nIF BYPASS = 'YES' THEN RETURN\nT = T + 1\nTVOL.T = TAPEVOL\nRETURN\n/*     */\nBUILD_TLMS_SYSIN_RECORDS:\n\"DELSTACK\"\nMEMBER = 'ABRTLMSI'\nTAPECNT = T\nDO T = 1 TO TAPECNT\n   TLMSRCD = 'UPV 'TVOL.T',SCRATCH=YES,CDS=0000'\n   QUEUE TLMSRCD\nEND\nRETURN\n/*     */\nWRITE_PDS_MEMBER:\n\"ALLOC DA('\"OUTPDS\"(\"MEMBER\")') FILE(ABRDD) SHR\"\nNUMRCDS = QUEUED()\n\"EXECIO\" NUMRCDS \"DISKW ABRDD (FINIS\"\nSRC = RC\n\"FREE FILE(ABRDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '***************************************************************'\n   SAY '*** EXECIO WRITE ERROR: RETURN CODE: ('SRC'). ***'\n   SAY '*** ERROR WRITING ('OUTPDS'('MEMBER'). ***'\n   SAY '*** ABRTLMS EXEC SUBTASK CANCELLED. ***'\n   SAY '***************************************************************'\n   EXIT SRC\nEND\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ADDMEMB": {"ttr": 1793, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x925\\x8f\\x00\\x95\\t?\\x16I\\x00\\x85\\x00\\x82\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf3@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1992-12-23T00:00:00", "modifydate": "1995-04-03T16:49:00", "lines": 133, "newlines": 130, "modlines": 0, "user": "TECH103"}, "text": "/*  REXX EXEC : ( ADDMEMB ).\n    FUNCTION  : BUILDS A IEBGENER JOB TO ADD|REPLACE A MEMBER INTO\n                THE USER'S TSO USER.CNTLLIB (SYSA) OR MAINT.CNTLLIB\n                (SYSM).\n                                                                    */\nTRACE O\n/*     */\nHOUSE_KEEPING:\nADDRESS ISPEXEC\nARG MEMBER\nIF MEMBER = '' THEN DO\n   SAY '*** MEMBER NAME NOT PASSED ON COMMAND LINE.***'\n   SAY '*** ADDMEMB EXEC TASK CANCELLED. ***'\n   EXIT\nEND\nACCTDFT = '5304010530000000'\n\"VGET (ACCTCDE) PROFILE\"\nIF RC \u00ac= 0 THEN ACCTCDE = ACCTDFT\nADDRESS TSO\nTSOID = SYSVAR(SYSUID)\nUCNTL = SYSDSN(DIALOG.ISPFILE)\nIF UCNTL = 'DATASET NOT FOUND' THEN DO\n\"ALLOC DA(DIALOG.ISPFILE) LIKE(USER.CNTLLIB) NEW SPACE(1,0) DIR(5) CYLINDERS\"\n   SRC = RC\n   IF SRC \u00ac= 0 THEN DO\n   SAY '*** ALLOCATE ERROR: ERROR ALLOCATING DATASET (DIALOG.ISPFILE). ***'\n   SAY '*** ADDMEMB EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\n   END\nEND\nMEM = SYSDSN(\"USER.CNTLLIB(\"MEMBER\")\")\nIF MEM = 'MEMBER NOT FOUND' THEN DO\n   SAY '*** MEMBER NOT FOUND IN (\"TSOID\".USER.CNTLLIB(\"MEMBER\"). ***'\n   SAY '*** ADDMEMB EXEC TASK CANCELLED - RETURN CODE: (28). ***'\n   EXIT\nEND\nX = MSG(\"OFF\")\n\"FREE FILE(ISPFILE)\"\n\n/*     */\nMAIN_ROUTINE:\nCALL READ_MEMBER\nCALL BUILD_IEBGENER_JOBJCL\nCALL BUILD_IEBGENER_SYSIN\nCALL BUILD_IEBGENER_ENDJCL\nCALL WRITE_IEBGENER_JOB\nCALL SUBMIT_IEBGENER_JOB\nEXIT 0\n\n/*     S U B R O U T I N E S   S E C T I O N     */\n\n/*     */\nREAD_MEMBER:\n\"ALLOC DA(USER.CNTLLIB(\"MEMBER\")) FILE(ISPFILE) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: (USER.CNTLLIB('MEMBER'). ***'\n   SAY '*** ADDMEMB EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\n\"EXECIO * DISKR ISPFILE (FINIS STEM DATA.\"\nSRC = RC\n\"FREE FILE(ISPFILE)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** EXECIO READ ERROR: (USER.CNTLLIB('MEMBER'). ***'\n   SAY '*** ADDMEMB EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nRETURN\n\n/*     */\nBUILD_IEBGENER_JOBJCL:\nJ = 0\nJN = MEMBER\n\"DELSTACK\"\nJCL.1 = \"//\"JN\" JOB\" ACCTCDE\",'GENER ADD PDS MEMBER',NOTIFY=\"TSOID\",\"\nJCL.2 = \"//             CLASS=S,MSGCLASS=G,MSGLEVEL=(1,1),REGION=4M\"\nJCL.3 = \"/*ROUTE  XEQ CHRMSYSM\"\nJCL.4 = \"/*ROUTE  PRINT CHRMSYSM.\"TSOID\nJCL.5 = \"//PDSADD    EXEC PGM=IEBGENER\"\nJCL.6 = \"//SYSIN     DD DUMMY\"\nJCL.7 = \"//SYSPRINT  DD SYSOUT=*\"\nJCL.8 = \"//SYSUT2    DD DSN=\"TSOID\".MAINT.CNTLLIB(\"MEMBER\"),DISP=SHR\"\nJCL.9 = \"//SYSUT1    DD DATA,DLM=$$\"\nDO 9\n   J = J + 1\n   QUEUE JCL.J\nEND\nRETURN\n\n/*     */\nBUILD_IEBGENER_SYSIN:\nDO I = 1 TO DATA.0\n   QUEUE DATA.I\nEND\nRETURN\n\n/*     */\nBUILD_IEBGENER_ENDJCL:\nE = 0\nEND.1 = \"$$\"\nEND.2 = \"/*\"\nEND.3 = \"//\"\nDO 3\n   E = E + 1\n   QUEUE END.E\nEND\nRETURN\n\n/*     */\nWRITE_IEBGENER_JOB:\n\"ALLOC DA(DIALOG.ISPFILE(\"MEMBER\")) FILE(ISPFILE) SHR\"\nNUMRCDS = QUEUED()\n\"EXECIO\" NUMRCDS \"DISKW ISPFILE (FINIS\"\nSRC = RC\n\"FREE FILE(ISPFILE)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** WRITE ERROR: ERROR WRITING ('TSOID'.DIALOG.ISPFILE('MEMBER'). ***'\n   SAY '*** ADDMEMB EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nRETURN\n\n/*     */\nSUBMIT_IEBGENER_JOB:\n\"SUBMIT '\"TSOID\".DIALOG.ISPFILE(\"MEMBER\")'\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** SUBMIT ERROR: ( 'TSOID'.DIALOG.ISPFILE('MEMBER'). ***'\n   SAY '*** ADDMEMB EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ALIASGEN": {"ttr": 1796, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x00\\x92'_\\x00\\x92'_\\x10\\x11\\x00\\x92\\x00\\x92\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf3@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "1992-10-01T00:00:00", "modifydate": "1992-10-01T10:11:00", "lines": 146, "newlines": 146, "modlines": 0, "user": "TECH103"}, "text": "/*  REXX EXEC ( ALIASGEN ).\n    FUNCTION: BUILD PDS MEMBERS CONTAINING THE ALIAS/RELATES FOR EACH\n              ASSOCIATION TO A CONNECTED ICF USER CATALOG.\n    ZEKE JOB: SYSS.ZEKE.JCLLIB(PTCAT01D).\n    INPUT   : IDCAMS LSTALIAS SYSOUT DATASET ( SYSS.LSTALIAS.SYSPRINT ).\n    OUTPUT  : PDS WITH ALIAS/RELATE MEMBERS ( SYSS.LSTALIAS.CNTLLIB ).\n                                                                      */\nTRACE O\n/*     */\nHOUSE_KEEPING:\nADDRESS TSO\nC = 0\nUCNT = 0\n/*     */\nREAD_LSTALIAS_OUTPUT:\n\"ALLOC DA('SYSS.LSTALIAS.SYSPRINT') F(ISPFILE) OLD\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ( SYSS.LSTALIAS.SYSPRINT ). ***'\n   SAY '*** DATASET IN USE OR UNAVAILABLE - RETURN CODE: (' SRC '). ***'\n   SAY '*** ALIASGEN EXEC SUBTASK CANCELLED. ***'\n   EXIT SRC\nEND\n\"EXECIO * DISKR ISPFILE (FINIS STEM DATA.\"\nSRC = RC\n\"FREE F(ISPFILE)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET EXECIO ERROR: ( SYSS.LSTALIAS.SYSPRINT ). ***'\n   SAY '*** EXECIO DATASET READ RETURN CODE: (' SRC '). ***'\n   SAY '*** ALIASGEN EXEC SUBTASK CANCELLED. ***'\n   EXIT SRC\nEND\n/*     */\nBUILD_USERCAT_TABLE:\nDO I = 1 TO DATA.0\n   UCATKEY = POS('USERCAT--',DATA.I)\n   IF UCATKEY \u00ac= 0 THEN DO\n      U = UCATKEY + 9\n      UCAT = SUBSTR(DATA.I,U)\n      USER_CATALOG = STRIP(UCAT)\n      CALL CHECK_USERCAT_TABLE\n   END\nEND\n/*     */\nGET_ALIAS_NAMES:\nUCATCNT = C\nC = 0\nDO UCATCNT\n   C = C + 1\n   IF C > 1 THEN DO\n      \"EXECIO 0 DISKW ISPFILE (FINIS\"\n      \"FREE F(ISPFILE)\"\n   END\n   ALLOCSW = 'YES'\n   DO I = 1 TO DATA.0\n      ALIASKEY = POS('ALIAS ---------',DATA.I)\n      IF ALIASKEY \u00ac= 0 THEN ALIAS = SUBWORD(DATA.I,3,1)\n      DATAKEY = POS('NONVSAM--',DATA.I)\n      IF DATAKEY \u00ac= 0 THEN ITERATE\n      UCATKEY = POS('USERCAT--',DATA.I)\n      IF UCATKEY \u00ac= 0 THEN DO\n         U = UCATKEY + 9\n         UCAT = SUBSTR(DATA.I,U)\n         USER_CATALOG = STRIP(UCAT)\n         IF USER_CATALOG = USERCAT.C THEN DO\n            PDSMEMB = 'USRCAT'||C\n            IF ALLOCSW = 'YES' THEN CALL ALLOC_CNTLLIB\n            RECORD.3 = \"         RELATE(\"USER_CATALOG\"))\"\n            CALL WRITE_PDSMEMB\n         END\n      END\n   END\nEND\n\"EXECIO 0 DISKW ISPFILE (FINIS\"\n\"FREE F(ISPFILE)\"\n/*     */\nGET_ALIAS_DSN_RELATES:\nPDSMEMB = 'RELATDSN'\nCALL ALLOC_CNTLLIB\nDO I = 1 TO DATA.0\n   ALIASKEY = POS('ALIAS ---------',DATA.I)\n   IF ALIASKEY \u00ac= 0 THEN ALIAS = SUBWORD(DATA.I,3,1)\n   UCATKEY = POS('USERCAT--',DATA.I)\n   IF UCATKEY \u00ac= 0 THEN ITERATE\n   DATAKEY = POS('NONVSAM--',DATA.I)\n   IF DATAKEY \u00ac= 0 THEN DO\n      U = DATAKEY + 9\n      RDSN = SUBSTR(DATA.I,U)\n      RELATE_DSN = STRIP(RDSN)\n      RECORD.3 = \"         RELATE(\"RELATE_DSN\"))\"\n      CALL WRITE_PDSMEMB\n   END\nEND\n\"EXECIO 0 DISKW ISPFILE (FINIS\"\n\"FREE F(ISPFILE)\"\nEXIT 0\n/*     S U B R O U T I N E S   S E C T I O N     */\n/*     */\nCHECK_USERCAT_TABLE:\nCATSW = 'NO'\nSAVCNT = C\nC = 0\nIF SAVCNT = 0 THEN DO\n   C = C + 1\n   USERCAT.C = USER_CATALOG\n   RETURN\nEND\nDO SAVCNT\n   C = C + 1\n   IF USER_CATALOG = USERCAT.C THEN CATSW = 'YES'\nEND\nIF CATSW = 'YES' THEN RETURN\nC = C + 1\nUSERCAT.C = USER_CATALOG\nRETURN\n/*     */\nALLOC_CNTLLIB:\nALLOCSW = 'NO'\n\"ALLOC DA('SYSS.LSTALIAS.CNTLLIB(\"PDSMEMB\")') F(ISPFILE) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ( SYSS.LSTALIAS.CNTLLIB ). ***'\n   SAY '*** DATASET IN USE OR UNAVAILABLE - RETURN CODE: (' SRC '). ***'\n   SAY '*** ALIASGEN EXEC SUBTASK CANCELLED. ***'\n   EXIT SRC\nEND\nRETURN\n/*     */\nWRITE_PDSMEMB:\nR = 0\n\"DELSTACK\"\nRECORD.1 = \" DEFINE ALIAS -\"\nRECORD.2 = \"         (NAME(\"ALIAS\") -\"\nDO 3\n   R = R + 1\n   QUEUE RECORD.R\nEND\n\"EXECIO 3 DISKW ISPFILE\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** PDS WRITE ERROR: SYSS.LSTALIAS.CNTLLIB('PDSMEMB'). ***'\n   SAY '*** EXECIO WRITE RETURN CODE: (' SRC '). ***'\n   SAY '*** ALIASGEN EXEC SUBTASK CANCELLED. ***'\n   EXIT SRC\nEND\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "BACKSCHD": {"ttr": 1800, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x10\\x00\\x00\\x00\\x93\"?\\x00\\x94\\x04\\x8f\\x126\\x00\\xbd\\x00\\xa9\\x00\\xbd\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf7@@@'", "ispf": {"version": "01.16", "flags": 0, "createdate": "1993-08-11T00:00:00", "modifydate": "1994-02-17T12:36:00", "lines": 189, "newlines": 169, "modlines": 189, "user": "TECH107"}, "text": "/* REXX BACKUP STATUS RECORD WRITE    */\n/*                                    */\n/* SCHEDUEL TABLE                     */\n/*                                    W       T                  */\n/*                             T      E       H                  */\n/*                      M      U      D       U     F     S     S*/\n/*                      O      E      N       R     R     A     U*/\n/*                      N      S      S       S     I     T     N*/\n/*                      =      =      =       =     =     =     =*/\npool_.1  ='ONLBATCH     I      I      I       I     I     I      ';\npool_.2  ='ONLGOLD      I      I      I       I     I     I      ';\npool_.3  ='ONLSALE      I      I      I       I     I     I      ';\npool_.4  ='POOLACIC     I      I      I       I     I     F      ';\npool_.5  ='POOLAPPL     I      I      I       I     I     F      ';\npool_.6  ='POOLART      I      I      I       I     I     F      ';\npool_.7  ='POOLCICS     I      I      I       I     I     F      ';\npool_.8  ='POOLDB2      I      I      I       I     I     F      ';\npool_.9  ='POOLEMC      I      I      I       I     I     F      ';\npool_.10 ='POOLMNT      I      I      I       I     I     F      ';\npool_.11 ='POOLMVS      I      I      I       I     I     F      ';\npool_.12 ='POOLPHYS     I      I      I       I     I     F      ';\npool_.13 ='POOLPLAN     I      I      I       I     I     F      ';\npool_.14 ='POOLPOS      I      I      I       I     I     F      ';\npool_.15 ='POOLQA       I      I      I       I     I     F      ';\npool_.16 ='POOLRAMI     I      I      I       I     I     F      ';\npool_.17 ='POOLSEQ      I      I      I       I     I     F      ';\npool_.18 ='POOLSMS      I      I      I       I     I     F      ';\npool_.19 ='POOLSMSC     I      I      I       I     I     F      ';\npool_.20 ='POOLSYS      I      I      I       I     I     F      ';\npool_.21 ='POOLTSO      I      I      I       I     I     F      ';\npool_.22 ='POOLUSER     I      I      I       I     I     F      ';\npool_.23 ='POOLVSAM     I      I      I       I     I     F      ';\npoolmax  = 23;\nnoincr   ='SYS007 SYS008 SYS011 SYS012 SYS013 SYS014 SYS015'\nnoincrmax= 7;\n/*                                    */\n/* GET DAY                            */\n/*                                    */\nCALL SETUP\nweekday = DATE(W)\nSELECT;\n    WHEN weekday = 'Monday'    THEN ;\n         day = 2;\n    WHEN weekday = 'Tuesday'   THEN ;\n         DO;\n           QUEUE 'DELETE FROM BUILD.TABRVOLS;' ;\n           QUEUE 'COMMIT;' ;\n           day = 3;\n         END;\n    WHEN weekday = 'Wednesday' THEN ;\n         day = 4;\n    WHEN weekday = 'Thursday'  THEN ;\n         day = 5;\n    WHEN weekday = 'Friday'    THEN ;\n         day = 6;\n    WHEN weekday = 'Saturday'  THEN ;\n         day = 7;\n    WHEN weekday = 'Sunday'    THEN ;\n         day = 8;\nOTHERWISE END;\n/*                                    */\n/* GET VOLS                           */\n/*                                    */\nDO Q=1 TO pdsot_.0;\n   poolfound = 'NO'\n   PARSE VAR pdsot_.Q word1 5 5 word2 11 58 word3 65 66 word4 74\n   SELECT;\n      WHEN word3  ='MEMBER:' THEN;\n         member = word4;\n      WHEN word1  ='//D$'    THEN;\n         DO P=1 TO poolmax UNTIL poolfound='YES'\n            SELECT;\n               WHEN member = WORD(pool_.P,1) THEN;\n                  DO;\n                    volser = word2;\n                    SELECT;\n                      WHEN WORD(pool_.P,DAY) = 'I' | ,\n                           WORD(pool_.P,DAY) = 'F' THEN;\n                         CALL WTESQL;\n                     OTHERWISE END;\n                     poolfound = YES;\n                  END;\n            OTHERWISE END;\n         END;\n      OTHERWISE END;\nEND;\n/*                                    */\n/* ONLINE LOOP                        */\n/*                                    */\nDO P=1 TO poolmax;\n   SELECT;\n     WHEN 'ONL' = SUBSTR(pool_.P,1,3) THEN;\n        DO;\n           volser = SUBSTR(pool_.P,4,5);\n           SELECT;\n              WHEN WORD(pool_.P,DAY) = 'I' THEN;\n                CALL WTESQL;\n           OTHERWISE END;\n        END;\n     OTHERWISE END;\nEND;\nCALL CLOSEUP;\nEXIT;\n/* *** */\n/* *** */\n/* *** */\nWTESQL:\nwrite='Y';\nDO G=1 TO noincrmax;\n   SELECT;\n     WHEN volser = WORD(noincr,G) THEN;\n      DO;\n         write='N';\n      END;\n   OTHERWISE END;\nEND;\nIF write='Y' THEN;\n   DO;\n      SELECT;\n          WHEN WORD(pool_.P,DAY) = 'I' THEN;\n              btype = 'INCRVOL';\n          WHEN WORD(pool_.P,DAY) = 'F' THEN;\n              btype = 'FULLVOL';\n      OTHERWISE END;\n      QUEUE \"INSERT INTO BUILD.TABRVOLS(VOLSER,DUMP_TYPE,DUMP_STATUS)\"\n      QUEUE \"    VALUES('\"volser\"','\"btype\"','PENDING');         \"\n   END;\nRETURN;\n/* *** */\n/* *** */\n/* *** */\nSETUP:\n\"NEWSTACK\";\n\"PRINTDS DATASET('SYSS.COMDISCO.DUMPJOBS') ,\n         TODATASET('PMBU.N.PDS.WORK')\"\nIF rc <> 0 THEN;\n  DO;\n    SAY \"RC=\" rc \"**IO** ERROR ON COMDISCO.DUMPJOBS *PRINTDS*\";\n    EXIT;\n  END;\n/* **** */\n/* **** */\n\"ALLOC FILE(PDSOT) DATASET('PMBU.N.PDS.WORK') SHR REUSE\";\nIF rc <> 0 THEN;\n  DO;\n    SAY \"RC=\" rc \"**IO** ERROR ON PDS.WORK ALLOCATE\";\n    EXIT;\n  END;\n/* **** */\n/* **** */\n\"ALLOC FILE(SQLOT) DATASET('PMBU.N.SQL.WORK') SHR REUSE\";\nIF rc <> 0 THEN;\n  DO;\n    SAY \"RC=\" rc \"**IO** ERROR ON SQL.WORK ALLOCATE\";\n    EXIT;\n  END;\n/* **** */\n/* **** */\nX = OUTTRAP('pdsot_.');\n\"EXECIO * DISKR PDSOT (FINIS STEM pdsot_.\";\nIF rc <> 0 THEN;\n  DO;\n    SAY \"RC=\" rc \"**IO** ERROR ON PDSOT READ\";\n    EXIT;\n  END;\nX = OUTTRAP('OFF');\nRETURN\n/* *** */\n/* *** */\n/* *** */\nCLOSEUP:\n\"EXECIO * DISKW SQLOT (FINIS\"\n\"DELSTACK\"\n/* *** */\n/* *** */\n/* *** */\n\"FREE  DDNAME(PDSOT SQLOT)\"\nIF rc <> 0 THEN;\n  DO;\n    SAY \"RC=\" rc \"**IO** ERROR ON DSN FREE\";\n    EXIT;\n  END;\n/* *** */\n/* *** */\n/* *** */\n/* *** */\n/* *** */\n/* *** */\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "BKSTAT": {"ttr": 1804, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x00\\x00\\x00\\x93\"?\\x00\\x93#\\x1f\\x15I\\x00\\xab\\x00m\\x00\\xab\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf7@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "1993-08-11T00:00:00", "modifydate": "1993-08-19T15:49:00", "lines": 171, "newlines": 109, "modlines": 171, "user": "TECH107"}, "text": "/* REXX BACKUP STATUS BROWSE  */\n/*                     */\n/* START QMF INTERFACE */\n/*                     */\n/* TRACE ?I */\nCALL DSQCIX \"EXIT\";\nCALL DSQCIX \"START (DSQSMODE=INTERACTIVE DSQSSUBS=DSNA\";\nIF dsq_return_code \u00ac=0 then do;\n    \"VMFCLEAR\";\n    say dsq_message_id dsq_message_text;\n    say dsq_q_message_id dsq_q_message_text;\n    signal TERM;\n    end;\n/*                          */\n/* DISPLAY SELECTION PANNEL */\n/*                          */\ndatec = DATE('O');\ndatec = OVERLAY('-',datec,3,1);\ndatec = OVERLAY('-',datec,6,1);\ndatec = INSERT('19',datec,0,2);\ncdate = datec;\nCALL LEAPRTN;\nIF TIME(H) < 12 THEN;\n   DO;\n     CALL PREVDATE;\n     datec = cdate;\n   END;\nCALL PREVDATE;\ndatep = cdate;\ncdate = datec;\nCALL NEXTDATE;\ndaten = cdate;\n\"VMFCLEAR\";\nDO FOREVER;\n   address \"ISPEXEC\" \"DISPLAY PANEL(PBKSTAT)\";\n   IF rc\u00ac=0 THEN SIGNAL TERM;\n   CALL SCREDIT;\n   SELECT;\n      WHEN wordn = 1 THEN;\n         op=\"('\"op1\"')\"\n      WHEN wordn = 2 THEN;\n         op=\"('\"op1\"','\"op2\"')\"\n      WHEN wordn = 3 THEN;\n         op=\"('\"op1\"','\"op2 \"','\"op3\"')\"\n      OTHERWISE;\n          ITERATE;\n          END;\n   ope = \"(\" op \")\"\n   CALL DSQCIX ,\n    \" RUN QUERY TECH107.QBSTAT (FORM=TECH107.FBSTAT\"  || ,\n    \" &DATEF='\"datef\"' &DATET='\"datet\"' &OP=\" ope ;\n   if dsq_return_code \u00ac=0 then do;\n       \"VMFCLEAR\";\n       say dsq_message_id dsq_message_text;\n       say dsq_q_message_id dsq_q_message_text;\n       signal TERM;\n       end;\nEND;\nTERM:\nCALL DSQCIX \"EXIT\";\nEXIT 0;\n/*************/\n/*************/\n/*************/\nPREVDATE:\ncyy =SUBSTR(cdate,3,2);cmm=SUBSTR(cdate,6,2);cdd=SUBSTR(cdate,9,2);\ncdd = cdd - 1; cdd=RIGHT(cdd,2,0);\nIF cdd = 00 then;\n   DO;\n    cmm = cmm - 1; cmm=RIGHT(cmm,2,0);\n    SELECT;\n       WHEN cmm=01 THEN;\n          DO;\n            cyy=cyy - 1; cyy=RIGHT(cyy,2,0); cmm=12; cdd=31;\n          END;\n       WHEN cmm=01 | cmm=03 | cmm=05 | cmm=07 | ,\n            cmm=08 | cmm=10 THEN;\n            cdd = 31;\n       WHEN cmm=02 THEN;\n            cdd = febmdd;\n       WHEN cmm=04 | cmm=06 | cmm=09 | cmm=01  THEN;\n            cdd = 30;\n       OTHERWISE  END;\n  END;\ncdate =  '19'  || cyy || '-' || cmm || '-' || cdd;\nRETURN;\n/*************/\n/*************/\n/*************/\nNEXTDATE:\ncyy =SUBSTR(cdate,3,2);cmm=SUBSTR(cdate,6,2);cdd=SUBSTR(cdate,9,2);\ncdd = cdd+1; cdd=RIGHT(cdd,2,0);\nSELECT;\n   WHEN cmm=12 & cdd>31 THEN;\n      DO;\n        cyy=cyy+1; cyy=RIGHT(cyy,2,0); cmm=01; cdd=01;\n      END;\n   WHEN cmm=02 & cdd>febmdd THEN;\n      DO;\n        cmm=03; cdd=01;\n      END;\n   WHEN (cmm=01 | cmm=03 | cmm=05 | cmm=07 | ,\n         cmm=08 | cmm=10) & cdd>31  THEN;\n      DO;\n        cmm=cmm+1; cmm=RIGHT(cmm,2,0); cdd=01;\n      END;\n   WHEN (cmm=04 | cmm=06 | cmm=09 | cmm=01) & cdd>30  THEN;\n      DO;\n        cmm=cmm+1; cmm=RIGHT(cmm,2,0); cdd=01;\n      END;\n   OTHERWISE  END;\ncdate =  '19'  || cyy || '-' || cmm || '-' || cdd;\nRETURN;\n/*************/\n/*************/\n/*************/\nSCREDIT:\n/*                              */\n/* FORMAT DATE AND SELECT QUERY */\n/*                              */\nSELECT;\n     WHEN s='2' THEN;\n       DO;\n         datef=datep; datet=datec;\n       END;\n     WHEN s='1' THEN;\n       DO;\n         datef=datec; datet=daten;\n       END;\n     OTHERWISE END;\n/*                              */\nwordn = 0\nIF   f = 'Y' THEN;\n     DO;\n       op1   = \"FAILURE','ACTIVE\"; wordn = wordn + 1;\n     END;\nIF   c = 'Y' THEN;\n     DO;\n       SELECT;\n           WHEN wordn = 0 THEN;\n              op1 = 'COMPLETE';\n           WHEN wordn = 1 THEN;\n              op2 = 'COMPLETE';\n           OTHERWISE END;\n       wordn = wordn + 1;\n     END;\nIF   p = 'Y' THEN;\n     DO;\n       SELECT;\n           WHEN wordn = 0 THEN;\n              op1 = 'PENDING';\n           WHEN wordn = 1 THEN;\n              op2 = 'PENDING';\n           WHEN wordn = 2 THEN;\n              op3 = 'PENDING';\n           OTHERWISE END;\n       wordn = wordn + 1;\n     END;\nRETURN;\n/*************/\n/*************/\n/*************/\nLEAPRTN:\ncyy =SUBSTR(cdate,3,2);\nfebmdd = 28;\nIF cyy//4 = 0 THEN;\n   febmdd=29;\nRETURN;\n/*************/\n/*************/\n/*************/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "BLDCJCL": {"ttr": 2051, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x91\"_\\x00\\x91\"\\x7f\\x11 \\x00$\\x00\\'\\x00$\\xc9\\xc2\\xd4\\xe4\\xe2\\xc5\\xd9@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1991-08-13T00:00:00", "modifydate": "1991-08-15T11:20:00", "lines": 36, "newlines": 39, "modlines": 36, "user": "IBMUSER"}, "text": "/* REXX Build a Copy Job                                     */\naddress \"TSO\";\n\"ALLOC F(INPUT) DA('SYSM.TECH.COMMON.CNTLLIB(BLDCDATA)') SHR\";\n\"EXECIO * DISKR INPUT (FINIS STEM INPUT.\";\n\"FREE F(INPUT)\";\n\"NEWSTACK\";\nQUEUE \"//COPYSYS JOB 5304010530000000,'M MCCARTY',NOTIFY=IBMUSER,\";\nQUEUE \"// CLASS=S,MSGCLASS=G,REGION=8M\";\nQUEUE \"//COPY EXEC PGM=IEBCOPY\";\nQUEUE \"//SYSPRINT DD SYSOUT=*\";\nDO I = 1 TO INPUT.0 BY 2;\n  PARSE VAR INPUT.I IDSN IVSER ODSN OVSER . ;\n  J = I+1;\n  PARSE VAR INPUT.J RECFM LRECL DATACLAS SPACE . ;\n  QUEUE \"//I\"I \"DD DSN=\"IDSN\",DISP=SHR,UNIT=3390,VOL=SER=\"IVSER;\n  QUEUE \"//O\"I \"DD DSN=\"ODSN\",DISP=(NEW,CATLG),VOL=SER=\"OVSER\",\";\n  QUEUE \"// DATACLAS=\"DATACLAS\",STORCLAS=SCSTNRDG,\";\n  IF OVSER=\"SMSSM1\" THEN MGMT=\"NOMIG\";\n     ELSE MGMT=\"STANDARD\";\n  IF RECFM=\"U\" THEN DSNT=\"PDS\";\n     ELSE DSNT=\"LIBRARY\";\n  QUEUE \"// MGMTCLAS=\"MGMT\",DSNTYPE=\"DSNT\",\";\n  QUEUE \"// RECFM=\"RECFM\",SPACE=\"SPACE\",\";\n  IF RECFM=\"U\" THEN QUEUE \"// BLKSIZE=23476\";\n     ELSE QUEUE \"// LRECL=\"LRECL;\nEND;\nQUEUE \"//SYSIN DD *\";\nDO I = 1 TO INPUT.0 BY 2;\n  QUEUE \" COPY I=I\"I\",O=O\"I;\nEND;\nQUEUE \"//\";\nQUEUE \"\";\n\"ALLOC F(OUTPT) DA('SYSM.TECH.COMMON.CNTLLIB(JSYSCOPY)') SHR\";\n\"EXECIO * DISKW OUTPT (FINIS\";\n\"FREE F(OUTPT)\";\nEXIT 0;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "BLDCOPY": {"ttr": 2053, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x15\\x00\\x00\\x00\\x91#\\x8f\\x00\\x94\\x04\\x7f\\t#\\x003\\x00\\x15\\x00&\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf6@@@'", "ispf": {"version": "01.21", "flags": 0, "createdate": "1991-08-26T00:00:00", "modifydate": "1994-02-16T09:23:00", "lines": 51, "newlines": 21, "modlines": 38, "user": "TECH106"}, "text": "/* REXX PROG TO READ UNIQUE-FILE LIST AND PRODUCE 10 AND OVER LIST */\nADDRESS \"TSO\";\n\"FREE F(INDD)\";\n\"ALLOC DA('SYS1.TECH.LIBSCN.IN') F(INDD) SHR\";\n\"ALLOC DA('SYS1.TECH.LIBRSCAN.OUT') F(OUTDD)  NEW \",\n       \"SPACE(30,10) DSORG(PS) RECFM(F,B) LRECL(80) BLKSIZE(800)\",\n       \"UNIT(SEQDA) TRACKS\";\n\"EXECIO * DISKR INDD (FINIS STEM DATA.\";\nPREVIOUS_MEMBER = EMPTY\nCOUNT = 0\nDO I = 1 TO DATA.0\n   FULLINE = DATA.I\n   IF WORDS(FULLINE) < 2 THEN ITERATE\n   COPYPOS = WORDPOS(' COPY ',FULLINE)\n   IF COPYPOS = 0 THEN ITERATE\n   WORD2 = WORD(FULLINE,2)\n   LENWORD2 = LENGTH(WORD2)\n   IF SUBSTR(FULLINE,2,1) /= ' ' & LENWORD2 = 4 THEN DO\n     WORD1 = SUBSTR(FULLINE,2,8)\n     PREVIOUS_MEMBER = WORD1\n     END\n   IF POS('*',FULLINE) = 29 THEN ITERATE\n   COPYBOOK = WORD(FULLINE,COPYPOS+1)\n   BOOKLENGTH = LENGTH(COPYBOOK)\n   PERIOD = SUBSTR(COPYBOOK,BOOKLENGTH,1)\n   WORD3 = WORD(FULLINE,COPYPOS+2)\n\n   IF (PERIOD /= '.') & ((WORD3 /= 'REPLACING') & ,\n      (WORD3 /= 'SUPPRESS.')) THEN ITERATE;\n   IF PERIOD = '.' THEN\n     DO\n       COPYBOOK = SUBSTR(COPYBOOK,1,BOOKLENGTH-1)\n       BOOKLENGTH = BOOKLENGTH - 1\n     END\n   IF BOOKLENGTH < 4 THEN ITERATE\n   IF SUBSTR(COPYBOOK,1,1) = \"'\" THEN\n     DO\n       NEWBOOK = SUBSTR(COPYBOOK,2,BOOKLENGTH-2)\n       COPYBOOK = NEWBOOK\n     END\n   DO\n     IF PREVIOUS_MEMBER = 'EMPTY' THEN ITERATE\n     DETAIL_LINE = PREVIOUS_MEMBER || '   ' || COPYBOOK\n     PUSH DETAIL_LINE\n     \"EXECIO 1 DISKW OUTDD\"\n   END\n END I;\n\"EXECIO 0 DISKW OUTDD (FINIS\"\n\"FREE F(INDD)\";\n\"FREE F(OUTDD)\";\nEXIT 0;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "BLKSIZE": {"ttr": 2055, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x13\\x00\\x00\\x00\\x91)\\x7f\\x00\\x910\\x1f\\x19!\\x00 \\x00\\x1b\\x00\\x00\\xc4\\xc5\\xe5\\xc3\\xf0\\xf0\\xf2@@@'", "ispf": {"version": "01.19", "flags": 0, "createdate": "1991-10-24T00:00:00", "modifydate": "1991-10-28T19:21:00", "lines": 32, "newlines": 27, "modlines": 0, "user": "DEVC002"}, "text": "/* REXX */\n/* 10/24/91 Ken K.   Converted from CMS             */\n/* Optimal BLKSIZE Calculation                      */\n/* Invocation is:   BLKSIZE devicetype lrecl        */\n/*     where devicetype is 3380 3390 3480 3490      */\n/* 10/24/91 Ken K.   Commented out following comand */\n/*'VMFCLEAR';  so we can show results clearly       */\nparse upper arg devicetype lrecl parm;\noptimal = validation(devicetype,lrecl); /* valid parameters passed */\nif optimal = '' then do;\n       say \"Please re-enter command as follows:\";\n       say \"BLKSIZE devicetype lrecl\";\n       say \"  where devicetype is 3380 or 3390 or 3480 or 3490\";\n       say \"  where lrecl is greater than 0 and less than 23477\";\n       exit 16;\n       end;\n   else do;\n      M = \"Optimal BLKSIZE = \"trunc(optimal / lrecl)*lrecl;\n      if parm \u00ac= 'PANEL'; then do\n         say \"Devicetype = \"devicetype;\n         say \"LRECL = \"lrecl;\n      end /*then do*/\n      say M\n      return 0;\n      end /*else do*/\nvalidation: procedure;\n     devtypes = '3380 3390 3480 3490'; /* valid device types */\n     halftrack = '23476 27998 32000 32000' /* matching half-tracks */\n     devicetype = arg(1); lrecl = arg(2);\n     if \u00acdatatype(lrecl,'W') | lrecl > 23476 | ,\n        find(devtypes,devicetype)=0 then return '';\n     return word(halftrack,find(devtypes,devicetype));\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "BMANB": {"ttr": 2057, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x10_\\x00\\x94\\x10_\\x04\\x10\\x00\\t\\x00\\t\\x00\\x00\\xc9\\xd6\\xc1\\xf4\\xf1\\xf0@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-04-15T00:00:00", "modifydate": "1994-04-15T04:10:00", "lines": 9, "newlines": 9, "modlines": 0, "user": "IOA410"}, "text": "PROC 0  APPLTYPE(S)  -\n        APPLID(CB)\n/****************************************************************\n/*                                                              *\n/*  CONTROL-B:   QUALITY ASSURANCE SYSTEM        ( TSO)         *\n/*                                                              *\n/****************************************************************\n%IOAONL APPLTYPE(&APPLTYPE) APPLID(&APPLID)\nEND:END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "BMANC": {"ttr": 2059, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x10_\\x00\\x94\\x10_\\x04\\x10\\x00\\n\\x00\\n\\x00\\x00\\xc9\\xd6\\xc1\\xf4\\xf1\\xf0@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-04-15T00:00:00", "modifydate": "1994-04-15T04:10:00", "lines": 10, "newlines": 10, "modlines": 0, "user": "IOA410"}, "text": "PROC 0  APPLTYPE(S)  -\n        APPLID(CC)\n/****************************************************************\n/*                                                              *\n/*  CONTROL-M:   PRODUCTION CONTROL  SYSTEM      ( TSO)         *\n/*  CONTROL-B:   QUALITY ASSURANCE SYSTEM        ( TSO)         *\n/*                                                              *\n/****************************************************************\n%IOAONL APPLTYPE(&APPLTYPE) APPLID(&APPLID)\nEND:END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "BMANE": {"ttr": 2061, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x10_\\x00\\x94\\x10_\\x04\\x10\\x00\\n\\x00\\n\\x00\\x00\\xc9\\xd6\\xc1\\xf4\\xf1\\xf0@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-04-15T00:00:00", "modifydate": "1994-04-15T04:10:00", "lines": 10, "newlines": 10, "modlines": 0, "user": "IOA410"}, "text": "PROC 0  APPLTYPE(S)  -\n        APPLID(CE)\n/****************************************************************\n/*                                                              *\n/*  CONTROL-B:   QUALITY ASSURANCE SYSTEM        ( TSO)         *\n/*  CONTROL-D:   REPORT DISTRIBUTION SYSTEM      ( TSO)         *\n/*                                                              *\n/****************************************************************\n%IOAONL APPLTYPE(&APPLTYPE) APPLID(&APPLID)\nEND:END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "BMANI": {"ttr": 2063, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x10_\\x00\\x94\\x10_\\x04\\x10\\x00\\x0b\\x00\\x0b\\x00\\x00\\xc9\\xd6\\xc1\\xf4\\xf1\\xf0@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-04-15T00:00:00", "modifydate": "1994-04-15T04:10:00", "lines": 11, "newlines": 11, "modlines": 0, "user": "IOA410"}, "text": "PROC 0  APPLTYPE(S)  -\n        APPLID(CI)\n/****************************************************************\n/*                                                              *\n/*  CONTROL-M:   PRODUCTION CONTROL  SYSTEM          ( TSO)     *\n/*  CONTROL-O:   AUTOMATED CONSOLE MANAGEMENT SYSTEM ( TSO)     *\n/*  CONTROL-B:   QUALITY ASSURANCE SYSTEM            ( TSO)     *\n/*                                                              *\n/****************************************************************\n%IOAONL APPLTYPE(&APPLTYPE) APPLID(&APPLID)\nEND:END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "BMANJ": {"ttr": 2065, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x10_\\x00\\x94\\x10_\\x04\\x10\\x00\\x0b\\x00\\x0b\\x00\\x00\\xc9\\xd6\\xc1\\xf4\\xf1\\xf0@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-04-15T00:00:00", "modifydate": "1994-04-15T04:10:00", "lines": 11, "newlines": 11, "modlines": 0, "user": "IOA410"}, "text": "PROC 0  APPLTYPE(S)  -\n        APPLID(CJ)\n/****************************************************************\n/*                                                              *\n/*  CONTROL-M:   PRODUCTION CONTROL  SYSTEM      ( TSO)         *\n/*  CONTROL-D:   REPORT DISTRIBUTION SYSTEM      ( TSO)         *\n/*  CONTROL-B:   QUALITY ASSURANCE   SYSTEM      ( TSO)         *\n/*                                                              *\n/****************************************************************\n%IOAONL APPLTYPE(&APPLTYPE) APPLID(&APPLID)\nEND:END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "BMANV": {"ttr": 2067, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x10_\\x00\\x94\\x10_\\x04\\x10\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc9\\xd6\\xc1\\xf4\\xf1\\xf0@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-04-15T00:00:00", "modifydate": "1994-04-15T04:10:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "IOA410"}, "text": "PROC 0  APPLTYPE(S)  -\n        APPLID(CV)\n/****************************************************************\n/*                                                              *\n/*  CONTROL-M:   PRODUCTION CONTROL  SYSTEM          ( TSO)     *\n/*  CONTROL-D:   REPORT DISTRIBUTION SYSTEM          ( TSO)     *\n/*  CONTROL-O:   AUTOMATED CONSOLE MANAGEMENT SYSTEM ( TSO)     *\n/*  CONTROL-B:   QUALITY ASSURANCE   SYSTEM          ( TSO)     *\n/*                                                              *\n/****************************************************************\n%IOAONL APPLTYPE(&APPLTYPE) APPLID(&APPLID)\nEND:END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "BMCDB2": {"ttr": 2069, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x93\\x10\\x9f\\x00\\x93\\x10\\x9f\\x12\\x10\\x01\\xa6\\x01\\xa6\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-04-19T00:00:00", "modifydate": "1993-04-19T12:10:00", "lines": 422, "newlines": 422, "modlines": 0, "user": "TECH105"}, "text": "PROC 0 PGM()          /* PROGRAM TO EXECUTE              */ +\n       SSID(DB2)      /* DB2 SUBSYSTEM NAME              */ +\n       ACCESS(DIRECT) /* CTLG ACCESS DIRECT/INDIRECT     */ +\n       LOADLQ(LOAD)   /* LAST QUALIFIER FOR LOAD LIBS    */ +\n       PLIBLQ(PLIB)   /*  \"       \"      \"  PLIBS        */ +\n       MLIBLQ(MLIB)   /*  \"       \"      \"  MLIBS        */ +\n       SLIBLQ(SLIB)   /*  \"       \"      \"  SLIBS        */ +\n       TLIBLQ(TLIB)   /*  \"       \"      \"  TLIBS        */ +\n       CLSTLQ(CLIST)  /*  \"       \"      \"  CLIST LIBS   */ +\n       PCALL          /* PANEL CALL INDICATOR            */ +\n       DEBUG          /* IF SET WILL PRINT CLIST AS EX'D */\n/*----------------------------------------------------------------*/\n/*   GENERATED BY TECH105    ON 93/04/19     AT 12:10             */\n/*----------------------------------------------------------------*/\n/*----------------------------------------------------------------*/\n/*                                                                */\n/* BMCDB2 DRIVER CLIST TO INVOKE BMC DB2 ADMINISTRATIVE PRODUCTS  */\n/*                                                                */\n/* TIS 1.1.03 AUGUST 1992                                         */\n/*                                                                */\n/* THIS CLIST CAN BE USED TO DISPLAY A SELECTION MENU FOR THE     */\n/* BMC DB2 ADMINISTRATIVE PRODUCTS INSTALLED BY TIS.              */\n/*                                                                */\n/* THIS CLIST:                                                    */\n/* 1. PROCESSES ANY PARMS PASSED TO IT.                           */\n/* 2. LIBDEFS A PLIB TO DISPLAY THE SELECTION MENU.               */\n/* 3. AFTER A SELECTION IS MADE ON THE PANEL, THE CLIST IS        */\n/*    CALLED AGAIN WITH THE 'PCALL' PARAMETER.                    */\n/* 4. LIBDEFS TO ALL REQUIRED ISPF LIBRARIES                      */\n/* 5. SETS THE DEFAULT OPTIONS (DOPTS) MODULE NAME BASED ON THE   */\n/*    PRODUCT AND SSID SELECTED.                                  */\n/* 6. BUILDS THE EXECUTION PARAMETERS FOR EACH PRODUCT.           */\n/* 7. INVOKES EACH PRODUCT.                                       */\n/*                                                                */\n/*                                                                */\n/* EXAMPLES:                                                      */\n/*                                                                */\n/* 1. TO INVOKE THE SELECTION MENU:                               */\n/*                                                                */\n/*    EX 'SYSM.BMC.V1R2M04.MONITOR.INSTALL(BMCDB2)'               */\n/*                                                                */\n/*----------------------------------------------------------------*/\n/*                                                                */\n/* CUSTOMIZATION TIPS:                                            */\n/*                                                                */\n/* ALU = ALTER FOR DB2                                            */\n/* ASU = DASD MANAGER FOR DB2                                     */\n/* ACT = CATALOG MANAGER FOR DB2                                  */\n/* ACM = CHANGE MANAGER FOR DB2                                   */\n/* DOM = ACTIVITY MONITOR FOR DB2                                 */\n/* DDT = OPERTUNE FOR DB2                                         */\n/*                                                                */\n/* DEFAULTS SHOULD BE SET AFTER THE \"DEFAULTS\" COMMENT BLOCK.     */\n/*                                                                */\n/* CUSTOMIZATION AREAS FOR MAINTINSTALL ARE INDICTED BY           */\n/* 'MAINTINSTALL' COMMENT BLOCKS.                                 */\n/*                                                                */\n/* CUSTOMIZATION AREAS FOR SSIDINSTALL ARE INDICATED BY A         */\n/* 'SSIDINSTALL' COMMENT BLOCK.                                   */\n/*                                                                */\n/* CUSTOMIZATION AREAS FOR CATALOG INDIRECTION ARE INDICATED BY A */\n/* 'C-I-INSTALL' COMMENT BLOCK.                                   */\n/*                                                                */\n/* CUSTOMIZATION AREAS FOR MIGRINSTALL ARE INDICATED BY A         */\n/* 'MIGRINSTALL' COMMENT BLOCK.                                   */\n/*                                                                */\n/*----------------------------------------------------------------*/\n /*----------------------------------------------------------------*/\n /* SET DEBUG OPTION                                               */\n /*----------------------------------------------------------------*/\n IF &DEBUG \u00ac= DEBUG +\n    THEN CONTROL NOLIST NOMSG NOFLUSH\n    ELSE CONTROL SYM CON LIST\n /*----------------------------------------------------------------*/\n /* THE PCALL PARAMETER IS USED TO BYPASS DISPLAY OF THE SELECTION */\n /* MENU.                                                          */\n /*                                                                */\n /* NORMALLY, THIS CLIST DISPLAYS THE PANEL, WHICH CALLS (EXECUTES)*/\n /* THE CLIST AGAIN WITH THE PCALL PARM                            */\n /*----------------------------------------------------------------*/\n IF &PCALL = &STR() THEN DO\n    IF &ALTER = ALTER THEN SET OPT = 1\n    IF &DASD  = DASD  THEN SET OPT = 2\n    IF &CAT   = CAT   THEN SET OPT = 3\n    IF &ACM   = ACM   THEN SET OPT = 4\n    IF &DB2AM = DB2AM THEN SET OPT = 5\n    IF &DDT   = DB2AM THEN SET OPT = 6\n    ISPEXEC LIBDEF ISPPLIB +\n            DATASET ID('SYSM.BMC.V1R2M04.MONITOR.INSTALL')\n    ISPEXEC SELECT PANEL(BMCDB2PR) OPT(&OPT)\n    ISPEXEC LIBDEF ISPPLIB DATASET\n    EXIT CODE(0)\n END\n /*----------------------------------------------------------------*/\n /* SET DEFAULTS HERE                                              */\n /*----------------------------------------------------------------*/\n /* NOTE:  IF THE BMC PRODUCTS FOR DB2 WERE INSTALLED USING        */\n /*        DIFFERENT HIGH LEVEL QUALIFIERS (HLQ), YOU WILL NEED    */\n /*        TO RESOLVE THE \"HLQ\" VARIABLES (HLQ1, HLQ2, HLQ3) TO    */\n /*        THE DIFFERENT HIGH LEVEL QUALIFIERS USED FOR EACH       */\n /*        PRODUCT.                                                */\n /*                                                                */\n /*        IF  YOU ARE NOT USING A SINGLE APF LIBRARY, YOU WILL    */\n /*        NEED TO PROCEED TO SECTION \"SET THE PARMS FOR EACH      */\n /*        PRODUCT AND CALLED LOADLIB\" AND MAKE SURE VARIABLE      */\n /*        \"CALLOAD1\" USES THE APPROPRIATE \"HLQ#\" WHEN RESOLVING   */\n /*        THE LOAD LIBRARY NAME.                                  */\n /*----------------------------------------------------------------*/\n   SET HLQ1 = &STR(SYSM.BMC.V1R2M04.MONITOR)\n   SET HLQ2 = &STR()      /* OPTIONAL 2ND HLQ                    */\n   SET HLQ3 = &STR()      /* OPTIONAL 3RD HLQ                    */\n   SET HLQ4 = &STR()\n                          /* OPERTUNE HLQ FOR PROFILE DATASET    */\n   SET DB2LOAD1 = &STR()  /* DB2 LOADLIB 1                       */\n   SET DB2LOAD2 = &STR()  /* DB2 LOADLIB 2                       */\n   SET AEXLOAD  = &STR()  /* OPTIONAL LOABLIB FOR EXEC/JCL GEN   */\n                          /* DSNAME IN TICS.....                 */\n   SET APFLOAD = &STR()\n                          /* OPTIONAL SEPARATE APF LOADLIB       */\n                          /* NO TICS PLEASE                      */\n   SET TSOEVER = &SYSTSOE\n                          /* TSO EXTENSION VERSION               */\n   SET ALTCLIST = N       /* USE ALTLIB TO ACTIVATE CLIST        */\n /*----------------------------------------------------------------*/\n /* VALIDATE HLQ1 AND MANDATORY PROC PARMS                         */\n /*----------------------------------------------------------------*/\n IF &PCALL \u00ac= &STR() THEN DO\n    IF &HLQ1 = &STR() THEN DO\n        SET ZEDSMSG = &STR(\"HLQ1\" REQUIRED)\n        SET ZEDLMSG = &STR(THE DSNAME HIGH LEVEL QUALIFER WAS BLANK. +\n                         IT IS REQUIRED BY THE CLIST)\n        GOTO SEVERITY2\n    END\n    IF  &SSID = &STR() THEN DO\n        SET ZEDSMSG = &STR(SSID REQUIRED)\n        SET ZEDLMSG = &STR(THE DB2 SUBSYSTEM NAME IS REQUIRED. THE +\n                         PANEL DID NOT PASS A SSID NAME)\n        GOTO SEVERITY2\n    END\n END\n /*----------------------------------------------------------------*/\n /* OPTIONAL LOAD LIBRARY FOR EXECUTION/JCLGEN                     */\n /*----------------------------------------------------------------*/\n IF &SYSDSN(&AEXLOAD) = &STR(OK) +\n    THEN ISPEXEC VPUT (AEXLOAD) SHARED  /* GIVE TO JCL GEN PROCESS */\n /*----------------------------------------------------------------*/\n /* USE THE SPECIAL APF LOADLIB (IF ANY)                           */\n /*----------------------------------------------------------------*/\n IF &APFLOAD \u00ac= &STR() THEN DO\n    SET LOAD1    = '&APFLOAD'\n    SET CALLOAD1 = &APFLOAD\n END\n ELSE DO\n    SET LOAD1    = '&HLQ1..&LOADLQ'\n    SET CALLOAD1 = &STR()\n END\n /*----------------------------------------------------------------*/\n /* SET THE OTHER LIBRARIES AND CHECK TO SEE IF THEY EXIST         */\n /*----------------------------------------------------------------*/\n /*-------------------- LLIBS HERE --------------------------------*/\n  SET LOAD2 = '&HLQ2..&LOADLQ'\n  SET LOAD3 = '&HLQ3..&LOADLQ'\n  IF &SYSDSN(&LOAD1) \u00ac= &STR(OK) THEN SET LOAD1 = &STR()\n  IF &SYSDSN(&LOAD2) \u00ac= &STR(OK) THEN SET LOAD2 = &STR()\n  IF &SYSDSN(&LOAD3) \u00ac= &STR(OK) THEN SET LOAD3 = &STR()\n /*-------------------- PLIBS HERE --------------------------------*/\n  SET PLIB1 = '&HLQ1..&PLIBLQ'\n  SET PLIB2 = '&HLQ2..&PLIBLQ'\n  SET PLIB3 = '&HLQ3..&PLIBLQ'\n  IF &SYSDSN(&PLIB1) \u00ac= &STR(OK) THEN SET PLIB1 = &STR()\n  IF &SYSDSN(&PLIB2) \u00ac= &STR(OK) THEN SET PLIB2 = &STR()\n  IF &SYSDSN(&PLIB3) \u00ac= &STR(OK) THEN SET PLIB3 = &STR()\n /*-------------------- MLIBS HERE --------------------------------*/\n  SET MLIB1 = '&HLQ1..&MLIBLQ'\n  SET MLIB2 = '&HLQ2..&MLIBLQ'\n  SET MLIB3 = '&HLQ3..&MLIBLQ'\n  IF &SYSDSN(&MLIB1) \u00ac= &STR(OK) THEN SET MLIB1 = &STR()\n  IF &SYSDSN(&MLIB2) \u00ac= &STR(OK) THEN SET MLIB2 = &STR()\n  IF &SYSDSN(&MLIB3) \u00ac= &STR(OK) THEN SET MLIB3 = &STR()\n /*-------------------- SLIBS HERE --------------------------------*/\n  SET SLIB1 = '&HLQ1..&SLIBLQ'\n  SET SLIB2 = '&HLQ2..&SLIBLQ'\n  SET SLIB3 = '&HLQ3..&SLIBLQ'\n  IF &SYSDSN(&SLIB1) \u00ac= &STR(OK) THEN SET SLIB1 = &STR()\n  IF &SYSDSN(&SLIB2) \u00ac= &STR(OK) THEN SET SLIB2 = &STR()\n  IF &SYSDSN(&SLIB3) \u00ac= &STR(OK) THEN SET SLIB3 = &STR()\n /*-------------------- TLIBS HERE --------------------------------*/\n  SET TLIB1 = '&HLQ1..&TLIBLQ'\n  SET TLIB2 = '&HLQ2..&TLIBLQ'\n  SET TLIB3 = '&HLQ3..&TLIBLQ'\n  IF &SYSDSN(&TLIB1) \u00ac= &STR(OK) THEN SET TLIB1 = &STR()\n  IF &SYSDSN(&TLIB2) \u00ac= &STR(OK) THEN SET TLIB2 = &STR()\n  IF &SYSDSN(&TLIB3) \u00ac= &STR(OK) THEN SET TLIB3 = &STR()\n /*-------------------- CLIST HERE --------------------------------*/\n  IF &ALTCLIST = Y THEN DO\n     SET CLST1 = '&HLQ1..&CLSTLQ'\n     SET CLST2 = '&HLQ2..&CLSTLQ'\n     SET CLST3 = '&HLQ3..&CLSTLQ'\n     IF &SYSDSN(&CLST1) \u00ac= &STR(OK) THEN SET CLST1 = &STR()\n     IF &SYSDSN(&CLST2) \u00ac= &STR(OK) THEN SET CLST2 = &STR()\n     IF &SYSDSN(&CLST3) \u00ac= &STR(OK) THEN SET CLST3 = &STR()\n  END\n /*---------------------------------------------------------------*/\n /*  SET DOPTS MODULE NAMES BASED ON SSID AND CATALOG ACCESS      */\n /*---------------------------------------------------------------*/\n SELECT (&SSID)\n   /*-------------------------------------------------------------*/\n   /* SSIDINSTALL:                                                */\n   /*    - INSERT $S07BMC HERE                                    */\n   /* MIGRINSTALL:                                                */\n   /*    - INSERT $G08BMC HERE                                    */\n   /*-------------------------------------------------------------*/\n   WHEN (DSNX) DO\n     SET ASUDOPTD = &STR()\n     SELECT (&ACCESS)\n       WHEN (DIRECT) DO\n       /*-------------------------------------------------*/\n       /* MAINTINSTALL:                                   */\n       /*    - DELETE 4 SET STATEMENTS                    */\n       /*    - INSERT $M12BMC HERE FOR DSNX               */\n       /*-------------------------------------------------*/\n         SET ALUDOPT = &STR()\n         SET ASUDOPT = &STR()\n         SET ACTDOPT = &STR()\n         SET ACMDOPT = &STR()\n       END\n       WHEN (INDIRECT) DO\n       /*-------------------------------------------------*/\n       /* MAINTINSTALL:                                   */\n       /*    - DELETE 4 SET STATEMENTS                    */\n       /*    - INSERT $M12BMC HERE FOR DSNX               */\n       /* C-I-INSTALL:                                    */\n       /*    - DELETE GOTO CIERR STATEMEMT                */\n       /*    - INSERT $Z08BMC HERE FOR DSNX               */\n       /*-------------------------------------------------*/\n         GOTO CIERR\n       END\n       OTHERWISE GOTO ACCSERR\n     END\n   END\n   OTHERWISE DO\n     IF &PGM \u00ac= DDTNINIT THEN GOTO SSIDERR\n   END\n END\n /*----------------------------------------------------------------*/\n /* LIBDEF LOAD LIBRARIES                                          */\n /*----------------------------------------------------------------*/\n IF &LOAD1\u00ac=&STR() OR &LOAD2\u00ac=&STR() OR \u00ac=&STR() THEN DO\n    ISPEXEC LIBDEF ISPLLIB DATASET +\n    ID( &LOAD1   +\n        &LOAD2   +\n        &LOAD3   +\n        &DB2LOAD1 +\n        &DB2LOAD2 ) COND\n END\n ELSE DO\n    SET ZEDSMSG = &STR(LOADLIB REQUIRED)\n    SET ZEDLMSG = &STR(AT LEAST ONE LOAD LIBRARY IS REQUIRED TO +\n                     EXECUTE THE BMC DB2 PRODUCTS)\n    GOTO SEVERITY2\n END\n /*----------------------------------------------------------------*/\n /* LIBDEF ALL OTHER NECESSARY LIBRARIES                           */\n /*----------------------------------------------------------------*/\n IF &PLIB1\u00ac=&STR() OR &PLIB2\u00ac=&STR() OR &PLIB3\u00ac=&STR() THEN DO\n    ISPEXEC LIBDEF ISPPLIB DATASET +\n      ID( &PLIB1 +\n          &PLIB2 +\n          &PLIB3 ) COND\n END\n IF &MLIB1\u00ac=&STR() OR &MLIB2\u00ac=&STR() OR &MLIB3\u00ac=&STR() THEN DO\n    ISPEXEC LIBDEF ISPMLIB DATASET +\n      ID( &MLIB1 +\n          &MLIB2 +\n          &MLIB3 ) COND\n END\n IF &SLIB1\u00ac=&STR() OR &SLIB2\u00ac=&STR() OR &SLIB3\u00ac=&STR() THEN DO\n    ISPEXEC LIBDEF ISPSLIB DATASET +\n      ID( &SLIB1 +\n          &SLIB2 +\n          &SLIB3 ) COND\n END\n IF &TLIB1\u00ac=&STR() OR &TLIB2\u00ac=&STR() OR &TLIB3\u00ac=&STR() THEN DO\n    ISPEXEC LIBDEF ISPTLIB DATASET +\n      ID( &TLIB1 +\n          &TLIB2 +\n          &TLIB3 ) COND\n END\n /*----------------------------------------------------------------*/\n /* ALTLIB CLIST LIBRARY                                           */\n /*----------------------------------------------------------------*/\n IF &ALTCLIST = Y AND &TSOEVER NL &STR(2010) THEN DO\n    IF &CLST1\u00ac=&STR() OR &CLST2\u00ac=&STR() OR &CLST3\u00ac=&STR() THEN +\n       ALTLIB ACT APPLICATION(CLIST) +\n         DSNAME(&CLST1 +\n                &CLST2 +\n                &CLST3 ) COND\n END\n /*----------------------------------------------------------------*/\n /* SET THE PARMS FOR EACH PRODUCT AND CALLED LOADLIB IF NEEDED    */\n /*----------------------------------------------------------------*/\n /* NOTE:  IF THE BMC PRODUCTS FOR DB2 WERE INSTALLED USING        */\n /*        DIFFERENT HIGH LEVEL QUALIFIERS (HLQ) AND ALL THE       */\n /*        PRODUCTS LOAD MODULES WERE NOT COPIED TO A SINGLE       */\n /*        APF LIBRARY, YOU NEED TO RESOLVE THE \"HLQ\" VARIABLES    */\n /*        TO THE DIFFERENT HIGH LEVEL QUALIFIERS USED FOR EACH    */\n /*        PRODUCT.                                                */\n /*                                                                */\n /*        CHANGE \"HLQ1\" TO EITHER \"HLQ2\" OR \"HLQ3\" DEPENDING ON   */\n /*        THE HIGH LEVEL QUALIFIER SET IN THE PREVIOUS SECTION    */\n /*        \"SET DEFAULTS HERE\".                                    */\n /*                                                                */\n /*        FOR EXAMPLE, IF CATALOG MANAGER WAS INSTALLED IN THE    */\n /*        SET OF LIBRARIES WHOSE HIGH LEVEL QUALIFIER IS IN       */\n /*        \"&HLQ2\", THEN IN THE \"WHEN(ACTEMAIN)\" SECTION BELOW,    */\n /*        CHANGE THE SET STATEMENT FOR \"CALLOAD1\"                 */\n /*        FROM: CALLOAD1 = &HLQ1..&LOADLQ                         */\n /*        TO:   CALLOAD1 = &HLQ2..&LOADLQ                         */\n /*----------------------------------------------------------------*/\n SELECT (&PGM)\n    WHEN(ALTFRONT) DO   /* ALTER                                   */\n         SET PARM    = &STR(S=&SSID,O=&ALUDOPT,D=&ASUDOPTD)\n         IF &CALLOAD1   = &STR() THEN +\n            SET CALLOAD1 = &HLQ1..&LOADLQ\n    END\n    WHEN(ACTEMAIN) DO   /* CATALOG MANAGER                         */\n         SET PARM = &STR(S=&SSID,O=&ACTDOPT,D=&ASUDOPTD,+\n                            A=&ACMDOPT)\n         IF &CALLOAD1   = &STR() THEN +\n            SET CALLOAD1 = &HLQ1..&LOADLQ\n    END\n    WHEN(ASUFMAIN) DO   /* DASD MANAGER                            */\n         SET PARM    = &STR(&ASUDOPT)\n         IF &CALLOAD1   = &STR() THEN +\n            SET CALLOAD1 = &HLQ1..&LOADLQ\n    END\n    WHEN(ACMFRONT) DO   /* CHANGE MANAGER                          */\n         SET PARM    = &STR(S=&SSID,O=&ACMDOPT,D=&ASUDOPTD)\n         IF &CALLOAD1   = &STR() THEN +\n            SET CALLOAD1 = &HLQ1..&LOADLQ\n    END\n    WHEN(DOM)      DO   /* ACTIVITY MONITOR                        */\n         SET PARM    = &STR()\n    END\n    WHEN(DDTNINIT) DO   /* OPERTUNE                                */\n         SET PARM    = &STR()\n         IF &CALLOAD1   = &STR() THEN +\n            SET CALLOAD1 = &HLQ1..&LOADLQ\n    END\n    OTHERWISE DO\n         SET ZEDSMSG = &STR(INVALID PGM NAME)\n         SET ZEDLMSG = &STR(AN INVALID PROGRAM NAME WAS PASSED TO THE  +\n                       CLIST BY PANEL BMCDB2PR)\n         GOTO SEVERITY1\n    END\n END\n /*----------------------------------------------------------------*/\n /* INVOKE THE SELECTED BMC ADMINISTRATIVE PRODUCT FOR DB2         */\n /*                                                                */\n /* NOTE: ACTIVITY MONITOR AND OPERTUNE MUST BE SELECT             */\n /*----------------------------------------------------------------*/\n SELECT (&PGM)\n    WHEN(DOM) DO\n       ISPEXEC SELECT PGM(DOM) NEWAPPL(BMCM) PASSLIB\n    END\n    WHEN(DDTNINIT) DO\n       ALLOC F(DDTLOAD) DA('&CALLOAD1') SHR REUSE\n       ALLOC F(DDTPROFS) DA('&HLQ4..PROFILE') SHR REUSE\n       ALLOC F(DDTTRACE) SYSOUT REUSE\n       ISPEXEC LIBDEF ISPLLIB LIBRARY ID(DDTLOAD)\n       ISPEXEC SELECT PGM(DDTNINIT) NEWAPPL(BMCT) PASSLIB\n       FREE F(DDTLOAD DDTPROFS DDTTRACE)\n    END\n    OTHERWISE DO\n       CALL '&CALLOAD1(&PGM)' '&PARM'\n       IF &LASTCC \u00ac= 0 THEN GOTO CALLERR\n    END\n END\n /*----------------------------------------------------------------*/\n /* UN-LIBDEF ALL ISPF LIBRARIES AFTER WE ARE THROUGH              */\n /*----------------------------------------------------------------*/\n ISPEXEC LIBDEF ISPLLIB DATASET\n ISPEXEC LIBDEF ISPPLIB DATASET\n ISPEXEC LIBDEF ISPMLIB DATASET\n ISPEXEC LIBDEF ISPSLIB DATASET\n ISPEXEC LIBDEF ISPTLIB DATASET\n /*----------------------------------------------------------------*/\n /* ALTLIB RESET CLIST LIBRARY                                     */\n /*----------------------------------------------------------------*/\n IF &ALTCLIST = Y AND &TSOEVER NL &STR(2010) THEN DO\n    IF &CLST1\u00ac=&STR() OR &CLST2\u00ac=&STR() OR &CLST3\u00ac=&STR() THEN +\n       ALTLIB RES\n END\n EXIT CODE(0)\nSSIDERR: +\n SET ZEDSMSG = (\"SSID\" INVALID)\n SET ZEDLMSG = (BMCDB2 CANNOT FIND SSID. VERIFY PRODUCT INSTALLED +\n                     ON \"&SSID\")\n GOTO SEVERITY2\nCIERR: +\n SET ZEDSMSG = (\"C-I\" ERROR)\n SET ZEDLMSG = (CATALOG INDIRECTION NOT INSTALLED FOR THIS PRODUCT)\n GOTO SEVERITY2\nACCSERR: +\n SET ZEDSMSG = (\"CTLG ACCESS\" INVALID)\n SET ZEDLMSG = (BMCDB2PR PASSED \"&ACCESS\" AS A CATALOG ACCESS +\n                      AND IT MUST BE DIRECT OR INDIRECT)\n GOTO SEVERITY2\nCALLERR: +\n SET ZEDSMSG = (CLIST ERROR)\n SET ZEDLMSG = (THE BMCDB2 CLIST ENCOUNTER AN ERROR. PLEASE TRY +\n                      AGAIN USING DEBUG PARAMETER)\n GOTO SEVERITY2\nSEVERITY1: +\n ISPEXEC LIBDEF ISPLLIB DATASET\n ISPEXEC LIBDEF ISPPLIB DATASET\n ISPEXEC LIBDEF ISPMLIB DATASET\n ISPEXEC LIBDEF ISPSLIB DATASET\n ISPEXEC LIBDEF ISPTLIB DATASET\nSEVERITY2: +\n ISPEXEC SETMSG MSG(ISRZ001)\n EXIT CODE(8)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "BMCDB2PR": {"ttr": 2309, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x93\\x10\\x9f\\x00\\x93\\x10\\x9f\\x12\\x10\\x00\\x9a\\x00\\x9a\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-04-19T00:00:00", "modifydate": "1993-04-19T12:10:00", "lines": 154, "newlines": 154, "modlines": 0, "user": "TECH105"}, "text": ")ATTR DEFAULT(%+_)\n /*******************************************************************/\n /*   GENERATED BY TECH105    ON 93/04/19     AT 12:10\n /*******************************************************************/\n /********************************************************************/\n /*              C u s t o m i z a t i o n   N o t e s               */\n /********************************************************************/\n /*                                                                  */\n /* For assistance, please contact DB2 Product support at:           */\n /*   Outside TEXAS: 800-537-1813                                    */\n /*                                                                  */\n /* STEP 1:  (OPTIONAL)                                              */\n /*   Change the default subsystem id that is displayed for a first  */\n /*   time user of this selection menu. This panel has been          */\n /*   customized initially to have your ssid name.                   */\n /*                                                                  */\n /* STEP 2:  (OPTIONAL)                                              */\n /*   Modify the ISPF NEWAPPL for ALTER, DASD, and CAT. The          */\n /*   defaults as shipped are: ALTER=ALUA, DASD=ASUA, CAT=ACTA,      */\n /*   CHANGE=ACMA.                                                   */\n /*                                                                  */\n /*   We recommend unique NEWAPPL names for each ssid/product for    */\n /*   ALTER, DASD, CAT and CHANGE MANAGER                            */\n /*                                                                  */\n /*   ACTIVITY MONITOR and OPERTUNE do not need unique NEWAPPL       */\n /*   names.                                                         */\n /*                                                                  */\n /********************************************************************/\n+ type(text)   color(green)  intens(low)\n% type(text)   color(white)  intens(high)\n\u00a2 type(text)   color(blue)   intens(low)\n~ type(text)   color(turq)   intens(low)\n_ type(input)  color(turq)   intens(high)\n)BODY EXPAND(\\\\)\n\u00a2\\-\\BMC's DB2 Administration Series\\-\\\n+OPTION ===>_ZCMD\\ \\+\n+\n+\n+\n+   %1 ALTER for DB2 *          +- Change or migrate DB2 objects/structures\n+\n+   %2 DASD MANAGER for DB2 *   +- Manage or monitor DB2 physical objects\n+\n    %3 CATALOG MANAGER for DB2 *+- Execute DDL or query the DB2 Catalog\n+\n    %4 CHANGE MANAGER for DB2 * +- Manage changes to DB2 objects/structures\n+\n+   %5 ACTIVITY MONITOR for DB2 +- Monitor DB2\n+\n+   %6 OPERTUNE for DB2         +- Tune DB2\n+\n+\n+   %*+DB2 SSID . . . . . . . . . . ._Z   +\n+   %*+DB2 Catalog Access . . . . . ._Z       + (Direct)\n+\n+\n+    Enter%OPTION+to invoke the product, or%END+to return.\n+\n)INIT\n   .cursor = zcmd\n   .zvars  = 'ssidnm catopt'\n   /***********************************************/\n   /* STEP 1                                      */\n   /*   Optionally change the default SSID        */\n   /***********************************************/\n   if (&ssidnm = &z)\n       &ssidnm = 'DSNX'\n   if (&catopt = &z)\n       &catopt = 'DIRECT'\n)PROC\n   /***********************************************/\n   /* Assist in debugging the clist               */\n   /***********************************************/\n   vget (evdebug) profile\n   if (&zcmd = 'DEBUG','DEBUG ON')\n       &evdebug = 'DEBUG'\n       &zcmd = &z\n   else\n       if (&zcmd = 'DEBUG OFF')\n           &evdebug = &z\n           &zcmd = &z\n   /***********************************************/\n   /* Logic to handle the subsytem name is below: */\n   /* we validate the ssid and catalog access for */\n   /* ALTER, DASD MANAGER, CATALOG MANAGER and    */\n   /* CHANGE MANAGER.                             */\n   /***********************************************/\n   if (&zcmd = 1,2,3,4)\n      ver (&ssidnm,nb)\n      /***********************************************/\n      /* C-I-INSTALL:                                */\n      /*   - Change verify for INDIRECT here to look */\n      /*     look like the following:                */\n      /*                                             */\n      /* ver (&catopt,nb,list,'DIRECT','INDIRECT')   */\n      /***********************************************/\n      ver (&catopt,nb,list,'DIRECT')\n   /***********************************************************/\n   /* SSIDINSTALL:                                            */\n   /*    - Insert $S07BMCP following comment block            */\n   /* MAINTINSTALL:                                           */\n   /*    - Insert $M12BMCP following comment block            */\n   /* MIGRINSTALL:                                            */\n   /*    - Insert $G08BMCP following comment block            */\n   /*                                                         */\n   /* Example of code to support multiple SSIDs:              */\n   /*   if (&ssidnm = 'DB2?')                                 */\n   /*       &aluappl = 'ALU?'                                 */\n   /*       &asuappl = 'ASU?'                                 */\n   /*       &actappl = 'ACT?'                                 */\n   /*       &acmappl = 'ACM?'                                 */\n   /***********************************************************/\n   if (&ssidnm = 'DSNX')\n       &aluappl = 'ALUA'\n       &asuappl = 'ASUA'\n       &actappl = 'ACTA'\n       &acmappl = 'ACMA'\n   /***********************************************/\n   /* VPUT to profile for use across sessions     */\n   /***********************************************/\n   vput (evdebug ssidnm) profile\n   &ZSEL = TRANS( TRUNC( &ZCMD,'.' )\n       1,'CMD(EX ''SYSM.BMC.V1R2M04.MONITOR.INSTALL(BMCDB2)''         +\n             ''PGM(ALTFRONT) PCALL &evdebug +\n             ssid(&ssidnm)                  +\n             access(&catopt)'' )            +\n          newappl(&aluappl)'\n       2,'CMD(EX ''SYSM.BMC.V1R2M04.MONITOR.INSTALL(BMCDB2)''         +\n             ''PGM(ASUFMAIN) PCALL &evdebug +\n             ssid(&ssidnm)                  +\n             access(&catopt)'' )            +\n          newappl(&asuappl)'\n       3,'CMD(EX ''SYSM.BMC.V1R2M04.MONITOR.INSTALL(BMCDB2)''         +\n             ''PGM(ACTEMAIN) PCALL &evdebug +\n             ssid(&ssidnm)                  +\n             access(&catopt)'' )            +\n          newappl(&actappl)'\n       4,'CMD(EX ''SYSM.BMC.V1R2M04.MONITOR.INSTALL(BMCDB2)''         +\n             ''PGM(ACMFRONT) PCALL &evdebug +\n             ssid(&ssidnm)                  +\n             access(&catopt)'' )            +\n          newappl(&acmappl)'\n       5,'CMD(EX ''SYSM.BMC.V1R2M04.MONITOR.INSTALL(BMCDB2)''         +\n             ''PGM(DOM) PCALL &evdebug      +\n             ssid(DSNX)'' )                +\n          newappl'\n       6,'CMD(EX ''SYSM.BMC.V1R2M04.MONITOR.INSTALL(BMCDB2)''         +\n             ''PGM(DDTNINIT) PCALL &evdebug '') +\n          newappl'\n     ' ',' '\n       X,'EXIT'\n       *,'?' )\n   &ZTRAIL = .TRAIL\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "BULDCMDS": {"ttr": 2313, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x03\\x00\\x00\\x00\\x91!\\x1f\\x00\\x91!\\x1f\\x12\\x14\\x00'\\x00\\x19\\x00\\x14\\xc9\\xc2\\xd4\\xe4\\xe2\\xc5\\xd9@@@\"", "ispf": {"version": "01.03", "flags": 0, "createdate": "1991-07-30T00:00:00", "modifydate": "1991-07-30T12:14:00", "lines": 39, "newlines": 25, "modlines": 20, "user": "IBMUSER"}, "text": "/* REXX Build an ISPF command application table              */\ntrue  = 1;\nfalse = 0;\neof = false;\nnull = \"\";\nuid = userid();\naddress \"ISPEXEC\";\ndsname = uid\".USER.CNTLLIB\";\naddress \"TSO\" \"ALLOC F(DDLOOK) DA('\"dsname\"(TABLCMDS)') OLD\";\n\"TBTOP  ISPCMDS\";\noutrec.1 = \"<!DOCTYPE DM SYSTEM ()>\";\noutrec.2 = \"<CMDTBL APPLID=ISP>\";\ni = 2;\ndo while (\u00aceof);\n   \"TBSKIP ISPCMDS\";\n   \"TBGET  ISPCMDS\";\n    if rc\u00ac=0 then do;\n         eof = true;\n         iterate;\n         end;\n    i = i+1;\n    outrec.i=\" <CMD NAME=\"zctverb\">\";\n    if zcttrunc>0 then ,\n         outrec.i=outrec.i||substr(zctverb,1,zcttrunc)\"<T>\"|| ,\n            substr(zctverb,zcttrunc+1);\n    i = i+1;\n    if substr(zctact,1,7)=\"SELECT \" | ,\n       substr(zctact,1,6)=\"ALIAS \" | ,\n       substr(zctact,1,1)=\"%\" ,\n          then ,\n    outrec.i=\"    <CMDACT ACTION='\"zctact\"'>\";\n    else ,\n    outrec.i=\"    <CMDACT ACTION=\"zctact\">\";\nend;\ni = i+1;\noutrec.i = \"</CMDTBL>\";\naddress \"TSO\" \"EXECIO * DISKW DDLOOK (FINIS STEM OUTREC.\";\nsay \"Output is in dsname \"dsname\"(TABLCMDS)\";\nexit 0;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CAICLS02": {"ttr": 2315, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0b\\x00\\x00\\x00\\x91(\\x0f\\x00\\x93\\x17O\\x15\\t\\x00$\\x00+\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf3@@@'", "ispf": {"version": "01.11", "flags": 0, "createdate": "1991-10-07T00:00:00", "modifydate": "1993-06-23T15:09:00", "lines": 36, "newlines": 43, "modlines": 0, "user": "TECH103"}, "text": "/*   REXX EXEC :  CA-DYNAM/TLMS 5.3 TSO ONLINE TRANSACTION  INTERFACE   */\n\nTRACE O\n/*     */\nHOUSE_KEEPING:\nADDRESS TSO\nCAIVMF   = 'SYSS.TLMS.V5R3M0.VMF'\nCAIVMFI  = 'SYSS.TLMS.V5R3M0.VMF'\nCAIVMFXI = 'SYSS.TLMS.V5R3M0.VMFINDEX.CLUSTER'\nCAIHELP  = 'SYSS.TLMS.V5R3M0.HELPLIB'\n\"ALLOC F(CAIVMFI) DA('\"CAIVMF\"') SHR\"\n\"ALLOC F(CAIVMF)  DA('\"CAIVMF\"') SHR\"\n\"ALLOC F(CAIVMFXI) DA('\"CAIVMFXI\"') SHR\"\n\"ALLOC F(CAIHELP) DA('\"CAIHELP\"') SHR\"\n/*     */\nDISPLAY_MAIN_PANEL:\nADDRESS ISPEXEC\n\"CONTROL DISPLAY LINE START(1)\"\nADDRESS TSO \"TLTPTSO\"\n\"CONTROL DISPLAY REFRESH\"\nIF SRC > 8 THEN DO\n   \"FREE F(CAIVMF)\"\n   \"FREE F(CAIVMFI)\"\n   \"FREE F(CAIVMFXI)\"\n   \"FREE F(CAIHELP)\"\n   SAY '*** PANEL ERROR: ERROR DISPLAYING PANEL ( CATLMSP1 ). ***'\n   SAY '*** CATLMS TSO ONLINE TRANSACTION CANCELLED - RC = 'SRC'. ***   '\nEND\n/*     */\nEXIT_TLMS:\nADDRESS TSO\n\"FREE F(CAIVMF)\"\n\"FREE F(CAIVMFI)\"\n\"FREE F(CAIVMFXI)\"\n\"FREE F(CAIHELP)\"\nEXIT 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CARTSALL": {"ttr": 2317, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x92\\x02O\\x00\\x93\\x14o\\x10&\\x00\\x11\\x00\\x11\\x00\\x00\\xe7\\xd6\\xd3\\xc4\\xf1@@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1992-01-24T00:00:00", "modifydate": "1993-05-26T10:26:00", "lines": 17, "newlines": 17, "modlines": 0, "user": "XOLD1"}, "text": " PROC 0\n SET VARLIST = &STR(ZTIME ZJDATE COUNT DSNWHOLE)\n ISPEXEC VGET (&VARLIST) SHARED\n SET HOUR = &SUBSTR(1:2,&ZTIME)\n SET MINS = &SUBSTR(4:5,&ZTIME)\n SET &HHMM = &STR(&HOUR)&STR(&MINS)\n SET YEAR = &SUBSTR(1:2,&ZJDATE)\n SET DAYS = &SUBSTR(4:6,&ZJDATE)\n SET &YYDDD = &STR(&YEAR)&STR(&DAYS)\n SET VARLIS2 = &STR(COUNT DSNWHOLE)\n SET &COUNT = &COUNT + 1\n SET &BASENAME = &STR(CARTS23)\n SET &DSNWHOLE = &STR(&SYSUID..&BASENAME..D&YYDDD..T&HHMM..F&COUNT)\n ISPEXEC VPUT (&VARLIS2) SHARED\n ALLOC FI(CONTROLT) DA('&DSNWHOLE.') +\n       NEW  BLKSIZE(8000) LRECL(5000) +\n       SP(2,1) TRACKS RECFM(V B) DSORG(PS)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CARTSFRE": {"ttr": 2319, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x92\\x02O\\x00\\x92\\x02O\\x14\\x16\\x00\\x02\\x00\\x02\\x00\\x00\\xe7\\xd6\\xd3\\xc4@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1992-01-24T00:00:00", "modifydate": "1992-01-24T14:16:00", "lines": 2, "newlines": 2, "modlines": 0, "user": "XOLD"}, "text": " PROC 0\n FREE FI(CONTROLT)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CARTSSUB": {"ttr": 2321, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x92\\x02O\\x00\\x92\\x13\\x9f\\t\\x13\\x00\\x0e\\x00\\x0e\\x00\\x00\\xe7\\xd6\\xd3\\xc4@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1992-01-24T00:00:00", "modifydate": "1992-05-18T09:13:00", "lines": 14, "newlines": 14, "modlines": 0, "user": "XOLD"}, "text": "PROC 0\n/*******************************************************************/\n/*                                                                 */\n/* THIS CLIST SUBMITS CARTS-TS FOR BACKGROUND EXECUTION            */\n/*                                                                 */\n/*******************************************************************/\n SET VARLIST = &STR(ZTEMPF)\n ISPEXEC VGET (&VARLIST) SHARED\nSUBMIT '&ZTEMPF'\n/*******************************************************************/\n/* EXIT-ALL DONE                                                   */\n/*******************************************************************/\nDONE: +\n  EXIT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CARTSTS": {"ttr": 2323, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0b\\x00\\x00\\x00\\x92\"\\x7f\\x00\\x93\\x18\\x9f\\x14B\\x00\\x98\\x00\\x87\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf3@@@'", "ispf": {"version": "01.11", "flags": 0, "createdate": "1992-08-14T00:00:00", "modifydate": "1993-07-08T14:42:00", "lines": 152, "newlines": 135, "modlines": 0, "user": "TECH103"}, "text": "PROC 0\n/*******************************************************************/\n/*   CREATE TEMPORARY TABLE FILE                                   */\n/*                                                                 */\n/*******************************************************************/\nCONTROL NOMSG\nSET &TBLNAME = &SYSUID..$$@@TBL.TABLE\nFREE F(TEMPTBL TTBL)\nDEL '&TBLNAME'\nATTR TTBL BLKSIZE(3120) LRECL(80) RECFM(F B) DSORG(PO)\nALLOC F(TEMPTBL) DA('&TBLNAME') USING(TTBL) NEW SP(5 1) TR DIR(10)\nFREE F(TEMPTBL TTBL)\nSET XSPTABL = &STR('&TBLNAME')\nCONTROL MSG\n/*******************************************************************/\n/*                                                                 */\n/* THIS CLIST STARTS THE ISPF INTERFACE OF CARTS-TS                */\n/*                                                                 */\n/*******************************************************************/\n/*******************************************************************/\n/* SET DATASET NAMES ASSIGNED TO VARIOUS CARTS-TS FILES            */\n/*******************************************************************/\n/*******************************************************************/\n/* REPLACE THE CHARACTER STRING BETWEEN THE ' WITH                 */\n/*   THE SAME DATASET NAMES YOU USED WHEN ORIGINALLY               */\n/*   DOWNLOADED THE CARTS-TS DISRTIBUTION TAPE                     */\n/*******************************************************************/\nSET CARTPLIB = &STR('SYSS.CARTS.V3R0M0.ISPPLIB')\nSET CARTLOAD = &STR('SYS1.CARTS.V3R0M0.LOADLIB')\nSET CARTSLIB = &STR('SYSS.CARTS.V3R0M0.ISPSLIB')\nSET CARTCLIB = &STR('SYSS.CARTS.V3R0M0.CLISTLIB')\nSET XSPFILE  = &STR('SYSS.CARTS.V3R0M0.TAILOR')\n/*******************************************************************/\nISPEXEC VPUT (CARTPLIB CARTLOAD CARTSLIB XSPFILE) SHARED\nISPEXEC VPUT (CARTCLIB) SHARED\nISPEXEC VPUT (XSPTABL) SHARED\n/*******************************************************************/\n/* ASSIGN THE TEMPORARY CARTS-TS LIBRARIES                         */\n/*******************************************************************/\nISPEXEC LIBDEF ISPLLIB DATASET ID(&CARTLOAD.)\nISPEXEC LIBDEF ISPPLIB DATASET ID(&CARTPLIB.)\nISPEXEC LIBDEF ISPSLIB DATASET ID(&CARTSLIB.)\nISPEXEC LIBDEF ISPTLIB DATASET ID(&XSPTABL.)\n/*******************************************************************/\n/* ALLOC ISPF TAILOR FILE                                          */\n/*******************************************************************/\nALLOC FI(ISPFILE) DA(&XSPFILE) SHR\n/*******************************************************************/\n/* ALLOCATE THE CARTS-TS ISPTABL FILE                              */\n/*   THE FOLLOWING SUB-CLIST WILL DETERMINE IF ISPTABL IS          */\n/*   CURRENTLY ALLOCATED, FREE THE EXISTING DATASET NAME AND       */\n/*   ALLOCATE THE CARTS-TS ISPTABL DATASET.  THE ORIGINAL          */\n/*   DATASET ALLOCATED WILL BE RESTORED AT THE END OF              */\n/*   THIS CLIST.                                                   */\n/*******************************************************************/\nSET OLDTABLS = N        /* SET ISPTABL SWITCH TO OFF */\n SET SYSDVAL = 32767 1\n READDVAL SYSOUTTRAP I SYSPROCDSNS DDNAME\n LISTA ST\n SET BL = &SUBSTR(1:03,                            )\n DO WHILE &DDNAME \u00ac= ISPTABL AND &I <= &SYSOUTLINE\n    SET  X = &STR(&&SYSOUTLINE&I)\n    IF &SUBSTR(1:2,&X.&BL) = &BL +\n    THEN SET DDNAME = &SUBSTR(3:10,&X)\n    SET I = &I + 1\n      END\nIF &DDNAME = ISPTABL +\nTHEN\n    SET I = &I - 2\n    SET OLDTABLS = Y\n    SET OLDTABL = &STR(&&SYSOUTLINE&I)\n    ISPEXEC VPUT (OLDTABL OLDTABLS) SHARED\n    FREE FI(ISPTABL)\n\nALLOC FI(ISPTABL) DA(&XSPTABL) SHR\n\n/*******************************************************************/\n/* CONCATENATE THE CARTS-TS CLISTL FILE                            */\n/*   THE FOLLOWING SUB-CLIST WILL DETERMINE IF SYSPROC IS          */\n/*   CURRENTLY ALLOCATED, FREE THE EXISTING DATASET NAME(S) AND    */\n/*   ALLOCATE THE CARTS-TS CLISTL DATASET.  THE ORIGINAL           */\n/*   DATASET(S) ALLOCATED WILL BE RESTORED AT THE END OF           */\n/*   THIS CLIST.                                                   */\n/*******************************************************************/\n SET SYSDVAL = 32767 1\n READDVAL SYSOUTTRAP I SYSLIBSDSNS DDNAME\n LISTA ST\n SET BL = &SUBSTR(1:03,                            )\n DO WHILE &DDNAME \u00ac= SYSPROC AND &I <= &SYSOUTLINE\n    SET  X = &STR(&&SYSOUTLINE&I)\n    IF &SUBSTR(1:2,&X.&BL) = &BL +\n    THEN SET DDNAME = &SUBSTR(3:10,&X)\n    SET I = &I + 1\n   END\n\n   IF &DDNAME = SYSPROC +\n   THEN DO\n          SET I = &I - 2\n          SET DSN = &&SYSOUTLINE&I\n          SET SYSLIBSDSNS = '&DSN'\n          DO WHILE &I +3 <= &SYSOUTLINE\n            SET I = &I +3\n            SET DSN = &&SYSOUTLINE&I\n            IF &SUBSTR(1:5,&DSN,&BL.&BL) \u00ac= &BL +\n            THEN SET I = &SYSOUTLINE\n            ELSE DO\n                   SET I = &I-1\n                   SET DSN = &&SYSOUTLINE&I\n                   SET SYSLIBSDSNS = &STR(&SYSLIBSDSNS '&DSN')\n                 END\n          END\n        END\nFREE FI(SYSPROC)\nALLOC FI(SYSPROC) DA(&SYSLIBSDSNS &CARTCLIB) SHR REUSE\n/*******************************************************************/\n/* START CARTS-TS UPDATE/HISTORY INQUIRY INTERFACE                 */\n/*******************************************************************/\nISPEXEC SELECT PGM(CARTSTSO)\n/*******************************************************************/\n/* DEALLOC ISPF TAILOR FILE                                        */\n/*******************************************************************/\nFREE FI(ISPFILE)\n/*******************************************************************/\n/* RELEASE THE CARTSTS-TS LIBRARIES                                */\n/*******************************************************************/\nISPEXEC LIBDEF ISPLLIB\nISPEXEC LIBDEF ISPSLIB\nISPEXEC LIBDEF ISPPLIB\nISPEXEC LIBDEF ISPTLIB\nISPEXEC VGET (OLDTABL) SHARED\nFREE FI(ISPTABL)\nIF OLDTABL \u00ac= +\nTHEN DO\n    ALLOC FI(ISPTABL) DA('&OLDTABL') SHR REUSE\nEND\nIF &STR(&SYSLIBSDSNS) = +\nTHEN DO\n      CONTROL NOMSG\n      FREE FI(SYSPROC)\n     END\nELSE ALLOC FI(SYSPROC) DA(&SYSLIBSDSNS) SHR REUSE\nCONTROL NOMSG\n/*******************************************************************/\n/* DELETE TEMPORARY TABLE FILE                                     */\n/*******************************************************************/\nDEL '&TBLNAME'\nCONTROL MSG\n/*******************************************************************/\n/* EXIT-ALL DONE                                                   */\n/*******************************************************************/\nDONE: +\n  EXIT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CCFBKOUT": {"ttr": 2563, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x00\\x00\\x94$_\\x00\\x950\\x0f\\x10\\x15\\x06\\x06\\x06\\x05\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf3@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1994-09-02T00:00:00", "modifydate": "1995-10-27T10:15:00", "lines": 1542, "newlines": 1541, "modlines": 0, "user": "TECH103"}, "text": "/*  REXX EXEC : ( CCFBKOUT ).\n    FUNCTION  :  FACILITATES THE LIB/CCF BACKOUT OF A CHANGE REQUEST\n                 WORKORDER (CR/WO) IN SELECTIVE MEMBER MODE OR GROUP\n                 MODE FOR THE THE ENTIRE CR/WO.\n                 THE CR/WO \"MUST' HAVE ALREADY BEEN PROMOTED INTO THE\n                 PRODUCTION LIBRARIAN MASTERS AND LOAD LIBRARIES.\n    AUTHOR    :  DAN BOWEN, TECH SERVICES.\n                                                                      */\n\nTRACE O\n/*     */\nHOUSE_KEEPING:\nADDRESS TSO\nX = MSG(\"OFF\")\nC = 0\nJ = 0\nP = 0\nR = 0\nS = 0\nI = 0\nH = 0\nDB = 0\nDC = 0\nDR = 0\nEC = 0\nEJ = 0\nEP = 0\nER = 0\nES = 0\nEI = 0\nLB = 0\nLC = 0\nAST = '********'\nMODCNT = 0\nTSOID = SYSVAR(SYSUID)\nCDAY = DATE(W)\nCDATE = DATE(U)\nMVS = 'SYSA'\nCLASS = 'P'\nCOMPMSG = 'DB2 BACKOUT COMPILE'\nACCTCDE = '5302010530000000'\nCICSLANG = 'BMSMAP CICSCOB CICSCOB2 DMSMAP'\nMEMBER_TYPES = 'COPYBOOK JCL PROC RAMIS SOURCE SYSIN'\nSYSMAST = 'SYS1.SYSTEM.CONTROL.MASTER'\nHISTMAST = 'SYS1.HISTSRCE.MASTER'\nMASTER = 'SYS1.PRODSRCE.MASTER'\nPARMLIB = 'SYSS.TECH.COMMON.PARMLIB'\nCNTLLIB = 'SYSS.QA.CCF.BACKOUT.CNTLLIB'\nQACCF = 'SYSS.QA.CCF.DB2.TURNOVER.PARMLIB'\n\"FREE FILE(CCFDD)\"\n\"FREE FILE(PARMDD)\"\nWDSN = SYSDSN(\"'\"CNTLLIB\"'\")\nIF WDSN = 'DATASET NOT FOUND' THEN SIGNAL STAGING_PDS_ERROR\nFROMLIB.1 = 'SYS1.PRODCOPY.MASTER'\nFROMLIB.2 = 'SYS1.PRODJCL.MASTER'\nFROMLIB.3 = 'SYS1.PRODPROC.MASTER'\nFROMLIB.4 = 'SYS1.PRODRAMI.MASTER'\nFROMLIB.5 = 'SYS1.PRODSRCE.MASTER'\nFROMLIB.6 = 'SYS1.PRODSYSI.MASTER'\nDESTLIB.1 = 'SYS1.BACKCOPY.MASTER'\nDESTLIB.2 = 'SYS1.BACKJCL.MASTER'\nDESTLIB.3 = 'SYS1.BACKPROC.MASTER'\nDESTLIB.4 = 'SYS1.BACKRAMI.MASTER'\nDESTLIB.5 = 'SYS1.BACKSRCE.MASTER'\nDESTLIB.6 = 'SYS1.BACKSYSI.MASTER'\nCALL CHECK_USER_AUTHORIZATION\nIF AUTHSW = 'NO' THEN SIGNAL AUTHORIZATION_ERROR\n/*\n        M A I N   R O U T I N E   S E C T I O N      */\n/*     */\nDISPLAY_RUN_OPTION_PANEL:\nADDRESS ISPEXEC\n\"CONTROL ERRORS RETURN\"\n\"DISPLAY PANEL(CCFBKPNL)\"\nSRC = RC\nIF SRC = 0 & BKOPT = 1 THEN SIGNAL BACKOUT_ALL\nIF SRC = 0 & BKOPT = 2 THEN SIGNAL BACKOUT_SELECTIVE\nIF SRC = 8 & WORKORDR = '' THEN EXIT 0\nADDRESS TSO\n\"FREE F(CCFDD)\"\nSAY '*** PANEL ERROR: ISPF DIALOG ERROR INVOKING PANEL ( CCFBKPNL ). ***'\nSAY '*** CCF BACKOUT MAIN TASK CANCELLED - RETURN CODE: ('SRC'). ***'\nEXIT SRC\n/*     */\nBACKOUT_ALL:\nSAY\nSAY 'B A C K O U T   J O B S T R E A M   B U I L D   I N   P R O G R E S S'\nSAY\nSAY 'PLEASE WAIT ...'\nSAY\nCALL CHECK_CRWO_SYSMAST_MEMBER\nCALL GET_CRWO_MODULE_NAMES\nCALL BUILD_LIBRCOPY_JOBSTREAM\nCALL BUILD_GPO_ARCHIVE_RESTORE_JOBSTREAM\nCALL BUILD_GPO_DELETE_MODULE_JOBSTREAM\nIF SCNT = 0 THEN DO\n   E = 1\n   JCL.1 = \"//\"\n   CALL WRITE_LBACKOUT_JCL2\n   CALL SUBMIT_BACKOUT_JOB\n   EXIT 0\nEND\nB = 0\nC = 0\nDB2SW = 'NO'\nDO S = 1 TO SCNT\n   CALL BUILD_IEBCOPY_LOAD_MODULE_NAMES\n   IF DYLSW = 'YES' THEN CALL BUILD_DYL280_LOAD_MODULE_NAMES\nEND\nCALL BUILD_IEBCOPY_LOADLIB_JOBSTREAM\nCALL BUILD_DELETE_LOADLIB_JOBSTREAM\nCALL SUBMIT_BACKOUT_JOB\nIF DB2SW = 'YES' THEN DO\n   CALL CHECK_DB2_PARMS_MEMBER\n   SAY\n   SAY '===>  DB2 MEMBER(S) BACKOUT IN PROGRESS ...'\n   SAY '+++ COMPILE/BIND JOB(S) WILL BE SUBMITTED AS SOURCE MEMBER NAME. +++'\n   IF DB > 0 THEN DO D = 1 TO DB\n      MEMBER = DB2BAT.D\n      SKELJCL = 'CCFDB2P1'\n      CALL SUBMIT_DB2_SKELETON_COMPILE_JCL\n   END\n   IF DC > 0 THEN DO D = 1 TO DC\n      MEMBER = DB2CICS.D\n      SKELJCL = 'CCFDB2P2'\n      CALL SUBMIT_DB2_SKELETON_COMPILE_JCL\n   END\nEND\nSAY\nSAY 'B A C K O U T   J O B S T R E A M   B U I L D   C O M P L E T E'\nSAY\nEXIT 0\n/*     */\nBACKOUT_SELECTIVE:\nCALL CHECK_CRWO_SYSMAST_MEMBER\nCALL GET_CRWO_MODULE_NAMES\nCALL INIT_SCREEN_MEMBER_PARM\nMODCNT = 0\nDO Y = 1 TO 6\n   MEMTYPE = WORD(MEMBER_TYPES,Y)\n   LABEL = 'DISPLAY_MEMBER_SELECTION_PANEL'Y\n   INTERPRET CALL LABEL\nEND\nIF MODCNT = 0 THEN DO\n   SAY\n   SAY '*** NO MEMBER(S) SELECTED FOR BACKOUT. ***'\n   SAY '*** LIB/CCF BACKOUT TASK TERMINATED FOR 'WORKORDR' - RC = (024). ***'\n   EXIT 024\nEND\nCALL BUILD_LIBRCOPY_JOBSTREAM\nCALL BUILD_GPO_ARCHIVE_RESTORE_JOBSTREAM\nCALL BUILD_GPO_DELETE_MODULE_JOBSTREAM\nIF SCNT = 0 THEN DO\n   E = 1\n   JCL.1 = \"//\"\n   CALL WRITE_LBACKOUT_JCL2\n   CALL SUBMIT_BACKOUT_JOB\n   EXIT 0\nEND\nB = 0\nC = 0\nDB2SW = 'NO'\nDO S = 1 TO SCNT\n   CALL BUILD_IEBCOPY_LOAD_MODULE_NAMES\n   IF DYLSW = 'YES' THEN CALL BUILD_DYL280_LOAD_MODULE_NAMES\nEND\nCALL BUILD_IEBCOPY_LOADLIB_JOBSTREAM\nCALL BUILD_DELETE_LOADLIB_JOBSTREAM\nCALL SUBMIT_BACKOUT_JOB\nIF DB2SW = 'YES' THEN DO\n   CALL CHECK_DB2_PARMS_MEMBER\n   SAY\n   SAY '===>  DB2 MEMBER(S) BACKOUT IN PROGRESS ...'\n   SAY '+++ COMPILE/BIND JOB(S) WILL BE SUBMITTED AS SOURCE MEMBER NAME. +++'\n   IF DB > 0 THEN DO D = 1 TO DB\n      MEMBER = DB2BAT.D\n      SKELJCL = 'CCFDB2P1'\n      CALL SUBMIT_DB2_SKELETON_COMPILE_JCL\n   END\n   IF DC > 0 THEN DO D = 1 TO DC\n      MEMBER = DB2CICS.D\n      SKELJCL = 'CCFDB2P2'\n      CALL SUBMIT_DB2_SKELETON_COMPILE_JCL\n   END\nEND\nSAY\nSAY 'B A C K O U T   J O B S T R E A M   B U I L D   C O M P L E T E'\nSAY\nEXIT 0\n/*\n        S U B R O U T I N E S   S E C T I O N       */\n/*     */\nCHECK_CRWO_SYSMAST_MEMBER:\nADDRESS TSO\nWOLEN = LENGTH(WORKORDR)\nIF WOLEN \u00ac= 8 THEN SIGNAL INVALID_WORKORDR_NUMBER\nWOKEY = SUBSTR(WORKORDR,1,2)\nIF WOKEY \u00ac= 'WO' THEN SIGNAL INVALID_WORKORDR_NUMBER\nWONUM = SUBSTR(WORKORDR,3,6)\nWOTYP = DATATYPE(WONUM)\nIF WOTYP \u00ac= 'NUM' THEN SIGNAL INVALID_WORKORDR_NUMBER\nWO = WORKORDR\nZRMEMB = 'ZR'||WONUM\nDO F = 1 TO 2\n   IF F = 1 THEN MEMBER = ZRMEMB\n   IF F = 2 THEN MEMBER = WORKORDR\n   LIBDSN = \"'\"SYSMAST\"(\"MEMBER\")'\"\n   LIBDD = LIBALLOC(LIBDSN)\n   IF LIBDD = \"ERROR\" THEN SIGNAL SYSMAST_ALLOC_ERROR\n   MASTDD = LIBALLOC(\"'\"SYSMAST\"'\")\n   IF MASTDD = \"ERROR\" THEN SIGNAL SYSMAST_ALLOC_ERROR\n   MASTMEM = XLIBEMEM(MASTDD,MEMBER)\n   IF MASTMEM = \"\"  THEN DO\n      \"EXECIO 0 DISKR\" LIBDD \"(FINIS\"\n      \"EXECIO 0 DISKR\" MASTDD \"(FINIS\"\n      \"FREE F(\"LIBDD\")\"\n      \"FREE F(\"MASTDD\")\"\n      ITERATE\n   END\n   LEAVE\nEND\n\"EXECIO 0 DISKR\" MASTDD \"(FINIS\"\n\"FREE F(\"MASTDD\")\"\nIF MASTMEM = \"\"  THEN SIGNAL CRWO_MODULE_NOT_FOUND\nRETURN\n/*     */\nGET_CRWO_MODULE_NAMES:\nADDRESS TSO\n\"EXECIO * DISKR\" LIBDD \"(STEM WODATA. FINIS\"\nSRC = RC\nIF SRC \u00ac= 0 THEN SIGNAL SYSMAST_MODULE_READ_ERROR\nDO L = 1 TO 6\n   DO D = 1 TO WODATA.0\n      PRODKEY = POS('TO: PROD',WODATA.D)\n      IF PRODKEY \u00ac= 0 THEN DO\n         MODNAME = WORD(WODATA.D,1)\n         EXCLMOD = 'XXXXXXXX'\n         CRWO = WORD(WODATA.D,3)\n         IF CRWO \u00ac= WORKORDR THEN ITERATE\n      END\n      FROMMAST = POS('FROM MASTER:',WODATA.D)\n      IF FROMMAST \u00ac= 0 THEN DO\n         EMRGLIB = POS('EMRG',WODATA.D)\n         IF EMRGLIB \u00ac= 0 THEN DO\n            LIBRMAST = WORD(WODATA.D,3)\n            CALL INVALID_BACKOUT_LIBRARY\n            LABEL = 'BUILD_MODULE_EXCLUDE_LIST'L\n            INTERPRET CALL LABEL\n            ITERATE\n         END\n      END\n      TOMAST = POS('TO   MASTER:',WODATA.D)\n      IF TOMAST \u00ac= 0 THEN DO\n         MASTDSN = WORD(WODATA.D,3)\n         IF MASTDSN = FROMLIB.L THEN DO\n            LABEL = 'BUILD_MODULE_LIST'L\n            LABELSW = 'YES'\n         END\n      END\n      VERSION = POS('VERS=',WODATA.D)\n      IF VERSION \u00ac= 0 THEN DO\n         DELETESW = 'NO'\n         NEWVERS = POS('VERS= *NEW*',WODATA.D)\n         IF NEWVERS \u00ac= 0 THEN DELETESW = 'YES'\n         IF LABELSW = 'YES' THEN DO\n            INTERPRET CALL LABEL\n            LABELSW = 'NO'\n         END\n      END\n   END\nEND\nEMRGCNT = H\nRETURN\n/*     */\nINVALID_BACKOUT_LIBRARY:\nEXCLMOD = MODNAME\nSAY\nSAY '*** INVALID BACKOUT LIBRARY: ('LIBRMAST'). ***'\nSAY '+++ MODULE: ('MODNAME') WILL NOT BE INCLUDED IN BACKOUT. +++'\nSAY '+++ MODULES LAST TURNED OVER FROM AN EMERGENCY ID ARE EXCLUDED. +++'\nSAY '+++ PLEASE NOTE AND TAKE APPROPRIATE ACTION, IF ANY. +++'\nSAY '===> TO CONTINUE, HIT ENTER ...'\nPULL OK\nRETURN\n/*     */\nBUILD_MODULE_LIST1:\nIF MODNAME = EXCLMOD THEN RETURN\nC = C + 1\nMODCNT = MODCNT + 1\nCOPYMEM.C = MODNAME\nCOPYSW.C = DELETESW\nRETURN\n/*     */\nBUILD_MODULE_LIST2:\nIF MODNAME = EXCLMOD THEN RETURN\nJ = J + 1\nMODCNT = MODCNT + 1\nJCLMEM.J = MODNAME\nJCLSW.J = DELETESW\nRETURN\n/*     */\nBUILD_MODULE_LIST3:\nIF MODNAME = EXCLMOD THEN RETURN\nP = P + 1\nMODCNT = MODCNT + 1\nPROCMEM.P = MODNAME\nPROCSW.P = DELETESW\nRETURN\n/*     */\nBUILD_MODULE_LIST4:\nIF MODNAME = EXCLMOD THEN RETURN\nR = R + 1\nMODCNT = MODCNT + 1\nRAMIMEM.R = MODNAME\nRAMISW.R = DELETESW\nRETURN\n/*     */\nBUILD_MODULE_LIST5:\nIF MODNAME = EXCLMOD THEN RETURN\nS = S + 1\nMODCNT = MODCNT + 1\nSRCEMEM.S = MODNAME\nSRCESW.S = DELETESW\nRETURN\n/*     */\nBUILD_MODULE_LIST6:\nIF MODNAME = EXCLMOD THEN RETURN\nI = I + 1\nMODCNT = MODCNT + 1\nSYSIMEM.I = MODNAME\nSYSISW.I = DELETESW\nRETURN\n/*     */\nBUILD_MODULE_EXCLUDE_LIST1:\nEC = EC + 1\nECOPY.EC = MODNAME\nRETURN\n/*     */\nBUILD_MODULE_EXCLUDE_LIST2:\nEJ = EJ + 1\nEJCL.EJ = MODNAME\nRETURN\n/*     */\nBUILD_MODULE_EXCLUDE_LIST3:\nEP = EP + 1\nEPROC.EP = MODNAME\nRETURN\n/*     */\nBUILD_MODULE_EXCLUDE_LIST4:\nER = ER + 1\nERAMI.ER = MODNAME\nRETURN\n/*     */\nBUILD_MODULE_EXCLUDE_LIST5:\nES = ES + 1\nESRCE.ES = MODNAME\nRETURN\n/*     */\nBUILD_MODULE_EXCLUDE_LIST6:\nEI = EI + 1\nESYSI.EI = MODNAME\nRETURN\n/*     */\nBUILD_LIBRCOPY_JOBSTREAM:\nADDRESS TSO\nIF MODCNT = 0 THEN SIGNAL BACKOUT_QUALIFY_ERROR\n\"ALLOC DA('\"CNTLLIB\"(\"WORKORDR\")') F(CCFDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN SIGNAL STAGING_PDS_ALLOC_ERROR\nMEM = WORKORDR\nWO = WORKORDR\nCCNT = C\nJCNT = J\nPCNT = P\nRCNT = R\nSCNT = S\nICNT = I\nRCD.1 = \"//\"WO\" JOB \"ACCTCDE\",'LIBCCF.BACKOUT.CRWO',NOTIFY=\"TSOID\",\"\nRCD.2 = \"//     CLASS=P,MSGCLASS=G,MSGLEVEL=(1,1),REGION=6M\"\nW = 2\nCALL WRITE_LBACKOUT_JCL1\nRCD.2 = \"//SYSPRINT DD SYSOUT=*\"\nRCD.3 = \"//LIST     DD SYSOUT=*\"\nRCD.4 = \"//INDEX    DD SYSOUT=*\"\nRCD.7 = \"//OSJOB    DD DSN=&&CPYMEMB,UNIT=SYSDA,\"\nRCD.8 = \"//         DCB=(RECFM=FB,LRECL=80,BLKSIZE=8000),\"\nRCD.9 = \"//         SPACE=(CYL,(9,1)),DISP=(NEW,PASS)\"\nRCD.10 = \"//SYSIN    DD *\"\nRCD.11 = \"-OPT UTILITY\"\nJCL.1 = \"-EMOD\"\nJCL.2 = \"-END\"\nJCL.3 = \"/*\"\nJCL.5 = \"/*\"\nJCL.7 = \"//SYSPRINT DD SYSOUT=*\"\nJCL.8 = \"//SYSUDUMP DD SYSOUT=Y\"\nJCL.9 = \"//SYSABEND DD SYSOUT=Y\"\nJCL.10 = \"//LIST DD SYSOUT=*\"\nJCL.11 = \"//INDEX DD SYSOUT=*\"\nJCL.12 = \"//OSJOB DD DUMMY\"\nJCL.14 = \"//SYSIN    DD DSN=&&CPYMEMB,DISP=(OLD,DELETE)\"\nJCL.15 = \"/*\"\nJCL.17 = \"/*\"\nDO L = 1 TO 6\n   W = 11\n   LABEL = 'GET_LIBRCOPY_MODNAME'||L\n   INTERPRET CALL LABEL\n   IF MODSW = 'NO' THEN ITERATE\n   CPYSTEP1 = WORD('SELCOPY SELJCL SELPROC SELRAMI SELSRCE SELSYSI',L)\n   ABEND1 = WORD('ABCOPY1 ABJCL1 ABPROC1 ABRAMI1 ABSRCE1 ABSYSI1',L)\n   RCD.1 = \"//\"CPYSTEP1\" EXEC PGM=LIBRCOPY\"\n   RCD.5 = \"//MASTER   DD DSN=\"FROMLIB.L\",DISP=SHR\"\n   RCD.6 = \"//DESTMAST DD DSN=\"DESTLIB.L\",DISP=SHR\"\n   CALL WRITE_LBACKOUT_JCL1\n   E = 17\n   JCL.4 = \"//\"ABEND1\" EXEC PGM=ABENDWTO,COND=(0,GE,\"CPYSTEP1\")\"\n   CPYSTEP2 = WORD('CPYCOPY CPYJCL CPYPROC CPYRAMI CPYSRCE CPYSYSI',L)\n   ABEND2 = WORD('ABCOPY2 ABJCL2 ABPROC2 ABRAMI2 ABSRCE2 ABSYSI2',L)\n   JCL.6 = \"//\"CPYSTEP2\" EXEC PGM=AFOLIBR,PARM='NRJS,NJTA'\"\n   JCL.13 = \"//MASTER   DD DSN=\"DESTLIB.L\",DISP=SHR\"\n   JCL.16 = \"//\"ABEND2\" EXEC PGM=ABENDWTO,COND=(0,GE,\"CPYSTEP2\")\"\n   CALL WRITE_LBACKOUT_JCL2\nEND\nRETURN\n/*     */\nGET_LIBRCOPY_MODNAME1:\nMODSW = 'NO'\nIF CCNT = 0 THEN RETURN\nDO C = 1 TO CCNT\n   EXCLSW = 'NO'\n   IF EC  > 0 THEN DO H = 1 TO EC\n      IF ECOPY.H = COPYMEM.C THEN EXCLSW = 'YES'\n   END\n   IF EXCLSW = 'YES' THEN ITERATE\n   MODSW = 'YES'\n   W = W + 1\n   RCD.W = '-COPY' COPYMEM.C\nEND\nRETURN\n/*     */\nGET_LIBRCOPY_MODNAME2:\nMODSW = 'NO'\nIF JCNT = 0 THEN RETURN\nDO J = 1 TO JCNT\n   EXCLSW = 'NO'\n   IF EJ > 0 THEN DO H = 1 TO EJ\n      IF EJCL.H = JCLMEM.J THEN EXCLSW = 'YES'\n   END\n   IF EXCLSW = 'YES' THEN ITERATE\n   MODSW = 'YES'\n   W = W + 1\n   RCD.W = '-COPY' JCLMEM.J\nEND\nRETURN\n/*     */\nGET_LIBRCOPY_MODNAME3:\nMODSW = 'NO'\nIF PCNT = 0 THEN RETURN\nDO P = 1 TO PCNT\n   EXCLSW = 'NO'\n   IF EP > 0 THEN DO H = 1 TO EP\n      IF EPROC.H = PROCMEM.P THEN EXCLSW = 'YES'\n   END\n   IF EXCLSW = 'YES' THEN ITERATE\n   MODSW = 'YES'\n   W = W + 1\n   RCD.W = '-COPY' PROCMEM.P\nEND\nRETURN\n/*     */\nGET_LIBRCOPY_MODNAME4:\nMODSW = 'NO'\nIF RCNT = 0 THEN RETURN\nDO R = 1 TO RCNT\n   EXCLSW = 'NO'\n   IF ER > 0 THEN DO H = 1 TO ER\n      IF ERAMI.H = RAMIMEM.R THEN EXCLSW = 'YES'\n   END\n   IF EXCLSW = 'YES' THEN ITERATE\n   MODSW = 'YES'\n   W = W + 1\n   RCD.W = '-COPY' RAMIMEM.R\nEND\nRETURN\n/*     */\nGET_LIBRCOPY_MODNAME5:\nMODSW = 'NO'\nIF SCNT = 0 THEN RETURN\nDO S = 1 TO SCNT\n   EXCLSW = 'NO'\n   IF ES > 0 THEN DO H = 1 TO ES\n      IF ESRCE.H = SRCEMEM.S THEN EXCLSW = 'YES'\n   END\n   IF EXCLSW = 'YES' THEN ITERATE\n   MODSW = 'YES'\n   W = W + 1\n   RCD.W = '-COPY' SRCEMEM.S\nEND\nRETURN\n/*     */\nGET_LIBRCOPY_MODNAME6:\nMODSW = 'NO'\nIF ICNT = 0 THEN RETURN\nDO I = 1 TO ICNT\n   EXCLSW = 'NO'\n   IF EI > 0 THEN DO H = 1 TO EI\n      IF ESYSI.H = SYSIMEM.I THEN EXCLSW = 'YES'\n   END\n   IF EXCLSW = 'YES' THEN ITERATE\n   MODSW = 'YES'\n   W = W + 1\n   RCD.W = '-COPY' SYSIMEM.I\nEND\nRETURN\n/*     */\nBUILD_GPO_ARCHIVE_RESTORE_JOBSTREAM:\nRCD.2 = \"//SYSPRINT DD SYSOUT=*\"\nRCD.3 = \"//LIST     DD SYSOUT=*\"\nRCD.4 = \"//INDEX    DD SYSOUT=*\"\nRCD.5 = \"//SYSAF01  DD UNIT=SYSDA,SPACE=(TRK,(30,30))\"\nRCD.6 = \"//SYSAF02  DD UNIT=SYSDA,SPACE=(TRK,(30,30))\"\nRCD.8 = \"//OSJOB    DD DSN=&&ARCMEMB,UNIT=SYSDA,\"\nRCD.9 = \"//         DCB=(RECFM=FB,LRECL=80,BLKSIZE=8000),\"\nRCD.10 = \"//         SPACE=(CYL,(9,1)),DISP=(NEW,PASS)\"\nRCD.11 = \"//SYSIN    DD *\"\nRCD.12 = \"-OPT GPO\"\nJCL.1 = \"-EMOD\"\nJCL.2 = \"-END\"\nJCL.3 = \"/*\"\nJCL.5 = \"/*\"\nJCL.7 = \"//SYSPRINT DD SYSOUT=*\"\nJCL.8 = \"//SYSUDUMP DD SYSOUT=Y\"\nJCL.9 = \"//SYSABEND DD SYSOUT=Y\"\nJCL.10 = \"//LIST DD SYSOUT=*\"\nJCL.11 = \"//INDEX DD SYSOUT=*\"\nJCL.12 = \"//OSJOB DD DUMMY\"\nJCL.14 = \"//SYSIN    DD DSN=&&ARCMEMB,DISP=(OLD,DELETE)\"\nJCL.15 = \"/*\"\nJCL.17 = \"/*\"\nDO L = 1 TO 6\n   W = 12\n   LABEL = 'GET_GPOARCH_MODNAME'||L\n   INTERPRET CALL LABEL\n   IF MODSW = 'NO' THEN ITERATE\n   ARCSTEP1 = WORD('ARCCOPY ARCJCL ARCPROC ARCRAMI ARCSRCE ARCSYSI',L)\n   ABEND3 = WORD('ABCOPY3 ABJCL3 ABPROC3 ABRAMI3 ABSRCE3 ABSYSI3',L)\n   RCD.1 = \"//\"ARCSTEP1\" EXEC PGM=AFOLIBR,PARM='NRJS,NJTA'\"\n   RCD.7 = \"//MASTER   DD DSN=\"FROMLIB.L\",DISP=SHR\"\n   W = W + 1\n   RCD.W = \"-HST\" WO \"TURNOVER BACKOUT BY:\" TSOID \"ON:\" CDAY CDATE\n   CALL WRITE_LBACKOUT_JCL1\n   E = 17\n   JCL.4 = \"//\"ABEND3\" EXEC PGM=ABENDWTO,COND=(0,GE,\"ARCSTEP1\")\"\n   ARCSTEP2 = WORD('REPCOPY REPJCL REPPROC REPRAMI REPSRCE REPSYSI',L)\n   ABEND4 = WORD('ABCOPY4 ABJCL4 ABPROC4 ABRAMI4 ABSRCE4 ABSYSI4',L)\n   JCL.6 = \"//\"ARCSTEP2\" EXEC PGM=AFOLIBR,PARM='NRJS,NJTA'\"\n   JCL.13 = \"//MASTER   DD DSN=\"FROMLIB.L\",DISP=SHR\"\n   JCL.16 = \"//\"ABEND4\" EXEC PGM=ABENDWTO,COND=(0,GE,\"ARCSTEP2\")\"\n   CALL WRITE_LBACKOUT_JCL2\nEND\nRETURN\n/*     */\nGET_GPOARCH_MODNAME1:\nMODSW = 'NO'\nIF CCNT = 0 THEN RETURN\nRCDSW = 'NO'\nDO C = 1 TO CCNT\n   IF COPYSW.C = 'YES' THEN ITERATE\n   IF RCDSW = 'YES' THEN DO\n      RCD.W = RCD.W||\"|\"\n      W = W + 1\n      RCD.W = \"-CON NAME=/\"COPYMEM.C\"/\"\n      ITERATE\n   END\n   EXCLSW = 'NO'\n   IF EC > 0 THEN DO H = 1 TO EC\n      IF ECOPY.H = COPYMEM.C THEN EXCLSW = 'YES'\n   END\n   IF EXCLSW = 'YES' THEN ITERATE\n   MODSW = 'YES'\n   W = W + 1\n   RCDSW = 'YES'\n   RCD.W = \"-SEL NAME=/\"COPYMEM.C\"/\"\nEND\nIF RCDSW = 'NO' THEN RETURN\nRCD.W = RCD.W||\",VERS,ARC=-1\"\nRETURN\n/*     */\nGET_GPOARCH_MODNAME2:\nMODSW = 'NO'\nIF JCNT = 0 THEN RETURN\nRCDSW = 'NO'\nDO J = 1 TO JCNT\n   IF JCLSW.J = 'YES' THEN ITERATE\n   IF RCDSW = 'YES' THEN DO\n      RCD.W = RCD.W||\"|\"\n      W = W + 1\n      RCD.W = \"-CON NAME=/\"JCLMEM.J\"/\"\n      ITERATE\n   END\n   EXCLSW = 'NO'\n   IF EJ > 0 THEN DO H = 1 TO EJ\n      IF EJCL.H = JCLMEM.J THEN EXCLSW = 'YES'\n   END\n   IF EXCLSW = 'YES' THEN ITERATE\n   MODSW = 'YES'\n   W = W + 1\n   RCDSW = 'YES'\n   RCD.W = \"-SEL NAME=/\"JCLMEM.J\"/\"\nEND\nIF RCDSW = 'NO' THEN RETURN\nRCD.W = RCD.W||\",VERS,ARC=-1\"\nRETURN\n/*     */\nGET_GPOARCH_MODNAME3:\nMODSW = 'NO'\nIF PCNT = 0 THEN RETURN\nRCDSW = 'NO'\nDO P = 1 TO PCNT\n   IF PROCSW.P = 'YES' THEN ITERATE\n   IF RCDSW = 'YES' THEN DO\n      RCD.W = RCD.W||\"|\"\n      W = W + 1\n      RCD.W = \"-CON NAME=/\"PROCMEM.P\"/\"\n      ITERATE\n   END\n   EXCLSW = 'NO'\n   IF EP > 0 THEN DO H = 1 TO EP\n      IF EPROC.H = PROCMEM.P THEN EXCLSW = 'YES'\n   END\n   IF EXCLSW = 'YES' THEN ITERATE\n   MODSW = 'YES'\n   W = W + 1\n   RCDSW = 'YES'\n   RCD.W = \"-SEL NAME=/\"PROCMEM.P\"/\"\nEND\nIF RCDSW = 'NO' THEN RETURN\nRCD.W = RCD.W||\",VERS,ARC=-1\"\nRETURN\n/*     */\nGET_GPOARCH_MODNAME4:\nMODSW = 'NO'\nIF RCNT = 0 THEN RETURN\nRCDSW = 'NO'\nDO R = 1 TO RCNT\n   IF RAMISW.R = 'YES' THEN ITERATE\n   IF RCDSW = 'YES' THEN DO\n      RCD.W = RCD.W||\"|\"\n      W = W + 1\n      RCD.W = \"-CON NAME=/\"RAMIMEM.R\"/\"\n      ITERATE\n   END\n   EXCLSW = 'NO'\n   IF ER > 0 THEN DO H = 1 TO ER\n      IF ERAMI.H = RAMIMEM.R THEN EXCLSW = 'YES'\n   END\n   IF EXCLSW = 'YES' THEN ITERATE\n   MODSW = 'YES'\n   W = W + 1\n   RCDSW = 'YES'\n   RCD.W = \"-SEL NAME=/\"RAMIMEM.R\"/\"\nEND\nIF RCDSW = 'NO' THEN RETURN\nRCD.W = RCD.W||\",VERS,ARC=-1\"\nRETURN\n/*     */\nGET_GPOARCH_MODNAME5:\nMODSW = 'NO'\nIF SCNT = 0 THEN RETURN\nRCDSW = 'NO'\nDO S = 1 TO SCNT\n   IF SRCESW.S = 'YES' THEN ITERATE\n   IF RCDSW = 'YES' THEN DO\n      RCD.W = RCD.W||\"|\"\n      W = W + 1\n      RCD.W = \"-CON NAME=/\"SRCEMEM.S\"/\"\n      ITERATE\n   END\n   EXCLSW = 'NO'\n   IF ES > 0 THEN DO H = 1 TO ES\n      IF ESRCE.H = SRCEMEM.S THEN EXCLSW = 'YES'\n   END\n   IF EXCLSW = 'YES' THEN ITERATE\n   MODSW = 'YES'\n   W = W + 1\n   RCDSW = 'YES'\n   RCD.W = \"-SEL NAME=/\"SRCEMEM.S\"/\"\nEND\nIF RCDSW = 'NO' THEN RETURN\nRCD.W = RCD.W||\",VERS,ARC=-1\"\nRETURN\n/*     */\nGET_GPOARCH_MODNAME6:\nMODSW = 'NO'\nIF ICNT = 0 THEN RETURN\nRCDSW = 'NO'\nDO I = 1 TO ICNT\n   IF SYSISW.I = 'YES' THEN ITERATE\n   IF RCDSW = 'YES' THEN DO\n      RCD.W = RCD.W||\"|\"\n      W = W + 1\n      RCD.W = \"-CON NAME=/\"SYSIMEM.I\"/\"\n      ITERATE\n   END\n   EXCLSW = 'NO'\n   IF EI > 0 THEN DO H = 1 TO EI\n      IF ESYSI.H = SYSIMEM.I THEN EXCLSW = 'YES'\n   END\n   IF EXCLSW = 'YES' THEN ITERATE\n   MODSW = 'YES'\n   W = W + 1\n   RCDSW = 'YES'\n   RCD.W = \"-SEL NAME=/\"SYSIMEM.I\"/\"\nEND\nIF RCDSW = 'NO' THEN RETURN\nRCD.W = RCD.W||\",VERS,ARC=-1\"\nRETURN\n/*     */\nBUILD_GPO_DELETE_MODULE_JOBSTREAM:\nC = 0\nJ = 0\nP = 0\nR = 0\nS = 0\nI = 0\nRCD.2 = \"//SYSPRINT DD SYSOUT=*\"\nRCD.3 = \"//LIST     DD SYSOUT=*\"\nRCD.4 = \"//INDEX    DD SYSOUT=*\"\nRCD.5 = \"//SYSAF01  DD UNIT=SYSDA,SPACE=(TRK,(30,30))\"\nRCD.6 = \"//SYSAF02  DD UNIT=SYSDA,SPACE=(TRK,(30,30))\"\nRCD.8 = \"//OSJOB    DD DSN=&&DELMEMB,UNIT=SYSDA,\"\nRCD.9 = \"//         DCB=(RECFM=FB,LRECL=80,BLKSIZE=8000),\"\nRCD.10 = \"//         SPACE=(CYL,(9,1)),DISP=(NEW,PASS)\"\nRCD.11 = \"//SYSIN    DD *\"\nRCD.12 = \"-OPT GPO\"\nJCL.1 = \"-END\"\nJCL.2 = \"/*\"\nJCL.4 = \"/*\"\nJCL.6 = \"//SYSPRINT DD SYSOUT=*\"\nJCL.7 = \"//SYSUDUMP DD SYSOUT=Y\"\nJCL.8 = \"//SYSABEND DD SYSOUT=Y\"\nJCL.9 = \"//LIST DD SYSOUT=*\"\nJCL.10 = \"//INDEX DD SYSOUT=*\"\nJCL.11 = \"//OSJOB DD DUMMY\"\nJCL.13 = \"//SYSIN    DD DSN=&&DELMEMB,DISP=(OLD,DELETE)\"\nJCL.14 = \"/*\"\nJCL.16 = \"/*\"\nDO L = 1 TO 6\n   W = 12\n   LABEL = 'GET_GPODELET_MODNAME'||L\n   INTERPRET CALL LABEL\n   IF MODSW = 'NO' THEN ITERATE\n   DELSTEP1 = WORD('DELCOPY DELJCL DELPROC DELRAMI DELSRCE DELSYSI',L)\n   ABEND5 = WORD('ABCOPY5 ABJCL5 ABPROC5 ABRAMI5 ABSRCE5 ABSYSI5',L)\n   RCD.1 = \"//\"DELSTEP1\" EXEC PGM=AFOLIBR,PARM='NRJS,NJTA'\"\n   RCD.7 = \"//MASTER   DD DSN=\"FROMLIB.L\",DISP=SHR\"\n   CALL WRITE_LBACKOUT_JCL1\n   E = 16\n   JCL.3 = \"//\"ABEND5\" EXEC PGM=ABENDWTO,COND=(0,GE,\"DELSTEP1\")\"\n   DELSTEP2 = WORD('REMCOPY REMJCL REMPROC REMRAMI REMSRCE REMSYSI',L)\n   ABEND6 = WORD('ABCOPY6 ABJCL6 ABPROC6 ABRAMI6 ABSRCE6 ABSYSI6',L)\n   JCL.5 = \"//\"DELSTEP2\" EXEC PGM=AFOLIBR,PARM='NRJS,NJTA'\"\n   JCL.12 = \"//MASTER   DD DSN=\"FROMLIB.L\",DISP=SHR\"\n   JCL.15 = \"//\"ABEND6\" EXEC PGM=ABENDWTO,COND=(0,GE,\"DELSTEP2\")\"\n   CALL WRITE_LBACKOUT_JCL2\nEND\nRETURN\n/*     */\nGET_GPODELET_MODNAME1:\nMODSW = 'NO'\nIF CCNT = 0 THEN RETURN\nRCDSW = 'NO'\nDO C = 1 TO CCNT\n   IF COPYSW.C = 'NO' THEN ITERATE\n   IF RCDSW = 'YES' THEN DO\n      RCD.W = RCD.W||\"|\"\n      W = W + 1\n      RCD.W = \"-CON NAME=/\"COPYMEM.C\"/\"\n      ITERATE\n   END\n   W = W + 1\n   RCDSW = 'YES'\n   RCD.W = \"-DLM NAME=/\"COPYMEM.C\"/\"\nEND\nIF RCDSW = 'NO' THEN RETURN\nMODSW = 'YES'\nRETURN\n/*     */\nGET_GPODELET_MODNAME2:\nMODSW = 'NO'\nIF JCNT = 0 THEN RETURN\nRCDSW = 'NO'\nDO J = 1 TO JCNT\n   IF JCLSW.J = 'NO' THEN ITERATE\n   IF RCDSW = 'YES' THEN DO\n      RCD.W = RCD.W||\"|\"\n      W = W + 1\n      RCD.W = \"-CON NAME=/\"JCLMEM.J\"/\"\n      ITERATE\n   END\n   W = W + 1\n   RCDSW = 'YES'\n   RCD.W = \"-DLM NAME=/\"JCLMEM.J\"/\"\nEND\nIF RCDSW = 'NO' THEN RETURN\nMODSW = 'YES'\nRETURN\n/*     */\nGET_GPODELET_MODNAME3:\nMODSW = 'NO'\nIF PCNT = 0 THEN RETURN\nRCDSW = 'NO'\nDO P = 1 TO PCNT\n   IF PROCSW.P = 'NO' THEN ITERATE\n   IF RCDSW = 'YES' THEN DO\n      RCD.W = RCD.W||\"|\"\n      W = W + 1\n      RCD.W = \"-CON NAME=/\"PROCMEM.P\"/\"\n      ITERATE\n   END\n   W = W + 1\n   RCDSW = 'YES'\n   RCD.W = \"-DLM NAME=/\"PROCMEM.P\"/\"\nEND\nIF RCDSW = 'NO' THEN RETURN\nMODSW = 'YES'\nRETURN\n/*     */\nGET_GPODELET_MODNAME4:\nMODSW = 'NO'\nIF RCNT = 0 THEN RETURN\nRCDSW = 'NO'\nDO R = 1 TO RCNT\n   IF RAMISW.R = 'NO' THEN ITERATE\n   IF RCDSW = 'NO' THEN DO\n      RCD.W = RCD.W||\"|\"\n      W = W + 1\n      RCD.W = \"-CON NAME=/\"RAMIMEM.R\"/\"\n      ITERATE\n   END\n   W = W + 1\n   RCDSW = 'YES'\n   RCD.W = \"-DLM NAME=/\"RAMIMEM.R\"/\"\nEND\nIF RCDSW = 'NO' THEN RETURN\nMODSW = 'YES'\nRETURN\n/*     */\nGET_GPODELET_MODNAME5:\nMODSW = 'NO'\nIF SCNT = 0 THEN RETURN\nRCDSW = 'NO'\nDO S = 1 TO SCNT\n   IF SRCESW.S = 'NO' THEN ITERATE\n   IF RCDSW = 'YES' THEN DO\n      RCD.W = RCD.W||\"|\"\n      W = W + 1\n      RCD.W = \"-CON NAME=/\"SRCEMEM.S\"/\"\n      ITERATE\n   END\n   W = W + 1\n   RCDSW = 'YES'\n   RCD.W = \"-DLM NAME=/\"SRCEMEM.S\"/\"\nEND\nIF RCDSW = 'NO' THEN RETURN\nMODSW = 'YES'\nRETURN\n/*     */\nGET_GPODELET_MODNAME6:\nMODSW = 'NO'\nIF ICNT = 0 THEN RETURN\nRCDSW = 'NO'\nDO I = 1 TO ICNT\n   IF SYSISW.I = 'NO' THEN ITERATE\n   IF RCDSW = 'YES' THEN DO\n      RCD.W = RCD.W||\"|\"\n      W = W + 1\n      RCD.W = \"-CON NAME=/\"SYSIMEM.I\"/\"\n      ITERATE\n   END\n   W = W + 1\n   RCDSW = 'YES'\n   RCD.W = \"-DLM NAME=/\"SYSIMEM.I\"/\"\nEND\nIF RCDSW = 'NO' THEN RETURN\nMODSW = 'YES'\nRETURN\n/*     */\nBUILD_IEBCOPY_LOAD_MODULE_NAMES:\nADDRESS TSO\nLANGCODE = ''\nDYLSW = 'NO'\nLIBHST = \"'\"HISTMAST\"(\"SRCEMEM.S\")'\"\nHISTDD = LIBALLOC(LIBHST)\nIF HISTDD = \"ERROR\" THEN SIGNAL HISTMAST_ALLOC_ERROR\n\"DELSTACK\"\n\"EXECIO 1 DISKR\" HISTDD \"4 (FINIS\"\nSRC = RC\n\"FREE FILE(\"HISTDD\")\"\nIF SRC \u00ac= 0 THEN SIGNAL HISTMAST_EXECIO_ERROR\nPULL LANGCODE .\nIF (LANGCODE = 'CICSCOPY') | (LANGCODE = 'CICS2CPY') THEN RETURN\nIF LANGCODE = 'CICSDB2' THEN DO\n   IF SRCESW.S = 'YES' THEN DO\n      LC = LC + 1\n      DELCICS.LC = SRCEMEM.S\n      RETURN\n   END\n   DB2SW = 'YES'\n   DC = DC + 1\n   DB2CICS.DC = SRCEMEM.S\n   RETURN\nEND\nIF LANGCODE = 'COBDB2' THEN DO\n   IF SRCESW.S = 'YES' THEN DO\n      LB = LB + 1\n      DELBAT.LB = SRCEMEM.S\n      RETURN\n   END\n   DB2SW = 'YES'\n   DB = DB + 1\n   DB2BAT.DB = SRCEMEM.S\n   RETURN\nEND\nLANG = WORDPOS(LANGCODE,CICSLANG)\nIF LANG \u00ac= 0 THEN DO\n   IF SRCESW.S = 'YES' THEN DO\n      LC = LC + 1\n      DELCICS.LC = SRCEMEM.S\n      RETURN\n   END\n   C = C + 1\n   CICS.C = SRCEMEM.S\n   RETURN\nEND\nIF LANGCODE = 'DYL280' THEN DO\n   DYLSW = 'YES'\n   RETURN\nEND\nIF SRCESW.S = 'YES' THEN DO\n   LB = LB + 1\n   DELBAT.LB = SRCEMEM.S\n   RETURN\nEND\nB = B + 1\nBATCH.B = SRCEMEM.S\nRETURN\n/*     */\nBUILD_DYL280_LOAD_MODULE_NAMES:\nIF SRCESW.S = 'YES' THEN DO\n   LB = LB + 1\n   DELBAT.LB = SRCEMEM.S\n   CALL CHECK_DYL280_NUMBER_REPORTS\n   IF REPTSW = 'NO' THEN RETURN\n   DO M = 1 TO NUMREPTS\n      IF M = 1 THEN ITERATE\n      MLEN = LENGTH(M)\n      IF MLEN = 1 THEN DYLMOD = PREFIX||'0'M\n      IF MLEN = 2 THEN DYLMOD = PREFIX||M\n      LB = LB + 1\n      DELBAT.LB = DYLMOD\n   END\n   RETURN\nEND\nB = B + 1\nBATCH.B = SRCEMEM.S\nCALL CHECK_DYL280_NUMBER_REPORTS\nIF REPTSW = 'NO' THEN RETURN\nDO M = 1 TO NUMREPTS\n   IF M = 1 THEN ITERATE\n   MLEN = LENGTH(M)\n   IF MLEN = 1 THEN DYLMOD = PREFIX||'0'M\n   IF MLEN = 2 THEN DYLMOD = PREFIX||M\n   B = B + 1\n   BATCH.B = DYLMOD\nEND\nRETURN\n/*     */\nCHECK_DYL280_NUMBER_REPORTS:\nADDRESS TSO\nREPTSW = 'NO'\nMLEN = LENGTH(SRCEMEM.S)\nPREFIX = SUBSTR(SRCEMEM.S,1,MLEN)\nIF MLEN >= 6 THEN PREFIX = SUBSTR(SRCEMEM.S,1,6)\nLIBDSN = \"'\"MASTER\"(\"SRCEMEM.S\")'\"\nLIBDD = LIBALLOC(LIBDSN)\nIF LIBDD = \"ERROR\" THEN RETURN\n\"EXECIO 1 DISKR\" LIBDD \"(FINIS STEM REPORT.\"\nSRC = RC\n\"FREE F(\"LIBDD\")\"\nIF SRC \u00ac= 0 THEN RETURN\nREPTFLG = POS('* REPORTS = ',REPORT.1)\nIF REPTFLG = 0 THEN RETURN\nNUMREPTS = WORD(REPORT.1,4)\nIF NUMREPTS = '' THEN RETURN\nRTYP = DATATYPE(NUMREPTS)\nIF RTYP \u00ac= 'NUM' THEN RETURN\nIF NUMREPTS < 2 THEN RETURN\nREPTSW = 'YES'\nRETURN\n/*     */\nBUILD_IEBCOPY_LOADLIB_JOBSTREAM:\nBCNT = B\nCCNT = C\nB = 0\nC = 0\nCOPYM.1 = 'LOADCPYB'\nFDD.1 = 'INDDB  '\nTDD.1 = 'OUTDDB '\nFLOAD.1 = 'SYS1.BACKUP.BATCH.LOADLIB'\nTLOAD.1 = 'SYS1.PROD.BATCH.LOADLIB'\nCOPYM.2 = 'LOADCPYC'\nFDD.2 = 'INDDC  '\nTDD.2 = 'OUTDDC '\nFLOAD.2 = 'SYS1.BACKUP.CICS.LOADLIB'\nTLOAD.2 = 'SYS1.PROD.CICS.LOADLIB'\nDO L = 1 TO 2\n   LABEL = 'BUILD_IEBCOPY_SYSIN'||L\n   INTERPRET CALL LABEL\nEND\nRETURN\n/*     */\nBUILD_IEBCOPY_SYSIN1:\nIF BCNT = 0 THEN RETURN\nI = 0\nW = 0\nLOADSW = 'NO'\nCNTL = \"       SELECT MEMBER=(\"\nDO B = 1 TO BCNT\n   LOADMOD = SYSDSN(\"'\"FLOAD.1\"(\"BATCH.B\")'\")\n   IF LOADMOD = 'MEMBER NOT FOUND' THEN ITERATE\n   LOADSW = 'YES'\n   I = I + 1\n   IF I = 1 THEN SYSIN = CNTL||BATCH.B\n   IF (I > 1) & (I < 5) THEN SYSIN = SYSIN||\",\"||BATCH.B\n   IF (I = 5) THEN DO\n      W = W + 1\n      SYSIN = SYSIN||\",\"||BATCH.B||\")\"\n      RCD.W = SYSIN\n      I = 0\n   END\nEND\nIF LOADSW = 'NO' THEN RETURN\nCALL WRITE_IEBCOPY_JCL\nCALL WRITE_LBACKOUT_JCL2\nIF I > 0 THEN DO\n   W = W + 1\n   SYSIN = SYSIN||\")\"\n   RCD.W = SYSIN\nEND\nW = W + 1\nRCD.W = \"/*\"\nW = W + 1\nRCD.W = \"//ABEND7  EXEC PGM=ABENDWTO,COND=(0,GE,\"COPYM.L\")\"\nW = W + 1\nRCD.W = \"/*\"\nCALL WRITE_LBACKOUT_JCL1\nRETURN\n/*     */\nBUILD_IEBCOPY_SYSIN2:\nIF CCNT = 0 THEN RETURN\nI = 0\nW = 0\nLOADSW = 'NO'\nCNTL = \"       SELECT MEMBER=(\"\nDO C = 1 TO CCNT\n   LOADMOD = SYSDSN(\"'\"FLOAD.2\"(\"CICS.C\")'\")\n   IF LOADMOD = 'MEMBER NOT FOUND' THEN ITERATE\n   LOADSW = 'YES'\n   I = I + 1\n   IF I = 1 THEN SYSIN = CNTL||CICS.C\n   IF (I > 1) & (I < 5) THEN SYSIN = SYSIN||\",\"||CICS.C\n   IF (I = 5) THEN DO\n      W = W + 1\n      SYSIN = SYSIN||\",\"||CICS.C||\")\"\n      RCD.W = SYSIN\n      I = 0\n   END\nEND\nIF LOADSW = 'NO' THEN RETURN\nCALL WRITE_IEBCOPY_JCL\nCALL WRITE_LBACKOUT_JCL2\nIF I > 0 THEN DO\n   W = W + 1\n   SYSIN = SYSIN||\")\"\n   RCD.W = SYSIN\nEND\nW = W + 1\nRCD.W = \"/*\"\nW = W + 1\nRCD.W = \"//ABEND8  EXEC PGM=ABENDWTO,COND=(0,GE,\"COPYM.L\")\"\nW = W + 1\nRCD.W = \"/*\"\nCALL WRITE_LBACKOUT_JCL1\nRETURN\n/*     */\nWRITE_IEBCOPY_JCL:\nE = 11\nFROMDD = STRIP(FDD.L)\nJCL.1 = \"//\"COPYM.L\" EXEC PGM=IEBCOPY\"\nJCL.2 = \"//\"FDD.L\"  DD    DSN=\"FLOAD.L\",DISP=SHR\"\nJCL.3 = \"//\"TDD.L\"  DD    DSN=\"TLOAD.L\",DISP=SHR\"\nJCL.4 = \"//SYSPRINT DD    SYSOUT=*\"\nJCL.5 = \"//SYSUT1   DD    UNIT=SYSDA,SPACE=(CYL,(2,1))\"\nJCL.6 = \"//SYSUT2   DD    UNIT=SYSDA,SPACE=(CYL,(2,1))\"\nJCL.7 = \"//SYSUT3   DD    UNIT=SYSDA,SPACE=(CYL,(2,1))\"\nJCL.8 = \"//SYSUT4   DD    UNIT=SYSDA,SPACE=(CYL,(2,1))\"\nJCL.9 = \"//SYSIN    DD  *\"\nJCL.10 = \"  COPY OUTDD=\"TDD.L\nJCL.11 = \"       INDD=((\"FROMDD\",R))\"\nRETURN\n/*     */\nBUILD_DELETE_LOADLIB_JOBSTREAM:\nBCNT = LB\nCCNT = LC\nB = 0\nC = 0\nW = 0\nLOADSW = 'NO'\nLIBDEF = 'BATCHDD CICSDD'\nLOADLIB.1 = 'SYS1.PROD.BATCH.LOADLIB'\nLOADLIB.2 = 'SYS1.PROD.CICS.LOADLIB'\nDO L = 1 TO 2\n   LABEL = 'BUILD_DELETE_SYSIN'||L\n   LIBDD = WORD(LIBDEF,L)\n   INTERPRET CALL LABEL\nEND\nIF LOADSW = 'NO' THEN RETURN\nCALL WRITE_IDCAMS_DELMOD_JCL\nCALL WRITE_LBACKOUT_JCL2\nW = W + 1\nRCD.W = \"/*\"\nW = W + 1\nRCD.W = \"//ABEND9  EXEC PGM=ABENDWTO,COND=(0,GE,DLOADMOD)\"\nW = W + 1\nRCD.W = \"/*\"\nCALL WRITE_LBACKOUT_JCL1\nRETURN\n/*     */\nBUILD_DELETE_SYSIN1:\nIF BCNT = 0 THEN RETURN\nDO B = 1 TO BCNT\n   LOADMOD = SYSDSN(\"'\"LOADLIB.1\"(\"DELBAT.B\")'\")\n   IF LOADMOD = 'MEMBER NOT FOUND' THEN ITERATE\n   LOADSW = 'YES'\n   W = W + 1\n   RCD.W = \"  DELETE   \"LOADLIB.1\"(\"DELBAT.B\") FILE(\"LIBDD\")\"\nEND\nRETURN\n/*     */\nBUILD_DELETE_SYSIN2:\nIF CCNT = 0 THEN RETURN\nDO C = 1 TO CCNT\n   LOADMOD = SYSDSN(\"'\"LOADLIB.2\"(\"DELCICS.C\")'\")\n   IF LOADMOD = 'MEMBER NOT FOUND' THEN ITERATE\n   LOADSW = 'YES'\n   W = W + 1\n   RCD.W = \"  DELETE   \"LOADLIB.2\"(\"DELCICS.C\") FILE(\"LIBDD\")\"\nEND\nRETURN\n/*     */\nWRITE_IDCAMS_DELMOD_JCL:\nE = 5\nJCL.1 = \"//DLOADMOD EXEC PGM=IDCAMS\"\nJCL.2 = \"//BATCHDD  DD   DSN=\"LOADLIB.1\",DISP=SHR\"\nJCL.3 = \"//CICSDD   DD   DSN=\"LOADLIB.2\",DISP=SHR\"\nJCL.4 = \"//SYSPRINT DD   SYSOUT=*\"\nJCL.5 = \"//SYSIN    DD  *\"\nRETURN\n/*     */\nCHECK_DB2_PARMS_MEMBER:\nSRC = 028\nDB2PARM = SYSDSN(\"'\"QACCF\"(\"WORKORDR\")'\")\nIF DB2PARM = 'MEMBER NOT FOUND' THEN SIGNAL DB2PARM_MEMBER_ERROR\nRETURN\n/*     */\nSUBMIT_DB2_SKELETON_COMPILE_JCL:\nADDRESS ISPEXEC\n\"FTOPEN TEMP\"\nSRC = RC\nIF SRC \u00ac= 0 THEN SIGNAL SKELETON_JCL_BUILD_ERROR\n\"FTINCL $CCFJOBD\"\nSRC = RC\nIF SRC \u00ac= 0 THEN SIGNAL SKELETON_JCL_BUILD_ERROR\n\"FTINCL\" SKELJCL\nSRC = RC\nIF SRC \u00ac= 0 THEN SIGNAL SKELETON_JCL_BUILD_ERROR\n\"FTCLOSE\"\nSRC = RC\nIF SRC \u00ac= 0 THEN SIGNAL SKELETON_JCL_BUILD_ERROR\n\"VGET ZTEMPF\"\nADDRESS TSO \"SUBMIT '\"ZTEMPF\"'\"\nSRC = RC\nIF SRC \u00ac= 0 THEN SIGNAL SKELETON_JCL_BUILD_ERROR\nRETURN\n/*     */\nWRITE_LBACKOUT_JCL1:\nADDRESS TSO\n\"DELSTACK\"\nRCDCNT = W\nDO W = 1 TO RCDCNT\n   QUEUE RCD.W\nEND\n\"EXECIO\" RCDCNT \"DISKW CCFDD\"\nSRC = RC\nIF SRC \u00ac= 0 THEN SIGNAL PDS_WRITE_ERROR\nRETURN\n/*     */\nWRITE_LBACKOUT_JCL2:\nADDRESS TSO\n\"DELSTACK\"\nRCDCNT = E\nDO E = 1 TO RCDCNT\n   QUEUE JCL.E\nEND\n\"EXECIO\" RCDCNT \"DISKW CCFDD\"\nSRC = RC\nIF SRC \u00ac= 0 THEN SIGNAL PDS_WRITE_ERROR\nRETURN\n/*     */\nINIT_SCREEN_MEMBER_PARM:\nDO A = 1 TO 56\n   INTERPRET 'MEM'A '= AST'\nEND\nRETURN\n/*     */\nDISPLAY_MEMBER_SELECTION_PANEL1:\nCCNT = C\nIF CCNT = 0 THEN RETURN\nIF C > 56 THEN CCNT = 56\nC = 0\nEC = 0\nDO A = 1 TO CCNT\n   INTERPRET 'MEM'A '= COPYMEM.'A\nEND\nADDRESS ISPEXEC\n\"CONTROL ERRORS RETURN\"\n\"DISPLAY PANEL(CCFBKPNM)\"\nSRC = RC\nIF SRC = 0 THEN DO A = 1 TO CCNT\n   SELMEMB = VALUE('SM'A)\n   IF SELMEMB = 'S' THEN DO\n      C = C + 1\n      MODCNT = MODCNT + 1\n      COPYMEM.C = COPYMEM.A\n      COPYSW.C = COPYSW.A\n      ITERATE\n   END\n   EC = EC + 1\n   ECOPY.EC = COPYMEM.A\nEND\nIF SRC = 0 THEN RETURN\nIF SRC = 8 THEN EXIT 8\nSAY\nSAY '*** PANEL ERROR: ISPF DIALOG ERROR INVOKING PANEL ( CCFBKPNM ). ***'\nSAY '*** CCF BACKOUT MAIN TASK CANCELLED - RETURN CODE: ('SRC'). ***'\nEXIT SRC\n/*     */\nDISPLAY_MEMBER_SELECTION_PANEL2:\nJCNT = J\nIF JCNT = 0 THEN RETURN\nIF J > 56 THEN JCNT = 56\nJ = 0\nEJ = 0\nDO A = 1 TO JCNT\n   INTERPRET 'MEM'A '= JCLMEM.'A\nEND\nADDRESS ISPEXEC\n\"CONTROL ERRORS RETURN\"\n\"DISPLAY PANEL(CCFBKPNM)\"\nSRC = RC\nIF SRC = 0 THEN DO A = 1 TO JCNT\n   SELMEMB = VALUE('SM'A)\n   IF SELMEMB = 'S' THEN DO\n      J = J + 1\n      MODCNT = MODCNT + 1\n      JCLMEM.J = JCLMEM.A\n      JCLSW.J = JCLSW.A\n      ITERATE\n   END\n   EJ = EJ + 1\n   EJCL.EJ = JCLMEM.A\nEND\nIF SRC = 0 THEN RETURN\nIF SRC = 8 THEN EXIT 8\nSAY\nSAY '*** PANEL ERROR: ISPF DIALOG ERROR INVOKING PANEL ( CCFBKPNM ). ***'\nSAY '*** CCF BACKOUT MAIN TASK CANCELLED - RETURN CODE: ('SRC'). ***'\nEXIT SRC\n/*     */\nDISPLAY_MEMBER_SELECTION_PANEL3:\nPCNT = P\nIF PCNT = 0 THEN RETURN\nIF P > 56 THEN PCNT = 56\nP = 0\nEP = 0\nDO A = 1 TO PCNT\n   INTERPRET 'MEM'A '= PROCMEM.'A\nEND\nADDRESS ISPEXEC\n\"CONTROL ERRORS RETURN\"\n\"DISPLAY PANEL(CCFBKPNM)\"\nSRC = RC\nIF SRC = 0 THEN DO A = 1 TO PCNT\n   SELMEMB = VALUE('SM'A)\n   IF SELMEMB = 'S' THEN DO\n      P = P + 1\n      MODCNT = MODCNT + 1\n      PROCMEM.P = PROCMEM.A\n      PROCSW.C = PROCSW.A\n      ITERATE\n   END\n   EP = EP + 1\n   EPROC.EP = PROCMEM.A\nEND\nIF SRC = 0 THEN RETURN\nIF SRC = 8 THEN EXIT 8\nSAY\nSAY '*** PANEL ERROR: ISPF DIALOG ERROR INVOKING PANEL ( CCFBKPNM ). ***'\nSAY '*** CCF BACKOUT MAIN TASK CANCELLED - RETURN CODE: ('SRC'). ***'\nEXIT SRC\n/*     */\nDISPLAY_MEMBER_SELECTION_PANEL4:\nRCNT = R\nIF RCNT = 0 THEN RETURN\nIF R > 56 THEN RCNT = 56\nR = 0\nER = 0\nDO A = 1 TO RCNT\n   INTERPRET 'MEM'A '= RAMIMEM.'A\nEND\nADDRESS ISPEXEC\n\"CONTROL ERRORS RETURN\"\n\"DISPLAY PANEL(CCFBKPNM)\"\nSRC = RC\nIF SRC = 0 THEN DO A = 1 TO RCNT\n   SELMEMB = VALUE('SM'A)\n   IF SELMEMB = 'S' THEN DO\n      R = R + 1\n      MODCNT = MODCNT + 1\n      RAMIMEM.R = RAMIMEM.A\n      RAMISW.C = RAMISW.A\n      ITERATE\n   END\n   ER = ER + 1\n   ERAMI.ER = RAMIMEM.A\nEND\nIF SRC = 0 THEN RETURN\nIF SRC = 8 THEN EXIT 8\nSAY\nSAY '*** PANEL ERROR: ISPF DIALOG ERROR INVOKING PANEL ( CCFBKPNM ). ***'\nSAY '*** CCF BACKOUT MAIN TASK CANCELLED - RETURN CODE: ('SRC'). ***'\nEXIT SRC\n/*     */\nDISPLAY_MEMBER_SELECTION_PANEL5:\nSCNT = S\nIF SCNT = 0 THEN RETURN\nIF S > 56 THEN SCNT = 56\nS = 0\nES = 0\nDO A = 1 TO SCNT\n   INTERPRET 'MEM'A '= SRCEMEM.'A\nEND\nADDRESS ISPEXEC\n\"CONTROL ERRORS RETURN\"\n\"DISPLAY PANEL(CCFBKPNM)\"\nSRC = RC\nIF SRC = 0 THEN DO A = 1 TO SCNT\n   SELMEMB = VALUE('SM'A)\n   IF SELMEMB = 'S' THEN DO\n      S = S + 1\n      MODCNT = MODCNT + 1\n      SRCEMEM.S = SRCEMEM.A\n      SRCESW.S = SRCESW.A\n      ITERATE\n   END\n   ES = ES + 1\n   ESRCE.ES = SRCEMEM.A\nEND\nIF SRC = 0 THEN RETURN\nIF SRC = 8 THEN EXIT 8\nSAY\nSAY '*** PANEL ERROR: ISPF DIALOG ERROR INVOKING PANEL ( CCFBKPNM ). ***'\nSAY '*** CCF BACKOUT MAIN TASK CANCELLED - RETURN CODE: ('SRC'). ***'\nEXIT SRC\n/*     */\nDISPLAY_MEMBER_SELECTION_PANEL6:\nICNT = I\nIF ICNT = 0 THEN RETURN\nIF I > 56 THEN ICNT = 56\nI = 0\nEI = 0\nDO A = 1 TO ICNT\n   INTERPRET 'MEM'A '= SYSIMEM.'A\nEND\nADDRESS ISPEXEC\n\"CONTROL ERRORS RETURN\"\n\"DISPLAY PANEL(CCFBKPNM)\"\nSRC = RC\nIF SRC = 0 THEN DO A = 1 TO ICNT\n   SELMEMB = VALUE('SM'A)\n   IF SELMEMB = 'S' THEN DO\n      I = I + 1\n      MODCNT = MODCNT + 1\n      SYSIMEM.I = SYSIMEM.A\n      SYSISW.I = SYSISW.A\n      ITERATE\n   END\n   EI = EI + 1\n   ESYSI.EI = SYSIMEM.A\nEND\nIF SRC = 0 THEN RETURN\nIF SRC = 8 THEN EXIT 8\nSAY\nSAY '*** PANEL ERROR: ISPF DIALOG ERROR INVOKING PANEL ( CCFBKPNM ). ***'\nSAY '*** CCF BACKOUT MAIN TASK CANCELLED - RETURN CODE: ('SRC'). ***'\nEXIT SRC\n/*     */\nSUBMIT_BACKOUT_JOB:\nADDRESS TSO\n\"EXECIO 0 DISKW CCFDD (FINIS\"\n\"SUBMIT '\"CNTLLIB\"(\"WORKORDR\")'\"\nSRC = RC\n\"FREE F(CCFDD)\"\nIF SRC \u00ac= 0 THEN SIGNAL SUBMIT_ERROR\nRETURN\n/*     */\nCHECK_USER_AUTHORIZATION:\nAUTHSW = 'NO'\n\"ALLOC DA('\"PARMLIB\"(ELIPSAUS)') F(PARMDD) SHR\"\n\"EXECIO * DISKR PARMDD (STEM AUTHUSR. FINIS\"\n\"FREE FILE(PARMDD)\"\nDO V = 1 TO AUTHUSR.0\n   IF AUTHUSR.V = TSOID THEN DO\n      AUTHSW = 'YES'\n      LEAVE\n   END\nEND\nRETURN\n/*\n         E R R O R   R O U T I N E S   S E C T I O N      */\n/*     */\nSTAGING_PDS_ERROR:\nSAY\nSAY '*** DATASET ERROR: ('CNTLLIB') - DATASET NOT FOUND. ***'\nSAY '*** UNABLE TO ALLOCATE THE STAGING SKELETON JCL PDS. ***'\nSAY '*** CCF BACKOUT MAIN TASK CANCELLED. ***'\nEXIT 028\n/*     */\nAUTHORIZATION_ERROR:\nSAY\nSAY '*** AUTHORIZATION ERROR: USER ('TSOID') NOT AUTHORIZED. ***'\nSAY '*** CCF BACKOUT MAIN TASK CANCELLED. ***'\nEXIT 913\n/*     */\nINVALID_WORKORDR_NUMBER:\nSAY\nSAY '*** INVALID CR/WO NUMBER: (' WORKORDR ') NOT FOUND IN SYSTEM MASTER. ***'\nSAY '+++ VALID CR/WO NUMBER MUST BE 8 BYTE FORMAT: ( WONNNNNN ). +++'\nSAY '*** CCF BACKOUT MAIN TASK CANCELLED. ***'\nEXIT 024\n/*     */\nSYSMAST_ALLOC_ERROR:\nSAY\nSAY '*** ALLOCATION ERROR: ('SYSMAST') - RETRY TASK. ***'\nSAY '*** DYNAMIC ALLOCATION FAILED FOR THE CONTROL LIBRARIAN MASTER. ***'\nSAY '*** CCF BACKOUT SUBTASK CANCELLED. ***'\nEXIT 100\n/*     */\nCRWO_MODULE_NOT_FOUND:\nSAY\nSAY '*** CRWO MODULE ERROR: MODULE NOT FOUND FOR (' ZRMEMB 'OR' MEMBER '). ***'\nSAY '*** MEMBERS NOT FOUND IN ('SYSMAST') DATASET. ***'\nSAY '*** CCF BACKOUT MAIN TASK CANCELLED - RETURN CODE: (028). ***'\n\"FREE F(\"LIBDD\")\"\nEXIT 028\n/*     */\nSYSMAST_MODULE_READ_ERROR:\nSAY\nSAY '*** EXECIO READ ERROR: ('SYSMAST'('MEMBER'). ***'\nSAY '*** CANNOT READ CR/WO SYSTEM MASTER MODULE TO EXTRACT MEMBER NAMES. ***'\nSAY '*** CCF BACKOUT SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\nEXIT SRC\n/*     */\nBACKOUT_QUALIFY_ERROR:\nSAY\nSAY '*** BACKOUT ERROR: NO TO-PRODUCTION MODULE RECORD ENTRIES FOUND. ***'\nSAY 'MEMBERS ('ZRMEMB 'OR' WORKORDR') DO NOT CONTAIN VALID MOVEMEMT RECORDS.'\nSAY '*** CCF BACKOUT MAIN TASK CANCELLED. ***'\nEXIT 028\n/*     */\nSTAGING_PDS_ALLOC_ERROR:\nSAY\nSAY '*** ALLOCATION ERROR: ('CNTLLIB'('WORKORDR') SKELETON JCL PDS. ***'\nSAY '*** DATASET UNAVAILABLE FOR JOBSTREAM BUILD/WRITE. ***'\nSAY '*** CCF BACKOUT MAIN TASK CANCELLED. ***'\n\"FREE F(CCFDD)\"\nEXIT SRC\n/*     */\nPDS_WRITE_ERROR:\nSAY\nSAY '*** PDS WRITE ERROR: ('CNTLLIB'('WORKORDR'). ***'\nSAY '*** SKELETON JCL JOBSTREAM BUILD ERROR. ***'\nSAY '*** CCF BACKOUT SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n\"FREE F(CCFDD)\"\nEXIT SRC\n/*     */\nHISTMAST_ALLOC_ERROR:\nSAY\nSAY '*** ALLOCATION ERROR: ('HISTMAST'('SRCEMEM.S') - RETRY TASK. ***'\nSAY '*** DYNAMIC ALLOCATION FAILED FOR THE SOURCE HISTORY MASTER. ***'\nSAY '*** CCF BACKOUT SUBTASK CANCELLED. ***'\nEXIT 100\n/*     */\nHISTMAST_EXECIO_ERROR:\nSAY\nSAY '*** EXECIO READ ERROR: ('HISTMAST'('SRCEMEM.S'). ***'\nSAY '*** UNABLE TO RETRIEVE LANG CODE FOR LOAD MODULE BACKOUT. ***'\nSAY '*** CCF BACKOUT EXEC SUBTASK CANCELLED - RC = ('SRC'). ***'\nEXIT SRC\n/*     */\nDB2PARM_MEMBER_ERROR:\nSAY\nSAY '*** PARMLIB MEMBER ERROR: ('QACCF'('WORKORDR'). ***'\nSAY '*** UNABLE TO RETRIEVE DB2 PACKAGE/BIND PARAMETER DATA. ***'\nSAY '*** CCF BACKOUT EXEC SUBTASK CANCELLED - RC = ('SRC'). ***'\nEXIT SRC\n/*     */\nSUBMIT_ERROR:\nSAY\nSAY '*** SUBMIT ERROR: ('CNTLLIB'('WORKORDR'). ***'\nSAY '*** EXECIO DISKW SKELETON JCL JOBSTREAM BUILD ERROR. ***'\nSAY '*** CCF BACKOUT SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n\"FREE F(CCFDD)\"\nEXIT SRC\n/*     */\nSKELETON_JCL_BUILD_ERROR:\nSAY\nSAY '*** SUBMIT ERROR: ('SKELJCL'('MEMBER'). ***'\nSAY '*** DIALOG SKELETON JCL JOBSTREAM BUILD ERROR. ***'\nSAY '*** CCF BACKOUT SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n\"FREE F(CCFDD)\"\nEXIT SRC\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CCFBMSLM": {"ttr": 3080, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x933?\\x00\\x933?\\x14\\x15\\x00\\x0f\\x00\\x0b\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf3@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1993-11-29T00:00:00", "modifydate": "1993-11-29T14:15:00", "lines": 15, "newlines": 11, "modlines": 0, "user": "TECH103"}, "text": "/*   REXX EXEC : ( CCFBMSLM )\n     FUNCTION  : VERIFIES IF A BMSMAP PROGRAM LOAD MODULE EXISTS IN THE\n                 ( SYS1.TURNOVER.CICS.LOADLIB ) DATASET.              */\nTRACE O\n/*     */\nADDRESS TSO\nARG MODULENM\nLOADLIB = 'SYS1.TURNOVER.CICS.LOADLIB'\nMOD = SYSDSN(\"'\"LOADLIB\"(\"MODULENM\")'\")\nIF MOD = 'OK' THEN EXIT 0\nSAY\nSAY '*** LOAD MODULE ERROR: SYS1.TURNOVER.CICS.LOADLIB('MODULENM'). ***'\nSAY '*** LOAD MODULE NOT FOUND - TURNOVER PROCESSING CANCELLED. ***'\nSAY\nEXIT 8\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CCFCOBCK": {"ttr": 3082, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x92(\\x8f\\x00\\x92)O\\x15\\x01\\x00;\\x006\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf3@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1992-10-14T00:00:00", "modifydate": "1992-10-20T15:01:00", "lines": 59, "newlines": 54, "modlines": 0, "user": "TECH103"}, "text": "/* REXX EXEC : ( CCFCOBCK )   TURNOVER COMPILE JCL CHECKER\n   LIB/CCF COBOL2 QA TURNOVER COMPILE FACILITY TO DETERMINE NATIVE OR\n   COMPATIBILITY MODE COMPILE OPTION, AND CHECK FOR CA-OPTIMIZER.   */\n\nTRACE O\n/*     */\nHOUSE_KEEPING:\nADDRESS TSO\nARG TSOUSER MEMBER\nIF TSOUSER = '' | MEMBER = '' THEN DO\n   SAY '*** MISSING ARGMENTS FOR CCFCOBCK INVOCATION. ***'\n   SAY '+++ TSO USERID AND LIBRARIAN MEMBER NAME MUST BE PASSED ARGMENTS. +++'\n   SAY '*** CCFCOBCK EXEC MAINTASK CANCELLED. ***'\n   EXIT 12\nEND\nC2P = 'APOST,LIB,CMPR2,RES,RENT,DYNAM'\n\"ALLOC DA('\"TSOUSER\".\"MEMBER\".SEQFILE') F(ISPFILE) SHR\"\nIF RC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR:' TSOUSER||'.'||MEMBER||'.'||SEQFILE '***'\n   SAY '*** CCFCOBCK EXEC MAINTASK CANCELLED. ***'\n   EXIT 12\nEND\n\"EXECIO * DISKR ISPFILE (FINIS STEM DATA.\"\nSRC = RC\n\"FREE F(ISPFILE)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET EXECIO ERROR:' TSOUSER||'.'||MEMBER||'.'||SEQFILE '***'\n   SAY '*** CCFCOBCK EXEC MAINTASK CANCELLED. ***'\n   EXIT 12\nEND\n/*     */\nCHECK_COBOL2_NATIVE_FLAG:\nNATIVE_SW = 'NO'\nDO I = 1 TO DATA.0\n   NOCMPR2 = POS('NOCMPR2-FLAG',DATA.I)\n   IF NOCMPR2 \u00ac= 0 THEN DO\n      NATIVE_SW = 'YES'\n      C2P = 'APOST,LIB,NOCMPR2,RES,RENT,DYNAM'\n      LEAVE\n   END\nEND\n/*     */\nCHECK_OPTIMIZE_FLAG:\nOPTIMIZE_SW = 'NO'\nDO I = 1 TO DATA.0\n   OPTFLAG = POS('OPT2-FLAG',DATA.I)\n   IF OPTFLAG \u00ac= 0 THEN DO\n      OPTIMIZE_SW = 'YES'\n      C2P = 'COPT,APOST,LIB,RES,RENT,DYNAM'\n      LEAVE\n   END\nEND\n/*     */\nCHECK_TURNOVER_COMPILE_TYPE:\nIF NATIVE_SW = 'YES' & OPTIMIZE_SW = 'NO'  THEN EXITRC = 1\nIF NATIVE_SW = 'NO'  & OPTIMIZE_SW = 'NO'  THEN EXITRC = 2\nIF NATIVE_SW = 'YES' & OPTIMIZE_SW = 'YES' THEN EXITRC = 3\nIF NATIVE_SW = 'NO'  & OPTIMIZE_SW = 'YES' THEN EXITRC = 4\nEXIT EXITRC\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CCFDYLDQ": {"ttr": 3084, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x1b\\x00\\x00\\x00\\x91#O\\x00\\x94!_\\x11\\x05\\x01)\\x00)\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf3@@@'", "ispf": {"version": "01.27", "flags": 0, "createdate": "1991-08-22T00:00:00", "modifydate": "1994-08-03T11:05:00", "lines": 297, "newlines": 41, "modlines": 0, "user": "TECH103"}, "text": "/* REXX EXEC : ( CCFDYLDQ ).\n   FUNCTION: INVOKED BY CCF SKELETON JCL ( CCFDYLDB ) FOR PROMOTION OF\n             DYLAKOR/DB2 SOURCE PROGRAMS INTO QA OR PROD LIBRARIES.\n             THIS REXX EXEC PROGRAM WILL PERFORM THE FOLLOWING TASKS:\n             1. READ/CHECK THE SOURCE PROGRAM TO GET THE DYLAKOR\n                REPORT AND DB2 LOAD MODULE NAMES, AND THE DB2 PLAN.\n             3. BUILD THE IDCAMS DELETE LOAD MODULE SYSIN MEMBER.\n             4. BUILD THE IEBCOPY COPY LOAD MODULE SYSIN MEMBER.\n             5. BUILD THE DB2 BIND CONTROL STATEMENTS SYSIN MEMBER.\n             6. BUILD THE DB2 GRANT CONTROL STATEMENTS SYSIN MEMBER.\n             7. BUILD IEHPROGM RENAME GENERATED ASSEMBLER PROGRAM.\n             8. BUILD LINKAGE EDITOR SYSLIN CONTROL SYSIN MEMBER.\n             9. BUILD LINKAGE EDITOR SYSLIN CONTROL SYSIN MEMBER.\n             INPUT  : ( SYS1.QASRCE.MASTER(&MEMBER).\n             OUTPUT : ( SYSS.QA.CCF.DYLAKOR.DYLCOPY.CNTLLIB(&MEMBER).\n                      ( SYSS.QA.CCF.DYLAKOR.DYLDEL01.CNTLLIB(&MEMBER).\n                      ( SYSS.QA.CCF.DYLAKOR.DYLDEL02.CNTLLIB(&MEMBER).\n                      ( SYSS.QA.CCF.DYLAKOR.DB2BIND.CNTLLIB(&MEMBER).\n                      ( SYSS.QA.CCF.DYLAKOR.DB2GRANT.CNTLLIB(&MEMBER).\n                      ( SYSS.QA.CCF.DYLAKOR.IEHPROGM.CNTLLIB(&MEMBER).\n                      ( SYSS.QA.CCF.DYLAKOR.LINKEDIT.CNTLLIB(&MEMBER).\n                                                                      */\nTRACE O\n/*     */\nHOUSE_KEEPING:\nADDRESS TSO\nARG TSOID MASTER MEMBER\nPARMS = 'TSOID MASTER MEMBER'\nDO I = 1 TO 3\n   IPARM = WORD(PARMS,I)\n   XPARM = VALUE(IPARM)\n   IF XPARM \u00ac= '' THEN ITERATE\n   SAY '*** PARM ERROR: MISSING PARM VALUE FOR ('IPARM'). ***'\n   SAY '*** CCFDYLDQ EXEC TASK CANCELLED - RC = (024). ***'\n   EXIT 024\nEND\nMCNT = 2\nPARMLIB = 'SYSS.TECH.COMMON.PARMLIB'\nDB2PARM = SYSDSN(\"'\"PARMLIB\"(DB2ADMIN)'\")\nIF DB2PARM = 'MEMBER NOT FOUND' THEN DO\n   SAY '*** MEMBER ERROR: MEMBER NOT FOUND ('PARMLIB'(DB2ADMIN). ***'\n   SAY '*** CCFDYLDQ EXEC SUBTASK CANCELLED - RETURN CODE: ('028'). ***'\n   EXIT 028\nEND\nX = MSG(\"OFF\")\n\"FREE FILE(PARMDD)\"\n\"FREE FILE(DB2DD)\"\nDEL.1 = \"  IF LASTCC = 8 THEN\"\nDEL.2 = \"     DO\"\nDEL.3 = \"       SET MAXCC = 0\"\nDEL.4 = \"     END\"\nLIBNODE = POS('PRODSRCE',MASTER)\nIF LIBNODE \u00ac= 0 THEN DO\n   CALL GET_DYLAKOR_MODULE_NAMES\n   IF ASMSW = 'NO' THEN CALL ASSEMBLE_NAME_ERROR\n   IF RPTSW = 'NO' THEN CALL REPORT_NAME_ERROR\n   DB2SYS = 'DSNA'\n   CALL BUILD_DB2_BIND_SYSIN\n   OUTMEMB = 'DB2BIND'\n   CALL WRITE_SYSIN_MEMBER\n   CALL BUILD_DB2_GRANT_SYSIN\n   OUTMEMB = 'DB2GRANT'\n   CALL WRITE_SYSIN_MEMBER\n   EXIT 2\nEND\nLIBNODE = POS('EMRGSRCE',MASTER)\nIF LIBNODE \u00ac= 0 THEN DO\n   CALL GET_DYLAKOR_MODULE_NAMES\n   IF ASMSW = 'NO' THEN CALL ASSEMBLE_NAME_ERROR\n   IF RPTSW = 'NO' THEN CALL REPORT_NAME_ERROR\n   LOADLIB = 'SYS1.EMERGNCY.BATCH.LOADLIB'\n   CALL BUILD_IDCAMS_DELETE_SYSIN\n   OUTMEMB = 'DYLDEL02'\n   CALL WRITE_SYSIN_MEMBER\n   DB2SYS = 'DSNA'\n   CALL BUILD_DB2_BIND_SYSIN\n   OUTMEMB = 'DB2BIND'\n   CALL WRITE_SYSIN_MEMBER\n   CALL BUILD_DB2_GRANT_SYSIN\n   OUTMEMB = 'DB2GRANT'\n   CALL WRITE_SYSIN_MEMBER\n   EXIT 3\nEND\nLIBNODE = POS('QASRCE',MASTER)\nIF LIBNODE = 0 THEN EXIT 0\n/*\n        M A I N   R O U T I N E   S E C T I O N     */\n/*     */\nMAIN_ROUTINE:\nDB2SYS = 'DSNX'\nCALL GET_DYLAKOR_MODULE_NAMES\nIF ASMSW = 'NO' THEN CALL ASSEMBLE_NAME_ERROR\nIF RPTSW = 'NO' THEN CALL REPORT_NAME_ERROR\nLOADLIB = 'SYS1.TEST.BATCH.LOADLIB'\nCALL BUILD_IDCAMS_DELETE_SYSIN\nOUTMEMB = 'DYLDEL01'\nCALL WRITE_SYSIN_MEMBER\nLOADLIB = 'SYS1.QA.BATCH.LOADLIB'\nCALL BUILD_IDCAMS_DELETE_SYSIN\nOUTMEMB = 'DYLDEL02'\nCALL WRITE_SYSIN_MEMBER\nCALL BUILD_IEBCOPY_COPY_SYSIN\nOUTMEMB = 'DYLCOPY'\nCALL WRITE_SYSIN_MEMBER\nCALL BUILD_DB2_BIND_SYSIN\nOUTMEMB = 'DB2BIND'\nCALL WRITE_SYSIN_MEMBER\nCALL BUILD_DB2_GRANT_SYSIN\nOUTMEMB = 'DB2GRANT'\nCALL WRITE_SYSIN_MEMBER\nCALL BUILD_IEHPROGM_SYSIN\nOUTMEMB = 'IEHPROGM'\nCALL WRITE_SYSIN_MEMBER\nCALL BUILD_LINKEDIT_SYSIN\nOUTMEMB = 'LINKEDIT'\nCALL WRITE_SYSIN_MEMBER\nEXIT 1\n/*\n       S U B R O U T I N E   S E C T I O N     */\n/*     */\nGET_DYLAKOR_MODULE_NAMES:\nASMSW = 'NO'\nRPTSW = 'NO'\nLIBDSN = \"'\"MASTER\"(\"MEMBER\")'\"\nLIBDD = LIBALLOC(LIBDSN)\nIF LIBDD = \"ERROR\" THEN DO\n   ERC = 100\n   SAY '*** DYNAMIC ALLOCATION ERROR: ('MASTER'). ***'\n   SAY '*** MODULE NAMES CANNOT BE READ FOR ('MEMBER') PROGRAM. ***'\n   SAY '*** CCFDYLDQ EXEC SUBTASK CANCELLED - RC = ('ERC'). ***'\n   EXIT ERC\nEND\nADDRESS TSO \"EXECIO * DISKR\" LIBDD \"(FINIS STEM PROGDATA.\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** INVALID OR MISSING LIBRARIAN MEMBER NAME. ***'\n   SAY '*** CCF DB2B EXEC TASK CANCELLED - RC = '024'. ***'\n   EXIT\nEND\nDO I = 1 TO PROGDATA.0\n   KEY1 = POS('OPTION FREEZE',PROGDATA.I)\n   IF KEY1 \u00ac= 0 THEN DO\n      KEY2 = WORDPOS('FREEZE',PROGDATA.I)\n      INDEXKEY = KEY2 + 1\n      DYLMOD = WORD(PROGDATA.I,INDEXKEY)\n      RPTSW = 'YES'\n      MOD.1 = DYLMOD\n   END\n   KEY3 = POS('TSO_ATTACH PLANID',PROGDATA.I)\n   IF KEY3 \u00ac= 0 THEN DO\n      KEY4 = WORDPOS('PLANID',PROGDATA.I)\n      INDEXKEY = KEY4 + 1\n      ASMMOD = WORD(PROGDATA.I,INDEXKEY)\n      DB2PLAN = WORD(PROGDATA.I,INDEXKEY)\n      ASMSW = 'YES'\n      MOD.2 = ASMMOD\n   END\nEND\nRETURN\n/*     */\nASSEMBLE_NAME_ERROR:\nERC = 024\nSAY '*** SYNTAX REQUIREMENTS ERROR FOR ('MEMBER') PROGRAM. ***'\nSAY '*** ASSEMBLE MODULE NAME NOT FOUND FROM KEY SYNTAX DATA. ***'\nSAY '*** CCFDYLDQ EXEC SUBTASK CANCELLED - RC = ('ERC'). ***'\nEXIT ERC\n/*     */\nREPORT_NAME_ERROR:\nERC = 024\nSAY '*** SYNTAX REQUIREMENTS ERROR FOR ('MEMBER') PROGRAM. ***'\nSAY '*** REPORTS MODULE NAME NOT FOUND FROM KEY SYNTAX DATA. ***'\nSAY '*** CCFDYLDQ EXEC SUBTASK CANCELLED - RC = ('ERC'). ***'\nEXIT ERC\n/*     */\nBUILD_IDCAMS_DELETE_SYSIN:\n\"DELSTACK\"\nDO M = 1 TO MCNT\n   RECORD = \"  DELETE \"LOADLIB\"(\"MOD.M\") FILE(LOADLIB)\"\n   QUEUE RECORD\nEND\nDO D = 1 TO 4\n   QUEUE DEL.D\nEND\nRETURN\n/*     */\nBUILD_IEBCOPY_COPY_SYSIN:\nI = 0\nM = 0\nCNTL = \"       SELECT MEMBER=(\"\n\"DELSTACK\"\nRECORD = \"  COPY OUTDD=OUTDD1\"\nQUEUE RECORD\nRECORD = \"       INDD=((INDD1,R))\"\nQUEUE RECORD\nDO MCNT\n   M = M + 1\n   I = I + 1\n   IF I = 1 THEN SYSIN = CNTL||MOD.M\n   IF (I > 1) & (I < 5) THEN SYSIN = SYSIN||\",\"||MOD.M\n   IF (I = 5) THEN DO\n      SYSIN = SYSIN||\",\"||MOD.M||\")\"\n      QUEUE SYSIN\n      I = 0\n   END\nEND\nIF I > 0 THEN DO\n   SYSIN = SYSIN||\")\"\n   QUEUE SYSIN\nEND\nRETURN\n/*     */\nBUILD_DB2_BIND_SYSIN:\n\"DELSTACK\"\nBIND.1 = \" DSN SYSTEM(\"DB2SYS\")\"\nBIND.2 = \" BIND PLAN(\"DB2PLAN\") -\"\nBIND.3 = \"      RETAIN -\"\nBIND.4 = \"      MEMBER(\"MEMBER\")\"\nBIND.5 = \" END\"\nDO B = 1 TO 5\n   QUEUE BIND.B\nEND\nRETURN\n/*     */\nBUILD_DB2_GRANT_SYSIN:\n\"DELSTACK\"\nCOMRCD = \"  COMMIT;\"\nBNDCNT = 4\nBND.1 = \"        GRANT\"\nBND.2 = \"        BIND,\"\nBND.3 = \"        EXECUTE\"\nBND.4 = \"  ON PLAN \"DB2PLAN\" TO\"\n\"ALLOC DA('\"PARMLIB\"(DB2ADMIN)') FILE(PARMDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('PARMLIB'(DB2ADMIN). ***'\n   SAY '*** CCFDYLDQ EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\n\"EXECIO * DISKR PARMDD (FINIS STEM AUTH.\"\nSRC = RC\n\"FREE FILE(PARMDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** EXECIO READ ERROR: ('PARMLIB'(DB2ADMIN). ***'\n   SAY '*** CCFDYLDQ EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nDO B = 1 TO BNDCNT\n   QUEUE BND.B\nEND\nDO I = 1 TO AUTH.0\n   AUTHUSR = WORD(AUTH.I,1)\n   AUSER = TSOID','\n   IF AUSER = AUTHUSR THEN ITERATE\n   DB2AUTH = '        '||AUTHUSR\n   QUEUE DB2AUTH\nEND\nQUEUE COMRCD\nRETURN\n/*     */\nBUILD_IEHPROGM_SYSIN:\n\"DELSTACK\"\nCONTX = \"         X\"\nRENAM = \"    RENAME  DSNAME=SYSS.QA.CCF.DYLAKOR.ASMLIB,VOL=3390=SYS017,\"\nRCD.1 = RENAM||CONTX\nRCD.2 = \"               NEWNAME=\"MEMBER\",MEMBER=\"ASMMOD\nDO R = 1 TO 2\n   QUEUE RCD.R\nEND\nRETURN\n/*     */\nBUILD_LINKEDIT_SYSIN:\n\"DELSTACK\"\nRCD.1 = \"  INCLUDE DB2LIB(DSNELI)\"\nRCD.2 = \"  NAME \"ASMMOD\"(R)\"\nDO R = 1 TO 2\n   QUEUE RCD.R\nEND\nRETURN\n/*     */\nWRITE_SYSIN_MEMBER:\n\"ALLOC DA('SYSS.QA.CCF.DYLAKOR.\"OUTMEMB\".CNTLLIB(\"MEMBER\")') FILE(DYLDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('OUTMEMB'('MEMBER'). ***'\n   SAY '*** CCFDYLDQ EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT 8\nEND\nRCDCNT = QUEUED()\n\"EXECIO\" RCDCNT \"DISKW DYLDD (FINIS\"\nSRC = RC\n\"FREE FILE(DYLDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** EXECIO WRITE ERROR: ('OUTMEMB'('MEMBER'). ***'\n   SAY '*** CCFDYLDQ EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT 8\nEND\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CCFEMRGP": {"ttr": 3333, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x916\\x1f\\x00\\x916\\x1f\\x17\"\\x00\\x10\\x00\\x10\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-12-27T00:00:00", "modifydate": "1991-12-27T17:22:00", "lines": 16, "newlines": 16, "modlines": 0, "user": "TECH103"}, "text": "/* REXX EXEC  */\n/* LIB/CCF PRODUCTION PROC TURNOVER TO DETERMINE WHEN A PROC WILL BE\n   COPIED INTO THE CORRESPONDING JES2 CONCATENATED PDS PROCLIB.  */\n\nTRACE O\n/*     */\nHOUSE_KEEPING:\nARG EMRGMAST\nIF EMRGMAST = '' THEN DO\n   SAY '*** LIBRARIAN MASTER DATASET NAME NOT PASSED AS EXEC ARGMENT. ***'\n   SAY '*** CCFEMRGP EXEC TASK CANCELLED. ***'\n   EXIT 8\nEND\nEXITRC = 4\nIF EMRGMAST = 'SYS1.EMRGPROC.MASTER' THEN EXITRC = 0\nEXIT EXITRC\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CCFJRNAL": {"ttr": 3335, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0c\\x00\\x00\\x00\\x93\\x13\\x0f\\x00\\x93 ?\\x12\\x17\\x00\\xb1\\x00\\x94\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf3@@@'", "ispf": {"version": "01.12", "flags": 0, "createdate": "1993-05-10T00:00:00", "modifydate": "1993-07-22T12:17:00", "lines": 177, "newlines": 148, "modlines": 0, "user": "TECH103"}, "text": "/* REXX EXEC : ( CCFJRNAL ).\n   FUNCTION  : THIS EXEC IS INVOKED DURING CCF TURNOVER PROCESSING\n               FROM CCF SKELETON ( $CCFJ004 ) TO CHECK FOR TARGET \"PROD\"\n               LIBRARIAN MOVEMENT.\n               THE FUNCTION OF THIS EXEC IS TO WRITE A JOURNAL RECORD\n               ENTRY TO TRACK ALL PRODUCTION MODULES THAT ARE TURNED\n               OVER DURING A 24 HOUR PERIOD.\n               JOURNAL RECORD ENTRIES ARE WRITTEN TO A PDS MEMBER WHICH\n               IS MAINTAINED BY JULIAN DATE.\n   INPUT     : ( SYSS.CCF.OSJOB.CNTLLIB(&MODULENM)).\n   OUTPUT    : ( SYSS.CCF.TURNOVER.JOURNAL ).\n                                                                      */\nTRACE O\n/*     */\nHOUSE_KEEPING:\nADDRESS TSO\nARG MASTER MODULE WORKORDR LOADLIB\nPARMS = 'MASTER MODULE WORKORDR'\nDO I = 1 TO 3\n   IPARM = WORD(PARMS,I)\n   XPARM = VALUE(IPARM)\n   IF XPARM \u00ac= '' THEN ITERATE\n   SAY '*** PARM ERROR: MISSING PARM VALUE FOR ('IPARM'). ***'\n   SAY '*** CCFJRNAL EXEC TASK CANCELLED - RC = (024). ***'\n   EXIT 024\nEND\nPRDLIB = POS('PROD',MASTER)\nIF PRDLIB = 0 THEN EXIT 0\nJULDATE = DATE(J)\nPDSMEMB = \"J\"||JULDATE\nCDATE = DATE(U)\nCTIME = TIME()\nNOMEMB = 'MEMBER NOT FOUND'\nOSJERR = 'DATASET NOT FOUND'\nOSJOBIN = 'SYSS.CCF.OSJOB.CNTLLIB'\nJOURLIB = 'SYSS.CCF.TURNOVER.JOURNAL'\nMEMBER = MODULE\nMASTER = LEFT(MASTER,21)\nMODULE = LEFT(MODULE,8)\nHEADER1 = 'DATE     TIME     WORKORDR CCFID   PROD LIBRARIAN MASTER MODULE   LAN\nGUAGE'\nHEADER2 = '-------- -------- -------- ------- --------------------- -------- ---\n-----'\n\nX = MSG(\"OFF\")\n\"FREE F(JOURDD)\"\n\"FREE F(OSJOBDD)\"\nMASTER_NODE = 'PRODCOPY PRODJCL PRODPROC PRODRAMI PRODSYSI'\nMODULE_LANG = 'COPYBOOK JCL PROC RAMIS SYSIN'\n/*     */\nMAIN_ROUTINE:\nCALL ALLOC_OSJOB\nINTERPRET CALL LABEL\nCALL GET_TURNOVER_PROGRAMMER\nCALL GET_MODULE_LANGUAGE\nCALL ALLOC_JOURNAL\nRECORD = CDATE CTIME WORKORDR PROGRAMMER MASTER MODULE LANGUAGE\nINTERPRET CALL LABEL\nIF WRITESW = 'ERROR' THEN CALL JOURNAL_WRITE_ERROR\nEXIT 0\n\n/*     S U B R O U T I N E S   S E C T I O N     */\n/*     */\nALLOC_OSJOB:\nLABEL = 'NOOP_ROUTINE'\nDSN = SYSDSN(\"'\"OSJOBIN\"'\")\nIF DSN = 'OK' THEN DO\n   \"ALLOC DA('\"OSJOBIN\"(\"MEMBER\")') F(OSJOBDD) SHR\"\n   \"EXECIO * DISKR OSJOBDD (FINIS STEM DATA.\"\n   SRC = RC\n   \"FREE F(OSJOBDD)\"\n   IF SRC \u00ac= 0 THEN LABEL = 'OSJOB_DATASET_READ_ERROR'\n   RETURN\nEND\nLABEL = 'OSJOB_DATASET_ERROR'\nRETURN\n\n/*     */\nGET_TURNOVER_PROGRAMMER:\nDO I = 1 TO DATA.0\n   CCFID = POS('-PGMR',DATA.I)\n   IF CCFID \u00ac= 0 THEN DO\n      PROGRAMMER = SUBSTR(DATA.I,8,7)\n      LEAVE\n   END\nEND\nRETURN\n\n/*     */\nGET_MODULE_LANGUAGE:\nMNODE = POS('PRODSRCE',MASTER)\nIF MNODE \u00ac= 0 THEN DO\n   LANGUAGE = 'BATCH SRCE'\n   LNODE = POS('CICS',LOADLIB)\n   IF LNODE \u00ac= 0 THEN LANGUAGE = 'CICS SRCE'\n   RETURN\nEND\nDO I = 1 TO 5\n   MNODE = WORD(MASTER_NODE,I)\n   LNODE = POS(MNODE,MASTER)\n   IF LNODE \u00ac= 0 THEN LANGUAGE = WORD(MODULE_LANG,I)\nEND\nRETURN\n\n/*     */\nALLOC_JOURNAL:\nLABEL = 'JOURNAL_DATASET_ERROR'\nDSN = SYSDSN(\"'\"JOURLIB\"(\"PDSMEMB\")'\")\nIF DSN = 'OK' THEN DO\n   \"ALLOC DA('\"JOURLIB\"(\"PDSMEMB\")') F(JOURDD) SHR\"\n   \"DELSTACK\"\n   \"EXECIO * DISKR JOURDD (FINIS\"\n   RCDCNT = QUEUED()\n   LABEL = 'REWRITE_JOURNAL'\nEND\nIF DSN = NOMEMB THEN DO\n   \"ALLOC DA('\"JOURLIB\"(\"PDSMEMB\")') F(JOURDD) SHR\"\n   LABEL = 'WRITE_JOURNAL'\nEND\nRETURN\n\n/*     */\nWRITE_JOURNAL:\nWRITESW = 'OK'\n\"DELSTACK\"\nQUEUE HEADER1\nQUEUE HEADER2\nQUEUE RECORD\n\"EXECIO 3 DISKW JOURDD (FINIS\"\nSRC = RC\n\"FREE F(JOURDD)\"\nIF SRC \u00ac= 0 THEN WRITESW = 'ERROR'\nRETURN\n\n/*     */\nREWRITE_JOURNAL:\nWRITESW = 'OK'\nRCDCNT = RCDCNT + 1\nQUEUE RECORD\n\"EXECIO\" RCDCNT \"DISKW JOURDD (FINIS\"\nSRC = RC\n\"FREE F(JOURDD)\"\nIF SRC \u00ac= 0 THEN WRITESW = 'ERROR'\nRETURN\n\n/*     */\nNOOP_ROUTINE:\nRETURN\n\n/*     E R R O R   R O U T I N E S   S E C T I O N     */\n/*     */\nOSJOB_DATASET_ERROR:\nSAY '*** OSJOB DATASET ERROR: 'DSN' ('OSJOBIN'). ***'\nSAY '*** JOURNAL RECORD ENTRIES CANNOT BE WRITTEN. ***'\nSAY '*** CCFJRNAL EXEC TASK CANCELLED. ***'\nEXIT 100\n\n/*     */\nOSJOB_DATASET_READ_ERROR:\nSAY '*** OSJOB DATASET READ ERROR: ('OSJOBIN'). ***'\nSAY '*** JOURNAL RECORD ENTRIES CANNOT BE WRITTEN. ***'\nSAY '*** CCFJRNAL EXEC TASK CANCELLED. ***'\nEXIT SRC\n\n/*     */\nJOURNAL_DATASET_ERROR:\nSAY '*** JOURNAL DATASET ERROR: 'DSN' ('JOURLIB'). ***'\nSAY '*** JOURNAL RECORD ENTRIES CANNOT BE WRITTEN. ***'\nSAY '*** CCFJRNAL EXEC TASK CANCELLED. ***'\nEXIT 110\n\n/*     */\nJOURNAL_WRITE_ERROR:\nSAY '*** JOURNAL WRITE ERROR: ('JOURLIB'('PDSMEMB'). ***'\nSAY '*** JOURNAL RECORD ENTRIES NOT WRITTEN. ***'\nSAY '*** CCFJRNAL EXEC TASK CANCELLED. ***'\nEXIT SRC\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CCFLOADL": {"ttr": 3339, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x92\\x00o\\x00\\x92\\x00o\\x118\\x00\\r\\x00\\x11\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf3@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1992-01-06T00:00:00", "modifydate": "1992-01-06T11:38:00", "lines": 13, "newlines": 17, "modlines": 0, "user": "TECH103"}, "text": "/* REXX EXEC  */\n/* LIB/CCF PRODUCTION PROC TURNOVER TO DETERMINE WHEN A PROC WILL BE\n   COPIED INTO THE CORRESPONDING JES2 CONCATENATED PDS PROCLIB.  */\n\nTRACE O\n/*     */\nHOUSE_KEEPING:\nARG PRODLOAD\nIF PRODLOAD = '' THEN EXIT 4\nEXITRC = 4\nIF PRODLOAD = 'SYS1.PROD.BATCH.LOADLIB' THEN EXITRC = 1\nIF PRODLOAD = 'SYS1.PROD.CICS.LOADLIB' THEN EXITRC = 2\nEXIT EXITRC\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CCFMEMBP": {"ttr": 3341, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x916\\x0f\\x00\\x916\\x0f\\x17\\x18\\x00\\x11\\x00\\x11\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-12-26T00:00:00", "modifydate": "1991-12-26T17:18:00", "lines": 17, "newlines": 17, "modlines": 0, "user": "TECH103"}, "text": "/* REXX EXEC  */\n/* LIB/CCF PRODUCTION PROC TURNOVER TO DETERMINE WHEN A PROC WILL BE\n   COPIED INTO THE CORRESPONDING JES2 CONCATENATED PDS PROCLIB.  */\n\nTRACE O\n/*     */\nHOUSE_KEEPING:\nARG PRODMEMB\nIF PRODMEMB = '' THEN DO\n   SAY '*** LIBRARIAN MASTER MEMBER NAME NOT PASSED AS EXEC ARGMENT. ** *'\n   SAY '*** CCFMEMBP EXEC TASK CANCELLED. ***'\n   EXIT 8\nEND\nEXITRC = 4\nPDSMEMB = SYSDSN(\"'SYS1.PRODPROC.MASTER.PDS(\"PRODMEMB\")'\")\nIF PDSMEMB = 'OK' THEN EXITRC = 0\nEXIT EXITRC\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CCFPROCP": {"ttr": 3343, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x916\\x0f\\x00\\x916\\x0f\\x16\\x16\\x00\\x10\\x00\\x10\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-12-26T00:00:00", "modifydate": "1991-12-26T16:16:00", "lines": 16, "newlines": 16, "modlines": 0, "user": "TECH103"}, "text": "/* REXX EXEC  */\n/* LIB/CCF PRODUCTION PROC TURNOVER TO DETERMINE WHEN A PROC WILL BE\n   COPIED INTO THE CORRESPONDING JES2 CONCATENATED PDS PROCLIB.  */\n\nTRACE O\n/*     */\nHOUSE_KEEPING:\nARG PRODMAST\nIF PRODMAST = '' THEN DO\n   SAY '*** LIBRARIAN MASTER DATASET NAME NOT PASSED AS EXEC ARGMENT. ***'\n   SAY '*** CCFPROCP EXEC TASK CANCELLED. ***'\n   EXIT 8\nEND\nEXITRC = 4\nIF PRODMAST = 'SYS1.PRODPROC.MASTER' THEN EXITRC = 0\nEXIT EXITRC\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CCFQACIC": {"ttr": 3345, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x93!\\x1f\\x00\\x93!\\x1f\\x17\\x12\\x007\\x007\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-07-30T00:00:00", "modifydate": "1993-07-30T17:12:00", "lines": 55, "newlines": 55, "modlines": 0, "user": "TECH103"}, "text": "/* REXX EXEC : ( CCFQACIC ).\n   FUNCTION  : READS SOURCE PROGRAM STATEMENTS TO DETERINE COBOL-II\n               CICS COMPILE TYPE FOR QA MOVEMENT COMPILE.             */\nTRACE O\n/*     */\nHOUSE_KEEPING:\nADDRESS TSO\nARG MASTER MEMBER\nPARMS = 'MASTER MEMBER'\nDO I = 1 TO 2\n   IPARM = WORD(PARMS,I)\n   XPARM = VALUE(IPARM)\n   IF XPARM \u00ac= '' THEN ITERATE\n   SAY '*** PARM ERROR: MISSING PARM VALUE FOR ('IPARM'). ***'\n   SAY '*** CCFQACIC EXEC TASK CANCELLED - RC = (024). ***'\n   EXIT 024\nEND\n\n/*     */\nMAIN_ROUTINE:\nEXITRC = 1\nCALL CHECK_OPTIMIZE_FLAG\nIF OPTIMIZE_SW = 'YES' THEN EXITRC = 2\nEXIT EXITRC\n\n/*     S U B R O U T I N E   S E C T I O N     */\n/*     */\nCHECK_OPTIMIZE_FLAG:\nOPTIMIZE_SW = 'NO'\nLIBDSN = \"'\"MASTER\"(\"MEMBER\")'\"\nLIBDD = LIBALLOC(LIBDSN)  /* DYNALLOC LIBMASTER W/LAM; RET DDNAME*/\nIF LIBDD = \"ERROR\" THEN DO\n   ERC = 100\n   SAY '*** DYNAMIC ALLOCATION ERROR: ('MASTER'). ***'\n   SAY '*** CANNOT READ COBOL2 COMPILE TYPE FLAG FOR ('MEMBER') PROGRAM. ***'\n   SAY '*** CCFQACIC EXEC SUBTASK CANCELLED - RC = ('ERC'). ***'\n   EXIT ERC\nEND\n\"EXECIO * DISKR\" LIBDD \"(FINIS STEM DATA.\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   ERC = 100\n   SAY '*** EXECIO READ ERROR: ('MASTER'('MEMBER'). ***'\n   SAY '*** CANNOT READ COBOL2 COMPILE TYPE FLAG FOR ('MEMBER') PROGRAM. ***'\n   SAY '*** CCFQACIC EXEC SUBTASK CANCELLED - RC = ('ERC'). ***'\n   EXIT ERC\nEND\nDO I = 1 TO DATA.0\n   OPTFLAG = POS('OPT2-FLAG',DATA.I)\n   IF OPTFLAG \u00ac= 0 THEN DO\n      OPTIMIZE_SW = 'YES'\n      LEAVE\n   END\nEND\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CCFQACOB": {"ttr": 3347, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x93\\x18/\\x00\\x93\\x18/\\x13$\\x00N\\x00N\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf3@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1993-07-01T00:00:00", "modifydate": "1993-07-01T13:24:00", "lines": 78, "newlines": 78, "modlines": 0, "user": "TECH103"}, "text": "/* REXX EXEC : ( CCFQACOB ).\n   FUNCTION  : READS SOURCE PROGRAM STATEMENTS TO DETERINE COBOL-II\n               COMPILE TYPE FOR QA MOVEMENT COMPILE.                  */\nTRACE O\n/*     */\nHOUSE_KEEPING:\nADDRESS TSO\nARG MASTER MEMBER\nPARMS = 'MASTER MEMBER'\nDO I = 1 TO 2\n   IPARM = WORD(PARMS,I)\n   XPARM = VALUE(IPARM)\n   IF XPARM \u00ac= '' THEN ITERATE\n   SAY '*** PARM ERROR: MISSING PARM VALUE FOR ('IPARM'). ***'\n   SAY '*** CCFQACOB EXEC TASK CANCELLED - RC = (024). ***'\n   EXIT 024\nEND\nC2P = 'APOST,LIB,CMPR2,RES,RENT,DYNAM'\n\n/*     */\nMAIN_ROUTINE:\nCALL CHECK_NATIVE_FLAG\nCALL CHECK_OPTIMIZE_FLAG\nCALL SET_QA_COMPILE_TYPE_RETURN_CODE\nEXIT EXITRC\n\n/*     S U B R O U T I N E   S E C T I O N     */\n/*     */\nCHECK_NATIVE_FLAG:\nNATIVE_SW = 'NO'\nLIBDSN = \"'\"MASTER\"(\"MEMBER\")'\"\nLIBDD = LIBALLOC(LIBDSN)  /* DYNALLOC LIBMASTER W/LAM; RET DDNAME*/\nIF LIBDD = \"ERROR\" THEN DO\n   ERC = 100\n   SAY '*** DYNAMIC ALLOCATION ERROR: ('MASTER'). ***'\n   SAY '*** CANNOT READ COBOL2 COMPILE TYPE FLAG FOR ('MEMBER') PROGRAM. ***'\n   SAY '*** CCFQACOB EXEC SUBTASK CANCELLED - RC = ('ERC'). ***'\n   EXIT ERC\nEND\n\"EXECIO * DISKR\" LIBDD \"(FINIS STEM DATA.\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   ERC = 100\n   SAY '*** EXECIO READ ERROR: ('MASTER'('MEMBER'). ***'\n   SAY '*** CANNOT READ COBOL2 COMPILE TYPE FLAG FOR ('MEMBER') PROGRAM. ***'\n   SAY '*** CCFQACOB EXEC SUBTASK CANCELLED - RC = ('ERC'). ***'\n   EXIT ERC\nEND\nDO I = 1 TO DATA.0\n   NOCMPR2 = POS('NOCMPR2-FLAG',DATA.I)\n   IF NOCMPR2 \u00ac= 0 THEN DO\n      NATIVE_SW = 'YES'\n      C2P = 'APOST,LIB,NOCMPR2,RES,RENT,DYNAM'\n      LEAVE\n   END\nEND\nRETURN\n\n/*     */\nCHECK_OPTIMIZE_FLAG:\nOPTIMIZE_SW = 'NO'\nDO I = 1 TO DATA.0\n   OPTFLAG = POS('OPT2-FLAG',DATA.I)\n   IF OPTFLAG \u00ac= 0 THEN DO\n      OPTIMIZE_SW = 'YES'\n      C2P = 'COPT,APOST,LIB,RES,RENT,DYNAM'\n      LEAVE\n   END\nEND\nRETURN\n\n/*     */\nSET_QA_COMPILE_TYPE_RETURN_CODE:\nIF NATIVE_SW = 'YES' & OPTIMIZE_SW = 'NO'  THEN EXITRC = 1\nIF NATIVE_SW = 'NO'  & OPTIMIZE_SW = 'NO'  THEN EXITRC = 2\nIF NATIVE_SW = 'YES' & OPTIMIZE_SW = 'YES' THEN EXITRC = 3\nIF NATIVE_SW = 'NO'  & OPTIMIZE_SW = 'YES' THEN EXITRC = 4\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CCFQADB2": {"ttr": 3585, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x04\\x7f\\x00\\x94\\x04\\x7f\\x10\"\\x00@\\x00@\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-02-16T00:00:00", "modifydate": "1994-02-16T10:22:00", "lines": 64, "newlines": 64, "modlines": 0, "user": "TECH103"}, "text": "/* REXX EXEC : ( CCFQADB2 ).\n   FUNCTION  : READS SOURCE PROGRAM STATEMENTS TO DETERINE COBOL-II\n               COMPILE TYPE FOR QA MOVEMENT COMPILE DB2 ONLY.         */\nTRACE O\n/*     */\nHOUSE_KEEPING:\nADDRESS TSO\nARG MASTER MEMBER\nPARMS = 'MASTER MEMBER'\nDO I = 1 TO 2\n   IPARM = WORD(PARMS,I)\n   XPARM = VALUE(IPARM)\n   IF XPARM \u00ac= '' THEN ITERATE\n   SAY '*** PARM ERROR: MISSING PARM VALUE FOR ('IPARM'). ***'\n   SAY '*** CCFQADB2 EXEC TASK CANCELLED - RC = (024). ***'\n   EXIT 024\nEND\nOPTIMIZE_SW = 'NO'\nC2P = 'APOST,LIB,CMPR2,RES,RENT,DYNAM'\n\n/*     */\nMAIN_ROUTINE:\nCALL CHECK_NATIVE_FLAG\nCALL SET_QA_COMPILE_TYPE_RETURN_CODE\nEXIT EXITRC\n\n/*     S U B R O U T I N E   S E C T I O N     */\n/*     */\nCHECK_NATIVE_FLAG:\nNATIVE_SW = 'NO'\nLIBDSN = \"'\"MASTER\"(\"MEMBER\")'\"\nLIBDD = LIBALLOC(LIBDSN)  /* DYNALLOC LIBMASTER W/LAM; RET DDNAME*/\nIF LIBDD = \"ERROR\" THEN DO\n   ERC = 100\n   SAY '*** DYNAMIC ALLOCATION ERROR: ('MASTER'). ***'\n   SAY '*** CANNOT READ COBOL2 COMPILE TYPE FLAG FOR ('MEMBER') PROGRAM. ***'\n   SAY '*** CCFQADB2 EXEC SUBTASK CANCELLED - RC = ('ERC'). ***'\n   EXIT ERC\nEND\n\"EXECIO * DISKR\" LIBDD \"(FINIS STEM DATA.\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   ERC = 100\n   SAY '*** EXECIO READ ERROR: ('MASTER'('MEMBER'). ***'\n   SAY '*** CANNOT READ COBOL2 COMPILE TYPE FLAG FOR ('MEMBER') PROGRAM. ***'\n   SAY '*** CCFQADB2 EXEC SUBTASK CANCELLED - RC = ('ERC'). ***'\n   EXIT ERC\nEND\nDO I = 1 TO DATA.0\n   NOCMPR2 = POS('NOCMPR2-FLAG',DATA.I)\n   IF NOCMPR2 \u00ac= 0 THEN DO\n      NATIVE_SW = 'YES'\n      C2P = 'APOST,LIB,NOCMPR2,RES,RENT,DYNAM'\n      LEAVE\n   END\nEND\nRETURN\n/*     */\nSET_QA_COMPILE_TYPE_RETURN_CODE:\nIF NATIVE_SW = 'YES' & OPTIMIZE_SW = 'NO'  THEN EXITRC = 1\nIF NATIVE_SW = 'NO'  & OPTIMIZE_SW = 'NO'  THEN EXITRC = 2\nIF NATIVE_SW = 'YES' & OPTIMIZE_SW = 'YES' THEN EXITRC = 3\nIF NATIVE_SW = 'NO'  & OPTIMIZE_SW = 'YES' THEN EXITRC = 4\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CCFQADYL": {"ttr": 3587, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0e\\x00\\x00\\x00\\x91#O\\x00\\x93\\x18\\x9f\\x113\\x00\\xb5\\x00)\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf3@@@'", "ispf": {"version": "01.14", "flags": 0, "createdate": "1991-08-22T00:00:00", "modifydate": "1993-07-08T11:33:00", "lines": 181, "newlines": 41, "modlines": 0, "user": "TECH103"}, "text": "/* REXX EXEC : ( CCFQADYL ).\n   FUNCTION: INVOKED BY CCF SKELETON JCL ( CCFDYLQ ) FOR PROMOTION OF\n             DYLAKOR SOURCE PROGRAMS INTO QA OR PROD LIBRARIES.\n             THIS REXX EXEC PROGRAM WILL PERFORM THE FOLLOWING TASKS:\n             1. ALLOCATE A TSO USER WORK PDS FOR A PROGRAM MEMBER.\n             2. READ/CHECK THE SOURCE PROGRAM FOR THE NUMBER OF REPORTS\n                COMMENT INDICATOR.\n             3. BUILD THE IDCAMS DELETE LOAD MODULE SYSIN MEMBER.\n             4. BUILD THE IEBCOPY COPY LOAD MODULE SYSIN MEMBER.\n             INPUT  : ( SYS1.QASRCE.MASTER(&MEMBER).\n             OUTPUT : ( SYSS.QA.CCF.DYLAKOR.DYLCOPY.CNTLLIB(&MEMBER).\n                      ( SYSS.QA.CCF.DYLAKOR.DYLDEL01.CNTLLIB(&MEMBER).\n                      ( SYSS.QA.CCF.DYLAKOR.DYLDEL02.CNTLLIB(&MEMBER).\n                                                                      */\nTRACE O\n/*     */\nHOUSE_KEEPING:\nADDRESS TSO\nARG TSOID MASTER MEMBER\nPARMS = 'TSOID MASTER MEMBER'\nDO I = 1 TO 3\n   IPARM = WORD(PARMS,I)\n   XPARM = VALUE(IPARM)\n   IF XPARM \u00ac= '' THEN ITERATE\n   SAY '*** PARM ERROR: MISSING PARM VALUE FOR ('IPARM'). ***'\n   SAY '*** CCFQADYL EXEC TASK CANCELLED - RC = (024). ***'\n   EXIT 024\nEND\nLIBNODE = POS('PRODSRCE',MASTER)\nIF LIBNODE \u00ac= 0 THEN EXIT 2\nLIBNODE = POS('QASRCE',MASTER)\nIF LIBNODE = 0 THEN EXIT 0\nPREFIX = SUBSTR(MEMBER,1,6)\nDEL.1 = \"  IF LASTCC = 8 THEN\"\nDEL.2 = \"     DO\"\nDEL.3 = \"       SET MAXCC = 0\"\nDEL.4 = \"     END\"\n\n/*     */\nMAIN_ROUTINE:\nCALL GET_REPORTS_NUMBER\nCALL BUILD_REPORT_MODULE_LIST\nLOADLIB = 'SYS1.TEST.BATCH.LOADLIB'\nCALL BUILD_IDCAMS_TEST_DELETE_SYSIN\nOUTMEMB = 'DYLDEL01'\nCALL WRITE_SYSIN_MEMBER\nLOADLIB = 'SYS1.QA.BATCH.LOADLIB'\nCALL BUILD_IDCAMS_QA_DELETE_SYSIN\nOUTMEMB = 'DYLDEL02'\nCALL WRITE_SYSIN_MEMBER\nCALL BUILD_IEBCOPY_COPY_SYSIN\nOUTMEMB = 'DYLCOPY'\nCALL WRITE_SYSIN_MEMBER\nEXIT 1\n\n/*     S U B R O U T I N E   S E C T I O N     */\n/*     */\nGET_REPORTS_NUMBER:\nADDRESS TSO\nRPTSW = 'NO'\nLIBDSN = \"'\"MASTER\"(\"MEMBER\")'\"\nLIBDD = LIBALLOC(LIBDSN)  /* DYNALLOC LIBMASTER W/LAM; RET DDNAME*/\nIF LIBDD = \"ERROR\" THEN DO\n   ERC = 100\n   SAY '*** DYNAMIC ALLOCATION ERROR: ('MASTER'). ***'\n   SAY '*** REPORTS FLAG CANNOT BE READ FOR ('MEMBER') PROGRAM. ***'\n   SAY '*** CCFQADYL EXEC SUBTASK CANCELLED - RC = ('ERC'). ***'\n   EXIT ERC\nEND\n\"EXECIO * DISKR\" LIBDD \"(FINIS STEM DATA.\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   ERC = 100\n   SAY '*** EXECIO READ ERROR: ('MASTER'('MEMBER'). ***'\n   SAY '*** REPORTS FLAG CANNOT BE READ FOR ('MEMBER') PROGRAM. ***'\n   SAY '*** CCFQADYL EXEC SUBTASK CANCELLED - RC = ('ERC'). ***'\n   EXIT ERC\nEND\nDO I = 1 TO DATA.0\n   REPTFLG = POS('* REPORTS = ',DATA.1)\n   IF REPTFLG \u00ac= 0 THEN DO\n      NUMREPTS = WORD(DATA.1,4)\n      IF NUMREPTS = '' THEN ITERATE\n      RTYP = DATATYPE(NUMREPTS)\n      IF RTYP = 'NUM' THEN DO\n         RPTSW = 'YES'\n         LEAVE\n      END\n   END\nEND\nIF RPTSW = 'NO' THEN NUMREPTS = 1\nRETURN\n\n/*     */\nBUILD_REPORT_MODULE_LIST:\nM = 0\nMCNT = 0\nDO NUMREPTS\n   M = M + 1\n   IF M = 1 THEN DO\n      MCNT = MCNT + 1\n      MOD.MCNT = MEMBER\n      ITERATE\n   END\n   MCNT = MCNT + 1\n   MLEN = LENGTH(M)\n   IF MLEN = 1 THEN MOD.MCNT = PREFIX||'0'M\n   IF MLEN = 2 THEN MOD.MCNT = PREFIX||M\nEND\nRETURN\n\n/*     */\nBUILD_IDCAMS_TEST_DELETE_SYSIN:\n\"DELSTACK\"\nDO M = 1 TO MCNT\n   RECORD = \"  DELETE \"LOADLIB\"(\"MOD.M\") FILE(LOADLIB)\"\n   QUEUE RECORD\nEND\nDO D = 1 TO 4\n   QUEUE DEL.D\nEND\nRETURN\n\n/*     */\nBUILD_IDCAMS_QA_DELETE_SYSIN:\n\"DELSTACK\"\nDO M = 1 TO MCNT\n   RECORD = \"  DELETE \"LOADLIB\"(\"MOD.M\") FILE(LOADLIB)\"\n   QUEUE RECORD\nEND\nDO D = 1 TO 4\n   QUEUE DEL.D\nEND\nRETURN\n\n/*     */\nBUILD_IEBCOPY_COPY_SYSIN:\nI = 0\nM = 0\nCNTL = \"       SELECT MEMBER=(\"\n\"DELSTACK\"\nRECORD = \"  COPY OUTDD=OUTDD1\"\nQUEUE RECORD\nRECORD = \"       INDD=((INDD1,R))\"\nQUEUE RECORD\nDO MCNT\n   M = M + 1\n   I = I + 1\n   IF I = 1 THEN SYSIN = CNTL||MOD.M\n   IF (I > 1) & (I < 5) THEN SYSIN = SYSIN||\",\"||MOD.M\n   IF (I = 5) THEN DO\n      SYSIN = SYSIN||\",\"||MOD.M||\")\"\n      QUEUE SYSIN\n      I = 0\n   END\nEND\nIF I > 0 THEN DO\n   SYSIN = SYSIN||\")\"\n   QUEUE SYSIN\nEND\nRETURN\n\n/*     */\nWRITE_SYSIN_MEMBER:\n\"ALLOC DA('SYSS.QA.CCF.DYLAKOR.\"OUTMEMB\".CNTLLIB(\"MEMBER\")') FILE(DYLDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('OUTMEMB'('MEMBER'). ***'\n   SAY '*** CCFQADYL EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT 8\nEND\nRCDCNT = QUEUED()\n\"EXECIO\" RCDCNT \"DISKW DYLDD (FINIS\"\nSRC = RC\n\"FREE FILE(DYLDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** EXECIO WRITE ERROR: ('OUTMEMB'('MEMBER'). ***'\n   SAY '*** CCFQADYL EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT 8\nEND\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CCFQASMB": {"ttr": 3591, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x12\\x00\\x00\\x00\\x91\\x16\\x8f\\x00\\x910_\\x15\\x14\\x00v\\x00U\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf3@@@'", "ispf": {"version": "01.18", "flags": 0, "createdate": "1991-06-17T00:00:00", "modifydate": "1991-11-01T15:14:00", "lines": 118, "newlines": 85, "modlines": 0, "user": "TECH103"}, "text": "/*  CA-LIBRARIAN LIB/CCF/ELIPS ASSEMBLE/COMPILE REXX EXEC AND ISPF\n    PANEL DIALOG FOR Q/A LIBRARY TURNOVER - ( BATCH PROGRAMS ).       */\n\nTRACE O\n/*     */\nHOUSE_KEEPING:\nADDRESS TSO\nSAVEMEMB = 'NULLMEMB'\nACCTCDE = 5302010530000000\nJCL.1 = 'QAASM'\nJCL.2 = 'QACOB'\nJCL.3 = 'QACOB2'\nJCL.4 = 'QADYL'\nJCL.5 = 'QARPG'\nJCL.6 = 'QARPI'\nTSOID = SYSVAR(SYSUID)\nMASTER = 'SYS1.TESTSRCE.MASTER'\nCP = 'APOST'\nC2P = 'APOST,LIB,CMPR2,RENT,RES,DYNAM'\nCCFLOAD = 'SYS1.QA.BATCH.LOADLIB'\nADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\nADDRESS ISPEXEC \"FTCLOSE\"\n\n/*     */\nDISPLAY_PANEL:\nDO FOREVER\n   ADDRESS ISPEXEC \"DISPLAY PANEL(CCFQASMB)\"\n   SRC = RC\n   IF SRC = 8 THEN LEAVE\n   IF SRC > 8 THEN DO\n      SAY '*** ERROR INVOKING ISPF DIALOG PANEL CCFQASMB - RC = 'SRC'.***'\n      EXIT SRC\n   END\n   CTYP = COMPTYP\n   IF MEMBER = SAVEMEMB THEN EXIT\n   CALL SELECT_COMPILE_JCL\n   IF SKELJCL = 'QACOB2' THEN CALL CHECK_COBOL2_NATIVE_FLAG\n   CALL SUBMIT_COMPILE_JCL\nEND\nEXIT\n\n/*     */\nSELECT_COMPILE_JCL:\nSAVEMEMB = MEMBER\nSKELJCL = JCL.CTYP\nLOADLIB = CCFLOAD\nRETURN\n\n/*     */\nCHECK_COBOL2_NATIVE_FLAG:\nADDRESS TSO\nLIBDSN = \"'SYS1.TESTSRCE.MASTER(\"MEMBER\")'\"\nLIBDD = LIBALLOC(LIBDSN)  /* DYNALLOC LIBMASTER W/LAM; RET DDNAME*/\nIF LIBDD = \"ERROR\" THEN DO\n   SAY '*** INVALID OR MISSING LIBRARIAN MASTER FILENAME. ***'\n   SAY '*** CCFQASMB EXEC SUBTASK CANCELLED. ***'\n   EXIT 4\nEND\n\"EXECIO * DISKR\" LIBDD \"(FINIS STEM PROGDATA.\"\nSRC = RC\nSAY PROGDATA.0\nSAY PROGDATA.1\n\"FREE DATASET(\"MASTER\")\"\nEXIT\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** INVALID OR MISSING LIBRARIAN MEMBER NAME. ***'\n   SAY '*** CCFQASMB EXEC SUBTASK CANCELLED. ***'\n   EXIT 4\nEND\nDO I = 1 TO PROGDATA.0\n   NOCMPR2 = POS('NOCMPR2-FLAG',PROGDATA.I)\n   IF NOCMPR2 \u00ac=0 THEN DO\n      DELSTACK\n      C2P = 'APOST,LIB,NOCMPR2,RENT,RES,DYNAM'\n      LEAVE\n   END\nEND\nRETURN\n\n/*     */\nSUBMIT_COMPILE_JCL:\nADDRESS ISPEXEC \"FTOPEN TEMP\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   ZERRMSG = CCFQA001\n   ADDRESS ISPEXEC \"SETMSG MSG(CCFQA001)\"\n   RETURN\n   END\nADDRESS ISPEXEC \"FTINCL CCFQJOBC\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   ZERRMSG = CCFQA002\n   ADDRESS ISPEXEC \"SETMSG MSG(CCFQA002)\"\n   RETURN\n   END\nADDRESS ISPEXEC \"FTINCL\" SKELJCL\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   ZERRMSG = CCFQA003\n   ADDRESS ISPEXEC \"SETMSG MSG(CCFQA003)\"\n   RETURN\n   END\nADDRESS ISPEXEC \"FTCLOSE\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   ZERRMSG = CCFQA005\n   RETURN\n   END\nADDRESS ISPEXEC \"VGET ZTEMPF\"\nADDRESS TSO \"SUBMIT '\"ZTEMPF\"'\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   ZERRMSG = CCFQA006\n   RETURN\n   END\nZERRMSG = CCFQA000\nADDRESS ISPEXEC \"SETMSG MSG(CCFQA000)\"\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CCFQDYL": {"ttr": 3594, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x08\\x00\\x00\\x00\\x91#O\\x00\\x93\\x12\\x0f\\x11Q\\x00~\\x00)\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf3@@@'", "ispf": {"version": "01.08", "flags": 0, "createdate": "1991-08-22T00:00:00", "modifydate": "1993-04-30T11:51:00", "lines": 126, "newlines": 41, "modlines": 0, "user": "TECH103"}, "text": "/* REXX EXEC  */\n/* LIB/CCF DYLAKOR QA TURNOVER COMPILE FACILITY TO DETERMINE IF THE\n   SOURCE PROGRAM CONTAINS COMMENT TO INDICATE A MULTIPLE REPORT AND\n   MULTIPLE LOAD MODULE TO BE MOVED.   */\n\nTRACE O\n/*     */\nHOUSE_KEEPING:\nARG TSOUSER MEMBER\nIF MEMBER = '' THEN DO\n   SAY '*** MEMBER NAME NOT PASSED ON COMMAND LINE. ***'\n   EXIT 4\nEND\nEXITRC = 4\nPREFIX = SUBSTR(MEMBER,1,6)\nDELTEST = '  DELETE SYS1.TEST.BATCH.LOADLIB'\nDELQA = '  DELETE SYS1.QA.BATCH.LOADLIB'\nADDRESS TSO\n\"ALLOC DA('\"TSOUSER\".\"MEMBER\".SEQFILE') F(ISPFILE) SHR\"\nIF RC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR:' TSOUSER||'.'||MEMBER||'.'||SEQFILE '***'\n   EXIT 8\nEND\n\"EXECIO 1 DISKR ISPFILE (FINIS STEM REPORT.\"\nSRC = RC\n\"FREE F(ISPFILE)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET EXECIO ERROR:' TSOUSER||'.'||MEMBER||'.'||SEQFILE '***'\n   EXIT 8\nEND\nREPTFLG = POS('* REPORTS = ',REPORT.1)\nIF REPTFLG \u00ac= 0 THEN DO\n   NUMREPTS = WORD(REPORT.1,4)\n   IF NUMREPTS = '' THEN EXIT EXITRC\n   RTYP = DATATYPE(NUMREPTS)\n   IF RTYP = 'NUM' THEN DO\n      CALL BUILD_REPORT_MODULE_LIST\n      CALL BUILD_DELETE_TEST_SYSIN\n      CALL BUILD_COPY_MODULE_SYSIN\n      CALL BUILD_DELETE_QA_SYSIN\n      EXITRC = 0\n   END\nEND\nEXIT EXITRC\n/*     */\nBUILD_REPORT_MODULE_LIST:\nM = 0\nMCNT = 0\nDO NUMREPTS\n   M = M + 1\n   IF M = 1 THEN ITERATE\n   MCNT = MCNT + 1\n   MLEN = LENGTH(M)\n   IF MLEN = 1 THEN MOD.MCNT = PREFIX||'0'M\n   IF MLEN = 2 THEN MOD.MCNT = PREFIX||M\nEND\nRETURN\n/*     */\nBUILD_DELETE_TEST_SYSIN:\nM = 0\nPDSMEMB = 'DYLDELTS'\n\"DELSTACK\"\nDO MCNT\n   M = M + 1\n   RECORD = DELTEST||\"(\"MOD.M\") FILE(DASDVOL)\"\n   QUEUE RECORD\nEND\nCALL WRITE_PDS_MEMBER\nRETURN\n/*     */\nBUILD_COPY_MODULE_SYSIN:\nI = 0\nM = 0\nPDSMEMB = 'DYLCOPY'\nCNTL = \"       SELECT MEMBER=(\"\n\"DELSTACK\"\nRECORD = \"  COPY OUTDD=OUTDD1\"\nQUEUE RECORD\nRECORD = \"       INDD=((INDD1,R))\"\nQUEUE RECORD\nDO MCNT\n   M = M + 1\n   I = I + 1\n   IF I = 1 THEN SYSIN = CNTL||MOD.M\n   IF (I > 1) & (I < 5) THEN SYSIN = SYSIN||\",\"||MOD.M\n   IF (I = 5) THEN DO\n      SYSIN = SYSIN||\",\"||MOD.M||\")\"\n      QUEUE SYSIN\n      I = 0\n   END\nEND\nIF I > 0 THEN DO\n   SYSIN = SYSIN||\")\"\n   QUEUE SYSIN\nEND\nCALL WRITE_PDS_MEMBER\nRETURN\n/*     */\nBUILD_DELETE_QA_SYSIN:\nM = 0\nPDSMEMB = 'DYLDELQA'\n\"DELSTACK\"\nDO MCNT\n   M = M + 1\n   RECORD = DELQA||\"(\"MOD.M\") FILE(DASDVOL)\"\n   QUEUE RECORD\nEND\nCALL WRITE_PDS_MEMBER\nRETURN\n/*     */\nWRITE_PDS_MEMBER:\nADDRESS TSO\n\"ALLOC DA('SYSS.TESTCCF.TURNOVER.CNTLLIB(\"PDSMEMB\")') F(DYLCNTL) OLD\"\nIF RC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ( SYSS.TESTCCF.TURNOVER.CNTLLIB ). ***'\n   EXIT 8\nEND\nRCDCNT = QUEUED()\n\"EXECIO\" RCDCNT \"DISKW DYLCNTL (FINIS\"\nSRC = RC\n\"FREE F(DYLCNTL)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET EXECIO ERROR: ( SYSS.TESTCCF.TURNOVER.CNTLLIB ). ***'\n   EXIT 8\nEND\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CCFQREXX": {"ttr": 3597, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x00\\x00\\x00\\x91\\x17\\x1f\\x00\\x91\\x17/\\x12R\\x00#\\x00\\x12\\x00\\x00\\xe3\\xc4\\xc2\\xd6\\xe6\\xc5\\xd5@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "1991-06-20T00:00:00", "modifydate": "1991-06-21T12:52:00", "lines": 35, "newlines": 18, "modlines": 0, "user": "TDBOWEN"}, "text": "/* REXX EXEC  */\n/* LIB/CCF COBOL2 QA TURNOVER COMPILE FACILITY TO DETERMINE NATIVE OR\n   COMPATIBILITY MODE COMPILE OPTION   */\n\nTRACE O\n/*     */\nHOUSE_KEEPING:\nARG TSOUSER MEMBER\nIF MEMBER = '' THEN DO\n   SAY '*** MEMBER NAME NOT PASSED ON COMMAND LINE. ***'\n   EXIT 8\nEND\nEXITRC = 4\nC2P = 'APOST,LIB,CMPR2,RES,RENT,DYNAM'\nADDRESS TSO\n\"ALLOC DA('\"TSOUSER\".\"MEMBER\".SEQFILE') F(ISPFILE) SHR\"\nIF RC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR:' TSOUSER||'.'||MEMBER||'.'||SEQFILE '***'\n   EXIT 8\nEND\n\"EXECIO * DISKR ISPFILE (FINIS STEM DATA.\"\nIF RC \u00ac= 0 THEN DO\n   SAY '*** DATASET EXECIO ERROR:' TSOUSER||'.'||MEMBER||'.'||SEQFILE '***'\n   EXIT 8\nEND\nDO I = 1 TO DATA.0\n   NOCMPR2 = POS('NOCMPR2-FLAG',DATA.I)\n   IF NOCMPR2 \u00ac= 0 THEN DO\n      EXITRC = 0\n      C2P = 'APOST,LIB,NOCMPR2,RES,RENT,DYNAM'\n      LEAVE\n   END\nEND\n\"FREE F(ISPFILE)\"\nEXIT EXITRC\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CCFRARCH": {"ttr": 3841, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00\\x00\\x00\\x924/\\x00\\x95\\x17\\x9f\\t#\\x00\\xae\\x00\\xae\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf3@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "1992-12-07T00:00:00", "modifydate": "1995-06-28T09:23:00", "lines": 174, "newlines": 174, "modlines": 0, "user": "TECH103"}, "text": "/*  REXX EXEC : ( CCFRARCH ).\n    FUNCTION  : ISPF PANEL INTERFACE TO ALLOW THE RESTORE OF \"TEST\"\n                LIBRARIAN MEMBER(S) FROM THE ARCHIVE MAINT BACKUP TAPE.\n    INPUT     : ARCHIVE LIBRARIAN BACKUP TAPES.\n    OUTPUT    : BATCH JOB WRITTEN: ( TSOID.DIALOG.ISPFILE(JOBNAME))\n                AND SUBMITTED TO SYSA SYSTEM CLASS=W.\n                                                                     */\nTRACE O\n/*     */\nHOUSE_KEEPING:\nADDRESS TSO\nUCNTL = SYSDSN(DIALOG.ISPFILE)\nIF UCNTL = 'DATASET NOT FOUND' THEN DO\n\"ALLOC DA(DIALOG.ISPFILE) LIKE(USER.CNTLLIB) NEW SPACE(1,0) DIR(5) CYLINDERS\"\n   SRC = RC\n   IF SRC \u00ac= 0 THEN DO\n   SAY '*** ALLOCATE ERROR: ERROR ALLOCATING DATASET (DIALOG.ISPFILE). ***'\n   SAY '*** CCFRARCH EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\n   END\nEND\nHLQ = 'PTAP.BACKUP.ARCHIVE'\nACCTCCF = '5200010520000000'\nTSOID = SYSVAR(SYSUID)\nLIBNODES = 'TESTPROC TESTSRCE TESTSYSI'\nTAPELBL = '1 1 1'\nX = MSG(\"OFF\")\n\"FREE FILE(ISPFILE)\"\nADDRESS ISPEXEC\n\"VGET (ACCTCDE) PROFILE\"\nIF RC \u00ac= 0 THEN ACCTCDE = ACCTCCF\n\n/*     */\nMAIN_ROUTINE:\nCALL DISPLAY_PANEL\nADDRESS TSO\nCALL ASSIGN_RESTORE_VARIABLES\nCALL ALLOC_CNTLPDS\nCALL BUILD_LBRESTORE_JOBJCL\nCALL BUILD_LBRESTORE_MEMBERS\nCALL BUILD_LBRESTORE_ENDJCL\nCALL WRITE_LBRESTORE_PDSMEMB\nCALL SUBMIT_LBRESTORE_JOB\nEXIT 0\n\n/*     S U B R O U T I N E S   S E C T I O N     */\n/*     */\nDISPLAY_PANEL:\nADDRESS ISPEXEC\n\"CONTROL ERRORS RETURN\"\n\"DISPLAY PANEL(CCFRARCP)\"\nSRC = RC\nIF SRC = 8 THEN EXIT 0\nIF SRC > 8 THEN DO\n   SAY '*** ERROR INVOKING ISPF DIALOG PANEL: CCFRARCP - RC = 'SRC'. ***'\n   SAY '*** CCFRARCH EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nRETURN\n\n/*     */\nASSIGN_RESTORE_VARIABLES:\nG = 0\nJN = JOBNAME\nACCTUSR = ACCTCDE\nNODE = WORD(LIBNODES,LIB)\nLBL = WORD(TAPELBL,LIB)\nM = 0\nR = 0\nMEMCNT = 0\nDO 20\n   R = R + 1\n   MEMBER = VALUE('MEMB'R)\n   IF MEMBER = '' THEN ITERATE\n   M = M + 1\n   MEMB.M = MEMBER\n   MEMCNT = MEMCNT + 1\nEND\nRETURN\n\n/*     */\nALLOC_CNTLPDS:\n\"ALLOC DA(DIALOG.ISPFILE(\"JOBNAME\")) FILE(ISPFILE) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: (DIALOG.ISPFILE('JOBNAME'). ***'\n   SAY '*** CCFRARCH EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nRETURN\n\n/*     */\nBUILD_LBRESTORE_JOBJCL:\nJ = 0\nRCDCNT = 16\n\"DELSTACK\"\nJCL.1 = \"//\"JN\" JOB\" ACCTUSR\",'\"TSOID\".LIB.REST.MOD',NOTIFY=\"TSOID\",\"\nJCL.2 = \"//             CLASS=W,MSGCLASS=S,MSGLEVEL=(1,0),REGION=4M\"\nJCL.3 = \"/*JOBPARM SYSAFF=SYSA\"\nJCL.4 = \"//SELECT   EXEC PGM=AFOLIBR,PARM='NRJS,NJTA'\"\nJCL.5 = \"//SYSAF01  DD UNIT=SYSDA,SPACE=(TRK,(10,5))\"\nJCL.6 = \"//SYSAF02  DD UNIT=SYSDA,SPACE=(TRK,(10,5))\"\nJCL.7 = \"//MASTIN   DD UNIT=SILO,DSN=\"HLQ\".\"NODE\"(\"G\"),\"\nJCL.8 = \"//         LABEL=(\"LBL\",SL),DISP=(OLD,KEEP)\"\nJCL.9 = \"//OSJOB    DD DSN=&&SELMEMB,UNIT=SYSDA,\"\nJCL.10 = \"//         DCB=(RECFM=FB,LRECL=80,BLKSIZE=8000),\"\nJCL.11 = \"//         SPACE=(CYL,(1,1)),DISP=(NEW,PASS)\"\nJCL.12 = \"//SYSPRINT DD SYSOUT=*\"\nJCL.13 = \"//LIST     DD SYSOUT=*\"\nJCL.14 = \"//INDEX    DD SYSOUT=*\"\nJCL.15 = \"//SYSIN    DD *\"\nJCL.16 = \"-OPT UTILITY,NOCYCLE\"\nDO RCDCNT\n   J = J + 1\n   QUEUE JCL.J\nEND\nRETURN\n\n/*     */\nBUILD_LBRESTORE_MEMBERS:\nM = 0\nDO MEMCNT\n   M = M + 1\n   RECORD = \"-COPY\" MEMB.M\n   QUEUE RECORD\nEND\nRETURN\n\n/*     */\nBUILD_LBRESTORE_ENDJCL:\nJ = 0\nRCDCNT = 11\nJCL.1 = \"-END\"\nJCL.2 = \"/*\"\nJCL.3 = \"//RESTORE  EXEC PGM=AFOLIBR,PARM='NRJS,NJTA',COND=(0,LT,SELECT)\"\nJCL.4 = \"//MASTER   DD DSN=SYS1.\"NODE\".MASTER,DISP=SHR\"\nJCL.5 = \"//OSJOB    DD DUMMY\"\nJCL.6 = \"//SYSPRINT DD SYSOUT=*\"\nJCL.7 = \"//LIST     DD SYSOUT=*\"\nJCL.8 = \"//INDEX    DD SYSOUT=*\"\nJCL.9 = \"//SYSIN    DD DSN=&&SELMEMB,DISP=(OLD,DELETE)\"\nJCL.10 = \"/*\"\nJCL.11 = \"//\"\nDO RCDCNT\n   J = J + 1\n   QUEUE JCL.J\nEND\nRETURN\n\n/*     */\nWRITE_LBRESTORE_PDSMEMB:\nNUMRCDS = QUEUED()\n\"EXECIO\" NUMRCDS \"DISKW ISPFILE (FINIS\"\nSRC = RC\n\"FREE FILE(ISPFILE)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** WRITE ERROR: ERROR WRITING 'TSOID'.DIALOG.ISPFILE('JOBNAME'). ***'\n   SAY '*** CCFRARCH EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nRETURN\n\n/*     */\nSUBMIT_LBRESTORE_JOB:\n\"SUBMIT (DIALOG.ISPFILE(\"JOBNAME\"))\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** SUBMIT ERROR: 'TSOID'.DIALOG.ISPFILE('JOBNAME'). ***'\n   SAY '*** CCFRARCH EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nSAY '+++ JOB: 'JOBNAME' SUBMITTED TO THE SYSA SYSTEM - CLASS=W. +++'\n\"DELETE (DIALOG.ISPFILE) SCRATCH PURGE NONVSAM\"\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CCFRMEMB": {"ttr": 3845, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x13\\x00\\x00\\x00\\x923\\x9f\\x00\\x95\\x02\\x1f\\x10&\\x00\\xa3\\x00\\x80\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf3@@@'", "ispf": {"version": "01.19", "flags": 0, "createdate": "1992-12-04T00:00:00", "modifydate": "1995-01-21T10:26:00", "lines": 163, "newlines": 128, "modlines": 0, "user": "TECH103"}, "text": "/*  REXX EXEC : ( CCFRMEMB ).\n    FUNCTION  : ISPF PANEL INTERFACE TO ALLOW THE RESTORE OF \"TEST\"\n                LIBRARIAN MEMBER(S) FROM THE DAILY BACKUP TAPES.\n    INPUT     : DAILY LIBRARIAN BACKUP TAPES.\n    OUTPUT    : BATCH JOB WRITTEN: ( SYSS.TESTCCF.ISPFILE.CNTLLIB ).\n                AND SUBMITTED TO SYSA SYSTEM CLASS=W.\n                                                                     */\nTRACE O\n/*     */\nHOUSE_KEEPING:\nADDRESS TSO\nHLQ = 'PTAP'\nACCTCCF = '5200010520000000'\nTSOID = SYSVAR(SYSUID)\nLIBNODES = 'TESTCOPY TESTJCL TESTPROC TESTRAMI TESTSRCE TESTSYSI'\nTAPELBL = '12 6 9 18 3 15'\nCNTLLIB = 'SYSS.TESTCCF.ISPFILE.CNTLLIB'\nX = MSG(\"OFF\")\n\"FREE FILE(CNTLDD)\"\nADDRESS ISPEXEC\n\"VGET (ACCTCDE) PROFILE\"\nIF RC \u00ac= 0 THEN ACCTCDE = ACCTCCF\n\n/*     */\nMAIN_ROUTINE:\nCALL DISPLAY_PANEL\nADDRESS TSO\nCALL ASSIGN_RESTORE_VARIABLES\nCALL BUILD_LBRESTORE_JOBJCL\nCALL BUILD_LBRESTORE_MEMBERS\nCALL BUILD_LBRESTORE_ENDJCL\nCALL WRITE_LBRESTORE_PDSMEMB\nCALL SUBMIT_LBRESTORE_JOB\nEXIT 0\n\n/*     S U B R O U T I N E S   S E C T I O N     */\n/*     */\nDISPLAY_PANEL:\nADDRESS ISPEXEC\n\"CONTROL ERRORS RETURN\"\n\"DISPLAY PANEL(CCFRMEMP)\"\nSRC = RC\nIF SRC = 8 THEN EXIT 0\nIF SRC > 8 THEN DO\n   SAY '*** ERROR INVOKING ISPF DIALOG PANEL: CCFRMEMP - RC = 'SRC'. ***'\n   SAY '*** CCFRMEMB EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nRETURN\n\n/*     */\nASSIGN_RESTORE_VARIABLES:\nG = GDG\nIF GDG > 0 THEN G = '-'||GDG\nJN = JOBNAME\nACCTUSR = ACCTCDE\nNODE = WORD(LIBNODES,LIB)\nLBL = WORD(TAPELBL,LIB)\nM = 0\nR = 0\nMEMCNT = 0\nDO 20\n   R = R + 1\n   MEMBER = VALUE('MEMB'R)\n   IF MEMBER = '' THEN ITERATE\n   M = M + 1\n   MEMB.M = MEMBER\n   MEMCNT = MEMCNT + 1\nEND\nRETURN\n\n/*     */\nBUILD_LBRESTORE_JOBJCL:\nJ = 0\nRCDCNT = 16\n\"DELSTACK\"\nJCL.1 = \"//\"JN\" JOB\" ACCTUSR\",'\"TSOID\".LIB.REST.MOD',NOTIFY=\"TSOID\",\"\nJCL.2 = \"//          CLASS=W,MSGCLASS=S,MSGLEVEL=(1,0),REGION=4M\"\nJCL.3 = \"/*JOBPARM SYSAFF=SYSA\"\nJCL.4 = \"//SELECT   EXEC PGM=AFOLIBR,PARM='NRJS,NJTA'\"\nJCL.5 = \"//SYSAF01  DD UNIT=SYSDA,SPACE=(TRK,(10,5))\"\nJCL.6 = \"//SYSAF02  DD UNIT=SYSDA,SPACE=(TRK,(10,5))\"\nJCL.7 = \"//MASTIN   DD UNIT=SILO,DSN=\"HLQ\".\"NODE\".MASTER(\"G\"),\"\nJCL.8 = \"//         LABEL=(\"LBL\",SL),DISP=(OLD,KEEP)\"\nJCL.9 = \"//OSJOB    DD DSN=&&SELMEMB,UNIT=SYSDA,\"\nJCL.10 = \"//         DCB=(RECFM=FB,LRECL=80,BLKSIZE=8000),\"\nJCL.11 = \"//         SPACE=(CYL,(1,1)),DISP=(NEW,PASS)\"\nJCL.12 = \"//SYSPRINT DD SYSOUT=*\"\nJCL.13 = \"//LIST     DD SYSOUT=*\"\nJCL.14 = \"//INDEX    DD SYSOUT=*\"\nJCL.15 = \"//SYSIN    DD *\"\nJCL.16 = \"-OPT UTILITY,NOCYCLE\"\nDO RCDCNT\n   J = J + 1\n   QUEUE JCL.J\nEND\nRETURN\n\n/*     */\nBUILD_LBRESTORE_MEMBERS:\nM = 0\nDO MEMCNT\n   M = M + 1\n   RECORD = \"-COPY\" MEMB.M\n   QUEUE RECORD\nEND\nRETURN\n\n/*     */\nBUILD_LBRESTORE_ENDJCL:\nJ = 0\nRCDCNT = 11\nJCL.1 = \"-END\"\nJCL.2 = \"/*\"\nJCL.3 = \"//RESTORE  EXEC PGM=AFOLIBR,PARM='NRJS,NJTA',COND=(0,LT,SELECT)\"\nJCL.4 = \"//MASTER   DD DSN=SYS1.\"NODE\".MASTER,DISP=SHR\"\nJCL.5 = \"//OSJOB    DD DUMMY\"\nJCL.6 = \"//SYSPRINT DD SYSOUT=*\"\nJCL.7 = \"//LIST     DD SYSOUT=*\"\nJCL.8 = \"//INDEX    DD SYSOUT=*\"\nJCL.9 = \"//SYSIN    DD DSN=&&SELMEMB,DISP=(OLD,DELETE)\"\nJCL.10 = \"/*\"\nJCL.11 = \"//\"\nDO RCDCNT\n   J = J + 1\n   QUEUE JCL.J\nEND\nRETURN\n\n/*     */\nWRITE_LBRESTORE_PDSMEMB:\nADDRESS TSO\n\"ALLOC DA('\"CNTLLIB\"(\"JOBNAME\")') FILE(CNTLDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('CNTLLIB'('JOBNAME'). ***'\n   SAY '*** CCFSCAN EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nNUMRCDS = QUEUED()\n\"EXECIO\" NUMRCDS \"DISKW CNTLDD (FINIS\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** WRITE ERROR: ERROR WRITING 'CNTLLIB'('JOBNAME'). ***'\n   SAY '*** CCFRMEMB EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nRETURN\n\n/*     */\nSUBMIT_LBRESTORE_JOB:\nADDRESS TSO\n\"SUBMIT ('\"CNTLLIB\"(\"JOBNAME\")')\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** SUBMIT ERROR: 'CNTLLIB'('JOBNAME'). ***'\n   SAY '*** CCFRMEMB EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nSAY '+++ JOB: 'JOBNAME' SUBMITTED TO THE SYSA SYSTEM - CLASS=W. +++'\n\"DELETE '\"CNTLLIB\"(\"JOBNAME\")'  FILE(CNTLDD)\"\n\"FREE FILE(CNTLDD)\"\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CCFSCAN": {"ttr": 3849, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01O\\x00\\x00\\x00\\x91$\\x7f\\x00\\x95#\\x7f\\x14P\\x00\\xe4\\x03\\xd1\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf3@@@'", "ispf": {"version": "01.79", "flags": 0, "createdate": "1991-09-04T00:00:00", "modifydate": "1995-08-25T14:50:00", "lines": 228, "newlines": 977, "modlines": 0, "user": "TECH103"}, "text": "/*  REXX EXEC :\n    THIS EXEC IS DESIGNED TO FACILITATE THE CA-LIBRARIAN SCAN UTILITY\n    OF MODULES RESIDING ON A MASTER DATASET.  */\n\nTRACE O\n/*     */\nHOUSE_KEEPING:\nADDRESS ISPEXEC\n\"CONTROL ERRORS RETURN\"\nACCTCCF = 5200010520000000\nLIBSTAT.1 = 'TEST'\nLIBSTAT.2 = 'TURN'\nLIBSTAT.3 = 'QA'\nLIBSTAT.4 = 'EMRG'\nLIBSTAT.5 = 'PROD'\nLIBTYPE.1 = 'COPY'\nLIBTYPE.2 = 'JCL'\nLIBTYPE.3 = 'PROC'\nLIBTYPE.4 = 'RAMI'\nLIBTYPE.5 = 'SRCE'\nLIBTYPE.6 = 'SYSI'\nM = 'S'\nSC = 01\nEC = 72\nJC = 8\nBEGMOD = '*'\nENDMOD = 'ALL'\nSCOD = 'ALL'\nLN = 00\nDELIM = ''\nDELIMITER = '/ @ $ % *'\nTSOID = SYSVAR(SYSUID)\nTSOUS = SUBSTR(TSOID,1,4)\nIF TSOUS = 'TECH' THEN M = 'G'\n\"VGET (ACCTCDE) PROFILE\"\nIF RC \u00ac= 0 THEN ACCTCDE = ACCTCCF\nADDRESS TSO\nX = MSG(\"OFF\")\n\"FREE FILE(CNTLDD)\"\nCNTLLIB = 'SYSS.TESTCCF.ISPFILE.CNTLLIB'\nMEMBER = TSOID'J'\n\n/*     */\nDISPLAY_LIBSCAN_PANELS:\nADDRESS ISPEXEC\n\"DISPLAY PANEL(LBSCANP1)\"\nSRC = RC\nIF SRC > 8 THEN DO\n   SAY '*** PANEL ERROR: ISPF DIALOG ERROR INVOKING PANEL ( LBSCANP1 ). ***'\n   SAY '*** LIBSCAN EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT\nEND\nIF SRC = 8 THEN EXIT 0\n\"DISPLAY PANEL(LBSCANP2)\"\nSRC = RC\nIF SRC > 8 THEN DO\n   SAY '*** PANEL ERROR: ISPF DIALOG ERROR INVOKING PANEL ( LBSCANP2 ). ***'\n   SAY '*** LIBSCAN EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT\nEND\nIF SRC = 8 THEN EXIT 0\n\n/*     */\nBUILD_SCAN_SUBMIT_JCL:\nADDRESS TSO\nCALL ASSIGN_SCAN_VARIABLES\nCALL BUILD_SCAN_JCL\nCALL BUILD_SCAN_SYSIN\nCALL WRITE_SCAN_JOB\nCALL SUBMIT_SCAN_JOB\n\"DELSTACK\"\n\"ALLOC DA('\"CNTLLIB\"(\"MEMBER\")') FILE(CNTLDD) SHR\"\n\"DELETE '\"CNTLLIB\"(\"MEMBER\")' FILE(CNTLDD)\"\n\"FREE FILE(CNTLDD)\"\nEXIT 0\n\n/*     S U B R O U T I N E S   S E C T I O N     */\n\n/*     */\nASSIGN_SCAN_VARIABLES:\nC = JC\nREGION = 'REGION=6M'\nS = LIBSTAT\nIF S = 1 THEN DO\n   C = 8\n   REGION = 'REGION=6M,TYPRUN=HOLD'\nEND\nT = LIBTYPE\nJN = JOBNAME\nJOBN = LENGTH(JN)\nUPPER SCAN1 SCAN2 SCAN3 SCAN4 SCAN5 SCAN6 SCAN7 SCAN8 SCAN9 SCAN10\nLBUSER = 'TEMP002'\nLBPW = 'LOGROUTE'\nIF JOBN < 8 THEN JN = LEFT(JN,8)\nMASTRDSN = 'SYSA.'LIBSTAT.S||LIBTYPE.T'.MASTER'\nSCOL = LENGTH(SC)\nIF SCOL < 2 THEN SC = RIGHT(SC,2,0)\nECOL = LENGTH(EC)\nIF ECOL < 2 THEN EC = RIGHT(EC,2,0)\nPLEN = LENGTH(LN)\nIF PLEN < 2 THEN LN = RIGHT(LN,2,0)\nZONE = 'STR='SC',END='EC\nLPRT = ',CTX='LN\nIF BEGMOD = '*' THEN DO\n   IF ENDMOD = 'ALL' THEN SCANR = '-SCANR ,Z9ZZZZZZ'\n   IF ENDMOD \u00ac= 'ALL' THEN SCANR = '-SCANR ,'||ENDMOD\n   RETURN\nEND\nIF ENDMOD = 'ALL' THEN SCANR = '-SCANR '||BEGMOD\nIF ENDMOD \u00ac= 'ALL' THEN SCANR = '-SCANR '||BEGMOD||','||ENDMOD\nRETURN\n\n/*     */\nBUILD_SCAN_JCL:\nJ = 0\n\"DELSTACK\"\nRCD.1 = \"//\"JN\" JOB\" ACCTCDE\",'\"TSOID\".LIBRSCAN',NOTIFY=\"TSOID\",\"\nRCD.2 = \"//     CLASS=\"C\",MSGCLASS=\"M\",MSGLEVEL=(0,0),\"REGION\nRCD.3 = \"//LIBRSCAN EXEC PGM=AFOLIBR\"\nRCD.4 = \"//SYSPRINT DD SYSOUT=*\"\nRCD.5 = \"//LIST     DD SYSOUT=*\"\nRCD.6 = \"//INDEX    DD SYSOUT=*\"\nRCD.7 = \"//OSJOB    DD DUMMY\"\nRCD.8 = \"//MASTER   DD DSN=\"MASTRDSN\",DISP=SHR\"\nRCD.9 = \"//OSJOB    DD DUMMY\"\nRCD.10 = \"//SYSIN    DD *\"\nRCD.11 = \"-OPT UTILITY\"\nDO 11\n   J = J + 1\n   QUEUE RCD.J\nEND\nIF ENDMOD \u00ac= 'ALL' THEN DO\n   J = J + 1\n   RCD.J = SCANR\n   QUEUE RCD.J\nEND\nRETURN\n\n/*     */\nBUILD_SCAN_SYSIN:\nN = 0\nR = 0\nSCNCNT = 0\nSCAN.1 = STRIP(SCAN1)\nSCAN.2 = STRIP(SCAN2)\nSCAN.3 = STRIP(SCAN3)\nSCAN.4 = STRIP(SCAN4)\nSCAN.5 = STRIP(SCAN5)\nSCAN.6 = STRIP(SCAN6)\nSCAN.7 = STRIP(SCAN7)\nSCAN.8 = STRIP(SCAN8)\nSCAN.9 = STRIP(SCAN9)\nSCAN.10 = STRIP(SCAN10)\nDO 10\n   N = N + 1\n   IF SCAN.N = '' THEN ITERATE\n   R = R + 1\n   SCAND.R = SCAN.N\n   SCNCNT = SCNCNT + 1\nEND\nR = 0\nDO SCNCNT\n   I = 0\n   R = R + 1\n/* DLEN = LENGTH(SCAND.R)\n   IF DLEN > 58 THEN DO\n      ZONE = ''              N O O P\n      LPRT = ''\n   END                     */\n   DO 5\n      I = I + 1\n      W = WORD(DELIMITER,I)\n      D = POS(W,SCAND.R)\n      IF D \u00ac= 0 THEN ITERATE\n      DELIM = W\n      LEAVE\n   END\n   IF DELIM = '' THEN DELIM = '#'\n   RCD.R = \"-SCAN\" DELIM||SCAND.R||DELIM||ZONE||LPRT\n   IF SC = 01 & EC = 72 THEN DO\n      RCD.R = \"-SCAN\" DELIM||SCAND.R||DELIM||LPRT\n   END\nEND\nR = R + 1\nRCD.R = \"-END\"\nR = R + 1\nRCD.R = \"/*\"\nR = R + 1\nRCD.R = \"//\"\nRCDCNT = J + R\nRETURN\n\n/*     */\nWRITE_SCAN_JOB:\nADDRESS TSO\n\"ALLOC DA('\"CNTLLIB\"(\"MEMBER\")') FILE(CNTLDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('CNTLLIB'('MEMBER'). ***'\n   SAY '*** CCFSCAN EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nDO R = 1 TO RCDCNT\n   QUEUE RCD.R\nEND\n\"EXECIO\" RCDCNT \"DISKW CNTLDD (FINIS\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** WRITE ERROR: ('CNTLLIB'('MEMBER'). ***'\n   SAY '*** LIBSCAN EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT\nEND\nRETURN\n\n/*     */\nSUBMIT_SCAN_JOB:\nADDRESS TSO\n\"SUBMIT ('\"CNTLLIB\"(\"MEMBER\")')\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** SUBMIT ERROR: MEMBER ( 'CNTLLIB'('MEMBER'). ***'\n   SAY '*** CCFSCAN EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nSAY '+++ JOB' JOBNAME ' SUBMITTED. +++'\n\"DELETE '\"CNTLLIB\"(\"MEMBER\")' FILE(CNTLDD)\"\n\"FREE FILE(CNTLDD)\"\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CCMERG": {"ttr": 4097, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01 \\x00\\x00\\x00\\x923/\\x00\\x94\\x11\\x8f\\x10\\x18\\x00\\x91\\x00\\x05\\x00\\x91\\xe3\\xc5\\xc3\\xc8\\xf1\\xf1\\xf0@@@'", "ispf": {"version": "01.32", "flags": 0, "createdate": "1992-11-27T00:00:00", "modifydate": "1994-04-28T10:18:00", "lines": 145, "newlines": 5, "modlines": 145, "user": "TECH110"}, "text": "/* REXX PRODXREF CC MERGE EXEC */\nPARSE UPPER ARG XCCDSNAME;\n\"EXECIO * DISKR CCSCAN   (STEM CCSCAN. FINIS\";\nDO K = 1 TO CCSCAN.0;\n     PARSE VAR CCSCAN.K CCMEM CCACCESS CCFNDD;\n     DROP CCSCAN.K;\n     CCMEM=STRIP(CCMEM);\n     CCACCESS=STRIP(CCACCESS);\n     CCFNDD=STRIP(CCFNDD);\n     IF CCACCESS=\"D\" | CCACCESS=\"E\" | CCACCESS=\"M\" ,\n      THEN DO;\n         IF SYMBOL('CCDD.CCMEM')=\"VAR\" THEN ,\n             CCDD.CCMEM=CCDD.CCMEM CCACCESS CCFNDD; /* DDNAME */\n           ELSE ,\n             CCDD.CCMEM=CCACCESS CCFNDD; /* DDNAME */\n         END;\n     ELSE DO;\n         IF SYMBOL('CCDS.CCMEM')=\"VAR\" THEN ,\n             CCDS.CCMEM=CCDS.CCMEM CCACCESS CCFNDD; /* DATASET */\n           ELSE ,\n             CCDS.CCMEM=CCACCESS CCFNDD; /* DATASET */\n         END;\nEND;\nDROP CCSCAN.0;\n\"EXECIO * DISKR XREFFILE (STEM XREFFILE. FINIS\";\nDO I = 1 TO XREFFILE.0;\n  PARSE VAR XREFFILE.I JOBNAME 9 JOBCLASS 10 EPROCSN 18 PROCNAME ,\n      26 EPGMSN 34 EXECPGM 42 STEPPROC 45 STEPJOB ,\n      48 DDNAME 56 DSNAME 100 MEMBER 108 DISP 111 ACCESS;\n  IF  DSNAME=\" \" THEN ITERATE I;\n  JOBNAME=STRIP(JOBNAME);\n  PROCNAME=STRIP(PROCNAME);\n  EPROCSN=STRIP(EPROCSN);\n  EPGMSN=STRIP(EPGMSN);\n  DDNAME=STRIP(DDNAME);\n  DSNAME=STRIP(DSNAME);\n  MEMBER=STRIP(MEMBER);\n  DISP=STRIP(DISP);\n  ACCESS =STRIP(ACCESS);\n  IF MEMBER=\" \" | MEMBER=\"\" | ,\n     DSNAME\u00ac=XCCDSNAME | ,\n     DATATYPE(MEMBER,\"W\") THEN ITERATE I;\n  IF SYMBOL('CCDD.MEMBER')=\"VAR\" THEN DO;\n     CTR = WORDS(CCDD.MEMBER);\n     DO J = 1 TO CTR BY 2;\n       FAX=WORD(CCDD.MEMBER,J);\n       FDN=WORD(CCDD.MEMBER,J+1);\n       FFDD.JOBNAME.EPGMSN.PROCNAME.EPROCSN.FDN=FAX;\n     END;\n     END;\nEND;\nXOUT=1;\nDO I = 1 TO XREFFILE.0;\n  PARSE VAR XREFFILE.I JOBNAME 9 JOBCLASS 10 EPROCSN 18 PROCNAME ,\n      26 EPGMSN 34 EXECPGM 42 STEPPROC 45 STEPJOB ,\n      48 DDNAME 56 DSNAME 100 MEMBER 108 DISP 111 ACCESS;\n  JOBNAME=STRIP(JOBNAME);\n  PROCNAME=STRIP(PROCNAME);\n  EPROCSN=STRIP(EPROCSN);\n  EPGMSN=STRIP(EPGMSN);\n  DDNAME=STRIP(DDNAME);\n  DSNAME=STRIP(DSNAME);\n  MEMBER=STRIP(MEMBER);\n  DISP=STRIP(DISP);\n  ACCESS =STRIP(ACCESS);\n  IF DSNAME=XCCDSNAME THEN DO;\n       XREFOUT.XOUT = XREFFILE.I; /* DUP RECORD UNCHANGED */\n       XOUT = XOUT + 1;\n       IF SYMBOL('CCDS.MEMBER')=\"VAR\" THEN DO;\n          CTR = WORDS(CCDS.MEMBER);\n          DO J = 1 TO CTR BY 2;\n            FAX=WORD(CCDS.MEMBER,J);\n            SELECT;\n              WHEN (FAX=\"F\") THEN FAX=\"INPUT \";\n              WHEN (FAX=\"G\") THEN FAX=\"OUTPUT\";\n              WHEN (FAX=\"H\") THEN FAX=\"DELETE\";\n              WHEN (FAX=\"I\") THEN FAX=\"ALLOC \";\n              WHEN (FAX=\"J\") THEN FAX=\"ALLOC \";\n              WHEN (FAX=\"K\") THEN FAX=\"ALLOC \";\n              WHEN (FAX=\"L\") THEN FAX=\"ALLOC \";\n              WHEN (FAX=\"N\") THEN FAX=\"VERIFY\";\n              WHEN (FAX=\"O\") THEN FAX=\"EXPORT\";\n              WHEN (FAX=\"P\") THEN FAX=\"RESTOR\";\n              WHEN (FAX=\"Q\") THEN FAX=\"RESTOR\";\n              WHEN (FAX=\"R\") THEN FAX=\"RESTOR\";\n              WHEN (FAX=\"Y\") THEN FAX=\"YYYYYY\"; /* DYL280 PGM */\n              WHEN (FAX=\"Z\") THEN FAX=\"ZZZZZZ\"; /* DB2 IKJEF PGM */\n              OTHERWISE FAX=\"??????\";\n            END;\n  IF FAX\u00ac=\"ZZZZZZ\" & FAX\u00ac=\"YYYYYY\" THEN DO; /* NOT DB2/DYL CALL */\n             FDS=LEFT(WORD(CCDS.MEMBER,J+1),44);\n             TEMP=XREFFILE.I;\n             TEMP=OVERLAY(FDS,TEMP,56,44);\n             TEMP=OVERLAY(FAX,TEMP,111,6);\n             TEMP=OVERLAY(\"   \",TEMP,108,3); /* NO DISP ON GENNED DS*/\n             XREFOUT.XOUT = TEMP; /* DUP RECORD */\n             XOUT = XOUT + 1;\n            END;\n           ELSE IF FAX=\"YYYYYY\" THEN DO; /* DYL PGM CALL */\n             FDS=LEFT(WORD(CCDS.MEMBER,J+1),8);\n             TEMP=XREFFILE.I;\n             TEMP=OVERLAY(FDS,TEMP,34,8);\n             TEMP=OVERLAY(\"   \",TEMP,108,3); /* NO DISP ON GENNED DB*/\n       TEMP=OVERLAY(\"DYLPGM\",TEMP,111,6); /* IND DYL INTERNAL PGM*/\n             XREFOUT.XOUT = TEMP; /* DUP RECORD */\n             XOUT = XOUT + 1;\n            END;\n           ELSE DO; /* DB2 PGM CALL */\n             FDS=LEFT(WORD(CCDS.MEMBER,J+1),8);\n             TEMP=XREFFILE.I;\n             TEMP=OVERLAY(FDS,TEMP,34,8);\n             TEMP=OVERLAY(\"   \",TEMP,108,3); /* NO DISP ON GENNED DB*/\n       TEMP=OVERLAY(\"DB2PGM\",TEMP,111,6); /* IND DB2 INTERNAL PGM*/\n             XREFOUT.XOUT = TEMP; /* DUP RECORD */\n             XOUT = XOUT + 1;\n            END;\n          END;\n         END;\n       ITERATE I;\n       END;\n  IF ACCESS \u00ac= \" \" & ACCESS\u00ac=\"\" THEN DO;\n       XREFOUT.XOUT = XREFFILE.I; /* DUP RECORD UNCHANGED */\n       XOUT = XOUT + 1;\n       ITERATE I;\n       END;\nIF SYMBOL('FFDD.JOBNAME.EPGMSN.PROCNAME.EPROCSN.DDNAME')=\"VAR\" ,\n       THEN DO;\n          FAX=FFDD.JOBNAME.EPGMSN.PROCNAME.EPROCSN.DDNAME;\n            SELECT;\n              WHEN (FAX=\"D\") THEN FAX=\"INPUT \";\n              WHEN (FAX=\"E\") THEN FAX=\"OUTPUT\";\n              WHEN (FAX=\"M\") THEN FAX=\"VERIFY\";\n              OTHERWISE FAX=\"??????\";\n            END;\n            TEMP=XREFFILE.I;\n            TEMP=OVERLAY(FAX,TEMP,111,6);\n            XREFOUT.XOUT = TEMP; /* DUP RECORD */\n            XOUT = XOUT + 1;\n            ITERATE I;\n          END;\n    XREFOUT.XOUT = XREFFILE.I; /* DUP RECORD UNCHANGED */\n    XOUT = XOUT + 1;\nEND;\n\"EXECIO * DISKW XREFOUT (STEM XREFOUT. FINIS\";\nEXIT 0;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CCPROC": {"ttr": 4101, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x012\\x00\\x00\\x00\\x923\\x9f\\x00\\x95\\x04o\\x16C\\x01K\\x00\\x04\\x01J\\xe3\\xc5\\xc3\\xc8\\xf1\\xf1\\xf0@@@'", "ispf": {"version": "01.50", "flags": 0, "createdate": "1992-12-04T00:00:00", "modifydate": "1995-02-15T16:43:00", "lines": 331, "newlines": 4, "modlines": 330, "user": "TECH110"}, "text": "/* REXX PROD XREF CC SCANNER */\nOUTPTR=1;\n\"EXECIO * DISKR CCSCAN (STEM CC. FINIS\";\nTRUE=\"1\";\nFALSE=\"0\";\nFOUNDMEM=FALSE;\nMEMCTR=0;\nDO I = 1 TO CC.0;\n  IF SUBSTR(CC.I,1,7)=\"MEMBER=\" THEN DO;\n       MEMNAME=SUBSTR(CC.I,8,8);\n       FOUNDMEM=TRUE;\n       MEMCTR=MEMCTR+1;\n       MEMDATA.MEMCTR=MEMNAME;\n       DROP CC.I;\n       ITERATE I;\n       END;\n   ELSE IF \u00acFOUNDMEM THEN EXIT 24; /* ERROR */\n  MEMDATA.MEMCTR = ,\nMEMDATA.MEMCTR STRIP(TRANSLATE(SUBSTR(CC.I,1,71),\"     \",\"=()-,\"));\n  DROP CC.I;\nEND;\nDROP CC.0;\nMEMDATA.0=MEMCTR;\nDO I = 1 TO MEMDATA.0;\n    PARSE VAR MEMDATA.I MEMNAME MEMDATA.I;\n    MEMDATA.I=SPACE(MEMDATA.I);\n    SCANCOM = TRUE; /* REMOVE ALL COMMENTS */\n    DO WHILE(SCANCOM);\n          SCANCOM=FALSE;\n          POS1=POS(\"/*\",MEMDATA.I);\n          IF POS1\u00ac=0 THEN DO;\n              POS2=POS(\"*/\",MEMDATA.I,POS1+2);\n              IF POS2\u00ac=0 THEN DO;\n                  DLEN = POS2 - POS1 + 2; /* COMMENT LEN */\n                  MEMDATA.I = DELSTR(MEMDATA.I,POS1,DLEN);\n                  SCANCOM = TRUE; /* SCAN FOR MORE COMMENTS */\n                  END;\n             END;\n      END;\n    ZZ=SUBSTR(MEMDATA.I,1,1);\n    IF ZZ=\"/\" | ZZ>=\"0\" THEN ITERATE I;\n    IF WORD(MEMDATA.I,1)=\"SORT\" THEN ITERATE I;\n    IF WORDPOS(\"REPRO\",MEMDATA.I)\u00ac=0 THEN DO;\n       DO WHILE(WORDPOS(\"REPRO\",MEMDATA.I)\u00ac=0);\n         OP=WORDPOS(\"REPRO\",MEMDATA.I)+1;\n         XX=DELWORD(MEMDATA.I,OP-1,1);\n         KEYW1=WORD(MEMDATA.I,OP);\n         KEYW2=WORD(MEMDATA.I,OP+2);\n         ACODE=\"\";\n         IF KEYW1=\"IFILE\"|KEYW1=\"INFILE\" THEN DO;\n              ACODE=\"D\"; ANAME=WORD(MEMDATA.I,OP+1); END;\n         ELSE IF KEYW1=\"OFILE\"|KEYW1=\"OUTFILE\" THEN DO;\n              ACODE=\"E\"; ANAME=WORD(MEMDATA.I,OP+1); END;\n         ELSE IF KEYW1=\"IDS\"|KEYW1=\"INDATASET\" THEN DO;\n              ACODE=\"F\"; ANAME=WORD(MEMDATA.I,OP+1); END;\n         ELSE IF KEYW1=\"ODS\"|KEYW1=\"OUTDATASET\" THEN DO;\n              ACODE=\"G\"; ANAME=WORD(MEMDATA.I,OP+1); END;\n         ELSE NOP;\n  IF ACODE\u00ac=\"\" THEN DO;\n    OUT.OUTPTR=LEFT(MEMNAME,8) ACODE LEFT(ANAME,44);\n    OUTPTR=OUTPTR+1; END;\n  ACODE=\"\";\n         IF KEYW2=\"IFILE\"|KEYW2=\"INFILE\" THEN DO;\n              ACODE=\"D\"; ANAME=WORD(MEMDATA.I,OP+3); END;\n         ELSE IF KEYW2=\"OFILE\"|KEYW2=\"OUTFILE\" THEN DO;\n              ACODE=\"E\"; ANAME=WORD(MEMDATA.I,OP+3); END;\n         ELSE IF KEYW2=\"IDS\"|KEYW2=\"INDATASET\" THEN DO;\n              ACODE=\"F\"; ANAME=WORD(MEMDATA.I,OP+3); END;\n         ELSE IF KEYW2=\"ODS\"|KEYW2=\"OUTDATASET\" THEN DO;\n              ACODE=\"G\"; ANAME=WORD(MEMDATA.I,OP+3); END;\n         ELSE NOP;\n  IF ACODE\u00ac=\"\" THEN DO;\n    OUT.OUTPTR=LEFT(MEMNAME,8) ACODE LEFT(ANAME,44);\n    OUTPTR=OUTPTR+1; END;\n  ACODE=\"\";\n  MEMDATA.I=XX;\n         END;\n         END;\n    IF WORDPOS(\"PROG\",MEMDATA.I)\u00ac=0 THEN DO;\n       DO WHILE(WORDPOS(\"PROG\",MEMDATA.I)\u00ac=0);  /* DB2 */\n         OP=WORDPOS(\"PROG\",MEMDATA.I)+1;\n         XX=DELWORD(MEMDATA.I,OP-1,1);\n         KEYW1=WORD(MEMDATA.I,OP);\n         KEYW2=WORD(MEMDATA.I,OP+1);\n         ACODE=\"\";\n         IF KEYW2=\"PLAN\" THEN DO;\n              ACODE=\"Z\";\n              ANAME=TRANSLATE(KEYW1,\" \",\"'\");\n              KEYW3=WORD(MEMDATA.I,OP+2); /* GET PLAN NAME */\n              PLNAME=TRANSLATE(KEYW3,\" \",\"'\"); END;\n         ELSE NOP;\n  IF ACODE\u00ac=\"\" THEN DO;\n    OUT.OUTPTR=LEFT(MEMNAME,8) ACODE LEFT(ANAME,44);\n    OUTPTR=OUTPTR+1;\n     IF ANAME\u00ac=PLNAME THEN DO; /* ONLY IF PLAN NAME DIFF THAN PROG*/\n       OUT.OUTPTR=LEFT(MEMNAME,8) ACODE LEFT(PLNAME,44);\n       OUTPTR=OUTPTR+1;\n       END;\n    END;\n  ACODE=\"\";\n  MEMDATA.I=XX;\n         END;\n         END;\n    IF WORDPOS(\"OPTION\",MEMDATA.I)\u00ac=0 THEN DO;\n       DO WHILE(WORDPOS(\"OPTION\",MEMDATA.I)\u00ac=0);\n         OP=WORDPOS(\"OPTION\",MEMDATA.I)+1;\n         XX=DELWORD(MEMDATA.I,OP-1,1);\n         KEYW1=WORD(MEMDATA.I,OP); /* = DYL280 OPTION RESTORE PGM */\n         KEYW2=WORD(MEMDATA.I,OP+1); /* PGM NAME */\n         ACODE=\"\";\n         IF KEYW1=\"RESTORE\" THEN DO;\n              ACODE=\"Y\";\n              ANAME=TRANSLATE(KEYW2,\" \",\"'\"); END;\n         ELSE NOP;\n  IF ACODE\u00ac=\"\" THEN DO;\n    OUT.OUTPTR=LEFT(MEMNAME,8) ACODE LEFT(ANAME,44);\n    OUTPTR=OUTPTR+1;\n    END;\n  ACODE=\"\";\n  MEMDATA.I=XX;\n         END;\n         END;\n    IF WORDPOS(\"SELECT\",MEMDATA.I)\u00ac=0 THEN DO;\n       DO WHILE(WORDPOS(\"SELECT\",MEMDATA.I)\u00ac=0);\n         OP=WORDPOS(\"SELECT\",MEMDATA.I)+1;\n         XX=DELWORD(MEMDATA.I,OP-1,1);\n         KEYW1=WORD(MEMDATA.I,OP);\n         KEYW2=WORD(MEMDATA.I,OP+1);\n         ACODE=\"\";\n         IF KEYW1=\"DSN\" | KEYW1=\"DSG\" THEN DO;\n              ACODE=\"F\";\n              ANAME=KEYW2; END;\n         ELSE NOP;\n  IF ACODE\u00ac=\"\" THEN DO;\n    OUT.OUTPTR=LEFT(MEMNAME,8) ACODE LEFT(ANAME,44);\n    OUTPTR=OUTPTR+1; END;\n  ACODE=\"\";\n  MEMDATA.I=XX;\n         END;\n         END;\n    IF WORDPOS(\"DUMP\",MEMDATA.I)\u00ac=0 | ,\n       WORDPOS(\"DUM\",MEMDATA.I)\u00ac=0 | ,\n       WORDPOS(\"RESTORE\",MEMDATA.I)\u00ac=0 | ,\n       WORDPOS(\"RESTOR\",MEMDATA.I)\u00ac=0 | ,\n       WORDPOS(\"RESTO\",MEMDATA.I)\u00ac=0 | ,\n       WORDPOS(\"REST\",MEMDATA.I)\u00ac=0 THEN DO;\n       DO WHILE(WORDPOS(\"DUMP\",MEMDATA.I)\u00ac=0 | ,\n                WORDPOS(\"DUM\",MEMDATA.I)\u00ac=0 | ,\n                WORDPOS(\"RESTORE\",MEMDATA.I)\u00ac=0 | ,\n                WORDPOS(\"RESTOR\",MEMDATA.I)\u00ac=0 | ,\n                WORDPOS(\"RESTO\",MEMDATA.I)\u00ac=0 | ,\n                WORDPOS(\"REST\",MEMDATA.I)\u00ac=0);\n        DTYPE=\"DUMP\";\n        IF WORDPOS(\"DUMP\",MEMDATA.I)\u00ac=0 THEN ,\n           OP=WORDPOS(\"DUMP\",MEMDATA.I)+1;\n        ELSE IF WORDPOS(\"DUM\",MEMDATA.I)\u00ac=0 THEN ,\n           OP=WORDPOS(\"DUM\",MEMDATA.I)+1;\n        ELSE IF WORDPOS(\"RESTORE\",MEMDATA.I)\u00ac=0 THEN DO;\n           OP=WORDPOS(\"RESTORE\",MEMDATA.I)+1; DTYPE=\"REST\"; END;\n        ELSE IF WORDPOS(\"RESTOR\",MEMDATA.I)\u00ac=0 THEN DO;\n           OP=WORDPOS(\"RESTOR\",MEMDATA.I)+1; DTYPE=\"REST\"; END;\n        ELSE IF WORDPOS(\"RESTO\",MEMDATA.I)\u00ac=0 THEN DO;\n           OP=WORDPOS(\"RESTO\",MEMDATA.I)+1; DTYPE=\"REST\"; END;\n        ELSE DO;\n           OP=WORDPOS(\"REST\",MEMDATA.I)+1; DTYPE=\"REST\"; END;\n         XX=DELWORD(MEMDATA.I,OP-1,1);\n         IF WORDPOS(\"INC\",MEMDATA.I,OP)\u00ac=0 THEN ,\n             OP1=WORDPOS(\"INC\",MEMDATA.I,OP)+1;\n         ELSE IF WORDPOS(\"INCL\",MEMDATA.I,OP)\u00ac=0 THEN ,\n             OP1=WORDPOS(\"INCL\",MEMDATA.I,OP)+1;\n         ELSE IF WORDPOS(\"INCLU\",MEMDATA.I,OP)\u00ac=0 THEN ,\n             OP1=WORDPOS(\"INCLU\",MEMDATA.I,OP)+1;\n         ELSE IF WORDPOS(\"INCLUD\",MEMDATA.I,OP)\u00ac=0 THEN ,\n             OP1=WORDPOS(\"INCLUD\",MEMDATA.I,OP)+1;\n         ELSE IF WORDPOS(\"INCLUDE\",MEMDATA.I,OP)\u00ac=0 THEN ,\n             OP1=WORDPOS(\"INCLUDE\",MEMDATA.I,OP)+1;\n         ELSE OP1=\"\";\n         ACODE=\"\";\n         IF OP1\u00ac=\"\" THEN DO;\n         KEYW1 = \"DSNAME\";\n         DO WHILE (KEYW1\u00ac=\"\");\n         KEYW1=WORD(MEMDATA.I,OP1);\n         IF POS(\".\",KEYW1)\u00ac=0 THEN DO;\n           ANAME=KEYW1;\n           OP1=OP1+1;\n           IF DTYPE=\"DUMP\" THEN ,\n             ACODE=\"F\";\n            ELSE ACODE=\"G\";\n            OUT.OUTPTR=LEFT(MEMNAME,8) ACODE LEFT(ANAME,44);\n            OUTPTR=OUTPTR+1;\n          END;\n          ELSE KEYW1=\"\";\n         END; /* END OF DO WHILE */\n         END; /* END OF OP1 NE NULL */\n  ACODE=\"\";\n  MEMDATA.I=XX;\n         END;\n         END;\n    IF WORDPOS(\"DELETE\",MEMDATA.I)\u00ac=0 THEN DO;\n       DO WHILE(WORDPOS(\"DELETE\",MEMDATA.I)\u00ac=0);\n           ACODE=\"H\";\n           OP=WORDPOS(\"DELETE\",MEMDATA.I)+1;\n           XX=DELWORD(MEMDATA.I,OP-1,1);\n           ANAME=WORD(MEMDATA.I,OP);\n           OUT.OUTPTR=LEFT(MEMNAME,8) ACODE LEFT(ANAME,44);\n           OUTPTR=OUTPTR+1;\n           DO WHILE(POS(\".\",WORD(MEMDATA.I,OP+1))\u00ac=0);\n              ANAME=WORD(MEMDATA.I,OP+1);\n              OUT.OUTPTR=LEFT(MEMNAME,8) ACODE LEFT(ANAME,44);\n              OUTPTR=OUTPTR+1;\n              OP=OP+1;\n           END;\n           MEMDATA.I=XX;\n         END;\n         END;\n    IF WORDPOS(\"DEFINE\",MEMDATA.I)\u00ac=0 THEN DO;\n       DO WHILE(WORDPOS(\"DEFINE\",MEMDATA.I)\u00ac=0);\n         OP=WORDPOS(\"DEFINE\",MEMDATA.I)+1;\n         XX=DELWORD(MEMDATA.I,OP-1,1);\n         ACODE=\"\";\n         KEYW1=WORD(MEMDATA.I,OP);\n         KEYW2=WORD(MEMDATA.I,OP+1);\n         ANAME=WORD(MEMDATA.I,OP+2);\n  IF (KEYW1=\"ALTERNATEINDEX\" | KEYW1=\"AIX\") & KEYW2=\"NAME\" THEN ,\n            ACODE=\"J\";\n  ELSE IF (KEYW1=\"CLUSTER\" | KEYW1=\"CL\") & KEYW2=\"NAME\" THEN ,\n            ACODE=\"I\";\n  ELSE IF (KEYW1=\"NONVSAM\" | KEYW1=\"NVSAM\") & KEYW2=\"NAME\" THEN ,\n            ACODE=\"L\";\n  ELSE IF (KEYW1=\"PATH\") & KEYW2=\"NAME\" THEN ,\n            ACODE=\"K\";\n  IF ACODE\u00ac=\"\" THEN DO;\n    OUT.OUTPTR=LEFT(MEMNAME,8) ACODE LEFT(ANAME,44);\n    OUTPTR=OUTPTR+1; END;\n  MEMDATA.I=XX;\n         END;\n         END;\n    IF WORDPOS(\"VERIFY\",MEMDATA.I)\u00ac=0 THEN DO;\n       DO WHILE(WORDPOS(\"VERIFY\",MEMDATA.I)\u00ac=0);\n         OP=WORDPOS(\"VERIFY\",MEMDATA.I)+1;\n         XX=DELWORD(MEMDATA.I,OP-1,1);\n         KEYW1=WORD(MEMDATA.I,OP);\n         ANAME=WORD(MEMDATA.I,OP+1);\n         ACODE=\"\";\n         IF KEYW1=\"FILE\" THEN ACODE=\"M\";\n         ELSE IF KEYW1=\"DS\"|KEYW1=\"DATASET\" THEN ACODE=\"N\";\n         ELSE NOP;\n  IF ACODE\u00ac=\"\" THEN DO;\n    OUT.OUTPTR=LEFT(MEMNAME,8) ACODE LEFT(ANAME,44);\n    OUTPTR=OUTPTR+1; END;\n  MEMDATA.I=XX;\n         END;\n         END;\n    IF WORDPOS(\"EXPORT\",MEMDATA.I)\u00ac=0 THEN DO;\n     FXO = \"\";\n     FXC = WORDS(MEMDATA.I);\n     DO FX = 1 TO FXC;\n      FXW = WORD(MEMDATA.I,FX);\n      IF FXW=\"EXO\" | FXW=\"ESTOP\" | FXW=\"VSAMAID\" THEN ITERATE FX;\n      FXO = FXO FXW;\n     END;\n     MEMDATA.I = FXO;\n       DO WHILE(WORDPOS(\"EXPORT\",MEMDATA.I)\u00ac=0);\n         OP=WORDPOS(\"EXPORT\",MEMDATA.I)+1;\n         XX=DELWORD(MEMDATA.I,OP-1,1);\n         KEYW1=WORD(MEMDATA.I,OP);\n         IF KEYW1=\"EXO\" | KEYW1=\"ESTOP\" | KEYW1=\"VSAMAID\" | ,\n            KEYW1=\"RECLEVEL\" | KEYW1=\"MOUNT\" THEN DO;\n                OP=OP+1;\n                KEYW1=WORD(MEMDATA.I,OP);\n                END;\n         OP=OP+1;\n         IF KEYW1=\"CLUSTER\" THEN DO;\n         ACODE=\"DUMMY\";\n         DO WHILE(ACODE\u00ac=\"\");\n         KEYW2=WORD(MEMDATA.I,OP+0);\n         ANAME=WORD(MEMDATA.I,OP+1);\n         IF KEYW2=\"CL\" | KEYW2=\"CLUSTER\" THEN ACODE=\"O\";\n         ELSE ACODE=\"\";\n  IF ACODE\u00ac=\"\" THEN DO;\n    OUT.OUTPTR=LEFT(MEMNAME,8) ACODE LEFT(ANAME,44);\n    OUTPTR=OUTPTR+1; END;\n         OP=OP+2;\n         END;\n         END;\n  MEMDATA.I=XX;\n         END;\n         END;\n    IF WORDPOS(\"RESTORE\",MEMDATA.I)\u00ac=0 THEN DO;\n     FXO = \"\";\n     FXC = WORDS(MEMDATA.I);\n     DO FX = 1 TO FXC;\n      FXW = WORD(MEMDATA.I,FX);\n      IF FXW=\"REMP\" | FXW=\"RVER\" | FXW=\"PURGE\" | ,\n         FXW=\"VSAMAID\" | FXW=\"NODELETE\" | FXW=\"ESTOP\" | ,\n         FXW=\"NOXTC\" THEN ITERATE FX;\n      FXO = FXO FXW;\n     END;\n     MEMDATA.I = FXO;\n       DO WHILE(WORDPOS(\"RESTORE\",MEMDATA.I)\u00ac=0);\n         OP=WORDPOS(\"RESTORE\",MEMDATA.I)+1;\n         XX=DELWORD(MEMDATA.I,OP-1,1);\n         KEYW1=WORD(MEMDATA.I,OP);\n         IF KEYW1=\"REMP\" | KEYW1=\"RVER\" | KEYW1=\"PURGE\" | ,\n            KEYW1=\"VSAMAID\" | KEYW1=\"NODELETE\" | ,\n            KEYW1=\"ESTOP\" | KEYW1=\"NOXTC\" THEN DO;\n                OP=OP+1;\n                KEYW1=WORD(MEMDATA.I,OP);\n                END;\n         OP=OP+1;\n         IF KEYW1=\"CLUSTER\" THEN DO;\n         ACODE=\"DUMMY\";\n         DO WHILE(ACODE\u00ac=\"\");\n         KEYW2=WORD(MEMDATA.I,OP+0);\n         ANAME=WORD(MEMDATA.I,OP+1);\n         ACODE=\"\";\n         IF KEYW2=\"CL\" | KEYW2=\"CLUSTER\" THEN ACODE=\"P\";\n         IF KEYW2=\"AIX\" THEN ACODE=\"Q\";\n         IF KEYW2=\"PATH\" THEN ACODE=\"R\";\n  IF ACODE\u00ac=\"\" THEN DO;\n    OUT.OUTPTR=LEFT(MEMNAME,8) ACODE LEFT(ANAME,44);\n    OUTPTR=OUTPTR+1; END;\n         OP=OP+2;\n         END;\n         END;\n  MEMDATA.I=XX;\n         END;\n         END;\nEND;\n\"EXECIO * DISKW OUTPUT (STEM OUT. FINIS\";\nEXIT 0;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CDRSCICS": {"ttr": 4107, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01 \\x00\\x00\\x00\\x93\\x11\\x1f\\x00\\x95\\x03\\x9f\\tP\\x00\\xa4\\x00\\x15\\x00\\xa4\\xe3\\xc5\\xc3\\xc8\\xf1\\xf1\\xf0@@@'", "ispf": {"version": "01.32", "flags": 0, "createdate": "1993-04-21T00:00:00", "modifydate": "1995-02-08T09:50:00", "lines": 164, "newlines": 21, "modlines": 164, "user": "TECH110"}, "text": "/* REXX CDRS FCT MERGE EXEC */\nPARSE UPPER ARG ONLJOB;\nONLJOB = STRIP(ONLJOB);\nONLVOL = SUBSTR(ONLJOB,4);\n\"EXECIO * DISKR FCTIN (FINIS STEM FCTIN.\";\nDO K = 1 TO FCTIN.0;\n     TEMP = SUBSTR(FCTIN.K,1,72);\n     CONT=SUBSTR(TEMP,72,1);\n     IF WORDPOS(\"DFHFCT\",TEMP)\u00ac=0 THEN DO;\n          CURRFCT=TEMP;\n          DO WHILE (CONT\u00ac=\" \");\n              K=K+1; /* INDEX */\n              TEMP = SUBSTR(FCTIN.K,1,72);\n              CONT=SUBSTR(TEMP,72,1);\n              CURRFCT=CURRFCT TEMP;\n          END;\n     CURRFCT=TRANSLATE(CURRFCT,\"   \",\",()\");\n     PARSE VAR CURRFCT . \"DATASET=\" MEMBER . ;\n     PARSE VAR CURRFCT . \"DSNAME=\" DSN . ;\n     IF DSN=\" \" | DSN=\"\" | SUBSTR(MEMBER,1,3)=\"DFH\" THEN ITERATE K;\n     FCT.MEMBER=DSN;\nEND;\nEND;\nDROP FCTIN.;\n\"EXECIO * DISKR ZEKE (FINIS STEM ZEKE.\";\nFCTNLIST=\"\";\nDO K = 1 TO ZEKE.0;\n    PARSE VAR ZEKE.K \"SET\" \"SCOM\" . \"SET\" \"DA\" FCTN \"CLO\" . ;\n    IF FCTN=\" \" | FCTN=\"\" THEN ITERATE K;\n    FCTN = TRANSLATE(FCTN,\"   \",\"(),\");\n    FCTNLIST = FCTNLIST FCTN;\nEND;\nDROP ZEKE.;\nJCLX.0 = 52; /* COUNT OF INCR JOB STATEMENTS */\nJCLX.1 = \"//\"ONLJOB \"JOB 530401053000,'SYSTEM.BACKUP',\";\nJCLX.2 = \"// NOTIFY=TECH251,\";\nJCLX.3 = \"// CLASS=H,MSGCLASS=G\";\nJCLX.4 = \"//LOAD1 EXEC PGM=IKJEFT01,DYNAMNBR=32,PARM='%DB2TIACK'\";\nJCLX.5 = \"//SYSTSPRT DD SYSOUT=*\";\nJCLX.6 = \"//SYSPRINT DD SYSOUT=*\";\nJCLX.7 = \"//SYSTSIN DD DUMMY\";\nJCLX.8 = \"//SYSPROC DD DSN=SYSS.TECH.COMMON.EXECLIB,DISP=SHR\";\nJCLX.9 = \"//SYSIN DD *\";\nJCLX.10 = \" DELETE FROM BUILD.TABRVOLS WHERE VOLSER='\"ONLVOL\"' AND \";\nJCLX.11 = \" DUMP_STATUS='PENDING' AND DUMP_TYPE='INCRVOL';\";\nJCLX.12 = \" COMMIT;\";\nJCLX.13 = \" INSERT INTO BUILD.TABRVOLS (VOLSER,DUMP_TYPE,DUMP_STATUS)\";\nJCLX.14 = \"    VALUES('\"ONLVOL\"','INCRVOL','ACTIVE');\";\nJCLX.15 = \"/*\";\nJCLX.16= \"//DUMPIT EXEC PGM=FDRABR,REGION=0M\";\nJCLX.17= \"//SYSPRIN1 DD SYSOUT=*\";\nJCLX.18= \"//SYSPRIN2 DD SYSOUT=*\";\nJCLX.19= \"//SYSPRIN3 DD SYSOUT=*\";\nJCLX.20= \"//DUMMY1   DD DUMMY\";\nJCLX.21=\"//TAPE1 DD DSN=I1ONLV,DISP=(,KEEP),UNIT=TA80,VOL=(,,,255)\";\nJCLX.22 =\"//TAPE2 DD DSN=I2ONLV,DISP=(,KEEP),UNIT=TA80,VOL=(,,,255)\";\nJCLX.23=\"//TAPE3 DD DSN=I3ONLV,DISP=(,KEEP),UNIT=TA80,VOL=(,,,255)\";\nJCLX.24=\"//DUMMY2 DD DUMMY\";\nJCLX.25= \"//SYSPRINT DD SYSOUT=*\";\nJCLX.26 = \"//SYSUDUMP DD SYSOUT=X\";\nJCLX.27 = \"//SYSIN DD *\";\nJCLX.28 = \" DUMP TYPE=ABR,ONLVOL,\";\nJCLX.29 = \"  AUTOUPD=YES,\";\nJCLX.30 = \"  BUFNO=MAX,\";\nJCLX.31 = \"  COMPRESS=ALL,\";\nJCLX.32 = \"  DATA=USED,\";\nJCLX.33 = \"  DATEP=NONE,\";\nJCLX.34 = \"  DSNENQ=TEST,\";\nJCLX.35 = \"  ENQ=RESERVE,\";\nJCLX.36 = \"  ENQERR=NO,\";\nJCLX.37 = \"  ENQERR=PROCESS,\";\nJCLX.38 = \"  FORMAT=NEW,\";\nJCLX.39 = \"  LBPZERO=INVALID,\";\nJCLX.40 = \"  MAXDD=512,MAXERR=1,\";\nJCLX.41 = \"  PRINT=ABR,\";\nJCLX.42 = \"  RETPD=9999,\";\nJCLX.43 = \"  SMSCONSTRUCT=NO,\";\nJCLX.44 = \"  SMSMANAGE=NO\";\nJCLX.45 = \" S CATDSN=SYS1.UCATPRD1.CLUSTER\";\nJCLX.46 = \" S CATDSN=SYS1.UCATPRD2.CLUSTER\";\nJCLX.47 = \" S CATDSN=SYS1.UCATPRD3.CLUSTER\";\nJCLX.48 = \" S CATDSN=SYS1.UCATPROD.CLUSTER\";\nJCLX.49 = \" S CATDSN=SYS1.UCATTSOE.CLUSTER\";\nJCLX.50 = \" S CATDSN=SYSS.TLMS.V5R3M0.RMF.CLUSTER\";\nJCLX.51 = \" S CATDSN=SYSS.TLMS.V5R3M0.VMF\";\nJCLX.52 = \" S CATDSN=SYSS.TLMS.V5R3M0.VMFINDEX.CLUSTER\";\nJCLY.0 = 25; /* COUNT OF INCR JOB STATEMENTS */\nJCLY.1 = \"// IF (RC<=8 & \u00acABEND) THEN\";\nJCLY.2 = \"//LOAD2 EXEC PGM=IKJEFT01,DYNAMNBR=32,PARM='%DB2TIACK'\";\nJCLY.3 = \"//SYSTSPRT DD SYSOUT=*\";\nJCLY.4 = \"//SYSPRINT DD SYSOUT=*\";\nJCLY.5 = \"//SYSTSIN DD DUMMY\";\nJCLY.6 = \"//SYSPROC DD DSN=SYSS.TECH.COMMON.EXECLIB,DISP=SHR\";\nJCLY.7 = \"//SYSIN DD *\";\nJCLY.8 = \" UPDATE BUILD.TABRVOLS SET DUMP_STATUS='COMPLETE'\";\nJCLY.9 = \"    WHERE VOLSER='\"ONLVOL\"' AND DUMP_TYPE='INCRVOL';\";\nJCLY.10 = \" COMMIT;\";\nJCLY.11 = \"/*\";\nJCLY.12 = \"// ENDIF\";\nJCLY.13 = \"// IF (RC>8 | ABEND) THEN\";\nJCLY.14 = \"//LOAD3 EXEC PGM=IKJEFT01,DYNAMNBR=32,PARM='%DB2TIACK'\";\nJCLY.15 = \"//SYSTSPRT DD SYSOUT=*\";\nJCLY.16 = \"//SYSPRINT DD SYSOUT=*\";\nJCLY.17 = \"//SYSTSIN DD DUMMY\";\nJCLY.18 = \"//SYSPROC DD DSN=SYSS.TECH.COMMON.EXECLIB,DISP=SHR\";\nJCLY.19 = \"//SYSIN DD *\";\nJCLY.20 = \" UPDATE BUILD.TABRVOLS SET DUMP_STATUS='FAILURE'\";\nJCLY.21 = \"    WHERE VOLSER='\"ONLVOL\"' AND DUMP_TYPE='INCRVOL' AND \";\nJCLY.22 = \"    DUMP_STATUS='ACTIVE';\";\nJCLY.23 = \"/*\";\nJCLY.24 = \"// ENDIF\";\nJCLY.25 = \"//\";\nINCRCTR=1;\nDO I = 1 TO JCLX.0; /* START JCL */\n    INCR.INCRCTR = JCLX.I;\n    INCRCTR=INCRCTR+1;\nEND;\nK = WORDS(FCTNLIST);\nDSNLIST=\"\";\nDO I = 1 TO K;\n    FCTE=WORD(FCTNLIST,I);\n    IF SYMBOL(\"FCT.FCTE\")=\"VAR\" THEN DO;\n       DUMMY=OUTTRAP(\"LISTC.\");\n       \"LISTC ENT('\"FCT.FCTE\"') ALL\";\n       DUMMY=OUTTRAP(\"OFF\");\n       TYPE=WORD(LISTC.1,1);\n       SELECT;\n         WHEN (TYPE=\"CLUSTER\") THEN DO;\n             IF WORDPOS(FCT.FCTE,DSNLIST)=0 THEN DO;\n                 DSNLIST=DSNLIST FCT.FCTE;\n                 INCR.INCRCTR=\" S CATDSN=\"FCT.FCTE;\n                 INCRCTR=INCRCTR+1;\n             END;\n             END;\n         WHEN (TYPE=\"PATH\") THEN NOP;\n         WHEN (TYPE=\"AIX\") THEN DO;\n             DO X = 1 TO LISTC.0;\n                IF POS(\"CLUSTER--\",LISTC.X)\u00ac=0 THEN DO;\n                      PARSE VAR LISTC.X . \"CLUSTER--\" CLDSN . ;\n                      CLDSN=STRIP(CLDSN);\n             IF WORDPOS(CLDSN,DSNLIST)=0 THEN DO;\n                 DSNLIST=DSNLIST CLDSN;\n                 INCR.INCRCTR=\" S CATDSN=\"CLDSN;\n                 INCRCTR=INCRCTR+1;\n                      END;\n                    END;\n             END X;\n             END;\n         OTHERWISE DO;\n             IF WORDPOS(FCT.FCTE,DSNLIST)=0 THEN DO;\n                 DSNLIST=DSNLIST FCT.FCTE;\n                 INCR.INCRCTR=\" S CATDSN=\"FCT.FCTE;\n                 INCRCTR=INCRCTR+1;\n             END;\n             END;\n       END;\n   END;\nEND;\nDO I = 1 TO JCLY.0; /* START JCL */\n    INCR.INCRCTR = JCLY.I;\n    INCRCTR=INCRCTR+1;\nEND;\n\"EXECIO * DISKW INCROUT (FINIS STEM INCR.\";\nEXIT 0;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CICDMPPR": {"ttr": 4355, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x11\\x00\\x00\\x00\\x93\\x05o\\x00\\x93\\x06\\x0f\\x120\\x00f\\x00\\x1b\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf1\\xf0@@@'", "ispf": {"version": "01.17", "flags": 0, "createdate": "1993-02-25T00:00:00", "modifydate": "1993-03-01T12:30:00", "lines": 102, "newlines": 27, "modlines": 0, "user": "TECH110"}, "text": "/* REXX CICS transaction dump processor */\ntasklist = \"\"; /* List of tasks abended */\ncodelist = \"\"; /* List of codes encountered */\ncicslist = \"\"; /* LIst of CICS regions processed */\nfirstdate=\"\";\nlastdate=\"\";\noutctr = 0;\ntrue = \"1\";\nfalse = \u00actrue;\neof = false;\ndo while(\u00aceof); /* Process all records */\n     \"EXECIO 1 DISKR DUMPIN (STEM DUMPIN.\";\n     if rc\u00ac=0 then do;\n            eof = true;\n            iterate;\n            end;\n     piece = substr(dumpin.1,1,1);\n     if piece\u00ac=\"1\" & piece\u00ac=\"-\" then iterate;\n     parse var dumpin.1 p1 p2 p3 p4 p5 p6 p7 p8 p9 p10 p11 p12 p13;\n     if p3=\"CICS\" & p4=\"TRANSACTION\" & p5=\"DUMP\" & p11=\"PAGE\" & ,\n        p12=\"1\" then do;\n            cicsname = substr(p1,2);\n            codename = strip(substr(p7,6));\n            if codename=\"\" then codename=\"????\";\n            if codename=\" \" then codename=\"????\";\n            taskname = strip(substr(p8,6));\n            if taskname=\"\" then taskname=\"????\";\n            if taskname=\" \" then taskname=\"????\";\n            savecode = p7;\n            savetask = p8;\n            savedate = p9;\n            parse var savedate \"DATE=\" lastdate;\n            if firstdate=\"\" then ,\n                parse var savedate \"DATE=\" firstdate;\n            savetime = p10;\n            end;\n     else if p1=\"-SYMPTOMS=\" then do;\n            parse var dumpin.1 . \"RIDS/\" rids;\n            rids=left(\"RIDS=\"strip(rids),15);\n            outctr = outctr + 1;\n            output.outctr = ,\n                 savedate savetime  ,\n                 left(savetask,10) left(savecode,10) rids ,\n                 substr(dumpin.1,2);\n            if wordpos(cicsname,cicslist)=0 then ,\n                 cicslist=cicslist cicsname;\n            if wordpos(taskname,tasklist)=0 then ,\n                 tasklist=tasklist taskname;\n            if wordpos(codename,codelist)=0 then ,\n                 codelist=codelist codename;\n            if symbol('task.taskname')=\"VAR\" then ,\n                 task.taskname=task.taskname+1;\n             else task.taskname=1;\n            if symbol('code.codename')=\"VAR\" then ,\n                 code.codename=code.codename+1;\n             else code.codename=1;\n            end;\n     else iterate;\nend;\ncicsctr = words(cicslist);\nsay center(\"    Charming Shoppes, Inc.    \",130,\"*\");\nsay center(\" Technical Support Department \",130,\"*\");\nsay center(\"    CICS Daily ABEND Report   \",130,\"*\");\nsay center(\"    For \"firstdate\" - \"lastdate\"   \",130,\"*\");\nsay \"\";\nsay \"\";\nsay \"\";\nsay \"CICS Region(s) Processed\";\nsay \"--------------------------\";\ndo i = 1 to cicsctr;\n   xcics = word(cicslist,i);\n   say xcics;\nend i;\ntaskctr = words(tasklist);\nsay \"\";\nsay \"\";\nsay \"\";\nsay \"Task ABEND Summary with Counters\";\nsay \"--------------------------------\";\ndo i = 1 to taskctr;\n   xtask = word(tasklist,i);\n   say xtask right(task.xtask,5);\nend i;\ncodectr = words(codelist);\nsay \"\";\nsay \"\";\nsay \"\";\nsay \"Code ABEND Summary with Counters\";\nsay \"--------------------------------\";\ndo i = 1 to codectr;\n   xcode = word(codelist,i);\n   say xcode right(code.xcode,5);\nend i;\nsay \"\";\nsay \"\";\nsay \"\";\nsay \"Detailed ABEND Records\";\nsay \"----------------------\";\ndo i = 1 to outctr;\n   say output.i;\n   say \"\";\nend i;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CMCPE": {"ttr": 4358, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "PROC 0 MEM() HELP\nCONTROL ASIS\nWRITE * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nWRITE *             SAS/CPE for MVS\nWRITE * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nIF &HELP = HELP THEN DO\n  GOTO FIN\nEND\nIF &STR(&MEM) = &STR() THEN -\n  SET AEX = &STR(''SYSS.SAS.V6R8M0.CPE.CPMISC(CMAUTOEX)'')\nELSE -\n  SET AEX = &STR(''&SYSPREF..CPE.AUTOEXEC(&MEM)'')\nSAS608 -\n  OPTIONS('MEMSIZE=16M ') -\n  WORK('2000,500') -\n  AUTOEXEC('&AEX') -\n  SASAUTOS('''SYSS.SAS.V6R8M0.AUTOLIB'' -\n  ''SYSS.MXG.V12R03MA.SRCELIB''')\nFIN: EXIT\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "COBCOMPB": {"ttr": 4360, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x91\\x17\\x0f\\x00\\x910_\\x15\\x17\\x00b\\x00{\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf3@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1991-06-19T00:00:00", "modifydate": "1991-11-01T15:17:00", "lines": 98, "newlines": 123, "modlines": 0, "user": "TECH103"}, "text": "/*  CA-LIBRARIAN LIB/CCF/ELIPS ASSEMBLE/COMPILE REXX EXEC INTERFACE\n    TO ISPF PANEL DIALOG - ( BATCH PROGRAMS AND OS/VS COBOL COMPILER ).\n                                                                      */\n\nTRACE O\n/*     */\nHOUSE_KEEPING:\nADDRESS TSO\nSAVEMEMB = 'NULLMEMB'\nACCTCDE = 5200010520000000\nJCL.1 = 'CCFCOBOL'\nJCL.2 = 'CCFCOBCO'\nTSOID = SYSVAR(SYSUID)\nCP = 'APOST,LIB'\nCCFLOAD = 'SYS1.TEST.BATCH.LOADLIB'\nEMERGENCY_ID= SUBSTR(TSOID,1,4)\nIF EMERGENCY_ID= 'OPER' THEN CCFLOAD = 'SYS1.EMERGNCY.BATCH.LOADLIB'\nADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\nADDRESS ISPEXEC \"FTCLOSE\"\n\n/*     */\nDISPLAY_PANEL:\nDO FOREVER\n   ADDRESS ISPEXEC \"DISPLAY PANEL(COBCOMPB)\"\n   SRC = RC\n   IF SRC = 8 THEN LEAVE\n   IF SRC > 8 THEN DO\n      SAY '*** ERROR INVOKING ISPF DIALOG PANEL COBCOMPB - RC = 'SRC'.***'\n      EXIT SRC\n   END\n   CTYP = COMPTYP\n   IF MEMBER = SAVEMEMB THEN EXIT\n   CALL SELECT_COMPILE_JCL\n   CALL SUBMIT_COMPILE_JCL\nEND\nEXIT\n\n/*     */\nSELECT_COMPILE_JCL:\nSAVEMEMB = MEMBER\nSKELJCL = JCL.CTYP\nMASTER = LIBPRJ||'.'LIBGRP||'.'LIBTYP\nCOPYLB1 = LIBPRJ||'.TESTCOPY.MASTER'\nCOPYLB2 = LIBPRJ||'.PRODCOPY.MASTER'\nSUBNODE = SUBSTR(LIBGRP,1,4)\nIF SUBNODE = 'PROD' THEN COPYLB1 = LIBPRJ||'.PRODCOPY.MASTER'\nLOADLIB = CCFLOAD\nIF EMERGENCY_ID = 'OPER' THEN DO\n   MASTER = 'SYS1.EMRGSRCE.MASTER'\n   COPYLB1 = 'SYS1.EMRGCOPY.MASTER'\n   LOADLIB = 'SYS1.EMERGNCY.BATCH.LOADLIB'\nEND\nSELECT\n   WHEN SKELJCL = 'CCFCOBOL' THEN COMPMSG = TSOID||'.BATCH.COBOL'\n   WHEN SKELJCL = 'CCFCOBCO' THEN COMPMSG = TSOID||'.COBOL.NOLINK'\n  OTHERWISE COMPMSG = TSOID||'.COMPILE.LINK'\nEND\nRETURN\n\n/*     */\nSUBMIT_COMPILE_JCL:\nADDRESS ISPEXEC \"FTOPEN TEMP\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   ZERRMSG = $CCFA001\n   ADDRESS ISPEXEC \"SETMSG MSG($CCFA001)\"\n   RETURN\n   END\nADDRESS ISPEXEC \"FTINCL $CCFJOBC\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   ZERRMSG = $CCFA002\n   ADDRESS ISPEXEC \"SETMSG MSG($CCFA002)\"\n   RETURN\n   END\nADDRESS ISPEXEC \"FTINCL\" SKELJCL\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   ZERRMSG = $CCFA003\n   ADDRESS ISPEXEC \"SETMSG MSG($CCFA003)\"\n   RETURN\n   END\nADDRESS ISPEXEC \"FTCLOSE\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   ZERRMSG = $CCFA005\n   RETURN\n   END\nADDRESS ISPEXEC \"VGET ZTEMPF\"\nADDRESS TSO \"SUBMIT '\"ZTEMPF\"'\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   ZERRMSG = $CCFA006\n   RETURN\n   END\nZERRMSG = $CCFA000\nADDRESS ISPEXEC \"SETMSG MSG($CCFA000)\"\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "COBCOMPC": {"ttr": 4363, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x91\\x17\\x0f\\x00\\x910_\\x15\\x18\\x00f\\x00\\x81\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf3@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1991-06-19T00:00:00", "modifydate": "1991-11-01T15:18:00", "lines": 102, "newlines": 129, "modlines": 0, "user": "TECH103"}, "text": "/*  CA-LIBRARIAN LIB/CCF/ELIPS ASSEMBLE/COMPILE REXX EXEC INTERFACE\n    TO ISPF PANEL DIALOG - ( CICS PROGRAMS AND OS/VS COBOL COMPILER ).\n                                                                      */\n\nTRACE O\n/*     */\nHOUSE_KEEPING:\nADDRESS TSO\nACCTCDE = 5200010520000000\nTSOID = SYSVAR(SYSUID)\nSAVEMEMB = 'NULLMEMB'\nJCL.1 = 'CCFCICS'\nJCL.2 = 'CCFICICS'\nJCL.3 = 'CCFCICCO'\nJCL.4 = 'CCFTCICS'\nCCFLOAD = 'SYS1.TEST.CICS.LOADLIB'\nEMERGENCY_ID= SUBSTR(TSOID,1,4)\nIF EMERGENCY_ID = 'OPER' THEN CCFLOAD = 'SYS1.EMERGNCY.CICS.LOADLIB'\nADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\nADDRESS ISPEXEC \"FTCLOSE\"\n\n/*     */\nDISPLAY_PANEL:\nDO FOREVER\n   ADDRESS ISPEXEC \"DISPLAY PANEL(COBCOMPC)\"\n   SRC = RC\n   IF SRC = 8 THEN LEAVE\n   IF SRC > 8 THEN DO\n      SAY '*** ERROR INVOKING ISPF DIALOG PANEL COBCOMPC - RC = 'SRC'.***'\n      EXIT SRC\n   END\n   CTYP = COMPTYP\n   IF MEMBER = SAVEMEMB THEN EXIT\n   CALL SELECT_COMPILE_JCL\n   CALL SUBMIT_COMPILE_JCL\nEND\nEXIT\n\n/*     */\nSELECT_COMPILE_JCL:\nSAVEMEMB = MEMBER\nSKELJCL = JCL.CTYP\nMASTER = LIBPRJ||'.'LIBGRP||'.'LIBTYP\nCOPYLB1 = LIBPRJ||'.TESTCOPY.MASTER'\nCOPYLB2 = LIBPRJ||'.PRODCOPY.MASTER'\nSUBNODE = SUBSTR(LIBGRP,1,4)\nIF SUBNODE = 'PROD' THEN COPYLB1 = LIBPRJ||'.PRODCOPY.MASTER'\nCPYMAST = LIBPRJ||'.TESTCOPY.MASTER'\nLOADLIB = CCFLOAD\nIF EMERGENCY_ID = 'OPER' THEN DO\n   MASTER = 'SYS1.EMRGSRCE.MASTER'\n   COPYLB1 = 'SYS1.EMRGCOPY.MASTER'\n   LOADLIB = 'SYS1.EMERGNCY.CICS.LOADLIB'\nEND\nSELECT\n   WHEN SKELJCL = 'CCFCICS' THEN COMPMSG = TSOID||'.CICS.COBOL'\n   WHEN SKELJCL = 'CCFICICS' THEN COMPMSG = TSOID||'.CICSCOB.INT'\n   WHEN SKELJCL = 'CCFCICCO' THEN COMPMSG = TSOID||'.CICS.COMPILE'\n   WHEN SKELJCL = 'CCFTCICS' THEN COMPMSG = TSOID||'.CICSCOB.TRN'\n  OTHERWISE COMPMSG = TSOID||'.COMPILE.LINK'\nEND\nRETURN\n\n/*     */\nSUBMIT_COMPILE_JCL:\nADDRESS ISPEXEC \"FTOPEN TEMP\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   ZERRMSG = $CCFA001\n   ADDRESS ISPEXEC \"SETMSG MSG($CCFA001)\"\n   RETURN\n   END\nADDRESS ISPEXEC \"FTINCL $CCFJOBC\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   ZERRMSG = $CCFA002\n   ADDRESS ISPEXEC \"SETMSG MSG($CCFA002)\"\n   RETURN\n   END\nADDRESS ISPEXEC \"FTINCL\" SKELJCL\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   ZERRMSG = $CCFA003\n   ADDRESS ISPEXEC \"SETMSG MSG($CCFA003)\"\n   RETURN\n   END\nADDRESS ISPEXEC \"FTCLOSE\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   ZERRMSG = $CCFA005\n   RETURN\n   END\nADDRESS ISPEXEC \"VGET ZTEMPF\"\nADDRESS TSO \"SUBMIT '\"ZTEMPF\"'\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   ZERRMSG = $CCFA006\n   RETURN\n   END\nZERRMSG = $CCFA000\nADDRESS ISPEXEC \"SETMSG MSG($CCFA000)\"\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CONTROLB": {"ttr": 4366, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x10_\\x00\\x94\\x10_\\x04\\x10\\x00I\\x00I\\x00\\x00\\xc9\\xd6\\xc1\\xf4\\xf1\\xf0@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-04-15T00:00:00", "modifydate": "1994-04-15T04:10:00", "lines": 73, "newlines": 73, "modlines": 0, "user": "IOA410"}, "text": "PROC 0 RULE(%) MISSION(%) GROUP(%) D(A) MODE(L) TEST(NO) -\n       PROG(CTBCXJB) -\n       ILPREFA(SYSM.IOA) -\n       ILVERA(V410) -\n       ILPREFB(SYSM.CTBI) -\n       ILVERB(V120) -\n       OLPREFB(SYSS.CTBO) -\n       OLVERB(V120) -\n       DBPREFA(SYSS.IOA) -\n       DBVERA(V410) -\n       DBPREFB(SYSS.CTBO) -\n       DBVERB(V120) -\n       HOLDCLASS(G) -\n       RULLIB(RULES) -\n       TSTLIB(PARM) -\n       DBGLIB(PARM) -\n       PROFMEM(CTBPROF)\nCONTROL LIST CONLIST SYMLIST\nIF &MISSION=% THEN SET &MISSION=\nIF &GROUP=% THEN SET &GROUP=\nIF &RULE=% THEN SET &RULE=\nIF &MODE=L THEN DO\n  /*** PASS  ***/\n  ALLOC F(DAPASCTB) DS(&ILPREFA..&ILVERA..PARM(PASCTB)) SHR REUSE\n  /*** IOADB ***/\n  ALLOC F(DARESF)   DS(&DBPREFA..&DBVERA..RES) SHR REUSE\n  ALLOC F(DASINC)   DS(&DBPREFA..&DBVERA..SNC) SHR REUSE\n  ALLOC F(DANRES)   DS(&DBPREFA..&DBVERA..NRS) SHR REUSE\n  ALLOC F(DANSINC)  DS(&DBPREFA..&DBVERA..NSN) SHR REUSE\n  ALLOC F(DALOG)    DS(&DBPREFA..&DBVERA..LOG) SHR REUSE\n  /*** CTBDB ***/\n  ALLOC F(DABJAFI)  DS(&DBPREFB..&DBVERB..JAFI) SHR REUSE\n  ALLOC F(DABJAFD)  DS(&DBPREFB..&DBVERB..JAFD) SHR REUSE\n  ALLOC F(DABREPI)  DS(&DBPREFB..&DBVERB..REPI) SHR REUSE\n  ALLOC F(DABREPD)  DS(&DBPREFB..&DBVERB..REPD) SHR REUSE\n  ALLOC F(DABGRPI)  DS(&DBPREFB..&DBVERB..GRPI) SHR REUSE\n  ALLOC F(DABGRPD)  DS(&DBPREFB..&DBVERB..GRPD) SHR REUSE\n  ALLOC F(DABVDBMI) DS(&DBPREFB..&DBVERB..MODI) SHR REUSE\n  ALLOC F(DABVDBMD) DS(&DBPREFB..&DBVERB..MODD) SHR REUSE\n  ALLOC F(DABVDBAI) DS(&DBPREFB..&DBVERB..VARI) SHR REUSE\n  ALLOC F(DABVDBAD) DS(&DBPREFB..&DBVERB..VARD) SHR REUSE\n  ALLOC F(DABABF)   DS(&DBPREFB..&DBVERB..ABF) SHR REUSE\n  /*** RULES ***/\n  ALLOC F(DABRULE) DS(&OLPREFB..&OLVERB..&RULLIB) SHR REUSE\n  /*** DEBUG ***/\n  ALLOC F(A)       DS(&ILPREFB..&ILVERB..&TSTLIB(&PROFMEM)) SHR REUSE\n  ALLOC F(LOCS)    DS(&ILPREFB..&ILVERB..&DBGLIB(CTBSORC)) SHR REUSE\n  ALLOC F(LVLS)    DS(&ILPREFB..&ILVERB..&DBGLIB(CTBCLVL)) SHR REUSE\n  ALLOC F(SYSIN)   DS(&ILPREFB..&ILVERB..&DBGLIB(CTBQE)) SHR REUSE\n  ALLOC F(DBGIN)   DS(&ILPREFB..&ILVERB..&DBGLIB(CTBDBG)) SHR REUSE\n  ALLOC F(DBGOUT)  DA (*) SHR REUSE\n  ALLOC F(PRTDBG)  SYSOUT(&HOLDCLASS) HOLD REUSE\n  ALLOC F(SYSUSER) SYSOUT(&HOLDCLASS) HOLD REUSE\n  ALLOC F(SYSRULE) SYSOUT(&HOLDCLASS) HOLD REUSE\nEND\nIF &D=H -\nTHEN DO\n       ALLOC F(SYSPRINT) SYSOUT(&HOLDCLASS) HOLD REUSE\n       ALLOC F(SYSTERM) SYSOUT(&HOLDCLASS) HOLD REUSE\n     END\nELSE DO\n       ALLOC F(SYSPRINT) DA (*) SHR REUSE\n       ALLOC F(SYSTERM) DA (*) SHR REUSE\n     END\n/*\n/*  CALL\n/*\nIF &TEST=NO -\nTHEN -\n   CALL '&ILPREFA..&ILVERA..LOAD(&PROG)' '/&RULE,/&MISSION,/&GROUP'\nELSE -\n   TEST '&ILPREFA..&ILVERA..LOAD(&PROG)' '/&RULE,/&MISSION,/&GROUP'\nEXIT CODE(&LASTCC)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "COPYXRFZ": {"ttr": 4369, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01#\\x00\\x00\\x00\\x91$\\x1f\\x00\\x913\\x9f\\x13\\x11\\x00[\\x00\\x15\\x00[\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf6@@@'", "ispf": {"version": "01.35", "flags": 0, "createdate": "1991-08-29T00:00:00", "modifydate": "1991-12-05T13:11:00", "lines": 91, "newlines": 21, "modlines": 91, "user": "TECH106"}, "text": "/* REXX EXEC TO LIST COPYBOOK TO SOURCE MEMBER XREF VIA PANELS */\nADDRESS TSO\nBLANK = \" \"\nDO FOREVER\n  ADDRESS ISPEXEC \"DISPLAY PANEL(XREFPANL)\"\n  SRC = RC\n  IF SRC = 0 THEN LEAVE\n  IF SRC = 8 THEN LEAVE\n  IF SRC > 8 THEN DO\n    SAY '*** ERROR INVOKING ISPF DIALOG XREFPANL - RC  'SRC'.***'\n    SAY '*** COPYXREF EXEC CANCELLED - RETURN CODE:  ('SRC'). ***'\n    EXIT SRC\n  END\nEND\n\"ALLOC DA('SYS1.TECH.LIBRSCAN.OUT.SORTED') F(INDD) SHR\"\nSCR = RC\nIF SRC /= 0 THEN DO\n   SAY '*** ERROR ALLOCATING INPUT DATASET - RC  'SRC'. ***'\n   EXIT SRC\n   END\n\"EXECIO * DISKR INDD (FINIS STEM DATA.\"\nCOUNT = 0\nJ = 1\nDO I = 1 TO DATA.0\n   FULLINE = DATA.I\n   SOURCE_MEMBER = WORD(FULLINE,1)\n   COPYBK = WORD(FULLINE,2)\n   IF COPYBK > COPYBOOK THEN LEAVE\n   IF COPYBK = COPYBOOK THEN DO\n      COUNT = COUNT + 1\n      MEMBER.J = SOURCE_MEMBER\n      J = J + 1\n      END\n END I\n J = J - 1\n IF COUNT = 0 THEN DO\n    SAY 'NO HITS'\n    \"EXECIO 0 DISKR INDD (FINIS\"\n    \"FREE F(INDD)\"\n    EXIT 99\n END\n\n /*    INITIALIZE SLOTS FOR DISPLAY  */\n DO L = 1 TO 112\n INTERPRET MEM||L '=' BLANK\n END L\n /*   COPY MEMBER.X VALUES TO MEMX VARIABLES  - NEEDED FOR PANELS */\n DO K = 1 TO J\n INTERPRET MEM||K '=' LEFT(MEMBER.K,8)\n END K\n\nDO FOREVER\n  ADDRESS ISPEXEC \"DISPLAY PANEL(XREFPNL1)\"\n  SRC = RC\n  IF SRC = 0 THEN LEAVE\n  IF SRC = 8 THEN LEAVE\n  IF SRC > 8 THEN DO\n     SAY '*** ERROR INVOKING ISPF DIALOG XREFPNL1 - RC  'SRC'.***'\n     SAY '*** COPYXREF EXEC CANCELLED - RETURN CODE:  ('SRC'). ***'\n     EXIT SRC\n   END\nEND\nMULTIPLE_OF_ONE12 = 0\nLOOPTOP:\nMULTIPLE_OF_ONE12 = MULTIPLE_OF_ONE12 + 112\nIF J < 113 THEN SIGNAL ENDPROC\nJ = J - 112\nDO L = 1 TO 112\nINTERPRET MEM||L '=' BLANK\nEND L\nDO K = 1 TO J\nM = K + MULTIPLE_OF_ONE12\nINTERPRET MEM||K '=' LEFT(MEMBER.M,8)\nEND K\nDO FOREVER\n  ADDRESS ISPEXEC \"DISPLAY PANEL(XREFPNL1)\"\n  SRC = RC\n  IF SRC = 0 THEN LEAVE\n  IF SRC = 8 THEN LEAVE\n  IF SRC > 8 THEN DO\n     SAY '*** ERROR INVOKING ISPF DIALOG XREFPNL1 - RC  'SRC'.***'\n     SAY '*** COPYXREF EXEC CANCELLED - RETURN CODE:  ('SRC'). ***'\n     EXIT SRC\n   END\nEND\nSIGNAL LOOPTOP\n\nENDPROC:\n \"EXECIO 0 DISKR INDD (FINIS\"\n \"FREE F(INDD)\"\n EXIT 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CPLANAPF": {"ttr": 4609, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01!\\x00\\x00\\x00\\x935_\\x00\\x94\\x04_\\x13X\\x00\\x82\\x00G\\x00\\x7f\\xe3\\xc5\\xc3\\xc8\\xf1\\xf1\\xf0@@@'", "ispf": {"version": "01.33", "flags": 0, "createdate": "1993-12-21T00:00:00", "modifydate": "1994-02-14T13:58:00", "lines": 130, "newlines": 71, "modlines": 127, "user": "TECH110"}, "text": "/* REXX Capacity Planning APAF Analysis feed into DB2               */\n/* categories for domains */\noutptr=1;\ndomains=\"SYSP SYST SYSM SA SB SM SYSU SYSV\";\ngroups = ,\n   \"MVSprod MVStest MVSmaint MVSprod MVSprod MVSmaint UNXprod UNXmaint\";\nglist=\"MVSprod MVSprod1 MVSprod2 MVStest MVSmaint UNXprod UNXmaint\";\ndatelist=\"\";\noutptr=1;\n\"EXECIO * DISKR APAFIN (STEM APAF. FINIS\";\nlastset=\"\"; /* used in indiv domain processing */\ndo i = 1 to apaf.0;\n    parse var apaf.i ansicc 2 apafdata;\n    if word(apafdata,4)=\"_SYSTEM_\" then do;\n        z=words(lastset); /* prev min data */\n        if lastset\u00ac=\"\" then do;\n        do y = 1 to z;\n          uname=word(lastset,y);\n          if symbol('data.uname.tempdate')=\"LIT\" then do;\n             data.uname.tempdate=util.uname;\n             end;\n           else data.uname.tempdate=data.uname.tempdate util.uname;\n        end; /* end y */\n        end; /* end if*/\n        lastset=\"\"; /* used in indiv domain processing */\n        parse var apafdata current_date time . . . . . . . sysutil . ;\n        parse var current_date mm \"/\" dd \"/\" yy;\n        parse var time hh \":\" .;\n        if hh>=7 & hh<=18 then shift=1;\n           else shift=2;\n        parse value weekday(mm\"/\"dd\"/19\"yy) with day julian;\n        tempdate=mm||dd||yy;\n        if sysutil=\"\" | sysutil=\" \" | substr(sysutil,1,1)=\"*\" then ,\n             iterate i;\n        if symbol('data.SYSTEM.tempdate')=\"LIT\" then do;\n             datelist=datelist tempdate;\n             data.SYSTEM.tempdate=sysutil;\n             end;\n         else data.SYSTEM.tempdate=data.SYSTEM.tempdate sysutil;\n        systemshift=\"SYSTEM\"||shift;\n        if symbol('data.systemshift.tempdate')=\"LIT\" then do;\n             data.systemshift.tempdate=sysutil;\n             end;\n     else data.systemshift.tempdate=data.systemshift.tempdate sysutil;\n        end; /* end system line */\n    if word(apafdata,4)=\"L\" then do;\n        parse var apafdata sysname . . . . . . . . . . sysutil . ;\n        if sysutil=\"\" | sysutil=\" \" | substr(sysutil,1,1)=\"*\" then ,\n             iterate i;\n        index=wordpos(sysname,domains);\n        if index=0 then iterate i;\n        sysname=word(groups,index);\n        gptr=wordpos(sysname,lastset);\n        if gptr=0 then do; /* first entry for that min */\n            lastset=lastset sysname;\n            util.sysname=sysutil;\n            if sysname=\"MVSprod\" then do;\n              sysnamesh=\"MVSprod\"||shift;\n              lastset=lastset sysnamesh;\n              util.sysnamesh=sysutil;\n              end;\n            end;\n          else do;\n            util.sysname=util.sysname+sysutil;\n            if sysname=\"MVSprod\" then do;\n              sysnamesh=\"MVSprod\"||shift;\n              util.sysnamesh=util.sysnamesh+sysutil;\n              end;\n           end;\n        end;\nend;\ncall calc \"SYSTEM\";\ncall calc \"SYSTEM1\";\ncall calc \"SYSTEM2\";\nz = words(glist);\ndo y = 1 to z;\n   callsysname = word(glist,y);\n   call calc callsysname;\nend;\n\"EXECIO * DISKW APAFOUT (STEM REPORT. FINIS\";\nexit 0;\ncalc: /* full expose */\nparse arg sysvar;\nk=words(datelist); /* count of different days */\ndo i = 1 to k;\n     tempdate=word(datelist,i);\n     l = words(data.sysvar.tempdate);\n     if l=1 then iterate i; /* catches no data avail */\n     sum=0;\n     do j = 1 to l;\n          sum=sum+word(data.sysvar.tempdate,j);\n     end;\n     mean=sum/l;\n     sumdiff=0;\n     max=0;\n     do j = 0 to 9;\n        freq.sysvar.j=0;\n     end;\n     do j = 1 to l;\n          point=word(data.sysvar.tempdate,j);\n          if point>max then max=point;\n          select;\n            when(point<10) then freq.sysvar.0=freq.sysvar.0+1;\n            when(point<20) then freq.sysvar.1=freq.sysvar.1+1;\n            when(point<30) then freq.sysvar.2=freq.sysvar.2+1;\n            when(point<40) then freq.sysvar.3=freq.sysvar.3+1;\n            when(point<50) then freq.sysvar.4=freq.sysvar.4+1;\n            when(point<60) then freq.sysvar.5=freq.sysvar.5+1;\n            when(point<70) then freq.sysvar.6=freq.sysvar.6+1;\n            when(point<80) then freq.sysvar.7=freq.sysvar.7+1;\n            when(point<90) then freq.sysvar.8=freq.sysvar.8+1;\n            otherwise           freq.sysvar.9=freq.sysvar.9+1;\n          end;\n          diff=point-mean;    /* variance calc */\n          sumdiff=sumdiff+(diff**2);\n     end;\n     var=right(trunc(sumdiff/l,2),6,\"0\");\n     parse var tempdate mm 3 dd 5 yy;\n     date=mm\"/\"dd\"/\"yy;\n     max=right(max\".00\",6,\"0\");\n     mean=right(trunc(mean,2),6,\"0\");\n     parse value weekday(mm\"/\"dd\"/19\"yy) with day julian;\noutput=date||day||left(sysvar,8)||mean||var||max;\n     do j = 0 to 9;\n      output=output||right(trunc((freq.sysvar.j/l)*100,2),6,\"0\");\n     end;\nREPORT.outptr=output;\noutptr=outptr+1;\nend;\nreturn;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CPLANTMN": {"ttr": 4612, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x10\\x00\\x00\\x00\\x935\\x0f\\x00\\x94\\x06o\\x16V\\x00H\\x00\\x11\\x00;\\xe3\\xc5\\xc3\\xc8\\xf1\\xf1\\xf0@@@'", "ispf": {"version": "01.16", "flags": 0, "createdate": "1993-12-16T00:00:00", "modifydate": "1994-03-07T16:56:00", "lines": 72, "newlines": 17, "modlines": 59, "user": "TECH110"}, "text": "/* REXX Capacity Planning TMON Analysis feed into DB2               */\nlowers=\"abcdefghijklmnopqrstuvwxyz\";\nuppers=\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\noutptr=1;\n\"execio * diskr TMONIN (finis stem tmon.\";\ndo i = 1 to tmon.0;\n    parse var tmon.i ansicc 2 tmondata;\n    if word(tmondata,1)=\"TIME:\" then do;\n        tmondata=strip(subword(tmondata,3));\n        do while(pos(\"  \",tmondata)\u00ac=0);\n           tmondata=overlay(\"*\",tmondata,pos(\"  \",tmondata));\n        end;\n        tmondata=space(translate(space(tmondata,0),\" \",\"*\"));\n        if wordpos(\"RPT\",tmondata)\u00ac=0 then ,\n            tmondata=delword(tmondata,wordpos(\"RPT\",tmondata),1);\n        if wordpos(\"TOTAL\",tmondata)\u00ac=0 then ,\n            tmondata=delword(tmondata,wordpos(\"TOTAL\",tmondata),1);\n        if wordpos(\"TRANS\",tmondata)\u00ac=0 then ,\n            tmondata=delword(tmondata,wordpos(\"TRANS\",tmondata),1);\n        if wordpos(\"TRANSACTION\",tmondata)\u00ac=0 then ,\n          tmondata=delword(tmondata,wordpos(\"TRANSACTION\",tmondata),1);\n        tmondata=translate(tmondata,lowers,uppers);\n        k = words(tmondata);\n        temp=\"\";\n        do j = 1 to k;\n           tword1=translate(substr(word(tmondata,j),1,1),uppers,lowers);\n           tword2=substr(word(tmondata,j),2);\n           temp=temp tword1||tword2;\n        end;\n        if word(temp,1)=\"Daily\" then temp=\"*All\";\n/*      if word(temp,1)=\"Terminal\" then temp=\"*Terminal\";   */\n        if word(temp,1)=\"Pcics1\" then temp=\"*Terminal\";\n        current_area = left(strip(temp),40);\n        i = i +1;\n        current_date = word(tmon.i,4);\n        end;\n    if word(tmondata,1)=\"TOTALS\" then do;\n        current_data=space(subword(tmondata,2));\n        current_data=remove(\",\",current_data);\n        k = words(current_data);\n        temp=\"\";\n        do j = 1 to k;\n            piece=word(current_data,j);\n            if pos(\".\",piece)=0 then ,\n               piece=piece\".0000\";\n            if pos(\":\",piece)\u00ac=0 then do;\n               hh=0;\n               if length(piece)>10 then ,\n                  parse var piece hh \":\" mm \":\" ss \".\" frac;\n               else if length(piece)>7 then ,\n                  parse var piece mm \":\" ss \".\" frac;\n               piece=trunc((3600*hh)+(60*mm)+ss)||\".\"frac;\n               end;\n            temp=temp right(piece,14,\"0\");\n        end;\n        current_data=space(temp,0);\n        parse var current_date mm \"/\" dd \"/\" yy;\n        parse value weekday(mm\"/\"dd\"/19\"yy) with day julian;\n        output.outptr=current_date||day||current_area||current_data;\n        outptr=outptr+1;\n        end;\nend;\n\"EXECIO * DISKW TMONOUT (FINIS STEM OUTPUT.\";\nexit 0;\n/* Remove Function */\nRemove: procedure;\nneedle   = arg(1);\nhaystack = arg(2);\ndo while (pos(needle,haystack)\u00ac=0);\n    haystack=delstr(haystack,pos(needle,haystack),1);\nend;\nreturn haystack;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CPMERG": {"ttr": 4615, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x93\\x08_\\x00\\x936/\\x115\\x00\\x11\\x00 \\x00\\x10\\xe3\\xc5\\xc3\\xc8\\xf1\\xf1\\xf0@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1993-03-26T00:00:00", "modifydate": "1993-12-28T11:35:00", "lines": 17, "newlines": 32, "modlines": 16, "user": "TECH110"}, "text": "/* REXX PRODXREF COPY MERGE EXEC */\n\"EXECIO * DISKR COPYIN (STEM COPYIN. FINIS\";\nDO K = 1 TO COPYIN.0;\n     TEMP = STRIP(COPYIN.K);\n     PARSE VAR TEMP SRCEMEM COPYMEM . ;\n     DSN=LEFT(\"*COPYBOOK*\",44);\n     COPYOUT.1=COPIES(\" \",116);\n     COPYOUT.1 = ,\n         OVERLAY(DSN,COPYOUT.1,56,44);\n     COPYOUT.1 = ,\n         OVERLAY(SRCEMEM,COPYOUT.1,34,8);\n     COPYOUT.1 = ,\n         OVERLAY(COPYMEM,COPYOUT.1,100,8);\n     \"EXECIO 1 DISKW COPYOUT (STEM COPYOUT.\";\nEND;\n\"EXECIO 0 DISKW COPYOUT (FINIS\";\nEXIT 0;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CSDSCAN": {"ttr": 4617, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x08\\x00\\x00\\x00\\x93\\t/\\x00\\x93\\t/\\x141\\x00[\\x00C\\x003\\xe3\\xc5\\xc3\\xc8\\xf1\\xf1\\xf0@@@'", "ispf": {"version": "01.08", "flags": 0, "createdate": "1993-04-02T00:00:00", "modifydate": "1993-04-02T14:31:00", "lines": 91, "newlines": 67, "modlines": 51, "user": "TECH110"}, "text": "/* REXX PRODXREF CSD MERGE EXEC */\nTRUE=\"1\";\nFALSE=\"0\";\nEOF=FALSE;\nTRANSLIST=\"\";\nPROGLIST=\"\";\nDO WHILE(\u00acEOF);\n     \"EXECIO 1 DISKR CSDIN (STEM CSDIN.\";\n     IF RC\u00ac=0 THEN DO;\n         EOF=TRUE;\n         ITERATE;\n         END;\n     TEMP = STRIP(SUBSTR(CSDIN.1,2));\n     IF POS(\"TRANSACTION(\",TEMP)\u00ac=0 THEN DO;\n         PARSE VAR TEMP \"TRANSACTION(\" TRANSID \")\" . ,\n            \"GROUP(\" GROUP \")\" . \"PROGRAM(\" PROGRAM \")\" . ;\n         TMP1=SUBSTR(GROUP,1,3);\n         TMP2=SUBSTR(PROGRAM,1,3);\n         IF TMP1=\"DFH\" | TMP2=\"DFH\" | ,\n            TMP1=\"MVS\" | TMP2=\"IGZ\" | TMP2=\"JSI\" | ,\n            TMP2=\"NXI\" | TMP2=\"DBS\" | TMP2=\"DFS\" | ,\n            TMP2=\"M4V\" | TMP2=\"PCS\" | TMP2=\"PLA\" | ,\n            TMP2=\"SYS\" | TMP2=\"ZEK\" | PROGRAM=\"X\" | ,\n            SUBSTR(GROUP,1,4)=\"TMON\" | ,\n            SUBSTR(GROUP,1,5)=\"INTER\" THEN ITERATE;\n         TRANSID=STRIP(TRANSID);\n         PROGRAM=STRIP(PROGRAM);\n         IF SYMBOL('TRANSL.TRANSID')=\"LIT\" THEN DO;\n               TRANSL.TRANSID=PROGRAM;\n               IF SYMBOL('TRANSP.PROGRAM')=\"LIT\" THEN ,\n                     TRANSP.PROGRAM=TRANSID;\n                  ELSE TRANSP.PROGRAM=TRANSP.PROGRAM TRANSID;\n               TRANSLIST = TRANSLIST TRANSID;\n               IF SYMBOL('PROGL.PROGRAM')=\"LIT\" THEN DO;\n                     PROGL.PROGRAM=PROGRAM;\n                     PROGLIST=PROGLIST PROGRAM;\n                     END;\n            END;\n         ITERATE;\n       END;\n     IF POS(\"LANGUAGE(\",TEMP)\u00ac=0 THEN DO;\n         PARSE VAR TEMP \"PROGRAM(\" PROGRAM \")\" . ,\n            \"GROUP(\" GROUP \")\" . ;\n         TMP1=SUBSTR(GROUP,1,3);\n         TMP2=SUBSTR(PROGRAM,1,3);\n         IF TMP1=\"DFH\" | TMP2=\"DFH\" | ,\n            TMP1=\"MVS\" | TMP2=\"IGZ\" | TMP2=\"JSI\" | ,\n            TMP2=\"NXI\" | TMP2=\"DBS\" | TMP2=\"DFS\" | ,\n            TMP2=\"M4V\" | TMP2=\"PCS\" | TMP2=\"PLA\" | ,\n            TMP2=\"SYS\" | TMP2=\"ZEK\" | PROGRAM=\"X\" | ,\n            SUBSTR(GROUP,1,4)=\"TMON\" | ,\n            SUBSTR(GROUP,1,5)=\"INTER\" THEN ITERATE;\n         PROGRAM=STRIP(PROGRAM);\n         IF SYMBOL('PROGL.PROGRAM')=\"LIT\" THEN DO;\n                     PROGL.PROGRAM=PROGRAM;\n                     PROGLIST=PROGLIST PROGRAM;\n                     END;\n         ITERATE;\n       END;\nEND;\nC=WORDS(PROGLIST);\nBLANK=COPIES(\" \",116);\nDO I = 1 TO C;\n    PROGRAM=WORD(PROGLIST,I);\n    XPROG=LEFT(PROGRAM,8);\n    IF SYMBOL('TRANSP.PROGRAM')=\"VAR\" THEN DO;\n        W=WORDS(TRANSP.PROGRAM);\n        DO L = 1 TO W;\n           XID=LEFT(WORD(TRANSP.PROGRAM,L),8);\n           CSDOUT.1=BLANK;\n           CSDOUT.1 = ,\n               OVERLAY(XID,CSDOUT.1,100,8);\n           CSDOUT.1 = ,\n               OVERLAY(XPROG,CSDOUT.1,34,8);\n           CSDOUT.1 = ,\n               OVERLAY(\"CICSPROD\",CSDOUT.1,1,8);\n           \"EXECIO 1 DISKW CSDOUT (STEM CSDOUT.\";\n        END;\n      END;\n    ELSE DO;\n           CSDOUT.1=BLANK;\n           CSDOUT.1 = ,\n               OVERLAY(XPROG,CSDOUT.1,34,8);\n           CSDOUT.1 = ,\n               OVERLAY(\"CICSPROD\",CSDOUT.1,1,8);\n           \"EXECIO 1 DISKW CSDOUT (STEM CSDOUT.\";\n           END;\nEND;\n\"EXECIO 0 DISKW CSDOUT (FINIS\";\n\"EXECIO 0 DISKR CSDIN (FINIS\";\nEXIT 0;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CTBISPFB": {"ttr": 4620, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x10_\\x00\\x94\\x10_\\x04\\x10\\x00\\t\\x00\\t\\x00\\x00\\xc9\\xd6\\xc1\\xf4\\xf1\\xf0@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-04-15T00:00:00", "modifydate": "1994-04-15T04:10:00", "lines": 9, "newlines": 9, "modlines": 0, "user": "IOA410"}, "text": "PROC 0  APPLTYPE(I)  -\n        APPLID(CB)\n/****************************************************************\n/*                                                              *\n/*  CONTROL-B:   QUALITY ASSURANCE SYSTEM        (ISPF)         *\n/*                                                              *\n/****************************************************************\n%IOAONL APPLTYPE(&APPLTYPE) APPLID(&APPLID)\nEND:END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CTBISPFC": {"ttr": 4622, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x10_\\x00\\x94\\x10_\\x04\\x10\\x00\\n\\x00\\n\\x00\\x00\\xc9\\xd6\\xc1\\xf4\\xf1\\xf0@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-04-15T00:00:00", "modifydate": "1994-04-15T04:10:00", "lines": 10, "newlines": 10, "modlines": 0, "user": "IOA410"}, "text": "PROC 0  APPLTYPE(I)  -\n        APPLID(CC)\n/****************************************************************\n/*                                                              *\n/*  CONTROL-M:   PRODUCTION CONTROL  SYSTEM      (ISPF)         *\n/*  CONTROL-B:   QUALITY ASSURANCE SYSTEM        (ISPF)         *\n/*                                                              *\n/****************************************************************\n%IOAONL APPLTYPE(&APPLTYPE) APPLID(&APPLID)\nEND:END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CTBISPFE": {"ttr": 4624, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x10_\\x00\\x94\\x10_\\x04\\x10\\x00\\n\\x00\\n\\x00\\x00\\xc9\\xd6\\xc1\\xf4\\xf1\\xf0@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-04-15T00:00:00", "modifydate": "1994-04-15T04:10:00", "lines": 10, "newlines": 10, "modlines": 0, "user": "IOA410"}, "text": "PROC 0  APPLTYPE(I)  -\n        APPLID(CE)\n/****************************************************************\n/*                                                              *\n/*  CONTROL-B:   QUALITY ASSURANCE SYSTEM        (ISPF)         *\n/*  CONTROL-D:   REPORT DISTRIBUTION SYSTEM      (ISPF)         *\n/*                                                              *\n/****************************************************************\n%IOAONL APPLTYPE(&APPLTYPE) APPLID(&APPLID)\nEND:END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CTBISPFI": {"ttr": 4626, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x10_\\x00\\x94\\x10_\\x04\\x10\\x00\\x0b\\x00\\x0b\\x00\\x00\\xc9\\xd6\\xc1\\xf4\\xf1\\xf0@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-04-15T00:00:00", "modifydate": "1994-04-15T04:10:00", "lines": 11, "newlines": 11, "modlines": 0, "user": "IOA410"}, "text": "PROC 0  APPLTYPE(I)  -\n        APPLID(CI)\n/****************************************************************\n/*                                                              *\n/*  CONTROL-M:   PRODUCTION CONTROL  SYSTEM          (ISPF)     *\n/*  CONTROL-O:   AUTOMATED CONSOLE MANAGEMENT SYSTEM (ISPF)     *\n/*  CONTROL-B:   QUALITY ASSURANCE SYSTEM            (ISPF)     *\n/*                                                              *\n/****************************************************************\n%IOAONL APPLTYPE(&APPLTYPE) APPLID(&APPLID)\nEND:END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CTBISPFJ": {"ttr": 4628, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x10_\\x00\\x94\\x10_\\x04\\x10\\x00\\x0b\\x00\\x0b\\x00\\x00\\xc9\\xd6\\xc1\\xf4\\xf1\\xf0@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-04-15T00:00:00", "modifydate": "1994-04-15T04:10:00", "lines": 11, "newlines": 11, "modlines": 0, "user": "IOA410"}, "text": "PROC 0  APPLTYPE(I)  -\n        APPLID(CJ)\n/****************************************************************\n/*                                                              *\n/*  CONTROL-M:   PRODUCTION CONTROL  SYSTEM      (ISPF)         *\n/*  CONTROL-D:   REPORT DISTRIBUTION SYSTEM      (ISPF)         *\n/*  CONTROL-B:   QUALITY ASSURANCE   SYSTEM      (ISPF)         *\n/*                                                              *\n/****************************************************************\n%IOAONL APPLTYPE(&APPLTYPE) APPLID(&APPLID)\nEND:END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CTBISPFV": {"ttr": 4630, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x10_\\x00\\x94\\x10_\\x04\\x10\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc9\\xd6\\xc1\\xf4\\xf1\\xf0@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-04-15T00:00:00", "modifydate": "1994-04-15T04:10:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "IOA410"}, "text": "PROC 0  APPLTYPE(I)  -\n        APPLID(CV)\n/****************************************************************\n/*                                                              *\n/*  CONTROL-M:   PRODUCTION CONTROL  SYSTEM          (ISPF)     *\n/*  CONTROL-D:   REPORT DISTRIBUTION SYSTEM          (ISPF)     *\n/*  CONTROL-O:   AUTOMATED CONSOLE MANAGEMENT SYSTEM (ISPF)     *\n/*  CONTROL-B:   QUALITY ASSURANCE   SYSTEM          (ISPF)     *\n/*                                                              *\n/****************************************************************\n%IOAONL APPLTYPE(&APPLTYPE) APPLID(&APPLID)\nEND:END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CTBXTSOB": {"ttr": 4632, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x10_\\x00\\x94\\x10_\\x04\\x10\\x00\\r\\x00\\r\\x00\\x00\\xc9\\xd6\\xc1\\xf4\\xf1\\xf0@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-04-15T00:00:00", "modifydate": "1994-04-15T04:10:00", "lines": 13, "newlines": 13, "modlines": 0, "user": "IOA410"}, "text": "PROC 0 LOADLIB(SYS1.IOA.V410.LOAD)\n\n/*******************************************************************/\n/*                                                                 */\n/* THIS CLIST CALLS THE ONLINE FACILITY UNDER TSO/ROSCOE UNDER THE */\n/* CROSS MEMORY INTERFACE.                                         */\n/*                                                                 */\n/*******************************************************************/\n\n\nCALL  '&LOADLIB(CTMCTSO)' 'BMAN'\n\nEXIT CODE(&MAXCC)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CTBXTSOC": {"ttr": 4634, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x10_\\x00\\x94\\x10_\\x04\\x10\\x00\\r\\x00\\r\\x00\\x00\\xc9\\xd6\\xc1\\xf4\\xf1\\xf0@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-04-15T00:00:00", "modifydate": "1994-04-15T04:10:00", "lines": 13, "newlines": 13, "modlines": 0, "user": "IOA410"}, "text": "PROC 0 LOADLIB(SYS1.IOA.V410.LOAD)\n\n/*******************************************************************/\n/*                                                                 */\n/* THIS CLIST CALLS THE ONLINE FACILITY UNDER TSO/ROSCOE UNDER THE */\n/* CROSS MEMORY INTERFACE.                                         */\n/*                                                                 */\n/*******************************************************************/\n\n\nCALL  '&LOADLIB(CTMCTSO)' 'BMNC'\n\nEXIT CODE(&MAXCC)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CTBXTSOE": {"ttr": 4636, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x10_\\x00\\x94\\x10_\\x04\\x10\\x00\\r\\x00\\r\\x00\\x00\\xc9\\xd6\\xc1\\xf4\\xf1\\xf0@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-04-15T00:00:00", "modifydate": "1994-04-15T04:10:00", "lines": 13, "newlines": 13, "modlines": 0, "user": "IOA410"}, "text": "PROC 0 LOADLIB(SYS1.IOA.V410.LOAD)\n\n/*******************************************************************/\n/*                                                                 */\n/* THIS CLIST CALLS THE ONLINE FACILITY UNDER TSO/ROSCOE UNDER THE */\n/* CROSS MEMORY INTERFACE.                                         */\n/*                                                                 */\n/*******************************************************************/\n\n\nCALL  '&LOADLIB(CTMCTSO)' 'BMNE'\n\nEXIT CODE(&MAXCC)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CTBXTSOI": {"ttr": 4638, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x10_\\x00\\x94\\x10_\\x04\\x10\\x00\\r\\x00\\r\\x00\\x00\\xc9\\xd6\\xc1\\xf4\\xf1\\xf0@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-04-15T00:00:00", "modifydate": "1994-04-15T04:10:00", "lines": 13, "newlines": 13, "modlines": 0, "user": "IOA410"}, "text": "PROC 0 LOADLIB(SYS1.IOA.V410.LOAD)\n\n/*******************************************************************/\n/*                                                                 */\n/* THIS CLIST CALLS THE ONLINE FACILITY UNDER TSO/ROSCOE UNDER THE */\n/* CROSS MEMORY INTERFACE.                                         */\n/*                                                                 */\n/*******************************************************************/\n\n\nCALL  '&LOADLIB(CTMCTSO)' 'BMNI'\n\nEXIT CODE(&MAXCC)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CTBXTSOJ": {"ttr": 4640, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x10_\\x00\\x94\\x10_\\x04\\x10\\x00\\r\\x00\\r\\x00\\x00\\xc9\\xd6\\xc1\\xf4\\xf1\\xf0@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-04-15T00:00:00", "modifydate": "1994-04-15T04:10:00", "lines": 13, "newlines": 13, "modlines": 0, "user": "IOA410"}, "text": "PROC 0 LOADLIB(SYS1.IOA.V410.LOAD)\n\n/*******************************************************************/\n/*                                                                 */\n/* THIS CLIST CALLS THE ONLINE FACILITY UNDER TSO/ROSCOE UNDER THE */\n/* CROSS MEMORY INTERFACE.                                         */\n/*                                                                 */\n/*******************************************************************/\n\n\nCALL  '&LOADLIB(CTMCTSO)' 'BMNJ'\n\nEXIT CODE(&MAXCC)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CTBXTSOV": {"ttr": 4865, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x10_\\x00\\x94\\x10_\\x04\\x10\\x00\\r\\x00\\r\\x00\\x00\\xc9\\xd6\\xc1\\xf4\\xf1\\xf0@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-04-15T00:00:00", "modifydate": "1994-04-15T04:10:00", "lines": 13, "newlines": 13, "modlines": 0, "user": "IOA410"}, "text": "PROC 0 LOADLIB(SYS1.IOA.V410.LOAD)\n\n/*******************************************************************/\n/*                                                                 */\n/* THIS CLIST CALLS THE ONLINE FACILITY UNDER TSO/ROSCOE UNDER THE */\n/* CROSS MEMORY INTERFACE.                                         */\n/*                                                                 */\n/*******************************************************************/\n\n\nCALL  '&LOADLIB(CTMCTSO)' 'BMNV'\n\nEXIT CODE(&MAXCC)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CTDBKPRQ": {"ttr": 4867, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x10_\\x00\\x94\\x10_\\x04\\x10\\x00J\\x00F\\x00\\x00\\xc9\\xd6\\xc1\\xf4\\xf1\\xf0@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-04-15T00:00:00", "modifydate": "1994-04-15T04:10:00", "lines": 74, "newlines": 70, "modlines": 0, "user": "IOA410"}, "text": "PROC 0 DEBUG DATEFMT(USA) +\n         STEPLIB(SYS1.IOA.V410.LOAD) +\n         LANG() +\n         OLPREFA(SYSS.IOA) +\n         OLPREFD(SYSS.CTDO) +\n         OLVERA(V410) +\n         OLVERD(V310) +\n         PGMID(CTDBRQ)\nISPEXEC CONTROL ERRORS RETURN\nCONTROL MAIN NOLIST NOCONLIST NOSYMLIST NOMSG\nIF &DEBUG=DEBUG THEN CONTROL MAIN LIST CONLIST SYMLIST MSG\nISPEXEC VGET (ZDAY,ZMONTH,ZYEAR)\nSET YY=&ZYEAR\nSET MM=&ZMONTH\nSET DD=&ZDAY\nSET &NOALC=&STR()\nSET MM=&SUBSTR(2:3,&EVAL(&MM+100))\nSET DD=&SUBSTR(2:3,&EVAL(&DD+100))\nSET CTDSLIB=&STR(&OLPREFD..&OLVERD..BKPMIS)\nSET CTDCAL=&STR(&OLPREFA..&OLVERA..CAL)\nSET CTDSMIS=&STR()\nSET CTDSCAT=&STR()\nSET FOR=NO\nREDISP:+\nIF &DATEFMT=JPN THEN +\n      ISPEXEC DISPLAY PANEL(CTDPBKQJ)\n      ELSE  +\n  IF &DATEFMT=USA THEN +\n        ISPEXEC DISPLAY PANEL(CTDPBKQA)\n        ELSE  ISPEXEC DISPLAY PANEL(CTDPBKQW)\nIF &RESP = END THEN EXIT\nSET FORCE=&FOR\nSET ZYEAR=&YY\nSET ZMONTH=&MM\nSET ZDAY=&DD\nSET ZDAY=&SUBSTR(2:3,&EVAL(&ZDAY+100))\nSET ZMONTH=&SUBSTR(2:3,&EVAL(&ZMONTH+100))\nIF &DATEFMT=JPN THEN +\n  %CTDUPAMF CTDSLIB('&CTDSLIB') +\n     CTDCAL('&CTDCAL') +\n     CTDSMIS(&CTDSMIS)+\n     CTDSCAT(&CTDSCAT) +\n     STEPLIB('&STEPLIB') +\n     LANG(&LANG) +\n     PGMID(&PGMID) +\n     FORCE(&FORCE) +\n     &DEBUG DATE(&YY&MM&DD) &NOALC\n   ELSE    +\n  IF &DATEFMT=USA THEN +\n    %CTDUPAMF CTDSLIB('&CTDSLIB') +\n       CTDCAL('&CTDCAL') +\n       CTDSMIS(&CTDSMIS)+\n       CTDSCAT(&CTDSCAT) +\n       STEPLIB('&STEPLIB') +\n       LANG(&LANG) +\n       PGMID(&PGMID) +\n       FORCE(&FORCE) +\n       &DEBUG DATE(&MM&DD&YY) &NOALC\n     ELSE    +\n    %CTDUPAMF CTDSLIB('&CTDSLIB') +\n       CTDCAL('&CTDCAL') +\n       CTDSMIS(&CTDSMIS)+\n       CTDSCAT(&CTDSCAT) +\n       STEPLIB('&STEPLIB') +\n       LANG(&LANG) +\n       PGMID(&PGMID) +\n       FORCE(&FORCE) +\n       &DEBUG DATE(&DD&MM&YY) &NOALC\nSET &NOALC=NOALC\nSET DD=&SUBSTR(2:3,&EVAL(&ZDAY+100))\nSET MM=&SUBSTR(2:3,&EVAL(&ZMONTH+100))\nSET YY=&SUBSTR(2:3,&EVAL(&ZYEAR+100))\nGOTO REDISP\nEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CTDCCND": {"ttr": 4870, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x10_\\x00\\x94\\x10_\\x04\\x10\\x00\\x1c\\x00\\x1c\\x00\\x00\\xc9\\xd6\\xc1\\xf4\\xf1\\xf0@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-04-15T00:00:00", "modifydate": "1994-04-15T04:10:00", "lines": 28, "newlines": 28, "modlines": 0, "user": "IOA410"}, "text": "PROC 0 DEBUG  DATEFMT(USA) +\n         DBPREFA(SYSS.IOA) +\n         DBVERA(V410) +\n         STEPLIB(SYS1.IOA.V410.LOAD) +\n         LANG() +\n         NOALC\nCONTROL MAIN NOLIST NOCONLIST NOSYMLIST NOMSG\nIF &DEBUG=DEBUG THEN CONTROL MAIN LIST CONLIST SYMLIST MSG\nREDISP:+\nIF &DATEFMT=JPN  +\n   THEN  ISPEXEC DISPLAY PANEL(CTDPCNDJ)\n   ELSE  +\n  IF &DATEFMT=USA  +\n     THEN  ISPEXEC DISPLAY PANEL(CTDPCNDA)\n     ELSE  ISPEXEC DISPLAY PANEL(CTDPCNDW)\nIF &RESP = END THEN EXIT\nALLOC DD(DALOG)    DA('&DBPREFA..&DBVERA..LOG') SH\nALLOC DD(DASINC)   DA('&DBPREFA..&DBVERA..SNC') SH\nALLOC DD(DARESF)   DA('&DBPREFA..&DBVERA..RES') SH\nALLOC DD(DAPRINT)  DS(*)\nIF &DATEFMT=JPN  +\n THEN CALL  '&STEPLIB&LANG(CTDCND)' '&CTMFUN COND &CTMCONDN &MM.&DD'\n  ELSE +\n  IF &DATEFMT=USA  +\n THEN CALL  '&STEPLIB&LANG(CTDCND)' '&CTMFUN COND &CTMCONDN &MM.&DD'\n ELSE CALL  '&STEPLIB&LANG(CTDCND)' '&CTMFUN COND &CTMCONDN &DD.&MD'\nGOTO  REDISP\nEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CTDCREPS": {"ttr": 4872, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x10_\\x00\\x94\\x10_\\x04\\x10\\x00K\\x00G\\x00\\x00\\xc9\\xd6\\xc1\\xf4\\xf1\\xf0@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-04-15T00:00:00", "modifydate": "1994-04-15T04:10:00", "lines": 75, "newlines": 71, "modlines": 0, "user": "IOA410"}, "text": "PROC 0 DEBUG DATEFMT(USA) +\n         STEPLIB(SYS1.IOA.V410.LOAD) +\n         LANG() +\n         REPLIB(SYSS.CTDO.V310.REPORTS) +\n         CTDCAL(SYSS.IOA.V410.CAL) +\n         REP() +\n         CAT(*) +\n         FORCE(NO) +\n         ODAT() +\n         PGMID(CTDRRQ)\nCONTROL MAIN NOLIST NOCONLIST NOSYMLIST NOMSG\nIF &DEBUG=DEBUG THEN CONTROL MAIN LIST CONLIST SYMLIST MSG\nIF .&ODAT = . THEN DO\nSET YY=&SUBSTR(7:8,&SYSDATE)\nSET MM=&SUBSTR(1:2,&SYSDATE)\nSET DD=&SUBSTR(4:5,&SYSDATE)\nGOTO ODATOK\n                   END\nIF &DATEFMT=JPN +\n    THEN DO\n            SET &YY=&SUBSTR(1:2,&ODAT)\n            SET &DD=&SUBSTR(5:6,&ODAT)\n            SET &MM=&SUBSTR(3:4,&ODAT)\n         END\n    ELSE  +\n        IF &DATEFMT=USA +\n            THEN DO\n                    SET &YY=&SUBSTR(5:6,&ODAT)\n                    SET &DD=&SUBSTR(3:4,&ODAT)\n                    SET &MM=&SUBSTR(1:2,&ODAT)\n                 END\n            ELSE DO\n                    SET &YY=&SUBSTR(5:6,&ODAT)\n                    SET &DD=&SUBSTR(1:2,&ODAT)\n                    SET &MM=&SUBSTR(3:4,&ODAT)\n                 END\nODATOK:+\nSET &NOALC=&STR()\nSET CTDSLIB=&REPLIB\nSET CTDSMIS=&REP\nSET CTDSCAT=&STR(&CAT)\nSET FORCE=&FORCE\nIF &DATEFMT=JPN THEN +\n  %CTDUPAMF CTDSLIB('&CTDSLIB') +\n     CTDCAL('&CTDCAL') +\n     CTDSMIS(&CTDSMIS)+\n     CTDSCAT(&CTDSCAT) +\n     STEPLIB('&STEPLIB') +\n     LANG(&LANG) +\n     PGMID(&PGMID) +\n     FORCE(&FORCE) +\n     &DEBUG DATE(&YY&MM&DD) &NOALC\n   ELSE    +\nIF &DATEFMT=USA THEN +\n  %CTDUPAMF CTDSLIB('&CTDSLIB') +\n     CTDCAL('&CTDCAL') +\n     CTDSMIS(&CTDSMIS)+\n     CTDSCAT(&CTDSCAT) +\n     STEPLIB('&STEPLIB') +\n     LANG(&LANG) +\n     PGMID(&PGMID) +\n     FORCE(&FORCE) +\n     &DEBUG DATE(&MM&DD&YY) &NOALC\n   ELSE    +\n  %CTDUPAMF CTDSLIB('&CTDSLIB') +\n     CTDCAL('&CTDCAL') +\n     CTDSMIS(&CTDSMIS)+\n     CTDSCAT(&CTDSCAT) +\n     STEPLIB('&STEPLIB') +\n     LANG(&LANG) +\n     PGMID(&PGMID) +\n     FORCE(&FORCE) +\n     &DEBUG DATE(&DD&MM&YY) &NOALC\nSET &NOALC=NOALC\nEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CTDCRMIS": {"ttr": 4875, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x10_\\x00\\x94\\x10_\\x04\\x10\\x00L\\x00L\\x00\\x00\\xc9\\xd6\\xc1\\xf4\\xf1\\xf0@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-04-15T00:00:00", "modifydate": "1994-04-15T04:10:00", "lines": 76, "newlines": 76, "modlines": 0, "user": "IOA410"}, "text": "PROC 0 DEBUG   STEPLIB(SYS1.IOA.V410.LOAD) LANG() +\n         MISDEF(SYSM.CTDI.V310.PARM) +\n         BKPMIS(SYSS.CTDO.V310.BKPMIS) +\n         RSTMIS(SYSS.CTDO.V310.RSTMIS) +\n         BKPSKL(SYSS.CTDO.V310.BKPSKL)\n  CONTROL NOLIST NOCONLIST NOSYMLIST NOMSG FLUSH\nIF &DEBUG=DEBUG THEN +\n    CONTROL LIST CONLIST SYMLIST MSG FLUSH\nFREE  DD(SYSPRINT)\nFREE  DD(DAMISI)\nFREE  DD(DASKL)\nFREE  DD(DABKPO)\nFREE  DD(DARSTO)\nALLOC DD(DAMISI) DSN('&MISDEF') SH\nALLOC DD(DASKL) DSN('&BKPSKL') SH\nALLOC DD(DABKPO) DSN('&BKPMIS') SH\nALLOC DD(DARSTO) DSN('&RSTMIS') SH\nALLOC DD(SYSPRINT) DA(*)\nISPEXEC CONTROL ERRORS RETURN\nREDISP: +\nDO WHILE &RESP \u00ac= END\n   SET &MEM = &STR()\n   ISPEXEC DISPLAY PANEL(CTDPCRMS) MSG(&MSG) CURSOR(&CUR)\n   SET &RC = &LASTCC\n   SET NNNN = &STR()\n   SET MSG  = &STR()\n   IF &RC = 8 THEN EXIT\n   ELSE +\n     IF &RC \u00ac= 0 THEN +\n        DO\n           WRITE UNABLE TO LOCATE PANEL CTDPCRMS (  RC=&RC  )\n           EXIT\n        END\n     ELSE\n       /*---------- CHECK AND EDIT BACKUP REQUEST  --------------*/\n       /*                                                        */\n       IF &BKR = BKP THEN +\n             DO\n               SET LEN = 4 - &LENGTH(&STR(&RETP))\n                 DO WHILE &LEN > 0\n                   SET NNNN = &STR(&NNNN.0)\n                   SET LEN = &LEN - 1\n                 END\n               SET &RETP = &STR(&NNNN&RETP)\n               SET &INT  = &STR(000)\n               IF  &LENGTH(&STR(&MEM)) = 0  THEN +\n                     SET &MEM = &STR(&BKR&RETP.D)\n             END\n       /*---------- CHECK AND EDIT RESTORE REQUEST  --------------*/\n       /*                                                         */\n       ELSE +\n         DO\n              IF &LENGTH(&STR(&INT)) = 0 AND +\n                 &LENGTH(&STR(&MEM)) = 0 THEN +\n                   DO\n                     SET &MSG = CTDPC332\n                     SET &CUR = MEM\n                     GOTO ENDLOOP\n                   END\n              ELSE +\n                   DO\n                    SET LEN = 3 - &LENGTH(&STR(&INT))\n                      DO WHILE &LEN>0\n                        SET NNNN = &STR(&NNNN.0)\n                        SET LEN = &LEN - 1\n                      END\n                     SET &INT = &STR(&NNNN&INT)\n                     SET &RETP= &STR(0000)\n                     IF  &LENGTH(&STR(&MEM)) = 0  THEN +\n                           SET &MEM = &STR(&BKR&INT.M)\n                   END\n         END\n     CALL  '&STEPLIB&LANG(CTDCBK)' '&BKR &RETP &INT &MEM'\nENDLOOP: END\nEXIT: +\n END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CTDIOLV": {"ttr": 4878, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x10_\\x00\\x94\\x10_\\x04\\x10\\x00\\t\\x00\\t\\x00\\x00\\xc9\\xd6\\xc1\\xf4\\xf1\\xf0@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-04-15T00:00:00", "modifydate": "1994-04-15T04:10:00", "lines": 9, "newlines": 9, "modlines": 0, "user": "IOA410"}, "text": "PROC 0  APPLTYPE(I)  -\n        APPLID(CU)\n/****************************************************************\n/*                                                              *\n/*  CONTROL-D:   REPORT DISTRIBUTION SYSTEM   (DOLV) (ISPF)     *\n/*                                                              *\n/****************************************************************\n%IOAONL APPLTYPE(&APPLTYPE) APPLID(&APPLID)\nEND:END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CTDISPF": {"ttr": 4880, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x10_\\x00\\x94\\x10_\\x04\\x10\\x00\\t\\x00\\t\\x00\\x00\\xc9\\xd6\\xc1\\xf4\\xf1\\xf0@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-04-15T00:00:00", "modifydate": "1994-04-15T04:10:00", "lines": 9, "newlines": 9, "modlines": 0, "user": "IOA410"}, "text": "PROC 0  APPLTYPE(I)  -\n        APPLID(CD)\n/****************************************************************\n/*                                                              *\n/*  CONTROL-D:   REPORT DISTRIBUTION SYSTEM      (ISPF)         *\n/*                                                              *\n/****************************************************************\n%IOAONL APPLTYPE(&APPLTYPE) APPLID(&APPLID)\nEND:END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CTDISPFU": {"ttr": 4882, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x10_\\x00\\x94\\x10_\\x04\\x10\\x00\\t\\x00\\t\\x00\\x00\\xc9\\xd6\\xc1\\xf4\\xf1\\xf0@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-04-15T00:00:00", "modifydate": "1994-04-15T04:10:00", "lines": 9, "newlines": 9, "modlines": 0, "user": "IOA410"}, "text": "PROC 0  APPLTYPE(I)  -\n        APPLID(CU)\n/****************************************************************\n/*                                                              *\n/*  CONTROL-D:   REPORT DISTRIBUTION SYSTEM   (DOLV) (ISPF)     *\n/*                                                              *\n/****************************************************************\n%IOAONL APPLTYPE(&APPLTYPE) APPLID(&APPLID)\nEND:END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CTDOLV": {"ttr": 4884, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x10_\\x00\\x94\\x10_\\x04\\x10\\x00\\t\\x00\\t\\x00\\x00\\xc9\\xd6\\xc1\\xf4\\xf1\\xf0@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-04-15T00:00:00", "modifydate": "1994-04-15T04:10:00", "lines": 9, "newlines": 9, "modlines": 0, "user": "IOA410"}, "text": "PROC 0  APPLTYPE(S)  -\n        APPLID(CU)\n/****************************************************************\n/*                                                              *\n/*  CONTROL-D:   REPORT DISTRIBUTION SYSTEM   (DOLV) ( TSO)     *\n/*                                                              *\n/****************************************************************\n%IOAONL APPLTYPE(&APPLTYPE) APPLID(&APPLID)\nEND:END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CTDPC": {"ttr": 4886, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x10_\\x00\\x94\\x10_\\x04\\x10\\x00\\t\\x00\\t\\x00\\x00\\xc9\\xd6\\xc1\\xf4\\xf1\\xf0@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-04-15T00:00:00", "modifydate": "1994-04-15T04:10:00", "lines": 9, "newlines": 9, "modlines": 0, "user": "IOA410"}, "text": "PROC 0  APPLTYPE(S)  -\n        APPLID(CF)\n/****************************************************************\n/*                                                              *\n/*  ACTIVATE CTDPC COMMUNICATION PROGRAM         ( TSO)         *\n/*                                                              *\n/****************************************************************\n%IOAONL APPLTYPE(&APPLTYPE) APPLID(&APPLID)\nEND:END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CTDPRTRQ": {"ttr": 4888, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x10_\\x00\\x94\\x10_\\x04\\x10\\x00J\\x00F\\x00\\x00\\xc9\\xd6\\xc1\\xf4\\xf1\\xf0@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-04-15T00:00:00", "modifydate": "1994-04-15T04:10:00", "lines": 74, "newlines": 70, "modlines": 0, "user": "IOA410"}, "text": "PROC 0 DEBUG DATEFMT(USA) +\n         STEPLIB(SYS1.IOA.V410.LOAD) +\n         LANG() +\n         OLPREFA(SYSS.IOA) +\n         OLPREFD(SYSS.CTDO) +\n         OLVERA(V410) +\n         OLVERD(V310) +\n         PGMID(CTDPRQ)\nISPEXEC CONTROL ERRORS RETURN\nCONTROL MAIN NOLIST NOCONLIST NOSYMLIST NOMSG\nIF &DEBUG=DEBUG THEN CONTROL MAIN LIST CONLIST SYMLIST MSG\nISPEXEC VGET (ZDAY,ZMONTH,ZYEAR)\nSET YY=&ZYEAR\nSET MM=&ZMONTH\nSET DD=&ZDAY\nSET &NOALC=&STR()\nSET MM=&SUBSTR(2:3,&EVAL(&MM+100))\nSET DD=&SUBSTR(2:3,&EVAL(&DD+100))\nSET CTDSLIB=&STR(&OLPREFD..&OLVERD..PRTMIS)\nSET CTDCAL=&STR(&OLPREFA..&OLVERA..CAL)\nSET CTDSMIS=&STR()\nSET CTDSCAT=&STR()\nSET FOR=NO\nREDISP:+\nIF &DATEFMT=JPN THEN +\n      ISPEXEC DISPLAY PANEL(CTDPPRQJ)\n      ELSE  +\n        IF &DATEFMT=USA THEN +\n              ISPEXEC DISPLAY PANEL(CTDPPRQA)\n              ELSE  ISPEXEC DISPLAY PANEL(CTDPPRQW)\nIF &RESP = END THEN EXIT\nSET FORCE=&FOR\nSET ZYEAR=&YY\nSET ZMONTH=&MM\nSET ZDAY=&DD\nSET ZDAY=&SUBSTR(2:3,&EVAL(&ZDAY+100))\nSET ZMONTH=&SUBSTR(2:3,&EVAL(&ZMONTH+100))\nIF &DATEFMT=JPN THEN +\n  %CTDUPAMF CTDSLIB('&CTDSLIB') +\n     CTDCAL('&CTDCAL') +\n     CTDSMIS(&CTDSMIS)+\n     CTDSCAT(&CTDSCAT) +\n     STEPLIB('&STEPLIB') +\n     LANG(&LANG) +\n     PGMID(&PGMID) +\n     FORCE(&FORCE) +\n     &DEBUG DATE(&YY&MM&DD) &NOALC\n   ELSE    +\nIF &DATEFMT=USA THEN +\n  %CTDUPAMF CTDSLIB('&CTDSLIB') +\n     CTDCAL('&CTDCAL') +\n     CTDSMIS(&CTDSMIS)+\n     CTDSCAT(&CTDSCAT) +\n     STEPLIB('&STEPLIB') +\n     LANG(&LANG) +\n     PGMID(&PGMID) +\n     FORCE(&FORCE) +\n     &DEBUG DATE(&MM&DD&YY) &NOALC\n   ELSE    +\n  %CTDUPAMF CTDSLIB('&CTDSLIB') +\n     CTDCAL('&CTDCAL') +\n     CTDSMIS(&CTDSMIS)+\n     CTDSCAT(&CTDSCAT) +\n     STEPLIB('&STEPLIB') +\n     LANG(&LANG) +\n     PGMID(&PGMID) +\n     FORCE(&FORCE) +\n     &DEBUG DATE(&DD&MM&YY) &NOALC\nSET &NOALC=NOALC\nSET DD=&SUBSTR(2:3,&EVAL(&ZDAY+100))\nSET MM=&SUBSTR(2:3,&EVAL(&ZMONTH+100))\nSET YY=&SUBSTR(2:3,&EVAL(&ZYEAR+100))\nGOTO REDISP\nEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CTDREPRQ": {"ttr": 4891, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x10_\\x00\\x94\\x10_\\x04\\x10\\x00J\\x00F\\x00\\x00\\xc9\\xd6\\xc1\\xf4\\xf1\\xf0@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-04-15T00:00:00", "modifydate": "1994-04-15T04:10:00", "lines": 74, "newlines": 70, "modlines": 0, "user": "IOA410"}, "text": "PROC 0 DEBUG DATEFMT(USA) +\n         STEPLIB(SYS1.IOA.V410.LOAD) +\n         LANG() +\n         OLPREFA(SYSS.IOA) +\n         OLPREFD(SYSS.CTDO) +\n         OLVERA(V410) +\n         OLVERD(V310) +\n         PGMID(CTDRRQ)\nISPEXEC CONTROL ERRORS RETURN\nCONTROL MAIN NOLIST NOCONLIST NOSYMLIST NOMSG\nIF &DEBUG=DEBUG THEN CONTROL MAIN LIST CONLIST SYMLIST MSG\nISPEXEC VGET (ZDAY,ZMONTH,ZYEAR)\nSET YY=&ZYEAR\nSET MM=&ZMONTH\nSET DD=&ZDAY\nSET &NOALC=&STR()\nSET MM=&SUBSTR(2:3,&EVAL(&MM+100))\nSET DD=&SUBSTR(2:3,&EVAL(&DD+100))\nSET CTDSLIB=&STR(&OLPREFD..&OLVERD..REPORTS)\nSET CTDCAL=&STR(&OLPREFA..&OLVERA..CAL)\nSET CTDSMIS=&STR()\nSET CTDSCAT=&STR()\nSET FOR=NO\nREDISP:+\nIF &DATEFMT=JPN THEN +\n      ISPEXEC DISPLAY PANEL(CTDPRPQJ)\n      ELSE  +\nIF &DATEFMT=USA THEN +\n      ISPEXEC DISPLAY PANEL(CTDPRPQA)\n      ELSE  ISPEXEC DISPLAY PANEL(CTDPRPQW)\nIF &RESP = END THEN EXIT\nSET FORCE=&FOR\nSET ZYEAR=&YY\nSET ZMONTH=&MM\nSET ZDAY=&DD\nSET ZDAY=&SUBSTR(2:3,&EVAL(&ZDAY+100))\nSET ZMONTH=&SUBSTR(2:3,&EVAL(&ZMONTH+100))\nIF &DATEFMT=JPN THEN +\n  %CTDUPAMF CTDSLIB('&CTDSLIB') +\n     CTDCAL('&CTDCAL') +\n     CTDSMIS(&CTDSMIS)+\n     CTDSCAT(&CTDSCAT) +\n     STEPLIB('&STEPLIB') +\n     LANG(&LANG) +\n     PGMID(&PGMID) +\n     FORCE(&FORCE) +\n     &DEBUG DATE(&YY&MM&DD) &NOALC\n   ELSE    +\nIF &DATEFMT=USA THEN +\n  %CTDUPAMF CTDSLIB('&CTDSLIB') +\n     CTDCAL('&CTDCAL') +\n     CTDSMIS(&CTDSMIS)+\n     CTDSCAT(&CTDSCAT) +\n     STEPLIB('&STEPLIB') +\n     LANG(&LANG) +\n     PGMID(&PGMID) +\n     FORCE(&FORCE) +\n     &DEBUG DATE(&MM&DD&YY) &NOALC\n   ELSE    +\n  %CTDUPAMF CTDSLIB('&CTDSLIB') +\n     CTDCAL('&CTDCAL') +\n     CTDSMIS(&CTDSMIS)+\n     CTDSCAT(&CTDSCAT) +\n     STEPLIB('&STEPLIB') +\n     LANG(&LANG) +\n     PGMID(&PGMID) +\n     FORCE(&FORCE) +\n     &DEBUG DATE(&DD&MM&YY) &NOALC\nSET &NOALC=NOALC\nSET DD=&SUBSTR(2:3,&EVAL(&ZDAY+100))\nSET MM=&SUBSTR(2:3,&EVAL(&ZMONTH+100))\nSET YY=&SUBSTR(2:3,&EVAL(&ZYEAR+100))\nGOTO REDISP\nEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CTDRSTRQ": {"ttr": 5121, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x10_\\x00\\x94\\x10_\\x04\\x10\\x00J\\x00F\\x00\\x00\\xc9\\xd6\\xc1\\xf4\\xf1\\xf0@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-04-15T00:00:00", "modifydate": "1994-04-15T04:10:00", "lines": 74, "newlines": 70, "modlines": 0, "user": "IOA410"}, "text": "PROC 0 DEBUG DATEFMT(USA) +\n         STEPLIB(SYS1.IOA.V410.LOAD) +\n         LANG() +\n         OLPREFA(SYSS.IOA) +\n         OLPREFD(SYSS.CTDO) +\n         OLVERA(V410) +\n         OLVERD(V310) +\n         PGMID(CTDSRQ)\nISPEXEC CONTROL ERRORS RETURN\nCONTROL MAIN NOLIST NOCONLIST NOSYMLIST NOMSG\nIF &DEBUG=DEBUG THEN CONTROL MAIN LIST CONLIST SYMLIST MSG\nISPEXEC VGET (ZDAY,ZMONTH,ZYEAR)\nSET YY=&ZYEAR\nSET MM=&ZMONTH\nSET DD=&ZDAY\nSET &NOALC=&STR()\nSET MM=&SUBSTR(2:3,&EVAL(&MM+100))\nSET DD=&SUBSTR(2:3,&EVAL(&DD+100))\nSET CTDSLIB=&STR(&OLPREFD..&OLVERD..RSTMIS)\nSET CTDCAL=&STR(&OLPREFA..&OLVERA..CAL)\nSET CTDSMIS=&STR()\nSET CTDSCAT=&STR()\nSET FOR=NO\nREDISP:+\nIF &DATEFMT=JPN THEN +\n      ISPEXEC DISPLAY PANEL(CTDPRSQJ)\n      ELSE  +\nIF &DATEFMT=USA THEN +\n      ISPEXEC DISPLAY PANEL(CTDPRSQA)\n      ELSE  ISPEXEC DISPLAY PANEL(CTDPRSQW)\nIF &RESP = END THEN EXIT\nSET FORCE=&FOR\nSET ZYEAR=&YY\nSET ZMONTH=&MM\nSET ZDAY=&DD\nSET ZDAY=&SUBSTR(2:3,&EVAL(&ZDAY+100))\nSET ZMONTH=&SUBSTR(2:3,&EVAL(&ZMONTH+100))\nSET &NOALC=NOALC\nSET DD=&SUBSTR(2:3,&EVAL(&ZDAY+100))\nSET MM=&SUBSTR(2:3,&EVAL(&ZMONTH+100))\nSET YY=&SUBSTR(2:3,&EVAL(&ZYEAR+100))\nIF &DATEFMT=JPN THEN +\n  %CTDUPAMF CTDSLIB('&CTDSLIB') +\n     CTDCAL('&CTDCAL') +\n     CTDSMIS(&CTDSMIS)+\n     CTDSCAT(&CTDSCAT) +\n     STEPLIB('&STEPLIB') +\n     LANG(&LANG) +\n     PGMID(&PGMID) +\n     FORCE(&FORCE) +\n     &DEBUG DATE(&YY&MM&DD) &NOALC\n   ELSE    +\nIF &DATEFMT=USA THEN +\n  %CTDUPAMF CTDSLIB('&CTDSLIB') +\n     CTDCAL('&CTDCAL') +\n     CTDSMIS(&CTDSMIS)+\n     CTDSCAT(&CTDSCAT) +\n     STEPLIB('&STEPLIB') +\n     LANG(&LANG) +\n     PGMID(&PGMID) +\n     FORCE(&FORCE) +\n     &DEBUG DATE(&MM&DD&YY) &NOALC\n   ELSE    +\n  %CTDUPAMF CTDSLIB('&CTDSLIB') +\n     CTDCAL('&CTDCAL') +\n     CTDSMIS(&CTDSMIS)+\n     CTDSCAT(&CTDSCAT) +\n     STEPLIB('&STEPLIB') +\n     LANG(&LANG) +\n     PGMID(&PGMID) +\n     FORCE(&FORCE) +\n     &DEBUG DATE(&DD&MM&YY) &NOALC\nGOTO REDISP\nEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CTDUPAMF": {"ttr": 5124, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x10_\\x00\\x94\\x10_\\x04\\x10\\x001\\x000\\x00\\x00\\xc9\\xd6\\xc1\\xf4\\xf1\\xf0@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-04-15T00:00:00", "modifydate": "1994-04-15T04:10:00", "lines": 49, "newlines": 48, "modlines": 0, "user": "IOA410"}, "text": "PROC 0 DEBUG  DATE() +\n       NOALC   +\n       PGMID() +\n       CTDSLIB() +\n       STEPLIB(SYS1.IOA.V410.LOAD) +\n       LANG() +\n       DBPREFD(SYSS.CTDO) +\n       DBPREFA(SYSS.IOA) +\n       ILPREFD(SYSM.CTDI) +\n       DBVERD(V310) +\n       DBVERA(V410) +\n       ILVERD(V310) +\n       CTDCAL(SYSS.IOA.V410.CAL) +\n       CTDSMIS()  +\n       CTDSCAT()  +\n       FORCE()\nCONTROL MAIN NOLIST NOCONLIST NOSYMLIST NOMSG\nIF &DEBUG=DEBUG THEN CONTROL MAIN LIST CONLIST SYMLIST MSG\nLSTDS: LISTDSI DACAL FILE PREALLOC\nSET  OLDDACAL = &SYSDSNAME\nFREE DD(DACAL)\nIF &NOALC=NOALC THEN GOTO NOALLOC\nFREE DD(DAOUT,SYSPRINT,PRTDBG,DAAMF,DALOG,DAGENUSR)\nALLOC DD(DAGENUSR) +\n     DA('&ILPREFD..&ILVERD..PARM') SH\nALLOC DD(DAAMF) +\n     DA('&DBPREFD..&DBVERD..AMF') SH\nALLOC DD(DALOG) +\n     DA('&DBPREFA..&DBVERA..LOG') SH\nALLOC DD(DAOUT) DA(*)\nALLOC DD(SYSPRINT) DA(*)\nALLOC DD(PRTDBG) SYSOUT(X) HOLD\nIF &DEBUG=DEBUG THEN GOTO DEBUGYS\nGOTO NOALLOC\nDEBUGYS:+\nFREE DD(PRTDBG)\nALLOC DD(PRTDBG) DA(*)\nNOALLOC:+\nALLOC DD(DACAL) +\n     DA('&CTDCAL') SH\nIF &FORCE=YES THEN SET FORCE=FORCE\n              ELSE SET FORCE=\nTSOEXEC CALL '&STEPLIB&LANG(&PGMID)' +\n '&DATE &CTDSLIB &CTDSMIS &CTDSCAT &FORCE'\nIF '&OLDDACAL' = '' THEN GOTO NODEALL\nIF '&OLDDACAL' = '&CTMCAL' THEN GOTO NODEALL\nFREE DD(DACAL)\nALLOC DD(DACAL) DA('&OLDDACAL') SH\nNODEALL: END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CTDXPC": {"ttr": 5126, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x10_\\x00\\x94\\x10_\\x04\\x10\\x00\\r\\x00\\r\\x00\\x00\\xc9\\xd6\\xc1\\xf4\\xf1\\xf0@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-04-15T00:00:00", "modifydate": "1994-04-15T04:10:00", "lines": 13, "newlines": 13, "modlines": 0, "user": "IOA410"}, "text": "PROC 0 LOADLIB(SYS1.IOA.V410.LOAD)\n\n/*******************************************************************/\n/*                                                                 */\n/* THIS CLIST CALLS THE ONLINE FACILITY UNDER TSO/ROSCOE UNDER THE */\n/* CROSS MEMORY INTERFACE - CONTROL-D/PC TRANSFER EXECUTOR.        */\n/*                                                                 */\n/*******************************************************************/\n\n\nCALL  '&LOADLIB(CTMCTSO)' 'DFTR'\n\nEXIT CODE(&MAXCC)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CTDXTSO": {"ttr": 5128, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x10_\\x00\\x94\\x10_\\x04\\x10\\x00\\r\\x00\\r\\x00\\x00\\xc9\\xd6\\xc1\\xf4\\xf1\\xf0@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-04-15T00:00:00", "modifydate": "1994-04-15T04:10:00", "lines": 13, "newlines": 13, "modlines": 0, "user": "IOA410"}, "text": "PROC 0 LOADLIB(SYS1.IOA.V410.LOAD)\n\n/*******************************************************************/\n/*                                                                 */\n/* THIS CLIST CALLS THE ONLINE FACILITY UNDER TSO/ROSCOE UNDER THE */\n/* CROSS MEMORY INTERFACE - CONTROL-D ONLY.                        */\n/*                                                                 */\n/*******************************************************************/\n\n\nCALL  '&LOADLIB(CTMCTSO)' 'DMAN'\n\nEXIT CODE(&MAXCC)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CTDXTSOU": {"ttr": 5130, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x10_\\x00\\x94\\x10_\\x04\\x10\\x00\\r\\x00\\r\\x00\\x00\\xc9\\xd6\\xc1\\xf4\\xf1\\xf0@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-04-15T00:00:00", "modifydate": "1994-04-15T04:10:00", "lines": 13, "newlines": 13, "modlines": 0, "user": "IOA410"}, "text": "PROC 0 LOADLIB(SYS1.IOA.V410.LOAD)\n\n/*******************************************************************/\n/*                                                                 */\n/* THIS CLIST CALLS THE ONLINE FACILITY UNDER TSO/ROSCOE UNDER THE */\n/* CROSS MEMORY INTERFACE - CONTROL-D ONLINE VIEWING ONLY          */\n/*                                                                 */\n/*******************************************************************/\n\n\nCALL  '&LOADLIB(CTMCTSO)' 'DOLV'\n\nEXIT CODE(&MAXCC)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CTMAES": {"ttr": 5132, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x10_\\x00\\x94\\x10_\\x04\\x10\\x00%\\x00%\\x00\\x00\\xc9\\xd6\\xc1\\xf4\\xf1\\xf0@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-04-15T00:00:00", "modifydate": "1994-04-15T04:10:00", "lines": 37, "newlines": 37, "modlines": 0, "user": "IOA410"}, "text": "PROC 0 ILPREFM('SYSM.CTMI')   -\n       ILVERM('V410')     -\n       OLPREFM('SYSS.CTMO')   -\n       OLVERM('V410')     -\n       STEPLIB('SYS1.IOA.V410.LOAD')   -\n       LANG()           -\n       SYMLIB('SYSM.CTMI.V410.PARM') -\n       DBG(DUMMY)             -\n       MEM(AESPARM)\n/*************************************************************\n/*                                                           *\n/*  THIS CLIST INVOKES THE CONTROL-M AUTO EDIT SIMULATION.   *\n/*                                                           *\n/*  TO USE THE SUBMIT OR SUBSCAN FUNCTIONS, THIS CLIST       *\n/*  ALLOCATES THE DD DASUBMIT TO A TEMPORARY FILE AND        *\n/*  USES THE TSO SUBMIT FUNCTION.                            *\n/*                                                           *\n/*  IF YOU WANT TO DIRECT THE DASUBMIT TO A SYSOUT OR TO     *\n/*  ANOTHER FILE/MEMBER, THIS CAN BE ACCOMPLISHED BY         *\n/*  CHANGING THE CORRESPONDING ALLOC COMMAND IN THIS CLIST.  *\n/*                                                           *\n/*************************************************************\nCONTROL NOMSG NOFLUSH\nFREE  DD(PRTDBG,DALIB,SYSPRINT,DASIM,DAGLOBAL,DALIBS11,DASUBMIT)\nALLOC F(PRTDBG)    &DBG SYSOUT(A)  HOLD\nALLOC DD(SYSPRINT) DA(*)\nALLOC DD(DASIM)    DA('&SYMLIB(&MEM)') SHR\nALLOC DD(DALIB)    DA('&OLPREFM..&OLVERM..JCL') SHR\nALLOC DD(DAGLOBAL) DA('&ILPREFM..&ILVERM..PARM') SHR\nALLOC DD(DASUBMIT) DA('&SYSUID..&OLVERM..SUBMIT') TR SP(1 1) NEW DELETE\nCONTROL MSG\nCALL    '&STEPLIB&LANG(CTMAES)'\nSUB     '&SYSUID..&OLVERM..SUBMIT'\nCONTROL NOMSG\nFREE    DD(PRTDBG)\nCONTROL MSG\nEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CTMCAES": {"ttr": 5134, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x10_\\x00\\x94\\x10_\\x04\\x10\\x00v\\x00t\\x00\\x00\\xc9\\xd6\\xc1\\xf4\\xf1\\xf0@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-04-15T00:00:00", "modifydate": "1994-04-15T04:10:00", "lines": 118, "newlines": 116, "modlines": 0, "user": "IOA410"}, "text": "PROC 0 DEBUG                +\n       DATEFMT(USA)   +\n       ILPREFM(SYSM.CTMI)   +\n       ILVERM(V410)     +\n       OLVERM(V410)     +\n       LANG()         +\n       LOADLIB(SYS1.IOA.V410.LOAD)   +\n       DBG(DUMMY)           +\n       NOALC\n /* CONTROL MAIN LIST CONLIST SYMLIST MSG\n /* WM1286 AM 200992 SUPPORT JAPANESE DATE */\nCONTROL NOMSG NOFLUSH\nFREE DD(PRTDBG)\nALLOC F(PRTDBG) &DBG SYSOUT(A)  HOLD\nCONTROL MSG\nIF &DEBUG=DEBUG  +\n   THEN CONTROL MAIN LIST CONLIST SYMLIST MSG\nISPEXEC VGET (ZDAY,ZMONTH,ZYEAR,ZUSER)\nISPEXEC VGET (JOBSCAN)\nSET CTMFUN=LIST\nSET CTMLIBN=&ILPREFM..&ILVERM..JCL\nSET CTMGLOB=&ILPREFM..&ILVERM..PARM\nSET CTMUSERN=&ZUSER\nREDISP:+\nSET YW=&ZYEAR\nSET YO=&ZYEAR\nSET MW=&ZMONTH\nSET MO=&ZMONTH\nSET DW=&ZDAY\nSET DO=&ZDAY\nSET &NOALC=&STR()\nSET MW=&SUBSTR(2:3,&EVAL(&MW+100))\nSET MO=&SUBSTR(2:3,&EVAL(&MO+100))\nSET DW=&SUBSTR(2:3,&EVAL(&DW+100))\nSET DO=&SUBSTR(2:3,&EVAL(&DO+100))\nSET YW=&SUBSTR(2:3,&EVAL(&YW+100))\nSET YO=&SUBSTR(2:3,&EVAL(&YO+100))\nIF &DATEFMT=JPN THEN SET &AMERDATE =NO\n                ELSE +\nIF &DATEFMT=USA THEN SET &AMERDATE =YES\n                ELSE SET &AMERDATE =NO\nISPEXEC  VPUT  AMERDATE PROFILE\nIF &JOBSCAN=YES  THEN +\n   ISPEXEC DISPLAY PANEL(CTMPAESJ)\nELSE +\n   ISPEXEC DISPLAY PANEL(CTMPAES)\nIF &RESP = END THEN EXIT\nIF &SYSINDEX(JOBSCAN,&CTMFUN) NE 0 THEN +\n  DO\n    SET &CTMFUN= SUBMIT\n    SET &JBS = YES\n  END\nELSE +\n  SET &JBS = NO\nCONTROL NOMSG\nLISTDSI DALIB FILE PREALLOC\nSET  OLDDALIB = &SYSDSNAME\nFREE  DD(DALIB)\nALLOC DD(DALIB)    DA('&ILPREFM..&ILVERM..PARM') SHR\nFREE  DD(ATTR,DAGLOBAL,DASIM,DASUBMIT,SYSPRINT)\nCONTROL MSG\nALLOC DD(ATTR) BLKSIZE(8000)\nALLOC DD(DAGLOBAL) DA('&CTMGLOB') SHR\nALLOC DD(SYSPRINT) DA('&SYSUID..&OLVERM..AESBRO') TR SP(1 1) NEW DELETE\nALLOC DD(DASUBMIT) DA('&SYSUID..&OLVERM..SUBMIT')  +\n      TR SP(1 1) NEW DELETE US(ATTR)\nALLOC DD(DASIM)    NEW TRACKS SP(1 1)\nOPENFILE DASIM OUTPUT\nSET DASIM=&STR(+\nLIBRARY &CTMLIBN)\nPUTFILE DASIM\nSET DASIM=&STR(+\nMEMBER  &CTMMEMN)\nPUTFILE DASIM\nSET DASIM=&STR(+\nOWNER   &CTMUSERN)\nPUTFILE DASIM\nSET DASIM=&STR(+\nWDATE   &DW.&MW.&YW)\nPUTFILE DASIM\nSET DASIM=&STR(+\nODATE   &DO.&MO.&YO)\nPUTFILE DASIM\nSET DASIM=&STR(+\n&CTMFUN)\nPUTFILE DASIM\nCLOSFILE DASIM\nTSOEXEC CALL '&LOADLIB&LANG(CTMAES)'\nIF &JBS = YES THEN +\n  DO\n    ISPEXEC LMINIT DATAID(CTMAES2) DDNAME(DASUBMIT)\n    IF &LASTCC \u00ac= 0 THEN DO\n     SET ECODE= 8\n     WRITE JOB/SCAN COULD NOT BE ACTIVATED FOR JCL SCAN\n    END\n    ELSE DO\n    ISPEXEC EDIT DATAID(&CTMAES2) MACRO(CTMDT)\n    ISPEXEC LMFREE DATAID(&CTMAES2)\n    ISPEXEC VGET ECODE SHARED\n    END\n    SET CTMFUN=JOBSCAN\n  END\nIF (&JBS \u00ac= YES) | (&ECODE = 8)  THEN +\n  DO\n    ISPEXEC LMINIT DATAID(CTMAES2) DDNAME(SYSPRINT)\n    ISPEXEC BROWSE  DATAID(&CTMAES2)\n    ISPEXEC LMFREE DATAID(&CTMAES2)\n  END\nFREE  DD(SYSPRINT)\nALLOC DD(SYSPRINT) DA(*)\nIF '&OLDDALIB' = '' THEN GOTO NODEALL\nFREE DD(DALIB)\nALLOC DD(DALIB) DA('&OLDDALIB')  SHR\nNODEALL:+\nIF &JBS \u00ac= YES THEN +\n  IF &SYSINDEX(SUB,&CTMFUN) NE 0 THEN SUB '&SYSUID..&OLVERM..SUBMIT'\nGOTO  REDISP\nEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CTMCALOC": {"ttr": 5137, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x10_\\x00\\x94\\x10_\\x04\\x10\\x00>\\x00>\\x00\\x00\\xc9\\xd6\\xc1\\xf4\\xf1\\xf0@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-04-15T00:00:00", "modifydate": "1994-04-15T04:10:00", "lines": 62, "newlines": 62, "modlines": 0, "user": "IOA410"}, "text": "PROC 0 DEBUG() MASTLIB() DAYLIB() JCLLIB(NO)\n/*******************************************************/\n/**  P.P.F. - PARAMETERS PROMPTING FACILITY - TYPE2   **/\n/**                                                   **/\n/**  THE CLIST ALLOCATE A DAILY LIBRARY AND TAKES THE **/\n/**  ALLOCATION PARAMETERS FROM THE MASTER LIBRARY.   **/\n/**                                                   **/\n/**  AFTER ALLOCATING THE DAILY JCL LIBRARY, ALL THE  **/\n/**  MEMBERS ARE COPIED FROM THE MASTER JCL LIBRARY   **/\n/**  TO THE DAILY LIBRARY.                            **/\n/**                                                   **/\n/*******************************************************/\n ISPEXEC CONTROL ERRORS RETURN\n IF &DEBUG = DEBUG +\n THEN +\n    CONTROL LIST MSG SYMLIST CONLIST\n ELSE +\n    CONTROL NOLIST NOMSG\n\n ALLOC FILE(TEMPALC) DA('&DAYLIB') LIKE('&MASTLIB') NEW CATALOG\n SET &RETCODE = &LASTCC\n FREE FILE(TEMPALC)\n\n IF &RETCODE \u00ac= 0 +\n THEN +\n    GOTO END\n\n IF &JCLLIB \u00ac= YES +\n THEN +\n    GOTO END\n\n /* COPY THE MASTER JCL LIBRARY TO THE DAILY JCL LIBRARY */\n\n ISPEXEC LMINIT DATAID(FROMID) DATASET('&MASTLIB') ENQ(SHR)\n SET &RETCODE = &LASTCC\n\n IF &RETCODE \u00ac= 0  +\n THEN +\n    GOTO END\n\n ISPEXEC LMINIT DATAID(TOID) DATASET('&DAYLIB') ENQ(SHR)\n SET &RETCODE = &LASTCC\n\n IF &RETCODE \u00ac= 0  +\n THEN +\n    GOTO BEFEND\n\n ISPEXEC LMOPEN DATAID(&FROMID) OPTION(INPUT)\n SET &RETCODE = &LASTCC\n\n IF &RETCODE \u00ac= 0  +\n THEN +\n    GOTO BEFEND\n\n ISPEXEC LMCOPY FROMID(&FROMID) TODATAID(&TOID) +\n         FROMMEM(*)\n SET &RETCODE = &LASTCC\n\n BEFEND: ISPEXEC LMFREE DATAID(&FROMID)\n         ISPEXEC LMFREE DATAID(&TOID)\n\n END: EXIT CODE(&RETCODE)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CTMCAMNU": {"ttr": 5139, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x10_\\x00\\x94\\x10_\\x04\\x10\\x00\\x16\\x00\\x16\\x00\\x00\\xc9\\xd6\\xc1\\xf4\\xf1\\xf0@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-04-15T00:00:00", "modifydate": "1994-04-15T04:10:00", "lines": 22, "newlines": 22, "modlines": 0, "user": "IOA410"}, "text": " PROC 0 DEBUG\n/*******************************************************/\n/**  P.P.F. - PARAMETERS PROMPTING FACILITY - TYPE2   **/\n/**                                                   **/\n/**  THE CLIST DISPLAYS THE PRIMARY OPTIONS MENU.     **/\n/**                                                   **/\n/*******************************************************/\n IF &DEBUG = DEBUG +\n THEN +\n    CONTROL LIST MSG CONLIST SYMLIST\n ELSE +\n    CONTROL NOLIST NOMSG\n ISPEXEC VGET (PTRAIL) SHARED\n IF &PTRAIL NE 1 AND &PTRAIL NE 2 +\n                 AND &PTRAIL NE 3 AND &PTRAIL NE &STR() +\n THEN +\n    DO\n     SET PTRAIL =\n     ISPEXEC SETMSG MSG(ISPD241)\n    END\n ISPEXEC SELECT PANEL(CTMPF00W) OPT(&PTRAIL)\n EXIT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CTMCAMST": {"ttr": 5141, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x10_\\x00\\x94\\x10_\\x04\\x10\\x00\\xc5\\x00\\xc5\\x00\\x00\\xc9\\xd6\\xc1\\xf4\\xf1\\xf0@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-04-15T00:00:00", "modifydate": "1994-04-15T04:10:00", "lines": 197, "newlines": 197, "modlines": 0, "user": "IOA410"}, "text": "PROC 0 DEBUG()\n/*******************************************************/\n/**  P.P.F. - PARAMETERS PROMPTING FACILITY - TYPE2   **/\n/**                                                   **/\n/**  THE CLIST DISPLAYS A SCREEN THAT GETS THE NAME   **/\n/**  AND THE DESCRIPTION OF A MASTER PROMPTING PLAN   **/\n/**  THAT WILL BE CREATED.                            **/\n/**                                                   **/\n/*******************************************************/\n ISPEXEC CONTROL ERRORS RETURN\n IF &DEBUG = DEBUG +\n THEN +\n    CONTROL LIST MSG SYMLIST CONLIST\n ELSE +\n    CONTROL NOLIST NOMSG\n ISPEXEC VGET ( PLNPREF PLANLIB) PROFILE\n SET &CREATED = NO\n ISPEXEC VGET (ZUSER) SHARED\n REDISP: -\n ISPEXEC DISPLAY PANEL(CTMPF12W)\n SET &RC = &LASTCC\n IF &RC \u00ac= 0  -\n THEN -\n    IF &RC \u00ac= 8  -\n    THEN -\n        DO\n          ISPEXEC SETMSG MSG(CTMF000Z)\n          GOTO END\n        END\n    ELSE -\n       GOTO END\n IF &PLANLIB \u00ac= &STR() AND &PLANLIB \u00ac= &STR( )        -\n THEN -\n    DO\n        SET &IND = 1\n INITRY: SET &TBFILE = &STR(TBFILE&IND)\n       ISPEXEC LMINIT DATAID(TRYID) DDNAME (&TBFILE) ENQ(SHR)\n       SET &RC = &LASTCC\n       IF &RC = 0 -\n       THEN -\n          DO\n            ISPEXEC LMFREE (&TRYID)\n            SET &DSNTRY = DSNTRY&IND\n            SET &DSNTR  = &&DSNTRY&IND\n            ISPEXEC VGET ( &DSNTRY ) SHARED\n            SET DSNTT = &SYSNSUB(2,&DSNTR)\n            IF &DSNTT = &PLANLIB -\n            THEN -\n               GOTO CONT\n            ELSE -\n               DO\n                 SET &IND = &IND + 1\n                 GOTO INITRY\n               END\n          END\n       IF &IND > 99 -\n       THEN -\n          SET &IND = 1\n       SET &TBFILE = &STR(TBFILE&IND)\n       SET &DSNTRY = DSNTRY&IND\n       SET &&DSNTRY = &PLANLIB\n       ISPEXEC VPUT (&DSNTRY) SHARED\n       FREE FILE(&TBFILE)\n       ALLOC FILE(&TBFILE) DA('&PLANLIB') SHR\n       SET &RC = &LASTCC\n       IF &RC \u00ac= 0 -\n       THEN -\n          DO\n              SET &DDERR = &TBFILE\n              SET &DSNERR = &PLANLIB\n              ISPEXEC SETMSG MSG(CTMF005D)\n              GOTO END\n          END\n CONT: SET &TBDD = &STR(&TBFILE)\n       SET &TBLIB = &STR(&PLANLIB)\n    END\n IF &PLANLIB = &STR() OR &PLANLIB =&STR( ) -\n THEN   -\n    DO\n       SET &TBDD = &STR(ISPTABL)\n       SET &TBLIB = &STR(ISPTABL)\n    END\n SET &MANUMSNM = &STR(&PLNPREF.&STR(MS) )\n /*  SET &MANUMSNM = &STR(&PLNPREF)\n ISPEXEC TBCREATE &MANUMSNM +\n       NAMES(PARMNAME PROCCUR# PRMJOBN PROMPIND PRDEFIND PRDEFVAL +\n       PRMDEFST PRVALIND PRMVAL PRMTYPE PROMPMSG ) WRITE LIBRARY(&TBDD)\n SET &RC=&LASTCC\n IF &RC = 8 -\n THEN -\n    DO\n      ISPEXEC SETMSG MSG(CTMF009F)\n      GOTO REDISP\n    END\n IF &RC > 8 -\n THEN    -\n    DO\n      ISPEXEC SETMSG MSG(CTMF000Z)\n      GOTO REDISP\n    END\n ISPEXEC TBVCLEAR &MANUMSNM\n ISPEXEC TBADD  &MANUMSNM\n SET &RC = &LASTCC\n IF &RC \u00ac= 0 -\n THEN    -\n    DO\n      ISPEXEC TBEND  &MANUMSNM\n      ISPEXEC SETMSG MSG(CTMF009A)\n      GOTO REDISP\n    END\n SET &TBNAME =  &MANUMSNM\n ISPEXEC SETMSG MSG(CTMF009B)\n ISPEXEC TBOPEN FETCHTB WRITE\n SET &RETC = &LASTCC\n IF &RETC GT 0 -\n THEN -\n    IF &RETC > 12 -\n    THEN -\n       DO\n         ISPEXEC TBEND  &MANUMSNM\n         ISPEXEC SETMSG MSG (CTMF000Z)\n         GOTO END\n       END\n    ELSE -\n       IF &RETC = 8 -\n       THEN -\n          DO\n             /* TRY TO CREATE IT NOW */\n            ISPEXEC TBCREATE FETCHTB KEYS(TBNAME) +\n               NAMES(USERID PLANLIB DESCRIPT) +\n               WRITE\n            SET &RC=&LASTCC\n            IF &RC > 8 -\n            THEN    -\n               DO\n                 ISPEXEC TBEND  &MANUMSNM\n                 ISPEXEC SETMSG MSG(CTMF000Z)\n                 GOTO REDISP\n               END\n          END\n       ELSE -\n          DO\n            ISPEXEC TBEND  &MANUMSNM\n            ISPEXEC SETMSG MSG (CTMF009E)\n            GOTO REDISP\n          END\n\n SET &TBNAME = &PLNPREF\n SET &USERID = &ZUSER\n ISPEXEC TBADD  FETCHTB\n SET &RETC = &LASTCC\n IF &RETC GT 0 -\n THEN -\n    IF &RETC = 8 -\n    THEN -\n       DO\n         ISPEXEC TBEND  &MANUMSNM\n         ISPEXEC TBEND  FETCHTB\n         ISPEXEC SETMSG MSG (CTMF009F)\n         GOTO REDISP\n       END\n    ELSE -\n       DO\n         ISPEXEC TBEND  &MANUMSNM\n         ISPEXEC TBEND  FETCHTB\n         ISPEXEC SETMSG MSG (CTMF009E)\n         GOTO REDISP\n       END\n ISPEXEC TBCLOSE  FETCHTB\n SET &RETC = &LASTCC\n IF &RETC GT 0 -\n THEN -\n    IF &RETC > 12 -\n    THEN -\n       DO\n         ISPEXEC TBEND  &MANUMSNM\n         ISPEXEC TBEND  FETCHTB\n         ISPEXEC SETMSG MSG (CTMF000Z)\n         GOTO REDISP\n       END\n    ELSE -\n       DO\n         ISPEXEC TBEND  &MANUMSNM\n         ISPEXEC TBEND  FETCHTB\n         ISPEXEC SETMSG MSG (CTMF009E)\n         GOTO REDISP\n       END\n ELSE -\n    DO\n        SET &CREATED = YES\n        SET &TABNAME = &MANUMSNM\n        ISPEXEC TBCLOSE  &MANUMSNM LIBRARY(&TBDD)\n    END\n\n END: ISPEXEC VPUT (PLANLIB PLNPREF ) PROFILE\n      ISPEXEC VPUT ( TBNAME TBLIB CREATED TABNAME ) SHARED\n      ISPEXEC LMFREE DATAID(&FROMID)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CTMCAUPT": {"ttr": 5380, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x10_\\x00\\x94\\x10_\\x04\\x10\\x01\\xde\\x01\\xde\\x00\\x00\\xc9\\xd6\\xc1\\xf4\\xf1\\xf0@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-04-15T00:00:00", "modifydate": "1994-04-15T04:10:00", "lines": 478, "newlines": 478, "modlines": 0, "user": "IOA410"}, "text": "PROC 0 DEBUG\n /*******************************************************************/\n /**                                                               **/\n /**              C  T  M  C  A  U  P  T                           **/\n /**             ========================                          **/\n /**                                                               **/\n /**  PARAMETER PROMPTING FACILITY - TYPE2                         **/\n /**                                                               **/\n /**  THIS CLIST IS THE FIRST PHASE OF THE PARAMETERS PROMPTING    **/\n /**  FACILITY (SECOND PHASE IS FETCHING THE PLAN INTO THE DAILY   **/\n /**  LIBRARIES AND THE THIRD PHASE IS EXECUTING THE PLAN).        **/\n /**                                                               **/\n /**  THE CLIST LETS THE USER TO CREATE / UPDATE THE MASTER        **/\n /**  PROMPTING PLAN AND DEFINE THE PARAMETERS WITHIN IT.          **/\n /**                                                               **/\n /*******************************************************************/\n ISPEXEC CONTROL ERRORS RETURN\n IF &DEBUG = DEBUG +\n THEN +\n    CONTROL LIST MSG CONLIST SYMLIST NOCAPS\n ELSE +\n    CONTROL NOLIST NOMSG NOCAPS\n SET &T = T\n ISPEXEC VGET ( PLNPREF ) PROFILE\n SET &RC = &LASTCC\n IF &RC = 8  -\n THEN -\n    SET &PLNPREF = REPTS\n ISPEXEC VGET ( PLANLIB ) PROFILE\n SET &RC = &LASTCC\n IF &RC = 8  -\n THEN -\n    SET &PLANLIB = &STR(SYSS.CTMO.V410.PLANMSTR)\n ISPEXEC VGET ( ZDAY ZMONTH ) SHARED\n SET &DD = &STR(&ZDAY)\n SET &MM = &STR(&ZMONTH)\n REDISP: +\n ISPEXEC DISPLAY PANEL(CTMPF10W)\n SET &RC = &LASTCC\n IF &RC \u00ac= 0 -\n THEN -\n    IF &RC \u00ac= 8 -\n    THEN -\n       DO\n          ISPEXEC SETMSG MSG(CTMF000Z)\n          GOTO END\n       END\n    ELSE -\n       GOTO END\n SET &ISMSTR = 1\n SET &TABNAME  = &STR(&PLNPREF.&STR(MS))\n /*  SET &TABNAME  = &STR(&PLNPREF)\n\n SET &TBLIB = &PLANLIB\n ISPEXEC LMINIT DATAID(FROMID) DATASET('&PLANLIB') ENQ(SHR)\n SET &RC = &LASTCC\n IF &RC \u00ac= 0  -\n THEN -\n    DO\n      ISPEXEC SETMSG MSG(CTMF000Z)\n      GOTO REDISP\n    END\n\n ISPEXEC LMOPEN DATAID(&FROMID) OPTION(INPUT)\n SET &RC = &LASTCC\n IF &RC \u00ac= 0  -\n THEN -\n    DO\n      ISPEXEC SETMSG MSG(CTMF000Z)\n      GOTO REDISP\n END\n ISPEXEC LMMFIND DATAID(&FROMID) MEMBER(&TABNAME)\n SET &RC = &LASTCC\n IF &RC \u00ac= 0  -\n THEN -\n    IF &RC > 8   -\n    THEN -\n       DO\n          ISPEXEC SETMSG MSG(CTMF000Z)\n          GOTO REDISP\n       END\n    ELSE -\n       DO\n          IF &ISMSTR = 1 -\n          THEN +\n             DO\n               /* MSG TO CREATE A NEW MASTER PLAN */\n                ISPEXEC SETMSG MSG(CTMF005B)\n                ISPEXEC VPUT (PLANLIB PLNPREF)\n                %CTMCAMST\n                ISPEXEC VGET (CREATED TABNAME PLANLIB PLNPREF)\n                IF &CREATED \u00ac= YES -\n                THEN +\n                   DO\n                      ISPEXEC LMFREE DATAID(&FROMID)\n                      GOTO REDISP\n                   END\n             END\n          ELSE +\n             DO\n                ISPEXEC SETMSG MSG(CTMF005C)\n                GOTO REDISP\n             END\n       END\n IF &PLANLIB \u00ac= &STR() -\n THEN   -\n    DO\n        SET &IND = 1\n INITRY: SET &TBFILE = &STR(TBFILE&IND)\n       ISPEXEC LMINIT DATAID(TRYID) DDNAME (&TBFILE) ENQ(SHR)\n       SET &RC = &LASTCC\n       IF &RC = 0 -\n       THEN -\n          DO\n            ISPEXEC LMFREE (&TRYID)\n            SET &DSNTRY = DSNTRY&IND\n            SET &DSNTR  = &&DSNTRY&IND\n            ISPEXEC VGET ( &DSNTRY ) SHARED\n            SET DSNTT = &SYSNSUB(2,&DSNTR)\n            IF &DSNTT = &PLANLIB -\n            THEN -\n               GOTO CONT\n            ELSE -\n               DO\n                 SET &IND = &IND + 1\n                 GOTO INITRY\n               END\n          END\n       IF &IND > 99 -\n       THEN -\n          SET &IND = 1\n       SET &TBFILE = &STR(TBFILE&IND)\n       SET &DSNTRY = DSNTRY&IND\n       SET &&DSNTRY = &PLANLIB\n       ISPEXEC VPUT (&DSNTRY) SHARED\n       FREE FILE(&TBFILE)\n       ALLOC FILE(&TBFILE) DA('&PLANLIB') SHR\n       SET &RC = &LASTCC\n       IF &RC \u00ac= 0 -\n       THEN -\n          DO\n              SET &DDERR = &TBFILE\n              SET &DSNERR = &PLANLIB\n              ISPEXEC SETMSG MSG(CTMF005D)\n              GOTO END\n          END\n CONT: SET &TBDD = &STR(&TBFILE)\n       SET &TBLIB = &STR(&PLANLIB)\n    END\n IF &PLANLIB = &STR() -\n THEN   -\n    DO\n      SET &TBDD = &STR(ISPTABL)\n      SET &TBLIB = &STR(ISPTABL)\n    END\n\n ISPEXEC VGET (ZUSER)\n SET TMPMST = &STR(&ZUSER.&STR(TMP))\n IF &LENGTH(&TMPMST) > 8 -\n THEN -\n    SET &TMPMST = &SUBSTR(1:8,&TMPMST)\n ISPEXEC TBEND &TMPMST\n ISPEXEC TBCREATE &TMPMST +\n         NAMES( PARMNAME PROCCUR# PRMJOBN PROMPIND PRDEFIND PRDEFVAL +\n         PRMDEFST PRVALIND PRMVAL PRMTYPE PROMPMSG ) WRITE\n SET RC=&LASTCC\n IF &RC GT 4 -\n THEN -\n    IF &RC > 12 -\n    THEN -\n       DO\n         ISPEXEC SETMSG MSG(CTMF000Z)\n         GOTO END\n       END\n    ELSE -\n       DO\n         ISPEXEC SETMSG MSG(CTMF005E)\n         GOTO END\n       END\n ISPEXEC TBOPEN &TABNAME WRITE LIBRARY(&TBFILE)\n SET &RETC = &LASTCC\n IF &RETC GT 0 -\n THEN -\n    IF &RETC > 12 -\n    THEN -\n       DO\n         ISPEXEC SETMSG MSG (CTMF000Z)\n         GOTO END\n       END\n    ELSE -\n       DO\n         ISPEXEC SETMSG MSG (CTMF005E)\n         GOTO END\n       END\nLOOPSKIP: +\n ISPEXEC TBSKIP &TABNAME\n IF &LASTCC = 8 -\n THEN -\n    GOTO DISP0\n ISPEXEC TBADD &TMPMST\n GOTO LOOPSKIP\nDISP0: +\n ISPEXEC TBTOP &TMPMST\nDISP01: +\n ISPEXEC TBVCLEAR &TMPMST\n SET &PARMNAME = &STR(&PREFIX.&STR(*))\n ISPEXEC TBSARG &TMPMST\n SET &RC = &LASTCC\n IF &RC = 0 -\n THEN +\n    GOTO DISPPAN1\n ELSE +\n    DO\n      SET &SPFRC = &RC\n      ISPEXEC SETMSG MSG(CTMF000A)\n      GOTO DISPPAN1\n    END\n /* SET QCRP = 0\n SET CURNAME = TCMD\nDISPPAN1: +\n ISPEXEC TBDISPL &TMPMST PANEL(CTMPF11W) ROWID(KEEPROW) &CSR\n SET RC = &LASTCC\n IF &RC > 8 +\n THEN +\n    DO\n       ISPEXEC TBEND &TABNAME\n       ISPEXEC TBEND &TMPMST\n       ISPEXEC SETMSG MSG (CTMF000Z)\n       GOTO END\n    END\n SET &CSR = &STR()\nAFTDISP: +\n IF &TCMD = CANCEL OR &TCMD =cancel +\n THEN +\n    GOTO ENDCAN\nED2: +\n SET RC1 = &RC\n SET QCRP = 0\n SET CURNAME = TCMD\n IF &ZTDSELS = 0 -\n THEN +\n    GOTO CKLINCMD\n IF &TSEL NE D AND &TSEL NE I AND &TSEL NE A AND +\n           &TSEL NE R AND &TSEL NE &STR( )       +\n THEN -\n    DO\n       ISPEXEC SETMSG MSG(CTMF005G)\n       GOTO ED4\n    END\n IF &TSEL = D OR &TSEL = d -\n THEN -\n    DO\n       ISPEXEC TBDELETE &TMPMST\n       GOTO ED4\n    END\n IF &TSEL = A OR &TSEL = R OR &TSEL = a OR &TSEL = r -\n THEN -\n    DO\n       SET &UPDTRET = BEFADD\n       GOTO GENUPDT\n       BEFADD: +\n       SET &UPDTRET = &STR()\n       SET UPDATEDD =\n       SET UPDATEMM =\n       ISPEXEC TBADD &TMPMST\n       IF &LASTCC GT 0 -\n       THEN -\n          DO\n             SET &RETC = &LASTCC\n             ISPEXEC SETMSG MSG(CTMF000A)\n             GOTO DIPPAN1\n          END\n       GOTO ED4\n    END\n IF &TSEL = I OR &TSEL = i -\n THEN -\n    DO\n       SET &UPDTRET = BEFINS\n       GOTO GENUPDT\n       BEFINS: +\n       SET &UPDTRET = &STR()\n       ISPEXEC TBVCLEAR &TMPMST\n       SET &DAILYM = Y\n       ISPEXEC TBQUERY &TMPMST    POSITION(QCRP)\n       ISPEXEC TBADD  &TMPMST\n       IF &LASTCC GT 0 -\n       THEN -\n          DO\n             SET &RETC = &LASTCC\n             ISPEXEC SETMSG MSG(CTMF000A)\n          END\n       SET QCRP = &QCRP + 1\n       GOTO ED4\n    END\n IF &TSEL = &STR( ) -\n THEN -\n    DO\n      GENUPDT: +\n      IF &PRDEFIND = Y +\n      THEN +\n         DO\n           SET &PRMVAL = &STR(&PRDEFVAL)\n           SET &PRMDEFST = &STR(DEF EXISTS)\n         END\n      ELSE +\n         SET &PRMDEFST = &STR(NO DEFAULT)\n      ISPEXEC TBPUT &TMPMST\n      IF &LASTCC GT 8 -\n      THEN -\n         DO\n            SET &RETC = &LASTCC\n            ISPEXEC SETMSG MSG(CTMF000A)\n            GOTO DISPPAN1\n         END\n      IF &PRMTYPE \u00ac= &STR() +\n      THEN +\n         DO\n            ISPEXEC VPUT (PRMTYPE PRMVAL) SHARED\n            ISPEXEC SELECT PGM(CTMTVAL) PARM(SYN)\n            ISPEXEC VGET (VALIDRC) SHARED\n            IF &VALIDRC \u00ac= 0 +\n            THEN +\n               DO\n                  SET &VALIDERR = YES\n                  SET &LASTROW = &KEEPROW\n                  SET &CSR = &STR(CURSOR(PRMTYPE))\n                  SET &ERRCSR = &CSR\n                  GOTO DISPPAN1\n               END\n            ELSE +\n               SET &VALIDERR = NO\n            IF &PRDEFIND = Y +\n            THEN +\n               DO\n      /*          SET &KEEPVAL = &STR(&PRMVAL)\n      /*          SET &PRMVAL = &STR(&PRDEFVAL)\n                  ISPEXEC VPUT (PRMTYPE PRMVAL) SHARED\n                  ISPEXEC SELECT PGM(CTMTVAL) PARM(VAL)\n      /*          SET &PRMVAL = &STR(&KEEPVAL)\n                  ISPEXEC VGET (VALIDRC) SHARED\n                  IF &VALIDRC \u00ac= 0 +\n                  THEN +\n                     DO\n                        SET &LASTROW = &KEEPROW\n                        SET &VALIDERR = YES\n                        SET &CSR = &STR(CURSOR(PRDEFVAL))\n                        SET &ERRCSR = &CSR\n                        GOTO DISPPAN1\n                     END\n                  ELSE +\n                     DO\n                        SET &VALIDERR = NO\n                     END\n               END\n         END\n      IF &UPDTRET = BEFADD +\n      THEN +\n         GOTO BEFADD\n      IF &UPDTRET = BEFINS +\n      THEN +\n         GOTO BEFINS\n    END\nED4: +\n IF &RC1 = 4  -\n THEN -\n    DO\n       ISPEXEC TBDISPL &TMPMST\n       SET RC = &LASTCC\n       GOTO ED2\n    END\n CKLINCMD: +\n IF &RESP = END OR &RC1 = 8 OR &TCMD = END OR &TCMD = end +\n THEN +\n    DO\n       IF &VALIDERR = YES +\n       THEN +\n          DO\n             ISPEXEC SETMSG MSG (CTMF007G)\n             ISPEXEC TBSKIP &TMPMST ROW(&LASTROW)\n             ISPEXEC TBDISPL &TMPMST PANEL(CTMPF11W) &ERRCSR +\n                    ROWID(KEEPROW)\n             SET RC = &LASTCC\n             IF &RC > 8 +\n             THEN +\n                DO\n                   ISPEXEC TBEND &TABNAME\n                   ISPEXEC TBEND &TMPMST\n                   ISPEXEC SETMSG MSG (CTMF000Z)\n                   GOTO END\n                END\n             GOTO AFTDISP\n          END\n  ISPEXEC TBEND &TABNAME\n  ISPEXEC TBCLOSE &TMPMST NAME(&TABNAME) LIBRARY(&TBFILE) PAD(20)\n  GOTO END\n    END\n IF &RC GT 8 -\n THEN -\n    DO\n       ISPEXEC SETMSG MSG(CTMF000Z)\n       GOTO END\n    END\n IF &LENGTH(&TCMD) > 2 -\n THEN -\n    DO\n      SET &CMDPREF = &SUBSTR(1:2,&TCMD)\n      IF &CMDPREF = L OR &CMDPREF = l -\n      THEN -\n         DO\n            SET &LOCARG = &SUBSTR(3:&LENGTH(&TCMD),&TCMD)\n            SET &LOCARG = &STR(&LOCARG.&STR(*))\n            SET &PARMNAME = &STR(&LOCARG)\n            ISPEXEC TBSCAN &TMPMST ARGLIST(PARMNAME) NOREAD\n            SET &RC = &LASTCC\n            IF &RC = 0 -\n            THEN +\n               GOTO DISPPAN1\n            ELSE +\n               IF &RC = 8 +\n               THEN +\n                  DO\n                    ISPEXEC SETMSG MSG(CTMF000B)\n                    GOTO DISPPAN1\n                  END\n               ELSE +\n                  DO\n                    ISPEXEC SETMSG MSG(CTMF000Z)\n                    GOTO DISPPAN1\n                  END\n         END\n      ELSE -\n         IF &TCMD = INSERT OR &TCMD = insert  -\n         THEN -\n             DO\n                ISPEXEC TBVCLEAR &TMPMST\n                SET &DAILYM = Y\n                ISPEXEC TBQUERY &TMPMST    POSITION(QCRP)\n                ISPEXEC TBADD  &TMPMST\n                IF &LASTCC GT 0 -\n                THEN -\n                   DO\n                      SET &RETC = &LASTCC\n                      ISPEXEC SETMSG MSG(CTMF000A)\n                   END\n                SET QCRP = &QCRP + 1\n                GOTO DISPPAN1\n             END\n         ELSE +\n            DO\n               ISPEXEC SETMSG MSG(CTMF000C)\n               GOTO DISPPAN1\n            END\n    END\n ELSE -\n    IF &TCMD \u00ac= &STR() -\n    THEN -\n       DO\n         ISPEXEC SETMSG MSG(CTMF000C)\n         GOTO DISPPAN1\n       END\n IF &LASTPREF \u00ac= &PREFIX +\n THEN +\n    DO\n       SET &LASTPREF = &PREFIX\n       GOTO DISP01\n    END\nREPOSTAB: +\n ISPEXEC TBTOP &TMPMST\n ISPEXEC TBSKIP &TMPMST NUMBER(&ZTDTOP)\n GOTO DISPPAN1\nENDCAN: +\n ISPEXEC TBEND &TABNAME\n ISPEXEC TBEND   &TMPMST\n ISPEXEC SETMSG MSG(CTMF005H)\nEND: +\n ISPEXEC VPUT (PLANLIB PLNPREF) PROFILE\n ISPEXEC VPUT (TBNAME TBLIB) SHARED\n ISPEXEC LMFREE DATAID(&FROMID)\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CTMCCND": {"ttr": 5633, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x10_\\x00\\x94\\x10_\\x04\\x10\\x00\\x1f\\x00\\x1f\\x00\\x00\\xc9\\xd6\\xc1\\xf4\\xf1\\xf0@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-04-15T00:00:00", "modifydate": "1994-04-15T04:10:00", "lines": 31, "newlines": 31, "modlines": 0, "user": "IOA410"}, "text": "PROC 0 DEBUG                +\n       DATEFMT(USA)   +\n       DBPREFA(SYSS.IOA)  +\n       DBVERA(V410)     +\n       LANG()         +\n       LOADLIB(SYS1.IOA.V410.LOAD)   +\n       DBG(DUMMY)           +\n       NOALC\nCONTROL MAIN NOLIST NOCONLIST NOSYMLIST NOMSG\nALLOC F(PRTDBG) &DBG SYSOUT(A)  HOLD\nIF &DEBUG=DEBUG THEN CONTROL MAIN LIST CONLIST SYMLIST MSG\nREDISP:+\nIF &DATEFMT=JPN  +\n   THEN  ISPEXEC DISPLAY PANEL(CTMPCNDJ)\n   ELSE  +\nIF &DATEFMT=USA  +\n   THEN  ISPEXEC DISPLAY PANEL(CTMPCNDA)\n   ELSE  ISPEXEC DISPLAY PANEL(CTMPCNDW)\nIF &RESP = END THEN EXIT\nALLOC DD(DALOG)    DA('&DBPREFA..&DBVERA..LOG') SH\nALLOC DD(DASINC)   DA('&DBPREFA..&DBVERA..SNC') SH\nALLOC DD(DARESF)   DA('&DBPREFA..&DBVERA..RES') SH\nALLOC DD(DAPRINT)  DS(*)\nIF &DATEFMT=JPN  +\n   THEN CALL  '&LOADLIB&LANG(CTMCND)' '&CTMFUN COND &CTMCONDN &MM.&DD'\n   ELSE +\nIF &DATEFMT=USA  +\n   THEN CALL  '&LOADLIB&LANG(CTMCND)' '&CTMFUN COND &CTMCONDN &MM.&DD'\n   ELSE CALL  '&LOADLIB&LANG(CTMCND)' '&CTMFUN COND &CTMCONDN &DD.&MM'\nGOTO  REDISP\nEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CTMCDAIL": {"ttr": 5635, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x10_\\x00\\x94\\x10_\\x04\\x10\\x00\\\\\\x00\\\\\\x00\\x00\\xc9\\xd6\\xc1\\xf4\\xf1\\xf0@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-04-15T00:00:00", "modifydate": "1994-04-15T04:10:00", "lines": 92, "newlines": 92, "modlines": 0, "user": "IOA410"}, "text": "PROC 0 DATE1() DATE2()                      +\n       CTMSLIB(SYSS.CTMO.V410.SCHEDULE) +\n       CTMCAL(SYSS.IOA.V410.CAL)       +\n       CTMSMEM() DEBUG                      +\n       CTMSJOB()                            +\n       CTMGRP()                             +\n       FORCE()                              +\n       DBPREFA(SYSS.IOA)                   +\n       DBPREFM(SYSS.CTMO)                   +\n       DBVERA(V410)                     +\n       DBVERM(V410)                     +\n       LANG()                         +\n       LOADLIB(SYS1.IOA.V410.LOAD)                   +\n       NOALC\n CONTROL MAIN NOLIST NOCONLIST NOSYMLIST NOMSG\n IF &DEBUG=DEBUG THEN CONTROL MAIN LIST CONLIST SYMLIST MSG\n /*   WARNING:   BE VERY CAREFULL WHEN CHANGING THE CLIST !\n /*              FREE  M U S T  BE DONE TO DAJOB,DAJOBI AND DACAL.\n /*\nLSTDS: LISTDSI DACAL FILE PREALLOC\nSET  OLDDACAL = &SYSDSNAME\n /*\nFREE DD(DAJOB,DAJOBI,DACAL)\n IF &NOALC=NOALC THEN GOTO NOALLOC\nFREE  DD(DACHK,DACKPT,DALIB,DALOG,DAOUT,PRTDBG,SYSPRINT)\nALLOC DD(DACHK)    NEW TRACKS SP(1 1)\nALLOC DD(DACKPT)   DA('&DBPREFM..&DBVERM..CKP') SH\nALLOC DD(DALOG)    DA('&DBPREFA..&DBVERA..LOG') SH\nALLOC DD(DAOUT)    DA(*)\nALLOC DD(PRTDBG)   DA(*)\nALLOC DD(SYSPRINT) DA(*)\nNOALLOC:+\nALLOC DD(DACAL)    DA('&CTMCAL') SH\n /*\nFREE DD(DAALOCIN)\nALLOC DD(DAALOCIN) DSN('SYSM.IOA.V410.PARM(ALCADDCD)')  SHR\nCALL '&LOADLIB(IOALOC)' 'ALLOC'\nSET RCODE = &LASTCC\nFREE DD(DAALOCIN)\nIF &RCODE NE 0 THEN EXIT CODE(&RCODE)\n /*\nOPENFILE DACHK OUTPUT\nSET DACHK=&STR(+\n&DATE2           &DATE1 &DATE1            &DATE1 &DATE1           &DATE1)\nPUTFILE DACHK\nCLOSFILE DACHK\n IF '&CTMSJOB'='1'  THEN GOTO NOJOBNM\nGRPNM:+\nALLOC DD(DAJOBI)   DA('&CTMSLIB(&CTMSMEM)') SH\nIF &LASTCC \u00ac= 0 THEN +\n  DO\n    SET RCODE = &LASTCC\n    WRITE CTMCDAIL:  ALLOCATION ERROR IN DAJOBI\n    WRITE CTMCDAIL:  PLEASE LOGOFF AND LOGON AGAIN\n    WRITENR       HIT ANY KEY TO CONTINUE\n    READ A\n    EXIT CODE(&RCODE)\n  END\nALLOC DD(DAJOB)    NEW  DELETE TRACKS SP(1 3)\nIF &LASTCC \u00ac= 0 THEN +\n  DO\n    SET RCODE = &LASTCC\n    WRITE CTMCDAIL:  ALLOCATION ERROR IN DAJOB\n    WRITE CTMCDAIL:  PLEASE LOGOFF AND LOGON AGAIN\n    WRITENR       HIT ANY KEY TO CONTINUE\n    READ A\n    EXIT CODE(&RCODE)\n  END\n /*  WARNING:   BE VERY CAREFULL WHEN CHANGING THE CLIST !\n /*             CTMTJRQ OVERRIDES CHARACTERISTICS OF THE \"DAJOB\" D.S. !\nCALL '&LOADLIB(CTMTJRQ)' '&CTMSJOB,&CTMGRP'\nGOTO REQJOBS\nNOJOBNM:+\nIF &STR('&CTMGRP') = '1'  THEN GOTO NOGRPNM\nGOTO GRPNM\nNOGRPNM:+\nALLOC DD(DAJOB) DA('&CTMSLIB(&CTMSMEM)') SH\nREQJOBS:+\nIF '&FORCE' NE 'YES'  THEN GOTO NOFORCE\nCALL '&LOADLIB(CTMJOB)' 'FORCE'\nGOTO FREEDD\nNOFORCE:+\nCALL '&LOADLIB(CTMJOB)'\nGOTO FREEDD\nFREEDD:+\nFREE DD(DAJOBI,DAJOB)\nIF '&OLDDACAL' = '' THEN GOTO NODEALL\nIF '&OLDDACAL' = '&CTMCAL' THEN GOTO NODEALL\nFREE DD(DACAL)\nALLOC DD(DACAL) DA('&OLDDACAL')\nNODEALL:+\nEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CTMCFAST": {"ttr": 5638, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x10_\\x00\\x94\\x10_\\x04\\x10\\x01V\\x01V\\x00\\x00\\xc9\\xd6\\xc1\\xf4\\xf1\\xf0@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-04-15T00:00:00", "modifydate": "1994-04-15T04:10:00", "lines": 342, "newlines": 342, "modlines": 0, "user": "IOA410"}, "text": "PROC 0 DATEFMT(USA) DEBUG\n/*******************************************************/\n/**  P.P.F. - PARAMETERS PROMPTING FACILITY - TYPE1   **/\n/**                                                   **/\n/**  THE CLIST DISPLAYS A SCREEN THAT GETS THE NAME   **/\n/**  OF THE TABLE TO WORK ON.                         **/\n/**  THE PARAMETERS VALUES WILL BE UPDATED IN THIS    **/\n/**  TABLE.                                           **/\n/**                                                   **/\n/**  CALLED BY THE PROGRAM : CTMTPPF.                 **/\n/**                                                   **/\n/*******************************************************/\n ISPEXEC CONTROL ERRORS RETURN\n IF &DEBUG = DEBUG +\n THEN +\n    CONTROL LIST MSG CONLIST SYMLIST\n ELSE +\n    CONTROL NOLIST NOMSG\n SET &T = T\n SET &M = M\n ISPEXEC VGET ( ZDAY ZMONTH ) SHARED\n ISPEXEC VPUT (DATEFMT) SHARED\n SET &DD = &STR(&ZDAY)\n SET &MM = &STR(&ZMONTH)\n SET &DDMM = &STR(&ZDAY.&ZMONTH)\n SET &PFK3 = ' '\n ISPEXEC VPUT (DDMM) SHARED\n ISPEXEC TBOPEN PROMPTB NOWRITE\n SET &RC = &LASTCC\n IF &RC \u00ac= 0  -\n THEN -\n    IF &RC = 8 -\n    THEN +\n       DO\n         SET &PFK3 = PFK3\n         ISPEXEC SETMSG MSG(CTMP005B)\n         GOTO END\n       END\n    ELSE +\n       DO\n         SET &PFK3 = PFK3\n         ISPEXEC SETMSG MSG(CTMP000Z)\n         GOTO END\n       END\nDISP0: +\n ISPEXEC TBTOP PROMPTB\n ISPEXEC TBSORT PROMPTB FIELDS(TBNAME)\nDISP01: +\n ISPEXEC TBVCLEAR PROMPTB\n SET &TBNAME = &STR(&PREFIX.&STR(*))\n ISPEXEC TBSARG PROMPTB\n SET &RC = &LASTCC\n IF &RC = 0 -\n THEN -\n    GOTO REDISP\n ELSE -\n    DO\n      SET &SPFRC = &RC\n      ISPEXEC SETMSG MSG(CTMP004F)\n      GOTO REDISP\n    END\n /* SET QCRP = 0\n SET CURNAME = TCMD\nREDISP: +\n IF &DATEFMT = JPN -\n THEN -\n    DO\n       ISPEXEC TBDISPL PROMPTB PANEL(CTMPP05J)\n    END\n ELSE -\n    IF &DATEFMT = USA -\n    THEN -\n       DO\n          ISPEXEC TBDISPL PROMPTB PANEL(CTMPP05A)\n       END\n    ELSE -\n       DO\n          ISPEXEC TBDISPL PROMPTB PANEL(CTMPP05W)\n       END\n SET &RC = &LASTCC\n IF &RC \u00ac= 0 -\n THEN -\n    IF &RC \u00ac= 8 -\n    THEN -\n       DO\n          SET &PFK3 = PFK3\n          ISPEXEC SETMSG MSG(CTMP000Z)\n          GOTO END\n       END\n    ELSE -\n       DO\n          SET &PFK3 = PFK3\n          GOTO END\n       END\n IF &LENGTH(&TCMD) > 2 -\n THEN -\n    DO\n      SET &CMDPREF = &SUBSTR(1:2,&TCMD)\n      IF &CMDPREF = L OR &CMDPREF = l -\n      THEN -\n         DO\n            SET &LOCARG = &SUBSTR(3:&LENGTH(&TCMD),&TCMD)\n            SET &LOCARG = &STR(&LOCARG.&STR(*))\n            SET &TBNAME = &STR(&LOCARG)\n            ISPEXEC TBSCAN PROMPTB ARGLIST(TBNAME) NOREAD\n            SET &RC = &LASTCC\n            IF &RC = 0 -\n            THEN +\n               GOTO REDISP\n            ELSE +\n               IF &RC = 8 +\n               THEN +\n                  DO\n                    ISPEXEC SETMSG MSG(CTMP004C)\n                    GOTO REDISP\n                  END\n               ELSE +\n                  DO\n                    ISPEXEC SETMSG MSG(CTMP000Z)\n                    GOTO REDISP\n                  END\n         END\n      ELSE -\n         DO\n           ISPEXEC SETMSG MSG(CTMP004O)\n           GOTO REDISP\n         END\n    END\n ELSE -\n    IF &TCMD \u00ac= &STR() -\n    THEN -\n       DO\n          ISPEXEC SETMSG MSG(CTMP004O)\n           GOTO REDISP\n       END\n IF &LASTPREF \u00ac= &PREFIX +\n THEN +\n    DO\n       SET &LASTPREF = &STR(&PREFIX)\n       GOTO DISP01\n    END\n IF &ZTDSELS = 0 -\n THEN +\n    GOTO REDISP\n IF &SRCMM = &STR() -\n THEN -\n    DO\n       SET &SRCDD = &DD\n       SET &SRCMM = &MM\n    END\n IF &DATEFMT = JPN -\n THEN -\n    SET &SRCDATE = &STR(&SRCMM.&SRCDD)\n ELSE -\n    IF &DATEFMT = USA -\n    THEN -\n       SET &SRCDATE = &STR(&SRCMM.&SRCDD)\n    ELSE -\n       SET &SRCDATE = &STR(&SRCDD.&SRCMM)\n AFDISP: +\n SET &TABNAME = &STR(&TBNAME.&T.&SRCDATE)\n SET &CALCMEM = &STR(&TBNAME.&M.&SRCDATE)\n SET &TOMEM = &TABNAME\n SET &CONDATE = &STR(&SRCDATE)\n SET &FROMMEM = &STR(&TBNAME.TMSTR)\n SET &TBPREF = &TBNAME\n ISPEXEC VPUT ( TBPREF MANULIB ) PROFILE\n ISPEXEC VPUT ( TBNAME MANULIB TABNAME CALCMEM CONDATE TBPREF) -\n           SHARED\n IF &MANULIB = &STR() -\n THEN -\n    DO\n      SET &TBLIB = &STR(ISPTLIB)\n      ISPEXEC LMINIT DATAID(TOID) DDNAME(&TBLIB) ENQ(SHR)\n      SET &RC = &LASTCC\n      IF &RC \u00ac= 0  -\n      THEN -\n      DO\n         ISPEXEC SETMSG MSG(CTMP000Z)\n         GOTO REDISP\n      END\n    END\n ELSE -\n    DO\n      SET &TBLIB = &MANULIB\n      ISPEXEC LMINIT DATAID(TOID) DATASET('&MANULIB') ENQ(SHR)\n      SET &RC = &LASTCC\n      IF &RC \u00ac= 0  -\n      THEN -\n      DO\n         ISPEXEC SETMSG MSG(CTMP000Z)\n         GOTO REDISP\n      END\n    END\n ISPEXEC LMOPEN DATAID(&TOID) OPTION(INPUT)\n SET &RC = &LASTCC\n IF &RC \u00ac= 0  -\n THEN -\n    DO\n      ISPEXEC SETMSG MSG(CTMP000Z)\n      GOTO REDISP\n    END\n ISPEXEC LMMFIND DATAID(&TOID) MEMBER(&TABNAME)\n SET &RC = &LASTCC\n IF &RC \u00ac= 0  -\n THEN -\n    IF &RC > 8   -\n    THEN -\n       DO\n          ISPEXEC SETMSG MSG(CTMP000Z)\n          GOTO REDISP\n       END\n    ELSE -\n       DO\n          /* COPY HERE  */\n\n          ISPEXEC LMCLOSE DATAID(&TOID)\n          IF &MANULIB = &STR() -\n          THEN -\n             DO\n               SET &TBLIB = &STR(ISPTLIB)\n            ISPEXEC LMINIT DATAID(FROMID) DDNAME(&TBLIB) ENQ(SHR)\n               SET &RC = &LASTCC\n               IF &RC \u00ac= 0  -\n               THEN -\n               DO\n                  ISPEXEC SETMSG MSG(CTMP000Z)\n                  GOTO REDISP\n               END\n             END\n          ELSE -\n            DO\n             SET &TBLIB = &MANULIB\n        ISPEXEC LMINIT DATAID(FROMID) DATASET('&MANULIB') ENQ(SHR)\n             SET &RC = &LASTCC\n             IF &RC \u00ac= 0  -\n             THEN -\n               DO\n                  ISPEXEC SETMSG MSG(CTMP000Z)\n                  GOTO REDISP\n               END\n             END\n          ISPEXEC LMOPEN DATAID(&FROMID) OPTION(INPUT)\n          SET &RC = &LASTCC\n          IF &RC \u00ac= 0  -\n          THEN -\n          DO\n             ISPEXEC SETMSG MSG(CTMP000Z)\n             GOTO REDISP\n          END\n          ISPEXEC LMMFIND DATAID(&FROMID) MEMBER(&FROMMEM)\n          SET &RC = &LASTCC\n          IF &RC \u00ac= 0  -\n          THEN -\n             IF &RC > 8   -\n             THEN -\n                DO\n                   ISPEXEC SETMSG MSG(CTMP000Z)\n                   GOTO REDISP\n                END\n             ELSE -\n                DO\n                   ISPEXEC SETMSG MSG(CTMP002A)\n                   GOTO REDISP\n                END\n           ISPEXEC LMCOPY FROMID(&FROMID) TODATAID(&TOID) -\n                   FROMMEM(&FROMMEM) TOMEM(&TOMEM)\n           SET &RC = &LASTCC\n           IF &RC \u00ac= 0  -\n           THEN -\n              IF &RC > 8   -\n              THEN -\n                 DO\n                    ISPEXEC SETMSG MSG(CTMP000Z)\n                    GOTO REDISP\n                 END\n              ELSE -\n                 DO\n                    ISPEXEC SETMSG MSG(CTMP002F)\n                    GOTO REDISP\n                 END\n      /*  ISPEXEC SETMSG MSG(CTMP003B)\n      /*  GOTO REDISP\n       END\n IF &MANULIB \u00ac= &STR() -\n THEN   -\n    DO\n        SET &IND = 1\n INITRY: SET &TBFILE = &STR(TBFILE&IND)\n       ISPEXEC LMINIT DATAID(TRYID) DDNAME (&TBFILE) ENQ(SHR)\n       SET &RC = &LASTCC\n       IF &RC = 0 -\n       THEN -\n          DO\n            ISPEXEC LMFREE (&TRYID)\n            SET &DSNTRY = DSNTRY&IND\n            SET &DSNTR  = &&DSNTRY&IND\n            ISPEXEC VGET ( &DSNTRY ) SHARED\n            SET DSNTT = &SYSNSUB(2,&DSNTR)\n            IF &DSNTT = &MANULIB -\n            THEN -\n               GOTO CONT\n            ELSE -\n               DO\n                 SET &IND = &IND + 1\n                 GOTO INITRY\n               END\n          END\n       IF &IND > 99 -\n       THEN -\n          SET &IND = 1\n       SET &TBFILE = &STR(TBFILE&IND)\n       SET &DSNTRY = DSNTRY&IND\n       SET &&DSNTRY = &MANULIB\n       ISPEXEC VPUT (&DSNTRY) SHARED\n       FREE FILE(&TBFILE)\n       ALLOC FILE(&TBFILE) DA('&MANULIB') SHR\n       SET &RC = &LASTCC\n       IF &RC \u00ac= 0 -\n       THEN -\n          DO\n              SET &DDERR = &TBFILE\n              SET &DSNERR = &MANULIB\n              ISPEXEC SETMSG MSG(CTMP004L)\n              GOTO END\n          END\n CONT: +\n       SET &TBDD = &STR(&TBFILE)\n       SET &TBLIB = &STR(&MANULIB)\n    END\n IF &MANULIB = &STR() -\n THEN   -\n    DO\n      SET &TBDD = &STR(ISPTABL)\n      SET &TBLIB = &STR(ISPTABL)\n    END\n ISPEXEC VPUT (TABNAME TBFILE) SHARED\nEND: +\n ISPEXEC VPUT (TBLIB PFK3) SHARED\n ISPEXEC TBCLOSE PROMPTB\n ISPEXEC LMFREE DATAID(&TOID)\n ISPEXEC LMFREE DATAID(&FROMID)\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CTMCFMNU": {"ttr": 5644, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x10_\\x00\\x94\\x10_\\x04\\x10\\x00\\x18\\x00\\x18\\x00\\x00\\xc9\\xd6\\xc1\\xf4\\xf1\\xf0@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-04-15T00:00:00", "modifydate": "1994-04-15T04:10:00", "lines": 24, "newlines": 24, "modlines": 0, "user": "IOA410"}, "text": "PROC 0 DBPREFA(SYSS.IOA) DBVERA(V410) DATEFMT(USA) DEBUG\n/*******************************************************/\n/**  P.P.F. - PARAMETERS PROMPTING FACILITY - TYPE1   **/\n/**                                                   **/\n/**  THE CLIST DISPLAYS THE PRIMARY OPTIONS MENU.     **/\n/**                                                   **/\n/*******************************************************/\n IF &DEBUG = DEBUG +\n THEN +\n    CONTROL LIST MSG CONLIST SYMLIST\n ELSE +\n    CONTROL NOLIST NOMSG\n SET &CTMLIB = &STR(&DBPREFA..&DBVERA)\n ISPEXEC VPUT (CTMLIB) SHARED\n ISPEXEC VPUT (DATEFMT) SHARED\n ISPEXEC VGET (PTRAIL) SHARED\n IF &PTRAIL NE 1 AND &PTRAIL NE 2 AND &PTRAIL NE &STR() +\n THEN +\n    DO\n     SET PTRAIL =\n     ISPEXEC SETMSG MSG(ISPD241)\n    END\n ISPEXEC SELECT PANEL(CTMPP00W) OPT(&PTRAIL)\n EXIT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CTMCFMST": {"ttr": 5646, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x10_\\x00\\x94\\x10_\\x04\\x10\\x00\\xfd\\x00\\xfd\\x00\\x00\\xc9\\xd6\\xc1\\xf4\\xf1\\xf0@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-04-15T00:00:00", "modifydate": "1994-04-15T04:10:00", "lines": 253, "newlines": 253, "modlines": 0, "user": "IOA410"}, "text": "PROC 0 OLPREFM(SYSS.CTMO) OLVERM(V410) DATEFMT(USA) DEBUG\n/*******************************************************/\n/**  P.P.F. - PARAMETERS PROMPTING FACILITY - TYPE1   **/\n/**                                                   **/\n/**  THE CLIST DISPLAYS A SCREEN THAT GETS THE NAME   **/\n/**  OF A MASTER TABLE THAT WILL BE CREATED.          **/\n/**                                                   **/\n/*******************************************************/\n ISPEXEC CONTROL ERRORS RETURN\n IF &DEBUG = DEBUG +\n THEN +\n    CONTROL LIST MSG CONLIST SYMLIST\n ELSE +\n    CONTROL NOLIST NOMSG\n ISPEXEC VGET ( TBPREF ) PROFILE\n ISPEXEC VGET ( MANULIB ) PROFILE\n SET &RC = &LASTCC\n IF &RC = 8  -\n THEN -\n    SET &MANULIB = &STR(&OLPREFM..&OLVERM..PROMPT)\n SET &CREATED = NO\n ISPEXEC VGET (ZUSER) SHARED\n REDISP: -\n ISPEXEC DISPLAY PANEL(CTMPP01W)\n SET &RC = &LASTCC\n IF &RC \u00ac= 0  -\n THEN -\n    IF &RC \u00ac= 8  -\n    THEN -\n        DO\n          ISPEXEC SETMSG MSG(CTMP000Z)\n          GOTO END\n        END\n    ELSE -\n       GOTO END\n IF &MANULIB \u00ac= &STR() AND &MANULIB \u00ac= &STR( )        -\n THEN -\n    DO\n        SET &IND = 1\n INITRY: SET &TBFILE = &STR(TBFILE&IND)\n       ISPEXEC LMINIT DATAID(TRYID) DDNAME (&TBFILE) ENQ(SHR)\n       SET &RC = &LASTCC\n       IF &RC = 0 -\n       THEN -\n          DO\n            ISPEXEC LMFREE (&TRYID)\n            SET &DSNTRY = DSNTRY&IND\n            SET &DSNTR  = &&DSNTRY&IND\n            ISPEXEC VGET ( &DSNTRY ) SHARED\n            SET DSNTT = &SYSNSUB(2,&DSNTR)\n            IF &DSNTT = &MANULIB -\n            THEN -\n               GOTO CONT\n            ELSE -\n               DO\n                 SET &IND = &IND + 1\n                 GOTO INITRY\n               END\n          END\n       IF &IND > 99 -\n       THEN -\n          SET &IND = 1\n       SET &TBFILE = &STR(TBFILE&IND)\n       SET &DSNTRY = DSNTRY&IND\n       SET &&DSNTRY = &MANULIB\n       ISPEXEC VPUT (&DSNTRY) SHARED\n       FREE FILE(&TBFILE)\n       ALLOC FILE(&TBFILE) DA('&MANULIB') SHR\n       SET &RC = &LASTCC\n       IF &RC \u00ac= 0 -\n       THEN -\n          DO\n              SET &DDERR = &TBFILE\n              SET &DSNERR = &MANULIB\n              ISPEXEC SETMSG MSG(CTMP004L)\n              GOTO END\n          END\n CONT: SET &TBDD = &STR(&TBFILE)\n       SET &TBLIB = &STR(&MANULIB)\n    END\n IF &MANULIB = &STR() OR &MANULIB =&STR( ) -\n THEN   -\n    DO\n       SET &TBDD = &STR(ISPTABL)\n       SET &TBLIB = &STR(ISPTABL)\n    END\n SET &MANUMSNM = &STR(&TBPREF.&STR(TMSTR) )\n ISPEXEC TBCREATE &MANUMSNM +\n         NAMES(CONDNAME PARMIN PARMOUT DESC UPDATEDD +\n           UPDATEMM INDIC ) WRITE LIBRARY(&TBDD)\n SET &RC=&LASTCC\n IF &RC = 8 -\n THEN -\n    DO\n   /* ISPEXEC SETMSG MSG(CTMP001C) */\n      SET &TBNAME =  &MANUMSNM\n      ISPEXEC SETMSG MSG(CTMP001F)\n      GOTO REDISP\n    END\n IF &RC > 8 -\n THEN    -\n    DO\n      ISPEXEC SETMSG MSG(CTMP000Z)\n      GOTO REDISP\n    END\n ISPEXEC TBVCLEAR &MANUMSNM\n ISPEXEC TBADD  &MANUMSNM\n SET &RC = &LASTCC\n IF &RC \u00ac= 0 -\n THEN    -\n    DO\n      ISPEXEC TBEND  &MANUMSNM\n      ISPEXEC SETMSG MSG(CTMP001A)\n      GOTO REDISP\n    END\n ELSE    -\n    DO\n      SET &TBNAME =  &MANUMSNM\n      ISPEXEC SETMSG MSG(CTMP001B)\n  /* NEW PART\n  /*  CONTROL LIST MSG SYMLIST CONLIST\n      GOTO OPNTB\n      ISPEXEC LMINIT DATAID(FROMID) DDNAME(ISPTLIB) ENQ(SHR)\n      SET &RC = &LASTCC\n      IF &RC \u00ac= 0  -\n      THEN -\n         DO\n           ISPEXEC TBEND  &MANUMSNM\n           ISPEXEC SETMSG MSG(CTMP000Z)\n           GOTO REDISP\n         END\n      ISPEXEC LMOPEN DATAID(&FROMID) OPTION(INPUT)\n      SET &RC = &LASTCC\n      IF &RC \u00ac= 0  -\n      THEN -\n         DO\n            ISPEXEC TBEND  &MANUMSNM\n            ISPEXEC SETMSG MSG(CTMP000Z)\n            GOTO REDISP\n         END\n      ISPEXEC LMMFIND DATAID(&FROMID) MEMBER(PROMPTB)\n      SET &RC = &LASTCC\n      IF &RC \u00ac= 0  -\n      THEN -\n         IF &RC > 8   -\n         THEN -\n            DO\n               ISPEXEC TBEND  &MANUMSNM\n               ISPEXEC SETMSG MSG(CTMP000Z)\n               GOTO REDISP\n            END\n         ELSE -\n            DO\n               ISPEXEC TBCREATE PROMPTB KEYS(TBNAME) -\n                  NAMES(USERID MANULIB DESCRIPT) +                      D +\n                  WRITE\n               SET &RC=&LASTCC\n               IF &RC > 8 -\n               THEN    -\n                  DO\n                    ISPEXEC TBEND  &MANUMSNM\n                    ISPEXEC SETMSG MSG(CTMP000Z)\n                    GOTO REDISP\n                  END\n            END\n      ELSE -\n         DO\n     OPNTB: ISPEXEC TBOPEN PROMPTB WRITE\n            SET &RETC = &LASTCC\n            IF &RETC GT 0 -\n            THEN -\n               IF &RETC > 12 -\n               THEN -\n                  DO\n                    ISPEXEC TBEND  &MANUMSNM\n                    ISPEXEC SETMSG MSG (CTMP000Z)\n                    GOTO END\n                  END\n               ELSE -\n                  IF &RETC = 8 -\n                  THEN -\n                     DO\n                        /* TRY TO CREATE IT NOW */\n                       ISPEXEC TBCREATE PROMPTB KEYS(TBNAME) +\n                          NAMES(USERID MANULIB DESCRIPT) +\n                          WRITE\n                       SET &RC=&LASTCC\n                       IF &RC > 8 -\n                       THEN    -\n                          DO\n                            ISPEXEC TBEND  &MANUMSNM\n                            ISPEXEC SETMSG MSG(CTMP000Z)\n                            GOTO REDISP\n                          END\n                     END\n                  ELSE -\n                     DO\n                       ISPEXEC TBEND  &MANUMSNM\n                       ISPEXEC SETMSG MSG (CTMP001E)\n                       GOTO REDISP\n                     END\n         END\n      SET &TBNAME = &TBPREF\n      SET &USERID = &ZUSER\n      ISPEXEC TBADD  PROMPTB\n      SET &RETC = &LASTCC\n      IF &RETC GT 0 -\n      THEN -\n         IF &RETC = 8 -\n         THEN -\n            DO\n              ISPEXEC TBEND  &MANUMSNM\n              ISPEXEC TBEND  PROMPTB\n              ISPEXEC SETMSG MSG (CTMP001F)\n              GOTO REDISP\n            END\n         ELSE -\n            DO\n              ISPEXEC TBEND  &MANUMSNM\n              ISPEXEC TBEND  PROMPTB\n              ISPEXEC SETMSG MSG (CTMP001E)\n              GOTO REDISP\n            END\n      ISPEXEC TBCLOSE  PROMPTB\n      SET &RETC = &LASTCC\n      IF &RETC GT 0 -\n      THEN -\n         IF &RETC > 12 -\n         THEN -\n            DO\n              ISPEXEC TBEND  &MANUMSNM\n              ISPEXEC TBEND  PROMPTB\n              ISPEXEC SETMSG MSG (CTMP000Z)\n              GOTO REDISP\n            END\n         ELSE -\n            DO\n              ISPEXEC TBEND  &MANUMSNM\n              ISPEXEC TBEND  PROMPTB\n              ISPEXEC SETMSG MSG (CTMP001E)\n              GOTO REDISP\n            END\n      ELSE -\n         DO\n             SET &CREATED = YES\n             SET &TABNAME = &MANUMSNM\n             ISPEXEC TBCLOSE  &MANUMSNM LIBRARY(&TBDD)\n         END\n      GOTO END\n    END\n END: ISPEXEC VPUT (MANULIB TBPREF ) PROFILE\n      ISPEXEC VPUT ( TBNAME TBLIB CREATED TABNAME ) SHARED\n      ISPEXEC LMFREE DATAID(&FROMID)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CTMCFUPT": {"ttr": 5893, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x10_\\x00\\x94\\x10_\\x04\\x10\\x01\\xc6\\x01\\xc6\\x00\\x00\\xc9\\xd6\\xc1\\xf4\\xf1\\xf0@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-04-15T00:00:00", "modifydate": "1994-04-15T04:10:00", "lines": 454, "newlines": 454, "modlines": 0, "user": "IOA410"}, "text": "PROC 0 OLPREFM(SYSS.CTMO) OLVERM(V410) DEBUG +\n       PROMPT(PROMPT)\n/*******************************************************/\n/**  P.P.F. - PARAMETERS PROMPTING FACILITY - TYPE1   **/\n/**                                                   **/\n/**  THE CLIST DISPLAYS A SCREEN THAT GETS THE NAME   **/\n/**  OF THE TABLE TO WORK ON.                         **/\n/**  THE TABLE IS DISPLAYED SO CONDITIONS AND         **/\n/**  PARAMETERS ARE DECLARED TO IT.                   **/\n/**                                                   **/\n/*******************************************************/\n ISPEXEC CONTROL ERRORS RETURN\n IF &DEBUG = DEBUG +\n THEN +\n    CONTROL LIST MSG CONLIST SYMLIST NOCAPS\n ELSE +\n    CONTROL NOLIST NOMSG NOCAPS\n SET &T = T\n ISPEXEC VGET ( TBPREF ) PROFILE\n ISPEXEC VGET ( MANULIB ) PROFILE\n SET &RC = &LASTCC\n IF &RC = 8  -\n THEN -\n    SET &MANULIB = &STR(&OLPREFM..&OLVERM..&PROMPT)\n REDISP: +\n SET &CHGIND = 0\n ISPEXEC DISPLAY PANEL(CTMPP03W)\n SET &RC = &LASTCC\n IF &RC \u00ac= 0 -\n THEN -\n    IF &RC \u00ac= 8 -\n    THEN -\n       DO\n          ISPEXEC SETMSG MSG(CTMP000Z)\n          GOTO END\n       END\n    ELSE -\n       GOTO END\n IF &TBPREF \u00ac= &STR() -\n THEN -\n    DO\n      SET &ISMSTR = 1\n      SET &TABNAME  = &STR(&TBPREF.&STR(TMSTR))\n    END\n ELSE -\n    DO\n      ISPEXEC SETMSG MSG(CTMP003A)\n      GOTO REDISP\n    END\n\n IF &MANULIB = &STR() -\n THEN -\n    DO\n      SET &TBLIB = &STR(ISPTLIB)\n      ISPEXEC LMINIT DATAID(FROMID) DDNAME(&TBLIB) ENQ(SHR)\n      SET &RC = &LASTCC\n      IF &RC \u00ac= 0  -\n      THEN -\n         DO\n           ISPEXEC SETMSG MSG(CTMP000Z)\n           GOTO REDISP\n         END\n    END\n ELSE -\n    DO\n      SET &TBLIB = &MANULIB\n      ISPEXEC LMINIT DATAID(FROMID) DATASET('&MANULIB') ENQ(SHR)\n      SET &RC = &LASTCC\n      IF &RC \u00ac= 0  -\n      THEN -\n         DO\n           ISPEXEC SETMSG MSG(CTMP000Z)\n           GOTO REDISP\n         END\n    END\n ISPEXEC LMOPEN DATAID(&FROMID) OPTION(INPUT)\n SET &RC = &LASTCC\n IF &RC \u00ac= 0  -\n THEN -\n    DO\n      ISPEXEC SETMSG MSG(CTMP000Z)\n      GOTO REDISP\n END\n ISPEXEC LMMFIND DATAID(&FROMID) MEMBER(&TABNAME)\n SET &RC = &LASTCC\n IF &RC \u00ac= 0  -\n THEN -\n    IF &RC > 8   -\n    THEN -\n       DO\n          ISPEXEC SETMSG MSG(CTMP000Z)\n          GOTO REDISP\n       END\n    ELSE -\n       DO\n          IF &ISMSTR = 1 -\n          THEN +\n             DO\n               /* MSG TO CREATE A NEW MASTER TABLE */\n                ISPEXEC SETMSG MSG(CTMP003J)\n                ISPEXEC VPUT (MANULIB TBPREF)\n                %CTMCFMST\n                ISPEXEC VGET (CREATED TABNAME MANULIB TBPREF)\n                IF &CREATED \u00ac= YES -\n                THEN +\n                   DO\n                      ISPEXEC LMFREE DATAID(&FROMID)\n                      GOTO REDISP\n                   END\n             END\n          ELSE +\n             DO\n                ISPEXEC SETMSG MSG(CTMP003B)\n                GOTO REDISP\n             END\n       END\n IF &MANULIB \u00ac= &STR() -\n THEN   -\n    DO\n        SET &IND = 1\n INITRY: SET &TBFILE = &STR(TBFILE&IND)\n       ISPEXEC LMINIT DATAID(TRYID) DDNAME (&TBFILE) ENQ(SHR)\n       SET &RC = &LASTCC\n       IF &RC = 0 -\n       THEN -\n          DO\n            ISPEXEC LMFREE (&TRYID)\n            SET &DSNTRY = DSNTRY&IND\n            SET &DSNTR  = &&DSNTRY&IND\n            ISPEXEC VGET ( &DSNTRY ) SHARED\n            SET DSNTT = &SYSNSUB(2,&DSNTR)\n            IF &DSNTT = &MANULIB -\n            THEN -\n               GOTO CONT\n            ELSE -\n               DO\n                 SET &IND = &IND + 1\n                 GOTO INITRY\n               END\n          END\n       IF &IND > 99 -\n       THEN -\n          SET &IND = 1\n       SET &TBFILE = &STR(TBFILE&IND)\n       SET &DSNTRY = DSNTRY&IND\n       SET &&DSNTRY = &MANULIB\n       ISPEXEC VPUT (&DSNTRY) SHARED\n       FREE FILE(&TBFILE)\n       ALLOC FILE(&TBFILE) DA('&MANULIB') SHR\n       SET &RC = &LASTCC\n       IF &RC \u00ac= 0 -\n       THEN -\n          DO\n              SET &DDERR = &TBFILE\n              SET &DSNERR = &MANULIB\n              ISPEXEC SETMSG MSG(CTMP004L)\n              GOTO END\n          END\n CONT: SET &TBDD = &STR(&TBFILE)\n       SET &TBLIB = &STR(&MANULIB)\n    END\n IF &MANULIB = &STR() -\n THEN   -\n    DO\n      SET &TBDD = &STR(ISPTABL)\n      SET &TBLIB = &STR(ISPTABL)\n    END\n\n ISPEXEC VGET (ZUSER)\n SET TMPMANU = &STR(&ZUSER.&STR(TMP))\n IF &LENGTH(&TMPMANU) > 8 -\n THEN -\n    SET &TMPMANU = &SUBSTR(1:8,&TMPMANU)\n ISPEXEC TBEND &TMPMANU\n ISPEXEC TBCREATE &TMPMANU +\n        NAMES (CONDNAME PARMIN PARMOUT DESC UPDATEDD +\n           UPDATEMM INDIC ) WRITE REPLACE\n SET RC=&LASTCC\n IF &RC GT 4 -\n THEN -\n    IF &RC > 12 -\n    THEN -\n       DO\n         ISPEXEC SETMSG MSG(CTMP000Z)\n         GOTO END\n       END\n    ELSE -\n       DO\n         ISPEXEC SETMSG MSG(CTMP003I)\n         GOTO END\n       END\n ISPEXEC TBOPEN &TABNAME WRITE LIBRARY(&TBFILE)\n SET &RETC = &LASTCC\n IF &RETC GT 0 -\n THEN -\n    IF &RETC > 12 -\n    THEN -\n       DO\n         ISPEXEC SETMSG MSG (CTMP000Z)\n         GOTO END\n       END\n    ELSE -\n       DO\n         ISPEXEC SETMSG MSG (CTMP003I)\n         GOTO END\n       END\nLOOPSKIP: +\n ISPEXEC TBSKIP &TABNAME\n IF &LASTCC = 8 -\n THEN -\n    GOTO DISP0\n ISPEXEC TBADD &TMPMANU\n GOTO LOOPSKIP\nDISP0: +\n ISPEXEC TBTOP &TMPMANU\nDISP01: +\n ISPEXEC TBVCLEAR &TMPMANU\n SET &PARMIN = &STR(&PREFIX.&STR(*))\n ISPEXEC TBSARG &TMPMANU\n SET &RC = &LASTCC\n IF &RC = 0 -\n THEN +\n    GOTO DISPPAN1\n ELSE +\n    DO\n      SET &SPFRC = &RC\n      ISPEXEC SETMSG MSG(CTMP004F)\n      GOTO DISPPAN1\n    END\n /* SET QCRP = 0\n SET CURNAME = TCMD\nDISPPAN1: +\n ISPEXEC TBDISPL &TMPMANU PANEL(CTMPP31W)\n SET RC = &LASTCC\nCANC0: +\n IF &TCMD = CANCEL OR &TCMD =cancel +\n THEN +\n    GOTO ENDCAN\n IF &RC GT 8 -\n THEN -\n    DO\n       ISPEXEC SETMSG MSG(CTMP000Z)\n       GOTO END\n    END\nED2: +\n SET RC1 = &RC\n SET QCRP = 0\n SET CURNAME = TCMD\n IF &TSEL NE D AND &TSEL NE I AND &TSEL NE A AND +\n           &TSEL NE R AND &TSEL NE &STR( ) AND +\n    &TSEL NE d AND &TSEL NE i AND &TSEL NE a AND +\n           &TSEL NE r                          +\n THEN -\n    DO\n       ISPEXEC SETMSG MSG(CTMP003C)\n       GOTO ED4\n    END\n IF &TSEL = D OR &TSEL = d -\n THEN -\n    DO\n       SET &CHGIND = 1                             /* WM1382 */\n       ISPEXEC TBDELETE &TMPMANU\n       GOTO ED4\n    END\n IF &TSEL = A OR &TSEL = R OR &TSEL = a OR &TSEL = r -\n THEN -\n    DO\n       SET &CHGIND = 1                         /* WM1382 */\n       ISPEXEC TBPUT &TMPMANU\n       IF &LASTCC GT 8 -\n       THEN -\n          DO\n             SET &RETC = &LASTCC\n             ISPEXEC SETMSG MSG(CTMP003E)\n             GOTO DISPPAN1\n          END\n       SET UPDATEDD =\n       SET UPDATEMM =\n       ISPEXEC TBADD &TMPMANU\n       IF &LASTCC GT 0 -\n       THEN -\n          DO\n             SET &RETC = &LASTCC\n             ISPEXEC SETMSG MSG(CTMP003D)\n             GOTO DISPPAN1\n          END\n       GOTO ED4\n    END\n IF &TSEL = I OR &TSEL = i -\n THEN -\n    DO\n       SET &CHGIND = 1                       /* WM1382 */\n       ISPEXEC TBPUT &TMPMANU\n       IF &LASTCC GT 8 -\n       THEN -\n          DO\n             SET &RETC = &LASTCC\n             ISPEXEC SETMSG MSG(CTMP003E)\n             GOTO DISPPAN1\n          END\n       ISPEXEC TBVCLEAR &TMPMANU\n       SET &DAILYM = Y\n       ISPEXEC TBQUERY &TMPMANU POSITION(QCRP)\n       ISPEXEC TBADD &TMPMANU\n       IF &LASTCC GT 0 -\n       THEN -\n          DO\n             SET &RETC = &LASTCC\n             ISPEXEC SETMSG MSG(CTMP003D)\n          END\n       SET QCRP = &QCRP + 1\n       GOTO ED4\n    END\n IF &ZTDSELS = 0 -\n THEN +\n    GOTO CKLINCMD\n IF &TSEL = &STR( ) -\n THEN -\n    DO\n      SET &CHGIND = 1                        /* WM1382 */\n      ISPEXEC TBPUT &TMPMANU\n      IF &LASTCC GT 8 -\n      THEN -\n         DO\n            SET &RETC = &LASTCC\n            ISPEXEC SETMSG MSG(CTMP003E)\n         END\n    END\nED4: +\n IF &RC1 = 4  -\n THEN -\n    DO\n       ISPEXEC TBDISPL &TMPMANU\n       SET RC = &LASTCC\n       GOTO ED2\n    END\n CKLINCMD: +\n IF &TCMD = SAVE OR &TCMD = save +\n THEN +\n    DO\n       ISPEXEC TBEND &TABNAME\nISPEXEC TBCLOSE &TMPMANU NAME(&TABNAME) LIBRARY(&TBFILE) PAD(20)\n       GOTO END\n    END\n IF &RESP = END OR &RC1 = 8 -\n THEN -\n    DO\n  /*   ISPEXEC SETMSG MSG(CTMP003M) */             /* WM1382 */\n  /*   GOTO DISPPAN1  */                             /* WM1382 */\n       IF &CHGIND = 0 +\n       THEN +\n          DO                                         /* WM1382 */\n            SET &TCMD = CANCEL                       /* WM1382 */\n            GOTO CANC0                               /* WM1382 */\n          END                                        /* WM1382 */\n       ELSE +\n       DO                                            /* WM1382 */\n         SAVWND: +\n         ISPEXEC DISPLAY PANEL(CTMPP37W)           /* WM1382 */\n         IF &SV = Y +\n         THEN +\n            DO                                       /* WM1382 */\n              SET &TCMD = SAVE                       /* WM1382 */\n              GOTO CKLINCMD                          /* WM1382 */\n            END                                      /* WM1382 */\n         IF &SV = N +\n         THEN +\n            DO\n              SET &TCMD = CANCEL                     /* WM1382 */\n              GOTO CANC0                             /* WM1382 */\n            END                                      /* WM1382 */\n         ISPEXEC SETMSG MSG(CTMP005C)              /* WM1382 */\n         GOTO SAVWND                                 /* WM1382 */\n       END                                           /* WM1382 */\n    END\n IF &LENGTH(&TCMD) > 2 -\n THEN -\n    DO\n      SET &CMDPREF = &SUBSTR(1:2,&TCMD)\n      IF &CMDPREF = L OR &CMDPREF = l -\n      THEN -\n         DO\n            SET &LOCARG = &SUBSTR(3:&LENGTH(&TCMD),&TCMD)\n            SET &LOCARG = &STR(&LOCARG.&STR(*))\n            SET &PARMIN = &STR(&LOCARG)\n            ISPEXEC TBSCAN &TMPMANU ARGLIST(PARMIN) NOREAD\n            SET &RC = &LASTCC\n            IF &RC = 0 -\n            THEN +\n               GOTO DISPPAN1\n            ELSE +\n               IF &RC = 8 +\n               THEN +\n                  DO\n                    ISPEXEC SETMSG MSG(CTMP004C)\n                    GOTO REPOSTAB\n                  END\n               ELSE +\n                  DO\n                    ISPEXEC SETMSG MSG(CTMP000Z)\n                    GOTO REPOSTAB\n                  END\n         END\n      ELSE -\n         IF &TCMD = INSERT OR &TCMD = insert  -\n         THEN -\n            DO\n               ISPEXEC TBVCLEAR &TMPMANU\n               SET &DAILYM = Y\n               ISPEXEC TBQUERY &TMPMANU POSITION(QCRP)\n               ISPEXEC TBADD &TMPMANU\n               IF &LASTCC GT 0 -\n               THEN -\n                  DO\n                     SET &RETC = &LASTCC\n                     ISPEXEC SETMSG MSG(CTMP003D)\n                  END\n               SET QCRP = &QCRP + 1\n               GOTO DISPPAN1\n            END\n         ELSE +\n            DO\n               ISPEXEC SETMSG MSG(CTMP004O)\n               GOTO DISPPAN1\n            END\n    END\n ELSE -\n    IF &TCMD \u00ac= &STR() -\n    THEN -\n       DO\n         ISPEXEC SETMSG MSG(CTMP004O)\n         GOTO DISPPAN1\n       END\n IF &LASTPREF \u00ac= &PREFIX +\n THEN +\n    DO\n       SET &LASTPREF = &STR(&PREFIX)\n       GOTO DISP0\n    END\nREPOSTAB: +\n ISPEXEC TBTOP &TMPMANU\n ISPEXEC TBSKIP &TMPMANU NUMBER(&ZTDTOP)\n GOTO DISPPAN1\nENDCAN: +\n ISPEXEC TBEND &TABNAME\n ISPEXEC TBEND &TMPMANU\n IF &CHGIND = 0 +\n THEN +\n    GOTO END                                        /* WM1382 */\n ISPEXEC SETMSG MSG(CTMP003F)\nEND: +\n ISPEXEC VPUT (MANULIB TBPREF) PROFILE\n ISPEXEC VPUT (TBNAME TBLIB) SHARED\n ISPEXEC LMFREE DATAID(&FROMID)\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "CTMCJOBS": {"ttr": 6147, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x10_\\x00\\x94\\x10_\\x04\\x10\\x00b\\x00b\\x00\\x00\\xc9\\xd6\\xc1\\xf4\\xf1\\xf0@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-04-15T00:00:00", "modifydate": "1994-04-15T04:10:00", "lines": 98, "newlines": 98, "modlines": 0, "user": "IOA410"}, "text": "PROC 0 DEBUG                             -\n       DATEFMT(USA)                -\n       SCHEDLIB(SYSS.CTMO.V410.SCHEDULE) -\n       CALLIB(SYSS.IOA.V410.CAL)    -\n       TABLE()                           -\n       GROUP()                           -\n       FORCE()                           -\n       JOB()                             -\n       DBPREFA(SYSS.IOA)                  -\n       DBPREFM(SYSS.CTMO)                  -\n       DBVERA(V410)                    -\n       DBVERM(V410)                    -\n       LANG()                      -\n       ODAT()\n /* WM1286 AM 200992 SUPPORT JAPANESE DATE */\nCONTROL MAIN NOLIST NOCONLIST NOSYMLIST NOMSG\nIF &DEBUG=DEBUG THEN CONTROL MAIN LIST CONLIST SYMLIST MSG\nIF .&ODAT = . THEN DO\nSET YY=&SUBSTR(7:8,&SYSDATE)\nSET MM=&SUBSTR(1:2,&SYSDATE)\nSET DD=&SUBSTR(4:5,&SYSDATE)\nGOTO ODATOK\n                   END\nSET &YY=&SUBSTR(5:6,&ODAT)\nIF &DATEFMT=JPN +\n    THEN DO\n            SET &YY=&SUBSTR(1:2,&ODAT)\n            SET &DD=&SUBSTR(5:6,&ODAT)\n            SET &MM=&SUBSTR(3:4,&ODAT)\n         END\n    ELSE +\nIF &DATEFMT=USA +\n    THEN DO\n            SET &DD=&SUBSTR(3:4,&ODAT)\n            SET &MM=&SUBSTR(1:2,&ODAT)\n         END\n    ELSE DO\n            SET &DD=&SUBSTR(1:2,&ODAT)\n            SET &MM=&SUBSTR(3:4,&ODAT)\n         END\nODATOK:+\nSET &NOALC=&STR()\nSET CTMCAL=&STR(&CALLIB)\nSET CTMSLIB=&STR(&SCHEDLIB)\nSET &CTMSMEM=&TABLE\nSET &CTMSJOB=&JOB\nSET &CTMGRP=&GROUP\nSET &FRC=&FORCE\nIF &CTMSJOB=    THEN SET CTMSJOB='1'\nIF &STR('&CTMGRP') =  ''   THEN SET CTMGRP='1'\nSET ZYEAR=&YY\nSET ZMONTH=&MM\nSET ZDAY=&DD\nIF &ZDAY GT 1 THEN DO\n             SET DD=&ZDAY-1\n             SET MM=&ZMONTH\n             END\n      ELSE DO\n          IF &ZMONTH GT 1 THEN  SET MM=&ZMONTH-1\n                 ELSE DO\n                    SET MM=12\n                    SET YY=&ZYEAR-1\n                    END\n          SET DD=31\n          IF &MM=4 OR &MM=6 OR &MM=9 OR &MM=11 THEN SET DD=30\n          IF &MM=2  THEN SET DD=28\n          IF &MM=2 AND (&YY=88 OR &YY=92 OR &YY=96) THEN SET DD=29\n          END\nSET MM=&SUBSTR(2:3,&EVAL(&MM+100))\nSET DD=&SUBSTR(2:3,&EVAL(&DD+100))\nSET ZDAY=&SUBSTR(2:3,&EVAL(&ZDAY+100))\nSET ZMONTH=&SUBSTR(2:3,&EVAL(&ZMONTH+100))\nIF &DATEFMT=JPN THEN +\n     %CTMCDAIL  CTMSLIB(&CTMSLIB) CTMCAL(&CTMCAL) CTMSMEM(&CTMSMEM) +\n           CTMSJOB(&CTMSJOB)   +\n           CTMGRP(&CTMGRP)     +\n           FORCE(&FRC)         +\n           DBPREFA(&DBPREFA) DBVERA(&DBVERA) +\n           DBPREFM(&DBPREFM) DBVERM(&DBVERM) +\n           &DEBUG DATE1(&YY&MM&DD) DATE2(&ZYEAR&ZMONTH&ZDAY) &NOALC\n   ELSE    +\nIF &DATEFMT=USA THEN +\n     %CTMCDAIL  CTMSLIB(&CTMSLIB) CTMCAL(&CTMCAL) CTMSMEM(&CTMSMEM) +\n           CTMSJOB(&CTMSJOB)   +\n           CTMGRP(&CTMGRP)     +\n           FORCE(&FRC)         +\n           DBPREFA(&DBPREFA) DBVERA(&DBVERA) +\n           DBPREFM(&DBPREFM) DBVERM(&DBVERM) +\n           &DEBUG DATE1(&MM&DD&YY) DATE2(&ZMONTH&ZDAY&ZYEAR) &NOALC\n   ELSE    +\n      %CTMCDAIL  CTMSLIB(&CTMSLIB) CTMCAL(&CTMCAL) CTMSMEM(&CTMSMEM) +\n           CTMSJOB(&CTMSJOB)   +\n           CTMGRP(&CTMGRP)     +\n           FORCE(&FRC)         +\n           DBPREFA(&DBPREFA) DBVERA(&DBVERA) +\n           DBPREFM(&DBPREFM) DBVERM(&DBVERM) +\n           &DEBUG DATE1(&DD&MM&YY) DATE2(&ZDAY&ZMONTH&ZYEAR) &NOALC\nEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CTMCJSC": {"ttr": 6150, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x10_\\x00\\x94\\x10_\\x04\\x10\\x00\\x02\\x00\\x02\\x00\\x00\\xc9\\xd6\\xc1\\xf4\\xf1\\xf0@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-04-15T00:00:00", "modifydate": "1994-04-15T04:10:00", "lines": 2, "newlines": 2, "modlines": 0, "user": "IOA410"}, "text": "SET JOBSCAN = YES\nISPEXEC  VPUT  JOBSCAN PROFILE\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CTMCK10": {"ttr": 6152, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x10_\\x00\\x94\\x10_\\x04\\x10\\x017\\x017\\x00\\x00\\xc9\\xd6\\xc1\\xf4\\xf1\\xf0@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-04-15T00:00:00", "modifydate": "1994-04-15T04:10:00", "lines": 311, "newlines": 311, "modlines": 0, "user": "IOA410"}, "text": "PROC 0 DEBUG()\nISPEXEC CONTROL ERRORS CANCEL\nCONTROL MAIN NOLIST NOCONLIST NOSYMLIST NOMSG\nIF &DEBUG=DEBUG THEN CONTROL MAIN LIST CONLIST SYMLIST MSG\nCONTROL ASIS\nSET &ACTION = CANCEL\n\n/********************************************************/\n/**                                                    **/\n/**    CONTROL-M QUICK SCHEDULE DEFINITION             **/\n/**                                                    **/\n/**    CLIST CTMCK10                                   **/\n/**                                                    **/\n/**    THIS IS THE FIRST PANEL FOR THE USER            **/\n/**                                                    **/\n/**    GET LIBRARY, TABLE NAME AND GROUP NAME          **/\n/**                                                    **/\n/**                                                    **/\n/********************************************************/\n\nSET &SCHEDTB =\nSET &GRP =\nSET &SF  =\nSET &ENDED = 0\nSET &OLDMEM = N     /* NO OLD VERSION OF TABLE */\n\nISPEXEC VGET (ZAPPLID)\nIF &ZAPPLID = CTMU THEN +\n         ISPEXEC VGET (CTMPKLIB  CTMPKSKL USOURCE) PROFILE\n  ELSE   ISPEXEC VGET (CTMPKLIB  CTMPKSKL USOURCE)\nSET &LIB = &CTMPKLIB\nSET &SKELMEM =&CTMPKSKL\nIF Z&USOURCE=Z THEN SET &USOURCE=T\n\n/********************************************************/\n/**                                                    **/\n/**    MAIN LOOP - DISPLAY PANEL AND GET INPUT         **/\n/**    UNTIL DATA IS VALID OR USER KILLS IT            **/\n/**                                                    **/\n/********************************************************/\nSET &CURSOR = LIB\nIF Q&LIB\u00ac= Q THEN SET &CURSOR=SCHEDTB\n\nSET &OPT1 = Y\nSET &OPT2 = N\nSET &OPT3 = N\n\nSET &OUTMSG=\n\nDO WHILE (&ENDED = 0)\n\n   /********************************************************/\n   /**                                                    **/\n   /**    DISPLAY PRIMARY PANEL AND GET RESPONSE          **/\n   /**                                                    **/\n   /********************************************************/\n\n   IF (&OUTMSG\u00ac=) THEN ISPEXEC SETMSG MSG(&OUTMSG)\n\n   ISPEXEC DISPLAY PANEL(CTMPK01W)  CURSOR(&CURSOR)\n   ISPEXEC VGET (ZVERB)\n\n   SET &CTMPKLIB = &LIB\n   SET &CTMPKSKL = &SKELMEM\n   IF &ZAPPLID = CTMU THEN +\n           ISPEXEC VPUT (CTMPKLIB  CTMPKSKL USOURCE) PROFILE\n      ELSE ISPEXEC VPUT (CTMPKLIB  CTMPKSKL)\n   ISPEXEC VPUT (USOURCE) /* ALWAYS IN APPLICAYION POOL */\n\n   ISPEXEC VPUT (ENDED)\n   SET &RESP = &ZVERB\n\n   /********************************************************/\n   /**                                                    **/\n   /**    IF USER HIT 'END' OR 'RETURN' JUST EXIT         **/\n   /**                                                    **/\n   /********************************************************/\n\n   IF ((&RESP = END) OR (&RESP = RETURN)  THEN +\n      DO\n         SET &ENDED = 1\n         SET &LIB=\n         SET &SCHEDTB=\n         SET &GRP=\n         ISPEXEC VPUT (ENDED LIB SCHEDTB GRP SKELMEM)\n         EXIT QUIT\n      END\n\n   /********************************************************/\n   /**                                                    **/\n   /**    VALIDATE USER INPUT DATA                        **/\n   /**                                                    **/\n   /********************************************************/\n\n   /********************************************************/\n   /**                                                    **/\n   /**    CONVERT OPTION TO A SINGLE NUMBER               **/\n   /**                                                    **/\n   /********************************************************/\n\n   IF &OPT1 = Y THEN SET &OPT = 1\n   IF &OPT2 = Y THEN SET &OPT = 2\n   IF &OPT3 = Y THEN SET &OPT = 3\n\n   /********************************************************/\n   /**                                                    **/\n   /**    VALIDATE SUFFIX - NO EMBEDDED BLANKS            **/\n   /**                                                    **/\n   /********************************************************/\n\n   SET &SFXOK = 1\n   SET &SFXLEN = &LENGTH(&NRSTR(&SF))\n\n   SET &I = 1\n   DO WHILE ( (&SFXOK=1) AND (&I<=&SFXLEN) )\n     SET &C = &STR(&SUBSTR(&I,&NRSTR(&SF)))\n     IF Z&NRSTR(&C) =Z  THEN SET &SFXOK=0\n     SET &I = &I + 1\n   END  /* OF SUFFIX VALIDATION\n\n   IF &SFXOK = 0 THEN +\n      DO\n         SET &OUTMSG =CTMK001E\n         SET &CURSOR = GRP\n      END\n\n   /********************************************************/\n   /**                                                    **/\n   /**    GROUP NAME VALIDATION :                         **/\n   /**      IF INPUT, EMBEDDED BLANKS NOT ALLOWED         **/\n   /**                                                    **/\n   /**    FOR OPTION 1,                                   **/\n   /**      FIRST CHARACTER NOT A DASH                    **/\n   /**      SUFFIX + PORTION BEFORE DASH <= 10 CHARACTERS **/\n   /**                                                    **/\n   /********************************************************/\n   SET &GROUPOK = 1\n   SET &GRPLEN = &LENGTH(&NRSTR(&GRP))\n\n   SET &I = 1\n   SET &DASH = 0\n\n   DO WHILE ((&GROUPOK=1) AND (&I <= &GRPLEN))\n     SET &C = &STR(&SUBSTR(&I,&NRSTR(&GRP)))\n     IF (&NRSTR(&C) = &STR(-)) THEN +\n       IF  &DASH = 0 THEN SET &DASH = &I\n     IF Z&NRSTR(&C) =Z  THEN SET &GROUPOK=0\n     SET &I = &I + 1\n   END /* LOOP OVER CHARACTERS IN GROUPNAME */\n\n   IF &GROUPOK = 0 THEN +\n      DO\n         SET &OUTMSG =CTMK001E\n         SET &CURSOR = GRP\n      END\n\n   IF (&OPT=1) AND (&GROUPOK=1) THEN +\n     DO\n       IF &DASH=0 THEN SET &DASH = &GRPLEN + 1\n       SET &SGRP = &SUBSTR(1:&DASH-1,&NRSTR(&GRP))\n       IF &DASH + &SFXLEN   > 11 THEN +\n         DO\n            SET &OUTMSG = CTMK001Q\n            SET &CURSOR = GRP\n            SET &GROUPOK = 0\n         END\n     END /* OPTION 1 GROUP + SUFFIX VALIDATION */\n\n\n\n   /********************************************************/\n   /**                                                    **/\n   /**    VALIDATE THAT THE SCHEDULING TBL LIBRARY EXISTS **/\n   /**                                                    **/\n   /********************************************************/\n\n   SET &LIBVALID = 1\n   SET &OLIB = &LIB\n   SET &MEMBER = 1\n   SET &SKELMOK= 1\n   SET &DSORG = PO\n   SET &LRECL = 80\n   SET &RECFM = FB\n\n   ISPEXEC CONTROL ERRORS RETURN\n   ISPEXEC LMINIT DATAID(CTMPKF00) DATASET('&LIB') ENQ(SHR) +\n                  ORG(DSORG)\n   ISPEXEC LMOPEN DATAID(&CTMPKF00) LRECL(LRECL) RECFM(RECFM) +\n                  OPTION(INPUT)\n   SET &RC = &LASTCC\n   ISPEXEC CONTROL ERRORS &ACTION\n   IF &RC \u00ac= 0 THEN +\n      DO\n        SET &LIBVALID = 0\n        SET &OUTMSG = CTMK001A\n      END\n\n   IF &LIBVALID  = 1 THEN +\n      DO\n        IF &DSORG \u00ac= PO  THEN +\n         DO\n           SET &OUTMSG = CTMK001D\n           SET &LIBVALID = 0\n         END\n        IF &LRECL \u00ac= 80  THEN +\n         DO\n           SET &OUTMSG = CTMK001C\n           SET &LIBVALID = 0\n         END\n        IF ((&RECFM \u00ac= FB) AND (&RECFM \u00ac= F))  THEN +\n         DO\n           SET &OUTMSG = CTMK001B\n           SET &LIBVALID = 0\n         END\n      END\n\n   IF &LIBVALID = 0 THEN SET &CURSOR = LIB\n\n   /********************************************************/\n   /**                                                    **/\n   /**    VALIDATE THAT THE SKELETON SCHEDULE EXISTS      **/\n   /**                                                    **/\n   /********************************************************/\n\n   IF &LIBVALID = 1 THEN +\n     DO\n       ISPEXEC CONTROL ERRORS RETURN\n       ISPEXEC LMMFIND DATAID(&CTMPKF00)  MEMBER(&SKELMEM)\n       SET &RC = &LASTCC\n       IF &RC \u00ac= 0 THEN +\n          DO\n             SET &OUTMSG = CTMK001G\n             SET &SKELMOK = 0\n          END\n       ISPEXEC CONTROL ERRORS &ACTION\n     END\n\n   IF &SKELMOK = 0 THEN SET &CURSOR = SKELMEM\n\n   /********************************************************/\n   /**                                                    **/\n   /**    VALIDATE SYNTAX OF OUTPUT TABLE NAME            **/\n   /**                                                    **/\n   /********************************************************/\n   SET &MEMLEN = &LENGTH(&NRSTR(&SCHEDTB))\n   SET &NDX = 1\n   DO WHILE ((&MEMBER=1) AND (&NDX <= &MEMLEN))\n     IF (&SUBSTR(&NDX,&NRSTR(&SCHEDTB))=&STR( )) THEN +\n       DO\n         SET &MEMBER=0\n         SET &OUTMSG = CTMK001E\n         SET &CURSOR = SCHEDTB\n       END\n     SET &NDX = &NDX + 1\n   END\n\n   /********************************************************/\n   /**                                                    **/\n   /**    DETERMINE WHETHER OR NOT THERE IS AN OLD        **/\n   /**    VERSION OF THE OUTPUT TABLE                     **/\n   /**                                                    **/\n   /********************************************************/\n\n   IF ((&LIBVALID = 1) AND (&GROUPOK = 1) AND (&MEMBER = 1)   +\n    AND (&SKELMOK = 1) AND (&SFXOK=1) ) THEN +\n     DO\n        ISPEXEC CONTROL ERRORS RETURN\n        ISPEXEC LMMFIND DATAID(&CTMPKF00)  MEMBER(&SCHEDTB)\n        SET &RC = &LASTCC\n        IF &RC = 0 THEN +\n          DO\n             SET &PERMIT=\n               /* PERMISSION TO UPDATE */\n             ISPEXEC DISPLAY PANEL(CTMPK04W) CURSOR(PERMIT)\n             ISPEXEC VGET (ZVERB)\n             SET &RESP=&ZVERB\n             IF &RESP=RETURN THEN +\n               DO\n                 SET &ENDED=1\n                 ISPEXEC VPUT (ENDED)\n                 EXIT\n               END\n             IF ( (&PERMIT=N) OR (&RESP=END) ) THEN +\n               DO\n                 SET &MEMBER=0        /* WONT GO ON */\n                 SET &SCHEDTB=        /* CLEAR SCREEN FIELD */\n               END\n             ELSE +\n               DO\n                        /* REDISPLAY WITH SCREEN LOCKED */\n                 ISPEXEC CONTROL DISPLAY LOCK\n                 ISPEXEC DISPLAY PANEL(CTMPK01W)\n               END\n          END\n     END\n\n   ISPEXEC CONTROL ERRORS RETURN\n   ISPEXEC LMCLOSE DATAID(&CTMPKF00)\n   ISPEXEC LMFREE  DATAID(&CTMPKF00)\n   ISPEXEC CONTROL ERRORS &ACTION\n\n\n   IF ((&LIBVALID = 1) AND (&GROUPOK = 1) AND (&MEMBER = 1)   +\n    AND (&SKELMOK = 1) AND (&SFXOK=1) ) THEN +\n     DO\n        ISPEXEC VPUT (ENDED LIB SCHEDTB GRP SGRP SKELMEM OPT SF)\n        EXIT\n     END\n\nEND  /* DATA IS NOW VALID */\nEXIT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CTMCK15": {"ttr": 6158, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x10_\\x00\\x94\\x10_\\x04\\x10\\x01\\x0b\\x01\\x0b\\x00\\x00\\xc9\\xd6\\xc1\\xf4\\xf1\\xf0@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-04-15T00:00:00", "modifydate": "1994-04-15T04:10:00", "lines": 267, "newlines": 267, "modlines": 0, "user": "IOA410"}, "text": "PROC 0 DEBUG()\nCONTROL MAIN NOLIST NOCONLIST NOSYMLIST NOMSG\nIF &DEBUG=DEBUG THEN CONTROL MAIN LIST CONLIST SYMLIST MSG\nISPEXEC CONTROL ERRORS RETURN\n\n/********************************************************/\n/**                                                    **/\n/**    CONTROL-M QUICK SCHEDULE DEFINITION             **/\n/**                                                    **/\n/**    CLIST CTMCK15  - READ SKELETON TABLE            **/\n/**                                                    **/\n/********************************************************/\n\nISPEXEC VGET (LIB SCHEDTB GRP  SGRP SKELMEM)\n\n/********************************************************/\n/**    READ IN THE MODEL TABLE AND SET UP              **/\n/********************************************************/\n\nISPEXEC LMFREE DATAID(&CTMPKIN)  /* IN CASE SOMETHING THERE */\n\nSET &IOERROR=Y\nSET &SKELVALD=N\nSET &CTMPKIN=&NUL\nISPEXEC VPUT (IOERROR CTMPKIN SKELVALD)\n\nISPEXEC LMINIT  DATAID(CTMPKIN) DATASET('&LIB') ENQ(SHR)\nSET &RC = &LASTCC\nIF &RC \u00ac= 0 THEN +\n   DO\n      ISPEXEC SETMSG MSG(CTMK003Z)\n      EXIT QUIT\n   END\n\nISPEXEC VPUT (CTMPKIN)\n\nISPEXEC LMOPEN  DATAID(&CTMPKIN) OPTION(INPUT)\nSET &RC = &LASTCC\nIF &RC \u00ac= 0 THEN +\n   DO\n      ISPEXEC SETMSG MSG(CTMK003Z)\n      EXIT QUIT\n   END\n\nISPEXEC LMMFIND DATAID(&CTMPKIN) MEMBER(&SKELMEM)\nSET &RC = &LASTCC\nIF &RC \u00ac= 0 THEN +\n   DO\n      ISPEXEC SETMSG MSG(CTMK003Z)\n      EXIT QUIT\n   END\n\n/********************************************************/\n/**    READ IN CARDS FROM MODEL                        **/\n/********************************************************/\n\nSET &MODEND = 0\nSET &NSHOUT = 0\nSET &NECARD = 0\nSET &NQCARD = 0\nSET &NRCARD = 0\nSET &NPCARD = 0\nSET &NCCARD = 0\nSET &NTCARD = 0\nSET &NBCARD = 0\nSET &NDCARD = 0\nSET &NMCARD = 0\nSET &NZCARD = 0\nSET &NHCARD = 0\nSET &NLCARD = 0\nSET &NVCARD = 0\nSET &NWCARD = 0\n\nSET &CARDV=V    /*  IN CASE SKELETON DOESNT HAVE ANY */\n\nDO WHILE &MODEND = 0\n\nISPEXEC LMGET   DATAID(&CTMPKIN) MODE(INVAR) DATALEN(MODLEN) +\n                   DATALOC(MODCARD) MAXLEN(80)\nSET &RC = &LASTCC\nIF &RC \u00ac= 0 THEN +\n  IF &RC = 8 THEN SET &MODEND = 1\n     ELSE +\n   DO\n      ISPEXEC SETMSG MSG(CTMK003Z)\n      EXIT QUIT\n   END\n\nIF &MODEND = 0 THEN +\n   DO\n\n     SET &C = &SUBSTR(1,&NRSTR(&MODCARD))\n\n     IF (&NRSTR(&C)\u00ac=B) THEN +\n       IF (&NRSTR(&C)\u00ac=C) THEN +\n       IF (&NRSTR(&C)\u00ac=D) THEN +\n       IF (&NRSTR(&C)\u00ac=E) THEN +\n       IF (&NRSTR(&C)\u00ac=H) THEN +\n       IF (&NRSTR(&C)\u00ac=I) THEN +\n       IF (&NRSTR(&C)\u00ac=L) THEN +\n       IF (&NRSTR(&C)\u00ac=M) THEN +\n       IF (&NRSTR(&C)\u00ac=O) THEN +\n       IF (&NRSTR(&C)\u00ac=P) THEN +\n       IF (&NRSTR(&C)\u00ac=Q) THEN +\n       IF (&NRSTR(&C)\u00ac=R) THEN +\n       IF (&NRSTR(&C)\u00ac=S) THEN +\n       IF (&NRSTR(&C)\u00ac=T) THEN +\n       IF (&NRSTR(&C)\u00ac=V) THEN +\n       IF (&NRSTR(&C)\u00ac=W) THEN +\n       IF (&NRSTR(&C)\u00ac=Z) THEN +\n         DO\n             ISPEXEC SETMSG MSG(CTMK001S)\n             EXIT QUIT\n         END\n\n     IF &C = E THEN +\n       DO\n         SET &NECARD = &NECARD + 1\n         SET &CARDE&NECARD = &NRSTR(&MODCARD)\n         ISPEXEC VPUT (CARDE&NECARD)\n       END\n\n     IF &C = Q THEN +\n       DO\n         SET &NQCARD = &NQCARD + 1\n         SET &CARDQ&NQCARD = &NRSTR(&MODCARD)\n         ISPEXEC VPUT (CARDQ&NQCARD)\n       END\n\n     IF &C = R THEN +\n       DO\n         SET &NRCARD = &NRCARD + 1\n         SET &CARDR&NRCARD = &NRSTR(&MODCARD)\n         ISPEXEC VPUT (CARDR&NRCARD)\n       END\n\n     IF &C = P THEN +\n       DO\n         SET &NPCARD = &NPCARD + 1\n         SET &CARDP&NPCARD = &NRSTR(&MODCARD)\n         ISPEXEC VPUT (CARDP&NPCARD)\n       END\n\n     IF &C = C THEN +\n       DO\n         SET &NCCARD = &NCCARD + 1\n         SET &CARDC&NCCARD = &NRSTR(&MODCARD)\n         ISPEXEC VPUT (CARDC&NCCARD)\n       END\n\n     IF &C = T THEN +\n       DO\n         SET &NTCARD = &NTCARD + 1\n         SET &CARDT&NTCARD = &NRSTR(&MODCARD)\n         ISPEXEC VPUT (CARDT&NTCARD)\n       END\n\n     IF &C = B THEN +\n       DO\n         SET &NBCARD = &NBCARD + 1\n         SET &CARDB&NBCARD = &NRSTR(&MODCARD)\n         ISPEXEC VPUT (CARDB&NBCARD)\n       END\n\n     IF &C = S THEN +\n       DO\n         SET &NSHOUT = &NSHOUT + 1\n         SET &CARDS&NSHOUT = &NRSTR(&MODCARD)\n         ISPEXEC VPUT (CARDS&NSHOUT)\n       END\n\n     IF &C = D THEN +\n       DO\n         SET &NDCARD = &NDCARD + 1\n         SET &TEMPU = &SUBSTR(1:8,&SYSUID&STR(        ))\n         SET &CTMCKSV=MOVEUID\n         ISPEXEC VPUT (MODCARD TEMPU CTMCKSV)\n         CTMTQSR     /* MOVE THE USER ID TO THE CARD */\n         SET &RC = &LASTCC\n         IF &RC>0 THEN +\n           DO\n              SET &ZERRLM = ERROR EXECUTING PROGRAM CTMTQSR\n              ISPEXEC SETMSG MSG(CTMK003Z)\n              EXIT QUIT\n           END\n         ISPEXEC VGET (CARDD)\n       END\n\n     IF &C = W THEN +\n       DO\n         SET &NWCARD = &NWCARD + 1\n         SET &CTMCKSV=MOVEWCD\n         ISPEXEC VPUT (MODCARD CTMCKSV)\n         CTMTQSR     /* MOVE MODCARD TO CARDW */\n         ISPEXEC VGET (CARDW)\n       END\n\n     IF &C = M THEN +\n       DO\n         SET &NMCARD = &NMCARD + 1\n         SET &CARDM = &NRSTR(&MODCARD)\n       END\n\n     IF &C = L THEN +\n       DO\n         SET &NLCARD = &NLCARD + 1\n         SET &CARDL = &NRSTR(&MODCARD)\n       END\n\n     IF &C = V THEN +\n       DO\n         SET &NVCARD = &NVCARD + 1\n         SET &CARDV = &NRSTR(&MODCARD)\n       END\n\n     IF &C = H THEN +\n       DO\n         SET &NHCARD = &NHCARD + 1\n         SET &CARDH = &NRSTR(&MODCARD)\n       END\n\n     IF &C = Z THEN +\n       DO\n         SET &NZCARD = &NZCARD + 1\n         SET &CARDZ = &NRSTR(&MODCARD)\n       END\n\n     IF &C = O THEN SET &CARDO = &NRSTR(&MODCARD)\n\n   END\nEND\n\nIF ( (&NDCARD\u00ac=1) OR (&NMCARD\u00ac=1) OR (&NZCARD\u00ac=1) OR (&NVCARD>1) OR +\n     (&NHCARD\u00ac=1) OR (&NLCARD\u00ac=1) OR (&NWCARD >1) ) THEN +\n       DO\n             ISPEXEC SETMSG MSG(CTMK001S)\n             EXIT QUIT\n       END\n\nISPEXEC VPUT (CARDD CARDM CARDL CARDH CARDO CARDZ CARDV)\nISPEXEC VPUT -\n    (NECARD NQCARD NRCARD NPCARD NCCARD NTCARD NBCARD NSHOUT)\nISPEXEC VPUT (CARDS CARDS2)\nISPEXEC VPUT (NWCARD CARDW)\n\n\nISPEXEC LMCLOSE DATAID(&CTMPKIN)\nSET &RC = &LASTCC\nIF &RC \u00ac= 0 THEN +\n   DO\n      ISPEXEC SETMSG MSG(CTMK003Z)\n      EXIT QUIT\n   END\n\nISPEXEC LMFREE  DATAID(&CTMPKIN)\nSET &RC = &LASTCC\nIF &RC \u00ac= 0 THEN +\n   DO\n      ISPEXEC SETMSG MSG(CTMK003Z)\n      EXIT QUIT\n   END\n\nSET &IOERROR=N\nSET &SKELVALD=Y\nISPEXEC VPUT (IOERROR SKELVALD)\n\nEXIT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CTMCK20": {"ttr": 6404, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x10_\\x00\\x94\\x10_\\x04\\x10\\x02\\xc3\\x02\\xc3\\x00\\x00\\xc9\\xd6\\xc1\\xf4\\xf1\\xf0@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-04-15T00:00:00", "modifydate": "1994-04-15T04:10:00", "lines": 707, "newlines": 707, "modlines": 0, "user": "IOA410"}, "text": "PROC 0 DEBUG()\n\nISPEXEC CONTROL ERRORS CANCEL\nCONTROL MAIN NOLIST NOCONLIST NOSYMLIST NOMSG\nIF &DEBUG=DEBUG THEN CONTROL MAIN LIST CONLIST SYMLIST MSG\n\n/********************************************************/\n/**                                                    **/\n/**    CONTROL-M QUICK SCHEDULE DEFINITION             **/\n/**                                                    **/\n/**    CLIST CTMCK20  - GET JOB DATA AND VALIDATE      **/\n/**                                                    **/\n/********************************************************/\n\nSET &NUL = &STR()    /* ENTERING CLIST 20 */\nSET &MINIMUM = 21\nSET &SCRSIZ = 21\nSET &SCRSZ3 = &SCRSIZ / 3\nSET &SCRSZ23 = &SCRSIZ - &SCRSZ3\nSET &USERBL = &SCRSZ23\nSET &ENDED = 0\nSET &RESP = &NUL\nSET &VALID = Y\nSET &REQUIRE = N\nSET &OUTMSG = &NUL\nSET &TBLSIZ = 0\nSET &HIUSED = 0\nSET &LBR=1\nSET &DISROW=1\n\nSET &ZTDMSG = CTMK002A /* NO \"ROW NN OF NN\" */\n\nISPEXEC VGET (LIB SCHEDTB)\n\n\nDO WHILE  (&RESP\u00ac=XXX) /* A \"DO FOREVER\" */\n\n /**************************/\n /* GIVE USER SOME ROOM    */\n /**************************/\n  IF   &VALID = Y   THEN +\n  DO\n     SET &ENDHIT=N\n     SET &CUR = &LBR\n     SET &CFIELD = JNAM\n     ISPEXEC TBBOTTOM CTMPKT00\n     ISPEXEC TBVCLEAR CTMPKT00\n     SET &NUMCLR = &TBLSIZ - &HIUSED\n     SET &NEEDED  = &USERBL  -&NUMCLR\n     IF (&TBLSIZ + &NEEDED) < &MINIMUM THEN +\n        SET &NEEDED = &MINIMUM - &TBLSIZ\n     SET &NDX = 1\n     DO WHILE (&NDX <= &NEEDED)\n        SET &JNUM = &NUMCLR + &HIUSED + &NDX\n        ISPEXEC TBADD    CTMPKT00\n        SET &NDX = &NDX + 1\n        SET &TBLSIZ = &TBLSIZ + 1\n     END\n  END\n\n\n /**************************/\n /* DISPLAY SCREEN         */\n /**************************/\n\n  IF (&OUTMSG \u00ac= &NUL) THEN ISPEXEC SETMSG MSG(&OUTMSG)\n  ISPEXEC VPUT (OUTMSG) SHARED\n\n\n  ISPEXEC VGET (ZUSER ZTIME)\n\n  IF (&CUR-&DISROW) < &SCRSZ3 THEN SET &DISROW = &CUR - &SCRSZ3\n  IF (&DISROW+&SCRSIZ-&CUR) < &SCRSZ3 THEN SET &DISROW = &CUR-&SCRSZ23\n  IF (&TBLSIZ-&DISROW) < &SCRSIZ THEN SET &DISROW = &TBLSIZ-&SCRSIZ\n  IF &DISROW < 1 THEN SET &DISROW = 1\n\n\n  ISPEXEC TBTOP   CTMPKT00\n  ISPEXEC TBSKIP CTMPKT00 NUMBER(&DISROW)\n  ISPEXEC TBDISPL CTMPKT00 PANEL(CTMPK02W) AUTOSEL(NO)  +\n                 CURSOR(&CFIELD)  POSITION(MODROW) CSRROW(&CUR)\n  SET &NUMCHGD = &ZTDSELS\n  IF (&ZCMD=UP) THEN SET &DISROW = &DISROW + &ZSCROLLN\n  IF (&ZCMD=DOWN) THEN SET &DISROW = &DISROW - &ZSCROLLN\n\n  ISPEXEC VGET (ZVERB)\n  SET &RESP = &ZVERB\n  IF Z&RESP = Z THEN  SET &RESP = ENTER\n  SET &ENDHIT=N\n\n  IF &RESP=RETURN THEN +\n    DO\n       SET &ENDED = 1\n       ISPEXEC VPUT (ENDED RESP)\n       ISPEXEC TBCLOSE  CTMPKT00\n       EXIT QUIT\n    END /* OF USER KILLED IT */\n\n  IF &RESP=END THEN SET &ENDHIT = Y\n\n\n /**************************/\n /* SEE IF JUST ENTER KEY  */\n /**************************/\n  IF (&NUMCHGD=0) THEN SET &PROCESS=N\n    ELSE SET &PROCESS = Y\n\n /**************************/\n /* PICK UP CHANGED LINES  */\n /**************************/\n  SET &MAXROW = 0\n\n  DO WHILE &NUMCHGD \u00ac= 0\n\n    IF &NRSTR(Q&OPER) = Q THEN SET &POPER = N\n       ELSE  SET &POPER = &NRSTR(&OPER)\n    SET &WASCHG = 1\n    SET &DEPVAL = 1\n    ISPEXEC TBPUT CTMPKT00\n    SET &NUMCHGD = &NUMCHGD - 1\n    SET &MAXROW = &MODROW\n    IF &NUMCHGD \u00ac= 0 THEN +\n      DO\n        ISPEXEC TBDISPL CTMPKT00 POSITION(MODROW)\n        ISPEXEC VGET (ZVERB)\n        SET &RESP = &ZVERB\n        IF Z&RESP = Z THEN  SET &RESP = ENTER\n        IF &RESP=RETURN THEN +\n          DO\n            SET &ENDED = 1\n            ISPEXEC VPUT (ENDED RESP)\n            ISPEXEC TBCLOSE  CTMPKT00\n            EXIT QUIT\n          END /* OF USER KILLED IT */\n        IF &RESP=END THEN SET &ENDHIT=Y\n      END\n\n  END /* OF PICKING UP CHANGED LINES */\n\n  IF (&OUTMSG\u00ac=&NUL) THEN SET &REQUIRE=Y\n\n  IF (&REQUIRE = Y) OR (&ENDHIT=Y) THEN +\n    DO\n      SET &PROCESS=Y\n      IF &HIUSED > &MAXROW THEN SET &MAXROW = &HIUSED\n    END\n\n  SET &REQUIRE=N\n  SET &OUTMSG=&NUL\n\n\n /**************************/\n /* FIRST LEVEL VALIDATION */\n /*                        */\n /* SEE THAT BASIC SYNTAX  */\n /* IS CORRECT             */\n /*                        */\n /* PARSE FROM END SO THAT */\n /* FIRST ERROR WILL FLAG  */\n /**************************/\n\n  IF (&PROCESS=Y) THEN +\n    DO\n      SET &VALID = Y\n      SET &MOVEROW = 0\n      SET &MOVETGT = 0\n      SET &TYPCOPY=N\n      SET &CFIELD = JNAM\n      SET &OFFSET=0\n      SET &NUMCMDS = 0\n      SET &MODROW = &MAXROW\n      ISPEXEC TBTOP CTMPKT00\n      ISPEXEC TBSKIP CTMPKT00 NUMBER(&MAXROW)\n    END\n\n  DO WHILE (&MODROW > 0) AND (&PROCESS=Y)\n     SET &OPVAL = 1\n     SET &POPER = &NRSTR(&OPER)\n     IF (Z&NRSTR(&POPER)= Z) THEN SET &POPER = N\n     IF ((&NRSTR(&POPER)<A) OR (&NRSTR(&POPER)>Z) ) THEN SET &OPVAL=0\n     IF &OPVAL=1 THEN +\n     IF (&POPER\u00ac=A) AND (&POPER\u00ac=B) AND (&POPER\u00ac=C) AND +\n        (&POPER\u00ac=D) AND (&POPER\u00ac=I) AND (&POPER\u00ac=M) AND +\n        (&POPER\u00ac=R) AND (&POPER\u00ac=N) AND (&POPER\u00ac=P) THEN SET &OPVAL=0\n     IF &OPVAL=0 THEN +\n          DO\n            SET &CUR = &MODROW\n            SET &CFIELD = OPER\n            SET &VALID = N\n            SET &OUTMSG=CTMK002B\n            SET &POPER = N\n          END /* OPER VALIDATION */\n\n     IF (&MODROW > &HIUSED) THEN  SET &HIUSED = &MODROW\n\n     IF (&POPER\u00ac=D) THEN +\n       DO\n\n         IF (&POPER=C) OR (&POPER=M) THEN +\n             IF &MOVEROW = 0 THEN +\n               DO\n                 SET &MOVEROW = &MODROW\n                 SET &TYPCOPY = &POPER\n               END\n               ELSE +\n               DO\n                 SET &CUR = &MODROW\n                 SET &CFIELD = OPER\n                 SET &VALID = N\n                 SET &OUTMSG=CTMK002D\n               END /* C/M VALIDATION */\n\n         IF (&POPER=B) OR (&POPER=A) THEN +\n             IF &MOVETGT = 0 THEN +\n               DO\n                 SET &MOVETGT = &MODROW\n                 IF (&POPER=B) THEN SET &DIR = BEFORE\n                   ELSE SET &DIR = AFTER\n               END\n               ELSE +\n               DO\n                 SET &CUR = &MODROW\n                 SET &CFIELD = OPER\n                 SET &VALID = N\n                 SET &OUTMSG=CTMK002E\n               END /* A/B VALIDATION */\n\n         IF (Z&NRSTR(&JNAM) = Z) THEN +\n            IF (Z&NRSTR(&DESC) \u00ac= Z) OR  (Z&NRSTR(&DEPS) \u00ac= Z) THEN +\n               DO\n                 SET &CUR = &MODROW\n                 SET &CFIELD = JNAM\n                 SET &VALID = N\n                 SET &OUTMSG=CTMK002H\n               END /* JOBNAME WAS BLANK */\n\n\n\n         /**************************/\n         /*                        */\n         /* VALIDATE JOBNAME FIELD */\n         /*                        */\n         /* ANYTHING IS VALID      */\n         /*  EXCEPT EMBEDDED BLANKS*/\n         /*                        */\n         /**************************/\n         SET &NDX = 1\n         SET &DEPLEN = &LENGTH(&NRSTR(&JNAM))\n         DO WHILE ((&VALID=Y) AND (&NDX <= &DEPLEN)\n           SET &C = &SUBSTR(&NDX,&NRSTR(&JNAM))\n           IF (&NRSTR(&C)=&STR( )) THEN  +\n             DO\n               SET &CUR = &MODROW\n               SET &CFIELD = JNAM\n               SET &VALID = N\n               SET &OUTMSG=CTMK001E /* ONLY TRAILING BLANKS */\n             END\n           SET &NDX = &NDX + 1\n         END\n\n         /**************************/\n         /*                        */\n         /* VALIDATE DEPENDENCY    */\n         /* FIELD - SYNTAX         */\n         /*                        */\n         /* ONLY DO THIS IF THE    */\n         /*  FIELD WAS CHANGED     */\n         /*                        */\n         /**************************/\n\n\n         SET &NUMDEPS = 0\n         SET &DEPNO = 1\n         SET &DEPLEN = &LENGTH(&NRSTR(&DEPS))\n         SET &FSTART = 1\n         IF &WASCHG = 1 THEN +\n          DO WHILE ((&FSTART <= &DEPLEN) AND (&DEPVAL=1))\n           SET &NDX = &FSTART\n           SET &C = &SUBSTR(&NDX,&NRSTR(&DEPS))\n           IF (&NRSTR(&C)=&STR(,)) THEN SET &DEPVAL = 0\n           IF (&NRSTR(&C)=&STR( )) THEN SET &DEPVAL = 0\n\n           IF (&NRSTR(&C)=&STR(-)) THEN +\n             DO\n             /**************************/\n             /* MINUS SIGN             */\n             /**************************/\n                SET &NDX = &NDX + 1\n                IF &NDX <= &DEPLEN THEN  +\n                  DO\n                    IF &SUBSTR(&NDX,&NRSTR(&DEPS)) \u00ac=&STR(,) THEN +\n                      SET &DEPVAL=0\n                  END /* CHECK CHARACTER AFTER MINUS SIGN */\n                IF &DEPVAL=1 THEN +\n                  DO\n                    SET &DJ&DEPNO =&STR(-)\n                    SET &T&DEPNO = M\n                    SET &DEPNO = &DEPNO + 1\n                    SET &FSTART = &FSTART + 2\n                  END /* OF VALID MINUS SIGN */\n             END /*  MINUS SIGN */\n             ELSE +\n           IF (&NRSTR(&C)=&STR(*)) THEN +\n             DO\n             /**************************/\n             /* ASTERISK               */\n             /**************************/\n               DO WHILE (&DEPVAL = 1) AND (&NDX <= &DEPLEN)\n                 SET &C = &SUBSTR(&NDX,&NRSTR(&DEPS))\n                 IF (&NRSTR(&C)=&NRSTR( ) THEN SET &DEPVAL = 0\n                 SET &NDX = &NDX + 1\n               END /*CHAR LOOP ON ASTERISK */\n               IF (&NDX=&FSTART+1) THEN SET &DEPVAL=0\n               IF (&DEPVAL=1) THEN\n                 DO\n                  SET &DJ&DEPNO = &SUBSTR(&FSTART:&DEPLEN,&NRSTR(&DEPS))\n                  SET &XCOND = &SUBSTR(&FSTART:&DEPLEN,&NRSTR(&DEPS))\n                  SET &T&DEPNO = C\n                  SET &DEPNO = &DEPNO + 1\n                 END /* MOVED THE CONDITION */\n               SET &FSTART=&NDX\n             END /* PROCESSING ASTERISK */\n           ELSE +\n           IF (&DEPVAL=1) THEN +\n             DO\n               SET &FEND = &FSTART\n               SET &NDX = &FSTART+1\n               DO WHILE (&FEND = &FSTART)\n                 IF &NDX > &DEPLEN THEN SET &FEND = &NDX\n                 ELSE +\n                   DO\n                     SET &C = &SUBSTR(&NDX,&NRSTR(&DEPS))\n                     IF (&NRSTR(&C)=&STR(,)) THEN SET &FEND=&NDX\n                     SET &NDX = &NDX + 1\n                   END\n               END /* FOUND A COMMA IF THERE IS ONE */\n               IF (&DATATYPE(&SUBSTR(&FSTART:&FEND-1,&NRSTR(&DEPS))) +\n                     = NUM) THEN SET &TY=N\n               ELSE SET &TY=A\n               IF (&TY=A) THEN +\n                 IF &FEND-1-&FSTART > 8 THEN SET &DEPVAL=0\n                 ELSE +\n                 DO\n                   SET &NDX = &FSTART\n                   DO WHILE (&NDX < &FEND) AND (&DEPVAL=1)\n                     SET &C=&SUBSTR(&NDX,&NRSTR(&DEPS))\n                     IF (&NRSTR(&C) = &STR( )) THEN SET &DEPVAL=0\n                     SET &NDX = &NDX + 1\n                   END /* OF ALF COLUMN CHECK */\n                 END /* CHECK AN ALPHA FIELD */\n               IF &DEPVAL = 1 THEN\n                 DO\n                   SET &T&DEPNO = &TY\n                   SET &DJ&DEPNO = &SUBSTR( +\n                        &FSTART:&FEND-1,&NRSTR(&DEPS))\n                   SET &DEPNO = &DEPNO + 1\n                 END\n               SET &FSTART = &FEND + 1\n             END /* LETTER OR NUMBER */\n\n         END /* OF CHARACTER SCAN OF DEPS FIELD */\n\n         IF &POPER = N THEN SET &POPER = &NUL\n\n         IF &WASCHG=1 THEN +\n           IF &DEPVAL = 0 THEN +\n             DO\n                SET &CUR = &MODROW\n                SET &CFIELD = DEPS\n                SET &VALID = N\n                SET &OUTMSG=CTMK002K\n                ISPEXEC TBPUT CTMPKT00\n             END /* INVALID DEPENDENCY FIELD */\n           ELSE +\n             DO\n               SET &WASCHG = 0\n               SET &NUMDEPS = &DEPNO-1\n               ISPEXEC TBPUT CTMPKT00\n             END\n\n       END  /* ROW IS NOT MARKED DELETE */\n     SET &MODROW = &MODROW - 1\n     ISPEXEC TBSKIP CTMPKT00 NUMBER(-1)\n  END /* OF FIRST LEVEL VALIDATION LOOP */\n\n  /**************************/\n  /* SECOND LEVEL VALIDATION*/\n  /*                        */\n  /* BASIC SYNTAX IS OK     */\n  /*                        */\n  /* CHECK INTER-LINE       */\n  /*  REFERENCES            */\n  /**************************/\n\n  IF (&PROCESS=Y) AND (&VALID=Y) THEN +\n    DO\n      IF (&MOVEROW \u00ac= 0) AND (&MOVETGT = 0)  THEN +\n        DO\n          SET &CUR = &MOVEROW\n          SET &CFIELD = OPER\n          SET &VALID = N\n          SET &OUTMSG=CTMK002F\n        END\n\n      IF (&MOVEROW = 0) AND (&MOVETGT \u00ac= 0)  THEN +\n        DO\n          SET &CUR = &MOVETGT\n          SET &CFIELD = OPER\n          SET &VALID = N\n          SET &OUTMSG=CTMK002G\n        END\n\n      IF &MOVETGT > &HIUSED THEN SET &HIUSED = &MOVETGT\n\n      IF (&DIR=BEFORE) THEN SET &MOVETGT = &MOVETGT-1\n        /* MOVETGT NOW POINTS TO ROW AFTER WHICH WILL BE MOVED */\n\n      SET &CURRENT = 1\n      SET &LBR=0\n\n    END\n\n  IF (&VALID=Y) AND (&PROCESS=Y) THEN +\n    DO WHILE &CURRENT <= &HIUSED\n\n      ISPEXEC TBTOP  CTMPKT00\n      ISPEXEC TBSKIP CTMPKT00  NUMBER(&CURRENT)\n\n      SET &NEW&JNUM = &JNUM + &OFFSET\n      IF (&POPER=&NUL) THEN SET &POPER=N\n      IF (&POPER\u00ac=N) THEN SET &NUMCMDS = &NUMCMDS+1\n      IF (&POPER=B) THEN +\n        DO\n          SET &REALTGT = &&NEW&JNUM\n          SET &REALTGT = &REALTGT\n        END\n      IF (&POPER=A) THEN +\n        DO\n          SET &REALTGT = &&NEW&JNUM\n          SET &REALTGT = &REALTGT + 1\n        END\n      IF (&POPER=B) OR (&POPER=P) THEN +\n        DO\n          SET &NN = &&NEW&JNUM\n          SET &NN = &NN + 1\n          SET &NEW&JNUM = &NN\n        END\n      IF (&POPER=A) OR (&POPER=B) OR (&POPER=I) OR +\n         (&POPER=P) OR (&POPER=R) THEN SET &OFFSET = &OFFSET + 1\n      IF (&POPER=D) OR (&POPER=M) THEN SET &OFFSET = &OFFSET - 1\n\n      IF (Z&NRSTR(&JNAM) = Z) AND (Z&POPER\u00ac=ZD) AND  (&LBR = 0) THEN +\n        SET &LBR=&CURRENT\n      IF (Z&NRSTR(&JNAM) \u00ac= Z) AND (Z&POPER\u00ac=ZD) THEN +\n      DO\n\n        /**************************/\n        /* DUPLICATE JOB NAMES    */\n        /**************************/\n        ISPEXEC TBSCAN CTMPKT00 ARGLIST(JNAM) NEXT  CONDLIST(EQ)\n        SET &RC=&LASTCC\n        IF (&RC=0) AND (Z&POPER \u00ac= ZD) THEN +\n          DO\n            SET &VALID=N\n            SET &CFIELD=JNAM\n            SET &CUR=&CURRENT\n            SET &OUTMSG=CTMK002L\n          END /* WAS A DUPLICATE JOB NAME */\n\n        /**************************/\n        /* CHECK THAT ALL JOB     */\n        /* DEPENDENCIES EXIST     */\n        /**************************/\n        SET &NDX = &NUMDEPS\n        DO WHILE ((&NDX > 0) AND (&VALID=Y))\n          SET &TY = &&T&NDX\n          SET &TY = &STR(&TY)\n\n          IF (&TY = M) THEN SET &FINDROW = &CURRENT - 1\n          IF (&TY = N) THEN +\n            DO\n              SET &FINDROW = &SYSNSUB(2,&&DJ&NDX)\n            END\n          IF (&TY = A) THEN +\n            DO\n\n              SET &DEPNDX = &SYSNSUB(2,&&DJ&NDX)\n              SET &JNAM = &NRSTR(&DEPNDX)\n              ISPEXEC TBTOP CTMPKT00\n              ISPEXEC TBSCAN CTMPKT00 +\n                    ARGLIST(JNAM) NEXT CONDLIST(EQ) POSITION(FINDROW)\n            END /* AN ALPHABETIC */\n\n          IF (&TY\u00ac=C) THEN +\n              IF (&FINDROW = 0) OR (&FINDROW > &HIUSED)  THEN +\n                DO /* DEPENDENCY NOT IN TABLE */\n                  SET &VALID=N\n                  SET &CFIELD=DEPS\n                  SET &CUR=&CURRENT\n                  SET &OUTMSG=CTMK002C\n                END\n      /*                                     */\n          IF (&TY=A) OR (&TY=N)  THEN +\n            DO\n\n              IF &FINDROW = &CURRENT THEN +\n                DO /* DEPENDENCY ON YOURSELF */\n                  SET &VALID=N\n                  SET &CFIELD=DEPS\n                  SET &CUR=&CURRENT\n                  SET &OUTMSG=CTMK002J\n                END\n\n              IF (&VALID = Y) THEN +\n                DO\n                  ISPEXEC TBTOP CTMPKT00\n                  ISPEXEC TBSKIP CTMPKT00 NUMBER(&FINDROW)\n\n                  IF Z&NRSTR(&JNAM)  =Z THEN +\n                    DO  /* REFERENCE TO A LINE WITH BLANK JOB NAME */\n                      SET &VALID=N\n                      SET &CFIELD=DEPS\n                      SET &CUR=&CURRENT\n                      SET &OUTMSG=CTMK002C\n                    END\n\n                  IF Z&POPER = ZD THEN +\n                    DO /* REFER TO A LINE WHICH IS BEING DELETED */\n                      SET &VALID=N\n                      SET &CFIELD=DEPS\n                      SET &CUR=&CURRENT\n                      SET &OUTMSG=CTMK002M\n                    END\n\n                  IF &VALID=Y     THEN +\n                    DO /* GET BACK TO MY ROW  */\n                      ISPEXEC TBTOP CTMPKT00\n                      ISPEXEC TBSKIP CTMPKT00 NUMBER(&CURRENT)\n                    END\n\n                END  /* FINAL CHECK   */\n\n            END /* ALL THE SEPARATE CHECKS FOR THIS DEPENDENCY */\n\n          SET &NDX = &NDX - 1\n        END /* LOOP OVER DEPENDENCIES */\n\n      END /* CHECKING A NON-BLANK NON-DELETED LINE */\n      SET &CURRENT = &CURRENT + 1\n\n    END /* LOOP LOOKING FOR JOBNAMES AND REFS */\n\n  IF (&VALID=Y) AND (&PROCESS=Y) AND (&LBR=0) THEN SET &LBR = &HIUSED+1\n\n  /**************************/\n  /* PROCESS LINE COMMANDS  */\n  /**************************/\n\n  /**************************/\n  /* DO A 'MOVE'            */\n  /*   BEFORE THE LOOP      */\n  /**************************/\n\n  IF  (&VALID=Y) AND (&TYPCOPY=M) AND (&PROCESS=Y)  THEN +\n    DO\n      SET &NEW&MOVEROW = &REALTGT\n      ISPEXEC TBTOP CTMPKT00\n      ISPEXEC TBSKIP CTMPKT00 NUMBER(&MOVEROW)\n      ISPEXEC TBDELETE CTMPKT00\n      SET &NN = &MOVETGT\n      IF &NN > &MOVEROW THEN SET &NN = &NN - 1\n      ISPEXEC TBTOP CTMPKT00\n      ISPEXEC TBSKIP CTMPKT00 NUMBER(&NN) NOREAD\n      SET &OPER = &NUL\n      SET &POPER = &NUL\n      SET &TYPCOPY = N\n      SET &REQUIRE = Y\n      ISPEXEC TBADD    CTMPKT00\n    END\n\n  SET &CURRENT = 1\n\n\n  IF (&VALID=Y) AND (&PROCESS=Y) AND (&NUMCMDS>0) THEN +\n    DO WHILE &CURRENT <= &HIUSED     /* PROCESS COMMANDS  */\n\n      ISPEXEC TBTOP CTMPKT00\n      ISPEXEC TBSKIP CTMPKT00 NUMBER(&CURRENT)\n\n      SET &LOPER = &POPER\n      IF (Z&LOPER=Z) THEN SET &LOPER = N\n      SET &POPER = &NUL\n      SET &OPER = &NUL\n\n      IF (&LOPER\u00ac=D) THEN\n        DO                          /* ADJUST DEPENDENCIES */\n          SET &NN = &&NEW&JNUM\n          SET &JNUM = &NN\n          SET &HERE = &JNUM\n          SET &NDX  = 1\n          SET &DEPS = &NUL\n          IF (&NUMDEPS=&NUL) THEN SET &NUMDEPS = 0\n          DO WHILE &NDX <= &NUMDEPS  /* LOOP OVER DEPENDENCIES */\n            SET &C = &&T&NDX\n            SET &C = &STR(&C)\n            IF (&C=N) THEN +\n              DO\n                SET &NN = &&DJ&NDX\n                SET &NN = &&NEW&NN\n                SET &DJ&NDX = &NN\n              END\n            SET &TEMP = &SYSNSUB(2,&&DJ&NDX)\n            SET &DEPS = &NRSTR(&DEPS)&NRSTR(&TEMP)\n            SET &NDX = &NDX + 1\n            IF &NDX <=&NUMDEPS THEN SET &DEPS = &NRSTR(&DEPS)&STR(,)\n          END  /* LOOP OVER DEPENDENCIES */\n        END\n\n      ISPEXEC TBPUT CTMPKT00\n\n      IF (&LOPER=C) THEN +\n        DO\n          SET &MOVEROW= &HERE\n        END\n\n      IF (&LOPER=D) THEN +\n        DO\n          ISPEXEC TBDELETE CTMPKT00\n          SET &CURRENT = &CURRENT - 1\n          SET &TBLSIZ = &TBLSIZ - 1\n          SET &HIUSED = &HIUSED - 1\n          SET &LBR = &LBR - 1\n        END\n\n      IF  (&LOPER=I) OR (&LOPER=R) OR +\n        (  (&LOPER=A) AND (&TYPCOPY=C) )  THEN  +\n        DO\n          IF (&LOPER = I) THEN ISPEXEC TBVCLEAR CTMPKT00\n          IF (&LOPER = R) THEN SET &REQUIRE = Y\n          SET &JNUM = &HERE + 1\n          SET &MOVETGT = &JNUM\n          ISPEXEC TBADD    CTMPKT00\n          SET &CURRENT = &CURRENT + 1\n          SET &TBLSIZ = &TBLSIZ + 1\n          SET &HIUSED = &HIUSED + 1\n          SET &LBR = &HERE + 1\n        END\n\n      IF ((&LOPER=B) AND (&TYPCOPY=C)) OR (&LOPER=P) THEN +\n        DO\n          ISPEXEC TBVCLEAR CTMPKT00\n          SET &JNUM = &HERE-1\n          SET &MOVETGT = &JNUM\n          ISPEXEC TBSKIP CTMPKT00 NUMBER (-1) NOREAD\n          ISPEXEC TBADD    CTMPKT00\n          SET &CURRENT = &CURRENT + 1\n          SET &TBLSIZ = &TBLSIZ + 1\n          SET &HIUSED = &HIUSED + 1\n          SET &LBR = &LBR + 1\n          IF &LOPER = P THEN SET &LBR = &HERE - 1\n        END\n\n      SET &CURRENT = &CURRENT + 1\n\n    END                       /* OF COMMAND LOOP */\n\n  IF (&VALID=Y) AND (&PROCESS=Y) AND (&NUMCMDS>0) THEN +\n    DO\n      ISPEXEC TBTOP CTMPKT00\n      ISPEXEC TBSKIP CTMPKT00 NUMBER(&CURRENT)\n      DO WHILE &CURRENT <= &TBLSIZ\n        SET &JNUM = &JNUM + &OFFSET\n        ISPEXEC TBPUT CTMPKT00\n        SET &CURRENT = &CURRENT + 1\n        ISPEXEC TBSKIP CTMPKT00\n      END\n    END\n\n  /**************************/\n  /* DO A 'COPY'            */\n  /*   AFTER THE LOOP       */\n  /**************************/\n\n  IF  (&VALID=Y) AND (&TYPCOPY=C) AND (&PROCESS=Y) THEN +\n    DO\n      ISPEXEC TBTOP CTMPKT00\n      ISPEXEC TBSKIP CTMPKT00 NUMBER(&MOVEROW)\n      SET &JNUM = &MOVETGT\n      ISPEXEC TBTOP CTMPKT00\n      ISPEXEC TBSKIP CTMPKT00 NUMBER(&JNUM) NOREAD\n      SET &OPER = &NUL\n      SET &POPER = &NUL\n      ISPEXEC TBPUT    CTMPKT00\n      SET &TYPCOPY = N\n      SET &REQUIRE = Y\n    END\n\n  IF  (&VALID=Y) AND (&ENDHIT=Y) AND (&REQUIRE=N) THEN +\n    DO\n      SET &ENDED = 0\n      ISPEXEC VPUT (ENDED RESP HIUSED)\n      EXIT QUIT\n    END\n\nEND /* OF \"DO FOREVER\" */\n\nEXIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CTMCK30": {"ttr": 6662, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x10_\\x00\\x94\\x10_\\x04\\x10\\x00\\xb1\\x00\\xb1\\x00\\x00\\xc9\\xd6\\xc1\\xf4\\xf1\\xf0@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-04-15T00:00:00", "modifydate": "1994-04-15T04:10:00", "lines": 177, "newlines": 177, "modlines": 0, "user": "IOA410"}, "text": "PROC 0 DEBUG(X)\nCONTROL MAIN NOLIST NOCONLIST NOSYMLIST NOMSG\nIF &DEBUG=DEBUG THEN CONTROL MAIN LIST CONLIST SYMLIST MSG\nISPEXEC CONTROL ERRORS RETURN\n\n/********************************************************/\n/**                                                    **/\n/**    CONTROL-M QUICK SCHEDULE DEFINITION             **/\n/**                                                    **/\n/**    CLIST CTMCK30  - EXIT OPTIONS WINDOW            **/\n/**    FINAL DETERMINATION OF LIBRARY AND TABLE NAME   **/\n/**                                                    **/\n/********************************************************/\n\nISPEXEC VGET (LIB SCHEDTB GRP  SGRP SKELMEM)\nSET &OLIB = &LIB\nSET &OTABLE = &NRSTR(&SCHEDTB)\nSET &NUL=()\nSET &CUR=CSAVE\nSET &VALID=N\n\nISPEXEC VGET (LIB SCHEDTB)\nSET &XLIB = &STR(LIB: )&LIB\nSET &XTAB = &STR(TABLE: )&NRSTR(&SCHEDTB)\n\nDO WHILE (&VALID=N)\n\n  ISPEXEC DISPLAY PANEL(CTMPK03W) CURSOR(&CUR)\n\n  SET &ENDED = N\n  IF (&RESP = END) OR (&RESP=RETURN) THEN +\n    DO\n      SET &ENDED = Y\n      ISPEXEC VPUT (OLIB OTABLE ENDED)\n      EXIT QUIT\n    END\n\n  SET &VALID=Y\n  IF (&NRSTR(&OTABLE)=&NUL)  THEN +\n    DO\n      SET &VALID=N\n      SET &CUR=OTABLE\n      ISPEXEC SETMSG MSG(CTMK001F)\n    END\n\n  IF (&OLIB=&NUL) THEN +\n    DO\n      SET &VALID=N\n      SET &CUR=OLIB\n      ISPEXEC SETMSG MSG(CTMK001H)\n    END\n\n  IF ((&CSAVE=&NUL) AND (&CCREATE=&NUL) OR +\n     ((&CSAVE\u00ac=&NUL) AND (&CCREATE\u00ac=&NUL)) THEN +\n    DO\n      SET &VALID=N\n      SET &CUR=CSAVE\n      ISPEXEC SETMSG MSG(CTMK003C)\n    END\n\n  IF (&CCREATE\u00ac=Y) AND (&CCREATE\u00ac=N) AND (&CCREATE\u00ac=&NUL) THEN +\n    DO\n      SET &VALID=N\n      SET &CUR=CCREATE\n      ISPEXEC SETMSG MSG(CTMK001K)\n    END\n\n  IF (&CSAVE\u00ac=Y) AND (&CSAVE\u00ac=N) AND (&CSAVE\u00ac=&NUL) THEN +\n    DO\n      SET &VALID=N\n      SET &CUR=CSAVE\n      ISPEXEC SETMSG MSG(CTMK001K)\n    END\n\n  IF ((&CSAVE=N) OR (&CCREATE=N)) AND (&VALID=Y) THEN +\n    DO\n      SET &ENDED = Y\n      ISPEXEC VPUT (OLIB OTABLE ENDED)\n      EXIT QUIT\n    END\n\n\n   IF (&OLIB=&LIB) THEN SET &LIBVALID=1\n   ELSE +\n     IF &VALID=Y THEN +\n     DO\n       SET &LIBVALID = 1\n       SET &DSORG = PO\n       SET &LRECL = 80\n       SET &RECFM = FB\n\n       ISPEXEC LMFREE DATAID(CTMPKF00)\n       ISPEXEC LMINIT DATAID(CTMPKF00) DATASET('&OLIB') +\n                           ENQ(SHR) ORG(DSORG)\n     ISPEXEC LMOPEN DATAID(&CTMPKF00) LRECL(LRECL) RECFM(RECFM) +\n                      OPTION(INPUT)\n       SET &RC = &LASTCC\n       IF &RC \u00ac= 0 THEN +\n          DO\n            ISPEXEC SETMSG MSG(CTMK003E)\n            SET &LIBVALID = 0\n          END\n\n       IF &LIBVALID  = 1 THEN +\n          DO\n            IF &DSORG \u00ac= PO  THEN +\n             DO\n               ISPEXEC SETMSG MSG(CTMK001D)\n               SET &LIBVALID = 0\n             END\n            IF &LRECL \u00ac= 80  THEN +\n             DO\n               ISPEXEC SETMSG MSG(CTMK001C)\n               SET &LIBVALID = 0\n             END\n            IF ((&RECFM \u00ac= FB) AND (&RECFM \u00ac= F))  THEN +\n             DO\n               ISPEXEC SETMSG MSG(CTMK001B)\n               SET &LIBVALID = 0\n             END\n          END\n\n       IF &LIBVALID = 0 THEN +\n         DO\n           SET &CUR=OLIB\n           SET &VALID=N\n         END\n     END /* OF VALIDATING THE LIBRARY */\n\n   /********************************************************/\n   /**                                                    **/\n   /**    DOES THE REQUESTED MEMBER EXIST                 **/\n   /**                                                    **/\n   /********************************************************/\n\n  IF (&VALID=Y) AND (&LIBVALID=1) THEN +\n    DO\n      IF (&LIB=&OLIB THEN +\n      DO\n        ISPEXEC LMFREE DATAID(CTMPKF00)\n        ISPEXEC LMINIT DATAID(CTMPKF00) DATASET('&OLIB') +\n                            ENQ(SHR) ORG(DSORG)\n      ISPEXEC LMOPEN DATAID(&CTMPKF00) LRECL(LRECL) RECFM(RECFM) +\n                       OPTION(INPUT)\n      END\n      ISPEXEC LMMFIND DATAID(&CTMPKF00)  MEMBER(&NRSTR(&OTABLE))\n      SET &RC = &LASTCC\n      IF &RC = 0 THEN SET &MFOUND=Y\n      ELSE SET &MFOUND=N\n    END\n\n\n  IF (&CTMPKF00\u00ac=&NUL) THEN +\n  DO\n    ISPEXEC LMCLOSE DATAID(&CTMPKF00)\n    ISPEXEC LMFREE  DATAID(&CTMPKF00)\n  END\n\n  IF (&VALID=Y) AND (&MFOUND=Y) AND (&CCREATE=Y) THEN +\n    DO\n      SET &VALID=N\n      ISPEXEC SETMSG MSG(CTMK003F)\n      SET &CUR=OTABLE\n    END\n\n  IF (&VALID=Y) AND (&MFOUND=N) AND (&CSAVE=Y) THEN +\n    DO\n      SET &VALID=N\n      ISPEXEC SETMSG MSG(CTMK003G)\n      SET &CUR=OTABLE\n    END\n\n\n  ISPEXEC VPUT (OLIB OTABLE ENDED MFOUND)\n\nEND\nEXIT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CTMCK40": {"ttr": 6666, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x10_\\x00\\x94\\x10_\\x04\\x10\\x02p\\x02p\\x00\\x00\\xc9\\xd6\\xc1\\xf4\\xf1\\xf0@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-04-15T00:00:00", "modifydate": "1994-04-15T04:10:00", "lines": 624, "newlines": 624, "modlines": 0, "user": "IOA410"}, "text": "PROC 0 DEBUG(X)\nCONTROL MAIN NOLIST NOCONLIST NOSYMLIST NOMSG\nIF &DEBUG=DEBUG THEN CONTROL MAIN LIST CONLIST SYMLIST MSG\nISPEXEC CONTROL ERRORS RETURN\n\n/********************************************************/\n/**                                                    **/\n/**    CONTROL-M QUICK SCHEDULE DEFINITION             **/\n/**                                                    **/\n/**    CLIST CTMCK40  - PRODUCE SCHED. TABLE BY        **/\n/**    MERGING THE SKELETON AND THE JOB TABLE          **/\n/**                                                    **/\n/********************************************************/\n\nSET &NUL = &STR()\nSET &BLK44 = &STR(                                            )\n  /* THE ABOVE CARD HAS 44 BLANKS - LEAVE IT ALONE  */\n\nISPEXEC VGET (OLIB OTABLE MFOUND)\nISPEXEC VGET (GRP SGRP  OPT SF)\n\nISPEXEC VGET (CARDD CARDM CARDL CARDH CARDO CARDZ CARDV)\nISPEXEC VGET -\n          (NECARD NQCARD NRCARD NPCARD NCCARD NTCARD NBCARD NSHOUT)\nISPEXEC VGET (NWCARD)\n\nISPEXEC VGET (ZTEMPN) SHARED\nSET &TEMPNAME = CTM#&EVAL(&SYSSRV//10000)\nISPEXEC VPUT (TEMPNAME)\n\n/********************************************************/\n/**    SET UP ALL NON JOB-DEPENDENT DATA IN CARD IMAGES**/\n/********************************************************/\n\n/********************/\n/**    SHOUT CARD  **/\n/********************/\n\nSET &SVAR = &NUL\nSET &NDX = 1\nDO WHILE &NDX <= &NSHOUT\n   ISPEXEC VGET (CARDS&NDX)\n   SET &TEMPU = &SYSNSUB(2,&&CARDS&NDX)\n   SET &SVAR = &NRSTR(&SVAR)&SUBSTR( +\n        2:80,&NRSTR(&TEMPU)&STR(&BLK44)&STR(&BLK44))\n   SET &NDX = &NDX + 1\nEND\n\nSET &SCOL = 0\nSET &NACHUZ = 0\nSET &LSVAR = &LENGTH(&NRSTR(&SVAR))\nDO WHILE (&SCOL < &LSVAR-8)\n  SET &SCOL = &SCOL + 1\n  IF  &SUBSTR(&SCOL:&SCOL+7,&NRSTR(&SVAR)) = %%JOBNAM THEN +\n    DO\n      SET &NACHUZ = &NACHUZ + 1\n      SET &ACHUZ&NACHUZ = &SCOL\n      SET &SCOL = &SCOL + 8\n      IF (SCOL < &LSVAR) THEN +\n        IF &SUBSTR(&SCOL:&SCOL,&NRSTR(&SVAR)) = E THEN SET &NACHUZ=0\n    END\nEND\n\n/********************/\n/**    DATES CARD  **/\n/********************/\nISPEXEC VGET (CARDD)\n\n/***********************/\n/**    WEEKDAYS CARD  **/\n/***********************/\nISPEXEC VGET (NWCARD)\nIF (&NWCARD=1) THEN +\n        ISPEXEC VGET (CARDW)\n\n/********************************************************/\n/**    INITIALIZE TO TOP OF THE TABLE                  **/\n/********************************************************/\n\nISPEXEC CONTROL ERRORS RETURN\nISPEXEC TBTOP     CTMPKT00\n\n\n/********************************************************/\n/**    FOR OPT 2 AND 3, CREATE OUTCOND TABLE           **/\n/********************************************************/\n\nIF ((&OPT = 2) OR (&OPT=3)) THEN +\n  DO\n    ISPEXEC TBTOP CTMPKT00\n    SET &MADE = 0\n    DO WHILE (&MADE = 0)\n      ISPEXEC TBSKIP CTMPKT00\n      SET &RC = &LASTCC\n      IF &RC = 8 THEN SET &MADE = 1\n      IF (&MADE = 0) THEN +\n        DO\n          SET &NDX = 1\n          SET &TOJOB = &NRSTR(&JNAM)\n          DO WHILE (&NDX <= &NUMDEPS)\n\n            SET &FRJOBNAM = &NUL\n            SET &FRJOBNUM = 0\n\n            SET &TY = &&T&NDX\n            SET &TY = &TY\n\n            IF &TY\u00ac=C THEN +\n              DO\n                IF &TY = M THEN SET &FRJOBNUM = &JNUM - 1\n                ELSE IF &TY = N THEN +\n                     SET &FRJOBNUM = &SYSNSUB(2,&&DJ&NDX)\n                ELSE IF &TY = A THEN +\n                     SET &FRJOBNAM = &SYSNSUB(2,&&DJ&NDX)\n                ISPEXEC TBADD CTMPKT99\n              END /* NOT A TYPE C DEPENDENCE */\n\n            SET &NDX = &NDX + 1\n          END /* LOOPING OVER DEPENDENCIES */\n        END  /* OF A ROW IN THE TABLE */\n    END  /* MAKING THE TABLE */\n  END\n\n\n/********************************************************/\n/**    OPEN THE FILE  FOR OUTPUT                       **/\n/********************************************************/\n\nISPEXEC LMFREE DATAID(&CTMPKOT)  /* IN CASE SOMETHING THERE */\n\nSET &IOERROR=Y\nSET &CTMPKOT=&NUL\nISPEXEC VPUT (CTMPKOT IOERROR)\n\nISPEXEC LMINIT  DATAID(CTMPKOT) DATASET('&OLIB') ENQ(SHRW)\nSET &RC = &LASTCC\nIF &RC \u00ac= 0 THEN +\n   DO\n     ISPEXEC SETMSG MSG(CTMK003Z)\n     EXIT QUIT\n   END\n\nISPEXEC VPUT (CTMPKOT)\n\nISPEXEC LMOPEN  DATAID(&CTMPKOT) OPTION(OUTPUT)\nSET &RC = &LASTCC\nIF &RC \u00ac= 0 THEN +\n   DO\n     ISPEXEC SETMSG MSG(CTMK003Z)\n     EXIT QUIT\n   END\n\n\nSET &DONE = 0\nSET &JNAM = &NUL\nDO WHILE (&DONE = 0)\n/********************************************************/\n/**    GET NEXT LINE OF THE TABLE                      **/\n/********************************************************/\n    SET &PREVJOB = &NRSTR(&JNAM)\n    ISPEXEC TBSKIP CTMPKT00 POSITION(SAVEROW)\n    SET &RC = &LASTCC\n    IF &RC = 8 THEN +\n      DO\n         SET &DONE = 1    /* END OF THE TABLE WAS REACHED */\n      END\n\n    IF (Z&NRSTR(&JNAM) \u00ac= Z) AND (&DONE=0)  THEN +\n      DO\n\n      /**********************************************/\n      /**    CREATE SCHED TABLE ENTRY FOR JOB      **/\n      /**********************************************/\n\n       SET &PADJOB = &STR(&SUBSTR(1:8,&NRSTR(&JNAM)&BLK44))\n\n      /********************/\n      /**  MEMBERS CARD  **/\n      /********************/\n\n       IF (&NRSTR(&GRP)\u00ac=&NUL) THEN +\n       SET &TEMPU=M&NRSTR(&PADJOB)&SUBSTR(1:20,&NRSTR(&GRP)&STR(&BLK44))\n       ELSE +\n         SET &TEMPU=M&NRSTR(&PADJOB)&SUBSTR(10:29,&NRSTR(&CARDM))\n       SET &CARDM = &NRSTR(&TEMPU)&SUBSTR(30:80,&NRSTR(&CARDM))\n\n      /********************/\n      /**  DOCUMENT CARD **/\n      /********************/\n\n       SET &CARDZ = Z&NRSTR(&PADJOB)&SUBSTR(10:80,&NRSTR(&CARDZ))\n\n      /********************/\n      /**  DESCRIPTION   **/\n      /********************/\n\n       SET &TEMPU = H&SUBSTR(1:50,&NRSTR(&DESC)&STR(&BLK44)&STR(&BLK44))\n       SET &CARDH = &NRSTR(&TEMPU)&SUBSTR(52:80,&NRSTR(&CARDH))\n\n      /********************/\n      /**  SHOUT    CARD **/\n      /********************/\n\n       SET &ACHUZX = 1\n       DO WHILE (&ACHUZX <= &NACHUZ)\n         SET &ACHUZCOL = &&ACHUZ&ACHUZX\n         SET &TEMPU = &STR(&SUBSTR(  +\n               1:&ACHUZCOL-1,&NRSTR(&SVAR))&NRSTR(&PADJOB)\n         SET &TEMPU = &NRSTR(&TEMPU)&STR(&SUBSTR( +\n               &ACHUZCOL+8:&LSVAR,&NRSTR(&SVAR)))\n         SET &SVAR  = &NRSTR(&TEMPU)\n         SET &ACHUZX = &ACHUZX + 1\n       END\n\n      /************************/\n      /**  WRITE D,M,L,H,V   **/\n      /************************/\n\n      ISPEXEC LMPUT DATAID(&CTMPKOT) MODE(INVAR) +\n         DATALOC(CARDD) DATALEN(80)\n      SET &RC = &LASTCC\n      IF &RC \u00ac= 0 THEN +\n         DO\n           ISPEXEC SETMSG MSG(CTMK003Z)\n           EXIT QUIT\n         END\n\n      IF (&NWCARD\u00ac=0) THEN +\n        DO\n          ISPEXEC LMPUT DATAID(&CTMPKOT) MODE(INVAR) +\n             DATALOC(CARDW) DATALEN(80)\n          SET &RC = &LASTCC\n          IF &RC \u00ac= 0 THEN +\n             DO\n               ISPEXEC SETMSG MSG(CTMK003Z)\n               EXIT QUIT\n             END\n        END\n\n      ISPEXEC LMPUT DATAID(&CTMPKOT) MODE(INVAR) +\n         DATALOC(CARDM) DATALEN(80)\n      SET &RC = &LASTCC\n      IF &RC \u00ac= 0 THEN +\n         DO\n           ISPEXEC SETMSG MSG(CTMK003Z)\n           EXIT QUIT\n         END\n\n      ISPEXEC LMPUT DATAID(&CTMPKOT) MODE(INVAR) +\n         DATALOC(CARDL) DATALEN(80)\n      SET &RC = &LASTCC\n      IF &RC \u00ac= 0 THEN +\n         DO\n           ISPEXEC SETMSG MSG(CTMK003Z)\n           EXIT QUIT\n         END\n\n      ISPEXEC LMPUT DATAID(&CTMPKOT) MODE(INVAR) +\n         DATALOC(CARDH) DATALEN(80)\n      SET &RC = &LASTCC\n      IF &RC \u00ac= 0 THEN +\n         DO\n           ISPEXEC SETMSG MSG(CTMK003Z)\n           EXIT QUIT\n         END\n\n      ISPEXEC LMPUT DATAID(&CTMPKOT) MODE(INVAR) +\n         DATALOC(CARDV) DATALEN(80)\n      SET &RC = &LASTCC\n      IF &RC \u00ac= 0 THEN +\n         DO\n           ISPEXEC SETMSG MSG(CTMK003Z)\n           EXIT QUIT\n         END\n\n      /************************/\n      /**  WRITE T CARDS      */\n      /************************/\n\n      SET &NDX = 1\n      DO WHILE &NDX <= &NTCARD\n        ISPEXEC VGET (CARDT&NDX)\n        ISPEXEC LMPUT DATAID(&CTMPKOT) MODE(INVAR) +\n           DATALOC(CARDT&NDX) DATALEN(80)\n        SET &RC = &LASTCC\n        IF &RC \u00ac= 0 THEN +\n           DO\n             ISPEXEC SETMSG MSG(CTMK003Z)\n             EXIT QUIT\n           END\n        SET &NDX = &NDX + 1\n      END\n\n      /************************/\n      /**  WRITE Z CARD       */\n      /************************/\n\n      ISPEXEC LMPUT DATAID(&CTMPKOT) MODE(INVAR) +\n         DATALOC(CARDZ) DATALEN(80)\n      SET &RC = &LASTCC\n      IF &RC \u00ac= 0 THEN +\n         DO\n           ISPEXEC SETMSG MSG(CTMK003Z)\n           EXIT QUIT\n         END\n\n      /************************/\n      /**  CREATE I CARD(S)  **/\n      /************************/\n\n      SET &NDX = 1\n      DO  WHILE &NDX <=  &NUMDEPS\n\n         SET &TJOB = &&T&NDX\n\n         IF &TJOB = C THEN +\n           SET &TEMPU=&SUBSTR(2:21,&NRSTR(&XCOND)&NRSTR(&BLK44))\n         ELSE +\n           DO\n\n             IF &TJOB = M THEN SET &DJOB = &NRSTR(&PREVJOB)\n\n             IF &TJOB = A THEN SET &DJOB = &SYSNSUB(2,&&DJ&NDX)\n\n             IF &TJOB = N THEN +\n               DO\n                 SET &DJOB = &&DJ&NDX\n                 SET &DJOB = &DJOB\n                 ISPEXEC TBTOP CTMPKT00\n                 ISPEXEC TBSKIP CTMPKT00 NUMBER(&DJOB)\n                 SET &DJOB = &NRSTR(&JNAM)\n                 ISPEXEC TBTOP CTMPKT00\n                 ISPEXEC TBSKIP CTMPKT00 NUMBER(&SAVEROW)\n               END\n\n             IF &OPT=1 THEN +\n     SET &TEMPU = &NRSTR(&SGRP)&STR(-)&NRSTR(&DJOB)&STR(-)&NRSTR(&SF)\n\n             IF &OPT=2 THEN +\n     SET &TEMPU = &NRSTR(&DJOB)&STR(-)&NRSTR(&JNAM)&STR(-)&NRSTR(&SF)\n\n             IF &OPT=3 THEN +\n     SET &TEMPU = &NRSTR(&SF)&STR(-)&NRSTR(&DJOB)&STR(-)&NRSTR(&JNAM)\n\n           END /* NOT AN ASTERISK  */\n\n         SET &TEMPU = &STR(&SUBSTR(1:20,&NRSTR(&TEMPU)&STR(&BLK44)))\n         SET &CARDI = I&NRSTR(&TEMPU)&STR(ODAT)\n\n         ISPEXEC LMPUT DATAID(&CTMPKOT) MODE(INVAR) +\n            DATALOC(CARDI) DATALEN(80)\n         SET &RC = &LASTCC\n         IF &RC \u00ac= 0 THEN +\n            DO\n              ISPEXEC SETMSG MSG(CTMK003Z)\n              EXIT QUIT\n            END\n\n         SET &NDX = &NDX + 1\n      END  /* LOOP OVER SUBFIELDS */\n\n\n      /************************/\n      /**  WRITE E AND Q CARDS*/\n      /************************/\n\n      SET &NDX = 1\n      DO WHILE &NDX <= &NECARD\n        ISPEXEC VGET (CARDE&NDX)\n        ISPEXEC LMPUT DATAID(&CTMPKOT) MODE(INVAR) +\n           DATALOC(CARDE&NDX) DATALEN(80)\n        SET &RC = &LASTCC\n        IF &RC \u00ac= 0 THEN +\n           DO\n             ISPEXEC SETMSG MSG(CTMK003Z)\n             EXIT QUIT\n           END\n        SET &NDX = &NDX + 1\n      END\n\n      SET &NDX = 1\n      DO WHILE &NDX <= &NQCARD\n        ISPEXEC VGET (CARDQ&NDX)\n        ISPEXEC LMPUT DATAID(&CTMPKOT) MODE(INVAR) +\n           DATALOC(CARDQ&NDX) DATALEN(80)\n        SET &RC = &LASTCC\n        IF &RC \u00ac= 0 THEN +\n           DO\n             ISPEXEC SETMSG MSG(CTMK003Z)\n             EXIT QUIT\n           END\n        SET &NDX = &NDX + 1\n      END\n\n      /********************/\n      /**  OUT-COND CARDS**/\n      /********************/\n\n       IF &OPT = 1 THEN +\n         DO\n     SET &TEMPU = &NRSTR(&SGRP)&STR(-)&NRSTR(&JNAM)&STR(-)&NRSTR(&SF)\n           SET &CARDO = +\n             O&STR(&SUBSTR(1:20,&NRSTR(&TEMPU)&STR(&BLK44))ODAT&STR(+)\n           ISPEXEC LMPUT DATAID(&CTMPKOT) MODE(INVAR) +\n              DATALOC(CARDO) DATALEN(80)\n           SET &RC = &LASTCC\n           IF &RC \u00ac= 0 THEN +\n              DO\n                ISPEXEC SETMSG MSG(CTMK003Z)\n                EXIT QUIT\n              END\n         END\n\n       IF ((&OPT=2) OR (&OPT=3)) THEN +\n         DO\n\n           SET &FOUND = 1\n           DO WHILE (&FOUND=1)\n             SET &FRJOBNAM = &NRSTR(&JNAM)\n             ISPEXEC TBTOP CTMPKT99\n           ISPEXEC TBSCAN CTMPKT99 ARGLIST(FRJOBNAM) CONDLIST(EQ)\n             SET &RC = &LASTCC\n             IF &RC = 8 THEN SET &FOUND = 0\n             ELSE  +\n               DO\n                 IF &OPT = 2 THEN +\n     SET &TEMPU=&NRSTR(&JNAM)&STR(-)&NRSTR(&TOJOB)&STR(-)&NRSTR(&SF)\n                 IF &OPT = 3 THEN +\n     SET &TEMPU=&NRSTR(&SF)&STR(-)&NRSTR(&JNAM)&STR(-)&NRSTR(&TOJOB)\n                 SET &CARDO = +\n             O&STR(&SUBSTR(1:20,&NRSTR(&TEMPU)&STR(&BLK44))ODAT&STR(+)\n                 ISPEXEC LMPUT DATAID(&CTMPKOT) MODE(INVAR) +\n                    DATALOC(CARDO) DATALEN(80)\n                 SET &RC = &LASTCC\n                 IF &RC \u00ac= 0 THEN +\n                    DO\n                      ISPEXEC SETMSG MSG(CTMK003Z)\n                      EXIT QUIT\n                    END\n                 ISPEXEC TBDELETE CTMPKT99\n               END   /* WROTE AN O CARD */\n           END\n\n           SET &FOUND = 1\n           DO WHILE (&FOUND=1)\n             SET &FRJOBNUM = &JNUM\n             ISPEXEC TBTOP CTMPKT99\n           ISPEXEC TBSCAN CTMPKT99 ARGLIST(FRJOBNUM) CONDLIST(EQ)\n             SET &RC = &LASTCC\n             IF &RC = 8 THEN SET &FOUND = 0\n             ELSE  +\n               DO\n                 IF &OPT = 2 THEN +\n     SET &TEMPU=&NRSTR(&JNAM)&STR(-)&NRSTR(&TOJOB)&STR(-)&NRSTR(&SF)\n                 IF &OPT = 3 THEN +\n     SET &TEMPU=&NRSTR(&SF)&STR(-)&NRSTR(&JNAM)&STR(-)&NRSTR(&TOJOB)\n                 SET &CARDO = +\n             O&STR(&SUBSTR(1:20,&NRSTR(&TEMPU)&STR(&BLK44))ODAT&STR(+)\n                 ISPEXEC LMPUT DATAID(&CTMPKOT) MODE(INVAR) +\n                    DATALOC(CARDO) DATALEN(80)\n                 SET &RC = &LASTCC\n                 IF &RC \u00ac= 0 THEN +\n                    DO\n                      ISPEXEC SETMSG MSG(CTMK003Z)\n                      EXIT QUIT\n                    END\n                 ISPEXEC TBDELETE CTMPKT99\n               END   /* WROTE AN O CARD */\n           END\n\n\n         END\n\n      /************************/\n      /**WRITE B,R,P,C CARDS **/\n      /************************/\n\n      SET &NDX = 1\n      DO WHILE &NDX <= &NBCARD\n        ISPEXEC VGET (CARDB&NDX)\n        SET &TEMPU = &&CARDB&NDX\n        SET &TEMPU = &STR(&TEMPU)\n        ISPEXEC LMPUT DATAID(&CTMPKOT) MODE(INVAR) +\n           DATALOC(TEMPU) DATALEN(80)\n        SET &RC = &LASTCC\n        IF &RC \u00ac= 0 THEN +\n           DO\n             ISPEXEC SETMSG MSG(CTMK003Z)\n             EXIT QUIT\n           END\n        SET &NDX = &NDX + 1\n      END\n\n      SET &NDX = 1\n      DO WHILE &NDX <= &NRCARD\n        ISPEXEC VGET (CARDR&NDX)\n        SET &TEMPU = &&CARDR&NDX\n        SET &TEMPU = &STR(&TEMPU)\n        ISPEXEC LMPUT DATAID(&CTMPKOT) MODE(INVAR) +\n           DATALOC(TEMPU) DATALEN(80)\n        SET &RC = &LASTCC\n        IF &RC \u00ac= 0 THEN +\n           DO\n             ISPEXEC SETMSG MSG(CTMK003Z)\n             EXIT QUIT\n           END\n        SET &NDX = &NDX + 1\n      END\n\n      SET &NDX = 1\n      DO WHILE &NDX <= &NPCARD\n        ISPEXEC VGET (CARDP&NDX)\n        ISPEXEC LMPUT DATAID(&CTMPKOT) MODE(INVAR) +\n           DATALOC(CARDP&NDX) DATALEN(80)\n        SET &RC = &LASTCC\n        IF &RC \u00ac= 0 THEN +\n           DO\n             ISPEXEC SETMSG MSG(CTMK003Z)\n             EXIT QUIT\n           END\n        SET &NDX = &NDX + 1\n      END\n\n      SET &NDX = 1\n      DO WHILE &NDX <= &NCCARD\n        ISPEXEC VGET (CARDC&NDX)\n        ISPEXEC LMPUT DATAID(&CTMPKOT) MODE(INVAR) +\n           DATALOC(CARDC&NDX) DATALEN(80)\n        SET &RC = &LASTCC\n        IF &RC \u00ac= 0 THEN +\n           DO\n             ISPEXEC SETMSG MSG(CTMK003Z)\n             EXIT QUIT\n           END\n        SET &NDX = &NDX + 1\n      END\n\n      /************************/\n      /**  WRITE SHOUT CARDS **/\n      /************************/\n\n      SET &NDX = 1\n      DO WHILE &NDX <= &NSHOUT\n        SET &CEND = 79 * &NDX\n        SET &CBEG = &CEND-78\n        SET &OUTSHT = S&SUBSTR(&CBEG:&CEND,&NRSTR(&SVAR))\n        ISPEXEC LMPUT DATAID(&CTMPKOT) MODE(INVAR) +\n           DATALOC(OUTSHT) DATALEN(80)\n        SET &RC = &LASTCC\n        IF &RC \u00ac= 0 THEN +\n           DO\n             ISPEXEC SETMSG MSG(CTMK003Z)\n             EXIT QUIT\n           END\n        SET &NDX = &NDX + 1\n      END\n\n      END   /* END PROCESSING A TABLE LINE */\n\nEND /* ALL LINES PROCESSED */\n\nIF (&MFOUND=N) THEN +\n  DO\n    ISPEXEC SETMSG MSG(CTMK003A)\n    ISPEXEC LMMADD  DATAID(&CTMPKOT) MEMBER(&NRSTR(&OTABLE))\n    SET &RC = &LASTCC\n  END\n\nIF (&MFOUND=Y) THEN +\n  DO\n    ISPEXEC SETMSG MSG(CTMK003H)\n    ISPEXEC LMMREP  DATAID(&CTMPKOT) MEMBER(&NRSTR(&OTABLE))\n    SET &RC = &LASTCC\n  END\n\nIF &RC \u00ac= 0 THEN +\n  DO\n    IF ((&ZERRMSG\u00ac=ISRLS080) AND (&ZERRMSG\u00ac=ISPS109)) THEN +\n      DO\n        ISPEXEC SETMSG MSG(CTMK003Z)\n        EXIT QUIT\n      END\n    ISPEXEC LMMADD  DATAID(&CTMPKOT) MEMBER(&TEMPNAME)\n    SET &RC = &LASTCC\n    IF &RC \u00ac= 0 THEN +\n      DO\n        ISPEXEC SETMSG MSG(CTMK003Z)\n        EXIT QUIT\n      END\n    SET &CTMCKSV=MEMRENAM\n    ISPEXEC VPUT (CTMCKSV)\n    CTMTQSR       /* RENAME TEMP MEMBER NAME TO REAL NAME */\n    ISPEXEC VGET (IOERROR)\n    IF (&IOERROR=Y) THEN +\n      DO\n        ISPEXEC SETMSG MSG(CTMK003Z)\n        EXIT QUIT\n      END\n  END\n\nISPEXEC LMCLOSE DATAID(&CTMPKOT)\nSET &RC = &LASTCC\nIF (&RC \u00ac= 0) THEN +\n   DO\n     ISPEXEC SETMSG MSG(CTMK003Z)\n     EXIT QUIT\n   END\n\nISPEXEC LMFREE  DATAID(&CTMPKOT)\nSET &RC = &LASTCC\nIF (&RC \u00ac= 0) THEN +\n   DO\n     ISPEXEC SETMSG MSG(CTMK003Z)\n     EXIT QUIT\n   END\n\nSET &CTMPKOT=&NUL\nSET &IOERROR=N\n\nISPEXEC VPUT (CTMPKOT IOERROR)\n\nEXIT\n\nEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CTMCND": {"ttr": 6920, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x10_\\x00\\x94\\x10_\\x04\\x10\\x00B\\x00B\\x00\\x00\\xc9\\xd6\\xc1\\xf4\\xf1\\xf0@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-04-15T00:00:00", "modifydate": "1994-04-15T04:10:00", "lines": 66, "newlines": 66, "modlines": 0, "user": "IOA410"}, "text": "PROC 0 DD()                 +\n       MM()                 +\n       FUNC()               +\n       COND()               +\n       DATEFMT(USA)   +\n       DBPREFA(SYSS.IOA)   +\n       DBVERA(V410)     +\n       LOADLIB(SYS1.IOA.V410.LOAD)   +\n       LANG()         +\n       DBG(DUMMY)\n/*******************************************************************/\n/*                                                                 */\n/* THIS CLIST IS SIMILAR TO THE CTMCCND CLIST, BUT WITHOUT DISPLAY */\n/* OF PANEL.  THE PANEL INFORMATION IS TRANSFERED VIA PARAMETERS   */\n/* TO CLIST. E.G., DD() MM() FUNC() AND COND().                    */\n/*                                                                 */\n/*******************************************************************/\nWRITE\nWRITE *** CTMCND CLIST STARTED\nWRITE\nFREE F(PRTDBG,DALOG,DASINC,DARESF,DAPRINT)\nSET &MAXCC=0     /* THIS IS BECAUSE THE FREE COMMAND RETURNS 12 */\nALLOC F(PRTDBG) &DBG SYSOUT(A)  HOLD\n\nALLOC DD(DALOG)    DA('&DBPREFA..&DBVERA..LOG') SHR\nIF &LASTCC\u00ac=0 +\nTHEN +\n   WRITE *** ALLOCATION FOR DDNAME=DALOG    FAILED. RC=&LASTCC\n\nALLOC DD(DASINC)   DA('&DBPREFA..&DBVERA..SNC') SHR\nIF &LASTCC\u00ac=0 +\nTHEN +\n   WRITE *** ALLOCATION FOR DDNAME=DASINC   FAILED. RC=&LASTCC\n\nALLOC DD(DARESF)   DA('&DBPREFA..&DBVERA..RES') SHR\nIF &LASTCC\u00ac=0 +\nTHEN +\n   WRITE *** ALLOCATION FOR DDNAME=DARESF   FAILED. RC=&LASTCC\n\nALLOC DD(DAPRINT)  DS(*)\n\n                             /* IF NO DD() MM() GIVEN, TAKE TODAYS */\nIF &MM= +\nTHEN +\n   SET &MM=&SUBSTR(1:2,&SYSDATE)\nIF &DD= +\nTHEN +\n   SET &DD=&SUBSTR(4:5,&SYSDATE)\n\nSET &CTMFUN=&STR(&FUNC)\nSET &CTMCONDN=&STR(&COND)\n\nIF &DATEFMT=JPN  +\n   THEN CALL  '&LOADLIB&LANG(CTMCND)' '&CTMFUN COND &CTMCONDN &MM.&DD'\n   ELSE +\nIF &DATEFMT=USA  +\n   THEN CALL  '&LOADLIB&LANG(CTMCND)' '&CTMFUN COND &CTMCONDN &MM.&DD'\n   ELSE CALL  '&LOADLIB&LANG(CTMCND)' '&CTMFUN COND &CTMCONDN &DD.&MM'\n   SET &RC=&LASTCC\n   WRITE *** CTMCND PROGRAM ENDED WITH RC=&RC.\n\nWRITE\nWRITE *** CTMCND CLIST ENDED\nWRITE\n /* RETURN CODE TO IKJEFT01 */\nEXIT CODE(&MAXCC)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CTMCSIM": {"ttr": 6922, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x10_\\x00\\x94\\x10_\\x04\\x10\\x00\\xdc\\x00\\xdc\\x00\\x00\\xc9\\xd6\\xc1\\xf4\\xf1\\xf0@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-04-15T00:00:00", "modifydate": "1994-04-15T04:10:00", "lines": 220, "newlines": 220, "modlines": 0, "user": "IOA410"}, "text": " /********************************************************************/\n /*                                                                  */\n /*       INTERACTIVE BUILD OF SIMULATION JOB                        */\n /*                                                                  */\n /*              CTMCSIM - RELEASE 3.0.0                             */\n /*                                                                  */\n /********************************************************************/\n\nPROC 0 DEBUG SKELETON(CTMPSIMS)                 /* SKELETON NAME */ +\n                                                   +\n   /* PARAMETERS WHOSE VALUES ARE INSERTED DURING INSTALLATION */ +\n                                                    +\n             ILPREFM(SYSM.CTMI)  ILVERM(V410)   +\n             OLPREFM(SYSS.CTMO)  OLVERM(V410)   +\n             DBPREFM(SYSS.CTMO)  DBVERM(V410)   +\n             DBVOLM(SYS021)    DBUNITM(3390) +\n             DATEFMT(USA)                     +\n                                                    +\n           SIM(Y)          /* DEFAULT OF PANEL-DEFINED VARIABLES */ +\n           STN(Y)                                                   +\n           DW('  ') MW('  ') YW('  ')                               +\n           SNA(N)   SOR(N)   SKA(Y)                                 +\n           SIMPARM(SIMPARM)                                         +\n           RJL(Y) RNS(Y)  TAP(N)  TVL(Y)  TTM(Y)  TJB(N)  TDS(N)    +\n           JS(Y) JSJ(Y)  JSE(N)  JSS(N)                             +\n           TAPULPRM(TAPULPRM)\n\nIF &DEBUG=DEBUG THEN CONTROL LIST CONLIST SYMLIST MSG FLUSH\n                ELSE CONTROL NOLIST NOCONLIST NOSYMLIST NOMSG NOFLUSH\n\nISPEXEC CONTROL ERRORS RETURN\n\nISPEXEC VGET JOBSCAN PROFILE\nIF &JOBSCAN=YES THEN +\n  SET &PANEL=CTMPSIMJ\nELSE +\n  DO\n    SET &PANEL=CTMPSIM\n    SET &JS=N\n  END\nISPEXEC VPUT DATEFMT PROFILE\n\nSET &UID=&SUBSTR(1:3,&SYSUID.XXX)           /* FOR JOBNAME'S PREFIX */\nSET &YY=&SUBSTR(7:8,&SYSDATE)\nSET &MM=&SUBSTR(1:2,&SYSDATE)\nSET &DD=&SUBSTR(4:5,&SYSDATE)\n\nSET &SIMFROM = &STR(&YY.&MM.&DD.0900)  /* ITS ALWAYS THE SAME FORMAT */\nSET &SIMUNTL = &STR(&YY.&MM.&DD.1600)\n\n/* SAVE THE DEFAILT VALUES OF THE FIRST SECTION OF PARAMETERS */\nSET &DEFAULT1=&STR(&SIMFROM.&SIMUNTL.&SNA.&SOR)\n\nSET &CURSOR=SIM                    /* THE DEFAULT CURSOR FIELD */\nDISPLAYP: +\nISPEXEC DISPLAY PANEL(&PANEL) CURSOR(&CURSOR)\nSET &RC=&LASTCC\nSET &CURSOR=SIM\n\nIF &RC=8 +\nTHEN +\n   GOTO EXIT                            /* PF03/15 WAS KEYED IN PANEL */\nELSE +\n   IF &RC\u00ac=0 +\n   THEN +\n      DO\n         WRITE UNABLE TO LOCATE PANEL &PANEL . (  RC=&RC  )\n         EXIT\n      END\n\n                     /* WHEN NO SIMULATION IS WANTED ( JUST REPORTS ) */\nIF &SIM=N +\nTHEN +\n  DO\n    /* CHECK VALUES OF THE FIRST SECTION OF PARAMETERS AGAINST DEFAULT*/\n   SET &SECTION1=&STR(&SIMFROM.&SIMUNTL.&SNA.&SOR)\n   IF '&SECTION1'\u00ac='&DEFAULT1' +\n   THEN +\n   ISPEXEC SETMSG MSG(CTMS001W) /* WARNING, NON-RELEVANT PARAMS */\n   GOTO PREPJOB   /* ANYWAY, WHEN &SIM=N, FOLLOWING CHECKS NOT NEEDED */\n  END\n\n   /* CREATE_NEW_AJF AND ORDER_DAILY  ALLOWED  ONLY WHEN TONIGHT=N  */\nIF &STN=Y +\nTHEN +\n   IF  ( &SNA=Y OR &SOR=Y )   THEN  GOTO ERR8\n\n    /*      VALIDITY CHECKS ON THE SIMFROM AND SIMUNTL DATES       */\nIF  &LENGTH(&STR(&SIMFROM)) \u00ac= 10             THEN  GOTO ERR2\nIF  &DATATYPE(&SUBSTR(1:5,&SIMFROM)) \u00ac= NUM   THEN  GOTO ERR2\nIF  &DATATYPE(&SUBSTR(6:10,&SIMFROM))\u00ac= NUM   THEN  GOTO ERR2\nIF  ( &SUBSTR(3:4,&SIMFROM) <01  OR  &SUBSTR(3:4,&SIMFROM) > 12   OR +\n      &SUBSTR(5:6,&SIMFROM) <01  OR  &SUBSTR(5:6,&SIMFROM) > 31   OR +\n      &SUBSTR(1:2,&SIMFROM) <86  OR  &SUBSTR(1:2,&SIMFROM) > 99   OR +\n      &SUBSTR(7:8,&SIMFROM) <01  OR  &SUBSTR(7:8,&SIMFROM) > 24   OR +\n      &SUBSTR(9:10,&SIMFROM) <00 OR  &SUBSTR(9:10,&SIMFROM) > 59  )   +\n                                              THEN  GOTO ERR2\nIF  &LENGTH(&STR(&SIMUNTL)) \u00ac= 10             THEN  GOTO ERR3\nIF  &DATATYPE(&SUBSTR(1:5,&SIMUNTL)) \u00ac= NUM   THEN  GOTO ERR3\nIF  &DATATYPE(&SUBSTR(6:10,&SIMUNTL))\u00ac= NUM   THEN  GOTO ERR3\nIF  ( &SUBSTR(3:4,&SIMUNTL) <01  OR  &SUBSTR(3:4,&SIMUNTL) > 12   OR +\n      &SUBSTR(5:6,&SIMUNTL) <01  OR  &SUBSTR(5:6,&SIMUNTL) > 31   OR +\n      &SUBSTR(1:2,&SIMUNTL) <86  OR  &SUBSTR(1:2,&SIMUNTL) > 99   OR +\n      &SUBSTR(7:8,&SIMUNTL) <01  OR  &SUBSTR(7:8,&SIMUNTL) > 24   OR +\n      &SUBSTR(9:10,&SIMUNTL) <00 OR  &SUBSTR(9:10,&SIMUNTL) > 59  )   +\n                                              THEN  GOTO ERR3\nIF  &SUBSTR(1:10,&SIMUNTL) < &SUBSTR(1:10,&SIMFROM) THEN  GOTO ERR4\n\nIF ( &RJL=Y AND &SKA=N ) +\nTHEN +\n   GOTO ERR9             /* FOR SKL REPORT, SIMOAJF MUST BE CREATED */\n\nIF ( &STN=Y AND &STR(&DW.&MW.&YW)\u00ac=   ) +\nTHEN +\n   GOTO ERR5                   /* ANOTHER DATE VALID ONLY WITH STN=N */\n\nIF &STN=N +\nTHEN +\n   DO\n      IF ( &DW>31 OR &DW<1 OR &MW<1 OR &MW>12 ) +\n      THEN +\n        GOTO ERR1               /* INVALID DATE ,DISPLAY MESSAGE */\n\n    SET &PYW=&YW                 /**** CALCULATE PREVIOUS DAY *****/\n    IF &DW GT 1 THEN DO\n                      SET &PDW=&DW-1\n                      SET &PMW=&MW\n                     END\n          ELSE DO\n           IF &MW GT 1 THEN  SET &PMW = &MW-1\n              ELSE DO\n               SET &PMW=12\n               SET &PYW=&YW-1\n              END\n           SET &PDW=31\n           IF &PMW=4 OR &PMW=6 OR &PMW=9 OR &PMW=11 THEN SET &PDW=30\n           IF &PMW=2  THEN SET &PDW=28\n           IF &PMW=2 AND (&YY=88 OR &YY=92 OR &YY=96) THEN SET &PDW=29\n          END\n    SET &PYW=&SUBSTR(2:3,&EVAL(&PYW+100))\n    SET &PMW=&SUBSTR(2:3,&EVAL(&PMW+100))\n    SET &PDW=&SUBSTR(2:3,&EVAL(&PDW+100))\n\n    IF &DATEFMT=JPN +\n    THEN +\n       DO\n          SET &DATEW=&STR(&YW.&MW.&DW)\n          SET &PDATE=&STR(&PYW.&PMW.&PDW)     /* PREVIOUS DAY */\n       END\n    ELSE +\n    IF &DATEFMT=USA +\n    THEN +\n       DO\n          SET &DATEW=&STR(&MW.&DW.&YW)\n          SET &PDATE=&STR(&PMW.&PDW.&PYW)     /* PREVIOUS DAY */\n       END\n    ELSE +\n       DO\n          SET &DATEW=&STR(&DW.&MW.&YW)\n          SET &PDATE=&STR(&PDW.&PMW.&PYW)     /* PREVIOUS DAY */\n       END\n\n                              /* THE FOLLOWING - AS THE CTMLCK DSECT */\nSET DACHK=&STR(+\n&DATEW           &PDATE &PDATE            &PDATE &PDATE    &PDATE &PDATE)\n   END                  /****** END TONIGHT=N  *******/\n\nPREPJOB: +\nSET &SEPERATE=&STR(-----------------------------------------------------\n---------------*)\n\nISPEXEC FTOPEN TEMP\nISPEXEC FTINCL &SKELETON\nSET &RC=&LASTCC\nIF &RC=8  THEN GOTO ERR6                    /* SKELETON WAS NOT FOUND */\nELSE IF &RC=12 THEN GOTO ERR7      /* SKELETON MEMBER IS ALREADY OPEN */\n\nISPEXEC FTCLOSE\nISPEXEC VGET (ZTEMPF,ZTEMPN) ASIS\n\nISPEXEC LMFREE DATAID(TEMP)\nISPEXEC LMINIT DATAID(TEMP) DDNAME(&ZTEMPN)\nISPEXEC EDIT DATAID(&TEMP)      /* EDIT THE PREPARED JOB */\nISPEXEC LMFREE DATAID(TEMP)\nGOTO   DISPLAYP                   /* BM 1783 */\n\n /* *** REMARK ***                                                   */\n /* IF THIS SPF VERSION DOES NOT SUPPORT THESE OPTIONS, THEN REPLACE */\n /* THE LAST 4 COMMANDS BY :                                         */\n /*    ISPEXEC EDIT DATASET(&ZTEMPF)                            */\n\nEXIT: EXIT\n\n ERR1:   ISPEXEC SETMSG MSG(CTMS001E)\n SET &CURSOR=DW\n GOTO DISPLAYP\n ERR2:   ISPEXEC SETMSG MSG(CTMS002E)\n SET &CURSOR=SIMFROM\n GOTO DISPLAYP\n ERR3:   ISPEXEC SETMSG MSG(CTMS003E)\n SET &CURSOR=SIMUNTL\n GOTO DISPLAYP\n ERR4:   ISPEXEC SETMSG MSG(CTMS004E)\n SET &CURSOR=SIMUNTL\n GOTO DISPLAYP\n ERR5:   ISPEXEC SETMSG MSG(CTMS005E)\n SET &CURSOR=STN\n GOTO DISPLAYP\n ERR6:   ISPEXEC SETMSG MSG(CTMS006E)\n GOTO DISPLAYP\n ERR7:   ISPEXEC SETMSG MSG(CTMS007E)\n GOTO DISPLAYP\n ERR8:   ISPEXEC SETMSG MSG(CTMS008E)\n SET &CURSOR=STN\n GOTO DISPLAYP\n ERR9:   ISPEXEC SETMSG MSG(CTMS010E)\n SET &CURSOR=SKA\n GOTO DISPLAYP\n\n END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CTMDT": {"ttr": 7172, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x10_\\x00\\x94\\x10_\\x04\\x10\\x00\\n\\x00\\n\\x00\\x00\\xc9\\xd6\\xc1\\xf4\\xf1\\xf0@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-04-15T00:00:00", "modifydate": "1994-04-15T04:10:00", "lines": 10, "newlines": 10, "modlines": 0, "user": "IOA410"}, "text": "ISREDIT MACRO\nSET &ECODE = 0\nISREDIT FIND '// THIS RECORD WAS ADDED BY CONTROL-M TO FAIL ' 1\nIF &LASTCC = 4 THEN +\n  ISREDIT JSCAN\nELSE +\n  SET &ECODE = 8\nISPEXEC VPUT ECODE SHARED\nISREDIT CANCEL\nISREDIT MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CTMEXEC": {"ttr": 7174, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x10_\\x00\\x94\\x10_\\x04\\x10\\x03\\x1e\\x03\\x1e\\x00\\x00\\xc9\\xd6\\xc1\\xf4\\xf1\\xf0@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-04-15T00:00:00", "modifydate": "1994-04-15T04:10:00", "lines": 798, "newlines": 798, "modlines": 0, "user": "IOA410"}, "text": " PROC 0 PLANID()               /* PLAN NAME 1-6 CHARACTERS      */   +\n        SUFFIX()               /* SUFFIX TO PLAN NAME   0-2 CHR */   +\n        REMAIN()               /* DISPLAY UNASSIGNED VARIABLES  */   +\n        DATE()                 /* REQUIRED DATE - DEFAULT TODAY */   +\n        TIME()                 /* TIME LIMIT FOR JOBS RUN       */   +\n        OLPREFA(SYSS.IOA)                   +\n        OLVERA(V410)                     +\n        DAYTBLB(SYSS.CTMO.V410.SCHD) +\n        UPPTBLB(SYSS.CTMO.V410.PLAN) +\n        AELIBNM(SYSS.CTMO.V410.AEDI) +\n        DBPREFA(SYSS.IOA) +\n        DBPREFM(SYSS.CTMO) +\n        DBVERA(V410)   +\n        DBVERM(V410)   +\n        DATEFMT(USA) +\n        DEBUG()\n /*******************************************************************/\n /**                                                               **/\n /**              C  T  M  E  X  E  C                              **/\n /**             =====================                             **/\n /**                                                               **/\n /**  PARAMETER PROMPTING FACILITY - TYPE2                         **/\n /**                                                               **/\n /**  THIS CLIST IS THE THIRD PHASE OF THE PARAMETERS PROMPTING    **/\n /**  FACILITY (FIRST PHASE IS THE MASTER PLAN DEFINITION, AND     **/\n /**  THE SECOND PHASE IS FETCHING THE PLAN).                      **/\n /**  CTMEXEC PERFORMS THE PROMPTING OF THE PARAMETERS AND AFTER   **/\n /**  IT IS COMPLETED, IT ORDERES THE PLAN TO CONTROL-M.           **/\n /**                                                               **/\n /**  THE CLIST PERFORMS THE FOLLOWING OPERATIONS:                 **/\n /**  1. LET THE USER TO SELECT THE REQUIRED UPP FOR UPDTING.      **/\n /**     THE POSSIBILITIES ARE:                                    **/\n /**     - WORK ON SPECIFIC PLANID ( WHEN PLANID NE \" \" )          **/\n /**     - GET A LIST OF PLANS     ( WHEN PLANID EQ \" \" )          **/\n /**     - GET ALL THE UPPS WHICH STILL HAS UNASSIGNED VARIABLES   **/\n /**       ONE AFTER THE OTHER     ( WHEN REMAIN EQ YES)           **/\n /**                                                               **/\n /**  2. PROMPT THE REQUIRED VARIABLES FOR THEIR VALUES.           **/\n /**                                                               **/\n /**  3. WHEN ALL THE VARIABLES HAVE VALUES, CALL CTMJOB TO ORDER  **/\n /**     THE PLAN.                                                 **/\n /**                                                               **/\n /*******************************************************************/\n /* WM1286 AM 200992 SUPPORT JAPANESE DATE */\n IF &DEBUG = DEBUG      +\n THEN                   +\n    CONTROL CAPS MSG LIST SYMLIST CONLIST\n ELSE                   +\n   CONTROL CAPS NOMSG NOLIST NOSYMLIST NOCONLIST NOFLUSH\n ISPEXEC CONTROL ERRORS RETURN\n\n /* DISPLAY PANEL TO GET THE REQUIRED PARAMETERS OR UPDATE THEM  */\n IF &PLANID = &STR() +\n THEN +\n    DO\n       SET &TEMP = &PLANID\n       ISPEXEC VGET (PLANID) PROFILE\n       SET &RC = &LASTCC\n       IF &RC \u00ac= 0 +\n       THEN +\n          SET &PLANID = &TEMP\n    END\n IF &REMAIN = &STR() +\n THEN +\n    SET &REMAIN = NO\n SET &TEMP = &DAYTBLB\n ISPEXEC VGET (DAYTBLB) PROFILE\n SET &RC = &LASTCC\n IF &RC \u00ac= 0 +\n THEN +\n    SET &DAYTBLB = &TEMP\n SET &TEMP = &UPPTBLB\n ISPEXEC VGET (UPPTBLB) PROFILE\n SET &RC = &LASTCC\n IF &RC \u00ac= 0 +\n THEN +\n    SET &UPPTBLB = &TEMP\n SET &TEMP = &AELIBNM\n ISPEXEC VGET (AELIBNM) PROFILE\n SET &RC = &LASTCC\n IF &RC \u00ac= 0 +\n THEN +\n    SET &AELIBNM = &TEMP\n IF &DATE = &STR() +\n THEN +\n    DO\n       ISPEXEC VGET (ZDAY,ZMONTH,ZYEAR)\n       IF &DATEFMT = JPN +\n       THEN +\n          SET &DATE = &STR(&ZYEAR.&ZMONTH.&ZDAY)\n       ELSE +\n       IF &DATEFMT = USA +\n       THEN +\n          SET &DATE = &STR(&ZMONTH.&ZDAY.&ZYEAR)\n       ELSE +\n          SET &DATE = &STR(&ZDAY.&ZMONTH.&ZYEAR)\n    END\n DISPPAN: +\n SET &TIME = &STR()\n ISPEXEC DISPLAY PANEL(CTMPF32W)\n SET &RC = &LASTCC\n IF &RC \u00ac= 0 -\n THEN -\n    IF &RC \u00ac= 8 -\n    THEN -\n       DO\n          ISPEXEC SETMSG MSG(CTMF000Z)\n          GOTO END\n       END\n    ELSE -\n       GOTO END\n\n ISPEXEC VPUT (DAYTBLB UPPTBLB AELIBNM ) PROFILE\n\n /* CHECK VALIDITY OF DATE: MUST BE 0(NULL) OR 6 CHARACTERS IN THE */\n /* FORMAT \"DDMMYY\" OR \"MMDDYY\" ACCORDING TO THE DATE TYPE         */\n CHKDT: +\n IF &DATE = &STR() +\n THEN +\n    DO\n       /* THE DEFAULT DATE IS TODAY */\n       ISPEXEC VGET (ZDAY,ZMONTH,ZYEAR)\n       IF &DATEFMT = JPN +\n       THEN +\n          SET &DATE = &STR(&ZYEAR.&ZMONTH.&ZDAY)\n       ELSE +\n       IF &DATEFMT = USA +\n       THEN +\n          SET &DATE = &STR(&ZMONTH.&ZDAY.&ZYEAR)\n       ELSE +\n          SET &DATE = &STR(&ZDAY.&ZMONTH.&ZYEAR)\n    END\n ELSE +\n    DO\n       IF &DATEFMT = JPN +\n       THEN +\n          DO\n             SET &ZYEAR = &SUBSTR(1:2,&DATE)\n             SET &ZDAY = &SUBSTR(5:6,&DATE)\n             SET &ZMONTH = &SUBSTR(3:4,&DATE)\n          END\n       ELSE +\n       IF &DATEFMT = USA +\n       THEN +\n          DO\n             SET &ZDAY = &SUBSTR(3:4,&DATE)\n             SET &ZMONTH = &SUBSTR(1:2,&DATE)\n             SET &ZYEAR = &SUBSTR(5:6,&DATE)\n          END\n       ELSE +\n          DO\n             SET &ZYEAR = &SUBSTR(5:6,&DATE)\n             SET &ZDAY = &SUBSTR(1:2,&DATE)\n             SET &ZMONTH = &SUBSTR(3:4,&DATE)\n          END\n       IF &ZDAY < 1 OR &ZDAY > 31 +\n       THEN +\n          DO\n              ISPEXEC SETMSG MSG(CTMF000E)\n              GOTO DISPPAN\n          END\n       IF &ZMONTH < 1 OR &ZMONTH > 12 +\n       THEN +\n          DO\n              ISPEXEC SETMSG MSG(CTMF000E)\n              GOTO DISPPAN\n          END\n    END\n\n /* SET &ORDDATE = &ZYEAR.&ZMONTH.&ZDAY\n SET &ORDDATE = &STR(&ZMONTH.&ZDAY)\n\n /* FIND OUT THE OPERATING MODE ACCORDING TO THE INPUT PARMS */\n CHKPARMS: +\n IF &REMAIN \u00ac= YES AND &PLANID \u00ac= &STR() +\n THEN +\n    DO\n       SET &NEWPLNID = &PLANID.&SUFFIX\n\n       /* CHECK THE EXISTENCE OF THE \"USER PROMPTING TABLE\" AND  */\n       /* THE \"DAILY SCHEDULING TABLE\".                          */\n       PLNDAYTB: +\n       SET &DAYLIB = &DAYTBLB.&ORDDATE\n       SET &DSNRC = &SYSDSN('&DAYLIB(&NEWPLNID)')\n       IF &DSNRC \u00ac= OK +\n       THEN +\n          IF &DSNRC = &STR(MEMBER NOT FOUND) +\n          THEN +\n             DO\n                SET &SCHTBLB = &DAYLIB\n                SET &MSGPLAN = &NEWPLNID\n                ISPEXEC SETMSG MSG(CTMF000G)\n                GOTO DISPPAN\n             END\n          ELSE +\n             DO\n                SET &ERRDSN = &DAYLIB\n                ISPEXEC SETMSG MSG(CTMF000F)\n                GOTO DISPPAN\n             END\n\n       ISPEXEC VPUT (PLANID) PROFILE\n\n       PLNUPPTB: +\n       SET &UPPLIB = &UPPTBLB.&ORDDATE\n       SET &DSNRC = &SYSDSN('&UPPLIB(&NEWPLNID)')\n       IF &DSNRC \u00ac= OK +\n       THEN +\n          IF &DSNRC = &STR(MEMBER NOT FOUND) +\n          THEN +\n             DO\n                SET &TABNAME = &PLANID\n                SET &TBLIB = &UPPLIB\n                ISPEXEC SETMSG MSG(CTMF005C)\n                GOTO DISPPAN\n             END\n          ELSE +\n             DO\n                SET &ERRDSN = &UPPLIB\n                ISPEXEC SETMSG MSG(CTMF000F)\n                GOTO DISPPAN\n             END\n       SET &PLANID = &NEWPLNID\n       GOTO AELIBCK\n\n    END\n\n /* CHECK THE EXISTENCE OF THE \"USER PROMPTING TABLE\" AND          */\n /* THE \"DAILY SCHEDULING TABLE\".                                  */\n CHKDAYTB: +\n SET &DAYLIB = &DAYTBLB.&ORDDATE\n SET &DSNRC = &SYSDSN('&DAYLIB')\n IF &DSNRC \u00ac= OK +\n THEN +\n    DO\n       SET &ERRDSN = &DAYLIB\n       ISPEXEC SETMSG MSG(CTMF000F)\n       GOTO DISPPAN\n    END\n\n CHKUPPTB: +\n SET &UPPLIB = &UPPTBLB.&ORDDATE\n SET &DSNRC = &SYSDSN('&UPPLIB')\n IF &DSNRC \u00ac= OK +\n THEN +\n    DO\n       SET &ERRDSN = &UPPLIB\n       ISPEXEC SETMSG MSG(CTMF000F)\n       GOTO DISPPAN\n    END\n\n /* CHECK THE EXISTANCE OF THE DAILY AUTO-EDIT LIBRARY */\n AELIBCK: +\n SET &AELIB = &AELIBNM.&ORDDATE\n SET &DSNRC = &SYSDSN('&AELIB')\n IF &DSNRC \u00ac= OK +\n THEN +\n    DO\n     /* WRITE TRY TO ALLOCATE &AELIB AS A NEW AUTO-EDIT DAILY LIBRARY.\n       SET &MSGDSN = &AELIB\n       ISPEXEC CONTROL DISPLAY LOCK\n       ISPEXEC DISPLAY MSG(CTMF002I)\n       %CTMCALOC MASTLIB(&UPPLIB) DAYLIB(&AELIB)\n       SET &RC = &LASTCC\n       IF &RC = 0 +\n       THEN +\n          GOTO CHKIDXTB\n\n       SET &ERRDSN = &AELIB\n       ISPEXEC SETMSG MSG(CTMF000F)\n       GOTO DISPPAN\n    END\n\n /* CHECK THE EXISTENCE OF THE INDEX TABLE (INDXTBL)    */\n /* THAT KEEPS INFORMATION ABOUT ALL THE UPPS.          */\n CHKIDXTB: +\n SET &UPPDDN = UPPDDN\n ISPEXEC SELECT PGM(CTMTIOT) PARM(&UPPDDN)\n ISPEXEC VGET (TIOTDDN,TIOTDSN,TIOTNUM) SHARED\n IF &TIOTDSN \u00ac= &UPPLIB +\n THEN +\n    DO\n       SET &TIOTNUM = &TIOTNUM + 101\n       SET &TIOTNUM = &SUBSTR(2:3,&TIOTNUM)\n       SET &UPPDDN = &STR(&UPPDDN.&TIOTNUM)\n       ALLOC FILE(&UPPDDN) DA('&UPPLIB') SHR\n       SET &RC = &LASTCC\n       IF &RC \u00ac= 0 +\n       THEN +\n          DO\n             SET &ERRDSN = &UPPLIB\n             ISPEXEC SETMSG MSG(CTMF000F)\n             GOTO DISPPAN\n          END\n    END\n ELSE +\n    SET &UPPDDN = &TIOTDDN\n\n SET &DSNRC = &SYSDSN('&UPPLIB(INDXTBL)')\n IF &DSNRC \u00ac= OK +\n THEN +\n    DO\n        ISPEXEC SETMSG MSG(CTMF001H)\n        GOTO DISPPAN\n    END\n ELSE +\n    DO\n       ISPEXEC TBOPEN INDXTBL LIBRARY(&UPPDDN) NOWRITE\n       SET &RC=&LASTCC\n       IF &RC \u00ac= 0 -\n       THEN +\n          IF &RC = 12 +\n          THEN +\n             DO\n                  ISPEXEC SETMSG MSG(CTMF001B)\n                  GOTO DISPPAN\n             END\n          ELSE +\n             DO\n                ISPEXEC SETMSG MSG(CTMF000A)\n                GOTO DISPPAN\n             END\n    END\n SET &TB1IND = NO\n SET &REMIND = NO\n IF &REMAIN = YES +\n THEN +\n    GOTO OPTREM\n IF &PLANID = &STR() +\n THEN +\n    GOTO OPTLIST\n\n /* TREAT A SPECIFIC PLANID  */\n SET &IXTBNAME = &NEWPLNID\n ISPEXEC TBSCAN INDXTBL ARGLIST(IXTBNAME) CONDLIST(EQ)\n SET &RC = &LASTCC\n IF &RC \u00ac= 0 +\n THEN +\n    DO\n       ISPEXEC TBEND INDXTBL\n       ISPEXEC SETMSG MSG(CTMF001I)\n       GOTO DISPPAN\n    END\n SET &TB1IND = YES\n GOTO PLANSEL\n ENDTB1: +\n ISPEXEC TBEND INDXTBL\n SET &RC = &LASTCC\n GOTO ENDAPEXE\n\n /* PROCEDURE FOR TREATING REMAIN OPTION - DISPLAY ONE BY ONE ALL   */\n /* THE PLANS THAT HAVE MORE VARIABLES TO PROMPT.                   */\n OPTREM: +\n ISPEXEC TBEND INDXTBL\n ISPEXEC TBOPEN INDXTBL LIBRARY(&UPPDDN) WRITE\n SET &RC=&LASTCC\n IF &RC \u00ac= 0 -\n THEN -\n    DO\n       ISPEXEC SETMSG MSG(CTMF000A)\n       GOTO DISPPAN\n    END\n SET &REMIND = YES\n ISPEXEC TBTOP INDXTBL\n ISPEXEC TBVCLEAR INDXTBL\n SET &IXTBEXEC = YES\n ISPEXEC TBSARG INDXTBL NEXT NAMECOND(IXTBEXEC,NE)\n SET &RC = &LASTCC\n SCNLOOP: +\n ISPEXEC TBSCAN INDXTBL\n   SET &RC = &LASTCC\n   IF &RC = 0 +\n   THEN +\n      DO\n         GOTO PLANSEL\n         GOTO SCNLOOP\n      END\n   ELSE +\n      IF &RC \u00ac= 8 +\n      THEN +\n         DO\n             ISPEXEC SETMSG MSG(CTMF000A)\n             GOTO ENDREM\n         END\n      ELSE +\n         ISPEXEC SETMSG MSG(CTMF001J)\n ENDREM: +\n ISPEXEC TBCLOSE INDXTBL LIBRARY(&UPPDDN)\n SET &RC = &LASTCC\n GOTO ENDAPEXE\n\n /* PROCEDURE FOR TREATING PLANS LIST OPTION - DISPLAY THE LIST OF  */\n /* THE PLANS IN THE DAILY LIBRARY AND THE USER CHOOSES A PLAN TO   */\n /* WORK ON.                                                        */\n OPTLIST: +\n ISPEXEC TBTOP INDXTBL\nDISP01: +\n ISPEXEC TBVCLEAR INDXTBL\n SET &IXTBNAME = &STR(&PREFIX.&STR(*))\n ISPEXEC TBSARG INDXTBL\n SET &RC = &LASTCC\n IF &RC = 0 -\n THEN -\n    GOTO REDISP\n ELSE -\n    DO\n      SET &SPFRC = &RC\n      ISPEXEC SETMSG MSG(CTMF000A)\n      GOTO REDISP\n    END\n SET CURNAME = TCMD\nREDISP: +\n IF &REMIND = YES +\n THEN +\n    GOTO SCNLOOP\n ELSE +\n    IF &TB1IND = YES +\n    THEN +\n       GOTO ENDTB1\n ISPEXEC TBDISPL INDXTBL PANEL(CTMPF30W)\n SET &RC = &LASTCC\n IF &RC > 4 -\n THEN -\n    IF &RC > 8 -\n    THEN -\n       DO\n          SET &PFK3 = PFK3\n          ISPEXEC SETMSG MSG(CTMF000Z)\n          GOTO ENDLIST\n       END\n    ELSE -\n       DO\n          SET &PFK3 = PFK3\n          GOTO ENDLIST\n       END\n IF &LENGTH(&TCMD) > 2 -\n THEN -\n    DO\n      SET &CMDPREF = &SUBSTR(1:2,&TCMD)\n      IF &CMDPREF = L /* OR &CMDPREF = L (SMALL)   -  */   +\n      THEN -\n         DO\n            SET &LOCARG = &SUBSTR(3:&LENGTH(&TCMD),&TCMD)\n            SET &LOCARG = &STR(&LOCARG.&STR(*))\n            SET &IXTBNAME = &STR(&LOCARG)\n            ISPEXEC TBSCAN INDXTBL ARGLIST(IXTBNAME) NOREAD\n            SET &RC = &LASTCC\n            IF &RC = 0 -\n            THEN +\n               GOTO REDISP\n            ELSE +\n               IF &RC = 8 +\n               THEN +\n                  DO\n                    ISPEXEC SETMSG MSG(CTMF000B)\n                    GOTO REDISP\n                  END\n               ELSE +\n                  DO\n                    ISPEXEC SETMSG MSG(CTMF000Z)\n                    GOTO REDISP\n                  END\n         END\n      ELSE -\n         DO\n           ISPEXEC SETMSG MSG(CTMF000C)\n           GOTO REDISP\n         END\n    END\n ELSE -\n    IF &TCMD \u00ac= &STR() -\n    THEN -\n       DO\n          ISPEXEC SETMSG MSG(CTMF000C)\n           GOTO REDISP\n       END\n IF &LASTPREF \u00ac= &PREFIX +\n THEN +\n    DO\n       SET &LASTPREF = &PREFIX\n       GOTO DISP01\n    END\n IF &ZTDSELS = 0 -\n THEN +\n    GOTO REDISP\n\n /* TAKE A REFRESH COPY OF THE INDEX TABLE */\n SET &KEEPTBNM = &IXTBNAME\n SET &KEEPTBTM = &STR(&IXTBTIME)\n SET &KEEPTBEX = &IXTBEXEC\n ISPEXEC TBEND INDXTBL\n ISPEXEC TBOPEN INDXTBL LIBRARY(&UPPDDN) NOWRITE\n SET &RC=&LASTCC\n IF &RC = 0 +\n THEN +\n    DO\n       SET &IXTBNAME = &KEEPTBNM\n       ISPEXEC TBSCAN INDXTBL ARGLIST(IXTBNAME) CONDLIST(EQ)\n       SET &RC = &LASTCC\n       IF &RC \u00ac= 0 +\n       THEN +\n          DO\n             ISPEXEC TBEND INDXTBL\n             ISPEXEC SETMSG MSG(CTMF001I)\n             GOTO DISPPAN\n          END\n       IF &KEEPTBEX \u00ac= &IXTBEXEC +\n       THEN +\n          DO\n             ISPEXEC SETMSG MSG(CTMF001L)\n             GOTO DISP01\n          END\n       SET &IXTBTIME = &STR(&KEEPTBTM)\n    END\n ELSE +\n    DO\n       ISPEXEC SETMSG MSG(CTMF001B)\n       GOTO DISPPAN\n    END\n\n /* A GENERAL SECTION FOR TREATING ONE TABLE. WE GET TO THIS SECTION */\n /* FROM ALL THE OPERATING OPTIONS.                                  */\n /* IT CALLS THE PROMPTING PROGRAM WHICH LETS THE USER FILL VALUES.  */\n /* IF ALL THE PARAMETERS HAS VALUES, IT CALLS THE ORDER PROGRAM     */\n /* WHICH BUILD THE AUTO-EDIT MEMBER AND ADDS THE CONDITION.         */\n /* AT LAST, WE OPERATE CTMJOB TO ACTUALY ORDER THE REQUIRED PLAN.   */\n /*                                                                  */\n PLANSEL: +\n IF &TIME \u00ac= &STR() +\n THEN +\n    SET &IXTBTIME = &STR(&TIME)\n SET &CANORDER = NO\n SET &AEDIONLY = NO\n IF &IXTBEXEC = YES +\n THEN +\n    DO\n       SET &AEDIONLY = YES\n    END\n ELSE +\n    SET &AEDIONLY = NO\n\n ISPEXEC TBOPEN &IXTBNAME LIBRARY(&UPPDDN) WRITE\n SET &RC=&LASTCC\n IF &RC \u00ac= 0 -\n THEN -\n    DO\n    /*  ISPEXEC SETMSG MSG(CTMF001C) */\n        ISPEXEC SETMSG MSG(CTMF005E)\n        GOTO DISP01\n    END\n IF &REMIND = YES +\n THEN +\n    ISPEXEC SELECT PGM(CTMTPRP) PARM(NULLS,&IXTBNAME)\n ELSE +\n    ISPEXEC SELECT PGM(CTMTPRP) PARM(ALLTB,&IXTBNAME)\n ISPEXEC VGET (PROMPTRC) SHARED\n IF &PROMPTRC > 4 +\n THEN +\n    DO\n       ISPEXEC TBEND &IXTBNAME\n  /*   WRITE HIGH RC FROM PROMPT PROGRAM &PROMPTRC  */\n  /*   WRITE UNABLE TO CONTINUE WITH THIS TABLE     */\n       GOTO REDISP\n    END\n ISPEXEC TBCLOSE &IXTBNAME LIBRARY(&UPPDDN)\n IF &PROMPTRC = 0 +\n THEN +\n    SET &CANORDER = YES\n ELSE +\n    DO\n       ISPEXEC SETMSG MSG (CTMF001A)\n    END\n\n /* NOW CHECK IF PLAN SHOULD BE ORDERED */\n IF &CANORDER = YES +\n THEN +\n    DO\n       ISPEXEC TBOPEN &IXTBNAME LIBRARY(&UPPDDN) NOWRITE\n       SET &RC=&LASTCC\n       IF &RC \u00ac= 0 -\n       THEN -\n          DO\n             ISPEXEC SETMSG MSG (CTMF001C)\n             GOTO REDISP\n          END\n       IF &AEDIONLY \u00ac= YES +\n       THEN +\n          DO\n             /* CHECK THAT THE PARAMETERS MEMBER DOESNT EXIST YET  */\n             /* \"MEMBER NOT FOUND\" IS THE DESIRED RC FROM SYSDSN   */\n             SET &DSNRC = &SYSDSN('&AELIB(&IXTBNAME)')\n             IF &DSNRC = OK +\n             THEN +\n                DO    /* \"OK\" RETURN CODE IS NOT GOOD HERE */\n                      ISPEXEC TBEND &IXTBNAME\n                      ISPEXEC SETMSG MSG(CTMF001E)\n                      GOTO RETLOOP\n                END\n             ELSE +\n                IF &DSNRC \u00ac= &STR(MEMBER NOT FOUND) +\n                THEN +\n                   DO\n                      ISPEXEC TBEND &IXTBNAME\n                      ISPEXEC SETMSG MSG(CTMF001D)\n                      GOTO RETLOOP\n                   END\n          END\n\n       FREE  DD(DARESF,DASINC,DALOG,DAPRINT,DACKPT)\n       ALLOC DD(DARESF)   DA('&DBPREFA..&DBVERA..RES') SH\n       ALLOC DD(DASINC)   DA('&DBPREFA..&DBVERA..SNC') SH\n       ALLOC DD(DALOG)    DA('&DBPREFA..&DBVERA..LOG') SH\n       ALLOC DD(DACKPT)   DA('&DBPREFM..&DBVERM..CKP') SH\n       ALLOC DD(DAPRINT)  DA(*)\n       ALLOC DD(DAOUT)    DA(*)\n       ALLOC DD(PRTDBG)   DA(*)\n       ALLOC DD(SYSPRINT) DA(*)\n       SET YY = &SUBSTR(5:6,&DATE)\n       IF &DATEFMT = JPN +\n       THEN +\n          DO\n             SET YY = &SUBSTR(1:2,&DATE)\n             SET &DD = &STR(&SUBSTR(5:6,&DATE))\n             SET &MM = &STR(&SUBSTR(3:4,&DATE))\n          END\n       ELSE +\n       IF &DATEFMT = USA +\n       THEN +\n          DO\n             SET &DD = &STR(&SUBSTR(3:4,&DATE))\n             SET &MM = &STR(&SUBSTR(1:2,&DATE))\n          END\n       ELSE +\n          DO\n             SET &DD = &STR(&SUBSTR(1:2,&DATE))\n             SET &MM = &STR(&SUBSTR(3:4,&DATE))\n          END\n  ISPEXEC VPUT (AELIB,DAYLIB,IXTBTIME,DD,MM,YY,DATEFMT,AEDIONLY) +\n                    SHARED\n\n       /* OPEN THE INDEX TABLE FOR UPDATE NOW */\n       IF &REMIND \u00ac= YES +\n       THEN +\n          DO\n             SET &KEEPTBNM = &IXTBNAME\n             SET &KEEPTBTM = &STR(&IXTBTIME)\n             SET &MONE = 0\n             ISPEXEC TBEND INDXTBL\n             WAITOPN1: +\n             ISPEXEC TBOPEN INDXTBL LIBRARY(&UPPDDN) WRITE\n             SET &RC=&LASTCC\n             IF &RC \u00ac= 0 -\n             THEN -\n                DO\n                   IF &MONE > 3 +\n                   THEN +\n                      DO\n                         ISPEXEC TBEND &IXTBNAME\n                         ISPEXEC SETMSG MSG(CTMF001B)\n                         ISPEXEC TBOPEN INDXTBL LIBRARY(&UPPDDN) +\n                                        NOWRITE\n                         SET &RC = &LASTCC\n                         IF &RC = 0 +\n                         THEN +\n                            GOTO DISP01\n                         ELSE +\n                            GOTO DISPPAN\n                      END\n                   ELSE +\n                      DO\n                         SET &MONE = &MONE + 1\n                         GOTO WAITOPN1\n                      END\n                END\n          END\n\n       /* NOW, CALL THE ORDER PROGRAM */\n   LSTDS: LISTDSI DACAL FILE PREALLOC\n       SET &OLDDACAL = &SYSDSNAME\n       FREE  DD(DACAL)\n       ALLOC DD(DACAL) DA('&OLPREFA..&OLVERA..CAL') SH\n       ISPEXEC SELECT PGM(CTMTORD) PARM(&IXTBNAME)\n       IF '&OLDDACAL' = '' THEN GOTO NODEALL\n       IF '&OLDDACAL' = '&OLPREFA..&OLVERA..CAL' THEN GOTO NODEALL\n       FREE  DD(DACAL)\n       ALLOC DD(DACAL) DA('&OLDDACAL')\n   NODEALL:+\n       ISPEXEC TBEND &IXTBNAME\n       ISPEXEC VGET (ORDERRC) SHARED\n       IF &ORDERRC = 0 +\n       THEN +\n          DO\n             SET &IXTBEXEC = YES\n             IF &AEDIONLY = YES +\n             THEN +\n                ISPEXEC SETMSG MSG(CTMF001K)\n             ELSE +\n                ISPEXEC SETMSG MSG(CTMF001G)\n          END\n       IF &REMIND \u00ac= YES +\n       THEN +\n          DO\n             SET &KEEPTBEX = &IXTBEXEC\n             SET &IXTBNAME = &KEEPTBNM\n             ISPEXEC TBSCAN INDXTBL ARGLIST(IXTBNAME) CONDLIST(EQ)\n             SET &RC = &LASTCC\n             IF &RC \u00ac= 0 +\n             THEN +\n                DO\n                   ISPEXEC TBEND INDXTBL\n                   ISPEXEC SETMSG MSG(CTMF001I)\n                   GOTO DISPPAN\n                END\n             SET &IXTBTIME = &STR(&KEEPTBTM)\n             SET &IXTBEXEC = &KEEPTBEX\n             ISPEXEC TBPUT INDXTBL\n             ISPEXEC TBCLOSE INDXTBL LIBRARY(&UPPDDN)\n             ISPEXEC TBOPEN INDXTBL LIBRARY(&UPPDDN) NOWRITE\n          END\n       ELSE +\n          DO\n              ISPEXEC TBPUT INDXTBL\n              GOTO SCNLOOP\n          END\n       GOTO DISP01\n    END\n RETLOOP: +\n IF &REMIND \u00ac= YES +\n THEN +\n    DO\n       SET &KEEPTBNM = &IXTBNAME\n       SET &KEEPTBTM = &STR(&IXTBTIME)\n       SET &KEEPTBEX = &IXTBEXEC\n       SET &MONE = 0\n       ISPEXEC TBEND INDXTBL\n       WAITOPN2: +\n       ISPEXEC TBOPEN INDXTBL LIBRARY(&UPPDDN) WRITE\n       SET &RC=&LASTCC\n       IF &RC = 0 +\n       THEN +\n          DO\n             SET &IXTBNAME = &KEEPTBNM\n             ISPEXEC TBSCAN INDXTBL ARGLIST(IXTBNAME) CONDLIST(EQ)\n             SET &RC = &LASTCC\n             IF &RC \u00ac= 0 +\n             THEN +\n                DO\n                   ISPEXEC TBEND INDXTBL\n                   ISPEXEC SETMSG MSG(CTMF001I)\n                   GOTO DISPPAN\n                END\n             SET &IXTBTIME = &STR(&KEEPTBTM)\n             SET &IXTBEXEC = &KEEPTBEX\n             ISPEXEC TBPUT INDXTBL\n             ISPEXEC TBCLOSE INDXTBL LIBRARY(&UPPDDN)\n          END\n       ELSE -\n          DO\n             IF &MONE > 3 +\n             THEN +\n                DO\n                   ISPEXEC SETMSG MSG(CTMF001B)\n                   ISPEXEC TBOPEN INDXTBL LIBRARY(&UPPDDN) NOWRITE\n                   SET &RC = &LASTCC\n                   IF &RC = 0 +\n                   THEN +\n                      GOTO DISP01\n                   ELSE +\n                      GOTO DISPPAN\n                END\n             ELSE +\n                DO\n                   SET &MONE = &MONE + 1\n                   GOTO WAITOPN2\n                END\n          END\n       ISPEXEC TBOPEN INDXTBL LIBRARY(&UPPDDN) NOWRITE\n    END\n ELSE +\n    DO\n       ISPEXEC TBPUT INDXTBL\n       GOTO SCNLOOP\n    END\n\n GOTO DISP01\n /* GOTO REDISP\n\n ENDLIST: +\n ISPEXEC TBEND INDXTBL\n SET &RC = &LASTCC\n IF &RC \u00ac= 0 +\n THEN +\n    ISPEXEC SETMSG MSG(CTMF000A)\n\n ENDAPEXE: +\n GOTO DISPPAN\n END: +\n EXIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CTMFETCH": {"ttr": 7431, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x10_\\x00\\x94\\x10_\\x04\\x10\\x027\\x027\\x00\\x00\\xc9\\xd6\\xc1\\xf4\\xf1\\xf0@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-04-15T00:00:00", "modifydate": "1994-04-15T04:10:00", "lines": 567, "newlines": 567, "modlines": 0, "user": "IOA410"}, "text": " PROC 0 PLANID()               /* PLAN NAME - MANDATORY 1-6 CHR */   +\n        SUFFIX()               /* SUFFIX TO PLAN NAME   0-2 CHR */   +\n        REPLACE()              /* REPLACE EXISTING UPP? YES/NO  */   +\n        CONF1(PPF2CONF)        /* CONFIGURATION TABLE NUMBER 1  */   +\n        CONF2()                /* CONFIGURATION TABLE NUMBER 2  */   +\n        CONF3()                /* CONFIGURATION TABLE NUMBER 3  */   +\n        CONF4()                /* CONFIGURATION TABLE NUMBER 4  */   +\n        DATE()                 /* REQUIRED DATE - DEFAULT TODAY */   +\n        SCHTBLB(SYSS.CTMO.V410.SCHEDULE)   +\n        DAYTBLB(SYSS.CTMO.V410.SCHD)     +\n        PRMTBLB(SYSS.CTMO.V410.PLANMSTR) +\n        UPPTBLB(SYSS.CTMO.V410.PLAN)     +\n        MSTJCLB(SYSS.CTMO.V410.JCLPROMP) +\n        DAYJCLB(SYSS.CTMO.V410.JCLP)     +\n        OLPREFA(SYSS.IOA)                   +\n        OLVERA(V410)                     +\n        DATEFMT(USA)                   +\n        BATCH(NO)                            +\n        DEBUG()\n /*******************************************************************/\n /**                                                               **/\n /**              C  T  M  F  E  T  C  H                           **/\n /**             ========================                          **/\n /**                                                               **/\n /**  PARAMETER PROMPTING FACILITY - TYPE2                         **/\n /**                                                               **/\n /**  THIS CLIST IS THE SECOND PHASE OF THE PARAMETERS PROMPTING   **/\n /**  FACILITY (FIRST PHASE IS THE MASTER PLAN DEFINITION, AND     **/\n /**  THE THIRD PHASE IS EXECUTING THE PLAN).                      **/\n /**  CTMFETCH SHOULD BE ACTIVATED ONCE FOR EVERY PLAN THAT        **/\n /**  SHOULD BE EXECUTED ON A CERTAIN DAY. IT COPIES THE           **/\n /**  SCHEDULING TABLE AND THE PROMPTING PLAN INTO THE DAILY       **/\n /**  LIBRARIES AND FROM THERE IT WILL BE EXECUTED.                **/\n /**                                                               **/\n /**  THIS CLIST PERFORMS THE FOLLOWING OPERATIONS:                **/\n /**  1. GET ALL THE REQUIRED PARAMETERS AND CHECK THEIR VALIDITY. **/\n /**  2. EXECUTES \"CTMJOB\" ON THE REQUIRED SCHEDULING TABLE        **/\n /**     TO FIND THE NAMES OF THE JOBS THAT WILL RUN ON THE        **/\n /**     REQUESTED DAY.                                            **/\n /**  3. COPY THE REQUIRED PLANID FROM THE \"SCHEDULING TABLE LIB\"  **/\n /**     TO THE \"DAILY SCHEDULING LIB\" TO CREATE / REPLACE THE     **/\n /**     DAILY SCHEDULING TABLE.                                   **/\n /**     ONLY JOBS THAT WERE MARKED BY CTMJOB AS JOBS THAT WILL    **/\n /**     RUN ON THE SPECIFIED DAY WILL BE INCLUDED IN THE          **/\n /**     DAILY SCHEDULING TABLE.                                   **/\n /**  4. THE \"MASTER PROMPTING PLAN\" FOR THAT PLANID IS COPIED     **/\n /**     FROM THE \"MASTER PROMPTING LIBRARY\" TO THE                **/\n /**     \"USER PROMPTING LIBRARY\" TO CREATE / REPLACE THE USER     **/\n /**     PROMPTING PLAN (UPP).                                     **/\n /**     ONLY PARAMETERS FOR THE JOBS THAT WILL RUN ON THAT DAY    **/\n /**     ARE COPIED INTO THE \"UPP\".                                **/\n /**  5. THE \"INDEX DAILY TABLE\" IN THE \"USER PROMPTING LIBRARY\"   **/\n /**     IS UPDATED TO CONTAIN AN ENTRY FOR THAT PLANID.           **/\n /**                                                               **/\n /*******************************************************************/\n IF &DEBUG = DEBUG      +\n THEN                   +\n    CONTROL MSG LIST SYMLIST CONLIST\n ELSE                   +\n    CONTROL NOMSG NOLIST NOSYMLIST NOCONLIST NOFLUSH\n ISPEXEC CONTROL ERRORS RETURN\n\n /* DISPLAY PANEL TO GET THE REQUIRED PARAMETERS OR UPDATE THEM  */\n IF &PLANID = &STR() +\n THEN +\n    DO\n       SET &TEMP = &PLANID\n       ISPEXEC VGET (PLANID) PROFILE\n       SET &RC = &LASTCC\n       IF &RC \u00ac= 0 +\n       THEN +\n          SET &PLANID = &TEMP\n    END\n IF &REPLACE = &STR() +\n THEN +\n    SET &REPLACE = NO\n SET &TEMP = &SCHTBLB\n ISPEXEC VGET (SCHTBLB) PROFILE\n SET &RC = &LASTCC\n IF &RC \u00ac= 0 +\n THEN +\n    SET &SCHTBLB = &TEMP\n SET &TEMP = &DAYTBLB\n ISPEXEC VGET (DAYTBLB) PROFILE\n SET &RC = &LASTCC\n IF &RC \u00ac= 0 +\n THEN +\n    SET &DAYTBLB = &TEMP\n SET &TEMP = &PRMTBLB\n ISPEXEC VGET (PRMTBLB) PROFILE\n SET &RC = &LASTCC\n IF &RC \u00ac= 0 +\n THEN +\n    SET &PRMTBLB = &TEMP\n SET &TEMP = &UPPTBLB\n ISPEXEC VGET (UPPTBLB) PROFILE\n SET &RC = &LASTCC\n IF &RC \u00ac= 0 +\n THEN +\n    SET &UPPTBLB = &TEMP\n SET &TEMP = &MSTJCLB\n ISPEXEC VGET (MSTJCLB) PROFILE\n SET &RC = &LASTCC\n IF &RC \u00ac= 0 +\n THEN +\n    SET &MSTJCLB = &TEMP\n SET &TEMP = &DAYJCLB\n ISPEXEC VGET (DAYJCLB) PROFILE\n SET &RC = &LASTCC\n IF &RC \u00ac= 0 +\n THEN +\n    SET &DAYJCLB = &TEMP\n IF &DATE = &STR() +\n THEN +\n    DO\n       ISPEXEC VGET (ZDAY,ZMONTH,ZYEAR)\n       IF &DATEFMT = JPN +\n       THEN +\n          SET &DATE = &STR(&ZYEAR.&ZMONTH.&ZDAY)\n       ELSE +\n       IF &DATEFMT = USA +\n       THEN +\n          SET &DATE = &STR(&ZMONTH.&ZDAY.&ZYEAR)\n       ELSE +\n          SET &DATE = &STR(&ZDAY.&ZMONTH.&ZYEAR)\n    END\n\n IF &BATCH = &STR(NO) +\n THEN +\n    DO\n       REDISP: +\n       IF &BATCH = &STR(YES) +\n       THEN +\n          GOTO END\n       ISPEXEC DISPLAY PANEL(CTMPF20W)\n       SET &RC = &LASTCC\n       IF &RC \u00ac= 0 -\n       THEN -\n          IF &RC \u00ac= 8 -\n          THEN -\n             DO\n                ISPEXEC SETMSG MSG(CTMF000Z)\n                GOTO END\n             END\n          ELSE -\n             GOTO END\n    END\n\n ISPEXEC VPUT (PLANID SCHTBLB DAYTBLB PRMTBLB UPPTBLB +\n               MSTJCLB DAYJCLB) PROFILE\n\n /* CHECK VALIDITY OF DATE: MUST BE 0(NULL) OR 6 CHARACTERS IN THE */\n /* FORMAT \"DDMMYY\" OR \"MMDDYY\" ACCORDING TO THE DATE TYPE         */\n CHKDT: +\n IF &DATE = &STR() +\n THEN +\n    DO\n       /* THE DEFAULT DATE IS TODAY */\n       ISPEXEC VGET (ZDAY,ZMONTH,ZYEAR)\n       IF &DATEFMT = JPN +\n       THEN +\n          SET &DATE = &STR(&ZYEAR.&ZMONTH.&ZDAY)\n       ELSE +\n       IF &DATEFMT = USA +\n       THEN +\n          SET &DATE = &STR(&ZMONTH.&ZDAY.&ZYEAR)\n       ELSE +\n          SET &DATE = &STR(&ZDAY.&ZMONTH.&ZYEAR)\n    END\n ELSE +\n    DO\n       IF &DATEFMT = JPN +\n       THEN +\n          DO\n             SET &ZYEAR = &SUBSTR(1:2,&DATE)\n             SET &ZDAY = &SUBSTR(5:6,&DATE)\n             SET &ZMONTH = &SUBSTR(3:4,&DATE)\n          END\n       ELSE +\n       IF &DATEFMT = USA +\n       THEN +\n          DO\n             SET &ZYEAR = &SUBSTR(5:6,&DATE)\n             SET &ZDAY = &SUBSTR(3:4,&DATE)\n             SET &ZMONTH = &SUBSTR(1:2,&DATE)\n          END\n       ELSE +\n          DO\n             SET &ZYEAR = &SUBSTR(5:6,&DATE)\n             SET &ZDAY = &SUBSTR(1:2,&DATE)\n             SET &ZMONTH = &SUBSTR(3:4,&DATE)\n          END\n       IF &ZDAY < 1 OR &ZDAY > 31 +\n       THEN +\n          DO\n              ISPEXEC SETMSG MSG(CTMF000E)\n              GOTO REDISP\n          END\n       IF &ZMONTH < 1 OR &ZMONTH > 12 +\n       THEN +\n          DO\n              ISPEXEC SETMSG MSG(CTMF000E)\n              GOTO REDISP\n          END\n    END\n\n SET ORDDATE = &STR(&ZYEAR.&ZMONTH.&ZDAY)\n SET DSNDATE = &STR(&ZMONTH.&ZDAY)\n SET &NEWPLNID = &PLANID.&SUFFIX\n\n /* CHECK THE EXISTENCE OF THE \"SCHEDULING TABLE LIBRARY\" AND      */\n /* THE \"DAILY SCHEDULING TABLE LIBRARY\".                          */\n CHKSCHTB: +\n SET &DSNRC = &SYSDSN('&SCHTBLB(&PLANID)')\n IF &DSNRC \u00ac= OK +\n THEN +\n    IF &DSNRC = &STR(MEMBER NOT FOUND) +\n    THEN +\n       DO\n          SET &MSGPLAN = &PLANID\n          ISPEXEC SETMSG MSG(CTMF000G)\n          GOTO REDISP\n       END\n    ELSE +\n       DO\n          SET &ERRDSN = &SCHTBLB\n          ISPEXEC SETMSG MSG(CTMF000F)\n          GOTO REDISP\n       END\n\n CHKDAYTB: +\n SET &DAYLIB = &DAYTBLB.&DSNDATE\n SET &DSNRC = &SYSDSN('&DAYLIB')\n IF &DSNRC \u00ac= OK  +\n THEN +\n    DO\n       /* WRITE TRY TO ALLOCATE &DAYLIB AS A NEW DAILY LIBRARY.\n       SET &MSGDSN = &DAYLIB\n       ISPEXEC CONTROL DISPLAY LOCK\n       ISPEXEC DISPLAY MSG(CTMF002I)\n       %CTMCALOC MASTLIB(&SCHTBLB) DAYLIB(&DAYLIB)\n       SET &RC = &LASTCC\n       IF &RC = 0 +\n       THEN +\n          GOTO CHKPRMTB\n\n       SET &ERRDSN = &DAYLIB\n       ISPEXEC SETMSG MSG(CTMF000F)\n       GOTO REDISP\n    END\n\n /* CHECK THE EXISTENCE OF THE \"MASTER PROMPTING PLAN LIBRARY\" AND  */\n /* THE \"USER PROMPTING PLANS LIBRARY\".                             */\n CHKPRMTB: +\n SET &MSTTBNM = &STR(&PLANID.MS)\n /* SET &MSTTBNM = &STR(&PLANID)\n SET &DSNRC = &SYSDSN('&PRMTBLB(&MSTTBNM)')\n IF &DSNRC \u00ac= OK +\n THEN +\n    IF &DSNRC = &STR(MEMBER NOT FOUND) +\n    THEN +\n       DO\n          SET &ERRDSN = &PRMTBLB\n          ISPEXEC SETMSG MSG(CTMF002E)\n          GOTO REDISP\n       END\n    ELSE +\n       DO\n          SET &ERRDSN = &PRMTBLB\n          ISPEXEC SETMSG MSG(CTMF000F)\n          GOTO REDISP\n       END\n\n ISPEXEC VPUT (PLANID) PROFILE\n CHKUPPTB: +\n SET &UPPLIB = &UPPTBLB.&DSNDATE\n SET &DSNRC = &SYSDSN('&UPPLIB')\n IF &DSNRC \u00ac= OK  +\n THEN +\n    DO\n       /* WRITE TRY TO ALLOCATE &UPPLIB AS A NEW DAILY LIBRARY.\n       SET &MSGDSN = &UPPLIB\n       ISPEXEC CONTROL DISPLAY LOCK\n       ISPEXEC DISPLAY MSG(CTMF002I)\n       %CTMCALOC MASTLIB(&PRMTBLB) DAYLIB(&UPPLIB)\n       SET &RC = &LASTCC\n       IF &RC = 0 +\n       THEN +\n          GOTO CHKJCLLB\n\n       SET &ERRDSN = &UPPLIB\n       ISPEXEC SETMSG MSG(CTMF000F)\n       GOTO REDISP\n    END\n\n CHKJCLLB: +\n SET &JCLLIB = &DAYJCLB.&DSNDATE\n SET &DSNRC = &SYSDSN('&JCLLIB')\n IF &DSNRC \u00ac= OK  +\n THEN +\n    DO\n       /* WRITE TRY TO ALLOCATE &JCLLIB AS A NEW DAILY LIBRARY.\n       SET &MSGDSN = &JCLLIB\n       ISPEXEC CONTROL DISPLAY LOCK\n       ISPEXEC DISPLAY MSG(CTMF002I)\n       %CTMCALOC MASTLIB(&MSTJCLB) DAYLIB(&JCLLIB) JCLLIB(YES)\n       SET &RC = &LASTCC\n       IF &RC = 0 +\n       THEN +\n          GOTO AFTJCLLB\n\n       SET &ERRDSN = &JCLLIB\n       ISPEXEC SETMSG MSG(CTMF000F)\n       GOTO REDISP\n    END\n\n /* CHECK THE REPLACE PARAMETER (YES/NO) AND ACCORDING TO IT CHECK  */\n /* IF THE SCEDULING TABLE OR THE UPP ALREADY EXISTS IN THE DAILY   */\n /* LIBRARIES.                                                      */\n AFTJCLLB: +\n IF &REPLACE = YES +\n THEN +\n    GOTO DONTCHK\n SET &DSNRC = &SYSDSN('&DAYLIB(&NEWPLNID)')\n IF &DSNRC = OK  +\n THEN +\n    DO\n       ISPEXEC SETMSG MSG(CTMF002M)\n       GOTO REDISP\n    /* WRITE SCHEDULING TABLE &NEWPLNID ALREADY EXISTS IN THE DAILY\n    /* WRITE LIBRARY &DAYLIB BUT REPLACE(YES) WAS NOT SPECIFIED\n    /* WRITE ENTER YES TO REPLACE OR END TO FINISH\n    END\n SET &DSNRC = &SYSDSN('&UPPLIB(&NEWPLNID)')\n IF &DSNRC = OK  +\n THEN +\n    DO\n       ISPEXEC SETMSG MSG(CTMF002M)\n       GOTO REDISP\n    /* WRITE USER PROMPTING PLAN &NEWPLNID ALREADY EXISTS IN THE DAILY\n    /* WRITE LIBRARY &UPPLIB BUT REPLACE(YES) WAS NOT SPECIFIED\n    /* WRITE ENTER YES TO REPLACE OR END TO FINISH\n    END\n\n DONTCHK: +\n ISPEXEC CONTROL DISPLAY LOCK\n ISPEXEC DISPLAY MSG(CTMF002J)\n /* WRITE *** CREATE DAILY USER PROMPTING PLAN          ***\n\n SET &MSTDDN = MSTDDN\n SET &UPPDDN = UPPDDN\n ISPEXEC SELECT PGM(CTMTIOT) PARM(&MSTDDN)\n ISPEXEC VGET (TIOTDDN,TIOTDSN,TIOTNUM) SHARED\n IF &TIOTDSN \u00ac= &PRMTBLB +\n THEN +\n    DO\n       SET &TIOTNUM = &TIOTNUM + 101\n       SET &TIOTNUM = &SUBSTR(2:3,&TIOTNUM)\n       SET &MSTDDN = &STR(&MSTDDN.&TIOTNUM)\n       ALLOC FILE(&MSTDDN) DA('&PRMTBLB') SHR\n       SET &RC = &LASTCC\n       IF &RC \u00ac= 0 +\n       THEN +\n          DO\n             SET &ERRDSN = &PRMTBLB\n             ISPEXEC SETMSG MSG(CTMF000F)\n             GOTO REDISP\n          END\n    END\n ELSE +\n    SET &MSTDDN = &TIOTDDN\n ISPEXEC SELECT PGM(CTMTIOT) PARM(&UPPDDN)\n ISPEXEC VGET (TIOTDDN,TIOTDSN,TIOTNUM) SHARED\n IF &TIOTDSN \u00ac= &UPPLIB +\n THEN +\n    DO\n       SET &TIOTNUM = &TIOTNUM + 101\n       SET &TIOTNUM = &SUBSTR(2:3,&TIOTNUM)\n       SET &UPPDDN = &STR(&UPPDDN.&TIOTNUM)\n       ALLOC FILE(&UPPDDN) DA('&UPPLIB') SHR\n       SET &RC = &LASTCC\n       IF &RC \u00ac= 0 +\n       THEN +\n          DO\n             SET &ERRDSN = &UPPLIB\n             ISPEXEC SETMSG MSG(CTMF000F)\n             GOTO REDISP\n          END\n    END\n ELSE +\n    SET &UPPDDN = &TIOTDDN\n ISPEXEC TBCREATE &NEWPLNID +\n         NAMES(PARMNAME PROCCUR# PRMJOBN PROMPIND PRDEFIND PRDEFVAL +\n         PRMDEFST PRVALIND PRMVAL PRMTYPE PROMPMSG ) +\n         WRITE REPLACE LIBRARY(&UPPDDN)\n SET &RC=&LASTCC\n IF &RC > 4 +\n THEN +\n    DO\n      IF &RC = 12 +\n      THEN +\n         ISPEXEC SETMSG MSG(CTMF005E)\n      ELSE +\n         ISPEXEC SETMSG MSG(CTMF000A)\n      FREE FILE(&MSTDDN)\n      FREE FILE(&UPPDDN)\n      GOTO REDISP\n    END\n\n /* WRITE *** COPY PARAMETERS FROM MASTER PLAN TO UPP   ***\n ISPEXEC CONTROL DISPLAY LOCK\n ISPEXEC DISPLAY MSG(CTMF002K)\n /* EACH USER PROMPTING PLAN CONTAINS A FEW PARAMETERS WHICH ARE   */\n /* DIFFERENT FOR EACH PLAN.                                       */\n /* PLANID   - CONTAINS THE PLAN NAME.                             */\n /* CONF1-4  - ARE CONFIGURATION TABLES (GENERAL TABLES WHICH MAY  */\n /*            CONTAIN INFORMATION LIKE SPECIAL DATES, NAMES ETC). */\n /*            THOSE TABLES CAN BE INCLUDED IN THE JCL AS %%MEMSYM */\n /*            STATEMENTS WITH %%LIBSYM AS %%CONF1-4.              */\n\n ISPEXEC TBVCLEAR &NEWPLNID\n SET &RC=&LASTCC\n IF &RC \u00ac= 0 -\n THEN -\n    DO\n       ISPEXEC SETMSG MSG(CTMF000A)\n       ISPEXEC TBEND &NEWPLNID\n       GOTO REDISP\n    END\n SET PRMJOBN = &STR(********)\n SET PARMNAME = PLANID\n SET PROMPIND = N\n SET PRVALIND = Y\n SET PRMVAL = &NEWPLNID\n ISPEXEC TBADD &NEWPLNID\n IF &RC \u00ac= 0 -\n THEN -\n    DO\n       ISPEXEC SETMSG MSG(CTMF000A)\n       ISPEXEC TBEND &NEWPLNID\n       GOTO REDISP\n    END\n SET I = 1\n DO WHILE &I < 5\n    SET V1 = &&CONF&I\n    SET V2 = &SYSNSUB(2,&V1)\n    SET PARMNAME = CONF&I\n    SET PRMVAL = &V2\n    ISPEXEC TBADD &NEWPLNID\n    IF &RC \u00ac= 0 -\n    THEN -\n       DO\n          ISPEXEC SETMSG MSG(CTMF000A)\n          ISPEXEC TBEND &NEWPLNID\n          GOTO REDISP\n       END\n    SET I = &I + 1\n END\n ISPEXEC TBCLOSE &NEWPLNID LIBRARY(&UPPDDN)\n\n /* CALL CTMTCOP TO COPY PARAMETERS FROM THE MASTER PROMPTING PLAN   */\n /* TO THE USER PROMPTING PLAN.                                      */\n /* ONLY PARAMETERS THE BELONG TO JOBS THAT WILL RUN TODAY, WILL BE  */\n /* COPIED TO THE \"UPP\".                                             */\n /* IT CALLS CTMJOB TO FIND OUT THE JOBS THAT WILL RUN TODAY.        */\n /* A LIST OF THE JOBS IS WRITTEN TO A FILE ALLOCATED TO             */\n /* OUTFETCH DD STATEMENT.                                           */\n\n /* WRITE *** COPY SCHEDULING TABLE TO THE DAILY LIB.   ***\n ISPEXEC CONTROL DISPLAY LOCK\n ISPEXEC DISPLAY MSG(CTMF002L)\n FREE FILE(OUTFETCH)\nALLOC DD(OUTFETCH) NEW TRACKS SP(1 1) RECFM(F B) LRECL(80) BLKSIZE(800)\n LSTDS: LISTDSI DACAL FILE PREALLOC\n SET  &OLDDACAL = &SYSDSNAME\n FREE  DD(DACAL)\n ALLOC DD(DACAL) DA('&OLPREFA..&OLVERA..CAL') SH\n ISPEXEC VPUT ( MSTDDN UPPDDN MSTTBNM PLANID NEWPLNID DAYLIB  +\n       REPLACE SCHTBLB ORDDATE JCLLIB ) SHARED\n ISPEXEC SELECT PGM(CTMTCOP)\n IF '&OLDDACAL' = '' THEN GOTO NODEALL\n IF '&OLDDACAL' = '&OLPREFA..&OLVERA..CAL' THEN GOTO NODEALL\n FREE DD(DACAL)\n ALLOC DD(DACAL) DA('&OLDDACAL')\n NODEALL:+\n ISPEXEC VGET (COPTBRC,ERRMSG,ERJCLM) SHARED\n IF &COPTBRC \u00ac= 0 +\n THEN +\n    DO\n       ISPEXEC SETMSG MSG(&ERRMSG)\n       GOTO REDISP\n    END\n FREE FILE(OUTFETCH)\n\n /* AFTER THE UPP WAS CREATED, ADD A ROW TO THE INDEX TABLE      */\n /* THAT KEEPS INFORMATION ABOUT ALL THE UPPS.                   */\n SET &DSNRC = &SYSDSN('&UPPLIB(INDXTBL)')\n IF &DSNRC \u00ac= OK +\n THEN +\n    IF &DSNRC = &STR(MEMBER NOT FOUND) +\n    THEN +\n       DO\n           /* CREATE A NEW INDEX TABLE   */\n          ISPEXEC TBCREATE INDXTBL KEYS(IXTBNAME) +\n                  NAMES(IXTBTIME, IXTBEXEC ) +\n                  WRITE LIBRARY(&UPPDDN)\n          SET &RC=&LASTCC\n          IF &RC \u00ac= 0 -\n          THEN -\n             DO\n                ISPEXEC SETMSG MSG(CTMF000A)\n                GOTO REDISP\n             END\n       END\n    ELSE +\n       DO\n          ISPEXEC SETMSG MSG(CTMF000A)\n          GOTO REDISP\n       END\n ELSE +\n    DO\n       ISPEXEC TBOPEN INDXTBL LIBRARY(&UPPDDN) WRITE\n       SET &RC=&LASTCC\n       IF &RC \u00ac= 0 -\n       THEN -\n          IF &RC = 12 +\n          THEN +\n             DO\n                ISPEXEC SETMSG MSG(CTMF001B)\n                GOTO REDISP\n             END\n          ELSE +\n             DO\n                ISPEXEC SETMSG MSG(CTMF000A)\n                GOTO REDISP\n             END\n    END\n ISPEXEC TBVCLEAR INDXTBL\n SET IXTBNAME = &NEWPLNID\n ISPEXEC TBADD INDXTBL\n SET &RC=&LASTCC\n IF &RC > 8 -\n THEN -\n    DO\n       ISPEXEC SETMSG MSG(CTMF000A)\n       ISPEXEC TBEND INDXTBL\n       GOTO REDISP\n    END\n\n ISPEXEC SETMSG MSG(CTMF002A)\n ISPEXEC TBCLOSE INDXTBL LIBRARY(&UPPDDN)\n SET &RC = &LASTCC\n\n FREE FILE(&MSTDDN)\n FREE FILE(&UPPDDN)\n ISPEXEC VPUT (PLANID SCHTBLB DAYTBLB PRMTBLB UPPTBLB +\n               MSTJCLB DAYJCLB) PROFILE\n ENDFETCH: +\n IF &SCHID \u00ac= &STR() +\n THEN +\n    ISPEXEC LMFREE DATAID(&SCHID)\n IF &DAYID \u00ac= &STR() +\n THEN +\n    ISPEXEC LMFREE DATAID(&DAYID)\n GOTO REDISP\n END: +\n EXIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CTMISPF": {"ttr": 7687, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x10_\\x00\\x94\\x10_\\x04\\x10\\x00\\t\\x00\\t\\x00\\x00\\xc9\\xd6\\xc1\\xf4\\xf1\\xf0@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-04-15T00:00:00", "modifydate": "1994-04-15T04:10:00", "lines": 9, "newlines": 9, "modlines": 0, "user": "IOA410"}, "text": "PROC 0  APPLTYPE(I)  -\n        APPLID(CM)\n/****************************************************************\n/*                                                              *\n/*  CONTROL-M:   PRODUCTION CONTROL  SYSTEM          (ISPF)     *\n/*                                                              *\n/****************************************************************\n%IOAONL APPLTYPE(&APPLTYPE) APPLID(&APPLID)\nEND:END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CTMISPFD": {"ttr": 7689, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x10_\\x00\\x94\\x10_\\x04\\x10\\x00\\n\\x00\\n\\x00\\x00\\xc9\\xd6\\xc1\\xf4\\xf1\\xf0@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-04-15T00:00:00", "modifydate": "1994-04-15T04:10:00", "lines": 10, "newlines": 10, "modlines": 0, "user": "IOA410"}, "text": "PROC 0  APPLTYPE(I)  -\n        APPLID(CS)\n/****************************************************************\n/*                                                              *\n/*  CONTROL-M:   PRODUCTION CONTROL  SYSTEM      (ISPF)         *\n/*  CONTROL-D:   REPORT DISTRIBUTION SYSTEM      (ISPF)         *\n/*                                                              *\n/****************************************************************\n%IOAONL APPLTYPE(&APPLTYPE) APPLID(&APPLID)\nEND:END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CTMJBINT": {"ttr": 7691, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x10_\\x00\\x94\\x10_\\x04\\x10\\x01\\x87\\x01\\x87\\x00\\x00\\xc9\\xd6\\xc1\\xf4\\xf1\\xf0@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-04-15T00:00:00", "modifydate": "1994-04-15T04:10:00", "lines": 391, "newlines": 391, "modlines": 0, "user": "IOA410"}, "text": "PROC 0 DEBUG() DEBUGD() +\n       DATEFMT(USA)     +\n       USRLIB(SYSS.CTMO.V410.SCHEDULE) +\n       USRTBL(@@USRTBL)\n\nIF &DEBUG=DEBUG THEN CONTROL MAIN LIST CONLIST SYMLIST MSG\n                ELSE CONTROL MAIN NOLIST NOCONLIST NOSYMLIST NOMSG\n\nISPEXEC CONTROL ERRORS CANCEL\nSET &RC = &LASTCC\nIF &RC \u00ac= 0 THEN EXIT QUIT   /*NOT RUNNING UNDER ISPF  */\nSET ACTION=RETURN\nISPEXEC CONTROL ERRORS &ACTION\n\n /********************************************************/\n /**                                                    **/\n /**    CONTROL-M END USER JOB SELECTION INTERFACE      **/\n /**                                                    **/\n /**    CLIST CTMJBINT                                  **/\n /**                                                    **/\n /********************************************************/\n\nISPEXEC VPUT (ZHTOP)\n\n /********************************************************/\n /**    PROGRAM VARIABLE INITIALIZATION                 **/\n /********************************************************/\nSET BLANKS = &STR(                                                   )\n   /* NOTE - ABOVE LINE HAS 50 BLANKS - LEAVE IT ALONE */\nSET USER   = &SYSUID\nSET NOALC = &STR()\nSET CTMGRP = '1'\nSET FRC = NO\n\n /********************************************************/\n /**                                                    **/\n /**    ALLOCATE AND OPEN THE FILE CONTAINING           **/\n /**    THE CORRESPONDENCE BETWEEN USERID AND           **/\n /**    SCHEDULING TABLE                                **/\n /**                                                    **/\n /********************************************************/\n\nISPEXEC LMINIT  DATAID(CTMPJIN) DATASET('&USRLIB') ENQ(SHR)\nSET &RC = &LASTCC\nIF &RC \u00ac= 0 THEN +\n   DO\n      ISPEXEC SETMSG MSG(CTMJ005A)\n      EXIT QUIT\n   END\n\nISPEXEC LMOPEN  DATAID(&CTMPJIN) OPTION(INPUT)\nSET &RC = &LASTCC\nIF &RC \u00ac= 0 THEN +\n   DO\n      ISPEXEC SETMSG MSG(CTMJ006A)\n      EXIT QUIT\n   END\n\nISPEXEC LMMFIND DATAID(&CTMPJIN) MEMBER(&USRTBL)\nSET &RC = &LASTCC\nIF &RC \u00ac= 0 THEN +\n      DO\n      ISPEXEC SETMSG MSG(CTMJ007A)\n      EXIT QUIT\n   END\n\n /********************************************************/\n /**    FIND THE RECORD CORRESPONDING TO THE USER       **/\n /********************************************************/\n\nSET USERFND = N   /* DIDNT FIND USER YET */\nSET EOF     = N   /* NOT AT EOF ON THE INPUT MEMBER */\n\nDO WHILE ((&EOF=N) AND (&USERFND=N))\nISPEXEC LMGET   DATAID(&CTMPJIN) MODE(INVAR) DATALEN(CARDLEN) +\n                      DATALOC(CARD) MAXLEN(80)\n   SET &RC = &LASTCC\n   IF &RC \u00ac= 0 THEN +\n     IF &RC = 8 THEN SET EOF=Y\n        ELSE +\n      DO\n         ISPEXEC SETMSG MSG(CTMJ000A)\n         EXIT QUIT\n      END\n\n    IF (&EOF=N) THEN +\n      IF Z&SUBSTR(1:1,&NRSTR(&CARD)&STR(&BLANKS))\u00ac=Z&STR(*) THEN +\n       DO\n          IF &SUBSTR(1:8,&NRSTR(&CARD)&STR(&BLANKS))=&USER +\n               THEN SET USERFND = Y\n          ELSE +\n             DO\n               SET I = 0\n               SET STAR = 0\n               DO WHILE ((&I<8) AND (&STAR=0))\n                 SET I = &I + 1\n                 SET CHAR = &SUBSTR(&I:&I,&NRSTR(&CARD)&STR(&BLANKS))\n                 IF Z&STR(&CHAR)=Z&STR(*) THEN SET STAR = &I\n               END\n               IF &STAR=1 THEN +\n                 DO\n                   SET USERFND = Y\n                   SET STAR = 0\n                 END\n               IF &STAR>0 THEN +\n                 DO\n                    IF &SUBSTR(1:&STAR-1,&NRSTR(&CARD))=&SUBSTR( +\n                         1:&STAR-1,&NRSTR(&USER)&STR(&BLANKS)) THEN +\n                    SET USERFND = Y\n                 END\n             END\n       END\nEND      /* OF THE LOOP READING RECORDS FROM MEMBER */\n\nISPEXEC LMCLOSE DATAID(&CTMPJIN)\nISPEXEC LMFREE  DATAID(&CTMPJIN)\n\nIF &USERFND=N THEN +\n   DO\n      ISPEXEC SETMSG MSG(CTMJ008A)\n      EXIT  QUIT\n   END\n\n /********************************************************/\n /**    EXTRACT LIBRARY AND MEMBER NAME                 **/\n /********************************************************/\n\nSET MEM =&SUBSTR(10:17,&NRSTR(&CARD)&STR(&BLANKS))\nSET LIB =&SUBSTR(20:63,&NRSTR(&CARD)&STR(&BLANKS))\nSET LIB =&LIB\nIF Z&LIB=Z THEN SET LIB = &USRLIB       /* LIB WAS BLANK ON CARD */\n\n /********************************************************/\n /**    ALLOCATE AND OPEN THE SCHEDULE TABLE FILE       **/\n /********************************************************/\n\nISPEXEC LMINIT  DATAID(CTMPJIN) DATASET('&LIB') ENQ(SHR)\nSET &RC = &LASTCC\nIF &RC \u00ac= 0 THEN +\n   DO\n      ISPEXEC SETMSG MSG(CTMJ005A)\n      EXIT QUIT\n   END\n\nISPEXEC LMOPEN  DATAID(&CTMPJIN) OPTION(INPUT)\nSET &RC = &LASTCC\nIF &RC \u00ac= 0 THEN +\n   DO\n      ISPEXEC SETMSG MSG(CTMJ006A)\n      EXIT QUIT\n   END\n\nISPEXEC LMMFIND DATAID(&CTMPJIN) MEMBER(&MEM)\nSET &RC = &LASTCC\nIF &RC \u00ac= 0 THEN +\n      DO\n      ISPEXEC SETMSG MSG(CTMJ008A)\n      EXIT QUIT\n   END\n\n /********************************************************/\n /**    CREATE A CLEAN JOBNAME TABLE                    **/\n /********************************************************/\n\nISPEXEC CONTROL ERRORS RETURN\n\nISPEXEC TBQUERY CTMPJT00\nSET &RC = &LASTCC\nIF &RC = 0 THEN  +\n   ISPEXEC TBCLOSE CTMPJT00\n\nISPEXEC CONTROL ERRORS &ACTION\n\nISPEXEC TBCREATE CTMPJT00 NAMES(OPER  JNAM DESC) NOWRITE\nISPEXEC TBVCLEAR CTMPJT00\n\n /********************************************************/\n /**    READ THE MEMBER AND FILL THE JOBNAME TABLE      **/\n /********************************************************/\n\nSET EOF=N\nDO WHILE (&EOF=N)\nISPEXEC LMGET   DATAID(&CTMPJIN) MODE(INVAR) DATALEN(CARDLEN) +\n                      DATALOC(CARD) MAXLEN(80)\n   SET &RC = &LASTCC\n   IF &RC \u00ac= 0 THEN +\n     IF &RC = 8 THEN SET EOF=Y\n        ELSE +\n      DO\n         ISPEXEC SETMSG MSG(CTMJ000A)\n         EXIT QUIT\n      END\n\n   IF &EOF=N THEN +\n      DO\n         SET CARDTYP=&SUBSTR(1,&NRSTR(&CARD)&STR(&BLANKS))\n         IF &CARDTYP=H THEN +\n             SET DESC=&SUBSTR(2:51,&NRSTR(&CARD)&STR(&BLANKS))\n         IF &CARDTYP=M THEN +\n            DO\n               IF Z&JNAM\u00ac=Z THEN ISPEXEC TBADD CTMPJT00\n               ISPEXEC TBVCLEAR CTMPJT00\n               SET JNAM=&SUBSTR(2:9,&NRSTR(&CARD)&STR(&BLANKS))\n            END\n      END\n\nEND /*OF THE READ LOOP */\n\nIF Z&JNAM\u00ac=Z  THEN ISPEXEC TBADD CTMPJT00\nISPEXEC LMCLOSE DATAID(&CTMPJIN)\nISPEXEC LMFREE  DATAID(&CTMPJIN)\n\n /********************************************************/\n /**    NOW PRESENT THE SCREEN TO THE USER              **/\n /********************************************************/\nSET MARK1=&STR( ====== >>>>>>>>>>>>>>>>>>>    NO MORE JOBS IN)\nSET MARK2=&STR( TABLE     <<<<<<<<<<<<<<<< =====)\nSET &ZTDMARK=&STR(&MARK1&MARK2)\nSET MEMNAME = &MEM          /* CLEAN UP MEMBER NAME */\nSET &ZTDMSG = CTMK002A      /* NO \"ROW NN OF NN\" */\nSET CUR     = 1             /* WHERE THE CURSOR IS */\n\nISPEXEC TBTOP   CTMPJT00\n\nSET &KILL = N   /* USER HAS NOT ENDED THE CLIST */\n\nDO WHILE &KILL\u00ac=Y /*THAT IS, REPEAT UNTIL USER ENDS IT ALL */\n\n   ISPEXEC TBTOP   CTMPJT00\n   ISPEXEC TBSKIP  CTMPJT00 NUMBER(&CUR)\nISPEXEC TBDISPL CTMPJT00 PANEL(CTMPJ00W) AUTOSEL(NO) CSRROW(&CUR)\n\n   SET &NUMROWS = &ZTDROWS\n   SET &CHANGED = &ZTDSELS\n\n   ISPEXEC VGET (ZVERB)\n   SET &RESP = &ZVERB\n   IF Z&RESP = Z THEN  SET &RESP = ENTER\n   IF ((&RESP=RETURN) OR (&RESP=END)) THEN SET KILL=Y\n\n   IF ((&KILL=N) AND (&CHANGED>0)) THEN   +\n     DO\n         ISPEXEC TBPUT  CTMPJT00\n         DO WHILE ((&ZTDSELS>1) AND (&KILL=N))\n\n               ISPEXEC TBDISPL CTMPJT00\n               ISPEXEC VGET (ZVERB)\n               SET &RESP = &ZVERB\n               IF Z&RESP = Z THEN  SET &RESP = ENTER\n               IF ((&RESP=RETURN) OR (&RESP=END)) THEN SET KILL=Y\n\n               ISPEXEC TBPUT  CTMPJT00\n         END /* OF PICKING UP MARKED LINES */\n\n         ISPEXEC TBTOP   CTMPJT00\n         SET LOOKROW=1\n         DO WHILE ((&LOOKROW<=&NUMROWS) AND (&KILL=N))\n           ISPEXEC TBSKIP  CTMPJT00\n           IF Z&OPER=ZS THEN +\n             DO\n                SET CUR=&LOOKROW\n                SET &OPER=&STR( )\n                ISPEXEC TBPUT CTMPJT00\n                SET &M=&MEM    /* CLEAN TRAILING BLANKS */\n                SET &J=&JNAM\n                SET CTMSLIB = &LIB\n                SET CTMSMEM = &M\n                SET CTMSJOB = &JNAM\n                ISPEXEC VGET (ZMONTH,ZDAY,ZYEAR)\n                IF &DATEFMT=WST THEN +\n                  DO\n                     SET &DTSTR=&STR(DD MM YY)\n                     SET D1 = &ZDAY\n                     SET D2 = &ZMONTH\n                     SET D3 = &ZYEAR\n                  END\n                IF &DATEFMT=USA THEN +\n                  DO\n                     SET &DTSTR=&STR(MM DD YY)\n                     SET D1 = &ZMONTH\n                     SET D2 = &ZDAY\n                     SET D3 = &ZYEAR\n                  END\n                IF &DATEFMT=JPN THEN +\n                  DO\n                     SET &DTSTR=&STR(YY MM DD)\n                     SET D1 = &ZYEAR\n                     SET D2 = &ZMONTH\n                     SET D3 = &ZDAY\n                  END\n                SET D1 = &SUBSTR(2:3,&EVAL(&D1+100))\n                SET D2 = &SUBSTR(2:3,&EVAL(&D2+100))\n                SET D3 = &SUBSTR(2:3,&EVAL(&D3+100))\n                SET THIS=Y\n                ISPEXEC DISPLAY PANEL(CTMPJ01W)\n                ISPEXEC VGET (ZVERB)\n                SET &RESP = &ZVERB\n                IF Z&RESP = Z THEN  SET &RESP = ENTER\n                IF ((&RESP=RETURN) OR (&RESP=END)) THEN SET &THIS=N\n\n                IF &THIS=Y THEN +\n                  DO\n                    IF &DATEFMT=WST THEN +\n                      DO\n                         SET DD = &D1\n                         SET MM = &D2\n                         SET YY = &D3\n                      END\n                    IF &DATEFMT=USA THEN +\n                      DO\n                         SET MM = &D1\n                         SET DD = &D2\n                         SET YY = &D3\n                      END\n                    IF &DATEFMT=JPN THEN +\n                      DO\n                         SET YY = &D1\n                         SET MM = &D2\n                         SET DD = &D3\n                      END\n\n                    /*****************************/\n                    /*  COMPUTE PREVIOUS DATE    */\n                    /*****************************/\n                     SET ZYEAR=&YY\n                     SET ZMONTH=&MM\n                     SET ZDAY=&DD\n                     IF &ZDAY GT 1 THEN DO\n                         SET DD=&ZDAY-1\n                         SET MM=&ZMONTH\n                       END\n                     ELSE DO\n                         IF &ZMONTH GT 1 THEN  SET MM=&ZMONTH-1\n                             ELSE DO\n                                SET MM=12\n                                SET YY=&ZYEAR-1\n                             END\n                         SET DD=31\n                         IF &MM=4 OR &MM=6 OR &MM=9 OR &MM=11 +\n                                        THEN SET DD=30\n                         IF &MM=2  THEN SET DD=28\n                         IF &MM=2 AND (&YY=88 OR &YY=92 OR &YY=96) +\n                                        THEN SET DD=29\n                          END\n\n                    SET MM=&SUBSTR(2:3,&EVAL(&MM+100))\n                    SET DD=&SUBSTR(2:3,&EVAL(&DD+100))\n                    SET ZDAY=&SUBSTR(2:3,&EVAL(&ZDAY+100))\n                    SET ZMONTH=&SUBSTR(2:3,&EVAL(&ZMONTH+100))\n\n                    IF &DATEFMT=USA THEN +\n                         %CTMCDAIL  CTMSLIB(&CTMSLIB) &NOALC +\n                                    CTMSMEM(&CTMSMEM) +\n                                    CTMSJOB(&CTMSJOB)   +\n                                    CTMGRP(&CTMGRP)     +\n                                    FORCE(&FRC)         +\n                                    &DEBUGD DATE1(&MM&DD&YY) +\n                                    DATE2(&ZMONTH&ZDAY&ZYEAR)\n\n                    IF &DATEFMT=WST THEN +\n                         %CTMCDAIL  CTMSLIB(&CTMSLIB) &NOALC +\n                                    CTMSMEM(&CTMSMEM) +\n                                    CTMSJOB(&CTMSJOB)   +\n                                    CTMGRP(&CTMGRP)     +\n                                    FORCE(&FRC)         +\n                                    &DEBUGD DATE1(&DD&MM&YY) +\n                                    DATE2(&ZDAY&ZMONTH&ZYEAR)\n\n                    IF &DATEFMT=JPN THEN +\n                         %CTMCDAIL  CTMSLIB(&CTMSLIB) &NOALC +\n                                    CTMSMEM(&CTMSMEM) +\n                                    CTMSJOB(&CTMSJOB)   +\n                                    CTMGRP(&CTMGRP)     +\n                                    FORCE(&FRC)         +\n                                    &DEBUGD DATE1(&YY&MM&DD) +\n                                    DATE2(&ZYEAR&ZMONTH&ZDAY)\n\n                    SET &NOALC=NOALC\n\n                  END  /* IF USER ALLOWED IT */\n             END   /*  PROCESSING A ROW  */\n\n           SET LOOKROW=&LOOKROW+1\n         END /* OF ORDERING JOBS */\n\n     END\n\n\nEND  /* OF MAIN LOOP AT HIGHEST SCREEN LEVEL */\nISPEXEC TBCLOSE CTMPJT00\nEXIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CTMJOBRQ": {"ttr": 7940, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x10_\\x00\\x94\\x10_\\x04\\x10\\x00a\\x00a\\x00\\x00\\xc9\\xd6\\xc1\\xf4\\xf1\\xf0@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-04-15T00:00:00", "modifydate": "1994-04-15T04:10:00", "lines": 97, "newlines": 97, "modlines": 0, "user": "IOA410"}, "text": "PROC 0 DEBUG  DATEFMT(USA)                          +\n              CTMSJOB()   /* DEFAULT FOR \"JOB NAME\" IS ' '         */\n /* WM1286 AM 220992 SUPPORT JAPANESE DATE */\n\nISPEXEC CONTROL ERRORS RETURN\nCONTROL MAIN NOLIST NOCONLIST NOSYMLIST NOMSG\nIF &DEBUG=DEBUG THEN CONTROL MAIN LIST CONLIST SYMLIST MSG\n\n  /*****************************/\n  /*   READ FROM PROFILE       */\n  /*****************************/\nISPEXEC VGET (CTMSLIB,CTMCAL) PROFILE\nIF &STR(&CTMSLIB) =          +\nTHEN +\n  SET CTMSLIB=&STR(SYSS.CTMO.V410.SCHEDULE)\nIF &STR(&CTMCAL) =          +\nTHEN +\n  SET CTMCAL=&STR(SYSS.IOA.V410.CAL)\nISPEXEC VGET (ZDAY,ZMONTH,ZYEAR)\nSET YY=&ZYEAR\nSET MM=&ZMONTH\nSET DD=&ZDAY\nSET &NOALC=&STR()\nSET MM=&SUBSTR(2:3,&EVAL(&MM+100))\nSET DD=&SUBSTR(2:3,&EVAL(&DD+100))\nSET CTMSMEM=\nSET CTMSJOB=\nREDISP:+\nIF &STR(&CTMSJOB)='1'  THEN SET CTMSJOB=&STR(*)\nSET CTMGRP=\nSET FRC=NO\nIF &DATEFMT=JPN THEN +\n            ISPEXEC DISPLAY PANEL(CTMPDALJ)\n            ELSE +\nIF &DATEFMT=USA THEN +\n            ISPEXEC DISPLAY PANEL(CTMPDALA)\n            ELSE ISPEXEC DISPLAY PANEL(CTMPDALW)\nIF &RESP = END THEN DO\n                      ISPEXEC VPUT (CTMSLIB,CTMCAL) PROFILE\n                      EXIT\n                    END\n\nSET ZYEAR=&YY\nSET ZMONTH=&MM\nSET ZDAY=&DD\nIF &ZDAY GT 1 THEN DO\n             SET DD=&ZDAY-1\n             SET MM=&ZMONTH\n             END\n      ELSE DO\n          IF &ZMONTH GT 1 THEN  SET MM=&ZMONTH-1\n                 ELSE DO\n                    SET MM=12\n                    SET YY=&ZYEAR-1\n                    END\n          SET DD=31\n          IF &MM=4 OR &MM=6 OR &MM=9 OR &MM=11 THEN SET DD=30\n          IF &MM=2  THEN SET DD=28\n          IF &MM=2 AND (&YY=88 OR &YY=92 OR &YY=96) THEN SET DD=29\n          END\nSET MM=&SUBSTR(2:3,&EVAL(&MM+100))\nSET DD=&SUBSTR(2:3,&EVAL(&DD+100))\nSET ZDAY=&SUBSTR(2:3,&EVAL(&ZDAY+100))\nSET ZMONTH=&SUBSTR(2:3,&EVAL(&ZMONTH+100))\nIF &STR('&CTMSJOB')=&STR('*')  THEN SET CTMSJOB='1'\nIF &STR('&CTMGRP') = ''   THEN SET CTMGRP='1'\nIF &DATEFMT=JPN THEN +\n     %CTMCDAIL  CTMSLIB(&CTMSLIB) CTMCAL(&CTMCAL) CTMSMEM(&CTMSMEM) +\n           CTMSJOB(&CTMSJOB)   +\n           CTMGRP(&CTMGRP)     +\n           FORCE(&FRC)         +\n           DBPREFA(SYSS.IOA) DBVERA(V410) +\n           DBPREFM(SYSS.CTMO) DBVERM(V410) +\n           &DEBUG DATE1(&YY&MM&DD) DATE2(&ZYEAR&ZMONTH&ZDAY) &NOALC\n   ELSE    +\nIF &DATEFMT=USA THEN +\n     %CTMCDAIL  CTMSLIB(&CTMSLIB) CTMCAL(&CTMCAL) CTMSMEM(&CTMSMEM) +\n           CTMSJOB(&CTMSJOB)   +\n           CTMGRP(&CTMGRP)     +\n           FORCE(&FRC)         +\n           DBPREFA(SYSS.IOA) DBVERA(V410) +\n           DBPREFM(SYSS.CTMO) DBVERM(V410) +\n           &DEBUG DATE1(&MM&DD&YY) DATE2(&ZMONTH&ZDAY&ZYEAR) &NOALC\n   ELSE    +\n      %CTMCDAIL  CTMSLIB(&CTMSLIB) CTMCAL(&CTMCAL) CTMSMEM(&CTMSMEM) +\n           CTMSJOB(&CTMSJOB)   +\n           CTMGRP(&CTMGRP)     +\n           FORCE(&FRC)         +\n           DBPREFA(SYSS.IOA) DBVERA(V410) +\n           DBPREFM(SYSS.CTMO) DBVERM(V410) +\n           &DEBUG DATE1(&DD&MM&YY) DATE2(&ZDAY&ZMONTH&ZYEAR) &NOALC\nSET &NOALC=NOALC\nSET YY=&ZYEAR\nSET DD=&SUBSTR(2:3,&EVAL(&ZDAY+100))\nSET MM=&SUBSTR(2:3,&EVAL(&ZMONTH+100))\nGOTO REDISP\nEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CTMQUICK": {"ttr": 7943, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x10_\\x00\\x94\\x10_\\x04\\x10\\x00u\\x00u\\x00\\x00\\xc9\\xd6\\xc1\\xf4\\xf1\\xf0@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-04-15T00:00:00", "modifydate": "1994-04-15T04:10:00", "lines": 117, "newlines": 117, "modlines": 0, "user": "IOA410"}, "text": "PROC 0 DEBUG(X) D10(X) D15(X) D20(X) D30(X) D40(X)\n\nISPEXEC CONTROL ERRORS CANCEL\nSET &RC = &LASTCC\nIF &RC \u00ac= 0 THEN EXIT QUIT\n\nCONTROL MAIN NOLIST NOCONLIST NOSYMLIST NOMSG\nIF &DEBUG=DEBUG THEN CONTROL MAIN LIST CONLIST SYMLIST MSG\nCONTROL ASIS\nSET &ACTION = CANCEL\n\n/********************************************************/\n/**                                                    **/\n/**    CONTROL-M QUICK SCHEDULE DEFINITION             **/\n/**                                                    **/\n/**    CLIST CTMQUICK                                  **/\n/**                                                    **/\n/**    THIS IS THE ENTRY CLIST AND HIGH LEVEL LOGIC    **/\n/**                                                    **/\n/********************************************************/\n\nISPEXEC VPUT (ZHTOP)\n\nSET &KILL = N   /* USER HAS NOT ENDED THE CLIST */\n\nDO WHILE &KILL\u00ac=X /*THAT IS, REPEAT UNTIL USER ENDS IT ALL */\nSET &SKELVALD=N  /* WE DONT YET HAVE A VALID SKELETON */\n\nDO WHILE (&SKELVALD=N)\n\n  /********************************************************/\n  /**    GET LIBRARY, TABLE, GROUP NAMES                 **/\n  /********************************************************/\n\n    %CTMCK10   DEBUG(&D10)\n\n    ISPEXEC VGET (ZVERB)\n    IF (&ZVERB = END) OR (&ZVERB = RETURN) THEN EXIT    QUIT\n\n  /********************************************************/\n  /**    GET SKELETON SCHEDULING TABLE                   **/\n  /********************************************************/\n\n    %CTMCK15   DEBUG(&D15)\n    ISPEXEC VGET (IOERROR CTMPKIN SKELVALD)\n    IF &IOERROR=Y THEN +\n      DO\n        ISPEXEC CONTROL ERRORS RETURN\n        ISPEXEC LMCLOSE DATAID(&CTMPKIN)\n        ISPEXEC LMFREE  DATAID(&CTMPKIN)\n      END\n\nEND\n\n/********************************************************/\n/**    CREATE A CLEAN JOBNAME TABLE                    **/\n/********************************************************/\n\n  ISPEXEC CONTROL ERRORS RETURN\n\n  ISPEXEC TBQUERY CTMPKT00\n  SET &RC = &LASTCC\n  IF &RC = 0 THEN  +\n     ISPEXEC TBCLOSE CTMPKT00\n\n  ISPEXEC TBQUERY CTMPKT99\n  SET &RC = &LASTCC\n  IF &RC = 0 THEN  +\n     ISPEXEC TBCLOSE CTMPKT99\n\n  ISPEXEC CONTROL ERRORS &ACTION\n\n  ISPEXEC TBCREATE CTMPKT00 NAMES(POPER  OPER   JNAM +\n     DJ1 DJ2 DJ3 DJ4 DJ5 DJ6 DJ7 DJ8 DJ9 DJ10 DJ11 DJ12 +\n     T1 T2 T3 T4 T5 T6 T7 T8 T9 T10 T11 T12 +\n     JNUM DEPS NUMDEPS DESC XCOND REBUILD DEPVAL WASCHG) NOWRITE\n\n  ISPEXEC TBCREATE CTMPKT99 NAMES(TOJOB FRJOBNUM FRJOBNAM) NOWRITE\n\n/********************************************************/\n/**    GET JOBS LIST FROM THE USER                     **/\n/********************************************************/\n\n  %CTMCK20  DEBUG(&D20)\n\n  ISPEXEC VGET (ZVERB HIUSED)\n  SET &RESP = &ZVERB\n\n  IF &RESP = RETURN THEN  EXIT QUIT /* USER HIT RETURN KEY */\n\n  IF &HIUSED=0 THEN SET &ENDED=Y\n     ELSE SET &ENDED=N\n\n  DO WHILE (&ENDED=N)\n    /*****************************************/\n    /**    GET FINAL DESTINATION OF TABLE   **/\n    /*****************************************/\n    %CTMCK30    DEBUG(&D30)\n    ISPEXEC VGET (ENDED)\n    IF (&ENDED=Y) THEN ISPEXEC SETMSG MSG(CTMK003B)\n    ELSE +\n      DO\n        /*****************************************/\n        /**    WRITE THE SCHEDULING TABLE       **/\n        /*****************************************/\n        %CTMCK40   DEBUG(&D40)\n        ISPEXEC VGET (IOERROR CTMPKOT)\n        IF &IOERROR=N THEN SET &ENDED=Y\n        ELSE +\n          DO\n            ISPEXEC LMCLOSE DATAID(&CTMPKOT)\n            ISPEXEC LMFREE  DATAID(&CTMPKOT)\n          END\n      END\n  END\nEND  /* OF MAIN LOOP AT HIGHEST SCREEN LEVEL */\nEXIT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CTMSETSB": {"ttr": 7946, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x10_\\x00\\x94\\x10_\\x04\\x10\\x00X\\x00X\\x00\\x00\\xc9\\xd6\\xc1\\xf4\\xf1\\xf0@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-04-15T00:00:00", "modifydate": "1994-04-15T04:10:00", "lines": 88, "newlines": 88, "modlines": 0, "user": "IOA410"}, "text": "ISREDIT MACRO (PARM)\n/********************************************************************/\n/*                                                                  */\n/* PURPOSE: THIS CLIST MAY BE USED TO REPLACE THE STANDARD SUBMIT   */\n/*          COMMAND BY CONTROL-M QUICK-SUBMIT FUNCTION.             */\n/*                                                                  */\n/*          TO TURN THIS OPTION ON, THE USER SHOULD INVOKE THAT     */\n/*          CLIST UNDER ISPF WHILE EDITING A MEMBER. FROM           */\n/*          THAT MOMENT ON, WHENEVER HE SUBMITS A MEMBER FROM A     */\n/*          LIBRARY WITH THE SAME 'PROJECT' - CONTROL-M'S QUICK-    */\n/*          SUBMIT WILL BE OPERATED INSTEAD.                        */\n/*                                                                  */\n/*          TO TURN THIS OPTION OFF, THE USER MAY INVOKE THAT       */\n/*          CLIST UNDER ISPF WHILE HE IS EDITING A MEMBER, BUT      */\n/*          THIS TIME WITH THE PARAMETER 'DELETE'.                  */\n/*                                                                  */\n/*         E.G.                                                     */\n/*            COMMAND ===> CTMSETSB                                 */\n/*            COMMAND ===> CTMSETSB DELETE                          */\n/*                                                                  */\n/* REMARK:                                                          */\n/*                                                                  */\n/*           THIS COMMAND IS EFFECTIVE FOR ALL LIBRARIES THAT HAVE  */\n/*           THE SAME 'PROJECT' DEFINITION.  IF YOU USE LIBRARIES   */\n/*           WITH DIFFERENT 'PROJECTS' DEFINITIONS, YOU WILL NEED   */\n/*           TO EXECUTE THIS CLIST FOR EACH PROJECT.                */\n/*                                                                  */\n/********************************************************************/\n\n      IF &PARM=DEBUG +\n      THEN +\n         CONTROL LIST MSG SYMLIST\n\n      IF &PARM=DELETE +\n      THEN +\n         DO                          /* ERASE EXISTANCE OF IMACRO */\n            ISREDIT PROFILE UNLOCK\n            ISREDIT IMACRO  NONE\n            ISREDIT PROFILE LOCK\n            ISREDIT END              /* TO SAVE THE PROFILE CHANGES */\n            WRITE THE SUBMIT COMMAND HAS BEEN RESTORED SUCCESSFULLY\n           EXIT\n         END\n\n      ISREDIT (IMACRO) = IMACRO      /* IDENTIFY THE CURRENT IMACRO */\n      IF &IMACRO=NONE +\n      THEN +\n         DO\n            WRITE ************************************************\n            WRITE * IN ORDER TO REPLACE THE SUBMIT COMMAND THERE *\n            WRITE * IS A NEED TO SAVE AND EXIT THE MEMBER YOU ARE*\n            WRITE * CURRENTLY EDITTING.                          *\n            WRITENR * DO YOU AGREE FOR DOING \"SAVE\" NOW (Y,N) ?\n            READ  &ANS\n            IF &ANS\u00ac=Y THEN DO\n                      WRITE\n                      WRITE REPLACE WAS NOT DONE (AS YOU REQUESTED).\n                      EXIT\n                            END\n            ISREDIT PROFILE UNLOCK\n            ISREDIT IMACRO  CTMSETSB\n            ISREDIT PROFILE LOCK\n            ISREDIT END              /* TO SAVE THE PROFILE CHANGES */\n            WRITE\n            WRITE THE SUBMIT COMMAND HAS BEEN REPLACED SUCCESSFULLY\n            EXIT\n        END\n      ELSE +\n      IF &IMACRO=CTMSETSB +\n      THEN +\n         DO                                   /* REGULAR ENTRY        */\n            ISREDIT DEFINE CTMQSB PGM MACRO   /* IMACRO IS ALREADY ON */\n            ISREDIT DEFINE SUB    ALIAS CTMQSB   /* USUAL ENTRY  */\n            ISREDIT DEFINE SUBMIT ALIAS CTMQSB\n            EXIT\n         END\n      ELSE +\n         DO                   /* THE USER HAVE ALREADY ANOTHER IMACRO */\n            WRITE\n            WRITE YOU ALREADY HAVE AN \"IMACRO\" . CONTACT YOUR SYSTEM\n            WRITE PROGRAMMER TO ADD THE 3 FOLLOWING COMMANDS TO YOUR\n            WRITE IMACRO :\n            WRITE            ISREDIT DEFINE CTMQSB PGM MACRO\n            WRITE            ISREDIT DEFINE SUB    ALIAS CTMQSB\n            WRITE            ISREDIT DEFINE SUBMIT ALIAS CTMQSB\n            WRITE\n            EXIT\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CTMXTSO": {"ttr": 7949, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x10_\\x00\\x94\\x10_\\x04\\x10\\x00\\r\\x00\\r\\x00\\x00\\xc9\\xd6\\xc1\\xf4\\xf1\\xf0@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-04-15T00:00:00", "modifydate": "1994-04-15T04:10:00", "lines": 13, "newlines": 13, "modlines": 0, "user": "IOA410"}, "text": "PROC 0 LOADLIB(SYS1.IOA.V410.LOAD)\n\n/*******************************************************************/\n/*                                                                 */\n/* THIS CLIST CALLS THE ONLINE FACILITY UNDER TSO/ROSCOE UNDER THE */\n/* CROSS MEMORY INTERFACE.                                         */\n/*                                                                 */\n/*******************************************************************/\n\n\nCALL  '&LOADLIB(CTMCTSO)' 'TMAN'\n\nEXIT CODE(&MAXCC)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CTMXTSOD": {"ttr": 7951, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x10_\\x00\\x94\\x10_\\x04\\x10\\x00\\r\\x00\\r\\x00\\x00\\xc9\\xd6\\xc1\\xf4\\xf1\\xf0@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-04-15T00:00:00", "modifydate": "1994-04-15T04:10:00", "lines": 13, "newlines": 13, "modlines": 0, "user": "IOA410"}, "text": "PROC 0 LOADLIB(SYS1.IOA.V410.LOAD)\n\n/*******************************************************************/\n/*                                                                 */\n/* THIS CLIST CALLS THE ONLINE FACILITY UNDER TSO/ROSCOE UNDER THE */\n/* CROSS MEMORY INTERFACE - SHARED DATABASE MODE                   */\n/*                                                                 */\n/*******************************************************************/\n\n\nCALL  '&LOADLIB(CTMCTSO)' 'TMND'\n\nEXIT CODE(&MAXCC)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CTOISPF": {"ttr": 7953, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x10_\\x00\\x94\\x10_\\x04\\x10\\x00\\n\\x00\\n\\x00\\x00\\xc9\\xd6\\xc1\\xf4\\xf1\\xf0@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-04-15T00:00:00", "modifydate": "1994-04-15T04:10:00", "lines": 10, "newlines": 10, "modlines": 0, "user": "IOA410"}, "text": "PROC 0  APPLTYPE(I)  -\n        APPLID(CO)\n/****************************************************************\n/*                                                              *\n/*  CONTROL-M:   PRODUCTION CONTROL  SYSTEM          (ISPF)     *\n/*  CONTROL-O:   AUTOMATED CONSOLE MANAGEMENT SYSTEM (ISPF)     *\n/*                                                              *\n/****************************************************************\n%IOAONL APPLTYPE(&APPLTYPE) APPLID(&APPLID)\nEND:END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CTOISPFK": {"ttr": 7955, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x10_\\x00\\x94\\x10_\\x04\\x10\\x00\\x0b\\x00\\x0b\\x00\\x00\\xc9\\xd6\\xc1\\xf4\\xf1\\xf0@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-04-15T00:00:00", "modifydate": "1994-04-15T04:10:00", "lines": 11, "newlines": 11, "modlines": 0, "user": "IOA410"}, "text": "PROC 0  APPLTYPE(I)  -\n        APPLID(CK)\n/****************************************************************\n/*                                                              *\n/*  CONTROL-M:   PRODUCTION CONTROL  SYSTEM          (ISPF)     *\n/*  CONTROL-D:   REPORT DISTRIBUTION SYSTEM          (ISPF)     *\n/*  CONTROL-O:   AUTOMATED CONSOLE MANAGEMENT SYSTEM (ISPF)     *\n/*                                                              *\n/****************************************************************\n%IOAONL APPLTYPE(&APPLTYPE) APPLID(&APPLID)\nEND:END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CTOXTSO": {"ttr": 7957, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x10_\\x00\\x94\\x10_\\x04\\x10\\x00\\r\\x00\\r\\x00\\x00\\xc9\\xd6\\xc1\\xf4\\xf1\\xf0@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-04-15T00:00:00", "modifydate": "1994-04-15T04:10:00", "lines": 13, "newlines": 13, "modlines": 0, "user": "IOA410"}, "text": "PROC 0 LOADLIB(SYS1.IOA.V410.LOAD)\n\n/*******************************************************************/\n/*                                                                 */\n/* THIS CLIST CALLS THE ONLINE FACILITY UNDER TSO/ROSCOE UNDER THE */\n/* CROSS MEMORY INTERFACE.                                         */\n/*                                                                 */\n/*******************************************************************/\n\n\nCALL  '&LOADLIB(CTMCTSO)' 'TMNO'\n\nEXIT CODE(&MAXCC)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CTOXTSOK": {"ttr": 7959, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x10_\\x00\\x94\\x10_\\x04\\x10\\x00\\x0f\\x00\\x0f\\x00\\x00\\xc9\\xd6\\xc1\\xf4\\xf1\\xf0@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-04-15T00:00:00", "modifydate": "1994-04-15T04:10:00", "lines": 15, "newlines": 15, "modlines": 0, "user": "IOA410"}, "text": "PROC 0 LOADLIB(SYS1.IOA.V410.LOAD)   +\n       DBG(DUMMY)\n/*******************************************************************/\n/*                                                                 */\n/* THIS CLIST CALLS THE ONLINE FACILITY UNDER TSO/ROSCOE UNDER THE */\n/* CROSS MEMORY INTERFACE.                                         */\n/*                                                                 */\n/*******************************************************************/\nFREE F(PRTDBG)\n\nALLOC F(PRTDBG) &DBG SYSOUT(A)  HOLD\n\nCALL  '&LOADLIB(CTMCTSO)' 'TMNK'\n\nEXIT CODE(&MAXCC)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CTRCCLN": {"ttr": 8193, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x10_\\x00\\x94\\x10_\\x04\\x10\\x00\\xa5\\x00\\xa5\\x00\\x00\\xc9\\xd6\\xc1\\xf4\\xf1\\xf0@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-04-15T00:00:00", "modifydate": "1994-04-15T04:10:00", "lines": 165, "newlines": 165, "modlines": 0, "user": "IOA410"}, "text": "PROC 0 DEBUG                +\n       DATEMFT(USA)   +\n       ILPREFM(SYSM.CTMI)   +\n       ILVERM(V410)     +\n       OLVERM(V410)     +\n       DBPREFM(SYSS.CTMO)   +\n       DBVERM(V410)     +\n       LANG()         +\n       LOADLIB(SYS1.IOA.V410.LOAD)   +\n       DBG(DUMMY)           +\n       CLASS(NULL)          +\n       PRTDBG               +\n       NOALC\n /*                                                        */\n /* THE \"CLASS\" PARAMETER SHOULD CONTAIN 'NULL' IN CASE NO */\n /* CLASS/JOBNAME REPLACEMENT IS REQUIRED.                 */\n /*                                                        */\nCONTROL MAIN NOLIST NOCONLIST NOMSG NOFLUSH\nFREE DD(PRTDBG)\nIF &PRTDBG=PRTDBG +\nTHEN +\n  ALLOC F(PRTDBG) DA(*)\nELSE +\n  ALLOC F(PRTDBG) &DBG SYSOUT(A)  HOLD\nIF &DEBUG=DEBUG  +\n   THEN CONTROL MAIN LIST CONLIST SYMLIST MSG\n\nISPEXEC VGET (ZDAY,ZMONTH,ZYEAR,ZUSER)\nSET CTMFUN=SUBMIT\nSET CTMLIBN=&ILPREFM..&ILVERM..JCL\nSET CTMGLOB=&ILPREFM..&ILVERM..PARM\nSET CTMUSERN=&ZUSER\nSET CL=&CLASS\nSET YW=&ZYEAR\nSET YO=&ZYEAR\nSET MW=&ZMONTH\nSET MO=&ZMONTH\nSET DW=&ZDAY\nSET DO=&ZDAY\nSET &NOALC=&STR()\nSET MW=&SUBSTR(2:3,&EVAL(&MW+100))\nSET MO=&SUBSTR(2:3,&EVAL(&MO+100))\nSET DW=&SUBSTR(2:3,&EVAL(&DW+100))\nSET DO=&SUBSTR(2:3,&EVAL(&DO+100))\nREDISP:+\nSET &ALLOCAES=0\nSET &ALLOCSUB=0\nSET &ALLOCSTR=0\nISPEXEC VPUT DATEFMT PROFILE\nISPEXEC DISPLAY PANEL(CTRPCLN)\nIF &RESP = END THEN GOTO FINISH\nLISTDSI DALIB FILE PREALLOC\nSET  OLDDALIB = &SYSDSNAME\nFREE  DD(DALIB)\nALLOC DD(DALIB)    DA('&ILPREFM..&ILVERM..PARM') SHR\nLISTDSI DACKPT FILE PREALLOC\nSET  OLDDACKP = &SYSDSNAME\nFREE  DD(DACKP)\nALLOC DD(DACKP)    DA('&DBPREFM..&DBVERM..CKP') SHR\nFREE  DD(DAGLOBAL,DASUBMIT,DASIM,SYSPRINT,DACTRFL,ATTR)\nALLOC F(ATTR) BLKSIZE(8000)\nALLOC DD(DAGLOBAL) DA('&CTMGLOB') SHR\n\nDELETE '&SYSUID..&OLVERM..AESBRO'\nALLOC DD(SYSPRINT) DA('&SYSUID..&OLVERM..AESBRO') TR SP(1 1) MOD\n\nIF &LASTCC\u00ac=0 +\n THEN SET &ALLOCAES=1\n\nDELETE '&SYSUID..&OLVERM..SUBMIT'\nALLOC DD(DASUBMIT) DA('&SYSUID..&OLVERM..SUBMIT') -\n      TR SP(1 1) NEW DELETE US(ATTR)\n\nIF &LASTCC\u00ac=0 +\n THEN SET &ALLOCSUB=1\nALLOC DD(DASIM)    NEW TRACKS SP(1 1)\nOPENFILE DASIM OUTPUT\nSET DASIM=&STR(+\nLIBRARY &CTMLIBN)\nPUTFILE DASIM\nSET DASIM=&STR(+\nMEMBER  &CTMMEMN)\nPUTFILE DASIM\nSET DASIM=&STR(+\nUSERID  &CTMUSERN)\nPUTFILE DASIM\nSET DASIM=&STR(+\nWDATE   &DW.&MW.&YW)\nPUTFILE DASIM\nSET DASIM=&STR(+\nODATE   &DO.&MO.&YO)\nPUTFILE DASIM\nSET DASIM=&STR(+\n&CTMFUN)\nPUTFILE DASIM\nCLOSFILE DASIM\nTSOEXEC CALL '&LOADLIB&LANG(CTMAES)'\n\nSET &M1=&CTMMEMN\nIF &DATATYPE(&ORDER)=NUM +\nTHEN +\n  SET &O1=&SUBSTR(2:6,&EVAL(&ORDER+100000))\nELSE +\n  SET &O1=&ORDER\nSET &F1=&FROMPGM\nSET &F2=&FROMSTEP\nSET &F3=&TOPGM\nSET &F4=&TOSTEP\nSET &S1=SAVE2\nSET &A1=&STR(C)\n\nDELETE '&SYSUID..O&O1..ARCHIVE'\nALLOC DD(DACTRFL) DA('&SYSUID..O&O1..ARCHIVE') SPACE(2 1) TR\n\n\nTSOEXEC CALL '&LOADLIB&LANG(CTMAJF)' 'ORDERID=&ORDER MEMBER=&M1'\nSET &AJFRC=&LASTCC\n\nFREE F(DACTRFL)\nFREE  DD(SYSPRINT)\n\nALLOC DD(SYSPRINT) DA('&SYSUID..&OLVERM..AESBRO') SHR DELETE\n\n\nIF &ALLOCAES=1 +\nTHEN DO\n     WRITE ALLOCATION ERROR\n     GOTO REDISP\n     END\nISPEXEC LMINIT DATAID(CTMAES2) DDNAME(SYSPRINT)\nISPEXEC VPUT (M1 O1 F1 F2 F3 F4 S1 A1 CL)\nISPEXEC EDIT DATAID(&CTMAES2)  MACRO(CTRMACRO)\nISPEXEC BROWSE  DATAID(&CTMAES2)\nISPEXEC LMFREE DATAID(&CTMAES2)\n\nIF &AJFRC NE 0 +\nTHEN DO\n     ISPEXEC SETMSG MSG(CTRC001E)\n     GOTO REDISP\n     END\n\nFREE  DD(SYSPRINT)\nALLOC DD(SYSPRINT) DA(*)\nIF '&OLDDALIB' = '' THEN GOTO NODEALL\nFREE DD(DALIB)\nALLOC DD(DALIB) DA('&OLDDALIB')  SHR\nNODEALL:+\nIF '&OLDDACKP' = '' THEN GOTO NODEALC\nFREE DD(DACKP)\nALLOC DD(DACKP) DA('&OLDDACKP')  SHR\nNODEALC:+\nIF &SYSINDEX(SUB,&CTMFUN) NE 0  AND &ALLOCSUB=0 +\nTHEN DO\n       SET &S1=SAVE1\n       ISPEXEC VPUT (S1)\n       ISPEXEC LMINIT DATAID(CTMSUB2) DDNAME(DASUBMIT)\n       ISPEXEC CONTROL ERRORS RETURN\n       ISPEXEC EDIT  DATAID(&CTMSUB2) MACRO(CTRMACRO)\n       ISPEXEC LMFREE DATAID(&CTMSUB2)\n       CONTROL MSG\n       SUB '&SYSUID..&OLVERM..SUBMIT'\n       CONTROL NOMSG\n     END\nGOTO  REDISP\nFINISH: EXIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CTRCSIM": {"ttr": 8197, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x10_\\x00\\x94\\x10_\\x04\\x10\\x00\\xa6\\x00\\xa6\\x00\\x00\\xc9\\xd6\\xc1\\xf4\\xf1\\xf0@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-04-15T00:00:00", "modifydate": "1994-04-15T04:10:00", "lines": 166, "newlines": 166, "modlines": 0, "user": "IOA410"}, "text": "PROC 0 DEBUG                +\n       DATEFMT(WST)   +\n       ILPREFM(CTMP)   +\n       ILVERM(V400)     +\n       OLVERM(V400)     +\n       DBPREFM(IOAP)   +\n       DBVERM(V400)     +\n       LANG()         +\n       LOADLIB(IOAP.V400.LOAD)   +\n       DBG(DUMMY)           +\n       CLASS(NULL)          +\n       PRTDBG               +\n       NOALC\n /*                                                        */\n /* THE \"CLASS\" PARAMETER SHOULD CONTAIN 'NULL' IN CASE NO */\n /* CLASS/JOBNAME REPLACEMENT IS REQUIRED.                 */\n /*                                                        */\n /* WM1286  22.09.92 SUPPORT JAPANESE DATE                 */\nCONTROL MAIN NOLIST NOCONLIST NOMSG NOFLUSH\nFREE DD(PRTDBG)\nIF &PRTDBG=PRTDBG +\nTHEN +\n  ALLOC F(PRTDBG) DA(*)\nELSE +\n  ALLOC F(PRTDBG) &DBG SYSOUT(A)  HOLD\nIF &DEBUG=DEBUG  +\n   THEN CONTROL MAIN LIST CONLIST SYMLIST MSG\n\nISPEXEC VGET (ZDAY,ZMONTH,ZYEAR,ZUSER)\nSET CTMFUN=SUBMIT\nSET CTMLIBN=&ILPREFM..&ILVERM..JCL\nSET CTMGLOB=&ILPREFM..&ILVERM..PARM\nSET CTMUSERN=&ZUSER\nSET CL=&CLASS\nREDISP:+\nSET YW=&ZYEAR\nSET YO=&ZYEAR\nSET MW=&ZMONTH\nSET MO=&ZMONTH\nSET DW=&ZDAY\nSET DO=&ZDAY\nSET &NOALC=&STR()\nSET MW=&SUBSTR(2:3,&EVAL(&MW+100))\nSET MO=&SUBSTR(2:3,&EVAL(&MO+100))\nSET DW=&SUBSTR(2:3,&EVAL(&DW+100))\nSET DO=&SUBSTR(2:3,&EVAL(&DO+100))\nSET &ALLOCAES=0\nSET &ALLOCSUB=0\nSET &ALLOCSTR=0\nISPEXEC VPUT DATEFMT PROFILE\nISPEXEC DISPLAY PANEL(CTRPSIM)\nIF &RESP = END THEN GOTO FINISH\nLISTDSI DALIB FILE PREALLOC\nSET  OLDDALIB = &SYSDSNAME\nFREE  DD(DALIB)\nALLOC DD(DALIB)    DA('&ILPREFM..&ILVERM..PARM') SHR\nLISTDSI DACKPT FILE PREALLOC\nSET  OLDDACKP = &SYSDSNAME\nFREE  DD(DACKP)\nALLOC DD(DACKP)    DA('&DBPREFM..&DBVERM..CKP') SHR\nFREE  DD(DAGLOBAL,DASUBMIT,DASIM,SYSPRINT,DACTRFL,ATTR)\nALLOC F(ATTR) BLKSIZE(8000)\nALLOC DD(DAGLOBAL) DA('&CTMGLOB') SHR\n\nDELETE '&SYSUID..&OLVERM..AESBRO'\nALLOC DD(SYSPRINT) DA('&SYSUID..&OLVERM..AESBRO') TR SP(1 1) MOD\n\nIF &LASTCC\u00ac=0 +\n THEN SET &ALLOCAES=1\n\nDELETE '&SYSUID..&OLVERM..SUBMIT'\nALLOC DD(DASUBMIT) DA('&SYSUID..&OLVERM..SUBMIT') -\n      TR SP(1 1) NEW DELETE US(ATTR)\n\nIF &LASTCC\u00ac=0 +\n THEN SET &ALLOCSUB=1\nALLOC DD(DASIM)    NEW TRACKS SP(1 1)\nOPENFILE DASIM OUTPUT\nSET DASIM=&STR(+\nLIBRARY &CTMLIBN)\nPUTFILE DASIM\nSET DASIM=&STR(+\nMEMBER  &CTMMEMN)\nPUTFILE DASIM\nSET DASIM=&STR(+\nUSERID  &CTMUSERN)\nPUTFILE DASIM\nSET DASIM=&STR(+\nWDATE   &DW.&MW.&YW)\nPUTFILE DASIM\nSET DASIM=&STR(+\nODATE   &DO.&MO.&YO)\nPUTFILE DASIM\nSET DASIM=&STR(+\n&CTMFUN)\nPUTFILE DASIM\nCLOSFILE DASIM\nTSOEXEC CALL '&LOADLIB&LANG(CTMAES)'\n\nSET &M1=&CTMMEMN\nIF &DATATYPE(&ORDER)=NUM +\nTHEN +\n  SET &O1=&SUBSTR(2:6,&EVAL(&ORDER+100000))\nELSE +\n  SET &O1=&ORDER\nSET &F1=&FROMPGM\nSET &F2=&FROMSTEP\nSET &F3=&TOPGM\nSET &F4=&TOSTEP\nSET &S1=SAVE2\nSET &A1=&ACT\n\nDELETE '&SYSUID..O&O1..ARCHIVE'\nALLOC DD(DACTRFL) DA('&SYSUID..O&O1..ARCHIVE') SPACE(2 1) TR\n\n\nTSOEXEC CALL '&LOADLIB&LANG(CTMAJF)' 'ORDERID=&ORDER MEMBER=&M1'\nSET &AJFRC=&LASTCC\n\nFREE F(DACTRFL)\nFREE  DD(SYSPRINT)\n\nALLOC DD(SYSPRINT) DA('&SYSUID..&OLVERM..AESBRO') SHR DELETE\n\n\nIF &ALLOCAES=1 +\nTHEN DO\n     WRITE ALLOCATION ERROR\n     GOTO REDISP\n     END\nISPEXEC LMINIT DATAID(CTMAES2) DDNAME(SYSPRINT)\nISPEXEC VPUT (M1 O1 F1 F2 F3 F4 S1 A1 CL)\nISPEXEC EDIT DATAID(&CTMAES2)  MACRO(CTRMACRO)\nISPEXEC BROWSE  DATAID(&CTMAES2)\nISPEXEC LMFREE DATAID(&CTMAES2)\n\nIF &AJFRC NE 0 +\nTHEN DO\n     ISPEXEC SETMSG MSG(CTRC001E)\n     GOTO REDISP\n     END\n\nFREE  DD(SYSPRINT)\nALLOC DD(SYSPRINT) DA(*)\nIF '&OLDDALIB' = '' THEN GOTO NODEALL\nFREE DD(DALIB)\nALLOC DD(DALIB) DA('&OLDDALIB')  SHR\nNODEALL:+\nIF '&OLDDACKP' = '' THEN GOTO NODEALC\nFREE DD(DACKP)\nALLOC DD(DACKP) DA(&OLDDACKP)  SHR\nNODEALC:+\nIF &SYSINDEX(SUB,&CTMFUN) NE 0  AND &ALLOCSUB=0 +\nTHEN DO\n       SET &S1=SAVE1\n       ISPEXEC VPUT (S1)\n       ISPEXEC LMINIT DATAID(CTMSUB2) DDNAME(DASUBMIT)\n       ISPEXEC CONTROL ERRORS RETURN\n       ISPEXEC EDIT  DATAID(&CTMSUB2) MACRO(CTRMACRO)\n       ISPEXEC LMFREE DATAID(&CTMSUB2)\n       CONTROL MSG\n       SUB '&SYSUID..&OLVERM..SUBMIT'\n       CONTROL NOMSG\n     END\nGOTO  REDISP\nFINISH: EXIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CTRMACRO": {"ttr": 8201, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x10_\\x00\\x94\\x10_\\x04\\x10\\x00\\xd3\\x00\\xd3\\x00\\x00\\xc9\\xd6\\xc1\\xf4\\xf1\\xf0@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-04-15T00:00:00", "modifydate": "1994-04-15T04:10:00", "lines": 211, "newlines": 211, "modlines": 0, "user": "IOA410"}, "text": "CONTROL END(END)\n/*                                              */\n/* ADD LINE BEFORE THE FIRST \"EXEC PGM\" CARD    */\n/*                                              */\nISREDIT MACRO\n\n/* CONTROL LIST SYMLIST CONLIST MSG\n\nSET &ROW=0\nSET &KEEPPROC=0\nSET &KEEPEXEC=0\nSET &SWEXEC=0\nSET &SWPROC=0\nSET &REMARK=&STR(//*)\nSET &SLASH=&STR(//)\nISPEXEC VGET (M1 O1 F1 F2 F3 F4 S1 A1 CL )\nSET &ACTCL=&STR(&A1)\nIF &ACTCL=&STR(C)  +\n  THEN GOTO NOCHANG\nIF &CL=&STR(NULL)   +\n  THEN GOTO NOCHANG\nISREDIT SCAN = OFF\nISREDIT FIND ' JOB ' ALL\nFINDJOB: +\nIF &S1=SAVE2 +\n  THEN DO\n       SET &FROM=2\n       SET &TO=4\n       END\n  ELSE DO\n       SET &FROM=1\n       SET &TO=3\n       END\nISREDIT (ROW,COL) = CURSOR\nSET &COLJOB=&COL\nSET &ROWJOB=&ROW\nISREDIT (STRING) = LINE .ZCSR\nIF '&STR(&SUBSTR(&FROM:&TO,&STR(&STRING).000))'='&STR(&REMARK)' +\nTHEN DO\n       SET &KEEPJOB=&ROWJOB\n       ISREDIT FIND ' JOB ' NEXT\n       GOTO FINDJOB\n     END\nELSE DO\n     IF &S1=SAVE2 +\n       THEN DO\n            SET &FROM=2\n            SET &TO=3\n            END\n       ELSE DO\n            SET &FROM=1\n            SET &TO=2\n            END\n     IF '&STR(&SUBSTR(&FROM:&TO,&STR(&STRING).000))'='&STR(&SLASH)' +\n     THEN DO\n          IF &S1=SAVE2 +\n            THEN DO\n                 SET &JOB1 = &STR( //)\n                 SET &JOB3 = &STR(&SUBSTR(8:72,&STR(&STRING)))\n                 END\n            ELSE DO\n                 SET &JOB1 = &STR(//)\n                 SET &JOB3 = &STR(&SUBSTR(7:72,&STR(&STRING)))\n                 END\n          SET &JOB2 = &STR(&SUBSTR(1:4,&STR(&SYSUID)))\n          SET &JOBC = &STR(&JOB1.&JOB2.&JOB3)\n          ISREDIT LINE &ROWJOB = \"&JOBC.\"\n          END\n      ELSE DO\n           SET &KEEPJOB=&ROWJOB\n           ISREDIT FIND ' JOB ' NEXT\n           GOTO FINDJOB\n           END\n     END\nISREDIT FIND 'CLASS='\nFINDCLS: +\nISREDIT (ROW,COL) = CURSOR\nSET &COLCLS=&COL\nSET &ROWCLS=&ROW\nISREDIT (KEYWRD) = LINE .ZCSR\nIF '&STR(&SUBSTR(&FROM:&TO,&STR(&KEYWRD).000))'='&STR(&REMARK)' +\nTHEN DO\n       SET &KEEPCLS=&ROWCLS\n       ISREDIT FIND 'CLASS=' NEXT\n       GOTO FINDCLS\n     END\nELSE DO\n       SET &BEFCOL = &COLCLS-3\nIF '&STR(&SUBSTR(&BEFCOL:&COLCLS,&STR(&KEYWRD).000))'='&STR(MSGC)' +\n       THEN DO\n              SET &KEEPCLS=&ROWCLS\n              ISREDIT FIND 'CLASS=' NEXT\n              GOTO FINDCLS\n            END\n       ELSE DO\n              SET &COLNEW = &COLCLS+5\n              SET &CLS1 = &STR(&SUBSTR(1:&COLNEW,&STR(&KEYWRD)))\n              SET &CLS2 = &STR(&CL)\n              SET &COLNEXT = &COLNEW+2\n              SET &CLS3 = &STR(&SUBSTR(&COLNEXT:72,&STR(&KEYWRD)))\n              SET &CLSC = &STR(&CLS1.&CLS2.&CLS3)\n              ISREDIT LINE &ROWCLS = \"&CLSC.\"\n            END\n    END\nNOCHANG:  +\nSET &FROM=1\nSET &TO=3\nIF &S1=SAVE2 +\nTHEN DO\n        SET &FROM=2\n        SET &TO=4\n     END\n\nISREDIT SCAN = OFF\nISREDIT FIND ' EXEC ' ALL\nMOREEXEC: +\nISREDIT (ROW) = LINENUM .ZCSR\nSET &ROWEXEC=&ROW\nIF &ROWEXEC<2 THEN GOTO ENDEXEC\nIF &ROWEXEC=&KEEPEXEC THEN GOTO ENDEXEC\nISREDIT (STRING) = LINE .ZCSR\nIF '&STR(&SUBSTR(&FROM:&TO,&STR(&STRING).000))'='&STR(&REMARK)' +\nTHEN DO\n       SET &KEEPEXEC=&ROWEXEC\n       ISREDIT FIND ' EXEC ' NEXT\n       GOTO MOREEXEC\n     END\nELSE SET &SWEXEC=1\nENDEXEC: +\nIF   &SWEXEC=0 THEN SET &ROWEXEC=1\n\nSET &ROW=0\nISREDIT SCAN = OFF\nISREDIT FIND ' PROC ' ALL\nMOREPROC: +\nISREDIT (ROW) = LINENUM .ZCSR\nSET &ROWPROC=&ROW\nIF &ROWPROC<2 THEN GOTO ENDPROC\nIF &ROWPROC=&KEEPPROC THEN GOTO ENDPROC\nISREDIT (STRING) = LINE .ZCSR\nIF '&STR(&SUBSTR(&FROM:&TO,&STR(&STRING).000))'='&STR(&REMARK)' +\nTHEN DO\n       SET &KEEPPROC=&ROWPROC\n       ISREDIT FIND ' PROC ' NEXT\n       GOTO MOREPROC\n     END\nELSE SET &SWPROC=1\nENDPROC: +\nIF &SWPROC=0 THEN SET &ROWPROC=1\n\nIF (&ROWPROC<2 AND &ROWEXEC<2) THEN GOTO FINISH\nIF &ROWEXEC<2  THEN SET &ROWEXEC=&ROWPROC\nIF &ROWPROC>1 +\nTHEN  IF &ROWPROC<&ROWEXEC THEN SET &ROWEXEC=&ROWPROC\n\nPROCEED: +\nSET &F11=&STR(&F1)\nSET &F22=&STR(&F2)\nSET &F33=&STR(&F3)\nSET &F44=&STR(&F4)\nSET &A11=&STR(&A1)\nSET &B11=&STR(RL)\nIF &A1=&STR(P) +\nTHEN DO\n     SET &A11=&STR(2)\n     SET &B11=&STR(BL)\n     SET &F11=\n     SET &F22=&STR($FIRST)\n     SET &F33=\n     SET &F44=\n     END\nIF &A1=&STR(C) +\n  THEN SET &ASR11=&STR(RC)\n  ELSE SET &ASR11=&STR(S&A11)\nSET &F12=&STR(&F11..&F22)\nSET &F34=&STR(&F33&F44)\nIF &F34=  +\nTHEN +\n  SET &CARD=&STR(// EXEC CONTROLR,PARM='&ASR11,&M1,&O1,&B11,&F12')\nELSE DO\n     SET &CARD=&STR(// EXEC CONTROLR,)\n     SET &CARD1=&STR(//     PARM='&ASR11,&M1,&O1,&B11,&F12,&F33..&F44')\n  END\n\nIF &S1=SAVE2 +\nTHEN SET &CARD=&STR(0&CARD)\nIF &F34\u00ac= +\nTHEN IF &S1=SAVE2 +\n     THEN  SET &CARD1=&STR(0&CARD1)\n     ELSE SET &CARD1=&STR(&CARD1)\n\nISREDIT LINE_BEFORE &ROWEXEC = \"&CARD.\"\nIF &F34\u00ac= +\nTHEN DO\n      SET &ROWEXEC = &ROWEXEC +1\n      ISREDIT LINE_BEFORE &ROWEXEC = \"&CARD1.\"\n     END\nSET &ROWEXEC = &ROWEXEC +1\nSET &CARD2=&STR(//DAARCH  DD DSN=&SYSUID..O&O1..ARCHIVE,)\nSET &CARD3=&STR(//  DISP=(SHR,KEEP) )\nIF &S1=SAVE2 +\nTHEN DO\n       SET &CARD2=&STR(0&CARD2)\n       SET &CARD3=&STR(0&CARD3)\n     END\nISREDIT LINE_BEFORE &ROWEXEC = \"&CARD2.\"\nSET &ROWEXEC = &ROWEXEC +1\nISREDIT LINE_BEFORE &ROWEXEC = \"&CARD3.\"\n\nFINISH: +\nISREDIT END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CTTCRSS": {"ttr": 8449, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x95\\x00/\\x00\\x95\\x00/\\x17I\\x00X\\x00X\\x00\\x00\\xc3\\xe3\\xe3\\xf1\\xf2\\xf2\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1995-01-02T00:00:00", "modifydate": "1995-01-02T17:49:00", "lines": 88, "newlines": 88, "modlines": 0, "user": "CTT122H"}, "text": "PROC 0 DEBUG                  +\n       PARM()                 +\n       LOADLIB(SYS1.IOA.V410.LOAD) +\n       DARLLIB(SYSM.CTTI.V1R2M2.PARM)\nIF &PARM =DEBUG THEN SET &DEBUG=DEBUG\nIF &DEBUG=DEBUG THEN DO\n   CONTROL MAIN LIST CONLIST SYMLIST MSG\n   FREE  F(PRTDBG,SYSPRINT)\n   ALLOC F(PRTDBG) DA(*)\n   ALLOC F(SYSPRINT) DA(*)\n   END\n  ELSE DO\n   CONTROL NOMSG NOFLUSH\n   FREE  F(PRTDBG,SYSPRINT)\n   ALLOC F(PRTDBG) DUMMY\n   ALLOC F(SYSPRINT) DUMMY\n  END\nSET &CRSFLD = CTTDSN\nREDISP:+\n ISPEXEC DISPLAY PANEL(CTTPRSS) CURSOR(&CRSFLD)\n   SET &RC = &LASTCC\n   IF (&RC > 8) THEN DO\n      WRITE ********************************************************\n      WRITE ***** ERROR IN NEXT PANEL TO BE DISPLAYED. RC = &RC  ****\n      WRITE ***** TERMINATING ...                               ****\n      WRITE ********************************************************\n      EXIT\n   END DO\n IF ( &YES = NO ) THEN GOTO REDISP\n ISPEXEC VPUT +\n   (CTTVOL,CTTDSN,CTTJBNAM,CTTACCNT,CTTPGM,CTTUSRID,      +\n    CTTMEDIA,CTTLOAD,CTTRLLST,CTTJCLXD,CTTLDATE)          +\n   PROFILE\n IF &RESP = END THEN EXIT\n IF ( &CTTLOAD = Y ) THEN DO\n    FREE  F(DARULLST)\n    ALLOC F(DARULLST) DS('&DARLLIB(&CTTRLLST)') SHR\n    /*\n    /* MAKE SURE THAT &CTTRLLST MEMBER EXISTS\n    /*\n   ISPEXEC LMINIT   DATAID(DARLL) DATASET('&DARLLIB') ENQ(SHR)\n   IF (&LASTCC \u00ac= 0) THEN DO\n      ISPEXEC SETMSG MSG(CTTR000Z)\n      SET &CRSFLD = CTTRLLST\n      GOTO REDISP\n   END DO\n   ISPEXEC LMOPEN   DATAID(&DARLL) OPTION(INPUT)\n   SET &RC = &LASTCC\n   IF (&RC \u00ac= 0) THEN DO\n      ISPEXEC SETMSG MSG(CTTR000Z)\n      GOTO REDISP\n   END DO\n   ISPEXEC LMMFIND  DATAID(&DARLL) MEMBER(&CTTRLLST)\n   SET RC = &LASTCC\n   IF ( &RC = 8 ) THEN DO\n     ISPEXEC SETMSG MSG(CTTR000A)    /* MEMBER NOT FOUND\n     SET &CRSFLD = CTTRLLST\n     GOTO REDISP\n   END DO\n   IF ( &RC \u00ac= 0 ) THEN DO\n     ISPEXEC SETMSG MSG(CTTR000B)    /* ALLOCATION ERROR\n     GOTO  REDISP\n   END DO\n   ISPEXEC LMFREE DATAID(DARLL)\n END DO\n   FREE  DD(DARSS)\n   ALLOC F(DARSS) NEW TRACKS SP(1 1)\n   CALL '&LOADLIB(CTTRSS)'   '&PARM'\n   SET RC = &LASTCC\n   IF ( &RC = 4 ) THEN ISPEXEC SETMSG MSG(CTTR000E)  /* NO MATCHES   */\n   IF ( &RC = 8 ) THEN ISPEXEC SETMSG MSG(CTTR000D)  /*C-T NOT ACTIVE*/\n   IF ( &RC = 12) THEN ISPEXEC SETMSG MSG(CTTR000F)  /*BAD RLD CARDS */\n   IF ( &RC = 16) THEN ISPEXEC SETMSG MSG(CTTR000G)  /*GETMAIN ERROR */\n   IF ( &RC = 20) THEN ISPEXEC SETMSG MSG(CTTR000H)  /* CTTGTH ERROR */\n   IF ( &RC > 20) THEN ISPEXEC SETMSG MSG(CTTR000I)  /*OTHERWISE     */\n   IF ( &RC \u00ac= 0 ) THEN GOTO REDISP\n   ISPEXEC LMINIT DATAID(OUTF) DDNAME(DARSS)\n   IF ( &LASTCC \u00ac= 0 ) THEN DO\n      ISPEXEC SETMSG MSG(CTTR000C)\n      GOTO REDISP\n   END DO\n   IF ( &CTTBE = BROWSE ) THEN +\n       ISPEXEC BROWSE  DATAID(&OUTF)\n      ELSE +\n       ISPEXEC EDIT   DATAID(&OUTF)\n   ISPEXEC LMFREE DATAID(&OUTF)\nGOTO  REDISP\nEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CTTISPFA": {"ttr": 8452, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x95\\x00/\\x00\\x95\\x00/\\x17I\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xe3\\xe3\\xf1\\xf2\\xf2\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1995-01-02T00:00:00", "modifydate": "1995-01-02T17:49:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "CTT122H"}, "text": "PROC 0  APPLTYPE(I)  -\n        APPLID(CA)\n/****************************************************************\n/*                                                              *\n/*  CONTROL-M:   PRODUCTION CONTROL  SYSTEM          (ISPF)     *\n/*  CONTROL-O:   AUTOMATED CONSOLE MANAGEMENT SYSTEM (ISPF)     *\n/*  CONTROL-T:   REMOVABLE MEDIA MANAGEMENT SYSTEM   (ISPF)     *\n/*  CONTROL-B:   ONLINE BALANCING SYSTEM             ( TSO)     *\n/*                                                              *\n/****************************************************************\n%IOAONL APPLTYPE(&APPLTYPE) APPLID(&APPLID)\nEND:END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CTTISPFG": {"ttr": 8454, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x95\\x00/\\x00\\x95\\x00/\\x17I\\x00\\x0b\\x00\\x0b\\x00\\x00\\xc3\\xe3\\xe3\\xf1\\xf2\\xf2\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1995-01-02T00:00:00", "modifydate": "1995-01-02T17:49:00", "lines": 11, "newlines": 11, "modlines": 0, "user": "CTT122H"}, "text": "PROC 0  APPLTYPE(I)  -\n        APPLID(CG)\n/****************************************************************\n/*                                                              *\n/*  CONTROL-M:   PRODUCTION CONTROL  SYSTEM          (ISPF)     *\n/*  CONTROL-O:   AUTOMATED CONSOLE MANAGEMENT SYSTEM (ISPF)     *\n/*  CONTROL-T:   REMOVABLE MEDIA MANAGEMENT SYSTEM   (ISPF)     *\n/*                                                              *\n/****************************************************************\n%IOAONL APPLTYPE(&APPLTYPE) APPLID(&APPLID)\nEND:END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CTTISPFH": {"ttr": 8456, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x95\\x00/\\x00\\x95\\x00/\\x17I\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xe3\\xe3\\xf1\\xf2\\xf2\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1995-01-02T00:00:00", "modifydate": "1995-01-02T17:49:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "CTT122H"}, "text": "PROC 0  APPLTYPE(I)  -\n        APPLID(CH)\n/****************************************************************\n/*                                                              *\n/*  CONTROL-M:   PRODUCTION CONTROL  SYSTEM          (ISPF)     *\n/*  CONTROL-D:   REPORT DISTRIBUTION SYSTEM          (ISPF)     *\n/*  CONTROL-O:   AUTOMATED CONSOLE MANAGEMENT SYSTEM (ISPF)     *\n/*  CONTROL-T:   REMOVABLE MEDIA MANAGEMENT SYSTEM   (ISPF)     *\n/*                                                              *\n/****************************************************************\n%IOAONL APPLTYPE(&APPLTYPE) APPLID(&APPLID)\nEND:END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CTTISPFL": {"ttr": 8458, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x95\\x00/\\x00\\x95\\x00/\\x17I\\x00\\x0b\\x00\\x0b\\x00\\x00\\xc3\\xe3\\xe3\\xf1\\xf2\\xf2\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1995-01-02T00:00:00", "modifydate": "1995-01-02T17:49:00", "lines": 11, "newlines": 11, "modlines": 0, "user": "CTT122H"}, "text": "PROC 0  APPLTYPE(I)  -\n        APPLID(CL)\n/****************************************************************\n/*                                                              *\n/*  CONTROL-M:   PRODUCTION CONTROL  SYSTEM          (ISPF)     *\n/*  CONTROL-O:   AUTOMATED CONSOLE MANAGEMENT SYSTEM (ISPF)     *\n/*  CONTROL-T:   REMOVABLE MEDIA MANAGEMENT SYSTEM   (ISPF)     *\n/*                                                              *\n/****************************************************************\n%IOAONL APPLTYPE(&APPLTYPE) APPLID(&APPLID)\nEND:END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CTTISPFN": {"ttr": 8460, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x95\\x00/\\x00\\x95\\x00/\\x17I\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xe3\\xe3\\xf1\\xf2\\xf2\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1995-01-02T00:00:00", "modifydate": "1995-01-02T17:49:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "CTT122H"}, "text": "PROC 0  APPLTYPE(I)  -\n        APPLID(CN)\n/****************************************************************\n/*                                                              *\n/*  CONTROL-M:   PRODUCTION CONTROL  SYSTEM        (ISPF)       *\n/*  CONTROL-D:   REPORT DISTRIBUTION SYSTEM        (ISPF)       *\n/*  CONTROL-B:   BALANCING SYSTEM                  (ISPF)       *\n/*  CONTROL-T:   REMOVABLE MEDIA MANAGEMENT SYSTEM (ISPF)       *\n/*                                                              *\n/****************************************************************\n%IOAONL APPLTYPE(&APPLTYPE) APPLID(&APPLID)\nEND:END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CTTISPFP": {"ttr": 8462, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x95\\x00/\\x00\\x95\\x00/\\x17I\\x00\\x0b\\x00\\x0b\\x00\\x00\\xc3\\xe3\\xe3\\xf1\\xf2\\xf2\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1995-01-02T00:00:00", "modifydate": "1995-01-02T17:49:00", "lines": 11, "newlines": 11, "modlines": 0, "user": "CTT122H"}, "text": "PROC 0  APPLTYPE(I)  -\n        APPLID(CP)\n/****************************************************************\n/*                                                              *\n/*  CONTROL-D:   REPORT DISTRIBUTION SYSTEM          (ISPF)     *\n/*  CONTROL-T:   REMOVABLE MEDIA MANAGEMENT SYSTEM   (ISPF)     *\n/*  CONTROL-B:   ONLINE BALANCING SYSTEM             ( TSO)     *\n/*                                                              *\n/****************************************************************\n%IOAONL APPLTYPE(&APPLTYPE) APPLID(&APPLID)\nEND:END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CTTISPFQ": {"ttr": 8464, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x95\\x00/\\x00\\x95\\x00/\\x17I\\x00\\n\\x00\\n\\x00\\x00\\xc3\\xe3\\xe3\\xf1\\xf2\\xf2\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1995-01-02T00:00:00", "modifydate": "1995-01-02T17:49:00", "lines": 10, "newlines": 10, "modlines": 0, "user": "CTT122H"}, "text": "PROC 0  APPLTYPE(I)  -\n        APPLID(CQ)\n/****************************************************************\n/*                                                              *\n/*  CONTROL-T:   REMOVABLE MEDIA MANAGEMENT SYSTEM (ISPF)       *\n/*  CONTROL-M:   PRODUCTION CONTROL SYSTEM         (ISPF)       *\n/*                                                              *\n/****************************************************************\n%IOAONL APPLTYPE(&APPLTYPE) APPLID(&APPLID)\nEND:END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CTTISPFR": {"ttr": 8466, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x95\\x00/\\x00\\x95\\x00/\\x17I\\x00\\n\\x00\\n\\x00\\x00\\xc3\\xe3\\xe3\\xf1\\xf2\\xf2\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1995-01-02T00:00:00", "modifydate": "1995-01-02T17:49:00", "lines": 10, "newlines": 10, "modlines": 0, "user": "CTT122H"}, "text": "PROC 0  APPLTYPE(I)  -\n        APPLID(CR)\n/****************************************************************\n/*                                                              *\n/*  CONTROL-D:   REPORT DISTRIBUTION SYSTEM        (ISPF)       *\n/*  CONTROL-T:   REMOVABLE MEDIA MANAGEMENT SYSTEM (ISPF)       *\n/*                                                              *\n/****************************************************************\n%IOAONL APPLTYPE(&APPLTYPE) APPLID(&APPLID)\nEND:END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CTTISPFT": {"ttr": 8468, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x95\\x00/\\x00\\x95\\x00/\\x17I\\x00\\t\\x00\\t\\x00\\x00\\xc3\\xe3\\xe3\\xf1\\xf2\\xf2\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1995-01-02T00:00:00", "modifydate": "1995-01-02T17:49:00", "lines": 9, "newlines": 9, "modlines": 0, "user": "CTT122H"}, "text": "PROC 0  APPLTYPE(I)  -\n        APPLID(CT)\n/****************************************************************\n/*                                                              *\n/*  CONTROL-T:   REMOVABLE MEDIA MANAGEMENT SYSTEM (ISPF)       *\n/*                                                              *\n/****************************************************************\n%IOAONL APPLTYPE(&APPLTYPE) APPLID(&APPLID)\nEND:END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CTTISPFX": {"ttr": 8470, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x95\\x00/\\x00\\x95\\x00/\\x17I\\x00\\x0b\\x00\\x0b\\x00\\x00\\xc3\\xe3\\xe3\\xf1\\xf2\\xf2\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1995-01-02T00:00:00", "modifydate": "1995-01-02T17:49:00", "lines": 11, "newlines": 11, "modlines": 0, "user": "CTT122H"}, "text": "PROC 0  APPLTYPE(I)  -\n        APPLID(CX)\n/****************************************************************\n/*                                                              *\n/*  CONTROL-M:   PRODUCTION CONTROL  SYSTEM        (ISPF)       *\n/*  CONTROL-D:   REPORT DISTRIBUTION SYSTEM        (ISPF)       *\n/*  CONTROL-T:   REMOVABLE MEDIA MANAGEMENT SYSTEM (ISPF)       *\n/*                                                              *\n/****************************************************************\n%IOAONL APPLTYPE(&APPLTYPE) APPLID(&APPLID)\nEND:END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CTTISPFY": {"ttr": 8472, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x95\\x00/\\x00\\x95\\x00/\\x17I\\x00\\n\\x00\\n\\x00\\x00\\xc3\\xe3\\xe3\\xf1\\xf2\\xf2\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1995-01-02T00:00:00", "modifydate": "1995-01-02T17:49:00", "lines": 10, "newlines": 10, "modlines": 0, "user": "CTT122H"}, "text": "PROC 0  APPLTYPE(I)  -\n        APPLID(CY)\n/****************************************************************\n/*                                                              *\n/*  CONTROL-T:   REMOVABLE MEDIA MANAGEMENT SYSTEM   (ISPF)     *\n/*  CONTROL-B:   ONLINE BALANCING SYSTEM             ( TSO)     *\n/*                                                              *\n/****************************************************************\n%IOAONL APPLTYPE(&APPLTYPE) APPLID(&APPLID)\nEND:END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CTTISPFZ": {"ttr": 8474, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x95\\x00/\\x00\\x95\\x00/\\x17I\\x00\\r\\x00\\r\\x00\\x00\\xc3\\xe3\\xe3\\xf1\\xf2\\xf2\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1995-01-02T00:00:00", "modifydate": "1995-01-02T17:49:00", "lines": 13, "newlines": 13, "modlines": 0, "user": "CTT122H"}, "text": "PROC 0  APPLTYPE(I)  -\n        APPLID(CZ)\n/****************************************************************\n/*                                                              *\n/*  CONTROL-M:   PRODUCTION CONTROL  SYSTEM          (ISPF)     *\n/*  CONTROL-D:   REPORT DISTRIBUTION SYSTEM          (ISPF)     *\n/*  CONTROL-O:   AUTOMATED CONSOLE MANAGEMENT SYSTEM (ISPF)     *\n/*  CONTROL-T:   REMOVABLE MEDIA MANAGEMENT SYSTEM   (ISPF)     *\n/*  CONTROL-B:   ONLINE BALANCING SYSTEM             ( TSO)     *\n/*                                                              *\n/****************************************************************\n%IOAONL APPLTYPE(&APPLTYPE) APPLID(&APPLID)\nEND:END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CTTONL": {"ttr": 8476, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x95\\x00/\\x00\\x95\\x00/\\x17I\\x00&\\x00&\\x00\\x00\\xc3\\xe3\\xe3\\xf1\\xf2\\xf2\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1995-01-02T00:00:00", "modifydate": "1995-01-02T17:49:00", "lines": 38, "newlines": 38, "modlines": 0, "user": "CTT122H"}, "text": "PROC 0  ILPREFA(SYSM.IOA)    -\n        ILVERA(V410)      -\n        ILPREFT(SYSM.CTTI)    -\n        ILVERT(V1R2M2)      -\n        APPLTYPE(&APPLTYPE)   -\n        APPLID(&APPLID)       -\n/****************************************************************\n/*                                                              *\n/*                  CTTONL                                      *\n/*  MAIN IOA ONLINE CLIST.                                      *\n/*  INVOKED FROM VARIOUS APPLICATION CLISTS                     *\n/*                                                              *\n/****************************************************************\nCONTROL NOMSG NOFLUSH\nALLOC DD(PRTDBG) SYSOUT(X) HOLD  REU\nALLOC DD(CDAMSNAP) SYSOUT(X) HOLD REU\n/**** ALLOC DD(ISPPROF) DSN('&SYSUID..ISPF.ISPPROF') OLD\nCONTROL MSG\nALLOC DD(CTMPGM&APPLID)  -\n  DSN('&ILPREFA..&ILVERA..PARMCMD(PGM&APPLID&APPLTYPE)') SHR REU\nALLOC DD(DAALOCIN)       -\n  DSN('&ILPREFA..&ILVERA..PARM(ALC&APPLID)') SHR REU\nIF &APPLTYPE = S THEN -\n   DO\n   IOATBMN APPLTYPE=&APPLTYPE,APPLID=&APPLID\n   END\nELSE IF &APPLTYPE = I THEN -\n   DO\n   ATTN\n   ISPEXEC SELECT PGM(IOATBMN) NEWAPPL(CTM) PASSLIB -\n   PARM(APPLTYPE=&APPLTYPE,APPLID=&APPLID)\n   ATTN OFF\n   END\nELSE -\n   DO\n   WRITE **** INVALID APPLTYPE VALUE ===> &APPLTYPE ****\n   END\nEND:END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CTTTLMS": {"ttr": 8478, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x95\\x18_\\x00\\x95\\x18_\\x18\\x19\\x00\\t\\x00\\t\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf3@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1995-07-04T00:00:00", "modifydate": "1995-07-04T18:19:00", "lines": 9, "newlines": 9, "modlines": 0, "user": "TECH103"}, "text": "PROC 0  APPLTYPE(S)  -\n        APPLID(TI)\n/****************************************************************\n/*                                                              *\n/*  CONTROL-T:   REMOVABLE MEDIA MANAGEMENT SYSTEM (ISPF)       *\n/*                                                              *\n/****************************************************************\n%IOAONL APPLTYPE(&APPLTYPE) APPLID(&APPLID)\nEND:END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CTTXTSOA": {"ttr": 8480, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x95\\x00/\\x00\\x95\\x00/\\x17I\\x00\\r\\x00\\r\\x00\\x00\\xc3\\xe3\\xe3\\xf1\\xf2\\xf2\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1995-01-02T00:00:00", "modifydate": "1995-01-02T17:49:00", "lines": 13, "newlines": 13, "modlines": 0, "user": "CTT122H"}, "text": "PROC 0 LOADLIB(SYS1.IOA.V410.LOAD)\n\n/*******************************************************************/\n/*                                                                 */\n/* THIS CLIST CALLS THE ONLINE FACILITY UNDER TSO/ROSCOE UNDER THE */\n/* CROSS MEMORY INTERFACE.                                         */\n/*                                                                 */\n/*******************************************************************/\n\n\nCALL  '&LOADLIB(CTMCTSO)' 'TMNA'\n\nEXIT CODE(&MAXCC)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CTTXTSOG": {"ttr": 8482, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x95\\x00/\\x00\\x95\\x00/\\x17I\\x00\\r\\x00\\r\\x00\\x00\\xc3\\xe3\\xe3\\xf1\\xf2\\xf2\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1995-01-02T00:00:00", "modifydate": "1995-01-02T17:49:00", "lines": 13, "newlines": 13, "modlines": 0, "user": "CTT122H"}, "text": "PROC 0 LOADLIB(SYS1.IOA.V410.LOAD)\n\n/*******************************************************************/\n/*                                                                 */\n/* THIS CLIST CALLS THE ONLINE FACILITY UNDER TSO/ROSCOE UNDER THE */\n/* CROSS MEMORY INTERFACE.                                         */\n/*                                                                 */\n/*******************************************************************/\n\n\nCALL  '&LOADLIB(CTMCTSO)' 'TMNG'\n\nEXIT CODE(&MAXCC)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CTTXTSOH": {"ttr": 8484, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x95\\x00/\\x00\\x95\\x00/\\x17I\\x00\\r\\x00\\r\\x00\\x00\\xc3\\xe3\\xe3\\xf1\\xf2\\xf2\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1995-01-02T00:00:00", "modifydate": "1995-01-02T17:49:00", "lines": 13, "newlines": 13, "modlines": 0, "user": "CTT122H"}, "text": "PROC 0 LOADLIB(SYS1.IOA.V410.LOAD)\n\n/*******************************************************************/\n/*                                                                 */\n/* THIS CLIST CALLS THE ONLINE FACILITY UNDER TSO/ROSCOE UNDER THE */\n/* CROSS MEMORY INTERFACE.                                         */\n/*                                                                 */\n/*******************************************************************/\n\n\nCALL  '&LOADLIB(CTMCTSO)' 'TMNH'\n\nEXIT CODE(&MAXCC)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CTTXTSOL": {"ttr": 8486, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x95\\x00/\\x00\\x95\\x00/\\x17I\\x00\\r\\x00\\r\\x00\\x00\\xc3\\xe3\\xe3\\xf1\\xf2\\xf2\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1995-01-02T00:00:00", "modifydate": "1995-01-02T17:49:00", "lines": 13, "newlines": 13, "modlines": 0, "user": "CTT122H"}, "text": "PROC 0 LOADLIB(SYS1.IOA.V410.LOAD)\n\n/*******************************************************************/\n/*                                                                 */\n/* THIS CLIST CALLS THE ONLINE FACILITY UNDER TSO/ROSCOE UNDER THE */\n/* CROSS MEMORY INTERFACE.                                         */\n/*                                                                 */\n/*******************************************************************/\n\n\nCALL  '&LOADLIB(CTMCTSO)' 'TMNL'\n\nEXIT CODE(&MAXCC)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CTTXTSON": {"ttr": 8488, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x95\\x00/\\x00\\x95\\x00/\\x17I\\x00\\r\\x00\\r\\x00\\x00\\xc3\\xe3\\xe3\\xf1\\xf2\\xf2\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1995-01-02T00:00:00", "modifydate": "1995-01-02T17:49:00", "lines": 13, "newlines": 13, "modlines": 0, "user": "CTT122H"}, "text": "PROC 0 LOADLIB(SYS1.IOA.V410.LOAD)\n\n/*******************************************************************/\n/*                                                                 */\n/* THIS CLIST CALLS THE ONLINE FACILITY UNDER TSO/ROSCOE UNDER THE */\n/* CROSS MEMORY INTERFACE.                                         */\n/*                                                                 */\n/*******************************************************************/\n\n\nCALL  '&LOADLIB(CTMCTSO)' 'TMNN'\n\nEXIT CODE(&MAXCC)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CTTXTSOP": {"ttr": 8490, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x95\\x00/\\x00\\x95\\x00/\\x17I\\x00\\r\\x00\\r\\x00\\x00\\xc3\\xe3\\xe3\\xf1\\xf2\\xf2\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1995-01-02T00:00:00", "modifydate": "1995-01-02T17:49:00", "lines": 13, "newlines": 13, "modlines": 0, "user": "CTT122H"}, "text": "PROC 0 LOADLIB(SYS1.IOA.V410.LOAD)\n\n/*******************************************************************/\n/*                                                                 */\n/* THIS CLIST CALLS THE ONLINE FACILITY UNDER TSO/ROSCOE UNDER THE */\n/* CROSS MEMORY INTERFACE.                                         */\n/*                                                                 */\n/*******************************************************************/\n\n\nCALL  '&LOADLIB(CTMCTSO)' 'TMNP'\n\nEXIT CODE(&MAXCC)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CTTXTSOQ": {"ttr": 8705, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x95\\x00/\\x00\\x95\\x00/\\x17I\\x00\\r\\x00\\r\\x00\\x00\\xc3\\xe3\\xe3\\xf1\\xf2\\xf2\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1995-01-02T00:00:00", "modifydate": "1995-01-02T17:49:00", "lines": 13, "newlines": 13, "modlines": 0, "user": "CTT122H"}, "text": "PROC 0 LOADLIB(SYS1.IOA.V410.LOAD)\n\n/*******************************************************************/\n/*                                                                 */\n/* THIS CLIST CALLS THE ONLINE FACILITY UNDER TSO/ROSCOE UNDER THE */\n/* CROSS MEMORY INTERFACE.                                         */\n/*                                                                 */\n/*******************************************************************/\n\n\nCALL  '&LOADLIB(CTMCTSO)' 'TMNQ'\n\nEXIT CODE(&MAXCC)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CTTXTSOR": {"ttr": 8707, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x95\\x00/\\x00\\x95\\x00/\\x17I\\x00\\r\\x00\\r\\x00\\x00\\xc3\\xe3\\xe3\\xf1\\xf2\\xf2\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1995-01-02T00:00:00", "modifydate": "1995-01-02T17:49:00", "lines": 13, "newlines": 13, "modlines": 0, "user": "CTT122H"}, "text": "PROC 0 LOADLIB(SYS1.IOA.V410.LOAD)\n\n/*******************************************************************/\n/*                                                                 */\n/* THIS CLIST CALLS THE ONLINE FACILITY UNDER TSO/ROSCOE UNDER THE */\n/* CROSS MEMORY INTERFACE.                                         */\n/*                                                                 */\n/*******************************************************************/\n\n\nCALL  '&LOADLIB(CTMCTSO)' 'TMNR'\n\nEXIT CODE(&MAXCC)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CTTXTSOT": {"ttr": 8709, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x95\\x00/\\x00\\x95\\x00/\\x17I\\x00\\r\\x00\\r\\x00\\x00\\xc3\\xe3\\xe3\\xf1\\xf2\\xf2\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1995-01-02T00:00:00", "modifydate": "1995-01-02T17:49:00", "lines": 13, "newlines": 13, "modlines": 0, "user": "CTT122H"}, "text": "PROC 0 LOADLIB(SYS1.IOA.V410.LOAD)\n\n/*******************************************************************/\n/*                                                                 */\n/* THIS CLIST CALLS THE ONLINE FACILITY UNDER TSO/ROSCOE UNDER THE */\n/* CROSS MEMORY INTERFACE.                                         */\n/*                                                                 */\n/*******************************************************************/\n\n\nCALL  '&LOADLIB(CTMCTSO)' 'TMNT'\n\nEXIT CODE(&MAXCC)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CTTXTSOX": {"ttr": 8711, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x95\\x00/\\x00\\x95\\x00/\\x17I\\x00\\r\\x00\\r\\x00\\x00\\xc3\\xe3\\xe3\\xf1\\xf2\\xf2\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1995-01-02T00:00:00", "modifydate": "1995-01-02T17:49:00", "lines": 13, "newlines": 13, "modlines": 0, "user": "CTT122H"}, "text": "PROC 0 LOADLIB(SYS1.IOA.V410.LOAD)\n\n/*******************************************************************/\n/*                                                                 */\n/* THIS CLIST CALLS THE ONLINE FACILITY UNDER TSO/ROSCOE UNDER THE */\n/* CROSS MEMORY INTERFACE.                                         */\n/*                                                                 */\n/*******************************************************************/\n\n\nCALL  '&LOADLIB(CTMCTSO)' 'TMNX'\n\nEXIT CODE(&MAXCC)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CTTXTSOY": {"ttr": 8713, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x95\\x00/\\x00\\x95\\x00/\\x17I\\x00\\r\\x00\\r\\x00\\x00\\xc3\\xe3\\xe3\\xf1\\xf2\\xf2\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1995-01-02T00:00:00", "modifydate": "1995-01-02T17:49:00", "lines": 13, "newlines": 13, "modlines": 0, "user": "CTT122H"}, "text": "PROC 0 LOADLIB(SYS1.IOA.V410.LOAD)\n\n/*******************************************************************/\n/*                                                                 */\n/* THIS CLIST CALLS THE ONLINE FACILITY UNDER TSO/ROSCOE UNDER THE */\n/* CROSS MEMORY INTERFACE.                                         */\n/*                                                                 */\n/*******************************************************************/\n\n\nCALL  '&LOADLIB(CTMCTSO)' 'TMNY'\n\nEXIT CODE(&MAXCC)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CTTXTSOZ": {"ttr": 8715, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x95\\x00/\\x00\\x95\\x00/\\x17I\\x00\\r\\x00\\r\\x00\\x00\\xc3\\xe3\\xe3\\xf1\\xf2\\xf2\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1995-01-02T00:00:00", "modifydate": "1995-01-02T17:49:00", "lines": 13, "newlines": 13, "modlines": 0, "user": "CTT122H"}, "text": "PROC 0 LOADLIB(SYS1.IOA.V410.LOAD)\n\n/*******************************************************************/\n/*                                                                 */\n/* THIS CLIST CALLS THE ONLINE FACILITY UNDER TSO/ROSCOE UNDER THE */\n/* CROSS MEMORY INTERFACE.                                         */\n/*                                                                 */\n/*******************************************************************/\n\n\nCALL  '&LOADLIB(CTMCTSO)' 'TMNZ'\n\nEXIT CODE(&MAXCC)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DASDBULD": {"ttr": 8717, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01c\\x00\\x00\\x00\\x925/\\x00\\x94\\x07\\x0f\\x15\\x13\\x02\\x9e\\x00\\x07\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf7@@@'", "ispf": {"version": "01.99", "flags": 0, "createdate": "1992-12-17T00:00:00", "modifydate": "1994-03-11T15:13:00", "lines": 670, "newlines": 7, "modlines": 0, "user": "TECH107"}, "text": "/* REXX DASD BUILD ANALYSIS */\nTRUE = \"1\";\nCNTCP = 1\nFALSE = \"0\";\nCPKCTR = 00;\nSUMMCTR=1;\nDASD.0885 = \"3380DJ\";\nDASD.1770 = \"3380E\";\nDASD.2655 = \"3380K\";\nDASD.2226 = \"33902\";\nDASD.3339 = \"33903\";\nDASD.6678 = \"33906\";\nCDRS.3380DJ = \"100 11F 200 21F\";\nCDRS.3380E  = \"480 49F\";\nCDRS.3380K  = \"C40 C5F F00 F00\";\nCDRS.33902  = \"3C0 3FF FC0 FFF\";\nCDRS.33903  = \"EC0 EFF 1C0 1FF\";\nCDRS.33906  = \"F00 F00\"; /* F00 IS END INDICATOR */\nCLASSLIST=\"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\n/* ALPHA LIST */\nABRPOOLS=\"ACIC APPL ART CICS DB2 EMC MNT MVS PLAN \" || ,\n  \"POS PHYS QA RAMI SEQ SMSC SMS SYSDA SYSTA SYS TSO UART USER VSAM\";\n/* LIST BY IMP */\nABRPOOLSR=\"SYS CICS EMC DB2 SMS VSAM ART ACIC UART APPL MVS PLAN \" || ,\n  \"POS QA RAMI SEQ PHYS SMSC TSO USER MNT SYSDA SYSTA\";\nTEMP = \"\";\nDO I = 1 TO WORDS(CDRS.3380DJ) BY 2;\n  LLIM = X2D(WORD(CDRS.3380DJ,I));\n  HLIM = X2D(WORD(CDRS.3380DJ,I+1));\n     DO J = LLIM TO HLIM;\n        TEMP = TEMP D2X(J);\n     END;\nEND;\nCDRS.3380DJ = TEMP;\nTEMP = \"\";\nDO I = 1 TO WORDS(CDRS.3380E) BY 2;\n  LLIM = X2D(WORD(CDRS.3380E,I));\n  HLIM = X2D(WORD(CDRS.3380E,I+1));\n     DO J = LLIM TO HLIM;\n        TEMP = TEMP D2X(J);\n     END;\nEND;\nCDRS.3380E = TEMP;\nTEMP = \"\";\nDO I = 1 TO WORDS(CDRS.3380K) BY 2;\n  LLIM = X2D(WORD(CDRS.3380K,I));\n  HLIM = X2D(WORD(CDRS.3380K,I+1));\n     DO J = LLIM TO HLIM;\n        TEMP = TEMP D2X(J);\n     END;\nEND;\nCDRS.3380K = TEMP;\nTEMP = \"\";\nDO I = 1 TO WORDS(CDRS.33902) BY 2;\n  LLIM = X2D(WORD(CDRS.33902,I));\n  HLIM = X2D(WORD(CDRS.33902,I+1));\n     DO J = LLIM TO HLIM;\n        TEMP = TEMP D2X(J);\n     END;\nEND;\nCDRS.33902 = TEMP;\nTEMP = \"\";\nDO I = 1 TO WORDS(CDRS.33903) BY 2;\n  LLIM = X2D(WORD(CDRS.33903,I));\n  HLIM = X2D(WORD(CDRS.33903,I+1));\n     DO J = LLIM TO HLIM;\n        TEMP = TEMP D2X(J);\n     END;\nEND;\nCDRS.33903 = TEMP;\nTEMP = \"\";\nDO I = 1 TO WORDS(CDRS.33906) BY 2;\n  LLIM = X2D(WORD(CDRS.33906,I));\n  HLIM = X2D(WORD(CDRS.33906,I+1));\n     DO J = LLIM TO HLIM;\n        TEMP = TEMP D2X(J);\n     END;\nEND;\nCDRS.33906 = TEMP;\nINIT_REST_UNIT = WORD(CDRS.33902,1);\nCDRS.33902 = DELWORD(CDRS.33902,1,1);\n\"CALL 'SYS1.TECH.COMMON.LOADLIB(DASDSCAN)'\";\n/* \"CALL 'TECH110.USER.LOADLIB(DASDSCAN)'\"; */\nSAVERC=RC;\nIF SAVERC\u00ac=0 THEN EXIT SAVERC;\n\"EXECIO * DISKR WORK (FINIS STEM DASDV.\";\nCHANGES = TRUE;\nDO WHILE(CHANGES); /* BUBBLE SORT DESCENDING BY FRAG INDEX */\n     CHANGES = FALSE;\n     DO I = 1 TO DASDV.0-1;\n          J = I+1;\n          PARSE VAR DASDV.I . . . FRAGINDEX1 . ;\n          PARSE VAR DASDV.J . . . FRAGINDEX2 . ;\n          IF FRAGINDEX1 < FRAGINDEX2 THEN DO;\n                 TEMP = DASDV.I;\n                 DASDV.I = DASDV.J;\n                 DASDV.J = TEMP;\n                 CHANGES = TRUE;\n                 END;\n     END;\nEND;\nFLAG_CNT=1\nDO I = 1 TO DASDV.0;\n  PARSE VAR DASDV.I VOLSER CYLCOUNT FREECYL FRAGINDEX . ;\n  ABR_BACKUP_DSN = \"'FDRABR.V\"VOLSER\"'\";\n  DUMMY = LISTDSI(ABR_BACKUP_DSN); /* SEE IF DATASET EXISTS */\n  IF DUMMY\u00ac=0 THEN DO;\n       DASDV.I = \"DUMMY\"; /* IGNORE THIS VOLUME */\n       ITERATE I; /* LOOP */\n       END;\n/*** CPK SELECTION *****/\n  IF SUBSTR(VOLSER,1,3) = \"MNT\" | SUBSTR(VOLSER,1,3) =\"SYS\" THEN\n     INTERPRET VOLSER '= \"NO\"'\n  ELSE\n  IF FLAG_CNT <= CPKCTR THEN DO\n     INTERPRET VOLSER '= \"YES\"'\n     FLAG_CNT = FLAG_CNT + 1\n     END\n  ELSE\n     INTERPRET VOLSER '= \"NO\"'\n/***********************/\n  POOLCTR=WORDS(ABRPOOLS);\n  DO J=1 TO POOLCTR;\n     POOL=WORD(ABRPOOLS,J);\n     IF ABBREV(VOLSER,POOL) THEN DO;\n           IF SYMBOL('POOLLIST.POOL')=\"VAR\" THEN ,\n               POOLLIST.POOL=POOLLIST.POOL VOLSER;\n            ELSE POOLLIST.POOL=VOLSER;\n          LEAVE J;\n         END;\n  END;\nEND;\nABRPOOLS = ABRPOOLSR; /* REORG LIST FOR ORDER TO PROCESS IN */\nDO J=1 TO POOLCTR;\n     POOL=WORD(ABRPOOLS,J);\n     VOLCNT=WORDS(POOLLIST.POOL);\n     JOBC=SUBSTR(CLASSLIST,J,1);\nSUMM.SUMMCTR=\"****** POOL\" LEFT(POOL,7) \"RESTORE JOBCLASS:\" JOBC ,\n        \"VOLCNT:\" VOLCNT;\n     SUMMCTR=SUMMCTR+1;\nEND;\nJCLZ1.0 = 6; /* COUNT OF DUMP JOB STATEMENTS */\nJCLZ1.1 = \"//LOAD1 EXEC PGM=IKJEFT01,DYNAMNBR=32,PARM='%DB2TIACK'\";\nJCLZ1.2 = \"//SYSTSPRT DD SYSOUT=*\";\nJCLZ1.3 = \"//SYSPRINT DD SYSOUT=*\";\nJCLZ1.4 = \"//SYSTSIN DD DUMMY\";\nJCLZ1.5 = \"//SYSPROC DD DSN=SYSS.TECH.COMMON.EXECLIB,DISP=SHR\";\nJCLZ1.6 = \"//SYSIN DD *\";\nJCLZ1.7 =\" INSERT INTO BUILD.TABRVOLS (VOLSER,DUMP_TYPE,DUMP_STATUS)\";\nJCLZ1.8= \"    VALUES('XXXXXX','INCRVOL','ACTIVE');\";\nJCLZ1.9= \" COMMIT;\";\nJCLZ1.10 = \" DELETE FROM BUILD.TABRVOLS WHERE VOLSER='XXXXXX' AND \";\nJCLZ1.11 = \" DUMP_STATUS='PENDING' AND DUMP_TYPE='INCRVOL';\";\nJCLZ1.12= \" COMMIT;\";\nJCLZ1.13= \"/*\";\nJCLZ2.0 = 7; /* COUNT OF DUMP JOB STATEMENTS */\nJCLZ2.1 = \"// IF (RC<=4 & \u00acABEND) THEN\";\nJCLZ2.2 = \"//LOAD2 EXEC PGM=IKJEFT01,DYNAMNBR=32,PARM='%DB2TIACK'\";\nJCLZ2.3 = \"//SYSTSPRT DD SYSOUT=*\";\nJCLZ2.4 = \"//SYSPRINT DD SYSOUT=*\";\nJCLZ2.5 = \"//SYSTSIN DD DUMMY\";\nJCLZ2.6 = \"//SYSPROC DD DSN=SYSS.TECH.COMMON.EXECLIB,DISP=SHR\";\nJCLZ2.7 = \"//SYSIN DD *\";\nJCLZ2.8 = \" UPDATE BUILD.TABRVOLS SET DUMP_STATUS='COMPLETE'\";\nJCLZ2.9 = \"    WHERE VOLSER='XXXXXX' AND DUMP_TYPE='INCRVOL';\";\nJCLZ2.10= \" COMMIT;\";\nJCLZ2.11= \"/*\";\nJCLZ2.12= \"// ENDIF\";\nJCLZ3.0 = 7; /* COUNT OF DUMP JOB STATEMENTS */\nJCLZ3.1 = \"// IF (RC>4 | ABEND) THEN\";\nJCLZ3.2 = \"//LOAD3 EXEC PGM=IKJEFT01,DYNAMNBR=32,PARM='%DB2TIACK'\";\nJCLZ3.3 = \"//SYSTSPRT DD SYSOUT=*\";\nJCLZ3.4 = \"//SYSPRINT DD SYSOUT=*\";\nJCLZ3.5 = \"//SYSTSIN DD DUMMY\";\nJCLZ3.6 = \"//SYSPROC DD DSN=SYSS.TECH.COMMON.EXECLIB,DISP=SHR\";\nJCLZ3.7 = \"//SYSIN DD *\";\nJCLZ3.8 = \" UPDATE BUILD.TABRVOLS SET DUMP_STATUS='FAILURE'\";\nJCLZ3.9 = \"    WHERE VOLSER='XXXXXX' AND DUMP_TYPE='INCRVOL' AND\";\nJCLZ3.10 = \"     DUMP_STATUS='ACTIVE';\";\nJCLZ3.11= \" COMMIT;\";\nJCLZ3.12= \"/*\";\nJCLZ3.13= \"// ENDIF\";\nJCLD.0 = 63; /* COUNT OF DUMP JOB STATEMENTS */\nJCLD.1 = \"//D$XXXXXX JOB 530401053000,'SYSTEM.BACKUP',\";\nJCLD.2 = \"// NOTIFY=TECH251,CLASS=S,MSGCLASS=G\";\nJCLD.3 = \"//LOAD1 EXEC PGM=IKJEFT01,DYNAMNBR=32,PARM='%DB2TIACK'\";\nJCLD.4 = \"//SYSTSPRT DD SYSOUT=*\";\nJCLD.5 = \"//SYSPRINT DD SYSOUT=*\";\nJCLD.6 = \"//SYSTSIN DD DUMMY\";\nJCLD.7 = \"//SYSPROC DD DSN=SYSS.TECH.COMMON.EXECLIB,DISP=SHR\";\nJCLD.8 = \"//SYSIN DD *\";\nJCLD.9 = \" DELETE FROM BUILD.TABRVOLS WHERE VOLSER='XXXXXX' AND \";\nJCLD.10 = \" DUMP_STATUS='PENDING' AND DUMP_TYPE='FULLVOL';\";\nJCLD.11 = \" COMMIT;\";\nJCLD.12 = \" INSERT INTO BUILD.TABRVOLS (VOLSER,DUMP_TYPE,DUMP_STATUS)\";\nJCLD.13 = \"    VALUES('XXXXXX','FULLVOL','ACTIVE');\";\nJCLD.14 = \"//DUMPIT EXEC PGM=FDRABR,REGION=9M\";\nJCLD.15 = \"//SYSPRINT DD SYSOUT=*\";\nJCLD.16 = \"//SYSPRIN1 DD SYSOUT=*\";\nJCLD.17 = \"//DISK1 DD UNIT=XXXX,\";\nJCLD.18 = \"// DISP=SHR,\";\nJCLD.19 = \"// VOL=SER=XXXXXX\";\nJCLD.20=\"//TAPE1 DD DSN=FXXXXXX,DISP=(,KEEP),UNIT=TA80,VOL=(,,,255)\";\nJCLD.21 = \"//SYSUDUMP DD SYSOUT=X\";\nJCLD.22 = \"//SYSIN DD *\";\nJCLD.23 = \" DUMP TYPE=FDR,\";\nJCLD.24 = \"  AUTOUPD=YES,\";\nJCLD.25 = \"  BUFNO=MAX,\";\nJCLD.26 = \"  COMPRESS=ALL,\";\nJCLD.27 = \"  DATA=ALL,\";\nJCLD.28 = \"  DATEP=NONE,\";\nJCLD.29 = \"  DSNENQ=TEST,\";\nJCLD.30 = \"  ENQ=RESERVE,\";\nJCLD.31 = \"  ENQERR=NO,\";\nJCLD.32 = \"  ENQERR=PROCESS,\";\nJCLD.33 = \"  FORMAT=NEW,\";\nJCLD.34 = \"  LBPZERO=INVALID,\";\nJCLD.35 = \"  MAXERR=1,\";\nJCLD.36 = \"  PRINT=ABR,\";\nJCLD.37 = \"  RETPD=9999,\";\nJCLD.38 = \"  SMSCONSTRUCT=NO,\";\nJCLD.39 = \"  SMSMANAGE=NO\";\nJCLD.40 = \"/*\";\nJCLD.41 = \"// IF (RC<=4 & \u00acABEND) THEN\";\nJCLD.42 = \"//LOAD2 EXEC PGM=IKJEFT01,DYNAMNBR=32,PARM='%DB2TIACK'\";\nJCLD.43 = \"//SYSTSPRT DD SYSOUT=*\";\nJCLD.44 = \"//SYSPRINT DD SYSOUT=*\";\nJCLD.45 = \"//SYSTSIN DD DUMMY\";\nJCLD.46 = \"//SYSPROC DD DSN=SYSS.TECH.COMMON.EXECLIB,DISP=SHR\";\nJCLD.47 = \"//SYSIN DD *\";\nJCLD.48 = \" UPDATE BUILD.TABRVOLS SET DUMP_STATUS='COMPLETE'\";\nJCLD.49 = \"    WHERE VOLSER='XXXXXX' AND DUMP_TYPE='FULLVOL';\";\nJCLD.50 = \"/*\";\nJCLD.51 = \"// ENDIF\";\nJCLD.52 = \"// IF (RC>4 | ABEND) THEN\";\nJCLD.53 = \"//LOAD3 EXEC PGM=IKJEFT01,DYNAMNBR=32,PARM='%DB2TIACK'\";\nJCLD.54 = \"//SYSTSPRT DD SYSOUT=*\";\nJCLD.55 = \"//SYSPRINT DD SYSOUT=*\";\nJCLD.56 = \"//SYSTSIN DD DUMMY\";\nJCLD.57 = \"//SYSPROC DD DSN=SYSS.TECH.COMMON.EXECLIB,DISP=SHR\";\nJCLD.58 = \"//SYSIN DD *\";\nJCLD.59 = \" UPDATE BUILD.TABRVOLS SET DUMP_STATUS='FAILURE'\";\nJCLD.60 = \"    WHERE VOLSER='XXXXXX' AND DUMP_TYPE='FULLVOL';\";\nJCLD.61 = \"/*\";\nJCLD.62 = \"// ENDIF\";\nJCLD.63 = \"//\";\nJCLX.0 = 30; /* COUNT OF INCR JOB STATEMENTS */\nJCLX.1 = \"//I$XXXX JOB 530401053000,'SYSTEM.BACKUP',\";\nJCLX.2 = \"// NOTIFY=TECH251,\";\nJCLX.3 = \"// CLASS=S,MSGCLASS=G\";\nJCLX.4 = \"//DUMPIT EXEC PGM=FDRABR,REGION=9M\";\nJCLX.5 = \"//SYSPRIN1 DD SYSOUT=*\";\nJCLX.6 = \"//SYSPRIN2 DD SYSOUT=*\";\nJCLX.7 = \"//SYSPRIN3 DD SYSOUT=*\";\nJCLX.8=\"//TAPE1 DD DSN=I1XXXX,DISP=(,KEEP),UNIT=TA80,VOL=(,,,255)\";\nJCLX.9=\"//TAPE2 DD DSN=I2XXXX,DISP=(,KEEP),UNIT=TA80,VOL=(,,,255)\";\nJCLX.10=\"//TAPE3 DD DSN=I3XXXX,DISP=(,KEEP),UNIT=TA80,VOL=(,,,255)\";\nJCLX.11= \"//SYSPRINT DD SYSOUT=*\";\nJCLX.12 = \"//SYSUDUMP DD SYSOUT=X\";\nJCLX.13 = \"//SYSIN DD *\";\nJCLX.14 = \" DUMP TYPE=ABR,\";\nJCLX.15 = \"  AUTOUPD=YES,\";\nJCLX.16 = \"  BUFNO=MAX,\";\nJCLX.17 = \"  COMPRESS=ALL,\";\nJCLX.18 = \"  DATA=USED,\";\nJCLX.19 = \"  DATEP=NONE,\";\nJCLX.20 = \"  DSNENQ=TEST,\";\nJCLX.21 = \"  ENQ=RESERVE,\";\nJCLX.22 = \"  ENQERR=NO,\";\nJCLX.23 = \"  ENQERR=PROCESS,\";\nJCLX.24 = \"  FORMAT=NEW,\";\nJCLX.25 = \"  LBPZERO=INVALID,\";\nJCLX.26 = \"  MAXERR=1,\";\nJCLX.27 = \"  PRINT=ABR,\";\nJCLX.28 = \"  RETPD=9999,\";\nJCLX.29 = \"  SMSCONSTRUCT=NO,\";\nJCLX.30 = \"  SMSMANAGE=NO\";\nJCLR.0 = 47; /* COUNT OF RESTORE JOB STATEMENTS */\nJCLR.1 = \"//R$XXXXXX JOB 530401053000,'TECH SUPPRT',\";\nJCLR.2 = \"// CLASS=?,MSGCLASS=X,MSGLEVEL=(1,1),REGION=6M\";\nJCLR.3 = \"//JOBLIB DD DSN=IMPORT.LINKLIB1,DISP=SHR\";\nJCLR.4 = \"//ACTIVE EXEC PGM=IKJEFT01,REGION=6M,\";\nJCLR.5= \"// PARM='ALTER ''FDRABR.COMDISCO.WEEKREST.VXXXXXX'' OWNER(I)'\"\nJCLR.6 = \"//SYSTSPRT DD SYSOUT=*\";\nJCLR.7 = \"//SYSTSIN DD DUMMY\";\nJCLR.8 = \"//*\";\nJCLR.9 = \"//*\";\nJCLR.10 = \"//*\";\nJCLR.11 = \"//*\";\nJCLR.12 = \"//*\";\nJCLR.13 = \"//RESTIT EXEC PGM=FDRABR,REGION=6M\";\nJCLR.14 = \"//SYSPRINT DD SYSOUT=*\";\nJCLR.15 = \"//ABRWORK  DD UNIT=SYSALLDA,SPACE=(CYL,(2,1))\";\nJCLR.16 = \"//DISK1 DD UNIT=XXXX,VOL=SER=XXXXXX,DISP=OLD\";\nJCLR.17 = \"//SYSIN DD *\";\nJCLR.18 = \" RESTORE TYPE=FDR,\";\nJCLR.19 = \"   CONFMESS=NO,\";\nJCLR.20 = \"   COPY=1,\";\nJCLR.21 = \"  CPYVOLID=YES,\";\nJCLR.22 = \"  DYNTAPE,\";\nJCLR.23 = \"  MAXERR=1,\";\nJCLR.24 = \"  SMSPROT=NONE,\";\nJCLR.25 = \"  VOLRESET=NO\";\nJCLR.26 = \" SELECT  VOL=XXXXXX,GEN=CURRENT\";\nJCLR.27 = \"/*\";\nJCLR.28 = \"//IXITIT EXEC PGM=ICKDSF,REGION=6M\";\nJCLR.29 = \"//SYSPRINT DD SYSOUT=*\";\nJCLR.30 = \"//DISK1 DD UNIT=XXXX,VOL=SER=XXXXXX,DISP=OLD\";\nJCLR.31 = \"//SYSIN DD *\";\nJCLR.32=\" BUILDIX DDNAME(DISK1) IXVTOC\";\nJCLR.33 = \"//COMPLETE EXEC PGM=IKJEFT01,COND=(0,NE,RESTIT),\";\nJCLR.34=\"// PARM='ALTER ''FDRABR.COMDISCO.WEEKREST.VXXXXXX'' OWNER(C)'\"\nJCLR.35 = \"//SYSTSPRT DD SYSOUT=*\";\nJCLR.36 = \"//SYSTSIN DD DUMMY\";\nJCLR.37 = \"//*\";\nJCLR.38 = \"//*\";\nJCLR.39 = \"//*\";\nJCLR.40 = \"//*\";\nJCLR.41 = \"//*\";\nJCLR.42 = \"//*\";\nJCLR.43 = \"//FAILURE EXEC PGM=IKJEFT01,COND=((0,GE,RESTIT),EVEN),\";\nJCLR.44=\"// PARM='ALTER ''FDRABR.COMDISCO.WEEKREST.VXXXXXX'' OWNER(F)'\"\nJCLR.45 = \"//SYSTSPRT DD SYSOUT=*\";\nJCLR.46 = \"//SYSTSIN DD DUMMY\";\nJCLR.47 = \"//\";\nJCLI.0 = 8; /* COUNT OF INIT JOB STATEMENTS */\nJCLI.1 = \"//I$XXXXXX JOB 530401053000,'TECH SUPPRT',NOTIFY=$CDRS1,\";\nJCLI.2 = \"// CLASS=A,MSGCLASS=X,MSGLEVEL=(1,1)\";\nJCLI.3 = \"//INITIT EXEC PGM=ICKDSF,REGION=6M\";\nJCLI.4 = \"//SYSPRINT DD SYSOUT=*\";\nJCLI.5 = \"//SYSIN DD *\";\nJCLI.6=\" INIT UNIT(XXX) NVFY NCHK INDEX(1,0,15) VTOC(0,1,14) -\";\nJCLI.7 = \"   NOMAP PRG NVAL VOLID(XXXXXX)\";\nJCLI.8 = \"//\";\nJCLC.0 = 14; /* COMPAKTOR */\nJCLC.1 = \"/*\"\nJCLC.2 = \"// IF (DUMPIT.RC<=4 & \u00acABEND) THEN\"\nJCLC.3 = \"//CPKIT  EXEC PGM=FDRCPK,REGION=9M\"\nJCLC.4 = \"//SYSPRINT DD SYSOUT=*\"\nJCLC.5 = \"//SYSMAP   DD SYSOUT=*\"\nJCLC.6 = \"//SYSSUMM  DD SYSOUT=*\"\nJCLC.7 = \"//SYSUDUMP DD SYSOUT=X\"\nJCLC.8 = \"//SYSIN DD *\"\nJCLC.9 = \" CPK TYPE=FASTCPK,VOL=(XXXXXX),ACTMESS=NO,CONFMESS=NO,\"\nJCLC.10= \" HI=NO,MAPS=SUMMARY,NOSECOND=NORLSE,ENQ=RESERVE,DSNENQ=USE,\"\nJCLC.11 =\" O=MAXFREE,PSRLSE=ALL,UNABLE=IGNORE,\"\nJCLC.12 =\" T=KEEP,V=NOCHANGE\"\nJCLC.13 =\"/*\"\nJCLC.14 =\"// ENDIF\"\nHEADTAIL = TRUE;\nSAY \"\";\nSAY \"****** INITIAL RESTORE 3390 UNIT:\" ,\n     INIT_REST_UNIT;\nSAY \"\";\nSUMM.SUMMCTR = \"****** INITIAL RESTORE 3390 UNIT:\" ,\n     INIT_REST_UNIT;\nSUMMCTR=SUMMCTR+1;\n/* LOOP */\nPOOLCTR=WORDS(ABRPOOLS);\nDO ZZ=1 TO POOLCTR;\nJOBC = SUBSTR(CLASSLIST,ZZ,1);\nPOOL=WORD(ABRPOOLS,ZZ);\nPOOLMEM=STRIP(SUBSTR(\"POOL\"POOL,1,8));\nDROP DUMP.;\nDROP INCR.;\nDROP REST.;\nDROP INIT.;\nDUMPCTR=1;\nINCRCTR=1;\nRESTCTR=1;\nINITCTR=1;\n\"FREE F(INIT)\";\n\"FREE F(DUMP)\";\n\"FREE F(INCR)\";\n\"FREE F(REST)\";\n\"ALLOC F(INIT) DA('SYSS.COMDISCO.INITJOBS(\"POOLMEM\")') SHR\";\nIF RC\u00ac=0 THEN EXIT 99;\nIF POOLMEM \u00ac=\"POOLSYSD\" & POOLMEM \u00ac=\"POOLSYST\" THEN DO;\n\"ALLOC F(DUMP) DA('SYSS.COMDISCO.DUMPJOBS(\"POOLMEM\")') SHR\";\nIF RC\u00ac=0 THEN EXIT 99;\nEND;\nIF POOLMEM \u00ac=\"POOLSYSD\" & POOLMEM \u00ac=\"POOLSYST\" THEN DO;\n\"ALLOC F(INCR) DA('SYSS.COMDISCO.INCRJOBS(\"POOLMEM\")') SHR\";\nIF RC\u00ac=0 THEN EXIT 99;\nEND;\nIF POOLMEM \u00ac=\"POOLSYSD\" & POOLMEM \u00ac=\"POOLSYST\" THEN DO;\n\"ALLOC F(REST) DA('SYSS.COMDISCO.RESTJOBS(\"POOLMEM\")') SHR\";\nIF RC\u00ac=0 THEN EXIT 99;\nEND;\nT1=OVERLAY(POOL,JCLX.1,POS('XXXX',JCLX.1));\nDO J = 1 TO 3;\n      IF J=1 THEN INCR.INCRCTR=T1;\n      ELSE INCR.INCRCTR=JCLX.J;\n      INCRCTR=INCRCTR+1;\nEND;\nDO J = 1 TO JCLZ1.0;\n      INCR.INCRCTR=JCLZ1.J;\n      INCRCTR=INCRCTR+1;\nEND;\nXCTR=WORDS(POOLLIST.POOL);\nTRUEVOLC=0;\nDO I = 1 TO XCTR;\n  XVOL=WORD(POOLLIST.POOL,I);\n  TEMP_PACK1 = SUBSTR(XVOL,1,5);\n  TEMP_PACK2 = SUBSTR(XVOL,1,3);\n  IF TEMP_PACK1=\"SYSDA\" | TEMP_PACK1=\"SYSTA\" | TEMP_PACK2=\"DRV\" ,\n     | TEMP_PACK2=\"TEM\" | TEMP_PACK2=\"LAN\" THEN ITERATE;\n  IF XVOL=\"SYS015\" | XVOL=\"SYS007\" | XVOL=\"SYS008\" | XVOL=\"SYS011\" | ,\n     XVOL=\"SYS012\" | XVOL=\"SYS013\" | XVOL=\"SYS014\" THEN ITERATE;\n  INCR.INCRCTR=JCLZ1.7;\n  INCRCTR=INCRCTR+1;\n  INCR.INCRCTR=OVERLAY(XVOL,JCLZ1.8,POS('XXXXXX',JCLZ1.8));\n  INCRCTR=INCRCTR+1;\n  INCR.INCRCTR=JCLZ1.9;\n  INCRCTR=INCRCTR+1;\n  INCR.INCRCTR=OVERLAY(XVOL,JCLZ1.10,POS('XXXXXX',JCLZ1.10));\n  INCRCTR=INCRCTR+1;\n  INCR.INCRCTR=JCLZ1.11;\n  INCRCTR=INCRCTR+1;\n  INCR.INCRCTR=JCLZ1.12;\n  INCRCTR=INCRCTR+1;\n  TRUEVOLC=TRUEVOLC+1;\nEND;\nINCR.INCRCTR=JCLZ1.13;\nINCRCTR=INCRCTR+1;\nT2=OVERLAY(POOL,JCLX.8,POS('XXXX',JCLX.8));\nT3=OVERLAY(POOL,JCLX.9,POS('XXXX',JCLX.9));\nT4=OVERLAY(POOL,JCLX.10,POS('XXXX',JCLX.10));\nDO J = 4 TO JCLX.0;\n      IF J=8 THEN INCR.INCRCTR=T2;\n      ELSE IF J=9 THEN INCR.INCRCTR=T3;\n      ELSE IF J=10 THEN INCR.INCRCTR=T4;\n      ELSE INCR.INCRCTR=JCLX.J;\n      /* TAPE CTR BY VOL CNT LOGIC */\n/*    IF TRUEVOLC>=9 & J=17 THEN ITERATE J;   */\n      IF TRUEVOLC>=9 THEN NOP;\n      ELSE IF TRUEVOLC>=4 & ,\n          (J=7 | J=10) THEN ITERATE J;\n      ELSE IF TRUEVOLC<4 & ,\n          (J=7 | J=10 | J=6 | J=9) THEN ITERATE J;\n      INCRCTR=INCRCTR+1;\n      IF TRUEVOLC>=9 & J=7 THEN DO;\n         INCR.INCRCTR=\"//SYSPRIN4 DD SYSOUT=*\";\n         INCRCTR=INCRCTR+1;\n/*       INCR.INCRCTR=\"//SYSPRIN5 DD SYSOUT=*\";\n         INCRCTR=INCRCTR+1;\n         INCR.INCRCTR=\"//SYSPRIN6 DD SYSOUT=*\";\n         INCRCTR=INCRCTR+1;    */\n      END;\n      IF TRUEVOLC>=9 & J=10 THEN DO;\n      POOLX = LEFT(POOL,4,\"X\"); /* FILL OUT */\nINCR.INCRCTR= ,\n \"//TAPE4 DD DSN=I4\"POOLX\",DISP=(,KEEP),UNIT=TA80,VOL=(,,,255)\"\n         INCRCTR=INCRCTR+1;\n/* INCR.INCRCTR= ,\n \"//TAPE5 DD DSN=I5\"POOLX\",DISP=(,KEEP),UNIT=TA80,VOL=(,,,255)\"\n         INCRCTR=INCRCTR+1;\nINCR.INCRCTR= ,\n \"//TAPE6 DD DSN=I6\"POOLX\",DISP=(,KEEP),UNIT=TA80,VOL=(,,,255)\"\n         INCRCTR=INCRCTR+1;     */\n      END;\nEND;\nXCTR=WORDS(POOLLIST.POOL);\nDO I = 1 TO XCTR;\n  XVOL=WORD(POOLLIST.POOL,I);\n  TEMP_PACK1 = SUBSTR(XVOL,1,5);\n  TEMP_PACK2 = SUBSTR(XVOL,1,3);\n  IF TEMP_PACK1=\"SYSDA\" | TEMP_PACK1=\"SYSTA\" | TEMP_PACK2=\"DRV\" ,\n     | TEMP_PACK2=\"TEM\" | TEMP_PACK2=\"LAN\" THEN ITERATE;\n  /* SKIP SOME INCR */\n  IF XVOL=\"SYS015\" | XVOL=\"SYS007\" | XVOL=\"SYS008\" | XVOL=\"SYS011\" | ,\n     XVOL=\"SYS012\" | XVOL=\"SYS013\" | XVOL=\"SYS014\" THEN ITERATE;\n  INCR.INCRCTR=\" MOUNT VOL=\"XVOL;\n  INCRCTR=INCRCTR+1;\nEND;\nDO J = 1 TO JCLZ2.0;\n      INCR.INCRCTR=JCLZ2.J;\n      INCRCTR=INCRCTR+1;\nEND;\nXCTR=WORDS(POOLLIST.POOL);\nDO I = 1 TO XCTR;\n  XVOL=WORD(POOLLIST.POOL,I);\n  TEMP_PACK1 = SUBSTR(XVOL,1,5);\n  TEMP_PACK2 = SUBSTR(XVOL,1,3);\n  IF TEMP_PACK1=\"SYSDA\" | TEMP_PACK1=\"SYSTA\" | TEMP_PACK2=\"DRV\" ,\n     | TEMP_PACK2=\"TEM\" | TEMP_PACK2=\"LAN\" THEN ITERATE;\n  IF XVOL=\"SYS015\" | XVOL=\"SYS007\" | XVOL=\"SYS008\" | XVOL=\"SYS011\" | ,\n     XVOL=\"SYS012\" | XVOL=\"SYS013\" | XVOL=\"SYS014\" THEN ITERATE;\n  INCR.INCRCTR=JCLZ2.8;\n  INCRCTR=INCRCTR+1;\n  INCR.INCRCTR=OVERLAY(XVOL,JCLZ2.9,POS('XXXXXX',JCLZ2.9));\n  INCRCTR=INCRCTR+1;\n  INCR.INCRCTR=JCLZ2.10;\n  INCRCTR=INCRCTR+1;\nEND;\nINCR.INCRCTR=JCLZ2.11;\nINCRCTR=INCRCTR+1;\nINCR.INCRCTR=JCLZ2.12;\nINCRCTR=INCRCTR+1;\nDO J = 1 TO JCLZ3.0;\n      INCR.INCRCTR=JCLZ3.J;\n      INCRCTR=INCRCTR+1;\nEND;\nXCTR=WORDS(POOLLIST.POOL);\nDO I = 1 TO XCTR;\n  XVOL=WORD(POOLLIST.POOL,I);\n  TEMP_PACK1 = SUBSTR(XVOL,1,5);\n  TEMP_PACK2 = SUBSTR(XVOL,1,3);\n  IF TEMP_PACK1=\"SYSDA\" | TEMP_PACK1=\"SYSTA\" | TEMP_PACK2=\"DRV\" ,\n     | TEMP_PACK2=\"TEM\" | TEMP_PACK2=\"LAN\" THEN ITERATE;\n  IF XVOL=\"SYS015\" | XVOL=\"SYS007\" | XVOL=\"SYS008\" | XVOL=\"SYS011\" | ,\n     XVOL=\"SYS012\" | XVOL=\"SYS013\" | XVOL=\"SYS014\" THEN ITERATE;\n  INCR.INCRCTR=JCLZ3.8;\n  INCRCTR=INCRCTR+1;\n  INCR.INCRCTR=OVERLAY(XVOL,JCLZ3.9,POS('XXXXXX',JCLZ3.9));\n  INCRCTR=INCRCTR+1;\n  INCR.INCRCTR=JCLZ3.10;\n  INCRCTR=INCRCTR+1;\n  INCR.INCRCTR=JCLZ3.11;\n  INCRCTR=INCRCTR+1;\nEND;\nINCR.INCRCTR=JCLZ3.12;\nINCRCTR=INCRCTR+1;\nINCR.INCRCTR=JCLZ3.13;\nINCRCTR=INCRCTR+1;\nINCR.INCRCTR=\"//\";\nINCRCTR=INCRCTR+1;\n DO I = 1 TO DASDV.0;\n  CPK=FALSE;\n  PARSE VAR DASDV.I VOLSER CYLCOUNT FREECYL FRAGINDEX . ;\n  IF VOLSER=\"DUMMY\" THEN ITERATE;\n  IF WORDPOS(VOLSER,POOLLIST.POOL)=0 THEN ITERATE;/*DIFFERENT POOL*/\n  DEVTYPE = DASD.CYLCOUNT;\n  TRUE_DEVTYPE = DASD.CYLCOUNT;\n  IF HEADTAIL THEN DO;\n         HEADTAIL = FALSE; /* ROTATE CUU SELECTION */\n         UNIT = WORD(CDRS.DEVTYPE,1);\n         CDRS.DEVTYPE = DELWORD(CDRS.DEVTYPE,1,1);\n         END;\n  ELSE DO;\n         HEADTAIL = TRUE;  /* ROTATE CUU SELECTION */\n         IF WORDS(CDRS.DEVTYPE)=0 THEN ,\n              UNIT=\"\";\n         ELSE DO;\n           UNIT = WORD(CDRS.DEVTYPE,WORDS(CDRS.DEVTYPE));\n           IF UNIT\u00ac=\"F00\" THEN ,\n           CDRS.DEVTYPE = DELWORD(CDRS.DEVTYPE,WORDS(CDRS.DEVTYPE),1);\n           END;\n         END;\n  TARGET_TYPE=DEVTYPE;\n  IF UNIT=\"\" THEN DO; /* COMDISCO HAS NO MORE */\n       SELECT;\n         WHEN (DEVTYPE=\"3380DJ\") THEN TARGET_TYPE=\"3380E\";\n         WHEN (DEVTYPE=\"3380E\") THEN TARGET_TYPE=\"3380K\";\n         WHEN (DEVTYPE=\"3380K\") THEN EXIT 16; /* EMERGENCY */\n         WHEN (DEVTYPE=\"33902\") THEN TARGET_TYPE=\"33903\";\n         WHEN (DEVTYPE=\"33903\") THEN TARGET_TYPE=\"33906\";\n         WHEN (DEVTYPE=\"33906\") THEN EXIT 20; /* EMERGENCY */\n         OTHERWISE EXIT 24;\n       END;\n       IF TARGET_TYPE=\"3380E\" & WORDS(CDRS.3380E)=0 THEN ,\n            TARGET_TYPE=\"3380K\";\n       IF WORDS(CDRS.TARGET_TYPE)=0 THEN EXIT 28;\n       UNIT = WORD(CDRS.TARGET_TYPE,1);\n       IF UNIT\u00ac=\"F00\" THEN ,\n       CDRS.TARGET_TYPE = DELWORD(CDRS.TARGET_TYPE,1,1);\n       END;\n  DEVTYPE = SUBSTR(DEVTYPE,1,4);\n  TEMP_PACK1 = SUBSTR(VOLSER,1,5);\n  TEMP_PACK2 = SUBSTR(VOLSER,1,3);\n  IF TEMP_PACK1\u00ac=\"SYSDA\" & TEMP_PACK1\u00ac=\"SYSTA\" & TEMP_PACK2\u00ac=\"DRV\" ,\n     & TEMP_PACK2\u00ac=\"TEM\" & TEMP_PACK2\u00ac=\"LAN\" ,\n       THEN DO;\n  T1=OVERLAY(DEVTYPE,JCLD.17,POS('XXXX',JCLD.17));\n  T2=OVERLAY(VOLSER,JCLD.19,POS('XXXXXX',JCLD.19));\n  T3=OVERLAY(VOLSER,JCLD.1,POS('XXXXXX',JCLD.1));\n  T4=OVERLAY(VOLSER,JCLD.20,POS('XXXXXX',JCLD.20));\n  T5=OVERLAY(VOLSER,JCLD.9,POS('XXXXXX',JCLD.9));\n  T7=OVERLAY(VOLSER,JCLD.13,POS('XXXXXX',JCLD.13));\n  T8=OVERLAY(VOLSER,JCLD.49,POS('XXXXXX',JCLD.49));\n  T9=OVERLAY(VOLSER,JCLD.60,POS('XXXXXX',JCLD.60));\n  T10=OVERLAY(VOLSER,JCLC.9,POS('XXXXXX',JCLC.9));\n  CDSR= \"'FDRABR.COMDISCO.WEEKREST.V\"VOLSER\"'\";\n     \"ALTER\" CDSR \"OWNER(N)\";\n  IF RC > 0 THEN ,\n    \"DEFINE NVSAM (NAME(\"CDSR\") DEVT(0000) VOL('******') OWNER(N))\";\n  DO J = 1 TO JCLD.0;\n      IF J=17 THEN DUMP.DUMPCTR=T1;\n      ELSE IF J=19 THEN DUMP.DUMPCTR=T2;\n      ELSE IF J=1 THEN DUMP.DUMPCTR=T3;\n      ELSE IF J=20 THEN DUMP.DUMPCTR=T4;\n      ELSE IF J=9 THEN DUMP.DUMPCTR=T5;\n      ELSE IF J=13 THEN DUMP.DUMPCTR=T7;\n      ELSE IF J=49 THEN DUMP.DUMPCTR=T8;\n      ELSE IF J=60 THEN DUMP.DUMPCTR=T9;\n      ELSE IF J=30 & VOLSER=\"SYS015\" THEN ,\n         DUMP.DUMPCTR=\"  ENQ=OFF,\";\n      ELSE DUMP.DUMPCTR=JCLD.J;\n      FLAGIT = \"NO\"\n   /* CHANGE  */\n      INTERPRET 'IF 'VOLSER '=\"YES\" THEN FLAGIT = \"YES\"'\n      IF J=23 & FLAGIT=\"YES\" THEN CPK=TRUE;\n      ELSE IF J=23 THEN CPK=FALSE;\n      ELSE NOP;\n   /* CHANGE  */\n      IF J=40 & (CPK) THEN ITERATE J ;\n      ELSE NOP;\n      DUMPCTR=DUMPCTR+1;\n      IF (J=39) & (CPK) THEN DO;\n           DO Z=1 TO JCLC.0;\n                DUMP.DUMPCTR=JCLC.Z;\n    /* CHANGE */\n                IF Z=9 THEN DUMP.DUMPCTR= T10;\n                DUMPCTR=DUMPCTR+1;\n           END;\n         END;\n  END;\n  T1=OVERLAY(DEVTYPE,JCLR.16,POS('XXXX',JCLR.16));\n  T1=OVERLAY(VOLSER,T1,POS('XXXXXX',T1));\n  T2=OVERLAY(VOLSER,JCLR.26,POS('XXXXXX',JCLR.26));\n  T3=OVERLAY(VOLSER,JCLR.1,POS('XXXXXX',JCLR.1));\n  T4=OVERLAY(VOLSER,JCLR.5,POS('XXXXXX',JCLR.5));\n  T5=OVERLAY(VOLSER,JCLR.34,POS('XXXXXX',JCLR.34));\n  T6=OVERLAY(VOLSER,JCLR.44,POS('XXXXXX',JCLR.44));\n  T7=OVERLAY(JOBC,JCLR.2,POS('?',JCLR.2));\n  DO J = 1 TO JCLR.0;\n      IF J=16 THEN REST.RESTCTR=T1;\n      ELSE IF J=26 THEN REST.RESTCTR=T2;\n      ELSE IF J=30 THEN REST.RESTCTR=T1;\n      ELSE IF J=34 THEN REST.RESTCTR=T5;\n      ELSE IF J=44 THEN REST.RESTCTR=T6;\n      ELSE IF J=5 THEN REST.RESTCTR=T4;\n      ELSE IF J=1 THEN REST.RESTCTR=T3;\n      ELSE IF J=2 THEN REST.RESTCTR=T7;\n      ELSE REST.RESTCTR=JCLR.J;\n      RESTCTR=RESTCTR+1;\n  END;\n  END;\n  T1=OVERLAY(UNIT,JCLI.6,POS('XXX',JCLI.6));\n  T2=OVERLAY(VOLSER,JCLI.7,POS('XXXXXX',JCLI.7));\n  T3=OVERLAY(VOLSER,JCLI.1,POS('XXXXXX',JCLI.1));\n IF UNIT\u00ac=\"F00\" THEN DO;\n  DO J = 1 TO JCLI.0;\n      IF J=6 THEN INIT.INITCTR=T1;\n      ELSE IF J=7 THEN INIT.INITCTR=T2;\n      ELSE IF J=1 THEN INIT.INITCTR=T3;\n      ELSE INIT.INITCTR=JCLI.J;\n      INITCTR=INITCTR+1;\n  END;\n END;\n IF UNIT\u00ac=\"F00\" THEN ,\n  SUMM.SUMMCTR = VOLSER \"TYPE\" LEFT(TRUE_DEVTYPE,6) \"MAPPED TO\",\n     \"CDRS UNIT\" UNIT \"TYPE\" TARGET_TYPE;\n ELSE ,\nSUMM.SUMMCTR=\"****** VOLUME\" VOLSER \"NOT INITIALIZED AND/OR RESTORED\";\n  IF VOLSER=\"SYS006\" THEN ,\n       SUMM.SUMMCTR=SUMM.SUMMCTR \"IPL LOADUNIT\" UNIT;\n  IF VOLSER=\"SYS001\" | VOLSER=\"SYS002\" THEN ,\n       SUMM.SUMMCTR=SUMM.SUMMCTR \"LOADPARM\" RIGHT(UNIT,4,\"0\")\"CDM\";\n  SUMMCTR=SUMMCTR+1;\n END I;\nIF POOLMEM \u00ac=\"POOLSYSD\" & POOLMEM \u00ac=\"POOLSYST\" THEN DO;\n \"EXECIO * DISKW DUMP (FINIS STEM DUMP.\";\n \"EXECIO * DISKW INCR (FINIS STEM INCR.\";\n \"EXECIO * DISKW REST (FINIS STEM REST.\";\nEND;\n \"EXECIO * DISKW INIT (FINIS STEM INIT.\";\nEND ZZ;\n\"EXECIO * DISKW SUMM (FINIS STEM SUMM.\";\nEXIT 0;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DASDBUL3": {"ttr": 8966, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0b\\x00\\x00\\x00\\x94\\x13\\x7f\\x00\\x94\\x19o\\x17\\x05\\x02N\\x02H\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf7@@@'", "ispf": {"version": "01.11", "flags": 0, "createdate": "1994-05-17T00:00:00", "modifydate": "1994-07-15T17:05:00", "lines": 590, "newlines": 584, "modlines": 0, "user": "TECH107"}, "text": "/* REXX DASD BUILD ANALYSIS */\nTRUE = \"1\";\nCNTCP = 1\nFALSE = \"0\";\nCPKCTR = 100;\nSUMMCTR=1;\nDASD.0885 = \"3380DJ\";\nDASD.1770 = \"3380E\";\nDASD.2655 = \"3380K\";\nDASD.2226 = \"33902\";\nDASD.3339 = \"33903\";\nDASD.6678 = \"33906\";\nCDRS.3380DJ = \"100 11F 200 21F\";\nCDRS.3380E  = \"480 49F\";\nCDRS.3380K  = \"C40 C5F F00 F00\";\nCDRS.33902  = \"3C0 3FF FC0 FFF\";\nCDRS.33903  = \"EC0 EFF 1C0 1FF\";\nCDRS.33906  = \"F00 F00\"; /* F00 IS END INDICATOR */\nCLASSLIST=\"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\n/* ALPHA LIST */\nABRPOOLS=\"ACIC APPL ART CICS DB2 EMC EMR MNT MVS PLAN \" || ,\n  \"POS PHYS QA RAMI SEQ SMSC SMS SYSDA SYSTA SYS TSO UART USER VSAM\";\n/* LIST BY IMP */\nABRPOOLSR=\"SYS CICS EMC DB2 SMS VSAM ART ACIC UART APPL EMR MVS \" || ,\n  \"PLAN POS QA RAMI SEQ PHYS SMSC TSO USER MNT\";\nTEMP = \"\";\nDO I = 1 TO WORDS(CDRS.3380DJ) BY 2;\n  LLIM = X2D(WORD(CDRS.3380DJ,I));\n  HLIM = X2D(WORD(CDRS.3380DJ,I+1));\n     DO J = LLIM TO HLIM;\n        TEMP = TEMP D2X(J);\n     END;\nEND;\nCDRS.3380DJ = TEMP;\nTEMP = \"\";\nDO I = 1 TO WORDS(CDRS.3380E) BY 2;\n  LLIM = X2D(WORD(CDRS.3380E,I));\n  HLIM = X2D(WORD(CDRS.3380E,I+1));\n     DO J = LLIM TO HLIM;\n        TEMP = TEMP D2X(J);\n     END;\nEND;\nCDRS.3380E = TEMP;\nTEMP = \"\";\nDO I = 1 TO WORDS(CDRS.3380K) BY 2;\n  LLIM = X2D(WORD(CDRS.3380K,I));\n  HLIM = X2D(WORD(CDRS.3380K,I+1));\n     DO J = LLIM TO HLIM;\n        TEMP = TEMP D2X(J);\n     END;\nEND;\nCDRS.3380K = TEMP;\nTEMP = \"\";\nDO I = 1 TO WORDS(CDRS.33902) BY 2;\n  LLIM = X2D(WORD(CDRS.33902,I));\n  HLIM = X2D(WORD(CDRS.33902,I+1));\n     DO J = LLIM TO HLIM;\n        TEMP = TEMP D2X(J);\n     END;\nEND;\nCDRS.33902 = TEMP;\nTEMP = \"\";\nDO I = 1 TO WORDS(CDRS.33903) BY 2;\n  LLIM = X2D(WORD(CDRS.33903,I));\n  HLIM = X2D(WORD(CDRS.33903,I+1));\n     DO J = LLIM TO HLIM;\n        TEMP = TEMP D2X(J);\n     END;\nEND;\nCDRS.33903 = TEMP;\nTEMP = \"\";\nDO I = 1 TO WORDS(CDRS.33906) BY 2;\n  LLIM = X2D(WORD(CDRS.33906,I));\n  HLIM = X2D(WORD(CDRS.33906,I+1));\n     DO J = LLIM TO HLIM;\n        TEMP = TEMP D2X(J);\n     END;\nEND;\nCDRS.33906 = TEMP;\nINIT_REST_UNIT = WORD(CDRS.33902,1);\nCDRS.33902 = DELWORD(CDRS.33902,1,1);\n\"CALL 'SYS1.TECH.COMMON.LOADLIB(DASDSCAN)'\";\n/* \"CALL 'TECH110.USER.LOADLIB(DASDSCAN)'\"; */\nSAVERC=RC;\nIF SAVERC\u00ac=0 THEN EXIT SAVERC;\n\"EXECIO * DISKR WORK (FINIS STEM DASDV.\";\nCHANGES = TRUE;\nDO WHILE(CHANGES); /* BUBBLE SORT DESCENDING BY FRAG INDEX */\n     CHANGES = FALSE;\n     DO I = 1 TO DASDV.0-1;\n          J = I+1;\n          PARSE VAR DASDV.I . . . FRAGINDEX1 . ;\n          PARSE VAR DASDV.J . . . FRAGINDEX2 . ;\n          IF FRAGINDEX1 < FRAGINDEX2 THEN DO;\n                 TEMP = DASDV.I;\n                 DASDV.I = DASDV.J;\n                 DASDV.J = TEMP;\n                 CHANGES = TRUE;\n                 END;\n     END;\nEND;\nFLAG_CNT=1\nDO I = 1 TO DASDV.0;\n  PARSE VAR DASDV.I VOLSER CYLCOUNT FREECYL FRAGINDEX . ;\n  ABR_BACKUP_DSN = \"'FDRABR.V\"VOLSER\"'\";\n  DUMMY = LISTDSI(ABR_BACKUP_DSN); /* SEE IF DATASET EXISTS */\n  IF DUMMY\u00ac=0 THEN DO;\n       DASDV.I = \"DUMMY\"; /* IGNORE THIS VOLUME */\n       ITERATE I; /* LOOP */\n       END;\n/*** CPK SELECTION *****/\n  TSTVSR = SUBSTR(VOLSER,1,4)\n  INTERPRET VOLSER '= \"NO\"'\n  IF TSTVSR = \"APPL\" |,\n     TSTVSR = \"PLAN\" |,\n     TSTVSR = \"POS0\" |,\n     TSTVSR = \"TSO0\" |,\n     TSTVSR = \"USER\" |,\n     TSTVSR = \"QA00\" |,\n     TSTVSR = \"PHYS\" |,\n     TSTVSR = \"VSAM\" |,\n     TSTVSR = \"CICS\" |,\n     TSTVSR = \"DB20\" |,\n     TSTVSR = \"EMRG\" |,\n     TSTVSR = \"UART\" |,\n     TSTVSR = \"ARTH\" |,\n     TSTVSR = \"SEQD\"   THEN DO\n     INTERPRET VOLSER '= \"YES\"'\n     END\n/***********************/\n  POOLCTR=WORDS(ABRPOOLS);\n  DO J=1 TO POOLCTR;\n     POOL=WORD(ABRPOOLS,J);\n     IF ABBREV(VOLSER,POOL) THEN DO;\n           IF SYMBOL('POOLLIST.POOL')=\"VAR\" THEN ,\n               POOLLIST.POOL=POOLLIST.POOL VOLSER;\n            ELSE POOLLIST.POOL=VOLSER;\n          LEAVE J;\n         END;\n  END;\nEND;\nABRPOOLS = ABRPOOLSR; /* REORG LIST FOR ORDER TO PROCESS IN */\nDO J=1 TO POOLCTR;\n     POOL=WORD(ABRPOOLS,J);\n     VOLCNT=WORDS(POOLLIST.POOL);\n     JOBC=SUBSTR(CLASSLIST,J,1);\nSUMM.SUMMCTR=\"****** POOL\" LEFT(POOL,7) \"RESTORE JOBCLASS:\" JOBC ,\n        \"VOLCNT:\" VOLCNT;\n     SUMMCTR=SUMMCTR+1;\nEND;\nJCLD.0 = 40; /* COUNT OF DUMP JOB STATEMENTS */\nJCLD.1 = \"//D$XXXXXX JOB 530401053000,'SYSTEM.BACKUP',\";\nJCLD.2 = \"// NOTIFY=TECH251,CLASS=S,MSGCLASS=G\";\nJCLD.3  = \"//DUMPIT EXEC PGM=FDRABR,REGION=9M\";\nJCLD.4  = \"//SYSPRINT DD SYSOUT=*\";\nJCLD.5  = \"//SYSPRIN1 DD SYSOUT=*\";\nJCLD.6  = \"//DISK1 DD UNIT=XXXX,\";\nJCLD.7  = \"// DISP=SHR,\";\nJCLD.8  = \"// VOL=SER=XXXXXX\";\nJCLD.9 =\"//TAPE1 DD DSN=FXXXXXX,DISP=(,KEEP),UNIT=TA80,VOL=(,,,255)\";\nJCLD.10 = \"//SYSUDUMP DD SYSOUT=X\";\nJCLD.11 = \"//SYSIN DD *\";\nJCLD.12 = \" DUMP TYPE=FDR,\";\nJCLD.13 = \"  AUTOUPD=YES,\";\nJCLD.14 = \"  BUFNO=MAX,\";\nJCLD.15 = \"  COMPRESS=ALL,\";\nJCLD.16 = \"  DATA=ALL,\";\nJCLD.17 = \"  DATEP=NONE,\";\nJCLD.18 = \"  DSNENQ=TEST,\";\nJCLD.19 = \"  ENQ=RESERVE,\";\nJCLD.20 = \"  ENQERR=NO,\";\nJCLD.21 = \"  ENQERR=PROCESS,\";\nJCLD.22 = \"  FORMAT=NEW,\";\nJCLD.23 = \"  LBPZERO=INVALID,\";\nJCLD.24 = \"  MAXERR=1,\";\nJCLD.25 = \"  PRINT=ABR,\";\nJCLD.26 = \"  RETPD=9999,\";\nJCLD.27 = \"  SMSCONSTRUCT=NO,\";\nJCLD.28 = \"  SMSMANAGE=NO\";\nJCLD.29 = \"/*\";\nJCLD.30 = \"// IF (DUMPIT.RC>4 | DUMPIT.ABEND=TRUE) THEN\";\nJCLD.31 = \"//DUMPFAIL EXEC WTO\";\nJCLD.32 = \"//SYSIN    DD *\";\nJCLD.33 = \" *** WARNING\";\nJCLD.34 = \" ** \";\nJCLD.35 = \" ** ERROR DURING FULL VOLUME BACKUP OF VOL > XXXXXX <.\";\nJCLD.36 = \" ** \";\nJCLD.37 = \" *** WARNING \";\nJCLD.38 = \"/*\";\nJCLD.39 = \"// ENDIF\";\nJCLD.40 = \"//\";\nJCLX.0 = 41; /* COUNT OF INCR JOB STATEMENTS */\nJCLX.1 = \"//I$XXXX JOB 530401053000,'SYSTEM.BACKUP',\";\nJCLX.2 = \"// NOTIFY=TECH251,\";\nJCLX.3 = \"// CLASS=S,MSGCLASS=G\";\nJCLX.4 = \"//DUMPIT EXEC PGM=FDRABR,REGION=9M\";\nJCLX.5 = \"//SYSPRIN1 DD SYSOUT=*\";\nJCLX.6 = \"//SYSPRIN2 DD SYSOUT=*\";\nJCLX.7 = \"//SYSPRIN3 DD SYSOUT=*\";\nJCLX.8=\"//TAPE1 DD DSN=I1XXXX,DISP=(,KEEP),UNIT=TA80,VOL=(,,,255)\";\nJCLX.9=\"//TAPE2 DD DSN=I2XXXX,DISP=(,KEEP),UNIT=TA80,VOL=(,,,255)\";\nJCLX.10=\"//TAPE3 DD DSN=I3XXXX,DISP=(,KEEP),UNIT=TA80,VOL=(,,,255)\";\nJCLX.11= \"//SYSPRINT DD SYSOUT=*\";\nJCLX.12 = \"//SYSUDUMP DD SYSOUT=X\";\nJCLX.13 = \"//SYSIN DD *\";\nJCLX.14 = \" DUMP TYPE=ABR,\";\nJCLX.15 = \"  AUTOUPD=YES,\";\nJCLX.16 = \"  BUFNO=MAX,\";\nJCLX.17 = \"  COMPRESS=ALL,\";\nJCLX.18 = \"  DATA=USED,\";\nJCLX.19 = \"  DATEP=NONE,\";\nJCLX.20 = \"  DSNENQ=TEST,\";\nJCLX.21 = \"  ENQ=RESERVE,\";\nJCLX.22 = \"  ENQERR=NO,\";\nJCLX.23 = \"  ENQERR=PROCESS,\";\nJCLX.24 = \"  FORMAT=NEW,\";\nJCLX.25 = \"  LBPZERO=INVALID,\";\nJCLX.26 = \"  MAXERR=1,\";\nJCLX.27 = \"  PRINT=ABR,\";\nJCLX.28 = \"  RETPD=9999,\";\nJCLX.29 = \"  SMSCONSTRUCT=NO,\";\nJCLX.30 = \"  SMSMANAGE=NO\";\nJCLXSTP = 30\n/* ********* 30 *********** */\nJCLX.31 = \"/*\";\nJCLX.32 = \"// IF (DUMPIT.RC>8 | DUMPIT.ABEND=TRUE) THEN\";\nJCLX.33 = \"//DUMPFAIL EXEC WTO\";\nJCLX.34 = \"//SYSIN    DD * \";\nJCLX.35 = \" *** WARNING\";\nJCLX.36 = \" ** \";\nJCLX.37 = \" ** ERROR DURING INCREMENTAL BACKUP OF VOL GROUP > XXXX <.\";\nJCLX.38 = \" ** \";\nJCLX.39 = \" *** WARNING\";\nJCLX.40 = \"/*\";\nJCLX.41 = \"// ENDIF\";\nJCLR.0 = 47; /* COUNT OF RESTORE JOB STATEMENTS */\nJCLR.1 = \"//R$XXXXXX JOB 530401053000,'TECH SUPPRT',\";\nJCLR.2 = \"// CLASS=?,MSGCLASS=X,MSGLEVEL=(1,1),REGION=6M\";\nJCLR.3 = \"//JOBLIB DD DSN=IMPORT.LINKLIB1,DISP=SHR\";\nJCLR.4 = \"//ACTIVE EXEC PGM=IKJEFT01,REGION=6M,\";\nJCLR.5 = \"// PARM='ALTER ''FDRABR.COMDISCO.WEEKREST.VXXXXXX'' OWNER(I)'\"\nJCLR.6 = \"//SYSTSPRT DD SYSOUT=*\";\nJCLR.7 = \"//SYSTSIN DD DUMMY\";\nJCLR.8 = \"//*\";\nJCLR.9 = \"//*\";\nJCLR.10 = \"//*\";\nJCLR.11 = \"//*\";\nJCLR.12 = \"//*\";\nJCLR.13 = \"//RESTIT EXEC PGM=FDRABR,REGION=6M\";\nJCLR.14 = \"//SYSPRINT DD SYSOUT=*\";\nJCLR.15 = \"//ABRWORK  DD UNIT=SYSALLDA,SPACE=(CYL,(2,1))\";\nJCLR.16 = \"//DISK1 DD UNIT=XXXX,VOL=SER=XXXXXX,DISP=OLD\";\nJCLR.17 = \"//SYSIN DD *\";\nJCLR.18 = \" RESTORE TYPE=FDR,\";\nJCLR.19 = \"   CONFMESS=NO,\";\nJCLR.20 = \"   COPY=1,\";\nJCLR.21 = \"  CPYVOLID=YES,\";\nJCLR.22 = \"  DYNTAPE,\";\nJCLR.23 = \"  MAXERR=1,\";\nJCLR.24 = \"  SMSPROT=NONE,\";\nJCLR.25 = \"  VOLRESET=NO\";\nJCLR.26 = \" SELECT  VOL=XXXXXX,GEN=CURRENT\";\nJCLR.27 = \"/*\";\nJCLR.28 = \"//IXITIT EXEC PGM=ICKDSF,REGION=6M\";\nJCLR.29 = \"//SYSPRINT DD SYSOUT=*\";\nJCLR.30 = \"//DISK1 DD UNIT=XXXX,VOL=SER=XXXXXX,DISP=OLD\";\nJCLR.31 = \"//SYSIN DD *\";\nJCLR.32=\" BUILDIX DDNAME(DISK1) IXVTOC\";\nJCLR.33 = \"//COMPLETE EXEC PGM=IKJEFT01,COND=(0,NE,RESTIT),\";\nJCLR.34=\"// PARM='ALTER ''FDRABR.COMDISCO.WEEKREST.VXXXXXX'' OWNER(C)'\"\nJCLR.35 = \"//SYSTSPRT DD SYSOUT=*\";\nJCLR.36 = \"//SYSTSIN DD DUMMY\";\nJCLR.37 = \"//*\";\nJCLR.38 = \"//*\";\nJCLR.39 = \"//*\";\nJCLR.40 = \"//*\";\nJCLR.41 = \"//*\";\nJCLR.42 = \"//*\";\nJCLR.43 = \"//FAILURE EXEC PGM=IKJEFT01,COND=((0,GE,RESTIT),EVEN),\";\nJCLR.44=\"// PARM='ALTER ''FDRABR.COMDISCO.WEEKREST.VXXXXXX'' OWNER(F)'\"\nJCLR.45 = \"//SYSTSPRT DD SYSOUT=*\";\nJCLR.46 = \"//SYSTSIN DD DUMMY\";\nJCLR.47 = \"//\";\nJCLI.0 = 8; /* COUNT OF INIT JOB STATEMENTS */\nJCLI.1 = \"//I$XXXXXX JOB 530401053000,'TECH SUPPRT',NOTIFY=$CDRS1,\";\nJCLI.2 = \"// CLASS=A,MSGCLASS=X,MSGLEVEL=(1,1)\";\nJCLI.3 = \"//INITIT EXEC PGM=ICKDSF,REGION=6M\";\nJCLI.4 = \"//SYSPRINT DD SYSOUT=*\";\nJCLI.5 = \"//SYSIN DD *\";\nJCLI.6=\" INIT UNIT(XXX) NVFY NCHK INDEX(1,0,15) VTOC(0,1,14) -\";\nJCLI.7 = \"   NOMAP PRG NVAL VOLID(XXXXXX)\";\nJCLI.8 = \"//\";\nJCLC.0 = 39; /* COMPAKTOR */\nJCLC.1 = \"// IF (DUMPIT.RC<=4 & \u00acDUMPIT.ABEND=TRUE) THEN\";\nJCLC.2 = \"//CPKIT  EXEC PGM=FDRCPK,REGION=9M\";\nJCLC.3 = \"//STEPLIB  DD DSN=SYS1.FDR.V5R2M33.LOADLIB,DISP=SHR\";\nJCLC.4 = \"//SYSPRINT DD SYSOUT=*\";\nJCLC.5 = \"//SYSMAP   DD SYSOUT=*\";\nJCLC.6 = \"//SYSSUMM  DD SYSOUT=*\";\nJCLC.7 = \"//SYSUDUMP DD SYSOUT=X\";\nJCLC.8 = \"//SYSIN DD *\";\nJCLC.9 = \" CPK TYPE=FASTCPK,VOL=(XXXXXX),ACTMESS=NO,CONFMESS=NO,\";\nJCLC.10= \" HI=NO,MAPS=SUMMARY,NOSECOND=NORLSE,ENQ=RESERVE,DSNENQ=USE,\";\nJCLC.11 = \" O=MAXFREE,PSRLSE=ALL,UNABLE=IGNORE,SIZEKEEP=(,,,10000),\";\nJCLC.12 = \" T=KEEP,V=NOCHANGE,CPKFREEX=10\";\nJCLC.13 = \"/*\";\nJCLC.14 = \"// ENDIF\";\nJCLC.15 = \"//*\";\nJCLC.16 = \"// IF (CPKIT.RC>0 | CPKIT.ABEND=TRUE) THEN\";\nJCLC.17 = \"//MAPIT    EXEC PGM=FDRCPK\";\nJCLC.18 = \"//TAPE1    DD DUMMY\";\nJCLC.19 = \"//SYSMAP   DD SYSOUT=*\";\nJCLC.20 = \"//SYSPRINT DD SYSOUT=*\";\nJCLC.21 = \"//SYSUDUMP DD SYSOUT=*\";\nJCLC.22 = \"//SYSIN    DD *\";\nJCLC.23 = \"   MAP VOL=XXXXXX,MAPS=SUMMARY \";\nJCLC.24 = \"/*\";\nJCLC.25 = \"// ENDIF \";\nJCLC.26 = \"// IF (MAPIT.RC>0 | MAPIT.ABEND=TRUE) THEN\";\nJCLC.27 = \"//CPKFAIL  EXEC WTO\";\nJCLC.28 = \"//SYSIN    DD * \";\nJCLC.29 = \" *** WARNING \";\nJCLC.30 = \" ** \";\nJCLC.31 = \" ** AN ERROR HAS OCCURRED DURING THE COMPACTION OF\";\nJCLC.32 = \" ** VOLUME > XXXXXX <. THIS PROBLEM MUST BE RESOLVED\";\nJCLC.33 = \" ** BEFORE THE SCHEDULE CONTINUES. CONTACT TECH SUPPORT\";\nJCLC.34 = \" ** PERSON ON CALL.\";\nJCLC.35 = \" ** \";\nJCLC.36 = \" *** WARNING \";\nJCLC.37 = \"/* \";\nJCLC.38 = \"// ENDIF \";\nJCLC.39 = \"// \";\nHEADTAIL = TRUE;\nSAY \"\";\nSAY \"****** INITIAL RESTORE 3390 UNIT:\" ,\n     INIT_REST_UNIT;\nSAY \"\";\nSUMM.SUMMCTR = \"****** INITIAL RESTORE 3390 UNIT:\" ,\n     INIT_REST_UNIT;\nSUMMCTR=SUMMCTR+1;\n/* LOOP */\nPOOLCTR=WORDS(ABRPOOLS);\nDO ZZ=1 TO POOLCTR;\nJOBC = SUBSTR(CLASSLIST,ZZ,1);\nPOOL=WORD(ABRPOOLS,ZZ);\nPOOLMEM=STRIP(SUBSTR(\"POOL\"POOL,1,8));\nDROP DUMP.;\nDROP INCR.;\nDROP REST.;\nDROP INIT.;\nDUMPCTR=1;\nINCRCTR=1;\nRESTCTR=1;\nINITCTR=1;\n\"FREE F(INIT)\";\n\"FREE F(DUMP)\";\n\"FREE F(INCR)\";\n\"FREE F(REST)\";\n\"ALLOC F(INIT) DA('SYSS.COMDISCO.INITJOBS(\"POOLMEM\")') SHR\";\nIF RC\u00ac=0 THEN EXIT 99;\nIF POOLMEM \u00ac=\"POOLSYSD\" & POOLMEM \u00ac=\"POOLSYST\" THEN DO;\n\"ALLOC F(DUMP) DA('SYSS.COMDISCO.DUMPJOBS(\"POOLMEM\")') SHR\";\nIF RC\u00ac=0 THEN EXIT 99;\nEND;\nIF POOLMEM \u00ac=\"POOLSYSD\" & POOLMEM \u00ac=\"POOLSYST\" THEN DO;\n\"ALLOC F(INCR) DA('SYSS.COMDISCO.INCRJOBS(\"POOLMEM\")') SHR\";\nIF RC\u00ac=0 THEN EXIT 99;\nEND;\nIF POOLMEM \u00ac=\"POOLSYSD\" & POOLMEM \u00ac=\"POOLSYST\" THEN DO;\n\"ALLOC F(REST) DA('SYSS.COMDISCO.RESTJOBS(\"POOLMEM\")') SHR\";\nIF RC\u00ac=0 THEN EXIT 99;\nEND;\nT1=OVERLAY(POOL,JCLX.1,POS('XXXX',JCLX.1));\nDO J = 1 TO 3;\n      IF J=1 THEN INCR.INCRCTR=T1;\n      ELSE INCR.INCRCTR=JCLX.J;\n      INCRCTR=INCRCTR+1;\nEND;\nXCTR=WORDS(POOLLIST.POOL);\nTRUEVOLC=0;\nDO I = 1 TO XCTR;\n  XVOL=WORD(POOLLIST.POOL,I);\n  TEMP_PACK1 = SUBSTR(XVOL,1,5);\n  TEMP_PACK2 = SUBSTR(XVOL,1,3);\n  IF TEMP_PACK1=\"SYSDA\" | TEMP_PACK1=\"SYSTA\" | TEMP_PACK2=\"DRV\" ,\n     | TEMP_PACK2=\"TEM\" | TEMP_PACK2=\"LAN\" THEN ITERATE;\n  IF XVOL=\"SYS015\" | XVOL=\"SYS007\" | XVOL=\"SYS008\" | XVOL=\"SYS011\" | ,\n     XVOL=\"SYS012\" | XVOL=\"SYS013\" | XVOL=\"SYS014\" THEN ITERATE;\n  TRUEVOLC=TRUEVOLC+1;\nEND;\n/* INCRCTR=INCRCTR+1 */;\nT2=OVERLAY(POOL,JCLX.8,POS('XXXX',JCLX.8));\nT3=OVERLAY(POOL,JCLX.9,POS('XXXX',JCLX.9));\nT4=OVERLAY(POOL,JCLX.10,POS('XXXX',JCLX.10));\nT5=OVERLAY(POOL,JCLX.37,POS('XXXX',JCLX.37));\nDO J = 4 TO JCLXSTP;\n      IF J=8 THEN INCR.INCRCTR=T2;\n      ELSE IF J=9 THEN INCR.INCRCTR=T3;\n      ELSE IF J=10 THEN INCR.INCRCTR=T4;\n      ELSE INCR.INCRCTR=JCLX.J;\n      /* TAPE CTR BY VOL CNT LOGIC */\n/*    IF TRUEVOLC>=9 & J=17 THEN ITERATE J;   */\n      IF TRUEVOLC>=9 THEN NOP;\n      ELSE IF TRUEVOLC>=4 & ,\n          (J=7 | J=10) THEN ITERATE J;\n      ELSE IF TRUEVOLC<4 & ,\n          (J=7 | J=10 | J=6 | J=9) THEN ITERATE J;\n      INCRCTR=INCRCTR+1;\n      IF TRUEVOLC>=9 & J=7 THEN DO;\n         INCR.INCRCTR=\"//SYSPRIN4 DD SYSOUT=*\";\n         INCRCTR=INCRCTR+1;\n/*       INCR.INCRCTR=\"//SYSPRIN5 DD SYSOUT=*\";\n         INCRCTR=INCRCTR+1;\n         INCR.INCRCTR=\"//SYSPRIN6 DD SYSOUT=*\";\n         INCRCTR=INCRCTR+1;    */\n      END;\n      IF TRUEVOLC>=9 & J=10 THEN DO;\n      POOLX = LEFT(POOL,4,\"X\"); /* FILL OUT */\nINCR.INCRCTR= ,\n \"//TAPE4 DD DSN=I4\"POOLX\",DISP=(,KEEP),UNIT=TA80,VOL=(,,,255)\"\n         INCRCTR=INCRCTR+1;\n/* INCR.INCRCTR= ,\n \"//TAPE5 DD DSN=I5\"POOLX\",DISP=(,KEEP),UNIT=TA80,VOL=(,,,255)\"\n         INCRCTR=INCRCTR+1;\nINCR.INCRCTR= ,\n \"//TAPE6 DD DSN=I6\"POOLX\",DISP=(,KEEP),UNIT=TA80,VOL=(,,,255)\"\n         INCRCTR=INCRCTR+1;     */\n      END;\nEND;\nXCTR=WORDS(POOLLIST.POOL);\nDO I = 1 TO XCTR;\n  XVOL=WORD(POOLLIST.POOL,I);\n  TEMP_PACK1 = SUBSTR(XVOL,1,5);\n  TEMP_PACK2 = SUBSTR(XVOL,1,3);\n  IF TEMP_PACK1=\"SYSDA\" | TEMP_PACK1=\"SYSTA\" | TEMP_PACK2=\"DRV\" ,\n     | TEMP_PACK2=\"TEM\" | TEMP_PACK2=\"LAN\" THEN ITERATE;\n  /* SKIP SOME INCR */\n  IF XVOL=\"SYS015\" | XVOL=\"SYS007\" | XVOL=\"SYS008\" | XVOL=\"SYS011\" | ,\n     XVOL=\"SYS012\" | XVOL=\"SYS013\" | XVOL=\"SYS014\" THEN ITERATE;\n  INCR.INCRCTR=\" MOUNT VOL=\"XVOL;\n  INCRCTR=INCRCTR+1;\nEND;\nJCLXHLD=JCLXSTP+1;\nDO J = JCLXHLD TO JCLX.0;\n   IF J=37 THEN INCR.INCRCTR=T5;\n   ELSE INCR.INCRCTR=JCLX.J;\n   INCRCTR=INCRCTR+1;\nEND;\nINCR.INCRCTR=\"//\";\n DO I = 1 TO DASDV.0;\n  CPK=FALSE;\n  PARSE VAR DASDV.I VOLSER CYLCOUNT FREECYL FRAGINDEX . ;\n  IF VOLSER=\"DUMMY\" THEN ITERATE;\n  IF WORDPOS(VOLSER,POOLLIST.POOL)=0 THEN ITERATE;/*DIFFERENT POOL*/\n  DEVTYPE = DASD.CYLCOUNT;\n  TRUE_DEVTYPE = DASD.CYLCOUNT;\n  IF HEADTAIL THEN DO;\n         HEADTAIL = FALSE; /* ROTATE CUU SELECTION */\n         UNIT = WORD(CDRS.DEVTYPE,1);\n         CDRS.DEVTYPE = DELWORD(CDRS.DEVTYPE,1,1);\n         END;\n  ELSE DO;\n         HEADTAIL = TRUE;  /* ROTATE CUU SELECTION */\n         IF WORDS(CDRS.DEVTYPE)=0 THEN ,\n              UNIT=\"\";\n         ELSE DO;\n           UNIT = WORD(CDRS.DEVTYPE,WORDS(CDRS.DEVTYPE));\n           IF UNIT\u00ac=\"F00\" THEN ,\n           CDRS.DEVTYPE = DELWORD(CDRS.DEVTYPE,WORDS(CDRS.DEVTYPE),1);\n           END;\n         END;\n  TARGET_TYPE=DEVTYPE;\n  IF UNIT=\"\" THEN DO; /* COMDISCO HAS NO MORE */\n       SELECT;\n         WHEN (DEVTYPE=\"3380DJ\") THEN TARGET_TYPE=\"3380E\";\n         WHEN (DEVTYPE=\"3380E\") THEN TARGET_TYPE=\"3380K\";\n         WHEN (DEVTYPE=\"3380K\") THEN EXIT 16; /* EMERGENCY */\n         WHEN (DEVTYPE=\"33902\") THEN TARGET_TYPE=\"33903\";\n         WHEN (DEVTYPE=\"33903\") THEN TARGET_TYPE=\"33906\";\n         WHEN (DEVTYPE=\"33906\") THEN EXIT 20; /* EMERGENCY */\n         OTHERWISE EXIT 24;\n       END;\n       IF TARGET_TYPE=\"3380E\" & WORDS(CDRS.3380E)=0 THEN ,\n            TARGET_TYPE=\"3380K\";\n       IF WORDS(CDRS.TARGET_TYPE)=0 THEN EXIT 28;\n       UNIT = WORD(CDRS.TARGET_TYPE,1);\n       IF UNIT\u00ac=\"F00\" THEN ,\n       CDRS.TARGET_TYPE = DELWORD(CDRS.TARGET_TYPE,1,1);\n       END;\n  DEVTYPE = SUBSTR(DEVTYPE,1,4);\n  TEMP_PACK1 = SUBSTR(VOLSER,1,5);\n  TEMP_PACK2 = SUBSTR(VOLSER,1,3);\n  IF TEMP_PACK1\u00ac=\"SYSDA\" & TEMP_PACK1\u00ac=\"SYSTA\" & TEMP_PACK2\u00ac=\"DRV\" ,\n     & TEMP_PACK2\u00ac=\"TEM\" & TEMP_PACK2\u00ac=\"LAN\" ,\n       THEN DO;\n  T1=OVERLAY(DEVTYPE,JCLD.6,POS('XXXX',JCLD.6));\n  T2=OVERLAY(VOLSER,JCLD.8,POS('XXXXXX',JCLD.8));\n  T3=OVERLAY(VOLSER,JCLD.1,POS('XXXXXX',JCLD.1));\n  T5=OVERLAY(VOLSER,JCLD.9,POS('XXXXXX',JCLD.9));\n  T10=OVERLAY(VOLSER,JCLD.35,POS('XXXXXX',JCLD.35));\n  T11=OVERLAY(VOLSER,JCLC.23,POS('XXXXXX',JCLC.23));\n  T12=OVERLAY(VOLSER,JCLC.32,POS('XXXXXX',JCLC.32));\n  T13=OVERLAY(VOLSER,JCLC.9,POS('XXXXXX',JCLC.9));\n  CDSR= \"'FDRABR.COMDISCO.WEEKREST.V\"VOLSER\"'\";\n     \"ALTER\" CDSR \"OWNER(N)\";\n  IF RC > 0 THEN ,\n    \"DEFINE NVSAM (NAME(\"CDSR\") DEVT(0000) VOL('******') OWNER(N))\";\n  DO J = 1 TO JCLD.0;\n      IF J=6 THEN DUMP.DUMPCTR=T1;\n      ELSE IF J=8 THEN DUMP.DUMPCTR=T2;\n      ELSE IF J=1 THEN DUMP.DUMPCTR=T3;\n      ELSE IF J=9 THEN DUMP.DUMPCTR=T5;\n      ELSE IF J=35 THEN DUMP.DUMPCTR=T10;\n      ELSE IF J=18 & VOLSER=\"SYS015\" THEN ,\n         DUMP.DUMPCTR=\"  ENQ=OFF,\";\n      ELSE DUMP.DUMPCTR=JCLD.J;\n      FLAGIT = \"NO\"\n   /* CHANGE  */\n      INTERPRET 'IF 'VOLSER '=\"YES\" THEN FLAGIT = \"YES\"'\n      IF J=23 & FLAGIT=\"YES\" THEN CPK=TRUE;\n      ELSE IF J=23 THEN CPK=FALSE;\n      ELSE NOP;\n   /* CHANGE  */\n      IF J=40 & (CPK) THEN ITERATE J ;\n      ELSE NOP;\n      DUMPCTR=DUMPCTR+1;\n      IF (J=39) & (CPK) THEN DO;\n           DO Z=1 TO JCLC.0;\n                DUMP.DUMPCTR=JCLC.Z;\n    /* CHANGE */\n                IF Z=9  THEN DUMP.DUMPCTR= T13;\n                IF Z=23 THEN DUMP.DUMPCTR= T11;\n                IF Z=32 THEN DUMP.DUMPCTR= T12;\n                DUMPCTR=DUMPCTR+1;\n           END;\n       END;\n  END;\n  T1=OVERLAY(DEVTYPE,JCLR.16,POS('XXXX',JCLR.16));\n  T1=OVERLAY(VOLSER,T1,POS('XXXXXX',T1));\n  T2=OVERLAY(VOLSER,JCLR.26,POS('XXXXXX',JCLR.26));\n  T3=OVERLAY(VOLSER,JCLR.1,POS('XXXXXX',JCLR.1));\n  T4=OVERLAY(VOLSER,JCLR.5,POS('XXXXXX',JCLR.5));\n  T5=OVERLAY(VOLSER,JCLR.34,POS('XXXXXX',JCLR.34));\n  T6=OVERLAY(VOLSER,JCLR.44,POS('XXXXXX',JCLR.44));\n  T7=OVERLAY(JOBC,JCLR.2,POS('?',JCLR.2));\n  DO J = 1 TO JCLR.0;\n      IF J=16 THEN REST.RESTCTR=T1;\n      ELSE IF J=26 THEN REST.RESTCTR=T2;\n      ELSE IF J=30 THEN REST.RESTCTR=T1;\n      ELSE IF J=34 THEN REST.RESTCTR=T5;\n      ELSE IF J=44 THEN REST.RESTCTR=T6;\n      ELSE IF J=5 THEN REST.RESTCTR=T4;\n      ELSE IF J=1 THEN REST.RESTCTR=T3;\n      ELSE IF J=2 THEN REST.RESTCTR=T7;\n      ELSE REST.RESTCTR=JCLR.J;\n      RESTCTR=RESTCTR+1;\n  END;\n  END;\n  T1=OVERLAY(UNIT,JCLI.6,POS('XXX',JCLI.6));\n  T2=OVERLAY(VOLSER,JCLI.7,POS('XXXXXX',JCLI.7));\n  T3=OVERLAY(VOLSER,JCLI.1,POS('XXXXXX',JCLI.1));\n IF UNIT\u00ac=\"F00\" THEN DO;\n  DO J = 1 TO JCLI.0;\n      IF J=6 THEN INIT.INITCTR=T1;\n      ELSE IF J=7 THEN INIT.INITCTR=T2;\n      ELSE IF J=1 THEN INIT.INITCTR=T3;\n      ELSE INIT.INITCTR=JCLI.J;\n      INITCTR=INITCTR+1;\n  END;\n END;\n IF UNIT\u00ac=\"F00\" THEN ,\n  SUMM.SUMMCTR = VOLSER \"TYPE\" LEFT(TRUE_DEVTYPE,6) \"MAPPED TO\",\n     \"CDRS UNIT\" UNIT \"TYPE\" TARGET_TYPE;\n ELSE ,\nSUMM.SUMMCTR=\"****** VOLUME\" VOLSER \"NOT INITIALIZED AND/OR RESTORED\";\n  IF VOLSER=\"SYS006\" THEN ,\n       SUMM.SUMMCTR=SUMM.SUMMCTR \"IPL LOADUNIT\" UNIT;\n  IF VOLSER=\"SYS001\" | VOLSER=\"SYS002\" THEN ,\n       SUMM.SUMMCTR=SUMM.SUMMCTR \"LOADPARM\" RIGHT(UNIT,4,\"0\")\"CDM\";\n  SUMMCTR=SUMMCTR+1;\n END I;\nIF POOLMEM \u00ac=\"POOLSYSD\" & POOLMEM \u00ac=\"POOLSYST\" THEN DO;\n \"EXECIO * DISKW DUMP (FINIS STEM DUMP.\";\n \"EXECIO * DISKW INCR (FINIS STEM INCR.\";\n \"EXECIO * DISKW REST (FINIS STEM REST.\";\nEND;\n \"EXECIO * DISKW INIT (FINIS STEM INIT.\";\nEND ZZ;\n\"EXECIO * DISKW SUMM (FINIS STEM SUMM.\";\nEXIT 0;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DASDBUL4": {"ttr": 9222, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x11\\x00\\x00\\x00\\x94\\x14\\x7f\\x00\\x94)/\\x12\\x00\\x02]\\x02H\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf7@@@'", "ispf": {"version": "01.17", "flags": 0, "createdate": "1994-05-27T00:00:00", "modifydate": "1994-10-19T12:00:00", "lines": 605, "newlines": 584, "modlines": 0, "user": "TECH107"}, "text": "/* REXX DASD BUILD ANALYSIS */\nTRUE = \"1\";\nCNTCP = 1\nFALSE = \"0\";\nCPKCTR = 100;\nSUMMCTR=1;\nDASD.0885 = \"3380DJ\";\nDASD.1770 = \"3380E\";\nDASD.2655 = \"3380K\";\nDASD.2226 = \"33902\";\nDASD.3339 = \"33903\";\nDASD.6678 = \"33906\";\nCDRS.3380DJ = \"100 11F 200 21F\";\nCDRS.3380E  = \"480 49F\";\nCDRS.3380K  = \"C40 C5F F00 F00\";\nCDRS.33902  = \"3C0 3FF FC0 FFF\";\nCDRS.33903  = \"EC0 EFF 1C0 1FF 200 2FF\";\n/* CDRS.33903  = \"EC0 EFF 1C0 1FF\"; DUMMY RANGE ADDED 9/23 */\nCDRS.33906  = \"F00 F00\"; /* F00 IS END INDICATOR */\nCLASSLIST=\"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\n/* ALPHA LIST */\nABRPOOLS=\"ACIC APPL ART CICS DB2 EMC EMR MNT MVS PLAN \" || ,\n  \"POS PHYS QA RAMI SEQ SMSC SMS SYSDA SYSTA SYS TART TSO \" || ,\n  \"UART USER VSAM\";\n/* LIST BY IMP */\nABRPOOLSR=\"SYS CICS EMC DB2 SMS VSAM ART ACIC UART APPL EMR MVS \" || ,\n  \"PLAN POS QA RAMI SEQ PHYS SMSC TSO USER MNT TART\";\nTEMP = \"\";\nDO I = 1 TO WORDS(CDRS.3380DJ) BY 2;\n  LLIM = X2D(WORD(CDRS.3380DJ,I));\n  HLIM = X2D(WORD(CDRS.3380DJ,I+1));\n     DO J = LLIM TO HLIM;\n        TEMP = TEMP D2X(J);\n     END;\nEND;\nCDRS.3380DJ = TEMP;\nTEMP = \"\";\nDO I = 1 TO WORDS(CDRS.3380E) BY 2;\n  LLIM = X2D(WORD(CDRS.3380E,I));\n  HLIM = X2D(WORD(CDRS.3380E,I+1));\n     DO J = LLIM TO HLIM;\n        TEMP = TEMP D2X(J);\n     END;\nEND;\nCDRS.3380E = TEMP;\nTEMP = \"\";\nDO I = 1 TO WORDS(CDRS.3380K) BY 2;\n  LLIM = X2D(WORD(CDRS.3380K,I));\n  HLIM = X2D(WORD(CDRS.3380K,I+1));\n     DO J = LLIM TO HLIM;\n        TEMP = TEMP D2X(J);\n     END;\nEND;\nCDRS.3380K = TEMP;\nTEMP = \"\";\nDO I = 1 TO WORDS(CDRS.33902) BY 2;\n  LLIM = X2D(WORD(CDRS.33902,I));\n  HLIM = X2D(WORD(CDRS.33902,I+1));\n     DO J = LLIM TO HLIM;\n        TEMP = TEMP D2X(J);\n     END;\nEND;\nCDRS.33902 = TEMP;\nTEMP = \"\";\nDO I = 1 TO WORDS(CDRS.33903) BY 2;\n  LLIM = X2D(WORD(CDRS.33903,I));\n  HLIM = X2D(WORD(CDRS.33903,I+1));\n     DO J = LLIM TO HLIM;\n        TEMP = TEMP D2X(J);\n     END;\nEND;\nCDRS.33903 = TEMP;\nTEMP = \"\";\nDO I = 1 TO WORDS(CDRS.33906) BY 2;\n  LLIM = X2D(WORD(CDRS.33906,I));\n  HLIM = X2D(WORD(CDRS.33906,I+1));\n     DO J = LLIM TO HLIM;\n        TEMP = TEMP D2X(J);\n     END;\nEND;\nCDRS.33906 = TEMP;\nINIT_REST_UNIT = WORD(CDRS.33902,1);\nCDRS.33902 = DELWORD(CDRS.33902,1,1);\n\"CALL 'SYS1.TECH.COMMON.LOADLIB(DASDSCAN)'\";\n/* \"CALL 'TECH110.USER.LOADLIB(DASDSCAN)'\"; */\nSAVERC=RC;\nIF SAVERC\u00ac=0 THEN EXIT SAVERC;\n\"EXECIO * DISKR WORK (FINIS STEM DASDV.\";\nCHANGES = TRUE;\nDO WHILE(CHANGES); /* BUBBLE SORT DESCENDING BY FRAG INDEX */\n     CHANGES = FALSE;\n     DO I = 1 TO DASDV.0-1;\n          J = I+1;\n          PARSE VAR DASDV.I . . . FRAGINDEX1 . ;\n          PARSE VAR DASDV.J . . . FRAGINDEX2 . ;\n          IF FRAGINDEX1 < FRAGINDEX2 THEN DO;\n                 TEMP = DASDV.I;\n                 DASDV.I = DASDV.J;\n                 DASDV.J = TEMP;\n                 CHANGES = TRUE;\n                 END;\n     END;\nEND;\nFLAG_CNT=1\nDO I = 1 TO DASDV.0;\n  PARSE VAR DASDV.I VOLSER CYLCOUNT FREECYL FRAGINDEX . ;\n  ABR_BACKUP_DSN = \"'FDRABR.V\"VOLSER\"'\";\n  DUMMY = LISTDSI(ABR_BACKUP_DSN); /* SEE IF DATASET EXISTS */\n  IF DUMMY\u00ac=0 THEN DO;\n       DASDV.I = \"DUMMY\"; /* IGNORE THIS VOLUME */\n       ITERATE I; /* LOOP */\n       END;\n/*** CPK SELECTION *****/\n  TSTVSR = SUBSTR(VOLSER,1,4)\n  INTERPRET VOLSER '= \"NO\"'\n  IF TSTVSR = \"APPL\" |,\n     TSTVSR = \"PLAN\" |,\n     TSTVSR = \"POS0\" |,\n     TSTVSR = \"TSO0\" |,\n     TSTVSR = \"USER\" |,\n     TSTVSR = \"QA00\" |,\n     TSTVSR = \"PHYS\" |,\n     TSTVSR = \"VSAM\" |,\n     TSTVSR = \"CICS\" |,\n     TSTVSR = \"DB20\" |,\n     TSTVSR = \"SEQD\" |,\n     TSTVSR = \"UART\" |,\n     TSTVSR = \"ARTH\" |,\n     TSTVSR = \"RAMI\" |,\n     TSTVSR = \"SMSU\" |,\n     TSTVSR = \"SMSC\" |,\n     TSTVSR = \"EMRG\" THEN DO\n     INTERPRET VOLSER '= \"YES\"'\n     END\n/***********************/\n  POOLCTR=WORDS(ABRPOOLS);\n  DO J=1 TO POOLCTR;\n     POOL=WORD(ABRPOOLS,J);\n     IF ABBREV(VOLSER,POOL) THEN DO;\n           IF SYMBOL('POOLLIST.POOL')=\"VAR\" THEN ,\n               POOLLIST.POOL=POOLLIST.POOL VOLSER;\n            ELSE POOLLIST.POOL=VOLSER;\n          LEAVE J;\n         END;\n  END;\nEND;\nABRPOOLS = ABRPOOLSR; /* REORG LIST FOR ORDER TO PROCESS IN */\nDO J=1 TO POOLCTR;\n     POOL=WORD(ABRPOOLS,J);\n     VOLCNT=WORDS(POOLLIST.POOL);\n     JOBC=SUBSTR(CLASSLIST,J,1);\nSUMM.SUMMCTR=\"****** POOL\" LEFT(POOL,7) \"RESTORE JOBCLASS:\" JOBC ,\n        \"VOLCNT:\" VOLCNT;\n     SUMMCTR=SUMMCTR+1;\nEND;\nJCLD.0 = 40; /* COUNT OF DUMP JOB STATEMENTS */\nJCLD.1 = \"//D$XXXXXX JOB 530401053000,'SYSTEM.BACKUP',\";\nJCLD.2 = \"// NOTIFY=TECH251,CLASS=S,MSGCLASS=G\";\nJCLD.3  = \"//DUMPIT EXEC PGM=FDRABR,REGION=9M\";\nJCLD.4  = \"//SYSPRINT DD SYSOUT=*\";\nJCLD.5  = \"//SYSPRIN1 DD SYSOUT=*\";\nJCLD.6  = \"//DISK1 DD UNIT=XXXX,\";\nJCLD.7  = \"// DISP=SHR,\";\nJCLD.8  = \"// VOL=SER=XXXXXX\";\nJCLD.9 =\"//TAPE1 DD DSN=FXXXXXX,DISP=(,KEEP),UNIT=TA80,VOL=(,,,255)\";\nJCLD.10 = \"//SYSUDUMP DD SYSOUT=X\";\nJCLD.11 = \"//SYSIN DD *\";\nJCLD.12 = \" DUMP TYPE=FDR,\";\nJCLD.13 = \"  AUTOUPD=YES,\";\nJCLD.14 = \"  BUFNO=MAX,\";\nJCLD.15 = \"  COMPRESS=ALL,\";\nJCLD.16 = \"  DATA=ALL,\";\nJCLD.17 = \"  DATEP=NONE,\";\nJCLD.18 = \"  DSNENQ=TEST,\";\nJCLD.19 = \"  ENQ=RESERVE,\";\nJCLD.20 = \"  ENQERR=NO,\";\nJCLD.21 = \"  ENQERR=PROCESS,\";\nJCLD.22 = \"  FORMAT=NEW,\";\nJCLD.23 = \"  LBPZERO=INVALID,\";\nJCLD.24 = \"  MAXERR=1,\";\nJCLD.25 = \"  PRINT=ABR,\";\nJCLD.26 = \"  RETPD=9999,\";\nJCLD.27 = \"  SMSCONSTRUCT=NO,\";\nJCLD.28 = \"  SMSMANAGE=NO\";\nJCLD.29 = \"/*\";\nJCLD.30 = \"// IF (DUMPIT.RC>4 | DUMPIT.ABEND=TRUE) THEN\";\nJCLD.31 = \"//DUMPFAIL EXEC WTO\";\nJCLD.32 = \"//SYSIN    DD *\";\nJCLD.33 = \" *** WARNING\";\nJCLD.34 = \" ** \";\nJCLD.35 = \" ** ERROR DURING FULL VOLUME BACKUP OF VOL > XXXXXX <.\";\nJCLD.36 = \" ** \";\nJCLD.37 = \" *** WARNING \";\nJCLD.38 = \"/*\";\nJCLD.39 = \"// ENDIF\";\nJCLD.40 = \"//\";\nJCLX.0 = 41; /* COUNT OF INCR JOB STATEMENTS */\nJCLX.1 = \"//I$XXXX JOB 530401053000,'SYSTEM.BACKUP',\";\nJCLX.2 = \"// NOTIFY=TECH251,\";\nJCLX.3 = \"// CLASS=S,MSGCLASS=G\";\nJCLX.4 = \"//DUMPIT EXEC PGM=FDRABR,REGION=11M\";\nJCLX.5 = \"//SYSPRIN1 DD SYSOUT=*\";\nJCLX.6 = \"//SYSPRIN2 DD SYSOUT=*\";\nJCLX.7 = \"//SYSPRIN3 DD SYSOUT=*\";\nJCLX.8=\"//TAPE1 DD DSN=I1XXXX,DISP=(,KEEP),UNIT=TA80,VOL=(,,,255)\";\nJCLX.9=\"//TAPE2 DD DSN=I2XXXX,DISP=(,KEEP),UNIT=TA80,VOL=(,,,255)\";\nJCLX.10=\"//TAPE3 DD DSN=I3XXXX,DISP=(,KEEP),UNIT=TA80,VOL=(,,,255)\";\nJCLX.11= \"//SYSPRINT DD SYSOUT=*\";\nJCLX.12 = \"//SYSUDUMP DD SYSOUT=X\";\nJCLX.13 = \"//SYSIN DD *\";\nJCLX.14 = \" DUMP TYPE=ABR,\";\nJCLX.15 = \"  AUTOUPD=YES,\";\nJCLX.16 = \"  BUFNO=MAX,\";\nJCLX.17 = \"  COMPRESS=ALL,\";\nJCLX.18 = \"  DATA=USED,\";\nJCLX.19 = \"  DATEP=NONE,\";\nJCLX.20 = \"  DSNENQ=TEST,\";\nJCLX.21 = \"  ENQ=RESERVE,\";\nJCLX.22 = \"  ENQERR=NO,\";\nJCLX.23 = \"  ENQERR=PROCESS,\";\nJCLX.24 = \"  FORMAT=NEW,\";\nJCLX.25 = \"  LBPZERO=INVALID,\";\nJCLX.26 = \"  MAXERR=1,\";\nJCLX.27 = \"  PRINT=ABR,\";\nJCLX.28 = \"  RETPD=9999,\";\nJCLX.29 = \"  SMSCONSTRUCT=NO,\";\nJCLX.30 = \"  SMSMANAGE=NO\";\nJCLXSTP = 30\n/* ********* 30 *********** */\nJCLX.31 = \"/*\";\nJCLX.32 = \"// IF (DUMPIT.RC>4 | DUMPIT.ABEND=TRUE) THEN\";\nJCLX.33 = \"//DUMPFAIL EXEC WTO\";\nJCLX.34 = \"//SYSIN    DD * \";\nJCLX.35 = \" *** WARNING\";\nJCLX.36 = \" ** \";\nJCLX.37 = \" ** ERROR DURING INCREMENTAL BACKUP OF VOL GROUP > XXXX <.\";\nJCLX.38 = \" ** \";\nJCLX.39 = \" *** WARNING\";\nJCLX.40 = \"/*\";\nJCLX.41 = \"// ENDIF\";\nJCLR.0 = 47; /* COUNT OF RESTORE JOB STATEMENTS */\nJCLR.1 = \"//R$XXXXXX JOB 530401053000,'TECH SUPPRT',\";\nJCLR.2 = \"// CLASS=?,MSGCLASS=X,MSGLEVEL=(1,1),REGION=6M\";\nJCLR.3 = \"//JOBLIB DD DSN=IMPORT.LINKLIB1,DISP=SHR\";\nJCLR.4 = \"//ACTIVE EXEC PGM=IKJEFT01,REGION=6M,\";\nJCLR.5 = \"// PARM='ALTER ''FDRABR.COMDISCO.WEEKREST.VXXXXXX'' OWNER(I)'\"\nJCLR.6 = \"//SYSTSPRT DD SYSOUT=*\";\nJCLR.7 = \"//SYSTSIN DD DUMMY\";\nJCLR.8 = \"//*\";\nJCLR.9 = \"//*\";\nJCLR.10 = \"//*\";\nJCLR.11 = \"//*\";\nJCLR.12 = \"//*\";\nJCLR.13 = \"//RESTIT EXEC PGM=FDRABR,REGION=6M\";\nJCLR.14 = \"//SYSPRINT DD SYSOUT=*\";\nJCLR.15 = \"//ABRWORK  DD UNIT=SYSALLDA,SPACE=(CYL,(2,1))\";\nJCLR.16 = \"//DISK1 DD UNIT=XXXX,VOL=SER=XXXXXX,DISP=OLD\";\nJCLR.17 = \"//SYSIN DD *\";\nJCLR.18 = \" RESTORE TYPE=FDR,\";\nJCLR.19 = \"   CONFMESS=NO,\";\nJCLR.20 = \"   COPY=1,\";\nJCLR.21 = \"  CPYVOLID=YES,\";\nJCLR.22 = \"  DYNTAPE,\";\nJCLR.23 = \"  MAXERR=1,\";\nJCLR.24 = \"  SMSPROT=NONE,\";\nJCLR.25 = \"  VOLRESET=NO\";\nJCLR.26 = \" SELECT  VOL=XXXXXX,GEN=CURRENT\";\nJCLR.27 = \"/*\";\nJCLR.28 = \"//IXITIT EXEC PGM=ICKDSF,REGION=6M\";\nJCLR.29 = \"//SYSPRINT DD SYSOUT=*\";\nJCLR.30 = \"//DISK1 DD UNIT=XXXX,VOL=SER=XXXXXX,DISP=OLD\";\nJCLR.31 = \"//SYSIN DD *\";\nJCLR.32=\" BUILDIX DDNAME(DISK1) IXVTOC\";\nJCLR.33 = \"//COMPLETE EXEC PGM=IKJEFT01,COND=(0,NE,RESTIT),\";\nJCLR.34=\"// PARM='ALTER ''FDRABR.COMDISCO.WEEKREST.VXXXXXX'' OWNER(C)'\"\nJCLR.35 = \"//SYSTSPRT DD SYSOUT=*\";\nJCLR.36 = \"//SYSTSIN DD DUMMY\";\nJCLR.37 = \"//*\";\nJCLR.38 = \"//*\";\nJCLR.39 = \"//*\";\nJCLR.40 = \"//*\";\nJCLR.41 = \"//*\";\nJCLR.42 = \"//*\";\nJCLR.43 = \"//FAILURE EXEC PGM=IKJEFT01,COND=((0,GE,RESTIT),EVEN),\";\nJCLR.44=\"// PARM='ALTER ''FDRABR.COMDISCO.WEEKREST.VXXXXXX'' OWNER(F)'\"\nJCLR.45 = \"//SYSTSPRT DD SYSOUT=*\";\nJCLR.46 = \"//SYSTSIN DD DUMMY\";\nJCLR.47 = \"//\";\nJCLI.0 = 8; /* COUNT OF INIT JOB STATEMENTS */\nJCLI.1 = \"//I$XXXXXX JOB 530401053000,'TECH SUPPRT',NOTIFY=$CDRS1,\";\nJCLI.2 = \"// CLASS=A,MSGCLASS=X,MSGLEVEL=(1,1)\";\nJCLI.3 = \"//INITIT EXEC PGM=ICKDSF,REGION=6M\";\nJCLI.4 = \"//SYSPRINT DD SYSOUT=*\";\nJCLI.5 = \"//SYSIN DD *\";\nJCLI.6=\" INIT UNIT(XXX) NVFY NCHK INDEX(1,0,15) VTOC(0,1,14) -\";\nJCLI.7 = \"   NOMAP PRG NVAL VOLID(XXXXXX)\";\nJCLI.8 = \"//\";\nJCLC.0 = 39; /* COMPAKTOR */\nJCLC.1 = \"// IF (DUMPIT.RC<=4 & \u00acDUMPIT.ABEND=TRUE) THEN\";\nJCLC.2 = \"//CPKIT  EXEC PGM=FDRCPK,REGION=9M\";\nJCLC.3 = \"//STEPLIB  DD DSN=SYS1.FDR.V5R2M33.LOADLIB,DISP=SHR\";\nJCLC.4 = \"//SYSPRINT DD SYSOUT=*\";\nJCLC.5 = \"//SYSMAP   DD SYSOUT=*\";\nJCLC.6 = \"//SYSSUMM  DD SYSOUT=*\";\nJCLC.7 = \"//SYSUDUMP DD SYSOUT=X\";\nJCLC.8 = \"//SYSIN DD *\";\nJCLC.9 = \" CPK TYPE=FASTCPK,VOL=(XXXXXX),ACTMESS=NO,CONFMESS=NO,\";\nJCLC.10= \" HI=NO,MAPS=SUMMARY,NOSECOND=NORLSE,ENQ=RESERVE,DSNENQ=USE,\";\nJCLC.11 = \" PSRLSE=ALL,UNABLE=IGNORE,SIZEKEEP=(,,,10000),\";\nJCLC.12 = \" O=MAXFREE,T=KEEP,V=NOCHANGE,CPKFREEX=10\";\nJCLC.13 = \"/*\";\nJCLC.14 = \"// ENDIF\";\nJCLC.15 = \"//*\";\nJCLC.16 = \"// IF (CPKIT.RC>0 | CPKIT.ABEND=TRUE) THEN\";\nJCLC.17 = \"//MAPIT    EXEC PGM=FDRCPK\";\nJCLC.18 = \"//TAPE1    DD DUMMY\";\nJCLC.19 = \"//SYSMAP   DD SYSOUT=*\";\nJCLC.20 = \"//SYSPRINT DD SYSOUT=*\";\nJCLC.21 = \"//SYSUDUMP DD SYSOUT=*\";\nJCLC.22 = \"//SYSIN    DD *\";\nJCLC.23 = \"   MAP VOL=XXXXXX,MAPS=SUMMARY \";\nJCLC.24 = \"/*\";\nJCLC.25 = \"// ENDIF \";\nJCLC.26 = \"// IF (MAPIT.RC>0 | MAPIT.ABEND=TRUE) THEN\";\nJCLC.27 = \"//CPKFAIL  EXEC WTO\";\nJCLC.28 = \"//SYSIN    DD * \";\nJCLC.29 = \" *** WARNING \";\nJCLC.30 = \" ** \";\nJCLC.31 = \" ** AN ERROR HAS OCCURRED DURING THE COMPACTION OF\";\nJCLC.32 = \" ** VOLUME > XXXXXX <. THIS PROBLEM MUST BE RESOLVED\";\nJCLC.33 = \" ** BEFORE THE SCHEDULE CONTINUES. CONTACT TECH SUPPORT\";\nJCLC.34 = \" ** PERSON ON CALL.\";\nJCLC.35 = \" ** \";\nJCLC.36 = \" *** WARNING \";\nJCLC.37 = \"/* \";\nJCLC.38 = \"// ENDIF \";\nJCLC.39 = \"// \";\nHEADTAIL = TRUE;\n/* ****************** */\nCPKC   = \" O=MAXFREE,T=KEEP,V=NOCHANGE,CPKFREEX=10\";\nCPKNC  = \" O=MINEXTS,T=KEEP,V=NOCHANGE\";\n/* ****************** */\nSAY \"\";\nSAY \"****** INITIAL RESTORE 3390 UNIT:\" ,\n     INIT_REST_UNIT;\nSAY \"\";\nSUMM.SUMMCTR = \"****** INITIAL RESTORE 3390 UNIT:\" ,\n     INIT_REST_UNIT;\nSUMMCTR=SUMMCTR+1;\n/* LOOP */\nPOOLCTR=WORDS(ABRPOOLS);\nDO ZZ=1 TO POOLCTR;\nJOBC = SUBSTR(CLASSLIST,ZZ,1);\nPOOL=WORD(ABRPOOLS,ZZ);\nPOOLMEM=STRIP(SUBSTR(\"POOL\"POOL,1,8));\nDROP DUMP.;\nDROP INCR.;\nDROP REST.;\nDROP INIT.;\nDUMPCTR=1;\nINCRCTR=1;\nRESTCTR=1;\nINITCTR=1;\n\"FREE F(INIT)\";\n\"FREE F(DUMP)\";\n\"FREE F(INCR)\";\n\"FREE F(REST)\";\n\"ALLOC F(INIT) DA('SYSS.COMDISCO.INITJOBS(\"POOLMEM\")') SHR\";\nIF RC\u00ac=0 THEN EXIT 99;\nIF POOLMEM \u00ac=\"POOLSYSD\" & POOLMEM \u00ac=\"POOLSYST\" THEN DO;\n\"ALLOC F(DUMP) DA('SYSS.COMDISCO.DUMPJOBS(\"POOLMEM\")') SHR\";\nIF RC\u00ac=0 THEN EXIT 99;\nEND;\nIF POOLMEM \u00ac=\"POOLSYSD\" & POOLMEM \u00ac=\"POOLSYST\" THEN DO;\n\"ALLOC F(INCR) DA('SYSS.COMDISCO.INCRJOBS(\"POOLMEM\")') SHR\";\nIF RC\u00ac=0 THEN EXIT 99;\nEND;\nIF POOLMEM \u00ac=\"POOLSYSD\" & POOLMEM \u00ac=\"POOLSYST\" THEN DO;\n\"ALLOC F(REST) DA('SYSS.COMDISCO.RESTJOBS(\"POOLMEM\")') SHR\";\nIF RC\u00ac=0 THEN EXIT 99;\nEND;\nT1=OVERLAY(POOL,JCLX.1,POS('XXXX',JCLX.1));\nDO J = 1 TO 3;\n      IF J=1 THEN INCR.INCRCTR=T1;\n      ELSE INCR.INCRCTR=JCLX.J;\n      INCRCTR=INCRCTR+1;\nEND;\nXCTR=WORDS(POOLLIST.POOL);\nTRUEVOLC=0;\nDO I = 1 TO XCTR;\n  XVOL=WORD(POOLLIST.POOL,I);\n  TEMP_PACK1 = SUBSTR(XVOL,1,5);\n  TEMP_PACK2 = SUBSTR(XVOL,1,3);\n  IF TEMP_PACK1=\"SYSDA\" | TEMP_PACK1=\"SYSTA\" | TEMP_PACK2=\"DRV\" ,\n     | TEMP_PACK2=\"TEM\" | TEMP_PACK2=\"LAN\" THEN ITERATE;\n  IF XVOL=\"SYS015\" | XVOL=\"SYS007\" | XVOL=\"SYS008\" | XVOL=\"SYS011\" | ,\n     XVOL=\"SYS012\" | XVOL=\"SYS013\" | XVOL=\"SYS014\" THEN ITERATE;\n  TRUEVOLC=TRUEVOLC+1;\nEND;\n/* INCRCTR=INCRCTR+1 */;\nT2=OVERLAY(POOL,JCLX.8,POS('XXXX',JCLX.8));\nT3=OVERLAY(POOL,JCLX.9,POS('XXXX',JCLX.9));\nT4=OVERLAY(POOL,JCLX.10,POS('XXXX',JCLX.10));\nT5=OVERLAY(POOL,JCLX.37,POS('XXXX',JCLX.37));\nDO J = 4 TO JCLXSTP;\n      IF J=8 THEN INCR.INCRCTR=T2;\n      ELSE IF J=9 THEN INCR.INCRCTR=T3;\n      ELSE IF J=10 THEN INCR.INCRCTR=T4;\n      ELSE INCR.INCRCTR=JCLX.J;\n      /* TAPE CTR BY VOL CNT LOGIC */\n/*    IF TRUEVOLC>=9 & J=17 THEN ITERATE J;   */\n      IF TRUEVOLC>=9 THEN NOP;\n      ELSE IF TRUEVOLC>=4 & ,\n          (J=7 | J=10) THEN ITERATE J;\n      ELSE IF TRUEVOLC<4 & ,\n          (J=7 | J=10 | J=6 | J=9) THEN ITERATE J;\n      INCRCTR=INCRCTR+1;\n      IF TRUEVOLC>=9 & J=7 THEN DO;\n         INCR.INCRCTR=\"//SYSPRIN4 DD SYSOUT=*\";\n         INCRCTR=INCRCTR+1;\n/*       INCR.INCRCTR=\"//SYSPRIN5 DD SYSOUT=*\";\n         INCRCTR=INCRCTR+1;\n         INCR.INCRCTR=\"//SYSPRIN6 DD SYSOUT=*\";\n         INCRCTR=INCRCTR+1;    */\n      END;\n      IF TRUEVOLC>=9 & J=10 THEN DO;\n      POOLX = LEFT(POOL,4,\"X\"); /* FILL OUT */\nINCR.INCRCTR= ,\n \"//TAPE4 DD DSN=I4\"POOLX\",DISP=(,KEEP),UNIT=TA80,VOL=(,,,255)\"\n         INCRCTR=INCRCTR+1;\n/* INCR.INCRCTR= ,\n \"//TAPE5 DD DSN=I5\"POOLX\",DISP=(,KEEP),UNIT=TA80,VOL=(,,,255)\"\n         INCRCTR=INCRCTR+1;\nINCR.INCRCTR= ,\n \"//TAPE6 DD DSN=I6\"POOLX\",DISP=(,KEEP),UNIT=TA80,VOL=(,,,255)\"\n         INCRCTR=INCRCTR+1;     */\n      END;\nEND;\nXCTR=WORDS(POOLLIST.POOL);\nDO I = 1 TO XCTR;\n  XVOL=WORD(POOLLIST.POOL,I);\n  TEMP_PACK1 = SUBSTR(XVOL,1,5);\n  TEMP_PACK2 = SUBSTR(XVOL,1,3);\n  IF TEMP_PACK1=\"SYSDA\" | TEMP_PACK1=\"SYSTA\" | TEMP_PACK2=\"DRV\" ,\n     | TEMP_PACK2=\"TEM\" | TEMP_PACK2=\"LAN\" THEN ITERATE;\n  /* SKIP SOME INCR */\n  IF XVOL=\"SYS015\" | XVOL=\"SYS007\" | XVOL=\"SYS008\" | XVOL=\"SYS011\" | ,\n     XVOL=\"SYS012\" | XVOL=\"SYS013\" | XVOL=\"SYS014\" THEN ITERATE;\n  INCR.INCRCTR=\" MOUNT VOL=\"XVOL;\n  INCRCTR=INCRCTR+1;\nEND;\nJCLXHLD=JCLXSTP+1;\nDO J = JCLXHLD TO JCLX.0;\n   IF J=37 THEN INCR.INCRCTR=T5;\n   ELSE INCR.INCRCTR=JCLX.J;\n   INCRCTR=INCRCTR+1;\nEND;\nINCR.INCRCTR=\"//\";\n DO I = 1 TO DASDV.0;\n  CPK=FALSE;\n  PARSE VAR DASDV.I VOLSER CYLCOUNT FREECYL FRAGINDEX . ;\n  IF VOLSER=\"DUMMY\" THEN ITERATE;\n  IF WORDPOS(VOLSER,POOLLIST.POOL)=0 THEN ITERATE;/*DIFFERENT POOL*/\n  DEVTYPE = DASD.CYLCOUNT;\n  TRUE_DEVTYPE = DASD.CYLCOUNT;\n  IF HEADTAIL THEN DO;\n         HEADTAIL = FALSE; /* ROTATE CUU SELECTION */\n         UNIT = WORD(CDRS.DEVTYPE,1);\n         CDRS.DEVTYPE = DELWORD(CDRS.DEVTYPE,1,1);\n         END;\n  ELSE DO;\n         HEADTAIL = TRUE;  /* ROTATE CUU SELECTION */\n         IF WORDS(CDRS.DEVTYPE)=0 THEN ,\n              UNIT=\"\";\n         ELSE DO;\n           UNIT = WORD(CDRS.DEVTYPE,WORDS(CDRS.DEVTYPE));\n           IF UNIT\u00ac=\"F00\" THEN ,\n           CDRS.DEVTYPE = DELWORD(CDRS.DEVTYPE,WORDS(CDRS.DEVTYPE),1);\n           END;\n         END;\n  TARGET_TYPE=DEVTYPE;\n  IF UNIT=\"\" THEN DO; /* COMDISCO HAS NO MORE */\n       SELECT;\n         WHEN (DEVTYPE=\"3380DJ\") THEN TARGET_TYPE=\"3380E\";\n         WHEN (DEVTYPE=\"3380E\") THEN TARGET_TYPE=\"3380K\";\n         WHEN (DEVTYPE=\"3380K\") THEN EXIT 16; /* EMERGENCY */\n         WHEN (DEVTYPE=\"33902\") THEN TARGET_TYPE=\"33903\";\n         WHEN (DEVTYPE=\"33903\") THEN TARGET_TYPE=\"33906\";\n         WHEN (DEVTYPE=\"33906\") THEN EXIT 20; /* EMERGENCY */\n         OTHERWISE EXIT 24;\n       END;\n       IF TARGET_TYPE=\"3380E\" & WORDS(CDRS.3380E)=0 THEN ,\n            TARGET_TYPE=\"3380K\";\n       IF WORDS(CDRS.TARGET_TYPE)=0 THEN EXIT 28;\n       UNIT = WORD(CDRS.TARGET_TYPE,1);\n       IF UNIT\u00ac=\"F00\" THEN ,\n       CDRS.TARGET_TYPE = DELWORD(CDRS.TARGET_TYPE,1,1);\n       END;\n  DEVTYPE = SUBSTR(DEVTYPE,1,4);\n  TEMP_PACK1 = SUBSTR(VOLSER,1,5);\n  TEMP_PACK2 = SUBSTR(VOLSER,1,3);\n  IF TEMP_PACK1\u00ac=\"SYSDA\" & TEMP_PACK1\u00ac=\"SYSTA\" & TEMP_PACK2\u00ac=\"DRV\" ,\n     & TEMP_PACK2\u00ac=\"TEM\" & TEMP_PACK2\u00ac=\"LAN\" ,\n       THEN DO;\n  T1=OVERLAY(DEVTYPE,JCLD.6,POS('XXXX',JCLD.6));\n  T2=OVERLAY(VOLSER,JCLD.8,POS('XXXXXX',JCLD.8));\n  T3=OVERLAY(VOLSER,JCLD.1,POS('XXXXXX',JCLD.1));\n  T5=OVERLAY(VOLSER,JCLD.9,POS('XXXXXX',JCLD.9));\n  T10=OVERLAY(VOLSER,JCLD.35,POS('XXXXXX',JCLD.35));\n  T11=OVERLAY(VOLSER,JCLC.23,POS('XXXXXX',JCLC.23));\n  T12=OVERLAY(VOLSER,JCLC.32,POS('XXXXXX',JCLC.32));\n  T13=OVERLAY(VOLSER,JCLC.9,POS('XXXXXX',JCLC.9));\n  TSTVSR = SUBSTR(VOLSER,1,4)\n  IF TSTVSR = \"DB20\" THEN\n     T14=CPKNC\n  ELSE\n     T14=CPKC\n  CDSR= \"'FDRABR.COMDISCO.WEEKREST.V\"VOLSER\"'\";\n     \"ALTER\" CDSR \"OWNER(N)\";\n  IF RC > 0 THEN ,\n    \"DEFINE NVSAM (NAME(\"CDSR\") DEVT(0000) VOL('******') OWNER(N))\";\n  DO J = 1 TO JCLD.0;\n      IF J=6 THEN DUMP.DUMPCTR=T1;\n      ELSE IF J=8 THEN DUMP.DUMPCTR=T2;\n      ELSE IF J=1 THEN DUMP.DUMPCTR=T3;\n      ELSE IF J=9 THEN DUMP.DUMPCTR=T5;\n      ELSE IF J=35 THEN DUMP.DUMPCTR=T10;\n      ELSE IF J=18 & VOLSER=\"SYS015\" THEN ,\n         DUMP.DUMPCTR=\"  ENQ=OFF,\";\n      ELSE DUMP.DUMPCTR=JCLD.J;\n      FLAGIT = \"NO\"\n   /* CHANGE  */\n      INTERPRET 'IF 'VOLSER '=\"YES\" THEN FLAGIT = \"YES\"'\n      IF J=23 & FLAGIT=\"YES\" THEN CPK=TRUE;\n      ELSE IF J=23 THEN CPK=FALSE;\n      ELSE NOP;\n   /* CHANGE  */\n      IF J=40 & (CPK) THEN ITERATE J ;\n      ELSE NOP;\n      DUMPCTR=DUMPCTR+1;\n      IF (J=39) & (CPK) THEN DO;\n           DO Z=1 TO JCLC.0;\n                DUMP.DUMPCTR=JCLC.Z;\n    /* CHANGE */\n                IF Z=9  THEN DUMP.DUMPCTR= T13;\n                IF Z=12 THEN DUMP.DUMPCTR= T14;\n                IF Z=23 THEN DUMP.DUMPCTR= T11;\n                IF Z=32 THEN DUMP.DUMPCTR= T12;\n                DUMPCTR=DUMPCTR+1;\n           END;\n       END;\n  END;\n  T1=OVERLAY(DEVTYPE,JCLR.16,POS('XXXX',JCLR.16));\n  T1=OVERLAY(VOLSER,T1,POS('XXXXXX',T1));\n  T2=OVERLAY(VOLSER,JCLR.26,POS('XXXXXX',JCLR.26));\n  T3=OVERLAY(VOLSER,JCLR.1,POS('XXXXXX',JCLR.1));\n  T4=OVERLAY(VOLSER,JCLR.5,POS('XXXXXX',JCLR.5));\n  T5=OVERLAY(VOLSER,JCLR.34,POS('XXXXXX',JCLR.34));\n  T6=OVERLAY(VOLSER,JCLR.44,POS('XXXXXX',JCLR.44));\n  T7=OVERLAY(JOBC,JCLR.2,POS('?',JCLR.2));\n  DO J = 1 TO JCLR.0;\n      IF J=16 THEN REST.RESTCTR=T1;\n      ELSE IF J=26 THEN REST.RESTCTR=T2;\n      ELSE IF J=30 THEN REST.RESTCTR=T1;\n      ELSE IF J=34 THEN REST.RESTCTR=T5;\n      ELSE IF J=44 THEN REST.RESTCTR=T6;\n      ELSE IF J=5 THEN REST.RESTCTR=T4;\n      ELSE IF J=1 THEN REST.RESTCTR=T3;\n      ELSE IF J=2 THEN REST.RESTCTR=T7;\n      ELSE REST.RESTCTR=JCLR.J;\n      RESTCTR=RESTCTR+1;\n  END;\n  END;\n  T1=OVERLAY(UNIT,JCLI.6,POS('XXX',JCLI.6));\n  T2=OVERLAY(VOLSER,JCLI.7,POS('XXXXXX',JCLI.7));\n  T3=OVERLAY(VOLSER,JCLI.1,POS('XXXXXX',JCLI.1));\n IF UNIT\u00ac=\"F00\" THEN DO;\n  DO J = 1 TO JCLI.0;\n      IF J=6 THEN INIT.INITCTR=T1;\n      ELSE IF J=7 THEN INIT.INITCTR=T2;\n      ELSE IF J=1 THEN INIT.INITCTR=T3;\n      ELSE INIT.INITCTR=JCLI.J;\n      INITCTR=INITCTR+1;\n  END;\n END;\n IF UNIT\u00ac=\"F00\" THEN ,\n  SUMM.SUMMCTR = VOLSER \"TYPE\" LEFT(TRUE_DEVTYPE,6) \"MAPPED TO\",\n     \"CDRS UNIT\" UNIT \"TYPE\" TARGET_TYPE;\n ELSE ,\nSUMM.SUMMCTR=\"****** VOLUME\" VOLSER \"NOT INITIALIZED AND/OR RESTORED\";\n  IF VOLSER=\"SYS006\" THEN ,\n       SUMM.SUMMCTR=SUMM.SUMMCTR \"IPL LOADUNIT\" UNIT;\n  IF VOLSER=\"SYS001\" | VOLSER=\"SYS002\" THEN ,\n       SUMM.SUMMCTR=SUMM.SUMMCTR \"LOADPARM\" RIGHT(UNIT,4,\"0\")\"CDM\";\n  SUMMCTR=SUMMCTR+1;\n END I;\nIF POOLMEM \u00ac=\"POOLSYSD\" & POOLMEM \u00ac=\"POOLSYST\" THEN DO;\n \"EXECIO * DISKW DUMP (FINIS STEM DUMP.\";\n \"EXECIO * DISKW INCR (FINIS STEM INCR.\";\n \"EXECIO * DISKW REST (FINIS STEM REST.\";\nEND;\n \"EXECIO * DISKW INIT (FINIS STEM INIT.\";\nEND ZZ;\n\"EXECIO * DISKW SUMM (FINIS STEM SUMM.\";\nEXIT 0;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DASDBUL5": {"ttr": 9478, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\x00\\x00\\x94)\\x9f\\x00\\x95\\x02\\x1f\\x175\\x02b\\x02a\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf1\\xf0@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "1994-10-26T00:00:00", "modifydate": "1995-01-21T17:35:00", "lines": 610, "newlines": 609, "modlines": 0, "user": "TECH110"}, "text": "/* REXX DASD BUILD ANALYSIS */\nTRUE = \"1\";\nCNTCP = 1\nFALSE = \"0\";\nCPKCTR = 100;\nSUMMCTR=1;\nDASD.0885 = \"3380DJ\";\nDASD.1770 = \"3380E\";\nDASD.2655 = \"3380K\";\nDASD.2226 = \"33902\";\nDASD.3339 = \"33903\";\nDASD.6678 = \"33906\";\nCDRS.3380DJ = \"100 11F 200 21F\";\nCDRS.3380E  = \"480 49F\";\nCDRS.3380K  = \"C40 C5F F00 F00\";\nCDRS.33902  = \"3C0 3FF FC0 FFF\";\nCDRS.33903  = \"EC0 EFF 1C0 1FF 200 2FF\";\n/* CDRS.33903  = \"EC0 EFF 1C0 1FF\"; DUMMY RANGE ADDED 9/23 */\nCDRS.33906  = \"F00 F00\"; /* F00 IS END INDICATOR */\nCLASSLIST=\"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\n/* ALPHA LIST */\nABRPOOLS=\"ACIC APPL ART CICS DB2 EMC EMR MNT MVS PLAN \" || ,\n  \"POS PHYS QA RAMI SEQ SMSC SMS SYSDA SYSTA SYS TART TSO \" || ,\n  \"UART USER VSAM\";\n/* LIST BY IMP */\nABRPOOLSR=\"SYS CICS EMC DB2 SMS VSAM ART ACIC UART APPL EMR \" || ,\n  \"MVS PLAN POS QA RAMI SEQ PHYS SMSC TSO USER MNT TART\";\nTEMP = \"\";\nDO I = 1 TO WORDS(CDRS.3380DJ) BY 2;\n  LLIM = X2D(WORD(CDRS.3380DJ,I));\n  HLIM = X2D(WORD(CDRS.3380DJ,I+1));\n     DO J = LLIM TO HLIM;\n        TEMP = TEMP D2X(J);\n     END;\nEND;\nCDRS.3380DJ = TEMP;\nTEMP = \"\";\nDO I = 1 TO WORDS(CDRS.3380E) BY 2;\n  LLIM = X2D(WORD(CDRS.3380E,I));\n  HLIM = X2D(WORD(CDRS.3380E,I+1));\n     DO J = LLIM TO HLIM;\n        TEMP = TEMP D2X(J);\n     END;\nEND;\nCDRS.3380E = TEMP;\nTEMP = \"\";\nDO I = 1 TO WORDS(CDRS.3380K) BY 2;\n  LLIM = X2D(WORD(CDRS.3380K,I));\n  HLIM = X2D(WORD(CDRS.3380K,I+1));\n     DO J = LLIM TO HLIM;\n        TEMP = TEMP D2X(J);\n     END;\nEND;\nCDRS.3380K = TEMP;\nTEMP = \"\";\nDO I = 1 TO WORDS(CDRS.33902) BY 2;\n  LLIM = X2D(WORD(CDRS.33902,I));\n  HLIM = X2D(WORD(CDRS.33902,I+1));\n     DO J = LLIM TO HLIM;\n        TEMP = TEMP D2X(J);\n     END;\nEND;\nCDRS.33902 = TEMP;\nTEMP = \"\";\nDO I = 1 TO WORDS(CDRS.33903) BY 2;\n  LLIM = X2D(WORD(CDRS.33903,I));\n  HLIM = X2D(WORD(CDRS.33903,I+1));\n     DO J = LLIM TO HLIM;\n        TEMP = TEMP D2X(J);\n     END;\nEND;\nCDRS.33903 = TEMP;\nTEMP = \"\";\nDO I = 1 TO WORDS(CDRS.33906) BY 2;\n  LLIM = X2D(WORD(CDRS.33906,I));\n  HLIM = X2D(WORD(CDRS.33906,I+1));\n     DO J = LLIM TO HLIM;\n        TEMP = TEMP D2X(J);\n     END;\nEND;\nCDRS.33906 = TEMP;\nINIT_REST_UNIT = WORD(CDRS.33902,1);\nCDRS.33902 = DELWORD(CDRS.33902,1,1);\n\"CALL 'SYS1.TECH.COMMON.LOADLIB(DASDSCAN)'\";\n/* \"CALL 'TECH110.USER.LOADLIB(DASDSCAN)'\"; */\nSAVERC=RC;\nIF SAVERC\u00ac=0 THEN EXIT SAVERC;\n\"EXECIO * DISKR WORK (FINIS STEM DASDV.\";\nCHANGES = TRUE;\nDO WHILE(CHANGES); /* BUBBLE SORT DESCENDING BY FRAG INDEX */\n     CHANGES = FALSE;\n     DO I = 1 TO DASDV.0-1;\n          J = I+1;\n          PARSE VAR DASDV.I . . . FRAGINDEX1 . ;\n          PARSE VAR DASDV.J . . . FRAGINDEX2 . ;\n          IF FRAGINDEX1 < FRAGINDEX2 THEN DO;\n                 TEMP = DASDV.I;\n                 DASDV.I = DASDV.J;\n                 DASDV.J = TEMP;\n                 CHANGES = TRUE;\n                 END;\n     END;\nEND;\nFLAG_CNT=1\nDO I = 1 TO DASDV.0;\n  PARSE VAR DASDV.I VOLSER CYLCOUNT FREECYL FRAGINDEX . ;\n  ABR_BACKUP_DSN = \"'FDRABR.V\"VOLSER\"'\";\n  DUMMY = LISTDSI(ABR_BACKUP_DSN); /* SEE IF DATASET EXISTS */\n  IF DUMMY\u00ac=0 THEN DO;\n       DASDV.I = \"DUMMY\"; /* IGNORE THIS VOLUME */\n       ITERATE I; /* LOOP */\n       END;\n/*** CPK SELECTION *****/\n  TSTVSR = SUBSTR(VOLSER,1,4)\n  INTERPRET VOLSER '= \"NO\"'\n  IF TSTVSR = \"APPL\" |,\n     TSTVSR = \"PLAN\" |,\n     TSTVSR = \"POS0\" |,\n     TSTVSR = \"TSO0\" |,\n     TSTVSR = \"USER\" |,\n     TSTVSR = \"QA00\" |,\n     TSTVSR = \"PHYS\" |,\n     TSTVSR = \"VSAM\" |,\n     TSTVSR = \"CICS\" |,\n     TSTVSR = \"DB20\" |,\n     TSTVSR = \"SEQD\" |,\n     TSTVSR = \"UART\" |,\n     TSTVSR = \"ARTH\" |,\n     TSTVSR = \"RAMI\" |,\n     TSTVSR = \"SMSU\" |,\n     TSTVSR = \"SMSC\" |,\n     TSTVSR = \"EMRG\" THEN DO\n     INTERPRET VOLSER '= \"YES\"'\n     END\n/***********************/\n  POOLCTR=WORDS(ABRPOOLS);\n  DO J=1 TO POOLCTR;\n     POOL=WORD(ABRPOOLS,J);\n     IF ABBREV(VOLSER,POOL) THEN DO;\n           IF SYMBOL('POOLLIST.POOL')=\"VAR\" THEN ,\n               POOLLIST.POOL=POOLLIST.POOL VOLSER;\n            ELSE POOLLIST.POOL=VOLSER;\n          LEAVE J;\n         END;\n  END;\nEND;\nABRPOOLS = ABRPOOLSR; /* REORG LIST FOR ORDER TO PROCESS IN */\nDO J=1 TO POOLCTR;\n     POOL=WORD(ABRPOOLS,J);\n     VOLCNT=WORDS(POOLLIST.POOL);\n     JOBC=SUBSTR(CLASSLIST,J,1);\nSUMM.SUMMCTR=\"****** POOL\" LEFT(POOL,7) \"RESTORE JOBCLASS:\" JOBC ,\n        \"VOLCNT:\" VOLCNT;\n     SUMMCTR=SUMMCTR+1;\nEND;\nJCLD.0 = 40; /* COUNT OF DUMP JOB STATEMENTS */\nJCLD.1 = \"//D$XXXXXX JOB 530401053000,'SYSTEM.BACKUP',\";\nJCLD.2 = \"// NOTIFY=TECH251,CLASS=S,MSGCLASS=G\";\nJCLD.3  = \"//DUMPIT EXEC PGM=FDRABR,REGION=9000K\";\nJCLD.4  = \"//SYSPRINT DD SYSOUT=*\";\nJCLD.5  = \"//SYSPRIN1 DD SYSOUT=*\";\nJCLD.6  = \"//DISK1 DD UNIT=XXXX,\";\nJCLD.7  = \"// DISP=SHR,\";\nJCLD.8  = \"// VOL=SER=XXXXXX\";\nJCLD.9 =\"//TAPE1 DD DSN=FXXXXXX,DISP=(,KEEP),UNIT=TA80,VOL=(,,,255)\";\nJCLD.10 = \"//SYSUDUMP DD SYSOUT=X\";\nJCLD.11 = \"//SYSIN DD *\";\nJCLD.12 = \" DUMP TYPE=FDR,\";\nJCLD.13 = \"  AUTOUPD=YES,\";\nJCLD.14 = \"  BUFNO=MAX,\";\nJCLD.15 = \"  COMPRESS=ALL,\";\nJCLD.16 = \"  DATA=ALL,\";\nJCLD.17 = \"  DATEP=NONE,\";\nJCLD.18 = \"  DSNENQ=TEST,\";\nJCLD.19 = \"  ENQ=RESERVE,\";\nJCLD.20 = \"  ENQERR=NO,\";\nJCLD.21 = \"  ENQERR=PROCESS,\";\nJCLD.22 = \"  FORMAT=NEW,\";\nJCLD.23 = \"  LBPZERO=INVALID,\";\nJCLD.24 = \"  MAXERR=1,\";\nJCLD.25 = \"  PRINT=ABR,\";\nJCLD.26 = \"  RETPD=9999,\";\nJCLD.27 = \"  SMSCONSTRUCT=NO,\";\nJCLD.28 = \"  SMSMANAGE=NO\";\nJCLD.29 = \"/*\";\nJCLD.30 = \"// IF (DUMPIT.RC>4 | DUMPIT.ABEND=TRUE) THEN\";\nJCLD.31 = \"//DUMPFAIL EXEC WTO\";\nJCLD.32 = \"//SYSIN    DD *\";\nJCLD.33 = \" *** WARNING\";\nJCLD.34 = \" ** \";\nJCLD.35 = \" ** ERROR DURING FULL VOLUME BACKUP OF VOL > XXXXXX <.\";\nJCLD.36 = \" ** \";\nJCLD.37 = \" *** WARNING \";\nJCLD.38 = \"/*\";\nJCLD.39 = \"// ENDIF\";\nJCLD.40 = \"//\";\nJCLX.0 = 41; /* COUNT OF INCR JOB STATEMENTS */\nJCLX.1 = \"//I$XXXX JOB 530401053000,'SYSTEM.BACKUP',\";\nJCLX.2 = \"// NOTIFY=TECH251,\";\nJCLX.3 = \"// CLASS=S,MSGCLASS=G\";\nJCLX.4 = \"//DUMPIT EXEC PGM=FDRABR,REGION=9000K\";\nJCLX.5 = \"//SYSPRIN1 DD SYSOUT=*\";\nJCLX.6 = \"//SYSPRIN2 DD SYSOUT=*\";\nJCLX.7 = \"//SYSPRIN3 DD SYSOUT=*\";\nJCLX.8=\"//TAPE1 DD DSN=I1XXXX,DISP=(,KEEP),UNIT=TA80,VOL=(,,,255)\";\nJCLX.9=\"//TAPE2 DD DSN=I2XXXX,DISP=(,KEEP),UNIT=TA80,VOL=(,,,255)\";\nJCLX.10=\"//TAPE3 DD DSN=I3XXXX,DISP=(,KEEP),UNIT=TA80,VOL=(,,,255)\";\nJCLX.11= \"//SYSPRINT DD SYSOUT=*\";\nJCLX.12 = \"//SYSUDUMP DD SYSOUT=X\";\nJCLX.13 = \"//SYSIN DD *\";\nJCLX.14 = \" DUMP TYPE=ABR,\";\nJCLX.15 = \"  AUTOUPD=YES,\";\nJCLX.16 = \"  BUFNO=MAX,\";\nJCLX.17 = \"  COMPRESS=ALL,\";\nJCLX.18 = \"  DATA=USED,\";\nJCLX.19 = \"  DATEP=NONE,\";\nJCLX.20 = \"  DSNENQ=TEST,\";\nJCLX.21 = \"  ENQ=RESERVE,\";\nJCLX.22 = \"  ENQERR=NO,\";\nJCLX.23 = \"  ENQERR=PROCESS,\";\nJCLX.24 = \"  FORMAT=NEW,\";\nJCLX.25 = \"  LBPZERO=INVALID,\";\nJCLX.26 = \"  MAXERR=1,\";\nJCLX.27 = \"  PRINT=ABR,\";\nJCLX.28 = \"  RETPD=9999,\";\nJCLX.29 = \"  SMSCONSTRUCT=NO,\";\nJCLX.30 = \"  SMSMANAGE=NO\";\nJCLXSTP = 30\nJCLY.4  = \"//DUMPIT EXEC PGM=FDRABR,REGION=9000K\";\n/* ********* 30 *********** */\nJCLX.31 = \"/*\";\nJCLX.32 = \"// IF (DUMPIT.RC>4 | DUMPIT.ABEND=TRUE) THEN\";\nJCLX.33 = \"//DUMPFAIL EXEC WTO\";\nJCLX.34 = \"//SYSIN    DD * \";\nJCLX.35 = \" *** WARNING\";\nJCLX.36 = \" ** \";\nJCLX.37 = \" ** ERROR DURING INCREMENTAL BACKUP OF VOL GROUP > XXXX <.\";\nJCLX.38 = \" ** \";\nJCLX.39 = \" *** WARNING\";\nJCLX.40 = \"/*\";\nJCLX.41 = \"// ENDIF\";\nJCLR.0 = 47; /* COUNT OF RESTORE JOB STATEMENTS */\nJCLR.1 = \"//R$XXXXXX JOB 530401053000,'TECH SUPPRT',\";\nJCLR.2 = \"// CLASS=?,MSGCLASS=X,MSGLEVEL=(1,1),REGION=6M\";\nJCLR.3 = \"//JOBLIB DD DSN=IMPORT.LINKLIB1,DISP=SHR\";\nJCLR.4 = \"//ACTIVE EXEC PGM=IKJEFT01,REGION=6M,\";\nJCLR.5 = \"// PARM='ALTER ''FDRABR.COMDISCO.WEEKREST.VXXXXXX'' OWNER(I)'\"\nJCLR.6 = \"//SYSTSPRT DD SYSOUT=*\";\nJCLR.7 = \"//SYSTSIN DD DUMMY\";\nJCLR.8 = \"//*\";\nJCLR.9 = \"//*\";\nJCLR.10 = \"//*\";\nJCLR.11 = \"//*\";\nJCLR.12 = \"//*\";\nJCLR.13 = \"//RESTIT EXEC PGM=FDRABR,REGION=6M\";\nJCLR.14 = \"//SYSPRINT DD SYSOUT=*\";\nJCLR.15 = \"//ABRWORK  DD UNIT=SYSALLDA,SPACE=(CYL,(2,1))\";\nJCLR.16 = \"//DISK1 DD UNIT=XXXX,VOL=SER=XXXXXX,DISP=OLD\";\nJCLR.17 = \"//SYSIN DD *\";\nJCLR.18 = \" RESTORE TYPE=FDR,\";\nJCLR.19 = \"   CONFMESS=NO,\";\nJCLR.20 = \"   COPY=1,\";\nJCLR.21 = \"  CPYVOLID=YES,\";\nJCLR.22 = \"  DYNTAPE,\";\nJCLR.23 = \"  MAXERR=1,\";\nJCLR.24 = \"  SMSPROT=NONE,\";\nJCLR.25 = \"  VOLRESET=NO\";\nJCLR.26 = \" SELECT  VOL=XXXXXX,GEN=CURRENT\";\nJCLR.27 = \"/*\";\nJCLR.28 = \"//IXITIT EXEC PGM=ICKDSF,REGION=6M\";\nJCLR.29 = \"//SYSPRINT DD SYSOUT=*\";\nJCLR.30 = \"//DISK1 DD UNIT=XXXX,VOL=SER=XXXXXX,DISP=OLD\";\nJCLR.31 = \"//SYSIN DD *\";\nJCLR.32=\" BUILDIX DDNAME(DISK1) IXVTOC\";\nJCLR.33 = \"//COMPLETE EXEC PGM=IKJEFT01,COND=(0,NE,RESTIT),\";\nJCLR.34=\"// PARM='ALTER ''FDRABR.COMDISCO.WEEKREST.VXXXXXX'' OWNER(C)'\"\nJCLR.35 = \"//SYSTSPRT DD SYSOUT=*\";\nJCLR.36 = \"//SYSTSIN DD DUMMY\";\nJCLR.37 = \"//*\";\nJCLR.38 = \"//*\";\nJCLR.39 = \"//*\";\nJCLR.40 = \"//*\";\nJCLR.41 = \"//*\";\nJCLR.42 = \"//*\";\nJCLR.43 = \"//FAILURE EXEC PGM=IKJEFT01,COND=((0,GE,RESTIT),EVEN),\";\nJCLR.44=\"// PARM='ALTER ''FDRABR.COMDISCO.WEEKREST.VXXXXXX'' OWNER(F)'\"\nJCLR.45 = \"//SYSTSPRT DD SYSOUT=*\";\nJCLR.46 = \"//SYSTSIN DD DUMMY\";\nJCLR.47 = \"//\";\nJCLI.0 = 8; /* COUNT OF INIT JOB STATEMENTS */\nJCLI.1 = \"//I$XXXXXX JOB 530401053000,'TECH SUPPRT',NOTIFY=$CDRS1,\";\nJCLI.2 = \"// CLASS=A,MSGCLASS=X,MSGLEVEL=(1,1)\";\nJCLI.3 = \"//INITIT EXEC PGM=ICKDSF,REGION=6M\";\nJCLI.4 = \"//SYSPRINT DD SYSOUT=*\";\nJCLI.5 = \"//SYSIN DD *\";\nJCLI.6=\" INIT UNIT(XXX) NVFY NCHK INDEX(1,0,15) VTOC(0,1,14) -\";\nJCLI.7 = \"   NOMAP PRG NVAL VOLID(XXXXXX)\";\nJCLI.8 = \"//\";\nJCLC.0 = 39; /* COMPAKTOR */\nJCLC.1 = \"// IF (DUMPIT.RC<=4 & \u00acDUMPIT.ABEND=TRUE) THEN\";\nJCLC.2 = \"//CPKIT  EXEC PGM=FDRCPK,REGION=9000K\";\nJCLC.3 = \"//STEPLIB  DD DSN=SYS1.FDR.V5R2M33.LOADLIB,DISP=SHR\";\nJCLC.4 = \"//SYSPRINT DD SYSOUT=*\";\nJCLC.5 = \"//SYSMAP   DD SYSOUT=*\";\nJCLC.6 = \"//SYSSUMM  DD SYSOUT=*\";\nJCLC.7 = \"//SYSUDUMP DD SYSOUT=X\";\nJCLC.8 = \"//SYSIN DD *\";\nJCLC.9 = \" CPK TYPE=FASTCPK,VOL=(XXXXXX),ACTMESS=NO,CONFMESS=NO,\";\nJCLC.10= \" HI=NO,MAPS=SUMMARY,NOSECOND=NORLSE,ENQ=RESERVE,DSNENQ=USE,\";\nJCLC.11 = \" PSRLSE=ALL,UNABLE=IGNORE,SIZEKEEP=(,,,10000),\";\nJCLC.12 = \" O=MAXFREE,T=KEEP,V=NOCHANGE,CPKFREEX=10\";\nJCLC.13 = \"/*\";\nJCLC.14 = \"// ENDIF\";\nJCLC.15 = \"//*\";\nJCLC.16 = \"// IF (CPKIT.RC>0 | CPKIT.ABEND=TRUE) THEN\";\nJCLC.17 = \"//MAPIT    EXEC PGM=FDRCPK\";\nJCLC.18 = \"//TAPE1    DD DUMMY\";\nJCLC.19 = \"//SYSMAP   DD SYSOUT=*\";\nJCLC.20 = \"//SYSPRINT DD SYSOUT=*\";\nJCLC.21 = \"//SYSUDUMP DD SYSOUT=*\";\nJCLC.22 = \"//SYSIN    DD *\";\nJCLC.23 = \"   MAP VOL=XXXXXX,MAPS=SUMMARY \";\nJCLC.24 = \"/*\";\nJCLC.25 = \"// ENDIF \";\nJCLC.26 = \"// IF (MAPIT.RC>0 | MAPIT.ABEND=TRUE) THEN\";\nJCLC.27 = \"//CPKFAIL  EXEC WTO\";\nJCLC.28 = \"//SYSIN    DD * \";\nJCLC.29 = \" *** WARNING \";\nJCLC.30 = \" ** \";\nJCLC.31 = \" ** AN ERROR HAS OCCURRED DURING THE COMPACTION OF\";\nJCLC.32 = \" ** VOLUME > XXXXXX <. THIS PROBLEM MUST BE RESOLVED\";\nJCLC.33 = \" ** BEFORE THE SCHEDULE CONTINUES. CONTACT TECH SUPPORT\";\nJCLC.34 = \" ** PERSON ON CALL.\";\nJCLC.35 = \" ** \";\nJCLC.36 = \" *** WARNING \";\nJCLC.37 = \"/* \";\nJCLC.38 = \"// ENDIF \";\nJCLC.39 = \"// \";\nHEADTAIL = TRUE;\n/* ****************** */\nCPKC   = \" O=MAXFREE,T=KEEP,V=NOCHANGE,CPKFREEX=10\";\nCPKNC  = \" O=MINEXTS,T=KEEP,V=NOCHANGE\";\n/* ****************** */\nSAY \"\";\nSAY \"****** INITIAL RESTORE 3390 UNIT:\" ,\n     INIT_REST_UNIT;\nSAY \"\";\nSUMM.SUMMCTR = \"****** INITIAL RESTORE 3390 UNIT:\" ,\n     INIT_REST_UNIT;\nSUMMCTR=SUMMCTR+1;\n/* LOOP */\nPOOLCTR=WORDS(ABRPOOLS);\nDO ZZ=1 TO POOLCTR;\nJOBC = SUBSTR(CLASSLIST,ZZ,1);\nPOOL=WORD(ABRPOOLS,ZZ);\nPOOLMEM=STRIP(SUBSTR(\"POOL\"POOL,1,8));\nDROP DUMP.;\nDROP INCR.;\nDROP REST.;\nDROP INIT.;\nDUMPCTR=1;\nINCRCTR=1;\nRESTCTR=1;\nINITCTR=1;\n\"FREE F(INIT)\";\n\"FREE F(DUMP)\";\n\"FREE F(INCR)\";\n\"FREE F(REST)\";\n\"ALLOC F(INIT) DA('SYSS.COMDISCO.INITJOBS(\"POOLMEM\")') SHR\";\nIF RC\u00ac=0 THEN EXIT 99;\nIF POOLMEM \u00ac=\"POOLSYSD\" & POOLMEM \u00ac=\"POOLSYST\" THEN DO;\n\"ALLOC F(DUMP) DA('SYSS.COMDISCO.DUMPJOBS(\"POOLMEM\")') SHR\";\nIF RC\u00ac=0 THEN EXIT 99;\nEND;\nIF POOLMEM \u00ac=\"POOLSYSD\" & POOLMEM \u00ac=\"POOLSYST\" THEN DO;\n\"ALLOC F(INCR) DA('SYSS.COMDISCO.INCRJOBS(\"POOLMEM\")') SHR\";\nIF RC\u00ac=0 THEN EXIT 99;\nEND;\nIF POOLMEM \u00ac=\"POOLSYSD\" & POOLMEM \u00ac=\"POOLSYST\" THEN DO;\n\"ALLOC F(REST) DA('SYSS.COMDISCO.RESTJOBS(\"POOLMEM\")') SHR\";\nIF RC\u00ac=0 THEN EXIT 99;\nEND;\nT1=OVERLAY(POOL,JCLX.1,POS('XXXX',JCLX.1));\nDO J = 1 TO 3;\n      IF J=1 THEN INCR.INCRCTR=T1;\n      ELSE INCR.INCRCTR=JCLX.J;\n      INCRCTR=INCRCTR+1;\nEND;\nXCTR=WORDS(POOLLIST.POOL);\nTRUEVOLC=0;\nDO I = 1 TO XCTR;\n  XVOL=WORD(POOLLIST.POOL,I);\n  TEMP_PACK1 = SUBSTR(XVOL,1,5);\n  TEMP_PACK2 = SUBSTR(XVOL,1,3);\n  IF TEMP_PACK1=\"SYSDA\" | TEMP_PACK1=\"SYSTA\" | TEMP_PACK2=\"DRV\" ,\n     | TEMP_PACK2=\"TEM\" | TEMP_PACK2=\"LAN\" THEN ITERATE;\n  IF XVOL=\"SYS015\" | XVOL=\"SYS007\" | XVOL=\"SYS008\" | XVOL=\"SYS011\" | ,\n     XVOL=\"SYS012\" | XVOL=\"SYS013\" | XVOL=\"SYS014\" THEN ITERATE;\n  TRUEVOLC=TRUEVOLC+1;\nEND;\n/* INCRCTR=INCRCTR+1 */;\nT2=OVERLAY(POOL,JCLX.8,POS('XXXX',JCLX.8));\nT3=OVERLAY(POOL,JCLX.9,POS('XXXX',JCLX.9));\nT4=OVERLAY(POOL,JCLX.10,POS('XXXX',JCLX.10));\nT5=OVERLAY(POOL,JCLX.37,POS('XXXX',JCLX.37));\nIF (POOL=\"SYS\" | POOL=\"ART\") THEN T6=JCLY.4;\nELSE T6=JCLX.4;\nDO J = 4 TO JCLXSTP;\n      IF J=4 THEN INCR.INCRCTR=T6;\n      ELSE IF J=8 THEN INCR.INCRCTR=T2;\n      ELSE IF J=9 THEN INCR.INCRCTR=T3;\n      ELSE IF J=10 THEN INCR.INCRCTR=T4;\n      ELSE INCR.INCRCTR=JCLX.J;\n      /* TAPE CTR BY VOL CNT LOGIC */\n/*    IF TRUEVOLC>=9 & J=17 THEN ITERATE J;   */\n      IF TRUEVOLC>=9 THEN NOP;\n      ELSE IF TRUEVOLC>=4 & ,\n          (J=7 | J=10) THEN ITERATE J;\n      ELSE IF TRUEVOLC<4 & ,\n          (J=7 | J=10 | J=6 | J=9) THEN ITERATE J;\n      INCRCTR=INCRCTR+1;\n      IF TRUEVOLC>=9 & J=7 THEN DO;\n         INCR.INCRCTR=\"//SYSPRIN4 DD SYSOUT=*\";\n         INCRCTR=INCRCTR+1;\n/*       INCR.INCRCTR=\"//SYSPRIN5 DD SYSOUT=*\";\n         INCRCTR=INCRCTR+1;\n         INCR.INCRCTR=\"//SYSPRIN6 DD SYSOUT=*\";\n         INCRCTR=INCRCTR+1;    */\n      END;\n      IF TRUEVOLC>=9 & J=10 THEN DO;\n      POOLX = LEFT(POOL,4,\"X\"); /* FILL OUT */\nINCR.INCRCTR= ,\n \"//TAPE4 DD DSN=I4\"POOLX\",DISP=(,KEEP),UNIT=TA80,VOL=(,,,255)\"\n         INCRCTR=INCRCTR+1;\n/* INCR.INCRCTR= ,\n \"//TAPE5 DD DSN=I5\"POOLX\",DISP=(,KEEP),UNIT=TA80,VOL=(,,,255)\"\n         INCRCTR=INCRCTR+1;\nINCR.INCRCTR= ,\n \"//TAPE6 DD DSN=I6\"POOLX\",DISP=(,KEEP),UNIT=TA80,VOL=(,,,255)\"\n         INCRCTR=INCRCTR+1;     */\n      END;\nEND;\nXCTR=WORDS(POOLLIST.POOL);\nDO I = 1 TO XCTR;\n  XVOL=WORD(POOLLIST.POOL,I);\n  TEMP_PACK1 = SUBSTR(XVOL,1,5);\n  TEMP_PACK2 = SUBSTR(XVOL,1,3);\n  IF TEMP_PACK1=\"SYSDA\" | TEMP_PACK1=\"SYSTA\" | TEMP_PACK2=\"DRV\" ,\n     | TEMP_PACK2=\"TEM\" | TEMP_PACK2=\"LAN\" THEN ITERATE;\n  /* SKIP SOME INCR */\n  IF XVOL=\"SYS015\" | XVOL=\"SYS007\" | XVOL=\"SYS008\" | XVOL=\"SYS011\" | ,\n     XVOL=\"SYS012\" | XVOL=\"SYS013\" | XVOL=\"SYS014\" THEN ITERATE;\n  INCR.INCRCTR=\" MOUNT VOL=\"XVOL;\n  INCRCTR=INCRCTR+1;\nEND;\nJCLXHLD=JCLXSTP+1;\nDO J = JCLXHLD TO JCLX.0;\n   IF J=37 THEN INCR.INCRCTR=T5;\n   ELSE INCR.INCRCTR=JCLX.J;\n   INCRCTR=INCRCTR+1;\nEND;\nINCR.INCRCTR=\"//\";\n DO I = 1 TO DASDV.0;\n  CPK=FALSE;\n  PARSE VAR DASDV.I VOLSER CYLCOUNT FREECYL FRAGINDEX . ;\n  IF VOLSER=\"DUMMY\" THEN ITERATE;\n  IF WORDPOS(VOLSER,POOLLIST.POOL)=0 THEN ITERATE;/*DIFFERENT POOL*/\n  DEVTYPE = DASD.CYLCOUNT;\n  TRUE_DEVTYPE = DASD.CYLCOUNT;\n  IF HEADTAIL THEN DO;\n         HEADTAIL = FALSE; /* ROTATE CUU SELECTION */\n         UNIT = WORD(CDRS.DEVTYPE,1);\n         CDRS.DEVTYPE = DELWORD(CDRS.DEVTYPE,1,1);\n         END;\n  ELSE DO;\n         HEADTAIL = TRUE;  /* ROTATE CUU SELECTION */\n         IF WORDS(CDRS.DEVTYPE)=0 THEN ,\n              UNIT=\"\";\n         ELSE DO;\n           UNIT = WORD(CDRS.DEVTYPE,WORDS(CDRS.DEVTYPE));\n           IF UNIT\u00ac=\"F00\" THEN ,\n           CDRS.DEVTYPE = DELWORD(CDRS.DEVTYPE,WORDS(CDRS.DEVTYPE),1);\n           END;\n         END;\n  TARGET_TYPE=DEVTYPE;\n  IF UNIT=\"\" THEN DO; /* COMDISCO HAS NO MORE */\n       SELECT;\n         WHEN (DEVTYPE=\"3380DJ\") THEN TARGET_TYPE=\"3380E\";\n         WHEN (DEVTYPE=\"3380E\") THEN TARGET_TYPE=\"3380K\";\n         WHEN (DEVTYPE=\"3380K\") THEN EXIT 16; /* EMERGENCY */\n         WHEN (DEVTYPE=\"33902\") THEN TARGET_TYPE=\"33903\";\n         WHEN (DEVTYPE=\"33903\") THEN TARGET_TYPE=\"33906\";\n         WHEN (DEVTYPE=\"33909\") THEN TARGET_TYPE=\"33906\";\n         WHEN (DEVTYPE=\"33906\") THEN EXIT 20; /* EMERGENCY */\n         OTHERWISE EXIT 24;\n       END;\n       IF TARGET_TYPE=\"3380E\" & WORDS(CDRS.3380E)=0 THEN ,\n            TARGET_TYPE=\"3380K\";\n       IF WORDS(CDRS.TARGET_TYPE)=0 THEN EXIT 28;\n       UNIT = WORD(CDRS.TARGET_TYPE,1);\n       IF UNIT\u00ac=\"F00\" THEN ,\n       CDRS.TARGET_TYPE = DELWORD(CDRS.TARGET_TYPE,1,1);\n       END;\n  DEVTYPE = SUBSTR(DEVTYPE,1,4);\n  TEMP_PACK1 = SUBSTR(VOLSER,1,5);\n  TEMP_PACK2 = SUBSTR(VOLSER,1,3);\n  IF TEMP_PACK1\u00ac=\"SYSDA\" & TEMP_PACK1\u00ac=\"SYSTA\" & TEMP_PACK2\u00ac=\"DRV\" ,\n     & TEMP_PACK2\u00ac=\"TEM\" & TEMP_PACK2\u00ac=\"LAN\" ,\n       THEN DO;\n  T1=OVERLAY(DEVTYPE,JCLD.6,POS('XXXX',JCLD.6));\n  T2=OVERLAY(VOLSER,JCLD.8,POS('XXXXXX',JCLD.8));\n  T3=OVERLAY(VOLSER,JCLD.1,POS('XXXXXX',JCLD.1));\n  T5=OVERLAY(VOLSER,JCLD.9,POS('XXXXXX',JCLD.9));\n  T10=OVERLAY(VOLSER,JCLD.35,POS('XXXXXX',JCLD.35));\n  T11=OVERLAY(VOLSER,JCLC.23,POS('XXXXXX',JCLC.23));\n  T12=OVERLAY(VOLSER,JCLC.32,POS('XXXXXX',JCLC.32));\n  T13=OVERLAY(VOLSER,JCLC.9,POS('XXXXXX',JCLC.9));\n  TSTVSR = SUBSTR(VOLSER,1,4)\n  IF TSTVSR = \"DB20\" THEN\n     T14=CPKNC\n  ELSE\n     T14=CPKC\n  CDSR= \"'FDRABR.COMDISCO.WEEKREST.V\"VOLSER\"'\";\n     \"ALTER\" CDSR \"OWNER(N)\";\n  IF RC > 0 THEN ,\n    \"DEFINE NVSAM (NAME(\"CDSR\") DEVT(0000) VOL('******') OWNER(N))\";\n  DO J = 1 TO JCLD.0;\n      IF J=6 THEN DUMP.DUMPCTR=T1;\n      ELSE IF J=8 THEN DUMP.DUMPCTR=T2;\n      ELSE IF J=1 THEN DUMP.DUMPCTR=T3;\n      ELSE IF J=9 THEN DUMP.DUMPCTR=T5;\n      ELSE IF J=35 THEN DUMP.DUMPCTR=T10;\n      ELSE IF J=18 & VOLSER=\"SYS015\" THEN ,\n         DUMP.DUMPCTR=\"  ENQ=OFF,\";\n      ELSE DUMP.DUMPCTR=JCLD.J;\n      FLAGIT = \"NO\"\n   /* CHANGE  */\n      INTERPRET 'IF 'VOLSER '=\"YES\" THEN FLAGIT = \"YES\"'\n      IF J=23 & FLAGIT=\"YES\" THEN CPK=TRUE;\n      ELSE IF J=23 THEN CPK=FALSE;\n      ELSE NOP;\n   /* CHANGE  */\n      IF J=40 & (CPK) THEN ITERATE J ;\n      ELSE NOP;\n      DUMPCTR=DUMPCTR+1;\n      IF (J=39) & (CPK) THEN DO;\n           DO Z=1 TO JCLC.0;\n                DUMP.DUMPCTR=JCLC.Z;\n    /* CHANGE */\n                IF Z=9  THEN DUMP.DUMPCTR= T13;\n                IF Z=12 THEN DUMP.DUMPCTR= T14;\n                IF Z=23 THEN DUMP.DUMPCTR= T11;\n                IF Z=32 THEN DUMP.DUMPCTR= T12;\n                DUMPCTR=DUMPCTR+1;\n           END;\n       END;\n  END;\n  T1=OVERLAY(DEVTYPE,JCLR.16,POS('XXXX',JCLR.16));\n  T1=OVERLAY(VOLSER,T1,POS('XXXXXX',T1));\n  T2=OVERLAY(VOLSER,JCLR.26,POS('XXXXXX',JCLR.26));\n  T3=OVERLAY(VOLSER,JCLR.1,POS('XXXXXX',JCLR.1));\n  T4=OVERLAY(VOLSER,JCLR.5,POS('XXXXXX',JCLR.5));\n  T5=OVERLAY(VOLSER,JCLR.34,POS('XXXXXX',JCLR.34));\n  T6=OVERLAY(VOLSER,JCLR.44,POS('XXXXXX',JCLR.44));\n  T7=OVERLAY(JOBC,JCLR.2,POS('?',JCLR.2));\n  DO J = 1 TO JCLR.0;\n      IF J=16 THEN REST.RESTCTR=T1;\n      ELSE IF J=26 THEN REST.RESTCTR=T2;\n      ELSE IF J=30 THEN REST.RESTCTR=T1;\n      ELSE IF J=34 THEN REST.RESTCTR=T5;\n      ELSE IF J=44 THEN REST.RESTCTR=T6;\n      ELSE IF J=5 THEN REST.RESTCTR=T4;\n      ELSE IF J=1 THEN REST.RESTCTR=T3;\n      ELSE IF J=2 THEN REST.RESTCTR=T7;\n      ELSE REST.RESTCTR=JCLR.J;\n      RESTCTR=RESTCTR+1;\n  END;\n  END;\n  T1=OVERLAY(UNIT,JCLI.6,POS('XXX',JCLI.6));\n  T2=OVERLAY(VOLSER,JCLI.7,POS('XXXXXX',JCLI.7));\n  T3=OVERLAY(VOLSER,JCLI.1,POS('XXXXXX',JCLI.1));\n IF UNIT\u00ac=\"F00\" THEN DO;\n  DO J = 1 TO JCLI.0;\n      IF J=6 THEN INIT.INITCTR=T1;\n      ELSE IF J=7 THEN INIT.INITCTR=T2;\n      ELSE IF J=1 THEN INIT.INITCTR=T3;\n      ELSE INIT.INITCTR=JCLI.J;\n      INITCTR=INITCTR+1;\n  END;\n END;\n IF UNIT\u00ac=\"F00\" THEN ,\n  SUMM.SUMMCTR = VOLSER \"TYPE\" LEFT(TRUE_DEVTYPE,6) \"MAPPED TO\",\n     \"CDRS UNIT\" UNIT \"TYPE\" TARGET_TYPE;\n ELSE ,\nSUMM.SUMMCTR=\"****** VOLUME\" VOLSER \"NOT INITIALIZED AND/OR RESTORED\";\n  IF VOLSER=\"SYS006\" THEN ,\n       SUMM.SUMMCTR=SUMM.SUMMCTR \"IPL LOADUNIT\" UNIT;\n  IF VOLSER=\"SYS001\" | VOLSER=\"SYS002\" THEN ,\n       SUMM.SUMMCTR=SUMM.SUMMCTR \"LOADPARM\" RIGHT(UNIT,4,\"0\")\"CDM\";\n  SUMMCTR=SUMMCTR+1;\n END I;\nIF POOLMEM \u00ac=\"POOLSYSD\" & POOLMEM \u00ac=\"POOLSYST\" THEN DO;\n \"EXECIO * DISKW DUMP (FINIS STEM DUMP.\";\n \"EXECIO * DISKW INCR (FINIS STEM INCR.\";\n \"EXECIO * DISKW REST (FINIS STEM REST.\";\nEND;\n \"EXECIO * DISKW INIT (FINIS STEM INIT.\";\nEND ZZ;\n\"EXECIO * DISKW SUMM (FINIS STEM SUMM.\";\nEXIT 0;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DASDBUL6": {"ttr": 9734, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\r\\x00\\x00\\x00\\x95\\x03\\x1f\\x00\\x95%_\\x16Q\\x02z\\x02y\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf1\\xf0@@@'", "ispf": {"version": "01.13", "flags": 0, "createdate": "1995-01-31T00:00:00", "modifydate": "1995-09-12T16:51:00", "lines": 634, "newlines": 633, "modlines": 0, "user": "TECH110"}, "text": "/* REXX DASD BUILD ANALYSIS */\nTRUE = \"1\";\nCNTCP = 1\nFALSE = \"0\";\nCPKCTR = 100;\nSUMMCTR=1;\nDASD.0885 = \"3380DJ\";\nDASD.1770 = \"3380E\";\nDASD.2655 = \"3380K\";\nDASD.2226 = \"33902\";\nDASD.3338 = \"33903\";\nDASD.3339 = \"33903\";\nDASD.10019 = \"33909\";\nDASD.99999 = \"99999\";\nCDRS.3380DJ = \"100 11F 200 21F\";\nCDRS.3380E = \"480 49F\";\nCDRS.3380K = \"C40 C5F F00 F00\";\nCDRS.33902 = \"3C0 3FF FC0 FFF\";\nCDRS.33903 = \"EC0 EFF 1C0 1FF 200 2FF A00 AFF B00 BFF \";\nCDRS.33909 = \"500 5FF 600 6FF 700 7FF 800 8FF 900 9FF D00 DFF\";\n/* CDRS.33903 = \"EC0 EFF 1C0 1FF (200 2FF)\"; DUMMY RANGE ADDED 9/23 */\n/* CDRS.33909 = \"(500 5FF 600 6FF **)\"; DUMMY RANGE ADDED 1/23/95 */\nCDRS.99999  = \"F00 F00\"; /* F00 IS END INDICATOR */\nCLASSLIST=\"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\n/* ALPHA LIST */\nABRPOOLS=\"ACIC APPL BAT CICS CIC0 DB2 EMC EMR MNT PLAN \" || ,\n  \"POS PHYS QA RAMI SEQ SMS SYSDA SYSTA SYS0 SYSP SYSQ TSO \" || ,\n  \"USER USR VSAM JES PAGE SYSB SYSAP SYST0 RAM0\";\n/* LIST BY IMP */\nABRPOOLSR=\"ACIC APPL BAT CICS CIC0 DB2 EMC EMR MNT PLAN \" || ,\n  \"POS PHYS QA RAMI SEQ SMS SYS0 SYSP SYSQ TSO \" || ,\n  \"USER USR VSAM JES PAGE SYSB SYSAP SYST0 RAM0\";\nTEMP = \"\";\nDO I = 1 TO WORDS(CDRS.3380DJ) BY 2;\n  LLIM = X2D(WORD(CDRS.3380DJ,I));\n  HLIM = X2D(WORD(CDRS.3380DJ,I+1));\n     DO J = LLIM TO HLIM;\n        TEMP = TEMP D2X(J);\n     END;\nEND;\nCDRS.3380DJ = TEMP;\nTEMP = \"\";\nDO I = 1 TO WORDS(CDRS.3380E) BY 2;\n  LLIM = X2D(WORD(CDRS.3380E,I));\n  HLIM = X2D(WORD(CDRS.3380E,I+1));\n     DO J = LLIM TO HLIM;\n        TEMP = TEMP D2X(J);\n     END;\nEND;\nCDRS.3380E = TEMP;\nTEMP = \"\";\nDO I = 1 TO WORDS(CDRS.3380K) BY 2;\n  LLIM = X2D(WORD(CDRS.3380K,I));\n  HLIM = X2D(WORD(CDRS.3380K,I+1));\n     DO J = LLIM TO HLIM;\n        TEMP = TEMP D2X(J);\n     END;\nEND;\nCDRS.3380K = TEMP;\nTEMP = \"\";\nDO I = 1 TO WORDS(CDRS.33902) BY 2;\n  LLIM = X2D(WORD(CDRS.33902,I));\n  HLIM = X2D(WORD(CDRS.33902,I+1));\n     DO J = LLIM TO HLIM;\n        TEMP = TEMP D2X(J);\n     END;\nEND;\nCDRS.33902 = TEMP;\nTEMP = \"\";\nDO I = 1 TO WORDS(CDRS.33903) BY 2;\n  LLIM = X2D(WORD(CDRS.33903,I));\n  HLIM = X2D(WORD(CDRS.33903,I+1));\n     DO J = LLIM TO HLIM;\n        TEMP = TEMP D2X(J);\n     END;\nEND;\nCDRS.33903 = TEMP;\nTEMP = \"\";\nDO I = 1 TO WORDS(CDRS.33909) BY 2;\n  LLIM = X2D(WORD(CDRS.33909,I));\n  HLIM = X2D(WORD(CDRS.33909,I+1));\n     DO J = LLIM TO HLIM;\n        TEMP = TEMP D2X(J);\n     END;\nEND;\nCDRS.33909 = TEMP;\n/* CDRS.99999  = \"F00 F00\";  F00 IS END INDICATOR */\nINIT_REST_UNIT = WORD(CDRS.33902,1);\nCDRS.33902 = DELWORD(CDRS.33902,1,1);\n\"CALL 'SYS1.TECH.COMMON.LOADLIB(DASDSCAN)'\";\n/* \"CALL 'TECH110.USER.LOADLIB(DASDSCAN)'\"; */\nSAVERC=RC;\nIF SAVERC\u00ac=0 THEN EXIT SAVERC;\n\"EXECIO * DISKR WORK (FINIS STEM DASDV.\";\nDO I = 1 TO DASDV.0;\n  PARSE VAR DASDV.I VOLSER CYLCOUNT FREECYL FRAGINDEX . ;\n  IF CYLCOUNT = \"0019\" THEN DO;\n     CYLCOUNT = \"10019\";\n  END;\n  DASDV.I = VOLSER || \" \" || CYLCOUNT || \" \" ,\n            || FREECYL || \" \" || FRAGINDEX ;\nEND;\nCHANGES = TRUE;\nDO WHILE(CHANGES); /* BUBBLE SORT DESCENDING BY FRAG INDEX */\n     CHANGES = FALSE;\n     DO I = 1 TO DASDV.0-1;\n          J = I+1;\n          PARSE VAR DASDV.I . . . FRAGINDEX1 . ;\n          PARSE VAR DASDV.J . . . FRAGINDEX2 . ;\n          IF FRAGINDEX1 < FRAGINDEX2 THEN DO;\n                 TEMP = DASDV.I;\n                 DASDV.I = DASDV.J;\n                 DASDV.J = TEMP;\n                 CHANGES = TRUE;\n                 END;\n     END;\nEND;\nFLAG_CNT=1\nDO I = 1 TO DASDV.0;\n  PARSE VAR DASDV.I VOLSER CYLCOUNT FREECYL FRAGINDEX . ;\n  ABR_BACKUP_DSN = \"'FDRABR.V\"VOLSER\"'\";\n  DUMMY = LISTDSI(ABR_BACKUP_DSN); /* SEE IF DATASET EXISTS */\n  IF DUMMY\u00ac=0 THEN DO;\n       DASDV.I = \"DUMMY\"; /* IGNORE THIS VOLUME */\n       ITERATE I; /* LOOP */\n       END;\n/*** CPK SELECTION *****/\n  TSTVSR = SUBSTR(VOLSER,1,4)\n  INTERPRET VOLSER '= \"NO\"'\n/*\n  IF TSTVSR = \"APPL\" |,\n     TSTVSR = \"PLAN\" |,\n     TSTVSR = \"POS0\" |,\n     TSTVSR = \"TSO0\" |,\n     TSTVSR = \"USER\" |,\n     TSTVSR = \"QA00\" |,\n     TSTVSR = \"PHYS\" |,\n     TSTVSR = \"VSAM\" |,\n     TSTVSR = \"CICS\" |,\n     TSTVSR = \"DB20\" |,\n     TSTVSR = \"SEQD\" |,\n     TSTVSR = \"UART\" |,\n     TSTVSR = \"ARTH\" |,\n     TSTVSR = \"RAMI\" |,\n     TSTVSR = \"SMSU\" |,\n     TSTVSR = \"SMSP\" |,\n     TSTVSR = \"SMSC\" |,\n     TSTVSR = \"USR0\" |,\n     TSTVSR = \"CIC0\" |,\n     TSTVSR = \"BAT0\" |,\n     TSTVSR = \"EMRG\" THEN DO\n     INTERPRET VOLSER '= \"YES\"'\n     END\n                       */\n/***********************/\n  POOLCTR=WORDS(ABRPOOLS);\n  DO J=1 TO POOLCTR;\n     POOL=STRIP(SUBSTR(WORD(ABRPOOLS,J),1,4));\n     IF ABBREV(VOLSER,POOL) THEN DO;\n           IF SYMBOL('POOLLIST.POOL')=\"VAR\" THEN ,\n               POOLLIST.POOL=POOLLIST.POOL VOLSER;\n            ELSE POOLLIST.POOL=VOLSER;\n          LEAVE J;\n         END;\n  END;\nEND;\nABRPOOLS = ABRPOOLSR; /* REORG LIST FOR ORDER TO PROCESS IN */\nDO J=1 TO POOLCTR;\n     POOL=STRIP(SUBSTR(WORD(ABRPOOLS,J),1,4));\n     VOLCNT=WORDS(POOLLIST.POOL);\n     JOBC=SUBSTR(CLASSLIST,J,1);\nSUMM.SUMMCTR=\"****** POOL\" LEFT(POOL,7) \"RESTORE JOBCLASS:\" JOBC ,\n        \"VOLCNT:\" VOLCNT;\n     SUMMCTR=SUMMCTR+1;\nEND;\nJCLD.0 = 40; /* COUNT OF DUMP JOB STATEMENTS */\nJCLD.1 = \"//D$XXXXXX JOB 530401053000,'SYSTEM.BACKUP',\";\nJCLD.2 = \"// NOTIFY=TECH251,CLASS=S,MSGCLASS=G\";\nJCLD.3  = \"//DUMPIT EXEC PGM=FDRABR\";\nJCLD.4  = \"//SYSPRINT DD SYSOUT=*\";\nJCLD.5  = \"//SYSPRIN1 DD SYSOUT=*\";\nJCLD.6  = \"//DISK1 DD UNIT=XXXX,\";\nJCLD.7  = \"// DISP=SHR,\";\nJCLD.8  = \"// VOL=SER=XXXXXX\";\nJCLD.9 =\"//TAPE1 DD DSN=FXXXXXX,DISP=(,KEEP),UNIT=TA80,VOL=(,,,255)\";\nJCLD.10 = \"//SYSUDUMP DD SYSOUT=X\";\nJCLD.11 = \"//SYSIN DD *\";\nJCLD.12 = \" DUMP TYPE=FDR,\";\nJCLD.13 = \"  AUTOUPD=YES,\";\nJCLD.14 = \"  BUFNO=MAX,\";\nJCLD.15 = \"  COMPRESS=ALL,\";\nJCLD.16 = \"  DATA=ALL,\";\nJCLD.17 = \"  DATEP=NONE,\";\nJCLD.18 = \"  DSNENQ=TEST,\";\nJCLD.19 = \"  ENQ=RESERVE,\";\nJCLD.20 = \"  ENQERR=NO,\";\nJCLD.21 = \"  ENQERR=PROCESS,\";\nJCLD.22 = \"  FORMAT=NEW,\";\nJCLD.23 = \"  LBPZERO=INVALID,\";\nJCLD.24 = \"  MAXERR=1,\";\nJCLD.25 = \"  PRINT=ABR,\";\nJCLD.26 = \"  RETPD=9999,\";\nJCLD.27 = \"  SMSCONSTRUCT=NO,\";\nJCLD.28 = \"  SMSMANAGE=NO\";\nJCLD.29 = \"/*\";\nJCLD.30 = \"// IF (DUMPIT.RC>4 | DUMPIT.ABEND=TRUE) THEN\";\nJCLD.31 = \"//DUMPFAIL EXEC WTO\";\nJCLD.32 = \"//SYSIN    DD *\";\nJCLD.33 = \" *** WARNING\";\nJCLD.34 = \" ** \";\nJCLD.35 = \" ** ERROR DURING FULL VOLUME BACKUP OF VOL > XXXXXX <.\";\nJCLD.36 = \" ** \";\nJCLD.37 = \" *** WARNING \";\nJCLD.38 = \"/*\";\nJCLD.39 = \"// ENDIF\";\nJCLD.40 = \"//\";\nJCLX.0 = 41; /* COUNT OF INCR JOB STATEMENTS */\nJCLX.1 = \"//I$XXXX JOB 530401053000,'SYSTEM.BACKUP',\";\nJCLX.2 = \"// NOTIFY=TECH251,\";\nJCLX.3 = \"// CLASS=S,MSGCLASS=G\";\nJCLX.4 = \"//DUMPIT EXEC PGM=FDRABR\";\nJCLX.5 = \"//SYSPRIN1 DD SYSOUT=*\";\nJCLX.6 = \"//SYSPRIN2 DD SYSOUT=*\";\nJCLX.7 = \"//SYSPRIN3 DD SYSOUT=*\";\nJCLX.8=\"//TAPE1 DD DSN=I1XXXX,DISP=(,KEEP),UNIT=TA80,VOL=(,,,255)\";\nJCLX.9=\"//TAPE2 DD DSN=I2XXXX,DISP=(,KEEP),UNIT=TA80,VOL=(,,,255)\";\nJCLX.10=\"//TAPE3 DD DSN=I3XXXX,DISP=(,KEEP),UNIT=TA80,VOL=(,,,255)\";\nJCLX.11= \"//SYSPRINT DD SYSOUT=*\";\nJCLX.12 = \"//SYSUDUMP DD SYSOUT=X\";\nJCLX.13 = \"//SYSIN DD *\";\nJCLX.14 = \" DUMP TYPE=ABR,\";\nJCLX.15 = \"  AUTOUPD=YES,\";\nJCLX.16 = \"  BUFNO=MAX,\";\nJCLX.17 = \"  COMPRESS=ALL,\";\nJCLX.18 = \"  DATA=USED,\";\nJCLX.19 = \"  DATEP=NONE,\";\nJCLX.20 = \"  DSNENQ=TEST,\";\nJCLX.21 = \"  ENQ=RESERVE,\";\nJCLX.22 = \"  ENQERR=NO,\";\nJCLX.23 = \"  ENQERR=PROCESS,\";\nJCLX.24 = \"  FORMAT=NEW,\";\nJCLX.25 = \"  LBPZERO=INVALID,\";\nJCLX.26 = \"  MAXERR=1,\";\nJCLX.27 = \"  PRINT=ABR,\";\nJCLX.28 = \"  RETPD=9999,\";\nJCLX.29 = \"  SMSCONSTRUCT=NO,\";\nJCLX.30 = \"  SMSMANAGE=NO\";\nJCLXSTP = 30\nJCLY.4  = \"//DUMPIT EXEC PGM=FDRABR,REGION=0M\";\n/* ********* 30 *********** */\nJCLX.31 = \"/*\";\nJCLX.32 = \"// IF (DUMPIT.RC>4 | DUMPIT.ABEND=TRUE) THEN\";\nJCLX.33 = \"//DUMPFAIL EXEC WTO\";\nJCLX.34 = \"//SYSIN    DD * \";\nJCLX.35 = \" *** WARNING\";\nJCLX.36 = \" ** \";\nJCLX.37 = \" ** ERROR DURING INCREMENTAL BACKUP OF VOL GROUP > XXXX <.\";\nJCLX.38 = \" ** \";\nJCLX.39 = \" *** WARNING\";\nJCLX.40 = \"/*\";\nJCLX.41 = \"// ENDIF\";\nJCLR.0 = 47; /* COUNT OF RESTORE JOB STATEMENTS */\nJCLR.1 = \"//R$XXXXXX JOB 530401053000,'TECH SUPPRT',\";\nJCLR.2 = \"// CLASS=?,MSGCLASS=X,MSGLEVEL=(1,1),REGION=0M\";\nJCLR.3 = \"//JOBLIB DD DSN=IMPORT.LINKLIB1,DISP=SHR\";\nJCLR.4 = \"//ACTIVE EXEC PGM=IKJEFT01,REGION=0M,\";\nJCLR.5 = \"// PARM='ALTER ''FDRABR.COMDISCO.WEEKREST.VXXXXXX'' OWNER(I)'\"\nJCLR.6 = \"//SYSTSPRT DD SYSOUT=*\";\nJCLR.7 = \"//SYSTSIN DD DUMMY\";\nJCLR.8 = \"//*\";\nJCLR.9 = \"//*\";\nJCLR.10 = \"//*\";\nJCLR.11 = \"//*\";\nJCLR.12 = \"//*\";\nJCLR.13 = \"//RESTIT EXEC PGM=FDRABR,REGION=0M\";\nJCLR.14 = \"//SYSPRINT DD SYSOUT=*\";\nJCLR.15 = \"//ABRWORK  DD UNIT=SYSALLDA,SPACE=(CYL,(2,1))\";\nJCLR.16 = \"//DISK1 DD UNIT=XXXX,VOL=SER=XXXXXX,DISP=OLD\";\nJCLR.17 = \"//SYSIN DD *\";\nJCLR.18 = \" RESTORE TYPE=FDR,\";\nJCLR.19 = \"   CONFMESS=NO,\";\nJCLR.20 = \"   COPY=1,\";\nJCLR.21 = \"  CPYVOLID=YES,\";\nJCLR.22 = \"  DYNTAPE,\";\nJCLR.23 = \"  MAXERR=1,\";\nJCLR.24 = \"  SMSPROT=NONE,\";\nJCLR.25 = \"  VOLRESET=NO\";\nJCLR.26 = \" SELECT  VOL=XXXXXX,GEN=CURRENT\";\nJCLR.27 = \"/*\";\nJCLR.28 = \"//IXITIT EXEC PGM=ICKDSF,REGION=0M\";\nJCLR.29 = \"//SYSPRINT DD SYSOUT=*\";\nJCLR.30 = \"//DISK1 DD UNIT=XXXX,VOL=SER=XXXXXX,DISP=OLD\";\nJCLR.31 = \"//SYSIN DD *\";\nJCLR.32=\" BUILDIX DDNAME(DISK1) IXVTOC\";\nJCLR.33 = \"//COMPLETE EXEC PGM=IKJEFT01,COND=(0,NE,RESTIT),\";\nJCLR.34=\"// PARM='ALTER ''FDRABR.COMDISCO.WEEKREST.VXXXXXX'' OWNER(C)'\"\nJCLR.35 = \"//SYSTSPRT DD SYSOUT=*\";\nJCLR.36 = \"//SYSTSIN DD DUMMY\";\nJCLR.37 = \"//*\";\nJCLR.38 = \"//*\";\nJCLR.39 = \"//*\";\nJCLR.40 = \"//*\";\nJCLR.41 = \"//*\";\nJCLR.42 = \"//*\";\nJCLR.43 = \"//FAILURE EXEC PGM=IKJEFT01,COND=((0,GE,RESTIT),EVEN),\";\nJCLR.44=\"// PARM='ALTER ''FDRABR.COMDISCO.WEEKREST.VXXXXXX'' OWNER(F)'\"\nJCLR.45 = \"//SYSTSPRT DD SYSOUT=*\";\nJCLR.46 = \"//SYSTSIN DD DUMMY\";\nJCLR.47 = \"//\";\nJCLI.0 = 8; /* COUNT OF INIT JOB STATEMENTS */\nJCLI.1 = \"//I$XXXXXX JOB 530401053000,'TECH SUPPRT',NOTIFY=$CDRS1,\";\nJCLI.2 = \"// CLASS=A,MSGCLASS=X,MSGLEVEL=(1,1)\";\nJCLI.3 = \"//INITIT EXEC PGM=ICKDSF,REGION=0M\";\nJCLI.4 = \"//SYSPRINT DD SYSOUT=*\";\nJCLI.5 = \"//SYSIN DD *\";\nJCLI.6=\" INIT UNIT(XXX) NVFY NCHK INDEX(1,0,15) VTOC(0,1,14) -\";\nJCLI.7 = \"   NOMAP PRG NVAL VOLID(XXXXXX)\";\nJCLI.8 = \"//\";\nJCLC.0 = 38; /* COMPAKTOR */\nJCLC.1 = \"// IF (DUMPIT.RC<=4 & \u00acDUMPIT.ABEND=TRUE) THEN\";\nJCLC.2 = \"//CPKIT  EXEC PGM=FDRCPK,REGION=0M\";\nJCLC.3 = \"//SYSPRINT DD SYSOUT=*\";\nJCLC.4 = \"//SYSMAP   DD SYSOUT=*\";\nJCLC.5 = \"//SYSSUMM  DD SYSOUT=*\";\nJCLC.6 = \"//SYSUDUMP DD SYSOUT=X\";\nJCLC.7 = \"//SYSIN DD *\";\nJCLC.8 = \" CPK TYPE=FASTCPK,VOL=(XXXXXX),ACTMESS=NO,CONFMESS=NO,\";\nJCLC.9= \" HI=NO,MAPS=SUMMARY,NOSECOND=NORLSE,ENQ=RESERVE,DSNENQ=USE,\";\nJCLC.10 = \" PSRLSE=ALL,UNABLE=IGNORE,SIZEKEEP=(,,,10000),\";\nJCLC.11 = \" O=MAXFREE,T=KEEP,V=NOCHANGE,CPKFREEX=10\";\nJCLC.12 = \"/*\";\nJCLC.13 = \"// ENDIF\";\nJCLC.14 = \"//*\";\nJCLC.15 = \"// IF (CPKIT.RC>0 | CPKIT.ABEND=TRUE) THEN\";\nJCLC.16 = \"//MAPIT    EXEC PGM=FDRCPK\";\nJCLC.17 = \"//TAPE1    DD DUMMY\";\nJCLC.18 = \"//SYSMAP   DD SYSOUT=*\";\nJCLC.19 = \"//SYSPRINT DD SYSOUT=*\";\nJCLC.20 = \"//SYSUDUMP DD SYSOUT=*\";\nJCLC.21 = \"//SYSIN    DD *\";\nJCLC.22 = \"   MAP VOL=XXXXXX,MAPS=SUMMARY \";\nJCLC.23 = \"/*\";\nJCLC.24 = \"// ENDIF \";\nJCLC.25 = \"// IF (MAPIT.RC>0 | MAPIT.ABEND=TRUE) THEN\";\nJCLC.26 = \"//CPKFAIL  EXEC WTO\";\nJCLC.27 = \"//SYSIN    DD * \";\nJCLC.28 = \" *** WARNING \";\nJCLC.29 = \" ** \";\nJCLC.30 = \" ** AN ERROR HAS OCCURRED DURING THE COMPACTION OF\";\nJCLC.31 = \" ** VOLUME > XXXXXX <. THIS PROBLEM MUST BE RESOLVED\";\nJCLC.32 = \" ** BEFORE THE SCHEDULE CONTINUES. CONTACT TECH SUPPORT\";\nJCLC.33 = \" ** PERSON ON CALL.\";\nJCLC.34 = \" ** \";\nJCLC.35 = \" *** WARNING \";\nJCLC.36 = \"/* \";\nJCLC.37 = \"// ENDIF \";\nJCLC.38 = \"// \";\nHEADTAIL = TRUE;\n/* ****************** */\nCPKC   = \" O=MAXFREE,T=KEEP,V=NOCHANGE,CPKFREEX=10\";\nCPKNC  = \" O=MINEXTS,T=KEEP,V=NOCHANGE\";\n/* ****************** */\nSAY \"\";\nSAY \"****** INITIAL RESTORE 3390 UNIT:\" ,\n     INIT_REST_UNIT;\nSAY \"\";\nSUMM.SUMMCTR = \"****** INITIAL RESTORE 3390 UNIT:\" ,\n     INIT_REST_UNIT;\nSUMMCTR=SUMMCTR+1;\n/* LOOP */\nPOOLCTR=WORDS(ABRPOOLS);\nDO ZZ=1 TO POOLCTR;\nJOBC = SUBSTR(CLASSLIST,ZZ,1);\nPOOL=STRIP(SUBSTR(WORD(ABRPOOLS,ZZ),1,4));\nPOOLMEM=STRIP(SUBSTR(\"POOL\"POOL,1,8));\nDROP DUMP.;\nDROP INCR.;\nDROP REST.;\nDROP INIT.;\nDUMPCTR=1;\nINCRCTR=1;\nRESTCTR=1;\nINITCTR=1;\n\"FREE F(INIT)\";\n\"FREE F(DUMP)\";\n\"FREE F(INCR)\";\n\"FREE F(REST)\";\n\"ALLOC F(INIT) DA('SYSS.COMDISCO.INITJOBS(\"POOLMEM\")') SHR\";\nIF RC\u00ac=0 THEN EXIT 99;\nIF POOLMEM \u00ac=\"POOLSYSD\" & POOLMEM \u00ac=\"POOLSYST\" THEN DO;\n\"ALLOC F(DUMP) DA('SYSS.COMDISCO.DUMPJOBS(\"POOLMEM\")') SHR\";\nIF RC\u00ac=0 THEN EXIT 99;\nEND;\nIF POOLMEM \u00ac=\"POOLSYSD\" & POOLMEM \u00ac=\"POOLSYST\" & ,\n   POOLMEM \u00ac=\"POOLPAGE\" & POOLMEM \u00ac=\"POOLJES\" THEN DO;\n\"ALLOC F(INCR) DA('SYSS.COMDISCO.INCRJOBS(\"POOLMEM\")') SHR\";\nIF RC\u00ac=0 THEN EXIT 99;\nEND;\nIF POOLMEM \u00ac=\"POOLSYSD\" & POOLMEM \u00ac=\"POOLSYST\" THEN DO;\n\"ALLOC F(REST) DA('SYSS.COMDISCO.RESTJOBS(\"POOLMEM\")') SHR\";\nIF RC\u00ac=0 THEN EXIT 99;\nEND;\nT1=OVERLAY(POOL,JCLX.1,POS('XXXX',JCLX.1));\nDO J = 1 TO 3;\n      IF J=1 THEN INCR.INCRCTR=T1;\n      ELSE INCR.INCRCTR=JCLX.J;\n      INCRCTR=INCRCTR+1;\nEND;\nXCTR=WORDS(POOLLIST.POOL);\nTRUEVOLC=0;\nDO I = 1 TO XCTR;\n  XVOL=WORD(POOLLIST.POOL,I);\n  TEMP_PACK1 = SUBSTR(XVOL,1,5);\n  TEMP_PACK2 = SUBSTR(XVOL,1,3);\n  IF TEMP_PACK1=\"SYSDA\" | TEMP_PACK1=\"SYSTA\" | TEMP_PACK2=\"DRV\" ,\n     | TEMP_PACK2=\"JES\" | TEMP_PACK2=\"PAG\" ,\n     | TEMP_PACK2=\"TEM\" | TEMP_PACK2=\"LAN\" THEN ITERATE;\n  IF XVOL=\"SYS015\" | XVOL=\"SYS007\" | XVOL=\"SYS008\" | XVOL=\"SYS011\" | ,\n     XVOL=\"SYS012\" | XVOL=\"SYS013\" | XVOL=\"SYS014\" THEN ITERATE;\n  TRUEVOLC=TRUEVOLC+1;\nEND;\n/* INCRCTR=INCRCTR+1 */;\nT2=OVERLAY(POOL,JCLX.8,POS('XXXX',JCLX.8));\nT3=OVERLAY(POOL,JCLX.9,POS('XXXX',JCLX.9));\nT4=OVERLAY(POOL,JCLX.10,POS('XXXX',JCLX.10));\nT5=OVERLAY(POOL,JCLX.37,POS('XXXX',JCLX.37));\nIF (POOL=\"SYS\" | POOL=\"ART\") THEN T6=JCLY.4;\nELSE T6=JCLX.4;\nDO J = 4 TO JCLXSTP;\n      IF J=4 THEN INCR.INCRCTR=T6;\n      ELSE IF J=8 THEN INCR.INCRCTR=T2;\n      ELSE IF J=9 THEN INCR.INCRCTR=T3;\n      ELSE IF J=10 THEN INCR.INCRCTR=T4;\n      ELSE INCR.INCRCTR=JCLX.J;\n      /* TAPE CTR BY VOL CNT LOGIC */\n/*    IF TRUEVOLC>=9 & J=17 THEN ITERATE J;   */\n      IF TRUEVOLC>=9 THEN NOP;\n      ELSE IF TRUEVOLC>=4 & ,\n          (J=7 | J=10) THEN ITERATE J;\n      ELSE IF TRUEVOLC<4 & ,\n          (J=7 | J=10 | J=6 | J=9) THEN ITERATE J;\n      INCRCTR=INCRCTR+1;\n/*    IF TRUEVOLC>=9 & J=7 THEN DO;\n         INCR.INCRCTR=\"//SYSPRIN4 DD SYSOUT=*\";\n         INCRCTR=INCRCTR+1;\n         INCR.INCRCTR=\"//SYSPRIN5 DD SYSOUT=*\";\n         INCRCTR=INCRCTR+1;\n         INCR.INCRCTR=\"//SYSPRIN6 DD SYSOUT=*\";\n         INCRCTR=INCRCTR+1;\n      END; */\n/*    IF TRUEVOLC>=9 & J=10 THEN DO;\n      POOLX = LEFT(POOL,4,\"X\");\nINCR.INCRCTR= ,\n \"//TAPE4 DD DSN=I4\"POOLX\",DISP=(,KEEP),UNIT=TA80,VOL=(,,,255)\"\n         INCRCTR=INCRCTR+1;\n   INCR.INCRCTR= ,\n \"//TAPE5 DD DSN=I5\"POOLX\",DISP=(,KEEP),UNIT=TA80,VOL=(,,,255)\"\n         INCRCTR=INCRCTR+1;\nINCR.INCRCTR= ,\n \"//TAPE6 DD DSN=I6\"POOLX\",DISP=(,KEEP),UNIT=TA80,VOL=(,,,255)\"\n         INCRCTR=INCRCTR+1;\n      END;    */\nEND;\nXCTR=WORDS(POOLLIST.POOL);\nDO I = 1 TO XCTR;\n  XVOL=WORD(POOLLIST.POOL,I);\n  TEMP_PACK1 = SUBSTR(XVOL,1,5);\n  TEMP_PACK2 = SUBSTR(XVOL,1,3);\n  /* SKIP SOME INCR */\n  IF TEMP_PACK1=\"SYSDA\" | TEMP_PACK1=\"SYSTA\" | TEMP_PACK2=\"DRV\" ,\n     | TEMP_PACK2=\"JES\" | TEMP_PACK2=\"PAG\" ,\n     | TEMP_PACK2=\"TEM\" | TEMP_PACK2=\"LAN\" THEN ITERATE;\n  IF XVOL=\"SYS015\" | XVOL=\"SYS007\" | XVOL=\"SYS008\" | XVOL=\"SYS011\" | ,\n     XVOL=\"SYS012\" | XVOL=\"SYS013\" | XVOL=\"SYS014\" THEN ITERATE;\n  INCR.INCRCTR=\" MOUNT VOL=\"XVOL;\n  INCRCTR=INCRCTR+1;\nEND;\nJCLXHLD=JCLXSTP+1;\nDO J = JCLXHLD TO JCLX.0;\n   IF J=37 THEN INCR.INCRCTR=T5;\n   ELSE INCR.INCRCTR=JCLX.J;\n   INCRCTR=INCRCTR+1;\nEND;\nINCR.INCRCTR=\"//\";\n DO I = 1 TO DASDV.0;\n  CPK=FALSE;\n  PARSE VAR DASDV.I VOLSER CYLCOUNT FREECYL FRAGINDEX . ;\n  IF VOLSER=\"DUMMY\" THEN ITERATE;\n  IF WORDPOS(VOLSER,POOLLIST.POOL)=0 THEN ITERATE;/*DIFFERENT POOL*/\n  DEVTYPE = DASD.CYLCOUNT;\n  TRUE_DEVTYPE = DASD.CYLCOUNT;\n  IF HEADTAIL THEN DO;\n         HEADTAIL = FALSE; /* ROTATE CUU SELECTION */\n         UNIT = WORD(CDRS.DEVTYPE,1);\n         CDRS.DEVTYPE = DELWORD(CDRS.DEVTYPE,1,1);\n         END;\n  ELSE DO;\n         HEADTAIL = TRUE;  /* ROTATE CUU SELECTION */\n         IF WORDS(CDRS.DEVTYPE)=0 THEN ,\n              UNIT=\"\";\n         ELSE DO;\n           UNIT = WORD(CDRS.DEVTYPE,WORDS(CDRS.DEVTYPE));\n           IF UNIT\u00ac=\"F00\" THEN ,\n           CDRS.DEVTYPE = DELWORD(CDRS.DEVTYPE,WORDS(CDRS.DEVTYPE),1);\n           END;\n         END;\n  TARGET_TYPE=DEVTYPE;\n  IF UNIT=\"\" THEN DO; /* COMDISCO HAS NO MORE */\n       SELECT;\n         WHEN (DEVTYPE=\"3380DJ\") THEN TARGET_TYPE=\"3380E\";\n         WHEN (DEVTYPE=\"3380E\") THEN TARGET_TYPE=\"3380K\";\n         WHEN (DEVTYPE=\"3380K\") THEN EXIT 16; /* EMERGENCY */\n         WHEN (DEVTYPE=\"33902\") THEN TARGET_TYPE=\"33903\";\n         WHEN (DEVTYPE=\"33903\") THEN TARGET_TYPE=\"33909\";\n         WHEN (DEVTYPE=\"33909\") THEN EXIT 20;\n         OTHERWISE EXIT 24;\n       END;\n       IF TARGET_TYPE=\"3380E\" & WORDS(CDRS.3380E)=0 THEN ,\n            TARGET_TYPE=\"3380K\";\n       IF WORDS(CDRS.TARGET_TYPE)=0 THEN EXIT 28;\n       UNIT = WORD(CDRS.TARGET_TYPE,1);\n       IF UNIT\u00ac=\"F00\" THEN ,\n       CDRS.TARGET_TYPE = DELWORD(CDRS.TARGET_TYPE,1,1);\n       END;\n  DEVTYPE = SUBSTR(DEVTYPE,1,4);\n  TEMP_PACK1 = SUBSTR(VOLSER,1,5);\n  TEMP_PACK2 = SUBSTR(VOLSER,1,3);\n  IF TEMP_PACK1\u00ac=\"SYSDA\" & TEMP_PACK1\u00ac=\"SYSTA\" & TEMP_PACK2\u00ac=\"DRV\" ,\n     & TEMP_PACK2\u00ac=\"TEM\" & TEMP_PACK2\u00ac=\"LAN\" ,\n       THEN DO;\n  T1=OVERLAY(DEVTYPE,JCLD.6,POS('XXXX',JCLD.6));\n  T2=OVERLAY(VOLSER,JCLD.8,POS('XXXXXX',JCLD.8));\n  T3=OVERLAY(VOLSER,JCLD.1,POS('XXXXXX',JCLD.1));\n  T5=OVERLAY(VOLSER,JCLD.9,POS('XXXXXX',JCLD.9));\n  T10=OVERLAY(VOLSER,JCLD.35,POS('XXXXXX',JCLD.35));\n  T11=OVERLAY(VOLSER,JCLC.22,POS('XXXXXX',JCLC.22));\n  T12=OVERLAY(VOLSER,JCLC.31,POS('XXXXXX',JCLC.31));\n  T13=OVERLAY(VOLSER,JCLC.8,POS('XXXXXX',JCLC.8));\n  TSTVSR = SUBSTR(VOLSER,1,4)\n  IF TSTVSR = \"DB20\" THEN\n     T14=CPKNC\n  ELSE\n     T14=CPKC\n  CDSR= \"'FDRABR.COMDISCO.WEEKREST.V\"VOLSER\"'\";\n     \"ALTER\" CDSR \"OWNER(N)\";\n  IF RC > 0 THEN ,\n    \"DEFINE NVSAM (NAME(\"CDSR\") DEVT(0000) VOL('******') OWNER(N))\";\n  DO J = 1 TO JCLD.0;\n      IF J=6 THEN DUMP.DUMPCTR=T1;\n      ELSE IF J=8 THEN DUMP.DUMPCTR=T2;\n      ELSE IF J=1 THEN DUMP.DUMPCTR=T3;\n      ELSE IF J=9 THEN DUMP.DUMPCTR=T5;\n      ELSE IF J=35 THEN DUMP.DUMPCTR=T10;\n      ELSE IF J=18 & ,\n           ( VOLSER=\"SYS015\" | POOL=\"PAGE\" | POOL=\"JES\" ) THEN ,\n           DUMP.DUMPCTR=\"  ENQ=OFF,\";\n      ELSE DUMP.DUMPCTR=JCLD.J;\n      FLAGIT = \"NO\"\n   /* CHANGE  */\n      INTERPRET 'IF 'VOLSER '=\"YES\" THEN FLAGIT = \"YES\"'\n      IF J=23 & FLAGIT=\"YES\" THEN CPK=TRUE;\n      ELSE IF J=23 THEN CPK=FALSE;\n      ELSE NOP;\n   /* CHANGE  */\n      IF J=40 & (CPK) THEN ITERATE J ;\n      ELSE NOP;\n      DUMPCTR=DUMPCTR+1;\n      IF (J=39) & (CPK) THEN DO;\n           DO Z=1 TO JCLC.0;\n                DUMP.DUMPCTR=JCLC.Z;\n    /* CHANGE */\n                IF Z=8  THEN DUMP.DUMPCTR= T13;\n                IF Z=11 THEN DUMP.DUMPCTR= T14;\n                IF Z=22 THEN DUMP.DUMPCTR= T11;\n                IF Z=31 THEN DUMP.DUMPCTR= T12;\n                DUMPCTR=DUMPCTR+1;\n           END;\n       END;\n  END;\n  T1=OVERLAY(DEVTYPE,JCLR.16,POS('XXXX',JCLR.16));\n  T1=OVERLAY(VOLSER,T1,POS('XXXXXX',T1));\n  T2=OVERLAY(VOLSER,JCLR.26,POS('XXXXXX',JCLR.26));\n  T3=OVERLAY(VOLSER,JCLR.1,POS('XXXXXX',JCLR.1));\n  T4=OVERLAY(VOLSER,JCLR.5,POS('XXXXXX',JCLR.5));\n  T5=OVERLAY(VOLSER,JCLR.34,POS('XXXXXX',JCLR.34));\n  T6=OVERLAY(VOLSER,JCLR.44,POS('XXXXXX',JCLR.44));\n  T7=OVERLAY(JOBC,JCLR.2,POS('?',JCLR.2));\n  DO J = 1 TO JCLR.0;\n      IF J=16 THEN REST.RESTCTR=T1;\n      ELSE IF J=26 THEN REST.RESTCTR=T2;\n      ELSE IF J=30 THEN REST.RESTCTR=T1;\n      ELSE IF J=34 THEN REST.RESTCTR=T5;\n      ELSE IF J=44 THEN REST.RESTCTR=T6;\n      ELSE IF J=5 THEN REST.RESTCTR=T4;\n      ELSE IF J=1 THEN REST.RESTCTR=T3;\n      ELSE IF J=2 THEN REST.RESTCTR=T7;\n      ELSE REST.RESTCTR=JCLR.J;\n      RESTCTR=RESTCTR+1;\n  END;\n  END;\n  T1=OVERLAY(UNIT,JCLI.6,POS('XXX',JCLI.6));\n  T2=OVERLAY(VOLSER,JCLI.7,POS('XXXXXX',JCLI.7));\n  T3=OVERLAY(VOLSER,JCLI.1,POS('XXXXXX',JCLI.1));\n IF UNIT\u00ac=\"F00\" THEN DO;\n  DO J = 1 TO JCLI.0;\n      IF J=6 THEN INIT.INITCTR=T1;\n      ELSE IF J=7 THEN INIT.INITCTR=T2;\n      ELSE IF J=1 THEN INIT.INITCTR=T3;\n      ELSE INIT.INITCTR=JCLI.J;\n      INITCTR=INITCTR+1;\n  END;\n END;\n IF UNIT\u00ac=\"F00\" THEN ,\n  SUMM.SUMMCTR = VOLSER \"TYPE\" LEFT(TRUE_DEVTYPE,6) \"MAPPED TO\",\n     \"CDRS UNIT\" UNIT \"TYPE\" TARGET_TYPE;\n ELSE ,\nSUMM.SUMMCTR=\"****** VOLUME\" VOLSER \"NOT INITIALIZED AND/OR RESTORED\";\n  IF VOLSER=\"SYS006\" THEN ,\n       SUMM.SUMMCTR=SUMM.SUMMCTR \"IPL LOADUNIT\" UNIT;\n  IF VOLSER=\"SYS001\" | VOLSER=\"SYS002\" THEN ,\n       SUMM.SUMMCTR=SUMM.SUMMCTR \"LOADPARM\" RIGHT(UNIT,4,\"0\")\"CDM\";\n  SUMMCTR=SUMMCTR+1;\n END I;\nIF POOLMEM \u00ac=\"POOLSYSD\" & POOLMEM \u00ac=\"POOLSYST\" THEN DO;\n   \"EXECIO * DISKW DUMP (FINIS STEM DUMP.\";\n   IF POOLMEM \u00ac=\"POOLPAGE\" & POOLMEM \u00ac=\"POOLJES\" THEN DO;\n      \"EXECIO * DISKW INCR (FINIS STEM INCR.\";\n   END;\n   \"EXECIO * DISKW REST (FINIS STEM REST.\";\nEND;\n \"EXECIO * DISKW INIT (FINIS STEM INIT.\";\nEND ZZ;\n\"EXECIO * DISKW SUMM (FINIS STEM SUMM.\";\nEXIT 0;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DASDPULL": {"ttr": 9991, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01%\\x00\\x00\\x00\\x925/\\x00\\x93#\\x8f\\tP\\x00;\\x00\\x07\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf7@@@'", "ispf": {"version": "01.37", "flags": 0, "createdate": "1992-12-17T00:00:00", "modifydate": "1993-08-26T09:50:00", "lines": 59, "newlines": 7, "modlines": 0, "user": "TECH107"}, "text": "/* REXX DASD PULL ANALYSIS */\nTRUE = \"1\";\nFALSE = \"0\";\nPULLCTR=1;\n\"EXECIO * DISKR SUMM (FINIS STEM VOL.\";\nLINES = VOL.0/2; /* HALVE THE REPORT LINES */\nVOLLIST = \"\";\nDO I = 1 TO LINES;\n   PARSE VAR VOL.I VOLSER . ;\n   IF VOLSER=\"******\" THEN ITERATE;\n   ROOT1 = SUBSTR(VOLSER,1,5);\n   IF ROOT1=\"SYSDA\" | ROOT1=\"SYSTA\" THEN ITERATE;\n   ROOT2 = SUBSTR(VOLSER,1,3);\n   IF ROOT2=\"DRV\" | ROOT2=\"TEM\" | ROOT2=\"LAN\" THEN ITERATE;\n   VOLLIST = VOLLIST VOLSER;\nEND;\nDROP VOL.;\nSYSIN.1 = \" P CATLG\";\n\"EXECIO * DISKW SYSIN (FINIS STEM SYSIN.\";\nDROP SYSIN.;\n\"CALL 'SYS1.FDR.V5R2M9.LOADLIB(FDRABRP)'\";\n\"EXECIO * DISKR ABRMAP (FINIS STEM CAT.\";\nVOL_FOUND=FALSE;\nDO I = 1 TO CAT.0;\n   IF SUBSTR(CAT.I,51,8)\u00ac=\"FDRABR.V\" THEN ITERATE I;\n   ISVOL=SUBSTR(CAT.I,13,6);\n   ISGEN=SUBSTR(CAT.I,23,2);\n   LINE = STRIP(SPACE(CAT.I));\n   IF ISVOL\u00ac=\" \" THEN DO;\n       PARSE VAR LINE VOLSER GEN CYCLE TYPE DATE DSNAME ,\n                   COPY FILE TVOL;\n       VOL_FOUND=TRUE;\n       END;\n   ELSE IF ISGEN\u00ac=\" \" THEN DO; /* IGNORE OLDER GENS */\n       VOL_FOUND=FALSE;\n       ITERATE I;\n       END;\n   ELSE IF VOL_FOUND THEN ,\n       PARSE VAR LINE CYCLE TYPE DATE DSNAME ,\n                   COPY FILE TVOL;\n   T1=I+1; T2=I+2;\n   TEMP1=STRIP(SPACE(CAT.T1));\n   TEMP2=STRIP(SPACE(CAT.T2));\n   IF TEMP1\u00ac=\"\" & TEMP1\u00ac=\" \" & WORDS(TEMP1)=1 THEN ,\n        TVOL=TVOL\",\"WORD(TEMP1,1);\n   IF TEMP2\u00ac=\"\" & TEMP2\u00ac=\" \" & WORDS(TEMP2)=1 THEN ,\n        TVOL=TVOL\",\"WORD(TEMP2,1);\n   IF WORDPOS(VOLSER,VOLLIST)\u00ac=0 THEN DO;\n   TVOL = TRANSLATE(TVOL,\" \",\",\");\n   JEND = WORDS(TVOL); /* MULTIVOL */\n   DO J = 1 TO JEND;\n   TTVOL = WORD(TVOL,J);\nPULLOUT.PULLCTR=DATE LEFT(TTVOL,6) RIGHT(FILE,4,\"0\") DSNAME GEN CYCLE;\n   PULLCTR=PULLCTR+1;\n   END;\n   END;\nEND;\n\"EXECIO * DISKW PULLLIST (FINIS STEM PULLOUT.\";\nEXIT 0;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DB2BINDB": {"ttr": 9993, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x011\\x00\\x00\\x00\\x93\\x01\\x9f\\x00\\x951\\x7f\\x10$\\x00\\xcd\\x00\\xd3\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf3@@@'", "ispf": {"version": "01.49", "flags": 0, "createdate": "1993-01-19T00:00:00", "modifydate": "1995-11-13T10:24:00", "lines": 205, "newlines": 211, "modlines": 0, "user": "TECH103"}, "text": "/*  REXX EXEC : ( DB2BINDB ).\n    FUNCTION  : CALLED BY THE DB2 BATCH COMPILE TASK ( DB2B ) TO\n                BUILD THE DB2 BIND PLAN SYSIN MEMBER.\n                A BIND JOB WILL BE WRITTEN AND SUBMITTED TO THE\n                SYSA SYSTEM ( DB2SYSX - DSNX ).\n    INPUT     : TSOID.USER.DBRMLIB(&&MEMBER).\n    OUTPUT    : SYSS.TESTCCF.ISPFILE.CNTLLIB(&&MEMBER) -\n                BATCH JOB SUBMITTED TO SYSA SYSTEM CLASS=P.\n                                                                     */\nTRACE O\n/*      */\nHOUSE_KEEPING:\nADDRESS TSO\nARG TSOID ACCTCDE MEMBER DB2COLL DB2SYS\nPARMS = 'TSOID ACCTCDE MEMBER DB2COLL DB2SYS'\nSRC = 0\nDO I = 1 TO 5\n   IPARM = WORD(PARMS,I)\n   XPARM = VALUE(IPARM)\n   IF XPARM \u00ac= '' THEN ITERATE\n   SAY '*** PARM ERROR: MISSING PARM VALUE FOR ('IPARM'). ***'\n   SAY '*** DB2BINDB EXEC TASK CANCELLED - RC = (024). ***'\n   EXIT 024\nEND\nIF DB2SYS = 'DSNX' THEN EXIT 0   /* ***   N O O P   D S N X   *** */\nGRANTPDS = 'SYSS.TESTCCF.GRANT.CNTLLIB'\nISPFILE = 'SYSS.TESTCCF.ISPFILE.CNTLLIB'\nUCNTL = SYSDSN(\"'\"ISPFILE\"'\")\nIF UCNTL = 'DATASET NOT FOUND' THEN DO\n   IF SRC \u00ac= 0 THEN DO\n      SAY '*** ALLOCATE ERROR: DATASET NOT FOUND ('ISPFILE'). ***'\n      SAY '*** DB2BINDB EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n      EXIT 100\n   END\nEND\nX = MSG(\"OFF\")\n\"FREE FILE(ISPDD)\"\n\"FREE FILE(PARMDD)\n\n/*     */\nMAIN_ROUTINE_DSNX:\nDB2PLAN = DB2COLL\nDB2NODE = 'DB2X'\nEXPLN = 'YES'\nCALL CHECK_GRANT_CNTLLIB\nCALL BUILD_BIND_PLAN_JOBCARD\nINTERPRET CALL LABEL\nCALL BUILD_BIND_PLAN_SYSIN\nIF LABEL = 'BUILD_IKJEFT01_GRANTJCL' THEN CALL BUILD_GRANT_CNTLLIB_JCL\nCALL BUILD_IDCAMS_DELETE_MEMBER\nCALL WRITE_BIND_PLAN_JOB\nCALL SUBMIT_BIND_PLAN_JOB\nEXIT 0\n\n/*     S U B R O U T I N E S   S E C T I O N     */\n/*     */\nCHECK_GRANT_CNTLLIB:\nLABEL = 'BUILD_IKJEFT01_GRANTJCL'\nGMEMB = SYSDSN(\"'\"GRANTPDS\"(\"DB2PLAN\")'\")\nIF GMEMB = 'MEMBER NOT FOUND' THEN RETURN\n\"ALLOC DA('\"GRANTPDS\"(\"DB2PLAN\")') F(PARMDD) SHR\"\n\"EXECIO * DISKR PARMDD (FINIS STEM GPARM.\"\n\"FREE F(PARMDD)\"\nDO I = 1 TO GPARM.0\n   IF GPARM.I = DB2SYS THEN LABEL = 'BUILD_IKJEFT01_NOGRANT'\nEND\nRETURN\n\n/*     */\nBUILD_BIND_PLAN_JOBCARD:\nJN = MEMBER\n\"DELSTACK\"\nJCL.1 = \"//\"JN\" JOB\" ACCTCDE\",'\"TSOID\".DB2.BINDPLAN',NOTIFY=\"TSOID\",\"\nJCL.2 = \"//          CLASS=P,MSGCLASS=S,MSGLEVEL=(1,0),REGION=6M\"\nJCL.3 = \"/*JOBPARM SYSAFF=SYSA\"\nDO J = 1 TO 3\n   QUEUE JCL.J\nEND\nRETURN\n\n/*     */\nBUILD_IKJEFT01_GRANTJCL:\nRCDCNT = 10\nJCL.1 = \"//DSNXBIND EXEC PGM=IKJEFT01,DYNAMNBR=20\"\nJCL.2 = \"//DBRMLIB  DD DSN=\"TSOID\".USER.DBRMLIB,DISP=SHR\"\nJCL.3 = \"//SYSTSPRT DD SYSOUT=*\"\nJCL.4 = \"//SYSPRINT DD SYSOUT=*\"\nJCL.5 = \"//SYSUDUMP DD SYSOUT=*\"\nJCL.6 = \"//SYSOUT   DD SYSOUT=*\"\nJCL.7 = \"//SYSIN    DD *\"\nJCL.8 = \" GRANT BIND, EXECUTE ON PLAN \"DB2PLAN\" TO PUBLIC;\"\nJCL.9 = \"/*\"\nJCL.10 = \"//SYSTSIN  DD *\"\nDO J = 1 TO RCDCNT\n   QUEUE JCL.J\nEND\nRETURN\n\n/*     */\nBUILD_IKJEFT01_NOGRANT:\nRCDCNT = 8\nJCL.1 = \"//DSNXBIND EXEC PGM=IKJEFT01,DYNAMNBR=20\"\nJCL.2 = \"//DBRMLIB  DD DSN=\"TSOID\".USER.DBRMLIB,DISP=SHR\"\nJCL.3 = \"//SYSTSPRT DD SYSOUT=*\"\nJCL.4 = \"//SYSPRINT DD SYSOUT=*\"\nJCL.5 = \"//SYSUDUMP DD SYSOUT=*\"\nJCL.6 = \"//SYSOUT   DD SYSOUT=*\"\nJCL.7 = \"//SYSIN    DD DUMMY,DCB=BLKSIZE=80\"\nJCL.8 = \"//SYSTSIN  DD *\"\nDO J = 1 TO RCDCNT\n   QUEUE JCL.J\nEND\nRETURN\n\n/*     */\nBUILD_BIND_PLAN_SYSIN:\nRCDCNT = 16\nREC.1 = \" DSN SYSTEM(\"DB2SYS\")\"\nREC.2 = \" BIND PLAN (\"DB2PLAN\") -\"\nREC.3 = \"      OWNER(\"TSOID\") -\"\nREC.4 = \"      VALIDATE(BIND) -\"\nREC.5 = \"      FLAG(I) -\"\nREC.6 = \"      ACQUIRE(USE) -\"\nREC.7 = \"      ISOLATION(CS) -\"\nREC.8 = \"      RELEASE(COMMIT) -\"\nREC.9 = \"      EXPLAIN(\"EXPLN\") -\"\nREC.10 = \"      ACTION (REPLACE) RETAIN -\"\nREC.11 = \"      PKLIST(\"DB2COLL\".*) -\"\nREC.12 = \"      ENABLE(*)\"\nREC.13 = \" RUN PROGRAM(DSNTIAD) PLAN(DSNTIA31) -\"\nREC.14 = \"     LIB('SYSS.DB2.V2R3M0.\"DB2NODE\".RUNLIB.LOAD')\"\nREC.15 = \" END\"\nREC.16 = \"/*\"\nDO R = 1 TO RCDCNT\n   QUEUE REC.R\nEND\nRETURN\n\n/*     */\nBUILD_GRANT_CNTLLIB_JCL:\nJCLCNT = 10\nJCL.1 = \"//DB2GRNTP EXEC PGM=IKJEFT01,DYNAMNBR=30,\"\nJCL.2 = \"//  PARM='%DB2GRNTP \"DB2PLAN\" \"DB2SYS\"',COND=(0,LT,DSNXBIND)\"\nJCL.3 = \"//SYSTSPRT DD SYSOUT=*\"\nJCL.4 = \"//SYSPRINT DD SYSOUT=*\"\nJCL.5 = \"//SYSIN    DD DUMMY\"\nJCL.6 = \"//SYSLBC   DD DSN=SYS1.BRODCAST,DISP=SHR\"\nJCL.7 = \"//SYSUADS  DD DSN=SYS1.UADS,DISP=SHR\"\nJCL.8 = \"//SYSPROC  DD DSN=SYSS.TECH.COMMON.EXECLIB,DISP=SHR\"\nJCL.9 = \"//SYSTSIN  DD DUMMY\"\nJCL.10 = \"/*\"\nDO J = 1 TO JCLCNT\n   QUEUE JCL.J\nEND\nRETURN\n\n/*     */\nBUILD_IDCAMS_DELETE_MEMBER:\nRCDCNT = 11\nJCL.1 = \"//DELETE   EXEC PGM=IDCAMS,COND=(0,LT,DSNXBIND)\"\nJCL.2 = \"//ISPDD    DD DSN=\"ISPFILE\",DISP=SHR\"\nJCL.3 = \"//SYSPRINT DD SYSOUT=*\"\nJCL.4 = \"//SYSIN    DD *\"\nJCL.5 = \"  DELETE  \"ISPFILE\"(\"MEMBER\")  FILE(ISPDD)\"\nJCL.6 = \"  IF LASTCC = 8 THEN\"\nJCL.7 = \"     DO\"\nJCL.8 = \"       SET MAXCC = 0\"\nJCL.9 = \"     END\"\nJCL.10 = \"/*\"\nJCL.11 = \"//\"\nDO J = 1 TO RCDCNT\n   QUEUE JCL.J\nEND\nRETURN\n\n/*     */\nWRITE_BIND_PLAN_JOB:\n\"ALLOC DA('\"ISPFILE\"(\"MEMBER\")') FILE(ISPDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('ISPFILE'('MEMBER'). ***'\n   SAY '*** DB2BINDB EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT 100\nEND\nNUMRCDS = QUEUED()\n\"EXECIO\" NUMRCDS \"DISKW ISPDD (FINIS\"\nSRC = RC\n\"FREE FILE(ISPDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** WRITE ERROR: ERROR WRITING ('ISPFILE'('MEMBER'). ***'\n   SAY '*** DB2BINDB EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nRETURN\n\n/*     */\nSUBMIT_BIND_PLAN_JOB:\n\"SUBMIT ('\"ISPFILE\"(\"MEMBER\")')\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** SUBMIT ERROR: ('ISPFILE'('MEMBER'). ***'\n   SAY '*** DB2BINDB EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DB2BINDC": {"ttr": 10241, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x19\\x00\\x00\\x00\\x93\\x02_\\x00\\x951\\x7f\\x10$\\x00\\x9a\\x00\\xce\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf3@@@'", "ispf": {"version": "01.25", "flags": 0, "createdate": "1993-01-25T00:00:00", "modifydate": "1995-11-13T10:24:00", "lines": 154, "newlines": 206, "modlines": 0, "user": "TECH103"}, "text": "/*  REXX EXEC : ( DB2BINDC ).\n    FUNCTION  : CALLED BY THE DB2 CICS COMPILE TASK ( DB2C ) TO\n                BUILD THE DB2 BIND PLAN SYSIN MEMBER.\n                A BIND JOB WILL BE WRITTEN AND SUBMITTED TO THE\n                SYSA SYSTEM ( DB2SYSX - DSNX ).\n    INPUT     : TSOID.USER.DBRMLIB(&&MEMBER).\n    OUTPUT    : SYSS.TESTCCF.ISPFILE.CNTLLIB(&&MEMBER) -\n                BATCH JOB SUBMITTED TO SYSA SYSTEM CLASS=P.\n                                                                     */\nTRACE O\n/*      */\nHOUSE_KEEPING:\nADDRESS TSO\nARG TSOID ACCTCDE MEMBER DB2COLL DB2SYS\nPARMS = 'TSOID ACCTCDE MEMBER DB2COLL DB2SYS'\nSRC = 0\nDO I = 1 TO 5\n   IPARM = WORD(PARMS,I)\n   XPARM = VALUE(IPARM)\n   IF XPARM \u00ac= '' THEN ITERATE\n   SAY '*** PARM ERROR: MISSING PARM VALUE FOR ('IPARM'). ***'\n   SAY '*** DB2BINDC EXEC TASK CANCELLED - RC = (024). ***'\n   EXIT 024\nEND\nID DB2SYS = 'DSNX' THEN EXIT 0   /* ***   N O O P   D S N X    *** */\nISPFILE = 'SYSS.TESTCCF.ISPFILE.CNTLLIB'\nUCNTL = SYSDSN(\"'\"ISPFILE\"'\")\nIF UCNTL = 'DATASET NOT FOUND' THEN DO\n   IF SRC \u00ac= 0 THEN DO\n      SAY '*** ALLOCATE ERROR: DATASET NOT FOUND ('ISPFILE'). ***'\n      SAY '*** DB2BINDC EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n      EXIT 100\n   END\nEND\nX = MSG(\"OFF\")\n\"FREE FILE(ISPDD)\"\n\n/*     */\nMAIN_ROUTINE_DSNX:\nDB2PLAN = DB2COLL\nDB2NODE = 'DB2Y'\nEXPLN = 'NO'\nCALL BUILD_BIND_PLAN_JOBCARD\nCALL BUILD_IKJEFT01_EXECJCL\nCALL BUILD_BIND_PLAN_SYSIN\nCALL BUILD_IDCAMS_DELETE_MEMBER\nCALL WRITE_BIND_PLAN_JOB\nCALL SUBMIT_BIND_PLAN_JOB\nEXIT 0\n\n/*     S U B R O U T I N E S   S E C T I O N     */\n/*     */\nBUILD_BIND_PLAN_JOBCARD:\nJN = MEMBER\n\"DELSTACK\"\nJCL.1 = \"//\"JN\" JOB\" ACCTCDE\",'\"TSOID\".DB2.BINDPLAN',NOTIFY=\"TSOID\",\"\nJCL.2 = \"//          CLASS=P,MSGCLASS=S,MSGLEVEL=(1,0),REGION=6M\"\nJCL.3 = \"/*JOBPARM SYSAFF=SYSA\"\nDO J = 1 TO 3\n   QUEUE JCL.J\nEND\nRETURN\n\n/*     */\nBUILD_IKJEFT01_EXECJCL:\nRCDCNT = 10\nJCL.1 = \"//DSNXBIND EXEC PGM=IKJEFT01,DYNAMNBR=20\"\nJCL.2 = \"//DBRMLIB  DD DSN=\"TSOID\".USER.DBRMLIB,DISP=SHR\"\nJCL.3 = \"//SYSTSPRT DD SYSOUT=*\"\nJCL.4 = \"//SYSPRINT DD SYSOUT=*\"\nJCL.5 = \"//SYSUDUMP DD SYSOUT=*\"\nJCL.6 = \"//SYSOUT   DD SYSOUT=*\"\nJCL.7 = \"//SYSIN    DD *\"\nJCL.8 = \" GRANT BIND, EXECUTE ON PLAN \"DB2PLAN\" TO PUBLIC;\"\nJCL.9 = \"/*\"\nJCL.10 = \"//SYSTSIN  DD *\"\nDO J = 1 TO RCDCNT\n   QUEUE JCL.J\nEND\nRETURN\n\n/*     */\nBUILD_BIND_PLAN_SYSIN:\nRCDCNT = 16\nREC.1 = \" DSN SYSTEM(\"DB2SYS\")\"\nREC.2 = \" BIND PLAN (\"DB2PLAN\") -\"\nREC.3 = \"      OWNER(\"TSOID\") -\"\nREC.4 = \"      VALIDATE(BIND) -\"\nREC.5 = \"      FLAG(I) -\"\nREC.6 = \"      ACQUIRE(USE) -\"\nREC.7 = \"      ISOLATION(CS) -\"\nREC.8 = \"      RELEASE(COMMIT) -\"\nREC.9 = \"      EXPLAIN(\"EXPLN\") -\"\nREC.10 = \"      ACTION (REPLACE) RETAIN -\"\nREC.11 = \"      PKLIST(\"DB2COLL\".*) -\"\nREC.12 = \"      ENABLE(*)\"\nREC.13 = \" RUN PROGRAM(DSNTIAD) PLAN(DSNTIA31) -\"\nREC.14 = \"     LIB('SYSS.DB2.V2R3M0.\"DB2NODE\".RUNLIB.LOAD')\"\nREC.15 = \" END\"\nREC.16 = \"/*\"\nDO R = 1 TO RCDCNT\n   QUEUE REC.R\nEND\nRETURN\n\n/*     */\nBUILD_IDCAMS_DELETE_MEMBER:\nRCDCNT = 11\nJCL.1 = \"//DELETE   EXEC PGM=IDCAMS,COND=(0,LT,DSNXBIND)\"\nJCL.2 = \"//ISPDD    DD DSN=\"ISPFILE\",DISP=SHR\"\nJCL.3 = \"//SYSPRINT DD SYSOUT=*\"\nJCL.4 = \"//SYSIN    DD *\"\nJCL.5 = \"  DELETE  \"ISPFILE\"(\"MEMBER\")  FILE(ISPDD)\"\nJCL.6 = \"  IF LASTCC = 8 THEN\"\nJCL.7 = \"     DO\"\nJCL.8 = \"       SET MAXCC = 0\"\nJCL.9 = \"     END\"\nJCL.10 = \"/*\"\nJCL.11 = \"//\"\nDO J = 1 TO RCDCNT\n   QUEUE JCL.J\nEND\nRETURN\n\n/*     */\nWRITE_BIND_PLAN_JOB:\n\"ALLOC DA('\"ISPFILE\"(\"MEMBER\")') FILE(ISPDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('ISPFILE'('MEMBER'). ***'\n   SAY '*** DB2BINDC EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT 100\nEND\nNUMRCDS = QUEUED()\n\"EXECIO\" NUMRCDS \"DISKW ISPDD (FINIS\"\nSRC = RC\n\"FREE FILE(ISPDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** WRITE ERROR: ERROR WRITING ('ISPFILE'('MEMBER'). ***'\n   SAY '*** DB2BINDC EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nRETURN\n\n/*     */\nSUBMIT_BIND_PLAN_JOB:\n\"SUBMIT ('\"ISPFILE\"(\"MEMBER\")')\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** SUBMIT ERROR: ('ISPFILE'('MEMBER'). ***'\n   SAY '*** DB2BINDC EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DB2BPROD": {"ttr": 10245, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x15\\x00\\x00\\x00\\x93\\x15O\\x00\\x951\\x7f\\x10$\\x00\\xe9\\x01#\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf3@@@'", "ispf": {"version": "01.21", "flags": 0, "createdate": "1993-06-03T00:00:00", "modifydate": "1995-11-13T10:24:00", "lines": 233, "newlines": 291, "modlines": 0, "user": "TECH103"}, "text": "/*  REXX EXEC : ( DB2BPROD ).\n    FUNCTION  : CALLED BY CCF QA AND PROD TURNOVER PROCESSING SKELETON\n                ( CCFBDB2Q - STEP0160 ) FOR DB2 BATCH COBOL2 PROGRAMS.\n                BUILDS THE PACKAGE/BIND/GRANT JOBS FOR SUBMISSION TO\n                THE SYSB DSNB SYSTEM.\n    INPUT     : SYSS.QA.CCF.DB2.TURNOVER.PARMLIB(&WORKORDR).\n    OUTPUT    : SYSS.QA.CCF.DB2.STAGING.CNTLLIB(&MEMBER).\n                                                                     */\nTRACE O\n/*     */\nHOUSE_KEEPING:\nADDRESS TSO\nARG TSOID MASTER MEMBER WORKORDR\nPARMS = 'TSOID MASTER MEMBER WORKORDR'\nEXIT 0\n/* ***   N O O P   *** */\nSRC = 0\nDO I = 1 TO 4\n   IPARM = WORD(PARMS,I)\n   XPARM = VALUE(IPARM)\n   IF XPARM \u00ac= '' THEN ITERATE\n   SAY '*** PARM ERROR: MISSING PARM VALUE FOR ('IPARM'). ***'\n   SAY '*** DB2BPROD EXEC TASK CANCELLED - RC = (024). ***'\n   EXIT 024\nEND\nX = MSG(\"OFF\")\n\"FREE FILE(PARMDD)\"\n\"FREE FILE(DB2DD)\"\nLIBNODE = POS('PRODSRCE',MASTER)\nIF LIBNODE = 0 THEN EXIT 0\n\n/*     */\nMAIN_ROUTINE_PROD:\nACCTCDE = '5302010530000000'\nDBSUBSYS = 'DSNB'\nOUTMEMB = MEMBER\nPARMLIB = 'SYSS.TECH.COMMON.PARMLIB'\nPARMPDS = 'SYSS.QA.CCF.DB2.TURNOVER.PARMLIB'\nOUTPDS = 'SYSS.QA.CCF.DB2.STAGING.CNTLLIB'\nRUNLIB = 'SYSS.DB2.V2R3M0.DB2B.RUNLIB.LOAD'\nGRANTPDS = 'SYSS.PROD.CCF.DB2.GRANT.CNTLLIB'\nDBRMLIB = 'SYSS.PROD.BATCH.DBRMLIB'\nCALL GET_DB2_PACKAGE_BIND_PARMS\nIF MEMBSW = 'NO' THEN DO\n   SAY '*** PARM ERROR: ENTRY NOT FOUND ('PARMPDS'('WORKORDR') ('MEMBER'). ***'\n   SAY '*** DB2BPROD EXEC SUBTASK CANCELLED - RETURN CODE: ('028'). ***'\n   EXIT 028\nEND\n\"DELSTACK\"\nCALL BUILD_JOBCARD\nCALL BUILD_PACKAGE_IKJEFT01_JCL\nCALL BUILD_PACKAGE_SYSIN\nCALL BUILD_BIND_IKJEFT01_JCL\nCALL BUILD_BIND_SYSIN\nCALL BUILD_IDCAMS_DELETE_MEMBER\nCALL WRITE_DB2_PARMS\nCALL SUBMIT_JOB\nEXIT 0\n\n/*     S U B R O U T I N E S   S E C T I O N     */\n/*     */\nGET_DB2_PACKAGE_BIND_PARMS:\nMEMBSW = 'NO'\nDB2PARM = SYSDSN(\"'\"PARMPDS\"(\"WORKORDR\")'\")\nIF DB2PARM = 'MEMBER NOT FOUND' THEN DO\n   SAY '*** MEMBER ERROR: MEMBER NOT FOUND ('PARMPDS'('WORKORDR'). ***'\n   SAY '*** DB2BPROD EXEC SUBTASK CANCELLED - RETURN CODE: ('028'). ***'\n   EXIT 028\nEND\n\"ALLOC DA('\"PARMPDS\"(\"WORKORDR\")') FILE(PARMDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('PARMPDS'('WORKORDR'). ***'\n   SAY '*** DB2BPROD EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\n\"EXECIO * DISKR PARMDD (FINIS STEM QPARM.\"\nSRC = RC\n\"FREE FILE(PARMDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** EXECIO READ ERROR: ('PARMPDS'('WORKORDR'). ***'\n   SAY '*** DB2BPROD EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nDO I = 1 TO QPARM.0\n   PMEMBER = WORD(QPARM.I,1)\n   COLLID = WORD(QPARM.I,2)\n   IF PMEMBER = MEMBER THEN DO\n      MEMBSW = 'YES'\n      DB2COLL = COLLID\n      DB2PLAN = COLLID\n      LEAVE\n   END\nEND\nRETURN\n\n/*     */\nBUILD_JOBCARD:\nJN = WORKORDR\nJCL.1 = \"//\"JN\" JOB\" ACCTCDE\",'\"TSOID\".DB2.PKG.BIND',NOTIFY=\"TSOID\",\"\nJCL.2 = \"//          CLASS=C,MSGCLASS=S,MSGLEVEL=(1,1),REGION=6M\"\nJCL.3 = \"/*JOBPARM SYSAFF=SYSB\"\nDO J = 1 TO 3\n   QUEUE JCL.J\nEND\nRETURN\n\n/*     */\nBUILD_PACKAGE_IKJEFT01_JCL:\nRCDCNT = 8\nJCL.1 = \"//PACKAGE  EXEC PGM=IKJEFT01,DYNAMNBR=20\"\nJCL.2 = \"//DBRMLIB  DD DSN=\"DBRMLIB\",DISP=SHR\"\nJCL.3 = \"//SYSTSPRT DD SYSOUT=*\"\nJCL.4 = \"//SYSPRINT DD SYSOUT=*\"\nJCL.5 = \"//SYSUDUMP DD SYSOUT=*\"\nJCL.6 = \"//SYSOUT   DD SYSOUT=*\"\nJCL.7 = \"//SYSIN    DD DUMMY,DCB=BLKSIZE=80\"\nJCL.8 = \"//SYSTSIN  DD *\"\nDO J = 1 TO RCDCNT\n   QUEUE JCL.J\nEND\nRETURN\n\n/*     */\nBUILD_PACKAGE_SYSIN:\nRCDCNT = 16\nRCD.1 = \" DSN SYSTEM(\"DBSUBSYS\")\"\nRCD.2 = \" BIND PACKAGE (\"DB2COLL\") -\"\nRCD.3 = \"      OWNER(\"TSOID\") -\"\nRCD.4 = \"      QUALIFIER(BUILD) -\"\nRCD.5 = \"      MEMBER (\"MEMBER\") - \"\nRCD.6 = \"      SQLERROR(NOPACKAGE) -\"\nRCD.7 = \"      VALIDATE(BIND) -\"\nRCD.8 = \"      FLAG(I) -\"\nRCD.9 = \"      ISOLATION (CS) -\"\nRCD.10 = \"      RELEASE(COMMIT) -\"\nRCD.11 = \"      EXPLAIN(NO) -\"\nRCD.12 = \"      CURRENTDATA(NO) -\"\nRCD.13 = \"      ACTION (ADD) -\"\nRCD.14 = \"      ENABLE(*)\"\nRCD.15 = \" END\"\nRCD.16 = \"/*\"\nDO R = 1 TO RCDCNT\n   QUEUE RCD.R\nEND\nRETURN\n\n/*     */\nBUILD_BIND_IKJEFT01_JCL:\nRCDCNT = 8\nJCL.1 = \"//BIND     EXEC PGM=IKJEFT01,DYNAMNBR=20,COND=(0,LT,PACKAGE)\"\nJCL.2 = \"//DBRMLIB  DD DSN=\"DBRMLIB\",DISP=SHR\"\nJCL.3 = \"//SYSTSPRT DD SYSOUT=*\"\nJCL.4 = \"//SYSPRINT DD SYSOUT=*\"\nJCL.5 = \"//SYSUDUMP DD SYSOUT=*\"\nJCL.6 = \"//SYSOUT   DD SYSOUT=*\"\nJCL.7 = \"//SYSIN    DD DSN=\"GRANTPDS\"(\"MEMBER\"),DISP=SHR\"\nJCL.8 = \"//SYSTSIN  DD *\"\nDO J = 1 TO RCDCNT\n   QUEUE JCL.J\nEND\nRETURN\n\n/*     */\nBUILD_BIND_SYSIN:\nRCDCNT = 16\nREC.1 = \" DSN SYSTEM(\"DBSUBSYS\")\"\nREC.2 = \" BIND PLAN (\"DB2PLAN\") -\"\nREC.3 = \"      OWNER(\"TSOID\") -\"\nREC.4 = \"      VALIDATE(BIND) -\"\nREC.5 = \"      FLAG(I) -\"\nREC.6 = \"      ACQUIRE(USE) -\"\nREC.7 = \"      ISOLATION(CS) -\"\nREC.8 = \"      RELEASE(COMMIT) -\"\nREC.9 = \"      EXPLAIN(NO) -\"\nREC.10 = \"      ACTION (REPLACE) -\"\nREC.11 = \"      PKLIST(\"DB2COLL\".*) -\"\nREC.12 = \"      ENABLE(*)\"\nREC.13 = \" RUN PROGRAM(DSNTIAD) PLAN(DSNTIA31) -\"\nREC.14 = \"     LIB('\"RUNLIB\"')\"\nREC.15 = \" END\"\nREC.16 = \"/*\"\nDO R = 1 TO RCDCNT\n   QUEUE REC.R\nEND\nRETURN\n\n/*     */\nBUILD_IDCAMS_DELETE_MEMBER:\nRCDCNT = 8\nJCL.1 = \"//DELETE   EXEC PGM=IDCAMS,COND=(0,LT)\"\nJCL.2 = \"//ISPFILE  DD DSN=\"OUTPDS\",DISP=SHR\"\nJCL.3 = \"//SYSPRINT DD SYSOUT=*\"\nJCL.4 = \"//SYSIN    DD *\"\nJCL.5 = \"  DELETE   \"OUTPDS\"(\"MEMBER\")  -\"\nJCL.6 = \"  FILE(ISPFILE)\"\nJCL.7 = \"/*\"\nJCL.8 = \"//\"\nDO J = 1 TO RCDCNT\n   QUEUE JCL.J\nEND\nRETURN\n\n/*     */\nWRITE_DB2_PARMS:\n\"ALLOC DA('\"OUTPDS\"(\"OUTMEMB\")') FILE(DB2DD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('OUTPDS'('OUTMEMB'). ***'\n   SAY '*** DB2BPROD EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nNUMRCDS = QUEUED()\n\"EXECIO\" NUMRCDS \"DISKW DB2DD (FINIS\"\nSRC = RC\n\"FREE FILE(DB2DD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** WRITE ERROR: ERROR WRITING ('OUTPDS'('OUTMEMB').  ***'\n   SAY '*** DB2BPROD EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nRETURN\n\n/*     */\nSUBMIT_JOB:\n\"SUBMIT ('\"OUTPDS\"(\"MEMBER\")')\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** SUBMIT ERROR: ('OUTPDS'('MEMBER'). ***'\n   SAY '*** DB2BPROD EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DB2CHKSS": {"ttr": 10250, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x00\\x00\\x95)\\x1f\\x00\\x953\\x9f\\x14@\\x00E\\x00\\xf7\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf3@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1995-10-18T00:00:00", "modifydate": "1995-12-05T14:40:00", "lines": 69, "newlines": 247, "modlines": 0, "user": "TECH103"}, "text": "/*  REXX EXEC : ( DB2CHKSS ).\n    FUNCTION  : CALLED BY CCF QA AND PROD TURNOVER PROCESSING SKELETONS\n                ( CCFBDB2Q, CCFCDB2Q, AND CCFDYLDB ).\n                VERIFIES THE EXISTENCE OF THE PACKAGE/BIND PARMLIB\n                WORKORDER MEMBER TO SET CONDITION CODE RETURN FOR\n                DB2 SUBSYSTEM NAME FOR V2 OR V3 DB2.\n    INPUT     : SYSS.QA.CCF.DB2.TURNOVER.PARMLIB(&WORKORDR).\n                                                                     */\nTRACE O\n/*     */\nHOUSE_KEEPING:\nADDRESS TSO\nARG MASTER MEMBER WORKORDR\nPARMS = 'MASTER MEMBER WORKORDR'\nSRC = 0\nDO I = 1 TO 3\n   IPARM = WORD(PARMS,I)\n   XPARM = VALUE(IPARM)\n   IF XPARM \u00ac= '' THEN ITERATE\n   SAY '*** PARM ERROR: MISSING PARM VALUE FOR ('IPARM'). ***'\n   SAY '*** DB2CHKSS EXEC TASK CANCELLED - RC = (024). ***'\n   EXIT 024\nEND\nEXIT 3\n/* ***        N O O P        *** */\nX = MSG(\"OFF\")\n\"FREE FILE(TESTDD)\"\n\"FREE FILE(QADD)\"\nLIBNODE = POS('QASRCE',MASTER)\nIF LIBNODE = 0 THEN EXIT 0\nERC = 2\nDB2_VERSION3 = 'SYSS.DB2.V3R1M0.'\nQACCF = 'SYSS.QA.CCF.DB2.TURNOVER.PARMLIB'\n/*     */\nMAIN_ROUTINE:\nCALL CHECK_QACCF_PARMS\nEXIT ERC\n/*\n       S U B R O U T I N E S   S E C T I O N     */\n/*     */\nCHECK_QACCF_PARMS:\nADDRESS TSO\nDB2PARM = SYSDSN(\"'\"QACCF\"(\"WORKORDR\")'\")\nIF DB2PARM = 'MEMBER NOT FOUND' THEN RETURN\n\"ALLOC DA('\"QACCF\"(\"WORKORDR\")') FILE(QADD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('QACCF'('WORKORDR'). ***'\n   SAY '*** DB2CHKSS EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\n\"EXECIO * DISKR QADD (FINIS STEM QPARM.\"\nSRC = RC\n\"FREE FILE(QADD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** EXECIO READ ERROR: ('QACCF'('WORKORDR'). ***'\n   SAY '*** DB2CHKSS EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nDO I = 1 TO QPARM.0\n   PMEMBER = WORD(QPARM.I,1)\n   VERSION = WORD(QPARM.I,7)\n   IF PMEMBER = MEMBER THEN DO\n      DB2VERS = VERSION\n      LEAVE\n   END\nEND\nIF DB2VERS = DB2_VERSION3 THEN ERC = 3\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DB2COBCK": {"ttr": 10252, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x94\\x04\\x7f\\x00\\x95)\\x9f\\x17C\\x00@\\x00@\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf3@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1994-02-16T00:00:00", "modifydate": "1995-10-26T17:43:00", "lines": 64, "newlines": 64, "modlines": 0, "user": "TECH103"}, "text": "/* REXX EXEC : ( DB2COBCK ).\n   FUNCTION  : READS SOURCE PROGRAM STATEMENTS TO DETERINE COBOL-II\n               COMPILE TYPE FOR QA MOVEMENT COMPILE DB2 ONLY.         */\nTRACE O\n/*     */\nHOUSE_KEEPING:\nADDRESS TSO\nARG MASTER MEMBER\nPARMS = 'MASTER MEMBER'\nDO I = 1 TO 2\n   IPARM = WORD(PARMS,I)\n   XPARM = VALUE(IPARM)\n   IF XPARM \u00ac= '' THEN ITERATE\n   SAY '*** PARM ERROR: MISSING PARM VALUE FOR ('IPARM'). ***'\n   SAY '*** DB2COBCK EXEC TASK CANCELLED - RC = (024). ***'\n   EXIT 024\nEND\nOPTIMIZE_SW = 'NO'\nC2P = 'APOST,LIB,CMPR2,RES,RENT,DYNAM'\n\n/*     */\nMAIN_ROUTINE:\nCALL CHECK_NATIVE_FLAG\nCALL SET_QA_COMPILE_TYPE_RETURN_CODE\nEXIT EXITRC\n\n/*     S U B R O U T I N E   S E C T I O N     */\n/*     */\nCHECK_NATIVE_FLAG:\nNATIVE_SW = 'NO'\nLIBDSN = \"'\"MASTER\"(\"MEMBER\")'\"\nLIBDD = LIBALLOC(LIBDSN)  /* DYNALLOC LIBMASTER W/LAM; RET DDNAME*/\nIF LIBDD = \"ERROR\" THEN DO\n   ERC = 100\n   SAY '*** DYNAMIC ALLOCATION ERROR: ('MASTER'). ***'\n   SAY '*** CANNOT READ COBOL2 COMPILE TYPE FLAG FOR ('MEMBER') PROGRAM. ***'\n   SAY '*** DB2COBCK EXEC SUBTASK CANCELLED - RC = ('ERC'). ***'\n   EXIT ERC\nEND\n\"EXECIO * DISKR\" LIBDD \"(FINIS STEM DATA.\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   ERC = 100\n   SAY '*** EXECIO READ ERROR: ('MASTER'('MEMBER'). ***'\n   SAY '*** CANNOT READ COBOL2 COMPILE TYPE FLAG FOR ('MEMBER') PROGRAM. ***'\n   SAY '*** DB2COBCK EXEC SUBTASK CANCELLED - RC = ('ERC'). ***'\n   EXIT ERC\nEND\nDO I = 1 TO DATA.0\n   NOCMPR2 = POS('NOCMPR2-FLAG',DATA.I)\n   IF NOCMPR2 \u00ac= 0 THEN DO\n      NATIVE_SW = 'YES'\n      C2P = 'APOST,LIB,NOCMPR2,RES,RENT,DYNAM'\n      LEAVE\n   END\nEND\nRETURN\n/*     */\nSET_QA_COMPILE_TYPE_RETURN_CODE:\nIF NATIVE_SW = 'YES' & OPTIMIZE_SW = 'NO'  THEN EXITRC = 1\nIF NATIVE_SW = 'NO'  & OPTIMIZE_SW = 'NO'  THEN EXITRC = 2\nIF NATIVE_SW = 'YES' & OPTIMIZE_SW = 'YES' THEN EXITRC = 3\nIF NATIVE_SW = 'NO'  & OPTIMIZE_SW = 'YES' THEN EXITRC = 4\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DB2DYLDQ": {"ttr": 10254, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01 \\x00\\x00\\x00\\x91#O\\x00\\x95)\\x9f\\x16E\\x01^\\x00)\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf3@@@'", "ispf": {"version": "01.32", "flags": 0, "createdate": "1991-08-22T00:00:00", "modifydate": "1995-10-26T16:45:00", "lines": 350, "newlines": 41, "modlines": 0, "user": "TECH103"}, "text": "/* REXX EXEC : ( DB2DYLDQ ).\n   FUNCTION: INVOKED BY CCF SKELETON JCL ( CCFDYLDB ) FOR PROMOTION OF\n             DYLAKOR/DB2 SOURCE PROGRAMS INTO QA OR PROD LIBRARIES.\n             THIS REXX EXEC PROGRAM WILL PERFORM THE FOLLOWING TASKS:\n             1. READ/CHECK THE SOURCE PROGRAM TO GET THE DYLAKOR\n                REPORT AND DB2 LOAD MODULE NAMES, AND THE DB2 PLAN.\n             3. BUILD THE IDCAMS DELETE LOAD MODULE SYSIN MEMBER.\n             4. BUILD THE IEBCOPY COPY LOAD MODULE SYSIN MEMBER.\n             5. BUILD THE DB2 BIND CONTROL STATEMENTS SYSIN MEMBER.\n             6. BUILD THE DB2 GRANT CONTROL STATEMENTS SYSIN MEMBER.\n             7. BUILD IEHPROGM RENAME GENERATED ASSEMBLER PROGRAM.\n             8. BUILD LINKAGE EDITOR SYSLIN CONTROL SYSIN MEMBER.\n             9. BUILD LINKAGE EDITOR SYSLIN CONTROL SYSIN MEMBER.\n             INPUT  : ( SYS1.QASRCE.MASTER(&MEMBER).\n             OUTPUT : ( SYSS.QA.CCF.DYLAKOR.DYLCOPY.CNTLLIB(&MEMBER).\n                      ( SYSS.QA.CCF.DYLAKOR.DYLDEL01.CNTLLIB(&MEMBER).\n                      ( SYSS.QA.CCF.DYLAKOR.DYLDEL02.CNTLLIB(&MEMBER).\n                      ( SYSS.QA.CCF.DYLAKOR.DB2BIND.CNTLLIB(&MEMBER).\n                      ( SYSS.QA.CCF.DYLAKOR.DB2GRANT.CNTLLIB(&MEMBER).\n                      ( SYSS.QA.CCF.DYLAKOR.IEHPROGM.CNTLLIB(&MEMBER).\n                      ( SYSS.QA.CCF.DYLAKOR.LINKEDIT.CNTLLIB(&MEMBER).\n                                                                      */\nTRACE O\n/*     */\nHOUSE_KEEPING:\nADDRESS TSO\nARG TSOID MASTER MEMBER WORKORDR\nPARMS = 'TSOID MASTER MEMBER WORKORDR'\nDO I = 1 TO 4\n   IPARM = WORD(PARMS,I)\n   XPARM = VALUE(IPARM)\n   IF XPARM \u00ac= '' THEN ITERATE\n   SAY '*** PARM ERROR: MISSING PARM VALUE FOR ('IPARM'). ***'\n   SAY '*** DB2DYLDQ EXEC TASK CANCELLED - RC = (024). ***'\n   EXIT 024\nEND\nMCNT = 2\nPARMLIB = 'SYSS.TECH.COMMON.PARMLIB'\nDB2PARM = SYSDSN(\"'\"PARMLIB\"(DB2ADMIN)'\")\nIF DB2PARM = 'MEMBER NOT FOUND' THEN DO\n   SAY '*** MEMBER ERROR: MEMBER NOT FOUND ('PARMLIB'(DB2ADMIN). ***'\n   SAY '*** DB2DYLDQ EXEC SUBTASK CANCELLED - RETURN CODE: ('028'). ***'\n   EXIT 028\nEND\nX = MSG(\"OFF\")\n\"FREE FILE(PARMDD)\"\n\"FREE FILE(DB2DD)\"\nDEL.1 = \"  IF LASTCC = 8 THEN\"\nDEL.2 = \"     DO\"\nDEL.3 = \"       SET MAXCC = 0\"\nDEL.4 = \"     END\"\nLIBNODE = POS('PRODSRCE',MASTER)\nIF LIBNODE \u00ac= 0 THEN DO\n   DB2SYS = 'DSNA'\n   CALL GET_DYLAKOR_MODULE_NAMES\n   IF ASMSW = 'NO' THEN CALL ASSEMBLE_NAME_ERROR\n   IF RPTSW = 'NO' THEN CALL REPORT_NAME_ERROR\n   PARMPDS = 'SYSS.QA.CCF.DB2.TURNOVER.PARMLIB'\n   CALL GET_DB2_SUBSYSTEM_NAME\n   CALL BUILD_DB2_BIND_SYSIN\n   OUTMEMB = 'DB2BIND'\n   CALL WRITE_SYSIN_MEMBER\n   CALL BUILD_DB2_GRANT_SYSIN\n   OUTMEMB = 'DB2GRANT'\n   CALL WRITE_SYSIN_MEMBER\n   EXIT 2\nEND\nLIBNODE = POS('EMRGSRCE',MASTER)\nIF LIBNODE \u00ac= 0 THEN DO\n   DB2SYS = 'DSNA'\n   CALL GET_DYLAKOR_MODULE_NAMES\n   IF ASMSW = 'NO' THEN CALL ASSEMBLE_NAME_ERROR\n   IF RPTSW = 'NO' THEN CALL REPORT_NAME_ERROR\n   LOADLIB = 'SYS1.EMERGNCY.BATCH.LOADLIB'\n   PARMPDS = 'SYSS.QA.CCF.DB2.TURNOVER.PARMLIB'\n   CALL GET_DB2_SUBSYSTEM_NAME\n   CALL BUILD_IDCAMS_DELETE_SYSIN\n   OUTMEMB = 'DYLDEL02'\n   CALL WRITE_SYSIN_MEMBER\n   CALL BUILD_DB2_BIND_SYSIN\n   OUTMEMB = 'DB2BIND'\n   CALL WRITE_SYSIN_MEMBER\n   CALL BUILD_DB2_GRANT_SYSIN\n   OUTMEMB = 'DB2GRANT'\n   CALL WRITE_SYSIN_MEMBER\n   EXIT 3\nEND\nLIBNODE = POS('QASRCE',MASTER)\nIF LIBNODE = 0 THEN EXIT 0\n/*\n        M A I N   R O U T I N E   S E C T I O N     */\n/*     */\nMAIN_ROUTINE_QA:\nADDRESS TSO\nCALL GET_DYLAKOR_MODULE_NAMES\nIF ASMSW = 'NO' THEN CALL ASSEMBLE_NAME_ERROR\nIF RPTSW = 'NO' THEN CALL REPORT_NAME_ERROR\nLOADLIB = 'SYS1.TEST.BATCH.LOADLIB'\nPARMPDS = 'SYSS.QA.CCF.DB2.TURNOVER.PARMLIB'\n\"%DB2QAPRM\" MASTER MEMBER WORKORDR\nERC = RC\nIF ERC \u00ac= 0 THEN EXIT ERC\nCALL GET_DB2_SUBSYSTEM_NAME\nIF MEMBSW = 'NO' THEN DO\n   SAY\n   SAY '*** PARM ERROR: ENTRY NOT FOUND ('PARMPDS'('WORKORDR') ('MEMBER'). ***'\n   SAY '*** DB2 PACKAGE/BIND/GRANT SYSIN MEMBERS CANNOT BE WRITTEN FOR QA. ***'\n   SAY '> REJECT MEMBER, PROGRAMMER MUST SPECIFY TURNOVER (YES) COMPILE OPTION.'\n   SAY '*** DB2DYLDQ EXEC SUBTASK CANCELLED - RETURN CODE: ('028'). ***'\n   SAY\n   EXIT 028\nEND\nCALL BUILD_IDCAMS_DELETE_SYSIN\nOUTMEMB = 'DYLDEL01'\nCALL WRITE_SYSIN_MEMBER\nLOADLIB = 'SYS1.QA.BATCH.LOADLIB'\nCALL BUILD_IDCAMS_DELETE_SYSIN\nOUTMEMB = 'DYLDEL02'\nCALL WRITE_SYSIN_MEMBER\nCALL BUILD_IEBCOPY_COPY_SYSIN\nOUTMEMB = 'DYLCOPY'\nCALL WRITE_SYSIN_MEMBER\nCALL BUILD_DB2_BIND_SYSIN\nOUTMEMB = 'DB2BIND'\nCALL WRITE_SYSIN_MEMBER\nCALL BUILD_DB2_GRANT_SYSIN\nOUTMEMB = 'DB2GRANT'\nCALL WRITE_SYSIN_MEMBER\nCALL BUILD_IEHPROGM_SYSIN\nOUTMEMB = 'IEHPROGM'\nCALL WRITE_SYSIN_MEMBER\nCALL BUILD_LINKEDIT_SYSIN\nOUTMEMB = 'LINKEDIT'\nCALL WRITE_SYSIN_MEMBER\nEXIT 1\n/*\n       S U B R O U T I N E   S E C T I O N     */\n/*     */\nGET_DYLAKOR_MODULE_NAMES:\nASMSW = 'NO'\nRPTSW = 'NO'\nLIBDSN = \"'\"MASTER\"(\"MEMBER\")'\"\nLIBDD = LIBALLOC(LIBDSN)\nIF LIBDD = \"ERROR\" THEN DO\n   ERC = 100\n   SAY '*** DYNAMIC ALLOCATION ERROR: ('MASTER'). ***'\n   SAY '*** MODULE NAMES CANNOT BE READ FOR ('MEMBER') PROGRAM. ***'\n   SAY '*** DB2DYLDQ EXEC SUBTASK CANCELLED - RC = ('ERC'). ***'\n   EXIT ERC\nEND\nADDRESS TSO \"EXECIO * DISKR\" LIBDD \"(FINIS STEM PROGDATA.\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** INVALID OR MISSING LIBRARIAN MEMBER NAME. ***'\n   SAY '*** CCF DB2B EXEC TASK CANCELLED - RC = '024'. ***'\n   EXIT\nEND\nDO I = 1 TO PROGDATA.0\n   KEY1 = POS('OPTION FREEZE',PROGDATA.I)\n   IF KEY1 \u00ac= 0 THEN DO\n      KEY2 = WORDPOS('FREEZE',PROGDATA.I)\n      INDEXKEY = KEY2 + 1\n      DYLMOD = WORD(PROGDATA.I,INDEXKEY)\n      RPTSW = 'YES'\n      MOD.1 = DYLMOD\n   END\n   KEY3 = POS('TSO_ATTACH PLANID',PROGDATA.I)\n   IF KEY3 \u00ac= 0 THEN DO\n      KEY4 = WORDPOS('PLANID',PROGDATA.I)\n      INDEXKEY = KEY4 + 1\n      ASMMOD = WORD(PROGDATA.I,INDEXKEY)\n      DB2PLAN = WORD(PROGDATA.I,INDEXKEY)\n      ASMSW = 'YES'\n      MOD.2 = ASMMOD\n   END\nEND\nRETURN\n/*     */\nGET_DB2_SUBSYSTEM_NAME:\nMEMBSW = 'NO'\nDB2PARM = SYSDSN(\"'\"PARMPDS\"(\"WORKORDR\")'\")\nIF DB2PARM = 'MEMBER NOT FOUND' THEN DO\n   SAY '*** MEMBER ERROR: MEMBER NOT FOUND ('PARMPDS'('WORKORDR'). ***'\n   SAY '*** DB2QAPBN EXEC SUBTASK CANCELLED - RETURN CODE: ('028'). ***'\n   RETURN\nEND\n\"ALLOC DA('\"PARMPDS\"(\"WORKORDR\")') FILE(PARMDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('PARMPDS'('WORKORDR'). ***'\n   SAY '*** DB2QAPBN EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\n\"EXECIO * DISKR PARMDD (FINIS STEM QPARM.\"\nSRC = RC\n\"FREE FILE(PARMDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** EXECIO READ ERROR: ('PARMPDS'('WORKORDR'). ***'\n   SAY '*** DB2QAPBN EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nDO I = 1 TO QPARM.0\n   PMEMBER = WORD(QPARM.I,1)\n   PROGTYP = WORD(QPARM.I,3)\n   DB2SUB = WORD(QPARM.I,5)\n   IF PMEMBER = MEMBER & PROGTYP = 'BATCH' THEN DO\n      MEMBSW = 'YES'\n      IF DB2SUB \u00ac= '' THEN DB2SYS = DB2SUB\n      LEAVE\n   END\nEND\nRETURN\n/*     */\nBUILD_IDCAMS_DELETE_SYSIN:\n\"DELSTACK\"\nDO M = 1 TO MCNT\n   RECORD = \"  DELETE \"LOADLIB\"(\"MOD.M\") FILE(LOADLIB)\"\n   QUEUE RECORD\nEND\nDO D = 1 TO 4\n   QUEUE DEL.D\nEND\nRETURN\n/*     */\nBUILD_IEBCOPY_COPY_SYSIN:\nI = 0\nM = 0\nCNTL = \"       SELECT MEMBER=(\"\n\"DELSTACK\"\nRECORD = \"  COPY OUTDD=OUTDD1\"\nQUEUE RECORD\nRECORD = \"       INDD=((INDD1,R))\"\nQUEUE RECORD\nDO MCNT\n   M = M + 1\n   I = I + 1\n   IF I = 1 THEN SYSIN = CNTL||MOD.M\n   IF (I > 1) & (I < 5) THEN SYSIN = SYSIN||\",\"||MOD.M\n   IF (I = 5) THEN DO\n      SYSIN = SYSIN||\",\"||MOD.M||\")\"\n      QUEUE SYSIN\n      I = 0\n   END\nEND\nIF I > 0 THEN DO\n   SYSIN = SYSIN||\")\"\n   QUEUE SYSIN\nEND\nRETURN\n/*     */\nBUILD_DB2_BIND_SYSIN:\n\"DELSTACK\"\nBIND.1 = \" DSN SYSTEM(\"DB2SYS\")\"\nBIND.2 = \" BIND PLAN(\"DB2PLAN\") -\"\nBIND.3 = \"      RETAIN -\"\nBIND.4 = \"      MEMBER(\"MEMBER\")\"\nBIND.5 = \" END\"\nDO B = 1 TO 5\n   QUEUE BIND.B\nEND\nRETURN\n/*     */\nBUILD_DB2_GRANT_SYSIN:\n\"DELSTACK\"\nCOMRCD = \"  COMMIT;\"\nBNDCNT = 4\nBND.1 = \"        GRANT\"\nBND.2 = \"        BIND,\"\nBND.3 = \"        EXECUTE\"\nBND.4 = \"  ON PLAN \"DB2PLAN\" TO\"\n\"ALLOC DA('\"PARMLIB\"(DB2ADMIN)') FILE(PARMDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('PARMLIB'(DB2ADMIN). ***'\n   SAY '*** DB2DYLDQ EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\n\"EXECIO * DISKR PARMDD (FINIS STEM AUTH.\"\nSRC = RC\n\"FREE FILE(PARMDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** EXECIO READ ERROR: ('PARMLIB'(DB2ADMIN). ***'\n   SAY '*** DB2DYLDQ EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nDO B = 1 TO BNDCNT\n   QUEUE BND.B\nEND\nDO I = 1 TO AUTH.0\n   AUTHUSR = WORD(AUTH.I,1)\n   AUSER = TSOID','\n   IF AUSER = AUTHUSR THEN ITERATE\n   DB2AUTH = '        '||AUTHUSR\n   QUEUE DB2AUTH\nEND\nQUEUE COMRCD\nRETURN\n/*     */\nBUILD_IEHPROGM_SYSIN:\n\"DELSTACK\"\nCONTX = \"         X\"\nRENAM = \"    RENAME  DSNAME=SYSS.QA.CCF.DYLAKOR.ASMLIB,VOL=3390=SYS017,\"\nRCD.1 = RENAM||CONTX\nRCD.2 = \"               NEWNAME=\"MEMBER\",MEMBER=\"ASMMOD\nDO R = 1 TO 2\n   QUEUE RCD.R\nEND\nRETURN\n/*     */\nBUILD_LINKEDIT_SYSIN:\n\"DELSTACK\"\nRCD.1 = \"  INCLUDE DB2LIB(DSNELI)\"\nRCD.2 = \"  NAME \"ASMMOD\"(R)\"\nDO R = 1 TO 2\n   QUEUE RCD.R\nEND\nRETURN\n/*     */\nWRITE_SYSIN_MEMBER:\n\"ALLOC DA('SYSS.QA.CCF.DYLAKOR.\"OUTMEMB\".CNTLLIB(\"MEMBER\")') FILE(DYLDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('OUTMEMB'('MEMBER'). ***'\n   SAY '*** DB2DYLDQ EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT 8\nEND\nRCDCNT = QUEUED()\n\"EXECIO\" RCDCNT \"DISKW DYLDD (FINIS\"\nSRC = RC\n\"FREE FILE(DYLDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** EXECIO WRITE ERROR: ('OUTMEMB'('MEMBER'). ***'\n   SAY '*** DB2DYLDQ EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT 8\nEND\nRETURN\n/*     */\nASSEMBLE_NAME_ERROR:\nERC = 024\nSAY '*** SYNTAX REQUIREMENTS ERROR FOR ('MEMBER') PROGRAM. ***'\nSAY '*** ASSEMBLE MODULE NAME NOT FOUND FROM KEY SYNTAX DATA. ***'\nSAY '*** DB2DYLDQ EXEC SUBTASK CANCELLED - RC = ('ERC'). ***'\nEXIT ERC\n/*     */\nREPORT_NAME_ERROR:\nERC = 024\nSAY '*** SYNTAX REQUIREMENTS ERROR FOR ('MEMBER') PROGRAM. ***'\nSAY '*** REPORTS MODULE NAME NOT FOUND FROM KEY SYNTAX DATA. ***'\nSAY '*** DB2DYLDQ EXEC SUBTASK CANCELLED - RC = ('ERC'). ***'\nEXIT ERC\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DB2DYLGT": {"ttr": 10502, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94 \\x8f\\x00\\x94 \\x8f\\x11I\\x00q\\x00q\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-07-27T00:00:00", "modifydate": "1994-07-27T11:49:00", "lines": 113, "newlines": 113, "modlines": 0, "user": "TECH103"}, "text": "/*  REXX EXEC : ( DB2DYLGT ).\n    FUNCTION  : CALLED BY DB2B COMPILE TASK TO BUILD THE GRANT\n                AUTHORIZATION SYSIN MEMBER FOR EMERGENCY BATCH COMPILES\n                FROM AN EMERGENCY CCFID ( TECH290 THRU TECH295 ).\n                *****   D Y L A K O R / D B 2   *****\n    INPUT     : SYSS.TECH.COMMON.PARMLIB(DB2ADMIN).\n    OUTPUT    : &TSOID.USER.DBRMLIB(&PROGRAM).\n                                                                     */\nTRACE O\n/*     */\nHOUSE_KEEPING:\nADDRESS TSO\nARG TSOID MEMBER DB2PLAN\nPARMS = 'TSOID MEMBER DB2PLAN'\nSRC = 0\nDO I = 1 TO 3\n   IPARM = WORD(PARMS,I)\n   XPARM = VALUE(IPARM)\n   IF XPARM \u00ac= '' THEN ITERATE\n   SAY '*** PARM ERROR: MISSING PARM VALUE FOR ('IPARM'). ***'\n   SAY '*** DB2DYLGT EXEC TASK CANCELLED - RC = (024). ***'\n   EXIT 024\nEND\nX = MSG(\"OFF\")\n\"FREE FILE(PARMDD)\"\n\"FREE FILE(DB2DD)\"\nDUNIT = 'APPLTA'\nTSOPRFX = SUBSTR(TSOID,1,4)\nIF TSOPRFX = 'TECH' THEN DUNIT = 'SMS'\nUCNTL = SYSDSN(USER.DBRMLIB)\nIF UCNTL = 'DATASET NOT FOUND' THEN DO\n\"ATTRIB ATTRB1 DSORG(PO) RECFM(F,B) LRECL(80) BLKSIZE(27920)\"\n\"ALLOC DA(USER.DBRMLIB) NEW SPACE(3,1) DIR(44) USING(ATTRB1) UNIT(\"DUNIT\")\"\n   SRC = RC\n   IF SRC \u00ac= 0 THEN DO\n   SAY '*** ALLOCATE ERROR: ERROR ALLOCATING DATASET (USER.DBRMLIB). ***'\n   SAY '*** DB2DYLGT EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\n   END\nEND\n\"FREE DA(USER.DBRMLIB)\"\nOUTPDS = TSOID'.USER.DBRMLIB'\nPARMLIB = 'SYSS.TECH.COMMON.PARMLIB'\n\n/*     */\nMAIN_ROUTINE:\nCALL BUILD_GRANT_SYSIN\nCALL WRITE_DB2_PARMS\nEXIT 0\n\n/*     S U B R O U T I N E S   S E C T I O N     */\n/*     */\nBUILD_GRANT_SYSIN:\n\"DELSTACK\"\nCOMRCD = \"  COMMIT;\"\nBNDCNT = 4\nBND.1 = \"        GRANT\"\nBND.2 = \"        BIND,\"\nBND.3 = \"        EXECUTE\"\nBND.4 = \"  ON PLAN \"DB2PLAN\" TO\"\nDB2PARM = SYSDSN(\"'\"PARMLIB\"(DB2ADMIN)'\")\nIF DB2PARM = 'MEMBER NOT FOUND' THEN DO\n   SAY '*** MEMBER ERROR: MEMBER NOT FOUND ('PARMLIB'(DB2ADMIN). ***'\n   SAY '*** DB2DYLGT EXEC SUBTASK CANCELLED - RETURN CODE: ('028'). ***'\n   EXIT 028\nEND\n\"ALLOC DA('\"PARMLIB\"(DB2ADMIN)') FILE(PARMDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('PARMLIB'(DB2ADMIN). ***'\n   SAY '*** DB2DYLGT EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\n\"EXECIO * DISKR PARMDD (FINIS STEM AUTH.\"\nSRC = RC\n\"FREE FILE(PARMDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** EXECIO READ ERROR: ('PARMLIB'(DB2ADMIN). ***'\n   SAY '*** DB2DYLGT EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nDO B = 1 TO BNDCNT\n   QUEUE BND.B\nEND\nDO I = 1 TO AUTH.0\n   AUTHUSR = WORD(AUTH.I,1)\n   AUSER = TSOID','\n   IF AUSER = AUTHUSR THEN ITERATE\n   DB2AUTH = '        '||AUTHUSR\n   QUEUE DB2AUTH\nEND\nQUEUE COMRCD\nRETURN\n\n/*     */\nWRITE_DB2_PARMS:\n\"ALLOC DA('\"OUTPDS\"(\"MEMBER\")') FILE(DB2DD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('OUTPDS'('MEMBER'). ***'\n   SAY '*** DB2DYLGT EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nNUMRCDS = QUEUED()\n\"EXECIO\" NUMRCDS \"DISKW DB2DD (FINIS\"\nSRC = RC\n\"FREE FILE(DB2DD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** WRITE ERROR: ERROR WRITING ('OUTPDS'('MEMBER').  ***'\n   SAY '*** DB2DYLGT EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DB2EBGRT": {"ttr": 10505, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\x00\\x00\\x93!\\x1f\\x00\\x93&o\\x11 \\x00\\x81\\x00\\x7f\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf3@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "1993-07-30T00:00:00", "modifydate": "1993-09-23T11:20:00", "lines": 129, "newlines": 127, "modlines": 0, "user": "TECH103"}, "text": "/*  REXX EXEC : ( DB2EGRNT ).\n    FUNCTION  : CALLED BY DB2B COMPILE TASK TO BUILD THE GRANT\n                AUTHORIZATION SYSIN MEMBER FOR EMERGENCY BATCH COMPILES\n                FROM AN EMERGENCY CCFID ( TECH290 THRU TECH295 ).\n    INPUT     : SYSS.TECH.COMMON.PARMLIB(DB2ADMIN).\n    OUTPUT    : &TSOID.USER.DBRMLIB(&PROGRAM).\n                                                                     */\nTRACE O\n/*     */\nHOUSE_KEEPING:\nADDRESS TSO\nARG TSOID MEMBER DB2COLL DB2PLAN\nPARMS = 'TSOID MEMBER DB2COLL DB2PLAN'\nSRC = 0\nDO I = 1 TO 4\n   IPARM = WORD(PARMS,I)\n   XPARM = VALUE(IPARM)\n   IF XPARM \u00ac= '' THEN ITERATE\n   SAY '*** PARM ERROR: MISSING PARM VALUE FOR ('IPARM'). ***'\n   SAY '*** DB2EGRNT EXEC TASK CANCELLED - RC = (024). ***'\n   EXIT 024\nEND\nX = MSG(\"OFF\")\n\"FREE FILE(PARMDD)\"\n\"FREE FILE(DB2DD)\"\nDUNIT = 'APPLTA'\nTSOPRFX = SUBSTR(TSOID,1,4)\nIF TSOPRFX = 'TECH' THEN DUNIT = 'SMS'\nUCNTL = SYSDSN(USER.DBRMLIB)\nIF UCNTL = 'DATASET NOT FOUND' THEN DO\n\"ATTRIB ATTRB1 DSORG(PO) RECFM(F,B) LRECL(80) BLKSIZE(27920)\"\n\"ALLOC DA(USER.DBRMLIB) NEW SPACE(3,1) DIR(44) USING(ATTRB1) UNIT(\"DUNIT\")\"\n   SRC = RC\n   IF SRC \u00ac= 0 THEN DO\n   SAY '*** ALLOCATE ERROR: ERROR ALLOCATING DATASET (USER.DBRMLIB). ***'\n   SAY '*** DB2EGRNT EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\n   END\nEND\n\"FREE DA(USER.DBRMLIB)\"\nOUTPDS = TSOID'.USER.DBRMLIB'\nPARMLIB = 'SYSS.TECH.COMMON.PARMLIB'\n\n/*     */\nMAIN_ROUTINE:\nCALL BUILD_GRANT_SYSIN\nCALL WRITE_DB2_PARMS\nEXIT 0\n\n/*     S U B R O U T I N E S   S E C T I O N     */\n/*     */\nBUILD_GRANT_SYSIN:\n\"DELSTACK\"\nPKGCNT = 5\nCOMRCD = \"  COMMIT;\"\nPKG.1 = \"        GRANT\"\nPKG.2 = \"        BIND,\"\nPKG.3 = \"        COPY,\"\nPKG.4 = \"        EXECUTE\"\nPKG.5 = \"  ON PACKAGE \"DB2COLL\".* TO\"\nBNDCNT = 4\nBND.1 = \"        GRANT\"\nBND.2 = \"        BIND,\"\nBND.3 = \"        EXECUTE\"\nBND.4 = \"  ON PLAN \"DB2PLAN\" TO\"\nDB2PARM = SYSDSN(\"'\"PARMLIB\"(DB2ADMIN)'\")\nIF DB2PARM = 'MEMBER NOT FOUND' THEN DO\n   SAY '*** MEMBER ERROR: MEMBER NOT FOUND ('PARMLIB'(DB2ADMIN). ***'\n   SAY '*** DB2EGRNT EXEC SUBTASK CANCELLED - RETURN CODE: ('028'). ***'\n   EXIT 028\nEND\n\"ALLOC DA('\"PARMLIB\"(DB2ADMIN)') FILE(PARMDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('PARMLIB'(DB2ADMIN). ***'\n   SAY '*** DB2EGRNT EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\n\"EXECIO * DISKR PARMDD (FINIS STEM AUTH.\"\nSRC = RC\n\"FREE FILE(PARMDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** EXECIO READ ERROR: ('PARMLIB'(DB2ADMIN). ***'\n   SAY '*** DB2EGRNT EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nDO P = 1 TO PKGCNT\n   QUEUE PKG.P\nEND\nDO I = 1 TO AUTH.0\n   AUTHUSR = WORD(AUTH.I,1)\n   AUSER = TSOID','\n   IF AUSER = AUTHUSR THEN ITERATE\n   DB2AUTH = '        '||AUTHUSR\n   QUEUE DB2AUTH\nEND\nQUEUE COMRCD\nDO B = 1 TO BNDCNT\n   QUEUE BND.B\nEND\nDO I = 1 TO AUTH.0\n   AUTHUSR = WORD(AUTH.I,1)\n   AUSER = TSOID','\n   IF AUSER = AUTHUSR THEN ITERATE\n   DB2AUTH = '        '||AUTHUSR\n   QUEUE DB2AUTH\nEND\nQUEUE COMRCD\nRETURN\n\n/*     */\nWRITE_DB2_PARMS:\n\"ALLOC DA('\"OUTPDS\"(\"MEMBER\")') FILE(DB2DD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('OUTPDS'('MEMBER'). ***'\n   SAY '*** DB2EGRNT EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nNUMRCDS = QUEUED()\n\"EXECIO\" NUMRCDS \"DISKW DB2DD (FINIS\"\nSRC = RC\n\"FREE FILE(DB2DD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** WRITE ERROR: ERROR WRITING ('OUTPDS'('MEMBER').  ***'\n   SAY '*** DB2EGRNT EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DB2ECGRT": {"ttr": 10508, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x93&o\\x00\\x93&o\\x11\\x15\\x00x\\x00x\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-09-23T00:00:00", "modifydate": "1993-09-23T11:15:00", "lines": 120, "newlines": 120, "modlines": 0, "user": "TECH103"}, "text": "/*  REXX EXEC : ( DB2ECGRT ).\n    FUNCTION  : CALLED BY DB2C COMPILE TASK TO BUILD THE GRANT\n                AUTHORIZATION SYSIN MEMBER FOR EMERGENCY CICS COMPILES\n                FROM AN EMERGENCY CCFID ( TECH290 THRU TECH295 ).\n    INPUT     : SYSS.TECH.COMMON.PARMLIB(DB2ADMIN).\n    OUTPUT    : &TSOID.USER.DBRMLIB(&PROGRAM).\n                                                                     */\nTRACE O\n/*     */\nHOUSE_KEEPING:\nADDRESS TSO\nARG TSOID MEMBER DB2COLL DB2PLAN\nPARMS = 'TSOID MEMBER DB2COLL DB2PLAN'\nSRC = 0\nDO I = 1 TO 4\n   IPARM = WORD(PARMS,I)\n   XPARM = VALUE(IPARM)\n   IF XPARM \u00ac= '' THEN ITERATE\n   SAY '*** PARM ERROR: MISSING PARM VALUE FOR ('IPARM'). ***'\n   SAY '*** DB2ECGRT EXEC TASK CANCELLED - RC = (024). ***'\n   EXIT 024\nEND\nX = MSG(\"OFF\")\n\"FREE FILE(PARMDD)\"\n\"FREE FILE(DB2DD)\"\nDUNIT = 'APPLTA'\nTSOPRFX = SUBSTR(TSOID,1,4)\nIF TSOPRFX = 'TECH' THEN DUNIT = 'SMS'\nUCNTL = SYSDSN(USER.DBRMLIB)\nIF UCNTL = 'DATASET NOT FOUND' THEN DO\n\"ATTRIB ATTRB1 DSORG(PO) RECFM(F,B) LRECL(80) BLKSIZE(27920)\"\n\"ALLOC DA(USER.DBRMLIB) NEW SPACE(3,1) DIR(44) USING(ATTRB1) UNIT(\"DUNIT\")\"\n   SRC = RC\n   IF SRC \u00ac= 0 THEN DO\n   SAY '*** ALLOCATE ERROR: ERROR ALLOCATING DATASET (USER.DBRMLIB). ***'\n   SAY '*** DB2ECGRT EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\n   END\nEND\n\"FREE DA(USER.DBRMLIB)\"\nOUTPDS = TSOID'.USER.DBRMLIB'\nPARMLIB = 'SYSS.TECH.COMMON.PARMLIB'\n\n/*     */\nMAIN_ROUTINE:\nCALL BUILD_GRANT_SYSIN\nCALL WRITE_DB2_PARMS\nEXIT 0\n\n/*     S U B R O U T I N E S   S E C T I O N     */\n/*     */\nBUILD_GRANT_SYSIN:\n\"DELSTACK\"\nPKGCNT = 4\nPKG.1 = \"        GRANT\"\nPKG.2 = \"        BIND,\"\nPKG.3 = \"        COPY\"\nPKG.4 = \"  ON PACKAGE \"DB2COLL\".* TO\"\nPKG.5 = \"  COMMIT;\"\nBNDCNT = 4\nBND.1 = \"  GRANT EXECUTE ON PACKAGE \"DB2COLL\".* TO PUBLIC;\"\nBND.2 = \"  COMMIT;\"\nBND.3 = \"  GRANT EXECUTE ON PLAN \"DB2PLAN\" TO PUBLIC;\"\nBND.4 = \"  COMMIT;\"\nDB2PARM = SYSDSN(\"'\"PARMLIB\"(DB2ADMIN)'\")\nIF DB2PARM = 'MEMBER NOT FOUND' THEN DO\n   SAY '*** MEMBER ERROR: MEMBER NOT FOUND ('PARMLIB'(DB2ADMIN). ***'\n   SAY '*** DB2ECGRT EXEC SUBTASK CANCELLED - RETURN CODE: ('028'). ***'\n   EXIT 028\nEND\n\"ALLOC DA('\"PARMLIB\"(DB2ADMIN)') FILE(PARMDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('PARMLIB'(DB2ADMIN). ***'\n   SAY '*** DB2ECGRT EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\n\"EXECIO * DISKR PARMDD (FINIS STEM AUTH.\"\nSRC = RC\n\"FREE FILE(PARMDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** EXECIO READ ERROR: ('PARMLIB'(DB2ADMIN). ***'\n   SAY '*** DB2ECGRT EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nDO P = 1 TO PKGCNT\n   QUEUE PKG.P\nEND\nDO I = 1 TO AUTH.0\n   AUTHUSR = WORD(AUTH.I,1)\n   AUSER = TSOID','\n   IF AUSER = AUTHUSR THEN ITERATE\n   DB2AUTH = '        '||AUTHUSR\n   QUEUE DB2AUTH\nEND\nQUEUE PKG.5\nDO B = 1 TO BNDCNT\n   QUEUE BND.B\nEND\nRETURN\n\n/*     */\nWRITE_DB2_PARMS:\n\"ALLOC DA('\"OUTPDS\"(\"MEMBER\")') FILE(DB2DD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('OUTPDS'('MEMBER'). ***'\n   SAY '*** DB2ECGRT EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nNUMRCDS = QUEUED()\n\"EXECIO\" NUMRCDS \"DISKW DB2DD (FINIS\"\nSRC = RC\n\"FREE FILE(DB2DD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** WRITE ERROR: ERROR WRITING ('OUTPDS'('MEMBER').  ***'\n   SAY '*** DB2ECGRT EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DB2GRNTP": {"ttr": 10755, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x93 ?\\x00\\x93 \\x9f\\x125\\x00k\\x00j\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf3@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1993-07-22T00:00:00", "modifydate": "1993-07-28T12:35:00", "lines": 107, "newlines": 106, "modlines": 0, "user": "TECH103"}, "text": "/*  REXX EXEC : ( DB2GRNTP ).\n    FUNCTION  : CALLED BY THE DB2 BATCH AND CICS COMPILE TASKS:\n                ( DB2B AND DB2C ).\n                A MEMBER WILL BE WRITTEN TO TRACK THE GRANT DB2 TASK\n                FOR A BIND PLAN EXECUTION.\n    INPUT     : DB2PLAN AND DB2SUBSYS PARMS.\n    OUTPUT    : SYSS.TESTCCF.GRANT.CNTLLIB(&DB2PLAN).\n                                                                     */\nTRACE O\n/*      */\nHOUSE_KEEPING:\nADDRESS TSO\nARG DB2PLAN DBSUBSYS\nPARMS = 'DB2PLAN DBSUBSYS'\nSRC = 0\nDO I = 1 TO 2\n   IPARM = WORD(PARMS,I)\n   XPARM = VALUE(IPARM)\n   IF XPARM \u00ac= '' THEN ITERATE\n   SAY '*** PARM ERROR: MISSING PARM VALUE FOR ('IPARM'). ***'\n   SAY '*** DB2GRNTP EXEC TASK CANCELLED - RC = (024). ***'\n   EXIT 024\nEND\nIF DBSUBSYS = 'DSNX' THEN EXIT 0\nGRANTPDS = 'SYSS.TESTCCF.GRANT.CNTLLIB'\nUCNTL = SYSDSN(\"'\"GRANTPDS\"'\")\nIF UCNTL = 'DATASET NOT FOUND' THEN DO\n   IF SRC \u00ac= 0 THEN DO\n      SAY '*** ALLOCATE ERROR: DATASET NOT FOUND ('GRANTPDS'). ***'\n      SAY '*** DB2GRNTP EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n      EXIT 100\n   END\nEND\nX = MSG(\"OFF\")\n\"FREE FILE(PARMDD)\"\n\n/*     */\nMAIN_ROUTINE:\nCALL CHECK_GRANT_CNTLLIB\n\"DELSTACK\"\nINTERPRET CALL LABEL\nEXIT 0\n\n/*     S U B R O U T I N E S   S E C T I O N     */\n/*     */\nCHECK_GRANT_CNTLLIB:\nLABEL = 'WRITE_GRANT_PARMS'\nGMEMB = SYSDSN(\"'\"GRANTPDS\"(\"DB2PLAN\")'\")\nIF GMEMB = 'MEMBER NOT FOUND' THEN RETURN\n\"ALLOC DA('\"GRANTPDS\"(\"DB2PLAN\")') F(PARMDD) SHR\"\n\"EXECIO * DISKR PARMDD (FINIS STEM GPARM.\"\n\"FREE F(PARMDD)\"\nLABEL = 'REWRITE_GRANT_PARMS'\nDO I = 1 TO GPARM.0\n   IF GPARM.I = DBSUBSYS THEN LABEL = 'NOOP_GRANT_PARMS'\nEND\nRETURN\n\n/*     */\nNOOP_GRANT_PARMS:\nRETURN\n\n/*     */\nWRITE_GRANT_PARMS:\n\"ALLOC DA('\"GRANTPDS\"(\"DB2PLAN\")') FILE(PARMDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('GRANTPDS'('DB2PLAN'). ***'\n   SAY '*** DB2GRNTP EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT 100\nEND\nRECORD = DBSUBSYS\nQUEUE RECORD\n\"EXECIO 1 DISKW PARMDD (FINIS\"\nSRC = RC\n\"FREE FILE(PARMDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** WRITE ERROR: ERROR WRITING ('GRANTPDS'('DB2PLAN'). ***'\n   SAY '*** DB2GRNTP EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nRETURN\n\n/*     */\nREWRITE_GRANT_PARMS:\n\"ALLOC DA('\"GRANTPDS\"(\"DB2PLAN\")') FILE(PARMDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('GRANTPDS'('DB2PLAN'). ***'\n   SAY '*** DB2GRNTP EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT 100\nEND\nDO I = 1 TO GPARM.0\n   QUEUE GPARM.I\nEND\nRECORD = DBSUBSYS\nQUEUE RECORD\nNUMRCDS = QUEUED()\n\"EXECIO \"NUMRCDS\" DISKW PARMDD (FINIS\"\nSRC = RC\n\"FREE FILE(PARMDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** WRITE ERROR: ERROR WRITING ('GRANTPDS'('DB2PLAN'). ***'\n   SAY '*** DB2GRNTP EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DB2PACKB": {"ttr": 10758, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x15\\x00\\x00\\x00\\x93\\x01\\x9f\\x00\\x95)\\x8f\\x145\\x00\\x96\\x015\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf3@@@'", "ispf": {"version": "01.21", "flags": 0, "createdate": "1993-01-19T00:00:00", "modifydate": "1995-10-25T14:35:00", "lines": 150, "newlines": 309, "modlines": 0, "user": "TECH103"}, "text": "/*  REXX EXEC : ( DB2PACKB ).\n    FUNCTION  : CALLED BY THE DB2 BATCH COMPILE TASK ( DB2B ) TO\n                BUILD THE DB2 PACKAGE SYSIN MEMBER.\n                A PACKAGE JOB WILL BE WRITTEN AND SUBMITTED TO THE\n                SYSA SYSTEM ( DB2SYSX - DSNX ).\n    INPUT     : TSOID.USER.DBRMLIB(MEMBER).\n    OUTPUT    : BATCH JOB WRITTEN: ( TSOID.DIALOG.ISPFILE(MEMBER))\n                AND SUBMITTED TO SYSA SYSTEM CLASS=P.\n                                                                     */\nTRACE O\n/*      */\nHOUSE_KEEPING:\nADDRESS TSO\nARG TSOID ACCTCDE MEMBER DB2COLL\nPARMS = 'TSOID ACCTCDE MEMBER DB2COLL'\nEXIT 0       /* ***  N O O P   R E T U R N   *** */\nSRC = 0\nDO I = 1 TO 4\n   IPARM = WORD(PARMS,I)\n   XPARM = VALUE(IPARM)\n   IF XPARM \u00ac= '' THEN ITERATE\n   SAY '*** PARM ERROR: MISSING PARM VALUE FOR ('IPARM'). ***'\n   SAY '*** DB2PACKB EXEC TASK CANCELLED - RC = (024). ***'\n   EXIT 024\nEND\nISPFILE = 'SYSS.TESTCCF.ISPFILE.CNTLLIB'\nUCNTL = SYSDSN(\"'\"ISPFILE\"'\")\nIF UCNTL = 'DATASET NOT FOUND' THEN DO\n   IF SRC \u00ac= 0 THEN DO\n      SAY '*** ALLOCATE ERROR: DATASET NOT FOUND ('ISPFILE'). ***'\n      SAY '*** DB2PACKB EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n      EXIT 100\n   END\nEND\nX = MSG(\"OFF\")\n\"FREE FILE(ISPDD)\"\n\n/*     */\nMAIN_ROUTINE:\nDB2SYS = 'DSNX'\nCALL BUILD_PACKAGE_JOBCARD\nCALL BUILD_IKJEFT01_EXECJCL\nCALL BUILD_PACKAGE_SYSIN\nCALL BUILD_IDCAMS_DELETE_MEMBER\nCALL WRITE_PACKAGE_JOB\nCALL SUBMIT_PACKAGE_JOB\nEXIT 0\n\n/*     S U B R O U T I N E S   S E C T I O N     */\n/*     */\nBUILD_PACKAGE_JOBCARD:\nJN = MEMBER\n\"DELSTACK\"\nJCL.1 = \"//\"JN\" JOB\" ACCTCDE\",'\"TSOID\".DB2.PACKAGE',NOTIFY=\"TSOID\",\"\nJCL.2 = \"//          CLASS=P,MSGCLASS=S,MSGLEVEL=(1,0),REGION=6M\"\nJCL.3 = \"/*JOBPARM SYSAFF=SYSA\"\nDO J = 1 TO 3\n   QUEUE JCL.J\nEND\nRETURN\n\n/*     */\nBUILD_IKJEFT01_EXECJCL:\nRCDCNT = 8\nJCL.1 = \"//DSNXPKG  EXEC PGM=IKJEFT01,DYNAMNBR=20,COND=(0,LT,DSNYPKG)\"\nJCL.2 = \"//DBRMLIB  DD DSN=\"TSOID\".USER.DBRMLIB,DISP=SHR\"\nJCL.3 = \"//SYSTSPRT DD SYSOUT=*\"\nJCL.4 = \"//SYSPRINT DD SYSOUT=*\"\nJCL.5 = \"//SYSUDUMP DD SYSOUT=*\"\nJCL.6 = \"//SYSOUT   DD SYSOUT=*\"\nJCL.7 = \"//SYSIN    DD DUMMY,DCB=BLKSIZE=80\"\nJCL.8 = \"//SYSTSIN  DD *\"\nDO J = 1 TO RCDCNT\n   QUEUE JCL.J\nEND\nRETURN\n\n/*     */\nBUILD_PACKAGE_SYSIN:\nRCDCNT = 16\nRCD.1 = \" DSN SYSTEM(\"DB2SYS\")\"\nRCD.2 = \" BIND PACKAGE (\"DB2COLL\") -\"\nRCD.3 = \"      OWNER(\"TSOID\") -\"\nRCD.4 = \"      QUALIFIER(BUILD) -\"\nRCD.5 = \"      MEMBER (\"MEMBER\") - \"\nRCD.6 = \"      SQLERROR(NOPACKAGE) -\"\nRCD.7 = \"      VALIDATE(BIND) -\"\nRCD.8 = \"      FLAG(I) -\"\nRCD.9 = \"      ISOLATION (CS) -\"\nRCD.10 = \"      RELEASE(COMMIT) -\"\nRCD.11 = \"      EXPLAIN(YES) -\"\nRCD.12 = \"      CURRENTDATA(NO) -\"\nRCD.13 = \"      ACTION (REPLACE) -\"\nRCD.14 = \"      ENABLE(*)\"\nRCD.15 = \" END\"\nRCD.16 = \"/*\"\nDO R = 1 TO RCDCNT\n   QUEUE RCD.R\nEND\nRETURN\n\n/*     */\nBUILD_IDCAMS_DELETE_MEMBER:\nRCDCNT = 11\nJCL.1 = \"//DELETE   EXEC PGM=IDCAMS,COND=(0,LT,DSNXPKG)\"\nJCL.2 = \"//ISPDD    DD DSN=\"ISPFILE\",DISP=SHR\"\nJCL.3 = \"//SYSPRINT DD SYSOUT=*\"\nJCL.4 = \"//SYSIN    DD *\"\nJCL.5 = \"  DELETE  \"ISPFILE\"(\"MEMBER\")  FILE(ISPDD)\"\nJCL.6 = \"  IF LASTCC = 8 THEN\"\nJCL.7 = \"     DO\"\nJCL.8 = \"       SET MAXCC = 0\"\nJCL.9 = \"     END\"\nJCL.10 = \"/*\"\nJCL.11 = \"//\"\nDO J = 1 TO RCDCNT\n   QUEUE JCL.J\nEND\nRETURN\n\n/*     */\nWRITE_PACKAGE_JOB:\n\"ALLOC DA('\"ISPFILE\"(\"MEMBER\")') FILE(ISPDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('ISPFILE'('MEMBER'). ***'\n   SAY '*** DB2PACKB EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT 100\nEND\nNUMRCDS = QUEUED()\n\"EXECIO\" NUMRCDS \"DISKW ISPDD (FINIS\"\nSRC = RC\n\"FREE FILE(ISPDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** WRITE ERROR: ERROR WRITING ('ISPFILE'('MEMBER'). ***'\n   SAY '*** DB2PACKB EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nRETURN\n\n/*     */\nSUBMIT_PACKAGE_JOB:\n\"SUBMIT ('\"ISPFILE\"(\"MEMBER\")')\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** SUBMIT ERROR: ('ISPFILE'('MEMBER'). ***'\n   SAY '*** DB2PACKB EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DB2PBPRM": {"ttr": 10762, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01%\\x00\\x00\\x00\\x93\\x15?\\x00\\x951\\x8f\\x10&\\x013\\x00\\xcd\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf3@@@'", "ispf": {"version": "01.37", "flags": 0, "createdate": "1993-06-02T00:00:00", "modifydate": "1995-11-14T10:26:00", "lines": 307, "newlines": 205, "modlines": 0, "user": "TECH103"}, "text": "/*  REXX EXEC : ( DB2PBPRM ).\n    FUNCTION  : CALLED BY CCF QA AND PROD COMPILE SKELETON JCL\n                ( CCFDB2Q1 ) FOR PRODUCTION CONTROL DB2 BATCH PROGRAMS.\n                BUILDS THE PACKAGE/BIND/GRANT CONTROL PARM MEMBERS AND\n                WRITES THE MEMBERS INTO CORRESPONDING QA AND PROD LIBS.\n    OUTPUT    : SYSS.&CCFNODE.CCF.DB2.BIND.CNTLLIB(&PROGRAM).\n                SYSS.&CCFNODE.CCF.DB2.GRANT.CNTLLIB(&PROGRAM).\n                SYSS.&CCFNODE.CCF.DB2.PACKAGE.CNTLLIB(&PROGRAM).\n                                                                     */\nTRACE O\n/*     */\nHOUSE_KEEPING:\nADDRESS TSO\nARG MEMBER LIBNODE DBSUBSYS DB2QUAL .\nPARMS = 'MEMBER LIBNODE DBSUBSYS DB2QUAL'\nSRC = 0\nDO I = 1 TO 4\n   IPARM = WORD(PARMS,I)\n   XPARM = VALUE(IPARM)\n   IF XPARM \u00ac= '' THEN ITERATE\n   SAY\n   SAY '*** PARM ERROR: MISSING PARM VALUE FOR ('IPARM'). ***'\n   SAY '*** DB2PBPRM EXEC TASK CANCELLED - RC = (024). ***'\n   SAY\n   EXIT 024\nEND\nX = MSG(\"OFF\")\n\"FREE FILE(PARMDD)\"\n\"FREE FILE(DB2DD)\"\nTSOID = SYSVAR(SYSUID)\nLABEL = 'MAIN_ROUTINE_'LIBNODE\nINTERPRET CALL LABEL\n/*     */\nMAIN_ROUTINE_QA:\nDB2ACT = 'ADD'\nDSNTPLAN = 'DSNTIA31'\nPARMLIB = 'SYSS.TECH.COMMON.PARMLIB'\nPARMPDS = 'SYSS.QA.CCF.DB2.TURNOVER.PARMLIB'\nBINDPDS = 'SYSS.QA.CCF.DB2.BIND.CNTLLIB'\nPACKPDS = 'SYSS.QA.CCF.DB2.PACKAGE.CNTLLIB'\nGRNTPDS = 'SYSS.QA.CCF.DB2.GRANT.CNTLLIB'\nRUNLIB = 'SYSS.DB2.V3R1M0.DB2X.RUNLIB.LOAD'\nIF DBSUBSYS = 'DB2Q' THEN RUNLIB = 'SYSS.DB2.V3R1M0.DB2Q.RUNLIB.LOAD'\nCALL GET_DB2_PACKAGE_BIND_PARMS\nCALL BUILD_PACKAGE_SYSIN\nOUTPDS = PACKPDS\nCALL WRITE_DB2_PARMS\nCALL BUILD_BIND_SYSIN\nOUTPDS = BINDPDS\nCALL WRITE_DB2_PARMS\nCALL BUILD_GRANT_SYSIN\nOUTPDS = GRNTPDS\nCALL WRITE_DB2_PARMS\nEXIT 0\n/*     */\nMAIN_ROUTINE_PROD:\nDB2ACT = 'ADD'\nDSNTPLAN = 'DSNTIA23'\nPARMLIB = 'SYSS.TECH.COMMON.PARMLIB'\nPARMPDS = 'SYSS.QA.CCF.DB2.TURNOVER.PARMLIB'\nBINDPDS = 'SYSS.PROD.CCF.DB2.BIND.CNTLLIB'\nPACKPDS = 'SYSS.PROD.CCF.DB2.PACKAGE.CNTLLIB'\nGRNTPDS = 'SYSS.PROD.CCF.DB2.GRANT.CNTLLIB'\nRUNLIB = 'SYSS.DB2.V2R3M0.RUNLIB.LOAD'\nIF DBSUBSYS = 'DB2P' THEN RUNLIB = 'SYSS.DB2.V3R1M0.DB2Q.RUNLIB.LOAD'\nCALL GET_DB2_PACKAGE_BIND_PARMS\nCALL BUILD_PACKAGE_SYSIN\nOUTPDS = PACKPDS\nCALL WRITE_DB2_PARMS\nCALL BUILD_BIND_SYSIN\nOUTPDS = BINDPDS\nCALL WRITE_DB2_PARMS\nCALL BUILD_GRANT_SYSIN\nOUTPDS = GRNTPDS\nCALL WRITE_DB2_PARMS\nEXIT 0\n/*     */\nMAIN_ROUTINE_EMERGNCY:\nDB2ACT = 'REPLACE'\nDSNTPLAN = 'DSNTIA23'\nPARMLIB = 'SYSS.TECH.COMMON.PARMLIB'\nBINDPDS = 'SYSS.PROD.CCF.DB2.BIND.CNTLLIB'\nPACKPDS = 'SYSS.PROD.CCF.DB2.PACKAGE.CNTLLIB'\nGRNTPDS = 'SYSS.PROD.CCF.DB2.GRANT.CNTLLIB'\nRUNLIB = 'SYSS.DB2.V2R3M0.RUNLIB.LOAD'\nIF DBSUBSYS = 'DB2P' THEN RUNLIB = 'SYSS.DB2.V3R1M0.DB2Q.RUNLIB.LOAD'\nCALL READ_PACKAGE_SYSIN_MEMBER\nCALL BUILD_PACKAGE_SYSIN\nOUTPDS = PACKPDS\nCALL WRITE_DB2_PARMS\nCALL BUILD_BIND_SYSIN\nOUTPDS = BINDPDS\nCALL WRITE_DB2_PARMS\nCALL BUILD_GRANT_SYSIN\nOUTPDS = GRNTPDS\nCALL WRITE_DB2_PARMS\nEXIT 0\n/*\n       S U B R O U T I N E S   S E C T I O N     */\n/*     */\nGET_DB2_PACKAGE_BIND_PARMS:\nDB2MEMB = SYSDSN(\"'\"PACKPDS\"(\"MEMBER\")'\")\nIF DB2MEMB = 'MEMBER NOT FOUND' THEN DO\n   DB2COLL = MEMBER\n   DB2PLAN = MEMBER\n   RETURN\nEND\n\"ALLOC DA('\"PACKPDS\"(\"MEMBER\")') FILE(PARMDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   DB2COLL = MEMBER\n   DB2PLAN = MEMBER\n   RETURN\nEND\n\"EXECIO * DISKR PARMDD (STEM DATA. FINIS\"\nSRC = RC\n\"FREE FILE(PARMDD)\"\nIF SRC \u00ac= 0 THEN DO\n   DB2COLL = MEMBER\n   DB2PLAN = MEMBER\n   RETURN\nEND\nDO I = 1 TO DATA.0\n   PKEY = POS('BIND PACKAGE',DATA.I)\n   IF PKEY \u00ac= 0 THEN DO\n      COLLKEY = WORD(DATA.I,3)\n      COLLID = STRIP(COLLKEY,\"L\",\"(\")\n      COLLID = STRIP(COLLID,\"T\",\")\")\n      DB2COLL = COLLID\n      DB2PLAN = COLLID\n      LEAVE\n   END\nEND\nRETURN\n/*     */\nBUILD_PACKAGE_SYSIN:\n\"DELSTACK\"\nRCDCNT = 15\nRCD.1 = \" DSN SYSTEM(\"DBSUBSYS\")\"\nRCD.2 = \" BIND PACKAGE (\"DB2COLL\") -\"\nRCD.3 = \"      OWNER(\"TSOID\") -\"\nRCD.4 = \"      QUALIFIER(\"DB2QUAL\") -\"\nRCD.5 = \"      MEMBER (\"MEMBER\") - \"\nRCD.6 = \"      SQLERROR(NOPACKAGE) -\"\nRCD.7 = \"      VALIDATE(BIND) -\"\nRCD.8 = \"      FLAG(I) -\"\nRCD.9 = \"      ISOLATION (CS) -\"\nRCD.10 = \"      RELEASE(COMMIT) -\"\nRCD.11 = \"      EXPLAIN(NO) -\"\nRCD.12 = \"      CURRENTDATA(NO) -\"\nRCD.13 = \"      ACTION (\"DB2ACT\") -\"\nRCD.14 = \"      ENABLE(*)\"\nRCD.15 = \" END\"\nDO R = 1 TO RCDCNT\n   QUEUE RCD.R\nEND\nRETURN\n/*     */\nBUILD_BIND_SYSIN:\n\"DELSTACK\"\nRCDCNT = 15\nREC.1 = \" DSN SYSTEM(\"DBSUBSYS\")\"\nREC.2 = \" BIND PLAN (\"DB2PLAN\") -\"\nREC.3 = \"      OWNER(\"TSOID\") -\"\nREC.4 = \"      VALIDATE(BIND) -\"\nREC.5 = \"      FLAG(I) -\"\nREC.6 = \"      ACQUIRE(USE) -\"\nREC.7 = \"      ISOLATION(CS) -\"\nREC.8 = \"      RELEASE(COMMIT) -\"\nREC.9 = \"      EXPLAIN(NO) -\"\nREC.10 = \"      ACTION (REPLACE) -\"\nREC.11 = \"      PKLIST(\"DB2COLL\".*) -\"\nREC.12 = \"      ENABLE(*)\"\nREC.13 = \" RUN PROGRAM(DSNTIAD) PLAN(\"DSNTPLAN\") -\"\nREC.14 = \"     LIB('\"RUNLIB\"')\"\nREC.15 = \" END\"\nDO R = 1 TO RCDCNT\n   QUEUE REC.R\nEND\nRETURN\n/*     */\nBUILD_GRANT_SYSIN:\n\"DELSTACK\"\nPKGCNT = 4\nPKG.1 = \"        GRANT\"\nPKG.2 = \"        BIND,\"\nPKG.3 = \"        COPY\"\nPKG.4 = \"  ON PACKAGE \"DB2COLL\".* TO\"\nPKG.5 = \"  COMMIT;\"\nBNDCNT = 4\nBND.1 = \"  GRANT EXECUTE ON PACKAGE \"DB2COLL\".* TO PUBLIC;\"\nBND.2 = \"  COMMIT;\"\nBND.3 = \"  GRANT EXECUTE ON PLAN \"DB2PLAN\" TO PUBLIC;\"\nBND.4 = \"  COMMIT;\"\nDB2PARM = SYSDSN(\"'\"PARMLIB\"(DB2ADMIN)'\")\nIF DB2PARM = 'MEMBER NOT FOUND' THEN DO\n   SAY '*** MEMBER ERROR: MEMBER NOT FOUND ('PARMLIB'(DB2ADMIN). ***'\n   SAY '*** DB2PBPRM EXEC SUBTASK CANCELLED - RETURN CODE: ('028'). ***'\n   EXIT 028\nEND\n\"ALLOC DA('\"PARMLIB\"(DB2ADMIN)') FILE(PARMDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('PARMLIB'(DB2ADMIN). ***'\n   SAY '*** DB2PBPRM EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\n\"EXECIO * DISKR PARMDD (FINIS STEM AUTH.\"\nSRC = RC\n\"FREE FILE(PARMDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** EXECIO READ ERROR: ('PARMLIB'(DB2ADMIN). ***'\n   SAY '*** DB2PBPRM EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nAUSER = TSOID','\nDO P = 1 TO PKGCNT\n   QUEUE PKG.P\nEND\nDO I = 1 TO AUTH.0\n   AUTHUSR = WORD(AUTH.I,1)\n   IF AUSER = AUTHUSR THEN ITERATE\n   DB2AUTH = '        '||AUTHUSR\n   QUEUE DB2AUTH\nEND\nQUEUE PKG.5\nDO B = 1 TO BNDCNT\n   QUEUE BND.B\nEND\nRETURN\n/*     */\nBUILD_GRANT_SYSIN_NOOP:\n\"DELSTACK\"\nPKGCNT = 5\nCOMRCD = \"  COMMIT;\"\nPKG.1 = \"        GRANT\"\nPKG.2 = \"        BIND,\"\nPKG.3 = \"        COPY,\"\nPKG.4 = \"        EXECUTE\"\nPKG.5 = \"  ON PACKAGE \"DB2COLL\".* TO\"\nBNDCNT = 4\nBND.1 = \"        GRANT\"\nBND.2 = \"        BIND,\"\nBND.3 = \"        EXECUTE\"\nBND.4 = \"  ON PLAN \"DB2PLAN\" TO\"\nDB2PARM = SYSDSN(\"'\"PARMLIB\"(DB2ADMIN)'\")\nIF DB2PARM = 'MEMBER NOT FOUND' THEN DO\n   SAY '*** MEMBER ERROR: MEMBER NOT FOUND ('PARMLIB'(DB2ADMIN). ***'\n   SAY '*** DB2PBPRM EXEC SUBTASK CANCELLED - RETURN CODE: ('028'). ***'\n   EXIT 028\nEND\n\"ALLOC DA('\"PARMLIB\"(DB2ADMIN)') FILE(PARMDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('PARMLIB'(DB2ADMIN). ***'\n   SAY '*** DB2PBPRM EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\n\"EXECIO * DISKR PARMDD (STEM AUTH. FINIS\"\nSRC = RC\n\"FREE FILE(PARMDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** EXECIO READ ERROR: ('PARMLIB'(DB2ADMIN). ***'\n   SAY '*** DB2PBPRM EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nAUSER = TSOID','\nDO P = 1 TO PKGCNT\n   QUEUE PKG.P\nEND\nDO I = 1 TO AUTH.0\n   AUTHUSR = WORD(AUTH.I,1)\n   IF AUSER = AUTHUSR THEN ITERATE\n   DB2AUTH = '        '||AUTHUSR\n   QUEUE DB2AUTH\nEND\nQUEUE COMRCD\nDO B = 1 TO BNDCNT\n   QUEUE BND.B\nEND\nDO I = 1 TO AUTH.0\n   AUTHUSR = WORD(AUTH.I,1)\n   IF AUSER = AUTHUSR THEN ITERATE\n   DB2AUTH = '        '||AUTHUSR\n   QUEUE DB2AUTH\nEND\nQUEUE COMRCD\nRETURN\n/*     */\nWRITE_DB2_PARMS:\n\"ALLOC DA('\"OUTPDS\"(\"MEMBER\")') FILE(DB2DD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('OUTPDS'('MEMBER'). ***'\n   SAY '*** DB2PBPRM EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nNUMRCDS = QUEUED()\n\"EXECIO\" NUMRCDS \"DISKW DB2DD (FINIS\"\nSRC = RC\n\"FREE FILE(DB2DD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** WRITE ERROR: ERROR WRITING ('OUTPDS'('MEMBER').  ***'\n   SAY '*** DB2PBPRM EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DB2PCPRM": {"ttr": 11011, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01#\\x00\\x00\\x00\\x93\\x15?\\x00\\x951\\x8f\\x10(\\x00\\xf7\\x00\\xcd\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf3@@@'", "ispf": {"version": "01.35", "flags": 0, "createdate": "1993-06-02T00:00:00", "modifydate": "1995-11-14T10:28:00", "lines": 247, "newlines": 205, "modlines": 0, "user": "TECH103"}, "text": "/*  REXX EXEC : ( DB2PCPRM ).\n    FUNCTION  : CALLED BY CCF QA AND PROD COMPILE SKELETON JCL\n                ( CCFDB2Q2 ) FOR PRODUCTION CONTROL DB2 CICS PROGRAMS.\n                BUILDS THE PACKAGE/BIND/GRANT CONTROL PARM MEMBERS AND\n                WRITES THE MEMBERS INTO CORRESPONDING QA PDS CNTL LIBS.\n    OUTPUT    : SYSS.QA.CCF.DB2.BIND.CNTLLIB($PROGRAM).\n                SYSS.QA.CCF.DB2.GRANT.CNTLLIB($PROGRAM).\n                SYSS.QA.CCF.DB2.PACKAGE.CNTLLIB($PROGRAM).\n                                                                     */\nTRACE O\n/*     */\nHOUSE_KEEPING:\nADDRESS TSO\nARG MEMBER LIBNODE DBSUBSYS DB2QUAL .\nPARMS = 'MEMBER LIBNODE DBSUBSYS DB2QUAL'\nSRC = 0\nDO I = 1 TO 4\n   IPARM = WORD(PARMS,I)\n   XPARM = VALUE(IPARM)\n   IF XPARM \u00ac= '' THEN ITERATE\n   SAY '*** PARM ERROR: MISSING PARM VALUE FOR ('IPARM'). ***'\n   SAY '*** DB2PCPRM EXEC TASK CANCELLED - RC = (024). ***'\n   EXIT 024\nEND\nX = MSG(\"OFF\")\n\"FREE FILE(PARMDD)\"\n\"FREE FILE(DB2DD)\"\nTSOID = SYSVAR(SYSUID)\nLABEL = 'MAIN_ROUTINE_'LIBNODE\nINTERPRET CALL LABEL\n/*     */\nMAIN_ROUTINE_QA:\nDB2ACT = 'ADD'\nDSNTPLAN = 'DSNTIA31'\nPARMLIB = 'SYSS.TECH.COMMON.PARMLIB'\nPARMPDS = 'SYSS.QA.CCF.DB2.TURNOVER.PARMLIB'\nBINDPDS = 'SYSS.QA.CCF.DB2.BIND.CNTLLIB'\nPACKPDS = 'SYSS.QA.CCF.DB2.PACKAGE.CNTLLIB'\nGRNTPDS = 'SYSS.QA.CCF.DB2.GRANT.CNTLLIB'\nRUNLIB = 'SYSS.DB2.V3R1M0.DB2X.RUNLIB.LOAD'\nIF DBSUBSYS = 'DB2Q' THEN RUNLIB = 'SYSS.DB2.V3R1M0.DB2Q.RUNLIB.LOAD'\nCALL GET_DB2_PACKAGE_BIND_PARMS\nCALL BUILD_PACKAGE_SYSIN\nOUTPDS = PACKPDS\nCALL WRITE_DB2_PARMS\nCALL BUILD_BIND_SYSIN\nOUTPDS = BINDPDS\nCALL WRITE_DB2_PARMS\nCALL BUILD_GRANT_SYSIN\nOUTPDS = GRNTPDS\nCALL WRITE_DB2_PARMS\nEXIT 0\n/*     */\nMAIN_ROUTINE_PROD:\nDB2ACT = 'ADD'\nDSNTPLAN = 'DSNTIA23'\nPARMLIB = 'SYSS.TECH.COMMON.PARMLIB'\nPARMPDS = 'SYSS.QA.CCF.DB2.TURNOVER.PARMLIB'\nBINDPDS = 'SYSS.PROD.CCF.DB2.BIND.CNTLLIB'\nPACKPDS = 'SYSS.PROD.CCF.DB2.PACKAGE.CNTLLIB'\nGRNTPDS = 'SYSS.PROD.CCF.DB2.GRANT.CNTLLIB'\nRUNLIB = 'SYSS.DB2.V2R3M0.RUNLIB.LOAD'\nIF DBSUBSYS = 'DB2P' THEN RUNLIB = 'SYSS.DB2.V3R1M0.DB2Q.RUNLIB.LOAD'\nCALL GET_DB2_PACKAGE_BIND_PARMS\nCALL BUILD_PACKAGE_SYSIN\nOUTPDS = PACKPDS\nCALL WRITE_DB2_PARMS\nCALL BUILD_BIND_SYSIN\nOUTPDS = BINDPDS\nCALL WRITE_DB2_PARMS\nCALL BUILD_GRANT_SYSIN\nOUTPDS = GRNTPDS\nCALL WRITE_DB2_PARMS\nEXIT 0\n/*     */\nMAIN_ROUTINE_EMERGNCY:\nDB2ACT = 'REPLACE'\nDSNTPLAN = 'DSNTIA23'\nPARMLIB = 'SYSS.TECH.COMMON.PARMLIB'\nBINDPDS = 'SYSS.PROD.CCF.DB2.BIND.CNTLLIB'\nPACKPDS = 'SYSS.PROD.CCF.DB2.PACKAGE.CNTLLIB'\nGRNTPDS = 'SYSS.PROD.CCF.DB2.GRANT.CNTLLIB'\nRUNLIB = 'SYSS.DB2.V2R3M0.RUNLIB.LOAD'\nIF DBSUBSYS = 'DB2P' THEN RUNLIB = 'SYSS.DB2.V3R1M0.DB2Q.RUNLIB.LOAD'\nCALL READ_PACKAGE_SYSIN_MEMBER\nCALL BUILD_PACKAGE_SYSIN\nOUTPDS = PACKPDS\nCALL WRITE_DB2_PARMS\nCALL BUILD_BIND_SYSIN\nOUTPDS = BINDPDS\nCALL WRITE_DB2_PARMS\nCALL BUILD_GRANT_SYSIN\nOUTPDS = GRNTPDS\nCALL WRITE_DB2_PARMS\nEXIT 0\n/*\n       S U B R O U T I N E S   S E C T I O N     */\n/*     */\nGET_DB2_PACKAGE_BIND_PARMS:\nDB2MEMB = SYSDSN(\"'\"PACKPDS\"(\"MEMBER\")'\")\nIF DB2MEMB = 'MEMBER NOT FOUND' THEN DO\n   DB2COLL = MEMBER\n   DB2PLAN = MEMBER\n   RETURN\nEND\n\"ALLOC DA('\"PACKPDS\"(\"MEMBER\")') FILE(PARMDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   DB2COLL = MEMBER\n   DB2PLAN = MEMBER\n   RETURN\nEND\n\"EXECIO * DISKR PARMDD (STEM DATA. FINIS\"\nSRC = RC\n\"FREE FILE(PARMDD)\"\nIF SRC \u00ac= 0 THEN DO\n   DB2COLL = MEMBER\n   DB2PLAN = MEMBER\n   RETURN\nEND\nDO I = 1 TO DATA.0\n   PKEY = POS('BIND PACKAGE',DATA.I)\n   IF PKEY \u00ac= 0 THEN DO\n      COLLKEY = WORD(DATA.I,3)\n      COLLID = STRIP(COLLKEY,\"L\",\"(\")\n      COLLID = STRIP(COLLID,\"T\",\")\")\n      DB2COLL = COLLID\n      DB2PLAN = COLLID\n      LEAVE\n   END\nEND\nRETURN\n/*     */\nBUILD_PACKAGE_SYSIN:\n\"DELSTACK\"\nRCDCNT = 15\nRCD.1 = \" DSN SYSTEM(\"DBSUBSYS\")\"\nRCD.2 = \" BIND PACKAGE (\"DB2COLL\") -\"\nRCD.3 = \"      OWNER(\"TSOID\") -\"\nRCD.4 = \"      QUALIFIER(\"DB2QUAL\") -\"\nRCD.5 = \"      MEMBER (\"MEMBER\") - \"\nRCD.6 = \"      SQLERROR(NOPACKAGE) -\"\nRCD.7 = \"      VALIDATE(BIND) -\"\nRCD.8 = \"      FLAG(I) -\"\nRCD.9 = \"      ISOLATION (CS) -\"\nRCD.10 = \"      RELEASE(COMMIT) -\"\nRCD.11 = \"      EXPLAIN(NO) -\"\nRCD.12 = \"      CURRENTDATA(NO) -\"\nRCD.13 = \"      ACTION (\"DB2ACT\") -\"\nRCD.14 = \"      ENABLE(*)\"\nRCD.15 = \" END\"\nDO R = 1 TO RCDCNT\n   QUEUE RCD.R\nEND\nRETURN\n/*     */\nBUILD_BIND_SYSIN:\n\"DELSTACK\"\nRCDCNT = 15\nREC.1 = \" DSN SYSTEM(\"DBSUBSYS\")\"\nREC.2 = \" BIND PLAN (\"DB2PLAN\") -\"\nREC.3 = \"      OWNER(\"TSOID\") -\"\nREC.4 = \"      VALIDATE(BIND) -\"\nREC.5 = \"      FLAG(I) -\"\nREC.6 = \"      ACQUIRE(USE) -\"\nREC.7 = \"      ISOLATION(CS) -\"\nREC.8 = \"      RELEASE(COMMIT) -\"\nREC.9 = \"      EXPLAIN(NO) -\"\nREC.10 = \"      ACTION (REPLACE) -\"\nREC.11 = \"      PKLIST(\"DB2COLL\".*) -\"\nREC.12 = \"      ENABLE(*)\"\nREC.13 = \" RUN PROGRAM(DSNTIAD) PLAN(\"DSNTPLAN\") -\"\nREC.14 = \"     LIB('\"RUNLIB\"')\"\nREC.15 = \" END\"\nDO R = 1 TO RCDCNT\n   QUEUE REC.R\nEND\nRETURN\n/*     */\nBUILD_GRANT_SYSIN:\n\"DELSTACK\"\nPKGCNT = 4\nPKG.1 = \"        GRANT\"\nPKG.2 = \"        BIND,\"\nPKG.3 = \"        COPY\"\nPKG.4 = \"  ON PACKAGE \"DB2COLL\".* TO\"\nPKG.5 = \"  COMMIT;\"\nBNDCNT = 4\nBND.1 = \"  GRANT EXECUTE ON PACKAGE \"DB2COLL\".* TO PUBLIC;\"\nBND.2 = \"  COMMIT;\"\nBND.3 = \"  GRANT EXECUTE ON PLAN \"DB2PLAN\" TO PUBLIC;\"\nBND.4 = \"  COMMIT;\"\nDB2PARM = SYSDSN(\"'\"PARMLIB\"(DB2ADMIN)'\")\nIF DB2PARM = 'MEMBER NOT FOUND' THEN DO\n   SAY '*** MEMBER ERROR: MEMBER NOT FOUND ('PARMLIB'(DB2ADMIN). ***'\n   SAY '*** DB2PCPRM EXEC SUBTASK CANCELLED - RETURN CODE: ('028'). ***'\n   EXIT 028\nEND\n\"ALLOC DA('\"PARMLIB\"(DB2ADMIN)') FILE(PARMDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('PARMLIB'(DB2ADMIN). ***'\n   SAY '*** DB2PCPRM EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\n\"EXECIO * DISKR PARMDD (FINIS STEM AUTH.\"\nSRC = RC\n\"FREE FILE(PARMDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** EXECIO READ ERROR: ('PARMLIB'(DB2ADMIN). ***'\n   SAY '*** DB2PCPRM EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nAUSER = TSOID','\nDO P = 1 TO PKGCNT\n   QUEUE PKG.P\nEND\nDO I = 1 TO AUTH.0\n   AUTHUSR = WORD(AUTH.I,1)\n   IF AUSER = AUTHUSR THEN ITERATE\n   DB2AUTH = '        '||AUTHUSR\n   QUEUE DB2AUTH\nEND\nQUEUE PKG.5\nDO B = 1 TO BNDCNT\n   QUEUE BND.B\nEND\nRETURN\n/*     */\nWRITE_DB2_PARMS:\n\"ALLOC DA('\"OUTPDS\"(\"MEMBER\")') FILE(DB2DD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('OUTPDS'('MEMBER'). ***'\n   SAY '*** DB2PCPRM EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nNUMRCDS = QUEUED()\n\"EXECIO\" NUMRCDS \"DISKW DB2DD (FINIS\"\nSRC = RC\n\"FREE FILE(DB2DD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** WRITE ERROR: ERROR WRITING ('OUTPDS'('MEMBER').  ***'\n   SAY '*** DB2PCPRM EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DB2PKBND": {"ttr": 11016, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x11\\x00\\x00\\x00\\x93\\x15_\\x00\\x951\\x7f\\x10%\\x00\\xf8\\x00\\xd0\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf3@@@'", "ispf": {"version": "01.17", "flags": 0, "createdate": "1993-06-04T00:00:00", "modifydate": "1995-11-13T10:25:00", "lines": 248, "newlines": 208, "modlines": 0, "user": "TECH103"}, "text": "/*  REXX EXEC : ( DB2PKBND ).\n    FUNCTION  : CALLED BY DB2B BATCH COBOL2 COMPILE TASK FROM SKELETONS\n                ( CCFDB2B6 AND CCFDB2B8 ).\n                BUILDS THE PACKAGE/BIND/GRANT JOBS FOR SUBMISSION TO\n                THE SYSA DSNX SYSTEM.\n    INPUT     : &&TSOID.USER.DBRMLIB(&&MEMBER).\n    OUTPUT    : SYSS.TESTCCF.ISPFILE.CNTLLIB(&&MEMBER) -\n                BATCH JOB SUBMITTED TO SYSA SYSTEM CLASS=P.\n                                                                     */\nTRACE O\n/*      */\nHOUSE_KEEPING:\nADDRESS TSO\nARG TSOID ACCTCDE MEMBER DB2COLL\nPARMS = 'TSOID ACCTCDE MEMBER DB2COLL'\nSRC = 0\nDO I = 1 TO 4\n   IPARM = WORD(PARMS,I)\n   XPARM = VALUE(IPARM)\n   IF XPARM \u00ac= '' THEN ITERATE\n   SAY '*** PARM ERROR: MISSING PARM VALUE FOR ('IPARM'). ***'\n   SAY '*** DB2PKBND EXEC TASK CANCELLED - RC = (024). ***'\n   EXIT 024\nEND\nEXIT 0     /* ***   N O O P   R E T U R N   *** */\nGRANTPDS = 'SYSS.TESTCCF.GRANT.CNTLLIB'\nISPFILE = 'SYSS.TESTCCF.ISPFILE.CNTLLIB'\nUCNTL = SYSDSN(\"'\"ISPFILE\"'\")\nIF UCNTL = 'DATASET NOT FOUND' THEN DO\n   IF SRC \u00ac= 0 THEN DO\n      SAY '*** ALLOCATE ERROR: DATASET NOT FOUND ('ISPFILE'). ***'\n      SAY '*** DB2PKBND EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n      EXIT 100\n   END\nEND\nX = MSG(\"OFF\")\n\"FREE FILE(ISPDD)\"\n\"FREE FILE(PARMDD)\"\n\n/*     */\nMAIN_ROUTINE_DSNX:\nDBSUBSYS = 'DSNX'\nDB2PLAN = DB2COLL\nRUNLIB = 'SYSS.DB2.V2R3M0.DB2X.RUNLIB.LOAD'\nDBRMLIB = TSOID||'.USER.DBRMLIB'\nCALL BUILD_JOBCARD\nCALL BUILD_PACKAGE_IKJEFT01_JCL\nCALL BUILD_PACKAGE_SYSIN\nCALL CHECK_GRANT_CNTLLIB\nINTERPRET CALL LABEL\nCALL BUILD_BIND_SYSIN\nIF LABEL = 'BUILD_BIND_IKJEFT01_GRANTJCL' THEN CALL BUILD_GRANT_CNTLLIB_JCL\nCALL BUILD_IDCAMS_DELETE_MEMBER\nCALL WRITE_PKGBIND_JOB\nCALL SUBMIT_PKGBIND_JOB\nEXIT 0\n\n/*     S U B R O U T I N E S   S E C T I O N     */\n/*     */\nBUILD_JOBCARD:\n\"DELSTACK\"\nJN = MEMBER\nJCL.1 = \"//\"JN\" JOB\" ACCTCDE\",'\"TSOID\".DB2.PKG.BIND',NOTIFY=\"TSOID\",\"\nJCL.2 = \"//          CLASS=P,MSGCLASS=S,MSGLEVEL=(1,1),REGION=6M\"\nJCL.3 = \"/*JOBPARM SYSAFF=SYSA\"\nDO J = 1 TO 3\n   QUEUE JCL.J\nEND\nRETURN\n\n/*     */\nBUILD_PACKAGE_IKJEFT01_JCL:\nRCDCNT = 8\nJCL.1 = \"//DSNXPKG  EXEC PGM=IKJEFT01,DYNAMNBR=20\"\nJCL.2 = \"//DBRMLIB  DD DSN=\"DBRMLIB\",DISP=SHR\"\nJCL.3 = \"//SYSTSPRT DD SYSOUT=*\"\nJCL.4 = \"//SYSPRINT DD SYSOUT=*\"\nJCL.5 = \"//SYSUDUMP DD SYSOUT=*\"\nJCL.6 = \"//SYSOUT   DD SYSOUT=*\"\nJCL.7 = \"//SYSIN    DD DUMMY,DCB=BLKSIZE=80\"\nJCL.8 = \"//SYSTSIN  DD *\"\nDO J = 1 TO RCDCNT\n   QUEUE JCL.J\nEND\nRETURN\n\n/*     */\nBUILD_PACKAGE_SYSIN:\nRCDCNT = 16\nRCD.1 = \" DSN SYSTEM(\"DBSUBSYS\")\"\nRCD.2 = \" BIND PACKAGE (\"DB2COLL\") -\"\nRCD.3 = \"      OWNER(\"TSOID\") -\"\nRCD.4 = \"      QUALIFIER(BUILD) -\"\nRCD.5 = \"      MEMBER (\"MEMBER\") - \"\nRCD.6 = \"      SQLERROR(NOPACKAGE) -\"\nRCD.7 = \"      VALIDATE(BIND) -\"\nRCD.8 = \"      FLAG(I) -\"\nRCD.9 = \"      ISOLATION (CS) -\"\nRCD.10 = \"      RELEASE(COMMIT) -\"\nRCD.11 = \"      EXPLAIN(YES) -\"\nRCD.12 = \"      CURRENTDATA(NO) -\"\nRCD.13 = \"      ACTION (REPLACE) -\"\nRCD.14 = \"      ENABLE(*)\"\nRCD.15 = \" END\"\nRCD.16 = \"/*\"\nDO R = 1 TO RCDCNT\n   QUEUE RCD.R\nEND\nRETURN\n\n/*     */\nCHECK_GRANT_CNTLLIB:\nLABEL = 'BUILD_BIND_IKJEFT01_GRANTJCL'\nGMEMB = SYSDSN(\"'\"GRANTPDS\"(\"DB2PLAN\")'\")\nIF GMEMB = 'MEMBER NOT FOUND' THEN RETURN\n\"ALLOC DA('\"GRANTPDS\"(\"DB2PLAN\")') F(PARMDD) SHR\"\n\"EXECIO * DISKR PARMDD (FINIS STEM GPARM.\"\n\"FREE F(PARMDD)\"\nDO I = 1 TO GPARM.0\n   IF GPARM.I = DBSUBSYS THEN LABEL = 'BUILD_BIND_IKJEFT01_NOGRANT'\nEND\nRETURN\n\n/*     */\nBUILD_BIND_IKJEFT01_GRANTJCL:\nRCDCNT = 10\nJCL.1 = \"//DSNXBIND EXEC PGM=IKJEFT01,DYNAMNBR=20,COND=(0,LT,DSNXPKG)\"\nJCL.2 = \"//DBRMLIB  DD DSN=\"TSOID\".USER.DBRMLIB,DISP=SHR\"\nJCL.3 = \"//SYSTSPRT DD SYSOUT=*\"\nJCL.4 = \"//SYSPRINT DD SYSOUT=*\"\nJCL.5 = \"//SYSUDUMP DD SYSOUT=*\"\nJCL.6 = \"//SYSOUT   DD SYSOUT=*\"\nJCL.7 = \"//SYSIN    DD *\"\nJCL.8 = \" GRANT BIND, EXECUTE ON PLAN \"DB2PLAN\" TO PUBLIC;\"\nJCL.9 = \"/*\"\nJCL.10 = \"//SYSTSIN  DD *\"\nDO J = 1 TO RCDCNT\n   QUEUE JCL.J\nEND\nRETURN\n\n/*     */\nBUILD_BIND_IKJEFT01_NOGRANT:\nRCDCNT = 8\nJCL.1 = \"//DSNXBIND EXEC PGM=IKJEFT01,DYNAMNBR=20,COND=(0,LT,DSNXPKG)\"\nJCL.2 = \"//DBRMLIB  DD DSN=\"TSOID\".USER.DBRMLIB,DISP=SHR\"\nJCL.3 = \"//SYSTSPRT DD SYSOUT=*\"\nJCL.4 = \"//SYSPRINT DD SYSOUT=*\"\nJCL.5 = \"//SYSUDUMP DD SYSOUT=*\"\nJCL.6 = \"//SYSOUT   DD SYSOUT=*\"\nJCL.7 = \"//SYSIN    DD DUMMY,DCB=BLKSIZE=80\"\nJCL.8 = \"//SYSTSIN  DD *\"\nDO J = 1 TO RCDCNT\n   QUEUE JCL.J\nEND\nRETURN\n\n/*     */\nBUILD_BIND_SYSIN:\nRCDCNT = 16\nREC.1 = \" DSN SYSTEM(\"DBSUBSYS\")\"\nREC.2 = \" BIND PLAN (\"DB2PLAN\") -\"\nREC.3 = \"      OWNER(\"TSOID\") -\"\nREC.4 = \"      VALIDATE(BIND) -\"\nREC.5 = \"      FLAG(I) -\"\nREC.6 = \"      ACQUIRE(USE) -\"\nREC.7 = \"      ISOLATION(CS) -\"\nREC.8 = \"      RELEASE(COMMIT) -\"\nREC.9 = \"      EXPLAIN(YES) -\"\nREC.10 = \"      ACTION (REPLACE) RETAIN -\"\nREC.11 = \"      PKLIST(\"DB2COLL\".*) -\"\nREC.12 = \"      ENABLE(*)\"\nREC.13 = \" RUN PROGRAM(DSNTIAD) PLAN(DSNTIA31) -\"\nREC.14 = \"     LIB('\"RUNLIB\"')\"\nREC.15 = \" END\"\nREC.16 = \"/*\"\nDO R = 1 TO RCDCNT\n   QUEUE REC.R\nEND\nRETURN\n\n/*     */\nBUILD_GRANT_CNTLLIB_JCL:\nJCLCNT = 10\nJCL.1 = \"//DB2GRNTP EXEC PGM=IKJEFT01,DYNAMNBR=30,\"\nJCL.2 = \"//  PARM='%DB2GRNTP \"DB2PLAN\" \"DBSUBSYS\"',COND=(0,LT)\"\nJCL.3 = \"//SYSTSPRT DD SYSOUT=*\"\nJCL.4 = \"//SYSPRINT DD SYSOUT=*\"\nJCL.5 = \"//SYSIN    DD DUMMY\"\nJCL.6 = \"//SYSLBC   DD DSN=SYS1.BRODCAST,DISP=SHR\"\nJCL.7 = \"//SYSUADS  DD DSN=SYS1.UADS,DISP=SHR\"\nJCL.8 = \"//SYSPROC  DD DSN=SYSS.TECH.COMMON.EXECLIB,DISP=SHR\"\nJCL.9 = \"//SYSTSIN  DD DUMMY\"\nJCL.10 = \"/*\"\nDO J = 1 TO JCLCNT\n   QUEUE JCL.J\nEND\nRETURN\n\n/*     */\nBUILD_IDCAMS_DELETE_MEMBER:\nRCDCNT = 11\nJCL.1 = \"//DELETE   EXEC PGM=IDCAMS,COND=(0,LT)\"\nJCL.2 = \"//ISPDD    DD DSN=\"ISPFILE\",DISP=SHR\"\nJCL.3 = \"//SYSPRINT DD SYSOUT=*\"\nJCL.4 = \"//SYSIN    DD *\"\nJCL.5 = \"  DELETE  \"ISPFILE\"(\"MEMBER\")  FILE(ISPDD)\"\nJCL.6 = \"  IF LASTCC = 8 THEN\"\nJCL.7 = \"     DO\"\nJCL.8 = \"       SET MAXCC = 0\"\nJCL.9 = \"     END\"\nJCL.10 = \"/*\"\nJCL.11 = \"//\"\nDO J = 1 TO RCDCNT\n   QUEUE JCL.J\nEND\nRETURN\n\n/*     */\nWRITE_PKGBIND_JOB:\n\"ALLOC DA('\"ISPFILE\"(\"MEMBER\")') FILE(ISPDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('ISPFILE'('MEMBER'). ***'\n   SAY '*** DB2PKBND EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nNUMRCDS = QUEUED()\n\"EXECIO\" NUMRCDS \"DISKW ISPDD (FINIS\"\nSRC = RC\n\"FREE FILE(ISPDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** WRITE ERROR: ERROR WRITING ('ISPFILE'('MEMBER').  ***'\n   SAY '*** DB2PKBND EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nRETURN\n\n/*     */\nSUBMIT_PKGBIND_JOB:\n\"SUBMIT ('\"ISPFILE\"(\"MEMBER\")')\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** SUBMIT ERROR: ('OUTPDS'('MEMBER'). ***'\n   SAY '*** DB2PKBND EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DB2PRDB1": {"ttr": 11021, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x00\\x00\\x94$/\\x00\\x952\\x1f\\x15Q\\x00\\xec\\x00\\xe5\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf3@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1994-08-30T00:00:00", "modifydate": "1995-11-17T15:51:00", "lines": 236, "newlines": 229, "modlines": 0, "user": "TECH103"}, "text": "/*  REXX EXEC : ( DB2PRDB1 ).\n    FUNCTION  : CALLED BY CCF BACKOUT AND PROD COMPILE SERVICES TO\n                BUILD THE PACKAGE/BIND/GRANT CONTROL PARM MEMBERS AND\n                WRITES THE MEMBERS INTO CORRESPONDING PROD DATASETS.\n    INPUT     : SYSS.QA.CCF.DB2.TURNOVER.PARMLIB(@WORKORDR).\n    OUTPUT    : SYSS.PROD.CCF.DB2.BIND.CNTLLIB(@MEMBER).\n                SYSS.PROD.CCF.DB2.GRANT.CNTLLIB(@MEMBER).\n                SYSS.PROD.CCF.DB2.PACKAGE.CNTLLIB(@MEMBER).\n    AUTHOR    : DAN BOWEN, TECH SERVICES.\n                                                                     */\nTRACE O\n/*     */\nHOUSE_KEEPING:\nADDRESS TSO\nARG MASTER MEMBER WORKORDR\nPARMS = 'MASTER MEMBER WORKORDR'\nSRC = 0\nDO I = 1 TO 3\n   IPARM = WORD(PARMS,I)\n   XPARM = VALUE(IPARM)\n   IF XPARM \u00ac= '' THEN ITERATE\n   SAY\n   SAY '*** PARM ERROR: MISSING PARM VALUE FOR ('IPARM'). ***'\n   SAY '*** DB2PRDB1 EXEC TASK CANCELLED - RC = (024). ***'\n   SAY\n   EXIT 024\nEND\nX = MSG(\"OFF\")\n\"FREE FILE(PARMDD)\"\n\"FREE FILE(DB2DD)\"\nTSOID = SYSVAR(SYSUID)\nDB2SYS = 'DSNA'\nDB2QUAL = 'BUILD'\nDB2ACT = 'ADD'\nDSNTPLAN = 'DSNTIA23'\nPARMLIB = 'SYSS.TECH.COMMON.PARMLIB'\nPARMPDS = 'SYSS.QA.CCF.DB2.TURNOVER.PARMLIB'\nBINDPDS = 'SYSS.PROD.CCF.DB2.BIND.CNTLLIB'\nPACKPDS = 'SYSS.PROD.CCF.DB2.PACKAGE.CNTLLIB'\nGRNTPDS = 'SYSS.PROD.CCF.DB2.GRANT.CNTLLIB'\nRUNLIB = 'SYSS.DB2.V2R3M0.RUNLIB.LOAD'\nDB2LOAD = 'SYS1.DB2.V2R3M0.LOAD'\nLIBNODE = POS('PRODSRCE',MASTER)\nIF LIBNODE \u00ac= 0 THEN SIGNAL MAIN_ROUTINE_PROD\nSAY\nSAY '*** PARM ERROR: INVALID PARM VALUE PASSED: ('MASTER'). ***'\nSAY '*** THE SPECIFIED CCF LIBRARIAN MASTER IS NOT SUPPORTED. ***'\nSAY '*** DB2PRDB1 EXEC TASK CANCELLED - RC = (024). ***'\nSAY\nEXIT 024\n/*     */\nMAIN_ROUTINE_PROD:\nCALL GET_DB2_PACKAGE_BIND_PARMS\nIF MEMBSW = 'NO' THEN DO\n   SAY\n   SAY '*** PARM ERROR: ENTRY NOT FOUND ('PARMPDS'('WORKORDR') ('MEMBER'). ***'\n   SAY '*** DB2 PACKAGE/BIND/GRANT SYSIN MEMBERS CANNOT BE WRITTEN FOR PROD. **'\n   SAY '*** DB2PRDB1 EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   SAY\n   EXIT SRC\nEND\nIF DB2SYS = 'DB2Q' | 'DB2P' THEN DO\n   RUNLIB = 'SYSS.DB2.V3R1M0.'DB2SYS'.RUNLIB.LOAD'\n   DB2LOAD = 'SYS1.DB2.V3R1M0.SDSNLOAD'\nEND\nCALL BUILD_PACKAGE_SYSIN\nOUTPDS = PACKPDS\nCALL WRITE_DB2_PARMS\nCALL BUILD_BIND_SYSIN\nOUTPDS = BINDPDS\nCALL WRITE_DB2_PARMS\nCALL BUILD_GRANT_SYSIN\nOUTPDS = GRNTPDS\nCALL WRITE_DB2_PARMS\nEXIT 0\n/*\n       S U B R O U T I N E S   S E C T I O N     */\n/*     */\nGET_DB2_PACKAGE_BIND_PARMS:\nSRC = 028\nMEMBSW = 'NO'\nDB2PARM = SYSDSN(\"'\"PARMPDS\"(\"WORKORDR\")'\")\nIF DB2PARM = 'MEMBER NOT FOUND' THEN RETURN\n\"ALLOC DA('\"PARMPDS\"(\"WORKORDR\")') FILE(PARMDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('PARMPDS'('WORKORDR'). ***'\n   RETURN\nEND\n\"EXECIO * DISKR PARMDD (FINIS STEM QPARM.\"\nSRC = RC\n\"FREE FILE(PARMDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** EXECIO READ ERROR: ('PARMPDS'('WORKORDR'). ***'\n   RETURN\nEND\nDO I = 1 TO QPARM.0\n   PMEMBER = WORD(QPARM.I,1)\n   COLLID = WORD(QPARM.I,2)\n   PROGTYP = WORD(QPARM.I,3)\n   DBSUBSYS = WORD(QPARM.I,5)\n   DBTQUAL = WORD(QPARM.I,6)\n   IF PMEMBER = MEMBER & PROGTYP = 'BATCH' THEN DO\n      MEMBSW = 'YES'\n      DB2COLL = COLLID\n      DB2PLAN = COLLID\n      IF DBSUBSYS \u00ac= '' THEN DB2SYS = DBSUBSYS\n      IF DBTQUAL \u00ac= '' THEN DB2QUAL = DBTQUAL\n      LEAVE\n   END\nEND\nDB2QUAL = 'BUILD'\nRETURN\n/*     */\nBUILD_PACKAGE_SYSIN:\n\"DELSTACK\"\nRCDCNT = 15\nRCD.1 = \" DSN SYSTEM(\"DB2SYS\")\"\nRCD.2 = \" BIND PACKAGE (\"DB2COLL\") -\"\nRCD.3 = \"      OWNER(\"TSOID\") -\"\nRCD.4 = \"      QUALIFIER(\"DB2QUAL\") -\"\nRCD.5 = \"      MEMBER (\"MEMBER\") - \"\nRCD.6 = \"      SQLERROR(NOPACKAGE) -\"\nRCD.7 = \"      VALIDATE(BIND) -\"\nRCD.8 = \"      FLAG(I) -\"\nRCD.9 = \"      ISOLATION (CS) -\"\nRCD.10 = \"      RELEASE(COMMIT) -\"\nRCD.11 = \"      EXPLAIN(NO) -\"\nRCD.12 = \"      CURRENTDATA(NO) -\"\nRCD.13 = \"      ACTION (\"DB2ACT\") -\"\nRCD.14 = \"      ENABLE(*)\"\nRCD.15 = \" END\"\nDO R = 1 TO RCDCNT\n   QUEUE RCD.R\nEND\nRETURN\n/*     */\nBUILD_BIND_SYSIN:\n\"DELSTACK\"\nRCDCNT = 15\nREC.1 = \" DSN SYSTEM(\"DB2SYS\")\"\nREC.2 = \" BIND PLAN (\"DB2PLAN\") -\"\nREC.3 = \"      OWNER(\"TSOID\") -\"\nREC.4 = \"      VALIDATE(BIND) -\"\nREC.5 = \"      FLAG(I) -\"\nREC.6 = \"      ACQUIRE(USE) -\"\nREC.7 = \"      ISOLATION(CS) -\"\nREC.8 = \"      RELEASE(COMMIT) -\"\nREC.9 = \"      EXPLAIN(NO) -\"\nREC.10 = \"      ACTION (REPLACE) -\"\nREC.11 = \"      PKLIST(\"DB2COLL\".*) -\"\nREC.12 = \"      ENABLE(*)\"\nREC.13 = \" RUN PROGRAM(DSNTIAD) PLAN(\"DSNTPLAN\") -\"\nREC.14 = \"     LIB('\"RUNLIB\"')\"\nREC.15 = \" END\"\nDO R = 1 TO RCDCNT\n   QUEUE REC.R\nEND\nRETURN\n/*     */\nBUILD_GRANT_SYSIN:\n\"DELSTACK\"\nPKGCNT = 5\nCOMRCD = \"  COMMIT;\"\nPKG.1 = \"        GRANT\"\nPKG.2 = \"        BIND,\"\nPKG.3 = \"        COPY,\"\nPKG.4 = \"        EXECUTE\"\nPKG.5 = \"  ON PACKAGE \"DB2COLL\".* TO\"\nBNDCNT = 4\nBND.1 = \"        GRANT\"\nBND.2 = \"        BIND,\"\nBND.3 = \"        EXECUTE\"\nBND.4 = \"  ON PLAN \"DB2PLAN\" TO\"\nDB2PARM = SYSDSN(\"'\"PARMLIB\"(DB2ADMIN)'\")\nIF DB2PARM = 'MEMBER NOT FOUND' THEN DO\n   SAY '*** MEMBER ERROR: MEMBER NOT FOUND ('PARMLIB'(DB2ADMIN). ***'\n   SAY '*** DB2PRDB1 EXEC SUBTASK CANCELLED - RETURN CODE: ('028'). ***'\n   EXIT 028\nEND\n\"ALLOC DA('\"PARMLIB\"(DB2ADMIN)') FILE(PARMDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('PARMLIB'(DB2ADMIN). ***'\n   SAY '*** DB2PRDB1 EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\n\"EXECIO * DISKR PARMDD (FINIS STEM AUTH.\"\nSRC = RC\n\"FREE FILE(PARMDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** EXECIO READ ERROR: ('PARMLIB'(DB2ADMIN). ***'\n   SAY '*** DB2PRDB1 EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nAUSER = TSOID','\nDO P = 1 TO PKGCNT\n   QUEUE PKG.P\nEND\nDO I = 1 TO AUTH.0\n   AUTHUSR = WORD(AUTH.I,1)\n   IF AUSER = AUTHUSR THEN ITERATE\n   DB2AUTH = '        '||AUTHUSR\n   QUEUE DB2AUTH\nEND\nQUEUE COMRCD\nDO B = 1 TO BNDCNT\n   QUEUE BND.B\nEND\nDO I = 1 TO AUTH.0\n   AUTHUSR = WORD(AUTH.I,1)\n   IF AUSER = AUTHUSR THEN ITERATE\n   DB2AUTH = '        '||AUTHUSR\n   QUEUE DB2AUTH\nEND\nQUEUE COMRCD\nRETURN\n/*     */\nWRITE_DB2_PARMS:\n\"ALLOC DA('\"OUTPDS\"(\"MEMBER\")') FILE(DB2DD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('OUTPDS'('MEMBER'). ***'\n   SAY '*** DB2PRDB1 EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nNUMRCDS = QUEUED()\n\"EXECIO\" NUMRCDS \"DISKW DB2DD (FINIS\"\nSRC = RC\n\"FREE FILE(DB2DD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** WRITE ERROR: ERROR WRITING ('OUTPDS'('MEMBER').  ***'\n   SAY '*** DB2PRDB1 EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DB2PRDC1": {"ttr": 11269, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x94$/\\x00\\x952\\x1f\\x15Q\\x00\\xe2\\x00\\xd9\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf3@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1994-08-30T00:00:00", "modifydate": "1995-11-17T15:51:00", "lines": 226, "newlines": 217, "modlines": 0, "user": "TECH103"}, "text": "/*  REXX EXEC : ( DBDPRDC1 ).\n    FUNCTION  : CALLED BY CCF BACKOUT AND COMPILE SERVICES TO BUILD\n                THE PACKAGE/BIND/GRANT CONTROL PARM MEMBERS AND\n                WRITES THE MEMBERS INTO CORRESPONDING QA PDS CNTL LIBS.\n    INPUT     : SYSS.QA.CCF.DB2.TURNOVER.PARMLIB(@WORKORDR).\n    OUTPUT    : SYSS.PROD.CCF.DB2.BIND.CNTLLIB(&PROGRAM).\n                SYSS.PROD.CCF.DB2.GRANT.CNTLLIB(&PROGRAM).\n                SYSS.PROD.CCF.DB2.PACKAGE.CNTLLIB(&PROGRAM).\n                                                                     */\nTRACE O\n/*     */\nHOUSE_KEEPING:\nADDRESS TSO\nARG MASTER MEMBER WORKORDR\nPARMS = 'MASTER MEMBER WORKORDR'\nSRC = 0\nDO I = 1 TO 3\n   IPARM = WORD(PARMS,I)\n   XPARM = VALUE(IPARM)\n   IF XPARM \u00ac= '' THEN ITERATE\n   SAY '*** PARM ERROR: MISSING PARM VALUE FOR ('IPARM'). ***'\n   SAY '*** DBDPRDC1 EXEC TASK CANCELLED - RC = (024). ***'\n   EXIT 024\nEND\nX = MSG(\"OFF\")\n\"FREE FILE(PARMDD)\"\n\"FREE FILE(DB2DD)\"\nTSOID = SYSVAR(SYSUID)\nDB2SYS = 'DSNA'\nDB2ACT = 'ADD'\nDB2QUAL = 'BUILD'\nDSNTPLAN = 'DSNTIA23'\nPARMLIB = 'SYSS.TECH.COMMON.PARMLIB'\nPARMPDS = 'SYSS.QA.CCF.DB2.TURNOVER.PARMLIB'\nBINDPDS = 'SYSS.PROD.CCF.DB2.BIND.CNTLLIB'\nPACKPDS = 'SYSS.PROD.CCF.DB2.PACKAGE.CNTLLIB'\nGRNTPDS = 'SYSS.PROD.CCF.DB2.GRANT.CNTLLIB'\nRUNLIB = 'SYSS.DB2.V2R3M0.RUNLIB.LOAD'\nDB2LOAD = 'SYS1.DB2.V2R3M0.LOAD'\nLIBNODE = POS('PRODSRCE',MASTER)\nIF LIBNODE \u00ac= 0 THEN SIGNAL MAIN_ROUTINE_PROD\nSAY\nSAY '*** PARM ERROR: INVALID PARM VALUE PASSED: ('MASTER'). ***'\nSAY '*** THE SPECIFIED CCF LIBRARIAN MASTER IS NOT SUPPORTED. ***'\nSAY '*** DBDPRDC1 EXEC TASK CANCELLED - RC = (024). ***'\nSAY\nEXIT 024\n/*     */\nMAIN_ROUTINE_PROD:\nCALL GET_DB2_PACKAGE_BIND_PARMS\nIF MEMBSW = 'NO' THEN DO\n   SAY\n   SAY '*** PARM ERROR: ENTRY NOT FOUND ('PARMPDS'('WORKORDR') ('MEMBER'). ***'\n   SAY '*** DB2 PACKAGE/BIND/GRANT SYSIN MEMBERS CANNOT BE WRITTEN FOR PROD. **'\n   SAY '*** DBDPRDC1 EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   SAY\n   EXIT SRC\nEND\nCALL BUILD_PACKAGE_SYSIN\nOUTPDS = PACKPDS\nCALL WRITE_DB2_PARMS\nCALL BUILD_BIND_SYSIN\nOUTPDS = BINDPDS\nCALL WRITE_DB2_PARMS\nCALL BUILD_GRANT_SYSIN\nOUTPDS = GRNTPDS\nCALL WRITE_DB2_PARMS\nEXIT 0\n/*     S U B R O U T I N E S   S E C T I O N     */\n/*     */\nGET_DB2_PACKAGE_BIND_PARMS:\nSRC = 028\nMEMBSW = 'NO'\nDB2PARM = SYSDSN(\"'\"PARMPDS\"(\"WORKORDR\")'\")\nIF DB2PARM = 'MEMBER NOT FOUND' THEN DO\n   SAY '*** MEMBER ERROR: MEMBER NOT FOUND ('PARMPDS'('WORKORDR'). ***'\n   SAY '*** DBDPRDC1 EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\n\"ALLOC DA('\"PARMPDS\"(\"WORKORDR\")') FILE(PARMDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('PARMPDS'('WORKORDR'). ***'\n   SAY '*** DBDPRDC1 EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\n\"EXECIO * DISKR PARMDD (FINIS STEM QPARM.\"\nSRC = RC\n\"FREE FILE(PARMDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** EXECIO READ ERROR: ('PARMPDS'('WORKORDR'). ***'\n   SAY '*** DBDPRDC1 EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nDO I = 1 TO QPARM.0\n   PMEMBER = WORD(QPARM.I,1)\n   COLLID = WORD(QPARM.I,2)\n   PROGTYP = WORD(QPARM.I,3)\n   DBSUBSYS = WORD(QPARM.I,5)\n   DBTQUAL = WORD(QPARM.I,6)\n   IF PMEMBER = MEMBER & PROGTYP = 'CICS' THEN DO\n      MEMBSW = 'YES'\n      DB2COLL = COLLID\n      DB2PLAN = COLLID\n      IF DBSUBSYS \u00ac= '' THEN DB2SYS = DBSUBSYS\n      IF DBTQUAL \u00ac= '' THEN DB2QUAL = DBTQUAL\n      LEAVE\n   END\nEND\nDB2QUAL = 'BUILD'\nRETURN\n/*     */\nBUILD_PACKAGE_SYSIN:\n\"DELSTACK\"\nRCDCNT = 15\nRCD.1 = \" DSN SYSTEM(\"DB2SYS\")\"\nRCD.2 = \" BIND PACKAGE (\"DB2COLL\") -\"\nRCD.3 = \"      OWNER(\"TSOID\") -\"\nRCD.4 = \"      QUALIFIER(\"DB2QUAL\") -\"\nRCD.5 = \"      MEMBER (\"MEMBER\") - \"\nRCD.6 = \"      SQLERROR(NOPACKAGE) -\"\nRCD.7 = \"      VALIDATE(BIND) -\"\nRCD.8 = \"      FLAG(I) -\"\nRCD.9 = \"      ISOLATION (CS) -\"\nRCD.10 = \"      RELEASE(COMMIT) -\"\nRCD.11 = \"      EXPLAIN(NO) -\"\nRCD.12 = \"      CURRENTDATA(NO) -\"\nRCD.13 = \"      ACTION (\"DB2ACT\") -\"\nRCD.14 = \"      ENABLE(*)\"\nRCD.15 = \" END\"\nDO R = 1 TO RCDCNT\n   QUEUE RCD.R\nEND\nRETURN\n/*     */\nBUILD_BIND_SYSIN:\n\"DELSTACK\"\nRCDCNT = 15\nREC.1 = \" DSN SYSTEM(\"DB2SYS\")\"\nREC.2 = \" BIND PLAN (\"DB2PLAN\") -\"\nREC.3 = \"      OWNER(\"TSOID\") -\"\nREC.4 = \"      VALIDATE(BIND) -\"\nREC.5 = \"      FLAG(I) -\"\nREC.6 = \"      ACQUIRE(USE) -\"\nREC.7 = \"      ISOLATION(CS) -\"\nREC.8 = \"      RELEASE(COMMIT) -\"\nREC.9 = \"      EXPLAIN(NO) -\"\nREC.10 = \"      ACTION (REPLACE) -\"\nREC.11 = \"      PKLIST(\"DB2COLL\".*) -\"\nREC.12 = \"      ENABLE(*)\"\nREC.13 = \" RUN PROGRAM(DSNTIAD) PLAN(\"DSNTPLAN\") -\"\nREC.14 = \"     LIB('\"RUNLIB\"')\"\nREC.15 = \" END\"\nDO R = 1 TO RCDCNT\n   QUEUE REC.R\nEND\nRETURN\n/*     */\nBUILD_GRANT_SYSIN:\n\"DELSTACK\"\nPKGCNT = 4\nPKG.1 = \"        GRANT\"\nPKG.2 = \"        BIND,\"\nPKG.3 = \"        COPY\"\nPKG.4 = \"  ON PACKAGE \"DB2COLL\".* TO\"\nPKG.5 = \"  COMMIT;\"\nBNDCNT = 4\nBND.1 = \"  GRANT EXECUTE ON PACKAGE \"DB2COLL\".* TO PUBLIC;\"\nBND.2 = \"  COMMIT;\"\nBND.3 = \"  GRANT EXECUTE ON PLAN \"DB2PLAN\" TO PUBLIC;\"\nBND.4 = \"  COMMIT;\"\nDB2PARM = SYSDSN(\"'\"PARMLIB\"(DB2ADMIN)'\")\nIF DB2PARM = 'MEMBER NOT FOUND' THEN DO\n   SAY '*** MEMBER ERROR: MEMBER NOT FOUND ('PARMLIB'(DB2ADMIN). ***'\n   SAY '*** DBDPRDC1 EXEC SUBTASK CANCELLED - RETURN CODE: ('028'). ***'\n   EXIT 028\nEND\n\"ALLOC DA('\"PARMLIB\"(DB2ADMIN)') FILE(PARMDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('PARMLIB'(DB2ADMIN). ***'\n   SAY '*** DBDPRDC1 EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\n\"EXECIO * DISKR PARMDD (FINIS STEM AUTH.\"\nSRC = RC\n\"FREE FILE(PARMDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** EXECIO READ ERROR: ('PARMLIB'(DB2ADMIN). ***'\n   SAY '*** DBDPRDC1 EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nAUSER = TSOID','\nDO P = 1 TO PKGCNT\n   QUEUE PKG.P\nEND\nDO I = 1 TO AUTH.0\n   AUTHUSR = WORD(AUTH.I,1)\n   IF AUSER = AUTHUSR THEN ITERATE\n   DB2AUTH = '        '||AUTHUSR\n   QUEUE DB2AUTH\nEND\nQUEUE PKG.5\nDO B = 1 TO BNDCNT\n   QUEUE BND.B\nEND\nRETURN\n/*     */\nWRITE_DB2_PARMS:\n\"ALLOC DA('\"OUTPDS\"(\"MEMBER\")') FILE(DB2DD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('OUTPDS'('MEMBER'). ***'\n   SAY '*** DBDPRDC1 EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nNUMRCDS = QUEUED()\n\"EXECIO\" NUMRCDS \"DISKW DB2DD (FINIS\"\nSRC = RC\n\"FREE FILE(DB2DD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** WRITE ERROR: ERROR WRITING ('OUTPDS'('MEMBER').  ***'\n   SAY '*** DBDPRDC1 EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DB2QACPB": {"ttr": 11274, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\"\\x00\\x00\\x00\\x93\\x15?\\x00\\x953\\x9f\\x14%\\x01\\x83\\x00\\xcd\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf3@@@'", "ispf": {"version": "01.34", "flags": 0, "createdate": "1993-06-02T00:00:00", "modifydate": "1995-12-05T14:25:00", "lines": 387, "newlines": 205, "modlines": 0, "user": "TECH103"}, "text": "/*  REXX EXEC : ( DB2QACPB ).\n    FUNCTION  : CALLED BY CCF QA AND PROD TURNOVER PROCESSING SKELETON\n                ( CCFCDB2Q ) AT STEP ( STEP0020 ) FOR CICS PROGRAMS.\n                BUILDS THE PACKAGE/BIND/GRANT CONTROL PARM MEMBERS AND\n                WRITES THE MEMBERS INTO CORRESPONDING QA PDS CNTL LIBS.\n    INPUT     : SYSS.QA.CCF.DB2.TURNOVER.PARMLIB(&WORKORDR).\n    OUTPUT    : SYSS.QA.CCF.DB2.BIND.CNTLLIB(&PROGRAM).\n                SYSS.QA.CCF.DB2.GRANT.CNTLLIB(&PROGRAM).\n                SYSS.QA.CCF.DB2.PACKAGE.CNTLLIB(&PROGRAM).\n                                                                     */\nTRACE O\n/*     */\nHOUSE_KEEPING:\nADDRESS TSO\nARG MASTER MEMBER WORKORDR\nPARMS = 'MASTER MEMBER WORKORDR'\nSRC = 0\nDO I = 1 TO 3\n   IPARM = WORD(PARMS,I)\n   XPARM = VALUE(IPARM)\n   IF XPARM \u00ac= '' THEN ITERATE\n   SAY '*** PARM ERROR: MISSING PARM VALUE FOR ('IPARM'). ***'\n   SAY '*** DB2QACPB EXEC TASK CANCELLED - RC = (024). ***'\n   EXIT 024\nEND\nX = MSG(\"OFF\")\n\"FREE FILE(PARMDD)\"\n\"FREE FILE(DB2DD)\"\nTSOID = SYSVAR(SYSUID)\nLIBNODE = POS('TURNSRCE',MASTER)\nIF LIBNODE \u00ac= 0 THEN SIGNAL MAIN_ROUTINE_QA\nLIBNODE = POS('QASRCE',MASTER)\nIF LIBNODE \u00ac= 0 THEN SIGNAL MAIN_ROUTINE_PROD\nLIBNODE = POS('EMRGSRCE',MASTER)\nIF LIBNODE \u00ac= 0 THEN SIGNAL MAIN_ROUTINE_EMERGNCY\nSAY\nSAY '*** PARM ERROR: INVALID PARM VALUE PASSED: ('MASTER'). ***'\nSAY '*** THE SPECIFIED CCF LIBRARIAN MASTER IS NOT SUPPORTED. ***'\nSAY '*** DB2QACPB EXEC TASK CANCELLED - RC = (024). ***'\nSAY\nEXIT 024\n/*     */\nMAIN_ROUTINE_QA:\nDB2SYS = 'DSNX'\nDB2ACT = 'ADD'\nDB2QUAL = 'BUILD'\nDSNTPLAN = 'DSNTIA31'\nPARMLIB = 'SYSS.TECH.COMMON.PARMLIB'\nPARMPDS = 'SYSS.QA.CCF.DB2.TURNOVER.PARMLIB'\nBINDPDS = 'SYSS.QA.CCF.DB2.BIND.CNTLLIB'\nPACKPDS = 'SYSS.QA.CCF.DB2.PACKAGE.CNTLLIB'\nGRNTPDS = 'SYSS.QA.CCF.DB2.GRANT.CNTLLIB'\nRUNLIB = 'SYSS.DB2.V2R3M0.DB2X.RUNLIB.LOAD'\nCALL GET_DB2_PACKAGE_BIND_PARMS\nIF MEMBSW = 'NO' THEN DO\n   SAY\n   SAY '*** PARM ERROR: ENTRY NOT FOUND ('PARMPDS'('WORKORDR') ('MEMBER'). ***'\n   SAY '*** DB2 PACKAGE/BIND/GRANT SYSIN MEMBERS CANNOT BE WRITTEN FOR QA. ***'\n   SAY '> REJECT MEMBER, PROGRAMMER MUST SPECIFY TURNOVER (YES) COMPILE OPTION.'\n   SAY '*** DB2QACPB EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   SAY\n   EXIT SRC\nEND\nCALL BUILD_PACKAGE_SYSIN\nOUTPDS = PACKPDS\nCALL WRITE_DB2_PARMS\nCALL BUILD_BIND_SYSIN\nOUTPDS = BINDPDS\nCALL WRITE_DB2_PARMS\nCALL BUILD_GRANT_SYSIN_QA\nOUTPDS = GRNTPDS\nCALL WRITE_DB2_PARMS\nEXIT 1\n/*     */\nMAIN_ROUTINE_PROD:\nDB2SYS = 'DSNA'\nDB2ACT = 'ADD'\nDB2QUAL = 'BUILD'\nDSNTPLAN = 'DSNTIA23'\nPARMLIB = 'SYSS.TECH.COMMON.PARMLIB'\nPARMPDS = 'SYSS.QA.CCF.DB2.TURNOVER.PARMLIB'\nBINDPDS = 'SYSS.PROD.CCF.DB2.BIND.CNTLLIB'\nPACKPDS = 'SYSS.PROD.CCF.DB2.PACKAGE.CNTLLIB'\nGRNTPDS = 'SYSS.PROD.CCF.DB2.GRANT.CNTLLIB'\nRUNLIB = 'SYSS.DB2.V2R3M0.RUNLIB.LOAD'\nCALL GET_DB2_PACKAGE_BIND_PARMS\nIF MEMBSW = 'NO' THEN DO\n   SAY\n   SAY '*** PARM ERROR: ENTRY NOT FOUND ('PARMPDS'('WORKORDR') ('MEMBER'). ***'\n   SAY '*** DB2 PACKAGE/BIND/GRANT SYSIN MEMBERS CANNOT BE WRITTEN FOR PROD. **'\n   SAY '*** DB2QACPB EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   SAY\n   EXIT SRC\nEND\nCALL BUILD_PACKAGE_SYSIN\nOUTPDS = PACKPDS\nCALL WRITE_DB2_PARMS\nCALL BUILD_BIND_SYSIN\nOUTPDS = BINDPDS\nCALL WRITE_DB2_PARMS\nCALL BUILD_GRANT_SYSIN_PROD\nOUTPDS = GRNTPDS\nCALL WRITE_DB2_PARMS\nEXIT 2\n/*     */\nMAIN_ROUTINE_EMERGNCY:\nDB2SYS = 'DSNA'\nDB2ACT = 'REPLACE'\nDB2QUAL = 'BUILD'\nDSNTPLAN = 'DSNTIA23'\nPARMLIB = 'SYSS.TECH.COMMON.PARMLIB'\nBINDPDS = 'SYSS.PROD.CCF.DB2.BIND.CNTLLIB'\nPACKPDS = 'SYSS.PROD.CCF.DB2.PACKAGE.CNTLLIB'\nGRNTPDS = 'SYSS.PROD.CCF.DB2.GRANT.CNTLLIB'\nRUNLIB = 'SYSS.DB2.V2R3M0.RUNLIB.LOAD'\nCALL READ_PACKAGE_SYSIN_MEMBER\nCALL BUILD_PACKAGE_SYSIN\nOUTPDS = PACKPDS\nCALL WRITE_DB2_PARMS\nCALL BUILD_BIND_SYSIN\nOUTPDS = BINDPDS\nCALL WRITE_DB2_PARMS\nCALL BUILD_GRANT_SYSIN_PROD\nOUTPDS = GRNTPDS\nCALL WRITE_DB2_PARMS\nEXIT 3\n/*\n       S U B R O U T I N E S   S E C T I O N     */\n/*     */\nGET_DB2_PACKAGE_BIND_PARMS:\nSRC = 28\nMEMBSW = 'NO'\nDB2PARM = SYSDSN(\"'\"PARMPDS\"(\"WORKORDR\")'\")\nIF DB2PARM = 'MEMBER NOT FOUND' THEN DO\n   SAY '*** MEMBER ERROR: MEMBER NOT FOUND ('PARMPDS'('WORKORDR'). ***'\n   RETURN\nEND\n\"ALLOC DA('\"PARMPDS\"(\"WORKORDR\")') FILE(PARMDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('PARMPDS'('WORKORDR'). ***'\n   RETURN\nEND\n\"EXECIO * DISKR PARMDD (FINIS STEM QPARM.\"\nSRC = RC\n\"FREE FILE(PARMDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** EXECIO READ ERROR: ('PARMPDS'('WORKORDR'). ***'\n   RETURN\nEND\nDO I = 1 TO QPARM.0\n   PMEMBER = WORD(QPARM.I,1)\n   COLLID = WORD(QPARM.I,2)\n   PROGTYP = WORD(QPARM.I,3)\n   DBSUBSYS = WORD(QPARM.I,5)\n   DBTQUAL = WORD(QPARM.I,6)\n   IF PMEMBER = MEMBER & PROGTYP = 'CICS' THEN DO\n      MEMBSW = 'YES'\n      DB2COLL = COLLID\n      DB2PLAN = COLLID\n/*    IF DBSUBSYS \u00ac= '' THEN DB2SYS = DBSUBSYS\n      IF DBTQUAL \u00ac= '' THEN DB2QUAL = DBTQUAL     */\n      LEAVE\n   END\nEND\nIF DB2SYS = 'DB2Q' | DB2SYS = 'DB2P' THEN DO\n   RUNLIB = 'SYSS.DB2.V3R1M0.'DB2SYS'.RUNLIB.LOAD'\nEND\nDB2QUAL = 'BUILD'\nRETURN\n/*     */\nREAD_PACKAGE_SYSIN_MEMBER:\nDB2MEMB = SYSDSN(\"'\"PACKPDS\"(\"MEMBER\")'\")\nIF DB2MEMB = 'MEMBER NOT FOUND' THEN DO\n   SAY\n   SAY '*** MEMBER ERROR: MEMBER NOT FOUND ('PACKPDS'('MEMBER'). ***'\n   SAY '*** PACKAGE SYSIN MEMBER CANNOT BE WRITTEN FOR PROD TURNOVER. ***'\n   SAY '*** DB2QACPB EXEC SUBTASK CANCELLED - RETURN CODE: ('028'). ***'\n   SAY\n   EXIT 028\nEND\n\"ALLOC DA('\"PACKPDS\"(\"MEMBER\")') FILE(PARMDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY\n   SAY '*** DATASET ALLOCATE ERROR: ('PACKPDS'('MEMBER'). ***'\n   SAY '*** PACKAGE SYSIN MEMBER CANNOT BE WRITTEN FOR PROD TURNOVER. ***'\n   SAY '*** DB2QACPB EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   SAY\n   EXIT SRC\nEND\n\"EXECIO * DISKR PARMDD (FINIS STEM DATA.\"\nSRC = RC\n\"FREE FILE(PARMDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY\n   SAY '*** EXECIO READ ERROR: ('PACKPDS'('MEMBER'). ***'\n   SAY '*** PACKAGE SYSIN MEMBER CANNOT BE WRITTEN FOR PROD TURNOVER. ***'\n   SAY '*** DB2QACPB EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   SAY\n   EXIT SRC\nEND\nDO I = 1 TO DATA.0\n   PKEY = POS('BIND PACKAGE',DATA.I)\n   IF PKEY \u00ac= 0 THEN DO\n      COLLKEY = WORD(DATA.I,3)\n      COLLID = STRIP(COLLKEY,\"L\",\"(\")\n      COLLID = STRIP(COLLID,\"T\",\")\")\n      DB2COLL = COLLID\n      DB2PLAN = COLLID\n      LEAVE\n   END\nEND\nRETURN\n/*     */\nBUILD_PACKAGE_SYSIN:\n\"DELSTACK\"\nRCDCNT = 15\nRCD.1 = \" DSN SYSTEM(\"DB2SYS\")\"\nRCD.2 = \" BIND PACKAGE (\"DB2COLL\") -\"\nRCD.3 = \"      OWNER(\"TSOID\") -\"\nRCD.4 = \"      QUALIFIER(\"DB2QUAL\") -\"\nRCD.5 = \"      MEMBER (\"MEMBER\") - \"\nRCD.6 = \"      SQLERROR(NOPACKAGE) -\"\nRCD.7 = \"      VALIDATE(BIND) -\"\nRCD.8 = \"      FLAG(I) -\"\nRCD.9 = \"      ISOLATION (CS) -\"\nRCD.10 = \"      RELEASE(COMMIT) -\"\nRCD.11 = \"      EXPLAIN(NO) -\"\nRCD.12 = \"      CURRENTDATA(NO) -\"\nRCD.13 = \"      ACTION (\"DB2ACT\") -\"\nRCD.14 = \"      ENABLE(*)\"\nRCD.15 = \" END\"\nDO R = 1 TO RCDCNT\n   QUEUE RCD.R\nEND\nRETURN\n/*     */\nBUILD_BIND_SYSIN:\n\"DELSTACK\"\nRCDCNT = 15\nREC.1 = \" DSN SYSTEM(\"DB2SYS\")\"\nREC.2 = \" BIND PLAN (\"DB2PLAN\") -\"\nREC.3 = \"      OWNER(\"TSOID\") -\"\nREC.4 = \"      VALIDATE(BIND) -\"\nREC.5 = \"      FLAG(I) -\"\nREC.6 = \"      ACQUIRE(USE) -\"\nREC.7 = \"      ISOLATION(CS) -\"\nREC.8 = \"      RELEASE(COMMIT) -\"\nREC.9 = \"      EXPLAIN(NO) -\"\nREC.10 = \"      ACTION (REPLACE) -\"\nREC.11 = \"      PKLIST(\"DB2COLL\".*) -\"\nREC.12 = \"      ENABLE(*)\"\nREC.13 = \" RUN PROGRAM(DSNTIAD) PLAN(\"DSNTPLAN\") -\"\nREC.14 = \"     LIB('\"RUNLIB\"')\"\nREC.15 = \" END\"\nDO R = 1 TO RCDCNT\n   QUEUE REC.R\nEND\nRETURN\n/*     */\nBUILD_GRANT_SYSIN_QA:\n\"DELSTACK\"\nPKGCNT = 5\nCOMRCD = \"  COMMIT;\"\nPKG.1 = \"        GRANT\"\nPKG.2 = \"        BIND,\"\nPKG.3 = \"        COPY,\"\nPKG.4 = \"        EXECUTE\"\nPKG.5 = \"  ON PACKAGE \"DB2COLL\".* TO\"\nBNDCNT = 4\nBND.1 = \"        GRANT\"\nBND.2 = \"        BIND,\"\nBND.3 = \"        EXECUTE\"\nBND.4 = \"  ON PLAN \"DB2PLAN\" TO\"\nDB2PARM = SYSDSN(\"'\"PARMLIB\"(DB2ADMIN)'\")\nIF DB2PARM = 'MEMBER NOT FOUND' THEN DO\n   SAY '*** MEMBER ERROR: MEMBER NOT FOUND ('PARMLIB'(DB2ADMIN). ***'\n   SAY '*** DB2QACPB EXEC SUBTASK CANCELLED - RETURN CODE: ('028'). ***'\n   EXIT 028\nEND\n\"ALLOC DA('\"PARMLIB\"(DB2ADMIN)') FILE(PARMDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('PARMLIB'(DB2ADMIN). ***'\n   SAY '*** DB2QACPB EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\n\"EXECIO * DISKR PARMDD (FINIS STEM AUTH.\"\nSRC = RC\n\"FREE FILE(PARMDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** EXECIO READ ERROR: ('PARMLIB'(DB2ADMIN). ***'\n   SAY '*** DB2QACPB EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nAUSER = TSOID','\nDO P = 1 TO PKGCNT\n   QUEUE PKG.P\nEND\nDO I = 1 TO AUTH.0\n   AUTHUSR = WORD(AUTH.I,1)\n   IF AUSER = AUTHUSR THEN ITERATE\n   DB2AUTH = '        '||AUTHUSR\n   QUEUE DB2AUTH\nEND\nQUEUE COMRCD\nDO B = 1 TO BNDCNT\n   QUEUE BND.B\nEND\nDO I = 1 TO AUTH.0\n   AUTHUSR = WORD(AUTH.I,1)\n   IF AUSER = AUTHUSR THEN ITERATE\n   DB2AUTH = '        '||AUTHUSR\n   QUEUE DB2AUTH\nEND\nQUEUE COMRCD\nRETURN\n/*     */\nBUILD_GRANT_SYSIN_PROD:\n\"DELSTACK\"\nPKGCNT = 4\nPKG.1 = \"        GRANT\"\nPKG.2 = \"        BIND,\"\nPKG.3 = \"        COPY\"\nPKG.4 = \"  ON PACKAGE \"DB2COLL\".* TO\"\nPKG.5 = \"  COMMIT;\"\nBNDCNT = 4\nBND.1 = \"  GRANT EXECUTE ON PACKAGE \"DB2COLL\".* TO PUBLIC;\"\nBND.2 = \"  COMMIT;\"\nBND.3 = \"  GRANT EXECUTE ON PLAN \"DB2PLAN\" TO PUBLIC;\"\nBND.4 = \"  COMMIT;\"\nDB2PARM = SYSDSN(\"'\"PARMLIB\"(DB2ADMIN)'\")\nIF DB2PARM = 'MEMBER NOT FOUND' THEN DO\n   SAY '*** MEMBER ERROR: MEMBER NOT FOUND ('PARMLIB'(DB2ADMIN). ***'\n   SAY '*** DB2QACPB EXEC SUBTASK CANCELLED - RETURN CODE: ('028'). ***'\n   EXIT 028\nEND\n\"ALLOC DA('\"PARMLIB\"(DB2ADMIN)') FILE(PARMDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('PARMLIB'(DB2ADMIN). ***'\n   SAY '*** DB2QACPB EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\n\"EXECIO * DISKR PARMDD (FINIS STEM AUTH.\"\nSRC = RC\n\"FREE FILE(PARMDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** EXECIO READ ERROR: ('PARMLIB'(DB2ADMIN). ***'\n   SAY '*** DB2QACPB EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nAUSER = TSOID','\nDO P = 1 TO PKGCNT\n   QUEUE PKG.P\nEND\nDO I = 1 TO AUTH.0\n   AUTHUSR = WORD(AUTH.I,1)\n   IF AUSER = AUTHUSR THEN ITERATE\n   DB2AUTH = '        '||AUTHUSR\n   QUEUE DB2AUTH\nEND\nQUEUE PKG.5\nDO B = 1 TO BNDCNT\n   QUEUE BND.B\nEND\nRETURN\n/*     */\nWRITE_DB2_PARMS:\n\"ALLOC DA('\"OUTPDS\"(\"MEMBER\")') FILE(DB2DD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('OUTPDS'('MEMBER'). ***'\n   SAY '*** DB2QACPB EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nNUMRCDS = QUEUED()\n\"EXECIO\" NUMRCDS \"DISKW DB2DD (FINIS\"\nSRC = RC\n\"FREE FILE(DB2DD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** WRITE ERROR: ERROR WRITING ('OUTPDS'('MEMBER').  ***'\n   SAY '*** DB2QACPB EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DB2QAPBN": {"ttr": 11525, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01$\\x00\\x00\\x00\\x93\\x15?\\x00\\x953?\\x14\\x15\\x01S\\x00\\xcd\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf3@@@'", "ispf": {"version": "01.36", "flags": 0, "createdate": "1993-06-02T00:00:00", "modifydate": "1995-11-29T14:15:00", "lines": 339, "newlines": 205, "modlines": 0, "user": "TECH103"}, "text": "/*  REXX EXEC : ( DB2QAPBN ).\n    FUNCTION  : CALLED BY CCF QA AND PROD TURNOVER PROCESSING SKELETON\n                ( CCFBDB2Q ) AT STEP ( STEP0020 ) FOR BATCH PROGRAMS.\n                BUILDS THE PACKAGE/BIND/GRANT CONTROL PARM MEMBERS AND\n                WRITES THE MEMBERS INTO CORRESPONDING QA AND PROD LIBS.\n    INPUT     : SYSS.QA.CCF.DB2.TURNOVER.PARMLIB(&WORKORDR).\n    OUTPUT    : SYSS.&CCFNODE.CCF.DB2.BIND.CNTLLIB(&PROGRAM).\n                SYSS.&CCFNODE.CCF.DB2.GRANT.CNTLLIB(&PROGRAM).\n                SYSS.&CCFNODE.CCF.DB2.PACKAGE.CNTLLIB(&PROGRAM).\n                                                                     */\nTRACE O\n/*     */\nHOUSE_KEEPING:\nADDRESS TSO\nARG MASTER MEMBER WORKORDR\nPARMS = 'MASTER MEMBER WORKORDR'\nSRC = 0\nDO I = 1 TO 3\n   IPARM = WORD(PARMS,I)\n   XPARM = VALUE(IPARM)\n   IF XPARM \u00ac= '' THEN ITERATE\n   SAY\n   SAY '*** PARM ERROR: MISSING PARM VALUE FOR ('IPARM'). ***'\n   SAY '*** DB2QAPBN EXEC TASK CANCELLED - RC = (024). ***'\n   SAY\n   EXIT 024\nEND\nX = MSG(\"OFF\")\n\"FREE FILE(PARMDD)\"\n\"FREE FILE(DB2DD)\"\nTSOID = SYSVAR(SYSUID)\nLIBNODE = POS('TURNSRCE',MASTER)\nIF LIBNODE \u00ac= 0 THEN SIGNAL MAIN_ROUTINE_QA\nLIBNODE = POS('QASRCE',MASTER)\nIF LIBNODE \u00ac= 0 THEN SIGNAL MAIN_ROUTINE_PROD\nLIBNODE = POS('EMRGSRCE',MASTER)\nIF LIBNODE \u00ac= 0 THEN SIGNAL MAIN_ROUTINE_EMERGNCY\nSAY\nSAY '*** PARM ERROR: INVALID PARM VALUE PASSED: ('MASTER'). ***'\nSAY '*** THE SPECIFIED CCF LIBRARIAN MASTER IS NOT SUPPORTED. ***'\nSAY '*** DB2QAPBN EXEC TASK CANCELLED - RC = (024). ***'\nSAY\nEXIT 024\n/*     */\nMAIN_ROUTINE_QA:\nDB2SYS = 'DSNX'\nDB2ACT = 'ADD'\nDB2QUAL = 'BUILD'\nDSNTPLAN = 'DSNTIA31'\nPARMLIB = 'SYSS.TECH.COMMON.PARMLIB'\nPARMPDS = 'SYSS.QA.CCF.DB2.TURNOVER.PARMLIB'\nBINDPDS = 'SYSS.QA.CCF.DB2.BIND.CNTLLIB'\nPACKPDS = 'SYSS.QA.CCF.DB2.PACKAGE.CNTLLIB'\nGRNTPDS = 'SYSS.QA.CCF.DB2.GRANT.CNTLLIB'\nRUNLIB = 'SYSS.DB2.V2R3M0.DB2X.RUNLIB.LOAD'\nCALL GET_DB2_PACKAGE_BIND_PARMS\nIF MEMBSW = 'NO' THEN DO\n   SAY\n   SAY '*** PARM ERROR: ENTRY NOT FOUND ('PARMPDS'('WORKORDR') ('MEMBER'). ***'\n   SAY '*** DB2 PACKAGE/BIND/GRANT SYSIN MEMBERS CANNOT BE WRITTEN FOR QA. ***'\n   SAY '> REJECT MEMBER, PROGRAMMER MUST SPECIFY TURNOVER (YES) COMPILE OPTION.'\n   SAY '*** DB2QAPBN EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   SAY\n   EXIT SRC\nEND\nCALL BUILD_PACKAGE_SYSIN\nOUTPDS = PACKPDS\nCALL WRITE_DB2_PARMS\nCALL BUILD_BIND_SYSIN\nOUTPDS = BINDPDS\nCALL WRITE_DB2_PARMS\nCALL BUILD_GRANT_SYSIN\nOUTPDS = GRNTPDS\nCALL WRITE_DB2_PARMS\nEXIT 1\n/*     */\nMAIN_ROUTINE_PROD:\nDB2SYS = 'DSNA'\nDB2ACT = 'ADD'\nDB2QUAL = 'BUILD'\nDSNTPLAN = 'DSNTIA23'\nPARMLIB = 'SYSS.TECH.COMMON.PARMLIB'\nPARMPDS = 'SYSS.QA.CCF.DB2.TURNOVER.PARMLIB'\nBINDPDS = 'SYSS.PROD.CCF.DB2.BIND.CNTLLIB'\nPACKPDS = 'SYSS.PROD.CCF.DB2.PACKAGE.CNTLLIB'\nGRNTPDS = 'SYSS.PROD.CCF.DB2.GRANT.CNTLLIB'\nRUNLIB = 'SYSS.DB2.V2R3M0.RUNLIB.LOAD'\nCALL GET_DB2_PACKAGE_BIND_PARMS\nIF MEMBSW = 'NO' THEN DO\n   SAY\n   SAY '*** PARM ERROR: ENTRY NOT FOUND ('PARMPDS'('WORKORDR') ('MEMBER'). ***'\n   SAY '*** DB2 PACKAGE/BIND/GRANT SYSIN MEMBERS CANNOT BE WRITTEN FOR PROD. **'\n   SAY '*** DB2QAPBN EXEC SUBTASK CANCELLED - RETURN CODE: ('028'). ***'\n   SAY\n   EXIT 028\nEND\nCALL BUILD_PACKAGE_SYSIN\nOUTPDS = PACKPDS\nCALL WRITE_DB2_PARMS\nCALL BUILD_BIND_SYSIN\nOUTPDS = BINDPDS\nCALL WRITE_DB2_PARMS\nCALL BUILD_GRANT_SYSIN\nOUTPDS = GRNTPDS\nCALL WRITE_DB2_PARMS\nEXIT 2\n/*     */\nMAIN_ROUTINE_EMERGNCY:\nDB2SYS = 'DSNA'\nDB2ACT = 'REPLACE'\nDB2QUAL = 'BUILD'\nDSNTPLAN = 'DSNTIA23'\nPARMLIB = 'SYSS.TECH.COMMON.PARMLIB'\nBINDPDS = 'SYSS.PROD.CCF.DB2.BIND.CNTLLIB'\nPACKPDS = 'SYSS.PROD.CCF.DB2.PACKAGE.CNTLLIB'\nGRNTPDS = 'SYSS.PROD.CCF.DB2.GRANT.CNTLLIB'\nRUNLIB = 'SYSS.DB2.V2R3M0.RUNLIB.LOAD'\nCALL READ_PACKAGE_SYSIN_MEMBER\nCALL BUILD_PACKAGE_SYSIN\nOUTPDS = PACKPDS\nCALL WRITE_DB2_PARMS\nCALL BUILD_BIND_SYSIN\nOUTPDS = BINDPDS\nCALL WRITE_DB2_PARMS\nCALL BUILD_GRANT_SYSIN\nOUTPDS = GRNTPDS\nCALL WRITE_DB2_PARMS\nEXIT 3\n/*\n       S U B R O U T I N E S   S E C T I O N     */\n/*     */\nGET_DB2_PACKAGE_BIND_PARMS:\nSRC = 028\nMEMBSW = 'NO'\nDB2PARM = SYSDSN(\"'\"PARMPDS\"(\"WORKORDR\")'\")\nIF DB2PARM = 'MEMBER NOT FOUND' THEN DO\n   SAY '*** MEMBER ERROR: MEMBER NOT FOUND ('PARMPDS'('WORKORDR'). ***'\n   RETURN\nEND\n\"ALLOC DA('\"PARMPDS\"(\"WORKORDR\")') FILE(PARMDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('PARMPDS'('WORKORDR'). ***'\n   RETURN\nEND\n\"EXECIO * DISKR PARMDD (FINIS STEM QPARM.\"\nSRC = RC\n\"FREE FILE(PARMDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** EXECIO READ ERROR: ('PARMPDS'('WORKORDR'). ***'\n   RETURN\nEND\nDO I = 1 TO QPARM.0\n   PMEMBER = WORD(QPARM.I,1)\n   COLLID = WORD(QPARM.I,2)\n   PROGTYP = WORD(QPARM.I,3)\n   DBSUBSYS = WORD(QPARM.I,5)\n   DBTQUAL = WORD(QPARM.I,6)\n   IF PMEMBER = MEMBER & PROGTYP = 'BATCH' THEN DO\n      MEMBSW = 'YES'\n      DB2COLL = COLLID\n      DB2PLAN = COLLID\n/*    IF DBSUBSYS \u00ac= '' THEN DB2SYS = DBSUBSYS\n      IF DBTQUAL \u00ac= '' THEN DB2QUAL = DBTQUAL   */\n      LEAVE\n   END\nEND\nIF DB2SYS = 'DB2Q' | DB2SYS = 'DB2P' THEN DO\n   RUNLIB = 'SYSS.DB2.V3R1M0.'DB2SYS'.RUNLIB.LOAD'\nEND\nDB2QUAL = 'BUILD'\nRETURN\n/*     */\nREAD_PACKAGE_SYSIN_MEMBER:\nDB2MEMB = SYSDSN(\"'\"PACKPDS\"(\"MEMBER\")'\")\nIF DB2MEMB = 'MEMBER NOT FOUND' THEN DO\n   SAY\n   SAY '*** MEMBER ERROR: MEMBER NOT FOUND ('PACKPDS'('MEMBER'). ***'\n   SAY '*** PACKAGE SYSIN MEMBER CANNOT BE WRITTEN FOR PROD TURNOVER. ***'\n   SAY '*** DB2QAPBN EXEC SUBTASK CANCELLED - RETURN CODE: ('028'). ***'\n   SAY\n   EXIT 028\nEND\n\"ALLOC DA('\"PACKPDS\"(\"MEMBER\")') FILE(PARMDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY\n   SAY '*** DATASET ALLOCATE ERROR: ('PACKPDS'('MEMBER'). ***'\n   SAY '*** PACKAGE SYSIN MEMBER CANNOT BE WRITTEN FOR PROD TURNOVER. ***'\n   SAY '*** DB2QAPBN EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   SAY\n   EXIT SRC\nEND\n\"EXECIO * DISKR PARMDD (FINIS STEM DATA.\"\nSRC = RC\n\"FREE FILE(PARMDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY\n   SAY '*** EXECIO READ ERROR: ('PACKPDS'('MEMBER'). ***'\n   SAY '*** PACKAGE SYSIN MEMBER CANNOT BE WRITTEN FOR PROD TURNOVER. ***'\n   SAY '*** DB2QAPBN EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   SAY\n   EXIT SRC\nEND\nDO I = 1 TO DATA.0\n   PKEY = POS('BIND PACKAGE',DATA.I)\n   IF PKEY \u00ac= 0 THEN DO\n      COLLKEY = WORD(DATA.I,3)\n      COLLID = STRIP(COLLKEY,\"L\",\"(\")\n      COLLID = STRIP(COLLID,\"T\",\")\")\n      DB2COLL = COLLID\n      DB2PLAN = COLLID\n      LEAVE\n   END\nEND\nRETURN\n/*     */\nBUILD_PACKAGE_SYSIN:\n\"DELSTACK\"\nRCDCNT = 15\nRCD.1 = \" DSN SYSTEM(\"DB2SYS\")\"\nRCD.2 = \" BIND PACKAGE (\"DB2COLL\") -\"\nRCD.3 = \"      OWNER(\"TSOID\") -\"\nRCD.4 = \"      QUALIFIER(\"DB2QUAL\") -\"\nRCD.5 = \"      MEMBER (\"MEMBER\") - \"\nRCD.6 = \"      SQLERROR(NOPACKAGE) -\"\nRCD.7 = \"      VALIDATE(BIND) -\"\nRCD.8 = \"      FLAG(I) -\"\nRCD.9 = \"      ISOLATION (CS) -\"\nRCD.10 = \"      RELEASE(COMMIT) -\"\nRCD.11 = \"      EXPLAIN(NO) -\"\nRCD.12 = \"      CURRENTDATA(NO) -\"\nRCD.13 = \"      ACTION (\"DB2ACT\") -\"\nRCD.14 = \"      ENABLE(*)\"\nRCD.15 = \" END\"\nDO R = 1 TO RCDCNT\n   QUEUE RCD.R\nEND\nRETURN\n/*     */\nBUILD_BIND_SYSIN:\n\"DELSTACK\"\nRCDCNT = 15\nREC.1 = \" DSN SYSTEM(\"DB2SYS\")\"\nREC.2 = \" BIND PLAN (\"DB2PLAN\") -\"\nREC.3 = \"      OWNER(\"TSOID\") -\"\nREC.4 = \"      VALIDATE(BIND) -\"\nREC.5 = \"      FLAG(I) -\"\nREC.6 = \"      ACQUIRE(USE) -\"\nREC.7 = \"      ISOLATION(CS) -\"\nREC.8 = \"      RELEASE(COMMIT) -\"\nREC.9 = \"      EXPLAIN(NO) -\"\nREC.10 = \"      ACTION (REPLACE) -\"\nREC.11 = \"      PKLIST(\"DB2COLL\".*) -\"\nREC.12 = \"      ENABLE(*)\"\nREC.13 = \" RUN PROGRAM(DSNTIAD) PLAN(\"DSNTPLAN\") -\"\nREC.14 = \"     LIB('\"RUNLIB\"')\"\nREC.15 = \" END\"\nDO R = 1 TO RCDCNT\n   QUEUE REC.R\nEND\nRETURN\n/*     */\nBUILD_GRANT_SYSIN:\n\"DELSTACK\"\nPKGCNT = 5\nCOMRCD = \"  COMMIT;\"\nPKG.1 = \"        GRANT\"\nPKG.2 = \"        BIND,\"\nPKG.3 = \"        COPY,\"\nPKG.4 = \"        EXECUTE\"\nPKG.5 = \"  ON PACKAGE \"DB2COLL\".* TO\"\nBNDCNT = 4\nBND.1 = \"        GRANT\"\nBND.2 = \"        BIND,\"\nBND.3 = \"        EXECUTE\"\nBND.4 = \"  ON PLAN \"DB2PLAN\" TO\"\nDB2PARM = SYSDSN(\"'\"PARMLIB\"(DB2ADMIN)'\")\nIF DB2PARM = 'MEMBER NOT FOUND' THEN DO\n   SAY '*** MEMBER ERROR: MEMBER NOT FOUND ('PARMLIB'(DB2ADMIN). ***'\n   SAY '*** DB2QAPBN EXEC SUBTASK CANCELLED - RETURN CODE: ('028'). ***'\n   EXIT 028\nEND\n\"ALLOC DA('\"PARMLIB\"(DB2ADMIN)') FILE(PARMDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('PARMLIB'(DB2ADMIN). ***'\n   SAY '*** DB2QAPBN EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\n\"EXECIO * DISKR PARMDD (FINIS STEM AUTH.\"\nSRC = RC\n\"FREE FILE(PARMDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** EXECIO READ ERROR: ('PARMLIB'(DB2ADMIN). ***'\n   SAY '*** DB2QAPBN EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nAUSER = TSOID','\nDO P = 1 TO PKGCNT\n   QUEUE PKG.P\nEND\nDO I = 1 TO AUTH.0\n   AUTHUSR = WORD(AUTH.I,1)\n   IF AUSER = AUTHUSR THEN ITERATE\n   DB2AUTH = '        '||AUTHUSR\n   QUEUE DB2AUTH\nEND\nQUEUE COMRCD\nDO B = 1 TO BNDCNT\n   QUEUE BND.B\nEND\nDO I = 1 TO AUTH.0\n   AUTHUSR = WORD(AUTH.I,1)\n   IF AUSER = AUTHUSR THEN ITERATE\n   DB2AUTH = '        '||AUTHUSR\n   QUEUE DB2AUTH\nEND\nQUEUE COMRCD\nRETURN\n/*     */\nWRITE_DB2_PARMS:\n\"ALLOC DA('\"OUTPDS\"(\"MEMBER\")') FILE(DB2DD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('OUTPDS'('MEMBER'). ***'\n   SAY '*** DB2QAPBN EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nNUMRCDS = QUEUED()\n\"EXECIO\" NUMRCDS \"DISKW DB2DD (FINIS\"\nSRC = RC\n\"FREE FILE(DB2DD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** WRITE ERROR: ERROR WRITING ('OUTPDS'('MEMBER').  ***'\n   SAY '*** DB2QAPBN EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DB2QAPRM": {"ttr": 11531, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0b\\x00\\x00\\x00\\x93\\x15/\\x00\\x95)\\x8f\\x173\\x00\\x95\\x00\\x93\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf3@@@'", "ispf": {"version": "01.11", "flags": 0, "createdate": "1993-06-01T00:00:00", "modifydate": "1995-10-25T17:33:00", "lines": 149, "newlines": 147, "modlines": 0, "user": "TECH103"}, "text": "/*  REXX EXEC : ( DB2QAPRM ).\n    FUNCTION  : CALLED BY CCF QA AND PROD TURNOVER PROCESSING SKELETONS\n                ( CCFBDB2Q AND CCFCDB2Q ) AT STEP ( STEP0010 ).\n                VERIFIES THE EXISTENCE OF THE PACKAGE/BIND PARMLIB\n                WORKORDER MEMBER FOR EXECIO WRITE TO THE QA PARMLIB.\n    INPUT     : SYSS.TESTCCF.DB2.TURNOVER.PARMLIB(WORKORDR).\n    OUTPUT    : SYSS.QA.CCF.DB2.TURNOVER.PARMLIB(WORKORDR).\n                                                                     */\nTRACE O\n/*     */\nHOUSE_KEEPING:\nADDRESS TSO\nARG MASTER MEMBER WORKORDR\nPARMS = 'MASTER MEMBER WORKORDR'\nSRC = 0\nDO I = 1 TO 3\n   IPARM = WORD(PARMS,I)\n   XPARM = VALUE(IPARM)\n   IF XPARM \u00ac= '' THEN ITERATE\n   SAY '*** PARM ERROR: MISSING PARM VALUE FOR ('IPARM'). ***'\n   SAY '*** DB2QAPRM EXEC TASK CANCELLED - RC = (024). ***'\n   EXIT 024\nEND\nX = MSG(\"OFF\")\n\"FREE FILE(TESTDD)\"\n\"FREE FILE(QADD)\"\nLIBNODE = POS('QASRCE',MASTER)\nIF LIBNODE = 0 THEN EXIT 0\n/*     */\nMAIN_ROUTINE_QA:\nTESTCCF = 'SYSS.TESTCCF.DB2.TURNOVER.PARMLIB'\nQACCF = 'SYSS.QA.CCF.DB2.TURNOVER.PARMLIB'\nCALL CHECK_TESTCCF_PARMS\nIF MEMBSW = 'YES' THEN DO\n   CALL CHECK_QACCF_PARMS\n   INTERPRET CALL LABEL\n   IF WRITESW = 'ERROR' THEN CALL PARM_WRITE_ERROR\nEND\nIF MEMBSW = 'NO' THEN DO\n   SAY\n   SAY '*** PARMLIB MEMBER ERROR: ('TESTCCF'('WORKORDR') ('MEMBER'). ***'\n   SAY '*** DB2 PACKAGE/BIND PARMS CANNOT BE WRITTEN FOR QA TURNOVER. ***'\n   SAY '+ REJECT MEMBER, PROGRAMMER MUST SPECIFY TURNOVER (YES) COMPILE OPTION.'\n   SAY '*** DB2QAPRM EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   SAY\n   EXIT SRC\nEND\nEXIT 0\n\n/*     S U B R O U T I N E S   S E C T I O N     */\n/*     */\nCHECK_TESTCCF_PARMS:\nSRC = 28\nMEMBSW = 'NO'\nDB2PARM = SYSDSN(\"'\"TESTCCF\"(\"WORKORDR\")'\")\nIF DB2PARM = 'MEMBER NOT FOUND' THEN RETURN\n\"ALLOC DA('\"TESTCCF\"(\"WORKORDR\")') FILE(TESTDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('TESTCCF'('WORKORDR'). ***'\n   RETURN\nEND\n\"EXECIO * DISKR TESTDD (FINIS STEM TPARM.\"\nSRC = RC\n\"FREE FILE(TESTDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** EXECIO READ ERROR: ('TESTCCF'('WORKORDR'). ***'\n   RETURN\nEND\nDO I = 1 TO TPARM.0\n   PMEMBER = WORD(TPARM.I,1)\n   IF PMEMBER = MEMBER THEN DO\n      MEMBSW = 'YES'\n      RECORD = TPARM.I\n      LEAVE\n   END\nEND\nRETURN\n/*     */\nCHECK_QACCF_PARMS:\nMATCHSW = 'NO'\nLABEL = REWRITE_QA_PARMS\nDB2PARM = SYSDSN(\"'\"QACCF\"(\"WORKORDR\")'\")\nIF DB2PARM = 'MEMBER NOT FOUND' THEN DO\n   LABEL = WRITE_QA_PARMS\n   RETURN\nEND\n\"ALLOC DA('\"QACCF\"(\"WORKORDR\")') FILE(QADD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('QACCF'('WORKORDR'). ***'\n   SAY '*** DB2QAPRM EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\n\"EXECIO * DISKR QADD (FINIS STEM QPARM.\"\nSRC = RC\n\"FREE FILE(QADD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** EXECIO READ ERROR: ('QACCF'('WORKORDR'). ***'\n   SAY '*** DB2QAPRM EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nDO I = 1 TO QPARM.0\n   PMEMBER = WORD(QPARM.I,1)\n   IF PMEMBER = MEMBER THEN DO\n      MATCHSW = 'YES'\n      QPARM.I = RECORD\n      LEAVE\n   END\nEND\nRETURN\n/*     */\nWRITE_QA_PARMS:\nWRITESW = 'OK'\n\"ALLOC DA('\"QACCF\"(\"WORKORDR\")') FILE(QADD) SHR\"\n\"DELSTACK\"\nQUEUE RECORD\n\"EXECIO 1 DISKW QADD (FINIS\"\nSRC = RC\n\"FREE FILE(QADD)\"\nIF SRC \u00ac= 0 THEN WRITESW = 'ERROR'\nRETURN\n/*     */\nREWRITE_QA_PARMS:\nWRITESW = 'OK'\n\"ALLOC DA('\"QACCF\"(\"WORKORDR\")') FILE(QADD) SHR\"\n\"DELSTACK\"\nDO I = 1 TO QPARM.0\n   QUEUE QPARM.I\nEND\nIF MATCHSW = 'NO' THEN QUEUE RECORD\nRCDCNT = QUEUED()\n\"EXECIO\" RCDCNT \"DISKW QADD (FINIS\"\nSRC = RC\n\"FREE FILE(QADD)\"\nIF SRC \u00ac= 0 THEN WRITESW = 'ERROR'\nRETURN\n/*     */\nNOOP_ROUTINE:\nWRITESW = 'OK'\nRETURN\n\n/*     */\nPARM_WRITE_ERROR:\nSAY '************************************************************************'\nSAY '*** PARMLIB WRITE ERROR: ('QACCF'('WORKORDR'). ***'\nSAY '*** DB2QAPRM EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\nSAY '************************************************************************'\nEXIT SRC\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DB2RMLIB": {"ttr": 11780, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0b\\x00\\x00\\x00\\x93\\x00_\\x00\\x94\\x08\\x0f\\x16Y\\x00\\x18\\x00\\x12\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf3@@@'", "ispf": {"version": "01.11", "flags": 0, "createdate": "1993-01-05T00:00:00", "modifydate": "1994-03-21T16:59:00", "lines": 24, "newlines": 18, "modlines": 0, "user": "TECH103"}, "text": "/* REXX EXEC : ( DB2RMLIB ).\n   FUNCTION  : CHECK AND/OR ALLOCATE THE USER.DBRMLIB DATASET FOR\n               STORING THE DB2 COMPILE GENERATED DBRM'S.\n                                                                      */\nTRACE O\n/*      */\nADDRESS TSO\nSRC = 0\nDUNIT = 'APPLTA'\nTSOID = SYSVAR(SYSUID)\nTSOPRFX = SUBSTR(TSOID,1,4)\nIF TSOPRFX = 'TECH' THEN DUNIT = 'SMS'\nUCNTL = SYSDSN(USER.DBRMLIB)\nIF UCNTL = 'DATASET NOT FOUND' THEN DO\n\"ATTRIB ATTRB1 DSORG(PO) RECFM(F,B) LRECL(80) BLKSIZE(27920)\"\n\"ALLOC DA(USER.DBRMLIB) NEW SPACE(15,3) DIR(44) USING(ATTRB1) UNIT(\"DUNIT\")\"\n   SRC = RC\n   IF SRC \u00ac= 0 THEN DO\n   SAY '*** ALLOCATE ERROR: ERROR ALLOCATING DATASET (USER.DBRMLIB). ***'\n   SAY '*** DB2RMLIB EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\n   END\nEND\nEXIT SRC\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DB2TEPCK": {"ttr": 11782, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x93\\x10_\\x00\\x93\\x10_\\x10\"\\x00\\x18\\x00\\x18\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf1\\xf0@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1993-04-15T00:00:00", "modifydate": "1993-04-15T10:22:00", "lines": 24, "newlines": 24, "modlines": 0, "user": "TECH110"}, "text": "/* REXX DB2 system dependent invoke DSNTEP2 */\ntrue=1;\nfalse=0;\nsysalib = \"'SYSS.DB2.V2R3M0.RUNLIB.LOAD'\";\nsysblib = \"'SYSS.DB2.V2R3M0.DB2B.RUNLIB.LOAD'\";\ncvtptr = storage(\"00000010\",4); /* locate llt/smca from cvt */\ncvtsmca = storage(d2x(c2d(cvtptr)+196),4); /* mapping smca */\nsavehi=substr(c2x(cvtsmca),1,2); /* hi order bit is on */\nsmcasid = savehi||d2x(x2d(substr(c2x(cvtsmca),3))+16);\nsmcasid = storage(smcasid,4); /* SMF id */\nselect;\n  when (smcasid=\"SYSA\") then do;\n    queue \"DSN SYSTEM(DSNA)\";\n    queue \"RUN PROGRAM(DSNTEP2) PLAN(DSNTEP23) LIBRARY(\"sysalib\")\";\n    queue \"END\";\n         end;\n  when (smcasid=\"SYSB\") then do;\n    queue \"DSN SYSTEM(DSNB)\";\n    queue \"RUN PROGRAM(DSNTEP2) PLAN(DSNTEP23) LIBRARY(\"sysblib\")\";\n    queue \"END\";\n         end;\n  otherwise exit 24;\nend;\nexit 0;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DB2TIACK": {"ttr": 11784, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x93\\x10_\\x00\\x93\\x10_\\x10\\x17\\x00\\x18\\x00\\x1b\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf1\\xf0@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1993-04-15T00:00:00", "modifydate": "1993-04-15T10:17:00", "lines": 24, "newlines": 27, "modlines": 0, "user": "TECH110"}, "text": "/* REXX DB2 system dependent invoke DSNTIAD */\ntrue=1;\nfalse=0;\nsysalib = \"'SYSS.DB2.V2R3M0.RUNLIB.LOAD'\";\nsysblib = \"'SYSS.DB2.V2R3M0.DB2B.RUNLIB.LOAD'\";\ncvtptr = storage(\"00000010\",4); /* locate llt/smca from cvt */\ncvtsmca = storage(d2x(c2d(cvtptr)+196),4); /* mapping smca */\nsavehi=substr(c2x(cvtsmca),1,2); /* hi order bit is on */\nsmcasid = savehi||d2x(x2d(substr(c2x(cvtsmca),3))+16);\nsmcasid = storage(smcasid,4); /* SMF id */\nselect;\n  when (smcasid=\"SYSA\") then do;\n    queue \"DSN SYSTEM(DSNA)\";\n    queue \"RUN PROGRAM(DSNTIAD) PLAN(DSNTIA23) LIBRARY(\"sysalib\")\";\n    queue \"END\";\n         end;\n  when (smcasid=\"SYSB\") then do;\n    queue \"DSN SYSTEM(DSNB)\";\n    queue \"RUN PROGRAM(DSNTIAD) PLAN(DSNTIA23) LIBRARY(\"sysblib\")\";\n    queue \"END\";\n         end;\n  otherwise exit 24;\nend;\nexit 0;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DDSSHUT": {"ttr": 11786, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x06\\x00\\x00\\x00\\x92&\\x9f\\x00\\x94%\\x1f\\x11'\\x00:\\x00\\x16\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf3@@@\"", "ispf": {"version": "01.06", "flags": 0, "createdate": "1992-09-25T00:00:00", "modifydate": "1994-09-08T11:27:00", "lines": 58, "newlines": 22, "modlines": 0, "user": "TECH103"}, "text": "/* REXX EXEC : ( DDSSHUT )\n   FUNCTION  : SHUTDOWN THE APCDDS AND DATACOM STARTED TASKS PRIOR\n               TO EXECUTING THE DATABASE DATASETS BACKUP.             */\nTRACE O\n/*     */\nMAIN_SHUTDOWN:\nERC = 0\n\"CONSOLE ACTIVATE\"\nSRC = RC\n\"CONSPROF SOLDISPLAY(NO)\"\nADDRESS CONSOLE\n\"D R,L\"\nX = GETMSG('MSGTXT.','SOL',,,15)\nIF SRC \u00ac= 0 THEN DO\n   ERC = 12\n   EXIT ERC\nEND\nDO I = 1 TO MSGTXT.0\n   DDSMSG = POS('CATK0246',MSGTXT.I)\n   IF DDSMSG \u00ac= 0 THEN DO\n      REPLY_ID = WORD(MSGTXT.I,1)\n      LEAVE\n   END\nEND\n\"R \"REPLY_ID\",DDSSHUT\"\nADDRESS TSO\n\"SLEEP 000100\"\nADDRESS CONSOLE\n\"P DATACOM\"\nADDRESS TSO\n\"SLEEP 000045\"\n/*     */\nCHECK_DATACOM_SHUTDOWN:\nDATSW = 'NO'\nADDRESS CONSOLE\n\"D A,L\"\nX = GETMSG('MSGTXT.','SOL',,,15)\nDO I = 1 TO MSGTXT.0\n   DAOSTC = POS('DATACOM',MSGTXT.I)\n   IF DAOSTC \u00ac= 0 THEN DATSW = 'YES'\nEND\nIF DATSW = 'NO' THEN SIGNAL EXIT_TASK\n\"C DATACOM\"\nADDRESS TSO\n\"SLEEP 000015\"\nADDRESS CONSOLE\n\"S DATACOM\"\nADDRESS TSO\n\"SLEEP 000015\"\nADDRESS CONSOLE\n\"P DATACOM\"\nADDRESS TSO\n\"SLEEP 000030\"\n/*     */\nEXIT_TASK:\nADDRESS TSO\n\"CONSOLE DEACTIVATE\"\nEXIT 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DDSSTART": {"ttr": 11788, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x92&\\x9f\\x00\\x94 \\x7f\\x12\\x13\\x00\\x0e\\x00\\x0b\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf3@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1992-09-25T00:00:00", "modifydate": "1994-07-26T12:13:00", "lines": 14, "newlines": 11, "modlines": 0, "user": "TECH103"}, "text": "/* REXX EXEC : ( DDSSTART )\n   FUNCTION  : START THE DATACOM AND APCDDS STARTED TASKS AFTER\n               COMPLETION OF THE DATABASE DATASETS BACKUP.            */\nTRACE O\n\"CONSOLE ACTIVATE\"\nADDRESS CONSOLE\n\"S DATACOM\"\nADDRESS TSO\n\"SLEEP 000100\"\nADDRESS CONSOLE\n\"S APCDDS\"\nADDRESS TSO\n\"CONSOLE DEACTIVATE\"\nEXIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DELETENV": {"ttr": 11790, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\r\\x00\\x00\\x00\\x95\\x02O\\x00\\x95\\x02\\x7f\\x12F\\x00(\\x00\\xb1\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf2\\xf0\\xf9@@@'", "ispf": {"version": "01.13", "flags": 0, "createdate": "1995-01-24T00:00:00", "modifydate": "1995-01-27T12:46:00", "lines": 40, "newlines": 177, "modlines": 0, "user": "TECH209"}, "text": "/*  REXX EXEC : ( DELETENV ).\n    FUNCTION  : PERFORMS IDCAMS LISTCAT FOR A SPECIFIED NONVSAM\n                DATASET AND DELETES THE FILE.\n                                                                    */\nTRACE O\n/*      */\nHOUSE_KEEPING:\nADDRESS TSO\nPARSE UPPER ARG NVFILE .\nIF GDGLVL = '' THEN DO\n   SAY '***********************************************************************'\n   SAY '*** PARM ERROR: NONVSAM DATASET NAME LEVEL QUALIFIER NOT PASSED . ***'\n   SAY '*** DELETENV EXEC TASK CANCELLED. ***'\n   SAY '***********************************************************************'\n   EXIT 024\nEND\n/*     */\nDELETE_DASD_NV:\n\"LISTCAT ENT('\"NVFILE\"') ALL\"\nSRC = RC\n SAY SRC\nIF SRC \\= 0 THEN DO\n   SAY '***********************************************************************'\n   SAY '*** DATASET DOES NOT EXIST. NO DELETE IS REQUIRED.              . ***'\n   SAY '***********************************************************************'\n   EXIT 000\nEND\n   \"ALLOC DA('\"NVFILE\"') FILE(NVFDD) SHR\"\nSRC = RC\n SAY SRC\nIF SRC \\= 0 THEN DO\n   SAY '***********************************************************************'\n   SAY '*** PARM ERROR: DSN IN USE. FILE CANNOT BE DELETED.             . ***'\n   SAY '*** DELETENV EXEC TASK CANCELLED. ***'\n   SAY '***********************************************************************'\n   EXIT 024\nEND\n   \"DELETE   ('\"NVFILE\"')   NONVSAM PURGE FILE(NVFDD)\"\n\"FREE FILE(NVFDD)\"\n/*     */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DELETGDG": {"ttr": 11792, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01#\\x00\\x00\\x00\\x94\\x17\\x9f\\x00\\x95\\x19/\\tU\\x00\\x9c\\x007\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf3@@@'", "ispf": {"version": "01.35", "flags": 0, "createdate": "1994-06-28T00:00:00", "modifydate": "1995-07-11T09:55:00", "lines": 156, "newlines": 55, "modlines": 0, "user": "TECH103"}, "text": "/*  REXX EXEC : ( DELETGDG ).\n    FUNCTION  : PERFORMS IDCAMS LISTCAT LEVEL FOR A SPECIFIED BASE GDG\n                DATASET AND DELETES THE ASSOCIATED GENERATIONS.\n    AUTHOR    : DAN BOWEN, TECH SERVICES.\n                                                                    */\nTRACE O\n/*      */\nHOUSE_KEEPING:\nADDRESS TSO\nPARSE UPPER ARG GDGLVL .\nIF GDGLVL = '' THEN DO\n   SAY '***********************************************************************'\n   SAY '*** PARM ERROR: GDG BASE DATASET NAME LEVEL QUALIFIER NOT PASSED. ***'\n   SAY '*** DELETEGDG EXEC TASK CANCELLED. ***'\n   SAY '***********************************************************************'\n   EXIT 024\nEND\nX = MSG(\"OFF\")\nCURTIME = TIME()\nHH = SUBSTR(CURTIME,1,2)\nMM = SUBSTR(CURTIME,4,2)\nSS = SUBSTR(CURTIME,7,2)\nTIMEP = HH||MM||SS\nOUTPDS = 'SYSS.TLMS.CNTLLIB'\nMEMBER = 'TL'TIMEP\nTAPEKEY = SUBSTR(GDGLVL,1,4)\nENDCNT = 8\nJCLCNT = 5\nJCL.1 = \"//CTTUTIL  JOB 5304010530000000,'CTT SCRATCH ULITITY',\"\nJCL.2 = \"//         CLASS=H,MSGCLASS=S,MSGLEVEL=(1,1),NOTIFY=TECH251\"\nJCL.3 = \"//SCRATCH  EXEC CTTMUP\"\nJCL.4 = \"//SYSIN    DD *\"\nJCL.5 = \"  TYPERUN  MODE=NORMAL,RULEINFO=NO,CHECK=NO\"\nEND.1 = \"/*\"\nEND.2= \"//DELETMEM  EXEC PGM=IDCAMS\"\nEND.3 = \"//UTILPDS  DD DSN=\"OUTPDS\",DISP=SHR\"\nEND.4 = \"//SYSPRINT DD SYSOUT=*\"\nEND.5 = \"//SYSIN    DD *\"\nEND.6 = \"  DELETE  \"OUTPDS\"(\"MEMBER\")  FILE(UTILPDS)\"\nEND.7 = \"/*\"\nEND.8 = \"//\"\nIF TAPEKEY = 'PTAP' THEN SIGNAL MAIN_ROUTINE_TAPE\n/*\n           M A I N   R O U T I N E   S E C T I O N           */\n/*     */\nMAIN_ROUTINE_DASD:\nCALL LISTCAT_DASD_GDG\nCALL DELETE_DASD_GDG\nEXIT 0\n/*     */\nMAIN_ROUTINE_TAPE:\nCALL LISTCAT_TAPE_GDG\nCALL WRITE_CONTROLT_JCL\nCALL SUBMIT_CONTROLT_JOB\nEXIT 0\n/*\n           S U B R O U T I N E   S E C T I O N           */\n/*     */\nLISTCAT_DASD_GDG:\nD = 0\nX = OUTTRAP(\"LSTCAT.\",\"*\",\"CONCAT\")\n\"LISTCAT LEVEL('\"GDGLVL\"') NAMES\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '***********************************************************************'\n   SAY '*** LISTCAT ERROR: NO GDG DATASETS FOUND FOR: ('GDGLVL'). ***'\n   SAY '*** DELETEGDG EXEC TASK CANCELLED. ***'\n   SAY '***********************************************************************'\n   EXIT SRC\nEND\nDO L = 1 TO LSTCAT.0\n   DSNKEY = POS(\"NONVSAM ------- \",LSTCAT.L)\n   IF DSNKEY \u00ac= 0 THEN DO\n      D = D + 1\n      GDG.D = WORD(LSTCAT.L,3)\n   END\nEND\nGDGCNT = D\nRETURN\n/*     */\nDELETE_DASD_GDG:\nDO I = 1 TO GDGCNT\n   \"ALLOC DA('\"GDG.I\"') FILE(GDGDD) SHR\"\n   \"DELETE   ('\"GDG.I\"')   SCRATCH PURGE FILE(GDGDD)\"\n   \"FREE FILE(GDGDD)\"\nEND\nRETURN\n/*     */\nLISTCAT_TAPE_GDG:\nT = 0\nGDGSW = 'NO'\nX = OUTTRAP(\"LSTCAT.\",\"*\",\"CONCAT\")\n\"LISTCAT LVL('\"GDGLVL\"') VOL\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '***********************************************************************'\n   SAY '*** LISTCAT ERROR: NO GDG DATASETS FOUND FOR: ('GDGLVL'). ***'\n   SAY '*** DELETEGDG EXEC TASK CANCELLED. ***'\n   SAY '***********************************************************************'\n   EXIT SRC\nEND\nDO L = 1 TO LSTCAT.0\n   DSNKEY = POS(\"NONVSAM ------- \",LSTCAT.L)\n   IF DSNKEY \u00ac= 0 THEN GDGSW = 'YES'\n   IF GDGSW = 'YES' THEN DO\n      VOLKEY = POS(\"VOLSER------------\",LSTCAT.L)\n      IF VOLKEY \u00ac= 0 THEN DO\n         STA = VOLKEY + 18\n         T = T + 1\n         TAPE.T = SUBSTR(LSTCAT.L,STA,6)\n         GDGSW = 'NO'\n      END\n   END\nEND\nTAPECNT = T\nRETURN\n/*     */\nWRITE_CONTROLT_JCL:\n\"DELSTACK\"\n\"ALLOC DA('\"OUTPDS\"(\"MEMBER\")') FILE(CTTDD) SHR\"\nDO J = 1 TO JCLCNT\n   QUEUE JCL.J\nEND\nDO I = 1 TO TAPECNT\n   CTTRCD = \"  GRPSCR VOLSER=\"TAPE.I\n   QUEUE CTTRCD\nEND\nDO E = 1 TO ENDCNT\n   QUEUE END.E\nEND\nNUMRCDS = QUEUED()\n\"EXECIO\" NUMRCDS \"DISKW CTTDD (FINIS\"\nSRC = RC\n\"FREE FILE(CTTDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '******************************************************************'\n   SAY '*** EXECIO WRITE ERROR: RETURN CODE: ('SRC'). ***'\n   SAY '*** ERROR WRITING ('OUTPDS'('MEMBER') CTT SYSIN RECORDS. ***'\n   SAY '*** CTT TAPE GDG VOLSER SCRATCH FACILITY CANCELLED. ***'\n   SAY '******************************************************************'\n   EXIT SRC\nEND\nRETURN\n/*     */\nSUBMIT_CONTROLT_JOB:\nADDRESS TSO\n\"SUBMIT '\"OUTPDS\"(\"MEMBER\")'\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '***********************************************************************'\n   SAY '*** SUBMIT ERROR: ('OUTPDS'('MEMBER') - RETURN CODE: ('SRC'). ***'\n   SAY '*** CTT TAPE GDG VOLSER SCRATCH FACILITY CANCELLED. ***'\n   SAY '***********************************************************************'\n   EXIT SRC\nEND\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DELNVR": {"ttr": 11796, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x92\\x15\\x7f\\x00\\x92\\x15\\x7f\\x12\\x15\\x00\\t\\x00\\t\\x00\\x05\\xe3\\xc5\\xc3\\xc8\\xf1\\xf1\\xf0@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1992-06-05T00:00:00", "modifydate": "1992-06-05T12:15:00", "lines": 9, "newlines": 9, "modlines": 5, "user": "TECH110"}, "text": "/* REXX */\nADDRESS \"ISPEXEC\" \"VGET (ZDLDSN ZDLVOL ZDLDEV) SHARED\";\nADDRESS \"TSO\";\n\"ALLOC F(\"ZDLVOL\") DA('\"ZDLDSN\"') OLD UNIT(\"ZDLDEV\") \"|| ,\n     \"VOL(\"ZDLVOL\")\";\n\"DELETE '\"ZDLDSN\"' NVR FILE(\"ZDLVOL\")\";\nSAVERC = RC;\n\"FREE F(\"ZDLVOL\")\";\nEXIT SAVERC;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DELVVR": {"ttr": 11798, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x92\\x15\\x7f\\x00\\x92\\x15\\x7f\\x12\\x19\\x00\\t\\x00\\t\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf1\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1992-06-05T00:00:00", "modifydate": "1992-06-05T12:19:00", "lines": 9, "newlines": 9, "modlines": 0, "user": "TECH110"}, "text": "/* REXX */\nADDRESS \"ISPEXEC\" \"VGET (ZDLDSN ZDLVOL ZDLDEV) SHARED\";\nADDRESS \"TSO\";\n\"ALLOC F(\"ZDLVOL\") DA('\"ZDLDSN\"') OLD UNIT(\"ZDLDEV\") \"|| ,\n     \"VOL(\"ZDLVOL\")\";\n\"DELETE '\"ZDLDSN\"' VVR FILE(\"ZDLVOL\")\";\nSAVERC = RC;\n\"FREE F(\"ZDLVOL\")\";\nEXIT SAVERC;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "DISPATCH": {"ttr": 11800, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x91)\\x0f\\x00\\x91)\\x0f\\tY\\x00\\x15\\x00\\x15\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf6@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-10-17T00:00:00", "modifydate": "1991-10-17T09:59:00", "lines": 21, "newlines": 21, "modlines": 0, "user": "TECH106"}, "text": "CONTROL MAIN NOMSG\nERROR DO\n      IF &LASTCC LT 0  THEN +\n          DO\n          WRITE\n          WRITE + END OF CAI/UCF/TSO SESSION FOR USER &SYSUID.\n          WRITE + CA-DISPATCH ONLINE NOT ACTIVE OR IS BEING QUIESCED.\n          WRITE\n          FREE  F(CAICTL)\n          EXIT QUIT\n          END\n      RETURN\n      END\nFREE  F(CAICTL)\nALLOC F(CAICTL) DA('SYS1.DISPATCH.V5R0M0.SYSCTL') SHR\nCALL 'SYS1.DISPATCH.V5R0M0.CAILIB(CAITSODC)'\nFREE  F(CAICTL)\nWRITE\nWRITE + END OF CAI/UCF/TSO SESSION FOR USER &SYSUID.\nWRITE\nEXIT QUIT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DISPOLVO": {"ttr": 11802, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x93\\x11\\x7f\\x00\\x93\\x11\\x7f\\x168\\x00\\x15\\x00\\x15\\x00\\x01\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf6@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1993-04-27T00:00:00", "modifydate": "1993-04-27T16:38:00", "lines": 21, "newlines": 21, "modlines": 1, "user": "TECH106"}, "text": "CONTROL MAIN NOMSG\nERROR DO\n      IF &LASTCC LT 0  THEN +\n          DO\n          WRITE\n          WRITE + END OF CAI/UCF/TSO SESSION FOR USER &SYSUID.\n          WRITE + CA-DISPATCH ONLINE NOT ACTIVE OR IS BEING QUIESCED.\n          WRITE\n          FREE  F(CAICTL)\n          EXIT QUIT\n          END\n      RETURN\n      END\nFREE  F(CAICTL)\nALLOC F(CAICTL) DA('SYS1.DISPATCH.V5R0M0.OLVO2.SYSCTL') SHR\nCALL 'SYS1.DISPATCH.V5R0M0.CAILIB(CAITSODC)'\nFREE  F(CAICTL)\nWRITE\nWRITE + END OF CAI/UCF/TSO SESSION FOR USER &SYSUID.\nWRITE\nEXIT QUIT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DMAN": {"ttr": 12033, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x10_\\x00\\x94\\x10_\\x04\\x10\\x00\\t\\x00\\t\\x00\\x00\\xc9\\xd6\\xc1\\xf4\\xf1\\xf0@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-04-15T00:00:00", "modifydate": "1994-04-15T04:10:00", "lines": 9, "newlines": 9, "modlines": 0, "user": "IOA410"}, "text": "PROC 0  APPLTYPE(S)  -\n        APPLID(CD)\n/****************************************************************\n/*                                                              *\n/*  CONTROL-D:   REPORT DISTRIBUTION SYSTEM          ( TSO)     *\n/*                                                              *\n/****************************************************************\n%IOAONL APPLTYPE(&APPLTYPE) APPLID(&APPLID)\nEND:END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DOMCLIST": {"ttr": 12035, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x95\\x15/\\x00\\x95\\x15/\\x15E\\x00\\x1d\\x00\\x1d\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf5@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1995-06-01T00:00:00", "modifydate": "1995-06-01T15:45:00", "lines": 29, "newlines": 29, "modlines": 0, "user": "TECH105"}, "text": " PROC 0\n IF &SYSISPF = ACTIVE THEN SET &SPF=YES\n                       ELSE SET &SPF=NO\n    ALLOC F(DOMPLIB)  DA('SYSS.BMC.MONITOR.V2R1M3.PLIB')      SHR REU\n    ALLOC F(DOMTLIB)  DA('SYSS.BMC.MONITOR.V2R1M3.TLIB')      SHR REU\n    ALLOC F(DOMLOAD)  DA('SYS1.BMC.MONITOR.V2R1M3.LOAD')      SHR REU\n /*\n   IF &SPF = NO THEN DO\n     CALL 'SYS1.BMC.MONITOR.V2R1M3.LOAD(DOMDMAIN)'\n     GOTO EXIT\n     END\n /*\n    ELSE DO\n     ISPEXEC LIBDEF ISPPLIB LIBRARY ID(DOMPLIB)\n     ISPEXEC LIBDEF ISPTLIB LIBRARY ID(DOMTLIB)\n     ISPEXEC LIBDEF ISPLLIB LIBRARY ID(DOMLOAD)\n /*\n     ISPEXEC SELECT CMD(DOMDMAIN) MODE(FSCR) NEWAPPL(DOM2) PASSLIB\n /*\n     ISPEXEC LIBDEF ISPLLIB\n     ISPEXEC LIBDEF ISPPLIB\n     ISPEXEC LIBDEF ISPTLIB\n     GOTO EXIT\n     END\n /*\n EXIT: +\n   CONTROL NOFLUSH\n   FREE F(DOMLOAD DOMPLIB DOMTLIB)\n   EXIT  CODE(0)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "DRERPROF": {"ttr": 12037, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x14\\x00\\x00\\x00\\x910\\x9f\\x00\\x911/\\x14B\\x018\\x018\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf8@@@'", "ispf": {"version": "01.20", "flags": 0, "createdate": "1991-11-05T00:00:00", "modifydate": "1991-11-08T14:42:00", "lines": 312, "newlines": 312, "modlines": 0, "user": "TECH108"}, "text": "/* REXX **********************************************************/\n/*                                                               */\n/*     PROGRAM NAME: DRERPROF                                    */\n/*                                                               */\n/* DESCRIPTIVE NAME: SLR Dialog profile                          */\n/*                                                               */\n/* Read this before you start editing this profile:              */\n/*                                                               */\n/* - This is a REXX program and REXX syntax rules must be        */\n/*   followed.                                                   */\n/* - The format of each profile variable is:                     */\n/*   variable = value                                            */\n/*   -  Variable is a symbolic name for an option or data set.   */\n/*   -  Value is the value to assign to the profile variable. It */\n/*      can be one or more words, with or without quotes.        */\n/*   -  A value can be continued to the next line by using a     */\n/*      comma as the last character. Example:                    */\n/*      SLRSAMP = 'SLR.LOCAL.SLRSAMP' , /* Customized tables   */*/\n/*                'SLR.V3R3M0.SLRSAMP'  /* SLR delivered tables*/*/\n/* - Variables starting with SLRU are output data sets and       */\n/*   can only contain one data set name. The other variables     */\n/*   beginning with SLR can have up to three data sets specified.*/\n/*   Exception to this rule is the SLRFORM data set which is an  */\n/*   output data set for GDDM ICU formats.                       */\n/* - All data sets, except data base names, must exist before    */\n/*   the SLR dialog is started.                                  */\n/* - The data set names must be fully qualified.                 */\n/* - When you allocate the user data sets, model them after      */\n/*   the corresponding SLR data set.                             */\n/*                                                               */\n/* - Normally, you create one profile for the SLR specialist,    */\n/*   who will perform customization, and one for all other       */\n/*   users. Each user must use their own SLRUTLIB, it cannot     */\n/*   be shared but it can be the same data set as used for the   */\n/*   ISPTABL for example.                                        */\n/*   The SLR specialist should use a SLR specific SLRUTLIB data  */\n/*   set. This data set should be the first data set name set    */\n/*   to variable SLRTLIB. In this way, the end users will only   */\n/*   see the customized SLR ISPF tables and not the shipped ones.*/\n/*                                                        PL79091*/\n/* - Before you start the SLR dialog, you must ensure that the   */\n/*   SLR LINKLIB is in the system link list or allocated to      */\n/*   STEPLIB. The SLR SLREXEC data set must be allcoated to      */\n/*   SYSEXEC or SYSPROC. The SLR SLRCLIST data set must be       */\n/*   allocated to SYSPROC.                                PL79091*/\n/*                                                               */\n/* CHANGE ACTIVITY:                                              */\n/*    Created 90-07-26 for SLR V3R3M0 by UB                      */\n/*    Change 01 91-03-01 Wrong data set for variable ADMCFORM.   */\n/*                       ADMCFORM should be SLRFORM target lib.  */\n/*                       Some documentation added.               */\n/*                       APAR PL79091.                           */\n/*    Change 02 91-05-23 Save of GDDM variable was omitted.      */\n/*                       APAR PL85043.                           */\n/*                                                               */\n/*****************************************************************/\nSignal on syntax                    /* Trap REXX syntax errors   */\nParse Source . . module .           /* Module name               */\n\n/*AAA*************************************************************/\n/* Set data set prefix                                           */\n/* usrpre is the prefix for data sets allocated per user.        */\n/* syspre is the prefix for data sets allocated per SLR system.  */\n/*        Normally the same as usrpre when customizing.          */\n/* slrpre is the prefix for the SLR target data sets.            */\n/*****************************************************************/\nusrpre = 'TECH108.SLR.V3R3M0' /*                                 */\nsyspre = 'TECH108.SLR.V3R3M0' /*USER DATA SET PREFIX (TSO PREFIX)*/\nslrpre = 'SYS1.SLR.V3R3M0'   /* SLR data set prefix              */\n\n/*****************************************************************/\n/* Set global options                                            */\n/*****************************************************************/\ndebug = 0                  /* 0 - No debug, 1 - Enable Debug     */\nlogo  = 0                  /* 0 - No SLR logo, 1 - Show SLR logo */\ngddm  = 0                  /* 0 - No GDDM used, 1 - GDDM used    */\n\n/*****************************************************************/\n/* Set language                                                  */\n/*****************************************************************/\nAddress \"ISPEXEC\"  \"VGET ZLANG\"     /* Get ISPF language         */\nIf Translate(zlang) = 'JAPANESE' Then\n  language = 'JAPANESE'             /* Japanese                  */\nElse\n  language = 'ENGLISH'              /* English (also default)    */\n\n/*****************************************************************/\n/* Output ISPF table data set. SLR will concatenate this         */\n/* data set before the SLRTABL data set when reading.            */\n/* Must be one per SLR user.                                     */\n/*****************************************************************/\nslrutlib = 'tech108.user.cntllib1'  /* SLR ISPF tables           */\n\n/*****************************************************************/\n/* Data sets containing local modifications to SLR. They will    */\n/* be concatenated ahead of the corresponding SLR data sets.     */\n/*****************************************************************/\nslruslib = syspre'.SLRCNTL'         /* SLR ISPF skeletons        */\nslrusamp = 'tech108.slr.v3r3m0.slrsamp'/*                        */\nslruasm  = syspre'.SLRASM'          /* User table source         */\nslrumacs = syspre'.SLRMACS'         /* User macros               */\nslruclist= syspre'.SLRCLIST'        /* User clists               */\nslrucntl = syspre'.SLRCNTL'         /* User JCL                  */\nslrform  = 'tech108.slr.v3r3m0.slrform'  /*<<<<<<<<<<<<<<<<<<<   */\n\n/*****************************************************************/\n/* SLR data bases. You can add your own data bases by adding     */\n/* a new unique data base symbolic name to the SLRDBS list and   */\n/* by assigning the new variable a name.                         */\n/* Note: do may not use MAINFILE as a data base name.            */\n/*****************************************************************/\nslrdbs   = 'REPORTDB SYSTEMDB WORKFILE',  /* List of data bases  */\n           'DEMODB ACCTDB FCASTDB PERFMDB NRDB'\nreportdb = slrpre'.REPORTDB.cluster' /*SLR report data base      */\nsystemdb = slrpre'.SYSTEMDB.cluster' /*SLR system data base      */\nworkfile = slrpre'.WORKFILE.cluster' /*SLR Work data base        */\nacctdb   = slrpre'.ACCTDB.cluster'  /* SLR accounting data base  */\nfcastdb  = slrpre'.FCASTDB.cluster' /* SLR forecasting data base */\nperfmdb  = slrpre'.PERFMDB.cluster' /* SLR performance data base */\ndemodb   = slrpre'.DEMODB.cluster'  /* SLR demo data base        */\nnrdb     = slrpre'.NRDB.cluster'    /* SLR Network Report db     */\n\n/*****************************************************************/\n/* SLR GDDM data sets                                            */\n/*****************************************************************/\nadmgdf   = syspre'.ADMGDF'           /* SLR GDDM ADMGDF          */\nadmcdata = syspre'.ADMCDATA'         /* SLR GDDM ADMCDATA        */\nadmcform = 'sysm.slr.v3r3m0.slrform' /* <<<<<<<<<<<<<<<<  PL79091*/\nadmdefs  = slrpre'.SLRCNTL(DREJGDPR)'  /* GDDM nicknames  PL79091*/\nadmsymbl = 'SYS1.GDDMSYM'            /* GDDM symbols      PL79091*/\n\n/*****************************************************************/\n/* SLR sort data sets                                            */\n/*****************************************************************/\nsortlib  = 'SYS1.syncsort.v3r4me.linklib'   /* <<<<<<<<<<<<<<<<  */\nsortwsz  = 30                       /* Number of workfile cyls   */\nsortwu   = 'SYSDA'                  /* Workfile unit             */\nsysout   = 'DUMMY'                  /* SORT message output       */\n\n/*****************************************************************/\n/* JCL jobcards                                                  */\n/*****************************************************************/\njobcard1 = \"//\"Userid()\"S JOB (123456,NOBO),'SLR JCL',            \"\njobcard2 = \"//  NOTIFY=\"Userid()\",MSGCLASS=Q,CLASS=A,REGION=6500K \"\njobcard3 = \"//*\"\njobcard4 = \"//*\"\njobcard5 = \"//*\"\n\n/*****************************************************************/\n/* SLR ISPF data sets. Since each user must have their own       */\n/* ISPF table data set for SLR outputs, the customized SLR ISPF  */\n/* table data set should be concatenated to the SLRTLIB to make  */\n/* it available to all SLR users.                                */\n/* Up to three data sets can be concatenated.                    */\n/*****************************************************************/\nslrplib = slrpre'.SLRPANEL'         /* SLR ISPF panels           */\nslrmlib = slrpre'.SLRMLIB'          /* SLR ISPF messages         */\nslrslib = slrpre'.SLRSLIB'          /* SLR ISPF skeletons        */\nslrtlib = 'tech108.user.cntllib1',  /* Customized SLR ISPF tables*/\n          slrpre'.SLRTABL'          /* SLR ISPF tables           */\n\n/*****************************************************************/\n/* SLR data sets. Up to three data sets may be concatenated.     */\n/*                                                        PL79091*/\n/*****************************************************************/\nslrload = 'sys1.linklib'            /* SLR load modules          */\nslrsamp = 'sysm.slr.v3r3m0.slrsamp' /* SLR table & exits (load)  */\nslrmacs = slrpre'.SLRMACS'          /* SLR table macros          */\nslrasm  = slrpre'.SLRASM'           /* SLR table & exits (source)*/\nslrexec = slrpre'.SLREXEC'          /* SLR rexx programs         */\nslrcntl = slrpre'.SLRCNTL'          /* SLR cntl programs         */\nslrclist= slrpre'.SLRCLIST'         /* SLR clist programs        */\nslrdbt  = slrpre'.SLRDBT'           /* SLR data base table ref.  */\nslrdump = 'DUMMY'                   /* SLR dump file. Can be:    */\n                                    /* DUMMY  -  No output       */\n                                    /* *   - Output to terminal  */\n\n/*****************************************************************/\n/*                                                               */\n/*             END OF CUSTOMIZATION FOR SLR                      */\n/*                                                               */\n/*   The rest of the code should not be modified.                */\n/*BBB ************************************************************/\n\n/*****************************************************************/\n/* LIBDEF to table data set                                      */\n/*****************************************************************/\nAddress \"ISPEXEC\" \"CONTROL ERRORS RETURN\"\nCall libdef 'ISPTLIB' slrutlib slrtlib  /* Keylists, cmd tables  */\nCall libdef 'SLRTLIB' slrutlib slrtlib  /* SLR input ISPF tables */\nCall libdef 'SLRTABL' slrutlib          /* SLR output tables     */\n\n/*****************************************************************/\n/* Open Profile ISPF table. If it doesn't exist, create it.      */\n/* The DRETPROF table has one key (PROFVAR) and one data         */\n/* column (PROFVAL).                                             */\n/*****************************************************************/\nAddress \"ISPEXEC\"\n\"TBOPEN  DRETPROF SHARE WRITE LIBRARY(SLRTLIB)\"\n\n/*****************************************************************/\n/* Check return code from TBOPEN                                 */\n/*****************************************************************/\nSelect\n  /***************************************************************/\n  /* Table opened, no action                                     */\n  /***************************************************************/\n  When rc = 0 Then\n    Nop\n\n  /***************************************************************/\n  /* Table does not exist. Create it                             */\n  /***************************************************************/\n  When rc = 8 Then\n    Do\n      \"TBCREATE DRETPROF KEYS(PROFVAR) NAMES(PROFVAL)\",\n      \"  LIBRARY(SLRTABL) SHARE REPLACE\"\n      If debug > 0 Then\n        Call drertrc module' TBCREATE DRETPROF rc = 'rc\n      If rc > 8 Then\n        Do\n          Say 'Cannot create SLR table DRETPROD on data set' slrutlib\n          Say 'Program terminates.'\n          Say zerrlm\n          Exit rc\n        End\n    End\n\n  /***************************************************************/\n  /* Other errors. Issue message                                 */\n  /***************************************************************/\n  When rc > 8 Then\n    Do\n      Say 'Cannot open SLR table DRETPROD on data set' slrutlib slrtlib\n      Say 'Program terminates with rc = 'rc\n      Say zerrlm\n      Exit rc\n    End\n  Otherwise\n    Nop\nEnd\n\n/*****************************************************************/\n/* For all supported SLR variables, update DRETPROF table        */\n/*****************************************************************/\nvl = ,                                  /* GDDM added     PL85043*/\n  'SLRSAMP  SLRUSAMP SLRMACS   SLRUMACS SLRASM   SLRUASM ',\n  'SLRFORM  ADMCFORM ADMCDATA  ADMGDF   ADMDEFS  ADMSYMBL',\n  'SLREXEC  SLRCNTL  SLRUCNTL  SLRMLIB  SLRPLIB  SLRSLIB ',\n  'SLRTLIB  SLRUTLIB SLRMKLB   SLRPKLB  SLRTKLB  SLRSKLB ',\n  'JOBCARD1 JOBCARD2 JOBCARD3  JOBCARD4 JOBCARD5         ',\n  'SORTLIB  SYSOUT   SORTWSZ   SORTWU   GDDM             ',\n  'DEBUG    LANGUAGE SLRDUMP   LOGO     SLRUSLIB         ',\n  'SLRDBT   SLRCLIST SLRUCLIST SLRLOAD  SLRDBS 'slrdbs\n\nDo i = 1 To Words(vl)\n  profvar = Word(vl,i)\n  profval = Translate(Value(profvar))\n  \"TBMOD DRETPROF\"\nEnd\n\n/*****************************************************************/\n/* Save profile                                                  */\n/*****************************************************************/\n\"TBSAVE  DRETPROF LIBRARY(SLRTABL)\"\n\nExit 0\n\n/*****************************************************************/\n/* Handle LIBDEF calls                                           */\n/*                                                               */\n/* Called as:  LIBDEF  dd_name  dsn_names                        */\n/*   dd_name   -  Any name allowed by LIBDEF                     */\n/*   dsn_names -  Any data set names allowed by LIBDEF DATASET   */\n/*                                                               */\n/* If any return code from LIBDEF, issue message and terminate   */\n/*****************************************************************/\nLibdef:\n  Arg dd_name dsn_names\n  ds_names = ''\n  Do i = 1 To Words(dsn_names)\n    ds_names = ds_names \"'\"Word(dsn_names,i)\"'\"\n  End\n\n  Address \"ISPEXEC\" \"LIBDEF \"dd_name\" DATASET ID(\"ds_names\") UNCOND\"\n  If rc > 4 Then\n    Do\n      Say 'ISPF LIBDEF error in SLR DRERPROF exec when trying to'\n      Say 'libdef 'dd_name' to 'ds_names'. LIBDEF return code 'rc\n      Say 'and message 'zerrlm\n      Exit rc\n    End\n\nReturn\n\n/*****************************************************************/\n/* Syntax error discovered                                       */\n/*****************************************************************/\nSyntax:\n  Call drertrc module' Syntax error in 'module' line 'sigl\n  Call drertrc module' Error text: 'Errortext(rc)\n  Call drertrc module' Error line: 'Space(Sourceline(sigl))\n  Say 'Syntax error trapped in: 'module\n  Say 'REXX return code 'rc ' in line 'sigl': 'errortext(rc)\n  Say 'Lines before error line are:'\n  Do i = Max(sigl - 5,1) To sigl\n    Say Right(i,5,'0')': 'Space(Sourceline(i))\n  End\n  Say 'Report problem to your SLR specialist'\n  Exit 20\n\nReturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "EDITPDS": {"ttr": 12043, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01#\\x00\\x00\\x00\\x92(\\x1f\\x00\\x92(\\x7f\\x15\\x07\\x00_\\x00\\x15\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf3@@@'", "ispf": {"version": "01.35", "flags": 0, "createdate": "1992-10-07T00:00:00", "modifydate": "1992-10-13T15:07:00", "lines": 95, "newlines": 21, "modlines": 0, "user": "TECH103"}, "text": "/*  REXX EXEC :   ( EDITPDS )\n    FUNCTION  : THIS REXX UTILITY WILL GENERATE A LIST OF ALL MEMBERS\n                CONTAINED IN A PARTITIONED DATA SET.\n                THE MEMBER LIST IS USED AS INPUT TO ISPF MACRO TO\n                PERFORM THE EDIT CHANGES OF ALL ITERATIONS OF THE\n                SPECIFIED CHARACTER STRING.\n                THE INITIAL MACRO ( @EDITMEM ) IS INVOKED TO PERFORM\n                THE EDIT CHANGES.\n                                                                     */\nTRACE O\n/*     */\nDISPLAY_PANEL:\nADDRESS ISPEXEC\nTSOUSER = USERID()\nPDS = TSOUSER\".USER.CNTLLIB\"\nDO FOREVER\n   \"DISPLAY PANEL(EDITPDSP)\"\n   SRC = RC\n   IF SRC = 0 THEN LEAVE\n   IF SRC = 8 THEN DO\n      SAY '*** EDITPDS EXEC UTILITY TERMINATED DUE TO USER REQUEST. ***'\n      EXIT\n   END\n   IF SRC > 8 THEN DO\n      SAY '*** ERROR INVOKING ISPF DIALOG PANEL EDITPDSP - RC = 'SRC'.***'\n      EXIT SRC\n   END\nEND\n/*     */\nHOUSE_KEEPING:\nMCNT = 0\nXSTRING = 'ISF ISP ISR'\nUPPER PDS\nDSN = SYSDSN(\"'\"PDS\"'\")\nIF DSN = 'DATASET NOT FOUND' THEN DO\n   SAY '*** DATASET ERROR: DATASET NOT FOUND FOR ('PDS'). ***'\n   SAY '*** EDITPDS EXEC MAINTASK CANCELLED. ***'\n   EXIT\nEND\n\"VPUT OLDSTR SHARED\"\n\"VPUT NEWSTR SHARED\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** VPUT ERROR: ISPF DIALOG VPUT ERROR FOR CHANGE STRING STOW. ***'\n   SAY '*** EDITPDS EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nADDRESS TSO\nX = OUTTRAP(\"PDSMEMB.\",\"*\",\"CONCAT\")\n\"LISTDS ('\"PDS\"') MEMBERS\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** LISTDS ERROR: ERROR LISTING PDS MEMBERS FROM 'PDS'. ***'\n   SAY '*** EDITPDS EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\n/*     */\nEDIT_MEMBERS:\nADDRESS ISPEXEC\nDO I = 7 TO PDSMEMB.0\n   MEMBER = STRIP(PDSMEMB.I)\n   CALL CHECK_MEMBER_EXCLUDE\n   IF EXCLSW = 'YES' THEN ITERATE\n   MCNT = MCNT + 1\n   SAY '+++ NOW EDITTING PDS MEMBER: 'MEMBER' +++'\n   SAY 'EDIT DATASET('PDS'('MEMBER')) MACRO(@EDITPDS)'\n   \"EDIT DATASET('\"PDS\"(\"MEMBER\")') MACRO(@EDITPDS)\"\n   SRC = RC\n   IF SRC = 12 THEN EXIT\n   SAY '+++ EDIT OF PDS MEMBER: 'MEMBER'  RC = 'SRC' +++'\nEND\nSAY '+++ EDIT OF 'PDS' MEMBERS COMPLETE - ('MCNT') MEMBERS EDITTED. +++'\nEXIT\n/*     */\nCHECK_MEMBER_EXCLUDE:\nEXCLSW = 'NO'\nMLEN = LENGTH(MEMBER)\nSCOL = MLEN - 3\nXPROF = SUBSTR(MEMBER,SCOL,4)\nIF XPROF = 'PROF' THEN DO\n   EXCLSW = 'YES'\n   RETURN\nEND\nXISPF = SUBSTR(MEMBER,1,3)\nXCLUDE = POS(XISPF,XSTRING)\nIF XCLUDE \u00ac= 0 THEN DO\n   EXCLSW = 'YES'\n   RETURN\nEND\nXLIBR = SUBSTR(MEMBER,1,4)\nIF XLIBR = 'LIB@' THEN DO\n   EXCLSW = 'YES'\n   RETURN\nEND\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ELIPS$CR": {"ttr": 12046, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x92\\x08_\\x00\\x92\\x08_\\x11\"\\x00\\x0f\\x00\\x0f\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1992-03-25T00:00:00", "modifydate": "1992-03-25T11:22:00", "lines": 15, "newlines": 15, "modlines": 0, "user": "TECH103"}, "text": "/*    REXX EXEC :\n   CA-LIBRARIAN 3.9 LIB/ELIPS CR ( COMMAND ROUTE )          */\n\nTRACE O\n/*     */\nHOUSE_KEEPING:\nADDRESS ISPEXEC\n\"CONTROL ERRORS RETURN\"\n\"VGET (ELI$DMF ELI$XNOD)\"\n\"VGET (ELICBCMD ELICBMOD)\"\nIF ELI$XNOD \u00ac= 'CR' THEN EXIT 0\nIF ELICBCMD \u00ac= 'Z' THEN EXIT 0\nSAY '*** THE EMRGPROC AND TESTPROC PDS DATASETS ARE NO LONGER REQUIRED. ***'\nSAY '+++ THE EMRGPROC AND TESTPROC LIBRARIAN DATASETS ARE NOW USED BY JES2. +++'\nEXIT 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ELIPS$FE": {"ttr": 12048, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x08\\x00\\x00\\x00\\x94\\x16_\\x00\\x94$?\\x15I\\x01\\x9e\\x01\\x9d\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf3@@@'", "ispf": {"version": "01.08", "flags": 0, "createdate": "1994-06-14T00:00:00", "modifydate": "1994-08-31T15:49:00", "lines": 414, "newlines": 413, "modlines": 0, "user": "TECH103"}, "text": "/*    REXX EXEC :\n   CA-LIBRARIAN 3.9 LIB/ELIPS FE ( FUNCTION ENTRANCE )          */\n\nTRACE O\n/*     */\nHOUSE_KEEPING:\nADDRESS ISPEXEC\n\"CONTROL ERRORS RETURN\"\n\"VGET (ELI$DMF ELI$DMOD ELI$XNOD ELI$XFUN ELI$DPGR ELI$DLAN)\"\nIF ELI$XNOD \u00ac= 'FE' THEN EXIT 0\nMASTER = ELI$DMF\nMODULE = ELI$DMOD\nFUNCTION = SUBSTR(ELI$XFUN,1,1)\nPROGRAMMER = ELI$DPGR\nLANGUAGE = ELI$DLAN\nLIBNODE = 'COPY JCL PROC RAMI SRCE SYSI'\nDO I = 1 TO 6\n   NODE = WORD(LIBNODE,I)\n   X = POS(NODE,ELI$DMF)\n   IF X \u00ac= 0 THEN LEAVE\nEND\nFROMMST = ELI$DMF\nTOMST = 'SYS1.ARCH'NODE'.MASTER'\nTSOID = SYSVAR(SYSUID)\nJULDATE = DATE(J)\nPDSMEMB = \"J\"||JULDATE\nCDATE = DATE(U)\nCTIME = TIME()\nNOMEMB = 'MEMBER NOT FOUND'\nTSOPRFX = SUBSTR(TSOID,1,6)\nERC = 0\nECNT = 2              /* EMRG LIB COUNT */\nLCNT = 4              /* QA AND PROD LIB COUNT */\nPCNT = 2              /* PROD COUNT */\nLIBPRFX = 'TURN QA PROD EMRG'\nHISTNODE = 'HISTCOPY HISTJCL HISTPROC HISTRAMI HISTSRCE HISTSYSI'\nRECORD = ELI$DMF MODULE PROGRAMMER \"DELETE BY:\" TSOID CDATE CTIME\nPARMLIB = 'SYSS.TECH.COMMON.PARMLIB'\nCALL GET_PARMS\nCALL CHECK_HISTORY_MASTER_ACCESS\nIF HSTSW = 'YES' THEN CALL CHECK_HISTORY_AUTHORIZATION\nDCLFUNC = 'A C D E EO EM EC ER ES I R UC UM'\nDCLCNT = 13           /* DB2 DCL LANGCODE FUNCTION ENTRY COUNT */\nLCNT = 4              /* QA AND PROD LIB COUNT */\nIF ELI$DLAN = 'DCL' THEN CALL CHECK_DB2ADMIN\nIF FUNCTION = 'D' THEN SIGNAL CHECK_DELETE\nIF FUNCTION = 'E' THEN SIGNAL CHECK_EDIT\nEXIT ERC\n/*     M A I N   R O U T I N E   S E C T I O N     */\n/*     */\nCHECK_DELETE:\nADDRESS TSO\nIF MASTER = 'SYS1.SYSTEM.CONTROL.MASTER' THEN EXIT 0\nCALL CHECK_BYPASS_OWNER\nIF DB2AUTH = 'YES' THEN AUTHSW = 'YES'\nIF AUTHSW = 'YES' THEN DO\n   CALL CHECK_PROD_DELETE\n   IF PRODSW = 'YES' THEN DO\n      IF AUTHSW = 'NO' THEN DO\n         CALL PROD_DELETE_ERROR\n         EXIT ERC\n      END\n      CALL ARCHIVE_MEMBER\n      IF ERC \u00ac= 0 THEN DO\n         CALL ARCHIVE_ERROR\n         EXIT ERC\n      END\n   END\n   CALL ALLOC_JOURNAL\n   INTERPRET CALL LABEL\n   CALL DELETE_LOADMOD\n   IF LMODSW = 'YES' THEN DO\n      IF LANGUAGE = 'DYL' | LANGUAGE = 'DY2' THEN CALL DELETE_DYLAKOR_LOADMOD\n   END\n   QASW = 'NO'\n   QALIB = POS('QA',MASTER)\n   IF QALIB \u00ac= 0 THEN DO I = 1 TO QACNTL.0\n      IF QACNTL.I = TSOID THEN QASW = 'YES'\n   END\n   IF QASW = 'YES' THEN DO\n      ADDRESS TSO\n/*    \"SEND '\"MASTER\"(\"MODULE\") DELETED BY: ' USER(TECH207) LOGON\"  */\n   END\n   EXIT ERC\nEND\nCALL CHECK_MODULE_OWNER\nIF OWNSW = 'YES' THEN DO\n   CALL ALLOC_JOURNAL\n   INTERPRET CALL LABEL\n   CALL DELETE_LOADMOD\n   IF LMODSW = 'YES' THEN DO\n      IF LANGUAGE = 'DYL' | LANGUAGE = 'DY2' THEN CALL DELETE_DYLAKOR_LOADMOD\n   END\n   EXIT ERC\nEND\nCALL DELETE_ERROR\nEXIT ERC\n/*     */\nCHECK_EDIT:\nADDRESS TSO\nERC = 0\nAUTHSW = 'NO'\nMSW = 'NO'\nDO L = 1 TO LCNT\n   NOEDIT = SUBWORD(LIBPRFX,L,1)\n   MATCH = POS(NOEDIT,MASTER)\n   IF MATCH \u00ac= 0 THEN MSW = 'YES'\nEND\nIF MSW = 'NO' THEN EXIT ERC\nDO I = 1 TO ADMIN.0\n   IF ADMIN.I = TSOID THEN AUTHSW = 'YES'\nEND\nIF AUTHSW = 'YES' THEN EXIT ERC\n/*     */\nCHECK_QALIB:\nAUTHSW = 'NO'\nQALIB = POS('QA',MASTER)\nIF QALIB \u00ac= 0 THEN DO I = 1 TO QACNTL.0\n   IF QACNTL.I = TSOID THEN AUTHSW = 'YES'\nEND\nIF AUTHSW = 'YES' THEN DO\n   ADDRESS TSO\n/* \"SEND '\"MASTER\"(\"MODULE\") EDITTED BY: ' USER(TECH207) LOGON\" */\n   EXIT ERC\nEND\n/*     */\nCHECK_EMERGENCY:\nAUTHSW = 'NO'\nEMRGLIB = POS('EMRG',MASTER)\nIF EMRGLIB \u00ac= 0 THEN DO\n   IF TSOPRFX = 'TECH29' THEN EXIT ERC\n   DO I = 1 TO AUTHUSR.0\n      IF AUTHUSR.I = TSOID THEN AUTHSW = 'YES'\n   END\n   IF AUTHSW = 'YES' THEN EXIT ERC\nEND\n/*     */\nAUTHORIZATION_ERROR:\nADDRESS ISPEXEC\n\"CONTROL ERRORS RETURN\"\nERC = 4\nELIXMYN = 'Y'\nELILMSG = '$ELIE005'\n\"SETMSG MSG($ELIE005)\"\n\"VPUT (\"ELIXMYN\") SHARED\"\nEXIT ERC\n/*     S U B R O U T I N E S   S E C T I O N     */\n/*     */\nCHECK_HISTORY_MASTER_ACCESS:\nHSTSW = 'NO'\nDO I = 1 TO 6\n   HSTLIB = WORD(HISTNODE,I)\n   HST = POS(HSTLIB,MASTER)\n   IF HST \u00ac= 0 THEN HSTSW = 'YES'\nEND\nRETURN\n/*     */\nCHECK_HISTORY_AUTHORIZATION:\nHSTAUTH = 'NO'\nDO I = 1 TO ADMIN.0\n   IF ADMIN.I = TSOID THEN HSTAUTH = 'YES'\nEND\nIF HSTAUTH = 'YES' THEN RETURN\nIF USRSW = 'YES' THEN RETURN\nIF FUNCTION = 'B' | FUNCTION = 'L' THEN RETURN\nERC = 4\nELIXMYN = 'Y'\nELILMSG = '$ELIE009'\nADDRESS ISPEXEC\n\"SETMSG MSG($ELIE009)\"\n\"VPUT (\"ELIXMYN\") SHARED\"\nEXIT ERC\n/*     */\nCHECK_DB2ADMIN:\nDB2AUTH = 'NO'\nDB2SW = 'NO'\nDO I = 1 TO DCLCNT\n   DB2FUNC = WORD(DCLFUNC,I)\n   IF DB2FUNC = ELI$XFUN THEN DB2SW = 'YES'\nEND\nIF DB2SW = 'NO' THEN RETURN\nDO I = 1 TO DB2ADMN.0\n   IF DB2ADMN.I = TSOID THEN DB2AUTH = 'YES'\nEND\nIF DB2AUTH = 'YES' THEN DO\n   AUTHSW = 'YES'\n   RETURN\nEND\nERC = 4\nELIXMYN = 'Y'\nELILMSG = 'LIBI083M'\nADDRESS ISPEXEC\n\"SETMSG MSG(LIBI083M)\"\n\"VPUT (\"ELIXMYN\") SHARED\"\nEXIT ERC\n/*     */\nCHECK_BYPASS_OWNER:\nAUTHSW = 'NO'\nDO I = 1 TO AUTHUSR.0\n   IF AUTHUSR.I = TSOID THEN AUTHSW = 'YES'\nEND\nRETURN\n/*     */\nCHECK_MODULE_OWNER:\nOWNSW = 'NO'\nIF PROGRAMMER = TSOID THEN OWNSW = 'YES'\nRETURN\n/*     */\nALLOC_JOURNAL:\nLABEL = 'NOOP_JOURNAL'\nDSN = SYSDSN(\"'\"JDSN\"(\"PDSMEMB\")'\")\nIF DSN = 'OK' THEN DO\n   \"ALLOC DA('\"JDSN\"(\"PDSMEMB\")') F(ISPFILE) SHR\"\n   \"DELSTACK\"\n   \"EXECIO * DISKR ISPFILE (FINIS\"\n   RCDCNT = QUEUED()\n   LABEL = 'REWRITE_JOURNAL'\nEND\nIF DSN = NOMEMB THEN DO\n   \"ALLOC DA('\"JDSN\"(\"PDSMEMB\")') F(ISPFILE) SHR\"\n   LABEL = 'WRITE_JOURNAL'\nEND\nRETURN\n/*     */\nWRITE_JOURNAL:\n\"DELSTACK\"\nQUEUE RECORD\n\"EXECIO 1 DISKW ISPFILE (FINIS\"\nSRC = RC\n\"FREE F(ISPFILE)\"\nIF SRC = 0 THEN RETURN\nCALL NOOP_JOURNAL\nRETURN\n/*     */\nREWRITE_JOURNAL:\nRCDCNT = RCDCNT + 1\nQUEUE RECORD\n\"EXECIO\" RCDCNT \"DISKW ISPFILE (FINIS\"\nSRC = RC\n\"FREE F(ISPFILE)\"\nIF SRC = 0 THEN RETURN\nCALL NOOP_JOURNAL\nRETURN\n/*     */\nMISSING_MODNAME:\nERC = 4\nELIXMYN = 'Y'\nELILMSG = 'LIBI083L'\nADDRESS ISPEXEC\n\"SETMSG MSG(LIBI083L)\"\n\"VPUT (\"ELIXMYN\") SHARED\"\nRETURN\n/*     */\nNOOP_JOURNAL:\nERC = 4\nELIXMYN = 'Y'\nELILMSG = '$ELIE003'\nADDRESS ISPEXEC\n\"SETMSG MSG($ELIE003)\"\n\"VPUT (\"ELIXMYN\") SHARED\"\nRETURN\n/*     */\nDELETE_ERROR:\nERC = 4\nELIXMYN = 'Y'\nELILMSG = '$ELIE004'\nADDRESS ISPEXEC\n\"SETMSG MSG($ELIE004)\"\n\"VPUT (\"ELIXMYN\") SHARED\"\nRETURN\n/*     */\nCHECK_PROD_DELETE:\nPRODSW = 'NO'\nPRODLIB = POS('PROD',MASTER)\nIF PRODLIB \u00ac= 0 THEN PRODSW = 'YES'\nIF PRODSW = 'NO' THEN RETURN\nAUTHSW = 'NO'\nDO I = 1 TO ADMIN.0\n   IF ADMIN.I = TSOID THEN AUTHSW = 'YES'\nEND\nRETURN\n/*     */\nPROD_DELETE_ERROR:\nERC = 4\nELIXMYN = 'Y'\nELILMSG = '$ELIE006'\nADDRESS ISPEXEC\n\"SETMSG MSG($ELIE006)\"\n\"VPUT (\"ELIXMYN\") SHARED\"\nRETURN\n/*     */\nARCHIVE_MEMBER:\nERC = 0\nPMAST = POS('PROD',ELI$DMF)\nIF PMAST = 0 THEN RETURN\nADDRESS ISPEXEC\n\"CONTROL ERRORS RETURN\"\n\"SELECT PGM(UTIMAIN) NEWAPPL(LIB@) NEWPOOL PARM(FDSN('\"FROMMST\"(\"MODULE\")')\n TDSN('\"TOMST\"(\"MODULE\")') CMD(C,OPT(REP)) RETURN\"\nERC = RC\nRETURN\n/*     */\nARCHIVE_ERROR:\nERC = 4\nELIXMYN = 'Y'\nELILMSG = '$ELIE008'\nADDRESS ISPEXEC\n\"SETMSG MSG($ELIE008)\"\n\"VPUT (\"ELIXMYN\") SHARED\"\nRETURN\n/*     */\nDELETE_LOADMOD:\nERC = 0\nLMODSW = 'NO'\nSRCELIB = POS('SRCE',MASTER)\nIF SRCELIB = 0 THEN RETURN\nSRCENODE = 'TEST RJCT EMRG PROD'\nLOADNODE = 'TEST REJECT EMERGNCY PROD'\nLTYPES = 'BATCH CICS'\nLLIBDD = 'BATCHDD CICSDD'\nC = 0\nDO 4\n   C = C + 1\n   SNODE = WORD(SRCENODE,C)\n   SN = POS(SNODE,MASTER)\n   IF SN \u00ac= 0 THEN DO\n      LNODE = WORD(LOADNODE,C)\n      LEAVE\n   END\nEND\nL = 0\nX = MSG(\"OFF\")\nDO 2\n   L = L + 1\n   LTYPE = WORD(LTYPES,L)\n   LOADLIB = 'SYS1.'LNODE'.'LTYPE'.LOADLIB'\n   DSNDD = WORD(LLIBDD,L)\n   LMOD = SYSDSN(\"'\"LOADLIB\"(\"MODULE\")'\")\n   IF LMOD = 'OK' THEN DO\n      ADDRESS TSO\n      LMODSW = 'YES'\n      \"ALLOC DA('\"LOADLIB\"')  FILE(\"DSNDD\") SHR\"\n      \"DELETE '\"LOADLIB\"(\"MODULE\")' FILE(\"DSNDD\")\"\n      \"FREE FILE(\"DSNDD\")\"\n   END\nEND\nX = MSG(\"ON\")\nADDRESS ISPEXEC\nRETURN\n/*     */\nDELETE_DYLAKOR_LOADMOD:\nADDRESS TSO\nMLEN = LENGTH(MODULE)\nPREFIX = SUBSTR(MODULE,1,MLEN)\nIF MLEN >= 6 THEN PREFIX = SUBSTR(MODULE,1,6)\nLIBDSN = \"'\"MASTER\"(\"MODULE\")'\"\nLIBDD = LIBALLOC(LIBDSN)    /* DYNALLOC LIBMASTER W/LAM; RET DDNAME*/\nIF LIBDD = \"ERROR\" THEN RETURN\n\"EXECIO 1 DISKR\" LIBDD \"(FINIS STEM REPORT.\"\nSRC = RC\nIF SRC \u00ac= 0 THEN RETURN\nREPTFLG = POS('* REPORTS = ',REPORT.1)\nIF REPTFLG = 0 THEN RETURN\nNUMREPTS = WORD(REPORT.1,4)\nIF NUMREPTS = '' THEN RETURN\nRTYP = DATATYPE(NUMREPTS)\nIF RTYP \u00ac= 'NUM' THEN RETURN\nX = MSG(\"OFF\")\nLOADLIB = 'SYS1.'LNODE'.BATCH.LOADLIB'\n\"ALLOC DA('\"LOADLIB\"')  FILE(BATCHDD) SHR\"\nDO M = 1 TO NUMREPTS\n   IF M = 1 THEN ITERATE\n   MLEN = LENGTH(M)\n   IF MLEN = 1 THEN DYLMOD = PREFIX||'0'M\n   IF MLEN = 2 THEN DYLMOD = PREFIX||M\n   LMOD = SYSDSN(\"'\"LOADLIB\"(\"DYLMOD\")'\")\n   IF LMOD = 'MEMBER NOT FOUND' THEN LEAVE\n   \"DELETE '\"LOADLIB\"(\"DYLMOD\")' FILE(BATCHDD)\"\nEND\n\"FREE FILE(BATCHDD)\"\nX = MSG(\"ON\")\nADDRESS ISPEXEC\nRETURN\n/*     */\nGET_PARMS:\nADDRESS TSO\nUSRSW = 'NO'\nX = MSG(\"OFF\")\n\"FREE FILE(PARMDD)\"\nFROMDSN = 'SYSS.TESTCCF.HISTORY.CNTLLIB'\nJDSN = 'SYSS.TESTCCF.JOURNAL.CNTLLIB'\n\"FREE FILE(PARMDD)\"\n\"ALLOC DA('\"PARMLIB\"(ELIPSADM)') F(PARMDD) SHR\"\n\"EXECIO * DISKR PARMDD (FINIS STEM ADMIN.\"\n\"FREE FILE(PARMDD)\"\n\"ALLOC DA('\"PARMLIB\"(ELIPSAUS)') F(PARMDD) SHR\"\n\"EXECIO * DISKR PARMDD (FINIS STEM AUTHUSR.\"\n\"FREE FILE(PARMDD)\"\n\"ALLOC DA('\"PARMLIB\"(ELIPDB2A)') F(PARMDD) SHR\"\n\"EXECIO * DISKR PARMDD (FINIS STEM DB2ADMN.\"\n\"FREE FILE(PARMDD)\"\n\"ALLOC DA('\"PARMLIB\"(ELIPSQAP)') F(PARMDD) SHR\"\n\"EXECIO * DISKR PARMDD (FINIS STEM QACNTL.\"\n\"FREE FILE(PARMDD)\"\nAUTHFLAG = SYSDSN(\"'\"FROMDSN\"(\"TSOID\")'\")\nIF AUTHFLAG = 'OK' THEN DO\n   \"ALLOC DA('\"FROMDSN\"(\"TSOID\")') F(PARMDD) SHR\"\n   \"EXECIO 1 DISKR PARMDD (FINIS STEM USRPARM.\"\n   \"FREE FILE(PARMDD)\"\n   EUSER = WORD(USRPARM.1,1)\n   EDATE = WORD(USRPARM.1,2)\n   IF EUSER = TSOID & EDATE = JULDATE THEN USRSW = 'YES'\nEND\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ELIPS$GA": {"ttr": 12295, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x018\\x00\\x00\\x00\\x91 _\\x00\\x935\\x0f\\x109\\x00,\\x00@\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf3@@@'", "ispf": {"version": "01.56", "flags": 0, "createdate": "1991-07-24T00:00:00", "modifydate": "1993-12-16T10:39:00", "lines": 44, "newlines": 64, "modlines": 0, "user": "TECH103"}, "text": "/*    REXX EXEC :\n   CA-LIBRARIAN 3.9 LIB/ELIPS GA ( GENERAL ALLOCATION )          */\n\nTRACE O\n/*     */\nHOUSE_KEEPING:\nADDRESS ISPEXEC\n\"CONTROL ERRORS RETURN\"\nADDRESS ISPEXEC \"VGET (ELI$DMF ELI$DMF2 ELI$XNOD ELI$XFUN)\"\nIF ELI$XNOD \u00ac= 'GA' THEN EXIT 0\nSYSMAST = POS('SYSTEM.CONTROL',ELI$DMF)\nIF SYSMAST = 0 THEN EXIT 0\nTSOID = SYSVAR(SYSUID)\nJULDATE = DATE(J)\nPARMLIB = 'SYSS.TECH.COMMON.PARMLIB'\nCALL GET_PARMS\n/*     M A I N   R O U T I N E   S E C T I O N     */\n/*     */\nCHECK_SYSMAST_DATASET:\nCALL CHECK_ADMIN_AUTHORIZATION\nIF AUTHSW = 'YES' THEN EXIT 0\nERC = 4\nELIXMYN = 'Y'\nELILMSG = '$ELIE002'\nADDRESS ISPEXEC \"SETMSG MSG($ELIE002)\"\nADDRESS ISPEXEC \"VPUT (\"ELIXMYN\") SHARED\"\nEXIT ERC\n/*     S U B R O U T I N E S   S E C T I O N     */\n/*     */\nCHECK_ADMIN_AUTHORIZATION:\nAUTHSW = 'NO'\nDO A = 1 TO ADMIN.0\n   IF ADMIN.A = TSOID THEN AUTHSW = 'YES'\nEND\nRETURN\n/*     */\nGET_PARMS:\nADDRESS TSO\nX = MSG(\"OFF\")\n\"FREE FILE(PARMDD)\"\n\"ALLOC DA('\"PARMLIB\"(ELIPSADM)') F(PARMDD) SHR\"\n\"EXECIO * DISKR PARMDD (FINIS STEM ADMIN.\"\n\"FREE FILE(PARMDD)\"\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "EXECUPDT": {"ttr": 12297, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x91 o\\x00\\x91 \\x7f\\x10I\\x00\\x07\\x00\\x14\\x00\\x06\\xd1\\xc5\\xc6\\xc6\\xd2@@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1991-07-25T00:00:00", "modifydate": "1991-07-26T10:49:00", "lines": 7, "newlines": 20, "modlines": 6, "user": "JEFFK"}, "text": "/* REXX VLFNOTE */\naddress \"TSO\";\nparse upper arg dsname ; /* element name */\nif substr(dsname,1,1) = \"'\" then , /* remove single quotes */\n    dsname = substr(dsname,2,length(dsname)-2);\n\"VLFNOTE UPDATE DSNAME('\"dsname\"')\";\nexit rc;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FCTMERG": {"ttr": 12299, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x05\\x00\\x00\\x00\\x93\\t\\x0f\\x00\\x936/\\x110\\x00'\\x00\\x11\\x00%\\xe3\\xc5\\xc3\\xc8\\xf1\\xf1\\xf0@@@\"", "ispf": {"version": "01.05", "flags": 0, "createdate": "1993-03-31T00:00:00", "modifydate": "1993-12-28T11:30:00", "lines": 39, "newlines": 17, "modlines": 37, "user": "TECH110"}, "text": "/* REXX PRODXREF FCT MERGE EXEC */\n\"EXECIO * DISKR FCTIN (STEM FCTIN. FINIS\";\nDO K = 1 TO FCTIN.0;\n     TEMP = SUBSTR(FCTIN.K,1,72);\n     CONT=SUBSTR(TEMP,72,1);\n     IF WORDPOS(\"DFHFCT\",TEMP)\u00ac=0 THEN DO;\n          CURRFCT=TEMP;\n          DO WHILE (CONT\u00ac=\" \");\n              K=K+1; /* INDEX */\n              TEMP = SUBSTR(FCTIN.K,1,72);\n              CONT=SUBSTR(TEMP,72,1);\n              CURRFCT=CURRFCT TEMP;\n          END;\n     CURRFCT=TRANSLATE(CURRFCT,\"   \",\",()\");\n     PARSE VAR CURRFCT . \"DATASET=\" MEMBER . ;\n     PARSE VAR CURRFCT . \"DSNAME=\" DSN . ;\n     ACCESS=\"INPUT\";\n     IF WORDPOS(\"UPDATE\",CURRFCT)\u00ac=0 | ,\n        WORDPOS(\"DELETE\",CURRFCT)\u00ac=0 | ,\n        WORDPOS(\"ADD\",CURRFCT)\u00ac=0 THEN ACCESS=\"OUTPUT\";\n     DSN=LEFT(DSN,44);\n     MEMBER=LEFT(MEMBER,8);\n     JOBNAME=\"CICSPROD\";\n     ACCESS=LEFT(ACCESS,6);\n     FCTOUT.1=COPIES(\" \",116);\n     FCTOUT.1 = ,\n         OVERLAY(DSN,FCTOUT.1,56,44);\n     FCTOUT.1 = ,\n         OVERLAY(MEMBER,FCTOUT.1,100,8);\n     FCTOUT.1 = ,\n         OVERLAY(JOBNAME,FCTOUT.1,1,8);\n     FCTOUT.1 = ,\n         OVERLAY(ACCESS,FCTOUT.1,111,6);\n     IF DSN=\" \" | MEMBER=\" \" THEN ITERATE K;\n     \"EXECIO 1 DISKW FCTOUT (STEM FCTOUT.\";\nEND;\nEND;\n\"EXECIO 0 DISKW FCTOUT (FINIS\";\nEXIT 0;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FDMERG": {"ttr": 12301, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0b\\x00\\x00\\x00\\x923/\\x00\\x936/\\x112\\x00 \\x00\\x05\\x00\\x1e\\xe3\\xc5\\xc3\\xc8\\xf1\\xf1\\xf0@@@'", "ispf": {"version": "01.11", "flags": 0, "createdate": "1992-11-27T00:00:00", "modifydate": "1993-12-28T11:32:00", "lines": 32, "newlines": 5, "modlines": 30, "user": "TECH110"}, "text": "/* REXX PRODXREF FD MERGE EXEC */\n\"EXECIO * DISKR FDSCAN   (STEM FDSCAN. FINIS\";\nDO K = 1 TO FDSCAN.0;\n     PARSE VAR FDSCAN.K FDPGM FDDDNAME FDACCESS;\n     DROP FDSCAN.K;\n     FDPGM=STRIP(FDPGM);\n     FDDDNAME=STRIP(FDDDNAME);\n     FDSC.FDPGM.FDDDNAME=STRIP(FDACCESS);\nEND;\nDROP FDSCAN.0;\n\"EXECIO * DISKR XREFIN (STEM XREFIN. FINIS\";\nXOUT = 1;\nDO I = 1 TO XREFIN.0;\n  PARSE VAR XREFIN.I JOBNAME 9 JOBCLASS 10 EPROCSN 18 PROCNAME ,\n      26 EPGMSN 34 EXECPGM 42 STEPPROC 45 STEPJOB ,\n      48 DDNAME 56 DSNAME 100 MEMBER 108 DISP 111 ACCESS;\n  IF ACCESS \u00ac= \" \" | DSNAME=\" \" THEN DO;\n       XREFOUT.XOUT = XREFIN.I; /* DUP RECORD UNCHANGED */\n       XOUT = XOUT + 1;\n       ITERATE I;\n       END;\n  EXECPGM=STRIP(EXECPGM);\n  DDNAME=STRIP(DDNAME);\n        IF SYMBOL('FDSC.EXECPGM.DDNAME')=\"VAR\" THEN DO;\n                 XREFIN.I = ,\n                 OVERLAY(FDSC.EXECPGM.DDNAME,XREFIN.I,111,6);\n                 END;\n  XREFOUT.XOUT = XREFIN.I; /* DUP RECORD CHANGED */\n  XOUT = XOUT + 1;\nEND;\n\"EXECIO * DISKW XREFOUT (STEM XREFOUT. FINIS\";\nEXIT 0;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FINDEXEC": {"ttr": 12303, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x91\\x16O\\x00\\x91\\x16O\\x15B\\x00\\x14\\x00\\x10\\x00\\x04\\xd1\\xc5\\xc6\\xc6\\xd2@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1991-06-13T00:00:00", "modifydate": "1991-06-13T15:42:00", "lines": 20, "newlines": 16, "modlines": 4, "user": "JEFFK"}, "text": "/* REXX BLDL locate element */\naddress \"TSO\";\nparse upper arg bldlmem ; /* element name */\nif bldlmem = \"\" then do;\n      say \"Missing member name.\";\n      exit 4;\n      end;\nbldldir = xlibemem(\"SYSPROC\",bldlmem); /* fetch dir entry */\nif bldldir = \"\"  then do;\n      say \"Locate for member\" bldlmem \"failed.\";\n      exit 4;\n      end;\nconcat# = x2d(substr(c2x(bldldir),23,2))+1; /* bldl K = concat # */\ndsnlist = @listalc(\"SYSPROC\"); /* allocated dsn list per ddname */\nif dsnlist = \"\" then do;\n      say \"Locate for member\" bldlmem \"failed.\";\n      exit 8;\n      end;\nsay \"Exec\" bldlmem \"located in dataset\" word(dsnlist,concat#);\nexit 0;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FINDLLIB": {"ttr": 12305, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x91\\x16O\\x00\\x91\\x16O\\x16W\\x00\\x14\\x00\\x14\\x00\\x00\\xd1\\xc5\\xc6\\xc6\\xd2@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-06-13T00:00:00", "modifydate": "1991-06-13T16:57:00", "lines": 20, "newlines": 20, "modlines": 0, "user": "JEFFK"}, "text": "/* REXX BLDL locate element */\naddress \"TSO\";\nparse upper arg bldlmem ; /* element name */\nif bldlmem = \"\" then do;\n      say \"Missing member name.\";\n      exit 4;\n      end;\nbldldir = xlibemem(\"ISPLLIB\",bldlmem); /* fetch dir entry */\nif bldldir = \"\"  then do;\n      say \"Locate for member\" bldlmem \"failed.\";\n      exit 4;\n      end;\nconcat# = x2d(substr(c2x(bldldir),23,2))+1; /* bldl K = concat # */\ndsnlist = @listalc(\"ISPLLIB\"); /* allocated dsn list per ddname */\nif dsnlist = \"\" then do;\n      say \"Locate for member\" bldlmem \"failed.\";\n      exit 8;\n      end;\nsay \"Loadmod\" bldlmem \"located in dataset\" word(dsnlist,concat#);\nexit 0;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FINDLOAD": {"ttr": 12307, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00\\x00\\x00\\x91\\x16_\\x00\\x91\\x16_\\x15\\x18\\x001\\x00$\\x00\\x19\\xd1\\xc5\\xc6\\xc6\\xd2@@@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "1991-06-14T00:00:00", "modifydate": "1991-06-14T15:18:00", "lines": 49, "newlines": 36, "modlines": 25, "user": "JEFFK"}, "text": "/* REXX BLDL locate element */\naddress \"TSO\";\nparse upper arg bldlmem ; /* element name */\nif bldlmem = \"\" then do;\n      say \"Missing member name.\";\n      exit 4;\n      end;\nbldldir = xlibload(bldlmem); /* fetch dir entry */\nif bldldir = \"\"  then do;\n      say \"Locate for member\" bldlmem \"failed.\";\n      exit 4;\n      end;\nconcat# = c2d(substr(bldldir,12,1))+1; /* bldl K = concat # */\nsysloc# = c2d(substr(bldldir,13,1)); /* bldl z = locate # */\nselect;\n   when sysloc# = 0 then do;\n      say \"Load module\" bldlmem \"located in private library.\";\n      exit 0;\n      end;\n   when sysloc# = 1 then do;\n      cvtptr = storage(\"00000010\",4); /* locate llt from cvt */\n      cvtllta = d2x(c2d(cvtptr)+1244); /* mapping ihallt */\n      llta = c2d(storage(cvtllta,4));\n      lltacount = c2d(storage(d2x(llta+4),4));\n      lltaentry = d2x(llta+9); /* entry ptr */\n      dsnlist = \"\";\n      do i = 1 to lltacount;\n           dsnlist = dsnlist strip(storage(lltaentry,44));\n           lltaentry = d2x(x2d(lltaentry)+45);\n      end;\n      say \"Load module\" bldlmem \"located in LINKLIST library\" ,\n             word(dsnlist,concat#);\n      exit 0;\n      end;\n   when sysloc# = 2 then do;\n/*    dsnlist = @listalc(\"STEPLIB\"); allocdsn list per ddname\n      if dsnlist = \"\" then do;\n         say \"Locate for member\" bldlmem \"failed.\";\n         exit 8;\n         end; */\n      say \"Load module\" bldlmem \"located in STEPLIB library.\";\n      exit 0;\n      end;\n   otherwise do;\n      say \"Load module\" bldlmem \"located in parent task library.\";\n      exit 0;\n      end;\nend;\nexit 0;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FINDMLIB": {"ttr": 12546, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x91\\x16O\\x00\\x91\\x16O\\x15C\\x00\\x14\\x00\\x10\\x00\\x04\\xd1\\xc5\\xc6\\xc6\\xd2@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1991-06-13T00:00:00", "modifydate": "1991-06-13T15:43:00", "lines": 20, "newlines": 16, "modlines": 4, "user": "JEFFK"}, "text": "/* REXX BLDL locate element */\naddress \"TSO\";\nparse upper arg bldlmem ; /* element name */\nif bldlmem = \"\" then do;\n      say \"Missing member name.\";\n      exit 4;\n      end;\nbldldir = xlibemem(\"ISPMLIB\",bldlmem); /* fetch dir entry */\nif bldldir = \"\"  then do;\n      say \"Locate for member\" bldlmem \"failed.\";\n      exit 4;\n      end;\nconcat# = x2d(substr(c2x(bldldir),23,2))+1; /* bldl K = concat # */\ndsnlist = @listalc(\"ISPMLIB\"); /* allocated dsn list per ddname */\nif dsnlist = \"\" then do;\n      say \"Locate for member\" bldlmem \"failed.\";\n      exit 8;\n      end;\nsay \"Message\" bldlmem \"located in dataset\" word(dsnlist,concat#);\nexit 0;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FINDPLIB": {"ttr": 12548, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x91\\x16O\\x00\\x91\\x16O\\x15D\\x00\\x14\\x00\\t\\x00\\x0c\\xd1\\xc5\\xc6\\xc6\\xd2@@@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1991-06-13T00:00:00", "modifydate": "1991-06-13T15:44:00", "lines": 20, "newlines": 9, "modlines": 12, "user": "JEFFK"}, "text": "/* REXX BLDL locate element */\naddress \"TSO\";\nparse upper arg bldlmem ; /* element name */\nif bldlmem = \"\" then do;\n      say \"Missing member name.\";\n      exit 4;\n      end;\nbldldir = xlibemem(\"ISPPLIB\",bldlmem); /* fetch dir entry */\nif bldldir = \"\"  then do;\n      say \"Locate for member\" bldlmem \"failed.\";\n      exit 4;\n      end;\nconcat# = x2d(substr(c2x(bldldir),23,2))+1; /* bldl K = concat # */\ndsnlist = @listalc(\"ISPPLIB\"); /* allocated dsn list per ddname */\nif dsnlist = \"\" then do;\n      say \"Locate for member\" bldlmem \"failed.\";\n      exit 8;\n      end;\nsay \"Panel\" bldlmem \"located in dataset\" word(dsnlist,concat#);\nexit 0;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FINDSLIB": {"ttr": 12550, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x91\\x16O\\x00\\x91\\x16O\\x15E\\x00\\x14\\x00\\x10\\x00\\x04\\xd1\\xc5\\xc6\\xc6\\xd2@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1991-06-13T00:00:00", "modifydate": "1991-06-13T15:45:00", "lines": 20, "newlines": 16, "modlines": 4, "user": "JEFFK"}, "text": "/* REXX BLDL locate element */\naddress \"TSO\";\nparse upper arg bldlmem ; /* element name */\nif bldlmem = \"\" then do;\n      say \"Missing member name.\";\n      exit 4;\n      end;\nbldldir = xlibemem(\"ISPSLIB\",bldlmem); /* fetch dir entry */\nif bldldir = \"\"  then do;\n      say \"Locate for member\" bldlmem \"failed.\";\n      exit 4;\n      end;\nconcat# = x2d(substr(c2x(bldldir),23,2))+1; /* bldl K = concat # */\ndsnlist = @listalc(\"ISPSLIB\"); /* allocated dsn list per ddname */\nif dsnlist = \"\" then do;\n      say \"Locate for member\" bldlmem \"failed.\";\n      exit 8;\n      end;\nsay \"Skeleton\" bldlmem \"located in dataset\" word(dsnlist,concat#);\nexit 0;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FINDTLIB": {"ttr": 12552, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x91\\x16O\\x00\\x91\\x16O\\x15E\\x00\\x14\\x00\\x10\\x00\\x04\\xd1\\xc5\\xc6\\xc6\\xd2@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1991-06-13T00:00:00", "modifydate": "1991-06-13T15:45:00", "lines": 20, "newlines": 16, "modlines": 4, "user": "JEFFK"}, "text": "/* REXX BLDL locate element */\naddress \"TSO\";\nparse upper arg bldlmem ; /* element name */\nif bldlmem = \"\" then do;\n      say \"Missing member name.\";\n      exit 4;\n      end;\nbldldir = xlibemem(\"ISPTLIB\",bldlmem); /* fetch dir entry */\nif bldldir = \"\"  then do;\n      say \"Locate for member\" bldlmem \"failed.\";\n      exit 4;\n      end;\nconcat# = x2d(substr(c2x(bldldir),23,2))+1; /* bldl K = concat # */\ndsnlist = @listalc(\"ISPTLIB\"); /* allocated dsn list per ddname */\nif dsnlist = \"\" then do;\n      say \"Locate for member\" bldlmem \"failed.\";\n      exit 8;\n      end;\nsay \"Table\" bldlmem \"located in dataset\" word(dsnlist,concat#);\nexit 0;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FL": {"ttr": 12554, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x010\\x00\\x00\\x00\\x91\\x17\\x7f\\x00\\x91\\x17\\x9f\\x10%\\x00\\xf8\\x00\\x04\\x00\\x00\\xd1\\xc5\\xc6\\xc6\\xd2@@@@@'", "ispf": {"version": "01.48", "flags": 0, "createdate": "1991-06-26T00:00:00", "modifydate": "1991-06-28T10:25:00", "lines": 248, "newlines": 4, "modlines": 0, "user": "JEFFK"}, "text": "/* REXX FileList */\ntrue = \"1\"; false = \"0\";  /* switches */\nrefresh_flag = false; /* no refresh */\nsname_flag = false; /* dont sort by name */\nsttr_flag = false; /* dont sort by ttr */\nsdate_flag = false; /* dont sort by date */\nssize_flag = false; /* dont sort by size */\nscommand = \"S\"; /* current meaning of the select command */\nparse upper arg filter;\naddress \"ISPEXEC\"; /* ISPF/PDF services */\nif filter \u00ac= \"\" & , /* filter is dsname */\n   (pos(\".\",filter)\u00ac=0 | substr(filter,1,1)=\"'\") then do;\n        parse var filter dsname \"(\" filter \")\"; /* components */\n        if substr(dsname,1,1)=\"'\" then ,\n            parse var dsname \"'\" dsname \"'\"; /* strip quotes */\n        end;\n  else dsname = userid()\".USER.CNTLLIB\"; /* personal PDS */\nif filter\u00ac=\"\" & pos(\"*\",filter)=0 then , /* 1 member only */\n    member_count = 1;\n  else member_count = 0; /* code for more than 1 member */\n/* Sysrecfm set */\ndummy = listdsi(\"'\"dsname\"'\"); /* recfm ? */\nif dummy \u00ac= 0 then do;\n       zedsmsg = \"Invalid dsname\";\n       zedlmsg = \"Invalid dsname or dataset not currently available.\";\n       signal error_exit;\n       end;\nif sysrecfm \u00ac= \"U\" then sdate_flag = true;\n    else ssize_flag = true;\nrefresh:\n\"LMINIT DATAID(FLISTID) DATASET('\"dsname\"') ENQ(SHRW)\";\nif rc \u00ac= 0 then do;\n       zedsmsg = \"Invalid dsname\";\n       zedlmsg = \"Invalid dsname or dataset not currently available.\";\n       signal error_exit;\n       end;\n\"LMOPEN DATAID(\"flistid\")\";\nif rc \u00ac= 0 then do;\n      \"LMFREE DATAID(\"flistid\")\";\n       zedsmsg = \"Open failure\";\n       zedlmsg = \"LMOPEN failure; dataset cannot be opened.\";\n       signal error_exit;\n       end;\nif ssize_flag then ,\n    zcmd = \"SORT SIZE NAME\"; /* sort by size */\nif sttr_flag then ,\n    zcmd = \"SORT TTR\"; /* sort by ttr */\nif sdate_flag then ,\n    zcmd = \"SORT CHA NAME\"; /* sort by time stamp */\nif sname_flag then ,\n    zcmd = \"SORT NAME\"; /* sort by name */\n\"CONTROL NONDISPL ENTER\"; /* non display mode first panel */\nif rc \u00ac= 0 then do;\n      \"LMCLOSE DATAID(\"flistid\")\";\n      \"LMFREE DATAID(\"flistid\")\";\n      \"LMFREE DATAID(\"flistid\")\";\n       zedsmsg = \"Control failure\";\n       zedlmsg = \"Control failure; filelist aborted.\";\n       signal error_exit;\n       end;\nif filter = \"\" then do;\n      \"LMMDISP DATAID(\"flistid\") COMMANDS(ANY)\";\n      if rc > 8 then do;\n          \"LMCLOSE DATAID(\"flistid\")\";\n          \"LMFREE DATAID(\"flistid\")\";\n          zedsmsg = \"Memlist failure\";\n          zedlmsg = \"LMMDISP failure; filelist aborted.\";\n          signal error_exit;\n          end;\n      else if rc = 8 then signal finis;\n      else if rc = 4 then do;\n             zedsmsg = \"No members found\";\n             zedlmsg = \"No members meet the selection criteria.\";\n             signal error_exit;\n             end;\n      end;\nelse do;\n      \"LMMDISP DATAID(\"flistid\") MEMBER(\"filter\") COMMANDS(ANY)\";\n      if rc > 8 then do;\n          \"LMCLOSE DATAID(\"flistid\")\";\n          \"LMFREE DATAID(\"flistid\")\";\n          zedsmsg = \"Memlist failure\";\n          zedlmsg = \"LMMDISP failure; filelist aborted.\";\n          signal error_exit;\n          end;\n      else if rc = 8 then signal finis;\n      else if rc = 4 then do;\n             zedsmsg = \"No members found\";\n             zedlmsg = \"No members meet the selection criteria.\";\n             signal error_exit;\n             end;\n      end;\nprocess:\nselected = true;\ndo while(selected);\n  upper zcmd;\n  zcmd = strip(zcmd);\n  zllcmd = strip(zllcmd); /* cleanup */\n  if zllcmd = \"S\" then zllcmd = scommand; /* substitute */\n  zlmember = strip(zlmember);\n  zludata = strip(zludata);\n  if zllcmd = \"=\" then zllcmd = lastcmd; /* repeat last command */\n  select;\n     when ((zllcmd = \"E\" | zllcmd = \"X\") & sysrecfm\u00ac=\"U\") then do;\n        \"EDIT DATAID(\"flistid\") MEMBER(\"zlmember\")\";\n        \"LMMDISP DATAID(\"flistid\") OPTION(PUT) MEMBER(\"zlmember\")\" ,\n            \"ZLUDATA(*Edited)\";\n        lastcmd = \"E\"; /* remember last command */\n        end;\n     when (zllcmd = \"B\" | zllcmd = \"S\") then do;\n        \"BROWSE DATAID(\"flistid\") MEMBER(\"zlmember\")\";\n        \"LMMDISP DATAID(\"flistid\") OPTION(PUT) MEMBER(\"zlmember\")\" ,\n            \"ZLUDATA(*Browsed)\";\n        lastcmd = \"B\"; /* remember last command */\n        end;\n     when (zllcmd = \"D\") then do;\n        dummy = msg(\"OFF\");\n        address \"TSO\" \"DELETE '\"dsname\"(\"zlmember\")'\";\n        dummy = msg(\"ON\");\n        \"LMMDISP DATAID(\"flistid\") OPTION(PUT) MEMBER(\"zlmember\")\" ,\n            \"ZLUDATA(*Deleted)\";\n        lastcmd = \"D\"; /* remember last command */\n        refresh_flag = true; /* refresh screen */\n        end;\n     when (zllcmd = \"R\") then do;\n        dummy = msg(\"OFF\");\n        address \"TSO\" \"RENAME '\"dsname\"(\"zlmember\")'\" ,\n            \"(\"zludata\")\";\n        saverc = rc;\n        dummy = msg(\"ON\");\n        if saverc = 0 then do;\n        \"LMMDISP DATAID(\"flistid\") OPTION(PUT) MEMBER(\"zlmember\")\" ,\n            \"ZLUDATA(*Renamed)\";\n        if member_count = 1 then , /* member count in list */\n             filter = zludata; /* refresh on new member name */\n        refresh_flag = true; /* refresh screen */\n        end;\n        else ,\n        \"LMMDISP DATAID(\"flistid\") OPTION(PUT) MEMBER(\"zlmember\")\" ,\n            \"ZLUDATA(*Name?)\";\n        lastcmd = \"R\"; /* remember last command */\n        end;\n     when (zllcmd = \"\") then nop;\n     otherwise do;\n        \"LMMDISP DATAID(\"flistid\") OPTION(PUT) MEMBER(\"zlmember\")\" ,\n            \"ZLUDATA(*?)\";\n       end;\n  end;\n  \"LMMDISP DATAID(\"flistid\") OPTION(GET)\";\n  disprc = rc;\n  select;\n    when disprc = 0 then nop; /* loop and do next member */\n    when disprc = 8 then selected = false; /* redisplay screen */\n    otherwise do;\n          \"LMCLOSE DATAID(\"flistid\")\";\n          \"LMFREE DATAID(\"flistid\")\";\n          zedsmsg = \"Memlist failure\";\n          zedlmsg = \"LMMDISP failure; filelist aborted.\";\n          signal error_exit;\n          end;\n  end;\nend;\nscommand = \"S\"; /* reset */\nselect; /* zcmd */\n   when (zcmd = \"REFRESH\") then refresh_flag = true; /* refresh */\n   when (zcmd = \"SNAME\") then do;\n           sname_flag = true;\n           sdate_flag = false;\n           ssize_flag = false;\n           sttr_flag = false;\n           refresh_flag = true;\n           end;\n   when (zcmd = \"SDATE\" & sysrecfm\u00ac=\"U\") then do;\n           sdate_flag = true;\n           sname_flag = false;\n           ssize_flag = false;\n           sttr_flag = false;\n           refresh_flag = true;\n           end;\n   when (zcmd = \"SSIZE\") then do;\n           sdate_flag = false;\n           sname_flag = false;\n           ssize_flag = true;\n           sttr_flag = false;\n           refresh_flag = true;\n           end;\n   when (zcmd = \"STTR\" & sysrecfm=\"U\") then do;\n           sdate_flag = false;\n           sname_flag = false;\n           ssize_flag = false;\n           sttr_flag = true;\n           refresh_flag = true;\n           end;\n   when (substr(zcmd,1,2)=\"B \") then do;\n           scommand = \"B\"; /* simulate browse */\n           zcmd = \"S \"substr(zcmd,3); /* simulate entry */\n           \"CONTROL NONDISPL ENTER\"; /* non display mode first panel */\n           \"LMMDISP DATAID(\"flistid\")\"; /* simulate redisplay */\n           signal process;\n           end;\n   when (substr(zcmd,1,2)=\"E \") then do;\n           scommand = \"E\"; /* simulate edit */\n           zcmd = \"S \"substr(zcmd,3); /* simulate entry */\n           \"CONTROL NONDISPL ENTER\"; /* non display mode first panel */\n           \"LMMDISP DATAID(\"flistid\")\"; /* simulate redisplay */\n           signal process;\n           end;\n   when (substr(zcmd,1,2)=\"X \") then do;\n           scommand = \"X\"; /* simulate edit */\n           zcmd = \"S \"substr(zcmd,3); /* simulate entry */\n           \"CONTROL NONDISPL ENTER\"; /* non display mode first panel */\n           \"LMMDISP DATAID(\"flistid\")\"; /* simulate redisplay */\n           signal process;\n           end;\n   when (substr(zcmd,1,2)=\"D \") then do;\n           scommand = \"D\"; /* simulate edit */\n           zcmd = \"S \"substr(zcmd,3); /* simulate entry */\n           \"CONTROL NONDISPL ENTER\"; /* non display mode first panel */\n           \"LMMDISP DATAID(\"flistid\")\"; /* simulate redisplay */\n           signal process;\n           end;\n   otherwise nop;\nend;\nif refresh_flag then do;\n     refresh_flag = false;\n     \"LMMDISP DATAID(\"flistid\") OPTION(FREE)\"; /* clean up */\n     \"LMCLOSE DATAID(\"flistid\")\";\n     \"LMFREE DATAID(\"flistid\")\";\n     signal refresh;\n     end;\n\"LMMDISP DATAID(\"flistid\")\";\n      if rc > 8 then do;\n          \"LMCLOSE DATAID(\"flistid\")\";\n          \"LMFREE DATAID(\"flistid\")\";\n          zedsmsg = \"Memlist failure\";\n          zedlmsg = \"LMMDISP failure; filelist aborted.\";\n          signal error_exit;\n          end;\n      else if rc > 0 then signal finis;\nsignal process;\nerror_exit:\n\"SETMSG MSG(ISRZ001)\"; /* display error message */\nexit 0;\nfinis:\n\"LMMDISP DATAID(\"flistid\") OPTION(FREE)\"; /* clean up */\n\"LMCLOSE DATAID(\"flistid\")\";\n\"LMFREE DATAID(\"flistid\")\";\nexit 0;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FOCCLIST": {"ttr": 12559, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0f\\x00\\x00\\x00\\x94\\x07\\x7f\\x00\\x94%\\x1f\\x12\\x07\\x00\\x10\\x00\"\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf6@@@'", "ispf": {"version": "01.15", "flags": 0, "createdate": "1994-03-18T00:00:00", "modifydate": "1994-09-08T12:07:00", "lines": 16, "newlines": 34, "modlines": 0, "user": "TECH106"}, "text": "PROC 0\nCONTROL MSG PROMPT\nFREE F(MASTER FOCEXEC ERRORS USERLIB FOCSQL)\nALLOC F(MASTER) DA('SYSS.FOCUS.V6R8M0.MASTER.DATA') SHR\nALLOC F(FOCEXEC) DA('SYSS.FOCUS.V6R8M0.FOCEXEC.DATA') SHR\nALLOC F(FMU) DA('SYSS.FOCUS.V6R8M0.FMU.DATA') SHR\nALLOC F(ERRORS) DA('SYSS.FOCUS.V6R8M0.ERRORS.DATA') SHR\nALLOC F(USERLIB) DA('SYSS.FOCUS.V6R8M0.FOCSQL.LOAD' -\n                    'SYS1.FOCUS.V6R8M0.LOAD' -\n                    'SYS1.DB2.V2R3M0.DSNLOAD' -\n                    'SYSS.FOCUS.V6R8M0.FUSELIB.LOAD') SHR\nALLOC F(FOCSQL) DA('SYSS.FOCUS.V6R8M0.FOCSQL.DATA') SHR\nDSN SYSTEM(DSNA)\nRUN PROGRAM(FOCUS) PLAN(DSQLA) LIBRARY('SYS1.FOCUS.V6R8M0.LOAD')\nEND\nEXIT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "FQXRF": {"ttr": 12561, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00\\x00\\x00\\x943\\x7f\\x00\\x944\\x8f\\tI\\x00\\x11\\x00\\x11\\x00\\x11\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf7@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "1994-12-03T00:00:00", "modifydate": "1994-12-14T09:49:00", "lines": 17, "newlines": 17, "modlines": 17, "user": "TECH107"}, "text": "PROC 0\nCONTROL NOMSG NOPROMPT NOLIST\nFREE F(OFFLINE ERRORS MASTER FOCEXEC FMU SYSIN FOCLIB FOCSQL PROFILE)\nALLOC F(FOCLIB)  DA('SYSS.FOCUS.V6R8M0.FOCSQL.LOAD') SHR\nALLOC F(FOCSQL)  DA('SYSS.TECH.COMMON.FOCSQL.DATA' -\n                    'SYSS.FOCUS.V6R8M0.FOCSQL.DATA') SHR\nALLOC F(ERRORS)  DA('SYSS.FOCUS.V6R8M0.ERRORS.DATA') SHR\nALLOC F(MASTER)  DA('SYSS.TECH.COMMON.MASTER.DATA' -\n                    'SYSS.FOCUS.V6R8M0.MASTER.DATA') SHR\nALLOC F(FOCEXEC) DA('SYSS.TECH.COMMON.FOCEXEC.DATA') SHR\nALLOC F(PROFILE) DA('SYSS.TECH.COMMON.QXRF.PROFILE') SHR\nALLOC F(FMU)     DA('SYSS.TECH.COMMON.FMU.DATA') SHR\nALLOC F(OFFLINE) SYSOUT(G) RECFM(F,B,A) LRECL(161) BLKSIZE(1610) -\n      FCB(GT15)\nCALL 'SYS1.FOCUS.V6R8M0.LOAD(FOCUS)'\nFREE F(OFFLINE ERRORS MASTER FOCEXEC FMU SYSIN FOCLIB FOCSQL PROFILE)\nEXIT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "FTLMS": {"ttr": 12563, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x00\\x00\\x00\\x943\\x7f\\x00\\x944\\x8f\\tQ\\x00\\x11\\x00\\x11\\x00\\x11\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf7@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "1994-12-03T00:00:00", "modifydate": "1994-12-14T09:51:00", "lines": 17, "newlines": 17, "modlines": 17, "user": "TECH107"}, "text": "PROC 0\nCONTROL NOMSG NOPROMPT NOLIST\nFREE F(OFFLINE ERRORS MASTER FOCEXEC FMU SYSIN FOCLIB FOCSQL PROFILE)\nALLOC F(FOCLIB)  DA('SYSS.FOCUS.V6R8M0.FOCSQL.LOAD') SHR\nALLOC F(FOCSQL)  DA('SYSS.TECH.COMMON.FOCSQL.DATA' -\n                    'SYSS.FOCUS.V6R8M0.FOCSQL.DATA') SHR\nALLOC F(ERRORS)  DA('SYSS.FOCUS.V6R8M0.ERRORS.DATA') SHR\nALLOC F(MASTER)  DA('SYSS.TECH.COMMON.MASTER.DATA' -\n                    'SYSS.FOCUS.V6R8M0.MASTER.DATA') SHR\nALLOC F(FOCEXEC) DA('SYSS.TECH.COMMON.FOCEXEC.DATA') SHR\nALLOC F(PROFILE) DA('SYSS.TECH.COMMON.TLMS.PROFILE') SHR\nALLOC F(FMU)     DA('SYSS.TECH.COMMON.FMU.DATA') SHR\nALLOC F(OFFLINE) SYSOUT(G) RECFM(F,B,A) LRECL(161) BLKSIZE(1610) -\n      FCB(GT15)\nCALL 'SYS1.FOCUS.V6R8M0.LOAD(FOCUS)'\nFREE F(OFFLINE ERRORS MASTER FOCEXEC FMU SYSIN FOCLIB FOCSQL PROFILE)\nEXIT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "FTTSO": {"ttr": 12565, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x12\\x00\\x00\\x00\\x88\\x11\\x1f\\x00\\x92&_\\x120\\x00\\x04\\x00\\x0f\\x00\\x04\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf6@@@'", "ispf": {"version": "01.18", "flags": 0, "createdate": "1988-04-20T00:00:00", "modifydate": "1992-09-21T12:30:00", "lines": 4, "newlines": 15, "modlines": 4, "user": "TECH106"}, "text": "/* REXX EXEC TO INVOKE FTTSO */\nADDRESS \"TSO\"; /* ENVIRONMENT */\n\"CALL 'SYSS.FTTSO.V2R2M0.LOADLIB(FTTSO)' '/\"SYSVAR(\"SYSPREF\")\"'\";\nEXIT RC;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "FXREF": {"ttr": 12567, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0c\\x00\\x00\\x00\\x943\\x7f\\x00\\x95\\x03\\x7f\\x10\\x11\\x00\\x11\\x00\\x11\\x00\\x07\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf7@@@'", "ispf": {"version": "01.12", "flags": 0, "createdate": "1994-12-03T00:00:00", "modifydate": "1995-02-06T10:11:00", "lines": 17, "newlines": 17, "modlines": 7, "user": "TECH107"}, "text": "PROC 0\nCONTROL NOMSG NOPROMPT NOLIST\nFREE F(OFFLINE ERRORS MASTER FOCEXEC FMU SYSIN FOCLIB FOCSQL PROFILE)\nALLOC F(FOCLIB)  DA('SYSS.FOCUS.V6R8M0.FOCSQL.LOAD') SHR\nALLOC F(FOCSQL)  DA('SYSS.TECH.COMMON.FOCSQL.DATA' -\n                    'SYSS.FOCUS.V6R8M0.FOCSQL.DATA') SHR\nALLOC F(ERRORS)  DA('SYSS.FOCUS.V6R8M0.ERRORS.DATA') SHR\nALLOC F(MASTER)  DA('SYSS.TECH.COMMON.MASTER.DATA' -\n                    'SYSS.FOCUS.V6R8M0.MASTER.DATA') SHR\nALLOC F(FOCEXEC) DA('SYSS.TECH.COMMON.FOCEXEC.DATA') SHR\nALLOC F(PROFILE) DA('SYSS.TECH.COMMON.XREF.PROFILE') SHR\nALLOC F(FMU)     DA('SYSS.TECH.COMMON.FMU.DATA') SHR\nALLOC F(OFFLINE) SYSOUT(G) RECFM(F,B,A) LRECL(161) BLKSIZE(1610) -\n      FCB(GT15)\nCALL 'SYS1.FOCUS.V6R8M0.LOAD(FOCUS)'\nFREE F(OFFLINE ERRORS MASTER FOCEXEC FMU SYSIN FOCLIB FOCSQL PROFILE)\nEXIT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "HOLDLIST": {"ttr": 12569, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x91\\x19\\x8f\\x00\\x91\\x19\\x8f\\t\\x07\\x00\\x0e\\x00\\n\\x00\\x00\\xd1\\xc5\\xc6\\xc6\\xd2@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1991-07-17T00:00:00", "modifydate": "1991-07-17T09:07:00", "lines": 14, "newlines": 10, "modlines": 0, "user": "JEFFK"}, "text": "/* REXX EXEC REF (SYS1.TECH.COMMON.EXECLIB)\n   Hold the ISPF/PDF list dataset\n   Set ISPF/PDF editor CAPS OFF when editing                        */\n/* Address the TSO/E environment                                    */\naddress \"TSO\";\nmsgstat = MSG('off');\n\"EXECUTIL HT\";\n\"FREE ATTR(ATRLIST)\";\n\"FREE DDNAME(ISPLIST)\";\n\"ATTR ATRLIST RECFM(F B A) LRECL(133) BLKSIZE(1330)\";\n\"ALLOC F(ISPLIST) SYSOUT(T) USING(ATRLIST) HOLD\";\n\"EXECUTIL RT\";\nmsgstat = MSG(msgstat);\nexit 0;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "IOA": {"ttr": 12571, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x95\\x16_\\x00\\x95\\x16_\\t6\\x00\\x0f\\x00\\x0f\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf2\\xf1@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1995-06-14T00:00:00", "modifydate": "1995-06-14T09:36:00", "lines": 15, "newlines": 15, "modlines": 0, "user": "TECH121"}, "text": "PROC 0  APPLTYPE(I)  -\n        APPLID(CZ)\n/****************************************************************\n/*                                                              *\n/*  CONTROL-M:   PRODUCTION CONTROL  SYSTEM          (ISPF)     *\n/*  CONTROL-D:   REPORT DISTRIBUTION SYSTEM          (ISPF)     *\n/*  CONTROL-O:   AUTOMATED CONSOLE MANAGEMENT SYSTEM (ISPF)     *\n/*  CONTROL-T:   REMOVABLE MEDIA MANAGEMENT SYSTEM   (ISPF)     *\n/*  CONTROL-B:   ONLINE BALANCING SYSTEM             ( TSO)     *\n/*                                                              *\n/*  COPY OF CTTISPFZ CLIST                        6/14/94 MJS   *\n/*                                                              *\n/****************************************************************\n%IOAONL APPLTYPE(&APPLTYPE) APPLID(&APPLID)\nEND:END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IOACCND": {"ttr": 12573, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x10_\\x00\\x94\\x10_\\x04\\x10\\x00\\x1f\\x00\\x1f\\x00\\x00\\xc9\\xd6\\xc1\\xf4\\xf1\\xf0@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-04-15T00:00:00", "modifydate": "1994-04-15T04:10:00", "lines": 31, "newlines": 31, "modlines": 0, "user": "IOA410"}, "text": "PROC 0 DEBUG                +\n       DATEFMT(USA)   +\n       DBPREFA(SYSS.IOA)   +\n       DBVERA(V410)     +\n       LANG()         +\n       LOADLIB(SYS1.IOA.V410.LOAD)   +\n       DBG(DUMMY)           +\n       NOALC\nCONTROL MAIN NOLIST NOCONLIST NOSYMLIST NOMSG\nALLOC F(PRTDBG) &DBG SYSOUT(A)  HOLD\nIF &DEBUG=DEBUG THEN CONTROL MAIN LIST CONLIST SYMLIST MSG\nREDISP:+\nIF &DATEFMT=JPN  +\n   THEN  ISPEXEC DISPLAY PANEL(CTMPCNDJ)\n   ELSE +\nIF &DATEFMT=USA  +\n   THEN  ISPEXEC DISPLAY PANEL(CTMPCNDA)\n   ELSE  ISPEXEC DISPLAY PANEL(CTMPCNDW)\nIF &RESP = END THEN EXIT\nALLOC DD(DALOG)    DA('&DBPREFA..&DBVERA..LOG') SH\nALLOC DD(DASINC)   DA('&DBPREFA..&DBVERA..SNC') SH\nALLOC DD(DARESF)   DA('&DBPREFA..&DBVERA..RES') SH\nALLOC DD(DAPRINT)  DS(*)\nIF &DATEFMT=JPN  +\n   THEN CALL  '&LOADLIB&LANG(IOACND)' '&CTMFUN COND &CTMCONDN &MM.&DD'\n   ELSE +\nIF &DATEFMT=USA  +\n   THEN CALL  '&LOADLIB&LANG(IOACND)' '&CTMFUN COND &CTMCONDN &MM.&DD'\n   ELSE CALL  '&LOADLIB&LANG(IOACND)' '&CTMFUN COND &CTMCONDN &DD.&MM'\nGOTO  REDISP\nEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IOAMAINT": {"ttr": 12801, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x10_\\x00\\x94\\x10_\\x04\\x10\\x00\\x87\\x00\\x87\\x00\\x00\\xc9\\xd6\\xc1\\xf4\\xf1\\xf0@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-04-15T00:00:00", "modifydate": "1994-04-15T04:10:00", "lines": 135, "newlines": 135, "modlines": 0, "user": "IOA410"}, "text": "PROC 0 DEBUG FUNC(B) SMPE(YES) +\n             STEPLIB(SYS1.IOA.V410.LOAD)     +\n             MAINTLIB(SYSM.IOA.V410.MAINTLIB)\n/*******************************************************************/\n/**             IOA MAINTENANCE CLIST                             **/\n/*******************************************************************/\n\nATTN GOTO FREE\nISPEXEC CONTROL ERRORS RETURN\nIF &DEBUG=DEBUG   THEN  CONTROL LIST MSG CONLIST SYMLIST NOFLUSH\n                  ELSE  CONTROL NOMSG NOFLUSH\nSET &CURSOR = &STR(MEMBER)\nSET &INIT    = &Z\nIF &SMPE = &STR(YES) THEN SET &SUB=&STR(SMP)\nELSE                      SET &SUB=&STR(IOA)\nMAINPNL: +\nSET &ZEDSMSG = &Z\nSET &ZEDLMSG = &Z\nSET &MEMBER  = &Z\nSET &F       = &FUNC\nMAINPANL: +\nSET &AST     = &Z\nSET &ZCMD    = &Z\nISPEXEC SETMSG MSG(ISRZ001)\nISPEXEC DISPLAY PANEL(IOAMNTP1) CURSOR(CURSOR)\nIF &RESP = &STR(END) THEN GOTO FREE\nSET &ZEDSMSG = &Z\nSET &ZEDLMSG = &Z\nISPEXEC CONTROL ERRORS RETURN\nIF &SYSDSN('&MAINTLIB') \u00ac= OK THEN DO\n  SET &ZEDSMSG = &STR(LIBRARY NOT FOUND)\n  SET &ZEDLMSG = +\n      &STR(LIBRARY &MAINTLIB NOT FOUND. PLEASE CREATE IT)\n  ISPEXEC SETMSG MSG(ISRZ001)\n  EXIT QUIT\nEND\nIF &INIT = &STR(YES) THEN GOTO INITDONE\nALLOC DD(ISPFILE) DS('&MAINTLIB') SHR REUSE\nISPEXEC LMINIT DATAID(LIB) DATASET('&MAINTLIB')\nSET &INIT = &STR(YES)\nINITDONE: +\nIF &STR(&MEMBER) \u00ac= &Z THEN DO\n  SET &LTH = &LENGTH(&STR(&MEMBER))\n  IF  &SUBSTR(&LTH:&LTH,&MEMBER) = &STR(*) THEN SET &AST = &STR(YES)\nEND\nCHKFUNC:  +\nIF &F = &STR(B) THEN DO\n/******************\n/** BROWSE FUNCTION\n/******************\n ISPEXEC BROWSE DATAID(&LIB) MEMBER(&MEMBER) MIXED(NO)\n SET &RC = &LASTCC\n IF  &RC = 0 THEN GOTO MAINPNL\n ELSE +\n IF  &RC = 16 THEN DO\n   IF &STR(&MEMBER) = &Z THEN DO\n      SET &ZEDSMSG = &STR(NO MEMBERS IN DATA SET)\n      SET &ZEDLMSG = &STR(THE PDS SPECIFIED CONTAINS NO MEMBERS).\n   END\n   ELSE DO\n      SET &ZEDSMSG = &STR(NO MATCHES)\n      SET &ZEDLMSG = +\n          &STR(THE SPECIFIED PATTERN PRODUCED NO MATCHING MEMBERS).\n   END\n END\n ELSE +\n IF  &RC = 14 THEN DO\n  SET &ZEDSMSG = &STR(MEMBER NOT FOUND)\n  SET &ZEDLMSG = +\n   &STR(THE REQUESTED MEMBER WAS NOT FOUND IN THE PDS DIRECTORY)\n END\n GOTO MAINPANL\nEND\nELSE +\nIF &F = &STR(E) THEN DO\n/******************\n/*** EDIT FUNCTION\n/******************\n ISPEXEC CONTROL ERRORS RETURN\n IF &AST \u00ac= &STR(YES) THEN +\n  IF &MEMBER \u00ac= &Z THEN +\n   IF &SYSDSN('&MAINTLIB(&MEMBER)') = &STR(MEMBER NOT FOUND) THEN DO\n    ISPEXEC  FTOPEN\n    ISPEXEC  FTINCL IOAMNTS2\n    ISPEXEC  FTINCL IOAMNTS1\n    ISPEXEC  FTINCL IOAMNTS3\n    ISPEXEC  FTCLOSE NAME(&MEMBER)\n    IF &LASTCC = 0 THEN DO\n      SET &ZEDSMSG=&STR(MEMBER &MEMBER CREATED)\n      SET &ZEDLMSG=&STR(MEMBER &MEMBER CREATED IN MAINTENANCE LIBRARY)\n    END\n    GOTO CHKFUNC\n   END\n ISPEXEC EDIT DATAID(&LIB) MEMBER(&MEMBER) MIXED(NO)\n SET &RC = &LASTCC\n IF &RC <= 4  THEN GOTO MAINPNL\n ELSE +\n IF &RC = 14 THEN DO\n  IF (&MEMBER = &Z OR &AST = &STR(YES)) THEN DO\n   SET &ZEDSMSG=&STR(DATASET IN USE)\n   SET &ZEDLMSG=&STR(THE SPECIFIED DATA SET IN USE)\n   GOTO MAINPANL\n  END\n  ELSE DO\n   SET &ZEDSMSG=&STR(MEMBER &MEMBER IN USE)\n   SET &ZEDLMSG=&STR(MEMBER &MEMBER IN USE. BROWSE OPTION WAS FORCED)\n   ISPEXEC SETMSG MSG(ISRZ001)\n   SET &F = &STR(B)\n   GOTO CHKFUNC\n  END\n END\n ELSE +\n IF &RC = 16 THEN DO\n  IF &AST = &STR(YES) THEN DO\n    SET &ZEDSMSG = &STR(NO MATCHES)\n    SET &ZEDLMSG = +\n        &STR(THE SPECIFIED PATTERN PRODUCED NO MATCHING MEMBERS).\n    GOTO MAINPANL\n  END\n END\n ELSE DO\n  SET &ZEDSMSG = &STR(SEVERE ERROR RC=&RC)\n  SET &ZEDLMSG = +\n      &STR(SEVERE ERROR DURING EDIT THE MEMBER &MEMBER. RC=&RC.)\n  GOTO MAINPANL\n END\nEND\nELSE GOTO MAINPNL\nFREE: +\nFREE F(ISPFILE)\nIF &LIB = &Z THEN EXIT QUIT\nISPEXEC LMCLOSE DATAID(&LIB)\nISPEXEC LMFREE DATAID(&LIB)\nISPEXEC SETMSG MSG(ISRZ001)\nEXIT QUIT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IOAONL": {"ttr": 12804, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x10_\\x00\\x94\\x10_\\x04\\x10\\x00$\\x00$\\x00\\x00\\xc9\\xd6\\xc1\\xf4\\xf1\\xf0@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-04-15T00:00:00", "modifydate": "1994-04-15T04:10:00", "lines": 36, "newlines": 36, "modlines": 0, "user": "IOA410"}, "text": "PROC 0  ILPREFA(SYSM.IOA)    -\n        ILVERA(V410)      -\n        APPLTYPE(&APPLTYPE)   -\n        APPLID(&APPLID)       -\n/****************************************************************\n/*                                                              *\n/*                  IOAONL                                      *\n/*  MAIN IOA ONLINE CLIST.                                      *\n/*  INVOKED FROM VARIOUS APPLICATION CLISTS                     *\n/*                                                              *\n/****************************************************************\nCONTROL NOMSG NOFLUSH\nALLOC DD(PRTDBG) SYSOUT(X) HOLD  REU\nALLOC DD(CDAMSNAP) SYSOUT(X) HOLD REU\n/**** ALLOC DD(ISPPROF) DSN('&SYSUID..ISPF.ISPPROF') OLD\nCONTROL MSG\nALLOC DD(CTMPGM&APPLID)  -\n  DSN('&ILPREFA..&ILVERA..PARMCMD(PGM&APPLID&APPLTYPE)') SHR REU\nALLOC DD(DAALOCIN)       -\n  DSN('&ILPREFA..&ILVERA..PARM(ALC&APPLID)') SHR REU\nIF &APPLTYPE = S THEN -\n   DO\n   IOATBMN APPLTYPE=&APPLTYPE,APPLID=&APPLID\n   END\nELSE IF &APPLTYPE = I THEN -\n   DO\n   ATTN\n   ISPEXEC SELECT PGM(IOATBMN) NEWAPPL(CTM) PASSLIB -\n   PARM(APPLTYPE=&APPLTYPE,APPLID=&APPLID)\n   ATTN OFF\n   END\nELSE -\n   DO\n   WRITE **** INVALID APPLTYPE VALUE ===> &APPLTYPE ****\n   END\nEND:END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IOAVERFY": {"ttr": 12806, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x10_\\x00\\x94\\x10_\\x04\\x10\\x00%\\x00%\\x00\\x00\\xc9\\xd6\\xc1\\xf4\\xf1\\xf0@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-04-15T00:00:00", "modifydate": "1994-04-15T04:10:00", "lines": 37, "newlines": 37, "modlines": 0, "user": "IOA410"}, "text": "PROC 0       DEBUG +\n             STEPLIB (SYS1.IOA.V410.LOAD) +\n             DBPREFA(SYSS.IOA) +\n             DBVERA(V410) +\n             ILPREFA(SYSM.IOA) +\n             ILVERA(V410) +\n             LANG() +\n             OUT(*) +\n             OUTDUMP(X)\n/********************************************************************/\n/*                                                                  */\n/*                 IOA VERIFICATION PROGRAM                         */\n/*                 ------------------------                         */\n/*                                                                  */\n/*    THIS PROGRAM VERIFIES THE STATUS OF IOA DATA-SETS AND         */\n/*    INSTALLATION PROBLEMS.                                        */\n/*                                                                  */\n/********************************************************************/\nCONTROL MAIN NOLIST NOCONLIST NOSYMLIST NOMSG\nIF &DEBUG=DEBUG THEN CONTROL MAIN LIST CONLIST SYMLIST MSG\nFREE FI(DAVRFREP)\nFREE FI(DAVRFOUT)\nFREE FI(SYSUDUMP)\nFREE FI(PRTDBG)\nFREE FI(DAVRFIN)\nFREE FI(DAALOCIN)\nFREE FI(SYSPRINT)\nALLOC FI(DAVRFREP) DA(*)\nALLOC FI(DAVRFOUT) DA(*)\nALLOC FI(PRTDBG)   DA(*)\nALLOC FI(DADUMP)   DA(*)\nALLOC FI(SYSUDUMP) SYSOUT(&OUTDUMP)\nALLOC FI(DAVRFIN)  DA(*)\nALLOC FI(DAALOCIN) DA('&ILPREFA..&ILVERA..PARM(ALCIOVFY)') SHR\nALLOC FI(SYSPRINT) DA(*)\nWRITE TYPE IN INPUT PARAMETERS\nCALL '&STEPLIB&LANG(CTMVRF10)'\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "IPCSINIT": {"ttr": 12808, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x91\\'?\\x00\\x91\\'?\\x15\"\\x00\\x03\\x00\\x03\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf1\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-09-30T00:00:00", "modifydate": "1991-09-30T15:22:00", "lines": 3, "newlines": 3, "modlines": 0, "user": "TECH110"}, "text": "/* IPCSINIT REXX exec */\naddress \"TSO\" \"ISPSTART PGM(BLSG) NEWAPPL(BLSG) ,\n   PASSLIB PARM(PANEL(BLSPPRIM))\";\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ISPCMDS": {"ttr": 12810, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "JCWMORT": {"ttr": 12814, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x88\\x01?\\x00\\x88\\x11\\x1f\\x16(\\x00\\x06\\x00\\x06\\x00\\x01\\xe3\\xe6\\xd7\\xc8@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1988-01-13T00:00:00", "modifydate": "1988-04-20T16:28:00", "lines": 6, "newlines": 6, "modlines": 1, "user": "TWPH"}, "text": "CONTROL PROMPT\nALLOC FILE(SYSIN) DA(*)\nALLOC FILE(SYSOUT) DA (*)\nCALL 'TD.TEST1.BATCH.LOADLIB(JCWMORT)'\nFREE FILE(SYSIN)\nFREE FILE(SYSOUT)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "JRWSERCH": {"ttr": 12816, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x016\\x00\\x00\\x00\\x94\\x11\\x1f\\x00\\x94\\x13O\\x11S\\x00J\\x00?\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf2\\xf0\\xf9@@@'", "ispf": {"version": "01.54", "flags": 0, "createdate": "1994-04-21T00:00:00", "modifydate": "1994-05-14T11:53:00", "lines": 74, "newlines": 63, "modlines": 0, "user": "TECH209"}, "text": "/*  REXX EXEC : ( WOSEARCH )\n    FUNCTION  : GENERATE CCF TURNOVER DISPLAY OF MEMBERS TURNED OVER.\n    INPUT     : ( SYSS.CCF.TURNOVER.JOURNAL(&&MEMBER)).\n    OUTPUT    : DISPLAY ON TSOE.\n                                                                      */\n/*     */\nHOUSE_KEEPING:\nADDRESS TSO\n/* PARMS = 'WONUMBR' */\nMEMFOUND = 0\nMEMDISP = 0\nTHEDATE = 31\nSAY \"THIS EXEC WILL SHOW THE LAST TWO TIMES A MEMBER HAS\"\nSAY \"BEEN TURNED OVER WITHIN THE LAST 31 DAYS AND ALL\"\nSAY \"MEMBERS ASSOCIATED WITH THE WORKORDERS USED FOR THE TURNOVERS.\"\nSAY\nSAY\nSAY \"ENTER THE MEMBER NAME YOU WOULD LIKE TO SEARCH FOR\"\nPULL MODNAME\nJOURNAL_PDS = 'TECH209.CCF.TEST.EXECL'\nCALL GET_JOURNAL_MEMBER_LIST\nCALL READ_JOURNAL_MEMBER\nCALL DISPLAY_NO_MEMBERS_FOUND\nEXIT\n/*   S U B R O U T I N E   S E C T I O N   */\n/*     */\nGET_JOURNAL_MEMBER_LIST:\nX = OUTTRAP(\"MEMBER.\",\"*\",\"CONCAT\")\n\"LISTDS ('\"JOURNAL_PDS\"') MEMBERS\"\nM = MEMBER.0\nX = MEMBER.0 - 7\nSRC = RC\nIF SRC = 0 THEN RETURN\nSAY\nSAY '*** LISTDS ERROR: ERROR READING ('JOURNAL_PDS') MEMBER LIST. ***'\nSAY '*** WOSEARCH EXEC SUBTASK CANCELLED RC = ('SRC'). ***'\nEXIT SRC\n\n/*     */\nREAD_JOURNAL_MEMBER:\nDO X                /* SKIP LISTDS HEADER INFO - START AT RCD 7 */\n   IF MEMFOUND = 2 THEN LEAVE\n   IF THEDATE = 0 THEN LEAVE\n   MEMBER = STRIP(MEMBER.M)\n/* SAY '+++ PROCESSING JOURNAL MEMBER: ('MEMBER') +++' */\n   \"ALLOC DA('\"JOURNAL_PDS\"(\"MEMBER\")') F(JOURDD) SHR\"\n   \"EXECIO * DISKR JOURDD (FINIS STEM DATA.\"\n   \"FREE FILE(JOURDD)\"\n   M = M - 1\n   THEDATE = THEDATE - 1\n   DO I = 3 TO DATA.0    /* SKIP JOURNAL MEMBER HEADER INFO - START AT RCD 3 */\n      PARSE VAR DATA.I PDATE PTIME WORKORDR PROGRAMMER MASTER MODULE MODTYPE\n         IF MODULE \\= MODNAME THEN ITERATE\n           WONUMBR = WORKORDR\n           CALL READ_MEMBER_AGAIN\n           MEMFOUND = MEMFOUND + 1\n           LEAVE\n   END\nEND\nRETURN\n/*     */\nREAD_MEMBER_AGAIN:\n   DO I = 3 TO DATA.0    /* SKIP JOURNAL MEMBER HEADER INFO - START AT RCD 3 */\n      PARSE VAR DATA.I PDATE PTIME WORKORDR PROGRAMMER MASTER MODULE MODTYPE\n         IF WORKORDR \\= WONUMBR THEN ITERATE\nSAY ''WORKORDR' - 'MODULE' - 'PDATE' - 'MASTER''\nMEMDISP = MEMDISP + 1\nEND\nRETURN\n/*     */\nDISPLAY_NO_MEMBERS_FOUND:\n   IF MEMDISP \u00ac= 0 THEN RETURN\nSAY ''MODNAME' HAS NOT BEEN TURNED OVER IN THE LAST 31 DAYS'\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "JRWSERC1": {"ttr": 12819, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00\\x00\\x00\\x94\\x11\\x1f\\x00\\x94\\x11\\x7f\\x176\\x008\\x00\\x03\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf2\\xf0\\xf9@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "1994-04-21T00:00:00", "modifydate": "1994-04-27T17:36:00", "lines": 56, "newlines": 3, "modlines": 0, "user": "TECH209"}, "text": "/*  REXX EXEC : ( CCFREPRT )\n    FUNCTION  : GENERATE CCF TURNOVER REPORT BY DATE AND MODULE TYPE.\n    INPUT     : ( SYSS.CCF.TURNOVER.JOURNAL(&&MEMBER)).\n    OUTPUT    : ( SYSS.CCF.TURNOVER.REPORT ).\n                                                                      */\n/*     */\nHOUSE_KEEPING:\nADDRESS TSO\nPARMS = 'WONUMBR'\nSAY \"WHAT DATE WOULD YOU LIKE TO GO BACK TO\"\nSAY \"ENTER JULIAN DATE IN FORMAT YYDDD\"\nPARSE PULL 'J'FROMDATE\nSAY \"ENTER THE MEMBER NAME YOU WOULD LIKE TO SEARCH FOR\"\nPARSE PULL MODNAME\nJOURNAL_PDS = 'TECH209.CCF.TEST.EXECL'\nCALL GET_JOURNAL_MEMBER_LIST\nCALL READ_JOURNAL_MEMBER\nEXIT\n/*   S U B R O U T I N E   S E C T I O N   */\n/*     */\nGET_JOURNAL_MEMBER_LIST:\nX = OUTTRAP(\"MEMBER.\",\"*\",\"CONCAT\")\n\"LISTDS ('\"JOURNAL_PDS\"') MEMBERS\"\nSRC = RC\nIF SRC = 0 THEN RETURN\nSAY\nSAY '*** LISTDS ERROR: ERROR READING ('JOURNAL_PDS') MEMBER LIST. ***'\nSAY '*** CCFREPRT EXEC SUBTASK CANCELLED RC = ('SRC'). ***'\nEXIT SRC\n\n/*     */\nREAD_JOURNAL_MEMBER:\nDO M = 7 TO MEMBER.0      /* SKIP LISTDS HEADER INFO - START AT RCD 7 */\n   MEMBER = STRIP(MEMBER.M)\n   IF MEMBER < FROMDATE THEN ITERATE\n/* SAY '+++ PROCESSING JOURNAL MEMBER: ('MEMBER') +++' */\n   \"ALLOC DA('\"JOURNAL_PDS\"(\"MEMBER\")') F(JOURDD) SHR\"\n   \"EXECIO * DISKR JOURDD (FINIS STEM DATA.\"\n   \"FREE FILE(JOURDD)\"\n   DO I = 3 TO DATA.0    /* SKIP JOURNAL MEMBER HEADER INFO - START AT RCD 3 */\n      PARSE VAR DATA.I PDATE PTIME WORKORDR PROGRAMMER MASTER MODULE MODTYPE\n         IF MODULE \\= MODNAME THEN ITERATE\n           WONUMBR = WORKORDR\n           CALL READ_MEMBER_AGAIN\n           LEAVE\n   END\nEND\nRETURN\n/*     */\nREAD_MEMBER_AGAIN:\n   DO I = 3 TO DATA.0    /* SKIP JOURNAL MEMBER HEADER INFO - START AT RCD 3 */\n      PARSE VAR DATA.I PDATE PTIME WORKORDR PROGRAMMER MASTER MODULE MODTYPE\n         IF WORKORDR \\= WONUMBR THEN ITERATE\nSAY ''WORKORDR' - 'MODULE' - 'PDATE' - 'PROGRAMMER''\nEND\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "JULIAN": {"ttr": 13057, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x93(_\\x00\\x932\\x7f\\x16\\x11\\x00<\\x001\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf3@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1993-10-12T00:00:00", "modifydate": "1993-11-23T16:11:00", "lines": 60, "newlines": 49, "modlines": 0, "user": "TECH103"}, "text": "/*  REXX EXEC : ( JULIAN ).\n    FUNCTION  : DISPLAY THE DATE, TIME, DAY, AND CURRENT JULIAN DATE.\n                CALULATE AND DISPLAY THE JUIAN DATE FOR ANY PASSED\n                CALINDAR DATE PARM FORMAT ( MM/DD/YY ).\n                                                                      */\n\nTRACE O\n/*     */\nHOUSE_KEEPING:\nADDRESS TSO\nARG PDATE\nIF PDATE = '' THEN DO\n   JULDATE = DATE(J)\n   CURDATE = DATE(U)\n   CURTIME = TIME()\n   CURDAY = DATE(W)\n   SAY\n   SAY 'DAY:' CURDAY '- DATE:' CURDATE '- TIME:' CURTIME '- JULIAN:' JULDATE\n   SAY\n   EXIT\nEND\n\n/*     */\nCONVERT_JULIAN_DATE:\nSCNT = 0\nDLEN = LENGTH(PDATE)\nIF DLEN = 7 | DLEN = 8 THEN DO I = 1 TO DLEN\n   SLASH = SUBSTR(PDATE,I,1)\n   IF SLASH = '/' THEN SCNT = SCNT + 1\nEND\nIF SCNT \u00ac= 2 THEN DO\n   SAY '*** INVALID DATE PARM ('PDATE') - FORMAT: (M/DD/YY OR MM/DD/YY). ***'\n   SAY '*** JULIAN EXEC MAINTASK CANCELLED. ***'\n   EXIT 024\nEND\nNUMDAYS.1 = '31 28 31 30 31 30 31 31 30 31 30 31'\nNUMDAYS.2 = '31 29 31 30 31 30 31 31 30 31 30 31'\nPARSE VALUE PDATE WITH PMM '/' PDD '/' PYY\nD = 0\nNDAYS = 0\nY = 2\nLEAPYR = PYY // 4\nLDAYS = 635\nIF LEAPYR > 0 THEN DO\n   Y = 1\n   LDAYS = 636\nEND\nIMONTH = PMM - 1\nDO IMONTH\n   D = D + 1\n   MDAYS = WORD(NUMDAYS.Y,D)\n   NDAYS = NDAYS + MDAYS\nEND\nNDAYS = NDAYS + PDD\nNDAYS = RIGHT(NDAYS,3,'0')\nJULDATEO = PYY||NDAYS\nSAY\nSAY '+++ JULIAN DATE FOR 'PDATE':' JULDATEO\nSAY\nEXIT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "KTLMSX": {"ttr": 13059, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x93%/\\x00\\x93%/\\x191\\x00\\x1c\\x00\\x1c\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf7@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-09-09T00:00:00", "modifydate": "1993-09-09T19:31:00", "lines": 28, "newlines": 28, "modlines": 0, "user": "TECH107"}, "text": "/* REXX TLMS    SYSTEM UTILIZATION */\nCALL DSQCIX \"START (DSQSMODE=INTERACTIVE DSQSSUBS=DSNA\";\nif dsq_return_code \u00ac=0 then do;\n    \"VMFCLEAR\";\n    say dsq_message_id dsq_message_text;\n    say dsq_q_message_id dsq_q_message_text;\n    signal term;\n    end;\ndo forever;\n\"VMFCLEAR\";\naddress \"ISPEXEC\" \"DISPLAY PANEL(PTLMS)\";\nif rc\u00ac=0 then signal term;\ndsname=strip(dsn);\nif dsname=\"\" then dsname=\"'%'\";\n    else do; dsname=\"'\"dsname\"%'\"; end;\n\"VMFCLEAR\";\nt=dsname; /* temp variable */\nCALL DSQCIX \"RUN QUERY TECH107.QTLMS (FORM TECH107.FTLMS &FILEDSN=\"t;\nif dsq_return_code \u00ac=0 then do;\n    \"VMFCLEAR\";\n    say dsq_message_id dsq_message_text;\n    say dsq_q_message_id dsq_q_message_text;\n    signal term;\n    end;\nend;\nterm:\nCALL DSQCIX \"EXIT\";\nEXIT 0;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "KWBACKUP": {"ttr": 13061, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x12/\\x00\\x94\\x12/\\x18)\\x02(\\x02(\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf7@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-05-02T00:00:00", "modifydate": "1994-05-02T18:29:00", "lines": 552, "newlines": 552, "modlines": 0, "user": "TECH107"}, "text": "/*  REXX EXEC : ( NWBACKUP ).\n    FUNCTION  : LAN BACKUP PANEL INTERFACE FACILITY FOR RESTART OF A\n                SPECIFIED SERVER VOLUME(S).\n                BUILDS AND SUBMITS THE JOB REQUIRED TO PERFORM THE\n                BACKUP OF THE FAILED VOLUME(S).\n    INPUT     : PTECH2.NETCA.&&SERVER.J&&JULIAN(&&SERVER).\n    OUTPUT    : &&USERID.DIALOG.ISPFILE(&&SERVER).\n    1/26/94 - REALITY AND ASP ADDED\n                                                                    */\nTRACE O\n/*      */\nHOUSE_KEEPING:\nADDRESS ISPEXEC\nTSOID = SYSVAR(SYSUID)\nSERVER.1 = 'CS1 PTTS12'\nSERVER.2 = 'CS2 PTTS13'\nSERVER.3 = 'FIN PTTS14'\nSERVER.4 = 'MIS PTTS15'\nSERVER.5 = 'CS3 PTTS16'\nSERVER.6 = 'CSI PTTS17'\nSERVER.7 = 'DB1 PTTS18'\nSERVER.8 = 'SYS PTTS19'\nSERVER.9 = 'CS4 PTTS43'\nSERVER.10 = 'DB1 PTTS45'\nSERVER.11 = 'COM PTTS20M'         /*  MONTHLY ONLY  */\nSERVER.12 = 'POS PTTS31D'\nSERVER.13 = 'MAGIC PTTS32D'\nSERVER.14 = 'PAD PTTS39D'        /* CS_PDAD SERVER ALWAYS FULL BACKUP */\nSERVER.15 = 'REA PTTS41D'        /* CS_1 VOL2 REALITY */\nSERVER.16 = 'REA PTTS41W'        /* CS_1 VOL2 REALITY */\nSERVER.17 = 'ASP PTTS42D'        /* CS_2 SERVER ALWAYS FULL BACKUP */\nBUSW.1 = 'SELECT'\nBUSW.2 = 'ALL'\nBUTP.1 = 'INCR'\nBUTP.2 = 'FULL'\nJS = 'D'\nCONFIG = 'CONFIGTI'\nBUTYPE = 'INCR'\nBUPARM = 'DAILY'\nSUB_IMMED = 'COM MAGIC PAD POS REA ASP'\nIMMEDCNT = 6\nJCLLIB = 'SYSS.NETCA.PRODJCL.JCLLIB'\nTEXTLIB = 'SYSS.NETCA.CONTROL.TEXTLIB'\nPARMLIB = 'SYSS.NETCA.RESTART.PARMLIB'\nMSGLIB = 'SYSS.NETCA.MESSAGE.CNTLLIB'\nCTEXTLIB = 'SYSS.NETUA.CA.V1R1M1.TEXTLIB'\n\"CONTROL ERRORS RETURN\"\nX = MSG(\"OFF\")\n\n/*     */\nDISPLAY_SERVER_PANEL:\n\"DISPLAY PANEL(NWSRVPNL)\"\nSRC = RC\nIF SRC = 8 THEN EXIT 0\nIF SRC > 8 THEN DO\n   SAY '*** ERROR INVOKING ISPF DIALOG PANEL ( NWSRVPNL ). ***'\n   SAY '*** NWBACKUP EXEC TASK CANCELLED - RC = 'SRC'. ***'\n   EXIT SRC\nEND\n\n/*     */\nCHECK_RESTART_PARMS:\nADDRESS TSO\n\"FREE FILE(NWDD)\"\n\"FREE FILE(ISPFILE)\"\nSERVER = WORD(SERVER.LAN,1)\nTLMS1 = SERVER\nDO S = 1 TO IMMEDCNT\n   BYPASS = WORD(SUB_IMMED,S)\n   IF BYPASS = SERVER THEN DO\n      TLMS1 = SUBSTR(SERVER,1,3)\n      SUBMEMB = WORD(SERVER.LAN,2)\n      SUBPDS = JCLLIB\n      CALL SUBMIT_RESTART_JOB\n      EXIT 0\n   END\nEND\nRSPARM = SERVER||'RSPRM'\nTLMSMEMB = TLMS1||'TLMS'\nNWPDS = PARMLIB\nNWDSN = SYSDSN(\"'\"NWPDS\"(\"RSPARM\")'\")\nIF NWDSN = 'OK' THEN DO\n   VOLSW = 'RSTPARM'\n   CALL GET_RESTART_PARMS\n   IF BUTYPE = 'FULL' THEN DO\n      JS = 'W'\n      CONFIG = 'CONFIGTF'\n      BUPARM = 'DAILYF'\n   END\n   IF BLDJOB = 'NO' THEN DO\n      SUBPDS = JCLLIB\n      SMEMB = WORD(SERVER.LAN,2)\n      SUBMEMB = SMEMB||JS\n      CALL SUBMIT_RESTART_JOB\n      EXIT 0\n   END\n   CALL BUILD_RESTART_VOLUME_MEMBER\n   CALL WRITE_PDS_MEMBER\n   CALL BUILD_RESTART_CONFIG_MEMBER\n   IF CFM = 'MEMBER NOT FOUND' THEN CALL WRITE_PDS_MEMBER\n   CALL ALLOC_ISPFILE_PDS\n   CALL BUILD_RESTART_JOB\n   CALL WRITE_PDS_MEMBER\n   SMEMB = WORD(SERVER.LAN,2)\n   SUBMEMB = SMEMB||JS\n   SUBPDS = TSOID||'.DIALOG.ISPFILE'\n   CALL SUBMIT_RESTART_JOB\n   CALL DELETE_ISPFILE_PDS\n   EXIT 0\nEND\n\n/*     */\nBUILD_RESTART_VOLUME_CONFIG:\nADDRESS TSO\nBUTYPE = 'FULL'\nCALL READ_SERVER_VOLUMES_PARMS\nBUPARM = 'DAILY'\nCALL DISPLAY_VOLUME_PANEL\nIF BUSW.LBU = 'ALL' THEN DO\n   JS = 'D'\n   SUBPDS = JCLLIB\n   SMEMB = WORD(SERVER.LAN,2)\n   IF BUTP.BUT = 'FULL' THEN JS = 'W'\n   SUBMEMB = SMEMB||JS\n   CALL SUBMIT_RESTART_JOB\n   EXIT 0\nEND\nBUTYPE = BUTP.BUT\nIF BUTYPE = 'FULL' THEN BUPARM = 'DAILYF'\nCALL BUILD_PANEL_RESTART_VOLUME_MEMBER\nIF RCNT = 0 THEN DO FOREVER\n   ADDRESS ISPEXEC \"SETMSG MSG(NWLAN001)\"\n   CALL DISPLAY_VOLUME_PANEL\n   CALL BUILD_PANEL_RESTART_VOLUME_MEMBER\n   IF RCNT > 0 THEN LEAVE\nEND\nCALL WRITE_PDS_MEMBER\nCALL BUILD_RESTART_CONFIG_MEMBER\nIF CFM = 'MEMBER NOT FOUND' THEN CALL WRITE_PDS_MEMBER\nCALL ALLOC_ISPFILE_PDS\nCALL GET_PANEL_VOLUMES\nCALL BUILD_RESTART_JOB\nCALL WRITE_PDS_MEMBER\nSMEMB = WORD(SERVER.LAN,2)\nSUBMEMB = SMEMB||JS\nSUBPDS = TSOID||'.DIALOG.ISPFILE'\nCALL SUBMIT_RESTART_JOB\nCALL DELETE_ISPFILE_PDS\nEXIT 0\n\n/*     S U B R O U T I N E S   S E C T I O N     */\n/*     */\nGET_RESTART_PARMS:\nADDRESS TSO\nBLDJOB = 'YES'\n\"ALLOC DA('\"NWPDS\"(\"RSPARM\")') FILE(NWDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('NWPDS'('RSPARM'). ***'\n   SAY '*** NWBACKUP EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\n\"EXECIO * DISKR NWDD (FINIS STEM VOLR.\"\nSRC = RC\n\"FREE FILE(NWDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** EXECIO READ ERROR: ('NWPDS'('RSPARM'). ***'\n   SAY '*** NWBACKUP EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nSERVOL = WORD(VOLR.1,1)\nBUTYPE = WORD(VOLR.1,3)\nIF SERVOL = 'ALL' THEN BLDJOB = 'NO'\nRETURN\n\n/*     */\nBUILD_RESTART_VOLUME_MEMBER:\nADDRESS TSO\n\"DELSTACK\"\nOUTMEMB = SERVER||'VOLS'\nOUTPDS = PARMLIB\nVOLPARMS = SERVER||'FVOLS'\n\"ALLOC DA('\"TEXTLIB\"(\"VOLPARMS\")') FILE(NWDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('TEXTLIB'('VOLPARMS'). ***'\n   SAY '*** NWBACKUP EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\n\"EXECIO * DISKR NWDD (FINIS STEM VOLP.\"\nSRC = RC\n\"FREE FILE(NWDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** EXECIO READ ERROR: ('TEXTLIB'('VOLPARMS'). ***'\n   SAY '*** NWBACKUP EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nDO I = 1 TO VOLR.0\n   SERVOL = WORD(VOLR.I,1)\n   DO V = 1 TO VOLP.0\n      UPPER VOLP.V\n      PVOL = WORD(VOLP.V,1)\n      IF PVOL = SERVOL THEN QUEUE VOLP.V\n   END\nEND\nRETURN\n\n/*     */\nBUILD_RESTART_CONFIG_MEMBER:\nADDRESS TSO\n\"DELSTACK\"\nOUTMEMB = SERVER||'CONFG'\nOUTPDS = PARMLIB\nVOLMEMB = SERVER||'VOLS'\nCFM = SYSDSN(\"'\"PARMLIB\"(\"OUTMEMB\")'\")\nIF CFM = 'OK' THEN RETURN\n\"ALLOC DA('\"TEXTLIB\"(\"CONFIG\")') FILE(NWDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('TEXTLIB'('CONFIG'). ***'\n   SAY '*** NWBACKUP EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\n\"EXECIO * DISKR NWDD (FINIS STEM PARM.\"\nSRC = RC\n\"FREE FILE(NWDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** EXECIO READ ERROR: ('TEXTLIB'('CONFIG'). ***'\n   SAY '*** NWBACKUP EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nDO I = 1 TO PARM.0\n   CHG = POS('VOLUMES',PARM.I)\n   IF CHG \u00ac= 0 THEN DO\n      PARM.I = \"         VOLUMES      '\"PARMLIB\"(\"VOLMEMB\")'\"\n   END\n   QUEUE PARM.I\nEND\nRETURN\n\n/*     */\nBUILD_RESTART_JOB:\n\"DELSTACK\"\nJ = 22\nSRVCONFG = SERVER||'CONFG'\nSMEMB = WORD(SERVER.LAN,2)\nJN = SMEMB||JS\nOUTMEMB = JN\nWTR = SUBSTR(JN,2)\nWTRNAME = WTR'00'\nOUTPDS = TSOID||'.DIALOG.ISPFILE'\nSCHPRT = 'PTECH2.NETCA.'SERVER'.SCHPRINT'\nSYSPRT = 'PTECH2.NETCA.'SERVER'.SYSPRINT'\nJCL.1 = \"//\"JN\"  JOB O030OVRHD0000000,'\"SERVER\" LAN BACKUP',NOTIFY=TECH251,\"\nJCL.2 = \"//             CLASS=F,MSGCLASS=Q,MSGLEVEL=(1,1),REGION=6M\"\nJCL.3 = \"//STEP010  EXEC PGM=IKJEFT01,DYNAMNBR=30,\"\nJCL.4 = \"//         PARM='%NWALLOC \"SERVER\" \"BUPARM\"'\"\nJCL.5 = \"//SYSTSPRT DD SYSOUT=*\"\nJCL.6 = \"//SYSPRINT DD SYSOUT=*\"\nJCL.7 = \"//SYSIN DD DUMMY\"\nJCL.8 = \"//SYSLBC DD DSN=SYS1.BRODCAST,DISP=SHR\"\nJCL.9 = \"//SYSUADS DD DSN=SYS1.UADS,DISP=SHR\"\nJCL.10 = \"//SYSPROC DD DSN=SYSS.TECH.COMMON.EXECLIB,DISP=SHR\"\nJCL.11 = \"//SYSTSIN DD DUMMY\"\nJCL.12 = \"/*\"\nJCL.13 = \"//ABEND010 EXEC PGM=ABENDWTO,COND=(0,GE,STEP010)\"\nJCL.14 = \"//* *** STEPLIB DD DSN=SYS1.PROD.BATCH.LOADLIB,DISP=SHR\"\nJCL.15 = \"/*\"\nJCL.16 = \"//STEP020 EXEC PGM=NUACLIEN\"\nJCL.17 = \"//SCHPRINT DD DSN=\"SCHPRT\",DISP=(MOD,CATLG,DELETE),\"\nJCL.18 = \"// SPACE=(CYL,(2,0,0)),DCB=(RECFM=FBA,LRECL=133,BLKSIZE=133),\"\nJCL.19 = \"// DATACLAS=LISTING\"\nJCL.20 = \"//SYSPRINT DD DSN=\"SYSPRT\",DISP=(MOD,CATLG,DELETE),\"\nJCL.21 = \"// SPACE=(CYL,(2,0,0)),DCB=(RECFM=FBA,LRECL=133,BLKSIZE=133),\"\nJCL.22 = \"// DATACLAS=LISTING\"\nIF VOLSW = 'RSTPARM' THEN DO\n   DO I = 1 TO VOLR.0\n      JVOL = WORD(VOLR.I,1)\n      DDVOL = 'DDC'||JVOL\n      DDINDX = 'DDI'||JVOL\n      BT = BUTYPE\n      IF I = 1 THEN DO\n         TUNIT = 'UNIT=(SILO,,DEFER)'\n         SAVEDD = DDVOL\n      END\n      IF I > 1 THEN TUNIT = 'UNIT=AFF='SAVEDD\n      REC.1 = \"//\"DDVOL\"  DD DSN=PTAP.NETCA.\"SERVER\".\"JVOL\".\"BT\".CONTAINR(+1),\"\n      REC.2 = \"//         DISP=(NEW,CATLG,DELETE),\"TUNIT\",\"\n      REC.3 = \"//         VOLUME=(,,,99),LABEL=(1,SL),\"\n      REC.4 = \"//   DCB=(MODEL.DSCB,RECFM=U,LRECL=0,BLKSIZE=32760,DSORG=PS)\"\n      REC.5 = \"//\"DDINDX\" DD DSN=PTECH2.NETCA.\"SERVER\".\"JVOL\".\"BT\".INDEX(+1),\"\n      REC.6 = \"//            DISP=(NEW,CATLG,DELETE),\"\n      REC.7 = \"//  DCB=(BLKSIZE=27998,LRECL=27994,RECFM=VB,DSORG=PS),\"\n      REC.8 = \"//  DATACLAS=DATAPS,MGMTCLAS=STANDARD,STORCLAS=SCSTNRDG,\"\n      REC.9 = \"//  SPACE=(27998,(50,10),RLSE)\"\n      DO E = 1 TO 9\n         J = J + 1\n         JCL.J = REC.E\n      END\n   END\nEND\nIF VOLSW = 'PANEL' THEN DO\n   DO I = 1 TO VOLP.0\n      JVOL = WORD(VOLP.I,1)\n      DDVOL = 'DDC'||JVOL\n      DDINDX = 'DDI'||JVOL\n      BT = BUTYPE\n      IF I = 1 THEN DO\n         TUNIT = 'UNIT=(SILO,,DEFER)'\n         SAVEDD = DDVOL\n      END\n      IF I > 1 THEN TUNIT = 'UNIT=AFF='SAVEDD\n      REC.1 = \"//\"DDVOL\"  DD DSN=PTAP.NETCA.\"SERVER\".\"JVOL\".\"BT\".CONTAINR(+1),\"\n      REC.2 = \"//         DISP=(NEW,CATLG,DELETE),\"TUNIT\",\"\n      REC.3 = \"//         VOLUME=(,,,99),LABEL=(1,SL),\"\n      REC.4 = \"//   DCB=(MODEL.DSCB,RECFM=U,LRECL=0,BLKSIZE=32760,DSORG=PS)\"\n      REC.5 = \"//\"DDINDX\" DD DSN=PTECH2.NETCA.\"SERVER\".\"JVOL\".\"BT\".INDEX(+1),\"\n      REC.6 = \"//            DISP=(NEW,CATLG,DELETE),\"\n      REC.7 = \"//  DCB=(BLKSIZE=27998,LRECL=27994,RECFM=VB,DSORG=PS),\"\n      REC.8 = \"//  DATACLAS=DATAPS,MGMTCLAS=STANDARD,STORCLAS=SCSTNRDG,\"\n      REC.9 = \"//  SPACE=(27998,(50,10),RLSE)\"\n      DO E = 1 TO 9\n         J = J + 1\n         JCL.J = REC.E\n      END\n   END\nEND\nJCLCNT = J\nDO J = 1 TO JCLCNT\n   QUEUE JCL.J\nEND\nR = 0\nRCDCNT = 35\nRCD.1 = \"//NUACACON DD DSN=\"PARMLIB\"(\"SRVCONFG\"),DISP=SHR\"\nRCD.2 = \"//NUACATXT DD DSN=\"CTEXTLIB\",DISP=SHR\"\nRCD.3 = \"//PARAMS DD *\"\nRCD.4 = \"-HOST \"SERVER\" -OUTPUT 'PTECH2.NETCA.\"SERVER\".SCRIPT'\"\nRCD.5 = \"    DD:NUACACON -CHECK\"\nRCD.6 = \"//SYSIN DD *\"\nRCD.7 = \"SET INPUT VERIFY ON\"\nRCD.8 = \"INPUT DD:NUACATXT(BASIC) 'PTECH2.NETCA.\"SERVER\".SCRIPT'\"\nRCD.9 = \"/*\"\nRCD.10 = \"//STEP030 EXEC PGM=IKJEFT01,DYNAMNBR=30,\"\nRCD.11 = \"// PARM='%NWABEND \"SERVER\" \"BUTYPE\" RESTART',\"\nRCD.12 = \"// COND=(4,GE,STEP020)\"\nRCD.13 = \"//SYSTSPRT DD SYSOUT=*\"\nRCD.14 = \"//SYSPRINT DD SYSOUT=*\"\nRCD.15 = \"//SYSIN DD DUMMY\"\nRCD.16 = \"//SYSLBC DD DSN=SYS1.BRODCAST,DISP=SHR\"\nRCD.17 = \"//SYSUADS DD DSN=SYS1.UADS,DISP=SHR\"\nRCD.18 = \"//SYSPROC DD DSN=SYSS.TECH.COMMON.EXECLIB,DISP=SHR\"\nRCD.19 = \"//SYSTSIN DD DUMMY\"\nRCD.20 = \"/*\"\nRCD.21 = \"//STEP040  EXEC CATRPTS,COND=((4,GE,STEP020),(1,NE,STEP030))\"\nRCD.22 = \"//SYSIN    DD DSN=\"PARMLIB\"(\"TLMSMEMB\"),DISP=SHR\"\nRCD.23 = \"/*\"\nRCD.24 = \"//ABEND050 EXEC WTO,COND=(4,GE,STEP020)\"\nRCD.25 = \"//SYSIN DD DSN=\"MSGLIB\"(\"SERVER\"),DISP=SHR\"\nRCD.26 = \"/*\"\nRCD.27 = \"//STEP060 EXEC PGM=IEBGENER\"\nRCD.28 = \"//SYSUT1 DD DSN=\"SYSPRT\",DISP=SHR\"\nRCD.29 = \"//SYSUT2 DD SYSOUT=(V,\"WTRNAME\"),DCB=BLKSIZE=133\"\nRCD.30 = \"//SYSPRINT DD DUMMY\"\nRCD.31 = \"//SYSIN DD DUMMY\"\nRCD.32 =  \"/*\"\nRCD.33 = \"//*          ABEND STEP FOR RETURN CODE GE 4\"\nRCD.34 = \"//ABEND070 EXEC PGM=ABENDWTO,COND=(4,GE,STEP020)\"\nRCD.35 = \"//\"\nDO RCDCNT\n   R = R + 1\n   QUEUE RCD.R\nEND\nRETURN\n\n/*     */\nREAD_SERVER_VOLUMES_PARMS:\nVOLPARMS = SERVER||'FVOLS'\n\"ALLOC DA('\"TEXTLIB\"(\"VOLPARMS\")') FILE(NWDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('TEXTLIB'('VOLPARMS'). ***'\n   SAY '*** NWBACKUP EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\n\"EXECIO * DISKR NWDD (FINIS STEM VOLB.\"\nSRC = RC\n\"FREE FILE(NWDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** EXECIO READ ERROR: ('TEXTLIB'('VOLPARMS'). ***'\n   SAY '*** NWBACKUP EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nV = 0\nVOL1 = '*****'\nVOL2 = '*****'\nVOL3 = '*****'\nVOL4 = '*****'\nVOL5 = '*****'\nVOL6 = '*****'\nVOL7 = '*****'\nVOL8 = '*****'\nDO I = 1 TO VOLB.0\n   UPPER VOLB.I\n   SVOL = POS(BUPARM,VOLB.I)\n   IF SVOL = 0 THEN ITERATE\n   V = V + 1\n   SERVOL = WORD(VOLB.I,1)\n   IF V = 1 THEN VOL1 = LEFT(SERVOL,5,'*')\n   IF V = 2 THEN VOL2 = LEFT(SERVOL,5,'*')\n   IF V = 3 THEN VOL3 = LEFT(SERVOL,5,'*')\n   IF V = 4 THEN VOL4 = LEFT(SERVOL,5,'*')\n   IF V = 5 THEN VOL5 = LEFT(SERVOL,5,'*')\n   IF V = 6 THEN VOL6 = LEFT(SERVOL,5,'*')\n   IF V = 7 THEN VOL7 = LEFT(SERVOL,5,'*')\n   IF V = 8 THEN VOL8 = LEFT(SERVOL,5,'*')\nEND\nRETURN\n\n/*     */\nDISPLAY_VOLUME_PANEL:\nADDRESS ISPEXEC \"DISPLAY PANEL(NWVOLPNL)\"\nSRC = RC\nIF SRC = 8 THEN EXIT 0\nIF SRC > 8 THEN DO\n   SAY '*** ERROR INVOKING ISPF DIALOG PANEL ( NWVOLPNL ). ***'\n   SAY '*** NWBACKUP EXEC TASK CANCELLED - RC = 'SRC'. ***'\n   EXIT SRC\nEND\nRETURN\n\n/*     */\nBUILD_PANEL_RESTART_VOLUME_MEMBER:\nADDRESS TSO\n\"DELSTACK\"\nVOLSW = 'PANEL'\nOUTMEMB = SERVER||'VOLS'\nOUTPDS = PARMLIB\nVOLPARMS = SERVER||'FVOLS'\n\"ALLOC DA('\"TEXTLIB\"(\"VOLPARMS\")') FILE(NWDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('TEXTLIB'('VOLPARMS'). ***'\n   SAY '*** NWBACKUP EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\n\"EXECIO * DISKR NWDD (FINIS STEM VOLP.\"\nSRC = RC\n\"FREE FILE(NWDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** EXECIO READ ERROR: ('TEXTLIB'('VOLPARMS'). ***'\n   SAY '*** NWBACKUP EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nDO I = 1 TO 8\n   SELVOL = VALUE('VBU'I)\n   IF SELVOL = '' THEN ITERATE\n   BUVOL = VALUE('VOL'I)\n   IF BUVOL = '' THEN ITERATE\n   SVR = POS('*',BUVOL)\n   SVRVOL = BUVOL\n   IF SVR \u00ac= 0 THEN DO\n      SVR = SVR - 1\n      SVRVOL = SUBSTR(BUVOL,1,SVR)\n   END\n   DO V = 1 TO VOLP.0\n      UPPER VOLP.V\n      SVOL = POS(BUPARM,VOLP.V)\n      IF SVOL = 0 THEN ITERATE\n      PVOL = WORD(VOLP.V,1)\n      IF PVOL = SVRVOL THEN QUEUE VOLP.V\n   END\nEND\nRCNT = QUEUED()\nRETURN\n\n/*     */\nGET_PANEL_VOLUMES:\nVOLMEMB = SERVER||'VOLS'\n\"ALLOC DA('\"PARMLIB\"(\"VOLMEMB\")') FILE(NWDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('PARMLIB'('VOLMEMB'). ***'\n   SAY '*** NWBACKUP EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\n\"EXECIO * DISKR NWDD (FINIS STEM VOLP.\"\nSRC = RC\n\"FREE FILE(NWDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** EXECIO READ ERROR: ('PARMLIB'('VOLMEMB'). ***'\n   SAY '*** NWBACKUP EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nRETURN\n\n/*     */\nALLOC_ISPFILE_PDS:\nADDRESS TSO\nUCNTL = SYSDSN(DIALOG.ISPFILE)\nIF UCNTL = 'DATASET NOT FOUND' THEN DO\n\"ALLOC DA(DIALOG.ISPFILE) LIKE(USER.CNTLLIB) NEW SPACE(1,0) DIR(5) CYLINDERS\"\n   SRC = RC\n   IF SRC \u00ac= 0 THEN DO\n   SAY '*** ALLOCATE ERROR: ERROR ALLOCATING DATASET (DIALOG.ISPFILE). ***'\n   SAY '*** NWBACKUP EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\n   END\nEND\nRETURN\n\n/*     */\nWRITE_PDS_MEMBER:\n\"ALLOC DA('\"OUTPDS\"(\"OUTMEMB\")') FILE(NWDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('OUTPDS'('OUTMEMB'). ***'\n   SAY '*** NWBACKUP EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nNUMRCDS = QUEUED()\n\"EXECIO\" NUMRCDS \"DISKW NWDD (FINIS\"\nSRC = RC\n\"FREE FILE(NWDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** WRITE ERROR: ERROR WRITING 'OUTPDS'('OUTMEMB'). ***'\n   SAY '*** NWBACKUP EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nRETURN\n\n/*     */\nSUBMIT_RESTART_JOB:\nADDRESS TSO\n\"SUBMIT '\"SUBPDS\"(\"SUBMEMB\")'\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** SUBMIT ERROR: MEMBER ( 'SUBPDS'('SUBMEMB'). ***'\n   SAY '*** NWBACKUP EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nIF NWDSN = 'OK' THEN DO\n   \"ALLOC DA('\"NWPDS\"(\"RSPARM\")') FILE(NWDD) SHR\"\n   \"DELETE ('\"NWPDS\"(\"RSPARM\")') FILE(NWDD)\"\n   \"FREE FILE(NWDD)\"\nEND\nRETURN\n\n/*     */\nDELETE_ISPFILE_PDS:\nADDRESS TSO\n\"DELETE  (DIALOG.ISPFILE)   NONVSAM SCRATCH PURGE\"\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "KWRESTOR": {"ttr": 13315, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x12/\\x00\\x94\\x12/#Q\\x02~\\x02~\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf7@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-05-02T00:00:00", "modifydate": "1994-05-02T23:51:00", "lines": 638, "newlines": 638, "modlines": 0, "user": "TECH107"}, "text": "/*  REXX EXEC : ( NWRESTOR ).\n    FUNCTION  : LAN SERVER BACKUP PANEL INTERFACE TO FACILITATE FILE\n                RESTORES FOR A SERVER VOLUME FROM THE MVS HOST CENTRAL\n                ARCHIVE BACKUP.\n                BUILDS AND WRITES THE JOB JCL AND INPUT SCRIPT TO\n                PERFORM THE LAN SERVER RESTORE AND SUBMITS THE JOB\n                FOR EXECUTION ON THE SYSB SYSTEM CLASS=S.\n    INPUT     : ( PTECH2.NETCA.&&SERVER.&&VOLUME.H ).\n                ( SYSS.NETCA.LAN.MVSNW.UA ).\n    OUTPUT    : ( PTECH3.NETCA.RESTORE.SCRIPT.PARMLIB(&MEMBER).\n                ( PTECH3.NETCA.RESTORE.SCRIPT.CNTLLIB(&MEMBER).\n    1/26/94   - ADDED REALITY AND ASP\n                                                                    */\nTRACE O\n/*      */\nHOUSE_KEEPING:\nADDRESS TSO\nSERVER.1 = 'COM'\nSERVER.2 = 'CS1'\nSERVER.3 = 'CS2'\nSERVER.4 = 'MAGIC'\nSERVER.5 = 'POS'\nSERVER.6 = 'CS3'\nSERVER.7 = 'DB1'\nSERVER.8 = 'CSI'\nSERVER.9 = 'FIN'\nSERVER.10 = 'MIS'\nSERVER.11 = 'SYS'\nSERVER.12 = 'PAD'\nSERVER.13 = 'REA'\nSERVER.14 = 'ASP'\nSERVER.15 = 'CS4'\nSERVER.16 = 'DB1'\nSERVER.17 = 'C4A'\nSERVER.18 = 'C4B'\nRESTYPE.1 = 'FILE'\nRESTYPE.2 = 'DRCT'\nRESTYPE.3 = 'VOL'\nRESTMOD.1 = 'INCR'\nRESTMOD.2 = 'FULL'\nPARMLIB = 'SYSS.TECH.COMMON.PARMLIB'\nSCRIPTLIB = 'PTECH3.NETCA.RESTORE.SCRIPT.PARMLIB'\nCNTLLIB = 'PTECH3.NETCA.RESTORE.SCRIPT.CNTLLIB'\nTEXTLIB = 'SYSS.NETCA.CONTROL.TEXTLIB'\nTSOID = SYSVAR(SYSUID)\nCURTIME = TIME()\nHH = SUBSTR(CURTIME,1,2)\nMM = SUBSTR(CURTIME,4,2)\nSS = SUBSTR(CURTIME,7,2)\nTIMEP = HH||MM||SS\nJSUFFIX = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\nX = MSG(\"OFF\")\n\"FREE FILE(NWDD)\"\nADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\n\n/*     */\nDISPLAY_SERVER_PANEL:\nAUTHPARM = 'NWHPDESK'\nNWMSG = 'NWLAN002'\nDO FOREVER\n   ADDRESS ISPEXEC\n   \"DISPLAY PANEL(NWRSTPN1)\"\n   SRC = RC\n   IF SRC = 8 THEN EXIT 0\n   IF SRC > 8 THEN DO\n      SAY '*** ERROR INVOKING ISPF DIALOG PANEL ( NWRSTPN1 ). ***'\n      SAY '*** NWRESTOR EXEC TASK CANCELLED - RC = 'SRC'. ***'\n      EXIT SRC\n   END\n   IF RESTYPE.RT = 'VOL' THEN DO\n      AUTHPARM = 'NWLANGRP'\n      NWMSG = 'NWLAN003'\n   END\n   CALL CHECK_USER_AUTHORIZATION\n   IF AUTHSW = 'YES' THEN LEAVE\n   \"SETMSG MSG(\"NWMSG\")\"\nEND\nSERVER = SERVER.LAN\nIF SERVER = 'MAGIC' THEN DO\n   VOLKEY = 'MAGIC SYS:'\n   RESTVOL = 'SYS:'\n/* RESTDPN = 'MAGIC' */\n   VOLUME = 'MAGIC'\n   SERVER = 'CS3'\n   RM = 2\n   SIGNAL BUILD_CONTAINER_DATASET_PARMS\nEND\nIF SERVER = 'POS' THEN DO\n   VOLKEY = 'POS VOL1:'\n   RESTVOL = 'VOL1:'\n/* RESTDPN = 'POS' */\n   VOLUME = 'POS'\n   SERVER = 'CS3'\n   RM = 2\n   SIGNAL BUILD_CONTAINER_DATASET_PARMS\nEND\nIF SERVER = 'REA' THEN DO\n   VOLKEY = 'REA VOL2:'\n   RESTVOL = 'VOL2:'\n   RESTDPN = 'REA'\n   VOLUME = 'REA'\n   SERVER = 'CS1'\n   RM = 2\n   SIGNAL BUILD_CONTAINER_DATASET_PARMS\nEND\nIF SERVER = 'ASP' THEN DO\n   VOLKEY = 'ASP VOL1:'\n   RESTVOL = 'VOL1:'\n   RESTDPN = 'ASP'\n   VOLUME = 'ASP'\n   SERVER = 'CSI'\n   RM = 2\n   SIGNAL BUILD_CONTAINER_DATASET_PARMS\nEND\n\n/*     */\nDISPLAY_VOLUME_PANEL:\nADDRESS TSO\n\"FREE FILE(NWDD)\"\n\"FREE FILE(ISPFILE)\"\nCALL READ_SERVER_VOLUMES_PARMS\nADDRESS ISPEXEC \"DISPLAY PANEL(NWRSTPN2)\"\nSRC = RC\nIF SRC = 8 THEN EXIT 0\nIF SRC > 8 THEN DO\n   SAY '*** ERROR INVOKING ISPF DIALOG PANEL ( NWRSTPN2 ). ***'\n   SAY '*** NWRESTOR EXEC TASK CANCELLED - RC = 'SRC'. ***'\n   EXIT SRC\nEND\nCALL GET_SELECTED_SERVER_VOLUME\nVOLKEY = VOLUME RESTVOL\n\n/*     */\nBUILD_CONTAINER_DATASET_PARMS:\nCALL GET_HISTORY_CONTAINER_DATASETS\nIF DSN = 0 THEN DO\n   SAY '*** HISTORY DATASET ERROR: NO VALID CONTAINER DATASET NAMES FOUND. ***'\n   SAY '*** DSN ('NWHSTLIB') DOES NOT CONTAIN A BACKUP STATUS OF (SSSS). ***'\n   SAY '*** NWRESTOR EXEC TASK CANCELLED - RC = (028). ***'\n   EXIT 028\nEND\nGDGCNT = 18\nNWPANEL = 'NWRSTPN3'\nIF RESTMOD.RM = 'FULL' & SERVER \u00ac= 'PAD' THEN DO\n   GDGCNT = 6\n   NWPANEL = 'NWRSTPN4'\nEND\nCALL BUILD_PANEL_DATASET_PARMS\n\n/*     */\nDISPLAY_DATASET_LIST_PANEL:\nDO FOREVER\n   ADDRESS ISPEXEC\n   \"DISPLAY PANEL(\"NWPANEL\")\"\n   SRC = RC\n   IF SRC = 8 THEN EXIT 0\n   IF SRC > 8 THEN DO\n      SAY '*** ERROR INVOKING ISPF DIALOG PANEL ( 'NWPANEL' ). ***'\n      SAY '*** NWRESTOR EXEC TASK CANCELLED - RC = 'SRC'. ***'\n      EXIT SRC\n   END\n   CALL GET_PANEL_INPUT_DATASET\n   IF DSNSW = 'YES' THEN LEAVE\n   \"SETMSG MSG(NWLAN004)\"\nEND\nIF RESTYPE.RT = 'DRCT' & RESTFN = '' THEN RESTFN = '*'\nIF RESTYPE.RT = 'VOL' THEN DO\n   RESTDPN = '*'\n   RESTFN = '*'\nEND\n\n/*     */\nDISPLAY_INPUT_PARMS_CONFIRMATION_PANEL:\nCALL LISTCAT_CONTAINER_DATASET\nCALL BUILD_PANEL_TAPE_VOLSERS\nADDRESS ISPEXEC\n\"DISPLAY PANEL(NWRSTPN5)\"\nSRC = RC\nIF SRC = 8 THEN EXIT 0\nIF SRC > 8 THEN DO\n   SAY '*** ERROR INVOKING ISPF DIALOG PANEL ( NWRSTPN5 ). ***'\n   SAY '*** NWRESTOR EXEC TASK CANCELLED - RC = 'SRC'. ***'\n   EXIT SRC\nEND\n\n/*     */\nCREATE_RESTORE_JOB_PARMS:\nADDRESS TSO\nSUBPDS = CNTLLIB\nJMEMB = 'J'TIMEP                  /* JOURNAL PARMS MEMBER */\nRMEMB = 'R'TIMEP                  /* RESTORE JOB JCL MEMBER */\nSMEMB = 'S'TIMEP                  /* SCRIPT INPUT MEMBER */\n\"DELSTACK\"\nCALL BUILD_JOBNAME_PARM\nOUTPDS = CNTLLIB\nOUTMEMB = JOBNAME\nQUEUE JOBNAME\nCALL WRITE_PDS_MEMBER\nCALL BUILD_RESTORE_JOB\nOUTMEMB = RMEMB\nCALL WRITE_PDS_MEMBER\n\"DELSTACK\"\nQUEUE SERVER\nQUEUE RESTVOL\nQUEUE RESTDSN\nQUEUE RESTDPN\nQUEUE RESTFN\nOUTMEMB = JMEMB\nCALL WRITE_PDS_MEMBER\nCALL BUILD_RESTORE_PARMS\nOUTMEMB = SMEMB\nOUTPDS = SCRIPTLIB\nCALL WRITE_PDS_MEMBER\nCALL SUBMIT_RESTORE_JOB\nEXIT 0\n\n/*     S U B R O U T I N E S   S E C T I O N     */\n/*     */\nCHECK_USER_AUTHORIZATION:\nADDRESS TSO\nAUTHSW = 'NO'\n\"ALLOC DA('\"PARMLIB\"(\"AUTHPARM\")') FILE(NWDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('PARMLIB'('AUTHPARM'). ***'\n   SAY '*** NWRESTOR EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\n\"EXECIO * DISKR NWDD (FINIS STEM AUTH.\"\nSRC = RC\n\"FREE FILE(NWDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** EXECIO READ ERROR: ('PARMLIB'('AUTHPARM'). ***'\n   SAY '*** NWRESTOR EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nDO I = 1 TO AUTH.0\n   LAU = POS(TSOID,AUTH.I)\n   IF LAU \u00ac= 0 THEN AUTHSW = 'YES'\nEND\nRETURN\n\n/*     */\nREAD_SERVER_VOLUMES_PARMS:\nADDRESS TSO\nVOLCONFG = SERVER'IVOLS'\nIF RESTMOD.RM = 'FULL' THEN VOLCONFG = SERVER'FVOLS'\n\"ALLOC DA('\"TEXTLIB\"(\"VOLCONFG\")') FILE(NWDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('TEXTLIB'('VOLCONFG'). ***'\n   SAY '*** NWRESTOR EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\n\"EXECIO * DISKR NWDD (FINIS STEM VOLP.\"\nSRC = RC\n\"FREE FILE(NWDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** EXECIO READ ERROR: ('TEXTLIB'('VOLCONFG'). ***'\n   SAY '*** NWRESTOR EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nV = 0\nVOL1 = '*****'\nVOL2 = '*****'\nVOL3 = '*****'\nVOL4 = '*****'\nVOL5 = '*****'\nVOL6 = '*****'\nVOL7 = '*****'\nVOL8 = '*****'\nDO I = 1 TO VOLP.0\n   UPPER VOLP.I\n   SVOL = POS('DAILY',VOLP.I)\n   IF SVOL = 0 THEN ITERATE\n   V = V + 1\n   SERVOL = WORD(VOLP.I,2)\n   RSTVOL.V = WORD(VOLP.I,2)\n   IF V = 1 THEN VOL1 = LEFT(SERVOL,5,'*')\n   IF V = 2 THEN VOL2 = LEFT(SERVOL,5,'*')\n   IF V = 3 THEN VOL3 = LEFT(SERVOL,5,'*')\n   IF V = 4 THEN VOL4 = LEFT(SERVOL,5,'*')\n   IF V = 5 THEN VOL5 = LEFT(SERVOL,5,'*')\n   IF V = 6 THEN VOL6 = LEFT(SERVOL,5,'*')\n   IF V = 7 THEN VOL7 = LEFT(SERVOL,5,'*')\n   IF V = 8 THEN VOL8 = LEFT(SERVOL,5,'*')\nEND\nRETURN\n\n/*     */\nGET_SELECTED_SERVER_VOLUME:\nDO I = 1 TO 8\n   SELVOL = VALUE('RV'I)\n   IF SELVOL = '' THEN ITERATE\n   RESTVOL = RSTVOL.I\n   VOLUME = STRIP(RESTVOL,'T',':')\n   LEAVE\nEND\nRETURN\n\n/*     */\nGET_HISTORY_CONTAINER_DATASETS:\nADDRESS TSO\nDSN = 0\nNWHSTLIB = 'PTECH2.NETCA.'SERVER'.'VOLUME'.H'\nNWDSN = SYSDSN(\"'\"NWHSTLIB\"'\")\nIF NWDSN = 'DATASET NOT FOUND' THEN DO\n   SAY '*** DATASET ERROR: DATASET NOT FOUND FOR ('NWHSTLIB'). ***'\n   SAY '*** NWRESTOR EXEC SUBTASK CANCELLED - RETURN CODE: (028). ***'\n   EXIT 028\nEND\n\"ALLOC DA('\"NWHSTLIB\"') FILE(NWDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('NWHSTLIB'). ***'\n   SAY '*** NWRESTOR EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\n\"EXECIO * DISKR NWDD (FINIS STEM HIST.\"\nSRC = RC\n\"FREE FILE(NWDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** EXECIO READ ERROR: ('NWHSTLIB'). ***'\n   SAY '*** NWRESTOR EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nBUDATE.1 = 'XXXX-XX-XX'\nBUDATE.2 = 'XXXX-XX-XX'\nBUDATE.3 = 'XXXX-XX-XX'\nBUDATE.4 = 'XXXX-XX-XX'\nBUDATE.5 = 'XXXX-XX-XX'\nBUDATE.6 = 'XXXX-XX-XX'\nBUDATE.7 = 'XXXX-XX-XX'\nBUDATE.8 = 'XXXX-XX-XX'\nBUDATE.9 = 'XXXX-XX-XX'\nBUDATE.10 = 'XXXX-XX-XX'\nBUDATE.11 = 'XXXX-XX-XX'\nBUDATE.12 = 'XXXX-XX-XX'\nBUDATE.13 = 'XXXX-XX-XX'\nBUDATE.14 = 'XXXX-XX-XX'\nBUDATE.15 = 'XXXX-XX-XX'\nBUDATE.16 = 'XXXX-XX-XX'\nBUDATE.17 = 'XXXX-XX-XX'\nBUDATE.18 = 'XXXX-XX-XX'\nBUDSN.1 = '--------------------------------------------'\nBUDSN.2 = '--------------------------------------------'\nBUDSN.3 = '--------------------------------------------'\nBUDSN.4 = '--------------------------------------------'\nBUDSN.5 = '--------------------------------------------'\nBUDSN.6 = '--------------------------------------------'\nBUDSN.7 = '--------------------------------------------'\nBUDSN.8 = '--------------------------------------------'\nBUDSN.9 = '--------------------------------------------'\nBUDSN.10 = '--------------------------------------------'\nBUDSN.11 = '--------------------------------------------'\nBUDSN.12 = '--------------------------------------------'\nBUDSN.13 = '--------------------------------------------'\nBUDSN.14 = '--------------------------------------------'\nBUDSN.15 = '--------------------------------------------'\nBUDSN.16 = '--------------------------------------------'\nBUDSN.17 = '--------------------------------------------'\nBUDSN.18 = '--------------------------------------------'\nDO I = 1 TO HIST.0\n   UPPER HIST.I\n   VLOC = POS(VOLKEY,HIST.I)\n   IF VLOC \u00ac= 0 THEN DO\n      BUSTATUS = WORD(HIST.I,9)\n      IF BUSTATUS = 'SSSS' THEN DO\n         BUTYPE = WORD(HIST.I,5)\n         IF BUTYPE = RESTMOD.RM THEN DO\n            DSN = DSN + 1\n            BUDATE.DSN = WORD(HIST.I,1)\n            BUTIME.DSN = WORD(HIST.I,2)\n            L = I + 1\n            UPPER HIST.L\n            HSTDSN = WORD(HIST.L,2)\n            BUDSN.DSN = STRIP(HSTDSN,\"B\",\"'\")\n         END\n      END\n   END\nEND\nRETURN\n\n/*     */\nBUILD_PANEL_DATASET_PARMS:\nDO D = 1 TO GDGCNT\n   IF BUDSN.D = '' THEN ITERATE\n   IF D = 1 THEN DO\n      BUDATE01 = BUDATE.D\n      BUDSN01 = BUDSN.D\n   END\n   IF D = 2 THEN DO\n      BUDATE02 = BUDATE.D\n      BUDSN02 = BUDSN.D\n   END\n   IF D = 3 THEN DO\n      BUDATE03 = BUDATE.D\n      BUDSN03 = BUDSN.D\n   END\n   IF D = 4 THEN DO\n      BUDATE04 = BUDATE.D\n      BUDSN04 = BUDSN.D\n   END\n   IF D = 5 THEN DO\n      BUDATE05 = BUDATE.D\n      BUDSN05 = BUDSN.D\n   END\n   IF D = 6 THEN DO\n      BUDATE06 = BUDATE.D\n      BUDSN06 = BUDSN.D\n   END\n   IF D = 7 THEN DO\n      BUDATE07 = BUDATE.D\n      BUDSN07 = BUDSN.D\n   END\n   IF D = 8 THEN DO\n      BUDATE08 = BUDATE.D\n      BUDSN08 = BUDSN.D\n   END\n   IF D = 9 THEN DO\n      BUDATE09 = BUDATE.D\n      BUDSN09 = BUDSN.D\n   END\n   IF D = 10 THEN DO\n      BUDATE10 = BUDATE.D\n      BUDSN10 = BUDSN.D\n   END\n   IF D = 11 THEN DO\n      BUDATE11 = BUDATE.D\n      BUDSN11 = BUDSN.D\n   END\n   IF D = 12 THEN DO\n      BUDATE12 = BUDATE.D\n      BUDSN12 = BUDSN.D\n   END\n   IF D = 13 THEN DO\n      BUDATE13 = BUDATE.D\n      BUDSN13 = BUDSN.D\n   END\n   IF D = 14 THEN DO\n      BUDATE14 = BUDATE.D\n      BUDSN14 = BUDSN.D\n   END\n   IF D = 15 THEN DO\n      BUDATE15 = BUDATE.D\n      BUDSN15 = BUDSN.D\n   END\n   IF D = 16 THEN DO\n      BUDATE16 = BUDATE.D\n      BUDSN16 = BUDSN.D\n   END\n   IF D = 17 THEN DO\n      BUDATE17 = BUDATE.D\n      BUDSN17 = BUDSN.D\n   END\n   IF D = 18 THEN DO\n      BUDATE18 = BUDATE.D\n      BUDSN18 = BUDSN.D\n   END\nEND\nRETURN\n\n/*     */\nGET_PANEL_INPUT_DATASET:\nDSNSW = 'NO'\nDO I = 1 TO GDGCNT\n   SELDSN = VALUE('RD'I)\n   IF SELDSN = '' THEN ITERATE\n   IF I < 10 THEN DO\n      RESTDAT = VALUE('BUDATE0'I)\n      RESTDSN = VALUE('BUDSN0'I)\n   END\n   IF I >= 10 THEN DO\n      RESTDAT = VALUE('BUDATE'I)\n      RESTDSN = VALUE('BUDSN'I)\n   END\n   IF RESTDSN = '' THEN ITERATE\n   DSNSW = 'YES'\n   LEAVE\nEND\nRETURN\n\n/*     */\nLISTCAT_CONTAINER_DATASET:\nADDRESS TSO\nT = 0\nX = OUTTRAP(\"LSTCAT.\",\"*\",\"CONCAT\")\n\"LISTCAT ENT('\"RESTDSN\"') ALL\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** LISTCAT ERROR: 'RESTDSN'. ***'\n   SAY '*** NWRESTOR EXEC SUBTASK CANCELLED - RC = ('SRC'). ***'\n   EXIT SRC\nEND\nDO L = 1 TO LSTCAT.0\n   VOLKEY = POS(\"VOLSER------------\",LSTCAT.L)\n   IF VOLKEY \u00ac= 0 THEN DO\n      STA = VOLKEY + 18\n      T = T + 1\n      TAPE.T = SUBSTR(LSTCAT.L,STA,6)\n   END\nEND\nTAPECNT = T\nRETURN\n\n/*     */\nBUILD_PANEL_TAPE_VOLSERS:\nDO T = 1 TO TAPECNT\n   IF T = 1 THEN TAPE1 = TAPE.T\n   IF T = 2 THEN TAPE2 = TAPE.T\n   IF T = 3 THEN TAPE3 = TAPE.T\n   IF T = 4 THEN TAPE4 = TAPE.T\n   IF T = 5 THEN TAPE5 = TAPE.T\n   IF T = 6 THEN TAPE6 = TAPE.T\n   IF T = 7 THEN TAPE7 = TAPE.T\n   IF T = 8 THEN TAPE8 = TAPE.T\nEND\nRETURN\n\n/*     */\nBUILD_JOBNAME_PARM:\nJN1 = 'NWR'\nJN2 = SUBSTR(TSOID,5,3)\nDO N = 1 TO 26\n   JN3 = SUBSTR(JSUFFIX,N,1)\n   JOBNAME = JN1||JN2||JN3\n   JOB = SYSDSN(\"'\"CNTLLIB\"(\"JOBNAME\")'\")\n   IF JOB = 'MEMBER NOT FOUND' THEN LEAVE\nEND\nJN = JOBNAME\nRETURN\n\n/*     */\nBUILD_RESTORE_JOB:\n\"DELSTACK\"\nRCDCNT = 36\nDIRPATH = STRIP(RESTDPN,'T','/')\nSTARGET = RESTVOL||DIRPATH\nIF RESTDPN = '*' THEN STARGET = RESTVOL\nJCL.1 = \"//\"JN\"  JOB 5304010530000000,'\"SERVER\" LAN RESTORE',NOTIFY=\"TSOID\",\"\nJCL.2 = \"//             CLASS=S,MSGCLASS=G,MSGLEVEL=(1,1),REGION=6M\"\nJCL.3 = \"/*JOBPARM SYSAFF=SYSB\"\nJCL.4 = \"//RESTORE  EXEC PGM=NUACLIEN\"\nJCL.5 = \"//NETUADD  DD DSN=PTECH3.NETCA.RESTORE.SCRIPT.PARMLIB,DISP=SHR\"\nJCL.6 = \"//SYSPRINT DD SYSOUT=*\"\nJCL.7 = \"//SYSIN DD *\"\nJCL.8 = \"CONNECT RS6000 -SERV \"SERVER\" \"LANID\" \"LANPW\nJCL.9 = \"SET DEBUG LOG SYS:/SICOM/CA/RESTORE/DEBUG.LOG\"\nJCL.10 = \"SET GLOBAL TARGET\" STARGET\nJCL.11 = \"SET GLOBAL OPTIONS -LOG SYS:/SICOM/CA/DB/RESTORE.RPT\"\nJCL.12 = \"INPUT 'SYSS.NETCA.LAN.MVSNW.UA'\"\nJCL.13 = \"INPUT DD:NETUADD(\"SMEMB\")\"\nJCL.14 = \"EXIT\"\nJCL.15 = \"/*\"\nJCL.16 = \"//WRITELOG EXEC PGM=IKJEFT01,DYNAMNBR=30,\"\nJCL.17 = \"//   PARM='%NWRSTLOG \"JMEMB\"',COND=(0,LT,RESTORE)\"\nJCL.18 = \"//SYSPRINT DD SYSOUT=*\"\nJCL.19 = \"//SYSTSPRT DD SYSOUT=*\"\nJCL.20 = \"//SYSIN    DD DUMMY\"\nJCL.21 = \"//SYSLBC   DD DSN=SYS1.BRODCAST,DISP=SHR\"\nJCL.22 = \"//SYSUADS  DD DSN=SYS1.UADS,DISP=SHR\"\nJCL.23 = \"//SYSPROC  DD DSN=SYSS.TECH.COMMON.EXECLIB,DISP=SHR\"\nJCL.24 = \"//SYSTSIN  DD DUMMY\"\nJCL.25 = \"/*\"\nJCL.26 = \"//DELETE   EXEC PGM=IDCAMS\"\nJCL.27 = \"//CNTLDD   DD DSN=\"CNTLLIB\",DISP=SHR\"\nJCL.28 = \"//SCRIPTDD DD DSN=\"SCRIPTLIB\",DISP=SHR\"\nJCL.29 = \"//SYSPRINT DD SYSOUT=*\"\nJCL.30 = \"//SYSIN    DD *\"\nJCL.31 = \"  DELETE   \"SCRIPTLIB\"(\"SMEMB\")  FILE(SCRIPTDD)\"\nJCL.32 = \"  DELETE   \"CNTLLIB\"(\"JMEMB\")  FILE(CNTLDD)\"\nJCL.33 = \"  DELETE   \"CNTLLIB\"(\"RMEMB\")  FILE(CNTLDD)\"\nJCL.34 = \"  DELETE   \"CNTLLIB\"(\"JOBNAME\")  FILE(CNTLDD)\"\nJCL.35 = \"/*\"\nJCL.36 = \"//\"\nDO J = 1 TO RCDCNT\n   QUEUE JCL.J\nEND\nRETURN\n\n/*     */\nBUILD_RESTORE_PARMS:\n\"DELSTACK\"\nRESTDSN = \"'\"||RESTDSN||\"'\"\nRESTPRM = '\"'||RESTDPN||RESTFN||' -PDT ON -REP ON\"'\nIF RESTYPE.RT = 'FILE' THEN DO\n   RECORD1 = 'CA_RESTORE 'RESTMOD.RM' 'RESTDSN' 'RESTVOL' -'\n   QUEUE RECORD1\n   RECORD2 = '   '||RESTPRM\n   QUEUE RECORD2\nEND\nIF RESTYPE.RT = 'DRCT' THEN DO\n   RESTPRM = '\"'||RESTDPN'*.* -PDT ON -REP ON\"'\n   RECORD1 = 'CA_RESTORE 'RESTMOD.RM' 'RESTDSN' 'RESTVOL' -'\n   QUEUE RECORD1\n   RECORD2 = '   '||RESTPRM\n   QUEUE RECORD2\nEND\nIF RESTYPE.RT = 'VOL' THEN DO\n   RECORD = 'CA_RESTORE 'RESTMOD.RM' 'RESTDSN' 'RESTVOL' -'\n   QUEUE RECORD\n   RECORD2 = '    \"/* -PDT ON REP ON\"'\n   QUEUE RECORD2\nEND\nRETURN\n\n/*     */\nWRITE_PDS_MEMBER:\nADDRESS TSO\n\"ALLOC DA('\"OUTPDS\"(\"OUTMEMB\")') FILE(NWDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('OUTPDS'('OUTMEMB'). ***'\n   SAY '*** NWRESTOR EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nNUMRCDS = QUEUED()\n\"EXECIO\" NUMRCDS \"DISKW NWDD (FINIS\"\nSRC = RC\n\"FREE FILE(NWDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** WRITE ERROR: ERROR WRITING 'OUTPDS'('OUTMEMB'). ***'\n   SAY '*** NWRESTOR EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nRETURN\n\n/*     */\nSUBMIT_RESTORE_JOB:\nADDRESS TSO\n\"SUBMIT ('\"SUBPDS\"(\"RMEMB\")')\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** SUBMIT ERROR: MEMBER ( 'SUBPDS'('RMEMB'). ***'\n   SAY '*** NWRESTOR EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LAMXCEPT": {"ttr": 13572, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x91\\x16\\x8f\\x00\\x91\\x16\\x8f\\x164\\x00\\x11\\x00\\x11\\x00\\x00\\xd1\\xc5\\xc6\\xc6\\xd2@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1991-06-17T00:00:00", "modifydate": "1991-06-17T16:34:00", "lines": 17, "newlines": 17, "modlines": 0, "user": "JEFFK"}, "text": "/* REXX Activate/deactivate SUBSYS=LAM intercept */\nparse upper arg what_to_do;\nif what_to_do \u00ac= \"ON\" & what_to_do \u00ac= \"OFF\" then do;\n      say \"Invalid invocation of LAMXCEPT.\";\n      exit 4;\n      end;\nselect;\n   when what_to_do = \"ON\" then ,\n          address \"TSO\" \"ALLOCATE F(LAMXCEPT) DUMMY\";\n   when what_to_do = \"OFF\" then ,\n          address \"TSO\" \"FREE F(LAMXCEPT)\";\n   otherwise do;\n      say \"Invalid invocation of LAMXCEPT.\";\n      exit 8;\n      end;\nend;\nexit 0;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LBBROWSE": {"ttr": 13574, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00\\x00\\x00\\x91\\x16\\x1f\\x00\\x91\\x16/\\x15\\x01\\x00\\x0f\\x00\\x07\\x00\\t\\xd1\\xc5\\xc6\\xc6\\xd2@@@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "1991-06-10T00:00:00", "modifydate": "1991-06-11T15:01:00", "lines": 15, "newlines": 7, "modlines": 9, "user": "JEFFK"}, "text": "/* REXX SYS1.TECH.COMMON.EXECLIB Browse Librarian master file */\nparse upper arg libdsn; /* acquire Librarian master file name */\nlibdsn = translate(libdsn,\"'\",'\"'); /* no double quot */\nif substr(libdsn,1,1)\u00ac=\"'\" then do;\n     libdsn = \"'BUILDING.PRODJCL.MASTER(\"libdsn\")'\";\n     end;\nparse var libdsn \"'\" dsname \"(\" member \")'\"; /* Breakout dsn */\nif dsname = \"\" | member = \"\" then do;\n     say \"Invalid LIBRARIAN master file / member name specified\";\n     exit 0;\n     end;\naddress \"ISPEXEC\";\n\"VPUT LIBDSN SHARED\"; /* Save for initial macro */\n\"EDIT DATASET('\"userid()\".USER.CNTLLIB(\"member\")') MACRO(@LBROWSE)\";\nexit 0;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LBCLOSE": {"ttr": 13576, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x08\\x00\\x00\\x00\\x92\\t\\x8f\\x00\\x94\\x06?\\x14A\\x01U\\x015\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf3@@@'", "ispf": {"version": "01.08", "flags": 0, "createdate": "1992-04-07T00:00:00", "modifydate": "1994-03-04T14:41:00", "lines": 341, "newlines": 309, "modlines": 0, "user": "TECH103"}, "text": "/* This REXX EXEC is designed to facilitate the CA-LIBRARIAN LIB/CCF\n   CLOSE function for a opened CR/WO that has completed the turnover\n   cycle into the PROD libraries.                   */\n\nTRACE O\n/*     */\nHOUSE_KEEPING:\nADDRESS TSO\nTSOID = SYSVAR(SYSUID)\nSYST1 = 'NONE'\nINPT1 = 'NONE'\nOUPT1 = 'NONE'\nDOCC1 = 'NONE'\nWCNT = 0\nRCDCNT = 0\nX = MSG(\"OFF\")\nDSN = SYSDSN(\"DIALOG.ISPFILE\")\nIF DSN = 'OK' THEN DO\n   \"FREE DA(DIALOG.ISPFILE)\"\n   SIGNAL DISPLAY_USER_ANALYSIS_PANEL\nEND\nCALL ALLOC_ISPFILE\n\"FREE DA(DIALOG.ISPFILE)\"\n\n/*     */\nDISPLAY_USER_ANALYSIS_PANEL:\nADDRESS ISPEXEC\n\"CONTROL ERRORS RETURN\"\nDO FOREVER\n   \"DISPLAY PANEL(LBCLOSE1)\"\n   SRC = RC\n   IF SRC = 0 THEN LEAVE\n   IF SRC = 8 THEN LEAVE\n   IF SRC > 8 THEN DO\n      SAY '*** PANEL ERROR: ISPF DIALOG ERROR INVOKING PANEL ( LBCLOSE1 ). ***'\n      SAY '*** LBCLOSE EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n      EXIT\n   END\nEND\nIF CCFUSER = '' | WORKORDR = '' | ANAL1 = '' THEN DO\n     SAY '*** REQUIRED DATA NOT SUPPLIED - LBCLOSE EXEC TASK TERMINATED. ***'\n     EXIT\nEND\nWO = WORKORDR\nMEM = WORKORDR\n\n/*     */\nDISPLAY_MODULE_AFFECTED_PANEL:\nDO FOREVER\n   \"DISPLAY PANEL(LBCLOSE2)\"\n   SRC = RC\n   IF SRC = 0 THEN LEAVE\n   IF SRC = 8 THEN LEAVE\n   IF SRC > 8 THEN DO\n      \"FREE F(ISPFILE)\"\n      SAY '*** PANEL ERROR: ISPF DIALOG ERROR INVOKING PANEL ( LBCLOSE2 ). ***'\n      SAY '*** LBCLOSE EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n      EXIT\n   END\nEND\nIF AFFT1 = '' | MODDATE = '' | VERDATE = '' THEN DO\n     \"FREE F(ISPFILE)\"\n     SAY '*** REQUIRED DATA NOT SUPPLIED - LBCLOSE EXEC TASK TERMINATED. ***'\n     EXIT\nEND\n\n/*     */\nDISPLAY_DOCLIST_PANEL:\nDO FOREVER\n   \"DISPLAY PANEL(LBCLOSE3)\"\n   SRC = RC\n   IF SRC = 0 THEN LEAVE\n   IF SRC = 8 THEN LEAVE\n   IF SRC > 8 THEN DO\n      \"FREE F(ISPFILE)\"\n      SAY '*** PANEL ERROR: ISPF DIALOG ERROR INVOKING PANEL ( LBCLOSE3 ). ***'\n      SAY '*** LBCLOSE EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n      EXIT\n   END\nEND\nIF SYST1 = '' THEN SYST1 = 'NONE'\nIF INPT1 = '' THEN INPT1 = 'NONE'\nIF OUPT1 = '' THEN OUPT1 = 'NONE'\nIF DOCC1 = '' THEN DOCC1 = 'NONE'\n\n/*     */\nBUILD_JOBSTREAM:\nADDRESS TSO\n\"DELSTACK\"\n\"FREE FILE(ISPFILE)\"\n\"ALLOC DA(DIALOG.ISPFILE(\"WORKORDR\")) F(ISPFILE) OLD\"\nCALL BUILD_JOB_JCL\nCALL BUILD_MODULE_ANALYSIS_RECORDS\nCALL BUILD_MODULE_AFFECTED_RECORDS\nCALL BUILD_SYSTLIST_RECORDS\nCALL BUILD_INPTLIST_RECORDS\nCALL BUILD_OUPTLIST_RECORDS\nCALL BUILD_DOCCLIST_RECORDS\nCALL BUILD_END_RECORDS\nCALL WRITE_LBCLOSE_RECORDS\nIF SRC \u00ac= 0 THEN CALL WRITE_LBCLOSE_RECORDS\nCALL SUBMIT_LBCLOSE_JOB\nADDRESS TSO\n\"ALLOC DA(DIALOG.ISPFILE F(ISPFILE) SHR\"\n\"DELETE (DIALOG.ISPFILE) SCRATCH PURGE NONVSAM FILE(ISPFILE)\"\n\"FREE F(ISPFILE)\"\nSAY '+++++++++++++++++++++++++++++++++++++++++++++++++++'\nSAY '+++ LBCLOSE EXEC TASK COMPLETE - JOB SUBMITTED. +++'\nSAY '+++++++++++++++++++++++++++++++++++++++++++++++++++'\nEXIT\n\n/*     S U B R O U T I N E S   S E C T I O N     */\n\n/*     */\nBUILD_JOB_JCL:\nR = 7\nRCD.1 = \"//\"WO\" JOB 5302010530000000,'LIBCCF.BATCH.CLOSE',NOTIFY=\"TSOID\",\"\nRCD.2 = \"//             CLASS=P,MSGCLASS=S,MSGLEVEL=(1,1),REGION=1024K\"\nRCD.3 = \"//CCFUTIL    EXEC PGM=$CCFB104,PARM=COND\"\nRCD.4 = \"//CCFPRINT   DD SYSOUT=*\"\nRCD.5 = \"-USER\" CCFUSER\nRCD.6 = \"-SYSM\" MODDATE\nRCD.7 = \"-SYSV\" VERDATE\nCALL QUEUE_RECORDS\nRETURN\n\n/*     */\nBUILD_MODULE_ANALYSIS_RECORDS:\nN = 0\nR = 0\nCCFCNT = 0\nADDRESS TSO\nANAL.1 = ANAL1\nANAL.2 = ANAL2\nANAL.3 = ANAL3\nANAL.4 = ANAL4\nANAL.5 = ANAL5\nANAL.6 = ANAL6\nANAL.7 = ANAL7\nANAL.8 = ANAL8\nANAL.9 = ANAL9\nANAL.10 = ANAL10\nANAL.11 = ANAL11\nANAL.12 = ANAL12\nDO 12\n   N = N + 1\n   IF ANAL.N = '' THEN ITERATE\n   CCFCNT = CCFCNT + 1\nEND\nDO CCFCNT\n   R = R + 1\n   RCD.R = \"-ANAL\" ANAL.R\nEND\nCALL QUEUE_RECORDS\nRETURN\n\n/*     */\nBUILD_MODULE_AFFECTED_RECORDS:\nN = 0\nR = 0\nCCFCNT = 0\nADDRESS TSO\nAFFT.1 = AFFT1\nAFFT.2 = AFFT2\nAFFT.3 = AFFT3\nAFFT.4 = AFFT4\nAFFT.5 = AFFT5\nAFFT.6 = AFFT6\nAFFT.7 = AFFT7\nAFFT.8 = AFFT8\nAFFT.9 = AFFT9\nAFFT.10 = AFFT10\nAFFT.11 = AFFT11\nAFFT.12 = AFFT12\nAFFT.13 = AFFT13\nAFFT.14 = AFFT14\nAFFT.15 = AFFT15\nDO 15\n   N = N + 1\n   IF AFFT.N = '' THEN ITERATE\n   CCFCNT = CCFCNT + 1\nEND\nDO CCFCNT\n   R = R + 1\n   RCD.R = \"-AFFT\" AFFT.R\nEND\nCALL QUEUE_RECORDS\nRETURN\n\n/*     */\nBUILD_SYSTLIST_RECORDS:\nN = 0\nR = 0\nCCFCNT = 0\nADDRESS TSO\nSYST.1 = SYST1\nSYST.2 = SYST2\nSYST.3 = SYST3\nDO 3\n   N = N + 1\n   IF SYST.N = '' THEN ITERATE\n   CCFCNT = CCFCNT + 1\nEND\nDO CCFCNT\n   R = R + 1\n   RCD.R = \"-SYST\" SYST.R\nEND\nCALL QUEUE_RECORDS\nRETURN\n\n/*     */\nBUILD_INPTLIST_RECORDS:\nN = 0\nR = 0\nCCFCNT = 0\nADDRESS TSO\nINPT.1 = INPT1\nINPT.2 = INPT2\nINPT.3 = INPT3\nDO 3\n   N = N + 1\n   IF INPT.N = '' THEN ITERATE\n   CCFCNT = CCFCNT + 1\nEND\nDO CCFCNT\n   R = R + 1\n   RCD.R = \"-INPT\" INPT.R\nEND\nCALL QUEUE_RECORDS\nRETURN\n\n/*     */\nBUILD_OUPTLIST_RECORDS:\nN = 0\nR = 0\nCCFCNT = 0\nADDRESS TSO\nOUPT.1 = OUPT1\nOUPT.2 = OUPT2\nOUPT.3 = OUPT3\nDO 3\n   N = N + 1\n   IF OUPT.N = '' THEN ITERATE\n   CCFCNT = CCFCNT + 1\nEND\nDO CCFCNT\n   R = R + 1\n   RCD.R = \"-OUPT\" OUPT.R\nEND\nCALL QUEUE_RECORDS\nRETURN\n\n/*     */\nBUILD_DOCCLIST_RECORDS:\nN = 0\nR = 0\nCCFCNT = 0\nADDRESS TSO\nDOCC.1 = DOCC1\nDOCC.2 = DOCC2\nDOCC.3 = DOCC3\nDO 3\n   N = N + 1\n   IF DOCC.N = '' THEN ITERATE\n   CCFCNT = CCFCNT + 1\nEND\nDO CCFCNT\n   R = R + 1\n   RCD.R = \"-DOCC\" DOCC.R\nEND\nCALL QUEUE_RECORDS\nRETURN\n\n/*     */\nBUILD_END_RECORDS:\nR = 5\nRCD.1 = \"-CLOSE\" WORKORDR\nRCD.2 = \"-EMOD\"\nRCD.3 = \"-END\"\nRCD.4 = \"/*\"\nRCD.5 = \"//\"\nCALL QUEUE_RECORDS\nRETURN\n\n/*     */\nQUEUE_RECORDS:\nRCNT = R\nRCDCNT = RCDCNT + R\nR = 0\nDO RCNT\n   R = R + 1\n   QUEUE RCD.R\nEND\nRETURN\n\n/*     */\nWRITE_LBCLOSE_RECORDS:\n\"EXECIO\" RCDCNT \"DISKW ISPFILE (FINIS\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   WCNT = WCNT + 1\n   IF WCNT > 1 THEN DO\n      SAY '*** EXECIO WRITE ERROR: ( 'TSOID'.DIALOG.ISPFILE('MEM'). ***'\n      SAY '*** LBCLOSE EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n      \"FREE F(ISPFILE)\"\n      \"DELETE (DIALOG.ISPFILE) SCRATCH PURGE NONVSAM\"\n      EXIT\n   END\n   SAY '*** EXECIO WRITE ERROR: ( 'TSOID'.DIALOG.ISPFILE('MEM'). ***'\n   SAY '+++ DATASET WILL BE DELETED AND RE-ALLOCATED - ATTEMPT RE-WRITE. +++'\n   \"FREE F(ISPFILE)\"\n   \"DELETE (DIALOG.ISPFILE) SCRATCH PURGE NONVSAM\"\n   CALL ALLOC_ISPFILE\n   \"FREE FILE(ISPFILE)\"\n   \"ALLOC DA(DIALOG.ISPFILE(\"WORKORDR\")') F(ISPFILE) OLD\"\nEND\nRETURN\n\n/*     */\nALLOC_ISPFILE:\n\"ALLOC DA(DIALOG.ISPFILE) LIKE(USER.CNTLLIB) NEW SPACE(2,0) DIR(15) CYLINDERS\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** ALLOCATE ERROR: ERROR ALLOCATING TEMP ISPFILE DATASET. ***'\n   SAY '*** LBCLOSE EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   \"DELETE (DIALOG.ISPFILE) SCRATCH PURGE NONVSAM\"\n   EXIT\nEND\nRETURN\n\n/*     */\nSUBMIT_LBCLOSE_JOB:\n\"SUBMIT '\"TSOID\".DIALOG.ISPFILE(\"WORKORDR\")'\"\nSRC = RC\n\"FREE F(ISPFILE)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** SUBMIT ERROR: MEMBER ( 'TSOID'.DIALOG.ISPFILE('MEM'). ***'\n   SAY '*** LBCLOSE EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT\nEND\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LBCOMPAR": {"ttr": 13582, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\x00\\x00\\x91\\x10\\x1f\\x00\\x910_\\x15\"\\x00[\\x00r\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf3@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "1991-04-11T00:00:00", "modifydate": "1991-11-01T15:22:00", "lines": 91, "newlines": 114, "modlines": 0, "user": "TECH103"}, "text": "/* This REXX EXEC is designed to facilitate the CA-LIBRARIAN member\n   compare of librarian modules residing in the TURNOVER pre-QA master\n   to the current arc level0 member in the PROD master.              */\n\nTRACE O\n/*     */\nHOUSE_KEEPING:\nADDRESS TSO\nTSOID = SYSVAR(SYSUID)\nACCTCDE = 5300010530000000\nJOBNAME = 'LBCOMPAR'\nSAVEMEMB= 'NULLMEMB'\nLIBTEST.1 = 'SYS1.QACOPY.MASTER'\nLIBTEST.2 = 'SYS1.QAJCL.MASTER'\nLIBTEST.3 = 'SYS1.QAPROC.MASTER'\nLIBTEST.4 = 'SYS1.QARAMI.MASTER'\nLIBTEST.5 = 'SYS1.QASRCE.MASTER'\nLIBTEST.6 = 'SYS1.QASYSI.MASTER'\nLIBPROD.1 = 'SYS1.PRODCOPY.MASTER'\nLIBPROD.2 = 'SYS1.PRODJCL.MASTER'\nLIBPROD.3 = 'SYS1.PRODPROC.MASTER'\nLIBPROD.4 = 'SYS1.PRODRAMI.MASTER'\nLIBPROD.5 = 'SYS1.PRODSRCE.MASTER'\nLIBPROD.6 = 'SYS1.PRODSYSI.MASTER'\nADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\nADDRESS ISPEXEC \"FTCLOSE\"\n\n/*     */\nDISPLAY_PANEL:\nDO FOREVER\n   ADDRESS ISPEXEC \"DISPLAY PANEL(LBCOMPAR)\"\n   SRC = RC\n   IF SRC = 0 THEN CALL GET_LBCOMPARE_PARMS\n   IF SRC = 8 THEN LEAVE\n   IF SRC > 8 THEN DO\n      SAY '*** ERROR INVOKING ISPF DIALOG PANEL LBCOMPAR - RC = 'SRC'.***'\n      EXIT SRC\n   END\n   IF MEMBER = '' |  M = '' THEN ITERATE\n   IF MEMBER = SAVEMEMB & M = SAVELIB THEN EXIT\n   CALL SUBMIT_LBCOMPARE_JOB\nEND\nEXIT\n\n/*     */\nGET_LBCOMPARE_PARMS:\nSYSUT1 = LIBPROD.M\nSYSUT2 = LIBTEST.M\nRETURN\n\n/*     */\nSUBMIT_LBCOMPARE_JOB:\nSAVEMEMB = MEMBER\nSAVELIB = M\nADDRESS ISPEXEC \"FTOPEN TEMP\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   ZERRMSG = LBCOM001\n   ADDRESS ISPEXEC \"SETMSG MSG(LBCOM001)\"\n   RETURN\n   END\nADDRESS ISPEXEC \"FTINCL LBCMPJOB\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   ZERRMSG = LBCOM002\n   ADDRESS ISPEXEC \"SETMSG MSG(LBCOM002)\"\n   RETURN\n   END\nADDRESS ISPEXEC \"FTINCL LBCOMPAR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   ZERRMSG = LBCOM003\n   ADDRESS ISPEXEC \"SETMSG MSG(LBCOM003)\"\n   RETURN\n   END\nADDRESS ISPEXEC \"FTCLOSE\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   ZERRMSG = LBCOM004\n   RETURN\n   END\nADDRESS ISPEXEC \"VGET ZTEMPF\"\nADDRESS TSO \"SUBMIT '\"ZTEMPF\"'\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   ZERRMSG = LBCOM005\n   RETURN\n   END\nZERRMSG = LBCOM000\nADDRESS ISPEXEC \"SETMSG MSG(LBCOM000)\"\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LBEXPAND": {"ttr": 13825, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x1a\\x00\\x00\\x00\\x91\\x15\\x8f\\x00\\x915\\x1f\\x17\\x17\\x008\\x00\\x0b\\x006\\xe3\\xc5\\xc3\\xc8\\xf1\\xf1\\xf0@@@'", "ispf": {"version": "01.26", "flags": 0, "createdate": "1991-06-07T00:00:00", "modifydate": "1991-12-17T17:17:00", "lines": 56, "newlines": 11, "modlines": 54, "user": "TECH110"}, "text": "/* REXX LBEXPAND LAM Support  */\naddress \"ISPEXEC\";\n\"ISREDIT MACRO (TYPEEXP)\";\nupper typeexp;\n\"ISREDIT (CURLINE,CURCOL) = CURSOR\"; /* do full xpnd if cursr at top */\nif typeexp=\"\" & curline\u00ac=0 & curcol \u00ac=0 then do; /* 1 line expand onl*/\n    \"ISREDIT LIBEXPND\"; /* perform expansion */\n    exit 0;\n    end;\nif typeexp\u00ac=\"DSN\" & typeexp\u00ac=\"PROC\" then do; /* invalid param */\n         zedsmsg = \"INVPRM?\";\n         zedlmsg = \"Invalid parameter; DSN or PROC\";\n         \"SETMSG MSG(ISRZ001)\";\n         exit 4;\n         end;\n\"ISREDIT (TOP) = LINENUM .ZFIRST\"; /* Top */\n\"ISREDIT (BOTTOM) = LINENUM .ZLAST\"; /* Bottom */\nif typeexp = \"PROC\" then do;\n  do curline = bottom to top by -1; /* loop backwards */\n    \"ISREDIT (LINEDATA) = LINE\" curline; /* Get data line */\n    if substr(linedata,1,2) \u00ac= \"//\" then iterate; /*data*/\n    if substr(linedata,3,1) = \"*\" then iterate; /* comment */\n    if pos(\" EXEC \",linedata)=0 then iterate; /*execonly */\n    if pos(\"PGM=\",linedata)\u00ac=0 then iterate;\n    \"ISREDIT CURSOR =\" curline; /* reset line ptr */\n    \"ISREDIT LIBEXPND\"; /* perform expansion */\n   end; /* end proc do loop */\n     end; /* proc end */\n/* dsn processing */\ndslist = \"BUILDING.PRODSYSI.MASTER\" ,\n         \"BUILDING.PRODRAMI.MASTER\" ,\n         \"BUILDING.EMRGSYSI.MASTER\" ,\n         \"BUILDING.EMRGRAMI.MASTER\" ,\n         \"SYS1.PRODSYSI.MASTER\" ,\n         \"SYS1.PRODRAMI.MASTER\" ,\n         \"SYS1.EMRGSYSI.MASTER\" ,\n         \"SYS1.EMRGRAMI.MASTER\" ,\n         \"CICS.VSAM.MASTER\" ,\n         \"PD.BATCH.VSAM.MASTER\";\ndo curline = bottom to top by -1; /* loop backwards */\n    \"ISREDIT (LINEDATA) = LINE\" curline; /* Get data line */\n    if substr(linedata,1,2) \u00ac= \"//\" then iterate; /*data*/\n    if substr(linedata,3,1) = \"*\" then iterate; /* comment */\n    if pos(\" DD \",linedata)=0 then iterate; /* DD only */\n    if pos(\"DSN=\",linedata)=0 & pos(\"DSNAME=\",linedata)=0 then iterate;\n    if pos(\"DSN=\",linedata)\u00ac=0 then ,\n        parse var linedata . \"DSN=\" dsname \"(\" member \")\" . ;\n     else ,\n        parse var linedata . \"DSNAME=\" dsname \"(\" member \")\" . ;\n    if member = \"\" then iterate;\n    if wordpos(dsname,dslist)=0 then iterate; /* not dsname */\n    \"ISREDIT CURSOR =\" curline; /* reset line ptr */\n    \"ISREDIT LIBEXPND\"; /* perform expansion */\nend;\n\"ISREDIT CURSOR = 1\"; /* reset line ptr */\nexit 1; /* reset to screen top */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LBFETCH": {"ttr": 13827, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x1a\\x00\\x00\\x00\\x91\\x15\\x7f\\x00\\x915\\x1f\\x17 \\x00A\\x00\\x06\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf1\\xf0@@@'", "ispf": {"version": "01.26", "flags": 0, "createdate": "1991-06-06T00:00:00", "modifydate": "1991-12-17T17:20:00", "lines": 65, "newlines": 6, "modlines": 0, "user": "TECH110"}, "text": "/* REXX LIBFETCH LAM Support */\naddress \"ISPEXEC\";\n\"ISREDIT MACRO (LIBDSN) NOPROCESS\"; /* Trap 'A' and 'B' line cmds*/\nupper libdsn;\nif libdsn = \"\" then do;\n      zedsmsg = \"LIBDSN?\";\n      zedlmsg = \"Re-enter LIBFETCH with Librarian master filename\"|| ,\n            \" and member name\";\n      \"SETMSG MSG(ISRZ001)\";\n      exit 4;\n      end;\nif substr(libdsn,1,9)=\"BUILDING.\" then do;\n     parse var libdsn . \".\" rdsn;\n     libdsn = \"SYS1.\"rdsn;\n     end;\nif substr(libdsn,1,10)=\"'BUILDING.\" then do;\n     parse var libdsn . \".\" rdsn;\n     libdsn = \"'SYS1.\"rdsn;\n     end;\n\"ISREDIT PROCESS DEST\";\nddname = liballoc(LIBDSN); /* Dynalloc libmaster w/lam; ret ddname*/\nif ddname = \"ERROR\" then do;\n      zedsmsg = \"LIBDSN?\";\n      zedlmsg = \"Invalid Librarian master filename\";\n      \"SETMSG MSG(ISRZ001)\";\n      exit 4;\n      end;\nparse var libdsn \"'\" bldldsn \"(\" bldlmem \")'\" . ;\nif bldlmem = \"\" then do;\n      zedsmsg = \"MEMBER?\";\n      zedlmsg = \"Invalid Librarian member name\";\n      \"SETMSG MSG(ISRZ001)\";\n      exit 4;\n      end;\nbldddn = liballoc(\"'\"bldldsn\"'\"); /*Dynal libmast w/lam; ret ddname*/\nif bldddn = \"ERROR\" then do;\n      zedsmsg = \"LIBDSN?\";\n      zedlmsg = \"Invalid Librarian master filename\";\n      \"SETMSG MSG(ISRZ001)\";\n      exit 4;\n      end;\nbldldir = xlibemem(bldddn,bldlmem); /* fetch dir entry */\nif bldldir = \"\"  then do;\n      zedsmsg = \"MEMBER?\";\n      zedlmsg = \"Invalid Librarian member name\";\n      \"SETMSG MSG(ISRZ001)\";\n      exit 4;\n      end;\nmsg_status = MSG(\"OFF\");\naddress \"TSO\" \"EXECIO * DISKR\" ddname \"(STEM LIBFETCH. FINIS\";\nsaverc = rc;\nmsg_status = MSG(\"ON\");\nif saverc \u00ac= 0 then do;\n      zedsmsg = \"MEMBER?\";\n      zedlmsg = \"Invalid Librarian member name\";\n      \"SETMSG MSG(ISRZ001)\";\n      exit 4;\n      end;\n\"ISREDIT (CURLINE) = LINENUM .ZDEST\";\ndo i = 1 to libfetch.0;\n   libfetch.i = translate(libfetch.i,\"'\",'\"'); /* no double quotes*/\n   dataline = libfetch.i;\n   \"ISREDIT LINE_AFTER\" CURLINE+i-1 '= (DATALINE)';\nend;\nexit 0;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LBHSTUPD": {"ttr": 13829, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01!\\x00\\x00\\x00\\x935\\x0f\\x00\\x936/\\x15P\\x01_\\x00\\xf5\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf3@@@'", "ispf": {"version": "01.33", "flags": 0, "createdate": "1993-12-16T00:00:00", "modifydate": "1993-12-28T15:50:00", "lines": 351, "newlines": 245, "modlines": 0, "user": "TECH103"}, "text": "/*    REXX EXEC : ( LBHSTUPD )\n      FUNCTION  : ALLOWS CA-LIBRARIAN HISTORY DATASET MEMBER UPDATE FOR\n                  A SPECIFIED WORKORDER NUMBER SELECTED RECORD ENTRIES.\n                                                                      */\nTRACE O\n/*      */\nHOUSE_KEEPING:\nADDRESS ISPEXEC\nX = MSG(\"OFF\")\nLIBNODES = 'HISTCOPY HISTJCL HISTPROC HISTRAMI HISTSRCE HISTSYSI'\nACCTCCF = 5200010520000000\nENDWO = '  CR:  WO'\nUTIREP = 'YES'\nVPUTSW = 'NO'\nCOPYSW = 'NO'\nMNTSW = 'NO'\nEXITSW = 'NO'\nTSOID = SYSVAR(SYSUID)\nJDATE = DATE(J)\nCDATE = DATE(U)\nCTIME = TIME()\nJMEMBER = 'H'JDATE\nSKELJCL = 'LBHSTJCL'\n\"VGET (ACCTCDE) PROFILE\"\nIF RC \u00ac= 0 THEN ACCTCDE = ACCTCCF\n/* *** \"VPUT (UTIREP) PROFILE\"\nIF RC = 0 THEN VPUTSW = 'YES'     *** */\nOUTPDS = 'SYSS.TESTCCF.HISTORY.CNTLLIB'\nJOURDSN = 'SYSS.TESTCCF.JOURNAL.CNTLLIB'\n\n/*     M A I N   R O U T I N E   S E C T I O N     */\n/*     */\nMAIN_ROUTINE:\nADDRESS TSO\nCALL WRITE_AUTHPARM\nCALL DISPLAY_HISTORY_PARMS_PANEL\nIF SRC >= 8 THEN DO\n   CALL DELETE_PDS_MEMBER\n   EXIT SRC\nEND\nCALL READ_HISTORY_MODULE\nCALL EXTRACT_WORKORDER_HISTORY_RECORDS\nCALL BUILD_SCREEN_DATA\nCALL DISPLAY_HISTORY_DATA_PANEL\nIF SRC >= 8 THEN DO\n   CALL DELETE_PDS_MEMBER\n   EXIT SRC\nEND\nCALL BUILD_HISTORY_UPDATE_RECORDS\nIF UPDCNT = DATACNT THEN CALL COMPARE_HISTORY_DATA\nIF EXITSW = 'YES' THEN DO\n   CALL DELETE_PDS_MEMBER\n   EXIT 0\nEND\nCALL QUEUE_ENDING_HISTORY_RECORDS\nCALL WRITE_HISTORY_PDS_MEMBER\n/*   ***   N O O P\nIF VPUTSW = 'YES' THEN CALL COPY_MEMBER_TO_HISTORY_MASTER\nIF COPYSW = 'NO' THEN CALL BUILD_SUBMIT_LIBREP_JOB\n                                                             *** */\nCALL BUILD_SUBMIT_LIBREP_JOB\nCALL ALLOC_JOURNAL_DATASET\nINTERPRET CALL LABEL\nMNTSW = 'YES'\nCALL DELETE_PDS_MEMBER\nEXIT 0\n\n/*     S U B R O U T I N E   S E C T I O N     */\n/*     */\nWRITE_AUTHPARM:\nADDRESS TSO\n\"ALLOC DA('\"OUTPDS\"(\"TSOID\")') FILE(ECRDD) SHR\"\nQUEUE TSOID JDATE\n\"EXECIO 1 DISKW ECRDD (FINIS\"\nSRC = RC\n\"FREE FILE(ECRDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** EXECIO WRITE ERROR: RETURN CODE: ('SRC'). ***'\n   SAY '*** ERROR WRITING ('OUTPDS') PARM MEMBER. ***'\n   SAY '*** LHISTORY EXEC SUBTASK CANCELLED. ***'\n   EXIT SRC\nEND\nRETURN\n/*     */\nDISPLAY_HISTORY_PARMS_PANEL:\nADDRESS ISPEXEC\n\"CONTROL ERRORS RETURN\"\n\"DISPLAY PANEL(LBHSTPN1)\"\nSRC = RC\nIF SRC = 8 THEN RETURN\nIF SRC > 8 THEN DO\n   SAY '*** ERROR INVOKING ISPF DIALOG PANEL ( LBHSTPN1 ). ***'\n   SAY '*** LHISTORY EXEC MAINTASK CANCELLED - RC = 'SRC'. ***'\n   RETURN\nEND\nHISTNODE = WORD(LIBNODES,LIB)\nFROMDSN = 'SYS1.'HISTNODE'.MASTER'\nMASTER = 'SYS1.'HISTNODE'.MASTER'\nKEYDATA = '  CR:  'WORKORDR\nRETURN\n/*     */\nREAD_HISTORY_MODULE:\nADDRESS TSO\nLIBDSN = \"'\"MASTER\"(\"MEMBER\")'\"\nLIBDD = LIBALLOC(LIBDSN)  /* DYNALLOC LIBMASTER W/LAM; RET DDNAME*/\nIF LIBDD = \"ERROR\" THEN DO\n   SRC = 100\n   SAY '*** DYNAMIC ALLOCATION ERROR: RETURN CODE ('SRC'). ***'\n   SAY '*** ERROR ALLOCATING ('MASTER'('MEMBER'). ***'\n   SAY '*** LHISTORY EXEC SUBTASK CANCELLED. ***'\n   CALL DELETE_PDS_MEMBER\n   EXIT SRC\nEND\n\"EXECIO * DISKR\" LIBDD \"(FINIS STEM DATA.\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** EXECIO READ ERROR: RETURN CODE ('SRC'). ***'\n   SAY '*** ERROR READING ('MASTER'('MEMBER'). ***'\n   SAY '*** LHISTORY EXEC SUBTASK CANCELLED. ***'\n   CALL DELETE_PDS_MEMBER\n   EXIT SRC\nEND\nRETURN\n/*     */\nEXTRACT_WORKORDER_HISTORY_RECORDS:\nADDRESS TSO\n\"FREE DA('\"OUTPDS\"')\"\nD = 0\nO = 0\nDATASW = 'NO'\nENDSW = 'NO'\n\"DELSTACK\"\nDO I = 1 TO DATA.0\n   UPDATA = SUBSTR(DATA.I,1,15)\n   IF DATASW = 'NO' & UPDATA \u00ac= KEYDATA THEN QUEUE DATA.I\n   IF UPDATA = KEYDATA THEN DO\n      DATAHDR = SUBSTR(DATA.I,1,70)\n      DATASW = 'YES'\n      QUEUE DATA.I\n      ITERATE\n   END\n   IF DATASW = 'YES' & ENDSW = 'NO' THEN DO\n      DATAKEY = SUBSTR(DATA.I,1,61)\n      DATAEND = SUBSTR(DATA.I,1,9)\n      IF DATAEND = ENDWO THEN DO\n         WOEND = SUBSTR(DATA.I,1,15)\n         IF WOEND = KEYDATA THEN DO\n            QUEUE DATA.I\n            ITERATE\n         END\n         ENDSW = 'YES'\n         E = I - 1\n         O = O + 1\n         ENDDATA.O = DATA.E\n         O = O + 1\n         ENDDATA.O = DATA.I\n         ITERATE\n      END\n      D = D + 1\n      HSTDATA.D = DATAKEY\n   END\n   IF DATASW = 'YES' & ENDSW = 'YES' THEN DO\n      O = O + 1\n      ENDDATA.O = DATA.I\n   END\nEND\nIF DATASW = 'NO' THEN DO\n   SRC = 028\n   SAY '*** HISTORY DATA ERROR: RETURN CODE: ('SRC'). ***'\n   SAY '*** NO DATA FOUND FOR 'FROMDSN'('MEMBER') ('WORKORDR'). ***'\n   SAY '*** LHISTORY EXEC SUBTASK CANCELLED. ***'\n   CALL DELETE_PDS_MEMBER\n   EXIT 0\nEND\nRETURN\n/*     */\nBUILD_SCREEN_DATA:\nDATACNT = D\nDO I = 1 TO DATACNT\n   INTERPRET 'D'I '= HSTDATA.'I\nEND\nRETURN\n/*     */\nDISPLAY_HISTORY_DATA_PANEL:\nADDRESS ISPEXEC\n\"CONTROL ERRORS RETURN\"\n\"DISPLAY PANEL(LBHSTPN2)\"\nSRC = RC\nIF SRC = 8 THEN RETURN\nIF SRC > 8 THEN DO\n   SAY '*** ERROR INVOKING ISPF DIALOG PANEL ( LBHSTPN2 ). ***'\n   SAY '*** LHISTORY EXEC MAINTASK CANCELLED - RC = 'SRC'. ***'\n   RETURN\nEND\nRETURN\n/*     */\nBUILD_HISTORY_UPDATE_RECORDS:\nUPDCNT = 0\nDO I = 1 TO 18\n   DATAVAL = VALUE('D'I)\n   IF DATAVAL = '' THEN ITERATE\n   UPDCNT = UPDCNT + 1\n   WRTDATA = LEFT(DATAVAL,72)\n   QDATA = WRTDATA'UPDATE'\n   QUEUE QDATA\nEND\nRETURN\n/*     */\nCOMPARE_HISTORY_DATA:\nEQUALCNT = 0\nDO I = 1 TO UPDCNT\n   DATAVAL = VALUE('D'I)\n   IF DATAVAL = HSTDATA.I THEN EQUALCNT = EQUALCNT + 1\nEND\nIF EQUALCNT = UPDCNT THEN EXITSW = 'YES'\nRETURN\n/*     */\nQUEUE_ENDING_HISTORY_RECORDS:\nADDRESS TSO\nENDCNT = O\nDO I = 1 TO ENDCNT\n   QUEUE ENDDATA.I\nEND\nRETURN\n/*     */\nWRITE_HISTORY_PDS_MEMBER:\nADDRESS TSO\n\"ALLOC DA('\"OUTPDS\"(\"MEMBER\")') FILE(ECRDD) SHR\"\nNUMRCDS = QUEUED()\n\"EXECIO\" NUMRCDS \"DISKW ECRDD (FINIS\"\nSRC = RC\n\"FREE FILE(ECRDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** EXECIO WRITE ERROR: RETURN CODE: ('SRC'). ***'\n   SAY '*** ERROR WRITING 'OUTPDS'('MEMBER') STAGING PDS. ***'\n   SAY '*** LHISTORY EXEC SUBTASK CANCELLED. ***'\n   CALL DELETE_PDS_MEMBER\n   EXIT SRC\nEND\nRETURN\n/*     */\nCOPY_MEMBER_TO_HISTORY_MASTER:\n/* ***   N O O P   R O U T I N E   *** */\nRETURN\nCOPYSW = 'NO'\nADDRESS ISPEXEC\n\"CONTROL ERRORS RETURN\"\nFROMDSN = 'SYSS.TESTCCF.HISTORY.CNTLLIB'\nTODSN = 'SYS1.'HISTNODE'.MASTER'\n\"SELECT PGM(UTIMAIN) NEWAPPL(LIB@) NEWPOOL PARM(FDSN('\"FROMDSN\"(\"MEMBER\")')\n TDSN('\"TODSN\"(\"MEMBER\")') CMD(C,OPT(REP)) RETURN\"\nSRC = RC\nIF SRC \u00ac= 0 THEN RETURN\nCOPYSW = 'YES'\nRETURN\n/*     */\nBUILD_SUBMIT_LIBREP_JOB:\nADDRESS ISPEXEC \"FTOPEN TEMP\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   ZERRMSG = $CCFA001\n   ADDRESS ISPEXEC \"SETMSG MSG($CCFA001)\"\n   CALL DELETE_PDS_MEMBER\n   EXIT SRC\nEND\nADDRESS ISPEXEC \"FTINCL\" SKELJCL\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   ZERRMSG = $CCFA003\n   ADDRESS ISPEXEC \"SETMSG MSG($CCFA003)\"\n   CALL DELETE_PDS_MEMBER\n   EXIT SRC\nEND\nADDRESS ISPEXEC \"FTCLOSE\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   ZERRMSG = $CCFA005\n   CALL DELETE_PDS_MEMBER\n   EXIT SRC\nEND\nADDRESS ISPEXEC \"VGET ZTEMPF\"\nADDRESS TSO \"SUBMIT '\"ZTEMPF\"'\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   ZERRMSG = $CCFA006\n   CALL DELETE_PDS_MEMBER\n   EXIT SRC\nEND\nRETURN\n/*     */\nALLOC_JOURNAL_DATASET:\nADDRESS TSO\nLABEL = 'NOOP_JOURNAL'\nRECORD = MASTER MEMBER 'UPDATED BY:' TSOID CDATE CTIME\n\"ALLOC DA('\"JOURDSN\"(\"JMEMBER\")') F(ECRDD) SHR\"\nDSN = SYSDSN(\"'\"JOURDSN\"(\"JMEMBER\")'\")\nIF DSN = 'OK' THEN DO\n   \"DELSTACK\"\n   \"EXECIO * DISKR ECRDD (FINIS\"\n   RCDCNT = QUEUED()\n   LABEL = 'REWRITE_JOURNAL'\nEND\nIF DSN = 'MEMBER NOT FOUND' THEN LABEL = WRITE_JOURNAL\nRETURN\n/*     */\nWRITE_JOURNAL:\nADDRESS TSO\n\"DELSTACK\"\nQUEUE RECORD\n\"EXECIO 1 DISKW ECRDD (FINIS\"\n\"FREE F(ECRDD)\"\nRETURN\n/*     */\nREWRITE_JOURNAL:\nADDRESS TSO\nRCDCNT = RCDCNT + 1\nQUEUE RECORD\n\"EXECIO\" RCDCNT \"DISKW ECRDD (FINIS\"\n\"FREE F(ECRDD)\"\nRETURN\n/*     */\nNOOP_JOURNAL:\nRETURN\n/*     */\nDELETE_PDS_MEMBER:\n/* ***\nADDRESS ISPEXEC\n\"CONTROL ERRORS CANCEL\"\n\"CONTROL NONDISPL END\"\nIF VPUTSW = 'YES' THEN DO\n   UTIREP = 'NO'\n   \"VPUT (UTIREP) PROFILE\"\nEND\n                                          *** */\nADDRESS TSO\n\"DELSTACK\"\nPDSMEMB = SYSDSN(\"'\"OUTPDS\"(\"TSOID\")'\")\nIF PDSMEMB = 'OK' THEN DO\n   \"ALLOC DA('\"OUTPDS\"(\"TSOID\")') FILE(ECRDD) SHR\"\n   \"DELETE '\"OUTPDS\"(\"TSOID\")' FILE(ECRDD)\"\n   \"FREE FILE(ECRDD)\"\nEND\nIF MNTSW = 'YES' THEN RETURN\nIF MEMBER = '' THEN MEMBER = 'XXXXXXXX'\nPDSMEMB = SYSDSN(\"'\"OUTPDS\"(\"MEMBER\")'\")\nIF PDSMEMB = 'OK' THEN DO\n   \"ALLOC DA('\"OUTPDS\"(\"MEMBER\")') FILE(ECRDD) SHR\"\n   \"DELETE '\"OUTPDS\"(\"MEMBER\")' FILE(ECRDD)\"\n   \"FREE FILE(ECRDD)\"\nEND\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LBLOGOUT": {"ttr": 13836, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x93\\x10o\\x00\\x93\\x10o\\x17\\t\\x01\\x1a\\x01\\x15\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf3@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1993-04-16T00:00:00", "modifydate": "1993-04-16T17:09:00", "lines": 282, "newlines": 277, "modlines": 0, "user": "TECH103"}, "text": "/* This REXX EXEC is designed to facilitate the CA-LIBRARIAN LIB/CCF\n   logout of modules for a new application system that does not already\n   exist in the PROD Librarian Master datasets.   */\n\nTRACE O\n/*     */\nHOUSE_KEEPING:\nADDRESS TSO\nJCLSW = 'NO'\nMEMBCNT = 0\nTSOID = SYSVAR(SYSUID)\nACCTCCF = 5200010520000000\nX = MSG(\"OFF\")\nLBPANEL.1 = 'ASSEMBLE 1'\nLBPANEL.2 = 'BMSMAP 18'\nLBPANEL.3 = 'BMSMAP 19'\nLBPANEL.4 = 'BMSMAP 20'\nLBPANEL.5 = 'CICSCOB 18'\nLBPANEL.6 = 'CICSCOB 19'\nLBPANEL.7 = 'CICSCOB 20'\nLBPANEL.8 = 'CICSCOB2 18'\nLBPANEL.9 = 'CICSCOB2 19'\nLBPANEL.10 = 'CICSCOB2 20'\nLBPANEL.11 = 'CICSCOPY 18'\nLBPANEL.12 = 'CICSCOPY 19'\nLBPANEL.13 = 'CICSCOPY 20'\nLBPANEL.14 = 'COBOL 1'\nLBPANEL.15 = 'COBOL2 1'\nLBPANEL.16 = 'COPY 3'\nLBPANEL.17 = 'DMSMAP 18'\nLBPANEL.18 = 'DMSMAP 19'\nLBPANEL.19 = 'DMSMAP 20'\nLBPANEL.20 = 'DYL280 1'\nLBPANEL.21 = 'JCL 4'\nLBPANEL.22 = 'PROC 5'\nLBPANEL.23 = 'RAMIS 6'\nLBPANEL.24 = 'RPGIAUTO 1'\nLBPANEL.25 = 'RPGII 1'\nLBPANEL.26 = 'SYSIN 7'\nLBPANEL.27 = 'COBDB2 21'\nLBPANEL.28 = 'CICSDB2 22'\nLBPANEL.29 = 'CICSDB2 23'\nLBPANEL.30 = 'CICSDB2 24'\nDSN = SYSDSN(\"'SYSS.TESTCCF.LOGOUT.CNTLLIB'\")\nIF DSN \u00ac= 'OK' THEN DO\n   SAY '*** DATASET ERROR: ( LOGOUT.CNTLLIB ) DATASET NOT FOUND. ***'\n   SAY '*** LBLOGOUT EXEC TASK CANCELLED. ***'\n   EXIT\nEND\n\"ALLOC DA('SYSS.TESTCCF.LOGOUT.CNTLLIB') F(ISPFILE) OLD\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** ALLOC ERROR: DATASET ( LOGOUT.CNTLLIB ) UNAVAILABLE OR IN USE. ***'\n   SAY '+++ RETRY LBLOGOUT TASK LATER. +++'\n   SAY '*** LBLOGOUT EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   \"FREE F(ISPFILE)\"\n   EXIT\nEND\nADDRESS ISPEXEC\n\"CONTROL ERRORS RETURN\"\n\"VGET (ACCTCDE) PROFILE\"\nIF RC \u00ac= 0 THEN ACCTCDE = ACCTCCF\n\n/*     */\nDISPLAY_MAIN_PANEL:\nDO FOREVER\n   ADDRESS ISPEXEC \"DISPLAY PANEL(LBLOPNL1)\"\n   SRC = RC\n   IF SRC = 0 THEN LEAVE\n   IF SRC = 8 THEN LEAVE\n   IF SRC > 8 THEN DO\n      \"FREE F(ISPFILE)\"\n      SAY '*** PANEL ERROR: ISPF DIALOG ERROR INVOKING PANEL ( LBLOPNL1 ). ***'\n      SAY '*** LBLOGOUT EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n      EXIT\n   END\nEND\nIF WORKORDR = '' | APPLSYS = '' | ABS1 = '' THEN DO\n     \"FREE F(ISPFILE)\"\n     SAY '*** REQUIRED DATA NOT SUPPLIED - LBLOGOUT EXEC TASK TERMINATED. ***'\n     EXIT\nEND\nWO = WORKORDR\nCALL GET_LOGOUT_PDS_MEMBER_NAME\n\n/*     */\nDISPLAY_LANGCODE_LCDF_PANEL:\nDO FOREVER\n   LANGTYP = ''\n   ADDRESS ISPEXEC \"DISPLAY PANEL(LBLOPNL2)\"\n   SRC = RC\n   IF SRC = 0 THEN CALL DISPLAY_MODULE_SELECTION_PANEL\n   IF SRC = 8 THEN CALL DISPLAY_MODULE_SELECTION_PANEL\n   IF SRC > 8 THEN DO\n      \"FREE F(ISPFILE)\"\n      SAY '*** PANEL ERROR: ISPF DIALOG ERROR INVOKING PANEL (LBLOPNL2). ***'\n      SAY '*** LBLOGOUT EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n      EXIT\n   END\nEND\nSIGNAL EXIT_RETURN\n\n/*     S U B R O U T I N E S   S E C T I O N     */\n/*     */\nGET_LOGOUT_PDS_MEMBER_NAME:\nM = 0\nMEMBSW = 'NO'\nDO 26\n   M = M + 1\n   JOB_SUFFIX = SUBSTR('ABCDEFGHIJKLMNOPQRSTUVWXYZ',M,1)\n   MEMBER = TSOID||JOB_SUFFIX\n   DSN = SYSDSN(\"'SYSS.TESTCCF.LOGOUT.CNTLLIB(\"MEMBER\")'\")\n   IF DSN \u00ac= 'OK' THEN DO\n      MEMBSW = 'YES'\n      LEAVE\n   END\nEND\nIF MEMBSW = 'NO' THEN DO\n   \"FREE F(ISPFILE)\"\n   SAY '*** MEMBER ERROR: ( LOGOUT.CNTLLIB ) UNABLE TO ADD MEMB. ***'\n   SAY '*** MEMBER SUFFIX ( A THRU Z ) ALREADY EXISTS. ***'\n   SAY '*** LBLOGOUT EXEC TASK CANCELLED. ***'\n   EXIT\nEND\nRETURN\n\n/*     */\nDISPLAY_MODULE_SELECTION_PANEL:\nIF LANGTYP = '' THEN SIGNAL SUBMIT_LOGOUT_JOB\nP = LANGTYP\nLANGCODE = SUBWORD(LBPANEL.P,1,1)\nDO FOREVER\n   ADDRESS ISPEXEC \"DISPLAY PANEL(LBLOPNL3)\"\n   SRC = RC\n   IF SRC = 0 THEN LEAVE\n   IF SRC = 8 THEN LEAVE\n   IF SRC > 8 THEN DO\n      \"FREE F(ISPFILE)\"\n     SAY '*** PANEL ERROR: ISPF DIALOG ERROR INVOKING PANEL (LBLOPNL3). ***'\n     SAY '*** LBLOGOUT EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n      EXIT\n   END\nEND\nCALL BUILD_MODULE_COPY_RECORDS\nRETURN\n\n/*     */\nBUILD_MODULE_COPY_RECORDS:\nN = 0\nADDRESS TSO\nMOD.1 = MOD1 MOD2 MOD3 MOD4 MOD5 MOD6 MOD7 MOD8 MOD9 MOD10\nMOD.2 = MOD11 MOD12 MOD13 MOD14 MOD15 MOD16 MOD17 MOD18 MOD19 MOD20\nMOD.3 = MOD21 MOD22 MOD23 MOD24 MOD25 MOD26 MOD27 MOD28 MOD29 MOD30\nMOD.4 = MOD31 MOD32 MOD33 MOD34 MOD35 MOD36 MOD37 MOD38 MOD39 MOD40\nMOD.5 = MOD41 MOD42 MOD43 MOD44 MOD45 MOD46 MOD47 MOD48 MOD49 MOD50\nDO 5\n   N = N + 1\n   IF MOD.N = '' THEN ITERATE\n   MEMBCNT = MEMBCNT + 1\nEND\nIF MEMBCNT = 0 THEN RETURN\nIF JCLSW = 'NO' THEN CALL WRITE_JOB_EXECUTE_JCL\nN = 0\nR = 0\nLIBRNUM = SUBWORD(LBPANEL.P,2,1)\nR = R + 1\nRCD.R = \"-MFID\" LIBRNUM\nR = R + 1\nRCD.R = \"-LANG\" LANGCODE\nDO MEMBCNT\n   I = 0\n   N = N + 1\n   DO 10\n      I = I + 1\n      MODNAME = SUBWORD(MOD.N,I,1)\n      IF MODNAME = '' THEN ITERATE\n      R = R + 1\n      RCD.R = \"-COPY\" MODNAME\n   END\nEND\nCALL WRITE_LOGOUT_RECORDS\nSAY '+++ PARAMETERS ACCEPTED FOR (' LANGCODE ') MODULE SELECTION. +++'\nSAY '===> HIT ENTER TO CONTINUE WITH NEXT PARMS OR TO END ...'\nPULL ENTER_KEY\nRETURN\n\n/*     */\nWRITE_JOB_EXECUTE_JCL:\nADDRESS TSO\nACNT = 0\nRCD.1 = \"//\"WO\" JOB \"ACCTCDE\",'LIBCCF.BATCH.LOGOUT',NOTIFY=\"TSOID\",\"\nRCD.2 = \"//             CLASS=P,MSGCLASS=S,MSGLEVEL=(1,1),REGION=4M\"\nRCD.3 = \"//CCFUTIL    EXEC PGM=$CCFB102,PARM=COND\"\nRCD.4 = \"//CCFPRINT   DD SYSOUT=*\"\nRCD.5 = \"-CRID\" WORKORDR\nRCD.6 = \"-APPL\" APPLSYS\nRCD.7 = \"-DESC BUILDING APPLICATION SYSTEM\"\nABS.1 = ABS1\nABS.2 = ABS2\nABS.3 = ABS3\nABS.4 = ABS4\nABS.5 = ABS5\nABS.6 = ABS6\nABS.7 = ABS7\nABS.8 = ABS8\nABS.9 = ABS9\nABS.10 = ABS10\nABS.11 = ABS11\nABS.12 = ABS12\nABS.13 = ABS13\nABS.14 = ABS14\nABS.15 = ABS15\nABS.16 = ABS16\nA = 0\nR = 7\nDO 16\n   A = A + 1\n   IF ABS.A = '' THEN ITERATE\n   ACNT = ACNT + 1\nEND\nIF ACNT = 0 THEN SIGNAL EXIT_RETURN\nA = 0\nDO ACNT\n   A = A + 1\n   R = R + 1\n   RCD.R = \"-ABST\" ABS.A\nEND\n\"FREE F(ISPFILE)\"\n\"ALLOC DA('SYSS.TESTCCF.LOGOUT.CNTLLIB(\"MEMBER\")') F(ISPFILE) OLD\"\nCALL WRITE_LOGOUT_RECORDS\nJCLSW = 'YES'\nRETURN\n\n/*     */\nSUBMIT_LOGOUT_JOB:\nADDRESS TSO\nIF MEMBCNT = 0 THEN SIGNAL EXIT_RETURN\nR = 4\nRCD.1 = \"-EMOD\"\nRCD.2 = \"-END\"\nRCD.3 = \"/*\"\nRCD.4 = \"//\"\nCALL WRITE_LOGOUT_RECORDS\n\"EXECIO 0 DISKW ISPFILE (FINIS\"\n\"SUBMIT 'SYSS.TESTCCF.LOGOUT.CNTLLIB(\"MEMBER\")'\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** SUBMIT ERROR: MEMBER ( SYS1.LOGOUT.CNTLLIB('MEMB'). ***'\n   SAY '*** LBLOGOUT EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   \"FREE F(ISPFILE)\"\n   EXIT\nEND\n\"FREE F(ISPFILE)\"\nSAY '+++ LBLOGOUT JOB: ('MEMBER') SUBMITTED - TASK COMPLETED RC = 0. +++'\nEXIT\n\n/*     */\nWRITE_LOGOUT_RECORDS:\n\"DELSTACK\"\nRCDCNT = R\nR = 0\nDO RCDCNT\n   R = R + 1\n   QUEUE RCD.R\nEND\n\"EXECIO\" R \"DISKW ISPFILE\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   MEMB = MEMBER\n   SAY '*** WRITE ERROR: WRITING MEMBER ( SYS1.LOGOUT.CNTLLIB('MEMB'). ***'\n   SAY '*** LBLOGOUT EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   \"FREE F(ISPFILE)\"\n   EXIT\nEND\nRETURN\n\n/*     */\nEXIT_RETURN:\n\"FREE F(ISPFILE)\"\nSAY '*** INSUFFICIENT OR NO USER DATA NOT SUPPLIED FOR LIB/CCF LOGOUT. ***'\nSAY '*** LBLOGOUT EXEC TASK TERMINATED. ***'\nEXIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LBSCAN": {"ttr": 14086, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01'\\x00\\x00\\x00\\x91$\\x7f\\x00\\x92\\x05\\x7f\\x165\\x00\\xdb\\x03\\xd1\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf3@@@\"", "ispf": {"version": "01.39", "flags": 0, "createdate": "1991-09-04T00:00:00", "modifydate": "1992-02-26T16:35:00", "lines": 219, "newlines": 977, "modlines": 0, "user": "TECH103"}, "text": "/*  REXX EXEC :\n    THIS EXEC IS DESIGNED TO FACILITATE THE CA-LIBRARIAN SCAN UTILITY\n    OF MODULES RESIDING ON A MASTER DATASET.  */\n\nTRACE O\n/*     */\nHOUSE_KEEPING:\nADDRESS ISPEXEC\n\"CONTROL ERRORS RETURN\"\nACCTCCF = 5200010520000000\nLIBSTAT.1 = 'TEST'\nLIBSTAT.2 = 'TURN'\nLIBSTAT.3 = 'QA'\nLIBSTAT.4 = 'EMRG'\nLIBSTAT.5 = 'PROD'\nLIBTYPE.1 = 'COPY'\nLIBTYPE.2 = 'JCL'\nLIBTYPE.3 = 'PROC'\nLIBTYPE.4 = 'RAMI'\nLIBTYPE.5 = 'SRCE'\nLIBTYPE.6 = 'SYSI'\nC = 'T'\nM = 'S'\nSTACOL = 001\nENDCOL = 072\nBEGMOD = '*'\nENDMOD = 'ALL'\nLNE = 0\nTSOID = SYSVAR(SYSUID)\nTSOID = SUBSTR(TSOID,1,4)\nIF TSOID = 'TECH' THEN DO\n   C = 'S'\n   M = 'G'\nEND\nTSOUS = SYSVAR(SYSUID)\n\"VGET (ACCTCDE) PROFILE\"\nIF RC \u00ac= 0 THEN ACCTCDE = ACCTCCF\nADDRESS TSO\nISPFDA = SYSDSN(DIALOG.ISPFILE)\nIF ISPFDA = 'OK' THEN DO\n   X = MSG(\"OFF\")\n   \"FREE DA(DIALOG.ISPFILE)\"\n   \"DELETE (DIALOG.ISPFILE) SCRATCH PURGE NONVSAM\"\nEND\n\"ALLOC DA(DIALOG.ISPFILE) LIKE(USER.CNTLLIB) NEW SPACE(1,0) DIR(15) CYLINDERS\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** ALLOCATE ERROR: ERROR ALLOCATING TEMP ISPFILE DATASET. ***'\n   SAY '*** LIBSCAN EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   \"DELETE (DIALOG.ISPFILE) SCRATCH PURGE NONVSAM\"\n   EXIT\nEND\n\"FREE DA(DIALOG.ISPFILE)\"\n\"ALLOC DA(DIALOG.ISPFILE(LIBRSCAN)) FILE(ISPFILE) OLD\"\n\n/*     */\nDISPLAY_LIBSCAN_PANELS:\nADDRESS ISPEXEC\n\"DISPLAY PANEL(LBSCANP1)\"\nSRC = RC\nIF SRC > 8 THEN DO\n   SAY '*** PANEL ERROR: ISPF DIALOG ERROR INVOKING PANEL ( LBSCANP1 ). ***'\n   SAY '*** LIBSCAN EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   \"FREE DA(DIALOG.ISPFILE)\"\n   \"DELETE (DIALOG.ISPFILE) SCRATCH PURGE NONVSAM\"\n   EXIT\nEND\nIF SRC = 8 THEN DO\n   \"FREE DA(DIALOG.ISPFILE)\"\n   \"DELETE (DIALOG.ISPFILE) SCRATCH PURGE NONVSAM\"\n   EXIT\nEND\nCALL ASSIGN_SCAN_VARIABLES\n\"DISPLAY PANEL(LBSCANP2)\"\nSRC = RC\nIF SRC > 8 THEN DO\n   SAY '*** PANEL ERROR: ISPF DIALOG ERROR INVOKING PANEL ( LBSCANP2 ). ***'\n   SAY '*** LIBSCAN EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   \"FREE DA(DIALOG.ISPFILE)\"\n   \"DELETE (DIALOG.ISPFILE) SCRATCH PURGE NONVSAM\"\n   EXIT\nEND\nIF SRC = 8 THEN DO\n   \"FREE DA(DIALOG.ISPFILE)\"\n   \"DELETE (DIALOG.ISPFILE) SCRATCH PURGE NONVSAM\"\n   EXIT\nEND\n\n/*     */\nBUILD_SCAN_SUBMIT_JCL:\nADDRESS TSO\nCALL BUILD_SCAN_JCL\nCALL BUILD_SCAN_SYSIN\nCALL WRITE_SCAN_JOB\nCALL SUBMIT_SCAN_JOB\n/* X = MSG(\"OFF\") */\n\"FREE DA(DIALOG.ISPFILE)\"\n/* \"DELETE (DIALOG.ISPFILE) SCRATCH PURGE NONVSAM\" */\nEXIT 0\n\n/*     S U B R O U T I N E S   S E C T I O N     */\n\n/*     */\nASSIGN_SCAN_VARIABLES:\nS = LIBSTAT\nT = LIBTYPE\nJN = JOBNAME\nJOBN = LENGTH(JN)\nIF JOBN < 8 THEN JN = LEFT(JN,8)\nMASTRDSN = 'SYS1.'LIBSTAT.S||LIBTYPE.T'.MASTER'\nSCOL = LENGTH(STACOL)\nIF SCOL < 3 THEN STACOL = RIGHT(STACOL,3,0)\nECOL = LENGTH(ENDCOL)\nIF ECOL < 3 THEN ENDCOL = RIGHT(ENDCOL,3,0)\nIF BEGMOD = '*' THEN RETURN\nBMOD = LENGTH(BEGMOD)\nIF BMOD < 8 THEN BEGMOD = LEFT(BEGMOD,8)\nEMOD = LENGTH(ENDMOD)\nIF EMOD < 8 THEN ENDMOD = LEFT(ENDMOD,8)\nRETURN\n\n/*     */\nBUILD_SCAN_JCL:\nJ = 0\n\"DELSTACK\"\nRCD.1 = \"//\"JN\" JOB\" ACCTCDE\",'\"TSOUS\".FAIRSCAN',NOTIFY=\"TSOUS\",\"\nRCD.2 = \"//             CLASS=\"C\",MSGCLASS=\"M\",MSGLEVEL=(1,1),REGION=4096K\"\nRCD.3 = \"//LIBRSCAN EXEC PGM=FAIRSCAN\"\nRCD.4 = \"//PRINTOUT DD SYSOUT=*\"\nRCD.5 = \"//SYSOUT   DD SYSOUT=*\"\nRCD.6 = \"//MASTER   DD DSN=\"MASTRDSN\",DISP=SHR\"\nRCD.7 = \"//CARDIN   DD *\"\nDO 7\n   J = J + 1\n   QUEUE RCD.J\nEND\nRETURN\n\n/*     */\nBUILD_SCAN_SYSIN:\nN = 0\nR = 0\nSCNCNT = 0\nSCAN.1 = SCAN1\nSCAN.2 = SCAN2\nSCAN.3 = SCAN3\nSCAN.4 = SCAN4\nSCAN.5 = SCAN5\nSCAN.6 = SCAN6\nSCAN.7 = SCAN7\nSCAN.8 = SCAN8\nSCAN.9 = SCAN9\nSCAN.10 = SCAN10\nDO 10\n   N = N + 1\n   IF SCAN.N = '' THEN ITERATE\n   SCNCNT = SCNCNT + 1\nEND\nDO SCNCNT\n   R = R + 1\n   RCD.R = \"-SCAN     \"SCAN.R\"#$#\"\nEND\nR = R + 1\nRCD.R = \"-COLM     \"STACOL ENDCOL\nR = R + 1\nRCD.R = \"-LINE     \"LNE\nIF BEGMOD \u00ac= '*' THEN DO\n   R = R + 1\n   RCD.R = \"-PROG     \"BEGMOD    ENDMOD\nEND\nR = R + 1\nRCD.R = \"/*\"\nR = R + 1\nRCD.R = \"//\"\nRCDCNT = J + R\nRETURN\n\n/*     */\nWRITE_SCAN_JOB:\nADDRESS TSO\nR = 0\nDO RCDCNT\n   R = R + 1\n   QUEUE RCD.R\nEND\n\"EXECIO\" RCDCNT \"DISKW ISPFILE\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** WRITE ERROR: ERROR WRITING SYSIN ENTRIES TO TEMP ISPFILE. ***'\n   SAY '*** LIBSCAN EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   \"FREE DA(DIALOG.ISPFILE)\"\n   \"DELETE (DIALOG.ISPFILE) SCRATCH PURGE NONVSAM\"\n   EXIT\nEND\n\"EXECIO 0 DISKW ISPFILE (FINIS\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** FTCLOSE ERROR: ERROR CLOSING TEMP ISPFILE DATASET FOR SUBMIT. ***'\n   SAY '*** LIBSCAN EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   \"FREE DA(DIALOG.ISPFILE)\"\n   \"DELETE (DIALOG.ISPFILE) SCRATCH PURGE NONVSAM\"\n   EXIT\nEND\nRETURN\n\n/*     */\nSUBMIT_SCAN_JOB:\nADDRESS TSO\nX = MSG(\"ON\")\n\"SUBMIT DIALOG.ISPFILE(LIBRSCAN)\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** SUBMIT ERROR: ERROR SUBMITTING' JOBNAME' FROM TEMP ISPFILE . ***'\n   SAY '*** LIBSCAN EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   \"FREE DA(DIALOG.ISPFILE)\"\n   \"DELETE (DIALOG.ISPFILE) SCRATCH PURGE NONVSAM\"\n   EXIT\nEND\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LGNALIAS": {"ttr": 14091, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x91\\x07?\\x00\\x91\\x17\\x9f\\x16\\x14\\x00 \\x00\\x0e\\x00\\x00\\xd1\\xc5\\xc6\\xc6\\xd2@@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1991-03-14T00:00:00", "modifydate": "1991-06-28T16:14:00", "lines": 32, "newlines": 14, "modlines": 0, "user": "JEFFK"}, "text": "/* REXX EXEC REF (SYS1.TECH.COMMON.EXECLIB)\n   Create alias names for @IKJLOGN common TSO/E logon procedure\n   Set ISPF/PDF editor CAPS OFF when editing                        */\n/* Address the TSO/E environment                                    */\naddress \"TSO\";\n\"DELETE 'SYS1.PROCLIB(@IKJTSOE)'\";\n\"DELETE 'SYS1.PROCLIB(@IKJTART)'\";\n\"DELETE 'SYS1.PROCLIB(@IKJUMNT)'\";\n\"DELETE 'SYS1.PROCLIB(@IKJUTBL)'\";\n\"DELETE 'SYS1.PROCLIB(@IKJUWTR)'\";\n\"DELETE 'SYS1.PROCLIB(@IKJBPDF)'\";\n\"DELETE 'SYS1.PROCLIB(@IKJBART)'\";\n\"DELETE 'SYS1.PROCLIB(@IKJBINF)'\";\n\"DELETE 'SYS1.PROCLIB(@IKJXPDF)'\";\n\"DELETE 'SYS1.PROCLIB(@IKJXART)'\";\n\"DELETE 'SYS1.PROCLIB(@IKJXINF)'\";\n\"DELETE 'SYS1.PROCLIB(@IKJSOPR)'\";\n\"DELETE 'SYS1.PROCLIB(@IKJSSUP)'\";\n\"RENAME 'SYS1.PROCLIB(@IKJLOGN)' (@IKJTSOE) ALIAS\";\n\"RENAME 'SYS1.PROCLIB(@IKJLOGN)' (@IKJTART) ALIAS\";\n\"RENAME 'SYS1.PROCLIB(@IKJLOGN)' (@IKJUMNT) ALIAS\";\n\"RENAME 'SYS1.PROCLIB(@IKJLOGN)' (@IKJUTBL) ALIAS\";\n\"RENAME 'SYS1.PROCLIB(@IKJLOGN)' (@IKJUWTR) ALIAS\";\n\"RENAME 'SYS1.PROCLIB(@IKJLOGN)' (@IKJBPDF) ALIAS\";\n\"RENAME 'SYS1.PROCLIB(@IKJLOGN)' (@IKJBART) ALIAS\";\n\"RENAME 'SYS1.PROCLIB(@IKJLOGN)' (@IKJBINF) ALIAS\";\n\"RENAME 'SYS1.PROCLIB(@IKJLOGN)' (@IKJXPDF) ALIAS\";\n\"RENAME 'SYS1.PROCLIB(@IKJLOGN)' (@IKJXART) ALIAS\";\n\"RENAME 'SYS1.PROCLIB(@IKJLOGN)' (@IKJXINF) ALIAS\";\n\"RENAME 'SYS1.PROCLIB(@IKJLOGN)' (@IKJSOPR) ALIAS\";\n\"RENAME 'SYS1.PROCLIB(@IKJLOGN)' (@IKJSSUP) ALIAS\";\nexit 0;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LIBALLDD": {"ttr": 14093, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x94 \\x0f\\x00\\x94 \\x0f\\tH\\x00\\x0c\\x00A\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf1\\xf0@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1994-07-19T00:00:00", "modifydate": "1994-07-19T09:48:00", "lines": 12, "newlines": 65, "modlines": 0, "user": "TECH110"}, "text": "/* REXX allocate LAM file with DDNAME support */\nparse upper arg \"'\" libddn \"'\" \"'\" libdsn \"'\";\nif libdsn = \"\" then do;\n      say \"Re-enter LIBALLDD with Librarian master filename\";\n      exit 4;\n      end;\nddname = liballod('\"'libddn'\"','\"'libdsn'\"');/*Dynalloc lam libmaster*/\nif ddname = \"ERROR\" then do;\n      say \"Invalid Librarian master filename\";\n      exit 8;\n      end;\nexit 0;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LIBALLOC": {"ttr": 14095, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x17\\x00\\x00\\x00\\x91\\x04?\\x00\\x91\\x17\\x1f\\tH\\x00\\x0f\\x00\\x06\\x00\\x00\\xd1\\xc5\\xc6\\xc6\\xd2@@@@@'", "ispf": {"version": "01.23", "flags": 0, "createdate": "1991-02-12T00:00:00", "modifydate": "1991-06-20T09:48:00", "lines": 15, "newlines": 6, "modlines": 0, "user": "JEFFK"}, "text": "/* REXX LIBALLOC LAM Support */\nlibmem = \"\"; /* Assume no member name */\nif pos(\"(\",arg(1)) \u00ac=0 then do; /* See if member name spec */\n         parse upper arg \"'\" libdsn \"(\" libmem \")'\";\n         end;\n  else do;\n         parse upper arg \"'\" libdsn \"'\";\n         end;\nlibdsn = strip(libdsn);\nchekrc = listdsi(\"'\"libdsn\"'\");\nif chekrc > 4 then return \"ERROR\";\nif libmem \u00ac= \"\" then ,\n    return XLIBALLC(libdsn,libmem);\n  else ,\n    return XLIBALLC(libdsn);\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LIBALLOD": {"ttr": 14097, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x00\\x00\\x00\\x94\\x19\\x9f\\x00\\x94 \\x0f\\x10\\x05\\x00\\x13\\x00\\x0f\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf1\\xf0@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "1994-07-18T00:00:00", "modifydate": "1994-07-19T10:05:00", "lines": 19, "newlines": 15, "modlines": 0, "user": "TECH110"}, "text": "/* REXX LIBALLOC LAM Support */\nlibmem = \"\"; /* Assume no member name */\nlibddn=arg(1);/* function parms */\nlibdsn=arg(2);\nparse upper var libddn with '\"' libddn '\"';\nif pos(\"(\",libdsn) \u00ac=0 then do; /* See if member name spec */\n    parse upper var libdsn with '\"' libdsn '(' libmem ')\"';\n    end;\n  else do;\n    parse upper var libdsn with '\"' libdsn '\"';\n    end;\nlibddn = strip(libddn);\nlibdsn = strip(libdsn);\nchekrc = listdsi(\"'\"libdsn\"'\");\nif chekrc > 4 then return \"ERROR\";\nif libmem \u00ac= \"\" then ,\n    return XLIBALLD(libddn,libdsn,libmem);\n  else ,\n    return XLIBALLD(libddn,libdsn);\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LIBDSRCE": {"ttr": 14337, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x94\\x11o\\x00\\x94\\x11o\\x10H\\x00\\x85\\x00\\x86\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf3@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1994-04-26T00:00:00", "modifydate": "1994-04-26T10:48:00", "lines": 133, "newlines": 134, "modlines": 0, "user": "TECH103"}, "text": "/*  REXX EXEC : ( LIBDSRCE ).\n    FUNCTION: PERFORM MAINTENANCE CLEANUP OF THE CCF TEST SRCE MASTER\n              ( SYS1.TESTSRCE.MASTER ) DATASET.\n\n    INPUT   : LIBRARIAN GPO INDEX SYSOUT DATASETS:\n              DSN = ( SYSS.TESTSRCE.LIBINDEX )\n\n    OUTPUT  : PDS WITH LIBRARIAN DLM ( DELETE MEMBER ) JOBSTREAM:\n              DSN = ( TSOID.USER.CNTLLIB(LIBDSRCJ).\n\n            : JOURNAL DATASET:\n              DSN = ( SYSS.TESTSRCE.DELETE.JOURNAL ).\n                                                                      */\nTRACE O\n/*     */\nHOUSE_KEEPING:\nADDRESS TSO\nPARSE UPPER ARG TSTINDEX\nIF TSTINDEX = '' THEN DO\n   SAY '*** PARM ERROR: GPO INDEX DATASET NAME NOT PASSED ON COMMAND LINE. ***'\n   SAY '*** LIBDSRCE EXEC TASK CANCELLED. ***'\n   EXIT 024\nEND\nLBDSN = SYSDSN(\"'\"TSTINDEX\"'\")\nIF LBDSN = 'DATASET NOT FOUND' THEN DO\n   SAY '*** DATASET ERROR: GPO INDEX DATASET ('TSTINDEX') NOT FOUND. ***'\n   SAY '*** LIBDSRCE EXEC TASK CANCELLED. ***'\n   EXIT 028\nEND\nD = 0\nX = MSG(\"OFF\")\n\"FREE FILE(LIBDD)\"\nTSOID = SYSVAR(SYSUID)\nACCTCDE = '5304010530000000'\nPDSMEMB = 'LIBDSRCJ'\nSUBPDS = TSOID'.USER.CNTLLIB'\nMASTER = 'SYS1.TESTSRCE.MASTER'\nCALL READ_TEST_LIBINDEX\n/*     */\nMAIN_ROUTINE:\nDO I = 1 TO TDATA.0\n   VALID_MODULE = POS('$NOJCL',TDATA.I)\n   IF VALID_MODULE = 0 THEN ITERATE\n   MODULE = WORD(TDATA.I,1)\n   PASSWORD = WORD(TDATA.I,2)\n   D = D + 1\n   DLMRCD.D = \"-DLM \"MODULE\",\"PASSWORD\nEND\nDLMCNT = D\nCALL BUILD_LIBDELET_JOB\nCALL WRITE_LIBDELET_JOB\nCALL SUBMIT_LIBDELET_JOB\nEXIT 0\n\n/*     S U B R O U T I N E S   S E C T I O N     */\n/*     */\nREAD_TEST_LIBINDEX:\n\"ALLOC DA('\"TSTINDEX\"') FILE(LIBDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ( 'TSTINDEX' ). ***'\n   SAY '*** DATASET IN USE OR UNAVAILABLE - RETURN CODE: (' SRC '). ***'\n   SAY '*** LIBDSRCE EXEC SUBTASK CANCELLED. ***'\n   EXIT SRC\nEND\n\"EXECIO * DISKR LIBDD (FINIS STEM TDATA.\"\nSRC = RC\n\"FREE FILE(LIBDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET EXECIO ERROR: ( 'TSTINDEX' ). ***'\n   SAY '*** EXECIO DATASET READ RETURN CODE: (' SRC '). ***'\n   SAY '*** LIBDSRCE EXEC SUBTASK CANCELLED. ***'\n   EXIT SRC\nEND\nRETURN\n/*     */\nBUILD_LIBDELET_JOB:\nJN = PDSMEMB\n\"DELSTACK\"\nJCL.1 = \"//\"JN\"  JOB \"ACCTCDE\",'TECH.SUPP.LIBDELETE',NOTIFY=\"TSOID\",\"\nJCL.2 = \"//             CLASS=S,MSGCLASS=G,MSGLEVEL=(1,1),REGION=6M\"\nJCL.3 = \"/*JOBPARM SYSAFF=SYSA\"\nJCL.4 = \"//LIBDLM   EXEC PGM=AFOLIBR\"\nJCL.5 = \"//MASTER   DD DSN=\"MASTER\",DISP=SHR\"\nJCL.6 = \"//OSJOB    DD DUMMY\"\nJCL.7 = \"//SYSPRINT DD SYSOUT=*\"\nJCL.8 = \"//LIST     DD SYSOUT=*\"\nJCL.9 = \"//INDEX    DD SYSOUT=*\"\nJCL.10 = \"//SYSIN    DD *\"\nDO J = 1 TO 10\n   QUEUE JCL.J\nEND\nDO I = 1 TO DLMCNT\n   QUEUE DLMRCD.I\nEND\nJCL.1 = \"-END\"\nJCL.2 = \"/*\"\nJCL.3 = \"//\"\nDO J = 1 TO 3\n   QUEUE JCL.J\nEND\nRETURN\n/*     */\nWRITE_LIBDELET_JOB:\n\"ALLOC DA('\"SUBPDS\"(\"PDSMEMB\")') FILE(LIBDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ( 'SUBPDS'('PDSMEMB'). ***'\n   SAY '*** DATASET IN USE OR UNAVAILABLE - RETURN CODE: (' SRC '). ***'\n   SAY '*** LIBDSRCE EXEC SUBTASK CANCELLED. ***'\n   EXIT SRC\nEND\nNUMRCDS = QUEUED()\n\"EXECIO\" NUMRCDS \"DISKW LIBDD (FINIS\"\nSRC = RC\n\"FREE FILE(LIBDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** PDS WRITE ERROR: 'SUBPDS'('PDSMEMB'). ***'\n   SAY '*** EXECIO WRITE RETURN CODE: (' SRC '). ***'\n   SAY '*** LIBDSRCE EXEC SUBTASK CANCELLED. ***'\n   EXIT SRC\nEND\nRETURN\n/*     */\nSUBMIT_LIBDELET_JOB:\n\"SUBMIT ('\"SUBPDS\"(\"PDSMEMB\")')\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** SUBMIT ERROR: MEMBER ( 'SUBPDS'('PDSMEMB'). ***'\n   SAY '*** LIBDSRCE EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LIBEXPND": {"ttr": 14340, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\x00\\x00\\x91\\x16/\\x00\\x915\\x1f\\x17\\x17\\x00N\\x00;\\x00\\x16\\xe3\\xc5\\xc3\\xc8\\xf1\\xf1\\xf0@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "1991-06-11T00:00:00", "modifydate": "1991-12-17T17:17:00", "lines": 78, "newlines": 59, "modlines": 22, "user": "TECH110"}, "text": "/* REXX LIBEXPND LAM Support  */\naddress \"ISPEXEC\";\ntrue = '1';   /* true and false bits */\nfalse = '0';\ncontinuation = false;\n\"ISREDIT MACRO\"; /* Header */\n\"ISREDIT (CURLINE,CURCOL) = CURSOR\"; /* Access cursor position */\n\"ISREDIT (LINEDATA) = LINE\" curline; /* Access that line */\nlinedata = strip(substr(linedata,1,72)); /* Truncate */\n/* See if proc expansion required */\nif substr(linedata,1,2)=\"//\" & substr(linedata,3,1)\u00ac=\"*\" & ,\n     pos(\" EXEC \",linedata)\u00ac=0 & pos(\"PGM=\",linedata)=0 then do;\n       if substr(linedata,3,1)=\" \" then ,  /* Get ddname */\n         ddname = \" \";\n       else parse var linedata \"//\" ddname \"EXEC\" . ;\n       if pos(\"PROC=\",linedata)\u00ac=0 then , /* get procname */\n         parse var linedata . \"PROC=\" member \",\" . ;\n        else parse var linedata . \"EXEC\" member \",\" . ;\n       member = strip(member); /* no blanks */\n       dsname = \"SYS1.PRODPROC.MASTER\"; /* default proclib */\n       libdsn = \"'\"dsname\"(\"member\")'\"; /* Alloc */\n       repline = \"//* LIBEXPAND PROCLIB:\"dsname\";MEMBER:\"member;\n       \"ISREDIT LINE\" curline \"= '\"repline\"'\";\n       repline = \"// PEND\";\n       \"ISREDIT LINE_AFTER\" curline \"= '\"repline\"'\";\n       \"ISREDIT LINE_AFTER\" curline+1 \"= (LINEDATA)\";\n       \"ISREDIT LIBFCRSR\" libdsn; /* fetch at cursor */\n       exit 0;\n    end; /* end of EXEC processing */\n/* Perform some DD cursory checks */\nif substr(linedata,1,2)\u00ac=\"//\" | substr(linedata,3,1)=\"*\" | ,\n    pos(\" DD \",linedata)=0 | ,\n    (pos(\"DSN=\",linedata)=0 & pos(\"DSNAME=\",linedata)=0) then do;\n         zedsmsg = \"DDSTMT?\";\n         zedlmsg = \"Invalid JCL Data Definition statement\";\n         \"SETMSG MSG(ISRZ001)\";\n         exit 4;\n         end;\nif substr(linedata,length(linedata),1)=\",\" | , /* Continuation */\n      (length(linedata)=72 & substr(linedata,72,1)\u00ac=\" \") then do;\n         continuation = true;\n         linedata = strip(substr(linedata,1,71));\n         nxtline = curline + 1;\n        do while(continuation);\n         \"ISREDIT (LNXTDATA) = LINE\" nxtline; /* Access that line */\n         \"ISREDIT DELETE\" nxtline; /* Delete that line */\n         lnxtdata = strip(substr(lnxtdata,1,72));\n         continuation = false; /* assume */\n         if substr(lnxtdata,length(lnxtdata),1)=\",\" | ,\n          (length(lnxtdata)=72 & substr(lnxtdata,72,1)\u00ac=\" \") then do;\n             continuation = true;\n             end;\n           lnxtdata = strip(substr(lnxtdata,1,71));\n           linedata = linedata||strip(substr(lnxtdata,3));\n         end; /* do while end */\n       end; /* major cont group end */\nif pos(\"DSN=\",linedata)\u00ac=0 then ,\n     parse var linedata . \"DSN=\" dsname \"(\" member \")\";\n  else ,\n     parse var linedata . \"DSNAME=\" dsname \"(\" member \")\";\nif dsname = \"\" | member = \"\" then do;\n         zedsmsg = \"DDSTMT?\";\n         zedlmsg = \"Invalid JCL Data Definition statement\";\n         \"SETMSG MSG(ISRZ001)\";\n         exit 4;\n         end;\nlibdsn = \"'\"dsname\"(\"member\")'\"; /* Alloc */\nif substr(linedata,3,1)=\" \" then ,  /* Get ddname */\n     ddname = \" \";\n  else parse var linedata \"//\" ddname \"DD\" . ;\nrepline = \"//* LIBEXPAND DSNAME:\"dsname\";MEMBER:\"member;\n\"ISREDIT LINE\" curline \"= '\"repline\"'\";\nrepline = \"//\"ddname \"DD DATA,DCB=BLKSIZE=80\";\n\"ISREDIT LINE_AFTER\" curline \"= '\"repline\"'\";\n\"ISREDIT LINE_AFTER\" curline+1 \"= '/*'\";\n\"ISREDIT SEEK C'DD DATA,DCB=BLKSIZE=80'\"; /* down 1 */\n\"ISREDIT LIBFCRSR\" libdsn; /* fetch at cursor */\nexit 0;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LIBFCRSR": {"ttr": 14343, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x14\\x00\\x00\\x00\\x91\\x15\\x7f\\x00\\x915\\x1f\\x17%\\x00@\\x00\\x06\\x00@\\xe3\\xc5\\xc3\\xc8\\xf1\\xf1\\xf0@@@'", "ispf": {"version": "01.20", "flags": 0, "createdate": "1991-06-06T00:00:00", "modifydate": "1991-12-17T17:25:00", "lines": 64, "newlines": 6, "modlines": 64, "user": "TECH110"}, "text": "/* REXX LIBFCRSR LAM Support  */\naddress \"ISPEXEC\";\n\"ISREDIT MACRO (LIBDSN)\"; /* Access dsname */\nif libdsn = \"\" then do;\n      zedsmsg = \"LIBDSN?\";\n      zedlmsg = \"Re-enter LIBFCRSR with Librarian master filename\"|| ,\n            \" and member name\";\n      \"SETMSG MSG(ISRZ001)\";\n      exit 4;\n      end;\nif substr(libdsn,1,9)=\"BUILDING.\" then do;\n     parse var libdsn . \".\" rdsn;\n     libdsn = \"SYS1.\"rdsn;\n     end;\nif substr(libdsn,1,10)=\"'BUILDING.\" then do;\n     parse var libdsn . \".\" rdsn;\n     libdsn = \"'SYS1.\"rdsn;\n     end;\n/* \"ISREDIT PROCESS DEST\"; */\nddname = liballoc(LIBDSN); /* Dynalloc libmaster w/lam; ret ddname*/\nif ddname = \"ERROR\" then do;\n      zedsmsg = \"LIBDSN?\";\n      zedlmsg = \"Invalid Librarian master filename\";\n      \"SETMSG MSG(ISRZ001)\";\n      exit 4;\n      end;\nparse var libdsn \"'\" bldldsn \"(\" bldlmem \")'\" . ;\nif bldlmem = \"\" then do;\n      zedsmsg = \"MEMBER?\";\n      zedlmsg = \"Invalid Librarian member name\";\n      \"SETMSG MSG(ISRZ001)\";\n      exit 4;\n      end;\nbldddn = liballoc(\"'\"bldldsn\"'\"); /*Dynal libmast w/lam; ret ddname*/\nif bldddn = \"ERROR\" then do;\n      zedsmsg = \"LIBDSN?\";\n      zedlmsg = \"Invalid Librarian master filename\";\n      \"SETMSG MSG(ISRZ001)\";\n      exit 4;\n      end;\nbldldir = xlibemem(bldddn,bldlmem); /* fetch dir entry */\nif bldldir = \"\"  then do;\n      zedsmsg = \"MEMBER?\";\n      zedlmsg = \"Invalid Librarian member name\";\n      \"SETMSG MSG(ISRZ001)\";\n      exit 4;\n      end;\nmsg_status = MSG(\"OFF\");\naddress \"TSO\" \"EXECIO * DISKR\" ddname \"(STEM LIBFCRSR. FINIS\";\nsaverc = rc;\nmsg_status = MSG(\"ON\");\nif saverc \u00ac= 0 then do;\n      zedsmsg = \"MEMBER?\";\n      zedlmsg = \"Invalid Librarian member name\";\n      \"SETMSG MSG(ISRZ001)\";\n      exit 4;\n      end;\n\"ISREDIT (CURLINE,CURCOL) = CURSOR\"; /* Access cursor position */\ndo i = 1 to libfcrsr.0;\n   libfcrsr.i = translate(libfcrsr.i,\"'\",'\"'); /* no double quotes*/\n   dataline = libfcrsr.i;\n   \"ISREDIT LINE_AFTER\" CURLINE+i-1 '= (DATALINE)';\nend;\nexit 0;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LIBPURGE": {"ttr": 14345, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01@\\x00\\x00\\x00\\x92\\x12\\x9f\\x00\\x95\\x16\\x0f\\x10G\\x02,\\x00\\x94\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf3@@@'", "ispf": {"version": "01.64", "flags": 0, "createdate": "1992-05-08T00:00:00", "modifydate": "1995-06-09T10:47:00", "lines": 556, "newlines": 148, "modlines": 0, "user": "TECH103"}, "text": "/* REXX EXEC : ( LIBPURGE )\n   FUNCTION  : THIS UTILITY IS DESIGNED TO FACILITATE THE MAINTENANCE\n               CLEANUP OF THE CCF EMERGENCY LIBRARIAN MASTERS AND\n               MANAGED LOADLIB DATASETS.\n               THE DELETION OF MEMBERS IS BASED ON A 24 HOUR\n               RESIDENT PERIOD IN THE EMERGENCY LIBRARY DATASETS.\n   AUTHOR    : DAN BOWEN.\n                                                                      */\nTRACE O\n/*     */\nHOUSE_KEEPING:\nADDRESS TSO\nC = 0\nE = 0\nG = 0\nP = 0\nCURHOUR = TIME(H)\nCURDATE = DATE(U)\nJULDATE = DATE(J)\nACCTCDE = '5304010530000000'\nLIBNODES = 'EMRGCOPY EMRGJCL EMRGPROC EMRGRAMI EMRGSYSI EMRGSRCE'\nJOBNAMES = 'PTLB05D PTLB06D PTLB07D PTLB08D PTLB09D PTLB10D'\nCCFMODS = 'MMRCNTL0 MTRCNTL0'\nCCFDSN = 'SYSS.ZEKE.EMRGPARM.CNTLLIB'\nLOADLIB.1 = 'SYS1.EMERGNCY.BATCH.LOADLIB BATCHDD'\nLOADLIB.2 = 'SYS1.EMERGNCY.CICS.LOADLIB CICSDD'\nNUMDAYS.1 = '31 28 31 30 31 30 31 31 30 31 30 31'\nNUMDAYS.2 = '31 29 31 30 31 30 31 31 30 31 30 31'\nPARSE VALUE CURDATE WITH CMM '/' CDD '/' CYY\nX = MSG(\"OFF\")\n\"FREE FILE(LBINDEX)\"\n\"FREE FILE(LBCNTL)\"\n\"FREE FILE(MMRDD)\"\n\"FREE FILE(MTRDD)\"\nDO P = 1 TO 2\n   CCFMOD = WORD(CCFMODS,P)\n   MTR = SYSDSN(\"'\"CCFDSN\"(\"CCFMOD\")'\")\n   IF MTR = 'OK' THEN DO\n      LABEL = 'READ_MODULE_'CCFMOD\n      INTERPRET CALL LABEL\n      ITERATE\n   END\n   SAY '***********************************************************************'\n   SAY '*** MEMBER ERROR: ('CCFDSN'('CCFMOD'). ***'\n   SAY '*** MEMBER NOT FOUND - UNABLE TO READ CCF CONTROL MODULE. ***'\n   SAY '*** LIBPURGE EXEC TASK CANCELLED - RETURN CODE: (028). ***'\n   SAY '***********************************************************************'\n   EXIT 028\nEND\n/*      M A I N   R O U T I N E   S E C T I O N     */\n/*     */\nMAIN_ROUTINE:\nDO C = 1 TO 6\n   R = 0\n   NODE = WORD(LIBNODES,C)\n   LIBINDEX = 'SYSS.ZEKE.'NODE'.LIBINDEX'\n   LIBMASTR = 'SYS1.'NODE'.MASTER'\n   CALL READ_LIBINDEX\n   CALL GET_DELETE_CANDIDATES\n   RCDCNT = R\n   IF RCDCNT = 0 THEN DO\n      SAY '+++ NO MODULES DELETED FROM: 'LIBMASTR' DATASET. +++'\n      ITERATE\n   END\n   CALL BUILD_LIBDELET_JOB\n   CALL WRITE_PDS_MEMBER\n   IF NODE = 'EMRGSRCE' THEN DO\n      GCNT = G\n      IF GCNT > 0 THEN DO G = 1 TO GCNT\n         PDSMEMB = LIBJOB.G\n         CALL SUBMIT_LIBDELET_JOB\n      END\n      CALL BUILD_DELETE_LOADLIB_JOB\n      IF LMODSW = 'YES' THEN DO\n         CALL WRITE_PDS_MEMBER\n         CALL SUBMIT_LIBDELET_JOB\n      END\n      CALL CHECK_DELETE_DYLAKOR_LOADMOD\n      IF LMODSW = 'YES' THEN DO\n         CALL WRITE_PDS_MEMBER\n         CALL SUBMIT_LIBDELET_JOB\n      END\n      CALL CHECK_UNASSIGNED_LOADMOD\n      CALL BUILD_DELETE_UNASSIGNED_LOADMOD\n      IF LMODSW = 'YES' THEN DO\n         CALL WRITE_PDS_MEMBER\n         CALL SUBMIT_LIBDELET_JOB\n      END\n   END\n   CALL BUILD_JOURNAL_MEMBER\n   CALL WRITE_PDS_MEMBER\nEND\nEXIT 0\n/*\n       S U B R O U T I N E S   S E C T I O N     */\n/*     */\nREAD_MODULE_MMRCNTL0:\n\"ALLOC DA('\"CCFDSN\"(\"CCFMOD\")') FILE(MMRDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '***********************************************************************'\n   SAY '*** ALLOCATE ERROR: FOR ('CCFDSN'('CCFMOD'). ***'\n   SAY '*** UNABLE TO READ ('CCFMOD') MODULE MOVEMENT RECORDS. ***'\n   SAY '*** LIBPURGE EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   SAY '***********************************************************************'\n   EXIT SRC\nEND\n\"EXECIO * DISKR MMRDD (STEM MMRDATA. FINIS\"\nSRC = RC\n\"FREE FILE(MMRDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '***********************************************************************'\n   SAY '*** EXECIO ERROR: ('CCFDSN'('CCFMOD'). ***'\n   SAY '*** UNABLE TO READ ('CCFMOD') MODULE MOVEMENT RECORDS. ***'\n   SAY '*** LIBPURGE EXEC SUBTASK CANCELLED - RC = ('SRC'). ***'\n   SAY '***********************************************************************'\n   EXIT SRC\nEND\nRETURN\n/*     */\nREAD_MODULE_MTRCNTL0:\n\"ALLOC DA('\"CCFDSN\"(\"CCFMOD\")') FILE(MTRDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '***********************************************************************'\n   SAY '*** ALLOCATE ERROR: FOR ('CCFDSN'('CCFMOD'). ***'\n   SAY '*** UNABLE TO READ ('CCFMOD') MODULE TRACKING RECORDS. ***'\n   SAY '*** LIBPURGE EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   SAY '***********************************************************************'\n   EXIT SRC\nEND\n\"EXECIO * DISKR MTRDD (STEM MTRDATA. FINIS\"\nSRC = RC\n\"FREE FILE(MTRDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '***********************************************************************'\n   SAY '*** EXECIO ERROR: ('CCFDSN'('CCFMOD'). ***'\n   SAY '*** UNABLE TO READ ('CCFMOD') MODULE TRACKING RECORDS. ***'\n   SAY '*** LIBPURGE EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   SAY '***********************************************************************'\n   EXIT SRC\nEND\nRETURN\n/*     */\nREAD_LIBINDEX:\n\"ALLOC DA('\"LIBINDEX\"') FILE(LBINDEX) OLD\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '***********************************************************************'\n   SAY '*** DATASET ALLOCATE ERROR: ( 'LIBINDEX' ). ***'\n   SAY '*** DATASET IN USE OR UNAVAILABLE - RETURN CODE: (' SRC '). ***'\n   SAY '*** LIBPURGE EXEC SUBTASK CANCELLED. ***'\n   SAY '***********************************************************************'\n   EXIT SRC\nEND\n\"EXECIO * DISKR LBINDEX (STEM DATA. FINIS\"\nSRC = RC\n\"FREE FILE(LBINDEX)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '***********************************************************************'\n   SAY '*** DATASET EXECIO ERROR: ( 'LIBINDEX' ). ***'\n   SAY '*** EXECIO DATASET READ RETURN CODE: (' SRC '). ***'\n   SAY '*** LIBPURGE EXEC SUBTASK CANCELLED. ***'\n   SAY '***********************************************************************'\n   EXIT SRC\nEND\nRETURN\n/*     */\nGET_DELETE_CANDIDATES:\nDO I = 1 TO DATA.0\n   UPDATE_SWITCH = 'YES'\n   VALID_MODULE = POS('$NOJCL',DATA.I)\n   IF VALID_MODULE = 0 THEN ITERATE\n   MODULE = WORD(DATA.I,1)\n   PASSWORD = WORD(DATA.I,2)\n   DATE_ADDED = SUBSTR(DATA.I,49,8)\n   DATE_UPDATED = SUBSTR(DATA.I,59,8)\n   UPDATE_TIME = SUBSTR(DATA.I,68,2)\n   PROGRAMMER = SUBSTR(DATA.I,107,7)\n   NOT_UPDATED = POS('NOT UPDATED',DATA.I)\n   IF NOT_UPDATED > 0 THEN DO\n      UPDATE_SWITCH = 'NO'\n      DATE_UPDATED = 'NOT-UPDATED'\n      UPDATE_TIME = 'NO-UPDATE-TIME'\n   END\n   CALL CHECK_MMR_MODULE\n   IF MMRSW = 'YES' THEN DO\n      DATE_ADDED = MDATE_ADDED\n      UPDATE_TIME = SUBSTR(MTIME_ADDED,1,2)\n      UPDATE_SWITCH = 'YES'\n   END\n   CALL CHECK_MTR_MODULE\n   IF MTRSW = 'YES' THEN DO\n      DATE_ADDED = MDATE_ADDED\n      UPDATE_TIME = SUBSTR(MTIME_ADDED,1,2)\n      UPDATE_SWITCH = 'YES'\n   END\n   PARSE VALUE DATE_ADDED WITH OMM '/' ODD '/' OYY\n   IF CYY > OYY THEN DO\n      ELAPS_YEARS = CYY - OYY\n      IF ELAPS_YEARS > 1 THEN DO\n         CALL QUEUE_RECORD\n         ITERATE\n      END\n      CALL CHECK_UPDATE_TIME\n      IF DELETE_SWITCH = 'NO' THEN DO\n         CALL CONVERT_JULIAN_DATE\n         ELAPS_DAYS = JULDATE - JULDATEO\n         IF ELAPS_DAYS > LDAYS THEN DELETE_SWITCH = 'YES'\n      END\n      IF DELETE_SWITCH = 'YES' THEN CALL QUEUE_RECORD\n      ITERATE\n   END\n   CALL CONVERT_JULIAN_DATE\n   IF JULDATEO = JULDATE THEN ITERATE\n   ELAPS_DAYS = JULDATE - JULDATEO\n   IF ELAPS_DAYS > 1 THEN DO\n      CALL QUEUE_RECORD\n      ITERATE\n   END\n   CALL CHECK_UPDATE_TIME\n   IF DELETE_SWITCH = 'NO' THEN ITERATE\n   CALL QUEUE_RECORD\nEND\nRETURN\n/*     */\nCHECK_MMR_MODULE:\nMMRSW = 'NO'\nDO M = 1 TO MMRDATA.0\n   TOPROD = POS('TO: PROD',MMRDATA.M)\n   IF TOPROD \u00ac= 0 THEN DO\n      MMRMOD = WORD(MMRDATA.M,1)\n      IF MMRMOD = MODULE THEN DO\n         MDATE_ADDED = WORD(MMRDATA.M,7)\n         MTIME_ADDED = WORD(MMRDATA.M,8)\n         MMRSW = 'YES'\n      END\n   END\n   CURRMAST = POS('CURR MASTER:',MMRDATA.M)\n   IF CURRMAST \u00ac= 0 THEN DO\n      EMERGENCY_MASTER = WORD(MMRDATA.M,3)\n      IF EMERGENCY_MASTER = LIBMASTR & MMRSW = 'YES' THEN LEAVE\n      MMRSW = 'NO'\n   END\nEND\nRETURN\n/*     */\nCHECK_MTR_MODULE:\nMTRSW = 'NO'\nIF MMRSW = 'YES' THEN RETURN\nDO M = 1 TO MTRDATA.0\n   LOGSTAMP = POS('LOGOUT STAMP:',MTRDATA.M)\n   IF LOGSTAMP \u00ac= 0 THEN DO\n      MTRMOD = WORD(MTRDATA.M,1)\n      IF MTRMOD = MODULE THEN DO\n         MDATE_ADDED = WORD(MTRDATA.M,6)\n         MTIME_ADDED = WORD(MTRDATA.M,7)\n         MTRSW = 'YES'\n      END\n   END\n   TESTMAST = POS('TEST MASTER:',MTRDATA.M)\n   IF TESTMAST \u00ac= 0 THEN DO\n      EMERGENCY_MASTER = WORD(MTRDATA.M,3)\n      IF EMERGENCY_MASTER = LIBMASTR & MTRSW = 'YES' THEN LEAVE\n      MTRSW = 'NO'\n   END\nEND\nRETURN\n/*     */\nCHECK_UPDATE_TIME:\nDELETE_SWITCH = 'NO'\nIF UPDATE_SWITCH = 'NO' THEN RETURN\nIF UPDATE_TIME < CURHOUR THEN DELETE_SWITCH = 'YES'\nRETURN\n/*     */\nQUEUE_RECORD:\nR = R + 1\nRECORD.R = MODULE PASSWORD DATE_ADDED DATE_UPDATED UPDATE_TIME PROGRAMMER\nRETURN\n/*     */\nCONVERT_JULIAN_DATE:\nD = 0\nNDAYS = 0\nY = 2\nLEAPYR = OYY // 4\nLDAYS = 635\nIF LEAPYR > 0 THEN DO\n   Y = 1\n   LDAYS = 636\nEND\nIMONTH = OMM - 1\nDO IMONTH\n   D = D + 1\n   MDAYS = WORD(NUMDAYS.Y,D)\n   NDAYS = NDAYS + MDAYS\nEND\nNDAYS = NDAYS + ODD\nNDAYS = RIGHT(NDAYS,3,'0')\nJULDATEO = OYY||NDAYS\nRETURN\n/*     */\nBUILD_LIBDELET_JOB:\nJN = WORD(JOBNAMES,C)\nPDSMEMB = WORD(JOBNAMES,C)\nG = G + 1\nLIBJOB.G = PDSMEMB\n\"DELSTACK\"\nJCL.1 = \"//\"JN\"  JOB \"ACCTCDE\",'TECH.SUPP.DANBOWEN',NOTIFY=TECH103,\"\nJCL.2 = \"//             CLASS=P,MSGCLASS=G,MSGLEVEL=(1,1),REGION=6M\"\nJCL.3 = \"//LIBDLM   EXEC PGM=AFOLIBR\"\nJCL.4 = \"//MASTER   DD DSN=SYS1.\"NODE\".MASTER,DISP=SHR\"\nJCL.5 = \"//OSJOB    DD DUMMY\"\nJCL.6 = \"//SYSPRINT DD SYSOUT=*\"\nJCL.7 = \"//LIST     DD SYSOUT=*\"\nJCL.8 = \"//INDEX    DD SYSOUT=*\"\nJCL.9 = \"//SYSIN    DD *\"\nDO J = 1 TO 9\n   QUEUE JCL.J\nEND\nDO R = 1 TO RCDCNT\n   DELMOD = WORD(RECORD.R,1)\n   PASSWORD = WORD(RECORD.R,2)\n   DELRCD = \"-DLM \"DELMOD\",\"PASSWORD\n   QUEUE DELRCD\nEND\nJCL.1 = \"-END\"\nJCL.2 = \"/*\"\nJCL.3 = \"//\"\nDO J = 1 TO 3\n   QUEUE JCL.J\nEND\nRETURN\n/*     */\nBUILD_DELETE_LOADLIB_JOB:\nJ = 7\nLMODSW = 'NO'\nJN = 'PTLL04D'\nPDSMEMB = JN\n\"DELSTACK\"\nJCL.1 = \"//\"JN\" JOB \"ACCTCDE\",'SOURCE.LMOD.DELETE',NOTIFY=TECH103,\"\nJCL.2 = \"//             CLASS=P,MSGCLASS=G,MSGLEVEL=(1,1),REGION=6M\"\nJCL.3 = \"//DELETMEM EXEC PGM=IDCAMS\"\nJCL.4 = \"//BATCHDD  DD DSN=SYS1.EMERGNCY.BATCH.LOADLIB,DISP=SHR\"\nJCL.5 = \"//CICSDD   DD DSN=SYS1.EMERGNCY.CICS.LOADLIB,DISP=SHR\"\nJCL.6 = \"//SYSPRINT DD SYSOUT=*\"\nJCL.7 = \"//SYSIN    DD *\"\nDO R = 1 TO RCDCNT\n   DELMOD = WORD(RECORD.R,1)\n   DO L = 1 TO 2\n      LOADLIB = WORD(LOADLIB.L,1)\n      DSNDD = WORD(LOADLIB.L,2)\n      LMOD = SYSDSN(\"'\"LOADLIB\"(\"DELMOD\")'\")\n      IF LMOD = 'OK' THEN DO\n         LMODSW = 'YES'\n         E = E + 1\n         LLMOD.E = DELMOD\n         J = J + 1\n         JCL.J = \"  DELETE   \"LOADLIB\"(\"DELMOD\")  FILE(\"DSNDD\")\"\n      END\n   END\nEND\nIF LMODSW = 'NO' THEN RETURN\nJCLCNT = J\nDO J = 1 TO JCLCNT\n   QUEUE JCL.J\nEND\nEJCL.1 = \"/*\"\nEJCL.2 = \"//\"\nDO J = 1 TO 2\n   QUEUE EJCL.J\nEND\nRETURN\n/*     */\nCHECK_DELETE_DYLAKOR_LOADMOD:\nADDRESS TSO\nJ = 6\nLMODSW = 'NO'\nJN = 'PTLL05D'\nPDSMEMB = JN\n LIBMASTR = 'SYS1.EMRGSRCE.MASTER'\n\"DELSTACK\"\nJCL.1 = \"//\"JN\" JOB \"ACCTCDE\",'DYLAKOR.LMOD.DELETE',NOTIFY=TECH103,\"\nJCL.2 = \"//             CLASS=P,MSGCLASS=G,MSGLEVEL=(1,1),REGION=6M\"\nJCL.3 = \"//DELETMEM EXEC PGM=IDCAMS\"\nJCL.4 = \"//BATCHDD  DD DSN=SYS1.EMERGNCY.BATCH.LOADLIB,DISP=SHR\"\nJCL.5 = \"//SYSPRINT DD SYSOUT=*\"\nJCL.6 = \"//SYSIN    DD *\"\nLOADLIB = WORD(LOADLIB.1,1)\nDSNDD = WORD(LOADLIB.1,2)\nDO R = 1 TO RCDCNT\n   DELMOD = WORD(RECORD.R,1)\n   M = 1\n   MLEN = LENGTH(DELMOD)\n   PREFIX = SUBSTR(DELMOD,1,MLEN)\n   IF MLEN >= 6 THEN PREFIX = SUBSTR(DELMOD,1,6)\n   LIBDSN = \"'\"LIBMASTR\"(\"DELMOD\")'\"\n   LIBDD = LIBALLOC(LIBDSN)\n   IF LIBDD = \"ERROR\" THEN ITERATE\n   \"EXECIO 1 DISKR\" LIBDD \"(STEM REPORT. FINIS\"\n   SRC = RC\n   \"FREE FILE(\"LIBDD\")\"\n   IF SRC \u00ac= 0 THEN ITERATE\n   REPTFLG = POS('* REPORTS = ',REPORT.1)\n   IF REPTFLG = 0 THEN ITERATE\n   NUMREPTS = WORD(REPORT.1,4)\n   IF NUMREPTS = '' THEN ITERATE\n   RTYP = DATATYPE(NUMREPTS)\n   IF RTYP \u00ac= 'NUM' THEN ITERATE\n   DO M = 1 TO NUMREPTS\n      IF M = 1 THEN ITERATE\n      MLEN = LENGTH(M)\n      IF MLEN = 1 THEN DYLMOD = PREFIX||'0'M\n      IF MLEN = 2 THEN DYLMOD = PREFIX||M\n      LMOD = SYSDSN(\"'\"LOADLIB\"(\"DYLMOD\")'\")\n      IF LMOD = 'MEMBER NOT FOUND' THEN LEAVE\n      LMODSW = 'YES'\n      E = E + 1\n      LLMOD.E = DYLMOD\n      J = J + 1\n      JCL.J = \"  DELETE   \"LOADLIB\"(\"DYLMOD\")  FILE(\"DSNDD\")\"\n   END\nEND\nIF LMODSW = 'NO' THEN RETURN\nJCLCNT = J\nDO J = 1 TO JCLCNT\n   QUEUE JCL.J\nEND\nEJCL.1 = \"/*\"\nEJCL.2 = \"//\"\nDO J = 1 TO 2\n   QUEUE EJCL.J\nEND\nRETURN\n/*     */\nCHECK_UNASSIGNED_LOADMOD:\nADDRESS TSO\nH = 0\nDO S = 1 TO DATA.0\n   SRCEMOD = POS('$NOJCL',DATA.S)\n   IF SRCEMOD = 0 THEN ITERATE\n   SRCEMEM = WORD(DATA.S,1)\n   E = E + 1\n   LLMOD.E = SRCEMEM\nEND\nECNT = E\nDO L = 1 TO 2\n   LOADLIB = WORD(LOADLIB.L,1)\n   M = OUTTRAP(\"MEMBLST.\",\"*\",\"CONCAT\")\n   \"LISTDS ('\"LOADLIB\"') MEMBERS\"\n   IF RC \u00ac= 0 THEN ITERATE\n   IF MEMBLST.0 < 7 THEN ITERATE\n   DO I = 7 TO MEMBLST.0\n      LOADMOD = STRIP(MEMBLST.I)\n      DO E = 1 TO ECNT\n         IF LOADMOD = LLMOD.E THEN DO\n            H = H + 1\n            EXMEMB.H = LOADMOD\n            LEAVE\n         END\n      END\n   END\nEND\nRETURN\n/*     */\nBUILD_DELETE_UNASSIGNED_LOADMOD:\nHCNT = H\nJ = 7\nLMODSW = 'NO'\nJN = 'PTLL06D'\nPDSMEMB = JN\n\"DELSTACK\"\nJCL.1 = \"//\"JN\" JOB \"ACCTCDE\",'UNASSIGN.LMOD.DELETE',NOTIFY=TECH103,\"\nJCL.2 = \"//             CLASS=P,MSGCLASS=G,MSGLEVEL=(1,1),REGION=6M\"\nJCL.3 = \"//DELETMEM EXEC PGM=IDCAMS\"\nJCL.4 = \"//BATCHDD  DD DSN=SYS1.EMERGNCY.BATCH.LOADLIB,DISP=SHR\"\nJCL.5 = \"//CICSDD   DD DSN=SYS1.EMERGNCY.CICS.LOADLIB,DISP=SHR\"\nJCL.6 = \"//SYSPRINT DD SYSOUT=*\"\nJCL.7 = \"//SYSIN    DD *\"\nDO L = 1 TO 2\n   LOADLIB = WORD(LOADLIB.L,1)\n   DSNDD = WORD(LOADLIB.L,2)\n   M = OUTTRAP(\"MEMBLST.\",\"*\",\"CONCAT\")\n   \"LISTDS ('\"LOADLIB\"') MEMBERS\"\n   IF RC \u00ac= 0 THEN ITERATE\n   IF MEMBLST.0 < 7 THEN ITERATE\n   DO I = 7 TO MEMBLST.0\n      LOADMOD = STRIP(MEMBLST.I)\n      DELETSW = 'YES'\n      DO H = 1 TO HCNT\n         IF LOADMOD = EXMEMB.H THEN DELETSW = 'NO'\n      END\n      IF DELETSW = 'NO' THEN ITERATE\n      LMODSW = 'YES'\n      J = J + 1\n      JCL.J = \"  DELETE   \"LOADLIB\"(\"LOADMOD\")  FILE(\"DSNDD\")\"\n   END\nEND\nIF LMODSW = 'NO' THEN RETURN\nJCLCNT = J\nDO J = 1 TO JCLCNT\n   QUEUE JCL.J\nEND\nEJCL.1 = \"/*\"\nEJCL.2 = \"//\"\nDO J = 1 TO 2\n   QUEUE EJCL.J\nEND\nRETURN\n/*     */\nBUILD_JOURNAL_MEMBER:\nPDSMEMB = WORD(LIBNODES,C)\nDO R = 1 TO RCDCNT\n   QUEUE RECORD.R\nEND\nRETURN\n/*     */\nWRITE_PDS_MEMBER:\nCALL ALLOC_CNTLLIB\nNUMRCDS = QUEUED()\n\"EXECIO\" NUMRCDS \"DISKW LBCNTL (FINIS\"\nSRC = RC\n\"FREE FILE(LBCNTL)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '***********************************************************************'\n   SAY '*** PDS WRITE ERROR: ('CCFDSN'('PDSMEMB'). ***'\n   SAY '*** EXECIO WRITE RETURN CODE: (' SRC '). ***'\n   SAY '*** LIBPURGE EXEC SUBTASK CANCELLED. ***'\n   SAY '***********************************************************************'\n   EXIT SRC\nEND\nRETURN\n/*     */\nALLOC_CNTLLIB:\n\"ALLOC DA('\"CCFDSN\"(\"PDSMEMB\")') FILE(LBCNTL) OLD\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '***********************************************************************'\n   SAY '*** DATASET ALLOCATE ERROR: ('CCFDSN'('PDSMEMB'). **'\n   SAY '*** DATASET IN USE OR UNAVAILABLE - RETURN CODE: (' SRC '). ***'\n   SAY '*** LIBPURGE EXEC SUBTASK CANCELLED. ***'\n   SAY '***********************************************************************'\n   EXIT SRC\nEND\nRETURN\n/*     */\nSUBMIT_LIBDELET_JOB:\n\"SUBMIT '\"CCFDSN\"(\"PDSMEMB\")'\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '***********************************************************************'\n   SAY '*** SUBMIT ERROR: MEMBER ('CCFDSN'('PDSMEMB'). ***'\n   SAY '*** LIBPURGE EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   SAY '***********************************************************************'\n   EXIT SRC\nEND\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LIBRINIT": {"ttr": 14598, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x10\\x00\\x00\\x00\\x94\"O\\x00\\x94&O\\x11F\\x00l\\x00e\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf3@@@'", "ispf": {"version": "01.16", "flags": 0, "createdate": "1994-08-12T00:00:00", "modifydate": "1994-09-21T11:46:00", "lines": 108, "newlines": 101, "modlines": 0, "user": "TECH103"}, "text": "/*  REXX EXEC : ( LIBRINIT ).\n    FUNCTION  : BUILD JCL JOBSTREAM TO ALLOCATE/FORMAT A CCF LIBRARIAN\n                MASTER DATASET.\n                OUTPUT JOB WILL BE SUBMITTED TO SYSA SYSTEM CLASS=S\n                FOR EXECUTION.\n    AUTHOR    : DAN BOWEN, MIS,TECH SERVICES.\n                                                                    */\nTRACE O\n/*      */\nHOUSE_KEEPING:\nADDRESS TSO\nHLQ = 'SYS1'\nLLQ = 'MASTER'\nVOL = 'LIBR01'\nLNODE1 = 'ARCH BACK EMRG HIST PROD QA RJCT TECH TEST TURN'\nLNODE2 = 'COPY JCL PROC RAMI SRCE SYSI TABLE WRITER SYSTEM.CONTROL'\nLIBLOCK = '2942 1086 7548 1086 27998 1086 4136 13682 2942'\nACCTCDE = '5304010530000000'\nMVS = 'SYSA'\nCLASS= 'S'\nX = MSG(\"OFF\")\n\"FREE FILE(LIBDD)\"\nADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\n/*\n      M A I N   R O U T I N E   S E C T I O N         */\n/*     */\nDISPLAY_LIBPARM_PANEL:\nDO FOREVER\n   ADDRESS ISPEXEC\n   \"DISPLAY PANEL(LIBRPANL)\"\n   SRC = RC\n   IF SRC = 8 THEN EXIT 0\n   IF SRC > 8 THEN DO\n      SAY '*** ERROR INVOKING ISPF DIALOG PANEL ( LIBRPANL ). ***'\n      SAY '*** LIBRINIT EXEC TASK CANCELLED - RC = 'SRC'. ***'\n      EXIT SRC\n   END\n   CALL BUILD_SKELETON_PARMS\n   CALL SUBMIT_JOB\nEND\nEXIT 0\n/*\n       S U B R O U T I N E S   S E C T I O N     */\n/*     */\nBUILD_SKELETON_PARMS:\nJOBNAME = JN\nMEMBER = JN\nALLOC = SPACE\nLIBVOL = VOL\nSKELJCL = 'LIBRSKL1'\nNODE2A = WORD(LNODE1,N1)\nNODE2B = WORD(LNODE2,N2)\nMLQ = NODE2A||NODE2B\nIF N2 > 6 THEN MLQ = NODE2B\nMASTER = HLQ'.'MLQ'.'LLQ\nNEWMSTR = HLQ'.'MLQ'.NEW.'LLQ\nSAVMSTR = HLQ'.'MLQ'.SAVE.'LLQ\nBLKSIZE = WORD(LIBLOCK,N2)\nSEQNR = '81,6,10,10'\nIF (NODE2A = 'HIST') | (NODE2B = 'SYSTEM.CONTROL') THEN DO\n   BLKSIZE = '2942'\n   SKELJCL = 'LIBRSKL2'\nEND\nIF NODE2B = 'SRCE' THEN SEQNR = '73,8,10,10'\nRETURN\n/*     */\nSUBMIT_JOB:\nADDRESS ISPEXEC\n\"FTOPEN TEMP\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   ZERRMSG = $LIBR002\n   \"SETMSG MSG($LIBR002)\"\n   RETURN\nEND\n\"FTINCL $CCFLJOB\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   ZERRMSG = $LIBR003\n   \"SETMSG MSG($LIBR003)\"\n   RETURN\nEND\n\"FTINCL\" SKELJCL\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   ZERRMSG = $LIBR004\n   \"SETMSG MSG($LIBR004)\"\n   RETURN\nEND\n\"FTCLOSE\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   ZERRMSG = $LIBR005\n   \"SETMSG MSG($LIBR005)\"\n   RETURN\nEND\n\"VGET ZTEMPF\"\nADDRESS TSO \"SUBMIT '\"ZTEMPF\"'\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   ZERRMSG = $LIBR006\n   \"SETMSG MSG($LIBR006)\"\n   RETURN\nEND\nADDRESS ISPEXEC\nZERRMSG = $LIBR001\n\"SETMSG MSG($LIBR001)\"\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LINKLIST": {"ttr": 14601, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x91\\x16_\\x00\\x91\\x16_\\x14I\\x00\\r\\x00\\x0c\\x00\\x01\\xd1\\xc5\\xc6\\xc6\\xd2@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1991-06-14T00:00:00", "modifydate": "1991-06-14T14:49:00", "lines": 13, "newlines": 12, "modlines": 1, "user": "JEFFK"}, "text": "/* REXX LINKLIST locate element */\naddress \"TSO\";\n\"VMFCLEAR\";\ncvtptr = storage(\"00000010\",4); /* locate llt from cvt */\ncvtllta = d2x(c2d(cvtptr)+1244); /* mapping ihallt */\nllta = c2d(storage(cvtllta,4));\nlltacount = c2d(storage(d2x(llta+4),4));\nlltaentry = d2x(llta+9); /* entry ptr */\ndo i = 1 to lltacount;\n     say strip(storage(lltaentry,44));\n     lltaentry = d2x(x2d(lltaentry)+45);\nend;\nexit 0;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LLAUP": {"ttr": 14603, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x16\\x00\\x00\\x00\\x910\\x8f\\x00\\x92'o\\x17H\\x009\\x00\\x0c\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf1\\xf0@@@\"", "ispf": {"version": "01.22", "flags": 0, "createdate": "1991-11-04T00:00:00", "modifydate": "1992-10-02T17:48:00", "lines": 57, "newlines": 12, "modlines": 0, "user": "TECH110"}, "text": "/* REXX automatic LLA update command */\nparse upper arg dsname . ;\nif dsname=\"\" then do;\n     say \"Invalid dsname argument passed\";\n     exit 0;\n     end;\nif substr(dsname,1,1)=\"'\" then , /* strip enclose quotes */\n     dsname=substr(dsname,2,length(dsname)-2);\n\"ALLOC F(INPUT) DA('SYS1.PARMLIB(CSVLLASS)') SHR\";\n\"EXECIO * DISKR INPUT (FINIS STEM LLADATA.\";\n\"FREE F(INPUT)\";\nparmlib_suffix = \"\";\ndo i = 1 to lladata.0;\n    parse var lladata.i \"/*\" \"SUFFIX(\" parmsufx \")\" sufdsn \"*/\";\n    parmsufx=strip(parmsufx); sufdsn=strip(sufdsn);\n    if sufdsn=dsname then do;\n          parmlib_suffix=parmsufx;\n          leave i;\n          end;\nend;\ncvtptr = storage(\"00000010\",4); /* locate llt/smca from cvt */\ncvtsmca = storage(d2x(c2d(cvtptr)+196),4); /* mapping smca */\nsavehi=substr(c2x(cvtsmca),1,2);\nsmcasid = savehi||d2x(x2d(substr(c2x(cvtsmca),3))+16);\nsmcasid = storage(smcasid,4); /* SMF id */\nif parmlib_suffix=\"\" then do;\ncvtllta = d2x(c2d(cvtptr)+1244); /* mapping ihallt */\nllta = c2d(storage(cvtllta,4));\nlltacount = c2d(storage(d2x(llta+4),4));\nlltaentry = d2x(llta+9); /* entry ptr */\ndo i = 1 to lltacount;\n     lnkdsn= strip(storage(lltaentry,44));\n     if dsname=lnkdsn then do;\n         parmlib_suffix=\"00\";\n         leave i; end;\n     lltaentry = d2x(x2d(lltaentry)+45);\nend;\nif parmlib_suffix=\"\" then do;\n     say \"Invalid dsname argument passed\";\n     exit 0;\n     end;\n     end;\nif parmlib_suffix = \"00\" then ,\n   say \"LinkList dataset is being LLA-refreshed\";\n   else ,\n   say \"Non-LinkList dataset is being LLA-refreshed\";\n   say \"Please LLAUP refresh on ALL other running systems\";\ncommand = \"F LLA,UPDATE=\"parmlib_suffix;\n\"CONSOLE SYSCMD(\"command\")\";\nselect;\n  when (smcasid=\"SYSA\") then sysid=\"2\"; /* other side */\n  when (smcasid=\"SYSB\") then sysid=\"1\";\n  otherwise sysid = \"\";\nend;\ncommand = \"$M\"sysid\",'\"command\"'\";\nif sysid\u00ac=\"\" then \"CONSOLE SYSCMD(\"command\")\";\nexit 0;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LOGOFF": {"ttr": 14605, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x19\\x00\\x00\\x00\\x91\\x17/\\x00\\x91\\x17/\\x113\\x00\\x05\\x00\\x02\\x00\\x04\\xd1\\xc5\\xc6\\xc6\\xd2@@@@@'", "ispf": {"version": "01.25", "flags": 0, "createdate": "1991-06-21T00:00:00", "modifydate": "1991-06-21T11:33:00", "lines": 5, "newlines": 2, "modlines": 4, "user": "JEFFK"}, "text": "/* REXX Logoff function */\naddress \"ISPEXEC\" \"CONTROL NONDISPL END\";        /* Panel nondisplay */\naddress \"ISPEXEC\" \"SELECT PANEL(@DUMMY) OPT(X)\"; /* ZPRIM = X        */\naddress \"TSO\" \"LOGOFF\";                          /* Stack LOGOFF     */\nexit 0;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LOGOFFON": {"ttr": 14607, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x91\\x17/\\x00\\x91\\x17/\\x113\\x00\\x05\\x00\\x04\\x00\\x02\\xd1\\xc5\\xc6\\xc6\\xd2@@@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1991-06-21T00:00:00", "modifydate": "1991-06-21T11:33:00", "lines": 5, "newlines": 4, "modlines": 2, "user": "JEFFK"}, "text": "/* REXX Logoffon function */\naddress \"ISPEXEC\" \"CONTROL NONDISPL END\";        /* Panel nondisplay */\naddress \"ISPEXEC\" \"SELECT PANEL(@DUMMY) OPT(X)\"; /* ZPRIM = X        */\naddress \"TSO\" \"ALLOC F(NOALLOC) DUMMY\";          /* Stack profil flag*/\nexit 0;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LOGON": {"ttr": 14609, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x91\\x17/\\x00\\x91\\x17/\\x113\\x00\\x05\\x00\\x04\\x00\\x01\\xd1\\xc5\\xc6\\xc6\\xd2@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1991-06-21T00:00:00", "modifydate": "1991-06-21T11:33:00", "lines": 5, "newlines": 4, "modlines": 1, "user": "JEFFK"}, "text": "/* REXX Logon function */\naddress \"ISPEXEC\" \"CONTROL NONDISPL END\";        /* Panel nondisplay */\naddress \"ISPEXEC\" \"SELECT PANEL(@DUMMY) OPT(X)\"; /* ZPRIM = X        */\naddress \"TSO\" \"LOGON\" userid();                  /* Stack re-LOGON   */\nexit 0;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LOOKCMDS": {"ttr": 14611, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x13\\x00\\x00\\x00\\x91 \\x7f\\x00\\x91 \\x7f\\x107\\x00\\x19\\x00\\x07\\x00\\x18\\xd1\\xc5\\xc6\\xc6\\xd2@@@@@'", "ispf": {"version": "01.19", "flags": 0, "createdate": "1991-07-26T00:00:00", "modifydate": "1991-07-26T10:37:00", "lines": 25, "newlines": 7, "modlines": 24, "user": "JEFFK"}, "text": "/* REXX Look at an ISPF command application table              */\ntrue  = 1;\nfalse = 0;\neof = false;\nnull = \"\";\nuid = userid();\naddress \"ISPEXEC\";\ndsname = uid\".USER.CNTLLIB\";\naddress \"TSO\" \"ALLOC F(DDLOOK) DA('\"dsname\"(FILECMDS)') OLD\";\n\"TBTOP  ISPCMDS\";\ni = 0;\ndo while (\u00aceof);\n   \"TBSKIP ISPCMDS\";\n   \"TBGET  ISPCMDS\";\n    if rc\u00ac=0 then do;\n         eof = true;\n         iterate;\n         end;\n    i = i+1;\n    outrec.i=left(\"Verb:\"left(zctverb,9)\"Trunc:\"left(zcttrunc,2)|| ,\n         \"Act:\"zctact,80);\nend;\naddress \"TSO\" \"EXECIO * DISKW DDLOOK (FINIS STEM OUTREC.\";\nsay \"Output is in dsname \"dsname\"(FILECMDS)\";\nexit 0;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "LPAR": {"ttr": 14613, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x00\\x00\\x00\\x91\\x16_\\x00\\x932\\x8f\\x142\\x00\\x16\\x00\\x05\\x00\\x12\\xe3\\xc5\\xc3\\xc8\\xf1\\xf1\\xf0@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "1991-06-14T00:00:00", "modifydate": "1993-11-24T14:32:00", "lines": 22, "newlines": 5, "modlines": 18, "user": "TECH110"}, "text": "/* REXX Identify LPAR exec */\npsapccav = c2x(storage(00000208,4)); /* pcca ptr */\npccacpid = d2x(x2d(psapccav)+4); /* pccacpid ptr */\ncpuid = storage(pccacpid,12); /* cpuid */\nparse var cpuid vv 3 lp 5 ssss 9 model; /* slit out components */\nparse var lp prcsr 2 domain;\nselect;\n   when (lp=\"40\" | lp=\"60\") then p=\"SYSA - System 'A' - Production \";\n   when (lp=\"80\" | lp=\"A0\") then p=\"SYSB - System 'B' - Production \";\n   when (lp=\"08\" | lp=\"28\") then p=\"SYSM - System 'M' - Maintenance\";\n   when domain=\"1\" then p=\"SYSP - System 'P' - Production \";\n   when domain=\"2\" then p=\"SYST - System 'T' - Test       \";\n   when domain=\"3\" then p=\"SYSM - System 'M' - Maintenance\";\n   when domain=\"5\" then p=\"SYSM - System 'M' - Maintenance\";\n   when domain=\"6\" then p=\"SYSA - System 'A' - Production \";\n   when domain=\"7\" then p=\"SYSB - System 'B' - Production \";\n   otherwise p = \"????????\";  /* true lparname */\nend;\nsay \"Vers             Logical Domain            Ser#  Model\";\nsay \"----   ----------------------------------- ----  -----\";\nsay \" \"vv\"        \"p                                  ssss\"  \"model;\nexit 0;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MAINVIEW": {"ttr": 14849, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x93#\\x0f\\x00\\x93#\\x0f\\x16\\x18\\x02\\x12\\x02\\x11\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf5@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1993-08-18T00:00:00", "modifydate": "1993-08-18T16:18:00", "lines": 530, "newlines": 529, "modlines": 0, "user": "TECH105"}, "text": "        PROC 0 PREFIX('SYS1.BABBAGE.V4R3M0') +\n               PREFX1('SYSS.BABBAGE.V4R3M0') +\n               SS()             /* BBI-SS ID                      */ +\n               PROFILE(YES)     /* USER DATASETS                  */ +\n               IMAGE(NO)        /* IMAGE LOGGING                  */ +\n               JOURNAL(YES)     /* JOURNAL LOGGING                */ +\n               PRINT(YES)       /* SCREEN PRINTING                */ +\n               UPREFIX()        /* PROFILE PREFIX                 */ +\n               ALLOCATE                                              +\n               T(CALL)\n\n        /*------------------------------------------------------------*/\n        /* SOURCE: BAIMAINV                                           */\n        /*                                                            */\n        /*                                                            */\n        /* IF REQUIRED, THIS CLIST MAY BE MODIFIED.  COMMENTS HAVE    */\n        /* BEEN INCLUDED TO AID YOU IN EVALUATING EACH SECTION.       */\n        /*                                                            */\n        /*           USE OF SYMBOLICS SHOWN ABOVE                     */\n        /*                                                            */\n        /*                                                            */\n        /* PREFIX  - HIGH-LEVEL QUALIFIER OF THE DATA SETS USED       */\n        /*                                                            */\n        /* SS      - 1 TO 4 CHARACTER ID OF THE B&B SUBSYSTEM WITH    */\n        /*           WHICH THE TERMINAL SESSION IS TO CONNECT.        */\n        /*           REQUIRED FOR FOCAL POINT, AUTOOPERATOR,          */\n        /*           MAINVIEW FOR CICS, MAINVIEW FOR DB2,             */\n        /*           MAINVIEW FOR IMS,  BUT IGNORED FOR OTHER         */\n        /*           PRODUCTS.                                        */\n        /*                                                            */\n        /* PROFILE - YES/NO.  SPECIFIES IF USER PROFILE DATA SET      */\n        /*           SHOULD BE ALLOCATED.  IF NOT ALLOCATED, THE      */\n        /*           COMMON PROFILE DATA SETS WILL BE SHARED.         */\n        /*                                                            */\n        /* IMAGE   - YES/NO.  SPECIFIES IF USER IMAGE LOG DATA SET    */\n        /*           SHOULD BE ALLOCATED.                             */\n        /*           OPTIONAL FOR FOCAL POINT,                        */\n        /*           MAINVIEW FOR CICS, MAINVIEW FOR DB2,             */\n        /*           MAINVIEW FOR IMS,  BUT IGNORED FOR OTHER         */\n        /*           PRODUCTS.                                        */\n        /*                                                            */\n        /* JOURNAL - YES/NO.  SPECIFIES IF USER JOURNAL DATA SET      */\n        /*           SHOULD BE ALLOCATED.                             */\n        /*           OPTIONAL FOR FOCAL POINT, AUTOOPERATOR,          */\n        /*           MAINVIEW FOR CICS, MAINVIEW FOR DB2,             */\n        /*           MAINVIEW FOR IMS,  BUT IGNORED FOR OTHER         */\n        /*           PRODUCTS.                                        */\n        /*                                                            */\n        /* PRINT   - YES/NO.  SPECIFIES IF USER SCREEN PRINT DATA SET */\n        /*           SHOULD BE ALLOCATED.                             */\n        /*           OPTIONAL FOR FOCAL POINT, AUTOOPERATOR,          */\n        /*           MAINVIEW FOR CICS, MAINVIEW FOR DB2,             */\n        /*           MAINVIEW FOR IMS,  BUT IGNORED FOR OTHER         */\n        /*           PRODUCTS.                                        */\n        /*                                                            */\n        /* UPREFIX - SPECIFIES THE PREFIX OF THE USER PROFILE DATA    */\n        /*           SET, BBIPROF.  THIS DATA SET CONTAINS TERMINAL   */\n        /*           SESSION DEFAULTS AND SAVED USER PROFILES.  THIS  */\n        /*           CLIST WILL CREATE ONE IF IT DOES NOT EXIST.      */\n        /*           IF A VALUE IS NOT SPECIFIES, DEFAULT IS CURRENT  */\n        /*           TSO USER PREFIX.                                 */\n        /*                                                            */\n        /* ALLOCATE- IF SPECIFIED, WILL FORCE REALLOCATION.           */\n        /*                                                            */\n        /* T       - USED ONLY IF YOUR BOOLE AND BABBAGE SUPPORT      */\n        /*           REPRESENTATIVE REQUESTS THAT YOU SPECIFY A VALUE.*/\n        /*                                                            */\n        /*------------------------------------------------------------*/\n\n            CONTROL NOMSG NOFLUSH\n            SET &SYSASIS = ON\n\n            IF &STR(&UPREFIX) = &STR() THEN DO\n              IF &STR(&SYSPREF) =                OR   +\n                 &STR(&SYSUID)  = &STR(&SYSPREF) THEN +\n                   SET &UPREFIX = &SYSUID\n              ELSE SET &UPREFIX = &STR(&SYSPREF..&SYSUID)\n              END\n\n            FREE DD(IMFSSDM  IMFSPRNT) /* IN CASE LEFT FROM 2.5.0 RUN */\n            FREE DD(IMFPROF  IMFLOAD ) /* IN CASE LEFT FROM 2.5.0 RUN */\n            FREE DD(IMFJRNL1 IMFIMAG1) /* IN CASE LEFT FROM 2.5.0 RUN */\n\n        /*------------------------------------------------------------*/\n        /*  DETERMINE ENTRY POINT                                     */\n        /*------------------------------------------------------------*/\n\n            IF &SYSDSN('&PREFIX..BBLINK(TSLOAD)') EQ OK THEN +\n               SET &BBI  = YES\n            IF &SYSDSN('&PREFIX..BBLINK(BBM9TC20)') EQ OK THEN +\n               SET &BBM = YES\n\n            IF &BBM = YES THEN SET &ENTRY = BBM9TC20\n            IF &BBI = YES THEN SET &ENTRY = TSLOAD\n\n        /*------------------------------------------------------------*/\n        /*  FORCE ALLOCATION?                                         */\n        /*------------------------------------------------------------*/\n\n            IF &ALLOCATE = ALLOCATE THEN GOTO ALLOCIT\n\n        /*------------------------------------------------------------*/\n        /*                                                            */\n        /*  CALL MAINVIEW                                             */\n        /*      DURING STARTUP, MAINVIEW CHECKS TO ENSURE THAT        */\n        /*      CERTAIN DATASETS ARE ALLOCATED (BBILOAD, PNLLIB,      */\n        /*      MSGLIB, AND BBIPROF) AND IF THEY ARE NOT, IT          */\n        /*      EXITS WITH A RETURN CODE OF 8. THUS, THE RETURN       */\n        /*      CODES FROM MAINVIEW ARE AS FOLLOWS:                   */\n        /*                                                            */\n        /*        0  - MAINVIEW SESSION ENDED NORMALLLY               */\n        /*        8  - SOME REQUIRED ALLOCATION WAS NOT FOUND         */\n        /*             IN THE TIOT. CHECK THE ALLOCATIONS AND         */\n        /*             TRY AGAIN.                                     */\n        /*       20  - SEVERE ERROR                                   */\n        /*                                                            */\n        /*------------------------------------------------------------*/\n\n        MAINLOOP: +\n            &T '&PREFIX..BBLINK(&ENTRY)' '&SS'\n            SET &CC = &LASTCC\n            IF &CC EQ  8 THEN GOTO ALLOCIT\n            IF &CC EQ 12 THEN GOTO RC12\n            IF &CC NE  0 THEN WRITE ERROR IN TSLOAD, RC = &CC\n            GOTO FINI\n\n        /*------------------------------------------------------------*/\n        /*  RETURN CODE 12 FROM CALL                                  */\n        /*------------------------------------------------------------*/\n\n        RC12: +\n            WRITE ENTRY POINT '&ENTRY' NOT FOUND IN '&PREFIX..BBLINK'\n            GOTO FINI\n\n\n        /*------------------------------------------------------------*/\n        /*                                                            */\n        /*  ALLOCATE REQUIRED DATASETS                                */\n        /*                                                            */\n        /*  NOTE: THIS CLIST IS DESIGNED TO BE CALLED MULTIPLE        */\n        /*        TIMES UNDER ISPF. SINCE IT WOULD BE WASTEFULL       */\n        /*        OF USER AND CPU TIME TO REALLOCATE THE DATASETS     */\n        /*        EACH TIME IT IS CALLED, AND THE ALLOCATED DATASETS  */\n        /*        MIGHT BE IN USE ON THE OTHER SIDE OF A SPLIT        */\n        /*        SCREEN, THIS CLIST IS DESIGNED TO ONLY DO THE       */\n        /*        ALLOCATIONS IN TWO CASES:                           */\n        /*                                                            */\n        /*          1) IF BBILOAD, MSGLIB, PNLLIB, OR BBIPROF HAVE    */\n        /*             NOT BEEN ALLOCATED.                            */\n        /*                                                            */\n        /*          2) IF THIS CLIST IS CALLED WITH THE \"ALLOCATE\"    */\n        /*             PARAMETER.                                     */\n        /*                                                            */\n        /*        NOTE THAT YOU CANNOT FORCE THE ALLOCATIONS IF       */\n        /*        MAINVIEW IS IN USE ON THE OTHER SIDE OF A SPLIT     */\n        /*        SCREEN. YOU MUST LEAVE AND REENTER ISPF, THEN       */\n        /*        CALL MAINVIEW AGAIN WITH THE ALLOCATE PARAMETER.    */\n        /*        NORMALLY, YOU WOULD NOT NEED TO DO THIS. THE        */\n        /*        ALLOCATION PARAMETER IS PROVIDED IN CASE YOU        */\n        /*        CHANGE THE ALLOCATIONS, AND WANT TO RESTART         */\n        /*        MAINVIEW WITHOUT LOGGING OFF.                       */\n        /*                                                            */\n        /*------------------------------------------------------------*/\n\n        ALLOCIT: +\n            IF &A = YES THEN DO                   /* LOOP PREVENTION */\n              WRITE\n              WRITE Error allocating datasets - SESSION TERMINATED\n              WRITE\n              GOTO FINI\n              END\n            SET &A = YES\n            FREE DD(BBISSDM BBISPRNT)\n\n        /*------------------------------------------------------------*/\n        /*  IF NO BBI PRODUCTS ARE INSTALLED, THEN IMAGE, JOURNAL     */\n        /*  AND PRINT DATASET ARE NOT NEEDED.                         */\n        /*------------------------------------------------------------*/\n\n            IF &BBI NE YES THEN DO\n               SET &IMAGE   = NO\n               SET &JOURNAL = NO\n               SET &PRINT   = NO\n               END\n\n        /*------------------------------------------------------------*/\n        /*                                                            */\n        /*  IF THE PROFILE OPTION IS YES, THEN ALLOCATE THE USER      */\n        /*  PROFILE DATA SET. IF ONE DOES NOT EXIST, THE USER IS      */\n        /*  QUERIED AS TO HOW TO PROCEED.                             */\n        /*                                                            */\n        /*  IF THE PROFILE OPTION IS NO, THE COMMON PROFILE DATA SET  */\n        /*  WILL BE THE ONLY DATA SET ALLOCATED FOR THIS USER.        */\n        /*                                                            */\n        /*------------------------------------------------------------*/\n\n        PLOOP: +\n            SET &VDEFDSNS =\n            SET &SDEFDSNS =\n            IF &SYSDSN('&PREFX1..SBBVDEF')  EQ OK THEN +\n              SET &VDEFDSNS = &STR('&PREFX1..SBBVDEF')\n            IF &SYSDSN('&PREFX1..SBBSDEF')  EQ OK THEN +\n              SET &SDEFDSNS = &STR('&PREFX1..SBBSDEF')\n            SET &PROFDSNS = &STR('&PREFX1..BBPROF')\n            IF &SYSDSN('&PREFX1..SBBPROF')  EQ OK THEN +\n              SET &PROFDSNS = &STR('&PREFX1..SBBPROF' &PROFDSNS)\n\n            IF &SUBSTR(1:1,&PROFILE ) NE Y THEN DO\n              IF &BBM EQ YES THEN DO\n                FREE  DD(BBVDEF BBSDEF)\n                IF &VDEFDSNS \u00ac=    THEN +\n                  ALLOC DD(BBVDEF) DS(&VDEFDSNS) SHR\n                IF &SDEFDSNS \u00ac=    THEN +\n                  ALLOC DD(BBSDEF) DS(&SDEFDSNS) SHR\n                END\n              FREE  DD(BBIPROF)\n              ALLOC DD(BBIPROF) DS(&PROFDSNS) SHR\n              END\n\n            ELSE DO\n              IF &BBI EQ YES THEN DO\n                FREE  DD(BBIPROF)\n                ALLOC DD(BBIPROF) DS('&UPREFIX..BBPROF') SHR\n                SET &ERC = &LASTCC\n\n                IF &ERC NE 0 THEN DO\n                  WRITE\n                  WRITE\n                  WRITE Unable to allocate '&UPREFIX..BBPROF'.\n                  WRITE\n                  WRITE The user profile dataset is required.  It holds\n                  WRITE information unique to your BBI/TS session, such\n                  WRITE as PFKEY settings, your default target and\n                  WRITE other such things.\n                  WRITE\n                  WRITE\n                  WRITENR WOULD YOU LIKE THIS CLIST TO CREATE IT? +\n                          (ENTER YES OR EXIT)\n                  SET &SYSASIS = OFF\n                  READ &ANS\n                  SET &SYSASIS = ON\n\n                  IF &SUBSTR(1,&ANS ) EQ N THEN EXIT\n                  IF &SUBSTR(1,&ANS ) EQ E THEN EXIT\n                  IF &SUBSTR(1,&ANS ) NE Y THEN GOTO PLOOP\n\n                  WRITE\n                  WRITENR SPECIFY VOLUME FOR ALLOCATION +\n                          (OR JUST PRESS ENTER FOR DEFAULT VOLUME)\n                  SET &SYSASIS = OFF\n                  READ &VOL\n                  SET &SYSASIS = ON\n                  IF &STR(&VOL) NE    THEN SET &VOL = &STR(VOL(&VOL))\n\n                  CONTROL MSG\n                  ALLOC DD(BBIPROF) DS('&UPREFIX..BBPROF') +\n                        CAT TRACK SPACE(15 5) &VOL DIR(5)  +\n                        RECFM(F B) LRECL(80) BLK(6160)\n                  SET &ERC = &LASTCC\n                  CONTROL NOMSG\n\n                  IF &ERC NE 0 THEN DO\n                    WRITE\n                    WRITE &STR(** Error allocating BBPROF;  **)\n                    WRITE &STR(** Correct problem and retry **)\n                    WRITE\n                    END /* ERC IF*/\n\n                  GOTO PLOOP\n                  END\n\n                SET &PROFDSNS = &STR('&UPREFIX..BBPROF' &PROFDSNS)\n                END   /* END IF &BBI = YES */\n\n              IF &BBM EQ YES THEN DO\n                IF &SYSDSN('&UPREFIX..BBVDEF') EQ OK THEN +\n                  SET &VDEFDSNS = &STR('&UPREFIX..BBVDEF' &VDEFDSNS)\n                IF &SYSDSN('&UPREFIX..BBSDEF') EQ OK THEN +\n                  SET &SDEFDSNS = &STR('&UPREFIX..BBSDEF' &SDEFDSNS)\n\n                FREE  DD(BBVDEF,BBSDEF)\n                IF &VDEFDSNS \u00ac=    THEN +\n                  ALLOC DD(BBVDEF)  DS(&VDEFDSNS) SHR\n                IF &SDEFDSNS \u00ac=    THEN +\n                  ALLOC DD(BBSDEF)  DS(&SDEFDSNS) SHR\n                END   /* END IF &BBM = YES */\n\n              FREE  DD(BBIPROF)\n              ALLOC DD(BBIPROF) DS(&PROFDSNS) SHR\n              END /* IF PROFILE = Y */\n\n        /*------------------------------------------------------------*/\n        /*                                                            */\n        /*  FREE UP ALL ALLOCATIONS INITIALLY AND THEN ALLOCATE THE   */\n        /*  DATA SETS THAT ARE ALWAYS NEEDED.                         */\n        /*                                                            */\n        /*------------------------------------------------------------*/\n\n            FREE DD(PNLLIB,MSGLIB,BBILOAD,BBIIMAG1,BBIJRNL1,SYSUDUMP)\n            FREE DD(ABNLDUMP)\n\n            ALLOC DD(ABNLDUMP) DUMMY             /* DISABLE ABENDAID */\n            ALLOC DD(SYSUDUMP) SYSOUT(A) HOLD\n\n            CONTROL MSG FLUSH\n\n            ALLOC DD(PNLLIB)  DS('&PREFX1..BBPPLIB') SHR\n            ALLOC DD(MSGLIB)  DS('&PREFX1..BBMLIB') SHR\n\n            CONTROL NOMSG NOFLUSH\n            ALLOC DD(BBILOAD) DS('&PREFIX..BBLINK') SHR\n\n            FREE DD(BBILINK)\n            ALLOC DD(BBILINK) DS('&PREFIX..BBLINK') SHR\n\n            FREE DD(BBTLIB)\n            ALLOC DD(BBTLIB)  DS('&PREFX1..BBTLIB') SHR\n\n            FREE DD(BBCLIB)\n            ALLOC DD(BBCLIB)  DS('&PREFX1..BBCLIB') SHR\n\n        /*------------------------------------------------------------*/\n        /*                                                            */\n        /*  IF THE JOURNAL OPTION IS YES, THEN ALLOCATE THE USER      */\n        /*  JOURNAL DATA SET.  IF ONE DOES NOT EXIST, THE USER        */\n        /*  IS QUERIED AS TO HOW TO PROCEED.                          */\n        /*                                                            */\n        /*------------------------------------------------------------*/\n\n            IF &SUBSTR(1:1,&JOURNAL ) EQ Y THEN DO\n              ALLOC DD(BBIJRNL1) DS('&UPREFIX..BBIJRNLL') SHR\n              IF &LASTCC NE 0 THEN DO\n                WRITE\n                WRITE\n                WRITE Unable to allocate '&UPREFIX..BBIJRNLL'\n                WRITE\n                WRITE The journal dataset is optional.\n                WRITE It will contain a log of commands issued by your\n                WRITE MAINVIEW session. The journal can be viewed by\n                WRITE specifying 'LOCAL' in the target field of the LOG\n                WRITE display panel. Various other commands will\n                WRITE automatically return their output to this log. If\n                WRITE you skip allocating this dataset, these commands\n                WRITE will behave as no-ops.  You will still be able to\n                WRITE view the 'GLOBAL' SS log even if you do not\n                WRITE allocate this dataset.\n                WRITE\n                WRITE\n                WRITE Would you like this CLIST to create it?\n                WRITENR (ENTER 'YES' OR PRESS ENTER TO SKIP)\n                SET &SYSASIS = OFF\n                READ &ANS\n                SET &SYSASIS = ON\n\n                IF &SUBSTR(1,&ANS ) EQ   THEN GOTO JLOOP\n                IF &SUBSTR(1,&ANS ) EQ N THEN GOTO JLOOP\n                IF &SUBSTR(1,&ANS ) EQ S THEN GOTO JLOOP\n                IF &SUBSTR(1,&ANS ) NE Y THEN GOTO PLOOP\n\n                WRITE\n                WRITENR SPECIFY VOLUME FOR ALLOCATION +\n                        (OR JUST PRESS ENTER FOR DEFAULT VOLUME)\n                SET &SYSASIS = OFF\n                READ &VOL\n                SET &SYSASIS = ON\n\n                IF &STR(&VOL) NE &STR() THEN SET &VOL = &STR(VOL(&VOL))\n\n                CONTROL MSG\n                ALLOC DS('&UPREFIX..BBIJRNLL') CAT TRACK SPACE(15) &VOL\n                SET &ERC = &LASTCC\n                CONTROL NOMSG\n\n                IF &ERC NE 0 THEN DO\n                  WRITE\n                  WRITE ** Error allocating BBIJRNLL; **\n                  WRITE ** Correct problem and retry  **\n                  WRITE\n                  GOTO PLOOP\n                  END\n                END\n\n              FREE               DS('&UPREFIX..BBIJRNLL')\n              ALLOC DD(BBIJRNL)  DS('&UPREFIX..BBIJRNLL')   SHR\n              &T '&PREFIX..BBLINK(LGILOG)' 'L,&UPREFIX'\n\n              FREE               DS('&UPREFIX..BBIJRNLL')\n              CONTROL MSG FLUSH\n              ALLOC DD(BBIJRNL1) DS('&UPREFIX..BBIJRNLL') SHR\n\n              END /* IF JOURNAL EQ Y */\n\n\n        /*------------------------------------------------------------*/\n        /*                                                            */\n        /*  IF THE IMAGE OPTION IS YES, THEN ALLOCATE THE USER        */\n        /*  IMAGE DATA SET.  IF ONE DOES NOT EXIST, THE USER          */\n        /*  IS QUERIED AS TO HOW TO PROCEED.                          */\n        /*                                                            */\n        /*------------------------------------------------------------*/\n\n        JLOOP: +\n            CONTROL NOMSG NOFLUSH\n            IF &SUBSTR(1:1,&IMAGE ) EQ Y THEN DO\n              ALLOC DD(BBIIMAG1) DS('&UPREFIX..BBIIMAGL') SHR\n              IF &LASTCC NE 0 THEN DO\n                WRITE\n                WRITE\n                WRITE Unable to allocate '&UPREFIX..BBIIMAGL'.\n                WRITE\n                WRITE The image dataset is optional.\n                WRITE It will contain screen immages of certain panels\n                WRITE where you have specified LOG=YES on the panel. If\n                WRITE you do not allocate this dataset, this image\n                WRITE logging function will not be available, but the\n                WRITE panels will function normally otherwise. Not all\n                WRITE panels have this capability.\n                WRITE\n                WRITE\n                WRITE Would you like this CLIST to create it?\n                WRITENR (ENTER 'YES' OR PRESS ENTER TO SKIP)\n                SET &SYSASIS = OFF\n                READ &ANS\n                SET &SYSASIS = ON\n\n                IF &SUBSTR(1,&ANS ) EQ   THEN GOTO ILOOP\n                IF &SUBSTR(1,&ANS ) EQ N THEN GOTO ILOOP\n                IF &SUBSTR(1,&ANS ) EQ S THEN GOTO ILOOP\n                IF &SUBSTR(1,&ANS ) NE Y THEN GOTO JLOOP\n\n                WRITE\n                WRITENR SPECIFY VOLUME FOR ALLOCATION +\n                        (OR JUST PRESS ENTER FOR DEFAULT VOLUME)\n                SET &SYSASIS = OFF\n                READ &VOL\n                SET &SYSASIS = ON\n\n                IF &STR(&VOL) NE &STR() THEN SET &VOL = &STR(VOL(&VOL))\n\n                CONTROL MSG\n                ALLOC DS('&UPREFIX..BBIIMAGL') CAT TRACK SPACE(15) &VOL\n                SET &ERC = &LASTCC\n                CONTROL NOMSG\n\n                IF &ERC NE 0 THEN DO\n                  WRITE\n                  WRITE ** Error allocating BBIIMAGL; **\n                  WRITE ** Correct problem and retry  **\n                  WRITE\n                  GOTO JLOOP\n                  END /* IF ERC NE 0 */\n                END /* IF LASTCC NE 0 */\n\n              FREE               DS('&UPREFIX..BBIIMAGL')\n              CONTROL MSG FLUSH\n              ALLOC DD(BBIIMAG1) DS('&UPREFIX..BBIIMAGL') SHR\n\n              END /* IF IMAGE EQ Y */\n\n        /*------------------------------------------------------------*/\n        /*                                                            */\n        /*  IF THE PRINT OPTION IS YES, THEN ALLOCATE THE USER        */\n        /*  PRINT DATA SET.  IF ONE DOES NOT EXIST, THE USER          */\n        /*  IS QUERIED AS TO HOW TO PROCEED.                          */\n        /*                                                            */\n        /*------------------------------------------------------------*/\n\n        ILOOP: +\n            CONTROL NOMSG NOFLUSH\n            IF &SUBSTR(1:1,&PRINT ) EQ Y THEN DO\n              ALLOC DD(BBISPRNT) DS('&UPREFIX..BBISPRNT') SHR\n              IF &LASTCC = 0 THEN DO\n                FREE DD(BBISPRNT)\n                ALLOC DD(BBISPRNT) DS('&UPREFIX..BBISPRNT') MOD\n                END\n               ELSE DO\n                WRITE\n                WRITE\n                WRITE Unable to allocate &UPREFIX..BBISPRNT.\n                WRITE\n                WRITE The screen print dataset is optional.\n                WRITE It will contain a copy of any panel where you\n                WRITE press the 'PRINT' PF KEY.\n                wRITE\n                WRITE Note that this dataset is only used when the ISPF\n                WRITE PRINT function is NOT active.  When running under\n                WRITE ISPF, the ISPF PRINT function will write the\n                WRITE screen to the ISPF LIST dataset.\n                WRITE\n                WRITE\n                WRITE Would you like this clist to create it?\n                WRITENR (ENTER 'YES' OR PRESS ENTER TO SKIP)\n                SET &SYSASIS = OFF\n                READ &ANS\n                SET &SYSASIS = ON\n\n                IF &SUBSTR(1,&ANS ) EQ   THEN GOTO MAINLOOP\n                IF &SUBSTR(1,&ANS ) EQ N THEN GOTO MAINLOOP\n                IF &SUBSTR(1,&ANS ) EQ S THEN GOTO MAINLOOP\n                IF &SUBSTR(1,&ANS ) NE Y THEN GOTO ILOOP\n\n                WRITE\n                WRITENR SPECIFY VOLUME FOR ALLOCATION +\n                        (OR JUST PRESS ENTER FOR DEFAULT VOLUME)\n                SET &SYSASIS = OFF\n                READ &VOL\n                SET &SYSASIS = ON\n\n                IF &STR(&VOL) NE &STR() THEN SET &VOL = &STR(VOL(&VOL))\n                CONTROL MSG\n                ALLOC DS('&UPREFIX..BBISPRNT') CAT TRACK +\n                      SPACE(15) &VOL RECFM(F B A) LRECL(80) BLK(6160)\n                SET &ERC = &LASTCC\n                CONTROL NOMSG\n                IF &ERC NE 0 THEN DO\n                  WRITE\n                  WRITE ** Error allocating BBISPRNT; **\n                  WRITE ** Correct problem and retry  **\n                  WRITE\n                  GOTO ILOOP\n                  END\n                FREE DS('&UPREFIX..BBISPRNT')\n                ALLOC DD(BBISPRNT) DS('&UPREFIX..BBISPRNT') SHR\n                END\n              END\n            GOTO MAINLOOP\n\n        FINI: +\n            CONTROL NOMSG\n            EXIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MMSBUILD": {"ttr": 14858, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\r\\x00\\x00\\x00\\x95\\x10\\x9f\\x00\\x95\\x11O\\x14\\x05\\x01\\x82\\x02\\t\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf3@@@'", "ispf": {"version": "01.13", "flags": 0, "createdate": "1995-04-19T00:00:00", "modifydate": "1995-04-24T14:05:00", "lines": 386, "newlines": 521, "modlines": 0, "user": "TECH103"}, "text": "/* REXX EXEC : ( MMSBUILD ).\n   FUNCTION  : READS THE INDEX DATASET LISTING OF MEMBERS IN THE MMS\n               SOURCE PDS. THE TYPE MEMBER AND LANG CODE IS DETERMINED\n               AND THE APPROPRIATE IEBCOPY JCL JOB IS BUILT TO COPY\n               THE MEMBERS INTO THE APPROPRIATE TARGET PDS FOR THE\n               LIBRARIAN UTILITY MASS ADD FUNCTION.\n               THE BATCH AND ONLINE CICS LOAD MODULE MEMBERS ARE ALSO\n               SEPARATED AND COPIED INTO A TARGET LOADLIB FOR MERGING\n               INTO THE PRODUCTION LOADLIB DATASETS.\n   INPUT     : DSN=( APPL307.MMS.MODLIST )\n               DSN=( SYSM.MMS.V4R1M1.SRLIB )\n               DSN=( SYSM.MMS.V4R1M1.LOADLIB ).\n   OUTPUT    : DSN=( SYSS.MMS.TURNOVER.JCLLIB )\n               DSN=( SYSS.MMS.TURNOVER.ASSEMBLR.SRCELIB )\n               DSN=( SYSS.MMS.TURNOVER.BATCH.COBOL.SRCELIB )\n               DSN=( SYSS.MMS.TURNOVER.CICS.COBOL.SRCELIB )\n               DSN=( SYSS.MMS.TURNOVER.ASSEMBLR.MACLIB )\n               DSN=( SYSS.MMS.TURNOVER.COPYBOOK.COPYLIB )\n               DSN=( SYSS.MMS.TURNOVER.XBOOK.COPYLIB )\n               DSN=( SYSS.MMS.TURNOVER.BATCH.LOADLIB )\n               DSN=( SYSS.MMS.TURNOVER.CICS.LOADLIB ).\n   AUTHOR    : DAN BOWEN - 04/19/95.\n                                                                      */\nTRACE O\n/*     */\nHOUSE_KEEPING:\nADDRESS TSO\nINDSN.1 = 'APPL307.MMS.MODLIST'\nINDSN.2 = 'SYSM.MMS.V4R1M1.SRLIB'\nINDSN.3 = 'SYSS.MMS.V4R1M1.LOADLIB'\nDO D = 1 TO 3\n   MDSN = SYSDSN(\"'\"INDSN.D\"'\")\n   IF MDSN = 'OK' THEN ITERATE\n   SAY '***********************************************************************'\n   SAY '*** DATASET NOT FOUND FOR: ('INDSN.D'). ***'\n   SAY '*** MMSBUILD EXEC TASK CANCELLED - RETURN CODE: (028). ***'\n   SAY '***********************************************************************'\n   EXIT 028\nEND\nX = MSG(\"OFF\")\n\"FREE FILE(MMSDD)\"\nACCTCDE = '5304010530000000'\nA = 1\nB = 1\nC = 1\nD = 1\nE = 0\nF = 1\nG = 1\nL = 1\nO = 1\nASMSRCE.A = '  COPY  OUTDD=OUTDD1,INDD=INDD1'\nCPYBOOK.B = '  COPY  OUTDD=OUTDD1,INDD=INDD1'\nXBOOK.C = '  COPY  OUTDD=OUTDD1,INDD=INDD1'\nMACRO.D = '  COPY  OUTDD=OUTDD1,INDD=INDD1'\nBATCOBOL.F = '  COPY  OUTDD=OUTDD1,INDD=INDD1'\nCICSCOB.G = '  COPY  OUTDD=OUTDD1,INDD=INDD1'\nLMODB.L = '  COPY  OUTDD=OUTDD1,INDD=INDD1'\nLMODC.O = '  COPY  OUTDD=OUTDD1,INDD=INDD1'\nTYPECNT = 10\nTYPE.1 = 'MAP ASM'\nTYPE.2 = 'BOOK CB2'\nTYPE.3 = 'XBOOK CB2'\nTYPE.4 = 'VIEW ASM'\nTYPE.5 = 'PGM CB2'\nTYPE.6 = 'PGM ASM'\nTYPE.7 = 'SUB ASM'\nTYPE.8 = 'SUB CB2'\nTYPE.9 = 'REC ASM'\nTYPE.10 = 'BOOK ASM'\nTARGCNT = 3\nTARG.1 = '-     B'\nTARG.2 = 'C     -'\nTARG.3 = 'C     B'\nPDS.11 = 'ASMSRCE 1'\nPDS.12 = 'ASMSRCE 2'\nPDS.13 = 'ASMSRCE 1 2'\nPDS.21 = 'COPYBOOK'\nPDS.22 = 'COPYBOOK'\nPDS.23 = 'COPYBOOK'\nPDS.31 = 'XBOOK 2'\nPDS.32 = 'XBOOK 2'\nPDS.33 = 'XBOOK 2'\nPDS.41 = 'MACRO'\nPDS.42 = 'MACRO'\nPDS.43 = 'MACRO'\nPDS.51 = 'BATCHCOB 1'\nPDS.52 = 'CICSCOB 2'\nPDS.53 = 'BATCHCOB 1 2'\nPDS.61 = 'ASMSRCE 1'\nPDS.62 = 'ASMSRCE 2'\nPDS.63 = 'ASMSRCE 1 2'\nPDS.71 = 'ASMSRCE 1'\nPDS.72 = 'ASMSRCE 2'\nPDS.73 = 'ASMSRCE 1 2'\nPDS.81 = 'BATCHCOB 1'\nPDS.82 = 'CICSCOB 2'\nPDS.83 = 'BATCHCOB 1 2'\nPDS.91 = 'COPYBOOK'\nPDS.92 = 'COPYBOOK'\nPDS.93 = 'COPYBOOK'\nPDS.101 = 'MACRO'\nPDS.102 = 'MACRO'\nPDS.103 = 'MACRO'\nMMSMEMB = 'MMSASSEM MMSCPYBK MMSXBOOK MMSMACRO MMSERRLG MMSBCOB2 MMSCCOB2\n MMSBLMOD MMSCLMOD'\nMMSTABLE = 'ASMSRCE. CPYBOOK. XBOOK. MACRO. EMSG. BATCOBOL. CICSCOB. LMODB.\n LMODC.'\nMMSINDEX = 'A B C D E F G L O'\nMMSIPDS.1 = 'SYSM.MMS.V4R1M1.SRLIB'\nMMSIPDS.2 = 'SYSM.MMS.V4R1M1.SRLIB'\nMMSIPDS.3 = 'SYSM.MMS.V4R1M1.SRLIB'\nMMSIPDS.4 = 'SYSM.MMS.V4R1M1.SRLIB'\nMMSIPDS.5 = 'SYSM.MMS.V4R1M1.SRLIB'\nMMSIPDS.6 = 'SYSM.MMS.V4R1M1.SRLIB'\nMMSIPDS.7 = 'SYSS.MMS.V4R1M1.LOADLIB'\nMMSIPDS.8 = 'SYSS.MMS.V4R1M1.LOADLIB'\nMMSOPDS.1 = 'SYSS.MMS.TURNOVER.ASSEMBLR.SRCELIB'\nMMSOPDS.2 = 'SYSS.MMS.TURNOVER.COPYBOOK.COPYLIB'\nMMSOPDS.3 = 'SYSS.MMS.TURNOVER.XBOOK.COPYLIB'\nMMSOPDS.4 = 'SYSS.MMS.TURNOVER.ASSEMBLR.MACLIB'\nMMSOPDS.5 = 'SYSS.MMS.TURNOVER.BATCH.COBOL.SRCELIB'\nMMSOPDS.6 = 'SYSS.MMS.TURNOVER.CICS.COBOL.SRCELIB'\nMMSOPDS.7 = 'SYSS.MMS.TURNOVER.BATCH.LOADLIB'\nMMSOPDS.8 = 'SYSS.MMS.TURNOVER.CICS.LOADLIB'\nMMSINFO.1 = 'MMS.ASSEMBLER.SOURCE'\nMMSINFO.2 = 'MMS.COPYBOOK.MEMBERS'\nMMSINFO.3 = 'MMS.XBOOK.MEMBERS'\nMMSINFO.4 = 'MMS.ASSEMBLER.MACRO'\nMMSINFO.5 = 'MMS.BATCH.COBOL.SRCE'\nMMSINFO.6 = 'MMS.CICS.COBOL.SRCE'\nMMSINFO.7 = 'MMS.BATCH.LOAD.MODS'\nMMSINFO.8 = 'MMS.CICS.LOAD.MODULE'\nMMSCPYM = 'MMSASSEM MMSCPYBK MMSXBOOK MMSMACRO MMSBCOB2 MMSCCOB2 MMSBLMOD\n MMSCLMOD'\nOUTPDS = 'SYSS.MMS.TURNOVER.JCLLIB'\nCALL READ_MMS_INDEX\nCALL READ_MMS_SOURCELIB\nCALL READ_MMS_LOADLIB\n/*      M A I N   R O U T I N E   S E C T I O N     */\n/*     */\nMAIN_ROUTINE:\nDO S = 7 TO SRCELST.0\n   MEMBER = STRIP(SRCELST.S)\n   CALL FIND_INDEX_MEMBER\n   IF FINDSW = 'NO' THEN ITERATE\n   CALL GET_MEMBER_TARGET_PDS\n   IF TARGSW = 'NO' THEN ITERATE\n   LABEL = 'BUILD_IEBCOPY_SYSIN_'TARGET\n   INTERPRET CALL LABEL\n   LOAD = WORD(TARGET,2)\n   IF LOAD = '' THEN ITERATE\n   MODSW = 'NO'\n   LABEL = 'BUILD_LOADLIB_IEBCOPY_SYSIN_'LOAD\n   INTERPRET CALL LABEL\n   IF MODSW = 'NO' THEN ITERATE\n   LOAD = WORD(TARGET,3)\n   IF LOAD = '' THEN ITERATE\n   LABEL = 'BUILD_LOADLIB_IEBCOPY_SYSIN_'LOAD\n   INTERPRET CALL LABEL\nEND\n/*     */\nWRITE_PDS_MEMBERS:\nDO I = 1 TO 9\n   OUTMEMB = WORD(MMSMEMB,I)\n   MMS = WORD(MMSTABLE,I)\n   S = WORD(MMSINDEX,I)\n   CALL WRITE_MMS_MEMBER\nEND\n/*     */\nWRITE_MMS_JCLJOB_MEMBERS:\nDO I = 1 TO 8\n   OUTMEMB = 'MMSCOPY'I\n   MMSIN = MMSIPDS.I\n   MMSOUT = MMSOPDS.I\n   MMSDOC = MMSINFO.I\n   CPYSYSIN = WORD(MMSCPYM,I)\n   CALL WRITE_MMS_JCL_MEMBER\nEND\nEXIT 0\n/*\n       S U B R O U T I N E    S E C T I O N     */\n/*     */\nREAD_MMS_INDEX:\n\"ALLOC DA('\"INDSN.1\"') FILE(MMSDD) SHR\"\n\"EXECIO * DISKR MMSDD (STEM MMSINDX. FINIS\"\nSRC = RC\n\"FREE FILE(MMSDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '***********************************************************************'\n   SAY '*** EXECIO READ ERROR: ('INDSN.1'). ***'\n   SAY '*** MMSBUILD EXEC SUBTASK CANCELLED - RC = ('SRC'). ***'\n   SAY '***********************************************************************'\n   EXIT SRC\nEND\nRETURN\n/*     */\nREAD_MMS_SOURCELIB:\nSO = OUTTRAP(\"SRCELST.\",\"*\",\"CONCAT\")\n\"LISTDS ('\"INDSN.2\"') MEMBERS\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** LISTDS ERROR FOR: ('INDSN.2'). ***'\n   SAY '*** MMSBUILD EXEC SUBTASK CANCELLED - RC = ('SRC'). ***'\n   EXIT SRC\nEND\nIF SRCELST.0 < 7 THEN DO\n   SAY '*** LISTDS ERROR FOR: ('INDSN.2'). ***'\n   SAY '*** NO MEMBERS IN THE INPUT PDS FROM LISTDS FUNCTION. ***'\n   SAY '*** MMSBUILD EXEC SUBTASK CANCELLED - RC = ('SRC'). ***'\n   EXIT SRC\nEND\nRETURN\n/*     */\nREAD_MMS_LOADLIB:\nLO = OUTTRAP(\"LOADLST.\",\"*\",\"CONCAT\")\n\"LISTDS ('\"INDSN.3\"') MEMBERS\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** LISTDS ERROR FOR: ('INDSN.3'). ***'\n   SAY '*** MMSBUILD EXEC SUBTASK CANCELLED - RC = ('SRC'). ***'\n   EXIT SRC\nEND\nIF LOADLST.0 < 7 THEN DO\n   SAY '*** LISTDS ERROR FOR: ('INDSN.3'). ***'\n   SAY '*** NO MEMBERS IN THE INPUT PDS FROM LISTDS FUNCTION. ***'\n   SAY '*** MMSBUILD EXEC SUBTASK CANCELLED - RC = ('SRC'). ***'\n   EXIT SRC\nEND\nRETURN\n/*     */\nFIND_INDEX_MEMBER:\nFINDSW = 'NO'\nTYPESW = 'NO'\nDO I = 1 TO MMSINDX.0\n   IMEMB = WORD(MMSINDX.I,1)\n   IF IMEMB = MEMBER THEN DO\n      FINDSW = 'YES'\n      T1 = WORD(MMSINDX.I,2)\n      T2 = WORD(MMSINDX.I,3)\n      LEAVE\n   END\nEND\nIF FINDSW = 'NO' THEN DO\n   E = E + 1\n   EMSG.E = MEMBER '*** NO ENTRY FOUND IN MODULE INDEX LISTING - EXCLUDED ***'\n   RETURN\nEND\nITYPE = T1 T2\nDO T = 1 TO TYPECNT\n   IF ITYPE = TYPE.T THEN DO\n      TYPESW = 'YES'\n      LEAVE\n   END\nEND\nIF TYPESW = 'NO' THEN DO\n   FINDSW = 'NO'\n   E = E + 1\n   EMSG.E = MEMBER '*** NO TYPE AND LANG ENTRY FOUND IN INDEX LIST - EXCLUDED'\n   RETURN\nEND\nRETURN\n/*     */\nGET_MEMBER_TARGET_PDS:\nTARGSW = 'NO'\nDO P = 1 TO TARGCNT\n   TOPDS = POS(TARG.P,MMSINDX.I)\n   IF TOPDS \u00ac= 0 THEN DO\n      TARGSW = 'YES'\n      TARGET = VALUE('PDS.'T||P)\n      LEAVE\n   END\nEND\nIF TARGSW = 'NO' THEN DO\n   E = E + 1\n   EMSG.E = MEMBER '*** NO ENTRY FOUND - LANG AND TARGET PDS - EXCLUDED ***'\n   RETURN\nEND\nRETURN\n/*     */\nBUILD_IEBCOPY_SYSIN_ASMSRCE:\nA = A + 1\nASMSRCE.A = '  SELECT  MEMBER=('MEMBER')'\nRETURN\n/*     */\nBUILD_IEBCOPY_SYSIN_COPYBOOK:\nB = B + 1\nCPYBOOK.B = '  SELECT  MEMBER=('MEMBER')'\nRETURN\n/*     */\nBUILD_IEBCOPY_SYSIN_XBOOK:\nC = C + 1\nXBOOK.C = '  SELECT  MEMBER=('MEMBER')'\nRETURN\n/*     */\nBUILD_IEBCOPY_SYSIN_MACRO:\nD = D + 1\nMACRO.D = '  SELECT  MEMBER=('MEMBER')'\nRETURN\n/*     */\nBUILD_IEBCOPY_SYSIN_BATCHCOB:\nF = F + 1\nBATCOBOL.F = '  SELECT  MEMBER=('MEMBER')'\nRETURN\n/*     */\nBUILD_IEBCOPY_SYSIN_CICSCOB:\nG = G + 1\nCICSCOB.G = '  SELECT  MEMBER=('MEMBER')'\nRETURN\n/*     */\nBUILD_LOADLIB_IEBCOPY_SYSIN_1:\nDO M = 7 TO LOADLST.0\n   LMOD = STRIP(LOADLST.M)\n   IF LMOD = MEMBER THEN DO\n      MODSW = 'YES'\n      LEAVE\n   END\nEND\nIF MODSW = 'NO' THEN RETURN\nL = L + 1\nLMODB.L = '  SELECT  MEMBER=('MEMBER')'\nRETURN\n/*     */\nBUILD_LOADLIB_IEBCOPY_SYSIN_2:\nIF MODSW = 'NO' THEN DO M = 7 TO LOADLST.0\n   LMOD = STRIP(LOADLST.M)\n   IF LMOD = MEMBER THEN DO\n      MODSW = 'YES'\n      LEAVE\n   END\nEND\nIF MODSW = 'NO' THEN RETURN\nO = O + 1\nLMODC.O = '  SELECT  MEMBER=('MEMBER')'\nRETURN\n/*     */\nWRITE_MMS_MEMBER:\n\"DELSTACK\"\nRCDCNT = VALUE(S)\nIF RCDCNT = 0 THEN RETURN\n\"ALLOC DA('\"OUTPDS\"(\"OUTMEMB\")') FILE(MMSDD) OLD\"\nDO R = 1 TO RCDCNT\n   RECORD = VALUE(MMS||R)\n   QUEUE RECORD\nEND\n\"EXECIO \"RCDCNT\" DISKW MMSDD (FINIS\"\nSRC = RC\n\"FREE FILE(MMSDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '***********************************************************************'\n   SAY '*** PDS WRITE ERROR: ('OUTPDS'('OUTMEMB'). ***'\n   SAY '*** EXECIO WRITE RETURN CODE: (' SRC '). ***'\n   SAY '*** MMSBUILD EXEC SUBTASK CANCELLED. ***'\n   SAY '***********************************************************************'\n   EXIT SRC\nEND\nRETURN\n/*     */\nWRITE_MMS_JCL_MEMBER:\n\"DELSTACK\"\nJN = OUTMEMB\nJCL.1 = \"//\"JN\" JOB \"ACCTCDE\",'\"MMSDOC\"',NOTIFY=TECH103,\"\nJCL.2 = \"//             CLASS=P,MSGCLASS=G,MSGLEVEL=(1,1),REGION=6M\"\nJCL.3 = \"//COPYMEMB EXEC PGM=IEBCOPY\"\nJCL.4 = \"//INDD1    DD DSN=\"MMSIN\",DISP=SHR\"\nJCL.5 = \"//OUTDD1   DD DSN=\"MMSOUT\",DISP=SHR\"\nJCL.6 = \"//SYSPRINT DD SYSOUT=*\"\nJCL.7 = \"//SYSIN    DD DSN=SYSS.MMS.TURNOVER.JCLLIB(\"CPYSYSIN\"),DISP=SHR\"\nJCL.8 = \"//\"\nDO J = 1 TO 8\n   QUEUE JCL.J\nEND\n\"ALLOC DA('\"OUTPDS\"(\"OUTMEMB\")') FILE(MMSDD) OLD\"\n\"EXECIO 8 DISKW MMSDD (FINIS\"\nSRC = RC\n\"FREE FILE(MMSDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '***********************************************************************'\n   SAY '*** PDS WRITE ERROR: ('OUTPDS'('OUTMEMB'). ***'\n   SAY '*** EXECIO WRITE RETURN CODE: (' SRC '). ***'\n   SAY '*** MMSBUILD EXEC SUBTASK CANCELLED. ***'\n   SAY '***********************************************************************'\n   EXIT SRC\nEND\nRETURN\n/* *****   E N D    M M S B U I L D   ***** */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "MODMATCH": {"ttr": 15111, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x1e\\x00\\x00\\x00\\x92\\x00\\x7f\\x00\\x92\\x00\\x8f\\x11\\x08\\x00\\xbd\\x00Y\\x00\\xbd\\xe3\\xc5\\xc3\\xc8\\xf1\\xf1\\xf0@@@'", "ispf": {"version": "01.30", "flags": 0, "createdate": "1992-01-07T00:00:00", "modifydate": "1992-01-08T11:08:00", "lines": 189, "newlines": 89, "modlines": 189, "user": "TECH110"}, "text": "/* REXX EXEC to compare/match Load Module PDSes              */\nparse upper arg dsname1 dsname2 . ;\n\"VMFCLEAR\";\nsay \"Processing...\";\nif dsname2 = \"\" then exit 16; /* Missing input */\nif substr(dsname1,1,1)\u00ac=\"'\" then ,\n      dsname1 = \"'\"dsname1\"'\";\nif substr(dsname2,1,1)\u00ac=\"'\" then ,\n      dsname2 = \"'\"dsname2\"'\";\ndummy = listdsi(dsname1 \"directory\");\nif sysreason=5 then do;say \"Invalid dsname: \"dsname1;exit 16;end;\nmem1dir = sysmembers;\ndummy = listdsi(dsname2 \"directory\");\nif sysreason=5 then do;say \"Invalid dsname: \"dsname2;exit 16;end;\nmem2dir = sysmembers;\ndummy = outtrap(\"dsn1list.\");\n\"LISTDS\" dsname1 \"MEMBERS\";\ndummy = outtrap(\"OFF\");\ndummy = outtrap(\"dsn2list.\");\n\"LISTDS\" dsname2 \"MEMBERS\";\ndummy = outtrap(\"OFF\");\nin1not2 = \"\";\nin2not1 = \"\";\ninboth = \"\";\nmem1 = 0;\nmem2 = 0;\ndo i = 1 to dsn1list.0;\n  if dsn1list.i=\"--MEMBERS--\" then do;\n       dsn1ptr = i+1; /* first member name */\n       leave i;\n       end;\nend;\ndo i = 1 to dsn2list.0;\n  if dsn2list.i=\"--MEMBERS--\" then do;\n       dsn2ptr = i+1; /* first member name */\n       leave i;\n       end;\nend;\ndo loop=1 to 99999; /* forever loop */\n    dsn1list.dsn1ptr = word(dsn1list.dsn1ptr,1);\n    dsn2list.dsn2ptr = word(dsn2list.dsn2ptr,1);\n    if dsn1list.dsn1ptr = dsn2list.dsn2ptr then do;\n           if pos(\",\",dsn1list.dsn1ptr)=0 & ,\n              pos(\")\",dsn1list.dsn1ptr)=0 then ,\n              inboth = inboth dsn1list.dsn1ptr;\n           mem1 = mem1+1; mem2 = mem2+1;\n           dsn1ptr = dsn1ptr+1;\n           dsn2ptr = dsn2ptr+1;\n           end;\n    else if dsn1list.dsn1ptr > dsn2list.dsn2ptr then do;\n           mem2 = mem2+1;\n           in2not1 = in2not1 dsn2list.dsn2ptr;\n           dsn2ptr = dsn2ptr+1;\n           end;\n    else if dsn1list.dsn1ptr < dsn2list.dsn2ptr then do;\n           mem1 = mem1+1;\n           in1not2 = in1not2 dsn1list.dsn1ptr;\n           dsn1ptr = dsn1ptr+1;\n           end;\n    if dsn1ptr>dsn1list.0 & dsn2ptr>dsn2list.0 then leave loop;\n    if dsn1ptr>dsn1list.0 then do;\n           do i = dsn2ptr to dsn2list.0;\n           dsn2list.i = word(dsn2list.i,1);\n           mem2 = mem2+1;\n           in2not1 = in2not1 dsn2list.i;\n           end;\n           leave loop;\n           end;\n    if dsn2ptr>dsn2list.0 then do;\n           do i = dsn1ptr to dsn1list.0;\n           dsn1list.i = word(dsn1list.i,1);\n           mem1 = mem1+1;\n           in1not2 = in1not2 dsn1list.i;\n           end;\n           leave loop;\n           end;\nend;\nx=msg(\"OFF\");\n\"FREE ATTRLIST(DIR)\";\n\"ATTR DIR BLKSIZE(256) LRECL(256) RECFM(F)\";\n\"FREE F(SYSUT1 SYSUT2 SYSIN SYSPRINT)\";\n\"ALLOC F(SYSUT1) DA(\"dsname1\") SHR USING(DIR)\";\n\"ALLOC F(SYSUT2) NEW DELETE SPACE(5 2) TRACKS\";\n\"ALLOC F(SYSPRINT) DUMMY\";\n\"ALLOC F(SYSIN) DUMMY\";\n\"CALL 'SYS1.LINKLIB(IEBGENER)'\";\n\"EXECIO * DISKR SYSUT2 (FINIS STEM IN1.\";\n\"FREE F(SYSUT1 SYSUT2)\";\n\"ALLOC F(SYSUT1) DA(\"dsname2\") SHR USING(DIR)\";\n\"ALLOC F(SYSUT2) NEW DELETE SPACE(5 2) TRACKS\";\n\"CALL 'SYS1.LINKLIB(IEBGENER)'\";\n\"EXECIO * DISKR SYSUT2 (FINIS STEM IN2.\";\n\"FREE F(SYSUT1 SYSUT2)\";\ndo i = 1 to in1.0;\nblkbytes=c2d(substr(in1.i,1,2));\nin1.i=substr(in1.i,3);\nblkbytes=blkbytes-2; /* ignore ctr itself */\ndo j = 1 to 21; /* max entry per blk */\n   notelen=0; /* assume no notes */\n   name=strip(substr(in1.i,1,8));\n   if c2x(name)=\"FFFFFFFFFFFFFFFF\" then leave i;\n   ttr =substr(in1.i,9,3);\n   c   =substr(in1.i,12,1);\n   plen=c2d(c); /* entry len - ignore notes */\n   if plen>=128 then plen=plen-128; /* strip alias,ttrn count bits */\n   if plen>=96  then do;\n        plen=plen-96;\n        notelen=12;\n        end;\n   if plen>=64  then do;\n        plen=plen-64;\n        notelen=8;\n        end;\n   if plen>=32  then do;\n        plen=plen-32;\n        notelen=4;\n        end;\n   plen=plen*2; /* halfword count */\n   len =plen+12; /* entry len */\n   blkbytes=blkbytes-len;\n   attr=c2x(substr(in1.i,17+notelen,2));\n   size=c2x(substr(in1.i,19+notelen,3));\n   inl1.name = attr size;\n   in1.i=substr(in1.i,len+1);\n   if blkbytes=0 then leave j;\nend;\nend;\ndo i = 1 to in2.0;\nblkbytes=c2d(substr(in2.i,1,2));\nin2.i=substr(in2.i,3);\nblkbytes=blkbytes-2; /* ignore ctr itself */\ndo j = 1 to 21; /* max entry per blk */\n   notelen=0; /* assume no notes */\n   name=strip(substr(in2.i,1,8));\n   if c2x(name)=\"FFFFFFFFFFFFFFFF\" then leave i;\n   ttr =substr(in2.i,9,3);\n   c   =substr(in2.i,12,1);\n   plen=c2d(c); /* entry len - ignore notes */\n   if plen>=128 then plen=plen-128; /* strip alias,ttrn count bits */\n   if plen>=96  then do;\n        plen=plen-96;\n        notelen=12;\n        end;\n   if plen>=64  then do;\n        plen=plen-64;\n        notelen=8;\n        end;\n   if plen>=32  then do;\n        plen=plen-32;\n        notelen=4;\n        end;\n   plen=plen*2; /* halfword count */\n   len =plen+12; /* entry len */\n   blkbytes=blkbytes-len;\n   attr=c2x(substr(in2.i,17+notelen,2));\n   size=c2x(substr(in2.i,19+notelen,3));\n   inl2.name = attr size;\n   in2.i=substr(in2.i,len+1);\n   if blkbytes=0 then leave j;\nend;\nend;\n\"VMFCLEAR\";\nalias1 = mem1dir-mem1;\nalias2 = mem2dir-mem2;\nsay \"DSNAME: \"dsname1\";   member count: \"mem1;\nsay \"DSNAME: \"dsname2\";   member count: \"mem2;\nif in1not2\u00ac=\"\" then do;\n      say \"Members in \"dsname1\" and NOT in \"dsname2;\n      ctr = words(in1not2);\n      do i = 1 to ctr;\n         say \"   \"word(in1not2,i);\n      end;\nend;\nif in2not1\u00ac=\"\" then do;\n      say \"Members in \"dsname2\" and NOT in \"dsname1;\n      ctr = words(in2not1);\n      do i = 1 to ctr;\n         say \"   \"word(in2not1,i);\n      end;\nend;\nbctr=words(inboth);\ndo i =1 to bctr;\n   n=word(inboth,i);\n   parse var inl1.n attr1 size1;\n   parse var inl2.n attr2 size2;\n   if attr1\u00ac=attr2 | size1\u00ac=size2 then ,\n       say \"Module mismatch (attributes|size):\" n;\nend;\nexit 0;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "NUAIBOUT": {"ttr": 15115, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x00\\x00\\x00\\x00\\x93(_\\x00\\x93(_\\x152\\x00\\x14\\x00\\x14\\x00\\x00\\xd5\\xe4\\xc1\\xf2\\xc1\\xc3@@@@'", "ispf": {"version": "02.00", "flags": 0, "createdate": "1993-10-12T00:00:00", "modifydate": "1993-10-12T15:32:00", "lines": 20, "newlines": 20, "modlines": 0, "user": "NUA2AC"}, "text": "PROC 0 DEBUG\n/**\n/**  REFER: NUA.V2R10M12.CLIST(NUAIBOUT)\n/**  COMP:  IBM/MVS USER-ACCESS (H213)\n/**  DOC:   ISPF MENU SYSTEM - ISPF/PDF BROWSE OF LAST COMMAND OUTPUT\n/**\nCONTROL NOFLUSH NOLIST NOMSG NOCONLIST NOPROMPT\nIF &DEBUG EQ DEBUG THEN CONTROL LIST MSG CONLIST\n/**\nIF &SYSISPF NE ACTIVE THEN DO\n    WRITE %NUAIBOUT - ISPF NOT AVAILABLE\n    EXIT QUIT CODE(12)\n    END\nELSE ISPEXEC CONTROL ERRORS RETURN\n/**\nISPEXEC VGET (NUAIOUT) SHARED\nISPEXEC BROWSE DATAID(&NUAIOUT) PANEL(NUAIBOUT)\nIF &LASTCC EQ 12 THEN ISPEXEC SETMSG MSG(NUAI007)\n/**\nEXIT CODE(0)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "NUAIBROW": {"ttr": 15117, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x00\\x00\\x00\\x00\\x93(_\\x00\\x93(_\\x152\\x000\\x000\\x00\\x00\\xd5\\xe4\\xc1\\xf2\\xc1\\xc3@@@@'", "ispf": {"version": "02.00", "flags": 0, "createdate": "1993-10-12T00:00:00", "modifydate": "1993-10-12T15:32:00", "lines": 48, "newlines": 48, "modlines": 0, "user": "NUA2AC"}, "text": "PROC 0 DEBUG\n/**\n/**  REFER: NUA.V2R10M12.CLIST(NUAIBROW)\n/**  COMP:  IBM/MVS USER-ACCESS (H213)\n/**  DOC:   ISPF MENU SYSTEM - ISPF/PDF BROWSE OF A REMOTE FILE\n/**\nCONTROL NOFLUSH NOLIST NOMSG NOCONLIST NOPROMPT\nIF &DEBUG EQ DEBUG THEN CONTROL LIST MSG CONLIST\n/**\nIF &SYSISPF NE ACTIVE THEN DO\n    WRITE %NUAIBROW - ISPF NOT AVAILABLE\n    EXIT QUIT CODE(12)\n    END\nELSE ISPEXEC CONTROL ERRORS RETURN\n/**\nISPEXEC VGET (NUAISESS) SHARED\nISPEXEC LMINIT DATAID(NUAIBROW) DDNAME(NUAIBRW&NUAISESS)\nISPEXEC BROWSE DATAID(&NUAIBROW) PANEL(NUAIBROW)\nSET CC=&LASTCC\n/**\nSET SKEL=NUAIBROW\nIF &CC GT 12 THEN DO\n    WRITE %NUAIBROW - ISPEXEC FAILED WITH A CONDITION CODE OF &CC.\n    SET SKEL=NUAIQUIT\n    END\nELSE DO\n    ISPEXEC LMFREE DATAID(&NUAIBROW)\n    FREE DD(NUAIBRW&NUAISESS)\n    ISPEXEC CONTROL NONDISPL END\n    IF &CC EQ 12 THEN ISPEXEC SETMSG MSG(NUAI008)\n    END\n/**\nERROR DO\n    ERROR DO\n        ERROR OFF\n        WRITE %NUAIBROW - FILE TAILORING FAILED\n        EXIT QUIT CODE(12)\n        END\n    %NUAIINIT ISPF /* THIS CAN SOMETIMES HELP AFTER AN ERROR */\n    GOTO FT\n    END\nFT: +\nISPEXEC FTOPEN\nISPEXEC FTINCL &SKEL\nISPEXEC FTCLOSE\nERROR OFF\n/**\nEXIT CODE(0)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "NUAIBRWE": {"ttr": 15361, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x00\\x00\\x00\\x00\\x93(_\\x00\\x93(_\\x152\\x00A\\x00A\\x00\\x00\\xd5\\xe4\\xc1\\xf2\\xc1\\xc3@@@@'", "ispf": {"version": "02.00", "flags": 0, "createdate": "1993-10-12T00:00:00", "modifydate": "1993-10-12T15:32:00", "lines": 65, "newlines": 65, "modlines": 0, "user": "NUA2AC"}, "text": "PROC 0 DEBUG\n/**\n/**  REFER: NUA.V2R10M12.CLIST(NUAIBRWE)\n/**  COMP:  IBM/MVS USER-ACCESS (H213)\n/**  DOC:   ISPF MENU SYSTEM - REMOTE FILE BROWSE ENTRY\n/**\nCONTROL NOFLUSH NOLIST NOMSG NOCONLIST NOPROMPT\nIF &DEBUG EQ DEBUG THEN CONTROL LIST MSG CONLIST\n/**\nIF &SYSISPF NE ACTIVE THEN DO\n    WRITE %NUAIBRWE - ISPF NOT AVAILABLE\n    EXIT QUIT CODE(12)\n    END\nELSE ISPEXEC CONTROL ERRORS RETURN\n/**\nISPEXEC VGET (NUAISOUR NUAISWCD NUAIHOST NUAIUSER NUAICOPT) PROFILE\nISPEXEC VGET (NUAISESS NUAIUNIT) SHARED\nIF &NUAIUNIT EQ THEN SET UNIT=\nELSE SET UNIT=UNIT(&NUAIUNIT)\nSET MSG=\nSET CURSOR=CURSOR(ZCMD)\nIF &STR(&NUAISWCD) EQ THEN SET CURSOR=CURSOR(NUAISWCD)\nIF &STR(&NUAISOUR) EQ THEN SET CURSOR=CURSOR(NUAISOUR)\nSET NEXTOPT=B\n/**\nPANEL: ISPEXEC DISPLAY PANEL(NUAIBRWE) &MSG &CURSOR\nSET CC=&LASTCC\nSET MSG=\nSET CURSOR=CURSOR(ZCMD)\nIF &CC NE 0 AND &CC NE 8 THEN +\n    WRITE %NUAIBRWE - ISPEXEC FAILED WITH A CONDITION CODE OF &CC.\n/**\nSET SKEL=NUAIBRWE\nIF &NUAICMD NE BROWSE THEN SET SKEL=NUAIUCMD\nIF &CC NE 0 THEN SET SKEL=NUAIQUIT\nELSE DO\n    ISPEXEC VPUT (NUAISOUR NUAISWCD NUAIHOST NUAIUSER NUAICOPY) PROFILE\n    ALLOC DD(NUAIBRW&NUAISESS) NEW DELETE SPACE(10 30) BLOCK(4096) +\n        DSORG(PS) RECFM(V B) LRECL(255) BLKSIZE(4096) REUSE &UNIT\n    IF &LASTCC NE 0 THEN DO\n        SETMSG=MSG(NUAI019)\n        GOTO PANEL\n        END\n    IF &STR(&NUAIPSWD) EQ THEN SET NUAIPSWT=\n    ELSE SET NUAIPSWT=XXXXXXXX\n    ISPEXEC CONTROL NONDISPL END\n    ISPEXEC CONTROL DISPLAY LINE START(12)\n    END\n/**\nERROR DO\n    ERROR DO\n        ERROR OFF\n        WRITE %NUAIBRWE - FILE TAILORING FAILED\n        EXIT QUIT CODE(12)\n        END\n    %NUAIINIT ISPF /* THIS CAN SOMETIMES HELP AFTER AN ERROR */\n    GOTO FT\n    END\nFT: +\nISPEXEC FTOPEN\nISPEXEC FTINCL &SKEL\nISPEXEC FTCLOSE\nERROR OFF\n/**\nEXIT CODE(0)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "NUAIEDIT": {"ttr": 15363, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x00\\x00\\x00\\x00\\x93(_\\x00\\x93(_\\x152\\x000\\x000\\x00\\x00\\xd5\\xe4\\xc1\\xf2\\xc1\\xc3@@@@'", "ispf": {"version": "02.00", "flags": 0, "createdate": "1993-10-12T00:00:00", "modifydate": "1993-10-12T15:32:00", "lines": 48, "newlines": 48, "modlines": 0, "user": "NUA2AC"}, "text": "PROC 0 DEBUG\n/**\n/**  REFER: NUA.V2R10M12.CLIST(NUAIEDIT)\n/**  COMP:  IBM/MVS USER-ACCESS (H213)\n/**  DOC:   ISPF MENU SYSTEM - ISPF/PDF EDIT OF A REMOTE FILE\n/**\nCONTROL NOFLUSH NOLIST NOMSG NOCONLIST NOPROMPT\nIF &DEBUG EQ DEBUG THEN CONTROL LIST MSG CONLIST\n/**\nIF &SYSISPF NE ACTIVE THEN DO\n    WRITE %NUAIEDIT - ISPF NOT AVAILABLE\n    EXIT QUIT CODE(12)\n    END\nELSE ISPEXEC CONTROL ERRORS RETURN\n/**\nISPEXEC VGET (NUAISWCD) PROFILE\nISPEXEC VGET (NUAISESS) SHARED\nISPEXEC LMINIT DATAID(NUAIEDIT) DDNAME(NUAIEDT&NUAISESS)\nISPEXEC EDIT DATAID(&NUAIEDIT) PANEL(NUAIEDIT)\nSET CC=&LASTCC\n/**\nSET SKEL=NUAIEDIT\nIF &CC GT 4 THEN DO\n    WRITE %NUAIEDIT - ISPEXEC FAILED WITH A CONDITION CODE OF &CC.\n    SET SKEL=NUAIQUIT\n    END\nELSE DO\n    ISPEXEC CONTROL NONDISPL END\n    IF &CC EQ 0 OR &NUAISWCD EQ YES THEN +\n        ISPEXEC CONTROL DISPLAY LINE START(4)\n    END\n/**\nERROR DO\n    ERROR DO\n        ERROR OFF\n        WRITE %NUAIEDIT - FILE TAILORING FAILED\n        EXIT QUIT CODE(12)\n        END\n    %NUAIINIT ISPF /* THIS CAN SOMETIMES HELP AFTER AN ERROR */\n    GOTO FT\n    END\nFT: +\nISPEXEC FTOPEN\nISPEXEC FTINCL &SKEL\nISPEXEC FTCLOSE\nERROR OFF\n/**\nEXIT CODE(0)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "NUAIEDTE": {"ttr": 15365, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x00\\x00\\x00\\x00\\x93(_\\x00\\x93(_\\x152\\x00A\\x00A\\x00\\x00\\xd5\\xe4\\xc1\\xf2\\xc1\\xc3@@@@'", "ispf": {"version": "02.00", "flags": 0, "createdate": "1993-10-12T00:00:00", "modifydate": "1993-10-12T15:32:00", "lines": 65, "newlines": 65, "modlines": 0, "user": "NUA2AC"}, "text": "PROC 0 DEBUG\n/**\n/**  REFER: NUA.V2R10M12.CLIST(NUAIEDTE)\n/**  COMP:  IBM/MVS USER-ACCESS (H213)\n/**  DOC:   ISPF MENU SYSTEM - REMOTE FILE EDIT ENTRY\n/**\nCONTROL NOFLUSH NOLIST NOMSG NOCONLIST NOPROMPT\nIF &DEBUG EQ DEBUG THEN CONTROL LIST MSG CONLIST\n/**\nIF &SYSISPF NE ACTIVE THEN DO\n    WRITE %NUAIEDTE - ISPF NOT AVAILABLE\n    EXIT QUIT CODE(12)\n    END\nELSE ISPEXEC CONTROL ERRORS RETURN\n/**\nISPEXEC VGET (NUAISOUR NUAISWCD NUAIHOST NUAIUSER NUAICOPT) PROFILE\nISPEXEC VGET (NUAISESS NUAIUNIT) SHARED\nIF &NUAIUNIT EQ THEN SET UNIT=\nELSE SET UNIT=UNIT(&NUAIUNIT)\nSET MSG=\nSET CURSOR=CURSOR(ZCMD)\nIF &STR(&NUAISWCD) EQ THEN SET CURSOR=CURSOR(NUAISWCD)\nIF &STR(&NUAISOUR) EQ THEN SET CURSOR=CURSOR(NUAISOUR)\nSET NEXTOPT=E\n/**\nPANEL: ISPEXEC DISPLAY PANEL(NUAIEDTE) &MSG &CURSOR\nSET CC=&LASTCC\nSET MSG=\nSET CURSOR=CURSOR(ZCMD)\nIF &CC NE 0 AND &CC NE 8 THEN +\n    WRITE %NUAIEDTE - ISPEXEC FAILED WITH A CONDITION CODE OF &CC.\n/**\nSET SKEL=NUAIEDTE\nIF &NUAICMD NE EDIT THEN SET SKEL=NUAIUCMD\nIF &CC NE 0 THEN SET SKEL=NUAIQUIT\nELSE DO\n    ISPEXEC VPUT (NUAISOUR NUAISWCD NUAIHOST NUAIUSER NUAICOPT) PROFILE\n    ALLOC DD(NUAIEDT&NUAISESS) NEW DELETE SPACE(10 30) BLOCK(4096) +\n        DSORG(PS) RECFM(V B) LRECL(255) BLKSIZE(4096) REUSE &UNIT\n    IF &LASTCC NE 0 THEN DO\n        SETMSG=MSG(NUAI019)\n        GOTO PANEL\n        END\n    IF &STR(&NUAIPSWD) EQ THEN SET NUAIPSWT=\n    ELSE SET NUAIPSWT=XXXXXXXX\n    ISPEXEC CONTROL NONDISPL END\n    ISPEXEC CONTROL DISPLAY LINE START(12)\n    END\n/**\nERROR DO\n    ERROR DO\n        ERROR OFF\n        WRITE %NUAIEDTE - FILE TAILORING FAILED\n        EXIT QUIT CODE(12)\n        END\n    %NUAIINIT ISPF /* THIS CAN SOMETIMES HELP AFTER AN ERROR */\n    GOTO FT\n    END\nFT: +\nISPEXEC FTOPEN\nISPEXEC FTINCL &SKEL\nISPEXEC FTCLOSE\nERROR OFF\n/**\nEXIT CODE(0)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "NUAIHOST": {"ttr": 15367, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x00\\x00\\x00\\x00\\x93(_\\x00\\x93(_\\x152\\x00C\\x00C\\x00\\x00\\xd5\\xe4\\xc1\\xf2\\xc1\\xc3@@@@'", "ispf": {"version": "02.00", "flags": 0, "createdate": "1993-10-12T00:00:00", "modifydate": "1993-10-12T15:32:00", "lines": 67, "newlines": 67, "modlines": 0, "user": "NUA2AC"}, "text": "PROC 0 DEBUG\n/**\n/**  REFER: NUA.V2R10M12.CLIST(NUAIHOST)\n/**  COMP:  IBM/MVS USER-ACCESS (H213)\n/**  DOC:   ISPF MENU SYSTEM - REMOTE HOST MANAGEMENT\n/**\nCONTROL NOFLUSH NOLIST NOMSG NOCONLIST NOPROMPT\nIF &DEBUG EQ DEBUG THEN CONTROL LIST MSG CONLIST\n/**\nIF &SYSISPF NE ACTIVE THEN DO\n    WRITE %NUAIHOST - ISPF NOT AVAILABLE\n    EXIT QUIT CODE(12)\n    END\nELSE ISPEXEC CONTROL ERRORS RETURN\n/**\nISPEXEC VGET (NUAIHNUM NUAIHOST NUAIUSER NUAICOPT) PROFILE\nISPEXEC VGET (NUAIHOUT NUAISESS) SHARED\nSET NEXTOPT=H\n/**\nPANEL: ISPEXEC BROWSE DATAID(&NUAIHOUT) PANEL(NUAIHOST)\nSET CC=&LASTCC\nIF &CC EQ 12 THEN DO\n    OPENFILE NUAIHST&NUAISESS OUTPUT\n    CONTROL ASIS\n    SET NUAIHOUT=Enter SHOW command to obtain current host information\n    CONTROL CAPS\n    PUTFILE NUAIHST&NUAISESS\n    CLOSFILE NUAIHST&NUAISESS\n    GOTO PANEL\n    END\nIF &STR(&NUAICMD) EQ END THEN SET &CC EQ 8\nIF &CC NE 0 AND &CC NE 8 THEN +\n    WRITE %NUAIHOST - ISPEXEC FAILED WITH A CONDITION CODE OF &CC.\n/**\nSET SKEL=NUAIHOST\nIF &NUAICMD NE CONNECT AND &NUAICMD NE DISCONNECT AND +\n    &NUAICMD NE SET AND &NUAICMD NE SHOW THEN DO\n    CONTROL ASIS\n    SET ZCMD=&STR(&NUAICMD &ZTRAIL)\n    CONTROL CAPS\n    SET SKEL=NUAIUCMD\n    END\nIF &CC NE 0 THEN SET SKEL=NUAIQUIT\nELSE DO\n    IF &STR(&NUAIPSWD) EQ THEN SET NUAIPSWT=\n    ELSE SET NUAIPSWT=XXXXXXXX\n    ISPEXEC VPUT (NUAIHNUM NUAIHOST NUAIUSER NUAICOPT) PROFILE\n    ISPEXEC CONTROL NONDISPL END\n    ISPEXEC CONTROL DISPLAY LINE START(11)\n    END\n/**\nERROR DO\n    ERROR DO\n        ERROR OFF\n        WRITE %NUAIHOST - FILE TAILORING FAILED\n        EXIT QUIT CODE(12)\n        END\n    %NUAIINIT ISPF /* THIS CAN SOMETIMES HELP AFTER AN ERROR */\n    GOTO FT\n    END\nFT: +\nISPEXEC FTOPEN\nISPEXEC FTINCL &SKEL\nISPEXEC FTCLOSE\nERROR OFF\n/**\nEXIT CODE(0)\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "NUAIINIT": {"ttr": 15369, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x00\\x00\\x00\\x00\\x93(_\\x00\\x93(_\\x152\\x00a\\x00a\\x00\\x00\\xd5\\xe4\\xc1\\xf2\\xc1\\xc3@@@@'", "ispf": {"version": "02.00", "flags": 0, "createdate": "1993-10-12T00:00:00", "modifydate": "1993-10-12T15:32:00", "lines": 97, "newlines": 97, "modlines": 0, "user": "NUA2AC"}, "text": "PROC 0 DEBUG ISPF HOST OUT\n/**\n/**  REFER: NUA.V2R10M12.CLIST(NUAIINIT)\n/**  COMP:  IBM/MVS USER-ACCESS (H213)\n/**  DOC:   ISPF MENU SYSTEM - WORK DATA SET INITIALIZATION\n/**\nCONTROL NOFLUSH NOLIST NOMSG NOCONLIST NOPROMPT\nIF &DEBUG EQ DEBUG THEN CONTROL LIST MSG CONLIST\n/**\nIF &SYSISPF NE ACTIVE THEN DO\n    WRITE %NUAIINIT - ISPF NOT AVAILABLE\n    GOTO INITFAIL\n    END\nELSE ISPEXEC CONTROL ERRORS RETURN\n/**\nISPEXEC VGET (ZSCREEN) SHARED\nSET NUAISESS=&ZSCREEN\nISPEXEC VPUT (NUAISESS) SHARED /* UNIQUE FILE SUFFIX FOR SPLIT SCREEN */\nISPEXEC VGET (NUAIUNIT) SHARED /* DASD WORK FILE UNIT TYPE */\nIF &NUAIUNIT EQ THEN SET UNIT=\nELSE SET UNIT=UNIT(&NUAIUNIT)\n/**\nIF &OUT EQ OUT OR &ISPF&OUT&HOST EQ THEN DO\n    ALLOC DD(NUAIOUT&NUAISESS) NEW DELETE SPACE(10 30) BLOCK(4096) +\n        DSORG(PS) RECFM(V B) LRECL(255) BLKSIZE(4096) REUSE &UNIT\n    IF &LASTCC NE 0 THEN DO\n        WRITE %NUAIINIT - UNABLE TO ALLOCATE COMMAND OUTPUT DATASET\n        GOTO INITFAIL\n        END\n    ISPEXEC LMINIT DATAID(NUAIOUT) DDNAME(NUAIOUT&NUAISESS)\n    IF &LASTCC NE 0 THEN DO\n        WRITE %NUAIINIT - LMINIT FAILED FOR COMMAND OUTPUT DATASET\n        GOTO INITFAIL\n        END\n    ISPEXEC VPUT (NUAIOUT) SHARED\n    END\n/**\nIF &HOST EQ HOST OR &ISPF&OUT&HOST EQ THEN DO\n    ALLOC DD(NUAIHST&NUAISESS) NEW DELETE SPACE(10 30) BLOCK(4096) +\n        DSORG(PS) RECFM(V B) LRECL(255) BLKSIZE(4096) REUSE &UNIT\n    IF &LASTCC NE 0 THEN DO\n        WRITE %NUAIINIT - UNABLE TO ALLOCATE SHOW HOST OUTPUT DATASET\n        GOTO INITFAIL\n        END\n    ERROR DO\n        ERROR OFF\n        WRITE %NUAIINIT - UNABLE TO INITIALIZE HOST OUTPUT DATASET\n        GOTO INITFAIL\n        END\n    OPENFILE NUAIHST&NUAISESS OUTPUT\n    CONTROL ASIS\n    SET NUAIHST&NUAISESS=Enter SHOW command to obtain current +\n        host information\n    CONTROL CAPS\n    PUTFILE NUAIHST&NUAISESS\n    CLOSFILE NUAIHST&NUAISESS\n    ERROR OFF\n    ISPEXEC LMINIT DATAID(NUAIHOUT) DDNAME(NUAIHST&NUAISESS)\n    IF &LASTCC NE 0 THEN DO\n        WRITE %NUAIINIT - LMINIT FAILED FOR SHOW HOST OUTPUT DATASET\n        GOTO INITFAIL\n        END\n    ISPEXEC VPUT (NUAIHOUT) SHARED\n    END\n/**\nIF &ISPF EQ ISPF OR &ISPF&OUT&HOST EQ THEN DO\n    ISPEXEC FTCLOSE /* THIS CAN SOMETIMES HELP AFTER AN ERROR */\n    ALLOC DD(ISPFILE) NEW DELETE SPACE(10 30) BLOCK(4096) +\n        DSORG(PS) RECFM(V B) LRECL(255) BLKSIZE(4096) REUSE &UNIT\n    IF &LASTCC NE 0 THEN DO\n        WRITE %NUAIINIT - UNABLE TO ALLOCATE FILE TAILORING DATASET\n        GOTO INITFAIL\n        END\n    ERROR DO\n        ERROR OFF\n        WRITE %NUAIINIT - FILE TAILORING FAILED\n        GOTO INITFAIL\n        END\n    ISPEXEC FTOPEN\n    ISPEXEC FTINCL NUAIQUIT\n    ISPEXEC FTCLOSE\n    ERROR OFF\n    END\n/**\nEXIT CODE(0)\n/**\nINITFAIL: +\nIF &OUT EQ OUT OR &ISPF&OUT&HOST EQ THEN DO\n    ISPEXEC LMFREE DATAID(&NUAIOUT)\n    FREE DD(NUAIOUT&NUAISESS)\n    END\nIF &HOST EQ HOST OR &ISPF&OUT&HOST EQ THEN DO\n    ISPEXEC LMFREE DATAID(&NUAIHOUT)\n    FREE DD(NUAIHST&NUAISESS)\n    END\nIF &ISPF EQ ISPF OR &ISPF&OUT&HOST EQ THEN ISPEXEC FTCLOSE\nEXIT CODE(12)\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "NUAILCMD": {"ttr": 15372, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x00\\x00\\x00\\x00\\x93(_\\x00\\x93(_\\x152\\x003\\x003\\x00\\x00\\xd5\\xe4\\xc1\\xf2\\xc1\\xc3@@@@'", "ispf": {"version": "02.00", "flags": 0, "createdate": "1993-10-12T00:00:00", "modifydate": "1993-10-12T15:32:00", "lines": 51, "newlines": 51, "modlines": 0, "user": "NUA2AC"}, "text": "PROC 0 DEBUG\n/**\n/**  REFER: NUA.V2R10M12.CLIST(NUAILCMD)\n/**  COMP:  IBM/MVS USER-ACCESS (H213)\n/**  DOC:   ISPF MENU SYSTEM - EXECUTE LOCAL HOST COMMAND\n/**\nCONTROL NOFLUSH NOLIST NOMSG NOCONLIST NOPROMPT\nIF &DEBUG EQ DEBUG THEN CONTROL LIST MSG CONLIST\n/**\nIF &SYSISPF NE ACTIVE THEN DO\n    WRITE %NUAILCMD - ISPF NOT AVAILABLE\n    EXIT QUIT CODE(12)\n    END\nELSE ISPEXEC CONTROL ERRORS RETURN\n/**\nISPEXEC VGET (NUAILCMD) PROFILE\nISPEXEC VGET (NUAISESS) SHARED\nSET MSG=\nSET CURSOR=CURSOR(ZCMD)\n/**\nISPEXEC DISPLAY PANEL(NUAILCMD) &MSG &CURSOR\nSET CC=&LASTCC\nSET MSG=\nSET CURSOR=CURSOR(ZCMD)\n/**\nSET SKEL=NUAILCMD\nIF &CC NE 0 AND &CC NE 8 THEN +\n    WRITE %NUAILCMD - ISPEXEC FAILED WITH A CONDITION CODE OF &CC.\nIF &CC NE 0 THEN SET SKEL=NUAIQUIT\nELSE DO\n    ISPEXEC VPUT NUAILCMD PROFILE\n    ISPEXEC CONTROL NONDISPL END\n    ISPEXEC CONTROL DISPLAY LINE START(7)\n    END\n/**\nERROR DO\n    ERROR DO\n        ERROR OFF\n        WRITE %NUAILCMD - FILE TAILORING FAILED\n        EXIT QUIT CODE(12)\n        END\n    %NUAIINIT ISPF /* THIS CAN SOMETIMES HELP AFTER AN ERROR */\n    GOTO FT\n    END\nFT: +\nISPEXEC FTOPEN\nISPEXEC FTINCL &SKEL\nISPEXEC FTCLOSE\nERROR OFF\n/**\nEXIT CODE(0)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "NUAIMENU": {"ttr": 15374, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x00\\x00\\x00\\x00\\x93(_\\x00\\x93(_\\x152\\x009\\x009\\x00\\x00\\xd5\\xe4\\xc1\\xf2\\xc1\\xc3@@@@'", "ispf": {"version": "02.00", "flags": 0, "createdate": "1993-10-12T00:00:00", "modifydate": "1993-10-12T15:32:00", "lines": 57, "newlines": 57, "modlines": 0, "user": "NUA2AC"}, "text": "PROC 0 DEBUG OPT()\n/**\n/**  REFER: NUA.V2R10M12.CLIST(NUAIMENU)\n/**  COMP:  IBM/MVS USER-ACCESS (H213)\n/**  DOC:   ISPF MENU SYSTEM - MAIN MENU\n/**\nCONTROL NOFLUSH NOLIST NOMSG NOCONLIST NOPROMPT\nIF &DEBUG EQ DEBUG THEN CONTROL LIST MSG CONLIST\n/**\nIF &SYSISPF NE ACTIVE THEN DO\n    WRITE %NUAIMENU - ISPF NOT AVAILABLE\n    EXIT QUIT CODE(12)\n    END\nELSE ISPEXEC CONTROL ERRORS RETURN\n/**\nIF &STR(&OPT) EQ INITIAL THEN DO\n    %NUAIINIT\n    IF &LASTCC NE 0 THEN DO\n        WRITE %NUAIMENU - DATASET INITIALIZATION FAILED\n        EXIT QUIT CODE(12)\n        END\n    ELSE DO\n        ISPEXEC VGET (NUAIOPT) SHARED\n        SET OPT=&NUAIOPT\n        SET NUAIOPT=\n        ISPEXEC VPUT (NUAIOPT) SHARED\n        END\n    END\nIF &STR(&OPT) NE THEN SET OPT=OPT(&OPT)\nELSE DO\n    ISPEXEC FTOPEN\n    ISPEXEC FTINCL NUAIQUIT\n    ISPEXEC FTCLOSE\n    END\n/**\nISPEXEC SELECT PANEL(NUAIMENU) &OPT\nSET CC=&LASTCC\nIF &DATATYPE(&CC) NE NUM OR &CC GT 4 THEN +\n    WRITE %NUAIMENU - ISPEXEC FAILED WITH A CONDITION CODE OF &CC.\n/**\nIF &CC EQ 4 THEN DO\n    ERROR DO\n        ERROR DO\n            ERROR OFF\n            WRITE %NUAIMENU - FILE TAILORING FAILED\n            EXIT QUIT CODE(12)\n            END\n        %NUAIINIT ISPF /* THIS CAN SOMETIMES HELP AFTER AN ERROR */\n        GOTO FT\n        END\nFT: +\n    ISPEXEC FTOPEN\n    ISPEXEC FTINCL NUAIQUIT\n    ISPEXEC FTCLOSE\n    ERROR OFF\n    END\nEXIT CODE(0)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "NUAINATV": {"ttr": 15376, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x00\\x00\\x00\\x00\\x93(_\\x00\\x93(_\\x152\\x00!\\x00!\\x00\\x00\\xd5\\xe4\\xc1\\xf2\\xc1\\xc3@@@@'", "ispf": {"version": "02.00", "flags": 0, "createdate": "1993-10-12T00:00:00", "modifydate": "1993-10-12T15:32:00", "lines": 33, "newlines": 33, "modlines": 0, "user": "NUA2AC"}, "text": "PROC 0 DEBUG\n/**\n/**  REFER: NUA.V2R10M12.CLIST(NUAINATV)\n/**  COMP:  IBM/MVS USER-ACCESS (H213)\n/**  DOC:   ISPF MENU SYSTEM - ENTER NATIVE MODE USER-ACCESS\n/**\nCONTROL NOFLUSH NOLIST NOMSG NOCONLIST NOPROMPT\nIF &DEBUG EQ DEBUG THEN CONTROL LIST MSG CONLIST\n/**\nIF &SYSISPF NE ACTIVE THEN DO\n    WRITE %NUAINATV - ISPF NOT AVAILABLE\n    EXIT QUIT CODE(12)\n    END\nELSE ISPEXEC CONTROL ERRORS RETURN\n/**\nISPEXEC VGET (NUAISESS) SHARED\nERROR DO\n    ERROR DO\n        ERROR OFF\n        WRITE %NUAINATV - FILE TAILORING FAILED\n        EXIT QUIT CODE(12)\n        END\n    %NUAIINIT ISPF /* THIS CAN SOMETIMES HELP AFTER AN ERROR */\n    GOTO FT\n    END\nFT: +\nISPEXEC FTOPEN\nISPEXEC FTINCL NUAINATV\nISPEXEC FTCLOSE\nERROR OFF\n/**\nISPEXEC CONTROL NONDISPL END\nEXIT CODE(0)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "NUAIPSV": {"ttr": 15378, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94#\\x0f\\x00\\x94#\\x0f\\x14\\x18\\x007\\x007\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-08-18T00:00:00", "modifydate": "1994-08-18T14:18:00", "lines": 55, "newlines": 55, "modlines": 0, "user": "TECH103"}, "text": "PROC 0 DEBUG QUIET MENU SCRIPT() TRAN(BRACKET) NUAIOPT() ISPEXEC(YES) +\n    LOAD(SYS1.NETUA.V2R10M12.LOADLIB) PGM(NUACLIEN) NUAIUNIT()\n/**\n/**  REFER: SYSS.NETUA.V2R10M12.TEXTLIB(NUAUSER)\n/**  COMP:  IBM/MVS USER-ACCESS (H213)\n/**  DOC:   TSO/E CLIST TO EXECUTE THE CLIENT PROGRAM\n/**\n/**  NOTE:  THIS MEMBER IS COPIED TO 'SYS1.CMDPROC' OR EQUIVALENT\n/**         DATA SET BY THE USER-ACCESS INSTALLATION JOB\n/**\nCONTROL NOFLUSH NOPROMPT MSG END(ENDO) ASIS  /* MSG REQUIRED */\nIF &DEBUG EQ DEBUG THEN CONTROL PROMPT LIST CONLIST\n/**\nIF &MENU EQ MENU THEN SET QUIET=QUIET\nELSE IF &SYSISPF EQ ACTIVE THEN ISPEXEC CONTROL DISPLAY LINE START(1)\nIF &QUIET EQ THEN WRITE %USER - USER-Access starting\nIF &STR(\"&SUBSTR(1:1,&STR(&SCRIPT ))\") EQ \"'\" THEN +\n    SET SCRIPT=&STR('&SCRIPT')\n/**\nIF &SYSENV EQ FORE THEN DO\n    ALLOC F(SYSIN)    DS(*) REUSE\n    ALLOC F(SYSPRINT) DS(*) REUSE RECFM(V B A)\n    ALLOC F(SYSERR)   DS(*) REUSE RECFM(V B A)\n    /**\n    IF &TRAN NE         THEN TERM NOTRAN NOCHAR\n    IF &TRAN EQ BRACKET THEN TERM CHAR((X'41',X'AD'),(X'42',X'BD'))\n    ENDO\n/**\nIF &ISPEXEC EQ YES AND &SYSISPF EQ ACTIVE THEN DO\n    ISPEXEC CONTROL ERRORS RETURN\n    ISPEXEC LIBDEF ISPLLIB EXCLDATA ID('&LOAD') UNCOND\n    SET &CC=&LASTCC\n    IF &CC EQ 0 THEN DO\n        IF &MENU EQ MENU THEN DO\n            ISPEXEC VPUT (NUAIOPT)  SHARED\n            ISPEXEC VPUT (NUAIUNIT) SHARED\n            ISPEXEC VGET (ZAPPLID) SHARED\n            IF &ZAPPLID EQ NUAI THEN SET NEWAPPL=\n            ELSE SET NEWAPPL=NEWAPPL(NUAI) PASSLIB\n            ENDO\n        ISPEXEC SELECT PGM(&PGM) PARM('&SCRIPT') &NEWAPPL\n        SET &CC=&LASTCC\n        ENDO\n    ISPEXEC LIBDEF ISPLLIB\n    ENDO\nELSE DO\n    CALL '&LOAD(&PGM)' '&SCRIPT'\n    SET CC=&LASTCC\n    ENDO\n/**\nIF &SYSENV EQ FORE AND &TRAN NE THEN TERM NOTRAN NOCHAR\n/**\nIF &QUIET EQ THEN WRITE %USER - USER-Access complete - Code(&CC)\nIF &DATATYPE(&CC) NE NUM THEN EXIT CODE(12)\nEXIT CODE(&CC)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "NUAIQUAL": {"ttr": 15617, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x00\\x00\\x00\\x00\\x93(_\\x00\\x93(_\\x152\\x001\\x001\\x00\\x00\\xd5\\xe4\\xc1\\xf2\\xc1\\xc3@@@@'", "ispf": {"version": "02.00", "flags": 0, "createdate": "1993-10-12T00:00:00", "modifydate": "1993-10-12T15:32:00", "lines": 49, "newlines": 49, "modlines": 0, "user": "NUA2AC"}, "text": "PROC 0 DEBUG\n/**\n/**  REFER: NUA.V2R10M12.CLIST(NUAIQUAL)\n/**  COMP:  IBM/MVS USER-ACCESS (H213)\n/**  DOC:   ISPF MENU SYSTEM - SHOW QUALIFIERS COMMAND\n/**\nCONTROL NOFLUSH NOLIST NOMSG NOCONLIST NOPROMPT\nIF &DEBUG EQ DEBUG THEN CONTROL LIST MSG CONLIST\n/**\nIF &SYSISPF NE ACTIVE THEN DO\n    WRITE %NUAIQUAL - ISPF NOT AVAILABLE\n    EXIT QUIT CODE(12)\n    END\nELSE ISPEXEC CONTROL ERRORS RETURN\nISPEXEC VGET (NUAISESS ZTRAIL) SHARED\n/**\nIF &STR(&ZTRAIL) NE THEN DO\n    SET ZCMD=&STR(&ZTRAIL)\n    ISPEXEC CONTROL NONDISPL ENTER\n    END\n/**\nISPEXEC DISPLAY PANEL(NUAIQUAL) CURSOR(ZCMD)\nSET CC=&LASTCC\n/**\nSET SKEL=NUAIQUAL\nIF &CC NE 0 AND &CC NE 8 THEN +\n    WRITE %NUAIQUAL - ISPEXEC FAILED WITH A CONDITION CODE OF &CC.\nIF &CC NE 0 THEN SET SKEL=NUAIQUIT\nELSE DO\n    ISPEXEC CONTROL NONDISPL END\n    ISPEXEC CONTROL DISPLAY LINE START(4)\n    END\n/**\nERROR DO\n    ERROR DO\n        ERROR OFF\n        WRITE %NUAIQUAL - FILE TAILORING FAILED\n        EXIT QUIT CODE(12)\n        END\n    %NUAIINIT ISPF /* THIS CAN SOMETIMES HELP AFTER AN ERROR */\n    GOTO FT\n    END\nFT: +\nISPEXEC FTOPEN\nISPEXEC FTINCL &SKEL\nISPEXEC FTCLOSE\nERROR OFF\n/**\nEXIT CODE(0)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "NUAIRCMD": {"ttr": 15619, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x00\\x00\\x00\\x00\\x93(_\\x00\\x93(_\\x152\\x003\\x003\\x00\\x00\\xd5\\xe4\\xc1\\xf2\\xc1\\xc3@@@@'", "ispf": {"version": "02.00", "flags": 0, "createdate": "1993-10-12T00:00:00", "modifydate": "1993-10-12T15:32:00", "lines": 51, "newlines": 51, "modlines": 0, "user": "NUA2AC"}, "text": "PROC 0 DEBUG\n/**\n/**  REFER: NUA.V2R10M12.CLIST(NUAIRCMD)\n/**  COMP:  IBM/MVS USER-ACCESS (H213)\n/**  DOC:   ISPF MENU SYSTEM - EXECUTE REMOTE HOST COMMAND\n/**\nCONTROL NOFLUSH NOLIST NOMSG NOCONLIST NOPROMPT\nIF &DEBUG EQ DEBUG THEN CONTROL LIST MSG CONLIST\n/**\nIF &SYSISPF NE ACTIVE THEN DO\n    WRITE %NUAIRCMD - ISPF NOT AVAILABLE\n    EXIT QUIT CODE(12)\n    END\nELSE ISPEXEC CONTROL ERRORS RETURN\n/**\nISPEXEC VGET (NUAIRCMD) PROFILE\nISPEXEC VGET (NUAISESS) SHARED\nSET MSG=\nSET CURSOR=CURSOR(ZCMD)\n/**\nISPEXEC DISPLAY PANEL(NUAIRCMD) &MSG &CURSOR\nSET CC=&LASTCC\nSET MSG=\nSET CURSOR=CURSOR(ZCMD)\n/**\nSET SKEL=NUAIRCMD\nIF &CC NE 0 AND &CC NE 8 THEN +\n    WRITE %NUAIRCMD - ISPEXEC FAILED WITH A CONDITION CODE OF &CC.\nIF &CC NE 0 THEN SET SKEL=NUAIQUIT\nELSE DO\n    ISPEXEC VPUT NUAIRCMD PROFILE\n    ISPEXEC CONTROL NONDISPL END\n    ISPEXEC CONTROL DISPLAY LINE START(7)\n    END\n/**\nERROR DO\n    ERROR DO\n        ERROR OFF\n        WRITE %NUAIRCMD - FILE TAILORING FAILED\n        EXIT QUIT CODE(12)\n        END\n    %NUAIINIT ISPF /* THIS CAN SOMETIMES HELP AFTER AN ERROR */\n    GOTO FT\n    END\nFT: +\nISPEXEC FTOPEN\nISPEXEC FTINCL &SKEL\nISPEXEC FTCLOSE\nERROR OFF\n/**\nEXIT CODE(0)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "NUAISHOW": {"ttr": 15621, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x00\\x00\\x00\\x00\\x93(_\\x00\\x93(_\\x152\\x001\\x001\\x00\\x00\\xd5\\xe4\\xc1\\xf2\\xc1\\xc3@@@@'", "ispf": {"version": "02.00", "flags": 0, "createdate": "1993-10-12T00:00:00", "modifydate": "1993-10-12T15:32:00", "lines": 49, "newlines": 49, "modlines": 0, "user": "NUA2AC"}, "text": "PROC 0 DEBUG\n/**\n/**  REFER: NUA.V2R10M12.CLIST(NUAISHOW)\n/**  COMP:  IBM/MVS USER-ACCESS (H213)\n/**  DOC:   ISPF MENU SYSTEM - SHOW COMMAND\n/**\nCONTROL NOFLUSH NOLIST NOMSG NOCONLIST NOPROMPT\nIF &DEBUG EQ DEBUG THEN CONTROL LIST MSG CONLIST\n/**\nIF &SYSISPF NE ACTIVE THEN DO\n    WRITE %NUAISHOW - ISPF NOT AVAILABLE\n    EXIT QUIT CODE(12)\n    END\nELSE ISPEXEC CONTROL ERRORS RETURN\n/**\nISPEXEC VGET (NUAISESS ZTRAIL) SHARED\nIF &STR(&ZTRAIL) NE THEN DO\n    SET ZCMD=&STR(&ZTRAIL)\n    ISPEXEC CONTROL NONDISPL ENTER\n    END\n/**\nISPEXEC DISPLAY PANEL(NUAISHOW) CURSOR(ZCMD)\nSET CC=&LASTCC\n/**\nSET SKEL=NUAISHOW\nIF &CC NE 0 AND &CC NE 8 THEN +\n    WRITE %NUAISHOW - ISPEXEC FAILED WITH A CONDITION CODE OF &CC.\nIF &CC NE 0 THEN SET SKEL=NUAIQUIT\nELSE DO\n    ISPEXEC CONTROL NONDISPL END\n    ISPEXEC CONTROL DISPLAY LINE START(4)\n    END\n/**\nERROR DO\n    ERROR DO\n        ERROR OFF\n        WRITE %NUAISHOW - FILE TAILORING FAILED\n        EXIT QUIT CODE(12)\n        END\n    %NUAIINIT ISPF /* THIS CAN SOMETIMES HELP AFTER AN ERROR */\n    GOTO FT\n    END\nFT: +\nISPEXEC FTOPEN\nISPEXEC FTINCL &SKEL\nISPEXEC FTCLOSE\nERROR OFF\n/**\nEXIT CODE(0)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "NUAITRAN": {"ttr": 15623, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x00\\x00\\x00\\x00\\x93(_\\x00\\x93(_\\x152\\x00=\\x00=\\x00\\x00\\xd5\\xe4\\xc1\\xf2\\xc1\\xc3@@@@'", "ispf": {"version": "02.00", "flags": 0, "createdate": "1993-10-12T00:00:00", "modifydate": "1993-10-12T15:32:00", "lines": 61, "newlines": 61, "modlines": 0, "user": "NUA2AC"}, "text": "PROC 0 DEBUG\n/**\n/**  REFER: NUA.V2R10M12.CLIST(NUAITRAN)\n/**  COMP:  IBM/MVS USER-ACCESS (H213)\n/**  DOC:   ISPF MENU SYSTEM - FILE TRANSFER\n/**\nCONTROL NOFLUSH NOLIST NOMSG NOCONLIST NOPROMPT\nIF &DEBUG EQ DEBUG THEN CONTROL LIST MSG CONLIST\n/**\nIF &SYSISPF NE ACTIVE THEN DO\n    WRITE %NUAITRAN - ISPF NOT AVAILABLE\n    EXIT QUIT CODE(12)\n    END\nELSE ISPEXEC CONTROL ERRORS RETURN\n/**\nISPEXEC VGET (NUAIMODE NUAICREA NUAITOPT NUAISOUR NUAIDEST NUAISWCD +\n    NUAIHOST NUAIUSER NUAICOPT) PROFILE\nISPEXEC VGET (NUAISESS) SHARED\nSET MSG=\nSET CURSOR=CURSOR(ZCMD)\nIF &STR(&NUAISWCD) EQ THEN SET CURSOR=CURSOR(NUAISWCD)\nIF &STR(&NUAICREA) EQ THEN SET CURSOR=CURSOR(NUAICREA)\nIF &STR(&NUAIMODE) EQ THEN SET CURSOR=CURSOR(NUAIMODE)\nIF &STR(&NUAISOUR) EQ THEN SET CURSOR=CURSOR(NUAISOUR)\nSET NEXTOPT=T\n/**\nISPEXEC DISPLAY PANEL(NUAITRAN) &MSG &CURSOR\nSET CC=&LASTCC\nSET MSG=\nSET CURSOR=CURSOR(ZCMD)\nIF &CC NE 0 AND &CC NE 8 THEN +\n    WRITE %NUAITRAN - ISPEXEC FAILED WITH A CONDITION CODE OF &CC.\n/**\nSET SKEL=NUAITRAN\nIF &NUAICMD NE SEND AND &NUAICMD NE RECEIVE THEN SET SKEL=NUAIUCMD\nIF &CC NE 0 THEN SET SKEL=NUAIQUIT\nELSE DO\n    IF &STR(&NUAIPSWD) EQ THEN SET NUAIPSWT=\n    ELSE SET NUAIPSWT=XXXXXXXX\n    ISPEXEC VPUT (NUAIMODE NUAICREA NUAITOPT NUAISOUR NUAIDEST +\n        NUAISWCD NUAIHOST NUAIUSER NUAICOPT) PROFILE\n    ISPEXEC CONTROL NONDISPL END\n    ISPEXEC CONTROL DISPLAY LINE START(7)\n    END\n/**\nERROR DO\n    ERROR DO\n        ERROR OFF\n        WRITE %NUAITRAN - FILE TAILORING FAILED\n        EXIT QUIT CODE(12)\n        END\n    %NUAIINIT ISPF /* THIS CAN SOMETIMES HELP AFTER AN ERROR */\n    GOTO FT\n    END\nFT: +\nISPEXEC FTOPEN\nISPEXEC FTINCL &SKEL\nISPEXEC FTCLOSE\nERROR OFF\n/**\nEXIT CODE(0)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "NUAIUCMD": {"ttr": 15625, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x00\\x00\\x00\\x00\\x93(_\\x00\\x93(_\\x152\\x00:\\x00:\\x00\\x00\\xd5\\xe4\\xc1\\xf2\\xc1\\xc3@@@@'", "ispf": {"version": "02.00", "flags": 0, "createdate": "1993-10-12T00:00:00", "modifydate": "1993-10-12T15:32:00", "lines": 58, "newlines": 58, "modlines": 0, "user": "NUA2AC"}, "text": "PROC 0 DEBUG CMD() NEXTOPT(C)\n/**\n/**  REFER: NUA.V2R10M12.CLIST(NUAIUCMD)\n/**  COMP:  IBM/MVS USER-ACCESS (H213)\n/**  DOC:   ISPF MENU SYSTEM - EXECUTE USER-ACCESS COMMAND\n/**\nCONTROL NOFLUSH NOLIST NOMSG NOCONLIST NOPROMPT\nIF &DEBUG EQ DEBUG THEN CONTROL LIST MSG CONLIST SYMLIST\n/**\nIF &SYSISPF NE ACTIVE THEN DO\n    WRITE %NUAIUCMD - ISPF NOT AVAILABLE\n    EXIT QUIT CODE(12)\n    END\nELSE ISPEXEC CONTROL ERRORS RETURN\n/**\nISPEXEC VGET (NUAISESS) SHARED\nIF &STR(&CMD) EQ THEN ISPEXEC VGET NUAIUCMD PROFILE\nELSE DO\n    CONTROL ASIS\n    SET NUAIUCMD=&STR(&CMD)\n    CONTROL CAPS\n    ISPEXEC CONTROL NONDISPL ENTER\n    END\nSET MSG=\nSET CURSOR=CURSOR(ZCMD)\n/**\nISPEXEC DISPLAY PANEL(NUAIUCMD) &MSG &CURSOR\nSET CC=&LASTCC\nSET MSG=\nSET CURSOR=CURSOR(ZCMD)\n/**\nSET SKEL=NUAIUCMD\nIF &CC NE 0 AND &CC NE 8 THEN +\n    WRITE %NUAIUCMD - ISPEXEC FAILED WITH A CONDITION CODE OF &CC.\nIF &CC NE 0 THEN SET SKEL=NUAIQUIT\nELSE DO\n    ISPEXEC VPUT NUAIUCMD PROFILE\n    ISPEXEC CONTROL NONDISPL END\n    IF &STR(&CMD) EQ THEN ISPEXEC CONTROL DISPLAY LINE START(7)\n    ELSE ISPEXEC CONTROL DISPLAY LINE START(4)\n    END\n/**\nERROR DO\n    ERROR DO\n        ERROR OFF\n        WRITE %NUAIUCMD - FILE TAILORING FAILED\n        EXIT QUIT CODE(12)\n        END\n    %NUAIINIT ISPF /* THIS CAN SOMETIMES HELP AFTER AN ERROR */\n    GOTO FT\n    END\nFT: +\nISPEXEC FTOPEN\nISPEXEC FTINCL &SKEL\nISPEXEC FTCLOSE\nERROR OFF\n/**\nEXIT CODE(0)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "NUAIVSET": {"ttr": 15627, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x00\\x00\\x00\\x00\\x93(_\\x00\\x93(_\\x152\\x00\\x18\\x00\\x18\\x00\\x00\\xd5\\xe4\\xc1\\xf2\\xc1\\xc3@@@@'", "ispf": {"version": "02.00", "flags": 0, "createdate": "1993-10-12T00:00:00", "modifydate": "1993-10-12T15:32:00", "lines": 24, "newlines": 24, "modlines": 0, "user": "NUA2AC"}, "text": "PROC 0 DEBUG N1() V1() N2() V2() N3() V3() N4() V4() N5() V5()\n/**\n/**  REFER: NUA.V2R10M12.CLIST(NUAIVSET)\n/**  COMP:  IBM/MVS USER-ACCESS (H213)\n/**  DOC:   ISPF MENU SYSTEM - SET ONE TO FIVE TSO/E VARIABLES\n/**\nCONTROL NOFLUSH NOLIST NOMSG NOCONLIST NOPROMPT\nIF &DEBUG EQ DEBUG THEN CONTROL LIST MSG CONLIST\n/**\nIF &SYSISPF NE ACTIVE THEN DO\n    WRITE %NUAIVSET - ISPF NOT AVAILABLE\n    EXIT CODE(20)\n    END\nELSE ISPEXEC CONTROL ERRORS RETURN\n/**\nERROR EXIT CODE(&LASTCC)\nIF &STR(&N1) NE THEN SET &&N1=&STR(&V1)\nIF &STR(&N2) NE THEN SET &&N2=&STR(&V2)\nIF &STR(&N3) NE THEN SET &&N3=&STR(&V3)\nIF &STR(&N4) NE THEN SET &&N4=&STR(&V4)\nIF &STR(&N5) NE THEN SET &&N5=&STR(&V5)\nIF &STR(&N1&N2&N3&N4&N5) NE THEN +\n    ISPEXEC VPUT (&N1 &N2 &N3 &N4 &N5) SHARED\nEXIT CODE(0)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "NUAIWILD": {"ttr": 15629, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x00\\x00\\x00\\x00\\x93(_\\x00\\x93(_\\x152\\x00\\\\\\x00\\\\\\x00\\x00\\xd5\\xe4\\xc1\\xf2\\xc1\\xc3@@@@'", "ispf": {"version": "02.00", "flags": 0, "createdate": "1993-10-12T00:00:00", "modifydate": "1993-10-12T15:32:00", "lines": 92, "newlines": 92, "modlines": 0, "user": "NUA2AC"}, "text": "PROC 0 DEBUG\n/**\n/**  REFER: NUA.V2R10M12.CLIST(NUAIWILD)\n/**  COMP:  IBM/MVS USER-ACCESS (H213)\n/**  DOC:   ISPF MENU SYSTEM - WILDCARD FILE TRANSFER\n/**\nCONTROL NOFLUSH NOLIST NOMSG NOCONLIST NOPROMPT\nIF &DEBUG EQ DEBUG THEN CONTROL LIST MSG CONLIST\n/**\nIF &SYSISPF NE ACTIVE THEN DO\n    WRITE %NUAIWILD - ISPF NOT AVAILABLE\n    EXIT QUIT CODE(12)\n    END\nELSE ISPEXEC CONTROL ERRORS RETURN\n/**\nISPEXEC VGET (NUAIDPAT NUAIDEST NUAIMODE NUAICREA NUAITOPT +\n    NUAIRMIG NUAISWCD NUAIHOST NUAIUSER NUAICOPT) PROFILE\nISPEXEC VGET (NUAISESS) SHARED\nSET MSG=\nSET CURSOR=CURSOR(ZCMD)\nIF &STR(&NUAISWCD) EQ THEN SET CURSOR=CURSOR(NUAISWCD)\nIF &STR(&NUAIDPAT) EQ THEN SET CURSOR=CURSOR(NUAIDPAT)\nSET NEXTOPT=W\n/**\nPANEL: ISPEXEC DISPLAY PANEL(NUAIWILD) &MSG &CURSOR\nSET CC=&LASTCC\nSET MSG=\nSET CURSOR=CURSOR(ZCMD)\nIF &CC NE 0 AND &CC NE 8 THEN +\n    WRITE %NUAIWILD - ISPEXEC FAILED WITH A CONDITION CODE OF &CC.\n/**\nSET SKEL=NUAIWILD\nIF &NUAICMD NE SEND THEN SET SKEL=NUAIUCMD\nIF &CC NE 0 THEN SET SKEL=NUAIQUIT\nIF &SKEL EQ NUAIWILD THEN DO\n    IF &STR(&NUAIPSWD) EQ THEN SET NUAIPSWT=\n    ELSE SET NUAIPSWT=XXXXXXXX\n    ISPEXEC VPUT (NUAIDPAT NUAIDEST NUAIMODE NUAICREA NUAITOPT +\n        NUAIRMIG NUAISWCD NUAIHOST NUAIUSER NUAICOPT) PROFILE\n    ISPEXEC TBCREATE NUAIWILD NAMES(NUAIDSN) NOWRITE REPLACE\n    IF &LASTCC GT 4 THEN DO\n        SET MSG=MSG(NUAI011)\n        GOTO PANEL\n        END\n    IF &NUAIRMIG EQ YES THEN SET RECALL = RECALL\n    ELSE SET RECALL =\n    ISPEXEC SELECT PGM(NUAIWLD) PARM('&STR(&NUAIDPAT) &RECALL')\n    SET CC=&LASTCC\n    IF &CC NE 0 THEN DO\n        SET MSG=MSG(NUAI012)\n        IF &CC EQ 100 THEN SET MSG=MSG(NUAI015) /* NO PATTERN */\n        IF &CC EQ 101 THEN SET MSG=MSG(NUAI014) /* NO MATCH */\n        IF &CC EQ 102 THEN SET MSG=MSG(NUAI015) /* BAD PATTERN */\n        IF &CC EQ 103 THEN SET MSG=MSG(NUAI016) /* BUFFER TOO SMALL */\n        IF &CC EQ 104 THEN SET MSG=MSG(NUAI017) /* SEARCH FAILED */\n        GOTO PANEL\n        END\n    ISPEXEC TBTOP NUAIWILD\n    IF &LASTCC NE 0 THEN DO\n        SET MSG=MSG(NUAI012)\n        GOTO PANEL\n        END\n    ISPEXEC TBDISPL NUAIWILD PANEL(NUAIWLST)\n    IF &LASTCC NE 0 THEN DO\n        SET MSG=MSG(NUAI013)\n        GOTO PANEL\n        END\n    END\nIF &SKEL NE NUAIQUIT THEN DO\n    ISPEXEC VPUT (NUAIDPAT NUAIDEST NUAIMODE NUAICREA NUAITOPT +\n        NUAIRMIG NUAISWCD NUAIHOST NUAIUSER NUAICOPT) PROFILE\n    ISPEXEC CONTROL NONDISPL END\n    ISPEXEC CONTROL DISPLAY LINE START(4)\n    END\n/**\nERROR DO\n    ERROR DO\n        ERROR OFF\n        WRITE %NUAIWILD - FILE TAILORING FAILED\n        EXIT QUIT CODE(12)\n        END\n    %NUAIINIT ISPF /* THIS CAN SOMETIMES HELP AFTER AN ERROR */\n    GOTO FT\n    END\nFT: +\nISPEXEC FTOPEN\nISPEXEC FTINCL &SKEL\nISPEXEC FTCLOSE\nERROR OFF\n/**\nISPEXEC TBCLOSE NUAIWILD\nEXIT CODE(0)\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "NUATYPE": {"ttr": 15632, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x01\\x00\\x00\\x00\\x91\\x05/\\x00\\x921O\\tF\\x00\\x17\\x00\\x17\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf3@@@'", "ispf": {"version": "02.01", "flags": 0, "createdate": "1991-02-21T00:00:00", "modifydate": "1992-11-09T09:46:00", "lines": 23, "newlines": 23, "modlines": 0, "user": "TECH103"}, "text": "PROC 1 DSNAME LOAD(SYS1.NETUA.V2R8M8.LOADLIB)\n/**\n/**  REFER: NUA.V2R8M8.TEXT(NUATYPE)\n/**  COMP:  IBM/MVS USER-ACCESS (H213)\n/**  DOC:   TSO/E CLIST TO TYPE (LIST) A DATA SET AT THE USERS TERMINAL\n/**\n/**  NOTE:  THIS CLIST MUST BE COPIED INTO A CLIST LIBRARY\n/**         ACCESSIBLE BY TSO/E USERS AT YOUR INSTALLATION\n/**\n/**         IF YOU CHANGE THE NAME OF THIS CLIST, BE SURE\n/**         TO SPECIFY THE NEW NAME IN YOUR USER-ACCESS\n/**         SITE STARTUP FILES BY ADDING A \"TYPE\" ALIAS\n/**\nCONTROL NOPROMPT NOFLUSH MSG\n/**\nALLOC F(NUATYPE) DS(&DSNAME) SHR REUSE\nIF &LASTCC NE 0 THEN EXIT CODE(12)\n/**\nCALL '&LOAD(NUATYPE)'\nSET CC=&LASTCC\n/**\nFREE F(NUATYPE)\nIF &CC NE 0 THEN EXIT CODE(12)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "NUAUSER": {"ttr": 15634, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x02\\x01\\x00\\x00\\x00\\x91\\x05/\\x00\\x921O\\tD\\x006\\x006\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf3@@@'", "ispf": {"version": "02.01", "flags": 0, "createdate": "1991-02-21T00:00:00", "modifydate": "1992-11-09T09:44:00", "lines": 54, "newlines": 54, "modlines": 0, "user": "TECH103"}, "text": "PROC 0 DEBUG QUIET MENU SCRIPT() TRAN(BRACKET) NUAIOPT() ISPEXEC(YES) +\n    LOAD(SYS1.NETUA.V2R8M8.LOADLIB) PGM(NUACLIEN)\n/**\n/**  REFER: NUA.V2R8M8.TEXT(NUAUSER)\n/**  COMP:  IBM/MVS USER-ACCESS (H213)\n/**  DOC:   TSO/E CLIST TO EXECUTE THE CLIENT (INITIATOR)\n/**\n/**  NOTE:  THIS CLIST MUST BE COPIED INTO A CLIST LIBRARY\n/**         ACCESSIBLE BY TSO/E USERS AT YOUR INSTALLATION\n/**\nCONTROL NOFLUSH NOPROMPT MSG END(ENDO) ASIS  /* MSG REQUIRED */\nIF &DEBUG EQ DEBUG THEN CONTROL PROMPT LIST CONLIST\n/**\nIF &MENU EQ MENU THEN SET QUIET=QUIET\nELSE IF &SYSISPF EQ ACTIVE THEN ISPEXEC CONTROL DISPLAY LINE START(1)\nIF &QUIET EQ THEN WRITE %NUAUSER  - USER-Access starting\nIF &STR(\"&SUBSTR(1:1,&STR(&SCRIPT ))\") EQ \"'\" THEN +\n    SET SCRIPT=&STR('&SCRIPT')\n/**\nIF &SYSENV EQ FORE THEN DO\n    ALLOC F(SYSIN)    DS(*) REUSE\n    ALLOC F(SYSPRINT) DS(*) REUSE RECFM(V B A)\n    ALLOC F(SYSERR)   DS(*) REUSE RECFM(V B A)\n    /**\n    IF &TRAN NE         THEN TERM NOTRAN NOCHAR\n    IF &TRAN EQ BRACKET THEN TERM CHAR((X'41',X'AD'),(X'42',X'BD'))\n    ENDO\n/**\nIF &ISPEXEC EQ YES AND &SYSISPF EQ ACTIVE THEN DO\n    ISPEXEC CONTROL ERRORS RETURN\n    ISPEXEC LIBDEF ISPLLIB EXCLDATA ID('&LOAD') UNCOND\n    SET &CC=&LASTCC\n    IF &CC EQ 0 THEN DO\n        IF &MENU EQ MENU THEN DO\n            ISPEXEC VPUT (NUAIOPT) SHARED\n            ISPEXEC VGET (ZAPPLID) SHARED\n            IF &ZAPPLID EQ NUAI THEN SET NEWAPPL=\n            ELSE SET NEWAPPL=NEWAPPL(NUAI) PASSLIB\n            ENDO\n        ISPEXEC SELECT PGM(&PGM) PARM('&SCRIPT') &NEWAPPL\n        SET &CC=&LASTCC\n        ENDO\n    ISPEXEC LIBDEF ISPLLIB\n    ENDO\nELSE DO\n    CALL '&LOAD(&PGM)' '&SCRIPT'\n    SET CC=&LASTCC\n    ENDO\n/**\nIF &SYSENV EQ FORE AND &TRAN NE THEN TERM NOTRAN NOCHAR\n/**\nIF &QUIET EQ THEN WRITE %NUAUSER  - USER-Access complete - Code(&CC)\nIF &DATATYPE(&CC) NE NUM THEN EXIT CODE(12)\nEXIT CODE(&CC)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "NWABEND": {"ttr": 15636, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x15\\x00\\x00\\x00\\x95\\x03O\\x00\\x95 \\x1f\\x10@\\x01_\\x01\\xb0\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf3@@@'", "ispf": {"version": "01.21", "flags": 0, "createdate": "1995-02-03T00:00:00", "modifydate": "1995-07-20T10:40:00", "lines": 351, "newlines": 432, "modlines": 0, "user": "TECH103"}, "text": "/*  REXX EXEC : ( NWABEND1 ).\n    ENTRY     : EXECUTED WHENEVER STEP020 OF THE LAN SERVER TO HOST\n                BACKUP JOBS TERMINATE WITH A RETURN CODE GREATER THAN 4.\n    FUNCTION  : THE SYSOUT LISTING DATASET IS INPUT TO THIS EXEC AND IS\n                SCANNED TO FIND ERROR MESSAGE CODES AND TEXT.\n              : A SYSIN MEMBER IS CREATED AND WRITTEN TO THE MESSAGE\n                CONTROL PDS DATASET AND IS INPUT VIA WTO TO DISPLAY\n                THE FORMATTED MESSAGE TEXT TO THE OPERATOR MASTER\n                CONSOLE AT THE ABEND030 STEP.\n              : A RESTART PARM MEMBER IS WRITTEN TO THE RESTART PDS\n                DATASET AND IS INPUT TO THE NWBACKUP ISPF PANEL AND REXX\n                RESTART FACILITY.\n              : THE CONTAINER AND INDEX GDG DATASETS FROM THE FAILED\n                JOB EXECUTION ARE DETERMINED AND DELETED.\n    INPUT     : ( PTECH2.NETCA.&&SERVER.SYSPRINT ).\n    OUTPUT    : ( SYSS.NETCA.MESSAGE.CNTLLIB(&&SERVER)\n                ( SYSS.NETCA.RESTART.PARMLIB(&&SERVER||'RSPRM').\n                                                                      */\n/*      */\nHOUSE_KEEPING:\nADDRESS TSO\nARG SERVER BUTYPE RUNMODE\nIF RUNMODE = '' THEN RUNMODE = 'BACKUP'\nERC = 0\nX = MSG(\"OFF\")\n\"FREE FILE(NWDD)\"\nNWLIB.1 = 'SYSS.NETCA.MESSAGE.CNTLLIB'\nNWLIB.2 = 'SYSS.NETCA.RESTART.PARMLIB'\nNWLIB.3 = 'SYSS.NETCA.CONTROL.TEXTLIB'\nNWLIB.4 = 'PTECH2.NETCA.'SERVER'.SYSPRINT'\nDO I = 1 TO 4\n   NWDSN = SYSDSN(\"'\"NWLIB.I\"'\")\n   IF NWDSN = 'OK' THEN ITERATE\n   OUTPDS = NWLIB.1\n   OUTMEMB = SERVER\n   MCNT = 4\n   MSG.1 = '*** LAN BACKUP FOR 'SERVER' FAILED OR IS INCOMPLETE. ***'\n   MSG.2 = '*** DATASET ERROR: DATASET NOT FOUND FOR ('NWLIB.I'). ***'\n   MSG.3 = '*** NOTIFY THE TECHNICAL SUPPORT CRITICAL CALL LIST PERSON. ***'\n   MSG.4 = '*** NWABEND EXEC TASK CANCELLED. ***'\n   IF NWLIB.I = 'SYSS.NETCA.MESSAGE.CNTLLIB' THEN DO\n      ALLOCATE_MESSAGE_CNTLLIB\n      ITERATE\n   END\n   CALL WRITE_MESSAGE_SYSIN\n   EXIT 028\nEND\nVOLKEY = 'DAILY'\nVOLMEMB = SERVER||'IVOLS'\nIF BUTYPE = 'FULL' THEN DO\n   VOLKEY = 'DAILYF'\n   VOLMEMB = SERVER||'FVOLS'\nEND\nDMEM.1 = SERVER\nDMEM.2 = SERVER||'RSPRM'\nLANID = LEFT(SERVER,6)\nDO I = 1 TO 2\n   DMEM = SYSDSN(\"'\"NWLIB.I\"(\"DMEM.I\")'\")\n   IF DMEM = 'OK' THEN DO\n      \"ALLOC DA('\"NWLIB.I\"(\"DMEM.I\")') FILE(NWDD) SHR\"\n      \"DELETE ('\"NWLIB.I\"(\"DMEM.I\")') FILE(NWDD)\"\n      \"FREE FILE(NWDD)\"\n   END\nEND\nSTATUS_TEXT = 'FINAL STATUS :'\nCALL READ_SERVER_VOLUMES\nCALL READ_SERVER_LISTING\n/*     */\n/*      M A I N   R O U T I N E   S E C T I O N     */\n/*     */\nCHECK_SUBCHANNEL_ALLOCATION_FAILURE:\nMSGSW = 'NO'\nMSGTEXT = 'NETEX-955'\nDO L = 1 TO LST.0\n   UPPER LST.L\n   MTEXT = POS(MSGTEXT,LST.L)\n   IF MTEXT \u00ac= 0 THEN DO\n      MCNT = 4\n      MSGSW = 'YES'\n      MSG.1 = 'SUBCHANNEL ALLOCATION FAIURE - EP ADDRESS NOT AVAILABLE.'\n      MSG.2 = 'TO DOCUMENT PROBLEM, PLEASE ISSUE COMMAND: D U,,ALLOC,400,32'\n      MSG.3 = 'FOR RESTART, SUBMIT JOB VIA COMMAND ===> NWB'\n      MSG.4 = 'IF PROBLEM PERSISTS, CONTACT CRITICAL CALL LIST PERSON.'\n      LEAVE\n   END\nEND\nIF MSGSW = 'YES' THEN DO\n   CALL WRITE_MESSAGE_MEMBER\n   F = 1\n   FMSG.1 = 'ALL FAIL' BUTYPE\n   CALL WRITE_RESTART_PARMS\n   EXIT ERC\nEND\n/*     */\nCHECK_REMOTE_CREATE_FAILURE:\nMSGSW = 'NO'\nMSGTEXT = 'REMOTE: FAILED TO CREATE FILE'\nDO L = 1 TO LST.0\n   UPPER LST.L\n   MTEXT = POS(MSGTEXT,LST.L)\n   IF MTEXT \u00ac= 0 THEN DO\n      R = L - 1\n      MCNT = 5\n      MSGSW = 'YES'\n      DO M = 1 TO 4\n         R = R + 1\n         ETXT = SUBSTR(LST.R,MTEXT,80)\n         EMSG = STRIP(ETXT)\n         MSG.M = EMSG\n      END\n      MSG.5 = 'CONTACT THE ON-CALL LAN COMMUNICATIONS PERSON.'\n      LEAVE\n   END\nEND\nIF MSGSW = 'YES' THEN DO\n   CALL WRITE_MESSAGE_MEMBER\n   F = 1\n   FMSG.1 = 'ALL FAIL' BUTYPE\n   CALL WRITE_RESTART_PARMS\n   EXIT ERC\nEND\n/*     */\nCHECK_CONNECTION_FAILURE:\nMSGSW = 'NO'\nMSGTEXT = 'CONNECTION TO HOST 'SERVER' FAILED'\nDO L = 1 TO LST.0\n   UPPER LST.L\n   MTEXT = POS(MSGTEXT,LST.L)\n   IF MTEXT \u00ac= 0 THEN DO\n      MCNT = 4\n      MSGSW = 'YES'\n      MSG.1 = 'CONNECTION TO HOST ('SERVER') FAILED.'\n      MSG.2 = 'SERVICE NOT OFFERED ON HOST ('SERVER').'\n      MSG.3 = 'CONTACT THE ON-CALL LAN COMMUNICATIONS PERSON.'\n      MSG.4 = 'FOR RESTART, SUBMIT JOB VIA COMMAND ===> NWB'\n      LEAVE\n   END\nEND\nIF MSGSW = 'YES' THEN DO\n   CALL WRITE_MESSAGE_MEMBER\n   F = 1\n   FMSG.1 = 'ALL FAIL' BUTYPE\n   CALL WRITE_RESTART_PARMS\n   EXIT ERC\nEND\n/*     */\nCHECK_VOLUME_COMPLETION_STATUS:\nF = 0\nM = 0\nMSGSW = 'NO'\nFAILSW = 'NO'\nS = 3\nMSG.1 = '... BACKUP STATUS FOR SERVER: ('LANID') ...'\nMSG.2 = 'VOLUME   BACKUP STATUS                      '\nMSG.3 = '------   -----------------------            '\nDO V = 1 TO VOLCNT\n   SERVOL = VOL.V\n   CALL CHECK_LOCAL_STATUS\n   IF BACKUP_STATUS = 'OK' THEN DO\n      CALL CHECK_REMOTE_STATUS\n      ITERATE\n   END\n   IF BACKUP_STATUS = 'FAIL' THEN DO\n      FAILSW = 'YES'\n      F = F + 1\n      FMSG.F = SERVOL 'FAIL' BUTYPE\n      ITERATE\n   END\nEND\nIF MSGSW = 'YES' THEN DO\n   MCNT = S\n   CALL WRITE_MESSAGE_MEMBER\nEND\nIF FAILSW = 'YES' THEN DO\n   IF F = VOLCNT THEN DO\n      F = 1\n      FMSG.1 = 'ALL FAIL' BUTYPE\n   END\n   CALL WRITE_RESTART_PARMS\n   EXIT ERC\nEND\nIF MSGSW = 'NO' THEN DO\n   MCNT = 4\n   MSG.1 = 'BACKUP FOR LAN SERVER ('SERVER') FAILED.'\n   MSG.2 = 'BROWSE/CHECK DATASET: ('NWLIB.4').'\n   MSG.3 = 'CONTACT THE ON-CALL PRODUCTION CONTROL PERSON.'\n   MSG.4 = 'RESTART AFTER PROBLEM IS CORRECTED.'\n   CALL WRITE_MESSAGE_MEMBER\n   IF FAILSW = 'NO' THEN DO\n      F = 1\n      FMSG.1 = 'ALL FAIL' BUTYPE\n      CALL WRITE_RESTART_PARMS\n   END\nEND\nEXIT ERC\n/*     */\n/*      S U B R O U T I N E S   S E C T I O N     */\n/*     */\nALLOCATE_MESSAGE_CNTLLIB:\n\"ATTRIB MSGLIB DSORG(PO) RECFM(F,B) LRECL(80) BLKSIZE(27920)\"\n\"ALLOC DA('\"NWLIB.1\"') NEW SPACE(3,1) USING(MSGLIB) DIR(1) DATACLAS(CNTL)\nMGMTCLAS(NOMIG) STORCLAS(SYSSHARE) DSNTYP(LIBRARY)\"\nSRC = RC\n\"FREE DA('SYSS.NETCA.MESSAGE.CNTLLIB')\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('NWLIB.1'). ***'\n   SAY '*** NOTIFY THE TECHNICAL SUPPORT CRITICAL CALL LIST PERSON. ***'\n   SAY '*** NWABEND EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT 100\nEND\nRETURN\n/*     */\nREAD_SERVER_LISTING:\n\"ALLOC DA('\"NWLIB.4\"') FILE(NWDD) SHR\"\n\"EXECIO * DISKR NWDD (STEM LST. FINIS\"\nSRC = RC\n\"FREE FILE(NWDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** EXECIO READ ERROR: ('NWLIB.4'). ***'\n   SAY '*** NWABEND EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nRETURN\n/*     */\nREAD_SERVER_VOLUMES:\nV = 0\nIF RUNMODE = 'RESTART' THEN DO\n   VOLMEMB = SERVER||'VOLS'\n   NWLIB.3 = NWLIB.2\nEND\n\"ALLOC DA('\"NWLIB.3\"(\"VOLMEMB\")') FILE(NWDD) SHR\"\n\"EXECIO * DISKR NWDD (STEM VOLDATA. FINIS\"\nSRC = RC\n\"FREE FILE(NWDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** EXECIO READ ERROR: ('NWLIB.3'('VOLMEMB'). ***'\n   SAY '*** NWABEND EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nDO I = 1 TO VOLDATA.0\n   UPPER VOLDATA.I\n   SVOL = POS(VOLKEY,VOLDATA.I)\n   IF SVOL = 0 THEN ITERATE\n   V = V + 1\n   VOL.V = WORD(VOLDATA.I,1)\nEND\nVOLCNT = V\nRETURN\n/*     */\nCHECK_LOCAL_STATUS:\nENDSW = 'NO'\nLANVOL = LEFT(SERVOL,4)\nBACKUP_STATUS = 'FAIL'\nEND_TEXT = 'BACKUP OF VOLUME 'SERVOL' TERMINATING'\nDO L = 1 TO LST.0\n   UPPER LST.L\n   ENDKEY = POS(END_TEXT,LST.L)\n   IF ENDKEY \u00ac= 0 THEN ENDSW = 'YES'\n   IF ENDSW = 'YES' THEN DO\n      STATKEY = POS(STATUS_TEXT,LST.L)\n      IF STATKEY \u00ac= 0 THEN DO\n         NUMWORDS = WORDS(LST.L)\n         GLOBAL_STATUS = WORD(LST.L,NUMWORDS)\n         LEAVE\n      END\n   END\nEND\nBUSTATUS = SUBSTR(GLOBAL_STATUS,1,4)\nIF BUSTATUS = 'SSSS' THEN DO\n   BACKUP_STATUS = 'OK'\n   RETURN\nEND\nDO E = 1 TO 4\n   BACKUP_STATUS = 'OK'\n   POSTAT = SUBSTR(GLOBAL_STATUS,E,1)\n   IF POSTAT = 'S' | POSTAT = 'W' THEN ITERATE\n   BACKUP_STATUS = 'FAIL'\nEND\nIF BACKUP_STATUS = 'FAIL' THEN DO\n   MSGSW = 'YES'\n   S = S + 1\n   MSG.S = LANVOL '*** BACKUP FAILED ***'\nEND\nRETURN\n/*     */\nCHECK_REMOTE_STATUS:\nREMOTE_STATUS = 'OK'\nDO E = 5 TO 8\n   POSTAT = SUBSTR(GLOBAL_STATUS,E,1)\n   IF POSTAT = 'S' | POSTAT = 'W' THEN ITERATE\n   REMOTE_STATUS = 'FAIL'\nEND\nS7 = SUBSTR(GLOBAL_STATUS,7,1)\nS8 = SUBSTR(GLOBAL_STATUS,8,1)\nIF S7 = 'E' | S8 = 'E' THEN REMOTE_STATUS = 'OK'\nIF REMOTE_STATUS = 'OK' THEN DO\n   MSGSW = 'YES'\n   S = S + 1\n   MSG.S = LANVOL '+++ BACKUP SUCCESSFUL +++'\n   RETURN\nEND\nERC = 8\nMSGSW = 'YES'\nS = S + 1\nMSG.S = LANVOL '+++ BACKUP SUCCESSFUL +++ >>> REMOTE SERVER ERROR'\nS = S + 1\nMSG.S = 'NOTIFY THE ON-CALL LAN COMMUNICATIONS PERSON.'\nRETURN\n/*     */\nWRITE_MESSAGE_MEMBER:\n\"DELSTACK\"\nOUTPDS = NWLIB.1\nOUTMEMB = SERVER\n\"ALLOC DA('\"OUTPDS\"(\"OUTMEMB\")') FILE(NWDD) SHR\"\nDO M = 1 TO MCNT\n   QUEUE MSG.M\nEND\n\"EXECIO\" MCNT \"DISKW NWDD (FINIS\"\nSRC = RC\n\"FREE FILE(NWDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** WRITE ERROR: ERROR WRITING 'OUTPDS'('OUTMEMB'). ***'\n   SAY '*** NWABEND EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nRETURN\n/*     */\nWRITE_RESTART_PARMS:\n\"DELSTACK\"\nMSGCNT = F\nOUTPDS = NWLIB.2\nOUTMEMB = SERVER||'RSPRM'\n\"ALLOC DA('\"OUTPDS\"(\"OUTMEMB\")') FILE(NWDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('OUTPDS'('OUTMEMB'). ***'\n   SAY '*** NWABEND EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nDO M = 1 TO MSGCNT\n   QUEUE FMSG.M\nEND\n\"EXECIO\" MSGCNT \"DISKW NWDD (FINIS\"\nSRC = RC\n\"FREE FILE(NWDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** WRITE ERROR: ERROR WRITING 'OUTPDS'('OUTMEMB'). ***'\n   SAY '*** NWABEND EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "NWABEND2": {"ttr": 15879, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\n\\x00\\x00\\x00\\x95\\x04\\x1f\\x00\\x95 \\x1f\\x10C\\x01U\\x01.\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf3@@@'", "ispf": {"version": "01.10", "flags": 0, "createdate": "1995-02-10T00:00:00", "modifydate": "1995-07-20T10:43:00", "lines": 341, "newlines": 302, "modlines": 0, "user": "TECH103"}, "text": "/*  REXX EXEC : ( NWABEND2 ).\n    ENTRY     : EXECUTED WHENEVER STEP020 OF THE LAN SERVER TO HOST\n                BACKUP JOBS TERMINATE WITH A RETURN CODE GREATER THAN 4.\n    FUNCTION  : THE SYSOUT LISTING DATASET IS INPUT TO THIS EXEC AND IS\n                SCANNED TO FIND ERROR MESSAGE CODES AND TEXT.\n              : A SYSIN MEMBER IS CREATED AND WRITTEN TO THE MESSAGE\n                CONTROL PDS DATASET AND IS INPUT VIA WTO TO DISPLAY\n                THE FORMATTED MESSAGE TEXT TO THE OPERATOR MASTER\n                CONSOLE AT THE ABEND030 STEP.\n              : A RESTART PARM MEMBER IS WRITTEN TO THE RESTART PDS\n                DATASET AND IS INPUT TO THE NWBACKUP ISPF PANEL AND REXX\n                RESTART FACILITY.\n              : THE CONTAINER AND INDEX GDG DATASETS FROM THE FAILED\n                JOB EXECUTION ARE DETERMINED AND DELETED.\n    INPUT     : ( PTECH2.NETCA.&&SERVER.SYSPRINT ).\n    OUTPUT    : ( SYSS.NETCA.MESSAGE.CNTLLIB(&&SERVER)\n                ( SYSS.NETCA.RESTART.PARMLIB(&&SERVER||'RSPRM').\n                                                                      */\n/*      */\nHOUSE_KEEPING:\nADDRESS TSO\nARG SERVER DIRNAME BUTYPE .\nERC = 0\nX = MSG(\"OFF\")\n\"FREE FILE(NWDD)\"\nDIR = SUBSTR(DIRNAME,1,3)\nOUTMEMB = SERVER||DIRNAME\nVOLMEMB = SERVER||DIRNAME\nNWLIB.1 = 'SYSS.NETCA.MESSAGE.CNTLLIB'\nNWLIB.2 = 'SYSS.NETCA.RESTART.PARMLIB'\nNWLIB.3 = 'SYSS.NETCA.CONTROL.TEXTLIB'\nNWLIB.4 = 'PTECH2.NETCA.'SERVER'.'DIRNAME'.SYSPRINT'\nDO I = 1 TO 4\n   NWDSN = SYSDSN(\"'\"NWLIB.I\"'\")\n   IF NWDSN = 'OK' THEN ITERATE\n   OUTPDS = NWLIB.1\n   MCNT = 4\n   MSG.1 = '*** LAN BACKUP FOR 'SERVER' FAILED OR IS INCOMPLETE. ***'\n   MSG.2 = '*** DATASET ERROR: DATASET NOT FOUND FOR ('NWLIB.I'). ***'\n   MSG.3 = '*** NOTIFY THE TECHNICAL SUPPORT CRITICAL CALL LIST PERSON. ***'\n   MSG.4 = '*** NWABEND EXEC TASK CANCELLED. ***'\n   IF NWLIB.I = 'SYSS.NETCA.MESSAGE.CNTLLIB' THEN DO\n      ALLOCATE_MESSAGE_CNTLLIB\n      ITERATE\n   END\n   CALL WRITE_MESSAGE_SYSIN\n   EXIT 028\nEND\nDMEM.1 = OUTMEMB\nDMEM.2 = SERVER||'RSPRM'\nLANID = OUTMEMB\nDO I = 1 TO 2\n   DMEM = SYSDSN(\"'\"NWLIB.I\"(\"DMEM.I\")'\")\n   IF DMEM = 'OK' THEN DO\n      \"ALLOC DA('\"NWLIB.I\"(\"DMEM.I\")') FILE(NWDD) SHR\"\n      \"DELETE ('\"NWLIB.I\"(\"DMEM.I\")') FILE(NWDD)\"\n      \"FREE FILE(NWDD)\"\n   END\nEND\nSTATUS_TEXT = 'FINAL STATUS :'\nCALL READ_SERVER_VOLUMES\nCALL READ_SERVER_LISTING\n/*     */\n/*      M A I N   R O U T I N E   S E C T I O N     */\n/*     */\nCHECK_SUBCHANNEL_ALLOCATION_FAILURE:\nMSGSW = 'NO'\nMSGTEXT = 'NETEX-955'\nDO L = 1 TO LST.0\n   UPPER LST.L\n   MTEXT = POS(MSGTEXT,LST.L)\n   IF MTEXT \u00ac= 0 THEN DO\n      MCNT = 4\n      MSGSW = 'YES'\n      MSG.1 = 'SUBCHANNEL ALLOCATION FAIURE - EP ADDRESS NOT AVAILABLE.'\n      MSG.2 = 'TO DOCUMENT PROBLEM, PLEASE ISSUE COMMAND: D U,,ALLOC,400,32'\n      MSG.3 = 'FOR RESTART, SUBMIT JOB VIA COMMAND ===> NWB'\n      MSG.4 = 'IF PROBLEM PERSISTS, CONTACT CRITICAL CALL LIST PERSON.'\n      LEAVE\n   END\nEND\nIF MSGSW = 'YES' THEN DO\n   CALL WRITE_MESSAGE_MEMBER\n   F = 1\n   FMSG.1 = 'ALL FAIL' BUTYPE\n   CALL WRITE_RESTART_PARMS\n   EXIT ERC\nEND\n/*     */\nCHECK_REMOTE_CREATE_FAILURE:\nMSGSW = 'NO'\nMSGTEXT = 'REMOTE: FAILED TO CREATE FILE'\nDO L = 1 TO LST.0\n   UPPER LST.L\n   MTEXT = POS(MSGTEXT,LST.L)\n   IF MTEXT \u00ac= 0 THEN DO\n      R = L - 1\n      MCNT = 5\n      MSGSW = 'YES'\n      DO M = 1 TO 4\n         R = R + 1\n         ETXT = SUBSTR(LST.R,MTEXT,80)\n         EMSG = STRIP(ETXT)\n         MSG.M = EMSG\n      END\n      MSG.5 = 'CONTACT THE ON-CALL LAN COMMUNICATIONS PERSON.'\n      LEAVE\n   END\nEND\nIF MSGSW = 'YES' THEN DO\n   CALL WRITE_MESSAGE_MEMBER\n   F = 1\n   FMSG.1 = 'ALL FAIL' BUTYPE\n   CALL WRITE_RESTART_PARMS\n   EXIT ERC\nEND\n/*     */\nCHECK_CONNECTION_FAILURE:\nMSGSW = 'NO'\nMSGTEXT = 'CONNECTION TO HOST 'SERVER' FAILED'\nDO L = 1 TO LST.0\n   UPPER LST.L\n   MTEXT = POS(MSGTEXT,LST.L)\n   IF MTEXT \u00ac= 0 THEN DO\n      MCNT = 4\n      MSGSW = 'YES'\n      MSG.1 = 'CONNECTION TO HOST ('SERVER') FAILED.'\n      MSG.2 = 'SERVICE NOT OFFERED ON HOST ('SERVER').'\n      MSG.3 = 'CONTACT THE ON-CALL LAN COMMUNICATIONS PERSON.'\n      MSG.4 = 'FOR RESTART, SUBMIT JOB VIA COMMAND ===> NWB'\n      LEAVE\n   END\nEND\nIF MSGSW = 'YES' THEN DO\n   CALL WRITE_MESSAGE_MEMBER\n   F = 1\n   FMSG.1 = 'ALL FAIL' BUTYPE\n   CALL WRITE_RESTART_PARMS\n   EXIT ERC\nEND\n/*     */\nCHECK_VOLUME_COMPLETION_STATUS:\nF = 0\nM = 0\nMSGSW = 'NO'\nFAILSW = 'NO'\nS = 3\nMSG.1 = '... BACKUP STATUS FOR SERVER: ('LANID') ...'\nMSG.2 = 'VOLUME   BACKUP STATUS                      '\nMSG.3 = '------   -----------------------            '\nDO V = 1 TO VOLCNT\n   SERVOL = VOL.V\n   CALL CHECK_LOCAL_STATUS\n   IF BACKUP_STATUS = 'OK' THEN DO\n      CALL CHECK_REMOTE_STATUS\n      ITERATE\n   END\n   IF BACKUP_STATUS = 'FAIL' THEN DO\n      FAILSW = 'YES'\n      F = F + 1\n      FMSG.F = SERVOL 'FAIL' BUTYPE\n      ITERATE\n   END\nEND\nIF MSGSW = 'YES' THEN DO\n   MCNT = S\n   CALL WRITE_MESSAGE_MEMBER\nEND\nIF FAILSW = 'YES' THEN DO\n   IF F = VOLCNT THEN DO\n      F = 1\n      FMSG.1 = 'ALL FAIL' BUTYPE\n   END\n   CALL WRITE_RESTART_PARMS\n   EXIT ERC\nEND\nIF MSGSW = 'NO' THEN DO\n   MCNT = 4\n   MSG.1 = 'BACKUP FOR LAN SERVER ('SERVER') FAILED.'\n   MSG.2 = 'BROWSE/CHECK DATASET: ('NWLIB.4').'\n   MSG.3 = 'CONTACT THE ON-CALL PRODUCTION CONTROL PERSON.'\n   MSG.4 = 'RESTART AFTER PROBLEM IS CORRECTED.'\n   CALL WRITE_MESSAGE_MEMBER\n   IF FAILSW = 'NO' THEN DO\n      F = 1\n      FMSG.1 = 'ALL FAIL' BUTYPE\n      CALL WRITE_RESTART_PARMS\n   END\nEND\nEXIT ERC\n/*     */\n/*      S U B R O U T I N E S   S E C T I O N     */\n/*     */\nALLOCATE_MESSAGE_CNTLLIB:\n\"ATTRIB MSGLIB DSORG(PO) RECFM(F,B) LRECL(80) BLKSIZE(27920)\"\n\"ALLOC DA('\"NWLIB.1\"') NEW SPACE(3,1) USING(MSGLIB) DIR(1) DATACLAS(CNTL)\nMGMTCLAS(NOMIG) STORCLAS(SYSSHARE) DSNTYP(LIBRARY)\"\nSRC = RC\n\"FREE DA('SYSS.NETCA.MESSAGE.CNTLLIB')\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('NWLIB.1'). ***'\n   SAY '*** NOTIFY THE TECHNICAL SUPPORT CRITICAL CALL LIST PERSON. ***'\n   SAY '*** NWABEND EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT 100\nEND\nRETURN\n/*     */\nREAD_SERVER_LISTING:\n\"ALLOC DA('\"NWLIB.4\"') FILE(NWDD) SHR\"\n\"EXECIO * DISKR NWDD (STEM LST. FINIS\"\nSRC = RC\n\"FREE FILE(NWDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** EXECIO READ ERROR: ('NWLIB.4'). ***'\n   SAY '*** NWABEND EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nRETURN\n/*     */\nREAD_SERVER_VOLUMES:\nV = 0\n\"ALLOC DA('\"NWLIB.3\"(\"VOLMEMB\")') FILE(NWDD) SHR\"\n\"EXECIO * DISKR NWDD (STEM VOLDATA. FINIS\"\nSRC = RC\n\"FREE FILE(NWDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** EXECIO READ ERROR: ('NWLIB.3'('VOLMEMB'). ***'\n   SAY '*** NWABEND EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nDO I = 1 TO VOLDATA.0\n   UPPER VOLDATA.I\n   SVOL = POS(VOLKEY,VOLDATA.I)\n   IF SVOL = 0 THEN ITERATE\n   V = V + 1\n   VOL.V = WORD(VOLDATA.I,1)\nEND\nVOLCNT = V\nRETURN\n/*     */\nCHECK_LOCAL_STATUS:\nENDSW = 'NO'\nLANVOL = LEFT(SERVOL,4)\nBACKUP_STATUS = 'FAIL'\nEND_TEXT = 'BACKUP OF VOLUME 'SERVOL' TERMINATING'\nDO L = 1 TO LST.0\n   UPPER LST.L\n   ENDKEY = POS(END_TEXT,LST.L)\n   IF ENDKEY \u00ac= 0 THEN ENDSW = 'YES'\n   IF ENDSW = 'YES' THEN DO\n      STATKEY = POS(STATUS_TEXT,LST.L)\n      IF STATKEY \u00ac= 0 THEN DO\n         NUMWORDS = WORDS(LST.L)\n         GLOBAL_STATUS = WORD(LST.L,NUMWORDS)\n         LEAVE\n      END\n   END\nEND\nBUSTATUS = SUBSTR(GLOBAL_STATUS,1,4)\nIF BUSTATUS = 'SSSS' THEN DO\n   BACKUP_STATUS = 'OK'\n   RETURN\nEND\nDO E = 1 TO 4\n   BACKUP_STATUS = 'OK'\n   POSTAT = SUBSTR(GLOBAL_STATUS,E,1)\n   IF POSTAT = 'S' | POSTAT = 'W' THEN ITERATE\n   BACKUP_STATUS = 'FAIL'\nEND\nIF BACKUP_STATUS = 'FAIL' THEN DO\n   MSGSW = 'YES'\n   S = S + 1\n   MSG.S = LANVOL '*** BACKUP FAILED ***'\nEND\nRETURN\n/*     */\nCHECK_REMOTE_STATUS:\nREMOTE_STATUS = 'OK'\nDO E = 5 TO 8\n   POSTAT = SUBSTR(GLOBAL_STATUS,E,1)\n   IF POSTAT = 'S' | POSTAT = 'W' THEN ITERATE\n   REMOTE_STATUS = 'FAIL'\nEND\nS7 = SUBSTR(GLOBAL_STATUS,7,1)\nS8 = SUBSTR(GLOBAL_STATUS,8,1)\nIF S7 = 'E' | S8 = 'E' THEN REMOTE_STATUS = 'OK'\nIF REMOTE_STATUS = 'OK' THEN DO\n   MSGSW = 'YES'\n   S = S + 1\n   MSG.S = LANVOL '+++ BACKUP SUCCESSFUL +++'\n   RETURN\nEND\nERC = 8\nMSGSW = 'YES'\nS = S + 1\nMSG.S = LANVOL '+++ BACKUP SUCCESSFUL +++ >>> REMOTE SERVER ERROR'\nS = S + 1\nMSG.S = 'NOTIFY THE ON-CALL LAN COMMUNICATIONS PERSON.'\nRETURN\n/*     */\nWRITE_MESSAGE_MEMBER:\n\"DELSTACK\"\nOUTPDS = NWLIB.1\n\"ALLOC DA('\"OUTPDS\"(\"OUTMEMB\")') FILE(NWDD) SHR\"\nDO M = 1 TO MCNT\n   QUEUE MSG.M\nEND\n\"EXECIO\" MCNT \"DISKW NWDD (FINIS\"\nSRC = RC\n\"FREE FILE(NWDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** WRITE ERROR: ERROR WRITING 'OUTPDS'('OUTMEMB'). ***'\n   SAY '*** NWABEND EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nRETURN\n/*     */\nWRITE_RESTART_PARMS:\n\"DELSTACK\"\nMSGCNT = F\nOUTPDS = NWLIB.2\nOUTMEMB = DIR||'RSPRM'\n\"ALLOC DA('\"OUTPDS\"(\"OUTMEMB\")') FILE(NWDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('OUTPDS'('OUTMEMB'). ***'\n   SAY '*** NWABEND EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nDO M = 1 TO MSGCNT\n   QUEUE FMSG.M\nEND\n\"EXECIO\" MSGCNT \"DISKW NWDD (FINIS\"\nSRC = RC\n\"FREE FILE(NWDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** WRITE ERROR: ERROR WRITING 'OUTPDS'('OUTMEMB'). ***'\n   SAY '*** NWABEND EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "NWALLOC": {"ttr": 16130, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01Y\\x00\\x00\\x00\\x925\\x8f\\x00\\x95\\x04\\x7f\\tV\\x01\\x9b\\x00P\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf3@@@'", "ispf": {"version": "01.89", "flags": 0, "createdate": "1992-12-23T00:00:00", "modifydate": "1995-02-16T09:56:00", "lines": 411, "newlines": 80, "modlines": 0, "user": "TECH103"}, "text": "/*  REXX EXEC : ( NWALLOC ).\n    FUNCTION  : VERIFIES AND/OR ALLOCATES THE HISTORY AN OLD HISTORY\n                DATASETS FOR EACH SERVER VOLUME SPECIFIED IN THE VOLUMES\n                PARM FILE FOR THE NETWORK SYSTEMS USER ACCESS LAN BACKUP.\n                PERFORMS MAINTENANCE CLEANUP OF HISTORY DATASET ENTRIES\n                FOR DATASETS NO LONGER FOUND IN THE CATALOG.\n                                                                    */\n/*      */\nHOUSE_KEEPING:\nADDRESS TSO\nARG SERVER BACKUP_TYPE\n/* ARG SERVER BACKUP_TYPE */\nIF SERVER = '' THEN DO\n   SAY '*** PARM ERROR: LAN SERVER NAME NOT PASSED ON COMMAND LINE.***'\n   SAY '*** NWALLOC EXEC TASK CANCELLED. ***'\n   EXIT 101\nEND\nIF BACKUP_TYPE = '' THEN DO\n   SAY '*** PARM ERROR: BACKUP TYPE NOT SPECIFIED FOR 'SERVER' LAN BACKUP. ***'\n   SAY '*** NWALLOC EXEC TASK CANCELLED. ***'\n   EXIT 102\nEND\nX = MSG(\"OFF\")\nBUTYPE = 'NOOP'\nDSNSUFX = 'H O UPDPRINT'\nLBLNODE = 'HISTORY HISTORY LISTING'\nPRTNODE = 'SCHPRINT SYSPRINT UPDPRINT'\nBUCNT = 5\nDIRBU = 'MAGIC POS REA ASP APPL'\nDIRVOL = 'MAG POS REA ASP APPL'\nDIRKEY.1 = 'MAGIC SYS:'\nDIRKEY.2 = 'POS VOL1:'\nDIRKEY.3 = 'REA VOL2:'\nDIRKEY.4 = 'ASP VOL1:'\nDIRKEY.5 = 'APPL VOL3:'\nVOLCNT = 0\nALLOCSW = 'NO'\nTLMSRCD = 'UPV XXXXXX,SCRATCH=YES'\nTEXTLIB = 'SYSS.NETCA.CONTROL.TEXTLIB'\nPARMLIB = 'SYSS.NETCA.RESTART.PARMLIB'\nHSTMODEL = 'SYSS.NETCA.MODEL.HIST'\nPRTMODEL = 'SYSS.NETCA.MODEL.SYSPRINT'\n/*     */\nIF BACKUP_TYPE = 'DAILY'   THEN BUTYPE = 'INCR'\nIF BACKUP_TYPE = 'DAILYF'  THEN BUTYPE = 'FULL'\n/*     */\nCHECK_DIRECTORY_BACKUP:\nDIRSW = 'NO'\nDO B = 1 TO BUCNT\n   DIR = WORD(DIRBU,B)\n   IF DIR = BACKUP_TYPE THEN DO\n      DIRSW = 'YES'\n      BUTYPE = 'FULL'\n      SERVOL = BACKUP_TYPE\n      LANVOL = WORD(DIRVOL,B)\n      TLMSMEMB = LANVOL'TLMS'\n      VOLKEY = DIRKEY.B\n      HSTDSN = 'PTECH2.NETCA.'SERVER'.'SERVOL'.H'\n      LEAVE\n   END\nEND\nIF DIRSW = 'YES' THEN DO\n   DO V = 1 TO 3\n      SUFX = WORD(DSNSUFX,V)\n      LNODE = WORD(LBLNODE,V)\n      PNODE = WORD(PRTNODE,V)\n   \"DELETE ('PTECH2.NETCA.\"SERVER\".\"SERVOL\".\"PNODE\"') NONVSAM SCRATCH PURGE\"\n    VOLDSN = SYSDSN(\"'PTECH2.NETCA.\"SERVER\".\"SERVOL\".\"SUFX\"'\")\n      IF VOLDSN = 'DATASET NOT FOUND' THEN DO\n         LABEL = 'ALLOCATE_'LNODE'_DATASET'\n         INTERPRET CALL LABEL\n      END\n   END\n   CALL CHECK_TLMS_MEMBER\n   IF ALLOCSW = 'YES' THEN EXIT 0\n   CALL LISTCAT_FULL_CONTAINER\n   IF MNTSW = 'NO' THEN EXIT 0\n   CALL READ_HISTORY_DATASET\n   IF MNTSW = 'NO' THEN EXIT 0\n   IF HIST.0 = 0 THEN EXIT 0\n   CALL SAVE_HISTORY_DATASET\n   IF MNTSW = 'NO' THEN EXIT 0\n   CALL PERFORM_HISTORY_MAINTENANCE\n   IF QUESW = 'NO' THEN EXIT 0\n   CALL REWRITE_HISTORY_DATASET\n   EXIT 0\nEND\n/*   E N D   O F   MAG / POS / ASP / REA   S E C T I O N   */\n/*     */\nTLMSMEMB = SERVER'TLMS'\nCALL CHECK_TLMS_MEMBER\nVOLMEMB = SERVER||'IVOLS'\nIF BUTYPE = 'FULL' THEN VOLMEMB = SERVER||'FVOLS'\nVOLPARM = SYSDSN(\"'\"TEXTLIB\"(\"VOLMEMB\")'\")\nIF VOLPARM = 'MEMBER NOT FOUND' THEN DO\n   SAY '*** PARM ERROR: INVALID BACKUP PARM ('BACKUP_TYPE'). ***'\n   SAY '*** MEMBER NOT FOUND: ('TEXTLIB'('VOLMEMB'). ***'\n   SAY '*** NWALLOC EXEC TASK CANCELLED. ***'\n   EXIT 103\nEND\n\"FREE FILE(NWDD)\"\n\"DELETE  ('PTECH2.NETCA.\"SERVER\".SCHPRINT') NONVSAM SCRATCH PURGE\"\n\"DELETE ('PTECH2.NETCA.\"SERVER\".SYSPRINT') NONVSAM SCRATCH PURGE\"\n/*     */\nMAIN_ROUTINE:\nCALL READ_VOLUMES_PARMS\nDO V = 1 TO VOL.0\n   UPPER VOL.V\n   LANBU = POS(BACKUP_TYPE,VOL.V)\n   IF LANBU = 0 THEN ITERATE\n   VOLCNT = VOLCNT + 1\n   SERVOL = WORD(VOL.V,1)\n   LANVOL = WORD(VOL.V,1)\n   HSTDSN = 'PTECH2.NETCA.'SERVER'.'SERVOL'.H'\n   DO S = 1 TO 3\n      SUFX = WORD(DSNSUFX,S)\n      LNODE = WORD(LBLNODE,S)\n      VOLDSN = SYSDSN(\"'PTECH2.NETCA.\"SERVER\".\"SERVOL\".\"SUFX\"'\")\n      IF VOLDSN = 'DATASET NOT FOUND' THEN DO\n         LABEL = 'ALLOCATE_'LNODE'_DATASET'\n         INTERPRET CALL LABEL\n      END\n   END\n   IF ALLOCSW = 'YES' THEN ITERATE\n   CALL LISTCAT_INCR_CONTAINER\n   IF MNTSW = 'NO' THEN ITERATE\n   CALL LISTCAT_FULL_CONTAINER\n   IF MNTSW = 'NO' THEN ITERATE\n   CALL READ_HISTORY_DATASET\n   IF MNTSW = 'NO' THEN ITERATE\n   IF HIST.0 = 0 THEN ITERATE\n   CALL SAVE_HISTORY_DATASET\n   IF MNTSW = 'NO' THEN ITERATE\n   VOLKEY = SERVOL SERVOL':'\n   CALL PERFORM_HISTORY_MAINTENANCE\n   IF QUESW = 'NO' THEN ITERATE\n   CALL REWRITE_HISTORY_DATASET\nEND\nIF VOLCNT = 0 THEN DO\n   SAY '*** PARM ERROR: BACKUP TYPE ( 'BACKUP_TYPE' ) NOT FOUND FOR ('SERVER')'\n   SAY '                IN ('TEXTLIB'('VOLMEMB'). ***'\n   SAY '*** NWALLOC EXEC SUBTASK CANCELLED. ***'\n   EXIT 8\nEND\nEXIT 0\n/*\n       S U B R O U T I N E S   S E C T I O N     */\n/*     */\nDELETE_TLMS_MEMBER:\nRETURN\n/* ***   N O O P   *** */\nNWDEL = SYSDSN(\"'\"PARMLIB\"(\"TLMSMEMB\")'\")\nIF NWDEL = 'OK' THEN DO\n   \"ALLOC DA('\"PARMLIB\"(\"TLMSMEMB\")') FILE(NWDD) SHR\"\n   \"DELETE ('\"PARMLIB\"(\"TLMSMEMB\")') FILE(NWDD)\"\n   \"FREE FILE(NWDD)\"\nEND\nRETURN\n/*     */\nREAD_VOLUMES_PARMS:\n\"ALLOC DA('\"TEXTLIB\"(\"VOLMEMB\")') FILE(NWDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('TEXTLIB'('VOLMEMB'). ***'\n   SAY '*** NWALLOC EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\n\"EXECIO * DISKR NWDD (FINIS STEM VOL.\"\nSRC = RC\n\"FREE FILE(NWDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** EXECIO READ ERROR: ('TEXTLIB'('VOLMEMB'). ***'\n   SAY '*** NWALLOC EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nRETURN\n/*     */\nALLOCATE_HISTORY_DATASET:\nALLOCSW = 'YES'\n\"ALLOC DA('PTECH2.NETCA.\"SERVER\".\"SERVOL\".\"SUFX\"')\nLIKE('\"HSTMODEL\"') NEW SPACE(1,1) TRACKS BLKSIZE(3120)\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** ALLOCATE ERROR: ERROR ALLOCATING 'SERVER' DATASET:'\n   SAY '                    (PTECH2.NETCA.'SERVER'.'SERVOL'.'SUFX'). ***'\n   SAY '*** NWALLOC EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\n\"FREE DA('PTECH2.NETCA.\"SERVER\".\"SERVOL\".\"SUFX\"')\"\nRETURN\n/*     */\nALLOCATE_LISTING_DATASET:\n\"ALLOC DA('PTECH2.NETCA.\"SERVER\".\"SERVOL\".\"SUFX\"')\nLIKE('\"PRTMODEL\"') NEW SPACE(1,1) CYLINDERS BLKSIZE(133) DATACLAS(LISTING)\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** ALLOCATE ERROR: ERROR ALLOCATING 'SERVER' DATASET:'\n   SAY '                    (PTECH2.NETCA.'SERVER'.'SERVOL'.'SUFX'). ***'\n   SAY '*** NWALLOC EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\n\"FREE DA('PTECH2.NETCA.\"SERVER\".\"SERVOL\".\"SUFX\"')\"\nRETURN\n/*     */\nCHECK_TLMS_MEMBER:\nADDRESS TSO\nTLMS = SYSDSN(\"'\"PARMLIB\"(\"TLMSMEMB\")'\")\nIF TLMS = 'OK' THEN RETURN\n\"DELSTACK\"\nQUEUE TLMSRCD\n\"ALLOC DA('\"PARMLIB\"(\"TLMSMEMB\")') FILE(NWDD) SHR\"\n\"EXECIO 1 DISKW NWDD (FINIS\"\nSRC = RC\n\"FREE FILE(NWDD)\"\nIF SRC = 0 THEN RETURN\nSAY '*** EXECIO WRITE ERROR: ('PARMLIB'('TLMSMEMB'). ***'\nSAY '*** NOTIFY ON-CALL TECH SUPPORT PERSON IMMEDIATELY. ***'\nSAY '*** NWALLOC EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\nEXIT SRC\n/*     */\nLISTCAT_FULL_CONTAINER:\nIF ALLOCSW = 'YES' THEN RETURN\nMNTSW = 'NO'\nRETURN\n/* ***   N O O P   *** */\nF = 0\nMNTSW = 'YES'\nDSNLVL = 'PTAP.NETCA.'SERVER'.'LANVOL'.FULL.CONTAINR'\nX = OUTTRAP(\"LSTCAT.\",\"*\",\"CONCAT\")\n\"LISTCAT LEVEL(\"DSNLVL\") NAMES\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** LISTCAT ERROR: MAINT CLEANUP FOR 'SERVER' HIST FILES BYPASSED. ***'\n   MNTSW = 'NO'\n   RETURN\nEND\nDO L = 1 TO LSTCAT.0\n   DSNKEY = POS(\"NONVSAM ------- \",LSTCAT.L)\n   IF DSNKEY \u00ac= 0 THEN DO\n      F = F + 1\n      FULL.F = WORD(LSTCAT.L,3)\n   END\nEND\nFULLCNT = F\nRETURN\n/*     */\nLISTCAT_INCR_CONTAINER:\nIF ALLOCSW = 'YES' THEN RETURN\nMNTSW = 'NO'\nRETURN\n/* ***   N O O P   *** */\nD = 0\nMNTSW = 'YES'\nDSNLVL = 'PTAP.NETCA.'SERVER'.'LANVOL'.INCR.CONTAINR'\nX = OUTTRAP(\"LSTCAT.\",\"*\",\"CONCAT\")\n\"LISTCAT LEVEL(\"DSNLVL\") NAMES\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** LISTCAT ERROR: MAINT CLEANUP FOR 'SERVER' HIST FILES BYPASSED. ***'\n   MNTSW = 'NO'\n   RETURN\nEND\nDO L = 1 TO LSTCAT.0\n   DSNKEY = POS(\"NONVSAM ------- \",LSTCAT.L)\n   IF DSNKEY \u00ac= 0 THEN DO\n      D = D + 1\n      INCR.D = WORD(LSTCAT.L,3)\n   END\nEND\nINCRCNT = D\nRETURN\n/*     */\nREAD_HISTORY_DATASET:\nIF ALLOCSW = 'YES' THEN RETURN\nMNTSW = 'NO'\nRETURN\n/* ***   N O O P   *** */\nMNTSW = 'YES'\n\"ALLOC DA('\"HSTDSN\"') FILE(NWDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** ALLOCATE ERROR: ERROR ALLOCATING ('HSTDSN'). ***'\n   SAY '*** HISTORY MAINTENANCE CLEANUP NOT PERFORMED FOR ('SERVOL'). ***'\n   MNTSW = 'NO'\n   RETURN\nEND\n\"EXECIO * DISKR NWDD (FINIS STEM HIST.\"\nSRC = RC\n\"FREE FILE(NWDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** EXECIO READ ERROR: ('HSTDSN'). ***'\n   SAY '*** HISTORY MAINTENANCE CLEANUP NOT PERFORMED FOR ('SERVOL'). ***'\n   MNTSW = 'NO'\n   RETURN\nEND\nRETURN\n/*     */\nSAVE_HISTORY_DATASET:\nIF ALLOCSW = 'YES' THEN RETURN\nMNTSW = 'NO'\nRETURN\n/* ***   N O O P   *** */\n\"DELSTACK\"\nMNTSW = 'YES'\nSAVEHIST = HSTDSN'.SAVE'\n\"DELETE   ('\"SAVEHIST\"')  NONVSAM SCRATCH PURGE\"\n\"ALLOC DA('\"SAVEHIST\"') LIKE('SYSS.NETCA.MODEL.HIST') NEW SPACE(1,1) TRACKS\nBLKSIZE(3120)\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** ALLOCATE ERROR: ('SAVEHIST'). ***'\n   SAY '*** HISTORY MAINTENANCE CLEANUP NOT PERFORMED FOR ('SERVOL'). ***'\n   MNTSW = 'NO'\n   RETURN\nEND\nDO H = 1 TO HIST.0\n   QUEUE HIST.H\nEND\n\"ALLOC DA('\"SAVEHIST\"') FILE(NWDD) SHR\"\nNUMRCDS = QUEUED()\n\"EXECIO\" NUMRCDS \"DISKW NWDD (FINIS\"\nSRC = RC\n\"FREE FILE(NWDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** WRITE ERROR: ERROR WRITING ('SAVEHIST'). ***'\n   SAY '*** HISTORY MAINTENANCE CLEANUP NOT PERFORMED FOR ('SERVOL'). ***'\n   MNTSW = 'NO'\n   RETURN\nEND\nRETURN\n/*     */\nPERFORM_HISTORY_MAINTENANCE:\nIF ALLOCSW = 'YES' THEN RETURN\nQUESW = 'NO'\nRETURN\n/* ***   N O O P   *** */\n\"DELSTACK\"\nQUESW = 'NO'\nDO H = 1 TO HIST.0\n   HISTRCD = HIST.H\n   UPPER HISTRCD\n   VLOC = POS(VOLKEY,HISTRCD)\n   IF VLOC \u00ac= 0 THEN DO\n      BUSTATUS = WORD(HISTRCD,9)\n      IF BUSTATUS = 'SSSS' THEN DO\n         HIST_BUTYPE = WORD(HISTRCD,5)\n         IF HIST_BUTYPE = 'INCR' THEN DO\n            N = H + 1\n            HISTRCD2 = HIST.N\n            UPPER HISTRCD2\n            HIST_BUDSN = WORD(HISTRCD2,2)\n            HIST_BUDSN = STRIP(HIST_BUDSN,\"B\",\"'\")\n            DO D = 1 TO INCRCNT\n               IF HIST_BUDSN = INCR.D THEN DO\n                  CALL QUEUE_HISTORY_RECORDS\n                  LEAVE\n               END\n            END\n         END\n         IF HIST_BUTYPE = 'FULL' THEN DO\n            N = H + 1\n            HISTRCD2 = HIST.N\n            UPPER HISTRCD2\n            HIST_BUDSN = WORD(HISTRCD2,2)\n            HIST_BUDSN = STRIP(HIST_BUDSN,\"B\",\"'\")\n            DO F = 1 TO FULLCNT\n               IF HIST_BUDSN = FULL.F THEN DO\n                  CALL QUEUE_HISTORY_RECORDS\n                  LEAVE\n               END\n            END\n         END\n      END\n   END\nEND\nRETURN\n/*     */\nQUEUE_HISTORY_RECORDS:\nQUESW = 'YES'\nW = H - 1\nDO 5\n   W = W + 1\n   QUEUE HIST.W\nEND\nRETURN\n/*     */\nREWRITE_HISTORY_DATASET:\nIF ALLOCSW = 'YES' THEN RETURN\n\"DELETE   ('\"HSTDSN\"') NONVSAM SCRATCH PURGE\"\n\"ALLOC DA('\"HSTDSN\"') LIKE('SYSS.NETCA.MODEL.HIST') NEW SPACE(1,1) TRACKS\nBLKSIZE(3120)\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** ALLOCATE ERROR: ('HSTDSN'). ***'\n   SAY '*** HISTORY MAINTENANCE CLEANUP NOT PERFORMED FOR ('SERVOL'). ***'\n   SAY '*** CONTACT TECHNICAL SUPPORT CRITICAL CALL LIST PERSONNEL. ***'\n   EXIT 8\nEND\n\"ALLOC DA('\"HSTDSN\"') FILE(NWDD) SHR\"\nNUMRCDS = QUEUED()\n\"EXECIO\" NUMRCDS \"DISKW NWDD (FINIS\"\nSRC = RC\n\"FREE FILE(NWDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** WRITE ERROR: ERROR RE-WRITING ('HSTDSN'). ***'\n   SAY '*** HISTORY MAINTENANCE CLEANUP NOT PERFORMED FOR ('SERVOL'). ***'\n   SAY '*** CONTACT TECHNICAL SUPPORT CRITICAL CALL LIST PERSONNEL. ***'\n   EXIT 8\nEND\n\"FREE DA('\"HSTDSN\"')\"\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "NWALLOCV": {"ttr": 16137, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x93\\x02\\x0f\\x00\\x93\\x04\\x9f\\x185\\x00a\\x008\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf3@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1993-01-20T00:00:00", "modifydate": "1993-02-18T18:35:00", "lines": 97, "newlines": 56, "modlines": 0, "user": "TECH103"}, "text": "/*  REXX EXEC : ( NWALLOCV ).\n    FUNCTION  : VERIFIES AND/OR ALLOCATES THE HISTORY AN OLD HISTORY\n                DATASETS FOR EACH SERVER VOLUME SPECIFIED IN THE VOLUMES\n                PARM FILE FOR THE NETWORK SYSTEMS USER ACCESS LAN BACKUP.\n                                                                    */\nTRACE O\n/*     */\nHOUSE_KEEPING:\nADDRESS TSO\nARG SERVER SERVOL\nIF SERVER = '' THEN DO\n   SAY '*** PARM ERROR: LAN SERVER NAME NOT PASSED ON COMMAND LINE.***'\n   SAY '*** NWALLOCV EXEC TASK CANCELLED. ***'\n   EXIT 1\nEND\nIF SERVOL = '' THEN DO\n   SAY '*** PARM ERROR: BACKUP VOL NOT SPECIFIED FOR 'SERVER' LAN BACKUP. ***'\n   SAY '*** NWALLOCV EXEC TASK CANCELLED. ***'\n   EXIT 2\nEND\nVOLPARM = SYSDSN(\"'SYSS.NETCA.\"SERVER\".\"SERVOL\".VOLUMES'\")\nIF VOLPARM = 'DATASET NOT FOUND' THEN DO\n   SAY '*** INPUT DSN ERROR: DATASET NOT FOUND FOR:'\n   SAY '               (SYSS.NETCA.'SERVER'.'SERVOL'.VOLUMES). ***'\n   SAY '*** NWALLOCV EXEC TASK CANCELLED. ***'\n   EXIT 28\nEND\nV = 0\nDSNSUFX = 'H O'\nX = MSG(\"OFF\")\n/*  JULDATE = DATE(J)\n   JNODE = 'J'JULDATE  */\n\"FREE FILE(ISPFILE)\"\nCALL DELETE_WORK_DATASETS\n/* *** NWPDS = 'PTECH3.NETCA.'||SERVER'.'JNODE\nNWDSN = SYSDSN(\"'\"NWPDS\"'\")\nIF NWDSN = 'OK' THEN SIGNAL MAIN_ROUTINE\nCALL DELETE_WORK_DATASETS\n\"ALLOC DA('\"NWPDS\"') LIKE('SYS1.PARMLIB') NEW SPACE(1,0) DIR(5) CYLINDERS\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** ALLOCATE ERROR: ERROR ALLOCATING DATASET ('SERVER'.'JNODE'). ***'\n   SAY '*** NWALLOC EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND            *** */\n\n/*     */\nMAIN_ROUTINE:\nDO 2\n   V = V + 1\n   SUFX = WORD(DSNSUFX,V)\n   VOLDSN = SYSDSN(\"'PTECH3.NETCA.\"SERVER\".\"SERVOL\".\"SUFX\"'\")\n   IF VOLDSN = 'DATASET NOT FOUND' THEN CALL ALLOCATE_VOLUME_DATASET\nEND\nEXIT 0\n\n/*     S U B R O U T I N E S   S E C T I O N     */\n\n/*     */\nDELETE_WORK_DATASETS:\nADDRESS TSO\nHLQ = 'PTECH3.NETCA.'SERVER\n\"DELETE   ('PTECH3.NETCA.\"SERVER\".LISTING')   NONVSAM SCRATCH PURGE\"\nRETURN\nX = OUTTRAP(\"LSTCAT.\",\"*\",\"CONCAT\")\n\"LISTCAT LEVEL(\"HLQ\")\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** LISTCAT ERROR: MAINT CLEANUP FOR 'SERVER' WORK FILES BYPASSED. ***'\n   RETURN\nEND\nDO L = 1 TO LSTCAT.0\n   DATAKEY = POS(\"NONVSAM ------- \",LSTCAT.L)\n   IF DATAKEY \u00ac= 0 THEN DO\n      DATADSN = WORD(LSTCAT.L,3)\n      DATADSN = STRIP(DATADSN)\n      PARSE VALUE DATADSN WITH NODE1 '.' NODE2 '.' NODE3 '.' NODE4\n      JULKEY = SUBSTR(NODE4,1,1)\n      IF JULKEY = 'J' THEN DO\n         \"DELETE   ('\"DATADSN\"')   NONVSAM SCRATCH PURGE\"\n      END\n   END\nEND\nRETURN\n\n/*     */\nALLOCATE_VOLUME_DATASET:\n\"ALLOC DA('PTECH3.NETCA.\"SERVER\".\"SERVOL\".\"SUFX\"')\nLIKE('SYSS.NETCA.MODEL.HIST') NEW SPACE(1,1) TRACKS BLKSIZE(3120)\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** ALLOCATE ERROR: ERROR ALLOCATING 'SERVER' DATASET:'\n   SAY '                    (PTECH3.NETCA.'SERVER'.'SERVOL'.'SUFX'). ***'\n   SAY '*** NWALLOCV EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "NWBACKUP": {"ttr": 16140, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01Y\\x00\\x00\\x00\\x93\\x04\\x1f\\x00\\x95\\x04\\x8f\\x18\\x00\\x00\\x1f\\x00\\xaf\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf3@@@'", "ispf": {"version": "01.89", "flags": 0, "createdate": "1993-02-10T00:00:00", "modifydate": "1995-02-17T18:00:00", "lines": 31, "newlines": 175, "modlines": 0, "user": "TECH103"}, "text": "/*  REXX EXEC : ( NWBACKUP ).\n    FUNCTION  : LAN BACKUP PANEL INTERFACE FACILITY FOR RESTART OF A\n                SPECIFIED SERVER VOLUME(S).\n                BUILDS AND SUBMITS THE JOB REQUIRED TO PERFORM THE\n                BACKUP OF THE FAILED VOLUME(S).\n    INPUT     : PTECH2.NETCA.RESTART.PARMLIB(&SERVER||'RSPRM').\n    OUTPUT    : &&USERID.DIALOG.ISPFILE(&&SERVER).\n                                                                    */\nTRACE O\n/*     */\nDISPLAY_SERVER_PANEL:\nADDRESS ISPEXEC\nTSOID = SYSVAR(SYSUID)\n\"DISPLAY PANEL(NWSRVPNL)\"\nSRC = RC\nIF SRC = 8 THEN EXIT 0\nIF SRC > 8 THEN DO\n   SAY '*** ERROR INVOKING ISPF DIALOG PANEL ( NWSRVPNL ). ***'\n   SAY '*** NWBACKUP EXEC TASK CANCELLED - RC = 'SRC'. ***'\n   EXIT SRC\nEND\n/*     */\nINVOKE_RESTART_EXEC:\nADDRESS TSO\nIF LAN > 11 THEN DO\n   LANUM = LAN - 11\n   \"%NWBNETEX\" LANUM\n   EXIT 0\nEND\n\"%NWBTCPIP\" LAN\nEXIT 0\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "NWBNETEX": {"ttr": 16385, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01W\\x00\\x00\\x00\\x93\\x04\\x1f\\x00\\x95\\x04\\x8f\\x17@\\x02\\x0f\\x00\\xaf\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf3@@@'", "ispf": {"version": "01.87", "flags": 0, "createdate": "1993-02-10T00:00:00", "modifydate": "1995-02-17T17:40:00", "lines": 527, "newlines": 175, "modlines": 0, "user": "TECH103"}, "text": "/*  REXX EXEC : ( NWBACKUP ).\n    FUNCTION  : LAN BACKUP PANEL INTERFACE FACILITY FOR RESTART OF A\n                SPECIFIED SERVER VOLUME(S).\n                BUILDS AND SUBMITS THE JOB REQUIRED TO PERFORM THE\n                BACKUP OF THE FAILED VOLUME(S).\n    INPUT     : PTECH2.NETCA.RESTART.PARMLIB(&SERVER||'RSPRM').\n    OUTPUT    : &USERID.DIALOG.ISPFILE(&SERVER).\n                                                                    */\nTRACE O\n/*      */\nHOUSE_KEEPING:\nARG LAN .\nADDRESS ISPEXEC\nTSOID = SYSVAR(SYSUID)\nSERVER.1 = 'POS PTTS31D'\nSERVER.2 = 'MAGIC PTTS32D'\nSERVER.3 = 'C6A PTTS50'        /* CS_6A  * SERVER 6                 */\nSERVER.4 = 'C6B PTTS51'        /* CS_6B  * SERVER 6                 */\nBUSW.1 = 'SELECT'\nBUSW.2 = 'ALL'\nBUTP.1 = 'INCR'\nBUTP.2 = 'FULL'\nJS = 'D'\nCONFIG = 'CONFIGTI'\nBUTYPE = 'INCR'\nBUPARM = 'DAILY'\nSUB_IMMED = 'MAGIC POS'\nIMMEDCNT = 2\nJCLLIB = 'SYSS.NETCA.NETEX.JCLLIB'\nTEXTLIB = 'SYSS.NETCA.CONTROL.TEXTLIB'\nPARMLIB = 'SYSS.NETCA.RESTART.PARMLIB'\nMSGLIB = 'SYSS.NETCA.MESSAGE.CNTLLIB'\nCTEXTLIB = 'SYSS.NETUA.CA.V1R1M1.TEXTLIB'\n\"CONTROL ERRORS RETURN\"\nX = MSG(\"OFF\")\n/*     */\nCHECK_RESTART_PARMS:\nADDRESS TSO\n\"FREE FILE(NWDD)\"\n\"FREE FILE(ISPFILE)\"\nSERVER = WORD(SERVER.LAN,1)\nTLMS1 = SERVER\nDO S = 1 TO IMMEDCNT\n   BYPASS = WORD(SUB_IMMED,S)\n   IF BYPASS = SERVER THEN DO\n      TLMS1 = SUBSTR(SERVER,1,3)\n      SUBMEMB = WORD(SERVER.LAN,2)\n      SUBPDS = JCLLIB\n      CALL SUBMIT_RESTART_JOB\n      EXIT 0\n   END\nEND\nRSPARM = SERVER||'RSPRM'\nTLMSMEMB = TLMS1||'TLMS'\nNWPDS = PARMLIB\nNWDSN = SYSDSN(\"'\"NWPDS\"(\"RSPARM\")'\")\nIF NWDSN = 'OK' THEN DO\n   VOLSW = 'RSTPARM'\n   CALL GET_RESTART_PARMS\n   IF BUTYPE = 'FULL' THEN DO\n      JS = 'W'\n      CONFIG = 'CONFIGTF'\n      BUPARM = 'DAILYF'\n   END\n   IF BLDJOB = 'NO' THEN DO\n      SUBPDS = JCLLIB\n      SMEMB = WORD(SERVER.LAN,2)\n      SUBMEMB = SMEMB||JS\n      CALL SUBMIT_RESTART_JOB\n      EXIT 0\n   END\n   CALL BUILD_RESTART_VOLUME_MEMBER\n   CALL WRITE_PDS_MEMBER\n   CALL BUILD_RESTART_CONFIG_MEMBER\n   IF CFM = 'MEMBER NOT FOUND' THEN CALL WRITE_PDS_MEMBER\n   CALL ALLOC_ISPFILE_PDS\n   CALL BUILD_RESTART_JOB\n   CALL WRITE_PDS_MEMBER\n   SMEMB = WORD(SERVER.LAN,2)\n   SUBMEMB = SMEMB||JS\n   SUBPDS = TSOID||'.DIALOG.ISPFILE'\n   CALL SUBMIT_RESTART_JOB\n   CALL DELETE_ISPFILE_PDS\n   EXIT 0\nEND\n\n/*     */\nBUILD_RESTART_VOLUME_CONFIG:\nADDRESS TSO\nBUTYPE = 'FULL'\nCALL READ_SERVER_VOLUMES_PARMS\nBUPARM = 'DAILY'\nCALL DISPLAY_VOLUME_PANEL\nIF BUSW.LBU = 'ALL' THEN DO\n   JS = 'D'\n   SUBPDS = JCLLIB\n   SMEMB = WORD(SERVER.LAN,2)\n   IF BUTP.BUT = 'FULL' THEN JS = 'W'\n   SUBMEMB = SMEMB||JS\n   CALL SUBMIT_RESTART_JOB\n   EXIT 0\nEND\nBUTYPE = BUTP.BUT\nIF BUTYPE = 'FULL' THEN BUPARM = 'DAILYF'\nCALL BUILD_PANEL_RESTART_VOLUME_MEMBER\nIF RCNT = 0 THEN DO FOREVER\n   ADDRESS ISPEXEC \"SETMSG MSG(NWLAN001)\"\n   CALL DISPLAY_VOLUME_PANEL\n   CALL BUILD_PANEL_RESTART_VOLUME_MEMBER\n   IF RCNT > 0 THEN LEAVE\nEND\nCALL WRITE_PDS_MEMBER\nCALL BUILD_RESTART_CONFIG_MEMBER\nIF CFM = 'MEMBER NOT FOUND' THEN CALL WRITE_PDS_MEMBER\nCALL ALLOC_ISPFILE_PDS\nCALL GET_PANEL_VOLUMES\nCALL BUILD_RESTART_JOB\nCALL WRITE_PDS_MEMBER\nSMEMB = WORD(SERVER.LAN,2)\nSUBMEMB = SMEMB||JS\nSUBPDS = TSOID||'.DIALOG.ISPFILE'\nCALL SUBMIT_RESTART_JOB\nCALL DELETE_ISPFILE_PDS\nEXIT 0\n\n/*     S U B R O U T I N E S   S E C T I O N     */\n/*     */\nGET_RESTART_PARMS:\nADDRESS TSO\nBLDJOB = 'YES'\n\"ALLOC DA('\"NWPDS\"(\"RSPARM\")') FILE(NWDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('NWPDS'('RSPARM'). ***'\n   SAY '*** NWBACKUP EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\n\"EXECIO * DISKR NWDD (FINIS STEM VOLR.\"\nSRC = RC\n\"FREE FILE(NWDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** EXECIO READ ERROR: ('NWPDS'('RSPARM'). ***'\n   SAY '*** NWBACKUP EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nSERVOL = WORD(VOLR.1,1)\nBUTYPE = WORD(VOLR.1,3)\nIF SERVOL = 'ALL' THEN BLDJOB = 'NO'\nRETURN\n\n/*     */\nBUILD_RESTART_VOLUME_MEMBER:\nADDRESS TSO\n\"DELSTACK\"\nOUTMEMB = SERVER||'VOLS'\nOUTPDS = PARMLIB\nVOLPARMS = SERVER||'FVOLS'\n\"ALLOC DA('\"TEXTLIB\"(\"VOLPARMS\")') FILE(NWDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('TEXTLIB'('VOLPARMS'). ***'\n   SAY '*** NWBACKUP EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\n\"EXECIO * DISKR NWDD (FINIS STEM VOLP.\"\nSRC = RC\n\"FREE FILE(NWDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** EXECIO READ ERROR: ('TEXTLIB'('VOLPARMS'). ***'\n   SAY '*** NWBACKUP EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nDO I = 1 TO VOLR.0\n   SERVOL = WORD(VOLR.I,1)\n   DO V = 1 TO VOLP.0\n      UPPER VOLP.V\n      PVOL = WORD(VOLP.V,1)\n      IF PVOL = SERVOL THEN QUEUE VOLP.V\n   END\nEND\nRETURN\n\n/*     */\nBUILD_RESTART_CONFIG_MEMBER:\nADDRESS TSO\n\"DELSTACK\"\nOUTMEMB = SERVER||'CONFG'\nOUTPDS = PARMLIB\nVOLMEMB = SERVER||'VOLS'\nCFM = SYSDSN(\"'\"PARMLIB\"(\"OUTMEMB\")'\")\nIF CFM = 'OK' THEN RETURN\n\"ALLOC DA('\"TEXTLIB\"(\"CONFIG\")') FILE(NWDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('TEXTLIB'('CONFIG'). ***'\n   SAY '*** NWBACKUP EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\n\"EXECIO * DISKR NWDD (FINIS STEM PARM.\"\nSRC = RC\n\"FREE FILE(NWDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** EXECIO READ ERROR: ('TEXTLIB'('CONFIG'). ***'\n   SAY '*** NWBACKUP EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nDO I = 1 TO PARM.0\n   CHG = POS('VOLUMES',PARM.I)\n   IF CHG \u00ac= 0 THEN DO\n      PARM.I = \"         VOLUMES      '\"PARMLIB\"(\"VOLMEMB\")'\"\n   END\n   QUEUE PARM.I\nEND\nRETURN\n\n/*     */\nBUILD_RESTART_JOB:\n\"DELSTACK\"\nJ = 22\nSRVCONFG = SERVER||'CONFG'\nSMEMB = WORD(SERVER.LAN,2)\nJN = SMEMB||JS\nOUTMEMB = JN\nWTR = SUBSTR(JN,2)\nWTRNAME = WTR'00'\nOUTPDS = TSOID||'.DIALOG.ISPFILE'\nSCHPRT = 'PTECH2.NETCA.'SERVER'.SCHPRINT'\nSYSPRT = 'PTECH2.NETCA.'SERVER'.SYSPRINT'\nJCL.1 = \"//\"JN\"  JOB O030OVRHD0000000,'\"SERVER\" LAN BACKUP',NOTIFY=TECH251,\"\nJCL.2 = \"//             CLASS=F,MSGCLASS=Q,MSGLEVEL=(1,1),REGION=6M\"\nJCL.3 = \"//STEP010  EXEC PGM=IKJEFT01,DYNAMNBR=30,\"\nJCL.4 = \"//         PARM='%NWALLOC \"SERVER\" \"BUPARM\"'\"\nJCL.5 = \"//SYSTSPRT DD SYSOUT=*\"\nJCL.6 = \"//SYSPRINT DD SYSOUT=*\"\nJCL.7 = \"//SYSIN DD DUMMY\"\nJCL.8 = \"//SYSLBC DD DSN=SYS1.BRODCAST,DISP=SHR\"\nJCL.9 = \"//SYSUADS DD DSN=SYS1.UADS,DISP=SHR\"\nJCL.10 = \"//SYSPROC DD DSN=SYSS.TECH.COMMON.EXECLIB,DISP=SHR\"\nJCL.11 = \"//SYSTSIN DD DUMMY\"\nJCL.12 = \"/*\"\nJCL.13 = \"//ABEND010 EXEC PGM=ABENDWTO,COND=(0,GE,STEP010)\"\nJCL.14 = \"//* *** STEPLIB DD DSN=SYS1.PROD.BATCH.LOADLIB,DISP=SHR\"\nJCL.15 = \"/*\"\nJCL.16 = \"//STEP020 EXEC PGM=NUACLIEN\"\nJCL.17 = \"//SCHPRINT DD DSN=\"SCHPRT\",DISP=(MOD,CATLG,DELETE),\"\nJCL.18 = \"// SPACE=(CYL,(2,0,0)),DCB=(RECFM=FBA,LRECL=133,BLKSIZE=133),\"\nJCL.19 = \"// DATACLAS=LISTING\"\nJCL.20 = \"//SYSPRINT DD DSN=\"SYSPRT\",DISP=(MOD,CATLG,DELETE),\"\nJCL.21 = \"// SPACE=(CYL,(2,0,0)),DCB=(RECFM=FBA,LRECL=133,BLKSIZE=133),\"\nJCL.22 = \"// DATACLAS=LISTING\"\nIF VOLSW = 'RSTPARM' THEN DO\n   DO I = 1 TO VOLR.0\n      JVOL = WORD(VOLR.I,1)\n      DDVOL = 'DDC'||JVOL\n      DDINDX = 'DDI'||JVOL\n      BT = BUTYPE\n      IF I = 1 THEN DO\n         TUNIT = 'UNIT=(SILO,,DEFER)'\n         SAVEDD = DDVOL\n      END\n      IF I > 1 THEN TUNIT = 'UNIT=AFF='SAVEDD\n      REC.1 = \"//\"DDVOL\"  DD DSN=PTAP.NETCA.\"SERVER\".\"JVOL\".\"BT\".CONTAINR(+1),\"\n      REC.2 = \"//         DISP=(NEW,CATLG,DELETE),\"TUNIT\",\"\n      REC.3 = \"//         VOLUME=(,,,99),LABEL=(1,SL),\"\n      REC.4 = \"//   DCB=(MODEL.DSCB,RECFM=U,LRECL=0,BLKSIZE=32760,DSORG=PS)\"\n      REC.5 = \"//\"DDINDX\" DD DSN=PTECH2.NETCA.\"SERVER\".\"JVOL\".\"BT\".INDEX(+1),\"\n      REC.6 = \"//            DISP=(NEW,CATLG,DELETE),\"\n      REC.7 = \"//  DCB=(BLKSIZE=27998,LRECL=27994,RECFM=VB,DSORG=PS),\"\n      REC.8 = \"//  DATACLAS=DATAPS,MGMTCLAS=STANDARD,STORCLAS=SCSTNRDG,\"\n      REC.9 = \"//  SPACE=(27998,(50,10),RLSE)\"\n      DO E = 1 TO 9\n         J = J + 1\n         JCL.J = REC.E\n      END\n   END\nEND\nIF VOLSW = 'PANEL' THEN DO\n   DO I = 1 TO VOLP.0\n      JVOL = WORD(VOLP.I,1)\n      DDVOL = 'DDC'||JVOL\n      DDINDX = 'DDI'||JVOL\n      BT = BUTYPE\n      IF I = 1 THEN DO\n         TUNIT = 'UNIT=(SILO,,DEFER)'\n         SAVEDD = DDVOL\n      END\n      IF I > 1 THEN TUNIT = 'UNIT=AFF='SAVEDD\n      REC.1 = \"//\"DDVOL\"  DD DSN=PTAP.NETCA.\"SERVER\".\"JVOL\".\"BT\".CONTAINR(+1),\"\n      REC.2 = \"//         DISP=(NEW,CATLG,DELETE),\"TUNIT\",\"\n      REC.3 = \"//         VOLUME=(,,,99),LABEL=(1,SL),\"\n      REC.4 = \"//   DCB=(MODEL.DSCB,RECFM=U,LRECL=0,BLKSIZE=32760,DSORG=PS)\"\n      REC.5 = \"//\"DDINDX\" DD DSN=PTECH2.NETCA.\"SERVER\".\"JVOL\".\"BT\".INDEX(+1),\"\n      REC.6 = \"//            DISP=(NEW,CATLG,DELETE),\"\n      REC.7 = \"//  DCB=(BLKSIZE=27998,LRECL=27994,RECFM=VB,DSORG=PS),\"\n      REC.8 = \"//  DATACLAS=DATAPS,MGMTCLAS=STANDARD,STORCLAS=SCSTNRDG,\"\n      REC.9 = \"//  SPACE=(27998,(50,10),RLSE)\"\n      DO E = 1 TO 9\n         J = J + 1\n         JCL.J = REC.E\n      END\n   END\nEND\nJCLCNT = J\nDO J = 1 TO JCLCNT\n   QUEUE JCL.J\nEND\nR = 0\nRCDCNT = 35\nRCD.1 = \"//NUACACON DD DSN=\"PARMLIB\"(\"SRVCONFG\"),DISP=SHR\"\nRCD.2 = \"//NUACATXT DD DSN=\"CTEXTLIB\",DISP=SHR\"\nRCD.3 = \"//PARAMS DD *\"\nRCD.4 = \"-HOST \"SERVER\" -OUTPUT 'PTECH2.NETCA.\"SERVER\".SCRIPT'\"\nRCD.5 = \"    DD:NUACACON -CHECK\"\nRCD.6 = \"//SYSIN DD *\"\nRCD.7 = \"SET INPUT VERIFY ON\"\nRCD.8 = \"INPUT DD:NUACATXT(BASIC) 'PTECH2.NETCA.\"SERVER\".SCRIPT'\"\nRCD.9 = \"/*\"\nRCD.10 = \"//STEP030 EXEC PGM=IKJEFT01,DYNAMNBR=30,\"\nRCD.11 = \"// PARM='%NWABEND \"SERVER\" \"BUTYPE\" RESTART',\"\nRCD.12 = \"// COND=(4,GE,STEP020)\"\nRCD.13 = \"//SYSTSPRT DD SYSOUT=*\"\nRCD.14 = \"//SYSPRINT DD SYSOUT=*\"\nRCD.15 = \"//SYSIN DD DUMMY\"\nRCD.16 = \"//SYSLBC DD DSN=SYS1.BRODCAST,DISP=SHR\"\nRCD.17 = \"//SYSUADS DD DSN=SYS1.UADS,DISP=SHR\"\nRCD.18 = \"//SYSPROC DD DSN=SYSS.TECH.COMMON.EXECLIB,DISP=SHR\"\nRCD.19 = \"//SYSTSIN DD DUMMY\"\nRCD.20 = \"/*\"\nRCD.21 = \"//STEP040  EXEC CATRPTS,COND=((4,GE,STEP020),(1,NE,STEP030))\"\nRCD.22 = \"//SYSIN    DD DSN=\"PARMLIB\"(\"TLMSMEMB\"),DISP=SHR\"\nRCD.23 = \"/*\"\nRCD.24 = \"//ABEND050 EXEC WTO,COND=(4,GE,STEP020)\"\nRCD.25 = \"//SYSIN DD DSN=\"MSGLIB\"(\"SERVER\"),DISP=SHR\"\nRCD.26 = \"/*\"\nRCD.27 = \"//STEP060 EXEC PGM=IEBGENER\"\nRCD.28 = \"//SYSUT1 DD DSN=\"SYSPRT\",DISP=SHR\"\nRCD.29 = \"//SYSUT2 DD SYSOUT=(V,\"WTRNAME\"),DCB=BLKSIZE=133\"\nRCD.30 = \"//SYSPRINT DD DUMMY\"\nRCD.31 = \"//SYSIN DD DUMMY\"\nRCD.32 =  \"/*\"\nRCD.33 = \"//*          ABEND STEP FOR RETURN CODE GE 4\"\nRCD.34 = \"//ABEND070 EXEC PGM=ABENDWTO,COND=(4,GE,STEP020)\"\nRCD.35 = \"//\"\nDO RCDCNT\n   R = R + 1\n   QUEUE RCD.R\nEND\nRETURN\n\n/*     */\nREAD_SERVER_VOLUMES_PARMS:\nVOLPARMS = SERVER||'FVOLS'\n\"ALLOC DA('\"TEXTLIB\"(\"VOLPARMS\")') FILE(NWDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('TEXTLIB'('VOLPARMS'). ***'\n   SAY '*** NWBACKUP EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\n\"EXECIO * DISKR NWDD (FINIS STEM VOLB.\"\nSRC = RC\n\"FREE FILE(NWDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** EXECIO READ ERROR: ('TEXTLIB'('VOLPARMS'). ***'\n   SAY '*** NWBACKUP EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nV = 0\nVOL1 = '*****'\nVOL2 = '*****'\nVOL3 = '*****'\nVOL4 = '*****'\nVOL5 = '*****'\nVOL6 = '*****'\nVOL7 = '*****'\nVOL8 = '*****'\nDO I = 1 TO VOLB.0\n   UPPER VOLB.I\n   SVOL = POS(BUPARM,VOLB.I)\n   IF SVOL = 0 THEN ITERATE\n   V = V + 1\n   SERVOL = WORD(VOLB.I,1)\n   IF V = 1 THEN VOL1 = LEFT(SERVOL,5,'*')\n   IF V = 2 THEN VOL2 = LEFT(SERVOL,5,'*')\n   IF V = 3 THEN VOL3 = LEFT(SERVOL,5,'*')\n   IF V = 4 THEN VOL4 = LEFT(SERVOL,5,'*')\n   IF V = 5 THEN VOL5 = LEFT(SERVOL,5,'*')\n   IF V = 6 THEN VOL6 = LEFT(SERVOL,5,'*')\n   IF V = 7 THEN VOL7 = LEFT(SERVOL,5,'*')\n   IF V = 8 THEN VOL8 = LEFT(SERVOL,5,'*')\nEND\nRETURN\n\n/*     */\nDISPLAY_VOLUME_PANEL:\nADDRESS ISPEXEC \"DISPLAY PANEL(NWVOLPNL)\"\nSRC = RC\nIF SRC = 8 THEN EXIT 0\nIF SRC > 8 THEN DO\n   SAY '*** ERROR INVOKING ISPF DIALOG PANEL ( NWVOLPNL ). ***'\n   SAY '*** NWBACKUP EXEC TASK CANCELLED - RC = 'SRC'. ***'\n   EXIT SRC\nEND\nRETURN\n\n/*     */\nBUILD_PANEL_RESTART_VOLUME_MEMBER:\nADDRESS TSO\n\"DELSTACK\"\nVOLSW = 'PANEL'\nOUTMEMB = SERVER||'VOLS'\nOUTPDS = PARMLIB\nVOLPARMS = SERVER||'FVOLS'\n\"ALLOC DA('\"TEXTLIB\"(\"VOLPARMS\")') FILE(NWDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('TEXTLIB'('VOLPARMS'). ***'\n   SAY '*** NWBACKUP EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\n\"EXECIO * DISKR NWDD (FINIS STEM VOLP.\"\nSRC = RC\n\"FREE FILE(NWDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** EXECIO READ ERROR: ('TEXTLIB'('VOLPARMS'). ***'\n   SAY '*** NWBACKUP EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nDO I = 1 TO 8\n   SELVOL = VALUE('VBU'I)\n   IF SELVOL = '' THEN ITERATE\n   BUVOL = VALUE('VOL'I)\n   IF BUVOL = '' THEN ITERATE\n   SVR = POS('*',BUVOL)\n   SVRVOL = BUVOL\n   IF SVR \u00ac= 0 THEN DO\n      SVR = SVR - 1\n      SVRVOL = SUBSTR(BUVOL,1,SVR)\n   END\n   DO V = 1 TO VOLP.0\n      UPPER VOLP.V\n      SVOL = POS(BUPARM,VOLP.V)\n      IF SVOL = 0 THEN ITERATE\n      PVOL = WORD(VOLP.V,1)\n      IF PVOL = SVRVOL THEN QUEUE VOLP.V\n   END\nEND\nRCNT = QUEUED()\nRETURN\n\n/*     */\nGET_PANEL_VOLUMES:\nVOLMEMB = SERVER||'VOLS'\n\"ALLOC DA('\"PARMLIB\"(\"VOLMEMB\")') FILE(NWDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('PARMLIB'('VOLMEMB'). ***'\n   SAY '*** NWBACKUP EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\n\"EXECIO * DISKR NWDD (FINIS STEM VOLP.\"\nSRC = RC\n\"FREE FILE(NWDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** EXECIO READ ERROR: ('PARMLIB'('VOLMEMB'). ***'\n   SAY '*** NWBACKUP EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nRETURN\n\n/*     */\nALLOC_ISPFILE_PDS:\nADDRESS TSO\nUCNTL = SYSDSN(DIALOG.ISPFILE)\nIF UCNTL = 'DATASET NOT FOUND' THEN DO\n\"ALLOC DA(DIALOG.ISPFILE) LIKE(USER.CNTLLIB) NEW SPACE(1,0) DIR(5) CYLINDERS\"\n   SRC = RC\n   IF SRC \u00ac= 0 THEN DO\n   SAY '*** ALLOCATE ERROR: ERROR ALLOCATING DATASET (DIALOG.ISPFILE). ***'\n   SAY '*** NWBACKUP EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\n   END\nEND\nRETURN\n\n/*     */\nWRITE_PDS_MEMBER:\n\"ALLOC DA('\"OUTPDS\"(\"OUTMEMB\")') FILE(NWDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('OUTPDS'('OUTMEMB'). ***'\n   SAY '*** NWBACKUP EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nNUMRCDS = QUEUED()\n\"EXECIO\" NUMRCDS \"DISKW NWDD (FINIS\"\nSRC = RC\n\"FREE FILE(NWDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** WRITE ERROR: ERROR WRITING 'OUTPDS'('OUTMEMB'). ***'\n   SAY '*** NWBACKUP EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nRETURN\n\n/*     */\nSUBMIT_RESTART_JOB:\nADDRESS TSO\n\"SUBMIT '\"SUBPDS\"(\"SUBMEMB\")'\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** SUBMIT ERROR: MEMBER ( 'SUBPDS'('SUBMEMB'). ***'\n   SAY '*** NWBACKUP EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nIF NWDSN = 'OK' THEN DO\n   \"ALLOC DA('\"NWPDS\"(\"RSPARM\")') FILE(NWDD) SHR\"\n   \"DELETE ('\"NWPDS\"(\"RSPARM\")') FILE(NWDD)\"\n   \"FREE FILE(NWDD)\"\nEND\nRETURN\n\n/*     */\nDELETE_ISPFILE_PDS:\nADDRESS TSO\n\"DELETE  (DIALOG.ISPFILE)   NONVSAM SCRATCH PURGE\"\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "NWBTCPIP": {"ttr": 16394, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01X\\x00\\x00\\x00\\x93\\x04\\x1f\\x00\\x95\\x04\\x8f\\x17U\\x02\\x18\\x00\\xaf\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf3@@@'", "ispf": {"version": "01.88", "flags": 0, "createdate": "1993-02-10T00:00:00", "modifydate": "1995-02-17T17:55:00", "lines": 536, "newlines": 175, "modlines": 0, "user": "TECH103"}, "text": "/*  REXX EXEC : ( NWBACKUP ).\n    FUNCTION  : LAN BACKUP PANEL INTERFACE FACILITY FOR RESTART OF A\n                SPECIFIED SERVER VOLUME(S).\n                BUILDS AND SUBMITS THE JOB REQUIRED TO PERFORM THE\n                BACKUP OF THE FAILED VOLUME(S).\n    INPUT     : PTECH2.NETCA.RESTART.PARMLIB(&SERVER||'RSPRM).\n    OUTPUT    : &USERID.DIALOG.ISPFILE(&SERVER).\n                                                                    */\nTRACE O\n/*      */\nHOUSE_KEEPING:\nARG LAN .\nADDRESS ISPEXEC\nTSOID = SYSVAR(SYSUID)\nSERVER.1 = 'CS1 PTTS12'\nSERVER.2 = 'CS2 PTTS13'\nSERVER.3 = 'FIN PTTS14'\nSERVER.4 = 'MIS PTTS15'\nSERVER.5 = 'REA PTTS41'       /* CS_1 VOL2 REALITY */\nSERVER.6 = 'C4A PTTS46'       /* CS_4A  */\nSERVER.7 = 'C4B PTTS47'       /* CS_4B  */\nSERVER.8 = 'CS5 PTTS48'       /* CS_5   */\nSERVER.9 = 'C5A PTTS49D'      /* CS_5A  * REALITY TEST ALWAYS FULL */\nSERVER.10 = 'APPL PTTS52D'    /* FIN APPL DIRECTORY BACKUP         */\nSERVER.11 = 'COM PTTS20M'     /* MONTHLY ONLY  */\nBUSW.1 = 'SELECT'\nBUSW.2 = 'ALL'\nBUTP.1 = 'INCR'\nBUTP.2 = 'FULL'\nJS = 'D'\nCONFIG = 'CONFIGTI'\nBUTYPE = 'INCR'\nBUPARM = 'DAILY'\nIMMEDCNT = 3\nSUB_IMMED = 'C5A APPL COM'\nJCLLIB = 'SYSS.NETCA.TCPIP.JCLLIB'\nTEXTLIB = 'SYSS.NETCA.CONTROL.TEXTLIB'\nPARMLIB = 'SYSS.NETCA.RESTART.PARMLIB'\nMSGLIB = 'SYSS.NETCA.MESSAGE.CNTLLIB'\nCTEXTLIB = 'SYSS.NETCA.V1R1M1.H213CMT.TEXTLIB'\n\"CONTROL ERRORS RETURN\"\nX = MSG(\"OFF\")\n/*     */\nCHECK_RESTART_PARMS:\nADDRESS TSO\n\"FREE FILE(NWDD)\"\n\"FREE FILE(ISPFILE)\"\nSERVER = WORD(SERVER.LAN,1)\nTLMS1 = SERVER\nDO S = 1 TO IMMEDCNT\n   BYPASS = WORD(SUB_IMMED,S)\n   IF BYPASS = SERVER THEN DO\n      TLMS1 = SUBSTR(SERVER,1,3)\n      SUBMEMB = WORD(SERVER.LAN,2)\n      SUBPDS = JCLLIB\n      CALL SUBMIT_RESTART_JOB\n      EXIT 0\n   END\nEND\nRSPARM = SERVER||'RSPRM'\nTLMSMEMB = TLMS1||'TLMS'\nNWPDS = PARMLIB\nNWDSN = SYSDSN(\"'\"NWPDS\"(\"RSPARM\")'\")\nIF NWDSN = 'OK' THEN DO\n   VOLSW = 'RSTPARM'\n   CALL GET_RESTART_PARMS\n   IF BUTYPE = 'FULL' THEN DO\n      JS = 'W'\n      CONFIG = 'CONFIGTF'\n      BUPARM = 'DAILYF'\n   END\n   IF BLDJOB = 'NO' THEN DO\n      SUBPDS = JCLLIB\n      SMEMB = WORD(SERVER.LAN,2)\n      SUBMEMB = SMEMB||JS\n      CALL SUBMIT_RESTART_JOB\n      EXIT 0\n   END\n   CALL BUILD_RESTART_VOLUME_MEMBER\n   CALL WRITE_PDS_MEMBER\n   CALL BUILD_RESTART_CONFIG_MEMBER\n   IF CFM = 'MEMBER NOT FOUND' THEN CALL WRITE_PDS_MEMBER\n   CALL ALLOC_ISPFILE_PDS\n   CALL BUILD_RESTART_JOB\n   CALL WRITE_PDS_MEMBER\n   SMEMB = WORD(SERVER.LAN,2)\n   SUBMEMB = SMEMB||JS\n   SUBPDS = TSOID||'.DIALOG.ISPFILE'\n   CALL SUBMIT_RESTART_JOB\n   CALL DELETE_ISPFILE_PDS\n   EXIT 0\nEND\n\n/*     */\nBUILD_RESTART_VOLUME_CONFIG:\nADDRESS TSO\nBUTYPE = 'FULL'\nCALL READ_SERVER_VOLUMES_PARMS\nBUPARM = 'DAILY'\nCALL DISPLAY_VOLUME_PANEL\nIF BUSW.LBU = 'ALL' THEN DO\n   JS = 'D'\n   SUBPDS = JCLLIB\n   SMEMB = WORD(SERVER.LAN,2)\n   IF BUTP.BUT = 'FULL' THEN JS = 'W'\n   SUBMEMB = SMEMB||JS\n   CALL SUBMIT_RESTART_JOB\n   EXIT 0\nEND\nBUTYPE = BUTP.BUT\nIF BUTYPE = 'FULL' THEN BUPARM = 'DAILYF'\nCALL BUILD_PANEL_RESTART_VOLUME_MEMBER\nIF RCNT = 0 THEN DO FOREVER\n   ADDRESS ISPEXEC \"SETMSG MSG(NWLAN001)\"\n   CALL DISPLAY_VOLUME_PANEL\n   CALL BUILD_PANEL_RESTART_VOLUME_MEMBER\n   IF RCNT > 0 THEN LEAVE\nEND\nCALL WRITE_PDS_MEMBER\nCALL BUILD_RESTART_CONFIG_MEMBER\nIF CFM = 'MEMBER NOT FOUND' THEN CALL WRITE_PDS_MEMBER\nCALL ALLOC_ISPFILE_PDS\nCALL GET_PANEL_VOLUMES\nCALL BUILD_RESTART_JOB\nCALL WRITE_PDS_MEMBER\nSMEMB = WORD(SERVER.LAN,2)\nSUBMEMB = SMEMB||JS\nSUBPDS = TSOID||'.DIALOG.ISPFILE'\nCALL SUBMIT_RESTART_JOB\nCALL DELETE_ISPFILE_PDS\nEXIT 0\n\n/*     S U B R O U T I N E S   S E C T I O N     */\n/*     */\nGET_RESTART_PARMS:\nADDRESS TSO\nBLDJOB = 'YES'\n\"ALLOC DA('\"NWPDS\"(\"RSPARM\")') FILE(NWDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('NWPDS'('RSPARM'). ***'\n   SAY '*** NWBACKUP EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\n\"EXECIO * DISKR NWDD (FINIS STEM VOLR.\"\nSRC = RC\n\"FREE FILE(NWDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** EXECIO READ ERROR: ('NWPDS'('RSPARM'). ***'\n   SAY '*** NWBACKUP EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nSERVOL = WORD(VOLR.1,1)\nBUTYPE = WORD(VOLR.1,3)\nIF SERVOL = 'ALL' THEN BLDJOB = 'NO'\nRETURN\n\n/*     */\nBUILD_RESTART_VOLUME_MEMBER:\nADDRESS TSO\n\"DELSTACK\"\nOUTMEMB = SERVER||'VOLS'\nOUTPDS = PARMLIB\nVOLPARMS = SERVER||'FVOLS'\n\"ALLOC DA('\"TEXTLIB\"(\"VOLPARMS\")') FILE(NWDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('TEXTLIB'('VOLPARMS'). ***'\n   SAY '*** NWBACKUP EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\n\"EXECIO * DISKR NWDD (FINIS STEM VOLP.\"\nSRC = RC\n\"FREE FILE(NWDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** EXECIO READ ERROR: ('TEXTLIB'('VOLPARMS'). ***'\n   SAY '*** NWBACKUP EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nDO I = 1 TO VOLR.0\n   SERVOL = WORD(VOLR.I,1)\n   DO V = 1 TO VOLP.0\n      UPPER VOLP.V\n      PVOL = WORD(VOLP.V,1)\n      IF PVOL = SERVOL THEN QUEUE VOLP.V\n   END\nEND\nRETURN\n\n/*     */\nBUILD_RESTART_CONFIG_MEMBER:\nADDRESS TSO\n\"DELSTACK\"\nOUTMEMB = SERVER||'CONFG'\nOUTPDS = PARMLIB\nVOLMEMB = SERVER||'VOLS'\nCFM = SYSDSN(\"'\"PARMLIB\"(\"OUTMEMB\")'\")\nIF CFM = 'OK' THEN RETURN\n\"ALLOC DA('\"TEXTLIB\"(\"CONFIG\")') FILE(NWDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('TEXTLIB'('CONFIG'). ***'\n   SAY '*** NWBACKUP EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\n\"EXECIO * DISKR NWDD (FINIS STEM PARM.\"\nSRC = RC\n\"FREE FILE(NWDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** EXECIO READ ERROR: ('TEXTLIB'('CONFIG'). ***'\n   SAY '*** NWBACKUP EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nDO I = 1 TO PARM.0\n   CHG = POS('VOLUMES',PARM.I)\n   IF CHG \u00ac= 0 THEN DO\n      PARM.I = \"         VOLUMES      '\"PARMLIB\"(\"VOLMEMB\")'\"\n   END\n   QUEUE PARM.I\nEND\nRETURN\n\n/*     */\nBUILD_RESTART_JOB:\n\"DELSTACK\"\nJ = 24\nSRVCONFG = SERVER||'CONFG'\nSMEMB = WORD(SERVER.LAN,2)\nJN = SMEMB||JS\nOUTMEMB = JN\nWTR = SUBSTR(JN,2)\nWTRNAME = WTR'00'\nOUTPDS = TSOID||'.DIALOG.ISPFILE'\nSCHPRT = 'PTECH2.NETCA.'SERVER'.SCHPRINT'\nSYSPRT = 'PTECH2.NETCA.'SERVER'.SYSPRINT'\nJCL.1 = \"//\"JN\"  JOB O030OVRHD0000000,'\"SERVER\" LAN BACKUP',NOTIFY=TECH251,\"\nJCL.2 = \"//             CLASS=F,MSGCLASS=Q,MSGLEVEL=(1,1),REGION=6M\"\nJCL.3 = \"//STEP010  EXEC PGM=IKJEFT01,DYNAMNBR=30,\"\nJCL.4 = \"//         PARM='%NWALLOC \"SERVER\" \"BUPARM\"'\"\nJCL.5 = \"//SYSTSPRT DD SYSOUT=*\"\nJCL.6 = \"//SYSPRINT DD SYSOUT=*\"\nJCL.7 = \"//SYSIN DD DUMMY\"\nJCL.8 = \"//SYSLBC DD DSN=SYS1.BRODCAST,DISP=SHR\"\nJCL.9 = \"//SYSUADS DD DSN=SYS1.UADS,DISP=SHR\"\nJCL.10 = \"//SYSPROC DD DSN=SYSS.TECH.COMMON.EXECLIB,DISP=SHR\"\nJCL.11 = \"//SYSTSIN DD DUMMY\"\nJCL.12 = \"/*\"\nJCL.13 = \"//ABEND010 EXEC PGM=ABENDWTO,COND=(0,GE,STEP010)\"\nJCL.14 = \"//* *** STEPLIB DD DSN=SYS1.PROD.BATCH.LOADLIB,DISP=SHR\"\nJCL.15 = \"/*\"\nJCL.16 = \"//STEP020 EXEC PGM=NUACLIEN\"\nJCL.17 = \"//STEPLIB  DD DSN=SYS1.NETUA.V2R10M12.LOADLIB,DISP=SHR\"\nJCL.18 = \"//         DD DSN=SYS1.NETCA.V1R1M1.H213CMT.LOADLIB,DISP=SHR\"\nJCL.19 = \"//SCHPRINT DD DSN=\"SCHPRT\",DISP=(MOD,CATLG,DELETE),\"\nJCL.20 = \"// SPACE=(CYL,(2,0,0)),DCB=(RECFM=FBA,LRECL=133,BLKSIZE=133),\"\nJCL.21 = \"// DATACLAS=LISTING\"\nJCL.22 = \"//SYSPRINT DD DSN=\"SYSPRT\",DISP=(MOD,CATLG,DELETE),\"\nJCL.23 = \"// SPACE=(CYL,(2,0,0)),DCB=(RECFM=FBA,LRECL=133,BLKSIZE=133),\"\nJCL.24 = \"// DATACLAS=LISTING\"\nIF VOLSW = 'RSTPARM' THEN DO\n   DO I = 1 TO VOLR.0\n      JVOL = WORD(VOLR.I,1)\n      DDVOL = 'DDC'||JVOL\n      DDINDX = 'DDI'||JVOL\n      BT = BUTYPE\n      IF I = 1 THEN DO\n         TUNIT = 'UNIT=(SILO,,DEFER)'\n         SAVEDD = DDVOL\n      END\n      IF I > 1 THEN TUNIT = 'UNIT=AFF='SAVEDD\n      REC.1 = \"//\"DDVOL\"  DD DSN=PTAP.NETCA.\"SERVER\".\"JVOL\".\"BT\".CONTAINR(+1),\"\n      REC.2 = \"//         DISP=(NEW,CATLG,DELETE),\"TUNIT\",\"\n      REC.3 = \"//         VOLUME=(,,,99),LABEL=(1,SL),\"\n      REC.4 = \"//   DCB=(MODEL.DSCB,RECFM=U,LRECL=0,BLKSIZE=32760,DSORG=PS)\"\n      REC.5 = \"//\"DDINDX\" DD DSN=PTECH2.NETCA.\"SERVER\".\"JVOL\".\"BT\".INDEX(+1),\"\n      REC.6 = \"//            DISP=(NEW,CATLG,DELETE),\"\n      REC.7 = \"//  DCB=(BLKSIZE=27998,LRECL=27994,RECFM=VB,DSORG=PS),\"\n      REC.8 = \"//  DATACLAS=DATAPS,MGMTCLAS=STANDARD,STORCLAS=SCSTNRDG,\"\n      REC.9 = \"//  SPACE=(27998,(50,10),RLSE)\"\n      DO E = 1 TO 9\n         J = J + 1\n         JCL.J = REC.E\n      END\n   END\nEND\nIF VOLSW = 'PANEL' THEN DO\n   DO I = 1 TO VOLP.0\n      JVOL = WORD(VOLP.I,1)\n      DDVOL = 'DDC'||JVOL\n      DDINDX = 'DDI'||JVOL\n      BT = BUTYPE\n      IF I = 1 THEN DO\n         TUNIT = 'UNIT=(SILO,,DEFER)'\n         SAVEDD = DDVOL\n      END\n      IF I > 1 THEN TUNIT = 'UNIT=AFF='SAVEDD\n      REC.1 = \"//\"DDVOL\"  DD DSN=PTAP.NETCA.\"SERVER\".\"JVOL\".\"BT\".CONTAINR(+1),\"\n      REC.2 = \"//         DISP=(NEW,CATLG,DELETE),\"TUNIT\",\"\n      REC.3 = \"//         VOLUME=(,,,99),LABEL=(1,SL),\"\n      REC.4 = \"//   DCB=(MODEL.DSCB,RECFM=U,LRECL=0,BLKSIZE=32760,DSORG=PS)\"\n      REC.5 = \"//\"DDINDX\" DD DSN=PTECH2.NETCA.\"SERVER\".\"JVOL\".\"BT\".INDEX(+1),\"\n      REC.6 = \"//            DISP=(NEW,CATLG,DELETE),\"\n      REC.7 = \"//  DCB=(BLKSIZE=27998,LRECL=27994,RECFM=VB,DSORG=PS),\"\n      REC.8 = \"//  DATACLAS=DATAPS,MGMTCLAS=STANDARD,STORCLAS=SCSTNRDG,\"\n      REC.9 = \"//  SPACE=(27998,(50,10),RLSE)\"\n      DO E = 1 TO 9\n         J = J + 1\n         JCL.J = REC.E\n      END\n   END\nEND\nJCLCNT = J\nDO J = 1 TO JCLCNT\n   QUEUE JCL.J\nEND\nR = 0\nRCDCNT = 35\nRCD.1 = \"//NUACACON DD DSN=\"PARMLIB\"(\"SRVCONFG\"),DISP=SHR\"\nRCD.2 = \"//NUACATXT DD DSN=\"CTEXTLIB\",DISP=SHR\"\nRCD.3 = \"//PARAMS DD *\"\nRCD.4 = \"-HOST \"SERVER\" -OUTPUT 'PTECH2.NETCA.\"SERVER\".SCRIPT'\"\nRCD.5 = \"    DD:NUACACON -CHECK\"\nRCD.6 = \"//SYSIN DD *\"\nRCD.7 = \"SET INPUT VERIFY ON\"\nRCD.8 = \"INPUT DD:NUACATXT(BASIC) 'PTECH2.NETCA.\"SERVER\".SCRIPT'\"\nRCD.9 = \"/*\"\nRCD.10 = \"//STEP030 EXEC PGM=IKJEFT01,DYNAMNBR=30,\"\nRCD.11 = \"// PARM='%NWABEND \"SERVER\" \"BUTYPE\" RESTART',\"\nRCD.12 = \"// COND=(4,GE,STEP020)\"\nRCD.13 = \"//SYSTSPRT DD SYSOUT=*\"\nRCD.14 = \"//SYSPRINT DD SYSOUT=*\"\nRCD.15 = \"//SYSIN DD DUMMY\"\nRCD.16 = \"//SYSLBC DD DSN=SYS1.BRODCAST,DISP=SHR\"\nRCD.17 = \"//SYSUADS DD DSN=SYS1.UADS,DISP=SHR\"\nRCD.18 = \"//SYSPROC DD DSN=SYSS.TECH.COMMON.EXECLIB,DISP=SHR\"\nRCD.19 = \"//SYSTSIN DD DUMMY\"\nRCD.20 = \"/*\"\nRCD.21 = \"//STEP040  EXEC CATRPTS,COND=((4,GE,STEP020),(1,NE,STEP030))\"\nRCD.22 = \"//SYSIN    DD DSN=\"PARMLIB\"(\"TLMSMEMB\"),DISP=SHR\"\nRCD.23 = \"/*\"\nRCD.24 = \"//ABEND050 EXEC WTO,COND=(4,GE,STEP020)\"\nRCD.25 = \"//SYSIN DD DSN=\"MSGLIB\"(\"SERVER\"),DISP=SHR\"\nRCD.26 = \"/*\"\nRCD.27 = \"//STEP060 EXEC PGM=IEBGENER\"\nRCD.28 = \"//SYSUT1 DD DSN=\"SYSPRT\",DISP=SHR\"\nRCD.29 = \"//SYSUT2 DD SYSOUT=(V,\"WTRNAME\"),DCB=BLKSIZE=133\"\nRCD.30 = \"//SYSPRINT DD DUMMY\"\nRCD.31 = \"//SYSIN DD DUMMY\"\nRCD.32 =  \"/*\"\nRCD.33 = \"//*          ABEND STEP FOR RETURN CODE GE 4\"\nRCD.34 = \"//ABEND070 EXEC PGM=ABENDWTO,COND=(4,GE,STEP020)\"\nRCD.35 = \"//\"\nDO RCDCNT\n   R = R + 1\n   QUEUE RCD.R\nEND\nRETURN\n\n/*     */\nREAD_SERVER_VOLUMES_PARMS:\nVOLPARMS = SERVER||'FVOLS'\n\"ALLOC DA('\"TEXTLIB\"(\"VOLPARMS\")') FILE(NWDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('TEXTLIB'('VOLPARMS'). ***'\n   SAY '*** NWBACKUP EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\n\"EXECIO * DISKR NWDD (FINIS STEM VOLB.\"\nSRC = RC\n\"FREE FILE(NWDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** EXECIO READ ERROR: ('TEXTLIB'('VOLPARMS'). ***'\n   SAY '*** NWBACKUP EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nV = 0\nVOL1 = '*****'\nVOL2 = '*****'\nVOL3 = '*****'\nVOL4 = '*****'\nVOL5 = '*****'\nVOL6 = '*****'\nVOL7 = '*****'\nVOL8 = '*****'\nDO I = 1 TO VOLB.0\n   UPPER VOLB.I\n   SVOL = POS(BUPARM,VOLB.I)\n   IF SVOL = 0 THEN ITERATE\n   V = V + 1\n   SERVOL = WORD(VOLB.I,1)\n   IF V = 1 THEN VOL1 = LEFT(SERVOL,5,'*')\n   IF V = 2 THEN VOL2 = LEFT(SERVOL,5,'*')\n   IF V = 3 THEN VOL3 = LEFT(SERVOL,5,'*')\n   IF V = 4 THEN VOL4 = LEFT(SERVOL,5,'*')\n   IF V = 5 THEN VOL5 = LEFT(SERVOL,5,'*')\n   IF V = 6 THEN VOL6 = LEFT(SERVOL,5,'*')\n   IF V = 7 THEN VOL7 = LEFT(SERVOL,5,'*')\n   IF V = 8 THEN VOL8 = LEFT(SERVOL,5,'*')\nEND\nRETURN\n\n/*     */\nDISPLAY_VOLUME_PANEL:\nADDRESS ISPEXEC \"DISPLAY PANEL(NWVOLPNL)\"\nSRC = RC\nIF SRC = 8 THEN EXIT 0\nIF SRC > 8 THEN DO\n   SAY '*** ERROR INVOKING ISPF DIALOG PANEL ( NWVOLPNL ). ***'\n   SAY '*** NWBACKUP EXEC TASK CANCELLED - RC = 'SRC'. ***'\n   EXIT SRC\nEND\nRETURN\n\n/*     */\nBUILD_PANEL_RESTART_VOLUME_MEMBER:\nADDRESS TSO\n\"DELSTACK\"\nVOLSW = 'PANEL'\nOUTMEMB = SERVER||'VOLS'\nOUTPDS = PARMLIB\nVOLPARMS = SERVER||'FVOLS'\n\"ALLOC DA('\"TEXTLIB\"(\"VOLPARMS\")') FILE(NWDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('TEXTLIB'('VOLPARMS'). ***'\n   SAY '*** NWBACKUP EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\n\"EXECIO * DISKR NWDD (FINIS STEM VOLP.\"\nSRC = RC\n\"FREE FILE(NWDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** EXECIO READ ERROR: ('TEXTLIB'('VOLPARMS'). ***'\n   SAY '*** NWBACKUP EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nDO I = 1 TO 8\n   SELVOL = VALUE('VBU'I)\n   IF SELVOL = '' THEN ITERATE\n   BUVOL = VALUE('VOL'I)\n   IF BUVOL = '' THEN ITERATE\n   SVR = POS('*',BUVOL)\n   SVRVOL = BUVOL\n   IF SVR \u00ac= 0 THEN DO\n      SVR = SVR - 1\n      SVRVOL = SUBSTR(BUVOL,1,SVR)\n   END\n   DO V = 1 TO VOLP.0\n      UPPER VOLP.V\n      SVOL = POS(BUPARM,VOLP.V)\n      IF SVOL = 0 THEN ITERATE\n      PVOL = WORD(VOLP.V,1)\n      IF PVOL = SVRVOL THEN QUEUE VOLP.V\n   END\nEND\nRCNT = QUEUED()\nRETURN\n\n/*     */\nGET_PANEL_VOLUMES:\nVOLMEMB = SERVER||'VOLS'\n\"ALLOC DA('\"PARMLIB\"(\"VOLMEMB\")') FILE(NWDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('PARMLIB'('VOLMEMB'). ***'\n   SAY '*** NWBACKUP EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\n\"EXECIO * DISKR NWDD (FINIS STEM VOLP.\"\nSRC = RC\n\"FREE FILE(NWDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** EXECIO READ ERROR: ('PARMLIB'('VOLMEMB'). ***'\n   SAY '*** NWBACKUP EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nRETURN\n\n/*     */\nALLOC_ISPFILE_PDS:\nADDRESS TSO\nUCNTL = SYSDSN(DIALOG.ISPFILE)\nIF UCNTL = 'DATASET NOT FOUND' THEN DO\n\"ALLOC DA(DIALOG.ISPFILE) LIKE(USER.CNTLLIB) NEW SPACE(1,0) DIR(5) CYLINDERS\"\n   SRC = RC\n   IF SRC \u00ac= 0 THEN DO\n   SAY '*** ALLOCATE ERROR: ERROR ALLOCATING DATASET (DIALOG.ISPFILE). ***'\n   SAY '*** NWBACKUP EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\n   END\nEND\nRETURN\n\n/*     */\nWRITE_PDS_MEMBER:\n\"ALLOC DA('\"OUTPDS\"(\"OUTMEMB\")') FILE(NWDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('OUTPDS'('OUTMEMB'). ***'\n   SAY '*** NWBACKUP EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nNUMRCDS = QUEUED()\n\"EXECIO\" NUMRCDS \"DISKW NWDD (FINIS\"\nSRC = RC\n\"FREE FILE(NWDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** WRITE ERROR: ERROR WRITING 'OUTPDS'('OUTMEMB'). ***'\n   SAY '*** NWBACKUP EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nRETURN\n\n/*     */\nSUBMIT_RESTART_JOB:\nADDRESS TSO\n\"SUBMIT '\"SUBPDS\"(\"SUBMEMB\")'\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** SUBMIT ERROR: MEMBER ( 'SUBPDS'('SUBMEMB'). ***'\n   SAY '*** NWBACKUP EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nIF NWDSN = 'OK' THEN DO\n   \"ALLOC DA('\"NWPDS\"(\"RSPARM\")') FILE(NWDD) SHR\"\n   \"DELETE ('\"NWPDS\"(\"RSPARM\")') FILE(NWDD)\"\n   \"FREE FILE(NWDD)\"\nEND\nRETURN\n\n/*     */\nDELETE_ISPFILE_PDS:\nADDRESS TSO\n\"DELETE  (DIALOG.ISPFILE)   NONVSAM SCRATCH PURGE\"\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "NWREALTY": {"ttr": 16649, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x11\\x00\\x00\\x00\\x95 \\x9f\\x00\\x95#O\\t9\\x00\\xf5\\x02M\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf3@@@'", "ispf": {"version": "01.17", "flags": 0, "createdate": "1995-07-28T00:00:00", "modifydate": "1995-08-22T09:39:00", "lines": 245, "newlines": 589, "modlines": 0, "user": "TECH103"}, "text": "/*  REXX EXEC : ( NWREALTY ).\n    FUNCTION  : LAN SERVER RESTORE TO FACILITATE THE REALITY CS1\n                VOL(REA/VOL2) RESTORE TO ALTERNATE PROD_SUPPORT VOLUME.\n                BUILDS AND WRITES THE JOB JCL AND INPUT SCRIPT TO\n                PERFORM THE LAN SERVER RESTORE AND SUBMITS THE JOB\n                FOR EXECUTION ON THE SYSA SYSTEM CLASS=J.\n    INPUT     : ( PTECH2.NETCA.CS1.REA.H )\n                ( PTECH2.NETCA.CS1.REA.SYSPRINT ).\n    OUTPUT    : ( PTECH3.NETCA.RESTORE.SCRIPT.CNTLLIB(&MEMBER).\n                                                                    */\nTRACE O\n/*      */\nHOUSE_KEEPING:\nADDRESS TSO\nSERVER = 'CS1'                   /* LAN SERVER name */\nRESTVOL = 'VOL2'                 /* LAN SERVER input restore volume */\nLANVOL = 'REA'                   /* LAN SERVER alias restore volume */\nALTVOL = 'PROD_SUPPORT:'         /* LAN SERVER -ALT target volume */\nDRCTPATH = '/REALITY/MMDATA/'    /* target directory path */\nRESTFN = '*'                     /* directory path data file specs */\nDATAKEY = 'VOLUME 'LANVOL' BACKUP SUCCESSFUL,'\nNWPRINT = 'PTECH2.NETCA.'SERVER'.'LANVOL'.SYSPRINT'\nCNTLLIB = 'PTECH3.NETCA.RESTORE.SCRIPT.CNTLLIB'\nJOURLIB = 'PTECH3.NETCA.RESTORE.JOURNAL'\nTEXTLIB = 'SYSS.NETCA.CONTROL.TEXTLIB'\nLANID = 'TECH399'\nTSOID = 'TECH251'\nJOBNAME = 'PTTS41R'\nCURTIME = TIME()\nHH = SUBSTR(CURTIME,1,2)\nMM = SUBSTR(CURTIME,4,2)\nSS = SUBSTR(CURTIME,7,2)\nTIMEP = HH||MM||SS\nJSUFFIX = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\nJMEMB = 'J'TIMEP                  /* JOURNAL PARMS MEMBER */\nRMEMB = 'R'TIMEP                  /* RESTORE JOB JCL MEMBER */\nOUTPDS = CNTLLIB\nX = MSG(\"OFF\")\n\"FREE FILE(NWDD)\"\n/*      M A I N   R O U T I N E   S E C T I O N     */\n/*     */\nMAIN_ROUTINE:\nCALL GET_INPUT_CONTAINER_DATASET_NAME\nCALL CHECK_CONTAINER_DATASET_CATALOG\nCALL BUILD_JOBNAME_PARM\nCALL BUILD_TCPIP_RESTORE_JOB\nOUTMEMB = RMEMB\nCALL WRITE_PDS_MEMBER\nCALL BUILD_JOURNAL_PARMS\nOUTMEMB = JMEMB\nCALL WRITE_PDS_MEMBER\nCALL SUBMIT_RESTORE_JOB\nEXIT 0\n/*\n       S U B R O U T I N E S   S E C T I O N     */\n/*     */\nGET_INPUT_CONTAINER_DATASET_NAME:\nDSW = 'NO'\nNWDSN = SYSDSN(\"'\"NWPRINT\"'\")\nIF NWDSN = 'DATASET NOT FOUND' THEN DO\n   SAY '***********************************************************************'\n   SAY '*                                                                     *'\n   SAY '* *** DATASET ERROR: DATASET NOT FOUND FOR ('NWPRINT').               *'\n   SAY '* *** UNABLE TO DETERMINE THE INPUT CONTAINER DATASET FOR RESTORE.    *'\n   SAY '* *** NWREALTY EXEC SUBTASK CANCELLED - RETURN CODE: (028).           *'\n   SAY '*                                                                     *'\n   SAY '***********************************************************************'\n   EXIT 028\nEND\n\"ALLOC DA('\"NWPRINT\"') FILE(NWDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '***********************************************************************'\n   SAY '*                                                                     *'\n   SAY '* *** DATASET ALLOCATE ERROR: ('NWPRINT').                            *'\n   SAY '* *** UNABLE TO DETERMINE THE INPUT CONTAINER DATASET FOR RESTORE.    *'\n   SAY '* *** NWREALTY EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC').         *'\n   SAY '*                                                                     *'\n   SAY '***********************************************************************'\n   EXIT SRC\nEND\n\"EXECIO * DISKR NWDD (STEM DATA. FINIS\"\nSRC = RC\n\"FREE FILE(NWDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '***********************************************************************'\n   SAY '*                                                                     *'\n   SAY '* *** EXECIO READ ERROR: ('NWPRINT').                                 *'\n   SAY '* *** UNABLE TO DETERMINE THE INPUT CONTAINER DATASET FOR RESTORE.    *'\n   SAY '* *** NWREALTY EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC').         *'\n   SAY '*                                                                     *'\n   SAY '***********************************************************************'\n   EXIT SRC\nEND\nDO I = 1 TO DATA.0\n   UPPER DATA.I\n   DKEY = POS(DATAKEY,DATA.I)\n   IF DKEY \u00ac= 0 THEN DO\n      DSW = 'YES'\n      N = I + 1\n      PRINT_DATA = STRIP(DATA.N)\n      LEAVE\n   END\nEND\nIF DSW = 'NO' THEN RETURN\nCONTAINER_DSN = WORD(PRINT_DATA,3)\nRESTDSN = STRIP(CONTAINER_DSN,\"B\",\"'\")\nRETURN\n/*     */\nCHECK_CONTAINER_DATASET_CATALOG:\nX = OUTTRAP(\"LSTCAT.\",\"*\",\"CONCAT\")\n\"LISTCAT ENT('\"RESTDSN\"') VOL\"\nIF SRC \u00ac= 0  THEN DO\n   SAY '***********************************************************************'\n   SAY '*                                                                     *'\n   SAY '* *** DATASET ERROR: DATASET NOT FOUND FOR ('RESTDSN').               *'\n   SAY '* *** THE INPUT TAPE CONTAINER DATASET WAS NOT FOUND IN A CATALOG.    *'\n   SAY '* *** NWREALTY EXEC SUBTASK CANCELLED - RETURN CODE: (028).           *'\n   SAY '*                                                                     *'\n   SAY '***********************************************************************'\n   EXIT 028\nEND\nRETURN\n/*     */\nBUILD_JOBNAME_PARM:\nRETURN\n/* ***     n o o p     *** */\nJN1 = 'NWR'\nJN2 = SUBSTR(TSOID,5,3)\nDO N = 1 TO 26\n   JN3 = SUBSTR(JSUFFIX,N,1)\n   JOBNAME = JN1||JN2||JN3\n   JOB = SYSDSN(\"'\"CNTLLIB\"(\"JOBNAME\")'\")\n   IF JOB = 'MEMBER NOT FOUND' THEN LEAVE\nEND\nJN = JOBNAME\nRETURN\n/*     */\nBUILD_TCPIP_RESTORE_JOB:\nADDRESS TSO\n\"DELSTACK\"\nJN = JOBNAME\nLANPW = 'BCKLAN'\nRESTDSN = \"'\"||RESTDSN||\"'\"\nRESTPRM1 = DRCTPATH||RESTFN '-PDT ON -SUB ON -REP ON -'\nRESTPRM2 = '-ALT 'ALTVOL||DRCTPATH'\"'\nRCD.1 = \"SET INPUT VERIFY ON\"\nRCD.2 = \"ON ERROR EXIT ERROR\"\nRCD.3 = \"CONNECT \"SERVER\" \"LANID\" \"LANPW\nRCD.4 = \"SEND -MODE RESTORE \"RESTDSN\" -\"\nRCD.5 = '    \"!UARESTORE 'RESTPRM1\nRCD.6 = '    '||RESTPRM2\nJCL.1 = \"//\"JN\"  JOB 5304010530000000,'\"SERVER\" REA RESTORE',NOTIFY=\"TSOID\",\"\nJCL.2 = \"//             CLASS=F,MSGCLASS=G,MSGLEVEL=(1,1),REGION=7M\"\nJCL.3 = \"//RESTORE  EXEC PGM=NUACLIEN\"\nJCL.4 = \"//STEPLIB  DD DSN=SYS1.NETUA.V2R10M12.LOADLIB,DISP=SHR\"\nJCL.5 = \"//         DD DSN=SYS1.NETCA.V1R1M1.H213CMT.LOADLIB,DISP=SHR\"\nJCL.6 = \"//SYSPRINT DD SYSOUT=*\"\nJCL.7 = \"//SYSIN DD *\"\nJCL.8 = \"EXIT\"\nJCL.9 = \"/*\"\nJCL.10 = \"//WRITELOG EXEC PGM=IKJEFT01,DYNAMNBR=30,\"\nJCL.11 = \"//   PARM='%NWRSTLOG \"JMEMB\"',COND=(0,LT,RESTORE)\"\nJCL.12 = \"//SYSPRINT DD SYSOUT=*\"\nJCL.13 = \"//SYSTSPRT DD SYSOUT=*\"\nJCL.14 = \"//SYSIN    DD DUMMY\"\nJCL.15 = \"//SYSLBC   DD DSN=SYS1.BRODCAST,DISP=SHR\"\nJCL.16 = \"//SYSUADS  DD DSN=SYS1.UADS,DISP=SHR\"\nJCL.17 = \"//SYSPROC  DD DSN=SYSS.TECH.COMMON.EXECLIB,DISP=SHR\"\nJCL.18 = \"//SYSTSIN  DD DUMMY\"\nJCL.19 = \"/*\"\nJCL.20 = \"//DELETE   EXEC PGM=IDCAMS,COND=(0,LT,RESTORE)\"\nJCL.21 = \"//CNTLDD   DD DSN=\"CNTLLIB\",DISP=SHR\"\nJCL.22 = \"//SYSPRINT DD SYSOUT=*\"\nJCL.23 = \"//SYSIN    DD *\"\nJCL.24 = \"  DELETE   \"CNTLLIB\"(\"JMEMB\")  FILE(CNTLDD)\"\nJCL.25 = \"  DELETE   \"CNTLLIB\"(\"RMEMB\")  FILE(CNTLDD)\"\nJCL.26 = \"/*\"\nJCL.27 = \"//ABEND     EXEC PGM=ABENDWTO,COND=(4,GE,RESTORE)\"\nJCL.28 = \"//\"\nDO J = 1 TO 7\n   QUEUE JCL.J\nEND\nDO R = 1 TO 6\n   QUEUE RCD.R\nEND\nDO J = 8 TO 28\n   QUEUE JCL.J\nEND\nRETURN\n/*     */\nBUILD_JOURNAL_PARMS:\n\"DELSTACK\"\nQUEUE SERVER\nQUEUE RESTVOL\nQUEUE RESTDSN\nQUEUE DRCTPATH\nQUEUE RESTFN\nRETURN\n/*     */\nWRITE_PDS_MEMBER:\nADDRESS TSO\n\"ALLOC DA('\"OUTPDS\"(\"OUTMEMB\")') FILE(NWDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '***********************************************************************'\n   SAY '*                                                                     *'\n   SAY '* *** DATASET ALLOCATE ERROR: ('OUTPDS'('OUTMEMB').                   *'\n   SAY '* *** UNABLE TO WRITE REALITY PROD_SUPPORT RESTORE JOB.               *'\n   SAY '* *** NWREALTY EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC').         *'\n   SAY '*                                                                     *'\n   SAY '***********************************************************************'\n   EXIT SRC\nEND\nNUMRCDS = QUEUED()\n\"EXECIO\" NUMRCDS \"DISKW NWDD (FINIS\"\nSRC = RC\n\"FREE FILE(NWDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '***********************************************************************'\n   SAY '*                                                                     *'\n   SAY '* *** DATASET WRITE ERROR: ('OUTPDS'('OUTMEMB').                      *'\n   SAY '* *** UNABLE TO WRITE REALITY PROD_SUPPORT RESTORE JOB.               *'\n   SAY '* *** NWREALTY EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC').         *'\n   SAY '*                                                                     *'\n   SAY '***********************************************************************'\n   EXIT SRC\nEND\nRETURN\n/*     */\nSUBMIT_RESTORE_JOB:\nADDRESS TSO\n\"SUBMIT ('\"CNTLLIB\"(\"RMEMB\")')\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '***********************************************************************'\n   SAY '*                                                                     *'\n   SAY '* *** JOB SUBMIT ERROR: ('CNTLLIB'('RMEMB').                          *'\n   SAY '* *** UNABLE TO SUBMIT THE REALITY PROD_SUPPORT RESTORE JOB.          *'\n   SAY '* *** NWREALTY EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC').         *'\n   SAY '*                                                                     *'\n   SAY '***********************************************************************'\n   EXIT SRC\nEND\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "NWREST": {"ttr": 16900, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\"\\x7f\\x00\\x94\"\\x7f\\x15V\\x02\\x84\\x02\\x84\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf7@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-08-15T00:00:00", "modifydate": "1994-08-15T15:56:00", "lines": 644, "newlines": 644, "modlines": 0, "user": "TECH107"}, "text": "/*  REXX EXEC : ( NWRESTOR ).\n    FUNCTION  : LAN SERVER BACKUP PANEL INTERFACE TO FACILITATE FILE\n                RESTORES FOR A SERVER VOLUME FROM THE MVS HOST CENTRAL\n                ARCHIVE BACKUP.\n                BUILDS AND WRITES THE JOB JCL AND INPUT SCRIPT TO\n                PERFORM THE LAN SERVER RESTORE AND SUBMITS THE JOB\n                FOR EXECUTION ON THE SYSB SYSTEM CLASS=S.\n    INPUT     : ( PTECH2.NETCA.&&SERVER.&&VOLUME.H ).\n                ( SYSS.NETCA.LAN.MVSNW.UA ).\n    OUTPUT    : ( PTECH3.NETCA.RESTORE.SCRIPT.PARMLIB(&MEMBER).\n                ( PTECH3.NETCA.RESTORE.SCRIPT.CNTLLIB(&MEMBER).\n    1/26/94   - ADDED REALITY AND ASP\n                                                                    */\nTRACE O\n/*      */\nHOUSE_KEEPING:\nADDRESS TSO\nSERVER.1 = 'COM'\nSERVER.2 = 'MAGIC'\nSERVER.3 = 'DB1'\nSERVER.4 = 'MIS'\nSERVER.5 = 'CS1'\nSERVER.6 = 'POS'\nSERVER.7 = 'CSI'\nSERVER.8 = 'SYS'\nSERVER.9 = 'CS2'\nSERVER.10 = 'CS3'\nSERVER.11 = 'FIN'\nSERVER.12 = 'PAD'\nSERVER.13 = 'REA'\nSERVER.14 = 'ASP'\nSERVER.15 = 'CS4'\nSERVER.16 = 'DB1'\nSERVER.17 = 'C4A'\nSERVER.18 = 'C4B'\nSERVER.19 = 'CS5'\nSERVER.20 = 'C5A'\nSERVER.21 = 'C6A'\nSERVER.22 = 'C6B'\nRESTYPE.1 = 'FILE'\nRESTYPE.2 = 'DRCT'\nRESTYPE.3 = 'VOL'\nRESTMOD.1 = 'INCR'\nRESTMOD.2 = 'FULL'\nPARMLIB = 'SYSS.TECH.COMMON.PARMLIB'\nSCRIPTLIB = 'PTECH3.NETCA.RESTORE.SCRIPT.PARMLIB'\nCNTLLIB = 'PTECH3.NETCA.RESTORE.SCRIPT.CNTLLIB'\nTEXTLIB = 'SYSS.NETCA.CONTROL.TEXTLIB'\nTSOID = SYSVAR(SYSUID)\nCURTIME = TIME()\nHH = SUBSTR(CURTIME,1,2)\nMM = SUBSTR(CURTIME,4,2)\nSS = SUBSTR(CURTIME,7,2)\nTIMEP = HH||MM||SS\nJSUFFIX = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\nX = MSG(\"OFF\")\n\"FREE FILE(NWDD)\"\nADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\n\n/*     */\nDISPLAY_SERVER_PANEL:\nAUTHPARM = 'NWHPDESK'\nNWMSG = 'NWLAN002'\nDO FOREVER\n   ADDRESS ISPEXEC\n   \"DISPLAY PANEL(NWRSTPN1)\"\n   SRC = RC\n   IF SRC = 8 THEN EXIT 0\n   IF SRC > 8 THEN DO\n      SAY '*** ERROR INVOKING ISPF DIALOG PANEL ( NWRSTPN1 ). ***'\n      SAY '*** NWRESTOR EXEC TASK CANCELLED - RC = 'SRC'. ***'\n      EXIT SRC\n   END\n   IF RESTYPE.RT = 'VOL' THEN DO\n      AUTHPARM = 'NWLANGRP'\n      NWMSG = 'NWLAN003'\n   END\n   CALL CHECK_USER_AUTHORIZATION\n   IF AUTHSW = 'YES' THEN LEAVE\n   \"SETMSG MSG(\"NWMSG\")\"\nEND\nSERVER = SERVER.LAN\nIF SERVER = 'MAGIC' THEN DO\n   VOLKEY = 'MAGIC SYS:'\n   RESTVOL = 'SYS:'\n/* RESTDPN = 'MAGIC' */\n   VOLUME = 'MAGIC'\n   SERVER = 'CS3'\n   RM = 2\n   SIGNAL BUILD_CONTAINER_DATASET_PARMS\nEND\nIF SERVER = 'POS' THEN DO\n   VOLKEY = 'POS VOL1:'\n   RESTVOL = 'VOL1:'\n/* RESTDPN = 'POS' */\n   VOLUME = 'POS'\n   SERVER = 'CS3'\n   RM = 2\n   SIGNAL BUILD_CONTAINER_DATASET_PARMS\nEND\nIF SERVER = 'REA' THEN DO\n   VOLKEY = 'REA VOL2:'\n   RESTVOL = 'VOL2:'\n   RESTDPN = 'REA'\n   VOLUME = 'REA'\n   SERVER = 'CS1'\n   RM = 2\n   SIGNAL BUILD_CONTAINER_DATASET_PARMS\nEND\nIF SERVER = 'ASP' THEN DO\n   VOLKEY = 'ASP VOL1:'\n   RESTVOL = 'VOL1:'\n   RESTDPN = 'ASP'\n   VOLUME = 'ASP'\n   SERVER = 'CSI'\n   RM = 2\n   SIGNAL BUILD_CONTAINER_DATASET_PARMS\nEND\n\n/*     */\nDISPLAY_VOLUME_PANEL:\nADDRESS TSO\n\"FREE FILE(NWDD)\"\n\"FREE FILE(ISPFILE)\"\nCALL READ_SERVER_VOLUMES_PARMS\nADDRESS ISPEXEC \"DISPLAY PANEL(NWRSTPN2)\"\nSRC = RC\nIF SRC = 8 THEN EXIT 0\nIF SRC > 8 THEN DO\n   SAY '*** ERROR INVOKING ISPF DIALOG PANEL ( NWRSTPN2 ). ***'\n   SAY '*** NWRESTOR EXEC TASK CANCELLED - RC = 'SRC'. ***'\n   EXIT SRC\nEND\nCALL GET_SELECTED_SERVER_VOLUME\nVOLKEY = VOLUME RESTVOL\n\n/*     */\nBUILD_CONTAINER_DATASET_PARMS:\nCALL GET_HISTORY_CONTAINER_DATASETS\nIF DSN = 0 THEN DO\n   SAY '*** HISTORY DATASET ERROR: NO VALID CONTAINER DATASET NAMES FOUND. ***'\n   SAY '*** DSN ('NWHSTLIB') DOES NOT CONTAIN A BACKUP STATUS OF (SSSS). ***'\n   SAY '*** NWRESTOR EXEC TASK CANCELLED - RC = (028). ***'\n   EXIT 028\nEND\nGDGCNT = 18\nNWPANEL = 'NWRSTPN3'\nIF RESTMOD.RM = 'FULL' & SERVER \u00ac= 'PAD' THEN DO\n   GDGCNT = 6\n   NWPANEL = 'NWRSTPN4'\nEND\nCALL BUILD_PANEL_DATASET_PARMS\n\n/*     */\nDISPLAY_DATASET_LIST_PANEL:\nDO FOREVER\n   ADDRESS ISPEXEC\n   \"DISPLAY PANEL(\"NWPANEL\")\"\n   SRC = RC\n   IF SRC = 8 THEN EXIT 0\n   IF SRC > 8 THEN DO\n      SAY '*** ERROR INVOKING ISPF DIALOG PANEL ( 'NWPANEL' ). ***'\n      SAY '*** NWRESTOR EXEC TASK CANCELLED - RC = 'SRC'. ***'\n      EXIT SRC\n   END\n   CALL GET_PANEL_INPUT_DATASET\n   IF DSNSW = 'YES' THEN LEAVE\n   \"SETMSG MSG(NWLAN004)\"\nEND\nIF RESTYPE.RT = 'DRCT' & RESTFN = '' THEN RESTFN = '*'\nIF RESTYPE.RT = 'VOL' THEN DO\n   RESTDPN = '*'\n   RESTFN = '*'\nEND\n\n/*     */\nDISPLAY_INPUT_PARMS_CONFIRMATION_PANEL:\nCALL LISTCAT_CONTAINER_DATASET\nCALL BUILD_PANEL_TAPE_VOLSERS\nADDRESS ISPEXEC\n\"DISPLAY PANEL(NWRSTPN5)\"\nSRC = RC\nIF SRC = 8 THEN EXIT 0\nIF SRC > 8 THEN DO\n   SAY '*** ERROR INVOKING ISPF DIALOG PANEL ( NWRSTPN5 ). ***'\n   SAY '*** NWRESTOR EXEC TASK CANCELLED - RC = 'SRC'. ***'\n   EXIT SRC\nEND\n\n/*     */\nCREATE_RESTORE_JOB_PARMS:\nADDRESS TSO\nSUBPDS = CNTLLIB\nJMEMB = 'J'TIMEP                  /* JOURNAL PARMS MEMBER */\nRMEMB = 'R'TIMEP                  /* RESTORE JOB JCL MEMBER */\nSMEMB = 'S'TIMEP                  /* SCRIPT INPUT MEMBER */\n\"DELSTACK\"\nCALL BUILD_JOBNAME_PARM\nOUTPDS = CNTLLIB\nOUTMEMB = JOBNAME\nQUEUE JOBNAME\nCALL WRITE_PDS_MEMBER\nCALL BUILD_RESTORE_JOB\nOUTMEMB = RMEMB\nCALL WRITE_PDS_MEMBER\n\"DELSTACK\"\nQUEUE SERVER\nQUEUE RESTVOL\nQUEUE RESTDSN\nQUEUE RESTDPN\nQUEUE RESTFN\nOUTMEMB = JMEMB\nCALL WRITE_PDS_MEMBER\nCALL BUILD_RESTORE_PARMS\nOUTMEMB = SMEMB\nOUTPDS = SCRIPTLIB\nCALL WRITE_PDS_MEMBER\nCALL SUBMIT_RESTORE_JOB\nEXIT 0\n\n/*     S U B R O U T I N E S   S E C T I O N     */\n/*     */\nCHECK_USER_AUTHORIZATION:\nADDRESS TSO\nAUTHSW = 'NO'\n\"ALLOC DA('\"PARMLIB\"(\"AUTHPARM\")') FILE(NWDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('PARMLIB'('AUTHPARM'). ***'\n   SAY '*** NWRESTOR EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\n\"EXECIO * DISKR NWDD (FINIS STEM AUTH.\"\nSRC = RC\n\"FREE FILE(NWDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** EXECIO READ ERROR: ('PARMLIB'('AUTHPARM'). ***'\n   SAY '*** NWRESTOR EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nDO I = 1 TO AUTH.0\n   LAU = POS(TSOID,AUTH.I)\n   IF LAU \u00ac= 0 THEN AUTHSW = 'YES'\nEND\nRETURN\n\n/*     */\nREAD_SERVER_VOLUMES_PARMS:\nADDRESS TSO\nVOLCONFG = SERVER'IVOLS'\nIF RESTMOD.RM = 'FULL' THEN VOLCONFG = SERVER'FVOLS'\n\"ALLOC DA('\"TEXTLIB\"(\"VOLCONFG\")') FILE(NWDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('TEXTLIB'('VOLCONFG'). ***'\n   SAY '*** NWRESTOR EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\n\"EXECIO * DISKR NWDD (FINIS STEM VOLP.\"\nSRC = RC\n\"FREE FILE(NWDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** EXECIO READ ERROR: ('TEXTLIB'('VOLCONFG'). ***'\n   SAY '*** NWRESTOR EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nV = 0\nVOL1 = '*****'\nVOL2 = '*****'\nVOL3 = '*****'\nVOL4 = '*****'\nVOL5 = '*****'\nVOL6 = '*****'\nVOL7 = '*****'\nVOL8 = '*****'\nDO I = 1 TO VOLP.0\n   UPPER VOLP.I\n   SVOL = POS('DAILY',VOLP.I)\n   IF SVOL = 0 THEN ITERATE\n   V = V + 1\n   SERVOL = WORD(VOLP.I,2)\n   RSTVOL.V = WORD(VOLP.I,2)\n   IF V = 1 THEN VOL1 = LEFT(SERVOL,5,'*')\n   IF V = 2 THEN VOL2 = LEFT(SERVOL,5,'*')\n   IF V = 3 THEN VOL3 = LEFT(SERVOL,5,'*')\n   IF V = 4 THEN VOL4 = LEFT(SERVOL,5,'*')\n   IF V = 5 THEN VOL5 = LEFT(SERVOL,5,'*')\n   IF V = 6 THEN VOL6 = LEFT(SERVOL,5,'*')\n   IF V = 7 THEN VOL7 = LEFT(SERVOL,5,'*')\n   IF V = 8 THEN VOL8 = LEFT(SERVOL,5,'*')\nEND\nRETURN\n\n/*     */\nGET_SELECTED_SERVER_VOLUME:\nDO I = 1 TO 8\n   SELVOL = VALUE('RV'I)\n   IF SELVOL = '' THEN ITERATE\n   RESTVOL = RSTVOL.I\n   VOLUME = STRIP(RESTVOL,'T',':')\n   LEAVE\nEND\nRETURN\n\n/*     */\nGET_HISTORY_CONTAINER_DATASETS:\nADDRESS TSO\nDSN = 0\nNWHSTLIB = 'PTECH2.NETCA.'SERVER'.'VOLUME'.H'\nNWDSN = SYSDSN(\"'\"NWHSTLIB\"'\")\nIF NWDSN = 'DATASET NOT FOUND' THEN DO\n   SAY '*** DATASET ERROR: DATASET NOT FOUND FOR ('NWHSTLIB'). ***'\n   SAY '*** NWRESTOR EXEC SUBTASK CANCELLED - RETURN CODE: (028). ***'\n   EXIT 028\nEND\n\"ALLOC DA('\"NWHSTLIB\"') FILE(NWDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('NWHSTLIB'). ***'\n   SAY '*** NWRESTOR EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\n\"EXECIO * DISKR NWDD (FINIS STEM HIST.\"\nSRC = RC\n\"FREE FILE(NWDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** EXECIO READ ERROR: ('NWHSTLIB'). ***'\n   SAY '*** NWRESTOR EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nBUDATE.1 = 'XXXX-XX-XX'\nBUDATE.2 = 'XXXX-XX-XX'\nBUDATE.3 = 'XXXX-XX-XX'\nBUDATE.4 = 'XXXX-XX-XX'\nBUDATE.5 = 'XXXX-XX-XX'\nBUDATE.6 = 'XXXX-XX-XX'\nBUDATE.7 = 'XXXX-XX-XX'\nBUDATE.8 = 'XXXX-XX-XX'\nBUDATE.9 = 'XXXX-XX-XX'\nBUDATE.10 = 'XXXX-XX-XX'\nBUDATE.11 = 'XXXX-XX-XX'\nBUDATE.12 = 'XXXX-XX-XX'\nBUDATE.13 = 'XXXX-XX-XX'\nBUDATE.14 = 'XXXX-XX-XX'\nBUDATE.15 = 'XXXX-XX-XX'\nBUDATE.16 = 'XXXX-XX-XX'\nBUDATE.17 = 'XXXX-XX-XX'\nBUDATE.18 = 'XXXX-XX-XX'\nBUDSN.1 = '--------------------------------------------'\nBUDSN.2 = '--------------------------------------------'\nBUDSN.3 = '--------------------------------------------'\nBUDSN.4 = '--------------------------------------------'\nBUDSN.5 = '--------------------------------------------'\nBUDSN.6 = '--------------------------------------------'\nBUDSN.7 = '--------------------------------------------'\nBUDSN.8 = '--------------------------------------------'\nBUDSN.9 = '--------------------------------------------'\nBUDSN.10 = '--------------------------------------------'\nBUDSN.11 = '--------------------------------------------'\nBUDSN.12 = '--------------------------------------------'\nBUDSN.13 = '--------------------------------------------'\nBUDSN.14 = '--------------------------------------------'\nBUDSN.15 = '--------------------------------------------'\nBUDSN.16 = '--------------------------------------------'\nBUDSN.17 = '--------------------------------------------'\nBUDSN.18 = '--------------------------------------------'\nDO I = 1 TO HIST.0\n   UPPER HIST.I\n   VLOC = POS(VOLKEY,HIST.I)\n   IF VLOC \u00ac= 0 THEN DO\n      BUSTATUS = WORD(HIST.I,9)\n      IF BUSTATUS = 'SSSS' THEN DO\n         BUTYPE = WORD(HIST.I,5)\n         IF BUTYPE = RESTMOD.RM THEN DO\n            DSN = DSN + 1\n            BUDATE.DSN = WORD(HIST.I,1)\n            BUTIME.DSN = WORD(HIST.I,2)\n            L = I + 1\n            UPPER HIST.L\n            HSTDSN = WORD(HIST.L,2)\n            BUDSN.DSN = STRIP(HSTDSN,\"B\",\"'\")\n         END\n      END\n   END\nEND\nRETURN\n\n/*     */\nBUILD_PANEL_DATASET_PARMS:\nDO D = 1 TO GDGCNT\n   IF BUDSN.D = '' THEN ITERATE\n   IF D = 1 THEN DO\n      BUDATE01 = BUDATE.D\n      BUDSN01 = BUDSN.D\n   END\n   IF D = 2 THEN DO\n      BUDATE02 = BUDATE.D\n      BUDSN02 = BUDSN.D\n   END\n   IF D = 3 THEN DO\n      BUDATE03 = BUDATE.D\n      BUDSN03 = BUDSN.D\n   END\n   IF D = 4 THEN DO\n      BUDATE04 = BUDATE.D\n      BUDSN04 = BUDSN.D\n   END\n   IF D = 5 THEN DO\n      BUDATE05 = BUDATE.D\n      BUDSN05 = BUDSN.D\n   END\n   IF D = 6 THEN DO\n      BUDATE06 = BUDATE.D\n      BUDSN06 = BUDSN.D\n   END\n   IF D = 7 THEN DO\n      BUDATE07 = BUDATE.D\n      BUDSN07 = BUDSN.D\n   END\n   IF D = 8 THEN DO\n      BUDATE08 = BUDATE.D\n      BUDSN08 = BUDSN.D\n   END\n   IF D = 9 THEN DO\n      BUDATE09 = BUDATE.D\n      BUDSN09 = BUDSN.D\n   END\n   IF D = 10 THEN DO\n      BUDATE10 = BUDATE.D\n      BUDSN10 = BUDSN.D\n   END\n   IF D = 11 THEN DO\n      BUDATE11 = BUDATE.D\n      BUDSN11 = BUDSN.D\n   END\n   IF D = 12 THEN DO\n      BUDATE12 = BUDATE.D\n      BUDSN12 = BUDSN.D\n   END\n   IF D = 13 THEN DO\n      BUDATE13 = BUDATE.D\n      BUDSN13 = BUDSN.D\n   END\n   IF D = 14 THEN DO\n      BUDATE14 = BUDATE.D\n      BUDSN14 = BUDSN.D\n   END\n   IF D = 15 THEN DO\n      BUDATE15 = BUDATE.D\n      BUDSN15 = BUDSN.D\n   END\n   IF D = 16 THEN DO\n      BUDATE16 = BUDATE.D\n      BUDSN16 = BUDSN.D\n   END\n   IF D = 17 THEN DO\n      BUDATE17 = BUDATE.D\n      BUDSN17 = BUDSN.D\n   END\n   IF D = 18 THEN DO\n      BUDATE18 = BUDATE.D\n      BUDSN18 = BUDSN.D\n   END\nEND\nRETURN\n\n/*     */\nGET_PANEL_INPUT_DATASET:\nDSNSW = 'NO'\nDO I = 1 TO GDGCNT\n   SELDSN = VALUE('RD'I)\n   IF SELDSN = '' THEN ITERATE\n   IF I < 10 THEN DO\n      RESTDAT = VALUE('BUDATE0'I)\n      RESTDSN = VALUE('BUDSN0'I)\n   END\n   IF I >= 10 THEN DO\n      RESTDAT = VALUE('BUDATE'I)\n      RESTDSN = VALUE('BUDSN'I)\n   END\n   IF RESTDSN = '' THEN ITERATE\n   DSNSW = 'YES'\n   LEAVE\nEND\nRETURN\n\n/*     */\nLISTCAT_CONTAINER_DATASET:\nADDRESS TSO\nT = 0\nX = OUTTRAP(\"LSTCAT.\",\"*\",\"CONCAT\")\n\"LISTCAT ENT('\"RESTDSN\"') ALL\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** LISTCAT ERROR: 'RESTDSN'. ***'\n   SAY '*** NWRESTOR EXEC SUBTASK CANCELLED - RC = ('SRC'). ***'\n   EXIT SRC\nEND\nDO L = 1 TO LSTCAT.0\n   VOLKEY = POS(\"VOLSER------------\",LSTCAT.L)\n   IF VOLKEY \u00ac= 0 THEN DO\n      STA = VOLKEY + 18\n      T = T + 1\n      TAPE.T = SUBSTR(LSTCAT.L,STA,6)\n   END\nEND\nTAPECNT = T\nRETURN\n\n/*     */\nBUILD_PANEL_TAPE_VOLSERS:\nDO T = 1 TO TAPECNT\n   IF T = 1 THEN TAPE1 = TAPE.T\n   IF T = 2 THEN TAPE2 = TAPE.T\n   IF T = 3 THEN TAPE3 = TAPE.T\n   IF T = 4 THEN TAPE4 = TAPE.T\n   IF T = 5 THEN TAPE5 = TAPE.T\n   IF T = 6 THEN TAPE6 = TAPE.T\n   IF T = 7 THEN TAPE7 = TAPE.T\n   IF T = 8 THEN TAPE8 = TAPE.T\nEND\nRETURN\n\n/*     */\nBUILD_JOBNAME_PARM:\nJN1 = 'NWR'\nJN2 = SUBSTR(TSOID,5,3)\nDO N = 1 TO 26\n   JN3 = SUBSTR(JSUFFIX,N,1)\n   JOBNAME = JN1||JN2||JN3\n   JOB = SYSDSN(\"'\"CNTLLIB\"(\"JOBNAME\")'\")\n   IF JOB = 'MEMBER NOT FOUND' THEN LEAVE\nEND\nJN = JOBNAME\nRETURN\n\n/*     */\nBUILD_RESTORE_JOB:\n\"DELSTACK\"\nRCDCNT = 36\nDIRPATH = STRIP(RESTDPN,'T','/')\nSTARGET = RESTVOL||DIRPATH\nIF RESTDPN = '*' THEN STARGET = RESTVOL\nIF SERVER  = 'C4A' THEN SERVER = 'CS4'\nIF SERVER  = 'C4B' THEN SERVER = 'CS4'\nJCL.1 = \"//\"JN\"  JOB 5304010530000000,'\"SERVER\" LAN RESTORE',NOTIFY=\"TSOID\",\"\nJCL.2 = \"//             CLASS=S,MSGCLASS=G,MSGLEVEL=(1,1),REGION=6M\"\nJCL.3 = \"/*JOBPARM SYSAFF=SYSB\"\nJCL.4 = \"//RESTORE  EXEC PGM=NUACLIEN\"\nJCL.5 = \"//NETUADD  DD DSN=PTECH3.NETCA.RESTORE.SCRIPT.PARMLIB,DISP=SHR\"\nJCL.6 = \"//SYSPRINT DD SYSOUT=*\"\nJCL.7 = \"//SYSIN DD *\"\nJCL.8 = \"CONNECT RS6000 -SERV \"SERVER\" \"LANID\" \"LANPW\nJCL.9 = \"SET DEBUG LOG SYS:/SICOM/CA/RESTORE/DEBUG.LOG\"\nJCL.10 = \"SET GLOBAL TARGET\" STARGET\nJCL.11 = \"SET GLOBAL OPTIONS -LOG SYS:/SICOM/CA/DB/RESTORE.RPT\"\nJCL.12 = \"INPUT 'SYSS.NETCA.LAN.MVSNW.UA'\"\nJCL.13 = \"INPUT DD:NETUADD(\"SMEMB\")\"\nJCL.14 = \"EXIT\"\nJCL.15 = \"/*\"\nJCL.16 = \"//WRITELOG EXEC PGM=IKJEFT01,DYNAMNBR=30,\"\nJCL.17 = \"//   PARM='%NWRSTLOG \"JMEMB\"',COND=(0,LT,RESTORE)\"\nJCL.18 = \"//SYSPRINT DD SYSOUT=*\"\nJCL.19 = \"//SYSTSPRT DD SYSOUT=*\"\nJCL.20 = \"//SYSIN    DD DUMMY\"\nJCL.21 = \"//SYSLBC   DD DSN=SYS1.BRODCAST,DISP=SHR\"\nJCL.22 = \"//SYSUADS  DD DSN=SYS1.UADS,DISP=SHR\"\nJCL.23 = \"//SYSPROC  DD DSN=SYSS.TECH.COMMON.EXECLIB,DISP=SHR\"\nJCL.24 = \"//SYSTSIN  DD DUMMY\"\nJCL.25 = \"/*\"\nJCL.26 = \"//DELETE   EXEC PGM=IDCAMS\"\nJCL.27 = \"//CNTLDD   DD DSN=\"CNTLLIB\",DISP=SHR\"\nJCL.28 = \"//SCRIPTDD DD DSN=\"SCRIPTLIB\",DISP=SHR\"\nJCL.29 = \"//SYSPRINT DD SYSOUT=*\"\nJCL.30 = \"//SYSIN    DD *\"\nJCL.31 = \"  DELETE   \"SCRIPTLIB\"(\"SMEMB\")  FILE(SCRIPTDD)\"\nJCL.32 = \"  DELETE   \"CNTLLIB\"(\"JMEMB\")  FILE(CNTLDD)\"\nJCL.33 = \"  DELETE   \"CNTLLIB\"(\"RMEMB\")  FILE(CNTLDD)\"\nJCL.34 = \"  DELETE   \"CNTLLIB\"(\"JOBNAME\")  FILE(CNTLDD)\"\nJCL.35 = \"/*\"\nJCL.36 = \"//\"\nDO J = 1 TO RCDCNT\n   QUEUE JCL.J\nEND\nRETURN\n\n/*     */\nBUILD_RESTORE_PARMS:\n\"DELSTACK\"\nRESTDSN = \"'\"||RESTDSN||\"'\"\nRESTPRM = '\"'||RESTDPN||RESTFN||' -PDT ON -REP ON\"'\nIF RESTYPE.RT = 'FILE' THEN DO\n   RECORD1 = 'CA_RESTORE 'RESTMOD.RM' 'RESTDSN' 'RESTVOL' -'\n   QUEUE RECORD1\n   RECORD2 = '   '||RESTPRM\n   QUEUE RECORD2\nEND\nIF RESTYPE.RT = 'DRCT' THEN DO\n   RESTPRM = '\"'||RESTDPN'*.* -PDT ON -REP ON\"'\n   RECORD1 = 'CA_RESTORE 'RESTMOD.RM' 'RESTDSN' 'RESTVOL' -'\n   QUEUE RECORD1\n   RECORD2 = '   '||RESTPRM\n   QUEUE RECORD2\nEND\nIF RESTYPE.RT = 'VOL' THEN DO\n   RECORD = 'CA_RESTORE 'RESTMOD.RM' 'RESTDSN' 'RESTVOL' -'\n   QUEUE RECORD\n   RECORD2 = '    \"/* -PDT ON REP ON\"'\n   QUEUE RECORD2\nEND\nRETURN\n\n/*     */\nWRITE_PDS_MEMBER:\nADDRESS TSO\n\"ALLOC DA('\"OUTPDS\"(\"OUTMEMB\")') FILE(NWDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('OUTPDS'('OUTMEMB'). ***'\n   SAY '*** NWRESTOR EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nNUMRCDS = QUEUED()\n\"EXECIO\" NUMRCDS \"DISKW NWDD (FINIS\"\nSRC = RC\n\"FREE FILE(NWDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** WRITE ERROR: ERROR WRITING 'OUTPDS'('OUTMEMB'). ***'\n   SAY '*** NWRESTOR EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nRETURN\n\n/*     */\nSUBMIT_RESTORE_JOB:\nADDRESS TSO\n\"SUBMIT ('\"SUBPDS\"(\"RMEMB\")')\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** SUBMIT ERROR: MEMBER ( 'SUBPDS'('RMEMB'). ***'\n   SAY '*** NWRESTOR EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "NWRESTOR": {"ttr": 17157, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01c\\x00\\x00\\x00\\x93\\x11\\x7f\\x00\\x95'\\x0f\\x144\\x02`\\x02/\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf3@@@\"", "ispf": {"version": "01.99", "flags": 0, "createdate": "1993-04-27T00:00:00", "modifydate": "1995-09-27T14:34:00", "lines": 608, "newlines": 559, "modlines": 0, "user": "TECH103"}, "text": "/*  REXX EXEC : ( NWRESTOR ).\n    FUNCTION  : LAN SERVER BACKUP PANEL INTERFACE TO FACILITATE FILE\n                RESTORES FOR A SERVER VOLUME FROM THE MVS HOST CENTRAL\n                ARCHIVE BACKUP.\n                BUILDS AND WRITES THE JOB JCL AND INPUT SCRIPT TO\n                PERFORM THE LAN SERVER RESTORE AND SUBMITS THE JOB\n                FOR EXECUTION ON THE SYSA SYSTEM CLASS=S.\n    INPUT     : ( PTECH2.NETCA.&&SERVER.&&VOLUME.H ).\n    OUTPUT    : ( PTECH3.NETCA.RESTORE.SCRIPT.CNTLLIB(&MEMBER).\n    AUTHOR    : DAN BOWEN.\n                                                                    */\nTRACE O\n/*      */\nHOUSE_KEEPING:\nADDRESS TSO\nSERVER.1 = 'CS1'\nSERVER.2 = 'CS2'\nSERVER.3 = 'MIS'\nSERVER.4 = 'FIN'\nSERVER.5 = 'CS4 C4A'\nSERVER.6 = 'CS4 C4B'\nSERVER.7 = 'CS5'\nSERVER.8 = 'CS6 C6A'\nSERVER.9 = 'CS6 C6B'\nSERVER.10 = 'COM'\nSERVER.11 = 'MAGIC DIRECTORY SYS: CS6'\nSERVER.12 = 'POS DIRECTORY VOL1: CS6'\nSERVER.13 = 'REA DIRECTORY VOL2: CS1'\nSERVER.14 = 'APPL DIRECTORY VOL3: FIN'\nRESTYPE.1 = 'FILE'\nRESTYPE.2 = 'DRCT'\nRESTYPE.3 = 'VOL'\nRMODE.1 = 'INCR'\nRMODE.2 = 'FULL'\nUSERACC = 'TCPIP'\nAST = '*****'\nXDATE = 'XXXX-XX-XX'\nXDSN = '--------------------------------------------'\nNETEX_CNT = 3\nNETEX_SERVERS = 'CS6 C6A C6B'\nPARMLIB = 'SYSS.TECH.COMMON.PARMLIB'\nSCRIPTLIB = 'PTECH3.NETCA.RESTORE.SCRIPT.PARMLIB'\nCNTLLIB = 'PTECH3.NETCA.RESTORE.SCRIPT.CNTLLIB'\nTEXTLIB = 'SYSS.NETCA.CONTROL.TEXTLIB'\nTSOID = SYSVAR(SYSUID)\nCURTIME = TIME()\nHH = SUBSTR(CURTIME,1,2)\nMM = SUBSTR(CURTIME,4,2)\nSS = SUBSTR(CURTIME,7,2)\nTIMEP = HH||MM||SS\nJSUFFIX = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\nX = MSG(\"OFF\")\n\"FREE FILE(NWDD)\"\n\"FREE FILE(ISPFILE)\"\nADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\n/*\n        M A I N   R O U T I N E   S E C T I O N\n                                                       */\n/*     */\nDISPLAY_SERVER_PANEL:\nAUTHPARM = 'NWHPDESK'\nNWMSG = 'NWLAN002'\nDO FOREVER\n   ADDRESS ISPEXEC\n   \"DISPLAY PANEL(NWRSTPN1)\"\n   SRC = RC\n   IF SRC = 8 THEN EXIT 0\n   IF SRC > 8 THEN DO\n      SAY '*** ERROR INVOKING ISPF DIALOG PANEL ( NWRSTPN1 ). ***'\n      SAY '*** NWRESTOR EXEC TASK CANCELLED - RC = 'SRC'. ***'\n      EXIT SRC\n   END\n   IF RESTYPE.RT = 'VOL' THEN DO\n      AUTHPARM = 'NWLANGRP'\n      NWMSG = 'NWLAN003'\n   END\n   CALL CHECK_USER_AUTHORIZATION\n   IF AUTHSW = 'YES' THEN LEAVE\n   \"SETMSG MSG(\"NWMSG\")\"\nEND\n/*     */\nCHECK_DIRECTORY_PARM:\nSERVER = WORD(SERVER.LAN,1)\nLANSERV = WORD(SERVER.LAN,2)\nIF LANSERV = '' THEN LANSERV = SERVER\nDIRESTORE = WORD(SERVER.LAN,2)\nIF DIRESTORE = 'DIRECTORY' THEN DO\n   VOLKEY = WORD(SERVER.LAN,1)||' 'WORD(SERVER.LAN,3)\n   RESTVOL = WORD(SERVER.LAN,3)\n   VOLUME = WORD(SERVER.LAN,1)\n   SERVER = WORD(SERVER.LAN,4)\n   LANSERV = WORD(SERVER.LAN,4)\n   DO N = 1 TO NETEX_CNT\n      NETX = WORD(NETEX_SERVERS,N)\n      IF NETX = LANSERV THEN USERACC = 'NETEX'\n   END\n   RM = 2\n   SIGNAL BUILD_CONTAINER_DATASET_PARMS\nEND\n/*     */\nDISPLAY_VOLUME_PANEL:\nCALL READ_SERVER_VOLUMES_PARMS\nADDRESS ISPEXEC \"DISPLAY PANEL(NWRSTPN2)\"\nSRC = RC\nIF SRC = 8 THEN EXIT 0\nIF SRC > 8 THEN DO\n   SAY '*** ERROR INVOKING ISPF DIALOG PANEL ( NWRSTPN2 ). ***'\n   SAY '*** NWRESTOR EXEC TASK CANCELLED - RC = 'SRC'. ***'\n   EXIT SRC\nEND\nCALL GET_SELECTED_SERVER_VOLUME\nVOLKEY = VOLUME RESTVOL\n/*     */\nBUILD_CONTAINER_DATASET_PARMS:\nCALL GET_HISTORY_CONTAINER_DATASETS\nIF DSN = 0 THEN DO\n   SAY '*** HISTORY DATASET ERROR: NO VALID CONTAINER DATASET NAMES FOUND. ***'\n   SAY '*** DSN ('NWHSTLIB') DOES NOT CONTAIN A BACKUP STATUS OF (SSSS). ***'\n   SAY '*** NWRESTOR EXEC TASK CANCELLED - RC = (028). ***'\n   EXIT 028\nEND\nGDGCNT = 18\nNWPANEL = 'NWRSTPN3'\nCALL BUILD_PANEL_DATASET_PARMS\n/*     */\nDISPLAY_DATASET_LIST_PANEL:\nDO FOREVER\n   ADDRESS ISPEXEC\n   \"DISPLAY PANEL(\"NWPANEL\")\"\n   SRC = RC\n   IF SRC = 8 THEN EXIT 0\n   IF SRC > 8 THEN DO\n      SAY '*** ERROR INVOKING ISPF DIALOG PANEL ( 'NWPANEL' ). ***'\n      SAY '*** NWRESTOR EXEC TASK CANCELLED - RC = 'SRC'. ***'\n      EXIT SRC\n   END\n   CALL GET_PANEL_INPUT_DATASET\n   IF DSNSW = 'YES' THEN LEAVE\n   \"SETMSG MSG(NWLAN004)\"\nEND\nIF RESTYPE.RT = 'DRCT' & RESTFN = '' THEN RESTFN = '*'\nIF RESTYPE.RT = 'VOL' THEN DO\n   RESTDPN = '*'\n   RESTFN = '*'\nEND\n/*     */\nDISPLAY_INPUT_PARMS_CONFIRMATION_PANEL:\nCALL LISTCAT_CONTAINER_DATASET\nCALL BUILD_PANEL_TAPE_VOLSERS\nADDRESS ISPEXEC\n\"DISPLAY PANEL(NWRSTPN5)\"\nSRC = RC\nIF SRC = 8 THEN EXIT 0\nIF SRC > 8 THEN DO\n   SAY '*** ERROR INVOKING ISPF DIALOG PANEL ( NWRSTPN5 ). ***'\n   SAY '*** NWRESTOR EXEC TASK CANCELLED - RC = 'SRC'. ***'\n   EXIT SRC\nEND\n/*     */\nCREATE_RESTORE_JOB_PARMS:\nADDRESS TSO\nSUBPDS = CNTLLIB\nJMEMB = 'J'TIMEP                  /* JOURNAL PARMS MEMBER */\nRMEMB = 'R'TIMEP                  /* RESTORE JOB JCL MEMBER */\nSMEMB = 'S'TIMEP                  /* SCRIPT INPUT MEMBER */\n\"DELSTACK\"\nCALL BUILD_JOBNAME_PARM\nOUTPDS = CNTLLIB\nOUTMEMB = JOBNAME\nQUEUE JOBNAME\nCALL WRITE_PDS_MEMBER\nDO N = 1 TO NETEX_CNT\n   NETX = WORD(NETEX_SERVERS,N)\n   IF NETX = LANSERV THEN USERACC = 'NETEX'\nEND\nLABEL = 'BUILD_RESTORE_JOB_'USERACC\nINTERPRET CALL LABEL\nOUTMEMB = RMEMB\nCALL WRITE_PDS_MEMBER\n\"DELSTACK\"\nQUEUE SERVER\nQUEUE RESTVOL\nQUEUE RESTDSN\nQUEUE RESTDPN\nQUEUE RESTFN\nOUTMEMB = JMEMB\nCALL WRITE_PDS_MEMBER\nLABEL = 'BUILD_RESTORE_PARMS_'USERACC\nINTERPRET CALL LABEL\nOUTMEMB = SMEMB\nOUTPDS = SCRIPTLIB\nCALL WRITE_PDS_MEMBER\nCALL SUBMIT_RESTORE_JOB\nEXIT 0\n/*\n       S U B R O U T I N E S   S E C T I O N     */\n/*     */\nCHECK_USER_AUTHORIZATION:\nADDRESS TSO\nAUTHSW = 'NO'\n\"ALLOC DA('\"PARMLIB\"(\"AUTHPARM\")') FILE(NWDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('PARMLIB'('AUTHPARM'). ***'\n   SAY '*** NWRESTOR EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\n\"EXECIO * DISKR NWDD (FINIS STEM AUTH.\"\nSRC = RC\n\"FREE FILE(NWDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** EXECIO READ ERROR: ('PARMLIB'('AUTHPARM'). ***'\n   SAY '*** NWRESTOR EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nDO I = 1 TO AUTH.0\n   LAU = POS(TSOID,AUTH.I)\n   IF LAU \u00ac= 0 THEN AUTHSW = 'YES'\nEND\nRETURN\n/*     */\nREAD_SERVER_VOLUMES_PARMS:\nADDRESS TSO\nVOLCONFG = LANSERV'IVOLS'\nIF RMODE.RM = 'FULL' THEN VOLCONFG = LANSERV'FVOLS'\n\"ALLOC DA('\"TEXTLIB\"(\"VOLCONFG\")') FILE(NWDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('TEXTLIB'('VOLCONFG'). ***'\n   SAY '*** NWRESTOR EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\n\"EXECIO * DISKR NWDD (STEM VOLP. FINIS\"\nSRC = RC\n\"FREE FILE(NWDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** EXECIO READ ERROR: ('TEXTLIB'('VOLCONFG'). ***'\n   SAY '*** NWRESTOR EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nDO V = 1 TO 8\n   INTERPRET 'VOL'V '= AST'\nEND\nV = 0\nDO I = 1 TO VOLP.0\n   UPPER VOLP.I\n   SVOL = POS('DAILY',VOLP.I)\n   IF SVOL = 0 THEN ITERATE\n   V = V + 1\n   SERVOL = WORD(VOLP.I,2)\n   RSTVOL.V = WORD(VOLP.I,2)\n   PANLVOL = LEFT(SERVOL,5,'*')\n   INTERPRET 'VOL'V '= PANLVOL'\nEND\nRETURN\n/*     */\nGET_SELECTED_SERVER_VOLUME:\nDO I = 1 TO 8\n   SELVOL = VALUE('RV'I)\n   IF SELVOL = '' THEN ITERATE\n   RESTVOL = RSTVOL.I\n   VOLUME = STRIP(RESTVOL,'T',':')\n   LEAVE\nEND\nRETURN\n/*     */\nGET_HISTORY_CONTAINER_DATASETS:\nADDRESS TSO\nDSN = 0\nNWHSTLIB = 'PTECH2.NETCA.'LANSERV'.'VOLUME'.H'\nNWDSN = SYSDSN(\"'\"NWHSTLIB\"'\")\nIF NWDSN = 'DATASET NOT FOUND' THEN DO\n   SAY '*** DATASET ERROR: DATASET NOT FOUND FOR ('NWHSTLIB'). ***'\n   SAY '*** NWRESTOR EXEC SUBTASK CANCELLED - RETURN CODE: (028). ***'\n   EXIT 028\nEND\n\"ALLOC DA('\"NWHSTLIB\"') FILE(NWDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('NWHSTLIB'). ***'\n   SAY '*** NWRESTOR EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\n\"EXECIO * DISKR NWDD (FINIS STEM HIST.\"\nSRC = RC\n\"FREE FILE(NWDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** EXECIO READ ERROR: ('NWHSTLIB'). ***'\n   SAY '*** NWRESTOR EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nDO D = 1 TO 18\n   INTERPRET 'BUDATE.'D '= XDATE'\n   INTERPRET 'BUDSN.'D '= XDSN'\nEND\nDO I = 1 TO HIST.0\n   UPPER HIST.I\n   VLOC = POS(VOLKEY,HIST.I)\n   IF VLOC \u00ac= 0 THEN DO\n      BUSTATUS = WORD(HIST.I,9)\n      IF BUSTATUS = 'SSSS' THEN DO\n         BUTYPE = WORD(HIST.I,5)\n         IF BUTYPE = RMODE.RM THEN DO\n            DSN = DSN + 1\n            BUDATE.DSN = WORD(HIST.I,1)\n            BUTIME.DSN = WORD(HIST.I,2)\n            L = I + 1\n            UPPER HIST.L\n            HSTDSN = WORD(HIST.L,2)\n            BUDSN.DSN = STRIP(HSTDSN,\"B\",\"'\")\n         END\n      END\n   END\nEND\nRETURN\n/*     */\nBUILD_PANEL_DATASET_PARMS:\nDO D = 1 TO GDGCNT\n   IF BUDSN.D = '' THEN ITERATE\n   P = RIGHT(D,2,'0')\n   PNLDATE = BUDATE.D\n   PNLDSN = BUDSN.D\n   INTERPRET 'BUDATE'P '= PNLDATE'\n   INTERPRET 'BUDSN'P '= PNLDSN'\nEND\nRETURN\n/*     */\nGET_PANEL_INPUT_DATASET:\nDSNSW = 'NO'\nDO I = 1 TO GDGCNT\n   SELDSN = VALUE('RD'I)\n   IF SELDSN = '' THEN ITERATE\n   IF I < 10 THEN DO\n      RESTDAT = VALUE('BUDATE0'I)\n      RESTDSN = VALUE('BUDSN0'I)\n   END\n   IF I >= 10 THEN DO\n      RESTDAT = VALUE('BUDATE'I)\n      RESTDSN = VALUE('BUDSN'I)\n   END\n   IF RESTDSN = '' THEN ITERATE\n   DSNSW = 'YES'\n   LEAVE\nEND\nRETURN\n/*     */\nLISTCAT_CONTAINER_DATASET:\nADDRESS TSO\nT = 0\nX = OUTTRAP(\"LSTCAT.\",\"*\",\"CONCAT\")\n\"LISTCAT ENT('\"RESTDSN\"') ALL\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** LISTCAT ERROR: 'RESTDSN'. ***'\n   SAY '*** DATASET NOT FOUND IN SYSTEM USER CATALOG. ***'\n   SAY '*** NWRESTOR EXEC SUBTASK CANCELLED - RC = ('SRC'). ***'\n   EXIT SRC\nEND\nDO L = 1 TO LSTCAT.0\n   VOLKEY = POS(\"VOLSER------------\",LSTCAT.L)\n   IF VOLKEY \u00ac= 0 THEN DO\n      STA = VOLKEY + 18\n      T = T + 1\n      TAPE.T = SUBSTR(LSTCAT.L,STA,6)\n   END\nEND\nTAPECNT = T\nRETURN\n/*     */\nBUILD_PANEL_TAPE_VOLSERS:\nDO T = 1 TO TAPECNT\n   INTERPRET 'TAPE'T '= TAPE.'T\nEND\nRETURN\n/*     */\nBUILD_JOBNAME_PARM:\nJN1 = 'NWR'\nJN2 = SUBSTR(TSOID,5,3)\nDO N = 1 TO 26\n   JN3 = SUBSTR(JSUFFIX,N,1)\n   JOBNAME = JN1||JN2||JN3\n   JOB = SYSDSN(\"'\"CNTLLIB\"(\"JOBNAME\")'\")\n   IF JOB = 'MEMBER NOT FOUND' THEN LEAVE\nEND\nJN = JOBNAME\nRETURN\n/*     */\nBUILD_RESTORE_JOB_NETEX:\n\"DELSTACK\"\nDL = LENGTH(RESTDPN)\nSLASH = SUBSTR(RESTDPN,DL)\nIF SLASH \u00ac= '/' THEN RESTDPN = RESTDPN'/'\nRESTDSN = \"'\"||RESTDSN||\"'\"\nRESTPRM = RESTDPN||RESTFN '-PDT ON -SUB ON -REP ON\"'\nRCD.1 = \"SET INPUT VERIFY ON\"\nRCD.2 = \"ON ERROR EXIT ERROR\"\nRCD.3 = \"CONNECT RS6000 -SERV \"SERVER\" \"LANID\" \"LANPW\nRCD.4 = \"SEND -MODE RESTORE \"RESTDSN\" -\"\nRCD.5 = '    \"!UARESTORE 'RMODE.RM RESTDSN RESTVOL' -'\nRCD.6 = '   '||RESTPRM\nJCL.1 = \"//\"JN\"  JOB 5304010530000000,'\"SERVER\" LAN RESTORE',NOTIFY=\"TSOID\",\"\nJCL.2 = \"//             CLASS=S,MSGCLASS=G,MSGLEVEL=(1,1),REGION=6M\"\nJCL.3 = \"/*JOBPARM SYSAFF=SYSA\"\nJCL.4 = \"//RESTORE  EXEC PGM=NUACLIEN\"\nJCL.5 = \"//NETUADD  DD DSN=PTECH3.NETCA.RESTORE.SCRIPT.PARMLIB,DISP=SHR\"\nJCL.6 = \"//SYSPRINT DD SYSOUT=*\"\nJCL.7 = \"//SYSIN DD *\"\nJCL.9 = \"EXIT\"\nJCL.10 = \"/*\"\nJCL.11 = \"//WRITELOG EXEC PGM=IKJEFT01,DYNAMNBR=30,\"\nJCL.12 = \"//   PARM='%NWRSTLOG \"JMEMB\"',COND=(0,LT,RESTORE)\"\nJCL.13 = \"//SYSPRINT DD SYSOUT=*\"\nJCL.14 = \"//SYSTSPRT DD SYSOUT=*\"\nJCL.15 = \"//SYSIN    DD DUMMY\"\nJCL.16 = \"//SYSLBC   DD DSN=SYS1.BRODCAST,DISP=SHR\"\nJCL.17 = \"//SYSUADS  DD DSN=SYS1.UADS,DISP=SHR\"\nJCL.18 = \"//SYSPROC  DD DSN=SYSS.TECH.COMMON.EXECLIB,DISP=SHR\"\nJCL.19 = \"//SYSTSIN  DD DUMMY\"\nJCL.20 = \"/*\"\nJCL.21 = \"//DELETE   EXEC PGM=IDCAMS\"\nJCL.22 = \"//CNTLDD   DD DSN=\"CNTLLIB\",DISP=SHR\"\nJCL.23 = \"//SCRIPTDD DD DSN=\"SCRIPTLIB\",DISP=SHR\"\nJCL.24 = \"//SYSPRINT DD SYSOUT=*\"\nJCL.25 = \"//SYSIN    DD *\"\nJCL.26 = \"  DELETE   \"SCRIPTLIB\"(\"SMEMB\")  FILE(SCRIPTDD)\"\nJCL.27 = \"  DELETE   \"CNTLLIB\"(\"JMEMB\")  FILE(CNTLDD)\"\nJCL.28 = \"  DELETE   \"CNTLLIB\"(\"RMEMB\")  FILE(CNTLDD)\"\nJCL.29 = \"  DELETE   \"CNTLLIB\"(\"JOBNAME\")  FILE(CNTLDD)\"\nJCL.30 = \"/*\"\nJCL.31 = \"//\"\nDO J = 1 TO 7\n   QUEUE JCL.J\nEND\nIF RESTYPE.RT = 'FILE' THEN DO R = 1 TO 6\n   QUEUE RCD.R\nEND\nIF RESTYPE.RT = 'DRCT' THEN DO\n   RESTPRM = RESTDPN\"* -PDT ON -SUB ON -REP ON\"\n   RCD.6 = '   '||RESTPRM\n   DO R = 1 TO 6\n      QUEUE RCD.R\n   END\nEND\nIF RESTYPE.RT = 'VOL' THEN DO\n   RCD.6 = \"     /* -PDT ON REP ON\"\n   DO R = 1 TO 6\n      QUEUE RCD.R\n   END\nEND\nDO J = 9 TO 31\n   QUEUE JCL.J\nEND\nRETURN\n/*     */\nBUILD_RESTORE_JOB_TCPIP:\n\"DELSTACK\"\nDL = LENGTH(RESTDPN)\nSLASH = SUBSTR(RESTDPN,DL)\nIF SLASH \u00ac= '/' THEN RESTDPN = RESTDPN'/'\nRESTDSN = \"'\"||RESTDSN||\"'\"\nRESTPRM = RESTDPN||RESTFN '-PDT ON -SUB ON -REP ON\"'\nRCD.1 = \"SET INPUT VERIFY ON\"\nRCD.2 = \"ON ERROR EXIT ERROR\"\nRCD.3 = \"CONNECT \"SERVER\" \"LANID\" \"LANPW\nRCD.4 = \"SEND -MODE RESTORE \"RESTDSN\" -\"\nRCD.5 = '    \"!UARESTORE 'RMODE.RM RESTDSN RESTVOL' -'\nRCD.6 = '   '||RESTPRM\nJCL.1 = \"//\"JN\"  JOB 5304010530000000,'\"SERVER\" LAN RESTORE',NOTIFY=\"TSOID\",\"\nJCL.2 = \"//             CLASS=S,MSGCLASS=G,MSGLEVEL=(1,1),REGION=6M\"\nJCL.3 = \"//RESTORE  EXEC PGM=NUACLIEN\"\nJCL.4 = \"//STEPLIB  DD DSN=SYS1.NETUA.V2R10M12.LOADLIB,DISP=SHR\"\nJCL.5 = \"//         DD DSN=SYS1.NETCA.V1R1M1.H213CMT.LOADLIB,DISP=SHR\"\nJCL.6 = \"//NETUADD  DD DSN=PTECH3.NETCA.RESTORE.SCRIPT.PARMLIB,DISP=SHR\"\nJCL.7 = \"//SYSPRINT DD SYSOUT=*\"\nJCL.8 = \"//SYSIN DD *\"\nJCL.9 = \"EXIT\"\nJCL.10 = \"/*\"\nJCL.11 = \"//WRITELOG EXEC PGM=IKJEFT01,DYNAMNBR=30,\"\nJCL.12 = \"//   PARM='%NWRSTLOG \"JMEMB\"',COND=(0,LT,RESTORE)\"\nJCL.13 = \"//SYSPRINT DD SYSOUT=*\"\nJCL.14 = \"//SYSTSPRT DD SYSOUT=*\"\nJCL.15 = \"//SYSIN    DD DUMMY\"\nJCL.16 = \"//SYSLBC   DD DSN=SYS1.BRODCAST,DISP=SHR\"\nJCL.17 = \"//SYSUADS  DD DSN=SYS1.UADS,DISP=SHR\"\nJCL.18 = \"//SYSPROC  DD DSN=SYSS.TECH.COMMON.EXECLIB,DISP=SHR\"\nJCL.19 = \"//SYSTSIN  DD DUMMY\"\nJCL.20 = \"/*\"\nJCL.21 = \"//DELETE   EXEC PGM=IDCAMS\"\nJCL.22 = \"//CNTLDD   DD DSN=\"CNTLLIB\",DISP=SHR\"\nJCL.23 = \"//SCRIPTDD DD DSN=\"SCRIPTLIB\",DISP=SHR\"\nJCL.24 = \"//SYSPRINT DD SYSOUT=*\"\nJCL.25 = \"//SYSIN    DD *\"\nJCL.26 = \"  DELETE   \"SCRIPTLIB\"(\"SMEMB\")  FILE(SCRIPTDD)\"\nJCL.27 = \"  DELETE   \"CNTLLIB\"(\"JMEMB\")  FILE(CNTLDD)\"\nJCL.28 = \"  DELETE   \"CNTLLIB\"(\"RMEMB\")  FILE(CNTLDD)\"\nJCL.29 = \"  DELETE   \"CNTLLIB\"(\"JOBNAME\")  FILE(CNTLDD)\"\nJCL.30 = \"/*\"\nJCL.31 = \"//\"\nDO J = 1 TO 8\n   QUEUE JCL.J\nEND\nIF RESTYPE.RT = 'FILE' THEN DO R = 1 TO 6\n   QUEUE RCD.R\nEND\nIF RESTYPE.RT = 'DRCT' THEN DO\n   RESTPRM = RESTDPN\"* -PDT ON -SUB ON -REP ON\"\n   RCD.6 = '   '||RESTPRM\n   DO R = 1 TO 6\n      QUEUE RCD.R\n   END\nEND\nIF RESTYPE.RT = 'VOL' THEN DO\n   RCD.6 = \"     /* -PDT ON REP ON\"\n   DO R = 1 TO 6\n      QUEUE RCD.R\n   END\nEND\nDO J = 9 TO 31\n   QUEUE JCL.J\nEND\nRETURN\n/*     */\nBUILD_RESTORE_PARMS_NETEX:\n\"DELSTACK\"\nDL = LENGTH(RESTDPN)\nSLASH = SUBSTR(RESTDPN,DL)\nIF SLASH \u00ac= '/' THEN RESTDPN = RESTDPN'/'\nRESTDSN = \"'\"||RESTDSN||\"'\"\nRESTPRM = '\"'||RESTDPN||RESTFN||' -PDT ON -SUB ON -REP ON\"'\nIF RESTYPE.RT = 'FILE' THEN DO\n   RECORD1 = 'CA_RESTORE 'RMODE.RM' 'RESTDSN' 'RESTVOL' -'\n   QUEUE RECORD1\n   RECORD2 = '   '||RESTPRM\n   QUEUE RECORD2\nEND\nIF RESTYPE.RT = 'DRCT' THEN DO\n   RESTPRM = '\"'||RESTDPN'* -PDT ON -SUB ON -REP ON\"'\n   RECORD1 = 'CA_RESTORE 'RMODE.RM' 'RESTDSN' 'RESTVOL' -'\n   QUEUE RECORD1\n   RECORD2 = '   '||RESTPRM\n   QUEUE RECORD2\nEND\nIF RESTYPE.RT = 'VOL' THEN DO\n   RECORD = 'CA_RESTORE 'RMODE.RM' 'RESTDSN' 'RESTVOL' -'\n   QUEUE RECORD\n   RECORD2 = '    \"/* -PDT ON REP ON\"'\n   QUEUE RECORD2\nEND\nRETURN\n/*     */\nBUILD_RESTORE_PARMS_TCPIP:\n\"DELSTACK\"\nRESTPRM = RESTDPN||RESTFN '-PDT ON -SUB ON -REP ON\"'\nRCD.1 = \"SET INPUT VERIFY ON\"\nRCD.2 = \"ON ERROR EXIT ERROR\"\nRCD.3 = \"CONNECT \"SERVER\" \"LANID\" \"LANPW\nRCD.4 = \"SEND -MODE RESTORE \"RESTDSN\" -\"\nRCD.5 = '\"!UARESTORE 'RMODE.RM RESTDSN RESTVOL' -'\nRCD.6 = '   '||RESTPRM\nRCD.7 = '-LOG RESTORE.LOG  -ERR RESTORE.ERR\" {HOST:REMOTE}.{DATE(1)}'\nIF RESTYPE.RT = 'FILE' THEN DO R = 1 TO 6\n   QUEUE RCD.R\nEND\nIF RESTYPE.RT = 'DRCT' THEN DO\n   RESTPRM = RESTDPN\"* -PDT ON -SUB ON -REP ON\"\n   RCD.6 = '   '||RESTPRM\n   DO R = 1 TO 6\n      QUEUE RCD.R\n   END\nEND\nIF RESTYPE.RT = 'VOL' THEN DO\n   RCD.6 = \"     /* -PDT ON REP ON\"\n   DO R = 1 TO 6\n      QUEUE RCD.R\n   END\nEND\nRETURN\n/*     */\nWRITE_PDS_MEMBER:\nADDRESS TSO\n\"ALLOC DA('\"OUTPDS\"(\"OUTMEMB\")') FILE(NWDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('OUTPDS'('OUTMEMB'). ***'\n   SAY '*** NWRESTOR EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nNUMRCDS = QUEUED()\n\"EXECIO\" NUMRCDS \"DISKW NWDD (FINIS\"\nSRC = RC\n\"FREE FILE(NWDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** WRITE ERROR: ERROR WRITING 'OUTPDS'('OUTMEMB'). ***'\n   SAY '*** NWRESTOR EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nRETURN\n/*     */\nSUBMIT_RESTORE_JOB:\nADDRESS TSO\n\"SUBMIT ('\"SUBPDS\"(\"RMEMB\")')\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** SUBMIT ERROR: MEMBER ( 'SUBPDS'('RMEMB'). ***'\n   SAY '*** NWRESTOR EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "NWRSTLOG": {"ttr": 17413, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0f\\x00\\x00\\x00\\x93\\x08\\x8f\\x00\\x93\"?\\x17\\x02\\x00p\\x01\\xa9\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf3@@@'", "ispf": {"version": "01.15", "flags": 0, "createdate": "1993-03-29T00:00:00", "modifydate": "1993-08-11T17:02:00", "lines": 112, "newlines": 425, "modlines": 0, "user": "TECH103"}, "text": "/*  REXX EXEC : ( NWRSTLOG ).\n    FUNCTION  : LAN SERVER RESTORE FROM MVS/ESA CENTRAL ARCHIVE HOST\n                WRITE JOURNAL ENTRY TO RECORD RESTORE FUNCTION TASKS.\n                EXECUTED ONLY IF CONDITION CODE ZERO IS RETURNED FROM\n                STEP 1 ( STEPNAME=RESTORE ) IN JOBSTREAM.\n    INPUT     : ( SYSS.NETCA.RESTORE.JOURNAL ).\n                ( &&USERID.DIALOG.ISPFILE ).\n    OUTPUT    : ( SYSS.NETCA.RESTORE.JOURNAL ).\n                                                                    */\nTRACE O\n/*     */\nHOUSE_KEEPING:\nADDRESS TSO\nARG JRNALMEM\nIF JRNALMEM = '' THEN DO\n   SAY '*** PARM ERROR: MISSING PARM VALUE FOR JOURNAL MEMBER. ***'\n   SAY '*** NWRSTLOG EXEC TASK CANCELLED - RC = (024). ***'\n   EXIT 024\nEND\nCDATE = DATE(U)\nCTIME = TIME()\nTSOID = SYSVAR(SYSUID)\nJOURLIB = 'PTECH3.NETCA.RESTORE.JOURNAL'\nJOURPDS = 'PTECH3.NETCA.RESTORE.SCRIPT.CNTLLIB'\nX = MSG(\"OFF\")\nNWDSN = SYSDSN(\"'\"JOURLIB\"'\")\nIF NWDSN = 'DATASET NOT FOUND' THEN DO\n   SAY '*** DATASET ERROR: DATASET NOT FOUND FOR ('JOURLIB'). ***'\n   SAY '*** NWRSTLOG EXEC SUBTASK CANCELLED - RETURN CODE: (028). ***'\n   EXIT SRC\nEND\n\"FREE FILE(NWDD)\"\n\n/*     */\nMAIN_ROUTINE:\nCALL GET_JOURNAL_PARMS\nCALL READ_JOURNAL_DATASET\nCALL WRITE_JOURNAL_DATASET\nEXIT 0\n\n/*     S U B R O U T I N E S   S E C T I O N     */\n/*     */\nGET_JOURNAL_PARMS:\n\"ALLOC DA('\"JOURPDS\"(\"JRNALMEM\")') FILE(NWDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('JOURPDS'('JRNALMEM'). ***'\n   SAY '*** NWRSTLOG EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\n\"EXECIO * DISKR NWDD (FINIS STEM PARM.\"\nSRC = RC\n\"FREE FILE(NWDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** EXECIO READ ERROR: ('JOURPDS'('JRNALMEM'). ***'\n   SAY '*** NWRSTLOG EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nSERVER = STRIP(PARM.1)\nRESTVOL = STRIP(PARM.2)\nRESTDSN = STRIP(PARM.3)\nRESTDPN = STRIP(PARM.4)\nRESTFN = STRIP(PARM.5)\nRETURN\n\n/*     */\nREAD_JOURNAL_DATASET:\n\"ALLOC DA('\"JOURLIB\"') FILE(NWDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('JOURLIB'). ***'\n   SAY '*** NWRSTLOG EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\n\"EXECIO * DISKR NWDD (FINIS STEM DATA.\"\nSRC = RC\n\"FREE FILE(NWDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** EXECIO READ ERROR: ('JOURLIB'). ***'\n   SAY '*** NWRSTLOG EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nRETURN\n\n/*     */\nWRITE_JOURNAL_DATASET:\n\"DELSTACK\"\nDO I = 1 TO DATA.0\n   QUEUE DATA.I\nEND\nRESTVOL = LEFT(RESTVOL,6)\nRESTDSN = LEFT(RESTDSN,44)\nRESTDPN = LEFT(RESTDPN,50)\nRECORD = CDATE CTIME TSOID SERVER RESTVOL RESTDSN RESTDPN RESTFN\nQUEUE RECORD\n\"ALLOC DA('\"JOURLIB\"') FILE(NWDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('JOURLIB'). ***'\n   SAY '*** NWRSTLOG EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nNUMRCDS = QUEUED()\n\"EXECIO\" NUMRCDS \"DISKW NWDD (FINIS\"\nSRC = RC\n\"FREE FILE(NWDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** WRITE ERROR: ERROR WRITING DSN ('JOURLIB'). ***'\n   SAY '*** NWRSTLOG EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ODASDB": {"ttr": 17416, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x934\\x9f\\x00\\x934\\x9f\\x13\\x01\\x02\\x86\\x02\\x86\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf7@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-12-15T00:00:00", "modifydate": "1993-12-15T13:01:00", "lines": 646, "newlines": 646, "modlines": 0, "user": "TECH107"}, "text": "/* REXX DASD BUILD ANALYSIS */\nTRUE = \"1\";\nFALSE = \"0\";\nSUMMCTR=1;\nDASD.0885 = \"3380DJ\";\nDASD.1770 = \"3380E\";\nDASD.2655 = \"3380K\";\nDASD.2226 = \"33902\";\nDASD.3339 = \"33903\";\nDASD.6678 = \"33906\";\nCDRS.3380DJ = \"100 11F 200 21F\";\nCDRS.3380E  = \"480 49F\";\nCDRS.3380K  = \"C40 C5F F00 F00\";\nCDRS.33902  = \"3C0 3FF FC0 FFF\";\nCDRS.33903  = \"EC0 EFF 1C0 1FF\";\nCDRS.33906  = \"F00 F00\"; /* F00 IS END INDICATOR */\nCLASSLIST=\"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\nABRPOOLS=\"ACIC APPL ART CICS DB2 EMC MNT MVS PLAN \" || ,\n  \"POS QA RAMI SEQ SMSC SMS SYSDA SYSTA SYS TSO UART USER VSAM\";\nABRPOOLSR=\"SYS CICS EMC DB2 SMS VSAM ART ACIC UART APPL MVS PLAN \" || ,\n  \"POS QA RAMI SEQ SMSC TSO USER MNT SYSDA SYSTA\";\nTEMP = \"\";\nDO I = 1 TO WORDS(CDRS.3380DJ) BY 2;\n  LLIM = X2D(WORD(CDRS.3380DJ,I));\n  HLIM = X2D(WORD(CDRS.3380DJ,I+1));\n     DO J = LLIM TO HLIM;\n        TEMP = TEMP D2X(J);\n     END;\nEND;\nCDRS.3380DJ = TEMP;\nTEMP = \"\";\nDO I = 1 TO WORDS(CDRS.3380E) BY 2;\n  LLIM = X2D(WORD(CDRS.3380E,I));\n  HLIM = X2D(WORD(CDRS.3380E,I+1));\n     DO J = LLIM TO HLIM;\n        TEMP = TEMP D2X(J);\n     END;\nEND;\nCDRS.3380E = TEMP;\nTEMP = \"\";\nDO I = 1 TO WORDS(CDRS.3380K) BY 2;\n  LLIM = X2D(WORD(CDRS.3380K,I));\n  HLIM = X2D(WORD(CDRS.3380K,I+1));\n     DO J = LLIM TO HLIM;\n        TEMP = TEMP D2X(J);\n     END;\nEND;\nCDRS.3380K = TEMP;\nTEMP = \"\";\nDO I = 1 TO WORDS(CDRS.33902) BY 2;\n  LLIM = X2D(WORD(CDRS.33902,I));\n  HLIM = X2D(WORD(CDRS.33902,I+1));\n     DO J = LLIM TO HLIM;\n        TEMP = TEMP D2X(J);\n     END;\nEND;\nCDRS.33902 = TEMP;\nTEMP = \"\";\nDO I = 1 TO WORDS(CDRS.33903) BY 2;\n  LLIM = X2D(WORD(CDRS.33903,I));\n  HLIM = X2D(WORD(CDRS.33903,I+1));\n     DO J = LLIM TO HLIM;\n        TEMP = TEMP D2X(J);\n     END;\nEND;\nCDRS.33903 = TEMP;\nTEMP = \"\";\nDO I = 1 TO WORDS(CDRS.33906) BY 2;\n  LLIM = X2D(WORD(CDRS.33906,I));\n  HLIM = X2D(WORD(CDRS.33906,I+1));\n     DO J = LLIM TO HLIM;\n        TEMP = TEMP D2X(J);\n     END;\nEND;\nCDRS.33906 = TEMP;\nINIT_REST_UNIT = WORD(CDRS.33902,1);\nCDRS.33902 = DELWORD(CDRS.33902,1,1);\n\"CALL 'SYS1.TECH.COMMON.LOADLIB(DASDSCAN)'\";\n/* \"CALL 'TECH110.USER.LOADLIB(DASDSCAN)'\"; */\nSAVERC=RC;\nIF SAVERC\u00ac=0 THEN EXIT SAVERC;\n\"EXECIO * DISKR WORK (FINIS STEM DASDV.\";\nCHANGES = TRUE;\nDO WHILE(CHANGES); /* BUBBLE SORT DESCENDING BY FRAG INDEX */\n     CHANGES = FALSE;\n     DO I = 1 TO DASDV.0-1;\n          J = I+1;\n          PARSE VAR DASDV.I . . . FRAGINDEX1 . ;\n          PARSE VAR DASDV.J . . . FRAGINDEX2 . ;\n          IF FRAGINDEX1 < FRAGINDEX2 THEN DO;\n                 TEMP = DASDV.I;\n                 DASDV.I = DASDV.J;\n                 DASDV.J = TEMP;\n                 CHANGES = TRUE;\n                 END;\n     END;\nEND;\nDO I = 1 TO DASDV.0;\n  PARSE VAR DASDV.I VOLSER CYLCOUNT FREECYL FRAGINDEX . ;\n  ABR_BACKUP_DSN = \"'FDRABR.V\"VOLSER\"'\";\n  DUMMY = LISTDSI(ABR_BACKUP_DSN); /* SEE IF DATASET EXISTS */\n  IF DUMMY\u00ac=0 THEN DO;\n       DASDV.I = \"DUMMY\"; /* IGNORE THIS VOLUME */\n       ITERATE I; /* LOOP */\n       END;\n  POOLCTR=WORDS(ABRPOOLS);\n  DO J=1 TO POOLCTR;\n     POOL=WORD(ABRPOOLS,J);\n     IF ABBREV(VOLSER,POOL) THEN DO;\n           IF SYMBOL('POOLLIST.POOL')=\"VAR\" THEN ,\n               POOLLIST.POOL=POOLLIST.POOL VOLSER;\n            ELSE POOLLIST.POOL=VOLSER;\n          LEAVE J;\n         END;\n  END;\nEND;\nABRPOOLS = ABRPOOLSR; /* REORG LIST FOR ORDER TO PROCESS IN */\nDO J=1 TO POOLCTR;\n     POOL=WORD(ABRPOOLS,J);\n     VOLCNT=WORDS(POOLLIST.POOL);\n     JOBC=SUBSTR(CLASSLIST,J,1);\nSUMM.SUMMCTR=\"****** POOL\" LEFT(POOL,7) \"RESTORE JOBCLASS:\" JOBC ,\n        \"VOLCNT:\" VOLCNT;\n     SUMMCTR=SUMMCTR+1;\nEND;\nJCLZ1.0 = 6; /* COUNT OF DUMP JOB STATEMENTS */\nJCLZ1.1 = \"//LOAD1 EXEC PGM=IKJEFT01,DYNAMNBR=32,PARM='%DB2TIACK'\";\nJCLZ1.2 = \"//SYSTSPRT DD SYSOUT=*\";\nJCLZ1.3 = \"//SYSPRINT DD SYSOUT=*\";\nJCLZ1.4 = \"//SYSTSIN DD DUMMY\";\nJCLZ1.5 = \"//SYSPROC DD DSN=SYSS.TECH.COMMON.EXECLIB,DISP=SHR\";\nJCLZ1.6 = \"//SYSIN DD *\";\nJCLZ1.7 =\" INSERT INTO BUILD.TABRVOLS (VOLSER,DUMP_TYPE,DUMP_STATUS)\";\nJCLZ1.8= \"    VALUES('XXXXXX','INCRVOL','ACTIVE');\";\nJCLZ1.9= \" COMMIT;\";\nJCLZ1.10 = \" DELETE FROM BUILD.TABRVOLS WHERE VOLSER='XXXXXX' AND \";\nJCLZ1.11 = \" DUMP_STATUS='PENDING' AND DUMP_TYPE='INCRVOL';\";\nJCLZ1.12= \" COMMIT;\";\nJCLZ1.13= \"/*\";\nJCLZ2.0 = 7; /* COUNT OF DUMP JOB STATEMENTS */\nJCLZ2.1 = \"// IF (RC<=4 & \u00acABEND) THEN\";\nJCLZ2.2 = \"//LOAD2 EXEC PGM=IKJEFT01,DYNAMNBR=32,PARM='%DB2TIACK'\";\nJCLZ2.3 = \"//SYSTSPRT DD SYSOUT=*\";\nJCLZ2.4 = \"//SYSPRINT DD SYSOUT=*\";\nJCLZ2.5 = \"//SYSTSIN DD DUMMY\";\nJCLZ2.6 = \"//SYSPROC DD DSN=SYSS.TECH.COMMON.EXECLIB,DISP=SHR\";\nJCLZ2.7 = \"//SYSIN DD *\";\nJCLZ2.8 = \" UPDATE BUILD.TABRVOLS SET DUMP_STATUS='COMPLETE'\";\nJCLZ2.9 = \"    WHERE VOLSER='XXXXXX' AND DUMP_TYPE='INCRVOL';\";\nJCLZ2.10= \" COMMIT;\";\nJCLZ2.11= \"/*\";\nJCLZ2.12= \"// ENDIF\";\nJCLZ3.0 = 7; /* COUNT OF DUMP JOB STATEMENTS */\nJCLZ3.1 = \"// IF (RC>4 | ABEND) THEN\";\nJCLZ3.2 = \"//LOAD3 EXEC PGM=IKJEFT01,DYNAMNBR=32,PARM='%DB2TIACK'\";\nJCLZ3.3 = \"//SYSTSPRT DD SYSOUT=*\";\nJCLZ3.4 = \"//SYSPRINT DD SYSOUT=*\";\nJCLZ3.5 = \"//SYSTSIN DD DUMMY\";\nJCLZ3.6 = \"//SYSPROC DD DSN=SYSS.TECH.COMMON.EXECLIB,DISP=SHR\";\nJCLZ3.7 = \"//SYSIN DD *\";\nJCLZ3.8 = \" UPDATE BUILD.TABRVOLS SET DUMP_STATUS='FAILURE'\";\nJCLZ3.9 = \"    WHERE VOLSER='XXXXXX' AND DUMP_TYPE='INCRVOL' AND\";\nJCLZ3.10 = \"     DUMP_STATUS='ACTIVE';\";\nJCLZ3.11= \" COMMIT;\";\nJCLZ3.12= \"/*\";\nJCLZ3.13= \"// ENDIF\";\nJCLD.0 = 63; /* COUNT OF DUMP JOB STATEMENTS */\nJCLD.1 = \"//D$XXXXXX JOB 530401053000,'SYSTEM.BACKUP',\";\nJCLD.2 = \"// NOTIFY=TECH251,CLASS=S,MSGCLASS=G\";\nJCLD.3 = \"//LOAD1 EXEC PGM=IKJEFT01,DYNAMNBR=32,PARM='%DB2TIACK'\";\nJCLD.4 = \"//SYSTSPRT DD SYSOUT=*\";\nJCLD.5 = \"//SYSPRINT DD SYSOUT=*\";\nJCLD.6 = \"//SYSTSIN DD DUMMY\";\nJCLD.7 = \"//SYSPROC DD DSN=SYSS.TECH.COMMON.EXECLIB,DISP=SHR\";\nJCLD.8 = \"//SYSIN DD *\";\nJCLD.9 = \" DELETE FROM BUILD.TABRVOLS WHERE VOLSER='XXXXXX' AND \";\nJCLD.10 = \" DUMP_STATUS='PENDING' AND DUMP_TYPE='FULLVOL';\";\nJCLD.11 = \" COMMIT;\";\nJCLD.12 = \" INSERT INTO BUILD.TABRVOLS (VOLSER,DUMP_TYPE,DUMP_STATUS)\";\nJCLD.13 = \"    VALUES('XXXXXX','FULLVOL','ACTIVE');\";\nJCLD.14 = \"//DUMPIT EXEC PGM=FDRABR,REGION=9M\";\nJCLD.15 = \"//SYSPRINT DD SYSOUT=*\";\nJCLD.16 = \"//SYSPRIN1 DD SYSOUT=*\";\nJCLD.17 = \"//DISK1 DD UNIT=XXXX,\";\nJCLD.18 = \"// DISP=SHR,\";\nJCLD.19 = \"// VOL=SER=XXXXXX\";\nJCLD.20=\"//TAPE1 DD DSN=FXXXXXX,DISP=(,KEEP),UNIT=TA80,VOL=(,,,255)\";\nJCLD.21 = \"//SYSUDUMP DD SYSOUT=X\";\nJCLD.22 = \"//SYSIN DD *\";\nJCLD.23 = \" DUMP TYPE=FDR,\";\nJCLD.24 = \"  AUTOUPD=YES,\";\nJCLD.25 = \"  BUFNO=MAX,\";\nJCLD.26 = \"  COMPRESS=ALL,\";\nJCLD.27 = \"  DATA=ALL,\";\nJCLD.28 = \"  DATEP=NONE,\";\nJCLD.29 = \"  DSNENQ=TEST,\";\nJCLD.30 = \"  ENQ=RESERVE,\";\nJCLD.31 = \"  ENQERR=NO,\";\nJCLD.32 = \"  ENQERR=PROCESS,\";\nJCLD.33 = \"  FORMAT=NEW,\";\nJCLD.34 = \"  LBPZERO=INVALID,\";\nJCLD.35 = \"  MAXERR=1,\";\nJCLD.36 = \"  PRINT=ABR,\";\nJCLD.37 = \"  RETPD=9999,\";\nJCLD.38 = \"  SMSCONSTRUCT=NO,\";\nJCLD.39 = \"  SMSMANAGE=NO\";\nJCLD.40 = \"/*\";\nJCLD.41 = \"// IF (RC<=4 & \u00acABEND) THEN\";\nJCLD.42 = \"//LOAD2 EXEC PGM=IKJEFT01,DYNAMNBR=32,PARM='%DB2TIACK'\";\nJCLD.43 = \"//SYSTSPRT DD SYSOUT=*\";\nJCLD.44 = \"//SYSPRINT DD SYSOUT=*\";\nJCLD.45 = \"//SYSTSIN DD DUMMY\";\nJCLD.46 = \"//SYSPROC DD DSN=SYSS.TECH.COMMON.EXECLIB,DISP=SHR\";\nJCLD.47 = \"//SYSIN DD *\";\nJCLD.48 = \" UPDATE BUILD.TABRVOLS SET DUMP_STATUS='COMPLETE'\";\nJCLD.49 = \"    WHERE VOLSER='XXXXXX' AND DUMP_TYPE='FULLVOL';\";\nJCLD.50 = \"/*\";\nJCLD.51 = \"// ENDIF\";\nJCLD.52 = \"// IF (RC>4 | ABEND) THEN\";\nJCLD.53 = \"//LOAD3 EXEC PGM=IKJEFT01,DYNAMNBR=32,PARM='%DB2TIACK'\";\nJCLD.54 = \"//SYSTSPRT DD SYSOUT=*\";\nJCLD.55 = \"//SYSPRINT DD SYSOUT=*\";\nJCLD.56 = \"//SYSTSIN DD DUMMY\";\nJCLD.57 = \"//SYSPROC DD DSN=SYSS.TECH.COMMON.EXECLIB,DISP=SHR\";\nJCLD.58 = \"//SYSIN DD *\";\nJCLD.59 = \" UPDATE BUILD.TABRVOLS SET DUMP_STATUS='FAILURE'\";\nJCLD.60 = \"    WHERE VOLSER='XXXXXX' AND DUMP_TYPE='FULLVOL';\";\nJCLD.61 = \"/*\";\nJCLD.62 = \"// ENDIF\";\nJCLD.63 = \"//\";\nJCLX.0 = 30; /* COUNT OF INCR JOB STATEMENTS */\nJCLX.1 = \"//I$XXXX JOB 530401053000,'SYSTEM.BACKUP',\";\nJCLX.2 = \"// NOTIFY=TECH251,\";\nJCLX.3 = \"// CLASS=S,MSGCLASS=G\";\nJCLX.4 = \"//DUMPIT EXEC PGM=FDRABR,REGION=9M\";\nJCLX.5 = \"//SYSPRIN1 DD SYSOUT=*\";\nJCLX.6 = \"//SYSPRIN2 DD SYSOUT=*\";\nJCLX.7 = \"//SYSPRIN3 DD SYSOUT=*\";\nJCLX.8=\"//TAPE1 DD DSN=I1XXXX,DISP=(,KEEP),UNIT=TA80,VOL=(,,,255)\";\nJCLX.9=\"//TAPE2 DD DSN=I2XXXX,DISP=(,KEEP),UNIT=TA80,VOL=(,,,255)\";\nJCLX.10=\"//TAPE3 DD DSN=I3XXXX,DISP=(,KEEP),UNIT=TA80,VOL=(,,,255)\";\nJCLX.11= \"//SYSPRINT DD SYSOUT=*\";\nJCLX.12 = \"//SYSUDUMP DD SYSOUT=X\";\nJCLX.13 = \"//SYSIN DD *\";\nJCLX.14 = \" DUMP TYPE=ABR,\";\nJCLX.15 = \"  AUTOUPD=YES,\";\nJCLX.16 = \"  BUFNO=MAX,\";\nJCLX.17 = \"  COMPRESS=ALL,\";\nJCLX.18 = \"  DATA=USED,\";\nJCLX.19 = \"  DATEP=NONE,\";\nJCLX.20 = \"  DSNENQ=TEST,\";\nJCLX.21 = \"  ENQ=RESERVE,\";\nJCLX.22 = \"  ENQERR=NO,\";\nJCLX.23 = \"  ENQERR=PROCESS,\";\nJCLX.24 = \"  FORMAT=NEW,\";\nJCLX.25 = \"  LBPZERO=INVALID,\";\nJCLX.26 = \"  MAXERR=1,\";\nJCLX.27 = \"  PRINT=ABR,\";\nJCLX.28 = \"  RETPD=9999,\";\nJCLX.29 = \"  SMSCONSTRUCT=NO,\";\nJCLX.30 = \"  SMSMANAGE=NO\";\nJCLR.0 = 47; /* COUNT OF RESTORE JOB STATEMENTS */\nJCLR.1 = \"//R$XXXXXX JOB 530401053000,'TECH SUPPRT',\";\nJCLR.2 = \"// CLASS=?,MSGCLASS=X,MSGLEVEL=(1,1),REGION=6M\";\nJCLR.3 = \"//JOBLIB DD DSN=IMPORT.LINKLIB1,DISP=SHR\";\nJCLR.4 = \"//ACTIVE EXEC PGM=IKJEFT01,REGION=6M,\";\nJCLR.5= \"// PARM='ALTER ''FDRABR.COMDISCO.WEEKREST.VXXXXXX'' OWNER(I)'\"\nJCLR.6 = \"//SYSTSPRT DD SYSOUT=*\";\nJCLR.7 = \"//SYSTSIN DD DUMMY\";\nJCLR.8 = \"//*\";\nJCLR.9 = \"//*\";\nJCLR.10 = \"//*\";\nJCLR.11 = \"//*\";\nJCLR.12 = \"//*\";\nJCLR.13 = \"//RESTIT EXEC PGM=FDRABR,REGION=6M\";\nJCLR.14 = \"//SYSPRINT DD SYSOUT=*\";\nJCLR.15 = \"//ABRWORK  DD UNIT=SYSALLDA,SPACE=(CYL,(2,1))\";\nJCLR.16 = \"//DISK1 DD UNIT=XXXX,VOL=SER=XXXXXX,DISP=OLD\";\nJCLR.17 = \"//SYSIN DD *\";\nJCLR.18 = \" RESTORE TYPE=FDR,\";\nJCLR.19 = \"   CONFMESS=NO,\";\nJCLR.20 = \"   COPY=1,\";\nJCLR.21 = \"  CPYVOLID=YES,\";\nJCLR.22 = \"  DYNTAPE,\";\nJCLR.23 = \"  MAXERR=1,\";\nJCLR.24 = \"  SMSPROT=NONE,\";\nJCLR.25 = \"  VOLRESET=NO\";\nJCLR.26 = \" SELECT  VOL=XXXXXX,GEN=CURRENT\";\nJCLR.27 = \"/*\";\nJCLR.28 = \"//IXITIT EXEC PGM=ICKDSF,REGION=6M\";\nJCLR.29 = \"//SYSPRINT DD SYSOUT=*\";\nJCLR.30 = \"//DISK1 DD UNIT=XXXX,VOL=SER=XXXXXX,DISP=OLD\";\nJCLR.31 = \"//SYSIN DD *\";\nJCLR.32=\" BUILDIX DDNAME(DISK1) IXVTOC\";\nJCLR.33 = \"//COMPLETE EXEC PGM=IKJEFT01,COND=(0,NE,RESTIT),\";\nJCLR.34=\"// PARM='ALTER ''FDRABR.COMDISCO.WEEKREST.VXXXXXX'' OWNER(C)'\"\nJCLR.35 = \"//SYSTSPRT DD SYSOUT=*\";\nJCLR.36 = \"//SYSTSIN DD DUMMY\";\nJCLR.37 = \"//*\";\nJCLR.38 = \"//*\";\nJCLR.39 = \"//*\";\nJCLR.40 = \"//*\";\nJCLR.41 = \"//*\";\nJCLR.42 = \"//*\";\nJCLR.43 = \"//FAILURE EXEC PGM=IKJEFT01,COND=((0,GE,RESTIT),EVEN),\";\nJCLR.44=\"// PARM='ALTER ''FDRABR.COMDISCO.WEEKREST.VXXXXXX'' OWNER(F)'\"\nJCLR.45 = \"//SYSTSPRT DD SYSOUT=*\";\nJCLR.46 = \"//SYSTSIN DD DUMMY\";\nJCLR.47 = \"//\";\nJCLI.0 = 8; /* COUNT OF INIT JOB STATEMENTS */\nJCLI.1 = \"//I$XXXXXX JOB 530401053000,'TECH SUPPRT',NOTIFY=$CDRS1,\";\nJCLI.2 = \"// CLASS=A,MSGCLASS=X,MSGLEVEL=(1,1)\";\nJCLI.3 = \"//INITIT EXEC PGM=ICKDSF,REGION=6M\";\nJCLI.4 = \"//SYSPRINT DD SYSOUT=*\";\nJCLI.5 = \"//SYSIN DD *\";\nJCLI.6=\" INIT UNIT(XXX) NVFY NCHK INDEX(1,0,15) VTOC(0,1,14) -\";\nJCLI.7 = \"   NOMAP PRG NVAL VOLID(XXXXXX)\";\nJCLI.8 = \"//\";\nJCLC.0 = 7; /* COMPAKTOR */\nJCLC.1 = \"//SYSMAP1 DD SYSOUT=*\";\nJCLC.2 = \"//CPKWORK DD UNIT=VIO,SPACE=(CYL,(1,1))\";\nJCLC.3 = \"//CPIN1 DD *\";\nJCLC.4 = \" CPK TYPE=COMPAKT,ACTMESS=NO,CONFMESS=NO,\";\nJCLC.5 = \"   HI=NO,MAPS=ALL,NOSECOND=NORLSE,\";\nJCLC.6 = \"   O=MAXFREE,OVERRIDE=NO,POR=ALL,\";\nJCLC.7 = \"   T=KEEP,V=NOCHANGE,%FREE=10\";\nHEADTAIL = TRUE;\nCPKCTR = 20;\nSAY \"\";\nSAY \"****** INITIAL RESTORE 3390 UNIT:\" ,\n     INIT_REST_UNIT;\nSAY \"\";\nSUMM.SUMMCTR = \"****** INITIAL RESTORE 3390 UNIT:\" ,\n     INIT_REST_UNIT;\nSUMMCTR=SUMMCTR+1;\n/* LOOP */\nPOOLCTR=WORDS(ABRPOOLS);\nDO ZZ=1 TO POOLCTR;\nJOBC = SUBSTR(CLASSLIST,ZZ,1);\nPOOL=WORD(ABRPOOLS,ZZ);\nPOOLMEM=STRIP(SUBSTR(\"POOL\"POOL,1,8));\nDROP DUMP.;\nDROP INCR.;\nDROP REST.;\nDROP INIT.;\nDUMPCTR=1;\nINCRCTR=1;\nRESTCTR=1;\nINITCTR=1;\n\"FREE F(INIT)\";\n\"FREE F(DUMP)\";\n\"FREE F(INCR)\";\n\"FREE F(REST)\";\n\"ALLOC F(INIT) DA('SYSS.COMDISCO.INITJOBS(\"POOLMEM\")') SHR\";\nIF RC\u00ac=0 THEN EXIT 99;\nIF POOLMEM \u00ac=\"POOLSYSD\" & POOLMEM \u00ac=\"POOLSYST\" THEN DO;\n\"ALLOC F(DUMP) DA('SYSS.COMDISCO.DUMPJOBS(\"POOLMEM\")') SHR\";\nIF RC\u00ac=0 THEN EXIT 99;\nEND;\nIF POOLMEM \u00ac=\"POOLSYSD\" & POOLMEM \u00ac=\"POOLSYST\" THEN DO;\n\"ALLOC F(INCR) DA('SYSS.COMDISCO.INCRJOBS(\"POOLMEM\")') SHR\";\nIF RC\u00ac=0 THEN EXIT 99;\nEND;\nIF POOLMEM \u00ac=\"POOLSYSD\" & POOLMEM \u00ac=\"POOLSYST\" THEN DO;\n\"ALLOC F(REST) DA('SYSS.COMDISCO.RESTJOBS(\"POOLMEM\")') SHR\";\nIF RC\u00ac=0 THEN EXIT 99;\nEND;\nT1=OVERLAY(POOL,JCLX.1,POS('XXXX',JCLX.1));\nDO J = 1 TO 3;\n      IF J=1 THEN INCR.INCRCTR=T1;\n      ELSE INCR.INCRCTR=JCLX.J;\n      INCRCTR=INCRCTR+1;\nEND;\nDO J = 1 TO JCLZ1.0;\n      INCR.INCRCTR=JCLZ1.J;\n      INCRCTR=INCRCTR+1;\nEND;\nXCTR=WORDS(POOLLIST.POOL);\nTRUEVOLC=0;\nDO I = 1 TO XCTR;\n  XVOL=WORD(POOLLIST.POOL,I);\n  TEMP_PACK1 = SUBSTR(XVOL,1,5);\n  TEMP_PACK2 = SUBSTR(XVOL,1,3);\n  IF TEMP_PACK1=\"SYSDA\" | TEMP_PACK1=\"SYSTA\" | TEMP_PACK2=\"DRV\" ,\n     | TEMP_PACK2=\"TEM\" | TEMP_PACK2=\"LAN\" THEN ITERATE;\n  IF XVOL=\"SYS015\" | XVOL=\"SYS007\" | XVOL=\"SYS008\" | XVOL=\"SYS011\" | ,\n     XVOL=\"SYS012\" | XVOL=\"SYS013\" | XVOL=\"SYS014\" THEN ITERATE;\n  INCR.INCRCTR=JCLZ1.7;\n  INCRCTR=INCRCTR+1;\n  INCR.INCRCTR=OVERLAY(XVOL,JCLZ1.8,POS('XXXXXX',JCLZ1.8));\n  INCRCTR=INCRCTR+1;\n  INCR.INCRCTR=JCLZ1.9;\n  INCRCTR=INCRCTR+1;\n  INCR.INCRCTR=OVERLAY(XVOL,JCLZ1.10,POS('XXXXXX',JCLZ1.10));\n  INCRCTR=INCRCTR+1;\n  INCR.INCRCTR=JCLZ1.11;\n  INCRCTR=INCRCTR+1;\n  INCR.INCRCTR=JCLZ1.12;\n  INCRCTR=INCRCTR+1;\n  TRUEVOLC=TRUEVOLC+1;\nEND;\nINCR.INCRCTR=JCLZ1.13;\nINCRCTR=INCRCTR+1;\nT2=OVERLAY(POOL,JCLX.8,POS('XXXX',JCLX.8));\nT3=OVERLAY(POOL,JCLX.9,POS('XXXX',JCLX.9));\nT4=OVERLAY(POOL,JCLX.10,POS('XXXX',JCLX.10));\nDO J = 4 TO JCLX.0;\n      IF J=8 THEN INCR.INCRCTR=T2;\n      ELSE IF J=9 THEN INCR.INCRCTR=T3;\n      ELSE IF J=10 THEN INCR.INCRCTR=T4;\n      ELSE INCR.INCRCTR=JCLX.J;\n      /* TAPE CTR BY VOL CNT LOGIC */\n/*    IF TRUEVOLC>=9 & J=17 THEN ITERATE J;   */\n      IF TRUEVOLC>=9 THEN NOP;\n      ELSE IF TRUEVOLC>=4 & ,\n          (J=7 | J=10) THEN ITERATE J;\n      ELSE IF TRUEVOLC<4 & ,\n          (J=7 | J=10 | J=6 | J=9) THEN ITERATE J;\n      INCRCTR=INCRCTR+1;\n      IF TRUEVOLC>=9 & J=7 THEN DO;\n         INCR.INCRCTR=\"//SYSPRIN4 DD SYSOUT=*\";\n         INCRCTR=INCRCTR+1;\n/*       INCR.INCRCTR=\"//SYSPRIN5 DD SYSOUT=*\";\n         INCRCTR=INCRCTR+1;\n         INCR.INCRCTR=\"//SYSPRIN6 DD SYSOUT=*\";\n         INCRCTR=INCRCTR+1;    */\n      END;\n      IF TRUEVOLC>=9 & J=10 THEN DO;\n      POOLX = LEFT(POOL,4,\"X\"); /* FILL OUT */\nINCR.INCRCTR= ,\n \"//TAPE4 DD DSN=I4\"POOLX\",DISP=(,KEEP),UNIT=TA80,VOL=(,,,255)\"\n         INCRCTR=INCRCTR+1;\n/* INCR.INCRCTR= ,\n \"//TAPE5 DD DSN=I5\"POOLX\",DISP=(,KEEP),UNIT=TA80,VOL=(,,,255)\"\n         INCRCTR=INCRCTR+1;\nINCR.INCRCTR= ,\n \"//TAPE6 DD DSN=I6\"POOLX\",DISP=(,KEEP),UNIT=TA80,VOL=(,,,255)\"\n         INCRCTR=INCRCTR+1;     */\n      END;\nEND;\nXCTR=WORDS(POOLLIST.POOL);\nDO I = 1 TO XCTR;\n  XVOL=WORD(POOLLIST.POOL,I);\n  TEMP_PACK1 = SUBSTR(XVOL,1,5);\n  TEMP_PACK2 = SUBSTR(XVOL,1,3);\n  IF TEMP_PACK1=\"SYSDA\" | TEMP_PACK1=\"SYSTA\" | TEMP_PACK2=\"DRV\" ,\n     | TEMP_PACK2=\"TEM\" | TEMP_PACK2=\"LAN\" THEN ITERATE;\n  /* SKIP SOME INCR */\n  IF XVOL=\"SYS015\" | XVOL=\"SYS007\" | XVOL=\"SYS008\" | XVOL=\"SYS011\" | ,\n     XVOL=\"SYS012\" | XVOL=\"SYS013\" | XVOL=\"SYS014\" THEN ITERATE;\n  INCR.INCRCTR=\" MOUNT VOL=\"XVOL;\n  INCRCTR=INCRCTR+1;\nEND;\nDO J = 1 TO JCLZ2.0;\n      INCR.INCRCTR=JCLZ2.J;\n      INCRCTR=INCRCTR+1;\nEND;\nXCTR=WORDS(POOLLIST.POOL);\nDO I = 1 TO XCTR;\n  XVOL=WORD(POOLLIST.POOL,I);\n  TEMP_PACK1 = SUBSTR(XVOL,1,5);\n  TEMP_PACK2 = SUBSTR(XVOL,1,3);\n  IF TEMP_PACK1=\"SYSDA\" | TEMP_PACK1=\"SYSTA\" | TEMP_PACK2=\"DRV\" ,\n     | TEMP_PACK2=\"TEM\" | TEMP_PACK2=\"LAN\" THEN ITERATE;\n  IF XVOL=\"SYS015\" | XVOL=\"SYS007\" | XVOL=\"SYS008\" | XVOL=\"SYS011\" | ,\n     XVOL=\"SYS012\" | XVOL=\"SYS013\" | XVOL=\"SYS014\" THEN ITERATE;\n  INCR.INCRCTR=JCLZ2.8;\n  INCRCTR=INCRCTR+1;\n  INCR.INCRCTR=OVERLAY(XVOL,JCLZ2.9,POS('XXXXXX',JCLZ2.9));\n  INCRCTR=INCRCTR+1;\n  INCR.INCRCTR=JCLZ2.10;\n  INCRCTR=INCRCTR+1;\nEND;\nINCR.INCRCTR=JCLZ2.11;\nINCRCTR=INCRCTR+1;\nINCR.INCRCTR=JCLZ2.12;\nINCRCTR=INCRCTR+1;\nDO J = 1 TO JCLZ3.0;\n      INCR.INCRCTR=JCLZ3.J;\n      INCRCTR=INCRCTR+1;\nEND;\nXCTR=WORDS(POOLLIST.POOL);\nDO I = 1 TO XCTR;\n  XVOL=WORD(POOLLIST.POOL,I);\n  TEMP_PACK1 = SUBSTR(XVOL,1,5);\n  TEMP_PACK2 = SUBSTR(XVOL,1,3);\n  IF TEMP_PACK1=\"SYSDA\" | TEMP_PACK1=\"SYSTA\" | TEMP_PACK2=\"DRV\" ,\n     | TEMP_PACK2=\"TEM\" | TEMP_PACK2=\"LAN\" THEN ITERATE;\n  IF XVOL=\"SYS015\" | XVOL=\"SYS007\" | XVOL=\"SYS008\" | XVOL=\"SYS011\" | ,\n     XVOL=\"SYS012\" | XVOL=\"SYS013\" | XVOL=\"SYS014\" THEN ITERATE;\n  INCR.INCRCTR=JCLZ3.8;\n  INCRCTR=INCRCTR+1;\n  INCR.INCRCTR=OVERLAY(XVOL,JCLZ3.9,POS('XXXXXX',JCLZ3.9));\n  INCRCTR=INCRCTR+1;\n  INCR.INCRCTR=JCLZ3.10;\n  INCRCTR=INCRCTR+1;\n  INCR.INCRCTR=JCLZ3.11;\n  INCRCTR=INCRCTR+1;\nEND;\nINCR.INCRCTR=JCLZ3.12;\nINCRCTR=INCRCTR+1;\nINCR.INCRCTR=JCLZ3.13;\nINCRCTR=INCRCTR+1;\nINCR.INCRCTR=\"//\";\nINCRCTR=INCRCTR+1;\n DO I = 1 TO DASDV.0;\n  CPK=FALSE;\n  PARSE VAR DASDV.I VOLSER CYLCOUNT FREECYL FRAGINDEX . ;\n  IF VOLSER=\"DUMMY\" THEN ITERATE;\n  IF WORDPOS(VOLSER,POOLLIST.POOL)=0 THEN ITERATE;/*DIFFERENT POOL*/\n  DEVTYPE = DASD.CYLCOUNT;\n  TRUE_DEVTYPE = DASD.CYLCOUNT;\n  IF HEADTAIL THEN DO;\n         HEADTAIL = FALSE; /* ROTATE CUU SELECTION */\n         UNIT = WORD(CDRS.DEVTYPE,1);\n         CDRS.DEVTYPE = DELWORD(CDRS.DEVTYPE,1,1);\n         END;\n  ELSE DO;\n         HEADTAIL = TRUE;  /* ROTATE CUU SELECTION */\n         IF WORDS(CDRS.DEVTYPE)=0 THEN ,\n              UNIT=\"\";\n         ELSE DO;\n           UNIT = WORD(CDRS.DEVTYPE,WORDS(CDRS.DEVTYPE));\n           IF UNIT\u00ac=\"F00\" THEN ,\n           CDRS.DEVTYPE = DELWORD(CDRS.DEVTYPE,WORDS(CDRS.DEVTYPE),1);\n           END;\n         END;\n  TARGET_TYPE=DEVTYPE;\n  IF UNIT=\"\" THEN DO; /* COMDISCO HAS NO MORE */\n       SELECT;\n         WHEN (DEVTYPE=\"3380DJ\") THEN TARGET_TYPE=\"3380E\";\n         WHEN (DEVTYPE=\"3380E\") THEN TARGET_TYPE=\"3380K\";\n         WHEN (DEVTYPE=\"3380K\") THEN EXIT 16; /* EMERGENCY */\n         WHEN (DEVTYPE=\"33902\") THEN TARGET_TYPE=\"33903\";\n         WHEN (DEVTYPE=\"33903\") THEN TARGET_TYPE=\"33906\";\n         WHEN (DEVTYPE=\"33906\") THEN EXIT 20; /* EMERGENCY */\n         OTHERWISE EXIT 24;\n       END;\n       IF TARGET_TYPE=\"3380E\" & WORDS(CDRS.3380E)=0 THEN ,\n            TARGET_TYPE=\"3380K\";\n       IF WORDS(CDRS.TARGET_TYPE)=0 THEN EXIT 28;\n       UNIT = WORD(CDRS.TARGET_TYPE,1);\n       IF UNIT\u00ac=\"F00\" THEN ,\n       CDRS.TARGET_TYPE = DELWORD(CDRS.TARGET_TYPE,1,1);\n       END;\n  DEVTYPE = SUBSTR(DEVTYPE,1,4);\n  TEMP_PACK1 = SUBSTR(VOLSER,1,5);\n  TEMP_PACK2 = SUBSTR(VOLSER,1,3);\n  IF TEMP_PACK1\u00ac=\"SYSDA\" & TEMP_PACK1\u00ac=\"SYSTA\" & TEMP_PACK2\u00ac=\"DRV\" ,\n     & TEMP_PACK2\u00ac=\"TEM\" & TEMP_PACK2\u00ac=\"LAN\" ,\n       THEN DO;\n  T1=OVERLAY(DEVTYPE,JCLD.17,POS('XXXX',JCLD.17));\n  T2=OVERLAY(VOLSER,JCLD.19,POS('XXXXXX',JCLD.19));\n  T3=OVERLAY(VOLSER,JCLD.1,POS('XXXXXX',JCLD.1));\n  T4=OVERLAY(VOLSER,JCLD.20,POS('XXXXXX',JCLD.20));\n  T5=OVERLAY(VOLSER,JCLD.9,POS('XXXXXX',JCLD.9));\n  T7=OVERLAY(VOLSER,JCLD.13,POS('XXXXXX',JCLD.13));\n  T8=OVERLAY(VOLSER,JCLD.49,POS('XXXXXX',JCLD.49));\n  T9=OVERLAY(VOLSER,JCLD.60,POS('XXXXXX',JCLD.60));\n  CDSR= \"'FDRABR.COMDISCO.WEEKREST.V\"VOLSER\"'\";\n  \"ALTER\" CDSR \"OWNER(N)\"; /* NOT ACTIVE */\n  IF RC > 0 THEN ,\n    \"DEFINE NVSAM (NAME(\"CDSR\") DEVT(0000) VOL('******') OWNER(N))\";\n  DO J = 1 TO JCLD.0;\n      IF J=17 THEN DUMP.DUMPCTR=T1;\n      ELSE IF J=19 THEN DUMP.DUMPCTR=T2;\n      ELSE IF J=1 THEN DUMP.DUMPCTR=T3;\n      ELSE IF J=20 THEN DUMP.DUMPCTR=T4;\n      ELSE IF J=9 THEN DUMP.DUMPCTR=T5;\n      ELSE IF J=13 THEN DUMP.DUMPCTR=T7;\n      ELSE IF J=49 THEN DUMP.DUMPCTR=T8;\n      ELSE IF J=60 THEN DUMP.DUMPCTR=T9;\n      ELSE IF J=30 & VOLSER=\"SYS015\" THEN ,\n         DUMP.DUMPCTR=\"  ENQ=OFF,\";\n      ELSE DUMP.DUMPCTR=JCLD.J;\n      IF J=23 & I<=CPKCTR & SUBSTR(VOLSER,1,3)\u00ac=\"MNT\" & ,\n        SUBSTR(VOLSER,1,3)\u00ac=\"SYS\" THEN DO;  /* CANT COMPKT SYS */\n          CPK=TRUE;\n          DUMP.DUMPCTR=DUMP.DUMPCTR||\"COMPAKT,\";\n          END;\n       ELSE IF J=23 THEN CPK=FALSE;\n       ELSE NOP;\n      IF (J=29) & (CPK) THEN DO;\n          DUMP.DUMPCTR=\"  DSNENQ=USE,\";\n          END;\n      DUMPCTR=DUMPCTR+1;\n      IF (J=39) & (CPK) THEN DO;\n           DO Z=1 TO JCLC.0;\n                DUMP.DUMPCTR=JCLC.Z;\n                DUMPCTR=DUMPCTR+1;\n           END;\n         END;\n  END;\n  T1=OVERLAY(DEVTYPE,JCLR.16,POS('XXXX',JCLR.16));\n  T1=OVERLAY(VOLSER,T1,POS('XXXXXX',T1));\n  T2=OVERLAY(VOLSER,JCLR.26,POS('XXXXXX',JCLR.26));\n  T3=OVERLAY(VOLSER,JCLR.1,POS('XXXXXX',JCLR.1));\n  T4=OVERLAY(VOLSER,JCLR.5,POS('XXXXXX',JCLR.5));\n  T5=OVERLAY(VOLSER,JCLR.34,POS('XXXXXX',JCLR.34));\n  T6=OVERLAY(VOLSER,JCLR.44,POS('XXXXXX',JCLR.44));\n  T7=OVERLAY(JOBC,JCLR.2,POS('?',JCLR.2));\n  DO J = 1 TO JCLR.0;\n      IF J=16 THEN REST.RESTCTR=T1;\n      ELSE IF J=26 THEN REST.RESTCTR=T2;\n      ELSE IF J=30 THEN REST.RESTCTR=T1;\n      ELSE IF J=34 THEN REST.RESTCTR=T5;\n      ELSE IF J=44 THEN REST.RESTCTR=T6;\n      ELSE IF J=5 THEN REST.RESTCTR=T4;\n      ELSE IF J=1 THEN REST.RESTCTR=T3;\n      ELSE IF J=2 THEN REST.RESTCTR=T7;\n      ELSE REST.RESTCTR=JCLR.J;\n      RESTCTR=RESTCTR+1;\n  END;\n  END;\n  T1=OVERLAY(UNIT,JCLI.6,POS('XXX',JCLI.6));\n  T2=OVERLAY(VOLSER,JCLI.7,POS('XXXXXX',JCLI.7));\n  T3=OVERLAY(VOLSER,JCLI.1,POS('XXXXXX',JCLI.1));\n IF UNIT\u00ac=\"F00\" THEN DO;\n  DO J = 1 TO JCLI.0;\n      IF J=6 THEN INIT.INITCTR=T1;\n      ELSE IF J=7 THEN INIT.INITCTR=T2;\n      ELSE IF J=1 THEN INIT.INITCTR=T3;\n      ELSE INIT.INITCTR=JCLI.J;\n      INITCTR=INITCTR+1;\n  END;\n END;\n IF UNIT\u00ac=\"F00\" THEN ,\n  SUMM.SUMMCTR = VOLSER \"TYPE\" LEFT(TRUE_DEVTYPE,6) \"MAPPED TO\",\n     \"CDRS UNIT\" UNIT \"TYPE\" TARGET_TYPE;\n ELSE ,\nSUMM.SUMMCTR=\"****** VOLUME\" VOLSER \"NOT INITIALIZED AND/OR RESTORED\";\n  IF VOLSER=\"SYS006\" THEN ,\n       SUMM.SUMMCTR=SUMM.SUMMCTR \"IPL LOADUNIT\" UNIT;\n  IF VOLSER=\"SYS001\" | VOLSER=\"SYS002\" THEN ,\n       SUMM.SUMMCTR=SUMM.SUMMCTR \"LOADPARM\" RIGHT(UNIT,4,\"0\")\"CDM\";\n  SUMMCTR=SUMMCTR+1;\n END I;\nIF POOLMEM \u00ac=\"POOLSYSD\" & POOLMEM \u00ac=\"POOLSYST\" THEN DO;\n \"EXECIO * DISKW DUMP (FINIS STEM DUMP.\";\n \"EXECIO * DISKW INCR (FINIS STEM INCR.\";\n \"EXECIO * DISKW REST (FINIS STEM REST.\";\nEND;\n \"EXECIO * DISKW INIT (FINIS STEM INIT.\";\nEND ZZ;\n\"EXECIO * DISKW SUMM (FINIS STEM SUMM.\";\nEXIT 0;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ODRSCICS": {"ttr": 17672, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x932?\\x00\\x932?\\x10\\x15\\x00\\xa4\\x00\\xa4\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf7@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-11-19T00:00:00", "modifydate": "1993-11-19T10:15:00", "lines": 164, "newlines": 164, "modlines": 0, "user": "TECH107"}, "text": "/* REXX CDRS FCT MERGE EXEC */\nPARSE UPPER ARG ONLJOB;\nONLJOB = STRIP(ONLJOB);\nONLVOL = SUBSTR(ONLJOB,4);\n\"EXECIO * DISKR FCTIN (FINIS STEM FCTIN.\";\nDO K = 1 TO FCTIN.0;\n     TEMP = SUBSTR(FCTIN.K,1,72);\n     CONT=SUBSTR(TEMP,72,1);\n     IF WORDPOS(\"DFHFCT\",TEMP)\u00ac=0 THEN DO;\n          CURRFCT=TEMP;\n          DO WHILE (CONT\u00ac=\" \");\n              K=K+1; /* INDEX */\n              TEMP = SUBSTR(FCTIN.K,1,72);\n              CONT=SUBSTR(TEMP,72,1);\n              CURRFCT=CURRFCT TEMP;\n          END;\n     CURRFCT=TRANSLATE(CURRFCT,\"   \",\",()\");\n     PARSE VAR CURRFCT . \"DATASET=\" MEMBER . ;\n     PARSE VAR CURRFCT . \"DSNAME=\" DSN . ;\n     IF DSN=\" \" | DSN=\"\" | SUBSTR(MEMBER,1,3)=\"DFH\" THEN ITERATE K;\n     FCT.MEMBER=DSN;\nEND;\nEND;\nDROP FCTIN.;\n\"EXECIO * DISKR ZEKE (FINIS STEM ZEKE.\";\nFCTNLIST=\"\";\nDO K = 1 TO ZEKE.0;\n    PARSE VAR ZEKE.K \"SET\" \"SCOM\" . \"SET\" \"DA\" FCTN \"CLO\" . ;\n    IF FCTN=\" \" | FCTN=\"\" THEN ITERATE K;\n    FCTN = TRANSLATE(FCTN,\"   \",\"(),\");\n    FCTNLIST = FCTNLIST FCTN;\nEND;\nDROP ZEKE.;\nJCLX.0 = 52; /* COUNT OF INCR JOB STATEMENTS */\nJCLX.1 = \"//\"ONLJOB \"JOB 530401053000,'SYSTEM.BACKUP',\";\nJCLX.2 = \"// NOTIFY=TECH251,TYPRUN=HOLD,\";\nJCLX.3 = \"// CLASS=H,MSGCLASS=G\";\nJCLX.4 = \"//LOAD1 EXEC PGM=IKJEFT01,DYNAMNBR=32,PARM='%DB2TIACK'\";\nJCLX.5 = \"//SYSTSPRT DD SYSOUT=*\";\nJCLX.6 = \"//SYSPRINT DD SYSOUT=*\";\nJCLX.7 = \"//SYSTSIN DD DUMMY\";\nJCLX.8 = \"//SYSPROC DD DSN=SYSS.TECH.COMMON.EXECLIB,DISP=SHR\";\nJCLX.9 = \"//SYSIN DD *\";\nJCLX.10 = \" DELETE FROM BUILD.TABRVOLS WHERE VOLSER='\"ONLVOL\"' AND \";\nJCLX.11 = \" DUMP_STATUS='PENDING' AND DUMP_TYPE='INCRVOL';\";\nJCLX.12 = \" COMMIT;\";\nJCLX.13 = \" INSERT INTO BUILD.TABRVOLS (VOLSER,DUMP_TYPE,DUMP_STATUS)\";\nJCLX.14 = \"    VALUES('\"ONLVOL\"','INCRVOL','ACTIVE');\";\nJCLX.15 = \"/*\";\nJCLX.16= \"//DUMPIT EXEC PGM=FDRABR,REGION=9M\";\nJCLX.17= \"//SYSPRIN1 DD SYSOUT=*\";\nJCLX.18= \"//SYSPRIN2 DD SYSOUT=*\";\nJCLX.19= \"//SYSPRIN3 DD SYSOUT=*\";\nJCLX.20= \"//SYSPRIN4 DD SYSOUT=*\";\nJCLX.21=\"//TAPE1 DD DSN=I1ONLV,DISP=(,KEEP),UNIT=TA80,VOL=(,,,255)\";\nJCLX.22 =\"//TAPE2 DD DSN=I2ONLV,DISP=(,KEEP),UNIT=TA80,VOL=(,,,255)\";\nJCLX.23=\"//TAPE3 DD DSN=I3ONLV,DISP=(,KEEP),UNIT=TA80,VOL=(,,,255)\";\nJCLX.24=\"//TAPE4 DD DSN=I4ONLV,DISP=(,KEEP),UNIT=TA80,VOL=(,,,255)\";\nJCLX.25= \"//SYSPRINT DD SYSOUT=*\";\nJCLX.26 = \"//SYSUDUMP DD SYSOUT=X\";\nJCLX.27 = \"//SYSIN DD *\";\nJCLX.28 = \" DUMP TYPE=ABR,ONLVOL,\";\nJCLX.29 = \"  AUTOUPD=YES,\";\nJCLX.30 = \"  BUFNO=MAX,\";\nJCLX.31 = \"  COMPRESS=ALL,\";\nJCLX.32 = \"  DATA=USED,\";\nJCLX.33 = \"  DATEP=NONE,\";\nJCLX.34 = \"  DSNENQ=TEST,\";\nJCLX.35 = \"  ENQ=RESERVE,\";\nJCLX.36 = \"  ENQERR=NO,\";\nJCLX.37 = \"  ENQERR=PROCESS,\";\nJCLX.38 = \"  FORMAT=NEW,\";\nJCLX.39 = \"  LBPZERO=INVALID,\";\nJCLX.40 = \"  MAXDD=512,MAXERR=1,\";\nJCLX.41 = \"  PRINT=ABR,\";\nJCLX.42 = \"  RETPD=9999,\";\nJCLX.43 = \"  SMSCONSTRUCT=NO,\";\nJCLX.44 = \"  SMSMANAGE=NO\";\nJCLX.45 = \" S CATDSN=SYS1.UCATPRD1.CLUSTER\";\nJCLX.46 = \" S CATDSN=SYS1.UCATPRD2.CLUSTER\";\nJCLX.47 = \" S CATDSN=SYS1.UCATPRD3.CLUSTER\";\nJCLX.48 = \" S CATDSN=SYS1.UCATPROD.CLUSTER\";\nJCLX.49 = \" S CATDSN=SYS1.UCATTSOE.CLUSTER\";\nJCLX.50 = \" S CATDSN=SYSS.TLMS.V5R3M0.RMF.CLUSTER\";\nJCLX.51 = \" S CATDSN=SYSS.TLMS.V5R3M0.VMF\";\nJCLX.52 = \" S CATDSN=SYSS.TLMS.V5R3M0.VMFINDEX.CLUSTER\";\nJCLY.0 = 25; /* COUNT OF INCR JOB STATEMENTS */\nJCLY.1 = \"// IF (RC<=8 & \u00acABEND) THEN\";\nJCLY.2 = \"//LOAD2 EXEC PGM=IKJEFT01,DYNAMNBR=32,PARM='%DB2TIACK'\";\nJCLY.3 = \"//SYSTSPRT DD SYSOUT=*\";\nJCLY.4 = \"//SYSPRINT DD SYSOUT=*\";\nJCLY.5 = \"//SYSTSIN DD DUMMY\";\nJCLY.6 = \"//SYSPROC DD DSN=SYSS.TECH.COMMON.EXECLIB,DISP=SHR\";\nJCLY.7 = \"//SYSIN DD *\";\nJCLY.8 = \" UPDATE BUILD.TABRVOLS SET DUMP_STATUS='COMPLETE'\";\nJCLY.9 = \"    WHERE VOLSER='\"ONLVOL\"' AND DUMP_TYPE='INCRVOL';\";\nJCLY.10 = \" COMMIT;\";\nJCLY.11 = \"/*\";\nJCLY.12 = \"// ENDIF\";\nJCLY.13 = \"// IF (RC>8 | ABEND) THEN\";\nJCLY.14 = \"//LOAD3 EXEC PGM=IKJEFT01,DYNAMNBR=32,PARM='%DB2TIACK'\";\nJCLY.15 = \"//SYSTSPRT DD SYSOUT=*\";\nJCLY.16 = \"//SYSPRINT DD SYSOUT=*\";\nJCLY.17 = \"//SYSTSIN DD DUMMY\";\nJCLY.18 = \"//SYSPROC DD DSN=SYSS.TECH.COMMON.EXECLIB,DISP=SHR\";\nJCLY.19 = \"//SYSIN DD *\";\nJCLY.20 = \" UPDATE BUILD.TABRVOLS SET DUMP_STATUS='FAILURE'\";\nJCLY.21 = \"    WHERE VOLSER='\"ONLVOL\"' AND DUMP_TYPE='INCRVOL' AND \";\nJCLY.22 = \"    DUMP_STATUS='ACTIVE';\";\nJCLY.23 = \"/*\";\nJCLY.24 = \"// ENDIF\";\nJCLY.25 = \"//\";\nINCRCTR=1;\nDO I = 1 TO JCLX.0; /* START JCL */\n    INCR.INCRCTR = JCLX.I;\n    INCRCTR=INCRCTR+1;\nEND;\nK = WORDS(FCTNLIST);\nDSNLIST=\"\";\nDO I = 1 TO K;\n    FCTE=WORD(FCTNLIST,I);\n    IF SYMBOL(\"FCT.FCTE\")=\"VAR\" THEN DO;\n       DUMMY=OUTTRAP(\"LISTC.\");\n       \"LISTC ENT('\"FCT.FCTE\"') ALL\";\n       DUMMY=OUTTRAP(\"OFF\");\n       TYPE=WORD(LISTC.1,1);\n       SELECT;\n         WHEN (TYPE=\"CLUSTER\") THEN DO;\n             IF WORDPOS(FCT.FCTE,DSNLIST)=0 THEN DO;\n                 DSNLIST=DSNLIST FCT.FCTE;\n                 INCR.INCRCTR=\" S CATDSN=\"FCT.FCTE;\n                 INCRCTR=INCRCTR+1;\n             END;\n             END;\n         WHEN (TYPE=\"PATH\") THEN NOP;\n         WHEN (TYPE=\"AIX\") THEN DO;\n             DO X = 1 TO LISTC.0;\n                IF POS(\"CLUSTER--\",LISTC.X)\u00ac=0 THEN DO;\n                      PARSE VAR LISTC.X . \"CLUSTER--\" CLDSN . ;\n                      CLDSN=STRIP(CLDSN);\n             IF WORDPOS(CLDSN,DSNLIST)=0 THEN DO;\n                 DSNLIST=DSNLIST CLDSN;\n                 INCR.INCRCTR=\" S CATDSN=\"CLDSN;\n                 INCRCTR=INCRCTR+1;\n                      END;\n                    END;\n             END X;\n             END;\n         OTHERWISE DO;\n             IF WORDPOS(FCT.FCTE,DSNLIST)=0 THEN DO;\n                 DSNLIST=DSNLIST FCT.FCTE;\n                 INCR.INCRCTR=\" S CATDSN=\"FCT.FCTE;\n                 INCRCTR=INCRCTR+1;\n             END;\n             END;\n       END;\n   END;\nEND;\nDO I = 1 TO JCLY.0; /* START JCL */\n    INCR.INCRCTR = JCLY.I;\n    INCRCTR=INCRCTR+1;\nEND;\n\"EXECIO * DISKW INCROUT (FINIS STEM INCR.\";\nEXIT 0;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "OLDREST": {"ttr": 17676, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x17/\\x00\\x94\\x17/\\x153\\x02~\\x02~\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf7@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-06-21T00:00:00", "modifydate": "1994-06-21T15:33:00", "lines": 638, "newlines": 638, "modlines": 0, "user": "TECH107"}, "text": "/*  REXX EXEC : ( NWRESTOR ).\n    FUNCTION  : LAN SERVER BACKUP PANEL INTERFACE TO FACILITATE FILE\n                RESTORES FOR A SERVER VOLUME FROM THE MVS HOST CENTRAL\n                ARCHIVE BACKUP.\n                BUILDS AND WRITES THE JOB JCL AND INPUT SCRIPT TO\n                PERFORM THE LAN SERVER RESTORE AND SUBMITS THE JOB\n                FOR EXECUTION ON THE SYSB SYSTEM CLASS=S.\n    INPUT     : ( PTECH2.NETCA.&&SERVER.&&VOLUME.H ).\n                ( SYSS.NETCA.LAN.MVSNW.UA ).\n    OUTPUT    : ( PTECH3.NETCA.RESTORE.SCRIPT.PARMLIB(&MEMBER).\n                ( PTECH3.NETCA.RESTORE.SCRIPT.CNTLLIB(&MEMBER).\n    1/26/94   - ADDED REALITY AND ASP\n                                                                    */\nTRACE O\n/*      */\nHOUSE_KEEPING:\nADDRESS TSO\nSERVER.1 = 'COM'\nSERVER.2 = 'CS1'\nSERVER.3 = 'CS2'\nSERVER.4 = 'MAGIC'\nSERVER.5 = 'POS'\nSERVER.6 = 'CS3'\nSERVER.7 = 'DB1'\nSERVER.8 = 'CSI'\nSERVER.9 = 'FIN'\nSERVER.10 = 'MIS'\nSERVER.11 = 'SYS'\nSERVER.12 = 'PAD'\nSERVER.13 = 'REA'\nSERVER.14 = 'ASP'\nSERVER.15 = 'CS4'\nSERVER.16 = 'DB1'\nSERVER.17 = 'C4A'\nSERVER.18 = 'C4B'\nRESTYPE.1 = 'FILE'\nRESTYPE.2 = 'DRCT'\nRESTYPE.3 = 'VOL'\nRESTMOD.1 = 'INCR'\nRESTMOD.2 = 'FULL'\nPARMLIB = 'SYSS.TECH.COMMON.PARMLIB'\nSCRIPTLIB = 'PTECH3.NETCA.RESTORE.SCRIPT.PARMLIB'\nCNTLLIB = 'PTECH3.NETCA.RESTORE.SCRIPT.CNTLLIB'\nTEXTLIB = 'SYSS.NETCA.CONTROL.TEXTLIB'\nTSOID = SYSVAR(SYSUID)\nCURTIME = TIME()\nHH = SUBSTR(CURTIME,1,2)\nMM = SUBSTR(CURTIME,4,2)\nSS = SUBSTR(CURTIME,7,2)\nTIMEP = HH||MM||SS\nJSUFFIX = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\nX = MSG(\"OFF\")\n\"FREE FILE(NWDD)\"\nADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\n\n/*     */\nDISPLAY_SERVER_PANEL:\nAUTHPARM = 'NWHPDESK'\nNWMSG = 'NWLAN002'\nDO FOREVER\n   ADDRESS ISPEXEC\n   \"DISPLAY PANEL(NWRSTPN1)\"\n   SRC = RC\n   IF SRC = 8 THEN EXIT 0\n   IF SRC > 8 THEN DO\n      SAY '*** ERROR INVOKING ISPF DIALOG PANEL ( NWRSTPN1 ). ***'\n      SAY '*** NWRESTOR EXEC TASK CANCELLED - RC = 'SRC'. ***'\n      EXIT SRC\n   END\n   IF RESTYPE.RT = 'VOL' THEN DO\n      AUTHPARM = 'NWLANGRP'\n      NWMSG = 'NWLAN003'\n   END\n   CALL CHECK_USER_AUTHORIZATION\n   IF AUTHSW = 'YES' THEN LEAVE\n   \"SETMSG MSG(\"NWMSG\")\"\nEND\nSERVER = SERVER.LAN\nIF SERVER = 'MAGIC' THEN DO\n   VOLKEY = 'MAGIC SYS:'\n   RESTVOL = 'SYS:'\n/* RESTDPN = 'MAGIC' */\n   VOLUME = 'MAGIC'\n   SERVER = 'CS3'\n   RM = 2\n   SIGNAL BUILD_CONTAINER_DATASET_PARMS\nEND\nIF SERVER = 'POS' THEN DO\n   VOLKEY = 'POS VOL1:'\n   RESTVOL = 'VOL1:'\n/* RESTDPN = 'POS' */\n   VOLUME = 'POS'\n   SERVER = 'CS3'\n   RM = 2\n   SIGNAL BUILD_CONTAINER_DATASET_PARMS\nEND\nIF SERVER = 'REA' THEN DO\n   VOLKEY = 'REA VOL2:'\n   RESTVOL = 'VOL2:'\n   RESTDPN = 'REA'\n   VOLUME = 'REA'\n   SERVER = 'CS1'\n   RM = 2\n   SIGNAL BUILD_CONTAINER_DATASET_PARMS\nEND\nIF SERVER = 'ASP' THEN DO\n   VOLKEY = 'ASP VOL1:'\n   RESTVOL = 'VOL1:'\n   RESTDPN = 'ASP'\n   VOLUME = 'ASP'\n   SERVER = 'CSI'\n   RM = 2\n   SIGNAL BUILD_CONTAINER_DATASET_PARMS\nEND\n\n/*     */\nDISPLAY_VOLUME_PANEL:\nADDRESS TSO\n\"FREE FILE(NWDD)\"\n\"FREE FILE(ISPFILE)\"\nCALL READ_SERVER_VOLUMES_PARMS\nADDRESS ISPEXEC \"DISPLAY PANEL(NWRSTPN2)\"\nSRC = RC\nIF SRC = 8 THEN EXIT 0\nIF SRC > 8 THEN DO\n   SAY '*** ERROR INVOKING ISPF DIALOG PANEL ( NWRSTPN2 ). ***'\n   SAY '*** NWRESTOR EXEC TASK CANCELLED - RC = 'SRC'. ***'\n   EXIT SRC\nEND\nCALL GET_SELECTED_SERVER_VOLUME\nVOLKEY = VOLUME RESTVOL\n\n/*     */\nBUILD_CONTAINER_DATASET_PARMS:\nCALL GET_HISTORY_CONTAINER_DATASETS\nIF DSN = 0 THEN DO\n   SAY '*** HISTORY DATASET ERROR: NO VALID CONTAINER DATASET NAMES FOUND. ***'\n   SAY '*** DSN ('NWHSTLIB') DOES NOT CONTAIN A BACKUP STATUS OF (SSSS). ***'\n   SAY '*** NWRESTOR EXEC TASK CANCELLED - RC = (028). ***'\n   EXIT 028\nEND\nGDGCNT = 18\nNWPANEL = 'NWRSTPN3'\nIF RESTMOD.RM = 'FULL' & SERVER \u00ac= 'PAD' THEN DO\n   GDGCNT = 6\n   NWPANEL = 'NWRSTPN4'\nEND\nCALL BUILD_PANEL_DATASET_PARMS\n\n/*     */\nDISPLAY_DATASET_LIST_PANEL:\nDO FOREVER\n   ADDRESS ISPEXEC\n   \"DISPLAY PANEL(\"NWPANEL\")\"\n   SRC = RC\n   IF SRC = 8 THEN EXIT 0\n   IF SRC > 8 THEN DO\n      SAY '*** ERROR INVOKING ISPF DIALOG PANEL ( 'NWPANEL' ). ***'\n      SAY '*** NWRESTOR EXEC TASK CANCELLED - RC = 'SRC'. ***'\n      EXIT SRC\n   END\n   CALL GET_PANEL_INPUT_DATASET\n   IF DSNSW = 'YES' THEN LEAVE\n   \"SETMSG MSG(NWLAN004)\"\nEND\nIF RESTYPE.RT = 'DRCT' & RESTFN = '' THEN RESTFN = '*'\nIF RESTYPE.RT = 'VOL' THEN DO\n   RESTDPN = '*'\n   RESTFN = '*'\nEND\n\n/*     */\nDISPLAY_INPUT_PARMS_CONFIRMATION_PANEL:\nCALL LISTCAT_CONTAINER_DATASET\nCALL BUILD_PANEL_TAPE_VOLSERS\nADDRESS ISPEXEC\n\"DISPLAY PANEL(NWRSTPN5)\"\nSRC = RC\nIF SRC = 8 THEN EXIT 0\nIF SRC > 8 THEN DO\n   SAY '*** ERROR INVOKING ISPF DIALOG PANEL ( NWRSTPN5 ). ***'\n   SAY '*** NWRESTOR EXEC TASK CANCELLED - RC = 'SRC'. ***'\n   EXIT SRC\nEND\n\n/*     */\nCREATE_RESTORE_JOB_PARMS:\nADDRESS TSO\nSUBPDS = CNTLLIB\nJMEMB = 'J'TIMEP                  /* JOURNAL PARMS MEMBER */\nRMEMB = 'R'TIMEP                  /* RESTORE JOB JCL MEMBER */\nSMEMB = 'S'TIMEP                  /* SCRIPT INPUT MEMBER */\n\"DELSTACK\"\nCALL BUILD_JOBNAME_PARM\nOUTPDS = CNTLLIB\nOUTMEMB = JOBNAME\nQUEUE JOBNAME\nCALL WRITE_PDS_MEMBER\nCALL BUILD_RESTORE_JOB\nOUTMEMB = RMEMB\nCALL WRITE_PDS_MEMBER\n\"DELSTACK\"\nQUEUE SERVER\nQUEUE RESTVOL\nQUEUE RESTDSN\nQUEUE RESTDPN\nQUEUE RESTFN\nOUTMEMB = JMEMB\nCALL WRITE_PDS_MEMBER\nCALL BUILD_RESTORE_PARMS\nOUTMEMB = SMEMB\nOUTPDS = SCRIPTLIB\nCALL WRITE_PDS_MEMBER\nCALL SUBMIT_RESTORE_JOB\nEXIT 0\n\n/*     S U B R O U T I N E S   S E C T I O N     */\n/*     */\nCHECK_USER_AUTHORIZATION:\nADDRESS TSO\nAUTHSW = 'NO'\n\"ALLOC DA('\"PARMLIB\"(\"AUTHPARM\")') FILE(NWDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('PARMLIB'('AUTHPARM'). ***'\n   SAY '*** NWRESTOR EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\n\"EXECIO * DISKR NWDD (FINIS STEM AUTH.\"\nSRC = RC\n\"FREE FILE(NWDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** EXECIO READ ERROR: ('PARMLIB'('AUTHPARM'). ***'\n   SAY '*** NWRESTOR EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nDO I = 1 TO AUTH.0\n   LAU = POS(TSOID,AUTH.I)\n   IF LAU \u00ac= 0 THEN AUTHSW = 'YES'\nEND\nRETURN\n\n/*     */\nREAD_SERVER_VOLUMES_PARMS:\nADDRESS TSO\nVOLCONFG = SERVER'IVOLS'\nIF RESTMOD.RM = 'FULL' THEN VOLCONFG = SERVER'FVOLS'\n\"ALLOC DA('\"TEXTLIB\"(\"VOLCONFG\")') FILE(NWDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('TEXTLIB'('VOLCONFG'). ***'\n   SAY '*** NWRESTOR EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\n\"EXECIO * DISKR NWDD (FINIS STEM VOLP.\"\nSRC = RC\n\"FREE FILE(NWDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** EXECIO READ ERROR: ('TEXTLIB'('VOLCONFG'). ***'\n   SAY '*** NWRESTOR EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nV = 0\nVOL1 = '*****'\nVOL2 = '*****'\nVOL3 = '*****'\nVOL4 = '*****'\nVOL5 = '*****'\nVOL6 = '*****'\nVOL7 = '*****'\nVOL8 = '*****'\nDO I = 1 TO VOLP.0\n   UPPER VOLP.I\n   SVOL = POS('DAILY',VOLP.I)\n   IF SVOL = 0 THEN ITERATE\n   V = V + 1\n   SERVOL = WORD(VOLP.I,2)\n   RSTVOL.V = WORD(VOLP.I,2)\n   IF V = 1 THEN VOL1 = LEFT(SERVOL,5,'*')\n   IF V = 2 THEN VOL2 = LEFT(SERVOL,5,'*')\n   IF V = 3 THEN VOL3 = LEFT(SERVOL,5,'*')\n   IF V = 4 THEN VOL4 = LEFT(SERVOL,5,'*')\n   IF V = 5 THEN VOL5 = LEFT(SERVOL,5,'*')\n   IF V = 6 THEN VOL6 = LEFT(SERVOL,5,'*')\n   IF V = 7 THEN VOL7 = LEFT(SERVOL,5,'*')\n   IF V = 8 THEN VOL8 = LEFT(SERVOL,5,'*')\nEND\nRETURN\n\n/*     */\nGET_SELECTED_SERVER_VOLUME:\nDO I = 1 TO 8\n   SELVOL = VALUE('RV'I)\n   IF SELVOL = '' THEN ITERATE\n   RESTVOL = RSTVOL.I\n   VOLUME = STRIP(RESTVOL,'T',':')\n   LEAVE\nEND\nRETURN\n\n/*     */\nGET_HISTORY_CONTAINER_DATASETS:\nADDRESS TSO\nDSN = 0\nNWHSTLIB = 'PTECH2.NETCA.'SERVER'.'VOLUME'.H'\nNWDSN = SYSDSN(\"'\"NWHSTLIB\"'\")\nIF NWDSN = 'DATASET NOT FOUND' THEN DO\n   SAY '*** DATASET ERROR: DATASET NOT FOUND FOR ('NWHSTLIB'). ***'\n   SAY '*** NWRESTOR EXEC SUBTASK CANCELLED - RETURN CODE: (028). ***'\n   EXIT 028\nEND\n\"ALLOC DA('\"NWHSTLIB\"') FILE(NWDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('NWHSTLIB'). ***'\n   SAY '*** NWRESTOR EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\n\"EXECIO * DISKR NWDD (FINIS STEM HIST.\"\nSRC = RC\n\"FREE FILE(NWDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** EXECIO READ ERROR: ('NWHSTLIB'). ***'\n   SAY '*** NWRESTOR EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nBUDATE.1 = 'XXXX-XX-XX'\nBUDATE.2 = 'XXXX-XX-XX'\nBUDATE.3 = 'XXXX-XX-XX'\nBUDATE.4 = 'XXXX-XX-XX'\nBUDATE.5 = 'XXXX-XX-XX'\nBUDATE.6 = 'XXXX-XX-XX'\nBUDATE.7 = 'XXXX-XX-XX'\nBUDATE.8 = 'XXXX-XX-XX'\nBUDATE.9 = 'XXXX-XX-XX'\nBUDATE.10 = 'XXXX-XX-XX'\nBUDATE.11 = 'XXXX-XX-XX'\nBUDATE.12 = 'XXXX-XX-XX'\nBUDATE.13 = 'XXXX-XX-XX'\nBUDATE.14 = 'XXXX-XX-XX'\nBUDATE.15 = 'XXXX-XX-XX'\nBUDATE.16 = 'XXXX-XX-XX'\nBUDATE.17 = 'XXXX-XX-XX'\nBUDATE.18 = 'XXXX-XX-XX'\nBUDSN.1 = '--------------------------------------------'\nBUDSN.2 = '--------------------------------------------'\nBUDSN.3 = '--------------------------------------------'\nBUDSN.4 = '--------------------------------------------'\nBUDSN.5 = '--------------------------------------------'\nBUDSN.6 = '--------------------------------------------'\nBUDSN.7 = '--------------------------------------------'\nBUDSN.8 = '--------------------------------------------'\nBUDSN.9 = '--------------------------------------------'\nBUDSN.10 = '--------------------------------------------'\nBUDSN.11 = '--------------------------------------------'\nBUDSN.12 = '--------------------------------------------'\nBUDSN.13 = '--------------------------------------------'\nBUDSN.14 = '--------------------------------------------'\nBUDSN.15 = '--------------------------------------------'\nBUDSN.16 = '--------------------------------------------'\nBUDSN.17 = '--------------------------------------------'\nBUDSN.18 = '--------------------------------------------'\nDO I = 1 TO HIST.0\n   UPPER HIST.I\n   VLOC = POS(VOLKEY,HIST.I)\n   IF VLOC \u00ac= 0 THEN DO\n      BUSTATUS = WORD(HIST.I,9)\n      IF BUSTATUS = 'SSSS' THEN DO\n         BUTYPE = WORD(HIST.I,5)\n         IF BUTYPE = RESTMOD.RM THEN DO\n            DSN = DSN + 1\n            BUDATE.DSN = WORD(HIST.I,1)\n            BUTIME.DSN = WORD(HIST.I,2)\n            L = I + 1\n            UPPER HIST.L\n            HSTDSN = WORD(HIST.L,2)\n            BUDSN.DSN = STRIP(HSTDSN,\"B\",\"'\")\n         END\n      END\n   END\nEND\nRETURN\n\n/*     */\nBUILD_PANEL_DATASET_PARMS:\nDO D = 1 TO GDGCNT\n   IF BUDSN.D = '' THEN ITERATE\n   IF D = 1 THEN DO\n      BUDATE01 = BUDATE.D\n      BUDSN01 = BUDSN.D\n   END\n   IF D = 2 THEN DO\n      BUDATE02 = BUDATE.D\n      BUDSN02 = BUDSN.D\n   END\n   IF D = 3 THEN DO\n      BUDATE03 = BUDATE.D\n      BUDSN03 = BUDSN.D\n   END\n   IF D = 4 THEN DO\n      BUDATE04 = BUDATE.D\n      BUDSN04 = BUDSN.D\n   END\n   IF D = 5 THEN DO\n      BUDATE05 = BUDATE.D\n      BUDSN05 = BUDSN.D\n   END\n   IF D = 6 THEN DO\n      BUDATE06 = BUDATE.D\n      BUDSN06 = BUDSN.D\n   END\n   IF D = 7 THEN DO\n      BUDATE07 = BUDATE.D\n      BUDSN07 = BUDSN.D\n   END\n   IF D = 8 THEN DO\n      BUDATE08 = BUDATE.D\n      BUDSN08 = BUDSN.D\n   END\n   IF D = 9 THEN DO\n      BUDATE09 = BUDATE.D\n      BUDSN09 = BUDSN.D\n   END\n   IF D = 10 THEN DO\n      BUDATE10 = BUDATE.D\n      BUDSN10 = BUDSN.D\n   END\n   IF D = 11 THEN DO\n      BUDATE11 = BUDATE.D\n      BUDSN11 = BUDSN.D\n   END\n   IF D = 12 THEN DO\n      BUDATE12 = BUDATE.D\n      BUDSN12 = BUDSN.D\n   END\n   IF D = 13 THEN DO\n      BUDATE13 = BUDATE.D\n      BUDSN13 = BUDSN.D\n   END\n   IF D = 14 THEN DO\n      BUDATE14 = BUDATE.D\n      BUDSN14 = BUDSN.D\n   END\n   IF D = 15 THEN DO\n      BUDATE15 = BUDATE.D\n      BUDSN15 = BUDSN.D\n   END\n   IF D = 16 THEN DO\n      BUDATE16 = BUDATE.D\n      BUDSN16 = BUDSN.D\n   END\n   IF D = 17 THEN DO\n      BUDATE17 = BUDATE.D\n      BUDSN17 = BUDSN.D\n   END\n   IF D = 18 THEN DO\n      BUDATE18 = BUDATE.D\n      BUDSN18 = BUDSN.D\n   END\nEND\nRETURN\n\n/*     */\nGET_PANEL_INPUT_DATASET:\nDSNSW = 'NO'\nDO I = 1 TO GDGCNT\n   SELDSN = VALUE('RD'I)\n   IF SELDSN = '' THEN ITERATE\n   IF I < 10 THEN DO\n      RESTDAT = VALUE('BUDATE0'I)\n      RESTDSN = VALUE('BUDSN0'I)\n   END\n   IF I >= 10 THEN DO\n      RESTDAT = VALUE('BUDATE'I)\n      RESTDSN = VALUE('BUDSN'I)\n   END\n   IF RESTDSN = '' THEN ITERATE\n   DSNSW = 'YES'\n   LEAVE\nEND\nRETURN\n\n/*     */\nLISTCAT_CONTAINER_DATASET:\nADDRESS TSO\nT = 0\nX = OUTTRAP(\"LSTCAT.\",\"*\",\"CONCAT\")\n\"LISTCAT ENT('\"RESTDSN\"') ALL\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** LISTCAT ERROR: 'RESTDSN'. ***'\n   SAY '*** NWRESTOR EXEC SUBTASK CANCELLED - RC = ('SRC'). ***'\n   EXIT SRC\nEND\nDO L = 1 TO LSTCAT.0\n   VOLKEY = POS(\"VOLSER------------\",LSTCAT.L)\n   IF VOLKEY \u00ac= 0 THEN DO\n      STA = VOLKEY + 18\n      T = T + 1\n      TAPE.T = SUBSTR(LSTCAT.L,STA,6)\n   END\nEND\nTAPECNT = T\nRETURN\n\n/*     */\nBUILD_PANEL_TAPE_VOLSERS:\nDO T = 1 TO TAPECNT\n   IF T = 1 THEN TAPE1 = TAPE.T\n   IF T = 2 THEN TAPE2 = TAPE.T\n   IF T = 3 THEN TAPE3 = TAPE.T\n   IF T = 4 THEN TAPE4 = TAPE.T\n   IF T = 5 THEN TAPE5 = TAPE.T\n   IF T = 6 THEN TAPE6 = TAPE.T\n   IF T = 7 THEN TAPE7 = TAPE.T\n   IF T = 8 THEN TAPE8 = TAPE.T\nEND\nRETURN\n\n/*     */\nBUILD_JOBNAME_PARM:\nJN1 = 'NWR'\nJN2 = SUBSTR(TSOID,5,3)\nDO N = 1 TO 26\n   JN3 = SUBSTR(JSUFFIX,N,1)\n   JOBNAME = JN1||JN2||JN3\n   JOB = SYSDSN(\"'\"CNTLLIB\"(\"JOBNAME\")'\")\n   IF JOB = 'MEMBER NOT FOUND' THEN LEAVE\nEND\nJN = JOBNAME\nRETURN\n\n/*     */\nBUILD_RESTORE_JOB:\n\"DELSTACK\"\nRCDCNT = 36\nDIRPATH = STRIP(RESTDPN,'T','/')\nSTARGET = RESTVOL||DIRPATH\nIF RESTDPN = '*' THEN STARGET = RESTVOL\nJCL.1 = \"//\"JN\"  JOB 5304010530000000,'\"SERVER\" LAN RESTORE',NOTIFY=\"TSOID\",\"\nJCL.2 = \"//             CLASS=S,MSGCLASS=G,MSGLEVEL=(1,1),REGION=6M\"\nJCL.3 = \"/*JOBPARM SYSAFF=SYSB\"\nJCL.4 = \"//RESTORE  EXEC PGM=NUACLIEN\"\nJCL.5 = \"//NETUADD  DD DSN=PTECH3.NETCA.RESTORE.SCRIPT.PARMLIB,DISP=SHR\"\nJCL.6 = \"//SYSPRINT DD SYSOUT=*\"\nJCL.7 = \"//SYSIN DD *\"\nJCL.8 = \"CONNECT RS6000 -SERV \"SERVER\" \"LANID\" \"LANPW\nJCL.9 = \"SET DEBUG LOG SYS:/SICOM/CA/RESTORE/DEBUG.LOG\"\nJCL.10 = \"SET GLOBAL TARGET\" STARGET\nJCL.11 = \"SET GLOBAL OPTIONS -LOG SYS:/SICOM/CA/DB/RESTORE.RPT\"\nJCL.12 = \"INPUT 'SYSS.NETCA.LAN.MVSNW.UA'\"\nJCL.13 = \"INPUT DD:NETUADD(\"SMEMB\")\"\nJCL.14 = \"EXIT\"\nJCL.15 = \"/*\"\nJCL.16 = \"//WRITELOG EXEC PGM=IKJEFT01,DYNAMNBR=30,\"\nJCL.17 = \"//   PARM='%NWRSTLOG \"JMEMB\"',COND=(0,LT,RESTORE)\"\nJCL.18 = \"//SYSPRINT DD SYSOUT=*\"\nJCL.19 = \"//SYSTSPRT DD SYSOUT=*\"\nJCL.20 = \"//SYSIN    DD DUMMY\"\nJCL.21 = \"//SYSLBC   DD DSN=SYS1.BRODCAST,DISP=SHR\"\nJCL.22 = \"//SYSUADS  DD DSN=SYS1.UADS,DISP=SHR\"\nJCL.23 = \"//SYSPROC  DD DSN=SYSS.TECH.COMMON.EXECLIB,DISP=SHR\"\nJCL.24 = \"//SYSTSIN  DD DUMMY\"\nJCL.25 = \"/*\"\nJCL.26 = \"//DELETE   EXEC PGM=IDCAMS\"\nJCL.27 = \"//CNTLDD   DD DSN=\"CNTLLIB\",DISP=SHR\"\nJCL.28 = \"//SCRIPTDD DD DSN=\"SCRIPTLIB\",DISP=SHR\"\nJCL.29 = \"//SYSPRINT DD SYSOUT=*\"\nJCL.30 = \"//SYSIN    DD *\"\nJCL.31 = \"  DELETE   \"SCRIPTLIB\"(\"SMEMB\")  FILE(SCRIPTDD)\"\nJCL.32 = \"  DELETE   \"CNTLLIB\"(\"JMEMB\")  FILE(CNTLDD)\"\nJCL.33 = \"  DELETE   \"CNTLLIB\"(\"RMEMB\")  FILE(CNTLDD)\"\nJCL.34 = \"  DELETE   \"CNTLLIB\"(\"JOBNAME\")  FILE(CNTLDD)\"\nJCL.35 = \"/*\"\nJCL.36 = \"//\"\nDO J = 1 TO RCDCNT\n   QUEUE JCL.J\nEND\nRETURN\n\n/*     */\nBUILD_RESTORE_PARMS:\n\"DELSTACK\"\nRESTDSN = \"'\"||RESTDSN||\"'\"\nRESTPRM = '\"'||RESTDPN||RESTFN||' -PDT ON -REP ON\"'\nIF RESTYPE.RT = 'FILE' THEN DO\n   RECORD1 = 'CA_RESTORE 'RESTMOD.RM' 'RESTDSN' 'RESTVOL' -'\n   QUEUE RECORD1\n   RECORD2 = '   '||RESTPRM\n   QUEUE RECORD2\nEND\nIF RESTYPE.RT = 'DRCT' THEN DO\n   RESTPRM = '\"'||RESTDPN'*.* -PDT ON -REP ON\"'\n   RECORD1 = 'CA_RESTORE 'RESTMOD.RM' 'RESTDSN' 'RESTVOL' -'\n   QUEUE RECORD1\n   RECORD2 = '   '||RESTPRM\n   QUEUE RECORD2\nEND\nIF RESTYPE.RT = 'VOL' THEN DO\n   RECORD = 'CA_RESTORE 'RESTMOD.RM' 'RESTDSN' 'RESTVOL' -'\n   QUEUE RECORD\n   RECORD2 = '    \"/* -PDT ON REP ON\"'\n   QUEUE RECORD2\nEND\nRETURN\n\n/*     */\nWRITE_PDS_MEMBER:\nADDRESS TSO\n\"ALLOC DA('\"OUTPDS\"(\"OUTMEMB\")') FILE(NWDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('OUTPDS'('OUTMEMB'). ***'\n   SAY '*** NWRESTOR EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nNUMRCDS = QUEUED()\n\"EXECIO\" NUMRCDS \"DISKW NWDD (FINIS\"\nSRC = RC\n\"FREE FILE(NWDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** WRITE ERROR: ERROR WRITING 'OUTPDS'('OUTMEMB'). ***'\n   SAY '*** NWRESTOR EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nRETURN\n\n/*     */\nSUBMIT_RESTORE_JOB:\nADDRESS TSO\n\"SUBMIT ('\"SUBPDS\"(\"RMEMB\")')\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** SUBMIT ERROR: MEMBER ( 'SUBPDS'('RMEMB'). ***'\n   SAY '*** NWRESTOR EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "OLDSDBLD": {"ttr": 18177, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x05o\\x00\\x94\\x05o\\x13\\x03\\x02\\x88\\x02\\x88\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf7@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-02-25T00:00:00", "modifydate": "1994-02-25T13:03:00", "lines": 648, "newlines": 648, "modlines": 0, "user": "TECH107"}, "text": "/* REXX DASD BUILD ANALYSIS */\nTRUE = \"1\";\nFALSE = \"0\";\nSUMMCTR=1;\nDASD.0885 = \"3380DJ\";\nDASD.1770 = \"3380E\";\nDASD.2655 = \"3380K\";\nDASD.2226 = \"33902\";\nDASD.3339 = \"33903\";\nDASD.6678 = \"33906\";\nCDRS.3380DJ = \"100 11F 200 21F\";\nCDRS.3380E  = \"480 49F\";\nCDRS.3380K  = \"C40 C5F F00 F00\";\nCDRS.33902  = \"3C0 3FF FC0 FFF\";\nCDRS.33903  = \"EC0 EFF 1C0 1FF\";\nCDRS.33906  = \"F00 F00\"; /* F00 IS END INDICATOR */\nCLASSLIST=\"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\n/* ALPHA LIST */\nABRPOOLS=\"ACIC APPL ART CICS DB2 EMC MNT MVS PLAN \" || ,\n  \"POS PHYS QA RAMI SEQ SMSC SMS SYSDA SYSTA SYS TSO UART USER VSAM\";\n/* LIST BY IMP */\nABRPOOLSR=\"SYS CICS EMC DB2 SMS VSAM ART ACIC UART APPL MVS PLAN \" || ,\n  \"POS QA RAMI SEQ PHYS SMSC TSO USER MNT SYSDA SYSTA\";\nTEMP = \"\";\nDO I = 1 TO WORDS(CDRS.3380DJ) BY 2;\n  LLIM = X2D(WORD(CDRS.3380DJ,I));\n  HLIM = X2D(WORD(CDRS.3380DJ,I+1));\n     DO J = LLIM TO HLIM;\n        TEMP = TEMP D2X(J);\n     END;\nEND;\nCDRS.3380DJ = TEMP;\nTEMP = \"\";\nDO I = 1 TO WORDS(CDRS.3380E) BY 2;\n  LLIM = X2D(WORD(CDRS.3380E,I));\n  HLIM = X2D(WORD(CDRS.3380E,I+1));\n     DO J = LLIM TO HLIM;\n        TEMP = TEMP D2X(J);\n     END;\nEND;\nCDRS.3380E = TEMP;\nTEMP = \"\";\nDO I = 1 TO WORDS(CDRS.3380K) BY 2;\n  LLIM = X2D(WORD(CDRS.3380K,I));\n  HLIM = X2D(WORD(CDRS.3380K,I+1));\n     DO J = LLIM TO HLIM;\n        TEMP = TEMP D2X(J);\n     END;\nEND;\nCDRS.3380K = TEMP;\nTEMP = \"\";\nDO I = 1 TO WORDS(CDRS.33902) BY 2;\n  LLIM = X2D(WORD(CDRS.33902,I));\n  HLIM = X2D(WORD(CDRS.33902,I+1));\n     DO J = LLIM TO HLIM;\n        TEMP = TEMP D2X(J);\n     END;\nEND;\nCDRS.33902 = TEMP;\nTEMP = \"\";\nDO I = 1 TO WORDS(CDRS.33903) BY 2;\n  LLIM = X2D(WORD(CDRS.33903,I));\n  HLIM = X2D(WORD(CDRS.33903,I+1));\n     DO J = LLIM TO HLIM;\n        TEMP = TEMP D2X(J);\n     END;\nEND;\nCDRS.33903 = TEMP;\nTEMP = \"\";\nDO I = 1 TO WORDS(CDRS.33906) BY 2;\n  LLIM = X2D(WORD(CDRS.33906,I));\n  HLIM = X2D(WORD(CDRS.33906,I+1));\n     DO J = LLIM TO HLIM;\n        TEMP = TEMP D2X(J);\n     END;\nEND;\nCDRS.33906 = TEMP;\nINIT_REST_UNIT = WORD(CDRS.33902,1);\nCDRS.33902 = DELWORD(CDRS.33902,1,1);\n\"CALL 'SYS1.TECH.COMMON.LOADLIB(DASDSCAN)'\";\n/* \"CALL 'TECH110.USER.LOADLIB(DASDSCAN)'\"; */\nSAVERC=RC;\nIF SAVERC\u00ac=0 THEN EXIT SAVERC;\n\"EXECIO * DISKR WORK (FINIS STEM DASDV.\";\nCHANGES = TRUE;\nDO WHILE(CHANGES); /* BUBBLE SORT DESCENDING BY FRAG INDEX */\n     CHANGES = FALSE;\n     DO I = 1 TO DASDV.0-1;\n          J = I+1;\n          PARSE VAR DASDV.I . . . FRAGINDEX1 . ;\n          PARSE VAR DASDV.J . . . FRAGINDEX2 . ;\n          IF FRAGINDEX1 < FRAGINDEX2 THEN DO;\n                 TEMP = DASDV.I;\n                 DASDV.I = DASDV.J;\n                 DASDV.J = TEMP;\n                 CHANGES = TRUE;\n                 END;\n     END;\nEND;\nDO I = 1 TO DASDV.0;\n  PARSE VAR DASDV.I VOLSER CYLCOUNT FREECYL FRAGINDEX . ;\n  ABR_BACKUP_DSN = \"'FDRABR.V\"VOLSER\"'\";\n  DUMMY = LISTDSI(ABR_BACKUP_DSN); /* SEE IF DATASET EXISTS */\n  IF DUMMY\u00ac=0 THEN DO;\n       DASDV.I = \"DUMMY\"; /* IGNORE THIS VOLUME */\n       ITERATE I; /* LOOP */\n       END;\n  POOLCTR=WORDS(ABRPOOLS);\n  DO J=1 TO POOLCTR;\n     POOL=WORD(ABRPOOLS,J);\n     IF ABBREV(VOLSER,POOL) THEN DO;\n           IF SYMBOL('POOLLIST.POOL')=\"VAR\" THEN ,\n               POOLLIST.POOL=POOLLIST.POOL VOLSER;\n            ELSE POOLLIST.POOL=VOLSER;\n          LEAVE J;\n         END;\n  END;\nEND;\nABRPOOLS = ABRPOOLSR; /* REORG LIST FOR ORDER TO PROCESS IN */\nDO J=1 TO POOLCTR;\n     POOL=WORD(ABRPOOLS,J);\n     VOLCNT=WORDS(POOLLIST.POOL);\n     JOBC=SUBSTR(CLASSLIST,J,1);\nSUMM.SUMMCTR=\"****** POOL\" LEFT(POOL,7) \"RESTORE JOBCLASS:\" JOBC ,\n        \"VOLCNT:\" VOLCNT;\n     SUMMCTR=SUMMCTR+1;\nEND;\nJCLZ1.0 = 6; /* COUNT OF DUMP JOB STATEMENTS */\nJCLZ1.1 = \"//LOAD1 EXEC PGM=IKJEFT01,DYNAMNBR=32,PARM='%DB2TIACK'\";\nJCLZ1.2 = \"//SYSTSPRT DD SYSOUT=*\";\nJCLZ1.3 = \"//SYSPRINT DD SYSOUT=*\";\nJCLZ1.4 = \"//SYSTSIN DD DUMMY\";\nJCLZ1.5 = \"//SYSPROC DD DSN=SYSS.TECH.COMMON.EXECLIB,DISP=SHR\";\nJCLZ1.6 = \"//SYSIN DD *\";\nJCLZ1.7 =\" INSERT INTO BUILD.TABRVOLS (VOLSER,DUMP_TYPE,DUMP_STATUS)\";\nJCLZ1.8= \"    VALUES('XXXXXX','INCRVOL','ACTIVE');\";\nJCLZ1.9= \" COMMIT;\";\nJCLZ1.10 = \" DELETE FROM BUILD.TABRVOLS WHERE VOLSER='XXXXXX' AND \";\nJCLZ1.11 = \" DUMP_STATUS='PENDING' AND DUMP_TYPE='INCRVOL';\";\nJCLZ1.12= \" COMMIT;\";\nJCLZ1.13= \"/*\";\nJCLZ2.0 = 7; /* COUNT OF DUMP JOB STATEMENTS */\nJCLZ2.1 = \"// IF (RC<=4 & \u00acABEND) THEN\";\nJCLZ2.2 = \"//LOAD2 EXEC PGM=IKJEFT01,DYNAMNBR=32,PARM='%DB2TIACK'\";\nJCLZ2.3 = \"//SYSTSPRT DD SYSOUT=*\";\nJCLZ2.4 = \"//SYSPRINT DD SYSOUT=*\";\nJCLZ2.5 = \"//SYSTSIN DD DUMMY\";\nJCLZ2.6 = \"//SYSPROC DD DSN=SYSS.TECH.COMMON.EXECLIB,DISP=SHR\";\nJCLZ2.7 = \"//SYSIN DD *\";\nJCLZ2.8 = \" UPDATE BUILD.TABRVOLS SET DUMP_STATUS='COMPLETE'\";\nJCLZ2.9 = \"    WHERE VOLSER='XXXXXX' AND DUMP_TYPE='INCRVOL';\";\nJCLZ2.10= \" COMMIT;\";\nJCLZ2.11= \"/*\";\nJCLZ2.12= \"// ENDIF\";\nJCLZ3.0 = 7; /* COUNT OF DUMP JOB STATEMENTS */\nJCLZ3.1 = \"// IF (RC>4 | ABEND) THEN\";\nJCLZ3.2 = \"//LOAD3 EXEC PGM=IKJEFT01,DYNAMNBR=32,PARM='%DB2TIACK'\";\nJCLZ3.3 = \"//SYSTSPRT DD SYSOUT=*\";\nJCLZ3.4 = \"//SYSPRINT DD SYSOUT=*\";\nJCLZ3.5 = \"//SYSTSIN DD DUMMY\";\nJCLZ3.6 = \"//SYSPROC DD DSN=SYSS.TECH.COMMON.EXECLIB,DISP=SHR\";\nJCLZ3.7 = \"//SYSIN DD *\";\nJCLZ3.8 = \" UPDATE BUILD.TABRVOLS SET DUMP_STATUS='FAILURE'\";\nJCLZ3.9 = \"    WHERE VOLSER='XXXXXX' AND DUMP_TYPE='INCRVOL' AND\";\nJCLZ3.10 = \"     DUMP_STATUS='ACTIVE';\";\nJCLZ3.11= \" COMMIT;\";\nJCLZ3.12= \"/*\";\nJCLZ3.13= \"// ENDIF\";\nJCLD.0 = 63; /* COUNT OF DUMP JOB STATEMENTS */\nJCLD.1 = \"//D$XXXXXX JOB 530401053000,'SYSTEM.BACKUP',\";\nJCLD.2 = \"// NOTIFY=TECH251,CLASS=S,MSGCLASS=G\";\nJCLD.3 = \"//LOAD1 EXEC PGM=IKJEFT01,DYNAMNBR=32,PARM='%DB2TIACK'\";\nJCLD.4 = \"//SYSTSPRT DD SYSOUT=*\";\nJCLD.5 = \"//SYSPRINT DD SYSOUT=*\";\nJCLD.6 = \"//SYSTSIN DD DUMMY\";\nJCLD.7 = \"//SYSPROC DD DSN=SYSS.TECH.COMMON.EXECLIB,DISP=SHR\";\nJCLD.8 = \"//SYSIN DD *\";\nJCLD.9 = \" DELETE FROM BUILD.TABRVOLS WHERE VOLSER='XXXXXX' AND \";\nJCLD.10 = \" DUMP_STATUS='PENDING' AND DUMP_TYPE='FULLVOL';\";\nJCLD.11 = \" COMMIT;\";\nJCLD.12 = \" INSERT INTO BUILD.TABRVOLS (VOLSER,DUMP_TYPE,DUMP_STATUS)\";\nJCLD.13 = \"    VALUES('XXXXXX','FULLVOL','ACTIVE');\";\nJCLD.14 = \"//DUMPIT EXEC PGM=FDRABR,REGION=9M\";\nJCLD.15 = \"//SYSPRINT DD SYSOUT=*\";\nJCLD.16 = \"//SYSPRIN1 DD SYSOUT=*\";\nJCLD.17 = \"//DISK1 DD UNIT=XXXX,\";\nJCLD.18 = \"// DISP=SHR,\";\nJCLD.19 = \"// VOL=SER=XXXXXX\";\nJCLD.20=\"//TAPE1 DD DSN=FXXXXXX,DISP=(,KEEP),UNIT=TA80,VOL=(,,,255)\";\nJCLD.21 = \"//SYSUDUMP DD SYSOUT=X\";\nJCLD.22 = \"//SYSIN DD *\";\nJCLD.23 = \" DUMP TYPE=FDR,\";\nJCLD.24 = \"  AUTOUPD=YES,\";\nJCLD.25 = \"  BUFNO=MAX,\";\nJCLD.26 = \"  COMPRESS=ALL,\";\nJCLD.27 = \"  DATA=ALL,\";\nJCLD.28 = \"  DATEP=NONE,\";\nJCLD.29 = \"  DSNENQ=TEST,\";\nJCLD.30 = \"  ENQ=RESERVE,\";\nJCLD.31 = \"  ENQERR=NO,\";\nJCLD.32 = \"  ENQERR=PROCESS,\";\nJCLD.33 = \"  FORMAT=NEW,\";\nJCLD.34 = \"  LBPZERO=INVALID,\";\nJCLD.35 = \"  MAXERR=1,\";\nJCLD.36 = \"  PRINT=ABR,\";\nJCLD.37 = \"  RETPD=9999,\";\nJCLD.38 = \"  SMSCONSTRUCT=NO,\";\nJCLD.39 = \"  SMSMANAGE=NO\";\nJCLD.40 = \"/*\";\nJCLD.41 = \"// IF (RC<=4 & \u00acABEND) THEN\";\nJCLD.42 = \"//LOAD2 EXEC PGM=IKJEFT01,DYNAMNBR=32,PARM='%DB2TIACK'\";\nJCLD.43 = \"//SYSTSPRT DD SYSOUT=*\";\nJCLD.44 = \"//SYSPRINT DD SYSOUT=*\";\nJCLD.45 = \"//SYSTSIN DD DUMMY\";\nJCLD.46 = \"//SYSPROC DD DSN=SYSS.TECH.COMMON.EXECLIB,DISP=SHR\";\nJCLD.47 = \"//SYSIN DD *\";\nJCLD.48 = \" UPDATE BUILD.TABRVOLS SET DUMP_STATUS='COMPLETE'\";\nJCLD.49 = \"    WHERE VOLSER='XXXXXX' AND DUMP_TYPE='FULLVOL';\";\nJCLD.50 = \"/*\";\nJCLD.51 = \"// ENDIF\";\nJCLD.52 = \"// IF (RC>4 | ABEND) THEN\";\nJCLD.53 = \"//LOAD3 EXEC PGM=IKJEFT01,DYNAMNBR=32,PARM='%DB2TIACK'\";\nJCLD.54 = \"//SYSTSPRT DD SYSOUT=*\";\nJCLD.55 = \"//SYSPRINT DD SYSOUT=*\";\nJCLD.56 = \"//SYSTSIN DD DUMMY\";\nJCLD.57 = \"//SYSPROC DD DSN=SYSS.TECH.COMMON.EXECLIB,DISP=SHR\";\nJCLD.58 = \"//SYSIN DD *\";\nJCLD.59 = \" UPDATE BUILD.TABRVOLS SET DUMP_STATUS='FAILURE'\";\nJCLD.60 = \"    WHERE VOLSER='XXXXXX' AND DUMP_TYPE='FULLVOL';\";\nJCLD.61 = \"/*\";\nJCLD.62 = \"// ENDIF\";\nJCLD.63 = \"//\";\nJCLX.0 = 30; /* COUNT OF INCR JOB STATEMENTS */\nJCLX.1 = \"//I$XXXX JOB 530401053000,'SYSTEM.BACKUP',\";\nJCLX.2 = \"// NOTIFY=TECH251,\";\nJCLX.3 = \"// CLASS=S,MSGCLASS=G\";\nJCLX.4 = \"//DUMPIT EXEC PGM=FDRABR,REGION=9M\";\nJCLX.5 = \"//SYSPRIN1 DD SYSOUT=*\";\nJCLX.6 = \"//SYSPRIN2 DD SYSOUT=*\";\nJCLX.7 = \"//SYSPRIN3 DD SYSOUT=*\";\nJCLX.8=\"//TAPE1 DD DSN=I1XXXX,DISP=(,KEEP),UNIT=TA80,VOL=(,,,255)\";\nJCLX.9=\"//TAPE2 DD DSN=I2XXXX,DISP=(,KEEP),UNIT=TA80,VOL=(,,,255)\";\nJCLX.10=\"//TAPE3 DD DSN=I3XXXX,DISP=(,KEEP),UNIT=TA80,VOL=(,,,255)\";\nJCLX.11= \"//SYSPRINT DD SYSOUT=*\";\nJCLX.12 = \"//SYSUDUMP DD SYSOUT=X\";\nJCLX.13 = \"//SYSIN DD *\";\nJCLX.14 = \" DUMP TYPE=ABR,\";\nJCLX.15 = \"  AUTOUPD=YES,\";\nJCLX.16 = \"  BUFNO=MAX,\";\nJCLX.17 = \"  COMPRESS=ALL,\";\nJCLX.18 = \"  DATA=USED,\";\nJCLX.19 = \"  DATEP=NONE,\";\nJCLX.20 = \"  DSNENQ=TEST,\";\nJCLX.21 = \"  ENQ=RESERVE,\";\nJCLX.22 = \"  ENQERR=NO,\";\nJCLX.23 = \"  ENQERR=PROCESS,\";\nJCLX.24 = \"  FORMAT=NEW,\";\nJCLX.25 = \"  LBPZERO=INVALID,\";\nJCLX.26 = \"  MAXERR=1,\";\nJCLX.27 = \"  PRINT=ABR,\";\nJCLX.28 = \"  RETPD=9999,\";\nJCLX.29 = \"  SMSCONSTRUCT=NO,\";\nJCLX.30 = \"  SMSMANAGE=NO\";\nJCLR.0 = 47; /* COUNT OF RESTORE JOB STATEMENTS */\nJCLR.1 = \"//R$XXXXXX JOB 530401053000,'TECH SUPPRT',\";\nJCLR.2 = \"// CLASS=?,MSGCLASS=X,MSGLEVEL=(1,1),REGION=6M\";\nJCLR.3 = \"//JOBLIB DD DSN=IMPORT.LINKLIB1,DISP=SHR\";\nJCLR.4 = \"//ACTIVE EXEC PGM=IKJEFT01,REGION=6M,\";\nJCLR.5= \"// PARM='ALTER ''FDRABR.COMDISCO.WEEKREST.VXXXXXX'' OWNER(I)'\"\nJCLR.6 = \"//SYSTSPRT DD SYSOUT=*\";\nJCLR.7 = \"//SYSTSIN DD DUMMY\";\nJCLR.8 = \"//*\";\nJCLR.9 = \"//*\";\nJCLR.10 = \"//*\";\nJCLR.11 = \"//*\";\nJCLR.12 = \"//*\";\nJCLR.13 = \"//RESTIT EXEC PGM=FDRABR,REGION=6M\";\nJCLR.14 = \"//SYSPRINT DD SYSOUT=*\";\nJCLR.15 = \"//ABRWORK  DD UNIT=SYSALLDA,SPACE=(CYL,(2,1))\";\nJCLR.16 = \"//DISK1 DD UNIT=XXXX,VOL=SER=XXXXXX,DISP=OLD\";\nJCLR.17 = \"//SYSIN DD *\";\nJCLR.18 = \" RESTORE TYPE=FDR,\";\nJCLR.19 = \"   CONFMESS=NO,\";\nJCLR.20 = \"   COPY=1,\";\nJCLR.21 = \"  CPYVOLID=YES,\";\nJCLR.22 = \"  DYNTAPE,\";\nJCLR.23 = \"  MAXERR=1,\";\nJCLR.24 = \"  SMSPROT=NONE,\";\nJCLR.25 = \"  VOLRESET=NO\";\nJCLR.26 = \" SELECT  VOL=XXXXXX,GEN=CURRENT\";\nJCLR.27 = \"/*\";\nJCLR.28 = \"//IXITIT EXEC PGM=ICKDSF,REGION=6M\";\nJCLR.29 = \"//SYSPRINT DD SYSOUT=*\";\nJCLR.30 = \"//DISK1 DD UNIT=XXXX,VOL=SER=XXXXXX,DISP=OLD\";\nJCLR.31 = \"//SYSIN DD *\";\nJCLR.32=\" BUILDIX DDNAME(DISK1) IXVTOC\";\nJCLR.33 = \"//COMPLETE EXEC PGM=IKJEFT01,COND=(0,NE,RESTIT),\";\nJCLR.34=\"// PARM='ALTER ''FDRABR.COMDISCO.WEEKREST.VXXXXXX'' OWNER(C)'\"\nJCLR.35 = \"//SYSTSPRT DD SYSOUT=*\";\nJCLR.36 = \"//SYSTSIN DD DUMMY\";\nJCLR.37 = \"//*\";\nJCLR.38 = \"//*\";\nJCLR.39 = \"//*\";\nJCLR.40 = \"//*\";\nJCLR.41 = \"//*\";\nJCLR.42 = \"//*\";\nJCLR.43 = \"//FAILURE EXEC PGM=IKJEFT01,COND=((0,GE,RESTIT),EVEN),\";\nJCLR.44=\"// PARM='ALTER ''FDRABR.COMDISCO.WEEKREST.VXXXXXX'' OWNER(F)'\"\nJCLR.45 = \"//SYSTSPRT DD SYSOUT=*\";\nJCLR.46 = \"//SYSTSIN DD DUMMY\";\nJCLR.47 = \"//\";\nJCLI.0 = 8; /* COUNT OF INIT JOB STATEMENTS */\nJCLI.1 = \"//I$XXXXXX JOB 530401053000,'TECH SUPPRT',NOTIFY=$CDRS1,\";\nJCLI.2 = \"// CLASS=A,MSGCLASS=X,MSGLEVEL=(1,1)\";\nJCLI.3 = \"//INITIT EXEC PGM=ICKDSF,REGION=6M\";\nJCLI.4 = \"//SYSPRINT DD SYSOUT=*\";\nJCLI.5 = \"//SYSIN DD *\";\nJCLI.6=\" INIT UNIT(XXX) NVFY NCHK INDEX(1,0,15) VTOC(0,1,14) -\";\nJCLI.7 = \"   NOMAP PRG NVAL VOLID(XXXXXX)\";\nJCLI.8 = \"//\";\nJCLC.0 = 7; /* COMPAKTOR */\nJCLC.1 = \"//SYSMAP1 DD SYSOUT=*\";\nJCLC.2 = \"//CPKWORK DD UNIT=VIO,SPACE=(CYL,(1,1))\";\nJCLC.3 = \"//CPIN1 DD *\";\nJCLC.4 = \" CPK TYPE=COMPAKT,ACTMESS=NO,CONFMESS=NO,\";\nJCLC.5 = \"   HI=NO,MAPS=ALL,NOSECOND=NORLSE,\";\nJCLC.6 = \"   O=MAXFREE,OVERRIDE=NO,POR=ALL,\";\nJCLC.7 = \"   T=KEEP,V=NOCHANGE,%FREE=10\";\nHEADTAIL = TRUE;\nCPKCTR = 20;\nSAY \"\";\nSAY \"****** INITIAL RESTORE 3390 UNIT:\" ,\n     INIT_REST_UNIT;\nSAY \"\";\nSUMM.SUMMCTR = \"****** INITIAL RESTORE 3390 UNIT:\" ,\n     INIT_REST_UNIT;\nSUMMCTR=SUMMCTR+1;\n/* LOOP */\nPOOLCTR=WORDS(ABRPOOLS);\nDO ZZ=1 TO POOLCTR;\nJOBC = SUBSTR(CLASSLIST,ZZ,1);\nPOOL=WORD(ABRPOOLS,ZZ);\nPOOLMEM=STRIP(SUBSTR(\"POOL\"POOL,1,8));\nDROP DUMP.;\nDROP INCR.;\nDROP REST.;\nDROP INIT.;\nDUMPCTR=1;\nINCRCTR=1;\nRESTCTR=1;\nINITCTR=1;\n\"FREE F(INIT)\";\n\"FREE F(DUMP)\";\n\"FREE F(INCR)\";\n\"FREE F(REST)\";\n\"ALLOC F(INIT) DA('SYSS.COMDISCO.INITJOBS(\"POOLMEM\")') SHR\";\nIF RC\u00ac=0 THEN EXIT 99;\nIF POOLMEM \u00ac=\"POOLSYSD\" & POOLMEM \u00ac=\"POOLSYST\" THEN DO;\n\"ALLOC F(DUMP) DA('SYSS.COMDISCO.DUMPJOBS(\"POOLMEM\")') SHR\";\nIF RC\u00ac=0 THEN EXIT 99;\nEND;\nIF POOLMEM \u00ac=\"POOLSYSD\" & POOLMEM \u00ac=\"POOLSYST\" THEN DO;\n\"ALLOC F(INCR) DA('SYSS.COMDISCO.INCRJOBS(\"POOLMEM\")') SHR\";\nIF RC\u00ac=0 THEN EXIT 99;\nEND;\nIF POOLMEM \u00ac=\"POOLSYSD\" & POOLMEM \u00ac=\"POOLSYST\" THEN DO;\n\"ALLOC F(REST) DA('SYSS.COMDISCO.RESTJOBS(\"POOLMEM\")') SHR\";\nIF RC\u00ac=0 THEN EXIT 99;\nEND;\nT1=OVERLAY(POOL,JCLX.1,POS('XXXX',JCLX.1));\nDO J = 1 TO 3;\n      IF J=1 THEN INCR.INCRCTR=T1;\n      ELSE INCR.INCRCTR=JCLX.J;\n      INCRCTR=INCRCTR+1;\nEND;\nDO J = 1 TO JCLZ1.0;\n      INCR.INCRCTR=JCLZ1.J;\n      INCRCTR=INCRCTR+1;\nEND;\nXCTR=WORDS(POOLLIST.POOL);\nTRUEVOLC=0;\nDO I = 1 TO XCTR;\n  XVOL=WORD(POOLLIST.POOL,I);\n  TEMP_PACK1 = SUBSTR(XVOL,1,5);\n  TEMP_PACK2 = SUBSTR(XVOL,1,3);\n  IF TEMP_PACK1=\"SYSDA\" | TEMP_PACK1=\"SYSTA\" | TEMP_PACK2=\"DRV\" ,\n     | TEMP_PACK2=\"TEM\" | TEMP_PACK2=\"LAN\" THEN ITERATE;\n  IF XVOL=\"SYS015\" | XVOL=\"SYS007\" | XVOL=\"SYS008\" | XVOL=\"SYS011\" | ,\n     XVOL=\"SYS012\" | XVOL=\"SYS013\" | XVOL=\"SYS014\" THEN ITERATE;\n  INCR.INCRCTR=JCLZ1.7;\n  INCRCTR=INCRCTR+1;\n  INCR.INCRCTR=OVERLAY(XVOL,JCLZ1.8,POS('XXXXXX',JCLZ1.8));\n  INCRCTR=INCRCTR+1;\n  INCR.INCRCTR=JCLZ1.9;\n  INCRCTR=INCRCTR+1;\n  INCR.INCRCTR=OVERLAY(XVOL,JCLZ1.10,POS('XXXXXX',JCLZ1.10));\n  INCRCTR=INCRCTR+1;\n  INCR.INCRCTR=JCLZ1.11;\n  INCRCTR=INCRCTR+1;\n  INCR.INCRCTR=JCLZ1.12;\n  INCRCTR=INCRCTR+1;\n  TRUEVOLC=TRUEVOLC+1;\nEND;\nINCR.INCRCTR=JCLZ1.13;\nINCRCTR=INCRCTR+1;\nT2=OVERLAY(POOL,JCLX.8,POS('XXXX',JCLX.8));\nT3=OVERLAY(POOL,JCLX.9,POS('XXXX',JCLX.9));\nT4=OVERLAY(POOL,JCLX.10,POS('XXXX',JCLX.10));\nDO J = 4 TO JCLX.0;\n      IF J=8 THEN INCR.INCRCTR=T2;\n      ELSE IF J=9 THEN INCR.INCRCTR=T3;\n      ELSE IF J=10 THEN INCR.INCRCTR=T4;\n      ELSE INCR.INCRCTR=JCLX.J;\n      /* TAPE CTR BY VOL CNT LOGIC */\n/*    IF TRUEVOLC>=9 & J=17 THEN ITERATE J;   */\n      IF TRUEVOLC>=9 THEN NOP;\n      ELSE IF TRUEVOLC>=4 & ,\n          (J=7 | J=10) THEN ITERATE J;\n      ELSE IF TRUEVOLC<4 & ,\n          (J=7 | J=10 | J=6 | J=9) THEN ITERATE J;\n      INCRCTR=INCRCTR+1;\n      IF TRUEVOLC>=9 & J=7 THEN DO;\n         INCR.INCRCTR=\"//SYSPRIN4 DD SYSOUT=*\";\n         INCRCTR=INCRCTR+1;\n/*       INCR.INCRCTR=\"//SYSPRIN5 DD SYSOUT=*\";\n         INCRCTR=INCRCTR+1;\n         INCR.INCRCTR=\"//SYSPRIN6 DD SYSOUT=*\";\n         INCRCTR=INCRCTR+1;    */\n      END;\n      IF TRUEVOLC>=9 & J=10 THEN DO;\n      POOLX = LEFT(POOL,4,\"X\"); /* FILL OUT */\nINCR.INCRCTR= ,\n \"//TAPE4 DD DSN=I4\"POOLX\",DISP=(,KEEP),UNIT=TA80,VOL=(,,,255)\"\n         INCRCTR=INCRCTR+1;\n/* INCR.INCRCTR= ,\n \"//TAPE5 DD DSN=I5\"POOLX\",DISP=(,KEEP),UNIT=TA80,VOL=(,,,255)\"\n         INCRCTR=INCRCTR+1;\nINCR.INCRCTR= ,\n \"//TAPE6 DD DSN=I6\"POOLX\",DISP=(,KEEP),UNIT=TA80,VOL=(,,,255)\"\n         INCRCTR=INCRCTR+1;     */\n      END;\nEND;\nXCTR=WORDS(POOLLIST.POOL);\nDO I = 1 TO XCTR;\n  XVOL=WORD(POOLLIST.POOL,I);\n  TEMP_PACK1 = SUBSTR(XVOL,1,5);\n  TEMP_PACK2 = SUBSTR(XVOL,1,3);\n  IF TEMP_PACK1=\"SYSDA\" | TEMP_PACK1=\"SYSTA\" | TEMP_PACK2=\"DRV\" ,\n     | TEMP_PACK2=\"TEM\" | TEMP_PACK2=\"LAN\" THEN ITERATE;\n  /* SKIP SOME INCR */\n  IF XVOL=\"SYS015\" | XVOL=\"SYS007\" | XVOL=\"SYS008\" | XVOL=\"SYS011\" | ,\n     XVOL=\"SYS012\" | XVOL=\"SYS013\" | XVOL=\"SYS014\" THEN ITERATE;\n  INCR.INCRCTR=\" MOUNT VOL=\"XVOL;\n  INCRCTR=INCRCTR+1;\nEND;\nDO J = 1 TO JCLZ2.0;\n      INCR.INCRCTR=JCLZ2.J;\n      INCRCTR=INCRCTR+1;\nEND;\nXCTR=WORDS(POOLLIST.POOL);\nDO I = 1 TO XCTR;\n  XVOL=WORD(POOLLIST.POOL,I);\n  TEMP_PACK1 = SUBSTR(XVOL,1,5);\n  TEMP_PACK2 = SUBSTR(XVOL,1,3);\n  IF TEMP_PACK1=\"SYSDA\" | TEMP_PACK1=\"SYSTA\" | TEMP_PACK2=\"DRV\" ,\n     | TEMP_PACK2=\"TEM\" | TEMP_PACK2=\"LAN\" THEN ITERATE;\n  IF XVOL=\"SYS015\" | XVOL=\"SYS007\" | XVOL=\"SYS008\" | XVOL=\"SYS011\" | ,\n     XVOL=\"SYS012\" | XVOL=\"SYS013\" | XVOL=\"SYS014\" THEN ITERATE;\n  INCR.INCRCTR=JCLZ2.8;\n  INCRCTR=INCRCTR+1;\n  INCR.INCRCTR=OVERLAY(XVOL,JCLZ2.9,POS('XXXXXX',JCLZ2.9));\n  INCRCTR=INCRCTR+1;\n  INCR.INCRCTR=JCLZ2.10;\n  INCRCTR=INCRCTR+1;\nEND;\nINCR.INCRCTR=JCLZ2.11;\nINCRCTR=INCRCTR+1;\nINCR.INCRCTR=JCLZ2.12;\nINCRCTR=INCRCTR+1;\nDO J = 1 TO JCLZ3.0;\n      INCR.INCRCTR=JCLZ3.J;\n      INCRCTR=INCRCTR+1;\nEND;\nXCTR=WORDS(POOLLIST.POOL);\nDO I = 1 TO XCTR;\n  XVOL=WORD(POOLLIST.POOL,I);\n  TEMP_PACK1 = SUBSTR(XVOL,1,5);\n  TEMP_PACK2 = SUBSTR(XVOL,1,3);\n  IF TEMP_PACK1=\"SYSDA\" | TEMP_PACK1=\"SYSTA\" | TEMP_PACK2=\"DRV\" ,\n     | TEMP_PACK2=\"TEM\" | TEMP_PACK2=\"LAN\" THEN ITERATE;\n  IF XVOL=\"SYS015\" | XVOL=\"SYS007\" | XVOL=\"SYS008\" | XVOL=\"SYS011\" | ,\n     XVOL=\"SYS012\" | XVOL=\"SYS013\" | XVOL=\"SYS014\" THEN ITERATE;\n  INCR.INCRCTR=JCLZ3.8;\n  INCRCTR=INCRCTR+1;\n  INCR.INCRCTR=OVERLAY(XVOL,JCLZ3.9,POS('XXXXXX',JCLZ3.9));\n  INCRCTR=INCRCTR+1;\n  INCR.INCRCTR=JCLZ3.10;\n  INCRCTR=INCRCTR+1;\n  INCR.INCRCTR=JCLZ3.11;\n  INCRCTR=INCRCTR+1;\nEND;\nINCR.INCRCTR=JCLZ3.12;\nINCRCTR=INCRCTR+1;\nINCR.INCRCTR=JCLZ3.13;\nINCRCTR=INCRCTR+1;\nINCR.INCRCTR=\"//\";\nINCRCTR=INCRCTR+1;\n DO I = 1 TO DASDV.0;\n  CPK=FALSE;\n  PARSE VAR DASDV.I VOLSER CYLCOUNT FREECYL FRAGINDEX . ;\n  IF VOLSER=\"DUMMY\" THEN ITERATE;\n  IF WORDPOS(VOLSER,POOLLIST.POOL)=0 THEN ITERATE;/*DIFFERENT POOL*/\n  DEVTYPE = DASD.CYLCOUNT;\n  TRUE_DEVTYPE = DASD.CYLCOUNT;\n  IF HEADTAIL THEN DO;\n         HEADTAIL = FALSE; /* ROTATE CUU SELECTION */\n         UNIT = WORD(CDRS.DEVTYPE,1);\n         CDRS.DEVTYPE = DELWORD(CDRS.DEVTYPE,1,1);\n         END;\n  ELSE DO;\n         HEADTAIL = TRUE;  /* ROTATE CUU SELECTION */\n         IF WORDS(CDRS.DEVTYPE)=0 THEN ,\n              UNIT=\"\";\n         ELSE DO;\n           UNIT = WORD(CDRS.DEVTYPE,WORDS(CDRS.DEVTYPE));\n           IF UNIT\u00ac=\"F00\" THEN ,\n           CDRS.DEVTYPE = DELWORD(CDRS.DEVTYPE,WORDS(CDRS.DEVTYPE),1);\n           END;\n         END;\n  TARGET_TYPE=DEVTYPE;\n  IF UNIT=\"\" THEN DO; /* COMDISCO HAS NO MORE */\n       SELECT;\n         WHEN (DEVTYPE=\"3380DJ\") THEN TARGET_TYPE=\"3380E\";\n         WHEN (DEVTYPE=\"3380E\") THEN TARGET_TYPE=\"3380K\";\n         WHEN (DEVTYPE=\"3380K\") THEN EXIT 16; /* EMERGENCY */\n         WHEN (DEVTYPE=\"33902\") THEN TARGET_TYPE=\"33903\";\n         WHEN (DEVTYPE=\"33903\") THEN TARGET_TYPE=\"33906\";\n         WHEN (DEVTYPE=\"33906\") THEN EXIT 20; /* EMERGENCY */\n         OTHERWISE EXIT 24;\n       END;\n       IF TARGET_TYPE=\"3380E\" & WORDS(CDRS.3380E)=0 THEN ,\n            TARGET_TYPE=\"3380K\";\n       IF WORDS(CDRS.TARGET_TYPE)=0 THEN EXIT 28;\n       UNIT = WORD(CDRS.TARGET_TYPE,1);\n       IF UNIT\u00ac=\"F00\" THEN ,\n       CDRS.TARGET_TYPE = DELWORD(CDRS.TARGET_TYPE,1,1);\n       END;\n  DEVTYPE = SUBSTR(DEVTYPE,1,4);\n  TEMP_PACK1 = SUBSTR(VOLSER,1,5);\n  TEMP_PACK2 = SUBSTR(VOLSER,1,3);\n  IF TEMP_PACK1\u00ac=\"SYSDA\" & TEMP_PACK1\u00ac=\"SYSTA\" & TEMP_PACK2\u00ac=\"DRV\" ,\n     & TEMP_PACK2\u00ac=\"TEM\" & TEMP_PACK2\u00ac=\"LAN\" ,\n       THEN DO;\n  T1=OVERLAY(DEVTYPE,JCLD.17,POS('XXXX',JCLD.17));\n  T2=OVERLAY(VOLSER,JCLD.19,POS('XXXXXX',JCLD.19));\n  T3=OVERLAY(VOLSER,JCLD.1,POS('XXXXXX',JCLD.1));\n  T4=OVERLAY(VOLSER,JCLD.20,POS('XXXXXX',JCLD.20));\n  T5=OVERLAY(VOLSER,JCLD.9,POS('XXXXXX',JCLD.9));\n  T7=OVERLAY(VOLSER,JCLD.13,POS('XXXXXX',JCLD.13));\n  T8=OVERLAY(VOLSER,JCLD.49,POS('XXXXXX',JCLD.49));\n  T9=OVERLAY(VOLSER,JCLD.60,POS('XXXXXX',JCLD.60));\n  CDSR= \"'FDRABR.COMDISCO.WEEKREST.V\"VOLSER\"'\";\n  \"ALTER\" CDSR \"OWNER(N)\"; /* NOT ACTIVE */\n  IF RC > 0 THEN ,\n    \"DEFINE NVSAM (NAME(\"CDSR\") DEVT(0000) VOL('******') OWNER(N))\";\n  DO J = 1 TO JCLD.0;\n      IF J=17 THEN DUMP.DUMPCTR=T1;\n      ELSE IF J=19 THEN DUMP.DUMPCTR=T2;\n      ELSE IF J=1 THEN DUMP.DUMPCTR=T3;\n      ELSE IF J=20 THEN DUMP.DUMPCTR=T4;\n      ELSE IF J=9 THEN DUMP.DUMPCTR=T5;\n      ELSE IF J=13 THEN DUMP.DUMPCTR=T7;\n      ELSE IF J=49 THEN DUMP.DUMPCTR=T8;\n      ELSE IF J=60 THEN DUMP.DUMPCTR=T9;\n      ELSE IF J=30 & VOLSER=\"SYS015\" THEN ,\n         DUMP.DUMPCTR=\"  ENQ=OFF,\";\n      ELSE DUMP.DUMPCTR=JCLD.J;\n      IF J=23 & I<=CPKCTR & SUBSTR(VOLSER,1,3)\u00ac=\"MNT\" & ,\n        SUBSTR(VOLSER,1,3)\u00ac=\"SYS\" THEN DO;  /* CANT COMPKT SYS */\n          CPK=TRUE;\n          DUMP.DUMPCTR=DUMP.DUMPCTR||\"COMPAKT,\";\n          END;\n       ELSE IF J=23 THEN CPK=FALSE;\n       ELSE NOP;\n      IF (J=29) & (CPK) THEN DO;\n          DUMP.DUMPCTR=\"  DSNENQ=USE,\";\n          END;\n      DUMPCTR=DUMPCTR+1;\n      IF (J=39) & (CPK) THEN DO;\n           DO Z=1 TO JCLC.0;\n                DUMP.DUMPCTR=JCLC.Z;\n                DUMPCTR=DUMPCTR+1;\n           END;\n         END;\n  END;\n  T1=OVERLAY(DEVTYPE,JCLR.16,POS('XXXX',JCLR.16));\n  T1=OVERLAY(VOLSER,T1,POS('XXXXXX',T1));\n  T2=OVERLAY(VOLSER,JCLR.26,POS('XXXXXX',JCLR.26));\n  T3=OVERLAY(VOLSER,JCLR.1,POS('XXXXXX',JCLR.1));\n  T4=OVERLAY(VOLSER,JCLR.5,POS('XXXXXX',JCLR.5));\n  T5=OVERLAY(VOLSER,JCLR.34,POS('XXXXXX',JCLR.34));\n  T6=OVERLAY(VOLSER,JCLR.44,POS('XXXXXX',JCLR.44));\n  T7=OVERLAY(JOBC,JCLR.2,POS('?',JCLR.2));\n  DO J = 1 TO JCLR.0;\n      IF J=16 THEN REST.RESTCTR=T1;\n      ELSE IF J=26 THEN REST.RESTCTR=T2;\n      ELSE IF J=30 THEN REST.RESTCTR=T1;\n      ELSE IF J=34 THEN REST.RESTCTR=T5;\n      ELSE IF J=44 THEN REST.RESTCTR=T6;\n      ELSE IF J=5 THEN REST.RESTCTR=T4;\n      ELSE IF J=1 THEN REST.RESTCTR=T3;\n      ELSE IF J=2 THEN REST.RESTCTR=T7;\n      ELSE REST.RESTCTR=JCLR.J;\n      RESTCTR=RESTCTR+1;\n  END;\n  END;\n  T1=OVERLAY(UNIT,JCLI.6,POS('XXX',JCLI.6));\n  T2=OVERLAY(VOLSER,JCLI.7,POS('XXXXXX',JCLI.7));\n  T3=OVERLAY(VOLSER,JCLI.1,POS('XXXXXX',JCLI.1));\n IF UNIT\u00ac=\"F00\" THEN DO;\n  DO J = 1 TO JCLI.0;\n      IF J=6 THEN INIT.INITCTR=T1;\n      ELSE IF J=7 THEN INIT.INITCTR=T2;\n      ELSE IF J=1 THEN INIT.INITCTR=T3;\n      ELSE INIT.INITCTR=JCLI.J;\n      INITCTR=INITCTR+1;\n  END;\n END;\n IF UNIT\u00ac=\"F00\" THEN ,\n  SUMM.SUMMCTR = VOLSER \"TYPE\" LEFT(TRUE_DEVTYPE,6) \"MAPPED TO\",\n     \"CDRS UNIT\" UNIT \"TYPE\" TARGET_TYPE;\n ELSE ,\nSUMM.SUMMCTR=\"****** VOLUME\" VOLSER \"NOT INITIALIZED AND/OR RESTORED\";\n  IF VOLSER=\"SYS006\" THEN ,\n       SUMM.SUMMCTR=SUMM.SUMMCTR \"IPL LOADUNIT\" UNIT;\n  IF VOLSER=\"SYS001\" | VOLSER=\"SYS002\" THEN ,\n       SUMM.SUMMCTR=SUMM.SUMMCTR \"LOADPARM\" RIGHT(UNIT,4,\"0\")\"CDM\";\n  SUMMCTR=SUMMCTR+1;\n END I;\nIF POOLMEM \u00ac=\"POOLSYSD\" & POOLMEM \u00ac=\"POOLSYST\" THEN DO;\n \"EXECIO * DISKW DUMP (FINIS STEM DUMP.\";\n \"EXECIO * DISKW INCR (FINIS STEM INCR.\";\n \"EXECIO * DISKW REST (FINIS STEM REST.\";\nEND;\n \"EXECIO * DISKW INIT (FINIS STEM INIT.\";\nEND ZZ;\n\"EXECIO * DISKW SUMM (FINIS STEM SUMM.\";\nEXIT 0;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "OLDSDBL2": {"ttr": 18435, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x06?\\x00\\x94\\x06?\\x18#\\x02\\x94\\x02\\x94\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf7@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-03-04T00:00:00", "modifydate": "1994-03-04T18:23:00", "lines": 660, "newlines": 660, "modlines": 0, "user": "TECH107"}, "text": "/* REXX DASD BUILD ANALYSIS */\nTRUE = \"1\";\nFALSE = \"0\";\nCNTCP = \"1\";\nSUMMCTR=1;\nDASD.0885 = \"3380DJ\";\nDASD.1770 = \"3380E\";\nDASD.2655 = \"3380K\";\nDASD.2226 = \"33902\";\nDASD.3339 = \"33903\";\nDASD.6678 = \"33906\";\nCDRS.3380DJ = \"100 11F 200 21F\";\nCDRS.3380E  = \"480 49F\";\nCDRS.3380K  = \"C40 C5F F00 F00\";\nCDRS.33902  = \"3C0 3FF FC0 FFF\";\nCDRS.33903  = \"EC0 EFF 1C0 1FF\";\nCDRS.33906  = \"F00 F00\"; /* F00 IS END INDICATOR */\nCLASSLIST=\"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\n/* ALPHA LIST */\nABRPOOLS=\"ACIC APPL ART CICS DB2 EMC MNT MVS PLAN \" || ,\n  \"POS PHYS QA RAMI SEQ SMSC SMS SYSDA SYSTA SYS TSO UART USER VSAM\";\n/* LIST BY IMP */\nABRPOOLSR=\"SYS CICS EMC DB2 SMS VSAM ART ACIC UART APPL MVS PLAN \" || ,\n  \"POS QA RAMI SEQ PHYS SMSC TSO USER MNT SYSDA SYSTA\";\nTEMP = \"\";\nDO I = 1 TO WORDS(CDRS.3380DJ) BY 2;\n  LLIM = X2D(WORD(CDRS.3380DJ,I));\n  HLIM = X2D(WORD(CDRS.3380DJ,I+1));\n     DO J = LLIM TO HLIM;\n        TEMP = TEMP D2X(J);\n     END;\nEND;\nCDRS.3380DJ = TEMP;\nTEMP = \"\";\nDO I = 1 TO WORDS(CDRS.3380E) BY 2;\n  LLIM = X2D(WORD(CDRS.3380E,I));\n  HLIM = X2D(WORD(CDRS.3380E,I+1));\n     DO J = LLIM TO HLIM;\n        TEMP = TEMP D2X(J);\n     END;\nEND;\nCDRS.3380E = TEMP;\nTEMP = \"\";\nDO I = 1 TO WORDS(CDRS.3380K) BY 2;\n  LLIM = X2D(WORD(CDRS.3380K,I));\n  HLIM = X2D(WORD(CDRS.3380K,I+1));\n     DO J = LLIM TO HLIM;\n        TEMP = TEMP D2X(J);\n     END;\nEND;\nCDRS.3380K = TEMP;\nTEMP = \"\";\nDO I = 1 TO WORDS(CDRS.33902) BY 2;\n  LLIM = X2D(WORD(CDRS.33902,I));\n  HLIM = X2D(WORD(CDRS.33902,I+1));\n     DO J = LLIM TO HLIM;\n        TEMP = TEMP D2X(J);\n     END;\nEND;\nCDRS.33902 = TEMP;\nTEMP = \"\";\nDO I = 1 TO WORDS(CDRS.33903) BY 2;\n  LLIM = X2D(WORD(CDRS.33903,I));\n  HLIM = X2D(WORD(CDRS.33903,I+1));\n     DO J = LLIM TO HLIM;\n        TEMP = TEMP D2X(J);\n     END;\nEND;\nCDRS.33903 = TEMP;\nTEMP = \"\";\nDO I = 1 TO WORDS(CDRS.33906) BY 2;\n  LLIM = X2D(WORD(CDRS.33906,I));\n  HLIM = X2D(WORD(CDRS.33906,I+1));\n     DO J = LLIM TO HLIM;\n        TEMP = TEMP D2X(J);\n     END;\nEND;\nCDRS.33906 = TEMP;\nINIT_REST_UNIT = WORD(CDRS.33902,1);\nCDRS.33902 = DELWORD(CDRS.33902,1,1);\n\"CALL 'SYS1.TECH.COMMON.LOADLIB(DASDSCAN)'\";\n/* \"CALL 'TECH110.USER.LOADLIB(DASDSCAN)'\"; */\nSAVERC=RC;\nIF SAVERC\u00ac=0 THEN EXIT SAVERC;\n\"EXECIO * DISKR WORK (FINIS STEM DASDV.\";\nCHANGES = TRUE;\nDO WHILE(CHANGES); /* BUBBLE SORT DESCENDING BY FRAG INDEX */\n     CHANGES = FALSE;\n     DO I = 1 TO DASDV.0-1;\n          J = I+1;\n          PARSE VAR DASDV.I . . . FRAGINDEX1 . ;\n          PARSE VAR DASDV.J . . . FRAGINDEX2 . ;\n          IF FRAGINDEX1 < FRAGINDEX2 THEN DO;\n                 TEMP = DASDV.I;\n                 DASDV.I = DASDV.J;\n                 DASDV.J = TEMP;\n                 CHANGES = TRUE;\n                 END;\n     END;\nEND;\nDO I = 1 TO DASDV.0;\n  PARSE VAR DASDV.I VOLSER CYLCOUNT FREECYL FRAGINDEX . ;\n  ABR_BACKUP_DSN = \"'FDRABR.V\"VOLSER\"'\";\n  DUMMY = LISTDSI(ABR_BACKUP_DSN); /* SEE IF DATASET EXISTS */\n  IF DUMMY\u00ac=0 THEN DO;\n       DASDV.I = \"DUMMY\"; /* IGNORE THIS VOLUME */\n       ITERATE I; /* LOOP */\n       END;\n  POOLCTR=WORDS(ABRPOOLS);\n  DO J=1 TO POOLCTR;\n     POOL=WORD(ABRPOOLS,J);\n     IF ABBREV(VOLSER,POOL) THEN DO;\n           IF SYMBOL('POOLLIST.POOL')=\"VAR\" THEN ,\n               POOLLIST.POOL=POOLLIST.POOL VOLSER;\n            ELSE POOLLIST.POOL=VOLSER;\n          LEAVE J;\n         END;\n  END;\nEND;\nABRPOOLS = ABRPOOLSR; /* REORG LIST FOR ORDER TO PROCESS IN */\nDO J=1 TO POOLCTR;\n     POOL=WORD(ABRPOOLS,J);\n     VOLCNT=WORDS(POOLLIST.POOL);\n     JOBC=SUBSTR(CLASSLIST,J,1);\nSUMM.SUMMCTR=\"****** POOL\" LEFT(POOL,7) \"RESTORE JOBCLASS:\" JOBC ,\n        \"VOLCNT:\" VOLCNT;\n     SUMMCTR=SUMMCTR+1;\nEND;\nJCLZ1.0 = 6; /* COUNT OF DUMP JOB STATEMENTS */\nJCLZ1.1 = \"//LOAD1 EXEC PGM=IKJEFT01,DYNAMNBR=32,PARM='%DB2TIACK'\";\nJCLZ1.2 = \"//SYSTSPRT DD SYSOUT=*\";\nJCLZ1.3 = \"//SYSPRINT DD SYSOUT=*\";\nJCLZ1.4 = \"//SYSTSIN DD DUMMY\";\nJCLZ1.5 = \"//SYSPROC DD DSN=SYSS.TECH.COMMON.EXECLIB,DISP=SHR\";\nJCLZ1.6 = \"//SYSIN DD *\";\nJCLZ1.7 =\" INSERT INTO BUILD.TABRVOLS (VOLSER,DUMP_TYPE,DUMP_STATUS)\";\nJCLZ1.8= \"    VALUES('XXXXXX','INCRVOL','ACTIVE');\";\nJCLZ1.9= \" COMMIT;\";\nJCLZ1.10 = \" DELETE FROM BUILD.TABRVOLS WHERE VOLSER='XXXXXX' AND \";\nJCLZ1.11 = \" DUMP_STATUS='PENDING' AND DUMP_TYPE='INCRVOL';\";\nJCLZ1.12= \" COMMIT;\";\nJCLZ1.13= \"/*\";\nJCLZ2.0 = 7; /* COUNT OF DUMP JOB STATEMENTS */\nJCLZ2.1 = \"// IF (RC<=4 & \u00acABEND) THEN\";\nJCLZ2.2 = \"//LOAD2 EXEC PGM=IKJEFT01,DYNAMNBR=32,PARM='%DB2TIACK'\";\nJCLZ2.3 = \"//SYSTSPRT DD SYSOUT=*\";\nJCLZ2.4 = \"//SYSPRINT DD SYSOUT=*\";\nJCLZ2.5 = \"//SYSTSIN DD DUMMY\";\nJCLZ2.6 = \"//SYSPROC DD DSN=SYSS.TECH.COMMON.EXECLIB,DISP=SHR\";\nJCLZ2.7 = \"//SYSIN DD *\";\nJCLZ2.8 = \" UPDATE BUILD.TABRVOLS SET DUMP_STATUS='COMPLETE'\";\nJCLZ2.9 = \"    WHERE VOLSER='XXXXXX' AND DUMP_TYPE='INCRVOL';\";\nJCLZ2.10= \" COMMIT;\";\nJCLZ2.11= \"/*\";\nJCLZ2.12= \"// ENDIF\";\nJCLZ3.0 = 7; /* COUNT OF DUMP JOB STATEMENTS */\nJCLZ3.1 = \"// IF (RC>4 | ABEND) THEN\";\nJCLZ3.2 = \"//LOAD3 EXEC PGM=IKJEFT01,DYNAMNBR=32,PARM='%DB2TIACK'\";\nJCLZ3.3 = \"//SYSTSPRT DD SYSOUT=*\";\nJCLZ3.4 = \"//SYSPRINT DD SYSOUT=*\";\nJCLZ3.5 = \"//SYSTSIN DD DUMMY\";\nJCLZ3.6 = \"//SYSPROC DD DSN=SYSS.TECH.COMMON.EXECLIB,DISP=SHR\";\nJCLZ3.7 = \"//SYSIN DD *\";\nJCLZ3.8 = \" UPDATE BUILD.TABRVOLS SET DUMP_STATUS='FAILURE'\";\nJCLZ3.9 = \"    WHERE VOLSER='XXXXXX' AND DUMP_TYPE='INCRVOL' AND\";\nJCLZ3.10 = \"     DUMP_STATUS='ACTIVE';\";\nJCLZ3.11= \" COMMIT;\";\nJCLZ3.12= \"/*\";\nJCLZ3.13= \"// ENDIF\";\nJCLD.0 = 63; /* COUNT OF DUMP JOB STATEMENTS */\nJCLD.1 = \"//D$XXXXXX JOB 530401053000,'SYSTEM.BACKUP',\";\nJCLD.2 = \"// NOTIFY=TECH251,CLASS=S,MSGCLASS=G\";\nJCLD.3 = \"//LOAD1 EXEC PGM=IKJEFT01,DYNAMNBR=32,PARM='%DB2TIACK'\";\nJCLD.4 = \"//SYSTSPRT DD SYSOUT=*\";\nJCLD.5 = \"//SYSPRINT DD SYSOUT=*\";\nJCLD.6 = \"//SYSTSIN DD DUMMY\";\nJCLD.7 = \"//SYSPROC DD DSN=SYSS.TECH.COMMON.EXECLIB,DISP=SHR\";\nJCLD.8 = \"//SYSIN DD *\";\nJCLD.9 = \" DELETE FROM BUILD.TABRVOLS WHERE VOLSER='XXXXXX' AND \";\nJCLD.10 = \" DUMP_STATUS='PENDING' AND DUMP_TYPE='FULLVOL';\";\nJCLD.11 = \" COMMIT;\";\nJCLD.12 = \" INSERT INTO BUILD.TABRVOLS (VOLSER,DUMP_TYPE,DUMP_STATUS)\";\nJCLD.13 = \"    VALUES('XXXXXX','FULLVOL','ACTIVE');\";\nJCLD.14 = \"//DUMPIT EXEC PGM=FDRABR,REGION=9M\";\nJCLD.15 = \"//SYSPRINT DD SYSOUT=*\";\nJCLD.16 = \"//SYSPRIN1 DD SYSOUT=*\";\nJCLD.17 = \"//DISK1 DD UNIT=XXXX,\";\nJCLD.18 = \"// DISP=SHR,\";\nJCLD.19 = \"// VOL=SER=XXXXXX\";\nJCLD.20=\"//TAPE1 DD DSN=FXXXXXX,DISP=(,KEEP),UNIT=TA80,VOL=(,,,255)\";\nJCLD.21 = \"//SYSUDUMP DD SYSOUT=X\";\nJCLD.22 = \"//SYSIN DD *\";\nJCLD.23 = \" DUMP TYPE=FDR,\";\nJCLD.24 = \"  AUTOUPD=YES,\";\nJCLD.25 = \"  BUFNO=MAX,\";\nJCLD.26 = \"  COMPRESS=ALL,\";\nJCLD.27 = \"  DATA=ALL,\";\nJCLD.28 = \"  DATEP=NONE,\";\nJCLD.29 = \"  DSNENQ=TEST,\";\nJCLD.30 = \"  ENQ=RESERVE,\";\nJCLD.31 = \"  ENQERR=NO,\";\nJCLD.32 = \"  ENQERR=PROCESS,\";\nJCLD.33 = \"  FORMAT=NEW,\";\nJCLD.34 = \"  LBPZERO=INVALID,\";\nJCLD.35 = \"  MAXERR=1,\";\nJCLD.36 = \"  PRINT=ABR,\";\nJCLD.37 = \"  RETPD=9999,\";\nJCLD.38 = \"  SMSCONSTRUCT=NO,\";\nJCLD.39 = \"  SMSMANAGE=NO\";\nJCLD.40 = \"/*\";\nJCLD.41 = \"// IF (RC<=4 & \u00acABEND) THEN\";\nJCLD.42 = \"//LOAD2 EXEC PGM=IKJEFT01,DYNAMNBR=32,PARM='%DB2TIACK'\";\nJCLD.43 = \"//SYSTSPRT DD SYSOUT=*\";\nJCLD.44 = \"//SYSPRINT DD SYSOUT=*\";\nJCLD.45 = \"//SYSTSIN DD DUMMY\";\nJCLD.46 = \"//SYSPROC DD DSN=SYSS.TECH.COMMON.EXECLIB,DISP=SHR\";\nJCLD.47 = \"//SYSIN DD *\";\nJCLD.48 = \" UPDATE BUILD.TABRVOLS SET DUMP_STATUS='COMPLETE'\";\nJCLD.49 = \"    WHERE VOLSER='XXXXXX' AND DUMP_TYPE='FULLVOL';\";\nJCLD.50 = \"/*\";\nJCLD.51 = \"// ENDIF\";\nJCLD.52 = \"// IF (RC>4 | ABEND) THEN\";\nJCLD.53 = \"//LOAD3 EXEC PGM=IKJEFT01,DYNAMNBR=32,PARM='%DB2TIACK'\";\nJCLD.54 = \"//SYSTSPRT DD SYSOUT=*\";\nJCLD.55 = \"//SYSPRINT DD SYSOUT=*\";\nJCLD.56 = \"//SYSTSIN DD DUMMY\";\nJCLD.57 = \"//SYSPROC DD DSN=SYSS.TECH.COMMON.EXECLIB,DISP=SHR\";\nJCLD.58 = \"//SYSIN DD *\";\nJCLD.59 = \" UPDATE BUILD.TABRVOLS SET DUMP_STATUS='FAILURE'\";\nJCLD.60 = \"    WHERE VOLSER='XXXXXX' AND DUMP_TYPE='FULLVOL';\";\nJCLD.61 = \"/*\";\nJCLD.62 = \"// ENDIF\";\nJCLD.63 = \"//\";\nJCLX.0 = 30; /* COUNT OF INCR JOB STATEMENTS */\nJCLX.1 = \"//I$XXXX JOB 530401053000,'SYSTEM.BACKUP',\";\nJCLX.2 = \"// NOTIFY=TECH251,\";\nJCLX.3 = \"// CLASS=S,MSGCLASS=G\";\nJCLX.4 = \"//DUMPIT EXEC PGM=FDRABR,REGION=9M\";\nJCLX.5 = \"//SYSPRIN1 DD SYSOUT=*\";\nJCLX.6 = \"//SYSPRIN2 DD SYSOUT=*\";\nJCLX.7 = \"//SYSPRIN3 DD SYSOUT=*\";\nJCLX.8=\"//TAPE1 DD DSN=I1XXXX,DISP=(,KEEP),UNIT=TA80,VOL=(,,,255)\";\nJCLX.9=\"//TAPE2 DD DSN=I2XXXX,DISP=(,KEEP),UNIT=TA80,VOL=(,,,255)\";\nJCLX.10=\"//TAPE3 DD DSN=I3XXXX,DISP=(,KEEP),UNIT=TA80,VOL=(,,,255)\";\nJCLX.11= \"//SYSPRINT DD SYSOUT=*\";\nJCLX.12 = \"//SYSUDUMP DD SYSOUT=X\";\nJCLX.13 = \"//SYSIN DD *\";\nJCLX.14 = \" DUMP TYPE=ABR,\";\nJCLX.15 = \"  AUTOUPD=YES,\";\nJCLX.16 = \"  BUFNO=MAX,\";\nJCLX.17 = \"  COMPRESS=ALL,\";\nJCLX.18 = \"  DATA=USED,\";\nJCLX.19 = \"  DATEP=NONE,\";\nJCLX.20 = \"  DSNENQ=TEST,\";\nJCLX.21 = \"  ENQ=RESERVE,\";\nJCLX.22 = \"  ENQERR=NO,\";\nJCLX.23 = \"  ENQERR=PROCESS,\";\nJCLX.24 = \"  FORMAT=NEW,\";\nJCLX.25 = \"  LBPZERO=INVALID,\";\nJCLX.26 = \"  MAXERR=1,\";\nJCLX.27 = \"  PRINT=ABR,\";\nJCLX.28 = \"  RETPD=9999,\";\nJCLX.29 = \"  SMSCONSTRUCT=NO,\";\nJCLX.30 = \"  SMSMANAGE=NO\";\nJCLR.0 = 47; /* COUNT OF RESTORE JOB STATEMENTS */\nJCLR.1 = \"//R$XXXXXX JOB 530401053000,'TECH SUPPRT',\";\nJCLR.2 = \"// CLASS=?,MSGCLASS=X,MSGLEVEL=(1,1),REGION=6M\";\nJCLR.3 = \"//JOBLIB DD DSN=IMPORT.LINKLIB1,DISP=SHR\";\nJCLR.4 = \"//ACTIVE EXEC PGM=IKJEFT01,REGION=6M,\";\nJCLR.5= \"// PARM='ALTER ''FDRABR.COMDISCO.WEEKREST.VXXXXXX'' OWNER(I)'\"\nJCLR.6 = \"//SYSTSPRT DD SYSOUT=*\";\nJCLR.7 = \"//SYSTSIN DD DUMMY\";\nJCLR.8 = \"//*\";\nJCLR.9 = \"//*\";\nJCLR.10 = \"//*\";\nJCLR.11 = \"//*\";\nJCLR.12 = \"//*\";\nJCLR.13 = \"//RESTIT EXEC PGM=FDRABR,REGION=6M\";\nJCLR.14 = \"//SYSPRINT DD SYSOUT=*\";\nJCLR.15 = \"//ABRWORK  DD UNIT=SYSALLDA,SPACE=(CYL,(2,1))\";\nJCLR.16 = \"//DISK1 DD UNIT=XXXX,VOL=SER=XXXXXX,DISP=OLD\";\nJCLR.17 = \"//SYSIN DD *\";\nJCLR.18 = \" RESTORE TYPE=FDR,\";\nJCLR.19 = \"   CONFMESS=NO,\";\nJCLR.20 = \"   COPY=1,\";\nJCLR.21 = \"  CPYVOLID=YES,\";\nJCLR.22 = \"  DYNTAPE,\";\nJCLR.23 = \"  MAXERR=1,\";\nJCLR.24 = \"  SMSPROT=NONE,\";\nJCLR.25 = \"  VOLRESET=NO\";\nJCLR.26 = \" SELECT  VOL=XXXXXX,GEN=CURRENT\";\nJCLR.27 = \"/*\";\nJCLR.28 = \"//IXITIT EXEC PGM=ICKDSF,REGION=6M\";\nJCLR.29 = \"//SYSPRINT DD SYSOUT=*\";\nJCLR.30 = \"//DISK1 DD UNIT=XXXX,VOL=SER=XXXXXX,DISP=OLD\";\nJCLR.31 = \"//SYSIN DD *\";\nJCLR.32=\" BUILDIX DDNAME(DISK1) IXVTOC\";\nJCLR.33 = \"//COMPLETE EXEC PGM=IKJEFT01,COND=(0,NE,RESTIT),\";\nJCLR.34=\"// PARM='ALTER ''FDRABR.COMDISCO.WEEKREST.VXXXXXX'' OWNER(C)'\"\nJCLR.35 = \"//SYSTSPRT DD SYSOUT=*\";\nJCLR.36 = \"//SYSTSIN DD DUMMY\";\nJCLR.37 = \"//*\";\nJCLR.38 = \"//*\";\nJCLR.39 = \"//*\";\nJCLR.40 = \"//*\";\nJCLR.41 = \"//*\";\nJCLR.42 = \"//*\";\nJCLR.43 = \"//FAILURE EXEC PGM=IKJEFT01,COND=((0,GE,RESTIT),EVEN),\";\nJCLR.44=\"// PARM='ALTER ''FDRABR.COMDISCO.WEEKREST.VXXXXXX'' OWNER(F)'\"\nJCLR.45 = \"//SYSTSPRT DD SYSOUT=*\";\nJCLR.46 = \"//SYSTSIN DD DUMMY\";\nJCLR.47 = \"//\";\nJCLI.0 = 8; /* COUNT OF INIT JOB STATEMENTS */\nJCLI.1 = \"//I$XXXXXX JOB 530401053000,'TECH SUPPRT',NOTIFY=$CDRS1,\";\nJCLI.2 = \"// CLASS=A,MSGCLASS=X,MSGLEVEL=(1,1)\";\nJCLI.3 = \"//INITIT EXEC PGM=ICKDSF,REGION=6M\";\nJCLI.4 = \"//SYSPRINT DD SYSOUT=*\";\nJCLI.5 = \"//SYSIN DD *\";\nJCLI.6=\" INIT UNIT(XXX) NVFY NCHK INDEX(1,0,15) VTOC(0,1,14) -\";\nJCLI.7 = \"   NOMAP PRG NVAL VOLID(XXXXXX)\";\nJCLI.8 = \"//\";\nJCLC.0 = 14; /* COMPAKTOR */\nJCLC.1 = \"/*\"\nJCLC.2 = \"// IF (DUMPIT.RC<=4 & \u00acABEND) THEN\"\nJCLC.3 = \"//CPKIT  EXEC PGM=FDRCPK,REGION=9M\"\nJCLC.4 = \"//SYSPRINT DD SYSOUT=*\"\nJCLC.5 = \"//SYSMAP   DD SYSOUT=*\"\nJCLC.6 = \"//SYSSUMM  DD SYSOUT=*\"\nJCLC.7 = \"//SYSUDUMP DD SYSOUT=X\"\nJCLC.8 = \"//SYSIN DD *\"\nJCLC.9 = \" CPK TYPE=FASTCPK,VOL=(XXXXXX),ACTMESS=NO,CONFMESS=NO,\"\nJCLC.10= \" HI=NO,MAPS=SUMMARY,NOSECOND=NORLSE,ENQ=RESERVE,DSNENQ=USE,\"\nJCLC.11 =\" O=MAXFREE,PSRLSE=ALL,UNABLE=IGNORE,\"\nJCLC.12 =\" T=KEEP,V=NOCHANGE\"\nJCLC.13 =\"/*\"\nJCLC.14 =\"// ENDIF\"\nHEADTAIL = TRUE;\nCPKCTR = 20;\nSAY \"\";\nSAY \"****** INITIAL RESTORE 3390 UNIT:\" ,\n     INIT_REST_UNIT;\nSAY \"\";\nSUMM.SUMMCTR = \"****** INITIAL RESTORE 3390 UNIT:\" ,\n     INIT_REST_UNIT;\nSUMMCTR=SUMMCTR+1;\n/* LOOP */\nPOOLCTR=WORDS(ABRPOOLS);\nDO ZZ=1 TO POOLCTR;\nJOBC = SUBSTR(CLASSLIST,ZZ,1);\nPOOL=WORD(ABRPOOLS,ZZ);\nPOOLMEM=STRIP(SUBSTR(\"POOL\"POOL,1,8));\nDROP DUMP.;\nDROP INCR.;\nDROP REST.;\nDROP INIT.;\nDUMPCTR=1;\nINCRCTR=1;\nRESTCTR=1;\nINITCTR=1;\n\"FREE F(INIT)\";\n\"FREE F(DUMP)\";\n\"FREE F(INCR)\";\n\"FREE F(REST)\";\n\"ALLOC F(INIT) DA('SYSS.COMDISCO.INITJOBS(\"POOLMEM\")') SHR\";\nIF RC\u00ac=0 THEN EXIT 99;\nIF POOLMEM \u00ac=\"POOLSYSD\" & POOLMEM \u00ac=\"POOLSYST\" THEN DO;\n\"ALLOC F(DUMP) DA('SYSS.COMDISCO.DUMPJOBS(\"POOLMEM\")') SHR\";\nIF RC\u00ac=0 THEN EXIT 99;\nEND;\nIF POOLMEM \u00ac=\"POOLSYSD\" & POOLMEM \u00ac=\"POOLSYST\" THEN DO;\n\"ALLOC F(INCR) DA('SYSS.COMDISCO.INCRJOBS(\"POOLMEM\")') SHR\";\nIF RC\u00ac=0 THEN EXIT 99;\nEND;\nIF POOLMEM \u00ac=\"POOLSYSD\" & POOLMEM \u00ac=\"POOLSYST\" THEN DO;\n\"ALLOC F(REST) DA('SYSS.COMDISCO.RESTJOBS(\"POOLMEM\")') SHR\";\nIF RC\u00ac=0 THEN EXIT 99;\nEND;\nT1=OVERLAY(POOL,JCLX.1,POS('XXXX',JCLX.1));\nDO J = 1 TO 3;\n      IF J=1 THEN INCR.INCRCTR=T1;\n      ELSE INCR.INCRCTR=JCLX.J;\n      INCRCTR=INCRCTR+1;\nEND;\nDO J = 1 TO JCLZ1.0;\n      INCR.INCRCTR=JCLZ1.J;\n      INCRCTR=INCRCTR+1;\nEND;\nXCTR=WORDS(POOLLIST.POOL);\nTRUEVOLC=0;\nDO I = 1 TO XCTR;\n  XVOL=WORD(POOLLIST.POOL,I);\n  TEMP_PACK1 = SUBSTR(XVOL,1,5);\n  TEMP_PACK2 = SUBSTR(XVOL,1,3);\n  IF TEMP_PACK1=\"SYSDA\" | TEMP_PACK1=\"SYSTA\" | TEMP_PACK2=\"DRV\" ,\n     | TEMP_PACK2=\"TEM\" | TEMP_PACK2=\"LAN\" THEN ITERATE;\n  IF XVOL=\"SYS015\" | XVOL=\"SYS007\" | XVOL=\"SYS008\" | XVOL=\"SYS011\" | ,\n     XVOL=\"SYS012\" | XVOL=\"SYS013\" | XVOL=\"SYS014\" THEN ITERATE;\n  INCR.INCRCTR=JCLZ1.7;\n  INCRCTR=INCRCTR+1;\n  INCR.INCRCTR=OVERLAY(XVOL,JCLZ1.8,POS('XXXXXX',JCLZ1.8));\n  INCRCTR=INCRCTR+1;\n  INCR.INCRCTR=JCLZ1.9;\n  INCRCTR=INCRCTR+1;\n  INCR.INCRCTR=OVERLAY(XVOL,JCLZ1.10,POS('XXXXXX',JCLZ1.10));\n  INCRCTR=INCRCTR+1;\n  INCR.INCRCTR=JCLZ1.11;\n  INCRCTR=INCRCTR+1;\n  INCR.INCRCTR=JCLZ1.12;\n  INCRCTR=INCRCTR+1;\n  TRUEVOLC=TRUEVOLC+1;\nEND;\nINCR.INCRCTR=JCLZ1.13;\nINCRCTR=INCRCTR+1;\nT2=OVERLAY(POOL,JCLX.8,POS('XXXX',JCLX.8));\nT3=OVERLAY(POOL,JCLX.9,POS('XXXX',JCLX.9));\nT4=OVERLAY(POOL,JCLX.10,POS('XXXX',JCLX.10));\nDO J = 4 TO JCLX.0;\n      IF J=8 THEN INCR.INCRCTR=T2;\n      ELSE IF J=9 THEN INCR.INCRCTR=T3;\n      ELSE IF J=10 THEN INCR.INCRCTR=T4;\n      ELSE INCR.INCRCTR=JCLX.J;\n      /* TAPE CTR BY VOL CNT LOGIC */\n/*    IF TRUEVOLC>=9 & J=17 THEN ITERATE J;   */\n      IF TRUEVOLC>=9 THEN NOP;\n      ELSE IF TRUEVOLC>=4 & ,\n          (J=7 | J=10) THEN ITERATE J;\n      ELSE IF TRUEVOLC<4 & ,\n          (J=7 | J=10 | J=6 | J=9) THEN ITERATE J;\n      INCRCTR=INCRCTR+1;\n      IF TRUEVOLC>=9 & J=7 THEN DO;\n         INCR.INCRCTR=\"//SYSPRIN4 DD SYSOUT=*\";\n         INCRCTR=INCRCTR+1;\n/*       INCR.INCRCTR=\"//SYSPRIN5 DD SYSOUT=*\";\n         INCRCTR=INCRCTR+1;\n         INCR.INCRCTR=\"//SYSPRIN6 DD SYSOUT=*\";\n         INCRCTR=INCRCTR+1;    */\n      END;\n      IF TRUEVOLC>=9 & J=10 THEN DO;\n      POOLX = LEFT(POOL,4,\"X\"); /* FILL OUT */\nINCR.INCRCTR= ,\n \"//TAPE4 DD DSN=I4\"POOLX\",DISP=(,KEEP),UNIT=TA80,VOL=(,,,255)\"\n         INCRCTR=INCRCTR+1;\n/* INCR.INCRCTR= ,\n \"//TAPE5 DD DSN=I5\"POOLX\",DISP=(,KEEP),UNIT=TA80,VOL=(,,,255)\"\n         INCRCTR=INCRCTR+1;\nINCR.INCRCTR= ,\n \"//TAPE6 DD DSN=I6\"POOLX\",DISP=(,KEEP),UNIT=TA80,VOL=(,,,255)\"\n         INCRCTR=INCRCTR+1;     */\n      END;\nEND;\nXCTR=WORDS(POOLLIST.POOL);\nDO I = 1 TO XCTR;\n  XVOL=WORD(POOLLIST.POOL,I);\n  TEMP_PACK1 = SUBSTR(XVOL,1,5);\n  TEMP_PACK2 = SUBSTR(XVOL,1,3);\n  IF TEMP_PACK1=\"SYSDA\" | TEMP_PACK1=\"SYSTA\" | TEMP_PACK2=\"DRV\" ,\n     | TEMP_PACK2=\"TEM\" | TEMP_PACK2=\"LAN\" THEN ITERATE;\n  /* SKIP SOME INCR */\n  IF XVOL=\"SYS015\" | XVOL=\"SYS007\" | XVOL=\"SYS008\" | XVOL=\"SYS011\" | ,\n     XVOL=\"SYS012\" | XVOL=\"SYS013\" | XVOL=\"SYS014\" THEN ITERATE;\n  INCR.INCRCTR=\" MOUNT VOL=\"XVOL;\n  INCRCTR=INCRCTR+1;\nEND;\nDO J = 1 TO JCLZ2.0;\n      INCR.INCRCTR=JCLZ2.J;\n      INCRCTR=INCRCTR+1;\nEND;\nXCTR=WORDS(POOLLIST.POOL);\nDO I = 1 TO XCTR;\n  XVOL=WORD(POOLLIST.POOL,I);\n  TEMP_PACK1 = SUBSTR(XVOL,1,5);\n  TEMP_PACK2 = SUBSTR(XVOL,1,3);\n  IF TEMP_PACK1=\"SYSDA\" | TEMP_PACK1=\"SYSTA\" | TEMP_PACK2=\"DRV\" ,\n     | TEMP_PACK2=\"TEM\" | TEMP_PACK2=\"LAN\" THEN ITERATE;\n  IF XVOL=\"SYS015\" | XVOL=\"SYS007\" | XVOL=\"SYS008\" | XVOL=\"SYS011\" | ,\n     XVOL=\"SYS012\" | XVOL=\"SYS013\" | XVOL=\"SYS014\" THEN ITERATE;\n  INCR.INCRCTR=JCLZ2.8;\n  INCRCTR=INCRCTR+1;\n  INCR.INCRCTR=OVERLAY(XVOL,JCLZ2.9,POS('XXXXXX',JCLZ2.9));\n  INCRCTR=INCRCTR+1;\n  INCR.INCRCTR=JCLZ2.10;\n  INCRCTR=INCRCTR+1;\nEND;\nINCR.INCRCTR=JCLZ2.11;\nINCRCTR=INCRCTR+1;\nINCR.INCRCTR=JCLZ2.12;\nINCRCTR=INCRCTR+1;\nDO J = 1 TO JCLZ3.0;\n      INCR.INCRCTR=JCLZ3.J;\n      INCRCTR=INCRCTR+1;\nEND;\nXCTR=WORDS(POOLLIST.POOL);\nDO I = 1 TO XCTR;\n  XVOL=WORD(POOLLIST.POOL,I);\n  TEMP_PACK1 = SUBSTR(XVOL,1,5);\n  TEMP_PACK2 = SUBSTR(XVOL,1,3);\n  IF TEMP_PACK1=\"SYSDA\" | TEMP_PACK1=\"SYSTA\" | TEMP_PACK2=\"DRV\" ,\n     | TEMP_PACK2=\"TEM\" | TEMP_PACK2=\"LAN\" THEN ITERATE;\n  IF XVOL=\"SYS015\" | XVOL=\"SYS007\" | XVOL=\"SYS008\" | XVOL=\"SYS011\" | ,\n     XVOL=\"SYS012\" | XVOL=\"SYS013\" | XVOL=\"SYS014\" THEN ITERATE;\n  INCR.INCRCTR=JCLZ3.8;\n  INCRCTR=INCRCTR+1;\n  INCR.INCRCTR=OVERLAY(XVOL,JCLZ3.9,POS('XXXXXX',JCLZ3.9));\n  INCRCTR=INCRCTR+1;\n  INCR.INCRCTR=JCLZ3.10;\n  INCRCTR=INCRCTR+1;\n  INCR.INCRCTR=JCLZ3.11;\n  INCRCTR=INCRCTR+1;\nEND;\nINCR.INCRCTR=JCLZ3.12;\nINCRCTR=INCRCTR+1;\nINCR.INCRCTR=JCLZ3.13;\nINCRCTR=INCRCTR+1;\nINCR.INCRCTR=\"//\";\nINCRCTR=INCRCTR+1;\n DO I = 1 TO DASDV.0;\n  CPK=FALSE;\n  PARSE VAR DASDV.I VOLSER CYLCOUNT FREECYL FRAGINDEX . ;\n  IF VOLSER=\"DUMMY\" THEN ITERATE;\n  IF WORDPOS(VOLSER,POOLLIST.POOL)=0 THEN ITERATE;/*DIFFERENT POOL*/\n  DEVTYPE = DASD.CYLCOUNT;\n  TRUE_DEVTYPE = DASD.CYLCOUNT;\n  IF HEADTAIL THEN DO;\n         HEADTAIL = FALSE; /* ROTATE CUU SELECTION */\n         UNIT = WORD(CDRS.DEVTYPE,1);\n         CDRS.DEVTYPE = DELWORD(CDRS.DEVTYPE,1,1);\n         END;\n  ELSE DO;\n         HEADTAIL = TRUE;  /* ROTATE CUU SELECTION */\n         IF WORDS(CDRS.DEVTYPE)=0 THEN ,\n              UNIT=\"\";\n         ELSE DO;\n           UNIT = WORD(CDRS.DEVTYPE,WORDS(CDRS.DEVTYPE));\n           IF UNIT\u00ac=\"F00\" THEN ,\n           CDRS.DEVTYPE = DELWORD(CDRS.DEVTYPE,WORDS(CDRS.DEVTYPE),1);\n           END;\n         END;\n  TARGET_TYPE=DEVTYPE;\n  IF UNIT=\"\" THEN DO; /* COMDISCO HAS NO MORE */\n       SELECT;\n         WHEN (DEVTYPE=\"3380DJ\") THEN TARGET_TYPE=\"3380E\";\n         WHEN (DEVTYPE=\"3380E\") THEN TARGET_TYPE=\"3380K\";\n         WHEN (DEVTYPE=\"3380K\") THEN EXIT 16; /* EMERGENCY */\n         WHEN (DEVTYPE=\"33902\") THEN TARGET_TYPE=\"33903\";\n         WHEN (DEVTYPE=\"33903\") THEN TARGET_TYPE=\"33906\";\n         WHEN (DEVTYPE=\"33906\") THEN EXIT 20; /* EMERGENCY */\n         OTHERWISE EXIT 24;\n       END;\n       IF TARGET_TYPE=\"3380E\" & WORDS(CDRS.3380E)=0 THEN ,\n            TARGET_TYPE=\"3380K\";\n       IF WORDS(CDRS.TARGET_TYPE)=0 THEN EXIT 28;\n       UNIT = WORD(CDRS.TARGET_TYPE,1);\n       IF UNIT\u00ac=\"F00\" THEN ,\n       CDRS.TARGET_TYPE = DELWORD(CDRS.TARGET_TYPE,1,1);\n       END;\n  DEVTYPE = SUBSTR(DEVTYPE,1,4);\n  TEMP_PACK1 = SUBSTR(VOLSER,1,5);\n  TEMP_PACK2 = SUBSTR(VOLSER,1,3);\n  IF TEMP_PACK1\u00ac=\"SYSDA\" & TEMP_PACK1\u00ac=\"SYSTA\" & TEMP_PACK2\u00ac=\"DRV\" ,\n     & TEMP_PACK2\u00ac=\"TEM\" & TEMP_PACK2\u00ac=\"LAN\" ,\n       THEN DO;\n  T1=OVERLAY(DEVTYPE,JCLD.17,POS('XXXX',JCLD.17));\n  T2=OVERLAY(VOLSER,JCLD.19,POS('XXXXXX',JCLD.19));\n  T3=OVERLAY(VOLSER,JCLD.1,POS('XXXXXX',JCLD.1));\n  T4=OVERLAY(VOLSER,JCLD.20,POS('XXXXXX',JCLD.20));\n  T5=OVERLAY(VOLSER,JCLD.9,POS('XXXXXX',JCLD.9));\n  T7=OVERLAY(VOLSER,JCLD.13,POS('XXXXXX',JCLD.13));\n  T8=OVERLAY(VOLSER,JCLD.49,POS('XXXXXX',JCLD.49));\n  T9=OVERLAY(VOLSER,JCLD.60,POS('XXXXXX',JCLD.60));\n  T10=OVERLAY(VOLSER,JCLC.9,POS('XXXXXX',JCLC.9));\n  CDSR= \"'FDRABR.COMDISCO.WEEKREST.V\"VOLSER\"'\";\n     \"ALTER\" CDSR \"OWNER(N)\";\n  IF RC > 0 THEN ,\n    \"DEFINE NVSAM (NAME(\"CDSR\") DEVT(0000) VOL('******') OWNER(N))\";\n  DO J = 1 TO JCLD.0;\n      IF J=17 THEN DUMP.DUMPCTR=T1;\n      ELSE IF J=19 THEN DUMP.DUMPCTR=T2;\n      ELSE IF J=1 THEN DUMP.DUMPCTR=T3;\n      ELSE IF J=20 THEN DUMP.DUMPCTR=T4;\n      ELSE IF J=9 THEN DUMP.DUMPCTR=T5;\n      ELSE IF J=13 THEN DUMP.DUMPCTR=T7;\n      ELSE IF J=49 THEN DUMP.DUMPCTR=T8;\n      ELSE IF J=60 THEN DUMP.DUMPCTR=T9;\n      ELSE IF J=30 & VOLSER=\"SYS015\" THEN ,\n         DUMP.DUMPCTR=\"  ENQ=OFF,\";\n      ELSE DUMP.DUMPCTR=JCLD.J;\n    /* CHANGE */\n      IF J=23 & CNTCP<=CPKCTR & ,\n        SUBSTR(VOLSER,1,3)\u00ac=\"MNT\" & ,\n        SUBSTR(VOLSER,1,3)\u00ac=\"SYS\" THEN DO;  /* CANT COMPKT SYS */\n          CNTCP = CNTCP + 1;\n          CPK=TRUE;\n          END;\n       ELSE IF J=23 THEN CPK=FALSE;\n       ELSE NOP;\n      IF J=40 & (CPK) THEN ITERATE J ;\n      ELSE NOP;\n      DUMPCTR=DUMPCTR+1;\n      IF (J=39) & (CPK) THEN DO;\n           DO Z=1 TO JCLC.0;\n                DUMP.DUMPCTR=JCLC.Z;\n    /* CHANGE */\n                IF Z=9 THEN DUMP.DUMPCTR= T10;\n                DUMPCTR=DUMPCTR+1;\n           END;\n         END;\n  END;\n  T1=OVERLAY(DEVTYPE,JCLR.16,POS('XXXX',JCLR.16));\n  T1=OVERLAY(VOLSER,T1,POS('XXXXXX',T1));\n  T2=OVERLAY(VOLSER,JCLR.26,POS('XXXXXX',JCLR.26));\n  T3=OVERLAY(VOLSER,JCLR.1,POS('XXXXXX',JCLR.1));\n  T4=OVERLAY(VOLSER,JCLR.5,POS('XXXXXX',JCLR.5));\n  T5=OVERLAY(VOLSER,JCLR.34,POS('XXXXXX',JCLR.34));\n  T6=OVERLAY(VOLSER,JCLR.44,POS('XXXXXX',JCLR.44));\n  T7=OVERLAY(JOBC,JCLR.2,POS('?',JCLR.2));\n  DO J = 1 TO JCLR.0;\n      IF J=16 THEN REST.RESTCTR=T1;\n      ELSE IF J=26 THEN REST.RESTCTR=T2;\n      ELSE IF J=30 THEN REST.RESTCTR=T1;\n      ELSE IF J=34 THEN REST.RESTCTR=T5;\n      ELSE IF J=44 THEN REST.RESTCTR=T6;\n      ELSE IF J=5 THEN REST.RESTCTR=T4;\n      ELSE IF J=1 THEN REST.RESTCTR=T3;\n      ELSE IF J=2 THEN REST.RESTCTR=T7;\n      ELSE REST.RESTCTR=JCLR.J;\n      RESTCTR=RESTCTR+1;\n  END;\n  END;\n  T1=OVERLAY(UNIT,JCLI.6,POS('XXX',JCLI.6));\n  T2=OVERLAY(VOLSER,JCLI.7,POS('XXXXXX',JCLI.7));\n  T3=OVERLAY(VOLSER,JCLI.1,POS('XXXXXX',JCLI.1));\n IF UNIT\u00ac=\"F00\" THEN DO;\n  DO J = 1 TO JCLI.0;\n      IF J=6 THEN INIT.INITCTR=T1;\n      ELSE IF J=7 THEN INIT.INITCTR=T2;\n      ELSE IF J=1 THEN INIT.INITCTR=T3;\n      ELSE INIT.INITCTR=JCLI.J;\n      INITCTR=INITCTR+1;\n  END;\n END;\n IF UNIT\u00ac=\"F00\" THEN ,\n  SUMM.SUMMCTR = VOLSER \"TYPE\" LEFT(TRUE_DEVTYPE,6) \"MAPPED TO\",\n     \"CDRS UNIT\" UNIT \"TYPE\" TARGET_TYPE;\n ELSE ,\nSUMM.SUMMCTR=\"****** VOLUME\" VOLSER \"NOT INITIALIZED AND/OR RESTORED\";\n  IF VOLSER=\"SYS006\" THEN ,\n       SUMM.SUMMCTR=SUMM.SUMMCTR \"IPL LOADUNIT\" UNIT;\n  IF VOLSER=\"SYS001\" | VOLSER=\"SYS002\" THEN ,\n       SUMM.SUMMCTR=SUMM.SUMMCTR \"LOADPARM\" RIGHT(UNIT,4,\"0\")\"CDM\";\n  SUMMCTR=SUMMCTR+1;\n END I;\nIF POOLMEM \u00ac=\"POOLSYSD\" & POOLMEM \u00ac=\"POOLSYST\" THEN DO;\n \"EXECIO * DISKW DUMP (FINIS STEM DUMP.\";\n \"EXECIO * DISKW INCR (FINIS STEM INCR.\";\n \"EXECIO * DISKW REST (FINIS STEM REST.\";\nEND;\n \"EXECIO * DISKW INIT (FINIS STEM INIT.\";\nEND ZZ;\n\"EXECIO * DISKW SUMM (FINIS STEM SUMM.\";\nEXIT 0;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ONWABEND": {"ttr": 18692, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x02o\\x00\\x94\\x02o\\x14P\\x01\\xf8\\x01\\xf8\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf7@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-01-26T00:00:00", "modifydate": "1994-01-26T14:50:00", "lines": 504, "newlines": 504, "modlines": 0, "user": "TECH107"}, "text": "/*  REXX EXEC : ( NWABEND ).\n    ENTRY     : EXECUTED WHENEVER STEP020 OF THE LAN SERVER TO HOST\n                BACKUP JOBS TERMINATE WITH A RETURN CODE GREATER THAN 4.\n    FUNCTION  : THE SYSOUT LISTING DATASET IS INPUT TO THIS EXEC AND IS\n                SCANNED TO FIND ERROR MESSAGE CODES AND TEXT.\n              : A SYSIN MEMBER IS CREATED AND WRITTEN TO THE MESSAGE\n                CONTROL PDS DATASET AND IS INPUT VIA WTO TO DISPLAY\n                THE FORMATTED MESSAGE TEXT TO THE OPERATOR MASTER\n                CONSOLE AT THE ABEND030 STEP.\n              : A RESTART PARM MEMBER IS WRITTEN TO THE RESTART PDS\n                DATASET AND IS INPUT TO THE NWBACKUP ISPF PANEL AND REXX\n                RESTART FACILITY.\n              : THE CONTAINER AND INDEX GDG DATASETS FROM THE FAILED\n                JOB EXECUTION ARE DETERMINED AND DELETED.\n    INPUT     : ( PTECH2.NETCA.&&SERVER.SYSPRINT ).\n    OUTPUT    : ( SYSS.NETCA.MESSAGE.CNTLLIB(&&SERVER)\n                ( SYSS.NETCA.RESTART.PARMLIB(&&SERVER||'RSPRM').\n                                                                    */\nTRACE O\n/*      */\nHOUSE_KEEPING:\nADDRESS TSO\nARG SERVER BUTYPE RUNMODE\nIF RUNMODE = '' THEN RUNMODE = 'BACKUP'\nX = MSG(\"OFF\")\n\"FREE FILE(NWDD)\"\nNWLIB.1 = 'SYSS.NETCA.MESSAGE.CNTLLIB'\nNWLIB.2 = 'PTECH2.NETCA.'SERVER'.SYSPRINT'\nNWLIB.3 = 'SYSS.NETCA.CONTROL.TEXTLIB'\nNWLIB.4 = 'SYSS.NETCA.RESTART.PARMLIB'\nDO I = 1 TO 4\n   NWDSN = SYSDSN(\"'\"NWLIB.I\"'\")\n   IF NWDSN = 'OK' THEN ITERATE\n   MCNT = 4\n   MSG.1 = '*** LAN BACKUP FOR 'SERVER' FAILED OR IS INCOMPLETE. ***'\n   MSG.2 = '*** DATASET ERROR: DATASET NOT FOUND FOR ('NWLIB.I'). ***'\n   MSG.3 = '*** NOTIFY THE TECHNICAL SUPPORT CRITICAL CALL LIST PERSON. ***'\n   MSG.4 = '*** NWABEND EXEC TASK CANCELLED. ***'\n   IF NWLIB.I = 'SYSS.NETCA.MESSAGE.CNTLLIB' THEN DO\n      ALLOCATE_MESSAGE_CNTLLIB\n      ITERATE\n   END\n   CALL WRITE_MESSAGE_SYSIN\n   EXIT 028\nEND\nT = 0\nTAPEVOL = 'XXXXXX'\nJULDATE = DATE(J)\nHISTKEY = 'CONTAINER INDEX'\nLBLNODE = 'CONTAINR INDEX'\nSTATUS_TEXT = 'SET GLOBAL FINAL_STATUS'\nSUSR.1 = 'NOTIFY THE ON-CALL LAN COMMUNICATIONS GROUP PERSON.'\nSUSR.2 = 'NOTIFY THE ON-CALL LAN COMMUNICATIONS GROUP PERSON.'\nSUSR.3 = 'NOTIFY THE ON-CALL TECHNICAL SUPPORT PERSON.'\nSUSR.4 = 'NOTIFY THE ON-CALL TECHNICAL SUPPORT PERSON.'\nSUSR.5 = 'NOTIFY THE ON-CALL TECHNICAL SUPPORT PERSON.'\nSUSR.6 = 'NOTIFY THE ON-CALL LAN COMMUNICATIONS GROUP PERSON.'\nSUSR.7 = 'NOTIFY THE ON-CALL LAN COMMUNICATIONS GROUP PERSON.'\nSUSR.8 = 'NOTIFY THE ON-CALL LAN COMMUNICATIONS GROUP PERSON.'\nSUSR.9 = 'NOTIFY THE ON-CALL LAN COMMUNICATIONS GROUP PERSON.'\nSMSG.1 = 'SERVICE NOT OFFERED FOR 'SERVER' SERVER CONNECTION FAILED.'\nSMSG.2 = 'CONNECTION FAILED - RETRY LIMIT EXCEEDED FOR 'SERVER' SERVER.'\nSMSG.3 = 'ERROR DURING RECEIVE MODE - DATA TRANSMISSION ERROR.'\nSMSG.4 = 'ERROR DURING RECEIVE MODE - INDEX TRANSMISSION ERROR.'\nSMSG.5 = 'ERROR DURING UPDATE MODE - HISTORY FILE UPDATE ERROR.'\nSMSG.6 = 'ERROR DURING SEND MODE - HISTORY FILE REMOTE ERROR.'\nSMSG.7 = 'ERROR DURING UPDATE MODE - REMOTE PURGE/UPDATE ERROR.'\nSMSG.8 = 'ERROR DURING NOTIFY MODE - REMOTE NOTIFY ERROR.'\nSMSG.9 = 'ERROR OCCURRED ON REMOTE 'SERVER' SERVER ENVIRONMENT.'\n\n/*   S T A R T   O F   M A G I C   A N D   P O S   S E C T I O N   */\n/*     */\nCHECK_MAGIC_POS_FAILURE_REASON:\nIF BUTYPE = 'MAGIC' | BUTYPE = 'POS' THEN DO\n   SERVOL = BUTYPE\n   VOLKEY = SUBSTR(BUTYPE,1,3)\n   TLMSMEMB = VOLKEY'TLMS'\n   BUTYPE = 'FULL'\n   HISTDSN = 'PTECH2.NETCA.'SERVER'.'SERVOL'.H'\n   NWLIB.2 = 'PTECH2.NETCA.'SERVER'.'SERVOL'.SYSPRINT'\n   CALL READ_SERVER_LISTING\n   DSNKEY.1 = 'PTAP.NETCA.'SERVER'.'VOLKEY'.'BUTYPE'.CONTAINR'\n   DSNKEY.2 = 'PTECH2.NETCA.'SERVER'.'VOLKEY'.'BUTYPE'.INDEX'\n   DO D = 1 TO 2\n      DSNTEXT = DSNKEY.D\n      DSNODE = WORD(LBLNODE,D)\n      HSTKEY = WORD(HISTKEY,D)\n      CALL FIND_DSNAME_IN_LISTING\n      CALL CHECK_LISTING_FINAL_STATUS\n      IF LSTSW = 'YES' THEN DO\n         IF BACKUP_STATUS = 'FAIL' THEN DO\n            LABEL = 'LISTCAT_CURRENT_GDG_'DSNODE\n            INTERPRET CALL LABEL\n            LABEL = 'DELETE_CURRENT_GDG_'DSNODE\n            INTERPRET CALL LABEL\n         END\n      END\n   END\n   IF T = 0 THEN DO\n      TAPECNT = 1\n      TLMSRCD.1 = 'UPV XXXXXX,SCRATCH=YES'\n   END\n   CALL WRITE_TLMS_SYSIN\n   OUTMEMB = SERVER||SERVOL\n   OUTPDS = NWLIB.1\n   CALL CHECK_SUBCHANNEL_ALLOCATION_FAILURE\n   IF MSGSW = 'YES' THEN DO\n      CALL WRITE_MESSAGE_SYSIN\n      EXIT 0\n   END\n   IF BACKUP_STATUS = 'FAIL' THEN DO E = 1 TO 4\n      POSTAT = SUBSTR(BUSTATUS,E,1)\n      IF POSTAT = 'S' | POSTAT = 'W' THEN ITERATE\n      LEAVE\n   END\n   CALL CHECK_BACKUP_MESSAGE_STATUS\n   CALL WRITE_MESSAGE_SYSIN\n   EXIT 0\nEND\n\n/*   E N D   O F   M A G I C   A N D   P O S   S E C T I O N   */\n/*     */\nCHECK_LAN_SERVER_FAILURE_REASON:\nVOLKEY = 'DAILY'\nVOLMEMB = SERVER||'IVOLS'\nTLMSMEMB = SERVER'TLMS'\nIF BUTYPE = 'FULL' THEN DO\n   VOLKEY = 'DAILYF'\n   VOLMEMB = SERVER||'FVOLS'\nEND\nF = 0\nQ = 0\nOUTPDS = NWLIB.1\nOUTMEMB = SERVER\nTAPECNT = 0\nRSMEMB = SERVER||'RSPRM'\nCALL READ_SERVER_VOLUMES\nCALL READ_SERVER_LISTING\nDO V = 1 TO VOLCNT\n   SERVOL = VOL.V\n   HISTDSN = 'PTECH2.NETCA.'SERVER'.'SERVOL'.H'\n   DSNKEY.1 = 'PTAP.NETCA.'SERVER'.'SERVOL'.'BUTYPE'.CONTAINR'\n   DSNKEY.2 = 'PTECH2.NETCA.'SERVER'.'SERVOL'.'BUTYPE'.INDEX'\n   DO D = 1 TO 2\n      DSNTEXT = DSNKEY.D\n      DSNODE = WORD(LBLNODE,D)\n      HSTKEY = WORD(HISTKEY,D)\n      CALL FIND_DSNAME_IN_LISTING\n      CALL CHECK_LISTING_FINAL_STATUS\n      IF LSTSW = 'YES' THEN DO\n         IF BACKUP_STATUS = 'FAIL' THEN DO\n            LABEL = 'LISTCAT_CURRENT_GDG_'DSNODE\n            INTERPRET CALL LABEL\n            LABEL = 'DELETE_CURRENT_GDG_'DSNODE\n            INTERPRET CALL LABEL\n         END\n      END\n   END\n   IF BACKUP_STATUS = 'OK' THEN ITERATE\n   CALL CHECK_SUBCHANNEL_ALLOCATION_FAILURE\n   IF MSGSW = 'YES' THEN DO\n      CALL WRITE_MESSAGE_SYSIN\n      MCNT = 1\n      MSG.1 = 'ALL FAIL' BUTYPE\n      OUTPDS = NWLIB.4\n      OUTMEMB = SERVER||'RSPRM'\n      CALL WRITE_MESSAGE_SYSIN\n      EXIT 0\n   END\n   IF BACKUP_STATUS = 'FAIL' THEN DO E = 1 TO 4\n      POSTAT = SUBSTR(BUSTATUS,E,1)\n      IF POSTAT = 'S' | POSTAT = 'W' THEN ITERATE\n      LEAVE\n   END\n   CALL CHECK_BACKUP_MESSAGE_STATUS\n   CALL QUEUE_MESSAGE_TEXT\n   IF E < 9 THEN DO\n      F = F + 1\n      FMSG.F = SERVOL 'FAIL' BUTYPE\n   END\nEND\nIF T = 0 THEN DO\n   TAPECNT = 1\n   TLMSRCD.1 = 'UPV XXXXXX,SCRATCH=YES'\nEND\nCALL WRITE_TLMS_SYSIN\n\n/*     */\nCHECK_RESTART_STATUS:\nFAILCNT = F\nIF FAILCNT = 0 THEN DO\n   NWDEL = SYSDSN(\"'\"NWLIB.4\"(\"RSMEMB\")'\")\n   IF NWDEL = 'OK' THEN DO\n      \"ALLOC DA('\"NWLIB.4\"(\"RSMEMB\")') FILE(NWDD) SHR\"\n      \"DELETE ('\"NWLIB.4\"(\"RSMEMB\")') FILE(NWDD)\"\n      \"FREE FILE(NWDD)\"\n   END\n   DO E = 1 TO 8\n      POSTAT = SUBSTR(GLOBAL_STATUS,E,1)\n      IF POSTAT = 'S' | POSTAT = 'W' THEN ITERATE\n      LEAVE\n   END\n   MCNT = 5\n   MSG.1 = 'LAN BACKUP FOR 'SERVER' SERVER VOLUMES IS COMPLETE.'\n   MSG.2 = 'THE BACKUP DOES NOT NEED TO BE RESTARTED.'\n   MSG.3 = SMSG.E\n   MSG.4 = 'BROWSE/CHECK DSN: 'NWLIB.2\n   MSG.5 = SUSR.E\n   OUTPDS = NWLIB.1\n   OUTMEMB = SERVER\n   CALL WRITE_MESSAGE_SYSIN\n   EXIT 0\nEND\nOUTPDS = NWLIB.4\nOUTMEMB = SERVER||'RSPRM'\nIF FAILCNT = VOLCNT THEN DO\n   MCNT = 1\n   MSG.1 = 'ALL FAIL' BUTYPE\nEND\nIF FAILCNT \u00ac= VOLCNT THEN DO\n   MCNT = FAILCNT\n   DO F = 1 TO FAILCNT\n      MSG.F = FMSG.F\n   END\nEND\nCALL WRITE_MESSAGE_SYSIN\nOUTPDS = NWLIB.1\nOUTMEMB = SERVER\nCALL WRITE_QUEUE_MESSAGE_SYSIN\nEXIT 0\n\n/*     S U B R O U T I N E S   S E C T I O N     */\n/*     */\nREAD_SERVER_VOLUMES:\nV = 0\nIF RUNMODE = 'RESTART' THEN DO\n   VOLMEMB = SERVER||'VOLS'\n   NWLIB.3 = NWLIB.4\nEND\n\"ALLOC DA('\"NWLIB.3\"(\"VOLMEMB\")') FILE(NWDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('NWLIB.3'('VOLMEMB'). ***'\n   SAY '*** NWABEND EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\n\"EXECIO * DISKR NWDD (FINIS STEM VOLDATA.\"\nSRC = RC\n\"FREE FILE(NWDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** EXECIO READ ERROR: ('NWLIB.3'('VOLMEMB'). ***'\n   SAY '*** NWABEND EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nDO I = 1 TO VOLDATA.0\n   UPPER VOLDATA.I\n   SVOL = POS(VOLKEY,VOLDATA.I)\n   IF SVOL = 0 THEN ITERATE\n   V = V + 1\n   VOL.V = WORD(VOLDATA.I,1)\nEND\nVOLCNT = V\nRETURN\n\n/*     */\nREAD_SERVER_LISTING:\n\"ALLOC DA('\"NWLIB.2\"') FILE(NWDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('NWLIB.2'). ***'\n   SAY '*** NWABEND EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\n\"EXECIO * DISKR NWDD (FINIS STEM LST.\"\nSRC = RC\n\"FREE FILE(NWDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** EXECIO READ ERROR: ('NWLIB.2'). ***'\n   SAY '*** NWABEND EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nRETURN\n\n/*     */\nFIND_DSNAME_IN_LISTING:\nLSTSW = 'NO'\nDO L = 1 TO LST.0\n   KEY = POS(DSNTEXT,LST.L)\n   IF KEY \u00ac= 0 THEN DO\n      LSTSW = 'YES'\n      NUMWORDS = WORDS(LST.L)\n      LISTDSN = WORD(LST.L,NUMWORDS)\n      LISTDSN = STRIP(LISTDSN,\"B\",\"'\")\n      LEAVE\n   END\nEND\nRETURN\n\n/*     */\nCHECK_LISTING_FINAL_STATUS:\nENDSW = 'NO'\nBACKUP_STATUS = 'FAIL'\nEND_TEXT = 'BACKUP OF VOLUME 'SERVOL' TERMINATING'\nDO L = 1 TO LST.0\n   UPPER LST.L\n   ENDKEY = POS(END_TEXT,LST.L)\n   IF ENDKEY \u00ac= 0 THEN ENDSW = 'YES'\n   IF ENDSW = 'YES' THEN DO\n      STATKEY = POS(STATUS_TEXT,LST.L)\n      IF STATKEY \u00ac= 0 THEN DO\n         NUMWORDS = WORDS(LST.L)\n         GLOBAL_STATUS = WORD(LST.L,NUMWORDS)\n         LEAVE\n      END\n   END\nEND\nBUSTATUS = SUBSTR(GLOBAL_STATUS,1,4)\nIF BUSTATUS = 'SSSS' THEN BACKUP_STATUS = 'OK'\nDO E = 1 TO 8\n   POSTAT = SUBSTR(GLOBAL_STATUS,E,1)\n   IF POSTAT = 'S' | POSTAT = 'W' THEN ITERATE\n   LEAVE\nEND\nRETURN\n\n/*     */\nLISTCAT_CURRENT_GDG_CONTAINR:\nTAPEVOL = 'XXXXXX'\nX = OUTTRAP(\"LSTCAT.\",\"*\",\"CONCAT\")\n\"LISTCAT ENT('\"LISTDSN\"') ALL\"\nSRC = RC\nIF SRC = 0 THEN DO L = 1 TO LSTCAT.0\n   DSNKEY = POS(\"NONVSAM ------- \",LSTCAT.L)\n   IF DSNKEY \u00ac= 0 THEN GDGDSN = WORD(LSTCAT.L,3)\n   TAPEKEY = POS(\"VOLSER------------\",LSTCAT.L)\n   IF TAPEKEY \u00ac= 0 THEN DO\n      VOLDATA = WORD(LSTCAT.L,1)\n      TAPEVOL = SUBSTR(VOLDATA,19,6)\n      LEAVE\n   END\nEND\nRETURN\n\n/*     */\nLISTCAT_CURRENT_GDG_INDEX:\n/* ***   N O O P   *** */\nRETURN\n\n/*     */\nDELETE_CURRENT_GDG_CONTAINR:\nIF TAPEVOL = 'XXXXXX' & T > 0 THEN RETURN\nT = T + 1\nTLMSRCD.T = 'UPV 'TAPEVOL',SCRATCH=YES'\nTAPECNT = T\nRETURN\n\n/*     */\nDELETE_CURRENT_GDG_INDEX:\n\"ALLOC DA('\"LISTDSN\"') FILE(NWDD) SHR\"\n\"DELETE  ('\"LISTDSN\"')   NONVSAM SCRATCH PURGE FILE(NWDD)\"\n\"FREE FILE(NWDD)\"\nRETURN\n\n/*     */\nWRITE_TLMS_SYSIN:\n\"ALLOC DA('\"NWLIB.4\"(\"TLMSMEMB\")') FILE(NWDD) SHR\"\n\"DELSTACK\"\nDO T = 1 TO TAPECNT\n   QUEUE TLMSRCD.T\nEND\n\"EXECIO \"TAPECNT\" DISKW NWDD (FINIS\"\nSRC = RC\n\"FREE FILE(NWDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** WRITE ERROR: ('NWLIB.4'('TLMSMEMB'). ***'\n   SAY '*** NWABEND EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nRETURN\n\n/*     */\nQUEUE_MESSAGE_TEXT:\nDO M = 1 TO MCNT\n   Q = Q + 1\n   QMSG.Q = MSG.M\nEND\nQCNT =  Q\nRETURN\n\n/*     */\nCHECK_SUBCHANNEL_ALLOCATION_FAILURE:\nMSGSW = 'NO'\nMSGTEXT = 'NETEX-955'\nDO L = 1 TO LST.0\n   UPPER LST.L\n   MTEXT = POS(MSGTEXT,LST.L)\n   IF MTEXT \u00ac= 0 THEN DO\n      MSGSW = 'YES'\n      MCNT = 6\n      MSG.1 = 'SUBCHANNEL ALLOCATION FAIURE - EP ADDRESS NOT AVAILABLE.'\n      MSG.2 = 'TOO MANY LAN BACKUP JOBS ARE RUNNING CONCURRENTLY.'\n      MSG.3 = 'TO DOCUMENT PROBLEM, PLEASE ISSUE COMMAND: D U,,ALLOC,400,24'\n      MSG.4 = 'WAIT UNTIL AT LEAST ONE LAN BACKUP JOB COMPLETES.'\n      MSG.5 = 'RESTART BACKUP FOR ALL VOLUMES ON SERVER 'SERVER'.'\n      MSG.6 = 'USE THE ( %NWBACKUP ) PANEL FACILITY FROM TSOE TO RESTART.'\n      LEAVE\n   END\nEND\nRETURN\n\n/*     */\nCHECK_BACKUP_MESSAGE_STATUS:\nIF BACKUP_STATUS = 'OK' THEN DO\n   MCNT = 6\n   MSG.1 = 'LAN BACKUP FOR 'SERVER' VOLUME: ('SERVOL') IS COMPLETE.'\n   MSG.2 = 'THE BACKUP DOES NOT NEED TO BE RESTARTED.'\n   MSG.3 = 'A PROBLEM OCCURRED ON THE REMOTE LAN SERVER.'\n   MSG.4 = 'BROWSE/CHECK SYSPRINT DSN: ('NWLIB.2').'\n   MSG.5 = 'ERROR TEXT IN SYSPRINT WILL PRECEDE (FINAL_STATUS) FLAG.'\n   MSG.6 = 'NOTIFY THE ON-CALL LAN COMMUNICATIONS GROUP PERSON.'\n   RETURN\nEND\nIF BACKUP_STATUS = 'FAIL' THEN DO\n   MCNT = 7\n   MSG.1 = 'LAN BACKUP FOR 'SERVER' VOLUME: ('SERVOL') FAILED.'\n   MSG.2 = 'RESTART BACKUP VIA TSOE ( %NWBACKUP ).'\n   MSG.3 = SMSG.E\n   MSG.4 = 'BROWSE/CHECK SYSPRINT DSN: ('NWLIB.2').'\n   MSG.5 = 'ERROR TEXT IN SYSPRINT WILL PRECEDE (FINAL_STATUS) FLAG.'\n   MSG.6 = 'CHECK RISC/6000 CONSOLE TO DETERMINE IF SERVICE OFFERED.'\n   MSG.7 = SUSR.E\n   RETURN\nEND\nIF LSTSW = 'NO' THEN DO\nMCNT = 5\nMSG.1 = 'LAN BACKUP FAILED FOR SERVER 'SERVER' VOLUME: ('SERVOL').'\nMSG.2 = 'RESTART BACKUP VIA TSOE ( %NWBACKUP ).'\nMSG.3 = 'CHECK RISC/6000 CONSOLE TO DETERMINE IF SERVICE OFFERED.'\nMSG.4 = 'BROWSE/CHECK SYSPRINT DSN: ('NWLIB.2').'\nMSG.5 = 'ERROR TEXT IN SYSPRINT WILL PRECEDE (FINAL_STATUS) FLAG.'\nRETURN\n\n/*     */\nALLOCATE_MESSAGE_CNTLLIB:\n\"ATTRIB MSGLIB DSORG(PO) RECFM(F,B) LRECL(80) BLKSIZE(27920)\"\n\"ALLOC DA('\"NWLIB.1\"') NEW SPACE(3,1) USING(MSGLIB) DIR(1) DATACLAS(CNTL)\nMGMTCLAS(NOMIG) STORCLAS(SYSSHARE) DSNTYP(LIBRARY)\"\nSRC = RC\n\"FREE DA('SYSS.NETCA.MESSAGE.CNTLLIB')\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('NWLIB.1'). ***'\n   SAY '*** NOTIFY THE TECHNICAL SUPPORT CRITICAL CALL LIST PERSON. ***'\n   SAY '*** NWABEND EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT 100\nEND\nRETURN\n\n/*     */\nWRITE_MESSAGE_SYSIN:\n\"DELSTACK\"\n\"ALLOC DA('\"OUTPDS\"(\"OUTMEMB\")') FILE(NWDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('OUTPDS'('OUTMEMB'). ***'\n   SAY '*** NWABEND EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nDO M = 1 TO MCNT\n   QUEUE MSG.M\nEND\nNUMRCDS = QUEUED()\n\"EXECIO\" NUMRCDS \"DISKW NWDD (FINIS\"\nSRC = RC\n\"FREE FILE(NWDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** WRITE ERROR: ERROR WRITING 'OUTPDS'('OUTMEMB'). ***'\n   SAY '*** NWABEND EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nRETURN\n\n/*     */\nWRITE_QUEUE_MESSAGE_SYSIN:\n\"DELSTACK\"\n\"ALLOC DA('\"OUTPDS\"(\"OUTMEMB\")') FILE(NWDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('OUTPDS'('OUTMEMB'). ***'\n   SAY '*** NWABEND EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nDO Q = 1 TO QCNT\n   QUEUE QMSG.Q\nEND\nNUMRCDS = QUEUED()\n\"EXECIO\" NUMRCDS \"DISKW NWDD (FINIS\"\nSRC = RC\n\"FREE FILE(NWDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** WRITE ERROR: ERROR WRITING 'OUTPDS'('OUTMEMB'). ***'\n   SAY '*** NWABEND EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ONWALLOC": {"ttr": 18945, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x02o\\x00\\x94\\x02o\\x14P\\x01t\\x01t\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf7@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-01-26T00:00:00", "modifydate": "1994-01-26T14:50:00", "lines": 372, "newlines": 372, "modlines": 0, "user": "TECH107"}, "text": "/*  REXX EXEC : ( NWALLOC ).\n    FUNCTION  : VERIFIES AND/OR ALLOCATES THE HISTORY AN OLD HISTORY\n                DATASETS FOR EACH SERVER VOLUME SPECIFIED IN THE VOLUMES\n                PARM FILE FOR THE NETWORK SYSTEMS USER ACCESS LAN BACKUP.\n                PERFORMS MAINTENANCE CLEANUP OF HISTORY DATASET ENTRIES\n                FOR DATASETS NO LONGER FOUND IN THE CATALOG.\n                                                                    */\nTRACE O\n/*      */\nHOUSE_KEEPING:\nADDRESS TSO\nARG SERVER BACKUP_TYPE\nIF SERVER = '' THEN DO\n   SAY '*** PARM ERROR: LAN SERVER NAME NOT PASSED ON COMMAND LINE.***'\n   SAY '*** NWALLOC EXEC TASK CANCELLED. ***'\n   EXIT 101\nEND\nIF BACKUP_TYPE = '' THEN DO\n   SAY '*** PARM ERROR: BACKUP TYPE NOT SPECIFIED FOR 'SERVER' LAN BACKUP. ***'\n   SAY '*** NWALLOC EXEC TASK CANCELLED. ***'\n   EXIT 102\nEND\nX = MSG(\"OFF\")\nBUTYPE = 'NOOP'\nDSNSUFX = 'H O UPDPRINT'\nLBLNODE = 'HISTORY HISTORY LISTING'\nPRTNODE = 'SCHPRINT SYSPRINT UPDPRINT'\nVOLCNT = 0\nALLOCSW = 'NO'\nTEXTLIB = 'SYSS.NETCA.CONTROL.TEXTLIB'\nPARMLIB = 'SYSS.NETCA.RESTART.PARMLIB'\nHSTMODEL = 'SYSS.NETCA.MODEL.HIST'\nPRTMODEL = 'SYSS.NETCA.MODEL.SYSPRINT'\nIF BACKUP_TYPE = 'DAILY' THEN BUTYPE = 'INCR'\nIF BACKUP_TYPE = 'DAILYF' THEN BUTYPE = 'FULL'\n/*     */\n/*   S T A R T   O F   M A G I C   A N D   P O S   S E C T I O N   */\nIF BACKUP_TYPE = 'MAGIC' | BACKUP_TYPE = 'POS' THEN DO\n   SERVOL = BACKUP_TYPE\n   BUTYPE = 'FULL'\n   HSTDSN = 'PTECH2.NETCA.'SERVER'.'SERVOL'.H'\n   VOLKEY = SUBSTR(BACKUP_TYPE,1,3)\n   TLMSMEMB = VOLKEY'TLMS'\n   CALL DELETE_TLMS_MEMBER\n   DO V = 1 TO 3\n      SUFX = WORD(DSNSUFX,V)\n      LNODE = WORD(LBLNODE,V)\n      PNODE = WORD(PRTNODE,V)\n      \"DELETE ('PTECH2.NETCA.\"SERVER\".\"SERVOL\".\"PNODE\"') NONVSAM SCRATCH PURGE\"\n      VOLDSN = SYSDSN(\"'PTECH2.NETCA.\"SERVER\".\"SERVOL\".\"SUFX\"'\")\n      IF VOLDSN = 'DATASET NOT FOUND' THEN DO\n         LABEL = 'ALLOCATE_'LNODE'_DATASET'\n         INTERPRET CALL LABEL\n      END\n   END\n   IF ALLOCSW = 'YES' THEN EXIT 0\n   SERVOL = SUBSTR(BACKUP_TYPE,1,3)\n   CALL LISTCAT_FULL_CONTAINER\n   IF MNTSW = 'NO' THEN EXIT 0\n   CALL READ_HISTORY_DATASET\n   IF MNTSW = 'NO' THEN EXIT 0\n   IF HIST.0 = 0 THEN EXIT 0\n   CALL SAVE_HISTORY_DATASET\n   IF MNTSW = 'NO' THEN EXIT 0\n   IF BACKUP_TYPE = 'MAGIC' THEN VOLKEY = 'MAGIC SYS:'\n   IF BACKUP_TYPE = 'POS' THEN VOLKEY = 'POS VOL1:'\n   CALL PERFORM_HISTORY_MAINTENANCE\n   IF QUESW = 'NO' THEN EXIT 0\n   CALL REWRITE_HISTORY_DATASET\n   EXIT 0\nEND\n/*   E N D   O F   M A G I C   A N D   P O S   S E C T I O N   */\n/*     */\nTLMSMEMB = SERVER'TLMS'\nCALL DELETE_TLMS_MEMBER\nVOLMEMB = SERVER||'IVOLS'\nIF BUTYPE = 'FULL' THEN VOLMEMB = SERVER||'FVOLS'\nVOLPARM = SYSDSN(\"'\"TEXTLIB\"(\"VOLMEMB\")'\")\nIF VOLPARM = 'MEMBER NOT FOUND' THEN DO\n   SAY '*** PARM ERROR: INVALID BACKUP PARM ('BACKUP_TYPE'). ***'\n   SAY '*** MEMBER NOT FOUND: ('TEXTLIB'('VOLMEMB'). ***'\n   SAY '*** NWALLOC EXEC TASK CANCELLED. ***'\n   EXIT 103\nEND\n\"FREE FILE(NWDD)\"\n\"DELETE   ('PTECH2.NETCA.\"SERVER\".SCHPRINT')   NONVSAM SCRATCH PURGE\"\n\"DELETE   ('PTECH2.NETCA.\"SERVER\".SYSPRINT')   NONVSAM SCRATCH PURGE\"\n\n/*     */\nMAIN_ROUTINE:\nCALL READ_VOLUMES_PARMS\nDO V = 1 TO VOL.0\n   UPPER VOL.V\n   LANBU = POS(BACKUP_TYPE,VOL.V)\n   IF LANBU = 0 THEN ITERATE\n   VOLCNT = VOLCNT + 1\n   SERVOL = WORD(VOL.V,1)\n   HSTDSN = 'PTECH2.NETCA.'SERVER'.'SERVOL'.H'\n   DO S = 1 TO 3\n      SUFX = WORD(DSNSUFX,S)\n      LNODE = WORD(LBLNODE,S)\n      VOLDSN = SYSDSN(\"'PTECH2.NETCA.\"SERVER\".\"SERVOL\".\"SUFX\"'\")\n      IF VOLDSN = 'DATASET NOT FOUND' THEN DO\n         LABEL = 'ALLOCATE_'LNODE'_DATASET'\n         INTERPRET CALL LABEL\n      END\n   END\n   IF ALLOCSW = 'YES' THEN ITERATE\n   CALL LISTCAT_INCR_CONTAINER\n   IF MNTSW = 'NO' THEN ITERATE\n   CALL LISTCAT_FULL_CONTAINER\n   IF MNTSW = 'NO' THEN ITERATE\n   CALL READ_HISTORY_DATASET\n   IF MNTSW = 'NO' THEN ITERATE\n   IF HIST.0 = 0 THEN ITERATE\n   CALL SAVE_HISTORY_DATASET\n   IF MNTSW = 'NO' THEN ITERATE\n   VOLKEY = SERVOL SERVOL':'\n   CALL PERFORM_HISTORY_MAINTENANCE\n   IF QUESW = 'NO' THEN ITERATE\n   CALL REWRITE_HISTORY_DATASET\nEND\nIF VOLCNT = 0 THEN DO\n   SAY '*** PARM ERROR: BACKUP TYPE ( 'BACKUP_TYPE' ) NOT FOUND FOR ('SERVER')'\n   SAY '                IN ('TEXTLIB'('VOLMEMB'). ***'\n   SAY '*** NWALLOC EXEC SUBTASK CANCELLED. ***'\n   EXIT 8\nEND\nEXIT 0\n\n/*     S U B R O U T I N E S   S E C T I O N     */\n/*     */\nDELETE_TLMS_MEMBER:\nNWDEL = SYSDSN(\"'\"PARMLIB\"(\"TLMSMEMB\")'\")\nIF NWDEL = 'OK' THEN DO\n   \"ALLOC DA('\"PARMLIB\"(\"TLMSMEMB\")') FILE(NWDD) SHR\"\n   \"DELETE ('\"PARMLIB\"(\"TLMSMEMB\")') FILE(NWDD)\"\n   \"FREE FILE(NWDD)\"\nEND\nRETURN\n\n/*     */\nREAD_VOLUMES_PARMS:\n\"ALLOC DA('\"TEXTLIB\"(\"VOLMEMB\")') FILE(NWDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('TEXTLIB'('VOLMEMB'). ***'\n   SAY '*** NWALLOC EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\n\"EXECIO * DISKR NWDD (FINIS STEM VOL.\"\nSRC = RC\n\"FREE FILE(NWDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** EXECIO READ ERROR: ('TEXTLIB'('VOLMEMB'). ***'\n   SAY '*** NWALLOC EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nRETURN\n\n/*     */\nALLOCATE_HISTORY_DATASET:\nALLOCSW = 'YES'\n\"ALLOC DA('PTECH2.NETCA.\"SERVER\".\"SERVOL\".\"SUFX\"')\nLIKE('\"HSTMODEL\"') NEW SPACE(1,1) TRACKS BLKSIZE(3120)\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** ALLOCATE ERROR: ERROR ALLOCATING 'SERVER' DATASET:'\n   SAY '                    (PTECH2.NETCA.'SERVER'.'SERVOL'.'SUFX'). ***'\n   SAY '*** NWALLOC EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\n\"FREE DA('PTECH2.NETCA.\"SERVER\".\"SERVOL\".\"SUFX\"')\"\nRETURN\n\n/*     */\nALLOCATE_LISTING_DATASET:\n\"ALLOC DA('PTECH2.NETCA.\"SERVER\".\"SERVOL\".\"SUFX\"')\nLIKE('\"PRTMODEL\"') NEW SPACE(1,1) CYLINDERS BLKSIZE(133) DATACLAS(LISTING)\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** ALLOCATE ERROR: ERROR ALLOCATING 'SERVER' DATASET:'\n   SAY '                    (PTECH2.NETCA.'SERVER'.'SERVOL'.'SUFX'). ***'\n   SAY '*** NWALLOC EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\n\"FREE DA('PTECH2.NETCA.\"SERVER\".\"SERVOL\".\"SUFX\"')\"\nRETURN\n\n/*     */\nLISTCAT_FULL_CONTAINER:\nIF ALLOCSW = 'YES' THEN RETURN\nF = 0\nMNTSW = 'YES'\nDSNLVL = 'PTAP.NETCA.'SERVER'.'SERVOL'.FULL.CONTAINR'\nX = OUTTRAP(\"LSTCAT.\",\"*\",\"CONCAT\")\n\"LISTCAT LEVEL(\"DSNLVL\") NAMES\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** LISTCAT ERROR: MAINT CLEANUP FOR 'SERVER' HIST FILES BYPASSED. ***'\n   MNTSW = 'NO'\n   RETURN\nEND\nDO L = 1 TO LSTCAT.0\n   DSNKEY = POS(\"NONVSAM ------- \",LSTCAT.L)\n   IF DSNKEY \u00ac= 0 THEN DO\n      F = F + 1\n      FULL.F = WORD(LSTCAT.L,3)\n   END\nEND\nFULLCNT = F\nRETURN\n\n/*     */\nLISTCAT_INCR_CONTAINER:\nIF ALLOCSW = 'YES' THEN RETURN\nD = 0\nMNTSW = 'YES'\nDSNLVL = 'PTAP.NETCA.'SERVER'.'SERVOL'.INCR.CONTAINR'\nX = OUTTRAP(\"LSTCAT.\",\"*\",\"CONCAT\")\n\"LISTCAT LEVEL(\"DSNLVL\") NAMES\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** LISTCAT ERROR: MAINT CLEANUP FOR 'SERVER' HIST FILES BYPASSED. ***'\n   MNTSW = 'NO'\n   RETURN\nEND\nDO L = 1 TO LSTCAT.0\n   DSNKEY = POS(\"NONVSAM ------- \",LSTCAT.L)\n   IF DSNKEY \u00ac= 0 THEN DO\n      D = D + 1\n      INCR.D = WORD(LSTCAT.L,3)\n   END\nEND\nINCRCNT = D\nRETURN\n\n/*     */\nREAD_HISTORY_DATASET:\nIF ALLOCSW = 'YES' THEN RETURN\nMNTSW = 'YES'\n\"ALLOC DA('\"HSTDSN\"') FILE(NWDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** ALLOCATE ERROR: ERROR ALLOCATING ('HSTDSN'). ***'\n   SAY '*** HISTORY MAINTENANCE CLEANUP NOT PERFORMED FOR ('SERVOL'). ***'\n   MNTSW = 'NO'\n   RETURN\nEND\n\"EXECIO * DISKR NWDD (FINIS STEM HIST.\"\nSRC = RC\n\"FREE FILE(NWDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** EXECIO READ ERROR: ('HSTDSN'). ***'\n   SAY '*** HISTORY MAINTENANCE CLEANUP NOT PERFORMED FOR ('SERVOL'). ***'\n   MNTSW = 'NO'\n   RETURN\nEND\nRETURN\n\n/*     */\nSAVE_HISTORY_DATASET:\nIF ALLOCSW = 'YES' THEN RETURN\n\"DELSTACK\"\nMNTSW = 'YES'\nSAVEHIST = HSTDSN'.SAVE'\n\"DELETE   ('\"SAVEHIST\"')  NONVSAM SCRATCH PURGE\"\n\"ALLOC DA('\"SAVEHIST\"') LIKE('SYSS.NETCA.MODEL.HIST') NEW SPACE(1,1) TRACKS\nBLKSIZE(3120)\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** ALLOCATE ERROR: ('SAVEHIST'). ***'\n   SAY '*** HISTORY MAINTENANCE CLEANUP NOT PERFORMED FOR ('SERVOL'). ***'\n   MNTSW = 'NO'\n   RETURN\nEND\nDO H = 1 TO HIST.0\n   QUEUE HIST.H\nEND\n\"ALLOC DA('\"SAVEHIST\"') FILE(NWDD) SHR\"\nNUMRCDS = QUEUED()\n\"EXECIO\" NUMRCDS \"DISKW NWDD (FINIS\"\nSRC = RC\n\"FREE FILE(NWDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** WRITE ERROR: ERROR WRITING ('SAVEHIST'). ***'\n   SAY '*** HISTORY MAINTENANCE CLEANUP NOT PERFORMED FOR ('SERVOL'). ***'\n   MNTSW = 'NO'\n   RETURN\nEND\nRETURN\n\n/*     */\nPERFORM_HISTORY_MAINTENANCE:\nIF ALLOCSW = 'YES' THEN RETURN\n\"DELSTACK\"\nQUESW = 'NO'\nDO H = 1 TO HIST.0\n   HISTRCD = HIST.H\n   UPPER HISTRCD\n   VLOC = POS(VOLKEY,HISTRCD)\n   IF VLOC \u00ac= 0 THEN DO\n      BUSTATUS = WORD(HISTRCD,9)\n      IF BUSTATUS = 'SSSS' THEN DO\n         HIST_BUTYPE = WORD(HISTRCD,5)\n         IF HIST_BUTYPE = 'INCR' THEN DO\n            N = H + 1\n            HISTRCD2 = HIST.N\n            UPPER HISTRCD2\n            HIST_BUDSN = WORD(HISTRCD2,2)\n            HIST_BUDSN = STRIP(HIST_BUDSN,\"B\",\"'\")\n            DO D = 1 TO INCRCNT\n               IF HIST_BUDSN = INCR.D THEN DO\n                  CALL QUEUE_HISTORY_RECORDS\n                  LEAVE\n               END\n            END\n         END\n         IF HIST_BUTYPE = 'FULL' THEN DO\n            N = H + 1\n            HISTRCD2 = HIST.N\n            UPPER HISTRCD2\n            HIST_BUDSN = WORD(HISTRCD2,2)\n            HIST_BUDSN = STRIP(HIST_BUDSN,\"B\",\"'\")\n            DO F = 1 TO FULLCNT\n               IF HIST_BUDSN = FULL.F THEN DO\n                  CALL QUEUE_HISTORY_RECORDS\n                  LEAVE\n               END\n            END\n         END\n      END\n   END\nEND\nRETURN\n\n/*     */\nQUEUE_HISTORY_RECORDS:\nQUESW = 'YES'\nW = H - 1\nDO 5\n   W = W + 1\n   QUEUE HIST.W\nEND\nRETURN\n\n/*     */\nREWRITE_HISTORY_DATASET:\nIF ALLOCSW = 'YES' THEN RETURN\n\"DELETE   ('\"HSTDSN\"')    NONVSAM SCRATCH PURGE\"\n\"ALLOC DA('\"HSTDSN\"') LIKE('SYSS.NETCA.MODEL.HIST') NEW SPACE(1,1) TRACKS\nBLKSIZE(3120)\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** ALLOCATE ERROR: ('HSTDSN'). ***'\n   SAY '*** HISTORY MAINTENANCE CLEANUP NOT PERFORMED FOR ('SERVOL'). ***'\n   SAY '*** CONTACT TECHNICAL SUPPORT CRITICAL CALL LIST PERSONNEL. ***'\n   EXIT 8\nEND\n\"ALLOC DA('\"HSTDSN\"') FILE(NWDD) SHR\"\nNUMRCDS = QUEUED()\n\"EXECIO\" NUMRCDS \"DISKW NWDD (FINIS\"\nSRC = RC\n\"FREE FILE(NWDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** WRITE ERROR: ERROR RE-WRITING ('HSTDSN'). ***'\n   SAY '*** HISTORY MAINTENANCE CLEANUP NOT PERFORMED FOR ('SERVOL'). ***'\n   SAY '*** CONTACT TECHNICAL SUPPORT CRITICAL CALL LIST PERSONNEL. ***'\n   EXIT 8\nEND\n\"FREE DA('\"HSTDSN\"')\"\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ONWREST": {"ttr": 18952, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\"\\x7f\\x00\\x94\"\\x7f\\x15W\\x02\\x84\\x02\\x84\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf7@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-08-15T00:00:00", "modifydate": "1994-08-15T15:57:00", "lines": 644, "newlines": 644, "modlines": 0, "user": "TECH107"}, "text": "/*  REXX EXEC : ( NWRESTOR ).\n    FUNCTION  : LAN SERVER BACKUP PANEL INTERFACE TO FACILITATE FILE\n                RESTORES FOR A SERVER VOLUME FROM THE MVS HOST CENTRAL\n                ARCHIVE BACKUP.\n                BUILDS AND WRITES THE JOB JCL AND INPUT SCRIPT TO\n                PERFORM THE LAN SERVER RESTORE AND SUBMITS THE JOB\n                FOR EXECUTION ON THE SYSB SYSTEM CLASS=S.\n    INPUT     : ( PTECH2.NETCA.&&SERVER.&&VOLUME.H ).\n                ( SYSS.NETCA.LAN.MVSNW.UA ).\n    OUTPUT    : ( PTECH3.NETCA.RESTORE.SCRIPT.PARMLIB(&MEMBER).\n                ( PTECH3.NETCA.RESTORE.SCRIPT.CNTLLIB(&MEMBER).\n    1/26/94   - ADDED REALITY AND ASP\n                                                                    */\nTRACE O\n/*      */\nHOUSE_KEEPING:\nADDRESS TSO\nSERVER.1 = 'COM'\nSERVER.2 = 'CS1'\nSERVER.3 = 'CS2'\nSERVER.4 = 'MAGIC'\nSERVER.5 = 'POS'\nSERVER.6 = 'CS3'\nSERVER.7 = 'DB1'\nSERVER.8 = 'CSI'\nSERVER.9 = 'FIN'\nSERVER.10 = 'MIS'\nSERVER.11 = 'SYS'\nSERVER.12 = 'PAD'\nSERVER.13 = 'REA'\nSERVER.14 = 'ASP'\nSERVER.15 = 'CS4'\nSERVER.16 = 'DB1'\nSERVER.17 = 'C4A'\nSERVER.18 = 'C4B'\nSERVER.19 = 'CS5'\nSERVER.20 = 'C5A'\nSERVER.21 = 'C6A'\nSERVER.22 = 'C6B'\nRESTYPE.1 = 'FILE'\nRESTYPE.2 = 'DRCT'\nRESTYPE.3 = 'VOL'\nRESTMOD.1 = 'INCR'\nRESTMOD.2 = 'FULL'\nPARMLIB = 'SYSS.TECH.COMMON.PARMLIB'\nSCRIPTLIB = 'PTECH3.NETCA.RESTORE.SCRIPT.PARMLIB'\nCNTLLIB = 'PTECH3.NETCA.RESTORE.SCRIPT.CNTLLIB'\nTEXTLIB = 'SYSS.NETCA.CONTROL.TEXTLIB'\nTSOID = SYSVAR(SYSUID)\nCURTIME = TIME()\nHH = SUBSTR(CURTIME,1,2)\nMM = SUBSTR(CURTIME,4,2)\nSS = SUBSTR(CURTIME,7,2)\nTIMEP = HH||MM||SS\nJSUFFIX = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\nX = MSG(\"OFF\")\n\"FREE FILE(NWDD)\"\nADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\n\n/*     */\nDISPLAY_SERVER_PANEL:\nAUTHPARM = 'NWHPDESK'\nNWMSG = 'NWLAN002'\nDO FOREVER\n   ADDRESS ISPEXEC\n   \"DISPLAY PANEL(NWRSTPN1)\"\n   SRC = RC\n   IF SRC = 8 THEN EXIT 0\n   IF SRC > 8 THEN DO\n      SAY '*** ERROR INVOKING ISPF DIALOG PANEL ( NWRSTPN1 ). ***'\n      SAY '*** NWRESTOR EXEC TASK CANCELLED - RC = 'SRC'. ***'\n      EXIT SRC\n   END\n   IF RESTYPE.RT = 'VOL' THEN DO\n      AUTHPARM = 'NWLANGRP'\n      NWMSG = 'NWLAN003'\n   END\n   CALL CHECK_USER_AUTHORIZATION\n   IF AUTHSW = 'YES' THEN LEAVE\n   \"SETMSG MSG(\"NWMSG\")\"\nEND\nSERVER = SERVER.LAN\nIF SERVER = 'MAGIC' THEN DO\n   VOLKEY = 'MAGIC SYS:'\n   RESTVOL = 'SYS:'\n/* RESTDPN = 'MAGIC' */\n   VOLUME = 'MAGIC'\n   SERVER = 'CS3'\n   RM = 2\n   SIGNAL BUILD_CONTAINER_DATASET_PARMS\nEND\nIF SERVER = 'POS' THEN DO\n   VOLKEY = 'POS VOL1:'\n   RESTVOL = 'VOL1:'\n/* RESTDPN = 'POS' */\n   VOLUME = 'POS'\n   SERVER = 'CS3'\n   RM = 2\n   SIGNAL BUILD_CONTAINER_DATASET_PARMS\nEND\nIF SERVER = 'REA' THEN DO\n   VOLKEY = 'REA VOL2:'\n   RESTVOL = 'VOL2:'\n   RESTDPN = 'REA'\n   VOLUME = 'REA'\n   SERVER = 'CS1'\n   RM = 2\n   SIGNAL BUILD_CONTAINER_DATASET_PARMS\nEND\nIF SERVER = 'ASP' THEN DO\n   VOLKEY = 'ASP VOL1:'\n   RESTVOL = 'VOL1:'\n   RESTDPN = 'ASP'\n   VOLUME = 'ASP'\n   SERVER = 'CSI'\n   RM = 2\n   SIGNAL BUILD_CONTAINER_DATASET_PARMS\nEND\n\n/*     */\nDISPLAY_VOLUME_PANEL:\nADDRESS TSO\n\"FREE FILE(NWDD)\"\n\"FREE FILE(ISPFILE)\"\nCALL READ_SERVER_VOLUMES_PARMS\nADDRESS ISPEXEC \"DISPLAY PANEL(NWRSTPN2)\"\nSRC = RC\nIF SRC = 8 THEN EXIT 0\nIF SRC > 8 THEN DO\n   SAY '*** ERROR INVOKING ISPF DIALOG PANEL ( NWRSTPN2 ). ***'\n   SAY '*** NWRESTOR EXEC TASK CANCELLED - RC = 'SRC'. ***'\n   EXIT SRC\nEND\nCALL GET_SELECTED_SERVER_VOLUME\nVOLKEY = VOLUME RESTVOL\n\n/*     */\nBUILD_CONTAINER_DATASET_PARMS:\nCALL GET_HISTORY_CONTAINER_DATASETS\nIF DSN = 0 THEN DO\n   SAY '*** HISTORY DATASET ERROR: NO VALID CONTAINER DATASET NAMES FOUND. ***'\n   SAY '*** DSN ('NWHSTLIB') DOES NOT CONTAIN A BACKUP STATUS OF (SSSS). ***'\n   SAY '*** NWRESTOR EXEC TASK CANCELLED - RC = (028). ***'\n   EXIT 028\nEND\nGDGCNT = 18\nNWPANEL = 'NWRSTPN3'\nIF RESTMOD.RM = 'FULL' & SERVER \u00ac= 'PAD' THEN DO\n   GDGCNT = 6\n   NWPANEL = 'NWRSTPN4'\nEND\nCALL BUILD_PANEL_DATASET_PARMS\n\n/*     */\nDISPLAY_DATASET_LIST_PANEL:\nDO FOREVER\n   ADDRESS ISPEXEC\n   \"DISPLAY PANEL(\"NWPANEL\")\"\n   SRC = RC\n   IF SRC = 8 THEN EXIT 0\n   IF SRC > 8 THEN DO\n      SAY '*** ERROR INVOKING ISPF DIALOG PANEL ( 'NWPANEL' ). ***'\n      SAY '*** NWRESTOR EXEC TASK CANCELLED - RC = 'SRC'. ***'\n      EXIT SRC\n   END\n   CALL GET_PANEL_INPUT_DATASET\n   IF DSNSW = 'YES' THEN LEAVE\n   \"SETMSG MSG(NWLAN004)\"\nEND\nIF RESTYPE.RT = 'DRCT' & RESTFN = '' THEN RESTFN = '*'\nIF RESTYPE.RT = 'VOL' THEN DO\n   RESTDPN = '*'\n   RESTFN = '*'\nEND\n\n/*     */\nDISPLAY_INPUT_PARMS_CONFIRMATION_PANEL:\nCALL LISTCAT_CONTAINER_DATASET\nCALL BUILD_PANEL_TAPE_VOLSERS\nADDRESS ISPEXEC\n\"DISPLAY PANEL(NWRSTPN5)\"\nSRC = RC\nIF SRC = 8 THEN EXIT 0\nIF SRC > 8 THEN DO\n   SAY '*** ERROR INVOKING ISPF DIALOG PANEL ( NWRSTPN5 ). ***'\n   SAY '*** NWRESTOR EXEC TASK CANCELLED - RC = 'SRC'. ***'\n   EXIT SRC\nEND\n\n/*     */\nCREATE_RESTORE_JOB_PARMS:\nADDRESS TSO\nSUBPDS = CNTLLIB\nJMEMB = 'J'TIMEP                  /* JOURNAL PARMS MEMBER */\nRMEMB = 'R'TIMEP                  /* RESTORE JOB JCL MEMBER */\nSMEMB = 'S'TIMEP                  /* SCRIPT INPUT MEMBER */\n\"DELSTACK\"\nCALL BUILD_JOBNAME_PARM\nOUTPDS = CNTLLIB\nOUTMEMB = JOBNAME\nQUEUE JOBNAME\nCALL WRITE_PDS_MEMBER\nCALL BUILD_RESTORE_JOB\nOUTMEMB = RMEMB\nCALL WRITE_PDS_MEMBER\n\"DELSTACK\"\nQUEUE SERVER\nQUEUE RESTVOL\nQUEUE RESTDSN\nQUEUE RESTDPN\nQUEUE RESTFN\nOUTMEMB = JMEMB\nCALL WRITE_PDS_MEMBER\nCALL BUILD_RESTORE_PARMS\nOUTMEMB = SMEMB\nOUTPDS = SCRIPTLIB\nCALL WRITE_PDS_MEMBER\nCALL SUBMIT_RESTORE_JOB\nEXIT 0\n\n/*     S U B R O U T I N E S   S E C T I O N     */\n/*     */\nCHECK_USER_AUTHORIZATION:\nADDRESS TSO\nAUTHSW = 'NO'\n\"ALLOC DA('\"PARMLIB\"(\"AUTHPARM\")') FILE(NWDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('PARMLIB'('AUTHPARM'). ***'\n   SAY '*** NWRESTOR EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\n\"EXECIO * DISKR NWDD (FINIS STEM AUTH.\"\nSRC = RC\n\"FREE FILE(NWDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** EXECIO READ ERROR: ('PARMLIB'('AUTHPARM'). ***'\n   SAY '*** NWRESTOR EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nDO I = 1 TO AUTH.0\n   LAU = POS(TSOID,AUTH.I)\n   IF LAU \u00ac= 0 THEN AUTHSW = 'YES'\nEND\nRETURN\n\n/*     */\nREAD_SERVER_VOLUMES_PARMS:\nADDRESS TSO\nVOLCONFG = SERVER'IVOLS'\nIF RESTMOD.RM = 'FULL' THEN VOLCONFG = SERVER'FVOLS'\n\"ALLOC DA('\"TEXTLIB\"(\"VOLCONFG\")') FILE(NWDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('TEXTLIB'('VOLCONFG'). ***'\n   SAY '*** NWRESTOR EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\n\"EXECIO * DISKR NWDD (FINIS STEM VOLP.\"\nSRC = RC\n\"FREE FILE(NWDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** EXECIO READ ERROR: ('TEXTLIB'('VOLCONFG'). ***'\n   SAY '*** NWRESTOR EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nV = 0\nVOL1 = '*****'\nVOL2 = '*****'\nVOL3 = '*****'\nVOL4 = '*****'\nVOL5 = '*****'\nVOL6 = '*****'\nVOL7 = '*****'\nVOL8 = '*****'\nDO I = 1 TO VOLP.0\n   UPPER VOLP.I\n   SVOL = POS('DAILY',VOLP.I)\n   IF SVOL = 0 THEN ITERATE\n   V = V + 1\n   SERVOL = WORD(VOLP.I,2)\n   RSTVOL.V = WORD(VOLP.I,2)\n   IF V = 1 THEN VOL1 = LEFT(SERVOL,5,'*')\n   IF V = 2 THEN VOL2 = LEFT(SERVOL,5,'*')\n   IF V = 3 THEN VOL3 = LEFT(SERVOL,5,'*')\n   IF V = 4 THEN VOL4 = LEFT(SERVOL,5,'*')\n   IF V = 5 THEN VOL5 = LEFT(SERVOL,5,'*')\n   IF V = 6 THEN VOL6 = LEFT(SERVOL,5,'*')\n   IF V = 7 THEN VOL7 = LEFT(SERVOL,5,'*')\n   IF V = 8 THEN VOL8 = LEFT(SERVOL,5,'*')\nEND\nRETURN\n\n/*     */\nGET_SELECTED_SERVER_VOLUME:\nDO I = 1 TO 8\n   SELVOL = VALUE('RV'I)\n   IF SELVOL = '' THEN ITERATE\n   RESTVOL = RSTVOL.I\n   VOLUME = STRIP(RESTVOL,'T',':')\n   LEAVE\nEND\nRETURN\n\n/*     */\nGET_HISTORY_CONTAINER_DATASETS:\nADDRESS TSO\nDSN = 0\nNWHSTLIB = 'PTECH2.NETCA.'SERVER'.'VOLUME'.H'\nNWDSN = SYSDSN(\"'\"NWHSTLIB\"'\")\nIF NWDSN = 'DATASET NOT FOUND' THEN DO\n   SAY '*** DATASET ERROR: DATASET NOT FOUND FOR ('NWHSTLIB'). ***'\n   SAY '*** NWRESTOR EXEC SUBTASK CANCELLED - RETURN CODE: (028). ***'\n   EXIT 028\nEND\n\"ALLOC DA('\"NWHSTLIB\"') FILE(NWDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('NWHSTLIB'). ***'\n   SAY '*** NWRESTOR EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\n\"EXECIO * DISKR NWDD (FINIS STEM HIST.\"\nSRC = RC\n\"FREE FILE(NWDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** EXECIO READ ERROR: ('NWHSTLIB'). ***'\n   SAY '*** NWRESTOR EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nBUDATE.1 = 'XXXX-XX-XX'\nBUDATE.2 = 'XXXX-XX-XX'\nBUDATE.3 = 'XXXX-XX-XX'\nBUDATE.4 = 'XXXX-XX-XX'\nBUDATE.5 = 'XXXX-XX-XX'\nBUDATE.6 = 'XXXX-XX-XX'\nBUDATE.7 = 'XXXX-XX-XX'\nBUDATE.8 = 'XXXX-XX-XX'\nBUDATE.9 = 'XXXX-XX-XX'\nBUDATE.10 = 'XXXX-XX-XX'\nBUDATE.11 = 'XXXX-XX-XX'\nBUDATE.12 = 'XXXX-XX-XX'\nBUDATE.13 = 'XXXX-XX-XX'\nBUDATE.14 = 'XXXX-XX-XX'\nBUDATE.15 = 'XXXX-XX-XX'\nBUDATE.16 = 'XXXX-XX-XX'\nBUDATE.17 = 'XXXX-XX-XX'\nBUDATE.18 = 'XXXX-XX-XX'\nBUDSN.1 = '--------------------------------------------'\nBUDSN.2 = '--------------------------------------------'\nBUDSN.3 = '--------------------------------------------'\nBUDSN.4 = '--------------------------------------------'\nBUDSN.5 = '--------------------------------------------'\nBUDSN.6 = '--------------------------------------------'\nBUDSN.7 = '--------------------------------------------'\nBUDSN.8 = '--------------------------------------------'\nBUDSN.9 = '--------------------------------------------'\nBUDSN.10 = '--------------------------------------------'\nBUDSN.11 = '--------------------------------------------'\nBUDSN.12 = '--------------------------------------------'\nBUDSN.13 = '--------------------------------------------'\nBUDSN.14 = '--------------------------------------------'\nBUDSN.15 = '--------------------------------------------'\nBUDSN.16 = '--------------------------------------------'\nBUDSN.17 = '--------------------------------------------'\nBUDSN.18 = '--------------------------------------------'\nDO I = 1 TO HIST.0\n   UPPER HIST.I\n   VLOC = POS(VOLKEY,HIST.I)\n   IF VLOC \u00ac= 0 THEN DO\n      BUSTATUS = WORD(HIST.I,9)\n      IF BUSTATUS = 'SSSS' THEN DO\n         BUTYPE = WORD(HIST.I,5)\n         IF BUTYPE = RESTMOD.RM THEN DO\n            DSN = DSN + 1\n            BUDATE.DSN = WORD(HIST.I,1)\n            BUTIME.DSN = WORD(HIST.I,2)\n            L = I + 1\n            UPPER HIST.L\n            HSTDSN = WORD(HIST.L,2)\n            BUDSN.DSN = STRIP(HSTDSN,\"B\",\"'\")\n         END\n      END\n   END\nEND\nRETURN\n\n/*     */\nBUILD_PANEL_DATASET_PARMS:\nDO D = 1 TO GDGCNT\n   IF BUDSN.D = '' THEN ITERATE\n   IF D = 1 THEN DO\n      BUDATE01 = BUDATE.D\n      BUDSN01 = BUDSN.D\n   END\n   IF D = 2 THEN DO\n      BUDATE02 = BUDATE.D\n      BUDSN02 = BUDSN.D\n   END\n   IF D = 3 THEN DO\n      BUDATE03 = BUDATE.D\n      BUDSN03 = BUDSN.D\n   END\n   IF D = 4 THEN DO\n      BUDATE04 = BUDATE.D\n      BUDSN04 = BUDSN.D\n   END\n   IF D = 5 THEN DO\n      BUDATE05 = BUDATE.D\n      BUDSN05 = BUDSN.D\n   END\n   IF D = 6 THEN DO\n      BUDATE06 = BUDATE.D\n      BUDSN06 = BUDSN.D\n   END\n   IF D = 7 THEN DO\n      BUDATE07 = BUDATE.D\n      BUDSN07 = BUDSN.D\n   END\n   IF D = 8 THEN DO\n      BUDATE08 = BUDATE.D\n      BUDSN08 = BUDSN.D\n   END\n   IF D = 9 THEN DO\n      BUDATE09 = BUDATE.D\n      BUDSN09 = BUDSN.D\n   END\n   IF D = 10 THEN DO\n      BUDATE10 = BUDATE.D\n      BUDSN10 = BUDSN.D\n   END\n   IF D = 11 THEN DO\n      BUDATE11 = BUDATE.D\n      BUDSN11 = BUDSN.D\n   END\n   IF D = 12 THEN DO\n      BUDATE12 = BUDATE.D\n      BUDSN12 = BUDSN.D\n   END\n   IF D = 13 THEN DO\n      BUDATE13 = BUDATE.D\n      BUDSN13 = BUDSN.D\n   END\n   IF D = 14 THEN DO\n      BUDATE14 = BUDATE.D\n      BUDSN14 = BUDSN.D\n   END\n   IF D = 15 THEN DO\n      BUDATE15 = BUDATE.D\n      BUDSN15 = BUDSN.D\n   END\n   IF D = 16 THEN DO\n      BUDATE16 = BUDATE.D\n      BUDSN16 = BUDSN.D\n   END\n   IF D = 17 THEN DO\n      BUDATE17 = BUDATE.D\n      BUDSN17 = BUDSN.D\n   END\n   IF D = 18 THEN DO\n      BUDATE18 = BUDATE.D\n      BUDSN18 = BUDSN.D\n   END\nEND\nRETURN\n\n/*     */\nGET_PANEL_INPUT_DATASET:\nDSNSW = 'NO'\nDO I = 1 TO GDGCNT\n   SELDSN = VALUE('RD'I)\n   IF SELDSN = '' THEN ITERATE\n   IF I < 10 THEN DO\n      RESTDAT = VALUE('BUDATE0'I)\n      RESTDSN = VALUE('BUDSN0'I)\n   END\n   IF I >= 10 THEN DO\n      RESTDAT = VALUE('BUDATE'I)\n      RESTDSN = VALUE('BUDSN'I)\n   END\n   IF RESTDSN = '' THEN ITERATE\n   DSNSW = 'YES'\n   LEAVE\nEND\nRETURN\n\n/*     */\nLISTCAT_CONTAINER_DATASET:\nADDRESS TSO\nT = 0\nX = OUTTRAP(\"LSTCAT.\",\"*\",\"CONCAT\")\n\"LISTCAT ENT('\"RESTDSN\"') ALL\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** LISTCAT ERROR: 'RESTDSN'. ***'\n   SAY '*** NWRESTOR EXEC SUBTASK CANCELLED - RC = ('SRC'). ***'\n   EXIT SRC\nEND\nDO L = 1 TO LSTCAT.0\n   VOLKEY = POS(\"VOLSER------------\",LSTCAT.L)\n   IF VOLKEY \u00ac= 0 THEN DO\n      STA = VOLKEY + 18\n      T = T + 1\n      TAPE.T = SUBSTR(LSTCAT.L,STA,6)\n   END\nEND\nTAPECNT = T\nRETURN\n\n/*     */\nBUILD_PANEL_TAPE_VOLSERS:\nDO T = 1 TO TAPECNT\n   IF T = 1 THEN TAPE1 = TAPE.T\n   IF T = 2 THEN TAPE2 = TAPE.T\n   IF T = 3 THEN TAPE3 = TAPE.T\n   IF T = 4 THEN TAPE4 = TAPE.T\n   IF T = 5 THEN TAPE5 = TAPE.T\n   IF T = 6 THEN TAPE6 = TAPE.T\n   IF T = 7 THEN TAPE7 = TAPE.T\n   IF T = 8 THEN TAPE8 = TAPE.T\nEND\nRETURN\n\n/*     */\nBUILD_JOBNAME_PARM:\nJN1 = 'NWR'\nJN2 = SUBSTR(TSOID,5,3)\nDO N = 1 TO 26\n   JN3 = SUBSTR(JSUFFIX,N,1)\n   JOBNAME = JN1||JN2||JN3\n   JOB = SYSDSN(\"'\"CNTLLIB\"(\"JOBNAME\")'\")\n   IF JOB = 'MEMBER NOT FOUND' THEN LEAVE\nEND\nJN = JOBNAME\nRETURN\n\n/*     */\nBUILD_RESTORE_JOB:\n\"DELSTACK\"\nRCDCNT = 36\nDIRPATH = STRIP(RESTDPN,'T','/')\nSTARGET = RESTVOL||DIRPATH\nIF RESTDPN = '*' THEN STARGET = RESTVOL\nIF SERVER  = 'C4A' THEN SERVER = 'CS4'\nIF SERVER  = 'C4B' THEN SERVER = 'CS4'\nJCL.1 = \"//\"JN\"  JOB 5304010530000000,'\"SERVER\" LAN RESTORE',NOTIFY=\"TSOID\",\"\nJCL.2 = \"//             CLASS=S,MSGCLASS=G,MSGLEVEL=(1,1),REGION=6M\"\nJCL.3 = \"/*JOBPARM SYSAFF=SYSB\"\nJCL.4 = \"//RESTORE  EXEC PGM=NUACLIEN\"\nJCL.5 = \"//NETUADD  DD DSN=PTECH3.NETCA.RESTORE.SCRIPT.PARMLIB,DISP=SHR\"\nJCL.6 = \"//SYSPRINT DD SYSOUT=*\"\nJCL.7 = \"//SYSIN DD *\"\nJCL.8 = \"CONNECT RS6000 -SERV \"SERVER\" \"LANID\" \"LANPW\nJCL.9 = \"SET DEBUG LOG SYS:/SICOM/CA/RESTORE/DEBUG.LOG\"\nJCL.10 = \"SET GLOBAL TARGET\" STARGET\nJCL.11 = \"SET GLOBAL OPTIONS -LOG SYS:/SICOM/CA/DB/RESTORE.RPT\"\nJCL.12 = \"INPUT 'SYSS.NETCA.LAN.MVSNW.UA'\"\nJCL.13 = \"INPUT DD:NETUADD(\"SMEMB\")\"\nJCL.14 = \"EXIT\"\nJCL.15 = \"/*\"\nJCL.16 = \"//WRITELOG EXEC PGM=IKJEFT01,DYNAMNBR=30,\"\nJCL.17 = \"//   PARM='%NWRSTLOG \"JMEMB\"',COND=(0,LT,RESTORE)\"\nJCL.18 = \"//SYSPRINT DD SYSOUT=*\"\nJCL.19 = \"//SYSTSPRT DD SYSOUT=*\"\nJCL.20 = \"//SYSIN    DD DUMMY\"\nJCL.21 = \"//SYSLBC   DD DSN=SYS1.BRODCAST,DISP=SHR\"\nJCL.22 = \"//SYSUADS  DD DSN=SYS1.UADS,DISP=SHR\"\nJCL.23 = \"//SYSPROC  DD DSN=SYSS.TECH.COMMON.EXECLIB,DISP=SHR\"\nJCL.24 = \"//SYSTSIN  DD DUMMY\"\nJCL.25 = \"/*\"\nJCL.26 = \"//DELETE   EXEC PGM=IDCAMS\"\nJCL.27 = \"//CNTLDD   DD DSN=\"CNTLLIB\",DISP=SHR\"\nJCL.28 = \"//SCRIPTDD DD DSN=\"SCRIPTLIB\",DISP=SHR\"\nJCL.29 = \"//SYSPRINT DD SYSOUT=*\"\nJCL.30 = \"//SYSIN    DD *\"\nJCL.31 = \"  DELETE   \"SCRIPTLIB\"(\"SMEMB\")  FILE(SCRIPTDD)\"\nJCL.32 = \"  DELETE   \"CNTLLIB\"(\"JMEMB\")  FILE(CNTLDD)\"\nJCL.33 = \"  DELETE   \"CNTLLIB\"(\"RMEMB\")  FILE(CNTLDD)\"\nJCL.34 = \"  DELETE   \"CNTLLIB\"(\"JOBNAME\")  FILE(CNTLDD)\"\nJCL.35 = \"/*\"\nJCL.36 = \"//\"\nDO J = 1 TO RCDCNT\n   QUEUE JCL.J\nEND\nRETURN\n\n/*     */\nBUILD_RESTORE_PARMS:\n\"DELSTACK\"\nRESTDSN = \"'\"||RESTDSN||\"'\"\nRESTPRM = '\"'||RESTDPN||RESTFN||' -PDT ON -REP ON\"'\nIF RESTYPE.RT = 'FILE' THEN DO\n   RECORD1 = 'CA_RESTORE 'RESTMOD.RM' 'RESTDSN' 'RESTVOL' -'\n   QUEUE RECORD1\n   RECORD2 = '   '||RESTPRM\n   QUEUE RECORD2\nEND\nIF RESTYPE.RT = 'DRCT' THEN DO\n   RESTPRM = '\"'||RESTDPN'*.* -PDT ON -REP ON\"'\n   RECORD1 = 'CA_RESTORE 'RESTMOD.RM' 'RESTDSN' 'RESTVOL' -'\n   QUEUE RECORD1\n   RECORD2 = '   '||RESTPRM\n   QUEUE RECORD2\nEND\nIF RESTYPE.RT = 'VOL' THEN DO\n   RECORD = 'CA_RESTORE 'RESTMOD.RM' 'RESTDSN' 'RESTVOL' -'\n   QUEUE RECORD\n   RECORD2 = '    \"/* -PDT ON REP ON\"'\n   QUEUE RECORD2\nEND\nRETURN\n\n/*     */\nWRITE_PDS_MEMBER:\nADDRESS TSO\n\"ALLOC DA('\"OUTPDS\"(\"OUTMEMB\")') FILE(NWDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('OUTPDS'('OUTMEMB'). ***'\n   SAY '*** NWRESTOR EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nNUMRCDS = QUEUED()\n\"EXECIO\" NUMRCDS \"DISKW NWDD (FINIS\"\nSRC = RC\n\"FREE FILE(NWDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** WRITE ERROR: ERROR WRITING 'OUTPDS'('OUTMEMB'). ***'\n   SAY '*** NWRESTOR EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nRETURN\n\n/*     */\nSUBMIT_RESTORE_JOB:\nADDRESS TSO\n\"SUBMIT ('\"SUBPDS\"(\"RMEMB\")')\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** SUBMIT ERROR: MEMBER ( 'SUBPDS'('RMEMB'). ***'\n   SAY '*** NWRESTOR EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "OP": {"ttr": 19209, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x910/\\x00\\x911/\\x119\\x00\\x04\\x00\\x04\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf1\\xf0@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1991-10-29T00:00:00", "modifydate": "1991-11-08T11:39:00", "lines": 4, "newlines": 4, "modlines": 0, "user": "TECH110"}, "text": "/* Console REXX activation */\nparse upper arg command;\n\"CONSOLE SYSCMD(\"command\")\";\nexit 0;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "OPER": {"ttr": 19211, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00\\x00\\x00\\x910/\\x00\\x93\\x16\\x0f\\x14@\\x00\\x04\\x00\\x04\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf1\\xf0@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "1991-10-29T00:00:00", "modifydate": "1993-06-09T14:40:00", "lines": 4, "newlines": 4, "modlines": 0, "user": "TECH110"}, "text": "/* Console REXX activation conversational */\n\"CONSOLE\"; /* conversational mode */\n\"CONSOLE DEACT\";\nexit 0;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "OTLMSX": {"ttr": 19213, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x17\\x00\\x00\\x00\\x922_\\x00\\x93\\x07\\x7f\\x15\\x12\\x00\\x1c\\x00'\\x00\\x14\\xe3\\xc5\\xc3\\xc8\\xf1\\xf1\\xf0@@@\"", "ispf": {"version": "01.23", "flags": 0, "createdate": "1992-11-20T00:00:00", "modifydate": "1993-03-18T15:12:00", "lines": 28, "newlines": 39, "modlines": 20, "user": "TECH110"}, "text": "/* REXX TLMS    SYSTEM UTILIZATION */\nCALL DSQCIX \"START (DSQSMODE=INTERACTIVE DSQSSUBS=DSNA\";\nif dsq_return_code \u00ac=0 then do;\n    \"VMFCLEAR\";\n    say dsq_message_id dsq_message_text;\n    say dsq_q_message_id dsq_q_message_text;\n    signal term;\n    end;\ndo forever;\n\"VMFCLEAR\";\naddress \"ISPEXEC\" \"DISPLAY PANEL(PTLMS)\";\nif rc\u00ac=0 then signal term;\ndsname=strip(dsn);\nif dsname=\"\" then dsname=\"'%'\";\n    else do; dsname=\"'\"dsname\"%'\"; end;\n\"VMFCLEAR\";\nt=dsname; /* temp variable */\nCALL DSQCIX \"RUN QUERY TECH110.QTLMS (FORM TECH110.FTLMS &FILEDSN=\"t;\nif dsq_return_code \u00ac=0 then do;\n    \"VMFCLEAR\";\n    say dsq_message_id dsq_message_text;\n    say dsq_q_message_id dsq_q_message_text;\n    signal term;\n    end;\nend;\nterm:\nCALL DSQCIX \"EXIT\";\nEXIT 0;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "OWBACKUP": {"ttr": 19215, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x02o\\x00\\x94\\x02o\\x14Q\\x02\"\\x02\"\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf7@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-01-26T00:00:00", "modifydate": "1994-01-26T14:51:00", "lines": 546, "newlines": 546, "modlines": 0, "user": "TECH107"}, "text": "/*  REXX EXEC : ( NWBACKUP ).\n    FUNCTION  : LAN BACKUP PANEL INTERFACE FACILITY FOR RESTART OF A\n                SPECIFIED SERVER VOLUME(S).\n                BUILDS AND SUBMITS THE JOB REQUIRED TO PERFORM THE\n                BACKUP OF THE FAILED VOLUME(S).\n    INPUT     : PTECH2.NETCA.&&SERVER.J&&JULIAN(&&SERVER).\n    OUTPUT    : &&USERID.DIALOG.ISPFILE(&&SERVER).\n                                                                    */\nTRACE O\n/*      */\nHOUSE_KEEPING:\nADDRESS ISPEXEC\nTSOID = SYSVAR(SYSUID)\nSERVER.1 = 'CS1 PTTS12'\nSERVER.2 = 'CS2 PTTS13'\nSERVER.3 = 'FIN PTTS14'\nSERVER.4 = 'MIS PTTS15'\nSERVER.5 = 'CS3 PTTS16'\nSERVER.6 = 'CSI PTTS17'\nSERVER.7 = 'DB1 PTTS18'\nSERVER.8 = 'SYS PTTS19'\nSERVER.9 = 'COM PTTS20M'         /*  MONTHLY ONLY  */\nSERVER.10 = 'POS PTTS31D'\nSERVER.11 = 'MAGIC PTTS32D'\nSERVER.12 = 'PAD PTTS39D'        /* CS_PDAD SERVER ALWAYS FULL BACKUP */\nBUSW.1 = 'SELECT'\nBUSW.2 = 'ALL'\nBUTP.1 = 'INCR'\nBUTP.2 = 'FULL'\nJS = 'D'\nCONFIG = 'CONFIGTI'\nBUTYPE = 'INCR'\nBUPARM = 'DAILY'\nSUB_IMMED = 'COM MAGIC PAD POS'\nIMMEDCNT = 4\nJCLLIB = 'SYSS.NETCA.PRODJCL.JCLLIB'\nTEXTLIB = 'SYSS.NETCA.CONTROL.TEXTLIB'\nPARMLIB = 'SYSS.NETCA.RESTART.PARMLIB'\nMSGLIB = 'SYSS.NETCA.MESSAGE.CNTLLIB'\nCTEXTLIB = 'SYSS.NETUA.CA.V1R1M1.TEXTLIB'\n\"CONTROL ERRORS RETURN\"\nX = MSG(\"OFF\")\n\n/*     */\nDISPLAY_SERVER_PANEL:\n\"DISPLAY PANEL(NWSRVPNL)\"\nSRC = RC\nIF SRC = 8 THEN EXIT 0\nIF SRC > 8 THEN DO\n   SAY '*** ERROR INVOKING ISPF DIALOG PANEL ( NWSRVPNL ). ***'\n   SAY '*** NWBACKUP EXEC TASK CANCELLED - RC = 'SRC'. ***'\n   EXIT SRC\nEND\n\n/*     */\nCHECK_RESTART_PARMS:\nADDRESS TSO\n\"FREE FILE(NWDD)\"\n\"FREE FILE(ISPFILE)\"\nSERVER = WORD(SERVER.LAN,1)\nTLMS1 = SERVER\nDO S = 1 TO IMMEDCNT\n   BYPASS = WORD(SUB_IMMED,S)\n   IF BYPASS = SERVER THEN DO\n      TLMS1 = SUBSTR(SERVER,1,3)\n      SUBMEMB = WORD(SERVER.LAN,2)\n      SUBPDS = JCLLIB\n      CALL SUBMIT_RESTART_JOB\n      EXIT 0\n   END\nEND\nRSPARM = SERVER||'RSPRM'\nTLMSMEMB = TLMS1||'TLMS'\nNWPDS = PARMLIB\nNWDSN = SYSDSN(\"'\"NWPDS\"(\"RSPARM\")'\")\nIF NWDSN = 'OK' THEN DO\n   VOLSW = 'RSTPARM'\n   CALL GET_RESTART_PARMS\n   IF BUTYPE = 'FULL' THEN DO\n      JS = 'W'\n      CONFIG = 'CONFIGTF'\n      BUPARM = 'DAILYF'\n   END\n   IF BLDJOB = 'NO' THEN DO\n      SUBPDS = JCLLIB\n      SMEMB = WORD(SERVER.LAN,2)\n      SUBMEMB = SMEMB||JS\n      CALL SUBMIT_RESTART_JOB\n      EXIT 0\n   END\n   CALL BUILD_RESTART_VOLUME_MEMBER\n   CALL WRITE_PDS_MEMBER\n   CALL BUILD_RESTART_CONFIG_MEMBER\n   IF CFM = 'MEMBER NOT FOUND' THEN CALL WRITE_PDS_MEMBER\n   CALL ALLOC_ISPFILE_PDS\n   CALL BUILD_RESTART_JOB\n   CALL WRITE_PDS_MEMBER\n   SMEMB = WORD(SERVER.LAN,2)\n   SUBMEMB = SMEMB||JS\n   SUBPDS = TSOID||'.DIALOG.ISPFILE'\n   CALL SUBMIT_RESTART_JOB\n   CALL DELETE_ISPFILE_PDS\n   EXIT 0\nEND\n\n/*     */\nBUILD_RESTART_VOLUME_CONFIG:\nADDRESS TSO\nBUTYPE = 'FULL'\nCALL READ_SERVER_VOLUMES_PARMS\nBUPARM = 'DAILY'\nCALL DISPLAY_VOLUME_PANEL\nIF BUSW.LBU = 'ALL' THEN DO\n   JS = 'D'\n   SUBPDS = JCLLIB\n   SMEMB = WORD(SERVER.LAN,2)\n   IF BUTP.BUT = 'FULL' THEN JS = 'W'\n   SUBMEMB = SMEMB||JS\n   CALL SUBMIT_RESTART_JOB\n   EXIT 0\nEND\nBUTYPE = BUTP.BUT\nIF BUTYPE = 'FULL' THEN BUPARM = 'DAILYF'\nCALL BUILD_PANEL_RESTART_VOLUME_MEMBER\nIF RCNT = 0 THEN DO FOREVER\n   ADDRESS ISPEXEC \"SETMSG MSG(NWLAN001)\"\n   CALL DISPLAY_VOLUME_PANEL\n   CALL BUILD_PANEL_RESTART_VOLUME_MEMBER\n   IF RCNT > 0 THEN LEAVE\nEND\nCALL WRITE_PDS_MEMBER\nCALL BUILD_RESTART_CONFIG_MEMBER\nIF CFM = 'MEMBER NOT FOUND' THEN CALL WRITE_PDS_MEMBER\nCALL ALLOC_ISPFILE_PDS\nCALL GET_PANEL_VOLUMES\nCALL BUILD_RESTART_JOB\nCALL WRITE_PDS_MEMBER\nSMEMB = WORD(SERVER.LAN,2)\nSUBMEMB = SMEMB||JS\nSUBPDS = TSOID||'.DIALOG.ISPFILE'\nCALL SUBMIT_RESTART_JOB\nCALL DELETE_ISPFILE_PDS\nEXIT 0\n\n/*     S U B R O U T I N E S   S E C T I O N     */\n/*     */\nGET_RESTART_PARMS:\nADDRESS TSO\nBLDJOB = 'YES'\n\"ALLOC DA('\"NWPDS\"(\"RSPARM\")') FILE(NWDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('NWPDS'('RSPARM'). ***'\n   SAY '*** NWBACKUP EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\n\"EXECIO * DISKR NWDD (FINIS STEM VOLR.\"\nSRC = RC\n\"FREE FILE(NWDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** EXECIO READ ERROR: ('NWPDS'('RSPARM'). ***'\n   SAY '*** NWBACKUP EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nSERVOL = WORD(VOLR.1,1)\nBUTYPE = WORD(VOLR.1,3)\nIF SERVOL = 'ALL' THEN BLDJOB = 'NO'\nRETURN\n\n/*     */\nBUILD_RESTART_VOLUME_MEMBER:\nADDRESS TSO\n\"DELSTACK\"\nOUTMEMB = SERVER||'VOLS'\nOUTPDS = PARMLIB\nVOLPARMS = SERVER||'FVOLS'\n\"ALLOC DA('\"TEXTLIB\"(\"VOLPARMS\")') FILE(NWDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('TEXTLIB'('VOLPARMS'). ***'\n   SAY '*** NWBACKUP EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\n\"EXECIO * DISKR NWDD (FINIS STEM VOLP.\"\nSRC = RC\n\"FREE FILE(NWDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** EXECIO READ ERROR: ('TEXTLIB'('VOLPARMS'). ***'\n   SAY '*** NWBACKUP EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nDO I = 1 TO VOLR.0\n   SERVOL = WORD(VOLR.I,1)\n   DO V = 1 TO VOLP.0\n      UPPER VOLP.V\n      PVOL = WORD(VOLP.V,1)\n      IF PVOL = SERVOL THEN QUEUE VOLP.V\n   END\nEND\nRETURN\n\n/*     */\nBUILD_RESTART_CONFIG_MEMBER:\nADDRESS TSO\n\"DELSTACK\"\nOUTMEMB = SERVER||'CONFG'\nOUTPDS = PARMLIB\nVOLMEMB = SERVER||'VOLS'\nCFM = SYSDSN(\"'\"PARMLIB\"(\"OUTMEMB\")'\")\nIF CFM = 'OK' THEN RETURN\n\"ALLOC DA('\"TEXTLIB\"(\"CONFIG\")') FILE(NWDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('TEXTLIB'('CONFIG'). ***'\n   SAY '*** NWBACKUP EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\n\"EXECIO * DISKR NWDD (FINIS STEM PARM.\"\nSRC = RC\n\"FREE FILE(NWDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** EXECIO READ ERROR: ('TEXTLIB'('CONFIG'). ***'\n   SAY '*** NWBACKUP EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nDO I = 1 TO PARM.0\n   CHG = POS('VOLUMES',PARM.I)\n   IF CHG \u00ac= 0 THEN DO\n      PARM.I = \"         VOLUMES      '\"PARMLIB\"(\"VOLMEMB\")'\"\n   END\n   QUEUE PARM.I\nEND\nRETURN\n\n/*     */\nBUILD_RESTART_JOB:\n\"DELSTACK\"\nJ = 22\nSRVCONFG = SERVER||'CONFG'\nSMEMB = WORD(SERVER.LAN,2)\nJN = SMEMB||JS\nOUTMEMB = JN\nWTR = SUBSTR(JN,2)\nWTRNAME = WTR'00'\nOUTPDS = TSOID||'.DIALOG.ISPFILE'\nSCHPRT = 'PTECH2.NETCA.'SERVER'.SCHPRINT'\nSYSPRT = 'PTECH2.NETCA.'SERVER'.SYSPRINT'\nJCL.1 = \"//\"JN\"  JOB O030OVRHD0000000,'\"SERVER\" LAN BACKUP',NOTIFY=TECH251,\"\nJCL.2 = \"//             CLASS=F,MSGCLASS=Q,MSGLEVEL=(1,1),REGION=6M\"\nJCL.3 = \"//STEP010  EXEC PGM=IKJEFT01,DYNAMNBR=30,\"\nJCL.4 = \"//         PARM='%NWALLOC \"SERVER\" \"BUPARM\"'\"\nJCL.5 = \"//SYSTSPRT DD SYSOUT=*\"\nJCL.6 = \"//SYSPRINT DD SYSOUT=*\"\nJCL.7 = \"//SYSIN DD DUMMY\"\nJCL.8 = \"//SYSLBC DD DSN=SYS1.BRODCAST,DISP=SHR\"\nJCL.9 = \"//SYSUADS DD DSN=SYS1.UADS,DISP=SHR\"\nJCL.10 = \"//SYSPROC DD DSN=SYSS.TECH.COMMON.EXECLIB,DISP=SHR\"\nJCL.11 = \"//SYSTSIN DD DUMMY\"\nJCL.12 = \"/*\"\nJCL.13 = \"//ABEND010 EXEC PGM=ABENDWTO,COND=(0,GE,STEP010)\"\nJCL.14 = \"//* *** STEPLIB DD DSN=SYS1.PROD.BATCH.LOADLIB,DISP=SHR\"\nJCL.15 = \"/*\"\nJCL.16 = \"//STEP020 EXEC PGM=NUACLIEN\"\nJCL.17 = \"//SCHPRINT DD DSN=\"SCHPRT\",DISP=(MOD,CATLG,DELETE),\"\nJCL.18 = \"// SPACE=(CYL,(2,0,0)),DCB=(RECFM=FBA,LRECL=133,BLKSIZE=133),\"\nJCL.19 = \"// DATACLAS=LISTING\"\nJCL.20 = \"//SYSPRINT DD DSN=\"SYSPRT\",DISP=(MOD,CATLG,DELETE),\"\nJCL.21 = \"// SPACE=(CYL,(2,0,0)),DCB=(RECFM=FBA,LRECL=133,BLKSIZE=133),\"\nJCL.22 = \"// DATACLAS=LISTING\"\nIF VOLSW = 'RSTPARM' THEN DO\n   DO I = 1 TO VOLR.0\n      JVOL = WORD(VOLR.I,1)\n      DDVOL = 'DDC'||JVOL\n      DDINDX = 'DDI'||JVOL\n      BT = BUTYPE\n      IF I = 1 THEN DO\n         TUNIT = 'UNIT=(SILO,,DEFER)'\n         SAVEDD = DDVOL\n      END\n      IF I > 1 THEN TUNIT = 'UNIT=AFF='SAVEDD\n      REC.1 = \"//\"DDVOL\"  DD DSN=PTAP.NETCA.\"SERVER\".\"JVOL\".\"BT\".CONTAINR(+1),\"\n      REC.2 = \"//         DISP=(NEW,CATLG,DELETE),\"TUNIT\",\"\n      REC.3 = \"//         VOLUME=(,,,99),LABEL=(1,SL),\"\n      REC.4 = \"//   DCB=(MODEL.DSCB,RECFM=U,LRECL=0,BLKSIZE=32760,DSORG=PS)\"\n      REC.5 = \"//\"DDINDX\" DD DSN=PTECH2.NETCA.\"SERVER\".\"JVOL\".\"BT\".INDEX(+1),\"\n      REC.6 = \"//            DISP=(NEW,CATLG,DELETE),\"\n      REC.7 = \"//  DCB=(BLKSIZE=27998,LRECL=27994,RECFM=VB,DSORG=PS),\"\n      REC.8 = \"//  DATACLAS=DATAPS,MGMTCLAS=STANDARD,STORCLAS=SCSTNRDG,\"\n      REC.9 = \"//  SPACE=(27998,(50,10),RLSE)\"\n      DO E = 1 TO 9\n         J = J + 1\n         JCL.J = REC.E\n      END\n   END\nEND\nIF VOLSW = 'PANEL' THEN DO\n   DO I = 1 TO VOLP.0\n      JVOL = WORD(VOLP.I,1)\n      DDVOL = 'DDC'||JVOL\n      DDINDX = 'DDI'||JVOL\n      BT = BUTYPE\n      IF I = 1 THEN DO\n         TUNIT = 'UNIT=(SILO,,DEFER)'\n         SAVEDD = DDVOL\n      END\n      IF I > 1 THEN TUNIT = 'UNIT=AFF='SAVEDD\n      REC.1 = \"//\"DDVOL\"  DD DSN=PTAP.NETCA.\"SERVER\".\"JVOL\".\"BT\".CONTAINR(+1),\"\n      REC.2 = \"//         DISP=(NEW,CATLG,DELETE),\"TUNIT\",\"\n      REC.3 = \"//         VOLUME=(,,,99),LABEL=(1,SL),\"\n      REC.4 = \"//   DCB=(MODEL.DSCB,RECFM=U,LRECL=0,BLKSIZE=32760,DSORG=PS)\"\n      REC.5 = \"//\"DDINDX\" DD DSN=PTECH2.NETCA.\"SERVER\".\"JVOL\".\"BT\".INDEX(+1),\"\n      REC.6 = \"//            DISP=(NEW,CATLG,DELETE),\"\n      REC.7 = \"//  DCB=(BLKSIZE=27998,LRECL=27994,RECFM=VB,DSORG=PS),\"\n      REC.8 = \"//  DATACLAS=DATAPS,MGMTCLAS=STANDARD,STORCLAS=SCSTNRDG,\"\n      REC.9 = \"//  SPACE=(27998,(50,10),RLSE)\"\n      DO E = 1 TO 9\n         J = J + 1\n         JCL.J = REC.E\n      END\n   END\nEND\nJCLCNT = J\nDO J = 1 TO JCLCNT\n   QUEUE JCL.J\nEND\nR = 0\nRCDCNT = 35\nRCD.1 = \"//NUACACON DD DSN=\"PARMLIB\"(\"SRVCONFG\"),DISP=SHR\"\nRCD.2 = \"//NUACATXT DD DSN=\"CTEXTLIB\",DISP=SHR\"\nRCD.3 = \"//PARAMS DD *\"\nRCD.4 = \"-HOST \"SERVER\" -OUTPUT 'PTECH2.NETCA.\"SERVER\".SCRIPT'\"\nRCD.5 = \"    DD:NUACACON -CHECK\"\nRCD.6 = \"//SYSIN DD *\"\nRCD.7 = \"SET INPUT VERIFY ON\"\nRCD.8 = \"INPUT DD:NUACATXT(BASIC) 'PTECH2.NETCA.\"SERVER\".SCRIPT'\"\nRCD.9 = \"/*\"\nRCD.10 = \"//STEP030 EXEC PGM=IKJEFT01,DYNAMNBR=30,\"\nRCD.11 = \"// PARM='%NWABEND \"SERVER\" \"BUTYPE\" RESTART',\"\nRCD.12 = \"// COND=(4,GE,STEP020)\"\nRCD.13 = \"//SYSTSPRT DD SYSOUT=*\"\nRCD.14 = \"//SYSPRINT DD SYSOUT=*\"\nRCD.15 = \"//SYSIN DD DUMMY\"\nRCD.16 = \"//SYSLBC DD DSN=SYS1.BRODCAST,DISP=SHR\"\nRCD.17 = \"//SYSUADS DD DSN=SYS1.UADS,DISP=SHR\"\nRCD.18 = \"//SYSPROC DD DSN=SYSS.TECH.COMMON.EXECLIB,DISP=SHR\"\nRCD.19 = \"//SYSTSIN DD DUMMY\"\nRCD.20 = \"/*\"\nRCD.21 = \"//STEP040  EXEC CATRPTS,COND=((4,GE,STEP020),(1,NE,STEP030))\"\nRCD.22 = \"//SYSIN    DD DSN=\"PARMLIB\"(\"TLMSMEMB\"),DISP=SHR\"\nRCD.23 = \"/*\"\nRCD.24 = \"//ABEND050 EXEC WTO,COND=(4,GE,STEP020)\"\nRCD.25 = \"//SYSIN DD DSN=\"MSGLIB\"(\"SERVER\"),DISP=SHR\"\nRCD.26 = \"/*\"\nRCD.27 = \"//STEP060 EXEC PGM=IEBGENER\"\nRCD.28 = \"//SYSUT1 DD DSN=\"SYSPRT\",DISP=SHR\"\nRCD.29 = \"//SYSUT2 DD SYSOUT=(V,\"WTRNAME\"),DCB=BLKSIZE=133\"\nRCD.30 = \"//SYSPRINT DD DUMMY\"\nRCD.31 = \"//SYSIN DD DUMMY\"\nRCD.32 =  \"/*\"\nRCD.33 = \"//*          ABEND STEP FOR RETURN CODE GE 4\"\nRCD.34 = \"//ABEND070 EXEC PGM=ABENDWTO,COND=(4,GE,STEP020)\"\nRCD.35 = \"//\"\nDO RCDCNT\n   R = R + 1\n   QUEUE RCD.R\nEND\nRETURN\n\n/*     */\nREAD_SERVER_VOLUMES_PARMS:\nVOLPARMS = SERVER||'FVOLS'\n\"ALLOC DA('\"TEXTLIB\"(\"VOLPARMS\")') FILE(NWDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('TEXTLIB'('VOLPARMS'). ***'\n   SAY '*** NWBACKUP EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\n\"EXECIO * DISKR NWDD (FINIS STEM VOLB.\"\nSRC = RC\n\"FREE FILE(NWDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** EXECIO READ ERROR: ('TEXTLIB'('VOLPARMS'). ***'\n   SAY '*** NWBACKUP EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nV = 0\nVOL1 = '*****'\nVOL2 = '*****'\nVOL3 = '*****'\nVOL4 = '*****'\nVOL5 = '*****'\nVOL6 = '*****'\nVOL7 = '*****'\nVOL8 = '*****'\nDO I = 1 TO VOLB.0\n   UPPER VOLB.I\n   SVOL = POS(BUPARM,VOLB.I)\n   IF SVOL = 0 THEN ITERATE\n   V = V + 1\n   SERVOL = WORD(VOLB.I,1)\n   IF V = 1 THEN VOL1 = LEFT(SERVOL,5,'*')\n   IF V = 2 THEN VOL2 = LEFT(SERVOL,5,'*')\n   IF V = 3 THEN VOL3 = LEFT(SERVOL,5,'*')\n   IF V = 4 THEN VOL4 = LEFT(SERVOL,5,'*')\n   IF V = 5 THEN VOL5 = LEFT(SERVOL,5,'*')\n   IF V = 6 THEN VOL6 = LEFT(SERVOL,5,'*')\n   IF V = 7 THEN VOL7 = LEFT(SERVOL,5,'*')\n   IF V = 8 THEN VOL8 = LEFT(SERVOL,5,'*')\nEND\nRETURN\n\n/*     */\nDISPLAY_VOLUME_PANEL:\nADDRESS ISPEXEC \"DISPLAY PANEL(NWVOLPNL)\"\nSRC = RC\nIF SRC = 8 THEN EXIT 0\nIF SRC > 8 THEN DO\n   SAY '*** ERROR INVOKING ISPF DIALOG PANEL ( NWVOLPNL ). ***'\n   SAY '*** NWBACKUP EXEC TASK CANCELLED - RC = 'SRC'. ***'\n   EXIT SRC\nEND\nRETURN\n\n/*     */\nBUILD_PANEL_RESTART_VOLUME_MEMBER:\nADDRESS TSO\n\"DELSTACK\"\nVOLSW = 'PANEL'\nOUTMEMB = SERVER||'VOLS'\nOUTPDS = PARMLIB\nVOLPARMS = SERVER||'FVOLS'\n\"ALLOC DA('\"TEXTLIB\"(\"VOLPARMS\")') FILE(NWDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('TEXTLIB'('VOLPARMS'). ***'\n   SAY '*** NWBACKUP EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\n\"EXECIO * DISKR NWDD (FINIS STEM VOLP.\"\nSRC = RC\n\"FREE FILE(NWDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** EXECIO READ ERROR: ('TEXTLIB'('VOLPARMS'). ***'\n   SAY '*** NWBACKUP EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nDO I = 1 TO 8\n   SELVOL = VALUE('VBU'I)\n   IF SELVOL = '' THEN ITERATE\n   BUVOL = VALUE('VOL'I)\n   IF BUVOL = '' THEN ITERATE\n   SVR = POS('*',BUVOL)\n   SVRVOL = BUVOL\n   IF SVR \u00ac= 0 THEN DO\n      SVR = SVR - 1\n      SVRVOL = SUBSTR(BUVOL,1,SVR)\n   END\n   DO V = 1 TO VOLP.0\n      UPPER VOLP.V\n      SVOL = POS(BUPARM,VOLP.V)\n      IF SVOL = 0 THEN ITERATE\n      PVOL = WORD(VOLP.V,1)\n      IF PVOL = SVRVOL THEN QUEUE VOLP.V\n   END\nEND\nRCNT = QUEUED()\nRETURN\n\n/*     */\nGET_PANEL_VOLUMES:\nVOLMEMB = SERVER||'VOLS'\n\"ALLOC DA('\"PARMLIB\"(\"VOLMEMB\")') FILE(NWDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('PARMLIB'('VOLMEMB'). ***'\n   SAY '*** NWBACKUP EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\n\"EXECIO * DISKR NWDD (FINIS STEM VOLP.\"\nSRC = RC\n\"FREE FILE(NWDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** EXECIO READ ERROR: ('PARMLIB'('VOLMEMB'). ***'\n   SAY '*** NWBACKUP EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nRETURN\n\n/*     */\nALLOC_ISPFILE_PDS:\nADDRESS TSO\nUCNTL = SYSDSN(DIALOG.ISPFILE)\nIF UCNTL = 'DATASET NOT FOUND' THEN DO\n\"ALLOC DA(DIALOG.ISPFILE) LIKE(USER.CNTLLIB) NEW SPACE(1,0) DIR(5) CYLINDERS\"\n   SRC = RC\n   IF SRC \u00ac= 0 THEN DO\n   SAY '*** ALLOCATE ERROR: ERROR ALLOCATING DATASET (DIALOG.ISPFILE). ***'\n   SAY '*** NWBACKUP EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\n   END\nEND\nRETURN\n\n/*     */\nWRITE_PDS_MEMBER:\n\"ALLOC DA('\"OUTPDS\"(\"OUTMEMB\")') FILE(NWDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('OUTPDS'('OUTMEMB'). ***'\n   SAY '*** NWBACKUP EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nNUMRCDS = QUEUED()\n\"EXECIO\" NUMRCDS \"DISKW NWDD (FINIS\"\nSRC = RC\n\"FREE FILE(NWDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** WRITE ERROR: ERROR WRITING 'OUTPDS'('OUTMEMB'). ***'\n   SAY '*** NWBACKUP EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nRETURN\n\n/*     */\nSUBMIT_RESTART_JOB:\nADDRESS TSO\n\"SUBMIT '\"SUBPDS\"(\"SUBMEMB\")'\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** SUBMIT ERROR: MEMBER ( 'SUBPDS'('SUBMEMB'). ***'\n   SAY '*** NWBACKUP EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nIF NWDSN = 'OK' THEN DO\n   \"ALLOC DA('\"NWPDS\"(\"RSPARM\")') FILE(NWDD) SHR\"\n   \"DELETE ('\"NWPDS\"(\"RSPARM\")') FILE(NWDD)\"\n   \"FREE FILE(NWDD)\"\nEND\nRETURN\n\n/*     */\nDELETE_ISPFILE_PDS:\nADDRESS TSO\n\"DELETE  (DIALOG.ISPFILE)   NONVSAM SCRATCH PURGE\"\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "OWRESTOR": {"ttr": 19465, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x02o\\x00\\x94\\x02o\\x14Q\\x02e\\x02e\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf7@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-01-26T00:00:00", "modifydate": "1994-01-26T14:51:00", "lines": 613, "newlines": 613, "modlines": 0, "user": "TECH107"}, "text": "/*  REXX EXEC : ( NWRESTOR ).\n    FUNCTION  : LAN SERVER BACKUP PANEL INTERFACE TO FACILITATE FILE\n                RESTORES FOR A SERVER VOLUME FROM THE MVS HOST CENTRAL\n                ARCHIVE BACKUP.\n                BUILDS AND WRITES THE JOB JCL AND INPUT SCRIPT TO\n                PERFORM THE LAN SERVER RESTORE AND SUBMITS THE JOB\n                FOR EXECUTION ON THE SYSB SYSTEM CLASS=S.\n    INPUT     : ( PTECH2.NETCA.&&SERVER.&&VOLUME.H ).\n                ( SYSS.NETCA.LAN.MVSNW.UA ).\n    OUTPUT    : ( PTECH3.NETCA.RESTORE.SCRIPT.PARMLIB(&MEMBER).\n                ( PTECH3.NETCA.RESTORE.SCRIPT.CNTLLIB(&MEMBER).\n                                                                    */\nTRACE O\n/*      */\nHOUSE_KEEPING:\nADDRESS TSO\nSERVER.1 = 'COM'\nSERVER.2 = 'CS1'\nSERVER.3 = 'CS2'\nSERVER.4 = 'MAGIC'\nSERVER.5 = 'POS'\nSERVER.6 = 'CS3'\nSERVER.7 = 'DB1'\nSERVER.8 = 'CSI'\nSERVER.9 = 'FIN'\nSERVER.10 = 'MIS'\nSERVER.11 = 'SYS'\nSERVER.12 = 'PAD'\nRESTYPE.1 = 'FILE'\nRESTYPE.2 = 'DRCT'\nRESTYPE.3 = 'VOL'\nRESTMOD.1 = 'INCR'\nRESTMOD.2 = 'FULL'\nPARMLIB = 'SYSS.TECH.COMMON.PARMLIB'\nSCRIPTLIB = 'PTECH3.NETCA.RESTORE.SCRIPT.PARMLIB'\nCNTLLIB = 'PTECH3.NETCA.RESTORE.SCRIPT.CNTLLIB'\nTEXTLIB = 'SYSS.NETCA.CONTROL.TEXTLIB'\nTSOID = SYSVAR(SYSUID)\nCURTIME = TIME()\nHH = SUBSTR(CURTIME,1,2)\nMM = SUBSTR(CURTIME,4,2)\nSS = SUBSTR(CURTIME,7,2)\nTIMEP = HH||MM||SS\nJSUFFIX = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\nX = MSG(\"OFF\")\n\"FREE FILE(NWDD)\"\nADDRESS ISPEXEC \"CONTROL ERRORS RETURN\"\n\n/*     */\nDISPLAY_SERVER_PANEL:\nAUTHPARM = 'NWHPDESK'\nNWMSG = 'NWLAN002'\nDO FOREVER\n   ADDRESS ISPEXEC\n   \"DISPLAY PANEL(NWRSTPN1)\"\n   SRC = RC\n   IF SRC = 8 THEN EXIT 0\n   IF SRC > 8 THEN DO\n      SAY '*** ERROR INVOKING ISPF DIALOG PANEL ( NWRSTPN1 ). ***'\n      SAY '*** NWRESTOR EXEC TASK CANCELLED - RC = 'SRC'. ***'\n      EXIT SRC\n   END\n   IF RESTYPE.RT = 'VOL' THEN DO\n      AUTHPARM = 'NWLANGRP'\n      NWMSG = 'NWLAN003'\n   END\n   CALL CHECK_USER_AUTHORIZATION\n   IF AUTHSW = 'YES' THEN LEAVE\n   \"SETMSG MSG(\"NWMSG\")\"\nEND\nSERVER = SERVER.LAN\nIF SERVER = 'MAGIC' THEN DO\n   VOLKEY = 'SYS SYS:'\n   RESTVOL = 'SYS:'\n   RESTDPN = 'MAGIC'\n   VOLUME = 'MAGIC'\n   SERVER = 'CS3'\n   RM = 2\n   SIGNAL BUILD_CONTAINER_DATASET_PARMS\nEND\nIF SERVER = 'POS' THEN DO\n   VOLKEY = 'VOL1 VOL1:'\n   RESTVOL = 'VOL1:'\n   RESTDPN = 'POS'\n   VOLUME = 'POS'\n   SERVER = 'CS3'\n   RM = 2\n   SIGNAL BUILD_CONTAINER_DATASET_PARMS\nEND\n\n/*     */\nDISPLAY_VOLUME_PANEL:\nADDRESS TSO\n\"FREE FILE(NWDD)\"\n\"FREE FILE(ISPFILE)\"\nCALL READ_SERVER_VOLUMES_PARMS\nADDRESS ISPEXEC \"DISPLAY PANEL(NWRSTPN2)\"\nSRC = RC\nIF SRC = 8 THEN EXIT 0\nIF SRC > 8 THEN DO\n   SAY '*** ERROR INVOKING ISPF DIALOG PANEL ( NWRSTPN2 ). ***'\n   SAY '*** NWRESTOR EXEC TASK CANCELLED - RC = 'SRC'. ***'\n   EXIT SRC\nEND\nCALL GET_SELECTED_SERVER_VOLUME\nVOLKEY = VOLUME RESTVOL\n\n/*     */\nBUILD_CONTAINER_DATASET_PARMS:\nCALL GET_HISTORY_CONTAINER_DATASETS\nIF DSN = 0 THEN DO\n   SAY '*** HISTORY DATASET ERROR: NO VALID CONTAINER DATASET NAMES FOUND. ***'\n   SAY '*** DSN ('NWHSTLIB') DOES NOT CONTAIN A BACKUP STATUS OF (SSSS). ***'\n   SAY '*** NWRESTOR EXEC TASK CANCELLED - RC = (028). ***'\n   EXIT 028\nEND\nGDGCNT = 18\nNWPANEL = 'NWRSTPN3'\nIF RESTMOD.RM = 'FULL' & SERVER \u00ac= 'PAD' THEN DO\n   GDGCNT = 6\n   NWPANEL = 'NWRSTPN4'\nEND\nCALL BUILD_PANEL_DATASET_PARMS\n\n/*     */\nDISPLAY_DATASET_LIST_PANEL:\nDO FOREVER\n   ADDRESS ISPEXEC\n   \"DISPLAY PANEL(\"NWPANEL\")\"\n   SRC = RC\n   IF SRC = 8 THEN EXIT 0\n   IF SRC > 8 THEN DO\n      SAY '*** ERROR INVOKING ISPF DIALOG PANEL ( 'NWPANEL' ). ***'\n      SAY '*** NWRESTOR EXEC TASK CANCELLED - RC = 'SRC'. ***'\n      EXIT SRC\n   END\n   CALL GET_PANEL_INPUT_DATASET\n   IF DSNSW = 'YES' THEN LEAVE\n   \"SETMSG MSG(NWLAN004)\"\nEND\nIF RESTYPE.RT = 'DRCT' & RESTFN = '' THEN RESTFN = '*'\nIF RESTYPE.RT = 'VOL' THEN DO\n   RESTDPN = '*'\n   RESTFN = '*'\nEND\n\n/*     */\nDISPLAY_INPUT_PARMS_CONFIRMATION_PANEL:\nCALL LISTCAT_CONTAINER_DATASET\nCALL BUILD_PANEL_TAPE_VOLSERS\nADDRESS ISPEXEC\n\"DISPLAY PANEL(NWRSTPN5)\"\nSRC = RC\nIF SRC = 8 THEN EXIT 0\nIF SRC > 8 THEN DO\n   SAY '*** ERROR INVOKING ISPF DIALOG PANEL ( NWRSTPN5 ). ***'\n   SAY '*** NWRESTOR EXEC TASK CANCELLED - RC = 'SRC'. ***'\n   EXIT SRC\nEND\n\n/*     */\nCREATE_RESTORE_JOB_PARMS:\nADDRESS TSO\nSUBPDS = CNTLLIB\nJMEMB = 'J'TIMEP                  /* JOURNAL PARMS MEMBER */\nRMEMB = 'R'TIMEP                  /* RESTORE JOB JCL MEMBER */\nSMEMB = 'S'TIMEP                  /* SCRIPT INPUT MEMBER */\n\"DELSTACK\"\nCALL BUILD_JOBNAME_PARM\nOUTPDS = CNTLLIB\nOUTMEMB = JOBNAME\nQUEUE JOBNAME\nCALL WRITE_PDS_MEMBER\nCALL BUILD_RESTORE_JOB\nOUTMEMB = RMEMB\nCALL WRITE_PDS_MEMBER\n\"DELSTACK\"\nQUEUE SERVER\nQUEUE RESTVOL\nQUEUE RESTDSN\nQUEUE RESTDPN\nQUEUE RESTFN\nOUTMEMB = JMEMB\nCALL WRITE_PDS_MEMBER\nCALL BUILD_RESTORE_PARMS\nOUTMEMB = SMEMB\nOUTPDS = SCRIPTLIB\nCALL WRITE_PDS_MEMBER\nCALL SUBMIT_RESTORE_JOB\nEXIT 0\n\n/*     S U B R O U T I N E S   S E C T I O N     */\n/*     */\nCHECK_USER_AUTHORIZATION:\nADDRESS TSO\nAUTHSW = 'NO'\n\"ALLOC DA('\"PARMLIB\"(\"AUTHPARM\")') FILE(NWDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('PARMLIB'('AUTHPARM'). ***'\n   SAY '*** NWRESTOR EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\n\"EXECIO * DISKR NWDD (FINIS STEM AUTH.\"\nSRC = RC\n\"FREE FILE(NWDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** EXECIO READ ERROR: ('PARMLIB'('AUTHPARM'). ***'\n   SAY '*** NWRESTOR EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nDO I = 1 TO AUTH.0\n   LAU = POS(TSOID,AUTH.I)\n   IF LAU \u00ac= 0 THEN AUTHSW = 'YES'\nEND\nRETURN\n\n/*     */\nREAD_SERVER_VOLUMES_PARMS:\nADDRESS TSO\nVOLCONFG = SERVER'IVOLS'\nIF RESTMOD.RM = 'FULL' THEN VOLCONFG = SERVER'FVOLS'\n\"ALLOC DA('\"TEXTLIB\"(\"VOLCONFG\")') FILE(NWDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('TEXTLIB'('VOLCONFG'). ***'\n   SAY '*** NWRESTOR EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\n\"EXECIO * DISKR NWDD (FINIS STEM VOLP.\"\nSRC = RC\n\"FREE FILE(NWDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** EXECIO READ ERROR: ('TEXTLIB'('VOLCONFG'). ***'\n   SAY '*** NWRESTOR EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nV = 0\nVOL1 = '*****'\nVOL2 = '*****'\nVOL3 = '*****'\nVOL4 = '*****'\nVOL5 = '*****'\nVOL6 = '*****'\nVOL7 = '*****'\nVOL8 = '*****'\nDO I = 1 TO VOLP.0\n   UPPER VOLP.I\n   SVOL = POS('DAILY',VOLP.I)\n   IF SVOL = 0 THEN ITERATE\n   V = V + 1\n   SERVOL = WORD(VOLP.I,2)\n   RSTVOL.V = WORD(VOLP.I,2)\n   IF V = 1 THEN VOL1 = LEFT(SERVOL,5,'*')\n   IF V = 2 THEN VOL2 = LEFT(SERVOL,5,'*')\n   IF V = 3 THEN VOL3 = LEFT(SERVOL,5,'*')\n   IF V = 4 THEN VOL4 = LEFT(SERVOL,5,'*')\n   IF V = 5 THEN VOL5 = LEFT(SERVOL,5,'*')\n   IF V = 6 THEN VOL6 = LEFT(SERVOL,5,'*')\n   IF V = 7 THEN VOL7 = LEFT(SERVOL,5,'*')\n   IF V = 8 THEN VOL8 = LEFT(SERVOL,5,'*')\nEND\nRETURN\n\n/*     */\nGET_SELECTED_SERVER_VOLUME:\nDO I = 1 TO 8\n   SELVOL = VALUE('RV'I)\n   IF SELVOL = '' THEN ITERATE\n   RESTVOL = RSTVOL.I\n   VOLUME = STRIP(RESTVOL,'T',':')\n   LEAVE\nEND\nRETURN\n\n/*     */\nGET_HISTORY_CONTAINER_DATASETS:\nADDRESS TSO\nDSN = 0\nNWHSTLIB = 'PTECH2.NETCA.'SERVER'.'VOLUME'.H'\nNWDSN = SYSDSN(\"'\"NWHSTLIB\"'\")\nIF NWDSN = 'DATASET NOT FOUND' THEN DO\n   SAY '*** DATASET ERROR: DATASET NOT FOUND FOR ('NWHSTLIB'). ***'\n   SAY '*** NWRESTOR EXEC SUBTASK CANCELLED - RETURN CODE: (028). ***'\n   EXIT 028\nEND\n\"ALLOC DA('\"NWHSTLIB\"') FILE(NWDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('NWHSTLIB'). ***'\n   SAY '*** NWRESTOR EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\n\"EXECIO * DISKR NWDD (FINIS STEM HIST.\"\nSRC = RC\n\"FREE FILE(NWDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** EXECIO READ ERROR: ('NWHSTLIB'). ***'\n   SAY '*** NWRESTOR EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nBUDATE.1 = 'XXXX-XX-XX'\nBUDATE.2 = 'XXXX-XX-XX'\nBUDATE.3 = 'XXXX-XX-XX'\nBUDATE.4 = 'XXXX-XX-XX'\nBUDATE.5 = 'XXXX-XX-XX'\nBUDATE.6 = 'XXXX-XX-XX'\nBUDATE.7 = 'XXXX-XX-XX'\nBUDATE.8 = 'XXXX-XX-XX'\nBUDATE.9 = 'XXXX-XX-XX'\nBUDATE.10 = 'XXXX-XX-XX'\nBUDATE.11 = 'XXXX-XX-XX'\nBUDATE.12 = 'XXXX-XX-XX'\nBUDATE.13 = 'XXXX-XX-XX'\nBUDATE.14 = 'XXXX-XX-XX'\nBUDATE.15 = 'XXXX-XX-XX'\nBUDATE.16 = 'XXXX-XX-XX'\nBUDATE.17 = 'XXXX-XX-XX'\nBUDATE.18 = 'XXXX-XX-XX'\nBUDSN.1 = '--------------------------------------------'\nBUDSN.2 = '--------------------------------------------'\nBUDSN.3 = '--------------------------------------------'\nBUDSN.4 = '--------------------------------------------'\nBUDSN.5 = '--------------------------------------------'\nBUDSN.6 = '--------------------------------------------'\nBUDSN.7 = '--------------------------------------------'\nBUDSN.8 = '--------------------------------------------'\nBUDSN.9 = '--------------------------------------------'\nBUDSN.10 = '--------------------------------------------'\nBUDSN.11 = '--------------------------------------------'\nBUDSN.12 = '--------------------------------------------'\nBUDSN.13 = '--------------------------------------------'\nBUDSN.14 = '--------------------------------------------'\nBUDSN.15 = '--------------------------------------------'\nBUDSN.16 = '--------------------------------------------'\nBUDSN.17 = '--------------------------------------------'\nBUDSN.18 = '--------------------------------------------'\nDO I = 1 TO HIST.0\n   UPPER HIST.I\n   VLOC = POS(VOLKEY,HIST.I)\n   IF VLOC \u00ac= 0 THEN DO\n      BUSTATUS = WORD(HIST.I,9)\n      IF BUSTATUS = 'SSSS' THEN DO\n         BUTYPE = WORD(HIST.I,5)\n         IF BUTYPE = RESTMOD.RM THEN DO\n            DSN = DSN + 1\n            BUDATE.DSN = WORD(HIST.I,1)\n            BUTIME.DSN = WORD(HIST.I,2)\n            L = I + 1\n            UPPER HIST.L\n            HSTDSN = WORD(HIST.L,2)\n            BUDSN.DSN = STRIP(HSTDSN,\"B\",\"'\")\n         END\n      END\n   END\nEND\nRETURN\n\n/*     */\nBUILD_PANEL_DATASET_PARMS:\nDO D = 1 TO GDGCNT\n   IF BUDSN.D = '' THEN ITERATE\n   IF D = 1 THEN DO\n      BUDATE01 = BUDATE.D\n      BUDSN01 = BUDSN.D\n   END\n   IF D = 2 THEN DO\n      BUDATE02 = BUDATE.D\n      BUDSN02 = BUDSN.D\n   END\n   IF D = 3 THEN DO\n      BUDATE03 = BUDATE.D\n      BUDSN03 = BUDSN.D\n   END\n   IF D = 4 THEN DO\n      BUDATE04 = BUDATE.D\n      BUDSN04 = BUDSN.D\n   END\n   IF D = 5 THEN DO\n      BUDATE05 = BUDATE.D\n      BUDSN05 = BUDSN.D\n   END\n   IF D = 6 THEN DO\n      BUDATE06 = BUDATE.D\n      BUDSN06 = BUDSN.D\n   END\n   IF D = 7 THEN DO\n      BUDATE07 = BUDATE.D\n      BUDSN07 = BUDSN.D\n   END\n   IF D = 8 THEN DO\n      BUDATE08 = BUDATE.D\n      BUDSN08 = BUDSN.D\n   END\n   IF D = 9 THEN DO\n      BUDATE09 = BUDATE.D\n      BUDSN09 = BUDSN.D\n   END\n   IF D = 10 THEN DO\n      BUDATE10 = BUDATE.D\n      BUDSN10 = BUDSN.D\n   END\n   IF D = 11 THEN DO\n      BUDATE11 = BUDATE.D\n      BUDSN11 = BUDSN.D\n   END\n   IF D = 12 THEN DO\n      BUDATE12 = BUDATE.D\n      BUDSN12 = BUDSN.D\n   END\n   IF D = 13 THEN DO\n      BUDATE13 = BUDATE.D\n      BUDSN13 = BUDSN.D\n   END\n   IF D = 14 THEN DO\n      BUDATE14 = BUDATE.D\n      BUDSN14 = BUDSN.D\n   END\n   IF D = 15 THEN DO\n      BUDATE15 = BUDATE.D\n      BUDSN15 = BUDSN.D\n   END\n   IF D = 16 THEN DO\n      BUDATE16 = BUDATE.D\n      BUDSN16 = BUDSN.D\n   END\n   IF D = 17 THEN DO\n      BUDATE17 = BUDATE.D\n      BUDSN17 = BUDSN.D\n   END\n   IF D = 18 THEN DO\n      BUDATE18 = BUDATE.D\n      BUDSN18 = BUDSN.D\n   END\nEND\nRETURN\n\n/*     */\nGET_PANEL_INPUT_DATASET:\nDSNSW = 'NO'\nDO I = 1 TO GDGCNT\n   SELDSN = VALUE('RD'I)\n   IF SELDSN = '' THEN ITERATE\n   IF I < 10 THEN DO\n      RESTDAT = VALUE('BUDATE0'I)\n      RESTDSN = VALUE('BUDSN0'I)\n   END\n   IF I >= 10 THEN DO\n      RESTDAT = VALUE('BUDATE'I)\n      RESTDSN = VALUE('BUDSN'I)\n   END\n   IF RESTDSN = '' THEN ITERATE\n   DSNSW = 'YES'\n   LEAVE\nEND\nRETURN\n\n/*     */\nLISTCAT_CONTAINER_DATASET:\nADDRESS TSO\nT = 0\nX = OUTTRAP(\"LSTCAT.\",\"*\",\"CONCAT\")\n\"LISTCAT ENT('\"RESTDSN\"') ALL\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** LISTCAT ERROR: 'RESTDSN'. ***'\n   SAY '*** NWRESTOR EXEC SUBTASK CANCELLED - RC = ('SRC'). ***'\n   EXIT SRC\nEND\nDO L = 1 TO LSTCAT.0\n   VOLKEY = POS(\"VOLSER------------\",LSTCAT.L)\n   IF VOLKEY \u00ac= 0 THEN DO\n      STA = VOLKEY + 18\n      T = T + 1\n      TAPE.T = SUBSTR(LSTCAT.L,STA,6)\n   END\nEND\nTAPECNT = T\nRETURN\n\n/*     */\nBUILD_PANEL_TAPE_VOLSERS:\nDO T = 1 TO TAPECNT\n   IF T = 1 THEN TAPE1 = TAPE.T\n   IF T = 2 THEN TAPE2 = TAPE.T\n   IF T = 3 THEN TAPE3 = TAPE.T\n   IF T = 4 THEN TAPE4 = TAPE.T\n   IF T = 5 THEN TAPE5 = TAPE.T\n   IF T = 6 THEN TAPE6 = TAPE.T\n   IF T = 7 THEN TAPE7 = TAPE.T\n   IF T = 8 THEN TAPE8 = TAPE.T\nEND\nRETURN\n\n/*     */\nBUILD_JOBNAME_PARM:\nJN1 = 'NWR'\nJN2 = SUBSTR(TSOID,5,3)\nDO N = 1 TO 26\n   JN3 = SUBSTR(JSUFFIX,N,1)\n   JOBNAME = JN1||JN2||JN3\n   JOB = SYSDSN(\"'\"CNTLLIB\"(\"JOBNAME\")'\")\n   IF JOB = 'MEMBER NOT FOUND' THEN LEAVE\nEND\nJN = JOBNAME\nRETURN\n\n/*     */\nBUILD_RESTORE_JOB:\n\"DELSTACK\"\nRCDCNT = 36\nDIRPATH = STRIP(RESTDPN,'T','/')\nSTARGET = RESTVOL||DIRPATH\nIF RESTDPN = '*' THEN STARGET = RESTVOL\nJCL.1 = \"//\"JN\"  JOB 5304010530000000,'\"SERVER\" LAN RESTORE',NOTIFY=\"TSOID\",\"\nJCL.2 = \"//             CLASS=S,MSGCLASS=G,MSGLEVEL=(1,1),REGION=6M\"\nJCL.3 = \"/*JOBPARM SYSAFF=SYSB\"\nJCL.4 = \"//RESTORE  EXEC PGM=NUACLIEN\"\nJCL.5 = \"//NETUADD  DD DSN=PTECH3.NETCA.RESTORE.SCRIPT.PARMLIB,DISP=SHR\"\nJCL.6 = \"//SYSPRINT DD SYSOUT=*\"\nJCL.7 = \"//SYSIN DD *\"\nJCL.8 = \"CONNECT RS6000 -SERV \"SERVER\" \"LANID\" \"LANPW\nJCL.9 = \"SET DEBUG LOG SYS:/SICOM/CA/RESTORE/DEBUG.LOG\"\nJCL.10 = \"SET GLOBAL TARGET\" STARGET\nJCL.11 = \"SET GLOBAL OPTIONS -LOG SYS:/SICOM/CA/DB/RESTORE.RPT\"\nJCL.12 = \"INPUT 'SYSS.NETCA.LAN.MVSNW.UA'\"\nJCL.13 = \"INPUT DD:NETUADD(\"SMEMB\")\"\nJCL.14 = \"EXIT\"\nJCL.15 = \"/*\"\nJCL.16 = \"//WRITELOG EXEC PGM=IKJEFT01,DYNAMNBR=30,\"\nJCL.17 = \"//   PARM='%NWRSTLOG \"JMEMB\"',COND=(0,LT,RESTORE)\"\nJCL.18 = \"//SYSPRINT DD SYSOUT=*\"\nJCL.19 = \"//SYSTSPRT DD SYSOUT=*\"\nJCL.20 = \"//SYSIN    DD DUMMY\"\nJCL.21 = \"//SYSLBC   DD DSN=SYS1.BRODCAST,DISP=SHR\"\nJCL.22 = \"//SYSUADS  DD DSN=SYS1.UADS,DISP=SHR\"\nJCL.23 = \"//SYSPROC  DD DSN=SYSS.TECH.COMMON.EXECLIB,DISP=SHR\"\nJCL.24 = \"//SYSTSIN  DD DUMMY\"\nJCL.25 = \"/*\"\nJCL.26 = \"//DELETE   EXEC PGM=IDCAMS\"\nJCL.27 = \"//CNTLDD   DD DSN=\"CNTLLIB\",DISP=SHR\"\nJCL.28 = \"//SCRIPTDD DD DSN=\"SCRIPTLIB\",DISP=SHR\"\nJCL.29 = \"//SYSPRINT DD SYSOUT=*\"\nJCL.30 = \"//SYSIN    DD *\"\nJCL.31 = \"  DELETE   \"SCRIPTLIB\"(\"SMEMB\")  FILE(SCRIPTDD)\"\nJCL.32 = \"  DELETE   \"CNTLLIB\"(\"JMEMB\")  FILE(CNTLDD)\"\nJCL.33 = \"  DELETE   \"CNTLLIB\"(\"RMEMB\")  FILE(CNTLDD)\"\nJCL.34 = \"  DELETE   \"CNTLLIB\"(\"JOBNAME\")  FILE(CNTLDD)\"\nJCL.35 = \"/*\"\nJCL.36 = \"//\"\nDO J = 1 TO RCDCNT\n   QUEUE JCL.J\nEND\nRETURN\n\n/*     */\nBUILD_RESTORE_PARMS:\n\"DELSTACK\"\nRESTDSN = \"'\"||RESTDSN||\"'\"\nRESTPRM = '\"'||RESTDPN||RESTFN||' -PDT ON -REP ON\"'\nIF RESTYPE.RT = 'FILE' THEN DO\n   RECORD1 = 'CA_RESTORE 'RESTMOD.RM' 'RESTDSN' 'RESTVOL' -'\n   QUEUE RECORD1\n   RECORD2 = '   '||RESTPRM\n   QUEUE RECORD2\nEND\nIF RESTYPE.RT = 'DRCT' THEN DO\n   RESTPRM = '\"'||RESTDPN'*.* -PDT ON -REP ON\"'\n   RECORD1 = 'CA_RESTORE 'RESTMOD.RM' 'RESTDSN' 'RESTVOL' -'\n   QUEUE RECORD1\n   RECORD2 = '   '||RESTPRM\n   QUEUE RECORD2\nEND\nIF RESTYPE.RT = 'VOL' THEN DO\n   RECORD = 'CA_RESTORE 'RESTMOD.RM' 'RESTDSN' 'RESTVOL' -'\n   QUEUE RECORD\n   RECORD2 = '    \"/* -PDT ON REP ON\"'\n   QUEUE RECORD2\nEND\nRETURN\n\n/*     */\nWRITE_PDS_MEMBER:\nADDRESS TSO\n\"ALLOC DA('\"OUTPDS\"(\"OUTMEMB\")') FILE(NWDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('OUTPDS'('OUTMEMB'). ***'\n   SAY '*** NWRESTOR EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nNUMRCDS = QUEUED()\n\"EXECIO\" NUMRCDS \"DISKW NWDD (FINIS\"\nSRC = RC\n\"FREE FILE(NWDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** WRITE ERROR: ERROR WRITING 'OUTPDS'('OUTMEMB'). ***'\n   SAY '*** NWRESTOR EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nRETURN\n\n/*     */\nSUBMIT_RESTORE_JOB:\nADDRESS TSO\n\"SUBMIT ('\"SUBPDS\"(\"RMEMB\")')\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** SUBMIT ERROR: MEMBER ( 'SUBPDS'('RMEMB'). ***'\n   SAY '*** NWRESTOR EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PDF": {"ttr": 19721, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\x00\\x00\\x91\\x14/\\x00\\x915/\\x03H\\x00\\r\\x00\"\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf1\\xf0@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "1991-05-22T00:00:00", "modifydate": "1991-12-18T03:48:00", "lines": 13, "newlines": 34, "modlines": 0, "user": "TECH110"}, "text": "/* REXX EXEC REF (SYS1.TECH.COMMON.EXECLIB)                         */\n/* Address the TSO/E environment                                    */\naddress \"TSO\";\n/* Who are we ??                                                    */\nparse value SYSVAR('sysproc') with '@IKJ' usergroup;\nmsgstat = MSG('off');\n\"EXECUTIL HT\";\naddress \"ISPEXEC\" \"CONTROL DISPLAY REFRESH\";\naddress \"ISPEXEC\" \"SELECT PANEL(@PDF\"usergroup\") NEWAPPL\";\naddress \"ISPEXEC\" \"CONTROL DISPLAY REFRESH\";\n\"EXECUTIL RT\";\nmsgstat = MSG(msgstat);\nexit 0;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PDSMATCH": {"ttr": 19723, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0b\\x00\\x00\\x00\\x91(\\x9f\\x00\\x92\\x00\\x8f\\x12\"\\x00[\\x00\\x19\\x00[\\xe3\\xc5\\xc3\\xc8\\xf1\\xf1\\xf0@@@'", "ispf": {"version": "01.11", "flags": 0, "createdate": "1991-10-16T00:00:00", "modifydate": "1992-01-08T12:22:00", "lines": 91, "newlines": 25, "modlines": 91, "user": "TECH110"}, "text": "/* REXX EXEC to compare/match PDS directory member names     */\nparse upper arg dsname1 dsname2 . ;\nif dsname2 = \"\" then exit 16; /* Missing input */\nif substr(dsname1,1,1)\u00ac=\"'\" then ,\n      dsname1 = \"'\"dsname1\"'\";\nif substr(dsname2,1,1)\u00ac=\"'\" then ,\n      dsname2 = \"'\"dsname2\"'\";\ndummy = listdsi(dsname1 \"directory\");\nif sysreason=5 then do;say \"Invalid dsname: \"dsname1;exit 16;end;\nmem1dir = sysmembers;\ndummy = listdsi(dsname2 \"directory\");\nif sysreason=5 then do;say \"Invalid dsname: \"dsname2;exit 16;end;\nmem2dir = sysmembers;\ndummy = outtrap(\"dsn1list.\");\n\"LISTDS\" dsname1 \"MEMBERS\";\ndummy = outtrap(\"OFF\");\ndummy = outtrap(\"dsn2list.\");\n\"LISTDS\" dsname2 \"MEMBERS\";\ndummy = outtrap(\"OFF\");\nin1not2 = \"\";\nin2not1 = \"\";\nmem1 = 0;\nmem2 = 0;\ndo i = 1 to dsn1list.0;\n  if dsn1list.i=\"--MEMBERS--\" then do;\n       dsn1ptr = i+1; /* first member name */\n       leave i;\n       end;\nend;\ndo i = 1 to dsn2list.0;\n  if dsn2list.i=\"--MEMBERS--\" then do;\n       dsn2ptr = i+1; /* first member name */\n       leave i;\n       end;\nend;\ndo loop=1 to 99999; /* forever loop */\n    dsn1list.dsn1ptr = word(dsn1list.dsn1ptr,1);\n    dsn2list.dsn2ptr = word(dsn2list.dsn2ptr,1);\n    if dsn1list.dsn1ptr = dsn2list.dsn2ptr then do;\n           mem1 = mem1+1; mem2 = mem2+1;\n           dsn1ptr = dsn1ptr+1;\n           dsn2ptr = dsn2ptr+1;\n           end;\n    else if dsn1list.dsn1ptr > dsn2list.dsn2ptr then do;\n           mem2 = mem2+1;\n           in2not1 = in2not1 dsn2list.dsn2ptr;\n           dsn2ptr = dsn2ptr+1;\n           end;\n    else if dsn1list.dsn1ptr < dsn2list.dsn2ptr then do;\n           mem1 = mem1+1;\n           in1not2 = in1not2 dsn1list.dsn1ptr;\n           dsn1ptr = dsn1ptr+1;\n           end;\n    if dsn1ptr>dsn1list.0 & dsn2ptr>dsn2list.0 then leave loop;\n    if dsn1ptr>dsn1list.0 then do;\n           do i = dsn2ptr to dsn2list.0;\n           dsn2list.i = word(dsn2list.i,1);\n           mem2 = mem2+1;\n           in2not1 = in2not1 dsn2list.i;\n           end;\n           leave loop;\n           end;\n    if dsn2ptr>dsn2list.0 then do;\n           do i = dsn1ptr to dsn1list.0;\n           dsn1list.i = word(dsn1list.i,1);\n           mem1 = mem1+1;\n           in1not2 = in1not2 dsn1list.i;\n           end;\n           leave loop;\n           end;\nend;\n\"VMFCLEAR\";\nalias1 = mem1dir-mem1;\nalias2 = mem2dir-mem2;\nsay \"DSNAME: \"dsname1\";   member count: \"mem1;\nsay \"DSNAME: \"dsname2\";   member count: \"mem2;\nif in1not2\u00ac=\"\" then do;\n      say \"Members in \"dsname1\" and NOT in \"dsname2;\n      ctr = words(in1not2);\n      do i = 1 to ctr;\n         say \"   \"word(in1not2,i);\n      end;\nend;\nif in2not1\u00ac=\"\" then do;\n      say \"Members in \"dsname2\" and NOT in \"dsname1;\n      ctr = words(in2not1);\n      do i = 1 to ctr;\n         say \"   \"word(in2not1,i);\n      end;\nend;\nexit 0;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PRINTLOG": {"ttr": 19726, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x91\\x14/\\x00\\x91\\x14/\\tW\\x00\\x0b\\x00\\x03\\x00\\x00\\xd1\\xc5\\xc6\\xc6\\xd2@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1991-05-22T00:00:00", "modifydate": "1991-05-22T09:57:00", "lines": 11, "newlines": 3, "modlines": 0, "user": "JEFFK"}, "text": "/* Printlog rexx exec */\n\"FREE F(ISPLOG) SYSOUT(T)\";\nif rc \\= 0 then exit rc;\nmsgstat = MSG('off');\n\"EXECUTIL HT\";\n\"FREE ATTR(ALOG)\";\n\"ATTR ALOG RECFM(V A) LRECL(125) BLKSIZE(129)\";\n\"ALLOC F(ISPLOG) SYSOUT(Z) USING(ALOG)\";\n\"EXECUTIL RT\";\nmsgstat = MSG(msgstat);\nexit 0;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PRINTQMF": {"ttr": 19969, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x92)_\\x00\\x93\\x08\\x1f\\x144\\x00\\x0b\\x00\\x0b\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf1\\xf0@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1992-10-21T00:00:00", "modifydate": "1993-03-22T14:34:00", "lines": 11, "newlines": 11, "modlines": 0, "user": "TECH110"}, "text": "/* PrintQMF rexx exec */\n\"FREE F(DSQPRINT) SYSOUT(G)\";\nif rc \\= 0 then exit rc;\nmsgstat = MSG('off');\n\"EXECUTIL HT\";\n\"FREE ATTR(ADSQPR)\";\n\"ATTR ADSQPR RECFM(F B A) LRECL(160) BLKSIZE(3200)\";\n\"ALLOC F(DSQPRINT) SYSOUT(G) USING(ADSQPR)\";\n\"EXECUTIL RT\";\nmsgstat = MSG(msgstat);\nexit 0;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "PXREFPRC": {"ttr": 19971, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01%\\x00\\x00\\x00\\x923/\\x00\\x94\\t\\x0f\\x11\\x05\\x00A\\x00\\x05\\x00A\\xe3\\xc5\\xc3\\xc8\\xf1\\xf1\\xf0@@@'", "ispf": {"version": "01.37", "flags": 0, "createdate": "1992-11-27T00:00:00", "modifydate": "1994-03-31T11:05:00", "lines": 65, "newlines": 5, "modlines": 65, "user": "TECH110"}, "text": "/* REXX PRODXREF FILLIN MISSING PROCEDURE NAMES */\n\"EXECIO * DISKR XREFIN (STEM XREFIN. FINIS\";\nXOUT=1;\nPROCNAME_STACK=\"\";\nPROCSTEP_STACK=\"\";\nCURRENT_JOBNAME=\"\";\nDO I = 1 TO XREFIN.0;\n  PARSE VAR XREFIN.I JOBNAME 9 JOBCLASS 10 EPROCSN 18 PROCNAME ,\n      26 EPGMSN 34 EXECPGM 42 STEPPROC 45 STEPJOB ,\n      48 DDNAME 56 DSNAME 100 MEMBER 108 DISP 111 ACCESS;\n  JOBNAME=STRIP(JOBNAME);\n  PROCNAME=STRIP(PROCNAME);\n  EPROCSN=STRIP(EPROCSN);\n  EPGMSN=STRIP(EPGMSN);\n  DDNAME=STRIP(DDNAME);\n  DSNAME=STRIP(DSNAME);\n  MEMBER=STRIP(MEMBER);\n  DISP=STRIP(DISP);\n  ACCESS =STRIP(ACCESS);\n  IF JOBNAME\u00ac=CURRENT_JOBNAME THEN DO;\n       FILLFLAG=\"\";\n       PROCNAME_STACK = \"\";\n       PROCSTEP_STACK = \"\";\n       CURRENT_JOBNAME = JOBNAME;\n       XREFOUT.XOUT = XREFIN.I; /* DUP RECORD UNCHANGED */\n       XOUT = XOUT + 1;\n       ITERATE I;\n       END;\n  IF STEPPROC=\" \" & PROCNAME\u00ac=\" \" THEN DO;\n       FILLFLAG=\"\";\n       PROCNAME_STACK = PROCNAME PROCNAME_STACK;\n       PROCSTEP_STACK = EPROCSN  PROCSTEP_STACK;\n       XREFOUT.XOUT = XREFIN.I; /* DUP RECORD UNCHANGED */\n       XOUT = XOUT + 1;\n       ITERATE I;\n       END;\n  IF STEPPROC\u00ac=\" \" & PROCNAME=\" \" & STEPPROC\u00ac=\"000\" & ,\n     PROCNAME_STACK\u00ac=\" \" & PROCSTEP_STACK\u00ac=\" \" & ,\n     PROCNAME_STACK\u00ac=\"\" & PROCSTEP_STACK\u00ac=\"\" THEN DO;\n      IF FILLFLAG=\"\" THEN DO;\n       PROCNAME_STACK = DELWORD(PROCNAME_STACK,1,1);\n       PROCSTEP_STACK = DELWORD(PROCSTEP_STACK,1,1);\n       FILLFLAG=\"ON\";\n      END;\n       EPROCSN=\" \";\n       PROCNAME=\" \";\n       IF PROCNAME_STACK\u00ac=\"\" THEN ,\n          PROCNAME = WORD(PROCNAME_STACK,1);\n       IF PROCSTEP_STACK\u00ac=\"\" THEN ,\n          EPROCSN  = WORD(PROCSTEP_STACK,1);\n       XREFOUT.XOUT = XREFIN.I; /* DUP RECORD UNCHANGED */\n       XREFOUT.XOUT=OVERLAY(EPROCSN,XREFOUT.XOUT,10,8);\n       XREFOUT.XOUT=OVERLAY(PROCNAME,XREFOUT.XOUT,18,8);\n       XOUT = XOUT + 1;\n       ITERATE I;\n       END;\n  ELSE DO;\n       FILLFLAG=\"\";\n       XREFOUT.XOUT = XREFIN.I; /* DUP RECORD UNCHANGED */\n       XOUT = XOUT + 1;\n       ITERATE I;\n       END;\nEND;\n\"EXECIO * DISKW XREFOUT (STEM XREFOUT. FINIS\";\nEXIT 0;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "QAXREF": {"ttr": 19973, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x01\\x00\\x00\\x00\\x94\\x14_\\x00\\x944\\x9f\\t'\\x00\\x11\\x00`\\x00\\x11\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf7@@@\"", "ispf": {"version": "01.01", "flags": 0, "createdate": "1994-05-25T00:00:00", "modifydate": "1994-12-15T09:27:00", "lines": 17, "newlines": 96, "modlines": 17, "user": "TECH107"}, "text": "PROC 0\nCONTROL NOMSG NOPROMPT NOLIST\nFREE F(OFFLINE ERRORS MASTER FOCEXEC FMU SYSIN FOCLIB FOCSQL PROFILE)\nALLOC F(FOCLIB)  DA('SYSS.FOCUS.V6R8M0.FOCSQL.LOAD') SHR\nALLOC F(FOCSQL)  DA('SYSS.TECH.COMMON.FOCSQL.DATA' -\n                    'SYSS.FOCUS.V6R8M0.FOCSQL.DATA') SHR\nALLOC F(ERRORS)  DA('SYSS.FOCUS.V6R8M0.ERRORS.DATA') SHR\nALLOC F(MASTER)  DA('SYSS.TECH.COMMON.MASTER.DATA' -\n                    'SYSS.FOCUS.V6R8M0.MASTER.DATA') SHR\nALLOC F(FOCEXEC) DA('SYSS.TECH.COMMON.FOCEXEC.DATA') SHR\nALLOC F(PROFILE) DA('SYSS.TECH.COMMON.QXRF.PROFILE') SHR\nALLOC F(FMU)     DA('SYSS.TECH.COMMON.FMU.DATA') SHR\nALLOC F(OFFLINE) SYSOUT(G) RECFM(F,B,A) LRECL(161) BLKSIZE(1610) -\n      FCB(GT15)\nCALL 'SYS1.FOCUS.V6R8M0.LOAD(FOCUS)'\nFREE F(OFFLINE ERRORS MASTER FOCEXEC FMU SYSIN FOCLIB FOCSQL PROFILE)\nEXIT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "QWSDSF": {"ttr": 19975, "alias": false, "halfwords": 0, "notes": 0, "parms": "b''", "ispf": false, "text": "/* REXX */\n/*                        >>>  QWSDSF <<<                    Rel 4.1 */\n/* > See comments describing this exec at the bottom of this member< */\n/*                                                                   */\n/* Trace ?R */                       /* For debugging, if needed     */\nAddress ISPEXEC\nINTAB1 = '000102030405060708090A0B0C0D0E0F'X \",=+*/()?\"  /*Translate */\nINTAB2 = '101112131415161718191A1B1C1D1E1F7D7F'X         /*Tables    */\nINTAB3 = '7D7F'X\n\"VGET (QWCSRP QWCSRN ISFBUF ZSCREENW) SHARED\"\nIf RC > 0\n Then\n Do\n Say 'VGET Return Code = ' RC\n Say 'See \"Debugging Cursor-Driven Invocation\" in Chapter Four of the'\n Say 'MVS/QuickRef User Guide'\nEnd\nIf RC = 0                /* If VGET flys, then we can do our thing   */\n Then\n Do\n \"VGET (ZAPPLID) SHARED\"\n QWSCRENW = ZSCREENW\n If ZAPPLID = \"QWRF\" THEN QWSCRENW = 78\n IF substr(QWCSRN,1,5) = \"PDSLN\"  /* Check for PdsTools invocation  */\n  THEN\n  DO\n  \"VGET (PDSTNAME PDSCSRRO) SHARED\"\n  IF substr(PDSTNAME,1,3) >< \"PDS\"\n   THEN\n   DO\n   SAY '***ERROR: This is not a PDSTOOLS log panel'\n   EXIT 12\n   END\n  \"TBTOP \" PDSTNAME\n  \"TBSKIP \" PDSTNAME \" NUMBER(\"PDSCSRRO\")\"\n  If QWCSRN = \"PDSLN1\" Then ISFBUF = pdsln1\n  If QWCSRN = \"PDSLN2\"\n   THEN\n   DO\n   ISFBUF = substr(pdsln1,80,79)\n   END\n  QWSCRENW = 79\n  QWSCRN = 1\n  PDSTNAME = \"NOTPDS\"    /* clear the table name for the next call */\n  END                    /* End of PdsTools inserts                */\n CURAREA = Translate(ISFBUF,\" \",INTAB1)  /* Blank out unwanted bytes */\n CURAREA = Translate(CURAREA,\" \",INTAB2) /* Blank out unwanted bytes */\n START = Lastpos(\" \",CURAREA,QWCSRP)   /* Set bounds for scan        */\n If START = 0 Then START = 1           /* Cursor offset can't be 0   */\n CURSOR_ROW = (QWCSRP-1) % QWSCRENW    /* Get row number cursor is on*/\n START_ROW = START % QWSCRENW          /* Row number field starts on */\n QWCLNE = substr(ISFBUF,((CURSOR_ROW*QWSCRENW)+1),QWSCRENW)\n QWCLNE = Translate(QWCLNE,\" \",INTAB3)\n /* If field starts on prior row, back-scan just to start of this row*/\n If START_ROW < CURSOR_ROW Then\n  START = ((QWCSRP % QWSCRENW) * QWSCRENW) + 1\n LGTH = ((START % QWSCRENW) +1) * QWSCRENW\n LGTH = (LGTH - START) + 1\n curword = Strip(Substr(curarea,start,lgth),\"L\") /*Strip unneeded*/\n Parse var curword msgid . 1 msgpx +3  /* parse out token & prefix   */\n parm=\"*=\"msgid        /* Force cross-topic search technique */\n/* Use line below instead of one above for cross-database search    */\n/* parm=\"?=\"msgid */\n parm = \"7D\"X || parm || \"FF\"X || QWCLNE || \"7D\"X\n \"SELECT PGM(QWIKREF1) PARM(\"parm\") NEWAPPL(QWRF)\"\n/* Use line below instead of one above if using QW LIBDEF CLIST */\n/* \"SELECT CMD(%QW PRM(\"parm\")) NEWAPPL(QWRF)\" */\nExit 0\nEnd\n/* This exec is used to invoke MVS/QuickRef from within several      */\n/* products that are used to view SYSOUT or the SYSLOG.  Supported   */\n/* products include SDSF, IOF, SAR, OPS/MVS, $AVRS, FLASHER, and     */\n/* any other application that uses a dynamic area to present text    */\n/* that contains messages or items stored within MVS/QuickRef.       */\n/* This exec parses out the word that the cursor is on and           */\n/* invokes MVS/QuickRef with the appropriate fast-path parm to       */\n/* immediately display the description of the message or JCL keyword */\n/* the cursor is on.                                                 */\n/*                                                                   */\n/* Instructions on how to install and use this exec can be found in  */\n/* chapter four of the MVS/QuickRef user's guide.  You MUST modify   */\n/* your main data display panel for SDSF, FLASHER, SAR, IOF, $AVRS,  */\n/* OPS/MVS, or any other product for which cursor driven invocation  */\n/* of MVS/QuickRef is desired, as documented in chapter four of the  */\n/* MVS/QuickRef User's Guide.                                        */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "QXOLD": {"ttr": 19978, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x944\\x9f\\x00\\x944\\x9f\\t%\\x00`\\x00`\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf7@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-12-15T00:00:00", "modifydate": "1994-12-15T09:25:00", "lines": 96, "newlines": 96, "modlines": 0, "user": "TECH107"}, "text": "/* REXX Production QAXREF            */\nCALL DSQCIX \"START (DSQSMODE=INTERACTIVE DSQSSUBS=DSNA\";\nif dsq_return_code \u00ac=0 then do;\n    \"VMFCLEAR\";\n    say dsq_message_id dsq_message_text;\n    say dsq_q_message_id dsq_q_message_text;\n    signal term;\n    end;\ndo forever;\n\"VMFCLEAR\";\naddress \"ISPEXEC\" \"DISPLAY PANEL(QAXREF)\";\nif rc\u00ac=0 then signal term;\njobname=strip(job); procname=strip(proc);\nprogram=strip(prog); dsname=strip(dsn); member=strip(mem);\naccess=strip(acc);\norder = \"\";\nwhere1=\"\";\nwhere2=\"\";\nwhere3=\"\";\nwhere4=\"\";\nwhere5=\"\";\nwhere6=\"\";\nif jobname\u00ac=\"\" then do;\n    where1=\"JOB_NAME LIKE '\"jobname\"%'\";\n    order=\"(JOB_NAME,STEP_WITHIN_JOB,DATASET_NAME)\";\n    end;\nif procname\u00ac=\"\" then do;\n    if where1=\"\" then do;\n       where2=\"PROC_NAME LIKE '\"procname\"%'\";\n       order=\"(PROC_NAME,JOB_NAME,STEP_WITHIN_JOB,DATASET_NAME)\";\n     end;\n    else ,\n       where2=\" AND PROC_NAME LIKE '\"procname\"%'\";\n    end;\nif program\u00ac=\"\" then do;\n    if where1=\"\" & where2=\"\" then do;\n       where3=\"EXEC_PGM LIKE '\"program\"%'\";\n       order=\"(EXEC_PGM,JOB_NAME,STEP_WITHIN_JOB,DATASET_NAME)\";\n     end;\n    else ,\n       where3=\" AND EXEC_PGM LIKE '\"program\"%'\";\n    end;\nif dsname\u00ac=\"\" then do;\n    if where1=\"\" & where2=\"\" & where3=\"\" then do;\n       where4=\"DATASET_NAME LIKE '\"dsname\"%'\";\n       order=\"(DATASET_NAME,JOB_NAME,STEP_WITHIN_JOB)\";\n     end;\n    else ,\n       where4=\" AND DATASET_NAME LIKE '\"dsname\"%'\";\n    end;\nif member\u00ac=\"\" then do;\n    if where1=\"\" & where2=\"\" & where3=\"\" & where4=\"\" then ,\n       where5=\"MEMBER LIKE '\"member\"%'\";\n    else ,\n       where5=\" AND MEMBER LIKE '\"member\"%'\";\n    end;\nif access\u00ac=\"\" then do;\n    if where1=\"\" & where2=\"\" & where3=\"\" & where4=\"\" & where5=\"\" then ,\n       where6=\"ACCESS LIKE '\"access\"%'\";\n    else ,\n       where6=\" AND ACCESS LIKE '\"access\"%'\";\n    end;\nif order=\"\" then ,\n    order=\"(JOB_NAME,STEP_WITHIN_JOB,DATASET_NAME)\";\nif where1=\"\" & where2=\"\" & where3=\"\" & where4=\"\" & where5=\"\" & ,\n   where6=\"\" then ,\n   do;\n    \"VMFCLEAR\";\n    say \"You DID NOT enter a selection criteria\";\n    iterate;\n    end;\nwhere1=\"(\"where1\")\";\nwhere2=\"(\"where2\")\";\nwhere3=\"(\"where3\")\";\nwhere4=\"(\"where4\")\";\nwhere5=\"(\"where5\")\";\nwhere6=\"(\"where6\")\";\n\"VMFCLEAR\";\nCALL DSQCIX \"RUN QUERY TECH110.QAXREF (FORM TECH110.FQAXREF \"|| ,\n                             \"&WHERE1=\"where1\",\" || ,\n                             \"&WHERE2=\"where2\",\" || ,\n                             \"&WHERE3=\"where3\",\" || ,\n                             \"&WHERE4=\"where4\",\" || ,\n                             \"&WHERE5=\"where5\",\" || ,\n                             \"&WHERE6=\"where6\",\" || ,\n                             \"&ORDER=\"order;\nif dsq_return_code \u00ac=0 then do;\n    \"VMFCLEAR\";\n    say dsq_message_id dsq_message_text;\n    say dsq_q_message_id dsq_q_message_text;\n    signal term;\n    end;\nend;\nterm:\nCALL DSQCIX \"EXIT\";\nEXIT 0;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RACRESUM": {"ttr": 19981, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x11\\x00\\x00\\x00\\x92\\t?\\x00\\x95%\\x1f\\x15#\\x00\\x18\\x00\\x01\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf1\\xf0@@@'", "ispf": {"version": "01.17", "flags": 0, "createdate": "1992-04-02T00:00:00", "modifydate": "1995-09-08T15:23:00", "lines": 24, "newlines": 1, "modlines": 0, "user": "TECH110"}, "text": "/* REXX */\n/*\"VMFCLEAR\";*/\nSAY \"\";\nSAY \"\";\nGETID:\nSAY \"Enter the userid to be resumed; else enter 'END'\";\nPARSE UPPER PULL USERID . ;\nDO WHILE(USERID=\"\");\n   /*  \"VMFCLEAR\"; */\n     SAY \"Missing userid; Please re-enter OR 'END'\";\n     PARSE UPPER PULL USERID . ;\nEND;\n/*IF USERID=\"END\" THEN EXIT 24;*/\nIF USERID=\"END\" THEN DO; ADDRESS \"TSO\" \"LOGOFF\"; EXIT 0; END;\n\"VMFCLEAR\";\n\"WHOIS\" USERID;\nIF RC \u00ac= 0 THEN DO; SAY WHOIS; SIGNAL GETID; END;\nSAY 'Verify the following userdata:'\nSAY STRIP(WHOIS);\nSAY \"Enter a 'Y' to continue; else enter 'N'\";\nPARSE UPPER PULL ANS;\nIF ANS \u00ac= 'Y' THEN SIGNAL GETID;\n'ALU' USERID 'PASSWORD('STRIP(USERID)') RESUME'\nSIGNAL GETID;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RCAPAF": {"ttr": 19983, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01+\\x00\\x00\\x00\\x922_\\x00\\x936/\\x15G\\x00\\x10\\x00'\\x00\\r\\xe3\\xc5\\xc3\\xc8\\xf1\\xf1\\xf0@@@\"", "ispf": {"version": "01.43", "flags": 0, "createdate": "1992-11-20T00:00:00", "modifydate": "1993-12-28T15:47:00", "lines": 16, "newlines": 39, "modlines": 13, "user": "TECH110"}, "text": "/* REXX Production XREF            */\nCALL DSQCIX \"START (DSQSMODE=BATCH DSQSSUBS=DSNA\";\nif dsq_return_code \u00ac=0 then do;\n    say dsq_message_id dsq_message_text;\n    say dsq_q_message_id dsq_q_message_text;\n    signal term;\n    end;\nCALL DSQCIX \"RUN PROC TECH110.PCAPAF\";\nif dsq_return_code \u00ac=0 then do;\n    say dsq_message_id dsq_message_text;\n    say dsq_q_message_id dsq_q_message_text;\n    signal term;\n    end;\nterm:\nCALL DSQCIX \"EXIT\";\nEXIT 0;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REFRESH": {"ttr": 19985, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x06\\x00\\x00\\x00\\x911\\x9f\\x00\\x912\\x1f\\x10\\x15\\x00|\\x00\\x13\\x00z\\xe3\\xc5\\xc3\\xc8\\xf1\\xf1\\xf0@@@'", "ispf": {"version": "01.06", "flags": 0, "createdate": "1991-11-15T00:00:00", "modifydate": "1991-11-17T10:15:00", "lines": 124, "newlines": 19, "modlines": 122, "user": "TECH110"}, "text": "/* REXX EXEC to refresh a target system from a maintenance system */\nparse upper arg product_name; /* passed parm */\nif product_name=\"\" | product_name=\"ESABASE\" then lvl=\"SYS1\";\n    else if product_name=\"TECHCOMM\" then lvl=\"SYS1.TECH.COMMON\";\n    else lvl = \"SYS1.\"product_name;\ndummy = outtrap(\"dsnlist.\");\n\"LISTC LEVEL('\"lvl\"') NAMES CAT('SYS1.MCATSYSM.CLUSTER')\";\ndummy = outtrap(\"OFF\");\nif product_name=\"\" then do;\n   products = \"ESABASE TECHCOMM\"; /* init product list */\n   prodlist.ESABASE = \"\"; /* init ESABASE dsname list */\n   prodlist.TECHCOMM = \"\"; /* init TECHCOMM dsname list */\n   end;\nelse do; /* reinit */\n   products=product_name; /* reinit */\n   prodlist.product_name = \"\";\n   end;\ndo index =1 to dsnlist.0;\n   parse upper var dsnlist.index enttype . dsname;\n   if enttype\u00ac=\"NONVSAM\" then iterate index;\n   dsname=strip(dsname);\n   quoted_dsname=\"'\"dsname\"'\";\n   funcrc = LISTDSI(quoted_dsname);\n   if funcrc>4 then iterate index; /* tape entry or gdg etc. */\n   if SYSDSORG\u00ac=\"PO\" then iterate index;\n   parse var dsname hlq \".\" mlq \".\" llq1 \".\" llqs;\n   if llq1=\"\" then do; /* dsn w/only 2 quals= part of ESA base */\n        prodlist.ESABASE = prodlist.ESABASE dsname;\n        end;\n   else if mlq=\"TECH\" & llq1=\"COMMON\" then do;\n        prodlist.TECHCOMM = prodlist.TECHCOMM dsname;\n        end;\n   else do; /* product */\n        parse var llq1 \"V\" vers \"R\" rel \"M\" mod;\n        if mod=\"\" & substr(llq1,1,4)\u00ac=\"NTVA\" then ,\n                iterate index; /* non-conform dsname */\n        revdsn = reverse(dsname); /* see if SMPTLIB */\n        parse var revdsn tlib \".\" . ;\n        tlib = reverse(tlib);\n        if substr(tlib,1,1)=\"F\" & datatype(substr(tlib,2),'W') then ,\n              iterate index; /* ignore if smptlib */\n        if wordpos(mlq,products)=0 then do;/* first time product*/\n                products=products mlq;\n                prodlist.mlq = dsname;\n                end;\n            else do;\n                prodlist.mlq = prodlist.mlq dsname;\n                end;\n        end;\nend;\nif product_name\u00ac=\"\" & prodlist.product_name=\"\" then do;\n     say \"No datasets found!\";\n     exit 0;\n     end;\n\"VMFCLEAR\";\nif product_name\u00ac=\"\" then do;\n     say \"Processing product\" product_name;\n     say \"\";\n     say \"The following datasets will be refreshed\";\n     ctr = words(prodlist.product_name);\n     do index = 1 to ctr;\n         say \"      \"word(prodlist.product_name,index);\n     end;\nend;\nelse do;\n     say \"Processing ALL products\";\n     say \"\";\n     say \"The following products will be refreshed\";\n     say \"\";\n     ctr = words(products);\n     do index = 1 to ctr;\n         say \"      \"word(products,index);\n     end;\nend;\nsay \"\";\nsay \"Enter to save REFRJOB in\" userid()\".USER.CNTLLIB\";\nsay \"Type and enter 'QUIT' to exit\";\nparse upper pull status;\nif status\u00ac=\"\" then exit 0;\n\"ALLOC F(REFROUT) DA('\"userid()\".USER.CNTLLIB(REFRJOB)') SHR\";\nstepctr=1;\nfdrddn = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\nline.1=\"//REFRJOB JOB (5304010530000000),'TECH.SUPPORT',\";\nline.2=\"// NOTIFY=\"userid()\",CLASS=S,MSGCLASS=G,MSGLEVEL=(1,1)\";\nlinectr=3;\nproduct_ctr = words(products);\ndo index=1 to product_ctr;\n      pname=word(products,index);\n      line.linectr=\"//STEP\"stepctr \"EXEC PGM=FDRCOPY,REGION=8M\";\n      stepctr=stepctr+1; linectr=linectr+1;\n      line.linectr=\"//SYSPRINT DD SYSOUT=*\";\n      linectr=linectr+1;\n      fdrptr = 1;\n      dctr=words(prodlist.pname);\n      do dindex=1 to dctr;\n          pdsn=word(prodlist.pname,dindex);\n          parse var pdsn . \".\" pdsn; /* strip hlq */\n          ddn=substr(fdrddn,fdrptr,1);fdrptr=fdrptr+1;\n          line.linectr=\"//SYSPRIN\"ddn \"DD SYSOUT=*\";\n          linectr=linectr+1;\n          line.linectr=\"//DISK\"ddn \"DD DSN=SYSM.\"pdsn\",DISP=SHR\";\n          linectr=linectr+1;\n          line.linectr=\"//TAPE\"ddn \"DD DSN=SYSA.\"pdsn\",DISP=SHR\";\n          linectr=linectr+1;\n      end;\n      line.linectr=\"//SYSIN DD *\";\n      linectr=linectr+1;\n      line.linectr=\"  COPY TYPE=DSF,ENQERR=PROCESS,DSNENQ=NONE\";\n      linectr=linectr+1;\n      fdrptr = 1;\n      do dindex=1 to dctr;\n          pdsn=word(prodlist.pname,dindex);\n          parse var pdsn . \".\" pdsn; /* strip hlq */\n          ddn=substr(fdrddn,fdrptr,1);fdrptr=fdrptr+1;\n          line.linectr=\"  SELECT DSN=SYS1.\"pdsn\",TAPEDD=\"ddn;\n          linectr=linectr+1;\n      end;\n      line.linectr=\"/*\";\n      linectr=linectr+1;\nend;\nline.linectr=\"//\";\n\"EXECIO * DISKW REFROUT (FINIS STEM LINE.\";\n\"FREE F(REFROUT)\";\nexit 0;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "REXXSMF": {"ttr": 19988, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0b\\x00\\x00\\x00\\x92&\\x9f\\x00\\x95\\x00\\x9f\\x14C\\x00F\\x00\\x16\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf3@@@'", "ispf": {"version": "01.11", "flags": 0, "createdate": "1992-09-25T00:00:00", "modifydate": "1995-01-09T14:43:00", "lines": 70, "newlines": 22, "modlines": 0, "user": "TECH103"}, "text": "/* REXX EXEC : ( REXXSMF )\n   FUNCTION  : INTEROGATE SYS1.MAN DATASETS AND SWITCH IF NECESSARY.\n               JCL WILL HAVE TO PASS A PARM OF MAN1, MAN2, MANA, OR\n               MANB.    */\nTRACE R\nADDRESS TSO\nARG DSNPARM\nPARMS = 'DSNPARM'\nERC = 0\nMSGCNT = 0\nDO 5\n\"CONSOLE ACTIVATE\"\n\"CONSPROF SOLDISPLAY(NO)\"\nADDRESS CONSOLE\n  \"D SMF\"\n  X = GETMSG('MSGTXT.','SOL',,,30)\n  SRC = RC\n  IF SRC = 0 THEN LEAVE\nEND\nIF SRC \u00ac= 0 THEN DO\n   ERC = 12\n   EXIT ERC\nEND\nDO I = 1 TO MSGTXT.0\n   SMFMSG = POS(DSNPARM,MSGTXT.I)\n   IF SMFMSG \u00ac= 0 THEN DO\n      REPLY_ID = WORD(MSGTXT.I,5)\n      SAY '+++ REPLY-ID: ('REPLY_ID') +++'\n      LEAVE\n   END\nEND\nIF REPLY_ID = \"ACTIVE\" THEN DO\n   \"I SMF\"\nEND\nCALL CHECK_SMF\nADDRESS TSO\n\"CONSOLE DEACTIVATE\"\nEXIT ERC\n/* SUBROUTINE */\nCHECK_SMF:\nDO 10\nADDRESS TSO\n\"SLEEP 000030\"\nADDRESS CONSOLE\n\"D SMF\"\nX = GETMSG('MSGTXT.','SOL',,,30)\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   ERC = 12\n   EXIT ERC\nEND\nDO I = 1 TO MSGTXT.0\n   SMFMSG = POS(DSNPARM,MSGTXT.I)\n   IF SMFMSG \u00ac= 0 THEN DO\n      REPLY_ID = WORD(MSGTXT.I,5)\n      SAY '+++ REPLY-ID: ('REPLY_ID') +++'\n      LEAVE\n   END\nEND\nIF REPLY_ID \\= \"ACTIVE\" THEN LEAVE\n   SAY '+++ REPLY-ID: ('REPLY_ID') +++'\n   MSGCNT = MSGCNT + 1\n   IF MSGCNT = 10 THEN DO\n      SAY \"THE SMF MAN DATASETS HAVE NOT BEEN SWITCHED!!\"\n      SAY \"THE SMF MAN DATASETS HAVE NOT BEEN SWITCHED!!\"\n      SAY \"THE SMF MAN DATASETS HAVE NOT BEEN SWITCHED!!\"\n      ERC = 12\n      EXIT ERC\n   END\nEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RMAXMON": {"ttr": 20225, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x13\\x00\\x00\\x00\\x92\\x05\\x8f\\x00\\x92\\t\\x1f\\x15\\x04\\x003\\x00\\x01\\x003\\xe3\\xc5\\xc3\\xc8\\xf1\\xf1\\xf0@@@'", "ispf": {"version": "01.19", "flags": 0, "createdate": "1992-02-27T00:00:00", "modifydate": "1992-03-31T15:04:00", "lines": 51, "newlines": 1, "modlines": 51, "user": "TECH110"}, "text": "/* ******************* REXX XBM monitor ************************** */\ntrue = \"1\"; false = \"0\";\naddress \"TSO\"; /* map environment */\ndsname = \"'SYS1.PRODSYSI.MASTER(TRC00D00)'\"; /* parmlib */\nddname = LIBALLOC(dsname); /* allocate parmlib even if librarian */\n\"EXECIO * DISKR\" ddname \"(FINIS STEM TBLINPUT.\"; /* acquire job */\npsaaold = storage(\"00000224\",4); /* locate current ascb from psa */\nascbasxb = storage(d2x(c2d(psaaold)+108),4); /* mapping asxb */\nasxbuser = storage(d2x(c2d(ascbasxb)+192),7); /* locate userid */\nmatch = false; /* Assume error */\ndo index = 1 to tblinput.0; /* Scan for name translation */\n    parse var tblinput.index origname newname . ;\n    origname=strip(origname); newname=strip(newname);\n    if origname\u00ac=asxbuser then iterate;\n         else do;\n            match=true;\n            jcl_member_name = newname;\n            leave index;\n            end;\nend;\nif \u00acmatch then exit 20; /* Leave as no table match */\ndsname = \"'SYS1.PRODJCL.MASTER(\"jcl_member_name\")'\"; /* parmlib */\nddname = LIBALLOC(dsname); /* allocate parmlib even if librarian */\n\"EXECIO * DISKR\" ddname \"(FINIS STEM JCLINPUT.\"; /* acquire job */\ngenuser = false; /* Generated job must have USER= */\ndo index = 1 to jclinput.0; /* scan */\n     if substr(jclinput.index,1,3)=\"//*\" then iterate; /* ignore */\n     if pos(\"USER=\",jclinput.index)\u00ac=0 then do;\n              /* Dont let job sub with USER=RMAX; will cause loop */\n              /* Must be USER=ZEKE                                */\n              if pos(\"USER=ZEKE\",jclinput.index)=0 then exit 16;\n              genuser=true; /* Valid job */\n              leave index; /* exit loop */\n              end;\nend;\nif \u00acgenuser then exit 16; /* Leave as invalid JCL found */\ncounter = jclinput.0+1; /* number of base jcl statements */\njclinput.counter = \"//SYSUT1 DD DATA,DCB=BLKSIZE=80\"; /* xbm in */\ncounter = counter+1; /* prep for sysin datastream loop */\n\"EXECIO * DISKR SYSIN (FINIS STEM STREAM.\"; /* process xbm input */\ndo index = 1 to stream.0;\n     jclstate = substr(stream.index,1,2); /* ignore jcl */\n     if jclstate=\"//\" | jclstate=\"/*\" then iterate; /*...*/\n     jclinput.counter = stream.index; /* add to output jcl */\n     counter = counter + 1; /* next */\nend;\njclinput.counter = \"/*\"; /* xbm sysin eof */\ncounter = counter+1; /* last time */\njclinput.counter = \"//\"; /* xbm sysin eof */\n\"EXECIO * DISKW INTRDR (FINIS STEM JCLINPUT.\"; /* write job */\nexit 0;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SAF": {"ttr": 20227, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x94\"\\x7f\\x00\\x94\"\\x7f\\x14\\x15\\x00&\\x00&\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf6\\xf0\\xf1@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1994-08-15T00:00:00", "modifydate": "1994-08-15T14:15:00", "lines": 38, "newlines": 38, "modlines": 0, "user": "TECH601"}, "text": "/*PROC 1 PREFIX\nCONTROL NOLIST NOMSG\n/* FILENAME : CLIST(SAF)\n/*\n/* ALLOCATION OF SAF PROGRAM-SUPPORT FILES\n/*\nALLOC F(FOCLIB)    DA('SYS1.SMARTDB2.V1R1M0.SMSAF.LOAD') SHR REU\nALLOC F(USERLIB)   DA('SYS1.SMARTDB2.V1R1M0.SMSAF.LOAD') SHR REU\n/*\n/* ALLOCATION OF SAF APPLICATION-SUPPORT FILES\n/*\nALLOC F(MASTER)    DA('SYSS.SMARTDB2.V1R1M0.SMDB2.APPS') SHR REU\nALLOC F(FOCEXEC)   DA('SYSS.SMARTDB2.V1R1M0.SMDB2.APPS') SHR REU\nALLOC F(TRF)       DA('SYSS.SMARTDB2.V1R1M0.SMDB2.APPS') SHR REU\nALLOC F(FOCSQL)    DA('SYSS.SMARTDB2.V1R1M0.SMDB2.DATA') SHR REU\nALLOC F(ERRORS)    DA('SYSS.SMARTDB2.V1R1M0.SMDB2.DATA') SHR REU\n/*\n/* INVOCATION OF SMSAF UTILITY PROGRAM\n/*\n   CALL 'SYS1.SMARTDB2.V1R1M0.SMSAF.LOAD(SMSAF)'\n/*\n/* FILE DE-ALLOCATION\n/*\n   FREE F(FOCLIB)\n   FREE F(USERLIB)\n   FREE F(MASTER)\n   FREE F(FOCEXEC)\n   FREE F(FOCSQL)\n   FREE F(TRF)\n   FREE F(ERRORS)\n   FREE F(STDOUT)\n   FREE F(FOCSORT)\n   FREE F(HOLD)\n   FREE F(HOLDMAST)\n   FREE F(FOCSTACK)\n   FREE F(OFFLINE)\n/*\nEXIT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SAS608": {"ttr": 20229, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94&/\\x00\\x94&/\\x11\\x11\\x01\"\\x01\"\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf1\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-09-19T00:00:00", "modifydate": "1994-09-19T11:11:00", "lines": 290, "newlines": 290, "modlines": 0, "user": "TECH110"}, "text": "/*********************************************************************\n/*  PRODUCT: MVS SAS RELEASE 6.08                                  ***\n/*  DOCUMENTATION: SAS Companion for the MVS Environment, Version 6***\n/*  FROM: SAS INSTITUTE INC., SAS Campus Drive, Cary, NC 27513     ***\n/*********************************************************************\nPROC 0                                                            +\n   ENTRY   (SASXA1)               /* Entry point name          */ +\n   CONFIG  ()                     /* User CONFIG file DSN      */ +\n   SASUSER ()                     /* SASUSER file DSN          */ +\n   AUTOEXEC ()                    /* User AUTOEXEC DSN         */ +\n   SASAUTOS ()                    /* User SASAUTOS DSN         */ +\n   LOAD     ()                    /* User load library DSN     */ +\n   /* --------ALLOW ALTERNATE DDNAMES ------------------------ */ +\n   DDCONFIG () DFCONFIG(CONFIG)   /* CONFIG= file DDname       */ +\n   DDSASUSR () DFSASUSR(SASUSER)  /* SASUSER= data lib DDname  */ +\n   DDAUTOEX () DFAUTOEX(SASEXEC)  /* AUTOEXEC= file DDname     */ +\n   DDSASAUT () DFSASAUT(SASAUTOS) /* SASAUTOS= library  DDname */ +\n   DDPARMCD () DFPARMCD(SASPARM)  /* PARMCARDS= file DDname    */ +\n   DDWORK   () DFWORK  (WORK)     /* WORK= data lib DDname     */ +\n   DDSYSIN  () DFSYSIN (SYSIN)    /* SYSIN= file DDname        */ +\n   DDLOG    () DFLOG   (SASLOG)   /* LOG= file DDname          */ +\n   DDPRINT  () DFPRINT (SASLIST)  /* PRINT= file DDname        */ +\n   DDSASMSG () DFSASMSG(SASMSG)   /* SASMSG=  library DDname   */ +\n   DDSASHLP () DFSASHLP(SASHELP)  /* SASHELP= data lib DDname  */ +\n   OPTIONS ()                     /* SAS options               */ +\n   PARMCARD(1)                    /* parmcard file size        */ +\n   UNITS   (CYL)                  /* alloc unit for LOG, PARMS */ +\n   WORK    ('500,200')          /* WORK data lib size in blks*/ +\n   INPUT   (*)                    /* SAS source i/p DSN        */ +\n   LOG     (*)                    /* SAS log DSN/size          */ +\n   PRINT   (*)                    /* SAS list DSN              */ +\n   BLOCK   (264)                  /* PRINT BLOCKSIZE           */ +\n   LRECL   (260)                  /* PRINT LRECL               */ +\n   SASLOAD ('''SYSS.SAS.V6R8M0.LIBRARY''')+\n                                  /* SAS load library DSN      */ +\n   SASMSG ('''SYSS.SAS.V6R8M0.SASMSG''')+\n                                  /* SAS message library DSN   */ +\n   SASHELP ('''SYSS.SAS.V6R8M0.SASHELP''')+\n                                  /* SAS catalog library DSN   */ +\n   MAUTS   ('''SYSS.SAS.V6R8M0.AUTOLIB''')+\n                                  /* SAS macro source DSN      */ +\n   SORTLINK(*)                    /* put system sort lib in    */ +\n                                  /* STEPLIB?  * => No         */ +\n   SORTLDSN('''SYS1.SORTLIB''')                              +\n                                  /* system sort library DSN   */ +\n   GO                             /* Continue previous session?*/ +\n   FLUSH   NOFLUSH                /* Flush stack if error?     */ +\n   STAE    NOSTAE                 /* Trap main task abends?    */ +\n   STAI    NOSTAI                 /* Trap subtask abends?      */ +\n   STAX    NOSTAX                 /* Trap attentions?          */ +\n   STACK   NOSTACK                /* Create new i/p stack?     */ +\n   SHARE   NOSHARE                /* Share subpool 78          */ +\n   TRACE                          /* CLIST debugging           */\n/*\n/*--------------------------------------------------------------\n/* Enable clist debugging options\n/*--------------------------------------------------------------\n/*\nIF &TRACE NE THEN +\n   CONTROL LIST CONLIST SYMLIST\nCONTROL ASIS\n/*\n/* -----------------------------------------------------------\n/* set DDnames and corresponding options appropriately\n/* -----------------------------------------------------------\n/*\nIF &DDCONFIG NE THEN +\n      SET OPTIONS=&STR(&OPTIONS CONFIG=&DDCONFIG)\nELSE +\n      SET DDCONFIG=&DFCONFIG\n\nIF &DDSASUSR NE THEN +\n      SET OPTIONS=&STR(&OPTIONS SASUSER=&DDSASUSR)\nELSE +\n      SET DDSASUSR=&DFSASUSR\n\nIF &DDAUTOEX NE THEN +\n      SET OPTIONS=&STR(&OPTIONS AUTOEXEC=&DDAUTOEX)\nELSE +\n      SET DDAUTOEX=&DFAUTOEX\n\nIF &DDSASAUT NE THEN +\n      SET OPTIONS=&STR(&OPTIONS SASAUTOS=&DDSASAUT)\nELSE +\n      SET DDSASAUT=&DFSASAUT\n\nIF &DDPARMCD NE THEN +\n      SET OPTIONS=&STR(&OPTIONS PARMCARDS=&DDPARMCD)\nELSE +\n      SET DDPARMCD=&DFPARMCD\n\nIF &DDWORK NE THEN +\n      SET OPTIONS=&STR(&OPTIONS WORK=&DDWORK)\nELSE +\n      SET DDWORK=&DFWORK\n\nIF &DDSYSIN NE THEN +\n      SET OPTIONS=&STR(&OPTIONS SYSIN=&DDSYSIN)\nELSE +\n      SET DDSYSIN=&DFSYSIN\n\nIF &DDLOG NE THEN +\n      SET OPTIONS=&STR(&OPTIONS LOG=&DDLOG)\nELSE +\n      SET DDLOG=&DFLOG\n\nIF &DDPRINT NE THEN +\n      SET OPTIONS=&STR(&OPTIONS PRINT=&DDPRINT)\nELSE +\n      SET DDPRINT=&DFPRINT\n\nIF &DDSASMSG NE THEN +\n      SET OPTIONS=&STR(&OPTIONS SASMSG=&DDSASMSG)\nELSE +\n      SET DDSASMSG=&DFSASMSG\n\nIF &DDSASHLP NE THEN +\n      SET OPTIONS=&STR(&OPTIONS SASHELP=&DDSASHLP)\nELSE +\n      SET DDSASHLP=&DFSASHLP\n/*\n/*--------------------------------------------------------------\n/* if SU11 installed then set SU11 to REUSE, else set it to null\n/*--------------------------------------------------------------\n/*\nSET SU11=REUSE\n/*\n/*--------------------------------------------------------------\n/* free files and attribute lists for reuse\n/*--------------------------------------------------------------\n/*\nCONTROL NOMSG\nFREE ATTR(SASDCB)\nIF &SU11 EQ  THEN DO\n  IF &GO EQ THEN DO\n     FREE FILE(&DDSYSIN &DDLOG &DDPRINT &DDWORK &DDSASHLP &DDCONFIG  +\n               &DDSASUSR &DDPARMCD &DDSASAUT &DDSASMSG SAMPSIO MAPS)\n  END\n  ELSE +\n     FREE FILE(&DDSYSIN &DDLOG)\nEND\nCONTROL MSG\n/*\n/*--------------------------------------------------------------\n/* Allocate SOURCE data set\n/*--------------------------------------------------------------\n/*\nIF &STR(&INPUT) NE &STR(*) THEN DO\n   SET OPTIONS=&STR(&OPTIONS SYSIN=&DDSYSIN)\n   ALLOC F(&DDSYSIN) DA(&INPUT) SHR &SU11\nEND\n/*\n/*--------------------------------------------------------------\n/* Allocate LOG file data set\n/*--------------------------------------------------------------\n/*\nIF &STR(&LOG) NE THEN DO\n   IF &DATATYPE(&STR(&SUBSTR(1:1,&STR(&LOG)))) EQ CHAR THEN +\n      ALLOC FILE(&DDLOG) DA(&LOG) &SU11\n   ELSE +\n      ALLOC FILE(&DDLOG) &UNITS SP(&LOG) &SU11\nEND\n/*\n/*--------------------------------------------------------------\n/* Allocate SASEXEC data set\n/*--------------------------------------------------------------\n/*\nIF &STR(&AUTOEXEC) NE THEN +\n   ALLOC F(&DDAUTOEX) DA(&AUTOEXEC) SHR &SU11\n/*\n/*--------------------------------------------------------------\n/* If GO, set NOWORKINIT so WORK not initialized\n/* Allocate other data sets if no GO option\n/*--------------------------------------------------------------\n/*\nIF &GO NE  THEN DO\n  SET &OPTIONS = &STR(&OPTIONS NOWORKINIT)\nEND\nELSE DO\n  /*\n  /* Allocate config file    User config concatenated after, since\n  /*                         later options supersede prior\n  /*\n  SET &CONFIGL = &STR('SYSS.SAS.V6R8M0.CNTLLIB(TSOXA)' +\n  &CONFIG)\n  ALLOC F(&DDCONFIG) DA(&CONFIGL) SHR &SU11\n  /*\n  /*\n  /* Allocate WORK file data set\n  /*\n  /*\n  ALLOC F(&DDWORK) SP(&WORK) DSORG(PS) UNIT(SYSDA) ROUND  +\n        RECFM(F S) LRECL(6144) BLKSIZE(6144) &SU11\n  /*\n  /*\n  /* Allocate MSG file data set\n  /*\n  /*\n  ALLOC F(&DDSASMSG) DA(&SASMSG) SHR &SU11\n  /*\n  /*\n  /* Allocate PRINT file data set\n  /*\n  /*\n   IF &STR(&PRINT) NE THEN DO\n     ATTRIB SASDCB RECFM(V B A) LRECL(&LRECL) BLKSIZE(&BLOCK) DSORG(PS)\n     IF &DATATYPE(&STR(&SUBSTR(1:1,&STR(&PRINT)))) EQ CHAR THEN +\n        ALLOC FILE(&DDPRINT) DA(&PRINT) USING(SASDCB) MOD &SU11\n     ELSE +\n        ALLOC FILE(&DDPRINT) &UNITS SP(&PRINT) USING(SASDCB) &SU11\n     FREE ATTR(SASDCB)\n   END\n  /*\n  /*\n  /* Allocate HELP library\n  /*\n  /*\n  ALLOC F(&DDSASHLP) DA(&SASHELP) SHR &SU11\n  /*\n  /*\n  /* Allocate SASPARM for parms\n  /*\n  /*\n  IF &STR(&PARMCARD) NE THEN +\n     ALLOC FILE(&DDPARMCD) &UNITS SP(&PARMCARD) UNIT(SYSDA) &SU11\n  /*\n  /*\n  /* Allocate SASUSER library   If SASUSER option specifies user file\n  /*                            dsn, allocate it. Otherwise check for\n  /*                            SASUSER by standard name.  If it does\n  /*                            not exist, create it.  If it does, use\n  /*                            it.\n  /*      NOTE:  To use the &SYSDSN CLIST function as shown,\n  /*      you need to have TSO/E Version 1, Release 3, or a\n  /*      subsequent release, installed.\n  /*\n  IF &SYSPREF EQ  THEN +\n    SET &USRPREF = &SYSUID\n  ELSE +\n    SET &USRPREF = &SYSPREF\n  IF &STR(&SASUSER) EQ THEN +\n      SET &SASUSER = &STR('&USRPREF..SAS608.SASUSER')\n  SET STATE = &SYSDSN(&SASUSER)\n  IF &STATE = OK  THEN +\n     ALLOC F(&DDSASUSR) DA(&SASUSER) OLD &SU11\n  ELSE +\n  IF &STATE = DATASET NOT FOUND THEN DO\n     WRITE Warning: SASUSER file does not exist, will be created.\n     ALLOC F(&DDSASUSR) DA(&SASUSER) NEW CATALOG SP(30 5) ROUND +\n           DSORG(PS) RECFM(F S) BLKSIZE(6144) &SU11\n     END\n  ELSE DO\n     WRITE Warning: SASUSER file: &STATE\n     WRITE          SASUSER file not allocated to this session\n     END\n  /*\n  /*\n  /* Allocate SASAUTOS autocall macro libraries\n  /*\n  /*\n  SET SASAUTOS = &STR(&SASAUTOS &MAUTS)\n  ALLOC F(&DDSASAUT) DA(&SASAUTOS) SHR &SU11\n  /*\n  /*\n  /* Allocate SAMPSIO sample SAS data library\n  /*\n  /*\n  ALLOC F(SAMPSIO) DA('SAS.SAS608.SAMPSIO') +\n        SHR &SU11\n END\n/*\n/* put system sort link library in STEPLIB if needed\n/*\nIF &STR(&SORTLINK) NE THEN +\n   SET SORTLDSN=&STR()\n/*\n/*\n/* Invoke SAS\n/*\n/*\nSET TASKLIB = &STR(&LOAD &SASLOAD &SORTLDSN)\nSET PARM=&STR(T(&TASKLIB) E(&ENTRY) O('&OPTIONS') &FLUSH &NOFLUSH +\n              &STAE &NOSTAE &STAI &NOSTAI &STAX &NOSTAX +\n              &STACK &NOSTACK &SHARE &NOSHARE)\nSASCP &PARM\nSET RC=&LASTCC\nCONTROL NOMSG\nIF &AUTOEXEC NE  THEN +\n  FREE F(&DDAUTOEX)\nEXIT CODE(&RC)\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "SAVEACDS": {"ttr": 20235, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x92\\x02\\x1f\\x00\\x92\\x02\\x1f\\x145\\x00\\x04\\x00\\x04\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf1\\xf0@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1992-01-21T00:00:00", "modifydate": "1992-01-21T14:35:00", "lines": 4, "newlines": 4, "modlines": 0, "user": "TECH110"}, "text": "/* REXX Saveacds */\naddress \"TSO\";\n\"CONSOLE SYSCMD(SETSMS SAVEACDS(SYSS.ACDS2.CLUSTER))\";\nexit 0;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SAVENWB": {"ttr": 20237, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x07\\x7f\\x00\\x94\\x07\\x7f\\x15S\\x02&\\x02&\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf7@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-03-18T00:00:00", "modifydate": "1994-03-18T15:53:00", "lines": 550, "newlines": 550, "modlines": 0, "user": "TECH107"}, "text": "/*  REXX EXEC : ( NWBACKUP ).\n    FUNCTION  : LAN BACKUP PANEL INTERFACE FACILITY FOR RESTART OF A\n                SPECIFIED SERVER VOLUME(S).\n                BUILDS AND SUBMITS THE JOB REQUIRED TO PERFORM THE\n                BACKUP OF THE FAILED VOLUME(S).\n    INPUT     : PTECH2.NETCA.&&SERVER.J&&JULIAN(&&SERVER).\n    OUTPUT    : &&USERID.DIALOG.ISPFILE(&&SERVER).\n    1/26/94 - REALITY AND ASP ADDED\n                                                                    */\nTRACE O\n/*      */\nHOUSE_KEEPING:\nADDRESS ISPEXEC\nTSOID = SYSVAR(SYSUID)\nSERVER.1 = 'CS1 PTTS12'\nSERVER.2 = 'CS2 PTTS13'\nSERVER.3 = 'FIN PTTS14'\nSERVER.4 = 'MIS PTTS15'\nSERVER.5 = 'CS3 PTTS16'\nSERVER.6 = 'CSI PTTS17'\nSERVER.7 = 'DB1 PTTS18'\nSERVER.8 = 'SYS PTTS19'\nSERVER.9 = 'COM PTTS20M'         /*  MONTHLY ONLY  */\nSERVER.10 = 'POS PTTS31D'\nSERVER.11 = 'MAGIC PTTS32D'\nSERVER.12 = 'PAD PTTS39D'        /* CS_PDAD SERVER ALWAYS FULL BACKUP */\nSERVER.13 = 'REA PTTS41D'        /* CS_1 VOL2 REALITY */\nSERVER.14 = 'REA PTTS41W'        /* CS_1 VOL2 REALITY */\nSERVER.15 = 'ASP PTTS42D'        /* CS_2 SERVER ALWAYS FULL BACKUP */\nBUSW.1 = 'SELECT'\nBUSW.2 = 'ALL'\nBUTP.1 = 'INCR'\nBUTP.2 = 'FULL'\nJS = 'D'\nCONFIG = 'CONFIGTI'\nBUTYPE = 'INCR'\nBUPARM = 'DAILY'\nSUB_IMMED = 'COM MAGIC PAD POS REA ASP'\nIMMEDCNT = 6\nJCLLIB = 'SYSS.NETCA.PRODJCL.JCLLIB'\nTEXTLIB = 'SYSS.NETCA.CONTROL.TEXTLIB'\nPARMLIB = 'SYSS.NETCA.RESTART.PARMLIB'\nMSGLIB = 'SYSS.NETCA.MESSAGE.CNTLLIB'\nCTEXTLIB = 'SYSS.NETUA.CA.V1R1M1.TEXTLIB'\n\"CONTROL ERRORS RETURN\"\nX = MSG(\"OFF\")\n\n/*     */\nDISPLAY_SERVER_PANEL:\n\"DISPLAY PANEL(NWSRVPNL)\"\nSRC = RC\nIF SRC = 8 THEN EXIT 0\nIF SRC > 8 THEN DO\n   SAY '*** ERROR INVOKING ISPF DIALOG PANEL ( NWSRVPNL ). ***'\n   SAY '*** NWBACKUP EXEC TASK CANCELLED - RC = 'SRC'. ***'\n   EXIT SRC\nEND\n\n/*     */\nCHECK_RESTART_PARMS:\nADDRESS TSO\n\"FREE FILE(NWDD)\"\n\"FREE FILE(ISPFILE)\"\nSERVER = WORD(SERVER.LAN,1)\nTLMS1 = SERVER\nDO S = 1 TO IMMEDCNT\n   BYPASS = WORD(SUB_IMMED,S)\n   IF BYPASS = SERVER THEN DO\n      TLMS1 = SUBSTR(SERVER,1,3)\n      SUBMEMB = WORD(SERVER.LAN,2)\n      SUBPDS = JCLLIB\n      CALL SUBMIT_RESTART_JOB\n      EXIT 0\n   END\nEND\nRSPARM = SERVER||'RSPRM'\nTLMSMEMB = TLMS1||'TLMS'\nNWPDS = PARMLIB\nNWDSN = SYSDSN(\"'\"NWPDS\"(\"RSPARM\")'\")\nIF NWDSN = 'OK' THEN DO\n   VOLSW = 'RSTPARM'\n   CALL GET_RESTART_PARMS\n   IF BUTYPE = 'FULL' THEN DO\n      JS = 'W'\n      CONFIG = 'CONFIGTF'\n      BUPARM = 'DAILYF'\n   END\n   IF BLDJOB = 'NO' THEN DO\n      SUBPDS = JCLLIB\n      SMEMB = WORD(SERVER.LAN,2)\n      SUBMEMB = SMEMB||JS\n      CALL SUBMIT_RESTART_JOB\n      EXIT 0\n   END\n   CALL BUILD_RESTART_VOLUME_MEMBER\n   CALL WRITE_PDS_MEMBER\n   CALL BUILD_RESTART_CONFIG_MEMBER\n   IF CFM = 'MEMBER NOT FOUND' THEN CALL WRITE_PDS_MEMBER\n   CALL ALLOC_ISPFILE_PDS\n   CALL BUILD_RESTART_JOB\n   CALL WRITE_PDS_MEMBER\n   SMEMB = WORD(SERVER.LAN,2)\n   SUBMEMB = SMEMB||JS\n   SUBPDS = TSOID||'.DIALOG.ISPFILE'\n   CALL SUBMIT_RESTART_JOB\n   CALL DELETE_ISPFILE_PDS\n   EXIT 0\nEND\n\n/*     */\nBUILD_RESTART_VOLUME_CONFIG:\nADDRESS TSO\nBUTYPE = 'FULL'\nCALL READ_SERVER_VOLUMES_PARMS\nBUPARM = 'DAILY'\nCALL DISPLAY_VOLUME_PANEL\nIF BUSW.LBU = 'ALL' THEN DO\n   JS = 'D'\n   SUBPDS = JCLLIB\n   SMEMB = WORD(SERVER.LAN,2)\n   IF BUTP.BUT = 'FULL' THEN JS = 'W'\n   SUBMEMB = SMEMB||JS\n   CALL SUBMIT_RESTART_JOB\n   EXIT 0\nEND\nBUTYPE = BUTP.BUT\nIF BUTYPE = 'FULL' THEN BUPARM = 'DAILYF'\nCALL BUILD_PANEL_RESTART_VOLUME_MEMBER\nIF RCNT = 0 THEN DO FOREVER\n   ADDRESS ISPEXEC \"SETMSG MSG(NWLAN001)\"\n   CALL DISPLAY_VOLUME_PANEL\n   CALL BUILD_PANEL_RESTART_VOLUME_MEMBER\n   IF RCNT > 0 THEN LEAVE\nEND\nCALL WRITE_PDS_MEMBER\nCALL BUILD_RESTART_CONFIG_MEMBER\nIF CFM = 'MEMBER NOT FOUND' THEN CALL WRITE_PDS_MEMBER\nCALL ALLOC_ISPFILE_PDS\nCALL GET_PANEL_VOLUMES\nCALL BUILD_RESTART_JOB\nCALL WRITE_PDS_MEMBER\nSMEMB = WORD(SERVER.LAN,2)\nSUBMEMB = SMEMB||JS\nSUBPDS = TSOID||'.DIALOG.ISPFILE'\nCALL SUBMIT_RESTART_JOB\nCALL DELETE_ISPFILE_PDS\nEXIT 0\n\n/*     S U B R O U T I N E S   S E C T I O N     */\n/*     */\nGET_RESTART_PARMS:\nADDRESS TSO\nBLDJOB = 'YES'\n\"ALLOC DA('\"NWPDS\"(\"RSPARM\")') FILE(NWDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('NWPDS'('RSPARM'). ***'\n   SAY '*** NWBACKUP EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\n\"EXECIO * DISKR NWDD (FINIS STEM VOLR.\"\nSRC = RC\n\"FREE FILE(NWDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** EXECIO READ ERROR: ('NWPDS'('RSPARM'). ***'\n   SAY '*** NWBACKUP EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nSERVOL = WORD(VOLR.1,1)\nBUTYPE = WORD(VOLR.1,3)\nIF SERVOL = 'ALL' THEN BLDJOB = 'NO'\nRETURN\n\n/*     */\nBUILD_RESTART_VOLUME_MEMBER:\nADDRESS TSO\n\"DELSTACK\"\nOUTMEMB = SERVER||'VOLS'\nOUTPDS = PARMLIB\nVOLPARMS = SERVER||'FVOLS'\n\"ALLOC DA('\"TEXTLIB\"(\"VOLPARMS\")') FILE(NWDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('TEXTLIB'('VOLPARMS'). ***'\n   SAY '*** NWBACKUP EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\n\"EXECIO * DISKR NWDD (FINIS STEM VOLP.\"\nSRC = RC\n\"FREE FILE(NWDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** EXECIO READ ERROR: ('TEXTLIB'('VOLPARMS'). ***'\n   SAY '*** NWBACKUP EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nDO I = 1 TO VOLR.0\n   SERVOL = WORD(VOLR.I,1)\n   DO V = 1 TO VOLP.0\n      UPPER VOLP.V\n      PVOL = WORD(VOLP.V,1)\n      IF PVOL = SERVOL THEN QUEUE VOLP.V\n   END\nEND\nRETURN\n\n/*     */\nBUILD_RESTART_CONFIG_MEMBER:\nADDRESS TSO\n\"DELSTACK\"\nOUTMEMB = SERVER||'CONFG'\nOUTPDS = PARMLIB\nVOLMEMB = SERVER||'VOLS'\nCFM = SYSDSN(\"'\"PARMLIB\"(\"OUTMEMB\")'\")\nIF CFM = 'OK' THEN RETURN\n\"ALLOC DA('\"TEXTLIB\"(\"CONFIG\")') FILE(NWDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('TEXTLIB'('CONFIG'). ***'\n   SAY '*** NWBACKUP EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\n\"EXECIO * DISKR NWDD (FINIS STEM PARM.\"\nSRC = RC\n\"FREE FILE(NWDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** EXECIO READ ERROR: ('TEXTLIB'('CONFIG'). ***'\n   SAY '*** NWBACKUP EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nDO I = 1 TO PARM.0\n   CHG = POS('VOLUMES',PARM.I)\n   IF CHG \u00ac= 0 THEN DO\n      PARM.I = \"         VOLUMES      '\"PARMLIB\"(\"VOLMEMB\")'\"\n   END\n   QUEUE PARM.I\nEND\nRETURN\n\n/*     */\nBUILD_RESTART_JOB:\n\"DELSTACK\"\nJ = 22\nSRVCONFG = SERVER||'CONFG'\nSMEMB = WORD(SERVER.LAN,2)\nJN = SMEMB||JS\nOUTMEMB = JN\nWTR = SUBSTR(JN,2)\nWTRNAME = WTR'00'\nOUTPDS = TSOID||'.DIALOG.ISPFILE'\nSCHPRT = 'PTECH2.NETCA.'SERVER'.SCHPRINT'\nSYSPRT = 'PTECH2.NETCA.'SERVER'.SYSPRINT'\nJCL.1 = \"//\"JN\"  JOB O030OVRHD0000000,'\"SERVER\" LAN BACKUP',NOTIFY=TECH251,\"\nJCL.2 = \"//             CLASS=F,MSGCLASS=Q,MSGLEVEL=(1,1),REGION=6M\"\nJCL.3 = \"//STEP010  EXEC PGM=IKJEFT01,DYNAMNBR=30,\"\nJCL.4 = \"//         PARM='%NWALLOC \"SERVER\" \"BUPARM\"'\"\nJCL.5 = \"//SYSTSPRT DD SYSOUT=*\"\nJCL.6 = \"//SYSPRINT DD SYSOUT=*\"\nJCL.7 = \"//SYSIN DD DUMMY\"\nJCL.8 = \"//SYSLBC DD DSN=SYS1.BRODCAST,DISP=SHR\"\nJCL.9 = \"//SYSUADS DD DSN=SYS1.UADS,DISP=SHR\"\nJCL.10 = \"//SYSPROC DD DSN=SYSS.TECH.COMMON.EXECLIB,DISP=SHR\"\nJCL.11 = \"//SYSTSIN DD DUMMY\"\nJCL.12 = \"/*\"\nJCL.13 = \"//ABEND010 EXEC PGM=ABENDWTO,COND=(0,GE,STEP010)\"\nJCL.14 = \"//* *** STEPLIB DD DSN=SYS1.PROD.BATCH.LOADLIB,DISP=SHR\"\nJCL.15 = \"/*\"\nJCL.16 = \"//STEP020 EXEC PGM=NUACLIEN\"\nJCL.17 = \"//SCHPRINT DD DSN=\"SCHPRT\",DISP=(MOD,CATLG,DELETE),\"\nJCL.18 = \"// SPACE=(CYL,(2,0,0)),DCB=(RECFM=FBA,LRECL=133,BLKSIZE=133),\"\nJCL.19 = \"// DATACLAS=LISTING\"\nJCL.20 = \"//SYSPRINT DD DSN=\"SYSPRT\",DISP=(MOD,CATLG,DELETE),\"\nJCL.21 = \"// SPACE=(CYL,(2,0,0)),DCB=(RECFM=FBA,LRECL=133,BLKSIZE=133),\"\nJCL.22 = \"// DATACLAS=LISTING\"\nIF VOLSW = 'RSTPARM' THEN DO\n   DO I = 1 TO VOLR.0\n      JVOL = WORD(VOLR.I,1)\n      DDVOL = 'DDC'||JVOL\n      DDINDX = 'DDI'||JVOL\n      BT = BUTYPE\n      IF I = 1 THEN DO\n         TUNIT = 'UNIT=(SILO,,DEFER)'\n         SAVEDD = DDVOL\n      END\n      IF I > 1 THEN TUNIT = 'UNIT=AFF='SAVEDD\n      REC.1 = \"//\"DDVOL\"  DD DSN=PTAP.NETCA.\"SERVER\".\"JVOL\".\"BT\".CONTAINR(+1),\"\n      REC.2 = \"//         DISP=(NEW,CATLG,DELETE),\"TUNIT\",\"\n      REC.3 = \"//         VOLUME=(,,,99),LABEL=(1,SL),\"\n      REC.4 = \"//   DCB=(MODEL.DSCB,RECFM=U,LRECL=0,BLKSIZE=32760,DSORG=PS)\"\n      REC.5 = \"//\"DDINDX\" DD DSN=PTECH2.NETCA.\"SERVER\".\"JVOL\".\"BT\".INDEX(+1),\"\n      REC.6 = \"//            DISP=(NEW,CATLG,DELETE),\"\n      REC.7 = \"//  DCB=(BLKSIZE=27998,LRECL=27994,RECFM=VB,DSORG=PS),\"\n      REC.8 = \"//  DATACLAS=DATAPS,MGMTCLAS=STANDARD,STORCLAS=SCSTNRDG,\"\n      REC.9 = \"//  SPACE=(27998,(50,10),RLSE)\"\n      DO E = 1 TO 9\n         J = J + 1\n         JCL.J = REC.E\n      END\n   END\nEND\nIF VOLSW = 'PANEL' THEN DO\n   DO I = 1 TO VOLP.0\n      JVOL = WORD(VOLP.I,1)\n      DDVOL = 'DDC'||JVOL\n      DDINDX = 'DDI'||JVOL\n      BT = BUTYPE\n      IF I = 1 THEN DO\n         TUNIT = 'UNIT=(SILO,,DEFER)'\n         SAVEDD = DDVOL\n      END\n      IF I > 1 THEN TUNIT = 'UNIT=AFF='SAVEDD\n      REC.1 = \"//\"DDVOL\"  DD DSN=PTAP.NETCA.\"SERVER\".\"JVOL\".\"BT\".CONTAINR(+1),\"\n      REC.2 = \"//         DISP=(NEW,CATLG,DELETE),\"TUNIT\",\"\n      REC.3 = \"//         VOLUME=(,,,99),LABEL=(1,SL),\"\n      REC.4 = \"//   DCB=(MODEL.DSCB,RECFM=U,LRECL=0,BLKSIZE=32760,DSORG=PS)\"\n      REC.5 = \"//\"DDINDX\" DD DSN=PTECH2.NETCA.\"SERVER\".\"JVOL\".\"BT\".INDEX(+1),\"\n      REC.6 = \"//            DISP=(NEW,CATLG,DELETE),\"\n      REC.7 = \"//  DCB=(BLKSIZE=27998,LRECL=27994,RECFM=VB,DSORG=PS),\"\n      REC.8 = \"//  DATACLAS=DATAPS,MGMTCLAS=STANDARD,STORCLAS=SCSTNRDG,\"\n      REC.9 = \"//  SPACE=(27998,(50,10),RLSE)\"\n      DO E = 1 TO 9\n         J = J + 1\n         JCL.J = REC.E\n      END\n   END\nEND\nJCLCNT = J\nDO J = 1 TO JCLCNT\n   QUEUE JCL.J\nEND\nR = 0\nRCDCNT = 35\nRCD.1 = \"//NUACACON DD DSN=\"PARMLIB\"(\"SRVCONFG\"),DISP=SHR\"\nRCD.2 = \"//NUACATXT DD DSN=\"CTEXTLIB\",DISP=SHR\"\nRCD.3 = \"//PARAMS DD *\"\nRCD.4 = \"-HOST \"SERVER\" -OUTPUT 'PTECH2.NETCA.\"SERVER\".SCRIPT'\"\nRCD.5 = \"    DD:NUACACON -CHECK\"\nRCD.6 = \"//SYSIN DD *\"\nRCD.7 = \"SET INPUT VERIFY ON\"\nRCD.8 = \"INPUT DD:NUACATXT(BASIC) 'PTECH2.NETCA.\"SERVER\".SCRIPT'\"\nRCD.9 = \"/*\"\nRCD.10 = \"//STEP030 EXEC PGM=IKJEFT01,DYNAMNBR=30,\"\nRCD.11 = \"// PARM='%NWABEND \"SERVER\" \"BUTYPE\" RESTART',\"\nRCD.12 = \"// COND=(4,GE,STEP020)\"\nRCD.13 = \"//SYSTSPRT DD SYSOUT=*\"\nRCD.14 = \"//SYSPRINT DD SYSOUT=*\"\nRCD.15 = \"//SYSIN DD DUMMY\"\nRCD.16 = \"//SYSLBC DD DSN=SYS1.BRODCAST,DISP=SHR\"\nRCD.17 = \"//SYSUADS DD DSN=SYS1.UADS,DISP=SHR\"\nRCD.18 = \"//SYSPROC DD DSN=SYSS.TECH.COMMON.EXECLIB,DISP=SHR\"\nRCD.19 = \"//SYSTSIN DD DUMMY\"\nRCD.20 = \"/*\"\nRCD.21 = \"//STEP040  EXEC CATRPTS,COND=((4,GE,STEP020),(1,NE,STEP030))\"\nRCD.22 = \"//SYSIN    DD DSN=\"PARMLIB\"(\"TLMSMEMB\"),DISP=SHR\"\nRCD.23 = \"/*\"\nRCD.24 = \"//ABEND050 EXEC WTO,COND=(4,GE,STEP020)\"\nRCD.25 = \"//SYSIN DD DSN=\"MSGLIB\"(\"SERVER\"),DISP=SHR\"\nRCD.26 = \"/*\"\nRCD.27 = \"//STEP060 EXEC PGM=IEBGENER\"\nRCD.28 = \"//SYSUT1 DD DSN=\"SYSPRT\",DISP=SHR\"\nRCD.29 = \"//SYSUT2 DD SYSOUT=(V,\"WTRNAME\"),DCB=BLKSIZE=133\"\nRCD.30 = \"//SYSPRINT DD DUMMY\"\nRCD.31 = \"//SYSIN DD DUMMY\"\nRCD.32 =  \"/*\"\nRCD.33 = \"//*          ABEND STEP FOR RETURN CODE GE 4\"\nRCD.34 = \"//ABEND070 EXEC PGM=ABENDWTO,COND=(4,GE,STEP020)\"\nRCD.35 = \"//\"\nDO RCDCNT\n   R = R + 1\n   QUEUE RCD.R\nEND\nRETURN\n\n/*     */\nREAD_SERVER_VOLUMES_PARMS:\nVOLPARMS = SERVER||'FVOLS'\n\"ALLOC DA('\"TEXTLIB\"(\"VOLPARMS\")') FILE(NWDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('TEXTLIB'('VOLPARMS'). ***'\n   SAY '*** NWBACKUP EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\n\"EXECIO * DISKR NWDD (FINIS STEM VOLB.\"\nSRC = RC\n\"FREE FILE(NWDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** EXECIO READ ERROR: ('TEXTLIB'('VOLPARMS'). ***'\n   SAY '*** NWBACKUP EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nV = 0\nVOL1 = '*****'\nVOL2 = '*****'\nVOL3 = '*****'\nVOL4 = '*****'\nVOL5 = '*****'\nVOL6 = '*****'\nVOL7 = '*****'\nVOL8 = '*****'\nDO I = 1 TO VOLB.0\n   UPPER VOLB.I\n   SVOL = POS(BUPARM,VOLB.I)\n   IF SVOL = 0 THEN ITERATE\n   V = V + 1\n   SERVOL = WORD(VOLB.I,1)\n   IF V = 1 THEN VOL1 = LEFT(SERVOL,5,'*')\n   IF V = 2 THEN VOL2 = LEFT(SERVOL,5,'*')\n   IF V = 3 THEN VOL3 = LEFT(SERVOL,5,'*')\n   IF V = 4 THEN VOL4 = LEFT(SERVOL,5,'*')\n   IF V = 5 THEN VOL5 = LEFT(SERVOL,5,'*')\n   IF V = 6 THEN VOL6 = LEFT(SERVOL,5,'*')\n   IF V = 7 THEN VOL7 = LEFT(SERVOL,5,'*')\n   IF V = 8 THEN VOL8 = LEFT(SERVOL,5,'*')\nEND\nRETURN\n\n/*     */\nDISPLAY_VOLUME_PANEL:\nADDRESS ISPEXEC \"DISPLAY PANEL(NWVOLPNL)\"\nSRC = RC\nIF SRC = 8 THEN EXIT 0\nIF SRC > 8 THEN DO\n   SAY '*** ERROR INVOKING ISPF DIALOG PANEL ( NWVOLPNL ). ***'\n   SAY '*** NWBACKUP EXEC TASK CANCELLED - RC = 'SRC'. ***'\n   EXIT SRC\nEND\nRETURN\n\n/*     */\nBUILD_PANEL_RESTART_VOLUME_MEMBER:\nADDRESS TSO\n\"DELSTACK\"\nVOLSW = 'PANEL'\nOUTMEMB = SERVER||'VOLS'\nOUTPDS = PARMLIB\nVOLPARMS = SERVER||'FVOLS'\n\"ALLOC DA('\"TEXTLIB\"(\"VOLPARMS\")') FILE(NWDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('TEXTLIB'('VOLPARMS'). ***'\n   SAY '*** NWBACKUP EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\n\"EXECIO * DISKR NWDD (FINIS STEM VOLP.\"\nSRC = RC\n\"FREE FILE(NWDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** EXECIO READ ERROR: ('TEXTLIB'('VOLPARMS'). ***'\n   SAY '*** NWBACKUP EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nDO I = 1 TO 8\n   SELVOL = VALUE('VBU'I)\n   IF SELVOL = '' THEN ITERATE\n   BUVOL = VALUE('VOL'I)\n   IF BUVOL = '' THEN ITERATE\n   SVR = POS('*',BUVOL)\n   SVRVOL = BUVOL\n   IF SVR \u00ac= 0 THEN DO\n      SVR = SVR - 1\n      SVRVOL = SUBSTR(BUVOL,1,SVR)\n   END\n   DO V = 1 TO VOLP.0\n      UPPER VOLP.V\n      SVOL = POS(BUPARM,VOLP.V)\n      IF SVOL = 0 THEN ITERATE\n      PVOL = WORD(VOLP.V,1)\n      IF PVOL = SVRVOL THEN QUEUE VOLP.V\n   END\nEND\nRCNT = QUEUED()\nRETURN\n\n/*     */\nGET_PANEL_VOLUMES:\nVOLMEMB = SERVER||'VOLS'\n\"ALLOC DA('\"PARMLIB\"(\"VOLMEMB\")') FILE(NWDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('PARMLIB'('VOLMEMB'). ***'\n   SAY '*** NWBACKUP EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\n\"EXECIO * DISKR NWDD (FINIS STEM VOLP.\"\nSRC = RC\n\"FREE FILE(NWDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** EXECIO READ ERROR: ('PARMLIB'('VOLMEMB'). ***'\n   SAY '*** NWBACKUP EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nRETURN\n\n/*     */\nALLOC_ISPFILE_PDS:\nADDRESS TSO\nUCNTL = SYSDSN(DIALOG.ISPFILE)\nIF UCNTL = 'DATASET NOT FOUND' THEN DO\n\"ALLOC DA(DIALOG.ISPFILE) LIKE(USER.CNTLLIB) NEW SPACE(1,0) DIR(5) CYLINDERS\"\n   SRC = RC\n   IF SRC \u00ac= 0 THEN DO\n   SAY '*** ALLOCATE ERROR: ERROR ALLOCATING DATASET (DIALOG.ISPFILE). ***'\n   SAY '*** NWBACKUP EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\n   END\nEND\nRETURN\n\n/*     */\nWRITE_PDS_MEMBER:\n\"ALLOC DA('\"OUTPDS\"(\"OUTMEMB\")') FILE(NWDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ('OUTPDS'('OUTMEMB'). ***'\n   SAY '*** NWBACKUP EXEC SUBTASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nNUMRCDS = QUEUED()\n\"EXECIO\" NUMRCDS \"DISKW NWDD (FINIS\"\nSRC = RC\n\"FREE FILE(NWDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** WRITE ERROR: ERROR WRITING 'OUTPDS'('OUTMEMB'). ***'\n   SAY '*** NWBACKUP EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nRETURN\n\n/*     */\nSUBMIT_RESTART_JOB:\nADDRESS TSO\n\"SUBMIT '\"SUBPDS\"(\"SUBMEMB\")'\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** SUBMIT ERROR: MEMBER ( 'SUBPDS'('SUBMEMB'). ***'\n   SAY '*** NWBACKUP EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'\n   EXIT SRC\nEND\nIF NWDSN = 'OK' THEN DO\n   \"ALLOC DA('\"NWPDS\"(\"RSPARM\")') FILE(NWDD) SHR\"\n   \"DELETE ('\"NWPDS\"(\"RSPARM\")') FILE(NWDD)\"\n   \"FREE FILE(NWDD)\"\nEND\nRETURN\n\n/*     */\nDELETE_ISPFILE_PDS:\nADDRESS TSO\n\"DELETE  (DIALOG.ISPFILE)   NONVSAM SCRATCH PURGE\"\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SPACECMP": {"ttr": 20488, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x0b\\x00\\x00\\x00\\x93\\x01?\\x00\\x93\\x01O\\tB\\x00'\\x006\\x00\\n\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf6@@@\"", "ispf": {"version": "01.11", "flags": 0, "createdate": "1993-01-13T00:00:00", "modifydate": "1993-01-14T09:42:00", "lines": 39, "newlines": 54, "modlines": 10, "user": "TECH106"}, "text": "/* REXX DASD SPACE COMPUTE EXEC */\nTRACE O\nRETRY:\nSAY 'ENTER BLOCK SIZE, REC SIZE, NUMBER OF RECORDS, FREE SPACE'\nPULL BLOCK_SIZE RECORD_SIZE NUM_RECORDS FREE_SPACE\nBLK_DATATYP = DATATYPE(BLOCK_SIZE)\nREC_DATATYP = DATATYPE(NUM_RECORDS)\nNUMREC_DATATYP = DATATYPE(NUM_RECORDS)\nFREESP_DATATYP = DATATYPE(FREE_SPACE)\nTYPES = BLK_DATATYP || REC_DATATYP || NUMREC_DATATYP || FREESP_DATATYP\nIF TYPES \\= 'NUMNUMNUMNUM' THEN\n  DO\n    SAY 'ERROR IN INPUT FIELD(S) - RETRY'\n    SIGNAL RETRY\n  END\nFREE_SPACE_BYTES = BLOCK_SIZE * (FREE_SPACE / 100)\nEFFECT_BLOCK_SIZE = BLOCK_SIZE - FREE_SPACE_BYTES\nRECS_PER_BLOCK = EFFECT_BLOCK_SIZE / RECORD_SIZE\nRECS_PER_BLOCK = RECS_PER_BLOCK % 1\nC = 10\nK = 0\nDN =  ( BLOCK_SIZE + 6 ) / 232\nDN = DN +.99; DN = DN % 1  /* ROUNDING UP  */\nD =  BLOCK_SIZE + (6 * DN) + 6;\nD = D / 34 + 9\nD = D + .99; D = D % 1   /*   ROUNDING UP  */\nSPACE = C + D + K\nBLOCKS_PER_TRACK = 1729 / SPACE\nBLOCKS_PER_TRACK = BLOCKS_PER_TRACK % 1\nBLK = NUM_RECORDS / RECS_PER_BLOCK; BLK = BLK % 1\nRECORDS_PER_TRACK = RECS_PER_BLOCK * BLOCKS_PER_TRACK\nTRACKS_NEEDED = NUM_RECORDS / RECORDS_PER_TRACK\nTRACKS_NEEDED = (TRACKS_NEEDED + .99) % 1\nCYLS_NEEDED = TRACKS_NEEDED / 15\nCYLS_NEEDED = (CYLS_NEEDED +.99) % 1\nPCNT_USED = (BLOCKS_PER_TRACK * EFFECT_BLOCK_SIZE) / 56664\nSAY 'FOR 3390: CYLS=' CYLS_NEEDED', TRKS=' TRACKS_NEEDED', BLKS=' BLK,\n' TRACK UTIL.=' PCNT_USED\nEXIT 0;\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SPACEREQ": {"ttr": 20490, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\n\\x00\\x00\\x00\\x94\\x10_\\x00\\x94\\x10_\\x15\\x01\\x00+\\x00\\x15\\x00'\\xe3\\xc5\\xc3\\xc8\\xf1\\xf1\\xf0@@@\"", "ispf": {"version": "01.10", "flags": 0, "createdate": "1994-04-15T00:00:00", "modifydate": "1994-04-15T15:01:00", "lines": 43, "newlines": 21, "modlines": 39, "user": "TECH110"}, "text": "/* REXX SMS Space by record calc - unsophisticated version */\ntrack_bytes=56664;\nhalf_track_bytes=27920; /* approximate */\ncyl_bytes=849960;\ntrack_cyl=15;\nkilo=1024;\nmeg=kilo*kilo;\n\"VMFCLEAR\";\nsay ,\n  \"Enter the AVGREC value coded ('M', 'K', or 'U')\";\npull avgrec;\nsay ,\n  \"Enter the SPACE units average record len value coded\";\npull reclen;\nsay ,\n  \"Enter the SPACE primary count value coded\";\npull primquan;\nsay ,\n  \"Enter the SPACE secondary count value coded\";\npull secquan;\nselect;\n   when (avgrec=\"M\") then mult=meg;\n   when (avgrec=\"K\") then mult=kilo;\n   when (avgrec=\"U\") then mult=1;\n   otherwise nop;\nend;\nprim_mult=primquan*reclen;\nsec_mult=secquan*reclen;\nprim_space_in_bytes=prim_mult*mult;\nsec_space_in_bytes=sec_mult*mult;\nprim_blks=prim_space_in_bytes/half_track_bytes;\nsec_blks=sec_space_in_bytes/half_track_bytes;\nprim_tracks=prim_blks/2; /* half track blocking */\nsec_tracks=sec_blks/2; /* half track blocking */\nprim_cyls=format(prim_tracks/track_cyl,6,0);\nsec_cyls=format(sec_tracks/track_cyl,6,0);\n\"VMFCLEAR\";\nsay \"This space request is for:\";\nsay \"       Primary byte count of:\" prim_space_in_bytes;\nsay \"          or about\" prim_cyls \"cylinders\";\nsay \"       Secondary byte count of:\" sec_space_in_bytes;\nsay \"          or about\" sec_cyls \"cylinders\";\nexit 0;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "STKVOL": {"ttr": 20492, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x07\\x00\\x00\\x00\\x93\\x14\\x8f\\x00\\x94\\x14_\\x12Y\\x006\\x00.\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf3@@@'", "ispf": {"version": "01.07", "flags": 0, "createdate": "1993-05-28T00:00:00", "modifydate": "1994-05-25T12:59:00", "lines": 54, "newlines": 46, "modlines": 0, "user": "TECH103"}, "text": "/*  REXX EXEC : ( STKVOL ).\n    FUNCTION: READS THE SORTED VOLUME REPORT LISTING DATASET SORTED BY\n              VOLUME AND CHECKS FOR DUPLICATE TAPE VOLSERS.\n    INPUT   : DSN = ( SYSS.STKHSC.VOLREPRT.LISTING ).\n    OUTPUT  : TERMINAL DISPLAY OF ANY DUPLICATE VOLSERS.\n                                                                      */\nTRACE O\n/*     */\nHOUSE_KEEPING:\nADDRESS TSO\nPARSE UPPER ARG REPORT .\nIF REPORT = '' THEN REPORT = 'SYSS.STKHSC.VOLREPRT.LISTING'\nX = MSG(\"OFF\")\n\"FREE FILE(STKDD)\"\nDUPCNT = 0\nSVOLUME = 'XXXXXX'\nCALL READ_VOLUME_REPORT\n\n/*     */\nMAIN_ROUTINE:\nDO I = 1 TO DATA.0\n   VOLKEY = WORD(DATA.I,3)\n   IF VOLKEY \u00ac= 'Y' THEN ITERATE\n   RVOLUME = SUBSTR(DATA.I,3,6)\n   IF RVOLUME = SVOLUME THEN DO                                         '\n      DUPCNT = DUPCNT + 1                                               '\n      SAY '*** DUPLICATE TAPE VOLUME FOUND: ('RVOLUME'). ***'           '\n   END                                                                  '\n   SVOLUME = RVOLUME\nEND\nSAY '+++ DUPLICATE TAPE VOLUME COUNT: ('DUPCNT'). +++'\nEXIT 0\n\n/*     S U B R O U T I N E S   S E C T I O N     */\n/*     */\nREAD_VOLUME_REPORT:\n\"ALLOC DA('\"REPORT\"') FILE(STKDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET ALLOCATE ERROR: ( 'REPORT' ). ***'\n   SAY '*** DATASET IN USE OR UNAVAILABLE - RETURN CODE: (' SRC '). ***'\n   SAY '*** STKVOL EXEC SUBTASK CANCELLED. ***'\n   EXIT SRC\nEND\n\"EXECIO * DISKR STKDD (FINIS STEM DATA.\"\nSRC = RC\n\"FREE FILE(STKDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** DATASET EXECIO ERROR: ( 'REPORT' ). ***'\n   SAY '*** EXECIO DATASET READ RETURN CODE: (' SRC '). ***'\n   SAY '*** STKVOL EXEC SUBTASK CANCELLED. ***'\n   EXIT SRC\nEND\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "STRLBDEF": {"ttr": 20494, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x16O\\x00\\x94\\x16O\\x15\\x00\\x00\\x1c\\x00\\x1c\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf5@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-06-13T00:00:00", "modifydate": "1994-06-13T15:00:00", "lines": 28, "newlines": 28, "modlines": 0, "user": "TECH105"}, "text": "PROC 0\n/********************************************************************/\n/*     CHANGE THE NAMES FOR THE STROBE.ISPF LIBRARIES:               */\n/*           STROBE.ISPPLIB       PANEL LIBRARY                      */\n/*           STROBE.ISPMLIB       MESSAGE LIBRARY                    */\n/*           STROBE.ISPSLIB       SKELETON JCL LIBRARY               */\n/*     IF YOU ARE TESTING A NEW VERSION OF STROBE AND PLAN TO        */\n/*           RENAME LINK LIST MEMBERS, CHANGE PGM(STRBISPF)          */\n/*********************************************************************/\nCONTROL  MSG NOFLUSH NOPROMPT\n/***************************************************\n/*DEFINE STROBE/ISPF LIBRARIES WITH SPECIFIED DDNAME\n/***************************************************\nISPEXEC  LIBDEF ISPPLIB  DATASET  ID('SYSS.STROBE.V1R9M2.ISPPLIB')\nISPEXEC  LIBDEF ISPMLIB  DATASET  ID('SYSS.STROBE.V1R9M2.ISPMLIB')\nISPEXEC  LIBDEF ISPSLIB  DATASET  ID('SYSS.STROBE.V1R9M2.ISPSLIB')\n/*\n/****************************\n/*EXECUTE STROBE/ISPF PROGRAM\n/****************************\nISPEXEC  SELECT PGM(STRBISPF) NEWAPPL(STR) PASSLIB\n/*\n/*****************************\n/*REMOVE STROBE/ISPF LIBRARIES\n/****************************\nISPEXEC  LIBDEF ISPPLIB  DATASET\nISPEXEC  LIBDEF ISPMLIB  DATASET\nISPEXEC  LIBDEF ISPSLIB  DATASET\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "SYSUP": {"ttr": 20737, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x012\\x00\\x00\\x00\\x910\\x8f\\x00\\x92'\\x9f\\x16\\t\\x00f\\x00\\x0c\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf1\\xf0@@@\"", "ispf": {"version": "01.50", "flags": 0, "createdate": "1991-11-04T00:00:00", "modifydate": "1992-10-05T16:09:00", "lines": 102, "newlines": 12, "modlines": 0, "user": "TECH110"}, "text": "/* REXX automatic System dataset update command */\ntrue=1;\nfalse=0;\nparse source \"TSO\". execname . ;\nselect;\n  when (execname=\"SYSUP\") then func=\"UPDATE\";\n  when (execname=\"SYSUPADD\") then func=\"ADD\";\n  when (execname=\"SYSUPDEL\") then func=\"DELETE\";\n  otherwise nop;\nend;\nparse upper arg dsname . ;\nif dsname=\"\" then do;\n     say \"Invalid dsname argument passed\";\n     exit 12;\n     end;\nquote = substr(dsname,1,1);\nif quote=\"'\" | quote='\"'  then , /* strip enclose quotes */\n     dsname=substr(dsname,2,length(dsname)-2);\nlla=false;\nvlf=false;\nif pos(\"(\",dsname)\u00ac=0 then do;\n      vlf=true;\n      parse var dsname dsname \"(\" member \")\" . ;\n      parmmem = \"COFVLFSS\";\n      end;\n  else do;\n      lla=true;\n      parmmem = \"CSVLLASS\";\n      end;\n\"ALLOC F(INPUT) DA('SYS1.PARMLIB(\"parmmem\")') SHR\";\n\"EXECIO * DISKR INPUT (FINIS STEM SYSDATA.\";\n\"FREE F(INPUT)\";\nparmlib_suffix = \"\";\nvlffound=false;\nif lla then ,\ndo i = 1 to sysdata.0;\n    parse var sysdata.i \"/*\" \"SUFFIX(\" parmsufx \")\" sufdsn \"*/\";\n    parmsufx=strip(parmsufx); sufdsn=strip(sufdsn);\n    if sufdsn=dsname then do;\n          parmlib_suffix=parmsufx;\n          leave i;\n          end;\nend;\nif vlf then ,\ndo i = 1 to sysdata.0;\n    parse var sysdata.i . \"EDSN(\" vlfdsn \")\" . ;\n    vlfdsn=strip(vlfdsn);\n    if vlfdsn=dsname then do;\n          vlffound=true;\n          leave i;\n          end;\nend;\nif vlf & \u00acvlffound then do;\n     say \"Invalid dsname argument passed\";\n     exit 12;\n     end;\ncvtptr = storage(\"00000010\",4); /* locate llt/smca from cvt */\ncvtsmca = storage(d2x(c2d(cvtptr)+196),4); /* mapping smca */\nsavehi=substr(c2x(cvtsmca),1,2); /* hi order bit is on */\nsmcasid = savehi||d2x(x2d(substr(c2x(cvtsmca),3))+16);\nsmcasid = storage(smcasid,4); /* SMF id */\nif lla then do; /* start of lla only code */\nif parmlib_suffix=\"\" then do;\ncvtllta = d2x(c2d(cvtptr)+1244); /* mapping ihallt */\nllta = c2d(storage(cvtllta,4));\nlltacount = c2d(storage(d2x(llta+4),4));\nlltaentry = d2x(llta+9); /* entry ptr */\ndo i = 1 to lltacount;\n     lnkdsn= strip(storage(lltaentry,44));\n     if dsname=lnkdsn then do;\n         parmlib_suffix=\"00\";\n         leave i; end;\n     lltaentry = d2x(x2d(lltaentry)+45);\nend;\nif parmlib_suffix=\"\" then do;\n     say \"Invalid dsname argument passed\";\n     exit 12;\n     end;\n     end;\nif parmlib_suffix = \"00\" then ,\n   say \"LinkList dataset is being LLA-refreshed\";\n   else ,\n   say \"Non-LinkList dataset is being LLA-refreshed\";\n   say \"Please LLAUP refresh on ALL other running systems\";\ncommand = \"F LLA,UPDATE=\"parmlib_suffix;\n\"CONSOLE ACTIVATE\"; /* make extended console */\n\"CONSOLE SYSCMD(\"command\")\";\nend; /* end off lla only */\nif vlf then do;\n     \"CONSOLE ACTIVATE\"; /* extended console */\n    command=\"S VLFUP,,,VLFPARM=(VLFDSN=\"dsname\",VLFMEM=\"member\",\" || ,\n                 \"VLFFUNC=\"func\")\";\n     end;\nselect;\n  when (smcasid=\"SYSA\") then sysid=\"2\"; /* sysid of other side */\n  when (smcasid=\"SYSB\") then sysid=\"1\";\n  otherwise sysid = \"\";\nend;\ncommand = \"$M\"sysid\",'\"command\"'\";\nif sysid\u00ac=\"\" then \"CONSOLE SYSCMD(\"command\")\";\n\"CONSOLE DEACTIVATE\"; /* terminate extended console */\nexit 0;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "SYSUTIL": {"ttr": 20740, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x05\\x00\\x00\\x00\\x921\\x7f\\x00\\x93\\x11o\\t4\\x00C\\x00=\\x00$\\xe3\\xc5\\xc3\\xc8\\xf1\\xf1\\xf0@@@'", "ispf": {"version": "01.05", "flags": 0, "createdate": "1992-11-12T00:00:00", "modifydate": "1993-04-26T09:34:00", "lines": 67, "newlines": 61, "modlines": 36, "user": "TECH110"}, "text": "/* REXX SYSUTIL SYSTEM UTILIZATION */\nCALL DSQCIX \"START (DSQSMODE=INTERACTIVE DSQSSUBS=DSNA\";\nrid=\"\"; /* report id */\ndo while (rid<>\"X\");\n\"VMFCLEAR\";\nSAY \"Please enter the number of the specific report or 'X' to exit\";\nsay \"\";\nsay \"1) System processor utilization by month\";\nsay \"2) System processor utilization by month day shift\";\nsay \"3) System processor utilization by month eve shift\";\nsay \"4) System processor utilization by month SYSA day shift\";\nsay \"5) System processor utilization by month SYSA eve shift\";\nsay \"6) System processor utilization by month SYSB day shift\";\nsay \"7) System processor utilization by month SYSB eve shift\";\nsay \"8) System processor utilization by day\";\nsay \"9) System processor utilization by day SYSA day shift\";\nsay \"10) System processor utilization by day SYSA eve shift\";\nsay \"11) System processor utilization by day SYSB day shift\";\nsay \"12) System processor utilization by day SYSB eve shift\";\nsay \"13) System utilization by Job account code\";\nsay \"14) Job service utilization by RACF group and user\";\nsay \"15) Job count and utilization summary by jobclass\";\nsay \"16) System utilization percentage by transaction group\";\nsay \"17) Output lines summary by RACF userid\";\nparse upper pull rid;\nif (rid=\"\" | rid=\"X\") then iterate;\n\"VMFCLEAR\";\nselect;\n  when rid=\"1\" then ,\n      CALL DSQCIX \"RUN QUERY QCPUM1 (FORM FCPUM1\";\n  when rid=\"2\" then ,\n      CALL DSQCIX \"RUN QUERY QCPUM2 (FORM FCPUM2\";\n  when rid=\"3\" then ,\n      CALL DSQCIX \"RUN QUERY QCPUM3 (FORM FCPUM3\";\n  when rid=\"4\" then ,\n      CALL DSQCIX \"RUN QUERY QCPUAM1 (FORM FCPUAM1\";\n  when rid=\"5\" then ,\n      CALL DSQCIX \"RUN QUERY QCPUAM2 (FORM FCPUAM2\";\n  when rid=\"6\" then ,\n      CALL DSQCIX \"RUN QUERY QCPUBM1 (FORM FCPUBM1\";\n  when rid=\"7\" then ,\n      CALL DSQCIX \"RUN QUERY QCPUBM2 (FORM FCPUBM2\";\n  when rid=\"8\" then ,\n      CALL DSQCIX \"RUN QUERY QCPUSS1 (FORM FCPUSS1\";\n  when rid=\"9\" then ,\n      CALL DSQCIX \"RUN QUERY QCPUAS1 (FORM FCPUAS1\";\n  when rid=\"10\" then ,\n      CALL DSQCIX \"RUN QUERY QCPUAS2 (FORM FCPUAS2\";\n  when rid=\"11\" then ,\n      CALL DSQCIX \"RUN QUERY QCPUBS1 (FORM FCPUBS1\";\n  when rid=\"12\" then ,\n      CALL DSQCIX \"RUN QUERY QCPUBS2 (FORM FCPUBS2\";\n  when rid=\"13\" then ,\n      CALL DSQCIX \"RUN QUERY QJOB2 (FORM FJOB2\";\n  when rid=\"14\" then ,\n      CALL DSQCIX \"RUN QUERY QJOB1 (FORM FJOB1\";\n  when rid=\"15\" then ,\n      CALL DSQCIX \"RUN QUERY QWRK1 (FORM FWRK1\";\n  when rid=\"16\" then ,\n      CALL DSQCIX \"RUN QUERY QWRK2 (FORM FWRK2\";\n  when rid=\"17\" then ,\n      CALL DSQCIX \"RUN QUERY QWTR1 (FORM FWTR1\";\n  otherwise nop;\nend;\nend;\nCALL DSQCIX \"EXIT\";\nEXIT 0;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TESTF": {"ttr": 20742, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x944\\x8f\\x00\\x944\\x8f\\t7\\x00\\x13\\x00\\x13\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf7@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-12-14T00:00:00", "modifydate": "1994-12-14T09:37:00", "lines": 19, "newlines": 19, "modlines": 0, "user": "TECH107"}, "text": "PROC 0\nCONTROL NOMSG NOPROMPT NOLIST\nFREE F(USERLIB ERRORS MASTER FOCEXEC FMU SYSIN FOCLIB FOCSQL PROFILE)\nFREE F(OFFLINE)\nALLOC F(FOCLIB)  DA('SYSS.FOCUS.V6R8M0.FOCSQL.LOAD') SHR\nALLOC F(FOCSQL)  DA('SYSS.TECH.COMMON.FOCSQL.DATA' -\n                    'SYSS.FOCUS.V6R8M0.FOCSQL.DATA') SHR\nALLOC F(ERRORS)  DA('SYSS.FOCUS.V6R8M0.ERRORS.DATA') SHR\nALLOC F(MASTER)  DA('SYSS.TECH.COMMON.MASTER.DATA' -\n                    'SYSS.FOCUS.V6R8M0.MASTER.DATA') SHR\nALLOC F(FOCEXEC) DA('SYSS.TECH.COMMON.FOCEXEC.DATA') SHR\nALLOC F(PROFILE) DA('SYSS.TECH.COMMON.XREF.PROFILE') SHR\nALLOC F(FMU)     DA('SYSS.TECH.COMMON.FMU.DATA') SHR\nALLOC F(OFFLINE) SYSOUT(G) RECFM(F,B,A) LRECL(161) BLKSIZE(1610) -\n      FCB(GT15)\nCALL 'SYS1.FOCUS.V6R8M0.LOAD(FOCUS)'\nFREE F(USERLIB ERRORS MASTER FOCEXEC FMU SYSIN FOCLIB FOCSQL PROFILE)\nFREE F(OFFLINE)\nEXIT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TLL": {"ttr": 20744, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x016\\x00\\x00\\x00\\x94\\x01\\x0f\\x00\\x94)O\\x15I\\x01\"\\x00G\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf3@@@'", "ispf": {"version": "01.54", "flags": 0, "createdate": "1994-01-10T00:00:00", "modifydate": "1994-10-21T15:49:00", "lines": 290, "newlines": 71, "modlines": 0, "user": "TECH103"}, "text": "/*   REXX EXEC : ( TLMSVSNL )\n     FUNCTION  : TSO INTERACTIVE TAPE DATASET VOLSER LIST SERVICES\n                                                                      */\nTRACE O\n/*     */\nHOUSE_KEEPING:\nADDRESS TSO\nPARSE UPPER ARG TAPEDSN .\nIF TAPEDSN = '' THEN DO\n   SAY '*** INVALID OR MISSING TAPE DATASET NAME ON COMMAND LINE. ***'\n   SAY '+++ TAPE DATASET NAME CAN BE PASSED FROM DSL COMMAND LINE. +++'\n   SAY '*** TLMS TAPE DATASET VOLSER LIST FACILITY CANCELLED. ***'\n   EXIT 1\nEND\nTAPEDSN = STRIP(TAPEDSN,\"B\",\"'\")\nTAPEHDR = '*****  TAPE VOLSER LIST FOR: 'TAPEDSN'  *****'\nX = MSG(\"OFF\")\nDUNIT = 'APPLTA'\nTSOID = SYSVAR(SYSUID)\nTSOPRFX = SUBSTR(TSOID,1,4)\nIF TSOPRFX = 'TECH' THEN DUNIT = 'SMS'\nUSERLIB = TSOID'.USER.CNTLLIB'\nUSERDSN.1 = TSOID'.TLMS.SYSIN'\nUSERDSN.2 = TSOID'.TLMS.SYSOUT'\nTLMSDSN.1  = 'SYSS.TLMS.V5R3M0.VMF'\nTLMSDSN.2  = 'SYSS.TLMS.V5R3M0.VMF'\nTLMSDSN.3  = 'SYSS.TLMS.V5R3M0.VMF'\nTLMSDSN.4  = 'SYSS.TLMS.V5R3M0.RMF.CLUSTER'\nTLMSDSN.5 = 'SYSS.TLMS.V5R3M0.VMFINDEX.CLUSTER'\nTLMSDSN.6 = USERDSN.1\nTLMSDSN.7 = USERDSN.2\nTLMSFIDD = 'CAIVMF CAIVMFI CAIVMFS CAIRMF CAIVMFXI SYSIN SYSPRINT'\nATTRB.1 = 'ATTRB1 DSORG(PS) RECFM(F B) LRECL(80) BLKSIZE(80)'\nATTRB.2 = 'ATTRB2 DSORG(PS) RECFM(F B A) LRECL(133) BLKSIZE(133)'\nLOADLIB = 'SYS1.TLMS.V5R3M0.CAILIB.LOADLIB'\n/*\n       M A I N   R O U T I N E   S E C T I O N     */\n/*     */\nMAIN_ROUTINE:\nCALL LISTCAT_TAPE_DATASET\nIF LSTSW = 'YES' THEN DO\n   CALL WRITE_TAPE_DATASET_VOLSERS\n   CALL EDIT_TAPE_DATASET_VOLSERS\n   EXIT 0\nEND\nCALL FREE_DATASETS\nCALL ALLOC_USER_DATASETS\nCALL WRITE_TLMS_DISPLAY_NAME_SYSIN\nCALL ALLOC_TLMS_DATASETS\nCALL FETCH_TLMS_LOAD_MODULE\nCALL GET_TLMS_BASE_VOLSER\nCALL WRITE_TLMS_DISPLAY_VOLUME_SYSIN\n\"FREE FILE(\"TLMSFIDD\")\"\nCALL ALLOC_TLMS_DATASETS\nCALL FETCH_TLMS_LOAD_MODULE\nCALL GET_TLMS_TAPE_VOLSER_LIST\nCALL BROWSE_TAPE_VOLSER_LIST\nCALL FREE_DATASETS\nEXIT 0\n/*\n       S U B R O U T I N E   S E C T I O N     */\n/*     */\nALLOC_USER_DATASETS:\nADDRESS TSO\nDO D = 1 TO 2\n   \"ATTRIB\" ATTRB.D\n   ATTRBTL = WORD(ATTRB.D,1)\n   \"ALLOC DA('\"USERDSN.D\"') NEW SPACE(1,0) CYLINDERS USING(\"ATTRBTL\")\n    UNIT(\"DUNIT\")\"\n   SRC = RC\n   IF SRC \u00ac= 0 THEN DO\n      SAY '*** ALLOCATE ERROR: RETURN CODE: ('SRC'). ***'\n      SAY '*** ERROR ALLOCATING DATASET: ('USERDSN.D'). ***'\n      SAY '*** TLMS TAPE DATASET VOLSER LIST FACILITY CANCELLED. ***'\n      EXIT SRC\n   END\nEND\nRETURN\n/*     */\nWRITE_TLMS_DISPLAY_NAME_SYSIN:\n\"FREE DA('\"USERDSN.1\"')\"\n\"FREE FILE(TLMSIN)\"\n\"DELSTACK\"\nTLMSRCD = 'DN DSN='TAPEDSN\n\"ALLOC DA('\"USERDSN.1\"') FILE(TLMSIN) SHR\"\nQUEUE TLMSRCD\n\"EXECIO 1 DISKW TLMSIN (FINIS\"\nSRC = RC\n\"FREE FILE(TLMSIN)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** EXECIO WRITE ERROR: RETURN CODE: ('SRC'). ***'\n   SAY '*** ERROR WRITING ('USERDSN.1') TLMS SYSIN RECORDS. ***'\n   SAY '*** TLMS TAPE DATASET VOLSER LIST FACILITY CANCELLED. ***'\n   CALL FREE_DATASETS\n   EXIT SRC\nEND\nRETURN\n/*     */\nALLOC_TLMS_DATASETS:\nADDRESS TSO\nDO D = 1 TO 7\n   TLMSDD = WORD(TLMSFIDD,D)\n   \"ALLOC DA('\"TLMSDSN.D\"') FILE(\"TLMSDD\") SHR\"\n   SRC = RC\n   IF SRC \u00ac= 0 THEN DO\n      SAY '*** ALLOCATE ERROR: RETURN CODE: ('SRC'). ***'\n      SAY '*** ERROR ALLOCATING DATASET: ('TLMSDSN.D'). ***'\n      SAY '*** TLMS TAPE DATASET VOLSER LIST FACILITY CANCELLED. ***'\n      CALL FREE_DATASETS\n      EXIT SRC\n   END\nEND\nRETURN\n/*     */\nFETCH_TLMS_LOAD_MODULE:\n\"CALL '\"LOADLIB\"(TLMSRPTS)'\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** TLMS LOCATE ERROR: RETURN CODE: ('SRC'). ***'\n   SAY '*** TAPE DSN ('TAPEDSN') NOT FOUND IN TLMS VMF. ***'\n   SAY '*** TLMS TAPE DATASET VOLSER LIST FACILITY CANCELLED. ***'\n   CALL FREE_DATASETS\n   EXIT SRC\nEND\nRETURN\n/*     */\nGET_TLMS_BASE_VOLSER:\nVOLSW = 'NO'\n\"FREE DA('\"USERDSN.2\"')\"\n\"FREE FILE(TLMSPRT)\"\n\"ALLOC DA('\"USERDSN.2\"') FILE(TLMSPRT) SHR\"\n\"EXECIO * DISKR TLMSPRT (STEM DATA. FINIS\"\nSRC = RC\n\"FREE FILE(TLMSPRT)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** EXECIO READ ERROR: RETURN CODE: ('SRC'). ***'\n   SAY '*** ERROR READING ('USERDSN.2') TLMS SYSOUT RECORDS. ***'\n   SAY '*** TLMS TAPE DATASET VOLSER LIST FACILITY CANCELLED. ***'\n   CALL FREE_DATASETS\n   EXIT SRC\nEND\nDO I = 1 TO DATA.0\n   VSNKEY = POS('VSN=',DATA.I)\n   IF VSNKEY \u00ac= 0 THEN DO\n      VOLSW = 'YES'\n      V = VSNKEY + 4\n      TAPEVOL = SUBSTR(DATA.I,V,6)\n      LEAVE\n   END\nEND\nIF VOLSW = 'YES' THEN RETURN\nSAY '*** TAPE VOLSER ERROR: RETURN CODE: (8). ***'\nSAY '*** BASE TAPE VOLSER NOT FOUND IN ('USERDSN.2') TLMS SYSOUT RECORDS. ***'\nSAY '*** TLMS TAPE DATASET VOLSER LIST FACILITY CANCELLED. ***'\nCALL FREE_DATASETS\nEXIT 8\n/*     */\nWRITE_TLMS_DISPLAY_VOLUME_SYSIN:\n\"DELSTACK\"\nTLMSRCD = 'DVL 'TAPEVOL\n\"ALLOC DA('\"USERDSN.1\"') FILE(TLMSIN) SHR\"\nQUEUE TLMSRCD\n\"EXECIO 1 DISKW TLMSIN (FINIS\"\nSRC = RC\n\"FREE FILE(TLMSIN)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** EXECIO WRITE ERROR: RETURN CODE: ('SRC'). ***'\n   SAY '*** ERROR WRITING ('USERDSN.1') TLMS SYSIN RECORDS. ***'\n   SAY '*** TLMS TAPE DATASET VOLSER LIST FACILITY CANCELLED. ***'\n   CALL FREE_DATASETS\n   EXIT SRC\nEND\nRETURN\n/*     */\nGET_TLMS_TAPE_VOLSER_LIST:\nVOLSW = 'NO'\nVOLKEY = 'DVL 'TAPEVOL\n\"ALLOC DA('\"USERDSN.2\"') FILE(TLMSPRT) SHR\"\n\"EXECIO * DISKR TLMSPRT (STEM DATA. FINIS\"\nSRC = RC\n\"FREE FILE(TLMSPRT)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** EXECIO READ ERROR: RETURN CODE: ('SRC'). ***'\n   SAY '*** ERROR READING ('USERDSN.2') TLMS SYSOUT RECORDS. ***'\n   SAY '*** TLMS TAPE DATASET VOLSER LIST FACILITY CANCELLED. ***'\n   CALL FREE_DATASETS\n   EXIT SRC\nEND\nDO I = 1 TO DATA.0\n   VOLLST = POS(VOLKEY,DATA.I)\n   IF VOLLST \u00ac= 0 THEN DO\n      VOLSW = 'YES'\n      ITERATE\n   END\n   IF VOLSW = 'YES' THEN DO\n      SKIP = POS(TAPEDSN,DATA.I)\n      IF SKIP \u00ac= 0 THEN ITERATE\n      ENDKEY = POS('BUILDING',DATA.I)\n      IF ENDKEY \u00ac= 0 THEN LEAVE\n/*    SAY DATA.I  */\n   END\nEND\nIF VOLSW = 'YES' THEN RETURN\nSAY '*** TAPE VOLSER ERROR: RETURN CODE: (8). ***'\nSAY '*** BASE TAPE VOLSER NOT FOUND IN ('USERDSN.2') TLMS SYSOUT RECORDS. ***'\nSAY '*** TLMS TAPE DATASET VOLSER LIST FACILITY CANCELLED. ***'\nCALL FREE_DATASETS\nEXIT 8\n/*     */\nBROWSE_TAPE_VOLSER_LIST:\nADDRESS ISPEXEC\n\"EDIT DATASET('\"USERDSN.2\"')\"\nRETURN\n/*     */\nFREE_DATASETS:\nADDRESS TSO\nDO D = 1 TO 2\n   \"FREE DA('\"USERDSN.D\"')\"\n   UDSN = SYSDSN(\"'\"USERDSN.D\"'\")\n   IF UDSN = 'DATASET NOT FOUND' THEN ITERATE\n   \"ALLOC DA('\"USERDSN.D\"') FILE(USERDD)\"\n   \"DELETE ('\"USERDSN.D\"')  NONVSAM SCRATCH PURGE FILE(USERDD)\"\n   \"FREE FILE(USERDD)\"\nEND\n\"FREE ATTRLIST(ATTRB1 ATTRB2)\"\n\"FREE FILE(\"TLMSFIDD\")\"\nRETURN\n/*     */\nLISTCAT_TAPE_DATASET:\nT = 0\nLSTSW = 'NO'\nX = OUTTRAP(\"LSTCAT.\",\"*\",\"CONCAT\")\n\"LISTCAT ENT('\"TAPEDSN\"') VOL\"\nIF RC \u00ac= 0 THEN RETURN\nLSTSW = 'YES'\nDO L = 1 TO LSTCAT.0\n   VOLKEY = POS(\"VOLSER------------\",LSTCAT.L)\n   IF VOLKEY \u00ac= 0 THEN DO\n      STA = VOLKEY + 18\n      T = T + 1\n      TAPE.T = SUBSTR(LSTCAT.L,STA,6)\n   END\nEND\nTAPECNT = T\nRETURN\n/*     */\nWRITE_TAPE_DATASET_VOLSERS:\n\"DELSTACK\"\nC = 0\nTAPERCD = ' '\n\"ALLOC DA('\"USERLIB\"(TLMSVSNO)') FILE(TLMSDD) SHR\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** ALLOCATE ERROR: RETURN CODE: ('SRC'). ***'\n   SAY '*** ERROR ALLOCATING DATASET: ('USERLIB'(TLMSVSNO). ***'\n   SAY '*** TLMS TAPE DATASET VOLSER LIST FACILITY CANCELLED. ***'\n   EXIT SRC\nEND\nQUEUE TAPEHDR\nDO T = 1 TO TAPECNT\n   C = C + 1\n   IF C < 10 THEN DO\n      TAPERCD = TAPERCD||TAPE.T||' '\n      ITERATE\n   END\n   IF C = 10 THEN DO\n      C = 0\n      TAPERCD = TAPERCD||TAPE.T\n      QUEUE TAPERCD\n      TAPERCD = ' '\n   END\nEND\nIF TAPERCD \u00ac= ' ' THEN QUEUE TAPERCD\nNUMRCDS = QUEUED()\n\"EXECIO\" NUMRCDS \"DISKW TLMSDD (FINIS\"\nSRC = RC\n\"FREE FILE(TLMSDD)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** EXECIO WRITE ERROR: RETURN CODE: ('SRC'). ***'\n   SAY '*** ERROR WRITING DATASET: ('USERLIB'(TLMSVSNO). ***'\n   SAY '*** TLMS TAPE DATASET VOLSER LIST FACILITY CANCELLED. ***'\n   \"DELSTACK\"\n   EXIT SRC\nEND\nRETURN\n/*     */\nEDIT_TAPE_DATASET_VOLSERS:\nADDRESS ISPEXEC\n\"BROWSE DATASET('\"USERLIB\"(TLMSVSNO)')\"\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TLMSDISP": {"ttr": 20750, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x19\\x00\\x00\\x00\\x94!_\\x00\\x95\\x11O\\x154\\x00\\xec\\x01;\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf3@@@'", "ispf": {"version": "01.25", "flags": 0, "createdate": "1994-08-03T00:00:00", "modifydate": "1995-04-24T15:34:00", "lines": 236, "newlines": 315, "modlines": 0, "user": "TECH103"}, "text": "/*   REXX EXEC : ( TLMSDISP )\n     FUNCTION  : READS THE DISPATCH GENERATED TLMS UPDATE SYSIN\n                 DATASET TO EXTRACT THE TAPE VOLSER(S) AND INVOKE\n                 THE TLMSRPTS PROGRAM SERVICES TO DISPLAY THE TAPE\n                 DATASET INFORMATION TO DETERMINE IF THE TAPE VOLSER\n                 INDICATOR SHOULD BE SET TO SCRATCH=YES.\n     INPUT     : ( SYSS.DISPATCH.V5R0M0.TMSFILE ).\n                                                                      */\nTRACE O\n/*     */\nHOUSE_KEEPING:\nADDRESS TSO\nX = MSG(\"OFF\")\nWORKRCD = '***** DUMMY *****'\nTLMSDSN.1  = 'SYSS.TLMS.V5R3M0.VMF'\nTLMSDSN.2  = 'SYSS.TLMS.V5R3M0.VMF'\nTLMSDSN.3  = 'SYSS.TLMS.V5R3M0.VMF'\nTLMSDSN.4  = 'SYSS.TLMS.V5R3M0.RMF.CLUSTER'\nTLMSDSN.5 = 'SYSS.TLMS.V5R3M0.VMFINDEX.CLUSTER'\nTLMSDSN.6 = 'SYSS.DISPATCH.TLMS.SYSIN'\nTLMSDSN.7 = 'SYSS.DISPATCH.TLMS.SYSPRINT'\nTLMSFIDD = 'CAIVMF CAIVMFI CAIVMFS CAIRMF CAIVMFXI SYSIN SYSPRINT'\nTMSFILE = 'SYSS.DISPATCH.V5R0M0.TMSFILE'\nLOADLIB = 'SYS1.TLMS.V5R3M0.CAILIB.LOADLIB'\n/*\n       M A I N   R O U T I N E   S E C T I O N     */\n/*     */\nMAIN_ROUTINE:\nCALL READ_CHECK_DISPATCH_TMSFILE\nIF DISPSW = 'NO' THEN EXIT 0\nCALL ALLOCATE_WORK_DATASETS\nCALL WRITE_TLMS_DVA_SYSIN\nCALL ALLOCATE_TLMS_DATASETS\nTASK = 'DVA'\nCALL FETCH_TLMS_LOAD_MODULE\nCALL FREE_DATASETS\nCALL READ_CHECK_TLMS_DVA_SYSPRINT\nIF UPVSW = 'NO' THEN EXIT 0\nCALL ALLOCATE_WORK_DATASETS\nCALL WRITE_TLMS_UPV_SYSIN\nCALL ALLOCATE_TLMS_DATASETS\nTASK = 'UPV'\nCALL FETCH_TLMS_LOAD_MODULE\nCALL FREE_DATASETS\nEXIT 0\n/*\n       S U B R O U T I N E   S E C T I O N     */\n/*     */\nREAD_CHECK_DISPATCH_TMSFILE:\nT = 0\nDISPSW = 'NO'\nTDSN = SYSDSN(\"'\"TMSFILE\"'\")\nIF TDSN = 'DATASET NOT FOUND' THEN DO\n   SAY '***********************************************************************'\n   SAY '*** DATASET ALLOCATE ERROR: ('TMSFILE'). ***'\n   SAY '*** DISPATCH TMSFILE INPUT DATASET NOT FOUND. ***'\n   SAY '*** TLMS TAPE DATASET VOLSER LIST FACILITY CANCELLED. ***'\n   SAY '***********************************************************************'\n   EXIT 028\nEND\n\"ALLOC DA('\"TMSFILE\"') FILE(DISPDD) SHR\"\n\"EXECIO * DISKR DISPDD (STEM TLMS. FINIS\"\nSRC = RC\n\"FREE FILE(DISPDD)\"\nIF SRC \u00ac= 0 THEN RETURN\nIF TLMS.0 = 0 THEN RETURN\nDISPSW = 'YES'\nDO I = 1 TO TLMS.0\n   UPDKEY = WORD(TLMS.I,1)\n   IF UPDKEY = 'UPD' THEN DO\n      T = T + 1\n      TAPEVOL.T = SUBSTR(TLMS.I,5,6)\n   END\nEND\nTAPECNT = T\nRETURN\n/*     */\nALLOCATE_WORK_DATASETS:\nADDRESS TSO\n\"DELSTACK\"\nQUEUE WORKRCD\n\"ALLOC DA('\"TLMSDSN.6\"') FILE(WORKDD) SHR\"\n\"EXECIO 1 DISKW WORKDD (FINIS\"\n\"FREE FILE(WORKDD)\"\nQUEUE WORKRCD\n\"ALLOC DA('\"TLMSDSN.7\"') FILE(WORKDD) SHR\"\n\"EXECIO 1 DISKW WORKDD (FINIS\"\n\"FREE FILE(WORKDD)\"\nRETURN\n/* ***       N O O P\n\"DELETE ('\"TLMSDSN.6\"')  NONVSAM SCRATCH PURGE FILE(WORKDD)\"\n\"FREE DA('\"TLMSDSN.6\"')\"\n\"FREE FILE(WORKDD)\"\n\"ALLOC DA('\"TLMSDSN.7\"') FILE(WORKDD)\"\n\"DELETE ('\"TLMSDSN.7\"')  NONVSAM SCRATCH PURGE FILE(WORKDD)\"\n\"FREE DA('\"TLMSDSN.7\"')\"\n\"FREE FILE(WORKDD)\"\n\"ATTRIB ATTRB1 DSORG(PS) RECFM(F B) LRECL(80) BLKSIZE(80)\"\n\"ATTRIB ATTRB2 DSORG(PS) RECFM(F B A) LRECL(133) BLKSIZE(133)\"\nW = 6\n\"ALLOC DA('\"TLMSDSN.6\"') NEW SPACE(1,0) CYLINDERS USING(ATTRB1) UNIT(SMS)\"\nSRC = RC\n\"FREE DA('\"TLMSDSN.6\"')\"\n\"FREE ATTRLIST(ATTRB1)\"\nIF SRC \u00ac= 0 THEN SIGNAL WORK_DATASET_ALLOCATE_ERROR\nW = 7\n\"ALLOC DA('\"TLMSDSN.7\"') NEW SPACE(1,0) CYLINDERS USING(ATTRB2) UNIT(SMS)\"\nSRC = RC\n\"FREE ATTRLIST(ATTRB2)\"\n\"FREE DA('\"TLMSDSN.7\"')\"\nIF SRC = 0 THEN RETURN\n                             *** */\n/*     */\nWORK_DATASET_ALLOCATE_ERROR:\nSAY '**************************************************************************'\nSAY '*** ALLOCATE ERROR: RETURN CODE: ('SRC'). ***'\nSAY '*** ERROR ALLOCATING DATASET: ('TLMSDSN.W'). ***'\nSAY '*** TLMS TAPE DATASET VOLSER LIST FACILITY CANCELLED. ***'\nSAY '**************************************************************************'\n\"FREE DA(\"TLMSDSN.W\")\"\nEXIT SRC\n/*     */\nWRITE_TLMS_DVA_SYSIN:\n\"DELSTACK\"\n\"FREE FILE(TLMSIN)\"\n\"ALLOC DA('\"TLMSDSN.6\"') FILE(TLMSIN) SHR\"\nDO I = 1 TO TAPECNT\n   TLMSRCD = 'DVA 'TAPEVOL.I\n   QUEUE TLMSRCD\nEND\n\"EXECIO \"TAPECNT\" DISKW TLMSIN (FINIS\"\nSRC = RC\n\"FREE FILE(TLMSIN)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** EXECIO WRITE ERROR: RETURN CODE: ('SRC'). ***'\n   SAY '*** ERROR WRITING ('TLMSDSN.6') TLMS DVA SYSIN RECORDS. ***'\n   SAY '*** TLMS TAPE DATASET VOLSER LIST FACILITY CANCELLED. ***'\n   EXIT SRC\nEND\nRETURN\n/*     */\nALLOCATE_TLMS_DATASETS:\nCALL FREE_DATASETS\nDO D = 1 TO 7\n   TLMSDD = WORD(TLMSFIDD,D)\n   \"ALLOC DA('\"TLMSDSN.D\"') FILE(\"TLMSDD\") SHR\"\n   SRC = RC\n   IF SRC \u00ac= 0 THEN DO\n      SAY '*** ALLOCATE ERROR: RETURN CODE: ('SRC'). ***'\n      SAY '*** ERROR ALLOCATING DATASET: ('TLMSDSN.D'). ***'\n      SAY '*** TLMS TAPE DATASET VOLSER LIST FACILITY CANCELLED. ***'\n      CALL FREE_DATASETS\n      EXIT SRC\n   END\nEND\nRETURN\n/*     */\nFETCH_TLMS_LOAD_MODULE:\nADDRESS TSO\n\"CALL '\"LOADLIB\"(TLMSRPTS)'\"\nSRC = RC\nIF SRC \u00ac= 0 THEN DO\n   SAY '***********************************************************************'\n   SAY '*** TLMS UTILITY ERROR: RETURN CODE: ('SRC'). ***'\n   SAY '*** ('TASK') UTILITY  FUNCTION DID NOT COMPLETE SUCCESSFULLY. ***'\n   SAY '***********************************************************************'\n   CALL FREE_DATASETS\n   EXIT SRC\nEND\nRETURN\n/*     */\nREAD_CHECK_TLMS_DVA_SYSPRINT:\nU = 0\nUPVSW = 'NO'\n\"FREE FILE(TLMSPRT)\"\n\"ALLOC DA('\"TLMSDSN.7\"') FILE(TLMSPRT) SHR\"\n\"EXECIO * DISKR TLMSPRT (STEM DVA. FINIS\"\nSRC = RC\n\"FREE FILE(TLMSPRT)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** EXECIO READ ERROR: RETURN CODE: ('SRC'). ***'\n   SAY '*** ERROR READING ('TLMSDSN.7') TLMS SYSOUT RECORDS. ***'\n   SAY '*** TLMS TAPE DATASET VOLSER LIST FACILITY CANCELLED. ***'\n   EXIT SRC\nEND\nDO T = 1 TO TAPECNT\n   VSNKEY = 'VSN='TAPEVOL.T\n   DO I = 1 TO DVA.0\n      VOLKEY = POS(VSNKEY,DVA.I)\n      IF VOLKEY \u00ac= 0 THEN DO\n         N = WORDS(DVA.I)\n         CDS = WORD(DVA.I,N)\n         R = I + 3\n         DVARCD = STRIP(DVA.R)\n         VSNKEY = POS('DSN=',DVARCD)\n         V = VSNKEY + 4\n         TAPEDSN = SUBSTR(DVARCD,V)\n         VCIKEY = POS('VCI.DCAR.NEW',TAPEDSN)\n         IF VCIKEY \u00ac= 0 THEN DO\n            UPVSW = 'YES'\n            U = U + 1\n            UPDVOL.U = TAPEVOL.T\n            SAY '++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++'\n            SAY '<<< TAPE VSN: ('TAPEVOL.T') *** TAPE DSN: ('TAPEDSN') >>>'\n            SAY '++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++'\n         END\n         LEAVE\n      END\n   END\nEND\nUPDCNT = U\nRETURN\n/*     */\nWRITE_TLMS_UPV_SYSIN:\n\"DELSTACK\"\n\"FREE FILE(TLMSIN)\"\n\"ALLOC DA('\"TLMSDSN.6\"') FILE(TLMSIN) SHR\"\nDO I = 1 TO UPDCNT\n   TLMSRCD = 'UPV 'UPDVOL.I',SCRATCH=YES,'CDS\n   QUEUE TLMSRCD\nEND\n\"EXECIO \"UPDCNT\" DISKW TLMSIN (FINIS\"\nSRC = RC\n\"FREE FILE(TLMSIN)\"\nIF SRC \u00ac= 0 THEN DO\n   SAY '*** EXECIO WRITE ERROR: RETURN CODE: ('SRC'). ***'\n   SAY '*** ERROR WRITING ('TLMSDSN.6') TLMS UPV SYSIN RECORDS. ***'\n   SAY '*** TLMS TAPE DATASET VOLSER LIST FACILITY CANCELLED. ***'\n   EXIT SRC\nEND\nRETURN\n/*     */\nFREE_DATASETS:\nADDRESS TSO\n\"FREE FILE(\"TLMSFIDD\")\"\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TLMSMERG": {"ttr": 20997, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x12\\x00\\x00\\x00\\x93\\x07\\x1f\\x00\\x93#\\x1f\\x15\\x14\\x00l\\x00\\x13\\x00a\\xe3\\xc5\\xc3\\xc8\\xf1\\xf1\\xf0@@@'", "ispf": {"version": "01.18", "flags": 0, "createdate": "1993-03-12T00:00:00", "modifydate": "1993-08-19T15:14:00", "lines": 108, "newlines": 19, "modlines": 97, "user": "TECH110"}, "text": "/* REXX TLMS REPORT MERGE */\nTRUE = \"1\";\nFALSE = \"0\";\nEOF = FALSE;\nDO WHILE(\u00acEOF);\n    \"EXECIO 1 DISKR TLMS016 (STEM TLMS016.\";\n    IF RC\u00ac=0 THEN DO;\n         EOF = TRUE;\n         ITERATE;\n         END;\n    PARSE VALUE STRIP(SUBSTR(TLMS016.1,2)) WITH ,\n       P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 P13 P14 P15 . ;\n    IF VERIFY(P1,\"FPQ\") = 0 THEN DO;\n         DSN = P2;\n         END;\n    ELSE IF VERIFY(P1,\"123456789\") = 0 THEN DO;\n    OFF1RETNTYPE=\"-\";\n    OFF2RETNTYPE=\"-\";\n    OFF1LOCID=\"--\";\n    OFF2LOCID=\"--\";\n    OFF1RETNQTY=\"----\";\n    OFF2RETNQTY=\"----\";\n         RETNTYPE = P1;\n         LOCID = P2;\n         RETNQTY = P3;\n         IF RETNQTY=\"\" & P1\u00ac=\"6\" THEN ,\n               RETNQTY=\"----\";\n         ELSE IF P1=\"6\" THEN DO;\n            RETNQTY=\"----\";\n            OFF1RETNTYPE=P3;\n            OFF2RETNTYPE=P6;\n            OFF1LOCID=P4;\n            OFF2LOCID=P7;\n            OFF1RETNQTY=P5;\n            OFF2RETNQTY=P8;\n    IF VERIFY(P6,\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\") = 0 THEN DO;\n               OFF1RETNQTY=\"----\";\n            OFF2RETNTYPE=P5;\n            OFF2LOCID=P6;\n            OFF2RETNQTY=P7;\n            END;\n            IF OFF2RETNQTY=\"\" THEN ,\n               OFF2RETNQTY=\"----\";\n            END;\nTLMSOUT.1=LEFT(DSN,44)\"A\"LEFT(LOCID,2)LEFT(RETNTYPE,1)|| ,\n             LEFT(RETNQTY,4)|| ,\n             LEFT(OFF1LOCID,2)LEFT(OFF1RETNTYPE,1)|| ,\n             LEFT(OFF1RETNQTY,4)|| ,\n             LEFT(OFF2LOCID,2)LEFT(OFF2RETNTYPE,1)|| ,\n             LEFT(OFF2RETNQTY,4);\n         \"EXECIO 1 DISKW TLMSOUT (STEM TLMSOUT.\";\n         END;\n    ELSE IF P1 = \"**DEFAULT**\" THEN DO;\n         DSN = P1;\n         END;\nEND;\nEOF = FALSE;\nOLDDSN=\"\";\nDO WHILE(\u00acEOF);\n    \"EXECIO 1 DISKR TLMS004 (STEM TLMS004.\";\n    IF RC\u00ac=0 THEN DO;\n         EOF = TRUE;\n         ITERATE;\n         END;\n    TEMP = STRIP(SUBSTR(TLMS004.1,2));\n    PARSE VAR TEMP ,\n       P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 P13 P14 P15 . ;\n    IF POS(\".\",P1)\u00ac=0 THEN DO;\n         DSN = P1;\n         IF SUBSTR(DSN,1,1)=\"*\" THEN ,\n             DSN=SUBSTR(DSN,2);\n    KEEPDATE = WORD(TEMP,WORDS(TEMP));\n    VOLSER=P3;\n    \"EXECIO 1 DISKR TLMS004 (STEM TLMS004.\";\n    PARSE VALUE STRIP(SUBSTR(TLMS004.1,2)) WITH ,\n       P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 P13 P14 P15 . ;\n         CREATEDATE=P1;\n         CREATETIME=P2;\n         LASTINP = P6;\n         VOLCNT=P10;\n         IF POS(\"/\",LASTINP)=0 THEN DO;\n              LASTINP=\"N.A.\"\n              VOLCNT=P7;\n              END;\n         IF VERIFY(VOLCNT,\"0123456789\")\u00ac=0 THEN ,\n             VOLCNT=\"001\";\n         TLMSOUT.1 = LEFT(DSN,44)\"B\"|| ,\n             LEFT(CREATEDATE,8)LEFT(LASTINP,8)RIGHT(VOLCNT,3,\"0\")|| ,\n             LEFT(KEEPDATE,8);\n         NEWDSN=LEFT(DSN,44)CREATEDATE||CREATETIME;\n         V2=SUBSTR(VOLSER,1,2);\n         V3=SUBSTR(VOLSER,1,3);\n         IF OLDDSN\u00ac=NEWDSN & ,\n          (V2=\"C0\" | V2=\"C1\" | V2=\"C2\" | V2=\"C3\" | V3=\"022\") THEN DO;\n           \"EXECIO 1 DISKW TLMSOUT (STEM TLMSOUT.\";\n           OLDDSN=LEFT(DSN,44)CREATEDATE||CREATETIME;\n          END;\n         TLMSOUT3.1=LEFT(DSN,44)LEFT(VOLSER,6);\n         IF ,   /* VOLSER ROW */\n          (V2=\"C0\" | V2=\"C1\" | V2=\"C2\" | V2=\"C3\" | V3=\"022\") THEN ,\n           \"EXECIO 1 DISKW TLMSOUT3 (STEM TLMSOUT3.\";\n         END;\nEND;\n\"EXECIO 0 DISKR TLMS016 (FINIS\";\n\"EXECIO 0 DISKR TLMS004 (FINIS\";\n\"EXECIO 0 DISKR TLMSOUT (FINIS\";\n\"EXECIO 0 DISKR TLMSOUT3 (FINIS\";\nEXIT 0;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TLMSMRGX": {"ttr": 21000, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\r\\x00\\x00\\x00\\x93\\x07O\\x00\\x93\\x07\\x7f\\x10U\\x00(\\x00G\\x00#\\xe3\\xc5\\xc3\\xc8\\xf1\\xf1\\xf0@@@'", "ispf": {"version": "01.13", "flags": 0, "createdate": "1993-03-15T00:00:00", "modifydate": "1993-03-18T10:55:00", "lines": 40, "newlines": 71, "modlines": 35, "user": "TECH110"}, "text": "/* REXX TLMS REPORT MERGE */\nTRUE = \"1\";\nFALSE = \"0\";\n\"EXECIO * DISKR TLMSIN  (FINIS STEM TLMSIN.\";\nRINDEX=0;\nDO INDEX=1 TO TLMSIN.0; /* FIND RETENTION RCD */\n    PARSE VAR TLMSIN.INDEX DSN 45 RTYPE 46 REST;\n    IF RTYPE=\"B\" THEN ITERATE;\n    RDSN=STRIP(DSN);\n    RINDEX=INDEX; /* SAVE INDEX TO R */\n    RREST=STRIP(REST); /* SAVE */\n    LEAVE INDEX;\nEND;\nDO INDEX = 1 TO TLMSIN.0;\n    PARSE VAR TLMSIN.INDEX DSN 45 RTYPE 46 REST;\n    IF RTYPE=\"B\" THEN DO;\n         KEEPDATE=SUBSTR(TLMSIN.INDEX,65,8);\n         IF POS(\"/\",KEEPDATE)=0 THEN KEEPDATE=\"N.A.\";\n         TLMSOUT.1=SUBSTR(TLMSIN.INDEX,1,64);\nIF RINDEX<INDEX THEN DO;\nRINDEX=0;\nDO IX=INDEX TO TLMSIN.0; /* FIND RETENTION RCD */\n    PARSE VAR TLMSIN.IX XDSN 45 XRTYPE 46 XREST;\n    IF XRTYPE=\"B\" THEN ITERATE IX;\n    RDSN=STRIP(XDSN);\n    RINDEX=IX; /* SAVE INDEX TO R */\n    RREST=STRIP(XREST); /* SAVE */\n    LEAVE IX;\nEND;\nEND;\n       DSN=STRIP(DSN);\n       IF ABBREV(DSN,RDSN)=1 THEN ,\n            TLMSOUT.1=TLMSOUT.1||RREST;\n         ELSE TLMSOUT.1=TLMSOUT.1||COPIES(\"-\",21);\n         TLMSOUT.1=TLMSOUT.1||LEFT(KEEPDATE,8);\n       \"EXECIO 1 DISKW TLMSOUT (STEM TLMSOUT.\";\nEND;\nEND;\n\"EXECIO 0 DISKW TLMSOUT (FINIS\";\nEXIT 0;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TLMSX": {"ttr": 21002, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x93&?\\x00\\x944\\x9f\\t!\\x00\\x11\\x00\\x1c\\x00\\x11\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf7@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1993-09-20T00:00:00", "modifydate": "1994-12-15T09:21:00", "lines": 17, "newlines": 28, "modlines": 17, "user": "TECH107"}, "text": "PROC 0\nCONTROL NOMSG NOPROMPT NOLIST\nFREE F(OFFLINE ERRORS MASTER FOCEXEC FMU SYSIN FOCLIB FOCSQL PROFILE)\nALLOC F(FOCLIB)  DA('SYSS.FOCUS.V6R8M0.FOCSQL.LOAD') SHR\nALLOC F(FOCSQL)  DA('SYSS.TECH.COMMON.FOCSQL.DATA' -\n                    'SYSS.FOCUS.V6R8M0.FOCSQL.DATA') SHR\nALLOC F(ERRORS)  DA('SYSS.FOCUS.V6R8M0.ERRORS.DATA') SHR\nALLOC F(MASTER)  DA('SYSS.TECH.COMMON.MASTER.DATA' -\n                    'SYSS.FOCUS.V6R8M0.MASTER.DATA') SHR\nALLOC F(FOCEXEC) DA('SYSS.TECH.COMMON.FOCEXEC.DATA') SHR\nALLOC F(PROFILE) DA('SYSS.TECH.COMMON.TLMS.PROFILE') SHR\nALLOC F(FMU)     DA('SYSS.TECH.COMMON.FMU.DATA') SHR\nALLOC F(OFFLINE) SYSOUT(G) RECFM(F,B,A) LRECL(161) BLKSIZE(1610) -\n      FCB(GT15)\nCALL 'SYS1.FOCUS.V6R8M0.LOAD(FOCUS)'\nFREE F(OFFLINE ERRORS MASTER FOCEXEC FMU SYSIN FOCLIB FOCSQL PROFILE)\nEXIT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TLMSXOLD": {"ttr": 21004, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x944\\x9f\\x00\\x944\\x9f\\t\\x18\\x00\\x1c\\x00\\x1c\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf7@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-12-15T00:00:00", "modifydate": "1994-12-15T09:18:00", "lines": 28, "newlines": 28, "modlines": 0, "user": "TECH107"}, "text": "/* REXX TLMS    SYSTEM UTILIZATION */\nCALL DSQCIX \"START (DSQSMODE=INTERACTIVE DSQSSUBS=DSNA\";\nif dsq_return_code \u00ac=0 then do;\n    \"VMFCLEAR\";\n    say dsq_message_id dsq_message_text;\n    say dsq_q_message_id dsq_q_message_text;\n    signal term;\n    end;\ndo forever;\n\"VMFCLEAR\";\naddress \"ISPEXEC\" \"DISPLAY PANEL(PTLMS)\";\nif rc\u00ac=0 then signal term;\ndsname=strip(dsn);\nif dsname=\"\" then dsname=\"'%'\";\n    else do; dsname=\"'\"dsname\"%'\"; end;\n\"VMFCLEAR\";\nt=dsname; /* temp variable */\nCALL DSQCIX \"RUN QUERY TECH107.QTLMS (FORM TECH107.FTLMS &FILEDSN=\"t;\nif dsq_return_code \u00ac=0 then do;\n    \"VMFCLEAR\";\n    say dsq_message_id dsq_message_text;\n    say dsq_q_message_id dsq_q_message_text;\n    signal term;\n    end;\nend;\nterm:\nCALL DSQCIX \"EXIT\";\nEXIT 0;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "TMAN": {"ttr": 21006, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x10_\\x00\\x94\\x10_\\x04\\x10\\x00\\t\\x00\\t\\x00\\x00\\xc9\\xd6\\xc1\\xf4\\xf1\\xf0@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-04-15T00:00:00", "modifydate": "1994-04-15T04:10:00", "lines": 9, "newlines": 9, "modlines": 0, "user": "IOA410"}, "text": "PROC 0  APPLTYPE(S)  -\n        APPLID(CM)\n/****************************************************************\n/*                                                              *\n/*  CONTROL-M:   PRODUCTION CONTROL  SYSTEM          ( TSO)     *\n/*                                                              *\n/****************************************************************\n%IOAONL APPLTYPE(&APPLTYPE) APPLID(&APPLID)\nEND:END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TMANA": {"ttr": 21008, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x95\\x00/\\x00\\x95\\x00/\\x17I\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xe3\\xe3\\xf1\\xf2\\xf2\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1995-01-02T00:00:00", "modifydate": "1995-01-02T17:49:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "CTT122H"}, "text": "PROC 0  APPLTYPE(S)  -\n        APPLID(CA)\n/****************************************************************\n/*                                                              *\n/*  CONTROL-T:   REMOVABLE MEDIA MANAGEMENT SYSTEM   ( TSO)     *\n/*  CONTROL-M:   PRODUCTION CONTROL  SYSTEM          ( TSO)     *\n/*  CONTROL-B:   ONLINE BALANCING SYSTEM             ( TSO)     *\n/*  CONTROL-O:   AUTOMATED CONSOLE MANAGEMENT SYSTEM ( TSO)     *\n/*                                                              *\n/****************************************************************\n%IOAONL APPLTYPE(&APPLTYPE) APPLID(&APPLID)\nEND:END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TMAND": {"ttr": 21010, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x10_\\x00\\x94\\x10_\\x04\\x10\\x00\\n\\x00\\n\\x00\\x00\\xc9\\xd6\\xc1\\xf4\\xf1\\xf0@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-04-15T00:00:00", "modifydate": "1994-04-15T04:10:00", "lines": 10, "newlines": 10, "modlines": 0, "user": "IOA410"}, "text": "PROC 0  APPLTYPE(S)  -\n        APPLID(CS)\n/****************************************************************\n/*                                                              *\n/*  CONTROL-M:   PRODUCTION CONTROL  SYSTEM          ( TSO)     *\n/*  CONTROL-D:   REPORT DISTRIBUTION SYSTEM          ( TSO)     *\n/*                                                              *\n/****************************************************************\n%IOAONL APPLTYPE(&APPLTYPE) APPLID(&APPLID)\nEND:END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TMANG": {"ttr": 21012, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x95\\x00/\\x00\\x95\\x00/\\x17I\\x00\\x0b\\x00\\x0b\\x00\\x00\\xc3\\xe3\\xe3\\xf1\\xf2\\xf2\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1995-01-02T00:00:00", "modifydate": "1995-01-02T17:49:00", "lines": 11, "newlines": 11, "modlines": 0, "user": "CTT122H"}, "text": "PROC 0  APPLTYPE(S)  -\n        APPLID(CG)\n/****************************************************************\n/*                                                              *\n/*  CONTROL-T:   REMOVABLE MEDIA MANAGEMENT SYSTEM   ( TSO)     *\n/*  CONTROL-M:   PRODUCTION CONTROL  SYSTEM          ( TSO)     *\n/*  CONTROL-B:   ONLINE BALANCING SYSTEM             ( TSO)     *\n/*                                                              *\n/****************************************************************\n%IOAONL APPLTYPE(&APPLTYPE) APPLID(&APPLID)\nEND:END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TMANH": {"ttr": 21014, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x95\\x00/\\x00\\x95\\x00/\\x17I\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xe3\\xe3\\xf1\\xf2\\xf2\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1995-01-02T00:00:00", "modifydate": "1995-01-02T17:49:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "CTT122H"}, "text": "PROC 0  APPLTYPE(S)  -\n        APPLID(CH)\n/****************************************************************\n/*                                                              *\n/*  CONTROL-T:   REMOVABLE MEDIA MANAGEMENT SYSTEM   ( TSO)     *\n/*  CONTROL-M:   PRODUCTION CONTROL  SYSTEM          ( TSO)     *\n/*  CONTROL-D:   REPORT DISTRIBUTION SYSTEM          ( TSO)     *\n/*  CONTROL-O:   AUTOMATED CONSOLE MANAGEMENT SYSTEM ( TSO)     *\n/*                                                              *\n/****************************************************************\n%IOAONL APPLTYPE(&APPLTYPE) APPLID(&APPLID)\nEND:END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TMANK": {"ttr": 21016, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x10_\\x00\\x94\\x10_\\x04\\x10\\x00\\x0b\\x00\\x0b\\x00\\x00\\xc9\\xd6\\xc1\\xf4\\xf1\\xf0@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-04-15T00:00:00", "modifydate": "1994-04-15T04:10:00", "lines": 11, "newlines": 11, "modlines": 0, "user": "IOA410"}, "text": "PROC 0  APPLTYPE(S)  -\n        APPLID(CK)\n/****************************************************************\n/*                                                              *\n/*  CONTROL-M:   PRODUCTION CONTROL  SYSTEM          ( TSO)     *\n/*  CONTROL-D:   REPORT DISTRIBUTION SYSTEM          ( TSO)     *\n/*  CONTROL-O:   AUTOMATED CONSOLE MANAGEMENT SYSTEM ( TSO)     *\n/*                                                              *\n/****************************************************************\n%IOAONL APPLTYPE(&APPLTYPE) APPLID(&APPLID)\nEND:END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TMANL": {"ttr": 21018, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x95\\x00/\\x00\\x95\\x00/\\x17I\\x00\\x0b\\x00\\x0b\\x00\\x00\\xc3\\xe3\\xe3\\xf1\\xf2\\xf2\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1995-01-02T00:00:00", "modifydate": "1995-01-02T17:49:00", "lines": 11, "newlines": 11, "modlines": 0, "user": "CTT122H"}, "text": "PROC 0  APPLTYPE(S)  -\n        APPLID(CL)\n/****************************************************************\n/*                                                              *\n/*  CONTROL-T:   REMOVABLE MEDIA MANAGEMENT SYSTEM   ( TSO)     *\n/*  CONTROL-M:   PRODUCTION CONTROL  SYSTEM          ( TSO)     *\n/*  CONTROL-O:   AUTOMATED CONSOLE MANAGEMENT SYSTEM ( TSO)     *\n/*                                                              *\n/****************************************************************\n%IOAONL APPLTYPE(&APPLTYPE) APPLID(&APPLID)\nEND:END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TMANN": {"ttr": 21020, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x95\\x00/\\x00\\x95\\x00/\\x17I\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xe3\\xe3\\xf1\\xf2\\xf2\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1995-01-02T00:00:00", "modifydate": "1995-01-02T17:49:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "CTT122H"}, "text": "PROC 0  APPLTYPE(S)  -\n        APPLID(CN)\n/****************************************************************\n/*                                                              *\n/*  CONTROL-T:   REMOVABLE MEDIA MANAGEMENT SYSTEM   ( TSO)     *\n/*  CONTROL-M:   PRODUCTION CONTROL  SYSTEM          ( TSO)     *\n/*  CONTROL-D:   REPORT DISTRIBUTION SYSTEM          ( TSO)     *\n/*  CONTROL-B:   BALANCING SYSTEM                    ( TSO)     *\n/*                                                              *\n/****************************************************************\n%IOAONL APPLTYPE(&APPLTYPE) APPLID(&APPLID)\nEND:END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TMANO": {"ttr": 21022, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x10_\\x00\\x94\\x10_\\x04\\x10\\x00\\n\\x00\\n\\x00\\x00\\xc9\\xd6\\xc1\\xf4\\xf1\\xf0@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-04-15T00:00:00", "modifydate": "1994-04-15T04:10:00", "lines": 10, "newlines": 10, "modlines": 0, "user": "IOA410"}, "text": "PROC 0  APPLTYPE(S)  -\n        APPLID(CO)\n/****************************************************************\n/*                                                              *\n/*  CONTROL-M:   PRODUCTION CONTROL  SYSTEM          ( TSO)     *\n/*  CONTROL-O:   AUTOMATED CONSOLE MANAGEMENT SYSTEM ( TSO)     *\n/*                                                              *\n/****************************************************************\n%IOAONL APPLTYPE(&APPLTYPE) APPLID(&APPLID)\nEND:END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TMANP": {"ttr": 21249, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x95\\x00/\\x00\\x95\\x00/\\x17I\\x00\\x0b\\x00\\x0b\\x00\\x00\\xc3\\xe3\\xe3\\xf1\\xf2\\xf2\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1995-01-02T00:00:00", "modifydate": "1995-01-02T17:49:00", "lines": 11, "newlines": 11, "modlines": 0, "user": "CTT122H"}, "text": "PROC 0  APPLTYPE(S)  -\n        APPLID(CP)\n/****************************************************************\n/*                                                              *\n/*  CONTROL-T:   REMOVABLE MEDIA MANAGEMENT SYSTEM   ( TSO)     *\n/*  CONTROL-D:   REPORT DISTRIBUTION SYSTEM          ( TSO)     *\n/*  CONTROL-B:   ONLINE BALANCING SYSTEM             ( TSO)     *\n/*                                                              *\n/****************************************************************\n%IOAONL APPLTYPE(&APPLTYPE) APPLID(&APPLID)\nEND:END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TMANQ": {"ttr": 21251, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x95\\x00/\\x00\\x95\\x00/\\x17I\\x00\\n\\x00\\n\\x00\\x00\\xc3\\xe3\\xe3\\xf1\\xf2\\xf2\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1995-01-02T00:00:00", "modifydate": "1995-01-02T17:49:00", "lines": 10, "newlines": 10, "modlines": 0, "user": "CTT122H"}, "text": "PROC 0  APPLTYPE(S)  -\n        APPLID(CQ)\n/****************************************************************\n/*                                                              *\n/*  CONTROL-T:   REMOVABLE MEDIA MANAGEMENT SYSTEM (TSO)        *\n/*  CONTROL-M:   PRODUCTION CONTROL  SYSTEM      ( TSO)         *\n/*                                                              *\n/****************************************************************\n%IOAONL APPLTYPE(&APPLTYPE) APPLID(&APPLID)\nEND:END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TMANR": {"ttr": 21253, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x95\\x00/\\x00\\x95\\x00/\\x17I\\x00\\n\\x00\\n\\x00\\x00\\xc3\\xe3\\xe3\\xf1\\xf2\\xf2\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1995-01-02T00:00:00", "modifydate": "1995-01-02T17:49:00", "lines": 10, "newlines": 10, "modlines": 0, "user": "CTT122H"}, "text": "PROC 0  APPLTYPE(S)  -\n        APPLID(CR)\n/****************************************************************\n/*                                                              *\n/*  CONTROL-T:   REMOVABLE MEDIA MANAGEMENT SYSTEM (TSO)        *\n/*  CONTROL-D:   REPORT DISTRIBUTION SYSTEM        ( TSO)       *\n/*                                                              *\n/****************************************************************\n%IOAONL APPLTYPE(&APPLTYPE) APPLID(&APPLID)\nEND:END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TMANT": {"ttr": 21255, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x95\\x00/\\x00\\x95\\x00/\\x17I\\x00\\t\\x00\\t\\x00\\x00\\xc3\\xe3\\xe3\\xf1\\xf2\\xf2\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1995-01-02T00:00:00", "modifydate": "1995-01-02T17:49:00", "lines": 9, "newlines": 9, "modlines": 0, "user": "CTT122H"}, "text": "PROC 0  APPLTYPE(S)  -\n        APPLID(CT)\n/****************************************************************\n/*                                                              *\n/*  CONTROL-T:   REMOVABLE MEDIA MANAGEMENT SYSTEM   ( TSO)     *\n/*                                                              *\n/****************************************************************\n%IOAONL APPLTYPE(&APPLTYPE) APPLID(&APPLID)\nEND:END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TMANX": {"ttr": 21257, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x95\\x00/\\x00\\x95\\x00/\\x17I\\x00\\x0b\\x00\\x0b\\x00\\x00\\xc3\\xe3\\xe3\\xf1\\xf2\\xf2\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1995-01-02T00:00:00", "modifydate": "1995-01-02T17:49:00", "lines": 11, "newlines": 11, "modlines": 0, "user": "CTT122H"}, "text": "PROC 0  APPLTYPE(S)  -\n        APPLID(CX)\n/****************************************************************\n/*                                                              *\n/*  CONTROL-T:   REMOVABLE MEDIA MANAGEMENT SYSTEM   ( TSO)     *\n/*  CONTROL-M:   PRODUCTION CONTROL  SYSTEM          ( TSO)     *\n/*  CONTROL-D:   REPORT DISTRIBUTION SYSTEM          ( TSO)     *\n/*                                                              *\n/****************************************************************\n%IOAONL APPLTYPE(&APPLTYPE) APPLID(&APPLID)\nEND:END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TMANY": {"ttr": 21259, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x95\\x00/\\x00\\x95\\x00/\\x17I\\x00\\n\\x00\\n\\x00\\x00\\xc3\\xe3\\xe3\\xf1\\xf2\\xf2\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1995-01-02T00:00:00", "modifydate": "1995-01-02T17:49:00", "lines": 10, "newlines": 10, "modlines": 0, "user": "CTT122H"}, "text": "PROC 0  APPLTYPE(S)  -\n        APPLID(CY)\n/****************************************************************\n/*                                                              *\n/*  CONTROL-T:   REMOVABLE MEDIA MANAGEMENT SYSTEM   ( TSO)     *\n/*  CONTROL-B:   ONLINE BALANCING SYSTEM             ( TSO)     *\n/*                                                              *\n/****************************************************************\n%IOAONL APPLTYPE(&APPLTYPE) APPLID(&APPLID)\nEND:END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TMANZ": {"ttr": 21261, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x95\\x00/\\x00\\x95\\x00/\\x17I\\x00\\r\\x00\\r\\x00\\x00\\xc3\\xe3\\xe3\\xf1\\xf2\\xf2\\xc8@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1995-01-02T00:00:00", "modifydate": "1995-01-02T17:49:00", "lines": 13, "newlines": 13, "modlines": 0, "user": "CTT122H"}, "text": "PROC 0  APPLTYPE(S)  -\n        APPLID(CZ)\n/****************************************************************\n/*                                                              *\n/*  CONTROL-T:   REMOVABLE MEDIA MANAGEMENT SYSTEM   ( TSO)     *\n/*  CONTROL-M:   PRODUCTION CONTROL  SYSTEM          ( TSO)     *\n/*  CONTROL-D:   REPORT DISTRIBUTION SYSTEM          ( TSO)     *\n/*  CONTROL-O:   AUTOMATED CONSOLE MANAGEMENT SYSTEM ( TSO)     *\n/*  CONTROL-B:   ONLINE BALANCING SYSTEM             ( TSO)     *\n/*                                                              *\n/****************************************************************\n%IOAONL APPLTYPE(&APPLTYPE) APPLID(&APPLID)\nEND:END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "TSODARUN": {"ttr": 21263, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x10\\x00\\x00\\x00\\x925/\\x00\\x925o\\x15V\\x00!\\x00\\x06\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf1\\xf0@@@'", "ispf": {"version": "01.16", "flags": 0, "createdate": "1992-12-17T00:00:00", "modifydate": "1992-12-21T15:56:00", "lines": 33, "newlines": 6, "modlines": 0, "user": "TECH110"}, "text": "/* REXX */\nTRUE = \"1\";\nFALSE = \"0\";\nSDSF.1 = \"PREFIX **\";\nSDSF.2 = \"DA OJOB\";\n\"EXECIO * DISKW ISFIN (FINIS STEM SDSF.\";\nDROP SDSF.;\nDO FOREVER;\n\"SDSF\";\nDROP SDSFOUT.;\n\"EXECIO * DISKR ISFOUT (FINIS STEM SDSFOUT.\";\nRCTR = 0;\nFOUND_DA = FALSE;\nDO I = 1 TO SDSFOUT.0;\n   IF \u00acFOUND_DA THEN DO;\n        IF SUBSTR(SDSFOUT.I,1,13)\u00ac=\"1 SDSF DA SYS\" THEN ITERATE I;\n        FOUND_DA = TRUE;\n        ITERATE I;\n        END;\n   IF SDSFOUT.I=\" \" THEN ITERATE I;\n   IF SUBSTR(SDSFOUT.I,1,15)=\"  COMMAND INPUT\" THEN DO;\n        RCTR = RCTR + 1;\n        REPOUT.RCTR=\"TIMESTAMP:\" DATE() TIME();\n        ITERATE I;\n        END;\n   RCTR = RCTR + 1;\n   REPOUT.RCTR = SUBSTR(SDSFOUT.I,2);\nEND;\n\"EXECIO * DISKW REPORT (FINIS STEM REPOUT.\";\nDROP REPOUT.;\n\"SLEEP 00010000\"; /* SLEEP HHMMSSTH */\nEND; /* END LOOP */\nEXIT 0;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "USER": {"ttr": 21265, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x921O\\x00\\x921O\\x10F\\x006\\x006\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1992-11-09T00:00:00", "modifydate": "1992-11-09T10:46:00", "lines": 54, "newlines": 54, "modlines": 0, "user": "TECH103"}, "text": "PROC 0 DEBUG QUIET MENU SCRIPT() TRAN(BRACKET) NUAIOPT() ISPEXEC(YES) +\n    LOAD(SYS1.NETUA.V2R8M8.LOADLIB) PGM(NUACLIEN)\n/**\n/**  REFER: NUA.V2R8M8.TEXT(NUAUSER)\n/**  COMP:  IBM/MVS USER-ACCESS (H213)\n/**  DOC:   TSO/E CLIST TO EXECUTE THE CLIENT (INITIATOR)\n/**\n/**  NOTE:  THIS CLIST MUST BE COPIED INTO A CLIST LIBRARY\n/**         ACCESSIBLE BY TSO/E USERS AT YOUR INSTALLATION\n/**\nCONTROL NOFLUSH NOPROMPT MSG END(ENDO) ASIS  /* MSG REQUIRED */\nIF &DEBUG EQ DEBUG THEN CONTROL PROMPT LIST CONLIST\n/**\nIF &MENU EQ MENU THEN SET QUIET=QUIET\nELSE IF &SYSISPF EQ ACTIVE THEN ISPEXEC CONTROL DISPLAY LINE START(1)\nIF &QUIET EQ THEN WRITE %NUAUSER  - USER-Access starting\nIF &STR(\"&SUBSTR(1:1,&STR(&SCRIPT ))\") EQ \"'\" THEN +\n    SET SCRIPT=&STR('&SCRIPT')\n/**\nIF &SYSENV EQ FORE THEN DO\n    ALLOC F(SYSIN)    DS(*) REUSE\n    ALLOC F(SYSPRINT) DS(*) REUSE RECFM(V B A)\n    ALLOC F(SYSERR)   DS(*) REUSE RECFM(V B A)\n    /**\n    IF &TRAN NE         THEN TERM NOTRAN NOCHAR\n    IF &TRAN EQ BRACKET THEN TERM CHAR((X'41',X'AD'),(X'42',X'BD'))\n    ENDO\n/**\nIF &ISPEXEC EQ YES AND &SYSISPF EQ ACTIVE THEN DO\n    ISPEXEC CONTROL ERRORS RETURN\n    ISPEXEC LIBDEF ISPLLIB EXCLDATA ID('&LOAD') UNCOND\n    SET &CC=&LASTCC\n    IF &CC EQ 0 THEN DO\n        IF &MENU EQ MENU THEN DO\n            ISPEXEC VPUT (NUAIOPT) SHARED\n            ISPEXEC VGET (ZAPPLID) SHARED\n            IF &ZAPPLID EQ NUAI THEN SET NEWAPPL=\n            ELSE SET NEWAPPL=NEWAPPL(NUAI) PASSLIB\n            ENDO\n        ISPEXEC SELECT PGM(&PGM) PARM('&SCRIPT') &NEWAPPL\n        SET &CC=&LASTCC\n        ENDO\n    ISPEXEC LIBDEF ISPLLIB\n    ENDO\nELSE DO\n    CALL '&LOAD(&PGM)' '&SCRIPT'\n    SET CC=&LASTCC\n    ENDO\n/**\nIF &SYSENV EQ FORE AND &TRAN NE THEN TERM NOTRAN NOCHAR\n/**\nIF &QUIET EQ THEN WRITE %NUAUSER  - USER-Access complete - Code(&CC)\nIF &DATATYPE(&CC) NE NUM THEN EXIT CODE(12)\nEXIT CODE(&CC)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "USERIP": {"ttr": 21267, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x08\\x00\\x00\\x00\\x94#\\x0f\\x00\\x94#_\\x131\\x008\\x007\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf3@@@'", "ispf": {"version": "01.08", "flags": 0, "createdate": "1994-08-18T00:00:00", "modifydate": "1994-08-23T13:31:00", "lines": 56, "newlines": 55, "modlines": 0, "user": "TECH103"}, "text": "PROC 0 DEBUG QUIET MENU TRAN(BRACKET) NUAIOPT() ISPEXEC(YES)          +\n    LOAD(SYS1.NETUA.V2R10M12.LOADLIB) PGM(NUACLIEN) NUAIUNIT()\n/**\n/**  REFER: SYSS.NETUA.V2R10M12.TEXTLIB(NUAUSER)\n/**  COMP:  IBM/MVS USER-ACCESS (H213)\n/**  DOC:   TSO/E CLIST TO EXECUTE THE CLIENT PROGRAM\n/** SCRIPT('SYSS.NETUA.V2R10M12.TEXTLIB(NUAIISPF)''\n/**\n/**  NOTE:  THIS MEMBER IS COPIED TO 'SYS1.CMDPROC' OR EQUIVALENT\n/**         DATA SET BY THE USER-ACCESS INSTALLATION JOB\n/**\nCONTROL NOFLUSH NOPROMPT MSG END(ENDO) ASIS  /* MSG REQUIRED */\nIF &DEBUG EQ DEBUG THEN CONTROL PROMPT LIST CONLIST\n/**\nIF &MENU EQ MENU THEN SET QUIET=QUIET\nELSE IF &SYSISPF EQ ACTIVE THEN ISPEXEC CONTROL DISPLAY LINE START(1)\nIF &QUIET EQ THEN WRITE %USER - USER-Access starting\nIF &STR(\"&SUBSTR(1:1,&STR(&SCRIPT ))\") EQ \"'\" THEN +\n    SET SCRIPT=&STR('&SCRIPT')\n/**\nIF &SYSENV EQ FORE THEN DO\n    ALLOC F(SYSIN)    DS(*) REUSE\n    ALLOC F(SYSPRINT) DS(*) REUSE RECFM(V B A)\n    ALLOC F(SYSERR)   DS(*) REUSE RECFM(V B A)\n    /**\n    IF &TRAN NE         THEN TERM NOTRAN NOCHAR\n    IF &TRAN EQ BRACKET THEN TERM CHAR((X'41',X'AD'),(X'42',X'BD'))\n    ENDO\n/**\nIF &ISPEXEC EQ YES AND &SYSISPF EQ ACTIVE THEN DO\n    ISPEXEC CONTROL ERRORS RETURN\n    ISPEXEC LIBDEF ISPLLIB EXCLDATA ID('&LOAD') UNCOND\n    SET &CC=&LASTCC\n    IF &CC EQ 0 THEN DO\n        IF &MENU EQ MENU THEN DO\n            ISPEXEC VPUT (NUAIOPT)  SHARED\n            ISPEXEC VPUT (NUAIUNIT) SHARED\n            ISPEXEC VGET (ZAPPLID) SHARED\n            IF &ZAPPLID EQ NUAI THEN SET NEWAPPL=\n            ELSE SET NEWAPPL=NEWAPPL(NUAI) PASSLIB\n            ENDO\n        ISPEXEC SELECT PGM(&PGM) PARM('&SCRIPT') &NEWAPPL\n        SET &CC=&LASTCC\n        ENDO\n    ISPEXEC LIBDEF ISPLLIB\n    ENDO\nELSE DO\n    CALL '&LOAD(&PGM)' '&SCRIPT'\n    SET CC=&LASTCC\n    ENDO\n/**\nIF &SYSENV EQ FORE AND &TRAN NE THEN TERM NOTRAN NOCHAR\n/**\nIF &QUIET EQ THEN WRITE %USER - USER-Access complete - Code(&CC)\nIF &DATATYPE(&CC) NE NUM THEN EXIT CODE(12)\nEXIT CODE(&CC)\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "VLFUP": {"ttr": 21269, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x13\\x00\\x00\\x00\\x92'\\x9f\\x00\\x92'\\x9f\\x16\\x03\\x00\\r\\x00\\x0b\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf1\\xf0@@@\"", "ispf": {"version": "01.19", "flags": 0, "createdate": "1992-10-05T00:00:00", "modifydate": "1992-10-05T16:03:00", "lines": 13, "newlines": 11, "modlines": 0, "user": "TECH110"}, "text": "/* REXX automatic VLF update command */\nparse upper arg \"(VLFDSN=\" dsname \",VLFMEM=\" member \",VLFFUNC=\" ,\n    func \")\";\nif dsname=\"\" then do;\n     say \"Invalid dsname argument passed\";\n     exit 0;\n     end;\nquote = substr(dsname,1,1);\nif quote=\"'\" | quote='\"' then , /* strip enclose quotes */\n     dsname=substr(dsname,2,length(dsname)-2);\nif func=\"\" then func=\"UPDATE\";\n\"VLFNOTE\" func \"DATASET('\"dsname\"(\"member\")')\";\nexit rc;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "VPSOPT02": {"ttr": 21271, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x0e\\x00\\x00\\x00\\x91\\x11\\x9f\\x00\\x93\\x01O\\x10\\x16\\x00Z\\x00\\\\\\x00Z\\xd3\\xd9\\xe2\\xf0\\xf0\\xf2@@@@'", "ispf": {"version": "01.14", "flags": 0, "createdate": "1991-04-29T00:00:00", "modifydate": "1993-01-14T10:16:00", "lines": 90, "newlines": 92, "modlines": 90, "user": "LRS002"}, "text": "PROC 0 DEBUG\nIF &DEBUG = DEBUG THEN -\n   DO\n      CONTROL MSG FLUSH CONLIST SYMLIST LIST\n   END\nELSE -\n   CONTROL NOMSG NOFLUSH NOCONLIST NOSYMLIST NOLIST\n   ISPEXEC DISPLAY PANEL(VPSPANEL) MSG(&MSG)\n   IF &LASTCC = 8 THEN EXIT CODE(8)\n/* ------------------------------------------------------------------ */\nBEGIN: -\n  IF &OPTIONS = Y THEN SET &OPTIONS = &STR()\n   SET &COPIES = &STR()\n   SET &FORMS = &STR()\n   SET &FCBNM = &STR()\n   SET &CLASS = &STR()\n   SET &PAGELEN = &STR()\n   SET &TMARGIN = &STR()\n   SET &BMARGIN = &STR()\n   SET &HLD     = &STR()\n/* ------------------------------------------------------------------ */\nIF &CNT      NE  &STR() THEN -\n   SET &COPIES = &STR(COPIES(&CNT))\n/* ------------------------------------------------------------------ */\nIF &FORMNAME NE &STR()  THEN -\n      SET &FORMS = &STR(FORMS(&FORMNAME) )\n/* ------------------------------------------------------------------ */\n   SET &NUMBRING = &STR(&NUMBRING)\n/* ------------------------------------------------------------------ */\n   SET &PAGEJECT = &STR(&PAGEJECT)\n/* ------------------------------------------------------------------ */\nIF &FCBID NE &STR() THEN -\n   SET &FCBNM = &STR(FCB(&FCBID) )\n/* ------------------------------------------------------------------ */\n   IF  &OCLASS  \u00ac= &STR() THEN +\n   SET &CLASS = &STR(CLASS(&OCLASS))\n/* ------------------------------------------------------------------ */\nIF &PL NE &STR()  THEN -\n   SET &PAGELEN = &STR(PAGELEN(&PL) )\n/* ------------------------------------------------------------------ */\nIF &TM NE &STR() THEN -\n   SET &TMARGIN = &STR(TMARGIN(&TM) )\n/* ------------------------------------------------------------------ */\nIF &BM NE &STR() THEN -\n   SET &BMARGIN = &STR(BMARGIN(&BM) )\n/* ---- WSP 10/28/91 (ALSO CHANGED PANEL) --------------------------- */\nIF &HOLD = Y THEN -\n   SET HLD = HOLD\n/* ------------------------------------------------------------------ */\nIF &SMMODE =  Y THEN -\n   DO\n     SET &NOMSG =\n     ISPEXEC CONTROL DISPLAY SM\n   END\nELSE -\n   ISPEXEC CONTROL DISPLAY LINE\nVPSPRINT &DSNVP +\n         &PRINTER  +\n         &NOMSG +\n         &COPIES +\n         &HEADER +\n         &HLD    +\n         &PAGEJECT +\n         &FORMS +\n         &NUMBRING +\n         &CARGCNTL +\n         &FCBNM +\n         &CLASS +\n         &PAGELEN +\n         &TMARGIN +\n         &BMARGIN +\n         &LOG +\n         &PAGES +\n         &LINES +\n         &OPTIONS\nSET &VPSRC = &LASTCC\nIF &VPSRC = 0 THEN -\n   DO\n     ISPEXEC DISPLAY MSG(VP015) CURSOR(DSNVP)\n     IF &LASTCC = 8 THEN -\n        EXIT CODE(8)\n     ELSE -\n     GOTO BEGIN\n   END\nELSE -\n   DO\n     ISPEXEC DISPLAY MSG(VP016) CURSOR(DSNVP)\n     IF &LASTCC = 8 THEN EXIT CODE(8)\n     GOTO BEGIN\n   END\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "WEEKDAY": {"ttr": 21274, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x935O\\x00\\x95\\x01\\x0f\\x131\\x00\\x1a\\x00\\x19\\x00\\x01\\xe3\\xc5\\xc3\\xc8\\xf1\\xf1\\xf0@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1993-12-20T00:00:00", "modifydate": "1995-01-10T13:31:00", "lines": 26, "newlines": 25, "modlines": 1, "user": "TECH110"}, "text": "/* REXX Weekday Calculation from 1901-2099 */\n/* Input is MM/DD/YYYY                     */\n/* Output is day of the week; i.e., Sun Julian-date-within-year */\nperpetual_pattern = , /* periodic calendar pattern */\n  \"3 4 5 13 1 2 3 11 6 7 1 9 4 5 6 14 2 3 4 12 7 1 2 10 5 6 7 8\";\nmonths_non_leapyear=\"01 32 60 91 121 152 182 213 244 274 305 335\";\nmonths_leapyear    =\"01 32 61 92 122 153 183 214 245 275 306 336\";\nweekdays=\"Sun Mon Tue Wed Thu Fri Sat\";\nparse arg mm \"/\" dd \"/\" yyyy; /* input calc date */\nif (yyyy< 1901) | (yyyy>2099) then return \"\"; /* error */\nif (mm< 1) | (mm>12) then return \"\"; /* error */\nif (dd< 1) | (dd>31) then return \"\"; /* error */\npattern = word(perpetual_pattern,(((yyyy - 1901) // 28) + 1));\nif pattern <= 7 then do;\n          months_pattern = months_non_leapyear;\n          week_offset    = pattern;\n          end;\nelse do;\n          months_pattern = months_leapyear;\n          week_offset    = pattern-7;\n          end;\njulian_date= word(months_pattern,mm)+dd-1;\nday        = (julian_date//7)-1+week_offset;\nif day=0 then day=7; /* adjustment */\nif day>7 then day=day-7;\nreturn word(weekdays,day) julian_date;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "WEEKDUMP": {"ttr": 21276, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x00\\x00\\x93\\x10_\\x00\\x93\\x10_\\x14\\x08\\x00\\x14\\x00\\x15\\x00\\x03\\xe3\\xc5\\xc3\\xc8\\xf1\\xf1\\xf0@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "1993-04-15T00:00:00", "modifydate": "1993-04-15T14:08:00", "lines": 20, "newlines": 21, "modlines": 3, "user": "TECH110"}, "text": "/* REXX ABR Dump Volume status */\nCALL DSQCIX \"START (DSQSMODE=INTERACTIVE DSQSSUBS=DSNA\";\nif dsq_return_code \u00ac=0 then do;\n    \"VMFCLEAR\";\n    say dsq_message_id dsq_message_text;\n    say dsq_q_message_id dsq_q_message_text;\n    signal term;\n    end;\n\"VMFCLEAR\";\nCALL DSQCIX \"RUN QUERY TECH110.QABRVOLS (FORM TECH110.FABRVOLS\";\nif dsq_return_code \u00ac=0 then do;\n    \"VMFCLEAR\";\n    say dsq_message_id dsq_message_text;\n    say dsq_q_message_id dsq_q_message_text;\n    signal term1;\n    end;\nterm1:\nCALL DSQCIX \"EXIT\";\nterm:\nEXIT 0;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "WEEKREST": {"ttr": 21278, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x93\\x01\\x1f\\x00\\x93\\x01?\\x12P\\x00\\x03\\x00\\x05\\x00\\x01\\xe3\\xc5\\xc3\\xc8\\xf1\\xf1\\xf0@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1993-01-11T00:00:00", "modifydate": "1993-01-13T12:50:00", "lines": 3, "newlines": 5, "modlines": 1, "user": "TECH110"}, "text": "/* REXX */\n\"WREST\"; /* REST MONITOR */\nEXIT 0;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "WOSEARCH": {"ttr": 21280, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x00\\x00\\x00\\x94\\x11\\x7f\\x00\\x94\\x13O\\x12\\x08\\x00I\\x008\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf2\\xf0\\xf9@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "1994-04-27T00:00:00", "modifydate": "1994-05-14T12:08:00", "lines": 73, "newlines": 56, "modlines": 0, "user": "TECH209"}, "text": "/*  REXX EXEC : ( WOSEARCH )\n    FUNCTION  : GENERATE CCF TURNOVER DISPLAY OF MEMBERS TURNED OVER.\n    INPUT     : ( SYSS.CCF.TURNOVER.JOURNAL(&&MEMBER)).\n    OUTPUT    : DISPLAY ON TSOE.\n                                                                      */\n/*     */\nHOUSE_KEEPING:\nADDRESS TSO\n/* PARMS = 'WONUMBR' */\nMEMFOUND = 0\nTHEDATE = 31\nMEMDISP = 0\nSAY \"THIS EXEC WILL SHOW THE LAST TWO TIMES A MEMBER HAS\"\nSAY \"BEEN TURNED OVER WITHIN THE LAST MONTH AND ALL MEMBERS\"\nSAY \"ASSOCIATED WITH THE WORKORDERS USED FOR THE TURNOVERS.\"\nSAY\nSAY \"ENTER THE MEMBER NAME YOU WOULD LIKE TO SEARCH FOR\"\nPULL MODNAME\nJOURNAL_PDS = 'SYSS.CCF.TURNOVER.JOURNAL'\nCALL GET_JOURNAL_MEMBER_LIST\nCALL READ_JOURNAL_MEMBER\nCALL DISPLAY_NO_MEMBERS_FOUND\nEXIT\n/*   S U B R O U T I N E   S E C T I O N   */\n/*     */\nGET_JOURNAL_MEMBER_LIST:\nX = OUTTRAP(\"MEMBER.\",\"*\",\"CONCAT\")\n\"LISTDS ('\"JOURNAL_PDS\"') MEMBERS\"\nM = MEMBER.0\nX = MEMBER.0 - 7\nSRC = RC\nIF SRC = 0 THEN RETURN\nSAY\nSAY '*** LISTDS ERROR: ERROR READING ('JOURNAL_PDS') MEMBER LIST. ***'\nSAY '*** WOSEARCH EXEC SUBTASK CANCELLED RC = ('SRC'). ***'\nEXIT SRC\n\n/*     */\nREAD_JOURNAL_MEMBER:\nDO X                /* SKIP LISTDS HEADER INFO - START AT RCD 7 */\n   IF MEMFOUND = 2 THEN LEAVE\n   IF THEDATE = 0 THEN LEAVE\n   MEMBER = STRIP(MEMBER.M)\n/* SAY '+++ PROCESSING JOURNAL MEMBER: ('MEMBER') +++' */\n   \"ALLOC DA('\"JOURNAL_PDS\"(\"MEMBER\")') F(JOURDD) SHR\"\n   \"EXECIO * DISKR JOURDD (FINIS STEM DATA.\"\n   \"FREE FILE(JOURDD)\"\n   M = M - 1\n   THEDATE = THEDATE - 1\n   DO I = 3 TO DATA.0    /* SKIP JOURNAL MEMBER HEADER INFO - START AT RCD 3 */\n      PARSE VAR DATA.I PDATE PTIME WORKORDR PROGRAMMER MASTER MODULE MODTYPE\n         IF MODULE \\= MODNAME THEN ITERATE\n           WONUMBR = WORKORDR\n           CALL READ_MEMBER_AGAIN\n           MEMFOUND = MEMFOUND + 1\n           LEAVE\n   END\nEND\nRETURN\n/*     */\nREAD_MEMBER_AGAIN:\n   DO I = 3 TO DATA.0    /* SKIP JOURNAL MEMBER HEADER INFO - START AT RCD 3 */\n      PARSE VAR DATA.I PDATE PTIME WORKORDR PROGRAMMER MASTER MODULE MODTYPE\n         IF WORKORDR \\= WONUMBR THEN ITERATE\nSAY ''WORKORDR' - 'MODULE' - 'PDATE''\nMEMDISP = MEMDISP + 1\nEND\nRETURN\n/*     */\nDISPLAY_NO_MEMBERS_FOUND:\n   IF MEMDISP \u00ac= 0 THEN RETURN\nSAY ''MODNAME' HAS NOT BEEN TURNED OVER IN THE LAST MONTH'\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "XDB2PROD": {"ttr": 21506, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x93\\x10_\\x00\\x93\\x19_\\x160\\x00\\x1a\\x00\\x18\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf6\\xf0\\xf1@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1993-04-15T00:00:00", "modifydate": "1993-07-14T16:30:00", "lines": 26, "newlines": 24, "modlines": 0, "user": "TECH601"}, "text": "/* REXX DB2 system dependent invoke DSN prd */\nparse upper arg prog plan; /* passed program and plan */\nif plan=\"\"  then exit 28;\ntrue=1;\nfalse=0;\nsysalib = \"'SYS1.prod.batch.loadlib'\";\nsysblib = \"'SYS1.prod.batch.loadlib'\";\ncvtptr = storage(\"00000010\",4); /* locate llt/smca from cvt */\ncvtsmca = storage(d2x(c2d(cvtptr)+196),4); /* mapping smca */\nsavehi=substr(c2x(cvtsmca),1,2); /* hi order bit is on */\nsmcasid = savehi||d2x(x2d(substr(c2x(cvtsmca),3))+16);\nsmcasid = storage(smcasid,4); /* SMF id */\nselect;\n  when (smcasid=\"SYSA\") then do;\n    queue \"DSN SYSTEM(DSNA)\";\n    queue \"RUN PROGRAM(\"prog\") PLAN(\"plan\") LIBRARY(\"sysalib\")\";\n    queue \"END\";\n         end;\n  when (smcasid=\"SYSB\") then do;\n    queue \"DSN SYSTEM(DSNB)\";\n    queue \"RUN PROGRAM(\"prog\") PLAN(\"plan\") LIBRARY(\"sysblib\")\";\n    queue \"END\";\n         end;\n  otherwise exit 24;\nend;\nexit 0;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "XDB2TEST": {"ttr": 21508, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x00\\x00\\x93\\x11?\\x00\\x93\\x19_\\x15F\\x00\\x1a\\x00\\x1a\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf6\\xf0\\xf1@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "1993-04-23T00:00:00", "modifydate": "1993-07-14T15:46:00", "lines": 26, "newlines": 26, "modlines": 0, "user": "TECH601"}, "text": "/* REXX DB2 system dependent invoke DSN prd */\nparse upper arg prog plan; /* passed program and plan */\nif plan=\"\"  then exit 28;\ntrue=1;\nfalse=0;\nsysalib = \"'SYS1.test.batch.loadlib'\";\nsysblib = \"'SYS1.test.batch.loadlib'\";\ncvtptr = storage(\"00000010\",4); /* locate llt/smca from cvt */\ncvtsmca = storage(d2x(c2d(cvtptr)+196),4); /* mapping smca */\nsavehi=substr(c2x(cvtsmca),1,2); /* hi order bit is on */\nsmcasid = savehi||d2x(x2d(substr(c2x(cvtsmca),3))+16);\nsmcasid = storage(smcasid,4); /* SMF id */\nselect;\n  when (smcasid=\"SYSA\") then do;\n    queue \"DSN SYSTEM(DSNX)\";\n    queue \"RUN PROGRAM(\"prog\") PLAN(\"plan\") LIBRARY(\"sysalib\")\";\n    queue \"END\";\n         end;\n  when (smcasid=\"SYSB\") then do;\n    queue \"DSN SYSTEM(DSNY)\";\n    queue \"RUN PROGRAM(\"prog\") PLAN(\"plan\") LIBRARY(\"sysblib\")\";\n    queue \"END\";\n         end;\n  otherwise exit 24;\nend;\nexit 0;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "XDSL": {"ttr": 21510, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x03\\x00\\x00\\x00\\x92(\\x7f\\x00\\x92)\\x0f\\x12\\x03\\x00\\x10\\x00\\x04\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf1\\xf0@@@'", "ispf": {"version": "01.03", "flags": 0, "createdate": "1992-10-13T00:00:00", "modifydate": "1992-10-16T12:03:00", "lines": 16, "newlines": 4, "modlines": 0, "user": "TECH110"}, "text": "/* REXX */\nparse upper arg searchfor;\nif searchfor=\"\" then do;\n    \"VMFCLEAR\";\n    say \"XDSL syntax is 'XDSL arg' where\";\n    say \"   arg is appended to the DSName list as follows:\";\n    say \"   search arg is 'SYS%.arg*.**'\";\n    exit 16;\n    end;\n\"CALL 'SYS1.TECH.COMMON.LOADLIB(XDSL)' '\"searchfor\"'\";\nsaverc = rc;\nif saverc\u00ac=0 then do;\n    \"VMFCLEAR\";\n    say \"XDSL failure; return code is:\" saverc;\n    end;\nexit 0;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "XLISTA": {"ttr": 21512, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x04\\x00\\x00\\x00\\x91\\x16_\\x00\\x91\\x16\\x8f\\t7\\x00Q\\x00$\\x00-\\xd1\\xc5\\xc6\\xc6\\xd2@@@@@'", "ispf": {"version": "01.04", "flags": 0, "createdate": "1991-06-14T00:00:00", "modifydate": "1991-06-17T09:37:00", "lines": 81, "newlines": 36, "modlines": 45, "user": "JEFFK"}, "text": "/* REXX LISTALC function */\nparse upper arg opt_ddname;\naddress \"TSO\";\ntrue = \"1\";\nfalse = \"0\";\ndummy = outtrap(\"listalc.\"); /* trap lista output */\n\"LISTALC STATUS\"; /* find dsnames per ddname */\nresponse = \"\";\nddnamelist = \"\";\ndo  i = 2 to listalc.0;\n       response = response strip(listalc.i); /* remove filler */\nend;\ncounter = words(response); /* loop */\ndo i = 1 to counter;\n     element = word(response,i);\n     if element = \"TERMFILE\" then do;\n           ddname = word(response,i+1);\n           ddnamelist = ddnamelist ddname;\n           ddname.ddname = \"TERMFILE\";\n           lastddname = ddname; /* save ddname for concat */\n           i = i + 1; /* skip */\n           end;\n     else if element = \"NULLFILE\" then do;\n           ddname = word(response,i+1);\n           ddnamelist = ddnamelist ddname;\n           ddname.ddname = \"NULLFILE\";\n           lastddname = ddname; /* save ddname for concat */\n           i = i + 1; /* skip */\n           end;\n        else do;\n           dsname = element;\n           if substr(dsname,1,1)=\"*\" then ,\n                 dsname = substr(dsname,2); /* remove notinuse flag*/\n           ddname = word(response,i+1);\n           if substr(ddname,1,4)=\"KEEP\" | substr(ddname,1,6)=\"DELETE\" ,\n               then do;\n                    ddname.lastddname = ddname.lastddname dsname;\n                    i = i + 1;\n               end;\n               else do;\n                    ddnamelist = ddnamelist ddname;\n                    ddname.ddname = dsname;\n                    lastddname = ddname; /* save ddname for concat */\n                    i = i + 2;\n               end;\n        end;\nend;\nddname# = words(ddnamelist); /* sort ddnames found */\ndo i = 1 to ddname#;\n    ddname.i = word(ddnamelist,i);\nend;\nswapped = true;\nif opt_ddname \u00ac=\"\" then swapped=false; /* skip sort for ddname */\ndo while(swapped);\nswapped = false;\ndo i = 1 to ddname#-1;\n   this = i;\n   next = i+1;\n   if ddname.this > ddname.next then do;\n        temp = ddname.next; /* swap */\n        ddname.next = ddname.this;\n        ddname.this = temp;\n        swapped = true;\n        end;\nend;\nend;\n\"VMFCLEAR\";\nif opt_ddname \u00ac= \"\" & wordpos(opt_ddname,ddnamelist)=0 then do;\n     say \"DDNAME\" opt_ddname \"is not currently allocated.\";\n     exit 4;\n     end;\ndo i = 1 to ddname#;\n  trueddn = ddname.i;\n  if opt_ddname \u00ac= \"\" & trueddn\u00ac=opt_ddname then iterate;\n  say left(trueddn,8) word(ddname.trueddn,1);\n  dsncount = words(ddname.trueddn);\n  if dsncount>1 then do j = 2 to dsncount;\n     say \"         \"word(ddname.trueddn,j);\n     end;\nend;\nexit 0;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "XREF": {"ttr": 21515, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01-\\x00\\x00\\x00\\x922_\\x00\\x944\\x9f\\t$\\x00\\x11\\x00'\\x00\\x11\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf7@@@\"", "ispf": {"version": "01.45", "flags": 0, "createdate": "1992-11-20T00:00:00", "modifydate": "1994-12-15T09:24:00", "lines": 17, "newlines": 39, "modlines": 17, "user": "TECH107"}, "text": "PROC 0\nCONTROL NOMSG NOPROMPT NOLIST\nFREE F(OFFLINE ERRORS MASTER FOCEXEC FMU SYSIN FOCLIB FOCSQL PROFILE)\nALLOC F(FOCLIB)  DA('SYSS.FOCUS.V6R8M0.FOCSQL.LOAD') SHR\nALLOC F(FOCSQL)  DA('SYSS.TECH.COMMON.FOCSQL.DATA' -\n                    'SYSS.FOCUS.V6R8M0.FOCSQL.DATA') SHR\nALLOC F(ERRORS)  DA('SYSS.FOCUS.V6R8M0.ERRORS.DATA') SHR\nALLOC F(MASTER)  DA('SYSS.TECH.COMMON.MASTER.DATA' -\n                    'SYSS.FOCUS.V6R8M0.MASTER.DATA') SHR\nALLOC F(FOCEXEC) DA('SYSS.TECH.COMMON.FOCEXEC.DATA') SHR\nALLOC F(PROFILE) DA('SYSS.TECH.COMMON.XREF.PROFILE') SHR\nALLOC F(FMU)     DA('SYSS.TECH.COMMON.FMU.DATA') SHR\nALLOC F(OFFLINE) SYSOUT(G) RECFM(F,B,A) LRECL(161) BLKSIZE(1610) -\n      FCB(GT15)\nCALL 'SYS1.FOCUS.V6R8M0.LOAD(FOCUS)'\nFREE F(OFFLINE ERRORS MASTER FOCEXEC FMU SYSIN FOCLIB FOCSQL PROFILE)\nEXIT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "XREFNEW": {"ttr": 21517, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x93%\\x7f\\x00\\x93%\\x7f\\x10\\x18\\x00O\\x00O\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf7@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1993-09-14T00:00:00", "modifydate": "1993-09-14T10:18:00", "lines": 79, "newlines": 79, "modlines": 0, "user": "TECH107"}, "text": "/* REXX TLMS REPORT MERGE */\nTRUE = \"1\";\nFALSE = \"0\";\nEOF = FALSE;\nDO WHILE(\u00acEOF);\n    \"EXECIO 1 DISKR TLMS016 (STEM TLMS016.\";\n    IF RC\u00ac=0 THEN DO;\n         EOF = TRUE;\n         ITERATE;\n         END;\n    PARSE VALUE STRIP(SUBSTR(TLMS016.1,2)) WITH ,\n       P1 P2 P3 P4 P5 P6 P7 P8 P9 P10 P11 P12 P13 P14 P15 . ;\n    IF VERIFY(P1,\"FPQ\") = 0 THEN DO;\n         DSN = P2;\n         END;\n    ELSE IF VERIFY(P1,\"123456789\") = 0 THEN DO;\n    OFF1RETNTYPE=\"-\";\n    OFF2RETNTYPE=\"-\";\n    OFF1LOCID=\"--\";\n    OFF2LOCID=\"--\";\n    OFF1RETNQTY=\"----\";\n    OFF2RETNQTY=\"----\";\n         RETNTYPE = P1;\n         LOCID = P2;\n         RETNQTY = P3;\n         IF RETNQTY=\"\" & P1\u00ac=\"6\" THEN ,\n               RETNQTY=\"----\";\n         ELSE IF P1=\"6\" THEN DO;\n            RETNQTY=\"----\";\n            OFF1RETNTYPE=P3;\n            OFF2RETNTYPE=P6;\n            OFF1LOCID=P4;\n            OFF2LOCID=P7;\n            OFF1RETNQTY=P5;\n            OFF2RETNQTY=P8;\n    IF VERIFY(P6,\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\") = 0 THEN DO;\n               OFF1RETNQTY=\"----\";\n            OFF2RETNTYPE=P5;\n            OFF2LOCID=P6;\n            OFF2RETNQTY=P7;\n            END;\n            IF OFF2RETNQTY=\"\" THEN ,\n               OFF2RETNQTY=\"----\";\n            END;\nTLMSOUT.1=LEFT(DSN,44)\"A\"LEFT(LOCID,2)LEFT(RETNTYPE,1)|| ,\n             LEFT(RETNQTY,4)|| ,\n             LEFT(OFF1LOCID,2)LEFT(OFF1RETNTYPE,1)|| ,\n             LEFT(OFF1RETNQTY,4)|| ,\n             LEFT(OFF2LOCID,2)LEFT(OFF2RETNTYPE,1)|| ,\n             LEFT(OFF2RETNQTY,4);\n         \"EXECIO 1 DISKW TLMSOUT (STEM TLMSOUT.\";\n         END;\n    ELSE IF P1 = \"**DEFAULT**\" THEN DO;\n         DSN = P1;\n         END;\nEND;\nEOF = FALSE;\nDO WHILE(\u00acEOF);\n    \"EXECIO 1 DISKR EARLOUT (STEM EARLOUT.\";\n    IF RC\u00ac=0 THEN DO;\n         EOF = TRUE;\n         ITERATE;\n         END;\n    TEST1 = (SUBSTR(EARLOUT.1,2,5));\n    SELECT;\n       WHEN TEST1 = '     ' THEN;\n            ITERATE;\n       WHEN TEST1 = 'Compu' | ,\n            TEST1 = 'CA-EA' | ,\n            TEST1 = 'Optio' THEN;\n            ITERATE;\n    OTHERWISE END;\n    TLMSOUT.1 = (SUBSTR(EARLOUT.1,2,73));\n    \"EXECIO 1 DISKW TLMSOUT (STEM TLMSOUT.\";\nEND;\n\"EXECIO 0 DISKR TLMS016 (FINIS\";\n\"EXECIO 0 DISKR TLMSOUT (FINIS\";\n\"EXECIO 0 DISKR EARLOUT (FINIS\";\nEXIT 0;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "XREFOLD": {"ttr": 21520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x944\\x9f\\x00\\x944\\x9f\\t$\\x00`\\x00`\\x00\\x00\\xe3\\xc5\\xc3\\xc8\\xf1\\xf0\\xf7@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-12-15T00:00:00", "modifydate": "1994-12-15T09:24:00", "lines": 96, "newlines": 96, "modlines": 0, "user": "TECH107"}, "text": "/* REXX Production XREF            */\nCALL DSQCIX \"START (DSQSMODE=INTERACTIVE DSQSSUBS=DSNA\";\nif dsq_return_code \u00ac=0 then do;\n    \"VMFCLEAR\";\n    say dsq_message_id dsq_message_text;\n    say dsq_q_message_id dsq_q_message_text;\n    signal term;\n    end;\ndo forever;\n\"VMFCLEAR\";\naddress \"ISPEXEC\" \"DISPLAY PANEL(PXREF)\";\nif rc\u00ac=0 then signal term;\njobname=strip(job); procname=strip(proc);\nprogram=strip(prog); dsname=strip(dsn); member=strip(mem);\naccess=strip(acc);\norder = \"\";\nwhere1=\"\";\nwhere2=\"\";\nwhere3=\"\";\nwhere4=\"\";\nwhere5=\"\";\nwhere6=\"\";\nif jobname\u00ac=\"\" then do;\n    where1=\"JOB_NAME LIKE '\"jobname\"%'\";\n    order=\"(JOB_NAME,STEP_WITHIN_JOB,DATASET_NAME)\";\n    end;\nif procname\u00ac=\"\" then do;\n    if where1=\"\" then do;\n       where2=\"PROC_NAME LIKE '\"procname\"%'\";\n       order=\"(PROC_NAME,JOB_NAME,STEP_WITHIN_JOB,DATASET_NAME)\";\n     end;\n    else ,\n       where2=\" AND PROC_NAME LIKE '\"procname\"%'\";\n    end;\nif program\u00ac=\"\" then do;\n    if where1=\"\" & where2=\"\" then do;\n       where3=\"EXEC_PGM LIKE '\"program\"%'\";\n       order=\"(EXEC_PGM,JOB_NAME,STEP_WITHIN_JOB,DATASET_NAME)\";\n     end;\n    else ,\n       where3=\" AND EXEC_PGM LIKE '\"program\"%'\";\n    end;\nif dsname\u00ac=\"\" then do;\n    if where1=\"\" & where2=\"\" & where3=\"\" then do;\n       where4=\"DATASET_NAME LIKE '\"dsname\"%'\";\n       order=\"(DATASET_NAME,JOB_NAME,STEP_WITHIN_JOB)\";\n     end;\n    else ,\n       where4=\" AND DATASET_NAME LIKE '\"dsname\"%'\";\n    end;\nif member\u00ac=\"\" then do;\n    if where1=\"\" & where2=\"\" & where3=\"\" & where4=\"\" then ,\n       where5=\"MEMBER LIKE '\"member\"%'\";\n    else ,\n       where5=\" AND MEMBER LIKE '\"member\"%'\";\n    end;\nif access\u00ac=\"\" then do;\n    if where1=\"\" & where2=\"\" & where3=\"\" & where4=\"\" & where5=\"\" then ,\n       where6=\"ACCESS LIKE '\"access\"%'\";\n    else ,\n       where6=\" AND ACCESS LIKE '\"access\"%'\";\n    end;\nif order=\"\" then ,\n    order=\"(JOB_NAME,STEP_WITHIN_JOB,DATASET_NAME)\";\nif where1=\"\" & where2=\"\" & where3=\"\" & where4=\"\" & where5=\"\" & ,\n   where6=\"\" then ,\n   do;\n    \"VMFCLEAR\";\n    say \"You DID NOT enter a selection criteria\";\n    iterate;\n    end;\nwhere1=\"(\"where1\")\";\nwhere2=\"(\"where2\")\";\nwhere3=\"(\"where3\")\";\nwhere4=\"(\"where4\")\";\nwhere5=\"(\"where5\")\";\nwhere6=\"(\"where6\")\";\n\"VMFCLEAR\";\nCALL DSQCIX \"RUN QUERY TECH110.QXREF (FORM TECH110.FXREF \"|| ,\n                             \"&WHERE1=\"where1\",\" || ,\n                             \"&WHERE2=\"where2\",\" || ,\n                             \"&WHERE3=\"where3\",\" || ,\n                             \"&WHERE4=\"where4\",\" || ,\n                             \"&WHERE5=\"where5\",\" || ,\n                             \"&WHERE6=\"where6\",\" || ,\n                             \"&ORDER=\"order;\nif dsq_return_code \u00ac=0 then do;\n    \"VMFCLEAR\";\n    say dsq_message_id dsq_message_text;\n    say dsq_q_message_id dsq_q_message_text;\n    signal term;\n    end;\nend;\nterm:\nCALL DSQCIX \"EXIT\";\nEXIT 0;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ZEKESCAN": {"ttr": 21523, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x16\\x00\\x00\\x00\\x93\\t/\\x00\\x936/\\x11\\t\\x00T\\x00C\\x00Q\\xe3\\xc5\\xc3\\xc8\\xf1\\xf1\\xf0@@@'", "ispf": {"version": "01.22", "flags": 0, "createdate": "1993-04-02T00:00:00", "modifydate": "1993-12-28T11:09:00", "lines": 84, "newlines": 67, "modlines": 81, "user": "TECH110"}, "text": "/* REXX PRODXREF ZEKE MERGE EXEC */\nTRUE=\"1\";\nFALSE=\"0\";\nEOF=FALSE;\nBLANK=COPIES(\" \",116);\n\"EXECIO * DISKR ZEKEIN (STEM ZEKEIN. FINIS\";\nDO K=1 TO ZEKEIN.0;\n     TEMP = ZEKEIN.K;\n     SELECT;\n       WHEN (SUBSTR(TEMP,2,4)=\"ZEKE\") THEN NOP;\n       WHEN (SUBSTR(TEMP,2,6)=\"REPORT\") THEN NOP;\n       WHEN (SUBSTR(TEMP,2,4)=\"EVNT\") THEN NOP;\n       WHEN (SUBSTR(TEMP,2,4)=\"TYPE\") THEN NOP;\n       WHEN (SUBSTR(TEMP,2,3)=\"JOB\") THEN DO;\n           JOBNAME=SUBSTR(TEMP,8,8);\n           END;\n       WHEN (SUBSTR(TEMP,12,6)=\"OCCURS\") THEN DO;\n           OCLAUSE=STRIP(SUBSTR(TEMP,19));\n           CONT=TRUE;\n           DO WHILE(CONT);\n                K=K+1; /* NEXT FOR CONTINUATION */\n                IF SUBSTR(ZEKEIN.K,20,4)=\"AND \" | ,\n                   SUBSTR(ZEKEIN.K,20,3)=\"OR \" THEN ,\n                     OCLAUSE=OCLAUSE STRIP(SUBSTR(ZEKEIN.K,20));\n                 ELSE DO;\n                   CONT=FALSE;\n                   K=K-1;\n                   END;\n           END; /* DO WHILE */\n           END; /* OCCURS */\n       WHEN (SUBSTR(TEMP,13,4)=\"WHEN\") THEN DO;\n           WCLAUSE=STRIP(SUBSTR(TEMP,19));\n           CONT=TRUE;\n           DO WHILE(CONT);\n                K=K+1; /* NEXT FOR CONTINUATION */\n                IF SUBSTR(ZEKEIN.K,20,4)=\"AND \" | ,\n                   SUBSTR(ZEKEIN.K,20,3)=\"OR \" | ,\n                   SUBSTR(ZEKEIN.K,2,18)=\" \" THEN ,\n                     WCLAUSE=WCLAUSE STRIP(SUBSTR(ZEKEIN.K,20));\n                 ELSE DO;\n                   CONT=FALSE;\n                   K=K-1;\n                   OCLAUSE=LEFT(\"*ZEKE* OCCURS \"OCLAUSE,44);\n                   ZEKEOUT.1=BLANK;\n                   ZEKEOUT.1 = ,\n                      OVERLAY(JOBNAME,ZEKEOUT.1,1,8);\n                   ZEKEOUT.1 = ,\n                      OVERLAY(OCLAUSE,ZEKEOUT.1,56,44);\n                   \"EXECIO 1 DISKW ZEKEOUT (STEM ZEKEOUT.\";\n                   WCLAUSE=SPACE(TRANSLATE(WCLAUSE,\"  \",\"()\"));\n                   Z=WORDS(WCLAUSE);\n                   DO M=1 TO Z;\n                       WW=WORD(WCLAUSE,M);\n                       SELECT;\n                          WHEN (WW=\"AEOJ\" | WW=\"AEOP\" | WW=\"AEOS\" | ,\n                                WW=\"BOJ\" | WW=\"BOP\" | WW=\"EOJ\" | ,\n                                WW=\"EOE\" | ,\n                                WW=\"EOP\" | WW=\"EOS\" | WW=\"WEOJ\" | ,\n                                WW=\"NOTDURING\") THEN DO;\n                                  TARGJOB=WORD(WCLAUSE,M+1);\n                                  M=M+2;\n                                  IF WW=\"NOTDURING\" THEN DO;\n                                     TARGJOB=TARGJOB WORD(WCLAUSE,M);\n                                     M=M+1;\n                                     END;\n                                  ZEKEOUT.1=BLANK;\n                  TCLAUSE=LEFT(\"*ZEKE* WHEN \"WW TARGJOB,44);\n                                  ZEKEOUT.1 = ,\n                                    OVERLAY(JOBNAME,ZEKEOUT.1,1,8);\n                                  ZEKEOUT.1 = ,\n                                    OVERLAY(TCLAUSE,ZEKEOUT.1,56,44);\n                               \"EXECIO 1 DISKW ZEKEOUT (STEM ZEKEOUT.\";\n                                END;\n                          OTHERWISE NOP;\n                       END;\n                   END;\n           END;\n           END;\n           END;\n       OTHERWISE NOP;\n     END; /* OUTER SELECT */\nEND K;\n\"EXECIO 0 DISKW ZEKOUT (FINIS\";\nEXIT 0;\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT253/FILE253.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT253", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}