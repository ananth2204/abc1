{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220011511000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 117572, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 6, "INMDSNAM": "CBT.V500.FILE209.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 117572, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 117572, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE209.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x03\\x05'", "DS1TRBAL": "b'\\x91\\x90'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x01\\x8f\\x00\\x0c\\x01\\x90\\x00\\x00\\x00\\x04'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$DOC": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x03/\\x00\\x94\\x03/\\x13\\x07\\x00\\x19\\x00\\x19\\x00\\x00\\xe5\\xc7\\xc3\\xc1\\xd9\\xe3@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-02-01T00:00:00", "modifydate": "1994-02-01T13:07:00", "lines": 25, "newlines": 25, "modlines": 0, "user": "VGCART"}, "text": "      CALCR - Hexadecimal and Decimal Semi-Programmable Calculator\n                  and Storage Display, written in REXX.\n\nThis is a REXX exec which can run on the MVS, VM, PC-DOS, and OS2\nplatforms.\n\nTo start using this calculator type HELP.\n\nTo get more information, type HELP FUNCTION.  Then do your stuff.\n\nThis code has some subtle \"ins and outs\" that you'll discover if\nyou use it a lot, and/or look at it in detail.\n\nDisclaimer:\n  This code has worked at SunGard.  There is no guarantee that the\n  code will work anywhere else.  Neither SunGard nor the author may\n  be held responsible for any damage caused by this code.\n\nAuthor:\n            Art Tansky\n            SunGard\n            600 Laurel Oak Road\n            Voorhees, New Jersey 08043\n            (609) 566-3611\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "CALCR": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x00\\x94\\x03/\\x00\\x94\\x03/\\x12$\\x03\\r\\x03\\r\\x00\\x00\\xe5\\xc7\\xc3\\xc1\\xd9\\xe3@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "1994-02-01T00:00:00", "modifydate": "1994-02-01T12:24:00", "lines": 781, "newlines": 781, "modlines": 0, "user": "VGCART"}, "text": "/*  REXX calculator and storage dumper.  Read the disclaimer at end.*/\n   NUMERIC DIGITS 30\n   arg !!temp1\n   call INITIALIZE\n   interpret \"trace\" result\n   signal on error\n   if address() = 'TSO' | address() = 'MVS' then signal on failure\n   signal on syntax\nREADY:\n   SAY 'Ready for commands.  Use \"EXIT\" to exit. Use \"HELP\" for help.'\n   DO UNTIL !!curr1 = 'EXIT'\n     pull !!curr1\n     if !!back then do\n       say\n       say  !!curr1\n       say\n     end\n     PARSE VAR !!curr1 !!do !!rest\n     SELECT\n       WHEN !!do = 'LET' THEN\n         call WHENLET\n       WHEN !!do = 'SAY' | !!do = 'DO' THEN\n         INTERPRET !!curr1\n       WHEN !!do = 'REXX' then\n         INTERPRET !!rest\n       WHEN !!curr1 = 'EXIT' THEN\n         iterate\n       WHEN !!curr1 = 'END' THEN\n         !!curr1= 'EXIT'\n       WHEN !!curr1 = '' THEN\n         if !!back then !!curr1 = 'EXIT'\n       WHEN !!do = 'DELETE' then\n         call WHENDELETE\n       WHEN !!curr1 = 'SORT' then\n         call WHENSORT\n       WHEN !!curr1 = 'VARTABLE' then\n         call WHENVARTABLE\n       WHEN !!do = 'DUMP' then\n         call WHENDUMP\n       WHEN !!do = 'TIMESTAMP' then\n         call WHENTIME\n       WHEN !!do = 'HELP' THEN\n         CALL WHENHELP\n       WHEN !!do = 'VERBOSE' THEN\n         CALL WHENVERBOSE\n       WHEN !!curr1 = \"NEG\" THEN\n         do\n           !!neg = !!true\n          say \"Hex display of negative values will be in 2's complement\"\n         end\n       WHEN !!curr1 = \"POS\" THEN\n         do\n           !!neg = \\!!true\n           say \"Hex display will be absolute value of decimal number\"\n         end\n       WHEN !!curr1 = \"TRACE\" THEN\n         TRACE ?i\n       WHEN !!do = 'TRACE' THEN\n         INTERPRET !!curr1\n       OTHERWISE\n         call WHENOTHERWISE\n     END   /* of SELECT */\n   END /* of main loop */\n   EXIT 0\nWHENOTHERWISE:\n   interpret \"!!!CURR = \" !!curr1\n   if datatype(!!!curr,'N') then\n     do\n       curr = !!!curr/1\n       !!!curr=HEXFMT(curr)\n     end\n   if length(!!!curr) > 78 then !!dunder = \">\"\n   else !!dunder = \"\"\n   !!!curr = left(!!!curr,78) || !!dunder\n   if !!!curr \\= ' ' then say !!!curr\n   return 0\nHEXFMT:\n   procedure expose !!max !!min !!minfrac !!hexmax !!neg !!verbose\n   curr = arg(1)\n   if abs(curr) <= !!hexmax then\n     do\n       temp = trunc(curr)\n       temp = abs(temp)\n       if !!neg & curr<0 then temp = d2x(!!hexmax + 1 - temp)\n       else temp = D2X(temp)\n       tempx = RIGHT(temp,16,'0')\n       tempx = insert(' ',tempx,8)\n     end\n   else\n     tempx = copies(' ',17)\n   return TEMPX comma(CURR)\nCOMMA: /* put commas into number and format it correctly */\n   procedure expose !!max !!min  !!minfrac !!verbose\n   curr = arg(1)\n   select\n     when abs(curr) < !!minfrac & curr \\= 0 then\n       return format(curr,,,,16)\n     when curr > !!max then\n       return ' ' || format(curr,,29,,20)\n     when curr < -1*!!max/10 then  /* neg numbers have xtra char */\n       return format(curr,,29,,19)\n     when abs(curr) < !!min then\n       return format(curr,,29,,20)\n     otherwise\n       nop\n   end /* of select */\n   int = trunc(curr)\n   fraction = curr - int\n   if int = '' then int = 0\n   int = format(int,20)\n   /*  17 = 20-3  */\n   do i = 17 to 1 by -3 while datatype(substr(int,i,1),'N')\n     int = insert(',',int,i)\n   end\n   int = right(int,26) /* 26 = 20 + int(20-1/3) */\n   select\n     when fraction = '' then nop\n     when fraction = 0 then fraction = ''\n     otherwise nop\n   end   /* of select */\n   if length(fraction) > 0 then do\n     parse var fraction . '.' fraction\n     fraction = '.'fraction\n   end /* of IF */\n   if int = 0 then\n     if curr < 0 then int = right('-0',26)\n   ret = int || fraction\n   return ret\nH:\nX:\n   PROCEDURE EXPOSE !!verbose\n   ARG TEMP\n   RETURN X2D(TEMP)\nS:            /* signed hex number */\n   PROCEDURE EXPOSE !!verbose\n   arg temp\n   neg = verify(left(temp,1),'89ABCDEFabcdef')\n   if neg = 0 then do\n     len = length(temp)\n     two = 1 || copies('0',len) /* 2**n greater than temp */\n     two = x2d(two)\n     return -1*(two-x2d(temp))\n   end\n   else return x2d(temp)\nB:  /* binary numbers */\n   procedure expose !!verbose\n   arg temp\n   temp = strip(temp)\n   temp = strip(temp,'L','0')\n   if verify(temp,'01 ') > 0 then do\n     say 'Binary numbers are made up of zeros and ones'\n     return 0\n   end\n   power = 1\n   value = 0\n   do i = length(temp) to 1 by -1\n     temp2 = substr(temp,i,1)\n     if temp2 = 1 then\n       value = value + power\n     if temp2 \\= ' ' then\n       power = power * 2\n   end\n   return value\nWHENLET:\n   INTERPRET !!rest\n   parse var !!rest !!variable '=' !!rest\n   if !!rest \\= '' then do /* if '=' in command */\n     !!variable = strip(!!variable)\n     if symbol(!!variable) = 'VAR' then do\n       if datatype(value(!!variable),'N') then do\n         curr = value(!!variable)\n         curr = curr / 1\n         result = hexfmt(curr)\n         if length(result) > 78 then !!dunder = \">\"\n         else !!dunder = \"\"\n         say left(result,78) || !!dunder\n       end /* of if datatype ... */\n       !!temp = !!vartble.!!variable\n       if !!temp = 0 then do\n         !!varnum = !!varnum + 1\n         !!vartble.!!varnum = !!variable\n         !!vartble.!!variable = !!varnum\n       end /* of if !!temp ... */\n     end /* of if symbol ... */\n   end /* of if !!rest ... */\n   return 0\nWHENVARTABLE:\n   do !!x = 1 to !!varnum\n     if !!vartble.!!x = !!deleted then iterate\n     !!curr = value(!!vartble.!!x)\n     if datatype(!!curr,'N') then do\n       result=left(hexfmt(!!curr),54)\n       say result !!vartble.!!x\n     end\n     else do\n       say left(!!curr,54) !!vartble.!!x\n     end\n   end\n   return 0\nWHENDUMP:\n   parse var !!rest !!address !!len\n   interpret '!!address =' !!address\n   !!address = value(!!address)\n   if length(!!len) > 0 then do\n     interpret '!!len = ' !!len\n     !!len = value(!!len)\n   end\n   call dump !!address !!len\n   return 0\nWHENSORT:\n   do !!i = 1 to !!varnum-1\n     do !!j = !!i+1 to !!varnum\n       if !!vartble.!!i > !!vartble.!!j then do\n         !!x = !!vartble.!!i\n         !!vartble.!!i = !!vartble.!!j\n         !!vartble.!!j = !!x\n       end /* of IF */\n     end /* of do !!j */\n     !!y = !!vartble.!!i\n     !!vartble.!!y = !!i\n   end /* of !!i */\n   do !!i = !!varnum to 1 by -1 while !!vartble.!!i = !!deleted\n   end\n   !!varnum = !!i\n   !!y = !!vartble.!!i\n   !!vartble.!!y = !!i\n   return 0\nWHENDELETE:\n   !!var1 = strip(!!rest)\n   DO WHILE !!var1 \\= ''\n     parse var !!var1 !!variable !!var1\n     !!temp = !!vartble.!!variable\n     if !!temp = 0 then do\n       say 'Variable \"'!!variable'\" is not in the table'\n     end\n     else do\n       !!vartble.!!temp = !!deleted\n       !!vartble.!!variable = 0\n       interpret 'drop' !!variable\n     end\n   end /* of DO WHILE */\n   return 0\nWHENTIME:\n   parse var !!rest !!stamp !!gmt !!dec\n   interpret '!!stamp =' !!stamp\n   if !!gmt = '' then !!gmt = 'GMT'\n   if !!dec = '' then !!dec = 'DECIMAL'\n   call 'IEBTIM' !!stamp ' ' !!gmt ' ' !!dec\n   return\nFRAC:\n   PROCEDURE EXPOSE !!verbose\n   ARG curr\n   temp = curr-trunc(curr)\n   temp = temp / 1\n   return temp\nDUMP2:   /*  display dump format of up to 16 bytes of storage  */\n   PROCEDURE EXPOSE !!verbose\n   parse arg address len\n   if len = '' then len = 16\n   address = d2x(address)\n   temp = storage(address,len)\n   temp2 = left(c2x(temp),32)\n   temp2 = insert(' ',temp2,24)\n   temp2 = insert('  ',temp2,16)\n   temp2 = insert(' ',temp2,8)\n   temp = \"|\" left(temp,16) \"|\" temp2 \"|\"\n   TEMP = RIGHT(address,8,'0') \"   \" temp\n   return temp\nDUMP:   /*  display dump format of storage  */\n   PROCEDURE EXPOSE !!verbose\n   parse arg address len\n   if len = '' then len = 16\n   lastgroup = address + len - 16\n   do i= address by 16 while i <= lastgroup\n     say dump2(i)\n   end\n   len = len//16\n   if len > 0 then say dump2(i len)\n   return 0\nSTG:   /*  return dec value of storage  */\n   PROCEDURE EXPOSE !!verbose\n   parse arg address len\n   if len = '' then len = 4\n   address = d2x(address)\n   temp = storage(address,len)\n   temp = c2d(temp)\n   return temp\nBIN16:  /*  return printable form of a number converted to binary */\nBIT16:  /*  return printable form of a number converted to binary */\n   PROCEDURE EXPOSE !!verbose !!hexmax !!neg\n   i=arg(1)\n   j = bin(i,16)\n   return j\nBIN:   /*  say printable form of a number converted to binary */\n   PROCEDURE EXPOSE !!verbose !!hexmax !!neg\n   a = trunc(arg(1))\n   if !!neg & a<0 then a = d2x(!!hexmax + 1 + a)\n   else a = D2X(abs(a))\n   b = arg(2)\n   if b = '' then b = 0\n   b = min(b,16)\n   if b > length(a) then a = right(a,b,0)\n   if length(a) > 16 then\n     do\n       say 'truncated to rightmost 16 hex digits'\n       a = right(a,16,0)\n     end\n   if length(a)//2 \\=0 then a = '0' || a\n   b = ' '\n   do i = 0 to length(a)/2\n     do j = 1 to 2\n       b = b || '  ' || substr(a,2*i+j,1) || ' '\n     end /* do j */\n     b = b || ' '\n     if i = 3 then b = b || '   '\n   end\n   say left(b,79)\n   x=!!bit(a)\n   if datatype(x,'N') then\n     do\n       say x\n       return ' '\n     end\n   else\n     return !!bit(a)\n!!BIT:  /*  return printable form of a number converted to binary */\n   PROCEDURE EXPOSE !!verbose\n   a = arg(1)\n   lena = min(length(a),16)\n   if lena//2 \\= 0 then do\n     lena = lena + 1\n     a = '0' || a\n   end\n   bin! = ''\n   do i = 1 to 9 by 8\n     do j = i to i+6 by 2 while j < lena\n       digit = substr(a,j,2)\n       do k = 7 to 0 by -1\n         if and1(2**k,x2d(digit)) = 0 then bin! = bin! || 0\n         else bin! = bin! || 1\n       end /* of do k */\n       bin! = bin! || ' '\n     end  /* of do j */\n     bin! = bin! || '   '\n   end  /* of do i */\n   return bin!\nOR:     /*  return 2 values logically ORed together */\n   PROCEDURE EXPOSE !!verbose\n   i = right(d2c(arg(1)),16,'0'x)\n   j = right(d2c(arg(2)),16,'0'x)\n   k = bitor(i,j,'0'x)\n   return c2d(k)\nXOR:    /*  return 2 values logically XORed together */\n   PROCEDURE EXPOSE !!verbose\n   i = right(d2c(arg(1)),16,'0'x)\n   j = right(d2c(arg(2)),16,'0'x)\n   k = bitxor(i,j,'0'x)\n   return c2d(k)\nAND:    /*  return 2 values logically ANDed together */\n   PROCEDURE EXPOSE !!verbose\n   i = right(d2c(arg(1)),16,'0'x)\n   j = right(d2c(arg(2)),16,'0'x)\n   k = bitand(i,j,'0'x)\n   return c2d(k)\nNOT:    /*  return one's complement of a number */\n   PROCEDURE EXPOSE !!verbose\n   i = arg(1)\n   j = x2d(copies('F',16))\n   k = xor(i,j)\n   return k\nAND1:    /*  return 2 1-digit values logically ANDed together */\n   PROCEDURE EXPOSE !!verbose\n   i = right(d2c(arg(1)),1)\n   j = right(d2c(arg(2)),1)\n   k = bitand(i,j,'0'x)\n   return c2d(k)\nC:  /* Combination function */\n   PROCEDURE expose !!!. !!verbose\n   first = arg(1)\n   second = arg(2)\n   if \\datatype(first,'W') | \\datatype(second,'W') then\n     return 'Combination function requires whole numbers'\n   if first < second then\n     return 'First argument must be no less than the second'\n   return format(!(first)/( !(second) * !(first-second) ),,0)\n!:  /* Factorial */\n   PROCEDURE expose !!!. !!verbose\n   NUMBER = ARG(1)\n   select\n     when datatype(!!!.number,'N') then\n       nop\n     when \\datatype(number,'W') | number < 0 then\n       !!!.number = ,\n           'Factorial function requires non-negative whole numbers.'\n     otherwise\n       nop\n   end /* of select */\n   if !!!.number \\= '!!!.'number then return !!!.number\n   if number > 40 then\n     do\n       nminus40 = number - 40\n       !!!.nminus40 = !(nminus40)\n     end\n   nminus1 = number - 1\n   !!!.number = number * !(nminus1)\n   return !!!.number\n   /*  The structure of \"!\" is this so that the restriction of 250\n       levels of nesting will allow maximum factorial computation. */\nCLOCK:\nFROMHMS:\n   PROCEDURE EXPOSE !!verbose\n   tod = ARG(1)\n   parse var tod hh '.' mm '.' ss\n   if ss = '' then do\n     ss = mm\n     mm = hh\n     hh = 0\n   end\n   if ss = '' then do\n     ss = mm\n     mm = 0\n   end\n   if ss > 59 | mm > 59 then\n     say 'value greater than 59 in minutes or seconds - possible error'\n   return ss + (60* (mm + 60*hh))\nUNCLOCK:\nTOHMS:\n   PROCEDURE EXPOSE !!verbose\n   tod = ARG(1)\n   hh = tod % (60*60)\n   tod = tod - hh*60*60\n   mm = tod % 60\n   ss = tod - mm*60\n   if hh < 10 then hcolon = \"0\"\n   else hcolon = \"\"\n   if mm < 10 then mcolon = \".0\"\n   else mcolon = \".\"\n   if ss < 10 then scolon = \".0\"\n   else scolon = \".\"\n   return  hcolon || hh || mcolon || mm || scolon || ss\nWHENVERBOSE:\n   PROCEDURE EXPOSE !!rest !!verbose !!false !!true\n   push !!rest\n   pull rest  /* now in upper case */\n   if abbrev('OFF',rest,1) then\n     do\n       !!verbose = !!false\n       say 'VERBOSE error messages are off.'\n     end\n   else\n     do\n       !!verbose = !!true\n       say 'VERBOSE error messages are on.'\n     end\n   return\nWHENHELP:\n   PROCEDURE EXPOSE CURR !!rest !!verbose !!endcomment\n   push !!rest\n   pull rest  /* now in upper case */\n   select\n     when abbrev('FUNCTIONS',rest,1) then\n       call helpfunc\n     when abbrev('TIME',rest,1) | abbrev('CLOCK',rest,1) then\n       call helptime\n     when abbrev('DUMP',rest,1) | abbrev(\"STORAGE\",rest,1) ,\n          | rest=\"STG\" then\n       call helpdump\n     when abbrev('REXX',rest,1) | abbrev('LOOP',rest,1) | rest='DO' then\n       call helprexx\n     when abbrev('TABLE',rest,1) then\n       call helptable\n     when abbrev('NUMBERS',rest,1) then\n       call helpnumber\n     otherwise\n       call helpgenl\n   end /* of select */\n   return\nSAYHELP:\n   do !!!i = sigl + 2\n     if sourceline(!!!i) = !!endcomment then leave !!!i\n     say strip(sourceline(!!!i),\"T\")\n   end\n   return\nHELPGENL:\n   call sayhelp\n/*\n    This is a decimal and hexadecimal calculator.  You can type in a\nnumber or an expression, and the result will be displayed in both\ndecimal and hex.  Positive hex numbers are typed as either \"H(nnnnn)\" or\n\"X(nnnnn)\".  Signed hex numbers are typed as \"S(nnnnn)\".  The value\ndisplayed is always in the variable \"CURR\".  All values are kept in\ndecimal for internal use.  The hex value displayed for each is\nre-computed each time from the integer part of the actual value (note:\ninteger part, not rounded).\n    Values can be displayed in binary by either of BIN(var-name) or\nBIN16(var-name).  BIN is a variable length display, and BIN16 is fixed\nlength.\n    You can set variables by using the keyword \"LET\" as in:  \"LET A =\nCURR + 5\" which would set \"A\" to 5 more than the currently displayed\nvalue.\n    You can turn on extra information in case of error with the VERBOSE\ncommand and turn it back off with \"VERBOSE OFF\".\n    For further help enter HELP with an operand of:\nFUNCTIONS, CLOCK, DUMP, NUMBERS, TABLE, or REXX.\n\n    You exit this facility by typing \"END\" or \"EXIT\".\n*/\n    return\nHELPFUNC:\nsay 'Here is how to get help for commands and functions you can use: '\nsay ' '\n  temp = left('Function   Help operand ',25)\n  say temp || '  ' || temp || '  ' || temp\n  say ' '\n  queue '!           NUMBERS '\n  queue 'AND         NUMBERS '\n  queue 'B           NUMBERS '\n  queue 'BIN         NUMBERS '\n  queue 'BIN16       NUMBERS '\n  queue 'C           NUMBERS '\n  queue 'DELETE      TABLE '\n  queue 'DO          REXX '\n  queue 'DUMP        DUMP '\n  queue 'END         (none) '\n  queue 'EXIT        (none) '\n  queue 'FACTORIAL   NUMBERS '\n  queue 'FRAC        NUMBERS '\n  queue 'FROMHMS     CLOCK '\n  queue 'H           NUMBERS '\n  queue 'LET         (none) '\n  queue 'NEG         NUMBERS '\n  queue 'NOT         NUMBERS '\n  queue 'OR          NUMBERS '\n  queue 'POS         NUMBERS '\n  queue 'REXX        REXX '\n  queue 'S           NUMBERS '\n  queue 'SAY         REXX '\n  queue 'SORT        TABLE '\n  queue 'STG         DUMP '\n  queue 'TIMESTAMP   CLOCK '\n  queue 'TOHMS       CLOCK '\n  queue 'TRACE       REXX '\n  queue 'TRUNC       NUMBERS '\n  queue 'VARTABLE    TABLE '\n  queue 'VERBOSE     (none) '\n  queue 'X           NUMBERS '\n  queue 'XOR         NUMBERS '\n  queue ' '  /* this space before the null is important */\n  queue ''\n  do i = 1\n    parse pull msg.i\n    if msg.i == '' then leave i\n    msg.i = left(msg.i,25)\n  end\n  max=i - i//3   /* max is greatest multiple of 3 <= i */\n  long = max/3\n  do i = 1 to long\n    j = i + long\n    k = j + long\n    say msg.i || '  ' || msg.j || '  ' || msg.k\n  end\nsay ' '\nsay '    You exit this facility by typing \"END\" or \"EXIT\". '\n    return\nHELPTABLE:\n   call sayhelp\n/*\n   You can list all variables you have set with the VARTABLE command,\nsort the variable names alphabetically with the SORT command, and delete\nvariables with \"DELETE var-names\".\n*/\n    return\nHELPNUMBER:\n   call sayhelp\n/*\n    This is a decimal and hexadecimal calculator.  You can type in a\nnumber or an expression, and the result will be displayed in both\ndecimal and hex.  Positive hex numbers are typed as \"H(nnnnn)\".  Signed\nhex numbers are typed as \"S(nnnnn)\".  Binary numbers are typed as\n\"B(nnnnn)\"; nnnnn is made up of zeros and ones, and blanks are ignored.\nThe value displayed is always in the variable \"CURR\".  All values are\nkept in decimal for internal use.  The hex value displayed for each is\nre-computed each time from the integer part of the actual value (note:\ninteger part, not rounded).\n    Values can be displayed in binary by either of BIN(var-name) or\nBIN16(var-name).  BIN is a variable length display, and BIN16 is fixed\nlength.\n    You can do logical bit operations on numbers with AND, OR, NOT, and\nXOR. An example of the syntax is \"AND(5,6)\" which will yield 4.\n    FRAC will return the fractional part of a value, while TRUNC will\nreturn the integer part.\n    \"!(n)\" will return n factorial and \"C(m,n)\" will return\ncombination(m,n) which is also known as \"m choose n\" and is the number\nof ways of picking a subset of n objects from m objects.  These are used\nin probability and statistics.\n    NEG will cause negative hex values to print in 2's complement, until\nyou use POS to print the absolute value of hex numbers.\n*/\n   return\nHELPREXX:\n   call sayhelp\n/*\n   You can perform any valid REXX command by prefixing the command with\n\"REXX\".  SAY, DO and TRACE are also recognized without having to prefix\nthe command with \"REXX\".  (Note: TRACE with no operands will be\ninterpreted as TRACE ?I).\n   There is a primitive looping capability in that you can start any\ncommand with \"DO\" and it will also be interpreted as a REXX command.\nYou could print the cubes of 1-12 with the command\n     \"do i = 1 to 12; queue i**3; end\"\n   The semicolon is a REXX command seperator and must be used if you are\nentering multiple REXX commands on one line.\n*/\n   return\nHELPTIME:\n   call sayhelp\n/*\n     You can print a number of seconds as HH.MM.SS with the function\nTOHMS(number). You can convert from HH.MM.SS to a decimal number of\nseconds with FROMHMS(HH.MM.SS). If there is only one period, FROMHMS\nassumes you are entering MM.SS; with no periods it assumes SS only.\nThese functions are useful for clock arithmetic.\n\n     TOHMS(FROMHMS(05.04.03)-FROMHMS(4.5.6) will yield 00.58.57 showing\n58 minutes and 57 seconds between 04:05:06 and 05:04:03.\n\n     TIMESTAMP will call the external routine IEBTIM which displays a\ntimestamp (such as is used in VSAM) in date and time format.  IEBTIM\nassumes that the number coming in is HEX unless otherwise specified;\nTIMESTAMP will otherwise specify for you unless you use other operands.\nSYNTAX:\n     TIMESTAMP value    GMT | gmtval     HEX\n       value is any value.  If it is a hex value, you must code both GMT\n       or gmtval and HEX (these are positional operands).  GMT (default)\n       will only work on MVS.  It tells IEBTIM to check the systems GMT\n       offset and compute based upon that.  Otherwise you can put the\n       GMT offset value in.\n     EXAMPLES:\nTIMESTAMP A401CA8B80240000 gmt hex     TIMESTAMP 11817949597696000000\nTIMESTAMP A401CA8B80240000 0   hex     TIMESTAMP 11817949597696000000  0\n*/\n   return\nHELPDUMP:\n   call sayhelp\n/*\n    \"STG(n)\" will return the 4 bytes at location n.  \"DUMP n\" will\nformat a dump of data at location n.  You can also code \"DUMP n length\"\nwhere length is the number of bytes to dump.  An example to print the\nCVT prefix area (an MVS area):\n  let a = stg(16)    (or let a = stg(h(10))  (or let a = !cvt)\n  dump a-40 40\nAn example to print the current LPALST concatenation (MVS):\n\n  let cvte=stg(!cvt+h(4ac))\n  let lpat=stg(cvte+h(38))\n  let numdsn = stg(lpat+7 1)    note optional length on stg\n  dump lpat numdsn*45+9\n  let name = lpat+9\n  do i = name by 45 for numdsn; say storage(d2x(i),44); end\n\nNote:  These functions may only be available under MVS.\n*/\n   return\nSYNTAX:\n   sigl2 = sigl\n   !!temp = 'SYNTAX'\n   !!temp2 = \"SYNTAX error\" rc\n   signal ERRRTN\nERROR:\n   sigl2 = sigl\n   !!temp = 'ERROR' rc\n   !!temp2 = !!temp\n   signal ERRRTN\nFAILURE:\n   sigl2 = sigl\n   !!temp = 'FAILURE' rc\n   !!temp2 = !!temp\n   signal ERRRTN\nERRRTN:\n   if !!inproc = '!!INPROC' then do\n     if !!verbose then do\n       say !!temp2 'in procedure (at line' sigl2')- ignored'\n       say 'Error' rc 'means \"' || errortext(rc) || '\"'\n       say 'Line' sigl2 'is:'\n       return strip(sourceline(sigl2),'T')\n     end\n     else return !!temp2 'in procedure (at line' sigl2')- ignored'\n   end\n   else do\n     say !!temp2 'in command (at line' sigl2')- ignored'\n     if !!verbose then do\n       say 'Error' rc 'means \"' || errortext(rc) || '\"'\n       say 'Line' sigl2 'is:'\n       say sourceline(sigl2)\n     end\n     interpret 'signal on' !!temp\n     signal ready\n   end\nINITIALIZE:\n   do while !!temp1 \\= ''\n     parse var !!temp1 !!temp2 !!temp1\n    if pos('=',!!temp2) = 0 then\n      do\n        !!temp2 = translate(!!temp2,\" \",\"_\")\n        queue !!temp2\n      end\n    else interpret !!temp2\n   end\n   if debug = \"TRACE\" then trace ?i\n   else if debug \\= \"DEBUG\" then trace i\n   curr=0\n   !!endcomment = \"*\" || \"/\"\n   !!hexmax = x2d(copies('F',16))\n   !!max = 99999999999999999999\n   !!min = -9999999999999999999\n   !!minfrac = 10**-33  /* Smallest number I'll express without\n                           going to scientific notation  */\n   drop debug\n   !!varnum = 0\n   !!vartble. = 0\n   !!deleted = x2c(fffffe) /* delete variable value */\n   !!true = 0=0\n   !!false= \\!!true\n   !!verbose = !!false\n   !!!.0 = 1\n   !!!.1 = 1\n   !!inproc = 'NO'  /* are we in a 'procedure'? */\n   !!neg = !!false  /* all hex numbers are positive */\n   !!temp = address()\n   SELECT\n     WHEN !!temp = 'TSO' then\n       do\n         if sysvar('SYSENV') = 'FORE' then\n           !!back = !!false\n         else\n           !!back = !!true\n         !cvt = stg(16)\n       end\n     WHEN !!temp = 'MVS' then\n       do\n         !!back = !!true\n         !cvt = stg(16)\n       end\n     OTHERWISE  /* eg under 'CMS' or pc-rexx */\n       !!back = !!false\n   end   /* of select */\n   return trace()\n /*  Written by Art Tansky at\n       SunGard\n       600 Laurel Oak Road\n       Voorhees, NJ 08043\n\n       Phone:  (609) 566-3611\n\n     If you find any bugs or have any suggestions for improvements or\n     additions, you can contact me at the address and phone number\n     above.  Please do not distribute modified versions of this code.\n     DO NOT REMOVE THE DISCLAIMER!\n\n  DISCLAIMER Disclaimer DISCLAIMER disclaimer DISCLAIMER Disclaimer:\n\n  This code has worked at Sungard.  There is no guarantee that the\n  code will work anywhere else.  Neither Sungard nor the author may be\n  held reponsible for any damage caused by this code.\n\n\n\n  Version 1.19 updates:\n    Use ! instead of # as some REXX implementations do not allow #.\n    Use \\ for not instead of a not sign for same above reasons.\n    Put 1st line comment in column 1 because OS/2 REXX requires it.\n    Replace \"upper\" with a push and pull because not all REXX's have\n      the \"upper\" command.\n\n  Version 1.20 updates:\n    Re-do HELP so that the exec can be line numbered.\n    Allow operands on the CALCR command to be queued to CALCR (as long\n      as they have no \"=\".  Since spaces delimit operands, underscores\n      (_'s) will be translated to spaces.\n\n */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT209/FILE209.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT209", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}