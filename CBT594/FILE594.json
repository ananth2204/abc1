{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012428000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 646646, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 13, "INMDSNAM": "CBT.V500.FILE594.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 646646, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 646646, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE594.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\x0c\\x0b'", "DS1TRBAL": "b'\\x8b\\x96'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xb0\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\xb0\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x04`\\x00\\x0e\\x04a\\x00\\x0b\\x00\\r'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x02(\\x0f\\x01\\x02(\\x0f\\t9\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf5\\xf3@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-10-07T00:00:00", "modifydate": "2002-10-07T09:39:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-453"}, "text": "REGULAR CBT TAPE - VERSION 453    FILE:  594\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT453.FILE594\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 46 MEMBERS COUNTED; CUMULATIVE SIZE IS 5,853 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   10/07/02    09:39:14    GMT-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$$NOTE": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x01\\x02'?\\x01\\x02'?\\t8\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc7\\xc1\\xd9\\xc4\\xc9\\xd5\\xd9@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-09-30T00:00:00", "modifydate": "2002-09-30T09:38:00", "lines": 12, "newlines": 12, "modlines": 0, "user": "GARDINR"}, "text": "        Roy Gardiner\n        64 High Road\n      Buckhurst Hill\n       Essex IG9 5RW\n\n    044 20 8504 8267\n\n        In an attempt to reduce spam, I have stoped using\n    'mailto' in my HTML and encode my email address to be obvious\n    only to real readers:\n\n          gardiner at-sign btinternet dot com\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$$DISCLM": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x01\\x02'?\\x01\\x02'?\\t8\\x00\\x1a\\x00\\x1a\\x00\\x00\\xc7\\xc1\\xd9\\xc4\\xc9\\xd5\\xd9@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-09-30T00:00:00", "modifydate": "2002-09-30T09:38:00", "lines": 26, "newlines": 26, "modlines": 0, "user": "GARDINR"}, "text": "\n  Copyright (c) 2000 Roy Gardiner\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation\n  files (the ``Software''), to use and change the Software\n  without restriction, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  You may not, by way of trade, copy, modify, merge, publish,\n  distribute, sublicense, and/or sell copies of the Software, or\n  technical support of the Software, or training in the use of the\n  Software.\n\n  THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY\n  KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE\n  WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE\n  AND NONINFRINGEMENT.  IN NO EVENT SHALL ROY GARDINER BE LIABLE\n  FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OF THE SOFTWARE.\n\n  -------------------------------------------------------------------\n                         Last updated: 27 Jan 2001\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$$HELP": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x01\\x02'?\\x01\\x02'?\\tB\\x04K\\x04K\\x00\\x00\\xd7\\xc4\\xe2\\xd3\\xd6\\xc1\\xc4@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-09-30T00:00:00", "modifydate": "2002-09-30T09:42:00", "lines": 1099, "newlines": 1099, "modlines": 0, "user": "PDSLOAD"}, "text": "./ ADD NAME=DADMIN   0100-02273-02273-0938-00055-00055-00000-GARDINR\nAdministration\n\n  You can make DDF available to others both on your local machine\n  and further afield.\n\n  Local use\n\n  Dissemination is done like this on one MVS image:\n\n     * copy the command UTCDSM5 to a central command library\n     * ensure that the DDFLIB dataset is read-available to all\n       potential DDF users\n\n  That's it!\n\n  You can keep track of what people think of DDF, if you want to.\n  This is done by means of the survey dataset. If the DDFLIB\n  dataset is:\n\n          QUAL1.QUAL2.DDFLIB\n\n  then you can create a new dataset\n\n          QUAL1.QUAL2.SURVEY\n\n  which DDF will look for. It should be an FB(80) PDS or PDS/E.\n  If it's a PDS it should have plenty of directory space because\n  DDF will generate one member for each DDF user. All DDF users\n  must have update access to the survey dataset and you should\n  copy the member ZTEMPLAT from DDFLIB to it.\n\n        Every so often, DDF will display the ZTEMPLAT member to\n  each user, asking them to fill in what they think of the\n  product. DDF will then save it using the Userid as member name.\n  DDF will also update the Userid's member on the survey each\n  time they use the product; it will add one to the Mod field in\n  the ISPF stats. Thus when you take a member list of the survey\n  dataset, if you\n\n          SORT CHANGED\n\n  you will see the last people to enter their views about DDF,\n  which you can then look at, and if you\n\n          SORT MOD\n\n  you can see who uses it most and how much.\n\n  Notify friends\n\n  If you like DDF, please feel free to tell your friends. You can\n  either point out the web site, or if they have no internet\n  access you can e-mail them and attach the Zip file from the\n  site, telling them to un-zip and open their browser on file\n  dfr01.htm.\n./ ADD NAME=DALLOC   0100-02273-02273-0938-00039-00039-00000-GARDINR\nAllocated datasets\n\n  You can type LA on the command line, which will generate a list\n  of all the datasets allocated to your session giving the DDname\n  and associated dataset(s) for each.\n\n  -------------------------- List of allocated datasets ---  ROW 1\n   Command ===>\n\n  C  Member   DDname   Dataset name                   Stats\n              ISPMUSR  USER01.USER.CLIST\n              ISPSUSR  USER01.USER.CLIST\n              ISPPLIB  SYS3.PLIB\n                       SYS1.PLIB\n\n  You can now issue commands\n\n     L ddname\n     F membername ddname\n\n  The L command brings the first line of the concatenation for\n  <ddname> to the top of the display, so that you can see what is\n  in it. The F command finds <membername> within <ddname>,\n  showing all instances, so that you can see where a command,\n  panel, message or whatever is coming from. When the members are\n  found, their ISPF stats are shown on the screen; so the\n  response to F UTCDSM5 SYSPROC might look like this:\n\n  C Member   DDname   Dataset name              Stats\n             SYSPROC  SYS3.CLIB\n                      SYS4.CLIB\n                      SYS1.CLIB\n    UTCDSM5           USER01.USER.CLIST        01.34 95/08/18 12:05 USER01\n\n\n  Under the C heading you can enter e b or v, which will Edit\n  Browse or View the dataset, producing a member list. If the\n  member has been put in after using F to find them, that member\n  will be edited.\n./ ADD NAME=DBRED    0100-02273-02273-0938-00024-00024-00000-GARDINR\nBrowse and Edit\n\n  Looking at PDSs is done with these commands under the CMD\n  heading.\n\n  E    If a member name is given under Member heading, edit it.\n       If not, create and edit it.\n  B    If a member is given, browse it. If it's not found, create\n       a member list using the member given as a pattern. If no\n       member is specified, produce a list of all members.\n  ML   Produce a full member list whether or not a member is\n       specified.\n  V    As for B, but instead of Browsing a member, view it.\n\n  When you edit, broswse or view a member, DDF will produce a\n  message giving the user, date and time of the last edit. If you\n  are editing and the user was not you, the beep sounds. This\n  helps to alert you if someone else has updated something you\n  are going to update.\n\n       These commands can also be used on sequential files, but\n  not VSAM or other data that ISPF cannot process. The member\n  field is ignored for sequential files - it's not an error to\n  have a member name, it's just not checked or used.\n./ ADD NAME=DDCLAIM  0100-02273-02273-0938-00026-00026-00000-GARDINR\n\n  Copyright (c) 2000 Roy Gardiner\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation\n  files (the ``Software''), to use and change the Software\n  without restriction, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  You may not, by way of trade, copy, modify, merge, publish,\n  distribute, sublicense, and/or sell copies of the Software, or\n  technical support of the Software, or training in the use of the\n  Software.\n\n  THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY\n  KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE\n  WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE\n  AND NONINFRINGEMENT.  IN NO EVENT SHALL ROY GARDINER BE LIABLE\n  FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OF THE SOFTWARE.\n\n  -------------------------------------------------------------------\n                         Last updated: 27 Jan 2001\n./ ADD NAME=DINSTALL 0100-02273-02273-0938-00054-00054-00000-GARDINR\nInstallation\n\n DDF can be downloaded from two sources:\n\n Binary file\n      which holds DDF in a TSO XMIT file in uncompressed format.\n      Download this to your PC, calling it ddflib.bin\n Zip file\n      which holds the XMIT format file plus the documentation\n      pages from the web site in compressed form. Download this\n      to your PC and unzip it. You can view this documentation\n      from your PC now, by opening file 'dfr01.htm' in your\n      browser. This will speed up viewing it because all the\n      files are now local.\n\n Upload the DDF components to your mainframe\n\n All the DDF components are held in ddflib.bin, which should be\n uploaded to the mainframe. The transfer must be binary (no CRLF\n or ASCII translation) and the target dataset should be LRECL=80\n and record format of fixed. This is very important! The RECEIVE\n command requires that the XMIT files be Lrecl=80 and fixed. It's\n often best to pre-allocate this dataset before doing the upload.\n\n On TSO, RECEIVE INDATASET(name)\n\n When prompted by message \"INMR906A Enter restore parameters or\n 'DELETE' or 'END' +\": respond\n\n DA('hlq1.hlq2.DDFLIB')\n\n The hlq1 will typically be your userid, hlq2 is your choice\n\n Install the command\n\n Copy UTCDSM5 (the DDF controlling exec) to your command or exec\n library, and edit it as follows:\n\n000027  /**********************************************************************/\n000028                               /* Editable variables -- start           */\n000029    genHLQ           = \"hlq1\"\n000030    genLev2Q         = \"hlq2\"\n\n Change the strings to the first and second level qualifiers you\n have chosen.\n\n Start\n\n Start by typing\n\n         TSO UTCDSM5\n\n on any ISPF command line; if the DDF main panel displays,\n installation is complete.  Proceed to Getting started.\n./ ADD NAME=DINTRO   0100-02273-02273-0938-00057-00057-00000-GARDINR\nIntroduction\n\n  The idea of DDF is to speed up many of the normal jobs in ISPF\n  by eliminating the need to remember and then type dataset names\n  all the time.\n\n  DDF keeps a list of datasets, which you enter under the Text\n  heading above. Names can be in any order. Actions are entered\n  under the Cmd heading and include commands to\n\n     * edit a dataset (or member)\n     * browse a dataset (or member)\n     * display and edit member stats\n     * compare members\n     * copy a member from one dataset to another (optionally\n       changing name)\n     * compare and merge members\n     * find versions of members across many datasets\n     * submit jobs\n     * access ISPF functions including 3.1, 3.2, 3.3, 3.4, 3.14\n       (search for strings)\n     * produce member list and then within member list:\n\n          o submit batch job\n          o browse member\n          o edit member\n          o rename member\n          o delete member\n          o execute member.\n\n  What is DDF?\n\n  DDF is a Rexx exec and some ISPF panels, skeletons and\n  messages. There is no Assembler and no need to complile\n  anything. There are no tricks or dodges; all DDF functions are\n  standard ISPF which you can see (and modify if you need to) in\n  the code.\n\n       You do not need to be a systems programmer to install DDF;\n  anyone with modest knowledge of ISPF can set it up for personal\n  use, or for use by more than one person. DDF does not interfere\n  with your ISPF environment beyond requiring one exec to be\n  copied to a suitable command library. All other DDF libraries\n  remain separate from and therefore independent of your standard\n  session, and indeed are only available whilst DDF is running -\n  DDF uses LIBDEF to gain access to them.\n\n  Who uses DDF?\n\n  When DDF is made widely available, experience shows that that\n  up to 10% of a typical TSO/ISPF user population will use it\n  every day; some of these will use DDF as their standard front\n  screen, rather than having an ISPF main menu. The main users\n  seem generally to be to be development people rather than\n  systems programmers; the latter have often written any number\n  of shortcuts and tools for themselves and have their working\n  environments tailored perfectly to suit them.\n./ ADD NAME=DLINES   0100-02273-02273-0938-00023-00023-00000-GARDINR\nOrder of lines\n\n  The order of display can be altered by several prefix commands\n  entered under the CMD heading\n\n  In   Insert n lines. If n is omitted then 1 blank line is added\n  Rn   Repeat n times. If n is omitted then the line is repeated\n       once.\n  C    Copy line. Used in conjunction with A or B4\n  A    Used with Copy or Move, where the line goes After the\n       specified line\n  B4   Use with Copy or Move, where the line goes Before the\n       specified line.\n             B4 is used to avoid confusion with the much more\n       commonly used B for Browse prefix command\n  D    Delete line\n  X    Exclude line from the display\n\n  See also the usage of the Show List and Show headings, which\n  enable you to group lines together (e.g. for groups of datasets\n  in the same project) and to control where they are in the list\n  and whether or not they are displayed. These enable you to keep\n  the most often used datasets at the top of the list.\n./ ADD NAME=DMCMP    0100-02273-02273-0938-00084-00084-00000-GARDINR\nMember compare\n\n You can invoke a standard SuperC compare like this:\n\n Cmd  Member   Text                     Description   Show\n cpn  FRED     USERID.QUAL2.QUAL3.QUAL4\n cpo  BILL     OTHERID.SOME.DATA.OR.OTHER\n\n Where the commands mean Compare New and Compare Old. The member\n with cpn against it is treated as the 'new' item, the other as\n the 'old' item. If the members to be compared have the same\n name, you need only enter it once, next to either of the\n commands. You do not have to enter the commands in any order,\n and you can enter one command, do other things (e.g. scrolling\n up and down), then enter the other.\n\n       You will be placed in browse of a temporary dataset\n containing the result of the comparison. The output report might\n look like this:\n\n BROWSE -  USER01.XMTEMP.D9940610.T51752.SUPERC1 - LINE 000 COL001 080\n COMMAND ===>                                       SCROLL ===> HALF\n *************************** TOP OF DATA  ***************************\n SUPERC - MVS/PDF FILE/LINE/WORD/BYTE/SFOR COMPARE UTILITY - V2.12\n NEW: USER01.USER.CLIST(FRED)                   OLD:USER01.USER.CLIST(BILL)\n  ID       SOURCE LINES\n      ----+----1----+----2----+----3----+----4----+----5----+----6----\n  I -      ISPEXEC VPUT (XXX) PROFILE\n  D -      ISPEXEC VPUT (XXX) SHARED\n  I -         ISPEXEC VPUT (XXX) PROFILE\n  D -         ISPEXEC VPUT (XXX) SHARED\n\n The report is SuperC standard; full details of the SuperC\n listings are available in the ISPF/PDF Guide supplied by IBM.\n\n extended compare\n\n The extended compare can be used to:\n\n    * change compare parameters, such as the compare columns\n    * merge two versions of an item into a third, merged version\n    * carry out a special logical comparison, which is used to\n      analyse the change control status of two items which have\n      been edited in a way defined by DDF.\n\n The extended compare is invoked by using NEW/OLD prefix commands\n instead of CPN/CPO. Instead of going directly to SuperC, the\n extended compare panel is displayed:\n\n  -------------------------- SuperC extended --------------------\n  Command ===>\n\n     1  Compare         - Compare using SuperC\n     2  Merge           - Merge using SuperC\n     3  Logical compare - Compare only the change control areas\n\n     New ===> USER01..USER.CLIST                       <\n  Member ===> FRED    <\n     Old ===> USER02..USER.CLIST                       <\n  Member ===> FRED02   <\n\n   Merge ===>                                          <\n  Member ===>          <\n  (Dataset names should be fully qualified, without quotes)\n    ===> 2 < Leftmost compare column (zero for full width compare)\n    ===> 72 < Rightmost compare column\n\n 1: Compare\n\n This will compare the New and Old files and produce a report\n which is displayed to the user in Browse mode. This is the same\n as CPN/CPO except that you can select column numbers to pass to\n SuperC. Columns outside the range will be ignored during the\n compare. Note that if you are comparing COBOL programs, you will\n probably want to exclude the sequence number columns 1-6 and\n 73-80, i.e. to select columns 7 to 72.\n\n 2: Merge\n\n You can merge the files into a new file and be placed into Edit\n of the merged result. If you attempt a merge and the target file\n already exists, you are informed of this and the merge is not\n done. Merge uses SuperC to combine the two files. There is a\n full explanation of how merging works.\n./ ADD NAME=DMCOPY   0100-02273-02273-0938-00032-00032-00000-GARDINR\nMember copy and move\n\n  You can copy between datasets like this:\n\n  Cmd Member   Text                     Description   Show\n  CO  FRED     USERID.QUAL2.QUAL3.QUAL4\n  TO  BILL     OTHERID.SOME.DATA.OR.OTHER\n\n  The commands shown above will Copy the member FRED To the\n  member BILL on the target dataset. If you want to copy or move\n  without changing the member name, you can leave the member name\n  blank on the TO and OV lines. The command combinations that can\n  be used are as follows (choose one from the left column and one\n  from the right):\n\n                       target member name. If the member already\n   co  copy member to  exists, it is not overwritten\n\n   mo  move member ov  target member name. Any existing member is\n                       overwritten\n\n  Note that the same dataset can appear as many times as you like\n  on a DDF list. If you use the same dataset name with CO/MO and\n  TO/OV:\n\n     * Using the same member and same dataset is not an error,\n       but also is not sensible!\n     * A MO/TO operation using the same dataset names and\n       different member is equivalent to renaming the member;\n       MO/OV will over-write any existing member.\n     * CO/TO or CO/OV creates a new copy, with or without\n       over-writing the target, respectively.\n./ ADD NAME=DMLIST   0100-02273-02273-0938-00048-00048-00000-GARDINR\nMember list\n\n You can get a member list by typing B or ML under the CMD\n heading; B will use the member name as a pattern (if the name is\n not found; if it is found, it will be browsed directly), ML will\n produce a full member list, which might look like this:\n\n MEMBER LIST -- USER01.USER.CLIST --DDF List B ------------ ROW 00001 OF 00004\n  COMMAND ===>                                                  SCROLL ===>PAGE\n             NAME                 VV.MM     CHANGED     SIZE  INIT   MOD   ID\n            #PDF                  01.08 95/09/29 16:31    48    32     0 USER01\n            #PDFB                 01.00 95/06/28 09:17    43    43     0 USER01\n            #PDFRX                01.08 90/06/13 10:24    36    25     0 USER01\n            #PDFX                 01.00 95/09/29 16:29    47    47     0 USER01\n            **END**\n\n When you get a member list (and you may often type in a member\n name you know does not exist in order to get one) then you can\n use these commands in the prefix area to the left of the member\n name:\n\n b    browse the member\n delete\n      delete the member. For obvious reasons there is no\n      abbreviation for this command.\n e    edit the member\n exec\n      execute this member, if it is a Clist or Rexx exec. If you\n      issue exec against something not a Clist or Rexx exec, you\n      will get an error message\n r    rename the member to a new name, which you type in next to\n      the old one in the column provided. The old member name\n      stays in the list, with the new member name next to it, as\n      an audit trail, until you quit the member list.\n sub  submit the member to batch for execution. If it is not a\n      valid JCL job, you will get an error message.\n\n Note that at present there is no = command like the one in 3.4.\n\n On the main command line, you can type these commands:\n\n b membername\n      Browse the membername. The member must exist, but need not\n      be on the current member list displayed\n e membername\n      Edit the membername. The member need not exist, nor need it\n      be on the current member list displayed. If it does not\n      exist, a new member is created.\n./ ADD NAME=DMMRG    0100-02273-02273-0938-00257-00257-00000-GARDINR\nSuperC Merge\n\n SuperC can merge two files together to produce a third, combined\n version.  The merged file contains control information to allow\n the user how to ensure that the final version is a correct\n combination of the two input versions.\n\n Two sample files are shown here, with a third which is the\n result of the SuperC merge process. A line by line guide is then\n given as to what the control information means.\n\n Merge file (old)\n     LINE 1\n     LINE 2\n     LINE 3 1\n     LINE 4 IS DELETED ON THE NEW FILE\n     LINE 5\n     LINE 6\n     LINE 7\n     LINE 8\n     LINE 9\n     LINE 10\n     LINE 11 WHICH IS DELETED ON THE NEW FILE\n     LINE 12 NOW THE LINE NUMBERS MATCH AGAIN\n     LINE 13\n     LINE 14\n     LINE 15\n Merge file (new)\n     LINE 1\n     LINE  2\n     LINE 3\n     LINE 5\n     LINE 6 IS CHANGED ON THE NEW FILE\n     LINE 6A IS INSERTED AFTER A CHANGED LINE\n     LINE 7\n     LINE 7A WHICH IS INSERTED ON THE NEW FILE\n     LINE 8\n     LINE 9 IS NOW ON LINE 10 BUT IDENTIFIED AS A CHANGE\n     LINE 10\n     LINE 12 NOW THE LINE NUMBERS MATCH AGAIN\n     LINE 13\n     LINE 14\n\n Merging these two files will create an output file like this,\n with SuperC control statements inserted:\n\n Merged result\n *HDR1  USER01.USER.CLISTB(COM2)\n *HDR2  USER01.USER.CLISTB(COM1)\n *M-    MAT#=  1      N-REF#=000001 O-REF#=000001\n     LINE 1\n *I-RF  INS#=  1      N-REF#=000002 O-REF#=000002\n     LINE  2\n *D-RF  DEL#=  1      N-REF#=000002 O-REF#=000002\n     LINE 2\n *M-    MAT#=  1      N-REF#=000003 O-REF#=000003\n     LINE 3\n *D-    DEL#=  1      N-REF#=000003 O-REF#=000004\n     LINE 4 IS DELETED ON THE NEW FILE\n *M-    MAT#=  1      N-REF#=000004 O-REF#=000005\n     LINE 5\n *I-RP  INS#=  2      N-REF#=000005 O-REF#=000006\n     LINE 6 IS CHANGED ON THE NEW FILE\n     LINE 6A IS INSERTED AFTER A CHANGED LINE\n *D-RP  DEL#=  1      N-REF#=000005 O-REF#=000006\n     LINE 6\n *M-    MAT#=  1      N-REF#=000007 O-REF#=000007\n     LINE 7\n *I-    INS#=  1      N-REF#=000008 O-REF#=000007\n     LINE 7A WHICH IS INSERTED ON THE NEW FILE\n *M-    MAT#=  1      N-REF#=000009 O-REF#=000008\n     LINE 8\n *I-RP  INS#=  1      N-REF#=000010 O-REF#=000009\n     LINE 9 IS NOW ON LINE 10 BUT IDENTIFIED AS A CHANGE\n *D-RP  DEL#=  1      N-REF#=000010 O-REF#=000009\n     LINE 9\n *M-    MAT#=  1      N-REF#=000011 O-REF#=000010\n     LINE 10\n *D-    DEL#=  1      N-REF#=000011 O-REF#=000011\n     LINE 11 WHICH IS DELETED ON THE NEW FILE\n *M-    MAT#=  3      N-REF#=000012 O-REF#=000012\n     LINE 12 NOW THE LINE NUMBERS MATCH AGAIN\n     LINE 13\n     LINE 14\n *D-    DEL#=  1      N-REF#=000014 O-REF#=000015\n     LINE 15\n\n SuperC combines the files where no differences are found. Where\n differences are found, it puts lines from both files into the\n output, with control lines to say what it has done. You then\n delete the control lines plus those lines you do not want - i.e.\n from either the old or new file.  The control lines start in\n column 1 with an asterisk, followed by the control information.\n Note that the legend\n\n        *****SUPERC CHANGE HEADER*****\n\n normally appears on the right on each control line. These have\n been edited out of the illustration to simplify it. The possible\n SuperC control codes are:.\n\n      *HDR1\n      *HDR2\n      *D-\n      *D-RF\n      *D-RP\n      *I-\n      *I-RF\n      *I-RP\n      *M-\n\n Explanation of SuperC merge file\n\n SuperC identifies reformatted, changed, deleted, inserted and\n matched lines: the merged file contains\n\n    * control data\n    * one copy of each matched line\n    * alternative copies of the different lines from both files\n      so you can choose which you want.\n\n Each control line from the merged file is shown below, with a\n recommended action where this is appropriate.\n\n       SuperC does not base its comparsions on line numbers, but\n on matching the data. It is not confused by line deletions or\n insertions, but can identify them even when line numbers have\n changed. This means that you will not get 'cascading', where one\n small difference produces many mismatch messages. You will see\n this in the explanation below.\n\n       The HDR control words identify the two datasets that were\n merged\n\n  *HDR1  USER01.USER.CLISTB(COM2)\n  *HDR2  USER01.USER.CLISTB(COM1)\n\n *HDR1 identifies the NEW version, *HDR2 identifies the OLD version.\n\n Recommended: delete both lines\n\n You may want to delay doing the deletion until after completing\n the actions outlined below, so that you can remind yourself\n which version is the New and which the Old.\n\n *M    MAT#=  1      N-REF#=000001 O-REF#=000001\n\n shows data lines that are the same on both files *M shows that\n matched lines have been found. MAT# shows how many matched lines\n there are. N-REF# and O-REF# are the line numbers in the new and\n old files, respectively, where the match was found. The data\n lines follow the *M line.\n\n Recommended: delete the *M header line.\n\n *I-RF  INS#=  1      N-REF#=000002 O-REF#=000002\n ...new file data lines\n *D-RF  DEL#=  1      N-REF#=000002 O-REF#=000002\n ...old file data lines\n\n *I-RF shows that some lines have been reformatted on the new\n file. INS# is the number of reformatted lines. The new lines\n follow the *I-RF line.\n\n *D-RF is the header for the reformatted lines from the old file.\n DEL# is the number of reformatted lines. The old lines follow\n the *D-RF line.\n\n Recommended: Decide which set of reformatted lines you want and\n delete the others, then delete the SuperC control lines\n\n    *M-    MAT#=  1      N-REF#=000003 O-REF#=000003\n\n *M indicates matched lines, MAT# shows how many. N-REF# and\n O-REF# are the line numbers in the new and old files. The data\n lines follow the *M line.\n\n Recommended: delete the *M header line.\n\n *D-    DEL#=  1      N-REF#=000003 O-REF#=000004 ...old file deleted lines\n\n *D shows that lines have been deleted from the old file. DEL# is\n the number of deleted lines.\n\n Recommended: delete the lines if they are not required in the\n new file, then delete the control line.\n\n *M-    MAT#=  1      N-REF#=000004 O-REF#=000005\n\n *M indicates matched lines, MAT# shows how many. N-REF# and\n O-REF# are the line numbers in the new and old files. The data\n lines follow the *M line.\n\n Recommended: delete the *M header line.\n\n *I-RP  INS#=  2      N-REF#=000005 O-REF#=000006\n ....lines from the new file\n *D-RP  DEL#=  1      N-REF#=000005 O-REF#=000006\n ....lines from the old file\n\n *I-RP is used where lines are replaced rather than reformatted.\n It is therefore much more common that *I-RF and *D-RF. INS# is\n the number of new lines. The new lines follow the *I-RP line.\n *D-RP is the header for the deleted lines from the old file.\n DEL# is the number of deleted lines. The old lines follow the\n *D-RF line.\n\n Recommended: select which set of lines you want, delete the\n other set and delete the control line\n\n *M-    MAT#=  1      N-REF#=000007 O-REF#=000007\n\n *M indicates matched lines, MAT# shows how many. N-REF# and\n O-REF# are the line numbers in the new and old files. The data\n lines follow the *M line.\n\n Recommended: delete the *M header line.\n\n *I-    INS#=  1      N-REF#=000008 O-REF#=000007\n\n *I- shows lines inseted on the new file. INS# is the number of\n new lines.\n\n Recommended: decide whether you want the lines, delete them if\n not, then delete the control line.\n\n *M-    MAT#=  1      N-REF#=000009 O-REF#=000008\n\n *M indicates matched lines, MAT# shows how many. N-REF# and\n O-REF# are the line numbers in the new and old files. The data\n lines follow the *M line.\n\n Recommended: delete the *M header line.\n\n *I-RP  INS#=  1      N-REF#=000010 O-REF#=000009\n *D-RP  DEL#=  1      N-REF#=000010 O-REF#=000009\n\n This illustrates that line numbers need not be the same for a\n changed line to be identified.\n\n *M-    MAT#=  1      N-REF#=000011 O-REF#=000010\n\n Recommended: as always, to delete the matched lines header\n\n *D-    DEL#=  1      N-REF#=000011 O-REF#=000011\n\n Recommended: decide if the deleted lines are needed or not,\n delete them as appropriate, then delete the control line.\n\n  *M-    MAT#=  3      N-REF#=000012 O-REF#=000012\n\n Recommended: as always, to delete the matched lines header\n\n *D-    DEL#=  1      N-REF#=000014 O-REF#=000015\n\n Recommended: decide if the deleted lines are needed or not,\n delete them as appropriate, then delete the control line.\n./ ADD NAME=DMSTATS  0100-02273-02273-0938-00030-00030-00000-GARDINR\nISPF stats\n\n  ISPF stats can be viewed and modified. If you want to check\n  whether a member exists, use the prefix command ST next to the\n  member you want to check. If the member exists, a display will\n  be given of the member's ISPF statistics like this:\n\n  -------------------------------- Member stats -------\n   Command ===>\n\n                          member   FRED\n                         library   USER01.QUAL.WHATEVER\n\n                  Version number   01\n              Modification level   08\n                   Creation date   94/04/08\n              Last changed  date   95/09/29\n              Last changed  time   16:31\n       Current number of records   48\n     Beginning number of records   32\n       Number of changed records   0\n                          Userid   USER01\n\n     Use command UPDATE to reset statistics\n\n  You can change any of the statistics at this point. Type UPDATE\n  on the command line, and all the displayed stats will turn from\n  blue to green. Simply overtype with the values you want. You\n  must have security access (RACF or ACF2 or whatever you are\n  using) to the dataset for this to work properly.\n./ ADD NAME=DMVERS   0100-02273-02273-0938-00073-00073-00000-GARDINR\nMember find\n\n  You can search for any number of occurrences of a member in\n  your DDF list. This is controlled by the Type field. The Type\n  field on the display contains text determined by the user that\n  indicates what type of data is contained in the dataset. You\n  might choose CBL for COBOL programs, or JCL for JCL, or PLI for\n  PL/1 programs, and so on.\n\n  DDF 1.0 ------------- USERID1 Jun 1994 -------  ROW 1 FROM nnn\n  Command ===>                                 Scroll ===> PAGE\n  Show list > ABC                                              <\n  Cmd  Member   Text                     Description   Show Type\n       FRED     PROJ1.QUAL2.QUAL3.QUAL4                ABC   A\n                PROJ1.LEVEL2.QUAL3.QUAL4               ABC   A\n                PROJ2.QUAL2.QUAL3.QUAL4                ABC   A\n       BILL     OTHERID.SOME.DATA.OR.OTHER             ABD   COB\n                YET.ANOTHER.LEVEL                      P1    PLI\n       XYZ      PROJ3.ANOTHER.DATSET                   RST   XX\n\n  The format of Find is F <membername> <type> <exclusion specification>\n  where\n\n  F\n\n  membername\n       The member for which the search is to be made\n  type\n       The value under the Type column, indicating which datasets\n       are to be checked. * means search all types\n  exclusion specification\n       x    search only the lines excluded from the display\n       nx   search only the lines NOT exluded from the dispay\n       *    search all lines, excluded or not\n\n  Some examples of F commands might be:\n\n    1. F FRED JCL NX\n    2. F AAXXX01 COB NX\n    3. F FRED R X\n    4. F FRED * NX\n    5. F FRED * *\n\n  where\n\n    1. Find the member FRED amongst datasets of type JCL that are\n       not excluded from the display, i.e search amongst those\n       datasets currently visible.\n    2. Find the member AAXXX01 amongst datasets of type COB that\n       are not excluded from the display\n    3. Find the member FRED amongst datasets of type R that are\n       excluded from the display\n    4. Find the member FRED amongst all datasets that are\n       currently visible.\n    5. Find the member FRED amongst all datasets whether visible\n       or excluded.\n\n  The Find function will then show an abbreviated display, giving\n  those datasets that have been searched. The rightmost portion\n  of the screen is changed to show the ISPF stats for each member\n  found. This means that:\n\n     * it becomes possible easily to see what versions are extant\n     * the last changed dates can be seen for each version found,\n       along with the userid making the change\n\n  Find is particularly useful in an environment where multiple\n  parallel developments are being undertaken - the usual case in\n  most large IT departments - because it can help track multiple\n  versions and avoid regression (regression is where a software\n  change or fixed is removed by a subsequent version because the\n  developer of the second one did not incorporate all changes\n  taking place in parallel).\n./ ADD NAME=DSLIST   0100-02273-02273-0938-00058-00058-00000-GARDINR\nShow\n\n  When you first use DDF you will only have a half dozen or so\n  datasets on your display. But as you get used to it, you will\n  soon find that you have more than one screen's worth and you\n  will be continuously scrolling up and down searching for the\n  ones you want, which becomes irritating and time consuming. The\n  Show heading allows you to of organise the display to group\n  logically related datasets together and either show or exclude\n  them from the display as you choose.For example:\n\n  DDF 1.0 ------------- USERID1 Jun 1994 -------  ROW 1 FROM nnn\n  Command ===>                                 Scroll ===>PAGE\n  Show list >                                                 <\n  Cmd  Member   Text                     Description   Show\n       FRED     PROJ1.QUAL2.QUAL3.QUAL4                ABC\n                PROJ1.LEVEL2.QUAL3.QUAL4               ABC\n                PROJ2.QUAL2.QUAL3.QUAL4                ABC\n       BILL     OTHERID.SOME.DATA.OR.OTHER             ABD\n                YET.ANOTHER.LEVEL                      P1\n       XYZ      PROJ3.ANOTHER.DATSET                   RST\n\n  You can type anything under the Show heading to identify\n  related datasets, as in the display above where all the ABC\n  project's datasets are grouped together. There are no special\n  values that you have to enter under Show; numbers and special\n  characters are just as good as letters. The Show column\n  determines the order that the datasets are shown; lines with\n  blank Show field of always being at the top of the display. You\n  can control the display with these commands: On the command\n  line:\n\n  H    Show the first line only in each group\n  SORT\n       Reorder the lines into the order given by the Show field\n  RESET\n       Reveal all lines\n\n  Prefix commands (under the Cmd heading)\n\n  HI   Suppress all following lines that have the same Show field\n  SH   Reveal all following lines that have the same Show field\n\n  If you hide a group of lines, then overtype the Show field on\n  the first line, all the following hidden lines inherit the new\n  Show value.\n\n  You can thus quickly reorder the complete display:\n\n     * Type H on the command line to show only the first line of\n       each group\n     * overtype each Show field with your new value\n     * type Sort on the command line to reorder the list\n\n  You can now use the SH and HI prefix commmands to show the\n  individual lines in each group.\n\n  See also Show list\n./ ADD NAME=DSLIST2  0100-02273-02273-0938-00034-00034-00000-GARDINR\nShow list\n\n  The Show list is an alternative way of limiting the number of\n  lines shown on the screen; if you have not already done so, you\n  should read about Show before continuing here.\n\n  Type a list of the groups you want to see next to the Show List\n  heading All the lines in every group are shown, and no others.\n  This feature, unlike using the SH and HI prefix commands, does\n  not show the first line of each group; to restore the first\n  lines, type H on the command line.\n\n       There does not have to be a perfect match between the Show\n  List and entries under the Show heading. In this example:\n\n  DDF 1.0 ------------- USERID1 Jun 1994 -------  ROW 1 FROM nnn\n  Command ===>                                 Scroll ===>PAGE\n  Show list >                                                 <\n  Cmd  Member   Text                     Description   Show\n       FRED     PROJ1.QUAL2.QUAL3.QUAL4                ABC\n                PROJ1.LEVEL2.QUAL3.QUAL4               ABC\n                PROJ2.QUAL2.QUAL3.QUAL4                ABC\n       BILL     OTHERID.SOME.DATA.OR.OTHER             ABD\n                YET.ANOTHER.LEVEL                      P1\n       XYZ      PROJ3.ANOTHER.DATSET                   RST\n\n  if you had entered AB in the Show List above, then all lines\n  with a show field starting AB would be shown, i.e. projects ABC\n  and ABD..  This feature can be used to create groups and\n  subgroups of datasets, entirely under your control.\n\n        Note that if you enter a Show List value for which there\n  are no matches, a new line will be created for you, so that the\n  new Show group can be created.\n./ ADD NAME=DSTART   0100-02273-02273-0938-00049-00049-00000-GARDINR\nGetting started\n\n Assuming that installation is complete, start by typing\n\n         TSO UTCDSM5\n\n on any ISPF command line; there will at first be no datasets in\n your list. To get some in quickly, use the Add command on the\n command line, of which there are two options:\n\n     ADD <qualifier>\n     ADD ALLOC\n\n If you typed     ADD userid01     DDF would select all datasets\n with that HLQ and you might see something like this:\n\n ------------------ Select from dataset prefix list ---  ROW 1 TO 20 OF 85\n  Command ===>                                           Scroll ===> HALF\n\n Cmd          Dataset name                          Added?  Show    Type\n              USERID01.QUAL021.XMDEC28                     >         >\n              USERID01.QUAL02.CLIB                         >         >\n              USERID01.CLIB                                >         >\n              USERID01.DGIPROT.TABLE                       >         >\n\n Under Cmd you can now type S to select datasets to be added to\n the display. Don't worry at this stage about putting anything\n under the Show or Type headings. Use PF3 or END to go back to\n the DDF screen.\n\n       To add lines from the datasets allocated to your session,\n type ADD ALLOC on the DDF command line. You will now see\n datasets of different HLQs allocated to your ISPF session.\n\n ----------------- Select from allocated data sets -- ROW 1 TO 20 OF 104\n Command ===>                                         Scroll ===> HALF\n\n Cmd DDname   Dataset name                          Added? Show     Type\n     SYSHELP  SYS3.HELP                                   >         >\n              SYS1.HELP                                   >         >\n     SMPTABL  SYS4.TLIB                                   >         >\n     SYS00001 SYS1.BRODCAST                               >         >\n     ISPPROF  USERID01.ISPF.PROFILE                       >         >\n     ISPTABL  USERID01.ISPF.PROFILE                       >         >\n     ISPPLIB  SYS3.PLIB                                   >         >\n              SYS1.PLIB                                   >         >\n\n Again use S in the prefix area to select datasets to add to the\n DDF display\n./ ADD NAME=DTEMPL   0100-02273-02273-0938-00056-00056-00000-GARDINR\nTemplates\n\n  Edit copy provides a way of bringing in a member name into the\n  one you are editing. This saves typing by using pre-written\n  outlines of commonly used code. The copy process is, however,\n  not as neat as we would like if you want to copy from a dataset\n  other than the one being edited; you have to type Copy, then\n  the name of the dataset, and then select the member you want.\n  It's only if the member you want is in the dataset you happen\n  to be editing that you can type\n\n         COPY membername\n\n  on the command line. With DDF you can sometimes code it this\n  way even if what you want is on a different dataset.\n\n  This is best illustrated by a walk-through of what an\n  experienced DDF user might do and what they would see on the\n  way. On the DDF command line, our expert types TEMPL to show\n  the separate datasets (TEMPLATES) used to hold Rexx, JCL, etc\n  fragments. These datasets are under our expert's control.\n\n  C Dataset name                          DDF type\n     <hlq>.TEMPLATE.JCL               J\n     <hlq>.TEMPLATE.REXX              R\n     <hlq>.TEMPLATE.CLIST             C\n\n  I (insert) D (delete) R (repeat) prefix commands are used to\n  control the list. <hlq> is the high-level qualifer for your\n  code fragment datasets. Note that the word TEMPLATE is not\n  required but it might be useful as a standard. The DDF screen\n  looks like this:\n\n  Show list > ABC                                              <\n  Cmd  Member   Text                     Description   Show Type\n       FRED     PROJ1.QUAL2.QUAL3.QUAL4                ABC   J\n                PROJ1.LEVEL2.QUAL3.QUAL4               ABC   R\n\n  When fred is edited, DDF will see it's Type J, which is\n  associated with a dataset called <hlq>.TEMPLATE.JCL, The\n  template dataset will be concatenated after the dataset being\n  edited. This means that during the edit of FRED our expert\n  could type (for example) COPY JOBCARD and Edit will attempt to\n  get it either from the dataset being edited or the template.\n  The point is that all datasets given type J will have the\n  template dataset concatentated in this way, enabling the\n  simplifed DDF copy feature for any number of datasets\n\n  On taking a DDF member list of PROJ1.QUAL2.QUAL3.QUAL4 above,\n  the template dataset will again be concatentated, giving a list\n  of the combined members of the two datasets. For this reason\n  it's probably best to give all template members names beginning\n  with Z; this will ensure that they sort to the end of the list.\n  Note that you will be able to distinguish between members on\n  the main and template dataset by their level numbers (1 and 2,\n  respectively).\n./ ADD NAME=D3N      0100-02273-02273-0938-00069-00069-00000-GARDINR\nISPF 3.n operations\n\n  You can invoke ISPF options 3.1, 3.2, 3.3, 3.4, 3.6 and 3.14\n  under the CMD heading as shown here using 3.1 as an example.\n\n  Cmd Member   Text                     Description   Show\n  3.1 FRED     USERID.QUAL2.QUAL3.QUAL4\n  31  BILL     OTHERID.SOME.DATA.OR.OTHER\n\n  You can always omit the dot, as shown here on the second line.\n  DDF does not implement 3.5 (reset ISPF stats) or 3.12 (SuperC\n  compare) because both of these are implemented in a different\n  way within DDF(ST prefix command and the CPN/CPO prefix\n  commands, respectively).\n\n        In each case DDF will show the appropriate 3.n screen\n  with the dataset name field filled in, ready for action. You\n  can then carry on as if in normal ISPF, except that of course\n  you will not have to type in the names. 3.1, 3.2, 3.6 and 3.14\n  need no further explanation, but 3.3 and 3.4 need a bit more\n  information.\n\n  3.3\n\n  You use 3.3 in conjunction with TO or OV, like the single\n  member moves. You do not get the first (copy from) 3.3 screen\n  until both 3.3 and (one of) TO or OV has been entered:\n\n  Cmd Member   Text                     Description   Show\n  3.3 FRED     USERID.QUAL2.QUAL3.QUAL4\n  to  BILL     OTHERID.SOME.DATA.OR.OTHER\n\n  When it is shown, the copy from dataset name will have been\n  filled in and you can then select members for copy or move in\n  the normal 3.3 style. When you press enter, the 3.3 copy to\n  screen will be displayed, again with the to dataset name filled\n  in. The member name FRED will be used as a pattern.\n\n  3.4\n\n  You can select how many qualifiers you want 3.4 to use, like\n  this:\n\n  Cmd  Member   Text                     Description   Show\n       FRED     USERID.QUAL2.QUAL3.QUAL4\n  34 2 BILL     OTHERID.SOME.DATA.OR.OTHER\n  34 * BILL     OTHERID.SOME.DATA.OR\n  34   BILL     OTHERID.SOME.DATA.OR*\n\n  The 3.4 (or 34 as shown here - you can always omit the dots)\n  will give a dataset list using two qualifiers OTHERID.SOME. If\n  you just specify 34 without a number, the whole line will be\n  used as the qualifier.  Note that the member name is ignored in\n  this operation.\n\n        34 * will cause the line to be used a pattern rather than\n  a qualifier, like this\n\n  34 *          OTHERID.SOME.DATA.OR\n\n       shows    OTHERID.SOME.DATA.OR.OTHER\n       and      OTHERID.SOME.DATA.ORWHAT\n\n  34            OTHERID.SOME.DATA.OR\n       shows\n       only     OTHERID.SOME.DATA.OR.OTHER\n\n  You can put an * on the end of the line, as illustrated, to get\n  the same effect, in which case the * will remain on the line.\n./ ADD NAME=RGCONT   0100-02273-02273-0938-00012-00012-00000-GARDINR\n        Roy Gardiner\n        64 High Road\n      Buckhurst Hill\n       Essex IG9 5RW\n\n    044 20 8504 8267\n\n        In an attempt to reduce spam, I have stoped using\n    'mailto' in my HTML and encode my email address to be obvious\n    only to real readers:\n\n          gardiner at-sign btinternet dot com\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$INTRO": {"ttr": 1025, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00\\x00\\x01\\x02'?\\x01\\x02'?\\t8\\x009\\x009\\x00\\x00\\xc7\\xc1\\xd9\\xc4\\xc9\\xd5\\xd9@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-09-30T00:00:00", "modifydate": "2002-09-30T09:38:00", "lines": 57, "newlines": 57, "modlines": 0, "user": "GARDINR"}, "text": "Introduction\n\n  The idea of DDF is to speed up many of the normal jobs in ISPF\n  by eliminating the need to remember and then type dataset names\n  all the time.\n\n  DDF keeps a list of datasets, which you enter under the Text\n  heading above. Names can be in any order. Actions are entered\n  under the Cmd heading and include commands to\n\n     * edit a dataset (or member)\n     * browse a dataset (or member)\n     * display and edit member stats\n     * compare members\n     * copy a member from one dataset to another (optionally\n       changing name)\n     * compare and merge members\n     * find versions of members across many datasets\n     * submit jobs\n     * access ISPF functions including 3.1, 3.2, 3.3, 3.4, 3.14\n       (search for strings)\n     * produce member list and then within member list:\n\n          o submit batch job\n          o browse member\n          o edit member\n          o rename member\n          o delete member\n          o execute member.\n\n  What is DDF?\n\n  DDF is a Rexx exec and some ISPF panels, skeletons and\n  messages. There is no Assembler and no need to complile\n  anything. There are no tricks or dodges; all DDF functions are\n  standard ISPF which you can see (and modify if you need to) in\n  the code.\n\n       You do not need to be a systems programmer to install DDF;\n  anyone with modest knowledge of ISPF can set it up for personal\n  use, or for use by more than one person. DDF does not interfere\n  with your ISPF environment beyond requiring one exec to be\n  copied to a suitable command library. All other DDF libraries\n  remain separate from and therefore independent of your standard\n  session, and indeed are only available whilst DDF is running -\n  DDF uses LIBDEF to gain access to them.\n\n  Who uses DDF?\n\n  When DDF is made widely available, experience shows that that\n  up to 10% of a typical TSO/ISPF user population will use it\n  every day; some of these will use DDF as their standard front\n  screen, rather than having an ISPF main menu. The main users\n  seem generally to be to be development people rather than\n  systems programmers; the latter have often written any number\n  of shortcuts and tools for themselves and have their working\n  environments tailored perfectly to suit them.\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$PDSLOAD": {"ttr": 1027, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01\\x00\\x00(\\x01\\x02'?\\x01\\x02'?\\tE\\x00\\x0f\\x00\\x0f\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@\"", "ispf": {"version": "01.00", "flags": 0, "createdate": "2002-09-30T00:00:00", "modifydate": "2002-09-30T09:45:28", "lines": 15, "newlines": 15, "modlines": 0, "user": "SBGOLOB"}, "text": "//SBGOLOBL JOB (ACCT#),PDSLOAD,\n// NOTIFY=&SYSUID,\n// CLASS=A,MSGCLASS=X,COND=(1,LT)\n//*--------------------------------------------------------------*//\n//*    This job will create a partitioned dataset from the       *//\n//*    $$HELP member in this file.                               *//\n//*--------------------------------------------------------------*//\n//LOA1 EXEC PGM=PDSLOAD\n//STEPLIB  DD DISP=SHR,DSN=userid.FILE035.PDS\n//SYSUT1   DD DISP=SHR,DSN=userid.FILE594.PDS($$HELP)\n//SYSPRINT DD SYSOUT=*\n//SYSUT2   DD DISP=(NEW,CATLG,DELETE),DSN=userid.DDF.HELP,\n//   DCB=(RECFM=FB,LRECL=80,BLKSIZE=27920),\n//   SPACE=(TRK,(15,15,44),RLSE)\n//*\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "@FILE594": {"ttr": 1029, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x12\\x01\\x01\\x02_\\x01\\x02(\\x0f\\t\"\\x00M\\x00\\x02\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2001-01-25T00:00:00", "modifydate": "2002-10-07T09:22:12", "lines": 77, "newlines": 2, "modlines": 0, "user": "SBGOLOB"}, "text": "//***FILE 594 is the Dataset Display Facility (DDF) from Roy        *   FILE 594\n//*           Gardiner.  This is an ISPF-based workbench tool,      *   FILE 594\n//*           to make it easier to work on your own collection      *   FILE 594\n//*           of datasets.                                          *   FILE 594\n//*                                                                 *   FILE 594\n//*           email:  roy@roygardiner.com                           *   FILE 594\n//*                                                                 *   FILE 594\n//*      Introduction to DDF                                        *   FILE 594\n//*                                                                 *   FILE 594\n//*           Dataset Display Facility (DDF)                        *   FILE 594\n//*                                                                 *   FILE 594\n//*           DDF maintains a user-controlled list of dataset       *   FILE 594\n//*           names against which many standard operations may      *   FILE 594\n//*           be done.  It eliminates the constant typing and       *   FILE 594\n//*           re-typing of dataset names that ISPF users must       *   FILE 594\n//*           normally do and significantly reduces the number      *   FILE 594\n//*           of 'enter' keys needed for some common operations.    *   FILE 594\n//*                                                                 *   FILE 594\n//*           DDF is designed to save you time.  Almost all the     *   FILE 594\n//*           ISPF functions you need to perform against            *   FILE 594\n//*           datasets can be done faster from a DDF screen than    *   FILE 594\n//*           from a standard ISPF menu; habitual users keep the    *   FILE 594\n//*           DDF screen in use instead of an ISPF main menu.       *   FILE 594\n//*                                                                 *   FILE 594\n//*           functions provided include:                           *   FILE 594\n//*                                                                 *   FILE 594\n//*           -edit a dataset (or member)                           *   FILE 594\n//*           -browse a dataset (or member)                         *   FILE 594\n//*           -display and edit member stats                        *   FILE 594\n//*           -compare members                                      *   FILE 594\n//*           -copy a member from one dataset to another            *   FILE 594\n//*             (optionally changing name)                          *   FILE 594\n//*           -compare and merge members                            *   FILE 594\n//*           -find versions of members across many datasets        *   FILE 594\n//*           -submit jobs                                          *   FILE 594\n//*           -access ISPF functions including 3.1, 3.2, 3.3,       *   FILE 594\n//*                                            3.4, 3.14            *   FILE 594\n//*           -produce member list and then within member list:     *   FILE 594\n//*                submit batch job                                 *   FILE 594\n//*                browse member                                    *   FILE 594\n//*                edit member                                      *   FILE 594\n//*                rename member                                    *   FILE 594\n//*                delete member                                    *   FILE 594\n//*                execute member                                   *   FILE 594\n//*                                                                 *   FILE 594\n//*        What is DDF?                                             *   FILE 594\n//*                                                                 *   FILE 594\n//*        DDF is a Rexx exec and some ISPF panels, skeletons       *   FILE 594\n//*        and messages. There is no Assembler and no need to       *   FILE 594\n//*        complile anything. There are no tricks or dodges; all    *   FILE 594\n//*        DDF functions are standard ISPF which you can see        *   FILE 594\n//*        (and modify if you need to) in the code.                 *   FILE 594\n//*                                                                 *   FILE 594\n//*             You do not need to be a systems programmer to       *   FILE 594\n//*        install DDF; anyone with modest knowledge of ISPF can    *   FILE 594\n//*        set it up for personal use, or for use by more than      *   FILE 594\n//*        one person. DDF does not interfere with your ISPF        *   FILE 594\n//*        environment beyond requiring one exec to be copied to    *   FILE 594\n//*        a suitable command library. All other DDF libraries      *   FILE 594\n//*        remain separate from and therefore independent of        *   FILE 594\n//*        your standard session, and indeed are only available     *   FILE 594\n//*        whilst DDF is running - DDF uses LIBDEF to gain          *   FILE 594\n//*        access to them.                                          *   FILE 594\n//*                                                                 *   FILE 594\n//*        Who uses DDF?                                            *   FILE 594\n//*                                                                 *   FILE 594\n//*        When DDF is made widely available, experience shows      *   FILE 594\n//*        that that up to 10% of a typical TSO/ISPF user           *   FILE 594\n//*        population will use it every day; some of these will     *   FILE 594\n//*        use DDF as their standard front screen, rather than      *   FILE 594\n//*        having an ISPF main menu. The main users seem            *   FILE 594\n//*        generally to be to be development people rather than     *   FILE 594\n//*        systems programmers; the latter have often written       *   FILE 594\n//*        any number of shortcuts and tools for themselves and     *   FILE 594\n//*        have their working environments tailored perfectly to    *   FILE 594\n//*        suit them.                                               *   FILE 594\n//*                                                                 *   FILE 594\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "HELPTEXT": {"ttr": 1032, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01\\x00\\x1f\\x01\\x01\\x00\\x1f\\x00\\x00\\x00\\xf4\\x00\\x00\\x00\\x00\\xe9\\xe9\\xe9\\xe9\\xe9\\xe9\\xe9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-01-01T00:00:00", "modifydate": "2001-01-01T00:00:00", "lines": 244, "newlines": 0, "modlines": 0, "user": "ZZZZZZZ"}, "text": "CMD A\nSHORT Move a display line after this line (see also M, B4).\nWHERE  line prefix area\nCMD ACT\nSHORT Action the line as a sequence of ISPF commands\nWHERE  line prefix area\nCMD ADD ALLOC\nSHORT Produce a list of all DDnames allocated to the ISPF session.\nWHERE  command line\nA scrollable list is produced of all DDnames allocated to the\nsession.\nCommand-line commands available are:\nL <ddname> to line up to\none of the DDnames;\nPrefix area commands\navailable are:\nS to select a dataset name for permanent addition to the DDF display.\nCMD ADD <prefix>\nSHORT Produce a list of all datasets with the HLQ of <prefix>\nWHERE  command line\nA scrollable list is produced of all datasets with high level\nqualifier of <prefix>.\nPrefix area commands\navailable are: S to select a dataset name\nfor permanent addition to the DDF\ndisplay.\nCMD B\nSHORT Browse the data set\nWHERE  line prefix area\nIf no member is provided, a member\nlist is produced. If a member is provided but does not exist,\nit is used as a pattern; that is, a member list is provided\nof all members\nhaving names starting with the specified characters.\nCMD B4\nSHORT Move a display line before this line (see also M, A).\nWHERE  line prefix area\nA display line is moved Before the line with\nB4 in the prefix area. B4 used so as not to cause confusion\nwith the B (Browse) prefix command.\nCMD CANcel\nSHORT End without saving the display\nWHERE  command line\nCMD CO\nSHORT Copy the specified member (see also MO, OV, TO)\nWHERE  line prefix area\nCopy this member. If used with OV, wil overlay the target member\nif it exists. If used with TO, will not copy\nif the target member already exists.\nCMD COMP\nSHORT compress this data set\nWHERE  line prefix area\nCMD CPN\nSHORT Compare function, new data set (See also CPO, NEW, OLD).\nWHERE  line prefix area\nNote that if the same member name is to be used for\nCPN or CPO, it need only be entered in one.\nCMD CPO\nSHORT Compare function, old data set (See also CPN, NEW, OLD).\nWHERE  line prefix area\nNote that if the same member name is to be used for\nCPN or CPO, it need only be entered in one.\nCMD D\nSHORT Delete this row (no Dn facility is provided)\nWHERE  line prefix area\nD does not delete any following hidden lines;\neach line must be deleted\nindividually.\nCMD DEL\nSHORT Delete a member of a data set.\nWHERE  line prefix area\nThe member is deleted and a message is issued.\nCMD E\nSHORT Edit the dataset (see also B).\nWHERE  line prefix area\nEdit the data set. If no member is provided, a member\nlist is produced. If a member is provided but does not exist,\nit is created.\nCMD Find\nSHORT From DDF display: Find <name> <type>. Find member within DDF type.\nWHERE  command line\nCheck if member <name> is present on\nany of the data sets of type <type>. You might have type SC\nfor all Script datasets so F FRED SC would search\nonly the type SC data sets for the member FRED.\nOnly those data sets where <name> was found\nremain on the display. ISPF stats are displayed wherever the member\nis found. PF3 sends the display back to  the normal DDF screen.\nNote that DDF searches all the datasets of the type\nspecified, irrespective of whether they are migrated by HSM or not.\nIf you search a lot of migrated datasets, response time will go up.\nCMD Heads\nSHORT Show only the first line of each of the Show fields.\nWHERE  command line\nAll lines are excluded other than the first\nin each Show group.\nThis has the effect of minimising the display.\nSee also the SH and HI line commands.\nCMD HI\nSHORT Hide following lines that have the same Show field (See also SH).\nWHERE  line prefix area\nThis commands hides all subsequent lines with the same Show\nfield as the one on which the HI is entered.\nCMD In\nSHORT Insert n lines\nWHERE  line prefix area\nCMD M\nSHORT Move this line (see also A, B4).\nWHERE  line prefix area\nIf you move a line to\nafter a line with a different Show field, the line moved changes\nto match the one after which it has moved.\nCMD ML\nSHORT Provide full member list (see also E and B).\nProvide a member list for the data set.\nML always provides a full list of the members of a data set,\nie. the member field is ignored.\nIf a template dataset is present, its members are also listed.\nWithin member list, the prefix commands E (edit) B (browse) R (rename)\nDELETE and EX (Execute) are available. E <membername> or B <membername>\ncan be entered on the command line.\nCMD MO\nSHORT Move a member to another dataset (see also CO, OV and TO)\nWHERE  line prefix area\nIf used with OV, will overlay\nany target member, if used with TO will not overlay the target if\nit already exists.\nCMD OV\nSHORT Target of MO (move) or CO (copy, see also TO)\nWHERE  line prefix area\nIf the to member is not specified, the name\nwill be the same as on the From data set.\nIf the member already exists it will be overwritten.\nCMD LA\nSHORT List all allocated datasets.\nWHERE  command line\nCommand line commands available:\nF <membername> <ddname> to find a member\nwithin one of the allocated DDnames.\nAll occurrences\nare shown, with their ISPF stats;\nL <ddname> to\nLine the display up against the specified DDname\nPrefix commands available:\nB to browse a member.\nOnly valid after F command\nUse PF3 to return to the normal DDF display.\nCMD MRG\nSHORT Invoke SuperC compare (extended) where this is the result version\nWHERE  prefix area\nThis command makes the specified dataset made known to the\nextended SuperC dialog as the target for the Merge operation. This\nparameter is optional.\nCMD NEW\nSHORT Invoke SuperC compare (extended) where this is the new version\n(See also OLD, CPN, CPO)\nWHERE  prefix area\nThis command makes the specified dataset made known to the\nextended SuperC dialog as the New dataset. Use the extended SuperC\ndialog when you want to select the compare columns or if you\nwant to merge two files to create a third.\nCMD OLD\nSHORT Invoke SuperC compare (extended) where this is the old version\n(See also NEW)\nWHERE  prefix area\nThis command makes the specified dataset made known to the\nextended SuperC dialog as the New dataset. Use the extended SuperC\ndialog when you want to select the compare columns or if you\nwant to merge two files to create a third.\nCMD Reset\nSHORT Show all lines on the DDF display.\nWHERE  command line\nCMD Rn\nSHORT Repeat n rows\nWHERE  line prefix area\nCMD SH\nSHORT Show following lines with the same Show field value(See also HI).\nWHERE  line prefix area\nCMD SHow <list>\nSHORT Select which Show values are to be displayed\nWHERE  command line\n<list> contains a list of Show values. Each display line is\nshown where it has a Show value on the list.\nThis is a method of showing only selected lines.\nTo reset the display use either Reset or Heads commands.\nCMD ST\nSHORT Display ISPF stats for the selected member.\nWHERE  line prefix area\nThis avoids having to\nget a member list to see that information.\nYou can type UPDATE to change the stats.\nCMD SUB\nSHORT Submit the member, or complete dataset, as an MVS job\nWHERE  line prefix area\nNo check is made to ensure that what is submitted is correct JCL.\nCMD SORT <heading>\nSHORT Sort the table by one of the headings.\nWHERE  command line\nCMD TEMPL\nSHORT View list of template libraries,\nWHERE  command line\nThe template libraries are included whenever an Edit is done\nwithin DDF on a dataset with the approriate Type.\nWhen you type copy <member> on the ISPF command line,\nboth the dataset being edited and the template library are searched.\nFrequently needed items can be kept on the template library for\neasy copying when needed.\nYou will note that the template library members are also listed\nwhen you select a member list. They can be identified by the level\nnumber under the 'lib' heading being greater than 1.\nThe member names in the template libraries supplied with DDF all\nstart with Z.\nCMD TO\nSHORT Target of MO (move) or CO (copy, see also OV)\nWHERE  line prefix area\nUsed with MO (move) or CO (copy) to specify the target data set.\nIf the to member is not specified, the name\nwill be the same as on the From data set. The Copy/Move is not done if\nthe member already exists.\nCMD X\nSHORT Exclude the line from the display.\nWHERE  line prefix area\nCMD 3.1 or 31\nSHORT Invoke the standard 3.1 utility with the DSN filled in.\nWHERE  line prefix area\nCMD 3.2 or 32\nSHORT Invoke the standard 3.2 utility with the DSN filled in.\nWHERE  line prefix area\nCMD 3.3 or 33\nSHORT Invoke the standard 3.3 utility with the From DSN filled in.\nWHERE  line prefix area\nUse in conjunction with TO to get the To DSN filled in as well.\nCMD 3.4 or 34\nSHORT Invoke the standard 3.4 utility using the data set prefix provided.\nWHERE  line prefix area\nIf you enter 3.4 n where n is in the range 1-4 this provides the\nlevel at which 3.4 is to be provided. So if the dataset is\nAA.BB.CC.DD then 3.4 1 will do a 3.4 of all AA data sets\n3.4 2 of all AA.BB data sets, and so on. 4 is the maximium level\nallowed. Entering 3.4 n where less than n qualifiers exist will\ncause a 3.4 error.\nCMD 3.14 or 314\nSHORT Invoke the SuperC find panel with the DSN filled in.\nWHERE  line prefix area\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ISRML000": {"ttr": 1037, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01\\x00\\x1f\\x01\\x01\\x00\\x1f\\x00\\x00\\x00_\\x00\\x00\\x00\\x00\\xe9\\xe9\\xe9\\xe9\\xe9\\xe9\\xe9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-01-01T00:00:00", "modifydate": "2001-01-01T00:00:00", "lines": 95, "newlines": 0, "modlines": 0, "user": "ZZZZZZZ"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "ISRSFSPR": {"ttr": 1040, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01\\x00\\x1f\\x01\\x01\\x00\\x1f\\x00\\x00\\x01\\x0c\\x00\\x00\\x00\\x00\\xe9\\xe9\\xe9\\xe9\\xe9\\xe9\\xe9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-01-01T00:00:00", "modifydate": "2001-01-01T00:00:00", "lines": 268, "newlines": 0, "modlines": 0, "user": "ZZZZZZZ"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "ISRUDA2S": {"ttr": 1285, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01\\x00\\x1f\\x01\\x01\\x00\\x1f\\x00\\x00\\x00\\xbb\\x00\\x00\\x00\\x00\\xe9\\xe9\\xe9\\xe9\\xe9\\xe9\\xe9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-01-01T00:00:00", "modifydate": "2001-01-01T00:00:00", "lines": 187, "newlines": 0, "modlines": 0, "user": "ZZZZZZZ"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "ISRUMC1": {"ttr": 1289, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01\\x00\\x1f\\x01\\x01\\x00\\x1f\\x00\\x00\\x00\\xc8\\x00\\x00\\x00\\x00\\xe9\\xe9\\xe9\\xe9\\xe9\\xe9\\xe9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-01-01T00:00:00", "modifydate": "2001-01-01T00:00:00", "lines": 200, "newlines": 0, "modlines": 0, "user": "ZZZZZZZ"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "ISRUMC2A": {"ttr": 1537, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01\\x00\\x1f\\x01\\x01\\x00\\x1f\\x00\\x00\\x00O\\x00\\x00\\x00\\x00\\xe9\\xe9\\xe9\\xe9\\xe9\\xe9\\xe9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-01-01T00:00:00", "modifydate": "2001-01-01T00:00:00", "lines": 79, "newlines": 0, "modlines": 0, "user": "ZZZZZZZ"}, "text": ")ATTR\n  \u00ac TYPE(INPUT) INTENS(NON)\n  @ TYPE(OUTPUT) INTENS(LOW) CAPS(OFF)  /*                       @M1C*/\n)BODY\n%&ZUMODE --- FROM &DSNI&ZUPMEMB (DDF modified version) -------------------------\n%COMMAND ===>_ZCMD                                                             +\n+\n+SPECIFY%\"TO\"+DATA SET BELOW.\n%\n+TO ISPF LIBRARY:\n+   PROJECT%===>_PROJ2   +\n+   GROUP  %===>_LIBR2   +\n+   TYPE   %===>_TYPE2   +\n+   MEMBER %===>_MEMB2   + &PRMPT                                   +\n+\n+TO OTHER PARTITIONED OR SEQUENTIAL DATA SET:\n+   DATA SET NAME %===>_DSN2\n+   VOLUME SERIAL %===>_VOL2  +  (If not cataloged)\n+\n+DATA SET PASSWORD%===>\u00acPSWD2   +(If password protected)\n+\n+\"TO\" DATA SET OPTIONS:\n+   IF PARTITIONED, REPLACE LIKE-NAMED MEMBERS%===>_ZURPL+ (YES or NO)\n+   IF SEQUENTIAL, \"TO\" DATA SET DISPOSITION  %===>_ZUOM + (OLD or MOD)\n+   SPECIFY PACK OPTION FOR \"TO\" DATA SET     %===>_ZUPO + (YES, NO or blank)\n)INIT\n  /* DDF modifications -- start                                      */\n  vget (dsn2)\n  /* DDF modifications -- end                                        */\n  &ZCMD = &Z\n  .HELP = ISR33021\n  &ZUOM = TRANS (&ZUSD M,'MOD' O,'OLD')                     /* OZ93212 */\n  &ZURPL = TRANS (&ZUREP Y,'YES' N,'NO' *,*)\n  &ZUPO = TRANS (&ZUPK Y,'YES' N,'NO' *,*)\n  &PRMPT = TRANS (&PROMPT S,' ' P,'(Blank unless member is to be renamed)')\n                                        /*                       @M1C*/\n)PROC\n  /* DDF modifications -- start                                      */\n  vput (dsn2)\n  /* DDF modifications -- end                                        */\n  IF (&DSN2 = ' ')\n    VER (&PROJ2,NB)\n    VER (&LIBR2,NB)\n    VER (&TYPE2,NB)\n  IF (&DSN2 \u00ac= ' ')\n    &ZFC = TRUNC(&DSN2,1)               /* IF FIRST CHARACTER     @M2A*/\n    IF (&ZFC = '''')                    /*  OF DSN IS \"'\" CHECK   @M2A*/\n      &ZREM = .TRAIL                    /*  TO SEE IF LAST \"'\"    @M2A*/\n      &ZREM2 = TRUNC(&ZREM,'''')        /*  IS MISSING.           @M2A*/\n      IF (&ZREM2 = &ZREM)               /*  IF LAST \"'\" MISSING   @M2A*/\n        &DSN2 = '&DSN2&ZFC'             /*    ADD IT TO THE END   @M2A*/\n    VER (&DSN2,DSNAME)\n  &ZUREP = TRUNC (&ZURPL,1)\n  &ZURPL = TRANS (&ZUREP Y,'YES' N,'NO' *,*)\n  VER (&ZURPL,LIST,YES,NO)\n  &ZUSD = TRUNC (&ZUOM,1)\n  &ZUOM = TRANS (&ZUSD M,'MOD' O,'OLD')                    /* OZ93212 */\n  VER (&ZUOM,LIST,MOD,OLD)\n  &ZUPK = TRUNC (&ZUPO,1)\n  VER (&ZUPK,LIST,Y,N)\n  &PROMPT = TRANS (&PRMPT ' ',S '(Blank unless member is to be renamed)',P)\n                                        /*                        @M1C*/\n  VPUT ( PROJ2 LIBR2 TYPE2 ZUREP ZUSD ) PROFILE\n)END\n /*                                                                   */\n /* \u00a2SEG(ISRUMC2A)   COMP(MOVECOPY)   PROD(MVS)                      */\n /*                                                                   */\n /* CHANGE ACTIVITY                                                   */\n /*  \u00a2L0= UNFLAGED PRE230                    :                        */\n /*  \u00a2M1= FUNCTION  M230     860909   158590 : Function test PTM      */\n /*   PTM00000142                                                     */\n /*                                                                   */\n /*  \u00a2M2= TRAILQ    M310     881102   641747 :                        */\n /*                                                                  */\n /*  OY16274 - 880922 - The English panel on a KN terminal displays  */\n /*                     lowercase garbage at the @PRMPT note beside  */\n /*                     the member field.   GT4045 - SJW             */\n /*                                                                  */\n/* 5665-402 (C) COPYRIGHT IBM CORP 1980, 1989 */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ISRUMC2B": {"ttr": 1540, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01\\x00\\x1f\\x01\\x01\\x00\\x1f\\x00\\x00\\x00\\xd4\\x00\\x00\\x00\\x00\\xe9\\xe9\\xe9\\xe9\\xe9\\xe9\\xe9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-01-01T00:00:00", "modifydate": "2001-01-01T00:00:00", "lines": 212, "newlines": 0, "modlines": 0, "user": "ZZZZZZZ"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "UTCDSM5": {"ttr": 1545, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01\\x00\\x1f\\x01\\x01\\x00\\x1f\\x00\\x00\\x08\\x91\\x00\\x00\\x00\\x00\\xe9\\xe9\\xe9\\xe9\\xe9\\xe9\\xe9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-01-01T00:00:00", "modifydate": "2001-01-01T00:00:00", "lines": 2193, "newlines": 0, "modlines": 0, "user": "ZZZZZZZ"}, "text": "/* Rexx  with thanks to Mike Cowlishaw of IBM */\n/**********************************************************************/\n/*                                                                    */\n/* Dataset Display Facility (DDF)                                     */\n/* -------------------------------                                    */\n/*                                                                    */\n/* Provide shortcuts into as many ISPF facilities as possible         */\n/*                                                                    */\n/* This program is copyright of Roy Gardiner gardiner@btinternet.com  */\n/*                                           www.roygardiner.com      */\n/*                                                                    */\n/*                                                                    */\n/* You may (and are very welcome to):                                 */\n/*                                                                    */\n/* - use and modify this program as you please                        */\n/* - send me bug reports and improvement suggestions to the above     */\n/*   email address. All dealt with on an as-and-when basis            */\n/* - redisribute this program and its components unchanged            */\n/*                                                                    */\n/* You are not allowed to:                                            */\n/*                                                                    */\n/* - resell this program or any part of it                            */\n/* - incorporate this program or any part of it in a product which    */\n/*   is to be sold.                                                   */\n/* - redisribute this program if it or any of its components have     */\n/*   been changed                                                     */\n/**********************************************************************/\n                             /* Editable variables -- start           */\n  genHLQ           = \"hlq1\"\n  genLev2Q         = \"hlq2\"\n                             /* Optional user survey dataset          */\n  surveyDsn        = genHLQ\".\"genLev2Q\".SURVEY\"\n                             /* Optional user FAQ dataset             */\n  FaqDsn           = genHLQ\".\"genLev2Q\".FAQ\"\n                             /* Editable variables -- end             */\n  arg argstr\n                             /* Debug on?                             */\n\n  if pos(\"DEBUG\",argstr) \\= 0\n  then trace all\n  else\n  do\n     a = msg(\"OFF\")\n     a = prompt(\"OFF\")\n  end\n\n  address \"ISPEXEC\"\n                             /*****************************************/\n                             /* Section:1  General setting up         */\n                             /*****************************************/\n                             /* general variables                     */\n  oper.b = \"BROWSE\"\n  oper.e = \"EDIT\"\n  oper.v = \"VIEW\"\n\n  library = \"ISPPROF\"\n  today = date()\n  ListNames = \"NAMES(LMEM LSTATS LDDNAME LDSN LADDED LASHOW LATYPE)\"\n                             /* panel, message and table libraries    */\n  yplib            = genHLQ\".\"genLev2Q\".DDFLIB\"\n  ymlib            = genHLQ\".\"genLev2Q\".DDFLIB\"\n  yslib            = genHLQ\".\"genLev2Q\".DDFLIB\"\n  dsmtlib          = genHLQ\".\"genLev2Q\".DDFLIB\"\n                             /* SuperC variables                      */\n  SuperCforCompare = \"LINECMP,DELTAL,NOPRTCC\"\n  SuperCforMerge   = \"LINECMP,DELTAL,UPDLDEL,NOPRTCC\"\n                             /* action compare; set to M for merge    */\n  SuperCAction     = \"\"\n                             /* target dataset for SuperC merge       */\n  mrgdsn           = \"\"\n  mrgmem           = \"\"\n                             /* ISPF error message defaults           */\n  zerrsm           = \"\"\n  zerrlm           = \"\"\n                             /* Table Extension variables             */\n  tsave            = \"\"\n                             /* current version search table          */\n  vTable        = \"\"\n                             /* Sort defaults for main table          */\n  sort_fields      = \"YSHOW,CH,A,YLINE,N,A\"\n  syspref          = sysvar(\"SYSPREF\")\n  sysuid           = sysvar(\"SYSUID\")\n                             /* Initial table set up                  */\n  \"TBSTATS UTTDSM5 STATUS1(STATUS1) STATUS2(STATUS2) LIBRARY(\"library\")\"\n                             /* Attempted recursive entry?            */\n  if status2 = 5 then\n  do\n                             /* Yes, abandon ship                     */\n     \"SETMSG MSG(UTMDD041)\"\n     signal VeryQQuit\n  end\n                             /* panel, message and table libraries    */\n  \"LIBDEF ISPPLIB DATASET ID('\"yplib\"')\"\n  \"LIBDEF ISPMLIB DATASET ID('\"ymlib\"')\"\n  \"LIBDEF ISPSLIB DATASET ID('\"yslib\"')\"\n  \"LIBDEF PARMLIB DATASET ID('\"dsmtlib\"')\"\n                             /* error handling                        */\n  \"CONTROL ERRORS RETURN\"\n  Zerrlm = \"\"\n  rc = 0\n  AcceptCCMax = 14\n  AcceptCC = AcceptCCMax\n  call on error name Error\n  call on failure name Error\n                             /* User survey being done?               */\n  if sysdsn(\"'\"surveydsn\"'\") = \"OK\" then\n  do\n                             /* yes, user already answered?           */\n     if sysdsn(\"'\"surveydsn\"(\"sysuid\")'\") \\= \"OK\" then\n     do\n                             /* no, copy in survey template           */\n        \"LMINIT   DATAID(SOURCE) DATASET('\"surveydsn\"')\"\n        \"LMINIT   DATAID(TARGET) DATASET('\"surveydsn\"')\"\n        \"LMOPEN   DATAID(\"source\")\"\n        \"LMCOPY   FROMID(\"source\") FROMMEM(ZTEMPLAT)\" ,\n                  \"TODATAID(\"target\") TOMEM(\"sysuid\") REPLACE\"\n        \"LMCLOSE  DATAID(\"source\")\"\n        \"LMFREE   DATAID(\"source\")\"\n        \"LMFREE   DATAID(\"target\")\"\n     end\n                             /* count the number of times this user   */\n                             /* has used DDF; use STATS to do it      */\n                             /* on the Modified Records area          */\n     \"LMINIT   DATAID(SOURCE) DATASET('\"surveydsn\"')\"\n     \"LMOPEN   DATAID(\"source\")\"\n     \"LMMFIND  DATAID(\"source\") MEMBER(\"sysuid\") STATS(YES)\"\n     if zlvers \\= 99  then\n     do\n        zlvers = 99\n        zlmnorc = 0\n     end\n                             /* Stick at the maximum!                 */\n     zlmnorc = min(zlmnorc + 1,65535)\n                             /* poll opinions after ever more         */\n                             /* invocations of the product            */\n     if zlmnorc = 10    | ,\n        zlmnorc = 50    | ,\n        zlmnorc = 100   | ,\n        zlmnorc = 500\n     then\n     do\n                             /* survey explanation panel              */\n        if zlmnorc = 10\n        then \"DISPLAY PANEL(UTPDSM5X)\"\n        else \"SETMSG MSG(UTMDD091)\"\n                             /* edit survey template. If user fails   */\n                             /* to reply, stats will be unchanged     */\n        \"EDIT     DATASET('\"surveydsn\"(\"sysuid\")')\"\n     end\n                             /* set stats (or reset after edit)       */\n     \"LMMSTATS DATAID(\"source\") MEMBER(\"sysuid\")\" ,\n             \"VERSION(\"zlvers\") MODRECS(\"zlmnorc\")\"\n     \"LMCLOSE  DATAID(\"source\")\"\n     \"LMFREE   DATAID(\"source\")\"\n  end\n                           /* Set up 'unique' high level qualifier    */\n                           /* clearly marked as temporary             */\n  if syspref \u00ac= sysuid\n  then tmphlq = syspref\".\"sysuid\n  else tmphlq = syspref\n  xmvhlq = tmphlq\".TEMP.T\"time(\"S\")\n\n  \"VPUT (XMVHLQ) SHARED\"\n                             /* User profile parameters               */\n  parms = \"YTLIB YSCROLL STSHOW YEDIT\"\n  ytlib   = \"\"\n  yscroll = \"\"\n  stshow  = \"\"\n  \"VGET (\"parms\") PROFILE\"\n  \"VGET (ZUSER ZSCREEN) SHARED\"\n  pshow   = stshow\n                             /* Are lines where the SHOW field is     */\n                             /* blank always to be shown?             */\n  if yshblank = \"\"\n  then yshblank = \"YES\"\n                             /* Is Edit recovery required?            */\n  recover = \"YES\"\n  do while recover = \"YES\"\n                             /*         don't abort if EDREC fails    */\n     AcceptCC = 20\n     \"EDREC QUERY\"\n     if rc = 4 then\n     do\n                             /* Yes, recover datasets before doing    */\n                             /*      anything else                    */\n        \"SETMSG MSG(UTMDD011)\"\n        \"EDREC PROCESS\"\n     end\n     else recover = \"NO\"\n     AcceptCC = AcceptCCMax\n  end\n                             /* see earlier TBSTATS command for       */\n                             /* status1 setting                       */\n  if status1 > 1 then\n  do\n     \"TBCREATE UTTDSM5 NAMES(YMEM\"  ,/* Member for display            */\n                            \"YOMEM\" ,/* Old member (for after find)   */\n                            \"YTEXT\" ,/* DSname/Action list            */\n                            \"YDESC\" ,/* Description of DSlist         */\n                            \"YDISPL\",/* YES/NO for display            */\n                            \"YTYPE\" ,/* Type (for find)               */\n                            \"YSHOW\" ,/* Show text                     */\n                            \"YLINE\" ,/* Line number for sort          */\n                   \") REPLACE LIBRARY(\"library\")\"\n     ymem    = \"\"\n     yomem   = \"\"\n     ytext   = \"\"\n     ydesc   = \"\"\n     ytype   = \"\"\n     yshow   = \"\"\n     ytstats = \"\"\n     ydispl = \"YES\"\n     \"TBADD UTTDSM5\"\n  end\n  else \"TBOPEN  UTTDSM5  LIBRARY(\"library\") SHARE\"\n                             /* DDF command summary table, for HELP   */\n  \"TBOPEN  UTTHELP  LIBRARY(\"parmlib\") SHARE NOWRITE\"\n                             /* Open or create user's template table  */\n  \"TBSTATS UTTEMPL STATUS1(STATUS1) LIBRARY(\"library\")\"\n  if status1 > 1 then\n  do\n     \"TBCREATE UTTEMPL NAMES(YDSNT YTYPET) LIBRARY(\"library\")\"\n     \"TBADD    UTTEMPL\"\n  end\n  else \"TBOPEN  UTTEMPL  LIBRARY(\"library\") SHARE\"\n                             /* the template table contains DSNs and  */\n                             /* Types. For each type specified, the   */\n                             /* DSN is concatenated to any dataset on */\n                             /* the list of the same type when that   */\n                             /* dataset is browsed or edited          */\n  call TemplBuild\n\n  \"TBTOP   UTTDSM5\"\n  \"TBQUERY UTTDSM5 NAMES(NAMES)\"\n  parse var names \"(\" names \")\"\n                             /* set up for move/copy where YSHOW is   */\n                             /* not move/copied but inherited from    */\n                             /* the target line's value               */\n  i = wordpos(\"YSHOW\",names)\n  names_less_yshow = delword(names,i,1)\n                             /* main display panel                    */\n  csrrow = 0\n  panel  = \"PANEL(UTPDSM5)\"\n  \"SETMSG MSG(UTMDD099)\"\n                             /* Section:2  Main table display loop    */\n                             /*****************************************/\n                             /* Continue after severe errors          */\n  AcceptCC = AcceptCCMax\n                             /* YDISPL controls which table rows are  */\n                             /* shown on the display panel            */\n  \"TBVCLEAR UTTDSM5\"\n  ydispl = \"YES\"\n  \"TBSARG   UTTDSM5 NAMECOND(YDISPL,EQ)\"\n  do while finished \\= \"YES\"\n\n     \"CONTROL ERRORS RETURN\"\n     \"TBDISPL  UTTDSM5\" panel \"CSRROW(\"csrrow\") AUTOSEL(NO)\"\n     tbrc = rc\n     panel = \"\"\n                             /* END command or PF3? and no Find       */\n                             /* function in progress?                 */\n     if tbrc = 8 & find \\= \"YES\" then\n     do\n                             /* Yes, get ready to exit                */\n        zcmd = \"\"\n        finished = \"YES\"\n     end\n                             /* END command from find, or forced end  */\n                             /* of find command?                      */\n     if (tbrc = 8 & find = \"YES\") | endfind = \"YES\" then\n     do\n        endfind = \"\"\n                             /* restore all the member names that     */\n                             /* were on the display before the FIND   */\n        tsave = \"\"\n        find = \"\"\n        \"TBTOP  UTTDSM5\"\n        \"TBVCLEAR UTTDSM5\"\n        yomem = \"\"\n        \"TBSARG UTTDSM5 NAMECOND(YOMEM,NE)\"\n        \"TBSCAN UTTDSM5\"\n        do while rc = 0\n           ymem = yomem\n           yomem = \"\"\n           \"TBPUT UTTDSM5\" tsave\n           \"TBSCAN UTTDSM5\"\n        end\n        panel = \"PANEL(UTPDSM5)\"\n                             /* reset normal display parameters       */\n        \"TBTOP     UTTDSM5\"\n        \"TBVCLEAR UTTDSM5\"\n        ydispl = \"YES\"\n        \"TBSARG UTTDSM5 NAMECOND(YDISPL,EQ)\"\n     end\n                             /* process all prefix area commands      */\n     do while ztdsels > 0\n        \"TBQUERY UTTDSM5 POSITION(CSRROW)\"\n                             /* Save row values entered on screen     */\n        \"VPUT (\"names\") SHARED\"\n                             /* Get values from table                 */\n        \"TBGET   UTTDSM5\"\n                             /* Store table SHOW value                */\n        oldshow = yshow\n                             /* Get back values entered on screen     */\n                             /* and put them onto the table           */\n        \"VGET (\"names\") SHARED\"\n                             /* Save Show value entered by user       */\n        newshow = yshow\n        \"TBPUT UTTDSM5\" tsave\n        \"TBSKIP UTTDSM5\"\n                             /* If the SHOW value is changed, any     */\n                             /* following hidden lines with the       */\n                             /* same Show value must also have        */\n                             /* their values changed                  */\n        do while    ydispl = \"NO\"       ,\n                 &  yshow = oldshow     ,\n                 &  rc = 0\n           yshow = newshow\n           \"TBPUT  UTTDSM5\" tsave\n           \"TBSKIP UTTDSM5\"\n        end\n                             /* Restore table position                */\n        \"TBTOP  UTTDSM5\"\n        \"TBSKIP UTTDSM5 NUMBER(\"csrrow\")\"\n        parse var ymem ymem \" \" .\n                             /* Section:3  Prefix (or line) commands  */\n                             /*****************************************/\n                             /*   SS:3 Linecmd:E Linecmd:B            */\n        select\n           when linecmd = \"E\" | linecmd = \"B\" | linecmd = \"V\" then\n           do\n                             /*   SS:3 Linecmd:E                      */\n              if linecmd = \"E\"\n              then oper = \"EDIT\"\n              else if linecmd = \"V\"\n              then oper = \"VIEW\"\n              else oper = \"BROWSE\"\n                             /* Does the dataset exist?               */\n              listrc = listdsi(\"'\"ytext\"'\")\n              reason = sysreason\n              if listrc = 0 then\n              do\n                             /* Yes, is it sequential?                */\n                 if sysdsorg = \"PS\" then\n                 do\n                             /* Yes, edit/browse directly             */\n                    \"CONTROL DISPLAY SAVE\"\n                    oper \"DATASET('\"ytext\"')\"\n                    \"CONTROL DISPLAY RESTORE\"\n                 end\n                 else\n                 do\n                             /* No, not sequential, assume a PDS      */\n                    xxdsn  = \"'\"ytext\"(\"ymem\")'\"\n                             /* Force member list?                    */\n                    if ymem = \"\" | pos(\"*\",ymem) \\= 0\n                    then call mlist\n                    else\n                    if  sysdsn(xxdsn) = OK | oper = \"EDIT\" then\n                    do\n                             /* Pick up template dataset, ensuring no */\n                             /* conflict with the other ISPF session  */\n                       lookdd = \"LOOK\"zscreen\n                       address \"TSO\" \"ALLOC DD(\"lookdd\")\"            ,\n                                     \"DA('\"ytext\"'\" templ.ytype\")\"  ,\n                                     \"SHR REUSE\"\n                       \"LMINIT DATAID(LOOKAT) DDNAME(\"lookdd\")\"\n\n                             /* get stats for member                  */\n                       call GetISPFStats lookat ymem \"OPEN\"\n\n                             /* browse/edit member with stats message */\n                       \"CONTROL DISPLAY SAVE\"\n                       \"SETMSG MSG(\"sMessage\") COND\"\n                       oper \"DATAID(\"lookat\") MEMBER(\"ymem\")\"\n                       if rc > 8 then\n                       \"SETMSG MSG(UTMDD010)\"\n                       sMessage = \"\"\n                       \"CONTROL DISPLAY RESTORE\"\n\n                       \"LMFREE DATAID(\"lookat\")\"\n                       address \"TSO\" \"FREE DD(\"lookdd\")\"\n                    end\n                             /* If no member match exists, use the    */\n                             /* name as a pattern for member list     */\n                    else call mlist\n                 end\n              end\n                             /* Display LISTDSI error message         */\n              else \"SETMSG MSG(UTMDD014)\"\n           end\n                             /* Member list forced                    */\n                             /*   SS:3 Linecmd:ML member list         */\n           when linecmd = \"ML\" then\n           do\n              oper = \"BROWSE\"\n              call mlist\n           end\n                             /* ISPF 3.1                              */\n                             /*   SS:3 Linecmd:31 linecmd:3.1         */\n           when linecmd = 31 then\n           do\n                             /* Save DSN and invoke ISPF              */\n              dsn = \"'\"ytext\"'\"\n              \"VPUT (DSN) SHARED\"\n              \"CONTROL DISPLAY SAVE\"\n              \"SELECT  PGM(ISRUDA) PARM(UTPDSM5D)\"\n              \"CONTROL DISPLAY RESTORE\"\n           end\n                             /* ISPF 3.2                              */\n                             /*   SS:3 Linecmd:32 linecmd:3.2         */\n           when linecmd = 32 then\n           do\n                             /* Save DSN and invoke ISPF              */\n              dsn = \"'\"ytext\"'\"\n              \"VPUT (DSN) SHARED\"\n              \"CONTROL DISPLAY SAVE\"\n              \"SELECT  PGM(ISRUDA) PARM(ISRUDA2)\"\n              \"CONTROL DISPLAY RESTORE\"\n           end\n                             /* ISPF 3.3 (process FROM dataset)       */\n                             /*   SS:3 Linecmd:33 linecmd:3.3         */\n           when linecmd = 33 then\n           do\n              copy33 = \"YES\"\n                             /* Member specified?                     */\n              if ymem = \"\"\n              then  xdsn1 = \"'\"ytext\"'\"\n              else\n              do\n                             /* Yes, append patterning character if   */\n                             /*      one not already there            */\n                 if right(ymem,1) = \"*\"\n                 then ast = \"\"\n                 else ast = \"*\"\n\n                 xdsn1 = \"'\"ytext\"(\"strip(left(ymem\"\"ast,8))\")'\"\n              end\n\n              \"VPUT XDSN1 SHARED\"\n           end\n                             /* ISPF 3.3 process TO dataset           */\n                             /*   SS:3 Linecmd:TO linecmd:OV          */\n           when linecmd = \"TO\" | linecmd = \"OV\" then\n           do\n              tfound = \"YES\"\n                             /* with or without replace?              */\n                             /*   SS:3 Linecmd:OV                     */\n              if linecmd = \"OV\"\n              then replace = \"REPLACE\"\n              else replace = \"\"\n                             /* save target DSN and member            */\n              \"TBGET UTTDSM5 ROWID(CTO)\"\n              tods = ytext\n              parse var ymem ymem \" \" .\n              tomember = ymem\n\n              dsn2 = \"'\"ytext\"'\"\n              \"VPUT (DSN2) SHARED\"\n           end\n                             /* ISPF 3.14 string search with SuperC   */\n                             /*   SS:3 Linecmd:314 Linecmd:3.14       */\n           when linecmd = \"314\" then\n           do\n              zssfndsn = \"'\"ytext\"(*)'\"\n              \"VPUT (ZSSFNDSN) SHARED\"\n              \"CONTROL DISPLAY SAVE\"\n              \"SELECT  PGM(ISRSFM)\"\n              \"CONTROL DISPLAY RESTORE\"\n              zssfndsn = \"\"\n              \"VPUT (ZSSFNDSN) SHARED\"\n           end\n                             /* Single member copy/move (from DSN)    */\n                             /*   SS:3 Linecmd:CO  Linecmd:MO         */\n           when linecmd = \"CO\" | linecmd = \"MO\" then\n           do\n                             /* Member name is compulsory             */\n              if ymem = \"\"\n              then \"SETMSG MSG(UTMDD015)\"\n              else\n              do\n                 cfound = \"YES\"\n                             /* Move or copy?                         */\n                             /*   SS:3 Linecmd:CO                     */\n                 if linecmd = \"CO\"\n                 then oneact = \"LMCOPY\"\n                 else oneact = \"LMMOVE\"\n                             /* Aquire and save From DSN              */\n                 \"TBGET UTTDSM5 ROWID(CFROM)\"\n                 frds     = ytext\n                 parse var ymem ymem \" \" .\n                 frmember = ymem\n              end\n           end\n                             /* ISPF 3.4                              */\n                             /*   SS:3 Linecmd:34  Linecmd:3.4        */\n           when linecmd = 34 then\n           do\n                             /* User can type 3.4 n in the prefix     */\n                             /* area, where n is the number of levels */\n                             /* needed. Split the DSN into words, get */\n                             /* the first n, put the dots back to     */\n                             /* make a DSN qualifier again            */\n              dstext = ytext\n                             /* Did the user specify 3.4 n?           */\n              if datatype(lopt,\"NUM\")\n                             /* yes, so                               */\n                             /* 1) 'translate' converts to words      */\n                             /* 2) 'delword' gets rid of unwanted     */\n                             /*    words (i.e n+1th and onwards)      */\n                             /* 3) 'space' replaces all spaces with   */\n                             /*    dots to make a DSN qualifier again */\n              then dstext =                                          ,\n                space(delword(translate(dstext,' ','.'),lopt+1),1,'.')\n                             /* Did the user specify 3.4 * ?          */\n                             /* yes, make the DSname a pattern        */\n              if lopt = \"*\" & right(dstext,1) \\= \"*\"\n              then dstext = dstext\"*\"                                ,\n\n              \"CONTROL DISPLAY SAVE\"\n              \"LMDINIT LISTID(LISTID) LEVEL(\"dstext\")\"\n              \"LMDDISP LISTID(\"Listid\") CONFIRM(YES) VIEW(VOLUME)\"\n              \"LMDFREE LISTID(\"Listid\")\"\n              \"CONTROL DISPLAY RESTORE\"\n           end\n                             /*   SS:3 Linecmd:3.6 or :36             */\n                             /*  print dataset or member              */\n           when linecmd = \"36\" then\n           do\n              if ymem \\= \"\"\n              then zhdsn = \"'\"ytext\"(\"ymem\")'\"\n              else zhdsn = \"'\"ytext\"'\"\n              \"VPUT ZHDSN\"\n\n              \"CONTROL DISPLAY SAVE\"\n              \"SELECT  PANEL(ISRUTIL) OPT(6)\"\n              \"CONTROL DISPLAY RESTORE\"\n           end\n                             /* Delete member                         */\n                             /*   SS:3 Linecmd:DEL                    */\n           when linecmd = \"DEL\" then\n           do\n                             /* Member name is required               */\n              if ymem = \"\"\n              then \"SETMSG MSG(UTMDS014)\"\n              else\n              do\n                 \"LMINIT DATAID(DELT) DATASET('\"ytext\"') ENQ(SHRW)\"\n                 if rc = 0 then\n                 do\n                    \"LMOPEN DATAID(\"delt\")  OPTION(OUTPUT)\"\n                    \"LMMDEL DATAID(\"delt\") MEMBER(\"ymem\")\"\n                    if rc = 0 then\n                    do\n                             /* erase member name from list           */\n                       delmem = ymem\n                       \"TBPUT UTTDSM5\" tsave\n                       \"SETMSG MSG(UTMDD022)\"\n                    end\n                    else \"SETMSG MSG(UTMDD021)\"\n\n                    \"LMCLOSE DATAID(\"delt\")\"\n                 end\n                 else \"SETMSG MSG(UTMDD021)\"\n\n                 \"LMFREE  DATAID(\"delt\")\"\n              end\n           end\n                             /* submit job                            */\n                             /*   SS:3 Linecmd:SUB                    */\n           when linecmd = \"SUB\" then\n           do\n              if ymem = \"\"\n              then dsn = \"'\"ytext\"'\"\n              else dsn = \"'\"ytext\"(\"ymem\")'\"\n                             /* get output for job submission message */\n              call submit dsn\n           end\n                             /* show ISPF member stats                */\n                             /*   SS:3 Linecmd:STATS                  */\n           when linecmd = \"STATS\" then\n           do\n              if ymem \\= \"\" then\n              do\n                 zllib   = \"\"\n                 zlvers  = \"\"\n                 zlmod   = \"\"\n                 zlcdate = \"\"\n                 zlmdate = \"\"\n                 zlmtime = \"\"\n                 zlcnorc = \"\"\n                 zlinorc = \"\"\n                 zlmnorc = \"\"\n                 zluser  = \"\"\n                 \"LMINIT  DATAID(SOURCE) DATASET('\"ytext\"')\"\n                 \"LMOPEN  DATAID(\"source\")\"\n                 if rc = 0 then\n                 do\n                    \"LMMFIND DATAID(\"source\") MEMBER(\"ymem\") STATS(YES)\"\n                    if rc = 0 then\n                    do\n                       xtype  = \"OUTPUT\"\n                       xcolor = \"WHITE\"\n                             /* show ISPF member stats                */\n                       \"CONTROL DISPLAY SAVE\"\n                       do while rc = 0\n                          \"DISPLAY PANEL(UTPDSM5C)\"\n                       end\n                       \"CONTROL DISPLAY RESTORE\"\n                             /* optional update if requested          */\n                       if xtype = \"INPUT\"\n                       then ,\n                          \"LMMSTATS\"         ,\n                          \"DATAID(\"source\")\"    ,\n                          \"MEMBER(\"ymem\")\"      ,\n                          \"VERSION(\"zlvers\")\"   ,\n                          \"MODLEVEL(\"zlmod\")\"   ,\n                          \"CREATED(\"zlcdate\")\"  ,\n                          \"MODDATE(\"zlmdate\")\"  ,\n                          \"MODTIME(\"zlmtime\")\"  ,\n                          \"CURSIZE(\"zlcnorc\")\"  ,\n                          \"INITSIZE(\"zlinorc\")\" ,\n                          \"MODRECS(\"zlmnorc\")\"  ,\n                          \"USER(\"zluser\")\"\n                    end\n                    else \"SETMSG MSG(UTMDD010)\"\n                 end\n                 else \"SETMSG MSG(UTMDD010)\"\n                 \"LMCLOSE DATAID(\"source\")\"\n                 \"LMFREE  DATAID(\"source\")\"\n              end\n           end\n                             /* SuperC compare or merge (new dataset) */\n                             /*   SS:3 Linecmd:CPN                    */\n           when linecmd = \"CPN\" then\n           do\n              cpnew = linecmd\n              newdsn = ytext\n              newmem = ymem\n           end\n                             /* SuperC compare or merge (old dataset) */\n                             /*   SS:3 Linecmd:CPO                    */\n           when linecmd = \"CPO\" then\n           do\n              cpold  = linecmd\n              olddsn = ytext\n              oldmem = ymem\n           end\n                             /* SuperC extended  (new dataset)        */\n                             /*   SS:3 Linecmd:NEW                    */\n           when linecmd = \"NEW\" then\n           do\n              xtnnew  = linecmd\n              newdsn = ytext\n              newmem = ymem\n           end\n                             /* SuperC extended  (old dataset)        */\n                             /*   SS:3 Linecmd:OLD                    */\n           when linecmd = \"OLD\"  then\n           do\n              xtnold  = linecmd\n              olddsn = ytext\n              oldmem = ymem\n           end\n                             /* SuperC extended (optional merge dsn)  */\n                             /*   SS:3 Linecmd:MRG                    */\n           when linecmd = \"MRG\"  then\n           do\n              xtnmrg  = linecmd\n              mrgdsn = ytext\n              mrgmem = ymem\n           end\n                             /* Insert or repeat lines                */\n                             /*   SS:3 Linecmd:I   Linecmd:R          */\n           when linecmd = \"I\"  | linecmd = \"R\" then\n           do\n                             /* Insert clear lines                    */\n                             /*   SS:3 Linecmd:I                      */\n              if linecmd = \"I\"\n              then \"TBVCLEAR UTTDSM5\"\n              ydispl = \"YES\"\n\n              \"TBADD    UTTDSM5\"\n              \"TBQUERY  UTTDSM5 POSITION(CSRROW)\"\n                             /* Insert/Repeat multiple lines          */\n              if datatype(number,\"NUM\") then\n              do i = 1 to number-1\n                 \"TBADD  UTTDSM5\"\n              end\n\n              SortR = \"YES\"\n              \"VPUT SORTR SHARED\"\n           end\n                             /* Hide lines with same show type        */\n                             /*   SS:3 Linecmd:HI                     */\n           when linecmd = \"HI\" then\n           do\n              yshow_store = yshow\n\n              if yshow = \"\" then yshblank = \"\"\n                             /* Continue until new show type found    */\n              \"TBSKIP UTTDSM5\"\n              do while yshow_store = yshow & rc = 0\n                 ydispl = \"NO\"\n                 \"TBPUT   UTTDSM5\" tsave\n                 \"TBSKIP  UTTDSM5\"\n              end\n           end\n                             /* Show lines with same show type        */\n                             /*   SS:3 Linecmd:SH                     */\n           when linecmd = \"SH\" then\n           do\n              yshow_store = yshow\n\n              if yshow = \"\" then yshblank = \"YES\"\n                             /* Continue until new show type found    */\n              \"TBSKIP UTTDSM5\"\n              do while yshow_store = yshow & rc = 0\n                 ydispl = \"YES\"\n                 \"TBPUT   UTTDSM5\" tsave\n                 \"TBSKIP  UTTDSM5\"\n              end\n           end\n                             /* Delete line                           */\n                             /*   SS:3 Linecmd:D                      */\n           when linecmd = \"D\" then\n           do\n              \"TBDELETE UTTDSM5\"\n           end\n                             /* Prepare to move line                  */\n                             /*   SS:3 Linecmd:M                      */\n           when linecmd = \"M\" then\n           do\n              copy = \"\"\n              move = \"YES\"\n              \"TBGET  UTTDSM5 ROWID(FROM) NOREAD\"\n           end\n                             /* Prepare to copy line                  */\n                             /*   SS:3 Linecmd:C                      */\n           when linecmd = \"C\" then\n           do\n              move = \"\"\n              copy = \"YES\"\n              \"TBGET  UTTDSM5 ROWID(FROM) NOREAD\"\n           end\n                             /* .. after this line                    */\n                             /*   SS:3 Linecmd:A                      */\n           when linecmd = \"A\" then\n           do\n              before = \"\"\n              after  = \"YES\"\n              \"TBGET  UTTDSM5 ROWID(TO) NOREAD\"\n           end\n                             /* .. before this line                   */\n                             /*   SS:3 Linecmd:A  Linecmd:B4          */\n           when linecmd = \"BE\" | linecmd = \"B4\" then\n           do\n              after  = \"\"\n              before = \"YES\"\n              \"TBGET  UTTDSM5 ROWID(TO) NOREAD\"\n           end\n                             /* exclude line from display             */\n                             /*   SS:3 Linecmd:X                      */\n           when linecmd = \"X\" then\n           do\n              ydispl = \"NO\"\n              \"TBPUT UTTDSM5\" tsave\n           end\n                             /*   SS:3 Linecmd:ACT                    */\n           when linecmd = \"ACT\" then\n           do\n              \"CONTROL DISPLAY SAVE\"\n              \"DISPLAY PANEL(UTPDSM5A) COMMAND(YTEXT)\"\n              \"CONTROL DISPLAY RESTORE\"\n           end\n                             /*   SS:3 Linecmd:EX                     */\n           when linecmd = \"EX\" then\n           do\n              \"CONTROL DISPLAY SAVE\"\n              address \"TSO\" \"EX '\"ytext\"(\"ymem\")'\"\n              \"CONTROL DISPLAY RESTORE\"\n           end\n                             /*   SS:3 Linecmd:TM                     */\n           when linecmd = \"TM\" then\n           do\n              \"CONTROL DISPLAY SAVE\"\n              \"DISPLAY PANEL(UTPDSM5N)\"\n              do while rc = 0\n\n                 a = msg(\"ON\")\n                 if ymem \\= \"\"\n                 then address \"TSO\" ,\n                     \"TRANSMIT\" ynode\".\"yuser \"DA('\"ytext\"(\"ymem\")')\"\n                 else address \"TSO\" ,\n                     \"TRANSMIT\" ynode\".\"yuser \"DA('\"ytext\"')\"\n                 a = msg(\"OFF\")\n                 \"DISPLAY PANEL(UTPDSM5N)\"\n              end\n              \"CONTROL DISPLAY RESTORE\"\n           end\n\n           otherwise nop\n        end\n                             /* Have all rows been processed?         */\n        if ztdsels > 1\n        then \"TBDISPL  UTTDSM5\"\n        else ztdsels = 0\n     end\n                             /* If command entered on command line,   */\n                             /* make sure cursor stays there          */\n     if zcmd \\= \"\"\n     then  csrrow = 0\n                             /* Section:4  Command-line commands      */\n                             /*****************************************/\n                             /* find command options ignoring any     */\n                             /* interpolated blanks                   */\n     parse var szcmd command opt1 opt2 opt3 opt4 .\n     next_zcmd = \"\"\n     select\n                             /* Show first line in each show group    */\n                             /*   SS:4 Zcmd:SHOW                      */\n        when zcmd = \"SHOW\" then\n        do\n                             /* establish search argument             */\n           stShow = pshow opt1\n           pshow = stShow\n           \"VPUT STSHOW PROFILE\"\n                             /* hide all displayed rows               */\n           \"TBVCLEAR UTTDSM5\"\n           ydispl = \"YES\"\n           \"TBSARG  UTTDSM5 NAMECOND(YDISPL,EQ)\"\n\n           \"TBTOP    UTTDSM5\"\n           \"TBSCAN   UTTDSM5\"\n           do while rc = 0\n              ydispl = \"NO\"\n              \"TBPUT  UTTDSM5\" tsave\n              \"TBSCAN UTTDSM5\"\n           end\n                             /* for each word in the show list:       */\n           showFound = \"NO\"\n           do i = 1 to words(pshow)\n              \"TBTOP    UTTDSM5\"\n              \"TBVCLEAR UTTDSM5\"\n              ydispl = \"NO\"\n                             /* use each word as a prefix             */\n              yshow  = subword(pshow,i,1)\"*\"\n                             /* search for equal rows to display that */\n                             /* are not already being displayed       */\n              \"TBSARG UTTDSM5 NAMECOND(YDISPL,EQ,YSHOW,EQ)\"\n              \"TBSCAN UTTDSM5\"\n              do while rc = 0\n                 ydispl = \"YES\"\n                 showFound = \"YES\"\n                 \"TBPUT UTTDSM5\" tsave\n                 \"TBSCAN UTTDSM5\"\n              end\n           end\n                             /* If nothing found, add 1st line        */\n           if showFound \\= \"YES\" & pshow \\= \"\" then\n           do\n              \"TBVCLEAR UTTDSM5\"\n              ydispl = \"YES\"\n              yshow = subword(pshow,1,1)\n              \"TBADD UTTDSM5\"\n           end\n                             /* re-establish display arguments        */\n           \"TBVCLEAR UTTDSM5\"\n           ydispl = \"YES\"\n\n           \"TBSARG UTTDSM5 NAMECOND(YDISPL,EQ)\"\n           \"TBTOP  UTTDSM5\"\n                             /* Force redisplay                       */\n           panel  = \"PANEL(UTPDSM5)\"\n        end\n                             /*   SS:4 Zcmd:HEADS                     */\n        when zcmd = \"HEADS\" then\n        do\n           \"TBTOP UTTDSM5\"\n           \"TBSKIP UTTDSM5\"\n           yshow_store = yshow\n           ydispl = \"YES\"\n           \"TBPUT UTTDSM5\" tsave\n\n          \"TBSKIP UTTDSM5\"\n           do while rc = 0\n                             /* Check each show field against the next*/\n              if yshow_store \\= yshow then\n              do\n                 yshow_store = yshow\n                 ydispl = \"YES\"\n              end\n                             /* Are blanks always shown?              */\n              else if yshow = \"\" & yshblank = \"YES\"\n                   then ydispl = \"YES\"\n                   else ydispl = \"NO\"\n\n              \"TBPUT UTTDSM5\" tsave\n              \"TBSKIP UTTDSM5\"\n           end\n                             /* force panel redisplay                 */\n           panel  = \"PANEL(UTPDSM5)\"\n        end\n                             /*   SS:4 Zcmd:SORT                      */\n        when zcmd = \"SORT\" then\n        do\n           select\n               when opt1 = \"\" then this_sort = sort_fields\n               when abbrev(\"MEMBER\",opt1,1) then\n                          this_sort = \"YMEM,C,A\"\n               when abbrev(\"TEXT\",opt1,1) then\n                          this_sort = \"YTEXT,C,A\"\n               when abbrev(\"DESCRIPTION\",opt1,1) then\n                          this_sort = \"YDESC,C,A\"\n               when abbrev(\"SHOW\",opt1,1) then\n                          this_sort = \"YSHOW,C,A\"\n               when abbrev(\"TYPE\",opt1,1) then\n                          this_sort = \"YTYPE,C,A\"\n               otherwise  this_sort = sort_fields\n           end\n           call sort_table this_sort\n           \"TBTOP  UTTDSM5\"\n                             /* force redisplay of table              */\n           panel  = \"PANEL(UTPDSM5)\"\n        end\n                             /*   SS:4 Zcmd:RESET                     */\n        when zcmd = \"RESET\" then\n        do\n                             /* display every line of table           */\n           \"TBTOP  UTTDSM5\"\n           \"TBSKIP UTTDSM5\"\n           do while rc = 0\n              ydispl = \"YES\"\n              \"TBPUT   UTTDSM5\" tsave\n              \"TBSKIP  UTTDSM5\"\n           end\n           \"TBTOP  UTTDSM5\"\n                             /* force redisplay of table              */\n           panel  = \"PANEL(UTPDSM5)\"\n        end\n                             /*   SS:4 Zcmd:CANCEL                    */\n        when zcmd = \"CANCEL\" then signal qquit\n                             /* List datasets allocated               */\n                             /*   SS:4 Zcmd:LISTALLOC Zcmd:LA         */\n        when zcmd = \"LISTALLOC\" then\n        do\n                             /* Get table of allocated datasets       */\n           call AllocatedDsns\n                             /* display and process table             */\n           call DisplayTable \"LISTA\",\"UTPDSM5H\"\n        end\n                             /* Add new lines...                      */\n                             /*   SS:4 Zcmd:ADD                       */\n        when zcmd = \"ADD\" then\n        do\n                             /* order all existing lines first        */\n           call Sort_Table sort_fields\n                             /* ...from a list of allocated files     */\n           ladded = \"\"\n           lashow = \"\"\n           latype = \"\"\n\n           if opt1 = \"ALLOC\"\n           then call addalloc\n           else\n           if opt1 \\= \"\"\n                             /* ...from a DS prefix list              */\n           then call addpref\n        end\n                             /* find a member in the list             */\n                             /*   SS:4 Zcmd:F Zcmd:FIND               */\n        when zcmd = \"FIND\" then\n        do\n                             /* MEMBER and TYPE parameters reqd.      */\n           if opt1 = \"\" then\n           do\n              next_zcmd = zcmd \"?  ?\"\n              \"SETMSG MSG(UTMDD026)\"\n           end\n           else\n           if opt2 = \"\" then\n           do\n                             /*  TYPE parameter reqd.                 */\n              next_zcmd = zcmd opt1 \"*\"\n              \"SETMSG MSG(UTMDD027)\"\n           end\n           else\n           do\n                             /* member stats will be shown            */\n              tsave = \"SAVE(TSTATS)\"\n              find = \"YES\"\n              \"TBTOP     UTTDSM5\"\n              \"TBVCLEAR  UTTDSM5\"\n                             /* scan either for ALL or by TYPE        */\n              if opt2 = \"*\" then\n              do\n                 cond1 = \"YTYPE,GE\"\n                 ytype = \"\"\n              end\n              else\n              do\n                 cond1 = \"YTYPE,EQ\"\n                 ytype = opt2\n              end\n              select\n                 when opt3 = \"NX\" then\n                 do\n                    cond2 = \",YDISPL,EQ\"\n                    ydispl = \"YES\"\n                 end\n                 when opt3 = \"X\" then\n                 do\n                    cond2 = \",YDISPL,NE\"\n                    ydispl = \"YES\"\n                 end\n                 otherwise\n                 do\n                    cond2 = \"\"\n                    ydispl = \"\"\n                 end\n              end\n\n              \"TBSARG  UTTDSM5 NAMECOND(\"cond1\"\"cond2\")\"\n              \"TBSCAN  UTTDSM5\"\n              do while rc = 0\n\n                 yomem = ymem\n                 ymem    = \"\"\n                 zlvers        = \"\"\n                 zlmod         = \"\"\n                 zlmdate       = \"\"\n                 zlmtime       = \"\"\n                 zluser        = \"\"\n                             /* Get member and stats                  */\n                 \"LMINIT  DATAID(FDSET) DATASET('\"ytext\"')\"\n                 \"LMOPEN  DATAID(\"fdset\")\"\n                 tstats = \"\"\n                 \"LMMFIND DATAID(\"fdset\") MEMBER(\"opt1\") STATS(YES)\"\n                 if rc = 0 then\n                 do\n                             /* Member was found                      */\n                    ymem = opt1\n                             /* move stats in if any were found       */\n                    if  zlvers \\= \"\"\n                    then tstats = zlvers\".\"zlmod zlmdate zlmtime zluser\n                 end\n\n                 \"LMCLOSE DATAID(\"fdset\")\"\n                 \"LMFREE  DATAID(\"fdset\")\"\n                 \"TBPUT  UTTDSM5\" tsave\n                             /* get next matching row                 */\n                 \"TBSCAN UTTDSM5\"\n              end\n\n              \"TBVCLEAR  UTTDSM5\"\n              type = opt2\n                             /* User can decide whether to see all    */\n                             /* rows or just where search successful  */\n              \"SETMSG MSG(UTMDD028)\"\n              smem = \"\"\n              if yfaf = \"F\" then\n              do\n                 smem = \"YMEM,EQ)\"\n                 ymem = opt1\n                 \"SETMSG MSG(UTMDS028)\"\n              end\n\n              \"TBSARG UTTDSM5 NAMECOND(TYPE,EQ\"smem\")\"\n              \"TBTOP UTTDSM5\"\n              panel  = \"PANEL(UTPDSM5E)\"\n           end\n        end\n                             /*   SS:4 Zcmd:TEMPL                     */\n        when zcmd = \"TEMPL\" then\n        do\n                             /* Show table of template datasets       */\n           call DisplayTable \"UTTEMPL\",\"UTPDSM5I\"\n           call TemplBuild\n        end\n                             /*   SS:4 Zcmd:SAVE                      */\n        when zcmd = \"SAVE\" then\n        do\n                             /* Save table without quitting           */\n           \"TBSAVE UTTDSM5 PAD(10)\"\n           \"SETMSG MSG(UTMDD037)\"\n        end\n                             /*   SS:4 Zcmd:CMDL                      */\n        when zcmd = \"CMDL\" then\n        do\n           \"CONTROL DISPLAY SAVE\"\n           call help_display\n           \"CONTROL DISPLAY RESTORE\"\n        end\n                             /* Display version search libraries      */\n                             /*   SS:4 Zcmd:VSL <list number>         */\n        when zcmd = \"VSL\" then\n        do\n                             /* If no number specified, assume 1      */\n           if opt1 = \"\"\n           then opt1 = 1\n                             /* create table if necessary             */\n           vTable = \"UTTV\"opt1\n           \"TBSTATS\" vTable \"STATUS1(STATUS1)\" ,\n                            \"STATUS2(STATUS2) LIBRARY(\"library\")\"\n           if status2 = 1 then\n           do\n              if status1 = 2 then\n              do\n                 \"TBCREATE\" vTable \"NAMES(VTDSN\"      ,\n                                         \"VTLETTER\"   ,\n                               \") REPLACE\"\n                 \"TBADD\" vTable\n              end\n              else \"TBOPEN\" vTable \"LIBRARY(\"library\") SHARE\"\n           end\n                             /* default is not to submit job...       */\n           vlsub = \"NO\"\n                             /* display table                         */\n           call DisplayTable vTable,\"UTPDSM5L\",\"FIELDS(VTLETTER,C,A)\"\n                             /* ...only submit at user request        */\n           if vlsub = \"YES\" then\n           do\n              vlsub = \"NO\"\n              call BatchTSO \"UTSTSO01\"\n           end\n           else \"SETMSG MSG(UTMDD052)\"\n                             /* close after usage                     */\n           \"TBCLOSE\" vTable \"LIBRARY(\"library\")\"\n        end\n                             /*   SS:4 Zcmd:FAQ                       */\n        when zcmd = \"FAQ\" then\n        do\n                             /* Check availability of FAQ dataset     */\n           a = sysdsn(\"'\"FaqDsn\"'\")\n           if a = \"OK\" then\n           do\n                             /* Browse or Edit requested?             */\n              if opt1 = \"E\"\n              then oper = \"EDIT\"\n              else if opt1 = \"V\"\n              then oper = \"VIEW\"\n              else oper = \"BROWSE\"\n\n              \"CONTROL DISPLAY SAVE\"\n              acceptCC = AcceptCCMax\n              oper \"DATASET('\"FaqDsn\"')\"\n              if rc > 8 then\n              \"SETMSG MSG(UTMDD010)\"\n              acceptCC = AcceptCCMax\n              \"CONTROL DISPLAY RESTORE\"\n           end\n           else\n           do\n              zerrlm = a\n              \"SETMSG MSG(UTMDD010)\"\n           end\n        end\n        otherwise nop\n     end\n     zcmd = next_zcmd\n                             /* Section:5  Command pairs (e.g.CO/TO)  */\n                             /*****************************************/\n                             /*   SS:5  :copy :move                   */\n     if (move   = \"YES\" | copy   = \"YES\") & ,\n        (after  = \"YES\" | before = \"YES\") then\n     do\n        \"TBSKIP UTTDSM5   ROW(\"from\")\"\n                             /* delete 'FROM' line when moving        */\n        if move = \"YES\"\n        then \"TBDELETE UTTDSM5\"\n                             /* save 'FROM' values                    */\n        \"VPUT (\"names_less_yshow\") SHARED\"\n                             /* point at new position                 */\n        \"TBSKIP  UTTDSM5 ROW(\"to\")\"\n                             /* step back 1 if 'before'               */\n        if before = \"YES\"\n        then \"TBSKIP  UTTDSM5 NUMBER(-1)\"\n                             /* retrieve values and add               */\n        \"VGET (\"names_less_yshow\") SHARED\"\n        \"TBADD    UTTDSM5\"\n                             /* get new line row number               */\n        \"TBQUERY  UTTDSM5 POSITION(CSRROW)\"\n        SortR = \"YES\"\n        \"VPUT SORTR SHARED\"\n                             /* reset all indicators                  */\n        after  = \"\"\n        before = \"\"\n        move   = \"\"\n        copy   = \"\"\n     end\n                             /*   SS:5  :CPN :CPO                     */\n     if cpnew = \"CPN\" & cpold = \"CPO\" then\n     do\n                             /* SuperC compare without merge          */\n        cpnew = \"\"\n        cpold = \"\"\n                             /* check dataset/member combinations     */\n        call checkDsns\n                             /* Check datasets                        */\n        Status1 = sysdsn(fqolddsn)\n        if Status1 \\= \"OK\"\n        then \"SETMSG MSG(UTMDD031)\"\n        else\n        do\n           Status2 = sysdsn(fqnewdsn)\n           if Status2 \\= \"OK\"\n           then \"SETMSG MSG(UTMDD032)\"\n        end\n                             /* Only do compares if datasets OK       */\n        if Status1 = \"OK\" & Status2 = \"OK\" then\n        do\n           SuperCParm = SuperCforCompare\n                             /* No statements dataset needed          */\n           address \"TSO\" \"FREE  DD(SYSIN)\"\n           call SuperC\n        end\n     end\n                             /*   SS:5  :NEW :OLD :MRG                */\n     if xtnnew = \"NEW\" & xtnold = \"OLD\" then\n     do\n                             /* Extended SuperC                       */\n        xtnnew    = \"\"\n        xtnold    = \"\"\n        xtnmrg    = \"\"\n\n        \"CONTROL DISPLAY SAVE\"\n        \"DISPLAY PANEL(UTPDSM5K)\"\n        do while rc < 8\n                             /* check dataset/member combinations     */\n           call checkDsns\n                             /* check datasets exist as specified     */\n           Status1 = sysdsn(fqolddsn)\n           if Status1 \\= \"OK\"\n           then \"SETMSG MSG(UTMDD031)\"\n           else\n           do\n              Status2 = sysdsn(fqnewdsn)\n              if Status2 \\= \"OK\"\n              then \"SETMSG MSG(UTMDD032)\"\n                             /* Is it a merge?                        */\n              else if ycpopt = 2 then\n              do\n                             /* Yes, merge dataset must exist but     */\n                             /* member must NOT exist, must be new    */\n                 Status3 = sysdsn(\"'\"mrgdsn\"'\")\n                 if Status3 \\= \"OK\"\n                 then \"SETMSG MSG(UTMDD034)\"\n                 Status4 = sysdsn(fqmrgdsn)\n                 if Status4 = \"OK\"\n                 then \"SETMSG MSG(UTMDD035)\"\n              end\n           end\n\n           select\n                             /* Option 1, compare without merge       */\n              when  ycpopt = 1 &                              ,\n                  (Status1 = \"OK\" & Status2  = \"OK\")  then\n              do\n                 SuperCParm = SuperCforCompare\n                 call SuperCStatements\n                 call SuperC\n              end\n                             /* Option 2, merge                       */\n              when ycpopt = 2 &                          ,\n                  (Status1 = \"OK\" & Status2  = \"OK\"      ,\n                  & Status3 = \"OK\" & Status4 \\= \"OK\") then\n              do\n                 SuperCParm = SuperCforMerge\n                 SuperCAction = \"M\"\n                 address \"TSO\" \"ALLOC DD(DELDD)\"  ,\n                               \"DA(\"fqmrgdsn\") SHR REUSE\"\n                 call SuperCStatements\n                 call SuperC\n                 address \"TSO\" \"FREE  DD(DELDD)\"\n              end\n                             /* Option 3, Logical level compare       */\n              when ycpopt = 3 & ,\n                  (Status1 = \"OK\" & Status2  = \"OK\")  then\n              do\n                 SuperCParm = SuperCforCompare\n                 call SuperCStatements \"LOGICAL\"\n                 call SuperC\n              end\n              otherwise nop\n           end\n           \"DISPLAY PANEL(UTPDSM5K)\"\n        end\n        zcmd = \"\"\n        \"CONTROL DISPLAY RESTORE\"\n     end\n                             /* Single member copy                    */\n     if cfound = \"YES\" & tfound = \"YES\" then\n     do\n        cfound = \"\"\n        tfound = \"\"\n                             /* 'TO' member name specified?           */\n                             /* No, then same as 'FROM'               */\n        if tomember = \"\" then tomember = frmember\n\n        \"LMINIT DATAID(TO)   DATASET('\"tods\"')\"\n        \"LMINIT DATAID(FROM) DATASET('\"frds\"')\"\n        \"LMOPEN DATAID(\"from\")\"\n                             /* Text for result message               */\n        if oneact = \"LMMOVE\"\n        then act = \"Move\"\n        else act = \"Copy\"\n                             /* 20 allows for member in use           */\n        acceptcc = 20\n        oneact   \"FROMID(\"from\") TODATAID(\"to\")\" ,\n                 \"FROMMEM(\"frmember\") TOMEM(\"tomember\")\" replace\n        actrc = rc\n        acceptcc = AcceptCCMax\n\n        \"LMFREE DATAID(\"to\")\"\n        \"LMFREE DATAID(\"from\")\"\n                             /* Put member name in target row         */\n        \"TBSKIP UTTDSM5  ROW(\"cto\")\"\n        if actrc = 0 then\n        do\n           ymem = tomember\n           \"TBPUT UTTDSM5\" tsave\n           \"SETMSG MSG(UTMDD016)\"\n        end\n        else \"SETMSG MSG(UTMDD017)\"\n\n        \"TBQUERY UTTDSM5 POSITION(CSRROW)\"\n     end\n                             /*  ISPF 3.3 copy                        */\n     if copy33 = \"YES\" & tfound = \"YES\" then\n     do\n        copy33 = \"\"\n        tfound = \"\"\n                             /* 3.3 replace option specified?         */\n        if replace = \"REPLACE\"\n        then zurep = \"Y\"\n        else zurep = \"N\"\n        \"VPUT (ZUREP)\"\n                             /* Invoke 3.3                            */\n        \"CONTROL DISPLAY SAVE\"\n        \"SELECT  PGM(ISRUMC)\"\n        \"CONTROL DISPLAY RESTORE\"\n     end\n                             /* make sure any error message is only   */\n                             /* displayed once                        */\n     if zerrsm \\= \"\" then\n     do\n        \"SETMSG MSG(UTMDD010) COND\"\n        zerrsm = \"\"\n     end\n  end\n                             /* Section:6  End of processing          */\n                             /*****************************************/\n                             /* save parameters and main table        */\nfinish:\n  \"VPUT (\"parms\") PROFILE\"\n  call sort_table(sort_fields)\n  \"TBCLOSE UTTDSM5  LIBRARY(\"library\")\"\n  \"TBCLOSE UTTEMPL  LIBRARY(\"library\")\"\n                             /* quick exit                            */\nqquit:\n                             /* abandon tables if not already closed  */\n  AcceptCC = AcceptCCMax\n  \"CONTROL ERRORS RETURN\"\n  \"TBEND   UTTDSM5\"\n  \"TBEND   UTTHELP\"\n  \"TBEND   UTTEMPL\"\n                             /* turn off libraries                    */\n  \"LIBDEF ISPPLIB\"\n  \"LIBDEF ISPMLIB\"\n  \"LIBDEF PARMLIB\"\n                             /* abandon ship!                         */\nVeryQQuit:\n  exit\n                             /* Section:7  S/R: member list           */\n                             /*****************************************/\nmlist:\n                             /* ML means full member list requested   */\n  if linecmd = \"ML\" | ymem = \"\"\n  then mbr = \"\"\n                             /* If pattern already specified, OK,     */\n                             /* otherwise insert an * on the right    */\n  else if pos(\"%\",ymem) = 0 && ,\n          pos(\"*\",ymem) = 0\n       then mbr = \"MEMBER(\"strip(ymem)\")\"\n       else mbr = \"MEMBER(\"strip(substr(strip(ymem)\"*\",1,8))\")\"\n\n                             /* Intitialise member list data set      */\n                             /* with template if specified            */\n  address \"TSO\" \"ALLOC DD(DSM3TMP\"zscreen\")\" ,\n                      \"DA('\"ytext\"'\" templ.ytype\") SHR REUSE\"\n  \"LMINIT DATAID(DSET) DDNAME(DSM3TMP\"zscreen\") ENQ(SHR)\"\n  \"LMOPEN  DATAID(\"dset\")\"\n                             /* Display member list                   */\n  \"CONTROL DISPLAY SAVE\"\n  \"LMMDISP DATAID(\"dset\") OPTION(DISPLAY) COMMANDS(ANY) FIELD(9)\" mbr\n  disprc = rc\n  if disprc > 0\n  then   \"SETMSG MSG(UTMDD010)\"\n  else\n  do while disprc = 0\n                             /* Split command line options            */\n     parse var zcmd command opt1 opt2 opt3 .\n     zcmd = \"\"\n\n     if abbrev(\"EDIT\",command,1)   then command = \"EDIT\"\n     if abbrev(\"BROWSE\",command,1) then command = \"BROWSE\"\n     if abbrev(\"VIEW\",command,1) then command = \"VIEW\"\n\n     if (command = \"EDIT\" | command = \"BROWSE\" | command = \"VIEW\") ,\n        & opt1 \\= \"\" then\n     do\n                             /* Edit/browse commmand line selection   */\n        call GetISPFStats dset opt1 \"NOOPEN\"\n        \"CONTROL DISPLAY SAVE\"\n        \"SETMSG MSG(\"sMessage\") COND\"\n        command \"DATAID(\"dset\") MEMBER(\"opt1\")\"\n        if rc > 8 then\n        \"SETMSG MSG(UTMDD010)\"\n        \"CONTROL DISPLAY RESTORE\"\n                             /* Add to displayed list                 */\n        \"LMMDISP DATAID(\"dset\") OPTION(ADD) MEMBER(\"opt1\")\"\n     end\n     else\n     if command \u00ac= \"\" then\n     do\n        zerrsm = \"Invalid command\"\n        zerrlm = \"Valid commands are: Edit View Browse\"\n       \"SETMSG MSG(ISRZ002)\"\n     end\n\n     getrc  = 0\n     do while getrc = 0\n                             /* Process selected members              */\n        smember = zlmember\n        zllcmd  = strip(translate(zllcmd,' ','_'))\n                             /* validate line command                 */\n        if zllcmd \u00ac= \"/\" & ,\n           zllcmd \u00ac= \"R\" & ,\n           zllcmd \u00ac= \"S\" & ,\n           zllcmd \u00ac= \"B\" & ,\n           zllcmd \u00ac= \"V\" & ,\n           zllcmd \u00ac= \"E\" & ,\n           zllcmd \u00ac= \"EXEC\" & ,\n           zllcmd \u00ac= \"\" & ,\n           \u00acabbrev(\"EXEC\",zllcmd,2) & ,\n           \u00acabbrev(\"DELETE\",zllcmd,3) & ,\n           \u00acabbrev(\"SUB\",zllcmd,3)\n        then\n        do\n           zerrsm = \"Invalid line command\"\n           zerrlm = \">\"zllcmd\"< is not a valid command\"\n          \"SETMSG MSG(ISRZ002)\"\n        end\n                             /* member selected by just 'enter'       */\n        if zllcmd = \"/\" then\n        select\n           when oper = \"EDIT\"   then zllcmd = \"E\"\n           when oper = \"VIEW\"   then zllcmd = \"V\"\n           otherwise                 zllcmd = \"B\"\n        end\n                             /*   SS:7 Zllcmd:R                       */\n        if zllcmd = \"R\" then\n        if zludata = \"\" | (substr(zludata,1,1) < \"A\" &       ,\n                           (substr(zludata,1,1) \u00ac= \"#\" &     ,\n                            substr(zludata,1,1) \u00ac= \"$\" &     ,\n                            substr(zludata,1,1) \u00ac= \"@\"))     ,\n                        | substr(zludata,1,1) > \"Z\" then\n\n        do\n           zerrsm = \"Invalid new name\"\n           zerrlm = \">\"zludata\"< is not a valid new name\"\n          \"SETMSG MSG(ISRZ002)\"\n        end\n        else\n        do\n                             /* Rename                                */\n           \"LMINIT  DATAID(DSETREN) DATASET('\"ytext\"') ENQ(SHRW)\"\n           \"LMOPEN  DATAID(\"dsetren\") OPTION(OUTPUT)\"\n           \"LMMREN  DATAID(\"dsetren\")\" ,\n                           \"MEMBER(\"zlmember\") NEWNAME(\"zludata\")\"\n           \"LMCLOSE DATAID(\"dsetren\")\"\n           \"LMFREE  DATAID(\"dsetren\")\"\n           \"LMMDISP DATAID(\"dset\") OPTION (ADD)\"  ,\n                           \"MEMBER(\"zludata\") ZLUDATA(\"zlmember\")\"\n                             /* New name already there?               */\n                             /*  Yes, modify existing entry           */\n           if rc = 8\n           then  \"LMMDISP DATAID(\"dset\") OPTION (PUT)\"  ,\n                           \"MEMBER(\"zludata\") ZLUDATA(\"zlmember\")\"\n           \"LMMDISP DATAID(\"dset\") OPTION (PUT)\"   ,\n                           \"MEMBER(\"zlmember\") ZLUDATA()\"\n        end\n                             /*   SS:7 Zllcmd:DELETE                  */\n        if abbrev(\"DELETE\",zllcmd,3) then\n        do\n           \"LMINIT  DATAID(DSETDEL) DATASET('\"ytext\"') ENQ(SHRW)\"\n           \"LMOPEN  DATAID(\"dsetdel\") OPTION(OUTPUT)\"\n           \"LMMDEL  DATAID(\"dsetdel\") MEMBER(\"zlmember\")\"\n           \"LMCLOSE DATAID(\"dsetdel\")\"\n           \"LMFREE  DATAID(\"dsetdel\")\"\n                             /* show deletion on the display          */\n           \"LMMDISP DATAID(\"dset\") OPTION (PUT)\"  ,\n                           \"MEMBER(\"zlmember\") ZLUDATA(Deleted)\"\n        end\n                             /*   SS:7 Zllcmd:SUBMIT                  */\n        if abbrev(\"SUBMIT\",zllcmd,3) then\n        do\n           subdsn = \"'\"ytext\"(\"strip(zlmember)\")'\"\n                          /* get output for job submission message */\n           a = msg(\"ON\")\n           a = outtrap(\"LINE.\",\"*\")\n           address \"TSO\" \"PROFILE MSGID\"\n           address \"TSO\" \"SUBMIT\" subdsn\n           a = msg(\"OFF\")\n           a = outtrap(\"FRED.\",0)\n           parse var line.1 . . jobno .\n           \"SETMSG MSG(UTMDD023)\"\n        end\n                             /*   SS:8 Zllcmd:EX                      */\n        if abbrev(\"EXEC\",zllcmd,2) then\n        do\n           \"CONTROL DISPLAY SAVE\"\n           address \"TSO\" \"EX '\"ytext\"(\"strip(zlmember)\")'\"\n           \"CONTROL DISPLAY RESTORE\"\n        end\n                             /*   SS:9 Zllcmd:E Zllcmd:B Zllcmd:S     */\n                             /* select prefix command                 */\n        thisoper = \"\"\n             if zllcmd = \"S\" then thisoper = oper\n        else if zllcmd = \"B\" then thisoper = \"BROWSE\"\n        else if zllcmd = \"V\" then thisoper = \"VIEW\"\n        else if zllcmd = \"E\" then thisoper = \"EDIT\"\n\n                             /* process prefix command                */\n        if thisoper \\= \"\" then\n        do\n           call GetISPFStats dset zlmember \"NOOPEN\"\n           \"CONTROL DISPLAY SAVE\"\n           \"SETMSG MSG(\"sMessage\") COND\"\n           thisoper \"DATAID(\"dset\") MEMBER(\"zlmember\")\"\n           if rc > 8 then\n           \"SETMSG MSG(UTMDD010)\"\n           \"CONTROL DISPLAY RESTORE\"\n        end\n                             /* get next selected member              */\n        \"LMMDISP DATAID(\"dset\") OPTION(GET)\"\n        getrc = rc\n     end\n                             /* redisplay member list                 */\n     \"LMMDISP DATAID(\"dset\") OPTION(DISPLAY) TOP(\"smember\")\"\n     disprc = rc\n  end\n  \"CONTROL DISPLAY RESTORE\"\n                             /* end of member list display            */\n  \"LMMDISP DATAID(\"dset\") OPTION(FREE)\"\n  \"LMCLOSE DATAID(\"dset\")\"\n  \"LMFREE  DATAID(\"dset\")\"\n  address \"TSO\" \"FREE  DD(DSM3TMP\"zscreen\")\"\n  return\n                             /* Section:8  S/R: template list         */\n                             /*****************************************/\nTemplBuild:\n  \"TBTOP   UTTEMPL\"\n  \"TBSKIP  UTTEMPL\"\n  templ. = \"\"\n  do while rc = 0\n\n     if ydsnt \\= \"\"\n     then templ.ytypet = \"'\"ydsnt\"'\"\n\n     \"TBSKIP  UTTEMPL\"\n  end\n  return\n                             /* Section:9  S/R: allocated data sets   */\n                             /*****************************************/\naddalloc:\n  /* Add to display from list of allocated datasets                   */\n                             /* Get table of allocated datasets       */\n  call AllocatedDsns\n                             /* display and process table             */\n  call DisplayTable \"LISTA\",\"UTPDSM5F\"\n                             /* sort added items                      */\n  call sort_table sort_fields\n  \"TBTOP   UTTDSM5\"\n  panel  = \"PANEL(UTPDSM5)\"\n  return\n                             /* Section:10 S/R: dataset prefix list   */\n                             /*****************************************/\naddpref:\n  /* Add from specified data set prefix                               */\n                             /* Create temporary table                */\n  \"TBCREATE LISTB NOWRITE REPLACE\" ListNames\n                             /* Create prefix list                    */\n  ldsn = \"\"\n  \"LMDINIT LISTID(LISTIDV) LEVEL(\"opt1\")\"\n  \"LMDLIST LISTID(\"listidv\") OPTION(LIST) DATASET(LDSN) STATS(NO)\"\n  do while rc = 0\n     \"TBADD LISTB\"\n     \"LMDLIST LISTID(\"listidv\") OPTION(LIST)\",\n              \"DATASET(LDSN) STATS(NO)\"\n  end\n  \"LMDLIST LISTID(\"listidv\") OPTION(FREE)\"\n  address \"ISPEXEC\" \"LMDFREE LISTID(\"listidv\")\"\n                             /* display and process table             */\n  call DisplayTable \"LISTB\",\"UTPDSM5G\"\n                             /* sort new entries to standard order    */\n  \"TBSORT  UTTDSM5  FIELDS(\"sort_fields\")\"\n  \"TBTOP UTTDSM5\"\n  panel  = \"PANEL(UTPDSM5)\"\n  return\n                             /* Section:11 S/R: list allocated DSNs   */\n                             /*****************************************/\nAllocatedDsns:\n  /* Create table of all allocated datasets                           */\n                             /* Trap TSO LISTA output                 */\n  a = outtrap(\"LINE.\",\"*\")\n  address \"TSO\" \"LISTA ST\"\n  a = outtrap(\"FRED.\",0)\n  yshow = \"\"\n  ytype = \"\"\n                             /* Build list of allocated datasets      */\n  \"TBCREATE LISTA NOWRITE REPLACE\" ListNames\n  do i = 2 to line.0\n                             /* Find DDname and DSNs                  */\n     if substr(line.i,1,2) \\= \"  \" then\n     do\n                             /* It's a DSN line                       */\n        parse var line.i part1 part2 .\n        if part1 \\= \"TERMFILE\" then\n        do\n           ldsn = part1\n           j = i + 1\n                             /* Find DDname, if any, on the next line */\n           parse var line.j part1 part2 ','\n           if part2 = \"\"\n           then lddname = \"\"\n           else lddname = part1\n           \"TBADD LISTA\"\n        end\n     end\n  end\n  AllocTableBuilt = \"YES\"\n  return\n                             /* Section:12 S/R: Display table         */\n                             /*****************************************/\nDisplayTable:\n  /* Display temporary table and process additions                    */\n  \"CONTROL DISPLAY SAVE\"\n  arg table,t_panel,t_sortarg\n  ascroll   = yscroll\n  old_lashow = \"\"\n  old_latype = \"\"\n  lashow     = \"\"\n  latype     = \"\"\n  lmem       = \"\"\n  crp        = 0\n  tblrow     = 0\n  \"TBTOP\"   table\n  \"TBDISPL\" table \"PANEL(\"t_panel\") CSRROW(\"tblrow\")\"\n  subTbRc = rc\n  do while subTbRc < 8 | ztdsels > 0\n                             /* parse command line ignoring           */\n                             /* interpolated blanks                   */\n     parse var bzcmd command alopt1 alopt2 alopt3 alopt4 .\n                             /*   SS:12 azcmd:LOCATE                  */\n                             /* Locate specified DDname               */\n     if azcmd = \"LOCATE\" then\n     do\n        azcmd = \"\"\n        \"TBTOP\"    table\n        \"TBVCLEAR\" table\n        lddname  = alopt1\n        \"TBSCAN\" table \"ARGLIST(LDDNAME) CONDLIST(EQ) POSITION(CRP)\"\n     end\n     else\n                             /*   SS:12 azcmd:FIND                    */\n     if azcmd = \"FIND\" then\n     do\n                             /* MEMBER and TYPE parameters reqd.      */\n        if alopt1 = \"\" then\n        do\n           zcmd = zcmd \"?  ?\"\n           \"SETMSG MSG(UTMDD036)\"\n        end\n        else\n        do\n           \"TBTOP\"    table\n           \"TBVCLEAR\" table\n           lddname = alopt2\n                             /* scan either for ALL or by TYPE        */\n           \"TBSARG\"   table \"NAMECOND(LDDNAME,EQ)\"\n           \"TBSCAN\"   table \"POSITION(CRP)\"\n           if rc = 0 then\n           do until lddname \\= \"\"\n\n              zlvers        = \"\"\n              zlmod         = \"\"\n              zlmdate       = \"\"\n              zlmtime       = \"\"\n              zluser        = \"\"\n                             /* get member and stats                  */\n              \"LMINIT  DATAID(FDSET) DATASET('\"ldsn\"')\"\n              \"LMOPEN  DATAID(\"fdset\")\"\n              \"LMMFIND DATAID(\"fdset\") MEMBER(\"alopt1\") STATS(YES)\"\n              if rc = 0 then\n              do\n                             /* move stats in if any were found       */\n                 if  zlvers \\= \"\" then\n                   lstats = zlvers\".\"zlmod zlmdate zlmtime zluser\n                 else lstats = \"Found with no ISPF stats\"\n                 lmem = alopt1\n              end\n              else\n              do\n                 lmem = \"\"\n                 lstats = \"\"\n              end\n\n              \"LMCLOSE DATAID(\"fdset\")\"\n              \"LMFREE  DATAID(\"fdset\")\"\n              \"TBPUT\" table\n                             /* get next matching row                 */\n              \"TBSKIP\" table\n           end\n                             /* Suppress display of final MEMBER NOT  */\n                             /* FOUND message as it is misleading     */\n           zerrsm = \"\"\n        end\n     end\n     else crp = ztdtop\n\n                             /* Process all selected lines            */\n     do while ztdsels > 0\n                             /* Update table                          */\n        \"TBPUT\" table\n                             /*   SS:12 alcmd:S                       */\n                             /* Select lines for table                */\n        if alcmd = \"S\" then\n        do\n                             /* Select (LIST tables only)             */\n           SortR = \"YES\"\n           \"VPUT SORTR SHARED\"\n           ytext = ldsn\n                             /* Inherit attributes from previous      */\n                             /* selection if not entered              */\n           if lashow  = \"\" then lashow = old_lashow\n           if latype  = \"\" then latype = old_latype\n                             /* store for inheritance                 */\n           old_lashow = lashow\n           old_latype = latype\n           ladded = \"Added\"\n                             /* Always show new line                  */\n           ydispl = \"YES\"\n                             /* Update table                          */\n           \"TBPUT\" table\n                             /* Initialise line for main table        */\n           yshow = lashow\n           ytype = latype\n           ymem  = \"\"\n           yomem = \"\"\n                             /*  Show that selection made             */\n           \"TBADD UTTDSM5\"\n        end\n        else\n                             /*   SS:12 alcmd:B alcmd:E               */\n        if alcmd = \"B\" | alcmd = \"E\" | alcmd = \"V\" then\n        do\n                             /* Browse (TEMPLATE and LIST tables)     */\n           if table \\= \"UTTEMPL\" then\n           do\n              opdsn = ldsn\n              opmem = lmem\n           end\n           else\n           do\n                             /* (Full member list always given for    */\n                             /* UTTEMPL - it won't be used much)      */\n              opdsn = ydsnt\n              opmem = \"\"\n           end\n\n           if opmem \\= \"\"\n           then fullc = oper.alcmd \"DATASET('\"opdsn\"(\"strip(opmem)\")')\"\n           else fullc = oper.alcmd \"DATASET('\"opdsn\"')\"\n\n           \"CONTROL DISPLAY SAVE\"\n                             /* just in case it's rubbish....         */\n           AcceptCC = 20\n           fullc\n           AcceptCC = AcceptCCMax\n           \"CONTROL DISPLAY RESTORE\"\n        end\n        else\n                             /*   SS:12 alcmd:E  alcmd:R              */\n        if alcmd = \"I\"  | alcmd = \"R\" then\n        do\n                             /* Insert lines                          */\n           if alcmd = \"I\"\n           then \"TBVCLEAR\" table\n\n           \"TBADD\" table\n           \"TBQUERY\" table \"POSITION(TBLROW)\"\n        end\n        else\n                             /*   SS:12 alcmd:D                       */\n        if alcmd = \"D\" then\n        do\n                             /* Delete lines                          */\n           \"TBDELETE\" table\n        end\n\n        alcmd = \"\"\n                             /*  get next selected line               */\n        if ztdsels = 1\n        then  ztdsels = 0\n        else \"TBDISPL\" table\n     end\n                             /* make sure any error message is only   */\n                             /* displayed once                        */\n     if zerrsm \\= \"\" then\n     do\n        \"SETMSG MSG(UTMDD010) COND\"\n        zerrsm = \"\"\n     end\n                             /* sort table if requested               */\n     if t_sortarg \\= \"\"\n     then \"TBSORT\" table t_sortarg\n\n                             /* reposition table                      */\n     azcmd = \"\"\n     if subTbRc \\= 8 then\n     do\n        \"TBTOP  \" table\n        \"TBSKIP \" table \"NUMBER(\"crp\")\"\n        \"TBDISPL\" table \"PANEL(\"t_panel\") CSRROW(\"tblrow\")\"\n        SubTbRc = rc\n     end\n  end\n  \"CONTROL DISPLAY RESTORE\"\n  return\n                             /* Section:13 S/R: Invoke SuperC         */\n                             /*****************************************/\nSuperC:\n  outdsn =  \"'\"xmvhlq\".SUPERC\"zscreen\"'\"\n\n  address \"TSO\" \"FREE  DD(SYSIN2)\"\n                             /* Dataset/members to be compared        */\n  address \"TSO\" \"ALLOC DD(OLDDD) DA(\"fqolddsn\") SHR REUSE\"\n  address \"TSO\" \"ALLOC DD(NEWDD) DA(\"fqnewdsn\") SHR REUSE\"\n  address \"TSO\" \"ALLOC DD(OUTDD) DA(\"outdsn\")\" ,\n                \"NEW SPACE(1,5) CYLINDERS REUSE\"\n                             /* Compare then browse output            */\n  \"SELECT PGM(ISRSUPC) PARM(\"SuperCParm\")\"\n                              /* Is it a merge action?                */\n  if SuperCAction = \"M\" then\n  do\n                              /* Yes, issue message saying merge done */\n     \"SETMSG MSG(UTMDD038)\"\n     SuperCAction = \"\"\n  end\n  else\n  do\n                              /* No, browse comparison output         */\n     \"CONTROL DISPLAY SAVE\"\n     \"BROWSE DATASET(\"outdsn\")\"\n     if rc \\= 0 then \"SETMSG MSG(UTMDD010)\"\n     \"CONTROL DISPLAY RESTORE\"\n  end\n                              /* Free datasets                        */\n  address \"TSO\" \"FREE  DD(SYSIN)\"\n  address \"TSO\" \"FREE  DD(OLDDD,NEWDD,OUTDD)\"\n  address \"TSO\" \"DELETE\" outdsn\n  return\n                             /* Section:14 S/R: Sort main table       */\n                             /*****************************************/\nsort_table:\n  /* Sort display into specified order                                */\n  arg sort_arg\n                             /* Renumber only needed if display lines */\n                             /* have been moved during the session    */\n  \"VGET SORTR SHARED\"\n  if SortR = \"YES\" then\n  do\n     SortR = \"\"\n     \"VPUT SORTR SHARED\"\n                             /* TBSORT will randomise the order of    */\n                             /* rows with equal sort keys; assigning  */\n                             /* each row a unique number and using it */\n                             /* in the sort stops this.               */\n     SortR = \"\"\n     xx = 1\n     \"TBTOP  UTTDSM5\"\n     \"TBSKIP UTTDSM5\"\n     do while rc = 0\n        yline = xx\n        xx = xx + 1\n        \"TBPUT UTTDSM5\" tsave\n        \"TBSKIP UTTDSM5\"\n     end\n  end\n  \"TBSORT UTTDSM5 FIELDS(\"sort_arg\")\"\n  return\n                             /* Section:15 S/R: Display help table    */\n                             /*****************************************/\n help_display:\n                             /* Display command summary table         */\n  \"TBDISPL UTTHELP PANEL(UTPHCMD)\"\n  do while rc < 8\n                             /* Allow multiple S prefix commands      */\n     do while ztdsels > 0\n\n        if lhcmd = \"S\" then\n        do\n                             /* Display on a panel full details of    */\n                             /* the selected command                  */\n           \"CONTROL DISPLAY SAVE\"\n           \"DISPLAY PANEL(UTPHCMD1)\"\n           do while rc < 8\n              \"DISPLAY PANEL(UTPHCMD1)\"\n           end\n           \"CONTROL DISPLAY RESTORE\"\n        end\n                             /* Get next selected line                */\n        if ztdsels > 1\n        then \"TBDISPL  UTTHELP\"\n        else ztdsels = 0\n     end\n     lhcmd = \"\"\n     \"TBDISPL UTTHELP PANEL(UTPHCMD)\"\n  end\n  return\n                             /* Section:16 S/R: Create SuperC stmts   */\n                             /*****************************************/\n SuperCStatements:\n  arg LogicalOption\n                             /* Create SuperC input statements file   */\n                             /* from the specified from:to columns    */\n  outline.1  = \"*\"\n  if ycpcoll \\= 0 then\n  do\n                             /* Non-zero leftmost column, so create   */\n                             /* a statements file                     */\n     outline.1  = \"CMPCOLM\" ycpcoll\":\"ycpcolr\n     lines = 1\n     SysinRqd = \"YES\"\n  end\n  if LogicalOption = \"LOGICAL\" then\n  do\n                             /* Make sure case does not affect the    */\n                             /* scan for change control keywords      */\n     outline.2   = \"NCHGT 'c','C'\"\n     outline.3   = \"NCHGT 'Ch','CH'\"\n     outline.4   = \"NCHGT 'CHa','CHA'\"\n     outline.5   = \"NCHGT 'CHAn','CHAN'\"\n     outline.6   = \"NCHGT 'CHANg','CHANG'\"\n     outline.7   = \"NCHGT 'CHANGe','CHANGE'\"\n     outline.8   = \"NCHGT 'CHANGEc','CHANGEC'\"\n     outline.9   = \"NCHGT 'CHANGECo','CHANGECO'\"\n     outline.10  = \"NCHGT 'CHANGECOn','CHANGECON'\"\n     outline.11  = \"NCHGT 'CHANGECONt','CHANGECONT'\"\n     outline.12  = \"NCHGT 'CHANGECONTr','CHANGECONTR'\"\n     outline.13  = \"NCHGT 'CHANGECONTRo','CHANGECONTRO'\"\n     outline.14  = \"NCHGT 'CHANGECONTROl','CHANGECONTROL'\"\n     outline.15  = \"NCHGT 'CHANGECONTROL-s','CHANGECONTROL-S'\"\n     outline.16  = \"NCHGT 'CHANGECONTROL-St','CHANGECONTROL-ST'\"\n     outline.17  = \"NCHGT 'CHANGECONTROL-STa','CHANGECONTROL-STA'\"\n     outline.18  = \"NCHGT 'CHANGECONTROL-STAr','CHANGECONTROL-STAR'\"\n     outline.19  = \"NCHGT 'CHANGECONTROL-STARt','CHANGECONTROL-START'\"\n     outline.20  = \"NCHGT 'CHANGECONTROL-e','CHANGECONTROL-E'\"\n     outline.21  = \"NCHGT 'CHANGECONTROL-En','CHANGECONTROL-EN'\"\n     outline.22  = \"NCHGT 'CHANGECONTROL-ENd','CHANGECONTROL-END'\"\n     outline.23  = \"OCHGT 'c','C'\"\n     outline.24  = \"OCHGT 'Ch','CH'\"\n     outline.25  = \"OCHGT 'CHa','CHA'\"\n     outline.26  = \"OCHGT 'CHAn','CHAN'\"\n     outline.27  = \"OCHGT 'CHANg','CHANG'\"\n     outline.28  = \"OCHGT 'CHANGe','CHANGE'\"\n     outline.29  = \"OCHGT 'CHANGEc','CHANGEC'\"\n     outline.30  = \"OCHGT 'CHANGECo','CHANGECO'\"\n     outline.31  = \"OCHGT 'CHANGECOn','CHANGECON'\"\n     outline.32  = \"OCHGT 'CHANGECONt','CHANGECONT'\"\n     outline.33  = \"OCHGT 'CHANGECONTr','CHANGECONTR'\"\n     outline.34  = \"OCHGT 'CHANGECONTRo','CHANGECONTRO'\"\n     outline.35  = \"OCHGT 'CHANGECONTROl','CHANGECONTROL'\"\n     outline.36  = \"OCHGT 'CHANGECONTROL-s','CHANGECONTROL-S'\"\n     outline.37  = \"OCHGT 'CHANGECONTROL-St','CHANGECONTROL-ST'\"\n     outline.38  = \"OCHGT 'CHANGECONTROL-STa','CHANGECONTROL-STA'\"\n     outline.39  = \"OCHGT 'CHANGECONTROL-STAr','CHANGECONTROL-STAR'\"\n     outline.40  = \"OCHGT 'CHANGECONTROL-STARt','CHANGECONTROL-START'\"\n     outline.41  = \"OCHGT 'CHANGECONTROL-e','CHANGECONTROL-E'\"\n     outline.42  = \"OCHGT 'CHANGECONTROL-En','CHANGECONTROL-EN'\"\n     outline.43  = \"OCHGT 'CHANGECONTROL-ENd','CHANGECONTROL-END'\"\n     outline.44  = \"CMPLINE TOP 'CHANGECONTROL-START'\"\n     outline.45  = \"CMPLINE BTM 'CHANGECONTROL-END'\"\n     lines = 45\n  end\n  if SysinRqd = \"YES\" then\n  do\n     address \"TSO\" \"ALLOC DD(SYSIN) SP(1) TRACKS REUSE\"         ,\n                   \"DSORG(PS) RECFM(F B) LRECL(80) BLKSIZE(80)\"\n     address \"TSO\" \"EXECIO\" lines \"DISKW SYSIN (FINIS STEM OUTLINE.\"\n  end\n                             /* leftmost column zero, so no Sysin     */\n                             /* and SuperC will do full width compare */\n  else\n  do\n     address \"TSO\" \"FREE DD(SYSIN)\"\n  end\n\n  return\n                             /* Section:16 S/R: SuperC datasets       */\n                             /*****************************************/\ncheckDsns:\n                             /* Check member name settings            */\n                             /* If only one set, then it is used for  */\n                             /* both comparisons. If both are set,    */\n                             /* then use both                         */\n  select\n     when newmem = \"\" & oldmem = \"\" then\n     do\n        fqolddsn = \"'\"olddsn\"'\"\n        fqnewdsn = \"'\"newdsn\"'\"\n     end\n     when newmem  = \"\" & oldmem \\= \"\" then\n     do\n        fqolddsn = \"'\"olddsn\"(\"oldmem\")'\"\n        fqnewdsn = \"'\"newdsn\"(\"oldmem\")'\"\n     end\n     when newmem \\= \"\" & oldmem = \"\" then\n     do\n        fqolddsn = \"'\"olddsn\"(\"newmem\")'\"\n        fqnewdsn = \"'\"newdsn\"(\"newmem\")'\"\n     end\n     otherwise\n     do\n        fqolddsn = \"'\"olddsn\"(\"oldmem\")'\"\n        fqnewdsn = \"'\"newdsn\"(\"newmem\")'\"\n     end\n  end\n                             /* check also Merge dataset              */\n  if mrgdsn \\= \"\" then\n  do\n     select\n        when mrgmem \\= \"\" then fqmrgdsn = \"'\"mrgdsn\"(\"mrgmem\")'\"\n        when newmem \\= \"\" then\n        do\n           fqmrgdsn = \"'\"mrgdsn\"(\"newmem\")'\"\n           mrgmem   = newmem\n        end\n        when oldmem \\= \"\" then\n        do\n           fqmrgdsn = \"'\"mrgdsn\"(\"oldmem\")'\"\n           mrgmem   = oldmem\n        end\n        otherwise\n     end\n  end\n  return\ngetISPFStats:\n\n  arg StatsDataid StatsMem StatsAction\n  zllib   = \"\"\n  zlvers  = \"\"\n  zlmod   = \"\"\n  zlcdate = \"\"\n  zlmdate = \"\"\n  zlmtime = \"\"\n  zlcnorc = \"\"\n  zlinorc = \"\"\n  zlmnorc = \"\"\n  zluser  = \"\"\n  source = StatsDataid\n                             /* Open dataid only if requested         */\n  rc = 0\n  if StatsAction = \"OPEN\"\n  then \"LMOPEN  DATAID(\"source\")\"\n  if rc = 0 then\n  do\n                             /* Find member if open successful        */\n     \"LMMFIND DATAID(\"source\") MEMBER(\"StatsMem\") STATS(YES)\"\n     if rc = 0 then\n     do\n                             /* Construct message giving ISPF stats   */\n        if zluser \\= \"\"\n        then sLegend = \"Last edited by\" zluser \"on\" zlmdate ,\n                       \"at\" zlmtime\n        else sLegend = \"No ISPF stats for this member\"\n     end\n     else sLegend = rc StatsMem zerrlm\n                             /* Notify level if current and last user */\n                             /* the same, or if no ISPF stats. If     */\n                             /* user now is not the same as the last  */\n                             /* user, issue a warning message         */\n     if zluser = zuser | zluser = \"\"\n     then sType = \"NOTIFY\"\n     else sType = \"WARNING\"\n     sMessage   = \"UTMDD045\"\n  end\n  else \"SETMSG MSG(UTMDD010)\"\n                             /* close dataid, if requested            */\n  if StatsAction = \"OPEN\"\n  then \"LMCLOSE DATAID(\"source\")\"\n\n  return\nbatchTSO:\n                             /* Build TSO batch job                   */\n\n  \"CONTROL DISPLAY SAVE\"\n  \"DISPLAY PANEL(UTPDSM5M)\"\n  dsrc = rc\n  \"CONTROL DISPLAY RESTORE\"\n  if dsrc = 0 then\n  do\n     arg skeleton\n     \"FTOPEN TEMP\"\n     \"FTINCL UTSJOB\"\n     \"FTINCL UTSTSO\"\n     \"FTINCL\" skeleton\n     \"FTCLOSE\"\n     \"VGET ZTEMPF SHARED\"\n     \"VGET YEDIT  PROFILE\"\n                             /* Edit or submit the JCL                */\n     if yedit = \"YES\" then\n     do\n        \"CONTROL DISPLAY SAVE\"\n        \"EDIT DATASET('\"ztempf\"')\"\n        \"CONTROL DISPLAY RESTORE\"\n     end\n     else call submit \"'\"ztempf\"'\"\n  end\n  return\n\nsubmit:\n                             /* trap output messages from submission  */\n  arg dsn\n  a = msg(\"ON\")\n  a = outtrap(\"LINE.\",\"*\")\n  address \"TSO\" \"PROFILE MSGID\"\n  address \"TSO\" \"SUBMIT\" dsn\n  a = msg(\"OFF\")\n  a = outtrap(\"FRED.\",0)\n  parse var line.1 . . jobno .\n  \"SETMSG MSG(UTMDD023)\"\n  return\n /********************************************************************/\n                             /* Generalised error handling            */\nError:\n                             /* Return acceptable code to the program */\n  if (rc >= 0 & rc <= AcceptCC) then\n  do\n     return\n  end\n                             /* Or report the error and terminate     */\n  eline = sourceline(sigl)\n  errCond = condition(\"C\")\n  errDesc = condition(\"D\")\n                             /* get error text if applicable          */\n  if lrc > 0 & lrc < 100\n  then etext = errortext(lrc)\n  else etext = \"\"\n                             /* Check error code                      */\n  if lrc = -3\n  then etext = \"A Host command was not found\"\n  \"DISPLAY PANEL(UTPDSM5Z)\"\n  signal qquit\n                             /* :END end of processing                */\n/**********************************************************************/\n/*                                                                    */\n/* Maintenance Notes - Use of Edit                                    */\n/* -------------------------------                                    */\n/*                                                                    */\n/* 1) find major sections     F SECTION: ALL                          */\n/* 2) subsections             F SS: ALL                               */\n/*                                                                    */\n/* Notes                                                              */\n/* -----                                                              */\n/*  a) each major section has a number (e.g. SECTION:3) and there is  */\n/*     never a blank between the colon (:) and the number             */\n/*  b) each SS: is followed by the number of the section of which it  */\n/*     is a part (e.g. SS:3) folowed by further commentary.           */\n/*                                                                    */\n/*  To find the code relating to a line (prefix area) or command line */\n/*  command in one of the various displays, use the Edit finds as     */\n/*  below where xxx is the command (xxx can be more or less than      */\n/*  three characters).                                                */\n/*                                                                    */\n/* 1) main display line commands                     F LINECMD:xxx    */\n/* 2) main display main commands                     F ZCMD:xxx       */\n/* 3) LA and ADD prefix sub-display line commands    F ALCMD:xxx      */\n/* 4)   ditto                       main commands    F ALCMD:xxx      */\n/* 5) member list line commands                      F ZLLCMD:xxx     */\n/*                                                                    */\n/**********************************************************************/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "UTHDSM5": {"ttr": 2563, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01\\x00\\x1f\\x01\\x01\\x00\\x1f\\x00\\x00\\x00\\x0e\\x00\\x00\\x00\\x00\\xe9\\xe9\\xe9\\xe9\\xe9\\xe9\\xe9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-01-01T00:00:00", "modifydate": "2001-01-01T00:00:00", "lines": 14, "newlines": 0, "modlines": 0, "user": "ZZZZZZZ"}, "text": ")attr\n)body expand(}})\n+DDF%Help+ ------------------+&zuser &today       +}-}\n%Command ===>_zcmd                                                            +\n+\n+\n+ To get a summary of available commands, go back to the main display\n+ and type%CMDL+on the command line.\n+\n+\n)init\n)reinit\n)proc\n)end\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "UTMDD01": {"ttr": 2565, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01\\x00\\x1f\\x01\\x01\\x00\\x1f\\x00\\x00\\x00\\x12\\x00\\x00\\x00\\x00\\xe9\\xe9\\xe9\\xe9\\xe9\\xe9\\xe9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-01-01T00:00:00", "modifydate": "2001-01-01T00:00:00", "lines": 18, "newlines": 0, "modlines": 0, "user": "ZZZZZZZ"}, "text": "UTMDD010 '&zerrsm'\n'&zerrlm'\nUTMDD011 'DDF Edit recover'\n'DDF automatically initiates Edit recovery first of all'\nUTMDD012 'Invalid command'\n'Command not recognised'\nUTMDD013 'level must be > 0'\n'Dataset level must be a number greater than zero'\nUTMDD014 'Failed &reason'\n'LISTDSI reason code was &reason.. Check if DSN is correct'\nUTMDD015 'No member specified'\n'If you want to copy many members use 3.3 prefix command'\nUTMDD016 '&act (&actrc)'\n'&frds(&frmember) to &tods(&tomember)'\nUTMDD017 'Failed &act(&actrc)'\n'&zerrlm'\nUTMDD018 'No member specified'\n'Single member delete requires the member name'\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "UTMDD02": {"ttr": 2567, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01\\x00\\x1f\\x01\\x01\\x00\\x1f\\x00\\x00\\x00\\x12\\x00\\x00\\x00\\x00\\xe9\\xe9\\xe9\\xe9\\xe9\\xe9\\xe9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-01-01T00:00:00", "modifydate": "2001-01-01T00:00:00", "lines": 18, "newlines": 0, "modlines": 0, "user": "ZZZZZZZ"}, "text": "UTMDD021 'Delete failed(&rc)'\n'&zerrlm'\nUTMDD022 'Deleted &delmem'\n'Deleted &ytext(&delmem)'\nUTMDD023 '&jobno'\n'Submitted &jobno'\nUTMDD024 'compressed'\n' dataset &ytext compressed'\nUTMDD025 'request failed'\n'&zerrlm'\nUTMDD026 'MEMBER and TYPE reqd'\n'The member you want and its type (or ALL) must be specified'\nUTMDD027 ''\n'Specifiy the TYPE, * NX to search all non-excluded, or * X for excluded'\nUTMDD028 'All datasets shown\n'All datasets searched, whether successful or not, are shown'\nUTMDD029 'Only success shown\n'Only the datasets where the search was successful are shown'\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "UTMDD03": {"ttr": 2569, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01\\x00\\x1f\\x01\\x01\\x00\\x1f\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\xe9\\xe9\\xe9\\xe9\\xe9\\xe9\\xe9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-01-01T00:00:00", "modifydate": "2001-01-01T00:00:00", "lines": 16, "newlines": 0, "modlines": 0, "user": "ZZZZZZZ"}, "text": "UTMDD031 'Old DSN error'\n'&olddsn &Status1.'\nUTMDD032 'New DSN error'\n'&newdsn &Status2.'\nUTMDD033 'Member name needed'\n'A member name must be specified for compare and merge'\nUTMDD034 'Merge DSN error'\n'&mrgdsn &Status3.'\nUTMDD035 'Merge member exists'\n'&mrgdsn &mrgmem already exists, merge would overwrite it.'\nUTMDD036 'MEMBER and DDname needed'\n'You can Find a member within an allocated DDname'\nUTMDD037 'Saved(&rc.)'\n'DDF main table was saved with code &RC..'\nUTMDD038 '&mrgmem created'\n'&mrgdsn &mrgmem was created\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "UTMDD04": {"ttr": 2571, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01\\x00\\x1f\\x01\\x01\\x00\\x1f\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\xe9\\xe9\\xe9\\xe9\\xe9\\xe9\\xe9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-01-01T00:00:00", "modifydate": "2001-01-01T00:00:00", "lines": 4, "newlines": 0, "modlines": 0, "user": "ZZZZZZZ"}, "text": "UTMDD041 .TYPE=WARNING\n'DDF is already running on this screen and may not be used recursively'\nUTMDD045 .TYPE=&STYPE\n'&sLegend'\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "UTMDD05": {"ttr": 2573, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01\\x00\\x1f\\x01\\x01\\x00\\x1f\\x00\\x00\\x00\\n\\x00\\x00\\x00\\x00\\xe9\\xe9\\xe9\\xe9\\xe9\\xe9\\xe9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-01-01T00:00:00", "modifydate": "2001-01-01T00:00:00", "lines": 10, "newlines": 0, "modlines": 0, "user": "ZZZZZZZ"}, "text": "UTMDD050 'No version list active'\n'Use VSL nn to select a version library list'\nUTMDD051 'Added to &vtable'\n'&ytext added to &vtable.'\nUTMDD052 'No job submitted'\n'Use SUB on the Version Selection List to request a versions report'\nUTMDD053 'Job will be submitted'\n'Versions report will be submitted on exit from this list'\nUTMDD054 'No job submission'\n'Versions report will not be produced'\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "UTMDD09": {"ttr": 2575, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01\\x00\\x1f\\x01\\x01\\x00\\x1f\\x00\\x00\\x00\\x07\\x00\\x00\\x00\\x00\\xe9\\xe9\\xe9\\xe9\\xe9\\xe9\\xe9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-01-01T00:00:00", "modifydate": "2001-01-01T00:00:00", "lines": 7, "newlines": 0, "modlines": 0, "user": "ZZZZZZZ"}, "text": "UTMDD091 '' .WINDOW=LNORESP\n'You have used DDF &zlmnorc times. Please enter any new opinions ' +\n'about the product if you wish. Thank you'\nUTMDD098 ''\n'&notsup not supported in this version'\nUTMDD099 ''\n'Welcome to the Dataset Display Facility'\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "UTPDSM5": {"ttr": 2577, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01\\x00\\x1f\\x01\\x01\\x00\\x1f\\x00\\x00\\x00Y\\x00\\x00\\x00\\x00\\xe9\\xe9\\xe9\\xe9\\xe9\\xe9\\xe9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-01-01T00:00:00", "modifydate": "2001-01-01T00:00:00", "lines": 89, "newlines": 0, "modlines": 0, "user": "ZZZZZZZ"}, "text": ")attr\n! type(input) intens(high) just(left)  caps(on)\n? type(text)  skip(on) color(turq)\n@ type(input) intens(low)  just(left)  caps(on)  padc(nulls)\n# type(input) intens(low)  just(left)  caps(off) padc(nulls) color(turq)\n+ type(text)  intens(low)  skip (on)\n\\ type(output) color(turquoise)\n)body expand(}})\n+DDF 1.0%PF1+for help -------+&zuser &today       +}-}\n%Command ===>_zcmd                                           %Scroll ===>_z   +\n+Show list >@pshow                                              +<\n%Cmd  +Member+  Text                                   Description   Show   Type\n)Model rows(scan)\n!lcmd @z       @z                                     #z            @z     @z\n)init\n .help = uthdsm5\n .zvars = '(yscroll ymem ytext ydesc yshow ytype)'\n)reinit\n refresh(lcmd pshow)\n if (&ztdsels = 0000)\n   refresh(zcmd)\n)proc\n &szcmd = &zcmd\n &zcmd = trunc(&zcmd,' ')\n &opt1 = .trail\n &opt1 = trunc(&opt1,' ')\n &opt2 = .trail\n &opt2 = trunc(&opt2,' ')\n &opt3 = .trail\n &zcmd = trans(&zcmd\n              CAN,CANCEL\n              CANC,CANCEL CANCE,CANCEL\n              F,FIND FI,FIND FIN,FIND\n              H,HEADS HE,HEADS HEA,HEADS HEAD,HEADS\n              LA,LISTALLOC\n              R,RESET RE,RESET RES,RESET RESE,RESET\n              SAV,SAVE\n              S,SHOW SH,SHOW SHO,SHOW\n              *,*)\n if (&pshow \u00ac= &stshow)\n   if (&zcmd = &z)\n      &zcmd = SHOW\n if  (&zcmd \u00ac= &z,ADD,CANCEL,CMDL,FAQ,FIND,HEADS,LISTALLOC,\n                  PARM,RESET,SAVE,SHOW,SORT,TEMPL,VSL)\n   &zcmd = &szcmd\n   .msg = utmdd012\n if (&zcmd \u00ac= CANCEL)\n   &linecmd = ' '\n   &lcmd = trunc(&lcmd,' ')\n   &lopt = .trail\n   &lcmd = trans(&lcmd 3.1,31\n                       3.2,32\n                       3.3,33\n                       3.4,34\n                       3.6,36\n                       3.14,314\n                       ST,STATS STA,STATS STAT,STATS\n                       *,*)\n   if (&lcmd = E,B,ML,V,\n               A,B4,BE,D,C,M,X,\n               CO,MO,TO,OV,\n               HI,SH,\n               CPN,CPO,\n               NEW,OLD,MRG,\n               SUB,ACT,DEL,EX,\n               31,32,33,34,36,314\n               COMP,STATS,TM,VSA,UC)\n     &linecmd  = &lcmd\n     if (&linecmd = 34)\n       if (&lopt = 0)\n          &lopt = &z\n          &linecmd = &z\n          .msg = utmdd013\n       else\n          &lpart1 = trunc(&text,'.')\n          &lpart2 = .trail\n          &lpart2 = trunc(&lpart2,'.')\n          &lpart3 = .trail\n          &lpart3 = trunc(&lpart3,'.')\n          &lpart4 = .trail\n          &lpart4 = trunc(&lpart4,'.')\n     else\n   else\n     &linecmd  = trunc(&lcmd,1)\n     if (&linecmd = I,R)\n        &number   = .trail\n     else &linecmd = &z\n   &lcmd = ' '\n)end\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "UTPDSM5A": {"ttr": 2580, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01\\x00\\x1f\\x01\\x01\\x00\\x1f\\x00\\x00\\x00\\x03\\x00\\x00\\x00\\x00\\xe9\\xe9\\xe9\\xe9\\xe9\\xe9\\xe9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-01-01T00:00:00", "modifydate": "2001-01-01T00:00:00", "lines": 3, "newlines": 0, "modlines": 0, "user": "ZZZZZZZ"}, "text": ")body\n%Command ===>_zcmd\n)end\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "UTPDSM5C": {"ttr": 2582, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01\\x00\\x1f\\x01\\x01\\x00\\x1f\\x00\\x00\\x00\\x1d\\x00\\x00\\x00\\x00\\xe9\\xe9\\xe9\\xe9\\xe9\\xe9\\xe9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-01-01T00:00:00", "modifydate": "2001-01-01T00:00:00", "lines": 29, "newlines": 0, "modlines": 0, "user": "ZZZZZZZ"}, "text": ")attr\n! type(&xtype) color(&xcolor)   caps(off)\n\u00ac type(output) color(white)     caps(off)\n)Body expand(}})\n+ }-} Member stats }-}\n%Command ===>_zcmd\n+\n+                       member  \u00acYMEM\n+                      library  \u00acYTEXT\n+\n+               Version number  !ZLVERS\n+           Modification level  !ZLMOD\n+                Creation date  !ZLCDATE\n+           Last changed  date  !ZLMDATE\n+           Last changed  time  !ZLMTIME\n+    Current number of records  !ZLCNORC\n+  Beginning number of records  !ZLINORC\n+    Number of changed records  !ZLMNORC\n+                       Userid  !ZLUSER\n+\n+\n+  Use command%UPDATE+to reset statistics\n)init\n)proc\n  if (&zcmd = UPD,UPDA,UPDAT,UPDATE)\n     &xtype  = INPUT\n     &xcolor = GREEN\n     &zcmd   = &z\n)end\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "UTPDSM5D": {"ttr": 2584, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01\\x00\\x1f\\x01\\x01\\x00\\x1f\\x00\\x00\\x01\\x02\\x00\\x00\\x00\\x00\\xe9\\xe9\\xe9\\xe9\\xe9\\xe9\\xe9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-01-01T00:00:00", "modifydate": "2001-01-01T00:00:00", "lines": 258, "newlines": 0, "modlines": 0, "user": "ZZZZZZZ"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "UTPDSM5E": {"ttr": 2818, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01\\x00\\x1f\\x01\\x01\\x00\\x1f\\x00\\x00\\x00T\\x00\\x00\\x00\\x00\\xe9\\xe9\\xe9\\xe9\\xe9\\xe9\\xe9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-01-01T00:00:00", "modifydate": "2001-01-01T00:00:00", "lines": 84, "newlines": 0, "modlines": 0, "user": "ZZZZZZZ"}, "text": ")attr\n! type(input) intens(high) just(left)  caps(on)\n\u00ac type(output)intens(low)\n@ type(input) intens(low)  just(left)  caps(on)  padc(nulls)\n# type(input) intens(low)  just(left)  caps(off) padc(nulls) color(turq)\n+ type(text)  intens(low)  skip (on)\n)body expand(}})\n+}-}% Find +    PF3 to return to normal + }-}\n%Command ===>_zcmd                                           %Scroll ===>_dscr+\n%Cmd  +Member+   Text                              Stats\n)Model rows(scan)\n!lcmd+@z       @z                                 \u00actstats\n)init\n/*.help = uthdsm5*/\n .zvars = '(ymem ytext)'\n)reinit\n  refresh(lcmd)\n  if (&ztdsels = 0000)\n    refresh(zcmd)\n)proc\n &szcmd = &zcmd\n &zcmd = trunc(&zcmd,' ')\n &opt1 = .trail\n &opt1 = trunc(&opt1,' ')\n &opt2 = .trail\n &zcmd = trans(&zcmd\n              CAN,CANCEL\n              CANC,CANCEL CANCE,CANCEL\n              F,FIND FI,FIND FIN,FIND\n              H,HEADS HE,HEADS HEA,HEADS HEAD,HEADS\n              LA,LISTALLOC\n              R,RESET RE,RESET RES,RESET RESE,RESET\n              SAV,SAVE\n              S,SHOW SH,SHOW SHO,SHOW\n              *,*)\n if  (&zcmd \u00ac= &z,ADD,CANCEL,CMDL,FIND,HEADS,LISTALLOC,\n                  PARM,RESET,SAVE,SHOW,SORT,TEMPL,VSL)\n   &zcmd = &szcmd\n   .msg = utmdd012\n if (&zcmd \u00ac= CANCEL)\n   if (&zcmd \u00ac= &z)\n     &endfind = 'YES'\n   &linecmd = ' '\n   &lcmd = trunc(&lcmd,' ')\n   &lopt = .trail\n   &lcmd = trans(&lcmd 3.1,31\n                       3.2,32\n                       3.3,33\n                       3.4,34\n                       3.6,36\n                       3.14,314\n                       ST,STATS STA,STATS STAT,STATS\n                       *,*)\n   if (&lcmd = E,B,ML,\n               A,B4,BE,D,C,M,X,\n               CO,MO,TO,OV,\n               HI,SH,\n               CPN,CPO,\n               NEW,OLD,MRG\n               SUB,ACT,DEL,EX,\n               31,32,33,34,36,314,\n               COMP,STATS,VSA)\n     &linecmd  = &lcmd\n     if (&linecmd = 34)\n       if (&lopt = 0)\n          &lopt = &z\n          &linecmd = &z\n          .msg = utmdd013\n       else\n          &lpart1 = trunc(&text,'.')\n          &lpart2 = .trail\n          &lpart2 = trunc(&lpart2,'.')\n          &lpart3 = .trail\n          &lpart3 = trunc(&lpart3,'.')\n          &lpart4 = .trail\n          &lpart4 = trunc(&lpart4,'.')\n     else\n   else\n     &linecmd  = trunc(&lcmd,1)\n     if (&linecmd = I,R)\n        &number   = .trail\n     else &linecmd = &z\n   &lcmd = ' '\n)end\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "UTPDSM5F": {"ttr": 2821, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01\\x00\\x1f\\x01\\x01\\x00\\x1f\\x00\\x00\\x00\\x18\\x00\\x00\\x00\\x00\\xe9\\xe9\\xe9\\xe9\\xe9\\xe9\\xe9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-01-01T00:00:00", "modifydate": "2001-01-01T00:00:00", "lines": 24, "newlines": 0, "modlines": 0, "user": "ZZZZZZZ"}, "text": ")attr\n ! type(output) color(blue)\n @ type(output) color(white)\n _ type(input)  color(red) caps(on)\n)body expand(}})\n+}-} Select from allocated data sets }-}\n%Command ===>_zcmd                                           %Scroll ===>_z   +\n\nCmd DDname   Dataset name                          Added? Show     Type\n)model\n_z !lddname !ldsn                                 @z    +>_lashow +>_z\n)init\n .zvars = '(ascroll alcmd ladded latype)'\n)proc\n  &bzcmd   = &zcmd\n  &azcmd   = trunc(&zcmd,' ')\n  &alopt1  = .trail\n  &alopt1  = trunc(&alopt1,' ')\n  &alopt2  = .trail\n  &zcmd    = &z\n  &azcmd = trans(&azcmd L,LOCATE LO,LOCATE LOC,LOCATE LOCA,LOCATE\n                        LOCAT,LOCATE\n                        *,*)\n)end\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "UTPDSM5G": {"ttr": 2823, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01\\x00\\x1f\\x01\\x01\\x00\\x1f\\x00\\x00\\x00\\x17\\x00\\x00\\x00\\x00\\xe9\\xe9\\xe9\\xe9\\xe9\\xe9\\xe9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-01-01T00:00:00", "modifydate": "2001-01-01T00:00:00", "lines": 23, "newlines": 0, "modlines": 0, "user": "ZZZZZZZ"}, "text": ")attr\n ! type(output) color(blue)\n @ type(output) color(white)\n _ type(input)  color(red) caps(on)\n)body expand(}})\n+}-} Select from dataset prefix list }-}\n%Command ===>_zcmd                                           %Scroll ===>_z   +\n\nCmd          Dataset name                          Added?  Show    Type\n)model\n_z +        !ldsn                                 @z    +>_lashow+>_z   +<\n)init\n .zvars = '(ascroll alcmd ladded latype)'\n)reinit\n refresh (ladded lashow latype)\n)proc\n  &bzcmd   = &zcmd\n  &azcmd   = trunc(&zcmd,' ')\n  &alopt1  = .trail\n  &alopt1  = trunc(&alopt1,' ')\n  &alopt2  = .trail\n  &zcmd    = &z\n)end\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "UTPDSM5H": {"ttr": 2825, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01\\x00\\x1f\\x01\\x01\\x00\\x1f\\x00\\x00\\x00\\x19\\x00\\x00\\x00\\x00\\xe9\\xe9\\xe9\\xe9\\xe9\\xe9\\xe9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-01-01T00:00:00", "modifydate": "2001-01-01T00:00:00", "lines": 25, "newlines": 0, "modlines": 0, "user": "ZZZZZZZ"}, "text": ")attr\n ! type(output) color(blue)\n @ type(output) color(white)\n _ type(input)  color(red) caps(on)\n)body expand(}})\n+}-} List of allocated datasets }-}\n%Command ===>_zcmd                                           %Scroll ===>_z   +\n\nC  Member   DDname   Dataset name                   Stats\n)model\n_z!lmem    !lddname !ldsn                          @lstats\n)init\n .zvars = '(ascroll alcmd)'\n)proc\n  &bzcmd   = &zcmd\n  &azcmd   = trunc(&zcmd,' ')\n  &alopt1  = .trail\n  &alopt1  = trunc(&alopt1,' ')\n  &alopt2  = .trail\n  &zcmd    = &z\n  &azcmd = trans(&azcmd L,LOCATE LO,LOCATE LOC,LOCATE LOCA,LOCATE\n                        LOCAT,LOCATE\n                        F,FIND FI,FIND FIN,FIND\n                        *,*)\n)end\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "UTPDSM5I": {"ttr": 2827, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01\\x00\\x1f\\x01\\x01\\x00\\x1f\\x00\\x00\\x00\\x12\\x00\\x00\\x00\\x00\\xe9\\xe9\\xe9\\xe9\\xe9\\xe9\\xe9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-01-01T00:00:00", "modifydate": "2001-01-01T00:00:00", "lines": 18, "newlines": 0, "modlines": 0, "user": "ZZZZZZZ"}, "text": ")attr\n ! type(input) intens(low) color(green) caps(on)\n @ type(output) color(white)\n _ type(input)  color(red) caps(on)\n)body expand(}})\n+}-} Maintain template libraries }-}\n%Command ===>_zcmd                                           %Scroll ===>_z   +\n\n C Dataset name                          DDF type\n)model\n_z!ydsnt                                !ytypet\n)init\n .zvars = '(ascroll alcmd)'\n)proc\n  &alcmd  = trunc(&alcmd,1)\n  if (&alcmd = I,R,B,E,D)\n  else &alcmd = &z\n)end\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "UTPDSM5K": {"ttr": 2829, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01\\x00\\x1f\\x01\\x01\\x00\\x1f\\x00\\x00\\x00)\\x00\\x00\\x00\\x00\\xe9\\xe9\\xe9\\xe9\\xe9\\xe9\\xe9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-01-01T00:00:00", "modifydate": "2001-01-01T00:00:00", "lines": 41, "newlines": 0, "modlines": 0, "user": "ZZZZZZZ"}, "text": ")attr\n+ type(text)   color(blue)    caps(off) skip(on)\n)Body expand(^^)\n%^-^ SuperC extended ^-^\n%Command ===>_zcmd\n+\n+   %1+ Compare         - Compare using SuperC\n+   %2+ Merge           - Merge using SuperC\n+   %3+ Logical compare - Compare only the change control areas\n+\n+   New%===>_newdsn                                                  +<\n+Member%===>_newmem  +<\n+\n+   Old%===>_olddsn                                                  +<\n+Member%===>_oldmem  +<\n+\n+ Merge%===>_mrgdsn                                                  +<\n+Member%===>_mrgmem  +<\n+\n+ (Dataset names should be fully qualified, without quotes)\n+\n+      %===>_z  +< Leftmost compare column (zero for full width compare)\n+      %===>_z  +< Rightmost compare column\n)init\n  .zvars = '(ycpcoll ycpcolr)'\n  .cursor = zcmd\n)proc\n &zcmd = trunc(&zcmd,'.')\n &opt1 = .trail\n ver(&newdsn,nb,dsname)\n ver(&olddsn,nb,dsname)\n ver(&ycpcoll,nb,num)\n ver(&ycpcolr,nb,num)\n &ycpopt = &zcmd\n if (&zcmd = 2)\n    ver(&mrgdsn,nb,dsname)\n    ver(&oldmem,nb)\n    ver(&newmem,nb)\n    ver(&mrgmem,nb)\nvput (ycpcoll ycpcolr) profile\n)end\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "UTPDSM5L": {"ttr": 2831, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01\\x00\\x1f\\x01\\x01\\x00\\x1f\\x00\\x00\\x00 \\x00\\x00\\x00\\x00\\xe9\\xe9\\xe9\\xe9\\xe9\\xe9\\xe9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-01-01T00:00:00", "modifydate": "2001-01-01T00:00:00", "lines": 32, "newlines": 0, "modlines": 0, "user": "ZZZZZZZ"}, "text": ")attr\n ! type(output) color(blue)\n @ type(output) color(white)\n _ type(input)  color(red) caps(on)\n)body expand(}})\n+}-} Version Search Table@vTable+}-}\n%Command ===>_zcmd                                           %Scroll ===>_z   +\n\nCmd   Dataset name                         +Report letter\n)model\n_z+>_vtdsn                               +<_z+\n)init\n .zvars = '(ascroll alcmd vtletter)'\n)reinit\n refresh(*)\n)proc\n  &bzcmd   = &zcmd\n  &azcmd   = trunc(&zcmd,' ')\n  &zcmd    = &z\n  if (&bzcmd = SUB,SUBM,SUBMI,SUBMIT)\n     &vlsub = YES\n     .msg = UTMDD053\n     .resp  = END\n  if (&bzcmd = NOSUB,NOSUBM,NOSUBMI,NOSUBMIT)\n     &vlsub = NO\n     .msg = UTMDD054\n  &alcmd  = trunc(&alcmd,1)\n  if (&alcmd = I,R,B,E,D)\n  else &alcmd = &z\n  if (&vtletter = &z)\n      &vtletter = A\n)end\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "UTPDSM5M": {"ttr": 2833, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01\\x00\\x1f\\x01\\x01\\x00\\x1f\\x00\\x00\\x00\"\\x00\\x00\\x00\\x00\\xe9\\xe9\\xe9\\xe9\\xe9\\xe9\\xe9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-01-01T00:00:00", "modifydate": "2001-01-01T00:00:00", "lines": 34, "newlines": 0, "modlines": 0, "user": "ZZZZZZZ"}, "text": ")attr\n)body expand(}})\n+}-}% DDF job submission + }-}\n%Command ===>_zcmd\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+  Press%ENTER+key to submit job\n+  Enter%END+command to terminate\n+\n+JOB STATEMENT INFORMATION:\n%  ===>_UTVJB1\n%  ===>_UTVJB2\n%  ===>_UTVJB3\n%  ===>_VTVJB4\n)INIT\nif (&utvjb1 = &z)\n  &utvjb1 = &bjc1\nif (&utvjb2 = &z)\n  &utvjb2 = &bjc2\nif (&utvjb3 = &z)\n  &utvjb3 = &bjc3\nif (&utvjb4 = &z)\n  &utvjb4 = &bjc4\n)proc\n vput (utvjb1 utvjb2 utvjb3 utvjb4) profile\n)end\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "UTPDSM5N": {"ttr": 2835, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01\\x00\\x1f\\x01\\x01\\x00\\x1f\\x00\\x00\\x00\\x14\\x00\\x00\\x00\\x00\\xe9\\xe9\\xe9\\xe9\\xe9\\xe9\\xe9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-01-01T00:00:00", "modifydate": "2001-01-01T00:00:00", "lines": 20, "newlines": 0, "modlines": 0, "user": "ZZZZZZZ"}, "text": ")attr\n\u00ac type(output) color(blue)    caps(off)\n+ type(text)   color(blue)    caps(off) skip(on)\n)body expand(}})\n+}-} Transmit }-}\n+Command %===>_ZCMD\n+\n+             member %===>_z                                                +<\n+             dataset%===>_z                                                +<\n+\n+                node%===>_z       +<\n+                user%===>_z       +<\n+\n)init\n .zvars = '(ymem ytext ynode yuser)'\n)proc\n ver(&ynode,nb)\n ver(&yuser,nb)\n vput (ynode,yuser) profile\n)end\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "UTPDSM5W": {"ttr": 2837, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01\\x00\\x1f\\x01\\x01\\x00\\x1f\\x00\\x00\\x00\\x1b\\x00\\x00\\x00\\x00\\xe9\\xe9\\xe9\\xe9\\xe9\\xe9\\xe9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-01-01T00:00:00", "modifydate": "2001-01-01T00:00:00", "lines": 27, "newlines": 0, "modlines": 0, "user": "ZZZZZZZ"}, "text": ")attr\n! type(output) color(red)     caps(off) skip(on)\n)Body expand(^^)\n%^-^ Error detection and reporting^-^\n%Command ===>_zcmd\n+\n\n+       procedure:!module  +< Return code:!lrc +<\n+ Rexx error type:!ErrCond+<Source line number!sigl    + and text:\n+\n+ !eline\n+ Diagnostic text (only applicable if it is a Rexx error):\n+\n+ !etext\n+ Last ISPF error message, if any:\n+\n+ !zerrlm\n+ Any descriptive text supplied by Rexx:\n+\n+ !ErrDesc\n+ Any descriptive text provided by the User:\n+\n+ !UserEtxt\n)init\n  .cursor = zcmd\n)proc\n)end\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "UTPDSM5X": {"ttr": 2839, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01\\x00\\x1f\\x01\\x01\\x00\\x1f\\x00\\x00\\x00\\x13\\x00\\x00\\x00\\x00\\xe9\\xe9\\xe9\\xe9\\xe9\\xe9\\xe9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-01-01T00:00:00", "modifydate": "2001-01-01T00:00:00", "lines": 19, "newlines": 0, "modlines": 0, "user": "ZZZZZZZ"}, "text": ")attr\n)body expand(}})\n+}-}% DDF user survey + }-}\n%Command ===>_zcmd\n+\n+ DDF is being evaluated. Please take the time to complete the\n+ following survey. You will be prompted from time to time to\n+ update your views.\n+\n+ If you do not wish to reply at this time, simply use%PF3+in the\n+ following edit session.\n+\n+%Thank you+\n+\n+ Press%enter+to continue\n+\n)INIT\n)proc\n)END\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "UTPDSM5Z": {"ttr": 2841, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01\\x00\\x1f\\x01\\x01\\x00\\x1f\\x00\\x00\\x00\\x19\\x00\\x00\\x00\\x00\\xe9\\xe9\\xe9\\xe9\\xe9\\xe9\\xe9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-01-01T00:00:00", "modifydate": "2001-01-01T00:00:00", "lines": 25, "newlines": 0, "modlines": 0, "user": "ZZZZZZZ"}, "text": ")attr\n! type(output) color(red)     caps(off) skip(on)\n)Body expand(}})\n%}-} DDF error handling }-}\n%Command ===>_zcmd\n+\nPlease print this panel and contact your DDF administrator\n\n+ Return code:!rc  +<\n+ Rexx error type:!ErrCond+<Source line number!sigl    + and text:\n+\n+ !eline\n+ Diagnostic text (only applicable if it is a Rexx error):\n+\n+ !etext\n+ Last ISPF error message, if any:\n+\n+ !zerrlm\n+ Any descriptive text supplied by Rexx:\n+\n+ !ErrDesc\n)init\n  .cursor = zcmd\n)proc\n)end\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "UTPHCMD": {"ttr": 2843, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01\\x00\\x1f\\x01\\x01\\x00\\x1f\\x00\\x00\\x00\\x0f\\x00\\x00\\x00\\x00\\xe9\\xe9\\xe9\\xe9\\xe9\\xe9\\xe9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-01-01T00:00:00", "modifydate": "2001-01-01T00:00:00", "lines": 15, "newlines": 0, "modlines": 0, "user": "ZZZZZZZ"}, "text": ")attr\n_ type(input) caps(on)\n@ type(output) color(blue)\n)body expand(}})\n+DDF%Command summary +-------+&zuser &today       +}-}\n%Command ===>_zcmd                                           %Scroll ===>_amt +\n+Type%S+next to a command for more information\n%C+Command      Action\n)Model\n_z@hcmd        @hstxt\n)init\n .zvars = '(lhcmd)'\n)reinit\n)proc\n)end\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "UTPHCMD1": {"ttr": 2845, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01\\x00\\x1f\\x01\\x01\\x00\\x1f\\x00\\x00\\x00\\x1e\\x00\\x00\\x00\\x00\\xe9\\xe9\\xe9\\xe9\\xe9\\xe9\\xe9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-01-01T00:00:00", "modifydate": "2001-01-01T00:00:00", "lines": 30, "newlines": 0, "modlines": 0, "user": "ZZZZZZZ"}, "text": ")attr\n@ type(output) color(blue) caps(off)\n)body expand(}})\n+DDF%Command detail  +-------+&zuser &today       +}-}\n%Command ===>_zcmd                                           %Scroll ===>_amt +\n\n+Command     :@hcmd\n+typed from  :@hfrom\n+summary     :@hstxt\n\n+full details:\n\n@htxt\n\n\n\n\n\n\n\n\n\n\n\n\n\n)init\n)reinit\n)proc\n)end\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "UTSJOB": {"ttr": 2847, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01\\x00\\x1f\\x01\\x01\\x00\\x1f\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\xe9\\xe9\\xe9\\xe9\\xe9\\xe9\\xe9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-01-01T00:00:00", "modifydate": "2001-01-01T00:00:00", "lines": 4, "newlines": 0, "modlines": 0, "user": "ZZZZZZZ"}, "text": "&UTVJB1\n&UTVJB2\n&UTVJB3\n&UTVJB4\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "UTSTSO": {"ttr": 3073, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01\\x00\\x1f\\x01\\x01\\x00\\x1f\\x00\\x00\\x000\\x00\\x00\\x00\\x00\\xe9\\xe9\\xe9\\xe9\\xe9\\xe9\\xe9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-01-01T00:00:00", "modifydate": "2001-01-01T00:00:00", "lines": 48, "newlines": 0, "modlines": 0, "user": "ZZZZZZZ"}, "text": "//* COPY FROM CENTRAL ISPF TABLES\n//IEBCOPY  EXEC PGM=IEBCOPY\n//SYSPRINT DD SYSOUT=*\n//SYSUT3   DD UNIT=SYSDA,SPACE=(CYL,1)\n//SYSUT4   DD UNIT=SYSDA,SPACE=(CYL,1)\n//PROFSYS  DD DSN=SYS1.SISPTENU,DISP=SHR\n//PROFILE  DD DISP=(,PASS),SPACE=(CYL,(1,0,5)),UNIT=SYSDA\n//SYSIN    DD *\n COPY OUTDD=PROFILE,INDD=PROFSYS\n S M=((ISPSPROF,,R))\n S M=((ISRPROF,,R))\n S M=((ISPPROF,,R))\n S M=((ISPCMDS,,R))\n//* START BATCH TSO\n//* TSO      EXEC PGM=IKJEFT01,DYNAMNBR=99,REGION=8M\n//TSO      EXEC PGM=IKJEFT01,DYNAMNBR=99\n//ISPCTL0  DD  DISP=NEW,UNIT=SYSDA,SPACE=(CYL,(1,1)),\n//             DCB=(LRECL=80,BLKSIZE=800,RECFM=FB)\n//ISPCTL1  DD  DISP=NEW,UNIT=SYSDA,SPACE=(CYL,(1,1)),\n//             DCB=(LRECL=80,BLKSIZE=800,RECFM=FB)\n//ISPCTL2  DD  DISP=NEW,UNIT=SYSDA,SPACE=(CYL,(1,1)),\n//             DCB=(LRECL=80,BLKSIZE=800,RECFM=FB)\n//ISPCTL3  DD  DISP=NEW,UNIT=SYSDA,SPACE=(CYL,(1,1)),\n//             DCB=(LRECL=80,BLKSIZE=800,RECFM=FB)\n//ISPCTL4  DD  DISP=NEW,UNIT=SYSDA,SPACE=(CYL,(1,1)),\n//             DCB=(LRECL=80,BLKSIZE=800,RECFM=FB)\n//ISPWRK1  DD  DISP=NEW,UNIT=SYSDA,SPACE=(CYL,(1,1)),\n//             DCB=(LRECL=256,BLKSIZE=2560,RECFM=FB)\n//ISPWRK2  DD  DISP=NEW,UNIT=SYSDA,SPACE=(CYL,(1,1)),\n//             DCB=(LRECL=256,BLKSIZE=2560,RECFM=FB)\n//ISPWRK3  DD  DISP=NEW,UNIT=SYSDA,SPACE=(CYL,(1,1)),\n//             DCB=(LRECL=256,BLKSIZE=2560,RECFM=FB)\n//ISPWRK4  DD  DISP=NEW,UNIT=SYSDA,SPACE=(CYL,(1,1)),\n//             DCB=(LRECL=256,BLKSIZE=2560,RECFM=FB)\n//ISPLOG   DD  DISP=(,PASS),UNIT=SYSDA,\n//             DCB=(LRECL=125,BLKSIZE=129),\n//             SPACE=(129,(592,563))\n//SYSHELP  DD  DSN=SYS1.HELP,DISP=SHR\n//ISPPROF  DD  DISP=(OLD,DELETE),DSN=*.IEBCOPY.PROFILE\n//SYSPROC  DD  DSN=ZZZZZZZ.A.CLIST,DISP=SHR\n//ISPPLIB  DD  DSN=SYS1.SISPPENU,DISP=SHR\n//ISPMLIB  DD  DSN=SYS1.SISPMENU,DISP=SHR\n//ISPSLIB  DD  DSN=SYS1.SISPSENU,DISP=SHR\n//ISPTLIB  DD  DSN=SYS1.SISPTENU,DISP=SHR\n//SYSTSPRT DD  SYSOUT=*\n//SYSPRINT DD  SYSOUT=*\n//SYSTERM  DD  SYSOUT=*\n//SYSIN    DD  DUMMY\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "UTSTSO01": {"ttr": 3075, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01\\x00\\x1f\\x01\\x01\\x00\\x1f\\x00\\x00\\x00\\x07\\x00\\x00\\x00\\x00\\xe9\\xe9\\xe9\\xe9\\xe9\\xe9\\xe9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-01-01T00:00:00", "modifydate": "2001-01-01T00:00:00", "lines": 7, "newlines": 0, "modlines": 0, "user": "ZZZZZZZ"}, "text": "//SYSTSIN DD *\n ISPSTART CMD(UTCB001 &VTABLE.) +\n NEWAPPL(ISR)\n//DATASETS DD *\n)DOT &VTABLE\n&VTLETTER &VTDSN.\n)ENDDOT\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "UTTEMPL": {"ttr": 3077, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01\\x00\\x1f\\x01\\x01\\x00\\x1f\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\xe9\\xe9\\xe9\\xe9\\xe9\\xe9\\xe9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-01-01T00:00:00", "modifydate": "2001-01-01T00:00:00", "lines": 2, "newlines": 0, "modlines": 0, "user": "ZZZZZZZ"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "UTTHELP": {"ttr": 3079, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01\\x00\\x1f\\x01\\x01\\x00\\x1f\\x00\\x00\\x00w\\x00\\x00\\x00\\x00\\xe9\\xe9\\xe9\\xe9\\xe9\\xe9\\xe9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-01-01T00:00:00", "modifydate": "2001-01-01T00:00:00", "lines": 119, "newlines": 0, "modlines": 0, "user": "ZZZZZZZ"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "ZTEMPLAT": {"ttr": 3082, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01\\x00\\x1f\\x01\\x01\\x00\\x1f\\x00\\x00\\x00\\x0e\\x00\\x00\\x00\\x00\\xe9\\xe9\\xe9\\xe9\\xe9\\xe9\\xe9@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-01-01T00:00:00", "modifydate": "2001-01-01T00:00:00", "lines": 14, "newlines": 0, "modlines": 0, "user": "ZZZZZZZ"}, "text": "DDF user survey: please fill in as appropriate\nyour name:\ntelephone number:\nI approve of DDF because\n------------------------\n\n\n\nI disapprove of DDF because\n---------------------------\n\n\n\nI think DDF should become an officially supported product:  YES/NO\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT594/FILE594.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT594", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}