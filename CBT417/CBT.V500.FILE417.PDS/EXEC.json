{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SLBD", "INMTNODE": "X", "INMTUID": "Y", "INMFTIME": "20201207105150000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 2428108, "INMDSORG": "PO", "INMTYPE": "Data Library", "INMLRECL": 80, "INMBLKSZ": 27920, "INMRECFM": "FB", "INMDIR": 1, "INMDSNAM": "SLBD.RACFADM.EXEC", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 2428108, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 2428108, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"SLBD.RACFADM.EXEC": {"COPYR1": {"type": "PDSE", "DS1DSORG": 512, "DS1BLKL": 27920, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 8, "DVACLASS": 32, "DVAUNIT": 0, "DVAMAXRC": 32760, "DVACYL": 256, "DVATRK": 256, "DVATRKLN": 65535, "DVAOVHD": 0, "num_header_records": 0}, "COPYR2": {"deb": "b'\\x03\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x00\\x00\\x00\\x04\\x00\\x00\\x00'", "extents": ["b'\\x03\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x00\\x00\\x00\\x04\\x00\\x00\\x00'", "b'\\x00\\r\\xa8H\\x00\\x00\\x00\\x00\\x00\\x00\\x00~\\x00\\xff\\x7f\\x00'", "b'\\x00\\r\\xa8H\\x00\\x00\\x00\\x7f\\x00\\x00\\x00\\xfd\\x00\\xff\\x7f\\x00'", "b'\\x00\\r\\xa8H\\x00\\x00\\x00\\xfe\\x00\\x00\\x00\\xff\\x00\\xff\\x02\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$DIR": {"ttr": 893, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01T\\x00H\\x01 \\x01\\x1f\\x01 \\x17/\\x15\\x05\\x00,\\x00\\r\\x00\\x00\\xd9\\xc1\\xc3\\xc6\\xc1\\xc4\\xd4@@@'", "ispf": {"version": "01.84", "flags": 0, "createdate": "2020-01-11T00:00:00", "modifydate": "2020-06-20T15:05:48", "lines": 44, "newlines": 13, "modlines": 0, "user": "RACFADM"}, "text": "*---------------------------------------------------------------------*\n*                       RACFADM - REXX Programs                       *\n*---------------------------------------------------------------------*\n\n  Member      Subject                   Description\n --------  -------------  --------------------------------------------\n $$DIR     Directory      Document members\n $STUB     Invocation     Can place rexx in site's REXX dataset\n OPERMIT   IBM TSO Cmd    Unix Access Control List, like PERMIT\n ORALTER   IBM TSO Cmd    Unix Security Attribute, like ALTER\n ORLIST    IBM TSO Cmd    Unix Dir/File Security, like RLIST\n RACFADM   Software       Dynamically allocate and invoke software\n RACFCLSA  Authorization  Display authorization on profile, menu opt 9\n RACFCLSG  Class          Extract generic class profiles\n RACFCLSR  Class          Display class profiles, menu option 4\n RACFCLSS  Class          Search and display classes\n RACFCMDS  Commands       Execute/save/display TSO RACF commands\n RACFDB    Database       Display RACF database info, menu option 8\n RACFDSL   DSList         Invoke DSLIST on ALTLIB/LIBDEF DSNs, opt D\n RACFDSN   Dataset        Display dataset profiles\n RACFEMAC  Edit Macro     View/edit, turn off highlighting\n RACFENQS  Enqueues       Display enqueues on ALTLIB/LIBDEF dsns, opt E\n RACFGRP   Group          Display group profiles, menu option 2\n RACFGTRE  Group Tree     Execute/display DSMON group tree rpt, opt 6\n RACFHELP  Help           Display TSO HELP on RACF commands\n RACFIBM   IBM's RACF     RACF Menu options: System, RRSF, Certificates\n RACFLOG   Documentation  Display changes/issues/isplog, opt C/I/L\n RACFMVS   Showmvs        Execute/display Showmvs RACF data, menu opt 7\n RACFMSG   Messages       RACF messages, menu option M\n RACFMSGC  Message        Display 'Confirm Request' panel\n RACFMSGS  Message        Display error message\n RACFOMVS  OMVS Commands  Exec RACF OMVS cmds (OPERMIT/ORALTER/ORLIST)\n RACFPRMS  Parameter      Display RACF parameters, menu option 7\n RACFPROF  Profile        Execute line cmd 'P', extract/display profile\n RACFPSWD  Password       Reset userid password (menu opt 5/linecmd PW)\n RACFRPTS  Reports        RACF reports, menu option R\n RACFSETD  Settings       Set default settings (0) when RACFADM invoked\n RACFSETG  Settings       Customize settings, menu option 0\n RACFUSR   User           Display userid profiles, menu option 1\n RACFUSRT  User           Add, delete and change TSO userid\n RACFUSRX  User           Userid cross reference report (line cmd XR)\n\n Notes\n   - Class is 'General Resources'\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$STUB": {"ttr": 895, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\t\\x00\"\\x01 \\x13O\\x01 \\x17_\\t\\x19\\x00\"\\x00\\x0b\\x00\\x00\\xd9\\xc1\\xc3\\xc6\\xc1\\xc4\\xd4@@@'", "ispf": {"version": "01.09", "flags": 0, "createdate": "2020-05-13T00:00:00", "modifydate": "2020-06-23T09:19:22", "lines": 34, "newlines": 11, "modlines": 0, "user": "RACFADM"}, "text": "/*%NOCOMMENT====================* REXX *==============================*/\n/*  PURPOSE:  RACFADM - ALTLIB/LIBDEF datasets and invoke software    */\n/*--------------------------------------------------------------------*/\n/*  NOTES:    1) Copy into a library in the standard                  */\n/*               SYSEXEC (or SYSPROC) allocations for the             */\n/*               intended users.                                      */\n/*                                                                    */\n/*            2) Tailor the HLQ variable for the RACFADM              */\n/*               high-level-qualifier.                                */\n/*--------------------------------------------------------------------*/\n/* FLG  YYMMDD  USERID   DESCRIPTION                                  */\n/* ---  ------  -------  -------------------------------------------- */\n/* @A3  200623  LBD      Fix TBCLOSE err, remove NEWAPPL and PASSLIB  */\n/* @A2  200622  LBD      Added initial option                         */\n/* @A1  200611  LBD      Added skeleton datasets                      */\n/* @A0  200320  LBD      Created REXX                                 */\n/*====================================================================*/\narg opt                                                       /* @A2 */\nhlq = 'radmhlq'               /* <=== Change this variable */\n\nAddress TSO\n  \"Altlib Act App(Exec) Dataset('\"hlq\".exec')\"                /* @A2 */\n\nAddress ISPExec\n  \"Libdef ISPMLIB Dataset ID('\"hlq\".msgs') stack\"             /* @A2 */\n  \"Libdef ISPPLIB Dataset ID('\"hlq\".panels') stack\"           /* @A2 */\n  \"Libdef ISPSLIB Dataset ID('\"hlq\".skels') stack\"            /* @A1 */\n  \"Select Cmd(%RacfADM NA\" opt \")\"                            /* @A3 */\n  \"Libdef ISPMLIB\"\n  \"Libdef ISPPLIB\"\n  \"Libdef ISPSLIB\"                                            /* @A1 */\n\nAddress TSO\n  \"Altlib DeAct App(Exec)\"\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "OPERMIT": {"ttr": 897, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01(\\x00\\x11\\x01 \\x12\\x8f\\x01 \\x18?\\x10$\\x06\\x9f\\x06\\x8f\\x00\\x00\\xd9\\xc1\\xc3\\xc6\\xc1\\xc4\\xd4@@@'", "ispf": {"version": "01.40", "flags": 0, "createdate": "2020-05-07T00:00:00", "modifydate": "2020-07-01T10:24:11", "lines": 1695, "newlines": 1679, "modlines": 0, "user": "RACFADM"}, "text": "/*%NOCOMMENT====================* REXX *==============================*/\n/*     TYPE:  TSO Command                                             */\n/*  PURPOSE:  RACF Unix Access Control List (ACL) Management (PERMIT) */\n/*--------------------------------------------------------------------*/\n/*    NOTES:  Obtained utility and documentation from:                */\n/*            ftp://public.dhe.ibm.com/s390/zos/racf/RacfUnixCommands */\n/*--------------------------------------------------------------------*/\n/* FLG  YYMMDD  USERID   DESCRIPTION                                  */\n/* ---  ------  -------  -------------------------------------------- */\n/* @A2  200701  RACFA    Updated doc, added dataset to OUTFILE()      */\n/* @A1  200605  RACFA    Changed 'Syntax...End-Syntax' comments       */\n/* @A0  200605  RACFA    Obtained REXX from IBM                       */\n/*====================================================================*/\n/* rexx */\n/**********************************************************************\n Licensed Materials - Property of IBM\n 5650-ZOS\n Copyright IBM Corp. 2020\n\n Name:    OPERMIT\n\n Version: 2\n\n Author: Bruce Wells - brwells@us.ibm.com\n\n Purpose: Provides UNIX access control list (acl) management using\n          a syntax consistent with the RACF PERMIT command\n\n Input:   An absolute path name\n\n NOTE!!! This exec is dependent upon the following \"Syntax:\" line and\n         the \"End-Syntax\" line below in order to display the syntax\n         when the exec is invoked without keyword parameters.\n\n         Feel free to add/change examples to show things that are\n         frequently done in your orgnization. But please preserve\n         these surrounding lines.\n\n Beg-Syntax:\n Purpose:  Provides UNIX access control list (acl) management using\n           a syntax consistent with the RACF PERMIT command\n\n Syntax:   OPERMIT absolute-path-name operands\n\n Operands: All keywords are optional\n             absolute-path-name     (positional)\n             ACCess(access-authority) | DELETE\n             ACL FMODEL DMODEL | ALL - type(s) of acl being modified.\n             ---\n             CLASS(FSSEC)\n             DEBUG\n             FROM(absolute-path-name)\n             FTYPE(ACL|FMODEL|DMODEL)\n                   ---\n             ID(name ...)\n             OUTFILE(path-or-dataset-name)\n             RECursive(ALL | CURRENT | FILESYS)\n                             -------\n             RESET\n             VERBOSE\n\n Examples:\n   1) Permit user JOHND to an access ACL\n        OPERMIT /u/brwells/myfile CLASS(FSSEC) ID(JOHND) ACCESS(r-x)\n        or\n        OPERMIT /u/brwells/myfile              ID(JOHND) ACCESS(r-x)\n\n   2) Remove access of group SYSPROGS from an access ACL\n        OPERMIT /u/brwells/myfile ID(SYSPROGS) DELETE\n\n   3) Remove an entire access list\n        OPERMIT /u/brwells/myfile RESET\n        OPERMIT /u/brwells/myfile RESET FMODEL\n        OPERMIT /u/brwells/myfile RESET DMODEL\n\n   4) Merge the access ACL from one path into that of another\n        OPERMIT /u/brwells/myfile FROM(/u/brwells/sourceFile)\n\n   5) Add/change an entry in a file model ACL\n        OPERMIT /u/brwells/myfile ID(JOHND) ACCESS(rw-) FMODEL\n\n End-Syntax\n\n**********************************************************************/\n/*******************************************************************/\n/*                                                                 */\n/* This program contains code made available by IBM Corporation    */\n/* on an AS IS basis. Any one receiving this program is            */\n/* considered to be licensed under IBM copyrights to use the       */\n/* IBM-provided source code in any way he or she deems fit,        */\n/* including copying it, compiling it, modifying it, and           */\n/* redistributing it, with or without modifications, except that   */\n/* it may be neither sold nor incorporated within a product that   */\n/* is sold.  No license under any IBM patents or patent            */\n/* applications is to be implied from this copyright license.      */\n/*                                                                 */\n/* The software is provided \"as-is\", and IBM disclaims all         */\n/* warranties, express or implied, including but not limited to    */\n/* implied warranties of merchantibility or fitness for a          */\n/* particular purpose.  IBM shall not be liable for any direct,    */\n/* indirect, incidental, special or consequential damages arising  */\n/* out of this agreement or the use or operation of the software.  */\n/*                                                                 */\n/* A user of this program should understand that IBM cannot        */\n/* provide technical support for the program and will not be       */\n/* responsible for any consequences of use of the program.         */\n/*                                                                 */\n/*******************************************************************/\nparse arg keywords                        /* Input keywords/values   */\nparse source . . execName .               /* Info about this exec    */\n\n/*********************************************************************/\n/* The following configuration variables affect the operation of     */\n/* this exec.                                                        */\n/*********************************************************************/\n/*********************************************************************/\n/* --------------   Start of Configuration Variables --------------- */\n/*********************************************************************/\n\n/*********************************************************************/\n/* noRun means that the security information is not changed.         */\n/* This mode of operation is useful in verbose mode, so              */\n/* you can see the equivalent shell commands. Also, it allows        */\n/* you to first evaluate the contents of the generated script file   */\n/* and only execute it as a shell script once you are satisfied      */\n/* with the results of the command.                                  */\n/*********************************************************************/\nnoRun = 1\n/*********************************************************************/\n/* verbose results in extra messages being issued during processing. */\n/* - Change to 0 to eliminate these messages by default. You can     */\n/*   still specify the VERBOSE keyword on individual commands to     */\n/*   get the messages.                                               */\n/* - Change to 11 to get these messages for sub-objects when you     */\n/*   specify RECURSIVE. Warning: It could get noisy! There is no     */\n/*   command keyword for this option.                                */\n/*********************************************************************/\nverboseVal = 1\n/*********************************************************************/\n/* outputFile is the name of the file in which the generated         */\n/* output will be written.  By default, it is set to                 */\n/* <exec-name>.script, where exec-name is the name you have saved    */\n/* this exec as (OPERMIT by default).                                */\n/*                                                                   */\n/* You can change this to any path name you want, relative or        */\n/* absolute.                                                         */\n/*                                                                   */\n/* You can also specify a pre-allocated, cataloged data set.  It     */\n/* can be a sequential data set or a PDS member. To specify a data   */\n/* set use the shell convention for a data set, which is to start    */\n/* it with \"//\" and enclose it within single quotes. For example:    */\n/*  outputFile = \"//'HLQ.SEQUENTL.DATASET'\"                          */\n/*   or                                                              */\n/*  outputFile = \"//'HLQ.PDS(MEMBER)'\"                               */\n/*                                                                   */\n/* Warning!: When the output is written to a data set, it cannot     */\n/*           be executed as a shell script. OPERMIT will issue a     */\n/*           message if you are not in noRun mode.                   */\n/*                                                                   */\n/*********************************************************************/\noutputFile = execname\".script\"\n\n/*********************************************************************/\n/* --------------   End of Configuration Variables ----------------- */\n/*********************************************************************/\n\n/*********************************************************************/\n/* Define/initialize command keyword names and values.               */\n/*********************************************************************/\nVERBOSEkwd   = \"VERBOSE\"\nRESETkwd     = \"RESET\"      ; resetVal = 0\nFROMkwd      = \"FROM\"       ; fromVal = ''\nFTYPEkwd     = \"FTYPE\"      ; ftypeVal = ''\nACCESSkwd    = \"ACCESS\"     ; accessVal = ''\nACCabbr      = 3            /* ACC is shortest allowed abbreviation  */\nIDkwd        = \"ID\"         ; idVal = ''\nDELETEkwd    = \"DELETE\"     ; deleteVal = 0\nCLASSkwd     = \"CLASS\"      ; classVal = ''\nALLkwd       = \"ALL\"        ; allVal = 0\nACLkwd       = \"ACL\"        ; aclVal = 0\nFMODELkwd    = \"FMODEL\"     ; fmodelVal = 0\nDMODELkwd    = \"DMODEL\"     ; dmodelVal = 0\nRECURSIVEkwd = \"RECURSIVE\"  ; recursiveVal = ''\nRECabbr      = 3            /* REC is shortest allowed abbreviation  */\nDEBUGkwd     = \"DEBUG\"      ; debugVal = 0\nOUTFILEkwd     = \"OUTFILE\"       ; outfileVal     = ''\nOUTabbr      = 3            /* OUT is shortest allowed abbreviation  */\n\n/*********************************************************************/\n/* -----------------   Start of Mainline     ----------------------- */\n/*********************************************************************/\n\ncall syscalls('ON')  /* Initialize UNIX environment */\naddress syscall\n\noutput. = ''         /* Initialize stem for shell commands */\n\n/*********************************************************************/\n/* Display syntax if no arguments are supplied.                      */\n/*********************************************************************/\nIf Length(keywords) = 0 Then Do\n  Display = \"no\"\n  If sourceline() > 0 Then Do\n    Do i = 1 to sourceline()\n     If Word(sourceline(i),1) = \"Beg-Syntax:\" Then do         /* @A1 */\n       Display = \"yes\"\n       iterate                                                /* @A1 */\n     end                                                      /* @A1 */\n     If Word(sourceline(i),1) = \"End-Syntax\" Then\n       Leave\n     If Display = \"yes\" Then\n       say Substr(sourceline(i),1,72)\n    End\n  End\n  Signal GETOUT\nEnd\n\n/*********************************************************************/\n/* Get positional path name argument.                                */\n/*********************************************************************/\npath = Word(keywords,1)          /* 1st keyword is the path name     */\n\n/*********************************************************************/\n/* Obtain information on passed path name.                           */\n/*********************************************************************/\n\"stat (path) stat.\"\n\n/* Check for success.                                                */\nIf retval = -1 then Do\n  Select /* errno */\n    When errno = ENOENT Then\n      say \"The specified path does not exist.\"\n    When errno = EACCES Then Do\n      Say \"You are not authorized to reach\" path\".\"\n\n      /***************************************************************/\n      /* Now, for extra credit, we will check for search access to   */\n      /* the directory components of the path name, since that is a  */\n      /* common cause of error, and display the first such directory */\n      /* to which the user is not authorized. (There is no sense in  */\n      /* continuing beyond that point because they will all yield a  */\n      /* failure even if search access is present.)                  */\n      /***************************************************************/\n      checkpath = ''    /* The path to check */\n      workpath = path   /* A working copy of the input path */\n      Do Forever\n        idx = Pos('/',workpath)\n        If idx = 0 Then  /* no more slashes means we are finished    */\n          leave\n        checkpath = checkpath || Substr(workpath,1,idx)\n        workpath = Substr(workpath,idx+1) /* Lop off head */\n\n        \"access (checkpath)\" X_OK\n\n        if retval = -1 then do\n          say \"You do not have search access to\" checkpath\n          Leave\n        End\n      End\n    End  /* EACCES */\n    Otherwise Do\n      say \"Error locating target object.\",\n          \" Stat() retval =\" retval \"errno =\" ,\n           errno \"errnojr =\" errnojr\n    End\n  End   /* Select errno*/\n  Signal GETOUT\nEnd /* retval = -1 */\n\n/*********************************************************************/\n/* Remove path from keyword string for subsequent processing.        */\n/* Make a copy, since the act of parsing will destroy the string.    */\n/*********************************************************************/\nkeywords = Subword(keywords,2)  /* Remove path from keyword string   */\nsaveKwds = keywords\n\n/*********************************************************************/\n/* Parse the keywords and values from the keyword string.            */\n/*********************************************************************/\nexecRc = 0\nexecRc = parseKeywords()\nIf execRc /= 0 Then\n  Signal GETOUT\n\n/*********************************************************************/\n/* Check keywords for consistency.                                   */\n/*********************************************************************/\nexecRc = checkKeywords()\nIf execRc /= 0 Then\n  Signal GETOUT\n\n/*********************************************************************/\n/* If OUTFILE was specified, override the value of the outputFile    */\n/* configuration variable.                                           */\n/*********************************************************************/\nIf outfileVal /= '' Then\n  outputFile = outfileVal\n\n/*********************************************************************/\n/* If FROM is specified, make sure path name exists and user has     */\n/* access.                                                           */\n/*********************************************************************/\nIf fromVal /= '' Then Do    /* FROM is specified                     */\n  execRc = validateFrom()   /* Validate and set up FROM object/acl   */\n  Select\n    When(execRc = 0) Then\n      Do                    /* FROM object exists and has acl        */\n      End\n    When(execRc = 4) Then\n      fromVal = ''          /* No acl, pretend FROM not specified    */\n    Otherwise\n      Signal GETOUT         /* Terminating error                     */\n  End /* Select */\nEnd  /* FROM specified */\n\n/*********************************************************************/\n/* For the values specified in ID(x ...), build the following stems: */\n/*   - permName: The RACF user ID or group name in the ID operand    */\n/*   - permType: indicates if the value is a user ID or group        */\n/*   - permID  : the UNIX UID or GID to which the name maps          */\n/*********************************************************************/\npermName.0 = 0\npermType.0 = 0\npermID.0 = 0\nIf idVal /= '' Then Do\n  execRc = buildIdStems()\n  If execRc /= 0 Then\n    Signal GETOUT\n  If debugVal = 1 Then Do\n    say ''\n    say 'ID values: name uid/gid type (1=user, 2=group)'\n    Do i = 1 to permID.0\n      say permName.i permID.i permType.i\n    End\n    say ''\n  End\nEnd\n\n/*********************************************************************/\n/* Build output file header.                                         */\n/*********************************************************************/\nCall buildOutputHeader\ncmdStart = output.0 + 1  /* Save line number of first command        */\n\n/*********************************************************************/\n/* Process the keywords.                                             */\n/*********************************************************************/\nexecRc = ProcessKeywords(path)\nIf execRc /= 0 Then\n  Signal GETOUT\n\n/*********************************************************************/\n/* Process RECURSIVE keyword.                                        */\n/*                                                                   */\n/* This is only valid when the target object is a directory.         */\n/*                                                                   */\n/* We obtain a list of sub-objects. This will contain the target     */\n/* itself, which we have already processed, so we skip the first     */\n/* directory.                                                        */\n/*                                                                   */\n/*********************************************************************/\n@stem = filelist.\nIf recursiveVal /= '' Then Do\n  call readdirproc path,@stem,recursiveVal\n  /* If DEBUG specified, display returned directory/file lists */\n  If debugVal = 1 Then Do\n    say 'Files:' filelist.0\n    Do i = 1 to filelist.0\n      say filelist.i\n    End\n    say ''\n    say 'Directories:' dirlist.0\n    Do i = 1 to dirlist.0\n      say dirlist.i\n    End\n  End\n  /*******************************************************************/\n  /* Process directories.                                            */\n  /*******************************************************************/\n  Do objs = 2 to dirlist.0\n    execRc = processKeywords(dirlist.objs)\n    If execRc /= 0 Then\n      Signal GETOUT\n  End\n  /*******************************************************************/\n  /* Nullify FMODEL and DMODEL, since they do not apply to files.    */\n  /*******************************************************************/\n  If ACLval = 1 Then Do\n    fmodelVal = 0 ; dmodelVal = 0\n  End\n\n  /*******************************************************************/\n  /* Process files if ACL keyword is specified or defaulted.         */\n  /*******************************************************************/\n  If ACLval = 1 Then Do\n    Do objs = 1 to filelist.0\n      execRc = processKeywords(filelist.objs)\n      If execRc /= 0 Then\n        Signal GETOUT\n    End\n  End\nEnd\n\nGETOUT:\n\n/*********************************************************************/\n/* Display list of shell commands that this command might            */\n/* have corresponded to, if we have any commands.                    */\n/*********************************************************************/\nIf verboseVal > 0 Then\n  If output.0 >= cmdStart Then Do\n    say ' '\n    say \"This command would result in the following\",\n        \"UNIX shell command(s):\"\n    Do cmds = cmdStart to output.0 /* Skip rexx header */\n      say Substr(output.cmds,2,Length(output.cmds)-2)\n    End\n  End\n  Else\n    if (display <> 'yes') then                                /* @A1 */\n    say 'The specified command resulted in no shell commands being',\n        'generated.'\n\n/*********************************************************************/\n/* Write the script stem to the output script file, if we have any   */\n/* commands.                                                         */\n/*********************************************************************/\nIf output.0 >= cmdStart Then\n  scriptOK = writeOutputFile()\n\n/*********************************************************************/\n/* Execute list of shell commands that this OPERMIT command          */\n/* generated, if we have any commands.                               */\n/*********************************************************************/\nIf noRun = 0 & scriptOK = 1 Then Do\n  If Substr(outputFile,1,2) /= \"//\" Then Do /* Script in UNIX file   */\n\n    call bpxwunix outputFile,,stdout.,stderr.\n\n    If retval >= 0 Then Do  /* bpxwunix worked. setfacl might have.  */\n      If stderr.0 > 0 Then Do\n        Do i = 1 to stderr.0\n          say stderr.i\n        End\n      End\n    End\n    Else Do\n      say \"Bpxwunix error\" retval errno errnojr \"when attempting\",\n          \"to run the\" outputFile \"file.\"\n    End\n  End                                       /* Script in UNIX file   */\n  Else Do                                   /* Script in data set    */\n    say 'Unable to execute shell script because you have saved it',\n        'into a data set.  See the value of the outputFile',\n        'configuraton variable.'\n    say 'No changes were made.'\n  End\nEnd   /* Not in noRun mode          */\n\nExit\n\n/*********************************************************************/\n/* -----------------     End of Mainline     ----------------------- */\n/*********************************************************************/\n\n\nprocessKeywords:\n/*********************************************************************/\n/* procedure: processKeywords                                        */\n/*                                                                   */\n/* input:  - The path name to modify                                 */\n/*                                                                   */\n/* output: - Returns a return code                                   */\n/*                                                                   */\n/* Notes:  - This is essentially just a continuation of mainline     */\n/*           processing, put into a subroutine so that it can be     */\n/*           called iteratively for sub-objects by the RECURSIVE     */\n/*           keyword.                                                */\n/*         - There is a conscious ordering in which we process       */\n/*           the keywords:                                           */\n/*           1) RESET - This cleans the slate for subsequent         */\n/*              keywords                                             */\n/*           2) FROM  - This merges acl entries from the source      */\n/*              acl to the target acl.                               */\n/*           3) ID/ACCESS/DELETE - this modifies whatever acl        */\n/*              entries may already exist or have been copied.       */\n/*         - We use some UNIX syscall commands to retrieve acls      */\n/*           and to manipulate acls in memory, but we always         */\n/*           generate setfacl commands rather than update acls       */\n/*           using the aclset syscall command. This is because       */\n/*           aclset always replaces an existing acl. This means      */\n/*           that the existing contents of an acl must be read,      */\n/*           altered, and re-written. The resulting audit trail      */\n/*           is brutal.  For example, if you have 100 existing       */\n/*           acl entries, and you modify only one, you would see     */\n/*           a \"DELFACL\" SMF record, followed by 100 \"SETFACL\"       */\n/*           SMF records, all of which seem to be for new permits.   */\n/*           In contrast, by issuing a setfacl command, you get a    */\n/*           single \"SETFACL\" SMF record which contains the old,     */\n/*           as well as the new, permissions.  This approach also    */\n/*           eliminates timing/error windows which could leave       */\n/*           your acl worse off than it started.                     */\n/*                                                                   */\n/*********************************************************************/\nparse arg rpath\n\npkRc = 0  /* Return value */\n\n/*********************************************************************/\n/* Obtain information on passed path name.                           */\n/*                                                                   */\n/* Note we never expect the possibility of 'not-found', because      */\n/* the mainline checked the path specified, and the RECURSIVE        */\n/* keyword resulted in us already locating a list of sub-objects.    */\n/* (Though there is, of course, a time-of-check to time-of-use       */\n/* window.)                                                          */\n/*                                                                   */\n/*********************************************************************/\n\"stat (rpath) rstat.\"\nIf retval < 0 Then Do\n  If errno = ENOENT Then\n    say \"Target object does not exist:\" rpath\n  Else If errno = EACCES Then\n    say 'Not authorized to read' rpath'.'\n  Else\n    say \"Error locating\" rpath\". Retval =\" retval \"errno =\" ,\n         errno \"errnojr =\" errnojr\n  pkRc = 8\n  Signal kwdExit\nEnd\n\n/*********************************************************************/\n/* Make a value of the path name that can be used in shell           */\n/* commands.  For example, if the path contains a blank, the         */\n/* entire path must be enclosed in quotes.                           */\n/*********************************************************************/\ncpath = munge(rpath)          /* cpath is for use in commands        */\n\n/*********************************************************************/\n/* Pre-process the ID, ACCESS, and DELETE keywords by setting up     */\n/* parts of an acl entry into which an UID/GID can be set below      */\n/* for each mappable ID value.                                       */\n/*********************************************************************/\n/*********************************************************************/\n/* Iterate thrice: once for each acl type.                           */\n/*********************************************************************/\nDo j = 1 to 3                       /* Process each acl type         */\n  Select\n    When j = 1 Then Do\n      If aclVal = 1 Then Do         /* Access acl requested?         */\n        aclType = ACL_TYPE_ACCESS   /* Process access acl            */\n        aclStatType = ST_ACCESSACL\n        aTypeMsg = \"access\"\n        aTypeCmd = \"a\"              /* Switch value for shell cmd    */\n        aTypeEnt = \"\"               /* No type for setfacl entry     */\n      End\n      Else\n        Iterate                     /* No, skip this iteration       */\n    End\n    When j = 2 Then Do\n      If fmodelVal = 1 Then Do      /* File model acl requested?     */\n        aclType = ACL_TYPE_FILEDEFAULT /* Process file model acl     */\n        aclStatType = ST_FMODELACL\n        aTypeMsg = \"file model\"\n        aTypeCmd = \"f\"              /* Switch value for shell cmd    */\n        aTypeEnt = \"fdefault:\"      /* fmod type for setfacl entry   */\n      End\n      Else\n        Iterate                     /* No, skip this iteration       */\n    End\n    When j = 3 Then Do\n      If dmodelVal = 1 Then Do      /* Directory model acl requested?*/\n        aclType = ACL_TYPE_DIRDEFAULT    /* Process dir model acl    */\n        aclStatType = ST_DMODELACL\n        aTypeMsg = \"directory model\"\n        aTypeCmd = \"d\"              /* Switch value for shell cmd    */\n        aTypeEnt = \"default:\"       /* dmod type for setfacl entry   */\n      End\n      Else\n        Iterate                     /* No, skip this iteration       */\n    End\n    Otherwise\n  End /* Select */\n\n  /*******************************************************************/\n  /* Process RESET keyword.                                          */\n  /*******************************************************************/\n  If resetVal = 1 Then Do      /* RESET specified */\n\n    /***********************************************/\n    /* ++ Add shell command to script stem.        */\n    /***********************************************/\n    tmp = output.0 + 1\n    output.tmp = \"'setfacl -D\"aTypeCmd cpath\"'\"\n    output.0 = tmp\n  End         /* RESET specified   */\n\n  /*******************************************************************/\n  /* Process FROM keyword.                                           */\n  /*******************************************************************/\n  If fromVal /= '' Then Do\n    /*****************************************************************/\n    /* Merge the FROM acl into the target object's access acl if     */\n    /* requested.                                                    */\n    /*****************************************************************/\n    'aclinit tacl'                   /* init var to hold target acl  */\n    'aclget tacl (rpath)' (aclType)  /* get the target acl           */\n\n    'aclinit iacl'                   /* init var to hold temp acl    */\n    iNames. = ''                     /* Stem of mapped iacl names    */\n    iNames.0 = 0\n    entryNum = mergeAcls()           /* Go sort them out             */\n\n    If entryNum > 0 Then Do          /* If any entries to copy       */\n      Do ents=1 by 1                 /* For each temp acl entry      */\n        'aclgetentry iacl tempEnt.' ents\n        If rc<0 | retval=-1 Then Leave  /* error, or no more entries */\n\n        /***********************************************/\n        /* ++ Add shell command to script stem.        */\n        /***********************************************/\n        If tempEnt.ACL_ENTRY_TYPE = ACL_ENTRY_USER Then\n          sfType = \"user\"\n        Else\n          sfType = \"group\"\n\n        If tempEnt.ACL_READ = 1 Then\n          entPerms = \"r\"\n        Else\n          entPerms = \"-\"\n        If tempEnt.ACL_WRITE = 1 Then\n          entPerms = entPerms\"w\"\n        Else\n          entPerms = entPerms\"-\"\n        If tempEnt.ACL_EXECUTE = 1 Then\n          entPerms = entPerms\"x\"\n        Else\n          entPerms = entPerms\"-\"\n\n        aEntry = aTypeEnt||sfType||\":\"iNames.ents\":\"entPerms\n        tmp = output.0 + 1\n        output.tmp = \"'setfacl -m\" aEntry cpath\"'\"\n        output.0 = tmp\n      End /* Loop on entries to copy */\n    End /* entries to copy */\n    Else Do\n      If path = rpath & verboseVal = 1 | verboseVal = 11 Then\n        say \"No acl entries were copied from\" fromVal 'to the',\n            aTypeMsg 'acl of' rpath\".\"\n    End\n    'aclfree tacl' /* must free source acl buffer */\n    'aclfree iacl' /* must free intermediate acl buffer */\n  End                    /* Process FROM keyword          */\n\n  /*******************************************************************/\n  /* Process ID, ACCESS, and DELETE keywords                         */\n  /*******************************************************************/\n  If permName.0 > 0 Then Do /* Mappable ID values were specified     */\n    /*****************************************************************/\n    /* Loop through each value in our perm stem and build a          */\n    /* separate setfacl command for each one.                        */\n    /*****************************************************************/\n    Do p = 1 to permName.0    /* For each mappable ID value          */\n      /***********************************************/\n      /* ++ Add shell command to script stem.        */\n      /***********************************************/\n      If permType.p = ACL_ENTRY_USER Then\n        sfType = \"user\"\n      Else\n        sfType = \"group\"\n      entPerms = Translate(accessVal,\"rwx\",\"RWX\")\n      aEntry = aTypeEnt||sfType||\":\"permName.p\n      tmp = output.0 + 1\n\n      /***************************************************************/\n      /* If DELETE is specified, we use '-x' and don't append the    */\n      /* permissions qualifier.                                      */\n      /***************************************************************/\n      If deleteVal = 1 Then\n        output.tmp = \"'setfacl -x\" aEntry cpath\"'\"\n      /***************************************************************/\n      /* If DELETE is not specified, we use '-m' and append the      */\n      /* permissions qualifier.                                      */\n      /***************************************************************/\n      Else\n        output.tmp = \"'setfacl -m\" aEntry\":\"entPerms cpath\"'\"\n\n      output.0 = tmp\n    End                       /* For each ID value                   */\n  End                         /* Process permit                      */\nEnd                           /* Process each acl type loop          */\n\nkwdExit:\nReturn pkRc                     /* processKeywords                   */\n\n/* ----------------------------------------------------------------- */\n\nparseKeywords:\n/*********************************************************************/\n/* Examine input to identify keywords and values. We process the     */\n/* keyword string as a set of words, taking into account that        */\n/* ID(x ...) can contains a list of blank-separated values.          */\n/*********************************************************************/\nparseRc = 0\nDo i = 1 to Words(keywords) Until Length(keywords)=0 /* Parse kwds   */\n\n  nextWord = Word(keywords,1)    /* Get next word                    */\n\n  /*******************************************************************/\n  /* Isolate the next keyword and its value.                         */\n  /*******************************************************************/\n  openParen = Pos(\"(\",nextWord)  /* Expect \"(\" to be part of word    */\n  closeParen = Pos(\")\",keywords) /* But must look for \")\" in the\n                                     entire cmd remainder            */\n\n  /*******************************************************************/\n  /* If there is no open paren in the word, then this is a keyword   */\n  /* without a value.                                                */\n  /*******************************************************************/\n  If openParen = 0 Then\n    Do\n      nextKwd = nextWord\n      nextVal = ''\n      endKwd = Length(nextWord)+1\n    End\n  /*******************************************************************/\n  /* If there is an open paren in the word, then this is a keyword   */\n  /* with a value.                                                   */\n  /*                                                                 */\n  /* In the case of ID, the value may be a blank-separated list      */\n  /* of users and groups, so we must take care to identify the       */\n  /* end of the keyword by looking for the closing paren.            */\n  /*******************************************************************/\n  Else\n    Do\n      nextKwd = Substr(nextWord,1,openParen-1)\n      valLength = closeParen - openParen - 1\n      nextVal = Strip(Substr(keywords,openParen+1,valLength),Both,\" \")\n      endKwd = Pos(\")\",keywords)+1\n    End\n  Upper nextKwd\n\n  /*******************************************************************/\n  /* Uncomment the following to help debug command parsing.          */\n  /*******************************************************************/\n  /*\n  say \"Command image remainder is\" keywords\n  say \"Keyword is\" nextKwd\n  say \"Value is\" nextVal \"of length\" Length(nextVal)\n  /* The following will be not quite accurate for \"))\" keywords.     */\n  say \"First position after current keyword/value is\" endKwd\n  say ''\n  */\n\n  /*******************************************************************/\n  /* Set the value for each specified keyword.                       */\n  /*******************************************************************/\n  Select                        /* Identify keyword                  */\n    /*****************************************************************/\n    /* For the OUTFILE keyword, some additional processing is        */\n    /* required to support a PDS member, due to the additional       */\n    /* parentheses. We must look for an additional closing paren     */\n    /* and redo the keyword-with-value code above to isolate the     */\n    /* value.                                                        */\n    /*                                                               */\n    /* Note that, when OUTFILE is not specified, we make no effort   */\n    /* to validate the value of the outputFile configuration value.  */\n    /* We just let it rip and let the file I/O fail at the end.      */\n    /* But this parsing forces our hand a bit. We assume the value   */\n    /* is specified correctly, but do just enough checking to avoid  */\n    /* a REXX error. If something is unexpected, we let the value    */\n    /* stand as parsed above and send it downstream for failure.     */\n    /*****************************************************************/\n    When Abbrev(OUTFILEkwd,nextKwd,OUTabbr) = 1 Then\n      Do\n        outfileVal = nextVal                /* Save output var       */\n\n        If Substr(outfileVal,1,2) = \"//\" &, /* If data set path      */\n           Pos(\"(\",nextval) > 0 Then Do     /* contains open paren   */\n\n          /* Find next closing paren, which should be true close     */\n          closeParen = closeParen +,\n                       Pos(\")\",Substr(keywords,closeParen+1))\n\n          /* Redo parse code to get correct parsing values           */\n          If closeParen > 0 Then Do         /* If \")\" found          */\n            valLength = closeParen - openParen - 1\n            nextVal = Strip(,\n                       Substr(keywords,openParen+1,valLength),Both,\" \")\n            endKwd = closeParen + 1\n            outfileVal = nextVal            /* Reload output var     */\n          End\n        End\n      End\n    /*****************************************************************/\n    /* If the RECURSIVE keyword is specified without a value, then   */\n    /* we use the default of CURRENT.                                */\n    /*****************************************************************/\n    When Abbrev(RECURSIVEkwd,nextKwd,RECabbr) = 1 Then\n      Do\n        If stat.ST_TYPE /= S_ISDIR Then Do\n          say 'RECURSIVE can only be specified for a directory.'\n          parseRc = 4\n        End\n        Else Do\n          If nextVal = '' Then Do\n            recursiveVal = 'CURRENT'\n          End\n          Else Do\n            Upper nextVal\n            recursiveVal = nextVal\n            If recursiveVal /= 'CURRENT' &,\n               recursiveVal /= 'FILESYS' &,\n               recursiveVal /= 'ALL' Then Do\n              say 'Invalid value specified for RECURSIVE keyword.'\n              say 'Use one of CURRENT, FILESYS, or ALL, or omit',\n                  'parentheses and value for the default of CURRENT'\n              parseRc = 4\n            End\n          End\n        End\n      End\n    When nextKwd = DEBUGkwd Then\n      Do\n        debugVal = 1\n      End\n    When nextKwd = VERBOSEkwd Then\n      Do\n        verboseVal = 1\n      End\n    When nextKwd = IDkwd Then\n      Do\n        Upper nextVal\n        idVal = nextVal\n      End\n    When Abbrev(ACCESSkwd,nextKwd,ACCabbr) = 1 Then\n      Do\n        Upper nextVal\n        accessVal = nextVal\n        /*************************************************************/\n        /* Make sure the value is valid.           */\n        /*************************************************************/\n        If Substr(accessVal,1,1) /= \"R\" &,\n           Substr(accessVal,1,1) /= \"-\"        |,\n           Substr(accessVal,2,1) /= \"W\" &,\n           Substr(accessVal,2,1) /= \"-\"        |,\n           Substr(accessVal,3,1) /= \"X\" &,\n           Substr(accessVal,3,1) /= \"-\" Then\n          Do\n            say 'Incorrect ACCESS value:' accessVal\n            parseRc = 4\n          End\n      End\n    /*****************************************************************/\n    /* The CLASS keyword is optional, but if specified, must have    */\n    /* a value of \"FSSEC\".  CLASS is tolerated so that OPERMIT       */\n    /* syntax can match PERMIT syntax as closely as possible.        */\n    /*****************************************************************/\n    When nextKwd = CLASSkwd Then   /* CLASS is pretty much a no-op   */\n      Do\n        Upper nextVal\n        classVal = nextVal\n        If classVal /= \"FSSEC\" Then Do\n          say \"Incorrect CLASS value:\" classVal\n          parseRc = 4\n        End\n      End\n    When nextKwd = FROMkwd Then\n      Do\n        fromVal = nextVal\n      End\n    When nextKwd = FTYPEkwd Then\n      Do\n        Upper nextVal\n        ftypeVal = nextVal\n        Select\n          When ftypeVal = 'ACL' Then Do\n            ftypeMsg = 'access'\n            ftypeCode = ACL_TYPE_ACCESS\n          End\n          When ftypeVal = 'FMODEL' Then Do\n            ftypeMsg = 'file model'\n            ftypeCode = ACL_TYPE_FILEDEFAULT\n          End\n          When ftypeVal = 'DMODEL' Then Do\n            ftypeMsg = 'directory model'\n            ftypeCode = ACL_TYPE_DIRDEFAULT\n          End\n          Otherwise Do\n            say 'Invalid value specified for FTYPE keyword.'\n            say 'Use one of ACL, DMODEL, or FMODEL, or omit',\n                'the keyword for the default of ACL.'\n            parseRc = 4\n          End\n        End /* Select */\n      End\n    When nextKwd = RESETkwd Then\n      Do\n        resetVal = 1\n      End\n    When nextKwd = DELETEkwd Then\n      Do\n        deleteVal = 1\n      End\n    When nextKwd = ALLkwd Then\n      Do\n        allVal = 1\n        If stat.ST_TYPE /= S_ISDIR Then Do\n          say \"ALL can only be specified for a directory.\"\n        End\n      End\n    When nextKwd = ACLkwd Then\n      Do\n        aclVal = 1\n      End\n    When nextKwd = FMODELkwd Then\n      Do\n        fmodelVal = 1\n        If stat.ST_TYPE /= S_ISDIR Then Do\n          say \"FMODEL can only be specified for a directory.\"\n          parseRc = 4\n        End\n      End\n    When nextKwd = DMODELkwd Then\n      Do\n        dmodelVal = 1\n        If stat.ST_TYPE /= S_ISDIR Then Do\n          say \"DMODEL can only be specified for a directory.\"\n          parseRc = 4\n        End\n      End\n    Otherwise\n      If Length(nextKwd) /= 0 Then Do\n        say \"Invalid keyword:\" nextKwd\n        parseRc = 4\n      End\n  End                           /* Identify keyword                  */\n\n  /*******************************************************************/\n  /* Make sure the next keyword is blank-separated from current.     */\n  /*******************************************************************/\n  If parseRc= 0 Then\n    If Substr(keywords,endKwd,1) <> \" \" Then Do\n      say \"Missing blank after\" nextKwd \"keyword.\"\n      Exit 4\n    End\n\n  /*******************************************************************/\n  /* Remove this keyword from the input string, for the next         */\n  /* iteration.                                                      */\n  /*******************************************************************/\n  keywords = Substr(keywords,endKwd)     /* Remove processed keyword */\n  keywords = Strip(keywords,Leading,\" \")\n\nEnd                             /* Parse keywords loop               */\n\nReturn parseRc                  /* parseKeywords                     */\n\n/* ----------------------------------------------------------------- */\n\ncheckKeywords:\n/*********************************************************************/\n/* Check for consistency of keywords:                                */\n/*  - Issue message and set return code when mutually exclusive      */\n/*    keywords are specified.                                        */\n/*  - Set defaults as appropriate.                                   */\n/*********************************************************************/\n\nexecRc = 0\n\n/*********************************************************************/\n/* If ALL was specified, none of ACL, FMODEL, or DMODEL can be       */\n/* specified.                                                        */\n/*********************************************************************/\nIf allVal = 1 Then Do\n  If aclVal = 1 | fmodelVal = 1 | dmodelVal = 1 Then Do\n    say 'None of ACL, DMODEL, or FMODEL can be specified with ALL.'\n    execRc = 4\n  End\n  Else Do         /* Set flags as if each ACL type was specified     */\n    aclVal = 1\n    dmodelVal = 1\n    fmodelVal = 1\n  End\nEnd\n\n/*********************************************************************/\n/* If none of ACL, FMODEL, or DMODEL were specified, default to ACL  */\n/* for subsequent processing.                                        */\n/*********************************************************************/\nIf aclVal = 0 & fmodelVal = 0 & dmodelVal = 0 Then Do\n  aclVal = 1\nEnd\n\n/*********************************************************************/\n/* When ID is specified, one of ACCESS and DELETE must also be,      */\n/* but not both.                                                     */\n/*********************************************************************/\nIf idVal /= '' Then Do\n  If accessVal = '' & deleteVal = 0 Then Do\n    say 'ID specified without ACCESS or DELETE.',\n        'Permissions are unchanged.'\n    execRc = 4\n  End\n\n  If accessVal /= '' & deleteVal = 1 Then Do\n    say 'ACCESS and DELETE cannot both be specified.',\n        'Permissions are unchanged.'\n    execRc = 4\n    Signal CHECKOUT\n  End\nEnd\n\n/*********************************************************************/\n/* If RESET and DELETE are both specified, RESET is ignored.         */\n/*********************************************************************/\nIf resetVal = 1 & deleteVal = 1 Then Do\n  say 'RESET is ignored because DELETE is also specified.'\n  resetVal = 0\nEnd\n\n/*********************************************************************/\n/* If FTYPE is specified in the absence of FROM, FTYPE is ignored.   */\n/*********************************************************************/\nIf ftypeVal /= '' & fromVal = '' Then Do\n  say 'FTYPE is ignored because FROM is not also specified.'\n  ftypeVal = 0\nEnd\n\n/*********************************************************************/\n/* If FTYPE is not specified, set defaults for ACL.                  */\n/*********************************************************************/\nIf ftypeVal = '' Then Do\n  ftypeVal = 'ACL'\n  ftypeMsg = 'access'\n  ftypeCode = ACL_TYPE_ACCESS\nEnd\n\nCHECKOUT:\nReturn execRc    /* checkKeywords */\n\n/* ----------------------------------------------------------------- */\n\nmergeAcls:\n/*********************************************************************/\n/* Merge entries from a source acl into a target acl.  If an acl     */\n/* entry for the same user or group exist in both the source and     */\n/* target acl, the target entry is left unchanged.                   */\n/*                                                                   */\n/* Input:                                                            */\n/*      - sacl: Global stem variable containing the source acl       */\n/*      - tacl: Global stem variable containing the target acl       */\n/*      - iacl: Global stem variable containing the intermediate     */\n/*        (working) acl                                              */\n/*                                                                   */\n/* Output:                                                           */\n/*      - iacl contains only those entries in the source acl         */\n/*        whose id does not already exist in the target acl          */\n/*      - iNames stem contains mapped user IDs/group names           */\n/*        corresponding to iacl.                                     */\n/*                                                                   */\n/* Returns:                                                          */\n/*      - number of entries in iacl                                  */\n/*                                                                   */\n/* Notes:                                                            */\n/*      - This routine works on in-memory acl stem variables. It     */\n/*        does not read or write any actual acl contents from/to     */\n/*        files.                                                     */\n/*                                                                   */\n/*********************************************************************/\nchanges = 0                      /* Number of entries to apply       */\n/*********************************************************************/\n/* Loop through the source acl processing each entry in turn.        */\n/*********************************************************************/\nDo x=1 by 1                      /* For each source (FROM) acl entry */\n  'aclgetentry sacl fromEnt.' x\n  If rc<0 | retval=-1 Then Leave /* error, or no more entries */\n\n  /*******************************************************************/\n  /* Map the source entry's UID/GID to a user ID/group. If the xID   */\n  /* is unmappable, we will issue a message and exclude it           */\n  /* from the output stem. This probably indicates that a UNIX       */\n  /* user or group was deleted from RACF, and orphan acl entries     */\n  /* were not cleaned up.    There is no sense in propagating        */\n  /* this condition.                                                 */\n  /*******************************************************************/\n  If fromEnt.acl_entry_type = ACL_ENTRY_USER Then Do\n    msgType = \"user\"\n    msgIdType = \"UID\"\n    'getpwuid' fromEnt.acl_id 'pwnam.'\n    If retval > 0 Then             /* Mapping successful             */\n      msgName = Strip(pwnam.PW_NAME,Both,\" \")\n    Else\n      msgName = \"*unmappable*\"\n  End\n  Else Do\n    msgType = \"group\"\n    msgIdType = \"GID\"\n    'getgrgid' fromEnt.acl_id 'grnam.'\n    If retval > 0 Then             /* Mapping successful             */\n      msgName = Strip(grnam.GR_NAME,Both,\" \")\n    Else\n      msgName = \"*unmappable*\"\n  End\n  /*******************************************************************/\n  /* If the xID is unmappable, we will issue a message and           */\n  /* exclude it from the output stem.    This probably               */\n  /* indicates that a user or group was deleted from RACF,           */\n  /* and orphan acl entries were not cleaned up.    There is no      */\n  /* sense in propagating this condition.                            */\n  /*******************************************************************/\n  If msgName = \"*unmappable*\" Then Do\n    say 'The UNIX' msgIdType 'value of' fromEnt.acl_id 'does not',\n        'map to a RACF' msgType'. The entry is not copied to the',\n        aTypeMsg 'acl of' rpath\".\"\n    Iterate /* Process next source acl entry */\n  End\n\n  /*******************************************************************/\n  /* Loop through each target acl entry looking for a match on the   */\n  /* source. If found, issue a message.                              */\n  /*******************************************************************/\n  Do y = 1 By 1          /* For each target acl entry                */\n    noCopy = 0           /* 0 = source acl entry should be copied    */\n    'aclgetentry tacl toEnt.' y\n    If rc<0 | retval=-1 Then Do    /* error, or no more entries */\n      Leave\n    End\n\n    /*****************************************************************/\n    /* Like the RACF PERMIT command, we issue a message when         */\n    /* declining to copy a matching acl entry, but only if           */\n    /* VERBOSE is specified.                                         */\n    /*****************************************************************/\n    If fromEnt.acl_entry_type = toEnt.acl_entry_type &,\n       fromEnt.acl_id = toEnt.acl_id Then Do\n      If verboseVal > 0 Then Do\n        say 'The UNIX' msgIdType 'value of' fromEnt.acl_id            ,\n            'mapped to RACF' msgType msgName 'already exists in the'  ,\n            aTypeMsg 'acl of' rpath\".\"                                ,\n            'Its access remains unchanged.'\n      End\n      noCopy = 1\n      Leave\n    End                            /* Entry already exists           */\n  End                           /* For each target acl entry         */\n\n  /*******************************************************************/\n  /* If the xID from the source acl entry is mappable, and does      */\n  /* not already have a target acl entry, then add the source acl    */\n  /* entry to our intermediate acl.                                  */\n  /*******************************************************************/\n  If noCopy = 0 Then Do         /* Must copy source acl entry        */\n    'aclupdateentry iacl fromEnt.'\n    changes = changes + 1       /* Increment number of entries       */\n    iNames.changes = msgName    /* Update corresponding names stem   */\n    iNames.0 = changes          /* Save updated count in iNames stem */\n  End                           /* Must copy source acl entry        */\nEnd                             /* For each source (FROM) acl entry  */\nReturn changes                  /* Return number of entries to copy  */\n\n/* ----------------------------------------------------------------- */\n\nbuildIdStems:\n/*********************************************************************/\n/* Build list(s) of information about the values specified on the    */\n/* ID keyword.                                                       */\n/*                                                                   */\n/* Input:                                                            */\n/*      - idVal: Global variable containing the value(s)             */\n/*        specified by the user on the ID keyword.                   */\n/*                                                                   */\n/* Output:                                                           */\n/*      - permName : stem of the actual values specified             */\n/*      - permType : stem of the value types (user or group)         */\n/*      - permID   : stem of the UID or GID value that permName      */\n/*                   maps to                                         */\n/* Notes:                                                            */\n/*      - Only UNIX users and groups are returned. If an ID value    */\n/*        does not have an OMVS segment with a UID/GID, a message    */\n/*        is issued and it is omitted from the output stems.         */\n/*                                                                   */\n/*********************************************************************/\n    /*****************************************************************/\n    /* Loop through each value specified for ID and map the names    */\n    /* to UIDs/GIDs.                                                 */\n    /*****************************************************************/\n    Do i = 1 to Words(idVal)  /* For each ID value                   */\n\n      /***************************************************************/\n      /* Determine if the ID value is a user or a group, and         */\n      /* indicate that in the permType stem.  Place the mapped       */\n      /* UID/GID into the corresponding position of the permID stem. */\n      /* An unmappable name results in a message and it is simply    */\n      /* omitted from the stems.                                     */\n      /***************************************************************/\n      'getpwnam' Word(idVal,i) 'pw.'\n      If retval > 0 Then Do   /* Success */\n        permName.i = Word(idVal,i)\n        permType.i = ACL_ENTRY_USER\n        permID.i   = pw.PW_UID\n      End\n      Else Do\n        'getgrnam' Word(idVal,i) 'gr.'\n        If retval > 0 Then Do   /* Success */\n          permName.i = Word(idVal,i)\n          permType.i = ACL_ENTRY_GROUP\n          permID.i   = gr.GR_GID\n        End\n        Else Do\n          say 'Unable to map' Word(idVal,i) 'into a UID or GID.',\n              'The name is ignored.'\n          Iterate           /* Continue processing ID values         */\n        End\n      End\n      /***************************************************************/\n      /* Increment the number of values in each stem.                */\n      /***************************************************************/\n      permName.0 = permName.0 + 1\n      permType.0 = permType.0 + 1\n      permID.0   = permID.0 + 1\n    End\n\n    /***************************************************************/\n    /* If no values were mappable, set a failing return code.      */\n    /***************************************************************/\n    If permName.0 = 0 Then Do\n      say 'None of the specified ID values could be mapped',\n          'to a UNIX identity. Permissions are unchanged.'\n      execRc = 4\n    End\n  Return execRc  /* buildIdStems */\n\n/* ----------------------------------------------------------------- */\n\nvalidateFrom:\n/*********************************************************************/\n/* procedure: validateFrom                                           */\n/*                                                                   */\n/* input:  The following global variables set by processKeywords     */\n/*         - fromVal                                                 */\n/*         - ftypeVal                                                */\n/*         - ftypeMsg                                                */\n/*         - ftypeCode                                               */\n/*                                                                   */\n/* output: - On success, the sacl variable contains the acl          */\n/*           retrieved from the FROM path name. This acl must be     */\n/*           freed before OPERMIT terminates.                        */\n/*         - A return code:                                          */\n/*           0: success                                              */\n/*           4: FROM object does not contain acl type requested      */\n/*           8: terminating error                                    */\n/*                                                                   */\n/* Notes:  - The inability to locate the target object, or the       */\n/*           absence of the desired acl type on that object,         */\n/*           are considered terminating errors.                      */\n/*                                                                   */\n/*********************************************************************/\n  vfRc = 0\n\n  /*******************************************************************/\n  /* Issue stat() against source (FROM) object so we have            */\n  /* information about it.                                           */\n  /*******************************************************************/\n  \"stat (fromVal) fstat.\"\n  /* Check for success.                                              */\n  If retval = -1 then Do\n    vfRc = 8  /* terminating error */\n    Select /* errno */\n      When errno = ENOENT Then\n        say 'The specified FROM path does not exist'\n      When errno = EACCES Then Do\n        Say \"You are not authorized to reach FROM path\" fromVal\".\"\n\n        /**************************************************************/\n        /* Now, for extra credit, we will check for search access to  */\n        /* the directory components of the path name, since that is a */\n        /* common cause of error, and display the first such directory*/\n        /* to which the user is not authorized. (There is no sense in */\n        /* continuing beyond that point because they will all yield a */\n        /* failure even if search access is present.)                 */\n        /**************************************************************/\n        checkpath = ''  /* The path to check */\n        workpath = fromVal /* A working copy of the input path */\n        Do Forever\n          idx = Pos('/',workpath)\n          If idx = 0 Then /* no more slashes means we are finished   */\n            leave\n          checkpath = checkpath || Substr(workpath,1,idx)\n          workpath = Substr(workpath,idx+1) /* Lop off head */\n\n          \"access (checkpath)\" X_OK\n\n          if retval = -1 then do\n            say \"You do not have search access to\" checkpath\n            Leave\n          End\n        End\n      End /* EACCES */\n      Otherwise Do\n        say \"Error locating FROM object.\",\n            \" Stat() retval =\" retval \"errno =\" ,\n             errno \"errnojr =\" errnojr\n      End\n    End /* Select errno*/\n    say \"Permissions are unchanged.\"\n    Signal VFOUT\n  End /* retval = -1 */\n\n  /*******************************************************************/\n  /* If the FROM path is not a directory, then flag use of FMODEL    */\n  /* and DMODEL suboperands of FTYPE.                                */\n  /*******************************************************************/\n  If fstat.ST_TYPE /= S_ISDIR &,\n     (ftypeVal = 'DMODEL' | ftypeVal = 'FMODEL') Then Do\n    say 'An FTYPE value of DMODEL or FMODEL can only be specified',\n        'when the FROM value is a directory.'\n    vfRc = 8\n    Signal VFOUT\n  End\n\n  /*******************************************************************/\n  /* If the FROM path does not contain the acl type requested,       */\n  /* issue a message, and let processing continue (vfRc=4).          */\n  /*******************************************************************/\n  If ftypeVal = 'ACL'    & fstat.ST_ACCESSACL = 0 |,\n     ftypeVal = 'DMODEL' & fstat.ST_DMODELACL = 0 |,\n     ftypeVal = 'FMODEL' & fstat.ST_FMODELACL = 0 Then Do\n    say 'FROM object has no' ftypeMsg 'acl.'\n    say 'Processing continues.'\n    vfRc = 4\n    Signal VFOUT\n  End\n\n  /*******************************************************************/\n  /* Get the FROM acl.                                               */\n  /*******************************************************************/\n  'aclinit sacl'                    /* init var to hold source acl   */\n  'aclget sacl (fromVal)' (ftypeCode)     /* get the access acl */\n\nVFOUT:\nReturn vfRC                     /* validateFrom                      */\n\n/* ----------------------------------------------------------------- */\n\nreaddirproc: procedure expose (syscall_constants) (@stem) dirlist. ,\n                                                          debugVal\n/*********************************************************************/\n/* Return list of subobjects of a directory                          */\n/*                                                                   */\n/* Input:                                                            */\n/*      - The path name of the user-specified directory              */\n/*      - The name of a stem to contain the list of subordinate      */\n/*        files.                                                     */\n/*      - A value indicating the scope of the operation:             */\n/*        - CURRENT - apply changes to objects within the specified  */\n/*          directory                                                */\n/*        - FILESYS - apply changes to objects within the containing */\n/*          zFS data set (i.e. mount points are not crossed)         */\n/*        - ALL - apply changes all the way down the mounted file    */\n/*          system structure, in and below the specified directory.  */\n/*                                                                   */\n/* Output:                                                           */\n/*      - The input stem is filled with the list of files            */\n/*      - the hard-coded 'dirlist.' stem contains a list of          */\n/*        subdirectories.                                            */\n/*                                                                   */\n/*********************************************************************/\n  parse arg path,stem,scope\n\n  /*******************************************************************/\n  /* Obtain the devno ('device number') of the file system in which  */\n  /* the input directory path exists. Comparing this to the devno    */\n  /* of sub-objects helps to determine when we have crossed a mount  */\n  /* point into a different zFS data set.                            */\n  /*******************************************************************/\n  at.=''\n  address syscall 'lstat (path) at.'\n  devno=at.st_dev\n\n  /*******************************************************************/\n  /* Initialize the directory stem and count, and the file count.    */\n  /*******************************************************************/\n  call value @stem,''\n  dirlist.=''\n  dirlist.1=path\n  dirlist=1\n  dirs=1\n  files=0\n\n  /*******************************************************************/\n  /* Loop on all directories. Initially, this only contains the      */\n  /* input directory, but in each iteration, the contents of the     */\n  /* directory will be read, and subdirectories will be placed       */\n  /* into the dirlist stem. Thus, subsequent iterations will         */\n  /* operate on these subdirectories as the list is built up.        */\n  /*******************************************************************/\n  Do dirx=1 By 1 While length(dirlist.dirx)>0\n    address syscall 'readdir (dirlist.dirx) names. attrs.'\n    If retval=-1 Then Leave\n    /*****************************************************************/\n    /* Loop on the contents of the directory being processed         */\n    /* in this iteration of the outer loop.                          */\n    /*****************************************************************/\n    Do d=1 to names.0\n      /***************************************************************/\n      /* Skip the special directories of \".\" and \"..\"                */\n      /***************************************************************/\n      If substr(names.d,1,1)='.' & attrs.d.st_type=s_isdir Then\n        iterate\n      /***************************************************************/\n      /* Add files to the input stem as absolute path names.         */\n      /***************************************************************/\n      If attrs.d.st_type=s_isreg Then\n        Do\n          files=files+1\n          call value stem||files,dirlist.dirx'/'names.d\n\n          Do i=1 to attrs.d.0\n            call value stem||files'.!attrs.'i,attrs.d.i\n          End\n        End\n      /***************************************************************/\n      /* Add directories to the dirlist stem as absolute path        */\n      /* names, excluding mount point directories if FILESYS         */\n      /* is specified.                                               */\n      /***************************************************************/\n      Else If attrs.d.st_type=s_isdir Then\n        Do\n          If (scope = 'CURRENT') |,\n             (scope = 'ALL')     |,\n             (scope = 'FILESYS' & attrs.d.st_dev=devno) Then Do\n            dirs = dirs + 1\n            dirlist = dirlist+1\n            dirlist.dirlist=dirlist.dirx'/'names.d\n          End\n          Else If attrs.d.st_dev/=devno & debugVal = 1 Then Do\n            say 'Excluding' dirlist.dirx'/'names.d,\n                'of type' attrs.d.st_type 'due to different devno'\n          End\n        End\n      Else\n        Do\n          If debugVal = 1 Then Do\n            say 'Excluding' dirlist.dirx'/'names.d,\n                'of type' attrs.d.st_type\n          End\n        End\n    End\n    /*****************************************************************/\n    /* If CURRENT is specified, we leave the outer loop after        */\n    /* having processed only the first directory (i.e. the one       */\n    /* specified by the user).                                       */\n    /*****************************************************************/\n    If scope = 'CURRENT' Then\n      Leave\n  End\n  /*******************************************************************/\n  /* Set the file count into the input file stem.                    */\n  /*******************************************************************/\n  call value stem'0',files\n  /*******************************************************************/\n  /* Set the directory count into the hard-coded directory stem.     */\n  /*******************************************************************/\n  dirlist.0=dirs\nreturn /* readdirproc */\n\n/* ----------------------------------------------------------------- */\n\nmunge: procedure\n/*********************************************************************/\n/* function: munge                                                   */\n/*                                                                   */\n/* input:  - A path name                                             */\n/*                                                                   */\n/* returns:  A version of the path name suitable for use in a        */\n/*           shell command                                           */\n/*                                                                   */\n/*********************************************************************/\nparse arg iPath\n\noPath = iPath                        /* Echo the input by default    */\nIf Pos(\" \",iPath) > 0 Then           /* If path contains a blank     */\n  oPath = '\"'iPath'\"'                /*  enclose it in doublequotes  */\n\nReturn oPath                         /* munge                        */\n\n/* ----------------------------------------------------------------- */\n\nbuildOutputHeader:\n/*********************************************************************/\n/* procedure: buildOutputHeader                                      */\n/*                                                                   */\n/* output: The following global variables are modified               */\n/*         - output. stem is primed with the heading defined         */\n/*           at the bottom of this file, and filled in with the      */\n/*           user-specified keywords that will result in             */\n/*           generated shell commands.                               */\n/*                                                                   */\n/* Notes:  We intentionally omit the path name to avoid awkward      */\n/*         continuations if it is greater than the line length.      */\n/*                                                                   */\n/*********************************************************************/\noutput.0 = 0\n/*********************************************************************/\n/* Find start of template at the bottom of this file.                */\n/*********************************************************************/\nDo sl = sourceline() to 1 by -1 Until sourceline(sl) = 'Template:'\nEnd\n/*********************************************************************/\n/* Set up some variables used while inserting variable lines.        */\n/*********************************************************************/\nlineStart = 4 ; lineEnd = 68\nlineLen = lineEnd - lineStart\n\n/*********************************************************************/\n/* Prime the script stem with the template lines.                    */\n/*********************************************************************/\nDo sl = sl+1 to sourceline()-1\n  line = '/* ' /* Reset line prefix */\n  tmp = output.0 + 1\n\n  If Pos(\"Created by\",sourceline(sl)) /= 0 Then Do\n    line = line'Created by    :' Userid() 'using the' execName 'exec'\n    line = Left(line,lineEnd,\" \") '*/'\n    output.tmp = line\n  End\n  Else If Pos(\"Creation date\",sourceline(sl)) /= 0 Then Do\n    line = line'Creation date :' Date() Time()\n    line = Left(line,lineEnd,\" \") '*/'\n    output.tmp = line\n  End\n  Else Do\n    output.tmp = Substr(sourceline(sl),1,71)\n  End\n\n  output.0 = tmp\nEnd\n\n/*********************************************************************/\n/* Process keywords by putting as many as will cleanly fit in a      */\n/* given line.  Write each line to the stem as they fill up.         */\n/*********************************************************************/\nline = '/* '   /* Reset line prefix */\nDo kNum = 1 to Words(saveKwds)\n  token = Strip(Word(saveKwds,kNum),Both,\" \")\n  Upper token\n  /*******************************************************************/\n  /* If the keyword is \"FROM\" and the path name is long enough that  */\n  /* the keyword could never fit in a single line, then replace it   */\n  /* with a smaller fake value and continue.                         */\n  /*******************************************************************/\n  If Substr(token,1,4) = \"FROM\" & Length(token) > lineLen Then\n    token = \"from(<path>)\"                      /* Use placeholder   */\n  Else\n    token = Strip(Word(saveKwds,kNum),Both,\" \") /* Restore case      */\n  /*******************************************************************/\n  /* If the keyword fits, append it to the current line.  Else,      */\n  /* write the line to the stem, and prime a new line for the next   */\n  /* keyword iteration.                                              */\n  /*******************************************************************/\n  If Length(token) <= lineEnd-Length(line) Then Do\n    line = line token\n  End\n  Else Do\n    line = Left(line,lineEnd,\" \") '*/'\n    tmp = output.0 + 1\n    output.tmp = line\n    output.0 = tmp\n    line = '/* '  /* Reset for next line */\n  End\nEnd\n/*********************************************************************/\n/* Put remaining keywords in a final stem entry.                     */\n/*********************************************************************/\nIf Length(line) > 0 Then Do  /* Write remainder */\n  line = Left(line,lineEnd,\" \") '*/'\n  tmp = output.0 + 1\n  output.tmp = line\n  output.0 = tmp\nEnd\n\n/*********************************************************************/\n/* Add block comment closing two lines                               */\n/*********************************************************************/\nDo sl = Sourceline()-1 to Sourceline()\n  tmp = output.0 + 1\n  output.tmp = Substr(sourceline(sl),1,71)\n  output.0 = tmp                          /* Increment num of lines  */\nEnd                                       /* For each template line  */\n\nReturn  /* buildOutputHeader */\n\n/* ----------------------------------------------------------------- */\n\nwriteOutputFile:\n/*********************************************************************/\n/* function: writeOutputFile                                         */\n/*                                                                   */\n/* input: The following global variables:                            */\n/*        - outputFile: Name of file, path, or data set into which   */\n/*                      to write the output                          */\n/*        - output.   : The stem variable containing the lines to    */\n/*                      write to the output file                     */\n/*                                                                   */\n/* output: The output is written                                     */\n/*                                                                   */\n/* returns: 1 - output successfully created                          */\n/*          0 - output not successfully created                      */\n/*                                                                   */\n/* Notes:  A data set starts with \"//\" by convention                 */\n/*                                                                   */\n/*********************************************************************/\nfileCreated = 1\n\n/*********************************************************************/\n/* Put \"exit 0\" at the end of the script to avoid exit status 255    */\n/* when executing the script with OSHELL.                            */\n/*********************************************************************/\ntmp = output.0 + 1\noutput.tmp = \"exit 0\"\noutput.0 = tmp\n\n/*********************************************************************/\n/* Write the output stem to the output UNIX file.                    */\n/*********************************************************************/\nIf Substr(outputFile,1,2) /= \"//\" Then Do  /* Unix file/path         */\n  'writefile (outputFile) 700 output.'\n  If retval = -1 Then Do\n    fileCreated = 0\n    say 'writefile error:' retval errno errnojr 'attempting to create',\n        outputFile 'output file.'\n    If noRun = 0 Then\n      say 'No changes were made.'\n  End\nEnd\n/*********************************************************************/\n/* Write the output stem to the output data set.                     */\n/*********************************************************************/\nElse Do\n  dsName = Substr(outputFile,3) /* Name starts after \"//\" */\n  address TSO                           /* Establish TSO environment */\n  \"ALLOC DA(\"dsName\") F(myoutdd) SHR REUSE\"\n  If rc /= 0 Then Do\n    say 'Error' rc 'allocating output data set' dsName'.'\n    fileCreated = 0\n  End\n  Else Do\n    \"EXECIO 0 DISKW myoutdd (OPEN\"\n    If rc /= 0 Then Do\n      say 'Error' rc 'opening output data set' dsName'.'\n      fileCreated = 0\n    End\n    Else Do\n      \"EXECIO * DISKW myoutdd (STEM output.\"\n      If rc /= 0 Then Do\n        say 'Error' rc 'writing to output data set' dsName'.'\n        fileCreated = 0\n      End\n      Else Do\n        \"EXECIO 0 DISKW myoutdd (FINIS\"\n        If rc /= 0 Then Do\n          say 'Error' rc 'closing output data set' dsName'.'\n          fileCreated = 0\n        End\n      End\n    End\n\n    \"FREE F(myoutdd)\"\n  End\n\n  address syscall    /* Restore syscall environment */\nEnd\n\nReturn fileCreated /* writeOutputFile */\n\n/* ----------------------------------------------------------------- */\n\n/*********************************************************************/\n/* ATTENTION!!!!!                                                    */\n/* The following label and lines are used in the construction of     */\n/* the output file and *MUST* remain at the very bottom              */\n/* of this exec!!!!                                                  */\n/*********************************************************************/\nTemplate:\n/* Rexx **************************************************************/\n/*                                                                   */\n/* Created by    :                                                   */\n/* Creation date :                                                   */\n/*                                                                   */\n/* This script contains the UNIX shell commands generated            */\n/* as a result of running the exec identified above with             */\n/* the following keywords:                                           */\n/*                                                                   */\n/*********************************************************************/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ORALTER": {"ttr": 899, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01!\\x00\\x15\\x01 \\x12\\x8f\\x01 \\x18?\\x10$\\x08\\x8e\\x08x\\x00\\x00\\xd9\\xc1\\xc3\\xc6\\xc1\\xc4\\xd4@@@'", "ispf": {"version": "01.33", "flags": 0, "createdate": "2020-05-07T00:00:00", "modifydate": "2020-07-01T10:24:15", "lines": 2190, "newlines": 2168, "modlines": 0, "user": "RACFADM"}, "text": "/*%NOCOMMENT====================* REXX *==============================*/\n/*     TYPE:  TSO Command                                             */\n/*  PURPOSE:  RACF Unix Security Attribute Management (ALTER)         */\n/*--------------------------------------------------------------------*/\n/*    NOTES:  Obtained utility and documentation from:                */\n/*            ftp://public.dhe.ibm.com/s390/zos/racf/RacfUnixCommands */\n/*--------------------------------------------------------------------*/\n/* FLG  YYMMDD  USERID   DESCRIPTION                                  */\n/* ---  ------  -------  -------------------------------------------- */\n/* @A2  200701  RACFA    Updated doc, added dataset to OUTFILE()      */\n/* @A1  200605  RACFA    Changed 'Syntax...End-Syntax' comments       */\n/* @A0  200605  RACFA    Obtained REXX from IBM                       */\n/*====================================================================*/\n/**********************************************************************\n Licensed Materials - Property of IBM\n 5650-ZOS\n Copyright IBM Corp. 2020\n\n Name:    ORALTER\n\n Version: 2\n\n Author: Bruce Wells - brwells@us.ibm.com\n\n Purpose: Provides UNIX security attribute management using\n          a syntax similar to the RACF RALTER command\n\n Input:   An absolute path name\n\n NOTE!!! This exec is dependent upon the following \"Syntax:\" line and\n         the \"End-Syntax\" line below in order to display the syntax\n         when the exec is invoked without keyword parameters.\n\n         Feel free to add/change examples to show things that are\n         frequently done in your orgnization. But please preserve\n         these surrounding lines.\n\n Beg-Syntax:\n Purpose:  Provides UNIX security attribute management using\n           a syntax similar to the RACF RALTER command\n\n Syntax:   ORALTER absolute_path_name operands\n\n Operands: All keywords are optional\n             FSSEC                (positional)\n             absolute-path-name   (positional)\n             APF | NOAPF\n             AUDIT(access-attempt(audit-access-level))\n             DEBUG\n             GLOBALaudit(access-attempt(audit-access-level))\n             GROUP(group-name)\n             OUTFILE(path-or-dataset-name)\n             OWNER(user-ID)\n             PERMS(uuugggooo)\n             PROGRAM | NOPROGRAM\n             RECursive(ALL | CURRENT | FILESYS)\n                             -------\n             SECLABEL(seclabel-name)\n             SETGID | NOSETGID\n             SETUID | NOSETUID\n             STICKY | NOSTICKY\n             VERBOSE\n\n Examples:\n   1) Change the owning file and group:\n        ORALTER /u/brwells/myfile OWNER(APPUSR1) GROUP(APPGRP)\n\n   2) Change the permission bits:\n        ORALTER /u/brwells/myfile PERMS(rwxr-xr-x)\n\n   3) Change the permission bits as above, in octal notation:\n        ORALTER /u/brwells/myfile PERMS(755)\n\n   4) Turn on the apf and program control extended attributes:\n        ORALTER /u/brwells/myprogram APF PROGRAM\n\n   5) Set the owner audit options to log all access:\n        ORALTER /u/brwells/myfile AUDIT(ALL(rwx))\n\n   6) Set the auditor audit options to log successful access:\n        ORALTER /u/brwells/myfile GLOBALAUDIT(SUCCESS(rwx))\n\n   7) To turn off all 'other' write bits in a directory:\n        ORALTER /u/brwells PERMS(o-w) RECURSIVE\n\n   8) To specify a path for the output script:\n        ORALTER /u/brwells PERMS(o-w) OUTFILE(/u/jdayka/john.sh)\n\n   9) To specify a PDS member for the output script:\n        ORALTER /u/brwells PERMS(o-w) OUTFILE(//'JDAYKA.UNIX(CMDOUT1)')\n\n End-Syntax\n\n**********************************************************************/\n/*******************************************************************/\n/*                                                                 */\n/* This program contains code made available by IBM Corporation    */\n/* on an AS IS basis. Any one receiving this program is            */\n/* considered to be licensed under IBM copyrights to use the       */\n/* IBM-provided source code in any way he or she deems fit,        */\n/* including copying it, compiling it, modifying it, and           */\n/* redistributing it, with or without modifications, except that   */\n/* it may be neither sold nor incorporated within a product that   */\n/* is sold.  No license under any IBM patents or patent            */\n/* applications is to be implied from this copyright license.      */\n/*                                                                 */\n/* The software is provided \"as-is\", and IBM disclaims all         */\n/* warranties, express or implied, including but not limited to    */\n/* implied warranties of merchantibility or fitness for a          */\n/* particular purpose.  IBM shall not be liable for any direct,    */\n/* indirect, incidental, special or consequential damages arising  */\n/* out of this agreement or the use or operation of the software.  */\n/*                                                                 */\n/* A user of this program should understand that IBM cannot        */\n/* provide technical support for the program and will not be       */\n/* responsible for any consequences of use of the program.         */\n/*                                                                 */\n/*******************************************************************/\nparse arg keywords                        /* Input keywords/values   */\nparse source . . execName .               /* Info about this exec    */\n\n/*********************************************************************/\n/* The following configuration variables affect the operation of     */\n/* this exec.                                                        */\n/*********************************************************************/\n/*********************************************************************/\n/* --------------   Start of Configuration Variables --------------- */\n/*********************************************************************/\n\n/*********************************************************************/\n/* noRun means that the security information is not changed.         */\n/* This mode of operation is useful in verbose mode, so              */\n/* you can see the equivalent shell commands. Also, it allows        */\n/* you to first evaluate the contents of the generated script file   */\n/* and only execute it as a shell script once you are satisfied      */\n/* with the results of the command.                                  */\n/*********************************************************************/\nnoRun = 1\n/*********************************************************************/\n/* verbose results in extra messages being issued during processing. */\n/* - Change to 0 to eliminate these messages by default. You can     */\n/*   still specify the VERBOSE keyword on individual commands to     */\n/*   get the messages.                                               */\n/* - Change to 11 to get these messages for sub-objects when you     */\n/*   specify RECURSIVE. Warning: It could get noisy! There is no     */\n/*   command keyword for this option.                                */\n/*********************************************************************/\nverboseVal = 1\n/*********************************************************************/\n/* outputFile is the name of the file in which the generated         */\n/* output will be written.  By default, it is set to                 */\n/* <exec-name>.script, where exec-name is the name you have saved    */\n/* this exec as (ORALTER by default).                                */\n/*                                                                   */\n/* You can change this to any path name you want, relative or        */\n/* absolute.                                                         */\n/*                                                                   */\n/* You can also specify a pre-allocated, cataloged data set.  It     */\n/* can be a sequential data set or a PDS member. To specify a data   */\n/* set use the shell convention for a data set, which is to start    */\n/* it with \"//\" and enclose it within single quotes. For example:    */\n/*  outputFile = \"//'HLQ.SEQUENTL.DATASET'\"                          */\n/*   or                                                              */\n/*  outputFile = \"//'HLQ.PDS(MEMBER)'\"                               */\n/*                                                                   */\n/* Warning!: When the output is written to a data set, it cannot     */\n/*           be executed as a shell script. OPERMIT will issue a     */\n/*           message if you are not in noRun mode.                   */\n/*                                                                   */\n/*********************************************************************/\noutputFile = execname\".script\"\n\n/*********************************************************************/\n/* --------------   End of Configuration Variables ----------------- */\n/*********************************************************************/\n\n/*********************************************************************/\n/* Define/initialize command keyword names and values.               */\n/*********************************************************************/\nVERBOSEkwd     = \"VERBOSE\"\nOWNERkwd       = \"OWNER\"         ; ownerVal       = ''\nGROUPkwd       = \"GROUP\"         ; groupVal       = ''\nPERMSkwd       = \"PERMS\"         ; permsVal       = ''\nSTICKYkwd      = \"STICKY\"        ; stickyVal      = 0\nNOSTICKYkwd    = \"NOSTICKY\"      ; noStickyVal    = 0\nSETUIDkwd      = \"SETUID\"        ; setuidVal      = 0\nNOSETUIDkwd    = \"NOSETUID\"      ; noSetuidVal    = 0\nSETGIDkwd      = \"SETGID\"        ; setgidVal      = 0\nNOSETGIDkwd    = \"NOSETGID\"      ; noSetgidVal    = 0\nAUDITkwd       = \"AUDIT\"         ; auditVal       = ''\nGLOBALAUDITkwd = \"GLOBALAUDIT\"   ; globalAuditVal = ''\nGLOBALabbr     = 6          /* GLOBAL is shortest abbreviation       */\nSECLABELkwd    = \"SECLABEL\"      ; seclabelVal    = ''\nAPFkwd         = \"APF\"           ; apfVal         = 0\nNOAPFkwd       = \"NOAPF\"         ; noApfVal       = 0\nPROGRAMkwd     = \"PROGRAM\"       ; programVal     = 0\nNOPROGRAMkwd   = \"NOPROGRAM\"     ; noProgramVal   = 0\nRECURSIVEkwd   = \"RECURSIVE\"     ; recursiveVal   = ''\nRECabbr      = 3            /* REC is shortest allowed abbreviation  */\nDEBUGkwd       = \"DEBUG\"         ; debugVal       = 0\nOUTFILEkwd     = \"OUTFILE\"       ; outfileVal     = ''\nOUTabbr      = 3            /* OUT is shortest allowed abbreviation  */\n\n/*********************************************************************/\n/* -----------------   Start of Mainline     ----------------------- */\n/*********************************************************************/\n\ncall syscalls('ON')  /* Initialize UNIX environment */\naddress syscall\n\noutput. = ''         /* Initialize stem for shell commands */\n\n/*********************************************************************/\n/* Display syntax if no arguments are supplied.                      */\n/*********************************************************************/\nIf Length(keywords) = 0 Then Do\n  Display = \"no\"\n  If sourceline() > 0 Then Do\n    Do i = 1 to sourceline()\n     If Word(sourceline(i),1) = \"Beg-Syntax:\" Then do         /* @A1 */\n       Display = \"yes\"\n       iterate                                                /* @A1 */\n     end                                                      /* @A1 */\n     If Word(sourceline(i),1) = \"End-Syntax\" Then\n       Leave\n     If Display = \"yes\" Then\n       say Substr(sourceline(i),1,72)\n    End\n  End\n  Signal GETOUT\nEnd\n\n/*********************************************************************/\n/* Inspect the first positional argument.  If it is 'FSSEC', we      */\n/* remove it from the command image and ignore it.  We tolerate      */\n/* this in case the user wants ORALTER to look just like the RALTER  */\n/* command, in which the 1st positional keyword is the class name.   */\n/*********************************************************************/\ntemp = Word(keywords,1)          /* Get 1st keyword                  */\nUpper temp\nIf temp = 'FSSEC' Then\n  keywords = Subword(keywords,2) /* Remove class from keyword string */\n\n/*********************************************************************/\n/* Get positional path name argument.                                */\n/*********************************************************************/\npath = Word(keywords,1)          /* 1st keyword is the path name     */\n\n/*********************************************************************/\n/* Obtain information on passed path name.                           */\n/*********************************************************************/\n\"stat (path) stat.\"\n\n/* Check for success.                                                */\nIf retval = -1 then Do\n  Select /* errno */\n    When errno = ENOENT Then\n      say \"The specified path does not exist.\"\n    When errno = EACCES Then Do\n      Say \"You are not authorized to reach\" path\".\"\n\n      /***************************************************************/\n      /* Now, for extra credit, we will check for search access to   */\n      /* the directory components of the path name, since that is a  */\n      /* common cause of error, and display the first such directory */\n      /* to which the user is not authorized. (There is no sense in  */\n      /* continuing beyond that point because they will all yield a  */\n      /* failure even if search access is present.)                  */\n      /***************************************************************/\n      checkpath = ''    /* The path to check */\n      workpath = path   /* A working copy of the input path */\n      Do Forever\n        idx = Pos('/',workpath)\n        If idx = 0 Then  /* no more slashes means we are finished    */\n          leave\n        checkpath = checkpath || Substr(workpath,1,idx)\n        workpath = Substr(workpath,idx+1) /* Lop off head */\n\n        \"access (checkpath)\" X_OK\n\n        if retval = -1 then do\n          say \"You do not have search access to\" checkpath\n          Leave\n        End\n      End\n    End  /* EACCES */\n    Otherwise Do\n      say \"Error locating target object.\",\n          \" Stat() retval =\" retval \"errno =\" ,\n           errno \"errnojr =\" errnojr\n    End\n  End   /* Select errno*/\n  Signal GETOUT\nEnd /* retval = -1 */\n\n/*********************************************************************/\n/* Remove path from keyword string for subsequent processing.        */\n/* Make a copy, since the act of parsing will destroy the string.    */\n/*********************************************************************/\nkeywords = Subword(keywords,2)  /* Remove path from keyword string   */\nsaveKwds = keywords\n\n/*********************************************************************/\n/* Parse the keywords and values from the keyword string.            */\n/*********************************************************************/\nexecRc = 0\nexecRc = parseKeywords()\nIf execRc /= 0 Then\n  Signal GETOUT\n\n/*********************************************************************/\n/* Check keywords for consistency.                                   */\n/*********************************************************************/\nexecRc = checkKeywords()\nIf execRc /= 0 Then\n  Signal GETOUT\n\n/*********************************************************************/\n/* If OUTFILE was specified, override the value of the outputFile    */\n/* configuration variable.                                           */\n/*********************************************************************/\nIf outfileVal /= '' Then\n  outputFile = outfileVal\n\n/*********************************************************************/\n/* Build output file header.                                         */\n/*********************************************************************/\nCall buildOutputHeader\ncmdStart = output.0 + 1  /* Save line number of first command        */\n\n/*********************************************************************/\n/* Process the keywords.                                             */\n/*********************************************************************/\nexecRc = ProcessKeywords(path)\nIf execRc /= 0 Then\n  Signal GETOUT\n\n/*********************************************************************/\n/* Process RECURSIVE keyword.                                        */\n/*                                                                   */\n/* This is only valid when the target object is a directory.         */\n/*                                                                   */\n/* We obtain a list of sub-objects. This will contain the target     */\n/* itself, which we have already processed, so we skip the first     */\n/* directory.                                                        */\n/*                                                                   */\n/*********************************************************************/\n@stem = filelist.\nIf recursiveVal /= '' Then Do\n  call readdirproc path,@stem,recursiveVal\n  /* If DEBUG specified, display returned directory/file lists */\n  If debugVal = 1 Then Do\n    say 'Files:' filelist.0\n    Do i = 1 to filelist.0\n      say filelist.i\n    End\n    say ''\n    say 'Directories:' dirlist.0\n    Do i = 1 to dirlist.0\n      say dirlist.i\n    End\n  End\n  /*******************************************************************/\n  /* Process directories.                                            */\n  /*******************************************************************/\n  Do objs = 2 to dirlist.0\n    execRc = processKeywords(dirlist.objs)\n    If execRc /= 0 Then\n      Signal GETOUT\n  End\n  /*******************************************************************/\n  /* Process files.                                                  */\n  /*******************************************************************/\n  Do objs = 1 to filelist.0\n    execRc = processKeywords(filelist.objs)\n    If execRc /= 0 Then\n      Signal GETOUT\n  End\nEnd\n\nGETOUT:\n\n/*********************************************************************/\n/* Display list of shell commands that this command might            */\n/* have corresponded to, if we have any commands.                    */\n/*********************************************************************/\nIf verboseVal > 0 Then\n  If output.0 >= cmdStart Then Do\n    say ' '\n    say \"This command would result in the following\",\n        \"UNIX shell command(s):\"\n    Do cmds = cmdStart to output.0 /* Skip rexx header */\n      say Substr(output.cmds,2,Length(output.cmds)-2)\n    End\n  End\n  Else\n    if (display <> 'yes') then                                /* @A1 */\n    say 'The specified command resulted in no shell commands being',\n        'generated.'\n\n/*********************************************************************/\n/* Write the script stem to the output script file, if we have any   */\n/* commands.                                                         */\n/*********************************************************************/\nIf output.0 >= cmdStart Then\n  scriptOK = writeOutputFile()\n\nExit\n\n/*********************************************************************/\n/* -----------------     End of Mainline     ----------------------- */\n/*********************************************************************/\n\n\nprocessKeywords:\n/*********************************************************************/\n/* procedure: processKeywords                                        */\n/*                                                                   */\n/* input:  - The path name to modify                                 */\n/*                                                                   */\n/* output: - Returns a return code                                   */\n/*                                                                   */\n/* Notes:  - This is essentially just a continuation of mainline     */\n/*           processing, put into a subroutine so that it can be     */\n/*           called iteratively for sub-objects by the RECURSIVE     */\n/*           keyword.                                                */\n/*                                                                   */\n/*           In that spirit, it might be annoying to see certain     */\n/*           messages repeated (e.g. the UID/GID mapping message)    */\n/*           or certain actions attempted (e.g. updating extended    */\n/*           attributes for a directory) when the RECURSIVE option   */\n/*           is used. The logic below is thus sensitive to the       */\n/*           fact that it might be getting called for RECURSIVE.     */\n/*                                                                   */\n/*********************************************************************/\nparse arg rpath\n\npkRc = 0  /* Return value */\n\n/*********************************************************************/\n/* Obtain information on passed path name.                           */\n/*                                                                   */\n/* Note we never expect the possibility of 'not-found', because      */\n/* the mainline checked the path specified, and the RECURSIVE        */\n/* keyword resulted in us already locating a list of sub-objects.    */\n/* (Though there is, of course, a time-of-check to time-of-use       */\n/* window.)                                                          */\n/*                                                                   */\n/*********************************************************************/\n\"stat (rpath) rstat.\"\nIf retval < 0 Then Do\n  If errno = ENOENT Then\n    say \"Target object does not exist:\" rpath\n  Else If errno = EACCES Then\n    say 'Not authorized to read' rpath'.'\n  Else\n    say \"Error locating\" rpath\". Retval =\" retval \"errno =\" ,\n         errno \"errnojr =\" errnojr\n  pkRc = 8\n  Signal kwdExit\nEnd\n\n/*********************************************************************/\n/* Make a value of the path name that can be used in shell           */\n/* commands.  For example, if the path contains a blank, the         */\n/* entire path must be enclosed in quotes.                           */\n/*********************************************************************/\ncpath = munge(rpath)          /* cpath is for use in commands        */\n\n/*********************************************************************/\n/* Process file ownership keywords (OWNER and GROUP)                 */\n/*********************************************************************/\npkRc = processOwnershipKwds()\nIf pkRc > 0 Then Signal kwdExit\n\n/*********************************************************************/\n/* Process file mode related keywords (PERMS, NO|STICKY, NO|SETUID,  */\n/* and NO|SETGID)                                                    */\n/*********************************************************************/\npkRc = processFilemodeKwds()\n\n/*********************************************************************/\n/* Process extended attribute keywords (NO|APF and NO|PROGRAM)       */\n/*********************************************************************/\npkRc = processExtattrKwds()\n\n/*********************************************************************/\n/* Process AUDIT keyword                                             */\n/*********************************************************************/\npkRc = processAuditKwd()\n\n/*********************************************************************/\n/* Process GLOBALAUDIT keyword                                       */\n/*********************************************************************/\npkRc = processGlobalauditKwd()\n\n/*********************************************************************/\n/* Process SECLABEL keyword                                          */\n/*********************************************************************/\npkRc = processSeclabelKwd()\n\nkwdExit:\nReturn pkRc                     /* processKeywords                   */\n\n/* ----------------------------------------------------------------- */\n\nprocessOwnershipKwds:\nowRc = 0 /* Return value */\n\n/*********************************************************************/\n/* Process OWNER keyword.                                            */\n/*********************************************************************/\nownerUid = rstat.ST_UID\n\nIf ownerVal /= '' Then Do   /* OWNER specified */\n  /***************************************************************/\n  /* Map the specified value to a numeric UID.                   */\n  /***************************************************************/\n  'getpwnam' ownerVal 'pw.'\n  If retval > 0 Then Do   /* Success */\n    ownerUid = pw.PW_UID\n  End\n  Else Do\n    say 'Unable to map' ownerVal 'into a UID.'\n    say 'Processing terminated with no changes made.'\n    owRc = 8\n    Signal ownExit\n  End\n\n  /***********************************************/\n  /* ++ Add shell command to script stem.        */\n  /***********************************************/\n  tmp = output.0 + 1\n  output.tmp = \"'chown\" ownerVal cpath\"'\"\n  output.0 = tmp\nEnd\n\n/*********************************************************************/\n/* Process GROUP keyword.                                            */\n/*********************************************************************/\nownerGid = rstat.ST_GID      /* GROUP specified */\nIf groupVal /= '' Then Do\n  /***************************************************************/\n  /* Map the specified value to a numeric GID.                   */\n  /***************************************************************/\n  'getgrnam' groupVal 'gr.'\n  If retval > 0 Then Do     /* Success */\n    ownerGid = gr.GR_GID\n  End\n  Else Do\n    say 'Unable to map' groupVal 'into a GID.'\n    say 'Processing terminated with no changes made.'\n    owRc = 8\n    Signal ownExit\n  End\n\n  /***********************************************/\n  /* ++ Add shell command to script stem.        */\n  /***********************************************/\n  tmp = output.0 + 1\n  output.tmp = \"'chgrp\" groupVal cpath\"'\"\n  output.0 = tmp\nEnd\n\n/*********************************************************************/\n/* Issue chown to set the UID and GID determined above.              */\n/*********************************************************************/\nIf noRun = 1 Then Signal ownExit\nIf ownerVal /= '' | groupVal /= '' Then Do /* OWNER/GROUP specified  */\n  \"chown (rpath) (ownerUid) (ownerGid)\"\n  If retval /= 0 Then Do\n    If errno = EPERM Then\n      say \"You are not authorized to change ownership of\" rpath\n    Else\n      say \"chown error:\" retval errno errnojr \"on\" rpath\n  End\n  Else Do\n    /*****************************************************************/\n    /* Issue a hopefully helpful message indicating the result of    */\n    /* the user->UID and/or group->GID mapping operation. But only   */\n    /* for the specified path (i.e. not for each recursive path),    */\n    /* and only if verbose mode is requested.                        */\n    /*****************************************************************/\n    If rpath = path & verboseVal > 0 |,\n                      verboseVal = 11 Then Do\n      If ownerVal /= '' Then\n        say \"Owner successfully changed to UID\" ownerUid \"for\" rpath\n      If groupVal /= '' Then\n        say \"Group successfully changed to GID\" ownerGid \"for\" rpath\n    End\n  End\nEnd\nownExit:\n\nReturn owRc /* processOwnershipKwds */\n\n/* ----------------------------------------------------------------- */\n\nprocessFilemodeKwds:\n/*********************************************************************/\n/* Process PERMS, NO|SETUID, NO|SETGID, and NO|STICKY keywords.      */\n/*                                                                   */\n/* All of these attributes exist in a 4-byte structure called the    */\n/* file mode. We obtain the existing file mode, merge the specified  */\n/* changes into it, and store the entire mode back using chmod().    */\n/*                                                                   */\n/*********************************************************************/\n\n/*********************************************************************/\n/* Process PERMS keyword                                             */\n/*                                                                   */\n/* The user may have specified the permissions in octal format,      */\n/* full symbolic format (all nine positions specified), or operator  */\n/* format, where individual permissions types are set, added, or     */\n/* removed.                                                          */\n/*********************************************************************/\nfmRc = 0 /* Return value */\n\nIf permsVal /= '' Then Do   /* PERMS is specified                    */\n  /*******************************************************************/\n  /* When the permission format is octal, things are simple, since   */\n  /* chmod() requires octal permissions. We simply copy the user's   */\n  /* input into the variable we will pass to chmod().                */\n  /*******************************************************************/\n  If permsFormat = 'octal' Then Do /* User specified octal format    */\n    chmodPerms = permsVal     /* Already in desired format for chmod */\n  End\n  /*******************************************************************/\n  /* When the permission format is in full symbolic mode, we         */\n  /* convert each rwx grouping into octal, concatenate the results,  */\n  /* and send that into chmod().                                     */\n  /*******************************************************************/\n  Else if permsFormat = 'full' Then Do /* User specified full format */\n    uperms = octalOf(Substr(permsVal,1,3))   /* Xlate 1st three bits */\n    gperms = octalOf(Substr(permsVal,4,3))   /* Xlate 2nd three bits */\n    operms = octalOf(Substr(permsVal,7,3))   /* Xlate 3rd three bits */\n    chmodPerms = uperms||gperms||operms  /* Concatenate octal values */\n  End\n  /*******************************************************************/\n  /* When the permission format is oper, we must first obtain the    */\n  /* octal representation of the normalized symbolic 'rwx' perm-     */\n  /* ission value. This must be applied to each of the subject       */\n  /* permission types (u/g/o).  If a type isn't specified, we use    */\n  /* the existing bits from stat().  These three sets are concat-    */\n  /* enated together to form a working permission string.            */\n  /* When the operator is:                                           */\n  /*  - equal('='), we simply use the work string as the new mode.   */\n  /*  - plus ('+'), we OR the work string with the existing mode     */\n  /*    from the stat structure.                                     */\n  /*  - minus('-'), we AND the 'complement' of the value with        */\n  /*    the stat structure to turn the bits off.                     */\n  /*******************************************************************/\n  Else If permsFormat = 'oper' Then Do   /* Let the fun begin        */\n    Parse Value permsVal With oSub oOp oBits /* Parse value string   */\n\n    /* Get the normal octal, or octal 'complement' format of perms   */\n    If oOp = '-' Then\n      oBits = octalOf(oBits,\"-\")   /* Xlate perm bits negatively */\n    Else\n      oBits = octalOf(oBits)       /* Xlate perm bits normally   */\n\n    /* For each subject value, copy or replace the relevant byte     */\n    /* from the file mode in the stat() structure.                   */\n    If Pos(\"U\",oSub) > 0 Then\n      uWorkPerms = oBits\n    Else\n      uworkPerms = Substr(rstat.ST_MODE,1,1)\n    If Pos(\"G\",oSub) > 0 Then\n      gWorkPerms = oBits\n    Else\n      gworkPerms = Substr(rstat.ST_MODE,2,1)\n    If Pos(\"O\",oSub) > 0 Then\n      oWorkPerms = oBits\n    Else\n      oworkPerms = Substr(rstat.ST_MODE,3,1)\n    /* Concatenate each type to get the working octal permissions.   */\n    workPerms = uworkPerms||gworkPerms||oworkPerms\n    /* Depending on the operation, we will now either replace the    */\n    /* existing perms with the work string (\"=\"), OR in the work     */\n    /* string (\"+\"), or AND off the bits in the 'negative' work      */\n    /* string. What results is the octal string to set using chmod().*/\n    Select\n      When oOp = \"=\" Then Do\n        chmodPerms = workPerms\n      End\n      When oOp = \"+\" Then Do\n        chmodPerms = BITOR(rstat.ST_MODE,workPerms)\n      End\n      When oOp = \"-\" Then Do\n        chmodPerms = BITAND(rstat.ST_MODE,workPerms)\n      End\n      Otherwise\n    End /* Select */\n  End\n\n  /***********************************************/\n  /* ++ Add shell command to script stem.        */\n  /***********************************************/\n  tmp = output.0 + 1\n  output.tmp = \"'chmod\" chmodPerms cpath\"'\"\n  output.0 = tmp\nEnd\nElse Do /* PERMS not specified. Use existing value. */\n  chmodPerms = rstat.ST_MODE\nEnd\n\n/*********************************************************************/\n/* Process NO|SETUID, NO|SETGID, and NO|STICKY keywords              */\n/*                                                                   */\n/* This consists of setting a variable to 1 or 0 depending on the    */\n/* keyword specified, or to the path's current value if neither      */\n/* keyword is specified.                                             */\n/*                                                                   */\n/*********************************************************************/\nIf setuidVal = 1 Then Do\n  chmodSetuid = 1\n  /***********************************************/\n  /* ++ Add shell command to script stem.        */\n  /***********************************************/\n  tmp = output.0 + 1\n  output.tmp = \"'chmod u+s\" cpath\"'\"\n  output.0 = tmp\nEnd\nIf nosetuidVal = 1 Then Do\n  chmodSetuid = 0\n  /***********************************************/\n  /* ++ Add shell command to script stem.        */\n  /***********************************************/\n  tmp = output.0 + 1\n  output.tmp = \"'chmod u-s\" cpath\"'\"\n  output.0 = tmp\nEnd\nIf setuidVal = 0 & nosetuidVal = 0 Then Do\n  chmodSetuid = rstat.ST_SETUID\nEnd\n\nIf setgidVal = 1 Then Do\n  chmodSetgid = 1\n  /***********************************************/\n  /* ++ Add shell command to script stem.        */\n  /***********************************************/\n  tmp = output.0 + 1\n  output.tmp = \"'chmod g+s\" cpath\"'\"\n  output.0 = tmp\nEnd\nIf nosetgidVal = 1 Then Do\n  chmodSetgid = 0\n  /***********************************************/\n  /* ++ Add shell command to script stem.        */\n  /***********************************************/\n  tmp = output.0 + 1\n  output.tmp = \"'chmod g-s\" cpath\"'\"\n  output.0 = tmp\nEnd\nIf setgidVal = 0 & nosetgidVal = 0 Then\n  chmodSetgid = rstat.ST_SETGID\n\nIf stickyVal = 1 Then Do\n  chmodSticky = 1\n  /***********************************************/\n  /* ++ Add shell command to script stem.        */\n  /***********************************************/\n  tmp = output.0 + 1\n  output.tmp = \"'chmod +t\" cpath\"'\"\n  output.0 = tmp\nEnd\nIf nostickyVal = 1 Then Do\n  chmodSticky = 0\n  /***********************************************/\n  /* ++ Add shell command to script stem.        */\n  /***********************************************/\n  tmp = output.0 + 1\n  output.tmp = \"'chmod -t\" cpath\"'\"\n  output.0 = tmp\nEnd\nIf stickyVal = 0 & nostickyVal = 0 Then\n  chmodSticky = rstat.ST_STICKY\n\n/*********************************************************************/\n/* If PERMS, NO|SETUID, NO|SETGID, or NO|STICKY keyword was          */\n/* specified, then set the values determined above using the         */\n/* chmod syscall.                                                    */\n/*********************************************************************/\nIf noRun = 1 Then Signal NOCHMOD\nIf permsVal /= '' |,\n   setuidVal+nosetuidVal+,\n   setgidVal+nosetgidVal+,\n   stickyVal+nostickyVal > 0 Then Do\n  \"chmod (rpath) (chmodPerms) (chmodSetuid) (chmodSetgid) (chmodSticky)\"\n\n  If retval /= 0 Then Do\n    If errno = EPERM Then\n      say \"You are not authorized to change permissions of\" rpath\n    Else\n      say \"chmod error:\" retval errno errnojr \"on\" rpath\n  End\n  Else\n    If rpath = path & verboseVal > 0 |,\n                      verboseVal = 11 Then Do\n      If permsVal /= '' Then\n        say \"Permission bits successfully changed to\" chmodPerms,\n            \"for\" rpath\n      If stickyVal /= 0 | noStickyVal /= 0 Then\n        say \"Sticky bit successfully changed for\" rpath\n      If setuidVal /= 0 | noSetuidVal /= 0 Then\n        say \"Set-user-ID bit successfully changed for\" rpath\n      If setgidVal /= 0 | noSetgidVal /= 0 Then\n        say \"Set-group-ID bit successfully changed for\" rpath\n    End\nEnd /* Any mode keywords specified */\nNOCHMOD:\n\nReturn fmRc /* processFilemodeKwds */\n\n/* ----------------------------------------------------------------- */\n\nprocessExtattrKwds:\n/*********************************************************************/\n/* Process NO|APF and NO|PROGRAM keywords                            */\n/*                                                                   */\n/* This consists of setting a variable to 1 or 0 depending on the    */\n/* keyword specified, or to the path's current value if neither      */\n/* keyword is specified.                                             */\n/*                                                                   */\n/* Authority to change the apf bit is separate from the authority    */\n/* to change the program bit, and UNIX is kind enough not to flag    */\n/* an error when the chattr syscall 'changes' a bit to its own       */\n/* value.  However, if multiple bits are specified, and the user     */\n/* is not authorized to one of them, we cannot determine which       */\n/* one is not allowed.  This makes the issuance of a precise         */\n/* error message impossible, but we do as best we can.               */\n/*                                                                   */\n/* To make the matter worse, failure might not be for lack of        */\n/* BPX.FILEATTR.xxx authority, but for lack of write access to       */\n/* the file. In the former case, we may as well stop trying any      */\n/* more NOxxx updates when RECURSIVE is specified, but in the        */\n/* latter case, subsequent updates could possibly work. The          */\n/* errno makes no distinction between the two cases, however.        */\n/*                                                                   */\n/*********************************************************************/\neaRc = 0 /* Return value */\n\nIf apfVal+noApfVal+programVal+noProgramVal > 0 Then Do /* any bits?  */\n  /*******************************************************************/\n  /* Set up variable for the possibility of an error.                */\n  /*******************************************************************/\n  extAttr = ''\n  Select\n    When apfVal+noApfVal>0 & programVal+noProgramVal>0 Then\n      extAttr = 'some'\n    When apfVal+noApfVal>0 & programVal+noProgramVal=0 Then\n      extAttr = 'the APF'\n    When apfVal+noApfVal=0 & programVal+noProgramVal>0 Then\n      extAttr = 'the PROGRAM'\n    Otherwise\n  End /* Select */\n\n  /* Initialize variables */\n  z1='00'x\n  z3='000000'x\n  gen_pc='02'x\n  gen_apf='04'x\n  val = z1 ; mask = z1\n\n  /*******************************************************************/\n  /* Only attempt extended attribute update for regular files.       */\n  /* Only issue message if operation is explicitly attempted against */\n  /* a directory (i.e. RECURSIVE not specified).                     */\n  /*******************************************************************/\n  If rstat.st_type <> S_ISREG Then Do\n     If recursiveVal = '' Then Do\n       say \"Extended attributes only apply to regular files.\"\n     End\n  End\n  Else Do                         /* It's a file                     */\n    If apfVal = 1 Then Do         /* APF specified                   */\n      mask = bitor(mask,gen_apf)  /* Set mask to specify APF bit     */\n      val  = bitor(val,gen_apf)   /* Set value to APF on             */\n\n      /***********************************************/\n      /* ++ Add shell command to script stem.        */\n      /***********************************************/\n      tmp = output.0 + 1\n      output.tmp = \"'extattr +a\" cpath\"'\"\n      output.0 = tmp\n    End\n\n    If noApfVal = 1 Then Do       /* NOAPF specified                 */\n      mask = bitor(mask,gen_apf)  /* Set mask to specify APF bit     */\n                                  /* (Value bit is already off)      */\n      /***********************************************/\n      /* ++ Add shell command to script stem.        */\n      /***********************************************/\n      tmp = output.0 + 1\n      output.tmp = \"'extattr -a\" cpath\"'\"\n      output.0 = tmp\n    End\n\n    If programVal = 1 Then Do     /* PROGRAM specified               */\n      mask = bitor(mask,gen_pc)   /* Set mask to specify PROGRAM bit */\n      val  = bitor(val,gen_pc)    /* Set value to PROGRAM on         */\n\n      /***********************************************/\n      /* ++ Add shell command to script stem.        */\n      /***********************************************/\n      tmp = output.0 + 1\n      output.tmp = \"'extattr +p\" cpath\"'\"\n      output.0 = tmp\n    End\n\n    If noProgramVal = 1 Then Do   /* NOPROGRAM specified             */\n      mask = bitor(mask,gen_pc)   /* Set mask to specify PROGRAM bit */\n                                  /* (Value bit is already off)      */\n      /***********************************************/\n      /* ++ Add shell command to script stem.        */\n      /***********************************************/\n      tmp = output.0 + 1\n      output.tmp = \"'extattr -p\" cpath\"'\"\n      output.0 = tmp\n    End\n\n    mask=z3 || mask               /* Widen mask and value to 4 bytes */\n    val=z3 || val\n\n    If noRun = 0 Then Do\n     \"chattr (rpath)\" ST_GENVALUE \"(mask) (val)\"\n\n     If retval /= 0 Then Do\n       If errno = EPERM Then Do\n         say \"You are not authorized to change\" extAttr \"extended\",\n             \"attribute.\"\n         If extAttr = 'some' Then\n           say \"Try modifying a single attribute at a time.\"\n         If recursiveVal /= '' Then Do\n           say \"No more extended attribute changes will be attempted.\"\n           /**********************************************************/\n           /* Nullify the keyword variables so we don't try again.   */\n           /* Note that we have already disallowed APF and PROGRAM   */\n           /* with the RECURSIVE keyword, but the user might be      */\n           /* specifying NOAPF or NOPROGRAM.                         */\n           /**********************************************************/\n           noApfVal = 0 ; noProgramVal = 0\n         End\n       End\n       Else\n         say \"chattr error:\" retval errno errnojr \"on\" rpath\n     End\n     Else\n       If rpath = path & verboseVal > 0 |,\n                         verboseVal = 11 Then Do\n         If apfVal /= 0 | noApfVal /= 0 Then\n           say \"APF bit successfully changed for\" rpath\n         If programVal /= 0 | noprogramVal /= 0 Then\n           say \"Program-control bit successfully changed for\" rpath\n       End\n    End /* noRun=0 */\n  End  /* It's a file */\nEnd    /* Extended attribute change requested */\nReturn eaRc /* processExtattrKwds */\n\n/* ----------------------------------------------------------------- */\n\nprocessAuditKwd:\n/*********************************************************************/\n/* Process AUDIT keyword                                             */\n/*                                                                   */\n/* The parseKeywords routine created two variables for us:           */\n/*  - uAudString:  contains one of ALL, SUCCESS, FAILURES, or NONE   */\n/*  - uPermstring: contains a 3-character maximum string consisting  */\n/*                of R, W, or X in any order.                        */\n/*********************************************************************/\nauRc = 0 /* Return value */\n\nIf auditVal /= '' Then Do   /* AUDIT is specified                    */\n  chauditVal = d2x(rstat.ST_UAUDIT,8) /* Get user audit bits      */\n  ra = Substr(chauditVal,1,2)    /* Byte containing read bits    */\n  wa = Substr(chauditVal,3,2)    /* Byte containing write bits   */\n  xa = Substr(chauditVal,5,2)    /* Byte containing execute bits */\n  rv = Substr(chauditVal,7,2)    /* Reserved byte                */\n\n  audCmd = \"'chaudit \"\n\n  Do j = 1 to Length(uPermString)\n    tempAud = getAud(uAudString)\n    Select\n      When Substr(uPermString,j,1) = \"R\" Then Do\n        ra = tempAud\n        audCmd = audCmd||\"r\"\n      End   /* When Read */\n      When Substr(uPermString,j,1) = \"W\" Then Do\n        wa = tempAud\n        audCmd = audCmd||\"w\"\n      End   /* When Write */\n      When Substr(uPermString,j,1) = \"X\" Then Do\n        xa = tempAud\n        audCmd = audCmd||\"x\"\n      End   /* When eXecute */\n      Otherwise /* Unexpected because already checked */\n        say \"Invalid permission string:\" uPermString\n        Exit 4\n    End /* Select on permission value */\n  End /* For each specified permission */\n\n  chauditVal = d2x(ra,2)||d2x(wa,2)||d2x(xa,2)||rv\n  chauditVal = x2d(chauditVal)\n\n  /***********************************************/\n  /* ++ Add shell command to script stem.        */\n  /***********************************************/\n  Select\n    When uAudString = \"SUCCESS\" Then Do\n      audCmd = audCmd||\"+s\"\n    End\n    When uAudString = \"FAILURES\" Then Do\n      audCmd = audCmd||\"+f\"\n    End\n    When uAudString = \"ALL\" Then Do\n      audCmd = audCmd||\"+sf\"\n    End\n    When uAudString = \"NONE\" Then Do\n      audCmd = audCmd||\"-sf\"\n    End\n    Otherwise\n  End /* Select */\n  tmp = output.0 + 1\n  output.tmp = audCmd cpath\"'\"\n  output.0 = tmp\n\n  If noRun = 0 Then Do\n   /* Issue chaudit syscall to update the user audit bits */\n   \"chaudit (rpath)\" (chauditVal) 0\n\n   If retval /= 0 Then Do\n     If errno = EPERM Then\n       say \"You are not authorized to change audit settings of\",\n            rpath\n     Else\n       say \"chaudit error:\" retval errno errnojr\n   End\n   Else\n     If rpath = path & verboseVal > 0 |,\n                       verboseVal = 11 Then Do\n       say \"Owner audit bits successfully changed for\" rpath\n     End\n  End /* noRun=0 */\nEnd /* AUDIT is specified */\n\nReturn auRc  /* processAuditKwd */\n\n/* ----------------------------------------------------------------- */\n\nprocessGlobalauditKwd:\n/*********************************************************************/\n/* Process GLOBALAUDIT keyword                                       */\n/*                                                                   */\n/* This is done exactly as the AUDIT keyword, above, except that we  */\n/* use a different field from the stat() output, and we provide a    */\n/* different flag for auditor options on the chaudit() syscall.      */\n/*********************************************************************/\ngaRc = 0 /* Return value */\n\nIf globalAuditVal /= '' Then Do  /* GLOBALAUDIT is specified     */\n  chauditVal = d2x(rstat.ST_AAUDIT,8) /* get Auditor audit bits   */\n  ra = Substr(chauditVal,1,2)    /* Byte containing read bits    */\n  wa = Substr(chauditVal,3,2)    /* Byte containing write bits   */\n  xa = Substr(chauditVal,5,2)    /* Byte containing execute bits */\n  rv = Substr(chauditVal,7,2)    /* Reserved byte                */\n\n  audCmd = \"'chaudit -a \"\n\n  Do j = 1 to Length(aPermString)\n    tempAud = getAud(aAudString)\n    Select\n      When Substr(aPermString,j,1) = \"R\" Then Do\n        ra = tempAud\n        audCmd = audCmd||\"r\"\n      End   /* When Read */\n      When Substr(aPermString,j,1) = \"W\" Then Do\n        wa = tempAud\n        audCmd = audCmd||\"w\"\n      End   /* When Write */\n      When Substr(aPermString,j,1) = \"X\" Then Do\n        xa = tempAud\n        audCmd = audCmd||\"x\"\n      End   /* When eXecute */\n      Otherwise /* Unexpected because already checked */\n        say \"Invalid permission string:\" aPermString\n        Exit 4\n    End /* Select on permission value */\n  End /* For each specified permission */\n\n  chauditVal = d2x(ra,2)||d2x(wa,2)||d2x(xa,2)||rv\n  chauditVal = x2d(chauditVal)\n\n  /***********************************************/\n  /* ++ Add shell command to script stem.        */\n  /***********************************************/\n  Select\n    When aAudString = \"SUCCESS\" Then Do\n      audCmd = audCmd||\"+s\"\n    End\n    When aAudString = \"FAILURES\" Then Do\n      audCmd = audCmd||\"+f\"\n    End\n    When aAudString = \"ALL\" Then Do\n      audCmd = audCmd||\"+sf\"\n    End\n    When aAudString = \"NONE\" Then Do\n      audCmd = audCmd||\"-sf\"\n    End\n    Otherwise\n  End /* Select */\n  tmp = output.0 + 1\n  output.tmp = audCmd cpath\"'\"\n  output.0 = tmp\n\n  If noRun = 0 Then Do\n   /* Issue chaudit syscall to update the auditor audit bits */\n   \"chaudit (rpath)\" (chauditVal) 1\n\n   If retval /= 0 Then Do\n     If errno = EPERM Then\n       say \"You are not authorized to change auditor audit settings of\",\n            rpath\n     Else\n       say \"chaudit error:\" retval errno errnojr\n   End\n   Else\n     If rpath = path & verboseVal > 0 |,\n                       verboseVal = 11 Then Do\n       say \"Auditor audit bits successfully changed for\" rpath\n     End\n  End /* noRun=0 */\nEnd\nReturn gaRc  /* processGlobalauditKwd */\n\n/* ----------------------------------------------------------------- */\n\nprocessSeclabelKwd:\n/*********************************************************************/\n/* Process SECLABEL keyword                                          */\n/*                                                                   */\n/* There is no syscall service to update the SECLABEL, so we issue   */\n/* the chlabel shell command using BPXWUNIX.                         */\n/*                                                                   */\n/* (You may now be asking: \"Why not use bpxwunix and the relevant    */\n/*  unix shell command to update *all* the security attributes       */\n/*  supported by ORALTER?\"  Answer: No reason at all. It was a       */\n/*  fun learning experience to use the syscalls.)                    */\n/*                                                                   */\n/*********************************************************************/\nslRc = 0 /* Return value */\n\nIf seclabelVal /= '' Then Do         /* SECLABEL is specified        */\n  cmdString = \"chlabel \"||seclabelVal||\" \"||cpath\n\n  /***********************************************/\n  /* ++ Add shell command to script stem.        */\n  /***********************************************/\n  tmp = output.0 + 1\n  output.tmp = \"'\"cmdString\"'\"\n  output.0 = tmp\n\n  If noRun = 0 Then Do\n   call bpxwunix cmdString,,stdout.,stderr.\n\n   If retval = 0 Then Do  /* bpxwunix worked. chlabel might have.    */\n     If stderr.0 > 0 Then Do\n       Do i = 1 to stderr.0\n         say stderr.i\n       End\n     End\n     Else\n       If rpath = path & verboseVal > 0 | verboseVal = 11 Then\n         say \"Security label successfully changed for\" rpath\n   End\n   Else Do\n     say \"Bpxwunix error\" retval errno errnojr \"when attempting\",\n         \"to set seclabel for\" rpath\n   End\n  End /* noRun=0 */\nEnd   /* SECLABEL specified */\nReturn slRc  /* processSeclabelKwd */\n\n/* ----------------------------------------------------------------- */\n\nparseKeywords:\n/*********************************************************************/\n/* Examine input to identify keywords and values. We process the     */\n/* keyword string as a set of words, taking into account that some   */\n/* keywords might allow blank-separated values.                      */\n/*********************************************************************/\nparseRc = 0\nDo i = 1 to Words(keywords) Until Length(keywords)=0 /* Parse kwds   */\n\n  nextWord = Word(keywords,1)    /* Get next word                    */\n\n  /*******************************************************************/\n  /* Isolate the next keyword and its value.                         */\n  /*******************************************************************/\n  openParen = Pos(\"(\",nextWord)  /* Expect \"(\" to be part of word    */\n  closeParen = Pos(\")\",keywords) /* But must look for \")\" in the\n                                     entire cmd remainder            */\n  closeDoubleParen = Pos(\"))\",keywords) /* Look for double close too */\n\n  /*******************************************************************/\n  /* If there is no open paren in the word, then this is a keyword   */\n  /* without a value.                                                */\n  /*******************************************************************/\n  If openParen = 0 Then\n    Do\n      nextKwd = nextWord\n      nextVal = ''\n      endKwd = Length(nextWord)+1\n    End\n  /*******************************************************************/\n  /* If there is an open paren in the word, then this is a keyword   */\n  /* with a value.                                                   */\n  /*                                                                 */\n  /* Note that this requires further tweaking for keywords with      */\n  /* suboperands (e.g. GLOBAL|AUDIT), and that gets handled by       */\n  /* specific keyword processing below.                              */\n  /*******************************************************************/\n  Else\n    Do\n      nextKwd = Substr(nextWord,1,openParen-1)\n      valLength = closeParen - openParen - 1\n      nextVal = Strip(Substr(keywords,openParen+1,valLength),Both,\" \")\n      endKwd = Pos(\")\",keywords)+1\n    End\n  Upper nextKwd\n\n  /*******************************************************************/\n  /* Uncomment the following to help debug command parsing.          */\n  /*******************************************************************/\n  /*\n  say \"Command image remainder is\" keywords\n  say \"Keyword is\" nextKwd\n  say \"Value is\" nextVal \"of length\" Length(nextVal)\n  /* The following will be not quite accurate for \"))\" keywords.     */\n  say \"First position after current keyword/value is\" endKwd\n  say ''\n  */\n\n  /*******************************************************************/\n  /* Set the value for each specified keyword.                       */\n  /*******************************************************************/\n  Select                        /* Identify keyword                  */\n    /*****************************************************************/\n    /* For the OUTFILE keyword, some additional processing is        */\n    /* required to support a PDS member, due to the additional       */\n    /* parentheses. We must look for an additional closing paren     */\n    /* and redo the keyword-with-value code above to isolate the     */\n    /* value.                                                        */\n    /*                                                               */\n    /* Note that, when OUTFILE is not specified, we make no effort   */\n    /* to validate the value of the outputFile configuration value.  */\n    /* We just let it rip and let the file I/O fail at the end.      */\n    /* But this parsing forces our hand a bit. We assume the value   */\n    /* is specified correctly, but do just enough checking to avoid  */\n    /* a REXX error. If something is unexpected, we let the value    */\n    /* stand as parsed above and send it downstream for failure.     */\n    /*****************************************************************/\n    When Abbrev(OUTFILEkwd,nextKwd,OUTabbr) = 1 Then\n      Do\n        outfileVal = nextVal                /* Save output var       */\n\n        If Substr(outfileVal,1,2) = \"//\" &, /* If data set path      */\n           Pos(\"(\",nextval) > 0 Then Do     /* contains open paren   */\n\n          /* Find next closing paren, which should be true close     */\n          closeParen = closeParen +,\n                       Pos(\")\",Substr(keywords,closeParen+1))\n\n          /* Redo parse code to get correct parsing values           */\n          If closeParen > 0 Then Do         /* If \")\" found          */\n            valLength = closeParen - openParen - 1\n            nextVal = Strip(,\n                       Substr(keywords,openParen+1,valLength),Both,\" \")\n            endKwd = closeParen + 1\n            outfileVal = nextVal            /* Reload output var     */\n          End\n        End\n      End\n    /*****************************************************************/\n    /* If the RECURSIVE keyword is specified without a value, then   */\n    /* we use the default of CURRENT.                                */\n    /*****************************************************************/\n    When Abbrev(RECURSIVEkwd,nextKwd,RECabbr) = 1 Then\n      Do\n        If stat.ST_TYPE /= S_ISDIR Then Do\n          say 'RECURSIVE can only be specified for a directory.'\n          parseRc = 4\n        End\n        Else Do\n          If nextVal = '' Then Do\n            recursiveVal = 'CURRENT'\n          End\n          Else Do\n            Upper nextVal\n            recursiveVal = nextVal\n            If recursiveVal /= 'CURRENT' &,\n               recursiveVal /= 'FILESYS' &,\n               recursiveVal /= 'ALL' Then Do\n              say 'Invalid value specified for RECURSIVE keyword.'\n              say 'Use one of CURRENT, FILESYS, or ALL, or omit',\n                  'parentheses and value for the default of CURRENT'\n              parseRc = 4\n            End\n          End\n        End\n      End\n    When nextKwd = DEBUGkwd Then\n      Do\n        debugVal = 1\n      End\n    When nextKwd = VERBOSEkwd Then\n      Do\n        verboseVal = 1\n      End\n    When nextKwd = OWNERkwd Then\n      Do\n        Upper nextVal\n        ownerVal = nextVal\n      End\n    When nextKwd = GROUPkwd Then\n      Do\n        Upper nextVal\n        groupVal = nextVal\n      End\n    When nextKwd = SECLABELkwd Then\n      Do\n        Upper nextVal\n        seclabelVal = nextVal\n      End\n    When nextKwd = PERMSkwd Then\n      Do\n        Upper nextVal\n        permsVal = nextVal\n        /*************************************************************/\n        /* Make sure the value is valid.           */\n        /*************************************************************/\n        permsFormat = verifyPermsFormat(permsVal)\n        If permsFormat = \"bad\" Then Do\n          say 'Incorrect PERMS value:' permsVal\n          parseRc = 4\n        End\n      End\n    When nextKwd = NOAPFkwd Then\n      Do\n        noApfVal = 1\n      End\n    When nextKwd = APFkwd Then\n      Do\n        apfVal = 1\n      End\n    When nextKwd = PROGRAMkwd Then\n      Do\n        programVal = 1\n      End\n    When nextKwd = NOPROGRAMkwd Then\n      Do\n        noProgramVal = 1\n      End\n    When nextKwd = STICKYkwd Then\n      Do\n        stickyVal = 1\n      End\n    When nextKwd = NOSTICKYkwd Then\n      Do\n        noStickyVal = 1\n      End\n    When nextKwd = SETUIDkwd Then\n      Do\n        setuidVal = 1\n      End\n    When nextKwd = NOSETUIDkwd Then\n      Do\n        noSetuidVal = 1\n      End\n    When nextKwd = SETGIDkwd Then\n      Do\n        setgidVal = 1\n      End\n    When nextKwd = NOSETGIDkwd Then\n      Do\n        noSetgidVal = 1\n      End\n    /*****************************************************************/\n    /* For the AUDIT keyword, we expect the value to end with 2      */\n    /* closing parens, but the code above which isolates values is   */\n    /* common with 'normal' keywords, and so terminates prior to the */\n    /* first closing paren, which actually makes our job easier.     */\n    /*****************************************************************/\n    When nextKwd = AUDITkwd Then\n      Do\n        auditVal = \"YES\"  /* Fake value indicating keyword specified */\n        Upper nextVal\n\n        Call parseAudit(nextKwd nextVal)\n\n        /* Check that the keyword ends with 2 closing parens.        */\n        If Substr(keywords,endKwd,1) /= \")\" Then Do\n          say \"Missing ending parenthesis in\" nextKwd \"keyword.\"\n          Exit 4\n        End\n\n        endKwd = endKwd + 1  /* Account for double closing paren     */\n      End\n    When Abbrev(GLOBALAUDITkwd,nextKwd,GLOBALabbr) = 1 Then\n      Do\n        globalAuditVal = \"YES\" /* Fake value indicating kwd spec'd   */\n        Upper nextVal\n\n        Call parseAudit(nextKwd nextVal)\n\n        /* Check that the keyword ends with 2 closing parens.        */\n        If Substr(keywords,endKwd,1) /= \")\" Then Do\n          say \"Missing ending parenthesis in\" nextKwd \"keyword.\"\n          Exit 4\n        End\n\n        endKwd = endKwd + 1  /* Account for double closing paren     */\n      End\n    Otherwise\n      If Length(nextKwd) /= 0 Then Do\n        say \"Invalid keyword:\" nextKwd\n        parseRc = 4\n      End\n  End                           /* Identify keyword                  */\n\n  /*******************************************************************/\n  /* Make sure the next keyword is blank-separated from current.     */\n  /*******************************************************************/\n  If parseRc= 0 Then\n    If Substr(keywords,endKwd,1) <> \" \" Then Do\n      say \"Missing blank after\" nextKwd \"keyword.\"\n      Exit 4\n    End\n\n  /*******************************************************************/\n  /* Remove this keyword from the input string, for the next         */\n  /* iteration.                                                      */\n  /*******************************************************************/\n  keywords = Substr(keywords,endKwd)     /* Remove processed keyword */\n  keywords = Strip(keywords,Leading,\" \")\n\nEnd                             /* Parse keywords loop               */\n\nReturn parseRc                  /* parseKeywords                     */\n\n/* ----------------------------------------------------------------- */\n\nverifyPermsFormat: procedure expose permsVal\n/*********************************************************************/\n/* function: verifyPermsFormat                                       */\n/*                                                                   */\n/* input:  - The value of the specified permission string            */\n/*                                                                   */\n/* returns:  A string indicating the format of the input:            */\n/*             - 'full'  : full symbolic form (uuugggooo)            */\n/*             - 'octal' : octal format (e.g. 777, 750, etc)         */\n/*             - 'oper'  : as an operator (e.g. o+r, ug-rw, etc.)    */\n/*                         as supported by the chmod shell command   */\n/*             - 'bad'   : none of the above                         */\n/*                                                                   */\n/*           When the format is 'oper' the value of permsVal,        */\n/*           originally set to the value specified by the user       */\n/*           for the PERMS keyword, is replaced by a normalized      */\n/*           string representing the permission types, operation,    */\n/*           and permission values.  See parseOperFormat.            */\n/*                                                                   */\n/*********************************************************************/\nparse arg perms\n\nIf (Substr(perms,1,1) = \"R\" |,\n    Substr(perms,1,1) = \"-\")    &,\n   (Substr(perms,2,1) = \"W\" |,\n    Substr(perms,2,1) = \"-\")    &,\n   (Substr(perms,3,1) = \"X\" |,\n    Substr(perms,3,1) = \"-\")    &,\n   (Substr(perms,4,1) = \"R\" |,\n    Substr(perms,4,1) = \"-\")    &,\n   (Substr(perms,5,1) = \"W\" |,\n    Substr(perms,5,1) = \"-\")    &,\n   (Substr(perms,6,1) = \"X\" |,\n    Substr(perms,6,1) = \"-\")    &,\n   (Substr(perms,7,1) = \"R\" |,\n    Substr(perms,7,1) = \"-\")    &,\n   (Substr(perms,8,1) = \"W\" |,\n    Substr(perms,8,1) = \"-\")    &,\n   (Substr(perms,9,1) = \"X\" |,\n    Substr(perms,9,1) = \"-\")    Then\n  Do   /* Full symbolic format */\n    permFormat = 'full'\n  End  /* Full symbolic format */\nElse\n  If Verify(perms,'01234567') = 0 & Length(perms) = 3 Then Do\n    permFormat = 'octal'\n  End\n  Else Do\n    permFormat = parseOperFormat(perms)\n    If permFormat /= 'bad' Then Do\n      permsVal = permFormat /* Blank-separated oper string returned  */\n      permFormat = 'oper'   /* Set format to oper                    */\n    End\n  End\n\nReturn permFormat   /* verifyPermsFormat */\n\n/* ----------------------------------------------------------------- */\n\nparseOperFormat: procedure\n/*********************************************************************/\n/* function: See if the PERMS value adheres to the operator format.  */\n/*                                                                   */\n/* input:  - The permission string                                   */\n/*                                                                   */\n/* returns:                                                          */\n/*  success - Normalized, blank-separated string containing:         */\n/*            - 1st word: permission types to change (U/G/O),        */\n/*                        concatenated, in that order                */\n/*            - 2nd word: operation (+, -, or =)                     */\n/*            - 3rd word: permission values to turn on or off        */\n/*                        (R/W/X), concatenated, in that order       */\n/*  failure - The string \"bad\"                                       */\n/*                                                                   */\n/*********************************************************************/\nparse arg perms\n\nops = \"+-=\"                      /* Operator values                  */\noPos = Verify(ops,perms,Match)   /* Returns pos of 1st char found    */\n\nIf oPos /= 0 Then Do                   /* An operator was found      */\n  oPos = Pos(Substr(ops,oPos,1),perms) /* Gets its position in perms */\n  operator = Substr(perms,oPos,1)      /* Set variable to operator   */\n  subject = Substr(perms,1,oPos-1)     /* Set var to subject type(s) */\n  permissions = Substr(perms,oPos+1)   /* Set var to permissions     */\n\n  /* Verify that only valid characters are specified in the subject. */\n  If subject = '' Then Do\n    say 'The permission type(s) must be specified.'\n    permFormat= 'bad'            /* Must contain supported operator  */\n  End\n  sPos = Verify(subject,\"AUGO\")        /* all,user,group,other       */\n  If sPos = 0 Then Do\n    /* Don't let a(ll) be specified with other values. The chmod     */\n    /* shell command tolerates this and uses 'all', but failing      */\n    /* might be less astonishing for the security administrator.     */\n    If Pos(\"A\",subject) /=0 & Length(subject) > 1 Then Do\n      say \"'A'(ll) cannot be specified with other permission types.\"\n      permFormat= 'bad'          /* Must contain supported operator  */\n    End\n  End\n  Else Do\n    badChar = Substr(subject,sPos,1)\n    say badChar \"is not a valid permission type.\"\n    permFormat= 'bad'            /* Must contain supported operator  */\n  End\n\n  /* Fail if permissions are null. Chmod tolerates this as a no-op,  */\n  /* but see above.                                                  */\n  if permissions = '' Then Do\n    say \"No permission values were specified.\"\n    permFormat= 'bad'            /* Must contain supported operator  */\n  End\n  /* Verify that only valid characters are specified in the perms.   */\n  Else Do\n    bPos = Verify(permissions,\"RWX\") /* Pos of 1st char found */\n    If bPos /= 0 Then Do\n      badChar = Substr(permissions,bPos,1)\n      say badChar \"is not a valid permission value.\"\n      permFormat= 'bad'          /* Must contain supported operator  */\n    End\n  End\n\n  /* Fail for subject and permissions > 3 chars. Chmod tolerates     */\n  /* this, but see above.                                            */\n  If Length(subject) > 3 Then Do\n    say \"Permission types can be no more than 3 characters.\"\n    permFormat= 'bad'            /* Must contain supported operator  */\n  End\n  If Length(permissions) > 3 Then Do\n    say \"Permission values can be no more than 3 characters.\"\n    permFormat= 'bad'            /* Must contain supported operator  */\n  End\n  /* Normalize by building new subject and permissions strings.      */\n  tmpPerms=''\n  valPerms=''\n  If Pos(\"R\",permissions) > 0 Then Do\n    tmpPerms = tmpPerms||\"R\"\n    valPerms = valPerms||\"R\"\n  End\n  Else\n    tmpPerms = tmpPerms||\"-\"\n  If Pos(\"W\",permissions) > 0 Then Do\n    tmpPerms = tmpPerms||\"W\"\n    valPerms = valPerms||\"W\"\n  End\n  Else\n    tmpPerms = tmpPerms||\"-\"\n  If Pos(\"X\",permissions) > 0 Then Do\n    tmpPerms = tmpPerms||\"X\"\n    valPerms = valPerms||\"X\"\n  End\n  Else\n    tmpPerms = tmpPerms||\"-\"\n  If subject = \"A\" Then\n    subject = \"UGO\"\n  tmpSubject = ''\n  If Pos(\"U\",subject) > 0 Then\n    tmpSubject = tmpSubject||\"U\"\n  If Pos(\"G\",subject) > 0 Then\n    tmpSubject = tmpSubject||\"G\"\n  If Pos(\"O\",subject) > 0 Then\n    tmpSubject = tmpSubject||\"O\"\n  /* If the specified perm types string is longer than the normal-   */\n  /* ized string, then duplicate values must have been specified     */\n  /* (e.g. \"rrw\"). Chmod tolerates this, but see above.              */\n  If permFormat /= \"bad\" &,      /* Error not already flagged        */\n     Length(tmpSubject) < Length(subject) Then Do\n    say \"Duplicate permission tyoes specified.\"\n    permFormat= 'bad'            /* Must contain unique perms        */\n  End\n  If permFormat /= \"bad\" then\n    permFormat = tmpSubject operator tmpPerms\nEnd\nElse\n  permFormat= 'bad'              /* Must contain supported operator  */\n\nReturn permFormat                /* parseOperFormat                  */\n\n/* ----------------------------------------------------------------- */\n\ncheckKeywords:\n/*********************************************************************/\n/* Check for consistency of keywords:                                */\n/*  - Issue message and set return code when mutually exclusive      */\n/*    keywords are specified.                                        */\n/*  - Set defaults as appropriate.                                   */\n/*********************************************************************/\n\nexecRc = 0\n\n/*********************************************************************/\n/* Check if both APF and NOAPF are specified.                        */\n/*********************************************************************/\nIf apfVal = 1 & noApfVal = 1 Then Do\n  say \"You cannot specify both APF and NOAPF.\"\n  execRc = 1\nEnd\n\n/*********************************************************************/\n/* Check if both PROGRAM and NOPROGRAM are specified.                */\n/*********************************************************************/\nIf programVal = 1 & noProgramVal = 1 Then Do\n  say \"You cannot specify both PROGRAM and NOPROGRAM.\"\n  execRc = 1\nEnd\n\n/*********************************************************************/\n/* Check if both STICKY and NOSTICKY are specified.                  */\n/*********************************************************************/\nIf stickyVal = 1 & noStickyVal = 1 Then Do\n  say \"You cannot specify both STICKY and NOSTICKY.\"\n  execRc = 1\nEnd\n\n/*********************************************************************/\n/* Check if both SETUID and NOSETUID are specified.                  */\n/*********************************************************************/\nIf setuidVal = 1 & noSetuidVal = 1 Then Do\n  say \"You cannot specify both SETUID and NOSETUID.\"\n  execRc = 1\nEnd\n\n/*********************************************************************/\n/* Check if both SETGID and NOSETGID are specified.                  */\n/*********************************************************************/\nIf setgidVal = 1 & noSetgidVal = 1 Then Do\n  say \"You cannot specify both SETGID and NOSETGID.\"\n  execRc = 1\nEnd\n\n/*********************************************************************/\n/* Check if either APF or PROGRAM is specified with RECURSIVE.       */\n/* That just seems dangerous.                                        */\n/*********************************************************************/\nIf programVal = 1 & recursiveVal /= '' Then Do\n  say \"You cannot specify PROGRAM with the RECURSIVE keyword.\"\n  execRc = 1\nEnd\n\nIf apfVal = 1 & recursiveVal /= '' Then Do\n  say \"You cannot specify APF with the RECURSIVE keyword.\"\n  execRc = 1\nEnd\n\nReturn execRc /* checkKeywords */\n\n/* ----------------------------------------------------------------- */\n\n/*********************************************************************/\n/* function: getAud                                                  */\n/*                                                                   */\n/* input:  - A string indicating the audit bits that should be set   */\n/*           ('ALL', 'NONE', 'SUCCESS', or 'FAILURES')               */\n/*                                                                   */\n/* returns:  A numeric value corresponding to the bits that must     */\n/*           be set (3, 0, 1, or 2, respective to the input)         */\n/*                                                                   */\n/*********************************************************************/\ngetAud: procedure\nparse arg audString\n\nSelect\n  When audString = \"SUCCESS\" Then Do\n    audVal = 1\n  End\n  When audString = \"FAILURES\" Then Do\n    audVal = 2\n  End\n  When audString = \"ALL\" Then Do\n    audVal = 3\n  End\n  Otherwise /* NONE */\n    audVal = 0\nEnd /* Select */\n\nReturn audVal /* getAud */\n\n/* ----------------------------------------------------------------- */\n\nparseAudit: procedure expose uAudString uPermString,\n                             aAudString aPermString,\n                             AUDITkwd\n/*********************************************************************/\n/* function: parseAudit                                              */\n/*                                                                   */\n/* input:  - The keyword being processed (AUDIT or GLOBALAUDIT)      */\n/*         - The value specified for the keyword                     */\n/*                                                                   */\n/* exposes:  uAudString  - ALL, NONE, SUCCESS, or FAILURES           */\n/*           uPermString - The permissions specified (e.g. RWX)      */\n/*           aAudString  - ALL, NONE, SUCCESS, or FAILURES           */\n/*           aPermString - The permissions specified (e.g. RWX)      */\n/*                                                                   */\n/*           The \"u\" variables are for the AUDIT (user audit         */\n/*             options) keyword                                      */\n/*           The \"a\" variables are for the GLOBALAUDIT (auditor      */\n/*             audit options) keyword                                */\n/*                                                                   */\n/*                                                                   */\n/*********************************************************************/\nparse arg keyword kwdValue\n\noparenIdx = Pos(\"(\",kwdValue)\nIf oparenIdx = 0 Then Do\n  say \"Invalid\" keyword \"value:\" kwdValue\n  Exit 4\nEnd\n\naudString = Substr(kwdValue,1,oparenIdx-1)\npermString = Substr(kwdValue,oparenIdx+1)\n\n/* Validate that audString contains a valid value.                   */\nIf audString /= \"ALL\"     &,\n  audString /= \"FAILURES\" &,\n  audString /= \"NONE\"     &,\n  audString /= \"SUCCESS\"  Then Do\n  say \"Invalid\" keyword \"access-intent value:\" audString\n  Exit 4\nEnd\n\n/* Validate that permString is 1 to 3 characters in length           */\nIf Length(permString) = 0 |,\n   Length(permString) > 3 Then Do\n  say \"Invalid\" keyword \"permission string:\" permString\n  Exit 4\nEnd\n/* Validate that permString contains only R, W, and X                */\nrCount = 0 ; wCount = 0 ; xCount = 0\nDo j = 1 to Length(permString)\n  Select\n    When Substr(permString,j,1) = \"R\" Then\n      rCount = rCount + 1\n    When Substr(permString,j,1) = \"W\" Then\n      wCount = wCount + 1\n    When Substr(permString,j,1) = \"X\" Then\n      xCount = xCount + 1\n    Otherwise\n      say \"Invalid\" keyword \"permission string:\" permString\n      Exit 4\n  End\nEnd\n\n/* Validate that permString does not contain duplicate               */\n/* values (e.g. RRX)                                                 */\nIf rCount > 1 | wCount > 1 | xCount > 1 Then Do\n  say \"Invalid\" keyword \"permission string:\" permString\n  Exit 4\nEnd\n\n/* Copy working variables into the appropriate exposed variables,    */\n/* depending on whether we are processing AUDIT or GLOBALAUDIT.      */\nIf keyword = AUDITkwd Then Do\n  uAudString = audString\n  uPermString = permString\nEnd\nElse Do\n  aAudString = audString\n  aPermString = permString\nEnd\n\nReturn /* parseAudit */\n\n/* ----------------------------------------------------------------- */\n\nOctalOf: procedure\n/*********************************************************************/\n/* function: octalOf                                                 */\n/*                                                                   */\n/* input:  - A three-character permission string (e.g., 'RWX',       */\n/*           '---', 'R-X', etc)                                      */\n/*         - An optional operator. When this value is \"-\", we        */\n/*           return the 'complement' of the normal output,           */\n/*           suitable for masking OFF the input bits.                */\n/*                                                                   */\n/* returns:  The octal representation of the input bits, which is    */\n/*           a single digit value from 0-7.                          */\n/*                                                                   */\n/*********************************************************************/\nparse arg perms,op\n\noVal = 0\n\nIf Substr(perms,1,1) = \"R\" Then\n  oVal = oVal + 4\nIf Substr(perms,2,1) = \"W\" Then\n  oVal = oVal + 2\nIf Substr(perms,3,1) = \"X\" Then\n  oVal = oVal + 1\n\nIf op = \"-\" Then\n  oVal = 7 - oVal\n\nReturn oVal /* octalOf */\n\n/* ----------------------------------------------------------------- */\n\nreaddirproc: procedure expose (syscall_constants) (@stem) dirlist. ,\n                                                          debugVal\n/*********************************************************************/\n/* Return list of subobjects of a directory                          */\n/*                                                                   */\n/* Input:                                                            */\n/*      - The path name of the user-specified directory              */\n/*      - The name of a stem to contain the list of subordinate      */\n/*        files.                                                     */\n/*      - A value indicating the scope of the operation:             */\n/*        - CURRENT - apply changes to objects within the specified  */\n/*          directory                                                */\n/*        - FILESYS - apply changes to objects within the containing */\n/*          zFS data set (i.e. mount points are not crossed)         */\n/*        - ALL - apply changes all the way down the mounted file    */\n/*          system structure, in and below the specified directory.  */\n/*                                                                   */\n/* Output:                                                           */\n/*      - The input stem is filled with the list of files            */\n/*      - the hard-coded 'dirlist.' stem contains a list of          */\n/*        subdirectories.                                            */\n/*                                                                   */\n/*********************************************************************/\n  parse arg path,stem,scope\n\n  /*******************************************************************/\n  /* Obtain the devno ('device number') of the file system in which  */\n  /* the input directory path exists. Comparing this to the devno    */\n  /* of sub-objects helps to determine when we have crossed a mount  */\n  /* point into a different zFS data set.                            */\n  /*******************************************************************/\n  at.=''\n  address syscall 'lstat (path) at.'\n  devno=at.st_dev\n\n  /*******************************************************************/\n  /* Initialize the directory stem and count, and the file count.    */\n  /*******************************************************************/\n  call value @stem,''\n  dirlist.=''\n  dirlist.1=path\n  dirlist=1\n  dirs=1\n  files=0\n\n  /*******************************************************************/\n  /* Loop on all directories. Initially, this only contains the      */\n  /* input directory, but in each iteration, the contents of the     */\n  /* directory will be read, and subdirectories will be placed       */\n  /* into the dirlist stem. Thus, subsequent iterations will         */\n  /* operate on these subdirectories as the list is built up.        */\n  /*******************************************************************/\n  Do dirx=1 By 1 While length(dirlist.dirx)>0\n    address syscall 'readdir (dirlist.dirx) names. attrs.'\n    If retval=-1 Then Leave\n    /*****************************************************************/\n    /* Loop on the contents of the directory being processed         */\n    /* in this iteration of the outer loop.                          */\n    /*****************************************************************/\n    Do d=1 to names.0\n      /***************************************************************/\n      /* Skip the special directories of \".\" and \"..\"                */\n      /***************************************************************/\n      If substr(names.d,1,1)='.' & attrs.d.st_type=s_isdir Then\n        iterate\n      /***************************************************************/\n      /* Add files to the input stem as absolute path names.         */\n      /***************************************************************/\n      If attrs.d.st_type=s_isreg Then\n        Do\n          files=files+1\n          call value stem||files,dirlist.dirx'/'names.d\n\n          Do i=1 to attrs.d.0\n            call value stem||files'.!attrs.'i,attrs.d.i\n          End\n        End\n      /***************************************************************/\n      /* Add directories to the dirlist stem as absolute path        */\n      /* names, excluding mount point directories if FILESYS         */\n      /* is specified.                                               */\n      /***************************************************************/\n      Else If attrs.d.st_type=s_isdir Then\n        Do\n          If (scope = 'CURRENT') |,\n             (scope = 'ALL')     |,\n             (scope = 'FILESYS' & attrs.d.st_dev=devno) Then Do\n            dirs = dirs + 1\n            dirlist = dirlist+1\n            dirlist.dirlist=dirlist.dirx'/'names.d\n          End\n          Else If attrs.d.st_dev/=devno & debugVal = 1 Then Do\n            say 'Excluding' dirlist.dirx'/'names.d,\n                'of type' attrs.d.st_type 'due to different devno'\n          End\n        End\n      Else\n        Do\n          If debugVal = 1 Then Do\n            say 'Excluding' dirlist.dirx'/'names.d,\n                'of type' attrs.d.st_type\n          End\n        End\n    End\n    /*****************************************************************/\n    /* If CURRENT is specified, we leave the outer loop after        */\n    /* having processed only the first directory (i.e. the one       */\n    /* specified by the user).                                       */\n    /*****************************************************************/\n    If scope = 'CURRENT' Then\n      Leave\n  End\n  /*******************************************************************/\n  /* Set the file count into the input file stem.                    */\n  /*******************************************************************/\n  call value stem'0',files\n  /*******************************************************************/\n  /* Set the directory count into the hard-coded directory stem.     */\n  /*******************************************************************/\n  dirlist.0=dirs\nreturn /* readdirproc */\n\n/* ----------------------------------------------------------------- */\n\nmunge: procedure\n/*********************************************************************/\n/* function: munge                                                   */\n/*                                                                   */\n/* input:  - A path name                                             */\n/*                                                                   */\n/* returns:  A version of the path name suitable for use in a        */\n/*           shell command                                           */\n/*                                                                   */\n/*********************************************************************/\nparse arg iPath\n\noPath = iPath                        /* Echo the input by default    */\nIf Pos(\" \",iPath) > 0 Then           /* If path contains a blank     */\n  oPath = '\"'iPath'\"'                /*  enclose it in doublequotes  */\n\nReturn oPath                         /* munge                        */\n\n/* ----------------------------------------------------------------- */\n\nbuildOutputHeader:\n/*********************************************************************/\n/* procedure: buildOutputHeader                                      */\n/*                                                                   */\n/* output: The following global variables are modified               */\n/*         - output. stem is primed with the heading defined         */\n/*           at the bottom of this file, and filled in with the      */\n/*           user-specified keywords that will result in             */\n/*           generated shell commands.                               */\n/*                                                                   */\n/* Notes:  We intentionally omit the path name to avoid awkward      */\n/*         continuations if it is greater than the line length.      */\n/*                                                                   */\n/*********************************************************************/\noutput.0 = 0\n/*********************************************************************/\n/* Find start of template at the bottom of this file.                */\n/*********************************************************************/\nDo sl = sourceline() to 1 by -1 Until sourceline(sl) = 'Template:'\nEnd\n/*********************************************************************/\n/* Set up some variables used while inserting variable lines.        */\n/*********************************************************************/\nlineStart = 4 ; lineEnd = 68\nlineLen = lineEnd - lineStart\n\n/*********************************************************************/\n/* Prime the script stem with the template lines.                    */\n/*********************************************************************/\nDo sl = sl+1 to sourceline()-1\n  line = '/* ' /* Reset line prefix */\n  tmp = output.0 + 1\n\n  If Pos(\"Created by\",sourceline(sl)) /= 0 Then Do\n    line = line'Created by    :' Userid() 'using the' execName 'exec'\n    line = Left(line,lineEnd,\" \") '*/'\n    output.tmp = line\n  End\n  Else If Pos(\"Creation date\",sourceline(sl)) /= 0 Then Do\n    line = line'Creation date :' Date() Time()\n    line = Left(line,lineEnd,\" \") '*/'\n    output.tmp = line\n  End\n  Else Do\n    output.tmp = Substr(sourceline(sl),1,71)\n  End\n\n  output.0 = tmp\nEnd\n\n/*********************************************************************/\n/* Process keywords by putting as many as will cleanly fit in a      */\n/* given line.  Write each line to the stem as they fill up.         */\n/*********************************************************************/\nline = '/* '   /* Reset line prefix */\nDo kNum = 1 to Words(saveKwds)\n  token = Strip(Word(saveKwds,kNum),Both,\" \")\n  /*******************************************************************/\n  /* If the keyword fits, append it to the current line.  Else,      */\n  /* write the line to the stem, and prime a new line for the next   */\n  /* keyword iteration.                                              */\n  /*******************************************************************/\n  If Length(token) <= lineEnd-Length(line) Then Do\n    line = line token\n  End\n  Else Do\n    line = Left(line,lineEnd,\" \") '*/'\n    tmp = output.0 + 1\n    output.tmp = line\n    output.0 = tmp\n    line = '/* '  /* Reset for next line */\n  End\nEnd\n/*********************************************************************/\n/* Put remaining keywords in a final stem entry.                     */\n/*********************************************************************/\nIf Length(line) > 0 Then Do  /* Write remainder */\n  line = Left(line,lineEnd,\" \") '*/'\n  tmp = output.0 + 1\n  output.tmp = line\n  output.0 = tmp\nEnd\n\n/*********************************************************************/\n/* Add block comment closing two lines                               */\n/*********************************************************************/\nDo sl = Sourceline()-1 to Sourceline()\n  tmp = output.0 + 1\n  output.tmp = Substr(sourceline(sl),1,71)\n  output.0 = tmp                          /* Increment num of lines  */\nEnd                                       /* For each template line  */\n\nReturn  /* buildOutputHeader */\n\n/* ----------------------------------------------------------------- */\n\nwriteOutputFile:\n/*********************************************************************/\n/* function: writeOutputFile                                         */\n/*                                                                   */\n/* input: The following global variables:                            */\n/*        - outputFile: Name of file, path, or data set into which   */\n/*                      to write the output                          */\n/*        - output.   : The stem variable containing the lines to    */\n/*                      write to the output file                     */\n/*                                                                   */\n/* output: The output is written                                     */\n/*                                                                   */\n/* returns: 1 - output successfully created                          */\n/*          0 - output not successfully created                      */\n/*                                                                   */\n/* Notes:  A data set starts with \"//\" by convention                 */\n/*                                                                   */\n/*********************************************************************/\nfileCreated = 1\n\n/*********************************************************************/\n/* Put \"exit 0\" at the end of the script to avoid exit status 255    */\n/* when executing the script with OSHELL.                            */\n/*********************************************************************/\ntmp = output.0 + 1\noutput.tmp = \"exit 0\"\noutput.0 = tmp\n\n/*********************************************************************/\n/* Write the output stem to the output UNIX file.                    */\n/*********************************************************************/\nIf Substr(outputFile,1,2) /= \"//\" Then Do  /* Unix file/path         */\n  'writefile (outputFile) 700 output.'\n  If retval = -1 Then Do\n    fileCreated = 0\n    say 'writefile error:' retval errno errnojr 'attempting to create',\n        outputFile 'output file.'\n    If noRun = 0 Then\n      say 'No changes were made.'\n  End\nEnd\n/*********************************************************************/\n/* Write the output stem to the output data set.                     */\n/*********************************************************************/\nElse Do\n  dsName = Substr(outputFile,3) /* Name starts after \"//\" */\n  address TSO                           /* Establish TSO environment */\n  \"ALLOC DA(\"dsName\") F(myoutdd) SHR REUSE\"\n  If rc /= 0 Then Do\n    say 'Error' rc 'allocating output data set' dsName'.'\n    fileCreated = 0\n  End\n  Else Do\n    \"EXECIO 0 DISKW myoutdd (OPEN\"\n    If rc /= 0 Then Do\n      say 'Error' rc 'opening output data set' dsName'.'\n      fileCreated = 0\n    End\n    Else Do\n      \"EXECIO * DISKW myoutdd (STEM output.\"\n      If rc /= 0 Then Do\n        say 'Error' rc 'writing to output data set' dsName'.'\n        fileCreated = 0\n      End\n      Else Do\n        \"EXECIO 0 DISKW myoutdd (FINIS\"\n        If rc /= 0 Then Do\n          say 'Error' rc 'closing output data set' dsName'.'\n          fileCreated = 0\n        End\n      End\n    End\n\n    \"FREE F(myoutdd)\"\n  End\n\n  address syscall    /* Restore syscall environment */\nEnd\n\nReturn fileCreated /* writeOutputFile */\n\n/* ----------------------------------------------------------------- */\n\n/*********************************************************************/\n/* ATTENTION!!!!!                                                    */\n/* The following label and lines are used in the construction of     */\n/* the output file and *MUST* remain at the very bottom              */\n/* of this exec!!!!                                                  */\n/*********************************************************************/\nTemplate:\n/* Rexx **************************************************************/\n/*                                                                   */\n/* Created by    :                                                   */\n/* Creation date :                                                   */\n/*                                                                   */\n/* This script contains the UNIX shell commands generated            */\n/* as a result of running the exec identified above with             */\n/* the following keywords:                                           */\n/*                                                                   */\n/*********************************************************************/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ORLIST": {"ttr": 901, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01$\\x003\\x01 \\x12\\x8f\\x01 \\x18?\\t\\x12\\x05\\xa6\\x05\\x9f\\x00\\x00\\xd9\\xc1\\xc3\\xc6\\xc1\\xc4\\xd4@@@'", "ispf": {"version": "01.36", "flags": 0, "createdate": "2020-05-07T00:00:00", "modifydate": "2020-07-01T09:12:33", "lines": 1446, "newlines": 1439, "modlines": 0, "user": "RACFADM"}, "text": "/*%NOCOMMENT====================* REXX *==============================*/\n/*     TYPE:  TSO Command                                             */\n/*  PURPOSE:  RACF Unix Security Information for a Dir/File (RLIST)   */\n/*--------------------------------------------------------------------*/\n/*    NOTES:  Obtained utility and documentation from:                */\n/*            ftp://public.dhe.ibm.com/s390/zos/racf/RacfUnixCommands */\n/*--------------------------------------------------------------------*/\n/* FLG  YYMMDD  USERID   DESCRIPTION                                  */\n/* ---  ------  -------  -------------------------------------------- */\n/* @A2  200701  RACFA    Updated doc, added dataset to OUTFILE()      */\n/* @A1  200605  RACFA    Changed 'Syntax...End-Syntax' comments       */\n/* @A0  200605  RACFA    Obtained REXX from IBM                       */\n/*====================================================================*/\n/**********************************************************************\n Licensed Materials - Property of IBM\n 5650-ZOS\n Copyright IBM Corp. 2020\n\n Name:    ORLIST\n\n Version: 2\n\n Author: Bruce Wells - brwells@us.ibm.com\n\n Purpose: Display security information for a Unix file or directory\n          using a syntax and output format similar to the RACF\n          RLIST command\n\n Input:   An absolute path name\n\n NOTE!!! This exec is dependent upon the following \"Syntax:\" line and\n         the \"End-Syntax\" line below in order to display the syntax\n         when the exec is invoked without keyword parameters.\n\n         Feel free to add/change examples to show things that are\n         frequently done in your orgnization. But please preserve\n         these surrounding lines.\n\n Beg-Syntax:\n Purpose:  Display security information for a Unix directory or\n           file using a syntax and output format similar to the\n           RACF RLIST command\n\n Syntax:   ORLIST absolute_path_name operands\n\n Operands: All keywords are optional\n             FSSEC                (positional)\n             absolute-path-name   (positional and required)\n             AUTH\n             DEBUG\n             NODISplay\n             OUTFILE(path-or-dataset-name)\n             RECursive(ALL | CURRENT | FILESYS)\n                             -------\n Examples:\n   1) Display all security information\n        ORLIST FSSEC /u/brwells/myfile\n\n   2) Display all security information omitting the optional class name\n        ORLIST /u/brwells/myfile\n\n   3) Display only the attributes used in a POSIX access decision\n        ORLIST /u/brwells/myfile AUTH\n\n   4) Write information for an entire directory to an output file\n      without diplaying it on the terminal\n        ORLIST /u/brwells/myfile RECURSIVE NODISPLAY\n\n End-Syntax\n\n**********************************************************************/\n/*******************************************************************/\n/*                                                                 */\n/* This program contains code made available by IBM Corporation    */\n/* on an AS IS basis. Any one receiving this program is            */\n/* considered to be licensed under IBM copyrights to use the       */\n/* IBM-provided source code in any way he or she deems fit,        */\n/* including copying it, compiling it, modifying it, and           */\n/* redistributing it, with or without modifications, except that   */\n/* it may be neither sold nor incorporated within a product that   */\n/* is sold.  No license under any IBM patents or patent            */\n/* applications is to be implied from this copyright license.      */\n/*                                                                 */\n/* The software is provided \"as-is\", and IBM disclaims all         */\n/* warranties, express or implied, including but not limited to    */\n/* implied warranties of merchantibility or fitness for a          */\n/* particular purpose.  IBM shall not be liable for any direct,    */\n/* indirect, incidental, special or consequential damages arising  */\n/* out of this agreement or the use or operation of the software.  */\n/*                                                                 */\n/* A user of this program should understand that IBM cannot        */\n/* provide technical support for the program and will not be       */\n/* responsible for any consequences of use of the program.         */\n/*                                                                 */\n/*******************************************************************/\nparse arg keywords                        /* Input keywords/values   */\nparse source . . execName .               /* Info about this exec    */\n\n/*********************************************************************/\n/* The following configuration variables affect the operation of     */\n/* this exec.                                                        */\n/*********************************************************************/\n/*********************************************************************/\n/* --------------   Start of Configuration Variables --------------- */\n/*********************************************************************/\n\n/*********************************************************************/\n/* doIrrxutil controls whether or not RACF's IRRXUTIL function is    */\n/* used to check for the existence of FSACCESS and FSEXEC profiles   */\n/* that cover the file system data set containing the object being   */\n/* listed. Change the value to 1 to get this extra information,      */\n/* after confirming that you have at least READ authority to         */\n/* IRR.RADMIN.RLIST in the FACILITY class.                           */\n/*********************************************************************/\ndoIrrxutil = 0\n\n/*********************************************************************/\n/* outputFile is the name of the file in which the generated         */\n/* output will be written.  By default, it is set to                 */\n/* <exec-name>.output, where exec-name is the name you have saved    */\n/* this exec as (ORLIST by default).                                 */\n/*                                                                   */\n/* You can change this to any path name you want, relative or        */\n/* absolute.                                                         */\n/*                                                                   */\n/* You can also specify a pre-allocated, cataloged data set.  It     */\n/* can be a sequential data set or a PDS member. To specify a data   */\n/* set use the shell convention for a data set, which is to start    */\n/* it with \"//\" and enclose it within single quotes. For example:    */\n/*  outputFile = \"//'HLQ.SEQUENTL.DATASET'\"                          */\n/*   or                                                              */\n/*  outputFile = \"//'HLQ.PDS(MEMBER)'\"                               */\n/*********************************************************************/\noutputFile = execname\".output\"\n\n/*********************************************************************/\n/* --------------   End of Configuration Variables ----------------- */\n/*********************************************************************/\n\n/*********************************************************************/\n/* Define/initialize command keyword names and values.               */\n/*********************************************************************/\nAUTHkwd        = \"AUTH\"          ; authVal        = 0\nDEBUGkwd       = \"DEBUG\"         ; debugVal       = 0\nNODISPLAYkwd   = \"NODISPLAY\"     ; noDisplayVal   = 0\nNODISabbr      = 5          /* NODIS is shortest allowed abbrev.     */\nRECURSIVEkwd   = \"RECURSIVE\"     ; recursiveVal   = ''\nRECabbr        = 3          /* REC is shortest allowed abbreviation  */\nOUTFILEkwd     = \"OUTFILE\"       ; outfileVal     = ''\nOUTabbr      = 3            /* OUT is shortest allowed abbreviation  */\n\n/*********************************************************************/\n/* -----------------   Start of Mainline     ----------------------- */\n/*********************************************************************/\n\ncall syscalls('ON')  /* Initialize UNIX environment */\naddress syscall\n\noutput. = ''                     /* Initialize stem for output lines */\noutput.0 = 0\n\n/*********************************************************************/\n/* Display syntax if no arguments are supplied.                      */\n/*********************************************************************/\nIf Length(keywords) = 0 Then Do\n  Display = \"no\"\n  If sourceline() > 0 Then Do\n    Do i = 1 to sourceline()\n     If Word(sourceline(i),1) = \"Beg-Syntax:\" Then do         /* @A1 */\n       Display = \"yes\"\n       iterate                                                /* @A1 */\n     end                                                      /* @A1 */\n     If Word(sourceline(i),1) = \"End-Syntax\" Then\n       Leave\n     If Display = \"yes\" Then\n       say Substr(sourceline(i),1,72)\n    End\n  End\n  Signal GETOUT\nEnd\n\n/*********************************************************************/\n/* Inspect the first positional argument.  If it is 'FSSEC', we      */\n/* remove it from the command image and ignore it.  We tolerate      */\n/* this in case the user wants ORLIST to look just like the RLIST    */\n/* command, in which the 1st positional keyword is the class name.   */\n/*********************************************************************/\ntemp = Word(keywords,1)          /* Get 1st keyword                  */\nUpper temp\nIf temp = 'FSSEC' Then\n  keywords = Subword(keywords,2) /* Remove class from keyword string */\n\n/*********************************************************************/\n/* Get positional path name argument.                                */\n/*********************************************************************/\npath = Word(keywords,1)          /* 1st keyword is the path name     */\n\n/*********************************************************************/\n/* Obtain information on passed path name.                           */\n/*********************************************************************/\n\"stat (path) stat.\"\n\n/* Check for success.                                               */\nIf retval = -1 then Do\n Select /* errno */\n  When errno = ENOENT Then\n    say \"The specified path does not exist.\"\n  When errno = EACCES Then Do\n    Say \"You are not authorized to reach\" path\".\"\n\n    /*****************************************************************/\n    /* Now, for extra credit, we will check for search access to     */\n    /* the directory components of the path name, since that is a    */\n    /* common cause of error, and display the first such directory   */\n    /* to which the user is not authorized. (There is no sense in    */\n    /* continuing beyond that point because they will all yield a    */\n    /* failure even if search access is present.)                    */\n    /*****************************************************************/\n    checkpath = ''      /* The path to check */\n    workpath = path     /* A working copy of the input path */\n    Do Forever\n      idx = Pos('/',workpath)\n      If idx = 0 Then    /* no more slashes means we are finished    */\n        leave\n      checkpath = checkpath || Substr(workpath,1,idx)\n      workpath = Substr(workpath,idx+1) /* Lop off head */\n\n      \"access (checkpath)\" X_OK\n\n      if retval = -1 then do\n        say \"You do not have search access to\" checkpath\n        Leave\n      End\n    End\n  End    /* EACCES */\n  Otherwise Do\n    say \"Error locating target object.\",\n        \" Stat() retval =\" retval \"errno =\" ,\n         errno \"errnojr =\" errnojr\n  End\n End     /* Select errno*/\n Signal GETOUT\nEnd /* retval = -1 */\n\n/*********************************************************************/\n/* Remove path from keyword string for subsequent processing.        */\n/*********************************************************************/\nkeywords = Subword(keywords,2)  /* Remove path from keyword string   */\n\n/*********************************************************************/\n/* Parse the keywords and values from the keyword string.            */\n/*********************************************************************/\nexecRc = 0\nexecRc = parseKeywords()\nIf execRc /= 0 Then\n  Signal GETOUT\n\n/*********************************************************************/\n/* If OUTFILE was specified, override the value of the outputFile    */\n/* configuration variable.                                           */\n/*********************************************************************/\nIf outfileVal /= '' Then\n  outputFile = outfileVal\n\n/*********************************************************************/\n/* Build output file header.                                         */\n/*********************************************************************/\nCall buildOutputHeader\nCall sey ' '\n\n/*********************************************************************/\n/* Pre-process RECURSIVE keyword.                                    */\n/*                                                                   */\n/* This is only valid when the target object is a directory.         */\n/*                                                                   */\n/* We obtain a list of sub-objects. This will contain the target     */\n/* itself.                                                           */\n/*                                                                   */\n/* We obtain the lists now so that they can be placed in the         */\n/* output file prior to generating the command output. This          */\n/* allows for an up-front list of the objects that are displayed,    */\n/* in the order in which they are subsequently displayed.            */\n/*                                                                   */\n/*********************************************************************/\n@stem = filelist.\nIf recursiveVal /= '' Then Do\n  call readdirproc path,@stem,recursiveVal\n\n  /*******************************************************************/\n  /* If debug is on, display the lists directly (don't write them    */\n  /* to the output stem), and exit without performing normal         */\n  /* listing operations.                                             */\n  /*******************************************************************/\n  If debugVal > 0 Then Do\n    say 'Directories:' dirlist.0\n    Do i = 1 to dirlist.0\n      say dirlist.i\n    End\n\n    say ''\n\n    say 'Files:' filelist.0\n    Do i = 1 to filelist.0\n      say filelist.i\n    End\n    Signal GETOUT\n  End\n  /*******************************************************************/\n  /* If debug is not specified, use the 'sey' procedure to write     */\n  /* both to the display and to the output file. Then let the        */\n  /* ORLIST command proceed as normal.                               */\n  /*******************************************************************/\n  Else Do\n    Call sey 'Directories:' dirlist.0\n    Do i = 1 to dirlist.0\n      Call sey dirlist.i\n    End\n\n    Call sey ' '\n\n    Call sey 'Files:' filelist.0\n    Do i = 1 to filelist.0\n      Call sey filelist.i\n    End\n    Call sey ' '\n  End\nEnd\n\n/*********************************************************************/\n/* Display the specified object if RECURSIVE not specified.          */\n/*********************************************************************/\nIf recursiveVal = '' Then Do\n  execRc = ProcessOutput(path)\n  If execRc /= 0 Then\n    Signal GETOUT\nEnd\n\n/*********************************************************************/\n/* Process RECURSIVE keyword.                                        */\n/*                                                                   */\n/* This is only valid when the target object is a directory.         */\n/*                                                                   */\n/* Process the list of sub-objects already gathered above. This      */\n/* will contain the target itself.                                   */\n/*                                                                   */\n/*********************************************************************/\nIf recursiveVal /= '' Then Do\n  /*******************************************************************/\n  /* Process directories.                                            */\n  /*******************************************************************/\n  Do objs = 1 to dirlist.0\n    Call sey ' '\n    sep =,\n'!-------------------------- Next Directory -------------------------!'\n    Call sey sep\n    Call sey ' '\n    execRc = processOutput(dirlist.objs)\n    If execRc /= 0 Then\n      Signal GETOUT\n  End\n\n  /*******************************************************************/\n  /* Process files.                                                  */\n  /*******************************************************************/\n  Do objs = 1 to filelist.0\n    Call sey ' '\n    sep =,\n'!---------------------------- Next File ----------------------------!'\n    Call sey sep\n    Call sey ' '\n    execRc = processOutput(filelist.objs)\n    If execRc /= 0 Then\n      Signal GETOUT\n  End\nEnd\n\n\nGETOUT:\n\n/*********************************************************************/\n/* Write the output stem to the output file.                         */\n/*********************************************************************/\nIf output.0 > 0 Then\n  scriptOK = writeOutputFile()\n\nExit\n\n/*********************************************************************/\n/* -----------------     End of Mainline     ----------------------- */\n/*********************************************************************/\n\n\nprocessOutput:\n/*********************************************************************/\n/* procedure: processOutput                                          */\n/*                                                                   */\n/* input:  - The path name to display                                */\n/*                                                                   */\n/* output: - Returns a return code                                   */\n/*                                                                   */\n/* Notes:  - This is essentially just a continuation of mainline     */\n/*           processing, put into a subroutine so that it can be     */\n/*           called iteratively for sub-objects by the RECURSIVE     */\n/*           keyword.                                                */\n/*                                                                   */\n/*********************************************************************/\nparse arg rpath\n\npoRc = 0  /* Return value */\n\n/*********************************************************************/\n/* Obtain information on passed path name.                           */\n/*                                                                   */\n/* Note we only expect the possibility of 'not-found' when called    */\n/* for the path specified on the command.  For the RECURSIVE         */\n/* option, the subobjects have already been located.                 */\n/*                                                                   */\n/*********************************************************************/\n\"stat (rpath) rstat.\"\nIf retval < 0 Then Do\n  If errno = ENOENT Then\n    say \"Target object does not exist:\" rpath\n  Else If errno = EACCES Then\n    say 'Not authorized to read' rpath'.'\n  Else\n    say \"Error locating\" rpath\". Retval =\" retval \"errno =\" ,\n         errno \"errnojr =\" errnojr\n  pkRc = 8\n  Signal kwdExit\nEnd\n\n/*********************************************************************/\n/* Echo the 'class' and path name, as RLIST does for profiles.       */\n/*********************************************************************/\nCall sey \"CLASS      NAME\"\nCall sey \"-----      ----\"\nmsg = Left('FSSEC',10) rpath\nCall sey msg\nCall sey \" \"\n\nIf authVal = 0 Then Do           /* Display if AUTH not specified    */\n  /*******************************************************************/\n  /* We have file information.  Now get mount entry information      */\n  /* by calling getmntent with the device number just returned by    */\n  /* stat().                                                         */\n  /*******************************************************************/\n  \"getmntent mnt.\" x2d(rstat.ST_DEV)\n  Call sey \"FILE SYSTEM CONTAINER ATTRIBUTES\"\n  Call sey \"--------------------------------\"\n  fsn = Strip(mnt.MNTE_FSNAME.1)\n  Call sey Left(\"NAME =\" fsn,44) \"TYPE =\" mnt.MNTE_FSTYPE.1\n  Call sey \"MOUNT POINT =\" mnt.MNTE_PATH.1\n\n  /*******************************************************************/\n  /* Display various mount mode options.                             */\n  /* I haven't tested nosecurity/setuid    TBD                       */\n  /*******************************************************************/\n  mntmode = d2x(mnt.MNTE_MODE.1,8)\n  mntmode=substr(mntmode,8)\n\n  nosecurity = 0\n  mode = \"\"\n  modebit = bitand(mntmode,'01'x)='01'x\n  If modebit = 1 then\n    mode = mode || \"READ-ONLY \"\n  Else\n    mode = mode || \"READ/WRITE \"\n\n  modebit = bitand(mntmode,'08'x)='08'x\n  If modebit = 1 then Do\n    mode = mode || \"NOSECURITY \"\n    nosecurity = 1\n  End\n\n  modebit = bitand(mntmode,'02'x)='02'x\n  If modebit = 1 then\n    mode = mode || \"NOSETUID \"\n\n  Call sey \"Mount mode =\" mode\n\n  /*******************************************************************/\n  /* Obtain the devno of the root directory for use in the           */\n  /* FSACCESS processing below.  Since we have already passed the    */\n  /* checking on the stat for the specified path, we assume it       */\n  /* will work for the root.                                         */\n  /*******************************************************************/\n  \"stat / rstem.\"\n\n  /*******************************************************************/\n  /* Indicate if containing file system is covered by an FSACCESS    */\n  /* profile.                                                        */\n  /* - FSACCESS is supported only for zFS                            */\n  /*   - but not for the root or when mounted with NOSECURITY        */\n  /*******************************************************************/\n  If doIrrxutil = 1                             &,\n     mnt.MNTE_FSTYPE.1 = 'ZFS' & nosecurity = 0 &,\n     rstat.ST_DEV /= rstem.ST_DEV Then Do\n    myrc = IRRXUTIL(\"EXTRACT\",\"FSACCESS\",fsn,\"RES\",,\"TRUE\")\n    Select\n      When myrc = \"0 0 0 0 0\" Then\n        Call sey \"Covered in FSACCESS class by\" RES.PROFILE\n      When myrc = \"12 12 4 4 4\" Then\n        Call sey \"Not protected by an FSACCESS class profile\"\n      When myrc = \"12 12 4 4 16\" Then\n        Call sey \"Not protected by an FSACCESS class profile\"\n      When myrc = \"12 12 8 8 24\" Then\n        Call sey \"Unable to report on FSACCESS coverage due to lack\",\n                 \"of R_admin authorization\"\n      Otherwise\n        Call sey \"Unable to report on FSACCESS coverage due to\",\n                 \"IRRXUTIL error\" myrc\n    End /* Select */\n  End\n\n  /*******************************************************************/\n  /* Indicate if containing file system is covered by an FSEXEC      */\n  /* profile.                                                        */\n  /* - FSEXEC is supported only for zFS and TFS                      */\n  /*******************************************************************/\n  /* We cannot tell for sure if a file is an executable, but we will */\n  /* only make the check for a regular file with at least one        */\n  /* execute bit on (ignoring the acl).                              */\n  /*******************************************************************/\n  up = getperms(Substr(rstat.ST_MODE,1,1))\n  gp = getperms(Substr(rstat.ST_MODE,2,1))\n  op = getperms(Substr(rstat.ST_MODE,3,1))\n\n  If doIrrxutil = 1                           &,\n     (mnt.MNTE_FSTYPE.1 = 'ZFS' | mnt.MNTE_FSTYPE.1 = 'TFS') &,\n     nosecurity = 0 & rstat.ST_TYPE = S_ISREG &,\n     (Substr(up,3,1)='x' | Substr(gp,3,1)='x' | Substr(op,3,1)='x'),\n  Then Do\n    myrc = IRRXUTIL(\"EXTRACT\",\"FSEXEC\",fsn,\"RES\",,\"TRUE\")\n    Select\n      When myrc = \"0 0 0 0 0\" Then\n        Call sey \"Covered in FSEXEC class by\" RES.PROFILE\n      When myrc = \"12 12 4 4 4\" Then\n        Call sey \"Not protected by an FSEXEC class profile\"\n      When myrc = \"12 12 4 4 16\" Then\n        Call sey \"Not protected by an FSEXEC class profile\"\n      When myrc = \"12 12 8 8 24\" Then\n        Call sey \"Unable to report on FSEXEC coverage due to lack\",\n                 \"of R_admin authorization\"\n      Otherwise\n        Call sey \"Unable to report on FSEXEC coverage due to\",\n                 \"IRRXUTIL error\" myrc\n    End /* Select */\n  End\n  Call sey \" \"\n\n  /*******************************************************************/\n  /* Display file information                                        */\n  /*******************************************************************/\n\n  /*******************************************************************/\n  /* Display file type                                               */\n  /*******************************************************************/\n  Call sey \"FILE TYPE\"\n  Call sey \"----------------------\"\n  Select\n    When rstat.ST_TYPE = S_ISREG Then\n      type = \"Regular file\"\n    When rstat.ST_TYPE = S_ISDIR Then\n      type = \"Directory\"\n    When rstat.ST_TYPE = S_ISCHR Then\n      type = \"Character special file\"\n    When rstat.ST_TYPE = S_ISFIFO Then\n      type = \"FIFO special file\"\n    /* Apparently, this will never return S_ISSYM because it will    */\n    /* follow the link instead. I'd have to incorporate lstat.       */\n    When rstat.ST_TYPE = S_ISSYM Then\n      type = \"Symbolic link\"\n    Otherwise\n      type = \"Unknown\"\n  End\n  Call sey type\n  Call sey \" \"\nEnd                              /* Don't display if AUTH specified  */\n\n  /*******************************************************************/\n  /* Map the returned UID to a user ID.  If that fails, we will      */\n  /* just display the UID.                                           */\n  /*******************************************************************/\n  \"getpwuid (rstat.ST_UID) pw.\"\n  If retval <= 0 Then\n    user = rstat.ST_UID\n  Else\n    user = pw.PW_NAME\n\n  /*******************************************************************/\n  /* Map the returned GID to a group.  If that fails, we will        */\n  /* just display the GID.                                           */\n  /*******************************************************************/\n  \"getgrgid (rstat.ST_GID) gr.\"\n  If retval <= 0 Then\n    group = rstat.ST_GID\n  Else\n    group = gr.GR_NAME\n\n  /*******************************************************************/\n  /* Display owning user and group, the 'other' bits as UACC, and    */\n  /* 'YOUR ACCESS'.                                                  */\n  /*******************************************************************/\n  op = getperms(Substr(rstat.ST_MODE,3,1)) /* Get 'other' bits       */\n\n  \"access (rpath)\" R_OK\n  If retval = -1 Then\n    uacc = \"-\"\n  Else\n    uacc = \"r\"\n  \"access (rpath)\" W_OK\n  If retval = -1 Then\n    uacc = uacc||\"-\"\n  Else\n    uacc = uacc||\"w\"\n  \"access (rpath)\" X_OK\n  If retval = -1 Then\n    uacc = uacc||\"-\"\n  Else\n    uacc = uacc||\"x\"\n\n  Call sey \"OWNER        GROUP OWNER  UNIVERSAL ACCESS  YOUR ACCESS\"\n  Call sey \"----------   -----------  ----------------  -----------\"\n  Call sey Left(user,12) Left(group,12) Left(op,17) uacc\n  Call sey \" \"\n\nIf authVal = 0 Then Do           /* Display if AUTH not specified    */\n  /*******************************************************************/\n  /* Display the security label                                      */\n  /*******************************************************************/\n  Call sey \"SECLABEL\"\n  Call sey \"--------\"\n  If Length(rstat.ST_SECLABEL) = 0 Then\n    secl = \"NO SECLABEL\"\n  Else\n    secl = rstat.ST_SECLABEL\n  Call sey secl\n  Call sey \" \"\n\n  /*******************************************************************/\n  /* Display owner audit options                                     */\n  /*******************************************************************/\n  Call sey \"AUDITING\"\n  Call sey \"--------\"\n  ra = Substr(d2x(rstat.ST_UAUDIT,8),1,2)\n  Select\n    When ra = 0 Then\n      rat = \"NONE(READ)\"\n    When ra = 1 Then\n      rat = \"SUCCESSES(READ)\"\n    When ra = 2 Then\n      rat = \"FAILURES(READ)\"\n    When ra = 3 Then\n      rat = \"ALL(READ)\"\n    Otherwise\n  End\n  wa = Substr(d2x(rstat.ST_UAUDIT,8),3,2)\n  Select\n    When wa = 0 Then\n      wat = \"NONE(UPDATE)\"\n    When wa = 1 Then\n      wat = \"SUCCESSES(UPDATE)\"\n    When wa = 2 Then\n      wat = \"FAILURES(UPDATE)\"\n    When wa = 3 Then\n      wat = \"ALL(UPDATE)\"\n    Otherwise\n  End\n  xa = Substr(d2x(rstat.ST_UAUDIT,8),5,2)\n  Select\n    When xa = 0 Then\n      xat = \"NONE(EXECUTE)\"\n    When xa = 1 Then\n      xat = \"SUCCESSES(EXECUTE)\"\n    When xa = 2 Then\n      xat = \"FAILURES(EXECUTE)\"\n    When xa = 3 Then\n      xat = \"ALL(EXECUTE)\"\n    Otherwise\n  End\n  Call sey rat\",\"wat\",\"xat\n  Call sey \" \"\n\n  /*******************************************************************/\n  /* Display auditor audit options.                                  */\n  /*                                                                 */\n  /* Note that the 'ls -W' shell command does not suppress the       */\n  /* AUDITOR audit options for non-RO/AUDITOR users, as the RACF     */\n  /* RLIST command does for the corresponding GLOBALAUDIT field.     */\n  /* Thus, we do not suppress them here, either. We *could* with     */\n  /* a simple IRRXUTIL call (or storage reference to the ACEE) to    */\n  /* determine the issuer's status.  Feel free to try it, or         */\n  /* submit a requirement to the author via the racf-l mailing       */\n  /* list.                                                           */\n  /*******************************************************************/\n\n  Call sey \"GLOBALAUDIT\"\n  Call sey \"-----------\"\n  ra = Substr(d2x(rstat.ST_AAUDIT,8),1,2)\n  Select\n    When ra = 0 Then\n      rat = \"NONE(READ)\"\n    When ra = 1 Then\n      rat = \"SUCCESSES(READ)\"\n    When ra = 2 Then\n      rat = \"FAILURES(READ)\"\n    When ra = 3 Then\n      rat = \"ALL(READ)\"\n    Otherwise\n  End\n  wa = Substr(d2x(rstat.ST_AAUDIT,8),3,2)\n  Select\n    When wa = 0 Then\n      wat = \"NONE(UPDATE)\"\n    When wa = 1 Then\n      wat = \"SUCCESSES(UPDATE)\"\n    When wa = 2 Then\n      wat = \"FAILURES(UPDATE)\"\n    When wa = 3 Then\n      wat = \"ALL(UPDATE)\"\n    Otherwise\n  End\n  xa = Substr(d2x(rstat.ST_AAUDIT,8),5,2)\n  Select\n    When xa = 0 Then\n      xat = \"NONE(EXECUTE)\"\n    When xa = 1 Then\n      xat = \"SUCCESSES(EXECUTE)\"\n    When xa = 2 Then\n      xat = \"FAILURES(EXECUTE)\"\n    When xa = 3 Then\n      xat = \"ALL(EXECUTE)\"\n    Otherwise\n  End\n  Call sey rat\",\"wat\",\"xat\n  Call sey \" \"\n\n  /*******************************************************************/\n  /* Mimic the following RLIST output:                               */\n  /*                                                                 */\n  /* CREATION DATE  LAST REFERENCE DATE  LAST CHANGE DATE            */\n  /*  (DAY) (YEAR)       (DAY) (YEAR)      (DAY) (YEAR)              */\n  /* -------------  -------------------  ----------------            */\n  /*   133    19          133    19         133    19                */\n  /*                                                                 */\n  /* using:                                                          */\n  /* ST_CRTIME File creation time                                    */\n  /* ST_ATIME  Time of last access                                   */\n  /* ST_CTIME  Time of last file status change                       */\n  /*                                                                 */\n  /* Other time values available in stat():                          */\n  /* ST_MTIME Time of last data modification                         */\n  /* ST_RTIME File backup time stamp (reference time)                */\n  /*******************************************************************/\n  m = \"CREATION DATE  LAST REFERENCE DATE  LAST STATUS CHANGE DATE\"\n  Call sey m\n  m = \"-------------  -------------------  -----------------------\"\n  Call sey m\n  m = Left(gtime(rstat.ST_CRTIME),14),\n                      Left(gtime(rstat.ST_ATIME),20),\n                                         Left(gtime(rstat.ST_CTIME),15)\n  Call sey m\n  Call sey \" \"\n\n  /*******************************************************************/\n  /* Display extended attributes.  Only applicable to regular files. */\n  /*                                                                 */\n  /* See the BPXYSTAT macro for a layout of the Genvalue bits.       */\n  /*******************************************************************/\n\n  if rstat.ST_TYPE = S_ISREG Then Do\n    Call sey \"EXTENDED ATTRIBUTES\"\n    Call sey \"-------------------\"\n    genval=substr(rstat.ST_GENVALUE,4)\n\n    extattra= bitand(genval,'04'x)='04'x\n    If extattra = 1 then\n      Call sey \"APF authorized\"\n\n    extattrp= bitand(genval,'02'x)='02'x\n    If extattrp = 1 then\n      Call sey \"Program controlled\"\n\n    extattrs= bitand(genval,'08'x)='00'x /* reverse bit */\n    If extattrs = 1 then\n      Call sey \"SHAREAS\"\n\n    extattrl= bitand(genval,'10'x)='10'x\n    If extattrl = 1 then\n      Call sey \"Loaded from the shared library region\"\n    Call sey \" \"\n  end\n\n  /*******************************************************************/\n  /* Display the non-permission file mode bits.                      */\n  /*******************************************************************/\n  Call sey \"FILE MODE BITS\"\n  Call sey \"--------------\"\n  Call sey \"Sticky  bit is:\" rstat.ST_STICKY\n  Call sey \"Set-uid bit is:\" rstat.ST_SETUID\n  Call sey \"Set-gid bit is:\" rstat.ST_SETGID\n  Call sey \" \"\nEnd                              /* Don't display if AUTH specified  */\n\n  /*******************************************************************/\n  /* Display the permission bits always (AUTH specified or not)      */\n  /*******************************************************************/\n  Call sey \"FILE PERMISSIONS\"\n  Call sey \"----------------\"\n  Call sey \" \"\n  Call sey \" OWNER GROUP OTHER\"\n  Call sey \" ----- ----- -----\"\n  octalPerms = Substr(rstat.ST_MODE,1,1)Substr(rstat.ST_MODE,2,1)||,\n               Substr(rstat.ST_MODE,3,1)\n  up = getperms(Substr(rstat.ST_MODE,1,1))\n  gp = getperms(Substr(rstat.ST_MODE,2,1))\n  op = getperms(Substr(rstat.ST_MODE,3,1))\n  m = \" \"up\"   \"gp\"   \"op\"           (\"octalPerms \"in octal notation)\"\n  Call sey m\n  Call sey \" \"\n\n  /*******************************************************************/\n  /* Display the extended access control list (acl) if one exists.   */\n  /*******************************************************************/\n\n  If rstat.ST_ACCESSACL = 1 Then Do\n    call getacl(ACL_TYPE_ACCESS rpath)\n  End\n  Else\n    Call sey \"NO ACCESS LIST\"\n  Call sey \" \"\n\nIf authVal = 0 Then Do           /* Display if AUTH not specified    */\n  /*******************************************************************/\n  /* If the path name is a directory, look for model ACLs.           */\n  /*******************************************************************/\n  If rstat.ST_TYPE = S_ISDIR Then Do\n\n    /*****************************************************************/\n    /* Display the directory model acl if one exists.                */\n    /*****************************************************************/\n\n    If rstat.ST_DMODELACL = 1 Then Do\n      Call sey \"A directory model ACL exists:\"\n      Call sey \" \"\n      call getacl(ACL_TYPE_DIRDEFAULT rpath)\n    End\n    Else\n      Call sey \"There is no directory model acl.\"\n    Call sey \" \"\n\n    /*****************************************************************/\n    /* Display the file model acl if one exists.                     */\n    /*****************************************************************/\n\n    If rstat.ST_FMODELACL = 1 Then Do\n      Call sey \"A file model ACL exists:\"\n      Call sey \" \"\n      call getacl(ACL_TYPE_FILEDEFAULT rpath)\n    End\n    Else\n      Call sey \"There is no file model acl.\"\n\n  End  /* Path is a directory  */\nEnd                              /* Don't display if AUTH specified  */\n\nkwdExit:\nReturn poRc                      /* processOutput                    */\n\n/* ----------------------------------------------------------------- */\n\ngetacl:\n/*********************************************************************/\n/* function: getacl                                                  */\n/*                                                                   */\n/* input:  - The type of acl requested (access, file model, or       */\n/*           directory model)                                        */\n/*         - The path of the file/directory to process (Note: it     */\n/*           is important that this be the last argument, in case    */\n/*           the path contains a blank.)                             */\n/*                                                                   */\n/* returns:  Nothing. But displays the acl contents (or a message    */\n/*           indicating that an acl does not exist)                  */\n/*                                                                   */\n/* notes:                                                            */\n/* - Use the aclget syscall. I found an example in the USS Rexx pub. */\n/*                                                                   */\n/*********************************************************************/\n  parse arg acltype apath\n\n  call syscalls('ON')    /* Need to re-establish predefined vars     */\n    Call sey \"ID          TYPE   ACCESS\"\n    Call sey \"--          ----   ------\"\n    'aclinit acl'                   /* init variable ACL to hold acl */\n    'aclget acl (apath)' acltype        /* get the acl               */\n    Do i=1 by 1                         /* get each acl entry        */\n      'aclgetentry acl acl.' i\n      if rc < 0 | retval = -1 then\n        leave                           /* error, assume no more     */\n      parse value '- - -' with pr pw px\n      if acl.acl_read=1 then\n        pr='R'                          /* set rwx permissions       */\n      if acl.acl_write=1 then\n        pw='W'\n      if acl.acl_execute=1 then\n        px='X'\n      perms = pr||pw||px\n\n      aclid=acl.acl_id                  /* get uid or gid            */\n\n      /* determine acl entry type */\n      if acl.acl_entry_type=acl_entry_user then Do\n        type='USER'\n        \"getpwuid (aclid) pw.\"\n        If retval > 0 Then\n          aclid = pw.PW_NAME\n      End\n      else\n        if acl.acl_entry_type=acl_entry_group then Do\n          type='GROUP'\n          \"getgrgid (aclid) gr.\"\n          If retval > 0 Then\n            aclid = gr.GR_NAME\n        End\n        else\n          type =\"???\"\n\n      Call sey Left(aclid,11) Left(type,6) Left(perms,5)\n    End\n  'aclfree acl'                         /* must free acl buffer      */\nReturn                                  /* getacl                    */\n\n/* ----------------------------------------------------------------- */\n\ngetperms: procedure\n/*********************************************************************/\n/* function: getperms                                                */\n/*                                                                   */\n/* input:    an octal number represeting a set of permissions        */\n/*                                                                   */\n/* returns:  a string representing the permissions                   */\n/*                                                                   */\n/*           E.G. rwx, r-x, ---, etc                                 */\n/*                                                                   */\n/*********************************************************************/\n  arg octal\n  Select\n    When octal=7 Then\n      perms = 'rwx'\n    When octal=6 Then\n      perms = 'rw-'\n    When octal=5 Then\n      perms = 'r-x'\n    When octal=4 Then\n      perms = 'r--'\n    When octal=3 Then\n      perms = '-wx'\n    When octal=2 Then\n      perms = '-w-'\n    When octal=1 Then\n      perms = '--x'\n    When octal=0 Then\n      perms = '---'\n    Otherwise\n  End\nreturn perms\n\n/* ----------------------------------------------------------------- */\n\ngtime:\n/**********************************************************************/\n/* Name:    gtime                                                     */\n/* Purpose: get gm time from epoch time                               */\n/**********************************************************************/\n  arg tm\n  numeric digits 10\n  if tm=0 | datatype(tm,'W')<>1 then\n     return ''\n  if tm=-1 then return ''    /* @DHA */\n  numeric digits\n  \"gmtime (tm) tm.\"\n  if retval=-1 then return ''\n  return right(tm.tm_year,4,0)'-' ||,\n         right(tm.tm_mon,2,0)'-'right(tm.tm_mday,2,0)\n\n/* ----------------------------------------------------------------- */\n\nparseKeywords:\n/*********************************************************************/\n/* Examine input to identify keywords and values. We process the     */\n/* keyword string as a set of words.                                 */\n/*********************************************************************/\nparseRc = 0\nDo i = 1 to Words(keywords) Until Length(keywords)=0 /* Parse kwds   */\n\n  nextWord = Word(keywords,1)    /* Get next word                    */\n\n  /*******************************************************************/\n  /* Isolate the next keyword and its value.                         */\n  /*******************************************************************/\n  openParen = Pos(\"(\",nextWord)  /* Expect \"(\" to be part of word    */\n  closeParen = Pos(\")\",keywords) /* But must look for \")\" in the\n                                     entire cmd remainder            */\n\n  /*******************************************************************/\n  /* If there is no open paren in the word, then this is a keyword   */\n  /* without a value.                                                */\n  /*******************************************************************/\n  If openParen = 0 Then\n    Do\n      nextKwd = nextWord\n      nextVal = ''\n      endKwd = Length(nextWord)+1\n    End\n  /*******************************************************************/\n  /* If there is an open paren in the word, then this is a keyword   */\n  /* with a value.                                                   */\n  /*******************************************************************/\n  Else\n    Do\n      nextKwd = Substr(nextWord,1,openParen-1)\n      valLength = closeParen - openParen - 1\n      nextVal = Strip(Substr(keywords,openParen+1,valLength),Both,\" \")\n      endKwd = Pos(\")\",keywords)+1\n    End\n  Upper nextKwd\n\n  /*******************************************************************/\n  /* Uncomment the following to help debug command parsing.          */\n  /*******************************************************************/\n  /*\n  say \"Command image remainder is\" keywords\n  say \"Keyword is\" nextKwd\n  say \"Value is\" nextVal \"of length\" Length(nextVal)\n  /* The following will be not quite accurate for \"))\" keywords.     */\n  say \"First position after current keyword/value is\" endKwd\n  say ''\n  */\n\n  /*******************************************************************/\n  /* Set the value for each specified keyword.                       */\n  /*******************************************************************/\n  Select                        /* Identify keyword                  */\n    /*****************************************************************/\n    /* For the OUTFILE keyword, some additional processing is        */\n    /* required to support a PDS member, due to the additional       */\n    /* parentheses. We must look for an additional closing paren     */\n    /* and redo the keyword-with-value code above to isolate the     */\n    /* value.                                                        */\n    /*                                                               */\n    /* Note that, when OUTFILE is not specified, we make no effort   */\n    /* to validate the value of the outputFile configuration value.  */\n    /* We just let it rip and let the file I/O fail at the end.      */\n    /* But this parsing forces our hand a bit. We assume the value   */\n    /* is specified correctly, but do just enough checking to avoid  */\n    /* a REXX error. If something is unexpected, we let the value    */\n    /* stand as parsed above and send it downstream for failure.     */\n    /*****************************************************************/\n    When Abbrev(OUTFILEkwd,nextKwd,OUTabbr) = 1 Then\n      Do\n        outfileVal = nextVal                /* Save output var       */\n\n        If Substr(outfileVal,1,2) = \"//\" &, /* If data set path      */\n           Pos(\"(\",nextval) > 0 Then Do     /* contains open paren   */\n\n          /* Find next closing paren, which should be true close     */\n          closeParen = closeParen +,\n                       Pos(\")\",Substr(keywords,closeParen+1))\n\n          /* Redo parse code to get correct parsing values           */\n          If closeParen > 0 Then Do         /* If \")\" found          */\n            valLength = closeParen - openParen - 1\n            nextVal = Strip(,\n                       Substr(keywords,openParen+1,valLength),Both,\" \")\n            endKwd = closeParen + 1\n            outfileVal = nextVal            /* Reload output var     */\n          End\n        End\n      End\n    /*****************************************************************/\n    /* If the RECURSIVE keyword is specified without a value, then   */\n    /* we use the default of CURRENT.                                */\n    /*****************************************************************/\n    When Abbrev(RECURSIVEkwd,nextKwd,RECabbr) = 1 Then\n      Do\n        If stat.ST_TYPE /= S_ISDIR Then Do\n          say 'RECURSIVE can only be specified for a directory.'\n          parseRc = 4\n        End\n        Else Do\n          If nextVal = '' Then Do\n            recursiveVal = 'CURRENT'\n          End\n          Else Do\n            Upper nextVal\n            recursiveVal = nextVal\n            If recursiveVal /= 'CURRENT' &,\n               recursiveVal /= 'FILESYS' &,\n               recursiveVal /= 'ALL' Then Do\n              say 'Invalid value specified for RECURSIVE keyword.'\n              say 'Use one of CURRENT, FILESYS, or ALL, or omit',\n                  'parentheses and value for the default of CURRENT'\n              parseRc = 4\n            End\n          End\n        End\n      End\n    When nextKwd = DEBUGkwd Then\n      Do\n        debugVal = 1\n      End\n    When nextKwd = AUTHkwd Then\n      Do\n        authVal = 1\n      End\n    When Abbrev(NODISPLAYkwd,nextKwd,NODISabbr) = 1 Then\n      Do\n        noDisplayVal = 1\n      End\n    Otherwise\n      If Length(nextKwd) /= 0 Then Do\n        say \"Invalid keyword:\" nextKwd\n        parseRc = 4\n      End\n  End                           /* Identify keyword                  */\n\n  /*******************************************************************/\n  /* Make sure the next keyword is blank-separated from current.     */\n  /*******************************************************************/\n  if Substr(keywords,endKwd,1) <> \" \" Then Do\n    say \"Missing blank after\" nextKwd \"keyword.\"\n    Exit 4\n  End\n\n  /*******************************************************************/\n  /* Remove this keyword from the input string, for the next         */\n  /* iteration.                                                      */\n  /*******************************************************************/\n  keywords = Substr(keywords,endKwd)     /* Remove processed keyword */\n  keywords = Strip(keywords,Leading,\" \")\n\nEnd                             /* Parse keywords loop               */\n\nReturn parseRc                  /* parseKeywords                     */\n\n/* ----------------------------------------------------------------- */\n\nsey:\n/*********************************************************************/\n/* Name:    sey                                                      */\n/*                                                                   */\n/* Purpose: Display or save output line                              */\n/*                                                                   */\n/* Input:   - line to be processed                                   */\n/*                                                                   */\n/* Output:  - global veriable output. updated                        */\n/*                                                                   */\n/*********************************************************************/\n  parse arg msg\n\n  /*******************************************************************/\n  /* Display output line unless display is being suppressed.         */\n  /*******************************************************************/\n  If NoDisplayVal = 0 Then\n    say msg\n\n  /*******************************************************************/\n  /* Add output line to the output stem.                             */\n  /*******************************************************************/\n  tmp = output.0 + 1\n  output.tmp = msg\n  output.0 = tmp\n\nReturn    /* sey */\n\n/* ----------------------------------------------------------------- */\n\nreaddirproc: procedure expose (syscall_constants) (@stem) dirlist. ,\n                                                          debugVal\n/*********************************************************************/\n/* Return list of subobjects of a directory                          */\n/*                                                                   */\n/* Input:                                                            */\n/*      - The path name of the user-specified directory              */\n/*      - The name of a stem to contain the list of subordinate      */\n/*        files.                                                     */\n/*      - A value indicating the scope of the operation:             */\n/*        - CURRENT - apply changes to objects within the specified  */\n/*          directory                                                */\n/*        - FILESYS - apply changes to objects within the containing */\n/*          zFS data set (i.e. mount points are not crossed)         */\n/*        - ALL - apply changes all the way down the mounted file    */\n/*          system structure, in and below the specified directory.  */\n/*                                                                   */\n/* Output:                                                           */\n/*      - The input stem is filled with the list of files            */\n/*      - the hard-coded 'dirlist.' stem contains a list of          */\n/*        subdirectories.                                            */\n/*                                                                   */\n/*********************************************************************/\n  parse arg path,stem,scope\n\n  /*******************************************************************/\n  /* Obtain the devno ('device number') of the file system in which  */\n  /* the input directory path exists. Comparing this to the devno    */\n  /* of sub-objects helps to determine when we have crossed a mount  */\n  /* point into a different zFS data set.                            */\n  /*******************************************************************/\n  at.=''\n  address syscall 'lstat (path) at.'\n  devno=at.st_dev\n\n  /*******************************************************************/\n  /* Initialize the directory stem and count, and the file count.    */\n  /*******************************************************************/\n  call value @stem,''\n  dirlist.=''\n  dirlist.1=path\n  dirlist=1\n  dirs=1\n  files=0\n\n  /*******************************************************************/\n  /* Loop on all directories. Initially, this only contains the      */\n  /* input directory, but in each iteration, the contents of the     */\n  /* directory will be read, and subdirectories will be placed       */\n  /* into the dirlist stem. Thus, subsequent iterations will         */\n  /* operate on these subdirectories as the list is built up.        */\n  /*******************************************************************/\n  Do dirx=1 By 1 While length(dirlist.dirx)>0\n    address syscall 'readdir (dirlist.dirx) names. attrs.'\n    If retval=-1 Then Leave\n    /*****************************************************************/\n    /* Loop on the contents of the directory being processed         */\n    /* in this iteration of the outer loop.                          */\n    /*****************************************************************/\n    Do d=1 to names.0\n      /***************************************************************/\n      /* Skip the special directories of \".\" and \"..\"                */\n      /***************************************************************/\n      If substr(names.d,1,1)='.' & attrs.d.st_type=s_isdir Then\n        iterate\n      /***************************************************************/\n      /* Add files to the input stem as absolute path names.         */\n      /***************************************************************/\n      If attrs.d.st_type=s_isreg Then\n        Do\n          files=files+1\n          call value stem||files,dirlist.dirx'/'names.d\n\n          Do i=1 to attrs.d.0\n            call value stem||files'.!attrs.'i,attrs.d.i\n          End\n        End\n      /***************************************************************/\n      /* Add directories to the dirlist stem as absolute path        */\n      /* names, excluding mount point directories if FILESYS         */\n      /* is specified.                                               */\n      /***************************************************************/\n      Else If attrs.d.st_type=s_isdir Then\n        Do\n          If (scope = 'CURRENT') |,\n             (scope = 'ALL')     |,\n             (scope = 'FILESYS' & attrs.d.st_dev=devno) Then Do\n            dirs = dirs + 1\n            dirlist = dirlist+1\n            dirlist.dirlist=dirlist.dirx'/'names.d\n          End\n          Else If attrs.d.st_dev/=devno & debugVal = 1 Then Do\n            say 'Excluding' dirlist.dirx'/'names.d,\n                'of type' attrs.d.st_type 'due to different devno'\n          End\n        End\n      Else\n        Do\n          If debugVal = 1 Then Do\n            say 'Excluding' dirlist.dirx'/'names.d,\n                'of type' attrs.d.st_type\n          End\n        End\n    End\n    /*****************************************************************/\n    /* If CURRENT is specified, we leave the outer loop after        */\n    /* having processed only the first directory (i.e. the one       */\n    /* specified by the user).                                       */\n    /*****************************************************************/\n    If scope = 'CURRENT' Then\n      Leave\n  End\n  /*******************************************************************/\n  /* Set the file count into the input file stem.                    */\n  /*******************************************************************/\n  call value stem'0',files\n  /*******************************************************************/\n  /* Set the directory count into the hard-coded directory stem.     */\n  /*******************************************************************/\n  dirlist.0=dirs\nreturn /* readdirproc */\n\n/* ----------------------------------------------------------------- */\n\nbuildOutputHeader:\n/*********************************************************************/\n/* procedure: buildOutputHeader                                      */\n/*                                                                   */\n/* output: The following global variables are modified               */\n/*         - output. stem is primed with the heading defined         */\n/*           at the bottom of this file, and filled in with the      */\n/*           header information.                                     */\n/*                                                                   */\n/*********************************************************************/\nlineEnd = 68\n/*********************************************************************/\n/* Find start of template at the bottom of this file.                */\n/*********************************************************************/\nDo sl = sourceline() to 1 by -1 Until sourceline(sl) = 'Template:'\nEnd\n/*********************************************************************/\n/* Prime the script stem with the template lines.                    */\n/*********************************************************************/\nDo sl = sl+1 to sourceline()              /* For each template line  */\n  tmp = output.0 + 1\n\n  /* Replace date/time placeholder with script and date/time         */\n  If Pos(\"DATE/TIME\",sourceline(sl)) > 0 Then Do /* Fill in datetime */\n    line = '/* Created on' Date() Time() 'by the' execName 'exec.'\n    line = Left(line,lineEnd,\" \") '*/'\n    output.tmp = line\n  End                                            /* Fill in datetime */\n  /* If start of recursive-only lines, finish up for non-recursive   */\n  Else If Pos(\"TemplateRecursive:\",sourceline(sl)) > 0 Then Do\n    If recursiveVal = '' Then Do          /* Not RECURSIVE           */\n      output.tmp = Substr( ,              /* Close the comment with  */\n        sourceline(sourceline()),1,71)    /*  last line in file      */\n      output.0 = tmp                      /* Increment num of lines  */\n      Leave                               /* Bail out of loop        */\n    End\n    Else\n      Iterate                             /* Skip this line, Cont.   */\n  End                                     /* Recursive template lbl  */\n  /* Include a normal template line.                                 */\n  Else Do\n    output.tmp = Substr(sourceline(sl),1,71) /* Write normal line    */\n  End\n\n  output.0 = tmp                          /* Increment num of lines  */\nEnd                                       /* For each template line  */\n\nReturn  /* buildOutputHeader */\n\n/* ----------------------------------------------------------------- */\n\nwriteOutputFile:\n/*********************************************************************/\n/* function: writeOutputFile                                         */\n/*                                                                   */\n/* input: The following global variables:                            */\n/*        - outputFile: Name of file, path, or data set into which   */\n/*                      to write the output                          */\n/*        - output.   : The stem variable containing the lines to    */\n/*                      write to the output file                     */\n/*                                                                   */\n/* output: The output is written                                     */\n/*                                                                   */\n/* returns: 1 - output successfully created                          */\n/*          0 - output not successfully created                      */\n/*                                                                   */\n/* Notes:  A data set starts with \"//\" by convention                 */\n/*                                                                   */\n/*********************************************************************/\nfileCreated = 1\n/*********************************************************************/\n/* Write the output stem to the output UNIX file.                    */\n/*********************************************************************/\nIf Substr(outputFile,1,2) /= \"//\" Then Do  /* Unix file/path         */\n  'writefile (outputFile) 700 output.'\n  If retval = -1 Then Do\n    fileCreated = 0\n    say 'writefile error:' retval errno errnojr 'attempting to create',\n        outputFile 'output file.'\n  End\nEnd\n/*********************************************************************/\n/* Write the output stem to the output data set.                     */\n/*********************************************************************/\nElse Do\n  dsName = Substr(outputFile,3) /* Name starts after \"//\" */\n\n  address TSO      /* Establish TSO environment */\n  \"ALLOC DA(\"dsName\") F(myoutdd) SHR REUSE\"\n  If rc /= 0 Then Do\n    say 'Error' rc 'allocating output data set' dsName'.'\n    fileCreated = 0\n  End\n  Else Do\n    \"EXECIO 0 DISKW myoutdd (OPEN\"\n    If rc /= 0 Then Do\n      say 'Error' rc 'opening output data set' dsName'.'\n      fileCreated = 0\n    End\n    Else Do\n      \"EXECIO * DISKW myoutdd (STEM output.\"\n      If rc /= 0 Then Do\n        say 'Error' rc 'writing to output data set' dsName'.'\n        fileCreated = 0\n      End\n      Else Do\n        \"EXECIO 0 DISKW myoutdd (FINIS\"\n        If rc /= 0 Then Do\n          say 'Error' rc 'closing output data set' dsName'.'\n          fileCreated = 0\n        End\n      End\n    End\n\n    \"FREE F(myoutdd)\"\n  End\n\n  address syscall  /* Restore syscall environment */\nEnd\n\nReturn fileCreated /* writeOutputFile */\n\n/* ----------------------------------------------------------------- */\n\n/*********************************************************************/\n/* ATTENTION!!!!!                                                    */\n/* The following label and lines are used in the construction of     */\n/* the output file and *MUST* remain at the very bottom              */\n/* of this exec!!!!                                                  */\n/*********************************************************************/\nTemplate:\n/*********************************************************************/\n/*                                                                   */\n/* DATE/TIME                                                         */\n/*                                                                   */\nTemplateRecursive:  /* More information when RECURSIVE specified */\n/* This file contains the security information of the UNIX           */\n/* objects requested. The list of objects is displayed immediately   */\n/* below, followed by the information for each individual object,    */\n/* in the order indicated by the list.                               */\n/*                                                                   */\n/* To advance quickly through individual objects, search for the     */\n/* \"!--\" string.                                                     */\n/*                                                                   */\n/*********************************************************************/\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RACFADM": {"ttr": 903, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01W\\x00V\\x01 \\x02\\x0f\\x01 \\x18/\\x16\\x10\\x00\\xa1\\x00%\\x00\\x00\\xd9\\xc1\\xc3\\xc6\\xc1\\xc4\\xd4@@@'", "ispf": {"version": "01.87", "flags": 0, "createdate": "2020-01-20T00:00:00", "modifydate": "2020-06-30T16:10:56", "lines": 161, "newlines": 37, "modlines": 0, "user": "RACFADM"}, "text": "/*%NOCOMMENT====================* REXX *==============================*/\n/*  PURPOSE:  RACFADM - Display Menu - LIBDEF and ALTLIB datasets     */\n/*--------------------------------------------------------------------*/\n/*  NOTES:    1) There are two subroutines to allow defining repeat   */\n/*               find (RFIND):                                        */\n/*               - SETUP_RFIND1 allocates a ISPF table and            */\n/*                 defines/adds the RFIND command                     */\n/*               - SETUP_RFIND2 updates the currently used table      */\n/*                 and modifies the RFIND command                     */\n/*               - Currently this program is using SETUP_RFIND1,      */\n/*                 due to SETUP_RFIND2 was leaving entry in table     */\n/*                 after exiting                                      */\n/*                                                                    */\n/*            2) For all users, this REXX program will call RACFSETD  */\n/*               to define default Settings (Option 0)                */\n/*--------------------------------------------------------------------*/\n/* FLG  YYMMDD  USERID   DESCRIPTION                                  */\n/* ---  ------  -------  -------------------------------------------- */\n/* @A2  200622  LBD      Support a passed option                      */\n/* @AC  200619  RACFA    Initialize the variable NULL                 */\n/* @AB  200619  LBD      Fixed datasets w/ last qual. as 'SKEL'       */\n/* @AA  200610  RACFA    Added skeleton dataset                       */\n/* @A9  200520  RACFA    Fixed RFIND, LIBDEF and TBCLOSE using $STUB  */\n/* @A8  200519  TRIDJK   Check user cmd table before site cmd table   */\n/* @A7  200519  RACFA    Use SETUP_RFIND1, RFIND2 left entry in table */\n/* @A6  200514  LBD      Add parmeter of NA to bypass allocations     */\n/* @A5  200514  LBD      Added different way to setup/define RFIND    */\n/* @A4  200501  RACFA    If 1st time used, get site default settings  */\n/* @A3  200501  LBD      Add dynamic command table                    */\n/* @A2  200124  RACFA    Place panels at top of REXX in variables     */\n/* @A1  200120  LBD      Added code for sites using qual. PLIB/MLIB   */\n/* @A0  200120  LBD      Created REXX                                 */\n/*====================================================================*/\nPANEL01     = \"RACFMENU\"  /* RACF Main Menu                */ /* @A2 */\nREXXPGM1    = \"RACFSETD\"  /* Obtain settings for new user  */ /* @A4 */\nNULL        = \"\"                                              /* @AC */\nArg RAOPT                 /* Invoked using $STUB mbr       */ /* @A6 */\n\nif pos('NA',RAOPT) > 0 then do                                /* @A2 */\n   rw = wordpos('NA',RAOPT)                                   /* @A2 */\n   radmopt = delword(raopt,rw,1)                              /* @A2 */\n   raopt = 'NA'                                               /* @A2 */\nend                                                           /* @A2 */\nelse                                                          /* @A2 */\n   radmopt = raopt                                            /* @A2 */\n\nADDRESS ISPEXEC\n  call Setup\n  'Select cmd('REXXPGM1')  NewAppl(RADM) PassLib'             /* @A4 */\n\n  if radmopt /= null then 'control nondispl enter'            /* @A2 */\n\n  'Select Panel('PANEL01') Opt('radmopt')' ,                  /* @A2 */\n         'NewAppl(RADM) PassLib'                              /* @A2 */\n  if (RAOPT <> \"NA\") THEN DO                                  /* @A9 */\n     'libdef ispmlib'\n     'libdef ispplib'\n     'libdef ispslib'                                         /* @AA */\n     Address TSO 'altlib deact app(exec)'\n  END                                                         /* @A9 */\n  'tbclose radmcmds'                                          /* @A7 */\nEXIT 0\n/*--------------------------------------------------------------------*/\n/*  Obtain dataset names and LIBDEF/ALTLIB them                       */\n/*--------------------------------------------------------------------*/\nSETUP:\n  parse source src                                            /* @A6 */\n  parse value src with TSO Type Name DDName DSName,           /* @A6 */\n                       NameO Env Addr Token                   /* @A6 */\n  cmd = name                                                  /* @A6 */\n\n  call setup_rfind1                                           /* @A9 */\n  if (raopt = 'NA') then return                               /* @A9 */\n  if (DSName /= '?') then exec = \"'\"dsname\"'\"\n  else do\n     x      = listdsi(DDName 'FILE')\n     exec   = \"'\"sysdsname\"'\"\n     dsname = sysdsname\n  end\n  dsname = translate(dsname,' ','.')\n  panels = \"'\"subword(dsname,1,words(dsname)-1)\" PANELS'\"\n  skels  = \"'\"subword(dsname,1,words(dsname)-1)\" SKELS'\"      /* @AB */\n  msgs   = \"'\"subword(dsname,1,words(dsname)-1)\" MSGS'\"\n  plib   = \"'\"subword(dsname,1,words(dsname)-1)\" ISPPLIB'\"    /* @A1 */\n  slib   = \"'\"subword(dsname,1,words(dsname)-1)\" ISPSLIB'\"    /* @AA */\n  mlib   = \"'\"subword(dsname,1,words(dsname)-1)\" ISPMLIB'\"    /* @A1 */\n  panels = translate(panels,'.',' ')\n  msgs   = translate(msgs,'.',' ')\n  skels  = translate(skels,'.',' ')                            /*@AB */\n  plib   = translate(plib,'.',' ')                            /* @A1 */\n  slib   = translate(slib,'.',' ')                            /* @AA */\n  mlib   = translate(mlib,'.',' ')                            /* @A1 */\n  x = listdsi(plib)                                           /* @A1 */\n  if (x = 0) then panels = plib                               /* @A1 */\n  x = listdsi(slib)                                           /* @AA */\n  if (x = 0) then skels = slib                                /* @AB */\n  x = listdsi(mlib)                                           /* @A1 */\n  if (x = 0) then msgs = mlib                                 /* @A1 */\n  Address TSO 'Altlib Act app(Exec) Dataset('exec')'\n  'Libdef ISPMLIB dataset id('msgs') Stack'\n  'Libdef ISPPLIB dataset id('panels') Stack'\n  'Libdef ISPSLIB dataset id('skels') Stack'                  /* @AB */\nRETURN\n/*--------------------------------------------------------------------*/\n/*  Define the ISPF Command Table to enable RFIND                @A3  */\n/*--------------------------------------------------------------------*/\n/*  This approach requires creating an ISPF table for the        @A3  */\n/*  applications commands (RFIND).                               @A3  */\n/*--------------------------------------------------------------------*/\nSETUP_RFIND1:                                                 /* @A3 */\n  'control errors return'                                     /* @A3 */\n  'tbquery radmcmds'                                          /* @A3 */\n  if (rc = 0) then return                                     /* @A3 */\n  \"TBCreate radmcmds names(zctverb zcttrunc zctact\" ,         /* @A3 */\n                     \"zctdesc) replace share nowrite\"         /* @A3 */\n  zctverb  = \"RFIND\"                                          /* @A3 */\n  zcttrunc = 0                                                /* @A3 */\n  zctact   = \"&RADMRFND\"                                      /* @A3 */\n  zctdesc  = \"RADM User controlled Repeat Find (RFIND)\"       /* @A3 */\n  \"TBAdd radmcmds\"                                            /* @A3 */\nRETURN                                                        /* @A3 */\n/*--------------------------------------------------------------------*/\n/*  Define the ISPF Command Table to enable RFIND                @A3  */\n/*--------------------------------------------------------------------*/\n/*  This approach does not require recursion or creating an      @A5  */\n/*  ISPF table for the applications commands. This approach      @A5  */\n/*  updates the active site command table in memory.             @A5  */\n/*                                                               @A5  */\n/*  This does:                                                   @A5  */\n/*    1) Define the commmand table entry                         @A5  */\n/*    2) vget the variable with the prefix for the site ISPF     @A5  */\n/*       command table.                                          @A5  */\n/*    3) Define a varable with the command table name            @A5  */\n/*    4) Move to the top of the command table                    @A5  */\n/*    5) Establish the table search                              @A5  */\n/*    6) If the entry is found then add it                       @A5  */\n/*    7) Prime the variable to null                              @A5  */\n/*--------------------------------------------------------------------*/\nSETUP_RFIND2:                                                 /* @A5 */\n  zctverb  = \"RFIND\"                                          /* @A5 */\n  zcttrunc = 0                                                /* @A5 */\n  zctact   = \"&RADMRFND\"                                      /* @A5 */\n  zctdesc  = \"RACFADM User controlled Repeat Find (RFIND)\"    /* @A5 */\n  'vget (zsctpref zuctpref)'                                  /* @A8 */\n  select                                                      /* @A8 */\n     when (zuctpref <> '') then                               /* @A8 */\n          ctab = zuctpref'cmds'                               /* @A8 */\n     when (zsctpref <> '') then                               /* @A8 */\n          ctab = zsctpref'cmds'                               /* @A8 */\n     otherwise                                                /* @A8 */\n          ctab = 'ISPcmds'                                    /* @A8 */\n  end                                                         /* @A8 */\n  'vget (zsctpref)'                                           /* @A5 */\n  if (zsctpref = '') then zsctpref = 'ISP'                    /* @A5 */\n  ctab = zsctpref'cmds'                                       /* @A5 */\n  'tbtop'  ctab                                               /* @A5 */\n  'tbscan' ctab 'arglist(zctact) condlist(EQ) Next'           /* @A5 */\n  if (rc > 0) then 'tbadd' ctab                               /* @A5 */\n  radmrfnd = null                                             /* @A5 */\n  'vput (radmrfnd)'                                           /* @A5 */\nRETURN                                                        /* @A5 */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RACFCERT": {"ttr": 963, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x14c\\x00X\\x01 \\x00?\\x01 3\\x9f\\x12W\\x01\\xef\\x00\\xb8\\x00\\x00\\xd9\\xc1\\xc3\\xc6\\xc1\\xc4\\xd4@@@'", "ispf": {"version": "20.99", "flags": 0, "createdate": "2020-01-03T00:00:00", "modifydate": "2020-12-04T12:57:58", "lines": 495, "newlines": 184, "modlines": 0, "user": "RACFADM"}, "text": "/*%NOCOMMENT====================* REXX *==============================*/\n/*  PURPOSE:  RACFADM - Digital Certificates, Option CA, List labels  */\n/*--------------------------------------------------------------------*/\n/* FLG  YYMhDD  USERID   DESCRIPTION                                  */\n/* ---  ------  -------  -------------------------------------------- */\n/* @A1  201118  TRIDJK   Add X (CA Export) line command               */\n/* @A0  200929  TRIDJK   Created REXX                                 */\n/*====================================================================*/\nPANEL27     = \"RACFCERT\"   /* List labels                  */\nPANELM2     = \"RACFMSG2\"   /* Display RACF command and RC  */\nPANELS1     = \"RACFSAVE\"   /* Obtain DSName to SAVE        */\nPANELXP     = \"RACFEXP\"    /* Export DSN prompt            */ /* @A1 */\nSKELETON1   = \"RACFCERT\"   /* Save tablea to dataset       */\nEDITMACR    = \"RACFEMAC\"   /* Edit Macro, turn HILITE off  */\nTABLEA      = 'TA'RANDOM(0,99999)  /* Unique table name A  */\nDDNAME      = 'RACFA'RANDOM(0,999) /* Unique ddname        */\nparse source . . REXXPGM .         /* Obtain REXX pgm name */\nREXXPGM     = LEFT(REXXPGM,8)\nNULL        = ''\n\nADDRESS ISPEXEC\n  \"CONTROL ERRORS RETURN\"\n  \"VGET (SETGDISP SETMADMN SETMSHOW SETMTRAC) PROFILE\"\n\n  If (SETMTRAC <> 'NO') then do\n     Say \"*\"COPIES(\"-\",70)\"*\"\n     Say \"*\"Center(\"Begin Program = \"REXXPGM,70)\"*\"\n     Say \"*\"COPIES(\"-\",70)\"*\"\n     if (SETMTRAC <> 'PROGRAMS') THEN\n        interpret \"Trace \"SUBSTR(SETMTRAC,1,1)\n  end\n\n  cmd = \"racdcert certauth list(label('DUMMY')\"\n  x    = outtrap('var.')\n  Address TSO cmd\n  cmd_rc = rc\n  x    = outtrap('off')\n  if (SETMSHOW <> 'NO') then\n     call SHOWCMD\n  if cmd_rc = 8 then do\n    RACFSMSG = \"Not authorized\"                               /* @A1 */\n    RACFLMSG = \"You are not authorized to issue\",             /* @A1 */\n               \"the RACDCERT command.\"                        /* @A1 */\n    \"SETMSG MSG(RACF011)\"                                     /* @A1 */\n    EXIT\n    end\n\n  racflmsg = \"Loading awesomeness..\"\n  \"control display lock\"\n  \"display msg(RACF011)\"\n  Address 'SYSCALL' 'SLEEP (1)'\n\n  SELCMDS = \"[S]Show[X]Export\"                                /* @A1 */\n\n  call Select_label\n  rc = display_table()\n  \"TBEND\" TABLEA\n\n  If (SETMTRAC <> 'NO') then do\n     Say \"*\"COPIES(\"-\",70)\"*\"\n     Say \"*\"Center(\"End Program = \"REXXPGM,70)\"*\"\n     Say \"*\"COPIES(\"-\",70)\"*\"\n  end\nEXIT\n/*--------------------------------------------------------------------*/\n/*  Select label                                                      */\n/*--------------------------------------------------------------------*/\nSELECT_LABEL:\n  seconds = time('S')\n  \"TBCREATE\" TABLEA \"KEYS(LABEL)\",\n                  \"NAMES(STDATE ENDATE STATUS) REPLACE NOWRITE\"\n  call get_cert_labels\n  sort     = 'LABEL,C,A'\n  CLRLABE  = \"TURQ\" ; CLRSTDA = \"GREEN\"\n  CLRENDA  = \"GREEN\"; CLRSTAT = \"GREEN\"\n  \"TBSORT \" TABLEA \"FIELDS(\"sort\")\"\n  \"TBTOP  \" TABLEA\nRETURN\n/*--------------------------------------------------------------------*/\n/*  Display digital certificate labels                                */\n/*--------------------------------------------------------------------*/\nGET_CERT_LABELS:\n  Scan = 'OFF'\n  cmd = \"racdcert certauth list\"\n  x = OUTTRAP('var.')\n  address TSO cmd\n  cmd_rc = rc\n  x = OUTTRAP('OFF')\n  if (SETMSHOW <> 'NO') then\n     call SHOWCMD\n\n  cnt = 0\n  do x = 1 to var.0\n    if pos('Label:',var.x) > 0 then do\n      cnt = cnt + 1\n      label  = substr(var.x,10,32)\n      i = x + 2\n      status = substr(var.i,11,9)\n      i = i + 1\n      stdate = substr(var.i,15,10)\n      i = i + 1\n      endate = substr(var.i,15,10)\n      \"TBMOD\" TABLEA\n      end\n    end\n\nRETURN\n/*--------------------------------------------------------------------*/\n/*  Labels table display section                                      */\n/*--------------------------------------------------------------------*/\nDISPLAY_TABLE:\n  opta   = ' '\n  xtdtop = 0\n  rsels  = 0\n  do forever\n     if (rsels < 2) then do\n        \"TBTOP \" TABLEA\n        'tbskip' tablea 'number('xtdtop')'\n        radmrfnd = 'PASSTHRU'\n        'vput (radmrfnd)'\n        \"TBDISPL\" TABLEA \"PANEL(\"PANEL27\")\"\n     end\n     else 'tbdispl' tablea\n     if (rc > 4) then leave\n     xtdtop   = ztdtop\n     rsels    = ztdsels\n     radmrfnd = null\n     'vput (radmrfnd)'\n     PARSE VAR ZCMD ZCMD PARM SEQ\n     IF (SROW <> \"\") & (SROW <> 0) THEN\n        IF (SROW > 0) THEN DO\n           \"TBTOP \" TABLEA\n           \"TBSKIP\" TABLEA \"NUMBER(\"SROW\")\"\n        END\n     if (zcmd = 'RFIND') then do\n        zcmd = 'FIND'\n        parm = findit\n        'tbtop ' TABLEA\n        'tbskip' TABLEA 'number('last_find')'\n     end\n     Select\n        When (abbrev(\"FIND\",zcmd,1) = 1) then\n             call do_find\n        WHEN (ABBREV(\"LOCATE\",ZCMD,1) = 1) THEN do\n             if (parm <> '') then do\n                locarg = parm'*'\n                PARSE VAR SORT . \",\" . \",\" SEQ\n                IF (SEQ = \"D\") THEN\n                   CONDLIST = \"LE\"\n                ELSE\n                   CONDLIST = \"GE\"\n                parse value sort with scan_field',' .\n                interpret scan_field ' = locarg'\n                'tbtop ' tablea\n                \"TBSCAN \"TABLEA\" ARGLIST(\"scan_field\")\",\n                        \"CONDLIST(\"CONDLIST\")\",\n                        \"position(scanrow)\"\n                xtdtop = scanrow\n             end\n        end\n        WHEN (ABBREV(\"ONLY\",ZCMD,1) = 1) THEN DO\n             find_str = translate(parm)\n             'tbtop ' TABLEA\n             'tbskip' TABLEA\n             do forever\n                str = translate(label stdate endate status)\n                if (pos(find_str,str) > 0) then nop\n                else 'tbdelete' TABLEA\n                'tbskip' TABLEA\n                if (rc > 0) then do\n                   'tbtop' TABLEA\n                   leave\n                end\n             end\n        END\n        WHEN (ABBREV(\"RESET\",ZCMD,1) = 1) THEN DO\n             call select_label\n             sort     = 'LABEL,C,A'\n             xtdtop   = 1\n        END\n        When (abbrev(\"SAVE\",zcmd,2) = 1) then DO\n             TMPSKELT = SKELETON1\n             call do_SAVE\n        END\n        WHEN (ABBREV(\"SORT\",ZCMD,1) = 1) THEN DO\n             SELECT\n                when (ABBREV(\"LABEL\",PARM,1) = 1) then\n                     call sortseq 'LABEL'\n                when (ABBREV(\"STDATE\",PARM,1) = 1) then\n                     call sortseq 'STDATE'\n                when (ABBREV(\"ENDATE\",PARM,1) = 1) then\n                     call sortseq 'ENDATE'\n                when (ABBREV(\"STATUS\",PARM,1) = 1) then\n                     call sortseq 'STATUS'\n                otherwise NOP\n           END\n        END\n        OTHERWISE NOP\n     End /* Select */\n     CLRLABE  = \"GREEN\"; CLRSTDA = \"GREEN\"\n     CLRENDA  = \"GREEN\"; CLRSTAT = \"GREEN\"\n     PARSE VAR SORT LOCARG \",\" .\n     INTERPRET \"CLR\"SUBSTR(LOCARG,1,4)\" = 'TURQ'\"\n     \"TBSORT\" TABLEA \"FIELDS(\"sort\")\"\n     \"TBTOP \" TABLEA\n     ZCMD = \"\"; PARM = \"\"\n     'control display save'\n     Select\n        when (opta = 'L') then call listl\n        when (opta = 'S') then call listl\n        when (opta = 'X') then call listl                     /* @A1 */\n        otherwise nop\n     End\n     'control display restore'\n  end  /* Do forever) */\nRETURN 0\n/*--------------------------------------------------------------------*/\n/*  Process primary command FIND                                      */\n/*--------------------------------------------------------------------*/\nDO_FIND:\n  if (parm = null) then do\n     racfsmsg = 'Error'\n     racflmsg = 'Find requires a value to search for.' ,\n                'Try again.'\n     'setmsg msg(RACF011)'\n     return\n  end\n  findit    = translate(parm)\n  last_find = 0\n  wrap      = 0\n  do forever\n     'tbskip' TABLEA\n     if (rc > 0) then do\n        if (wrap = 1) then do\n           racfsmsg = 'Not Found'\n           racflmsg = findit 'not found.'\n           'setmsg msg(RACF011)'\n           return\n        end\n        if (wrap = 0) then wrap = 1\n        'tbtop' TABLEA\n     end\n     else do\n        testit = translate(label stdate endate status)\n        if (pos(findit,testit) > 0) then do\n           'tbquery' TABLEA 'position(srow)'\n           'tbtop'   TABLEA\n           'tbskip'  TABLEA 'number('srow')'\n           last_find = srow\n           xtdtop    = srow\n           if (wrap = 0) then\n              racfsmsg = 'Found'\n           else\n              racfsmsg = 'Found/Wrapped'\n           racflmsg = findit 'found in row' srow + 0\n           'setmsg msg(RACF011)'\n           return\n        end\n     end\n  end\nRETURN\n/*--------------------------------------------------------------------*/\n/*  Define sort sequence, to allow point-n-shoot sorting (A/D)        */\n/*--------------------------------------------------------------------*/\nSORTSEQ:\n  parse arg sortcol\n  INTERPRET \"TMPSEQ = SORT\"substr(SORTCOL,1,4)\n  select\n     when (seq <> \"\") then do\n          if (seq = 'A') then\n             tmpseq = 'D'\n          else\n             tmpseq = 'A'\n          sort = sortcol',C,'seq\n     end\n     when (seq = \"\"),\n        & (tmpseq = 'A') then do\n           sort   = sortcol',C,A'\n           tmpseq = 'D'\n     end\n     Otherwise do\n        sort   = sortcol',C,D'\n        tmpseq = 'A'\n     end\n  end\n  INTERPRET \"SORT\"SUBSTR(SORTCOL,1,4)\" = TMPSEQ\"\nRETURN\n/*--------------------------------------------------------------------*/\n/*  List/Export label                                                 */\n/*--------------------------------------------------------------------*/\nLISTL:\n  IF (OPTA = \"X\") THEN DO                                     /* @A1 */\n     xdsn = label                                             /* @A1 */\n     call dsn_chars                                           /* @A1 */\n     do x = 1 to length(xdsn)                                 /* @A1 */\n        if x // 9 = 0 then do                                 /* @A1 */\n           if datatype(substr(xdsn,x+1,1),'M') = 1 then       /* @A1 */\n              xdsn = overlay('.',xdsn,x,1)                    /* @A1 */\n           else                                               /* @A1 */\n              xdsn = overlay('.@',xdsn,x,2)                   /* @A1 */\n        end                                                   /* @A1 */\n     end                                                      /* @A1 */\n     xdsn = \"'\"userid()\".\"xdsn\".XP'\"                          /* @A1 */\n     'ADDPOP'                                                 /* @A1 */\n     'DISPLAY PANEL('panelxp')'                               /* @A1 */\n     disprc = RC                                              /* @A1 */\n     'REMPOP'                                                 /* @A1 */\n     if (disprc = 8) then do                                  /* @A1 */\n        cmd_rc = 8                                            /* @A1 */\n        RETURN                                                /* @A1 */\n     end                                                      /* @A1 */\n     cmd = \"racdcert certauth export(label('\"LABEL\"')) dsn(\"xdsn\")\"\n     X = OUTTRAP(\"CMDREC.\")                                   /* @A1 */\n     ADDRESS TSO cmd                                          /* @A1 */\n     cmd_rc = rc                                              /* @A1 */\n     X = OUTTRAP(\"OFF\")                                       /* @A1 */\n     if (SETMSHOW <> 'NO') then                               /* @A1 */\n        call SHOWCMD                                          /* @A1 */\n     DROP CMDREC.                                             /* @A1 */\n     if (cmd_rc = 0) then do                                  /* @A1 */\n       RACFSMSG = \"Certificate exported\"                      /* @A1 */\n       RACFLMSG = \"Label '\"strip(label)\"' was exported to\",   /* @A1 */\n                  \"dataset \"xdsn                              /* @A1 */\n       \"SETMSG MSG(RACF011)\"                                  /* @A1 */\n       end                                                    /* @A1 */\n  END                                                         /* @A1 */\n  ELSE DO                                                     /* @A1 */\n     cmd = \"racdcert certauth list(label('\"LABEL\"'))\"\n     X = OUTTRAP(\"CMDREC.\")\n     ADDRESS TSO cmd\n     cmd_rc = rc\n     X = OUTTRAP(\"OFF\")\n     if (SETMSHOW <> 'NO') then\n        call SHOWCMD\n     DO J = 1 TO CMDREC.0\n        CMDREC.J = SUBSTR(CMDREC.J,1,80)\n     END\n     ADDRESS TSO \"ALLOC F(\"DDNAME\") NEW REUSE\",\n                 \"LRECL(80) BLKSIZE(0) RECFM(F B)\",\n                 \"UNIT(VIO) SPACE(1 5) CYLINDERS\"\n     ADDRESS TSO \"EXECIO * DISKW \"DDNAME\" (STEM CMDREC. FINIS\"\n     DROP CMDREC.\n\n     \"LMINIT DATAID(CMDDATID) DDNAME(\"DDNAME\")\"\n     SELECT\n        WHEN (SETGDISP = \"VIEW\") THEN\n             \"VIEW DATAID(\"CMDDATID\") MACRO(\"EDITMACR\")\"\n        WHEN (SETGDISP = \"EDIT\") THEN\n             \"EDIT DATAID(\"CMDDATID\") MACRO(\"EDITMACR\")\"\n        OTHERWISE\n             \"BROWSE DATAID(\"CMDDATID\")\"\n     END\n     ADDRESS TSO \"FREE FI(\"DDNAME\")\"\n     if (cmd_rc > 0) then\n        CALL racfmsgs \"ERR10\" /* Generic failure */\n  END\nRETURN\n/*--------------------------------------------------------------------*/\n/*  Keep only DSN characters                                     @A1  */\n/*--------------------------------------------------------------------*/\nDSN_CHARS:                                                    /* @A1 */\n   if left(xdsn,1) > 'Z' | left(xdsn,1) = '-' then            /* @A1 */\n      xdsn = '@'substr(xdsn,2)                                /* @A1 */\n   dsn='abcdefghijklmnopqrstuvwxyz'||,                        /* @A1 */\n       'ABCDEFGHIJKLMNOPQRSTUVWXYZ'||,                        /* @A1 */\n       '0123456789-@#$'                                       /* @A1 */\n   nondsn = space(translate(xdsn,,dsn),0)                     /* @A1 */\n   xdsn   = space(translate(xdsn,,nondsn),0)                  /* @A1 */\nRETURN                                                        /* @A1 */\n/*--------------------------------------------------------------------*/\n/*  Display RACF command and return code                              */\n/*--------------------------------------------------------------------*/\nSHOWCMD:\n  IF (SETMSHOW = \"BOTH\") | (SETMSHOW = \"DISPLAY\") THEN DO\n     PARSE VAR CMD MSG1 60 MSG2 121 MSG3\n     MSG4 = \"Return code = \"cmd_rc\n     \"ADDPOP ROW(6) COLUMN(4)\"\n     \"DISPLAY PANEL(\"PANELM2\")\"\n     \"REMPOP\"\n  END\n  IF (SETMSHOW = \"BOTH\") | (SETMSHOW = \"LOG\") THEN DO\n     zerrsm = \"RACFADM \"REXXPGM\" RC=\"cmd_rc\n     zerrlm = cmd\n     'log msg(isrz003)'\n  END\nRETURN\n/*--------------------------------------------------------------------*/\n/*  Save table to dataset                                             */\n/*--------------------------------------------------------------------*/\nDO_SAVE:\n  X = MSG(\"OFF\")\n  \"ADDPOP COLUMN(40)\"\n  \"VGET (RACFSDSN RACFSMBR RACFSFIL RACFSREP) PROFILE\"\n  IF (RACFSDSN = \"\") THEN         /* SAve - Dataset Name  */\n     RACFSDSN = USERID()\".RACFADM.REPORTS\"\n  IF (RACFSFIL = \"\") THEN         /* SAve - As (TXT/CVS)  */\n     RACFSFIL = \"T\"\n  IF (RACFSREP = \"\") THEN         /* SAve - Replace (Y/N) */\n     RACFSREP = \"N\"\n\n  DO FOREVER\n     \"DISPLAY PANEL(\"PANELS1\")\"\n     IF (RC = 08) THEN DO\n        \"REMPOP\"\n        RETURN\n     END\n     RACFSDSN = STRIP(RACFSDSN,,\"'\")\n     RACFSDSN = STRIP(RACFSDSN,,'\"')\n     RACFSDSN = STRIP(RACFSDSN)\n     SYSDSORG = \"\"\n     X = LISTDSI(\"'\"RACFSDSN\"'\")\n     IF (SYSDSORG = \"\") | (SYSDSORG = \"PS\"),\n      | (SYSDSORG = \"PO\") THEN\n        NOP\n     ELSE DO\n        RACFSMSG = \"Not PDS/Seq File\"\n        RACFLMSG = \"The dataset specified is not\",\n                  \"a partitioned or sequential\",\n                  \"dataset, please enter a valid\",\n                  \"dataset name.\"\n       \"SETMSG MSG(RACF011)\"\n       ITERATE\n     END\n     IF (SYSDSORG = \"PS\") & (RACFSMBR <> \"\") THEN DO\n        RACFSMSG = \"Seq File - No mbr\"\n        RACFLMSG = \"This dataset is a sequential\",\n                  \"file, please remove the\",\n                  \"member name.\"\n       \"SETMSG MSG(RACF011)\"\n       ITERATE\n     END\n     IF (SYSDSORG = \"PO\") & (RACFSMBR = \"\") THEN DO\n        RACFSMSG = \"PDS File - Need Mbr\"\n        RACFLMSG = \"This dataset is a partitioned\",\n                  \"dataset, please include a member\",\n                  \"name.\"\n       \"SETMSG MSG(RACF011)\"\n       ITERATE\n     END\n\n     IF (RACFSMBR = \"\") THEN\n        TMPDSN = RACFSDSN\n     ELSE\n        TMPDSN = RACFSDSN\"(\"RACFSMBR\")\"\n     DSNCHK = SYSDSN(\"'\"TMPDSN\"'\")\n     IF (DSNCHK = \"OK\" & RACFSREP = \"N\") THEN DO\n        RACFSMSG = \"DSN/MBR Exists\"\n        RACFLMSG = \"Dataset/member already exists. \",\n                  \"Please type in \"Y\" to replace file.\"\n        \"SETMSG MSG(RACF011)\"\n        ITERATE\n     END\n     LEAVE\n  END\n  \"REMPOP\"\n  \"VPUT (RACFSDSN RACFSMBR RACFSFIL RACFSREP) PROFILE\"\n\nADDRESS TSO\n  IF (RACFSREP = \"Y\" & RACFSMBR = \"\") |,\n     (DSNCHK <> \"OK\" & DSNCHK <> \"MEMBER NOT FOUND\"),\n     THEN DO\n     \"DELETE '\"RACFSDSN\"'\"\n     IF (RACFSMBR = \"\") THEN\n        \"ALLOC  FI(ISPFILE) DA('\"RACFSDSN\"') NEW\",\n            \"REUSE SP(1 1) CYLINDER UNIT(SYSALLDA)\",\n            \"LRECL(80) RECFM(F B)\"\n     ELSE\n        \"ALLOC  FI(ISPFILE) DA('\"RACFSDSN\"') NEW\",\n            \"REUSE SP(1 1) CYLINDER UNIT(SYSALLDA)\",\n            \"LRECL(80) RECFM(F B)\",\n            \"DSORG(PO) DSNTYPE(LIBRARY,2)\"\n  END\n  ELSE\n     \"ALLOC  FI(ISPFILE) DA('\"RACFSDSN\"') SHR REUSE\"\n\nADDRESS ISPEXEC\n  \"FTOPEN\"\n  \"FTINCL \"TMPSKELT\n  IF (RACFSMBR = \"\") THEN\n     \"FTCLOSE\"\n  ELSE\n     \"FTCLOSE NAME(\"RACFSMBR\")\"\n  ADDRESS TSO \"FREE FI(ISPFILE)\"\n\n  SELECT\n     WHEN (SETGDISP = \"VIEW\") THEN\n          \"VIEW DATASET('\"RACFSDSN\"') MACRO(\"EDITMACR\")\"\n     WHEN (SETGDISP = \"EDIT\") THEN\n          \"EDIT DATASET('\"RACFSDSN\"') MACRO(\"EDITMACR\")\"\n     OTHERWISE\n          \"BROWSE DATASET('\"RACFSDSN\"')\"\n  END\n  X = MSG(\"ON\")\n\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RACFCLSA": {"ttr": 905, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x14c\\x00\\x19\\x01 \\x00?\\x01 \\x16\\x1f\\x07Q\\x00\\xd4\\x00\\xd9\\x00\\x00\\xd9\\xc1\\xc3\\xc6\\xc1\\xc4\\xd4@@@'", "ispf": {"version": "20.99", "flags": 0, "createdate": "2020-01-03T00:00:00", "modifydate": "2020-06-09T07:51:19", "lines": 212, "newlines": 217, "modlines": 0, "user": "RACFADM"}, "text": "/*%NOCOMMENT====================* REXX *==============================*/\n/*  PURPOSE:  RACFADM - Authorization - Menu option 99 (Hidden)       */\n/*--------------------------------------------------------------------*/\n/* FLG  YYMMDD  USERID   DESCRIPTION                                  */\n/* ---  ------  -------  -------------------------------------------- */\n/* @AP  200430  RACFA    Chg tbla to TABLEA, moved def. var. up top   */\n/* @AO  200423  RACFA    Move PARSE REXXPGM name up above IF SETMTRAC */\n/* @AN  200422  RACFA    Ensure the REXX program name is 8 chars      */\n/* @AM  200422  RACFA    Use variable REXXPGM in log msg              */\n/* @AL  200417  RACFA    Chged panel names RACFAUT1/2 to RACFCLSE/F   */\n/* @AK  200417  RACFA    Renamed this REXX pgm, was RACFAUTH          */\n/* @AJ  200413  RACFA    Chg TRACEing to only display banner (P=Pgms) */\n/* @AI  200412  RACFA    Chg TRACE to allow 'L'abels or 'R'esults     */\n/* @AH  200324  RACFA    Allow both display/logging of RACF commands  */\n/* @AG  200324  RACFA    Allow logging RACF commands to ISPF Log file */\n/* @AF  200303  RACFA    Del 'EXCMD' procedure, not referenced        */\n/* @AE  200301  RACFA    Deleted EMSG procedure, not referenced       */\n/* @AD  200226  RACFA    Fix @AB chg, chg ret_code to cmd_rc          */\n/* @AC  200226  RACFA    Added 'CONTROL ERRORS RETURN'                */\n/* @AB  200226  RACFA    Added 'Return Code =' when displaying cmd    */\n/* @AA  200226  RACFA    Removed double quotes before/after cmd       */\n/* @A9  200224  RACFA    Standardize quotes, chg single to double     */\n/* @A8  200124  RACFA    Place panels at top of REXX in variables     */\n/* @A7  200223  RACFA    Del 'address TSO \"PROFILE MSGID\"', not needed*/\n/* @A6  200221  RACFA    Make 'ADDRESS ISPEXEC' defualt, reduce code  */\n/* @A5  200220  RACFA    Fixed displaying all RACF commands           */\n/* @A4  200220  RACFA    Added SETMTRAC=YES, then TRACE R             */\n/* @A3  200218  RACFA    Condense VGETs into one line                 */\n/* @A2  200120  RACFA    Removed 'say msg.msg_var' in EXCMD procedure */\n/* @A1  200119  RACFA    Standardized/reduced lines of code           */\n/* @A0  011229  NICORIZ  Created REXX, V2.1, www.rizzuto.it           */\n/*====================================================================*/\nPANEL14     = \"RACFCLSE\"   /* Enter profile/class/user     */ /* @AL */\nPANEL15     = \"RACFCLSF\"   /* List group/ids and access    */ /* @AL */\nPANELM2     = \"RACFMSG2\"   /* Display RACF command and RC  */ /* @A8 */\nTABLEA      = 'TA'RANDOM(0,99999)  /* Unique table name A  */ /* @AP */\nparse source . . REXXPGM .         /* Obtain REXX pgm name */ /* @AO */\nREXXPGM     = LEFT(REXXPGM,8)                                 /* @AO */\n\nADDRESS ISPEXEC                                               /* @A6 */\n  Arg rclass profile user\n  \"CONTROL ERRORS RETURN\"                                     /* @AC */\n  \"VGET (SETMSHOW SETMTRAC) PROFILE\"                          /* @A3 */\n\n  If (SETMTRAC <> 'NO') then do                               /* @AI */\n     Say \"*\"COPIES(\"-\",70)\"*\"                                 /* @AI */\n     Say \"*\"Center(\"Begin Program = \"REXXPGM,70)\"*\"           /* @AI */\n     Say \"*\"COPIES(\"-\",70)\"*\"                                 /* @AI */\n     if (SETMTRAC <> 'PROGRAMS') THEN                         /* @AJ */\n        interpret \"Trace \"SUBSTR(SETMTRAC,1,1)                /* @AI */\n  end\n\n  rlv    = SYSVAR('SYSLRACF')\n  called = SYSVAR('SYSNEST')\n  If (called = 'YES') then \"CONTROL NONDISPL ENTER\"\n\n  \"DISPLAY PANEL(\"PANEL14\")\" /* get prof */                   /* @A8 */\n  ret_code = rc\n  Do while (ret_code = 0) /* While not end on panel   */\n     ret_code = 8\n     call get_prof_acl    /* get profile access list  */\n     call get_user_group  /* get connected groups     */\n     call Analyse         /* analyze and show diff.   */\n     if (called <> 'YES') then do\n        \"DISPLAY PANEL(\"PANEL14\")\"                            /* @A8 */\n        ret_code = rc\n     end\n  end\n\n  If (SETMTRAC <> 'NO') then do                               /* @AI */\n     Say \"*\"COPIES(\"-\",70)\"*\"                                 /* @AI */\n     Say \"*\"Center(\"End Program = \"REXXPGM,70)\"*\"             /* @AI */\n     Say \"*\"COPIES(\"-\",70)\"*\"                                 /* @AI */\n  end                                                         /* @AI */\nRETURN 0\n/*--------------------------------------------------------------------*/\n/*  Display profile permits                                           */\n/*--------------------------------------------------------------------*/\nANALYSE:\n  seconds = time('S')\n  \"TBCREATE\" TABLEA \"KEYS(ID) NAMES(ACC) REPLACE NOWRITE\"\n  do a = 1 to acl_ix\n     id  = subword(acl.a,1,1)\n     acc = subword(acl.a,2,1)\n     do g = 1 to grp_ix\n        if (id = subword(grp.g,1,1)) | (id = user) then\n           \"TBMOD\" TABLEA\n     end\n  end\n  /* Permit table display section */\n  \"TBSORT \" TABLEA \"FIELDS(ID)\"\n  \"TBTOP  \" TABLEA\n  \"TBDISPL\" TABLEA \"PANEL(\"PANEL15\")\"                         /* @A8 */\n  \"TBEND  \" TABLEA\nRETURN\n/*--------------------------------------------------------------------*/\n/*  Get profile permits                                               */\n/*--------------------------------------------------------------------*/\nGET_PROF_ACL:\n  flags   = 'OFF'\n  audit   = ' '\n  owner   = ' '\n  uacc    = ' '\n  data    = ' '\n  warn    = ' '\n  acl_ix  = 0\n  if (type = 'DISCRETE') then\n     type = ' '\n  cmd = \"RLIST \"RCLASS PROFILE\" AUTH\"                         /* @A5 */\n  x = OUTTRAP('VAR.')\n  address TSO cmd                                             /* @A5 */\n  cmd_rc = rc                                                 /* @AB */\n  x = OUTTRAP('OFF')\n  if (SETMSHOW <> 'NO') then                                  /* @AG */\n     call SHOWCMD                                             /* @A5 */\n  if (type = ' ') then\n     type = 'DISCRETE'\n  Do i = 1 to var.0          /* Scan output */\n     temp = var.i\n     if (rlv > '1081') then   /* RACF 1.9 ADD BLANK */\n        temp = ' 'temp\n     l = LENGTH(temp)\n     if (uacc = ' ') then\n        if (substr(temp,2,12) = 'LEVEL  OWNER') then do\n           i     = i + 2\n           temp  = var.i\n           owner = subword(temp,2,1)\n           uacc  = subword(temp,3,1)\n           warn  = subword(temp,5,1)\n        end\n     if (audit = ' ') then\n        if (substr(temp,2,8) = 'AUDITING') then do\n           i     = i + 2\n           temp  = var.i\n           audit = subword(temp,1,1)\n        end\n     if (data = ' ') then\n        if (substr(temp,2,17) = 'INSTALLATION DATA') then do\n           i    = i + 2\n           temp = var.i\n           data = temp\n           i    = i + 1\n           temp = var.i\n           data = data || substr(temp,2)\n        end\n     if (flags = 'ON') then do\n        if (l = 1) | (l= 2) then\n           flags = 'OUT'     /* end of access list */\n        if (l > 8) then\n           if (substr(temp,1,9) = ' ') then\n              flags = 'OUT'  /* end of access list */\n     end\n     if (flags = 'ON') then do\n        if (substr(temp,2,10) = 'NO ENTRIES') then do\n          id  = 'NONE'        /* empty access list */\n          acc = 'DEFINED'\n        end\n        else do\n           id  = subword(temp,1,1)\n           acc = subword(temp,2,1)\n        end\n        acl_ix     = acl_ix+1  /* increase counter  */\n        acl.acl_ix = id acc    /* store acl         */\n     end\n     if (substr(temp,1,17) = 'USER      ACCESS') then do\n        flags = 'ON'      /* start of access list */\n        i     = i + 1     /* skip */\n     end\n  end  /* Loop scan output */\nRETURN\n/*--------------------------------------------------------------------*/\n/*  Get user group                                                    */\n/*--------------------------------------------------------------------*/\nGET_USER_GROUP:\n  If (USER = 'NONE') then\n     return\n  flags  = 'OFF'\n  grp_ix = 0\n  cmd    = \"LU \"USER                                          /* @A5 */\n  x = OUTTRAP('VAR.')\n  address TSO cmd                                             /* @A5 */\n  x = OUTTRAP('OFF')\n  cmd_rc = rc                                                 /* @AB */\n  if (SETMSHOW <> 'NO') then                                  /* @AG */\n     call SHOWCMD                                             /* @A5 */\n  Do i = 1 to var.0               /* Scan output */\n     temp = var.i\n     if (substr(temp,3,5) = 'GROUP') then do\n        id         = substr(temp,9,8)\n        acc        = substr(temp,24,8)\n        grp_ix     = grp_ix+1    /* increase counter */\n        grp.grp_ix = id acc      /* store acl        */\n     End\n  End\nRETURN\n/*--------------------------------------------------------------------*/\n/*  Display RACF command and return code                         @A5  */\n/*--------------------------------------------------------------------*/\nSHOWCMD:                                                      /* @A5 */\n  IF (SETMSHOW = \"BOTH\") | (SETMSHOW = \"DISPLAY\") THEN DO     /* @AH */\n     PARSE VAR CMD MSG1 60 MSG2 121 MSG3                      /* @A5 */\n     MSG4 = \"Return code = \"cmd_rc                            /* @AB */\n     \"ADDPOP ROW(6) COLUMN(4)\"                                /* @A9 */\n     \"DISPLAY PANEL(\"PANELM2\")\"                               /* @A8 */\n     \"REMPOP\"                                                 /* @A9 */\n  END                                                         /* @AG */\n  IF (SETMSHOW = \"BOTH\") | (SETMSHOW = \"LOG\") THEN DO         /* @AH */\n     zerrsm = \"RACFADM \"REXXPGM\" RC=\"cmd_rc                   /* @AM */\n     zerrlm = cmd                                             /* @AG */\n     'log msg(isrz003)'                                       /* @AG */\n  END                                                         /* @AG */\nRETURN                                                        /* @A5 */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RACFCLSG": {"ttr": 907, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x14c\\x00\\x08\\x01 \\x00?\\x01 \\x17\\x1f\\x07S\\x05R\\x03\\x16\\x00\\x00\\xd9\\xc1\\xc3\\xc6\\xc1\\xc4\\xd4@@@'", "ispf": {"version": "20.99", "flags": 0, "createdate": "2020-01-03T00:00:00", "modifydate": "2020-06-19T07:53:08", "lines": 1362, "newlines": 790, "modlines": 0, "user": "RACFADM"}, "text": "/*%NOCOMMENT====================* REXX *==============================*/\n/*  PURPOSE:  RACFADM - General Resources - Generic class profile     */\n/*--------------------------------------------------------------------*/\n/* FLG  YYMMDD  USERID   DESCRIPTION                                  */\n/* ---  ------  -------  -------------------------------------------- */\n/* @C6  200618  RACFA    Chged SYSDA to SYSALLDA                      */\n/* @C5  200617  RACFA    Added comments to right of variables         */\n/* @C4  200616  RACFA    Added capability to SAve file as TXT/CSV     */\n/* @C3  200610  RACFA    Added primary command 'SAVE'                 */\n/* @C2  200604  RACFA    Fix, prevent from going to top of table      */\n/* @C1  200527  RACFA    Fix, allow typing 'S' on multiple rows       */\n/* @BZ  200520  RACFA    Display line cmd 'P'rofile, when 'Admin=N'   */\n/* @BY  200506  RACFA    Drop array immediately when done using       */\n/* @BX  200504  TRIDJK   Adding, place in order, prior was at bottom  */\n/* @BW  200502  RACFA    Re-worked displaying tables, use DO FOREVER  */\n/* @BV  200501  LBD      Add primary commands FIND/RFIND              */\n/* @BU  200430  RACFA    Chg tblb to TABLEB, moved def. var. up top   */\n/* @BT  200430  RACFA    Chg tbla to TABLEA, moved def. var. up top   */\n/* @BS  200429  RACFA    Re-arranged variables (General, Mgmt, TSO)   */\n/* @BR  200424  RACFA    Updated RESET, pass filter, ex: R filter     */\n/* @BQ  200424  RACFA    Chg msg RACF013 to RACF012                   */\n/* @BP  200424  RACFA    Move DDNAME at top, standardize/del dups     */\n/* @BO  200423  RACFA    Move PARSE REXXPGM name up above IF SETMTRAC */\n/* @BN  200423  RACFA    'Status Interval' by percentage (SETGSTAP)   */\n/* @BM  200422  RACFA    Ensure the REXX program name is 8 chars      */\n/* @BL  200422  RACFA    Use variable REXXPGM in log msg              */\n/* @BK  200413  RACFA    Chg TRACEing to only display banner (P=Pgms) */\n/* @BJ  200412  RACFA    Chg TRACE to allow 'L'abels or 'R'esults     */\n/* @BI  200407  RACFA    EXCMD removed 'else msg_var = 1 to msg.0'    */\n/* @BH  200404  RACFA    'Admin RACF API = Y' then display 'P'rofile  */\n/* @BG  200402  RACFA    Chg LRECL=132 to LRECL=80                    */\n/* @BF  200401  RACFA    Fixed point-n-shoot default sort (RACFCLS5)  */\n/* @BE  200401  RACFA    Create subroutine to VIEW/EDIT/BROWSE        */\n/* @BD  200401  RACFA    Chged edit macro RACFLOGE to RACFEMAC        */\n/* @BC  200401  RACFA    VIEW/EDIT use edit macro, to turn off HILITE */\n/* @BB  200331  RACFA    Deleted variable SELCMDS1/2, now SELCMDS     */\n/* @BA  200331  TRIDJK   Added 'P'rofile to panel                     */\n/* @B9  200330  RACFA    Chg RACFDLS5 point/shoot ascending/descending*/\n/* @B8  200330  RACFA    Allow point-n-shoot sort ascending/descending*/\n/* @B7  200324  RACFA    Allow both display/logging of RACF commands  */\n/* @B6  200324  RACFA    Allow logging RACF commands to ISPF Log file */\n/* @B5  200315  RACFA    Added line cmd 'P=Profile'                   */\n/* @B4  200303  RACFA    Chg 'RC/Ret_code' to 'cmd_rc' after EXCMD    */\n/* @B3  200303  RACFA    Fixed RC and del TBDMOD, not needed          */\n/* @B2  200303  RACFA    Chk RC 'RLIST prms', if RC>0 then 'RLIST'    */\n/* @B1  200303  RACFA    Del CMDPRM and get_setropts_options          */\n/* @AZ  200303  RACFA    Fixed chking RC, del TBMOD, not needed       */\n/* @AY  200302  RACFA    Del TBTOP cmd, prior to TBSCAN for LOCATE    */\n/* @AW  200301  RACFA    Fixed displaying userids, was ret_code       */\n/* @AU  200301  RACFA    Del EMSG procedure, instead call racfmsgs    */\n/* @AT  200226  RACFA    Fix @AR chg, chg ret_code to cmd_rc          */\n/* @AS  200226  RACFA    Added 'CONTROL ERRORS RETURN'                */\n/* @AR  200226  RACFA    Added 'Return Code =' when displaying cmd    */\n/* @AQ  200226  RACFA    Removed double quotes before/after cmd       */\n/* @AP  200225  RACFA    Chg PANEL09=RACFCLS9 to PANEL02=RACFCLS2     */\n/* @AO  200225  TRIDJK   Fix ONLY search argument for profiles        */\n/* @AN  200224  RACFA    Standardize quotes, chg single to double     */\n/* @AM  200224  RACFA    Place panels at top of REXX in variables     */\n/* @AL  200223  RACFA    Deleted panel RACFCLS2, no longer needed     */\n/* @AK  200223  RACFA    Added primary cmds SORT, LOCATE, ONLY, RESET */\n/* @AJ  200223  RACFA    Del 'address TSO \"PROFILE MSGID\"', not needed*/\n/* @AI  200222  RACFA    Allow placing cursor on row and press ENTER  */\n/* @AH  200221  RACFA    Removed \"G = '(G)'\", not referenced          */\n/* @AG  200221  RACFA    Make 'ADDRESS ISPEXEC' defualt, reduce code  */\n/* @AF  200220  RACFA    Fixed displaying all RACF commands           */\n/* @AE  200220  RACFA    When SETMTRAC=YES, then TRACE R, was I       */\n/* @AD  200220  RACFA    Removed initializing SETGSTA variable        */\n/* @AC  200220  RACFA    Added capability to browse/edit/view file    */\n/* @AB  200218  RACFA    Use dynamic area to display SELECT commands  */\n/* @AA  200218  RACFA    Added 'Status Interval' option               */\n/* @A9  200123  RACFA    Retrieve default filter, Option 0 - Settings */\n/* @A8  200123  TRIDJK   If LG fails, then issue a LU                 */\n/* @A7  200122  RACFA    set rfilter='', so as not to tie up terminal */\n/* @A6  200122  TRIDJK   Test/del MFA option from 'LU userid' command */\n/* @A5  200120  RACFA    Removed 'say msg.msg_var' in EXCMD procedure */\n/* @A4  200119  RACFA    Standardized/reduced lines of code           */\n/* @A3  200119  RACFA    Added comment box above procedures           */\n/* @A2  200118  RACFA    Added line command L-List to display group   */\n/* @A1  200118  RACFA    Added line command L-List to execute RLIST   */\n/* @A0  011229  NICORIZ  Created REXX, V2.1, www.rizzuto.it           */\n/*====================================================================*/\nPANEL01     = \"RACFCLS1\"   /* Set filter, menu option 4    */ /* @AM */\nPANEL02     = \"RACFCLS2\"   /* List profiles/descriptions   */ /* @AP */\nPANEL03     = \"RACFCLS3\"   /* Add class                    */ /* @AM */\nPANEL04     = \"RACFCLS4\"   /* Change class                 */ /* @AM */\nPANEL05     = \"RACFCLS5\"   /* List group/ids and access    */ /* @AM */\nPANEL06     = \"RACFCLS6\"   /* Change access                */ /* @AM */\nPANEL07     = \"RACFCLS7\"   /* Add access                   */ /* @AM */\nPANEL12     = \"RACFCLSB\"   /* List members                 */ /* @AM */\nPANEL13     = \"RACFCLSC\"   /* Add class                    */ /* @AM */\nPANELM1     = \"RACFMSG1\"   /* Confirm Request (pop-up)     */ /* @AM */\nPANELM2     = \"RACFMSG2\"   /* Display RACF command and RC  */ /* @AM */\nPANELS1     = \"RACFSAVE\"   /* Obtain DSName to SAVE        */ /* @C3 */\nSKELETON1   = \"RACFCLS2\"   /* Save tablea to dataset       */ /* @C3 */\nSKELETON2   = \"RACFCLS5\"   /* Save tableb to dataset       */ /* @C3 */\nEDITMACR    = \"RACFEMAC\"   /* Edit Macro, turn HILITE off  */ /* @BD */\nTABLEA      = 'TA'RANDOM(0,99999)  /* Unique table name A  */ /* @BT */\nTABLEB      = 'TB'RANDOM(0,99999)  /* Unique table name B  */ /* @BU */\nDDNAME      = 'RACFA'RANDOM(0,999) /* Unique ddname        */ /* @BP */\nNULL        = ''                                              /* @BV */\nparse source . . REXXPGM .         /* Obtain REXX pgm name */ /* @BO */\nREXXPGM     = LEFT(REXXPGM,8)                                 /* @BO */\n\nADDRESS ISPEXEC                                               /* @AG */\n  Arg Rclass Rfilter Rdisp\n  If (Rfilter = '') Then Do                                   /* @A9 */\n     \"VGET (SETGFLTR) PROFILE\"                                /* @A9 */\n     Rfilter = SETGFLTR                                       /* @A9 */\n  end                                                         /* @A9 */\n\n  Raclist       = 'NO'\n  Pnl_list_prof = PANEL02                                     /* @AP */\n  Rclass        = strip(rclass)\n\n  \"CONTROL ERRORS RETURN\"                                     /* @AS */\n  \"VGET (SETGSTA  SETGSTAP SETGDISP SETGCONF\",                /* @BS */\n        \"SETMADMN SETMIRRX SETMSHOW SETMTRAC\"                 /* @BS */\n\n  If (SETMTRAC <> 'NO') then do                               /* @BJ */\n     Say \"*\"COPIES(\"-\",70)\"*\"                                 /* @BJ */\n     Say \"*\"Center(\"Begin Program = \"REXXPGM,70)\"*\"           /* @BJ */\n     Say \"*\"COPIES(\"-\",70)\"*\"                                 /* @BJ */\n     if (SETMTRAC <> 'PROGRAMS') THEN                         /* @BK */\n        interpret \"Trace \"SUBSTR(SETMTRAC,1,1)                /* @BJ */\n  end\n\n  If (SETMADMN = \"YES\") then do                               /* @B5 */\n     IF (SETMIRRX = \"YES\") THEN                               /* @BH */\n        SELCMDS = \"[S]Show,[L]List,[P]Profile,\"||,            /* @BB */\n                  \"[C]Change,[A]Add,[R]Remove\"                /* @B5 */\n     ELSE                                                     /* @BH */\n        SELCMDS = \"[S]Show,[L]List,\"||,                       /* @BH */\n                  \"[C]Change,[A]Add,[R]Remove\"                /* @BH */\n  end                                                         /* @B5 */\n  else do                                                     /* @BZ */\n     IF (SETMIRRX = \"YES\") THEN                               /* @BH */\n        SELCMDS = \"[S]Show,[L]list,[P]Profile\"                /* @BZ */\n     ELSE                                                     /* @BZ */\n        SELCMDS = \"[S]Show,[L]list\"                           /* @AB */\n  end                                                         /* @BZ */\n\n  rlv    = SYSVAR('SYSLRACF')\n  called = SYSVAR('SYSNEST')\n  If (called = 'YES') & (rdisp <> 'YES') then\n     \"CONTROL NONDISPL ENTER\"\n\n  \"DISPLAY PANEL(\"PANEL01\")\"                                  /* @AM */\n  Do while (rc = 0)\n     call Profl\n     if (called <> 'YES') | (rdisp = 'YES') then\n        \"DISPLAY PANEL(\"PANEL01\")\"                            /* @AM */\n  end\n\n  If (raclist = 'YES') then do\n     msg    = 'You are about to refresh class',\n               rclass 'in RACLIST'\n     Sure_? = Confirm_request(msg)\n     if (sure_? = 'YES') then do\n        cmd = \"SETROPTS RACLIST(\"rclass\") REFRESH\"            /* @AF */\n        address TSO cmd                                       /* @AF */\n        cmd_rc = rc                                           /* @AR */\n        if (SETMSHOW <> 'NO') then                            /* @B6 */\n           call SHOWCMD                                       /* @AF */\n     end\n  end\n\n  If (SETMTRAC <> 'NO') then do                               /* @BJ */\n     Say \"*\"COPIES(\"-\",70)\"*\"                                 /* @BJ */\n     Say \"*\"Center(\"End Program = \"REXXPGM,70)\"*\"             /* @BJ */\n     Say \"*\"COPIES(\"-\",70)\"*\"                                 /* @BJ */\n  end                                                         /* @BJ */\nRETURN 0\n/*--------------------------------------------------------------------*/\n/*  Show all profiles for a filter                                    */\n/*--------------------------------------------------------------------*/\nPROFL:\n  Call CREATE_TABLEA\n  opta   = ' '\n  xtdtop = 0                                                  /* @BW */\n  rsels  = 0                                                  /* @BW */\n  do forever                                                  /* @BW */\n     if (rsels < 2) then do                                   /* @BW */\n        \"TBTOP \" TABLEA                                       /* @BW */\n        'tbskip' tablea 'number('xtdtop')'                    /* @BW */\n        radmrfnd = 'PASSTHRU'                                 /* @BW */\n        'vput (radmrfnd)'                                     /* @BW */\n        \"TBDISPL\" TABLEA \"PANEL(\"Pnl_list_prof\")\"             /* @BW */\n     end                                                      /* @BW */\n     else 'tbdispl' tablea                                    /* @BW */\n     if (rc > 4) then leave                                   /* @BW */\n     xtdtop   = ztdtop                                        /* @BW */\n     rsels    = ztdsels                                       /* @BW */\n     radmrfnd = null                                          /* @BW */\n     'vput (radmrfnd)'                                        /* @BW */\n     PARSE VAR ZCMD ZCMD PARM SEQ                             /* @BW */\n     IF (SROW <> \"\") & (SROW <> 0) THEN                       /* @AI */\n        IF (SROW > 0) THEN DO                                 /* @AI */\n           \"TBTOP \" TABLEA                                    /* @AI */\n           \"TBSKIP\" TABLEA \"NUMBER(\"SROW\")\"                   /* @AI */\n        END                                                   /* @AI */\n     if (zcmd = 'RFIND') then do                              /* @BV */\n        zcmd = 'FIND'                                         /* @BV */\n        parm = findit                                         /* @BV */\n        'tbtop ' TABLEA                                       /* @BV */\n        'tbskip' TABLEA 'number('last_find')'                 /* @BV */\n     end                                                      /* @BV */\n     Select                                                   /* @AK */\n        When (abbrev(\"FIND\",zcmd,1) = 1) then                 /* @BV */\n             call do_finda                                    /* @BV */\n        WHEN (ABBREV(\"LOCATE\",ZCMD,1) = 1) THEN do            /* @A5 */\n             if (parm <> '') then do                          /* @BW */\n                locarg = parm'*'                              /* @BW */\n                PARSE VAR SORT . \",\" . \",\" SEQ                /* @BW */\n                IF (SEQ = \"D\") THEN                           /* @BW */\n                   CONDLIST = \"LE\"                            /* @BW */\n                ELSE                                          /* @BW */\n                   CONDLIST = \"GE\"                            /* @BW */\n                parse value sort with scan_field',' .         /* @BW */\n                interpret scan_field ' = locarg'              /* @BW */\n                'tbtop ' tablea                               /* @BW */\n                \"TBSCAN \"TABLEA\" ARGLIST(\"scan_field\")\",      /* @BW */\n                        \"CONDLIST(\"CONDLIST\")\",               /* @BW */\n                        \"position(scanrow)\"                   /* @BW */\n                xtdtop = scanrow                              /* @BW */\n             end                                              /* @BW */\n        end                                                   /* @BW */\n        WHEN (ABBREV(\"ONLY\",ZCMD,1) = 1) THEN DO              /* @AK */\n             find_str = translate(parm)                       /* @AK */\n             'tbtop ' TABLEA                                  /* @AK */\n             'tbskip' TABLEA                                  /* @AK */\n             do forever                                       /* @AK */\n                str = translate(profile data)                 /* @AO */\n                if (pos(find_str,str) > 0) then nop           /* @AK */\n                else 'tbdelete' TABLEA                        /* @AK */\n                'tbskip' TABLEA                               /* @AK */\n                if (rc > 0) then do                           /* @AK */\n                   'tbtop' TABLEA                             /* @AK */\n                   leave                                      /* @AK */\n                end                                           /* @AK */\n             end                                              /* @AK */\n        END                                                   /* @AK */\n        WHEN (ABBREV(\"RESET\",ZCMD,1) = 1) THEN DO             /* @AK */\n             if (parm <> '') then                             /* @BR */\n                rfilter = parm                                /* @BR */\n             sort     = 'PROFILE,C,A'                         /* @AK */\n             sortprof = 'D'; sortdata = 'A'                   /* @B8 */\n             xtdtop   = 1                                     /* @AK */\n             \"TBEND\" TABLEA                                   /* @B8 */\n             call CREATE_TABLEA                               /* @AK */\n        END                                                   /* @AK */\n        When (abbrev(\"SAVE\",zcmd,2) = 1) then DO              /* @C3 */\n             TMPSKELT = SKELETON1                             /* @C3 */\n             call do_SAVE                                     /* @C3 */\n        END                                                   /* @C3 */\n        WHEN (ABBREV(\"SORT\",ZCMD,1) = 1) THEN DO              /* @AK */\n             SELECT                                           /* @AK */\n                when (ABBREV(\"PROFILE\",PARM,1) = 1) then      /* @AK */\n                     call sortseq 'PROFILE'                   /* @B8 */\n                when (ABBREV(\"DESCRIPTION\",PARM,1) = 1) then  /* @AK */\n                     call sortseq 'DATA'                      /* @B8 */\n                otherwise NOP                                 /* @AK */\n             END                                              /* @AK */\n             PARSE VAR SORT LOCARG \",\" .                      /* @BW */\n             CLRPROF = \"GREEN\"; CLRDATA = \"GREEN\"             /* @BW */\n             INTERPRET \"CLR\"SUBSTR(LOCARG,1,4)\" = 'TURQ'\"     /* @BW */\n             \"TBSORT\" TABLEA \"FIELDS(\"sort\")\"                 /* @BW */\n             \"TBTOP \" TABLEA                                  /* @BW */\n        END                                                   /* @AK */\n        otherwise NOP                                         /* @AK */\n     END /* Select */                                         /* @AK */\n     ZCMD = \"\"; PARM = \"\"                                     /* @BW */\n     'control display save'                                   /* @BW */\n     Select\n        when (opta = 'A') then call Addd\n        when (opta = 'C') then call Chgd\n        when (opta = 'L') then call Lisd                      /* @A1 */\n        when (opta = 'M') then call Dism\n        when (opta = 'P') then                                /* @BA */\n             call RACFPROF rclass profile                     /* @BA */\n        when (opta = 'R') then call Deld\n        when (opta = 'S') then call Disd\n        otherwise nop\n     End\n     'control display restore'                                /* @BW */\n  end  /* Do forever) */                                      /* @BW */\nRETURN\n/*--------------------------------------------------------------------*/\n/*  Process primary command FIND for TABLEA                      @BV  */\n/*--------------------------------------------------------------------*/\nDO_FINDA:                                                     /* @BV */\n  if (parm = null) then do                                    /* @BV */\n     racfsmsg = 'Error'                                       /* @BV */\n     racflmsg = 'Find requires a value to search for.' ,      /* @BV */\n                'Try again.'                                  /* @BV */\n     'setmsg msg(RACF011)'                                    /* @BV */\n     return                                                   /* @BV */\n  end                                                         /* @BV */\n  findit    = translate(parm)                                 /* @BV */\n  last_find = 0                                               /* @BV */\n  wrap      = 0                                               /* @BV */\n  do forever                                                  /* @BV */\n     'tbskip' TABLEA                                          /* @BV */\n     if (rc > 0) then do                                      /* @BV */\n        if (wrap = 1) then do                                 /* @BV */\n           racfsmsg = 'Not Found'                             /* @BV */\n           racflmsg = findit 'not found.'                     /* @BV */\n           'setmsg msg(RACF011)'                              /* @BV */\n           return                                             /* @BV */\n        end                                                   /* @BV */\n        if (wrap = 0) then wrap = 1                           /* @BV */\n        'tbtop' TABLEA                                        /* @BV */\n     end                                                      /* @BV */\n     else do                                                  /* @BV */\n        testit = translate(profile data)                      /* @BV */\n        if (pos(findit,testit) > 0) then do                   /* @BV */\n           'tbquery' TABLEA 'position(srow)'                  /* @BV */\n           'tbtop'   TABLEA                                   /* @BV */\n           'tbskip'  TABLEA 'number('srow')'                  /* @BV */\n           last_find = srow                                   /* @BV */\n           xtdtop    = srow                                   /* @BV */\n           if (wrap = 0) then                                 /* @BV */\n              racfsmsg = 'Found'                              /* @BV */\n           else                                               /* @BV */\n              racfsmsg = 'Found/Wrapped'                      /* @BV */\n           racflmsg = findit 'found in row' srow + 0          /* @BV */\n           'setmsg msg(RACF011)'                              /* @BV */\n           return                                             /* @BV */\n        end                                                   /* @BV */\n     end                                                      /* @BV */\n  end                                                         /* @BV */\nRETURN                                                        /* @BV */\n/*--------------------------------------------------------------------*/\n/*  Define sort sequence, to allow point-n-shoot sorting (A/D)   @B8  */\n/*--------------------------------------------------------------------*/\nSORTSEQ:                                                      /* @B8 */\n  parse arg sortcol                                           /* @B8 */\n  INTERPRET \"TMPSEQ = SORT\"substr(SORTCOL,1,4)                /* @B8 */\n  select                                                      /* @B8 */\n     when (seq <> \"\") then do                                 /* @B8 */\n          if (seq = 'A') then                                 /* @B8 */\n             tmpseq = 'D'                                     /* @B8 */\n          else                                                /* @B8 */\n             tmpseq = 'A'                                     /* @B8 */\n          sort = sortcol',C,'seq                              /* @B8 */\n     end                                                      /* @B8 */\n     when (seq = \"\"),                                         /* @B8 */\n        & (tmpseq = 'A') then do                              /* @B8 */\n           sort   = sortcol',C,A'                             /* @B8 */\n           tmpseq = 'D'                                       /* @B8 */\n     end                                                      /* @B8 */\n     Otherwise do                                             /* @B8 */\n        sort   = sortcol',C,D'                                /* @B8 */\n        tmpseq = 'A'                                          /* @B8 */\n     end                                                      /* @B8 */\n  end                                                         /* @B8 */\n  INTERPRET \"SORT\"SUBSTR(SORTCOL,1,4)\" = TMPSEQ\"              /* @B8 */\nRETURN                                                        /* @B8 */\n/*--------------------------------------------------------------------*/\n/*  Add new profile                                                   */\n/*--------------------------------------------------------------------*/\nADDD:\n  new ='NO'\n  if (profile = 'NONE') then\n     new = 'YES'\n  else\n     CALL Getd\n  \"DISPLAY PANEL(\"PANEL03\")\"                                  /* @AM */\n  if (rc > 0) then\n     return\n  if (type = 'DISCRETE') then\n     type = ' '\n  aud = ' '\n  wrn = ' '\n  if (warn = 'YES') then\n     wrn = 'WARNING'\n  if (fail <> ' ') then\n     aud = 'FAILURES('FAIL')'\n  if (succ <> ' ') then\n     aud = 'SUCCESS('SUCC')' aud\n  if (aud <> ' ') then\n     aud = 'AUDIT('AUD')'\n  xtr = ' '\n  if (data <> ' ') then\n     xtr = xtr \"DATA('\"data\"')\"\n  call EXCMD \"RDEF \"RCLASS\" (\"PROFILE\") OWN(\"OWNER\")\",\n             \"UACC(\"UACC\")\" aud xtr wrn\n  if (cmd_rc > 0) then do                                     /* @B4 */\n     CALL racfmsgs 'ERR01' /* Add failed */                   /* @AU */\n     return\n  end\n  x = msg('OFF')\n  call EXCMD \"PE \"PROFILE\" CLASS(\"RCLASS\")\",\n             \"ID(\"USERID()\") DELETE\" TYPE\n  x = msg('ON')\n  if (from <> ' ') then do\n     if (type <> ' ') then ftype = 'FGENERIC'\n     else ftype = ''\n     fopt = \"FROM(\"FROM\") FCLASS(\"FCLASS\") \"FTYPE\"\"\n     call EXCMD \"PERMIT \"PROFILE\" CLASS(\"RCLASS\")\",\n                 TYPE FOPT\n     if (cmd_rc > 0) then                                     /* @B4 */\n        CALL racfmsgs 'ERR04' /* Permit Warn */               /* @AU */\n  end\n  if (type = ' ') then\n     type = 'DISCRETE'\n  \"TBMOD\" TABLEA \"ORDER\"                                      /* @BX */\n  if (new = 'YES') then do\n     profile = 'NONE'\n     type    = 'GEN'\n     \"TBDELETE\"  TABLEA\n  end\nRETURN\n/*--------------------------------------------------------------------*/\n/*  Change profile                                                    */\n/*--------------------------------------------------------------------*/\nCHGD:\n  if (profile = 'NONE') then\n     return\n  CALL Getd\n  \"DISPLAY PANEL(\"PANEL04\")\"                                  /* @AM */\n  if (rc > 0) then return\n  own = ' '\n  if (owner <> ' ') then\n     own = 'OWNER('OWNER')'\n  wrn = ' '\n  if (warn  = 'YES') then\n     wrn = 'WARNING'\n  else\n     wrn = 'NOWARNING'\n  uc = ' '\n  if (uacc <> ' ') then\n     uc = 'UACC('UACC')'\n  aud = ' '\n  if (fail <> ' ') then\n     aud = 'FAILURES('FAIL')'\n  if (succ <> ' ') then\n     aud = 'SUCCESS('SUCC')' aud\n  if (aud  <> ' ') then\n     aud = 'AUDIT('AUD')'\n  xtr = ' '\n  if (data <> ' ') then do\n     if (data = 'NONE') then\n        data = ' '\n     xtr = xtr \"DATA('\"DATA\"')\"\n  end\n  call EXCMD \"RALTER \"RCLASS\" (\"PROFILE\")\",\n             own uc aud xtr wrn\n  if (cmd_rc > 0) then                                        /* @B4 */\n     call racfmsgs 'ERR07' /* Altdsd failed */                /* @AU */\n  else do\n      if (type = ' ') then\n         type = 'DISCRETE'\n      \"TBMOD\" TABLEA\n  end\nRETURN\n/*--------------------------------------------------------------------*/\n/*  Delete Profile                                                    */\n/*--------------------------------------------------------------------*/\nDELD:\n  if (profile = 'NONE') then\n     return\n  if (type = 'DISCRETE') then\n     type = ' '\n  msg    ='You are about to delete 'profile\n  Sure_? = Confirm_request(msg)\n  if (sure_? = 'YES') then do\n     call EXCMD \"RDELETE \"RCLASS PROFILE\n     if (cmd_rc = 0) then do                                  /* @B4 */\n        if type = ' ' then\n           type = 'DISCRETE'\n        \"TBDELETE\" TABLEA\n     end\n     else\n        CALL racfmsgs \"ERR02\" /* RDELETE failed */            /* @AU */\n  end\nRETURN\n/*--------------------------------------------------------------------*/\n/*  Display member list                                               */\n/*--------------------------------------------------------------------*/\nDISM:\n  if (profile = 'NONE') then\n     return\n  \"TBCREATE\" TABLEB \"KEYS(ID) NAMES(ACC) REPLACE NOWRITE\"\n  id = 'NONE'\n  /* Populate table */\n  call GETM\n  /* Permit table display section */\n  rb   = 'NO'\n  optb = ' '\n  /* Ability to perform actions on different profile */\n  Real_profile = profile||rclass\n  Profchg      = 'NO'\n  If (profile||rclass <> Real_profile) then Profchg = 'YES'\n  \"TBSORT \" TABLEB \"FIELDS(ID)\"\n  \"TBTOP  \" TABLEB\n  xtdtop = 0                                                  /* @BW */\n  rsels = 0                                                   /* @BW */\n  do forever                                                  /* @BW */\n     if (rsels < 2) then do                                   /* @BW */\n        \"TBTOP \" TABLEB                                       /* @BW */\n        'tbskip' tableb 'number('xtdtop')'                    /* @BW */\n        radmrfnd = 'PASSTHRU'                                 /* @BW */\n        'vput (radmrfnd)'                                     /* @BW */\n        \"TBDISPL\" TABLEB \"PANEL(\"PANEL12\")\"                   /* @BW */\n     end                                                      /* @BW */\n     else 'tbdispl' tablea                                    /* @BW */\n     if (rc > 4) then leave                                   /* @BW */\n     xtdtop   = ztdtop                                        /* @BW */\n     rsels    = ztdsels                                       /* @BW */\n     radmrfnd = null                                          /* @BW */\n     'vput (radmrfnd)'                                        /* @BW */\n     PARSE VAR ZCMD ZCMD PARM SEQ                             /* @BW */\n     IF (SROW <> \"\") & (SROW <> 0) THEN                       /* @AI */\n        IF (SROW > 0) THEN DO                                 /* @AI */\n           \"TBTOP \" TABLEB                                    /* @AI */\n           \"TBSKIP\" TABLEB \"NUMBER(\"SROW\")\"                   /* @AI */\n        END                                                   /* @AI */\n     ZCMD = \"\"; PARM = \"\"                                     /* @BW */\n     'control display save'                                   /* @BW */\n     Select\n        when (optb = 'A') then call Addm\n        when (optb = 'R') then call Delm\n        otherwise nop\n     End\n     'control display restore'                                /* @BW */\n  end  /* Do forever) */                                      /* @BW */\n  \"TBEND\" TABLEB\nRETURN\n/*--------------------------------------------------------------------*/\n/*  Add member                                                        */\n/*--------------------------------------------------------------------*/\nADDM:\n  new = 'NO'\n  if (id = 'NONE') then\n     new = 'YES'\n  \"DISPLAY PANEL(\"PANEL13\")\"                                  /* @AM */\n  if (rc > 0) then return\n  addmem = 'ADDMEM('id')'\n  call EXCMD \"RALTER \"RCLASS PROFILE ADDMEM\n  if (cmd_rc = 0) then do                                     /* @B4 */\n     \"TBMOD\" TABLEB\n     if (new = 'YES') then do\n        id = 'NONE'\n        \"TBDELETE\" TABLEB\n     end\n  end\n  else call racfmsgs 'ERR10' /* Add member Failed */          /* @AU */\nRETURN\n/*--------------------------------------------------------------------*/\n/*  Remove Member                                                     */\n/*--------------------------------------------------------------------*/\nDELM:\n  if (id = 'NONE') then\n     return\n  msg    ='You are about to delete 'id\n  Sure_? = Confirm_request(msg)\n  if (sure_? = 'YES') then do\n     delmem = 'DELMEM('id')'\n     call EXCMD \"RALTER \"RCLASS PROFILE DELMEM\n     if (cmd_rc = 0) then                                     /* @B4 */\n        \"TBDELETE\" TABLEB\n     else\n        CALL racfmsgs \"ERR14\"   /* RDELETE failed */          /* @AU */\n  end\nRETURN\n/*--------------------------------------------------------------------*/\n/*  Get member list                                                   */\n/*--------------------------------------------------------------------*/\nGETM:\n  cmd = \"RLIST \"RCLASS PROFILE\" AUTH\"                         /* @AF */\n  x = OUTTRAP('var.')\n  address TSO cmd                                             /* @AF */\n  cmd_rc = rc                                                 /* @AR */\n  x = OUTTRAP('OFF')\n  if (SETMSHOW <> 'NO') then                                  /* @B6 */\n     call SHOWCMD                                             /* @AF */\n  dism_max = var.0\n  rsce_beg = 0\n  rsce_end = 0\n  Do dism_count=0 to dism_max\n     rsce_beg = POS('RESOURCES IN GROUP',var.dism_count)\n     if rsce_beg then\n        do until rsce_end\n           dism_count = dism_count+1\n           parse var var.dism_count id rest\n           rsce_end = POS('LEVEL  OWNER',var.dism_count)\n           if (id <> '') & (id <> '---------') & \u00acrsce_end\n             then \"TBMOD\" TABLEB\n        end\n  end\nRETURN\n/*--------------------------------------------------------------------*/\n/*  Display profile permits                                           */\n/*--------------------------------------------------------------------*/\nDISD:\n  if (profile = 'NONE') then\n     return\n  tmpsort   = sort                                            /* @B9 */\n  tmprsels  = rsels                                           /* @C1 */\n  tmpxtdtop = xtdtop                                          /* @C2 */\n  Do until (RB='NO')     /* allow rebuild option */\n     call create_TABLEB                                       /* @B9 */\n     Real_profile = profile||rclass\n     rb      = 'NO'\n     Profchg = 'NO'\n     xtdtop  = 0                                              /* @BW */\n     rsels   = 0                                              /* @BW */\n     do forever                                               /* @BW */\n        if (rsels < 2) then do                                /* @BW */\n           optb = ' '                                         /* @BW */\n           \"TBTOP \" TABLEB                                    /* @BW */\n           'tbskip' tableb 'number('xtdtop')'                 /* @BW */\n           radmrfnd = 'PASSTHRU'                              /* @BW */\n           'vput (radmrfnd)'                                  /* @BW */\n           \"TBDISPL\" TABLEB \"PANEL(\"PANEL05\")\"                /* @BW */\n        end                                                   /* @BW */\n        else 'tbdispl' tableb                                 /* @BW */\n        retb = rc                                             /* @BW */\n        if (retb > 4) then leave                              /* @BW */\n        xtdtop   = ztdtop                                     /* @BW */\n        rsels    = ztdsels                                    /* @BW */\n        radmrfnd = null                                       /* @BW */\n        'vput (radmrfnd)'                                     /* @BW */\n        PARSE VAR ZCMD ZCMD PARM SEQ                          /* @BW */\n        IF (SROW <> \"\") & (SROW <> 0) THEN                    /* @AI */\n           IF (SROW > 0) THEN DO                              /* @AI */\n              \"TBTOP \" TABLEB                                 /* @AI */\n              \"TBSKIP\" TABLEB \"NUMBER(\"SROW\")\"                /* @AI */\n           END                                                /* @AI */\n        if (zcmd = 'RFIND') then do                           /* @BV */\n           zcmd = 'FIND'                                      /* @BV */\n           parm = findit                                      /* @BV */\n           'tbtop ' TABLEB                                    /* @BV */\n           'tbskip' TABLEB 'number('last_find')'              /* @BV */\n        end                                                   /* @BV */\n        Select                                                /* @B9 */\n           When (abbrev(\"FIND\",zcmd,1) = 1) then              /* @BV */\n                call do_findb                                 /* @BV */\n           WHEN (ABBREV(\"LOCATE\",ZCMD,1) = 1) THEN DO         /* @BW */\n                if (parm <> '') then do                       /* @BW */\n                   locarg = parm'*'                           /* @BW */\n                   PARSE VAR SORT . \",\" . \",\" SEQ             /* @BW */\n                   IF (SEQ = \"D\") THEN                        /* @BW */\n                      CONDLIST = \"LE\"                         /* @BW */\n                   ELSE                                       /* @BW */\n                      CONDLIST = \"GE\"                         /* @BW */\n                   parse value sort with scan_field',' .      /* @BW */\n                   interpret scan_field ' = locarg'           /* @BW */\n                   'tbtop ' tableb                            /* @BW */\n                   \"TBSCAN \"TABLEB\" ARGLIST(\"scan_field\")\",   /* @BW */\n                           \"CONDLIST(\"CONDLIST\")\",            /* @BW */\n                           \"position(scanrow)\"                /* @BW */\n                   xtdtop = scanrow                           /* @BW */\n                end                                           /* @BW */\n           end                                                /* @BW */\n           WHEN (ABBREV(\"ONLY\",ZCMD,1) = 1) THEN DO           /* @B9 */\n                find_str = translate(parm)                    /* @B9 */\n                'tbtop ' TABLEB                               /* @B9 */\n                'tbskip' TABLEB                               /* @B9 */\n                do forever                                    /* @B9 */\n                   str = translate(id acc)                    /* @B9 */\n                   if (pos(find_str,str) > 0) then nop        /* @B9 */\n                   else 'tbdelete' TABLEB                     /* @B9 */\n                   'tbskip' TABLEB                            /* @B9 */\n                   if (rc > 0) then do                        /* @B9 */\n                      'tbtop' TABLEB                          /* @B9 */\n                      leave                                   /* @B9 */\n                   end                                        /* @B9 */\n                end                                           /* @B9 */\n           END                                                /* @B9 */\n           WHEN (ABBREV(\"RESET\",ZCMD,1) = 1) THEN DO          /* @B9 */\n                if (parm <> '') then                          /* @BR */\n                   rfilter = parm                             /* @BR */\n                SORT   = 'ID,C,A'                             /* @B9 */\n                sortid = 'D'; sortacc = 'A'                   /* @B9 */\n                xtdtop   = 1                                  /* @B9 */\n                \"TBEND\" TABLEB                                /* @B9 */\n                call create_TABLEB                            /* @B9 */\n           END                                                /* @B9 */\n           When (abbrev(\"SAVE\",zcmd,2) = 1) then DO           /* @C3 */\n                TMPSKELT = SKELETON2                          /* @C3 */\n                call do_SAVE                                  /* @C3 */\n           END                                                /* @C3 */\n           WHEN (ABBREV(\"SORT\",ZCMD,1) = 1) THEN DO           /* @B9 */\n                SELECT                                        /* @B9 */\n                   when (ABBREV(\"GROUP\",PARM,1) = 1) then     /* @B9 */\n                        call sortseq 'ID'                     /* @B9 */\n                   when (ABBREV(\"ID\",PARM,1) = 1) then        /* @B9 */\n                        call sortseq 'ID'                     /* @B9 */\n                   when (ABBREV(\"ACCESS\",PARM,1) = 1) then    /* @B9 */\n                        call sortseq 'ACC'                    /* @B9 */\n                   otherwise NOP                              /* @B9 */\n                END                                           /* @B9 */\n                PARSE VAR SORT LOCARG \",\" .                   /* @BW */\n                CLRID = \"GREEN\"; CLRACC = \"GREEN\"             /* @BW */\n                INTERPRET \"CLR\"SUBSTR(LOCARG,1,4)\" = 'TURQ'\"  /* @BW */\n                \"TBSORT\" TABLEB \"FIELDS(\"sort\")\"              /* @BW */\n                \"TBTOP \" TABLEB                               /* @BW */\n           END                                                /* @B9 */\n           otherwise NOP                                      /* @B9 */\n        END /* Select */                                      /* @B9 */\n        ZCMD = \"\"; PARM = \"\"                                  /* @BW */\n        'control display save'                                /* @BW */\n        Select\n           when (optb = 'A') then call Addp\n           when (optb = 'C') then call Chgp\n           when (optb = 'L') then call Lisp                   /* @A2 */\n           when (optb = 'P') then                             /* @B5 */\n                call RACFPROF 'GROUP' ID                      /* @B5 */\n           when (optb = 'R') then call Delp\n           when (optb = 'S') then call Disp\n           otherwise nop\n        End\n        'control display restore'                             /* @BW */\n     end  /* Do forever) */                                   /* @BW */\n     \"TBEND\" TABLEB\n  end  /* Do until */\n  sort   = tmpsort                                            /* @B9 */\n  rsels  = tmprsels                                           /* @C1 */\n  xtdtop = tmpxtdtop                                          /* @C2 */\nRETURN\n/*--------------------------------------------------------------------*/\n/*  Process primary command FIND for TABLEB                      @BV  */\n/*--------------------------------------------------------------------*/\nDO_FINDB:                                                     /* @BV */\n  if (parm = null) then do                                    /* @BV */\n     racfsmsg = 'Error'                                       /* @BV */\n     racflmsg = 'Find requires a value to search for.' ,      /* @BV */\n                'Try again.'                                  /* @BV */\n     'setmsg msg(RACF011)'                                    /* @BV */\n     return                                                   /* @BV */\n  end                                                         /* @BV */\n  findit    = translate(parm)                                 /* @BV */\n  last_find = 0                                               /* @BV */\n  wrap      = 0                                               /* @BV */\n  do forever                                                  /* @BV */\n     'tbskip' TABLEB                                          /* @BV */\n     if (rc > 0) then do                                      /* @BV */\n        if (wrap = 1) then do                                 /* @BV */\n           racfsmsg = 'Not Found'                             /* @BV */\n           racflmsg = findit 'not found.'                     /* @BV */\n           'setmsg msg(RACF011)'                              /* @BV */\n           return                                             /* @BV */\n        end                                                   /* @BV */\n        if (wrap = 0) then wrap = 1                           /* @BV */\n        'tbtop' TABLEB                                        /* @BV */\n     end                                                      /* @BV */\n     else do                                                  /* @BV */\n        testit = translate(id acc)                            /* @BV */\n        if (pos(findit,testit) > 0) then do                   /* @BV */\n           'tbquery' TABLEB 'position(srow)'                  /* @BV */\n           'tbtop'   TABLEB                                   /* @BV */\n           'tbskip'  TABLEB 'number('srow')'                  /* @BV */\n           last_find = srow                                   /* @BV */\n           xtdtop    = srow                                   /* @BV */\n           if (wrap = 0) then                                 /* @BV */\n              racfsmsg = 'Found'                              /* @BV */\n           else                                               /* @BV */\n              racfsmsg = 'Found/Wrapped'                      /* @BV */\n           racflmsg = findit 'found in row' srow + 0          /* @BV */\n           'setmsg msg(RACF011)'                              /* @BV */\n           return                                             /* @BV */\n        end                                                   /* @BV */\n     end                                                      /* @BV */\n  end                                                         /* @BV */\nRETURN                                                        /* @BV */\n/*--------------------------------------------------------------------*/\n/*  Create table 'B'                                             @B9  */\n/*--------------------------------------------------------------------*/\nCREATE_TABLEB:                                                /* @B9 */\n  \"TBCREATE\" TABLEB \"KEYS(ID)\",\n                  \"NAMES(ACC) REPLACE NOWRITE\"\n  flags = 'OFF'\n  audit = ' '\n  owner = ' '\n  uacc  = ' '\n  data  = ' '\n  warn  = ' '\n  if (type = 'DISCRETE') then\n     type = ' '\n  cmd = \"RLIST \"RCLASS PROFILE\" AUTH\"                         /* @AF */\n  x = OUTTRAP('VAR.')\n  address TSO cmd                                             /* @AF */\n  cmd_rc = rc                                                 /* @AR */\n  x = OUTTRAP('OFF')\n  if (SETMSHOW <> 'NO') then                                  /* @B6 */\n     call SHOWCMD                                             /* @AF */\n  if (type = ' ') then\n     type = 'DISCRETE'\n  Do i = 1 to var.0                /* Scan output */\n     temp = var.i\n     if (rlv > '1081') then  /* RACF 1.9 add blank */\n        temp= ' 'temp\n     l = LENGTH(temp)\n     if (uacc = ' ') then\n        if (substr(temp,2,12)= 'LEVEL  OWNER') then do\n           i     = i + 2\n           temp  = var.i\n           owner = subword(temp,2,1)\n           uacc  = subword(temp,3,1)\n           warn  = subword(temp,5,1)\n        end\n     if (audit = ' ') then\n        if (substr(temp,2,8) = 'AUDITING') then do\n           i     = i + 2\n           temp  = var.i\n           audit = subword(temp,1,1)\n        end\n     if (data = ' ') then\n        if (substr(temp,2,17) = 'INSTALLATION DATA') then do\n           i    = i + 2\n           temp = var.i\n           data = temp\n           i    = i + 1\n           temp = var.i\n           data = data || substr(temp,2)\n        end\n     if (flags = 'ON') then do\n        if (l = 1) | (l = 2) then\n           flags = 'OUT'     /* end of access list */\n        if (l > 8) then\n           if (substr(temp,1,9) = ' ') then\n              flags = 'OUT'  /* end of access list */\n     end\n     if (flags = 'ON') then do\n        if (substr(temp,2,10) = 'NO ENTRIES') then do\n           id  = 'NONE'       /* empty access list */\n           acc = 'DEFINED'\n        end\n        else do\n           id  = subword(temp,1,1)\n           acc = subword(temp,2,1)\n        end\n        \"TBMOD\" TABLEB\n     end\n     if (substr(temp,1,17) = 'USER      ACCESS') then do\n        flags = 'ON'   /* start of access list */\n        i     = i + 1      /* skip */\n     end\n  end  /* Loop scan output */\n  sort     = 'ID,C,A'                                         /* @BW */\n  sortid   = 'D'; sortacc  = 'A'                              /* @BW */\n  CLRID = \"TURQ\"; CLRACC = \"GREEN\"   /* Col. colors */        /* @BW */\n  \"TBSORT \" TABLEB \"FIELDS(\"sort\")\"                           /* @BW */\n  \"TBTOP  \" TABLEB                                            /* @BW */\nRETURN                                                        /* @B9 */\n/*--------------------------------------------------------------------*/\n/*  Get RLIST info                                                    */\n/*--------------------------------------------------------------------*/\nGETD:\n  flags  = 'OFF'\n  owner  = ' '\n  uacc   = ' '\n  audit  = ' '\n  data   = ' '\n  warn   = ' '\n  memcls = ' '\n  cmd    = \"RLIST \"RCLASS PROFILE                             /* @AF */\n  x = OUTTRAP('getd_var.')\n  address TSO cmd                                             /* @AF */\n  cmd_rc = rc                                                 /* @AR */\n  x = OUTTRAP('OFF')\n  if (SETMSHOW <> 'NO') then                                  /* @B6 */\n     call SHOWCMD                                             /* @AF */\n  Do getd_i = 1 to getd_var.0 while (flags<> 'OUT') /* Scan output */\n     getd_temp = getd_var.getd_i\n     if (rlv > '1081') then         /* RACF 1.9 add blank */\n        getd_temp= ' 'getd_temp\n     if (uacc = ' ') then\n        if (substr(getd_temp,2,12) = 'LEVEL  OWNER') then do\n           getd_i    = getd_i + 2\n           getd_temp = getd_var.getd_i\n           owner     = subword(getd_temp,2,1)\n           uacc      = subword(getd_temp,3,1)\n           warn      = subword(getd_temp,5,1)\n        end\n     if (memcls = ' ') then\n        if (substr(getd_temp,2,17) = 'MEMBER CLASS NAME') then do\n           getd_i        = getd_i + 2\n           getd_temp     = getd_var.getd_i\n           memcls        = subword(getd_temp,1,1)\n           If (SETMADMN = \"YES\") then                         /* @AL */\n               SELCMDS = \"[S]Show,[L]list,[C]Change,\"||,      /* @AL */\n                         \"[A]dd,[R]Remove,[M]Member\"          /* @AL */\n           else                                               /* @AL */\n               SELCMDS = \"[S]Show,[L]list\"                    /* @AL */\n        end\n     if (audit = ' ') then\n        if (substr(getd_temp,2,8) = 'AUDITING') then do\n           getd_i    = getd_i + 2\n           getd_temp = getd_var.getd_i\n           audit     = subword(getd_temp,1,1)\n        end\n     if (data = ' ') then\n        if (substr(getd_temp,2,17) = 'INSTALLATION DATA') then do\n           getd_i        = getd_i + 2\n           getd_temp     = getd_var.getd_i\n           data_1st_line = getd_temp\n           getd_i        = getd_i+ 1\n           getd_temp     = getd_var.getd_i\n           data_2nd_line = getd_temp\n           data = data_1st_line||strip(data_2nd_line,'t')\n        end\n  end  /* Getd_i= 1 do */\n\n  a = INDEX(audit,'ALL')\n  if (a > 0) then do\n     fail = substr(audit,a+4,7)\n     succ = substr(audit,a+4,7)\n  end\n  else do\n     f = INDEX(audit,'FAILURES')\n     if (f > 0) then\n        fail = substr(audit,f+9,7)\n     s = INDEX(audit,'SUCCESS')\n     if (s > 0) then\n        succ = substr(audit,s+8,7)\n  end\nRETURN\n/*--------------------------------------------------------------------*/\n/*  Change permit option                                              */\n/*--------------------------------------------------------------------*/\nCHGP:\n  If (id = 'NONE') then\n     return\n  \"DISPLAY PANEL(\"PANEL06\")\"                                  /* @AM */\n  if (rc > 0) then\n     return\n  if (type = 'DISCRETE') then\n     type = ' '\n  call EXCMD \"PE \"PROFILE\" CLASS(\"RCLASS\")\",\n             \"ID(\"ID\") ACC(\"ACC\")\" TYPE\n  if (cmd_rc = 0) then do                                     /* @B4 */\n     if (type = ' ') then\n        type = 'DISCRETE'\n     \"TBMOD\" TABLEB\n  end\n  else\n     Call racfmsgs 'ERR03' /* Permit failed */                /* @AU */\nRETURN\n/*--------------------------------------------------------------------*/\n/*  Display userid                                                    */\n/*--------------------------------------------------------------------*/\nDISP:\n  x   = msg('OFF')\n  cmd = \"LU \"id                                               /* @AF */\n  x = OUTTRAP('trash.')\n  address TSO cmd                                             /* @AF */\n  cmd_rc = rc\n  x = OUTTRAP('OFF')\n  if (SETMSHOW <> 'NO') then                                  /* @B6 */\n     call SHOWCMD                                             /* @AF */\n  x = msg('ON')\n  if (cmd_rc = 0) then call RACFUSR id                        /* @AW */\n  else call RACFGRP id\nRETURN\n/*--------------------------------------------------------------------*/\n/*  Add permit option                                                 */\n/*--------------------------------------------------------------------*/\nADDP:\n  new = 'NO'\n  if (id = 'NONE') then\n     new = 'YES'\n  from = ' '\n  \"DISPLAY PANEL(\"PANEL07\")\"                                  /* @AM */\n  if (rc > 0) then\n     return\n  if (type = 'DISCRETE') then\n     type = ' '\n  idopt = ' '\n  if (id <> ' ') then\n     idopt = 'ID('ID') ACCESS('ACC')'\n  fopt = ' '\n  if (from <> ' ') then do\n     fopt = \"FROM('\"FROM\"') FCLASS(\"RCLASS\") FGENERIC\"\n     rb   = 'YES'             /* Cause table rebuild */\n  end\n  call EXCMD \"PERMIT \"PROFILE\" CLASS(\"RCLASS\") \",\n              idopt type fopt\n  if (cmd_rc = 0) then do                                     /* @B4 */\n     \"TBMOD\" TABLEB\n     if (new = 'YES') then do\n        id = 'NONE'\n        \"TBDELETE\" TABLEB\n     end\n  end\n  else do\n     if (from <> ' ') then\n        call racfmsgs 'ERR04' /* Permit Warning/Failed */     /* @AU */\n     else\n        call racfmsgs 'ERR05' /* Permit Failed */             /* @AU */\n  end\nRETURN\n/*--------------------------------------------------------------------*/\n/*  Delete permit option                                              */\n/*--------------------------------------------------------------------*/\nDELP:\n  if (id = 'NONE') then\n     return\n  if (type = 'DISCRETE') then\n     type = ' '\n  msg    ='You are about to delete access for 'ID\n  Sure_? = Confirm_request(msg)\n  if (sure_? = 'YES') then do\n     call EXCMD \"PE \"PROFILE\" CLASS(\"RCLASS\")\",\n                \"ID(\"ID\") DELETE\" TYPE\n     if (cmd_rc = 0) then                                     /* @B4 */\n        \"TBDELETE\" TABLEB\n     else\n        call racfmsgs 'ERR06'     /* Permit Failed */         /* @AU */\n  end\nRETURN\n/*--------------------------------------------------------------------*/\n/*  Confirm delete                                                    */\n/*--------------------------------------------------------------------*/\nCONFIRM_REQUEST:\n  signal off error\n  arg message\n  answer  = 'NO'\n  zwinttl = 'CONFIRM REQUEST'\n  ckey    = ''\n  if (SETGCONF ='NO') then ckey = 'ENTER'\n  Do while (ckey <> 'PF03') & (ckey <> 'ENTER')\n     \"CONTROL NOCMD\"                                          /* @AN */\n     \"ADDPOP\"                                                 /* @AN */\n     \"DISPLAY PANEL(\"PANELM1\")\"                               /* @AM */\n     \"REMPOP\"                                                 /* @AN */\n  end\n  Select\n     when (ckey = 'PF03')  then answer = 'NO'\n     when (ckey = 'ENTER') then answer = 'YES'\n     otherwise nop\n  End\n  zwinttl = ' '\nRETURN answer\n/*--------------------------------------------------------------------*/\n/*  Exec command                                                      */\n/*--------------------------------------------------------------------*/\nEXCMD:\n  signal off error\n  arg cmd\n  x = OUTTRAP('msg.')\n  address TSO cmd                                             /* @AQ */\n  cmd_rc = rc\n  x = OUTTRAP('OFF')\n  if (SETMSHOW <> 'NO') then                                  /* @B6 */\n     call SHOWCMD                                             /* @AF */\n  if (subword(msg.1,1,1) = 'ICH11009I') |,\n     (subword(msg.1,1,1) = 'ICH10006I') |,\n     (subword(msg.1,1,1) = 'ICH06011I') then raclist = 'YES'\nRETURN\n/*--------------------------------------------------------------------*/\n/*  List class's profile                                              */\n/*--------------------------------------------------------------------*/\nLISD:                                                         /* @A1 */\n  cmd = \"RLIST \"RCLASS PROFILE\" AUTH\"                         /* @AF */\n  X = OUTTRAP(\"CMDREC.\")                                      /* @A1 */\n  ADDRESS TSO cmd                                             /* @AF */\n  cmd_rc = rc                                                 /* @AR */\n  X = OUTTRAP(\"OFF\")                                          /* @A1 */\n  if (SETMSHOW <> 'NO') then                                  /* @B6 */\n     call SHOWCMD                                             /* @AF */\n  if (cmd_rc > 0) then do    /* Remove parms */               /* @B2 */\n     cmd = \"RLIST \"RCLASS PROFILE                             /* @B2 */\n     X = OUTTRAP(\"CMDREC.\")                                   /* @B2 */\n     ADDRESS TSO cmd                                          /* @B2 */\n     cmd_rc = rc                                              /* @B2 */\n     X = OUTTRAP(\"OFF\")                                       /* @B2 */\n     if (SETMSHOW <> 'NO') then                               /* @B6 */\n        call SHOWCMD                                          /* @B2 */\n  end                                                         /* @B2 */\n  call display_info                                           /* @BE */\n  if (cmd_rc > 0) then                                        /* @AZ */\n     CALL racfmsgs \"ERR10\" /* Generic failure */              /* @AU */\nRETURN                                                        /* @A1 */\n/*--------------------------------------------------------------------*/\n/*  Set boolean value for mask                                        */\n/*--------------------------------------------------------------------*/\nSETBOOL:\n  variable = arg(1)                                           /* @A6 */\n  offset   = arg(2)                                           /* @A6 */\n  value    = arg(3)                                           /* @A6 */\n  status1  = arg(4)                                           /* @A6 */\n  status2  = arg(5)                                           /* @A6 */\n  interpret \"rcvtsta$= d2x((x2d(\"cvtrac\"))+\"offset\")\"         /* @A6 */\n  x        = storage(rcvtsta$,1)                              /* @A6 */\n  interpret variable '= 'status1                              /* @A6 */\n  interpret \"x=bitand(x,'\"value\"'x)\" /*remove bad bits*/      /* @A6 */\n  interpret \"if (x= '\"value\"'x) then \"variable\"=\"status2      /* @A6 */\nRETURN 0                                                      /* @A6 */\n/*--------------------------------------------------------------------*/\n/*  List group                                                        */\n/*--------------------------------------------------------------------*/\nLISP:                                                         /* @A2 */\n  CMDPRM  = \"CSDATA DFP OMVS OVM TME\"                         /* @A2 */\n  cmd     = \"LG \"ID CMDPRM                                    /* @AF */\n  X = OUTTRAP(\"CMDREC.\")                                      /* @A2 */\n  ADDRESS TSO cmd                                             /* @AF */\n  cmd_rc = rc                                                 /* @AR */\n  X = OUTTRAP(\"OFF\")                                          /* @A2 */\n  if (SETMSHOW <> 'NO') then                                  /* @B6 */\n     call SHOWCMD                                             /* @AF */\n  if (cmd_rc > 0) then do                                     /* @A8 */\n     X = OUTTRAP(\"CMDREC.\")                                   /* @A2 */\n     CMD     = \"LU \"ID                                        /* @AF */\n     ADDRESS TSO cmd                                          /* @AR */\n     cmd_rc = rc                                              /* @AR */\n     X = OUTTRAP(\"OFF\")                                       /* @A2 */\n     if (SETMSHOW <> 'NO') then                               /* @B6 */\n        call SHOWCMD                                          /* @AF */\n  end                                                         /* @A8 */\n  call display_info                                           /* @BE */\n  if (cmd_rc > 0) then                                        /* @B3 */\n     CALL racfmsgs \"ERR13\"   /* Generic failure */            /* @AU */\nRETURN                                                        /* @A2 */\n/*--------------------------------------------------------------------*/\n/*  Display information from line commands 'L' and 'P'           @BE  */\n/*--------------------------------------------------------------------*/\nDISPLAY_INFO:                                                 /* @BE */\n  ADDRESS TSO \"ALLOC F(\"DDNAME\") NEW REUSE\",                  /* @A2 */\n              \"LRECL(80) BLKSIZE(0) RECFM(F B)\",              /* @BG */\n              \"UNIT(VIO) SPACE(1 5) CYLINDERS\"                /* @A2 */\n  ADDRESS TSO \"EXECIO * DISKW \"DDNAME\" (STEM CMDREC. FINIS\"   /* @A2 */\n  DROP CMDREC.                                                /* @BY */\n                                                              /* @BY */\n  \"LMINIT DATAID(CMDDATID) DDNAME(\"DDNAME\")\"                  /* @A2 */\n  SELECT                                                      /* @AC */\n     WHEN (SETGDISP = \"VIEW\") THEN                            /* @AC */\n          \"VIEW DATAID(\"CMDDATID\") MACRO(\"EDITMACR\")\"         /* @BC */\n     WHEN (SETGDISP = \"EDIT\") THEN                            /* @AC */\n          \"EDIT DATAID(\"CMDDATID\") MACRO(\"EDITMACR\")\"         /* @BC */\n     OTHERWISE                                                /* @AC */\n          \"BROWSE DATAID(\"CMDDATID\")\"                         /* @AC */\n  END                                                         /* @AC */\n  ADDRESS TSO \"FREE FI(\"DDNAME\")\"                             /* @A2 */\nRETURN                                                        /* @BE */\n/*--------------------------------------------------------------------*/\n/*  Display RACF command and return code                         @AF  */\n/*--------------------------------------------------------------------*/\nSHOWCMD:                                                      /* @AF */\n  IF (SETMSHOW = \"BOTH\") | (SETMSHOW = \"DISPLAY\") THEN DO     /* @B7 */\n     PARSE VAR CMD MSG1 60 MSG2 121 MSG3                      /* @AF */\n     MSG4 = \"Return code = \"cmd_rc                            /* @AR */\n     \"ADDPOP ROW(6) COLUMN(4)\"                                /* @AN */\n     \"DISPLAY PANEL(\"PANELM2\")\"                               /* @AM */\n     \"REMPOP\"                                                 /* @AN */\n  END                                                         /* @B6 */\n  IF (SETMSHOW = \"BOTH\") | (SETMSHOW = \"LOG\") THEN DO         /* @B7 */\n     zerrsm = \"RACFADM \"REXXPGM\" RC=\"cmd_rc                   /* @BL */\n     zerrlm = cmd                                             /* @B6 */\n     'log msg(isrz003)'                                       /* @B6 */\n  END                                                         /* @B6 */\nRETURN                                                        /* @AF */\n/*--------------------------------------------------------------------*/\n/*  Create table 'A'                                             @AK  */\n/*--------------------------------------------------------------------*/\nCREATE_TABLEA:\n  seconds = TIME('S')\n  \"TBCREATE\" TABLEA \"KEYS(PROFILE TYPE)\",\n                  \"NAMES(RCLASS DATA) REPLACE NOWRITE\"\n  cmd = \"SEARCH FILTER(\"RFILTER\") CLASS(\"rclass\")\"            /* @AF */\n  x = OUTTRAP('var.')\n  address TSO cmd                                             /* @AF */\n  cmd_rc = rc                                                 /* @AR */\n  x = OUTTRAP('OFF')\n  if (SETMSHOW <> 'NO') then                                  /* @B6 */\n     call SHOWCMD                                             /* @AF */\n  if (SETGSTAP <> \"\") THEN                                    /* @BN */\n     INTERPRET \"RECNUM = var.0*.\"SETGSTAP\"%1\"                 /* @BN */\n  Do i = 1 to var.0\n     temp    = var.i\n     profile = SUBWORD(temp,1,1)\n     t       = INDEX(temp,g)\n     if (t > 0) then\n        type = 'GEN'\n     else do\n        type = 'DISCRETE'\n        msgr = SUBWORD(temp,1,1)\n        Select\n           when (msgr = 'ICH31005I') then do\n                profile = 'NONE'     /* No profiles */\n                type    = 'GEN'\n           end\n           when (msgr = 'ICH31009I') then do\n                profile = 'INVALID'  /* Bad filter  */\n                call racfmsgs 'ERR08'                         /* @AU */\n           end\n           when (msgr = 'ICH31012I') then do\n                profile = 'INVALID'  /* Bad filter  */\n                call racfmsgs 'ERR08'                         /* @AU */\n           end\n           when (msgr = 'ICH31014I') then do\n                profile = 'INVALID'  /* Bad filter  */\n                call racfmsgs 'ERR08'                         /* @AU */\n           end\n           when (msgr = 'ICH31016I') then do\n                profile = 'INVALID'  /* Bad filter  */\n                call racfmsgs 'ERR08'                         /* @AU */\n           end\n           when (msgr = 'ICH31017I') then do\n                profile = 'INVALID'  /* Bad filter  */\n                call racfmsgs 'ERR08'                         /* @AU */\n           end\n           when (msgr= 'ICH31018I') then do\n                profile = 'INVALID'  /* Bad filter  */\n                call racfmsgs 'ERR08'                         /* @AU */\n           end\n           when (msgr = 'IKJ56716I') then do\n                profile = 'INVALID'  /* Bad filter  */\n                call racfmsgs 'ERR08'                         /* @AU */\n           end\n           when (substr(msgr,1,6) = 'ICH310') then do\n                type = ' '           /* Misc. errs  */\n                call racfmsgs 'ERR09'                         /* @AU */\n           end\n           otherwise nop\n        End  /* Select */\n     end  /* Else */\n     /*---------------------------------------------*/\n     /* Display number of records retrieved        -*/\n     /*---------------------------------------------*/\n     IF (SETGSTA = \"\") THEN DO                                /* @BN */\n        IF (RECNUM <> 0) THEN                                 /* @BN */\n           IF (I//RECNUM = 0) THEN DO                         /* @BN */\n              n1 = i; n2 = var.0                              /* @BN */\n              pct = ((n1/n2)*100)%1'%'                        /* @BN */\n              \"control display lock\"                          /* @BN */\n              \"display msg(RACF012)\"                          /* @BQ */\n           END                                                /* @BN */\n     END                                                      /* @BN */\n     ELSE DO                                                  /* @BN */\n        IF (SETGSTA <> 0) THEN                                /* @BN */\n           IF (I//SETGSTA = 0) THEN DO                        /* @AA */\n              n1 = i; n2 = var.0\n              pct = ((n1/n2)*100)%1'%'                        /* @BN */\n              \"control display lock\"\n              \"display msg(RACF012)\"                          /* @BQ */\n           END                                                /* @AA */\n     END                                                      /* @BN */\n     /* Get Further information */\n     call GETD\n     \"TBMOD\" TABLEA\n  end  /* Do i=1 to var.0 */\n  if (profile = 'INVALID') then do\n     \"TBEND\" TABLEA\n     return\n  end\n  sort     = 'PROFILE,C,A'                                    /* @BW */\n  sortprof = 'D'; sortdata = 'A'                              /* @BW */\n  CLRPROF = \"TURQ\"; CLRDATA = \"GREEN\"   /* Col. colors */     /* @BW */\n  \"TBSORT \" TABLEA \"FIELDS(\"sort\")\"                           /* @BW */\n  \"TBTOP  \" TABLEA                                            /* @BW */\nRETURN                                                        /* @AK */\n/*--------------------------------------------------------------------*/\n/*  Save table to dataset                                        @C3  */\n/*--------------------------------------------------------------------*/\nDO_SAVE:                                                      /* @C3 */\n  X = MSG(\"OFF\")                                              /* @C3 */\n  \"ADDPOP COLUMN(40)\"                                         /* @C3 */\n  \"VGET (RACFSDSN RACFSMBR RACFSFIL RACFSREP) PROFILE\"        /* @C4 */\n  IF (RACFSDSN = \"\") THEN         /* SAve - Dataset Name  */  /* @C5 */\n     RACFSDSN = USERID()\".RACFADM.REPORTS\"                    /* @EK */\n  IF (RACFSFIL = \"\") THEN         /* SAve - As (TXT/CVS)  */  /* @C5 */\n     RACFSFIL = \"T\"                                           /* @EL */\n  IF (RACFSREP = \"\") THEN         /* SAve - Replace (Y/N) */  /* @C5 */\n     RACFSREP = \"N\"                                           /* @EK */\n                                                              /* @C3 */\n  DO FOREVER                                                  /* @C3 */\n     \"DISPLAY PANEL(\"PANELS1\")\"                               /* @C3 */\n     IF (RC = 08) THEN DO                                     /* @C3 */\n        \"REMPOP\"                                              /* @C3 */\n        RETURN                                                /* @C3 */\n     END                                                      /* @C3 */\n     RACFSDSN = STRIP(RACFSDSN,,\"'\")                          /* @C3 */\n     RACFSDSN = STRIP(RACFSDSN,,'\"')                          /* @C3 */\n     RACFSDSN = STRIP(RACFSDSN)                               /* @C3 */\n     SYSDSORG = \"\"                                            /* @C3 */\n     X = LISTDSI(\"'\"RACFSDSN\"'\")                              /* @C3 */\n     IF (SYSDSORG = \"\") | (SYSDSORG = \"PS\"),                  /* @C3 */\n      | (SYSDSORG = \"PO\") THEN                                /* @C3 */\n        NOP                                                   /* @C3 */\n     ELSE DO                                                  /* @C3 */\n        RACFSMSG = \"Not PDS/Seq File\"                         /* @C3 */\n        RACFLMSG = \"The dataset specified is not\",            /* @C3 */\n                  \"a partitioned or sequential\",              /* @C3 */\n                  \"dataset, please enter a valid\",            /* @C3 */\n                  \"dataset name.\"                             /* @C3 */\n       \"SETMSG MSG(RACF011)\"                                  /* @C3 */\n       ITERATE                                                /* @C3 */\n     END                                                      /* @C3 */\n     IF (SYSDSORG = \"PS\") & (RACFSMBR <> \"\") THEN DO          /* @C3 */\n        RACFSMSG = \"Seq File - No mbr\"                        /* @C3 */\n        RACFLMSG = \"This dataset is a sequential\",            /* @C3 */\n                  \"file, please remove the\",                  /* @C3 */\n                  \"member name.\"                              /* @C3 */\n       \"SETMSG MSG(RACF011)\"                                  /* @C3 */\n       ITERATE                                                /* @C3 */\n     END                                                      /* @C3 */\n     IF (SYSDSORG = \"PO\") & (RACFSMBR = \"\") THEN DO           /* @C3 */\n        RACFSMSG = \"PDS File - Need Mbr\"                      /* @C3 */\n        RACFLMSG = \"This dataset is a partitioned\",           /* @C3 */\n                  \"dataset, please include a member\",         /* @C3 */\n                  \"name.\"                                     /* @C3 */\n       \"SETMSG MSG(RACF011)\"                                  /* @C3 */\n       ITERATE                                                /* @C3 */\n     END                                                      /* @C3 */\n                                                              /* @C3 */\n     IF (RACFSMBR = \"\") THEN                                  /* @C3 */\n        TMPDSN = RACFSDSN                                     /* @C3 */\n     ELSE                                                     /* @C3 */\n        TMPDSN = RACFSDSN\"(\"RACFSMBR\")\"                       /* @C3 */\n     DSNCHK = SYSDSN(\"'\"TMPDSN\"'\")                            /* @C3 */\n     IF (DSNCHK = \"OK\" & RACFSREP = \"N\") THEN DO              /* @C3 */\n        RACFSMSG = \"DSN/MBR Exists\"                           /* @C3 */\n        RACFLMSG = \"Dataset/member already exists. \",         /* @C3 */\n                  \"Please type in \"Y\" to replace file.\"       /* @C3 */\n        \"SETMSG MSG(RACF011)\"                                 /* @C3 */\n        ITERATE                                               /* @C3 */\n     END                                                      /* @C3 */\n     LEAVE                                                    /* @C3 */\n  END                                                         /* @C3 */\n  \"REMPOP\"                                                    /* @C3 */\n  \"VPUT (RACFSDSN RACFSMBR RACFSFIL RACFSREP) PROFILE\"        /* @C4 */\n                                                              /* @C3 */\nADDRESS TSO                                                   /* @C3 */\n  IF (RACFSREP = \"Y\" & RACFSMBR = \"\") |,                      /* @C3 */\n     (DSNCHK <> \"OK\" & DSNCHK <> \"MEMBER NOT FOUND\"),         /* @C3 */\n     THEN DO                                                  /* @C3 */\n     \"DELETE '\"RACFSDSN\"'\"                                    /* @C3 */\n     IF (RACFSMBR = \"\") THEN                                  /* @C3 */\n        \"ALLOC  FI(ISPFILE) DA('\"RACFSDSN\"') NEW\",            /* @C3 */\n            \"REUSE SP(1 1) CYLINDER UNIT(SYSALLDA)\",          /* @C6 */\n            \"LRECL(80) RECFM(F B)\"                            /* @C3 */\n     ELSE                                                     /* @C3 */\n        \"ALLOC  FI(ISPFILE) DA('\"RACFSDSN\"') NEW\",            /* @C3 */\n            \"REUSE SP(1 1) CYLINDER UNIT(SYSALLDA)\",          /* @C6 */\n            \"LRECL(80) RECFM(F B)\",                           /* @C3 */\n            \"DSORG(PO) DSNTYPE(LIBRARY,2)\"                    /* @C3 */\n  END                                                         /* @C3 */\n  ELSE                                                        /* @C3 */\n     \"ALLOC  FI(ISPFILE) DA('\"RACFSDSN\"') SHR REUSE\"          /* @C3 */\n                                                              /* @C3 */\nADDRESS ISPEXEC                                               /* @C3 */\n  \"FTOPEN\"                                                    /* @C3 */\n  \"FTINCL \"TMPSKELT                                           /* @C3 */\n  IF (RACFSMBR = \"\") THEN                                     /* @C3 */\n     \"FTCLOSE\"                                                /* @C3 */\n  ELSE                                                        /* @C3 */\n     \"FTCLOSE NAME(\"RACFSMBR\")\"                               /* @C3 */\n  ADDRESS TSO \"FREE FI(ISPFILE)\"                              /* @C3 */\n                                                              /* @C3 */\n  SELECT                                                      /* @C3 */\n     WHEN (SETGDISP = \"VIEW\") THEN                            /* @C3 */\n          \"VIEW DATASET('\"RACFSDSN\"') MACRO(\"EDITMACR\")\"      /* @C3 */\n     WHEN (SETGDISP = \"EDIT\") THEN                            /* @C3 */\n          \"EDIT DATASET('\"RACFSDSN\"') MACRO(\"EDITMACR\")\"      /* @C3 */\n     OTHERWISE                                                /* @C3 */\n          \"BROWSE DATASET('\"RACFSDSN\"')\"                      /* @C3 */\n  END                                                         /* @C3 */\n  X = MSG(\"ON\")                                               /* @C3 */\n                                                              /* @C3 */\nRETURN                                                        /* @C3 */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RACFCLSR": {"ttr": 909, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x14c\\x00C\\x01 \\x00?\\x01 \\x17\\x0f\\x11\\x13\\x02\\x0b\\x00\\xb8\\x00\\x00\\xd9\\xc1\\xc3\\xc6\\xc1\\xc4\\xd4@@@'", "ispf": {"version": "20.99", "flags": 0, "createdate": "2020-01-03T00:00:00", "modifydate": "2020-06-18T11:13:43", "lines": 523, "newlines": 184, "modlines": 0, "user": "RACFADM"}, "text": "/*%NOCOMMENT====================* REXX *==============================*/\n/*  PURPOSE:  RACFADM - General Resources - Option 4, List classes    */\n/*--------------------------------------------------------------------*/\n/* FLG  YYMhDD  USERID   DESCRIPTION                                  */\n/* ---  ------  -------  -------------------------------------------- */\n/* @BB  200618  RACFA    Chged SYSDA to SYSALLDA                      */\n/* @BA  200617  RACFA    Added comments to right of variables         */\n/* @B9  200616  RACFA    Added capability to SAve file as TXT/CSV     */\n/* @B8  200610  RACFA    Added primary command 'SAVE'                 */\n/* @B7  200506  RACFA    Drop array immediately when done using       */\n/* @B6  200502  RACFA    Re-worked displaying tables, use DO FOREVER  */\n/* @B5  200501  LBD      Add primary commands FIND/RFIND              */\n/* @B4  200430  RACFA    Chg tbla to TABLEA, moved def. var. up top   */\n/* @B3  200429  RACFA    Re-arranged variables (General, Mgmt, TSO)   */\n/* @B2  200424  RACFA    Move DDNAME at top, standardize/del dups     */\n/* @B1  200423  RACFA    Move PARSE REXXPGM name up above IF SETMTRAC */\n/* @AZ  200422  RACFA    Ensure the REXX program name is 8 chars      */\n/* @AY  200422  RACFA    Use variable REXXPGM in log msg              */\n/* @AX  200413  RACFA    Chg TRACEing to only display banner (P=Pgms) */\n/* @AW  200412  RACFA    Chg TRACE to allow 'L'abels or 'R'esults     */\n/* @AV  200407  RACFA    EXCMD removed 'else msg_var = 1 to msg.0'    */\n/* @AU  200402  RACFA    Chg LRECL=132 to LRECL=80                    */\n/* @AT  200401  RACFA    Chged edit macro RACFLOGE to RACFEMAC        */\n/* @AS  200401  RACFA    VIEW/EDIT use edit macro, to turn off HILITE */\n/* @AR  200330  RACFA    Allow point-n-shoot sort ascending/descending*/\n/* @AQ  200324  RACFA    Allow both display/logging of RACF commands  */\n/* @AP  200324  RACFA    Allow logging RACF commands to ISPF Log file */\n/* @AO  200303  RACFA    Chg 'RC/Ret_code' to 'cmd_rc' after EXCMD    */\n/* @AN  200303  RACFA    Chg 'RL class ALL' to 'RL class * ALL'       */\n/* @AM  200303  RACFA    Chk RC 'RL cls prms', if RC>0 then 'RL cls'  */\n/* @AL  200303  RACFA    Added line cmd 'L-List'                      */\n/* @AK  200226  RACFA    Fix @AI chg, chg ret_code to cmd_rc          */\n/* @AJ  200226  RACFA    Added 'CONTROL ERRORS RETURN'                */\n/* @AI  200226  RACFA    Added 'Return Code =' when displaying cmd    */\n/* @AH  200226  RACFA    Removed double quotes before/after cmd       */\n/* @AG  200224  RACFA    Standardize quotes, chg single to double     */\n/* @AF  200224  RACFA    Place panels at top of REXX in variables     */\n/* @AE  200223  RACFA    Del 'address TSO \"PROFILE MSGID\"', not needed*/\n/* @AD  200223  RACFA    Added primary command SORT                   */\n/* @AC  200223  RACFA    Use dynamic area to display SELECT commands  */\n/* @AB  200222  RACFA    Removed translating OPTA/B, not needed       */\n/* @AA  200222  RACFA    Allow placing cursor on row and press ENTER  */\n/* @A9  200221  RACFA    Added primary commands 'ONLY' and 'RESET'    */\n/* @A8  200221  RACFA    Allow abbreviating the 'LOCATE' command      */\n/* @A7  200221  RACFA    Make 'ADDRESS ISPEXEC' defualt, reduce code  */\n/* @A6  200220  RACFA    Fixed displaying all RACF commands           */\n/* @A5  200220  RACFA    Added SETMTRAC=YES, then TRACE R             */\n/* @A4  200218  RACFA    Condense VGETs into one line                 */\n/* @A3  200120  RACFA    Removed 'say msg.msg_var' in EXCMD procedure */\n/* @A2  200119  RACFA    Standardized/reduced lines of code           */\n/* @A1  200119  RACFA    Placed comment boxes above procedures        */\n/* @A0  011229  NICORIZ  Created REXX, V2.1, www.rizzuto.it           */\n/*====================================================================*/\nPANEL27     = \"RACFCLSR\"   /* List classes (show, refresh) */ /* @AF */\nPANELM2     = \"RACFMSG2\"   /* Display RACF command and RC  */ /* @AF */\nPANELS1     = \"RACFSAVE\"   /* Obtain DSName to SAVE        */ /* @B8 */\nSKELETON1   = \"RACFCLSR\"   /* Save tablea to dataset       */ /* @B8 */\nEDITMACR    = \"RACFEMAC\"   /* Edit Macro, turn HILITE off  */ /* @AT */\nTABLEA      = 'TA'RANDOM(0,99999)  /* Unique table name A  */ /* @B4 */\nDDNAME      = 'RACFA'RANDOM(0,999) /* Unique ddname        */ /* @B2 */\nparse source . . REXXPGM .         /* Obtain REXX pgm name */ /* @B1 */\nREXXPGM     = LEFT(REXXPGM,8)                                 /* @B1 */\nNULL        = ''                                              /* @B5 */\n\nADDRESS ISPEXEC                                               /* @A7 */\n  Arg class\n  \"CONTROL ERRORS RETURN\"                                     /* @AJ */\n  \"VGET (SETGDISP SETMADMN SETMSHOW SETMTRAC) PROFILE\"        /* @B3 */\n\n  If (SETMTRAC <> 'NO') then do                               /* @AW */\n     Say \"*\"COPIES(\"-\",70)\"*\"                                 /* @AW */\n     Say \"*\"Center(\"Begin Program = \"REXXPGM,70)\"*\"           /* @AW */\n     Say \"*\"COPIES(\"-\",70)\"*\"                                 /* @AW */\n     if (SETMTRAC <> 'PROGRAMS') THEN                         /* @AX */\n        interpret \"Trace \"SUBSTR(SETMTRAC,1,1)                /* @AW */\n  end                                                         /* @AW */\n\n  If (SETMADMN = \"YES\") then                                  /* @AC */\n      SELCMDS = \"[S]Show,[L]List,[R]Refresh\"                  /* @AL */\n  else                                                        /* @AC */\n      SELCMDS = \"[S]Show,[L]List\"                             /* @AL */\n\n  rlv = SYSVAR('SYSLRACF')\n  if (class = '') then DO                                     /* @A9 */\n     call Select_class\n     rc = display_table()                                     /* @A9 */\n     \"TBEND\" TABLEA                                           /* @A9 */\n  END                                                         /* @A9 */\n  else\n     call RACFCLSG class '**' 'YES' /*generic prof routine*/\n\n  If (SETMTRAC <> 'NO') then do                               /* @AW */\n     Say \"*\"COPIES(\"-\",70)\"*\"                                 /* @AW */\n     Say \"*\"Center(\"End Program = \"REXXPGM,70)\"*\"             /* @AW */\n     Say \"*\"COPIES(\"-\",70)\"*\"                                 /* @AW */\n  end                                                         /* @AW */\nEXIT\n/*--------------------------------------------------------------------*/\n/*  Select class                                                      */\n/*--------------------------------------------------------------------*/\nSELECT_CLASS:\n  seconds = time('S')\n  \"TBCREATE\" TABLEA \"KEYS(CLASS)\",\n                  \"NAMES(ACTION) REPLACE NOWRITE\"\n  call get_act_class\n  sort     = 'CLASS,C,A'                                      /* @B6 */\n  sortclas = 'D'                                              /* @B6 */\n  \"TBSORT \" TABLEA \"FIELDS(\"sort\")\"                           /* @B6 */\n  \"TBTOP  \" TABLEA                                            /* @B6 */\nRETURN\n/*--------------------------------------------------------------------*/\n/*  Display profile permits                                           */\n/*--------------------------------------------------------------------*/\nGET_ACT_CLASS:\n  Scan = 'OFF'\n  cmd  = \"SETROPTS LIST\"                                      /* @A6 */\n  x = OUTTRAP('var.')\n  address TSO cmd                                             /* @A6 */\n  cmd_rc = rc                                                 /* @AI */\n  x = OUTTRAP('OFF')\n  if (SETMSHOW <> 'NO') then                                  /* @AP */\n     call SHOWCMD                                             /* @A6 */\n  Do i = 1 to var.0         /* Scan output */\n     temp = var.i\n     if (rlv > '1081') then  /* RACF 1.9 add blank */\n        temp= ' 'temp\n     Select\n        when (substr(temp,2,16) = 'ACTIVE CLASSES =') then do\n             scan   = 'ON'\n             record = substr(temp,18,80)\n             nwords = words(record)\n             do t = 1 to nwords\n                class = subword(record,t,1)\n                if (class <> 'USER'),\n                 & (class <> 'DATASET'),\n                 & (class <> 'GROUP') then\n                   \"TBMOD\" TABLEA\n             end\n        end\n        when (substr(temp,2,25) = 'GENERIC',\n             'PROFILE CLASSES =') then leave\n        otherwise\n          if (scan = 'ON') then do\n             record = var.i\n             nwords = words(record)\n             do t = 1 to nwords\n                class = subword(record,t,1)\n                if (class <> 'USER'),\n                 & (class <> 'DATASET'),\n                 & (class <> 'GROUP') then\n                   \"TBMOD\" TABLEA\n             end\n        end\n     End  /* end_select */\n  end /* do i */\nRETURN\n/*--------------------------------------------------------------------*/\n/*  Profiles table display section                                    */\n/*--------------------------------------------------------------------*/\nDISPLAY_TABLE:\n  opta   = ' '\n  xtdtop = 0                                                  /* @B6 */\n  rsels  = 0                                                  /* @B6 */\n  do forever                                                  /* @B6 */\n     if (rsels < 2) then do                                   /* @B6 */\n        \"TBTOP \" TABLEA                                       /* @B6 */\n        'tbskip' tablea 'number('xtdtop')'                    /* @B6 */\n        radmrfnd = 'PASSTHRU'                                 /* @B6 */\n        'vput (radmrfnd)'                                     /* @B6 */\n        \"TBDISPL\" TABLEA \"PANEL(\"PANEL27\")\"                   /* @B6 */\n     end                                                      /* @B6 */\n     else 'tbdispl' tablea                                    /* @B6 */\n     if (rc > 4) then leave                                   /* @B6 */\n     xtdtop   = ztdtop                                        /* @B6 */\n     rsels    = ztdsels                                       /* @B6 */\n     radmrfnd = null                                          /* @B6 */\n     'vput (radmrfnd)'                                        /* @B6 */\n     PARSE VAR ZCMD ZCMD PARM SEQ                             /* @B6 */\n     IF (SROW <> \"\") & (SROW <> 0) THEN                       /* @AA */\n        IF (SROW > 0) THEN DO                                 /* @AA */\n           \"TBTOP \" TABLEA                                    /* @AA */\n           \"TBSKIP\" TABLEA \"NUMBER(\"SROW\")\"                   /* @AA */\n        END                                                   /* @AA */\n     if (zcmd = 'RFIND') then do                              /* @B5 */\n        zcmd = 'FIND'                                         /* @B5 */\n        parm = findit                                         /* @B5 */\n        'tbtop ' TABLEA                                       /* @B5 */\n        'tbskip' TABLEA 'number('last_find')'                 /* @B5 */\n     end                                                      /* @B5 */\n     Select\n        When (abbrev(\"FIND\",zcmd,1) = 1) then                 /* @B5 */\n             call do_find                                     /* @B5 */\n        WHEN (ABBREV(\"LOCATE\",ZCMD,1) = 1) THEN do            /* @B6 */\n             if (parm <> '') then do                          /* @B6 */\n                locarg = parm'*'                              /* @B6 */\n                PARSE VAR SORT . \",\" . \",\" SEQ                /* @B6 */\n                IF (SEQ = \"D\") THEN                           /* @B6 */\n                   CONDLIST = \"LE\"                            /* @B6 */\n                ELSE                                          /* @B6 */\n                   CONDLIST = \"GE\"                            /* @B6 */\n                parse value sort with scan_field',' .         /* @B6 */\n                interpret scan_field ' = locarg'              /* @B6 */\n                'tbtop ' tablea                               /* @B6 */\n                \"TBSCAN \"TABLEA\" ARGLIST(\"scan_field\")\",      /* @B6 */\n                        \"CONDLIST(\"CONDLIST\")\",               /* @B6 */\n                        \"position(scanrow)\"                   /* @B6 */\n                xtdtop = scanrow                              /* @B6 */\n             end                                              /* @B6 */\n        end                                                   /* @B6 */\n        WHEN (ABBREV(\"ONLY\",ZCMD,1) = 1) THEN DO              /* @A9 */\n             find_str = translate(parm)                       /* @A9 */\n             'tbtop ' TABLEA                                  /* @A9 */\n             'tbskip' TABLEA                                  /* @A9 */\n             do forever                                       /* @A9 */\n                str = translate(class action)                 /* @A9 */\n                if (pos(find_str,str) > 0) then nop           /* @A9 */\n                else 'tbdelete' TABLEA                        /* @A9 */\n                'tbskip' TABLEA                               /* @A9 */\n                if (rc > 0) then do                           /* @A9 */\n                   'tbtop' TABLEA                             /* @A9 */\n                   leave                                      /* @A9 */\n                end                                           /* @A9 */\n             end                                              /* @A9 */\n        END                                                   /* @A9 */\n        WHEN (ABBREV(\"RESET\",ZCMD,1) = 1) THEN DO             /* @A9 */\n             call select_class                                /* @A9 */\n             sort     = 'CLASS,C,A'                           /* @AD */\n             sortclas = 'D'                                   /* @AR */\n             xtdtop   = 1                                     /* @A9 */\n        END                                                   /* @A9 */\n        When (abbrev(\"SAVE\",zcmd,2) = 1) then DO              /* @B8 */\n             TMPSKELT = SKELETON1                             /* @B8 */\n             call do_SAVE                                     /* @B8 */\n        END                                                   /* @B8 */\n        WHEN (ABBREV(\"SORT\",ZCMD,1) = 1) THEN DO              /* @B6 */\n             call sortseq 'CLASS'                             /* @AR */\n             \"TBSORT\" TABLEA \"FIELDS(\"sort\")\"                 /* @B6 */\n             \"TBTOP \" TABLEA                                  /* @B6 */\n        END\n        OTHERWISE NOP                                         /* @A8 */\n     End\n     ZCMD = \"\"; PARM = \"\"                                     /* @B6 */\n     'control display save'                                   /* @B6 */\n     Select\n        when (opta = 'L') then call lisp                      /* @AL */\n        when (opta = 'R') then call REFRESH\n        when (opta = 'S') then   /* call generic */\n             call RACFCLSG class '**' 'YES'\n        otherwise nop\n     End\n     'control display restore'                                /* @B6 */\n  end  /* Do forever) */                                      /* @B6 */\nRETURN 0\n/*--------------------------------------------------------------------*/\n/*  Process primary command FIND                                 @B5  */\n/*--------------------------------------------------------------------*/\nDO_FIND:                                                      /* @B5 */\n  if (parm = null) then do                                    /* @B5 */\n     racfsmsg = 'Error'                                       /* @B5 */\n     racflmsg = 'Find requires a value to search for.' ,      /* @B5 */\n                'Try again.'                                  /* @B5 */\n     'setmsg msg(RACF011)'                                    /* @B5 */\n     return                                                   /* @B5 */\n  end                                                         /* @B5 */\n  findit    = translate(parm)                                 /* @B5 */\n  last_find = 0                                               /* @B5 */\n  wrap      = 0                                               /* @B5 */\n  do forever                                                  /* @B5 */\n     'tbskip' TABLEA                                          /* @B5 */\n     if (rc > 0) then do                                      /* @B5 */\n        if (wrap = 1) then do                                 /* @B5 */\n           racfsmsg = 'Not Found'                             /* @B5 */\n           racflmsg = findit 'not found.'                     /* @B5 */\n           'setmsg msg(RACF011)'                              /* @B5 */\n           return                                             /* @B5 */\n        end                                                   /* @B5 */\n        if (wrap = 0) then wrap = 1                           /* @B5 */\n        'tbtop' TABLEA                                        /* @B5 */\n     end                                                      /* @B5 */\n     else do                                                  /* @B5 */\n        testit = translate(class action)                      /* @B5 */\n        if (pos(findit,testit) > 0) then do                   /* @B5 */\n           'tbquery' TABLEA 'position(srow)'                  /* @B5 */\n           'tbtop'   TABLEA                                   /* @B5 */\n           'tbskip'  TABLEA 'number('srow')'                  /* @B5 */\n           last_find = srow                                   /* @B5 */\n           xtdtop    = srow                                   /* @B5 */\n           if (wrap = 0) then                                 /* @B5 */\n              racfsmsg = 'Found'                              /* @B5 */\n           else                                               /* @B5 */\n              racfsmsg = 'Found/Wrapped'                      /* @B5 */\n           racflmsg = findit 'found in row' srow + 0          /* @B5 */\n           'setmsg msg(RACF011)'                              /* @B5 */\n           return                                             /* @B5 */\n        end                                                   /* @B5 */\n     end                                                      /* @B5 */\n  end                                                         /* @B5 */\nRETURN                                                        /* @B5 */\n/*--------------------------------------------------------------------*/\n/*  Define sort sequence, to allow point-n-shoot sorting (A/D)   @AR  */\n/*--------------------------------------------------------------------*/\nSORTSEQ:                                                      /* @AR */\n  parse arg sortcol                                           /* @AR */\n  INTERPRET \"TMPSEQ = SORT\"substr(SORTCOL,1,4)                /* @AR */\n  select                                                      /* @AR */\n     when (seq <> \"\") then do                                 /* @AR */\n          if (seq = 'A') then                                 /* @AR */\n             tmpseq = 'D'                                     /* @AR */\n          else                                                /* @AR */\n             tmpseq = 'A'                                     /* @AR */\n          sort = sortcol',C,'seq                              /* @AR */\n     end                                                      /* @AR */\n     when (seq = \"\"),                                         /* @AR */\n        & (tmpseq = 'A') then do                              /* @AR */\n           sort   = sortcol',C,A'                             /* @AR */\n           tmpseq = 'D'                                       /* @AR */\n     end                                                      /* @AR */\n     Otherwise do                                             /* @AR */\n        sort   = sortcol',C,D'                                /* @AR */\n        tmpseq = 'A'                                          /* @AR */\n     end                                                      /* @AR */\n  end                                                         /* @AR */\n  INTERPRET \"SORT\"SUBSTR(SORTCOL,1,4)\" = TMPSEQ\"              /* @AR */\nRETURN                                                        /* @AR */\n/*--------------------------------------------------------------------*/\n/*  Refresh class                                                     */\n/*--------------------------------------------------------------------*/\nREFRESH:\n  msg    = 'You are about to refresh class 'class\n  Sure_? = RACFMSGC(msg)\n  if (sure_? = 'YES') then do\n     call EXCMD \"SETR RACLIST(\"class\") REFRESH\"\n     if (cmd_rc <> 0) then                                    /* @AO */\n        call racfmsgs \"ERR10\" /* CMD FAILED */\n     else do\n        action = '*REFRESHED'\n        \"TBMOD\" TABLEA\n     end\n  end\nRETURN\n/*--------------------------------------------------------------------*/\n/*  Exec command                                                      */\n/*--------------------------------------------------------------------*/\nEXCMD:\n  signal off error\n  arg cmd\n  x = OUTTRAP('msg.')\n  address TSO cmd                                             /* @AH */\n  cmd_rc = rc\n  x = OUTTRAP('OFF')\n  if (SETMSHOW <> 'NO') then                                  /* @AP */\n     call SHOWCMD                                             /* @A6 */\n  if (subword(msg.1,1,1)= 'ICH11009I') |,\n     (subword(msg.1,1,1)= 'ICH10006I') |,\n     (subword(msg.1,1,1)= 'ICH06011I') then\n     raclist = 'YES'\nRETURN\n/*--------------------------------------------------------------------*/\n/*  List class                                                   @AL  */\n/*--------------------------------------------------------------------*/\nLISP:\n  cmd     = \"RL \"CLASS\" * ALL\"                                /* @AN */\n  X = OUTTRAP(\"CMDREC.\")\n  ADDRESS TSO cmd\n  cmd_rc = rc\n  X = OUTTRAP(\"OFF\")\n  if (SETMSHOW <> 'NO') then                                  /* @AP */\n     call SHOWCMD\n  if (cmd_rc > 0) then do    /* Remove parms */               /* @AM */\n     cmd     = \"RL \"CLASS\" *\"                                 /* @AN */\n     X = OUTTRAP(\"CMDREC.\")                                   /* @AM */\n     ADDRESS TSO cmd                                          /* @AM */\n     cmd_rc = rc                                              /* @AM */\n     X = OUTTRAP(\"OFF\")                                       /* @AM */\n     if (SETMSHOW <> 'NO') then                               /* @AP */\n        call SHOWCMD                                          /* @AM */\n  end                                                         /* @AM */\n\n  ADDRESS TSO \"ALLOC F(\"DDNAME\") NEW REUSE\",\n              \"LRECL(80) BLKSIZE(0) RECFM(F B)\",              /* @AU */\n              \"UNIT(VIO) SPACE(1 5) CYLINDERS\"\n  ADDRESS TSO \"EXECIO * DISKW \"DDNAME\" (STEM CMDREC. FINIS\"\n  DROP CMDREC.                                                /* @B7 */\n                                                              /* @B7 */\n  \"LMINIT DATAID(CMDDATID) DDNAME(\"DDNAME\")\"\n  SELECT\n     WHEN (SETGDISP = \"VIEW\") THEN\n          \"VIEW DATAID(\"CMDDATID\") MACRO(\"EDITMACR\")\"         /* @AS */\n     WHEN (SETGDISP = \"EDIT\") THEN\n          \"EDIT DATAID(\"CMDDATID\") MACRO(\"EDITMACR\")\"         /* @AS */\n     OTHERWISE\n          \"BROWSE DATAID(\"CMDDATID\")\"\n  END\n  ADDRESS TSO \"FREE FI(\"DDNAME\")\"\n  if (cmd_rc > 0) then                                        /* @AC */\n     CALL racfmsgs \"ERR10\" /* Generic failure */              /* @AC */\nRETURN\n/*--------------------------------------------------------------------*/\n/*  Display RACF command and return code                         @A6  */\n/*--------------------------------------------------------------------*/\nSHOWCMD:                                                      /* @A6 */\n  IF (SETMSHOW = \"BOTH\") | (SETMSHOW = \"DISPLAY\") THEN DO     /* @AQ */\n     PARSE VAR CMD MSG1 60 MSG2 121 MSG3                      /* @A6 */\n     MSG4 = \"Return code = \"cmd_rc                            /* @AI */\n     \"ADDPOP ROW(6) COLUMN(4)\"                                /* @AG */\n     \"DISPLAY PANEL(\"PANELM2\")\"                               /* @AF */\n     \"REMPOP\"                                                 /* @AG */\n  END                                                         /* @AP */\n  IF (SETMSHOW = \"BOTH\") | (SETMSHOW = \"LOG\") THEN DO         /* @AQ */\n     zerrsm = \"RACFADM \"REXXPGM\" RC=\"cmd_rc                   /* @AY */\n     zerrlm = cmd                                             /* @AP */\n     'log msg(isrz003)'                                       /* @AP */\n  END                                                         /* @AP */\nRETURN                                                        /* @A6 */\n/*--------------------------------------------------------------------*/\n/*  Save table to dataset                                        @B8  */\n/*--------------------------------------------------------------------*/\nDO_SAVE:                                                      /* @B8 */\n  X = MSG(\"OFF\")                                              /* @B8 */\n  \"ADDPOP COLUMN(40)\"                                         /* @B8 */\n  \"VGET (RACFSDSN RACFSMBR RACFSFIL RACFSREP) PROFILE\"        /* @B9 */\n  IF (RACFSDSN = \"\") THEN         /* SAve - Dataset Name  */  /* @BA */\n     RACFSDSN = USERID()\".RACFADM.REPORTS\"                    /* @EK */\n  IF (RACFSFIL = \"\") THEN         /* SAve - As (TXT/CVS)  */  /* @BA */\n     RACFSFIL = \"T\"                                           /* @EL */\n  IF (RACFSREP = \"\") THEN         /* SAve - Replace (Y/N) */  /* @BA */\n     RACFSREP = \"N\"                                           /* @EK */\n                                                              /* @B8 */\n  DO FOREVER                                                  /* @B8 */\n     \"DISPLAY PANEL(\"PANELS1\")\"                               /* @B8 */\n     IF (RC = 08) THEN DO                                     /* @B8 */\n        \"REMPOP\"                                              /* @B8 */\n        RETURN                                                /* @B8 */\n     END                                                      /* @B8 */\n     RACFSDSN = STRIP(RACFSDSN,,\"'\")                          /* @B8 */\n     RACFSDSN = STRIP(RACFSDSN,,'\"')                          /* @B8 */\n     RACFSDSN = STRIP(RACFSDSN)                               /* @B8 */\n     SYSDSORG = \"\"                                            /* @B8 */\n     X = LISTDSI(\"'\"RACFSDSN\"'\")                              /* @B8 */\n     IF (SYSDSORG = \"\") | (SYSDSORG = \"PS\"),                  /* @B8 */\n      | (SYSDSORG = \"PO\") THEN                                /* @B8 */\n        NOP                                                   /* @B8 */\n     ELSE DO                                                  /* @B8 */\n        RACFSMSG = \"Not PDS/Seq File\"                         /* @B8 */\n        RACFLMSG = \"The dataset specified is not\",            /* @B8 */\n                  \"a partitioned or sequential\",              /* @B8 */\n                  \"dataset, please enter a valid\",            /* @B8 */\n                  \"dataset name.\"                             /* @B8 */\n       \"SETMSG MSG(RACF011)\"                                  /* @B8 */\n       ITERATE                                                /* @B8 */\n     END                                                      /* @B8 */\n     IF (SYSDSORG = \"PS\") & (RACFSMBR <> \"\") THEN DO          /* @B8 */\n        RACFSMSG = \"Seq File - No mbr\"                        /* @B8 */\n        RACFLMSG = \"This dataset is a sequential\",            /* @B8 */\n                  \"file, please remove the\",                  /* @B8 */\n                  \"member name.\"                              /* @B8 */\n       \"SETMSG MSG(RACF011)\"                                  /* @B8 */\n       ITERATE                                                /* @B8 */\n     END                                                      /* @B8 */\n     IF (SYSDSORG = \"PO\") & (RACFSMBR = \"\") THEN DO           /* @B8 */\n        RACFSMSG = \"PDS File - Need Mbr\"                      /* @B8 */\n        RACFLMSG = \"This dataset is a partitioned\",           /* @B8 */\n                  \"dataset, please include a member\",         /* @B8 */\n                  \"name.\"                                     /* @B8 */\n       \"SETMSG MSG(RACF011)\"                                  /* @B8 */\n       ITERATE                                                /* @B8 */\n     END                                                      /* @B8 */\n                                                              /* @B8 */\n     IF (RACFSMBR = \"\") THEN                                  /* @B8 */\n        TMPDSN = RACFSDSN                                     /* @B8 */\n     ELSE                                                     /* @B8 */\n        TMPDSN = RACFSDSN\"(\"RACFSMBR\")\"                       /* @B8 */\n     DSNCHK = SYSDSN(\"'\"TMPDSN\"'\")                            /* @B8 */\n     IF (DSNCHK = \"OK\" & RACFSREP = \"N\") THEN DO              /* @B8 */\n        RACFSMSG = \"DSN/MBR Exists\"                           /* @B8 */\n        RACFLMSG = \"Dataset/member already exists. \",         /* @B8 */\n                  \"Please type in \"Y\" to replace file.\"       /* @B8 */\n        \"SETMSG MSG(RACF011)\"                                 /* @B8 */\n        ITERATE                                               /* @B8 */\n     END                                                      /* @B8 */\n     LEAVE                                                    /* @B8 */\n  END                                                         /* @B8 */\n  \"REMPOP\"                                                    /* @B8 */\n  \"VPUT (RACFSDSN RACFSMBR RACFSFIL RACFSREP) PROFILE\"        /* @B9 */\n                                                              /* @B8 */\nADDRESS TSO                                                   /* @B8 */\n  IF (RACFSREP = \"Y\" & RACFSMBR = \"\") |,                      /* @B8 */\n     (DSNCHK <> \"OK\" & DSNCHK <> \"MEMBER NOT FOUND\"),         /* @B8 */\n     THEN DO                                                  /* @B8 */\n     \"DELETE '\"RACFSDSN\"'\"                                    /* @B8 */\n     IF (RACFSMBR = \"\") THEN                                  /* @B8 */\n        \"ALLOC  FI(ISPFILE) DA('\"RACFSDSN\"') NEW\",            /* @B8 */\n            \"REUSE SP(1 1) CYLINDER UNIT(SYSALLDA)\",          /* @BB */\n            \"LRECL(80) RECFM(F B)\"                            /* @B8 */\n     ELSE                                                     /* @B8 */\n        \"ALLOC  FI(ISPFILE) DA('\"RACFSDSN\"') NEW\",            /* @B8 */\n            \"REUSE SP(1 1) CYLINDER UNIT(SYSALLDA)\",          /* @BB */\n            \"LRECL(80) RECFM(F B)\",                           /* @B8 */\n            \"DSORG(PO) DSNTYPE(LIBRARY,2)\"                    /* @B8 */\n  END                                                         /* @B8 */\n  ELSE                                                        /* @B8 */\n     \"ALLOC  FI(ISPFILE) DA('\"RACFSDSN\"') SHR REUSE\"          /* @B8 */\n                                                              /* @B8 */\nADDRESS ISPEXEC                                               /* @B8 */\n  \"FTOPEN\"                                                    /* @B8 */\n  \"FTINCL \"TMPSKELT                                           /* @B8 */\n  IF (RACFSMBR = \"\") THEN                                     /* @B8 */\n     \"FTCLOSE\"                                                /* @B8 */\n  ELSE                                                        /* @B8 */\n     \"FTCLOSE NAME(\"RACFSMBR\")\"                               /* @B8 */\n  ADDRESS TSO \"FREE FI(ISPFILE)\"                              /* @B8 */\n                                                              /* @B8 */\n  SELECT                                                      /* @B8 */\n     WHEN (SETGDISP = \"VIEW\") THEN                            /* @B8 */\n          \"VIEW DATASET('\"RACFSDSN\"') MACRO(\"EDITMACR\")\"      /* @B8 */\n     WHEN (SETGDISP = \"EDIT\") THEN                            /* @B8 */\n          \"EDIT DATASET('\"RACFSDSN\"') MACRO(\"EDITMACR\")\"      /* @B8 */\n     OTHERWISE                                                /* @B8 */\n          \"BROWSE DATASET('\"RACFSDSN\"')\"                      /* @B8 */\n  END                                                         /* @B8 */\n  X = MSG(\"ON\")                                               /* @B8 */\n                                                              /* @B8 */\nRETURN                                                        /* @B8 */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RACFCLSS": {"ttr": 911, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x14c\\x00$\\x01 \\x00?\\x01 \\x17\\x0f\\x11\\x14\\x02\\xd3\\x00\\xf4\\x00\\x00\\xd9\\xc1\\xc3\\xc6\\xc1\\xc4\\xd4@@@'", "ispf": {"version": "20.99", "flags": 0, "createdate": "2020-01-03T00:00:00", "modifydate": "2020-06-18T11:14:24", "lines": 723, "newlines": 244, "modlines": 0, "user": "RACFADM"}, "text": "/*%NOCOMMENT====================* REXX *==============================*/\n/*  PURPOSE:  RACFADM - General Resources - Search classes            */\n/*--------------------------------------------------------------------*/\n/* FLG  YYMMDD  USERID   DESCRIPTION                                  */\n/* ---  ------  -------  -------------------------------------------- */\n/* @BO  200618  RACFA    Chged SYSDA to SYSALLDA                      */\n/* @BN  200617  RACFA    Added comments to right of variables         */\n/* @BM  200616  RACFA    Added primary command 'SAVE' when SEarching  */\n/* @BL  200616  RACFA    Added capability to SAve file as TXT/CSV     */\n/* @BK  200610  RACFA    Added primary command 'SAVE'                 */\n/* @BJ  200506  RACFA    Drop array immediately when done using       */\n/* @BI  200502  RACFA    Re-worked displaying tables, use DO FOREVER  */\n/* @BH  200501  LBD      Add primary commands FIND/RFIND              */\n/* @BG  200430  RACFA    Chg tblb to TABLEB, moved def. var. up top   */\n/* @BF  200430  RACFA    Chg tbla to TABLEA, moved def. var. up top   */\n/* @BE  200429  RACFA    Re-arranged variables (General, Mgmt, TSO)   */\n/* @BD  200424  RACFA    Chg msg RACF013 to RACF012                   */\n/* @BC  200424  RACFA    Fix msg RACF013, was RACF012                 */\n/* @BB  200424  RACFA    Move DDNAME at top, standardize/del dups     */\n/* @BA  200423  RACFA    Move PARSE REXXPGM name up above IF SETMTRAC */\n/* @B9  200423  RACFA    Deleted the paranthesis, syntax error        */\n/* @B8  200423  RACFA    'Status Interval' by percentage (SETGSTAP)   */\n/* @B7  200422  RACFA    Ensure the REXX program name is 8 chars      */\n/* @B6  200422  RACFA    Use variable REXXPGM in log msg              */\n/* @B5  200417  RACFA    Chg REXX pgm name RACFAUTH to RACFCLSA       */\n/* @B4  200413  RACFA    Chg TRACEing to only display banner (P=Pgms) */\n/* @B3  200412  RACFA    Deleted subroutine 'ERROR', not needed       */\n/* @B2  200412  RACFA    Chg TRACE to allow 'L'abels or 'R'esults     */\n/* @B1  200402  RACFA    Chg LRECL=132 to LRECL=80                    */\n/* @AZ  200402  RACFA    Fixed VIEW/EDIT, was missing edit macro var. */\n/* @AY  200401  RACFA    Create subroutine to VIEW/EDIT/BROWSE        */\n/* @AX  200401  RACFA    VIEW/EDIT use edit macro, to turn off HILITE */\n/* @AW  200330  RACFA    Allow point-n-shoot sort ascending/descending*/\n/* @AV  200324  RACFA    Allow both display/logging of RACF commands  */\n/* @AU  200324  RACFA    Allow logging RACF commands to ISPF Log file */\n/* @AT  200303  RACFA    Chg 'RL class ALL' to 'RL class * ALL'       */\n/* @AS  200303  RACFA    Added line cmd 'L-List' to class's profile   */\n/* @AR  200303  RACFA    Added line cmd 'L-List' to class             */\n/* @AQ  200302  RACFA    Fixed SORT cmd for class profiles            */\n/* @AP  200302  RACFA    Chk/honor 'Status Interval' for cls profiles */\n/* @AO  200302  RACFA    Add SORT/LOCATE/ONLY/RESET for class profiles*/\n/* @AN  200301  RACFA    Chk for 'NO ENTRIES MEET SEARCH CRITERIA'    */\n/* @AM  200226  RACFA    Fix @AK chg, chg ret_code to cmd_rc          */\n/* @AL  200226  RACFA    Added 'CONTROL ERRORS RETURN'                */\n/* @AK  200226  RACFA    Removed double quotes before/after cmd       */\n/* @AJ  200225  RACFA    Del address TSO \"PROFILE PREF(\"USERID()\")\"   */\n/* @AI  200224  RACFA    Fixed PANEL08, typo in defining variable     */\n/* @AH  200224  RACFA    Standardize quotes, chg single to double     */\n/* @AG  200224  RACFA    Place panels at top of REXX in variables     */\n/* @AF  200223  RACFA    Del 'address TSO \"PROFILE MSGID\"', not needed*/\n/* @AE  200223  RACFA    Reduced code when LOCATEing, not necessary   */\n/* @AD  200223  RACFA    Reduced code when SORTing, not necessary     */\n/* @AC  200223  RACFA    Created RACFCLSD (only Class, no profile col)*/\n/* @AB  200223  RACFA    Added primary cmds: SORT, LOCATE, ONLY, RESET*/\n/* @AA  200222  RACFA    Removed translating OPTA/B, not needed       */\n/* @A9  200222  RACFA    Allow placing cursor on row and press ENTER  */\n/* @A8  200221  RACFA    Removed \"G = '(G)'\", not referenced          */\n/* @A7  200221  RACFA    Get SETMSHOW, to display RACF cmds           */\n/* @A6  200221  RACFA    Make 'ADDRESS ISPEXEC' defualt, reduce code  */\n/* @A5  200220  RACFA    Fixed displaying all RACF commands           */\n/* @A4  200220  RACFA    Added SETMTRAC=YES, then TRACE R             */\n/* @A3  200214  RACFA    Chged panel name RACFSRCH to RACFCLS8        */\n/* @A2  200120  RACFA    Standardized/reduced lines of code           */\n/* @A1  200120  RACFA    Added comment box above procedures           */\n/* @A0  011229  NICORIZ  Created REXX, V2.1, www.rizzuto.it           */\n/*====================================================================*/\nPANEL08     = \"RACFCLS8\"   /* List classes and profiles    */ /* @AI */\nPANEL13     = \"RACFCLSD\"   /* Add class                    */ /* @AG */\nPANELM2     = \"RACFMSG2\"   /* Display RACF command and R   */ /* @AG */\nPANELS1     = \"RACFSAVE\"   /* Obtain DSName to SAVE        */ /* @BK */\nSKELETON1   = \"RACFCLSD\"   /* Save tablea to dataset       */ /* @BM */\nSKELETON2   = \"RACFCLS8\"   /* Save tableb to dataset       */ /* @BK */\nEDITMACR    = \"RACFEMAC\"   /* Edit Macro, turn HILITE off  */ /* @AZ */\nTABLEA      = 'TA'RANDOM(0,99999)  /* Unique table name A  */ /* @BF */\nTABLEB      = 'TB'RANDOM(0,99999)  /* Unique table name B  */ /* @BG */\nDDNAME      = 'RACFA'RANDOM(0,999) /* Unique ddname        */ /* @BB */\nparse source . . REXXPGM .         /* Obtain REXX pgm name */ /* @BA */\nREXXPGM     = LEFT(REXXPGM,8)                                 /* @BA */\nNULL        = ''                                              /* @BH */\n\nADDRESS ISPEXEC                                               /* @A6 */\n  Arg user\n  selection = 0  /* something selected */\n\n  \"CONTROL ERRORS RETURN\"                                     /* @AL */\n  \"VGET (SETGSTA SETGSTAP SETGDISP SETMSHOW\",                 /* @BE */\n        \"SETMTRAC) PROFILE\"                                   /* @BE */\n\n  If (SETMTRAC <> 'NO') then do                               /* @B2 */\n     Say \"*\"COPIES(\"-\",70)\"*\"                                 /* @B2 */\n     Say \"*\"Center(\"Begin Program = \"REXXPGM,70)\"*\"           /* @B2 */\n     Say \"*\"COPIES(\"-\",70)\"*\"                                 /* @B2 */\n     if (SETMTRAC <> 'PROGRAMS') THEN                         /* @B4 */\n        interpret \"Trace \"SUBSTR(SETMTRAC,1,1)                /* @B2 */\n  end                                                         /* @B2 */\n\n  rlv = SYSVAR('SYSLRACF')\n  seconds = time('S')\n  call Select_class\n  if selection then rc = display_table_permit()\n  \"TBEND\" TABLEB\n\n  If (SETMTRAC <> 'NO') then do                               /* @B2 */\n     Say \"*\"COPIES(\"-\",70)\"*\"                                 /* @B2 */\n     Say \"*\"Center(\"End Program = \"REXXPGM,70)\"*\"             /* @B2 */\n     Say \"*\"COPIES(\"-\",70)\"*\"                                 /* @B2 */\n  end                                                         /* @B2 */\nEXIT\n/*--------------------------------------------------------------------*/\n/*  Get permits                                                       */\n/*--------------------------------------------------------------------*/\nGET_PERMITS:\n  \"TBCREATE\" TABLEB\" KEYS(CLASS PROFILE) REPLACE NOWRITE\"     /* @AO */\n  class = arg(1)\n  user  = arg(2)\n  cmd   = \"SEARCH CLASS(\"class\") USER(\"user\")\"                /* @A5 */\n  x = OUTTRAP('VAR.')\n  address TSO cmd                                             /* @A5 */\n  cmd_rc = rc                                                 /* @AK */\n  x = OUTTRAP('OFF')\n  if (SETMSHOW <> 'NO') then                                  /* @AU */\n     call SHOWCMD                                             /* @A5 */\n  if (SETGSTAP <> \"\") THEN                                    /* @B8 */\n     INTERPRET \"RECNUM = var.0*.\"SETGSTAP\"%1\"                 /* @B8 */\n  Do i = 1 to var.0   /* Scan output */\n     profile = subword(var.i,1,1)\n     If (profile = \"NO\") then                                 /* @AN */\n        LEAVE         /* NO ENTRIES MEET SEARCH CRITERIA */\n     if (profile <> 'ICH31005I') then do\n        IF (SETGSTA = \"\") THEN DO                             /* @B8 */\n           IF (RECNUM <> 0) THEN                              /* @B8 */\n              IF (I//RECNUM = 0) THEN DO                      /* @B8 */\n                 n1 = i; n2 = var.0                           /* @B8 */\n                 pct = ((n1/n2)*100)%1'%'                     /* @B8 */\n                 \"control display lock\"                       /* @B8 */\n                 \"display msg(RACF012)\"                       /* @BD */\n              END                                             /* @B8 */\n        END                                                   /* @B8 */\n        ELSE DO                                               /* @B8 */\n           IF (SETGSTA <> 0) THEN                             /* @B8 */\n              IF (I//SETGSTA = 0) THEN DO                     /* @AP */\n                 n1 = i; n2 = var.0\n                 pct = ((n1/n2)*100)%1'%'                     /* @B8 */\n                 \"control display lock\"\n                 \"display msg(RACF012)\"                       /* @BD */\n              end                                             /* @AP */\n        END                                                   /* @B8 */\n        \"TBMOD\" TABLEB\n     end\n  end /* end_do i=1     */\n  sort     = 'PROFILE,C,A'                                    /* @BI */\n  sortprof = 'D'                                              /* @BI */\n  \"TBSORT \"TABLEB\" FIELDS(\"SORT\")\"                            /* @BI */\n  \"TBTOP  \"TABLEB                                             /* @BI */\nRETURN 0\n/*--------------------------------------------------------------------*/\n/*  Display permit table B                                            */\n/*--------------------------------------------------------------------*/\nDISPLAY_TABLE_PERMIT:\n  xtdtop = 0                                                  /* @BI */\n  rsels  = 0                                                  /* @BI */\n  do forever                                                  /* @BI */\n     if (rsels < 2) then do                                   /* @BI */\n        opta = ' '                                            /* @BI */\n        \"TBTOP \" TABLEB                                       /* @BI */\n        'tbskip' tableb 'number('xtdtop')'                    /* @BI */\n        radmrfnd = 'PASSTHRU'                                 /* @BI */\n        'vput (radmrfnd)'                                     /* @BI */\n        \"TBDISPL\" TABLEB \"PANEL(\"PANEL08\")\"                   /* @BI */\n     end                                                      /* @BI */\n     else 'tbdispl' tableb                                    /* @BI */\n     if (rc > 4) then leave                                   /* @BI */\n     xtdtop   = ztdtop                                        /* @BI */\n     rsels    = ztdsels                                       /* @BI */\n     radmrfnd = null                                          /* @BI */\n     'vput (radmrfnd)'                                        /* @BI */\n     PARSE VAR ZCMD ZCMD PARM SEQ                             /* @BI */\n     IF (SROW <> \"\") & (SROW <> 0) THEN                       /* @A9 */\n        IF (SROW > 0) THEN DO                                 /* @A9 */\n           \"TBTOP \" TABLEB                                    /* @A9 */\n           \"TBSKIP\" TABLEB \"NUMBER(\"SROW\")\"                   /* @A9 */\n        END                                                   /* @A9 */\n     if (zcmd = 'RFIND') then do                              /* @BH */\n        zcmd = 'FIND'                                         /* @BH */\n        parm = findit                                         /* @BH */\n        'tbtop ' TABLEB                                       /* @BH */\n        'tbskip' TABLEB 'number('last_find')'                 /* @BH */\n     end                                                      /* @BH */\n     Select\n        When (abbrev(\"FIND\",zcmd,1) = 1) then                 /* @BH */\n             call do_findb                                    /* @BH */\n        WHEN (ABBREV(\"LOCATE\",ZCMD,1) = 1) THEN do            /* @BI */\n             if (parm <> '') then do                          /* @BI */\n                locarg = parm'*'                              /* @BI */\n                PARSE VAR SORT . \",\" . \",\" SEQ                /* @BI */\n                IF (SEQ = \"D\") THEN                           /* @BI */\n                   CONDLIST = \"LE\"                            /* @BI */\n                ELSE                                          /* @BI */\n                   CONDLIST = \"GE\"                            /* @BI */\n                parse value sort with scan_field',' .         /* @BI */\n                interpret scan_field ' = locarg'              /* @BI */\n                'tbtop ' tableb                               /* @BI */\n                \"TBSCAN \"TABLEb\" ARGLIST(\"scan_field\")\",      /* @BI */\n                        \"CONDLIST(\"CONDLIST\")\",               /* @BI */\n                        \"position(scanrow)\"                   /* @BI */\n                xtdtop = scanrow                              /* @BI */\n             end                                              /* @BI */\n        end                                                   /* @BI */\n        WHEN (ABBREV(\"ONLY\",ZCMD,1) = 1) THEN DO              /* @AO */\n             find_str = translate(parm)                       /* @AO */\n             'tbtop ' TABLEB                                  /* @AO */\n             'tbskip' TABLEB                                  /* @AO */\n             do forever                                       /* @AO */\n                str = translate(profile)                      /* @AO */\n                if (pos(find_str,str) > 0) then nop           /* @AO */\n                else 'tbdelete' TABLEB                        /* @AO */\n                'tbskip' TABLEB                               /* @AO */\n                if (rc > 0) then do                           /* @AO */\n                   'tbtop' TABLEB                             /* @AO */\n                   leave                                      /* @AO */\n                end                                           /* @AO */\n             end                                              /* @AO */\n        END                                                   /* @AO */\n        WHEN (ABBREV(\"RESET\",ZCMD,1) = 1) THEN DO             /* @AO */\n             sort     = 'PROFILE,C,A'                         /* @AO */\n             sortprof = 'D'                                   /* @AW */\n             xtdtop   = 1                                     /* @AO */\n             rc = get_permits(class,user) /*get permits*/     /* @AO */\n        END                                                   /* @AO */\n        When (abbrev(\"SAVE\",zcmd,2) = 1) then DO              /* @BK */\n             TMPSKELT = SKELETON2                             /* @BK */\n             call do_SAVE                                     /* @BK */\n        END                                                   /* @BK */\n        WHEN (ABBREV(\"SORT\",ZCMD,1) = 1) THEN DO              /* @BI */\n             call sortseq 'PROFILE'                           /* @AW */\n             \"TBSORT \"TABLEB\" FIELDS(\"SORT\")\"                 /* @BI */\n             \"TBTOP  \"TABLEB                                  /* @BI */\n        END                                                   /* @BI */\n        otherwise locvar=''\n     End\n     ZCMD = \"\"; PARM = \"\"                                     /* @BI */\n     'control display save'                                   /* @BI */\n     Select\n        when (opta = 'L') then call lisd                      /* @AS */\n        when (opta = 'S') then\n             x = RACFCLSA(class profile user)\n        otherwise nop\n     End\n     'control display restore'                                /* @BI */\n  end  /* Do forever) */                                      /* @BI */\nRETURN 0\n/*--------------------------------------------------------------------*/\n/*  Process primary command FIND for tableb                      @BH  */\n/*--------------------------------------------------------------------*/\nDO_FINDB:                                                     /* @BH */\n  if (parm = null) then do                                    /* @BH */\n     racfsmsg = 'Error'                                       /* @BH */\n     racflmsg = 'Find requires a value to search for.' ,      /* @BH */\n                'Try again.'                                  /* @BH */\n     'setmsg msg(RACF011)'                                    /* @BH */\n     return                                                   /* @BH */\n  end                                                         /* @BH */\n  findit    = translate(parm)                                 /* @BH */\n  last_find = 0                                               /* @BH */\n  wrap      = 0                                               /* @BH */\n  do forever                                                  /* @BH */\n     'tbskip' TABLEB                                          /* @BH */\n     if (rc > 0) then do                                      /* @BH */\n        if (wrap = 1) then do                                 /* @BH */\n           racfsmsg = 'Not Found'                             /* @BH */\n           racflmsg = findit 'not found.'                     /* @BH */\n           'setmsg msg(RACF011)'                              /* @BH */\n           return                                             /* @BH */\n        end                                                   /* @BH */\n        if (wrap = 0) then wrap = 1                           /* @BH */\n        'tbtop' TABLEB                                        /* @BH */\n     end                                                      /* @BH */\n     else do                                                  /* @BH */\n        testit = translate(profile)                           /* @BH */\n        if (pos(findit,testit) > 0) then do                   /* @BH */\n           'tbquery' TABLEB 'position(srow)'                  /* @BH */\n           'tbtop'   TABLEB                                   /* @BH */\n           'tbskip'  TABLEB 'number('srow')'                  /* @BH */\n           last_find = srow                                   /* @BH */\n           xtdtop    = srow                                   /* @BH */\n           if (wrap = 0) then                                 /* @BH */\n              racfsmsg = 'Found'                              /* @BH */\n           else                                               /* @BH */\n              racfsmsg = 'Found/Wrapped'                      /* @BH */\n           racflmsg = findit 'found in row' srow + 0          /* @BH */\n           'setmsg msg(RACF011)'                              /* @BH */\n           return                                             /* @BH */\n        end                                                   /* @BH */\n     end                                                      /* @BH */\n  end                                                         /* @BH */\nRETURN                                                        /* @BH */\n/*--------------------------------------------------------------------*/\n/*  Process primary command FIND for tablea                      @BH  */\n/*--------------------------------------------------------------------*/\nDO_FINDA:                                                     /* @BH */\n  if (parm = null) then do                                    /* @BH */\n     racfsmsg = 'Error'                                       /* @BH */\n     racflmsg = 'Find requires a value to search for.' ,      /* @BH */\n                'Try again.'                                  /* @BH */\n     'setmsg msg(RACF011)'                                    /* @BH */\n     return                                                   /* @BH */\n  end                                                         /* @BH */\n  findit    = translate(parm)                                 /* @BH */\n  last_find = 0                                               /* @BH */\n  wrap      = 0                                               /* @BH */\n  do forever                                                  /* @BH */\n     'tbskip' TABLEA                                          /* @BH */\n     if (rc > 0) then do                                      /* @BH */\n        if (wrap = 1) then do                                 /* @BH */\n           racfsmsg = 'Not Found'                             /* @BH */\n           racflmsg = findit 'not found.'                     /* @BH */\n           'setmsg msg(RACF011)'                              /* @BH */\n           return                                             /* @BH */\n        end                                                   /* @BH */\n        if (wrap = 0) then wrap = 1                           /* @BH */\n        'tbtop' TABLEA                                        /* @BH */\n     end                                                      /* @BH */\n     else do                                                  /* @BH */\n        testit = translate(class)                             /* @BH */\n        if (pos(findit,testit) > 0) then do                   /* @BH */\n           'tbquery' TABLEA 'position(srow)'                  /* @BH */\n           'tbtop'   TABLEA                                   /* @BH */\n           'tbskip'  TABLEA 'number('srow')'                  /* @BH */\n           last_find = srow                                   /* @BH */\n           xtdtop    = srow                                   /* @BH */\n           if (wrap = 0) then                                 /* @BH */\n              racfsmsg = 'Found'                              /* @BH */\n           else                                               /* @BH */\n              racfsmsg = 'Found/Wrapped'                      /* @BH */\n           racflmsg = findit 'found in row' srow + 0          /* @BH */\n           'setmsg msg(RACF011)'                              /* @BH */\n           return                                             /* @BH */\n        end                                                   /* @BH */\n     end                                                      /* @BH */\n  end                                                         /* @BH */\nRETURN                                                        /* @BH */\n/*--------------------------------------------------------------------*/\n/*  Define sort sequence, to allow point-n-shoot sorting (A/D)   @AW  */\n/*--------------------------------------------------------------------*/\nSORTSEQ:                                                      /* @AW */\n  parse arg sortcol                                           /* @AW */\n  INTERPRET \"TMPSEQ = SORT\"substr(SORTCOL,1,4)                /* @AW */\n  select                                                      /* @AW */\n     when (seq <> \"\") then do                                 /* @AW */\n          if (seq = 'A') then                                 /* @AW */\n             tmpseq = 'D'                                     /* @AW */\n          else                                                /* @AW */\n             tmpseq = 'A'                                     /* @AW */\n          sort = sortcol',C,'seq                              /* @AW */\n     end                                                      /* @AW */\n     when (seq = \"\"),                                         /* @AW */\n        & (tmpseq = 'A') then do                              /* @AW */\n           sort   = sortcol',C,A'                             /* @AW */\n           tmpseq = 'D'                                       /* @AW */\n     end                                                      /* @AW */\n     Otherwise do                                             /* @AW */\n        sort   = sortcol',C,D'                                /* @AW */\n        tmpseq = 'A'                                          /* @AW */\n     end                                                      /* @AW */\n  end                                                         /* @AW */\n  INTERPRET \"SORT\"SUBSTR(SORTCOL,1,4)\" = TMPSEQ\"              /* @AW */\nRETURN                                                        /* @AW */\n/*--------------------------------------------------------------------*/\n/*  Select class                                                      */\n/*--------------------------------------------------------------------*/\nSELECT_CLASS:\n  call get_act_class\n  rc = display_table()\n  \"TBEND\" TABLEA\nRETURN\n/*--------------------------------------------------------------------*/\n/*  Display profile permits                                           */\n/*--------------------------------------------------------------------*/\nGET_ACT_CLASS:\n  seconds = time('S')                                         /* @AB */\n  \"TBCREATE\" TABLEA \"KEYS(CLASS)\",                            /* @AB */\n                  \"NAMES(ACTION) REPLACE NOWRITE\"             /* @AB */\n  Scan = 'OFF'                                                /* @AB */\n  cmd  = \"SETROPTS LIST\"                                      /* @A5 */\n  x = OUTTRAP('var.')\n  address TSO cmd                                             /* @A5 */\n  cmd_rc = rc                                                 /* @AK */\n  x = OUTTRAP('OFF')\n  if (SETMSHOW <> 'NO') then                                  /* @AU */\n     call SHOWCMD                                             /* @A5 */\n  Do i = 1 to var.0           /* Scan output */\n     temp = var.i\n     if (rlv > '1081') then   /* RACF 1.9 add blank */\n        temp = ' 'temp\n     Select\n        when (substr(temp,2,16) = 'ACTIVE CLASSES =') then do\n             scan   = 'ON'\n             record = substr(temp,18,80)\n             nwords = words(record)\n             do t = 1 to nwords\n                class = subword(record,t,1)\n                if (class <> 'USER'),\n                 & (class <> 'DATASET'),\n                 & (class <> 'GROUP') then\n                   \"TBMOD\" TABLEA\n             end\n        end\n        when (substr(temp,2,25) =,\n             'GENERIC PROFILE CLASSES =') then leave\n        otherwise\n             if (scan = 'ON') then do\n                  record = var.i\n                  nwords = words(record)\n                  do t = 1 to nwords\n                     class = subword(record,t,1)\n                     if (class <> 'USER'),\n                      & (class <> 'DATASET'),\n                      & (class <> 'GROUP') then\n                        \"TBMOD\" TABLEA\n                  end\n             end\n     End    /* end_select */\n  end  /* end_scan output */\n  sort     = 'CLASS,C,A'                                      /* @BI */\n  sortclas = 0                                                /* @BI */\n  \"TBSORT \" TABLEA \"FIELDS(\"sort\")\"                           /* @BI */\n  \"TBTOP  \" TABLEA                                            /* @BI */\nRETURN\n/*--------------------------------------------------------------------*/\n/*  Display table A                                                   */\n/*--------------------------------------------------------------------*/\nDISPLAY_TABLE:\n  opta   = ' '\n  xtdtop = 0                                                  /* @BI */\n  rsels  = 0                                                  /* @BI */\n  do forever                                                  /* @BI */\n     if (rsels < 2) then do                                   /* @BI */\n        \"TBTOP \" TABLEA                                       /* @BI */\n        'tbskip' tablea 'number('xtdtop')'                    /* @BI */\n        radmrfnd = 'PASSTHRU'                                 /* @BI */\n        'vput (radmrfnd)'                                     /* @BI */\n        \"TBDISPL\" TABLEA \"PANEL(\"PANEL13\")\"                   /* @BI */\n     end                                                      /* @BI */\n     else 'tbdispl' tablea                                    /* @BI */\n     if (rc > 4) then leave                                   /* @BI */\n     xtdtop   = ztdtop                                        /* @BI */\n     rsels    = ztdsels                                       /* @BI */\n     radmrfnd = null                                          /* @BI */\n     'vput (radmrfnd)'                                        /* @BI */\n     PARSE VAR ZCMD ZCMD PARM SEQ                             /* @BI */\n     IF (SROW <> \"\") & (SROW <> 0) THEN                       /* @A9 */\n        IF (SROW > 0) THEN DO                                 /* @A9 */\n           \"TBTOP \" TABLEA                                    /* @A9 */\n           \"TBSKIP\" TABLEA \"NUMBER(\"SROW\")\"                   /* @A9 */\n        END                                                   /* @A9 */\n     if (zcmd = 'RFIND') then do                              /* @BH */\n        zcmd = 'FIND'                                         /* @BH */\n        parm = findit                                         /* @BH */\n        'tbtop ' TABLEA                                       /* @BH */\n        'tbskip' TABLEA 'number('last_find')'                 /* @BH */\n     end                                                      /* @BH */\n     Select                                                   /* @AB */\n        When (abbrev(\"FIND\",zcmd,1) = 1) then                 /* @BH */\n             call do_finda                                    /* @BH */\n        WHEN (ABBREV(\"LOCATE\",ZCMD,1) = 1) THEN do            /* @BI */\n             if (parm <> '') then do                          /* @BI */\n                locarg = parm'*'                              /* @BI */\n                PARSE VAR SORT . \",\" . \",\" SEQ                /* @BI */\n                IF (SEQ = \"D\") THEN                           /* @BI */\n                   CONDLIST = \"LE\"                            /* @BI */\n                ELSE                                          /* @BI */\n                   CONDLIST = \"GE\"                            /* @BI */\n                parse value sort with scan_field',' .         /* @BI */\n                interpret scan_field ' = locarg'              /* @BI */\n                'tbtop ' tablea                               /* @BI */\n                \"TBSCAN \"TABLEA\" ARGLIST(\"scan_field\")\",      /* @BI */\n                        \"CONDLIST(\"CONDLIST\")\",               /* @BI */\n                        \"position(scanrow)\"                   /* @BI */\n                xtdtop = scanrow                              /* @BI */\n             end                                              /* @BI */\n        end                                                   /* @BI */\n        WHEN (ABBREV(\"ONLY\",ZCMD,1) = 1) THEN DO              /* @AB */\n             find_str = translate(parm)                       /* @AB */\n             'tbtop ' TABLEA                                  /* @AB */\n             'tbskip' TABLEA                                  /* @AB */\n             do forever                                       /* @AB */\n                str = translate(class)                        /* @AB */\n                if (pos(find_str,str) > 0) then nop           /* @AB */\n                else 'tbdelete' TABLEA                        /* @AB */\n                'tbskip' TABLEA                               /* @AB */\n                if (rc > 0) then do                           /* @AB */\n                   'tbtop' TABLEA                             /* @AB */\n                   leave                                      /* @AB */\n                end                                           /* @AB */\n             end                                              /* @AB */\n        END                                                   /* @AB */\n        WHEN (ABBREV(\"RESET\",ZCMD,1) = 1) THEN DO             /* @AB */\n             call get_act_class                               /* @AB */\n             sort     = 'CLASS,C,A'                           /* @AD */\n             sortclas = 'A'                                   /* @AW */\n             xtdtop   = 1                                     /* @AB */\n        END                                                   /* @AB */\n        When (abbrev(\"SAVE\",zcmd,2) = 1) then DO              /* @BM */\n             TMPSKELT = SKELETON1                             /* @BM */\n             call do_SAVE                                     /* @BM */\n        END                                                   /* @BM */\n        WHEN (ABBREV(\"SORT\",ZCMD,1) = 1) THEN DO              /* @BI */\n             call sortseq 'CLASS'                             /* @AW */\n             \"TBSORT\" TABLEA \"FIELDS(\"sort\")\"                 /* @BI */\n             \"TBTOP \" TABLEA                                  /* @BI */\n        END                                                   /* @BI */\n        otherwise NOP                                         /* @AB */\n     END /* Select */                                         /* @AB */\n     ZCMD = \"\"; PARM = \"\"                                     /* @BI */\n     'control display save'                                   /* @BI */\n     select\n        when (opta = 'L') then call lisp                      /* @AR */\n        when (opta = 'S') then do\n             DISPCLS = CLASS                                  /* @AC */\n             rc = get_permits(class,user) /*get permits*/\n             'control display restore'                        /* @BI */\n             selection = 1\n             leave                                            /* @BI */\n        end\n        otherwise nop\n     End\n  end  /* Do forever) */                                      /* @BI */\nRETURN 0\n/*--------------------------------------------------------------------*/\n/*  List class                                                   @AR  */\n/*--------------------------------------------------------------------*/\nLISP:                                                         /* @AR */\n  cmd     = \"RL \"CLASS\" * ALL\"                                /* @AT */\n  X = OUTTRAP(\"CMDREC.\")                                      /* @AR */\n  ADDRESS TSO cmd                                             /* @AR */\n  cmd_rc = rc                                                 /* @AR */\n  X = OUTTRAP(\"OFF\")                                          /* @AR */\n  if (SETMSHOW <> 'NO') then                                  /* @AU */\n     call SHOWCMD                                             /* @AR */\n  if (cmd_rc > 0) then do   /* Remove parms */                /* @AR */\n     cmd     = \"RL \"CLASS\" *\"                                 /* @AT */\n     X = OUTTRAP(\"CMDREC.\")                                   /* @AR */\n     ADDRESS TSO cmd                                          /* @AR */\n     cmd_rc = rc                                              /* @AR */\n     X = OUTTRAP(\"OFF\")                                       /* @AR */\n     if (SETMSHOW <> 'NO') then                               /* @AU */\n        call SHOWCMD                                          /* @AR */\n  end                                                         /* @AR */\n  call display_info                                           /* @A8 */\n  if (cmd_rc > 0) then                                        /* @AR */\n     CALL racfmsgs \"ERR10\" /* Generic failure */              /* @AR */\nRETURN                                                        /* @AR */\n/*--------------------------------------------------------------------*/\n/*  Display information from line commands 'L' and 'P'           @AY  */\n/*--------------------------------------------------------------------*/\nDISPLAY_INFO:                                                 /* @AY */\n  ADDRESS TSO \"ALLOC F(\"DDNAME\") NEW REUSE\",                  /* @AR */\n              \"LRECL(80) BLKSIZE(0) RECFM(F B)\",              /* @B1 */\n              \"UNIT(VIO) SPACE(1 5) CYLINDERS\"                /* @AR */\n  ADDRESS TSO \"EXECIO * DISKW \"DDNAME\" (STEM CMDREC. FINIS\"   /* @AR */\n  DROP CMDREC.                                                /* @BJ */\n                                                              /* @BJ */\n  \"LMINIT DATAID(CMDDATID) DDNAME(\"DDNAME\")\"                  /* @AR */\n  SELECT                                                      /* @AR */\n     WHEN (SETGDISP = \"VIEW\") THEN                            /* @AR */\n          \"VIEW DATAID(\"CMDDATID\") MACRO(\"EDITMACR\")\"         /* @AX */\n     WHEN (SETGDISP = \"EDIT\") THEN                            /* @AR */\n          \"EDIT DATAID(\"CMDDATID\") MACRO(\"EDITMACR\")\"         /* @AX */\n     OTHERWISE                                                /* @AR */\n          \"BROWSE DATAID(\"CMDDATID\")\"                         /* @AR */\n  END                                                         /* @AR */\n  ADDRESS TSO \"FREE FI(\"DDNAME\")\"                             /* @AR */\nRETURN                                                        /* @AY */\n/*--------------------------------------------------------------------*/\n/*  List class's profile                                         @AS  */\n/*--------------------------------------------------------------------*/\nLISD:                                                         /* @AS */\n  cmd  = \"RLIST \"CLASS PROFILE\" AUTH\"                         /* @AS */\n  X    = OUTTRAP(\"CMDREC.\")                                   /* @AS */\n  ADDRESS TSO cmd                                             /* @AS */\n  cmd_rc = rc                                                 /* @AS */\n  X    = OUTTRAP(\"OFF\")                                       /* @AS */\n  if (SETMSHOW <> 'NO') then                                  /* @AU */\n     call SHOWCMD                                             /* @AS */\n  if (cmd_rc > 0) then do    /* Remove parms */               /* @AS */\n     cmd = \"RLIST \"RCLASS PROFILE                             /* @AS */\n     X = OUTTRAP(\"CMDREC.\")                                   /* @AS */\n     ADDRESS TSO cmd                                          /* @AS */\n     cmd_rc = rc                                              /* @AS */\n     X = OUTTRAP(\"OFF\")                                       /* @AS */\n     if (SETMSHOW <> 'NO') then                               /* @AU */\n        call SHOWCMD                                          /* @AS */\n  end                                                         /* @AS */\n  call display_info                                           /* @A8 */\n  if (cmd_rc > 0) then                                        /* @AS */\n     CALL racfmsgs \"ERR10\" /* Generic failure */              /* @AS */\nRETURN                                                        /* @AS */\n/*--------------------------------------------------------------------*/\n/*  Display RACF command and return code                         @AV  */\n/*--------------------------------------------------------------------*/\nSHOWCMD:                                                      /* @AV */\n  IF (SETMSHOW = \"BOTH\") | (SETMSHOW = \"DISPLAY\") THEN DO     /* @AV */\n     PARSE VAR CMD MSG1 60 MSG2 121 MSG3                      /* @AV */\n     MSG4 = \"Return code = \"cmd_rc                            /* @AK */\n     \"ADDPOP ROW(6) COLUMN(4)\"                                /* @AH */\n     \"DISPLAY PANEL(\"PANELM2\")\"                               /* @AG */\n     \"REMPOP\"                                                 /* @AH */\n  END                                                         /* @AU */\n  IF (SETMSHOW = \"BOTH\") | (SETMSHOW = \"LOG\") THEN DO         /* @AV */\n     zerrsm = \"RACFADM \"REXXPGM\" RC=\"cmd_rc                   /* @B6 */\n     zerrlm = cmd                                             /* @AU */\n     'log msg(isrz003)'                                       /* @AU */\n  END                                                         /* @AU */\nRETURN                                                        /* @AV */\n/*--------------------------------------------------------------------*/\n/*  Save table to dataset                                        @BK  */\n/*--------------------------------------------------------------------*/\nDO_SAVE:                                                      /* @BK */\n  X = MSG(\"OFF\")                                              /* @BK */\n  \"ADDPOP COLUMN(40)\"                                         /* @BK */\n  \"VGET (RACFSDSN RACFSMBR RACFSFIL RACFSREP) PROFILE\"        /* @BL */\n  IF (RACFSDSN = \"\") THEN         /* SAve - Dataset Name  */  /* @BN */\n     RACFSDSN = USERID()\".RACFADM.REPORTS\"                    /* @EK */\n  IF (RACFSFIL = \"\") THEN         /* SAve - As (TXT/CVS)  */  /* @BN */\n     RACFSFIL = \"T\"                                           /* @EL */\n  IF (RACFSREP = \"\") THEN         /* SAve - Replace (Y/N) */  /* @BN */\n     RACFSREP = \"N\"                                           /* @EK */\n                                                              /* @BK */\n  DO FOREVER                                                  /* @BK */\n     \"DISPLAY PANEL(\"PANELS1\")\"                               /* @BK */\n     IF (RC = 08) THEN DO                                     /* @BK */\n        \"REMPOP\"                                              /* @BK */\n        RETURN                                                /* @BK */\n     END                                                      /* @BK */\n     RACFSDSN = STRIP(RACFSDSN,,\"'\")                          /* @BK */\n     RACFSDSN = STRIP(RACFSDSN,,'\"')                          /* @BK */\n     RACFSDSN = STRIP(RACFSDSN)                               /* @BK */\n     SYSDSORG = \"\"                                            /* @BK */\n     X = LISTDSI(\"'\"RACFSDSN\"'\")                              /* @BK */\n     IF (SYSDSORG = \"\") | (SYSDSORG = \"PS\"),                  /* @BK */\n      | (SYSDSORG = \"PO\") THEN                                /* @BK */\n        NOP                                                   /* @BK */\n     ELSE DO                                                  /* @BK */\n        RACFSMSG = \"Not PDS/Seq File\"                         /* @BK */\n        RACFLMSG = \"The dataset specified is not\",            /* @BK */\n                  \"a partitioned or sequential\",              /* @BK */\n                  \"dataset, please enter a valid\",            /* @BK */\n                  \"dataset name.\"                             /* @BK */\n       \"SETMSG MSG(RACF011)\"                                  /* @BK */\n       ITERATE                                                /* @BK */\n     END                                                      /* @BK */\n     IF (SYSDSORG = \"PS\") & (RACFSMBR <> \"\") THEN DO          /* @BK */\n        RACFSMSG = \"Seq File - No mbr\"                        /* @BK */\n        RACFLMSG = \"This dataset is a sequential\",            /* @BK */\n                  \"file, please remove the\",                  /* @BK */\n                  \"member name.\"                              /* @BK */\n       \"SETMSG MSG(RACF011)\"                                  /* @BK */\n       ITERATE                                                /* @BK */\n     END                                                      /* @BK */\n     IF (SYSDSORG = \"PO\") & (RACFSMBR = \"\") THEN DO           /* @BK */\n        RACFSMSG = \"PDS File - Need Mbr\"                      /* @BK */\n        RACFLMSG = \"This dataset is a partitioned\",           /* @BK */\n                  \"dataset, please include a member\",         /* @BK */\n                  \"name.\"                                     /* @BK */\n       \"SETMSG MSG(RACF011)\"                                  /* @BK */\n       ITERATE                                                /* @BK */\n     END                                                      /* @BK */\n                                                              /* @BK */\n     IF (RACFSMBR = \"\") THEN                                  /* @BK */\n        TMPDSN = RACFSDSN                                     /* @BK */\n     ELSE                                                     /* @BK */\n        TMPDSN = RACFSDSN\"(\"RACFSMBR\")\"                       /* @BK */\n     DSNCHK = SYSDSN(\"'\"TMPDSN\"'\")                            /* @BK */\n     IF (DSNCHK = \"OK\" & RACFSREP = \"N\") THEN DO              /* @BK */\n        RACFSMSG = \"DSN/MBR Exists\"                           /* @BK */\n        RACFLMSG = \"Dataset/member already exists. \",         /* @BK */\n                  \"Please type in \"Y\" to replace file.\"       /* @BK */\n        \"SETMSG MSG(RACF011)\"                                 /* @BK */\n        ITERATE                                               /* @BK */\n     END                                                      /* @BK */\n     LEAVE                                                    /* @BK */\n  END                                                         /* @BK */\n  \"REMPOP\"                                                    /* @BK */\n  \"VPUT (RACFSDSN RACFSMBR RACFSFIL RACFSREP) PROFILE\"        /* @BL */\n                                                              /* @BK */\nADDRESS TSO                                                   /* @BK */\n  IF (RACFSREP = \"Y\" & RACFSMBR = \"\") |,                      /* @BK */\n     (DSNCHK <> \"OK\" & DSNCHK <> \"MEMBER NOT FOUND\"),         /* @BK */\n     THEN DO                                                  /* @BK */\n     \"DELETE '\"RACFSDSN\"'\"                                    /* @BK */\n     IF (RACFSMBR = \"\") THEN                                  /* @BK */\n        \"ALLOC  FI(ISPFILE) DA('\"RACFSDSN\"') NEW\",            /* @BK */\n            \"REUSE SP(1 1) CYLINDER UNIT(SYSALLDA)\",          /* @BO */\n            \"LRECL(80) RECFM(F B)\"                            /* @BK */\n     ELSE                                                     /* @BK */\n        \"ALLOC  FI(ISPFILE) DA('\"RACFSDSN\"') NEW\",            /* @BK */\n            \"REUSE SP(1 1) CYLINDER UNIT(SYSALLDA)\",          /* @BO */\n            \"LRECL(80) RECFM(F B)\",                           /* @BK */\n            \"DSORG(PO) DSNTYPE(LIBRARY,2)\"                    /* @BK */\n  END                                                         /* @BK */\n  ELSE                                                        /* @BK */\n     \"ALLOC  FI(ISPFILE) DA('\"RACFSDSN\"') SHR REUSE\"          /* @BK */\n                                                              /* @BK */\nADDRESS ISPEXEC                                               /* @BK */\n  \"FTOPEN\"                                                    /* @BK */\n  \"FTINCL \"TMPSKELT                                           /* @BK */\n  IF (RACFSMBR = \"\") THEN                                     /* @BK */\n     \"FTCLOSE\"                                                /* @BK */\n  ELSE                                                        /* @BK */\n     \"FTCLOSE NAME(\"RACFSMBR\")\"                               /* @BK */\n  ADDRESS TSO \"FREE FI(ISPFILE)\"                              /* @BK */\n                                                              /* @BK */\n  SELECT                                                      /* @BK */\n     WHEN (SETGDISP = \"VIEW\") THEN                            /* @BK */\n          \"VIEW DATASET('\"RACFSDSN\"') MACRO(\"EDITMACR\")\"      /* @BK */\n     WHEN (SETGDISP = \"EDIT\") THEN                            /* @BK */\n          \"EDIT DATASET('\"RACFSDSN\"') MACRO(\"EDITMACR\")\"      /* @BK */\n     OTHERWISE                                                /* @BK */\n          \"BROWSE DATASET('\"RACFSDSN\"')\"                      /* @BK */\n  END                                                         /* @BK */\n  X = MSG(\"ON\")                                               /* @BK */\n                                                              /* @BK */\nRETURN                                                        /* @BK */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RACFCMDS": {"ttr": 947, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01-\\x007\\x01 \\x12\\x0f\\x01 &\\x1f\\x15\\x11\\x01\\x14\\x019\\x00\\x00\\xd9\\xc1\\xc3\\xc6\\xc1\\xc4\\xd4@@@'", "ispf": {"version": "01.45", "flags": 0, "createdate": "2020-04-29T00:00:00", "modifydate": "2020-09-17T15:11:37", "lines": 276, "newlines": 313, "modlines": 0, "user": "RACFADM"}, "text": "/*%NOCOMMENT====================* REXX *==============================*/\n/*  PURPOSE:  RACFADM - Execute RACF Commands - Menu option C         */\n/*--------------------------------------------------------------------*/\n/*  NOTES:    1) This REXX program will save the commands entered     */\n/*               into the user's dataset allocated to ISPTABLE or     */\n/*               ISPPROF in member RACFCMDS                           */\n/*--------------------------------------------------------------------*/\n/* FLG  YYMMDD  USERID   DESCRIPTION                                  */\n/* ---  ------  -------  -------------------------------------------- */\n/* @AA  200913  LBD      Display RACF command in flower box at top    */\n/* @A9  200628  RACFA    Added parm GEN to LISTDSD command            */\n/* @A8  200619  RACFA    Initalize the variable NULL                  */\n/* @A7  200519  TRIDJK   Allow logging of RACF commands               */\n/* @A6  200430  RACFA    Added skeleton RACF commands to table        */\n/* @A5  200430  RACFA    Place table name in variable at top of REXX  */\n/* @A4  200429  RACFA    Standardize ddname, etc.                     */\n/* @A3  200429  RACFA    Chk Setting's 'REXX trace'                   */\n/* @A2  200429  RACFA    Chg HELP PF-Key to invoke 'TSO RACFHELP'     */\n/* @A1  200429  RACFA    Get Settings (Opt 0) 'Display files' to view */\n/* @A0  200429  LBD      Created REXX                                 */\n/*====================================================================*/\nPANEL01     = \"RACFCMDS\"   /* Execute RACF command         */ /* @A1 */\nPANELM2     = \"RACFMSG2\"   /* Display RACF command and RC  */ /* @A7 */\nEDITMACR    = \"RACFEMAC\"   /* Edit Macro, turn HILITE off  */ /* @A1 */\nDDNAME      = 'RACFA'RANDOM(0,999) /* Unique ddname        */\nTABLE       = \"RACFACMD\"   /* Permanent table in ISPPROF   */ /* @A5 */\nRACFCMDS.   = \"\"                                              /* @A6 */\nRACFCMDS.0  = 7            /* Populate table w/ RACF cmds  */ /* @A6 */\nRACFCMDS.1  = \"LU ?        CICS CSDATA DCE DFP EIM KERB\",     /* @A6 */\n              \"LANGUAGE LNOTES MFA NDS NETVIEW OMVS\",         /* @A6 */\n              \"OPERPARM OVM PROXY TSO WORKATTR\"               /* @A6 */\nRACFCMDS.2  = \"LG ?        CSDATA DFP OMVS OVM TME\"           /* @A6 */\nRACFCMDS.3  = \"LISTDSD DATASET('\"?\"                  ')\",     /* @A6 */\n              \"ALL GEN\"                                       /* @A9 */\nRACFCMDS.4  = \"RL ?        * ALL\"                             /* @A6 */\nRACFCMDS.5  = \"RL ?        ?        AUTH\"                     /* @A6 */\nRACFCMDS.6  = \"SEARCH CLASS(?       ) USER(?       )\"         /* @A6 */\nRACFCMDS.7  = \"SETROPTS LIST\"                                 /* @A6 */\nNULL        = ''                                              /* @A8 */\nparse source . . REXXPGM .         /* Obtain REXX pgm name */ /* @A3 */\nREXXPGM     = LEFT(REXXPGM,8)                                 /* @A3 */\n\nADDRESS ISPEXEC\n  \"VGET (SETGDISP SETMSHOW SETMTRAC) PROFILE\"                 /* @A7 */\n  If (SETMTRAC <> 'NO') then do                               /* @A3 */\n     Say \"*\"COPIES(\"-\",70)\"*\"                                 /* @A3 */\n     Say \"*\"Center(\"Begin Program = \"REXXPGM,70)\"*\"           /* @A3 */\n     Say \"*\"COPIES(\"-\",70)\"*\"                                 /* @A3 */\n     if (SETMTRAC <> 'PROGRAMS') THEN                         /* @A3 */\n        interpret \"Trace \"SUBSTR(SETMTRAC,1,1)                /* @A3 */\n  end                                                         /* @A3 */\n  \"VGET (ZPF01 ZPF02 ZPF03 ZPF04 ZPF05 ZPF06 ZPF07 ZPF08\",    /* @A2 */\n         ZPF09 ZPF10 ZPF11 ZPF12 ZPF13 ZPF14 ZPF15 ZPF16\",    /* @A2 */\n         ZPF17 ZPF18 ZPF19 ZPF20 ZPF21 ZPF22 ZPF23 ZPF24)\"    /* @A2 */\n  DO J = 1 TO 24                                              /* @A2 */\n     K = RIGHT(J,2,0)                                         /* @A2 */\n     INTERPRET \"PFKEY = ZPF\"K                                 /* @A2 */\n     UPPER PFKEY                                              /* @A2 */\n     IF (PFKEY = \"HELP\") THEN DO                              /* @A2 */\n        INTERPRET \"ZPF\"K\" = 'TSO RACFHELP'\"                   /* @A2 */\n        \"VPUT (ZPF\"K\")\"                                       /* @A2 */\n     END                                                      /* @A2 */\n  END                                                         /* @A2 */\n\n  parse arg cmd\n\n  parse value '' with null rcsel\n  /* ---------------------------------------------------- *\n  | Set ISPExec                                          |\n  | Get the ISPF vars from ZIGI for localrep and zigirep |\n  | Define localdir as a composite variable              |\n  * ---------------------------------------------------- */\n  'Control Errors Return'\n\n  /* -------------------------------------------------- *\n  | Check to see if the user has ISPTABL allocated and |\n  | if not then use ISPPROF as our table DD            |\n  * -------------------------------------------------- */\n  isptabl = 'ISPTABL'\n  x = listdsi(isptabl 'FILE')\n  if (x > 0) then isptabl = 'ISPPROF'\n\n  /* ----------------------------------------------------- *\n  | Open the table but if it doesn't exist then create it |\n  * ----------------------------------------------------- */\n  'TBOpen 'table' Library('isptabl') Write Share'             /* @A5 */\n  if (rc > 0) then do\n     'tbcreate 'table' keys(racfcmde)',                       /* @A5 */\n              'library('isptabl') write share'\n      call populate\n  end\n\n  /* -------------------- *\n  | Setup table defaults |\n  * -------------------- */\n  ztdtop = 0\n  ztdsels = 0\n\n  /* ---------------------------------------------------------------- *\n  | Process the table.                                               |\n  |                                                                  |\n  | Row selections:  S to copy the command to the git command  entry |\n  |                  D to delete the command (supports multipe row   |\n  |                    selections)                                   |\n  |                  X to execute the command now and update the     |\n  |                    git command entry field                       |\n  * ---------------------------------------------------------------- */\n  do forever\n     if (ztdsels = 0) then do\n        'tbtop   'table                                       /* @A5 */\n        'tbskip  'table' number('ztdtop')'                    /* @A5 */\n        'tbdispl 'table' panel('panel01') cursor(racfcmd)'    /* @A5 */\n     end\n     else\n        'tbdispl racfacmd'\n     if (rc > 4) then leave\n     if (row = 0) then rcsel = null\n     if (row <> null) then\n        if (row > 0) then do\n          'TBTop  'table                                      /* @A5 */\n          'TBSkip 'table' Number('row')'                      /* @A5 */\n        end\n     Select\n        When (zcmd = 'CLEAR') then do\n             'tbclose  'table' replcopy library('isptabl')'   /* @A5 */\n             'tberase  'table' library('isptabl')'            /* @A5 */\n             'tbcreate 'table' keys(racfcmde)',               /* @A5 */\n                      'library('isptabl') write share'\n             racfcmd = null\n        end\n        When (rcsel = 'D') then 'tbdelete 'table              /* @A5 */\n        When (rcsel = 'S') then do\n             racfcmd = racfcmde\n             ztdsels = 0\n        end\n        When (rcsel = 'X') then do\n             racfcmd = racfcmde\n             ztdsels = 0\n             call do_racfcmd\n        end\n        When (racfcmd /= null) then call do_racfcmd\n        Otherwise nop\n     end\n     rcsel = null\n  end\n\n  /* -------------- *\n  | Close and exit |\n  * -------------- */\n  'tbclose 'table' replcopy library('isptabl')'               /* @A5 */\n\n  DO J = 1 TO 24                                              /* @A2 */\n     K = RIGHT(J,2,0)                                         /* @A2 */\n     INTERPRET \"PFKEY = ZPF\"K                                 /* @A2 */\n     IF (PFKEY = \"TSO RACFHELP\") THEN DO                      /* @A2 */\n        INTERPRET \"ZPF\"K\" = 'HELP'\"                           /* @A2 */\n        \"VPUT (ZPF\"K\")\"                                       /* @A2 */\n     END                                                      /* @A2 */\n  END                                                         /* @A2 */\n\n  If (SETMTRAC <> 'NO') then do                               /* @A3 */\n     Say \"*\"COPIES(\"-\",70)\"*\"                                 /* @A3 */\n     Say \"*\"Center(\"End Program = \"REXXPGM,70)\"*\"             /* @A3 */\n     Say \"*\"COPIES(\"-\",70)\"*\"                                 /* @A3 */\n  end                                                         /* @A3 */\nEXIT\n/*--------------------------------------------------------------------*/\n/*  Execute the racf command                                          */\n/*--------------------------------------------------------------------*/\nDO_RACFCMD:\n  cmd_rc = 0                                                  /* @AA */\n  racfcmde = racfcmd\n  'tbadd 'table                                               /* @A5 */\n  call outtrap 'so.'\n  do until racfcmd = null                                     /* @AA */\n     parse value racfcmd with racfcmde';'racfcmd              /* @AA */\n     call racfputl '*'copies('-',70)'*'                       /* @AA */\n     call racfputl '* Command:' racfcmde                      /* @AA */\n     call racfputl '*'copies('-',70)'*'                       /* @AA */\n     Address TSO racfcmde                                     /* @AA */\n     if rc > cmd_rc then cmd_rc = rc                          /* @AA */\n     end                                                      /* @AA */\n  call outtrap 'off'\n  cmd = racfcmde                                              /* @A7 */\n  if (SETMSHOW <> 'NO') then                                  /* @A7 */\n     call SHOWCMD                                             /* @A7 */\n  call view_std\nRETURN\n/*--------------------------------------------------------------------*/\n/*  Display RACF command and return code                         @A7  */\n/*--------------------------------------------------------------------*/\nSHOWCMD:                                                      /* @A7 */\n  IF (SETMSHOW = \"BOTH\") | (SETMSHOW = \"DISPLAY\") THEN DO     /* @A7 */\n     PARSE VAR CMD MSG1 60 MSG2 121 MSG3                      /* @A7 */\n     MSG4 = \"Return code = \"cmd_rc                            /* @A7 */\n     \"ADDPOP ROW(6) COLUMN(4)\"                                /* @A7 */\n     \"DISPLAY PANEL(\"PANELM2\")\"                               /* @A7 */\n     \"REMPOP\"                                                 /* @A7 */\n  END                                                         /* @A7 */\n  IF (SETMSHOW = \"BOTH\") | (SETMSHOW = \"LOG\") THEN DO         /* @A7 */\n     zerrsm = \"RACFADM \"REXXPGM\" RC=\"cmd_rc                   /* @A7 */\n     zerrlm = cmd                                             /* @A7 */\n     'log msg(isrz003)'                                       /* @A7 */\n  END                                                         /* @A7 */\nRETURN                                                        /* @A7 */\n/*--------------------------------------------------------------------*/\n/*  Generalized routine to browse or view the results of the command  */\n/*--------------------------------------------------------------------*/\nVIEW_STD:\n  stdopt = 'B'\n  'Control Display Save'\n  /* --------------------------------------- *\n  | Get lrecl to determine dcb for temp d/s |\n  * --------------------------------------- */\n  vlrecl = 80\n  do li  = 1 to so.0\n     so.li = strip(so.li)\n     if (length(so.li) > vlrecl) then vlrecl = length(so.li)\n     if (so.li = null) then so.li = ' '\n  end\n  sec = so.0\n  if (vlrecl < 81) then vlrecl = 80\n  else vlrecl = vlrecl + 4\n  if (vlrecl = 80) then vrecfm = 'f b'\n  else vrecfm = 'v b'\n\n  /* ------------------------------------------ *\n  | Allocate a temporary data set for our data |\n  * ------------------------------------------ */\nAddress TSO\n  'Alloc f('ddname') new reuse spa(5,5) tr' ,                 /* @A4 */\n        'recfm('vrecfm') lrecl('vlrecl') blksize(0)'\n  stdopt = null\n  /* ----------------------- *\n  | Write out the stem data |\n  * ----------------------- */\n  if (stdopt = null) then do\n     'Execio * diskw' ddname '(finis stem so.'                /* @A4 */\n     drop so.\n  end\n\n  /* -------------------------------------------------- *\n  | Access the Temporary Data Set using ISPF           |\n  | Library Services.                                  |\n  | Then using ISPF Browse service to browse the data. |\n  | And use Library Services to Free the Data Set.     |\n  * -------------------------------------------------- */\nAddress ISPExec\n  if (sec > 0) then do\n     'lminit dataid(ddb) ddname('ddname')'                    /* @A4 */\n     SELECT                                                   /* @A1 */\n        WHEN (SETGDISP = \"VIEW\") THEN                         /* @A1 */\n             \"VIEW DATAID(\"DDB\") MACRO(\"EDITMACR\")\"           /* @A1 */\n        WHEN (SETGDISP = \"EDIT\") THEN                         /* @A1 */\n             \"EDIT DATAID(\"DDB\") MACRO(\"EDITMACR\")\"           /* @A1 */\n        OTHERWISE                                             /* @A1 */\n             \"BROWSE DATAID(\"DDB\")\"                           /* @A1 */\n     END                                                      /* @A1 */\n     'lmfree dataid('ddb')'\n  end\n\n  /* ----------------------------- *\n  | Last Free the z/OS Allocation |\n  * ----------------------------- */\n  Address TSO 'Free f('ddname')'                              /* @A4 */\n  'Control Display Restore'\nRETURN\n/*--------------------------------------------------------------------*/\n/*  Pre-Populate the command table for new user                       */\n/*--------------------------------------------------------------------*/\nPOPULATE:\n  DO J = 1 TO RACFCMDS.0\n     racfcmde = RACFCMDS.J\n     'tbadd 'table                                            /* @A5 */\n  END\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RACFDB": {"ttr": 913, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01c\\x00)\\x01\\x034/\\x01 \\x18\\x1f\\x16\\x11\\x01\\xf4\\x01\\x83\\x00\\x00\\xd9\\xc1\\xc3\\xc6\\xc1\\xc4\\xd4@@@'", "ispf": {"version": "01.99", "flags": 0, "createdate": "2003-12-08T00:00:00", "modifydate": "2020-06-29T16:11:29", "lines": 500, "newlines": 387, "modlines": 0, "user": "RACFADM"}, "text": "/*%NOCOMMENT====================* REXX *==============================*/\n/*  PURPOSE:  RACFADM - Database Information - Menu option 7 or 8     */\n/*--------------------------------------------------------------------*/\n/* FLG  YYMMDD  USERID   DESCRIPTION                                  */\n/* ---  ------  -------  -------------------------------------------- */\n/* @AJ  200629  RACFA    If no RACF bkup dsn, then display N/A        */\n/* @AI  200629  RACFA    Fixed FMID                                   */\n/* @AH  200616  RACFA    Chg panel name RACFRPTS to RACFDISP          */\n/* @AG  200517  RACFA    Standardize environment (ADDRESS ISPEXEC)    */\n/* @AF  200516  RACFA    Fix display error messages                   */\n/* @AE  200506  RACFA    Display headers in a different color         */\n/* @AD  200501  RACFA    A tweak to the text displayed                */\n/* @AC  200424  RACFA    Move DDNAME at top, standardize/del dups     */\n/* @AB  200423  RACFA    Move PARSE REXXPGM name up above IF SETMTRAC */\n/* @AA  200423  RACFA    Chg dash line to 72, was 62 columns in length*/\n/* @A9  200423  RACFA    Ensure REXX program name is 8 chars long     */\n/* @A8  200413  RACFA    Chg TRACEing to only display banner (P=Pgms) */\n/* @A7  200412  RACFA    Chg SAY to ISPF message                      */\n/* @A6  200412  RACFA    Chg TRACE to allow 'L'abels or 'R'esults     */\n/* @A5  200402  RACFA    Allow tracing, 'REXX trace = Y' in Settings  */\n/* @A4  200401  RACFA    Chged edit macro RACFLOGE to RACFEMAC        */\n/* @A3  200401  RACFA    VIEW/EDIT use edit macro, to turn off HILITE */\n/* @A2  200326  RACFA    Chg temp file to LRECL=80, was 132           */\n/* @A1  200326  RACFA    Chg SAYs to QUEUE, alloc, browse, free file  */\n/* @A0  200326  LBD      Obtained REXX                                */\n/*====================================================================*/\n/*REXX*BUFFERS********************************************************/\n/*                                                                   */\n/*  DISPLAY RACF DSNAMES AND NUMERIOUS OTHER GOODIES                 */\n/*                                                                   */\n/*  AUTHORS:                                                         */\n/*           THERE IS A VARITY OF AUTHORS INVOLVED WITH THIS CODE    */\n/*             AND I LIKE GIVING CREDIT WHERE CREDIT IS DUE. WALT    */\n/*             FARRELL STARTED THIS CODE BY DISPLAYING ALL DSNT DSN  */\n/*             ENTRIES AND BUFFER SIZES. OTHER AUTHORS ARE G. FOGG   */\n/*             (THAT'S ME WRITTING THESE COMMENTS)                   */\n/*             AND I TOOK SOME EXISTING REXX CODE I HAD WRITTEN      */\n/*             A LONG TIME AGO THEN MODIFIED AND INTEGRATED IT INTO  */\n/*             WALT'S STUFF. I BORROWED REXX STATEMENTS FROM ZELDON'S*/\n/*             REXX EXEC \"IPLINFO\" THAT DISPLAYS THE SMF ID, THE     */\n/*             OPERATING SYSTEM RELEASE AND RACF'S FMID LEVEL.       */\n/*                                                                   */\n/*  DISCLAIMERS:                                                     */\n/*           (1) USE AT YOUR OWN RISK--EVEN THOUGH THIS CODE DOES    */\n/*                 NOT MODIFY STORAGE OR RACF DATABASE INFORMATION.  */\n/*                 SO AGAIN, USE AT YOUR OWN RISK.                   */\n/*           (2) DON'T EVEN THINK THAT SOMEHOW, THE AUTHORS ARE EVEN */\n/*                 LIBEL FOR THIS CODE.                              */\n/*           (3) IT'S FREE CODE SO NO WHINING ALLOWED. SUGGESTIONS   */\n/*                 FOR IMPROVEMENT OR ANY BUGS FOUND IS ACCEPTABLE   */\n/*                 VIA EMAIL TO: GFOGG@NWLINK.COM                    */\n/*  GENERAL DESCRIPTION:                                             */\n/*             THIS EXEC RETRIEVES DATA FROM THE DSDT INSTORAGE      */\n/*               BLOCK, MAPPED BY THE ICHPDSDT MACRO AND \"ALL\"       */\n/*               FIELDS ARE MARKED AS \"NOT A PROGRAMMING INTERFACE\"  */\n/*               WHICH MEANS AT IBM'S DESCRETION, THESE FIELDS MAY   */\n/*               CHANGE WITHOUT NOTICE. HOWEVER, I HAVE NEVER SEEN   */\n/*               THIS HAPPEN; THEY JUST ADD NEW FIELDS ONCE IN       */\n/*               WHILE  OR ADD NEW FIELDS IN THE OCO EXTENSION       */\n/*               CONTROL BLOCK THAT IS NOT PUBLISHED.                */\n/*             THIS EXEC ALSO READS EACH RACF DATABASE DEFINED       */\n/*               IN THE DSDT TO GET BAM ADDRESSES IN THE ICB BLOCK   */\n/*               AND READS EACH BAM BLOCK TO CACULATE THE AMOUNT     */\n/*               OF SPACE USED. THE MORE BAM BLOCKS THE MORE TIME    */\n/*               IT TAKES THIS EXEC TO PROCESS SO YOU MAY SEE        */\n/*               SOME TIME DELAY IN DISPLAYING THE INFORMATION.      */\n/*               REMEMBER--REXX I/O IS VERY SLOW. ADDITIONALLY I     */\n/*               DON'T SERIALIZE THE RACF DB WITH SYSZRACF SO NO     */\n/*               I/O DELAYS ARE AFFECTED BY THIS EXEC.               */\n/*                                                                   */\n/*  USAGE:  SAVE THIS REXX EXEC IN SOME REXX LIBRARY AND GIVE IT A   */\n/*            NAME. I USE THE NAME \"RACFDB\". I ALSO HAVE MY REXX     */\n/*            LIBRARY CONCATIONATED TO DD(SYSEXEC) AS PART OF THE    */\n/*            LOGON LIBRARIES SO I CAN JUST ENTER THE COMMAND IN     */\n/*            ANY PDF PANEL LINE. EXAMPLE:  \"COMMAND===>TSO RACFDB\"  */\n/*                                                                   */\n/*  OUTPUT FROM THE COMMAND:                                         */\n/*                                                                   */\n/* -------------------START OF COMMAND OUTPUT------------------------*/\n/* (1) SMF NAME=XOST Z/OS 01.04.00 SECURITY SERVER RACF FMID=HRF7707 */\n/*                                                                   */\n/* (2) PRIMARY #1: STATUS =ACTIVE                                    */\n/*   DSNAME = SYS1.RACF.PRIM                           VOL =XXRACF   */\n/*   # BUFFERS = 255                                                 */\n/*   PERCENT SPACE USED = %45.82 OF CYLINDER(130)                    */\n/*                                                                   */\n/* BACKUP  #1: STATUS=ACTIVE                                         */\n/*   DSNAME = SYS1.RACF.BKUP                           VOL=ZZRACF    */\n/*   # BUFFERS = 51                                                  */\n/*   PERCENT SPACE USED = %45.82 OF CYLINDER(130)                    */\n/*                                                                   */\n/* (3) IRRMIN00 VERSION/RELEASE/MODIFICATION = 7707                  */\n/* (4) RACF DATABASE TEMPLATE RMID LEVEL =     HRF7707               */\n/* (5) SYSPLEX COMMUNICATIONS ENABLED AND                            */\n/* (6) IN DATASHARING MODE                                           */\n/* ---------------------END OF COMMAND OUTPUT------------------------*/\n/*                                                                   */\n/*  NOTES:                                                           */\n/*  (1) DISPLAYS THE SMF ID AS DEFINED IN THE PARMLIB MEMBER         */\n/*        SMFPRMXX USING THE SID(NAME) STATEMENT.                    */\n/*      DISPLAYS THE OS NAME AS EITHER OS/390 OR Z/OS.               */\n/*      DISPLAYS THE VERSION/RELEASE/MODIFICATION OF THE OS.         */\n/*      DISPLAYS THE SECURITY SERVER RACF FMID. THE RACF FMID        */\n/*      MAY OR MAY NOT CHANGE BETWEEN OS RELEASES. FOR EXAMPLE,      */\n/*      RACF FMID HRF7703 WAS THE SAME FOR OS/390 V2R10 AND          */\n/*      Z/OS V1R1.                                                   */\n/*                                                                   */\n/*  (2) DISPLAYS THE RACF DATABASE AS THE PRIMARY OR BACKUP AND      */\n/*        IF THE DATABASE IS ACTIVE OR INACTIVE. ALSO SHOWN IS THE   */\n/*        SEQUENCE NUMBER OF THE DATABASE AS DEFINED IN ICHRDSNT.    */\n/*      DISPLAYS THE RACF DATABASE NAME AND VOLSER OF WHERE THE      */\n/*        DATABASE IS CATALOGED.                                     */\n/*      DISPLAYS THE NUMBER OF RESIDENT DATA BLOCKS DEFINED IN THE   */\n/*        ICHRDSNT TABLE FOR THE RACF DATABASE.                      */\n/*      DISPLAYS THE PERCENT SPACE USED OF THE SPACE ALLOCATED (BY   */\n/*      AS DEFINED BY RACF BAM (BLOCK AVALIBILITY MASK) BLOCKS AND   */\n/*        SHOWS HOW THE DATABASE WAS ALLOCATED BY EITHER BLOCKS,     */\n/*        TRACKS OR CYLINDERS.                                       */\n/*                                                                   */\n/*  (3) DISPLAYS THE VERSION OF IRRMIN00 THAT LAST PROCESSED THE     */\n/*        RACF DATABASE. FOR EXAMPLE, YOUR SYSTEM IS IPL'ED ON       */\n/*        Z/OS V1R2 WITH RACF FMID HRF7705. IF YOU USED A COPY OF    */\n/*        Z/OS V1R4 IRRMIN00 TO UPDATE THE TEMPLATES PRIOR TO        */\n/*        IPLING ON V1R4 THEN THE IRRMIN00 VERSION DISPLAYED ON      */\n/*        THIS LINE SHOULD BE 7707.                                  */\n/*                                                                   */\n/*  (4) DISPLAYS THE RMID OR TEMPLATE LEVEL. RMID IS ALSO KNOWN      */\n/*        AS THE SYSMOD ID (A SMPE TERM). THIS COULD BE THE FMID     */\n/*        OF RACF OR AN APAR VALUE. THIS FIELD WILL HAVE RACF'S      */\n/*        FMID MOST OF THE TIME BUT IF AN APAR OR A SPE REQUIRES THE */\n/*        TEMPLATES UPDATED THEN YOU WILL SEE THE APAR VALUE INSTEAD */\n/*        OF RACF'S FMID VALUE.                                      */\n/*                                                                   */\n/*  (5) TELLS YOU IF SYSPLEX COMMAND COMMUNICATION IS ENABLED OR     */\n/*        NOT AS SPECIFIED IN THE ICHRDSNT FLAG BYTE.                */\n/*                                                                   */\n/*  (6) DISPLAYS DATASHARE MODE AS SPECIFIED IN THE ICHRDSNT TABLE   */\n/*        OR MODIFIED BY THE \"RVARY DATASHARE/NODATASHARE\" COMMAND.  */\n/*        POSSIBE MESSAGES DISPLAYED:                                */\n/*         IN NON-DATASHARING MODE                                   */\n/*         IN DATASHARE MODE                                         */\n/*         IN READ-ONLY MODE                                         */\n/*         IN TRANSTITION MODE. EITHER BE READ ONLY OR DATASHARE     */\n/*                                                                   */\n/*      NOTE: THIS EXEC SHOWS XCF, DATASHARING STATUS, AND IF THE    */\n/*              THE DATABASE(S) ARE ACTIVE OR NOT BUT I ALSO         */\n/*              SUGGEST TO USE THE IBM SUPPORTED METHOD BY USING     */\n/*              THE \"RVARY LIST\" COMMAND TO GET THIS TYPE OF         */\n/*              INFORMATION.                                         */\n/*                                                                   */\n/*  ENVIRONMENT:                                                     */\n/*           THIS CODE HAS BEEN TESTED ON OS/390 V2R10 AND           */\n/*           Z/OS V1R4 ON SINGLE AND SPLIT DATABASES.                */\n/*                                                                   */\n/*********************************************************************/\nPANEL01     = \"RACFDISP\"   /* Display report with colors   */ /* @AH */\nEDITMACR    = \"RACFEMAC\"   /* Edit Macro, turn HILITE off  */ /* @A4 */\nDDNAME      = 'RACFA'RANDOM(0,999) /* Unique ddname        */ /* @AC */\nparse source . . REXXPGM .                                    /* @AB */\nREXXPGM     = LEFT(REXXPGM,8)      /* Obtain REXX pgm name */ /* @AB */\n\nADDRESS ISPEXEC                                               /* @AG */\n  \"VGET (SETGDISP SETMTRAC)\"                                  /* @A5 */\n  If (SETMTRAC <> 'NO') then do                               /* @A6 */\n     Say \"*\"COPIES(\"-\",70)\"*\"                                 /* @A6 */\n     Say \"*\"Center(\"Begin Program = \"REXXPGM,70)\"*\"           /* @A6 */\n     Say \"*\"COPIES(\"-\",70)\"*\"                                 /* @A6 */\n     if (SETMTRAC <> 'PROGRAMS') THEN                         /* @A8 */\n        interpret \"Trace \"SUBSTR(SETMTRAC,1,1)                /* @A6 */\n  end                                                         /* @A6 */\n\n  racflmsg = \"Retrieving data - Please be patient\"            /* @A1 */\n  ADDRESS ISPEXEC \"control display lock\"                      /* @AG */\n  ADDRESS ISPEXEC \"display msg(RACF011)\"                      /* @AG */\n  NUMERIC DIGITS 10     /* DEFINE DIGIT SIZE FOR 31 BIT ADDRESSING   */\n  RACFVRMN = ''\n  LINE     = ''\n  CVT      = C2X( STORAGE(10,4) )      /* POINTER TO CVT             */\n  RCVT     = D2X(X2D(CVT) +X2D(3E0))   /* POINTER TO RCVT POINTER    */\n  RCVT     = C2X(STORAGE(RCVT,4))      /* POINTER TO RCVT            */\n  /* SAY \"RCVT ACRONYM: \"STORAGE(RCVT,4) */\n  DSDT     = D2X(X2D(RCVT) + X2D(E0) ) /* POINTER TO DSDT POINTER    */\n  DSDT     = C2X(STORAGE(DSDT,4))      /* POINTER TO DSDT            */\n  /* SAY \"DSDT ACRONYM: \"STORAGE(DSDT,4) */\n  DSDTNUM  = D2X(X2D(DSDT) + X2D(4))   /* ADDRESS OF DSDTNUM         */\n  DSDTNUM  = C2D(STORAGE(DSDTNUM,4))   /* DSDTNUM                    */\n  DSDTPRIM = D2X(X2D(DSDT) + X2D(90))  /* ADDRESS OF FIRST PRIM DS   */\n  DSDTBACK = D2X(X2D(DSDT) + X2D(140)) /* ADDRESS OF FIRST BKUP DS   */\n  DSDTDSRQ = D2X(X2D(DSDT) + X2D(88))  /* DATASHARE FLAG ONE         */\n  DSDTDSRQ = STORAGE(DSDTDSRQ,1)       /* GET CMD COMMUNICATIONS FLG */\n  IF (BITAND(DSDTDSRQ,'80'X) = '80'X) THEN\n     SYSCOM = \"Sysplex communications ENABLED and\"            /* @A1 */\n  ELSE                                                        /* @A1 */\n     SYSCOM = \"Sysplex communications DISABLED and\"           /* @A1 */\n  DSDTDSMO = D2X(X2D(DSDT) + X2D(89))  /* DATASHARE FLAG TWO         */\n  DSDTDSMO = C2D(STORAGE(DSDTDSMO,1))  /* GET DATASHARE STATUS FLAG  */\n  SELECT\n     WHEN (DSDTDSMO = 0) THEN\n          SYSDS = \"in NON-DATA SHARING mode\"                  /* @A1 */\n     WHEN (DSDTDSMO = 1) THEN\n          SYSDS = \"in DATASHARE mode\"                         /* @A1 */\n     WHEN (DSDTDSMO = 2) THEN\n          SYSDS = \"in READ only mode\"                         /* @A1 */\n     WHEN (DSDTDSMO = 3) THEN\n          SYSDS = \"in TRANSITION mode.\",                      /* @A1 */\n                = \"Either be READ ONLY or DATASHARE\"          /* @A1 */\n     OTHERWISE\n          SYSDS = \"WARNING: Unknown DSDTDSMO code==>\" DSDTDSMO/* @A1 */\n  END  /*-- END OF SELECT SEQUENCE --*/\n\n  CALL SSVRM                         /*DISPLAY OS AND RACF FMID DATA */\n  DO II = 1 TO DSDTNUM                 /* LOOP THROUGH ENTRIES       */\n     PNAME = D2X(X2D(DSDTPRIM) + X2D(21))  /* ADDR OF NAME           */\n     PNAME = STORAGE(PNAME,44)             /* NAME                   */\n     PNUM  = D2X(X2D(DSDTPRIM) + X2D(20))  /* ADDR OF BUFFER COUNT   */\n     PNUM  = C2D(STORAGE(PNUM,1))          /* BUFFER COUNT           */\n     PSTAT = D2X(X2D(DSDTPRIM) + X2D(1D))  /* ADDR OF DSDPSTAT       */\n     PSTAT = STORAGE(PSTAT,1)              /* PRIMARY STATUS BYTE    */\n     IF (BITAND(PSTAT,'80'X) = '80'X) THEN\n        PSTAT = \"ACTIVE\"\n     ELSE\n        PSTAT = \"INACTIVE\"\n     BNAME = D2X(X2D(DSDTBACK) + X2D(21))  /* ADDR OF NAME           */\n     BNAME = STORAGE(BNAME,44)             /* NAME                   */\n     if pos(left(bname,1),'ABCDEFGHIJKLMNOPQRSTUVWXYZ@#$') = 0\n        then bname = ''                                       /* @AJ */\n     if (bname = \"\") THEN                                     /* @AJ */\n         bname = \"N/A\"                                        /* @AJ */\n     BNUM  = D2X(X2D(DSDTBACK) + X2D(20))  /* ADDR OF BUFFER COUNT   */\n     BNUM  = C2D(STORAGE(BNUM,1))          /* BUFFER COUNT           */\n     BSTAT = D2X(X2D(DSDTBACK) + X2D(1D))  /* ADDR OF DSDTSTAT       */\n     BSTAT = STORAGE(BSTAT,1)              /* BACKUP  STATUS BYTE    */\n     IF (BITAND(BSTAT,'80'X) = '80'X) THEN\n        BSTAT = \"ACTIVE\"\n     ELSE\n        BSTAT = \"INACTIVE\"\n     QUEUE COPIES(\"-\",72)                                     /* @AA */\n     QSNAME = \"'\"STRIP(PNAME)\"'\"         /*PUT QUOTES AROUND RDB NAME*/\n     CALL FINDSIZE QSNAME                /* GET THE SPACE USED VALUE */\n     QUEUE \"PRIMARY #\"II                                      /* @AD */\n     QUEUE \"  Status ......... \"PSTAT                         /* @A1 */\n     QUEUE \"  Dsname ......... \"PNAME                         /* @A1 */\n     QUEUE \"  Volume ......... \"VOLSER                        /* @A1 */\n     QUEUE \"  # Buffers ...... \"PNUM                          /* @A1 */\n     QUEUE \"  % Space used ...\",                              /* @A1 */\n           \"%\"TRUNC(((USED_SEGS / SEG_COUNT) * 100),2) \"OF\",\n           SPACEUNIT\"(\"SPACEALLOC\")\"\n     QUEUE \" \"                                                /* @A1 */\n     QSNAME = \"'\"STRIP(BNAME)\"'\"         /*PUT QUOTES AROUND RDB NAME*/\n     CALL FINDSIZE QSNAME                /* GET THE SPACE USED VALUE */\n     QUEUE \"BACKUP  #\"II                                      /* @AD */\n     QUEUE \"  Status ......... \"BSTAT                         /* @A1 */\n     QUEUE \"  Dsname ......... \"BNAME                         /* @A1 */\n     QUEUE \"  Volume ......... \"VOLSER                        /* @A1 */\n     QUEUE \"  # Buffers ...... \"BNUM                          /* @A1 */\n     QUEUE \"  % Space used ...\",                              /* @A1 */\n           \"%\"TRUNC(((USED_SEGS / SEG_COUNT) * 100),2) \"OF\",\n           SPACEUNIT\"(\"SPACEALLOC\")\"\n\n     DSDTPRIM = D2X(X2D(DSDTPRIM) + 352) /* BUMP TO NEXT SLOT        */\n     DSDTBACK = D2X(X2D(DSDTBACK) + 352) /* BUMP TO NEXT SLOT        */\n  END                                    /* END OF II DO LOOP        */\n\n  CVDX  = D2X(X2D(RCVT) + X2D(258) )   /* ADDR OF RCDX POINTER       */\n  CVDX  = C2X(STORAGE(CVDX,4))         /* POINTER TO CVDX            */\n  PVERA = D2X(X2D(CVDX) + X2D(1DC))    /* ADDRESS OF TMPLATE VERSION */\n  DPVER = STORAGE(PVERA,7)             /* DYNAMIC PARSE VERSION      */\n\n  QUEUE COPIES('-',72)                                        /* @AA */\n  QUEUE \"IRRMIN00 version/release/modification ... \"RACFVRMN  /* @A1 */\n  QUEUE \"RACF database template RMID level ....... \"RACFTEMP  /* @A1 */\n  QUEUE \"Dynamic parse version ................... \"DPVER\n                                                              /* @A1 */\n  /* IF ICBTMPRL /= '0000000000000000'X THEN DO             *//* @A1 */\n  /*     QUEUE \"Template release/APAR level .............\", *//* @A1 */\n  /*           ICBTMPRL33\".\"33ICBTMPAL                      *//* @A1 */\n  /* END                                                    *//* @A1 */\n  QUEUE SYSCOM SYSDS                                          /* @A1 */\n  QUEUE                                                       /* @A1 */\n                                                              /* @A1 */\n  ADDRESS TSO \"ALLOC F(\"DDNAME\") NEW REUSE\",                  /* @AG */\n              \"LRECL(80) BLKSIZE(0) RECFM(F B)\",              /* @A2 */\n              \"UNIT(VIO) SPACE(1 5) CYLINDERS\"                /* @A1 */\n  ADDRESS TSO \"EXECIO * DISKW \"DDNAME\" (FINIS\"                /* @AG */\n\n  \"LMINIT DATAID(CMDDATID) DDNAME(\"DDNAME\")\"                  /* @AG */\n  SELECT                                                      /* @A1 */\n     WHEN (SETGDISP = \"VIEW\") THEN                            /* @A1 */\n          \"VIEW DATAID(\"CMDDATID\")\",                          /* @AG */\n                       \"MACRO(\"EDITMACR\")\",                   /* @AE */\n                       \"PANEL(\"PANEL01\")\"                     /* @AE */\n     WHEN (SETGDISP = \"EDIT\") THEN                            /* @A1 */\n          \"EDIT DATAID(\"CMDDATID\")\",                          /* @AG */\n                       \"MACRO(\"EDITMACR\")\",                   /* @AE */\n                       \"PANEL(\"PANEL01\")\"                     /* @AE */\n     OTHERWISE                                                /* @A1 */\n          \"BROWSE DATAID(\"CMDDATID\")\"                         /* @AG */\n  END                                                         /* @A1 */\n\n  ADDRESS TSO \"FREE FI(\"DDNAME\")\"                             /* @AG */\n\n  call Goodbye                                                /* @A6 */\nEXIT\n/*--------------------------------------------------------------------*/\n/*  If tracing is on, display flower box                         @A6  */\n/*--------------------------------------------------------------------*/\nGOODBYE:                                                      /* @A6 */\n  If (SETMTRAC <> 'NO') then do                               /* @A6 */\n     Say \"*\"COPIES(\"-\",70)\"*\"                                 /* @A6 */\n     Say \"*\"Center(\"End Program = \"REXXPGM,70)\"*\"             /* @A6 */\n     Say \"*\"COPIES(\"-\",70)\"*\"                                 /* @A6 */\n  end                                                         /* @A6 */\nEXIT                                                          /* @A6 */\n/*--------------------------------+----------------------------------*/\n/*                           SUBROUTE AREA                           */\n/*--------------------------------+----------------------------------*/\nFINDSIZE:\n  ARG RDSN                      /* GET RACF DATASET NAME             */\n  FREE_SEGS = 0                 /* TOTAL NUMBER FREE SEGMENTS        */\n  USED_SEGS = 0                 /* TOTAL NUMBER ALLOCATED SEGMENTS   */\n  CALL $RDSN_SETUP              /* OPEN RACF DSN AND READ ICB BLOCK  */\n  BAM_COUNTER = 0               /* COUNT NUMBER OF BAMS PROCESSED    */\n\n  DO FOREVER\n     BAM_COUNTER = BAM_COUNTER + 1\n     /*SAY \"PROCESSING BAM BLOCK \" BAM_COUNTER \"OF\" C2D(BAM_BCNT)*/\n\n     X = $GBLK(BAM_ADDR,BSIZE)   /* READ IN A BAM BLOCK              */\n     PARSE VAR BLK.1   ,         /* PARSE BAM HEADER AND MASK BITS   */\n           PREV_BAM_BLOCK +6,    /* PREVIOUS OR IF ZERO THE 1st BAM  */\n           NEXT_BAM_BLOCK +6,    /* NEXT BAM BLOCK ADDRESS           */\n           RBA1_BAM_BLOCK +6,    /* RBA OF 1ST. BLOCK BAM DEFINES    */\n           BLK_CNT +2,           /* NO. OF BLOCKS THIS BAM DEFINES   */\n           BAM_DATA              /* BAM MASK BIT (1 BIT = 1 SEGMENT) */\n\n     BLKC = C2D(BLK_CNT)                   /* EACH SEGMENT=256 BYTES */\n     X = $GET_BAM_COUNT(BAM_DATA,BLKC)     /* GET ALLOC. DATA IN BAM */\n     IF (C2D(NEXT_BAM_BLOCK) = 0) THEN     /* NO MORE BAMS?          */\n        LEAVE\n     ELSE\n        BAM_ADDR = NEXT_BAM_BLOCK          /* Yes CONTINUE           */\n  END                                      /*     END OF DO FOREVER  */\n\n  /* SAY \"FREE SEGMENTS =>    \" FREE_SEGS */\n  /* SAY \"USED SEGMENTS =>    \" USED_SEGS */\n  /* SAY \"TOTAL SEGMENTS=>    \" SEG_COUNT */\n  ADDRESS TSO \"EXECIO 1 DISKR SYSRACF 1 (STEM ICB. FINIS\"     /* @AG */\n  ADDRESS TSO \"FREE F(SYSRACF)\"                               /* @AG */\nRETURN\n/*---------------------------RDSN_SETUP-------------------------------*/\n/* THIS FUNCTION WILL QUERRY THE USER FOR A RACF DATABASE NAME AND    */\n/* ISSUE THE \"ALLOC\" COMMAND. THE FIRST RECORD (ICB) IS READ FROM THE */\n/* RACF DATABASE TO OBTAIN BAM POINTER DATA.                          */\n/* THIS FUNCTION WILL ONLY DO ELEMENTRY CHECKING TO SEE IF THE RACF   */\n/* DATABASE NAME IS LEGIT. IT ONLY CHECKS IF THE DATA SET NAME ENTERED*/\n/* IS CATALOGED AND IF THE BLOCK SIZE IS 4096. ANY OTHER ISSUES LIKE  */\n/* THE WRONG DSORG OR RECFM ARE NOT CHECKED AND EXPECT ERRORS TO      */\n/* HAPPEN DURING EXECIO PROCESSING.                                   */\n/*--------------------------------------------------------------------*/\n$RDSN_SETUP:\n  /*--------------------------------------------------------*/\n  /* CALL LISTDSI TO TEST IF THE RACF DATASET IS CATALOGED. */\n  /*--------------------------------------------------------*/\n  FRC = LISTDSI(RDSN)\n  IF (FRC /= 0) THEN DO\n     racfsmsg = ''                                            /* @A7 */\n     racflmsg = 'Invalid or unknown RACF',                    /* @A7 */\n                'database name: 'RDSN'. ',                    /* @A7 */\n                'Dataset must be cataloged,',                 /* @A7 */\n                'restructured RACF database.'                 /* @A7 */\n     \"SETMSG MSG(RACF011)\"                                    /* @AG */\n     call Goodbye                                             /* @A6 */\n  END\n  BSIZE      = SYSBLKSIZE\n  VOLSER     = SYSVOLUME\n  SPACEUNIT  = SYSUNITS\n  SPACEALLOC = SYSALLOC\n  /*----------------------------------------*/\n  /* TEST TO SEE IF THE BLOCK SIZE IS 4096. */\n  /*----------------------------------------*/\n  IF (BSIZE /= 4096) THEN DO\n     racfsmsg = ''                                            /* @A7 */\n     racflmsg = \"RACF database entered does not have a\",      /* @A7 */\n                \"restructured 4096 block size.\"               /* @A7 */\n     \"SETMSG MSG(RACF011)\"                                    /* @AG */\n     call Goodbye                                             /* @A6 */\n  END\n  /*---------------------------------------------------*/\n  /* ALLOCATE AND READ IN THE ICB TO GET BAM POINTERS. */\n  /*---------------------------------------------------*/\n  ADDRESS TSO \"ALLOC F(SYSRACF) REUSE DA(\"RDSN\")\",            /* @AG */\n              \"SHR LRECL(\"BSIZE\")\"                            /* @AG */\n  ADDRESS TSO \"EXECIO 1 DISKR SYSRACF 1 (STEM ICB. \"          /* @AG */\n\n  BAM_BCNT = SUBSTR(ICB.1,05,4)       /* NUMBER OF BAM BLKS DEFINED  */\n  BAM_ADDR = SUBSTR(ICB.1,21,6)       /* RBA OF 1st BAM BLK IN CHAIN */\n  IF (RACFVRMN = '') THEN DO\n     RACFVRMN = SUBSTR(ICB.1,1019,6)  /* TEMPLATE VERSION/RELEASE/MOD*/\n     RACFTEMP = SUBSTR(ICB.1,1057,7)  /* TEMPLATE LEVEL VALUE        */\n     ICBTMPRL = SUBSTR(ICB.1,519,8)   /* TEMPLATE RELEASE LEVEL      */\n     ICBTMPAL = SUBSTR(ICB.1,527,8)   /* TEMPLATE APAR    LEVEL      */\n  END\nRETURN\n/*---------------------------$GBLK------------------------------------*/\n/* THIS FUNCTION WILL READ ONE RACF DATABASE RECORD. INPUT TO THIS    */\n/* ROUTINE IS THE RBA ADDRESS OF THE BLOCK TO BE READ AND THE BLKSIZE */\n/* WHICH IS USED TO CACULATE THE RECORD NUMBER NEEDED IN THE EXECIO.  */\n/* RECORD NUMBER =  (RBA / BLKSIZE) + 1                               */\n/* FUNCTION:  $GBLK    -GET A RACF BLOCK FROM THE DATABASE            */\n/* ARGUMENT 1 = RBA ADDRESS IN CHARACTER FORMAT                       */\n/* ARGUMENT 2 = BLOCK SIZE OF THE RACF DATABASE BLOCKS IN DECIMAL     */\n/*--------------------------------------------------------------------*/\n$GBLK:\n  PARSE ARG AD1, AD2\n  IF (AD1 = 0) THEN\n     REC_ADDR = 1\n  ELSE\n     REC_ADDR = TRUNC(((C2D(AD1) / AD2) + 1))\n  ADDRESS TSO \"EXECIO 1 DISKR SYSRACF \"REC_ADDR\" (STEM BLK. \" /* @AG */\n  RRC = RC\nRETURN RRC\n/*------------------------$GET_BAM_COUNT------------------------------*/\n/* THIS FUNCTION WILL COUNT THE NUMBER OF BAM BITS SET ON OR OFF      */\n/* IN A GIVEN BAM BLOCK.                                              */\n/* FUNCTION:  $GET_BAM_COUNT ARG1 ARG2                                */\n/* ARGUMENT 1 = BAM MASK BITS (EACH BIT = 1 SEGMENT)                  */\n/* ARGUMENT 2 = NUMBER OF BLOCKS THIS BAM BLOCK DEFINES               */\n/* RESULTS FROM ROUTINE:                                              */\n/* FREE_SEGS = TOTAL NUMBER OF FREE SEGMENTS DEFINED IN THIS BAM BLK  */\n/* USED_SEGS = TOTAL NUMBER OF USED SEGMENTS DEFINED IN THIS BAM BLK  */\n/* SEG_COUNT = SUM OF BOTH ABOVE VALUES (SAME AS NUMBER OF SEGMENTS)  */\n/* NOTE: A FREE SEGMENT = BIT MASK BIT = 1                            */\n/*       A USED SEGMENT = BIT MASK BIT = 0                            */\n/*--------------------------------------------------------------------*/\n$GET_BAM_COUNT:\n  PARSE ARG AD1, AD2\n  AD2 = (2 * AD2)\n  DO I = 1 TO AD2\n    BYTE = SUBSTR(AD1,I,1)\n    IF (BITAND(BYTE,'80'X) = '80'X) THEN\n        FREE_SEGS = 1 + FREE_SEGS\n    ELSE\n        USED_SEGS = 1 + USED_SEGS\n    IF (BITAND(BYTE,'40'X) = '40'X) THEN\n        FREE_SEGS = 1 + FREE_SEGS\n    ELSE\n        USED_SEGS = 1 + USED_SEGS\n    IF (BITAND(BYTE,'20'X) = '20'X) THEN\n        FREE_SEGS = 1 + FREE_SEGS\n    ELSE\n        USED_SEGS = 1 + USED_SEGS\n    IF (BITAND(BYTE,'10'X) = '10'X) THEN\n        FREE_SEGS = 1 + FREE_SEGS\n    ELSE\n        USED_SEGS = 1 + USED_SEGS\n    IF (BITAND(BYTE,'08'X) = '08'X) THEN\n        FREE_SEGS = 1 + FREE_SEGS\n    ELSE\n        USED_SEGS = 1 + USED_SEGS\n    IF (BITAND(BYTE,'04'X) = '04'X) THEN\n        FREE_SEGS = 1 + FREE_SEGS\n    ELSE\n        USED_SEGS = 1 + USED_SEGS\n    IF (BITAND(BYTE,'02'X) = '02'X) THEN\n        FREE_SEGS = 1 + FREE_SEGS\n    ELSE\n        USED_SEGS = 1 + USED_SEGS\n    IF (BITAND(BYTE,'01'X) = '01'X) THEN\n        FREE_SEGS = 1 + FREE_SEGS\n    ELSE\n        USED_SEGS = 1 + USED_SEGS\n  END\n  SEG_COUNT = USED_SEGS + FREE_SEGS\nRETURN SEG_COUNT\n/*--------------------------------------------------------------------*/\n/*  SSVRM                                                             */\n/*--------------------------------------------------------------------*/\nSSVRM:\n  CVT      = C2D(STORAGE(10,4))               /* POINT TO CVT         */\n  SMCA     = STORAGE(D2X(CVT + 196),4)        /* POINT TO  SMCA       */\n  SMCA     = BITAND(SMCA,'7FFFFFFF'X)         /* ZERO HIGH ORDER BIT  */\n  SMCA     = C2D(SMCA)                        /* CONVERT TO DECIMAL   */\n  SMFNAME  = STORAGE(D2X(SMCA + 16),4)        /* POINT TO SMF NAME    */\n  SMFNAME  = STRIP(SMFNAME,T)                 /* DEL TRAILING BLANKS  */\n  ECVT     = C2D(STORAGE(D2X(CVT + 140),4))   /* POINT TO CVTECVT     */\n  CVTRAC   = C2D(STORAGE(D2X(CVT + 992),4))   /* POINT TO RACF CVT    */\n  RACFMID  = \"HRF\"STORAGE(D2X(CVT - 29),4)    /* RACF FMID        @AI */\n  RCVTALIS = STORAGE(D2X(CVTRAC+330),1)       /* GET RCVTALIS BYTE    */\n  PRODNAM  = STORAGE(D2X(ECVT+496),16)        /* POINT TO PRODUCT NAME*/\n  SSNAME   = STRIP(PRODNAM,T)                 /* DEL TRAILING BLANKS  */\n  VER      = STORAGE(D2X(ECVT+512),2)         /* POINT TO VERSION     */\n  REL      = STORAGE(D2X(ECVT+514),2)         /* POINT TO RELEASE     */\n  MOD      = STORAGE(D2X(ECVT+516),2)         /* POINT TO MOD LEVEL   */\n  VRM      = VER'.'REL'.'MOD                  /* VRM OF OS            */\n  QUEUE \"RACF database statistics as of \"DATE() TIME()        /* @AD */\n  QUEUE \"SMF name =\",\n        SMFNAME\"  \"SSNAME VRM\"  RACF FMID = \"RACFMID\n  QUEUE \"The application identity mapping stage is set at\",   /* @AD */\n        STRIP(C2D(RCVTALIS))                                  /* @AD */\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RACFDSL": {"ttr": 915, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x14\\x00Y\\x01 \\x11\\x0f\\x01 \\x16?\\x04\\x02\\x00w\\x00_\\x00\\x00\\xd9\\xc1\\xc3\\xc6\\xc1\\xc4\\xd4@@@'", "ispf": {"version": "01.20", "flags": 0, "createdate": "2020-04-19T00:00:00", "modifydate": "2020-06-11T04:02:59", "lines": 119, "newlines": 95, "modlines": 0, "user": "RACFADM"}, "text": "/*%NOCOMMENT====================* REXX *==============================*/\n/*  PURPOSE:  RACFADM - Dataset List - Menu option D                  */\n/*--------------------------------------------------------------------*/\n/*  NOTES:    1) This utility will obtain the LIBDEF/ALTLIB dataset   */\n/*               names and if the high level qualifiers are identical */\n/*               in all three datasets (panel, message and REXX), it  */\n/*               it will invoke ISPF 3.4 Dataset list, displaying the */\n/*               datasets                                             */\n/*--------------------------------------------------------------------*/\n/* FLG  YYMMDD  USERID   DESCRIPTION                                  */\n/* ---  ------  -------  -------------------------------------------- */\n/* @A5  200504  RACFA    Missing continuation (comma) in long msg     */\n/* @A4  200423  RACFA    Move PARSE REXXPGM name up above IF SETMTRAC */\n/* @A3  200423  RACFA    Ensure REXX program name is 8 chars long     */\n/* @A2  200420  RACFA    Verify last level qualifier is not blank/null*/\n/* @A1  200420  RACFA    Removed single quote of REXX/CLIST dsname    */\n/* @A0  200419  RACFA    Created REXX                                 */\n/*====================================================================*/\nparse source . . REXXPGM .         /* Obtain REXX pgm name */ /* @A4 */\nREXXPGM     = LEFT(REXXPGM,8)                                 /* @A4 */\n\nADDRESS ISPEXEC\n  \"VGET (SETMTRAC) PROFILE\"\n  If (SETMTRAC <> 'NO') then do\n     Say \"*\"COPIES(\"-\",70)\"*\"\n     Say \"*\"Center(\"Begin Program = \"REXXPGM,70)\"*\"\n     Say \"*\"COPIES(\"-\",70)\"*\"\n     if (SETMTRAC <> 'PROGRAMS') THEN\n        interpret \"Trace \"SUBSTR(SETMTRAC,1,1)\n  end\n\n  call Get_clist_dsn\n  \"QLIBDEF ISPPLIB TYPE(DATASET) ID(DSNPAN)\"\n  \"QLIBDEF ISPMLIB TYPE(DATASET) ID(DSNMSG)\"\n\n  DSNREX = STRIP(DSNREX,,\"'\")                                 /* @A1 */\n  DSNPAN = STRIP(DSNPAN,,\"'\")\n  DSNMSG = STRIP(DSNMSG,,\"'\")\n  PARSE VAR DSNREX R1 \".\" R2 \".\" R3 \".\" R4 \".\" R5 \".\" .\n  PARSE VAR DSNPAN P1 \".\" P2 \".\" P3 \".\" P4 \".\" P5 \".\" .\n  PARSE VAR DSNMSG M1 \".\" M2 \".\" M3 \".\" M4 \".\" M4 \".\" .\n\n  SELECT\n     WHEN (R5 <> '') & (R5 = P5) & (R5 = M5) THEN             /* @A2 */\n          DSNAME = R1\".\"R2\".\"R3\".\"R4\".\"R5\n     WHEN (R4 <> '') & (R4 = P4) & (R4 = M4) THEN             /* @A2 */\n          DSNAME = R1\".\"R2\".\"R3\".\"R4\n     WHEN (R3 <> '') & (R3 = P3) & (R3 = M3) THEN             /* @A2 */\n          DSNAME = R1\".\"R2\".\"R3\n     WHEN (R2 <> '') & (R2 = P2) & (R2 = M2) THEN             /* @A2 */\n          DSNAME = R1\".\"R2\n     WHEN (R1 <> '') & (R1 = P1) & (R1 = M1) THEN             /* @A2 */\n          DSNAME = R1\n     OTHERWISE\n          DSNAME = \"\"\n  END\n\n  IF (DSNAME = \"\") THEN DO\n     racfsmsg = \"Error - No DSNs\"\n     racflmsg = \"Unable to determine RACFADM's\",\n                \"LIBDEF/ALTLIB dataset names,\",               /* @A5 */\n                \"due to the HLQ name is different\",\n                \"on the panel, message or REXX\",\n                \"dataset\"\n     \"SETMSG MSG(RACF011)\"\n  END\n  ELSE\n     \"SELECT PGM(ISRDSLST) PARM(DSL '\"DSNAME\"')\",\n             \"SUSPEND SCRNAME(RACFADM)\"\n\n  If (SETMTRAC <> 'NO') then do\n     Say \"*\"COPIES(\"-\",70)\"*\"\n     Say \"*\"Center(\"End Program = \"REXXPGM,70)\"*\"\n     Say \"*\"COPIES(\"-\",70)\"*\"\n  end\nEXIT\n/*--------------------------------------------------------------------*/\n/*  Get CLIST dataset name                                            */\n/*--------------------------------------------------------------------*/\n/*  1) The 'ALTLIB DISPLAY' statement, will look for                  */\n/*     'Application-level' in the display in order to obtain          */\n/*     the DDname of the ALTLIBed dataset                             */\n/*       Current search order (by DDNAME) is:                         */\n/*       Application-level CLIST DDNAME=SYS00529                      */\n/*       System-level EXEC       DDNAME=SYSEXEC                       */\n/*       System-level CLIST      DDNAME=SYSPROC                       */\n/*  2) The 'LISTA STATUS' will display all the DDnames and datasets   */\n/*     allocated, allowing the capability to obtain the dataset name  */\n/*     allocated to the 'Application-level CLIST' ddname (SYS#####)   */\n/*--------------------------------------------------------------------*/\nGET_CLIST_DSN:\n  X = OUTTRAP(\"REC.\")\n  ADDRESS TSO \"ALTLIB DISPLAY\"\n  X = OUTTRAP(\"OFF\")\n\n  IF (SUBSTR(REC.2,1,3) = \"IKJ\") THEN\n     PARSE VAR REC.2 . W1 W2 \"DDNAME=\"DDALTLIB\n  ELSE\n     PARSE VAR REC.2 W1 W2 \"DDNAME=\"DDALTLIB\n  DROP REC.\n  RC = 0\n  IF (W1 <> \"Application-level\") THEN DO\n     RC = 8\n     return\n  END\n\n  X = OUTTRAP(\"REC.\")\n  ADDRESS TSO \"LISTA STATUS\"\n  X = OUTTRAP(\"OFF\")\n  do J = 1 TO REC.0\n     PARSE VAR REC.J W1 .\n     IF (W1 = DDALTLIB) THEN DO\n        K = J - 1\n        DSNREX = REC.K\n        LEAVE\n     END\n  end\n  DROP REC. W1 DDALTLIB\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RACFDSN": {"ttr": 917, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00\\x19\\x01 \\x18\\x8f\\x01 \\x19\\x0f\\x10G\\x04\\xe4\\x04\\xe3\\x00\\x00\\xd9\\xc1\\xc3\\xc6\\xc1\\xc4\\xd4@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2020-07-06T00:00:00", "modifydate": "2020-07-08T10:47:19", "lines": 1252, "newlines": 1251, "modlines": 0, "user": "RACFADM"}, "text": "/*%NOCOMMENT====================* REXX *==============================*/\n/*  PURPOSE:  RACFADM - Dataset Profiles - Menu option 3              */\n/*--------------------------------------------------------------------*/\n/* FLG  YYMMDD  USERID   DESCRIPTION                                  */\n/* ---  ------  -------  -------------------------------------------- */\n/* @CM  200708  TRIDJK   Msg if selection list has no entries ('NONE')*/\n/* @CL  200624  RACFA    Allow passing fully qual. dsn with quotes    */\n/* @CK  200624  RACFA    Chg line cmd L, added datasets               */\n/* @CJ  200618  RACFA    Chged SYSDA to SYSALLDA                      */\n/* @CI  200617  RACFA    Added comments to right of variables         */\n/* @CH  200616  RACFA    Added capability to SAve file as TXT/CSV     */\n/* @CG  200610  RACFA    Added primary command 'SAVE'                 */\n/* @CF  200604  RACFA    Fix, prevent from going to top of table      */\n/* @CE  200527  RACFA    Fix, allow typing 'S' on multiple rows       */\n/* @CD  200520  RACFA    Display line cmd 'P'rofile, when 'Admin=N'   */\n/* @CC  200506  RACFA    Drop array immediately when done using       */\n/* @CB  200504  TRIDJK   Adding, place in order, prior was at bottom  */\n/* @CA  200502  RACFA    Re-worked displaying tables, use DO FOREVER  */\n/* @C9  200501  LBD      Add primary commands FIND/RFIND              */\n/* @C8  200430  RACFA    Chg tblb to TABLEB, moved def. var. up top   */\n/* @C7  200430  RACFA    Chg tbla to TABLEA, moved def. var. up top   */\n/* @C6  200429  RACFA    Re-arranged variables (General, Mgmt, TSO)   */\n/* @C5  200424  RACFA    Fixed displaying error msg for PERMIT cmd    */\n/* @C4  200424  RACFA    Updated RESET, pass filter, ex: R filter     */\n/* @C3  200424  RACFA    Chg msg RACF013 to RACF012                   */\n/* @C2  200424  RACFA    Move DDNAME at top, standardize/del dups     */\n/* @C1  200423  RACFA    Move PARSE REXXPGM name up above IF SETMTRAC */\n/* @BZ  200423  RACFA    'Status Interval' by percentage (SETGSTAP)   */\n/* @BY  200422  RACFA    Ensure the REXX program name is 8 chars      */\n/* @BX  200422  RACFA    Use variable REXXPGM in log msg              */\n/* @BW  200413  RACFA    Chg TRACEing to only display banner (P=Pgms) */\n/* @BV  200412  RACFA    Chg TRACE to allow 'L'abels or 'R'esults     */\n/* @BU  200410  RACFA    Fixed sorting entries prior to displaying    */\n/* @BT  200408  RACFA    Chg 'Dataset = NO' to NONE                   */\n/* @BS  200407  RACFA    EXCMD removed 'else msg_var = 1 to msg.0'    */\n/* @BR  200404  RACFA    'Admin RACF API = Y' then display 'P'rofile  */\n/* @BQ  200402  RACFA    Chg LRECL=132 to LRECL=80                    */\n/* @BP  200401  RACFA    Create subroutine to VIEW/EDIT/BROWSE        */\n/* @BO  200401  RACFA    Chged edit macro RACFLOGE to RACFEMAC        */\n/* @BN  200401  RACFA    VIEW/EDIT use edit macro, to turn off HILITE */\n/* @BM  200330  RACFA    Chg RACFDSN5 point/shoot ascending/descending*/\n/* @BL  200330  RACFA    Allow point-n-shoot sort ascending/descending*/\n/* @BK  200324  RACFA    Allow both display/logging of RACF commands  */\n/* @BJ  200324  RACFA    Allow logging RACF commands to ISPF Log file */\n/* @BI  200316  RACFA    Prevent typing in 'L' line cmd next to '*'   */\n/* @BH  200315  RACFA    Added line cmd 'P=Profile'                   */\n/* @BG  200305  TRIDJK   TBDELETE if cmd_rc = 0 on DELDSD command     */\n/* @BF  200303  RACFA    Chg 'ret_code' to 'cmd_rc' after EXCMD       */\n/* @BE  200303  RACFA    Chg 'RL class ALL' to 'RL class * ALL'       */\n/* @BD  200303  RACFA    Fixed chking RC and removed TBMOD, not needed*/\n/* @BC  200303  RACFA    Chk RC 'LD dsn prms', if RC>0 then 'LD dsn'  */\n/* @BB  200303  RACFA    Removed TBMOD in LISP procedure, not needed  */\n/* @BA  200302  RACFA    Del TBTOP cmd, prior to TBSCAN for LOCATE    */\n/* @B9  200301  RACFA    When grp/ids (RACFUSR5) don't display D-DSN  */\n/* @B8  200301  RACFA    Display msg when id is an asterisk (*)       */\n/* @B7  200301  RACFA    Fixed displaying userids, was ret_code       */\n/* @B6  200301  RACFA    Del EMSG procedure, instead call racfmsgs    */\n/* @B5  200228  RACFA    Check for 'NO ENTRIES MEET SEARCH CRITERIA'  */\n/* @B4  200227  RACFA    Added line command 'D', display user datasets*/\n/* @B3  200226  RACFA    Fix @AZ chg, chg ret_code to cmd_rc          */\n/* @B2  200226  RACFA    Fixed 'L List' cmd, added single quotes      */\n/* @B1  200226  RACFA    Added 'CONTROL ERRORS RETURN'                */\n/* @AZ  200226  RACFA    Added 'Return Code =' when displaying cmd    */\n/* @AY  200226  RACFA    Removed double quotes before/after cmd       */\n/* @AX  200226  RACFA    Del address TSO \"PROFILE PREF(\"USERID()\")\"   */\n/* @AW  200226  RACFA    Removed 'ADDRESS TSO PROF NOPREFIX'          */\n/* @AV  200224  RACFA    Standardize quotes, chg single to double     */\n/* @AU  200224  RACFA    Place panels at top of REXX in variables     */\n/* @AT  200223  RACFA    Fixed SORTed color column                    */\n/* @AS  200223  RACFA    Fixed SORT DATASET                           */\n/* @AR  200223  RACFA    Simplified SORT, removed FLD/DFL_SORT vars   */\n/* @AQ  200222  RACFA    Allowing abbreviating the column in SORT cmd */\n/* @AP  200222  RACFA    Removed translating OPTA/B, not needed       */\n/* @AO  200222  RACFA    Allow placing cursor on row and press ENTER  */\n/* @AN  200222  RACFA    Added primary commands 'SORT'                */\n/* @AM  200221  RACFA    Added primary commands 'LOCATE'              */\n/* @AL  200221  RACFA    Added primary commands 'ONLY' and 'RESET'    */\n/* @AK  200221  RACFA    Removed \"G = '(G)'\", not referenced          */\n/* @AJ  200221  RACFA    Make 'ADDRESS ISPEXEC' defualt, reduce code  */\n/* @AI  200220  RACFA    Fixed displaying all RACF commands           */\n/* @AH  200220  RACFA    Added SETMTRAC=YES, then TRACE R             */\n/* @AG  200220  RACFA    Removed initializing SETGSTA variable        */\n/* @AF  200220  RACFA    Added capability to browse/edit/view file    */\n/* @AE  200218  RACFA    Use dynamic area to display SELECT commands  */\n/* @AD  200218  RACFA    Added 'Status Interval' option               */\n/* @AC  200123  RACFA    Retrieve default filter, Option 0 - Settings */\n/* @AB  200123  TRIDJK   If LG fails, then issue a LU                 */\n/* @AA  200120  TRIDJK   Fixed displaying NOWARNING                   */\n/* @A9  200120  TRIDJK   Chged 'subword(temp,4,1)', was (temp,5,1)    */\n/* @A8  200120  RACFA    Removed 'say msg.msg_var' in EXCMD procedure */\n/* @A7  200119  RACFA    Standardized/reduced lines of code           */\n/* @A6  200119  RACFA    Added comment box above procedures           */\n/* @A5  200118  RACFA    Added line command 'L' to list userid        */\n/* @A4  200118  RACFA    Fixed NOPREF issue with users TSO PROFILE    */\n/* @A3  200117  RACFA    Only 'Refresh Generic Class' if chg was made */\n/* @A2  200117  RACFA    Adjusted DISPLAY code                        */\n/* @A1  200110  RACFA    Added line command 'L' to list dataset       */\n/* @A0  011229  NICORIZ  Created REXX, V2.1, www.rizzuto.it           */\n/*====================================================================*/\nPANEL01     = \"RACFDSN1\"   /* Set filter, menu option 3    */ /* @AU */\nPANEL02     = \"RACFDSN2\"   /* List profiles and types      */ /* @AU */\nPANEL03     = \"RACFDSN3\"   /* Add profile                  */ /* @AU */\nPANEL04     = \"RACFDSN4\"   /* Change profile               */ /* @AU */\nPANEL05     = \"RACFDSN5\"   /* Show groups and access       */ /* @AU */\nPANEL06     = \"RACFDSN6\"   /* Change access                */ /* @AU */\nPANEL07     = \"RACFDSN7\"   /* Add access                   */ /* @AU */\nPANELM1     = \"RACFMSG1\"   /* Confirm Request (pop-up)     */ /* @AU */\nPANELM2     = \"RACFMSG2\"   /* Display RACF command and RC  */ /* @AU */\nPANELS1     = \"RACFSAVE\"   /* Obtain DSName to SAVE        */ /* @CG */\nSKELETON1   = \"RACFDSN2\"   /* Save tablea to dataset       */ /* @CG */\nSKELETON2   = \"RACFDSN5\"   /* Save tableb to dataset       */ /* @CG */\nEDITMACR    = \"RACFEMAC\"   /* Edit Macro, turn HILITE off  */ /* @BO */\nTABLEA      = 'TA'RANDOM(0,99999)  /* Unique table name A  */ /* @C7 */\nTABLEB      = 'TB'RANDOM(0,99999)  /* Unique table name B  */ /* @C8 */\nDDNAME      = 'RACFA'RANDOM(0,999) /* Unique ddname        */ /* @C2 */\nparse source . . REXXPGM .         /* Obtain REXX pgm name */ /* @C1 */\nREXXPGM     = LEFT(REXXPGM,8)                                 /* @C1 */\nNULL        = ''                                              /* @C9 */\n\nADDRESS ISPEXEC                                               /* @AJ */\n  Rclass = 'DATASET'\n  \"CONTROL ERRORS RETURN\"                                     /* @B1 */\n  \"VGET (SETGFLTR SETGSTA  SETGSTAP SETGDISP\",                /* @C6 */\n        \"SETMADMN SETMIRRX SETMSHOW SETMTRAC) PROFILE\"        /* @C6 */\n\n  If (SETMTRAC <> 'NO') then do                               /* @BV */\n     Say \"*\"COPIES(\"-\",70)\"*\"                                 /* @BV */\n     Say \"*\"Center(\"Begin Program = \"REXXPGM,70)\"*\"           /* @BV */\n     Say \"*\"COPIES(\"-\",70)\"*\"                                 /* @BV */\n     if (SETMTRAC <> 'PROGRAMS') THEN                         /* @BW */\n        interpret \"Trace \"SUBSTR(SETMTRAC,1,1)                /* @BV */\n  end                                                         /* @BV */\n\n  If (SETMADMN = \"YES\") then do                               /* @B2 */\n     SELCMDS2 = \"[S]Show,[L]List,[D]Dsn,[C]Change,\"||,        /* @B9 */\n                \"[A]Add,[R]Remove\"                            /* @B4 */\n     IF (SETMIRRX = \"YES\") THEN                               /* @BR */\n        SELCMDS5 = \"[S]Show,[L]List,[P]Profile,\"||,           /* @BH */\n                   \"[C]Change,[A]Add,[R]Remove\"               /* @BH */\n     ELSE                                                     /* @BR */\n        SELCMDS5 = \"[S]Show,[L]List,\"||,                      /* @BR */\n                   \"[C]Change,[A]Add,[R]Remove\"               /* @BR */\n  end\n  else do\n     SELCMDS2 = \"[S]Show,[L]list,[D]Dsn\"                      /* @B9 */\n     IF (SETMIRRX = \"YES\") THEN                               /* @CD */\n        SELCMDS5 = \"[S]Show,[L]list,[P]Profile\"               /* @CD */\n     ELSE                                                     /* @CD */\n        SELCMDS5 = \"[S]Show,[L]list\"                          /* @B9 */\n  end\n\n  Rfilter  = SETGFLTR                                         /* @AC */\n  rlv      = SYSVAR('SYSLRACF')\n  chgsmade = 'N'                                              /* @A3 */\n\n  \"DISPLAY PANEL(\"PANEL01\")\"                                  /* @AU */\n  X = MSG(\"OFF\")                                              /* @CL */\n  CHKDSN = SYSDSN(RFILTER)                                    /* @CL */\n  X = MSG(\"ON\")                                               /* @CL */\n  IF (CHKDSN = \"OK\") THEN DO                                  /* @CL */\n     CALL LIST_FULL_DSN                                       /* @CL */\n     RETURN                                                   /* @CL */\n  END                                                         /* @CL */\n\n  Do while (rc = 0)\n     call Profl\n     \"DISPLAY PANEL(\"PANEL01\")\"                               /* @AU */\n  End\n\n  If (chgsmade = \"Y\") then Do                                 /* @A3 */\n     msg='You are about to refresh the generic class: 'rclass /* @A3 */\n     Sure_? = Confirm_request(msg)                            /* @A3 */\n     If (Sure_? = 'YES') then                                 /* @A3 */\n        call EXCMD \"SETROPTS GENERIC(DATASET)\"                /* @A3 */\n  End                                                         /* @A3 */\n\n  If (SETMTRAC <> 'NO') then do                               /* @BW */\n     Say \"*\"COPIES(\"-\",70)\"*\"                                 /* @BW */\n     Say \"*\"Center(\"End Program = \"REXXPGM,70)\"*\"             /* @BW */\n     Say \"*\"COPIES(\"-\",70)\"*\"                                 /* @BW */\n  end                                                         /* @BW */\nEXIT\n/*--------------------------------------------------------------------*/\n/*  Show all profiles for a filter                                    */\n/*--------------------------------------------------------------------*/\nPROFL:\n  call CREATE_TABLEA\n  if (dataset = 'INVALID') | (dataset = 'NONE') THEN DO       /* @CM */\n     \"TBEND\" tbla\n     call racfmsgs 'ERR16'                                    /* @C5 */\n     rc=8                                                     /* @CM */\n     return\n  end\n  opta   = ' '\n  xtdtop = 0                                                  /* @CA */\n  rsels  = 0                                                  /* @CA */\n  do forever                                                  /* @CA */\n     if (rsels < 2) then do                                   /* @CA */\n        \"TBTOP \" TABLEA                                       /* @CA */\n        'tbskip' tablea 'number('xtdtop')'                    /* @CA */\n        radmrfnd = 'PASSTHRU'                                 /* @CA */\n        'vput (radmrfnd)'                                     /* @CA */\n        \"TBDISPL\" TABLEA \"PANEL(\"PANEL02\")\"                   /* @CA */\n     end                                                      /* @CA */\n     else 'tbdispl' tablea                                    /* @CA */\n     if (rc > 4) then leave                                   /* @CA */\n     xtdtop   = ztdtop                                        /* @CA */\n     rsels    = ztdsels                                       /* @CA */\n     radmrfnd = null                                          /* @CA */\n     'vput (radmrfnd)'                                        /* @CA */\n     PARSE VAR ZCMD ZCMD PARM SEQ                             /* @CA */\n     IF (SROW <> \"\") & (SROW <> 0) THEN                       /* @AO */\n        IF (SROW > 0) THEN DO                                 /* @AO */\n           \"TBTOP \" TABLEA                                    /* @AO */\n           \"TBSKIP\" TABLEA \"NUMBER(\"SROW\")\"                   /* @AO */\n        END                                                   /* @AO */\n     if (zcmd = 'RFIND') then do                              /* @C9 */\n        zcmd = 'FIND'                                         /* @C9 */\n        parm = findit                                         /* @C9 */\n        'tbtop ' TABLEA                                       /* @C9 */\n        'tbskip' TABLEA 'number('last_find')'                 /* @C9 */\n     end                                                      /* @C9 */\n     Select                                                   /* @AL */\n        When (abbrev(\"FIND\",zcmd,1) = 1) then                 /* @C9 */\n             call do_finda                                    /* @C9 */\n        WHEN (ABBREV(\"LOCATE\",ZCMD,1) = 1) THEN do            /* @BI */\n             if (parm <> '') then do                          /* @BI */\n                locarg = parm'*'                              /* @BI */\n                PARSE VAR SORT . \",\" . \",\" SEQ                /* @BI */\n                IF (SEQ = \"D\") THEN                           /* @BI */\n                   CONDLIST = \"LE\"                            /* @BI */\n                ELSE                                          /* @BI */\n                   CONDLIST = \"GE\"                            /* @BI */\n                parse value sort with scan_field',' .         /* @BI */\n                interpret scan_field ' = locarg'              /* @BI */\n                'tbtop ' tablea                               /* @BI */\n                \"TBSCAN \"TABLEa\" ARGLIST(\"scan_field\")\",      /* @BI */\n                        \"CONDLIST(\"CONDLIST\")\",               /* @BI */\n                        \"position(scanrow)\"                   /* @BI */\n                xtdtop = scanrow                              /* @BI */\n             end                                              /* @BI */\n        end                                                   /* @BI */\n        WHEN (ABBREV(\"ONLY\",ZCMD,1) = 1) THEN DO              /* @AL */\n             find_str = translate(parm)                       /* @AL */\n             'tbtop ' TABLEA                                  /* @AL */\n             'tbskip' TABLEA                                  /* @AL */\n             do forever                                       /* @AL */\n                str = translate(dataset type)                 /* @AL */\n                if (pos(find_str,str) > 0) then nop           /* @AL */\n                else 'tbdelete' TABLEA                        /* @AL */\n                'tbskip' TABLEA                               /* @AL */\n                if (rc > 0) then do                           /* @AL */\n                   'tbtop' TABLEA                             /* @AL */\n                   leave                                      /* @AL */\n                end                                           /* @AL */\n             end                                              /* @AL */\n        END                                                   /* @AL */\n        WHEN (ABBREV(\"RESET\",ZCMD,1) = 1) THEN DO             /* @AL */\n             if (parm <> '') then                             /* @C4 */\n                rfilter = parm                                /* @C4 */\n             xtdtop   = 1                                     /* @AL */\n             \"TBEND\" TABLEA                                   /* @BL */\n             call CREATE_TABLEA                               /* @AL */\n        END                                                   /* @AL */\n        When (abbrev(\"SAVE\",zcmd,2) = 1) then DO              /* @CG */\n             TMPSKELT = SKELETON1                             /* @CG */\n             call do_SAVE                                     /* @CG */\n        END                                                   /* @CG */\n        WHEN (ABBREV(\"SORT\",ZCMD,1) = 1) THEN DO              /* @AN */\n             SELECT                                           /* @AN */\n                when (ABBREV(\"PROFILE\",PARM,1) = 1) then      /* @AQ */\n                     call sortseq 'DATASET'                   /* @BL */\n                when (ABBREV(\"TYPE\",PARM,1) = 1) then         /* @AQ */\n                     call sortseq 'TYPE'                      /* @BL */\n                otherwise NOP                                 /* @AN */\n             END                                              /* @AN */\n             CLRDATA = \"GREEN\"; CLRTYPE = \"GREEN\"             /* @CA */\n             PARSE VAR SORT LOCARG \",\" .                      /* @CA */\n             INTERPRET \"CLR\"SUBSTR(LOCARG,1,4)\" = 'TURQ'\"     /* @CA */\n             \"TBSORT \"TABLEA \"FIELDS(\"sort\")\"                 /* @CA */\n             \"TBTOP  \"TABLEA                                  /* @CA */\n        END                                                   /* @AN */\n        otherwise NOP                                         /* @AM */\n     END /* Select */                                         /* @AL */\n     ZCMD = \"\"; PARM = \"\"                                     /* @CA */\n     'control display save'                                   /* @CA */\n     Select\n        when (opta = 'A') then call Addd\n        when (opta = 'C') then call Chgd\n        when (opta = 'D')  then do                            /* @B4 */\n             \"CONTROL DISPLAY SAVE\"                           /* @B4 */\n             \"SELECT PGM(ISRDSLST)\",                          /* @B4 */\n                     \"PARM(DSL '\"dataset\"')\",                 /* @B4 */\n                     \"SUSPEND SCRNAME(DSL)\"                   /* @B4 */\n             \"CONTROL DISPLAY RESTORE\"                        /* @B4 */\n        end                                                   /* @B4 */\n        when (opta = 'L') then call Lisd                      /* @A1 */\n        when (opta = 'R') then call Deld\n        when (opta = 'S') then call Disd\n        otherwise nop\n     End\n     'control display restore'                                /* @CA */\n  end  /* Do forever) */                                      /* @CA */\nRETURN\n/*--------------------------------------------------------------------*/\n/*  Process primary command FIND for TABLEA                      @C9  */\n/*--------------------------------------------------------------------*/\nDO_FINDa:                                                     /* @C9 */\n  if (parm = null) then do                                    /* @C9 */\n     racfsmsg = 'Error'                                       /* @C9 */\n     racflmsg = 'Find requires a value to search for.' ,      /* @C9 */\n                'Try again.'                                  /* @C9 */\n     'setmsg msg(RACF011)'                                    /* @C9 */\n     return                                                   /* @C9 */\n  end                                                         /* @C9 */\n  findit    = translate(parm)                                 /* @C9 */\n  last_find = 0                                               /* @C9 */\n  wrap      = 0                                               /* @C9 */\n  do forever                                                  /* @C9 */\n     'tbskip' TABLEA                                          /* @C9 */\n     if (rc > 0) then do                                      /* @C9 */\n        if (wrap = 1) then do                                 /* @C9 */\n           racfsmsg = 'Not Found'                             /* @C9 */\n           racflmsg = findit 'not found.'                     /* @C9 */\n           'setmsg msg(RACF011)'                              /* @C9 */\n           return                                             /* @C9 */\n        end                                                   /* @C9 */\n        if (wrap = 0) then wrap = 1                           /* @C9 */\n        'tbtop' TABLEA                                        /* @C9 */\n     end                                                      /* @C9 */\n     else do                                                  /* @C9 */\n        testit = translate(dataset type)                      /* @C9 */\n        if (pos(findit,testit) > 0) then do                   /* @C9 */\n           'tbquery' TABLEA 'position(srow)'                  /* @C9 */\n           'tbtop'   TABLEA                                   /* @C9 */\n           'tbskip'  TABLEA 'number('srow')'                  /* @C9 */\n           last_find = srow                                   /* @C9 */\n           xtdtop    = srow                                   /* @C9 */\n           if (wrap = 0) then                                 /* @C9 */\n              racfsmsg = 'Found'                              /* @C9 */\n           else                                               /* @C9 */\n              racfsmsg = 'Found/Wrapped'                      /* @C9 */\n           racflmsg = findit 'found in row' srow + 0          /* @C9 */\n           'setmsg msg(RACF011)'                              /* @C9 */\n           return                                             /* @C9 */\n        end                                                   /* @C9 */\n     end                                                      /* @C9 */\n  end                                                         /* @C9 */\nRETURN                                                        /* @C9 */\n/*--------------------------------------------------------------------*/\n/*  Define sort sequence, to allow point-n-shoot sorting (A/D)   @BL  */\n/*--------------------------------------------------------------------*/\nSORTSEQ:                                                      /* @BL */\n  parse arg sortcol                                           /* @BL */\n  INTERPRET \"TMPSEQ = SORT\"substr(SORTCOL,1,4)                /* @BL */\n  select                                                      /* @BL */\n     when (seq <> \"\") then do                                 /* @BL */\n          if (seq = 'A') then                                 /* @BL */\n             tmpseq = 'D'                                     /* @BL */\n          else                                                /* @BL */\n             tmpseq = 'A'                                     /* @BL */\n          sort = sortcol',C,'seq                              /* @BL */\n     end                                                      /* @BL */\n     when (seq = \"\"),                                         /* @BL */\n        & (tmpseq = 'A') then do                              /* @BL */\n           sort   = sortcol',C,A'                             /* @BL */\n           tmpseq = 'D'                                       /* @BL */\n     end                                                      /* @BL */\n     Otherwise do                                             /* @BL */\n        sort   = sortcol',C,D'                                /* @BL */\n        tmpseq = 'A'                                          /* @BL */\n     end                                                      /* @BL */\n  end                                                         /* @BL */\n  INTERPRET \"SORT\"SUBSTR(SORTCOL,1,4)\" = TMPSEQ\"              /* @BL */\nRETURN                                                        /* @BL */\n/*--------------------------------------------------------------------*/\n/*  Add new profile                                                   */\n/*--------------------------------------------------------------------*/\nADDD:\n  chgsmade = \"Y\"                                              /* @A3 */\n  new      = 'NO'\n  if (dataset = 'NONE') then\n     new = 'YES'\n  else\n     CALL Getd\n  \"DISPLAY PANEL(\"PANEL03\")\"                                  /* @AU */\n  if (rc > 0) then\n     return\n  if (type = 'DISCRETE') then\n     type = ' '\n  aud = ' '\n  if (fail <> ' ') then\n     aud = 'FAILURES('FAIL')'\n  if (succ <> ' ') then\n     aud = 'SUCCESS('SUCC')' aud\n  if (aud <> ' ') then\n     aud = 'AUDIT('AUD')'\n  wrn = ' '\n  if (warn = 'YES') then\n     wrn = 'WARNING'\n  if (warn = 'NO') then                                       /* @AA */\n     wrn = 'NOWARNING'                                        /* @AA */\n  xtr = ' '\n  if (data <> ' ') then\n     xtr = xtr \"DATA('\"data\"')\"\n  call EXCMD \"ADDSD '\"DATASET\"' OWN(\"OWNER\")\",\n             \"UACC(\"UACC\")\" type aud xtr\n  if (cmd_rc > 0) then do                                     /* @BE */\n     CALL racfmsgs 'ERR01' /* Add failed */                   /* @B6 */\n     return\n  end\n  x = msg('OFF')\n  call EXCMD \"PERMIT '\"DATASET\"' ID(\"USERID()\")\",\n             \"DELETE\" TYPE\n  x = msg('ON')\n  if (from <> ' ') then do\n     fopt = \"FROM('\"FROM\"') FCLASS(DATASET) FGENERIC\"\n     call EXCMD \"PERMIT '\"DATASET\"'\" TYPE FOPT\n     if (cmd_rc > 0) then                                     /* @BE */\n        CALL racfmsgs 'ERR04' /* Permit Warn */               /* @B6 */\n  end\n  if (type = ' ') then\n     type = 'DISCRETE'\n  \"TBMOD\" TABLEA \"ORDER\"                                      /* @CB */\n  if (new = 'YES') then do\n     dataset = 'NONE'\n     type    = 'GEN'\n     \"TBDELETE\" TABLEA\n  end\nRETURN\n/*--------------------------------------------------------------------*/\n/*  Change profile                                                    */\n/*--------------------------------------------------------------------*/\nCHGD:\n  chgsmade = \"Y\"                                              /* @A3 */\n  if (dataset = 'NONE') then\n     return\n  CALL Getd\n  \"DISPLAY PANEL(\"PANEL04\")\"                                  /* @AU */\n  if (rc > 0) then return\n  if (type = 'DISCRETE') then\n     type = ' '\n  own = ' '\n  if (owner <> ' ') then\n     own = 'OWNER('OWNER')'\n  uc = ' '\n  if (uacc <> ' ') then\n     uc = 'UACC('UACC')'\n  aud = ' '\n  wrn = ' '\n  if (warn  = 'YES') then\n     wrn = 'WARNING'\n  if (warn  = 'NO') then                                      /* @AA */\n     wrn = 'NOWARNING'                                        /* @AA */\n  if (fail <> ' ') then\n     aud = 'FAILURES('FAIL')'\n  if (succ <> ' ') then\n     aud = 'SUCCESS('SUCC')' aud\n  if (aud  <> ' ') then\n     aud = 'AUDIT('AUD')'\n  xtr = ' '\n  if (data <> ' ') then do\n     if (data = 'NONE') then\n        data = ' '\n     xtr = xtr \"DATA('\"DATA\"')\"\n  end\n  msg = \"ALTDSD '\"DATASET\"'\" own uc type aud xtr wrn\n  call EXCMD \"ALTDSD '\"DATASET\"'\" own uc type aud xtr wrn\n  if (cmd_rc > 0) then                                        /* @BE */\n     call racfmsgs 'ERR07' /* Altdsd failed */                /* @B6 */\n  else do\n     if (type = ' ') then\n        type = 'DISCRETE'\n     \"tbmod\" TABLEA\n  end\nRETURN\n/*--------------------------------------------------------------------*/\n/*  Delete profile                                                    */\n/*--------------------------------------------------------------------*/\nDELD:\n  chgsmade = \"Y\"                                              /* @A3 */\n  if (dataset = 'NONE') then\n     return\n  if (type = 'DISCRETE') then\n     type = ' '\n  msg    = 'You are about to delete 'dataset\n  Sure_? = Confirm_request(msg)\n  if (sure_? = 'YES') then do\n     call EXCMD \"DELDSD '\"DATASET\"'\" type\n     if (cmd_rc > 0) then do                                  /* @BE */\n        if (type = ' ') then\n           type = 'DISCRETE'\n        CALL racfmsgs \"ERR02\" /* Del DSD failed */            /* @BG */\n        return                                                /* @BG */\n     end\n     else\n        \"TBDELETE\" TABLEA                                     /* @BG */\n  end\nRETURN\n/*--------------------------------------------------------------------*/\n/*  Display profile permits                                           */\n/*--------------------------------------------------------------------*/\nDISD:\n  if (dataset = 'NONE') then do                               /* @BU */\n     call racfmsgs ERR21                                      /* @BU */\n     return\n  end                                                         /* @BU */\n  tmpsort   = sort                                            /* @BM */\n  tmprsels  = rsels                                           /* @CE */\n  tmpxtdtop = xtdtop                                          /* @CF */\n  Do until (RB = 'NO')      /* allow rebuild option */\n     call create_TABLEB                                       /* @BM */\n     rb     = 'NO'\n     xtdtop = 0                                               /* @CA */\n     rsels  = 0                                               /* @CA */\n     do forever                                               /* @CA */\n        if (rsels < 2) then do                                /* @CA */\n           optb = ' '                                         /* @CA */\n           \"TBTOP \" TABLEB                                    /* @CA */\n           'tbskip' tableb 'number('xtdtop')'                 /* @CA */\n           radmrfnd = 'PASSTHRU'                              /* @CA */\n           'vput (radmrfnd)'                                  /* @CA */\n           \"TBDISPL\" TABLEB \"PANEL(\"PANEL05\")\"                /* @CA */\n        end                                                   /* @CA */\n        else 'tbdispl' tableb                                 /* @CA */\n        if (rc > 4) then leave                                /* @CA */\n        xtdtop   = ztdtop                                     /* @CA */\n        rsels    = ztdsels                                    /* @CA */\n        radmrfnd = null                                       /* @CA */\n        'vput (radmrfnd)'                                     /* @CA */\n        PARSE VAR ZCMD ZCMD PARM SEQ                          /* @CA */\n        IF (SROW <> \"\") & (SROW <> 0) THEN                    /* @AO */\n           IF (SROW > 0) THEN DO                              /* @AO */\n              \"TBTOP \" TABLEB                                 /* @AO */\n              \"TBSKIP\" TABLEB \"NUMBER(\"SROW\")\"                /* @AO */\n           END                                                /* @AO */\n        if (zcmd = 'RFIND') then do                           /* @C9 */\n           zcmd = 'FIND'                                      /* @C9 */\n           parm = findit                                      /* @C9 */\n           'tbtop' TABLEB                                     /* @C9 */\n           'tbskip' TABLEB 'number('last_find')'              /* @C9 */\n        end                                                   /* @C9 */\n        Select                                                /* @BM */\n           When (abbrev(\"FIND\",zcmd,1) = 1) then              /* @C9 */\n                call do_findb                                 /* @C9 */\n           WHEN (ABBREV(\"LOCATE\",ZCMD,1) = 1) THEN DO         /* @CA */\n                if (parm <> '') then do                       /* @CA */\n                   locarg = parm'*'                           /* @CA */\n                   PARSE VAR SORT . \",\" . \",\" SEQ             /* @CA */\n                   IF (SEQ = \"D\") THEN                        /* @CA */\n                      CONDLIST = \"LE\"                         /* @CA */\n                   ELSE                                       /* @CA */\n                      CONDLIST = \"GE\"                         /* @CA */\n                   parse value sort with scan_field',' .      /* @CA */\n                   interpret scan_field ' = locarg'           /* @CA */\n                   'tbtop ' tableb                            /* @CA */\n                   \"TBSCAN \"TABLEb\" ARGLIST(\"scan_field\")\",   /* @CA */\n                           \"CONDLIST(\"CONDLIST\")\",            /* @CA */\n                           \"position(scanrow)\"                /* @CA */\n                   xtdtop = scanrow                           /* @CA */\n                end                                           /* @CA */\n           END                                                /* @CA */\n           WHEN (ABBREV(\"ONLY\",ZCMD,1) = 1) THEN DO           /* @BM */\n                find_str = translate(parm)                    /* @BM */\n                'tbtop ' TABLEB                               /* @BM */\n                'tbskip' TABLEB                               /* @BM */\n                do forever                                    /* @BM */\n                   str = translate(id acc)                    /* @BM */\n                   if (pos(find_str,str) > 0) then nop        /* @BM */\n                   else 'tbdelete' TABLEB                     /* @BM */\n                   'tbskip' TABLEB                            /* @BM */\n                   if (rc > 0) then do                        /* @BM */\n                      'tbtop' TABLEB                          /* @BM */\n                      leave                                   /* @BM */\n                   end                                        /* @BM */\n                end                                           /* @BM */\n           END                                                /* @BM */\n           WHEN (ABBREV(\"RESET\",ZCMD,1) = 1) THEN DO          /* @BM */\n                xtdtop   = 1                                  /* @BM */\n                \"TBEND\" TABLEB                                /* @BM */\n                call create_TABLEB                            /* @BM */\n           END                                                /* @BM */\n           When (abbrev(\"SAVE\",zcmd,2) = 1) then DO           /* @CG */\n                TMPSKELT = SKELETON2                          /* @CG */\n                call do_SAVE                                  /* @CG */\n           END                                                /* @CG */\n           WHEN (ABBREV(\"SORT\",ZCMD,1) = 1) THEN DO           /* @BM */\n                SELECT                                        /* @BM */\n                   when (ABBREV(\"GROUP\",PARM,1) = 1) then     /* @BM */\n                        call sortseq 'ID'                     /* @BM */\n                   when (ABBREV(\"ID\",PARM,1) = 1) then        /* @BM */\n                        call sortseq 'ID'                     /* @BM */\n                   when (ABBREV(\"ACCESS\",PARM,1) = 1) then    /* @BM */\n                        call sortseq 'ACC'                    /* @BM */\n                   otherwise NOP                              /* @BM */\n                END                                           /* @BM */\n                PARSE VAR SORT LOCARG \",\" .                   /* @CA */\n                CLRID = \"GREEN\"; CLRACC = \"GREEN\"             /* @CA */\n                INTERPRET \"CLR\"SUBSTR(LOCARG,1,4)\" = 'TURQ'\"  /* @CA */\n                \"TBSORT\" TABLEB \"FIELDS(\"sort\")\"              /* @CA */\n                \"TBTOP \" TABLEB                               /* @CA */\n           END                                                /* @BM */\n           otherwise NOP                                      /* @BM */\n        END /* Select */                                      /* @BM */\n        ZCMD = \"\"; PARM = \"\"                                  /* @CA */\n        'control display save'                                /* @CA */\n        Select\n           when (optb = 'A') then call Addp\n           when (optb = 'C') then call Chgp\n           when (optb = 'L') then call Lisp                   /* @A5 */\n           when (optb = 'P') then                             /* @BH */\n                call RACFPROF 'GROUP' id                      /* @BH */\n           when (optb = 'R') then call Delp\n           when (optb = 'S') then call Disp\n           otherwise nop\n        End\n        'control display restore'                             /* @CA */\n     end  /* Do forever) */                                   /* @CA */\n  end  /* Do until */\n  sort   = tmpsort                                            /* @BM */\n  rsels  = tmprsels                                           /* @CE */\n  xtdtop = tmpxtdtop                                          /* @CF */\nRETURN\n/*--------------------------------------------------------------------*/\n/*  Process primary command FIND for TABLEA                      @C9  */\n/*--------------------------------------------------------------------*/\nDO_FINDB:                                                     /* @C9 */\n  if (parm = null) then do                                    /* @C9 */\n     racfsmsg = 'Error'                                       /* @C9 */\n     racflmsg = 'Find requires a value to search for.' ,      /* @C9 */\n                'Try again.'                                  /* @C9 */\n     'setmsg msg(RACF011)'                                    /* @C9 */\n     return                                                   /* @C9 */\n  end                                                         /* @C9 */\n  findit    = translate(parm)                                 /* @C9 */\n  last_find = 0                                               /* @C9 */\n  wrap      = 0                                               /* @C9 */\n  do forever                                                  /* @C9 */\n     'tbskip' TABLEB                                          /* @C9 */\n     if (rc > 0) then do                                      /* @C9 */\n        if (wrap = 1) then do                                 /* @C9 */\n           racfsmsg = 'Not Found'                             /* @C9 */\n           racflmsg = findit 'not found.'                     /* @C9 */\n           'setmsg msg(RACF011)'                              /* @C9 */\n           return                                             /* @C9 */\n        end                                                   /* @C9 */\n        if (wrap = 0) then wrap = 1                           /* @C9 */\n        'tbtop' TABLEB                                        /* @C9 */\n     end                                                      /* @C9 */\n     else do                                                  /* @C9 */\n        testit = translate(id acc)                            /* @C9 */\n        if (pos(findit,testit) > 0) then do                   /* @C9 */\n           'tbquery' TABLEB 'position(srow)'                  /* @C9 */\n           'tbtop'   TABLEB                                   /* @C9 */\n           'tbskip'  TABLEB 'number('srow')'                  /* @C9 */\n           last_find = srow                                   /* @C9 */\n           xtdtop    = srow                                   /* @C9 */\n           if (wrap = 0) then                                 /* @C9 */\n              racfsmsg = 'Found'                              /* @C9 */\n           else                                               /* @C9 */\n              racfsmsg = 'Found/Wrapped'                      /* @C9 */\n           racflmsg = findit 'found in row' srow + 0          /* @C9 */\n           'setmsg msg(RACF011)'                              /* @C9 */\n           return                                             /* @C9 */\n        end                                                   /* @C9 */\n     end                                                      /* @C9 */\n  end                                                         /* @C9 */\nRETURN                                                        /* @C9 */\n/*--------------------------------------------------------------------*/\n/*  Create table 'B'                                             @BM  */\n/*--------------------------------------------------------------------*/\nCREATE_TABLEB:                                                /* @BM */\n  \"TBCREATE\" TABLEB \"KEYS(ID) NAMES(ACC)\",\n                  \"REPLACE NOWRITE\"\n  flags = 'OFF'\n  audit = ' '\n  owner = ' '\n  warn  = ' '\n  uacc  = ' '\n  data  = ' '\n  if (type = 'DISCRETE') then\n     type = ' '\n  cmd = \"LISTDSD DA('\"DATASET\"') AUTH\"\n  x = OUTTRAP('VAR.')\n  address TSO cmd                                             /* @AI */\n  cmd_rc = rc                                                 /* @AZ */\n  x = OUTTRAP('OFF')\n  if (SETMSHOW <> 'NO') then                                  /* @BJ */\n     call SHOWCMD                                             /* @AI */\n  if (type = ' ') then\n     type = 'DISCRETE'\n  Do i = 1 to var.0          /* Scan output */\n     temp = var.i\n     if (rlv > '1081') then  /* RACF 1.9 add blank */\n        temp = ' 'temp\n     l = LENGTH(temp)\n     if (uacc= ' ') then\n        if (substr(temp,2,12)= 'LEVEL  OWNER') then do\n           i     = i + 2\n           temp  = var.i\n           owner = subword(temp,2,1)\n           uacc  = subword(temp,3,1)\n           warn  = subword(temp,4,1)                          /* @A9 */\n        end\n     if (audit = ' ') then\n        if (substr(temp,2,8) = 'AUDITING') then do\n           i     = i + 2\n           temp  = var.i\n           audit = subword(temp,1,1)\n        end\n     if (data = ' ') then\n        if (substr(temp,2,17) = 'INSTALLATION DATA') then do\n           i    = i + 2\n           temp = var.i\n           data = temp\n           i    = i + 1\n           temp = var.i\n           data = data || substr(temp,2)\n        end\n     if (flags = 'ON') then do\n        if (l = 1) | (l = 2) then\n           flags = 'OUT'     /* end of access list */\n        if (l > 8) then\n           if (substr(temp,1,9) = ' ') then\n              flags = 'OUT'  /* end of access list */\n     end\n     if (flags = 'ON') then do\n        if (substr(temp,2,10) = 'NO ENTRIES') then do\n           id  = 'NONE'        /* empty access list */\n           acc = 'DEFINED'\n        end\n        else do\n           id  = subword(temp,1,1)\n           acc = subword(temp,2,1)\n        end\n        \"TBMOD\" TABLEB\n     end\n     if (substr(temp,5,13) = 'ID     ACCESS') then do\n        flags = 'ON'      /* start of access list */\n        i     = i + 1     /* skip */\n     end\n  end  /* Loop scan output */\n  sort   = 'ID,C,A'                                           /* @CA */\n  sortid = 'D'; sortacc = 'A'        /* Sort order */         /* @CA */\n  CLRID  = \"TURQ\"; CLRACC = \"GREEN\"  /* Col colors */         /* @CA */\n  \"TBSORT \" TABLEB \"FIELDS(\"sort\")\"                           /* @CA */\n  \"TBTOP  \" TABLEB                                            /* @CA */\nRETURN                                                        /* @BM */\n/*--------------------------------------------------------------------*/\n/*  Get LISTDSD info to initialize add or change option               */\n/*--------------------------------------------------------------------*/\nGETD:\n  flags = 'OFF'\n  owner = ' '\n  warn  = ' '\n  uacc  = ' '\n  audit = ' '\n  data  = ' '\n  cmd   = \"LISTDSD DA('\"DATASET\"')\"                           /* @AI */\n  x = OUTTRAP('VAR.')\n  address TSO cmd                                             /* @AI */\n  cmd_rc = rc                                                 /* @AZ */\n  x = OUTTRAP('OFF')\n  if (SETMSHOW <> 'NO') then                                  /* @BJ */\n     call SHOWCMD                                             /* @AI */\n  Do i = 1 to var.0 while (flags <> 'OUT') /* Scan output */\n     temp = var.i\n     if (rlv > '1081') then  /* RACF 1.9 add blank */\n        temp = ' 'temp\n     if (uacc = ' ') then\n        if (substr(temp,2,12) = 'LEVEL  OWNER') then do\n           i     = i + 2\n           temp  = var.i\n           owner = subword(temp,2,1)\n           uacc  = subword(temp,3,1)\n           warn  = subword(temp,4,1)                          /* @A9 */\n        end\n     if (audit = ' ') then\n        if (substr(temp,2,8) = 'AUDITING') then do\n           i     = i + 2\n           temp  = var.i\n           audit = subword(temp,1,1)\n        end\n     if (data = ' ') then\n        if (substr(temp,2,17) = 'INSTALLATION DATA') then do\n           i    = i + 2\n           temp = var.i\n           if (rlv > '1081') then  /* RACF 1.9 add blank */\n              temp = ' 'temp\n           data = subword(temp,1)\n           i    = i + 1\n           temp = var.i\n           if (rlv > '1081') then  /* RACF 1.9 add blank */\n              temp = ' 'temp\n           data = data || substr(temp,2)\n        end\n  end /* i= 1 do */\n  a = INDEX(audit,'ALL')\n  if (a > 0) then do\n     fail = substr(audit,a+4,7)\n     succ = substr(audit,a+4,7)\n  end\n  else do\n     f = INDEX(audit,'FAILURES')\n     if (f > 0) then\n        fail = substr(audit,f+9,7)\n     s = INDEX(audit,'SUCCESS')\n     if (s > 0) then\n        succ = substr(audit,s+8,7)\n  end\nRETURN\n/*--------------------------------------------------------------------*/\n/*  Change permit option                                              */\n/*--------------------------------------------------------------------*/\nCHGP:\n  If (id = 'NONE') then\n     return\n  \"DISPLAY PANEL(\"PANEL06\")\"                                  /* @AU */\n  if (rc > 0) then\n     return\n  if (type = 'DISCRETE') then\n     type = ' '\n  call EXCMD \"PERMIT '\"DATASET\"' ID(\"ID\") ACC(\"ACC\")\" TYPE\n  if (cmd_rc = 0) then do                                     /* @C5 */\n     if (type = ' ') then\n        type = 'DISCRETE'\n     \"TBMOD\" TABLEB\n  end\n  else\n     Call racfmsgs 'ERR03' /* permit failed */                /* @B6 */\nRETURN\n/*--------------------------------------------------------------------*/\n/*  Add permit option                                                 */\n/*--------------------------------------------------------------------*/\nADDP:\n  new = 'NO'\n  if (id = 'NONE') then\n     new = 'YES'\n  from = ' '\n  \"DISPLAY PANEL(\"PANEL07\")\"                                  /* @AU */\n  if (rc > 0) then\n     return\n  if (type = 'DISCRETE') then\n     type = ' '\n  idopt = ' '\n  if (id <> ' ') then\n     idopt = 'ID('ID') ACCESS('ACC')'\n  fopt = ' '\n  if (from <> ' ') then do\n     fopt = \"FROM('\"FROM\"') FCLASS(DATASET) FGENERIC\"\n     rb   = 'YES'             /* Cause table rebuild */\n  end\n  call EXCMD \"PERMIT '\"DATASET\"'\" idopt type fopt\n  if (cmd_rc = 0) then do                                     /* @C5 */\n     \"TBMOD\" TABLEB\n     if (new = 'YES') then do\n        id = 'NONE'\n        \"TBDELETE\" TABLEB\n     end\n  end\n  else do\n     if (from <> ' ') then\n        call racfmsgs 'ERR04' /* Permit Warning/Failed */     /* @B6 */\n     else\n        call racfmsgs 'ERR05' /* Permit Failed */             /* @B6 */\n  end\nRETURN\n/*--------------------------------------------------------------------*/\n/*  Delete permit option                                              */\n/*--------------------------------------------------------------------*/\nDELP:\n  if (id = 'NONE') then\n     return\n  if (type = 'DISCRETE') then\n     type = ' '\n  msg    = 'You are about to delete access for 'ID\n  Sure_? = Confirm_request(msg)\n  if (sure_? = 'YES') then do\n     call EXCMD \"PERMIT '\"DATASET\"' ID(\"ID\") DELETE\" TYPE\n     if (cmd_rc = 0) then                                     /* @C5 */\n        \"TBDELETE\" TABLEB\n     else\n        call racfmsgs 'ERR06' /* Permit Failed */             /* @B6 */\n  end\nRETURN\n/*--------------------------------------------------------------------*/\n/*  Display userid                                                    */\n/*--------------------------------------------------------------------*/\nDISP:\n  if (id = \"*\") then do  /* Wild card - All other entries */  /* @B8 */\n     call RACFMSGS ERR17                                      /* @B8 */\n     return                                                   /* @B8 */\n  end                                                         /* @B8 */\n  x   = msg('OFF')\n  cmd = \"LU \"id                                               /* @AI */\n  x = OUTTRAP('trash.')\n  address TSO cmd                                             /* @AI */\n  cmd_rc = rc\n  x = OUTTRAP('OFF')\n  if (SETMSHOW <> 'NO') then                                  /* @BJ */\n     call SHOWCMD                                             /* @AI */\n  x = msg('ON')\n  if (cmd_rc = 0) then call RACFUSR id                        /* @B7 */\n  else call RACFGRP id\nRETURN\n/*--------------------------------------------------------------------*/\n/*  Confirm delete                                                    */\n/*--------------------------------------------------------------------*/\nCONFIRM_REQUEST:\n  signal off error\n  arg message\n  answer  = 'NO'\n  zwinttl = 'CONFIRM REQUEST'\n  Do until (ckey = 'PF03') | (ckey = 'ENTER')\n     \"CONTROL NOCMD\"                                          /* @AV */\n     \"ADDPOP\"                                                 /* @AV */\n     \"DISPLAY PANEL(\"PANELM1\")\"                               /* @AU */\n     \"REMPOP\"                                                 /* @AV */\n  end\n  select\n     when (ckey = 'PF03')  then answer = 'NO'\n     when (ckey = 'ENTER') then answer = 'YES'\n     otherwise nop\n  End\n  zwinttl = ' '\nRETURN answer\n/*--------------------------------------------------------------------*/\n/*  Exec command                                                      */\n/*--------------------------------------------------------------------*/\nEXCMD:\n  signal off error\n  arg cmd\n  x = OUTTRAP('msg.')\n  address TSO cmd                                             /* @AY */\n  cmd_rc = rc\n  x = OUTTRAP('OFF')\n  if (SETMSHOW <> 'NO') then                                  /* @BJ */\n     call SHOWCMD                                             /* @AI */\n  if (subword(msg.1,1,1) = 'ICH11009I') |,\n     (subword(msg.1,1,1) = 'ICH10006I') |,\n     (subword(msg.1,1,1) = 'ICH06011I') then raclist = 'YES'\nRETURN\n/*--------------------------------------------------------------------*/\n/*  List dataset                                                      */\n/*--------------------------------------------------------------------*/\nLISD:                                                         /* @A1 */\n  CMDPRM  = \"ALL DSNS\"                                        /* @CK */\n  CMD     = \"LISTDSD DATASET('\"DATASET\"')\" CMDPRM             /* @B2 */\n  X = OUTTRAP(\"CMDREC.\")                                      /* @A1 */\n  ADDRESS TSO cmd                                             /* @AI */\n  cmd_rc = rc                                                 /* @AZ */\n  X = OUTTRAP(\"OFF\")                                          /* @A1 */\n  if (SETMSHOW <> 'NO') then                                  /* @BJ */\n     call SHOWCMD                                             /* @AI */\n  if (cmd_rc > 0) then do   /* Remove parms */                /* @BC */\n     CMD = \"LISTDSD DATASET('\"DATASET\"')\"                     /* @BC */\n     X   = OUTTRAP(\"CMDREC.\")                                 /* @BC */\n     ADDRESS TSO cmd                                          /* @BC */\n     cmd_rc = rc                                              /* @BC */\n     X   = OUTTRAP(\"OFF\")                                     /* @BC */\n     if (SETMSHOW <> 'NO') then                               /* @BJ */\n        call SHOWCMD                                          /* @BC */\n  end                                                         /* @BC */\n  call display_info                                           /* @BP */\n  if (cmd_rc > 0) then                                        /* @BD */\n     CALL racfmsgs \"ERR10\" /* Generic failure */              /* @B6 */\nRETURN                                                        /* @A1 */\n/*--------------------------------------------------------------------*/\n/*  Display information from line commands 'L' and 'P'           @BP  */\n/*--------------------------------------------------------------------*/\nDISPLAY_INFO:\n  ADDRESS TSO \"ALLOC F(\"DDNAME\") NEW REUSE\",                  /* @A1 */\n              \"LRECL(80) BLKSIZE(0) RECFM(F B)\",              /* @BQ */\n              \"UNIT(VIO) SPACE(1 5) CYLINDERS\"                /* @A1 */\n  ADDRESS TSO \"EXECIO * DISKW \"DDNAME\" (STEM CMDREC. FINIS\"   /* @A1 */\n  DROP CMDREC.                                                /* @CC */\n                                                              /* @CC */\n  \"LMINIT DATAID(CMDDATID) DDNAME(\"DDNAME\")\"                  /* @A1 */\n  SELECT                                                      /* @AF */\n     WHEN (SETGDISP = \"VIEW\") THEN                            /* @AF */\n          \"VIEW DATAID(\"CMDDATID\") MACRO(\"EDITMACR\")\"         /* @BN */\n     WHEN (SETGDISP = \"EDIT\") THEN                            /* @AF */\n          \"EDIT DATAID(\"CMDDATID\") MACRO(\"EDITMACR\")\"         /* @BN */\n     OTHERWISE                                                /* @AF */\n          \"BROWSE DATAID(\"CMDDATID\")\"                         /* @AF */\n  END                                                         /* @AF */\n  ADDRESS TSO \"FREE FI(\"DDNAME\")\"                             /* @A1 */\nRETURN                                                        /* @BP */\n/*--------------------------------------------------------------------*/\n/*  List group                                                        */\n/*--------------------------------------------------------------------*/\nLISP:                                                         /* @A5 */\n  if (id = \"*\") then do  /* Wild card - All other entries */  /* @BI */\n     call RACFMSGS ERR17                                      /* @BI */\n     return                                                   /* @BI */\n  end                                                         /* @BI */\n  CMDPRM  = \"CSDATA DFP OMVS OVM TME\"                         /* @A5 */\n  CMD     = \"LG \"ID CMDPRM                                    /* @AI */\n  X = OUTTRAP(\"CMDREC.\")                                      /* @A5 */\n  ADDRESS TSO cmd                                             /* @AI */\n  cmd_rc = rc                                                 /* @AZ */\n  X = OUTTRAP(\"OFF\")                                          /* @A5 */\n  if SETMSHOW <> 'NO' then                                    /* @BJ */\n     call SHOWCMD                                             /* @AI */\n  if (cmd_rc > 0) then do   /* Remove parms */                /* @AB */\n     X = OUTTRAP(\"CMDREC.\")                                   /* @AI */\n     CMD    = \"LU \"ID                                         /* @AI */\n     ADDRESS TSO cmd                                          /* @AI */\n     cmd_rc = rc                                              /* @AB */\n     if (SETMSHOW <> 'NO') then                               /* @BJ */\n        call SHOWCMD                                          /* @AI */\n     X = OUTTRAP(\"OFF\")                                       /* @AI */\n  end                                                         /* @AB */\n  call display_info                                           /* @BP */\n  if (cmd_rc > 0) then                                        /* @BF */\n     CALL racfmsgs \"ERR15\" /* Generic failure */              /* @B6 */\nRETURN                                                        /* @A5 */\n/*--------------------------------------------------------------------*/\n/*  Display RACF command and return code                         @AI  */\n/*--------------------------------------------------------------------*/\nSHOWCMD:                                                      /* @AI */\n  IF (SETMSHOW = \"BOTH\") | (SETMSHOW = \"DISPLAY\") THEN DO     /* @BK */\n     PARSE VAR CMD MSG1 60 MSG2 121 MSG3                      /* @AI */\n     MSG4 = \"Return code = \"cmd_rc                            /* @AZ */\n     \"ADDPOP ROW(6) COLUMN(4)\"                                /* @AV */\n     \"DISPLAY PANEL(\"PANELM2\")\"                               /* @AU */\n     \"REMPOP\"                                                 /* @AV */\n  END                                                         /* @BJ */\n  IF (SETMSHOW = \"BOTH\") | (SETMSHOW = \"LOG\") THEN DO         /* @BK */\n     zerrsm = \"RACFADM \"REXXPGM\" RC=\"cmd_rc                   /* @BX */\n     zerrlm = cmd                                             /* @BJ */\n     'log msg(isrz003)'                                       /* @BJ */\n  END                                                         /* @BJ */\nRETURN                                                        /* @AI */\n/*--------------------------------------------------------------------*/\n/*  Create table 'A'                                             @AL  */\n/*--------------------------------------------------------------------*/\nCREATE_TABLEA:\n  \"TBCREATE\" TABLEA \"KEYS(DATASET TYPE) REPLACE NOWRITE\"\n  cmd = \"SEARCH FILTER(\"RFILTER\") CLASS(DATASET)\"             /* @AI */\n  x = OUTTRAP('var.')\n  address TSO cmd                                             /* @AI */\n  cmd_rc = rc                                                 /* @AB */\n  x = OUTTRAP('OFF')\n  if (SETMSHOW <> 'NO') then                                  /* @BJ */\n     call SHOWCMD                                             /* @AI */\n  if (SETGSTAP <> \"\") THEN                                    /* @BZ */\n     INTERPRET \"RECNUM = var.0*.\"SETGSTAP\"%1\"                 /* @BZ */\n  Do i = 1 to var.0\n     temp = var.i\n     /*---------------------------------------------*/\n     /* Display number of records retrieved        -*/\n     /*---------------------------------------------*/\n     IF (SETGSTA = \"\") THEN DO                                /* @BZ */\n        IF (RECNUM <> 0) THEN                                 /* @BZ */\n           IF (I//RECNUM = 0) THEN DO                         /* @BZ */\n              n1 = i; n2 = var.0                              /* @BZ */\n              pct = ((n1/n2)*100)%1'%'                        /* @BZ */\n              \"control display lock\"                          /* @BZ */\n              \"display msg(RACF012)\"                          /* @C3 */\n           END                                                /* @BZ */\n     END                                                      /* @BZ */\n     ELSE DO                                                  /* @BZ */\n        IF (SETGSTA <> 0) THEN                                /* @BZ */\n           IF (I//SETGSTA = 0) THEN DO                        /* @AD */\n              n1 = i; n2 = var.0\n              pct = ((n1/n2)*100)%1'%'                        /* @BZ */\n              \"control display lock\"\n              \"display msg(RACF012)\"                          /* @C3 */\n           END                                                /* @AD */\n     END                                                      /* @BZ */\n\n     dataset = SUBWORD(temp,1,1)\n     t       = INDEX(temp,g)\n     if (t > 0) then\n        type = 'GEN'\n     else do\n        type = 'DISCRETE'\n        msgr = SUBWORD(temp,1,1)\n        Select\n           when (msgr = 'ICH31005I') then do\n                dataset = 'NONE'     /* No datasets */\n                type    = 'GEN'\n           end\n           when (msgr = 'ICH31009I') then do\n                dataset = 'INVALID'  /* Bad filter  */\n                call racfmsgs 'ERR08'                         /* @B6 */\n           end\n           when (msgr = 'ICH31012I') then do\n                dataset = 'INVALID'  /* Bad filter  */\n                call racfmsgs 'ERR08'                         /* @B6 */\n           end\n           when (msgr = 'ICH31014I') then do\n                dataset = 'INVALID'  /* Bad filter  */\n                call racfmsgs 'ERR08'                         /* @B6 */\n           end\n           when (msgr = 'ICH31016I') then do\n                dataset = 'INVALID'  /* Bad filter  */\n                call racfmsgs 'ERR08'                         /* @B6 */\n           end\n           when (msgr = 'ICH31017I') then do\n                dataset = 'INVALID'  /* Bad filter  */\n                call racfmsgs 'ERR08'                         /* @B6 */\n           end\n           when (msgr = 'ICH31018I') then do\n                dataset = 'INVALID'  /* Bad filter  */\n                call racfmsgs 'ERR08'                         /* @B6 */\n           end\n           when (msgr= 'IKJ56716I') then do\n                dataset = 'INVALID'  /* Bad filter  */\n                call racfmsgs 'ERR08'                         /* @B6 */\n           end\n           when (substr(msgr,1,6) = 'ICH310') then do\n                type = ' '           /* Misc. errs  */\n                call racfmsgs 'ERR09'                         /* @B6 */\n           end\n           otherwise nop\n        End  /* Select */\n     end  /* Else */\n     \"TBMOD\" TABLEA\n  end        /* Do i=1 to var.0 */\n  sort     = 'DATASET,C,A'                                    /* @CA */\n  sortdata = 'D'; sorttype = 'A'         /* Sort order */     /* @CA */\n  CLRDATA  = \"TURQ\"; CLRTYPE = \"GREEN\"   /* Col colors */     /* @CA */\n  \"TBSORT \" TABLEA \"FIELDS(\"sort\")\"                           /* @CA */\n  \"TBTOP  \" TABLEA                                            /* @CA */\nRETURN\n/*--------------------------------------------------------------------*/\n/*  Save table to dataset                                        @CG  */\n/*--------------------------------------------------------------------*/\nDO_SAVE:                                                      /* @CG */\n  X = MSG(\"OFF\")                                              /* @CG */\n  \"ADDPOP COLUMN(40)\"                                         /* @CG */\n  \"VGET (RACFSDSN RACFSMBR RACFSFIL RACFSREP) PROFILE\"        /* @CH */\n  IF (RACFSDSN = \"\") THEN         /* SAve - Dataset Name  */  /* @CI */\n     RACFSDSN = USERID()\".RACFADM.REPORTS\"                    /* @EK */\n  IF (RACFSFIL = \"\") THEN         /* SAve - As (TXT/CVS)  */  /* @CI */\n     RACFSFIL = \"T\"                                           /* @EL */\n  IF (RACFSREP = \"\") THEN         /* SAve - Replace (Y/N) */  /* @CI */\n     RACFSREP = \"N\"                                           /* @EK */\n                                                              /* @CG */\n  DO FOREVER                                                  /* @CG */\n     \"DISPLAY PANEL(\"PANELS1\")\"                               /* @CG */\n     IF (RC = 08) THEN DO                                     /* @CG */\n        \"REMPOP\"                                              /* @CG */\n        RETURN                                                /* @CG */\n     END                                                      /* @CG */\n     RACFSDSN = STRIP(RACFSDSN,,\"'\")                          /* @CG */\n     RACFSDSN = STRIP(RACFSDSN,,'\"')                          /* @CG */\n     RACFSDSN = STRIP(RACFSDSN)                               /* @CG */\n     SYSDSORG = \"\"                                            /* @CG */\n     X = LISTDSI(\"'\"RACFSDSN\"'\")                              /* @CG */\n     IF (SYSDSORG = \"\") | (SYSDSORG = \"PS\"),                  /* @CG */\n      | (SYSDSORG = \"PO\") THEN                                /* @CG */\n        NOP                                                   /* @CG */\n     ELSE DO                                                  /* @CG */\n        RACFSMSG = \"Not PDS/Seq File\"                         /* @CG */\n        RACFLMSG = \"The dataset specified is not\",            /* @CG */\n                  \"a partitioned or sequential\",              /* @CG */\n                  \"dataset, please enter a valid\",            /* @CG */\n                  \"dataset name.\"                             /* @CG */\n       \"SETMSG MSG(RACF011)\"                                  /* @CG */\n       ITERATE                                                /* @CG */\n     END                                                      /* @CG */\n     IF (SYSDSORG = \"PS\") & (RACFSMBR <> \"\") THEN DO          /* @CG */\n        RACFSMSG = \"Seq File - No mbr\"                        /* @CG */\n        RACFLMSG = \"This dataset is a sequential\",            /* @CG */\n                  \"file, please remove the\",                  /* @CG */\n                  \"member name.\"                              /* @CG */\n       \"SETMSG MSG(RACF011)\"                                  /* @CG */\n       ITERATE                                                /* @CG */\n     END                                                      /* @CG */\n     IF (SYSDSORG = \"PO\") & (RACFSMBR = \"\") THEN DO           /* @CG */\n        RACFSMSG = \"PDS File - Need Mbr\"                      /* @CG */\n        RACFLMSG = \"This dataset is a partitioned\",           /* @CG */\n                  \"dataset, please include a member\",         /* @CG */\n                  \"name.\"                                     /* @CG */\n       \"SETMSG MSG(RACF011)\"                                  /* @CG */\n       ITERATE                                                /* @CG */\n     END                                                      /* @CG */\n                                                              /* @CG */\n     IF (RACFSMBR = \"\") THEN                                  /* @CG */\n        TMPDSN = RACFSDSN                                     /* @CG */\n     ELSE                                                     /* @CG */\n        TMPDSN = RACFSDSN\"(\"RACFSMBR\")\"                       /* @CG */\n     DSNCHK = SYSDSN(\"'\"TMPDSN\"'\")                            /* @CG */\n     IF (DSNCHK = \"OK\" & RACFSREP = \"N\") THEN DO              /* @CG */\n        RACFSMSG = \"DSN/MBR Exists\"                           /* @CG */\n        RACFLMSG = \"Dataset/member already exists. \",         /* @CG */\n                  \"Please type in \"Y\" to replace file.\"       /* @CG */\n        \"SETMSG MSG(RACF011)\"                                 /* @CG */\n        ITERATE                                               /* @CG */\n     END                                                      /* @CG */\n     LEAVE                                                    /* @CG */\n  END                                                         /* @CG */\n  \"REMPOP\"                                                    /* @CG */\n  \"VPUT (RACFSDSN RACFSMBR RACFSFIL RACFSREP) PROFILE\"        /* @CH */\n                                                              /* @CG */\nADDRESS TSO                                                   /* @CG */\n  IF (RACFSREP = \"Y\" & RACFSMBR = \"\") |,                      /* @CG */\n     (DSNCHK <> \"OK\" & DSNCHK <> \"MEMBER NOT FOUND\"),         /* @CG */\n     THEN DO                                                  /* @CG */\n     \"DELETE '\"RACFSDSN\"'\"                                    /* @CG */\n     IF (RACFSMBR = \"\") THEN                                  /* @CG */\n        \"ALLOC  FI(ISPFILE) DA('\"RACFSDSN\"') NEW\",            /* @CG */\n            \"REUSE SP(1 1) CYLINDER UNIT(SYSALLDA)\",          /* @CJ */\n            \"LRECL(80) RECFM(F B)\"                            /* @CG */\n     ELSE                                                     /* @CG */\n        \"ALLOC  FI(ISPFILE) DA('\"RACFSDSN\"') NEW\",            /* @CG */\n            \"REUSE SP(1 1) CYLINDER UNIT(SYSALLDA)\",          /* @CJ */\n            \"LRECL(80) RECFM(F B)\",                           /* @CG */\n            \"DSORG(PO) DSNTYPE(LIBRARY,2)\"                    /* @CG */\n  END                                                         /* @CG */\n  ELSE                                                        /* @CG */\n     \"ALLOC  FI(ISPFILE) DA('\"RACFSDSN\"') SHR REUSE\"          /* @CG */\n                                                              /* @CG */\nADDRESS ISPEXEC                                               /* @CG */\n  \"FTOPEN\"                                                    /* @CG */\n  \"FTINCL \"TMPSKELT                                           /* @CG */\n  IF (RACFSMBR = \"\") THEN                                     /* @CG */\n     \"FTCLOSE\"                                                /* @CG */\n  ELSE                                                        /* @CG */\n     \"FTCLOSE NAME(\"RACFSMBR\")\"                               /* @CG */\n  ADDRESS TSO \"FREE FI(ISPFILE)\"                              /* @CG */\n                                                              /* @CG */\n  SELECT                                                      /* @CG */\n     WHEN (SETGDISP = \"VIEW\") THEN                            /* @CG */\n          \"VIEW DATASET('\"RACFSDSN\"') MACRO(\"EDITMACR\")\"      /* @CG */\n     WHEN (SETGDISP = \"EDIT\") THEN                            /* @CG */\n          \"EDIT DATASET('\"RACFSDSN\"') MACRO(\"EDITMACR\")\"      /* @CG */\n     OTHERWISE                                                /* @CG */\n          \"BROWSE DATASET('\"RACFSDSN\"')\"                      /* @CG */\n  END                                                         /* @CG */\n  X = MSG(\"ON\")                                               /* @CG */\n                                                              /* @CG */\nRETURN                                                        /* @CG */\n/*--------------------------------------------------------------------*/\n/*  List fully qualified dataset with single quotes              @CL  */\n/*--------------------------------------------------------------------*/\nLIST_FULL_DSN:                                                /* @CL */\n  CMDPRM  = \"DSNS GEN\"                                        /* @CL */\n  CMD     = \"LISTDSD DATASET(\"RFILTER\")\" CMDPRM               /* @CL */\n  X = OUTTRAP(\"CMDREC.\")                                      /* @CL */\n  ADDRESS TSO cmd                                             /* @CL */\n  cmd_rc = rc                                                 /* @CL */\n  X = OUTTRAP(\"OFF\")                                          /* @CL */\n  if (SETMSHOW <> 'NO') then                                  /* @CL */\n     call SHOWCMD                                             /* @CL */\n  call display_info                                           /* @CL */\n  if (cmd_rc > 0) then                                        /* @CL */\n     CALL racfmsgs \"ERR10\" /* Generic failure */              /* @CL */\nRETURN                                                        /* @CL */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RACFEMAC": {"ttr": 919, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\n\\x00V\\x01 \\x04\\x9f\\x01 \\x16?\\x04\\x03\\x00\\x10\\x00\\n\\x00\\x00\\xd9\\xc1\\xc3\\xc6\\xc1\\xc4\\xd4@@@'", "ispf": {"version": "01.10", "flags": 0, "createdate": "2020-02-18T00:00:00", "modifydate": "2020-06-11T04:03:56", "lines": 16, "newlines": 10, "modlines": 0, "user": "RACFADM"}, "text": "/*%NOCOMMENT====================* REXX *==============================*/\n/*  PURPOSE:  RACFADM - Edit Macro - VIEW/EDIT turn off highlighting  */\n/*--------------------------------------------------------------------*/\n/*  NOTES:    1) This edit macro is used by all REXX programs         */\n/*--------------------------------------------------------------------*/\n/* FLG  YYMMDD  USERID   DESCRIPTION                                  */\n/* ---  ------  -------  -------------------------------------------- */\n/* @A3  200303  RACFA    Renamed member to RACFDSPE, was RACFCHGE     */\n/* @A2  200221  RACFA    Make 'ADDRESS ISREDIT' defualt, reduce code  */\n/* @A1  200220  RACFA    Added RESET, to remove messages (==MSG>)     */\n/* @A0  200218  RACFA    Created REXX                                 */\n/*====================================================================*/\nADDRESS ISREDIT                                               /* @A2 */\n  \"MACRO (PARM) NOPROCESS\"\n  \"HI OFF\"\n  \"RESET\"                                                     /* @A1 */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RACFENQS": {"ttr": 921, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01c\\x00)\\x01 \\t/\\x01 \\x17?\\x04G\\x01\\x0e\\x002\\x00\\x00\\xd9\\xc1\\xc3\\xc6\\xc1\\xc4\\xd4@@@'", "ispf": {"version": "01.99", "flags": 0, "createdate": "2020-04-01T00:00:00", "modifydate": "2020-06-21T04:47:29", "lines": 270, "newlines": 50, "modlines": 0, "user": "RACFADM"}, "text": "/*%NOCOMMENT====================* REXX *==============================*/\n/*  PURPOSE:  RACFADM - Enqueues - Menu option E                      */\n/*--------------------------------------------------------------------*/\n/* FLG  YYMMDD  USERID   DESCRIPTION                                  */\n/* ---  ------  -------  -------------------------------------------- */\n/* @AU  200621  RACFA    Shifted over report by 2 characters          */\n/* @AT  200620  RACFA    Reduced lines displayed, less paging down/up */\n/* @AS  200616  RACFA    Chg panel name RACFRPTS to RACFDISP          */\n/* @AR  200611  RACFA    Moved database enqueues to top of list       */\n/* @AQ  200611  RACFA    Added ISPSLIB enqueues                       */\n/* @AP  200520  RACFA    If no ALT/LIBDEF dsns, display RACFDB enques */\n/* @AO  200506  RACFA    Standardize all headers                      */\n/* @AN  200506  RACFA    Display headers in a different color         */\n/* @AM  200429  RACFA    Added a astericks to dsn/enqueues headers    */\n/* @AL  200423  RACFA    Move PARSE REXXPGM name up above IF SETMTRAC */\n/* @AK  200423  RACFA    Place DSN/Enques in flower/comment box       */\n/* @AJ  200423  RACFA    Del 'call racfmsgs ERR19' when rows = 0      */\n/* @AI  200422  RACFA    Ensure the REXX program name is 8 chars      */\n/* @AH  200422  RACFA    Use variable REXXPGM in log msg              */\n/* @AG  200422  RACFA    Remove spaces from RACF database names       */\n/* @AF  200422  RACFA    Display enqueues on RACF backup database     */\n/* @AE  200416  RACFA    Display enqueues on RACF database            */\n/* @AD  200413  RACFA    Take into account, PROFILE MSGID(ON)         */\n/* @AC  200413  RACFA    Del ver word 2 is CLIST, some may be EXEC    */\n/* @AB  200413  RACFA    Added more comments above 'GET_CLIST_DSN'    */\n/* @AA  200413  RACFA    If ALTLIB, not have 'Appl Lev', skip code    */\n/* @A9  200413  RACFA    Get REXX pgm name and use as DD name         */\n/* @A8  200413  RACFA    Chg TRACEing to only display banner (P=Pgms) */\n/* @A7  200412  RACFA    Add enqueues for msgs and REXX dsns          */\n/* @A6  200412  RACFA    Chg TRACE to allow 'L'abels or 'R'esults     */\n/* @A5  200402  RACFA    Chg LRECL=132 to LRECL=80                    */\n/* @A4  200402  RACFA    Issue message if no LIBDEF ISPPLIB dataset   */\n/* @A3  200401  RACFA    Chged edit macro RACFLOGE to RACFEMAC        */\n/* @A2  200401  RACFA    VIEW/EDIT use edit macro, to turn off HILITE */\n/* @A1  200402  RACFA    Dropped array, save memory                   */\n/* @A0  200401  RACFA    Created REXX                                 */\n/*====================================================================*/\nPANEL01     = \"RACFDISP\"   /* Display report with colors   */ /* @AS */\nPANELM2     = \"RACFMSG2\"   /* Display RACF command and RC  */\nEDITMACR    = \"RACFEMAC\"   /* Edit Macro, turn HILITE off  */ /* @A2 */\nQNAME       = \"SYSDSN\"     /* MAJOR resource name for DSNs */\nDDNAME      = 'RACFA'RANDOM(0,999) /* Unique ddname        */ /* @A9 */\nRECENQ.     = \"\"                                              /* @AT */\nCNT         = 0            /* Record counter               */ /* @AT */\nparse source . . REXXPGM .         /* Obtain REXX pgm name */ /* @AL */\nREXXPGM     = LEFT(REXXPGM,8)                                 /* @AL */\n\nADDRESS ISPEXEC\n  \"VGET (SETGDISP SETMSHOW SETMTRAC) PROFILE\"\n  If (SETMTRAC <> 'NO') then do                               /* @A6 */\n     Say \"*\"COPIES(\"-\",70)\"*\"                                 /* @A6 */\n     Say \"*\"Center(\"Begin Program = \"REXXPGM,70)\"*\"           /* @A6 */\n     Say \"*\"COPIES(\"-\",70)\"*\"                                 /* @A6 */\n     if (SETMTRAC <> 'PROGRAMS') THEN                         /* @A8 */\n        interpret \"Trace \"SUBSTR(SETMTRAC,1,1)                /* @A6 */\n  end                                                         /* @A6 */\n\n  call GET_RACF_DBNAMES                                       /* @AR */\n  call Get_enqs \"RACFPRM\"                                     /* @AR */\n  call Get_enqs \"RACFBKP\"                                     /* @AR */\n  call Get_enqs \"CLIST\"                                       /* @A7 */\n  call Get_enqs \"ISPPLIB\"                                     /* @A7 */\n  call Get_enqs \"ISPSLIB\"                                     /* @AQ */\n  call Get_enqs \"ISPMLIB\"                                     /* @A7 */\n\n  QUEUE \"*\"COPIES(\"-\",70)\"*\"                                  /* @AT */\n  QUEUE \"*\"Center(\"RACFADM - Enqueues\",70)\"*\"                 /* @AT */\n  QUEUE \"*\"COPIES(\"-\",70)\"*\"                                  /* @AT */\n  QUEUE \" \"                                                   /* @AT */\n  QUEUE \"   Enqs   \"CENTER(\"Dataset\",44)                      /* @AU */\n  QUEUE \"   ----   \"COPIES(\"-\",44)                            /* @AU */\n  DO J = 1 TO RECENQ.0                                        /* @AT */\n     PARSE VAR RECENQ.J KEY DSN ENQ .                         /* @AT */\n     IF (KEY = \"D\") THEN                                      /* @AT */\n        QUEUE \"   \"RIGHT(ENQ,4)\"   \"LEFT(DSN,44)              /* @AU */\n     IF (KEY = \"E\") THEN DO                                   /* @AT */\n        PARSE VAR RECENQ.J KEY LPAR ENQ USERID NAME           /* @AT */\n        SELECT                                                /* @AT */\n           WHEN (ENQ = \"SHARE\") THEN ENQ = \"SHR\"              /* @AT */\n           WHEN (ENQ = \"EXCLU\") THEN ENQ = \"EXC\"              /* @AT */\n           OTHEWISE NOP                                       /* @AT */\n        END                                                   /* @AT */\n        QUEUE COPIES(\" \",12)LEFT(LPAR,8)\" \",                  /* @AU */\n              ENQ\"  \"LEFT(USERID,8)\" \",                       /* @AT */\n              LEFT(NAME,21)                                   /* @AT */\n     END                                                      /* @AT */\n  END                                                         /* @AT */\n  DROP RECENQ.                                                /* @AT */\n  QUEUE                                                       /* @AT */\n\n  ADDRESS TSO \"ALLOC F(\"DDNAME\") NEW REUSE\",\n              \"LRECL(80) BLKSIZE(0) RECFM(F B)\",              /* @A5 */\n              \"UNIT(VIO) SPACE(1 5) CYLINDERS\"\n  ADDRESS TSO \"EXECIO * DISKW \"DDNAME\" (FINIS\"\n  \"LMINIT DATAID(CMDDATID) DDNAME(\"DDNAME\")\"\n  SELECT\n     WHEN (SETGDISP = \"VIEW\") THEN\n          \"VIEW DATAID(\"CMDDATID\") MACRO(\"EDITMACR\")\",        /* @AN */\n               \"PANEL(\"PANEL01\")\"                             /* @AN */\n     WHEN (SETGDISP = \"EDIT\") THEN\n          \"EDIT DATAID(\"CMDDATID\") MACRO(\"EDITMACR\")\",        /* @AN */\n               \"PANEL(\"PANEL01\")\"                             /* @AN */\n     OTHERWISE\n          \"BROWSE DATAID(\"CMDDATID\")\"\n  END\n  ADDRESS TSO \"FREE FI(\"DDNAME\")\"\n  call Goodbye                                                /* @A6 */\nEXIT\n/*--------------------------------------------------------------------*/\n/*  If tracing is on, display flower box                         @A6  */\n/*--------------------------------------------------------------------*/\nGOODBYE:                                                      /* @A6 */\n  If (SETMTRAC <> 'NO') then do                               /* @A6 */\n     Say \"*\"COPIES(\"-\",70)\"*\"                                 /* @A6 */\n     Say \"*\"Center(\"End Program = \"REXXPGM,70)\"*\"             /* @A6 */\n     Say \"*\"COPIES(\"-\",70)\"*\"                                 /* @A6 */\n  end                                                         /* @A6 */\nEXIT                                                          /* @A6 */\n/*--------------------------------------------------------------------*/\n/*  Obtain enqueues on datasets                                  @A7  */\n/*--------------------------------------------------------------------*/\nGET_ENQS:                                                     /* @A7 */\n  PARSE ARG DDQLIB                                            /* @A7 */\n  SELECT                                                      /* @AE */\n     WHEN (DDQLIB = \"CLIST\") THEN                             /* @AE */\n          CALL GET_CLIST_DSN                                  /* @A7 */\n     WHEN (DDQLIB = \"RACFPRM\") THEN DO                        /* @AF */\n          DSNAME = PRMDBASE                                   /* @AF */\n          RC = 0                                              /* @AF */\n          if (dsname = \"\") THEN                               /* @AF */\n             RC = 8                                           /* @AF */\n     END                                                      /* @AF */\n     WHEN (DDQLIB = \"RACFBKP\") THEN DO                        /* @AF */\n          DSNAME = BKPDBASE                                   /* @AF */\n          RC = 0                                              /* @AF */\n          if (dsname = \"\") THEN                               /* @AF */\n             RC = 8                                           /* @AF */\n     END                                                      /* @AF */\n     OTHERWISE                                                /* @AE */\n          \"QLIBDEF \"DDQLIB\" TYPE(DATASET) ID(DSNAME)\"         /* @A7 */\n  END                                                         /* @AE */\n  if (RC > 0) then do                                         /* @A4 */\n     call racfmsgs ERR19                                      /* @A4 */\n     return                                                   /* @A7 */\n  end                                                         /* @A6 */\n\n  ROWS  = 0\n  RNAME = STRIP(DSNAME,,\"'\")\n  \"QUERYENQ TABLE(ENQTBL) QNAME(QNAME) RNAME(RNAME) XSYS\"\n  QUERYRC = RC\n  IF (QUERYRC <> 8) THEN DO                                   /* @AE */\n     \"TBTOP   \"ENQTBL\n     \"TBQUERY \"ENQTBL\" ROWNUM(ROWS)\"\n  END                                                         /* @AE */\n\n  IF (ROWS = 0) THEN DO                                       /* @A7 */\n     IF (QUERYRC <> 8) THEN                                   /* @AE */\n        \"TBCLOSE \"ENQTBL                                      /* @A7 */\n     CNT = CNT + 1                                            /* @AT */\n     RECENQ.CNT = \"D \"RNAME\" 0\"                               /* @AT */\n     RECENQ.0 = CNT                                           /* @AT */\n     RETURN                                                   /* @A7 */\n  END                                                         /* @A7 */\n  ELSE DO                                                     /* @A7 */\n     CNT         = CNT + 1                                    /* @AT */\n     RECENQ.CNT = \"D \"RNAME\" \"strip(rows,'L',0)               /* @AT */\n\n     DO J = 1 TO ROWS\n        \"TBSKIP \"ENQTBL\n        \"TBGET  \"ENQTBL\n        cmd = \"LU \"ZENJOB\n        X = OUTTRAP(\"CMDREC.\")\n        ADDRESS TSO cmd\n        cmd_rc = rc\n        if (SETMSHOW <> 'NO') then\n           call SHOWCMD\n        if (cmd_rc > 0) then\n           Luname = \"\"\n        else\n           parse var cmdrec.1 . \"NAME=\"luname \"OWNER=\" .\n        X = OUTTRAP(\"OFF\")\n        CNT = CNT + 1                                         /* @AT */\n        RECENQ.CNT = \"E \"ZENSYST\" \"ZENDISP,                   /* @AT */\n                     ZENJOB\" \"LUNAME                          /* @AT */\n     END\n  END\n  RECENQ.0 = CNT                                              /* @AT */\n  \"TBCLOSE \"ENQTBL\n  DROP CMDREC.                                                /* @A1 */\nRETURN                                                        /* @A7 */\n/*--------------------------------------------------------------------*/\n/*  Get CLIST dataset name                                       @A7  */\n/*--------------------------------------------------------------------*/\n/*  1) The 'ALTLIB DISPLAY' statement, will look for                  */\n/*     'Application-level' in the display in order to obtain          */\n/*     the DDname of the ALTLIBed dataset                             */\n/*       Current search order (by DDNAME) is:                         */\n/*       Application-level CLIST DDNAME=SYS00529                      */\n/*       System-level EXEC       DDNAME=SYSEXEC                       */\n/*       System-level CLIST      DDNAME=SYSPROC                       */\n/*  2) The 'LISTA STATUS' will display all the DDnames and datasets   */\n/*     allocated, allowing the capability to obtain the dataset name  */\n/*     allocated to the 'Application-level CLIST' ddname (SYS#####)   */\n/*--------------------------------------------------------------------*/\nGET_CLIST_DSN:                                                /* @A7 */\nADDRESS TSO                                                   /* @A7 */\n  X = OUTTRAP(\"RECALT.\")                                      /* @A7 */\n  \"ALTLIB DISPLAY\"                                            /* @A7 */\n  X = OUTTRAP(\"OFF\")                                          /* @A7 */\n                                                              /* @A7 */\n  IF (SUBSTR(RECALT.2,1,3) = \"IKJ\") THEN                      /* @AD */\n     PARSE VAR RECALT.2 . W1 W2 \"DDNAME=\"DDALTLIB             /* @AD */\n  ELSE                                                        /* @AD */\n     PARSE VAR RECALT.2 W1 W2 \"DDNAME=\"DDALTLIB               /* @A7 */\n  DROP RECALT.                                                /* @A7 */\n  RC = 0                                                      /* @AA */\n  IF (W1 <> \"Application-level\") THEN DO                      /* @AC */\n     RC = 8                                                   /* @AA */\n     return                                                   /* @A7 */\n  END                                                         /* @AA */\n                                                              /* @A7 */\n  X = OUTTRAP(\"RECLA.\")                                       /* @A7 */\n  \"LISTA STATUS\"                                              /* @A7 */\n  X = OUTTRAP(\"OFF\")                                          /* @A7 */\n  do J = 1 TO RECLA.0                                         /* @A7 */\n     PARSE VAR RECLA.J W1 .                                   /* @A7 */\n     IF (W1 = DDALTLIB) THEN DO                               /* @A7 */\n        K = J - 1                                             /* @A7 */\n        DSNAME = RECLA.K                                      /* @A7 */\n        LEAVE                                                 /* @A7 */\n     END                                                      /* @A7 */\n  end                                                         /* @A7 */\n  DROP RECLA. W1 DDALTLIB                                     /* @A7 */\nADDRESS ISPEXEC                                               /* @A7 */\nRETURN                                                        /* @A7 */\n/*--------------------------------------------------------------------*/\n/*  Display RACF command and return code                              */\n/*--------------------------------------------------------------------*/\nSHOWCMD:\n  IF (SETMSHOW = \"BOTH\") | (SETMSHOW = \"DISPLAY\") THEN DO\n     PARSE VAR CMD MSG1 60 MSG2 121 MSG3\n     MSG4 = \"Return code = \"cmd_rc\n     \"ADDPOP ROW(6) COLUMN(4)\"\n     \"DISPLAY PANEL(\"PANELM2\")\"\n     \"REMPOP\"\n  END\n  IF (SETMSHOW = \"BOTH\") | (SETMSHOW = \"LOG\") THEN DO\n     zerrsm = \"RACFADM \"REXXPGM\" RC=\"cmd_rc                   /* @AH */\n     zerrlm = cmd\n     'log msg(isrz003)'\n  END\nRETURN\n/*--------------------------------------------------------------------*/\n/*  Get RACF primary and backup database names                   @AF  */\n/*--------------------------------------------------------------------*/\nGET_RACF_DBNAMES:                                             /* @AE */\n  CVT      = C2X(STORAGE(10,4))           /* Pointer to CVT          */\n  RCVT     = D2X(X2D(CVT) +X2D(3E0))      /* Pointer to RCVT pointer */\n  RCVT     = C2X(STORAGE(RCVT,4))         /* Pointer to RCVT         */\n  DSDT     = D2X(X2D(RCVT) + X2D(E0))     /* Pointer to DSDT pointer */\n  DSDT     = C2X(STORAGE(DSDT,4))         /* Pointer to DSDT         */\n  DSDTNUM  = D2X(X2D(DSDT) + X2D(4))      /* Address of DSDTNUM      */\n  DSDTNUM  = C2D(STORAGE(DSDTNUM,4))      /* DSDTNUM                 */\n  DSDTPRIM = D2X(X2D(DSDT) + X2D(90))     /* Address of 1st Prim DSN */\n  DSDTBACK = D2X(X2D(DSDT) + X2D(140))    /* Address of 1st Bkup DSN */\n  PNAME    = D2X(X2D(DSDTPRIM) + X2D(21)) /* Addr of primary name    */\n  PRMDBASE = STRIP(STORAGE(PNAME,44))     /* Primary name        @AG */\n  BNAME    = D2X(X2D(DSDTBACK) + X2D(21)) /* Addr of backup name     */\n  BKPDBASE = STRIP(STORAGE(BNAME,44))     /* Backup name         @AG */\nRETURN                                                        /* @AE */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RACFGRP": {"ttr": 965, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\n\\x00\\x01\\x01 \\x18\\x8f\\x01 3\\x8f\\x12\\x19\\x04\\x80\\x04{\\x00\\x00\\xd9\\xc1\\xc3\\xc6\\xc1\\xc4\\xd4@@@'", "ispf": {"version": "01.10", "flags": 0, "createdate": "2020-07-06T00:00:00", "modifydate": "2020-12-03T12:19:01", "lines": 1152, "newlines": 1147, "modlines": 0, "user": "RACFADM"}, "text": "/*%NOCOMMENT====================* REXX *==============================*/\n/*  PURPOSE:  RACFADM - Group Profiles - Menu option 2                */\n/*--------------------------------------------------------------------*/\n/* FLG  YYMMDD  USERID   DESCRIPTION                                  */\n/* ---  ------  -------  -------------------------------------------- */\n/* @CZ  201201  RACFA    Unhide line command 'X' for ADMIN users      */\n/* @CY  201130  TRIDJK   Added hidden line command 'X'                */\n/* @CV  200708  TRIDJK   Msg if selection list has no entries ('NONE')*/\n/* @CU  200618  RACFA    Chged SYSDA to SYSALLDA                      */\n/* @CT  200617  RACFA    Added comments to right of variables         */\n/* @CS  200616  RACFA    Fix OWNER, was including CREATED date        */\n/* @CR  200616  RACFA    Added capability to SAve file as TXT/CSV     */\n/* @CQ  200610  RACFA    Added primary command 'SAVE'                 */\n/* @CP  200608  RACFA    Fix, F3 (END) out of search panel            */\n/* @CO  200604  RACFA    Fix, prevent from going to top of table      */\n/* @CN  200527  RACFA    Fix, allow typing 'S' on multiple rows       */\n/* @CM  200520  RACFA    Display line cmd 'P'rofile, when 'Admin=N'   */\n/* @CL  200506  RACFA    Drop array immediately when done using       */\n/* @CK  200504  TRIDJK   Adding, place in order, prior was at bottom  */\n/* @CJ  200502  RACFA    Re-worked displaying tables, use DO FOREVER  */\n/* @CI  200501  RACFA    Fixed F3 (END) out of panel RACFGRP8         */\n/* @CH  200501  LBD      Add primary commands FIND/RFIND              */\n/* @CG  200430  RACFA    Chg tblb to TABLEB, moved def. var. up top   */\n/* @CF  200430  RACFA    Chg tbla to TABLEA, moved def. var. up top   */\n/* @CE  200429  RACFA    Re-arranged variables (General, Mgmt, TSO)   */\n/* @CD  200424  RACFA    Updated RESET, pass filter, ex: R filter     */\n/* @CA  200424  RACFA    Chg msg RACF013 to RACF012                   */\n/* @C9  200424  RACFA    Move DDNAME at top, standardize/del dups     */\n/* @C8  200423  RACFA    Move PARSE REXXPGM name up above IF SETMTRAC */\n/* @C7  200423  RACFA    'Status Interval' by percentage (SETGSTAP)   */\n/* @C6  200423  TRIDJK   Change ACC to '', when no rows               */\n/* @C5  200422  RACFA    Ensure the REXX program name is 8 chars      */\n/* @C4  200422  RACFA    Use variable REXXPGM in log msg              */\n/* @C3  200417  RACFA    Changed date to 'U'SA, was 'O'rdered         */\n/* @C2  200417  TRIDJK   Added 'Created' date                         */\n/* @C1  200413  RACFA    Chg TRACEing to only display banner (P=Pgms) */\n/* @BZ  200412  RACFA    Chg TRACE to allow 'L'abels or 'R'esults     */\n/* @BY  200410  RACFA    Do not display 'Segment' or 'Command'        */\n/* @BX  200410  RACFA    If id = 'None' only allow line cmd 'A'dd     */\n/* @BW  200407  RACFA    EXCMD removed 'else msg_var = 1 to msg.0'    */\n/* @BV  200406  RACFA    Remove spaces between sub-groups             */\n/* @BU  200406  RACFA    Added 'NONE' to subgroups when NO SUBGROUPS  */\n/* @BT  200406  TRIDJK   Added subgroups to RACFGRP5 panel            */\n/* @BS  200404  RACFA    'Admin RACF API = Y' then display 'P'rofile  */\n/* @BR  200402  RACFA    Chg LRECL=132 to LRECL=80                    */\n/* @BQ  200401  RACFA    Create subroutine to VIEW/EDIT/BROWSE        */\n/* @BP  200401  RACFA    Chged edit macro RACFLOGE to RACFEMAC        */\n/* @BO  200401  RACFA    VIEW/EDIT use edit macro, to turn off HILITE */\n/* @BN  200331  RACFA    Fix SORT order, ex line cmd and no TURQ      */\n/* @BM  200330  RACFA    Chg RACFGRP5 point/shoot ascending/descending*/\n/* @BL  200330  RACFA    Allow point-n-shoot sort ascending/descending*/\n/* @BK  200324  RACFA    Allow both display/logging of RACF commands  */\n/* @BJ  200324  RACFA    Allow logging RACF commands to ISPF Log file */\n/* @BI  200315  RACFA    Added line cmd 'P' for RACFGRP5 panel        */\n/* @BH  200315  RACFA    Placed 'P-Prof' next to other list commands  */\n/* @BG  200315  RACFA    Renamed RACFGRPP to RACFPROF, in 2nd SELECT  */\n/* @BF  200315  RACFA    Renamed RACFGRPP to RACFPROF                 */\n/* @BE  200313  RACFA    Del XPROF subroutine, call RACFGRPP directly */\n/* @BD  200313  RACFA    Renamed RACFGHPS to RACFGRPP (P-Profile)     */\n/* @BC  200313  TRIDJK   Add Supgrp and Owner to group list           */\n/* @BB  200303  RACFA    Del 'ret_code = rc', not referenced          */\n/* @BA  200303  RACFA    Chg 'RL class ALL' to 'RL class * ALL'       */\n/* @B9  200302  RACFA    Chk RC 'LU id prms', if RC>0 then 'LU id'    */\n/* @B8  200303  RACFA    Fixed chking RC after executing command      */\n/* @B7  200302  RACFA    Chk RC 'LG grp prms', if RC>0 then 'LG grp'  */\n/* @B6  200302  RACFA    Del TBTOP cmd, prior to TBSCAN for LOCATE    */\n/* @B5  200301  RACFA    Del EMSG procedure, instead call RACFMSGS    */\n/* @B4  200228  RACFA    Do not display User=No, Access=Command       */\n/* @B3  200228  RACFA    Check for 'NO ENTRIES MEET SEARCH CRITERIA'  */\n/* @B2  200226  RACFA    Fix @AZ chg, chg ret_code to cmd_rc          */\n/* @B1  200226  RACFA    Added 'CONTROL ERRORS RETURN'                */\n/* @AZ  200226  RACFA    Added 'Return Code =' when displaying cmd    */\n/* @AY  200226  RACFA    Removed double quotes before/after cmd       */\n/* @AX  200224  RACFA    Standardize quotes, chg single to double     */\n/* @AW  200224  RACFA    Place panels at top of REXX in variables     */\n/* @AV  200223  RACFA    Del 'address TSO \"PROFILE MSGID\"', not needed*/\n/* @AU  200223  RACFA    Simplified SORT, removed FLD/DFL_SORT vars   */\n/* @AT  200222  RACFA    Allowing abbreviating the column in SORT cmd */\n/* @AS  200222  RACFA    Removed translating OPTA/B, not needed       */\n/* @AR  200222  RACFA    Allow placing cursor on row and press ENTER  */\n/* @AQ  200221  RACFA    Removed \"G = '(G)'\", not referenced          */\n/* @AP  200221  LBD      Add ONLY primary command                     */\n/* @AO  200221  RACFA    Make 'ADDRESS ISPEXEC' defualt, reduce code  */\n/* @AN  200220  RACFA    Fixed displaying all RACF commands           */\n/* @AM  200220  RACFA    Added SETMTRAC=YES, then TRACE R             */\n/* @AL  200220  RACFA    Removed initializing SETGSTA variable        */\n/* @AK  200220  RACFA    Added capability to browse/edit/view file    */\n/* @AJ  200218  RACFA    Use dynamic area to display SELECT commands  */\n/* @AI  200218  RACFA    Added 'Status Interval' option               */\n/* @AH  200216  RACFA    Chg color to turq/green, was white/turq      */\n/* @AG  200207  RACFA    Fix color of sort col, when F3, diff. id     */\n/* @AF  200207  RACFA    Fix SORT, place at top of table              */\n/* @AE  200207  RACFA    Fix RESET, was not placing at top of table   */\n/* @AD  200207  RACFA    Fix LOCATE, not working when sort descending */\n/* @AC  200206  TRIDJK   Allow A/D in SORT command                    */\n/* @AB  200123  RACFA    Retrieve default filter, Option 0 - Settings */\n/* @AA  200122  RACFA    Del TBTOP placed in by change @A3            */\n/* @A9  200122  TRIDJK   Test/del MFA option from 'LU userid' command */\n/* @A8  200120  RACFA    Removed 'say msg.msg_var' in EXCMD procedure */\n/* @A7  200119  RACFA    Standardized/reduced lines of code           */\n/* @A6  200119  RACFA    Added comment box above procedures           */\n/* @A5  200118  RACFA    Added line command 'L', list userid          */\n/* @A4  200116  RACFA    Changed colors, White/Turq, was Turq/Blue    */\n/* @A3  200115  RACFA    Add SORT/LOCATE/RESET commands               */\n/* @A2  200113  RACFA    Add alloc/exec/free, instead of RACFLIST     */\n/* @A1  200110  RACFA    Invoke RACFLIST when displaying a userid     */\n/* @A0  011229  NICORIZ  Created REXX, V2.1, www.rizzuto.it           */\n/*====================================================================*/\nPANEL01     = \"RACFGRP1\"   /* Set filter, menu option 2    */ /* @AW */\nPANEL02     = \"RACFGRP2\"   /* Add group                    */ /* @AW */\nPANEL04     = \"RACFGRP4\"   /* Alter profile                */ /* @AW */\nPANEL05     = \"RACFGRP5\"   /* List userids and access      */ /* @AW */\nPANEL06     = \"RACFGRP6\"   /* Change connection            */ /* @AW */\nPANEL07     = \"RACFGRP7\"   /* Add connection               */ /* @AW */\nPANEL08     = \"RACFGRP8\"   /* List groups and descriptions */ /* @AW */\nPANELM1     = \"RACFMSG1\"   /* Confirm Request (pop-up)     */ /* @AW */\nPANELM2     = \"RACFMSG2\"   /* Display RACF command and RC  */ /* @AW */\nPANELS1     = \"RACFSAVE\"   /* Obtain DSName to SAVE        */ /* @CQ */\nSKELETON1   = \"RACFGRP8\"   /* Save tablea to dataset       */ /* @CQ */\nSKELETON2   = \"RACFGRP5\"   /* Save tableb to dataset       */ /* @CQ */\nEDITMACR    = \"RACFEMAC\"   /* Edit Macro, turn HILITE off  */ /* @BO */\nTABLEA      = 'TA'RANDOM(0,99999)  /* Unique table name A  */ /* @CF */\nTABLEB      = 'TB'RANDOM(0,99999)  /* Unique table name B  */ /* @CG */\nDDNAME      = 'RACFA'RANDOM(0,999) /* Unique ddname        */ /* @C9 */\nparse source . . REXXPGM .         /* Obtain REXX pgm name */ /* @C8 */\nREXXPGM     = LEFT(REXXPGM,8)                                 /* @C8 */\nNULL        = ''                                              /* @CH */\n\nADDRESS ISPEXEC                                               /* @AO */\n  Rclass = 'GROUP'\n  Arg Rfilter\n  If (Rfilter = '') Then Do                                   /* @AB */\n     \"VGET (SETGFLTR) PROFILE\"                                /* @AB */\n     Rfilter = SETGFLTR                                       /* @AB */\n  end                                                         /* @AB */\n\n  \"CONTROL ERRORS RETURN\"                                     /* @B1 */\n  \"VGET (SETGSTA  SETGSTAP SETGDISP SETMADMN\",                /* @CE */\n        \"SETMIRRX SETMSHOW SETMTRAC) PROFILE\"                 /* @CE */\n\n  If (SETMTRAC <> 'NO') then do                               /* @BZ */\n     Say \"*\"COPIES(\"-\",70)\"*\"                                 /* @BZ */\n     Say \"*\"Center(\"Begin Program = \"REXXPGM,70)\"*\"           /* @BZ */\n     Say \"*\"COPIES(\"-\",70)\"*\"                                 /* @BZ */\n     if (SETMTRAC <> 'PROGRAMS') THEN                         /* @C1 */\n        interpret \"Trace \"SUBSTR(SETMTRAC,1,1)                /* @BZ */\n  end\n\n  If (SETMADMN = \"YES\") then                                  /* @B2 */\n     If (SETMIRRX = \"YES\") then                               /* @BS */\n        SELCMDS = \"[S]Show,[L]List,[P]Profile,\"||,            /* @BH */\n                  \"[C]Change,[A]Add,\"||,                      /* @BH */\n                  \"[R]Remove,[X]Xref\"                         /* @CZ */\n     Else                                                     /* @BS */\n        SELCMDS = \"[S]Show,[L]List,\"||,                       /* @BS */\n                  \"[C]Change,[A]Add,\"||,                      /* @BS */\n                  \"[R]Remove,[X]Xref\"                         /* @CZ */\n  else do                                                     /* @CM */\n     If (SETMIRRX = \"YES\") then                               /* @CM */\n        SELCMDS = \"[S]Show,[L]list,[P]Profile\"                /* @CM */\n     else                                                     /* @CM */\n        SELCMDS = \"[S]Show,[L]list\"                           /* @AJ */\n  end                                                         /* @CM */\n\n  rlv    = SYSVAR('SYSLRACF')\n  called = SYSVAR('SYSNEST')\n  If (called = 'YES') then \"CONTROL NONDISPL ENTER\"\n\n  \"DISPLAY PANEL(\"PANEL01\")\" /* get profile filter */         /* @AW */\n  Do while (rc < 8)                                           /* @CI */\n     call Profl\n     If (called <> 'YES') then\n        \"DISPLAY PANEL(\"PANEL01\")\"                            /* @AW */\n  end\n\n  If (SETMTRAC <> 'NO') then do                               /* @BZ */\n     Say \"*\"COPIES(\"-\",70)\"*\"                                 /* @BZ */\n     Say \"*\"Center(\"End Program = \"REXXPGM,70)\"*\"             /* @BZ */\n     Say \"*\"COPIES(\"-\",70)\"*\"                                 /* @BZ */\n  end                                                         /* @BZ */\nEXIT\n/*--------------------------------------------------------------------*/\n/*  Show all profiles for a filter                                    */\n/*--------------------------------------------------------------------*/\nPROFL:\n  call CREATE_TABLEA                                          /* @AP */\n  if (group = 'INVALID') | (group = 'NONE') then do           /* @CV */\n     \"TBEND\" tbla\n     call racfmsgs 'ERR16'                                    /* @C5 */\n     rc=8                                                     /* @CV */\n     return\n  end\n  opta   = ' '                                                /* @CJ */\n  xtdtop = 0                                                  /* @CJ */\n  rsels  = 0                                                  /* @CJ */\n  do forever                                                  /* @CJ */\n     if (rsels < 2) then do                                   /* @CJ */\n        \"TBTOP  \" TABLEA                                      /* @CJ */\n        'tbskip' tablea 'number('xtdtop')'                    /* @CJ */\n        radmrfnd = 'PASSTHRU'                                 /* @CJ */\n        'vput (radmrfnd)'                                     /* @CJ */\n        \"TBDISPL\" TABLEA \"PANEL(\"PANEL08\")\"                   /* @CJ */\n     end                                                      /* @CJ */\n     else 'tbdispl' tablea                                    /* @CJ */\n     if (rc > 4) then leave                                   /* @CP */\n     xtdtop   = ztdtop                                        /* @CJ */\n     rsels    = ztdsels                                       /* @CJ */\n     radmrfnd = null                                          /* @CJ */\n     'vput (radmrfnd)'                                        /* @CJ */\n     PARSE VAR ZCMD ZCMD PARM SEQ                             /* @CJ */\n     IF (SROW <> \"\") & (SROW <> 0) THEN                       /* @AR */\n        IF (SROW > 0) THEN DO                                 /* @AR */\n           \"TBTOP \" TABLEA                                    /* @AR */\n           \"TBSKIP\" TABLEA \"NUMBER(\"SROW\")\"                   /* @AR */\n        END                                                   /* @AR */\n     if (zcmd = 'RFIND') then do                              /* @CH */\n        zcmd = 'FIND'                                         /* @CH */\n        parm = findit                                         /* @CH */\n        'tbtop ' TABLEA                                       /* @CH */\n        'tbskip' TABLEA 'number('last_find')'                 /* @CH */\n     end                                                      /* @CH */\n     Select\n        When (abbrev(\"FIND\",zcmd,1) = 1) then                 /* @CH */\n             call do_finda                                    /* @CH */\n        WHEN (ABBREV(\"LOCATE\",ZCMD,1) = 1) THEN do            /* @CJ */\n             if (parm <> '') then do                          /* @CJ */\n                locarg = parm'*'                              /* @CJ */\n                PARSE VAR SORT . \",\" . \",\" SEQ                /* @CJ */\n                IF (SEQ = \"D\") THEN                           /* @CJ */\n                   CONDLIST = \"LE\"                            /* @CJ */\n                ELSE                                          /* @CJ */\n                   CONDLIST = \"GE\"                            /* @CJ */\n                parse value sort with scan_field',' .         /* @CJ */\n                interpret scan_field ' = locarg'              /* @CJ */\n                'tbtop ' tablea                               /* @CJ */\n                \"TBSCAN \"TABLEA\" ARGLIST(\"scan_field\")\",      /* @CJ */\n                        \"CONDLIST(\"CONDLIST\")\",               /* @CJ */\n                        \"position(scanrow)\"                   /* @CJ */\n                xtdtop = scanrow                              /* @CJ */\n             end                                              /* @CJ */\n        end\n        WHEN (ABBREV(\"ONLY\",ZCMD,1) = 1) THEN DO              /* @AP */\n             find_str = translate(parm)                       /* @AP */\n             'tbtop ' TABLEA                                  /* @AP */\n             'tbskip' TABLEA                                  /* @AP */\n             do forever                                       /* @AP */\n                str = translate(group supgrp owner data)      /* @BC */\n                if (pos(find_str,str) > 0) then nop           /* @AP */\n                else 'tbdelete' TABLEA                        /* @AP */\n                'tbskip' TABLEA                               /* @AP */\n                if (rc > 0) then do                           /* @AP */\n                   'tbtop' TABLEA                             /* @AP */\n                   leave                                      /* @AP */\n                end                                           /* @AP */\n             end                                              /* @AP */\n        END                                                   /* @AP */\n        WHEN (ABBREV(\"RESET\",ZCMD,1) = 1) THEN DO             /* @AE */\n             if (parm <> '') then                             /* @CD */\n                rfilter = parm                                /* @CD */\n             xtdtop   = 1                                     /* @AE */\n             \"TBEND\" TABLEA                                   /* @BL */\n             call CREATE_TABLEA                               /* @AP */\n        END                                                   /* @AE */\n        When (abbrev(\"SAVE\",zcmd,2) = 1) then DO              /* @CQ */\n             TMPSKELT = SKELETON1                             /* @CQ */\n             call do_SAVE                                     /* @CQ */\n        END                                                   /* @CQ */\n        WHEN (ABBREV(\"SORT\",ZCMD,1) = 1) THEN DO              /* @AF */\n             SELECT                                           /* @A3 */\n                when (ABBREV(\"GROUP\",PARM,1) = 1) then        /* @AT */\n                     call sortseq 'GROUP'                     /* @BL */\n                when (ABBREV(\"SUPGRP\",PARM,1) = 1) then       /* @BC */\n                     call sortseq 'SUPGRP'                    /* @BL */\n                when (ABBREV(\"OWNER\",PARM,1) = 1) then        /* @BC */\n                     call sortseq 'OWNER'                     /* @BL */\n                when (ABBREV(\"DESCRIPTION\",PARM,1) = 1) then  /* @AT */\n                     call sortseq 'DATA'                      /* @BL */\n                otherwise NOP                                 /* @A3 */\n             END                                              /* @A3 */\n             PARSE VAR SORT LOCARG \",\" .                      /* @CJ */\n             CLRGROU = \"GREEN\"; CLRDATA = \"GREEN\"             /* @CJ */\n             CLRSUPG = \"GREEN\"; CLROWNE = \"GREEN\"             /* @CJ */\n             INTERPRET \"CLR\"SUBSTR(LOCARG,1,4)\" = 'TURQ'\"     /* @CJ */\n             \"TBSORT\" TABLEA \"FIELDS(\"sort\")\"                 /* @CJ */\n             \"TBTOP \" TABLEA                                  /* @CJ */\n        END                                                   /* @AF */\n        otherwise NOP\n     End  /* Select */\n     ZCMD = \"\"; PARM = \"\"                                     /* @CJ */\n     'control display save'                                   /* @CJ */\n     Select\n        when (opta = 'A') then call Addd\n        when (opta = 'C') then call Chgd\n        when (opta = 'L') then call Lisd\n        when (opta = 'X') then Call RACFUSRX group JCC        /* @CY */\n        when (opta = 'P') then                                /* @BE */\n             call RACFPROF 'GROUP' group                      /* @BF */\n        when (opta = 'R') then call Deld\n        when (opta = 'S') then call Disd\n        otherwise nop\n     End /* Select */\n     'control display restore'                                /* @CJ */\n  end  /* Do forever) */                                      /* @CJ */\nRETURN\n/*--------------------------------------------------------------------*/\n/*  Process primary command FIND for TABLEA                      @CH  */\n/*--------------------------------------------------------------------*/\nDO_FINDA:                                                     /* @CH */\n  if (parm = null) then do                                    /* @CH */\n     racfsmsg = 'Error'                                       /* @CH */\n     racflmsg = 'Find requires a value to search for.' ,      /* @CH */\n                'Try again.'                                  /* @CH */\n     'setmsg msg(RACF011)'                                    /* @CH */\n     return                                                   /* @CH */\n  end                                                         /* @CH */\n  findit    = translate(parm)                                 /* @CH */\n  last_find = 0                                               /* @CH */\n  wrap      = 0                                               /* @CH */\n  do forever                                                  /* @CH */\n     'tbskip' TABLEA                                          /* @CH */\n     if (rc > 0) then do                                      /* @CH */\n        if (wrap = 1) then do                                 /* @CH */\n           racfsmsg = 'Not Found'                             /* @CH */\n           racflmsg = findit 'not found.'                     /* @CH */\n           'setmsg msg(RACF011)'                              /* @CH */\n           return                                             /* @CH */\n        end                                                   /* @CH */\n        if (wrap = 0) then wrap = 1                           /* @CH */\n        'tbtop' TABLEA                                        /* @CH */\n     end                                                      /* @CH */\n     else do                                                  /* @CH */\n        testit = translate(group supgrp owner data)           /* @CH */\n        if (pos(findit,testit) > 0) then do                   /* @CH */\n           'tbquery' TABLEA 'position(srow)'                  /* @CH */\n           'tbtop'   TABLEA                                   /* @CH */\n           'tbskip'  TABLEA 'number('srow')'                  /* @CH */\n           last_find = srow                                   /* @CH */\n           xtdtop    = srow                                   /* @CH */\n           if (wrap = 0) then                                 /* @CH */\n              racfsmsg = 'Found'                              /* @CH */\n           else                                               /* @CH */\n              racfsmsg = 'Found/Wrapped'                      /* @CH */\n           racflmsg = findit 'found in row' srow + 0          /* @CH */\n           'setmsg msg(RACF011)'                              /* @CH */\n           return                                             /* @CH */\n        end                                                   /* @CH */\n     end                                                      /* @CH */\n  end                                                         /* @CH */\nRETURN                                                        /* @CH */\n/*--------------------------------------------------------------------*/\n/*  Define sort sequence, to allow point-n-shoot sorting (A/D)   @BL  */\n/*--------------------------------------------------------------------*/\nSORTSEQ:                                                      /* @BL */\n  parse arg sortcol                                           /* @BL */\n  INTERPRET \"TMPSEQ = SORT\"substr(SORTCOL,1,4)                /* @BL */\n  select                                                      /* @BL */\n     when (seq <> \"\") then do                                 /* @BL */\n          if (seq = 'A') then                                 /* @BL */\n             tmpseq = 'D'                                     /* @BL */\n          else                                                /* @BL */\n             tmpseq = 'A'                                     /* @BL */\n          sort = sortcol',C,'seq                              /* @BL */\n     end                                                      /* @BL */\n     when (seq = \"\"),                                         /* @BL */\n        & (tmpseq = 'A') then do                              /* @BL */\n           sort   = sortcol',C,A'                             /* @BL */\n           tmpseq = 'D'                                       /* @BL */\n     end                                                      /* @BL */\n     Otherwise do                                             /* @BL */\n        sort   = sortcol',C,D'                                /* @BL */\n        tmpseq = 'A'                                          /* @BL */\n     end                                                      /* @BL */\n  end                                                         /* @BL */\n  INTERPRET \"SORT\"SUBSTR(SORTCOL,1,4)\" = TMPSEQ\"              /* @BL */\nRETURN                                                        /* @BL */\n/*--------------------------------------------------------------------*/\n/*  Add new profile                                                   */\n/*--------------------------------------------------------------------*/\nADDD:\n  new = 'NO'\n  if (group = 'NONE') then\n     new ='YES'\n  else\n     CALL Getd\n  \"DISPLAY PANEL(\"PANEL02\")\"                                  /* @AW */\n  if (rc > 0) then\n     return\n  xtr = ' '\n  if (data <> ' ') then\n     xtr = xtr \"DATA('\"data\"')\"\n  call EXCMD \"AG (\"group\") OWNER(\"owner\")\",\n             \"SUPGROUP(\"supgrp\")\" xtr\n  if (cmd_rc > 0) then do                                     /* @BA */\n     CALL racfmsgs 'ERR01' /* Add failed */                   /* @B5 */\n     return\n  end\n  \"TBMOD\" TABLEA \"ORDER\"                                      /* @CK */\n  if (new = 'YES') then do\n     group = 'NONE'\n     \"TBDELETE\"  TABLEA\n  end\nRETURN\n/*--------------------------------------------------------------------*/\n/*  Add new profile                                                   */\n/*--------------------------------------------------------------------*/\nCHGD:\n  if (group = 'NONE') then\n     return\n  CALL Getd\n  \"DISPLAY PANEL(\"PANEL04\")\"                                  /* @AW */\n  if (rc > 0) then return\n  xtr = ' '\n  if (data <> ' ') then do\n     if data = 'NONE' then\n        data = ' '\n     xtr = xtr \"DATA('\"DATA\"')\"\n  end\n  call EXCMD \"ALG (\"group\") OWNER(\"OWNER\")\",\n             \"SUPGROUP(\"SUPGRP\")\" xtr\n  if (cmd_rc > 0) then                                        /* @BA */\n     call racfmsgs 'ERR07' /* Altgroup failed */              /* @B5 */\n  else\n     \"TBMOD\" TABLEA\nRETURN\n/*--------------------------------------------------------------------*/\n/*  Delete profile                                                    */\n/*--------------------------------------------------------------------*/\nDELD:\n  if (group = 'NONE') then\n     return\n  msg    = 'You are about to delete 'group\n  Sure_? = Confirm_delete(msg)\n  if (sure_? = 'YES') then do\n     call EXCMD \"DG (\"group\")\"\n     if (cmd_rc = 0) then                                     /* @BA */\n        \"TBDELETE\" TABLEA\n     else\n       CALL racfmsgs \"ERR02\" /* RDELETE failed */             /* @B5 */\n  end\nRETURN\n/*--------------------------------------------------------------------*/\n/*  Display profile permits                                           */\n/*--------------------------------------------------------------------*/\nDISD:\n  if (group = 'NONE') then\n     return\n  tmpsort   = sort                                            /* @BM */\n  tmprsels  = rsels                                           /* @CN */\n  tmpxtdtop = xtdtop                                          /* @CO */\n  Do until (RB = 'NO')   /* allow rebuild option to loop */\n     call create_TABLEB                                       /* @BM */\n     rb   = 'NO'\n     drop rownum\n     \"TBQUERY\" TABLEB \"ROWNUM(\"rownum\")\"\n     if (rownum = 0) then do\n        id  = 'NONE'\n        acc = ''                                              /* @C6 */\n        \"TBMOD\" TABLEB\n     end\n     xtdtop = 0                                               /* @CJ */\n     rsels  = 0                                               /* @CJ */\n     do forever                                               /* @CJ */\n        if (rsels < 2) then do                                /* @CJ */\n           optb = ' '                                         /* @CJ */\n           \"TBTOP \" TABLEB                                    /* @CJ */\n           'tbskip' tableb 'number('xtdtop')'                 /* @CJ */\n           radmrfnd = 'PASSTHRU'                              /* @CJ */\n           'vput (radmrfnd)'                                  /* @CJ */\n           \"TBDISPL\" TABLEB \"PANEL(\"PANEL05\")\"                /* @CJ */\n        end                                                   /* @CJ */\n        else 'tbdispl' tableb                                 /* @CJ */\n        if (rc > 4) then leave                                /* @CJ */\n        xtdtop   = ztdtop                                     /* @CJ */\n        rsels    = ztdsels                                    /* @CJ */\n        radmrfnd = null                                       /* @CJ */\n        'vput (radmrfnd)'                                     /* @CJ */\n        PARSE VAR ZCMD ZCMD PARM SEQ                          /* @CJ */\n        IF (SROW <> \"\") & (SROW <> 0) THEN                    /* @AR */\n           IF (SROW > 0) THEN DO                              /* @AR */\n              \"TBTOP \" TABLEB                                 /* @AR */\n              \"TBSKIP\" TABLEB \"NUMBER(\"SROW\")\"                /* @AR */\n           END                                                /* @AR */\n        if (zcmd = 'RFIND') then do                           /* @CH */\n           zcmd = 'FIND'                                      /* @CH */\n           parm = findit                                      /* @CH */\n           'tbtop ' TABLEB                                    /* @CH */\n           'tbskip' TABLEB 'number('last_find')'              /* @CH */\n        end                                                   /* @CH */\n        Select                                                /* @BM */\n           When (abbrev(\"FIND\",zcmd,1) = 1) then              /* @CH */\n                call do_findb                                 /* @CH */\n           WHEN (ABBREV(\"LOCATE\",ZCMD,1) = 1) THEN DO         /* @CJ */\n                if (parm <> '') then do                       /* @CJ */\n                   locarg = parm'*'                           /* @CJ */\n                   PARSE VAR SORT . \",\" . \",\" SEQ             /* @CJ */\n                   IF (SEQ = \"D\") THEN                        /* @CJ */\n                      CONDLIST = \"LE\"                         /* @CJ */\n                   ELSE                                       /* @CJ */\n                      CONDLIST = \"GE\"                         /* @CJ */\n                   parse value sort with scan_field',' .      /* @CJ */\n                   interpret scan_field ' = locarg'           /* @CJ */\n                   'tbtop ' tableb                            /* @CJ */\n                   \"TBSCAN \"TABLEB\" ARGLIST(\"scan_field\")\",   /* @CJ */\n                           \"CONDLIST(\"CONDLIST\")\",            /* @CJ */\n                           \"position(scanrow)\"                /* @CJ */\n                   xtdtop = scanrow                           /* @CJ */\n                end                                           /* @CJ */\n           END                                                /* @CJ */\n           WHEN (ABBREV(\"ONLY\",ZCMD,1) = 1) THEN DO           /* @BM */\n                find_str = translate(parm)                    /* @BM */\n                'tbtop ' TABLEB                               /* @BM */\n                'tbskip' TABLEB                               /* @BM */\n                do forever                                    /* @BM */\n                   str = translate(id acc)                    /* @BM */\n                   if (pos(find_str,str) > 0) then nop        /* @BM */\n                   else 'tbdelete' TABLEB                     /* @BM */\n                   'tbskip' TABLEB                            /* @BM */\n                   if (rc > 0) then do                        /* @BM */\n                      'tbtop' TABLEB                          /* @BM */\n                      leave                                   /* @BM */\n                   end                                        /* @BM */\n                end                                           /* @BM */\n           END                                                /* @BM */\n           WHEN (ABBREV(\"RESET\",ZCMD,1) = 1) THEN DO          /* @BM */\n                sort     = 'ID,C,A'                           /* @BM */\n                sortid   = 'D'; sortacc = 'A'                 /* @BM */\n                xtdtop   = 1                                  /* @BM */\n                \"TBEND\" TABLEB                                /* @BM */\n                call create_TABLEB                            /* @BM */\n           END                                                /* @BM */\n           When (abbrev(\"SAVE\",zcmd,2) = 1) then DO           /* @CQ */\n                TMPSKELT = SKELETON2                          /* @CQ */\n                call do_SAVE                                  /* @CQ */\n           END                                                /* @CQ */\n           WHEN (ABBREV(\"SORT\",ZCMD,1) = 1) THEN DO           /* @BM */\n                SELECT                                        /* @BM */\n                   when (ABBREV(\"USERID\",PARM,1) = 1) then    /* @BM */\n                        call sortseq 'ID'                     /* @BM */\n                   when (ABBREV(\"ACCESS\",PARM,1) = 1) then    /* @BM */\n                        call sortseq 'ACC'                    /* @BM */\n                   otherwise NOP                              /* @BM */\n                END                                           /* @BM */\n                PARSE VAR SORT LOCARG \",\" .                   /* @CJ */\n                CLRID = \"GREEN\"; CLRACC = \"GREEN\"             /* @CJ */\n                INTERPRET \"CLR\"SUBSTR(LOCARG,1,4)\" = 'TURQ'\"  /* @CJ */\n                \"TBSORT\" TABLEB \"FIELDS(\"sort\")\"              /* @CJ */\n                \"TBTOP \" TABLEB                               /* @CJ */\n           END                                                /* @BM */\n           otherwise NOP                                      /* @BM */\n        End  /* Select */                                     /* @BM */\n        ZCMD = \"\"; PARM = \"\"                                  /* @CJ */\n        'control display save'                                /* @CJ */\n        if (optb <> 'A') & (id = 'NONE') then                 /* @BX */\n           Call RACFMSGS ERR21                                /* @BX */\n        else do                                               /* @BX */\n           Select\n              when (optb = 'A')  then call Addp\n              when (optb = 'C')  then call Chgp\n              when (optb = 'L')  then call Lisp               /* @A5 */\n              when (optb = 'P') then                          /* @BI */\n                   call RACFPROF 'USER' id                    /* @BI */\n              when (optb = 'R')  then call Delp\n              when (optb = 'S')  then call RACFUSR id\n              when (optb = 'SE') then call RACFCLSS id\n              when (optb = 'X') then Call RACFUSRX id JCC     /* @CY */\n              otherwise nop\n           End\n        end\n        'control display restore'                             /* @CJ */\n     end  /* Do forever) */                                   /* @CJ */\n     \"TBEND\" TABLEB\n  end /* Do until */\n  sort   = tmpsort                                            /* @BM */\n  rsels  = tmprsels                                           /* @CN */\n  xtdtop = tmpxtdtop                                          /* @CO */\nRETURN\n/*--------------------------------------------------------------------*/\n/*  Process primary command FIND for TABLEB                      @CH  */\n/*--------------------------------------------------------------------*/\nDO_FINDB:                                                     /* @CH */\n  if (parm = null) then do                                    /* @CH */\n     racfsmsg = 'Error'                                       /* @CH */\n     racflmsg = 'Find requires a value to search for.' ,      /* @CH */\n                'Try again.'                                  /* @CH */\n     'setmsg msg(RACF011)'                                    /* @CH */\n     return                                                   /* @CH */\n  end                                                         /* @CH */\n  findit    = translate(parm)                                 /* @CH */\n  last_find = 0                                               /* @CH */\n  wrap      = 0                                               /* @CH */\n  do forever                                                  /* @CH */\n     'tbskip' TABLEB                                          /* @CH */\n     if (rc > 0) then do                                      /* @CH */\n        if (wrap = 1) then do                                 /* @CH */\n           racfsmsg = 'Not Found'                             /* @CH */\n           racflmsg = findit 'not found.'                     /* @CH */\n           'setmsg msg(RACF011)'                              /* @CH */\n           return                                             /* @CH */\n        end                                                   /* @CH */\n        if (wrap = 0) then wrap = 1                           /* @CH */\n        'tbtop' TABLEB                                        /* @CH */\n     end                                                      /* @CH */\n     else do                                                  /* @CH */\n        testit = translate(id acc)                            /* @CH */\n        if (pos(findit,testit) > 0) then do                   /* @CH */\n           'tbquery' TABLEB 'position(srow)'                  /* @CH */\n           'tbtop'   TABLEB                                   /* @CH */\n           'tbskip'  TABLEB 'number('srow')'                  /* @CH */\n           last_find = srow                                   /* @CH */\n           xtdtop    = srow                                   /* @CH */\n           if (wrap = 0) then                                 /* @CH */\n              racfsmsg = 'Found'                              /* @CH */\n           else                                               /* @CH */\n              racfsmsg = 'Found/Wrapped'                      /* @CH */\n           racflmsg = findit 'found in row' srow + 0          /* @CH */\n           'setmsg msg(RACF011)'                              /* @CH */\n           return                                             /* @CH */\n        end                                                   /* @CH */\n     end                                                      /* @CH */\n  end                                                         /* @CH */\nRETURN                                                        /* @CH */\n/*--------------------------------------------------------------------*/\n/*  Create table 'B'                                             @BM  */\n/*--------------------------------------------------------------------*/\nCREATE_TABLEB:                                                /* @BM */\n  \"TBCREATE\" TABLEB \"KEYS(ID) NAMES(ACC)\",\n                  \"REPLACE NOWRITE\"\n  flags  = 'OFF'\n  audit  = ' '\n  owner  = ' '\n  subgrp = 'NONE'                                             /* @BU */\n  uacc   = ' '\n  data   = ' '\n  cmd    = \"LG \"group                                         /* @AN */\n  x = OUTTRAP('VAR.')\n  address TSO cmd                                             /* @AN */\n  cmd_rc = rc                                                 /* @AZ */\n  x = OUTTRAP('OFF')\n  if (SETMSHOW <> 'NO') then                                  /* @BJ */\n     call SHOWCMD                                             /* @AN */\n  Do i = 1 to var.0          /* Scan output */\n     temp = var.i\n     if (rlv > '1081') then  /* RACF 1.9 add blank */\n        temp = ' 'temp\n     l = LENGTH(temp)\n     if (uacc = ' ') then\n        if (substr(temp,6,14) = 'SUPERIOR GROUP') then do\n           temp    = var.i\n           uacc    = substr(temp,20,8)\n           supgrp  = substr(temp,20,8)\n           owner   = substr(temp,39,8)\n           datecre = substr(temp,59,6)                        /* @C2 */\n           datecre = SUBSTR(datecre,1,2)SUBSTR(datecre,4,3)   /* @C2 */\n           datecre = DATE('U',datecre,'J')                    /* @C3 */\n        end\n     if (data = ' ') then\n        if (substr(temp,6,17) = 'INSTALLATION DATA') then do\n           temp = var.i\n           data =  substr(temp,23,45)\n           i    = i + 1\n           temp = var.i\n           if (substr(temp,5,8) <> 'NO MODEL') &,\n              (substr(temp,5,5) <> 'MODEL') then\n              data = data || strip(substr(temp,23,45),'t')\n         end\n     if (subgrp = 'NONE') then                                /* @BU */\n        if (subword(temp,1,1) = 'SUBGROUP(S)=') then do       /* @BT */\n           temp = var.i                                       /* @BT */\n           subgrp = substr(temp,18,54)                        /* @BT */\n           i    = i + 1                                       /* @BT */\n           temp = var.i                                       /* @BT */\n           do while substr(temp,1,17) = ' '                   /* @BT */\n              subgrp = subgrp\"\"substr(temp,18,54)             /* @BT */\n              i    = i + 1                                    /* @BT */\n              temp = var.i                                    /* @BT */\n           end                                                /* @BT */\n           tmpsubgrp = subgrp                                 /* @BV */\n           subgrp    = word(tmpsubgrp,1)                      /* @BV */\n           do JJ = 2 TO WORDS(tmpsubgrp)                      /* @BV */\n              subgrp = subgrp\" \"WORD(tmpsubgrp,JJ)            /* @BV */\n           end                                                /* @BV */\n        end                                                   /* @BT */\n     if (flags = 'ON') then do\n        if (l = 1) | (l = 2) then\n           flags = 'OUT'     /* end access list */\n        if (l > 8) then\n           if (substr(temp,1,60) = ' ') then\n              flags = 'OUT'  /* end access list */\n     end\n     if (flags = 'ON') then do\n        if (substr(temp,2,10) = 'No Command') then iterate    /* @B4 */\n        if (substr(temp,2,10) = 'Command Au') then iterate    /* @BY */\n        if (substr(temp,2,10) = 'Segment:  ') then iterate    /* @BY */\n        if (substr(temp,2,10) = 'NO ENTRIES') then do\n           id  = 'NONE'       /* empty access list */\n           acc = 'DEFINED'\n        end\n        else do\n           id  = subword(temp,1,1)\n           acc = subword(temp,2,1)\n        end\n        if (substr(temp,8,2) <> ' ') then\n           \"TBMOD\" TABLEB\n     end\n     if (subword(temp,1,1) = 'USER(S)=') then do\n        flags = 'ON'   /* start access list */\n     end\n  end /* loop scan output */\n  sort   = 'ID,C,A'                                           /* @CJ */\n  sortid = 'D'; sortacce = 'A'         /* Sort order */       /* @CJ */\n  CLRID  = \"TURQ\"; CLRACC = \"GREEN\"    /* COL COLORS */       /* @CJ */\n  \"TBSORT \" TABLEB \"FIELDS(\"sort\")\"                           /* @CJ */\n  \"TBTOP  \" TABLEB                                            /* @CJ */\nRETURN                                                        /* @BM */\n/*--------------------------------------------------------------------*/\n/*  Get LG info to initialize add or change option                    */\n/*--------------------------------------------------------------------*/\nGETD:\n  owner  = ' '\n  data   = ' '\n  supgrp = ' '\n  cmd    = \"LG \"group                                         /* @AN */\n  x = OUTTRAP('details.')\n  address TSO cmd                                             /* @AN */\n  cmd_rc = rc                                                 /* @AZ */\n  x = OUTTRAP('OFF')\n  if (SETMSHOW <> 'NO') then                                  /* @BJ */\n     call SHOWCMD                                             /* @AN */\n  parse var details.2 'SUPERIOR GROUP=' supgrp,               /* @CS */\n          'OWNER=' owner .                                    /* @CS */\n  parse var details.3 'INSTALLATION DATA=' data_1st_line\n  data_2nd_line = details.4\n  if (subword(data_2nd_line,2,1) = 'MODEL') |,\n     (subword(data_2nd_line,1,1) = 'MODEL') then\n     data = data_1st_line\n  else\n     data = data_1st_line||strip(substr(data_2nd_line,23,45),'t')\nRETURN\n/*--------------------------------------------------------------------*/\n/*  Change permit option                                              */\n/*--------------------------------------------------------------------*/\nCHGP:\n  If (id = 'NONE') then\n     return\n  \"DISPLAY PANEL(\"PANEL06\")\"                                  /* @AW */\n  if (rc > 0) then\n     return\n  call EXCMD \"CONNECT (\"id\") GROUP(\"group\") AUTH(\"acc\")\"\n  if (cmd_rc = 0) then                                        /* @BA */\n     \"TBMOD\" TABLEB\n  else\n     Call racfmsgs 'ERR03' /* Permit failed */                /* @B5 */\nRETURN\n/*--------------------------------------------------------------------*/\n/*  List group                                                        */\n/*--------------------------------------------------------------------*/\nLISD:\n  CMDPRM   = \"CSDATA DFP OMVS OVM TME\"                        /* @A2 */\n  cmd      = \"LG \"GROUP\" \"CMDPRM                              /* @AN */\n  X = OUTTRAP(\"CMDREC.\")                                      /* @A2 */\n  ADDRESS TSO cmd                                             /* @AN */\n  cmd_rc   = rc                                               /* @AZ */\n  X = OUTTRAP(\"OFF\")                                          /* @A2 */\n  if (SETMSHOW <> 'NO') then                                  /* @BJ */\n     call SHOWCMD                                             /* @AN */\n  if (cmd_rc > 0) then DO    /* Remove parms */               /* @B7 */\n     cmd = \"LG \"GROUP                                         /* @B7 */\n     X = OUTTRAP(\"CMDREC.\")                                   /* @B7 */\n     ADDRESS TSO cmd                                          /* @B7 */\n     cmd_rc   = rc                                            /* @B7 */\n     X = OUTTRAP(\"OFF\")                                       /* @B7 */\n     if (SETMSHOW <> 'NO') then                               /* @BJ */\n        call SHOWCMD                                          /* @B7 */\n  END                                                         /* @B7 */\n  call display_info                                           /* @BQ */\n  if (cmd_rc > 0) then                                        /* @B8 */\n     CALL racfmsgs \"ERR10\" /* Generic failure */              /* @B5 */\nRETURN\n/*--------------------------------------------------------------------*/\n/*  Display information from line commands 'L' and 'P'           @BQ  */\n/*--------------------------------------------------------------------*/\nDISPLAY_INFO:                                                 /* @BQ */\n  ADDRESS TSO \"ALLOC F(\"DDNAME\") NEW REUSE\",                  /* @A2 */\n              \"LRECL(80) BLKSIZE(0) RECFM(F B)\",              /* @BR */\n              \"UNIT(VIO) SPACE(1 5) CYLINDERS\"                /* @A2 */\n  ADDRESS TSO \"EXECIO * DISKW \"DDNAME\" (STEM CMDREC. FINIS\"   /* @A2 */\n  DROP CMDREC.                                                /* @CL */\n                                                              /* @CL */\n  \"LMINIT DATAID(CMDDATID) DDNAME(\"DDNAME\")\"                  /* @A2 */\n  SELECT                                                      /* @AK */\n     WHEN (SETGDISP = \"VIEW\") THEN                            /* @AK */\n          \"VIEW DATAID(\"CMDDATID\") MACRO(\"EDITMACR\")\"         /* @BO */\n     WHEN (SETGDISP = \"EDIT\") THEN                            /* @AK */\n          \"EDIT DATAID(\"CMDDATID\") MACRO(\"EDITMACR\")\"         /* @BO */\n     OTHERWISE                                                /* @AK */\n          \"BROWSE DATAID(\"CMDDATID\")\"                         /* @AK */\n  END                                                         /* @AK */\n  ADDRESS TSO \"FREE FI(\"DDNAME\")\"                             /* @A2 */\nRETURN                                                        /* @BQ */\n/*--------------------------------------------------------------------*/\n/*  List userid                                                       */\n/*--------------------------------------------------------------------*/\nLISP:\n  CMDPRM  = \"CICS CSDATA DCE DFP EIM KERB LANGUAGE\",          /* @A5 */\n            \"LNOTES MFA NDS NETVIEW OMVS OPERPARM\",           /* @A5 */\n            \"OVM PROXY TSO WORKATTR\"                          /* @A5 */\n  call get_setropts_options                                   /* @A9 */\n  if (rcvtsmfa = 'NO') then do                                /* @A9 */\n     mfa_pos = pos('MFA',CMDPRM)                              /* @A9 */\n     CMDPRM = delstr(CMDPRM,mfa_pos,4)                        /* @A9 */\n  end                                                         /* @A9 */\n  cmd = \"LU \"ID CMDPRM                                        /* @AN */\n  X = OUTTRAP(\"CMDREC.\")                                      /* @A5 */\n  ADDRESS TSO cmd                                             /* @AN */\n  cmd_rc = rc                                                 /* @AZ */\n  X = OUTTRAP(\"OFF\")                                          /* @A5 */\n  if (SETMSHOW <> 'NO') then                                  /* @BJ */\n     call SHOWCMD                                             /* @AN */\n  if (cmd_rc > 0) then DO    /* Remove parms */               /* @B9 */\n     cmd = \"LU \"ID                                            /* @B9 */\n     X = OUTTRAP(\"CMDREC.\")                                   /* @B9 */\n     ADDRESS TSO cmd                                          /* @B9 */\n     cmd_rc = rc                                              /* @B9 */\n     X = OUTTRAP(\"OFF\")                                       /* @B9 */\n     if (SETMSHOW <> 'NO') then                               /* @BJ */\n        call SHOWCMD                                          /* @B9 */\n  END                                                         /* @B9 */\n  call display_info                                           /* @BQ */\n  if (cmd_rc > 0) then                                        /* @B9 */\n     CALL RACFMSGS \"ERR10\" /* Generic failure */              /* @B5 */\nRETURN\n/*--------------------------------------------------------------------*/\n/*  Get Multi Factor Authentication (MFA) option from RCVT            */\n/*--------------------------------------------------------------------*/\nGET_SETROPTS_OPTIONS:                                         /* @A9 */\n  cvt     = c2x(storage(10,4))      /* cvt address        */  /* @A9 */\n  cvtrac$ = d2x((x2d(cvt))+992)     /* cvt+3E0 = cvtrac $ */  /* @A9 */\n  cvtrac  = c2x(storage(cvtrac$,4)) /* cvtrac=access cntl */  /* @A9 */\n  rc      = setbool(rcvtsmfa,633,'02','NO','YES') /* mfa  */  /* @A9 */\nRETURN                                                        /* @A9 */\n/*--------------------------------------------------------------------*/\n/*  Set boolean value for mask                                        */\n/*--------------------------------------------------------------------*/\nSETBOOL:\n  variable = arg(1)                                           /* @A9 */\n  offset   = arg(2)                                           /* @A9 */\n  value    = arg(3)                                           /* @A9 */\n  status1  = arg(4)                                           /* @A9 */\n  status2  = arg(5)                                           /* @A9 */\n  interpret \"rcvtsta$= d2x((x2d(\"cvtrac\"))+\"offset\")\"         /* @A9 */\n  x        = storage(rcvtsta$,1)                              /* @A9 */\n  interpret variable '= 'status1                              /* @A9 */\n  interpret \"x=bitand(x,'\"value\"'x)\" /*remove bad bits*/      /* @A9 */\n  interpret \"if (x= '\"value\"'x) then \"variable\"=\"status2      /* @A9 */\nRETURN 0                                                      /* @A9 */\n/*--------------------------------------------------------------------*/\n/*  Add permit option                                                 */\n/*--------------------------------------------------------------------*/\nADDP:\n  new = 'NO'\n  if (id = 'NONE') then\n     new = 'YES'\n  from = ' '\n  \"DISPLAY PANEL(\"PANEL07\")\"                                  /* @AW */\n  if (rc > 0) then\n     return\n  idopt = ' '\n  if (id <> ' ') then\n     idopt = 'ID('ID') ACCESS('ACC')'\n  fopt = ' '\n  call EXCMD \"CONNECT (\"id\") GROUP(\"group\") AUTH(\"acc\")\"\n  if (cmd_rc = 0) then do                                     /* @BA */\n     \"TBMOD\" TABLEB\n     if (new = 'YES') then do\n        id = 'NONE'\n        \"TBDELETE\" TABLEB\n     end\n  end\n  else do\n     if (from <> ' ') then\n        call racfmsgs 'ERR04' /* Permit Warning/Failed */     /* @B5 */\n     else\n        call racfmsgs 'ERR05' /* Permit Failed */             /* @B5 */\n  end\nRETURN\n/*--------------------------------------------------------------------*/\n/*   Delete permit option                                             */\n/*--------------------------------------------------------------------*/\nDELP:\n  if (id = 'NONE') then\n     return\n  msg    = 'You are about to delete access for 'ID\n  Sure_? = Confirm_delete(msg)\n  if (sure_? = 'YES') then do\n     call EXCMD \"REMOVE \"id\" GROUP(\"group\")\"\n     if (cmd_rc = 0) then                                     /* @BA */\n        \"TBDELETE\" TABLEB\n     else\n        call racfmsgs 'ERR06' /* Permit Failed */             /* @B5 */\n  end\nRETURN\n/*--------------------------------------------------------------------*/\n/*  Confirm delete                                                    */\n/*--------------------------------------------------------------------*/\nCONFIRM_DELETE:\n  signal off error\n  arg message\n  answer  = 'NO'\n  zwinttl = 'CONFIRM REQUEST'\n  Do until (ckey = 'PF03') | (ckey = 'ENTER')\n    \"CONTROL NOCMD\"                                           /* @AX */\n    \"ADDPOP\"                                                  /* @AX */\n    \"DISPLAY PANEL(\"PANELM1\")\"                                /* @AW */\n    \"REMPOP\"                                                  /* @AX */\n  end\n  Select\n     when (ckey = 'PF03')  then answer = 'NO'\n     when (ckey = 'ENTER') then answer = 'YES'\n     otherwise nop\n  End\n  zwinttl = ' '\nRETURN answer\n/*--------------------------------------------------------------------*/\n/*  Exec command                                                      */\n/*--------------------------------------------------------------------*/\nEXCMD:\n  signal off error\n  arg cmd\n  x = OUTTRAP('msg.')\n  address TSO cmd                                             /* @AY */\n  cmd_rc = rc\n  x = OUTTRAP('OFF')\n  if (SETMSHOW <> 'NO') then                                  /* @BJ */\n     call SHOWCMD                                             /* @AN */\n  if (subword(msg.1,1,1)= 'ICH11009I') |,\n     (subword(msg.1,1,1)= 'ICH10006I') |,\n     (subword(msg.1,1,1)= 'ICH06011I') then raclist = 'YES'\nRETURN\n/*--------------------------------------------------------------------*/\n/*  Display RACF command and return code                         @AN  */\n/*--------------------------------------------------------------------*/\nSHOWCMD:                                                      /* @AN */\n  IF (SETMSHOW = \"BOTH\") | (SETMSHOW = \"DISPLAY\") THEN DO     /* @BK */\n     PARSE VAR CMD MSG1 60 MSG2 121 MSG3                      /* @AN */\n     MSG4 = \"Return code = \"cmd_rc                            /* @AN */\n     \"ADDPOP ROW(6) COLUMN(4)\"                                /* @AZ */\n     \"DISPLAY PANEL(\"PANELM2\")\"                               /* @AX */\n     \"REMPOP\"                                                 /* @AW */\n  END                                                         /* @BJ */\n  IF (SETMSHOW = \"BOTH\") | (SETMSHOW = \"LOG\") THEN DO         /* @BK */\n     zerrsm = \"RACFADM \"REXXPGM\" RC=\"cmd_rc                   /* @C4 */\n     zerrlm = cmd                                             /* @BJ */\n     'log msg(isrz003)'                                       /* @BJ */\n  END                                                         /* @BJ */\nRETURN                                                        /* @AN */\n/*--------------------------------------------------------------------*/\n/*  Create table 'A'                                             @AP  */\n/*--------------------------------------------------------------------*/\nCREATE_TABLEA:                                                /* @AP */\n  seconds = TIME('S')\n  \"TBCREATE\" TABLEA \"KEYS(GROUP) NAMES(DATA SUPGRP OWNER)\",   /* @BC */\n           \"REPLACE NOWRITE\"\n  cmd = \"SEARCH FILTER(\"RFILTER\") CLASS(\"rclass\")\"            /* @AN */\n  x = OUTTRAP('var.')\n  address TSO cmd                                             /* @AN */\n  cmd_rc = rc                                                 /* @AZ */\n  x = OUTTRAP('OFF')\n  if (SETMSHOW <> 'NO') then                                  /* @BJ */\n     call SHOWCMD                                             /* @AN */\n  if (SETGSTAP <> \"\") THEN                                    /* @C7 */\n     INTERPRET \"RECNUM = var.0*.\"SETGSTAP\"%1\"                 /* @C7 */\n  Do i = 1 to var.0\n     temp  = var.i\n     group = SUBWORD(temp,1,1)\n     msgr  = SUBWORD(temp,1,1)\n     Select\n        when (msgr = 'ICH31005I') then\n             group = 'NONE'       /* No groups  */\n        when (msgr = 'ICH31009I') then do\n             group = 'INVALID'    /* Bad filter */\n             call racfmsgs 'ERR08'                            /* @B5 */\n        end\n        when (msgr = 'ICH31012I') then do\n             group = 'INVALID'    /* Bad filter */\n             call racfmsgs 'ERR08'                            /* @B5 */\n        end\n        when (msgr = 'ICH31014I') then do\n             group = 'INVALID'    /* Bad filter */\n             call racfmsgs 'ERR08'                            /* @B5 */\n        end\n        when (msgr = 'ICH31016I') then do\n             group = 'INVALID'    /* Bad filter */\n             call racfmsgs 'ERR08'                            /* @B5 */\n        end\n        when (msgr = 'ICH31017I') then do\n             group = 'INVALID'    /* Bad filter */\n             call racfmsgs 'ERR08'                            /* @B5 */\n        end\n        when (msgr = 'ICH31018I') then do\n             group = 'INVALID'    /* Bad filter */\n             call racfmsgs 'ERR08'                            /* @B5 */\n        end\n        when (msgr = 'IKJ56716I') then do\n             group = 'INVALID'    /* Bad filter */\n             call racfmsgs 'ERR08'                            /* @B5 */\n        end\n        when (substr(msgr,1,6) = 'ICH310') then\n             call racfmsgs 'ERR09'                            /* @B5 */\n        otherwise nop\n     End  /* Select */\n     /*---------------------------------------------*/\n     /* Display number of records retrieved        -*/\n     /*---------------------------------------------*/\n     IF (SETGSTA = \"\") THEN DO                                /* @C7 */\n        IF (RECNUM <> 0) THEN                                 /* @C7 */\n           IF (I//RECNUM = 0) THEN DO                         /* @C7 */\n              n1 = i; n2 = var.0                              /* @C7 */\n              pct = ((n1/n2)*100)%1'%'                        /* @C7 */\n              \"control display lock\"                          /* @C7 */\n              \"display msg(RACF012)\"                          /* @CA */\n           END                                                /* @C7 */\n     END                                                      /* @C7 */\n     ELSE DO                                                  /* @C7 */\n        IF (SETGSTA <> 0) THEN                                /* @C7 */\n           IF (I//SETGSTA = 0) THEN DO                        /* @AI */\n              n1 = i; n2 = var.0\n              pct = ((n1/n2)*100)%1'%'                        /* @C7 */\n              \"control display lock\"\n              \"display msg(RACF012)\"                          /* @CA */\n           END                                                /* @AI */\n     END                                                      /* @C7 */\n     /* Get further information */\n     Call GETD\n     \"TBMOD\" TABLEA\n  end /* Do i=1 to var.0 */\n  sort     = 'GROUP,C,A'                                      /* @CJ */\n  sortgrou = 'D'; sortsupg = 'A'         /* Sort order */     /* @CJ */\n  sortowne = 'A'; sortdata = 'A'                              /* @CJ */\n  CLRGROU  = \"TURQ\";  CLRDATA = \"GREEN\"  /* Col colors */     /* @CJ */\n  CLRSUPG  = \"GREEN\"; CLROWNE = \"GREEN\"                       /* @CJ */\n  \"TBSORT \" TABLEA \"FIELDS(\"sort\")\"                           /* @CJ */\n  \"TBTOP  \" TABLEA                                            /* @CJ */\nRETURN                                                        /* @AP */\n/*--------------------------------------------------------------------*/\n/*  Save table to dataset                                        @CQ  */\n/*--------------------------------------------------------------------*/\nDO_SAVE:                                                      /* @CQ */\n  X = MSG(\"OFF\")                                              /* @CQ */\n  \"ADDPOP COLUMN(40)\"                                         /* @CQ */\n  \"VGET (RACFSDSN RACFSMBR RACFSFIL RACFSREP) PROFILE\"        /* @CR */\n  IF (RACFSDSN = \"\") THEN         /* SAve - Dataset Name  */  /* @CT */\n     RACFSDSN = USERID()\".RACFADM.REPORTS\"                    /* @EK */\n  IF (RACFSFIL = \"\") THEN         /* SAve - As (TXT/CVS)  */  /* @CT */\n     RACFSFIL = \"T\"                                           /* @EL */\n  IF (RACFSREP = \"\") THEN         /* SAve - Replace (Y/N) */  /* @CT */\n     RACFSREP = \"N\"                                           /* @EK */\n                                                              /* @CQ */\n  DO FOREVER                                                  /* @CQ */\n     \"DISPLAY PANEL(\"PANELS1\")\"                               /* @CQ */\n     IF (RC = 08) THEN DO                                     /* @CQ */\n        \"REMPOP\"                                              /* @CQ */\n        RETURN                                                /* @CQ */\n     END                                                      /* @CQ */\n     RACFSDSN = STRIP(RACFSDSN,,\"'\")                          /* @CQ */\n     RACFSDSN = STRIP(RACFSDSN,,'\"')                          /* @CQ */\n     RACFSDSN = STRIP(RACFSDSN)                               /* @CQ */\n     SYSDSORG = \"\"                                            /* @CQ */\n     X = LISTDSI(\"'\"RACFSDSN\"'\")                              /* @CQ */\n     IF (SYSDSORG = \"\") | (SYSDSORG = \"PS\"),                  /* @CQ */\n      | (SYSDSORG = \"PO\") THEN                                /* @CQ */\n        NOP                                                   /* @CQ */\n     ELSE DO                                                  /* @CQ */\n        RACFSMSG = \"Not PDS/Seq File\"                         /* @CQ */\n        RACFLMSG = \"The dataset specified is not\",            /* @CQ */\n                  \"a partitioned or sequential\",              /* @CQ */\n                  \"dataset, please enter a valid\",            /* @CQ */\n                  \"dataset name.\"                             /* @CQ */\n       \"SETMSG MSG(RACF011)\"                                  /* @CQ */\n       ITERATE                                                /* @CQ */\n     END                                                      /* @CQ */\n     IF (SYSDSORG = \"PS\") & (RACFSMBR <> \"\") THEN DO          /* @CQ */\n        RACFSMSG = \"Seq File - No mbr\"                        /* @CQ */\n        RACFLMSG = \"This dataset is a sequential\",            /* @CQ */\n                  \"file, please remove the\",                  /* @CQ */\n                  \"member name.\"                              /* @CQ */\n       \"SETMSG MSG(RACF011)\"                                  /* @CQ */\n       ITERATE                                                /* @CQ */\n     END                                                      /* @CQ */\n     IF (SYSDSORG = \"PO\") & (RACFSMBR = \"\") THEN DO           /* @CQ */\n        RACFSMSG = \"PDS File - Need Mbr\"                      /* @CQ */\n        RACFLMSG = \"This dataset is a partitioned\",           /* @CQ */\n                  \"dataset, please include a member\",         /* @CQ */\n                  \"name.\"                                     /* @CQ */\n       \"SETMSG MSG(RACF011)\"                                  /* @CQ */\n       ITERATE                                                /* @CQ */\n     END                                                      /* @CQ */\n                                                              /* @CQ */\n     IF (RACFSMBR = \"\") THEN                                  /* @CQ */\n        TMPDSN = RACFSDSN                                     /* @CQ */\n     ELSE                                                     /* @CQ */\n        TMPDSN = RACFSDSN\"(\"RACFSMBR\")\"                       /* @CQ */\n     DSNCHK = SYSDSN(\"'\"TMPDSN\"'\")                            /* @CQ */\n     IF (DSNCHK = \"OK\" & RACFSREP = \"N\") THEN DO              /* @CQ */\n        RACFSMSG = \"DSN/MBR Exists\"                           /* @CQ */\n        RACFLMSG = \"Dataset/member already exists. \",         /* @CQ */\n                  \"Please type in \"Y\" to replace file.\"       /* @CQ */\n        \"SETMSG MSG(RACF011)\"                                 /* @CQ */\n        ITERATE                                               /* @CQ */\n     END                                                      /* @CQ */\n     LEAVE                                                    /* @CQ */\n  END                                                         /* @CQ */\n  \"REMPOP\"                                                    /* @CQ */\n  \"VPUT (RACFSDSN RACFSMBR RACFSFIL RACFSREP) PROFILE\"        /* @CR */\n                                                              /* @CQ */\nADDRESS TSO                                                   /* @CQ */\n  IF (RACFSREP = \"Y\" & RACFSMBR = \"\") |,                      /* @CQ */\n     (DSNCHK <> \"OK\" & DSNCHK <> \"MEMBER NOT FOUND\"),         /* @CQ */\n     THEN DO                                                  /* @CQ */\n     \"DELETE '\"RACFSDSN\"'\"                                    /* @CQ */\n     IF (RACFSMBR = \"\") THEN                                  /* @CQ */\n        \"ALLOC  FI(ISPFILE) DA('\"RACFSDSN\"') NEW\",            /* @CQ */\n            \"REUSE SP(1 1) CYLINDER UNIT(SYSALLDA)\",          /* @CU */\n            \"LRECL(132) RECFM(F B)\"                           /* @CR */\n     ELSE                                                     /* @CQ */\n        \"ALLOC  FI(ISPFILE) DA('\"RACFSDSN\"') NEW\",            /* @CQ */\n            \"REUSE SP(1 1) CYLINDER UNIT(SYSALLDA)\",          /* @CU */\n            \"LRECL(132) RECFM(F B)\",                          /* @CR */\n            \"DSORG(PO) DSNTYPE(LIBRARY,2)\"                    /* @CQ */\n  END                                                         /* @CQ */\n  ELSE                                                        /* @CQ */\n     \"ALLOC  FI(ISPFILE) DA('\"RACFSDSN\"') SHR REUSE\"          /* @CQ */\n                                                              /* @CQ */\nADDRESS ISPEXEC                                               /* @CQ */\n  \"FTOPEN\"                                                    /* @CQ */\n  \"FTINCL \"TMPSKELT                                           /* @CQ */\n  IF (RACFSMBR = \"\") THEN                                     /* @CQ */\n     \"FTCLOSE\"                                                /* @CQ */\n  ELSE                                                        /* @CQ */\n     \"FTCLOSE NAME(\"RACFSMBR\")\"                               /* @CQ */\n  ADDRESS TSO \"FREE FI(ISPFILE)\"                              /* @CQ */\n                                                              /* @CQ */\n  SELECT                                                      /* @CQ */\n     WHEN (SETGDISP = \"VIEW\") THEN                            /* @CQ */\n          \"VIEW DATASET('\"RACFSDSN\"') MACRO(\"EDITMACR\")\"      /* @CQ */\n     WHEN (SETGDISP = \"EDIT\") THEN                            /* @CQ */\n          \"EDIT DATASET('\"RACFSDSN\"') MACRO(\"EDITMACR\")\"      /* @CQ */\n     OTHERWISE                                                /* @CQ */\n          \"BROWSE DATASET('\"RACFSDSN\"')\"                      /* @CQ */\n  END                                                         /* @CQ */\n  X = MSG(\"ON\")                                               /* @CQ */\n                                                              /* @CQ */\nRETURN                                                        /* @CQ */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RACFGTRE": {"ttr": 923, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\n\\x00 \\x01 \\x12\\x7f\\x01 \\x16\\x8f\\t \\x00\\x8c\\x00\\x86\\x00\\x00\\xd9\\xc1\\xc3\\xc6\\xc1\\xc4\\xd4@@@'", "ispf": {"version": "01.10", "flags": 0, "createdate": "2020-05-06T00:00:00", "modifydate": "2020-06-16T09:20:20", "lines": 140, "newlines": 134, "modlines": 0, "user": "RACFADM"}, "text": "/*%NOCOMMENT====================* REXX *==============================*/\n/*  PURPOSE:  RACFADM - Group Tree Report - Menu option 6             */\n/*--------------------------------------------------------------------*/\n/* FLG  YYMMDD  USERID   DESCRIPTION                                  */\n/* ---  ------  -------  -------------------------------------------- */\n/* @AJ  200616  RACFA    Chg panel name RACFRPTS to RACFDISP          */\n/* @AI  200506  LBD      Add ISPF Variable for report                 */\n/* @AH  200506  RACFA    Fix spaces from text between paranthesis (.) */\n/* @AG  200506  LBD      Disp rpt header and bar lines in diff. color */\n/* @AF  200503  RACFA    Add 'Please be patient' message              */\n/* @AE  200429  RACFA    Re-arranged variables (General, Mgmt, TSO)   */\n/* @AD  200423  RACFA    Move PARSE REXXPGM name up above IF SETMTRAC */\n/* @AC  200423  RACFA    Removed blank in column 1 of report          */\n/* @AB  200423  RACFA    Do not chk for titles when looping thru rpt  */\n/* @AA  200423  RACFA    Ensure REXX program name is 8 chars long     */\n/* @A9  200423  RACFA    Fix placing ')' at end of rpt title          */\n/* @A8  200422  RACFA    Remove leading space in front of ')'         */\n/* @A7  200417  RACFA    Free file when done using                    */\n/* @A5  200417  RACFA    Chg edit macro, add code to del blank rows   */\n/* @A4  200417  TRIDJK   When EDIT/VIEW, remove blank rows/lines      */\n/* @A3  200417  RACFA    Removed 'enq(exclu)', not needed             */\n/* @A2  200416  RACFA    Honor users setting on displaying of file    */\n/* @A1  200416  RACFA    Increased size of SYSPRINT                   */\n/* @A0  200416  TRIDJK   Created REXX program                         */\n/*====================================================================*/\nPANEL01     = \"RACFDISP\"   /* Display report with colors   */ /* @AJ */\nEDITMACR    = \"RACFEMAC\"   /* Edit Macro, turn hilite off  */ /* @A5 */\nDDNAME      = \"RACFA\"RANDOM(0,999) /* Unique ddname        */ /* @A5 */\nparse source . . REXXPGM .         /* Obtain REXX pgm name */ /* @AD */\nREXXPGM     = LEFT(REXXPGM,8)                                 /* @AD */\n\nADDRESS ISPEXEC\n  \"VGET (SETGDISP SETMTRAC) PROFILE\"                          /* @AE */\n  If (SETMTRAC <> 'NO') then do\n     Say \"*\"COPIES(\"-\",70)\"*\"\n     Say \"*\"Center(\"Begin Program = \"REXXPGM,70)\"*\"\n     Say \"*\"COPIES(\"-\",70)\"*\"\n     if (SETMTRAC <> 'PROGRAMS') THEN\n        interpret \"Trace \"SUBSTR(SETMTRAC,1,1)\n  end\n  racflmsg = \"Retrieving data - Please be patient\"            /* @AF */\n  \"control display lock\"                                      /* @AF */\n  \"display msg(RACF011)\"                                      /* @AF */\n\nAddress TSO\n  /*--------------------------------------------*/\n  /*  Call ICHDSM00 for group tree report       */\n  /*--------------------------------------------*/\n  'alloc f(sysprint) new reuse unit(sysallda)',\n         'space(1,1) tracks'\n  'alloc f(sysut2)   new reuse unit(sysallda)',\n         'space(20,50) cylinders',                            /* @A1 */\n         'recfm(F B A) lrecl(133) blksize(0)'                 /* @A1 */\n  'alloc f(sysin)    new reuse unit(sysallda)',\n         'lrecl(80) blksize(0) recfm(f b)',\n         'space(1,1) tracks'\n  'newstack'\n  queue 'LINECOUNT 0'\n  queue 'FUNCTION RACGRP'\n  queue\n  'Execio * diskw sysin (finis'\n\n  \"call *(ichdsm00)\"\n\n  /*--------------------------------------------*/\n  /*  Remove empty rows/lines and format report */\n  /*--------------------------------------------*/\n  'execio * diskr sysut2 (stem sysut2. finis'                 /* @A5 */\n  'free  f(sysprint sysut2 sysin)'\n  'delstack'\n\n  rec.1 = substr(sysut2.1,2)                                  /* @AC */\n  rec.2 = strip(substr(sysut2.2,2))                           /* @AC */\n  K = 2                                                       /* @A5 */\n  do J = 3 To sysut2.0                                        /* @A5 */\n     sysut2.J = Substr(sysut2.J,2)                            /* @AC */\n     parse var sysut2.j W1 W2 .                               /* @A5 */\n     Select                                                   /* @A5 */\n        when (W1 = '|') then iterate                          /* @A5 */\n        when (W1 = ' ') then iterate                          /* @A5 */\n        otherwise                                             /* @A5 */\n             nop                                              /* @A5 */\n     end                                                      /* @A5 */\n     PARSE VAR SYSUT2.J W1 \"(\" W2 \")\" W3                      /* @AH */\n     K = K + 1                                                /* @A5 */\n     SELECT                                                   /* @AH */\n        WHEN (W2 = \"\") THEN                                   /* @AH */\n             REC.K = W1                                       /* @AH */\n        OTHERWISE                                             /* @AH */\n             REC.K = W1\"(\"STRIP(W2)\")\"W3                      /* @AH */\n     END                                                      /* @AH */\n  end                                                         /* @A5 */\n  rec.0 = K                                                   /* @A5 */\n  drop sysut2.                                                /* @A5 */\n                                                              /* @A5 */\n  'alloc f('DDNAME')  new reuse unit(sysallda)',              /* @A5 */\n         'space(20,50) cylinders',                            /* @A5 */\n         'recfm(F B A) lrecl(133) blksize(0)'                 /* @A5 */\n  'execio * diskw 'DDNAME' (stem rec. finis'                  /* @A5 */\n  drop rec.                                                   /* @A5 */\n\nAddress ISPExec\n  /*---------------------*/\n  /*  Browse the report  */\n  /*---------------------*/\n  'lminit dataid(id) ddname('DDNAME')'                        /* @A5 */\n  if (rc \u00ac= 0) then do\n     racfsmsg = 'Allocation error'\n     racflmsg = 'LMINIT failed for 'DDNAME                    /* @A5 */\n     'setmsg msg(racf001)'\n     call Goodbye\n  end\n  vtype = 'TREE'                                              /* @AI */\n  'vput (vtype) shared'                                       /* @AI */\n  SELECT                                                      /* @A2 */\n     WHEN (SETGDISP = \"VIEW\") THEN                            /* @A2 */\n          \"VIEW DATAID(\"ID\") MACRO(\"EDITMACR\")\",              /* @A2 */\n               \"PANEL(\"PANEL01\")\"                             /* @AG */\n     WHEN (SETGDISP = \"EDIT\") THEN                            /* @A2 */\n          \"EDIT DATAID(\"ID\") MACRO(\"EDITMACR\")\",              /* @A2 */\n               \"PANEL(\"PANEL01\")\"                             /* @AG */\n     OTHERWISE                                                /* @A2 */\n          \"BROWSE DATAID(\"ID\")\"                               /* @A2 */\n  END                                                         /* @A2 */\n  vtype = ''                                                  /* @AI */\n  'vput (vtype) shared'                                       /* @AI */\n  'lmfree dataid('id')'\n  Address TSO 'Free fi('DDNAME')'                             /* @A7 */\n  call Goodbye\nEXIT\n/*--------------------------------------------------------------------*/\n/*  If tracing is on, display flower box                              */\n/*--------------------------------------------------------------------*/\nGOODBYE:\n  If (SETMTRAC <> 'NO') then do\n     Say \"*\"COPIES(\"-\",70)\"*\"\n     Say \"*\"Center(\"End Program = \"REXXPGM,70)\"*\"\n     Say \"*\"COPIES(\"-\",70)\"*\"\n  end\nEXIT\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RACFHELP": {"ttr": 925, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x03\\x19\\x00\\x04\\x01\\x170\\x0f\\x01 \\x17\\x0f\\x11\\x18\\x06v\\x07m\\x00\\x00\\xd9\\xc1\\xc3\\xc6\\xc1\\xc4\\xd4@@@'", "ispf": {"version": "03.25", "flags": 0, "createdate": "2017-10-27T00:00:00", "modifydate": "2020-06-18T11:18:04", "lines": 1654, "newlines": 1901, "modlines": 0, "user": "RACFADM"}, "mimetype": "application/octet-stream", "datatype": "binary", "extension": ".bin"}, "RACFIBM": {"ttr": 927, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x15\\x00D\\x01 \\x13/\\x01 \\x18O\\x07W\\x00j\\x00-\\x00\\x00\\xd9\\xc1\\xc3\\xc6\\xc1\\xc4\\xd4@@@'", "ispf": {"version": "01.21", "flags": 0, "createdate": "2020-05-11T00:00:00", "modifydate": "2020-07-02T07:57:44", "lines": 106, "newlines": 45, "modlines": 0, "user": "RACFADM"}, "text": "/*%NOCOMMENT====================* REXX *==============================*/\n/*  PURPOSE:  RACFADM - Menu options:                                 */\n/*               9  IBMSys    RACF system options                     */\n/*              10  IBMRRSF   RACF remote services                    */\n/*              11  IBMCert   RACF certificates                       */\n/*--------------------------------------------------------------------*/\n/* FLG  YYMMDD  USERID   DESCRIPTION                                  */\n/* ---  ------  -------  -------------------------------------------- */\n/* @A4  200702  RACFA    Allow symbolics in dsname                    */\n/* @A3  200525  RACFA    Allow defining pgm name in Settings (Opt 0)  */\n/* @A2  200519  RACFA    Remove single quotes from datasets           */\n/* @A1  200511  RACFA    Chk ISPF variables for dataset names         */\n/* @A0  200510  LBD      Created REXX                                 */\n/*====================================================================*/\nADDRESS ISPEXEC\n  arg racfopt\n  if racfopt = '' then return 8\n  'VGet (SETDIBMM SETDIBMP SETDIBMS SETDIBMC',                /* @A3 */\n        'SETPIBM) Profile'                                    /* @A3 */\n  IF (SETPIBM = \"\") THEN    /* IBM Main Menu Panel */         /* @A3 */\n     SETPIBM = \"ICHP00\"                                       /* @A3 */\n\n  IF (SETDIBMM = \"\") | (SETDIBMP = \"\"),                       /* @A1 */\n   | (CETDIBMS = \"\") | (SETDIBMC = \"\") THEN                   /* @A1 */\n     CALL PROCESS_MENU_OPT                                    /* @A1 */\n  ELSE DO                                                     /* @A1 */\n     SETDIBMM = STRIP(SETDIBMM,,\"'\")                          /* @A2 */\n     PARSE VAR SETDIBMM DSN1 \"&\" SYMBOL \".\" DSN2              /* @A4 */\n     SYMBVAL  = MVSVAR(\"SYMDEF\",SYMBOL)                       /* @A4 */\n     SETDIBMM = DSN1\"\"SYMBVAL\"\"DSN2                           /* @A4 */\n     IF (SYSDSN(\"'\"SETDIBMM\"'\") <> \"OK\") THEN DO              /* @A1 */\n        RACFSMSG = \"Invalid - Message DSN\"                    /* @A1 */\n        RACFLMSG = \"The message dataset does not exist,\",     /* @A1 */\n                   \"DSN='SETDIBMM'.  Invoke Settings\",        /* @A1 */\n                   \"(Option 0) and verify the IBM RACF\",      /* @A1 */\n                   \"datasets defined are valid.\"              /* @A1 */\n        \"SETMSG MSG(RACF011)\"                                 /* @A1 */\n        EXIT                                                  /* @A1 */\n     END                                                      /* @A1 */\n     SETDIBMP = STRIP(SETDIBMP,,\"'\")                          /* @A2 */\n     PARSE VAR SETDIBMP DSN1 \"&\" SYMBOL \".\" DSN2              /* @A4 */\n     SYMBVAL  = MVSVAR(\"SYMDEF\",SYMBOL)                       /* @A4 */\n     SETDIBMP = DSN1\"\"SYMBVAL\"\"DSN2                           /* @A4 */\n     IF (SYSDSN(\"'\"SETDIBMP\"'\") <> \"OK\") THEN DO              /* @A1 */\n        RACFSMSG = \"Invalid - Panel DSN\"                      /* @A1 */\n        RACFLMSG = \"The panel dataset does not exist,\",       /* @A1 */\n                   \"DSN='SETDIBMP'.  Invoke Settings\",        /* @A1 */\n                   \"(Option 0) and verify the IBM RACF\",      /* @A1 */\n                   \"datasets defined are valid.\"              /* @A1 */\n        \"SETMSG MSG(RACF011)\"                                 /* @A1 */\n        EXIT                                                  /* @A1 */\n     END                                                      /* @A1 */\n     SETDIBMS = STRIP(SETDIBMS,,\"'\")                          /* @A2 */\n     PARSE VAR SETDIBMS DSN1 \"&\" SYMBOL \".\" DSN2              /* @A4 */\n     SYMBVAL  = MVSVAR(\"SYMDEF\",SYMBOL)                       /* @A4 */\n     SETDIBMS = DSN1\"\"SYMBVAL\"\"DSN2                           /* @A4 */\n     IF (SYSDSN(\"'\"SETDIBMS\"'\") <> \"OK\") THEN DO              /* @A1 */\n        RACFSMSG = \"Invalid - Skeleton DSN\"                   /* @A1 */\n        RACFLMSG = \"The skeleton dataset does not exist,\",    /* @A1 */\n                   \"DSN='SETDIBMS'.  Invoke Settings\",        /* @A1 */\n                   \"(Option 0) and verify the IBM RACF\",      /* @A1 */\n                   \"datasets defined are valid.\"              /* @A1 */\n        \"SETMSG MSG(RACF011)\"                                 /* @A1 */\n        EXIT                                                  /* @A1 */\n     END                                                      /* @A1 */\n     SETDIBMC = STRIP(SETDIBMC,,\"'\")                          /* @A2 */\n     PARSE VAR SETDIBMC DSN1 \"&\" SYMBOL \".\" DSN2              /* @A4 */\n     SYMBVAL  = MVSVAR(\"SYMDEF\",SYMBOL)                       /* @A4 */\n     SETDIBMC = DSN1\"\"SYMBVAL\"\"DSN2                           /* @A4 */\n     IF (SYSDSN(\"'\"SETDIBMC\"'\") <> \"OK\") THEN DO              /* @A1 */\n        RACFSMSG = \"Invalid - Clist DSN\"                      /* @A1 */\n        RACFLMSG = \"The clist dataset does not exist,\",       /* @A1 */\n                   \"DSN='SETDIBMC'.  Invoke Settings\",        /* @A1 */\n                   \"(Option 0) and verify the IBM RACF\",      /* @A1 */\n                   \"datasets defined are valid.\"              /* @A1 */\n        \"SETMSG MSG(RACF011)\"                                 /* @A1 */\n        EXIT                                                  /* @A1 */\n     END                                                      /* @A1 */\n     Address TSO,\n     \"Altlib Act App(Clist) Dataset('\"SETDIBMC\"')\"\n\n     \"Libdef ISPMLIB Dataset ID('\"SETDIBMM\"') stack\"\n     \"Libdef ISPPLIB Dataset ID('\"SETDIBMP\"') stack\"\n     \"Libdef ISPSLIB Dataset ID('\"SETDIBMS\"') stack\"\n\n     CALL PROCESS_MENU_OPT\n\n     \"Libdef ISPMLIB\"\n     \"Libdef ISPPLIB\"\n     \"Libdef ISPSLIB\"\n\n     Address TSO\n     \"Altlib Deact app(clist)\"\n  END\nEXIT\n/*--------------------------------------------------------------------*/\n/*  Display RACF Menu option                                          */\n/*--------------------------------------------------------------------*/\nPROCESS_MENU_OPT:\n  Select\n    When racfopt = 5 then 'Select Panel('SETPIBM') Opt(5)'    /* @A3 */\n    When racfopt = 6 then 'Select Panel('SETPIBM') Opt(6)'    /* @A3 */\n    When racfopt = 7 then 'Select Panel('SETPIBM') Opt(7)'    /* @A3 */\n    Otherwise nop\n  end\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RACFLOG": {"ttr": 929, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x10\\x00U\\x01 \\x14\\x1f\\x01 \\x18\\x0f\\x05E\\x00\\xcf\\x00\\xc7\\x00\\x00\\xd9\\xc1\\xc3\\xc6\\xc1\\xc4\\xd4@@@'", "ispf": {"version": "01.16", "flags": 0, "createdate": "2020-05-20T00:00:00", "modifydate": "2020-06-28T05:45:55", "lines": 207, "newlines": 199, "modlines": 0, "user": "RACFADM"}, "text": "/*%NOCOMMENT====================* REXX *==============================*/\n/*  PURPOSE:  RACFADM - ISPLog/Standards/Updates - Opts L, S, U (I)   */\n/*--------------------------------------------------------------------*/\n/* FLG  YYMMDD  USERID   DESCRIPTION                                  */\n/* ---  ------  -------  -------------------------------------------- */\n/* @AL  200616  RACFA    Chg panel name RACFRPTS to RACFDISP          */\n/* @AK  200524  TRIDJK   Fixed displaying error message               */\n/* @AJ  200519  TRIDJK   Support ISPLOG SYSOUT datasets - SDSF/(E)JES */\n/* @AI  200511  RACFA    Place most current records at top of file    */\n/* @AH  200506  RACFA    Display headers in a different color         */\n/* @AG  200504  RACFA    Make long msg more meaningful                */\n/* @AF  200504  RACFA    Added the capability to view ISPLOG file     */\n/* @AE  200423  RACFA    Move PARSE REXXPGM name up above IF SETMTRAC */\n/* @AD  200423  RACFA    Ensure REXX program name is 8 chars long     */\n/* @AC  200422  RACFA    Fixed displaying error message               */\n/* @AB  200413  RACFA    Chg TRACEing to only display banner (P=Pgms) */\n/* @AA  200412  RACFA    Chg TRACE to allow 'L'abels or 'R'esults     */\n/* @A9  200402  RACFA    Issue message if no LIBDEF ISPPLIB dataset   */\n/* @A8  200401  RACFA    Chged edit macro RACFLOGE to RACFEMAC        */\n/* @A7  200303  RACFA    Def/use variable for edit macro              */\n/* @A6  200303  RACFA    Renamed edit macro to RACFDSPE, was RACFCHGE */\n/* @A5  200303  RACFA    Receive member as a parmater                 */\n/* @A4  200303  RACFA    Renamed mbr to RACFDSP, was RACFCHGS         */\n/* @A3  200221  RACFA    Make 'ADDRESS ISPEXEC' defualt, reduce code  */\n/* @A2  200220  RACFA    Added SETMTRAC=YES, then TRACE R             */\n/* @A1  200220  RACFA    Added capability to browse/edit/view file    */\n/* @A0  200218  RACFA    Created REXX                                 */\n/*====================================================================*/\nPANEL01     = \"RACFDISP\"   /* Display report with colors   */ /* @AL */\nEDITMACR    = \"RACFEMAC\"   /* Edit Macro, turn HILITE off  */ /* @A8 */\nparse source . . REXXPGM .         /* Obtain REXX pgm name */ /* @AE */\nREXXPGM     = LEFT(REXXPGM,8)                                 /* @AE */\n\nADDRESS ISPEXEC                                               /* @A3 */\n  PARSE ARG MEMBER                                            /* @A5 */\n  \"VGET (SETGDISP SETMTRAC) PROFILE\"                          /* @A2 */\n  If (SETMTRAC <> 'NO') then do                               /* @AA */\n     Say \"*\"COPIES(\"-\",70)\"*\"                                 /* @AA */\n     Say \"*\"Center(\"Begin Program = \"REXXPGM,70)\"*\"           /* @AA */\n     Say \"*\"COPIES(\"-\",70)\"*\"                                 /* @AA */\n     if (SETMTRAC <> 'PROGRAMS') THEN                         /* @AB */\n        interpret \"Trace \"SUBSTR(SETMTRAC,1,1)                /* @AA */\n  end                                                         /* @AA */\n  IF (member = \"ISPLOG\") THEN                                 /* @AF */\n     CALL ISPLOG_FILE                                         /* @AF */\n  ELSE                                                        /* @AF */\n     CALL LOG_FILE\n\n  If (SETMTRAC <> 'NO') then do                               /* @AA */\n     Say \"*\"COPIES(\"-\",70)\"*\"                                 /* @AA */\n     Say \"*\"Center(\"End Program = \"REXXPGM,70)\"*\"             /* @AA */\n     Say \"*\"COPIES(\"-\",70)\"*\"                                 /* @AA */\n  end                                                         /* @AA */\nEXIT                                                          /* @AA */\n/*--------------------------------------------------------------------*/\n/*  Display the Change or Issues Log file                             */\n/*--------------------------------------------------------------------*/\nLOG_FILE:\n  \"QLIBDEF ISPPLIB TYPE(DATASET) ID(DSNAME)\"\n  if (RC > 0) then do                                         /* @A9 */\n     call RACFMSGS ERR19                                      /* @AC */\n     return                                                   /* @AA */\n  end                                                         /* @A9 */\n  DSNAME = \"'\"STRIP(DSNAME,,\"'\")\"(\"MEMBER\")'\"                 /* @A5 */\n\n  SELECT                                                      /* @A1 */\n     WHEN (SETGDISP = \"VIEW\") THEN                            /* @A1 */\n          \"VIEW DATASET(\"DSNAME\") MACRO(\"EDITMACR\")\",         /* @AH */\n               \"PANEL(\"PANEL01\")\"                             /* @AH */\n     WHEN (SETGDISP = \"EDIT\") THEN                            /* @A1 */\n          \"EDIT DATASET(\"DSNAME\") MACRO(\"EDITMACR\")\",         /* @AH */\n               \"PANEL(\"PANEL01\")\"                             /* @AH */\n     OTHERWISE                                                /* @A1 */\n          \"BROWSE DATASET(\"DSNAME\")\"                          /* @A1 */\n  END                                                         /* @A1 */\nRETURN                                                        /* @AA */\n/*--------------------------------------------------------------------*/\n/*  Display the ISPLog file                                      @AF  */\n/*--------------------------------------------------------------------*/\nISPLOG_FILE:                                                  /* @AF */\n  RECIN.0 = 0                                                 /* @AK */\n  \"VGET (ZLOGNAME)\"                                           /* @AJ */\n  If right(zlogname,2) = '.?' then        /* SYSOUT? */       /* @AJ */\n     Call DO_ISFCALLS                                         /* @AJ */\n  else                                                        /* @AJ */\n     Call ISPLOG_ISPF                                         /* @AJ */\n                                                              /* @AI */\n  IF (RECIN.0 = 0) THEN DO                                    /* @AK */\n     RACFSMSG = \"\"                                            /* @AF */\n     RACFLMSG = \"The ISPF Log file is not allocated or\",      /* @AF */\n                \"may not have been written to.  Verify\",      /* @AF */\n                \"ISPF Settings (=0), 'Log/List',\",            /* @AG */\n                \"'1. Log Data set defaults', has primary\",    /* @AG */\n                \"and secondary pages.  If not, suggest\",      /* @AG */\n                \"making 'Primary pages = 10' and\",            /* @AG */\n                \"'Secondary pages = 10', then\",               /* @AG */\n                \"terminate and re-invoke ISPF.\"               /* @AG */\n     'setmsg msg(RACF011)'                                    /* @AF */\n     RETURN                                                   /* @AK */\n  END                                                         /* @AK */\n\n  K = 0                                                       /* @AI */\n  DO J = RECIN.0 To 1 by -1                                   /* @AI */\n     K = K + 1                                                /* @AI */\n     RECOUT.K = RECIN.J                                       /* @AI */\n  END                                                         /* @AI */\n  RECOUT.0 = K                                                /* @AI */\n  DROP RECIN.\n\n  ADDRESS TSO \"ALLOC F(\"DDNAME\") NEW REUSE\",                  /* @AI */\n              \"LRECL(125) BLKSIZE(0) RECFM(V B A)\",           /* @AI */\n              \"UNIT(VIO) SPACE(1 5) CYLINDERS\"                /* @AI */\n  ADDRESS TSO \"EXECIO * DISKW \"DDNAME\" (STEM RECOUT. FINIS\"   /* @AI */\n  DROP RECOUT.                                                /* @AI */\n                                                              /* @AI */\n  \"LMINIT DATAID(DATAID) DDNAME(\"DDNAME\")\"                    /* @AI */\n  SELECT                                                      /* @AI */\n     WHEN (SETGDISP = \"VIEW\") THEN                            /* @AI */\n          \"VIEW DATAID(\"DATAID\") MACRO(\"EDITMACR\")\",          /* @AI */\n               \"PANEL(\"PANEL01\")\"                             /* @AH */\n     WHEN (SETGDISP = \"EDIT\") THEN                            /* @AI */\n          \"EDIT DATAID(\"DATAID\") MACRO(\"EDITMACR\")\",          /* @AI */\n               \"PANEL(\"PANEL01\")\"                             /* @AH */\n     OTHERWISE                                                /* @AI */\n          \"BROWSE DATAID(\"DATAID\")\"                           /* @AI */\n  END                                                         /* @AI */\n  ADDRESS TSO \"FREE FI(\"DDNAME\")\"                             /* @AI */\n                                                              /* @AF */\nRETURN                                                        /* @AF */\n/*--------------------------------------------------------------------*/\n/*  Obtain the ISPF log file using ISPF                          @AJ  */\n/*--------------------------------------------------------------------*/\nISPLOG_ISPF:                                                  /* @AJ */\n  \"VGET (ZLOGNAME)\"                                           /* @AF */\n  IF (ZLOGNAME = \"\") THEN DO                                  /* @AF */\n     return                                                   /* @AF */\n  END                                                         /* @AF */\n                                                              /* @AF */\n  \"SELECT PGM(ISPLLP) PARM(LOG KEEP) SUSPEND\"                 /* @AF */\n                                                              /* @AF */\n  ADDRESS TSO \"ALLOC FI(\"DDNAME\") DA('\"ZLOGNAME\"') SHR REUS\"  /* @AF */\n  IF (RC > 0) THEN DO                                         /* @AF */\n     RACFSMSG = \"\"                                            /* @AF */\n     RACFLMSG = \"Unable to allocate the ISPF log file:\",      /* @AF */\n                 ZLOGNAME\".  Please investigate.\"             /* @AF */\n     'setmsg msg(RACF011)'                                    /* @AF */\n     return                                                   /* @AF */\n  END                                                         /* @AF */\n                                                              /* @AI */\n  ADDRESS TSO \"EXECIO * DISKR \"DDNAME\" (STEM RECIN. FINIS\"    /* @AI */\n  ADDRESS TSO \"FREE FI(\"DDNAME\")\"                             /* @AI */\n                                                              /* @AI */\nRETURN\n/*--------------------------------------------------------------------*/\n/*  Check for ISPLOG SYSOUT                                      @AJ  */\n/*--------------------------------------------------------------------*/\nDO_ISFCALLS:                                                  /* @AJ */\n  rc=isfcalls('ON')                                           /* @AJ */\n  /*-----------------------------*/                           /* @AJ */\n  /*  Access the STATUS display  */                           /* @AJ */\n  /*-----------------------------*/                           /* @AJ */\n  Address SDSF \"ISFEXEC ST \"userid()                          /* @AJ */\n  /*-------------------*/                                     /* @AJ */\n  /*  Find TSO Userid  */                                     /* @AJ */\n  /*-------------------*/                                     /* @AJ */\n  do ix=1 to JNAME.0                                          /* @AJ */\n     if JNAME.ix = userid() & ,                               /* @AJ */\n        QUEUE.ix = \"EXECUTION\" & ,                            /* @AJ */\n        ACTSYS.ix <> \"\" then do                               /* @AJ */\n        /*-----------------------------------------*/         /* @AJ */\n        /*  Issue the ? (JDS) action against the   */         /* @AJ */\n        /*  row to list the data sets in the job.  */         /* @AJ */\n        /*-----------------------------------------*/         /* @AJ */\n        Address SDSF \"ISFACT ST TOKEN('\"TOKEN.ix\"')\",         /* @AJ */\n                     \"PARM(NP ?) ( prefix jds_\"               /* @AJ */\n        /*---------------------------------------------*/     /* @AJ */\n        /*  Find the ISPLOG data sets and read them    */     /* @AJ */\n        /*  using ISFBROWSE.  Use isflinelim to limit  */     /* @AJ */\n        /*  the number of REXX variables returned.     */     /* @AJ */\n        /*---------------------------------------------*/     /* @AJ */\n        isflinelim=5000                                       /* @AJ */\n        ky = 1                                                /* @AJ */\n        racfadm. = ''                                         /* @AJ */\n        do jx=1 to jds_DDNAME.0                               /* @AJ */\n           if left(jds_DDNAME.jx,6) = \"ISPLOG\" then do        /* @AJ */\n              /*---------------------------------------*/     /* @AJ */\n              /*  Read the records from the data set.  */     /* @AJ */\n              /*---------------------------------------*/     /* @AJ */\n              do until isfnextlinetoken=''                    /* @AJ */\n                 Address SDSF \"ISFBROWSE ST\",                 /* @AJ */\n                              \"TOKEN('\"jds_TOKEN.jx\"')\"       /* @AJ */\n                 do kx=1 to isfline.0                         /* @AJ */\n                    recin.ky = isfline.kx                     /* @AJ */\n                    ky = ky + 1                               /* @AJ */\n                 end                                          /* @AJ */\n                 recin.0 = ky - 1                             /* @AJ */\n                 /*-----------------------------*/            /* @AJ */\n                 /*  Set start for next browse  */            /* @AJ */\n                 /*-----------------------------*/            /* @AJ */\n                 isfstartlinetoken = isfnextlinetoken         /* @AJ */\n              end                                             /* @AJ */\n           end                                                /* @AJ */\n        end                                                   /* @AJ */\n     end                                                      /* @AJ */\n  end                                                         /* @AJ */\n  rc=isfcalls('OFF')                                          /* @AJ */\nRETURN                                                        /* @AJ */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RACFMSG": {"ttr": 951, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x01c\\x00)\\x01 \\x17/\\x01 '?\\x18\\x13\\x03\\t\\x01\\xc8\\x00\\x00\\xd9\\xc1\\xc3\\xc6\\xc1\\xc4\\xd4@@@\"", "ispf": {"version": "01.99", "flags": 0, "createdate": "2020-06-20T00:00:00", "modifydate": "2020-09-29T18:13:29", "lines": 777, "newlines": 456, "modlines": 0, "user": "RACFADM"}, "text": "/*%NOCOMMENT====================* REXX *==============================*/\n/*  PURPOSE:  RACFADM - RACF Messages - Menu Option M                 */\n/*--------------------------------------------------------------------*/\n/* FLG  YYMMDD  USERID   DESCRIPTION                                  */\n/* ---  ------  -------  -------------------------------------------- */\n/* @AJ  200918  RACFA    Fix 'Type=A', was displaying same msg        */\n/* @AI  200903  RACFA    Added 'OMVS' to USS messages                 */\n/* @AH  200903  RACFA    Display all ICH408I msgs, except pswd invalid*/\n/* @AG  200702  RACFA    Allow symbolic in dsname                     */\n/* @AF  200701  RACFA    Initialize command field (zcmd)              */\n/* @AE  200630  RACFA    Added \"=\" for today's date                   */\n/* @AD  200630  RACFA    Allow TSO PREFIX has HLQ in dsname           */\n/* @AC  200629  RACFA    Fixed EJES, when date=*                      */\n/* @AB  200629  RACFA    Fix display SYSLOG/OPERLOG, del some code    */\n/* @AA  200629  RACFA    Allow an asterick as a date                  */\n/* @A9  200627  RACFA    Batch, chg parm syntax and upper case        */\n/* @A8  200627  RACFA    Create variables for USERID and LPAR         */\n/* @A7  200627  RACFA    Executing batch, chg display of parameters   */\n/* @A6  200627  RACFA    Added EJES and chged variable names          */\n/* @A5  200625  RACFA    Make DATE=today and LOG=A as default         */\n/* @A4  200624  RACFA    ICH408I in W7 for SYSLOG and W8 for OPERLOG  */\n/* @A3  200624  RACFA    When batch, fix comments in SYSTSPRT         */\n/* @A2  200624  RACFA    Get site variable to use SYSLOG or OPERLOG   */\n/* @A1  200622  TRIDJK   Fix JDATE                                    */\n/* @A0  200620  RACFA    Created REXX                                 */\n/*====================================================================*/\nTODAY      = DATE(\"U\")\nENV        = SYSVAR(SYSENV)\nUSERID     = USERID()                                         /* @A8 */\nLPAR       = MVSVAR(\"SYMDEF\",\"SYSNAME\")                       /* @A8 */\n\nADDRESS ISPEXEC\n  ADDRESS TSO \"PROFILE VARSTORAGE(HIGH)\"\n  IF (ENV = \"FORE\") THEN\n     CALL FOREGROUND\n  ELSE\n     CALL BATCH\nEXIT\n/*--------------------------------------------------------------------*/\n/*  Execution in foreground mode                                      */\n/*--------------------------------------------------------------------*/\nFOREGROUND:\n  PANEL01    = \"RACFMSG\"            /* Pop-up data entry  */\n  PANEL02    = \"RACFDISP\"           /* ICH408I Color=Turq */\n  SKELETON1  = \"RACFJOB\"            /* JOB card           */\n  SKELETON2  = \"RACFMSG\"            /* TSO PARM=RACFERRS  */\n\n  \"VGET (RACFMID  RACFMLPR RACFMDAT RACFMTYP\",\n        \"RACFMUSS RACFMMOD RACFMJCL RACFMSCN\",                /* @A6 */\n        \"SETGPREF SETMTRAC SETLMSG  SETPMSG  SETDMSG\",        /* @AD */\n        \"ZLLGJOB1 ZLLGJOB2 ZLLGJOB3 ZLLGJOB4) PROFILE\"\n  If (SETMTRAC <> 'NO') then do\n     Say \"*\"COPIES(\"-\",70)\"*\"\n     Say \"*\"Center(\"Begin Program = \"REXXPGM,70)\"*\"\n     Say \"*\"COPIES(\"-\",70)\"*\"\n     if (SETMTRAC <> 'PROGRAMS') THEN\n        interpret \"Trace \"SUBSTR(SETMTRAC,1,1)\n  end\n  IF (RACFMID  = \"\") THEN RACFMID  = \"*\"\n  IF (RACFMLPR = \"\") THEN RACFMLPR = \"*\"\n  SELECT                                                      /* @AA */\n     WHEN (RACFMDAT = \"\")  THEN RACFMDAT = DATE(\"U\")          /* @AA */\n     WHEN (RACFMDAT = \"*\") THEN NOP                           /* @AA */\n     OTHERWISE RACFMDAT = DATE(\"U\")                           /* @AA */\n  END                                                         /* @AA */\n  IF (RACFMTYP = \"\") THEN RACFMTYP = \"A\"\n  IF (RACFMUSS = \"\") THEN RACFMUSS = \"N\"\n  RACFMMOD = \"F\"                                              /* @AA */\n  IF (RACFMJCL = \"\") THEN RACFMJCL = \"Y\"\n  IF (SETLMSG  = \"\") THEN SETLMSG  = \"O\"                      /* @A6 */\n  IF (SETPMSG  = \"\") THEN SETPMSG  = \"SDSF\"                   /* @A6 */\n  RACFMSCN = \"A\"                                              /* @A5 */\n\n  /*-----------------------------------------------*/\n  /* If IBM's ISPF JOB card variable is:           */\n  /*   ZLLGJOB1 =                                  */\n  /* or                                            */\n  /*   ZLLGJOB1 = //USERID   JOB (ACCOUNT),'NAME'  */\n  /* or                                            */\n  /*   ZLLGJOB1 = //@??##### JOB (??T),'NAME',etc. */\n  /*-----------------------------------------------*/\n  PARSE UPPER VAR ZLLGJOB1 W1 .\n  IF (ZLLGJOB1 = \"\") | (W1 = \"//USERID\") then do\n     ZLLGJOB1 = \"//job-name JOB (acct),'first-last-name',\"\n     ZLLGJOB2 = \"//         MSGCLASS=?,CLASS=?,\"||,\n                \"REGION=0M,NOTIFY=&SYSUID\"\n     \"VPUT (ZLLGJOB1 ZLLGJOB2)\"\n  END\n\n  CALL CLIST_DSN                                              /* @A6 */\n\n  DO FOREVER\n     DSNRPT = USERID\".RACFERRS.RPT\"RANDOM()\n     ZCMD = \"\"                                                /* @AF */\n     \"DISPLAY PANEL(\"PANEL01\")\"\n     IF (RC = 8) THEN LEAVE\n     IF (RACFMDAT = \"*\") THEN                                 /* @AA */\n        JDATE = \"*\"\n     ELSE DO                                                  /* @AA */\n        PARSE VAR racfmdat MM \"/\" DD \"/\" YY .\n        YYYYMMDD = \"20\"YY\"\"MM\"\"DD\n        DDD      = DATE(\"D\",YYYYMMDD,\"S\")\n        JDATE    = YY\"\"RIGHT(DDD,3,'0')                       /* @A1 */\n     END                                                      /* @AA */\n\n     IF (RACFMMOD = \"F\") THEN\n        CALL FOREGROUND_LOG\n     ELSE\n        CALL FOREGROUND_CREATE_JCL\n  END\n\n  \"VPUT (RACFMID  RACFMLPR RACFMDAT RACFMTYP\",                /* @AA */\n        \"RACFMUSS RACFMMOD RACFMJCL RACFMSCN\",                /* @A6 */\n        \"SETGPREF SETMTRAC SETLMSG  SETPMSG  SETDMSG\",        /* @AD */\n        \"ZLLGJOB1 ZLLGJOB2 ZLLGJOB3 ZLLGJOB4) PROFILE\"\n\n  If (SETMTRAC <> 'NO') then do\n     Say \"*\"COPIES(\"-\",70)\"*\"\n     Say \"*\"Center(\"End Program = \"REXXPGM,70)\"*\"\n     Say \"*\"COPIES(\"-\",70)\"*\"\n  end\n\nRETURN\n/*--------------------------------------------------------------------*/\n/*  Execution in batch mode                                           */\n/*--------------------------------------------------------------------*/\nBATCH:\n  ADDRESS TSO \"EXECIO * DISKR PARMS (STEM PARMS. FINIS\"\n  DO J = 1 TO PARMS.0\n     SELECT\n        WHEN (POS(\"USERID=\",PARMS.J)  > 0) THEN               /* @A9 */\n             PARSE UPPER VAR PARMS.J . \"USERID=\"RACFMID .     /* @A9 */\n        WHEN (POS(\"LPAR=\",PARMS.J)    > 0) THEN               /* @A9 */\n             PARSE UPPER VAR PARMS.J . \"LPAR=\"RACFMLPR .      /* @A9 */\n        WHEN (POS(\"DATE=\",PARMS.J)    > 0) THEN               /* @A9 */\n             PARSE UPPER VAR PARMS.J . \"DATE=\"RACFMDAT .      /* @A9 */\n        WHEN (POS(\"USSONLY=\",PARMS.J) > 0) THEN               /* @A9 */\n             PARSE UPPER VAR PARMS.J . \"USSONLY=\"RACFMUSS .   /* @A9 */\n        WHEN (POS(\"TYPE=\",PARMS.J)    > 0) THEN               /* @A9 */\n             PARSE UPPER VAR PARMS.J . \"TYPE=\"RACFMTYP .      /* @A9 */\n        WHEN (POS(\"LOG=\",PARMS.J)     > 0) THEN               /* @A9 */\n             PARSE UPPER VAR PARMS.J . \"LOG=\"SETLMSG .        /* @A9 */\n        WHEN (POS(\"SCAN=\",PARMS.J)    > 0) THEN               /* @A9 */\n             PARSE UPPER VAR PARMS.J . \"SCAN=\"RACFMSCN .      /* @A9 */\n        WHEN (POS(\"PROGRAM=\",PARMS.J) > 0) THEN               /* @A9 */\n             PARSE UPPER VAR PARMS.J . \"PROGRAM=\"SETPMSG .    /* @A9 */\n        OTHERWISE\n             NOP\n     END /* Select */\n  END J\n  DROP PARMS.\n\n  IF (RACFMID  = \"\")  THEN RACFMID  = \"*\"\n  IF (RACFMLPR = \"\")  THEN RACFMLPR = \"*\"\n  IF (RACFMDAT = \"\")  THEN RACFMDAT = DATE(\"U\")\n  IF (RACFMDAT = \"=\") THEN RACFMDAT = DATE(\"U\")               /* @AE */\n  IF (RACFMUSS = \"\")  THEN RACFMUSS = \"N\"\n  IF (RACFMTYP = \"\")  THEN RACFMTYP = \"A\"\n  IF (RACFMSCN = \"\")  THEN RACFMSCN = \"A\"                     /* @A6 */\n  if (RACFMDAT = \"*\") THEN                                    /* @AA */\n     JDATE = \"*\"\n  else do                                                     /* @AA */\n     PARSE VAR racfmdat MM \"/\" DD \"/\" YY .\n     YYYYMMDD = \"20\"YY\"\"MM\"\"DD\n     DDD      = DATE(\"D\",YYYYMMDD,\"S\")\n     JDATE    = YY\"\"RIGHT(DDD,3,'0')                          /* @A1 */\n  END                                                         /* @AA */\n  IF (RACFMSCN = \"A\") THEN DO                                 /* @A6 */\n     SELECT                                                   /* @A6 */\n        WHEN (SETPMSG = \"EJES\") THEN DO                       /* @A6 */\n             IF (SETLMSG = \"S\") THEN\n                EJESLOG = \"SYSLOG\"\n             ELSE\n                EJESLOG = \"OPERLOG\"\n             CALL EJES_LOG RACFMDAT EJESLOG RACFMLPR          /* @A6 */\n        END\n        OTHERWISE                                             /* @A6 */\n             CALL SDSF_LOG                                    /* @A6 */\n     END                                                      /* @A6 */\n  END                                                         /* @A6 */\n  ELSE\n     CALL DSN_LOG                                             /* @A6 */\n\n  SAY \"*\"COPIES(\"-\",70)\"*\"                                    /* @A7 */\n  SAY \"*\"CENTER(\"RACFADM - Messages\",70)\"*\"                   /* @A7 */\n  SAY \"*\"COPIES(\"-\",70)\"*\"                                    /* @A7 */\n  SAY \" \"                                                     /* @A7 */\n  SAY \"   Total:\"                                             /* @A7 */\n  SAY \"     Messages = \"TOTALMSGS                             /* @A7 */\n  SAY \" \"                                                     /* @A7 */\n  SAY \"   Parameters:\"                                        /* @A7 */\n  SAY \"     Userid   = \"LEFT(RACFMID,8),                      /* @A7 */\n      \" (\"USERID\", *)\"                                        /* @A8 */\n  SAY \"     Lpar     = \"LEFT(racfmlpr,8),                     /* @A7 */\n      \" (\"LPAR\", *)\"                                          /* @A8 */\n  SAY \"     Date     = \"LEFT(racfmdat,8),                     /* @A7 */\n      \" (mm/dd/yy, =, *)\"                                     /* @AE */\n  SAY \"     Type     = \"LEFT(racfmtyp,8),                     /* @A7 */\n      \" (A=All, I=Insufficient, V=Violation)\"                 /* @A7 */\n  SAY \"     USS      = \"LEFT(racfmuss,8),                     /* @A7 */\n      \" (Y=Yes, N=No)\"                                        /* @A7 */\n  SAY \"     Log      = \"LEFT(SETLMSG,8),                      /* @A7 */\n      \" (O=Operlog, S=Syslog)\"                                /* @A7 */\n  SAY \"     Scan     = \"LEFT(RACFMSCN,8),                     /* @A7 */\n      \" (A=Active log, B=Backup log)\"                         /* @A7 */\n  SAY \"     Program  = \"LEFT(SETPMSG,8),                      /* @A7 */\n      \" (EJES, SDSF)\"                                         /* @A7 */\n  SAY \" \"                                                     /* @A7 */\n  ADDRESS TSO \"EXECIO * DISKW ERRORS (STEM LOGMSG. FINIS\"\n  EXECIORC = RC\n  DROP LOGMSG.\n  IF (EXECIORC > 0) THEN DO\n     SAY \"ERROR - Missing DD card ERRORS, unable to write\",\n         \"the ICH408I messages.\"\n     RETURN\n  END\nRETURN\n/*--------------------------------------------------------------------*/\n/*  Foreground, create batch JCL (Mode = B)                           */\n/*--------------------------------------------------------------------*/\nFOREGROUND_CREATE_JCL:\n  PARSE VAR TMPDMSG2 . \"(\" W1 \")\" .                           /* @AG */\n  IF (W1 = \"\") THEN DO\n     X = OUTTRAP(\"LC.\")\n     ADDRESS TSO \"LISTCAT ENT('\"TMPDMSG2\"')\"                  /* @AG */\n     X = OUTTRAP(\"OFF\")\n     PARSE VAR LC.1 W1 W2 .\n     DROP LC.                                                 /* @AG */\n     IF (W1 = \"GDG\") & (W2 = \"BASE\") THEN DO\n        CALL GDG_BASE_GET_GOVO                                /* @A6 */\n        IF (TMPDMSG1 = \"\") THEN DO\n           RACFSMSG = \"Invalid Date\"\n           RACFLMSG = \"There are no GDG genarations\",\n                      \"with a date of \"RACFMDAT\".\"\n           \"SETMSG MSG(RACF011)\"\n           RETURN\n        END\n     END\n  END\n\n  \"FTOPEN TEMP\"\n  \"VGET (ZTEMPF)\"\n  \"FTINCL \"SKELETON1\n  \"FTINCL \"SKELETON2\n  \"FTCLOSE\"\n\n  IF (RACFMJCL = \"Y\") THEN\n     \"EDIT DATASET('\"ztempf\"')\"\n  ELSE DO\n     ADDRESS TSO \"SUBMIT '\"ztempf\"'\"\n     RACFSMSG = \"Job Submitted\"\n     RACFLMSG = \"Batch job was submitted.  Invoke SDSF\",\n                \"to view output\"\n     \"SETMSG MSG(RACF011)\"\n  END\n\nRETURN\n/*--------------------------------------------------------------------*/\n/*  Foreground, process log (Mode = A)                                */\n/*--------------------------------------------------------------------*/\nFOREGROUND_LOG:\n  LOGMSG.0 = 0\n\n  IF (RACFMSCN = \"A\") THEN DO   /* Active OPERLOG? */         /* @A6 */\n     SELECT                                                   /* @A6 */\n        WHEN (SETPMSG = \"EJES\") THEN DO                       /* @A6 */\n             IF (SETLMSG = \"S\") THEN                          /* @A6 */\n                EJESLOG = \"SYSLOG\"                            /* @A6 */\n             ELSE                                             /* @A6 */\n                EJESLOG = \"OPERLOG\"                           /* @A6 */\n             CALL EJES_LOG RACFMDAT EJESLOG RACFMLPR          /* @A6 */\n        END                                                   /* @A6 */\n        OTHERWISE                                             /* @A6 */\n             CALL SDSF_LOG                                    /* @A6 */\n     END                                                      /* @A6 */\n  END                                                         /* @A6 */\n  ELSE DO\n     PARSE VAR TMPDMSG2 . \"(\" W1 \")\" .                        /* @AG */\n     IF (W1 = \"\") THEN DO\n        X = OUTTRAP(\"LC.\")\n        ADDRESS TSO \"LISTCAT ENT('\"TMPDMSG2\"')\"               /* @AG */\n        X = OUTTRAP(\"OFF\")\n        PARSE VAR LC.1 W1 W2 .\n        DROP LC.                                              /* @AG */\n        IF (W1 = \"GDG\") & (W2 = \"BASE\") THEN DO\n           CALL GDG_BASE_GET_GOVO                             /* @A6 */\n           IF (TMPDMSG1 = \"\") THEN DO                         /* @AG */\n              RACFSMSG = \"Invalid Date\"\n              RACFLMSG = \"There are no GDG genarations\",\n                         \"with a date of \"RACFMDAT\".\"\n              \"SETMSG MSG(RACF011)\"\n              RETURN\n           END\n           TMPDSN = \"'\"TMPDMSG1\"'\"                            /* @AG */\n        END\n        ELSE\n           TMPDSN = \"'\"TMPDMSG2\"'\"                            /* @AG */\n     END\n     ELSE\n        TMPDSN = \"'\"TMPDMSG2\"'\"                               /* @AG */\n\n     ADDRESS TSO \"ALLOCATE FI(BKPLOG) DSN(\"TMPDSN\")\",         /* @AD */\n                 \"SHR REUSE BUFNO(30) LRECL(259)\"\n     CALL DSN_LOG                                             /* @A6 */\n     ADDRESS TSO \"FREE FI(BKPLOG)\"\n  END\n  IF (LOGMSG.0 = 0) THEN DO\n     RACFSMSG = \"No Security Errors\"\n     RACFLMSG = \"There are no ICH408I messages\",\n                \"with the search criteria specified.\"\n     \"SETMSG MSG(RACF011)\"\n  END\n  ELSE DO\n     ADDRESS TSO \"ALLOCATE FI(RACFERRS)\",\n         \"NEW REUSE UNIT(VIO)\",\n         \"LRECL(240) BLKSIZE(0) RECFM(V B)\",\n         \"CYLINDERS SPACE(10 10)\"\n     ADDRESS TSO \"EXECIO * DISKW RACFERRS (STEM LOGMSG. FINIS\"\n     DROP LOGMSG.\n     RACFSMSG = TOTALMSGS\" Total Errors\"\n     RACFLMSG = \"There are \"TOTALMSGS\" total RACF\",\n               \"errors displayed.\"\n     \"SETMSG MSG(RACF011)\"\n     \"VGET (ZPF10 ZPF11)\"\n     SAVEPF10 = ZPF10\n     SAVEPF11 = ZPF11\n     ZPF10    = \"LEFT 55\"\n     ZPF11    = \"RIGHT 55\"\n     \"VPUT (ZPF10 ZPF11)\"\n     \"LMINIT DATAID(DATAID) DDNAME(RACFERRS)\"\n     \"VIEW DATAID(\"DATAID\") PANEL(\"PANEL02\")\"\n     ADDRESS TSO \"FREE FI(RACFERRS)\"\n     ZPF10    = SAVEPF10\n     ZPF11    = SAVEPF11\n     \"VPUT (ZPF10 ZPF11)\"\n  END\nRETURN\n/*--------------------------------------------------------------------*/\n/*  SDSF, scan the active log (Scan = A)                              */\n/*--------------------------------------------------------------------*/\nSDSF_LOG:                                                     /* @A6 */\n  IF (JDATE <> \"*\") THEN DO                                   /* @AA */\n     ISFLOGSTARTDATE = RACFMDAT\n     ISFLOGSTARTTIME = \"00:00\"\n     ISFLOGSTOPDATE  = RACFMDAT  /* DATE - MM/DD/YY */\n     ISFLOGSTOPTIME  = \"23:59\"   /* Time - hh:mm:ss */\n  END                                                         /* @AA */\n  ISFLINELIM      = 0\n\n  RC = ISFCALLS(\"ON\")\n  IF (RC <> 0) THEN DO\n     IF (ENV = \"FORE\") THEN DO\n        RACFLMSG = \"SDSF is not active on this lpar.\"\n        \"SETMSG MSG(RACF011)\"\n     END\n     ELSE\n        SAY \"ERROR - SDSF is not active on this lpar.\"\n     RETURN\n  END\n\n  KLPAR = MVSVAR(\"SYMDEF\",\"SYSKLPAR\")     /* GDPS K-Lpar? */  /* @A2 */\n  SELECT                                                      /* @A2 */\n     WHEN (KLPAR = \"Y\") THEN DO                               /* @A2 */\n          ISFSYSID = SUBSTR(LPAR,2) /* Chg IEFSYSID=LPAR? */  /* @A2 */\n          ADDRESS SDSF \"ISFLOG READ TYPE(SYSLOG)\"             /* @A2 */\n     END                                                      /* @A2 */\n     OTHERWISE DO                                             /* @A2 */\n          IF (RACFMLPR = \"*\") | (KLPAR <> \"\") THEN            /* @A6 */\n             ADDRESS SDSF \"ISFLOG READ TYPE(OPERLOG)\"         /* @A6 */\n          ELSE DO                                             /* @A6 */\n             ISFSYSID = RACFMLPR                              /* @A2 */\n             ADDRESS SDSF \"ISFLOG READ TYPE(SYSLOG)\"          /* @A6 */\n          END\n     END                                                      /* @A2 */\n  END                                                         /* @A2 */\n  RC=ISFCALLS(\"OFF\")\n\n  K = 0\n  TOTALMSGS = 0\n  CALL PROCESS_LOG_RECS                                       /* @A6 */\n  LOGMSG.0 = K\nRETURN\n/*--------------------------------------------------------------------*/\n/*  Scan the backup log dataset (Scan = B)                            */\n/*--------------------------------------------------------------------*/\nDSN_LOG:                                                      /* @A6 */\n  K         = 0\n  READRC    = 0\n  TOTALMSGS = 0\n  DO WHILE READRC = 0\n     ADDRESS TSO \"EXECIO 300000 DISKR BKPLOG (STEM ISFLINE.\"\n     READRC = RC\n     CALL PROCESS_LOG_RECS                                    /* @A6 */\n  END\n  ADDRESS TSO \"EXECIO 0 DISKR BKPLOG (FINIS\"\n  LOGMSG.0 = K\nRETURN\n/*--------------------------------------------------------------------*/\n/*  Proces log records, find ICH408I msgs that meet search criteria   */\n/*--------------------------------------------------------------------*/\nPROCESS_LOG_RECS:                                             /* @A6 */\n  DO J = 1 TO ISFLINE.0-1\n     PARSE VAR ISFLINE.J W1 W2 W3 W4 W5 W6 W7 W8 W9 W10\n     IF (W7 = \"ICH408I\") | (W8 = \"ICH408I\") THEN DO           /* @A4 */\n        if (jdate = W4) | (jdate = \"*\") then DO               /* @AA */\n           IF (RACFMLPR = \"*\") | (RACFMLPR = W3) THEN DO\n              MSGBEG = J\n              MSGEND = J + 12\n              DO M = MSGBEG TO MSGEND\n                 PARSE VAR ISFLINE.M W1 .\n                 IF (W1 = \"E\") THEN DO\n                    MSGEND = M\n                    LEAVE\n                 END\n              END M\n              DO M = MSGBEG TO MSGEND\n                 SELECT\n                    WHEN (RACFMTYP = 'V') THEN\n                         FOUND = POS(\"VIOLATION\",ISFLINE.M)\n                    WHEN (RACFMTYP = 'I') THEN\n                         FOUND = POS(\"INSUFFICIENT\",ISFLINE.M)\n                    OTHERWISE DO                             /* @AH */\n                         FOUND = POS(\"PASSWORD\",ISFLINE.M)    /* @AH */\n                         IF (FOUND > 0) THEN                  /* @AH */\n                            FOUND = 00                        /* @AH */\n                         ELSE                                 /* @AH */\n                            FOUND = 99                        /* @AH */\n                    END                                       /* @AH */\n                 END                                          /* @AH */\n                 IF (FOUND > 0) THEN DO\n                    IF (RACFMID <> \"*\") THEN DO\n                       DO N = MSGBEG TO MSGEND\n                          FOUND = POS(RACFMID,ISFLINE.N)\n                          IF (FOUND > 0) THEN LEAVE N\n                       END N\n                       IF (FOUND = 0) THEN LEAVE M\n                    END\n                    IF (RACFMUSS = \"Y\") THEN DO\n                       DO N = MSGBEG TO MSGEND\n                          FOUND = POS(\"EFFECTIVE\",ISFLINE.N)\n                          IF (FOUND > 0) THEN LEAVE N\n                          FOUND = POS(\"OMVS\",ISFLINE.N)       /* @AI */\n                          IF (FOUND > 0) THEN LEAVE N         /* @AI */\n                       END N\n                       IF (FOUND = 0) THEN LEAVE M\n                    END\n                    TOTALMSGS = TOTALMSGS + 1\n                    DO N = MSGBEG TO MSGEND\n                       K = K + 1\n                       LOGMSG.K = ISFLINE.N\n                    END N\n                    LEAVE M                                   /* @AJ */\n                 END /* If FOUND */\n              END M\n           END /* If RACFMLPR*/\n        END /* If jdate */\n     END /* If ICH408I */\n  END J\n  DROP ISFLINE.\nRETURN\n/*--------------------------------------------------------------------*/\n/*  When the 'Backup log' dataset is a base GDG, obtain the           */\n/*  the generation with a create date of minus 1, due to the          */\n/*  backup was taken after midnight                                   */\n/*--------------------------------------------------------------------*/\nGDG_BASE_GET_GOVO:                                            /* @A6 */\n  /*------------------------------------*/\n  /*  Convert Cregorian to Julian date  */\n  /*------------------------------------*/\n  MM   = SUBSTR(RACFMDAT,1,2)\n  DD   = SUBSTR(RACFMDAT,4,2)\n  CC   = SUBSTR(DATE(\"S\"),1,2)\n  YY   = SUBSTR(RACFMDAT,7,2)\n  IF (YY//4=0) & (YY<>0 | CC//4=0) THEN\n     JULTAB=DD'3129313031303131303130'\n  ELSE\n     JULTAB=DD'3128313031303131303130'\n  DAYS=0\n  DO I=1 TO MM\n     MDAYS=SUBSTR(JULTAB,I*2-1,2)\n     DAYS=DAYS+MDAYS\n  END\n  DAYS = DAYS + 1\n  YYYY = SUBSTR(DATE(\"S\"),1,4)\n  IF (YYYY//4 = 0) THEN   /* Leap year? */\n     NOOFDAYS = 366\n  ELSE\n     NOOFDAYS = 365\n  IF (DAYS = NOOFDAY) THEN DO\n     DAYS = \"001\"\n     YY   = YY + 1\n  END\n  JULIAN=CC||YY'.'RIGHT(DAYS,3,'0')\n\n  X = OUTTRAP(\"IDCAMS.\")\n  ADDRESS TSO \"LISTCAT ENT('\"TMPDMSG2\"') ALL\"                 /* @AG */\n  X        = OUTTRAP(\"OFF\")\n  K        = 0\n  TMPDMSG1 = \"\"\n  DO J = 1 TO IDCAMS.0\n     PARSE VAR IDCAMS.J W1 W2 W3 .\n     IF (W1 = \"NONVSAM\") THEN DO\n        L = J + 3\n        PARSE VAR IDCAMS.L AW1 \"CREATION--------\" AW2\n        IF (AW2 = JULIAN) THEN DO\n           TMPDMSG1 = W3\n           LEAVE\n        END\n     END\n  END\n  DROP IDCAMS.\nRETURN\n/*--------------------------------------------------------------------*/\n/*  Get CLIST/REXX dataset name, used in batch JCL to invoke REXX pgm */\n/*--------------------------------------------------------------------*/\n/*  1) The 'ALTLIB DISPLAY' statement, will look for                  */\n/*     'Application-level' in the display in order to obtain          */\n/*     the DDname of the ALTLIBed dataset                             */\n/*       Current search order (by DDNAME) is:                         */\n/*       Application-level CLIST DDNAME=SYS00529                      */\n/*       System-level EXEC       DDNAME=SYSEXEC                       */\n/*       System-level CLIST      DDNAME=SYSPROC                       */\n/*  2) The 'LISTA STATUS' will display all the DDnames and datasets   */\n/*     allocated, allowing the capability to obtain the dataset name  */\n/*     allocated to the 'Application-level CLIST' ddname (SYS#####)   */\n/*--------------------------------------------------------------------*/\nCLIST_DSN:                                                    /* @A6 */\n  X = OUTTRAP(\"RECALT.\")\n  ADDRESS TSO \"ALTLIB DISPLAY\"\n  X = OUTTRAP(\"OFF\")\n\n  IF (SUBSTR(RECALT.2,1,3) = \"IKJ\") THEN\n     PARSE VAR RECALT.2 . W1 W2 \"DDNAME=\"DDALTLIB\n  ELSE\n     PARSE VAR RECALT.2 W1 W2 \"DDNAME=\"DDALTLIB\n  DROP RECALT.\n  RC = 0\n  IF (W1 <> \"Application-level\") THEN DO\n     RC = 8\n     return\n  END\n\n  X = OUTTRAP(\"RECLA.\")\n  ADDRESS TSO \"LISTA STATUS\"\n  X = OUTTRAP(\"OFF\")\n  do J = 1 TO RECLA.0\n     PARSE VAR RECLA.J W1 .\n     IF (W1 = DDALTLIB) THEN DO\n        K = J - 1\n        DSNREXX = RECLA.K\n        LEAVE\n     END\n  end\n  DROP RECLA. W1 DDALTLIB\nRETURN\n/*--------------------------------------------------------------------*/\n/*  (E)JES - Scan for IRR and ICH Messages                            */\n/*--------------------------------------------------------------------*/\n/*                                                                    */\n/*  This REXX extracts IRR and ICH messages from OPERLOG, SYSLOG or   */\n/*  DLOG using (E)JES.                                                */\n/*                                                                    */\n/*  1) Input:                                                         */\n/*       There are three positional input parameters:                 */\n/*         logdate = mm/dd/yy                                         */\n/*         logtype = SYSLOG or OPERLOG                                */\n/*         logsys  = system name                                      */\n/*                                                                    */\n/*       OPERLOG and DLOG can display IRR and ICH messages from       */\n/*       all connected systems by specifying an asterisk (*)          */\n/*       for logsys.                                                  */\n/*                                                                    */\n/*       JES2 SYSLOG is not a merged log and will display only        */\n/*       one system at a time.  An asterisk is not valid for          */\n/*       JES2 SYSLOG.                                                 */\n/*                                                                    */\n/*       Sample invocation extracting the IRR and ICH messages        */\n/*       logged to SYSLOG on June 26, 2020 by system MVSA0.           */\n/*          RACFSCAN 06/26/20 SYSLOG MVSA0                            */\n/*                                                                    */\n/*   1) SCAN:                                                         */\n/*       The scan is a trivial operation for (E)JES OPERLOG.          */\n/*       One can simply set date/time boundaries and filter           */\n/*       on system name and messages that start with IRR and          */\n/*       ICH. The OPERLOG browser processes Message Descrip-          */\n/*       tor Blocks (MDBs) and fully understands multi-line           */\n/*       messages, etc. This scan runs at machine speed.              */\n/*                                                                    */\n/*       For SYSLOG and DLOG, the scan task takes longer              */\n/*       because some of the logic is implemented in REXX.            */\n/*       (E)JES could (at machine speed) display messages             */\n/*       that start with IRR and ICH but, because SYSLOG and          */\n/*       DLOG are just simple text files and not a logical            */\n/*       collection of MDBs like OPERLOG, the result would            */\n/*       have been one line per message only. Many IRR and            */\n/*       ICH messages are either multiline messages (MLWTOs)          */\n/*       or single line WTOs continued on a second line when          */\n/*       formatted by MVS. Therefore, this exec implements            */\n/*       logic to examine the lines immediately following             */\n/*       the located IRR or ICH message to see if any of              */\n/*       them should be queued after the message line.                */\n/*                                                                    */\n/*       A single system search through the DLOG can be slow          */\n/*       in a multisystem environment because DLOG is a               */\n/*       JESplex-wide merged log and the exec must filter             */\n/*       out all of the ICH and IRR messages issued by                */\n/*       systems other than the requested one.                        */\n/*                                                                    */\n/*   3) OUTPUT:                                                       */\n/*       The exec creates a stem variable called LOGMSG.              */\n/*       A line of code near the logical end echos this stem          */\n/*       using SAY statements:                                        */\n/*                                                                    */\n/*       do i = 1 to LOGMSG.0;say LOGMSG.i;end                        */\n/*                                                                    */\n/*       This is done for the batch job use case. You can             */\n/*       replace this with any processing desired.                    */\n/*                                                                    */\n/* CHANGE-ACTIVITY =                                                  */\n/*   2020/06/27 = Initial version authored by Ed Jaffe at             */\n/*                Phoenix Software International, Inc.                */\n/*--------------------------------------------------------------------*/\nEJES_LOG:\n  logdate = \"09/04/19\"  /* mm/dd/yy              */\n  logtype = \"SYSLOG\"    /* SYSLOG or OPERLOG     */\n  logsys  = \"MVSA0\"     /* Lpar (Sysname)        */\n\n  parse UPPER arg logdate logtype logsys /* Get Parms */\n\n  if (logdate = \"*\") then                                     /* @AC */\n     logdate = \"01/01/90\"                                     /* @AC */\n\n  rc = EJESREXX(\"ON\")\n  dateparm = LEFT(DATE(\"Standard\",logdate,\"Usa\"),4) ||,\n             DATE(\"Days\",logdate,\"Usa\")\n  datepdot = LEFT(DATE(\"Standard\",logdate,\"Usa\"),4) ||,\n             \".\" || DATE(\"Days\",logdate,\"Usa\")\n\n  select\n    /******************/\n    /* Handle OPERLOG */\n    /******************/\n    when logtype = \"OPERLOG\" then do\n      QUEUE \"MASKCHAR * %\"\n      QUEUE \"DATEFMT YYYYDDD .\"\n      QUEUE \"LOG\" logtype\n      QUEUE \"XSELECT\"\n      QUEUE \":<\"logsys\"><><><><><><><><><><>\"||,\n             \"<><><><><><IRR*><ICH*><><><><><>\"||,\n             \"<00.00-\"datepdot\">\"||,\n             \"<23.59-\"datepdot\">\"\n      QUEUE \"\"\n      ADDRESS EJES \"EXECAPI * (PRE log_ TERM\"\n      end /* when */\n\n    /**************************/\n    /* Handle SYSLOG and DLOG */\n    /**************************/\n    when logtype = \"SYSLOG\" then do\n\n      msgprfx.1=\"IRR\";msgprfx.2=\"ICH\";msgprfx.0=2\n      IRRline.0 = 0;IRRtime.0 = 0\n      ICHline.0 = 0;ICHtime.0 = 0\n\n      do msgidx = 1 to msgprfx.0\n        DELSTACK\n        QUEUE \"MASKCHAR * %\"\n        QUEUE \"DATEFMT YYYYDDD .\"\n        QUEUE \"logsys\" logsys\n        QUEUE \"LOG\" logtype\n        QUEUE \"LOCATE 00.00-\"datepdot\n        QUEUE \"FIND P'\" || msgprfx.msgidx || \"###'\"\n        QUEUE \"\"\n        ADDRESS EJES \"EXECAPI 9 (PRE log_\"\n        do while rc = 0\n          if (logdate <> \"*\") then                            /* @AC */\n             if RIGHT(log_LogTime.1,7) <> dateparm then leave;\n          column = log_FindPos.1.1\n          /* Filter & Continuation Rules for JES2 SYSLOG */\n          if EJES_EnvJES = 2 then do\n            call EJES_addMSGline 1\n            select\n              when LEFT(logmsg.1,1) = \"N\" then\n                if LEFT(logmsg.2,1) = \"S\" then\n                   call EJES_addMSGline 2\n              when LEFT(logmsg.1,1) = \"M\" then\n                do i = 2 to logmsg.0\n                  call EJES_addMSGline i\n                  if LEFT(logmsg.i,1) = \"E\" then leave;\n                end\n              otherwise;\n            end /* select */\n          end\n          /* Filter & Continuation Rules for JES3 DLOG */\n          else do\n            keylen = column - 30\n            key = SUBSTR(logmsg.1,30,keylen)\n            if logsys = \"*\" | WORD(key,1) = logsys then do\n              call EJES_addMSGline 1\n              do i = 2 to logmsg.0\n                if key <> SUBSTR(logmsg.i,30,keylen) then\n                   leave\n                if SUBSTR(logmsg.i,column,1) = \"I\" | ,\n                   SUBSTR(logmsg.i,column,1) = \"$\" then\n                   leave\n                call EJES_addMSGline i\n                if SUBSTR(logmsg.i,column,1) <> \" \" then\n                   leave\n              end\n            end\n          end\n          DELSTACK\n          QUEUE \"UP\" logmsg.0\n          QUEUE \"RFIND\"\n          QUEUE \"\"\n          ADDRESS EJES \"EXECAPI 9 (PRE log_\"\n        end\n      end /* msgidx = msgprfx.0 */\n\n      /* Merge IRR and ICH Messages */\n      rc = EJESREXX(\"TERMAPI\")\n      IRRnum = 1\n      ICHnum = 1\n      logmsg.0 = 0\n      do forever\n        select\n          when IRRnum <= IRRline.0 then do\n            if ICHnum > ICHline.0 then call EJES_logIRRline\n            else do\n              if IRRtime.IRRnum <= ICHtime.ICHnum then\n                 call EJES_logIRRline\n              else call EJES_Logichline\n            end\n            end /* when */\n          when IRRnum > IRRline.0 then do\n            if ICHnum > ICHline.0 then leave;\n            call EJES_Logichline\n            end /* when */\n          otherwise;\n        end\n      end\n\n      end /* when */\n    otherwise do\n      logmsg.0 = 0\n      end /* otherwise */\n  end /* select */\nRETURN\n/*--------------------------------------------------------------------*/\n/*  EJES - SYSLOG logic                                               */\n/*--------------------------------------------------------------------*/\nEJES_ADDMSGLINE:\n  arg ix\n  interpret \"k =\" msgprfx.msgidx || \"line.0 + 1\"\n  interpret msgprfx.msgidx || \"line.0 = k\"\n  interpret msgprfx.msgidx || \"line.k = logmsg.ix\"\n  interpret msgprfx.msgidx || \"time.0 = k\"\n  interpret msgprfx.msgidx || \"time.k = log_LogTime.ix\"\n  return\n/*--------------------------------------------------------------------*/\n/*  EJES - IRR messages                                               */\n/*--------------------------------------------------------------------*/\nEJES_LOGIRRLINE:\n/*  i = logmsg.0 + 1           */\n/*  logmsg.0 = i               */\n/*  logmsg.i = IRRline.IRRnum  */\n/*  IRRnum = IRRnum + 1        */\nRETURN\n/*--------------------------------------------------------------------*/\n/*  EJES - ICH messages                                               */\n/*--------------------------------------------------------------------*/\nEJES_LOGICHLINE:\n  i = logmsg.0 + 1\n  logmsg.0 = i\n  logmsg.i = ICHline.ICHnum\n  ICHnum = ICHnum + 1\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RACFMSGC": {"ttr": 931, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x14C\\x00\\x08\\x01 \\x00?\\x01 \\x16?\\x04\\x11\\x009\\x00'\\x00\\x00\\xd9\\xc1\\xc3\\xc6\\xc1\\xc4\\xd4@@@\"", "ispf": {"version": "20.67", "flags": 0, "createdate": "2020-01-03T00:00:00", "modifydate": "2020-06-11T04:11:08", "lines": 57, "newlines": 39, "modlines": 0, "user": "RACFADM"}, "text": "/*%NOCOMMENT====================* REXX *==============================*/\n/*  PURPOSE:  RACFADM - Display 'Confirm Request' pop-up panel        */\n/*--------------------------------------------------------------------*/\n/*  NOTES:    1) This REXX program is used by all REXX programs       */\n/*--------------------------------------------------------------------*/\n/* FLG  YYMMDD  USERID   DESCRIPTION                                  */\n/* ---  ------  -------  -------------------------------------------- */\n/* @AB  200423  RACFA    Move PARSE REXXPGM name up above IF SETMTRAC */\n/* @AA  200423  RACFA    Ensure REXX program name is 8 chars long     */\n/* @A9  200413  RACFA    Chg TRACEing to only display banner (P=Pgms) */\n/* @A8  200412  RACFA    Chg TRACE to allow 'L'abels or 'R'esults     */\n/* @A7  200228  RACFA    Removed SETMSHOW from VGET, not used         */\n/* @A6  200224  RACFA    Standardize quotes, chg single to double     */\n/* @A5  200224  RACFA    Place panels at top of REXX in variables     */\n/* @A4  200223  RACFA    Del 'address TSO \"PROFILE MSGID\"', not needed*/\n/* @A3  200220  RACFA    Added SETMTRAC=YES, then TRACE R             */\n/* @A2  200218  RACFA    Condense VGETs into one line                 */\n/* @A1  200119  RACFA    Standardized/reduced lines of code           */\n/* @A0  011229  NICORIZ  Created REXX, V2.1, www.rizzuto.it           */\n/*====================================================================*/\nPANELM1     = \"RACFMSG1\"   /* Confirm Request (pop-up)     */ /* @A5 */\nparse source . . REXXPGM .         /* Obtain REXX pgm name */ /* @AB */\nREXXPGM     = LEFT(REXXPGM,8)                                 /* @AB */\n\nADDRESS ISPEXEC                                               /* @A3 */\n  Arg message\n  Signal off error\n  \"VGET (SETMTRAC) PROFILE\"                                   /* @A7 */\n  If (SETMTRAC <> 'NO') then do                               /* @A8 */\n     Say \"*\"COPIES(\"-\",70)\"*\"                                 /* @A8 */\n     Say \"*\"Center(\"Begin Program = \"REXXPGM,70)\"*\"           /* @A8 */\n     Say \"*\"COPIES(\"-\",70)\"*\"                                 /* @A8 */\n     if (SETMTRAC <> 'PROGRAMS') THEN                         /* @A9 */\n        interpret \"Trace \"SUBSTR(SETMTRAC,1,1)                /* @A8 */\n  end                                                         /* @A8 */\n\n  answer  = 'NO'\n  zwinttl = 'CONFIRM REQUEST'\n  Do until (ckey = 'PF03') | (ckey = 'ENTER')\n     'CONTROL NOCMD'\n     \"ADDPOP\"                                                 /* @A6 */\n     \"DISPLAY PANEL(\"PANELM1\")\"                               /* @A5 */\n     \"REMPOP\"                                                 /* @A6 */\n  End\n  Select\n     when (ckey = 'PF03')  then answer = 'NO'\n     when (ckey = 'ENTER') then answer = 'YES'\n     otherwise nop\n  End\n  zwinttl = ' '\n\n  If (SETMTRAC <> 'NO') then do                               /* @A8 */\n     Say \"*\"COPIES(\"-\",70)\"*\"                                 /* @A8 */\n     Say \"*\"Center(\"End Program = \"REXXPGM,70)\"*\"             /* @A8 */\n     Say \"*\"COPIES(\"-\",70)\"*\"                                 /* @A8 */\n  end                                                         /* @A8 */\nRETURN answer\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RACFMSGS": {"ttr": 949, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x14K\\x00\\x07\\x01 \\x00?\\x01 &\\x1f\\x15\\x14\\x00\\x92\\x00/\\x00\\x00\\xd9\\xc1\\xc3\\xc6\\xc1\\xc4\\xd4@@@'", "ispf": {"version": "20.75", "flags": 0, "createdate": "2020-01-03T00:00:00", "modifydate": "2020-09-17T15:14:07", "lines": 146, "newlines": 47, "modlines": 0, "user": "RACFADM"}, "text": "/*%NOCOMMENT====================* REXX *==============================*/\n/*  PURPOSE:  RACFADM - Display error message                         */\n/*--------------------------------------------------------------------*/\n/*  NOTES:    1) This REXX program is used by all REXX programs       */\n/*--------------------------------------------------------------------*/\n/* FLG  YYMMDD  USERID   DESCRIPTION                                  */\n/* ---  ------  -------  -------------------------------------------- */\n/* @AG  200913  LBD      Accept message from command (msg.1)          */\n/* @AF  200423  RACFA    Move PARSE REXXPGM name up above IF SETMTRAC */\n/* @AE  200423  RACFA    Ensure REXX program name is 8 chars long     */\n/* @AD  200413  RACFA    Chg ERR07                                    */\n/* @AC  200413  RACFA    Chg TRACEing to only display banner (P=Pgms) */\n/* @AB  200412  RACFA    Chged ERR19 msg, inlude ALTLIB in msg        */\n/* @AA  200412  RACFA    Chg TRACE to allow 'L'abels or 'R'esults     */\n/* @A9  200410  RACFA    Added ERR21 msg, 'Invalid entry - NONE'      */\n/* @A8  200402  RACFA    Added ERR20 msg, 'Invalid security access'   */\n/* @A7  200402  RACFA    Added ERR19 msg, 'No LIBDEF ISPPLIB DSN'     */\n/* @A6  200301  RACFA    Standardize/use this module for all msgs     */\n/* @A5  200223  RACFA    Del 'address TSO \"PROFILE MSGID\"', not needed*/\n/* @A4  200221  RACFA    Make 'ADDRESS ISPEXEC' defualt, reduce code  */\n/* @A3  200220  RACFA    Added SETMTRAC=YES, then TRACE R             */\n/* @A2  200218  RACFA    Condense VGETs into one line                 */\n/* @A1  200119  RACFA    Standardized/reduced lines of code           */\n/* @A0  011229  NICORIZ  Created REXX, V2.1, www.rizzuto.it           */\n/*====================================================================*/\nparse source . . REXXPGM .         /* Obtain REXX pgm name */ /* @AF */\nREXXPGM     = LEFT(REXXPGM,8)                                 /* @AF */\n\nADDRESS ISPEXEC                                               /* @A4 */\n  parse arg code message                                      /* @AG */\n  \"VGET (SETMTRAC) PROFILE\"                                   /* @A2 */\n  If (SETMTRAC <> 'NO') then do                               /* @AA */\n     Say \"*\"COPIES(\"-\",70)\"*\"                                 /* @AA */\n     Say \"*\"Center(\"Begin Program = \"REXXPGM,70)\"*\"           /* @AA */\n     Say \"*\"COPIES(\"-\",70)\"*\"                                 /* @AA */\n     if (SETMTRAC <> 'PROGRAMS') THEN                         /* @AC */\n        interpret \"Trace \"SUBSTR(SETMTRAC,1,1)                /* @AA */\n  end                                                         /* @AA */\n\n  racfsmsg = ''; racflsmsg = ''\n  Select\n     when (code = 'ERR01') then do\n          racfsmsg = 'Add profile failed'\n          racflmsg = 'Unable to add the profile'\n     end\n     when (code = 'ERR02') then do\n          racfsmsg = 'Delete profile failed'\n          racflmsg = 'Unable to delete the profile'\n     end\n     when (code = 'ERR03') then do\n          racfsmsg = 'Permit profile failed'\n          racflmsg = 'Unable to permit the profile'\n     end\n     when (code = 'ERR04') then do\n          racfsmsg = 'Check permit results'\n          racflmsg = 'Please verify the permit settings'\n     end\n     when (code = 'ERR05') then do\n          racfsmsg = 'Permit add failed'\n          racflmsg = 'Unable to add the permit'\n     end\n     when (code = 'ERR06') then do\n          racfsmsg = 'Permit delete failed'\n          racflmsg = 'Unable to delete the permit'\n     end\n     when (code = 'ERR07') then do\n          racfsmsg = 'Alter profile failed'\n          racflmsg = 'Unable to alter the profile'            /* @AD */\n     end\n     when (code = 'ERR08') then do\n          racfsmsg = 'Filter is invalid'\n          racflmsg = 'The filter criteria is invalid'\n     end\n     when (code = 'ERR09') then do\n          racfsmsg = 'Error in search'\n          racflmsg = 'Encountered an error in seaching'\n     end\n     when (code = 'ERR10') then do\n          racfsmsg = 'Command failed'\n          racflmsg = 'Unable to execute the command'\n     end\n     when (code = 'ERR11') then do\n          racfsmsg = 'Define alias error'\n          racflmsg = 'Unable to deine the alias'\n     end\n     when (code = 'ERR12') then do\n          racfsmsg = 'User revoked'\n          racflmsg = 'Userid is revoked'\n     end\n     when (code = 'ERR13') then do\n          RACFSMSG = 'Add member failed'\n          racflmsg = 'Unable to add member'\n     end\n     when (code = 'ERR14') then do\n          RACFSMSG = 'Remove member failed'\n          racflmsg = 'Unable to remove member'\n     end\n     when (code = 'ERR15') then do\n          RACFSMSG = 'LG/LU failed'\n          racflmsg = 'LG/LU failed, please investigate'\n     end\n     WHEN (code = 'ERR16') then do\n          racfsmsg = 'No entries'\n          racflmsg = 'No entries meet search criteria'\n     end\n     WHEN (code = 'ERR17') then do\n          racfsmsg = 'Invalid - Wild card'\n          racflmsg = 'The astrisk (*) is a wild card,',\n                     'signifies default access'\n     end\n     WHEN (code = 'ERR18') then do\n          racfsmsg = 'Invalid - User Catalog'\n          racflmsg = 'The TSO User Catalog defined in',\n                     'Settings is invalid or null'\n     end\n     WHEN (code = 'ERR19') then do                            /* @A7 */\n          racfsmsg = 'Error ALTLIB/LIBDEF DSN'                /* @AB */\n          racflmsg = 'Unable to determine the ALTLIBed',      /* @AB */\n                     'or LIBDEFed datasets used to',          /* @AB */\n                     'invoke RACFADM.'                        /* @AB */\n     end                                                      /* @A7 */\n     WHEN (code = 'ERR20') then do                            /* @A8 */\n          racfsmsg = 'Invalid security access'                /* @A8 */\n          racflmsg = 'Userid does not have',                  /* @A8 */\n                     'security access to execute',            /* @A8 */\n                     'IRRXUTIL, please see Notes in',         /* @A8 */\n                     'tutorial'                               /* @A8 */\n     end                                                      /* @A8 */\n     WHEN (code = 'ERR21') then do                            /* @A9 */\n          racfsmsg = 'Invalid entry'                          /* @A9 */\n          racflmsg = 'NO and NONE are not valid entries.'     /* @A9 */\n     end                                                      /* @A9 */\n     otherwise nop\n  End\n  if message /= '' then                                       /* @AG */\n     if length(racflmsg) > 70                                 /* @AG */\n        then racflmsg = racflmsg message                      /* @AG */\n        else racflmsg = left(racflmsg,70) message             /* @AG */\n  \"SETMSG MSG(RACF011)\"\n\n  If (SETMTRAC <> 'NO') then do                               /* @AA */\n     Say \"*\"COPIES(\"-\",70)\"*\"                                 /* @AA */\n     Say \"*\"Center(\"End Program = \"REXXPGM,70)\"*\"             /* @AA */\n     Say \"*\"COPIES(\"-\",70)\"*\"                                 /* @AA */\n  end                                                         /* @AA */\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RACFMVS": {"ttr": 933, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01!\\x00\"\\x01 \\x13\\x7f\\x01 \\x18O\\x07(\\x00q\\x00?\\x00\\x00\\xd9\\xc1\\xc3\\xc6\\xc1\\xc4\\xd4@@@'", "ispf": {"version": "01.33", "flags": 0, "createdate": "2020-05-16T00:00:00", "modifydate": "2020-07-02T07:28:22", "lines": 113, "newlines": 63, "modlines": 0, "user": "RACFADM"}, "text": "/*%NOCOMMENT====================* REXX *==============================*/\n/*  PURPOSE:  RACFADM - RACF Data (Showmvs) - Menu opt 7 and O (SLIST)*/\n/*--------------------------------------------------------------------*/\n/* FLG  YYMMDD  USERID   DESCRIPTION                                  */\n/* ---  ------  -------  -------------------------------------------- */\n/* @A4  200702  RACFA    Allow for symbolic in dsname                 */\n/* @A3  200611  RACFA    Add capability to display USS info   (Opt O) */\n/* @A2  200525  RACFA    Allow defining pgm name in Settings  (Opt 0) */\n/* @A1  200519  RACFA    Obtain DSN from $DEVSETG or Settings (Opt 0) */\n/* @A0  200516  RACFA    Developed REXX                               */\n/*====================================================================*/\nX           = MSG(\"OFF\")\nEDITMACR    = \"RACFEMAC\"   /* Edit Macro, turn HILITE off  */\nDDNAME      = 'RACFA'RANDOM(0,999) /* Unique ddname        */\nparse source . . REXXPGM .         /* Obtain REXX pgm name */\nREXXPGM     = LEFT(REXXPGM,8)\n\nADDRESS ISPEXEC\n  PARSE ARG PARM                                              /* @A3 */\n  \"VGET (SETGDISP SETMSHOW SETMTRAC\",                         /* @A2 */\n        \"SETPMVS SETDMVSL) PROFILE\"                           /* @A2 */\n  If (SETMTRAC <> 'NO') then do\n     Say \"*\"COPIES(\"-\",70)\"*\"\n     Say \"*\"Center(\"Begin Program = \"REXXPGM,70)\"*\"\n     Say \"*\"COPIES(\"-\",70)\"*\"\n     if (SETMTRAC <> 'PROGRAMS') THEN\n        interpret \"Trace \"SUBSTR(SETMTRAC,1,1)\n  end\n  IF (SETPMVS = \"\") THEN                                      /* @A2 */\n     SETPMVS = \"SHOWZOS\"                                      /* @A2 */\n\n  racflmsg = \"Retrieving data - Please be patient\"\n  \"control display lock\"\n  \"display msg(RACF011)\"\n\n  IF (SETDMVSL <> \"\") THEN DO                                 /* @A1 */\n     SETDMVSL = STRIP(SETDMVSL,,\"'\")                          /* @A4 */\n     PARSE VAR SETDMVSL DSN1 \"&\" SYMBOL \".\" DSN2              /* @A4 */\n     SYMBVAL  = MVSVAR(\"SYMDEF\",SYMBOL)                       /* @A4 */\n     SETDMVSL = DSN1\"\"SYMBVAL\"\"DSN2                           /* @A4 */\n     IF (SYSDSN(\"'\"SETDMVSL\"'\") <> \"OK\") THEN DO              /* @A4 */\n        RACFSMSG = \"Invalid - Loadlib DSN\"                    /* @A4 */\n        RACFLMSG = \"The loadlib dataset does not exist,\",     /* @A4 */\n                   \"DSN='SETDMVSL'.  Invoke Settings\",        /* @A4 */\n                   \"(Option 0) and verify the SHOWMVS\",       /* @A4 */\n                   \"dataset defined is valid.\"                /* @A4 */\n        \"SETMSG MSG(RACF011)\"                                 /* @A1 */\n        EXIT                                                  /* @A1 */\n     END                                                      /* @A1 */\n     \"LIBDEF ISPLLIB DATASET ID('\"SETDMVSL\"') STACK\"          /* @A1 */\n  END                                                         /* @A1 */\n\n  ADDRESS TSO \"ALLOC DD(SHOWMVS) UNIT(VIO) NEW\",\n              \"SPACE(10 10) CYLINDERS\"\n  ADDRESS LINKMVS SETPMVS                                     /* @A2 */\n  LASTRC = RC\n  IF (SETDMVSL <> \"\") THEN                                    /* @A1 */\n     \"LIBDEF ISPLLIB\"                                         /* @A1 */\n  if (LASTRC <> 0) THEN DO\n     racfsmsg = 'Error - SHOWMVS'\n     racflmsg = 'Unable to execute SHOWMVS (RC='RC'). ',\n                'Verify SHOWMVS is in the linklist,'\n                'ISPLLIB or STEPLIB.'\n     'setmsg msg(RACF011)'\n     return\n  END\n  ADDRESS TSO \"EXECIO * DISKR SHOWMVS (STEM ZOSREC. FINIS\"\n  ADDRESS TSO \"FREE  DD(SHOWMVS)\"\n\n  K = 0\n  FOUND = \"N\"\n  DO J = 1 TO ZOSREC.0\n     PARSE VAR ZOSREC.J V1 2 V2 3 V3 V4 .\n     IF (V2 = \">\") THEN DO                                    /* @A3 */\n        IF (PARM = \"\") & (V3 = \"RACF\") THEN                   /* @A3 */\n           FOUND = \"Y\"                                        /* @A3 */\n        IF (PARM = \"UNIX\") & (V3 = \"UNIX\") THEN               /* @A3 */\n           FOUND = \"Y\"                                        /* @A3 */\n        IF (PARM = \"USS\") & (V3 = \"USS\") THEN                 /* @A3 */\n           FOUND = \"Y\"                                        /* @A3 */\n     END                                                      /* @A3 */\n     IF (FOUND = \"Y\") THEN DO\n        IF (K > 0) & (V2 = \">\") THEN\n           LEAVE\n        K = K + 1\n        RACFREC.K = SUBSTR(ZOSREC.J,2)\n     END\n  END\n  RACFREC.0 = K\n\n  ADDRESS TSO \"ALLOC F(\"DDNAME\") NEW REUSE\",\n              \"LRECL(133) BLKSIZE(0) RECFM(F B)\",\n              \"UNIT(VIO) SPACE(1 5) CYLINDERS\"\n  ADDRESS TSO \"EXECIO * DISKW \"DDNAME\" (STEM RACFREC. FINIS\"\n  DROP RACFREC.\n\n  \"LMINIT DATAID(CMDDATID) DDNAME(\"DDNAME\")\"\n  SELECT\n     WHEN (SETGDISP = \"VIEW\") THEN\n          \"VIEW DATAID(\"CMDDATID\") MACRO(\"EDITMACR\")\"\n     WHEN (SETGDISP = \"EDIT\") THEN\n          \"EDIT DATAID(\"CMDDATID\") MACRO(\"EDITMACR\")\"\n     OTHERWISE\n          \"BROWSE DATAID(\"CMDDATID\")\"\n  END\n  ADDRESS TSO \"FREE FI(\"DDNAME\")\"\n\n  If (SETMTRAC <> 'NO') then do\n     Say \"*\"COPIES(\"-\",70)\"*\"\n     Say \"*\"Center(\"End Program = \"REXXPGM,70)\"*\"\n     Say \"*\"COPIES(\"-\",70)\"*\"\n  end\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RACFOMVS": {"ttr": 935, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01c\\x00\\t\\x01 \\x15o\\x01 \\x16\\x8f\\t!\\x02%\\x00\\t\\x00\\x00\\xd9\\xc1\\xc3\\xc6\\xc1\\xc4\\xd4@@@'", "ispf": {"version": "01.99", "flags": 0, "createdate": "2020-06-04T00:00:00", "modifydate": "2020-06-16T09:21:09", "lines": 549, "newlines": 9, "modlines": 0, "user": "RACFADM"}, "text": "/*%NOCOMMENT====================* REXX *==============================*/\n/*  PURPOSE:  RACFADM - OMVS RACF Commands - Menu option O            */\n/*--------------------------------------------------------------------*/\n/*  NOTES:    1) Allows executing the IBM REXX programs:              */\n/*                 OPERMIT ... Unix Access Control List, like PERMIT  */\n/*                 ORALTER ... Unix Security Attribute, like ALTER    */\n/*                 ORLIST .... Unix Dir/File Security, like RLIST     */\n/*            2) And one internal command                             */\n/*                 FLIST...... Unix ZFS/HFS File Usage/Attribute Info */\n/*                 GLIST...... Unix Group Identifier (GID) List       */\n/*                 SLIST...... Showmvs UNIX System Services           */\n/*                 ULIST...... Unix User/Group Identifier (UID/GID)   */\n/*--------------------------------------------------------------------*/\n/* FLG  YYMMDD  USERID   DESCRIPTION                                  */\n/* ---  ------  -------  -------------------------------------------- */\n/* @AQ  200616  RACFA    Chg panel name RACFRPTS to RACFDISP          */\n/* @AP  200611  RACFA    Fix, duplicate entries, was MODE||RESULT     */\n/* @AO  200611  RACFA    Expanded dashes                              */\n/* @AN  200611  RACFA    Added SLIST, display Showmvs Unix info.      */\n/* @AM  200608  RACFA    F/G/ULIST, trans parm keywords to uppercase  */\n/* @AL  200608  RACFA    GLIST, changed parm 'Name' to 'Group'        */\n/* @AK  200608  RACFA    FLIST path, was disp 'no met srch criteria'  */\n/* @AJ  200608  RACFA    Move translating abbreviation to panel       */\n/* @AI  200608  TRIDJK   PERMIT/RALTER/RLIST, del TMPCMD, use OMVSCMD */\n/* @AH  200608  RACFA    Fix init var OMVSCMDS due to a abbreviation  */\n/* @AG  200608  RACFA    Upd F, upd verify parms, reduce code         */\n/* @AF  200608  RACFA    Upd F/G/U, fix abbreviating commands         */\n/* @AE  200608  RACFA    Upd F/G/U, move 'Numeric Digits' to top pgm  */\n/* @AD  200608  RACFA    Upd F/G/U, move CHKPRM to init subroutine    */\n/* @AC  200608  RACFA    Removed unnecessary 'TRACE O' left in code   */\n/* @AB  200608  RACFA    Fix F/G/U, display error msg, for no entries */\n/* @AA  200607  RACFA    If no recs found, display message            */\n/* @A9  200607  RACFA    GLIST cmd, add verification of GID           */\n/* @A8  200607  RACFA    UID/GID limit is 0 to 2,147,483,647          */\n/* @A7  200607  RACFA    Added GLIST command                          */\n/* @A6  200607  RACFA    Clean up code, reduce no. of subroutines     */\n/* @A5  200606  RACFA    Enhanced ULIST to allow passing more parms   */\n/* @A4  200606  RACFA    Enhanced FLIST to resolve/display path       */\n/* @A3  200606  RACFA    Display report headers in color              */\n/* @A2  200606  RACFA    Added FLIST command                          */\n/* @A1  200606  RACFA    Added ULIST command                          */\n/* @A0  200605  TRIDJK   Created REXX                                 */\n/*====================================================================*/\nPANEL01     = \"RACFOMVS\"    /* Obtain cmd, path and options*/\nPANEL02     = \"RACFDISP\"    /* Display report with colors  */ /* @AQ */\nEDITMACR    = \"RACFEMAC\"    /* Edit Macro, turn HILITE off */\nUIDGIDLIMIT = 2417483647    /* Limit = 0 - 2,147,483,647   */ /* @A8 */\nparse source . . REXXPGM .         /* Obtain REXX pgm name */\nREXXPGM     = LEFT(REXXPGM,8)\nnumeric digits 12                                             /* @A2 */\n\nADDRESS ISPEXEC\n  PARSE ARG MEMBER\n  \"VGET (SETGDISP SETGMVS SETMTRAC) PROFILE\"                  /* @AN */\n  If (SETGMVS = \"YES\") THEN DO                                /* @AN */\n     OMVSCMDS = \"](Flist, Glist, Permit, RAlter,\",            /* @AN */\n                \"RList, Slist or Ulist)\"                      /* @AN */\n     OMVSDES1 = \"[SList]   Unix System Services (USS)\",       /* @AN */\n                \"Information (Showmvs)\"                       /* @AN */\n     OMVSDES2 = \"[Ulist]   Unix User/Group Identifier\",       /* @AN */\n                \"(UID/GID) Information\"                       /* @AN */\n  END                                                         /* @AN */\n  Else DO                                                     /* @AN */\n     OMVSCMDS = \"](Flist, Glist, Permit, RAlter,\",            /* @AN */\n                \"RList or Ulist)\"                             /* @AN */\n     OMVSDES1 = \"[Ulist]   Unix User/Group Identifier\",       /* @AN */\n                \"(UID/GID) Information\"                       /* @AN */\n     OMVSDES2 = \"\"                                            /* @AN */\n  END                                                         /* @AN */\n\n  If (SETMTRAC <> 'NO') then do\n     Say \"*\"COPIES(\"-\",70)\"*\"\n     Say \"*\"Center(\"Begin Program = \"REXXPGM,70)\"*\"\n     Say \"*\"COPIES(\"-\",70)\"*\"\n     if (SETMTRAC <> 'PROGRAMS') THEN\n        interpret \"Trace \"SUBSTR(SETMTRAC,1,1)\n  end\n\n  Do Forever\n     \"DISPLAY PANEL(\"PANEL01\")\" /* get utility cmd options*/\n     If (rc = 8) then exit\n     CMDREC.  = \"\"                                            /* @A6 */\n     CMDREC.0 = 0; NO = 0                                     /* @A6 */\n     IF (OMVSCMD = \"FLIST\"),                                  /* @AJ */\n      | (OMVSCMD = \"GLIST\"),                                  /* @AJ */\n      | (OMVSCMD = \"SLIST\"),                                  /* @AN */\n      | (OMVSCMD = \"ULIST\") THEN                              /* @AJ */\n        CALL FLIST_GLIST_ULIST_INIT                           /* @A6 */\n     IF (CMDREC.0 = 0) THEN DO                                /* @A6 */\n        SELECT                                                /* @A1 */\n           WHEN (OMVSCMD = \"FLIST\") THEN                      /* @AJ */\n                call flist                                    /* @A2 */\n           WHEN (OMVSCMD = \"GLIST\") THEN                      /* @AJ */\n                call glist                                    /* @AH */\n           WHEN (OMVSCMD = \"SLIST\") THEN DO                   /* @AN */\n                IF (CHKPRM = \"USERS\") THEN                    /* @AN */\n                   MVSPRM = \"USS\"                             /* @AN */\n                ELSE                                          /* @AN */\n                   MVSPRM = \"UNIX\"                            /* @AN */\n                call RACFMVS MVSPRM                           /* @AN */\n                ITERATE                                       /* @AN */\n           END                                                /* @AN */\n           WHEN (OMVSCMD = \"ULIST\") THEN                      /* @AJ */\n                call ulist                                    /* @A1 */\n           WHEN (OMVSCMD = \"PERMIT\") THEN DO                  /* @AJ */\n                X = OUTTRAP(\"CMDREC.\")                        /* @A1 */\n                Address TSO \"O\"OMVSCMD OMVSPATH OMVSOPTS      /* @AJ */\n                X = OUTTRAP(\"OFF\")                            /* @A1 */\n           end                                                /* @A1 */\n           OTHERWISE DO                                       /* @A1 */\n                X = OUTTRAP(\"CMDREC.\")                        /* @A1 */\n                parse var OMVSOPTS w1 w2\n                if (w1 = \"FSSEC\") | (w1 = \"fssec\") then\n                   Address TSO \"O\"OMVSCMD w1 OMVSPATH w2      /* @AI */\n                else\n                   Address TSO \"O\"OMVSCMD OMVSPATH OMVSOPTS   /* @AI */\n                X = OUTTRAP(\"OFF\")                            /* @A1 */\n           END /* Select */                                   /* @A1 */\n        END /* If CMDREC */                                   /* @A6 */\n     end /*Do Forever */\n\n     IF (CMDREC.0 = 0) THEN DO                                /* @AA */\n        CMDREC.1 = \"No records met the search criteria.\"      /* @AA */\n        CMDREC.0 = 1                                          /* @AA */\n     END                                                      /* @AA */\n\n     ADDRESS TSO \"ALLOC F(\"DDNAME\") NEW REUSE\",\n                 \"LRECL(132) BLKSIZE(0) RECFM(F B)\",\n                 \"UNIT(VIO) SPACE(1 5) CYLINDERS\"\n     ADDRESS TSO \"EXECIO * DISKW \"DDNAME,\n                 \"(STEM CMDREC. FINIS\"\n     DROP CMDREC.\n\n     \"LMINIT DATAID(CMDDATID) DDNAME(\"DDNAME\")\"\n     SELECT\n        WHEN (SETGDISP = \"VIEW\") THEN DO                      /* @A3 */\n             IF (OMVSCMD = \"FLIST\"),                          /* @A3 */\n              | (OMVSCMD = \"ULIST\") THEN                      /* @A3 */\n                \"VIEW DATAID(\"CMDDATID\")\",                    /* @A3 */\n                             \"MACRO(\"EDITMACR\")\",             /* @A3 */\n                             \"PANEL(\"PANEL02\")\"               /* @A3 */\n             ELSE                                             /* @A3 */\n                \"VIEW DATAID(\"CMDDATID\")\",                    /* @A3 */\n                             \"MACRO(\"EDITMACR\")\"              /* @A3 */\n        END                                                   /* @A3 */\n        WHEN (SETGDISP = \"EDIT\") THEN DO                      /* @A3 */\n             IF (OMVSCMD = \"FLIST\"),                          /* @A3 */\n              | (OMVSCMD = \"ULIST\") THEN                      /* @A3 */\n                \"EDIT DATAID(\"CMDDATID\")\",                    /* @A3 */\n                             \"MACRO(\"EDITMACR\")\",             /* @A3 */\n                             \"PANEL(\"PANEL02\")\"               /* @A3 */\n             ELSE                                             /* @A3 */\n                \"EDIT DATAID(\"CMDDATID\")\",                    /* @A3 */\n                             \"MACRO(\"EDITMACR\")\"              /* @A3 */\n        END                                                   /* @A3 */\n        OTHERWISE\n             \"BROWSE DATAID(\"CMDDATID\")\"\n     END /* Select */\n     ADDRESS TSO \"FREE FI(\"DDNAME\")\"\n  End /* Do Forever */\n\n  If (SETMTRAC <> 'NO') then do\n     Say \"*\"COPIES(\"-\",70)\"*\"\n     Say \"*\"Center(\"End Program = \"REXXPGM,70)\"*\"\n     Say \"*\"COPIES(\"-\",70)\"*\"\n  end\nEXIT\n/*--------------------------------------------------------------------*/\n/*  ULIST - Unix User/Group Identifier (UID/GID)                 @A6  */\n/*--------------------------------------------------------------------*/\nULIST:                                                        /* @A1 */\n  PARSE VAR CHKPRM \"UID(\"UID\")\" .                             /* @A5 */\n  PARSE VAR CHKPRM \"GID(\"GID\")\" .                             /* @A5 */\n  PARSE VAR CHKPRM \"SHELL(\"SHELL\")\" .                         /* @A5 */\n  PARSE VAR CHKPRM \"HOME(\"HOME\")\" .                           /* @A5 */\n  PARSE UPPER VAR CHKPRM W1 .                                 /* @A5 */\n  IF (POS(\"(\",W1) = 0) THEN                                   /* @A5 */\n     ID = W1                                                  /* @A5 */\n  ELSE                                                        /* @A5 */\n     ID = \"\"                                                  /* @A5 */\n                                                              /* @A5 */\n  IF (ID <> \"\") THEN                                          /* @A5 */\n     IF (LENGTH(ID) > 8) THEN DO                              /* @A1 */\n        CMDREC.1 = 'The userid ('id') is larger than 8',      /* @A1 */\n                   'characters in length.'                    /* @A1 */\n        CMDREC.0 = 1                                          /* @A1 */\n        return                                                /* @A1 */\n     END                                                      /* @A1 */\n  IF (UID <> \"\") THEN                                         /* @A5 */\n     IF (DATATYPE(UID) <> \"NUM\"),                             /* @A8 */\n      | (UID > UIDGIDLIMIT) THEN DO                           /* @A8 */\n        CMDREC.1 = \"The UID (\"uid\") is either not numeric\",   /* @A8 */\n                   \"or greater than \"UIDGIDLIMIT              /* @A8 */\n        CMDREC.0 = 1                                          /* @A1 */\n        return                                                /* @A1 */\n     END                                                      /* @A1 */\n  IF (GID <> \"\") THEN                                         /* @A5 */\n     IF (DATATYPE(GID) <> \"NUM\"),                             /* @A8 */\n      | (GID > UIDGIDLIMIT) THEN DO                           /* @A8 */\n        CMDREC.1 = \"The GID (\"gid\") is either not numeric\",   /* @A8 */\n                   \"or greater than \"UIDGIDLIMIT              /* @A8 */\n        CMDREC.0 = 1                                          /* @A1 */\n        return                                                /* @A1 */\n     END                                                      /* @A1 */\n                                                              /* @A1 */\n  cmdrec.1 = \" Userid     UID       GID    Shell   \",         /* @A1 */\n             \"Home-Directory\"                                 /* @A1 */\n  cmdrec.2 = \"-------- ---------- ------- --------\",          /* @A1 */\n             \"----------------\"                               /* @A1 */\n  NO = 2                                                      /* @A1 */\n                                                              /* @A1 */\n  address syscall \"getpwent pw.\"                              /* @A1 */\n  firstid = pw.1                                              /* @A1 */\n  do forever                                                  /* @A1 */\n     if (pw.1 <> previd) then do                              /* @A1 */\n        IF (CHKPRM = \"\") THEN do                              /* @A1 */\n           NO = NO + 1                                        /* @A1 */\n           cmdrec.NO = pw.1 left(pw.2,10) left(pw.3,7),       /* @A1 */\n                            left(pw.5,8)  left(pw.4,50)       /* @A1 */\n        end                                                   /* @A1 */\n        ELSE DO                                               /* @A1 */\n           IF ((ID    <> \"\") & (ID    = PW.1)),               /* @A6 */\n            | ((UID   <> \"\") & (UID   = PW.2)),               /* @A6 */\n            | ((GID   <> \"\") & (GID   = PW.3)),               /* @A6 */\n            | ((SHELL <> \"\") & (SHELL = PW.5)),               /* @A6 */\n            | ((HOME  <> \"\") & (HOME  = PW.4)) THEN DO        /* @A6 */\n              NO = NO + 1                                     /* @A1 */\n              cmdrec.NO = pw.1 left(pw.2,10) left(pw.3,7),    /* @A1 */\n                               left(pw.5,8)  left(pw.4,50)    /* @A1 */\n           END                                                /* @A1 */\n        end /* If CHKPRM */                                   /* @A1 */\n     end /* If pw.1 */                                        /* @A1 */\n     previd = pw.1                                            /* @A1 */\n     address syscall \"getpwent pw.\"                           /* @A1 */\n     if (retval = -1) then                                    /* @A1 */\n        leave                                                 /* @A1 */\n     if (pw.1 = firstid) then                                 /* @A1 */\n        leave                                                 /* @A1 */\n  end /* Do Forever */                                        /* @A1 */\n                                                              /* @AB */\n  cmdrec.0 = NO                                               /* @A1 */\n  IF (NO = 2) THEN DO   /* Just rpt hdr? */                   /* @AB */\n     CMDREC.  = \"\"                                            /* @AB */\n     CMDREC.0 = 0                                             /* @AB */\n  END                                                         /* @AB */\nRETURN                                                        /* @A1 */\n/*--------------------------------------------------------------------*/\n/*  FLIST - Unix ZFS/HFS File Usage/Attribute Information        @A6  */\n/*--------------------------------------------------------------------*/\nFLIST:                                                        /* @A2 */\n  fsm.    = ''                                                /* @A2 */\n  fsm.0.0 = ''                                                /* @A2 */\n  fsm.0.1 = 'SECACL'                                          /* @A2 */\n  fsm.1.0 = ''                                                /* @A2 */\n  fsm.1.1 = 'UNMOUNT'                                         /* @A2 */\n  fsm.2.0 = ''                                                /* @A2 */\n  fsm.2.1 = 'CLIENT'                                          /* @A2 */\n  fsm.3.0 = ''                                                /* @A2 */\n  fsm.3.1 = 'NOAUTOMOVE'                                      /* @A2 */\n  fsm.4.0 = ''                                                /* @A2 */\n  fsm.4.1 = 'NOSEC'                                           /* @A2 */\n  fsm.5.0 = ''                                                /* @A2 */\n  fsm.5.1 = 'DFS-EXPORTED'                                    /* @A2 */\n  fsm.6.0 = ''                                                /* @A2 */\n  fsm.6.1 = 'NOSETUID'                                        /* @A2 */\n  fsm.7.0 = 'RDWR'                                            /* @A2 */\n  fsm.7.1 = 'READ'                                            /* @A2 */\n  percent = -1                                                /* @A2 */\n  string  = ''                                                /* @A2 */\n                                                              /* @A2 */\n  parse var CHKPRM \"PERC(\"percent\")\" .                        /* @A2 */\n  parse upper var CHKPRM \"TEXT(\"string\")\" .                   /* @A2 */\n  if (percent = '') & (string = '') & (CHKPRM <> '') THEN do  /* @A4 */\n     call flist_resolve_path_name                             /* @A4 */\n     return                                                   /* @A4 */\n  end                                                         /* @A4 */\n                                                              /* @A2 */\n  if (percent <> '') & (datatype(percent) <> 'NUM') then do   /* @AG */\n     CMDREC.1 = \"The percentage must be numeric,\",            /* @AG */\n                \"PERC(\"percent\").\"                            /* @AG */\n     CMDREC.0 = 1                                             /* @AG */\n     RETURN                                                   /* @A2 */\n  end                                                         /* @A2 */\n                                                              /* @A2 */\n  address syscall \"getmntent m.\"                              /* @A2 */\n                                                              /* @A2 */\n  CMDREC.1 = '%InUse Owner Filesystem / Mountpoint /',        /* @A2 */\n             '(Mount-attributes)'                             /* @A2 */\n  CMDREC.2 = '------ -----' copies('-',100)                   /* @AO */\n  NO = 2                                                      /* @A2 */\n                                                              /* @A2 */\n  l  = 0                                                      /* @A2 */\n  do i = 1 to m.0                                             /* @A2 */\n     sysname = strip(m.mnte_sysname.i)                        /* @A2 */\n     upper sysname                                            /* @A2 */\n     fsname  = strip(m.mnte_fsname.i)                         /* @A2 */\n     upper fsname                                             /* @A2 */\n     path = strip(m.mnte_path.i)                              /* @A2 */\n     upper path                                               /* @A2 */\n     parm = strip(m.mnte_parm.i)                              /* @A2 */\n     mode = ''                                                /* @A2 */\n     if (m.mnte_mode.i > 255) then                            /* @A2 */\n        m.mnte_mode.i = m.mnte_mode.i - 256                   /* @A2 */\n     Call FLIST_Translate_Mode_Settings m.mnte_mode.i         /* @A2 */\n     mode = result                                            /* @AP */\n     if (string <> '') then do                                /* @A2 */\n        if (substr(string,1,1) = '\u00ac'),                        /* @A2 */\n         & (length(string) > 1) then do                       /* @A2 */\n            stringx = substr(string,2)                        /* @A2 */\n            if (pos(stringx,sysname) = 0),                    /* @A2 */\n             & (pos(stringx,fsname)  = 0),                    /* @A2 */\n             & (pos(stringx,path)    = 0),                    /* @A2 */\n             & (pos(stringx,mode)    = 0),                    /* @A2 */\n             & (pos(stringx,parm)    = 0) then                /* @A2 */\n               call FLIST_get_usage                           /* @A2 */\n        end                                                   /* @A2 */\n        else do                                               /* @A2 */\n           if (pos(string,sysname) > 0),                      /* @A2 */\n            | (pos(string,fsname)  > 0),                      /* @A2 */\n            | (pos(string,path)    > 0),                      /* @A2 */\n            | (pos(string,mode)    > 0),                      /* @A2 */\n            | (pos(string,parm)    > 0) then                  /* @A2 */\n              call FLIST_get_usage                            /* @A2 */\n        end                                                   /* @A2 */\n     end /* If String */                                      /* @A2 */\n     else                                                     /* @A2 */\n        Call FLIST_Get_Usage                                  /* @A2 */\n  end /* Do Forever */                                        /* @A2 */\n                                                              /* @AB */\n  IF (NO = 2) THEN DO   /* Just rpt hdr? */                   /* @AB */\n     CMDREC.  = \"\"                                            /* @AB */\n     CMDREC.0 = 0                                             /* @AB */\n  END                                                         /* @AB */\n  ELSE DO                                                     /* @AB */\n     NO = NO + 1                                              /* @A2 */\n     CMDREC.NO = COPIES(\"-\",72)                               /* @A2 */\n     NO = NO + 1                                              /* @A2 */\n     CMDREC.NO = 'Total Filesystems Mounted =' m.0            /* @A2 */\n     NO = NO + 1                                              /* @A2 */\n     CMDREC.NO = 'Total Filesystems Listed  =' l              /* @A2 */\n     CMDREC.0  = NO                                           /* @A2 */\n  END                                                         /* @AB */\nRETURN                                                        /* @A2 */\n/*--------------------------------------------------------------------*/\n/*  FLIST - Get usage                                            @A2  */\n/*--------------------------------------------------------------------*/\nFLIST_GET_USAGE:                                              /* @A2 */\n  address syscall 'statfs' m.mnte_fsname.i s.                 /* @A2 */\n  if (DATATYPE(S.STFS_BLOCKSIZE) = \"NUM\") THEN DO             /* @A2 */\n     j = s.stfs_total * s.stfs_blocksize                      /* @A2 */\n     k = s.stfs_inuse * s.stfs_blocksize                      /* @A2 */\n     p = trunc(k/j*100,2)                                     /* @A2 */\n  END                                                         /* @A2 */\n                                                              /* @A2 */\n  if (p > percent) then do                                    /* @A2 */\n     l  = l + 1                                               /* @A2 */\n     NO = NO + 1                                              /* @A2 */\n     CMDREC.NO = right(p,6) left(m.mnte_sysname.i,5),         /* @A2 */\n                 left(m.mnte_fsname.i,44)                     /* @A2 */\n     NO = NO + 1                                              /* @A2 */\n     CMDREC.NO = copies(' ',12) left(m.mnte_path.i,64)        /* @A2 */\n     NO = NO + 1                                              /* @A2 */\n     CMDREC.NO = copies(' ',12) '('strip(mode)')'             /* @A2 */\n     if (parm <> '') then do                                  /* @A2 */\n        NO = NO + 1                                           /* @A2 */\n        CMDREC.NO = copies(' ',12) 'PARM('strip(parm)')'      /* @A2 */\n     end                                                      /* @A2 */\n  end                                                         /* @A2 */\nRETURN                                                        /* @A2 */\n/*--------------------------------------------------------------------*/\n/*  FLIST - Translate Mount Table Hex Mode Settings to Words     @A2  */\n/*--------------------------------------------------------------------*/\nFLIST_TRANSLATE_MODE_SETTINGS:                                /* @A6 */\n  arg mode                                                    /* @A2 */\n  mode_in_hex = d2c(mode)                                     /* @A2 */\n  mode = ''                                                   /* @A2 */\n  do bit = 7 to 0 by -1                                       /* @A2 */\n     and_value  = d2c(2**(7-bit))                             /* @A2 */\n     bit_status = bitand(mode_in_hex,and_value) > '00'x       /* @A2 */\n     fsm.bit    = fsm.bit.bit_status                          /* @A2 */\n     if (fsm.bit <> '') then mode = mode||fsm.bit' '          /* @A2 */\n  end                                                         /* @A2 */\nRETURN MODE                                                   /* @A2 */\n/*--------------------------------------------------------------------*/\n/*  FLIST - Resolve path name                                    @A6  */\n/*--------------------------------------------------------------------*/\nFLIST_RESOLVE_PATH_NAME:                                      /* @A4 */\n  ID = CHKPRM                                                 /* @A4 */\n  address syscall 'stat (id) st.'                             /* @A4 */\n  if (rc <> 0) & (retval = -1) then do                        /* @A6 */\n     cmdrec.1 = 'Unable to find path' id                      /* @A4 */\n     cmdrec.0 = 1                                             /* @A4 */\n     return                                                   /* @A6 */\n  end                                                         /* @A6 */\n                                                              /* @A6 */\n  address syscall \"getmntent a.\"                              /* @A4 */\n  address syscall 'realpath (id) path'                        /* @A4 */\n  if (rc <> 0) | (retval = -1) then do                        /* @A4 */\n     cmdrec.1 = 'Unable to resolve path for' id               /* @A4 */\n     cmdrec.0 = 1                                             /* @A4 */\n     return                                                   /* @A4 */\n  end                                                         /* @A4 */\n                                                              /* @A6 */\n  cmdrec.1 = 'Specified path:' id                             /* @A4 */\n  cmdrec.2 = 'Resolved  path:' path                           /* @A4 */\n  cmdrec.3 = ' '                                              /* @A4 */\n  cmdrec.4 = 'Resolved path dissection:'                      /* @A4 */\n  cmdrec.5 = 'UGO Owning-User(Uid)   Owning-Group(Gid) ',     /* @A4 */\n             'Path node'                                      /* @A4 */\n  cmdrec.6 = '--- ------------------ ------------------',     /* @A4 */\n             '--------->'                                     /* @A4 */\n  no = 6                                                      /* @A4 */\n                                                              /* @A4 */\n  pp = ''                                                     /* @A4 */\n  do while path <> ''                                         /* @A4 */\n     parse var path p '/' path                                /* @A4 */\n     pp = pp || '/' || p                                      /* @A4 */\n     address syscall 'stat (pp) st.'                          /* @A4 */\n     pw.pw_name = '-undef-'                                   /* @A4 */\n     address syscall 'getpwuid (st.st_uid) pw.'               /* @A4 */\n     uid = strip(pw.pw_name)'('st.st_uid')'                   /* @A4 */\n     gr.gr_name = '-undef-'                                   /* @A4 */\n     address syscall 'getgrgid (st.st_gid) gr.'               /* @A4 */\n     gid=strip(gr.gr_name)'('st.st_gid')'                     /* @A4 */\n     NO = NO + 1                                              /* @A4 */\n     CMDREC.NO = st.st_mode left(uid,18) left(gid,18) pp      /* @A4 */\n     call flist_chkmntpt                                      /* @A4 */\n     if (result = 4) then do                                  /* @A4 */\n        if (a.MNTE_MODE.i > 255) then                         /* @A4 */\n           a.MNTE_MODE.i = a.MNTE_MODE.i - 256                /* @A4 */\n        Call FLIST_Translate_Mode_Settings a.MNTE_MODE.i      /* @A4 */\n        mode = result                                         /* @A4 */\n        NO   = NO + 1                                         /* @A4 */\n        CMDREC.NO = '    FileSys='a.MNTE_FSNAME.i             /* @A4 */\n        NO   = NO + 1                                         /* @A4 */\n        CMDREC.NO = '    Owner='left(a.MNTE_SYSNAME.i,5),     /* @A4 */\n                    ' Mode=('strip(mode)')'                   /* @A4 */\n     end                                                      /* @A4 */\n     if (pp = '/') then pp = ''                               /* @A4 */\n  end /* Do While */                                          /* @A4 */\n                                                              /* @AB */\n  cmdrec.0 = NO                                               /* @AK */\n  IF (NO = 6) THEN DO   /* Just rpt hdr? */                   /* @AB */\n     CMDREC.  = \"\"                                            /* @AB */\n     CMDREC.0 = 0                                             /* @AB */\n  END                                                         /* @AB */\nRETURN                                                        /* @A4 */\n/*--------------------------------------------------------------------*/\n/*  FLIST - Check mount point                                    @A6  */\n/*--------------------------------------------------------------------*/\nFLIST_CHKMNTPT:                                               /* @A4 */\n  do i = a.0 to 1 by -1                                       /* @A4 */\n     if (a.MNTE_PATH.i = pp) then                             /* @A4 */\n        return 4                                              /* @A4 */\n  end                                                         /* @A4 */\nRETURN 0                                                      /* @A4 */\n/*--------------------------------------------------------------------*/\n/*  GLIST - Group Identifier (GID) List                          @A7  */\n/*--------------------------------------------------------------------*/\nGLIST:                                                        /* @A7 */\n  PARSE VAR CHKPRM \"GROUP(\"GROUP\")\" .                         /* @AL */\n  PARSE VAR CHKPRM \"GID(\"TMPGID\")\" .                          /* @A7 */\n                                                              /* @A7 */\n  IF (TMPGID <> \"\") THEN                                      /* @A9 */\n     IF (DATATYPE(TMPGID) <> \"NUM\"),                          /* @A9 */\n      | (TMPGID > UIDGIDLIMIT) THEN DO                        /* @A9 */\n        CMDREC.1 = \"The GID (\"tmpgid\") is either not\",        /* @A9 */\n                   \"numeric or greater than \"UIDGIDLIMIT      /* @A9 */\n        CMDREC.0 = 1                                          /* @A9 */\n        return                                                /* @A9 */\n     END                                                      /* @A9 */\n                                                              /* @A9 */\n  do forever                                                  /* @A7 */\n     address syscall \"getgrent gr.\"                           /* @A7 */\n     if (retval = 0) | (retval = -1) then                     /* @A7 */\n        leave                                                 /* @A7 */\n     gid = left(gr.2,8)                                       /* @A7 */\n     if (CHKPRM <> \"\") THEN                                   /* @A7 */\n        SELECT                                                /* @AL */\n           WHEN ((GROUP <> \"\") & (GROUP = gr.1)) THEN         /* @AL */\n                NOP                                           /* @AL */\n           WHEN ((GID <> \"\") & (TMPGID = gid)) THEN           /* @A7 */\n                NOP                                           /* @A7 */\n           OTHERWISE                                          /* @AL */\n                ITERATE                                       /* @AL */\n        END                                                   /* @AL */\n     NO  = NO + 1                                             /* @A7 */\n     CMDREC.NO = \"Group-Name=\"gr.1 \"GID=\"gid \"#members=\"gr.3  /* @A7 */\n     #m = gr.3                                                /* @A7 */\n     do i = 4 to #m+3 by 7                                    /* @A7 */\n        do j = i to i+6                                       /* @A7 */\n           if (j > #m+3) then gr.j = ''                       /* @A7 */\n        end                                                   /* @A7 */\n        l = i + 1; m = i + 2; n = i + 3                       /* @A7 */\n        o = i + 4; p = i + 5; q = i + 6                       /* @A7 */\n        NO = NO + 1                                           /* @A7 */\n        CMDREC.NO = \"    \"gr.i gr.l gr.m gr.n gr.o gr.p gr.q  /* @A7 */\n     end /* Do I */                                           /* @A7 */\n  end /* Do Forever */                                        /* @A7 */\n                                                              /* @AL */\n  CMDREC.0 = NO                                               /* @AL */\nRETURN                                                        /* @A7 */\n/*--------------------------------------------------------------------*/\n/*  F/G/ULIST - Verify environment and display 'Patients' msg    @A6  */\n/*--------------------------------------------------------------------*/\nFLIST_GLIST_ULIST_INIT:                                       /* @A6 */\n  NO     = 0                                                  /* @A6 */\n  CHKPRM = STRIP(OMVSPATH)STRIP(OMVSOPTS)                     /* @AD */\n                                                              /* @AM */\n  UPPPRM = TRANSLATE(CHKPRM)            /* Translate parms */ /* @AM */\n  colpos = pos('GID(',UPPPRM)           /* to uppercase    */ /* @AM */\n  If (colpos > 0) then                                        /* @AM */\n     CHKPRM = overlay('GID',CHKPRM,colpos,3)                  /* @AM */\n  colpos = pos('GROUP(',UPPPRM)                               /* @AM */\n  If (colpos > 0) then                                        /* @AM */\n     CHKPRM = overlay('GROUP',CHKPRM,colpos,5)                /* @AM */\n  colpos = pos('HOME(',UPPPRM)                                /* @AM */\n  If (colpos > 0) then                                        /* @AM */\n     CHKPRM = overlay('HOME',CHKPRM,colpos,4)                 /* @AM */\n  colpos = pos('PATH(',UPPPRM)                                /* @AM */\n  If (colpos > 0) then                                        /* @AM */\n     CHKPRM = overlay('PATH',CHKPRM,colpos,4)                 /* @AM */\n  colpos = pos('PERC(',UPPPRM)                                /* @AM */\n  If (colpos > 0) then                                        /* @AM */\n     CHKPRM = overlay('PERC',CHKPRM,colpos,4)                 /* @AM */\n  colpos = pos('SHELL(',UPPPRM)                               /* @AM */\n  If (colpos > 0) then                                        /* @AM */\n     CHKPRM = overlay('SHELL',CHKPRM,colpos,4)                /* @AM */\n  colpos = pos('TEXT(',UPPPRM)                                /* @AM */\n  If (colpos > 0) then                                        /* @AM */\n     CHKPRM = overlay('TEXT',CHKPRM,colpos,4)                 /* @AM */\n  colpos = pos('UID(',UPPPRM)                                 /* @AM */\n  If (colpos > 0) then                                        /* @AM */\n     CHKPRM = overlay('UID',CHKPRM,colpos,3)                  /* @AM */\n  colpos = pos('USERS',UPPPRM)                                /* @AN */\n  If (colpos > 0) then                                        /* @AN */\n     CHKPRM = overlay('USERS',CHKPRM,colpos,5)                /* @AN */\n                                                              /* @A6 */\n  if (OMVSCMD <> \"SLIST\") & (syscalls('ON') > 3) then do      /* @AN */\n     CMDREC.1 = 'Unable to establish the SYSCALL',            /* @A1 */\n                'environment.'                                /* @A1 */\n     CMDREC.0 = 1                                             /* @A1 */\n     return                                                   /* @A1 */\n  end                                                         /* @A1 */\n                                                              /* @A6 */\n  racflmsg = \"Retrieving data - Please be patient\"            /* @A1 */\n  \"control display lock\"                                      /* @A1 */\n  \"display msg(RACF011)\"                                      /* @A1 */\nRETURN                                                        /* @A6 */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RACFPRMS": {"ttr": 955, "alias": false, "halfwords": 30, "notes": 0, "parms": "b\"\\x14c\\x00#\\x01 \\x00?\\x01 '_\\x13\\x10\\x02\\x9f\\x00\\xe7\\x00\\x00\\xd9\\xc1\\xc3\\xc6\\xc1\\xc4\\xd4@@@\"", "ispf": {"version": "20.99", "flags": 0, "createdate": "2020-01-03T00:00:00", "modifydate": "2020-10-01T13:10:23", "lines": 671, "newlines": 231, "modlines": 0, "user": "RACFADM"}, "text": "/*%NOCOMMENT====================* REXX *==============================*/\n/*  PURPOSE:  RACFADM - RACF Parameters - Menu option 8 or 9          */\n/*--------------------------------------------------------------------*/\n/* FLG  YYMMDD  USERID   DESCRIPTION                                  */\n/* ---  ------  -------  -------------------------------------------- */\n/* @AY  200730  TRIDJK   Added Generic prof chk/Generic cmd proc      */\n/* @AX  200629  RACFA    Added FMID                                   */\n/* @AW  200629  RACFA    Chged RACF version to V##R##, was V##R##M##  */\n/* @AU  200629  RACFA    Fixed displaying RACF version                */\n/* @AT  200629  RACFA    If no RACF bkup dsn, then display N/A        */\n/* @AS  200618  RACFA    Chged SYSDA to SYSALLDA                      */\n/* @AR  200617  RACFA    Added comments to right of variables         */\n/* @AQ  200616  RACFA    Added capability to SAve file as TXT/CSV     */\n/* @AP  200610  RACFA    Added primary command 'SAVE'                 */\n/* @AO  200608  TRIDJK   Add 'Password minimum change interval'       */\n/* @AN  200502  RACFA    Del line 170, 'call table_create', not used  */\n/* @AM  200501  RACFA    Commented 'JES early verify', obsolete parm  */\n/* @AL  200501  LBD      Add primary commands FIND/RFIND              */\n/* @AK  200430  RACFA    Chg tbla to TABLEA, moved def. var. up top   */\n/* @AJ  200429  TRIDJK   Chg text on 2 parmeters                      */\n/* @AI  200429  RACFA    Chg 'Datasets' to 'Dataset'                  */\n/* @AH  200428  TRIDJK   Fixed variable names                         */\n/* @AG  200427  RACFA    Standardize SORT, LOCATE, ONLY & RESET cmds  */\n/* @AF  200427  TRIDJK   Added 'Password phrase'                      */\n/* @AE  200427  LBD      Convert to table display                     */\n/* @AD  200424  TRIDJK   Swapped rcvtelen & rcvtslen (end/start leng) */\n/* @AC  200424  TRIDJK   Add password lowercase/spc char/ext support  */\n/* @AB  200423  RACFA    Move PARSE REXXPGM name up above IF SETMTRAC */\n/* @AA  200423  RACFA    Ensure REXX program name is 8 chars long     */\n/* @A9  200423  RACFA    Chg variable name RCVTGDSN to RCVTPDSN       */\n/* @A8  200423  RACFA    Get RACF Bkp database name                   */\n/* @A7  200413  RACFA    Chg TRACEing to only display banner (P=Pgms) */\n/* @A6  200412  RACFA    Chg TRACE to allow 'L'abels or 'R'esults     */\n/* @A5  200224  RACFA    Place panels at top of REXX in variables     */\n/* @A4  200221  RACFA    Make 'ADDRESS ISPEXEC' defualt, reduce code  */\n/* @A3  200220  RACFA    Added SETMTRAC=YES, then TRACE R             */\n/* @A2  200120  TRIDJK   Add multi factor authentication (rcvtsmfa)   */\n/* @A1  200119  RACFA    Standardized/reduced lines of code           */\n/* @A0  011229  NICORIZ  Created REXX, V2.1, www.rizzuto.it           */\n/*====================================================================*/\nPANEL19     = \"RACFPRMS\"   /* RACF parameters, menu opt 7  */ /* @A5 */\nPANELS1     = \"RACFSAVE\"   /* Obtain DSName to SAVE        */ /* @AP */\nSKELETON1   = \"RACFPRMS\"   /* Save tablea to dataset       */ /* @AP */\nEDITMACR    = \"RACFEMAC\"   /* Edit Macro, turn HILITE off  */ /* @AP */\nTABLEA      = 'TA'RANDOM(0,99999)  /* Unique table name A  */ /* @AK */\nparse source . . REXXPGM .         /* Obtain REXX pgm name */ /* @AB */\nREXXPGM     = LEFT(REXXPGM,8)                                 /* @AB */\nparse value '' with null                                      /* @AE */\n\nADDRESS ISPEXEC                                               /* @A4 */\n  \"VGET (SETMTRAC SETGDISP) PROFILE\"                          /* @AP */\n  If (SETMTRAC <> 'NO') then do                               /* @A6 */\n     Say \"*\"COPIES(\"-\",70)\"*\"                                 /* @A6 */\n     Say \"*\"Center(\"Begin Program = \"REXXPGM,70)\"*\"           /* @A6 */\n     Say \"*\"COPIES(\"-\",70)\"*\"                                 /* @A6 */\n     if (SETMTRAC <> 'PROGRAMS') THEN                         /* @A7 */\n        interpret \"Trace \"SUBSTR(SETMTRAC,1,1)                /* @A6 */\n  end                                                         /* @A6 */\n\n  cvt     = c2x(storage(10,4))              /* cvt address            */\n  cvtrac$ = d2x((x2d(cvt))+992)             /* cvt + 3E0 = cvtrac $   */\n  cvtrac  = c2x(storage(cvtrac$,4))         /* cvtrac = access cntl   */\n  rcvt$   = cvtrac                          /* store for panel output */\n\n  call Get_bkp_database_name                /* Get bkp dsname         */\n  call Get_initial_rcvt_values              /* Get initial values     */\n  call Racf_audit_options                   /* Get audit options      */\n  call Racf_jes2_options\n  call Racf_password_options\n  call Racf_rvary_passwords\n  call Racf_setropt_options\n  call Racf_dasd_options\n  call Racf_model_options\n  call Racf_terminal_options\n  call Racf_tape_options\n  call Racf_dataset_class                                     /* @AY */\n  call Racf_statistics\n  call Get_passphrase                       /* Password phrase   @AF */\n\n  SORT = \"DESCU,C,A\"                                          /* @AG */\n  sortdesc = 'D'; sortvalu = 'A'                              /* @AG */\n  call CREATE_TABLEA                                          /* @AE */\n  /*----------------------------------*/                      /* @AE */\n  /* Display the table and process it */                      /* @AE */\n  /*----------------------------------*/                      /* @AE */\n  Do forever                                                  /* @AE */\n     radmrfnd = 'PASSTHRU'                                    /* @AL */\n     'vput (radmrfnd)'                                        /* @AL */\n     'tbdispl' TABLEA 'panel('panel19')'                      /* @AE */\n     lastrc = rc                                              /* @AL */\n     radmrfnd = null                                          /* @AL */\n     'vput (radmrfnd)'                                        /* @AL */\n     if (lastrc > 0) then leave                               /* @AE */\n     /*-------------------------*/                            /* @AE */\n     /* Reset racfrfnd to blank */                            /* @AE */\n     /*-------------------------*/                            /* @AE */\n     PARSE VAR ZCMD ZCMD PARM SEQ                             /* @AG */\n     if (zcmd = 'RFIND') then do                              /* @AL */\n        zcmd = 'FIND'                                         /* @AL */\n        parm = findit                                         /* @AL */\n        'tbtop' tablea                                        /* @AL */\n        'tbskip' tablea 'number('last_find')'                 /* @AL */\n     end                                                      /* @AL */\n     Select                                                   /* @AG */\n        When (abbrev(\"FIND\",zcmd,1) = 1) then                 /* @AL */\n             call do_find                                     /* @AL */\n        When (abbrev('LOCATE',zcmd,1) = 1) then               /* @AG */\n             call do_locate                                   /* @AG */\n        When (abbrev('ONLY',zcmd,1) = 1) then                 /* @AG */\n             call do_only                                     /* @AG */\n        When (abbrev('RESET',zcmd,1) = 1) then do             /* @AG */\n             sort     = 'DESCU,C,A'                           /* @AG */\n             sortdesc = 'A'; sortvalu = 'A'                   /* @AG */\n             \"TBEND\" TABLEA                                   /* @AG */\n             call CREATE_TABLEA                               /* @AG */\n        end                                                   /* @AG */\n        When (abbrev(\"SAVE\",zcmd,2) = 1) then DO              /* @AP */\n             TMPSKELT = SKELETON1                             /* @AP */\n             call do_SAVE                                     /* @AP */\n        END                                                   /* @AP */\n        when (abbrev('SORT',zcmd,1) = 1) then do              /* @AG */\n             if (abbrev('DESCRIPTION',PARM,1)) THEN           /* @AG */\n                call do_sort 'DESCU'                          /* @AG */\n             if (abbrev('VALUE',PARM,1)) THEN                 /* @AG */\n                call do_sort 'VALUE'                          /* @AG */\n        end                                                   /* @AG */\n        otherwise nop                                         /* @AG */\n     end                                                      /* @AG */\n  end                                                         /* @AE */\n  'tbend' TABLEA                                              /* @AE */\n                                                              /* @AE */\n  If (SETMTRAC <> 'NO') then do                               /* @A6 */\n     Say \"*\"COPIES(\"-\",70)\"*\"                                 /* @A6 */\n     Say \"*\"Center(\"End Program = \"REXXPGM,70)\"*\"             /* @A6 */\n     Say \"*\"COPIES(\"-\",70)\"*\"                                 /* @A6 */\n  end                                                         /* @A6 */\n                                                              /* @AE */\nRETURN 0000                                                   /* @AE */\n/*--------------------------------------------------------------------*/\n/*  Process primary command FIND                                 @AL  */\n/*--------------------------------------------------------------------*/\nDO_FIND:                                                      /* @AL */\n  if (parm = null) then do                                    /* @AL */\n     racfsmsg = 'Error'                                       /* @AL */\n     racflmsg = 'Find requires a value to search for.' ,      /* @AL */\n                'Try again.'                                  /* @AL */\n     'setmsg msg(RACF011)'                                    /* @AL */\n     return                                                   /* @AL */\n  end                                                         /* @AL */\n  findit    = translate(parm)                                 /* @AL */\n  last_find = 0                                               /* @AL */\n  wrap      = 0                                               /* @AL */\n  do forever                                                  /* @AL */\n     'tbskip' tablea                                          /* @AL */\n     if (rc > 0) then do                                      /* @AL */\n        if (wrap = 1) then do                                 /* @AL */\n           racfsmsg = 'Not Found'                             /* @AL */\n           racflmsg = findit 'not found.'                     /* @AL */\n           'setmsg msg(RACF011)'                              /* @AL */\n           return                                             /* @AL */\n        end                                                   /* @AL */\n        if (wrap = 0) then wrap = 1                           /* @AL */\n        'tbtop' tablea                                        /* @AL */\n     end                                                      /* @AL */\n     else do                                                  /* @AL */\n        testit = translate(desc value)                        /* @AL */\n        if (pos(findit,testit) > 0) then do                   /* @AL */\n           'tbquery' tablea 'position(srow)'                  /* @AL */\n           'tbtop'   tablea                                   /* @AL */\n           'tbskip'  tablea 'number('srow')'                  /* @AL */\n           last_find = srow                                   /* @AL */\n           xtdtop    = srow                                   /* @AL */\n           if (wrap = 0) then                                 /* @AL */\n              racfsmsg = 'Found'                              /* @AL */\n           else                                               /* @AL */\n              racfsmsg = 'Found/Wrapped'                      /* @AL */\n           racflmsg = findit 'found in row' srow + 0          /* @AL */\n           'setmsg msg(RACF011)'                              /* @AL */\n           return                                             /* @AL */\n        end                                                   /* @AL */\n     end                                                      /* @AL */\n  end                                                         /* @AL */\nRETURN                                                        /* @AL */\n/*--------------------------------------------------------------------*/\n/*  Reset the table                                              @AE  */\n/*--------------------------------------------------------------------*/\nDO_RESET:                                                     /* @AE */\n  'tbend' TABLEA                                              /* @AE */\n  call CREATE_TABLEA                                          /* @AE */\nRETURN                                                        /* @AE */\n/*--------------------------------------------------------------------*/\n/*  Sort the table - 1st ascending then descending               @AE  */\n/*--------------------------------------------------------------------*/\nDO_SORT:                                                      /* @AE */\n  parse arg sortcol                                           /* @AG */\n  INTERPRET \"TMPSEQ = SORT\"substr(SORTCOL,1,4)                /* @AG */\n  select                                                      /* @AG */\n     when (seq <> \"\") then do                                 /* @AG */\n          if (seq = 'A') then                                 /* @AG */\n             tmpseq = 'D'                                     /* @AG */\n          else                                                /* @AG */\n             tmpseq = 'A'                                     /* @AG */\n          sort = sortcol',C,'seq                              /* @AG */\n     end                                                      /* @AG */\n     when (seq = \"\"),                                         /* @AG */\n        & (tmpseq = 'A') then do                              /* @AG */\n           sort   = sortcol',C,A'                             /* @AG */\n           tmpseq = 'D'                                       /* @AG */\n     end                                                      /* @AG */\n     Otherwise do                                             /* @AG */\n        sort   = sortcol',C,D'                                /* @AG */\n        tmpseq = 'A'                                          /* @AG */\n     end                                                      /* @AG */\n  end                                                         /* @AG */\n  INTERPRET \"SORT\"SUBSTR(SORTCOL,1,4)\" = TMPSEQ\"              /* @AG */\n  'TBSort' TABLEA 'Fields('sort')'                            /* @AG */\n  'tbtop'  TABLEA                                             /* @AE */\n  CLRDESC = \"GREEN\"; CLRVALU = \"GREEN\"                        /* @AG */\n  INTERPRET \"CLR\"SUBSTR(SORTCOL,1,4)\" = 'TURQ'\"               /* @AG */\nRETURN                                                        /* @AE */\n/*--------------------------------------------------------------------*/\n/*  Locate table entry                                           @AE  */\n/*--------------------------------------------------------------------*/\nDO_LOCATE:                                                    /* @AE */\n  ASTERICK = \"*\"                                              /* @AG */\n  PARSE VAR SORT LOCARG \",\" .                                 /* @AG */\n  INTERPRET LOCARG\" = parm||ASTERICK\"                         /* @AG */\n  PARSE VAR SORT . \",\" . \",\" SEQ                              /* @AG */\n  IF (SEQ = \"D\") THEN                                         /* @AG */\n     CONDLIST = \"LE\"                                          /* @AG */\n  ELSE                                                        /* @AG */\n     CONDLIST = \"GE\"                                          /* @AG */\n  \"TBSCAN \"TABLEA,                                            /* @AG */\n          \"ARGLIST(\"LOCARG\") CONDLIST(\"CONDLIST\")\"            /* @AG */\nRETURN                                                        /* @AE */\n/*--------------------------------------------------------------------*/\n/*  Only display rows with the provided text string              @AE  */\n/*--------------------------------------------------------------------*/\nDO_ONLY:                                                      /* @AE */\n  'tbtop' TABLEA                                              /* @AE */\n  hit = 0                                                     /* @AE */\n  do forever                                                  /* @AE */\n     'tbskip' TABLEA                                          /* @AE */\n     if (rc > 0) then leave                                   /* @AE */\n     hit = 0                                                  /* @AE */\n     if (pos(parm,descu value) > 0) then                      /* @AG */\n        iterate                                               /* @AE */\n     'tbdelete' TABLEA                                        /* @AE */\n  end                                                         /* @AE */\nRETURN                                                        /* @AE */\n/*--------------------------------------------------------------------*/\n/*  Get initial RCVT values                                           */\n/*--------------------------------------------------------------------*/\nGET_INITIAL_RCVT_VALUES:\n  rc        = Setchar(rcvtpdsn,56,44)       /* racf dsn           @A9 */\n  rc        = Setchar(rcvtuads,100,44)      /* uads dsn               */\n  rc        = Setchar(rcvtuvol,144,6)       /* uads vol               */\n\n  CVT       = C2D(STORAGE(10,4))            /* Get RACF Version  @AU  */\n  x         = storage(d2x(cvt - 38),5)                        /* @AU */\n  rcvtgrnm  = 'V'substr(x,3,1)'R'substr(x,5,1)                /* @AW */\n  rcvtfmid  = \"HRF\"STORAGE(D2X(CVT - 29),4)                   /* @AX */\n  rcvtstat$ =  d2x((x2d(cvtrac))+36)        /*                        */\n  rcvtgext  =  c2x(storage(rcvtstat$,4))    /* RACF extension         */\n  rcvtstat$ =  d2x((x2d(cvtrac))+36)        /*                        */\n  rcvtgucb  =  c2x(storage(rcvtstat$,4))    /* dsn UCB                */\n  rcvtstat$ =  d2x((x2d(cvtrac))+4)         /*                        */\n  rcvtgdcb  =  c2x(storage(rcvtstat$,4))    /* dsn dcb                */\n  rcvtstat$ =  d2x((x2d(cvtrac))+8)         /*                        */\n  rcvtgdeb  =  c2x(storage(rcvtstat$,4))    /* dsn DEB                */\n\n  rc= Setbool(rcvtgsta,53,'80','Active','Inactive')  /* RACF active?  */\n  rc= Setbool(rcvtgmsg,153,'04','No','Yes')          /* ICH412I issued*/\n  rc= Setbool(rcvtgoff,153,'80','No','Yes')          /* RVARY INACTIVE*/\nRETURN\n/*--------------------------------------------------------------------*/\n/*  RACF JES2 parameters                                              */\n/*--------------------------------------------------------------------*/\nRACF_JES2_OPTIONS:\n  rc= Setbool(rcvtjchk,150,'02','NO','YES') /* jes2_early_verify      */\n  rc= Setbool(rcvtjall,150,'01','NO','YES') /* jes2_batchgallracf     */\n  rc= Setbool(rcvtjxal,150,'04','NO','YES') /* jes2_xbmallracf        */\n  rc= Setchar(rcvtjsys,696,8)               /* jes NJE userid         */\n  rc= Setchar(rcvtjund,704,8)               /* jes undefined user     */\nRETURN\n/*--------------------------------------------------------------------*/\n/*  RACF RVARY passwords                                              */\n/*--------------------------------------------------------------------*/\nRACF_RVARY_PASSWORDS:\n  rcvtrwpw$ = d2x((x2d(cvtrac))+440)        /* rcvtrwpw     $         */\n  rcvtrwpw  = c2x(storage(rcvtrwpw$,8))     /* rcvtrwpw               */\n  rcvtrnpw$ = d2x((x2d(cvtrac))+448)        /* rcvtrwpw     $         */\n  rcvtrnpw  = c2x(storage(rcvtrnpw$,8))     /* rcvtrnpw               */\n  rc        = Setvalue(rcvtslen,244,1)      /* pe length begin   @AD  */\n  rc        = Setvalue(rcvtelen,245,1)      /* pe length end     @AD  */\n  if (rcvtslen = 0) then rcvtslen = 1                         /* @AD */\n  if (rcvtelen = 0) then rcvtelen = 8                         /* @AD */\n  rc        = Setchar(rcvtruls,246,8)       /* password syntax        */\nRETURN\n/*--------------------------------------------------------------------*/\n/*  RACF password options                                             */\n/*--------------------------------------------------------------------*/\nRACF_PASSWORD_OPTIONS:\n  rc = Setvalue(rcvtpinv,155,1)             /* password expires       */\n  rc = Setvalue(rcvtphis,240,1)             /* password historical    */\n  rc = Setvalue(rcvtprvk,241,1)             /* password revoked att.  */\n  rc = Setvalue(rcvtpwrn,242,1)             /* password warning       */\n  rc = Setvalue(rcvtpina,243,1)             /* password inactive      */\nRETURN\n/*--------------------------------------------------------------------*/\n/*  RACF setropt options                                              */\n/*--------------------------------------------------------------------*/\nRACF_SETROPT_OPTIONS:\n  rc = Setbool(rcvtsegn,53,'01','NO','YES')  /* egn                   */\n  rc = Setbool(rcvtplc,633,'40','NO','YES')  /* lower case pswd   @AC */\n  rc = Setbool(rcvtpsc,633,'08','NO','YES')  /* special chr pswd  @AC */\n  rc = Setbool(rcvtxpwd,633,'04','NO','YES') /* extend pswd spt   @AC */\n  rc = Setbool(rcvtmfa,633,'02','NO','YES')  /* mfa               @A2 */\n  rc = Setbool(rcvtsads,53,'02','YES','NO')  /* adsp                  */\n  rc = Setbool(rcvtscat,628,'40','NO','YES') /* catdsns               */\n  rc = Setbool(rcvtseos,393,'20','NO','YES') /* erase on scratch      */\n  rc = Setbool(rcvtsapl,764,'08','NO','YES') /* applaudit             */\n  rc = Setbool(rcvtsaus,764,'10','YES','NO') /* audit special         */\n  rc = Setbool(rcvtsauo,151,'01','NO','YES') /* audit operations      */\n  rc = Setbool(rcvtsgrc,329,'80','NO','YES') /* listofgroupschecking  */\n  rc = Setbool(rcvtsgno,628,'02','NO','YES') /* generic owner         */\n  rc = Setbool(rcvtsmla,628,'04','NO','YES') /* mlactive              */\n  rc = Setbool(rcvtsmlq,628,'20','NO','YES') /* mlquiet               */\n  rc = Setbool(rcvtsmls,628,'08','NO','YES') /* mls                   */\n  rc = Setbool(rcvtsmlt,628,'10','NO','YES') /* mlstable              */\n  rc = Setbool(rcvtsslc,628,'80','NO','YES') /* seclabel control      */\n  rc = Setbool(rcvtssla,628,'01','NO','YES') /* seclabel audit        */\n  rc = Setbool(rcvtswhe,394,'80','NO','YES') /* when program          */\n  rc = Setbool(rcvtspra,393,'80','NO','YES') /* protect all           */\n  rc = Setvalue(rcvtsrpe,396,2)              /* retention period      */\n  rc = Setvalue(rcvtpmin,634,1)              /* pswd min chg intv @AO */\n\n  rcvtsta$ = d2x((x2d(cvtrac))+630)         /* rcvtsta      $         */\n  x        = storage(rcvtsta$,2)\n  rcvtslui = c2d(x)                         /* lu session interval    */\n\n  rc       = Setchar(rcvtqual,400,9)        /* prefix password+period */\nRETURN\n/*--------------------------------------------------------------------*/\n/*  Set variable in a Yes/No                                          */\n/*--------------------------------------------------------------------*/\nSETBOOL:\n  variable = arg(1)\n  offset   = arg(2)\n  value    = arg(3)\n  status1  = arg(4)\n  status2  = arg(5)\n  interpret  \"rcvtsta$= d2x((x2d(\"cvtrac\"))+\"offset\")\"\n  x        = storage(rcvtsta$,1)\n  interpret  variable '= 'status1\n  interpret  \"x=bitand(x,'\"value\"'x)\"       /* remove unwanted bits   */\n  interpret  \"if (x= '\"value\"'x) then \"variable\"=\"status2\nRETURN 0000\n/*--------------------------------------------------------------------*/\n/*  Set value                                                         */\n/*--------------------------------------------------------------------*/\nSETVALUE:\n  variable = arg(1)\n  offset   = arg(2)\n  length   = arg(3)\n  interpret  \"rcvtsta$= d2x((x2d(\"cvtrac\"))+\"offset\")\"\n  cmd      = variable '=c2d(storage('rcvtsta$','length'))'\n  interpret  cmd\nRETURN 0000\n/*--------------------------------------------------------------------*/\n/*  Set character                                                     */\n/*--------------------------------------------------------------------*/\nSETCHAR:\n  variable = arg(1)\n  offset   = arg(2)\n  length   = arg(3)\n  interpret  \"rcvtsta$= d2x((x2d(\"cvtrac\"))+\"offset\")\"\n  cmd      = variable '=storage('rcvtsta$','length')'\n  interpret  cmd\nRETURN 0000\n/*--------------------------------------------------------------------*/\n/*  RACF DASD options                                                 */\n/*--------------------------------------------------------------------*/\nRACF_DASD_OPTIONS:\n  rc= Setbool(rcvtdvpr,150,'40','NO','YES') /* dasd vol protection    */\n  rc= Setbool(rcvtndup,153,'10','NO','YES') /* no duplicate datasets  */\nRETURN\n/*--------------------------------------------------------------------*/\n/*  RACF model options                                                */\n/*--------------------------------------------------------------------*/\nRACF_MODEL_OPTIONS:\n  rc= Setbool(rcvtmgdg,324,'80','NO','YES') /* model gdg              */\n  rc= Setbool(rcvtmusr,324,'40','NO','YES') /* model user             */\n  rc= Setbool(rcvtmgrp,324,'20','NO','YES') /* model group            */\nRETURN\n/*--------------------------------------------------------------------*/\n/*  RACF terminal options                                             */\n/*--------------------------------------------------------------------*/\nRACF_TERMINAL_OPTIONS:\n  rc = Setbool(rcvttaut,154,'80','NO','YES') /* terminal auth chking  */\n  rc = Setbool(rcvttuac,154,'40','NO','YES') /* terminal uacc         */\nRETURN\n/*--------------------------------------------------------------------*/\n/*  RACF statistics                                                   */\n/*--------------------------------------------------------------------*/\nRACF_STATISTICS:\n  rc = Setbool(rcvtnls ,53,'40','Yes','No')         /* racinit        */\n  rc = Setbool(rcvtndss,53,'20','Yes','No')         /* data set       */\n  rc = Setbool(rcvtntvs,53,'10','Yes','No')         /* tape           */\n  rc = Setbool(rcvtndvs,53,'08','Yes','No')         /* dasd           */\n  rc = Setbool(rcvtntms,53,'04','Yes','No')         /* terminal       */\nRETURN\n/*--------------------------------------------------------------------*/\n/*  RACF tape options                                                 */\n/*--------------------------------------------------------------------*/\nRACF_TAPE_OPTIONS:\n  rc = Setbool(rcvttvpr,150,'80','NO','YES')   /* tape vol protection */\n  rc = Setbool(rcvttdpr,392,'40','NO','YES')   /* tape dsn protection */\nRETURN\n/*--------------------------------------------------------------------*/\n/*  RACF generic profile checking/cmd processing for dataset class    */\n/*--------------------------------------------------------------------*/\nRACF_DATASET_CLASS:                                           /* @AY */\n  rc = Setbool(rcvtdgen,150,'20','NO','YES')   /* generic profile chk */\n  rc = Setbool(rcvtdgcm,150,'10','NO','YES')   /* generic command proc*/\nRETURN\n/*--------------------------------------------------------------------*/\n/*  RACF audit options                                                */\n/*--------------------------------------------------------------------*/\nRACF_AUDIT_OPTIONS:\n  rcvtauop$ = d2x((x2d(cvtrac))+151)        /* rcvtauop     $         */\n\n  x         = storage(rcvtauop$,1)          /* rcvtauop               */\n  rcvtagro  = 'No'                          /* default                */\n  x         = bitand(x,'40'x)               /* remove unwanted bits   */\n  if (x = '40'x) then                       /* audit group class?     */\n     rcvtagro = 'Yes'                       /* yes                    */\n\n  x         = storage(rcvtauop$,1)          /* rcvtauop               */\n  rcvtause='No'                             /* default                */\n  x         = bitand(x,'20'x)               /* remove unwanted bits   */\n  if (x = '20'x) then                       /* audit user class ?     */\n     rcvtause = 'Yes'                       /* yes                    */\n\n  x         = storage(rcvtauop$,1)          /* rcvtauop               */\n  rcvtadat='No'                             /* default                */\n  x         = bitand(x,'10'x)               /* remove unwanted bits   */\n  if (x = '10'x) then                       /* audit dataset class?   */\n     rcvtadat ='Yes'                        /* yes                    */\n\n  x         = storage(rcvtauop$,1)          /* rcvtauop               */\n  rcvtadas='No'                             /* default                */\n  x         = bitand(x,'08'x)               /* remove unwanted bits   */\n  if (x = '08'x) then                       /* audit DASDVOL class?   */\n     rcvtadas ='Yes'                        /* yes                    */\nRETURN\n/*--------------------------------------------------------------------*/\n/*  Get RACF backup database name                                @A9  */\n/*--------------------------------------------------------------------*/\nGET_BKP_DATABASE_NAME:                                        /* @A9 */\n  DSDT     = D2X(X2D(CVTRAC) + X2D(E0))   /* Pointer to DSDT pointer */\n  DSDT     = C2X(STORAGE(DSDT,4))         /* Pointer to DSDT         */\n  DSDTNUM  = D2X(X2D(DSDT) + X2D(4))      /* Address of DSDTNUM      */\n  DSDTNUM  = C2D(STORAGE(DSDTNUM,4))      /* DSDTNUM                 */\n  DSDTBACK = D2X(X2D(DSDT) + X2D(140))    /* Address of 1st Bkup DSN */\n  BNAME    = D2X(X2D(DSDTBACK) + X2D(21)) /* Addr of backup name     */\n  RCVTBDSN = STRIP(STORAGE(BNAME,44))     /* Backup name             */\n  if pos(left(rcvtbdsn,1),'ABCDEFGHIJKLMNOPQRSTUVWXYZ@#$') = 0\n     then rcvtbdsn = ''                                       /* @AT */\n  if (rcvtbdsn = \"\") THEN                                     /* @AT */\n     rcvtbdsn = \"N/A\"                                         /* @AT */\nRETURN                                                        /* @A9 */\n/*--------------------------------------------------------------------*/\n/*  Get PASSPHRASE setting                                       @AF  */\n/*--------------------------------------------------------------------*/\nGET_PASSPHRASE:                                               /* @AF */\n  cmd    = \"PARMLIB LIST(LOGON)\"                              /* @AF */\n  x = outtrap('var.')                                         /* @AF */\n  Address TSO cmd                                             /* @AF */\n  cmd_rc = rc                                                 /* @AF */\n  x = outtrap('off')                                          /* @AF */\n  if (cmd_rc > 0) then return                                 /* @AF */\n  Do i = 1 to var.0                                           /* @AF */\n     parse var var.i 'PASSPHRASE(' pphrase ')'                /* @AF */\n     if (pphrase = 'ON') | (pphrase = 'OFF') then leave       /* @AF */\n  end                                                         /* @AF */\nRETURN                                                        /* @AF */\n/*--------------------------------------------------------------------*/\n/*  Add the data to the table                                    @AE  */\n/*--------------------------------------------------------------------*/\nADD_T:                                                        /* @AE */\n  parse arg desc 34 value .                                   /* @AE */\n  desc  = strip(desc)                                         /* @AE */\n  descu = translate(desc)                                     /* @AG */\n  value = strip(value)                                        /* @AE */\n  'tbadd' TABLEA                                              /* @AE */\nRETURN                                                        /* @AE */\n/*--------------------------------------------------------------------*/\n/*  Build the Table with the RACF Information                    @AE  */\n/*--------------------------------------------------------------------*/\nCREATE_TABLEA:                                                /* @AE */\n  'tbcreate' TABLEA 'names(desc,descu,value) nowrite'         /* @AE */\n  call add_t  'Audit operations                 'RCVTSAUO     /* @AE */\n  call add_t  'Audit special                    'RCVTSAUS     /* @AE */\n  call add_t  'Audit APPC transactions          'RCVTSAPL     /* @AJ */\n  call add_t  'Catalogued datasets only         'RCVTSCAT     /* @AE */\n  call add_t  'Data Base Backup                 'RCVTBDSN     /* @AE */\n  call add_t  'Data Base Primary                'RCVTPDSN     /* @AE */\n  call add_t  'Dataset protection               'RCVTSADS     /* @AE */\n  call add_t  'Duplicate datasets               'RCVTNDUP     /* @AE */\n  call add_t  'DASD volume protection           'RCVTDVPR     /* @AE */\n  call add_t  'Enhanced generic naming          'RCVTSEGN     /* @AE */\n  call add_t  'Erase on scratch                 'RCVTSEOS     /* @AE */\n  call add_t  'FMID                             'RCVTFMID     /* @AX */\n  call add_t  'Generic owner                    'RCVTSGNO     /* @AE */\n  call add_t  'Generic prof chk (DATASET class) 'RCVTDGEN     /* @AY */\n  call add_t  'Generic cmd proc (DATASET class) 'RCVTDGCM     /* @AY */\n  call add_t  'Initialize statistics            'RCVTNLS      /* @AH */\n  call add_t  'JES batch all                    'RCVTJALL     /* @AE */\n/*call add_t  'JES early verify                 'RCVTJCHK  */ /* @AM */\n  call add_t  'JES undefined userid             'RCVTJUND     /* @AE */\n  call add_t  'JES NJE userid                   'RCVTJSYS     /* @AE */\n  call add_t  'JES XBM all                      'RCVTJXAL     /* @AE */\n  call add_t  'List groups access checking      'RCVTSGRC     /* @AE */\n  call add_t  'LU session interval              'RCVTSLUI     /* @AE */\n  call add_t  'Model groups                     'RCVTMGRP     /* @AE */\n  call add_t  'Model users                      'RCVTMUSR     /* @AE */\n  call add_t  'Model GDG                        'RCVTMGDG     /* @AE */\n  call add_t  'Multi factor authentication      'RCVTMFA      /* @AH */\n  call add_t  'Multi-level active               'RCVTSMLA     /* @AJ */\n  call add_t  'Multi-level quiet                'RCVTSMLQ     /* @AE */\n  call add_t  'Multi-level secure               'RCVTSMLT     /* @AE */\n  call add_t  'Multi-level stable               'RCVTSMLS     /* @AE */\n  call add_t  'Password attempts                'RCVTPRVK     /* @AE */\n  call add_t  'Password extended support        'RCVTXPWD     /* @AE */\n  call add_t  'Password history                 'RCVTPHIS     /* @AE */\n  call add_t  'Password interval                'RCVTPINV     /* @AE */\n  call add_t  'Password lower case allowed      'RCVTPLC      /* @AH */\n  call add_t  'Password maximum length          'RCVTELEN     /* @AE */\n  call add_t  'Password minimum change interval 'RCVTPMIN     /* @AO */\n  call add_t  'Password minimum length          'RCVTSLEN     /* @AE */\n  call add_t  'Password phrase                  'PPHRASE      /* @AF */\n  call add_t  'Password rules                   'RCVTRULS     /* @AE */\n  call add_t  'Password special chars allowed   'RCVTPSC      /* @AH */\n  call add_t  'Password warning                 'RCVTPWRN     /* @AE */\n  call add_t  'Protect all                      'RCVTSPRA     /* @AE */\n  call add_t  'Retention period                 'RCVTSRPE     /* @AE */\n  call add_t  'Security label audit             'RCVTSSLA     /* @AE */\n  call add_t  'Security level control           'RCVTSSLC     /* @AE */\n  call add_t  'Single level prefix              'RCVTQUAL     /* @AE */\n  call add_t  'Tape dataset protection          'RCVTTDPR     /* @AE */\n  call add_t  'Tape volume protection           'RCVTTVPR     /* @AE */\n  call add_t  'Terminal authority               'RCVTTAUT     /* @AE */\n  call add_t  'Terminal UACC                    'RCVTTUAC     /* @AE */\n  call add_t  'Userid inactive                  'RCVTPINA     /* @AE */\n  call add_t  'UADS dataset                     'RCVTUADS     /* @AI */\n  call add_t  'UADS volume                      'RCVTUVOL     /* @AE */\n  call add_t  'Version                          'RCVTGRNM     /* @AE */\n  call add_t  'When program                     'RCVTSWHE     /* @AE */\n  CLRDESC = \"TURQ\" ; CLRVALU = \"GREEN\"  /* COL COLORS */      /* @AG */\n  'TBSort' TABLEA 'Fields('sort')'                            /* @AG */\nRETURN                                                        /* @AE */\n/*--------------------------------------------------------------------*/\n/*  Save table to dataset                                        @AP  */\n/*--------------------------------------------------------------------*/\nDO_SAVE:                                                      /* @AP */\n  X = MSG(\"OFF\")                                              /* @AP */\n  \"ADDPOP COLUMN(40)\"                                         /* @AP */\n  \"VGET (RACFSDSN RACFSMBR RACFSFIL RACFSREP) PROFILE\"        /* @AQ */\n  IF (RACFSDSN = \"\") THEN         /* SAve - Dataset Name  */  /* @AR */\n     RACFSDSN = USERID()\".RACFADM.REPORTS\"                    /* @EK */\n  IF (RACFSFIL = \"\") THEN         /* SAve - As (TXT/CVS)  */  /* @AR */\n     RACFSFIL = \"T\"                                           /* @EL */\n  IF (RACFSREP = \"\") THEN         /* SAve - Replace (Y/N) */  /* @AR */\n     RACFSREP = \"N\"                                           /* @EK */\n                                                              /* @AP */\n  DO FOREVER                                                  /* @AP */\n     \"DISPLAY PANEL(\"PANELS1\")\"                               /* @AP */\n     IF (RC = 08) THEN DO                                     /* @AP */\n        \"REMPOP\"                                              /* @AP */\n        RETURN                                                /* @AP */\n     END                                                      /* @AP */\n     RACFSDSN = STRIP(RACFSDSN,,\"'\")                          /* @AP */\n     RACFSDSN = STRIP(RACFSDSN,,'\"')                          /* @AP */\n     RACFSDSN = STRIP(RACFSDSN)                               /* @AP */\n     SYSDSORG = \"\"                                            /* @AP */\n     X = LISTDSI(\"'\"RACFSDSN\"'\")                              /* @AP */\n     IF (SYSDSORG = \"\") | (SYSDSORG = \"PS\"),                  /* @AP */\n      | (SYSDSORG = \"PO\") THEN                                /* @AP */\n        NOP                                                   /* @AP */\n     ELSE DO                                                  /* @AP */\n        RACFSMSG = \"Not PDS/Seq File\"                         /* @AP */\n        RACFLMSG = \"The dataset specified is not\",            /* @AP */\n                  \"a partitioned or sequential\",              /* @AP */\n                  \"dataset, please enter a valid\",            /* @AP */\n                  \"dataset name.\"                             /* @AP */\n       \"SETMSG MSG(RACF011)\"                                  /* @AP */\n       ITERATE                                                /* @AP */\n     END                                                      /* @AP */\n     IF (SYSDSORG = \"PS\") & (RACFSMBR <> \"\") THEN DO          /* @AP */\n        RACFSMSG = \"Seq File - No mbr\"                        /* @AP */\n        RACFLMSG = \"This dataset is a sequential\",            /* @AP */\n                  \"file, please remove the\",                  /* @AP */\n                  \"member name.\"                              /* @AP */\n       \"SETMSG MSG(RACF011)\"                                  /* @AP */\n       ITERATE                                                /* @AP */\n     END                                                      /* @AP */\n     IF (SYSDSORG = \"PO\") & (RACFSMBR = \"\") THEN DO           /* @AP */\n        RACFSMSG = \"PDS File - Need Mbr\"                      /* @AP */\n        RACFLMSG = \"This dataset is a partitioned\",           /* @AP */\n                  \"dataset, please include a member\",         /* @AP */\n                  \"name.\"                                     /* @AP */\n       \"SETMSG MSG(RACF011)\"                                  /* @AP */\n       ITERATE                                                /* @AP */\n     END                                                      /* @AP */\n                                                              /* @AP */\n     IF (RACFSMBR = \"\") THEN                                  /* @AP */\n        TMPDSN = RACFSDSN                                     /* @AP */\n     ELSE                                                     /* @AP */\n        TMPDSN = RACFSDSN\"(\"RACFSMBR\")\"                       /* @AP */\n     DSNCHK = SYSDSN(\"'\"TMPDSN\"'\")                            /* @AP */\n     IF (DSNCHK = \"OK\" & RACFSREP = \"N\") THEN DO              /* @AP */\n        RACFSMSG = \"DSN/MBR Exists\"                           /* @AP */\n        RACFLMSG = \"Dataset/member already exists. \",         /* @AP */\n                  \"Please type in \"Y\" to replace file.\"       /* @AP */\n        \"SETMSG MSG(RACF011)\"                                 /* @AP */\n        ITERATE                                               /* @AP */\n     END                                                      /* @AP */\n     LEAVE                                                    /* @AP */\n  END                                                         /* @AP */\n  \"REMPOP\"                                                    /* @AP */\n  \"VPUT (RACFSDSN RACFSMBR RACFSFIL RACFSREP) PROFILE\"        /* @AQ */\n                                                              /* @AP */\nADDRESS TSO                                                   /* @AP */\n  IF (RACFSREP = \"Y\" & RACFSMBR = \"\") |,                      /* @AP */\n     (DSNCHK <> \"OK\" & DSNCHK <> \"MEMBER NOT FOUND\"),         /* @AP */\n     THEN DO                                                  /* @AP */\n     \"DELETE '\"RACFSDSN\"'\"                                    /* @AP */\n     IF (RACFSMBR = \"\") THEN                                  /* @AP */\n        \"ALLOC  FI(ISPFILE) DA('\"RACFSDSN\"') NEW\",            /* @AP */\n            \"REUSE SP(1 1) CYLINDER UNIT(SYSALLDA)\",          /* @AS */\n            \"LRECL(80) RECFM(F B)\"                            /* @AP */\n     ELSE                                                     /* @AP */\n        \"ALLOC  FI(ISPFILE) DA('\"RACFSDSN\"') NEW\",            /* @AP */\n            \"REUSE SP(1 1) CYLINDER UNIT(SYSALLDA)\",          /* @AS */\n            \"LRECL(80) RECFM(F B)\",                           /* @AP */\n            \"DSORG(PO) DSNTYPE(LIBRARY,2)\"                    /* @AP */\n  END                                                         /* @AP */\n  ELSE                                                        /* @AP */\n     \"ALLOC  FI(ISPFILE) DA('\"RACFSDSN\"') SHR REUSE\"          /* @AP */\n                                                              /* @AP */\nADDRESS ISPEXEC                                               /* @AP */\n  \"FTOPEN\"                                                    /* @AP */\n  \"FTINCL \"TMPSKELT                                           /* @AP */\n  IF (RACFSMBR = \"\") THEN                                     /* @AP */\n     \"FTCLOSE\"                                                /* @AP */\n  ELSE                                                        /* @AP */\n     \"FTCLOSE NAME(\"RACFSMBR\")\"                               /* @AP */\n  ADDRESS TSO \"FREE FI(ISPFILE)\"                              /* @AP */\n                                                              /* @AP */\n  SELECT                                                      /* @AP */\n     WHEN (SETGDISP = \"VIEW\") THEN                            /* @AP */\n          \"VIEW DATASET('\"RACFSDSN\"') MACRO(\"EDITMACR\")\"      /* @AP */\n     WHEN (SETGDISP = \"EDIT\") THEN                            /* @AP */\n          \"EDIT DATASET('\"RACFSDSN\"') MACRO(\"EDITMACR\")\"      /* @AP */\n     OTHERWISE                                                /* @AP */\n          \"BROWSE DATASET('\"RACFSDSN\"')\"                      /* @AP */\n  END                                                         /* @AP */\n  X = MSG(\"ON\")                                               /* @AP */\n                                                              /* @AP */\nRETURN                                                        /* @AP */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RACFPROF": {"ttr": 953, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01c\\x00\\x15\\x01 \\x06o\\x01 \\'?\\x18\\x19\\x01\"\\x00j\\x00\\x00\\xd9\\xc1\\xc3\\xc6\\xc1\\xc4\\xd4@@@'", "ispf": {"version": "01.99", "flags": 0, "createdate": "2020-03-06T00:00:00", "modifydate": "2020-09-29T18:19:15", "lines": 290, "newlines": 106, "modlines": 0, "user": "RACFADM"}, "text": "/*%NOCOMMENT====================* REXX *==============================*/\n/*  PURPOSE:  RACFADM - User/Group Profiles - Line cmd 'P' in opt 1/2 */\n/*--------------------------------------------------------------------*/\n/*  SYNTAX:   CALL RACFPROF 'USER/GROUP' userid/group                 */\n/*--------------------------------------------------------------------*/\n/*  NOTES:    1) Executes RACF administration API (IRRXUTIL)          */\n/*                                                                    */\n/*            2) Must have Settings (Opt 0) 'Administrator=Y' in      */\n/*               order to display/use the line command 'P-Profile'    */\n/*                                                                    */\n/*            3) The user must have READ access to                    */\n/*               'IRR.RADMIN.LIST_/RLIST' in FACILITY, plus           */\n/*               authority to list the profile                        */\n/*--------------------------------------------------------------------*/\n/* FLG  YYMMDD  USERID   DESCRIPTION                                  */\n/* ---  ------  -------  -------------------------------------------- */\n/* @AZ  200923  TRIDJK   PARSE ARG ...  (lower case for DIGTCERT/RING)*/\n/* @AY  200423  RACFA    Move PARSE REXXPGM name up above IF SETMTRAC */\n/* @AX  200422  RACFA    Fixed IRRXUTIL RC when displaying RACF cmds  */\n/* @AW  200422  RACFA    Ensure the REXX program name is 8 chars      */\n/* @AV  200422  RACFA    Use variable REXXPGM in log msg              */\n/* @AU  200417  RACFA    Removed 'enq(exclu)', not needed             */\n/* @AT  200413  RACFA    Chg TRACEing to only display banner (P=Pgms) */\n/* @AS  200412  RACFA    Chg TRACE to allow 'L'abels or 'R'esults     */\n/* @AR  200410  RACFA    Chk for 'None', display message              */\n/* @AQ  200407  RACFA    Remove unnecessary spaces in group/profile   */\n/* @AP  200403  RACFA    Fix IRRXUTIL, needed single quotes on parms  */\n/* @AO  200403  RACFA    Chged 'cmd' var to text, so SHOWCMD works    */\n/* @AN  200402  RACFA    No sec. access to IRRXUTIL, display err msg  */\n/* @AM  200402  RACFA    Display RACF cmd, when profile has * or _    */\n/* @AL  200401  RACFA    Chged edit macro RACFLOGE to RACFEMAC        */\n/* @AK  200401  RACFA    VIEW/EDIT use edit macro, to turn off HILITE */\n/* @AJ  200331  TRIDJK   Chg LEFT(RACF.PROFILE,8) to RACF.PROFILE     */\n/* @AI  200324  TRIDJK   Chg loop var K to seg, due to conflict       */\n/* @AH  200324  RACFA    Allow both display/logging of RACF commands  */\n/* @AG  200324  RACFA    Allow logging RACF commands to ISPF Log file */\n/* @AF  200316  RACFA    Fix profile=*, no go, display msg            */\n/* @AE  200316  TRIDJK   No cmd trace if profile has special chars    */\n/* @AD  200316  RACFA    Added spacing after semi-colon               */\n/* @AC  200316  RACFA    Break up DATA field into multi-line msg      */\n/* @AB  200316  RACFA    Added a space after semi-colon               */\n/* @AA  200316  RACFA    Added SETMTRAC=YES, then TRACE R             */\n/* @A9  200316  RACFA    Display RACF cmd (IRXXUTIL) after execution  */\n/* @A8  200315  RACFA    If RC>0, then chg class variable (USER/GROUP)*/\n/* @A7  200315  RACFA    Del/add space in front of data               */\n/* @A6  200315  RACFA    Chged comments above                         */\n/* @A5  200313  RACFA    Standardized REXX program                    */\n/* @A4  200313  RACFA    Chg to allow editing/browsing the data       */\n/* @A3  200313  TRIDJK   Display profile using R_admin extract vars   */\n/* @A2  100101  WELLS    Created REXX   (brwells@us.ibm.com)          */\n/* @A1  091201  ONGHENA  Created REXX   (onghena@us.ibm.com)          */\n/* @A0  060101  WELLS    Created HLASM  (brwells@us.ibm.com)          */\n/*====================================================================*/\nPANELM2     = \"RACFMSG2\"   /* Display RACF command and RC  */ /* @A9 */\nEDITMACR    = \"RACFEMAC\"   /* Edit Macro, turn HILITE off  */ /* @AL */\nDDNAME      = 'RACFA'RANDOM(0,999) /* Unique ddname        */\nparse source . . REXXPGM .         /* Obtain REXX pgm name */ /* @AY */\nREXXPGM     = LEFT(REXXPGM,8)                                 /* @AY */\n\nParse arg class profile                                       /* @AZ */\nSelect                                                        /* @AR */\n   When (profile = \"*\") then do                               /* @AF */\n      call RACFMSGS ERR17                                     /* @AF */\n      return                                                  /* @AF */\n   end                                                        /* @AF */\n   When (profile = \"NO\") then do                              /* @AR */\n      call RACFMSGS ERR21                                     /* @AR */\n      return                                                  /* @AR */\n   end                                                        /* @AR */\n   When (profile = \"NONE\") then do                            /* @AR */\n      call RACFMSGS ERR21                                     /* @AR */\n      return                                                  /* @AR */\n   end                                                        /* @AR */\n   otherwise                                                  /* @AR */\n      nop                                                     /* @AR */\nend                                                           /* @AR */\n\n/* Initialize VIEW output stem */                             /* @A3 */\nirrxout. = ''\nirrx     = 0\n\nADDRESS ISPEXEC\n  \"VGET (SETGDISP SETMSHOW SETMTRAC) PROFILE\"                 /* @A9 */\n  If (SETMTRAC <> 'NO') then do                               /* @AS */\n     Say \"*\"COPIES(\"-\",70)\"*\"                                 /* @AS */\n     Say \"*\"Center(\"Begin Program = \"REXXPGM,70)\"*\"           /* @AS */\n     Say \"*\"COPIES(\"-\",70)\"*\"                                 /* @AS */\n     if (SETMTRAC <> 'PROGRAMS') THEN                         /* @AT */\n        interpret \"Trace \"SUBSTR(SETMTRAC,1,1)                /* @AS */\n  end                                                         /* @AS */\n\n  /* Call IRRXUTIL to extract the desired profile        */\n  call exccmd                                                 /* @A9 */\n\n  /* Check return code and exit if problem is discovered */\n  if (word(cmd_rc,1) <> 0) then do                            /* @A9 */\n     select                                                   /* @A8 */\n        when (class = \"USER\") THEN class=\"GROUP\"              /* @A8 */\n        otherwise class=\"USER\"                                /* @A8 */\n     end                                                      /* @A8 */\n     call exccmd                                              /* @A9 */\n     if (word(cmd_rc,1) <> 0) then do                         /* @A9 */\n        call sez \"Error calling IRRXUTIL: \"cmd_rc             /* @A9 */\n        if (word(cmd_rc,1) = 12) then                         /* @A9 */\n           call sez \"R_admin failure\"\n        irrxout.0 = irrx\n        call do_view_stem irrxout\n        call Goodbye                                          /* @AS */\n     end\n  end\n\n  /* Print header */\n  call sez \"Profile: \"RACF.PROFILE,                           /* @AJ */\n           \" Segments: \"||,                                   /* @AD */\n           right(RACF.0,2,\"0\")\n\n  /* Run through all segments */\n  do seg = 1 to RACF.0                                        /* @AI */\n     segname = RACF.seg      /* Get next segment name */      /* @AI */\n     call sez \"Segment: \"left(segname,8)\"  Fields:   \"||,     /* @AD */\n                    right(RACF.segname.0,2,\"0\")\n     /* Run through the fields in this segment */\n     do l = 1 to RACF.segname.0\n        fieldName = RACF.segname.l /* Get next field name */\n\n        /* If repeat header, handle the repeat group.     */\n        /* Tricky part, to keep the repeat group together */\n        if (RACF.segname.fieldname.repeatcount > 0) then do\n           /* Get dimension (number of fields in a group)\n              and cardinality (number of groups) */\n           dimension = RACF.segname.fieldname.subfield.0\n           repeats   = RACF.segname.fieldname.repeatcount\n           call sez \"Repeat field: \"left(fieldname,8),        /* @AB */\n                    \"  Subfields: \"right(dimension,2,\"0\")||,  /* @AD */\n                    \"  Occurrences: \"right(repeats,4,\"0\")     /* @AD */\n\n            /* For each repeat group */\n           do rpt = 1 to repeats\n                 /* Run thru each of the fields */\n              do dim = 1 to dimension\n                 /* Get repeat group field name */\n                 subfld = RACF.segname.fieldname.SUBFIELD.dim\n                 /* Get repeat group value */\n                 call sez \"  \"left(subfld,8)\": \"||,           /* @AB */\n                          RACF.segname.subfld.rpt\n              end /* dim */\n              call sez \"  \"COPIES(\"-\",44)\n           end /* repeats */\n        end /* repeat header */\n        else if (RACF.segname.fieldname.REPEATING = \"TRUE\") then do\n           /* Skip repeating fields because */\n           /* they were already handled     */\n           /* in the logic above when the   */\n           /* repeatheader was processed    */\n        end\n        else do /* not repeating */\n           /* Display value for this field  */\n           if (fieldname = \"DATA\") THEN                       /* @AC */\n              call linegt55                                   /* @AC */\n           else\n              call sez \"  \"left(fieldname,8)||,               /* @A7 */\n                       \": \"RACF.segname.fieldname.1\n        end /* not repeating */\n     end /* fields */\n  end /* segments */\n\n  /* --------------------------------- */                     /* @A3 */\n  /* Display connect groups for user   */                     /* @A3 */\n  /* --------------------------------- */                     /* @A3 */\n  if (class = 'USER') then do\n     gcnt = racf.base.connects.repeatcount\n     call sez 'Connect Groups:  ' 'Fields:'right(gcnt,2,\"0\")\n     do i = 1 to gcnt\n        call sez '  'racf.base.cgroup.i                       /* @A7 */\n     end\n  end\n\n  /* --------------------------------- */                     /* @A3 */\n  /* View IRRXUTIL output              */                     /* @A3 */\n  /* --------------------------------- */                     /* @A3 */\n  irrxout.0 = irrx\n  call do_view_stem irrxout\n  call Goodbye                                                /* @AS */\nEXIT\n/*--------------------------------------------------------------------*/\n/*  If tracing is on, display flower box                         @AS  */\n/*--------------------------------------------------------------------*/\nGOODBYE:                                                      /* @AS */\n  If (SETMTRAC <> 'NO') then do                               /* @AS */\n     Say \"*\"COPIES(\"-\",70)\"*\"                                 /* @AS */\n     Say \"*\"Center(\"End Program = \"REXXPGM,70)\"*\"             /* @AS */\n     Say \"*\"COPIES(\"-\",70)\"*\"                                 /* @AS */\n  end                                                         /* @AS */\nEXIT                                                          /* @AS */\n/*--------------------------------------------------------------------*/\n/*  Break up the line of data since it is larger than 50 chrs    @AC  */\n/*--------------------------------------------------------------------*/\nLINEGT55:                                                     /* @AC */\n  FIELDLEN = LENGTH(RACF.segname.fieldname.1)                 /* @AC */\n  FIELDREM = FIELDLEN//55                                     /* @AC */\n  FIELDINT = FIELDLEN%55                                      /* @AC */\n  if (FIELDREM > 0) THEN                                      /* @AC */\n     FIELDINT = FIELDINT + 1                                  /* @AC */\n  STRCOL = 1                                                  /* @AC */\n  do J = 1 to FIELDINT                                        /* @AC */\n     TMPFIELD = SUBSTR(RACF.segname.fieldname.1,STRCOL,55)    /* @AC */\n     NOWORDS  = WORDS(TMPFIELD)                               /* @AC */\n     WORDS    = \"\"                                            /* @AC */\n     do K = 1 to NOWORDS                                      /* @AC */\n        WORDS = WORDS\" \"WORD(TMPFIELD,K)                      /* @AC */\n     end                                                      /* @AC */\n     TMPFIELD = STRIP(WORDS)                                  /* @AC */\n     if (J = 1) THEN                                          /* @AC */\n        call sez \"  \"left(fieldname,8)||,                     /* @AC */\n                 \": \"tmpfield                                 /* @AC */\n     else                                                     /* @AC */\n        call sez \"  \"left(' ',8)||,                           /* @AC */\n                 \": \"tmpfield                                 /* @AC */\n     STRCOL   = STRCOL + 55                                   /* @AC */\n  end                                                         /* @AC */\nRETURN                                                        /* @AC */\n/*--------------------------------------------------------------------*/\n/*  Add to stem                                                  @A3  */\n/*--------------------------------------------------------------------*/\nSEZ:\n  parse arg text\n  irrx = irrx + 1\n  irrxout.irrx = text\nRETURN\n/*--------------------------------------------------------------------*/\n/*  ISPF View Stem routine                                       @A3  */\n/*--------------------------------------------------------------------*/\nDO_VIEW_STEM:\n  parse arg stem\n\nAddress TSO\n  'alloc f('ddname') unit(vio) new reuse space(1,1) tracks',\n        'lrecl(255) recfm(f b) blksize(0) dsorg(ps)'          /* @AZ */\n  'execio * diskw' ddname '(finis stem' stem'.'\n\nAddress ISPExec\n  'lminit dataid(id) ddname('ddname')'                        /* @AU */\n  if (rc \u00ac= 0) then do\n     zedsmsg = 'Error'\n     zedlmsg = 'Error.  LMINIT failed for VIO output file'\n    'setmsg msg(isrz001)'\n    call Goodbye                                              /* @AS */\n  end\n  Select                                                      /* @A4 */\n     When (SETGDISP = \"VIEW\") THEN                            /* @A4 */\n          \"VIEW DATAID(\"id\") MACRO(\"EDITMACR\")\"               /* @AK */\n     When (SETGDISP = \"EDIT\") THEN                            /* @A4 */\n          \"EDIT DATAID(\"id\") MACRO(\"EDITMACR\")\"               /* @AK */\n     Otherwise                                                /* @A4 */\n          'browse dataid('id')'                               /* @A4 */\n  end                                                         /* @A4 */\n  'lmfree dataid('id')'\n  Address TSO 'free f('ddname')'\nRETURN\n/*--------------------------------------------------------------------*/\n/*  Execute IRRUXTIL command                                     @A9  */\n/*--------------------------------------------------------------------*/\nEXCCMD:                                                       /* @A9 */\n  class   = STRIP(class)                                      /* @AQ */\n  profile = STRIP(profile)                                    /* @AQ */\n  cmd = \"IRRXUTIL('EXTRACT','\"class\"','\"profile\"','RACF',)\"   /* @AP */\n  interpret 'cmd_rc = 'cmd                                    /* @A9 */\n  cmd_rc = WORD(cmd_rc,1)                                     /* @AX */\n  if (SETMSHOW <> 'NO') then                                  /* @AG */\n     call SHOWCMD                                             /* @A9 */\n  if (WORD(cmd_rc,1) = 12) then                               /* @AN */\n     call racfmsgs ERR20                                      /* @AN */\nRETURN                                                        /* @A9 */\n/*--------------------------------------------------------------------*/\n/*  Display RACF command and return code                         @A9  */\n/*--------------------------------------------------------------------*/\nSHOWCMD:                                                      /* @A9 */\n  IF (SETMSHOW = \"BOTH\") | (SETMSHOW = \"DISPLAY\") THEN DO     /* @AH */\n     PARSE VAR CMD MSG1 60 MSG2 121 MSG3                      /* @A9 */\n     MSG4 = \"Return code = \"cmd_rc                            /* @A9 */\n     \"ADDPOP ROW(6) COLUMN(4)\"                                /* @A9 */\n     \"DISPLAY PANEL(\"PANELM2\")\"                               /* @A9 */\n     \"REMPOP\"                                                 /* @A9 */\n  END                                                         /* @AG */\n  IF (SETMSHOW = \"BOTH\") | (SETMSHOW = \"LOG\") THEN DO         /* @AH */\n     zerrsm = \"RACFADM \"REXXPGM\" RC=\"WORD(cmd_rc,1)           /* @AV */\n     zerrlm = cmd                                             /* @AG */\n     'log msg(isrz003)'                                       /* @AG */\n  END                                                         /* @AG */\nRETURN                                                        /* @A9 */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RACFPSWD": {"ttr": 943, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01c\\x00\\x08\\x01 \\t\\x7f\\x01 %/\\x066\\x00\\x98\\x00\\x06\\x00\\x00\\xd9\\xc1\\xc3\\xc6\\xc1\\xc4\\xd4@@@'", "ispf": {"version": "01.99", "flags": 0, "createdate": "2020-04-06T00:00:00", "modifydate": "2020-09-08T06:36:08", "lines": 152, "newlines": 6, "modlines": 0, "user": "RACFADM"}, "text": "/*%NOCOMMENT====================* REXX *==============================*/\n/*  PURPOSE:  RACFADM - Password Reset - Menu opt 5, line command PW  */\n/*--------------------------------------------------------------------*/\n/* FLG  YYMMDD  USERID   DESCRIPTION                                  */\n/* ---  ------  -------  -------------------------------------------- */\n/* @AG  200908  TRIDJK   Minor update/fix to 'Passphrase'             */\n/* @AF  200821  TRIDJK   Password phrase support                      */\n/* @AE  200504  JRT      SET vars are stored in PROFILE, line was ASIS*/\n/* @AD  200504  JRT      Use RACFPSWE panel if admin mode set         */\n/* @AC  200429  RACFA    Re-arranged variables (General, Mgmt, TSO)   */\n/* @AB  200426  RACFA    Chged var. ERAIPSWD to SETTPSWD (user pswd)  */\n/* @AA  200425  RACFA    Chk Settings (Opt 0) 'Initial Password' field*/\n/* @A9  200424  RACFA    Added lower case to random password          */\n/* @A8  200423  RACFA    Move PARSE REXXPGM name up above IF SETMTRAC */\n/* @A7  200422  RACFA    Ensure the REXX program name is 8 chars      */\n/* @A6  200422  TRIDJK   Use variable REXXPGM in log msg              */\n/* @A5  200413  RACFA    Chg TRACEing to only display banner (P=Pgms) */\n/* @A4  200412  RACFA    Chg TRACE to allow 'L'abels or 'R'esults     */\n/* @A3  200407  RACFA    Ensure REMPOP is accomplished when F3 (END)  */\n/* @A2  200407  RACFA    Made panel a variable                        */\n/* @A1  200407  RACFA    Removed unnecessary ISPF variables           */\n/* @A0  200407  TRIDJK   Created                                      */\n/*====================================================================*/\nPANELPW     = \"RACFPSWD\"   /* Password reset               */\nPANELPE     = \"RACFPSWE\"   /* Password reset and revoke    */ /* @AD */\nPANELM2     = \"RACFMSG2\"   /* Display RACF command and RC  */\nparse source . . REXXPGM .         /* Obtain REXX pgm name */ /* @A8 */\nREXXPGM     = LEFT(REXXPGM,8)                                 /* @A8 */\n\nparse arg userid\nAddress ISPExec\n  \"VGET (SETMADMN SETMSHOW SETMTRAC SETTPSWD) PROFILE\"        /* @AE */\n  \"VGET (SETMPHRA) PROFILE\"                                   /* @AF */\n  If (SETMTRAC <> 'NO') then do                               /* @A4 */\n     Say \"*\"COPIES(\"-\",70)\"*\"                                 /* @A4 */\n     Say \"*\"Center(\"Begin Program = \"REXXPGM,70)\"*\"           /* @A4 */\n     Say \"*\"COPIES(\"-\",70)\"*\"                                 /* @A4 */\n     if (SETMTRAC <> 'PROGRAMS') THEN                         /* @A5 */\n        interpret \"Trace \"SUBSTR(SETMTRAC,1,1)                /* @A4 */\n  end                                                         /* @A4 */\n  If (SETMADMN = 'YES') then                                  /* @AD */\n     panelpw = PANELPE                                        /* @AD */\n  If (SETTPSWD = \"\") THEN                                     /* @AB */\n     pswd = newpswd()                                         /* @AA */\n  else                                                        /* @AA */\n     pswd = SETTPSWD                                          /* @AB */\n  'ADDPOP'\n  'DISPLAY PANEL('panelpw')'                                  /* @A2 */\n  disprc = RC                                                 /* @A3 */\n  'REMPOP'\n  if (disprc = 8) then do                                     /* @A3 */\n     cmd_rc = 8                                               /* @A4 */\n     call Goodbye                                             /* @A4 */\n  end                                                         /* @A4 */\n  added = ''\n  if (resume = 'Y') then\n     added = 'RESUME'\n  if (expired = 'N') then                                     /* @AD */\n     added = added||' NOEXPIRED'                              /* @AD */\n  if SETMPHRA = 'YES' then                                    /* @AF */\n    call EXCMD \"ALTUSER \"userid\" PHRASE('\"pswd\"')\" added      /* @AF */\n  else                                                        /* @AF */\n    call EXCMD 'ALTUSER 'userid' PASSWORD('pswd')' added      /* @AF */\n  if (cmd_rc > 0) then do\n     racfsmsg = 'ALTUSER failed'\n     racflmsg = msg.1\n     \"SETMSG MSG(RACF011)\"\n  end\n  else do\n     If (SETMPHRA = 'YES') then                               /* @AG */\n        pwtype = 'Phrase'                                     /* @AG */\n     else                                                     /* @AG */\n        pwtype = 'Password'                                   /* @AG */\n     racfsmsg = 'Password reset'\n     racflmsg = userid 'password reset to 'pswd\n     \"SETMSG MSG(RACF011)\"\n  end\n  call Goodbye                                                /* @A4 */\nEXIT cmd_rc                                                   /* @A3 */\n/*--------------------------------------------------------------------*/\n/*  If tracing is on, display flower box                         @A4  */\n/*--------------------------------------------------------------------*/\nGOODBYE:                                                      /* @A4 */\n  If (SETMTRAC <> 'NO') then do                               /* @A4 */\n     Say \"*\"COPIES(\"-\",70)\"*\"                                 /* @A4 */\n     Say \"*\"Center(\"End Program = \"REXXPGM,70)\"*\"             /* @A4 */\n     Say \"*\"COPIES(\"-\",70)\"*\"                                 /* @A4 */\n  end                                                         /* @A4 */\nEXIT cmd_rc                                                   /* @A4 */\n/*--------------------------------------------------------------------*/\n/*  Generate password                                                 */\n/*--------------------------------------------------------------------*/\nNEWPSWD:\n  /* No vowels, or \"V\" or \"Z\" */\n  choices  = 'BCDFGHJKLMNPQRSTWXYbcdfghjklmnpqrstwxy'         /* @A9 */\n  chars.   = ''\n  password = ''\n  /* Initialize stem variables */\n  do n = 1 to length(choices)\n     chars.n = substr(choices,n,1)\n  end\n  /* n character password */                                  /* @AF */\n  psize = 6                                                   /* @AF */\n  do forever\n     pick = random(1,length(choices))\n     /* No repeating characters */\n     if (pos(chars.pick,password) > 0) then\n        nop\n     else\n        password = password||chars.pick\n     if (length(password) > (psize-1)) then                   /* @AF */\n        leave\n  end\n  /* Plug in 1 numeric character */\n  number   = random(1,9)\n  place    = random(2,psize)                                  /* @AF */\n  password = overlay(number,password,place,1)\nRETURN password\n/*--------------------------------------------------------------------*/\n/*  Exec command                                                      */\n/*--------------------------------------------------------------------*/\nEXCMD:\n  signal off error\n  parse arg cmd\n  x = OUTTRAP('msg.')\n  address TSO cmd\n  cmd_rc = rc\n  x = OUTTRAP('OFF')\n  if (SETMSHOW <> 'NO') then\n     call SHOWCMD\n  if (subword(msg.1,1,1)= 'ICH11009I') |,\n     (subword(msg.1,1,1)= 'ICH10006I') |,\n     (subword(msg.1,1,1)= 'ICH06011I') then raclist = 'YES'\nRETURN\n/*--------------------------------------------------------------------*/\n/*  Display RACF command and return code                              */\n/*--------------------------------------------------------------------*/\nSHOWCMD:\n  IF (SETMSHOW = \"BOTH\") | (SETMSHOW = \"DISPLAY\") THEN DO\n     PARSE VAR CMD MSG1 60 MSG2 121 MSG3\n     MSG4 = \"Return code = \"cmd_rc\n     \"ADDPOP ROW(6) COLUMN(4)\"\n     \"DISPLAY PANEL(\"PANELM2\")\"\n     \"REMPOP\"\n  END\n  IF (SETMSHOW = \"BOTH\") | (SETMSHOW = \"LOG\") THEN DO\n     zerrsm = \"RACFADM \"REXXPGM\" RC=\"WORD(cmd_rc,1)           /* @A6 */\n     zerrlm = cmd\n     parse value \"\" with zerralrm zerrhm zerrtp zerrwn        /* @AF */\n     'log msg(isrz003)'\n  END\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RACFPUTL": {"ttr": 945, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00W\\x01 %o\\x01 &\\x1f\\x15\\x08\\x00\\x0c\\x00\\x06\\x00\\x00\\xd9\\xc1\\xc3\\xc6\\xc1\\xc4\\xd4@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2020-09-12T00:00:00", "modifydate": "2020-09-17T15:08:57", "lines": 12, "newlines": 6, "modlines": 0, "user": "RACFADM"}, "text": "/*%NOCOMMENT====================* REXX *==============================*/\n/*  PURPOSE:  RACFADM - Called by RACFCMDS, display command at top    */\n/*--------------------------------------------------------------------*/\n/* FLG  YYMMDD  USERID   DESCRIPTION                                  */\n/* ---  ------  -------  -------------------------------------------- */\n/* @A0  200913  LBD      Created REXX                                 */\n/*====================================================================*/\nparse arg  prose\nprose = strip(prose,'B',\"'\")\nprose = strip(prose,'B','\"')\nsay prose\nreturn\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RACFRPTS": {"ttr": 937, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01c\\x00\\x00\\x01\\t$o\\x01 \\x18\\x8f\\x068\\x02\\x02\\x00\\x03\\x00\\x00\\xd9\\xc1\\xc3\\xc6\\xc1\\xc4\\xd4@@@'", "ispf": {"version": "01.99", "flags": 0, "createdate": "2009-09-03T00:00:00", "modifydate": "2020-07-06T06:38:00", "lines": 514, "newlines": 3, "modlines": 0, "user": "RACFADM"}, "text": "/*%NOCOMMENT====================* REXX *==============================*/\n/*  PURPOSE:  RACFADM - RACF Reports - Menu option R                  */\n/*--------------------------------------------------------------------*/\n/*  NOTES:    1) Will create RACF reports via a batch job using       */\n/*               - IBM's DFSORT ICETOOL using IRRDBU00 unload dataset */\n/*               - IBM's Data Security Monitor (DSMON)                */\n/*            2) Reads in panel dataset member $REPORTS to obtain     */\n/*               and display the list of reports                      */\n/*--------------------------------------------------------------------*/\n/* FLG  YYMMDD  USERID   DESCRIPTION                                  */\n/* ---  ------  -------  -------------------------------------------- */\n/* @AH  200701  RACFA    Unload - GDG BASE, relative, G#V#, make (+1) */\n/* @AG  200630  RACFA    Allow TSO PREFIX has HLQ in dsname           */\n/* @AF  200620  RACFA    Added primary command SUBMIT                 */\n/* @AE  200619  RACFA    Added line cmd 'R', remove '*'               */\n/* @AD  200619  RACFA    F3 out, no disp job card, when RESET typed   */\n/* @AC  200619  RACFA    If ALL rpts selected, remove others selected */\n/* @AB  200619  RACFA    Init RNUM with number of rows                */\n/* @AA  200619  LBD      Place all rpts selected into one job         */\n/* @A9  200619  RACFA    Relocated obtaining ISPF Job card variables  */\n/* @A8  200618  RACFA    Added SKELETON1 for JOB card                 */\n/* @A7  200618  RACFA    Chg SKELETON1/2 to SKELETON2/3               */\n/* @A6  200618  RACFA    Obtain ZLLGJOB3/4 variables                  */\n/* @A5  200618  RACFA    Chg UNIT to be SYSALLDA, was SYSDA           */\n/* @A4  200618  RACFA    Fix chking 1st word in job card no. 1 (Upper)*/\n/* @A3  200618  RACFA    Fix when JOB card is defined, save ZCMD      */\n/* @A2  200618  RACFA    Use $DEFSETG vars for temp dsn unit/space    */\n/* @A1  200618  RACFA    Fixed displaying job card                    */\n/* @A0  200617  RACFA    Developed REXX                               */\n/*====================================================================*/\nPANEL01     = \"RACFRPTS\"   /* Display reports              */\nPANEL99     = \"RACFRPTJ\"   /* Define JOB card/JCL parms    */\nSKELETON1   = \"RACFJOB\"    /* Job card                     */ /* @A8 */\nSKELETON2   = \"RACFRPTU\"   /* RACF unload pgm (IRRDBU00)   */ /* @A7 */\nSKELETON3   = \"RACFRPTS\"   /* RACF reports (ICETOOL/DSMON) */ /* @A7 */\nTABLEA      = \"RADM\"RANDOM(0,9999)\nDDNAME      = 'RACFA'RANDOM(0,999) /* Unique ddname        */\nRPTSMBR     = \"$REPORTS\"   /* List of reports              */\nparse source . . REXXPGM .         /* Obtain REXX pgm name */\nREXXPGM     = LEFT(REXXPGM,8)\nNULL        = \"\"                                              /* @AA */\nSELECTS     = 0                                               /* @AA */\n\nADDRESS ISPEXEC\n  \"VGET (SETGDISP SETGPREF SETMSHOW SETMTRAC SETDRPTU\",       /* @AG */\n        \"SETJRPTU SETJRPTS RACFRJCL\",                         /* @A2 */\n        \"ZLLGJOB1 ZLLGJOB2 ZLLGJOB3 ZLLGJOB4) PROFILE\"        /* @A9 */\n\n  If (SETMTRAC <> 'NO') then do\n     Say \"*\"COPIES(\"-\",70)\"*\"\n     Say \"*\"Center(\"Begin Program = \"REXXPGM,70)\"*\"\n     Say \"*\"COPIES(\"-\",70)\"*\"\n     if (SETMTRAC <> 'PROGRAMS') THEN\n        interpret \"Trace \"SUBSTR(SETMTRAC,1,1)\n  end\n  IF (RACFRJCL = \"\") THEN\n     RACFRJCL    = \"Y\"\n  IF (SETJRPTU = \"\") THEN                                     /* @A2 */\n     SETJRPTU = \"SYSALLDA\"                                    /* @A5 */\n  IF (SETJRPTS = \"\") THEN                                     /* @A2 */\n     SETJRPTS = \"(CYL,(100,100))\"                             /* @A2 */\n\n  ZSCROLLD = \"CSR\"\n  \"VPUT (ZSCROLLD)\"\n\n  \"QLIBDEF ISPPLIB TYPE(DATASET) ID(DSNAME)\"\n  if (RC > 0) then do\n     call racfmsgs ERR19\n     return\n  end\n  DSNRPTS = STRIP(DSNAME,,\"'\")\"(\"RPTSMBR\")\"\n\n  CALL CREATE_TABLEA\n\n  IF (RNUM = 0) THEN DO\n     RACFSMSG = \"No entries in file\"\n     RACFSMSG = \"There is are no valid entries in the\",\n               \"dataset: \"DSNRPTS\n     \"SETMSG MSG(RACF011)\"\n  END\n  ELSE\n     CALL DISP_PANEL\n\nADDRESS ISPEXEC\n  \"TBCLOSE \"TABLEA\n\n  If (SETMTRAC <> 'NO') then do\n     Say \"*\"COPIES(\"-\",70)\"*\"\n     Say \"*\"Center(\"End Program = \"REXXPGM,70)\"*\"\n     Say \"*\"COPIES(\"-\",70)\"*\"\n  end\n\nEXIT\n/*--------------------------------------------------------------------*/\n/*  Display Panel                                                     */\n/*--------------------------------------------------------------------*/\nDISP_PANEL:\n  opta   = ' '\n  xtdtop = 0\n  rsels  = 0\n  do forever\n     if (rsels < 2) then do\n        \"TBTOP \" TABLEA\n        'tbskip' tablea 'number('xtdtop')'\n        radmrfnd = 'PASSTHRU'\n        'vput (radmrfnd)'\n        \"TBDISPL\" TABLEA \"PANEL(\"PANEL01\")\"\n     end\n     else 'tbdispl' tablea\n     if (rc > 4) then leave\n     xtdtop   = ztdtop\n     rsels    = ztdsels\n     radmrfnd = null\n     'vput (radmrfnd)'\n     PARSE VAR ZCMD ZCMD PARM SEQ\n     IF (SROW <> \"\") & (SROW <> 0) THEN\n        IF (SROW > 0) THEN DO\n           \"TBTOP \" TABLEA\n           \"TBSKIP\" TABLEA \"NUMBER(\"SROW\")\"\n        END\n     if (zcmd = 'RFIND') then do\n        zcmd = 'FIND'\n        parm = findit\n        'tbtop ' TABLEA\n        'tbskip' TABLEA 'number('last_find')'\n     end\n     SELECT\n        When (abbrev(\"FIND\",zcmd,1) = 1) then\n             call do_finda\n        When (abbrev(\"JOB\",zcmd,1) = 1) then\n             call DEFINE_JOB_CARD\n        WHEN (ABBREV(\"LOCATE\",ZCMD,1) = 1) THEN do\n             if (parm <> '') then do\n                locarg = parm'*'\n                PARSE VAR SORT . \",\" . \",\" SEQ\n                IF (SEQ = \"D\") THEN\n                   CONDLIST = \"LE\"\n                ELSE\n                   CONDLIST = \"GE\"\n                parse value sort with scan_field',' .\n                IF (SCAN_FIELD = \"DESC\") THEN\n                   SCAN_FIELD = \"DESCCAPS\"\n                interpret scan_field ' = locarg'\n                'tbtop ' tablea\n                \"TBSCAN \"TABLEA\" ARGLIST(\"scan_field\")\",\n                        \"CONDLIST(\"CONDLIST\")\",\n                        \"position(scanrow)\"\n                xtdtop = scanrow\n             end\n        end\n        WHEN (ABBREV(\"ONLY\",ZCMD,1) = 1) THEN DO\n             find_str = translate(parm)\n             'tbtop ' TABLEA\n             'tbskip' TABLEA\n             do forever\n                str = translate(rec name pgm desc)\n                if (pos(find_str,str) > 0) then nop\n                else 'tbdelete' TABLEA\n                'tbskip' TABLEA\n                if (rc > 0) then do\n                   'tbtop' TABLEA\n                   leave\n                end\n             end\n        END\n        WHEN (ABBREV(\"RESET\",ZCMD,1) = 1) THEN DO\n             if (parm <> '') then\n                rfilter = parm\n             xtdtop   = 1\n             \"TBEND\" TABLEA\n             call CREATE_TABLEA\n        END\n        WHEN (ABBREV(\"SORT\",ZCMD,1) = 1) THEN DO\n             SELECT\n                when (ABBREV(\"REC\",PARM,1) = 1) then\n                     call sortseq 'REC'\n                when (ABBREV(\"NAME\",PARM,1) = 1) then\n                     call sortseq 'NAME'\n                when (ABBREV(\"PROGRAM\",PARM,1) = 1) then\n                     call sortseq 'PGM'\n                when (ABBREV(\"DESCRIPTION\",PARM,1) = 1) then\n                     call sortseq 'DESC'\n                otherwise NOP\n           END\n           CLRREC   = \"GREEN\"; CLRNAME = \"GREEN\"\n           CLRPGM   = \"GREEN\"; CLRDESC = \"GREEN\"\n           PARSE VAR SORT LOCARG \",\" .\n           INTERPRET \"CLR\"SUBSTR(LOCARG,1,4)\" = 'TURQ'\"\n           \"TBSORT \"TABLEA\" FIELDS(\"sort\")\"\n           \"TBTOP  \"TABLEA\n        END\n        WHEN (ABBREV(\"SUBMIT\",ZCMD,2) = 1) THEN DO            /* @AF */\n             if (selects = 1) then do                         /* @AF */\n                CALL CHK_ALL                                  /* @AF */\n                IF (SUBMIT = \"Y\") THEN                        /* @AF */\n                   CALL CREATE_JCL                            /* @AF */\n                CALL CLEAR_DOIT                               /* @AF */\n             END                                              /* @AF */\n             else do                                          /* @AF */\n                RACFSMSG = \"No reports selected\"              /* @AF */\n                RACFLMSG = \"Please select at least\",          /* @AF */\n                           \"one report to edit or\",           /* @AF */\n                           \"submit.\"                          /* @AF */\n                \"SETMSG MSG(RACF011)\"                         /* @AF */\n             end                                              /* @AF */\n        END                                                   /* @AF */\n        WHEN ABBREV(\"UNLOAD\",ZCMD,1) = 1 THEN\n             CALL CREATE_JCL\n        otherwise NOP\n     End /* Select */\n     ZCMD = \"\"; PARM = \"\"\n     'control display save'\n     Select\n        when (opta = 'S') then do                             /* @AA */\n             doit = '*'                                       /* @AA */\n             'tbput' tablea                                   /* @AA */\n             selects = 1                                      /* @AA */\n        end                                                   /* @AA */\n        when (opta = 'R') then do                             /* @AE */\n             doit = ' '                                       /* @AE */\n             'tbput' tablea                                   /* @AE */\n        end                                                   /* @AE */\n        otherwise nop\n     End\n     'control display restore'\n  END  /* Do Forever */\n                                                              /* @AA */\n  /*----------------------------------------------------*/    /* @AA */\n  /* If any reports were selected then generate the JCL */    /* @AA */\n  /*----------------------------------------------------*/    /* @AA */\n  if (selects = 1) then do                                    /* @AC */\n     CALL CHK_ALL                                             /* @AE */\n     IF (SUBMIT = \"Y\") THEN                                   /* @AE */\n        CALL CREATE_JCL\n  END                                                         /* @AE */\n                                                              /* @AA */\n  \"VPUT (SETDRPTU RACFRJCL) PROFILE\"\nRETURN\n/*--------------------------------------------------------------------*/\n/*  Create/populate table                                             */\n/*--------------------------------------------------------------------*/\nCREATE_TABLEA:\nSELECTS = \"\"                                                  /* @AD */\nADDRESS ISPEXEC\n  \"TBCREATE \"TABLEA\" NAMES(REC DOIT NAME PGM DESC\",           /* @AA */\n                          \"DESCCAPS) NOWRITE REPLACE\"         /* @AA */\nADDRESS TSO\n  \"ALLOC FI(\"DDNAME\") DA('\"DSNRPTS\"') SHR REUSE\"\n  \"EXECIO * DISKR \"DDNAME\" (STEM REC. FINIS\"\n  \"FREE FI(\"DDNAME\")\"\n\nADDRESS ISPEXEC\n  DOIT = \"\"                                                   /* @AA */\n  DO K = 1 TO REC.0\n     PARSE VAR REC.K REC NAME PGM DESC\n     IF (SUBSTR(REC.K,1,1) = \"*\") THEN ITERATE\n     REC  = STRIP(REC)\n     NAME = STRIP(NAME)\n     DESC = STRIP(DESC)\n     DESCCAPS = DESC\n     UPPER DESCCAPS\n     \"TBADD \"TABLEA\n  END\n  DROP REC.\n\n  CLRREC = \"TURQ\"  ; CLRNAME = \"GREEN\"\n  CLRPGM = \"GREEN\" ; CLRDESC = \"GREEN\"\n  sort   = 'REC,C,A'\n  sortid = 'D'; sortacc = 'A'\n  \"TBQUERY \"TABLEA\" ROWNUM(RNUM)\"                             /* @AB */\n  \"TBSORT \" TABLEA \"FIELDS(\"sort\")\"\nRETURN\n/*--------------------------------------------------------------------*/\n/*  Process primary command FIND for TABLEA                           */\n/*--------------------------------------------------------------------*/\nDO_FINDA:\n  if (parm = null) then do\n     racfsmsg = 'Error'\n     racflmsg = 'Find requires a value to search for.' ,\n                'Try again.'\n     'setmsg msg(RACF011)'\n     return\n  end\n  findit    = translate(parm)\n  last_find = 0\n  wrap      = 0\n  do forever\n     'tbskip' TABLEA\n     if (rc > 0) then do\n        if (wrap = 1) then do\n           racfsmsg = 'Not Found'\n           racflmsg = findit 'not found.'\n           'setmsg msg(RACF011)'\n           return\n        end\n        if (wrap = 0) then wrap = 1\n        'tbtop' TABLEA\n     end\n     else do\n        testit = translate(REC NAME PGM DESC)\n        if (pos(findit,testit) > 0) then do\n           'tbquery' TABLEA 'position(srow)'\n           'tbtop'   TABLEA\n           'tbskip'  TABLEA 'number('srow')'\n           last_find = srow\n           xtdtop    = srow\n           if (wrap = 0) then\n              racfsmsg = 'Found'\n           else\n              racfsmsg = 'Found/Wrapped'\n           racflmsg = findit 'found in row' srow + 0\n           'setmsg msg(RACF011)'\n           return\n        end\n     end\n  end\nRETURN\n/*--------------------------------------------------------------------*/\n/*  Define sort sequence, to allow point-n-shoot sorting (A/D)        */\n/*--------------------------------------------------------------------*/\nSORTSEQ:\n  parse arg sortcol\n  INTERPRET \"TMPSEQ = SORT\"substr(SORTCOL,1,4)\n  select\n     when (seq <> \"\") then do\n          if (seq = 'A') then\n             tmpseq = 'D'\n          else\n             tmpseq = 'A'\n          sort = sortcol',C,'seq\n     end\n     when (seq = \"\"),\n        & (tmpseq = 'A') then do\n           sort   = sortcol',C,D'\n           tmpseq = 'D'\n     end\n     Otherwise do\n        sort   = sortcol',C,A'\n        tmpseq = 'A'\n     end\n  end\n  INTERPRET \"SORT\"SUBSTR(SORTCOL,1,4)\" = TMPSEQ\"\nRETURN\n/*--------------------------------------------------------------------*/\n/*  Create Batch job                                                  */\n/*--------------------------------------------------------------------*/\nCREATE_JCL:\nADDRESS ISPEXEC\n  /*-----------------------------------------------*/         /* @A1 */\n  /* If IBM's ISPF JOB card variable is:           */         /* @A1 */\n  /*   ZLLGJOB1 =                                  */         /* @A1 */\n  /* or                                            */         /* @A1 */\n  /*   ZLLGJOB1 = //USERID   JOB (ACCOUNT),'NAME'  */         /* @A1 */\n  /* or                                            */         /* @A1 */\n  /*   ZLLGJOB1 = //@??##### JOB (??T),'NAME',etc. */         /* @A1 */\n  /* or                                            */         /* @A1 */\n  /*   ZLLGJOB1 = //JOB-NAME JOB (???),'NAME',etc. */         /* @A1 */\n  /*-----------------------------------------------*/         /* @A1 */\n  PARSE UPPER VAR ZLLGJOB1 W1 .                               /* @A1 */\n  IF (ZLLGJOB1 = \"\") | (W1 = \"//USERID\"),                     /* @A1 */\n   | (W1 = \"//@??#####\") | (W1 = \"//JOB-NAME\") THEN DO        /* @A1 */\n     TMPZCMD = ZCMD                                           /* @A3 */\n     CALL DEFINE_JOB_CARD\n     ZCMD    = TMPZCMD                                        /* @A3 */\n  END\n\n  \"FTOPEN TEMP\"\n  \"VGET (ZTEMPF)\"                                             /* @A9 */\n\n  TMPDRPTU = STRIP(TMPDRPTU,,\"'\")\n  GDGDSN = \"N\"                                                /* @AH */\n  \"FTINCL \"SKELETON1                                          /* @A8 */\n  IF (ABBREV(\"UNLOAD\",ZCMD,1) = 1) THEN DO                    /* @AH */\n     PARSE VAR TMPDRPTU W1 \"(\" W2 \")\" .                       /* @AH */\n     IF (W2 <> \"\") THEN DO                                    /* @AH */\n        TMPDRPTU = W1\"(+1)\"                                   /* @AH */\n        GDGDSN = \"Y\"                                          /* @AH */\n     END                                                      /* @AH */\n     ELSE DO                                                  /* @AH */\n        DSNLEN = LENGTH(TMPDRPTU)                             /* @AH */\n        GOOVOO = SUBSTR(TMPDRPTU,DSNLEN-7)                    /* @AH */\n        GOOVOO = TRANSLATE(GOOVOO,##########,0123456789)      /* @AH */\n        IF (GOOVOO = \"G####V##\") THEN DO                      /* @AH */\n           GDGDSN = \"Y\"                                       /* @AH */\n           TMPDRPTU = SUBSTR(TMPDRPTU,1,DSNLEN-9)\"(+1)\"       /* @AH */\n        END                                                   /* @AH */\n        ELSE DO                                               /* @AH */\n           X = OUTTRAP(\"LC.\")                                 /* @AH */\n           ADDRESS TSO \"LISTCAT ENT('\"TMPDRPTU\"')\"            /* @AH */\n           X = OUTTRAP(\"OFF\")                                 /* @AH */\n           PARSE VAR LC.1 W1 W2 .                             /* @AH */\n           IF (W1 = \"GDG\") & (W2 = \"BASE\") THEN               /* @AH */\n              TMPDRPTU  = TMPDRPTU\"(+1)\"                      /* @AH */\n           DROP LC.                                           /* @AH */\n        END /* Else */                                        /* @AH */\n     END /* Else */                                           /* @AH */\n     CALL GET_RACF_DSNS\n     \"FTINCL \"SKELETON2                                       /* @A7 */\n  END /* If UNLOAD */\n  ELSE\n     \"FTINCL \"SKELETON3                                       /* @A7 */\n  \"FTCLOSE\"\n\n  IF (RACFRJCL = \"Y\") THEN\n     \"EDIT DATASET('\"ztempf\"')\"\n  ELSE DO\n     ADDRESS TSO \"SUBMIT '\"ztempf\"'\"\n     RACFSMSG = \"Job Submitted\"\n     RACFLMSG = \"Batch job was submitted.  Invoke SDSF\",\n                \"to view output\"\n     \"SETMSG MSG(RACF011)\"\n  END\nRETURN\n/*--------------------------------------------------------------------*/\n/*  Define JOB card and JCL parameters                                */\n/*--------------------------------------------------------------------*/\nDEFINE_JOB_CARD:\n  /*-----------------------------------------------*/         /* @A1 */\n  /* If IBM's ISPF JOB card variable is:           */         /* @A1 */\n  /*   ZLLGJOB1 =                                  */         /* @A1 */\n  /* or                                            */         /* @A1 */\n  /*   ZLLGJOB1 = //USERID   JOB (ACCOUNT),'NAME'  */         /* @A1 */\n  /* or                                            */         /* @A1 */\n  /*   ZLLGJOB1 = //@??##### JOB (??T),'NAME',etc. */         /* @A1 */\n  /*-----------------------------------------------*/         /* @A1 */\n  PARSE UPPER VAR ZLLGJOB1 W1 .                               /* @A4 */\n  IF (ZLLGJOB1 = \"\") | (W1 = \"//USERID\") then do              /* @A1 */\n     ZLLGJOB1 = \"//job-name JOB (acct),'first-last-name',\"\n     ZLLGJOB2 = \"//         MSGCLASS=?,CLASS=?,\"||,\n                \"REGION=0M,NOTIFY=&SYSUID\"\n     \"VPUT (ZLLGJOB1 ZLLGJOB2)\"\n  END\n\n  'control display save'                                      /* @A1 */\n  \"ADDPOP\"\n  DO FOREVER\n     \"DISPLAY PANEL(\"PANEL99\")\"\n     IF (RC = 8) THEN LEAVE\n  END\n  \"REMPOP\"\n  'control display restore'                                   /* @A1 */\n\n  \"VPUT (ZLLGJOB1 ZLLGJOB2 ZLLGJOB3 ZLLGJOB4\",\n        \"SETJRPTU SETJRPTS) PROFILE\"                          /* @A2 */\nRETURN\n/*--------------------------------------------------------------------*/\n/*  Get RACF primary and backup database names                        */\n/*--------------------------------------------------------------------*/\nGET_RACF_DSNS:\n    cvt      = c2x(storage(10,4))\n    cvtrac$  = d2x((x2d(cvt))+992)\n    cvtrac   = c2x(storage(cvtrac$,4))\n    rcvtsta$ = d2x((x2d(cvtrac))+56)\n    RACFDPRM = strip(storage(rcvtsta$,44))\n    RCVT     = D2X(X2D(CVT) +X2D(3E0))\n    RCVT     = C2X(STORAGE(RCVT,4))\n    DSDT     = D2X(X2D(RCVT) + X2D(E0))\n    DSDT     = C2X(STORAGE(DSDT,4))\n    DSDTBACK = D2X(X2D(DSDT) + X2D(140))\n    BNAME    = D2X(X2D(DSDTBACK) + X2D(21))\n    RACFDBKP = STRIP(STORAGE(BNAME,44))\n    RACFDTMP = RACFDBKP\n    if (RACFDBKP = \"\") then do\n        RACFDBKP = \"N/A\"\n        RACFDTMP = RACFDPRM\n    end\nRETURN\n/*--------------------------------------------------------------------*/\n/*  Verify at least one report was selected and unselect 'ALL',  @AC  */\n/*  if other reports were selected, eliminating duplication      @AC  */\n/*--------------------------------------------------------------------*/\nCHK_ALL:                                                      /* @AC */\n  \"TBSORT \"TABLEA\" FIELDS(REC,C,A)\"                           /* @AC */\n  \"TBSKIP \"TABLEA                                             /* @AC */\n  \"TBGET  \"TABLEA                                             /* @AC */\n                                                              /* @AC */\n  SUBMIT = \"N\"                                                /* @AE */\n  IF (REC = \"ALL\") & (DOIT = \"*\") THEN DO                     /* @AC */\n     DO J = 2 TO RNUM                                         /* @AC */\n        \"TBSKIP \"TABLEA                                       /* @AC */\n        \"TBGET  \"TABLEA                                       /* @AC */\n        IF (DOIT = \"*\") THEN DO                               /* @AC */\n           DOIT = \"\"                                          /* @AC */\n           \"TBPUT \"TABLEA                                     /* @AC */\n        END                                                   /* @AC */\n     END                                                      /* @AC */\n     SUBMIT = \"Y\"                                             /* @AE */\n  END                                                         /* @AC */\n  ELSE DO                                                     /* @AE */\n     DO J = 2 TO RNUM                                         /* @AE */\n        \"TBSKIP \"TABLEA                                       /* @AE */\n        \"TBGET  \"TABLEA                                       /* @AE */\n        IF (DOIT = \"*\") THEN                                  /* @AE */\n           SUBMIT = \"Y\"                                       /* @AE */\n     END                                                      /* @AE */\n  END                                                         /* @AE */\n  \"TBTOP \"TABLEA                                              /* @AC */\nRETURN                                                        /* @AC */\n/*--------------------------------------------------------------------*/\n/*  Clear the DOIT field on all reports                          @AF  */\n/*--------------------------------------------------------------------*/\nCLEAR_DOIT:                                                   /* @AF */\n  \"TBTOP \"TABLEA                                              /* @AF */\n                                                              /* @AF */\n  DO J = 2 TO RNUM                                            /* @AF */\n     \"TBSKIP \"TABLEA                                          /* @AF */\n     \"TBGET  \"TABLEA                                          /* @AF */\n     IF (DOIT = \"*\") THEN DO                                  /* @AF */\n        DOIT = \"\"                                             /* @AF */\n        \"TBPUT \"TABLEA                                        /* @AF */\n     END                                                      /* @AF */\n  END                                                         /* @AF */\n  \"TBTOP \"TABLEA                                              /* @AF */\nRETURN                                                        /* @AF */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RACFSETD": {"ttr": 957, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01c\\x000\\x01 \\x12/\\x01 3_\\x16I\\x00\\xdb\\x000\\x00\\x00\\xd9\\xc1\\xc3\\xc6\\xc1\\xc4\\xd4@@@'", "ispf": {"version": "01.99", "flags": 0, "createdate": "2020-05-01T00:00:00", "modifydate": "2020-11-30T16:49:30", "lines": 219, "newlines": 48, "modlines": 0, "user": "RACFADM"}, "text": "/*%NOCOMMENT====================* REXX *==============================*/\n/*  PURPOSE:  RACFADM - Settings - Executes when RACFADM is invoked   */\n/*--------------------------------------------------------------------*/\n/*  NOTES:    1) This member will read in $DEFSETG to obtain the      */\n/*               default Settings (Option 0) for new users and if     */\n/*               necessary, force a refresh of a sections variables   */\n/*               (General, Management, etc.) by setting the variable  */\n/*               'SETR??? = Y'                                        */\n/*                                                                    */\n/*            2) To override these settings, create a member called   */\n/*               $DEFSITE and define/set any variables                */\n/*               - The $DEFSITE member is optional, but if it exists, */\n/*                 it will be read and override any settings defined  */\n/*                 in member $DEFSETG                                 */\n/*               - This will prevent from having to update the        */\n/*                 $DEFSETG member everytime a new version of         */\n/*                 RACFADM is installed                               */\n/*                                                                    */\n/*            3) The following are the naming standard for variables  */\n/*               used to save the user's Settings (Option 0)          */\n/*               - Syntax                                             */\n/*                   SET#????                                         */\n/*               - Where                                              */\n/*                   SET .... Settings (Option 0)                     */\n/*                   # ...... G=General, M=Management, T=Adding TSO   */\n/*                            Userid, P=Program/Panel (Load, REXX or  */\n/*                            CLIST member), D=Dataset, J=JCL and     */\n/*                            R=Refresh                               */\n/*                   ???? ... Field name, any characters and for      */\n/*                            Refresh variables (4th chr = R) the     */\n/*                            variables (4th chr = R) the section     */\n/*                            name (GEN, MGT, TSO, MVS and IBM)       */\n/*               - The REXX programs and panels will translate the    */\n/*                 abbreviated contents to its full word, in hopes    */\n/*                 of making it easier to understand/maintain the     */\n/*                 code, for example: Y, will be translated to YES    */\n/*                                                                    */\n/*--------------------------------------------------------------------*/\n/* FLG  YYMMDD  USERID   DESCRIPTION                                  */\n/* ---  ------  -------  -------------------------------------------- */\n/* @AM  201130  RACFA    Validate GDG base, without recalling gens    */\n/* @AL  200720  LBD      Fix to honor lowercase password              */\n/* @AK  200702  RACFA    Reduced lines of code, easier to maintain    */\n/* @AJ  200702  RACFA    Fix refreshing SHOWMVS variables             */\n/* @AI  200702  RACFA    Allow symbolic in dsnames                    */\n/* @AH  200627  RACFA    Validate RACFMSG backup log DSN is valid     */\n/* @AG  200627  RACFA    Upper case record                            */\n/* @AF  200627  RACFA    Chg LOG to MSG                               */\n/* @AE  200627  RACFA    Chg SLOG to LOG and chk cols 5-7, was 4-8    */\n/* @AD  200625  RACFA    Fixed refreshing SDSF Log file file          */\n/* @AC  200624  RACFA    Chg/standardize site variable for SDSF log   */\n/* @AB  200620  RACFA    Add code to refresh RACFMSGs OPERLOG Bkp dsn */\n/* @AA  200617  RACFA    Add code to refresh RACFRPTs IRRDBU00 dsn    */\n/* @A9  200617  RACFA    Fix refreshing several sections (TSO/MGT/etc)*/\n/* @A8  200528  RACFA    Allow forcing redefining a sections variables*/\n/* @A7  200523  LBD      Allow a site override mbr, called $DEFSITE   */\n/* @A6  200522  RACFA    Added DROP REC.                              */\n/* @A5  200519  RACFA    Validate SHOWMVS DSN exit/valid              */\n/* @A4  200512  RACFA    Validate IBM RACF DSNs exist/valid           */\n/* @A3  200512  RACFA    Moved chking/defining var W3 out of SELECT   */\n/* @A2  200511  RACFA    Remove single/double quotes                  */\n/* @A1  200511  RACFA    Added SETMIBM                                */\n/* @A0  200501  RACFA    Created REXX                                 */\n/*====================================================================*/\nMBRDSETG    = \"$DEFSETG\"   /* Default Settings member      */\nMBRDSITE    = \"$DEFSITE\"   /* Site Default Overrides       */ /* @A7 */\nDDNAME      = 'RACFA'RANDOM(0,999) /* Unique ddname        */\nNEWUSER     = 'N'                  /* New user?            */ /* @A8 */\n\nADDRESS ISPEXEC\n  'vget (SETMADMN) profile'\n  if (setmadmn = \"\") then                                     /* @A8 */\n     newuser = 'Y'                                            /* @A8 */\n\n  \"QLIBDEF ISPPLIB TYPE(DATASET) ID(DSNAMEW)\"                 /* @A7 */\n  if (RC > 0) then\n     call RACFMSGS ERR19\n  DSNAME  = \"'\"STRIP(DSNAMEW,,\"'\")\"(\"MBRDSETG\")'\"             /* @A7 */\n  SITEDSN = \"'\"STRIP(DSNAMEW,,\"'\")\"(\"MBRDSITE\")'\"             /* @A7 */\n\nADDRESS TSO\n  \"ALLOC FI(\"DDNAME\") DA(\"DSNAME\") SHR REUSE\"\n  \"EXECIO * DISKR \"DDNAME\" (STEM REC. FINIS\"\n  \"FREE FI(\"DDNAME\")\"\n\n/* ------------------------------- *                          /* @A7 */\n | Check for Site Over-Ride Member |                          /* @A7 */\n | And if so combine into REC. stem|                          /* @A7 */\n * ------------------------------- */                         /* @A7 */\n if (sysdsn(sitedsn) = 'OK') then do                          /* @A7 */\n    \"ALLOC FI(\"DDNAME\") DA(\"SITEDSN\") SHR REUSE\"              /* @A7 */\n    \"EXECIO * DISKR \"DDNAME\" (STEM site. FINIS\"               /* @A7 */\n    \"FREE FI(\"DDNAME\")\"                                       /* @A7 */\n    oc = rec.0                                                /* @A7 */\n    do i = 1 to site.0                                        /* @A7 */\n       oc = oc + 1                                            /* @A7 */\n       rec.oc = site.i                                        /* @A7 */\n    end                                                       /* @A7 */\n    rec.0 = oc                                                /* @A7 */\n  end                                                         /* @A7 */\n  drop site.                                                  /* @A7 */\n\nADDRESS ISPEXEC\n  DO J = 1 TO REC.0\n     IF (SUBSTR(REC.J,1,1) = \"*\") THEN ITERATE\n     PARSE UPPER VAR REC.J W1 W2 W3 W4 .                      /* @AG */\n     IF (W3 = \"/*\") THEN W3 = \"\"                              /* @AG */\n     IF (W3 = \"Y\")  THEN W3 = \"YES\"                           /* @AG */\n     IF (W3 = \"N\")  THEN W3 = \"NO\"                            /* @AG */\n     CKCHR4    = SUBSTR(W1,4,1)                               /* @AK */\n     CKCHR4TO7 = SUBSTR(W1,4,4)                               /* @AK */\n     SELECT\n        WHEN (W1 = \"SETGDISP\") THEN\n             SELECT\n                WHEN (W3 = \"B\")  THEN W3 = \"BROWSE\"           /* @A7 */\n                WHEN (W3 = \"E\")  THEN W3 = \"EDIT\"             /* @A7 */\n                WHEN (W3 = \"V\")  THEN W3 = \"VIEW\"             /* @A7 */\n                OTHERWISE NOP\n             END\n        WHEN (W1 = \"SETMSHOW\") THEN\n             SELECT\n                WHEN (W3 = \"D\")  THEN W3 = \"DISPLAY\"          /* @A7 */\n                WHEN (W3 = \"L\")  THEN W3 = \"LOG\"              /* @A7 */\n                WHEN (W3 = \"B\")  THEN W3 = \"BOTH\"             /* @A7 */\n                OTHERWISE NOP\n             END\n        WHEN (W1 = \"SETMTRAC\") THEN\n             SELECT\n                WHEN (W3 = \"L\")  THEN W3 = \"LABELS\"           /* @A7 */\n                WHEN (W3 = \"P\")  THEN W3 = \"PROGRAMS\"         /* @A7 */\n                WHEN (W3 = \"R\")  THEN W3 = \"RESULTS\"          /* @A7 */\n                OTHERWISE NOP\n             END\n        WHEN (W1 = \"SETTPSWD\") THEN                           /* @AL */\n             W3 = word(rec.j,3)                               /* @AL */\n        WHEN (CKCHR4 = \"D\") & (W3 <> \"\") THEN DO              /* @AK */\n             PARSE VAR W3 DSN1 \"&\" SYMBOL \".\" DSN2            /* @AK */\n             SYMBVAL = MVSVAR(\"SYMDEF\",SYMBOL)                /* @AK */\n             TSTW3   = DSN1\"\"SYMBVAL\"\"DSN2                    /* @AK */\n             PARSE VAR TSTW3 TSTW3 \"(\" .                      /* @AK */\n             TSTW3   = STRIP(TSTW3,,\"'\")                      /* @AK */\n             TSTW3   = STRIP(TSTW3,,'\"')                      /* @AK */\n             X = OUTTRAP(\"LCRPT.\",1)                          /* @AM */\n             ADDRESS TSO \"LISTCAT ENT('\"TSTW3\"')\"             /* @AM */\n             X = OUTTRAP(\"OFF\")                               /* @AM */\n             PARSE VAR LCRPT.1 W1 W2 W3 W4                    /* @AM */\n             IF (W1 <> \"GDG\") & (W2 <> \"BASE\") THEN           /* @AM */\n                IF (SYSDSN(\"'\"TSTW3\"'\") <> \"OK\") THEN DO      /* @AM */\n                   RACFSMSG = \"$DEFSETG - Invalid DSN\"        /* @AM */\n                   RACFLMSG = \"The variable \"W1\" has a\",      /* @AM */\n                              \"dataset defined to it, that\",  /* @AM */\n                              \"DOES NOT EXIST, DSN=\"TSTW3\".\", /* @AM */\n                              \" Please update/fix the site\",  /* @AM */\n                              \"default settings in the\",      /* @AM */\n                              \"panel member $DEFSETG or\",     /* @AM */\n                              \"$DEFSITE.\"                     /* @AM */\n                   \"SETMSG MSG(RACF011)\"                      /* @AM */\n                END                                           /* @AM */\n             IF (CKCHR4TO7 = \"DMVS\"),                         /* @AK */\n              | (CKCHR4TO7 = \"DIBM\") THEN DO                  /* @AK */\n                W3 = STRIP(W3,,\"'\")                           /* @AK */\n                W3 = STRIP(W3,,'\"')                           /* @AK */\n             END                                              /* @AK */\n        END                                                   /* @AK */\n        OTHERWISE NOP\n     END\n\n     INTERPRET W1\" = W3\"                                      /* @A7 */\n     CKCHR1TO4 = SUBSTR(W1,1,4)                               /* @A9 */\n     CKCHR5TO7 = SUBSTR(W1,5,3)                               /* @AE */\n     SELECT                                                   /* @A8 */\n        /* Is this a variable used to Refresh?     */         /* @A8 */\n        WHEN (CKCHR1TO4 = \"SETR\") THEN                        /* @A9 */\n             CKRESVAR = W1                                    /* @A9 */\n        /* Refresh 'General' variables?            */         /* @A8 */\n        WHEN (CKRESVAR = \"SETRGEN\"),                          /* @A9 */\n           & (SETRGEN = \"YES\") THEN                           /* @A9 */\n             IF (CKCHR1TO4 = \"SETG\") THEN                     /* @A9 */\n                INTERPRET \"'VPUT (\"W1\") PROFILE'\"             /* @A8 */\n        /* Refresh 'Management' variables?         */         /* @A8 */\n        WHEN (CKRESVAR = \"SETRMGT\"),                          /* @A9 */\n           & (SETRMGT = \"YES\") THEN                           /* @A9 */\n             IF (CKCHR1TO4 = \"SETM\") THEN                     /* @A9 */\n                INTERPRET \"'VPUT (\"W1\") PROFILE'\"             /* @A8 */\n        /* Refresh 'Adding TSO Userid' variables?  */         /* @A8 */\n        WHEN (CKRESVAR = \"SETRTSO\"),                          /* @A9 */\n           & (SETRTSO = \"YES\") THEN                           /* @A9 */\n             IF (CKCHR1TO4 = \"SETT\") THEN                     /* @A9 */\n                INTERPRET \"'VPUT (\"W1\") PROFILE'\"             /* @A8 */\n        /* Refresh SHOWMVS program and dataset?    */         /* @A8 */\n        WHEN (CKRESVAR = \"SETRMVS\"),                          /* @AJ */\n           & (SETRMVS = \"YES\") THEN                           /* @A9 */\n             IF (CKCHR5TO7 = \"MVS\") THEN                      /* @AE */\n                INTERPRET \"'VPUT (\"W1\") PROFILE'\"             /* @A8 */\n        /* Refresh IBM RACF panel and datasets?    */         /* @A8 */\n        WHEN (CKRESVAR = \"SETRIBM\"),                          /* @A9 */\n           & (SETRIBM = \"YES\") THEN                           /* @A9 */\n             IF (CKCHR5TO7 = \"IBM\") THEN                      /* @AE */\n                INTERPRET \"'VPUT (\"W1\") PROFILE'\"             /* @A8 */\n        /* Refresh RACFRPTS IRRDBU00 dataset?      */         /* @AA */\n        WHEN (CKRESVAR = \"SETRRPT\"),                          /* @AA */\n           & (SETRRPT = \"YES\") THEN                           /* @AA */\n             IF (CKCHR5TO7 = \"RPT\") THEN                      /* @AE */\n                INTERPRET \"'VPUT (\"W1\") PROFILE'\"             /* @AA */\n        /* Refresh RACFMSG variables?              */         /* @AF */\n        WHEN (CKRESVAR = \"SETRMSG\"),                          /* @AF */\n           & (SETRMSG = \"YES\") THEN                           /* @AE */\n             IF (CKCHR5TO7 = \"MSG\") THEN                      /* @AF */\n                INTERPRET \"'VPUT (\"W1\") PROFILE'\"             /* @AB */\n        /* Not a new user?                         */         /* @A8 */\n        WHEN (NEWUSER = 'N') then                             /* @A8 */\n             NOP                                              /* @A8 */\n        /* Must be a new user then                 */         /* @A8 */\n        OTHERWISE                                             /* @A8 */\n             INTERPRET \"'VPUT (\"W1\") PROFILE'\"                /* @A8 */\n     END                                                      /* @A8 */\n  END\n  DROP REC.                                                   /* @A6 */\nRETURN\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RACFSETG": {"ttr": 939, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01.\\x00\\x07\\x01 \\x02?\\x01 \\x16?\\x18\\x17\\x00:\\x00\\t\\x00\\x00\\xd9\\xc1\\xc3\\xc6\\xc1\\xc4\\xd4@@@'", "ispf": {"version": "01.46", "flags": 0, "createdate": "2020-01-23T00:00:00", "modifydate": "2020-06-11T18:17:07", "lines": 58, "newlines": 9, "modlines": 0, "user": "RACFADM"}, "text": "/*%NOCOMMENT====================* REXX *==============================*/\n/*  PURPOSE:  RACFADM - User Settings - Menu option 0                 */\n/*--------------------------------------------------------------------*/\n/* FLG  YYMMDD  USERID   DESCRIPTION                                  */\n/* ---  ------  -------  -------------------------------------------- */\n/* @AA  200519  RACFA    Chk F3 (END) and leave settings              */\n/* @A9  200519  RACFA    Added displaying Showmvs dataset             */\n/* @A8  200511  RACFA    Added displaying IBM RACF datasets           */\n/* @A7  200423  RACFA    Move PARSE REXXPGM name up above IF SETMTRAC */\n/* @A6  200423  RACFA    Ensure REXX program name is 8 chars long     */\n/* @A5  200413  RACFA    Chg TRACEing to only display banner (P=Pgms) */\n/* @A4  200412  RACFA    Chg TRACE to allow 'L'abels or 'R'esults     */\n/* @A3  200224  RACFA    Place panels at top of REXX in variables     */\n/* @A2  200221  RACFA    Make 'ADDRESS ISPEXEC' defualt, reduce code  */\n/* @A1  200220  RACFA    Added SETMTRAC=YES, then TRACE R             */\n/* @A0  200123  RACFA    Created REXX                                 */\n/*====================================================================*/\nPANEL16     = \"RACFSETG\"   /* Settings, menu option 0      */ /* @A3 */\nPANEL17     = \"RACFSETH\"   /* Showmvs  dataset             */ /* @A9 */\nPANEL18     = \"RACFSETI\"   /* IBM RACF datasets            */ /* @A8 */\nparse source . . REXXPGM .         /* Obtain REXX pgm name */ /* @A7 */\nREXXPGM     = LEFT(REXXPGM,8)                                 /* @A7 */\n\nADDRESS ISPEXEC                                               /* @A2 */\n  \"VGET (SETMTRAC) PROFILE\"                                   /* @A1 */\n  If (SETMTRAC <> 'NO') then do                               /* @A4 */\n     Say \"*\"COPIES(\"-\",70)\"*\"                                 /* @A4 */\n     Say \"*\"Center(\"Begin Program = \"REXXPGM,70)\"*\"           /* @A4 */\n     Say \"*\"COPIES(\"-\",70)\"*\"                                 /* @A4 */\n     if (SETMTRAC <> 'PROGRAMS') THEN                         /* @A5 */\n        interpret \"Trace \"SUBSTR(SETMTRAC,1,1)                /* @A4 */\n  end                                                         /* @A4 */\n\n  DO FOREVER\n     \"Display Panel(\"PANEL16\")\"\n     IF (RC = 8) THEN LEAVE                                   /* @AA */\n\n     \"VGET (SETGMVSD) PROFILE\"       /* Showmvs pgm/dsn  */   /* @A9 */\n     IF (SETGMVSD = \"YES\") THEN DO                            /* @A9 */\n        \"Display Panel(\"PANEL17\")\"                            /* @A9 */\n        SETGMVSD  = \"NO\"                                      /* @A9 */\n        \"VPUT (SETGMVSD)\"                                     /* @A9 */\n     END                                                      /* @A9 */\n\n     \"VGET (SETMIBMD) PROFILE\"      /* IBM RACF datasets */   /* @A8 */\n     IF (SETMIBMD = \"YES\") THEN DO                            /* @A8 */\n        \"Display Panel(\"PANEL18\")\"                            /* @A8 */\n        SETMIBMD  = \"NO\"                                      /* @A8 */\n        \"VPUT (SETMIBMD)\"                                     /* @A8 */\n     END                                                      /* @A8 */\n  END /* Do Forever */\n\n  If (SETMTRAC <> 'NO') then do                               /* @A4 */\n     Say \"*\"COPIES(\"-\",70)\"*\"                                 /* @A4 */\n     Say \"*\"Center(\"End Program = \"REXXPGM,70)\"*\"             /* @A4 */\n     Say \"*\"COPIES(\"-\",70)\"*\"                                 /* @A4 */\n  end                                                         /* @A4 */\nEXIT                                                          /* @A4 */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RACFUSR": {"ttr": 959, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x16\\x00#\\x01 \\x18\\x8f\\x01 3\\x7f\\x08\\x02\\x06\\x82\\x06l\\x00\\x00\\xd9\\xc1\\xc3\\xc6\\xc1\\xc4\\xd4@@@'", "ispf": {"version": "01.22", "flags": 0, "createdate": "2020-07-06T00:00:00", "modifydate": "2020-12-02T08:02:23", "lines": 1666, "newlines": 1644, "modlines": 0, "user": "RACFADM"}, "text": "/*%NOCOMMENT====================* REXX *==============================*/\n/*  PURPOSE:  RACFADM - User Profiles - Menu option 1                 */\n/*--------------------------------------------------------------------*/\n/*  NOTES:    1) Line command 'XR', Cross Reference Report, is not    */\n/*               displayed (hidden) on panel RACFUSR2                 */\n/*               - Reason for this is sites with a large RACF         */\n/*                 database, the time for 'IRRUT100' to read/obtain   */\n/*                 the data is significant                            */\n/*               - This command can only be accessed/used when        */\n/*                 Settings (option 0) 'Administration = Y'           */\n/*--------------------------------------------------------------------*/\n/* FLG  YYMMDD  USERID   DESCRIPTION                                  */\n/* ---  ------  -------  -------------------------------------------- */\n/* @EU  201201  RACFA    Unhide line command X for ADMIN users        */\n/* @ET  201130  TRIDJK   Added hidden line commands X and XR          */\n/* @ES  200913  LBD      Bypass AUTOUID if a UID exists               */\n/* @ER  200911  LBD      Enclose OMVS home/program in quotes          */\n/* @EQ  200821  TRIDJK   Password phrase support                      */\n/* @EP  200708  TRIDJK   Msg if selection list has no entries ('NONE')*/\n/* @EO  200622  TRIDJK   Line cmd A/C, added DATA field               */\n/* @EN  200618  RACFA    Chged SYSDA to SYSALLDA                      */\n/* @EM  200617  RACFA    Added comments to right of variables         */\n/* @EL  200616  RACFA    Added capability to SAve file as TXT/CSV     */\n/* @EK  200610  RACFA    Added primary command 'SAVE'                 */\n/* @EJ  200604  RACFA    Fix, prevent from going to top of table      */\n/* @EI  200527  RACFA    Fix, allow typing 'S' on multiple rows       */\n/* @EH  200520  RACFA    Display line cmd 'P'rofile, when 'Admin=N'   */\n/* @EG  200517  LBD      Prevent user from deleting their own userid  */\n/* @EF  200504  TRIDJK   Adding, place in order, prior was at bottom  */\n/* @EE  200502  LBD      Re-worked displaying tables, use DO FOREVER  */\n/* @ED  200501  LBD      Add primary commands FIND/RFIND              */\n/* @EC  200430  RACFA    Chg tblb to TABLEB, moved def. var. up top   */\n/* @EB  200430  RACFA    Chg tbla to TABLEA, moved def. var. up top   */\n/* @EA  200429  RACFA    Re-arranged variables (General, Mgmt, TSO)   */\n/* @E9  200426  RACFA    Chged var. ERAIPSWD to SETTPSWD (user pswd)  */\n/* @E8  200425  RACFA    Chk Settings (Opt 0) 'Initial Password' field*/\n/* @E7  200424  RACFA    Chged 'A'dd, 'C'hange and 'P'roile act msg   */\n/* @E6  200424  RACFA    Changed ZAP to ALTUSR (line cmd AL)          */\n/* @E5  200424  RACFA    Added lower case to random password          */\n/* @E4  200424  RACFA    Updated RESET, pass filter, ex: R filter     */\n/* @E3  200424  RACFA    Chg msg RACF013 to RACF012                   */\n/* @E2  200424  RACFA    Move DDNAME at top, standardize/del dups     */\n/* @E1  200424  RACFA    Add linc cmd, create/display random password */\n/* @DZ  200423  RACFA    Move PARSE REXXPGM name up above IF SETMTRAC */\n/* @DY  200423  RACFA    'Status Interval' by percentage (SETGSTAP)   */\n/* @DX  200423  RACFA    Don't make ATT=YES, when userid is 'REVOKED' */\n/* @DW  200422  TRIDJK   Fixed IRRXUTIL RC when displaying RACF cmds  */\n/* @DV  200422  RACFA    Ensure the REXX program name is 8 chars      */\n/* @DU  200422  RACFA    Use variable REXXPGM in log msg              */\n/* @DT  200422  RACFA    Updated comments above @ADDD/@CHGD           */\n/* @DS  200421  RACFA    Renamed RACFUSR#/@ to RACFUSR5/6             */\n/* @DR  200421  RACFA    Del panels RACFUSR6/7 (addd/chgd)            */\n/* @DQ  200421  RACFA    Del subroutine ADDD/CHGD, and some code      */\n/* @DP  200420  TRIDJK   Use panel RACFUSR@ for SETMIRRX='YES/NO'     */\n/* @DO  200417  RACFA    Changed date to 'U'SA, was 'O'rdered         */\n/* @DN  200417  TRIDJK   Added 'Created' date                         */\n/* @DM  200413  RACFA    Chg TRACEing to only display banner (P=Pgms) */\n/* @DL  200412  RACFA    If line cmds Add/Change fail, display err msg*/\n/* @DK  200412  RACFA    Chg TRACE to allow 'L'abels or 'R'esults     */\n/* @DJ  200408  RACFA    Removed duplicate line cmd (R-Rem)           */\n/* @DI  200407  RACFA    Added another dynamic area to RACFUSR2 panel */\n/* @DH  200407  RACFA    Display PW when 'Admin RACF API = N'         */\n/* @DG  200407  RACFA    Added line command 'PW', Password            */\n/* @DF  200407  RACFA    EXCMD removed 'else msg_var = 1 to msg.0'    */\n/* @DE  200407  RACFA    Let user type in password on panel           */\n/* @DD  200406  RACFA    'Admin RACF API = Y', chged password to user */\n/* @DC  200404  RACFA    Fixed IRRXUTIL, needed quotes around variable*/\n/* @DB  200404  RACFA    Fixed IRRXUTIL, needed quotes around USER    */\n/* @DA  200404  RACFA    Chk RACF cmd length, use necessary msg panel */\n/* @D9  200404  RACFA    Chged subroutine comments in flower box      */\n/* @D8  200404  RACFA    Chged message variable names                 */\n/* @D7  200404  RACFA    'Admin RACF API = Y' then display 'P'rofile  */\n/* @D6  200403  RACFA    If adding userid fails return                */\n/* @D5  200403  RACFA    Allow displaying/logging command             */\n/* @D4  200403  TRIDJK   Added RACF API opt for A and C line commands */\n/* @D3  200402  RACFA    Chg LRECL=132 to LRECL=80                    */\n/* @D2  200401  RACFA    Create subroutine to VIEW/EDIT/BROWSE        */\n/* @D1  200401  RACFA    Chged edit macro RACFLOGE to RACFEMAC        */\n/* @CZ  200401  RACFA    VIEW/EDIT use edit macro, to turn off HILITE */\n/* @CY  200330  RACFA    RACFUSR3, point/shoot sort ascend/descending */\n/* @CX  200330  RACFA    Allow point-n-shoot sort ascending/descending*/\n/* @CW  200325  RACFA    Line cmd 'P', add '*Prof' to row             */\n/* @CV  200324  RACFA    Allow both Display/logging of RACF commands  */\n/* @CU  200324  RACFA    Allow logging RACF commands to ISPF Log file */\n/* @CT  200322  RACFA    Del an unnecessary END statement on Line 629 */\n/* @CS  200320  RACFA    Relocate code to upd attrs and row           */\n/* @CR  200319  RACFA    Fix changing a TSO userid when 'TSO User=N'  */\n/* @CQ  200317  RACFA    Fix obtaining TSO acct, proc, size and unit  */\n/* @CP  200317  RACFA    Init TSOLIB=Y/N, if SETTUDSN has dsname      */\n/* @CO  200315  RACFA    Added line command 'P-Profile' to RACFUSR3   */\n/* @CN  200315  RACFA    Fixed typing in L as 1st line command        */\n/* @CM  200315  RACFA    Placed 'P-Prof' next to other list commands  */\n/* @CL  200315  RACFA    Renamed RACFSEQ to RACFPROF                  */\n/* @CK  200315  RACFA    Added line command 'P-Profile'               */\n/* @CJ  200313  RACFA    Chg subroutine name CHKATTR to UPDATTR       */\n/* @CI  200313  RACFA    After 'C'hanging userid, upd attribute vars  */\n/* @CH  200312  RACFA    Renamed attribute variables                  */\n/* @CG  200311  ZDOHK    Fix Atributes for user change                */\n/* @CF  200305  TRIDJK   Fix DELETE msgs for ISPPROF and TSOLIB       */\n/* @CE  200304  RACFA    Update ATT field on panel, when updated      */\n/* @CD  200304  RACFA    Del unnecessary double quotes                */\n/* @CC  200303  RACFA    Del 'ret_code' lines for PANEL01... While    */\n/* @CB  200303  RACFA    Chg 'ret_code = 0' to 'cmd_rc = rc'          */\n/* @CA  200303  RACFA    Chg 'RL class ALL' to 'RL class * ALL'       */\n/* @C9  200303  RACFA    Chk RC 'LG grp prms', if RC>0 then 'LU grp'  */\n/* @C8  200303  RACFA    Fixed chking RC after executing command      */\n/* @C7  200302  RACFA    Removed DO...END around code, not needed     */\n/* @C6  200302  RACFA    Chk RC 'LU ID PRMS', if RC>0 then 'LU ID'    */\n/* @C5  200301  RACFA    Check for 'NO ENTRIES MEET SEARCH CRITERIA'  */\n/* @C4  200228  RACFA    Removed quote/commas, using PARSE ARG instead*/\n/* @C3  200228  RACFA    Place single quotes around comma, prevent err*/\n/* @C2  200228  RACFA    Added PASSWORD() to ADDUSER                  */\n/* @C1  200228  RACFA    Removed ERAMCAT from VGET, not used          */\n/* @BZ  200227  RACFA    Had to add \"\" for contuation to work properly*/\n/* @BY  200227  RACFA    Fix continuation of statement                */\n/* @BX  200227  TRIDJK   Fix for add and change (NONE/PROTECTED)      */\n/* @BW  200227  RACFA    Added line command 'D', display user datasets*/\n/* @BU  200226  RACFA    Fix @BS chg, chg ret_code to cmd_rc          */\n/* @BT  200226  RACFA    Added 'CONTROL ERRORS RETURN'                */\n/* @BS  200226  RACFA    Added 'Return Code =' when displaying cmd    */\n/* @BR  200226  RACFA    Removed double quotes before/after cmd       */\n/* @BQ  200226  RACFA    Place NO in TSO field                        */\n/* @BP  200226  RACFA    Place NO in REVOKE field                     */\n/* @BO  200226  RACFA    Fixed SORTing ATTR2, was ATTR, and added NO  */\n/* @BN  200226  RACFA    Fixed ATTR color when sorting                */\n/* @BM  200224  RACFA    Standardize quotes, chg single to double     */\n/* @BL  200224  RACFA    Place panels at top of REXX in variables     */\n/* @BK  200223  RACFA    Del 'address TSO \"PROFILE MSGID\"', not needed*/\n/* @BJ  200223  RACFA    Simplified SORT, removed FLD/DFL_SORT vars   */\n/* @BI  200222  RACFA    Allowing abbreviating the column in SORT cmd */\n/* @BH  200222  RACFA    Removed translating OPTA/B, not needed       */\n/* @BG  200222  RACFA    Allow placing cursor on row and press ENTER  */\n/* @BF  200221  RACFA    Removed \"G = '(G)'\", not referenced          */\n/* @BE  200221  LBD      Add ONLY primary command                     */\n/* @BD  200221  RACFA    Display '*Search' to right of userid         */\n/* @BC  200221  RACFA    Make 'ADDRESS ISPEXEC' defualt, reduce code  */\n/* @BB  200220  RACFA    Fixed displaying all RACF commands           */\n/* @BA  200220  RACFA    Added SETMTRAC=YES, then TRACE R             */\n/* @B9  200220  RACFA    Removed initializing SETGSTA variable        */\n/* @B8  200220  RACFA    Removed SE (Search) when general user (USR3) */\n/* @B7  200220  RACFA    Added capability to browse/edit/view file    */\n/* @B6  200220  RACFA    Removed SE (Search) from panel RACFUSR3      */\n/* @B5  200220  RACFA    Chged REXX pgm name RACFTSO to RACFUSRT      */\n/* @B4  200219  RACFA    Display SE (Search), was a hidden line cmd   */\n/* @B3  200218  RACFA    Use dynamic area to display SELECT commands  */\n/* @B2  200218  RACFA    Chged SETMADMN to YES/NO, was userid         */\n/* @B1  200218  RACFA    Fixed SETMADMN, was ERAADMIN                 */\n/* @AZ  200218  RACFA    Added 'Status Interval' option               */\n/* @AY  200216  RACFA    Chg color to turq/green, was white/turq      */\n/* @AX  200214  RACFA    Changed REXX pgm name RACFXREF to RACFUSRX   */\n/* @AU  200206  RACFA    Fix color of sort col, when F3, diff. id     */\n/* @AT  200206  RACFA    Fix SORT, place at top of table              */\n/* @AS  200206  RACFA    Fix RESET, was not placing at top of table   */\n/* @AR  200206  RACFA    Fix LOCATE, not working when sort descending */\n/* @AQ  200205  TRIDJK   Allow A/D in SORT command                    */\n/* @AP  200131  TRIDJK   Simulate irr* permanent user profiles        */\n/* @AO  200131  TRIDJK   Fixed logon date for digital certicate logons*/\n/* @AN  200126  TRIDJK   Chged yy.jjj to yy/mm/dd                     */\n/* @AM  200123  RACFA    Retrieve default filter, Option 0 - Settings */\n/* @AL  200123  TRIDJK   Add XR (cross reference report) line command */\n/* @AK  200122  RACFA    Del TBTOP after selecting row, was chg @A7   */\n/* @AJ  200122  TRIDJK   Test/del MFA option from 'LU userid' command */\n/* @AI  200122  RACFA    Fixed displaying logon date                  */\n/* @AH  200120  RACFA    Removed 'say msg.msg_var' in EXCMD procedure */\n/* @AG  200120  RACFA    Fixed continuation issue                     */\n/* @AF  200119  RACFA    Standardized/reduced lines of code           */\n/* @AE  200119  RACFA    Added comment box above procedures           */\n/* @AD  200119  RACFA    Fixed F3 (END) when adding/changing TSO user */\n/* @AC  200118  RACFA    Added line command 'L', list group           */\n/* @AB  200117  RACFA    Fixed attributes on Change/Add screens       */\n/* @AA  200116  RACFA    Changed colors, White/Turq, was Turq/Blue    */\n/* @A9  200115  RACFA    If id has attributes, place YES in 'Att' col */\n/* @A8  200115  RACFA    Renamed variable WFLOCARG to LOCARG          */\n/* @A7  200115  RACFA    Fixed sort/locate, multiple issues           */\n/* @A6  200114  RACFA    Change the color for sorted column           */\n/* @A5  200114  RACFA    Allow abbrev, locate on sorted column, reset */\n/* @A4  200114  TRIDJK   Changed action (msg)                         */\n/* @A3  200114  RACFA    Fixed SORT command thanks to John Kalinich   */\n/* @A2  200113  RACFA    Add alloc/exec/free, instead of RACFLIST     */\n/* @A1  200110  RACFA    Invoke RACFLIST when displaying a userid     */\n/* @A0  011229  NICORIZ  Created REXX, V2.1, www.rizzuto.it           */\n/*====================================================================*/\nPANEL01     = \"RACFUSR1\"   /* Set filter, menu option 1    */ /* @BL */\nPANEL02     = \"RACFUSR2\"   /* List userids (admin/user)    */ /* @D4 */\nPANEL03     = \"RACFUSR3\"   /* Show groups and access       */ /* @BL */\nPANEL04     = \"RACFUSR4\"   /* Connect profile              */ /* @BL */\nPANEL05     = \"RACFUSR5\"   /* Alter userids (admin)        */ /* @E6 */\nPANEL06     = \"RACFUSR6\"   /* Add/change userid            */ /* @DT */\nPANEL07     = \"RACFUSR7\"   /* Change connection            */ /* @BL */\nPANEL08     = \"RACFUSR8\"   /* Alter TSO segment            */ /* @BL */\nPANELM2     = \"RACFMSG2\"   /* Display RACF command and RC  */ /* @BL */\nPANELM3     = \"RACFMSG3\"   /* Display RACF IRXXUTIL Cmd    */ /* @D4 */\nPANELS1     = \"RACFSAVE\"   /* Obtain DSName to SAVE        */ /* @EK */\nSKELETON1   = \"RACFUSR2\"   /* Save tablea to dataset       */ /* @EK */\nSKELETON2   = \"RACFUSR3\"   /* Save tableb to dataset       */ /* @EK */\nEDITMACR    = \"RACFEMAC\"   /* Edit Macro, turn HILITE off  */ /* @CZ */\nTABLEA      = 'TA'RANDOM(0,99999)  /* Unique table name A  */ /* @EB */\nTABLEB      = 'TB'RANDOM(0,99999)  /* Unique table name B  */ /* @EC */\nDDNAME      = 'RACFA'RANDOM(0,999) /* Unique ddname        */ /* @E2 */\nparse source . . REXXPGM .         /* Obtain REXX pgm name */ /* @DZ */\nREXXPGM     = LEFT(REXXPGM,8)                                 /* @DZ */\nNULL        = ''                                              /* @ED */\n\nADDRESS ISPEXEC                                               /* @BC */\n  Arg Rfilter\n  If (Rfilter = '') Then Do                                   /* @AM */\n     \"VGET (SETGFLTR) PROFILE\"                                /* @AM */\n     Rfilter = SETGFLTR                                       /* @AM */\n  end                                                         /* @AM */\n  Call Digital_Certs                                          /* @AP */\n  Rclass = 'USER'\n\n  \"CONTROL ERRORS RETURN\"                                     /* @B1 */\n  \"VGET (SETGSTA  SETGSTAP SETGDISP SETMADMN\",                /* @EA */\n        \"SETMIRRX SETMSHOW SETMTRAC SETTPSWD\",                /* @EA */\n        \"SETTPROF SETTUDSN SETMPHRA) PROFILE\"                 /* @EQ */\n\n  If (SETMTRAC <> 'NO') then do                               /* @DK */\n     Say \"*\"COPIES(\"-\",70)\"*\"                                 /* @DK */\n     Say \"*\"Center(\"Begin Program = \"REXXPGM,70)\"*\"           /* @DK */\n     Say \"*\"COPIES(\"-\",70)\"*\"                                 /* @DK */\n     if (SETMTRAC <> 'PROGRAMS') THEN                         /* @DM */\n        interpret \"Trace \"SUBSTR(SETMTRAC,1,1)                /* @DK */\n  end                                                         /* @DK */\n\n  If (SETTUDSN <> \"\") then                                    /* @CP */\n     TSOLIB = 'Y'                                             /* @CP */\n  else                                                        /* @CP */\n     TSOLIB = 'N'                                             /* @CP */\n\n  If (SETMADMN = \"YES\") then do                               /* @B2 */\n     IF (SETMIRRX = \"YES\") then do                            /* @D7 */\n        SELCMD2A = \"[S]Show[SE]Srch[L]List[P]Prof\"||,         /* @DI */\n                   \"[D]Dsn[PW]Pswd[C]Chg[A]Add[R]Rem\"||,      /* @DI */\n                   \"[RS]Res\"                                  /* @DI */\n        SELCMD2B = \" [RV]Rev[AL]Alt[X]Xref\"                   /* @EU */\n        SELCMDS3 = \"[S]Show,[L]List,[P]Profile,\"||,           /* @CO */\n                   \"[C]Change,[A]Add,[R]Remove\"               /* @CO */\n     end                                                      /* @D7 */\n     else do                                                  /* @D7 */\n        SELCMD2A = \"[S]Show[SE]Srch[L]List\"||,                /* @DI */\n                   \"[D]Dsn[PW]Pswd[C]Chg[A]Add[R]Rem\"||,      /* @DI */\n                   \"[RS]Res[RV]Rev\"                           /* @DJ */\n        SELCMD2B = \"        [AL]Alt[X]Xref\"                   /* @EU */\n        SELCMDS3 = \"[S]Show,[L]List,\"||,                      /* @D7 */\n                   \"[C]Change,[A]Add,[R]Remove\"               /* @D7 */\n     end                                                      /* @D7 */\n  end\n  else do\n     IF (SETMIRRX = \"YES\") then do                            /* @EH */\n        SELCMD2A = \"[S]Show,[SE]Search,[L]list,\"||,           /* @EH */\n                   \"[P]Profile,[D]Dsn\"                        /* @EH */\n        SELCMDS3 = \"[S]Show,[L]list,[P]Profile\"               /* @EH */\n     end\n     else do                                                  /* @EH */\n        SELCMD2A = \"[S]Show,[SE]Search,[L]list,[D]Dsn\"        /* @DI */\n        SELCMDS3 = \"[S]Show,[L]list\"                          /* @B8 */\n     end                                                      /* @EH */\n     SELCMD2B = \"\"                                            /* @DI */\n  end\n\n  rlv       = SYSVAR('SYSLRACF')\n  called    = SYSVAR('SYSNEST')\n  if (called = 'YES') then \"CONTROL NONDISPL ENTER\"\n\n  \"DISPLAY PANEL(\"PANEL01\")\" /* get profile */                /* @BL */\n  Do while (rc = 0)\n     call Profl\n     if (called <> 'YES') then\n        \"DISPLAY PANEL(\"PANEL01\")\"                            /* @BL */\n  End\n\n  If (SETMTRAC <> 'NO') then do                               /* @DK */\n     Say \"*\"COPIES(\"-\",70)\"*\"                                 /* @DK */\n     Say \"*\"Center(\"End Program = \"REXXPGM,70)\"*\"             /* @DK */\n     Say \"*\"COPIES(\"-\",70)\"*\"                                 /* @DK */\n  end                                                         /* @DK */\nEXIT\n/*--------------------------------------------------------------------*/\n/*  Show all profiles for a filter                                    */\n/*--------------------------------------------------------------------*/\nPROFL:\n  call CREATE_TABLEA                                          /* @BE */\n  if (USER = 'INVALID') | (USER = 'NONE') THEN DO             /* @EP */\n     \"TBEND\" tbla\n     call racfmsgs 'ERR16' msg.1                              /* @X1 */\n     rc=8                                                     /* @EP */\n     return\n  end\n  opta   = ' '\n  xtdtop = 0                                                  /* @EE */\n  rsels  = 0                                                  /* @EE */\n  do forever                                                  /* @EE */\n     if (rsels < 2) then do                                   /* @EE */\n        \"TBTOP \" TABLEA                                       /* @EE */\n        'tbskip' tablea 'number('xtdtop')'                    /* @EE */\n        radmrfnd = 'PASSTHRU'                                 /* @EE */\n        'vput (radmrfnd)'                                     /* @EE */\n        \"TBDISPL\" TABLEA \"PANEL(\"PANEL02\")\"                   /* @EE */\n     end                                                      /* @EE */\n     else 'tbdispl' tablea                                    /* @EE */\n     if (rc > 4) then leave                                   /* @EE */\n     xtdtop   = ztdtop                                        /* @EE */\n     rsels    = ztdsels                                       /* @EE */\n     radmrfnd = null                                          /* @EE */\n     'vput (radmrfnd)'                                        /* @EE */\n     PARSE VAR ZCMD ZCMD PARM SEQ                             /* @EE */\n     IF (SROW <> \"\") & (SROW <> 0) THEN                       /* @BG */\n        IF (SROW > 0) THEN DO                                 /* @BG */\n           \"TBTOP \" TABLEA                                    /* @BG */\n           \"TBSKIP\" TABLEA \"NUMBER(\"SROW\")\"                   /* @BG */\n        END                                                   /* @BG */\n     if (zcmd = 'RFIND') then do                              /* @ED */\n        zcmd = 'FIND'                                         /* @ED */\n        parm = findit                                         /* @ED */\n        'tbtop ' TABLEA                                       /* @ED */\n        'tbskip' TABLEA 'number('last_find')'                 /* @ED */\n     end                                                      /* @ED */\n     Select\n        When (abbrev(\"FIND\",zcmd,1) = 1) then                 /* @ED */\n             call do_finda                                    /* @ED */\n        WHEN (ABBREV(\"LOCATE\",ZCMD,1) = 1) THEN do            /* @A5 */\n             if (parm <> '') then do\n                locarg = parm'*'\n                PARSE VAR SORT . \",\" . \",\" SEQ                /* @BJ */\n                IF (SEQ = \"D\") THEN                           /* @AR */\n                   CONDLIST = \"LE\"                            /* @AR */\n                ELSE                                          /* @AR */\n                   CONDLIST = \"GE\"                            /* @AR */\n                parse value sort with scan_field',' .\n                interpret scan_field ' = locarg'\n                'tbtop ' tablea\n                \"TBSCAN \"TABLEA\" ARGLIST(\"scan_field\")\",\n                        \"CONDLIST(\"CONDLIST\")\",\n                        \"position(scanrow)\"\n                xtdtop = scanrow\n             end\n        end\n        WHEN (ABBREV(\"ONLY\",ZCMD,1) = 1) THEN DO              /* @BE */\n             find_str = translate(parm)                       /* @BE */\n             'tbtop ' TABLEA                                  /* @BE */\n             'tbskip' TABLEA                                  /* @BE */\n             do forever                                       /* @BE */\n                str = translate(user name defgrp owner attr2) /* @BO */\n                if (pos(find_str,str) > 0) then nop           /* @BE */\n                else 'tbdelete' TABLEA                        /* @BE */\n                'tbskip' TABLEA                               /* @BE */\n                if (rc > 0) then do                           /* @BE */\n                   'tbtop' TABLEA                             /* @BE */\n                   leave                                      /* @BE */\n                end                                           /* @BE */\n             end                                              /* @BE */\n        END                                                   /* @LB */\n        WHEN (ABBREV(\"RESET\",ZCMD,1) = 1) THEN DO             /* @AS */\n             if (parm <> '') then                             /* @E4 */\n                rfilter = parm                                /* @E4 */\n             xtdtop   = 1                                     /* @AS */\n             \"TBEND\" TABLEA                                   /* @BE */\n             call CREATE_TABLEA                               /* @BE */\n        END                                                   /* @AS */\n        When (abbrev(\"SAVE\",zcmd,2) = 1) then DO              /* @EK */\n             TMPSKELT = SKELETON1                             /* @EK */\n             call do_SAVE                                     /* @EK */\n        END                                                   /* @EK */\n        WHEN (ABBREV(\"SORT\",ZCMD,1) = 1) THEN DO              /* @AT */\n             SELECT                                           /* @A5 */\n                when (ABBREV(\"USERID\",PARM,1) = 1) then\n                     call sortseq 'USER'                      /* @CX */\n                when (ABBREV(\"NAME\",PARM,1) = 1) then\n                     call sortseq 'NAME'                      /* @CX */\n                when (ABBREV(\"GROUP\",PARM,1) = 1) then        /* @BI */\n                     call sortseq 'DEFGRP'                    /* @CX */\n                when (ABBREV(\"LOGON\",PARM,1) = 1) then        /* @BI */\n                     call sortseq 'DATELGN'                   /* @CX */\n                when (ABBREV(\"OWNER\",PARM,1) = 1) then        /* @BI */\n                     call sortseq 'OWNER'                     /* @CX */\n                when (ABBREV(\"REV\",PARM,1) = 1) then          /* @BI */\n                     call sortseq 'REVOKED'                   /* @CX */\n                when (ABBREV(\"ATT\",PARM,1) = 1) then          /* @BN */\n                     call sortseq 'ATTR2'                     /* @CX */\n                when (ABBREV(\"TSO\",PARM,1) = 1) then          /* @BI */\n                     call sortseq 'TSOUSER'                   /* @CX */\n                otherwise NOP                                 /* @A5 */\n           END                                                /* @A5 */\n           CLRUSER  = \"GREEN\"; CLRNAME = \"GREEN\"              /* @EE */\n           CLRDEFG  = \"GREEN\"; CLRDATE = \"GREEN\"              /* @EE */\n           CLROWNE  = \"GREEN\"; CLRREVO = \"GREEN\"              /* @EE */\n           CLRATTR  = \"GREEN\"; CLRTSOU = \"GREEN\"              /* @EE */\n           PARSE VAR SORT LOCARG \",\" .                        /* @EE */\n           INTERPRET \"CLR\"SUBSTR(LOCARG,1,4)\" = 'TURQ'\"       /* @EE */\n           \"TBSORT \"TABLEA\" FIELDS(\"sort\")\"                   /* @EE */\n           \"TBTOP  \"TABLEA                                    /* @EE */\n        END                                                   /* @AT */\n        otherwise NOP\n     End /* Select */\n     ZCMD = \"\"; PARM = \"\"                                     /* @EE */\n     'control display save'                                   /* @EE */\n     Select\n        when (opta = 'A')  then call @Addd                    /* @DQ */\n        when (opta = 'C')  then call @Chgd                    /* @DQ */\n        when (opta = 'D')  then do                            /* @BW */\n             \"CONTROL DISPLAY SAVE\"                           /* @BW */\n             \"SELECT PGM(ISRDSLST)\",                          /* @BW */\n                    \"PARM(DSL '\"user\"')\",                     /* @BW */\n                    \"SUSPEND SCRNAME(DSL)\"                    /* @BW */\n             \"CONTROL DISPLAY RESTORE\"                        /* @BW */\n             action = '*Dsn'                                  /* @BW */\n             \"TBMOD\" TABLEA                                   /* @BW */\n        end                                                   /* @BW */\n        when (opta = 'L')  then call Lisd\n        when (opta = 'P') then do                             /* @CK */\n             call RACFPROF 'USER' user                        /* @CK */\n             action = '*Prof'                                 /* @CW */\n             \"TBMOD\" TABLEA                                   /* @CW */\n        end                                                   /* @CW */\n        when (opta = 'PW') then do                            /* @DG */\n             RC = RACFPSWD(user)                              /* @DG */\n             if (RC = 0) then do                              /* @DG */\n                action = '*Pswd'                              /* @DG */\n                \"TBMOD\" TABLEA                                /* @DG */\n             end                                              /* @DG */\n        end\n        when (opta = 'R')  then call Deld\n        when (opta = 'RS') then call Resd\n        when (opta = 'RV') then call Revd\n        when (opta = 'S')  then call Disd\n        when (opta = 'SE') then do\n             if (revoked <> 'YES') then\n                call RACFCLSS user\n             else\n                call racfmsgs 'ERR12' msg.1 /* user revoked */\n             action = '*Search'                               /* @BD */\n             \"TBMOD\" TABLEA                                   /* @BD */\n        end\n        when (opta = 'XR') then call RACFUSRX user            /* @ET */\n        when (opta = 'X') then call RACFUSRX user JCC         /* @ET */\n        when (opta = 'AL') then call Altd                     /* @E6 */\n        otherwise nop\n     End\n     'control display restore'                                /* @EE */\n  end  /* Do forever) */                                      /* @EE */\nRETURN\n/*--------------------------------------------------------------------*/\n/*  Process primary command FIND for TABLEA                      @ED  */\n/*--------------------------------------------------------------------*/\nDO_FINDA:                                                     /* @ED */\n  if (parm = null) then do                                    /* @ED */\n     racfsmsg = 'Error'                                       /* @ED */\n     racflmsg = 'Find requires a value to search for.' ,      /* @ED */\n                'Try again.'                                  /* @ED */\n     'setmsg msg(RACF011)'                                    /* @ED */\n     return                                                   /* @ED */\n  end                                                         /* @ED */\n  findit    = translate(parm)                                 /* @ED */\n  last_find = 0                                               /* @ED */\n  wrap      = 0                                               /* @ED */\n  do forever                                                  /* @ED */\n     'tbskip' TABLEA                                          /* @ED */\n     if (rc > 0) then do                                      /* @ED */\n        if (wrap = 1) then do                                 /* @ED */\n           racfsmsg = 'Not Found'                             /* @ED */\n           racflmsg = findit 'not found.'                     /* @ED */\n           'setmsg msg(RACF011)'                              /* @ED */\n           return                                             /* @ED */\n        end                                                   /* @ED */\n        if (wrap = 0) then wrap = 1                           /* @ED */\n        'tbtop' TABLEA                                        /* @ED */\n     end                                                      /* @ED */\n     else do                                                  /* @ED */\n        testit = translate(user name)                         /* @ED */\n        if (pos(findit,testit) > 0) then do                   /* @ED */\n           'tbquery' TABLEA 'position(srow)'                  /* @ED */\n           'tbtop'   TABLEA                                   /* @ED */\n           'tbskip'  TABLEA 'number('srow')'                  /* @ED */\n           last_find = srow                                   /* @ED */\n           xtdtop    = srow                                   /* @ED */\n           if (wrap = 0) then                                 /* @ED */\n              racfsmsg = 'Found'                              /* @ED */\n           else                                               /* @ED */\n              racfsmsg = 'Found/Wrapped'                      /* @ED */\n           racflmsg = findit 'found in row' srow + 0          /* @ED */\n           'setmsg msg(RACF011)'                              /* @ED */\n           return                                             /* @ED */\n        end                                                   /* @ED */\n     end                                                      /* @ED */\n  end                                                         /* @ED */\nRETURN                                                        /* @ED */\n/*--------------------------------------------------------------------*/\n/*  Define sort sequence, to allow point-n-shoot sorting (A/D)   @CX  */\n/*--------------------------------------------------------------------*/\nSORTSEQ:                                                      /* @CX */\n  parse arg sortcol                                           /* @CX */\n  INTERPRET \"TMPSEQ = SORT\"substr(SORTCOL,1,4)                /* @CX */\n  select                                                      /* @CX */\n     when (seq <> \"\") then do                                 /* @CX */\n          if (seq = 'A') then                                 /* @CX */\n             tmpseq = 'D'                                     /* @CX */\n          else                                                /* @CX */\n             tmpseq = 'A'                                     /* @CX */\n          sort = sortcol',C,'seq                              /* @CX */\n     end                                                      /* @CX */\n     when (seq = \"\"),                                         /* @CX */\n        & (tmpseq = 'A') then do                              /* @CX */\n           sort   = sortcol',C,A'                             /* @CX */\n           tmpseq = 'D'                                       /* @CX */\n     end                                                      /* @CX */\n     Otherwise do                                             /* @CX */\n        sort   = sortcol',C,D'                                /* @CX */\n        tmpseq = 'A'                                          /* @CX */\n     end                                                      /* @CX */\n  end                                                         /* @CX */\n  INTERPRET \"SORT\"SUBSTR(SORTCOL,1,4)\" = TMPSEQ\"              /* @CX */\nRETURN                                                        /* @CX */\n/*--------------------------------------------------------------------*/\n/*  Resume/reset userid                                               */\n/*--------------------------------------------------------------------*/\nRESD:\n  action = '*Reset'                                           /* @A4 */\n  msg    = 'You are about to resume/reset 'USER NAME\n  Sure_? = RACFMSGC(msg)\n  if (sure_? = 'YES') then do\n     if (SETTPSWD = \"\") then                                  /* @EQ */\n        userp = \"user.user.user\"                              /* @EQ */\n     else                                                     /* @EQ */\n        userp = left(SETTPSWD,14)                             /* @EQ */\n     if SETMPHRA = 'YES' then                                 /* @EQ */\n        call EXCMD \"ALTUSER \"user\" RESUME PHRASE('\"userp\"')\"  /* @EQ */\n     else                                                     /* @EQ */\n        call EXCMD \"ALTUSER \"user\" RESUME PASSWORD(\"user\")\"   /* @EQ */\n     if (cmd_rc = 0) then do                                  /* @CA */\n        revoked ='NO'                                         /* @BP */\n        \"TBMOD\" TABLEA\n     end\n     else\n        CALL racfmsgs \"ERR07\" msg.1 /* Alter failed */        /* @X1 */\n  end\nRETURN\n/*--------------------------------------------------------------------*/\n/*  Revoke userid                                                     */\n/*--------------------------------------------------------------------*/\nREVD:\n  action = \"*Revoke\"                                          /* @A4 */\n  msg    = 'You are about to revoke 'USER NAME\n  Sure_? = RACFMSGC(msg)\n  if (sure_? = 'YES') then do\n     call EXCMD \"ALTUSER \"user\" REVOKE\"\n     if (cmd_rc = 0) then do                                  /* @CA */\n        revoked ='YES'\n        \"TBMOD\" TABLEA\n     end\n     else\n        CALL racfmsgs \"ERR07\" msg.1 /* Alter failed */        /* @X1 */\n  end\nRETURN\n/*--------------------------------------------------------------------*/\n/*  List userid                                                       */\n/*--------------------------------------------------------------------*/\nLISD:\n  action  = '*Listed'                                         /* @A4 */\n  CMDPRM  = \"CICS CSDATA DCE DFP EIM KERB LANGUAGE\",          /* @A2 */\n            \"LNOTES MFA NDS NETVIEW OMVS OPERPARM\",           /* @A2 */\n            \"OVM PROXY TSO WORKATTR\"                          /* @A2 */\n  call get_setropts_options                                   /* @AJ */\n  if (rcvtsmfa = 'NO') then do                                /* @AJ */\n     mfa_pos = pos('MFA',CMDPRM)                              /* @AJ */\n     CMDPRM = delstr(CMDPRM,mfa_pos,4)                        /* @AJ */\n  end                                                         /* @AJ */\n  cmd = \"LU \"USER CMDPRM                                      /* @BB */\n  X = OUTTRAP(\"CMDREC.\")                                      /* @A2 */\n  ADDRESS TSO cmd                                             /* @BB */\n  cmd_rc = rc                                                 /* @BS */\n  if (SETMSHOW <> 'NO') then                                  /* @CU */\n     call SHOWCMD                                             /* @BS */\n  X = OUTTRAP(\"OFF\")                                          /* @A2 */\n  IF (cmd_rc > 0) then DO    /* Removed parms */              /* @C6 */\n     X = OUTTRAP(\"CMDREC.\")                                   /* @C6 */\n     cmd = \"LU \"USER                                          /* @C6 */\n     ADDRESS TSO cmd                                          /* @C6 */\n     cmd_rc = rc                                              /* @C6 */\n     X = OUTTRAP(\"OFF\")                                       /* @C6 */\n     if (SETMSHOW <> 'NO') then                               /* @CU */\n        call SHOWCMD                                          /* @C6 */\n  END                                                         /* @C6 */\n  if (user = 'irrcerta') then do                              /* @AP */\n     CMDREC. = ''                                             /* @AP */\n     CMDREC.0 = 3                                             /* @AP */\n     CMDREC.1 = irrcerta.1                                    /* @AP */\n     CMDREC.2 = irrcerta.3                                    /* @AP */\n     CMDREC.3 = irrcerta.6                                    /* @AP */\n  end                                                         /* @AP */\n  if (user = 'irrmulti') then do                              /* @AP */\n     CMDREC. = ''                                             /* @AP */\n     CMDREC.0 = 3                                             /* @AP */\n     CMDREC.1 = irrmulti.1                                    /* @AP */\n     CMDREC.2 = irrmulti.3                                    /* @AP */\n     CMDREC.3 = irrmulti.6                                    /* @AP */\n  end                                                         /* @AP */\n  if (user = 'irrsitec') then do                              /* @AP */\n     CMDREC. = ''                                             /* @AP */\n     CMDREC.0 = 3                                             /* @AP */\n     CMDREC.1 = irrsitec.1                                    /* @AP */\n     CMDREC.2 = irrsitec.3                                    /* @AP */\n     CMDREC.3 = irrsitec.6                                    /* @AP */\n  end                                                         /* @AP */\n  call display_info                                           /* @D2 */\n  if (cmd_rc = 0) then                                        /* @C8 */\n     \"TBMOD\" TABLEA\n  else\n     CALL racfmsgs \"ERR10\" msg.1 /* Generic failure */        /* @X1 */\nRETURN\n/*--------------------------------------------------------------------*/\n/*  Display information from line commands 'L' and 'P'           @D2  */\n/*--------------------------------------------------------------------*/\nDISPLAY_INFO:                                                 /* @D2 */\n  ADDRESS TSO \"ALLOC F(\"DDNAME\") NEW REUSE\",                  /* @A2 */\n              \"LRECL(80) BLKSIZE(0) RECFM(F B)\",              /* @D3 */\n              \"UNIT(VIO) SPACE(1 5) CYLINDERS\"                /* @A2 */\n  ADDRESS TSO \"EXECIO * DISKW \"DDNAME\" (STEM CMDREC. FINIS\"   /* @A2 */\n  DROP CMDREC.                                                /* @A2 */\n                                                              /* @A2 */\n  \"LMINIT DATAID(CMDDATID) DDNAME(\"DDNAME\")\"                  /* @A2 */\n  SELECT                                                      /* @B7 */\n     WHEN (SETGDISP = \"VIEW\") THEN                            /* @B7 */\n          \"VIEW DATAID(\"CMDDATID\") MACRO(\"EDITMACR\")\"         /* @CZ */\n     WHEN (SETGDISP = \"EDIT\") THEN                            /* @B7 */\n          \"EDIT DATAID(\"CMDDATID\") MACRO(\"EDITMACR\")\"         /* @CZ */\n     OTHERWISE                                                /* @B7 */\n          \"BROWSE DATAID(\"CMDDATID\")\"                         /* @B7 */\n  END                                                         /* @B7 */\n  ADDRESS TSO \"FREE FI(\"DDNAME\")\"                             /* @A2 */\nRETURN                                                        /* @D2 */\n/*--------------------------------------------------------------------*/\n/*  Get Multi Factor Authentication (MFA) option from RCVT            */\n/*--------------------------------------------------------------------*/\nGET_SETROPTS_OPTIONS:                                         /* @AJ */\n  cvt     = c2x(storage(10,4))      /* cvt address        */  /* @AJ */\n  cvtrac$ = d2x((x2d(cvt))+992)     /* cvt+3E0 = cvtrac $ */  /* @AJ */\n  cvtrac  = c2x(storage(cvtrac$,4)) /* cvtrac=access cntl */  /* @AJ */\n  rc      = setbool(rcvtsmfa,633,'02','NO','YES') /* mfa  */  /* @AJ */\nRETURN                                                        /* @AJ */\n/*--------------------------------------------------------------------*/\n/*  Set boolean value for mask                                        */\n/*--------------------------------------------------------------------*/\nSETBOOL:\n  variable = arg(1)                                           /* @AJ */\n  offset   = arg(2)                                           /* @AJ */\n  value    = arg(3)                                           /* @AJ */\n  status1  = arg(4)                                           /* @AJ */\n  status2  = arg(5)                                           /* @AJ */\n  interpret  \"rcvtsta$= d2x((x2d(\"cvtrac\"))+\"offset\")\"        /* @AJ */\n  x        = storage(rcvtsta$,1)                              /* @AJ */\n  interpret variable '= 'status1                              /* @AJ */\n  interpret \"x=bitand(x,'\"value\"'x)\" /*remove bad bits*/      /* @AJ */\n  interpret \"if (x= '\"value\"'x) then \"variable\"=\"status2      /* @AJ */\nRETURN 0                                                      /* @AJ */\n/*--------------------------------------------------------------------*/\n/*  List group                                                        */\n/*--------------------------------------------------------------------*/\nLISP:\n  action  = '*Prof'                                           /* @E7 */\n  CMDPRM  = \"CSDATA DFP OMVS OVM TME\"                         /* @AC */\n  cmd     = \"LG \"ID\" \"CMDPRM                                  /* @BB */\n  X = OUTTRAP(\"CMDREC.\")                                      /* @AC */\n  ADDRESS TSO cmd                                             /* @BB */\n  cmd_rc = rc                                                 /* @BS */\n  X = OUTTRAP(\"OFF\")                                          /* @AC */\n  if (SETMSHOW <> 'NO') then                                  /* @CU */\n     call SHOWCMD                                             /* @BB */\n  if (cmd_rc > 0) then do /* Remove Parms */                  /* @C9 */\n     cmd     = \"LG \"ID                                        /* @C9 */\n     X = OUTTRAP(\"CMDREC.\")                                   /* @C9 */\n     ADDRESS TSO cmd                                          /* @C9 */\n     cmd_rc = rc                                              /* @C9 */\n     X = OUTTRAP(\"OFF\")                                       /* @C9 */\n     if (SETMSHOW <> 'NO') then                               /* @CU */\n        call SHOWCMD                                          /* @C9 */\n  END                                                         /* @C9 */\n  call display_info                                           /* @D2 */\n  if (cmd_rc = 0) then                                        /* @C8 */\n     \"TBMOD\" TABLEB                                           /* @AC */\n  else                                                        /* @AC */\n     CALL racfmsgs \"ERR10\" msg.1 /* Generic failure */        /* @X1 */\nRETURN                                                        /* @AC */\n/*--------------------------------------------------------------------*/\n/*  Obtain userid attributes                                     @CI  */\n/*--------------------------------------------------------------------*/\nUPDATTR:                                                      /* @CJ */\n  cmd    = \"LU \"USER\" TSO\"                                    /* @CI */\n  x      = OUTTRAP('details.')                                /* @CI */\n  address TSO cmd                                             /* @CI */\n  cmd_rc = rc                                                 /* @CI */\n  x      = OUTTRAP('OFF')                                     /* @CI */\n  if (SETMSHOW <> 'NO') then                                  /* @CU */\n     call SHOWCMD                                             /* @CI */\n  parse var details.3 'ATTRIBUTES='attribute1                 /* @CI */\n  parse var details.4 'ATTRIBUTES='attribute2                 /* @CI */\n  attr = STRIP(attribute1) STRIP(attribute2)                  /* @CI */\n  none  = POS('NONE',attr)                                    /* @CI */\n  if (none <> 0) then                                         /* @CI */\n     attr = delstr(attr,none,4)      /* Delete 'NONE'    */   /* @CI */\n  none  = POS('REVOKED',attr)                                 /* @DX */\n  if (none <> 0) then                                         /* @DX */\n     attr = delstr(attr,revoked,7)   /* Delete 'REVOKED' */   /* @DX */\n  attr2 = 'NO'                                                /* @CI */\n  if (none = 0) then do                                       /* @CI */\n     attr2 = 'YES'                                            /* @CI */\n  end                                                         /* @CI */\nRETURN                                                        /* @CI */\n/*--------------------------------------------------------------------*/\n/*  Delete profile                                                    */\n/*--------------------------------------------------------------------*/\nDELD:\n  ACTION = \"*Delete\"                                          /* @A4 */\n  if (USER = 'NONE') then\n     return\n  if (user = userid()) then do                                /* @EG */\n     racflmsg = 'You can NOT delete your userid',             /* @EG */\n                '('user').  This is for your own',            /* @EG */\n                'safety!'                                     /* @EG */\n     'setmsg msg(RACF011)'                                    /* @EG */\n     return\n  end\n  msg    = 'You are about to delete 'USER\n  Sure_? = RACFMSGC(msg)\n  if (sure_? = 'YES') then do\n     if (tsouser = 'YES') then do\n        msg    = user'.'SETTPROF                              /* @CF */\n        if SETTUDSN <> '' then                                /* @CF */\n        msg    = msg || ' and 'user'.'SETTUDSN                /* @CF */\n        msg    = msg || ' will be deleted'                    /* @CF */\n        Sure_? = RACFMSGC(msg)\n        if (sure_? = 'YES') then\n           ret_code = RACFUSRT('DELD' user tsoproc,           /* @C4 */\n                      tsoacct defgrp owner tsolib)            /* @C4 */\n        if (ret_code <= 8) then do\n           call EXCMD \"DELUSER (\"USER\")\"\n           if (cmd_rc = 0) then                               /* @CA */\n              \"TBDELETE\" TABLEA\n           else CALL racfmsgs \"ERR02\" msg.1 /* RDELETE failed */\n        end\n        else CALL racfmsgs \"ERR02\"  msg.1 /* RDELETE failed */\n     end\n     else do\n        call EXCMD \"DELUSER (\"USER\")\"\n        if (cmd_rc = 0) then                                  /* @CA */\n           \"TBDELETE\" TABLEA\n        else CALL racfmsgs \"ERR02\" msg.1  /* RDELETE failed */\n     end\n  end  /* Confirm-delete */\nRETURN\n/*--------------------------------------------------------------------*/\n/*  Display profile permits                                           */\n/*--------------------------------------------------------------------*/\nDISD:\n  action = '*Shown'                                           /* @A4 */\n  \"TBMOD\" TABLEA\n  if (USER = 'NONE') then\n     return\n  tmpsort   = sort                                            /* @CY */\n  tmprsels  = rsels                                           /* @EI */\n  tmpxtdtop = xtdtop                                          /* @EJ */\n  Do until (RB='NO')   /* allow rebuild option to loop */\n     call CREATE_TABLEB                                       /* @CY */\n     rb     = 'NO'\n     xtdtop = 0                                               /* @EE */\n     rsels  = 0                                               /* @EE */\n     do forever                                               /* @EE */\n        if (rsels < 2) then do                                /* @EE */\n           optb = ' '                                         /* @EE */\n           \"TBTOP \" TABLEB                                    /* @EE */\n           'tbskip' tableb 'number('xtdtop')'                 /* @EE */\n           radmrfnd = 'PASSTHRU'                              /* @EE */\n           'vput (radmrfnd)'                                  /* @EE */\n           \"TBDISPL\" TABLEB \"PANEL(\"PANEL03\")\"                /* @EE */\n        end                                                   /* @EE */\n        else 'tbdispl' tableb                                 /* @EE */\n        if (rc > 4) then leave                                /* @EE */\n        xtdtop   = ztdtop                                     /* @EE */\n        rsels    = ztdsels                                    /* @EE */\n        radmrfnd = null                                       /* @EE */\n        'vput (radmrfnd)'                                     /* @EE */\n        PARSE VAR ZCMD ZCMD PARM SEQ                          /* @EE */\n        IF (SROW <> \"\") & (SROW <> 0) THEN                    /* @BG */\n           IF (SROW > 0) THEN DO                              /* @BG */\n              \"TBTOP \" TABLEB                                 /* @BG */\n              \"TBSKIP\" TABLEB \"NUMBER(\"SROW\")\"                /* @BG */\n           END                                                /* @BG */\n        if (zcmd = 'RFIND') then do                           /* @ED */\n           zcmd = 'FIND'                                      /* @ED */\n           parm = findit                                      /* @ED */\n           'tbtop ' TABLEB                                    /* @ED */\n           'tbskip' TABLEB 'number('last_find')'              /* @ED */\n        end                                                   /* @ED */\n        Select                                                /* @CY */\n           When (abbrev(\"FIND\",zcmd,1) = 1) then              /* @ED */\n                call do_findb                                 /* @ED */\n           WHEN (ABBREV(\"LOCATE\",ZCMD,1) = 1) THEN DO\n                if (parm <> '') then do                       /* @EE */\n                   locarg = parm'*'                           /* @EE */\n                   PARSE VAR SORT . \",\" . \",\" SEQ             /* @EE */\n                   IF (SEQ = \"D\") THEN                        /* @EE */\n                      CONDLIST = \"LE\"                         /* @EE */\n                   ELSE                                       /* @EE */\n                      CONDLIST = \"GE\"                         /* @EE */\n                   parse value sort with scan_field',' .      /* @EE */\n                   interpret scan_field ' = locarg'           /* @EE */\n                   'tbtop ' tableb                            /* @EE */\n                   \"TBSCAN \"TABLEB\" ARGLIST(\"scan_field\")\",   /* @EE */\n                           \"CONDLIST(\"CONDLIST\")\",            /* @EE */\n                           \"position(scanrow)\"                /* @EE */\n                   xtdtop = scanrow                           /* @EE */\n                end                                           /* @EE */\n           end\n           WHEN (ABBREV(\"ONLY\",ZCMD,1) = 1) THEN DO           /* @CY */\n                find_str = translate(parm)                    /* @CY */\n                'tbtop ' TABLEB                               /* @CY */\n                'tbskip' TABLEB                               /* @CY */\n                do forever                                    /* @CY */\n                   str = translate(id acc)                    /* @CY */\n                   if (pos(find_str,str) > 0) then nop        /* @CY */\n                   else 'tbdelete' TABLEB                     /* @CY */\n                   'tbskip' TABLEB                            /* @CY */\n                   if (rc > 0) then do                        /* @CY */\n                      'tbtop' TABLEB                          /* @CY */\n                      leave                                   /* @CY */\n                   end                                        /* @CY */\n                end                                           /* @CY */\n           END                                                /* @CY */\n           WHEN (ABBREV(\"RESET\",ZCMD,1) = 1) THEN DO          /* @CY */\n                xtdtop = 1                                    /* @CY */\n                \"TBEND\" TABLEB                                /* @CY */\n                call CREATE_TABLEB                            /* @CY */\n           END                                                /* @CY */\n           When (abbrev(\"SAVE\",zcmd,2) = 1) then DO           /* @EK */\n                TMPSKELT = SKELETON2                          /* @EK */\n                call do_SAVE                                  /* @EK */\n           END                                                /* @EK */\n           WHEN (ABBREV(\"SORT\",ZCMD,1) = 1) THEN DO           /* @CY */\n                SELECT                                        /* @CY */\n                   when (ABBREV(\"GROUP\",PARM,1) = 1) then     /* @CY */\n                        call sortseq 'ID'                     /* @CY */\n                   when (ABBREV(\"ACCESS\",PARM,1) = 1) then    /* @CY */\n                        call sortseq 'ACC'                    /* @CY */\n                   otherwise NOP                              /* @CY */\n                END                                           /* @CY */\n                PARSE VAR SORT LOCARG \",\" .                   /* @EE */\n                CLRID   = \"GREEN\"; CLRACC  = \"GREEN\"          /* @EE */\n                INTERPRET \"CLR\"SUBSTR(LOCARG,1,4)\" = 'TURQ'\"  /* @EE */\n                \"TBSORT\" TABLEB \"FIELDS(\"sort\")\"              /* @EE */\n                \"TBTOP \" TABLEB                               /* @EE */\n           END                                                /* @CY */\n           otherwise NOP                                      /* @CY */\n        End /* Select */                                      /* @CY */\n        ZCMD = \"\"; PARM = \"\"                                  /* @EE */\n        'control display save'                                /* @EE */\n        Select\n           when (optb = 'A') then call Addp\n           when (optb = 'C') then call Chgp\n           when (optb = 'L') then call Lisp                   /* @CN */\n           when (optb = 'P') then do                          /* @CO */\n                call RACFPROF 'GROUP' id                      /* @CO */\n                action = '*Prof'                              /* @CW */\n                \"TBMOD\" TABLEB                                /* @CW */\n           end                                                /* @CW */\n           when (optb = 'R') then call Delp\n           when (optb = 'S') then call RACFGRP id\n           otherwise nop\n        End\n        'control display restore'                             /* @EE */\n     end  /* Do forever) */                                   /* @EE */\n     \"TBEND\" TABLEB\n  end  /* Do until */\n  sort   = tmpsort                                            /* @CY */\n  rsels  = tmprsels                                           /* @EI */\n  xtdtop = tmpxtdtop                                          /* @EJ */\nRETURN\n/*--------------------------------------------------------------------*/\n/*  Process primary command FIND for TABLEB                      @ED  */\n/*--------------------------------------------------------------------*/\nDO_FINDB:                                                     /* @ED */\n  if (parm = null) then do                                    /* @ED */\n     racfsmsg = 'Error'                                       /* @ED */\n     racflmsg = 'Find requires a value to search for.' ,      /* @ED */\n                'Try again.'                                  /* @ED */\n     'setmsg msg(RACF011)'                                    /* @ED */\n     return                                                   /* @ED */\n  end                                                         /* @ED */\n  findit    = translate(parm)                                 /* @ED */\n  last_find = 0                                               /* @ED */\n  wrap      = 0                                               /* @ED */\n  do forever                                                  /* @ED */\n     'tbskip' TABLEB                                          /* @ED */\n     if (rc > 0) then do                                      /* @ED */\n        if (wrap = 1) then do                                 /* @ED */\n           racfsmsg = 'Not Found'                             /* @ED */\n           racflmsg = findit 'not found.'                     /* @ED */\n           'setmsg msg(RACF011)'                              /* @ED */\n           return                                             /* @ED */\n        end                                                   /* @ED */\n        if (wrap = 0) then wrap = 1                           /* @ED */\n        'tbtop' tableb                                        /* @ED */\n     end                                                      /* @ED */\n     else do                                                  /* @ED */\n        testit = translate(id acc)                            /* @ED */\n        if (pos(findit,testit) > 0) then do                   /* @ED */\n           'tbquery' TABLEB 'position(srow)'                  /* @ED */\n           'tbtop'   TABLEB                                   /* @ED */\n           'tbskip'  TABLEB 'number('srow')'                  /* @ED */\n           last_find = srow                                   /* @ED */\n           xtdtop    = srow                                   /* @ED */\n           if (wrap = 0) then                                 /* @ED */\n              racfsmsg = 'Found'                              /* @ED */\n           else                                               /* @ED */\n              racfsmsg = 'Found/Wrapped'                      /* @ED */\n           racflmsg = findit 'found in row' srow + 0          /* @ED */\n           'setmsg msg(RACF011)'                              /* @ED */\n           return                                             /* @ED */\n        end                                                   /* @ED */\n     end                                                      /* @ED */\n  end                                                         /* @ED */\nRETURN                                                        /* @ED */\n/*--------------------------------------------------------------------*/\n/*  Create table 'B'                                             @CY  */\n/*--------------------------------------------------------------------*/\nCREATE_TABLEB:                                                /* @CY */\n  \"TBCREATE\" TABLEB \"KEYS(ID) NAMES(ACC)\",\n                  \"REPLACE NOWRITE\"\n  flags = 'OFF'\n  uacc  = ' '\n  cmd   = \"LU \"USER                                           /* @BB */\n  x = OUTTRAP('VAR.')\n  address TSO cmd                                             /* @BB */\n  cmd_rc = rc                                                 /* @BS */\n  x = OUTTRAP('OFF')\n  if (SETMSHOW <> 'NO') then                                  /* @CU */\n     call SHOWCMD                                             /* @BB */\n  Do i = 1 to var.0  /* Scan output */\n     temp = var.i\n     if (substr(temp,3,5) = 'GROUP') then do\n        id  = substr(temp,9,8)\n        acc = substr(temp,24,8)\n        \"TBMOD\" TABLEB\n     end\n  end\n  sort   = 'ID,C,A'                                           /* @EE */\n  sortid = 'D'; sortacc = 'A'                                 /* @EE */\n  CLRID  = \"TURQ\"; CLRACC  = \"GREEN\"                          /* @EE */\n  \"TBSORT \" TABLEB \"FIELDS(\"sort\")\"                           /* @EE */\n  \"TBTOP  \" TABLEB                                            /* @EE */\nRETURN                                                        /* @CY */\n/*--------------------------------------------------------------------*/\n/*  Get user info to initialize add or change option                  */\n/*--------------------------------------------------------------------*/\nGETD:\n  owner    = ' '\n  name     = ' '\n  defgrp   = ' '\n  data     = ' '\n  datecre  = ' '\n  datelgn  = ' '\n  datepass = ' '\n  intpass  = ' '\n  revoked  = 'NO'                                             /* @BP */\n  tsouser  = ''\n  attr     = ''\n  attrspec = 'N'      /* Special:    Y=Yes, N=No */           /* @CH */\n  attroper = 'N'      /* Operations: Y=Yes, N=No */           /* @CH */\n  attraudi = 'N'      /* Auditor:    Y=Yes, N=No */           /* @CH */\n  cmd      = \"LU \"USER\" TSO\"                                  /* @BB */\n\n  x        = OUTTRAP('details.')\n  address TSO cmd                                             /* @BB */\n  cmd_rc = rc                                                 /* @BS */\n  x        = OUTTRAP('OFF')\n  if (SETMSHOW <> 'NO') then                                  /* @CU */\n     call SHOWCMD                                             /* @BB */\n  getd_max = details.0\n\n  if (user = 'irrcerta') then do                              /* @AP */\n     details.1 = irrcerta.1                                   /* @AP */\n     details.3 = irrcerta.3                                   /* @AP */\n     details.6 = irrcerta.6                                   /* @AP */\n  end                                                         /* @AP */\n  if (user = 'irrmulti') then do                              /* @AP */\n     details.1 = irrmulti.1                                   /* @AP */\n     details.3 = irrmulti.3                                   /* @AP */\n     details.6 = irrmulti.6                                   /* @AP */\n  end                                                         /* @AP */\n  if (user = 'irrsitec') then do                              /* @AP */\n      details.1 = irrsitec.1                                  /* @AP */\n      details.3 = irrsitec.3                                  /* @AP */\n      details.6 = irrsitec.6                                  /* @AP */\n  end                                                         /* @AP */\n\n  parse var details.1 ,\n  'USER=' x 'NAME=' name 'OWNER=' owner 'CREATED=' datecre\n  if datecre <> '' then do                                    /* @DN */\n     datecre = SUBSTR(datecre,1,2)SUBSTR(datecre,4,3)         /* @DN */\n     datecre = DATE('U',datecre,'J')                          /* @DO */\n  end                                                         /* @DN */\n\n  parse var details.2 ,\n        'DEFAULT-GROUP=' defgrp 'PASSDATE=',\n        datepass 'PASS-INTERVAL=' Intpass\n\n  parse var details.3 'ATTRIBUTES='attribute1                 /* @AB */\n  parse var details.4 'ATTRIBUTES='attribute2                 /* @AB */\n  attr = STRIP(attribute1) STRIP(attribute2)                  /* @AB */\n  if (POS('SPECIAL',attr) > 0)    then ATTRSPEC = \"Y\"         /* @CH */\n  if (POS('OPERATIONS',attr) > 0) then ATTROPER = \"Y\"         /* @CH */\n  if (POS('AUDITOR',attr) > 0)    then ATTRAUDI = \"Y\"         /* @CH */\n\n  rev  = POS('REVOKED',attr)\n  if (rev <> 0) then do                                       /* @BX */\n     revoked = 'YES'                                          /* @BX */\n     attr = delstr(attr,rev,7)   /* Del 'REVOKED' */          /* @BX */\n  end                                                         /* @BX */\n  none  = POS('NONE',attr)                                    /* @A9 */\n  if (none <> 0) then                                         /* @BX */\n     attr = delstr(attr,none,4)  /* Del 'NONE'    */          /* @BX */\n  attr2 = 'NO'                                                /* @BO */\n  if (none = 0) then do                                       /* @A9 */\n     attr2 = 'YES'                                            /* @AB */\n  end                                                         /* @A9 */\n  prot  = POS('PROTECTED',attr)                               /* @BX */\n  if (prot <> 0) then attr = delstr(attr,prot,9)              /* @BX */\n\n  parse var details.5 'LAST-ACCESS=' datelgn5                 /* @AI */\n  parse var details.6 'LAST-ACCESS=' datelgn6                 /* @AI */\n  Select                                                      /* @AI */\n     When (datelgn5 <> \"\") Then                               /* @AI */\n          datelgn = datelgn5                                  /* @AI */\n     otherwise                                                /* @AI */\n          datelgn = datelgn6                                  /* @AI */\n  end                                                         /* @AI */\n  if (datelgn = 'UNKNOW') then                                /* @AN */\n     datelgn = 'UNKNOWN'                                      /* @AN */\n  if (datelgn = \" \") | (datelgn = 'UNKNOWN') then             /* @AO */\n     nop                                                      /* @AO */\n  else do                                                     /* @AR */\n     datelgn = SUBSTR(datelgn,1,2)SUBSTR(datelgn,4,3)         /* @AN */\n     datelgn = DATE('O',datelgn,'J')                          /* @AN */\n  end                                                         /* @AN */\n\n  parse var details.7 'INSTALLATION-DATA=' data\n  TSOUSER = \"NO\"                                              /* @BQ */\n  do getd_count=8 to getd_max\n     if (details.getd_count = 'NO TSO INFORMATION') then leave\n     if (details.getd_count = 'TSO INFORMATION') then do\n        tsouser    ='YES'\n        getd_count = getd_count + 1                           /* @CQ */\n        do k = getd_count to getd_max                         /* @CQ */\n           parse var details.k W1 W2                          /* @CQ */\n           W2 = STRIP(W2)                                     /* @CQ */\n           Select                                             /* @CQ */\n              When (W1 = 'ACCTNUM=') then tsoacct = W2        /* @CQ */\n              When (W1 = 'PROC=')    then tsoproc = W2        /* @CQ */\n              When (W1 = 'SIZE=')    then tsosize = W2        /* @CQ */\n              When (W1 = 'UNIT=')    then tsounit = W2        /* @CQ */\n              otherwise nop                                   /* @CQ */\n           end                                                /* @CQ */\n        end                                                   /* @CQ */\n        if (tsosize <> ' ') then tsosize = format(tsosize)\n        leave\n     end  /* Tso-info */\n  end  /* Do count */\nRETURN\n/*--------------------------------------------------------------------*/\n/*  Change permit option                                              */\n/*--------------------------------------------------------------------*/\nCHGP:\n  If (id = 'NONE') then\n     return\n  \"DISPLAY PANEL(\"PANEL07\")\"                                  /* @BL */\n  if (rc > 0) then\n     return\n  call EXCMD \"PE \"USER\" CLASS(\"RCLASS\") ID(\"ID\")\",\n             \"ACC(\"ACC\")\" TYPE\n  if (cmd_rc = 0) then                                        /* @CA */\n     \"TBMOD\" TABLEB\n  else\n     Call racfmsgs 'ERR03' msg.1 /* permit failed */          /* @X1 */\nRETURN\n/*--------------------------------------------------------------------*/\n/*  Add permit option                                                 */\n/*--------------------------------------------------------------------*/\nADDP:\n  new = 'NO'\n  if (id = 'NONE') then\n     new = 'YES'\n  from = ' '\n  \"DISPLAY PANEL(\"PANEL04\")\"                                  /* @BL */\n  if (rc > 0) then\n     return\n  idopt = ' '\n  if (id <> ' ') then\n     idopt = 'ID('ID') ACCESS('ACC')'\n  fopt = ' '\n  if (from <> ' ') then do\n     fopt = \"FROM('\"FROM\"') FCLASS(\"RCLASS\") FGENERIC\"\n     rb   = 'YES'             /* Cause table rebuild */\n  end\n  call EXCMD \"CONNECT (\"user\") GROUP(\"id\") AUTH(\"acc\")\"\n  if (cmd_rc = 0) then do                                     /* @CA */\n     \"TBMOD\" TABLEB\n     if (new = 'YES') then do\n        id = 'NONE'\n        \"TBDELETE\" TABLEB\n     end\n  end\n  else do\n     if (from <> ' ') then\n        call racfmsgs 'ERR04' msg.1 /* Permit Warning/Failed */\n     else\n        call racfmsgs 'ERR05' msg.1 /* Permit Failed */       /* @X1 */\n  end\nRETURN\n/*--------------------------------------------------------------------*/\n/*  Delete permit option                                              */\n/*--------------------------------------------------------------------*/\nDELP:\n  if (id = 'NONE') then\n     return\n  msg    = 'You are about to delete access for 'ID\n  Sure_? = RACFMSGC(msg)\n  if (sure_? = 'YES') then do\n     call EXCMD \"REMOVE (\"user\") GROUP(\"id\")\"\n     if (cmd_rc = 0) then                                     /* @CA */\n        \"TBDELETE\" TABLEB\n     else\n        call racfmsgs 'ERR06'  msg.1   /* Permit Failed */    /* @X1 */\n  end\nRETURN\n/*--------------------------------------------------------------------*/\n/*  Exec command                                                      */\n/*--------------------------------------------------------------------*/\nEXCMD:\n  signal off error\n  parse arg cmd    /* preserve lower case for OMVS seg */     /* @D4 */\n  x = OUTTRAP('msg.')\n  address TSO cmd                                             /* @BR */\n  cmd_rc = rc                                                 /* @BS */\n  x = OUTTRAP('OFF')\n  if (SETMSHOW <> 'NO') then                                  /* @CU */\n     call SHOWCMD                                             /* @BB */\n  if (subword(msg.1,1,1)= 'ICH11009I') |,\n     (subword(msg.1,1,1)= 'ICH10006I') |,\n     (subword(msg.1,1,1)= 'ICH06011I') then raclist = 'YES'\nRETURN\n/*--------------------------------------------------------------------*/\n/*  Simulate digital certificate user profiles                        */\n/*--------------------------------------------------------------------*/\nDIGITAL_CERTS:                                                /* @AP */\n  irrcerta.  = ''\n  irrmulti.  = ''\n  irrsitec.  = ''\n\n  irrcerta.1 = 'USER=irrcerta  NAME=CERTAUTH Anchor',         /* @AP */\n               'OWNER=irrcerta  CREATED=99.195'               /* @AP */\n  irrcerta.3 = ' ATTRIBUTES=REVOKED'                          /* @AP */\n  irrcerta.6 = ' LAST-ACCESS=UNKNOWN'                         /* @AP */\n\n  irrmulti.1 = 'USER=irrmulti  NAME=Criteria Anchor',         /* @AP */\n               'OWNER=irrmulti  CREATED=99.195'               /* @AP */\n  irrmulti.3 = ' ATTRIBUTES=REVOKED'                          /* @AP */\n  irrmulti.6 = ' LAST-ACCESS=UNKNOWN'                         /* @AP */\n\n  irrsitec.1 = 'USER=irrsitec  NAME=SITE Anchor',             /* @AP */\n               'OWNER=irrsitec  CREATED=99.195'               /* @AP */\n  irrsitec.3 = ' ATTRIBUTES=REVOKED'                          /* @AP */\n  irrsitec.6 = ' LAST-ACCESS=UNKNOWN'                         /* @AP */\nRETURN                                                        /* @AP */\n/*--------------------------------------------------------------------*/\n/*  Display RACF command and return code                         @BB  */\n/*--------------------------------------------------------------------*/\nSHOWCMD:                                                      /* @BB */\n  IF (SETMSHOW = \"BOTH\") | (SETMSHOW = \"DISPLAY\") THEN DO     /* @CV */\n     PARSE VAR CMD MSG1   60 MSG2 121 MSG3 181 MSG3A,         /* @D8 */\n               241 MSG3B 301 MSG3C                            /* @D8 */\n     MSG4 = \"Return code = \"cmd_rc                            /* @D8 */\n     \"ADDPOP ROW(6) COLUMN(4)\"                                /* @BB */\n     if (MSG3A = \"\") THEN                                     /* @DA */\n        \"DISPLAY PANEL(\"PANELM2\")\"                            /* @D4 */\n     else                                                     /* @DA */\n        \"DISPLAY PANEL(\"PANELM3\")\"                            /* @D4 */\n     \"REMPOP\"                                                 /* @BB */\n  END                                                         /* @CU */\n  IF (SETMSHOW = \"BOTH\") | (SETMSHOW = \"LOG\") THEN DO         /* @CV */\n     zerrsm = \"RACFADM \"REXXPGM\" RC=\"cmd_rc                   /* @DU */\n     zerrlm = cmd                                             /* @CU */\n     'log msg(isrz003)'                                       /* @CU */\n  END                                                         /* @CU */\nRETURN                                                        /* @BB */\n/*--------------------------------------------------------------------*/\n/*  Create table 'A'                                             @BE  */\n/*--------------------------------------------------------------------*/\nCREATE_TABLEA:                                                /* @BE */\n  action    = ''\n  seconds   = TIME('S')\n  \"TBCREATE\" TABLEA ,\n       \"KEYS(USER) NAMES(ACTION NAME OWNER DEFGRP DATELGN DATECRE\",\n                        \"REVOKED ATTR TSOUSER DATA ATTR2)\",\n                        \"REPLACE NOWRITE\"\n  cmd = \"SEARCH FILTER(\"RFILTER\") CLASS(\"rclass\")\"            /* @BB */\n  x = OUTTRAP('var.')\n  address TSO cmd                                             /* @BB */\n  cmd_rc = rc                                                 /* @BS */\n  x = OUTTRAP('OFF')\n  if (SETMSHOW <> 'NO') then                                  /* @CU */\n     call SHOWCMD                                             /* @BB */\n  if (SETGSTAP <> \"\") THEN                                    /* @DY */\n     INTERPRET \"RECNUM = var.0*.\"SETGSTAP\"%1\"                 /* @DY */\n  Do i = 1 to var.0\n     temp = var.i\n     USER = SUBWORD(temp,1,1)\n     t    = INDEX(temp,g)\n     if (t > 0) then nop\n     else do\n        msgr = SUBWORD(temp,1,1)\n        Select\n           when (msgr = 'ICH31005I') then do\n                USER = 'NONE'        /* No USERs */\n           end\n           when (msgr = 'ICH31009I') then do\n                USER = 'INVALID'     /* Bad filter */\n                call racfmsgs 'ERR08' msg.1                   /* @X1 */\n           end\n           when (msgr = 'ICH31012I') then do\n                USER = 'INVALID'     /* Bad filter */\n                call racfmsgs 'ERR08' msg.1                   /* @X1 */\n           end\n           when (msgr = 'ICH31014I') then do\n                USER = 'INVALID'     /* Bad filter */\n                call racfmsgs 'ERR08' msg.1                   /* @X1 */\n           end\n           when (msgr = 'ICH31016I') then do\n                USER = 'INVALID'     /* Bad filter */\n                call racfmsgs 'ERR08' msg.1                   /* @X1 */\n           end\n           when (msgr = 'ICH31017I') then do\n                USER = 'INVALID'     /* Bad filter */\n                call racfmsgs 'ERR08' msg.1                   /* @X1 */\n           end\n           when (msgr = 'ICH31018I') then do\n                USER = 'INVALID'     /* Bad filter */\n                call racfmsgs 'ERR08' msg.1                   /* @X1 */\n           end\n           when (msgr = 'IKJ56716I') then do\n                USER = 'INVALID'     /* Bad filter */\n                call racfmsgs 'ERR08' msg.1                   /* @X1 */\n           end\n           when (substr(msgr,1,6) = 'ICH310') then do\n                call racfmsgs 'ERR09' msg.1                   /* @X1 */\n           end\n           otherwise nop\n        End  /* Select */\n     end  /* Else */\n     /*---------------------------------------------*/\n     /* Display number of users retrieved          -*/\n     /*---------------------------------------------*/\n     IF (SETGSTA = \"\") THEN DO                                /* @DY */\n        IF (RECNUM <> 0) THEN                                 /* @DY */\n           IF (I//RECNUM = 0) THEN DO                         /* @DY */\n              n1 = i; n2 = var.0                              /* @DY */\n              pct = ((n1/n2)*100)%1'%'                        /* @DY */\n              \"control display lock\"                          /* @DY */\n              \"display msg(RACF012)\"                          /* @E3 */\n           END                                                /* @DY */\n     END                                                      /* @DY */\n     ELSE DO\n        IF (SETGSTA <> 0) THEN                                /* @DY */\n           IF (I//SETGSTA = 0) THEN DO                        /* @AZ */\n              n1 = i; n2 = var.0\n              pct = ((n1/n2)*100)%1'%'                        /* @DY */\n              \"control display lock\"\n              \"display msg(RACF012)\"                          /* @E3 */\n           END                                                /* @AZ */\n     END\n     /*---------------------------------------------*/\n     /* Get further info                           -*/\n     /*---------------------------------------------*/\n     call GETD\n     \"TBMOD\" TABLEA\n  end  /* Do i=1 to var.0 */\n\n  sort     = 'USER,C,A'                                       /* @EE */\n  sortuser = 'D'; sortname = 'A'         /* Sort order */     /* @EE */\n  sortdefg = 'A'; sortdate = 'D'                              /* @EE */\n  sortowne = 'A'; sortrevo = 'D'                              /* @EE */\n  sortattr = 'D'; sorttsou = 'D'                              /* @EE */\n  CLRUSER  = \"TURQ\" ; CLRNAME = \"GREEN\"  /* Col colors */     /* @EE */\n  CLRDEFG  = \"GREEN\"; CLRDATE = \"GREEN\"                       /* @EE */\n  CLROWNE  = \"GREEN\"; CLRREVO = \"GREEN\"                       /* @EE */\n  CLRATTR  = \"GREEN\"; CLRTSOU = \"GREEN\"                       /* @EE */\n  \"TBSORT \" TABLEA \"FIELDS(\"sort\")\"                           /* @EE */\n  \"TBTOP  \" TABLEA                                            /* @EE */\nRETURN                                                        /* @BE */\n/*--------------------------------------------------------------------*/\n/*  Add new profile                                              @DT  */\n/*--------------------------------------------------------------------*/\n@ADDD:                                                        /* @D4 */\n  action = '*Add'                                             /* @E7 */\n  if (SETTPSWD = \"\") then                                     /* @E9 */\n     pswd = newpswd()                                         /* @E1 */\n  else                                                        /* @E8 */\n     pswd = SETTPSWD                                          /* @E9 */\n  \"DISPLAY PANEL(\"PANEL06\")\"                                  /* @DS */\n  if (rc = 8) then                                            /* @D4 */\n     return                                                   /* @D4 */\n  if (pswd = '') then                                         /* @DE */\n     pswd = user                                              /* @DE */\n  if SETMPHRA = 'YES' then                                    /* @EQ */\n     add1 = \"ADDUSER \"user\" OWNER(\"bowner\") PHRASE('\"pswd\"')\" /* @EQ */\n  else                                                        /* @EQ */\n     add1 = \"ADDUSER \"user\" OWNER(\"bowner\") PASSWORD(\"pswd\")\" /* @EQ */\n                                                              /* @EQ */\n  add2 = ' DFLTGRP('defgrp') NAME('''name''') ' attr          /* @EQ */\n  cmd = add1 add2                                             /* @EQ */\n  if (ohome||oprogram = '') then                              /* @D4 */\n     nop                                                      /* @D4 */\n  else do                                                     /* @D4 */\n     parse value '' with o1 o2                                /* @D4 */\n     cmd = cmd||,                                             /* @D4 */\n           ' OMVS('                                           /* @D4 */\n           if ohome    <> '' then                             /* @ER */\n              o1 = \"HOME('\"ohome\"')\"                          /* @ER */\n           if oprogram <> '' then                             /* @ER */\n              o2 = \"PROGRAM('\"oprogram\"')\"                    /* @ER */\n           cmd = cmd||o1 o2 'AUTOUID'||,                      /* @D4 */\n           ')'                                                /* @D4 */\n  end                                                         /* @D4 */\n  if (tsoproc||tsoacct||tsosize||tsounit = '') then           /* @D4 */\n     nop                                                      /* @D4 */\n  else do                                                     /* @D4 */\n     parse value '' with t1 t2 t3 t4                          /* @D4 */\n     cmd = cmd||,                                             /* @D4 */\n           ' TSO('                                            /* @D4 */\n           if tsoproc <> '' then t1 = 'PROC('tsoproc')'       /* @D4 */\n           if tsoacct <> '' then t2 = 'ACCTNUM('tsoacct')'    /* @D4 */\n           if tsosize <> '' then t3 = 'SIZE('tsosize')'       /* @D4 */\n           if tsounit <> '' then t4 = 'UNIT('tsounit')'       /* @D4 */\n           cmd = cmd||t1 t2 t3 t4||,                          /* @D4 */\n           ')'                                                /* @D4 */\n    end                                                       /* @D4 */\n  if (copclass||copident||copprty||ctimeout = '') then        /* @D4 */\n     nop                                                      /* @D4 */\n  else do                                                     /* @D4 */\n     parse value '' with c1 c2 c3 c4                          /* @D4 */\n     cmd = cmd||,                                             /* @D4 */\n           ' CICS('                                           /* @D4 */\n           if copclass <> '' then c1 = 'OPCLASS('copclass')'  /* @D4 */\n           if copident <> '' then c2 = 'OPIDENT('copident')'  /* @D4 */\n           if copprty  <> '' then c3 = 'OPPRTY('copprty')'    /* @D4 */\n           if ctimeout <> '' then c4 = 'TIMEOUT('ctimeout')'  /* @D4 */\n           cmd = cmd||c1 c2 c3 c4||,                          /* @D4 */\n           ')'                                                /* @D4 */\n  end                                                         /* @D4 */\n  if (ddatacls||dmgmtcls||dstorcls = '') then                 /* @D4 */\n     nop                                                      /* @D4 */\n  else do                                                     /* @D4 */\n     parse value '' with d1 d2 d3                             /* @D4 */\n     cmd = cmd||,                                             /* @D4 */\n           ' DFP('                                            /* @D4 */\n           if ddatacls <> '' then d1 = 'DATACLAS('ddatacls')' /* @D4 */\n           if dmgmtcls <> '' then d2 = 'MGMTCLAS('dmgmtcls')' /* @D4 */\n           if dstorcls <> '' then d3 = 'STORCLAS('dstorcls')' /* @D4 */\n           cmd = cmd||d1 d2 d3||,                             /* @D4 */\n           ')'                                                /* @D4 */\n  end                                                         /* @D4 */\n  if (idata = '') then                                        /* @EO */\n     nop                                                      /* @EO */\n  else                                                        /* @EO */\n     cmd = cmd||' DATA('''idata''') '                         /* @EO */\n  call excmd cmd                                              /* @D4 */\n  if (cmd_rc > 0) then do                                     /* @DL */\n     call racfmsgs ERR01 msg.1 /* Add failed */               /* @X1 */\n     return                                                   /* @D6 */\n  end                                                         /* @DL */\n  cmd_rc = RACFUSRT('ADDD' user tsoproc,                      /* @DL */\n           tsoacct defgrp bowner)                             /* @D4 */\n  if (cmd_rc > 0) then do                                     /* @DL */\n     call racfmsgs ERR01 msg.1   /* Add failed */             /* @X1 */\n     return                                                   /* @D6 */\n  end                                                         /* @DL */\n  call @chkattr                                               /* @D4 */\n  \"TBMOD\" TABLEA \"ORDER\"                                      /* @EF */\n  call disd /* Connect basic group */                         /* @D4 */\nRETURN                                                        /* @D4 */\n/*--------------------------------------------------------------------*/\n/*  Generate password                                            @E1  */\n/*--------------------------------------------------------------------*/\nNEWPSWD:                                                      /* @E1 */\n  /* No vowels, or \"V\" or \"Z\" */                              /* @E1 */\n  choices  = 'BCDFGHJKLMNPQRSTWXYbcdfghjklmnpqrstwxy'         /* @E5 */\n  chars.   = ''                                               /* @E1 */\n  password = ''                                               /* @E1 */\n  /* Initialize stem variables */                             /* @E1 */\n  do n = 1 to length(choices)                                 /* @E1 */\n     chars.n = substr(choices,n,1)                            /* @E1 */\n  end                                                         /* @E1 */\n  /* n character password */                                  /* @EQ */\n  psize = 6                                                   /* @EQ */\n  do forever                                                  /* @E1 */\n     pick = random(1,length(choices))                         /* @E1 */\n     /* No repeating characters */                            /* @E1 */\n     if (pos(chars.pick,password) > 0) then                   /* @E1 */\n        nop                                                   /* @E1 */\n     else                                                     /* @E1 */\n        password = password||chars.pick                       /* @E1 */\n     if (length(password) > (psize-1)) then                   /* @EQ */\n        leave                                                 /* @E1 */\n  end                                                         /* @E1 */\n  /* Plug in 1 numeric character */                           /* @E1 */\n  number   = random(1,9)                                      /* @E1 */\n  place    = random(2,psize)                                  /* @EQ */\n  password = overlay(number,password,place,1)                 /* @E1 */\nRETURN password                                               /* @E1 */\n/*--------------------------------------------------------------------*/\n/*  Change profile                                               @DT  */\n/*--------------------------------------------------------------------*/\n@CHGD:                                                        /* @D4 */\n  action = \"*Change\"                                          /* @E7 */\n  \"DISPLAY PANEL(\"PANEL06\")\"                                  /* @D4 */\n  if (rc = 8) then                                            /* @D4 */\n     return                                                   /* @D4 */\n  call outtrap 'x.'                                           /* @X1 */\n  address tso 'lu' user 'omvs'                                /* @X1 */\n  call outtrap 'off'                                          /* @X1 */\n  autouid = 'AUTOUID'                                         /* @X1 */\n  do xi = 1 to x.0                                            /* @X1 */\n     if left(x.xi,4) = 'UID=' then autouid = ''               /* @X1 */\n     end                                                      /* @X1 */\n  cmd = 'ALTUSER 'user' OWNER('bowner')'||,                   /* @D4 */\n        ' DFLTGRP('defgrp') NAME('''name''') ' attr           /* @D4 */\n  if (ohome||oprogram = '') then                              /* @D4 */\n     nop                                                      /* @D4 */\n  else do                                                     /* @D4 */\n     parse value '' with o1 o2                                /* @D4 */\n     cmd = cmd||,                                             /* @D4 */\n           ' OMVS('                                           /* @D4 */\n           if ohome    <> '' then o1 = 'HOME('ohome')'        /* @D4 */\n           if oprogram <> '' then o2 = 'PROGRAM('oprogram')'  /* @D4 */\n           cmd = cmd||o1 o2 autouid')'                        /* @X1 */\n  end                                                         /* @D4 */\n  if (tsoproc||tsoacct||tsosize||tsounit = '') then           /* @D4 */\n     nop                                                      /* @D4 */\n  else do                                                     /* @D4 */\n      parse value '' with t1 t2 t3 t4                         /* @D4 */\n      cmd = cmd||,                                            /* @D4 */\n          ' TSO('                                             /* @D4 */\n          if (tsoproc <> '') then t1 = 'PROC('tsoproc')'      /* @D4 */\n          if (tsoacct <> '') then t2 = 'ACCTNUM('tsoacct')'   /* @D4 */\n          if (tsosize <> '') then t3 = 'SIZE('tsosize')'      /* @D4 */\n          if (tsounit <> '') then t4 = 'UNIT('tsounit')'      /* @D4 */\n          cmd = cmd||t1 t2 t3 t4||,                           /* @D4 */\n          ')'                                                 /* @D4 */\n    end                                                       /* @D4 */\n  if (copclass||copident||copprty||ctimeout = '') then        /* @D4 */\n     nop                                                      /* @D4 */\n  else do                                                     /* @D4 */\n     parse value '' with c1 c2 c3 c4                          /* @D4 */\n     cmd = cmd||,                                             /* @D4 */\n         ' CICS('                                             /* @D4 */\n         if (copclass <> '') then c1 = 'OPCLASS('copclass')'  /* @D4 */\n         if (copident <> '') then c2 = 'OPIDENT('copident')'  /* @D4 */\n         if (copprty  <> '') then c3 = 'OPPRTY('copprty')'    /* @D4 */\n         if (ctimeout <> '') then c4 = 'TIMEOUT('ctimeout')'  /* @D4 */\n         cmd = cmd||c1 c2 c3 c4||,                            /* @D4 */\n         ')'                                                  /* @D4 */\n  end                                                         /* @D4 */\n  if (ddatacls||dmgmtcls||dstorcls = '') then                 /* @D4 */\n     nop                                                      /* @D4 */\n  else do                                                     /* @D4 */\n     parse value '' with d1 d2 d3                             /* @D4 */\n     cmd = cmd||,                                             /* @D4 */\n         ' DFP('                                              /* @D4 */\n         if (ddatacls <> '') then d1 = 'DATACLAS('ddatacls')' /* @D4 */\n         if (dmgmtcls <> '') then d2 = 'MGMTCLAS('dmgmtcls')' /* @D4 */\n         if (dstorcls <> '') then d3 = 'STORCLAS('dstorcls')' /* @D4 */\n         cmd = cmd||d1 d2 d3||,                               /* @D4 */\n         ')'                                                  /* @D4 */\n  end                                                         /* @D4 */\n  if idata = '' then                                          /* @EO */\n     nop                                                      /* @EO */\n  else                                                        /* @EO */\n     cmd = cmd||' DATA('''idata''') '                         /* @EO */\n  call excmd cmd                                              /* @D4 */\n  if (cmd_rc > 0) then do                                     /* @DL */\n     call racfmsgs ERR07 msg.1   /* Changed failed */         /* @X1 */\n     return                                                   /* @D6 */\n  end                                                         /* @DL */\n  call @chkattr                                               /* @D4 */\n  /*- Authorize logon and account to default group  -*/       /* @D4 */\n  if (tsouser = 'YES') then do                                /* @D4 */\n     cmd = \"PE \"tsoacct\" CLASS(ACCTNUM) ACC(READ)\",           /* @D4 */\n           \"ID(\"defgrp\")\"                                     /* @D4 */\n     call excmd cmd                                           /* @D4 */\n     if (cmd_rc > 0) then                                     /* @DL */\n        call racfmsgs ERR03  msg.1  /* Permit failed */       /* @X1 */\n     cmd = \"PE \"tsoproc\" CLASS(TSOPROC) ACC(READ)\",           /* @D4 */\n           \"ID(\"defgrp\")\"                                     /* @D4 */\n     call excmd cmd                                           /* @D4 */\n     if (cmd_rc > 0) then                                     /* @DL */\n        call racfmsgs ERR03   msg.1 /* Permit failed */       /* @X1 */\n  end                                                         /* @D4 */\n  \"TBMOD\" TABLEA                                              /* @D4 */\nRETURN                                                        /* @D4 */\n/*--------------------------------------------------------------------*/\n/*  Delete profile attributes, when 'Admin RACF API = Y'         @D4  */\n/*--------------------------------------------------------------------*/\nALTD:                                                         /* @E6 */\n  action = \"*Alter\"                                           /* @E6 */\n  \"DISPLAY PANEL(\"PANEL05\")\"                                  /* @DS */\n  if (rc = 8) then                                            /* @D4 */\n     return                                                   /* @D4 */\n  cmd = 'ALTUSER 'user nos                                    /* @D4 */\n  call excmd cmd                                              /* @D4 */\n  call @chkattr                                               /* @D4 */\n  \"TBMOD\" TABLEA                                              /* @D4 */\nRETURN                                                        /* @D4 */\n/*--------------------------------------------------------------------*/\n/*  Chk TSO segment/REVOKED/ATTRIB, when 'Admin RACF API = Y'    @D4  */\n/*--------------------------------------------------------------------*/\n@CHKATTR:                                                     /* @D4 */\n  if (SETMIRRX = 'NO') then do                                /* @DP */\n    call GETD                                                 /* @DP */\n    RETURN                                                    /* @DP */\n    end                                                       /* @DP */\n  cmd = \"IRRXUTIL('EXTRACT','USER','\"user\"','RACF',)\"         /* @DC */\n  interpret 'cmd_rc = 'cmd                                    /* @D5 */\n  cmd_rc = WORD(cmd_rc,1)                                     /* @DW */\n  if (SETMSHOW <> 'NO') then                                  /* @D5 */\n     call SHOWCMD                                             /* @D5 */\n  if (WORD(cmd_rc,1) <> 0) then do                            /* @D5 */\n     call racfmsgs ERR20 msg.1                                /* @X1 */\n     return                                                   /* @D4 */\n  end                                                         /* @D5 */\n  tsouser = 'NO'                                              /* @D4 */\n  do seg=1 to racf.0                                          /* @D4 */\n     if (racf.seg = 'TSO') then                               /* @D4 */\n        tsouser = 'YES'                                       /* @D4 */\n  end                                                         /* @D4 */\n  if (racf.base.revokefl.1 = 'TRUE') then                     /* @D4 */\n     revoked = 'YES'                                          /* @D4 */\n  else                                                        /* @D4 */\n     revoked = 'NO'                                           /* @D4 */\n  if (racf.base.special.1 = 'TRUE') |,                        /* @D4 */\n     (racf.base.oper.1    = 'TRUE') |,                        /* @D4 */\n     (racf.base.grpacc.1  = 'TRUE') |,                        /* @D4 */\n     (racf.base.auditor.1 = 'TRUE') |,                        /* @D4 */\n     (racf.base.roaudit.1 = 'TRUE') |,                        /* @D4 */\n     (racf.base.rest.1    = 'TRUE') |,                        /* @D4 */\n     (racf.base.adsp.1    = 'TRUE') then                      /* @D4 */\n     attr2 = 'YES'                                            /* @D4 */\n  else                                                        /* @D4 */\n     attr2 = 'NO'                                             /* @D4 */\nRETURN                                                        /* @D4 */\n/*--------------------------------------------------------------------*/\n/*  Save table to dataset                                        @EK  */\n/*--------------------------------------------------------------------*/\nDO_SAVE:                                                      /* @EK */\n  X = MSG(\"OFF\")                                              /* @EK */\n  \"ADDPOP COLUMN(40)\"                                         /* @EK */\n  \"VGET (RACFSDSN RACFSMBR RACFSFIL RACFSREP) PROFILE\"        /* @EL */\n  IF (RACFSDSN = \"\") THEN         /* SAve - Dataset Name  */  /* @EM */\n     RACFSDSN = USERID()\".RACFADM.REPORTS\"                    /* @EK */\n  IF (RACFSFIL = \"\") THEN         /* SAve - As (TXT/CVS)  */  /* @EM */\n     RACFSFIL = \"T\"                                           /* @EL */\n  IF (RACFSREP = \"\") THEN         /* SAve - Replace (Y/N) */  /* @EM */\n     RACFSREP = \"N\"                                           /* @EK */\n                                                              /* @EK */\n  DO FOREVER                                                  /* @EK */\n     \"DISPLAY PANEL(\"PANELS1\")\"                               /* @EK */\n     IF (RC = 08) THEN DO                                     /* @EK */\n        \"REMPOP\"                                              /* @EK */\n        RETURN                                                /* @EK */\n     END                                                      /* @EK */\n     RACFSDSN = STRIP(RACFSDSN,,\"'\")                          /* @EK */\n     RACFSDSN = STRIP(RACFSDSN,,'\"')                          /* @EK */\n     RACFSDSN = STRIP(RACFSDSN)                               /* @EK */\n     SYSDSORG = \"\"                                            /* @EK */\n     X = LISTDSI(\"'\"RACFSDSN\"'\")                              /* @EK */\n     IF (SYSDSORG = \"\") | (SYSDSORG = \"PS\"),                  /* @EK */\n      | (SYSDSORG = \"PO\") THEN                                /* @EK */\n        NOP                                                   /* @EK */\n     ELSE DO                                                  /* @EK */\n        RACFSMSG = \"Not PDS/Seq File\"                         /* @EK */\n        RACFLMSG = \"The dataset specified is not\",            /* @EK */\n                  \"a partitioned or sequential\",              /* @EK */\n                  \"dataset, please enter a valid\",            /* @EK */\n                  \"dataset name.\"                             /* @EK */\n       \"SETMSG MSG(RACF011)\"                                  /* @EK */\n       ITERATE                                                /* @EK */\n     END                                                      /* @EK */\n     IF (SYSDSORG = \"PS\") & (RACFSMBR <> \"\") THEN DO          /* @EK */\n        RACFSMSG = \"Seq File - No mbr\"                        /* @EK */\n        RACFLMSG = \"This dataset is a sequential\",            /* @EK */\n                  \"file, please remove the\",                  /* @EK */\n                  \"member name.\"                              /* @EK */\n       \"SETMSG MSG(RACF011)\"                                  /* @EK */\n       ITERATE                                                /* @EK */\n     END                                                      /* @EK */\n     IF (SYSDSORG = \"PO\") & (RACFSMBR = \"\") THEN DO           /* @EK */\n        RACFSMSG = \"PDS File - Need Mbr\"                      /* @EK */\n        RACFLMSG = \"This dataset is a partitioned\",           /* @EK */\n                  \"dataset, please include a member\",         /* @EK */\n                  \"name.\"                                     /* @EK */\n       \"SETMSG MSG(RACF011)\"                                  /* @EK */\n       ITERATE                                                /* @EK */\n     END                                                      /* @EK */\n                                                              /* @EK */\n     IF (RACFSMBR = \"\") THEN                                  /* @EK */\n        TMPDSN = RACFSDSN                                     /* @EK */\n     ELSE                                                     /* @EK */\n        TMPDSN = RACFSDSN\"(\"RACFSMBR\")\"                       /* @EK */\n     DSNCHK = SYSDSN(\"'\"TMPDSN\"'\")                            /* @EK */\n     IF (DSNCHK = \"OK\" & RACFSREP = \"N\") THEN DO              /* @EK */\n        RACFSMSG = \"DSN/MBR Exists\"                           /* @EK */\n        RACFLMSG = \"Dataset/member already exists. \",         /* @EK */\n                  \"Please type in \"Y\" to replace file.\"       /* @EK */\n        \"SETMSG MSG(RACF011)\"                                 /* @EK */\n        ITERATE                                               /* @EK */\n     END                                                      /* @EK */\n     LEAVE                                                    /* @EK */\n  END                                                         /* @EK */\n  \"REMPOP\"                                                    /* @EK */\n  \"VPUT (RACFSDSN RACFSMBR RACFSFIL RACFSREP) PROFILE\"        /* @EL */\n                                                              /* @EK */\nADDRESS TSO                                                   /* @EK */\n  IF (RACFSREP = \"Y\" & RACFSMBR = \"\") |,                      /* @EK */\n     (DSNCHK <> \"OK\" & DSNCHK <> \"MEMBER NOT FOUND\"),         /* @EK */\n     THEN DO                                                  /* @EK */\n     \"DELETE '\"RACFSDSN\"'\"                                    /* @EK */\n     IF (RACFSMBR = \"\") THEN                                  /* @EK */\n        \"ALLOC  FI(ISPFILE) DA('\"RACFSDSN\"') NEW\",            /* @EK */\n            \"REUSE SP(1 1) CYLINDER UNIT(SYSALLDA)\",          /* @EN */\n            \"LRECL(80) RECFM(F B)\"                            /* @EK */\n     ELSE                                                     /* @EK */\n        \"ALLOC  FI(ISPFILE) DA('\"RACFSDSN\"') NEW\",            /* @EK */\n            \"REUSE SP(1 1) CYLINDER UNIT(SYSALLDA)\",          /* @EN */\n            \"LRECL(80) RECFM(F B)\",                           /* @EK */\n            \"DSORG(PO) DSNTYPE(LIBRARY,2)\"                    /* @EK */\n  END                                                         /* @EK */\n  ELSE                                                        /* @EK */\n     \"ALLOC  FI(ISPFILE) DA('\"RACFSDSN\"') SHR REUSE\"          /* @EK */\n                                                              /* @EK */\nADDRESS ISPEXEC                                               /* @EK */\n  \"FTOPEN\"                                                    /* @EK */\n  \"FTINCL \"TMPSKELT                                           /* @EK */\n  IF (RACFSMBR = \"\") THEN                                     /* @EK */\n     \"FTCLOSE\"                                                /* @EK */\n  ELSE                                                        /* @EK */\n     \"FTCLOSE NAME(\"RACFSMBR\")\"                               /* @EK */\n  ADDRESS TSO \"FREE FI(ISPFILE)\"                              /* @EK */\n                                                              /* @EK */\n  SELECT                                                      /* @EK */\n     WHEN (SETGDISP = \"VIEW\") THEN                            /* @EK */\n          \"VIEW DATASET('\"RACFSDSN\"') MACRO(\"EDITMACR\")\"      /* @EK */\n     WHEN (SETGDISP = \"EDIT\") THEN                            /* @EK */\n          \"EDIT DATASET('\"RACFSDSN\"') MACRO(\"EDITMACR\")\"      /* @EK */\n     OTHERWISE                                                /* @EK */\n          \"BROWSE DATASET('\"RACFSDSN\"')\"                      /* @EK */\n  END                                                         /* @EK */\n  X = MSG(\"ON\")                                               /* @EK */\n                                                              /* @EK */\nRETURN                                                        /* @EK */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RACFUSRT": {"ttr": 941, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x14c\\x00D\\x01 \\x00?\\x01 \\x18\\x0f\\x05B\\x00\\xfb\\x00\\x84\\x00\\x00\\xd9\\xc1\\xc3\\xc6\\xc1\\xc4\\xd4@@@'", "ispf": {"version": "20.99", "flags": 0, "createdate": "2020-01-03T00:00:00", "modifydate": "2020-06-28T05:42:44", "lines": 251, "newlines": 132, "modlines": 0, "user": "RACFADM"}, "text": "/*%NOCOMMENT====================* REXX *==============================*/\n/*  PURPOSE:  RACFADM - User Profile - Opt 1, create TSO alias/dsns   */\n/*--------------------------------------------------------------------*/\n/* FLG  YYMMDD  USERID   DESCRIPTION                                  */\n/* ---  ------  -------  -------------------------------------------- */\n/* @B4  200502  RACFA    Added return                                 */\n/* @B3  200429  RACFA    Re-arranged variables (General, Mgmt, TSO)   */\n/* @B2  200423  RACFA    Move PARSE REXXPGM name up above IF SETMTRAC */\n/* @B1  200422  RACFA    Ensure the REXX program name is 8 chars      */\n/* @AZ  200422  RACFA    Use variable REXXPGM in log msg              */\n/* @AY  200422  TRIDJK   Fixed allocating JOBLIB                      */\n/* @AX  200413  RACFA    Fixed returning the return codes             */\n/* @AW  200413  RACFA    Get REXX pgm name and use as DD name         */\n/* @AV  200413  RACFA    Chg TRACEing to only display banner (P=Pgms) */\n/* @AU  200412  RACFA    Fixed returning RC                           */\n/* @AT  200412  RACFA    Chg TRACE to allow 'L'abels or 'R'esults     */\n/* @AS  200324  RACFA    Allow both display/logging of RACF commands  */\n/* @AR  200324  RACFA    Allow logging RACF commands to ISPF Log file */\n/* @AQ  200320  RACFA    Del all users dsns, prior was ISPPROF/JOBLIB */\n/* @AP  200317  RACFA    Chg JOBLIB=Y, was JOBLIB=YES                 */\n/* @AO  200317  RACFA    Add error msg when unable to define alias    */\n/* @AN  200316  RACFA    Removed ERAMCAT, ERAUVOL, ERAUNIT, not used  */\n/* @AM  200305  RACFA    Del comments and ERROR subroutine            */\n/* @AL  200305  RACFA    Del OUTTRAP('TRASH.') and DISPLAY_MSG proc.  */\n/* @AK  200305  TRIDJK   Add quotes to userid on DELETE/DEFINE ALIAS  */\n/* @AJ  200305  TRIDJK   NOP the ERROR: CHGD: DISPLAY_MSG: sections   */\n/* @AI  200305  TRIDJK   Comment out \"x = OUTTRAP('trash.')\"          */\n/* @AH  200228  RACFA    Removed ARG() statements, use PARSE ARG      */\n/* @AG  200228  RACFA    Allow turning disp. REXX cmds 'Settings (0)' */\n/* @AF  200228  RACFA    Allow turning tracing on from 'Settings (0)' */\n/* @AE  200227  RACFA    If EGN=YES, then 2 asterisks, else one       */\n/* @AD  200227  RACFA    Set info messages off, del outtrap('trash.') */\n/* @AC  200227  TRIDJK   Add single quotes around catalog name        */\n/* @AB  200226  RACFA    Removed \"PROFILE PREF(\"USERID()\")\"           */\n/* @AB  200226  RACFA    Removed 'ADDRESS TSO PROF NOPREFIX'          */\n/* @AA  200225  LBD      Fixed PREFIX, wrong environment              */\n/* @A9  200224  RACFA    Place panels at top of REXX in variables     */\n/* @A8  200223  RACFA    Del 'address TSO \"PROFILE MSGID\"', not needed*/\n/* @A7  200221  RACFA    Make 'ADDRESS ISPEXEC' defualt, reduce code  */\n/* @A6  200220  RACFA    Added SETMTRAC=YES, then TRACE R             */\n/* @A5  200220  RACFA    Renamed RACFTSO to RACFUSRT (Standardization)*/\n/* @A4  200218  RACFA    Condense VGETs into one line                 */\n/* @A3  200119  RACFA    Standardized/reduced lines of code           */\n/* @A2  200119  RACFA    Added comment box above procedures           */\n/* @A1  200118  RACFA    Fixed NOPREF issue with users TSO PROFILE    */\n/* @A0  011229  NICORIZ  Created REXX, V2.1, www.rizzuto.it           */\n/*====================================================================*/\nX           = MSG(\"OFF\")   /* No informational messages    */ /* @AD */\nPANEL29     = \"RACFUSRT\"   /* Add, chg and del TSO userid  */ /* @A9 */\nPANELM2     = \"RACFMSG2\"   /* Display RACF command and RC  */ /* @AW */\nDDNAME      = 'RACFA'RANDOM(0,999) /* Unique ddname        */ /* @AW */\nparse source . . REXXPGM .         /* Obtain REXX pgm name */ /* @B2 */\nREXXPGM     = LEFT(REXXPGM,8)                                 /* @B2 */\n\nADDRESS ISPEXEC                                               /* @AF */\n  \"VGET (SETMSHOW SETMTRAC SETTCTLG\",                         /* @B3 */\n        \"SETTPROF SETTUDSN) PROFILE\"                          /* @B3 */\n  If (SETMTRAC <> 'NO') then do                               /* @AT */\n     Say \"*\"COPIES(\"-\",70)\"*\"                                 /* @AT */\n     Say \"*\"Center(\"Begin Program = \"REXXPGM,70)\"*\"           /* @AT */\n     Say \"*\"COPIES(\"-\",70)\"*\"                                 /* @AT */\n     if (SETMTRAC <> 'PROGRAMS') THEN                         /* @AV */\n        interpret \"Trace \"SUBSTR(SETMTRAC,1,1)                /* @AT */\n  end                                                         /* @AT */\n\n  rc      = GETEGN(ERAEGN,53,'01','NO','YES')  /* egn=Y/N */  /* @AE */\n  ASTERIC = \"*\"                                               /* @AE */\n  IF (ERAEGN = \"YES\") THEN                                    /* @AE */\n     ASTERIC = \"**\"                                           /* @AE */\n\n  parse arg era_cmd user tsoproc tsoacct defgrp owner joblib  /* @AH */\n  interpret 'signal ' era_cmd\n/*--------------------------------------------------------------------*/\n/*  Change userid                                                     */\n/*--------------------------------------------------------------------*/\nCHGD:\n  cmd_rc = 0\n  call goodbye                                                /* @AT */\nRETURN cmd_rc                                                 /* @AW */\n/*--------------------------------------------------------------------*/\n/*  Add userid                                                        */\n/*--------------------------------------------------------------------*/\nADDD:                                                         /* @AJ */\n  cmd = \"ADDSD  ('\"user\".\"ASTERIC\"') UACC(READ)\",             /* @AG */\n        \"OWNER(\"owner\")\"                                      /* @AG */\n  call exccmd                                                 /* @AG */\n  IF (cmd_rc > 0) then                                        /* @AM */\n     call Goodbye                                             /* @AT */\n\n  /*- Authorize Library allocation                -*/\n  cmd = \"PERMIT '\"user\".\"ASTERIC\"' GEN ACC(ALTER)\",           /* @AG */\n                 \"ID(\"USERID()\")\"                             /* @AG */\n  call exccmd                                                 /* @AG */\n  IF (cmd_rc > 0) then                                        /* @AM */\n     call Goodbye                                             /* @AT */\n\n  cmd = \"SETROPTS REFRESH GENERIC(DATASET)\"                   /* @AG */\n  call exccmd                                                 /* @AG */\n  IF (cmd_rc > 0) then                                        /* @AM */\n     call Goodbye                                             /* @AT */\n\n  /*- Delete user alias for datasets -*/\n  cmd = \"DEL '\"user\"' ALIAS PURGE\"                            /* @AG */\n  call exccmd                                                 /* @AG */\n\n  SETTCTLG = Strip(SETTCTLG,,\"'\")                             /* @AC */\n  cmd = \"DEF ALIAS (NAME('\"user\"') RELATE('\"SETTCTLG\"'))\"     /* @AK */\n  call exccmd                                                 /* @AG */\n  IF (cmd_rc > 0) then do                                     /* @AO */\n     call racfmsgs ERR018  /* Invalid user catalog */         /* @AO */\n     call Goodbye                                             /* @AT */\n  end                                                         /* @AO */\n\n  /*- Allocate ISPF profile          -*/\n  cmd = \"ALLOC FILE(\"DDNAME\") DATASET('\"user\".\"SETTPROF\"')\",  /* @AW */\n              \"NEW SPACE(5,5) CYLINDERS\",                     /* @AG */\n              \"BLKSIZE(0) LRECL(80) RECFM(F B)\",              /* @AG */\n              \"CATALOG DIR(250)\"                              /* @AG */\n  call exccmd                                                 /* @AG */\n  cmd = \"FREE FILE(\"DDNAME\")\"                                 /* @AW */\n  call exccmd                                                 /* @AG */\n\n  /*- Allocate joblib library        -*/\n  if (SETTUDSN <> '') then do                                 /* @AY */\n     cmd = \"ALLOC FILE(\"DDNAME\")\",                            /* @AW */\n                  \"DATASET('\"user\".\"SETTUDSN\"')\",             /* @AG */\n                  \"NEW SPACE(5,5) CYLINDERS\",                 /* @AG */\n                  \"BLKSIZE(0) LRECL(80) RECFM(F B)\",          /* @AG */\n                  \"CATALOG DIR(250)\"                          /* @AG */\n     call exccmd                                              /* @AG */\n     cmd = \"FREE FILE(\"DDNAME\")\"                              /* @AW */\n     call exccmd                                              /* @AG */\n  end\n\n  /*- Authorize logon and account to default group  -*/\n  cmd = \"PE \"tsoacct\" CLASS(ACCTNUM) ACC(READ) ID(\"defgrp\")\"  /* @AG */\n  call exccmd                                                 /* @AG */\n  IF (cmd_rc > 0) then                                        /* @AM */\n     call Goodbye                                             /* @AT */\n  cmd = \"PE \"tsoproc\" CLASS(TSOPROC) ACC(READ) ID(\"defgrp\")\"  /* @AG */\n  call exccmd                                                 /* @AG */\n  IF (cmd_rc > 0) then                                        /* @AM */\n     call Goodbye                                             /* @AT */\n\n  cmd = \"SETROPTS RACLIST(ACCTNUM) REFRESH\"                   /* @AG */\n  call exccmd                                                 /* @AG */\n  IF (cmd_rc > 0) then                                        /* @AM */\n     call Goodbye                                             /* @AT */\n  cmd = \"SETROPTS RACLIST(TSOPROC) REFRESH\"                   /* @AG */\n  call exccmd                                                 /* @AG */\n  IF (cmd_rc > 0) then                                        /* @AM */\n     call Goodbye                                             /* @AT */\n\n  call Delete_Admin_permits\nRETURN cmd_rc                                                 /* @AW */\n/*--------------------------------------------------------------------*/\n/*  Delete userid                                                     */\n/*--------------------------------------------------------------------*/\nDELD:\n  cmd = \"DELDSD  ('\"user\".\"ASTERIC\"')\"                        /* @AG */\n  call exccmd                                                 /* @AG */\n  IF (cmd_rc > 0) then                                        /* @AM */\n     call Goodbye                                             /* @AT */\n\n  X = OUTTRAP(\"REC.\")                                         /* @AQ */\n  ADDRESS TSO \"LISTCAT LEV('\"user\"')\"                         /* @AQ */\n  X = OUTTRAP(\"OFF\")                                          /* @AQ */\n  DO J = 1 TO REC.0                                           /* @AQ */\n     PARSE VAR REC.J W1 W2 W3 .                               /* @AQ */\n     IF (W2 = \"-------\") THEN DO                              /* @AQ */\n        CMD = \"DELETE '\"W3\"'\"                                 /* @AQ */\n        call exccmd                                           /* @AQ */\n     END                                                      /* @AQ */\n  END                                                         /* @AQ */\n  DROP REC.\n\n  cmd = \"DELETE ('\"user\"') ALIAS\"                             /* @AK */\n  call exccmd                                                 /* @AG */\n  call Goodbye                                                /* @AT */\nRETURN cmd_rc                                                 /* @B4 */\n/*--------------------------------------------------------------------*/\n/*  Delete temporary authorizations for RACF administrator            */\n/*--------------------------------------------------------------------*/\nDELETE_ADMIN_PERMITS:\n  cmd = \"PERMIT '\"user\".\"ASTERIC\"' GEN DELETE\",               /* @AG */\n                 \"ID(\"USERID()\")\"                             /* @AG */\n  call exccmd                                                 /* @AG */\n  IF (cmd_rc > 0) then                                        /* @AM */\n     call Goodbye                                             /* @AT */\n\n  cmd = \"SETROPTS REFRESH GENERIC(DATASET)\"                   /* @AG */\n  call exccmd                                                 /* @AG */\n  call Goodbye                                                /* @AT */\nRETURN cmd_rc                                                 /* @AW */\n/*--------------------------------------------------------------------*/\n/*  Enhanced Generic Name (EGN) = Yes or No                           */\n/*--------------------------------------------------------------------*/\nGETEGN:\n  variable = arg(1)\n  offset   = arg(2)\n  value    = arg(3)\n  status1  = arg(4)\n  status2  = arg(5)\n  cvt      = c2x(storage(10,4))      /* cvt address        */\n  cvtrac$  = d2x((x2d(cvt))+992)     /* cvt+3E0 = cvtrac $ */\n  cvtrac   = c2x(storage(cvtrac$,4)) /* cvtrac=access cntl */\n  rcvtsta$ = d2x((x2d(cvtrac))+53)\n  interpret \"rcvtsta$= d2x((x2d(\"cvtrac\"))+\"offset\")\"\n  x        = storage(rcvtsta$,1)\n  interpret variable '= 'status1\n  interpret \"x=bitand(x,'\"value\"'x)\" /* del unwanted bits*/\n  interpret \"if (x= '\"value\"'x) then \"variable\"=\"status2\nRETURN 0000\n/*--------------------------------------------------------------------*/\n/*  Execute RACF command                                         @BB  */\n/*--------------------------------------------------------------------*/\nEXCCMD:                                                       /* @AG */\nADDRESS TSO                                                   /* @AG */\n  cmd                                                         /* @AG */\n  cmd_rc = rc                                                 /* @AG */\n  if (SETMSHOW <> 'NO') then                                  /* @AG */\n     call SHOWCMD                                             /* @AG */\nRETURN                                                        /* @AG */\n/*--------------------------------------------------------------------*/\n/*  Display RACF command and return code                         @BB  */\n/*--------------------------------------------------------------------*/\nSHOWCMD:                                                      /* @BB */\nADDRESS ISPEXEC                                               /* @AG */\n  IF (SETMSHOW = \"BOTH\") | (SETMSHOW = \"DISPLAY\") THEN DO     /* @AS */\n     PARSE VAR CMD MSG1 60 MSG2 121 MSG3                      /* @BB */\n     MSG4 = \"Return code = \"cmd_rc                            /* @BS */\n     \"ADDPOP ROW(6) COLUMN(4)\"                                /* @BB */\n     \"DISPLAY PANEL(\"PANELM2\")\"                               /* @BL */\n     \"REMPOP\"                                                 /* @BB */\n  END                                                         /* @AR */\n  IF (SETMSHOW = \"BOTH\") | (SETMSHOW = \"LOG\") THEN DO         /* @AS */\n     zerrsm = \"RACFADM \"REXXPGM\" RC=\"cmd_rc                   /* @AZ */\n     zerrlm = cmd                                             /* @AR */\n     'log msg(isrz003)'                                       /* @AR */\n  END                                                         /* @AR */\nRETURN                                                        /* @BB */\n/*--------------------------------------------------------------------*/\n/*  If tracing is on, display flower box                         @AT  */\n/*--------------------------------------------------------------------*/\nGOODBYE:                                                      /* @AT */\n  If (SETMTRAC <> 'NO') then do                               /* @AT */\n     Say \"*\"COPIES(\"-\",70)\"*\"                                 /* @AT */\n     Say \"*\"Center(\"End Program = \"REXXPGM,70)\"*\"             /* @AT */\n     Say \"*\"COPIES(\"-\",70)\"*\"                                 /* @AT */\n  end                                                         /* @AT */\nRETURN CMD_RC                                                 /* @AU */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "RACFUSRX": {"ttr": 961, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01K\\x00@\\x01 \\x02?\\x01 3\\x7f\\x08@\\x00\\xa9\\x00%\\x00\\x00\\xd9\\xc1\\xc3\\xc6\\xc1\\xc4\\xd4@@@'", "ispf": {"version": "01.75", "flags": 0, "createdate": "2020-01-23T00:00:00", "modifydate": "2020-12-02T08:40:40", "lines": 169, "newlines": 37, "modlines": 0, "user": "RACFADM"}, "text": "/*%NOCOMMENT====================* REXX *==============================*/\n/*  PURPOSE:  RACFADM - User Profile - Opt 1, Cross Ref. Rpt (cmd XR) */\n/*--------------------------------------------------------------------*/\n/*  NOTES:    1) This user line command XR, Cross Reference Report,   */\n/*               is not displayed as a line command                   */\n/*                                                                    */\n/*            2) Reason for this is sites with a large RACF database, */\n/*               the time for IRRUT100 to read/obtain the data is     */\n/*               significant                                          */\n/*                                                                    */\n/*            3) To access/use this command, turn on the Settings     */\n/*               (Option 0):                                          */\n/*                 Administrator ..... Y                              */\n/*--------------------------------------------------------------------*/\n/* FLG  YYMMDD  USERID   DESCRIPTION                                  */\n/* ---  ------  -------  -------------------------------------------- */\n/* @AC  201201  TRIDJK   Allow user to change/define JOB card         */\n/* @AB  201130  TRIDJK   Added code to submit batch job               */\n/* @AA  200429  RACFA    Re-arranged variables (General, Mgmt, TSO)   */\n/* @A9  200423  RACFA    Move PARSE REXXPGM name up above IF SETMTRAC */\n/* @A8  200423  RACFA    Ensure REXX program name is 8 chars long     */\n/* @A7  200422  TRIDJK   Added capability to browse/edit/view file    */\n/* @A6  200417  RACFA    Removed 'enq(exclu)', not needed             */\n/* @A5  200413  RACFA    Chg TRACEing to only display banner (P=Pgms) */\n/* @A4  200412  RACFA    Chg TRACE to allow 'L'abels or 'R'esults     */\n/* @A3  200301  RACFA    Standardize messaging                        */\n/* @A2  200221  RACFA    Make 'ADDRESS ISPEXEC' defualt, reduce code  */\n/* @A1  200220  RACFA    Added SETMTRAC=YES, then TRACE R             */\n/* @A0  200123  TRIDJK   Created REXX program                         */\n/*====================================================================*/\nPANEL99     = \"RACFRPTJ\"   /* Define JOB card/JCL parms    */ /* @AC */\nSKELETON1   = \"RACFXREF\"   /* Cross reference JCL          */ /* @AC */\nEDITMACR    = \"RACFEMAC\"   /* Edit Macro, turn HILITE off  */ /* @A7 */\nparse source . . REXXPGM .         /* Obtain REXX pgm name */ /* @A9 */\nREXXPGM     = LEFT(REXXPGM,8)                                 /* @A9 */\n\nADDRESS ISPEXEC                                               /* @A2 */\n  \"VGET (SETGDISP SETMTRAC) PROFILE\"                          /* @AA */\n  If (SETMTRAC <> 'NO') then do                               /* @A4 */\n     Say \"*\"COPIES(\"-\",70)\"*\"                                 /* @A4 */\n     Say \"*\"Center(\"Begin Program = \"REXXPGM,70)\"*\"           /* @A4 */\n     Say \"*\"COPIES(\"-\",70)\"*\"                                 /* @A4 */\n     if (SETMTRAC <> 'PROGRAMS') THEN                         /* @A5 */\n        interpret \"Trace \"SUBSTR(SETMTRAC,1,1)                /* @A4 */\n  end                                                         /* @A4 */\n  /*--------------------------------------------*/\n  /*  Call IRRUT100 for cross reference report  */\n  /*--------------------------------------------*/\nParse Arg user parm                                           /* @AB */\n\nif parm = 'JCC' then do                                       /* @AB */\n  call create_jcl                                             /* @AB */\n  call goodbye                                                /* @AB */\nend                                                           /* @AB */\n\nAddress TSO\n  x = outtrap('delete.','*')\n  'delete irrut100.'result\n  x = outtrap('off')\n  'alloc f(sysprint) new reuse unit(sysallda)',\n         'space(1,1) tracks'\n  'alloc f(sysut1)   new reuse unit(sysallda)',\n         'space(1,1) tracks'\n  'alloc f(sysin)    new reuse unit(sysallda)',\n         'lrecl(80) blksize(0) recfm(f b)',\n         'space(1,1) tracks'\n  'newstack'\n  queue user\n  queue\n  'Execio * diskw sysin (finis'\n  \"call *(irrut100)\"\n  'Execio * diskr sysprint (finis stem sysp.'\n\n  /*---------------------*/\n  /*  Browse the report  */\n  /*---------------------*/\nAddress ISPExec\n  'lminit dataid(id) ddname(sysprint)'                        /* @A6 */\n  if (rc \u00ac= 0) then do\n     racfsmsg = 'Allocation error'                            /* @A3 */\n     racflmsg = 'LMINIT failed for SYSPRINT'                  /* @A3 */\n     'setmsg msg(racf001)'                                    /* @A3 */\n     call Goodbye                                             /* @DK */\n  end\n  Select                                                      /* @A7 */\n     When (SETGDISP = \"VIEW\") THEN                            /* @A7 */\n          \"VIEW DATAID(\"id\") MACRO(\"EDITMACR\")\"               /* @A7 */\n     When (SETGDISP = \"EDIT\") THEN                            /* @A7 */\n          \"EDIT DATAID(\"id\") MACRO(\"EDITMACR\")\"               /* @A7 */\n     Otherwise                                                /* @A7 */\n          'browse dataid('id')'                               /* @A7 */\n  end                                                         /* @A7 */\n  'lmfree dataid('id')'\n\nAddress TSO\n  'delstack'\n  'free  f(sysut1 sysprint sysin)'\n  'alloc f(sysin) ds(*) reuse'\n\n  call Goodbye\nEXIT\n/*--------------------------------------------------------------------*/\n/*  Create Batch job                                             @AC  */\n/*--------------------------------------------------------------------*/\nCREATE_JCL:                                                   /* @AC */\nADDRESS ISPEXEC                                               /* @AC */\n  /*-----------------------------------------------*/         /* @AC */\n  /* If IBM's ISPF JOB card variable is:           */         /* @AC */\n  /*   ZLLGJOB1 =                                  */         /* @AC */\n  /* or                                            */         /* @AC */\n  /*   ZLLGJOB1 = //USERID   JOB (ACCOUNT),'NAME'  */         /* @AC */\n  /* or                                            */         /* @AC */\n  /*   ZLLGJOB1 = //@??##### JOB (??T),'NAME',etc. */         /* @AC */\n  /* or                                            */         /* @AC */\n  /*   ZLLGJOB1 = //JOB-NAME JOB (???),'NAME',etc. */         /* @AC */\n  /*-----------------------------------------------*/         /* @AC */\n  PARSE UPPER VAR ZLLGJOB1 W1 .                               /* @AC */\n  IF (ZLLGJOB1 = \"\") | (W1 = \"//USERID\"),                     /* @AC */\n   | (W1 = \"//@??#####\") | (W1 = \"//JOB-NAME\") THEN DO        /* @AC */\n     TMPZCMD = ZCMD                                           /* @AC */\n     CALL DEFINE_JOB_CARD                                     /* @AC */\n     ZCMD    = TMPZCMD                                        /* @AC */\n  END                                                         /* @AC */\n  \"FTOPEN TEMP\"                                               /* @AC */\n  \"VGET (ZTEMPF)\"                                             /* @AC */\n  \"FTINCL \"SKELETON1                                          /* @AC */\n  \"FTCLOSE\"                                                   /* @AC */\n  \"EDIT DATASET('\"ztempf\"')\"                                  /* @AC */\nRETURN                                                        /* @AC */\n/*--------------------------------------------------------------------*/\n/*  Define JOB card and JCL parameters                           @AC  */\n/*--------------------------------------------------------------------*/\nDEFINE_JOB_CARD:                                              /* @AC */\n  /*-----------------------------------------------*/         /* @AC */\n  /* If IBM's ISPF JOB card variable is:           */         /* @AC */\n  /*   ZLLGJOB1 =                                  */         /* @AC */\n  /* or                                            */         /* @AC */\n  /*   ZLLGJOB1 = //USERID   JOB (ACCOUNT),'NAME'  */         /* @AC */\n  /* or                                            */         /* @AC */\n  /*   ZLLGJOB1 = //@??##### JOB (??T),'NAME',etc. */         /* @AC */\n  /*-----------------------------------------------*/         /* @AC */\n  PARSE UPPER VAR ZLLGJOB1 W1 .                               /* @AC */\n  IF (ZLLGJOB1 = \"\") | (W1 = \"//USERID\") then do              /* @AC */\n     ZLLGJOB1 = \"//job-name JOB (acct),'first-last-name',\"    /* @AC */\n     ZLLGJOB2 = \"//         MSGCLASS=?,CLASS=?,\"||,           /* @AC */\n                \"REGION=0M,NOTIFY=&SYSUID\"                    /* @AC */\n     \"VPUT (ZLLGJOB1 ZLLGJOB2)\"                               /* @AC */\n  END                                                         /* @AC */\n                                                              /* @AC */\n  'control display save'                                      /* @AC */\n  \"ADDPOP\"                                                    /* @AC */\n  DO FOREVER                                                  /* @AC */\n     \"DISPLAY PANEL(\"PANEL99\")\"                               /* @AC */\n     IF (RC = 8) THEN LEAVE                                   /* @AC */\n  END                                                         /* @AC */\n  \"REMPOP\"                                                    /* @AC */\n  'control display restore'                                   /* @AC */\n  \"VPUT (ZLLGJOB1 ZLLGJOB2 ZLLGJOB3 ZLLGJOB4) PROFILE\"        /* @AC */\nRETURN                                                        /* @AC */\n/*--------------------------------------------------------------------*/\n/*  If tracing is on, display flower box                         @A1  */\n/*--------------------------------------------------------------------*/\nGOODBYE:                                                      /* @A1 */\n  If (SETMTRAC <> 'NO') then do                               /* @A1 */\n     Say \"*\"COPIES(\"-\",70)\"*\"                                 /* @A1 */\n     Say \"*\"Center(\"End Program = \"REXXPGM,70)\"*\"             /* @A1 */\n     Say \"*\"COPIES(\"-\",70)\"*\"                                 /* @A1 */\n  end                                                         /* @A1 */\nEXIT                                                          /* @AC */\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT417/CBT.V500.FILE417.PDS/EXEC.xmi", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT417/CBT.V500.FILE417.PDS", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}