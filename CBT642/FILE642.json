{"INMR01": {"INMLRECL": 80, "INMFNODE": "N1", "INMFUID": "SBGOLOB", "INMTNODE": "A", "INMTUID": "A", "INMFTIME": "20201220012520000000", "INMNUMF": 1}, "INMR02": {"1": {"INMUTILN": "IEBCOPY", "INMSIZE": 587860, "INMDSORG": "PO", "INMTYPE": "None", "INMLRECL": 80, "INMBLKSZ": 5600, "INMRECFM": "FB", "INMDIR": 9, "INMDSNAM": "CBT.V500.FILE642.PDS", "numfile": 1}, "2": {"INMUTILN": "INMCOPY", "INMSIZE": 587860, "INMDSORG": "PS", "INMLRECL": 32756, "INMBLKSZ": 3120, "INMRECFM": "VS", "numfile": 1}}, "INMR03": {"1": {"INMSIZE": 587860, "INMDSORG": "PS", "INMLRECL": 80, "INMRECFM": "?"}}, "file": {"CBT.V500.FILE642.PDS": {"COPYR1": {"type": "PDS", "DS1DSORG": 512, "DS1BLKL": 5600, "DS1LRECL": 80, "DS1RECFM": "FB", "DS1KEYL": 0, "DS1OPTCD": 0, "DS1SMSFG": 0, "file_tape_blocksize": 3120, "DVAOPTS": 12336, "DVACLASS": 32, "DVAUNIT": 15, "DVAMAXRC": 32760, "DVACYL": 3340, "DVATRK": 15, "DVATRKLN": 58786, "DVAOVHD": 0, "num_header_records": 2, "DS1REFD": "200354", "DS1SCEXT": "b'\\x00\\x00\\x00'", "DS1SCALO": "b'\\x80\\x00\\x00\\xbe'", "DS1LSTAR": "b'\\x00\\n\\t'", "DS1TRBAL": "b'\\x82\\xb0'"}, "COPYR2": {"deb": "b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "extents": ["b'\\x01\\x00\\x00\\x00\\xff\\x00\\x00\\x00\\x8f\\x03\\x90\\x00\\x04\\x9a\\xc0\\xd8'", "b'X\\xf4\\xfd\\xd0\\x00\\x00\\x04\\x94\\x00\\x0b\\x04\\x95\\x00\\x06\\x00\\x0b'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'", "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"]}, "members": {"$$$#DATE": {"ttr": 516, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04P\\x007\\x01\\x106/\\x01\\x106/\\x16G\\x00\\x0c\\x00\\x0c\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf8\\xf0@@@'", "ispf": {"version": "04.80", "flags": 0, "createdate": "2010-12-28T00:00:00", "modifydate": "2010-12-28T16:47:37", "lines": 12, "newlines": 12, "modlines": 0, "user": "CBT-480"}, "text": "REGULAR CBT TAPE - VERSION 480    FILE:  642\n\n    ORIGINAL DSNAME:  SBGOLOB.CBT480.FILE642\n    ---------------\n                    --RECFM-LRECL-BLKSIZE-DSORG\n                      FB    80    5600    PO\n\n   PDS117I 18 MEMBERS COUNTED; CUMULATIVE SIZE IS 5,049 RECORDS\n\n\nTIME THIS PDS WAS SHIPPED:   12/28/10    16:47:37    GMT-5:00\n\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$$NOTE1": {"ttr": 518, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00G\\x01\\x03\\x19\\x0f\\x01\\x03\\x19\\x0f\\x134\\x00 \\x00 \\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-07-09T00:00:00", "modifydate": "2003-07-09T13:34:47", "lines": 32, "newlines": 32, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:   CBT tape contribution\n   Date:   Wed, 9 Jul 2003 09:58:31 -0700\n   From:   \"Rich Hobt\" <Rich.Hobt@airborne.com>\n     To:   sbgolob@cbttape.org\n\n\nHi Sam.\n\nAfter many years of using CBT tape programs, I finally have a\ncontribution of my own.  I wrote a program (AFCLOGR1) that scans\nOPERLOG logstreams for specific text, msgids, etc.  and formats\nthe output in hardcopy SYSLOG format.  It has become quite handy\nto me, and we use it in a number of different ways here.  Perhaps\nothers may find it useful too.\n\nI packed it all up in an FB80 PDS and TSO XMIT'ed it per the\ninstructions, and am attaching it to this EMAIL as AFCLOGR1.XMIT.\nThe original PDS was named TRLH.AFCLOGR1.SRC, and was LRECL=80,\nRECFM=FB, BLKSIZE=27920.  I included documentation, JCL, and the\nlocal macros needed to assemble it.\n\nIf there is anything else you need, please let me know.\n\nRegards,\n\nRich Hobt\nAirborne Freight Corporation\n3101 Western Ave.\nSeattle, WA.  98121\n(206) 830-4088\n\n\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "$$NOTE2": {"ttr": 520, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00!\\x01\\t\\x00O\\x01\\t\\x00O\\x10H\\x00\\x12\\x00\\x12\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2009-01-04T00:00:00", "modifydate": "2009-01-04T10:48:21", "lines": 18, "newlines": 18, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:    New version of file 642\nFrom:       RHobt@azdps.gov\nDate:       Wed, 31 Dec 2008 15:50:01 -0700\nTo:         sbgolob@cbttape.org\n\nHi Sam,\n\nI've changed employers, and found a bug in my OPERLOG scan\nprogram - CBT file 642.  Attached is a newer version, with the\nbug fixed.\n\nHave a happy New Year!\n\nRich Hobt\nSystems Software Analyst\nArizona Department of Public Safety\n(602) 223-2519\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$$NOTE3": {"ttr": 522, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x19\\x01\\x106/\\x01\\x106/\\x16F\\x00\\x16\\x00\\x16\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2010-12-28T00:00:00", "modifydate": "2010-12-28T16:46:19", "lines": 22, "newlines": 22, "modlines": 0, "user": "SBGOLOB"}, "text": "Subject:  CBT file 642\nFrom:     <RHobt@azdps.gov>\nDate:     Tue, 28 Dec 2010 12:54:57 -0700\nTo:       <sbgolob@cbttape.org>\n\nHi Sam,\n\nI've updated my Operlog scan program to correct a problem that it\nhad with very large operlog records.  It used to just abend; now\nit handles as much of the record as it is given.\n\nI've attached the full PDS (in TSO Transmit format) with the\nsource, documentation, macros, etc.\n\nHappy holidays to you and yours!\n\nRich Hobt\nSystems Software Analyst\nArizona Department of Public Safety\n(602) 223-2519\nAFCLOGR1.XMIT\n\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "$PDSLOAD": {"ttr": 524, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x16\\x00\\x11\\x01\\x026_\\x01\\t\\x00O\\x108\\x00%\\x00\\x08\\x00\\x00\\xe2\\xc2\\xc7\\xd6\\xd3\\xd6\\xc2@@@'", "ispf": {"version": "01.22", "flags": 0, "createdate": "2002-12-31T00:00:00", "modifydate": "2009-01-04T10:38:11", "lines": 37, "newlines": 8, "modlines": 0, "user": "SBGOLOB"}, "text": "//SBGOLOBL JOB (ACCT#),PDSLOAD,\n// NOTIFY=&SYSUID,\n// CLASS=B,MSGCLASS=X\n//* --------------------------------------------------- *//\n//*      PDSLOAD JOB TO CREATE INSTALL LIBRARIES        *//\n//*                                                     *//\n//*     (PLEASE CUSTOMIZE FOR YOUR OWN SYSTEM)          *//\n//* --------------------------------------------------- *//\n//TSOBATCH EXEC PGM=IKJEFT01\n//SYSTSPRT DD SYSOUT=*\n//SYSTSIN DD *\n   RECEIVE INDS('SBGOLOB.CBT477.FILE642(PDSLOAD)')\n   DSN ('SBGOLOB.TEMP.PDSLOAD') VOL(WORK04)\n/*\n//*\n//PDSLOAD PROC IPDS='SBGOLOB.CBT477.FILE642',      <=== CHANGE\n//             OPRE=SBGOLOB,\n//             QUAL=FILE642,\n//             MEMB=XXX,\n//             OUNT=SYSALLDA,\n//             OVL=WORK04,\n//             DSP1=NEW,\n//             DSP2=CATLG,\n//             DSP3='',\n//             P=30,S=60,D=44\n//*\n//LOAD   EXEC PGM=PDSLOAD\n//STEPLIB  DD DISP=SHR,DSN=SBGOLOB.TEMP.PDSLOAD\n//SYSPRINT DD SYSOUT=*\n//SYSUT1   DD DISP=SHR,DSN=&IPDS(&MEMB)\n//SYSUT2   DD UNIT=&OUNT,VOL=SER=&OVL,\n//             DSN=&OPRE..&QUAL..&MEMB,\n//             DISP=(&DSP1,&DSP2&DSP3),\n//             SPACE=(TRK,(&P,&S,&D),RLSE)\n//  PEND\n//*\n//S002 EXEC PDSLOAD,MEMB=AFCSMP1\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "$README": {"ttr": 526, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x19\\x003\\x01\\x03\\x19\\x0f\\x01\\x106/\\x11S\\x00\\xc9\\x00\\x02\\x00\\x00\\xd7\\xe2\\xf7\\xf2\\xf3\\xf1@@@@'", "ispf": {"version": "01.25", "flags": 0, "createdate": "2003-07-09T00:00:00", "modifydate": "2010-12-28T11:53:33", "lines": 201, "newlines": 2, "modlines": 0, "user": "PS7231"}, "text": "AFCLOGR1 is a program I developed to scan through an OPERLOG datastream,\nprinting out selected records in hardcopy SYSLOG format.  I find it\nconvenient to use for a number of purposes:\n\n  Finding something in the log when I don't have the time or patience to\n  keep hitting PF5 in SDSF to look for it.\n\n  Filtering out all the garbage messages in a given time span, when the\n  thing I am looking for may be \"hidden\" amongst many other messages.\n\n  Finding more than one keyword or message ID.\n\n  Filtering based on jobname, jobid, or system name.\n\n  Running a daily job to scan for \"interesting\" messages since the last\n  time I ran the job.  I have an automated process for building and\n  submitting this job when I log on in the morning.\n\nI'm sure you can find other uses for it as well.\n\nOne note about the program design - I could have added SYSIN parameters to\nspecify the date and time, then dynamically allocate and read the\nlogstream, but I decided against it.  Too much like reinventing the wheel.\nThe subsystem JCL already has that capability, and it just didn't seem\nworth the effort.\n\nOur logstream name is SYSPLEX.OPERLOG - if yours is different, you'll\nhave to change the name in the AFCLOGSC proc, or whatever JCL you use\nto run the program.\n\nThis program has been run on z/OS 1.3 - 1.9, but I see no reason it can't\nrun on later levels.  HOWEVER, due to the heavy use of relative addressing,\nit will only run on a box with the relative addressing instructions\navailable.  I'm not sure at which architectural level they were introduced,\nbut I'm pretty sure they've been around for a while.\n\nUPDATES:\n\n2010/12/28\nI decided I didn't like the U200 abend that I had introduced for \"too large\"\nrecords, so I added code to handle them, at least as much as possible.  Although\nthe logstream LRECL can be as large as 65535, we only receive up to 32752 bytes\non a GET.  And then, it may be cut off in the middle of a section, so the\nMDBTLEN may be incorrect.  It doesn't happen very often (just really big\ncommands like \"D TCPIP,TN3270,TELNET,CONN,MAX=*\".  But as far as I can tell,\nthis version works correctly within those restrictions.\n\n2008/12/31\nFixed a bug where the program would get into a tight loop.  This was due\nto me assuming that the OPERLOG LRECL was somehow fixed at 4100.  When I\ntried running it at my new job, I discovered that this wasn't so.  Now the\nprogram will check the LRECL against the MDB length, and ABEND with a\nU200 if it isn't big enough.  If this happens, just increase the LRECL\nin the LOGIN JCL.\n\n2006/09/25\nThis version has a couple of small enhancements - multiple SYSID statements\nhonored, and FIND=QUIT.  It was also \"adjusted\" so as not to use a base\nregister for the code - it's all relative now.  I haven't seen a program\nwritten this way before, and I couldn't resist experimenting with it.  There\nare undoubtedly better ways to do it, but this at least has the small virtue\nof actually working.\n\n--------------------------------------------------------------------------------\n\nSYSIN statements:\n\nJOBNAME=XXXXXXXX\n  Limit the search to records produced by this jobname.\n\nJOBID=JOBXXXXX\n  Limit the search to records produced by this jobid.\n\nJOBNAME and JOBID are not guaranteed to find every message\nrelated to the specified jobname and/or jobid.  Not sure why this\nis so, but sometimes the messages just don't seem to have this data\nin the right fields.\n\nSYSID=XXXXXXXX\n  Limit the search to records produced from this system (or systems -\n  up to 16, each specified on a separate SYSID= card).\n\nNote that the following text and msgid keywords refer to \"selected\"\nrecords.  These are records \"selected\" by any of the preceeding\nkeywords.  If none of these are specified, \"selected\" becomes all\noperlog records in the JCL-controlled timespan.\n\nTEXT='TEXT YOU ARE LOOKING FOR'\n\n  The first character after the \"=\" is the string delimiter and is\n  required.  This can be any character, but must be matched at the\n  end.  Maximum string length is 127.  The text of all selected\n  messages (including multi record) will be scanned for this text.\n\nMSGID='MSGID YOU ARE LOOKING FOR'\n\n  The first character after the \"=\" is the string delimiter and is\n  required.  This can be any character, but must be matched at the\n  end.  Maximum string length is 127.  Only the first 3 columns of\n  the 1st line of each selected message will be scanned for the\n  beginning of this text, so it is faster than the TEXT= keyword.\n\nFIND=EXCLUDE\n\n  Entered as shown.  The result of this keyword is that if any of\n  the text or msgids are found, the record will not be printed.\n  Use this to print everything except the matches.\n\nFIND=QUIT\n\n  Entered as shown.  Use this if you are scanning through a long\n  time span for the 1st occurrance of something, and dont want to\n  waste the time searching through the rest of the log after you\n  found it.  Causes execution to end after the 1st hit.\n\nThe order of the keywords does not matter.  A record is printed if\nit matches any of the text strings and the jobname, jobid, and/or\nsysid criteria (or not printed, if \"FIND=EXCLUDE\").\n\nIf you just want to print out all the log records in a given\ntimespan, leave out the sysin parameters (or only include comments).\n\nA \"*\" in column 1 indicates a comment record.\n\nExamples:\n\n//LOGCOPY  EXEC PGM=AFCLOGR1\n//SYSUDUMP DD   SYSOUT=*\n//LOGIN DD DSN=SYSPLEX.OPERLOG,RECFM=VB,LRECL=32756,BLKSIZE=32760,\n// SUBSYS=(LOGR,,'FROM=(2001/339,07:00),TO=(2001/339,07:01),LOCAL')\n//LOGOUT   DD   SYSOUT=*\n//SYSIN    DD   *\n* THIS COMMENT INTENTIONALLY LEFT MEANINGLESS\nTEXT=' INVALID '\nMSGID='IEF403I'\n\nThis jobstep scans the operlog from 07:00 December 5, 2001 to\n07:01 December 5, 2001 for any message containing the word\n\" INVALID \", or any message starting with \"IEF403I\".\n\n\n\n//LOGCOPY  EXEC PGM=AFCLOGR1\n//SYSUDUMP DD   SYSOUT=*\n//LOGIN DD DSN=SYSPLEX.OPERLOG,RECFM=VB,LRECL=32756,BLKSIZE=32760,\n// SUBSYS=(LOGR,,'FROM=(2001/339,07:00),TO=(2001/339,07:01),LOCAL')\n//LOGOUT   DD   SYSOUT=*\n//SYSIN    DD   *\n* ANOTHER POINTLESS COMMENT\nMSGID=\"ICH408\"\nTEXT=%INDICATED FOR%\nFIND=EXCLUDE\n\nThis jobstep scans the same period, but prints every message\nthat does not start with \"ICH408\" or contain the phrase\n\"INDICATED FOR\".\n\n\nAbends and return codes:\n\nAbend U100:  The login buffer overflowed.  I did an abend\n  rather than set a return code because this way we can see\n  what kind of huge record caused the overflow.\n\nRC 12: SEARCH-FOR text buffer overflow.  Too much SYSIN, too much to\n       look for.  Or too many SYSID= cards.\n\nRC 8: Delimiter error on a SYSIN statement.\n\nRC 1: Nothing found.\n\nRC 0: Normal return, we found at least one hit.\n\n--------------------------------------------------------------------------------\n\nThe members in this dataset are:\n\n$README  - I guess you already know about this one.\nAFCLOGR1 - The assembler source for the log scanner.  AFC stands for\n           'Airborne Freight Corporation', by the way - my employer\n           when I wrote the original version.\nAFCLOGSC - JCL proc to run the program.\nASMINFO  - A macro, used by INR to build a human-readable program header.\nASMJCL   - JCL to assemble and link the program.\nBR2JMP   - A macro, used by INR to OPSYN branch instructions to jumps\nCLEAR    - A macro, used by AFCLOGR1 to clear a storage field to blanks.\nINR      - A macro, used by AFCLOGR1 for entry housekeeping.  No base reg.\nEXECJCL  - JCL to run the program (uses proc AFCLOGSC)\nOUTR     - A macro, used by AFCLOGR1 for exit housekeeping.\n\nThis program may be used, modified, and/or shared by anyone.  Just don't\nsell it, and please give me some credit.\n\nRichard Hobt\nArizona Department of Public Safety\n2310 N. 20th\nPhoenix, AZ.  85009\n(602) 223-2519\nRHobt@azdps.gov\n\nSeptember 25, 2006\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "@FILE642": {"ttr": 530, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x04P\\x000\\x01\\x106/\\x01\\x106/\\x16G\\x00\\xcd\\x00\\xcd\\x00\\x00\\xc3\\xc2\\xe3`\\xf4\\xf8\\xf0@@@'", "ispf": {"version": "04.80", "flags": 0, "createdate": "2010-12-28T00:00:00", "modifydate": "2010-12-28T16:47:30", "lines": 205, "newlines": 205, "modlines": 0, "user": "CBT-480"}, "text": "//***FILE 642 is from Rich Hobt and contains two program packages.  *   FILE 642\n//*           AFCLOGR1 is a program to find any strings you want,   *   FILE 642\n//*           in a SYSPLEX OPERLOG.  AFCSMP1 provides an interface  *   FILE 642\n//*           to the API provided by SMP/E and can be used to       *   FILE 642\n//*           produce customized SMP/E reports that can be fed      *   FILE 642\n//*           into REXX or (especially) SAS for further processing. *   FILE 642\n//*                                                                 *   FILE 642\n//*     AFCSMP1 is presented as an IEBUPDTE unloaded pds            *   FILE 642\n//*     (actually in PDSLOAD format, to preserve the ISPF           *   FILE 642\n//*     statistics.  The PDSLOAD program is provided here           *   FILE 642\n//*     in this pds, and a job (member $PDSLOAD) is also            *   FILE 642\n//*     provided to create a separate pds for AFCSMP1,              *   FILE 642\n//*     with the install information and $README instructions.      *   FILE 642\n//*                                                                 *   FILE 642\n//*     A description of AFCLOGR1 follows, and is followed by a     *   FILE 642\n//*           description of AFCSMP1.                               *   FILE 642\n//*                                                                 *   FILE 642\n//*                  --->  AFCLOGR1  <---                           *   FILE 642\n//*                                                                 *   FILE 642\n//*     AFCLOGR1 is a program I developed to scan through an        *   FILE 642\n//*     OPERLOG datastream, printing out selected records in        *   FILE 642\n//*     hardcopy SYSLOG format.  I find it convenient to use for    *   FILE 642\n//*     a number of purposes:                                       *   FILE 642\n//*                                                                 *   FILE 642\n//*       Finding something in the log when I don't have the        *   FILE 642\n//*       time or patience to keep hitting PF5 in SDSF to look      *   FILE 642\n//*       for it.                                                   *   FILE 642\n//*                                                                 *   FILE 642\n//*       Filtering out all the garbage messages in a given time    *   FILE 642\n//*       span, when the thing I am looking for may be \"hidden\"     *   FILE 642\n//*       amongst many other messages.                              *   FILE 642\n//*                                                                 *   FILE 642\n//*       Finding more than one keyword or message ID.              *   FILE 642\n//*                                                                 *   FILE 642\n//*       Filtering based on jobname, jobid, or system name.        *   FILE 642\n//*                                                                 *   FILE 642\n//*       Running a daily job to scan for \"interesting\" messages    *   FILE 642\n//*       since the last time I ran the job.  I have an             *   FILE 642\n//*       automated process for building and submitting this job    *   FILE 642\n//*       when I log on in the morning.                             *   FILE 642\n//*                                                                 *   FILE 642\n//*     I'm sure you can find other uses for it as well.            *   FILE 642\n//*                                                                 *   FILE 642\n//*     One note about the program design - I could have added      *   FILE 642\n//*     SYSIN parameters to specify the date and time, then         *   FILE 642\n//*     dynamically allocate and read the logstream, but I          *   FILE 642\n//*     decided against it.  Too much like reinventing the          *   FILE 642\n//*     wheel.  The subsystem JCL already has that capability,      *   FILE 642\n//*     and it just didn't seem worth the effort.                   *   FILE 642\n//*                                                                 *   FILE 642\n//*     Our logstream name is SYSPLEX.OPERLOG - if yours is         *   FILE 642\n//*     different, you'll have to change the name in the            *   FILE 642\n//*     AFCLOGSC proc, or whatever JCL you use to run the           *   FILE 642\n//*     program.                                                    *   FILE 642\n//*                                                                 *   FILE 642\n//*     This program has been run on z/OS 1.3 - 1.9, but I see      *   FILE 642\n//*     no reason it can't run on later levels.  HOWEVER, due to    *   FILE 642\n//*     the heavy use of relative addressing, it will only run      *   FILE 642\n//*     on a box with the relative addressing instructions          *   FILE 642\n//*     available.  I'm not sure at which architectural level       *   FILE 642\n//*     they were introduced, but I'm pretty sure they've been      *   FILE 642\n//*     around for a while.                                         *   FILE 642\n//*                                                                 *   FILE 642\n//*     UPDATES:                                                    *   FILE 642\n//*                                                                 *   FILE 642\n//*     2008/12/31                                                  *   FILE 642\n//*     Fixed a bug where the program would get into a tight        *   FILE 642\n//*     loop.  This was due to me assuming that the OPERLOG         *   FILE 642\n//*     LRECL was somehow fixed at 4100.  When I tried running      *   FILE 642\n//*     it at my new job, I discovered that this wasn't so.  Now    *   FILE 642\n//*     the program will check the LRECL against the MDB length,    *   FILE 642\n//*     and ABEND with a U200 if it isn't big enough.  If this      *   FILE 642\n//*     happens, just increase the LRECL in the LOGIN JCL.          *   FILE 642\n//*                                                                 *   FILE 642\n//*     2006/09/25                                                  *   FILE 642\n//*     This version has a couple of small enhancements -           *   FILE 642\n//*     multiple SYSID statements honored, and FIND=QUIT.  It       *   FILE 642\n//*     was also \"adjusted\" so as not to use a base register for    *   FILE 642\n//*     the code - it's all relative now.  I haven't seen a         *   FILE 642\n//*     program written this way before, and I couldn't resist      *   FILE 642\n//*     experimenting with it.  There are undoubtedly better        *   FILE 642\n//*     ways to do it, but this at least has the small virtue of    *   FILE 642\n//*     actually working.                                           *   FILE 642\n//*                                                                 *   FILE 642\n//*     ----------------------------------------------------------  *   FILE 642\n//*                                                                 *   FILE 642\n//*     SYSIN statements:                                           *   FILE 642\n//*                                                                 *   FILE 642\n//*     JOBNAME=XXXXXXXX                                            *   FILE 642\n//*       Limit the search to records produced by this jobname.     *   FILE 642\n//*                                                                 *   FILE 642\n//*     JOBID=JOBXXXXX                                              *   FILE 642\n//*       Limit the search to records produced by this jobid.       *   FILE 642\n//*                                                                 *   FILE 642\n//*     JOBNAME and JOBID are not guaranteed to find every          *   FILE 642\n//*     message related to the specified jobname and/or jobid.      *   FILE 642\n//*     Not sure why this is so, but sometimes the messages just    *   FILE 642\n//*     don't seem to have this data in the right fields.           *   FILE 642\n//*                                                                 *   FILE 642\n//*     SYSID=XXXXXXXX                                              *   FILE 642\n//*       Limit the search to records produced from this system     *   FILE 642\n//*       (or systems - up to 16, each specified on a separate      *   FILE 642\n//*       SYSID= card).                                             *   FILE 642\n//*                                                                 *   FILE 642\n//*     Note that the following text and msgid keywords refer to    *   FILE 642\n//*     \"selected\" records.  These are records \"selected\" by any    *   FILE 642\n//*     of the preceeding keywords.  If none of these are           *   FILE 642\n//*     specified, \"selected\" becomes all operlog records in the    *   FILE 642\n//*     JCL-controlled timespan.                                    *   FILE 642\n//*                                                                 *   FILE 642\n//*     TEXT='TEXT YOU ARE LOOKING FOR'                             *   FILE 642\n//*                                                                 *   FILE 642\n//*       The first character after the \"=\" is the string           *   FILE 642\n//*       delimiter and is required.  This can be any character,    *   FILE 642\n//*       but must be matched at the end.  Maximum string length    *   FILE 642\n//*       is 127.  The text of all selected messages (including     *   FILE 642\n//*       multi record) will be scanned for this text.              *   FILE 642\n//*                                                                 *   FILE 642\n//*     MSGID='MSGID YOU ARE LOOKING FOR'                           *   FILE 642\n//*                                                                 *   FILE 642\n//*       The first character after the \"=\" is the string           *   FILE 642\n//*       delimiter and is required.  This can be any character,    *   FILE 642\n//*       but must be matched at the end.  Maximum string length    *   FILE 642\n//*       is 127.  Only the first 3 columns of the 1st line of      *   FILE 642\n//*       each selected message will be scanned for the             *   FILE 642\n//*       beginning of this text, so it is faster than the TEXT=    *   FILE 642\n//*       keyword.                                                  *   FILE 642\n//*                                                                 *   FILE 642\n//*     FIND=EXCLUDE                                                *   FILE 642\n//*                                                                 *   FILE 642\n//*       Entered as shown.  The result of this keyword is that     *   FILE 642\n//*       if any of the text or msgids are found, the record        *   FILE 642\n//*       will not be printed.  Use this to print everything        *   FILE 642\n//*       except the matches.                                       *   FILE 642\n//*                                                                 *   FILE 642\n//*     FIND=QUIT                                                   *   FILE 642\n//*                                                                 *   FILE 642\n//*       Entered as shown.  Use this if you are scanning           *   FILE 642\n//*       through a long time span for the 1st occurrance of        *   FILE 642\n//*       something, and dont want to waste the time searching      *   FILE 642\n//*       through the rest of the log after you found it.           *   FILE 642\n//*       Causes execution to end after the 1st hit.                *   FILE 642\n//*                                                                 *   FILE 642\n//*     The order of the keywords does not matter.  A record is     *   FILE 642\n//*     printed if it matches any of the text strings and the       *   FILE 642\n//*     jobname, jobid, and/or sysid criteria (or not printed,      *   FILE 642\n//*     if \"FIND=EXCLUDE\").                                         *   FILE 642\n//*                                                                 *   FILE 642\n//*     If you just want to print out all the log records in a      *   FILE 642\n//*     given timespan, leave out the sysin parameters (or only     *   FILE 642\n//*     include comments).                                          *   FILE 642\n//*                                                                 *   FILE 642\n//*     A \"*\" in column 1 indicates a comment record.               *   FILE 642\n//*                                                                 *   FILE 642\n//*     ----------------------------------------------------------  *   FILE 642\n//*                                                                 *   FILE 642\n//*     The members in this dataset are:                            *   FILE 642\n//*                                                                 *   FILE 642\n//*     $README  - I guess you already know about this one.         *   FILE 642\n//*     AFCLOGR1 - The assembler source for the log scanner.  AFC   *   FILE 642\n//*                stands for 'Airborne Freight Corporation', by    *   FILE 642\n//*                the way - my employer when I wrote the           *   FILE 642\n//*                original version.                                *   FILE 642\n//*     AFCLOGSC - JCL proc to run the program.                     *   FILE 642\n//*     ASMINFO  - A macro, used by INR to build a                  *   FILE 642\n//*                human-readable program header.                   *   FILE 642\n//*     ASMJCL   - JCL to assemble and link the program.            *   FILE 642\n//*     CLEAR    - A macro, used by AFCLOGR1 to clear a storage     *   FILE 642\n//*                field to blanks.                                 *   FILE 642\n//*     INR      - A macro, used by AFCLOGR1 for entry              *   FILE 642\n//*                housekeeping.  No base reg.                      *   FILE 642\n//*     EXECJCL  - JCL to run the program (uses proc AFCLOGSC)      *   FILE 642\n//*     OUTR     - A macro, used by AFCLOGR1 for exit housekeeping. *   FILE 642\n//*                                                                 *   FILE 642\n//*     This program may be used, modified, and/or shared by        *   FILE 642\n//*     anyone.  Just don't sell it, and please give me some        *   FILE 642\n//*     credit.                                                     *   FILE 642\n//*                                                                 *   FILE 642\n//*                                                                 *   FILE 642\n//*                  --->  AFCSMP1  <---                            *   FILE 642\n//*                                                                 *   FILE 642\n//*     AFCSMP1 is a program I developed to access the API          *   FILE 642\n//*     provided by SMP/E.  It uses control cards to build the      *   FILE 642\n//*     SMP/E request (DD GIMIN), then formats and outputs the      *   FILE 642\n//*     results (DD GIMOUT).  Status and error messages are         *   FILE 642\n//*     reported via DD GIMPRINT.  It is mainly useful for          *   FILE 642\n//*     extracting data to be further processed by REXX, SAS, or    *   FILE 642\n//*     whatever.  It is especially useful in SAS, as it can be     *   FILE 642\n//*     invoked directly from within the code.                      *   FILE 642\n//*                                                                 *   FILE 642\n//*     This program has been run on z/OS 1.3, 1.4, 1.7. and 1.8.   *   FILE 642\n//*                                                                 *   FILE 642\n//*     This program may be used, modified, and/or shared by        *   FILE 642\n//*     anyone.  Just don't sell it, and please give me some        *   FILE 642\n//*     credit.                                                     *   FILE 642\n//*                                                                 *   FILE 642\n//*     Richard Hobt                                                *   FILE 642\n//*     Arizona Department of Public Safety                         *   FILE 642\n//*     2310 N. 20th                                                *   FILE 642\n//*     Phoenix, AZ.  85009                                         *   FILE 642\n//*     (602) 223-2519                                              *   FILE 642\n//*     RHobt@azdps.gov                                             *   FILE 642\n//*                                                                 *   FILE 642\n//*     Dec. 31, 2008                                               *   FILE 642\n//*                                                                 *   FILE 642\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "AFCLOGR1": {"ttr": 769, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x08\\x00\\x19\\x01\\x03\\x19\\x0f\\x01\\x106/\\x112\\x04\\x87\\x04\\x14\\x00\\x00\\xd7\\xe2\\xf7\\xf2\\xf3\\xf1@@@@'", "ispf": {"version": "01.08", "flags": 0, "createdate": "2003-07-09T00:00:00", "modifydate": "2010-12-28T11:32:19", "lines": 1159, "newlines": 1044, "modlines": 0, "user": "PS7231"}, "text": "         TITLE 'A F C L O G R 1   AFC OPERLOG EXTRACT'\n***********************************************************************\n*                                                                     *\n* AFCLOGR1                                                            *\n*                                                                     *\n* THIS PROGRAM IS INTENDED TO READ AN OPERLOG DATA STREAM FROM        *\n* LOGIN AND WRITE SELECTED RECORDS TO LOGOUT IN HARDCOPY LOG FORMAT.  *\n*                                                                     *\n* TIME SPAN OF THE RECORDS TO BE SEARCHED IS CONTROLLED IN THE JCL.   *\n* RECORD SELECTION IS DETERMINED BY SYSIN CONTROL CARDS.  THERE ARE   *\n* 6 KEYWORDS (NOT COLUMN-SPECIFIC):                                   *\n*                                                                     *\n* JOBNAME=XXXXXXXX                                                    *\n*   LIMIT THE SEARCH TO RECORDS PRODUCED BY THIS JOBNAME              *\n*                                                                     *\n* JOBID=JOBXXXXX                                                      *\n*   LIMIT THE SEARCH TO RECORDS PRODUCED BY THIS JOBID                *\n*                                                                     *\n* SYSID=XXXXXXXX                                                      *\n*   LIMIT THE SEARCH TO RECORDS PRODUCED FROM THIS SYSTEM (OR         *\n*   SYSTEMS IF MULTIPLE SYSID CARDS ARE FOUND - UP TO 16).            *\n*                                                                     *\n* NOTE THAT THE FOLLOWING TEXT AND MSGID KEYWORDS REFER TO \"SELECTED\" *\n* RECORDS.  THESE ARE RECORDS \"SELECTED\" BY ANY OF THE PRECEEDING     *\n* KEYWORDS.  IF NONE OF THESE ARE SPECIFIED, \"SELECTED\" BECOMES ALL   *\n* OPERLOG RECORDS IN THE JCL-CONTROLLED TIMESPAN.                     *\n*                                                                     *\n* TEXT='TEXT YOU ARE LOOKING FOR'                                     *\n*                                                                     *\n*   THE FIRST CHARACTER AFTER THE \"=\" IS THE STRING DELIMITER AND IS  *\n*   REQUIRED.  THIS CAN BE ANY CHARACTER, BUT MUST BE MATCHED AT THE  *\n*   END.  MAXIMUM STRING LENGTH IS 127.  THE TEXT OF ALL SELECTED     *\n*   MESSAGES (INCLUDING MULTI RECORD) WILL BE SCANNED FOR THIS TEXT.  *\n*                                                                     *\n* MSGID='MSGID YOU ARE LOOKING FOR'                                   *\n*                                                                     *\n*   THE FIRST CHARACTER AFTER THE \"=\" IS THE STRING DELIMITER AND IS  *\n*   REQUIRED.  THIS CAN BE ANY CHARACTER, BUT MUST BE MATCHED AT THE  *\n*   END.  MAXIMUM STRING LENGTH IS 127.  ONLY THE FIRST 3 COLUMNS OF  *\n*   THE 1ST LINE OF EACH SELECTED MESSAGE WILL BE SCANNED FOR THIS    *\n*   TEXT, SO IT IS FASTER THAN THE TEXT= KEYWORD.                     *\n*                                                                     *\n* FIND=EXCLUDE                                                        *\n*                                                                     *\n*   ENTERED AS SHOWN.  THE RESULT OF THIS KEYWORD IS THAT IF ANY OF   *\n*   THE TEXT OR MSGIDS ARE FOUND, THE RECORD WILL NOT BE PRINTED.     *\n*   USE THIS TO PRINT EVERYTHING EXCEPT THE MATCHES.                  *\n*                                                                     *\n* FIND=QUIT                                                           *\n*                                                                     *\n*   ENTERED AS SHOWN.  USE THIS IF YOU ARE SCANNING THROUGH A LONG    *\n*   TIME SPAN FOR THE 1ST OCCURRANCE OF SOMETHING, AND DONT WANT TO   *\n*   WASTE THE TIME SEARCHING THROUGH THE REST OF THE LOG.  CAUSES     *\n*   EXECUTION TO END AFTER THE 1ST HIT.                               *\n*                                                                     *\n* THE ORDER OF THE KEYWORDS DOES NOT MATTER.  A RECORD IS PRINTED IF  *\n* IT MATCHES ANY OF THE TEXT STRINGS AND THE JOBNAME, JOBID, AND/OR   *\n* SYSID CRITERIA (OR NOT PRINTED, IF \"FIND=EXCLUDE\").                 *\n*                                                                     *\n* AN \"*\" IN COLUMN 1 OF ANY SYSIN RECORD INDICATES A COMMENT, AND     *\n* THAT RECORD IS IGNORED.  A NULL OR DUMMY'D SYSIN (OR ALL COMMENTS)  *\n* CAUSES ALL THE OPERLOG RECORDS TO BE PRINTED.                       *\n*                                                                     *\n* EXAMPLES:                                                           *\n*                                                                     *\n* //LOGCOPY  EXEC PGM=AFCLOGR1                                        *\n* //SYSUDUMP DD   SYSOUT=*                                            *\n* //LOGIN DD DSN=SYSPLEX.OPERLOG,RECFM=VB,LRECL=4100,BLKSIZE=32760,   *\n* // SUBSYS=(LOGR,,'FROM=(2001/339,07:00),TO=(2001/339,07:01),LOCAL') *\n* //LOGOUT   DD   SYSOUT=*                                            *\n* //SYSIN    DD   *                                                   *\n* * THIS COMMENT INTENTIONALLY LEFT MEANINGLESS                       *\n* TEXT=' INVALID '                                                    *\n* MSGID='IEF403I'                                                     *\n*                                                                     *\n* THIS JOBSTEP SCANS THE OPERLOG FROM 07:00 DECEMBER 5, 2001 TO       *\n* 07:01 DECEMBER 5, 2001 FOR ANY MESSAGE CONTAINING THE WORD          *\n* \" INVALID \", OR ANY MESSAGE STARTING WITH \"IEF403I\".                *\n*                                                                     *\n* //LOGCOPY  EXEC PGM=AFCLOGR1                                        *\n* //SYSUDUMP DD   SYSOUT=*                                            *\n* //LOGIN DD DSN=SYSPLEX.OPERLOG,RECFM=VB,LRECL=4100,BLKSIZE=32760,   *\n* // SUBSYS=(LOGR,,'FROM=(2001/339,07:00),TO=(2001/339,07:01),LOCAL') *\n* //LOGOUT   DD   SYSOUT=*                                            *\n* //SYSIN    DD   *                                                   *\n* * ANOTHER POINTLESS COMMENT                                         *\n* MSGID=\"ICH408\"                                                      *\n* TEXT=%INDICATED FOR%                                                *\n* FIND=EXCLUDE                                                        *\n*                                                                     *\n* THIS JOBSTEP SCANS THE SAME PERIOD, BUT PRINTS EVERY MESSAGE        *\n* THAT DOES NOT START WITH \"ICH408\" OR CONTAIN THE PHRASE             *\n* \"INDICATED FOR\".                                                    *\n*                                                                     *\n*                                                                     *\n* ABENDS AND RETURN CODES:                                            *\n*                                                                     *\n* ABEND U100:  THE LOGIN BUFFER OVERFLOWED.  I DID AN ABEND           *\n*   RATHER THAN SET A RETURN CODE BECAUSE THIS WAY WE CAN SEE         *\n*   WHAT KIND OF HUGE RECORD CAUSED THE OVERFLOW.                     *\n*                                                                     *\n* ABEND 200 NO LONGER PROCESSED                                     RH4\n* ABEND U200:  THE LRECL OF THE LOGIN DD IS TOO SMALL - WE          RH3\n*   ENCOUNTERED A RECORD THAT WAS INCOMPLETE.  INCREASE THE         RH3\n*   LRECL OF THE LOGIN DD.                                          RH3\n*                                                                     *\n* RC 12: SEARCH-FOR TEXT BUFFER OVERFLOWED.  TOO MUCH TO LOOK FOR.    *\n*        OR TOO MANY SYSID= CARDS.                                    *\n*                                                                     *\n* RC 8: DELIMITER ERROR ON A SYSIN STATEMENT.                         *\n*                                                                     *\n* RC 1: NOTHING FOUND                                                 *\n*                                                                     *\n* RC 0: NORMAL RETURN, WE FOUND AT LEAST ONE HIT                      *\n*                                                                     *\n*                                                                     *\n* REGISTER USAGE:                                                     *\n*                                                                     *\n* R15 - *WORK                                                         *\n* R14 - LINK (JAS)                                                    *\n* R13 - WORKAREA BASE                                                 *\n* R12 - CONSTANTS BASE REG                                            *\n* R11 - LOGIN DCB                                                     *\n* R10 - LOGOUT DCB                                                    *\n* R9  - *WORK                                                         *\n* R8  - *WORK                                                         *\n* R7  - *WORK                                                         *\n* R6  - *WORK                                                         *\n* R5  - *WORK                                                         *\n* R4  - *WORK                                                         *\n* R3  - *WORK                                                         *\n* R2  - *WORK                                                         *\n* R1  - *WORK                                                         *\n* R0  - *WORK                                                         *\n*                                                                     *\n* 12/02/2010  RLH   INSTEAD AF ABENDING WITH A TOO-LARGE RECORD     RH4\n*                   (RH3), JUST USE THE PART THAT FITS.  WE DO THIS RH4\n*                   BECAUSE IT IS POSSIBLE FOR A LOG RECORD TO BE   RH4\n*                   65536 IN LENGTH, TOO BIG FOR US TO HANDLE.      RH4\n*                   WHEN THIS HAPPENS, WE JUST GET A \"CUT OFF\"      RH4\n*                   RECORD, IN WHICH CASE WE WILL PROCESS AS MUCH   RH4\n*                   OF IT AS IS THERE.                              RH4\n*                                                                     *\n* 12/15/2008  RLH   ABEND U200 IF MDBLEN > LRECL                    RH3\n*                   I FOUND THIS PROBLEM WHEN I USED JCL FROM       RH3\n*                   AFC/DHL, WHERE THE LRECL OF THE LOGSTREAM WAS   RH3\n*                   4100.  HERE AT DPS, IT'S APPARENTLY MORE.  WHEN RH3\n*                   A LARGE RECORD WAS READ, ONLY THE 1ST 4100      RH3\n*                   BYTES WERE PUT IN THE BUFFER, RESULTING IN AN   RH3\n*                   INCOMPLETE RECORD, AND A LOOPING CONDITION.     RH3\n*                   SO IF YOU GET A U200 ABEND, INCREASE THE LRECL  RH3\n*                   ON THE LOGIN FILE.                              RH3\n*                                                                     *\n* 09/24/2007  TRLH  MDBMCSH REMOVED IN Z/OS 1.8                   RH2 *\n* 09/19/2006  TRLH  ADD SUPPORT FOR MULTIPLE SYSID STATEMENTS         *\n* 08/25/2006  TRLH  NO BASE REG FOR CODE, USE ALL RELATIVE ADDRESSING *\n* 09/27/2005  TRLH  ADD \"FIND=QUIT\"                               RH1 *\n* 07/29/2002  TRLH  MSGID SHOULD LOOK IN 1ST 3 COLS, NOT JUST 2       *\n* 07/24/2002  TRLH  ADD RC=1 FOR NOTHING FOUND                        *\n* 12/07/2001  TRLH  ORIGINAL CODE                                     *\n*                                                                     *\n* RICHARD HOBT                                                        *\n* DHL WORLDWIDE EXPRESS                                               *\n* 8701 E. HARTFORD                                                    *\n* SCOTTSDALE, AZ.                                                     *\n* (480) 375-7320                                                      *\n* RICH.HOBT@DHL.COM                                                   *\n*                                                                     *\n***********************************************************************\n         SYSSTATE ARCHLVL=2\n         YREGS\n         EJECT\nAFCLOGR1 INR   WALEN=WORKAREA_LEN,RMODE=24,AMODE=24\n         USING WORKAREA,R13           ADDRESS DYNAMIC STORAGE\n         LARL  R12,CONSTANT_AREA      ADDRESS STATIC STORAGE\n         USING CONSTANT_AREA,R12\n*\n* GO INITIALIZE VARIOUS WORK AREA ITEMS\n*\n         ST    R1,PARM_ADDRESS        SAVE PARM ADDRESS\n*\n         JAS   R14,INITIALIZE\n         CLC   MAIN_RC,F0             DID IT GO OK?\n         JNE   EGRESS                 NO, LEAVE NOW\n*\n* MAIN PROCESS\n*\n         JAS   R14,PROCESS\n*\n* CLEANUP\n*\n         JAS   R14,CLEANUP\n*\n* EXIT\n*\nEGRESS   DS    0H\n\n         ICM   R15,B'1111',MAIN_RC    GET RETURN CODE\n         OUTR  RETCODE=YES\n*----------------------------------------------------------------------\n*\n* INITIALIZE ROUTINE - SET UP VARIABLES IN THE WORK AREA\n*\nINITIALIZE DS 0H\n         ST    R14,R14_INITIALIZE\n*\n         XC    MAIN_RC,MAIN_RC         SET RC=0\n         XC    BUFFER_RECORD_NO,BUFFER_RECORD_NO\n         XC    BUFFER_COUNT,BUFFER_COUNT\n         XC    BUFFER_SIZE,BUFFER_SIZE\n         MVI   FLAGS,X'00'\n         MVI   FLAG_INC_EXC,X'00'\n         MVI   SEARCH_JOBNAME_L,X'00'\n         XC    SEARCH_JOBID,SEARCH_JOBID\n         XC    SEARCH_SYSID_COUNT,SEARCH_SYSID_COUNT\n*\n         LA    R2,TEXT_SPACE\n         LA    R4,F1\n         LA    R3,@TEXT_SIZE\n         XR    R5,R5\n         MVCL  R2,R4                   CLEAR TEXT_SPACE\n*\n         LA    R1,BUFFER_SPACE\n         ST    R1,BUFFER_NEXT\n         JAS   R14,OPEN_FILES\n*\n         JAS   R14,READ_SYSIN\n*\n         L     R14,R14_INITIALIZE\n         BR    R14\n*----------------------------------------------------------------------\n*\n* PROCESS ROUTINE - SCAN THE INPUT, BUILD THE OUTPUT\n*\nPROCESS  DS 0H\n         ST    R14,R14_PROCESS\n*\nNEXT_LOG_RECORD DS 0H\n         GET   (R11)               READ RECORD\n         ST    R1,CURRENT_RECORD_ADDRESS\n         MVC   CURRENT_RECORD_ID,MDBGMID-MDBG+MDBHLEN+4(R1) SAVE ID\n*\n         CLC   CURRENT_RECORD_ID,PREVIOUS_RECORD_ID  CONTINUATION?\n         JE    ADD_CURRENT_RECORD  YES, ADD IT TO BUFFER\n         JAS   R14,UNLOAD_BUFFER   NO, UNLOAD CURRENT BUFFER CONTENTS\n         TM    FLAGS,@GOT_A_HIT+@FIND_QUIT DO WE NEED TO QUIT NOW?  RH1\n         JO    PROCESS_DONE        YES, ALL DONE                    RH1\nADD_CURRENT_RECORD DS 0H\n         JAS   R14,ADD_TO_BUFFER   ADD CURRENT RECORD TO BUFFER\n*\n         MVC   PREVIOUS_RECORD_ID,CURRENT_RECORD_ID SAVE RECORD ID\n         J     NEXT_LOG_RECORD\n*\nLOGIN_EOF DS 0H\n         JAS   R14,UNLOAD_BUFFER\nPROCESS_DONE DS 0H\n         L     R14,R14_PROCESS\n         BR    R14\n*----------------------------------------------------------------------\n*\n* ADD RECORD TO BUFFER\n*\nADD_TO_BUFFER DS 0H\n         ST    R14,R14_ADD_TO_BUFFER\n*\n         L     R4,CURRENT_RECORD_ADDRESS  WHERE IT COMES FROM\n         CLC   0(2,R4),MDBLEN-MDB+4(R4)   COMPARE RDW AND MDBLEN    RH3\n*        JL    LRECL_ABEND                IF RDW IS LESS, ABEND     RH3\n         JNL   MDBLEN_OK                  GO AHEAD USING MDB LENGTH RH4\n         LH    R1,0(R4)                   GET RDW                   RH4\n         AHI   R1,-4                      REDUCE BY RDW LENGTH      RH4\n         STH   R1,MDBLEN-MDB+4(R4)        \"REAL\" MDBLEN             RH4\nMDBLEN_OK DS 0H                                                     RH4\n         LH    R3,0(R4)                   LENGTH (FROM RDW)\n         L     R6,BUFFER_SIZE             HOW MUCH SPACE IN USE\n         AR    R6,R3                      HOW MUCH WILL BE USED\n         C     R6,F_BUFFER_SIZE           TOO MUCH?\n         JNL   BUFFER_ABEND               YES, GO ABEND NOW\n         L     R2,BUFFER_NEXT             WHERE IT GOES TO\n         LR    R5,R3                      EQUAL LENGTH\n         MVCL  R2,R4                      COPY CURRENT RECORD\n         ST    R2,BUFFER_NEXT             NEXT ONE GOES HERE\n         ST    R6,BUFFER_SIZE             UPDATE SPACE COUNT\n         L     R3,BUFFER_COUNT\n         AHI   R3,1\n         ST    R3,BUFFER_COUNT            INCREMENT RECORD COUNT\n*\nADD_TO_BUFFER_RETURN DS 0H\n         L     R14,R14_ADD_TO_BUFFER\n         BR    R14\nBUFFER_ABEND DS 0H\n         ABEND 100,DUMP                   ABEND U100\n*LRECL_ABEND DS 0H                                             RH3  RH4\n*        ABEND 200,DUMP                   ABEND U200           RH3  RH4\n*----------------------------------------------------------------------\n*\n* PROCESS RECORDS IN BUFFERS\n*\nUNLOAD_BUFFER DS 0H\n         ST    R14,R14_UNLOAD_BUFFER\n* LOOK THROUGH THE BUFFERED RECORDS TO SEE IF WE WANT TO PRINT ANY\n         LA    R9,BUFFER_SPACE     ADDRESS OF 1ST RECORD IN BUFFER\n         MVC   BUFFER_RECORD_NO,F1 1ST RECORD\n         L     R8,BUFFER_COUNT     NUMBER OF RECORDS\n         LTR   R8,R8               ANYTHING THERE?\n         JZ    UNLOAD_BUFFER_RETURN NO, GO AWAY\nNEXT_BUFFER_FILTER DS 0H\n*\n         STM   R8,R9,R8_R9_UNLOAD  SAVE OUR REGS\n         AHI   R9,4                POINT PAST RDW\n         JAS   R14,FILTER_RECORD   GO SEE IF WE WANT TO KEEP IT\n         LM    R8,R9,R8_R9_UNLOAD  RESTORE OUR REGS\n         XC    FOUND_FLAG,FLAG_INC_EXC ADJUST FOR INCLUDE/EXCLUDE\n         TM    FOUND_FLAG,@FOUND   DID WE FIND ANYTHING?\n         JO    WRITE_BUFFER_RECORDS YES, GO DO IT\n         AH    R9,0(R9)            POINT TO NEXT BUFFER RECORD\n         L     R1,BUFFER_RECORD_NO\n         AHI   R1,1                ADD 1 TO CURRENT RECORD NUMBER\n         ST    R1,BUFFER_RECORD_NO\n         JCT   R8,NEXT_BUFFER_FILTER LOOK THROUGH ALL RECORDS\n         J     FLUSH_BUFFERS       FLUSH BUFFERS AND RETURN\n* PRINT THE BUFFERED RECORDS\nWRITE_BUFFER_RECORDS DS 0H\n         OI    FLAGS,@GOT_A_HIT    INDICATE THAT WE GOT A HIT\n         LA    R9,BUFFER_SPACE     ADDRESS OF 1ST RECORD IN BUFFER\n         L     R8,BUFFER_COUNT     NUMBER OF RECORDS\n         MVC   BUFFER_RECORD_NO,F1 1ST RECORD\nNEXT_BUFFER_WRITE  DS 0H\n*\n         STM   R8,R9,R8_R9_UNLOAD  SAVE OUR REGS\n         AHI   R9,4                POINT PAST RDW\n         JAS   R14,WRITE_RECORD    GO FORMAT IT FOR PRINT\n         LM    R8,R9,R8_R9_UNLOAD  RESTORE OUR REGS\n         L     R1,BUFFER_RECORD_NO\n         AHI   R1,1                ADD 1 TO CURRENT RECORD NUMBER\n         ST    R1,BUFFER_RECORD_NO\n         AH    R9,0(R9)            POINT TO NEXT BUFFER RECORD\n         JCT   R8,NEXT_BUFFER_WRITE LOOP THROUGH THE BUFFER\n*\nFLUSH_BUFFERS DS 0H\n         XC    BUFFER_RECORD_NO,BUFFER_RECORD_NO\n         XC    BUFFER_COUNT,BUFFER_COUNT NO RECORDS IN USE\n         XC    BUFFER_SIZE,BUFFER_SIZE   NO BYTES IN USE\n         LA    R1,BUFFER_SPACE           POINT TO\n         ST    R1,BUFFER_NEXT            FIRST POSITION\n*\nUNLOAD_BUFFER_RETURN DS 0H\n         L     R14,R14_UNLOAD_BUFFER\n         BR    R14\n*----------------------------------------------------------------------\n*\n* FILTER RECORD - SEE IF WE WANT TO \"KEEP\" THIS RECORD\n*\n* INPUT:\n*   R9 HAS ADDRESS OF RECORD\n* OUTPUT:\n*\n*\nFILTER_RECORD DS 0H\n         ST    R14,R14_FILTER_RECORD\n*\n         NI    FOUND_FLAG,255-@FOUND ASSUME WE DON'T WANT IT\n*\n         CLI   TEXT_SPACE,X'00'    ANY TEXT TO LOOK FOR?\n         JNE   FILTER_SEARCH       YES\n         CLI   SEARCH_JOBNAME_L,X'00' HOW ABOUT A JOBNAME?\n         JNE   FILTER_SEARCH       YES, CONTINUE\n         TM    SEARCH_JOBID,X'BF'  JOBID, MAYBE?\n         JNZ   FILTER_SEARCH       YES\n         CLI   SEARCH_SYSID_COUNT,0  SYSID, MAYBE?\n         JNE   FILTER_SEARCH       YES\nFILTER_NO_ITEMS DS 0H\n         OI    FOUND_FLAG,@FOUND   NOTHING TO FILTER ON, MATCH ALL\n         J     FILTER_RECORD_RETURN\nFILTER_SEARCH DS 0H\n         LH    R8,0(R9)            LENGTH OF ENTIRE RECORD\n         AHI   R8,MDBHLEN*-1       MINUS MDB HEADER LENGTH\n         AHI   R9,MDBHLEN          POINT TO MDBG PART\n         SH    R8,0(R9)            SUBTRACT MDBG LENGTH FROM TOTAL\n*\n         USING MDBG,R9\n         MVC   TEMP_MDBGJBNM,MDBGJBNM SAVE JOBNAME\n         CLI   SEARCH_SYSID_COUNT,0 SEARCH FOR SYSID?\n         JE    FILTER_MDBSCP       NO, CONTINUE\n         LA    R3,SEARCH_SYSID     YES, START HERE\n         LB    R4,SEARCH_SYSID_COUNT HERE'S HOW MANY\nFILTER_SYSID_LOOP DS 0H\n         CLC   0(8,R3),MDBGOSNM     DOES IT MATCH?\n         JE    FILTER_MDBSCP        YES, CONTINUE\n         AHI   R3,8                 NEXT SYSID IN LIST\n         JCT   R4,FILTER_SYSID_LOOP LOOP IF MORE\n         J     FILTER_RECORD_RETURN NO MATCH, DON'T BOTHER WITH REST\n         DROP  R9\n*\nFILTER_MDBSCP DS 0H\n         AH    R9,0(R9)            ADD MDBGLEN TO POINT AT MDBSCP\n         SH    R8,0(R9)            SUBTRACT MDBC LENGTH FROM TOTAL\n*\n         USING MDBSCP,R9\n         LB    R3,SEARCH_JOBNAME_L GET LENGTH OF JOBNAME\n         LTR   R3,R3               JOBNAME PRESENT?\n         JZ    FILTER_JOBID        NO, SKIP THIS\n         AHI   R3,-1\n         EX    R3,FILTER_COMPARE_JOBNAME_1\n         JE    FILTER_JOBID        MATCHES, CONTINUE\n         EX    R3,FILTER_COMPARE_JOBNAME_2\n         JE    FILTER_JOBID        MATCHES, CONTINUE\n         J     FILTER_RECORD_RETURN NO MATCH, SKIP IT\n*\nFILTER_JOBID DS 0H\n         TM    SEARCH_JOBID,X'BF'  JOBID PRESENT?\n         JZ    FILTER_MDBT         NO, CONTINUE\n         CLC   SEARCH_JOBID,MDBCOJID YES - DOES IT MATCH?\n         JE    FILTER_MDBT          YES, CONTINUE\n         J     FILTER_RECORD_RETURN NO, DON'T BOTHER\n         DROP  R9\n*\nFILTER_MDBT DS 0H\n         CLI   TEXT_SPACE,X'00'    ANY TEXT TO LOOK FOR?\n         JNE   FILTER_SEARCH_TEXT  YES\n         OI    FOUND_FLAG,@FOUND   NO, SO MARK AS \"FOUND\"\n         J     FILTER_RECORD_RETURN\nFILTER_SEARCH_TEXT DS 0H\n         AH    R9,0(R9)            ADD MDBCLEN TO POINT AT MDBT\n         OI    FLAGS,@1STSEG       INDICATE 1ST SEGMENT OF MSG\n* NOW R9 POINTS AT MDBT, R8 HAS REMAINING LENGTH OF RECORD\nFILTER_SEGMENT_LOOP DS 0H\n         STM   R8,R9,R8_R9_FILTER  SAVE R8 AND R9, JUST IN CASE\n         JAS   R14,SEARCH_TEXT     SEARCH FOR MATCHING TEXT\n         LM    R8,R9,R8_R9_FILTER  RESTORE R8 AND R9\n         TM    FOUND_FLAG,@FOUND   FOUND?\n         JO    FILTER_RECORD_RETURN YES, NO NEED TO SEARCH FURTHER\n         SH    R8,0(R9)            REMAINING LENGTH IN RECORD\n         JNP   FILTER_RECORD_RETURN ALL DONE\n         AH    R9,0(R9)            POINT TO NEXT MDBT SEGMENT\n         CH    R8,0(R9)            IS IT A \"SHORT\" MDBT?            RH4\n         JNL   FILTER_NORMAL_MDBT  NO, NORMAL ONE                   RH4\n         CHI   R8,MDBTMBOB         YES - ANY TEXT IN IT?            RH4\n         JNH   FILTER_RECORD_RETURN NO, JUST SKIP IT                RH4\n         STH   R8,0(R9)            YES, SET \"NEW\" MDBTLEN           RH4\nFILTER_NORMAL_MDBT DS 0H                                            RH4\n         NI    FLAGS,255-@1STSEG   INDICATE NOT 1ST SEGMENT ANY MORE\n         J     FILTER_SEGMENT_LOOP MORE TO DO\n*\nFILTER_RECORD_RETURN DS 0H\n         L     R14,R14_FILTER_RECORD\n         BR    R14\n*----------------------------------------------------------------------\n*\n* SEARCH_TEXT - SEARCH THE MESSAGE SEGMENT FOR TARGET TEXT\n* R9 HAS ADDRESS OF AN MDBT SEGMENT\n*\nSEARCH_TEXT  DS 0H\n         ST    R14,R14_SEARCH_TEXT\n         USING MDBT,R9              ADRESSABILITY\n*\n         LA    R2,TEXT_SPACE        START AT THE BEGINNING\n         XR    R3,R3\nSEARCH_TEXT_LOOP DS 0H\n         IC    R3,0(R2)             LENGTH OF THIS TEXT\n         N     R3,F_X_7F            MAKE SURE HOB IS OFF\n         LTR   R3,R3                ANYTHING HERE?\n         JZ    SEARCH_TEXT_RETURN   NO\n         LA    R4,MDBTMSGT          POINT AT MSG TEXT\n* GET LENGTH OF TARGET. IF TOO SHORT, JUST LEAVE\n         LH    R5,MDBTLEN           LENGTH OF WHOLE SEGMENT\n         AHI   R5,MDBTMBOB*-1       SUBTRACT HEADER TO GET MSG LENGTH\n         SR    R5,R3                AND WE DON'T NEED TO LOOK PAST END\n         JM    TEXT_COMPARE_NEXT    TOO LONG, DON'T BOTHER\n         AHI   R5,1                 COUNTER IS DIFFERENCE + 1\n         AHI   R3,-1                DECREMENT COMPARE LENGTH\n*\n         TM    0(R2),@MSGID_ONLY   MSGID FORM OF TEXT?\n         JNO   TEXT_COMPARE_LOOP    NO, COUNT IS SET FOR TEXT COMPARE\n* SEARCH 1ST SEGMENT ONLY FOR MSGID\n         TM    FLAGS,@1STSEG        MSGID - 1ST SEGMENT OF MESSAGE?\n         JNO   TEXT_COMPARE_NEXT    NO, NO NEED TO SEARCH FOR THIS\n         CHI   R5,3                 ALREADY A SHORT LOOP?\n         JNH   TEXT_COMPARE_LOOP    YES\n         LA    R5,3                 NO, ONLY SEARCH 1ST 3 POSITIONS\n*\nTEXT_COMPARE_LOOP DS 0H\n         EX    R3,TEXT_COMPARE      IS THE TEXT HERE?\n         JE    TEXT_FOUND           YES\n         AHI   R4,1                 ADVANCE ONE CHAR\n         JCT   R5,TEXT_COMPARE_LOOP KEEP LOOKING\nTEXT_COMPARE_NEXT DS 0H\n         LA    R2,2(R3,R2)          ADDRESS NEXT SPOT IN TABLE\n         J     SEARCH_TEXT_LOOP     LOOK SOME MORE\nTEXT_FOUND DS 0H\n         OI    FOUND_FLAG,@FOUND    INDICATE A HIT\n*\nSEARCH_TEXT_RETURN DS 0H\n         L     R14,R14_SEARCH_TEXT\n         BR    R14\n         DROP  R9\n*----------------------------------------------------------------------\n*\n* PRINT RECORD - FORMAT AND OUTPUT THE RECORD\n* R9 HAS ADDRESS OF RECORD\n*\nWRITE_RECORD DS 0H\n         ST    R14,R14_WRITE_RECORD\n*\n         USING MDB,R9\n         LA    R8,LOGOUT_SPACE     ADDRESS OUTPUT RECORD\n         USING HCL,R8\n         LH    R2,MDBLEN           LENGTH OF RECORD (MDBLEN) IN R2\n         DROP  R9\n*\n* PROCESS MDBG PART OF INPUT RECORD\n*\n         LA    R9,MDBHLEN(,R9)     POINT R9 PAST MDB AT MDBG\n         USING MDBG,R9\n         AHI   R2,MDBHLEN*-1       HOW MUCH LEFT IN RECORD\n         CLEAR LOGOUT_SPACE        CLEAR OUTPUT RECORD\n         LA    R1,HCLHEADL+4       PRIME RECORD LEN + RDW LEN\n         STH   R1,LOGOUT_RECLEN\n         XC    LOGOUT_BLKLEN,LOGOUT_BLKLEN AND RDW\n*\n         MVC   HCLTIME,MDBGTIMH    MOVE TIME HH.MM.SS.TH\n         MVC   HCLDATE,MDBGDSTP+2  MOVE (YY)YYDDD LAST 5 CHARS\n         MVC   HCLSYSID,MDBGOSNM   SYSTEM NAME\n         MVC   JOBNAME,MDBGJBNM    SAVE JOBNAME FOR LATER\n*\n         CLC   BUFFER_RECORD_NO,F1 1ST RECORD IN BUFFER?\n         JH    GOT_MLID            IF NOT, ALREADY HAVE MLID\n         ICM   R15,B'0111',MDBGSEQ MESSAGE SEQUENCE NUMBER\n         CVD   R15,QWORD           CONVERT TO DECIMAL\n         UNPK  MLID,QWORD          SAVE LOW 3 DIGITS AS EBCDIC\n         OI    MLID+2,C'0'         MAKE IT PRINTABLE\nGOT_MLID DS 0H\n*\n* PROCESS MDBSCP PART OF INPUT RECORD\n*\n         SH    R2,MDBGLEN          KEEP REMAINING LENGTH CURRENT\n         AH    R9,MDBGLEN          POINT AT MDBSCP\n         DROP  R9\n         USING MDBSCP,R9           ADDRESS MDBSCP\n* TRANSLATE 1ST 28 ROUTING CODES TO DISPLAYABLE FORMAT\n         UNPK  QWORD(9),MDBCERC(5) UNPACK FIRST 28 ROUTING CODES\n         TR    QWORD(7),HEX_TRANSLATE MAKE THEM PRINTABLE\n         MVC   HCLROUTC,QWORD      MOVE INTO RECORD\n* TRANSLATE USER EXIT/MPF FLAGS TO DISPLAYABLE FORMAT\n         UNPK  QWORD(9),MDBCXMOD(5) UNPACK REQUEST FLAGS\n         TR    QWORD(8),HEX_TRANSLATE MAKE THEM PRINTABLE\n         MVC   REQUEST_FLAGS,QWORD SAVE COPY FOR MULTI-LINE MSG\n         MVC   HCLREQFL,QWORD      MOVE INTO RECORD\n* FIGURE OUT RECORD ID\n         MVI   HCLRECTP,HCLMLWTO   ASSUME A MULTILINE MSG\n         CLC   MDBCLCNT,F1         SEE IF MORE THAN ONE LINE\n         JH    DONE_WITH_RECID     OK IF SO\n         MVI   HCLRECTP,HCLWTO     MAKE IT A SINGLE LINE MESSAGE\n         TM    MDBMLVL1,MDBMLR     IS IT A WTOR?\n         JNO   DONE_WITH_RECID     NO, OK\n         MVI   HCLRECTP,HCLWTOR    MAKE IT A WTOR\nDONE_WITH_RECID DS 0H\n* FIGURE OUT RECORD TYPE\n         TM    MDBCMSC2,MDBCOCMD   IS IT AN OPERATOR CMD ECHO?\n         JNO   NOT_OP_COMMAND      NO, TRY NEXT\n         MVI   HCLREQTP,HCLCMD     YES, MARK AS OPERATOR COMMAND\n         CLC   MDBCCNID,F0         IS IT AN INTERNAL CMD (CONID=0)?\n         JNE   DONE_WITH_RECTYPE   NO, SO HCLCMD IS OK\n         MVI   HCLREQTP,HCLINTNL   MARK IT AS INTERNAL COMMAND\n         J     DONE_WITH_RECTYPE\nNOT_OP_COMMAND DS 0H\n         TM    MDBCATT1,MDBCMCSC   IS IT A COMMAND RESPONSE?\n         JO    MARK_AS_RESPONSE    YES, MARK IT SO\n         TM    MDBDESC1,MDBDESCE   IS IT DESC=5 (ALSO CMD RESP)\n         JNO   DONE_WITH_RECTYPE   NO, NOT CMD RESPONSE\nMARK_AS_RESPONSE DS 0H\n         MVI   HCLREQTP,HCLRESP   MARK IT AS COMMAND RESPONSE\nDONE_WITH_RECTYPE DS 0H\n         MVC   REQUEST_TYPE,HCLREQTP SAVE FOR MULTI-LINE\n* NOW FIGURE OUT WHAT CONSOLE NAME OR JOBNAME TO USE\n* SHAMELESSLY LIFTED FROM THE IBM SAMPLE PROGRAM IEAMDBLG\n         CLI   HCLREQTP,HCLCMD     IS IT A COMMAND?\n         JNE   NOT_COMMAND         NO, TRY NEXT\n         CLC   MDBCCNID,F128       IS IT AN INSTREAM COMMAND?\n         JE    USE_CONSOLE_NAME    YES, USE CONSOLE NAME (INSTREAM)\n         CLC   JOBNAME,BLANK_8     IS JOBNAME BLANK?\n         JE    USE_CONSOLE_NAME    YES, USE CONSOLE NAME\n         J     CHECK_FOR_MCS_CONSOLE GO SEE IF IT'S AN MCS CONSOLE\nNOT_COMMAND DS 0H\n         CLI   HCLREQTP,HCLINTNL   IS IT AN INTERNAL COMMAND?\n         JNE   NOT_INTERNAL_CONSOLE_1 NO, TRY NEXT\n         CLC   JOBNAME,BLANK_8     IS JOBNAME BLANK?\n         JNE   USE_JOBNAME         NO, SO USE JOB NAME\n         MVI   HCLREQTP,HCLCMD     CHANGE REQUEST TYPE TO \"COMMAND\"\n         J     USE_CONSOLE_NAME    USE CONSOLE NAME (INTERNAL)\nNOT_INTERNAL_CONSOLE_1 DS 0H\n         CLI   HCLREQTP,HCLRESP    IS IT A COMMAND RESPONSE?\n         JNE   USE_JOBNAME         NO, SO USE JOB NAME\n*        TM    MDBCMCSF,MDBMCSB+MDBMCSH WAS IT SENT BY CONSOLE ID   RH2\n         TM    MDBCMCSF,MDBMCSB    WAS IT SENT BY CONSOLE ID IN R0  RH2\n         JZ    USE_JOBNAME         NO, USE JOB NAME\n         CLC   JOBNAME,BLANK_8     IS JOBNAME BLANK?\n         JNE   USE_JOBNAME         NO, SO USE JOB NAME\n         CLC   MDBCCNID,F0         IS IT INTERNAL?\n         JE    USE_CONSOLE_NAME    YES, USE CONSOLE NAME (INTERNAL)\n         CLC   MDBCCNID,F128       IS IT INSTREAM?\n         JE    USE_CONSOLE_NAME    YES, USE CONSOLE NAME (INSTREAM)\nCHECK_FOR_MCS_CONSOLE DS 0H\n         CLI   MDBCCNID,X'00'      IS CONSOLE CLASS ZERO (MCS)?\n         JE    USE_JOBNAME         YES, USE JOB NAME\n         TM    MDBCCNID,X'E0'      IS CONSOLE CLASS A JES3 CONSOLE?\n         JNZ   USE_JOBNAME         YES, SO USE JOB NAME\nUSE_CONSOLE_NAME DS 0H\n         MVC   HCLCONID,MDBCCNNM   MOVE IN CONSOLE NAME FROM MDB\n         CLC   MDBCCNID,F0         IS IT \"INTERNAL\"?\n         JNE   NOT_INTERNAL_CONSOLE_2 NO, OK\n         MVC   HCLCONID,C_INTERNAL MOVE IN \"INTERNAL\"\n         J     DONE_WITH_CONSOLE\nNOT_INTERNAL_CONSOLE_2 DS 0H\n         CLC   MDBCCNID,F128       IS IT \"INSTREAM\"?\n         JNE   DONE_WITH_CONSOLE   NO, OK\n         MVC   HCLCONID,C_INSTREAM MOVE IN \"INSTREAM\"\n         J     DONE_WITH_CONSOLE   DONE WITH JOB/CONSOLE FIELD\nUSE_JOBNAME DS 0H\n         MVC   HCLJOBID,JOBNAME    MOVE IN JOB NAME\n*\nDONE_WITH_CONSOLE DS 0H\n* SEE IF WE NEED TO ADD MLID AT END OF MESSAGE\n         NI    FLAGS,255-@APPEND_MLID TURN OFF \"APPEND MLID\" FLAG\n         CLI   HCLRECTP,HCLMLWTO   MULTI-LINE MESSAGE?\n         JNE   MLID_NOT_NEEDED     NOPE, NO MLID NEEDED\n         TM    MDBDESC2,MDBDESCI   YES - OPERATOR REQUEST?\n         JNO   SET_MLID_FLAG       NO, GO APPEND MLID\n         CLC   BUFFER_RECORD_NO,F1 1ST OF MULTIPLE RECORDS?\n         JH    MLID_NOT_NEEDED     NO, ALREADY HAVE MLID\n         LR    R1,R9               GET POINTER...\n         AH    R1,MDBCLEN          ...TO TEXT SEGMENT...\n         AH    R1,0(R1)            ...AND POINT TO END OF THAT\n         CHI   R1,3                LAST 3 CHARS OF TEXT\n         MVC   MLID,0(R1)          SAVE THAT AS MLID IN THIS CASE\n         J     MLID_NOT_NEEDED     AND CONTINUE\nSET_MLID_FLAG DS 0H\n         OI    FLAGS,@APPEND_MLID  FLAG TO ADD MLID NOW\nMLID_NOT_NEEDED DS 0H\n*\n* PROCESS MDBT PART OF INPUT RECORD\n*\n         SH    R2,MDBCLEN          KEEP REMAINING LENGTH CURRENT\n         AH    R9,MDBCLEN          POINT AT MDBT\n         J     WRITE_SEGMENT       REC TYPE ALREADY DONE FOR 1ST REC\n         DROP  R9\n*\n         USING MDBT,R9\nMULTI_LINE_SEGMENT DS 0H\n         MVC   HCLMLID,MLID        MULTI-LINE MESSAGE ID\n         MVC   HCLREQTP,REQUEST_TYPE REQUEST TYPE\n         MVC   HCLREQFL,REQUEST_FLAGS INIT REQUEST FLAGS\n         TM    MDBTLNT1,MDBTLABT   LABEL TEXT TYPE?\n         JNO   TEXT_NOT_LABEL\n         MVI   HCLRECTP,HCLLABEL   YES, MARK IT AS SUCH\nTEXT_NOT_LABEL DS 0H\n         TM    MDBTLNT1,MDBTDATT   DATA TEXT?\n         JNO   TEXT_NOT_DATA\n         MVI   HCLRECTP,HCLDATA    YES, MARK IT AS SUCH\nTEXT_NOT_DATA  DS 0H\n         TM    MDBTLNT1,MDBTENDT   END TEXT?\n         JNO   WRITE_SEGMENT\n         MVI   HCLRECTP,HCLDTEND   YES, MARK IT AS SUCH\nWRITE_SEGMENT  DS 0H\n*\n         LH    R3,MDBTLEN          LENGTH OF WHOLE TEXT SEGMENT\n         AHI   R3,MDBTMBOB*-1      COMPUTE LENGTH OF TEXT PART\n         LR    R1,R3               SAVE TEXT LENGTH IN R1\n         AHI   R3,-1               DECREMENT FOR EXECUTE\n         EX    R3,MOVE_RECORD\n         TM    FLAGS,@APPEND_MLID  APPEND MLID?\n         JNO   NO_MLID_NEEDED      NO\n         LA    R3,HCLTEXT+1(R3)    POINT AT END OF MESSAGE\n         MVI   0(R3),C' '          BLANK\n         MVC   1(3,R3),MLID        ATTACH THE MLID NUMBER\n         AHI   R1,4                ACCOUNT FOR EXTRA LENGTH\nNO_MLID_NEEDED DS 0H\n         NI    FLAGS,255-@APPEND_MLID TURN OFF THE FLAG\n         AH    R1,LOGOUT_RECLEN    ADD IN CURRENT RECLEN\n         STH   R1,LOGOUT_RECLEN    UPDATE RDW\n         PUT   (R10),LOGOUT_RECORD\n         SH    R2,MDBTLEN          SUBTRACT TEXT SEGMENT LENGTH\n         JNP   WRITE_RECORD_RETURN IF ALL DONE, JUMP\n         AH    R9,MDBTLEN          NOT DONE, POINT TO NEXT SEGMENT\n         CH    R2,MDBTLEN          IS IT A \"SHORT\" MDBT?            RH4\n         JNL   WRITE_NORMAL_MDBT   NO, NORMAL ONE                   RH4\n         CHI   R2,MDBTMBOB         YES - ANY TEXT IN IT?            RH4\n         JNH   WRITE_RECORD_RETURN NO, JUST SKIP IT                 RH4\n         STH   R2,MDBTLEN          YES, SET \"NEW\" MDBTLEN           RH4\nWRITE_NORMAL_MDBT DS 0H                                             RH4\n         CLEAR LOGOUT_SPACE        CLEAR OUTPUT RECORD\n         LA    R1,HCLHEADL+4       PRIME RECORD LEN + RDW LEN\n         STH   R1,LOGOUT_RECLEN\n         J     MULTI_LINE_SEGMENT LOOP, DO NEXT SEGMENT\n*\nWRITE_RECORD_RETURN DS 0H\n         L     R14,R14_WRITE_RECORD\n         BR    R14\n         DROP  R9\n         DROP  R8\n*----------------------------------------------------------------------\n*\n* CLEANUP ROUTINE(S)\n*\nCLEANUP  DS 0H\n         ST    R14,R14_CLEANUP\n*\n         JAS   R14,CLOSE_FILES\n*\n         CLC   MAIN_RC,F0             RETURN CODE ZERO SO FAR?\n         JNE   CLEANUP_RETURN         IF NOT ZERO, JUST LEAVE\n         TM    FLAGS,@GOT_A_HIT       YES, BUT DID WE FIND ANYTHING?\n         JO    CLEANUP_RETURN         YES, LEAVE IT AT ZERO\n         MVC   MAIN_RC,F1             NO, NOTHING FOUND.  RC=1\n*\nCLEANUP_RETURN DS   0H\n         L     R14,R14_CLEANUP\n         BR    R14\n*----------------------------------------------------------------------\n*\n* OPEN FILES\n*\nOPEN_FILES DS 0H\n         ST    R14,R14_OPEN_FILES\n*\n         MVC   OPEN(OPEN_MACRO_L),OPEN_MACRO\n*\n         MVC   LOGIN(LOGIN_DCB_L),LOGIN_DCB\n         LA    R11,LOGIN\n         OPEN  ((R11),(INPUT)),MF=(E,OPEN)\n*\n         MVC   LOGOUT(LOGOUT_DCB_L),LOGOUT_DCB\n         LA    R10,LOGOUT\n         OPEN  ((R10),(OUTPUT)),MF=(E,OPEN)\n*\n         MVC   SYSIN(SYSIN_DCB_L),SYSIN_DCB\n         LA    R9,SYSIN\n         OPEN  ((R9),(INPUT)),MF=(E,OPEN)\n*\n         L     R14,R14_OPEN_FILES\n         BR    R14\n*----------------------------------------------------------------------\n*\n* CLOSE FILES\n*\nCLOSE_FILES DS 0H\n         ST    R14,R14_CLOSE_FILES\n*\n         MVC   CLOSE(CLOSE_MACRO_L),CLOSE_MACRO\n*\n         LA    R11,LOGIN\n         CLOSE ((R11)),MF=(E,CLOSE) LOGIN\n*\n         LA    R10,LOGOUT\n         CLOSE ((R10)),MF=(E,CLOSE) LOGOUT\n*\n         LA    R9,SYSIN\n         CLOSE ((R9)),MF=(E,CLOSE) SYSIN\n*\n         L     R14,R14_CLOSE_FILES\n         BR    R14\n*----------------------------------------------------------------------\n*\n* READ SYSIN\n*\nREAD_SYSIN DS 0H\n         ST    R14,R14_READ_SYSIN\n*\n         LA    R9,SYSIN\n         USING IHADCB,R9\n         TM    DCBOFLGS,DCBOFOPN   WAS OPEN OK?\n         JNO   READ_SYSIN_RETURN   NO, SKIP THIS\n*\nSYSIN_LOOP DS 0H\n         GET   (R9)                READ A SYSIN RECORD\n         LR    R4,R1               POINT R4 AT IT\n         LR    R6,R4               SAVE ALSO IN R6\n         CLI   0(R4),C'*'          COMMENT?\n         JE    SYSIN_LOOP          YES, SKIP IT\n* LOOK FOR \"TEXT=\"\n         LH    R5,DCBLRECL         NO, GET LENGTH OF RECORD\n         LA    R2,KEYWORD_TEXT     ADDRESS OF TEXT KEYWORD\n         LA    R3,L'KEYWORD_TEXT   SET LENGTH\n         JAS   R14,FIND_KEYWORD    GO SCAN FOR IT\n         LTR   R4,R4               FOUND IT?\n         JNZ   SYSIN_FOUND_TEXT    YES, GO GRAB TEXT\n* LOOK FOR \"MSGID=\"\n         LR    R4,R6               POINT R4 AT RECORD AGAIN\n         LH    R5,DCBLRECL         GET LENGTH OF RECORD AGAIN\n         LA    R2,KEYWORD_MSGID    ADDRESS OF MSGID KEYWORD\n         LA    R3,L'KEYWORD_MSGID  SET LENGTH\n         JAS   R14,FIND_KEYWORD    GO SCAN FOR IT\n         LTR   R4,R4               FOUND IT?\n         JNZ   SYSIN_FOUND_MSGID   YES, GO GRAB TEXT\n* LOOK FOR \"FIND=\"\n         LR    R4,R6               POINT R4 AT RECORD AGAIN\n         LH    R5,DCBLRECL         GET LENGTH OF RECORD AGAIN\n         LA    R2,KEYWORD_FIND     ADDRESS OF FIND= KEYWORD\n         LA    R3,L'KEYWORD_FIND   SET LENGTH\n         JAS   R14,FIND_KEYWORD    GO SCAN FOR IT\n         LTR   R4,R4               FOUND IT?\n         JNZ   SYSIN_FOUND_FIND    YES, GO DECODE IT\n* LOOK FOR \"JOBNAME=\"\n         LR    R4,R6               POINT R4 AT RECORD AGAIN\n         LH    R5,DCBLRECL         GET LENGTH OF RECORD AGAIN\n         LA    R2,KEYWORD_JOBNAME  ADDRESS OF JOBNAME= KEYWORD\n         LA    R3,L'KEYWORD_JOBNAME SET LENGTH\n         JAS   R14,FIND_KEYWORD    GO SCAN FOR IT\n         LTR   R4,R4               FOUND IT?\n         JNZ   SYSIN_FOUND_JOBNAME YES, GO HANDLE IT\n* LOOK FOR \"JOBID=\"\n         LR    R4,R6               POINT R4 AT RECORD AGAIN\n         LH    R5,DCBLRECL         GET LENGTH OF RECORD AGAIN\n         LA    R2,KEYWORD_JOBID    ADDRESS OF JOBID= KEYWORD\n         LA    R3,L'KEYWORD_JOBID  SET LENGTH\n         JAS   R14,FIND_KEYWORD    GO SCAN FOR IT\n         LTR   R4,R4               FOUND IT?\n         JNZ   SYSIN_FOUND_JOBID   YES, GO HANDLE IT\n* LOOK FOR \"SYSID=\"\n         LR    R4,R6               POINT R4 AT RECORD AGAIN\n         LH    R5,DCBLRECL         GET LENGTH OF RECORD AGAIN\n         LA    R2,KEYWORD_SYSID    ADDRESS OF SYSID= KEYWORD\n         LA    R3,L'KEYWORD_SYSID  SET LENGTH\n         JAS   R14,FIND_KEYWORD    GO SCAN FOR IT\n         LTR   R4,R4               FOUND IT?\n         JNZ   SYSIN_FOUND_SYSID   YES, GO HANDLE IT\n*\n         J     SYSIN_LOOP          DON'T KNOW, IGNORE IT\n*\nSYSIN_FOUND_JOBNAME DS 0H\n         LR    R5,R4               SAVE STARTING POINT\n         LA    R2,8                MAX LENGTH OF A JOBNAME\n         XR    R3,R3               CURRENT JOBNAME LENGTH\nSYSIN_FOUND_JOBNAME_LOOP DS 0H\n         CLI   0(R4),C' '          END OF JOBNAME FOUND?\n         JE    SYSIN_FOUND_JOBNAME_END YES\n         AHI   R4,1                NEXT CHAR\n         AHI   R3,1                ADD 1 TO LENGTH\n         JCT   R2,SYSIN_FOUND_JOBNAME_LOOP\nSYSIN_FOUND_JOBNAME_END DS 0H\n         LTR   R3,R3               ANYTHING THERE?\n         JNP   SYSIN_LOOP          NO, DON'T BOTHER\n         STC   R3,SEARCH_JOBNAME_L SAVE LENGTH\n         AHI   R3,-1\n         EX    R3,SYSIN_MOVE_JOBNAME MOVE JOBNAME\n         J     SYSIN_LOOP          NEXT CARD\n*\nSYSIN_FOUND_JOBID   DS 0H\n         MVC   SEARCH_JOBID,0(R4)  SAVE SEARCH-FOR JOBID\n         J     SYSIN_LOOP          NEXT CARD\n*\nSYSIN_FOUND_SYSID   DS 0H\n         XR    R5,R5\n         IC    R5,SEARCH_SYSID_COUNT GET CURRENT COUNT\n         AHI   R5,1                ADD ONE\n         CHI   R5,MAX_SYSIDS       TOO MANY?\n         JH    SYSIN_ERROR_12      YES, ERROR\n         STC   R5,SEARCH_SYSID_COUNT SAVE NEW COUNT\n         AHI   R5,-1               NOW USE PREVIOUS COUNT\n         MHI   R5,8                TO COMPUTE TABLE OFFSET\n         LA    R3,SEARCH_SYSID     START OF SYSID TABLE\n         AR    R3,R5               ADD OFFSET TO ADDRESS NEXT SLOT\n         MVC   0(8,R3),0(R4)       SAVE THIS SEARCH-FOR SYSID\n         J     SYSIN_LOOP          NEXT CARD\n*\nSYSIN_FOUND_FIND DS 0H\n* LOOK FOR \"FIND=EXCLUDE\".  SET FLAG_INC_EXC SO THAT XOR WITH\n* FOUND_FLAG REVERSES IT IF EXCLUDE WAS SPECIFIED.\n         CLC   0(L'KEYWORD_EXCLUDE,R4),KEYWORD_EXCLUDE FIND=EXCLUDE?\n         JE    SYSIN_FOUND_EXCLUDE YES\n* LOOK FOR \"FIND=QUIT\"\".  SET FLAG IF SO.                           RH1\n         CLC   0(L'C_QUIT,R4),C_QUIT FIND=QUIT?                     RH1\n         JE    SYSIN_FOUND_QUIT    YES                              RH1\n*                                                                   RH1\n         NI    FLAG_INC_EXC,255-@FOUND NO, ASSUME TYPE=INCLUDE\n         J     SYSIN_LOOP          CONTINUE\nSYSIN_FOUND_EXCLUDE DS 0H\n         OI    FLAG_INC_EXC,@FOUND TYPE=EXCLUDE\n         J     SYSIN_LOOP          CONTINUE\n*                                                                   RH1\nSYSIN_FOUND_QUIT DS 0H                                              RH1\n         OI    FLAGS,@FIND_QUIT    FIND=QUIT                        RH1\n         J     SYSIN_LOOP          CONTINUE                         RH1\n*\nSYSIN_FOUND_TEXT DS 0H             FOUND \"TEXT=\" FORM OF KEYWORD\n         NI    FLAGS,255-@MSGKWD   TURN OFF MSGID KEYWORD FLAG\n         J     SYSIN_GRAB_TEXT     NOW GO EXTRACT TEXT\nSYSIN_FOUND_MSGID DS 0H            FOUND \"MSGID=\" FORM OF KEYWORD\n         OI    FLAGS,@MSGKWD       TURN ON MSGID KEYWORD FLAG\n         J     SYSIN_GRAB_TEXT     NOW GO EXTRACT TEXT\nSYSIN_GRAB_TEXT DS 0H\n* FOUND \"TEXT=\" OR \"MSGID=\" KEYWORD\n         LR    R5,R6               1ST BYTE OF RECORD\n         AH    R5,DCBLRECL         ADD LENGTH\n         AHI   R5,-1               POINT R5 AT LAST BYTE OF RECORD\n         CR    R4,R5               ARE WE \"IN BOUNDS\"?\n         JNL   SYSIN_ERROR_8       NO, SOME KIND OF ERROR\n         MVC   TEXT_DELIMITER,0(R4) SAVE DELIMITER\n         AHI   R4,1                1ST CHAR OF TEXT ITSELF\n         SR    R5,R4               LENGTH LEFT ON CARD\n         JNP   SYSIN_ERROR_8       ERROR IF AT END NOW\n         LR    R2,R4               SAVE 1ST BYTE IN R2\n         XR    R3,R3               LENGTH IN R3\nSYSIN_TEXT_LOOP DS 0H\n         CLC   0(1,R4),TEXT_DELIMITER FOUND END DELIMITER YET?\n         JE    SYSIN_TEXT_FOUND    YES, LEAVE LOOP\n         AHI   R4,1                NO, NEXT CHAR\n         AHI   R3,1                ADD 1 TO LENGTH\n         JCT   R5,SYSIN_TEXT_LOOP  KEEP LOOKING\n         J     SYSIN_ERROR_8       ERROR IF NOT FOUND\nSYSIN_TEXT_FOUND DS 0H\n         LTR   R3,R3               IS THERE A LENGTH?\n         JZ    SYSIN_ERROR_8       NO, THAT'S AN ERROR\n* FIND NEXT AVAILABLE SLOT IN TEXT_SPACE\n         LA    R4,TEXT_SPACE       WHERE TO START\n         XR    R5,R5\nSYSIN_FIND_TEXT_SLOT DS 0H\n         CLI   0(R4),X'00'         OPEN SPOT HERE?\n         JE    SYSIN_ADD_TEXT      YES, GO\n         IC    R5,0(R4)            LENGTH OF THIS ENTRY\n         N     R5,F_X_7F           TURN OFF HOB\n         LA    R4,1(R4,R5)         POINT R4 AT NEXT SLOT\n         LA    R1,BUFFER_SPACE     \"OUT OF SPACE\" ADDRESS\n         CR    R4,R1               GONE TOO FAR?\n         JNL   SYSIN_ERROR_12      YES, ERROR\n         J     SYSIN_FIND_TEXT_SLOT NO, CONTINUE\nSYSIN_ADD_TEXT DS 0H\n         LR    R5,R4               NEW SPOT ADDRESS\n         LA    R5,1(R3,R5)         ADD LENGTH OF NEW ENTRY + 1\n         LA    R1,BUFFER_SPACE     \"OUT OF SPACE\" ADDRESS\n         CR    R5,R1               WOULD WE GO OUT-OF-BOUNDS?\n         JNL   SYSIN_ERROR_12      YES, THAT WOULD BE AN ERROR\n         CH    R3,MAX_TEXT_LENGTH  TOO BIG?\n         JH    SYSIN_ERROR_8       YES, THAT WOULD BE AN ERROR TOO\n         STC   R3,0(R4)            SAVE IT\n         TM    FLAGS,@MSGKWD       WAS IT MSGID= FORM?\n         JNO   SYSIN_ADD_TEXT_2    NO\n         OI    0(R4),@MSGID_ONLY   YES, SET HIGH-ORDER BIT\n         NI    FLAGS,255-@MSGKWD   TURN OFF FLAG\nSYSIN_ADD_TEXT_2 DS 0H\n         AHI   R3,-1               LENGTH - 1 FOR EXECUTE\n         EX    R3,SYSIN_MOVE_TEXT  MOVE IT IN\n*\n         J     SYSIN_LOOP         GO TRY FOR ANOTHER RECORD\n*\nSYSIN_ERROR_8 DS 0H\n         MVC   MAIN_RC,F8         RETURN CODE 8\n         J     READ_SYSIN_RETURN\nSYSIN_ERROR_12 DS 0H\n         MVC   MAIN_RC,F12        RETURN CODE 12\n         J     READ_SYSIN_RETURN\nSYSIN_EOF DS 0H\n*\nREAD_SYSIN_RETURN DS 0H\n         L     R14,R14_READ_SYSIN\n         BR    R14\n         DROP  R9\n*----------------------------------------------------------------------\n*\n* FIND_KEYWORD ROUTINE - SCAN FOR A GIVEN KEYWORD\n*\n* INPUT R2 - INPUT KEYWORD\n*       R3 - INPUT KEYWORD LENGTH\n*       R4 - INPUT STRING\n*       R5 - INPUT STRING LENGTH\n* OUTPUT - R4 HAS ADDRESS OF 1ST BYTE PAST THE KEYWORD, OR 0 IF\n*          NOT FOUND\nFIND_KEYWORD DS 0H\n         ST    R14,R14_FIND_KEYWORD\n*SCAN FOR KEYWORD\n         SR    R5,R3               DON'T WANT SEARCH PAST END OF INPUT\n         AHI   R5,1                IN CASE LENGTHS WERE EQUAL\n         LTR   R5,R5               NOW - ANYTHING TO LOOK FOR?\n         JNP   FIND_KEYWORD_NOT_FOUND TOO SHORT, DON'T BOTHER\n         AHI   R3,-1               DECREMENT KW LENGTH FOR EXECUTE\nFIND_KEYWORD_FIND_KEY DS 0H\n         EX    R3,FIND_KEYWORD_CLC FOUND KEYWORD?\n         JE    FIND_KEYWORD_FOUND_KEY YES\n         AHI   R4,1                NEXT CHAR IN INPUT STRING\n         JCT   R5,FIND_KEYWORD_FIND_KEY KEEP LOOKING\nFIND_KEYWORD_NOT_FOUND DS 0H\n         XR    R4,R4               INDICATE NOT FOUND\n         J     FIND_KEYWORD_DONE   LEAVE\nFIND_KEYWORD_FOUND_KEY DS 0H\n         LA    R4,1(R3,R4)         POINT AT CHAR FOLLOWING\nFIND_KEYWORD_DONE DS 0H             EXIT\n         L     R14,R14_FIND_KEYWORD SET RETURN ADDRESS\n         BR    R14\n*----------------------------------------------------------------------\n*\n* CONSTANTS\n*\nCONSTANT_AREA DS 0D\n         LTORG\n*\n         USING MDBSCP,R9           ADDRESSABILITY FOR EXECUTED INST\nFILTER_COMPARE_JOBNAME_1 CLC SEARCH_JOBNAME(0),TEMP_MDBGJBNM\nFILTER_COMPARE_JOBNAME_2 CLC SEARCH_JOBNAME(0),MDBCOJBN\n         DROP  R9\n         USING HCL,R8\n         USING MDBT,R9\nMOVE_RECORD MVC HCLTEXT(0),MDBTMSGT\n         DROP  R8,R9\nSYSIN_MOVE_JOBNAME MVC SEARCH_JOBNAME(0),0(R5) SAVE SEARCH-FOR JOBNAME\nSYSIN_MOVE_TEXT MVC 1(0,R4),0(R2)\nFIND_KEYWORD_CLC CLC 0(0,R4),0(R2)  COMPARE FOR KEYWORD\nTEXT_COMPARE CLC 0(0,R4),1(R2)\n*\nOPEN_MACRO OPEN LOGIN_DCB,MF=L\nOPEN_MACRO_L EQU *-OPEN_MACRO\n*\nCLOSE_MACRO CLOSE LOGOUT_DCB,MF=L\nCLOSE_MACRO_L EQU *-CLOSE_MACRO\n*\nLOGIN_DCB   DCB   DDNAME=LOGIN,                                        X\n               MACRF=(GL),                                             X\n               RECFM=V,                                                X\n               EODAD=LOGIN_EOF,                                        X\n               DSORG=PS\nLOGIN_DCB_L EQU *-LOGIN_DCB\n*\nLOGOUT_DCB  DCB   DDNAME=LOGOUT,                                       X\n               MACRF=(PM),                                             X\n               RECFM=VB,                                               X\n               LRECL=259,                                              X\n               DSORG=PS\nLOGOUT_DCB_L EQU *-LOGOUT_DCB\n*\nSYSIN_DCB  DCB   DDNAME=SYSIN,                                         X\n               MACRF=(GL),                                             X\n               RECFM=FB,                                               X\n               DSORG=PS,                                               X\n               EODAD=SYSIN_EOF\nSYSIN_DCB_L    EQU *-SYSIN_DCB\n*\nHEX_TRANSLATE   EQU *-240\n                DC C'0123456789ABCDEF'\nMAX_TEXT_LENGTH DC H'127'          MAX LENGTH FOR TEXT SEARCH ITEM\n*\nKEYWORD_TEXT    DC C'TEXT='        TEXT= KEYWORD\nKEYWORD_MSGID   DC C'MSGID='       MSGID= KEYWORD\nKEYWORD_FIND    DC C'FIND='        FIND= KEYWORD\nKEYWORD_EXCLUDE DC C'EXCLUDE'\nKEYWORD_JOBNAME DC C'JOBNAME='\nKEYWORD_JOBID   DC C'JOBID='\nKEYWORD_SYSID   DC C'SYSID='\nC_QUIT          DC C'QUIT'                                          RH1\nC_INTERNAL      DC CL8'INTERNAL'\nC_INSTREAM      DC CL8'INSTREAM'\nBLANK_8  DC    CL8' '\nF0       DC    F'0'\nF1       DC    F'1'\nF8       DC    F'8'\nF12      DC    F'12'\nF128     DC    F'128'\nF_BUFFER_SIZE DC AL4(@BUFFER_SIZE)\nF_X_7F   DC    X'0000007F'\n*----------------------------------------------------------------------\n* DSECTS\n*----------------------------------------------------------------------\n* GENERAL WORK AREA\nWORKAREA DSECT\nRSA               DS 18F           REGISTER SAVE AREA\nR14_INITIALIZE    DS F             R14 SAVE AREA\nR14_PROCESS       DS F             R14 SAVE AREA\nR14_CLEANUP       DS F             R14 SAVE AREA\nR14_FIND_KEYWORD  DS F             R14 SAVE AREA\nR14_OPEN_FILES    DS F             R14 SAVE AREA\nR14_CLOSE_FILES   DS F             R14 SAVE AREA\nR14_FILTER_RECORD DS F             R14 SAVE AREA\nR8_R9_FILTER      DS 2F            REG SAVE AREA\nR14_WRITE_RECORD  DS F             R14 SAVE AREA\nR14_UNLOAD_BUFFER DS F             R14 SAVE AREA\nR8_R9_UNLOAD      DS 2F            REG SAVE AREA\nR14_ADD_TO_BUFFER DS F             R14 SAVE AREA\nR14_SEARCH_TEXT   DS F             R14 SAVE AREA\nR14_READ_SYSIN    DS F             R14 SAVE AREA\n*\nPARM_ADDRESS           DS F        ADDRESS OF PASSED PARM\nMAIN_RC                DS F        MAIN PROGRAM RETURN CODE\nQWORD                  DS 2D       GENERAL SCRATCH AREA\nCURRENT_RECORD_ID      DS F\nPREVIOUS_RECORD_ID     DS F\nCURRENT_RECORD_ADDRESS DS F\nREQUEST_FLAGS          DS CL8      REQUEST FLAGS FOR MULTI-LINE MSG\nJOBNAME                DS CL8      SAVE JOBNAME\nMLID                   DS CL3      MULTI-LINE MESSAGE ID\nREQUEST_TYPE           DS C        SAVE REQUEST TYPE FOR MULTI-LINE\nFLAGS                  DS X        PROGRAMS FLAGS\n@APPEND_MLID            EQU X'80'  ...APPEND MLID TO 1ST LINE OF MSG\n@MSGKWD                 EQU X'40'  ...MSGID= KEYWORD\n@1STSEG                 EQU X'20'  ...WE'RE IN 1ST MDBT SEGMENT OF MSG\n@GOT_A_HIT              EQU X'10'  ...WE FOUND AT LEAST ONE MATCH\n@FIND_QUIT              EQU X'08'  ...QUIT AFTER THE 1ST FIND       RH1\nFOUND_FLAG             DS X        PROGRAM FLAG FOR FIND ONLY\n@FOUND                  EQU X'80'  ...FOUND MSG OR TEXT\nFLAG_INC_EXC           DS X        FLAG FOR FLIPPING FOUND_FLAG\nTEXT_DELIMITER         DS C        \"TEXT=\" DELIMITER\nTEMP_MDBGJBNM          DS CL8\nSEARCH_JOBNAME_L       DS X        LENGTH OF SEARCH_JOBNAME\nSEARCH_JOBNAME         DS CL8      JOBNAME FROM SYSIN TO LOK FOR\nSEARCH_JOBID           DS CL8      JOBID FROM SYSIN TO LOK FOR\nMAX_SYSIDS             EQU 16      MAX NO. OF SYSIDS ALLOWED\nSEARCH_SYSID_COUNT     DS X        NO. OF SYSIDS IN FOLLOWING TABLE\nSEARCH_SYSID           DS (MAX_SYSIDS*8)C SYSIDS FROM SYSIN\n*\nOPEN     DS    (OPEN_MACRO_L)X     SPACE FOR OPEN PARMLIST\n*\nCLOSE    DS    (CLOSE_MACRO_L)X    SPACE FOR CLOSE PARMLIST\n*\nLOGIN    DS    (LOGIN_DCB_L)X      SPACE FOR LOGIN DCB\n*\nLOGOUT   DS    (LOGOUT_DCB_L)X     SPACE FOR LOGOUT DCB\n*\nSYSIN    DS    (SYSIN_DCB_L)X      SPACE FOR SYSIN DCB\n*\n* OUTPUT (HARDCOPY LOG FORMAT)\n*\nLOGOUT_RECORD DS 0F\nLOGOUT_RECLEN DS H                 RDW RECLEN\nLOGOUT_BLKLEN DS H                 RDW BLOCK\nLOGOUT_SPACE  DS CL256             STORAGE FOR \"HCL\" RECORD\nLOGOUT_SPACE_L EQU *-LOGOUT_SPACE\n*\nBUFFER_RECORD_NO DS F              CURRENT RECORD NUMBER IN BUFFER\nBUFFER_SIZE   DS F                 NUMBER OF BYTES IN USE\nBUFFER_COUNT  DS F                 COUNT OF RECORDS IN BUFFER\nBUFFER_NEXT   DS F                 POINTER TO NEXT AVAIL SPACE\n*\n* TEXT_SPACE CONTAINS THE MESSAGE TEXT TO FILTER ON.  FORMAT IS\n* 7 BIT LENGTH FOLLOWED BY TEXT.  IF HIGH-ORDER BIT OF LENGTH IS\n* ON, TEXT IS FOR MESSAGEID COMPARE ONLY.\n*\nTEXT_SPACE   DS 0C                 SPACE FOR SEARCH-FOR TEXT\n@MSGID_ONLY   EQU X'80'            FLAG IN LENGTH BYTE\n             ORG WORKAREA+4092     MOVE TO LAST ADDRESSIBLE WORD\n*\n* BUFFER AREA FOR INPUT RECORDS (OPERLOG FORMAT)\n*\nBUFFER_SPACE DS (@BUFFER_SIZE)X    ACTUAL BUFFER SPACE\n*\nWORKAREA_LEN EQU *-WORKAREA        TOTAL LENGTH OF WORKAREA\n*\n* EQUATES\n*\n@BUFFER_SIZE EQU @BUFFER_LRECL*@MAX_BUFFERS AMT OF INPUT BUFFER SPACE\n@BUFFER_LRECL EQU 32760            BUFFER LRECL                     RH4\n@MAX_BUFFERS EQU 64                MAX NO. OF BUFFER RECORDS        RH4\n@TEXT_SIZE   EQU BUFFER_SPACE-TEXT_SPACE\n*----------------------------------------------------------------------\n* MAPPING MACROS\n*\n         DCBD DSORG=PS\n*\n         IEAVM105\n*\n         IHAHCLOG\n*\n         END\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "AFCLOGSC": {"ttr": 1034, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00T\\x01\\x03\\x19\\x0f\\x01\\x086o\\x15 \\x00i\\x00a\\x00\\x00\\xd7\\xe2\\xf7\\xf2\\xf3\\xf1@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2003-07-09T00:00:00", "modifydate": "2008-12-31T15:20:54", "lines": 105, "newlines": 97, "modlines": 0, "user": "PS7231"}, "text": "//AFCLOGSC PROC FROM=START,        BOGUS TIMES TO CAUSE JCL ERROR\n//         TO=END                  IF NOT SPECIFIED\n//**********************************************************************\n//*\n//* SCAN Z/OS OPERLOG FOR TEXT STRINGS AND/OR MESSAGES\n//*\n//* PROC KEYWORDS:\n//*\n//*   FROM\n//*     STARTING DATE/TIME FOR THE SCAN.  MUST BE IN THE FORMAT\n//*     \"'YYYY/JJJ,HH:HH'\"\n//*   TO\n//*     ENDING DATE/TIME FOR THE SCAN.  MUST BE IN THE FORMAT\n//*     \"'YYYY/JJJ,HH:HH'\"\n//*\n//*     YYYY IS 4-DIGIT YEAR\n//*     JJJ  IS 3-DIGIT JULIAN DAY\n//*     HH   IS 2-DIGIT HOUR\n//*     MM   IS 2-DIGIT MINUTE\n//*\n//*     EXAMPLE:  '2002/212,14:35'\n//*\n//*   FROM AND TO ARE BOTH REQUIRED.  THE SHORTER THE TIME SPAN, THE\n//*   FASTER THE JOB WILL RUN.\n//*\n//*\n//* SYSIN PARAMETERS:\n//*\n//* JOBNAME=XXXXXXXX\n//*   LIMIT THE SEARCH TO RECORDS PRODUCED BY THIS JOBNAME\n//*\n//* JOBID=JOBXXXXX\n//*   LIMIT THE SEARCH TO RECORDS PRODUCED BY THIS JOBID\n//*\n//* JOBNAME AND JOBID ARE NOT GUARANTEED TO FIND EVERY MESSAGE\n//* RELATED TO THE SPECIFIED JOBNAME AND/OR JOBID.\n//*\n//* SYSID=XXXXXXXX\n//*   LIMIT THE SEARCH TO RECORDS PRODUCED FROM THIS SYSTEM (OR\n//*   SYSTEMS - UP TO 16, EACH SPECIFIED ON A SEPARATE SYSID= CARDS).\n//*\n//* NOTE THAT THE FOLLOWING TEXT AND MSGID KEYWORDS REFER TO \"SELECTED\"\n//* RECORDS.  THESE ARE RECORDS \"SELECTED\" BY ANY OF THE PRECEEDING\n//* KEYWORDS.  IF NONE OF THESE ARE SPECIFIED, \"SELECTED\" BECOMES ALL\n//* OPERLOG RECORDS IN THE JCL-CONTROLLED TIMESPAN.\n//*\n//* TEXT='TEXT YOU ARE LOOKING FOR'\n//*\n//*   THE FIRST CHARACTER AFTER THE \"=\" IS THE STRING DELIMITER AND IS\n//*   REQUIRED.  THIS CAN BE ANY CHARACTER, BUT MUST BE MATCHED AT THE\n//*   END.  MAXIMUM STRING LENGTH IS 127.  THE TEXT OF ALL SELECTED\n//*   MESSAGES (INCLUDING MULTI RECORD) WILL BE SCANNED FOR THIS TEXT.\n//*\n//* MSGID='MSGID YOU ARE LOOKING FOR'\n//*\n//*   THE FIRST CHARACTER AFTER THE \"=\" IS THE STRING DELIMITER AND IS\n//*   REQUIRED.  THIS CAN BE ANY CHARACTER, BUT MUST BE MATCHED AT THE\n//*   END.  MAXIMUM STRING LENGTH IS 127.  ONLY THE FIRST 3 COLUMNS OF\n//*   THE 1ST LINE OF EACH SELECTED MESSAGE WILL BE SCANNED FOR THIS\n//*   TEXT, SO IT IS FASTER THAN THE TEXT= KEYWORD.\n//*\n//* FIND=EXCLUDE\n//*\n//*   ENTERED AS SHOWN.  THE RESULT OF THIS KEYWORD IS THAT IF ANY OF\n//*   THE TEXT OR MSGIDS ARE FOUND, THE RECORD WILL NOT BE PRINTED.\n//*   USE THIS TO PRINT EVERYTHING EXCEPT THE MATCHES.\n//*\n//* FIND=QUIT\n//*\n//*   ENTERED AS SHOWN.  USE THIS IF YOU ARE SCANNING THROUGH A LONG\n//*   TIME SPAN FOR THE 1ST OCCURRANCE OF SOMETHING, AND DONT WANT TO\n//*   WASTE THE TIME SEARCHING THROUGH THE REST OF THE LOG.  CAUSES\n//*   EXECUTION TO END AFTER THE 1ST HIT.\n//*\n//* THE ORDER OF THE KEYWORDS DOES NOT MATTER.  A RECORD IS PRINTED IF\n//* IT MATCHES ANY OF THE TEXT STRINGS AND THE JOBNAME, JOBID, AND/OR\n//* SYSID CRITERIA (OR NOT PRINTED, IF \"FIND=EXCLUDE\").\n//*\n//* IF YOU JUST WANT TO PRINT OUT ALL THE LOG RECORDS IN A GIVEN\n//* TIMESPAN, LEAVE OUT THE SYSIN PARAMETERS (OR ONLY INCLUDE COMMENTS).\n//*\n//* A \"*\" IN COLUMN 1 INDICATES A COMMENT RECORD\n//*\n//* RETURN CODES:\n//*\n//*   RC 8: DELIMITER ERROR ON A SYSIN STATEMENT.\n//*   RC 1: NOTHING FOUND\n//*   RC 0: NORMAL RETURN, WE FOUND AT LEAST ONE HIT\n//*\n//* EXAMPLE:\n//*\n//* //SCANLOG  EXEC AFCLOGSC,\n//* // FROM='2002/212,11:30',TO='2002/212,12:30'\n//* //SYSIN    DD   *\n//* * SCAN LOG FOR CAS9180E MESSAGES FROM F083\n//* * FROM 11:30 TILL 12:30 ON JULY 31, 2002\n//* SYSID=F083\n//* MSGID='CAS9180E'\n//*\n//**********************************************************************\n//AFCLOGSC EXEC PGM=AFCLOGR1,REGION=8M\n//LOGIN    DD   DSN=SYSPLEX.OPERLOG,RECFM=VB,LRECL=32756,BLKSIZE=32760,\n// SUBSYS=(LOGR,,'FROM=(&FROM.),TO=(&TO.),LOCAL')\n//LOGOUT   DD   SYSOUT=*\n//SYSUDUMP DD   SYSOUT=*\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "AFCSMP1": {"ttr": 1283, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x08\\x04_\\x01\\x08\\x04_\\tX\\x0bE\\x0bE\\x00\\x00\\xe3\\xd9\\xd3\\xc8@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2008-02-14T00:00:00", "modifydate": "2008-02-14T09:58:00", "lines": 2885, "newlines": 2885, "modlines": 0, "user": "TRLH"}, "text": "./ ADD NAME=$README  0121-03190-08038-1011-00183-00002-00000-TRLH\nAFCSMP1 is a program I developed to access the API provided by SMP/E.\nIt uses control cards to build the SMP/E request (DD GIMIN), then\nformats and outputs the results (DD GIMOUT).  Status and error messages\nare reported via DD GIMPRINT.  It is mainly useful for extracting data\nto be further processed by REXX, SAS, or whatever.  It is especially\nuseful in SAS, as it can be invoked directly from within the code.\n\nThis program has been run on z/OS 1.3, 1.4, 1.7. and 1.8.\n\nThis program may be used, modified, and/or shared by anyone.  Just don't\nsell it, and please give me some credit.\n\n--------------------------------------------------------------------------------\n\n  The format of the GIMIN data is:\n\n    KEYWORD VALUE\n\n    ... where KEYWORD starts in column 1 and is one of:\n\n      CSI\n      ZONE\n      ENTRY\n      SUBENTRY\n      FILTER\n\n    The values are described in 'SMP/E Reference', 'SC28-1806', in the\n    chapter 'SMP/E CSI Application Programming Interface'.\n\n    Comments are indicated by an '*' in column 1.  Continuation is\n    indicated by any non-blank in column 72.  Blanks between col 72 and\n    the last parm character are ignored, and the search resumes in col 1\n    of the next card.\n\n    Maximum length of the various parms is:\n\n     CSI:      44\n     ZONE:     255\n     ENTRY:    255\n     SUBENTRY: 255\n     FILTER:   768\n\n  The GIMOUT data typically has a line describing the type,\n  subtype, etc. followed by a line or lines containing the\n  values.  For example,\n\n    TYPE=SYSMOD\n    EBB1102 TARGR7\n    SUBENTRY=SMODTYPE\n    FUNCTION\n    SUBENTRY=APPLY\n    NO\n\n  Here's some sample jcl:\n\n    //AFCSMP1  EXEC PGM=AFCSMP1,REGION=64M\n    //SYSUDUMP DD   GIMOUT=*\n    //GIMPRINT DD   GIMOUT=*\n    //GIMOUT   DD   GIMOUT=*,RECFM=VB,LRECL=1028,BLKSIZE=27998\n    //GIMIN    DD   *\n    * LIST ALL THE FUNCTION SYSMODS IN TARGR7\n    CSI SYSS.GLOBAL.CSI\n    ZONE TARGR7\n    ENTRY SYSMOD\n    SUBENTRY *\n    FILTER SMODTYPE='FUNCTION'\n    /*\n\n  It can also be executed directly from within a SAS program, like\n  this:\n\n// SET GZONE=SYSS.GLOBAL.CSI             SMPE GLOBAL ZONE DATASET\n//*-----------------------------------------------------------\n//SAS      EXEC SAS,PARM='SORT=4,SYSPARM=&GZONE.'\n//GIMIN    DD   DISP=(NEW,PASS),DSN=&&SYSIN,\n//  UNIT=VIO,SPACE=(TRK,(5,5)),\n//  RECFM=FB,LRECL=80,BLKSIZE=0\n//GIMOUT   DD   DISP=(NEW,PASS),DSN=&&SYSOUT,\n//  UNIT=SYSDA,SPACE=(TRK,(90,90)),\n//  RECFM=VB,LRECL=1028,BLKSIZE=0\n//GIMPRINT DD   SYSOUT=*\n//SYSIN    DD   *\n\n  /*\n  ** PRODUCE \"GIMIN\" STATEMENTS TO RETRIEVE THE ZONE INDEX DATA\n  */\n\n  DATA _NULL_;\n    FILE GIMIN NOPRINT OLD ;\n    GZONE = SYSPARM();\n    PUT \"CSI \" GZONE;\n    PUT \"ZONE GLOBAL                                       \";\n    PUT \"ENTRY GLOBALZONE                                  \";\n    PUT \"SUBENTRY ZONEINDEX                                \";\n    STOP;\n\n  /*\n  ** INVOKE THE SMPE API PROGRAM TO EXTRACT THE DATA TO FILE GIMOUT\n  */\n\n  PROC AFCSMP1;\n\n  /*\n  ** PROCESS THE GIMOUT DATA\n  */\n\n  DATA ZONES;\n    KEEP ZONE ZONETYP;\n    INFILE GIMOUT LENGTH=LEN;\n    INPUT @1 ALINE $VARYING200. LEN;\n    IF INDEX(ALINE,\",\") > 0 THEN DO;\n       ZONE = SCAN(ALINE,1,\",\");\n       ZONETYP = SCAN(ALINE,3,\",\");\n       OUTPUT;\n    END;\n/*\n\n  This example produces the SAS dataset ZONES with zone name (\"ZONE\")\n  and type (\"ZONETYP\", TARGET or DLIB), read directly from SMPE\n  via the API.  I ignored the zone dsname in this example, but\n  it's there.\n\n--------------------------------------------------------------------------------\n\nThe members in this dataset are:\n\n$README  - I guess you already know about this one.\n#DDDEFS  - Data file used by the APPSINCE sample job.  This dataset\n           specifies the relationships between SMPE target DDDEFs and\n           actual production datasets in our shop.  THIS ONLY APPLIES\n           TO OUR SHOP.  You'll have to provide your own target/production\n           relationships if you want to use this.\nAFCSMP1  - The assembler source for the API program.  AFC stands for\n           'Airborne Freight Corporation', by the way - my former\n           employer, absorbed by my current employer, DHL.\nAPSELECT - SAS macro used by the APPSINCE sample job to specify the CSI,\n           zone, and date range of the SYSMODs you want to implement.\nAPPSINCE - An example of a SAS job that uses the AFCSMP1 program.  Ever\n           install a few PTFs and want to implement them, but didn't\n           want to copy all the complete target libraries?  Wouldn't it\n           be nice to have a job that just copied the changed elements?\n           That's what this job generates.\nASMJCL   - JCL to assemble and link the program.\nENTERX   - A macro, used by AFCSMP1 for entry housekeeping.\nEXECJCL  - JCL to run the program\nFUNCLIST - Another example of a SAS job that uses AFCSMP1.  This sample\n           produces:\n\n             A report of all FMIDs in all the zones referenced by a\n             particular global CSI.  The report is in the form of a\n             SAS \"PROC PRINT\", a DCF version (TSO SCRIPT), and an HTML\n             version for Web browsers.\n\n             A DCF report of FMIDs in need of APPLY (RECEIVEd but not\n             APPLYd)\n\n             A DCF report of FMIDs in need of ACCEPT (APPLYd but not\n             ACCEPTed)\n\n             A DCF report of FMIDs needing to be REJECTed (APPLYd and\n             ACCEPTed and still in the GLOBAL zone)\n\n             A DCF report of FMIDs that are in the global FMID list\n             that should be removed.  These are FMIDs for which you are\n             still RECEIVEing service, but which are no longer APPLYd\n             or ACCEPTed anywhere.\n\n             A DCF report of FMIDs that need to be added to the global\n             FMID list.  These are APPLYd or ACCEPTed somewhere, but\n             you are not getting service for them.\n\n           This sample references a dataset\n\nLEAVEX   - A macro, used by AFCSMP1 for exit housekeeping.\n\nRichard Hobt\nDHL Worldwide Express\n7501 E. Hartford Drive\nScottsdale, AZ.  85255\n(480) 375-7320\nRich.Hobt@dhl.com\n\nFeb. 7, 2008\n./ ADD NAME=#DDDEFS  0101-03192-06279-0836-00135-00135-00000-TRLH\n*\n* THIS DATASET LISTS THE ACTUAL PRODUCTION DATASET DESTINATIONS\n* FOR SMPE DDDEFS.  IT IS USED BY THE 'APPSINCE' JOBS TO BUILD\n* IMPLEMENTATION JCL.\n* 1ST THING IS DDDEF NAME, 2ND THING IS OUTPUT DDNAME,\n* 3RD THING IS PRODUCTION DATASET NAME.  COMMENTS MAY FOLLOW\nAKQLINK  LINKIBM  SYS1.LINKLIST.IBM      PPFA MODULES\nAPSLINK  LINKIBM  SYS1.LINKLIST.IBM      PSF MODULES\nBBACTDEF OBBACTDF SYS1.BOOLE.BBACTDEF    B&B\nBBCLIB   OBBCLIB  SYS1.BOOLE.BBCLIB      B&B\nBBCMOD   OBBCMOD  SYS1.BOOLE.BBCMOD      B&B\nBBHELP   OBBHELP  SYS1.BOOLE.BBHELP      B&B\nBBILIB   OBBILIB  SYS1.BOOLE.BBILIB      B&B\nBBLINK   OBBLINK  SYS1.BOOLE.BBLINK      B&B\nBBLOAD   OBBLOAD  SYS1.BOOLE.BBLOAD      B&B\nBBMAC    OBBMAC   SYS1.BOOLE.BBMAC       B&B\nBBMLIB   OBBMLIB  SYS1.BOOLE.BBMLIB      B&B\nBBPARM   OBBPARM  SYS1.BOOLE.BBPARM      B&B\nBBPLIB   OBBPLIB  SYS1.BOOLE.BBPLIB      B&B\nBBPROC   OBBPROC  SYS1.BOOLE.BBPROC      B&B\nBBPROF   OBBPROF  SYS1.BOOLE.BBPROF      B&B\nBBSAMP   OBBSAMP  SYS1.BOOLE.BBSAMP      B&B\nBBSDEF   OBBSDEF  SYS1.BOOLE.BBSDEF      B&B\nBBSLIB   OBBSLIB  SYS1.BOOLE.BBSLIB      B&B\nBBSRC    OBBSRC   SYS1.BOOLE.BBSRC       B&B\nBBTLIB   OBBTLIB  SYS1.BOOLE.BBTLIB      B&B\nBBUSER   OBBUSER  SYS1.BOOLE.BBUSER      B&B\nBBVDEF   OBBVDEF  SYS1.BOOLE.BBVDEF      B&B\nBBYCOPY  OBBYCOPY SYS1.BOOLE.BBYCOPY     B&B\nCAILIB   LINKCAI  SYS1.LINKLIST.CAILIB   CA MODULES\nDCFASM   ODUMMY   NULLFILE               DCF SOURCE STUFF?\nDCFGML   ODCFGML  SYS2.DCFMAC            DCF MACROS\nDCFLOAD  LINKIBM  SYS1.LINKLIST.IBM      DCF MODULES\nDCFSAMP  OHELP    SYS2.HELP              DCF MISC (INC HELP)\nDZILINK  LINKIBM  SYS1.LINKLIST.IBM      OGL MODULES\nGDDMLOAD LINKIBM  SYS1.LINKLIST.IBM      GDDM MODULES\nHASPLOAD LINKCCCC SYS1.LINKLIB.CCAT01    SHOULD BE ON CCAT01 BEFORE SYNC\nHASPMIG  MIGCCCC  SYS1.MIGLIB.CCAT01     SHOULD BE ON CCAT01 BEFORE SYNC\nHELP     OHELP    SYS2.HELP              TSO HELP\nICEDGTL  LINKCCCC SYS1.LINKLIB.CCAT01    SHOULD BE ON CCAT01 BEFORE SYNC\nICQCCLIB OICQCLIB SYS2.ICQ.COMMANDS      ICF CLISTS\nMACLIB   ODUMMY   NULLFILE               TARGPP MACLIB, NOT NEEDED\nMSGENP   ODUMMY   NULLFILE               NOT NEEDED\nMSGENU   ODUMMY   NULLFILE               NOT NEEDED\nPARMLIB  ODUMMY   NULLFILE               PROBABLY NOT NEEDED\nPLILINK  LINKIBM  SYS1.LINKLIST.IBM      PL/1 RUNTIME\nPROCLIB  ODUMMY   NULLFILE               PROBABLY NOT NEEDED\nSACLINK  OSACLINK SYS3.IXFP.SACLINK      IXFP SAS/C TRANSIENT LIB\nSAMPLIB  ODUMMY   NULLFILE               PROBABLY NOT NEEDED\nSAPKMOD1 LINKIBM  SYS1.LINKLIST.IBM      ACIF LOAD MODS\nSAPKSAM1 ODUMMY   NULLFILE               ACIF?\nSAPPMOD1 ODUMMY   NULLFILE               ACIF?\nSAPPSAMP ODUMMY   NULLFILE               ACIF?\nSAPQMOD1 ODUMMY   NULLFILE               ACIF LOAD MODS - NOT USED\nSAPQMOD2 ODUMMY   NULLFILE               ACIF LOAD MODS - NOT USED\nSAPQSAM1 ODUMMY   NULLFILE               ACIF?\nSASCOMOD OSASCOMD SYS1.BOOLE.SASCOMOD    B&B\nSASMMAC1 ODUMMY   NULLFILE               HL ASSEMBLER MACROS\nSASMMOD1 LINKIBM  SYS1.LINKLIST.IBM      HL ASSEMBLER MODULES\nSBLMMOD1 LINKIBM  SYS1.LINKLIST.IBM      INFO MODULES\nSBLMTXT1 LINKIBM  SYS1.LINKLIST.IBM      INFO MODULES\nSDGTPSRC ODUMMY   NULLFILE               WHAT IS IT?\nSEDCLINK OEDCLINK SYS2.SEDCLINK          C/370\nSEDGPENU TEMPPLIB TEMP.PLIB.DATASET      NEEDS TO HAVE PANLCONV RUN\nSEEQINST ODUMMY   NULLFILE               HCM STUFF\nSEOYPENU TEMPPLIB TEMP.PLIB.DATASET      NEEDS TO HAVE PANLCONV RUN\nSEPWPENU TEMPPLIB TEMP.PLIB.DATASET      NEEDS TO HAVE PANLCONV RUN\nSEQQCLIB OEQQCLIB SYS2.OPC.SEQQCLIB      OPC CLISTS\nSEQQLMD0 LINKOPC  SYS1.LINKLIST.OPC      OPC LOAD MODS\nSEQQMSG0 OEQQMSG0 SYS2.OPC.SEQQMSG0      OPC \"MESSAGES\"\nSEQQPENU OEQQPENU SYS2.OPC.SEQQPENU      OPC PANELS\nSEUVPNL  TEMPPLIB TEMP.PLIB.DATASET      NEEDS TO HAVE PANLCONV RUN\nSEWXAUTH LINKIBM  SYS1.LINKLIST.IBM      LANRES/MVS\nSEWXEXEC OEWXEXEC SYS2.SEWEXEC           LANRES/MVS\nSEWXLMOD LINKPROD SYS1.LINKLIST.PROD     LANRES/MVS\nSEWXMSGS OEWXMSGS SYS2.SEWXMSGS          LANRES/MVS\nSEWXPLIB OEWXPLIB TEMP.PLIB.DATASET\nSEWXSAMP ODUMMY   NULLFILE               LANRES/MVS\nSEWXSLIB OEWXSLIB SYS2.SEWXSLIB          LANRES/MVS\nSEWXSRVC ODUMMY   NULLFILE               LANRES/MVS\nSEZACMAC ODUMMY   NULLFILE               WHAT IS IT?\nSEZACMTX ODUMMY   NULLFILE               TCP/IP\nSEZADBRM ODUMMY   NULLFILE               WHAT IS IT?\nSEZADSIL ODUMMY   NULLFILE               TCP/IP\nSEZAINST ODUMMY   NULLFILE               WHAT IS IT?\nSEZALIBN ODUMMY   NULLFILE               TCP/IP\nSEZALINK ODUMMY   NULLFILE               TCP/IP\nSEZALNK2 ODUMMY   NULLFILE               TCP/IP\nSEZAPENU TEMPPLIB TEMP.PLIB.DATASET      NEEDS TO HAVE PANLCONV RUN\nSEZARNT1 ODUMMY   NULLFILE               WHAT IS IT?\nSEZATCP  ODUMMY   NULLFILE               TCP/IP\nSGDDMSAM ODUMMY   NULLFILE               GDDM ASSEMBLER SOURCE/MACROS\nSGIMCLS0 PRODCLST PROD.CLIST             SMPE CLISTS\nSGIMLINK LINKIBM  SYS1.LINKLIST.IBM      SMP/E MODULES\nSGIMLMD0 LINKIBM  SYS1.LINKLIST.IBM      SMP/E MODULES\nSGIMSENU PRODSLIB PROD.ISPF.ISPSLIB      SMPE SKELETONS\nSIBASM   ODUMMY   NULLFILE               IXFP ASSEMBLER SOURCE\nSIBCLIB  OSIBCLIB SYS3.IXFP.SIBCLIB      IXFP CLISTS\nSIBLINK  LINKIBM  SYS1.LINKLIST.IBM      IXFP LOAD MODS\nSIBLOAD  LINKIBM  SYS1.LINKLIST.IBM      IXFP LOAD MODS\nSIBMAC   ODUMMY   NULLFILE               IXFP ASSEMBLER MACROS\nSIBMBASE LINKIBM  SYS1.LINKLIST.IBM      PL/1\nSIBMLIB  OSIBMLIB SYS3.IXFP.SIBMLIB      IXFP ISPF MESSAGES\nSIBMLINK LINKIBM  SYS1.LINKLIST.IBM      PL/1\nSIBPLIB  OSIBPLIB SYS3.IXFP.SIBPLIB      IXFP ISPF PANELS\nSIBRTNS  ODUMMY   NULLFILE               IXFP COMMON PARSER (?)\nSIBSAMP  ODUMMY   NULLFILE               IXFP SAMPLES\nSIBSAS   ODUMMY   NULLFILE               IXFP SAS SAMPLES\nSIBSLIB  OSIBSLIB SYS3.IXFP.SIBSLIB      IXFP ISPF SKELETONS\nSIBTLIB  OSIBTLIB PROD.ISPF.ISPTLIB      IXFP ISPF TABLE (1 MEMBER)\nSICELINK LINKIBM  SYS1.LINKLIST.IBM      SORT MODULES\nSICELNKN ODUMMY   NULLFILE               SORT NON-RESIDENT STUFF\nSICELPA  LPASHARE SYS1.LPALIB.SHARED     SORT\nSICESAMP ODUMMY   NULLFILE               SORT SAMPLES\nSIFALIB  LINKIBM  SYS1.LINKLIST.IBM\nSIMWMOD1 LINKIBM  SYS1.LINKLIST.IBM      WEBSRV/MVS\nSIOEPNLE TEMPPLIB TEMP.PLIB.DATASET      NEEDS TO HAVE PANLCONV RUN\nSISFJCL  ODUMMY   NULLFILE               SDSF STARTED TASK JCL - NOT NEEDED\nSISFMLIB PRODMLIB PROD.ISPF.ISPMLIB      SDSF MESSAGES\nSISFPLIB TEMPPLIB TEMP.PLIB.DATASET      NEEDS TO HAVE PANLCONV RUN\nSISFSRC  ODUMMY   NULLFILE               SDSF SOURCE - NOWHERE TO GO\nSISFTLIB TEMPTLIB TEMP.TLIB.DATASET      SDSF TABLES\nSISPGENU ODUMMY   NULLFILE               ISPF DTL SOURCE\nSISPGMLI ODUMMY   NULLFILE               ISPF DTL SOURCE\nSISPGUI  ODUMMY   NULLFILE               ISPF W/S CODE UPLOAD FILE\nSISPMACS ODUMMY   NULLFILE               ISPF ASSEMBLER MACROS\nSISPPENU TEMPPLIB TEMP.PLIB.DATASET      NEEDS TO HAVE PANLCONV RUN\nSISPSAMP ODUMMY   NULLFILE               ISPF SAMPLE STUFF\nSISTCLI0 PRODCLST PROD.CLIST             VTAM CLISTS\nSISTDAT2 ODUMMY   NULLFILE               WHAT IS IT?\nSISTDBUG ODUMMY   NULLFILE               WHAT IS IT?\nSISTMAC1 ODUMMY   NULLFILE               VTAM MACROS?\nSKPRTNS  ODUMMY   NULLFILE               IXFP ROUTINES\nSSAROMOD ODUMMY   NULLFILE               IXFP SAS/C RESIDENT LIB\nSTKLOAD  NOTIBM   SYS1.LINKLIST.NOTIBM   IXFP LOAD MODS\n./ ADD NAME=AFCSMP1  0105-03191-06279-0825-00843-00782-00000-TRLH\n         TITLE 'A F C S M P 1  -- BATCH EXECUTION OF SMPE API'\n         YREGS\n***********************************************************************\n*                                                                     *\n* AFCSMP1 -- BATCH EXECUTION OF SMPE API INTERFACE                    *\n*                                                                     *\n*   THIS PROGRAM CALLS THE SMPE API INTERFACE WITH PARMS SPECIFIED    *\n*   VIA DDNAME GIMIN.  OUTPUT IS FORMATTED IN A VB DATASET ALLOCATED  *\n*   TO DDNAME GIMOUT.  STATUS, ERROR MESSAGES, ETC. ARE REPORTED VIA  *\n*   DDNAME GIMPRINT.  IT'S MAINLY USEFUL FOR GENERATING DATA TO BE    *\n*   FURTHER PROCESSED BY SAS OR REXX PROGRAMS.                        *\n*                                                                     *\n*   NOTE -- SOME QUERYS CAN TAKE A VERY LONG TIME, AND YOU MIGHT      *\n*   THINK IT'S LOOPING, BUT PROBABLY NOT.  FOR EXAMPLE, I RAN THE     *\n*   FOLLOWING, AND IT TOOK ALMOST AN HOUR AND A HALF:                 *\n*                                                                     *\n*     CSI SYSS.GLOBAL.CSI                                             *\n*     ZONE TARGR7,DLIBR7                                              *\n*     ENTRY ELEMENT                                                   *\n*     SUBENTRY SYSLIB,DISTLIB                                         *\n*                                                                     *\n*                                                                     *\n*   THE FORMAT OF THE GIMIN DATA IS:                                  *\n*                                                                     *\n*     KEYWORD VALUE                                                   *\n*                                                                     *\n*     WHERE KEYWORD STARTS IN COLUMN 1 AND IS ONE OF:                 *\n*                                                                     *\n*       CSI                                                           *\n*       ZONE                                                          *\n*       ENTRY                                                         *\n*       SUBENTRY                                                      *\n*       FILTER                                                        *\n*                                                                     *\n*     THE VALUES ARE DESCRIBED IN 'SMP/E REFERENCE', 'SC28-1806',     *\n*     IN THE CHAPTER 'SMP/E CSI APPLICATION PROGRAMMING INTERFACE'.   *\n*                                                                     *\n*     COMMENTS ARE INDICATED BY AN '*' IN COLUMN 1.                   *\n*     CONTINUATION IS INDICATED BY ANY NON-BLANK IN COLUMN 72.        *\n*     BLANKS BETWEEN COL 72 AND THE LAST PARM CHARACTER ARE           *\n*     IGNORED, AND THE SEARCH RESUMES IN COL 1 OF THE NEXT            *\n*     CARD.                                                           *\n*                                                                     *\n*     MAXIMUM LENGTH OF THE VARIOUS PARMS IS:                         *\n*      CSI:      44                                                   *\n*      ZONE:     255                                                  *\n*      ENTRY:    255                                                  *\n*      SUBENTRY: 255                                                  *\n*      FILTER:   768                                                  *\n*     ALTHOUGH YOU MIGHT WANT TO CHECK THE ACTUAL ENTRIES IN THE      *\n*     WORKAREA DSECT TO BE SURE.                                      *\n*                                                                     *\n*   THE GIMOUT DATA TYPICALLY HAS A LINE DESCRIBING THE TYPE,         *\n*   SUBTYPE, ETC. FOLLOWED BY A LINE OR LINES CONTAINING THE          *\n*   VALUES.  FOR EXAMPLE,                                             *\n*                                                                     *\n*     TYPE=SYSMOD                                                     *\n*     EBB1102 TARGR7                                                  *\n*     SUBENTRY=SMODTYPE                                               *\n*     FUNCTION                                                        *\n*     SUBENTRY=APPLY                                                  *\n*     NO                                                              *\n*                                                                     *\n*   HERE'S SOME SAMPLE JCL:                                           *\n*                                                                     *\n*     //AFCSMP1  EXEC PGM=AFCSMP1,REGION=64M                          *\n*     //SYSUDUMP DD   GIMOUT=*                                        *\n*     //GIMPRINT DD   GIMOUT=*                                        *\n*     //GIMOUT   DD   GIMOUT=*,RECFM=VB,LRECL=1028,BLKSIZE=27998      *\n*     //GIMIN    DD   *                                               *\n*     * LIST ALL THE FUNCTION SYSMODS IN TARGR7                       *\n*     CSI SYSS.GLOBAL.CSI                                             *\n*     ZONE TARGR7                                                     *\n*     ENTRY SYSMOD                                                    *\n*     SUBENTRY *                                                      *\n*     FILTER SMODTYPE='FUNCTION'                                      *\n*     /*                                                              *\n*                                                                     *\n*   IT CAN ALSO BE EXECUTED DIRECTLY FROM WITHIN A SAS PROGRAM, LIKE  *\n*   THIS:                                                             *\n*                                                                     *\n* // SET GZONE=SYSS.GLOBAL.CSI             SMPE GLOBAL ZONE DATASET   *\n* //*-----------------------------------------------------------      *\n* //SAS      EXEC SAS,PARM='SORT=4,SYSPARM=&GZONE.'                   *\n* //GIMIN    DD   DISP=(NEW,PASS),DSN=&&SYSIN,                        *\n* //  UNIT=VIO,SPACE=(TRK,(5,5)),                                     *\n* //  RECFM=FB,LRECL=80,BLKSIZE=0                                     *\n* //GIMOUT   DD   DISP=(NEW,PASS),DSN=&&SYSOUT,                       *\n* //  UNIT=SYSDA,SPACE=(TRK,(90,90)),                                 *\n* //  RECFM=VB,LRECL=1028,BLKSIZE=0                                   *\n* //GIMPRINT DD   SYSOUT=*                                            *\n* //SYSIN    DD   *                                                   *\n*                                                                     *\n*   /*                                                                *\n*   ** PRODUCE \"GIMIN\" STATEMENTS TO RETRIEVE THE ZONE INDEX DATA     *\n*   */                                                                *\n*                                                                     *\n*   DATA _NULL_;                                                      *\n*     FILE GIMIN NOPRINT OLD ;                                        *\n*     GZONE = SYSPARM();                                              *\n*     PUT \"CSI \" GZONE;                                               *\n*     PUT \"ZONE GLOBAL                                       \";       *\n*     PUT \"ENTRY GLOBALZONE                                  \";       *\n*     PUT \"SUBENTRY ZONEINDEX                                \";       *\n*     STOP;                                                           *\n*                                                                     *\n*   /*                                                                *\n*   ** INVOKE THE SMPE API PROGRAM TO EXTRACT THE DATA TO FILE GIMOUT *\n*   */                                                                *\n*                                                                     *\n*   PROC AFCSMP1;                                                     *\n*                                                                     *\n*   /*                                                                *\n*   ** PROCESS THE GIMOUT DATA                                        *\n*   */                                                                *\n*                                                                     *\n*   DATA ZONES;                                                       *\n*     KEEP ZONE ZONETYP;                                              *\n*     INFILE GIMOUT LENGTH=LEN;                                       *\n*     INPUT @1 ALINE $VARYING200. LEN;                                *\n*     IF INDEX(ALINE,\",\") > 0 THEN DO;                                *\n*        ZONE = SCAN(ALINE,1,\",\");                                    *\n*        ZONETYP = SCAN(ALINE,3,\",\");                                 *\n*        OUTPUT;                                                      *\n*     END;                                                            *\n* /*                                                                  *\n*                                                                     *\n*   THIS EXAMPLE PRODUCES THE DATASET ZONES WITH ZONE NAME (\"ZONE\")   *\n*   AND TYPE (\"ZONETYP\", TARGET OR DLIB), READ DIRECTLY FROM SMPE     *\n*   VIA THE API.  I IGNORED THE ZONE DSNAME IN THIS EXAMPLE, BUT      *\n*   IT'S THERE.                                                       *\n*                                                                     *\n* CHANGES:                                                            *\n*                                                                     *\n* 07/17/2003  RLH  LOGIC DIDN'T ALLOW FOR SINGLE CHARACTER ON     RLH1*\n*                  INPUT CONTINUATION CARD.                       RLH1*\n*                                                                     *\n* RICHARD HOBT                                                        *\n* AIRBORNE FREIGHT CORPORATION                                        *\n* 3101 WESTERN AVENUE                                                 *\n* SEATTLE, WA.  98121                                                 *\n* (206) 830-4088                                                      *\n* RICH.HOBT@AIRBORNE.COM                                              *\n*                                                                     *\n***********************************************************************\n*\nAFCSMP1  ENTERX (R12),(,WORKAREA_LEN,C),AMODE=31,RMODE=24\n         USING WORKAREA,R13\n*\n         BRAS  R14,INITIALIZE      INITIALIZE\n*\n         BRAS  R14,OPEN_FILES      OPEN FILES\n         CLC   OUR_RETURN_CODE,=F'0' OPEN OK?\n         JNE   CLEANUP             NO, JUST LEAVE NOW\n*\n         BRAS  R14,READ_INPUT      READ INPUT AND REPORT ON IT\n         CLC   OUR_RETURN_CODE,=F'0' PARMS OK?\n         JNE   CLEANUP             NO, JUST LEAVE NOW\n*\n         BRAS  R14,CALL_API        GO CALL THE API\n         CLC   OUR_RETURN_CODE,=F'0' API CALL OK?\n         JNE   CLEANUP             NO, JUST LEAVE NOW\n*\n         BRAS  R14,PROCESS_LISTS   PROCESS THE API RESULTS\n*\nCLEANUP  DS    0H                  CLOSE FILES, FREE STORAGE, ETC.\n         BRAS  R14,CLEAN_UP\n*\nEGRESS   DS    0H\n         L     R15,OUR_RETURN_CODE FINAL RETURN CODE\n         LEAVEX                    ALL DONE\n*\n*\n*\n*\n*\n*\n*\nINITIALIZE DS 0H\n*\n* INITIALIZE THOSE THINGS THAT NEED IT\n*\n         ST    R14,R14_INITIALIZE        SAVE RETURN ADDR\n         XC    FLAGS,FLAGS            CLEAR FLAG\n         XC    QUERY_PARMS,QUERY_PARMS\n         XC    OUR_RETURN_CODE,OUR_RETURN_CODE\n         XC    OUTBUFFER_LEN,OUTBUFFER_LEN\n         MVC   INDCB(@KINDCB),KINDCB  INIT GIMIN DCB\n         MVC   OUTDCB(@KOUTDCB),KOUTDCB INIT GIMOUT DCB\n         MVC   RPTDCB(@KRPTDCB),KRPTDCB INIT GIMPRINT DCB\n         MVC   OPEN(@KOPEN),KOPEN INIT OPEN PARMLIST\n         MVC   CLOSE(@KCLOSE),KCLOSE INIT CLOSE PARMLIST\n         MVC   TIME(@KTIME),KTIME INIT TIME PARMLIST\nINITIALIZE_RETURN DS 0H\n         L     R14,R14_INITIALIZE  WHERE TO RETURN TO\n         BR    R14                 GO BACK\n*\n* OPEN THE INPUT AND OUTPUT FILES\n*\nOPEN_FILES DS 0H\n         ST    R14,R14_OPEN\nOPEN_INPUT DS 0H\n         LA    R11,INDCB           ADDRESS INPUT DCB\n         USING IHADCB,R11\n         OPEN  ((R11),(INPUT)),MF=(E,OPEN)   OPEN IT\n         TM    DCBOFLGS,DCBOFOPN   DID IT WORK?\n         JO    OPEN_OUTPUT         YES, CONTINUE\n         MVC   OUR_RETURN_CODE,=F'12' OPEN GIMIN FAILURE\n         J     OPEN_FILES_RETURN\n*\nOPEN_OUTPUT DS 0H\n         LA    R11,OUTDCB\n         OPEN  ((R11),(OUTPUT)),MF=(E,OPEN)\n         TM    DCBOFLGS,DCBOFOPN   DID IT WORK?\n         JO    OPEN_GIMPRINT       YES, CONTINUE\n         MVC   OUR_RETURN_CODE,=F'16' OPEN GIMOUT FAILURE\n         J     OPEN_FILES_RETURN\n*\nOPEN_GIMPRINT DS 0H\n         LA    R11,RPTDCB\n         OPEN  ((R11),(OUTPUT)),MF=(E,OPEN)\n         TM    DCBOFLGS,DCBOFOPN   DID IT WORK?\n         JO    OPEN_FILES_RETURN   YES, CONTINUE\n         MVC   OUR_RETURN_CODE,=F'20' OPEN GIMPRINT FAILURE\n         J     OPEN_FILES_RETURN\nOPEN_FILES_RETURN DS 0H\n         L     R14,R14_OPEN\n         BR    R14                 RETURN TO CALLER\n*\n*\n* READ GIMIN AND REPORT WHAT WE FOUND\n*\nREAD_INPUT DS  0H\n         ST    R14,R14_READ        SAVE RETURN ADDRESS\n         MVC   GIMPRINT,=CL133' --- GIMIN DATA: ----------------------'\n         BRAS  R14,WRITE_GIMPRINT  WRITE A HEADING\n         MVC   GIMPRINT,=CL133' '\nREAD_LOOP DS   0H\n         GET   INDCB,INBUFFER      READ A RECORD\n         MVC   GIMPRINT+1(80),INBUFFER   ECHO\n         BRAS  R14,WRITE_GIMPRINT  IT TO GIMPRINT\n         CLI   INBUFFER,C'*'       COMMENT?\n         JE    READ_LOOP           YES, SKIP IT\nCSI_TEST DS    0H\n         CLC   CSI_K,INBUFFER      CSI KEYWORD?\n         JNE   ZONE_TEST           NO, TRY ZONE\n         LA    R1,INBUFFER+L'CSI_K POINT AT START OF CSI DATA\n         BRAS  R14,EXTRACT_TEXT\n         CHI   R2,L'CSI_NAME       TOO BIG?\n         JH    PARM_ERROR          YES, LEAVE\n         ST    R2,CSILEN           SAVE LENGTH\n         BCTR  R2,0                REDUCE FOR EXECUTE\n         LA    R3,CSI_NAME         POINT AT TARGET AREA\n         EX    R2,MOVE_THING       MOVE TEXT\n         J     READ_LOOP           KEEP GOING\n*\nZONE_TEST DS   0H\n         CLC   ZONE_K,INBUFFER     ZONE KEYWORD?\n         JNE   ENTRY_TEST          NO, TRY ENTRY\n         LA    R1,INBUFFER+L'ZONE_K POINT AT START OF ZONE DATA\n         BRAS  R14,EXTRACT_TEXT\n         CHI   R2,L'ZONE_NAME      TOO BIG?\n         JH    PARM_ERROR          YES, LEAVE\n         ST    R2,ZONELEN          SAVE LENGTH\n         BCTR  R2,0                REDUCE FOR EXECUTE\n         LA    R3,ZONE_NAME        POINT AT TARGET AREA\n         EX    R2,MOVE_THING       MOVE TEXT\n         J     READ_LOOP           KEEP GOING\n*\nENTRY_TEST DS  0H\n         CLC   ENTRY_K,INBUFFER    ENTRY KEYWORD?\n         JNE   SUBENTRY_TEST       NO, TRY SUBENTRY\n         LA    R1,INBUFFER+L'ENTRY_K POINT AT START OF ENTRY DATA\n         BRAS  R14,EXTRACT_TEXT\n         CHI   R2,L'ENTRY_NAME      TOO BIG?\n         JH    PARM_ERROR          YES, LEAVE\n         ST    R2,ENTRYLEN         SAVE LENGTH\n         BCTR  R2,0                REDUCE FOR EXECUTE\n         LA    R3,ENTRY_NAME       POINT AT TARGET AREA\n         EX    R2,MOVE_THING       MOVE TEXT\n         J     READ_LOOP           KEEP GOING\n*\nSUBENTRY_TEST DS 0H\n         CLC   SUBENTRY_K,INBUFFER SUBENTRY KEYWORD?\n         JNE   FILTER_TEST         NO, TRY FILTER\n         LA    R1,INBUFFER+L'SUBENTRY_K POINT AT START OF SUBENTRY DATA\n         BRAS  R14,EXTRACT_TEXT\n         CHI   R2,L'SUBENTRY_NAME       TOO BIG?\n         JH    PARM_ERROR          YES, LEAVE\n         ST    R2,SUBENTRYLEN      SAVE LENGTH\n         BCTR  R2,0                REDUCE FOR EXECUTE\n         LA    R3,SUBENTRY_NAME    POINT AT TARGET AREA\n         EX    R2,MOVE_THING       MOVE TEXT\n         J     READ_LOOP           KEEP GOING\nFILTER_TEST DS 0H\n         CLC   FILTER_K,INBUFFER FILTER KEYWORD?\n         JNE   READ_LOOP           NO, IGNORE IT\n         LA    R1,INBUFFER+L'FILTER_K POINT AT START OF FILTER DATA\n         BRAS  R14,EXTRACT_TEXT\n         CHI   R2,L'FILTER_NAME       TOO BIG?\n         JH    PARM_ERROR          YES, LEAVE\n         ST    R2,FILTERLEN        SAVE LENGTH\n         LR    R0,R1                   ADDRESS FROM ...\n         LR    R1,R2                   ... AND LENGTH\n         LR    R3,R1                   LENGTH...\n         LA    R2,FILTER_NAME          ... AND ADDRESS TO\n         MVCL  R2,R0               MOVE FILTER DATA\n         J     READ_LOOP           KEEP GOING\n*\nEODAD    DS    0H\n         LA    R11,INDCB           ADDRESS INPUT DCB\n         CLOSE ((R11)),MF=(E,CLOSE) DONE WITH THIS FILE\n*\n* REPORT THE PARMS AS WE UNDERSTAND THEM\n*\n         MVC   GIMPRINT,=CL133' --- GIMAPI PARMS: --------------------'\n         BRAS  R14,WRITE_GIMPRINT  WRITE A HEADING\n*\n         LA    R1,CSI_NAME         CSI PARM AND LENGTH\n         L     R2,CSILEN\n         LA    R3,CSI_R            \"CSI:\" HEADER\n         BRAS  R14,REPORT_PARM     GO REPORT THIS PARM\n*\n         LA    R1,ZONE_NAME\n         L     R2,ZONELEN\n         LA    R3,ZONE_R           \"ZONE:\" HEADER\n         BRAS  R14,REPORT_PARM     GO REPORT THIS PARM\n*\n         LA    R1,ENTRY_NAME\n         L     R2,ENTRYLEN\n         LA    R3,ENTRY_R          \"ENTRY:\" HEADER\n         BRAS  R14,REPORT_PARM     GO REPORT THIS PARM\n*\n         LA    R1,SUBENTRY_NAME\n         L     R2,SUBENTRYLEN\n         LA    R3,SUBENTRY_R       \"SUBENTRY:\" HEADER\n         BRAS  R14,REPORT_PARM     GO REPORT THIS PARM\n*\n         LA    R1,FILTER_NAME\n         L     R2,FILTERLEN\n         LA    R3,FILTER_R         \"FILTER:\" HEADER\n         BRAS  R14,REPORT_PARM     GO REPORT THIS PARM\n         J     READ_INPUT_RETURN\nPARM_ERROR DS 0H\n         MVC   OUR_RETURN_CODE,=F'4'  PARM ERROR\nREAD_INPUT_RETURN DS 0H\n         L     R14,R14_READ\n         BR    R14\n*\n*\n* CALL THE API, CHECK FOR ERRORS\n*\nCALL_API DS    0H\n         ST    R14,R14_CALL_API\n*\n* SET UP THE PARMS FOR THE QUERY\n*\n         LA    R1,CSI_NAME\n         ST    R1,PCSI\n         LA    R1,ZONE_NAME\n         ST    R1,PZONE\n         LA    R1,ENTRY_NAME\n         ST    R1,PENTRY\n         LA    R1,SUBENTRY_NAME\n         ST    R1,PSUBENTRY\n         LA    R1,FILTER_NAME\n         ST    R1,PFILTER\n         LA    R1,QUERY_PARMS\n         ST    R1,PARMADDR\n*\n         LOAD  EP=GIMAPI                LOAD API\n         ST    R0,PGMADDR\n*\n* GET THE TIME WE STARTED THE CALL\n*\n         BRAS  R14,GET_TIME\n         MVC   GIMPRINT,=CL133' --- GIMAPI TIMINGS: ------------------'\n         BRAS  R14,WRITE_GIMPRINT  WRITE A LINE\n         MVC   GIMPRINT,=CL133'  GIMAPI CALLED AT:   HHMMSSTH MMDDYYYY'\n         MVC   GIMPRINT+22(8),TIME_STRING\n         MVC   GIMPRINT+31(8),DATE_STRING\n         BRAS  R14,WRITE_GIMPRINT\n\n         L     R15,PGMADDR\n         CALL (15),(QUERYCMD,PARMADDR,LISTADDR,APILANG,RC,CC,MSGADDR), X\n               MF=(E,PLIST)\n*\n* GET THE TIME WE RETURNED FROM THE CALL\n*\n         BRAS  R14,GET_TIME\n         MVC   GIMPRINT,=CL133'  GIMAPI RETURNED AT: HHMMSSTH MMDDYYYY'\n         MVC   GIMPRINT+22(8),TIME_STRING\n         MVC   GIMPRINT+31(8),DATE_STRING\n         BRAS  R14,WRITE_GIMPRINT\n*\n         OI    FLAGS,GIMAPI_LOADED INDICATE CLEANUP REQUIRED\n         ICM   R1,B'1111',RC       WHAT WAS RC?\n         JZ    CALL_API_RETURN     ZERO, CONTINUE\n*\n* GIMAPI FOUND AN ERROR, AND PRODUCES NICE FORMATTED MESSAGE(S)\n* DESCRIBING IT.  COPY THEM TO GIMPRINT FOR THE USER, THEN SET\n* THE RETURN CODE SO WE QUIT.\n*\n         L     R7,MSGADDR          GET ADDR OF ERROR MESSAGE\n         USING ITEM_LIST,R7\n         MVC   OUR_RETURN_CODE,=F'8' INDICATE API ERROR\n         MVC   GIMPRINT,=CL133' --- ERROR MESSAGES: ------------------'\n         BRAS  R14,WRITE_GIMPRINT  WRITE A LINE\nFIND_ERROR_MSG DS 0H\n         CLEAR GIMPRINT            BLANK THE LINE\n         L     R2,DATALEN          LENGTH OF STRING\n         CHI   R2,L'GIMPRINT-1        TOO BIG?\n         JNH   WRITE_ERROR_MSG     NO\n         LA    R2,L'GIMPRINT-1     YES, USE MAX LRECL\nWRITE_ERROR_MSG DS 0H\n         BCTR  R2,0                DECREMENT LENGTH\n         L     R1,DATA             POINT AT MESSAGE TEXT\n         LA    R3,GIMPRINT+1       WHERE TO MOVE IT TO\n         EX    R2,MOVE_THING       MOVE TO GIMPRINT\n         BRAS  R14,WRITE_GIMPRINT  WRITE A LINE\n         ICM   R7,B'1111',ITMNEXT  IS THERE MORE?\n         JZ    CALL_API_ERROR      NO, QUIT NOW\n         J     FIND_ERROR_MSG      YES, CONTINUE\nCALL_API_ERROR DS 0H\n         MVC   OUR_RETURN_CODE,RC  INDICATE ERROR\nCALL_API_RETURN DS 0H\n         L     R14,R14_CALL_API\n         BR    R14\n         DROP  R7\n*\n*\n* PROCESS AND PRINT THE API RESULTS\n*\nPROCESS_LISTS DS 0H\n         USING ENTRY_LIST,R10\n         USING CSIENTRY,R9\n         USING SUBENTRY,R8\n         USING ITEM_LIST,R7\n         ST    R14,R14_PROCESS\n*\n         L     R10,LISTADDR        ADDRESS OF HEAD OF LIST\n*\nPRINT_TYPE DS 0H\n         LTR   R10,R10             ANY MORE TYPES?\n         JZ    PROCESS_LISTS_RETURN NO, ALL DONE\n         MVC   ENTRY_TYPE_DATA(5),=CL5'TYPE='\n         MVC   ENTRY_TYPE_DATA+5(12),TYPE\n         MVC   ENTRY_TYPE(2),=AL2(17)  LENGTH\n         L     R9,ENTRIES          NEXT EXTRY\n         J     PRINT_ENTRIES       GO PRINT\nMORE_TYPES DS 0H\n         L     R10,NEXT            NEXT TYPE\n         J     PRINT_TYPE          GO PRINT IT\n*\nPRINT_ENTRIES DS 0H\n         LTR   R9,R9\n         JZ    MORE_TYPES          ALL DONE, SEE IF MORE TYPES\n         MVC   OUTBUFFER(L'ENTRY_TYPE),ENTRY_TYPE TELL WHAT IT IS\n         BRAS  R14,WRITE_GIMOUT\n         MVC   OUTBUFFER_DATA(L'ENTRYNAME),ENTRYNAME\n         MVI   OUTBUFFER_DATA+L'ENTRYNAME,C' '\n         MVC   OUTBUFFER_DATA+L'ENTRYNAME+1(L'ZONENAME),ZONENAME\n         MVC   OUTBUFFER_LEN(2),=AL2(L'ENTRYNAME+L'ZONENAME+1) LENGTH\n         BRAS  R14,WRITE_GIMOUT\n         L     R8,SUBENTRIES       ADDR OF SUBENTRIES\n         J     PRINT_SUBENTRIES\nMORE_ENTRIES DS 0H\n         L     R9,CSINEXT          NEXT ENTRY\n         J     PRINT_ENTRIES       GO PRINT IT\n*\nPRINT_SUBENTRIES DS 0H\n         LTR   R8,R8\n         JZ    MORE_ENTRIES        ALL DONE, SEE IF MORE ENTRIES\n         L     R7,SUBENTDATA       ADDR OF DATA\n         CLC   =CL3'VER',SUBTYPE   IS IT A VER TYPE?\n         JE    HANDLE_VER          YES, HANDLE SPECIAL\n         MVC   OUTBUFFER_DATA(9),=C'SUBENTRY='\n         MVC   OUTBUFFER_DATA+9(L'SUBTYPE),SUBTYPE\n         MVC   OUTBUFFER_LEN(2),=AL2(L'SUBTYPE+9) LENGTH\n         BRAS  R14,WRITE_GIMOUT\n         J     PRINT_SUBDATA       NO, NORMAL\nMORE_SUBENTRIES DS 0H\n         L     R8,SUBNEXT          NEXT SUBENTRY\n         J     PRINT_SUBENTRIES    GO PRINT IT\n*\nPRINT_SUBDATA DS 0H\n         LTR   R7,R7               ANY DATA?\n         JZ    MORE_SUBENTRIES     NO\n         L     R0,DATA             WHERE TO MOVE FROM\n         L     R1,DATALEN          LENGTH\n         C     R1,=F'1024'         MAX LENGTH?\n         JNH   SUBDATA_LEN_OK      OK\n         L     R1,=F'1024'         NO, USE MAX\nSUBDATA_LEN_OK DS 0H\n         LA    R2,OUTBUFFER_DATA   WHERE TO MOVE TO\n         LR    R3,R1               LENGTH\n         STH   R3,OUTBUFFER_LEN    SAVE LENGTH\n         MVCL  R2,R0               MOVE DATA\n         BRAS R14,WRITE_GIMOUT\n         L     R7,ITMNEXT          NEXT DATA\n         J     PRINT_SUBDATA       AND GO\n*\nHANDLE_VER DS 0H\n         DROP  R8\n         DROP  R7\n         USING VER,R6\n         USING SUBENTRY,R5\n         USING ITEM_LIST,R4\n         LR    R6,R7              USE R6 FOR VER STUFF\nPRINT_VERS DS 0H\n         LTR   R6,R6               MORE TO DO?\n         JZ    MORE_SUBENTRIES     BACK TO SUBENTRIES IF DONE\n         MVC   OUTBUFFER_DATA(4),=C'VER='\n         MVC   OUTBUFFER_DATA+4(L'VERNUM),VERNUM  VERSION\n         MVC   OUTBUFFER_LEN(2),=AL2(L'VERNUM+4)\n         BRAS  R14,WRITE_GIMOUT\n         L     R5,VERDATA          LIKE SUBENTRY\n         J     PRINT_VERDATA       GO HANDLE IT\nMORE_VERS DS 0H\n         L     R6,VERNEXT          NEXT VER\n         J     PRINT_VERS          AND CONTINUE\n*\nPRINT_VERDATA DS 0H\n         LTR   R5,R5               ANYTHING?\n         JZ    MORE_VERS           NO, BACK TO VERS\n         MVC   OUTBUFFER_DATA(9),=CL9'VERTHING='\n         MVC   OUTBUFFER_DATA+9(L'SUBTYPE),SUBTYPE\n         MVC   OUTBUFFER_LEN(2),=AL2(L'SUBTYPE+9)\n         BRAS  R14,WRITE_GIMOUT\n         L     R4,SUBENTDATA       ADDR OF DATA\n         J     PRINT_VERLIST\nMORE_VERDATA DS 0H\n         L     R5,SUBNEXT\n         J     PRINT_VERDATA\n*\nPRINT_VERLIST DS 0H\n         LTR   R4,R4               ANYTHING?\n         JZ    MORE_VERDATA        NO\n         L     R0,DATA             WHERE TO MOVE FROM\n         L     R1,DATALEN          LENGTH\n         C     R1,=F'1024'         MAX LENGTH?\n         JNH   VERDATA_LEN_OK      OK\n         L     R1,=F'1024'         NO, USE MAX\nVERDATA_LEN_OK DS 0H\n         LA    R2,OUTBUFFER_DATA   WHERE TO MOVE TO\n         LR    R3,R1               LENGTH\n         STH   R3,OUTBUFFER_LEN    SAVE LENGTH\n         MVCL  R2,R0               MOVE DATA\n         BRAS  R14,WRITE_GIMOUT\n         L     R4,ITMNEXT          NEXT DATA\n         J     PRINT_VERLIST       AND GO\n         DROP  R6\n         DROP  R5\n         DROP  R4\nPROCESS_LISTS_RETURN DS 0H\n         L     R14,R14_PROCESS\n         BR    R14\n*\n*\n* CLOSE FILES, FREE GIMAPI STORAGE, DELETE GIMAPI\n*\nCLEAN_UP DS    0H\n         ST    R14,R14_CLEANUP\n         LA    R11,INDCB           ADDRESS GIMIN DCB\n         TM    DCBOFLGS,DCBOFOPN   IS IT STILL OPEN?\n         JNO   CHECK_CLOSE_2       NO, CONTINUE\n         CLOSE ((R11)),MF=(E,CLOSE) CLOSE GIMIN\nCHECK_CLOSE_2 DS 0H\n         LA    R11,OUTDCB          ADDRESS GIMOUT DCB\n         TM    DCBOFLGS,DCBOFOPN   IS IT STILL OPEN?\n         JNO   CHECK_CLOSE_3       NO, CONTINUE\n         CLOSE ((R11)),MF=(E,CLOSE) CLOSE GIMOUT\nCHECK_CLOSE_3 DS 0H\n         LA    R11,RPTDCB          ADDRESS GIMPRINT DCB\n         TM    DCBOFLGS,DCBOFOPN   IS IT STILL OPEN?\n         JNO   CHECK_CLOSE_4       NO, CONTINUE\n         CLOSE ((R11)),MF=(E,CLOSE) CLOSE GIMPRINT\nCHECK_CLOSE_4 DS 0H\n         TM    FLAGS,GIMAPI_LOADED DO WE NEED TO FREE AND DELETE?\n         JZ    CLEAN_UP_RETURN     NO\n         L     R15,PGMADDR\n         CALL (15),(FREECMD,0,LISTADDR,APILANG,RC,CC,MSGADDR),         X\n               MF=(E,PLIST)\n         DELETE EP=GIMAPI\n         NI    FLAGS,255-GIMAPI_LOADED\nCLEAN_UP_RETURN DS 0H\n         L     R14,R14_CLEANUP\n         BR    R14\n*\n*\n* EXTRACT NON-BLANK TEXT FROM GIMIN RECORD\n*\n* ON ENTRY, R1 POINTS TO THE TEXT\n* ON RETURN, R1 POINTS TO THE TEXT, R2 HAS THE LENGTH\n*\n* USES OUTBUFFER FOR CONTINUATION CARDS\n*\nEXTRACT_TEXT DS 0H\n         ST    R14,R14_EXTRACT\n         XC    OUTBUFFER_LEN(2),OUTBUFFER_LEN\nPROCESS_CARD DS 0H\n         LA    R2,INBUFFER+70     END OF INPUT\nFIND_1ST_CHAR DS 0H\n         CLI   0(R1),C' '         ANYTHING HERE?\n         JNE   FIND_LAST_CHAR     YES, GO\n         LA    R1,1(R1)           NEXT COLUMN\n         CR    R1,R2              TOO FAR?\n         JNL   NO_INPUT           YES\n         J     FIND_1ST_CHAR      NO, NOT YET\nFIND_LAST_CHAR DS 0H\n* START OF TEXT IS POINTED TO BY R1\n         CLI   0(R2),C' '         ANYTHING HERE?\n         JNE   COMPUTE_LENGTH     YES, FOUND END\n         BCTR  R2,0               BACK UP ONE CHAR\n         CR    R1,R2              TOO FAR?\n*        JNL   NO_INPUT           JNL DIDN'T ALLOW FOR 1 CHAR CARD RLH1\n         JH    NO_INPUT           YES\n         J     FIND_LAST_CHAR     NO, KEEP LOOKING\nCOMPUTE_LENGTH DS 0H\n* WE HAVE START AND END, COMPUTE THE LENGTH\n         SR    R2,R1\n         LA    R2,1(R2)           ADJUST\n         J     END_OF_INPUT       AND SEE IF WE'RE DONE\nNO_INPUT DS    0H\n* NOTHING FOUND, USE '*'\n         LA    R1,ASTER            POINT AT ASTERISK\n         LA    R2,1                LENGTH OF 1\n         J     EXTRACT_FINISH\nEND_OF_INPUT DS 0H\n         CLI   INBUFFER+71,C' '    ANY CONTINUATION?\n         JE    EXTRACT_FINISH      NOPE, WE'RE DONE\n         LA    R3,OUTBUFFER_DATA   ADDRESS OF BUFFER\n         LH    R14,OUTBUFFER_LEN   LENGTH OF WHAT'S THERE\n         AR    R3,R14              WHERE NEW STUFF GOES\n         AR    R14,R2              NEW TOTAL LENGTH\n         CHI   R14,L'OUTBUFFER_DATA       TOO BIG?\n         JNL   EXTRACT_RETURN      YES, GET OUT NOW\n         BCTR  R2,0                DECREMENT R2\n         EX    R2,MOVE_THING       ADD NEW STUFF TO BUFFER\n         STH   R14,OUTBUFFER_LEN   SAVE NEW LENGTH\n*\n         GET   INDCB,INBUFFER      READ CONTINUATION\n         MVC   GIMPRINT+1(80),INBUFFER   ECHO\n         BRAS  R14,WRITE_GIMPRINT  IT TO GIMPRINT\n         LA    R1,INBUFFER         POINT AT BEGINNING\n         J     PROCESS_CARD        GO HANDLE IT\nEXTRACT_FINISH DS 0H\n         CLC   OUTBUFFER_LEN(2),=AL2(0) STUFF STORED IN BUFFER?\n         JE    EXTRACT_RETURN      NOPE, ALL DONE\n         LA    R3,OUTBUFFER_DATA   ADDRESS OF BUFFER\n         LH    R14,OUTBUFFER_LEN   LENGTH OF WHAT'S THERE\n         AR    R3,R14              WHERE NEW STUFF GOES\n         AR    R14,R2              NEW TOTAL LENGTH\n         CHI   R14,L'OUTBUFFER_DATA       TOO BIG?\n         JNL   EXTRACT_RETURN      YES, GET OUT NOW\n         BCTR  R2,0                DECREMENT R2\n         EX    R2,MOVE_THING       ADD NEW STUFF TO BUFFER\n         STH   R14,OUTBUFFER_LEN   SAVE NEW LENGTH\n         LR    R2,R14              NEW TOTAL LENGTH\n         LA    R1,OUTBUFFER_DATA   START OF STRING\nEXTRACT_RETURN DS 0H\n         L     R14,R14_EXTRACT\n         BR    R14                 RETURN TO CALLER\n*\n*\n* REPORT ON A PARM\n*\n* ON ENTRY, R1 POINTS TO PARM TEXT\n*           R2 HAS LENGTH\n*           R3 POINTS TO PARM TYPE TEXT\n*\nREPORT_PARM DS 0H\n         ST    R14,R14_REPORT\n         MVC   GIMPRINT,=CL133' '\n         MVC   GIMPRINT_D(L'CSI_R),0(R3) \"HEADER\"\n         LA    R3,GIMPRINT_D+L'CSI_R WHERE TO PUT STUFF\n         LA    R5,L'GIMPRINT_D-L'CSI_R HOW BIG IT CAN BE\nFILL_IN_LINE DS 0H\n         LTR   R4,R2               ANYTHING TO PRINT?\n         JNP   REPORT_WRITE_IT     NO, ALL DONE\n         CR    R4,R5               TOO BIG FOR THIS LINE?\n         JNH   REPORT_FILL_IN      NO\n         LR    R4,R5               YES, USE WHAT WE CAN\nREPORT_FILL_IN DS 0H\n         BCTR  R4,0                REDUCE FOR EXECUTE\n         EX    R4,MOVE_THING       MOVE WHAT FITS\nREPORT_WRITE_IT DS 0H\n         LR    R5,R1               SAVE R1 ACROSS PRINT\n         BRAS  R14,WRITE_GIMPRINT  WRITE IT OUT\n         LA    R4,1(R4)            RESTORE LENGTH\n         SR    R2,R4               ANYTHING LEFT TO REPORT?\n         JNP   REPORT_PARM_RETURN  NO, ALL DONE\n         LA    R1,0(R5,R4)         NEXT UNREPORTED CHAR (FROM SAVED R1)\n         MVC   GIMPRINT,=CL133' '  BLANK THE OUTPUT LINE\n         LA    R3,GIMPRINT_D       WHERE TO MOVE TO\n         LA    R5,L'GIMPRINT_D     HOW MUCH IT CAN HOLD\n         J     FILL_IN_LINE        KEEP GOING\nREPORT_PARM_RETURN DS 0H\n         L     R14,R14_REPORT\n         BR    R14\n*\n*\n*\n* WRITE A LINE OF GIMPRINT\n*\nWRITE_GIMPRINT DS 0H\n         ST    R14,R14_GIMPRINT\n         PUT   RPTDCB,GIMPRINT     WRITE THE LINE\n         L     R14,R14_GIMPRINT\n         BR    R14\n*\n*\n* WRITE A LINE OF GIMOUT\n*\nWRITE_GIMOUT DS 0H\n         ST    R14,R14_GIMOUT\n         LH    R14,OUTBUFFER_LEN   GET LENGTH OF DATA\n         LA    R14,4(R14)          ACCOUNT FOR LENGTH OF RDW\n         STH   R14,OUTBUFFER_LEN   SAVE IT BACK\n         PUT   OUTDCB,OUTBUFFER    WRITE THE LINE\n         L     R14,R14_GIMOUT\n         BR    R14\n*\n*\n* GET THE TIME AND FORMAT IT\n*\nGET_TIME DS 0H\n         ST    R14,R14_TIME\n         XC    TIME_DATE(16),TIME_DATE         CLEAR\n         TIME  DEC,TIME_DATE,DATETYPE=MMDDYYYY,LINKAGE=SYSTEM,         X\n               MF=(E,TIME)\n         UNPK  TIME_STRING(9),TIME_PACKED(5) UNPACK TIME\n         UNPK  DATE_STRING(9),DATE_PACKED(5) UNPACK DATE\n         L     R14,R14_TIME\n         BR    R14\n*\n*\n*\nMOVE_THING MVC 0(0,R3),0(R1)       EXECUTED\n*\nQUERYCMD DC     CL8'QUERY   '\nFREECMD  DC     CL8'FREE    '\nAPILANG  DC     CL8'ENU'\nCSI_K    DC     C'CSI '\nZONE_K   DC     C'ZONE '\nENTRY_K  DC     C'ENTRY '\nSUBENTRY_K DC   C'SUBENTRY '\nFILTER_K DC     C'FILTER '\nCSI_R    DC     C'CSI:      '\nZONE_R   DC     C'ZONE:     '\nENTRY_R  DC     C'ENTRY:    '\nSUBENTRY_R DC   C'SUBENTRY: '\nFILTER_R DC     C'FILTER:   '\nASTER    DC     C'*'\n*\nKINDCB   DCB   DDNAME=GIMIN,DSORG=PS,MACRF=GM,EODAD=EODAD,LRECL=80\n@KINDCB  EQU   *-KINDCB\n*\nKOUTDCB  DCB   DDNAME=GIMOUT,DSORG=PS,MACRF=PM,RECFM=VB,LRECL=1028\n@KOUTDCB EQU   *-KOUTDCB\n*\nKRPTDCB  DCB   DDNAME=GIMPRINT,DSORG=PS,MACRF=PM,RECFM=FBA,LRECL=133\n@KRPTDCB EQU   *-KRPTDCB\n*\nKOPEN    OPEN  KINDCB,MF=L\n@KOPEN   EQU   *-KOPEN\nKCLOSE   OPEN  KOUTDCB,MF=L\n@KCLOSE  EQU   *-KCLOSE\nKTIME    TIME  LINKAGE=SYSTEM,MF=L\n@KTIME   EQU   *-KTIME\n*\n         LTORG\n*\nWORKAREA DSECT\nRSA           DS 18F               REGISTER SAVE AREA\nTIME_DATE     DS 0D\nTIME_PACKED   DS D\nDATE_PACKED   DS D\nPLIST         DS 8F                PARMS FOR GIMAPI\nPGMADDR       DS F                 GIMAPI ADDRESS\nPARMADDR      DS F                 ADDRESS OF QUERY_PARMS\nLISTADDR      DS F                 ADDRESS OF RESULTS LIST\nRC            DS F                 API RETURN CODE\nCC            DS F                 API CONDITION CODE\nMSGADDR       DS F                 API ERROR MESSAGE ADDRESS\nOUR_RETURN_CODE DS F\nR14_INITIALIZE  DS F               R14 SAVE AREA\nR14_OPEN        DS F               R14 SAVE AREA\nR14_READ        DS F               R14 SAVE AREA\nR14_EXTRACT     DS F               R14 SAVE AREA\nR14_CALL_API    DS F               R14 SAVE AREA\nR14_GIMPRINT    DS F               R14 SAVE AREA\nR14_GIMOUT      DS F               R14 SAVE AREA\nR14_PROCESS     DS F               R14 SAVE AREA\nR14_CLEANUP     DS F               R14 SAVE AREA\nR14_TIME        DS F               R14 SAVE AREA\nR14_REPORT      DS F               R14 SAVE AREA\nCSI_NAME      DS CL44              CSI NAME\nZONE_NAME     DS CL255             ZONE NAME(S)\nENTRY_NAME    DS CL255             TYPE OF ENTRY (MOD, LMOD, SRC, ...)\nSUBENTRY_NAME DS CL255             TYPE OF SUBENTRY (SYSLIB, ETC.)\nFILTER_NAME   DS CL768             FILTERING\nTIME_STRING   DS 8C                UNPACKED TIME\nTIME_FILLER   DS C                 (FILLER FOR UNPACK)\nDATE_STRING   DS 8C                UNPACKED DATE\nDATE_FILLER   DS C                 (FILLER FOR UNPACK)\n              DS 0F\nENTRY_TYPE    DS 0CL21             ENTRY TYPE STRING\n              DS F                 RDW\nENTRY_TYPE_DATA DS CL17            DESCRIPTION\n*\nFLAGS    DS   X                    PROGRAM FLAGS\nGIMAPI_LOADED EQU X'80'            ...GIMAPI LOADED\n*\nINDCB    DS    (@KINDCB)XL1        INPUT DCB\nOUTDCB   DS    (@KOUTDCB)XL1       OUTPUT DCB\nRPTDCB   DS    (@KRPTDCB)XL1       REPORT DCB\nOPEN     DS    (@KOPEN)XL1         OPEN PARMLIST\nCLOSE    DS    (@KCLOSE)XL1        CLOSE PARMLIST\nTIME     DS    (@KTIME)XL1         TIME PARMLIST\n*\nGIMPRINT DS  0CL133                GIMPRINT BUFFER\nGIMPRINT_CC DS C                   CARRIAGE CONTROL\nGIMPRINT_D  DS CL132               GIMPRINT DATA\n         DS  0F                    ALIGNMENT\nINBUFFER DS  CL80                  GIMIN BUFFER\n         DS  0F                    ALIGNMENT\nOUTBUFFER DS 0CL1028               GIMOUT BUFFER\nOUTBUFFER_LEN DS F                 VB RDW\nOUTBUFFER_DATA DS CL1024           OUTPUT DATA\n*\n* THE GIMMASM MACRO IS KIND OF WIERD -- IT HAS NON-DSECT PARMS\n* AT THE BEGINNING WHICH WE WANT INCLUDED IN OUR WORK AREA, THEN\n* A SERIES OF DSECTS.  SO WE PUT IT AT THE END OF OUR WORK AREA,\n* AND SET THE WORK AREA LENGTH SO IT INCLUDES THE NON-DSECT PARTS.\n*\n         GIMMASM                   SMPE API AREAS\n*\nWORKAREA_LEN EQU FILTERLEN+L'FILTERLEN-WORKAREA\n*\n         DCBD  DSORG=PS,DEVD=DA    DCB DSECT\n*\n         END\n./ ADD NAME=APPSINCE 0102-03192-03192-0834-00812-00812-00000-TRLH\n//TRLHINCE JOB (TRLH,6C,),\n//            'Rich Hobt',\n//            MSGCLASS=T,\n//            NOTIFY=&SYSUID,\n//            CLASS=T\n//DEFAULT  OUTPUT CLASS=*,JESDS=ALL,DEFAULT=YES,\n//     NAME=('Rich Hobt'),\n//     ROOM=('6C'),\n// BUILDING=('Western'),\n//     DEPT=('SYSW'),\n//  ADDRESS=('3101 Western Ave.',\n//           'Seattle, WA.  98121',\n//           'U.S.A.',\n//           'Planet Earth')\n//*\n//*  This JCL is from: TRLH.AFCSMP1.SRC(APPSINCE)\n//*\n//*---------------------------------------------------------------------\n//*\n//* JOB TO BUILD AN IEBCOPY JOB TO IMPLEMENT SMPE MAINTENANCE\n//* APPLIED BETWEEN SPECIFIED DATES.  ONLY THE AFFECTED ELEMENTS\n//* ARE SELECTED.\n//*\n//* SPECIFY THE ZONE AND DATE(S) VIA THE APSELECT MACRO\n//*\n//*---------------------------------------------------------------------\n//SAS      EXEC SAS,\n// WORK='25000,5000',\n// REGION.SAS=64M\n//MACROS   DD   DISP=SHR,DSN=TRLH.AFCSMP1.SRC\n//OUTDSNS  DD   DISP=SHR,DSN=TRLH.AFCSMP1.SRC(#DDDEFS)\n//GIMIN    DD   DISP=(NEW,PASS),DSN=&&SYSIN,\n//  UNIT=VIO,SPACE=(TRK,(5,5)),\n//  RECFM=FB,LRECL=80,BLKSIZE=0\n//GIMOUT   DD   DISP=(NEW,PASS),DSN=&&SYSOUT,\n//  UNIT=SYSDA,SPACE=(TRK,(90,90)),\n//  RECFM=VB,LRECL=1028,BLKSIZE=0\n//GIMPRINT DD   SYSOUT=*\n//APSYSMOD DD   SYSOUT=*\n//APPSTUFF DD   SYSOUT=*\n//RPTLMOD  DD   SYSOUT=*\n//RPTOTHR  DD   SYSOUT=*\n//ORPHANS  DD   SYSOUT=*\n//TRACE    DD   SYSOUT=*\n//INSTALL  DD   SYSOUT=*\n//SYSIN    DD  *\n  OPTIONS LS=80 NOCENTER SYMBOLGEN MACROGEN NODATE S=80;\n  %INCLUDE MACROS(APSELECT);\n\n  /* Specify:                                                              */\n  /*   CSI      (default: SYSS.GLOBAL.CSI)                                 */\n  /*   ZONE     (DEFAULT: TARGZ14)                                         */\n  /*   FROMDATE (default: none)  can be either DDJJJ or MM/DD/YY           */\n  /*   TODATE   (default: today) can be either DDJJJ or MM/DD/YY           */\n  /*                                                                       */\n  /* ... via the APSELECT macro.                                           */\n\n %APSELECT(CSI=SYSS.CA.GLOBAL.CSI,ZONE=CAITGT,FROMDATE=06/02/03);\n\n  /* Build the control cards for the initial SMPE query                    */\n  /* (sysmods applied since a given date) and invoke the                   */\n  /* SMPE API.                                                             */\n\n  data _NULL_;\n    file gimin noprint old ;\n    format filter $char80.;\n    put \"CSI &vcsi                                         \";\n    put \"ZONE &vzone                                       \";\n    put \"ENTRY SYSMOD                                      \";\n    PUT \"SUBENTRY ELEMENT,ASSEM,INSTALLDATE,INSTALLTIME,FMID     \";\n    FILTER = \"FILTER DELBY=''&LASTSUP=''&INSTALLDATE>='&VFRMDATE'\";\n    lenf = length(filter);\n    filter = trim(filter) || repeat(\" \",70-lenf) || \"*\";\n    put filter;\n    filter = \"&INSTALLDATE<='&vtodate'\";\n    put filter;\n    stop;\n\n  proc AFCSMP1;\n\n  /* Read the initial query results and build the sysmods dataset,         */\n  /* containing sysmod names and elements.  Print a report showing         */\n  /* the sysmods and apply dates and times.                                */\n\n  data sysmods;\n    keep sysmod\n         element\n         type\n         fmid\n      ;\n    retain sysmod \"       \"\n           type   \"            \"\n           fmid   \"       \"\n      ;\n    infile gimout length=len;\n    input @1 aline $varying200. len;\n    if aline =: \"TYPE=SYSMOD\" then do;\n       input @1 sysmod $char7.;\n       return;\n    end;\n    if aline =: \"SUBENTRY=FMID\" then do;\n       input @1 fmid $char7.;\n       return;\n    end;\n    if scan(aline,1,'=') = \"SUBENTRY\" then do;\n       type = scan(aline,2,'=');\n       IF TYPE = \"ASSEM\" THEN TYPE = \"MOD\";\n       input @1 element $varying200. len;\n       output;\n       return;\n    end;\n    element = aline;\n    output;\n    return;\n\n data apsysmod;\n   set sysmods;\n   label idate = \"Install Date\"\n         itime = \"Install Time\"\n     ;\n   format idate worddate.\n          itime time8.\n     ;\n   retain idate\n     ;\n   if type = \"INSTALLDATE\" then idate = input(element,julian5.);\n   if type = \"INSTALLTIME\" then do;\n      itime = input(element,time8.);\n      output;\n   end;\n\n proc sort data=apsysmod; by idate itime sysmod;\n\n proc printto print=apsysmod;\n\n proc print data=apsysmod uniform noobs label;\n id sysmod;\n var fmid idate itime;\n title \"Sysmods applied in zone &vzone between &wfrmdate and &wtodate\";\n\n  /* Build the control cards to extract all the MOD/LMOD relationships.    */\n  /* If there are too many mods for a FILTER statement (max len=768)       */\n  /* then ignore filtering and grab everything.  Otherwise, build a filter */\n  /* statement to cut down on execution time.                              */\n\n  data modlist;\n    set sysmods;\n    keep mod\n      ;\n    if type =: \"MOD\";\n    mod = element;\n\n  proc sort data=modlist nodupkey; by mod;\n\n  data _NULL_;\n    set modlist nobs=nobs end=eof;\n    file gimin noprint old;\n    format filter $char100.;\n    retain filter\n      ;\n    if _N_ = 1 then do;\n       put \"CSI &vcsi                                         \";\n       put \"ZONE &vzone                                       \";\n       put \"ENTRY MOD                                         \";\n       put \"SUBENTRY ENAME,LMOD,TALIAS                        \";\n       filter = \"FILTER ENAME='\";\n    end;\n\n    if nobs > 45 then stop;\n\n    if _N_ = 1 then filter = trim(filter) || mod;\n               else filter = trim(filter) || \"|ENAME='\" || mod;\n    filter = trim(filter) || \"'\";\n    if length(filter) > 71 then do;\n       line = substr(filter,1,71) || \"*\";\n       put line;\n       filter = trim(substr(filter,72));\n    end;\n    if eof then do;\n       if length(filter) > 71 then do;\n          line = substr(filter,1,71) || \"*\";\n          put line;\n          filter = trim(substr(filter,72));\n       end;\n       put filter;\n     end;\n\n  proc AFCSMP1;\n\n  data allmods (keep=mod lmod)\n       malias0 (keep=mod talias)\n      ;\n    retain mod\n           subentry \"        \"\n      ;\n    infile gimout length=len;\n    input @1 aline $varying200. len;\n    if aline =: \"TYPE=MOD\" then do;\n       input @1 aline $varying200. len;\n       mod = scan(aline,1,\" \");\n       return;\n    end;\n    if aline =: \"SUBENTRY=LMOD\" then do;\n       input @1 lmod $varying200. len;\n       subentry = \"LMOD\";\n       output allmods;\n       return;\n    end;\n    if aline =: \"SUBENTRY=TALIAS\" then do;\n       input @1 talias $varying200. len;\n       subentry = \"TALIAS\";\n       output malias0;\n       return;\n    end;\n    if subentry = \"LMOD\" then do;\n       lmod = aline;\n       output allmods;\n       return;\n    end;\n    if subentry = \"TALIAS\" then do;\n       talias = aline;\n       output malias0;\n       return;\n    end;\n\n proc sort data=allmods; by mod;\n proc sort data=malias0; by mod talias;\n\n  /* combine malias0 and allmods to assign t-alii to lmods */\n\n data malias(keep = lmod talias);\n   merge allmods\n         malias0 (in=haslias)\n     ;\n     by mod;\n     if haslias;\n\n proc sort data=malias; by lmod talias;\n\n  /* Separate the changed mods from other entries, and put them in         */\n  /* their own datasets.                                                   */\n\n data appmods(keep=mod)\n      appother(keep=element type)\n   ;\n   set sysmods;\n   if type =: \"MOD\" then do;\n      mod = element;\n      output appmods;\n   end;\n   else do;\n      IF TYPE =: \"INSTALL\" THEN RETURN;\n      output appother;\n   end;\n\n proc sort data=appmods; by mod;\n\n /* Merge the applied mods with the allmods dataset to get a               */\n /* list of changed lmods.                                                 */\n\n data applmods;\n   keep lmod\n        type\n    ;\n   retain type \"LMOD\";\n   merge appmods(in=applied)\n         allmods(in=haslmod)\n     ;\n   by mod;\n   if applied and haslmod;\n\n /* Sort the applied lmods (APPLMODS) and other stuff (APPOTHER) to get    */\n /* rid of duplicates.                                                     */\n\n proc sort data=applmods nodupkey; by lmod;\n proc sort data=appother nodupkey; by type element;\n\n proc printto print=appstuff;\n proc print data=applmods uniform noobs;\n id type;\n var lmod;\n title \"Lmods applied in zone &vzone between &wfrmdate and &wtodate\";\n\n proc print data=appother uniform noobs;\n id type;\n var element;\n title \"Other items applied in zone &vzone between &wfrmdate and &wtodate\";\n\n  /* Build the control cards to extract all the lmod/syslib relationships. */\n  /* If there are too many lmods for a filter statement (max len=768)      */\n  /* then ignore filtering and grab everything.  Otherwise, build a filter */\n  /* statement to cut down on execution time.                              */\n\n  data _NULL_;\n    set applmods nobs=nobs end=eof;\n    file gimin noprint old;\n    format filter $char100.;\n    retain filter\n      ;\n    if _N_ = 1 then do;\n       put \"CSI &vcsi                                         \";\n       put \"ZONE &vzone                                       \";\n       put \"ENTRY LMOD                                        \";\n       PUT \"SUBENTRY ENAME,SYSLIB,LMODALIAS                   \";\n       filter = \"FILTER ENAME='\";\n    end;\n\n    if nobs > 45 then stop;\n\n    if _N_ = 1 then filter = trim(filter) || lmod;\n               else filter = trim(filter) || \"|ENAME='\" || lmod;\n    filter = trim(filter) || \"'\";\n    if length(filter) > 71 then do;\n       line = substr(filter,1,71) || \"*\";\n       put line;\n       filter = trim(substr(filter,72));\n    end;\n    if eof then do;\n       if length(filter) > 71 then do;\n          line = substr(filter,1,71) || \"*\";\n          put line;\n          filter = trim(substr(filter,72));\n       end;\n       put filter;\n     end;\n\n  proc AFCSMP1;\n\n  data lsyslib0 (keep=lmod syslib type)\n       lalias (keep=lmod lmodalias)\n    ;\n    RETAIN LMOD \"        \"\n           TYPE \"LMOD\"\n           subentry \"        \"\n      ;\n    infile gimout length=len;\n    input @1 aline $varying200. len;\n    if aline =: \"TYPE=LMOD\" then do;\n       input @1 aline $varying200. len;\n       lmod = scan(aline,1,\" \");\n       subentry = '        ';\n       return;\n    end;\n    if aline =: \"SUBENTRY=SYSLIB\" then do;\n       input @1 syslib $varying200. len;\n       output lsyslib0;\n       subentry = \"SYSLIB\";\n       return;\n    end;\n    if aline =: \"SUBENTRY=LMODALIAS\" then do;\n       input @1 lmodalias $varying200. len;\n       output lalias;\n       subentry = \"LALIAS\";\n       return;\n    end;\n    if subentry = \"SYSLIB\" then do;\n       syslib = aline; /* more than one syslib */\n       output lsyslib0;\n    end;\n    if subentry = \"LALIAS\" then do;\n       lmodalias = aline; /* more than one alias  */\n       output lalias;\n    end;\n\n  proc sort data=lsyslib0 nodupkey; by lmod syslib;\n  proc sort data=lalias   nodupkey; by lmod lmodalias;\n\n  data lsyslib1\n       orphanl\n    ;\n    merge applmods(in=applied)\n          lsyslib0(in=haslib)\n      ;\n      by lmod;\n    if applied and haslib then output lsyslib1;\n    if applied and not haslib then output orphanl;\n\n  /*\n  ** Merge the applied lmods with their aliases\n  */\n  data lsyslib(keep=lmod syslib type main)\n    ;\n    merge lsyslib1(in=insyslib)\n          malias(in=inalias1)\n          lalias(in=inalias2)\n      ;\n      by lmod;\n      main = \"        \";\n      if insyslib then output;      /* output main entry */\n      if insyslib & (inalias1 | inalias2) then do;\n         main = lmod;\n         if inalias1 then lmod = talias;\n         else if inalias2 then lmod = lmodalias;\n         output;   /* output an alias entry */\n      end;\n\n  proc printto print=rptlmod;\n  proc print uniform noobs data=lsyslib;\n  id lmod;\n  var syslib main;\n  title \"Applied lmods and their syslibs\";\n\n  proc printto print=orphans;\n  proc print uniform noobs data=orphanl;\n  id lmod;\n  title \"Applied lmods without any defined syslibs\";\n\n\n  /*                                                                       */\n  /* Build the control cards to extract all the element/syslib             */\n  /* relationships.  If there are too many elements for a filter           */\n  /* statement (max len=768) then ignore filtering and grab everything.    */\n  /* Otherwise, build a filter statement to cut down on execution time.    */\n\n  proc sort data=appother nodupkey; by element type;\n\n  data _NULL_;\n    set appother nobs=nobs end=eof;\n    file gimin noprint old;\n    format filter $char100.;\n    retain filter\n      ;\n    if _N_ = 1 then do;\n       put \"CSI &vcsi                                         \";\n       put \"ZONE &vzone                                       \";\n       put \"ENTRY ELEMENT                                     \";\n       put \"SUBENTRY ENAME,SYSLIB,ALIAS,MALIAS                \";\n       filter = \"FILTER ENAME='\";\n    end;\n\n    if nobs > 45 then stop;\n\n    if _N_ = 1 then filter = trim(filter) || element;\n               else filter = trim(filter) || \"|ENAME='\" || element;\n    filter = trim(filter) || \"'\";\n    if length(filter) > 71 then do;\n       line = substr(filter,1,71) || \"*\";\n       put line;\n       filter = trim(substr(filter,72));\n    end;\n    if eof then do;\n       if length(filter) > 71 then do;\n          line = substr(filter,1,71) || \"*\";\n          put line;\n          filter = trim(substr(filter,72));\n       end;\n       put filter;\n    end;\n\n  proc AFCSMP1;\n\n  data esyslib0(keep=element syslib type)\n       ealias(keep=element alias)\n      ;\n    retain element\n           type\n           subentry \"        \"\n      ;\n    infile gimout length=len;\n    input @1 aline $varying200. len;\n    if aline =: \"TYPE=\" then do;\n       type = scan(aline,2,\"=\");\n       input @1 aline $varying200. len;\n       element = scan(aline,1,\" \");\n       subentry = '        ';\n       return;\n    end;\n    if aline =: \"SUBENTRY=MALIAS\" then do;\n       input @1 alias $varying200. len;\n       output ealias;\n       subentry = \"MALIAS\";\n       return;\n    end;\n    if aline =: \"SUBENTRY=SYSLIB\" then do;\n       input @1 syslib $varying200. len;\n       output esyslib0;\n       subentry = \"SYSLIB\";\n       return;\n    end;\n    if subentry = \"SYSLIB\" then do;\n       syslib = aline; /* more than one syslib */\n       output esyslib0;\n    end;\n    if subentry = \"MALIAS\" then do;\n       alias = aline; /* more than one malias  */\n       output ealias;\n    end;\n\n  proc sort data=esyslib0 nodupkey; by element type;\n  proc sort data=ealias nodupkey; by element alias;\n\n  data esyslib1\n       orphane\n    ;\n    merge appother(in=applied)\n          ESYSLIB0(IN=HASLIB)\n      ;\n      by element;\n    if applied and haslib then output esyslib1;\n    if applied and not haslib then output orphane;\n\n  /*\n  ** Merge the applied elements with their aliases\n  */\n  data esyslib(keep=element syslib type main)\n    ;\n    merge esyslib1(in=insyslib)\n          ealias(in=inalias)\n      ;\n      by element;\n      main = \"        \";\n      if insyslib then output;      /* output main entry */\n      if insyslib & inalias then do;\n         main = element;\n         element = alias;\n         output;   /* output an alias entry */\n      end;\n\n  proc printto print=rptothr;\n  proc print uniform noobs data=esyslib;\n  id element;\n  var type syslib main;\n  title \"Applied elements and their syslibs\";\n\n  proc printto print=orphans;\n  proc print uniform noobs data=orphane;\n  id element;\n  var type;\n  title \"Applied elements without any defined syslibs\";\n\n  /*                                                                       */\n  /* Now that we've got all the applied elements and their syslibs, we     */\n  /* need to associate the syslibs with datasets.                          */\n\n  data _NULL_;\n    file gimin noprint old;\n    format filter $char80.;\n    put \"CSI &vcsi                                         \";\n    put \"ZONE &vzone                                       \";\n    put \"ENTRY DDDEF                                       \";\n    put \"SUBENTRY ENAME,DATASET,PATH,VOLUME                \";\n    stop;\n\n  proc AFCSMP1;\n\n  /* Read the DDDEF query results and build the initial DDDEFS dataset    */\n\n  data dddefs0;\n    keep syslib\n         dataset\n         volume\n         path\n      ;\n    retain syslib \"        \"\n           dataset \"                                        \"\n           volume \"      \"\n           path\n      ;\n    infile gimout length=len eof=eof;\n    input @1 aline $varying200. len;\n    if aline =: \"TYPE=DDDEF\" then do;\n       if syslib ne \"        \" then do;\n          output;\n          path = repeat(' ',255);\n          dataset = repeat(' ',44);\n          volume = \"      \";\n       end;\n       input @1 aline $varying200. len;\n       syslib = scan(aline,1,\" \");\n       return;\n    end;\n    if scan(aline,1,'=') = \"SUBENTRY\" then do;\n       type = scan(aline,2,'=');\n       input @1 aline $varying200. len;\n       if type =: \"DATASET\" then dataset = aline;\n       if type =: \"VOLUME\" then volume = aline;\n       if type =: \"PATH\" then do;\n          path = aline;\n          dataset = \" \";\n          volume = \"      \";\n       end;\n       return;\n    end;\n    return;\n  eof:\n    output;\n    stop;\n\n  proc sort data=dddefs0; by syslib;\n\n  proc sort data=lsyslib; by syslib;\n\n  /*                                                                    */\n  /* Now, combine the lmods and dddefs (lsyslib and dddefs0) to         */\n  /* add dataset info to the lmods.                                     */\n\n  data lsyslib2;\n    merge lsyslib(in=keeper)\n          dddefs0\n      ;\n      by syslib;\n    if keeper;\n\n  proc sort data=esyslib; by syslib;\n\n  /* Now, combine the elements and dddefs (esyslib and dddefs0) to      */\n  /* add dataset info to the non-lmod elements.                         */\n\n  data esyslib2;\n    merge esyslib(in=keeper)\n          dddefs0\n      ;\n      by syslib;\n    if keeper;\n\n  /* Separate the things needing to be iebcopied someplace from the     */\n  /* things handled by sync jobs.                                       */\n\ndata lmodsync\n     lmodcopy\n  ;\n  drop lmod\n       path\n  ;\n  set lsyslib2;\n  element = lmod;\n  if volume =: \"SY\" or path ne \"\" then output lmodsync;\n                                  else output lmodcopy;\n\nproc sort data=lmodcopy nodupkey ; by syslib element;\nproc sort data=lmodcopy; by syslib main element;\n\ndata elemsync\n     elemcopy\n  ;\n  drop path;\n  set esyslib2;\n  if volume =: \"SY\" or path ne \"\" then output elemsync;\n                                  else output elemcopy;\n\nproc sort data=elemcopy nodupkey ; by syslib element;\nproc sort data=elemcopy; by syslib main element;\n\n\ndata outdsns;                       /* read the dddef-prod dataset file */\n  infile outdsns;\n  keep syslib outdd outdsn;\n  input @1 aline $char80. ;\n  if substr(aline,1,1) = \"*\" then return;\n  syslib = scan(aline,1,\" \");\n  outdd  = scan(aline,2,\" \");\n  outdsn = scan(aline,3,\" \");\n  output;\n\nproc sort data=outdsns; by syslib;\n\nproc printto print=TRACE;\n\nproc print uniform noobs data=lmodsync;\ntitle \"LMODs handled by SYSRES SYNC\";\n\nproc print uniform noobs data=lmodcopy;\ntitle \"LMODs needing to be copied\";\n\nproc print uniform noobs data=elemsync;\ntitle \"Elements handled by SYSRES SYNC\";\n\nproc print uniform noobs data=elemcopy;\ntitle \"Elements needing to be copied\";\n\nproc print uniform noobs data=outdsns;\ntitle \"Output dataset names\";\n\n /*\n ** Add output dataset DDNAMEs and datasets to LMODs for IEBCOPY.\n */\n\ndata lmodout;\n  merge lmodcopy(in=keeper)\n        outdsns\n    ;\n  by syslib;\n  if keeper;\n\n /* Add output dataset DDNAMEs and datasets to other elements */\n\ndata elemout;\n  merge elemcopy(in=keeper)\n        outdsns\n    ;\n  by syslib;\n  if keeper;\n\n /*\n ** Generate JCL header.  Do this in a separate step in case there are no\n ** non-LMOD elements.\n */\n\n data _NULL_;   /* first, the base JCL and input libraries */\n   file install noprint;\n   put \"//INSTALL  JOB\";\n   put \"//*\";\n   put \"//* JCL GENERATED BY APPSINCE ON &SYSDATE &SYSTIME\";\n   PUT \"//* ZONE &VZONE FOR SYSMODS APPLIED BETWEEN &WFRMDATE (&VFRMDATE)\";\n   PUT \"//*                                 AND     &WTODATE (&VTODATE)\";\n   put \"//*\";\n\n /* Generate JCL for non-LMOD elements */\n\n data _NULL_;   /* first, the base JCL and input libraries */\n   file install mod noprint;\n   retain x -1;\n   set elemout;\n     by syslib;\n   if _N_ = 1 then do;\n      put \"//ELEMENTS EXEC PGM=IEBCOPY,REGION=8M\";\n      put \"//SYSPRINT DD   SYSOUT=*\";\n      put \"//SYSUT3   DD   UNIT=SYSDA,SPACE=(TRK,(10,10))\";\n      put \"//SYSUT4   DD   UNIT=SYSDA,SPACE=(TRK,(10,10))\";\n      put \"//*\";\n      put \"//* GENERATED DD STATEMENTS FOR NON-LMOD INPUT LIBRARIES\";\n      put \"//*\";\n   end;\n   if first.syslib then do;\n      put \"//\" syslib @11 \" DD   DISP=SHR,DSN=\" dataset;\n   end;\n\n proc sort data=elemout nodupkey out=elemodd; by outdd;\n\n data _NULL_;   /* Next, output libraries */\n   file install mod noprint;\n   retain x -1;\n   set elemodd;\n     by outdd;\n   if _N_ = 1 then do;\n      put \"//*\";\n      put \"//* GENERATED DD STATEMENTS FOR NON-LMOD OUTPUT LIBRARIES\";\n      put \"//*\";\n   end;\n   if first.outdd then do;\n      if outdd NE \"\" then\n      put \"//\" OUTDD @11 \" DD   DISP=SHR,DSN=\" OUTDSN;\n   end;\n\n data _NULL_;   /* Finally, output SYSIN */\n   file install mod noprint;\n   retain x -1;\n   set elemout;\n     by syslib;\n   if _N_ = 1 then do;\n      put \"//*\";\n      put \"//SYSIN   DD   *\";\n   end;\n   if first.syslib then do;\n      if outdd = \"\" then outdd = \"????????\";\n      put \" COPY INDD=((\" SYSLIB +X \",R)),OUTDD=\" OUTDD;\n   end;\n   if main =: \" \" then put \"  S M=\" ELEMENT;\n   else put \"  S M=\" element @20 \"* ALIAS OF \" main \"*\";\n\n /* Generate JCL for LOD elements */\n\n data _NULL_;   /* first, the base JCL and input libraries */\n   file install mod noprint;\n   retain x -1;\n   set lmodout;\n     by syslib;\n   if _N_ = 1 then do;\n      put \"//LMODS    EXEC PGM=IEBCOPY,REGION=8M\";\n      put \"//SYSPRINT DD   SYSOUT=*\";\n      put \"//SYSUT3   DD   UNIT=SYSDA,SPACE=(TRK,(10,10))\";\n      put \"//SYSUT4   DD   UNIT=SYSDA,SPACE=(TRK,(10,10))\";\n      put \"//*\";\n      put \"//* GENERATED DD STATEMENTS FOR LMOD INPUT LIBRARIES\";\n      put \"//*\";\n   end;\n   if first.syslib then do;\n      put \"//\" syslib @11 \" DD   DISP=SHR,DSN=\" dataset;\n   end;\n\n proc sort data=lmodout nodupkey out=lmododd; by outdd;\n\n data _NULL_;   /* Next, output libraries */\n   file install mod noprint;\n   retain x -1;\n   set lmododd;\n     by outdd;\n   if _N_ = 1 then do;\n      put \"//*\";\n      put \"//* GENERATED DD STATEMENTS FOR LMOD OUTPUT LIBRARIES\";\n      put \"//*\";\n   end;\n   if first.outdd then do;\n      if outdd NE \"\" then\n      put \"//\" OUTDD @11 \" DD   DISP=SHR,DSN=\" OUTDSN;\n   end;\n\n data _NULL_;   /* Finally, output SYSIN */\n   file install mod noprint;\n   retain x -1;\n   set lmodout;\n     by syslib;\n   if _N_ = 1 then do;\n      put \"//*\";\n      put \"//SYSIN   DD   *\";\n   end;\n   if first.syslib then do;\n      if outdd = \"\" then outdd = \"????????\";\n      put \" COPYMOD INDD=((\" SYSLIB +X \",R)),OUTDD=\" OUTDD;\n   end;\n   if main =: \" \" then put \"  S M=\" ELEMENT;\n   else put \"  S M=\" element @20 \"* ALIAS OF \" main \"*\";\n./ ADD NAME=APSELECT 0100-03192-03192-0827-00034-00034-00000-TRLH\n  %MACRO APSELECT(CSI=SYSS.GLOBAL.CSI,ZONE=TARGZ14,FROMDATE=,TODATE=);\n    %global vcsi vzone vfrmdate vtodate wfrmdate wtodate;\n    %let vcsi=&csi;\n    %let vzone=&zone;\n    data _NULL_;\n      vfdate = \"&fromdate\";\n      if index(vfdate,'/') > 0 then do;\n         mfdate = input(vfdate,mmddyy8.);\n         jfdate = put(mfdate,julian5.);\n      end;\n      else jfdate = vfdate;\n      call symput('vfrmdate',jfdate);\n      wdate = input(jfdate,julian5.);\n      wfdate = trim(left(put(wdate,worddate18.)));\n      call symput('wfrmdate',wfdate);\n      /* */\n      FORMAT VTDATE $8.;\n      vtdate = \"&todate\";\n      if vtdate = \"\" then do;\n         vtdate = put(date(),julian5.);\n      end;\n      if index(vtdate,'/') > 0 then do;\n         mtdate = input(vtdate,mmddyy8.);\n         jtdate = put(mtdate,julian5.);\n      end;\n      else do;\n         jtdate = vtdate;\n      end;\n      call symput('vtodate',jtdate);\n      wdate = input(jtdate,julian5.);\n      wtdate = trim(left(put(wdate,worddate18.)));\n      call symput('wtodate',wtdate);\n      stop;\n  %mend APSELECT;\n./ ADD NAME=ASMSMP1  0101-03190-03191-0803-00047-00043-00000-TRLH\n//TRLHMJCL JOB (TRLH,6C,),\n//            'Rich Hobt',\n//            MSGCLASS=T,\n//            NOTIFY=&SYSUID,\n//            CLASS=X\n//DEFAULT  OUTPUT CLASS=*,JESDS=ALL,DEFAULT=YES,\n//     NAME=('Rich Hobt'),\n//     ROOM=('6C'),\n// BUILDING=('Western'),\n//     DEPT=('SYSW'),\n//  ADDRESS=('3101 Western Ave.',\n//           'Seattle, WA.  98121',\n//           'U.S.A.',\n//           'Planet Earth')\n//*\n//*  This JCL is from: TRLH.AFCSMP1.SRC(ASMJCL)\n//*\n//*--------------------------------------------------------------------\n//*\n//*  THIS JOB ASSEMBLES AND LINKS AFCSMP1\n//*\n//ASM      EXEC PGM=ASMA90,\n//         PARM='OBJECT,NODECK,XREF(FULL),RENT'\n//SYSLIB   DD   DISP=SHR,DSN=SYS1.MACLIB\n//         DD   DISP=SHR,DSN=SYS1.MODGEN\n//         DD   DISP=SHR,DSN=TRLH.AFCSMP1.SRC                <-- CHANGE\n//SYSUT1   DD   DSN=&&SYSUT1,SPACE=(4096,(120,120),,,ROUND),UNIT=VIO,\n//         DCB=BUFNO=1\n//SYSPRINT DD   SYSOUT=*\n//SYSLIN   DD   DSN=&&OBJ,SPACE=(3040,(40,40),,,ROUND),UNIT=VIO,\n//         DISP=(MOD,PASS),\n//         DCB=(BLKSIZE=3040,LRECL=80,RECFM=FBS,BUFNO=1)\n//SYSIN    DD   DISP=SHR,DSN=TRLH.AFCSMP1.SRC(AFCSMP1)       <-- CHANGE\n//*--------------------------------------------------------------------\n// IF (RC<=4) THEN\n//LINK     EXEC PGM=HEWL,\n//         PARM='MAP,LIST,LET,RENT,REFR,REUS'\n//SYSLIN   DD   DSN=&&OBJ,DISP=(OLD,DELETE)\n//         DD   DDNAME=SYSIN\n//SYSLMOD  DD   DISP=SHR,DSN=TRLH.PDSE.LOAD                  <-- CHANGE\n//SYSUT1   DD   DSN=&&SYSUT1,SPACE=(1024,(120,120),,,ROUND),UNIT=VIO,\n//         DCB=BUFNO=1\n//SYSPRINT DD   SYSOUT=*\n//L.SYSIN  DD *\n NAME AFCSMP1(R)\n//*\n// ENDIF\n./ ADD NAME=CLEAR    0100-03199-03199-1052-00009-00009-00000-TRLH\n         MACRO\n         CLEAR &TEXT\n         AIF   (N'&TEXT NE 1).ERROR1\n         MVI   &TEXT,C' '\n         MVC   &TEXT+1(L'&TEXT-1),&TEXT\n         MEXIT\n.ERROR1  MNOTE 20,'*** MISSING OPERAND ***'\n         MEXIT\n         MEND\n./ ADD NAME=ENTERX   0100-03190-03190-0806-00149-00149-00000-TRLH\n         MACRO\n&SUBR    ENTERX &BASES,&SAVE,&CSECT,&AMODE=24,&RMODE=24\n.*   THIS MACRO, USED WITH THE LEAVE MACRO, WILL PERFORM\n.*   STANDARD HOUSEKEEPING FOR A CSECT, INCLUDING SAVEAREA\n.*   CONSTRUCTION AND CHAINING, AND GETTING SOME STORAGE,\n.*   IF THAT IS DESIRED.\n.*   THE LEAVE MACRO WILL FREE THE GOTTEN STORAGE\n.*   THE OPERANDS ARE\n.*       &SUBR    ENTER  &BASES,&SAVE,&CSECT,&AMODE=,&RMODE=\n.*    WHERE\n.*       &SUBR    IS THE NAME OF THE CSECT\n.*       &BASES   ARE THE BASE REGISTERS FOR THE ROUTINE\n.*       &SAVE    IS THE LABEL FOR A SAVEAREA, OR A SUBPOOL\n.*                AND LENGTH FOR THE STORAGE OBTAIN\n.*                OR, IF NUMERIC, THE OFFSET OFF OF R1 OF A PASSED\n.*                SAVEAREA TO USE. (,,C) TO CLEAR THE SAVEAREA\n.*       &CSECT   TO CONTINUE AN EXISTING CSECT WITH ENTRY\n.*                POINT &SUBR\n.*\n.*    EXAMPLES -\n.*               ENTER 13,*\n.*\n.*       THIS WILL GENERATE NON-REENTRANT CODE, USING SAVEAREA\n.*       AS THE SAVE AREA LABEL, AND REGISTER 13 FOR THE BASE\n.*       REGISTER.\n.*\n.*       RENTMOD  ENTER (12,11),(,LDSECT)\n.*\n.*       THIS WILL GENERATE REENTRANT CODE WITH REGISTERS 12 AND\n.*       11 FOR BASE REGISTERS.  A STORAGE OBTAIN WILL BE DONE FOR THE\n.*       DEFAULT SUBPOOL (0) WITH A LENGTH 'LDSECT'.\n.*\n         GBLC  &LV,&SP\n         LCLA  &K,&N\n         LCLC  &AREA,&B(16),&SUBNAME,&S\n&SUBNAME SETC  '&SUBR'\n         AIF   ('&SUBNAME' NE '').SUBSPEC\n&SUBNAME SETC  'MAIN'         DEFAULT CSECT NAME\n.SUBSPEC AIF   ('&CSECT' EQ '').NOTENT  IS IT AN ENTRY POINT?\n&CSECT   CSECT                          CONTINUE CSECT\n.SUBCONT ANOP\n&SUBNAME DS    0F\n         ENTRY &SUBNAME\n         SAVE  (14,12),T,'&CSECT &SYSDATE &SYSTIME &SUBNAME'\n         AGO   .CSSPEC\n.NOTENT  ANOP                           NEW CSECT\n&SUBNAME CSECT\n.SUBSTRT ANOP\n&SUBNAME RMODE &RMODE\n&SUBNAME AMODE &AMODE\n         ENTRY &SUBNAME\n         SAVE  (14,12),T,'&SUBNAME &SYSDATE &SYSTIME'\n.CSSPEC  ANOP\n         AIF   ('&BASES(1)' EQ '15' OR '&BASES' EQ '').R15SET\n         AIF   ('&BASES(1)' EQ '13' AND '&SAVE' NE '').R15SET\n         LR    &BASES(1),15  SET FIRST BASE REG\n.R15SET  CNOP  0,4\n&S       SETC  '&SUBNAME'\n         AIF   (N'&SAVE EQ 2).P4   SUBPOOL, SIZE SPEC?\n         AIF   ('&SAVE' EQ '').P3  NO SAVEAREA - DEFAULT\n&AREA    SETC  '&SAVE'\n         AIF   ('&SAVE' NE '*').P2\n&AREA    SETC  'SAVEAREA'\n.P2      AIF   ('&BASES(1)' NE '13').P4\n&S       SETC  '*'\n         USING &SUBNAME,15\n         ST    14,&AREA+4\n         LA    14,&AREA\n         ST    14,8(13)\n         L     14,&AREA+4\n         ST    13,&AREA+4\n         BAL   13,*+76        SKIP AROUND THE SAVEAREA\n         DROP  15\n         AGO   .P4\n.P3      AIF   ('&BASES(1)' NE '13').P4\n         MNOTE 8,'*** CONTENTS OF REG 13 ARE LOST.  NO SAVE AREA WAS ESX\n               TABLISHED.'\n.P4      AIF   ('&BASES(1)' NE '14' OR '&SAVE' EQ '').P5\n         MNOTE 8,'*** MACRO RESTRICTION - REG 14 MUST NOT BE USED AS THX\n               E FIRST BASE REGISTER IF A SAVE AREA IS USED.'\n.P5      AIF   ('&BASES' EQ '').P9\n&N       SETA  N'&BASES\n.P6      ANOP\n&K       SETA  &K+1\n&B(&K)   SETC  ','.'&BASES(&K)'\n         AIF   (N'&SAVE EQ 1).PE\n         AIF   ('&BASES(&K)' NE '13').P7\n         MNOTE 8,'*** REG 13 MAY NOT BE USED AS A BASE REGISTER FOR REEX\n               NTRANT CODE.'\n         AGO   .P7\n.PE      AIF   ('&BASES(&K+1)' NE '13' OR '&SAVE' EQ '').P7\n         MNOTE 8,'*** WHEN USING A SAVE AREA, REG 13 MAY NOT BE USED ASX\n                A SECONDARY BASE REGISTER.'\n.P7      AIF   ('&BASES(&K+1)' NE '').P6\n         USING &S&B(1)&B(2)&B(3)&B(4)&B(5)&B(6)&B(7)&B(8)&B(9)&B(10)&B(X\n               11)&B(12)&B(13)&B(14)&B(15)&B(16)\n&K       SETA  1\n         AIF   ('&BASES(1)' NE '13' OR '&SAVE' EQ '').P8\n&AREA    DC    18F'0'\n.P8      AIF   (&K GE &N).P10\n         LA    &BASES(&K+1),2048(,&BASES(&K))\n         LA    &BASES(&K+1),2048(,&BASES(&K+1))\n&K       SETA  &K+1\n         AGO   .P8\n.P9      USING &SUBNAME,15\n.P10     AIF   (N'&SAVE GE 2).P13\n         AIF   ('&SAVE' EQ '' OR '&BASES(1)' EQ '13').P12\n.*       AIF   ('&SAVE(1)' GE '0').P16  NUMERIC MEANS A PASSED AREA\n         AIF   (T'&SAVE(1) NE 'U').P16  NUMERIC MEANS A PASSED AREA\n         ST    14,&AREA+4\n         LA    14,&AREA\n         ST    14,8(13)\n         L     14,&AREA+4\n         ST    13,&AREA+4\n.P11     BAL   13,*+76       SKIP AROUND THE SAVEAREA\n&AREA    DC    18F'0'\n.P12     MEXIT\n.P13     ANOP\n&LV      SETC  '&SAVE(2)'\n&SP      SETC  '0'\n         AIF   ('&SAVE(1)' EQ '').P14\n&SP      SETC  '&SAVE(1)'\n.P14     ANOP               DO A STORAGE OBTAIN FOR THE AREA\n         STORAGE OBTAIN,LENGTH=&LV,SP=&SP,LOC=BELOW\n.*                            CHAIN THE SAVEAREAS\n         XC    0(4,1),0(1)    ZERO FIRST WORD\n         ST    13,4(1)        PRIOR SAVEAREA ADDRESS TO MINE\n         ST    1,8(13)        MY SAVEAREA ADDRESS TO HIS\n         LR    2,13           KEEP THE SAVEAREA ADDRESS FOR REGS\n         LR    13,1           THIS IS MY SAVEAREA\n         AIF   ('&SAVE(3)' NE 'C').P15   CLEAR THE SAVEAREA?\n         LA    4,12(,13)      YES, POINT PAST THE CHAIN\n         L     5,=A(&LV)      GET THE SIZE\n         LA    6,12           MINUS THE CHAIN AREA (12 BYTES )\n         SR    5,6            GIVES THE AMOUNT TO CLEAR\n         SR    7,7            CLEAR THE FROM COUNT AND CLEAR BYTE\n         MVCL  4,6            WHEE, CLEAR IT OUT\n         LM    14,7,12(2)     RESTORE THE ORIGINAL REGISTERS\n         MEXIT\n.P15     ANOP\n         LM    14,2,12(2)     RESTORE ORIGINAL REGS\n         MEXIT\n.P16     L     1,&AREA+0(1)   NUMERIC &SAVE IMPLIES A PASSED SAVEAREA\n         ST    13,4(1)        PRIOR SAVEAREA ADDRESS TO MINE\n         ST    1,8(13)        MY SAVEAREA ADDRESS TO HIS\n         LR    2,13           KEEP THE SAVEAREA ADDRESS FOR REGS\n         LR    13,1           THIS IS MY SAVEAREA\n         LM    0,2,20(2)      RESTORE ORIGINAL REGS\n         MEND\n./ ADD NAME=EXECJCL  0103-03190-03192-0824-00034-00022-00000-TRLH\n//TRLHCJCL JOB (TRLH,6C,),\n//            'Rich Hobt',\n//            MSGCLASS=T,\n//            NOTIFY=&SYSUID,\n//            CLASS=T\n//DEFAULT  OUTPUT CLASS=*,JESDS=ALL,DEFAULT=YES,\n//     NAME=('Rich Hobt'),\n//     ROOM=('6C'),\n// BUILDING=('Western'),\n//     DEPT=('SYSW'),\n//  ADDRESS=('3101 Western Ave.',\n//           'Seattle, WA.  98121',\n//           'U.S.A.',\n//           'Planet Earth')\n//*\n//*  This JCL is from: TRLH.AFCSMP1.SRC(EXECJCL)\n//*\n//*---------------------------------------------------------------------\n//AFCSMP1  EXEC PGM=AFCSMP1,REGION=64M\n//SYSUDUMP DD   SYSOUT=*\n//GIMPRINT DD   SYSOUT=*\n//GIMOUT   DD   SYSOUT=*,RECFM=VB,LRECL=1028,BLKSIZE=27998\n//GIMIN    DD   *\n* Report all function sysmods in all zones in the given csi\nCSI SYSS.GLOBAL.CSI\nZONE *\nENTRY SYSMOD\n*  Include the FMID, description, feature number, FESN, install date,\n*  and install time.\nSUBENTRY ENAME,DESCRIPTION,FESN,INSTALLDATE,INSTALLTIME\n*  Only take sysmods applied/accepted, and those that are not in error\n*  or SUPed\nFILTER (SMODTYPE='FUNCTION')&((APPLY='YES')|(ACCEPT='YES'))            *\n&(LASTSUP='')&(ERROR='NO')\n./ ADD NAME=FUNCLIST 0103-03192-03338-1052-00614-00595-00000-TRLH\n//TRLHLIST JOB (TRLH,6C,),\n//            'Rich Hobt',\n//            MSGCLASS=T,\n//            NOTIFY=&SYSUID,\n//            CLASS=X\n/*JOBPARM K=0\n//*XEQ    AFEX01\n//DEFAULT  OUTPUT CLASS=*,JESDS=ALL,DEFAULT=YES,\n//     NAME=('Rich Hobt'),\n//     ROOM=('6C'),\n// BUILDING=('Western'),\n//     DEPT=('SYSW'),\n//  ADDRESS=('3101 Western Ave.',\n//           'Seattle, WA.  98121',\n//           'U.S.A.',\n//           'Planet Earth')\n//*\n//*  This JCL is from: TRLH.SAS2.CNTL(FUNCLIST)\n//*\n//********************************************************************/\n//*                                                                  */\n//* THIS JOB PRODUCES A SCRIPT/VS DATA STREAM TO PRINT A TABLE       */\n//* SHOWING ALL FUNCTIONS RECEIVED, APPLIED, AND/OR ACCEPTED IN ALL  */\n//* THE ZONES ASSOCIATED WITH A GIVEN SMPE GLOBAL ZONE.  IT ALSO     */\n//* PRODUCES REPORTS SHOWING FMIDS NEEDING TO BE APPLIED, ACCEPTED,  */\n//* OR REJECTED.  THE REPORTS ARE IN SCRIPT INPUT FORMAT AND ARE     */\n//* PLACED IN SYSW.MVS.DOC MEMBERS STARTING WITH #FUNC.              */\n//*                                                                  */\n//* 02/23/00  PKS   Put HTML in dataset                              */\n//*                                                                  */\n//* 10/07/97  TRLH  Extract zone name from global zone to use        */\n//*                 in headings.                                     */\n//*                                                                  */\n//* 09/16/97  TRLH  ADD REPORTS FOR GLOBAL ZONE FMIDS TO BE          */\n//*                 ADDED AND DELETED                                */\n//* 12/20/96  TRLH  ADD HTML OUTPUT                                  */\n//*                                                                  */\n//********************************************************************/\n//*                                                                  */\n//* MAKE SURE THAT THE ZONE AND GZONE VARIABLES ARE SET CORRECTLY\n//*\n// SET ZONE=IBM                 IBM\n// SET GZONE=SYSS.GLOBAL.CSI\n//*\n//*SET ZONE=CA                   COMPUTER ASSOCIATES\n//*SET GZONE=SYSS.CA.GLOBAL.CSI\n//*\n//*SET ZONE=BB                   BOOLE\n//*SET GZONE=SYSS.GLOBAL.CSI\n//*\n//*SET ZONE=BET                  BETA\n//*SET GZONE=SYSS.GLOBAL.CSI\n//*\n//*SET ZONE=CCC                  CANDLE CC\n//*SET GZONE=SYSS.GLOBAL.CSI\n//*\n//*SET ZONE=COG                  CANDLE OG\n//*SET GZONE=SYSS.GLOBAL.CSI\n//*\n//*SET ZONE=CW                   COMPUWARE\n//*SET GZONE=SYSS.GLOBAL.CSI\n//*\n//*--------------------------------------------------------------------\n//SAS      EXEC SAS,PARM='SORT=4,SYSPARM=&ZONE./&GZONE.'\n//GIMIN    DD   DISP=(NEW,PASS),DSN=&&SYSIN,\n//  UNIT=VIO,SPACE=(TRK,(5,5)),\n//  RECFM=FB,LRECL=80,BLKSIZE=0\n//GIMOUT   DD   DISP=(NEW,PASS),DSN=&&SYSOUT,\n//  UNIT=SYSDA,SPACE=(TRK,(90,90)),\n//  RECFM=VB,LRECL=1028,BLKSIZE=0\n//GIMPRINT DD   SYSOUT=*\n//FMIDXRF  DD   DISP=SHR,DSN=SYSW.FMIDXRF.DATA\n//REPORT   DD   DISP=SHR,DSN=SYSW.MVS.DOC(#Z&ZONE.TAB)\n//APPFMID  DD   DISP=SHR,DSN=SYSW.MVS.DOC(#Z&ZONE.APP)\n//ACCFMID  DD   DISP=SHR,DSN=SYSW.MVS.DOC(#Z&ZONE.ACC)\n//REJFMID  DD   DISP=SHR,DSN=SYSW.MVS.DOC(#Z&ZONE.REJ)\n//DELFMID  DD   DISP=SHR,DSN=SYSW.MVS.DOC(#Z&ZONE.GZD)\n//ADDFMID  DD   DISP=SHR,DSN=SYSW.MVS.DOC(#Z&ZONE.GZA)\n//HTML     DD   DISP=SHR,DSN=SYSW.MVS.DOC.HTML(#Z&ZONE.HTM)\n//*REPORT   DD   SYSOUT=*\n//*APPFMID  DD   SYSOUT=*\n//*ACCFMID  DD   SYSOUT=*\n//*REJFMID  DD   SYSOUT=*\n//*DELFMID  DD   SYSOUT=*\n//*ADDFMID  DD   SYSOUT=*\n//*HTML     DD   SYSOUT=*\n//SYSIN    DD   *\n  OPTIONS LS=255 VSAMLOAD NOMPRINT SYMBOLGEN NODATE NONUMBER NOSOURCE2\n          NOMACROGEN NOCENTER;\n\n  /*\n  ** RETRIEVE THE ZONE INDEX AND FMID LIST FROM THE GLOBAL ZONE\n  */\n\n  DATA _NULL_;\n    FILE GIMIN NOPRINT OLD ;\n    PARMS = SYSPARM();\n    ZONE  = SCAN(PARMS,1,'/');\n    GZONE  = SCAN(PARMS,2,'/');\n    CALL SYMPUT('ZONE',ZONE);\n    PUT \"CSI \" GZONE;\n    PUT \"ZONE GLOBAL                                       \";\n    PUT \"ENTRY GLOBALZONE                                  \";\n    PUT \"SUBENTRY ZONEINDEX,FMID                           \";\n    STOP;\n\n  PROC AFCSMP1;\n\n  DATA ZONES (KEEP=ZONE ZONETYP)\n       GZFMID (KEEP=FMID)\n    ;\n    RETAIN SUBENTRY \"         \"\n      ;\n    INFILE GIMOUT LENGTH=LEN;\n    INPUT @1 ALINE $VARYING200. LEN;\n    IF INDEX(ALINE,\"SUBENTRY=\") > 0 THEN DO;\n       SUBENTRY = SCAN(ALINE,2,\"=\");\n       RETURN;\n    END;\n    IF SUBENTRY = \"FMID\" THEN DO;\n       FMID = ALINE;\n       OUTPUT GZFMID;\n       RETURN;\n    END;\n    IF SUBENTRY = \"ZONEINDEX\" THEN DO;\n       ZONE = SCAN(ALINE,1,\",\");\n       ZONETYP = SCAN(ALINE,3,\",\");\n       OUTPUT ZONES;\n       RETURN;\n    END;\n\n  PROC SORT DATA=GZFMID; BY FMID;\n\n  /*\n  ** RETRIEVE THE GLOBAL ZONE FUNCTIONS\n  */\n\n  DATA _NULL_;\n    FILE GIMIN NOPRINT OLD ;\n    PARMS = SYSPARM();\n    GZONE  = SCAN(PARMS,2,'/');\n    PUT \"CSI \" GZONE;\n    PUT \"ZONE GLOBAL                                       \";\n    PUT \"ENTRY SYSMOD                                      \";\n    PUT \"SUBENTRY ENAME,DESCRIPTION,FESN,RECDATE,RECTIME   \";\n    PUT \"FILTER (SMODTYPE='FUNCTION')&(ERROR='NO')         \";\n    STOP;\n\n  PROC AFCSMP1;\n\n  DATA GLOBAL;\n    INFILE GIMOUT LENGTH=LEN EOF=EOF;\n    FORMAT INSTDATE DATE.\n           INSTTIME TIME.\n      ;\n    LENGTH DESCR $64;\n    RETAIN NOTFIRST 0\n           FMID     \"       \"\n           FESN     \"        \"\n           ZONE     \"       \"\n           DESCR\n           INSTDATE\n           INSTTIME\n      ;\n    KEEP FMID\n         ZONE\n         FESN\n         DESCR\n         INSTDATE\n         INSTTIME\n      ;\n    INPUT @1 ALINE $VARYING200. LEN;\n    IF ALINE =: \"TYPE=SYSMOD\" THEN DO;  /* NEW SYSMOD */\n       IF NOTFIRST THEN OUTPUT;\n       NOTFIRST = 1;\n       FESN     = \"       \";\n       DESCR    = REPEAT(\" \",64);\n       INSTDATE = 0;\n       INSTTIME = 0;\n       INPUT @1 ALINE $VARYING200. LEN;\n       FMID = SCAN(ALINE,1);\n       ZONE = SCAN(ALINE,2);\n       RETURN;\n    END;\n    IF ALINE =: \"SUBENTRY=DESCRIPTION\" THEN DO;\n       INPUT @1 DESCR $VARYING200. LEN;\n       RETURN;\n    END;\n    IF ALINE =: \"SUBENTRY=FESN\" THEN DO;\n       INPUT @1 FESN $VARYING200. LEN;\n       RETURN;\n    END;\n    IF ALINE =: \"SUBENTRY=RECDATE\" THEN DO;\n       INPUT @1 ALINE $VARYING200. LEN;\n       INSTDATE = DATEJUL(ALINE);\n       RETURN;\n    END;\n    IF ALINE =: \"SUBENTRY=RECTIME\" THEN DO;\n       INPUT @1 ALINE $VARYING200. LEN;\n       INSTTIME = HMS(SCAN(ALINE,1,\":\"),SCAN(ALINE,2,\":\"),SCAN(ALINE,3,\":\"));\n       RETURN;\n    END;\n    RETURN;\n\n  EOF:\n    OUTPUT;\n\n  /*\n  ** RETRIEVE THE TARGET AND DLIB ZONE FUNCTIONS\n  */\n\n  DATA _NULL_;\n    FILE GIMIN NOPRINT OLD ;\n    PARMS = SYSPARM();\n    GZONE  = SCAN(PARMS,2,'/');\n    PUT \"CSI \" GZONE;\n    PUT \"ZONE *\";\n    PUT \"ENTRY SYSMOD\";\n    PUT \"SUBENTRY ENAME,DESCRIPTION,FESN,INSTALLDATE,INSTALLTIME\";\n    PUT \"FILTER (SMODTYPE='FUNCTION')&((APPLY='YES')|(ACCEPT='YES'))\" @72 \"*\";\n    PUT \"&(LASTSUP='')&(ERROR='NO')\";\n    STOP;\n\n  PROC AFCSMP1;\n\n  DATA TARGDLIB;\n    INFILE GIMOUT LENGTH=LEN EOF=EOF;\n    FORMAT INSTDATE DATE.\n           INSTTIME TIME.\n      ;\n    LENGTH DESCR $64;\n    RETAIN NOTFIRST 0\n           FMID     \"       \"\n           FESN     \"        \"\n           ZONE     \"       \"\n           DESCR\n           INSTDATE\n           INSTTIME\n      ;\n    KEEP FMID\n         ZONE\n         FESN\n         DESCR\n         INSTDATE\n         INSTTIME\n      ;\n    INPUT @1 ALINE $VARYING200. LEN;\n    IF ALINE =: \"TYPE=SYSMOD\" THEN DO;  /* NEW SYSMOD */\n       IF NOTFIRST THEN OUTPUT;\n       NOTFIRST = 1;\n       FESN     = \"       \";\n       DESCR    = REPEAT(\" \",64);\n       INSTDATE = 0;\n       INSTTIME = 0;\n       INPUT @1 ALINE $VARYING200. LEN;\n       FMID = SCAN(ALINE,1);\n       ZONE = SCAN(ALINE,2);\n       RETURN;\n    END;\n    IF ALINE =: \"SUBENTRY=DESCRIPTION\" THEN DO;\n       INPUT @1 DESCR $VARYING200. LEN;\n       RETURN;\n    END;\n    IF ALINE =: \"SUBENTRY=FESN\" THEN DO;\n       INPUT @1 FESN $VARYING200. LEN;\n       RETURN;\n    END;\n    IF ALINE =: \"SUBENTRY=INSTALLDATE\" THEN DO;\n       INPUT @1 ALINE $VARYING200. LEN;\n       INSTDATE = DATEJUL(ALINE);\n       RETURN;\n    END;\n    IF ALINE =: \"SUBENTRY=INSTALLTIME\" THEN DO;\n       INPUT @1 ALINE $VARYING200. LEN;\n       INSTTIME = HMS(SCAN(ALINE,1,\":\"),SCAN(ALINE,2,\":\"),SCAN(ALINE,3,\":\"));\n       RETURN;\n    END;\n    RETURN;\n\n  EOF:\n    OUTPUT;\n\n  /* SORT ALL THE FUNCTIONS BY ZONE                               */\n\n  PROC SORT DATA=GLOBAL; BY ZONE FMID;\n  PROC SORT DATA=TARGDLIB; BY ZONE FMID;\n  PROC SORT DATA=ZONES;    BY ZONE;\n\n  DATA FUNCTION;\n    MERGE GLOBAL\n          TARGDLIB\n          ZONES\n          ;\n    BY ZONE;\n\n  PROC SORT DATA=FUNCTION OUT=FUNCTION NODUPS; BY FMID;\n\n  /*PROC PRINT UNIFORM NOOBS DATA=FUNCTION;*/\n\n  /* PRODUCE A SAS DATASET CONTAINING FMIDS, DESCRIPTIONS, AND    */\n  /* PRODUCT NUMBERS SO WE CAN MAKE A PRETTY REPORT.              */\n\n  DATA FMIDXRF;\n    INFILE FMIDXRF;\n    LENGTH DESC_EXT $64;\n    DROP DESC1 DESC2;\n    INPUT @1  DESC2    $CHAR20.\n          @22 FMID     $CHAR7.\n          @31 PGMNO    $CHAR7.\n          @39 COMPID   $CHAR9.\n          @49 REL      $CHAR3.\n          @93 DESC1    $CHAR29.\n      ;\n    DESC_EXT = TRIM(DESC1) || \" \" || DESC2;\n    IF SUBSTR(DESC2,1,1) NE \"*\" THEN OUTPUT;\n\n  PROC SORT DATA=FMIDXRF; BY FMID;\n\n  DATA ACCEPTED\n       APPLIED\n       BOTH;\n    MERGE FUNCTION(IN=APPLIED)\n          FMIDXRF(IN=HASDESC);\n    BY FMID;\n    IF APPLIED;\n    IF DESCR = \"\" THEN DESCR = DESC_EXT;\n    IF DESCR = \"\" THEN DESCR = \"???\";\n    IF ZONETYP =: \"DLIB\" THEN OUTPUT ACCEPTED;\n                         ELSE OUTPUT APPLIED;\n    OUTPUT BOTH;\n\n  PROC SORT DATA=BOTH; BY ZONE FMID;\n\n  PROC PRINT DATA=BOTH UNIFORM NOOBS;\n  TITLE \"FMIDS BY ZONE \";\n  BY ZONE;\n  PAGEBY ZONE;\n  VAR FMID DESCR INSTDATE;\n\n  PROC SORT DATA=BOTH; BY FMID INSTDATE ZONE;\n\n  DATA GZOK\n       GZADD\n       GZDEL0\n    ;\n    MERGE GZFMID(IN=INGZONE)\n          BOTH(IN=INUSE)\n      ;\n      BY FMID;\n    IF INGZONE AND INUSE THEN OUTPUT GZOK;\n    IF INGZONE AND NOT INUSE THEN OUTPUT GZDEL0;\n    IF NOT INGZONE AND INUSE THEN OUTPUT GZADD;\n\n /*\n ** The fmids deserving deletion from the global zone fmid list\n ** don't have descriptions from smpe, so try to get them from\n ** the FMIDXRF data.\n */\n\n    DATA GZDEL;\n    MERGE GZDEL0(IN=KEEPIT)\n          FMIDXRF\n      ;\n    BY FMID;\n    DESCR = DESC_EXT;\n    IF KEEPIT;\n\nPROC SORT DATA=GZDEL NODUPKEY; BY FMID;\nPROC SORT DATA=GZADD NODUPKEY; BY FMID;\n\nDATA _NULL_;\n  RETAIN X     -1\n         ONOFF 0\n    ;\n  TODAE = DATE();\n  TYME = TIME();\n  TODAY = TRIM(LEFT(PUT(TODAE,WORDDATE.))) || \" \" || TRIM(PUT(TYME,TIME5.));\n  SET BOTH END=THATSALL;\n    BY FMID;\n  IF _N_ = 1 THEN DO;\n   /* DCF */\n    FILE REPORT NOPRINT;\n    PUT \".* SMPE ACTIVE FMIDS (By FMID)                              \";\n    PUT \".*                                                          \";\n    PUT \".*                                                          \";\n    PUT \".* if this member is being formatted on its own (not part   \";\n    PUT \".* of $MANUAL) define the 'menu' font.  Otherwise it is     \";\n    PUT \".* defined in $MANUAL.                                      \";\n    PUT \".*                                                          \";\n    PUT \".if &$PN = 0                                                \";\n    PUT \".th .df menu type('gothic' 08) codepage T1D0BASE            \";\n    PUT \".rh on                                                      \";\n    PUT \"&ZONE FUNCTIONs installed at AFC (\" TODAY +X \")\";\n    PUT \".sp                                                         \";\n    PUT \".rh off                                                     \";\n    PUT \".*                                                          \";\n    PUT \".* use 'menu' font because it's small (8 point)             \";\n    PUT \".*                                                          \";\n    PUT \".bf menu                                                    \";\n    PUT \".if &$LDEV eq 38PPNS90 .go p3800                            \";\n    PUT \".if &$LDEV eq AFPA     .go p3800                            \";\n    PUT \".*                                                          \";\n    PUT \".* set table definition for a dataset (wider width)         \";\n    PUT \".*                                                          \";\n    PUT \":rdef id=ractid cwidths='9m 20m 9m 11m 5m *'                \";\n    PUT \"      align='left left center center center left'           \";\n    PUT \"      valign='center center center center center center'    \";\n    PUT \"      concat = 'yes no yes yes yes no'                      \";\n    PUT \":table id=actid refid=ractid split=yes width=74m            \";\n    PUT \".go table                                                   \";\n    PUT \"...p3800                                                    \";\n    PUT \".*                                                          \";\n    PUT \".* set table definition for a 3800 (default width)          \";\n    PUT \".*                                                          \";\n    PUT \":rdef id=ractid cwidths='10m 32m 10m 13m 6m *'              \";\n    PUT \"      align='left left center center center left'           \";\n    PUT \"      valign='center center center center center center'    \";\n    PUT \"      concat = 'yes no yes yes yes no'                      \";\n    PUT \":table id=actid refid=ractid split=yes                      \";\n    PUT \"...table                                                    \";\n    PUT \".*                                                          \";\n    PUT \".* build the table rows                                     \";\n    PUT \".*                                                          \";\n    PUT \":thd                                                        \";\n    PUT \":c.FMID :c.DESCRIPTION :c.PGMNO :c.COMPID :c.REL :c.ZONES   \";\n    PUT \":ethd                                                       \";\n   /* HTML */\n    FILE HTML NOPRINT;\n    PUT \"<HTML>                                                     \";\n    PUT \"<HEAD>                                                     \";\n    PUT \"<TITLE>&ZONE SMPE Function List</TITLE>                \";\n    PUT \"</HEAD>                                                    \";\n    PUT \"<H2><CENTER>&ZONE SMPE Functions</CENTER></H2>      \";\n    PUT \"<BODY><P><P>                                               \";\n    PUT \"<!-- SMPE ACTIVE FMIDS (BY FMID)                         -->\";\n    PUT \"<!--                                                     -->\";\n    PUT \"<CENTER>\";\n    PUT \"<TABLE BORDER=1 WIDTH=99% CELLSPACING=1 CELLPADDING=1>     \";\n    PUT \"<CAPTION>&ZONE FMIDs installed at AFC as of \" TODAY @;\n    PUT \"</CAPTION>\";\n    PUT \" \";\n    PUT \"<TR ALIGN=CENTER VALIGN=MIDDLE>\";\n    PUT \" <TD BGCOLOR='FFC0C0'>FMID</TD>\";\n    PUT \" <TD BGCOLOR='FFC0C0'>Description</TD>\";\n    PUT \" <TD BGCOLOR='FFC0C0'>Pgm. no.</TD>\";\n    PUT \" <TD BGCOLOR='FFC0C0'>Comp. ID</TD>\";\n    PUT \" <TD BGCOLOR='FFC0C0'>Rel</TD>\";\n    PUT \" <TD BGCOLOR='FFC0C0'>ZONE(s)</TD>\";\n    PUT \"</TR>\";\n    PUT \" \";\n  END;\n  IF FIRST.FMID THEN DO;\n    IF ONOFF = 1 THEN DO;\n       BG = \"BGCOLOR='FFFFFF'\";\n       ONOFF = 0;\n    END;\n    ELSE DO;\n       BG = \"BGCOLOR='COFFCO'\";\n       ONOFF = 1;\n    END;\n   /* DCF */\n    FILE REPORT NOPRINT;\n    PUT \":row\";\n    PUT \":c.\" FMID;\n    PUT \":C.\" DESCR;\n    /*IF DESC2 NE \"\" THEN PUT DESC2;*/\n    PUT \":c.\" PGMNO;\n    PUT \":c.\" COMPID;\n    PUT \":c.\" REL;\n    PUT \":c.\" ZONE INSTDATE MMDDYY.;\n   /* HTML */\n    FILE HTML NOPRINT;\n    PUT \"<TR>\";\n    PUT \" <TD ALIGN=CENTER \" BG \">\" FMID \"</TD>\";\n    PUT \" <TD \" BG \">\" DESCR \"</TD>\";\n    IF PGMNO NE \"\" THEN PUT \" <TD \" BG \">\" PGMNO \"</TD>\";\n       ELSE PUT \" <TD \" BG \">&nbsp</TD>\";\n    IF COMPID NE \"\" THEN PUT \" <TD \" BG \">\" COMPID \"</TD>\";\n       ELSE PUT \" <TD \" BG \">&nbsp</TD>\";\n    IF REL NE \"\" THEN PUT \" <TD \" BG \">\" REL \"</TD>\";\n       ELSE PUT \" <TD \" BG \">&nbsp</TD>\";\n    IF LAST.FMID THEN PUT \" <TD \" BG \">\" ZONE INSTDATE MMDDYY. \"</TD></TR>\";\n                 ELSE PUT \" <TD \" BG \">\" ZONE INSTDATE MMDDYY. ;\n  END;\n  ELSE DO;\n   /* DCF */\n    FILE REPORT NOPRINT;\n    PUT ZONE INSTDATE MMDDYY.;\n   /* HTML */\n    FILE HTML NOPRINT;\n    IF LAST.FMID THEN PUT \" <BR />\" ZONE INSTDATE MMDDYY. \"</TD></TR>\";\n                 ELSE PUT \" <BR />\" ZONE INSTDATE MMDDYY. ;\n  END;\n  IF THATSALL = 1 THEN DO;\n   /* DCF */\n    FILE REPORT NOPRINT;\n    PUT \".*                                                          \";\n    PUT \".* set the caption and end the table                        \";\n    PUT \".*                                                          \";\n    PUT \":TCAP.&ZONE FMIDs installed at Airborne (as of \" TODAY +X \")\";\n    PUT \":etable.                                                    \";\n    PUT \".*                                                          \";\n    PUT \".* restore font to whatever it was previously and cancel    \";\n    PUT \".* the running heading.                                     \";\n    PUT \".*                                                          \";\n    PUT \".rh cancel                                                  \";\n    PUT \".pf                                                         \";\n   /* HTML */\n    FILE HTML NOPRINT;\n    PUT \"</TABLE>\";\n    PUT \"</CENTER>\";\n    PUT \"</body>\";\n    PUT \"</html>\";\n  END;\n\nDATA NAPPLY\n     NACCEPT\n     NREJECT\n  ;\n  RETAIN GLOBAL 0\n         DLIB   0\n         TARGET 0\n    ;\n  DROP DLIB TARGET GLOBAL;\n  SET BOTH;\n    BY FMID;\n  IF ZONETYP =: \"DLIB\" THEN DLIB = DLIB + 1;\n  IF ZONETYP =: \"TARGET\" THEN TARGET = TARGET + 1;\n  IF ZONE =: \"GLOBAL\" THEN GLOBAL = GLOBAL + 1;\n  IF LAST.FMID THEN DO;\n     IF TARGET = 0 AND GLOBAL > 0 THEN OUTPUT NAPPLY;\n     IF TARGET > 0 AND DLIB = 0 THEN OUTPUT NACCEPT;\n     IF DLIB > 0 AND GLOBAL > 0 THEN OUTPUT NREJECT;\n     GLOBAL = 0;\n     DLIB = 0;\n     TARGET = 0;\n  END;\n\n /*PROC PRINT UNIFORM NOOBS DATA=BOTH;\nTITLE \"DIAGNOSTIC OUTPUT - DATASET BOTH\";*/\n\nDATA _NULL_;\n  RETAIN X -1;\n  TODAE = DATE();\n  TODAY = TRIM(LEFT(PUT(TODAE,WORDDATE.)));\n  FILE APPFMID NOPRINT;\n  SET NAPPLY END=THATSALL;\n  IF _N_ = 1 THEN DO;\n     PUT \".SP\";\n     PUT \"FMID's in need of APPLY (as of \" TODAY +X \"):\";\n     PUT \":ul\";\n  END;\n  PUT \":LI.\" FMID DESCR \"(RECEIVED \" INSTDATE +X \")\";\n  IF THATSALL THEN PUT \":EUL\";\n\nDATA _NULL_;\n  RETAIN X -1;\n  TODAE = DATE();\n  TODAY = TRIM(LEFT(PUT(TODAE,WORDDATE.)));\n  FILE ACCFMID NOPRINT;\n  SET NACCEPT END=THATSALL;\n  IF _N_ = 1 THEN DO;\n     PUT \".SP\";\n     PUT \"FMID's in need of ACCEPT (as of \" TODAY +X \"):\";\n     PUT \":ul\";\n  END;\n  IF ZONE = \"TARGFOC\" THEN RETURN;\n  PUT \":LI.\" FMID ZONE DESCR;\n  IF THATSALL THEN PUT \":EUL\";\n\nDATA _NULL_;\n  RETAIN X -1;\n  TODAE = DATE();\n  TODAY = TRIM(LEFT(PUT(TODAE,WORDDATE.)));\n  FILE REJFMID NOPRINT;\n  SET NREJECT END=THATSALL;\n  IF _N_ = 1 THEN DO;\n     PUT \".SP\";\n     PUT \":H2.FMID's in need of REJECTion (as of \" TODAY +X \"):\";\n     PUT \":ul\";\n  END;\n  PUT \":LI.\" FMID ZONE DESCR;\n  IF THATSALL THEN PUT \":EUL\";\n\nDATA _NULL_;\n  RETAIN X -1;\n  TODAE = DATE();\n  TODAY = TRIM(LEFT(PUT(TODAE,WORDDATE.)));\n  FILE DELFMID NOPRINT;\n  SET GZDEL END=THATSALL;\n  IF _N_ = 1 THEN DO;\n     PUT \".SP\";\n     PUT \":H2.FMID'S in GLOBAL zone FMID list but shouldn't be \";\n     PUT \"(as of \" TODAY +X \"):\";\n     PUT \":ul\";\n  END;\n  PUT \":LI.\" FMID DESCR;\n  IF THATSALL THEN PUT \":EUL\";\n\nDATA _NULL_;\n  RETAIN X -1;\n  TODAE = DATE();\n  TODAY = TRIM(LEFT(PUT(TODAE,WORDDATE.)));\n  FILE ADDFMID NOPRINT;\n  SET GZADD END=THATSALL;\n  IF _N_ = 1 THEN DO;\n     PUT \".SP\";\n     PUT \":H2.FMID'S not in GLOBAL zone FMID list that should be \";\n     PUT \"(as of \" TODAY +X \"):\";\n     PUT \":ul\";\n  END;\n  PUT \":LI.\" FMID ZONE DESCR;\n  IF THATSALL THEN PUT \":EUL\";\n/*\n./ ADD NAME=LEAVEX   0100-03190-03190-0807-00014-00014-00000-TRLH\n         MACRO\n&NAME    LEAVEX &EQ,&RC=\n         GBLC  &LV,&SP\n&NAME    LR    2,13\n         L     13,4(13)\n         AIF   ('&RC' EQ '').L0\n         LA    15,&RC         LOAD THE RETURN CODE\n.L0      STM   15,1,16(13)  STORE RETURN REGS\n         AIF   ('&LV' EQ '').L1  ANYTHING TO FREE?\n         STORAGE RELEASE,LENGTH=&LV,SP=&SP,ADDR=(2)\n.L1      RETURN (14,12),T     RETURN FROM WHENCE WE CAME\n         AIF   ('&EQ' NE 'EQ').L4  REGISTERS TOO?\n         EQUREGS\n.L4      MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "ASMINFO": {"ttr": 2313, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00X\\x01\\x06&\\x8f\\x01\\x06&\\x8f\\x14\\x19\\x00!\\x00!\\x00\\x00\\xe3\\xd9\\xd3\\xc8@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2006-09-25T00:00:00", "modifydate": "2006-09-25T14:19:58", "lines": 33, "newlines": 33, "modlines": 0, "user": "TRLH"}, "text": "         MACRO\n&LBL     ASMINFO\n.**********************************************************************\n.*\n.*  THIS MACRO PRODUCES A CONSTANT STRING IDENTIFYING THE TIME,\n.*  DATE, DATASET, MEMBER, AND JOBNAME OF THE ASSEMBLY OF THE\n.*  INVOKING PROGRAM.\n.*\n.* *IMPORTANT*\n.*\n.*  In order to produce the correct results, the macro source member\n.*  must be in the same PDS as the source member, and this PDS should\n.*  be 1st in the syslib concatenation.  This is because the DSN and\n.*  MEMBER symbols are local in scope and reflect the MACRO source\n.*  rather than the assembler program.\n.*\n.**********************************************************************\n         DC    C'Assembled by job '\n         DC    C'&SYSJOB'\n         DC    c' at '\n         DC    C'&SYSTIME'\n         DC    C' on '\n         DC    C'&SYSDATE'\n         AIF   ('&SYSLIB_DSN' NE '&SYSIN_DSN').ERR1\n         DC    C' from dataset '\n         DC    C'&SYSIN_DSN'\n         DC    C'('\n         DC    C'&SYSIN_MEMBER'\n         DC    C')'\n         MEXIT\n.ERR1    MNOTE *,'ASMINFO MACRO SOURCE SHOULD BE IN THE SAME LIBRARY AS*\n                THE ASSEMBLER SOURCE.'\n         MEND\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "ASMJCL": {"ttr": 2315, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00G\\x01\\x03\\x19\\x0f\\x01\\x03\\x19\\x0f\\x08\"\\x00+\\x00+\\x00\\x00\\xe3\\xd9\\xd3\\xc8@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-07-09T00:00:00", "modifydate": "2003-07-09T08:22:47", "lines": 43, "newlines": 43, "modlines": 0, "user": "TRLH"}, "text": "//TRLHMJCL JOB (TRLH,6C,),\n//            'Rich Hobt',\n//            MSGCLASS=T,\n//            NOTIFY=&SYSUID,\n//            CLASS=X\n//DEFAULT  OUTPUT CLASS=*,JESDS=ALL,DEFAULT=YES,\n//     NAME=('Rich Hobt'),\n//     ROOM=('6C'),\n// BUILDING=('Western'),\n//     DEPT=('SYSW'),\n//  ADDRESS=('3101 Western Ave.',\n//           'Seattle, WA.  98121',\n//           'U.S.A.',\n//           'Planet Earth')\n//*\n//*  This JCL is from: TRLH.AFCLOGR1.SRC(ASMJCL)\n//*\n//ASM      EXEC PGM=ASMA90,\n//         PARM='OBJECT,NODECK,XREF(FULL),RENT'\n//SYSLIB   DD   DISP=SHR,DSN=SYS1.MACLIB\n//         DD   DISP=SHR,DSN=SYS1.MODGEN\n//         DD   DISP=SHR,DSN=TRLH.AFCLOGR1.SRC               <-- CHANGE\n//SYSUT1   DD   DSN=&&SYSUT1,SPACE=(4096,(120,120),,,ROUND),UNIT=VIO,\n//         DCB=BUFNO=1\n//SYSPRINT DD   SYSOUT=*\n//SYSLIN   DD   DSN=&&OBJ,SPACE=(3040,(40,40),,,ROUND),UNIT=VIO,\n//         DISP=(MOD,PASS),\n//         DCB=(BLKSIZE=3040,LRECL=80,RECFM=FBS,BUFNO=1)\n//SYSIN    DD   DISP=SHR,DSN=TRLH.AFCLOGR1.SRC(AFCLOGR1)     <-- CHANGE\n//*--------------------------------------------------------------------\n// IF (RC<=4) THEN\n//LINK     EXEC PGM=HEWL,\n//         PARM='MAP,LIST,LET,RENT,REFR,REUS'\n//SYSLIN   DD   DSN=&&OBJ,DISP=(OLD,DELETE)\n//         DD   DDNAME=SYSIN\n//SYSLMOD  DD   DISP=SHR,DSN=TRLH.PDSE.LOAD                  <-- CHANGE\n//SYSUT1   DD   DSN=&&SYSUT1,SPACE=(1024,(120,120),,,ROUND),UNIT=VIO,\n//         DCB=BUFNO=1\n//SYSPRINT DD   SYSOUT=*\n//L.SYSIN  DD *\n NAME AFCLOGR1(R)\n//*\n// ENDIF\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "BR2JMP": {"ttr": 2317, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00G\\x01\\x106/\\x01\\x106/\\x11F\\x00 \\x00 \\x00\\x00\\xd7\\xe2\\xf7\\xf2\\xf3\\xf1@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2010-12-28T00:00:00", "modifydate": "2010-12-28T11:46:47", "lines": 32, "newlines": 32, "modlines": 0, "user": "PS7231"}, "text": "         MACRO\n&LABEL   BR2JMP\n.**********************************************************************\n.*\n.*  THIS MACRO GENERATES OPSYN ASSEMBLER DIRECTIVES TO CAUSE ALL HARD\n.*  BRANCH INSTRUCTIONS TO BE TRANSLATED TO THEIR RELATIVE JUMP\n.*  EQUIVALENTS.\n.*\n.**********************************************************************\nB        OPSYN J\nBAL      OPSYN JAS\nBAS      OPSYN JAS\nBC       OPSYN BRC\nBCT      OPSYN JCT\nBE       OPSYN JE\nBH       OPSYN JH\nBL       OPSYN JL\nBM       OPSYN JM\nBNE      OPSYN JNE\nBNH      OPSYN JNH\nBNL      OPSYN JNL\nBNM      OPSYN JNM\nBNO      OPSYN JNO\nBNP      OPSYN JNP\nBNZ      OPSYN JNZ\nBO       OPSYN JO\nBP       OPSYN JP\nBXH      OPSYN BRXH\nBXLE     OPSYN BRXLE\nBZ       OPSYN JZ\n         MNOTE *,'BRANCH INSTRUCTIONS WILL BE CHANGED TO JUMP RELATIVE'\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "CLEAR": {"ttr": 2319, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x01\\x00\\x13\\x01\\x03\\x19\\x0f\\x01\\x06&\\x8f\\x14B\\x00\\t\\x00\\t\\x00\\x00\\xe3\\xd9\\xd3\\xc8@@@@@@'", "ispf": {"version": "01.01", "flags": 0, "createdate": "2003-07-09T00:00:00", "modifydate": "2006-09-25T14:42:13", "lines": 9, "newlines": 9, "modlines": 0, "user": "TRLH"}, "text": "         MACRO\n         CLEAR &TEXT\n         AIF   (N'&TEXT NE 1).ERROR1\n         MVI   &TEXT,C' '\n         MVC   &TEXT+1(L'&TEXT-1),&TEXT\n         MEXIT\n.ERROR1  MNOTE 20,'*** MISSING OPERAND ***'\n         MEXIT\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "EXECJCL": {"ttr": 2321, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00S\\x01\\x03\\x19\\x0f\\x01\\x03\\x19\\x0f\\x080\\x00\\x16\\x00\\x16\\x00\\x00\\xe3\\xd9\\xd3\\xc8@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2003-07-09T00:00:00", "modifydate": "2003-07-09T08:30:53", "lines": 22, "newlines": 22, "modlines": 0, "user": "TRLH"}, "text": "//TRLHCJCL JOB (TRLH,6C,),\n//            'Rich Hobt',\n//            MSGCLASS=T,\n//            NOTIFY=&SYSUID,\n//            CLASS=X\n//DEFAULT  OUTPUT CLASS=*,JESDS=ALL,DEFAULT=YES,\n//     NAME=('Rich Hobt'),\n//     ROOM=('6C'),\n// BUILDING=('Western'),\n//     DEPT=('SYSW'),\n//  ADDRESS=('3101 Western Ave.',\n//           'Seattle, WA.  98121',\n//           'U.S.A.',\n//           'Planet Earth')\n//*\n//*  This JCL is from: TRLH.AFCLOGR1.SRC(EXECJCL)\n//*\n//SCANLOG  EXEC AFCLOGSC,\n// FROM='2003/188,02:00',TO='2003/188,08:08'\n//SYSIN    DD   *\nTEXT='DUPLEX'\nMSGID='IXC'\n", "mimetype": "text/plain", "datatype": "unknown-8bit", "extension": ".txt"}, "INR": {"ttr": 2562, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x02\\x00Q\\x01\\x06&\\x8f\\x01\\x106/\\x11E\\x00Y\\x00K\\x00\\x00\\xd7\\xe2\\xf7\\xf2\\xf3\\xf1@@@@'", "ispf": {"version": "01.02", "flags": 0, "createdate": "2006-09-25T00:00:00", "modifydate": "2010-12-28T11:45:51", "lines": 89, "newlines": 75, "modlines": 0, "user": "PS7231"}, "text": "         MACRO\n&NAME    INR   &WALEN=,&AMODE=31,&RMODE=ANY,&OPSYN=NO\n.**********************************************************************\n.*\n.*  THIS MACRO GENERATES STANDARD REENTRANT ENTRY CODE USING\n.*  RELATIVE ADDRESSING (NO CODE BASE REG)  (USE WITH \"OUTR\" MACRO)\n.*\n.*    WALEN= LENGTH OF STORAGE AREA (BYTES).  R13 WILL POINT TO\n.*           THIS AREA, AND THE 1ST 72 BYTES WILL BE USED AS A\n.*           STANDARD SAVE AREA.  THE REST IS YOUR DYNAMIC STORAGE\n.*           AREA, SO YOU DON'T HAVE TO DO A SEPARATE GETMAIN IF\n.*           YOU DON'T WANT TO.\n.*    AMODE= AMODE OF THE PROGRAM\n.*    RMODE= RMODE OF THE PROGRAM\n.*    OPSYN= YES OR NO.  YES WILL INCLUDE THE BR2JMP MACRO TO\n.*           \"OPSYN\" NON-RELATIVE INSTRUCTIONS TO THEIR RELATIVE\n.*           COUNTERPARTS.  NO IS THE DEFAULT.\n.*\n.**********************************************************************\n         GBLC  &LGETLEN\n         LCLC  &PGMNAME,&INR0,&INR1,&INR2\n&PGMNAME SETC  'MAIN'           DEFAULT NAME\n&LGETLEN SETC  '72'             DEFAULT GETMAIN SIZE\n.*\n.* CHECK THE LABEL FOR PROGRAM NAME\n.*\n         AIF   ('&NAME' EQ '').NAMEBAD\n&PGMNAME SETC  '&NAME'\n         AGO   .NAMEOK\n.NAMEBAD ANOP\n         MNOTE 4,'PROGRAM NAME NOT SPECIFIED.  DEFAULTING TO MAIN'\n.NAMEOK  ANOP\n.*\n.* CHECK THE WALEN. DEFAULT TO 72\n.*\n         AIF   ('&WALEN' EQ '').WALENOK NOT SPECIFIED, USE DEFAULT\n&LGETLEN SETC  '&WALEN'\n.WALENOK ANOP\n.*\n.* EDIT AMODE AND RMODE PARAMETERS\n.*\n         AIF   (('&AMODE' NE '24') AND ('&AMODE' NE '31') AND          X\n               ('&AMODE' NE 'ANY')).AMERR\n         AIF   (('&RMODE' NE '24') AND ('&RMODE' NE 'ANY')).RMERR\n.DOIT    ANOP\n&INR0    SETC  'INR0&SYSNDX'\n&INR1    SETC  'INR1&SYSNDX'\n&INR2    SETC  'INR2&SYSNDX'\n&PGMNAME CSECT                   SET CSECT NAME\n         ENTRY &PGMNAME          ENTRY POINT NAME\n&PGMNAME AMODE &AMODE            SET AMODE\n&PGMNAME RMODE &RMODE            SET RMODE\n         J     &INR0             JUMP AROUND HEADER INFO\n         ASMINFO\n&INR0    DS    0H\n         SAVE  (14,12)           SAVE CALLERS REGS\n         LARL  R8,&INR1          ADDRESS LOCAL LITERAL POOL\n         USING &INR1,R8\n         STORAGE OBTAIN,LENGTH=&LGETLEN GET STORAGE AREA\n         XC    0(4,R1),0(R1)     ZERO FIRST WORD\n         ST    R13,4(R1)         PRIOR SAVEAREA ADDRESS TO MINE\n         ST    R1,8(R13)         MY SAVEAREA ADDRESS TO HIS\n         LR    R2,R13            KEEP OLD SAVE AREA FOR LATER RESTORE\n         LR    R13,R1            THIS IS MY SAVEAREA\n         LA    R4,12(,R13)       POINT PAST THE CHAIN\n         L     R5,=A(&LGETLEN)\n         LA    R6,12             SIZE - CHAIN AREA (12 BYTES) ...\n         SR    R5,R6             ...GIVES THE AMOUNT TO CLEAR\n         SR    R7,R7             CLEAR THE FROM COUNT AND CLEAR BYTE\n         MVCL  R4,R6             WHEE, CLEAR IT OUT\n         LM    R14,R8,12(R2)     RESTORE THE ORIGINAL REGISTERS\n         DROP  R8\n         J     &INR2             JUMP AROUND LITERAL POOL\n&INR1    DS    0H\n         LTORG\n.*\n.* IF THEY SAID OPSYN=YES, GENERATE OPSYN INSTRUCTIONS TO CHANGE\n.* BRANCH-TYPE INSTRUCTIONS TO RELATIVE JUMPS\n.*\n         AIF   ('&OPSYN' NE 'YES').NOPSYN\n         BR2JMP\n.NOPSYN  ANOP\n&INR2    DS    0H                START OF USER CODE\n         MEXIT\n.AMERR   MNOTE 8,'AMODE MUST BE 24, 31, OR ANY'\n         MEXIT\n.RMERR   MNOTE 8,'RMODE MUST BE 24 OR ANY'\n         MEXIT\n         MEND\n", "mimetype": "text/plain", "datatype": "ebcdic", "extension": ".txt"}, "OUTR": {"ttr": 2565, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00(\\x01\\x06&\\x8f\\x01\\x06&\\x8f\\x14\\x18\\x00,\\x00,\\x00\\x00\\xe3\\xd9\\xd3\\xc8@@@@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2006-09-25T00:00:00", "modifydate": "2006-09-25T14:18:28", "lines": 44, "newlines": 44, "modlines": 0, "user": "TRLH"}, "text": "         MACRO\n&LABEL   OUTR  &RETCODE=\n.**********************************************************************\n.*\n.*  THIS MACRO GENERATES STANDARD EXIT CODE FOR BATCH PROGRAMS USING\n.*  THE 'INR' MACRO.\n.*\n.*  RETCODE MAY BE:\n.*    'YES' INDICATING THAT R15 IS ALREADY LOADED WITH A RETURN CODE\n.*    (R)   INDICATING THAT THE RETURN CODE IS IN REGISTER R\n.*    XXX   SET RETURN CODE 'XXX'\n.*  '0' IS THE RETURN CODE IF NOT OTHERWISE SET\n.*\n.**********************************************************************\n         GBLC  &LGETLEN\n         LCLC  &RETC,&RETREG\n         LCLA  &RETCLEN\n&RETC    SETC  '0'                DEFAULT RETURN CODE\n         AIF   ('&RETCODE' EQ '').SETCON\n         AIF   ('&RETCODE'(1,1) NE '(').SETCODE\n&RETCLEN SETA  K'&RETCODE-2\n&RETREG  SETC  '&RETCODE'(2,&RETCLEN)\n         AGO   .SETCON\n.SETCODE ANOP\n&RETC    SETC  '&RETCODE'\n.SETCON  ANOP\n         PUSH  PRINT\n         PRINT GEN\n&LABEL   DS    0H\n         LR    1,13               GET ADDR OF OUR SAVE AREA\n         L     13,4(,13)          RESTORE CALLER'S SAVE AREA\n         AIF   ('&RETCODE' EQ 'YES').SETCON3\n         AIF   ('&RETREG' EQ '').SETCON2\n         LR    15,&RETREG         SET RETURN CODE\n         AGO   .SETCON3\n.SETCON2 ANOP\n         LA    15,&RETC           SET RETURN CODE\n.SETCON3 ANOP\n         ST    15,16(,13)         SAVE RETURN CODE ACROSS LM\n         STORAGE RELEASE,LENGTH=&LGETLEN,ADDR=(1) FREE OUR SAVE AREA\n         LM    14,12,12(13)       RESTORE REGS 14-12\n         BR    14                 RETURN TO CALLER\n         POP   PRINT\n         MEND\n", "mimetype": "text/plain", "datatype": "iso-8859-1", "extension": ".txt"}, "PDSLOAD": {"ttr": 2567, "alias": false, "halfwords": 30, "notes": 0, "parms": "b'\\x01\\x00\\x00\\x00\\x01\\x01\\x15\\x7f\\x01\\x01\\x15\\x7f\\x156\\x00e\\x00e\\x00\\x00\\xd3\\xd6\\xc1\\xc4\\xd3\\xc9\\xc2@@@'", "ispf": {"version": "01.00", "flags": 0, "createdate": "2001-06-06T00:00:00", "modifydate": "2001-06-06T15:36:00", "lines": 101, "newlines": 101, "modlines": 0, "user": "LOADLIB"}, "mimetype": "application/xmit", "datatype": "binary", "extension": ".xmi"}}}}, "SCRIPTOPTIONS": {"filename": "./CBT642/FILE642.XMI", "LRECL": 80, "loglevel": 30, "outputfolder": "CBT642", "encoding": "cp1140", "unnum": true, "quiet": false, "force": false, "binary": false, "modifydate": true}}