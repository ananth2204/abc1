         TITLE 'A F C L O G R 1   AFC OPERLOG EXTRACT'
***********************************************************************
*                                                                     *
* AFCLOGR1                                                            *
*                                                                     *
* THIS PROGRAM IS INTENDED TO READ AN OPERLOG DATA STREAM FROM        *
* LOGIN AND WRITE SELECTED RECORDS TO LOGOUT IN HARDCOPY LOG FORMAT.  *
*                                                                     *
* TIME SPAN OF THE RECORDS TO BE SEARCHED IS CONTROLLED IN THE JCL.   *
* RECORD SELECTION IS DETERMINED BY SYSIN CONTROL CARDS.  THERE ARE   *
* 6 KEYWORDS (NOT COLUMN-SPECIFIC):                                   *
*                                                                     *
* JOBNAME=XXXXXXXX                                                    *
*   LIMIT THE SEARCH TO RECORDS PRODUCED BY THIS JOBNAME              *
*                                                                     *
* JOBID=JOBXXXXX                                                      *
*   LIMIT THE SEARCH TO RECORDS PRODUCED BY THIS JOBID                *
*                                                                     *
* SYSID=XXXXXXXX                                                      *
*   LIMIT THE SEARCH TO RECORDS PRODUCED FROM THIS SYSTEM (OR         *
*   SYSTEMS IF MULTIPLE SYSID CARDS ARE FOUND - UP TO 16).            *
*                                                                     *
* NOTE THAT THE FOLLOWING TEXT AND MSGID KEYWORDS REFER TO "SELECTED" *
* RECORDS.  THESE ARE RECORDS "SELECTED" BY ANY OF THE PRECEEDING     *
* KEYWORDS.  IF NONE OF THESE ARE SPECIFIED, "SELECTED" BECOMES ALL   *
* OPERLOG RECORDS IN THE JCL-CONTROLLED TIMESPAN.                     *
*                                                                     *
* TEXT='TEXT YOU ARE LOOKING FOR'                                     *
*                                                                     *
*   THE FIRST CHARACTER AFTER THE "=" IS THE STRING DELIMITER AND IS  *
*   REQUIRED.  THIS CAN BE ANY CHARACTER, BUT MUST BE MATCHED AT THE  *
*   END.  MAXIMUM STRING LENGTH IS 127.  THE TEXT OF ALL SELECTED     *
*   MESSAGES (INCLUDING MULTI RECORD) WILL BE SCANNED FOR THIS TEXT.  *
*                                                                     *
* MSGID='MSGID YOU ARE LOOKING FOR'                                   *
*                                                                     *
*   THE FIRST CHARACTER AFTER THE "=" IS THE STRING DELIMITER AND IS  *
*   REQUIRED.  THIS CAN BE ANY CHARACTER, BUT MUST BE MATCHED AT THE  *
*   END.  MAXIMUM STRING LENGTH IS 127.  ONLY THE FIRST 3 COLUMNS OF  *
*   THE 1ST LINE OF EACH SELECTED MESSAGE WILL BE SCANNED FOR THIS    *
*   TEXT, SO IT IS FASTER THAN THE TEXT= KEYWORD.                     *
*                                                                     *
* FIND=EXCLUDE                                                        *
*                                                                     *
*   ENTERED AS SHOWN.  THE RESULT OF THIS KEYWORD IS THAT IF ANY OF   *
*   THE TEXT OR MSGIDS ARE FOUND, THE RECORD WILL NOT BE PRINTED.     *
*   USE THIS TO PRINT EVERYTHING EXCEPT THE MATCHES.                  *
*                                                                     *
* FIND=QUIT                                                           *
*                                                                     *
*   ENTERED AS SHOWN.  USE THIS IF YOU ARE SCANNING THROUGH A LONG    *
*   TIME SPAN FOR THE 1ST OCCURRANCE OF SOMETHING, AND DONT WANT TO   *
*   WASTE THE TIME SEARCHING THROUGH THE REST OF THE LOG.  CAUSES     *
*   EXECUTION TO END AFTER THE 1ST HIT.                               *
*                                                                     *
* THE ORDER OF THE KEYWORDS DOES NOT MATTER.  A RECORD IS PRINTED IF  *
* IT MATCHES ANY OF THE TEXT STRINGS AND THE JOBNAME, JOBID, AND/OR   *
* SYSID CRITERIA (OR NOT PRINTED, IF "FIND=EXCLUDE").                 *
*                                                                     *
* AN "*" IN COLUMN 1 OF ANY SYSIN RECORD INDICATES A COMMENT, AND     *
* THAT RECORD IS IGNORED.  A NULL OR DUMMY'D SYSIN (OR ALL COMMENTS)  *
* CAUSES ALL THE OPERLOG RECORDS TO BE PRINTED.                       *
*                                                                     *
* EXAMPLES:                                                           *
*                                                                     *
* //LOGCOPY  EXEC PGM=AFCLOGR1                                        *
* //SYSUDUMP DD   SYSOUT=*                                            *
* //LOGIN DD DSN=SYSPLEX.OPERLOG,RECFM=VB,LRECL=4100,BLKSIZE=32760,   *
* // SUBSYS=(LOGR,,'FROM=(2001/339,07:00),TO=(2001/339,07:01),LOCAL') *
* //LOGOUT   DD   SYSOUT=*                                            *
* //SYSIN    DD   *                                                   *
* * THIS COMMENT INTENTIONALLY LEFT MEANINGLESS                       *
* TEXT=' INVALID '                                                    *
* MSGID='IEF403I'                                                     *
*                                                                     *
* THIS JOBSTEP SCANS THE OPERLOG FROM 07:00 DECEMBER 5, 2001 TO       *
* 07:01 DECEMBER 5, 2001 FOR ANY MESSAGE CONTAINING THE WORD          *
* " INVALID ", OR ANY MESSAGE STARTING WITH "IEF403I".                *
*                                                                     *
* //LOGCOPY  EXEC PGM=AFCLOGR1                                        *
* //SYSUDUMP DD   SYSOUT=*                                            *
* //LOGIN DD DSN=SYSPLEX.OPERLOG,RECFM=VB,LRECL=4100,BLKSIZE=32760,   *
* // SUBSYS=(LOGR,,'FROM=(2001/339,07:00),TO=(2001/339,07:01),LOCAL') *
* //LOGOUT   DD   SYSOUT=*                                            *
* //SYSIN    DD   *                                                   *
* * ANOTHER POINTLESS COMMENT                                         *
* MSGID="ICH408"                                                      *
* TEXT=%INDICATED FOR%                                                *
* FIND=EXCLUDE                                                        *
*                                                                     *
* THIS JOBSTEP SCANS THE SAME PERIOD, BUT PRINTS EVERY MESSAGE        *
* THAT DOES NOT START WITH "ICH408" OR CONTAIN THE PHRASE             *
* "INDICATED FOR".                                                    *
*                                                                     *
*                                                                     *
* ABENDS AND RETURN CODES:                                            *
*                                                                     *
* ABEND U100:  THE LOGIN BUFFER OVERFLOWED.  I DID AN ABEND           *
*   RATHER THAN SET A RETURN CODE BECAUSE THIS WAY WE CAN SEE         *
*   WHAT KIND OF HUGE RECORD CAUSED THE OVERFLOW.                     *
*                                                                     *
* ABEND 200 NO LONGER PROCESSED                                     RH4
* ABEND U200:  THE LRECL OF THE LOGIN DD IS TOO SMALL - WE          RH3
*   ENCOUNTERED A RECORD THAT WAS INCOMPLETE.  INCREASE THE         RH3
*   LRECL OF THE LOGIN DD.                                          RH3
*                                                                     *
* RC 12: SEARCH-FOR TEXT BUFFER OVERFLOWED.  TOO MUCH TO LOOK FOR.    *
*        OR TOO MANY SYSID= CARDS.                                    *
*                                                                     *
* RC 8: DELIMITER ERROR ON A SYSIN STATEMENT.                         *
*                                                                     *
* RC 1: NOTHING FOUND                                                 *
*                                                                     *
* RC 0: NORMAL RETURN, WE FOUND AT LEAST ONE HIT                      *
*                                                                     *
*                                                                     *
* REGISTER USAGE:                                                     *
*                                                                     *
* R15 - *WORK                                                         *
* R14 - LINK (JAS)                                                    *
* R13 - WORKAREA BASE                                                 *
* R12 - CONSTANTS BASE REG                                            *
* R11 - LOGIN DCB                                                     *
* R10 - LOGOUT DCB                                                    *
* R9  - *WORK                                                         *
* R8  - *WORK                                                         *
* R7  - *WORK                                                         *
* R6  - *WORK                                                         *
* R5  - *WORK                                                         *
* R4  - *WORK                                                         *
* R3  - *WORK                                                         *
* R2  - *WORK                                                         *
* R1  - *WORK                                                         *
* R0  - *WORK                                                         *
*                                                                     *
* 12/02/2010  RLH   INSTEAD AF ABENDING WITH A TOO-LARGE RECORD     RH4
*                   (RH3), JUST USE THE PART THAT FITS.  WE DO THIS RH4
*                   BECAUSE IT IS POSSIBLE FOR A LOG RECORD TO BE   RH4
*                   65536 IN LENGTH, TOO BIG FOR US TO HANDLE.      RH4
*                   WHEN THIS HAPPENS, WE JUST GET A "CUT OFF"      RH4
*                   RECORD, IN WHICH CASE WE WILL PROCESS AS MUCH   RH4
*                   OF IT AS IS THERE.                              RH4
*                                                                     *
* 12/15/2008  RLH   ABEND U200 IF MDBLEN > LRECL                    RH3
*                   I FOUND THIS PROBLEM WHEN I USED JCL FROM       RH3
*                   AFC/DHL, WHERE THE LRECL OF THE LOGSTREAM WAS   RH3
*                   4100.  HERE AT DPS, IT'S APPARENTLY MORE.  WHEN RH3
*                   A LARGE RECORD WAS READ, ONLY THE 1ST 4100      RH3
*                   BYTES WERE PUT IN THE BUFFER, RESULTING IN AN   RH3
*                   INCOMPLETE RECORD, AND A LOOPING CONDITION.     RH3
*                   SO IF YOU GET A U200 ABEND, INCREASE THE LRECL  RH3
*                   ON THE LOGIN FILE.                              RH3
*                                                                     *
* 09/24/2007  TRLH  MDBMCSH REMOVED IN Z/OS 1.8                   RH2 *
* 09/19/2006  TRLH  ADD SUPPORT FOR MULTIPLE SYSID STATEMENTS         *
* 08/25/2006  TRLH  NO BASE REG FOR CODE, USE ALL RELATIVE ADDRESSING *
* 09/27/2005  TRLH  ADD "FIND=QUIT"                               RH1 *
* 07/29/2002  TRLH  MSGID SHOULD LOOK IN 1ST 3 COLS, NOT JUST 2       *
* 07/24/2002  TRLH  ADD RC=1 FOR NOTHING FOUND                        *
* 12/07/2001  TRLH  ORIGINAL CODE                                     *
*                                                                     *
* RICHARD HOBT                                                        *
* DHL WORLDWIDE EXPRESS                                               *
* 8701 E. HARTFORD                                                    *
* SCOTTSDALE, AZ.                                                     *
* (480) 375-7320                                                      *
* RICH.HOBT@DHL.COM                                                   *
*                                                                     *
***********************************************************************
         SYSSTATE ARCHLVL=2
         YREGS
         EJECT
AFCLOGR1 INR   WALEN=WORKAREA_LEN,RMODE=24,AMODE=24
         USING WORKAREA,R13           ADDRESS DYNAMIC STORAGE
         LARL  R12,CONSTANT_AREA      ADDRESS STATIC STORAGE
         USING CONSTANT_AREA,R12
*
* GO INITIALIZE VARIOUS WORK AREA ITEMS
*
         ST    R1,PARM_ADDRESS        SAVE PARM ADDRESS
*
         JAS   R14,INITIALIZE
         CLC   MAIN_RC,F0             DID IT GO OK?
         JNE   EGRESS                 NO, LEAVE NOW
*
* MAIN PROCESS
*
         JAS   R14,PROCESS
*
* CLEANUP
*
         JAS   R14,CLEANUP
*
* EXIT
*
EGRESS   DS    0H

         ICM   R15,B'1111',MAIN_RC    GET RETURN CODE
         OUTR  RETCODE=YES
*----------------------------------------------------------------------
*
* INITIALIZE ROUTINE - SET UP VARIABLES IN THE WORK AREA
*
INITIALIZE DS 0H
         ST    R14,R14_INITIALIZE
*
         XC    MAIN_RC,MAIN_RC         SET RC=0
         XC    BUFFER_RECORD_NO,BUFFER_RECORD_NO
         XC    BUFFER_COUNT,BUFFER_COUNT
         XC    BUFFER_SIZE,BUFFER_SIZE
         MVI   FLAGS,X'00'
         MVI   FLAG_INC_EXC,X'00'
         MVI   SEARCH_JOBNAME_L,X'00'
         XC    SEARCH_JOBID,SEARCH_JOBID
         XC    SEARCH_SYSID_COUNT,SEARCH_SYSID_COUNT
*
         LA    R2,TEXT_SPACE
         LA    R4,F1
         LA    R3,@TEXT_SIZE
         XR    R5,R5
         MVCL  R2,R4                   CLEAR TEXT_SPACE
*
         LA    R1,BUFFER_SPACE
         ST    R1,BUFFER_NEXT
         JAS   R14,OPEN_FILES
*
         JAS   R14,READ_SYSIN
*
         L     R14,R14_INITIALIZE
         BR    R14
*----------------------------------------------------------------------
*
* PROCESS ROUTINE - SCAN THE INPUT, BUILD THE OUTPUT
*
PROCESS  DS 0H
         ST    R14,R14_PROCESS
*
NEXT_LOG_RECORD DS 0H
         GET   (R11)               READ RECORD
         ST    R1,CURRENT_RECORD_ADDRESS
         MVC   CURRENT_RECORD_ID,MDBGMID-MDBG+MDBHLEN+4(R1) SAVE ID
*
         CLC   CURRENT_RECORD_ID,PREVIOUS_RECORD_ID  CONTINUATION?
         JE    ADD_CURRENT_RECORD  YES, ADD IT TO BUFFER
         JAS   R14,UNLOAD_BUFFER   NO, UNLOAD CURRENT BUFFER CONTENTS
         TM    FLAGS,@GOT_A_HIT+@FIND_QUIT DO WE NEED TO QUIT NOW?  RH1
         JO    PROCESS_DONE        YES, ALL DONE                    RH1
ADD_CURRENT_RECORD DS 0H
         JAS   R14,ADD_TO_BUFFER   ADD CURRENT RECORD TO BUFFER
*
         MVC   PREVIOUS_RECORD_ID,CURRENT_RECORD_ID SAVE RECORD ID
         J     NEXT_LOG_RECORD
*
LOGIN_EOF DS 0H
         JAS   R14,UNLOAD_BUFFER
PROCESS_DONE DS 0H
         L     R14,R14_PROCESS
         BR    R14
*----------------------------------------------------------------------
*
* ADD RECORD TO BUFFER
*
ADD_TO_BUFFER DS 0H
         ST    R14,R14_ADD_TO_BUFFER
*
         L     R4,CURRENT_RECORD_ADDRESS  WHERE IT COMES FROM
         CLC   0(2,R4),MDBLEN-MDB+4(R4)   COMPARE RDW AND MDBLEN    RH3
*        JL    LRECL_ABEND                IF RDW IS LESS, ABEND     RH3
         JNL   MDBLEN_OK                  GO AHEAD USING MDB LENGTH RH4
         LH    R1,0(R4)                   GET RDW                   RH4
         AHI   R1,-4                      REDUCE BY RDW LENGTH      RH4
         STH   R1,MDBLEN-MDB+4(R4)        "REAL" MDBLEN             RH4
MDBLEN_OK DS 0H                                                     RH4
         LH    R3,0(R4)                   LENGTH (FROM RDW)
         L     R6,BUFFER_SIZE             HOW MUCH SPACE IN USE
         AR    R6,R3                      HOW MUCH WILL BE USED
         C     R6,F_BUFFER_SIZE           TOO MUCH?
         JNL   BUFFER_ABEND               YES, GO ABEND NOW
         L     R2,BUFFER_NEXT             WHERE IT GOES TO
         LR    R5,R3                      EQUAL LENGTH
         MVCL  R2,R4                      COPY CURRENT RECORD
         ST    R2,BUFFER_NEXT             NEXT ONE GOES HERE
         ST    R6,BUFFER_SIZE             UPDATE SPACE COUNT
         L     R3,BUFFER_COUNT
         AHI   R3,1
         ST    R3,BUFFER_COUNT            INCREMENT RECORD COUNT
*
ADD_TO_BUFFER_RETURN DS 0H
         L     R14,R14_ADD_TO_BUFFER
         BR    R14
BUFFER_ABEND DS 0H
         ABEND 100,DUMP                   ABEND U100
*LRECL_ABEND DS 0H                                             RH3  RH4
*        ABEND 200,DUMP                   ABEND U200           RH3  RH4
*----------------------------------------------------------------------
*
* PROCESS RECORDS IN BUFFERS
*
UNLOAD_BUFFER DS 0H
         ST    R14,R14_UNLOAD_BUFFER
* LOOK THROUGH THE BUFFERED RECORDS TO SEE IF WE WANT TO PRINT ANY
         LA    R9,BUFFER_SPACE     ADDRESS OF 1ST RECORD IN BUFFER
         MVC   BUFFER_RECORD_NO,F1 1ST RECORD
         L     R8,BUFFER_COUNT     NUMBER OF RECORDS
         LTR   R8,R8               ANYTHING THERE?
         JZ    UNLOAD_BUFFER_RETURN NO, GO AWAY
NEXT_BUFFER_FILTER DS 0H
*
         STM   R8,R9,R8_R9_UNLOAD  SAVE OUR REGS
         AHI   R9,4                POINT PAST RDW
         JAS   R14,FILTER_RECORD   GO SEE IF WE WANT TO KEEP IT
         LM    R8,R9,R8_R9_UNLOAD  RESTORE OUR REGS
         XC    FOUND_FLAG,FLAG_INC_EXC ADJUST FOR INCLUDE/EXCLUDE
         TM    FOUND_FLAG,@FOUND   DID WE FIND ANYTHING?
         JO    WRITE_BUFFER_RECORDS YES, GO DO IT
         AH    R9,0(R9)            POINT TO NEXT BUFFER RECORD
         L     R1,BUFFER_RECORD_NO
         AHI   R1,1                ADD 1 TO CURRENT RECORD NUMBER
         ST    R1,BUFFER_RECORD_NO
         JCT   R8,NEXT_BUFFER_FILTER LOOK THROUGH ALL RECORDS
         J     FLUSH_BUFFERS       FLUSH BUFFERS AND RETURN
* PRINT THE BUFFERED RECORDS
WRITE_BUFFER_RECORDS DS 0H
         OI    FLAGS,@GOT_A_HIT    INDICATE THAT WE GOT A HIT
         LA    R9,BUFFER_SPACE     ADDRESS OF 1ST RECORD IN BUFFER
         L     R8,BUFFER_COUNT     NUMBER OF RECORDS
         MVC   BUFFER_RECORD_NO,F1 1ST RECORD
NEXT_BUFFER_WRITE  DS 0H
*
         STM   R8,R9,R8_R9_UNLOAD  SAVE OUR REGS
         AHI   R9,4                POINT PAST RDW
         JAS   R14,WRITE_RECORD    GO FORMAT IT FOR PRINT
         LM    R8,R9,R8_R9_UNLOAD  RESTORE OUR REGS
         L     R1,BUFFER_RECORD_NO
         AHI   R1,1                ADD 1 TO CURRENT RECORD NUMBER
         ST    R1,BUFFER_RECORD_NO
         AH    R9,0(R9)            POINT TO NEXT BUFFER RECORD
         JCT   R8,NEXT_BUFFER_WRITE LOOP THROUGH THE BUFFER
*
FLUSH_BUFFERS DS 0H
         XC    BUFFER_RECORD_NO,BUFFER_RECORD_NO
         XC    BUFFER_COUNT,BUFFER_COUNT NO RECORDS IN USE
         XC    BUFFER_SIZE,BUFFER_SIZE   NO BYTES IN USE
         LA    R1,BUFFER_SPACE           POINT TO
         ST    R1,BUFFER_NEXT            FIRST POSITION
*
UNLOAD_BUFFER_RETURN DS 0H
         L     R14,R14_UNLOAD_BUFFER
         BR    R14
*----------------------------------------------------------------------
*
* FILTER RECORD - SEE IF WE WANT TO "KEEP" THIS RECORD
*
* INPUT:
*   R9 HAS ADDRESS OF RECORD
* OUTPUT:
*
*
FILTER_RECORD DS 0H
         ST    R14,R14_FILTER_RECORD
*
         NI    FOUND_FLAG,255-@FOUND ASSUME WE DON'T WANT IT
*
         CLI   TEXT_SPACE,X'00'    ANY TEXT TO LOOK FOR?
         JNE   FILTER_SEARCH       YES
         CLI   SEARCH_JOBNAME_L,X'00' HOW ABOUT A JOBNAME?
         JNE   FILTER_SEARCH       YES, CONTINUE
         TM    SEARCH_JOBID,X'BF'  JOBID, MAYBE?
         JNZ   FILTER_SEARCH       YES
         CLI   SEARCH_SYSID_COUNT,0  SYSID, MAYBE?
         JNE   FILTER_SEARCH       YES
FILTER_NO_ITEMS DS 0H
         OI    FOUND_FLAG,@FOUND   NOTHING TO FILTER ON, MATCH ALL
         J     FILTER_RECORD_RETURN
FILTER_SEARCH DS 0H
         LH    R8,0(R9)            LENGTH OF ENTIRE RECORD
         AHI   R8,MDBHLEN*-1       MINUS MDB HEADER LENGTH
         AHI   R9,MDBHLEN          POINT TO MDBG PART
         SH    R8,0(R9)            SUBTRACT MDBG LENGTH FROM TOTAL
*
         USING MDBG,R9
         MVC   TEMP_MDBGJBNM,MDBGJBNM SAVE JOBNAME
         CLI   SEARCH_SYSID_COUNT,0 SEARCH FOR SYSID?
         JE    FILTER_MDBSCP       NO, CONTINUE
         LA    R3,SEARCH_SYSID     YES, START HERE
         LB    R4,SEARCH_SYSID_COUNT HERE'S HOW MANY
FILTER_SYSID_LOOP DS 0H
         CLC   0(8,R3),MDBGOSNM     DOES IT MATCH?
         JE    FILTER_MDBSCP        YES, CONTINUE
         AHI   R3,8                 NEXT SYSID IN LIST
         JCT   R4,FILTER_SYSID_LOOP LOOP IF MORE
         J     FILTER_RECORD_RETURN NO MATCH, DON'T BOTHER WITH REST
         DROP  R9
*
FILTER_MDBSCP DS 0H
         AH    R9,0(R9)            ADD MDBGLEN TO POINT AT MDBSCP
         SH    R8,0(R9)            SUBTRACT MDBC LENGTH FROM TOTAL
*
         USING MDBSCP,R9
         LB    R3,SEARCH_JOBNAME_L GET LENGTH OF JOBNAME
         LTR   R3,R3               JOBNAME PRESENT?
         JZ    FILTER_JOBID        NO, SKIP THIS
         AHI   R3,-1
         EX    R3,FILTER_COMPARE_JOBNAME_1
         JE    FILTER_JOBID        MATCHES, CONTINUE
         EX    R3,FILTER_COMPARE_JOBNAME_2
         JE    FILTER_JOBID        MATCHES, CONTINUE
         J     FILTER_RECORD_RETURN NO MATCH, SKIP IT
*
FILTER_JOBID DS 0H
         TM    SEARCH_JOBID,X'BF'  JOBID PRESENT?
         JZ    FILTER_MDBT         NO, CONTINUE
         CLC   SEARCH_JOBID,MDBCOJID YES - DOES IT MATCH?
         JE    FILTER_MDBT          YES, CONTINUE
         J     FILTER_RECORD_RETURN NO, DON'T BOTHER
         DROP  R9
*
FILTER_MDBT DS 0H
         CLI   TEXT_SPACE,X'00'    ANY TEXT TO LOOK FOR?
         JNE   FILTER_SEARCH_TEXT  YES
         OI    FOUND_FLAG,@FOUND   NO, SO MARK AS "FOUND"
         J     FILTER_RECORD_RETURN
FILTER_SEARCH_TEXT DS 0H
         AH    R9,0(R9)            ADD MDBCLEN TO POINT AT MDBT
         OI    FLAGS,@1STSEG       INDICATE 1ST SEGMENT OF MSG
* NOW R9 POINTS AT MDBT, R8 HAS REMAINING LENGTH OF RECORD
FILTER_SEGMENT_LOOP DS 0H
         STM   R8,R9,R8_R9_FILTER  SAVE R8 AND R9, JUST IN CASE
         JAS   R14,SEARCH_TEXT     SEARCH FOR MATCHING TEXT
         LM    R8,R9,R8_R9_FILTER  RESTORE R8 AND R9
         TM    FOUND_FLAG,@FOUND   FOUND?
         JO    FILTER_RECORD_RETURN YES, NO NEED TO SEARCH FURTHER
         SH    R8,0(R9)            REMAINING LENGTH IN RECORD
         JNP   FILTER_RECORD_RETURN ALL DONE
         AH    R9,0(R9)            POINT TO NEXT MDBT SEGMENT
         CH    R8,0(R9)            IS IT A "SHORT" MDBT?            RH4
         JNL   FILTER_NORMAL_MDBT  NO, NORMAL ONE                   RH4
         CHI   R8,MDBTMBOB         YES - ANY TEXT IN IT?            RH4
         JNH   FILTER_RECORD_RETURN NO, JUST SKIP IT                RH4
         STH   R8,0(R9)            YES, SET "NEW" MDBTLEN           RH4
FILTER_NORMAL_MDBT DS 0H                                            RH4
         NI    FLAGS,255-@1STSEG   INDICATE NOT 1ST SEGMENT ANY MORE
         J     FILTER_SEGMENT_LOOP MORE TO DO
*
FILTER_RECORD_RETURN DS 0H
         L     R14,R14_FILTER_RECORD
         BR    R14
*----------------------------------------------------------------------
*
* SEARCH_TEXT - SEARCH THE MESSAGE SEGMENT FOR TARGET TEXT
* R9 HAS ADDRESS OF AN MDBT SEGMENT
*
SEARCH_TEXT  DS 0H
         ST    R14,R14_SEARCH_TEXT
         USING MDBT,R9              ADRESSABILITY
*
         LA    R2,TEXT_SPACE        START AT THE BEGINNING
         XR    R3,R3
SEARCH_TEXT_LOOP DS 0H
         IC    R3,0(R2)             LENGTH OF THIS TEXT
         N     R3,F_X_7F            MAKE SURE HOB IS OFF
         LTR   R3,R3                ANYTHING HERE?
         JZ    SEARCH_TEXT_RETURN   NO
         LA    R4,MDBTMSGT          POINT AT MSG TEXT
* GET LENGTH OF TARGET. IF TOO SHORT, JUST LEAVE
         LH    R5,MDBTLEN           LENGTH OF WHOLE SEGMENT
         AHI   R5,MDBTMBOB*-1       SUBTRACT HEADER TO GET MSG LENGTH
         SR    R5,R3                AND WE DON'T NEED TO LOOK PAST END
         JM    TEXT_COMPARE_NEXT    TOO LONG, DON'T BOTHER
         AHI   R5,1                 COUNTER IS DIFFERENCE + 1
         AHI   R3,-1                DECREMENT COMPARE LENGTH
*
         TM    0(R2),@MSGID_ONLY   MSGID FORM OF TEXT?
         JNO   TEXT_COMPARE_LOOP    NO, COUNT IS SET FOR TEXT COMPARE
* SEARCH 1ST SEGMENT ONLY FOR MSGID
         TM    FLAGS,@1STSEG        MSGID - 1ST SEGMENT OF MESSAGE?
         JNO   TEXT_COMPARE_NEXT    NO, NO NEED TO SEARCH FOR THIS
         CHI   R5,3                 ALREADY A SHORT LOOP?
         JNH   TEXT_COMPARE_LOOP    YES
         LA    R5,3                 NO, ONLY SEARCH 1ST 3 POSITIONS
*
TEXT_COMPARE_LOOP DS 0H
         EX    R3,TEXT_COMPARE      IS THE TEXT HERE?
         JE    TEXT_FOUND           YES
         AHI   R4,1                 ADVANCE ONE CHAR
         JCT   R5,TEXT_COMPARE_LOOP KEEP LOOKING
TEXT_COMPARE_NEXT DS 0H
         LA    R2,2(R3,R2)          ADDRESS NEXT SPOT IN TABLE
         J     SEARCH_TEXT_LOOP     LOOK SOME MORE
TEXT_FOUND DS 0H
         OI    FOUND_FLAG,@FOUND    INDICATE A HIT
*
SEARCH_TEXT_RETURN DS 0H
         L     R14,R14_SEARCH_TEXT
         BR    R14
         DROP  R9
*----------------------------------------------------------------------
*
* PRINT RECORD - FORMAT AND OUTPUT THE RECORD
* R9 HAS ADDRESS OF RECORD
*
WRITE_RECORD DS 0H
         ST    R14,R14_WRITE_RECORD
*
         USING MDB,R9
         LA    R8,LOGOUT_SPACE     ADDRESS OUTPUT RECORD
         USING HCL,R8
         LH    R2,MDBLEN           LENGTH OF RECORD (MDBLEN) IN R2
         DROP  R9
*
* PROCESS MDBG PART OF INPUT RECORD
*
         LA    R9,MDBHLEN(,R9)     POINT R9 PAST MDB AT MDBG
         USING MDBG,R9
         AHI   R2,MDBHLEN*-1       HOW MUCH LEFT IN RECORD
         CLEAR LOGOUT_SPACE        CLEAR OUTPUT RECORD
         LA    R1,HCLHEADL+4       PRIME RECORD LEN + RDW LEN
         STH   R1,LOGOUT_RECLEN
         XC    LOGOUT_BLKLEN,LOGOUT_BLKLEN AND RDW
*
         MVC   HCLTIME,MDBGTIMH    MOVE TIME HH.MM.SS.TH
         MVC   HCLDATE,MDBGDSTP+2  MOVE (YY)YYDDD LAST 5 CHARS
         MVC   HCLSYSID,MDBGOSNM   SYSTEM NAME
         MVC   JOBNAME,MDBGJBNM    SAVE JOBNAME FOR LATER
*
         CLC   BUFFER_RECORD_NO,F1 1ST RECORD IN BUFFER?
         JH    GOT_MLID            IF NOT, ALREADY HAVE MLID
         ICM   R15,B'0111',MDBGSEQ MESSAGE SEQUENCE NUMBER
         CVD   R15,QWORD           CONVERT TO DECIMAL
         UNPK  MLID,QWORD          SAVE LOW 3 DIGITS AS EBCDIC
         OI    MLID+2,C'0'         MAKE IT PRINTABLE
GOT_MLID DS 0H
*
* PROCESS MDBSCP PART OF INPUT RECORD
*
         SH    R2,MDBGLEN          KEEP REMAINING LENGTH CURRENT
         AH    R9,MDBGLEN          POINT AT MDBSCP
         DROP  R9
         USING MDBSCP,R9           ADDRESS MDBSCP
* TRANSLATE 1ST 28 ROUTING CODES TO DISPLAYABLE FORMAT
         UNPK  QWORD(9),MDBCERC(5) UNPACK FIRST 28 ROUTING CODES
         TR    QWORD(7),HEX_TRANSLATE MAKE THEM PRINTABLE
         MVC   HCLROUTC,QWORD      MOVE INTO RECORD
* TRANSLATE USER EXIT/MPF FLAGS TO DISPLAYABLE FORMAT
         UNPK  QWORD(9),MDBCXMOD(5) UNPACK REQUEST FLAGS
         TR    QWORD(8),HEX_TRANSLATE MAKE THEM PRINTABLE
         MVC   REQUEST_FLAGS,QWORD SAVE COPY FOR MULTI-LINE MSG
         MVC   HCLREQFL,QWORD      MOVE INTO RECORD
* FIGURE OUT RECORD ID
         MVI   HCLRECTP,HCLMLWTO   ASSUME A MULTILINE MSG
         CLC   MDBCLCNT,F1         SEE IF MORE THAN ONE LINE
         JH    DONE_WITH_RECID     OK IF SO
         MVI   HCLRECTP,HCLWTO     MAKE IT A SINGLE LINE MESSAGE
         TM    MDBMLVL1,MDBMLR     IS IT A WTOR?
         JNO   DONE_WITH_RECID     NO, OK
         MVI   HCLRECTP,HCLWTOR    MAKE IT A WTOR
DONE_WITH_RECID DS 0H
* FIGURE OUT RECORD TYPE
         TM    MDBCMSC2,MDBCOCMD   IS IT AN OPERATOR CMD ECHO?
         JNO   NOT_OP_COMMAND      NO, TRY NEXT
         MVI   HCLREQTP,HCLCMD     YES, MARK AS OPERATOR COMMAND
         CLC   MDBCCNID,F0         IS IT AN INTERNAL CMD (CONID=0)?
         JNE   DONE_WITH_RECTYPE   NO, SO HCLCMD IS OK
         MVI   HCLREQTP,HCLINTNL   MARK IT AS INTERNAL COMMAND
         J     DONE_WITH_RECTYPE
NOT_OP_COMMAND DS 0H
         TM    MDBCATT1,MDBCMCSC   IS IT A COMMAND RESPONSE?
         JO    MARK_AS_RESPONSE    YES, MARK IT SO
         TM    MDBDESC1,MDBDESCE   IS IT DESC=5 (ALSO CMD RESP)
         JNO   DONE_WITH_RECTYPE   NO, NOT CMD RESPONSE
MARK_AS_RESPONSE DS 0H
         MVI   HCLREQTP,HCLRESP   MARK IT AS COMMAND RESPONSE
DONE_WITH_RECTYPE DS 0H
         MVC   REQUEST_TYPE,HCLREQTP SAVE FOR MULTI-LINE
* NOW FIGURE OUT WHAT CONSOLE NAME OR JOBNAME TO USE
* SHAMELESSLY LIFTED FROM THE IBM SAMPLE PROGRAM IEAMDBLG
         CLI   HCLREQTP,HCLCMD     IS IT A COMMAND?
         JNE   NOT_COMMAND         NO, TRY NEXT
         CLC   MDBCCNID,F128       IS IT AN INSTREAM COMMAND?
         JE    USE_CONSOLE_NAME    YES, USE CONSOLE NAME (INSTREAM)
         CLC   JOBNAME,BLANK_8     IS JOBNAME BLANK?
         JE    USE_CONSOLE_NAME    YES, USE CONSOLE NAME
         J     CHECK_FOR_MCS_CONSOLE GO SEE IF IT'S AN MCS CONSOLE
NOT_COMMAND DS 0H
         CLI   HCLREQTP,HCLINTNL   IS IT AN INTERNAL COMMAND?
         JNE   NOT_INTERNAL_CONSOLE_1 NO, TRY NEXT
         CLC   JOBNAME,BLANK_8     IS JOBNAME BLANK?
         JNE   USE_JOBNAME         NO, SO USE JOB NAME
         MVI   HCLREQTP,HCLCMD     CHANGE REQUEST TYPE TO "COMMAND"
         J     USE_CONSOLE_NAME    USE CONSOLE NAME (INTERNAL)
NOT_INTERNAL_CONSOLE_1 DS 0H
         CLI   HCLREQTP,HCLRESP    IS IT A COMMAND RESPONSE?
         JNE   USE_JOBNAME         NO, SO USE JOB NAME
*        TM    MDBCMCSF,MDBMCSB+MDBMCSH WAS IT SENT BY CONSOLE ID   RH2
         TM    MDBCMCSF,MDBMCSB    WAS IT SENT BY CONSOLE ID IN R0  RH2
         JZ    USE_JOBNAME         NO, USE JOB NAME
         CLC   JOBNAME,BLANK_8     IS JOBNAME BLANK?
         JNE   USE_JOBNAME         NO, SO USE JOB NAME
         CLC   MDBCCNID,F0         IS IT INTERNAL?
         JE    USE_CONSOLE_NAME    YES, USE CONSOLE NAME (INTERNAL)
         CLC   MDBCCNID,F128       IS IT INSTREAM?
         JE    USE_CONSOLE_NAME    YES, USE CONSOLE NAME (INSTREAM)
CHECK_FOR_MCS_CONSOLE DS 0H
         CLI   MDBCCNID,X'00'      IS CONSOLE CLASS ZERO (MCS)?
         JE    USE_JOBNAME         YES, USE JOB NAME
         TM    MDBCCNID,X'E0'      IS CONSOLE CLASS A JES3 CONSOLE?
         JNZ   USE_JOBNAME         YES, SO USE JOB NAME
USE_CONSOLE_NAME DS 0H
         MVC   HCLCONID,MDBCCNNM   MOVE IN CONSOLE NAME FROM MDB
         CLC   MDBCCNID,F0         IS IT "INTERNAL"?
         JNE   NOT_INTERNAL_CONSOLE_2 NO, OK
         MVC   HCLCONID,C_INTERNAL MOVE IN "INTERNAL"
         J     DONE_WITH_CONSOLE
NOT_INTERNAL_CONSOLE_2 DS 0H
         CLC   MDBCCNID,F128       IS IT "INSTREAM"?
         JNE   DONE_WITH_CONSOLE   NO, OK
         MVC   HCLCONID,C_INSTREAM MOVE IN "INSTREAM"
         J     DONE_WITH_CONSOLE   DONE WITH JOB/CONSOLE FIELD
USE_JOBNAME DS 0H
         MVC   HCLJOBID,JOBNAME    MOVE IN JOB NAME
*
DONE_WITH_CONSOLE DS 0H
* SEE IF WE NEED TO ADD MLID AT END OF MESSAGE
         NI    FLAGS,255-@APPEND_MLID TURN OFF "APPEND MLID" FLAG
         CLI   HCLRECTP,HCLMLWTO   MULTI-LINE MESSAGE?
         JNE   MLID_NOT_NEEDED     NOPE, NO MLID NEEDED
         TM    MDBDESC2,MDBDESCI   YES - OPERATOR REQUEST?
         JNO   SET_MLID_FLAG       NO, GO APPEND MLID
         CLC   BUFFER_RECORD_NO,F1 1ST OF MULTIPLE RECORDS?
         JH    MLID_NOT_NEEDED     NO, ALREADY HAVE MLID
         LR    R1,R9               GET POINTER...
         AH    R1,MDBCLEN          ...TO TEXT SEGMENT...
         AH    R1,0(R1)            ...AND POINT TO END OF THAT
         CHI   R1,3                LAST 3 CHARS OF TEXT
         MVC   MLID,0(R1)          SAVE THAT AS MLID IN THIS CASE
         J     MLID_NOT_NEEDED     AND CONTINUE
SET_MLID_FLAG DS 0H
         OI    FLAGS,@APPEND_MLID  FLAG TO ADD MLID NOW
MLID_NOT_NEEDED DS 0H
*
* PROCESS MDBT PART OF INPUT RECORD
*
         SH    R2,MDBCLEN          KEEP REMAINING LENGTH CURRENT
         AH    R9,MDBCLEN          POINT AT MDBT
         J     WRITE_SEGMENT       REC TYPE ALREADY DONE FOR 1ST REC
         DROP  R9
*
         USING MDBT,R9
MULTI_LINE_SEGMENT DS 0H
         MVC   HCLMLID,MLID        MULTI-LINE MESSAGE ID
         MVC   HCLREQTP,REQUEST_TYPE REQUEST TYPE
         MVC   HCLREQFL,REQUEST_FLAGS INIT REQUEST FLAGS
         TM    MDBTLNT1,MDBTLABT   LABEL TEXT TYPE?
         JNO   TEXT_NOT_LABEL
         MVI   HCLRECTP,HCLLABEL   YES, MARK IT AS SUCH
TEXT_NOT_LABEL DS 0H
         TM    MDBTLNT1,MDBTDATT   DATA TEXT?
         JNO   TEXT_NOT_DATA
         MVI   HCLRECTP,HCLDATA    YES, MARK IT AS SUCH
TEXT_NOT_DATA  DS 0H
         TM    MDBTLNT1,MDBTENDT   END TEXT?
         JNO   WRITE_SEGMENT
         MVI   HCLRECTP,HCLDTEND   YES, MARK IT AS SUCH
WRITE_SEGMENT  DS 0H
*
         LH    R3,MDBTLEN          LENGTH OF WHOLE TEXT SEGMENT
         AHI   R3,MDBTMBOB*-1      COMPUTE LENGTH OF TEXT PART
         LR    R1,R3               SAVE TEXT LENGTH IN R1
         AHI   R3,-1               DECREMENT FOR EXECUTE
         EX    R3,MOVE_RECORD
         TM    FLAGS,@APPEND_MLID  APPEND MLID?
         JNO   NO_MLID_NEEDED      NO
         LA    R3,HCLTEXT+1(R3)    POINT AT END OF MESSAGE
         MVI   0(R3),C' '          BLANK
         MVC   1(3,R3),MLID        ATTACH THE MLID NUMBER
         AHI   R1,4                ACCOUNT FOR EXTRA LENGTH
NO_MLID_NEEDED DS 0H
         NI    FLAGS,255-@APPEND_MLID TURN OFF THE FLAG
         AH    R1,LOGOUT_RECLEN    ADD IN CURRENT RECLEN
         STH   R1,LOGOUT_RECLEN    UPDATE RDW
         PUT   (R10),LOGOUT_RECORD
         SH    R2,MDBTLEN          SUBTRACT TEXT SEGMENT LENGTH
         JNP   WRITE_RECORD_RETURN IF ALL DONE, JUMP
         AH    R9,MDBTLEN          NOT DONE, POINT TO NEXT SEGMENT
         CH    R2,MDBTLEN          IS IT A "SHORT" MDBT?            RH4
         JNL   WRITE_NORMAL_MDBT   NO, NORMAL ONE                   RH4
         CHI   R2,MDBTMBOB         YES - ANY TEXT IN IT?            RH4
         JNH   WRITE_RECORD_RETURN NO, JUST SKIP IT                 RH4
         STH   R2,MDBTLEN          YES, SET "NEW" MDBTLEN           RH4
WRITE_NORMAL_MDBT DS 0H                                             RH4
         CLEAR LOGOUT_SPACE        CLEAR OUTPUT RECORD
         LA    R1,HCLHEADL+4       PRIME RECORD LEN + RDW LEN
         STH   R1,LOGOUT_RECLEN
         J     MULTI_LINE_SEGMENT LOOP, DO NEXT SEGMENT
*
WRITE_RECORD_RETURN DS 0H
         L     R14,R14_WRITE_RECORD
         BR    R14
         DROP  R9
         DROP  R8
*----------------------------------------------------------------------
*
* CLEANUP ROUTINE(S)
*
CLEANUP  DS 0H
         ST    R14,R14_CLEANUP
*
         JAS   R14,CLOSE_FILES
*
         CLC   MAIN_RC,F0             RETURN CODE ZERO SO FAR?
         JNE   CLEANUP_RETURN         IF NOT ZERO, JUST LEAVE
         TM    FLAGS,@GOT_A_HIT       YES, BUT DID WE FIND ANYTHING?
         JO    CLEANUP_RETURN         YES, LEAVE IT AT ZERO
         MVC   MAIN_RC,F1             NO, NOTHING FOUND.  RC=1
*
CLEANUP_RETURN DS   0H
         L     R14,R14_CLEANUP
         BR    R14
*----------------------------------------------------------------------
*
* OPEN FILES
*
OPEN_FILES DS 0H
         ST    R14,R14_OPEN_FILES
*
         MVC   OPEN(OPEN_MACRO_L),OPEN_MACRO
*
         MVC   LOGIN(LOGIN_DCB_L),LOGIN_DCB
         LA    R11,LOGIN
         OPEN  ((R11),(INPUT)),MF=(E,OPEN)
*
         MVC   LOGOUT(LOGOUT_DCB_L),LOGOUT_DCB
         LA    R10,LOGOUT
         OPEN  ((R10),(OUTPUT)),MF=(E,OPEN)
*
         MVC   SYSIN(SYSIN_DCB_L),SYSIN_DCB
         LA    R9,SYSIN
         OPEN  ((R9),(INPUT)),MF=(E,OPEN)
*
         L     R14,R14_OPEN_FILES
         BR    R14
*----------------------------------------------------------------------
*
* CLOSE FILES
*
CLOSE_FILES DS 0H
         ST    R14,R14_CLOSE_FILES
*
         MVC   CLOSE(CLOSE_MACRO_L),CLOSE_MACRO
*
         LA    R11,LOGIN
         CLOSE ((R11)),MF=(E,CLOSE) LOGIN
*
         LA    R10,LOGOUT
         CLOSE ((R10)),MF=(E,CLOSE) LOGOUT
*
         LA    R9,SYSIN
         CLOSE ((R9)),MF=(E,CLOSE) SYSIN
*
         L     R14,R14_CLOSE_FILES
         BR    R14
*----------------------------------------------------------------------
*
* READ SYSIN
*
READ_SYSIN DS 0H
         ST    R14,R14_READ_SYSIN
*
         LA    R9,SYSIN
         USING IHADCB,R9
         TM    DCBOFLGS,DCBOFOPN   WAS OPEN OK?
         JNO   READ_SYSIN_RETURN   NO, SKIP THIS
*
SYSIN_LOOP DS 0H
         GET   (R9)                READ A SYSIN RECORD
         LR    R4,R1               POINT R4 AT IT
         LR    R6,R4               SAVE ALSO IN R6
         CLI   0(R4),C'*'          COMMENT?
         JE    SYSIN_LOOP          YES, SKIP IT
* LOOK FOR "TEXT="
         LH    R5,DCBLRECL         NO, GET LENGTH OF RECORD
         LA    R2,KEYWORD_TEXT     ADDRESS OF TEXT KEYWORD
         LA    R3,L'KEYWORD_TEXT   SET LENGTH
         JAS   R14,FIND_KEYWORD    GO SCAN FOR IT
         LTR   R4,R4               FOUND IT?
         JNZ   SYSIN_FOUND_TEXT    YES, GO GRAB TEXT
* LOOK FOR "MSGID="
         LR    R4,R6               POINT R4 AT RECORD AGAIN
         LH    R5,DCBLRECL         GET LENGTH OF RECORD AGAIN
         LA    R2,KEYWORD_MSGID    ADDRESS OF MSGID KEYWORD
         LA    R3,L'KEYWORD_MSGID  SET LENGTH
         JAS   R14,FIND_KEYWORD    GO SCAN FOR IT
         LTR   R4,R4               FOUND IT?
         JNZ   SYSIN_FOUND_MSGID   YES, GO GRAB TEXT
* LOOK FOR "FIND="
         LR    R4,R6               POINT R4 AT RECORD AGAIN
         LH    R5,DCBLRECL         GET LENGTH OF RECORD AGAIN
         LA    R2,KEYWORD_FIND     ADDRESS OF FIND= KEYWORD
         LA    R3,L'KEYWORD_FIND   SET LENGTH
         JAS   R14,FIND_KEYWORD    GO SCAN FOR IT
         LTR   R4,R4               FOUND IT?
         JNZ   SYSIN_FOUND_FIND    YES, GO DECODE IT
* LOOK FOR "JOBNAME="
         LR    R4,R6               POINT R4 AT RECORD AGAIN
         LH    R5,DCBLRECL         GET LENGTH OF RECORD AGAIN
         LA    R2,KEYWORD_JOBNAME  ADDRESS OF JOBNAME= KEYWORD
         LA    R3,L'KEYWORD_JOBNAME SET LENGTH
         JAS   R14,FIND_KEYWORD    GO SCAN FOR IT
         LTR   R4,R4               FOUND IT?
         JNZ   SYSIN_FOUND_JOBNAME YES, GO HANDLE IT
* LOOK FOR "JOBID="
         LR    R4,R6               POINT R4 AT RECORD AGAIN
         LH    R5,DCBLRECL         GET LENGTH OF RECORD AGAIN
         LA    R2,KEYWORD_JOBID    ADDRESS OF JOBID= KEYWORD
         LA    R3,L'KEYWORD_JOBID  SET LENGTH
         JAS   R14,FIND_KEYWORD    GO SCAN FOR IT
         LTR   R4,R4               FOUND IT?
         JNZ   SYSIN_FOUND_JOBID   YES, GO HANDLE IT
* LOOK FOR "SYSID="
         LR    R4,R6               POINT R4 AT RECORD AGAIN
         LH    R5,DCBLRECL         GET LENGTH OF RECORD AGAIN
         LA    R2,KEYWORD_SYSID    ADDRESS OF SYSID= KEYWORD
         LA    R3,L'KEYWORD_SYSID  SET LENGTH
         JAS   R14,FIND_KEYWORD    GO SCAN FOR IT
         LTR   R4,R4               FOUND IT?
         JNZ   SYSIN_FOUND_SYSID   YES, GO HANDLE IT
*
         J     SYSIN_LOOP          DON'T KNOW, IGNORE IT
*
SYSIN_FOUND_JOBNAME DS 0H
         LR    R5,R4               SAVE STARTING POINT
         LA    R2,8                MAX LENGTH OF A JOBNAME
         XR    R3,R3               CURRENT JOBNAME LENGTH
SYSIN_FOUND_JOBNAME_LOOP DS 0H
         CLI   0(R4),C' '          END OF JOBNAME FOUND?
         JE    SYSIN_FOUND_JOBNAME_END YES
         AHI   R4,1                NEXT CHAR
         AHI   R3,1                ADD 1 TO LENGTH
         JCT   R2,SYSIN_FOUND_JOBNAME_LOOP
SYSIN_FOUND_JOBNAME_END DS 0H
         LTR   R3,R3               ANYTHING THERE?
         JNP   SYSIN_LOOP          NO, DON'T BOTHER
         STC   R3,SEARCH_JOBNAME_L SAVE LENGTH
         AHI   R3,-1
         EX    R3,SYSIN_MOVE_JOBNAME MOVE JOBNAME
         J     SYSIN_LOOP          NEXT CARD
*
SYSIN_FOUND_JOBID   DS 0H
         MVC   SEARCH_JOBID,0(R4)  SAVE SEARCH-FOR JOBID
         J     SYSIN_LOOP          NEXT CARD
*
SYSIN_FOUND_SYSID   DS 0H
         XR    R5,R5
         IC    R5,SEARCH_SYSID_COUNT GET CURRENT COUNT
         AHI   R5,1                ADD ONE
         CHI   R5,MAX_SYSIDS       TOO MANY?
         JH    SYSIN_ERROR_12      YES, ERROR
         STC   R5,SEARCH_SYSID_COUNT SAVE NEW COUNT
         AHI   R5,-1               NOW USE PREVIOUS COUNT
         MHI   R5,8                TO COMPUTE TABLE OFFSET
         LA    R3,SEARCH_SYSID     START OF SYSID TABLE
         AR    R3,R5               ADD OFFSET TO ADDRESS NEXT SLOT
         MVC   0(8,R3),0(R4)       SAVE THIS SEARCH-FOR SYSID
         J     SYSIN_LOOP          NEXT CARD
*
SYSIN_FOUND_FIND DS 0H
* LOOK FOR "FIND=EXCLUDE".  SET FLAG_INC_EXC SO THAT XOR WITH
* FOUND_FLAG REVERSES IT IF EXCLUDE WAS SPECIFIED.
         CLC   0(L'KEYWORD_EXCLUDE,R4),KEYWORD_EXCLUDE FIND=EXCLUDE?
         JE    SYSIN_FOUND_EXCLUDE YES
* LOOK FOR "FIND=QUIT"".  SET FLAG IF SO.                           RH1
         CLC   0(L'C_QUIT,R4),C_QUIT FIND=QUIT?                     RH1
         JE    SYSIN_FOUND_QUIT    YES                              RH1
*                                                                   RH1
         NI    FLAG_INC_EXC,255-@FOUND NO, ASSUME TYPE=INCLUDE
         J     SYSIN_LOOP          CONTINUE
SYSIN_FOUND_EXCLUDE DS 0H
         OI    FLAG_INC_EXC,@FOUND TYPE=EXCLUDE
         J     SYSIN_LOOP          CONTINUE
*                                                                   RH1
SYSIN_FOUND_QUIT DS 0H                                              RH1
         OI    FLAGS,@FIND_QUIT    FIND=QUIT                        RH1
         J     SYSIN_LOOP          CONTINUE                         RH1
*
SYSIN_FOUND_TEXT DS 0H             FOUND "TEXT=" FORM OF KEYWORD
         NI    FLAGS,255-@MSGKWD   TURN OFF MSGID KEYWORD FLAG
         J     SYSIN_GRAB_TEXT     NOW GO EXTRACT TEXT
SYSIN_FOUND_MSGID DS 0H            FOUND "MSGID=" FORM OF KEYWORD
         OI    FLAGS,@MSGKWD       TURN ON MSGID KEYWORD FLAG
         J     SYSIN_GRAB_TEXT     NOW GO EXTRACT TEXT
SYSIN_GRAB_TEXT DS 0H
* FOUND "TEXT=" OR "MSGID=" KEYWORD
         LR    R5,R6               1ST BYTE OF RECORD
         AH    R5,DCBLRECL         ADD LENGTH
         AHI   R5,-1               POINT R5 AT LAST BYTE OF RECORD
         CR    R4,R5               ARE WE "IN BOUNDS"?
         JNL   SYSIN_ERROR_8       NO, SOME KIND OF ERROR
         MVC   TEXT_DELIMITER,0(R4) SAVE DELIMITER
         AHI   R4,1                1ST CHAR OF TEXT ITSELF
         SR    R5,R4               LENGTH LEFT ON CARD
         JNP   SYSIN_ERROR_8       ERROR IF AT END NOW
         LR    R2,R4               SAVE 1ST BYTE IN R2
         XR    R3,R3               LENGTH IN R3
SYSIN_TEXT_LOOP DS 0H
         CLC   0(1,R4),TEXT_DELIMITER FOUND END DELIMITER YET?
         JE    SYSIN_TEXT_FOUND    YES, LEAVE LOOP
         AHI   R4,1                NO, NEXT CHAR
         AHI   R3,1                ADD 1 TO LENGTH
         JCT   R5,SYSIN_TEXT_LOOP  KEEP LOOKING
         J     SYSIN_ERROR_8       ERROR IF NOT FOUND
SYSIN_TEXT_FOUND DS 0H
         LTR   R3,R3               IS THERE A LENGTH?
         JZ    SYSIN_ERROR_8       NO, THAT'S AN ERROR
* FIND NEXT AVAILABLE SLOT IN TEXT_SPACE
         LA    R4,TEXT_SPACE       WHERE TO START
         XR    R5,R5
SYSIN_FIND_TEXT_SLOT DS 0H
         CLI   0(R4),X'00'         OPEN SPOT HERE?
         JE    SYSIN_ADD_TEXT      YES, GO
         IC    R5,0(R4)            LENGTH OF THIS ENTRY
         N     R5,F_X_7F           TURN OFF HOB
         LA    R4,1(R4,R5)         POINT R4 AT NEXT SLOT
         LA    R1,BUFFER_SPACE     "OUT OF SPACE" ADDRESS
         CR    R4,R1               GONE TOO FAR?
         JNL   SYSIN_ERROR_12      YES, ERROR
         J     SYSIN_FIND_TEXT_SLOT NO, CONTINUE
SYSIN_ADD_TEXT DS 0H
         LR    R5,R4               NEW SPOT ADDRESS
         LA    R5,1(R3,R5)         ADD LENGTH OF NEW ENTRY + 1
         LA    R1,BUFFER_SPACE     "OUT OF SPACE" ADDRESS
         CR    R5,R1               WOULD WE GO OUT-OF-BOUNDS?
         JNL   SYSIN_ERROR_12      YES, THAT WOULD BE AN ERROR
         CH    R3,MAX_TEXT_LENGTH  TOO BIG?
         JH    SYSIN_ERROR_8       YES, THAT WOULD BE AN ERROR TOO
         STC   R3,0(R4)            SAVE IT
         TM    FLAGS,@MSGKWD       WAS IT MSGID= FORM?
         JNO   SYSIN_ADD_TEXT_2    NO
         OI    0(R4),@MSGID_ONLY   YES, SET HIGH-ORDER BIT
         NI    FLAGS,255-@MSGKWD   TURN OFF FLAG
SYSIN_ADD_TEXT_2 DS 0H
         AHI   R3,-1               LENGTH - 1 FOR EXECUTE
         EX    R3,SYSIN_MOVE_TEXT  MOVE IT IN
*
         J     SYSIN_LOOP         GO TRY FOR ANOTHER RECORD
*
SYSIN_ERROR_8 DS 0H
         MVC   MAIN_RC,F8         RETURN CODE 8
         J     READ_SYSIN_RETURN
SYSIN_ERROR_12 DS 0H
         MVC   MAIN_RC,F12        RETURN CODE 12
         J     READ_SYSIN_RETURN
SYSIN_EOF DS 0H
*
READ_SYSIN_RETURN DS 0H
         L     R14,R14_READ_SYSIN
         BR    R14
         DROP  R9
*----------------------------------------------------------------------
*
* FIND_KEYWORD ROUTINE - SCAN FOR A GIVEN KEYWORD
*
* INPUT R2 - INPUT KEYWORD
*       R3 - INPUT KEYWORD LENGTH
*       R4 - INPUT STRING
*       R5 - INPUT STRING LENGTH
* OUTPUT - R4 HAS ADDRESS OF 1ST BYTE PAST THE KEYWORD, OR 0 IF
*          NOT FOUND
FIND_KEYWORD DS 0H
         ST    R14,R14_FIND_KEYWORD
*SCAN FOR KEYWORD
         SR    R5,R3               DON'T WANT SEARCH PAST END OF INPUT
         AHI   R5,1                IN CASE LENGTHS WERE EQUAL
         LTR   R5,R5               NOW - ANYTHING TO LOOK FOR?
         JNP   FIND_KEYWORD_NOT_FOUND TOO SHORT, DON'T BOTHER
         AHI   R3,-1               DECREMENT KW LENGTH FOR EXECUTE
FIND_KEYWORD_FIND_KEY DS 0H
         EX    R3,FIND_KEYWORD_CLC FOUND KEYWORD?
         JE    FIND_KEYWORD_FOUND_KEY YES
         AHI   R4,1                NEXT CHAR IN INPUT STRING
         JCT   R5,FIND_KEYWORD_FIND_KEY KEEP LOOKING
FIND_KEYWORD_NOT_FOUND DS 0H
         XR    R4,R4               INDICATE NOT FOUND
         J     FIND_KEYWORD_DONE   LEAVE
FIND_KEYWORD_FOUND_KEY DS 0H
         LA    R4,1(R3,R4)         POINT AT CHAR FOLLOWING
FIND_KEYWORD_DONE DS 0H             EXIT
         L     R14,R14_FIND_KEYWORD SET RETURN ADDRESS
         BR    R14
*----------------------------------------------------------------------
*
* CONSTANTS
*
CONSTANT_AREA DS 0D
         LTORG
*
         USING MDBSCP,R9           ADDRESSABILITY FOR EXECUTED INST
FILTER_COMPARE_JOBNAME_1 CLC SEARCH_JOBNAME(0),TEMP_MDBGJBNM
FILTER_COMPARE_JOBNAME_2 CLC SEARCH_JOBNAME(0),MDBCOJBN
         DROP  R9
         USING HCL,R8
         USING MDBT,R9
MOVE_RECORD MVC HCLTEXT(0),MDBTMSGT
         DROP  R8,R9
SYSIN_MOVE_JOBNAME MVC SEARCH_JOBNAME(0),0(R5) SAVE SEARCH-FOR JOBNAME
SYSIN_MOVE_TEXT MVC 1(0,R4),0(R2)
FIND_KEYWORD_CLC CLC 0(0,R4),0(R2)  COMPARE FOR KEYWORD
TEXT_COMPARE CLC 0(0,R4),1(R2)
*
OPEN_MACRO OPEN LOGIN_DCB,MF=L
OPEN_MACRO_L EQU *-OPEN_MACRO
*
CLOSE_MACRO CLOSE LOGOUT_DCB,MF=L
CLOSE_MACRO_L EQU *-CLOSE_MACRO
*
LOGIN_DCB   DCB   DDNAME=LOGIN,                                        X
               MACRF=(GL),                                             X
               RECFM=V,                                                X
               EODAD=LOGIN_EOF,                                        X
               DSORG=PS
LOGIN_DCB_L EQU *-LOGIN_DCB
*
LOGOUT_DCB  DCB   DDNAME=LOGOUT,                                       X
               MACRF=(PM),                                             X
               RECFM=VB,                                               X
               LRECL=259,                                              X
               DSORG=PS
LOGOUT_DCB_L EQU *-LOGOUT_DCB
*
SYSIN_DCB  DCB   DDNAME=SYSIN,                                         X
               MACRF=(GL),                                             X
               RECFM=FB,                                               X
               DSORG=PS,                                               X
               EODAD=SYSIN_EOF
SYSIN_DCB_L    EQU *-SYSIN_DCB
*
HEX_TRANSLATE   EQU *-240
                DC C'0123456789ABCDEF'
MAX_TEXT_LENGTH DC H'127'          MAX LENGTH FOR TEXT SEARCH ITEM
*
KEYWORD_TEXT    DC C'TEXT='        TEXT= KEYWORD
KEYWORD_MSGID   DC C'MSGID='       MSGID= KEYWORD
KEYWORD_FIND    DC C'FIND='        FIND= KEYWORD
KEYWORD_EXCLUDE DC C'EXCLUDE'
KEYWORD_JOBNAME DC C'JOBNAME='
KEYWORD_JOBID   DC C'JOBID='
KEYWORD_SYSID   DC C'SYSID='
C_QUIT          DC C'QUIT'                                          RH1
C_INTERNAL      DC CL8'INTERNAL'
C_INSTREAM      DC CL8'INSTREAM'
BLANK_8  DC    CL8' '
F0       DC    F'0'
F1       DC    F'1'
F8       DC    F'8'
F12      DC    F'12'
F128     DC    F'128'
F_BUFFER_SIZE DC AL4(@BUFFER_SIZE)
F_X_7F   DC    X'0000007F'
*----------------------------------------------------------------------
* DSECTS
*----------------------------------------------------------------------
* GENERAL WORK AREA
WORKAREA DSECT
RSA               DS 18F           REGISTER SAVE AREA
R14_INITIALIZE    DS F             R14 SAVE AREA
R14_PROCESS       DS F             R14 SAVE AREA
R14_CLEANUP       DS F             R14 SAVE AREA
R14_FIND_KEYWORD  DS F             R14 SAVE AREA
R14_OPEN_FILES    DS F             R14 SAVE AREA
R14_CLOSE_FILES   DS F             R14 SAVE AREA
R14_FILTER_RECORD DS F             R14 SAVE AREA
R8_R9_FILTER      DS 2F            REG SAVE AREA
R14_WRITE_RECORD  DS F             R14 SAVE AREA
R14_UNLOAD_BUFFER DS F             R14 SAVE AREA
R8_R9_UNLOAD      DS 2F            REG SAVE AREA
R14_ADD_TO_BUFFER DS F             R14 SAVE AREA
R14_SEARCH_TEXT   DS F             R14 SAVE AREA
R14_READ_SYSIN    DS F             R14 SAVE AREA
*
PARM_ADDRESS           DS F        ADDRESS OF PASSED PARM
MAIN_RC                DS F        MAIN PROGRAM RETURN CODE
QWORD                  DS 2D       GENERAL SCRATCH AREA
CURRENT_RECORD_ID      DS F
PREVIOUS_RECORD_ID     DS F
CURRENT_RECORD_ADDRESS DS F
REQUEST_FLAGS          DS CL8      REQUEST FLAGS FOR MULTI-LINE MSG
JOBNAME                DS CL8      SAVE JOBNAME
MLID                   DS CL3      MULTI-LINE MESSAGE ID
REQUEST_TYPE           DS C        SAVE REQUEST TYPE FOR MULTI-LINE
FLAGS                  DS X        PROGRAMS FLAGS
@APPEND_MLID            EQU X'80'  ...APPEND MLID TO 1ST LINE OF MSG
@MSGKWD                 EQU X'40'  ...MSGID= KEYWORD
@1STSEG                 EQU X'20'  ...WE'RE IN 1ST MDBT SEGMENT OF MSG
@GOT_A_HIT              EQU X'10'  ...WE FOUND AT LEAST ONE MATCH
@FIND_QUIT              EQU X'08'  ...QUIT AFTER THE 1ST FIND       RH1
FOUND_FLAG             DS X        PROGRAM FLAG FOR FIND ONLY
@FOUND                  EQU X'80'  ...FOUND MSG OR TEXT
FLAG_INC_EXC           DS X        FLAG FOR FLIPPING FOUND_FLAG
TEXT_DELIMITER         DS C        "TEXT=" DELIMITER
TEMP_MDBGJBNM          DS CL8
SEARCH_JOBNAME_L       DS X        LENGTH OF SEARCH_JOBNAME
SEARCH_JOBNAME         DS CL8      JOBNAME FROM SYSIN TO LOK FOR
SEARCH_JOBID           DS CL8      JOBID FROM SYSIN TO LOK FOR
MAX_SYSIDS             EQU 16      MAX NO. OF SYSIDS ALLOWED
SEARCH_SYSID_COUNT     DS X        NO. OF SYSIDS IN FOLLOWING TABLE
SEARCH_SYSID           DS (MAX_SYSIDS*8)C SYSIDS FROM SYSIN
*
OPEN     DS    (OPEN_MACRO_L)X     SPACE FOR OPEN PARMLIST
*
CLOSE    DS    (CLOSE_MACRO_L)X    SPACE FOR CLOSE PARMLIST
*
LOGIN    DS    (LOGIN_DCB_L)X      SPACE FOR LOGIN DCB
*
LOGOUT   DS    (LOGOUT_DCB_L)X     SPACE FOR LOGOUT DCB
*
SYSIN    DS    (SYSIN_DCB_L)X      SPACE FOR SYSIN DCB
*
* OUTPUT (HARDCOPY LOG FORMAT)
*
LOGOUT_RECORD DS 0F
LOGOUT_RECLEN DS H                 RDW RECLEN
LOGOUT_BLKLEN DS H                 RDW BLOCK
LOGOUT_SPACE  DS CL256             STORAGE FOR "HCL" RECORD
LOGOUT_SPACE_L EQU *-LOGOUT_SPACE
*
BUFFER_RECORD_NO DS F              CURRENT RECORD NUMBER IN BUFFER
BUFFER_SIZE   DS F                 NUMBER OF BYTES IN USE
BUFFER_COUNT  DS F                 COUNT OF RECORDS IN BUFFER
BUFFER_NEXT   DS F                 POINTER TO NEXT AVAIL SPACE
*
* TEXT_SPACE CONTAINS THE MESSAGE TEXT TO FILTER ON.  FORMAT IS
* 7 BIT LENGTH FOLLOWED BY TEXT.  IF HIGH-ORDER BIT OF LENGTH IS
* ON, TEXT IS FOR MESSAGEID COMPARE ONLY.
*
TEXT_SPACE   DS 0C                 SPACE FOR SEARCH-FOR TEXT
@MSGID_ONLY   EQU X'80'            FLAG IN LENGTH BYTE
             ORG WORKAREA+4092     MOVE TO LAST ADDRESSIBLE WORD
*
* BUFFER AREA FOR INPUT RECORDS (OPERLOG FORMAT)
*
BUFFER_SPACE DS (@BUFFER_SIZE)X    ACTUAL BUFFER SPACE
*
WORKAREA_LEN EQU *-WORKAREA        TOTAL LENGTH OF WORKAREA
*
* EQUATES
*
@BUFFER_SIZE EQU @BUFFER_LRECL*@MAX_BUFFERS AMT OF INPUT BUFFER SPACE
@BUFFER_LRECL EQU 32760            BUFFER LRECL                     RH4
@MAX_BUFFERS EQU 64                MAX NO. OF BUFFER RECORDS        RH4
@TEXT_SIZE   EQU BUFFER_SPACE-TEXT_SPACE
*----------------------------------------------------------------------
* MAPPING MACROS
*
         DCBD DSORG=PS
*
         IEAVM105
*
         IHAHCLOG
*
         END
