./ ADD NAME=$README  0121-03190-08038-1011-00183-00002-00000-TRLH
AFCSMP1 is a program I developed to access the API provided by SMP/E.
It uses control cards to build the SMP/E request (DD GIMIN), then
formats and outputs the results (DD GIMOUT).  Status and error messages
are reported via DD GIMPRINT.  It is mainly useful for extracting data
to be further processed by REXX, SAS, or whatever.  It is especially
useful in SAS, as it can be invoked directly from within the code.

This program has been run on z/OS 1.3, 1.4, 1.7. and 1.8.

This program may be used, modified, and/or shared by anyone.  Just don't
sell it, and please give me some credit.

--------------------------------------------------------------------------------

  The format of the GIMIN data is:

    KEYWORD VALUE

    ... where KEYWORD starts in column 1 and is one of:

      CSI
      ZONE
      ENTRY
      SUBENTRY
      FILTER

    The values are described in 'SMP/E Reference', 'SC28-1806', in the
    chapter 'SMP/E CSI Application Programming Interface'.

    Comments are indicated by an '*' in column 1.  Continuation is
    indicated by any non-blank in column 72.  Blanks between col 72 and
    the last parm character are ignored, and the search resumes in col 1
    of the next card.

    Maximum length of the various parms is:

     CSI:      44
     ZONE:     255
     ENTRY:    255
     SUBENTRY: 255
     FILTER:   768

  The GIMOUT data typically has a line describing the type,
  subtype, etc. followed by a line or lines containing the
  values.  For example,

    TYPE=SYSMOD
    EBB1102 TARGR7
    SUBENTRY=SMODTYPE
    FUNCTION
    SUBENTRY=APPLY
    NO

  Here's some sample jcl:

    //AFCSMP1  EXEC PGM=AFCSMP1,REGION=64M
    //SYSUDUMP DD   GIMOUT=*
    //GIMPRINT DD   GIMOUT=*
    //GIMOUT   DD   GIMOUT=*,RECFM=VB,LRECL=1028,BLKSIZE=27998
    //GIMIN    DD   *
    * LIST ALL THE FUNCTION SYSMODS IN TARGR7
    CSI SYSS.GLOBAL.CSI
    ZONE TARGR7
    ENTRY SYSMOD
    SUBENTRY *
    FILTER SMODTYPE='FUNCTION'
    /*

  It can also be executed directly from within a SAS program, like
  this:

// SET GZONE=SYSS.GLOBAL.CSI             SMPE GLOBAL ZONE DATASET
//*-----------------------------------------------------------
//SAS      EXEC SAS,PARM='SORT=4,SYSPARM=&GZONE.'
//GIMIN    DD   DISP=(NEW,PASS),DSN=&&SYSIN,
//  UNIT=VIO,SPACE=(TRK,(5,5)),
//  RECFM=FB,LRECL=80,BLKSIZE=0
//GIMOUT   DD   DISP=(NEW,PASS),DSN=&&SYSOUT,
//  UNIT=SYSDA,SPACE=(TRK,(90,90)),
//  RECFM=VB,LRECL=1028,BLKSIZE=0
//GIMPRINT DD   SYSOUT=*
//SYSIN    DD   *

  /*
  ** PRODUCE "GIMIN" STATEMENTS TO RETRIEVE THE ZONE INDEX DATA
  */

  DATA _NULL_;
    FILE GIMIN NOPRINT OLD ;
    GZONE = SYSPARM();
    PUT "CSI " GZONE;
    PUT "ZONE GLOBAL                                       ";
    PUT "ENTRY GLOBALZONE                                  ";
    PUT "SUBENTRY ZONEINDEX                                ";
    STOP;

  /*
  ** INVOKE THE SMPE API PROGRAM TO EXTRACT THE DATA TO FILE GIMOUT
  */

  PROC AFCSMP1;

  /*
  ** PROCESS THE GIMOUT DATA
  */

  DATA ZONES;
    KEEP ZONE ZONETYP;
    INFILE GIMOUT LENGTH=LEN;
    INPUT @1 ALINE $VARYING200. LEN;
    IF INDEX(ALINE,",") > 0 THEN DO;
       ZONE = SCAN(ALINE,1,",");
       ZONETYP = SCAN(ALINE,3,",");
       OUTPUT;
    END;
/*

  This example produces the SAS dataset ZONES with zone name ("ZONE")
  and type ("ZONETYP", TARGET or DLIB), read directly from SMPE
  via the API.  I ignored the zone dsname in this example, but
  it's there.

--------------------------------------------------------------------------------

The members in this dataset are:

$README  - I guess you already know about this one.
#DDDEFS  - Data file used by the APPSINCE sample job.  This dataset
           specifies the relationships between SMPE target DDDEFs and
           actual production datasets in our shop.  THIS ONLY APPLIES
           TO OUR SHOP.  You'll have to provide your own target/production
           relationships if you want to use this.
AFCSMP1  - The assembler source for the API program.  AFC stands for
           'Airborne Freight Corporation', by the way - my former
           employer, absorbed by my current employer, DHL.
APSELECT - SAS macro used by the APPSINCE sample job to specify the CSI,
           zone, and date range of the SYSMODs you want to implement.
APPSINCE - An example of a SAS job that uses the AFCSMP1 program.  Ever
           install a few PTFs and want to implement them, but didn't
           want to copy all the complete target libraries?  Wouldn't it
           be nice to have a job that just copied the changed elements?
           That's what this job generates.
ASMJCL   - JCL to assemble and link the program.
ENTERX   - A macro, used by AFCSMP1 for entry housekeeping.
EXECJCL  - JCL to run the program
FUNCLIST - Another example of a SAS job that uses AFCSMP1.  This sample
           produces:

             A report of all FMIDs in all the zones referenced by a
             particular global CSI.  The report is in the form of a
             SAS "PROC PRINT", a DCF version (TSO SCRIPT), and an HTML
             version for Web browsers.

             A DCF report of FMIDs in need of APPLY (RECEIVEd but not
             APPLYd)

             A DCF report of FMIDs in need of ACCEPT (APPLYd but not
             ACCEPTed)

             A DCF report of FMIDs needing to be REJECTed (APPLYd and
             ACCEPTed and still in the GLOBAL zone)

             A DCF report of FMIDs that are in the global FMID list
             that should be removed.  These are FMIDs for which you are
             still RECEIVEing service, but which are no longer APPLYd
             or ACCEPTed anywhere.

             A DCF report of FMIDs that need to be added to the global
             FMID list.  These are APPLYd or ACCEPTed somewhere, but
             you are not getting service for them.

           This sample references a dataset

LEAVEX   - A macro, used by AFCSMP1 for exit housekeeping.

Richard Hobt
DHL Worldwide Express
7501 E. Hartford Drive
Scottsdale, AZ.  85255
(480) 375-7320
Rich.Hobt@dhl.com

Feb. 7, 2008
./ ADD NAME=#DDDEFS  0101-03192-06279-0836-00135-00135-00000-TRLH
*
* THIS DATASET LISTS THE ACTUAL PRODUCTION DATASET DESTINATIONS
* FOR SMPE DDDEFS.  IT IS USED BY THE 'APPSINCE' JOBS TO BUILD
* IMPLEMENTATION JCL.
* 1ST THING IS DDDEF NAME, 2ND THING IS OUTPUT DDNAME,
* 3RD THING IS PRODUCTION DATASET NAME.  COMMENTS MAY FOLLOW
AKQLINK  LINKIBM  SYS1.LINKLIST.IBM      PPFA MODULES
APSLINK  LINKIBM  SYS1.LINKLIST.IBM      PSF MODULES
BBACTDEF OBBACTDF SYS1.BOOLE.BBACTDEF    B&B
BBCLIB   OBBCLIB  SYS1.BOOLE.BBCLIB      B&B
BBCMOD   OBBCMOD  SYS1.BOOLE.BBCMOD      B&B
BBHELP   OBBHELP  SYS1.BOOLE.BBHELP      B&B
BBILIB   OBBILIB  SYS1.BOOLE.BBILIB      B&B
BBLINK   OBBLINK  SYS1.BOOLE.BBLINK      B&B
BBLOAD   OBBLOAD  SYS1.BOOLE.BBLOAD      B&B
BBMAC    OBBMAC   SYS1.BOOLE.BBMAC       B&B
BBMLIB   OBBMLIB  SYS1.BOOLE.BBMLIB      B&B
BBPARM   OBBPARM  SYS1.BOOLE.BBPARM      B&B
BBPLIB   OBBPLIB  SYS1.BOOLE.BBPLIB      B&B
BBPROC   OBBPROC  SYS1.BOOLE.BBPROC      B&B
BBPROF   OBBPROF  SYS1.BOOLE.BBPROF      B&B
BBSAMP   OBBSAMP  SYS1.BOOLE.BBSAMP      B&B
BBSDEF   OBBSDEF  SYS1.BOOLE.BBSDEF      B&B
BBSLIB   OBBSLIB  SYS1.BOOLE.BBSLIB      B&B
BBSRC    OBBSRC   SYS1.BOOLE.BBSRC       B&B
BBTLIB   OBBTLIB  SYS1.BOOLE.BBTLIB      B&B
BBUSER   OBBUSER  SYS1.BOOLE.BBUSER      B&B
BBVDEF   OBBVDEF  SYS1.BOOLE.BBVDEF      B&B
BBYCOPY  OBBYCOPY SYS1.BOOLE.BBYCOPY     B&B
CAILIB   LINKCAI  SYS1.LINKLIST.CAILIB   CA MODULES
DCFASM   ODUMMY   NULLFILE               DCF SOURCE STUFF?
DCFGML   ODCFGML  SYS2.DCFMAC            DCF MACROS
DCFLOAD  LINKIBM  SYS1.LINKLIST.IBM      DCF MODULES
DCFSAMP  OHELP    SYS2.HELP              DCF MISC (INC HELP)
DZILINK  LINKIBM  SYS1.LINKLIST.IBM      OGL MODULES
GDDMLOAD LINKIBM  SYS1.LINKLIST.IBM      GDDM MODULES
HASPLOAD LINKCCCC SYS1.LINKLIB.CCAT01    SHOULD BE ON CCAT01 BEFORE SYNC
HASPMIG  MIGCCCC  SYS1.MIGLIB.CCAT01     SHOULD BE ON CCAT01 BEFORE SYNC
HELP     OHELP    SYS2.HELP              TSO HELP
ICEDGTL  LINKCCCC SYS1.LINKLIB.CCAT01    SHOULD BE ON CCAT01 BEFORE SYNC
ICQCCLIB OICQCLIB SYS2.ICQ.COMMANDS      ICF CLISTS
MACLIB   ODUMMY   NULLFILE               TARGPP MACLIB, NOT NEEDED
MSGENP   ODUMMY   NULLFILE               NOT NEEDED
MSGENU   ODUMMY   NULLFILE               NOT NEEDED
PARMLIB  ODUMMY   NULLFILE               PROBABLY NOT NEEDED
PLILINK  LINKIBM  SYS1.LINKLIST.IBM      PL/1 RUNTIME
PROCLIB  ODUMMY   NULLFILE               PROBABLY NOT NEEDED
SACLINK  OSACLINK SYS3.IXFP.SACLINK      IXFP SAS/C TRANSIENT LIB
SAMPLIB  ODUMMY   NULLFILE               PROBABLY NOT NEEDED
SAPKMOD1 LINKIBM  SYS1.LINKLIST.IBM      ACIF LOAD MODS
SAPKSAM1 ODUMMY   NULLFILE               ACIF?
SAPPMOD1 ODUMMY   NULLFILE               ACIF?
SAPPSAMP ODUMMY   NULLFILE               ACIF?
SAPQMOD1 ODUMMY   NULLFILE               ACIF LOAD MODS - NOT USED
SAPQMOD2 ODUMMY   NULLFILE               ACIF LOAD MODS - NOT USED
SAPQSAM1 ODUMMY   NULLFILE               ACIF?
SASCOMOD OSASCOMD SYS1.BOOLE.SASCOMOD    B&B
SASMMAC1 ODUMMY   NULLFILE               HL ASSEMBLER MACROS
SASMMOD1 LINKIBM  SYS1.LINKLIST.IBM      HL ASSEMBLER MODULES
SBLMMOD1 LINKIBM  SYS1.LINKLIST.IBM      INFO MODULES
SBLMTXT1 LINKIBM  SYS1.LINKLIST.IBM      INFO MODULES
SDGTPSRC ODUMMY   NULLFILE               WHAT IS IT?
SEDCLINK OEDCLINK SYS2.SEDCLINK          C/370
SEDGPENU TEMPPLIB TEMP.PLIB.DATASET      NEEDS TO HAVE PANLCONV RUN
SEEQINST ODUMMY   NULLFILE               HCM STUFF
SEOYPENU TEMPPLIB TEMP.PLIB.DATASET      NEEDS TO HAVE PANLCONV RUN
SEPWPENU TEMPPLIB TEMP.PLIB.DATASET      NEEDS TO HAVE PANLCONV RUN
SEQQCLIB OEQQCLIB SYS2.OPC.SEQQCLIB      OPC CLISTS
SEQQLMD0 LINKOPC  SYS1.LINKLIST.OPC      OPC LOAD MODS
SEQQMSG0 OEQQMSG0 SYS2.OPC.SEQQMSG0      OPC "MESSAGES"
SEQQPENU OEQQPENU SYS2.OPC.SEQQPENU      OPC PANELS
SEUVPNL  TEMPPLIB TEMP.PLIB.DATASET      NEEDS TO HAVE PANLCONV RUN
SEWXAUTH LINKIBM  SYS1.LINKLIST.IBM      LANRES/MVS
SEWXEXEC OEWXEXEC SYS2.SEWEXEC           LANRES/MVS
SEWXLMOD LINKPROD SYS1.LINKLIST.PROD     LANRES/MVS
SEWXMSGS OEWXMSGS SYS2.SEWXMSGS          LANRES/MVS
SEWXPLIB OEWXPLIB TEMP.PLIB.DATASET
SEWXSAMP ODUMMY   NULLFILE               LANRES/MVS
SEWXSLIB OEWXSLIB SYS2.SEWXSLIB          LANRES/MVS
SEWXSRVC ODUMMY   NULLFILE               LANRES/MVS
SEZACMAC ODUMMY   NULLFILE               WHAT IS IT?
SEZACMTX ODUMMY   NULLFILE               TCP/IP
SEZADBRM ODUMMY   NULLFILE               WHAT IS IT?
SEZADSIL ODUMMY   NULLFILE               TCP/IP
SEZAINST ODUMMY   NULLFILE               WHAT IS IT?
SEZALIBN ODUMMY   NULLFILE               TCP/IP
SEZALINK ODUMMY   NULLFILE               TCP/IP
SEZALNK2 ODUMMY   NULLFILE               TCP/IP
SEZAPENU TEMPPLIB TEMP.PLIB.DATASET      NEEDS TO HAVE PANLCONV RUN
SEZARNT1 ODUMMY   NULLFILE               WHAT IS IT?
SEZATCP  ODUMMY   NULLFILE               TCP/IP
SGDDMSAM ODUMMY   NULLFILE               GDDM ASSEMBLER SOURCE/MACROS
SGIMCLS0 PRODCLST PROD.CLIST             SMPE CLISTS
SGIMLINK LINKIBM  SYS1.LINKLIST.IBM      SMP/E MODULES
SGIMLMD0 LINKIBM  SYS1.LINKLIST.IBM      SMP/E MODULES
SGIMSENU PRODSLIB PROD.ISPF.ISPSLIB      SMPE SKELETONS
SIBASM   ODUMMY   NULLFILE               IXFP ASSEMBLER SOURCE
SIBCLIB  OSIBCLIB SYS3.IXFP.SIBCLIB      IXFP CLISTS
SIBLINK  LINKIBM  SYS1.LINKLIST.IBM      IXFP LOAD MODS
SIBLOAD  LINKIBM  SYS1.LINKLIST.IBM      IXFP LOAD MODS
SIBMAC   ODUMMY   NULLFILE               IXFP ASSEMBLER MACROS
SIBMBASE LINKIBM  SYS1.LINKLIST.IBM      PL/1
SIBMLIB  OSIBMLIB SYS3.IXFP.SIBMLIB      IXFP ISPF MESSAGES
SIBMLINK LINKIBM  SYS1.LINKLIST.IBM      PL/1
SIBPLIB  OSIBPLIB SYS3.IXFP.SIBPLIB      IXFP ISPF PANELS
SIBRTNS  ODUMMY   NULLFILE               IXFP COMMON PARSER (?)
SIBSAMP  ODUMMY   NULLFILE               IXFP SAMPLES
SIBSAS   ODUMMY   NULLFILE               IXFP SAS SAMPLES
SIBSLIB  OSIBSLIB SYS3.IXFP.SIBSLIB      IXFP ISPF SKELETONS
SIBTLIB  OSIBTLIB PROD.ISPF.ISPTLIB      IXFP ISPF TABLE (1 MEMBER)
SICELINK LINKIBM  SYS1.LINKLIST.IBM      SORT MODULES
SICELNKN ODUMMY   NULLFILE               SORT NON-RESIDENT STUFF
SICELPA  LPASHARE SYS1.LPALIB.SHARED     SORT
SICESAMP ODUMMY   NULLFILE               SORT SAMPLES
SIFALIB  LINKIBM  SYS1.LINKLIST.IBM
SIMWMOD1 LINKIBM  SYS1.LINKLIST.IBM      WEBSRV/MVS
SIOEPNLE TEMPPLIB TEMP.PLIB.DATASET      NEEDS TO HAVE PANLCONV RUN
SISFJCL  ODUMMY   NULLFILE               SDSF STARTED TASK JCL - NOT NEEDED
SISFMLIB PRODMLIB PROD.ISPF.ISPMLIB      SDSF MESSAGES
SISFPLIB TEMPPLIB TEMP.PLIB.DATASET      NEEDS TO HAVE PANLCONV RUN
SISFSRC  ODUMMY   NULLFILE               SDSF SOURCE - NOWHERE TO GO
SISFTLIB TEMPTLIB TEMP.TLIB.DATASET      SDSF TABLES
SISPGENU ODUMMY   NULLFILE               ISPF DTL SOURCE
SISPGMLI ODUMMY   NULLFILE               ISPF DTL SOURCE
SISPGUI  ODUMMY   NULLFILE               ISPF W/S CODE UPLOAD FILE
SISPMACS ODUMMY   NULLFILE               ISPF ASSEMBLER MACROS
SISPPENU TEMPPLIB TEMP.PLIB.DATASET      NEEDS TO HAVE PANLCONV RUN
SISPSAMP ODUMMY   NULLFILE               ISPF SAMPLE STUFF
SISTCLI0 PRODCLST PROD.CLIST             VTAM CLISTS
SISTDAT2 ODUMMY   NULLFILE               WHAT IS IT?
SISTDBUG ODUMMY   NULLFILE               WHAT IS IT?
SISTMAC1 ODUMMY   NULLFILE               VTAM MACROS?
SKPRTNS  ODUMMY   NULLFILE               IXFP ROUTINES
SSAROMOD ODUMMY   NULLFILE               IXFP SAS/C RESIDENT LIB
STKLOAD  NOTIBM   SYS1.LINKLIST.NOTIBM   IXFP LOAD MODS
./ ADD NAME=AFCSMP1  0105-03191-06279-0825-00843-00782-00000-TRLH
         TITLE 'A F C S M P 1  -- BATCH EXECUTION OF SMPE API'
         YREGS
***********************************************************************
*                                                                     *
* AFCSMP1 -- BATCH EXECUTION OF SMPE API INTERFACE                    *
*                                                                     *
*   THIS PROGRAM CALLS THE SMPE API INTERFACE WITH PARMS SPECIFIED    *
*   VIA DDNAME GIMIN.  OUTPUT IS FORMATTED IN A VB DATASET ALLOCATED  *
*   TO DDNAME GIMOUT.  STATUS, ERROR MESSAGES, ETC. ARE REPORTED VIA  *
*   DDNAME GIMPRINT.  IT'S MAINLY USEFUL FOR GENERATING DATA TO BE    *
*   FURTHER PROCESSED BY SAS OR REXX PROGRAMS.                        *
*                                                                     *
*   NOTE -- SOME QUERYS CAN TAKE A VERY LONG TIME, AND YOU MIGHT      *
*   THINK IT'S LOOPING, BUT PROBABLY NOT.  FOR EXAMPLE, I RAN THE     *
*   FOLLOWING, AND IT TOOK ALMOST AN HOUR AND A HALF:                 *
*                                                                     *
*     CSI SYSS.GLOBAL.CSI                                             *
*     ZONE TARGR7,DLIBR7                                              *
*     ENTRY ELEMENT                                                   *
*     SUBENTRY SYSLIB,DISTLIB                                         *
*                                                                     *
*                                                                     *
*   THE FORMAT OF THE GIMIN DATA IS:                                  *
*                                                                     *
*     KEYWORD VALUE                                                   *
*                                                                     *
*     WHERE KEYWORD STARTS IN COLUMN 1 AND IS ONE OF:                 *
*                                                                     *
*       CSI                                                           *
*       ZONE                                                          *
*       ENTRY                                                         *
*       SUBENTRY                                                      *
*       FILTER                                                        *
*                                                                     *
*     THE VALUES ARE DESCRIBED IN 'SMP/E REFERENCE', 'SC28-1806',     *
*     IN THE CHAPTER 'SMP/E CSI APPLICATION PROGRAMMING INTERFACE'.   *
*                                                                     *
*     COMMENTS ARE INDICATED BY AN '*' IN COLUMN 1.                   *
*     CONTINUATION IS INDICATED BY ANY NON-BLANK IN COLUMN 72.        *
*     BLANKS BETWEEN COL 72 AND THE LAST PARM CHARACTER ARE           *
*     IGNORED, AND THE SEARCH RESUMES IN COL 1 OF THE NEXT            *
*     CARD.                                                           *
*                                                                     *
*     MAXIMUM LENGTH OF THE VARIOUS PARMS IS:                         *
*      CSI:      44                                                   *
*      ZONE:     255                                                  *
*      ENTRY:    255                                                  *
*      SUBENTRY: 255                                                  *
*      FILTER:   768                                                  *
*     ALTHOUGH YOU MIGHT WANT TO CHECK THE ACTUAL ENTRIES IN THE      *
*     WORKAREA DSECT TO BE SURE.                                      *
*                                                                     *
*   THE GIMOUT DATA TYPICALLY HAS A LINE DESCRIBING THE TYPE,         *
*   SUBTYPE, ETC. FOLLOWED BY A LINE OR LINES CONTAINING THE          *
*   VALUES.  FOR EXAMPLE,                                             *
*                                                                     *
*     TYPE=SYSMOD                                                     *
*     EBB1102 TARGR7                                                  *
*     SUBENTRY=SMODTYPE                                               *
*     FUNCTION                                                        *
*     SUBENTRY=APPLY                                                  *
*     NO                                                              *
*                                                                     *
*   HERE'S SOME SAMPLE JCL:                                           *
*                                                                     *
*     //AFCSMP1  EXEC PGM=AFCSMP1,REGION=64M                          *
*     //SYSUDUMP DD   GIMOUT=*                                        *
*     //GIMPRINT DD   GIMOUT=*                                        *
*     //GIMOUT   DD   GIMOUT=*,RECFM=VB,LRECL=1028,BLKSIZE=27998      *
*     //GIMIN    DD   *                                               *
*     * LIST ALL THE FUNCTION SYSMODS IN TARGR7                       *
*     CSI SYSS.GLOBAL.CSI                                             *
*     ZONE TARGR7                                                     *
*     ENTRY SYSMOD                                                    *
*     SUBENTRY *                                                      *
*     FILTER SMODTYPE='FUNCTION'                                      *
*     /*                                                              *
*                                                                     *
*   IT CAN ALSO BE EXECUTED DIRECTLY FROM WITHIN A SAS PROGRAM, LIKE  *
*   THIS:                                                             *
*                                                                     *
* // SET GZONE=SYSS.GLOBAL.CSI             SMPE GLOBAL ZONE DATASET   *
* //*-----------------------------------------------------------      *
* //SAS      EXEC SAS,PARM='SORT=4,SYSPARM=&GZONE.'                   *
* //GIMIN    DD   DISP=(NEW,PASS),DSN=&&SYSIN,                        *
* //  UNIT=VIO,SPACE=(TRK,(5,5)),                                     *
* //  RECFM=FB,LRECL=80,BLKSIZE=0                                     *
* //GIMOUT   DD   DISP=(NEW,PASS),DSN=&&SYSOUT,                       *
* //  UNIT=SYSDA,SPACE=(TRK,(90,90)),                                 *
* //  RECFM=VB,LRECL=1028,BLKSIZE=0                                   *
* //GIMPRINT DD   SYSOUT=*                                            *
* //SYSIN    DD   *                                                   *
*                                                                     *
*   /*                                                                *
*   ** PRODUCE "GIMIN" STATEMENTS TO RETRIEVE THE ZONE INDEX DATA     *
*   */                                                                *
*                                                                     *
*   DATA _NULL_;                                                      *
*     FILE GIMIN NOPRINT OLD ;                                        *
*     GZONE = SYSPARM();                                              *
*     PUT "CSI " GZONE;                                               *
*     PUT "ZONE GLOBAL                                       ";       *
*     PUT "ENTRY GLOBALZONE                                  ";       *
*     PUT "SUBENTRY ZONEINDEX                                ";       *
*     STOP;                                                           *
*                                                                     *
*   /*                                                                *
*   ** INVOKE THE SMPE API PROGRAM TO EXTRACT THE DATA TO FILE GIMOUT *
*   */                                                                *
*                                                                     *
*   PROC AFCSMP1;                                                     *
*                                                                     *
*   /*                                                                *
*   ** PROCESS THE GIMOUT DATA                                        *
*   */                                                                *
*                                                                     *
*   DATA ZONES;                                                       *
*     KEEP ZONE ZONETYP;                                              *
*     INFILE GIMOUT LENGTH=LEN;                                       *
*     INPUT @1 ALINE $VARYING200. LEN;                                *
*     IF INDEX(ALINE,",") > 0 THEN DO;                                *
*        ZONE = SCAN(ALINE,1,",");                                    *
*        ZONETYP = SCAN(ALINE,3,",");                                 *
*        OUTPUT;                                                      *
*     END;                                                            *
* /*                                                                  *
*                                                                     *
*   THIS EXAMPLE PRODUCES THE DATASET ZONES WITH ZONE NAME ("ZONE")   *
*   AND TYPE ("ZONETYP", TARGET OR DLIB), READ DIRECTLY FROM SMPE     *
*   VIA THE API.  I IGNORED THE ZONE DSNAME IN THIS EXAMPLE, BUT      *
*   IT'S THERE.                                                       *
*                                                                     *
* CHANGES:                                                            *
*                                                                     *
* 07/17/2003  RLH  LOGIC DIDN'T ALLOW FOR SINGLE CHARACTER ON     RLH1*
*                  INPUT CONTINUATION CARD.                       RLH1*
*                                                                     *
* RICHARD HOBT                                                        *
* AIRBORNE FREIGHT CORPORATION                                        *
* 3101 WESTERN AVENUE                                                 *
* SEATTLE, WA.  98121                                                 *
* (206) 830-4088                                                      *
* RICH.HOBT@AIRBORNE.COM                                              *
*                                                                     *
***********************************************************************
*
AFCSMP1  ENTERX (R12),(,WORKAREA_LEN,C),AMODE=31,RMODE=24
         USING WORKAREA,R13
*
         BRAS  R14,INITIALIZE      INITIALIZE
*
         BRAS  R14,OPEN_FILES      OPEN FILES
         CLC   OUR_RETURN_CODE,=F'0' OPEN OK?
         JNE   CLEANUP             NO, JUST LEAVE NOW
*
         BRAS  R14,READ_INPUT      READ INPUT AND REPORT ON IT
         CLC   OUR_RETURN_CODE,=F'0' PARMS OK?
         JNE   CLEANUP             NO, JUST LEAVE NOW
*
         BRAS  R14,CALL_API        GO CALL THE API
         CLC   OUR_RETURN_CODE,=F'0' API CALL OK?
         JNE   CLEANUP             NO, JUST LEAVE NOW
*
         BRAS  R14,PROCESS_LISTS   PROCESS THE API RESULTS
*
CLEANUP  DS    0H                  CLOSE FILES, FREE STORAGE, ETC.
         BRAS  R14,CLEAN_UP
*
EGRESS   DS    0H
         L     R15,OUR_RETURN_CODE FINAL RETURN CODE
         LEAVEX                    ALL DONE
*
*
*
*
*
*
*
INITIALIZE DS 0H
*
* INITIALIZE THOSE THINGS THAT NEED IT
*
         ST    R14,R14_INITIALIZE        SAVE RETURN ADDR
         XC    FLAGS,FLAGS            CLEAR FLAG
         XC    QUERY_PARMS,QUERY_PARMS
         XC    OUR_RETURN_CODE,OUR_RETURN_CODE
         XC    OUTBUFFER_LEN,OUTBUFFER_LEN
         MVC   INDCB(@KINDCB),KINDCB  INIT GIMIN DCB
         MVC   OUTDCB(@KOUTDCB),KOUTDCB INIT GIMOUT DCB
         MVC   RPTDCB(@KRPTDCB),KRPTDCB INIT GIMPRINT DCB
         MVC   OPEN(@KOPEN),KOPEN INIT OPEN PARMLIST
         MVC   CLOSE(@KCLOSE),KCLOSE INIT CLOSE PARMLIST
         MVC   TIME(@KTIME),KTIME INIT TIME PARMLIST
INITIALIZE_RETURN DS 0H
         L     R14,R14_INITIALIZE  WHERE TO RETURN TO
         BR    R14                 GO BACK
*
* OPEN THE INPUT AND OUTPUT FILES
*
OPEN_FILES DS 0H
         ST    R14,R14_OPEN
OPEN_INPUT DS 0H
         LA    R11,INDCB           ADDRESS INPUT DCB
         USING IHADCB,R11
         OPEN  ((R11),(INPUT)),MF=(E,OPEN)   OPEN IT
         TM    DCBOFLGS,DCBOFOPN   DID IT WORK?
         JO    OPEN_OUTPUT         YES, CONTINUE
         MVC   OUR_RETURN_CODE,=F'12' OPEN GIMIN FAILURE
         J     OPEN_FILES_RETURN
*
OPEN_OUTPUT DS 0H
         LA    R11,OUTDCB
         OPEN  ((R11),(OUTPUT)),MF=(E,OPEN)
         TM    DCBOFLGS,DCBOFOPN   DID IT WORK?
         JO    OPEN_GIMPRINT       YES, CONTINUE
         MVC   OUR_RETURN_CODE,=F'16' OPEN GIMOUT FAILURE
         J     OPEN_FILES_RETURN
*
OPEN_GIMPRINT DS 0H
         LA    R11,RPTDCB
         OPEN  ((R11),(OUTPUT)),MF=(E,OPEN)
         TM    DCBOFLGS,DCBOFOPN   DID IT WORK?
         JO    OPEN_FILES_RETURN   YES, CONTINUE
         MVC   OUR_RETURN_CODE,=F'20' OPEN GIMPRINT FAILURE
         J     OPEN_FILES_RETURN
OPEN_FILES_RETURN DS 0H
         L     R14,R14_OPEN
         BR    R14                 RETURN TO CALLER
*
*
* READ GIMIN AND REPORT WHAT WE FOUND
*
READ_INPUT DS  0H
         ST    R14,R14_READ        SAVE RETURN ADDRESS
         MVC   GIMPRINT,=CL133' --- GIMIN DATA: ----------------------'
         BRAS  R14,WRITE_GIMPRINT  WRITE A HEADING
         MVC   GIMPRINT,=CL133' '
READ_LOOP DS   0H
         GET   INDCB,INBUFFER      READ A RECORD
         MVC   GIMPRINT+1(80),INBUFFER   ECHO
         BRAS  R14,WRITE_GIMPRINT  IT TO GIMPRINT
         CLI   INBUFFER,C'*'       COMMENT?
         JE    READ_LOOP           YES, SKIP IT
CSI_TEST DS    0H
         CLC   CSI_K,INBUFFER      CSI KEYWORD?
         JNE   ZONE_TEST           NO, TRY ZONE
         LA    R1,INBUFFER+L'CSI_K POINT AT START OF CSI DATA
         BRAS  R14,EXTRACT_TEXT
         CHI   R2,L'CSI_NAME       TOO BIG?
         JH    PARM_ERROR          YES, LEAVE
         ST    R2,CSILEN           SAVE LENGTH
         BCTR  R2,0                REDUCE FOR EXECUTE
         LA    R3,CSI_NAME         POINT AT TARGET AREA
         EX    R2,MOVE_THING       MOVE TEXT
         J     READ_LOOP           KEEP GOING
*
ZONE_TEST DS   0H
         CLC   ZONE_K,INBUFFER     ZONE KEYWORD?
         JNE   ENTRY_TEST          NO, TRY ENTRY
         LA    R1,INBUFFER+L'ZONE_K POINT AT START OF ZONE DATA
         BRAS  R14,EXTRACT_TEXT
         CHI   R2,L'ZONE_NAME      TOO BIG?
         JH    PARM_ERROR          YES, LEAVE
         ST    R2,ZONELEN          SAVE LENGTH
         BCTR  R2,0                REDUCE FOR EXECUTE
         LA    R3,ZONE_NAME        POINT AT TARGET AREA
         EX    R2,MOVE_THING       MOVE TEXT
         J     READ_LOOP           KEEP GOING
*
ENTRY_TEST DS  0H
         CLC   ENTRY_K,INBUFFER    ENTRY KEYWORD?
         JNE   SUBENTRY_TEST       NO, TRY SUBENTRY
         LA    R1,INBUFFER+L'ENTRY_K POINT AT START OF ENTRY DATA
         BRAS  R14,EXTRACT_TEXT
         CHI   R2,L'ENTRY_NAME      TOO BIG?
         JH    PARM_ERROR          YES, LEAVE
         ST    R2,ENTRYLEN         SAVE LENGTH
         BCTR  R2,0                REDUCE FOR EXECUTE
         LA    R3,ENTRY_NAME       POINT AT TARGET AREA
         EX    R2,MOVE_THING       MOVE TEXT
         J     READ_LOOP           KEEP GOING
*
SUBENTRY_TEST DS 0H
         CLC   SUBENTRY_K,INBUFFER SUBENTRY KEYWORD?
         JNE   FILTER_TEST         NO, TRY FILTER
         LA    R1,INBUFFER+L'SUBENTRY_K POINT AT START OF SUBENTRY DATA
         BRAS  R14,EXTRACT_TEXT
         CHI   R2,L'SUBENTRY_NAME       TOO BIG?
         JH    PARM_ERROR          YES, LEAVE
         ST    R2,SUBENTRYLEN      SAVE LENGTH
         BCTR  R2,0                REDUCE FOR EXECUTE
         LA    R3,SUBENTRY_NAME    POINT AT TARGET AREA
         EX    R2,MOVE_THING       MOVE TEXT
         J     READ_LOOP           KEEP GOING
FILTER_TEST DS 0H
         CLC   FILTER_K,INBUFFER FILTER KEYWORD?
         JNE   READ_LOOP           NO, IGNORE IT
         LA    R1,INBUFFER+L'FILTER_K POINT AT START OF FILTER DATA
         BRAS  R14,EXTRACT_TEXT
         CHI   R2,L'FILTER_NAME       TOO BIG?
         JH    PARM_ERROR          YES, LEAVE
         ST    R2,FILTERLEN        SAVE LENGTH
         LR    R0,R1                   ADDRESS FROM ...
         LR    R1,R2                   ... AND LENGTH
         LR    R3,R1                   LENGTH...
         LA    R2,FILTER_NAME          ... AND ADDRESS TO
         MVCL  R2,R0               MOVE FILTER DATA
         J     READ_LOOP           KEEP GOING
*
EODAD    DS    0H
         LA    R11,INDCB           ADDRESS INPUT DCB
         CLOSE ((R11)),MF=(E,CLOSE) DONE WITH THIS FILE
*
* REPORT THE PARMS AS WE UNDERSTAND THEM
*
         MVC   GIMPRINT,=CL133' --- GIMAPI PARMS: --------------------'
         BRAS  R14,WRITE_GIMPRINT  WRITE A HEADING
*
         LA    R1,CSI_NAME         CSI PARM AND LENGTH
         L     R2,CSILEN
         LA    R3,CSI_R            "CSI:" HEADER
         BRAS  R14,REPORT_PARM     GO REPORT THIS PARM
*
         LA    R1,ZONE_NAME
         L     R2,ZONELEN
         LA    R3,ZONE_R           "ZONE:" HEADER
         BRAS  R14,REPORT_PARM     GO REPORT THIS PARM
*
         LA    R1,ENTRY_NAME
         L     R2,ENTRYLEN
         LA    R3,ENTRY_R          "ENTRY:" HEADER
         BRAS  R14,REPORT_PARM     GO REPORT THIS PARM
*
         LA    R1,SUBENTRY_NAME
         L     R2,SUBENTRYLEN
         LA    R3,SUBENTRY_R       "SUBENTRY:" HEADER
         BRAS  R14,REPORT_PARM     GO REPORT THIS PARM
*
         LA    R1,FILTER_NAME
         L     R2,FILTERLEN
         LA    R3,FILTER_R         "FILTER:" HEADER
         BRAS  R14,REPORT_PARM     GO REPORT THIS PARM
         J     READ_INPUT_RETURN
PARM_ERROR DS 0H
         MVC   OUR_RETURN_CODE,=F'4'  PARM ERROR
READ_INPUT_RETURN DS 0H
         L     R14,R14_READ
         BR    R14
*
*
* CALL THE API, CHECK FOR ERRORS
*
CALL_API DS    0H
         ST    R14,R14_CALL_API
*
* SET UP THE PARMS FOR THE QUERY
*
         LA    R1,CSI_NAME
         ST    R1,PCSI
         LA    R1,ZONE_NAME
         ST    R1,PZONE
         LA    R1,ENTRY_NAME
         ST    R1,PENTRY
         LA    R1,SUBENTRY_NAME
         ST    R1,PSUBENTRY
         LA    R1,FILTER_NAME
         ST    R1,PFILTER
         LA    R1,QUERY_PARMS
         ST    R1,PARMADDR
*
         LOAD  EP=GIMAPI                LOAD API
         ST    R0,PGMADDR
*
* GET THE TIME WE STARTED THE CALL
*
         BRAS  R14,GET_TIME
         MVC   GIMPRINT,=CL133' --- GIMAPI TIMINGS: ------------------'
         BRAS  R14,WRITE_GIMPRINT  WRITE A LINE
         MVC   GIMPRINT,=CL133'  GIMAPI CALLED AT:   HHMMSSTH MMDDYYYY'
         MVC   GIMPRINT+22(8),TIME_STRING
         MVC   GIMPRINT+31(8),DATE_STRING
         BRAS  R14,WRITE_GIMPRINT

         L     R15,PGMADDR
         CALL (15),(QUERYCMD,PARMADDR,LISTADDR,APILANG,RC,CC,MSGADDR), X
               MF=(E,PLIST)
*
* GET THE TIME WE RETURNED FROM THE CALL
*
         BRAS  R14,GET_TIME
         MVC   GIMPRINT,=CL133'  GIMAPI RETURNED AT: HHMMSSTH MMDDYYYY'
         MVC   GIMPRINT+22(8),TIME_STRING
         MVC   GIMPRINT+31(8),DATE_STRING
         BRAS  R14,WRITE_GIMPRINT
*
         OI    FLAGS,GIMAPI_LOADED INDICATE CLEANUP REQUIRED
         ICM   R1,B'1111',RC       WHAT WAS RC?
         JZ    CALL_API_RETURN     ZERO, CONTINUE
*
* GIMAPI FOUND AN ERROR, AND PRODUCES NICE FORMATTED MESSAGE(S)
* DESCRIBING IT.  COPY THEM TO GIMPRINT FOR THE USER, THEN SET
* THE RETURN CODE SO WE QUIT.
*
         L     R7,MSGADDR          GET ADDR OF ERROR MESSAGE
         USING ITEM_LIST,R7
         MVC   OUR_RETURN_CODE,=F'8' INDICATE API ERROR
         MVC   GIMPRINT,=CL133' --- ERROR MESSAGES: ------------------'
         BRAS  R14,WRITE_GIMPRINT  WRITE A LINE
FIND_ERROR_MSG DS 0H
         CLEAR GIMPRINT            BLANK THE LINE
         L     R2,DATALEN          LENGTH OF STRING
         CHI   R2,L'GIMPRINT-1        TOO BIG?
         JNH   WRITE_ERROR_MSG     NO
         LA    R2,L'GIMPRINT-1     YES, USE MAX LRECL
WRITE_ERROR_MSG DS 0H
         BCTR  R2,0                DECREMENT LENGTH
         L     R1,DATA             POINT AT MESSAGE TEXT
         LA    R3,GIMPRINT+1       WHERE TO MOVE IT TO
         EX    R2,MOVE_THING       MOVE TO GIMPRINT
         BRAS  R14,WRITE_GIMPRINT  WRITE A LINE
         ICM   R7,B'1111',ITMNEXT  IS THERE MORE?
         JZ    CALL_API_ERROR      NO, QUIT NOW
         J     FIND_ERROR_MSG      YES, CONTINUE
CALL_API_ERROR DS 0H
         MVC   OUR_RETURN_CODE,RC  INDICATE ERROR
CALL_API_RETURN DS 0H
         L     R14,R14_CALL_API
         BR    R14
         DROP  R7
*
*
* PROCESS AND PRINT THE API RESULTS
*
PROCESS_LISTS DS 0H
         USING ENTRY_LIST,R10
         USING CSIENTRY,R9
         USING SUBENTRY,R8
         USING ITEM_LIST,R7
         ST    R14,R14_PROCESS
*
         L     R10,LISTADDR        ADDRESS OF HEAD OF LIST
*
PRINT_TYPE DS 0H
         LTR   R10,R10             ANY MORE TYPES?
         JZ    PROCESS_LISTS_RETURN NO, ALL DONE
         MVC   ENTRY_TYPE_DATA(5),=CL5'TYPE='
         MVC   ENTRY_TYPE_DATA+5(12),TYPE
         MVC   ENTRY_TYPE(2),=AL2(17)  LENGTH
         L     R9,ENTRIES          NEXT EXTRY
         J     PRINT_ENTRIES       GO PRINT
MORE_TYPES DS 0H
         L     R10,NEXT            NEXT TYPE
         J     PRINT_TYPE          GO PRINT IT
*
PRINT_ENTRIES DS 0H
         LTR   R9,R9
         JZ    MORE_TYPES          ALL DONE, SEE IF MORE TYPES
         MVC   OUTBUFFER(L'ENTRY_TYPE),ENTRY_TYPE TELL WHAT IT IS
         BRAS  R14,WRITE_GIMOUT
         MVC   OUTBUFFER_DATA(L'ENTRYNAME),ENTRYNAME
         MVI   OUTBUFFER_DATA+L'ENTRYNAME,C' '
         MVC   OUTBUFFER_DATA+L'ENTRYNAME+1(L'ZONENAME),ZONENAME
         MVC   OUTBUFFER_LEN(2),=AL2(L'ENTRYNAME+L'ZONENAME+1) LENGTH
         BRAS  R14,WRITE_GIMOUT
         L     R8,SUBENTRIES       ADDR OF SUBENTRIES
         J     PRINT_SUBENTRIES
MORE_ENTRIES DS 0H
         L     R9,CSINEXT          NEXT ENTRY
         J     PRINT_ENTRIES       GO PRINT IT
*
PRINT_SUBENTRIES DS 0H
         LTR   R8,R8
         JZ    MORE_ENTRIES        ALL DONE, SEE IF MORE ENTRIES
         L     R7,SUBENTDATA       ADDR OF DATA
         CLC   =CL3'VER',SUBTYPE   IS IT A VER TYPE?
         JE    HANDLE_VER          YES, HANDLE SPECIAL
         MVC   OUTBUFFER_DATA(9),=C'SUBENTRY='
         MVC   OUTBUFFER_DATA+9(L'SUBTYPE),SUBTYPE
         MVC   OUTBUFFER_LEN(2),=AL2(L'SUBTYPE+9) LENGTH
         BRAS  R14,WRITE_GIMOUT
         J     PRINT_SUBDATA       NO, NORMAL
MORE_SUBENTRIES DS 0H
         L     R8,SUBNEXT          NEXT SUBENTRY
         J     PRINT_SUBENTRIES    GO PRINT IT
*
PRINT_SUBDATA DS 0H
         LTR   R7,R7               ANY DATA?
         JZ    MORE_SUBENTRIES     NO
         L     R0,DATA             WHERE TO MOVE FROM
         L     R1,DATALEN          LENGTH
         C     R1,=F'1024'         MAX LENGTH?
         JNH   SUBDATA_LEN_OK      OK
         L     R1,=F'1024'         NO, USE MAX
SUBDATA_LEN_OK DS 0H
         LA    R2,OUTBUFFER_DATA   WHERE TO MOVE TO
         LR    R3,R1               LENGTH
         STH   R3,OUTBUFFER_LEN    SAVE LENGTH
         MVCL  R2,R0               MOVE DATA
         BRAS R14,WRITE_GIMOUT
         L     R7,ITMNEXT          NEXT DATA
         J     PRINT_SUBDATA       AND GO
*
HANDLE_VER DS 0H
         DROP  R8
         DROP  R7
         USING VER,R6
         USING SUBENTRY,R5
         USING ITEM_LIST,R4
         LR    R6,R7              USE R6 FOR VER STUFF
PRINT_VERS DS 0H
         LTR   R6,R6               MORE TO DO?
         JZ    MORE_SUBENTRIES     BACK TO SUBENTRIES IF DONE
         MVC   OUTBUFFER_DATA(4),=C'VER='
         MVC   OUTBUFFER_DATA+4(L'VERNUM),VERNUM  VERSION
         MVC   OUTBUFFER_LEN(2),=AL2(L'VERNUM+4)
         BRAS  R14,WRITE_GIMOUT
         L     R5,VERDATA          LIKE SUBENTRY
         J     PRINT_VERDATA       GO HANDLE IT
MORE_VERS DS 0H
         L     R6,VERNEXT          NEXT VER
         J     PRINT_VERS          AND CONTINUE
*
PRINT_VERDATA DS 0H
         LTR   R5,R5               ANYTHING?
         JZ    MORE_VERS           NO, BACK TO VERS
         MVC   OUTBUFFER_DATA(9),=CL9'VERTHING='
         MVC   OUTBUFFER_DATA+9(L'SUBTYPE),SUBTYPE
         MVC   OUTBUFFER_LEN(2),=AL2(L'SUBTYPE+9)
         BRAS  R14,WRITE_GIMOUT
         L     R4,SUBENTDATA       ADDR OF DATA
         J     PRINT_VERLIST
MORE_VERDATA DS 0H
         L     R5,SUBNEXT
         J     PRINT_VERDATA
*
PRINT_VERLIST DS 0H
         LTR   R4,R4               ANYTHING?
         JZ    MORE_VERDATA        NO
         L     R0,DATA             WHERE TO MOVE FROM
         L     R1,DATALEN          LENGTH
         C     R1,=F'1024'         MAX LENGTH?
         JNH   VERDATA_LEN_OK      OK
         L     R1,=F'1024'         NO, USE MAX
VERDATA_LEN_OK DS 0H
         LA    R2,OUTBUFFER_DATA   WHERE TO MOVE TO
         LR    R3,R1               LENGTH
         STH   R3,OUTBUFFER_LEN    SAVE LENGTH
         MVCL  R2,R0               MOVE DATA
         BRAS  R14,WRITE_GIMOUT
         L     R4,ITMNEXT          NEXT DATA
         J     PRINT_VERLIST       AND GO
         DROP  R6
         DROP  R5
         DROP  R4
PROCESS_LISTS_RETURN DS 0H
         L     R14,R14_PROCESS
         BR    R14
*
*
* CLOSE FILES, FREE GIMAPI STORAGE, DELETE GIMAPI
*
CLEAN_UP DS    0H
         ST    R14,R14_CLEANUP
         LA    R11,INDCB           ADDRESS GIMIN DCB
         TM    DCBOFLGS,DCBOFOPN   IS IT STILL OPEN?
         JNO   CHECK_CLOSE_2       NO, CONTINUE
         CLOSE ((R11)),MF=(E,CLOSE) CLOSE GIMIN
CHECK_CLOSE_2 DS 0H
         LA    R11,OUTDCB          ADDRESS GIMOUT DCB
         TM    DCBOFLGS,DCBOFOPN   IS IT STILL OPEN?
         JNO   CHECK_CLOSE_3       NO, CONTINUE
         CLOSE ((R11)),MF=(E,CLOSE) CLOSE GIMOUT
CHECK_CLOSE_3 DS 0H
         LA    R11,RPTDCB          ADDRESS GIMPRINT DCB
         TM    DCBOFLGS,DCBOFOPN   IS IT STILL OPEN?
         JNO   CHECK_CLOSE_4       NO, CONTINUE
         CLOSE ((R11)),MF=(E,CLOSE) CLOSE GIMPRINT
CHECK_CLOSE_4 DS 0H
         TM    FLAGS,GIMAPI_LOADED DO WE NEED TO FREE AND DELETE?
         JZ    CLEAN_UP_RETURN     NO
         L     R15,PGMADDR
         CALL (15),(FREECMD,0,LISTADDR,APILANG,RC,CC,MSGADDR),         X
               MF=(E,PLIST)
         DELETE EP=GIMAPI
         NI    FLAGS,255-GIMAPI_LOADED
CLEAN_UP_RETURN DS 0H
         L     R14,R14_CLEANUP
         BR    R14
*
*
* EXTRACT NON-BLANK TEXT FROM GIMIN RECORD
*
* ON ENTRY, R1 POINTS TO THE TEXT
* ON RETURN, R1 POINTS TO THE TEXT, R2 HAS THE LENGTH
*
* USES OUTBUFFER FOR CONTINUATION CARDS
*
EXTRACT_TEXT DS 0H
         ST    R14,R14_EXTRACT
         XC    OUTBUFFER_LEN(2),OUTBUFFER_LEN
PROCESS_CARD DS 0H
         LA    R2,INBUFFER+70     END OF INPUT
FIND_1ST_CHAR DS 0H
         CLI   0(R1),C' '         ANYTHING HERE?
         JNE   FIND_LAST_CHAR     YES, GO
         LA    R1,1(R1)           NEXT COLUMN
         CR    R1,R2              TOO FAR?
         JNL   NO_INPUT           YES
         J     FIND_1ST_CHAR      NO, NOT YET
FIND_LAST_CHAR DS 0H
* START OF TEXT IS POINTED TO BY R1
         CLI   0(R2),C' '         ANYTHING HERE?
         JNE   COMPUTE_LENGTH     YES, FOUND END
         BCTR  R2,0               BACK UP ONE CHAR
         CR    R1,R2              TOO FAR?
*        JNL   NO_INPUT           JNL DIDN'T ALLOW FOR 1 CHAR CARD RLH1
         JH    NO_INPUT           YES
         J     FIND_LAST_CHAR     NO, KEEP LOOKING
COMPUTE_LENGTH DS 0H
* WE HAVE START AND END, COMPUTE THE LENGTH
         SR    R2,R1
         LA    R2,1(R2)           ADJUST
         J     END_OF_INPUT       AND SEE IF WE'RE DONE
NO_INPUT DS    0H
* NOTHING FOUND, USE '*'
         LA    R1,ASTER            POINT AT ASTERISK
         LA    R2,1                LENGTH OF 1
         J     EXTRACT_FINISH
END_OF_INPUT DS 0H
         CLI   INBUFFER+71,C' '    ANY CONTINUATION?
         JE    EXTRACT_FINISH      NOPE, WE'RE DONE
         LA    R3,OUTBUFFER_DATA   ADDRESS OF BUFFER
         LH    R14,OUTBUFFER_LEN   LENGTH OF WHAT'S THERE
         AR    R3,R14              WHERE NEW STUFF GOES
         AR    R14,R2              NEW TOTAL LENGTH
         CHI   R14,L'OUTBUFFER_DATA       TOO BIG?
         JNL   EXTRACT_RETURN      YES, GET OUT NOW
         BCTR  R2,0                DECREMENT R2
         EX    R2,MOVE_THING       ADD NEW STUFF TO BUFFER
         STH   R14,OUTBUFFER_LEN   SAVE NEW LENGTH
*
         GET   INDCB,INBUFFER      READ CONTINUATION
         MVC   GIMPRINT+1(80),INBUFFER   ECHO
         BRAS  R14,WRITE_GIMPRINT  IT TO GIMPRINT
         LA    R1,INBUFFER         POINT AT BEGINNING
         J     PROCESS_CARD        GO HANDLE IT
EXTRACT_FINISH DS 0H
         CLC   OUTBUFFER_LEN(2),=AL2(0) STUFF STORED IN BUFFER?
         JE    EXTRACT_RETURN      NOPE, ALL DONE
         LA    R3,OUTBUFFER_DATA   ADDRESS OF BUFFER
         LH    R14,OUTBUFFER_LEN   LENGTH OF WHAT'S THERE
         AR    R3,R14              WHERE NEW STUFF GOES
         AR    R14,R2              NEW TOTAL LENGTH
         CHI   R14,L'OUTBUFFER_DATA       TOO BIG?
         JNL   EXTRACT_RETURN      YES, GET OUT NOW
         BCTR  R2,0                DECREMENT R2
         EX    R2,MOVE_THING       ADD NEW STUFF TO BUFFER
         STH   R14,OUTBUFFER_LEN   SAVE NEW LENGTH
         LR    R2,R14              NEW TOTAL LENGTH
         LA    R1,OUTBUFFER_DATA   START OF STRING
EXTRACT_RETURN DS 0H
         L     R14,R14_EXTRACT
         BR    R14                 RETURN TO CALLER
*
*
* REPORT ON A PARM
*
* ON ENTRY, R1 POINTS TO PARM TEXT
*           R2 HAS LENGTH
*           R3 POINTS TO PARM TYPE TEXT
*
REPORT_PARM DS 0H
         ST    R14,R14_REPORT
         MVC   GIMPRINT,=CL133' '
         MVC   GIMPRINT_D(L'CSI_R),0(R3) "HEADER"
         LA    R3,GIMPRINT_D+L'CSI_R WHERE TO PUT STUFF
         LA    R5,L'GIMPRINT_D-L'CSI_R HOW BIG IT CAN BE
FILL_IN_LINE DS 0H
         LTR   R4,R2               ANYTHING TO PRINT?
         JNP   REPORT_WRITE_IT     NO, ALL DONE
         CR    R4,R5               TOO BIG FOR THIS LINE?
         JNH   REPORT_FILL_IN      NO
         LR    R4,R5               YES, USE WHAT WE CAN
REPORT_FILL_IN DS 0H
         BCTR  R4,0                REDUCE FOR EXECUTE
         EX    R4,MOVE_THING       MOVE WHAT FITS
REPORT_WRITE_IT DS 0H
         LR    R5,R1               SAVE R1 ACROSS PRINT
         BRAS  R14,WRITE_GIMPRINT  WRITE IT OUT
         LA    R4,1(R4)            RESTORE LENGTH
         SR    R2,R4               ANYTHING LEFT TO REPORT?
         JNP   REPORT_PARM_RETURN  NO, ALL DONE
         LA    R1,0(R5,R4)         NEXT UNREPORTED CHAR (FROM SAVED R1)
         MVC   GIMPRINT,=CL133' '  BLANK THE OUTPUT LINE
         LA    R3,GIMPRINT_D       WHERE TO MOVE TO
         LA    R5,L'GIMPRINT_D     HOW MUCH IT CAN HOLD
         J     FILL_IN_LINE        KEEP GOING
REPORT_PARM_RETURN DS 0H
         L     R14,R14_REPORT
         BR    R14
*
*
*
* WRITE A LINE OF GIMPRINT
*
WRITE_GIMPRINT DS 0H
         ST    R14,R14_GIMPRINT
         PUT   RPTDCB,GIMPRINT     WRITE THE LINE
         L     R14,R14_GIMPRINT
         BR    R14
*
*
* WRITE A LINE OF GIMOUT
*
WRITE_GIMOUT DS 0H
         ST    R14,R14_GIMOUT
         LH    R14,OUTBUFFER_LEN   GET LENGTH OF DATA
         LA    R14,4(R14)          ACCOUNT FOR LENGTH OF RDW
         STH   R14,OUTBUFFER_LEN   SAVE IT BACK
         PUT   OUTDCB,OUTBUFFER    WRITE THE LINE
         L     R14,R14_GIMOUT
         BR    R14
*
*
* GET THE TIME AND FORMAT IT
*
GET_TIME DS 0H
         ST    R14,R14_TIME
         XC    TIME_DATE(16),TIME_DATE         CLEAR
         TIME  DEC,TIME_DATE,DATETYPE=MMDDYYYY,LINKAGE=SYSTEM,         X
               MF=(E,TIME)
         UNPK  TIME_STRING(9),TIME_PACKED(5) UNPACK TIME
         UNPK  DATE_STRING(9),DATE_PACKED(5) UNPACK DATE
         L     R14,R14_TIME
         BR    R14
*
*
*
MOVE_THING MVC 0(0,R3),0(R1)       EXECUTED
*
QUERYCMD DC     CL8'QUERY   '
FREECMD  DC     CL8'FREE    '
APILANG  DC     CL8'ENU'
CSI_K    DC     C'CSI '
ZONE_K   DC     C'ZONE '
ENTRY_K  DC     C'ENTRY '
SUBENTRY_K DC   C'SUBENTRY '
FILTER_K DC     C'FILTER '
CSI_R    DC     C'CSI:      '
ZONE_R   DC     C'ZONE:     '
ENTRY_R  DC     C'ENTRY:    '
SUBENTRY_R DC   C'SUBENTRY: '
FILTER_R DC     C'FILTER:   '
ASTER    DC     C'*'
*
KINDCB   DCB   DDNAME=GIMIN,DSORG=PS,MACRF=GM,EODAD=EODAD,LRECL=80
@KINDCB  EQU   *-KINDCB
*
KOUTDCB  DCB   DDNAME=GIMOUT,DSORG=PS,MACRF=PM,RECFM=VB,LRECL=1028
@KOUTDCB EQU   *-KOUTDCB
*
KRPTDCB  DCB   DDNAME=GIMPRINT,DSORG=PS,MACRF=PM,RECFM=FBA,LRECL=133
@KRPTDCB EQU   *-KRPTDCB
*
KOPEN    OPEN  KINDCB,MF=L
@KOPEN   EQU   *-KOPEN
KCLOSE   OPEN  KOUTDCB,MF=L
@KCLOSE  EQU   *-KCLOSE
KTIME    TIME  LINKAGE=SYSTEM,MF=L
@KTIME   EQU   *-KTIME
*
         LTORG
*
WORKAREA DSECT
RSA           DS 18F               REGISTER SAVE AREA
TIME_DATE     DS 0D
TIME_PACKED   DS D
DATE_PACKED   DS D
PLIST         DS 8F                PARMS FOR GIMAPI
PGMADDR       DS F                 GIMAPI ADDRESS
PARMADDR      DS F                 ADDRESS OF QUERY_PARMS
LISTADDR      DS F                 ADDRESS OF RESULTS LIST
RC            DS F                 API RETURN CODE
CC            DS F                 API CONDITION CODE
MSGADDR       DS F                 API ERROR MESSAGE ADDRESS
OUR_RETURN_CODE DS F
R14_INITIALIZE  DS F               R14 SAVE AREA
R14_OPEN        DS F               R14 SAVE AREA
R14_READ        DS F               R14 SAVE AREA
R14_EXTRACT     DS F               R14 SAVE AREA
R14_CALL_API    DS F               R14 SAVE AREA
R14_GIMPRINT    DS F               R14 SAVE AREA
R14_GIMOUT      DS F               R14 SAVE AREA
R14_PROCESS     DS F               R14 SAVE AREA
R14_CLEANUP     DS F               R14 SAVE AREA
R14_TIME        DS F               R14 SAVE AREA
R14_REPORT      DS F               R14 SAVE AREA
CSI_NAME      DS CL44              CSI NAME
ZONE_NAME     DS CL255             ZONE NAME(S)
ENTRY_NAME    DS CL255             TYPE OF ENTRY (MOD, LMOD, SRC, ...)
SUBENTRY_NAME DS CL255             TYPE OF SUBENTRY (SYSLIB, ETC.)
FILTER_NAME   DS CL768             FILTERING
TIME_STRING   DS 8C                UNPACKED TIME
TIME_FILLER   DS C                 (FILLER FOR UNPACK)
DATE_STRING   DS 8C                UNPACKED DATE
DATE_FILLER   DS C                 (FILLER FOR UNPACK)
              DS 0F
ENTRY_TYPE    DS 0CL21             ENTRY TYPE STRING
              DS F                 RDW
ENTRY_TYPE_DATA DS CL17            DESCRIPTION
*
FLAGS    DS   X                    PROGRAM FLAGS
GIMAPI_LOADED EQU X'80'            ...GIMAPI LOADED
*
INDCB    DS    (@KINDCB)XL1        INPUT DCB
OUTDCB   DS    (@KOUTDCB)XL1       OUTPUT DCB
RPTDCB   DS    (@KRPTDCB)XL1       REPORT DCB
OPEN     DS    (@KOPEN)XL1         OPEN PARMLIST
CLOSE    DS    (@KCLOSE)XL1        CLOSE PARMLIST
TIME     DS    (@KTIME)XL1         TIME PARMLIST
*
GIMPRINT DS  0CL133                GIMPRINT BUFFER
GIMPRINT_CC DS C                   CARRIAGE CONTROL
GIMPRINT_D  DS CL132               GIMPRINT DATA
         DS  0F                    ALIGNMENT
INBUFFER DS  CL80                  GIMIN BUFFER
         DS  0F                    ALIGNMENT
OUTBUFFER DS 0CL1028               GIMOUT BUFFER
OUTBUFFER_LEN DS F                 VB RDW
OUTBUFFER_DATA DS CL1024           OUTPUT DATA
*
* THE GIMMASM MACRO IS KIND OF WIERD -- IT HAS NON-DSECT PARMS
* AT THE BEGINNING WHICH WE WANT INCLUDED IN OUR WORK AREA, THEN
* A SERIES OF DSECTS.  SO WE PUT IT AT THE END OF OUR WORK AREA,
* AND SET THE WORK AREA LENGTH SO IT INCLUDES THE NON-DSECT PARTS.
*
         GIMMASM                   SMPE API AREAS
*
WORKAREA_LEN EQU FILTERLEN+L'FILTERLEN-WORKAREA
*
         DCBD  DSORG=PS,DEVD=DA    DCB DSECT
*
         END
./ ADD NAME=APPSINCE 0102-03192-03192-0834-00812-00812-00000-TRLH
//TRLHINCE JOB (TRLH,6C,),
//            'Rich Hobt',
//            MSGCLASS=T,
//            NOTIFY=&SYSUID,
//            CLASS=T
//DEFAULT  OUTPUT CLASS=*,JESDS=ALL,DEFAULT=YES,
//     NAME=('Rich Hobt'),
//     ROOM=('6C'),
// BUILDING=('Western'),
//     DEPT=('SYSW'),
//  ADDRESS=('3101 Western Ave.',
//           'Seattle, WA.  98121',
//           'U.S.A.',
//           'Planet Earth')
//*
//*  This JCL is from: TRLH.AFCSMP1.SRC(APPSINCE)
//*
//*---------------------------------------------------------------------
//*
//* JOB TO BUILD AN IEBCOPY JOB TO IMPLEMENT SMPE MAINTENANCE
//* APPLIED BETWEEN SPECIFIED DATES.  ONLY THE AFFECTED ELEMENTS
//* ARE SELECTED.
//*
//* SPECIFY THE ZONE AND DATE(S) VIA THE APSELECT MACRO
//*
//*---------------------------------------------------------------------
//SAS      EXEC SAS,
// WORK='25000,5000',
// REGION.SAS=64M
//MACROS   DD   DISP=SHR,DSN=TRLH.AFCSMP1.SRC
//OUTDSNS  DD   DISP=SHR,DSN=TRLH.AFCSMP1.SRC(#DDDEFS)
//GIMIN    DD   DISP=(NEW,PASS),DSN=&&SYSIN,
//  UNIT=VIO,SPACE=(TRK,(5,5)),
//  RECFM=FB,LRECL=80,BLKSIZE=0
//GIMOUT   DD   DISP=(NEW,PASS),DSN=&&SYSOUT,
//  UNIT=SYSDA,SPACE=(TRK,(90,90)),
//  RECFM=VB,LRECL=1028,BLKSIZE=0
//GIMPRINT DD   SYSOUT=*
//APSYSMOD DD   SYSOUT=*
//APPSTUFF DD   SYSOUT=*
//RPTLMOD  DD   SYSOUT=*
//RPTOTHR  DD   SYSOUT=*
//ORPHANS  DD   SYSOUT=*
//TRACE    DD   SYSOUT=*
//INSTALL  DD   SYSOUT=*
//SYSIN    DD  *
  OPTIONS LS=80 NOCENTER SYMBOLGEN MACROGEN NODATE S=80;
  %INCLUDE MACROS(APSELECT);

  /* Specify:                                                              */
  /*   CSI      (default: SYSS.GLOBAL.CSI)                                 */
  /*   ZONE     (DEFAULT: TARGZ14)                                         */
  /*   FROMDATE (default: none)  can be either DDJJJ or MM/DD/YY           */
  /*   TODATE   (default: today) can be either DDJJJ or MM/DD/YY           */
  /*                                                                       */
  /* ... via the APSELECT macro.                                           */

 %APSELECT(CSI=SYSS.CA.GLOBAL.CSI,ZONE=CAITGT,FROMDATE=06/02/03);

  /* Build the control cards for the initial SMPE query                    */
  /* (sysmods applied since a given date) and invoke the                   */
  /* SMPE API.                                                             */

  data _NULL_;
    file gimin noprint old ;
    format filter $char80.;
    put "CSI &vcsi                                         ";
    put "ZONE &vzone                                       ";
    put "ENTRY SYSMOD                                      ";
    PUT "SUBENTRY ELEMENT,ASSEM,INSTALLDATE,INSTALLTIME,FMID     ";
    FILTER = "FILTER DELBY=''&LASTSUP=''&INSTALLDATE>='&VFRMDATE'";
    lenf = length(filter);
    filter = trim(filter) || repeat(" ",70-lenf) || "*";
    put filter;
    filter = "&INSTALLDATE<='&vtodate'";
    put filter;
    stop;

  proc AFCSMP1;

  /* Read the initial query results and build the sysmods dataset,         */
  /* containing sysmod names and elements.  Print a report showing         */
  /* the sysmods and apply dates and times.                                */

  data sysmods;
    keep sysmod
         element
         type
         fmid
      ;
    retain sysmod "       "
           type   "            "
           fmid   "       "
      ;
    infile gimout length=len;
    input @1 aline $varying200. len;
    if aline =: "TYPE=SYSMOD" then do;
       input @1 sysmod $char7.;
       return;
    end;
    if aline =: "SUBENTRY=FMID" then do;
       input @1 fmid $char7.;
       return;
    end;
    if scan(aline,1,'=') = "SUBENTRY" then do;
       type = scan(aline,2,'=');
       IF TYPE = "ASSEM" THEN TYPE = "MOD";
       input @1 element $varying200. len;
       output;
       return;
    end;
    element = aline;
    output;
    return;

 data apsysmod;
   set sysmods;
   label idate = "Install Date"
         itime = "Install Time"
     ;
   format idate worddate.
          itime time8.
     ;
   retain idate
     ;
   if type = "INSTALLDATE" then idate = input(element,julian5.);
   if type = "INSTALLTIME" then do;
      itime = input(element,time8.);
      output;
   end;

 proc sort data=apsysmod; by idate itime sysmod;

 proc printto print=apsysmod;

 proc print data=apsysmod uniform noobs label;
 id sysmod;
 var fmid idate itime;
 title "Sysmods applied in zone &vzone between &wfrmdate and &wtodate";

  /* Build the control cards to extract all the MOD/LMOD relationships.    */
  /* If there are too many mods for a FILTER statement (max len=768)       */
  /* then ignore filtering and grab everything.  Otherwise, build a filter */
  /* statement to cut down on execution time.                              */

  data modlist;
    set sysmods;
    keep mod
      ;
    if type =: "MOD";
    mod = element;

  proc sort data=modlist nodupkey; by mod;

  data _NULL_;
    set modlist nobs=nobs end=eof;
    file gimin noprint old;
    format filter $char100.;
    retain filter
      ;
    if _N_ = 1 then do;
       put "CSI &vcsi                                         ";
       put "ZONE &vzone                                       ";
       put "ENTRY MOD                                         ";
       put "SUBENTRY ENAME,LMOD,TALIAS                        ";
       filter = "FILTER ENAME='";
    end;

    if nobs > 45 then stop;

    if _N_ = 1 then filter = trim(filter) || mod;
               else filter = trim(filter) || "|ENAME='" || mod;
    filter = trim(filter) || "'";
    if length(filter) > 71 then do;
       line = substr(filter,1,71) || "*";
       put line;
       filter = trim(substr(filter,72));
    end;
    if eof then do;
       if length(filter) > 71 then do;
          line = substr(filter,1,71) || "*";
          put line;
          filter = trim(substr(filter,72));
       end;
       put filter;
     end;

  proc AFCSMP1;

  data allmods (keep=mod lmod)
       malias0 (keep=mod talias)
      ;
    retain mod
           subentry "        "
      ;
    infile gimout length=len;
    input @1 aline $varying200. len;
    if aline =: "TYPE=MOD" then do;
       input @1 aline $varying200. len;
       mod = scan(aline,1," ");
       return;
    end;
    if aline =: "SUBENTRY=LMOD" then do;
       input @1 lmod $varying200. len;
       subentry = "LMOD";
       output allmods;
       return;
    end;
    if aline =: "SUBENTRY=TALIAS" then do;
       input @1 talias $varying200. len;
       subentry = "TALIAS";
       output malias0;
       return;
    end;
    if subentry = "LMOD" then do;
       lmod = aline;
       output allmods;
       return;
    end;
    if subentry = "TALIAS" then do;
       talias = aline;
       output malias0;
       return;
    end;

 proc sort data=allmods; by mod;
 proc sort data=malias0; by mod talias;

  /* combine malias0 and allmods to assign t-alii to lmods */

 data malias(keep = lmod talias);
   merge allmods
         malias0 (in=haslias)
     ;
     by mod;
     if haslias;

 proc sort data=malias; by lmod talias;

  /* Separate the changed mods from other entries, and put them in         */
  /* their own datasets.                                                   */

 data appmods(keep=mod)
      appother(keep=element type)
   ;
   set sysmods;
   if type =: "MOD" then do;
      mod = element;
      output appmods;
   end;
   else do;
      IF TYPE =: "INSTALL" THEN RETURN;
      output appother;
   end;

 proc sort data=appmods; by mod;

 /* Merge the applied mods with the allmods dataset to get a               */
 /* list of changed lmods.                                                 */

 data applmods;
   keep lmod
        type
    ;
   retain type "LMOD";
   merge appmods(in=applied)
         allmods(in=haslmod)
     ;
   by mod;
   if applied and haslmod;

 /* Sort the applied lmods (APPLMODS) and other stuff (APPOTHER) to get    */
 /* rid of duplicates.                                                     */

 proc sort data=applmods nodupkey; by lmod;
 proc sort data=appother nodupkey; by type element;

 proc printto print=appstuff;
 proc print data=applmods uniform noobs;
 id type;
 var lmod;
 title "Lmods applied in zone &vzone between &wfrmdate and &wtodate";

 proc print data=appother uniform noobs;
 id type;
 var element;
 title "Other items applied in zone &vzone between &wfrmdate and &wtodate";

  /* Build the control cards to extract all the lmod/syslib relationships. */
  /* If there are too many lmods for a filter statement (max len=768)      */
  /* then ignore filtering and grab everything.  Otherwise, build a filter */
  /* statement to cut down on execution time.                              */

  data _NULL_;
    set applmods nobs=nobs end=eof;
    file gimin noprint old;
    format filter $char100.;
    retain filter
      ;
    if _N_ = 1 then do;
       put "CSI &vcsi                                         ";
       put "ZONE &vzone                                       ";
       put "ENTRY LMOD                                        ";
       PUT "SUBENTRY ENAME,SYSLIB,LMODALIAS                   ";
       filter = "FILTER ENAME='";
    end;

    if nobs > 45 then stop;

    if _N_ = 1 then filter = trim(filter) || lmod;
               else filter = trim(filter) || "|ENAME='" || lmod;
    filter = trim(filter) || "'";
    if length(filter) > 71 then do;
       line = substr(filter,1,71) || "*";
       put line;
       filter = trim(substr(filter,72));
    end;
    if eof then do;
       if length(filter) > 71 then do;
          line = substr(filter,1,71) || "*";
          put line;
          filter = trim(substr(filter,72));
       end;
       put filter;
     end;

  proc AFCSMP1;

  data lsyslib0 (keep=lmod syslib type)
       lalias (keep=lmod lmodalias)
    ;
    RETAIN LMOD "        "
           TYPE "LMOD"
           subentry "        "
      ;
    infile gimout length=len;
    input @1 aline $varying200. len;
    if aline =: "TYPE=LMOD" then do;
       input @1 aline $varying200. len;
       lmod = scan(aline,1," ");
       subentry = '        ';
       return;
    end;
    if aline =: "SUBENTRY=SYSLIB" then do;
       input @1 syslib $varying200. len;
       output lsyslib0;
       subentry = "SYSLIB";
       return;
    end;
    if aline =: "SUBENTRY=LMODALIAS" then do;
       input @1 lmodalias $varying200. len;
       output lalias;
       subentry = "LALIAS";
       return;
    end;
    if subentry = "SYSLIB" then do;
       syslib = aline; /* more than one syslib */
       output lsyslib0;
    end;
    if subentry = "LALIAS" then do;
       lmodalias = aline; /* more than one alias  */
       output lalias;
    end;

  proc sort data=lsyslib0 nodupkey; by lmod syslib;
  proc sort data=lalias   nodupkey; by lmod lmodalias;

  data lsyslib1
       orphanl
    ;
    merge applmods(in=applied)
          lsyslib0(in=haslib)
      ;
      by lmod;
    if applied and haslib then output lsyslib1;
    if applied and not haslib then output orphanl;

  /*
  ** Merge the applied lmods with their aliases
  */
  data lsyslib(keep=lmod syslib type main)
    ;
    merge lsyslib1(in=insyslib)
          malias(in=inalias1)
          lalias(in=inalias2)
      ;
      by lmod;
      main = "        ";
      if insyslib then output;      /* output main entry */
      if insyslib & (inalias1 | inalias2) then do;
         main = lmod;
         if inalias1 then lmod = talias;
         else if inalias2 then lmod = lmodalias;
         output;   /* output an alias entry */
      end;

  proc printto print=rptlmod;
  proc print uniform noobs data=lsyslib;
  id lmod;
  var syslib main;
  title "Applied lmods and their syslibs";

  proc printto print=orphans;
  proc print uniform noobs data=orphanl;
  id lmod;
  title "Applied lmods without any defined syslibs";


  /*                                                                       */
  /* Build the control cards to extract all the element/syslib             */
  /* relationships.  If there are too many elements for a filter           */
  /* statement (max len=768) then ignore filtering and grab everything.    */
  /* Otherwise, build a filter statement to cut down on execution time.    */

  proc sort data=appother nodupkey; by element type;

  data _NULL_;
    set appother nobs=nobs end=eof;
    file gimin noprint old;
    format filter $char100.;
    retain filter
      ;
    if _N_ = 1 then do;
       put "CSI &vcsi                                         ";
       put "ZONE &vzone                                       ";
       put "ENTRY ELEMENT                                     ";
       put "SUBENTRY ENAME,SYSLIB,ALIAS,MALIAS                ";
       filter = "FILTER ENAME='";
    end;

    if nobs > 45 then stop;

    if _N_ = 1 then filter = trim(filter) || element;
               else filter = trim(filter) || "|ENAME='" || element;
    filter = trim(filter) || "'";
    if length(filter) > 71 then do;
       line = substr(filter,1,71) || "*";
       put line;
       filter = trim(substr(filter,72));
    end;
    if eof then do;
       if length(filter) > 71 then do;
          line = substr(filter,1,71) || "*";
          put line;
          filter = trim(substr(filter,72));
       end;
       put filter;
    end;

  proc AFCSMP1;

  data esyslib0(keep=element syslib type)
       ealias(keep=element alias)
      ;
    retain element
           type
           subentry "        "
      ;
    infile gimout length=len;
    input @1 aline $varying200. len;
    if aline =: "TYPE=" then do;
       type = scan(aline,2,"=");
       input @1 aline $varying200. len;
       element = scan(aline,1," ");
       subentry = '        ';
       return;
    end;
    if aline =: "SUBENTRY=MALIAS" then do;
       input @1 alias $varying200. len;
       output ealias;
       subentry = "MALIAS";
       return;
    end;
    if aline =: "SUBENTRY=SYSLIB" then do;
       input @1 syslib $varying200. len;
       output esyslib0;
       subentry = "SYSLIB";
       return;
    end;
    if subentry = "SYSLIB" then do;
       syslib = aline; /* more than one syslib */
       output esyslib0;
    end;
    if subentry = "MALIAS" then do;
       alias = aline; /* more than one malias  */
       output ealias;
    end;

  proc sort data=esyslib0 nodupkey; by element type;
  proc sort data=ealias nodupkey; by element alias;

  data esyslib1
       orphane
    ;
    merge appother(in=applied)
          ESYSLIB0(IN=HASLIB)
      ;
      by element;
    if applied and haslib then output esyslib1;
    if applied and not haslib then output orphane;

  /*
  ** Merge the applied elements with their aliases
  */
  data esyslib(keep=element syslib type main)
    ;
    merge esyslib1(in=insyslib)
          ealias(in=inalias)
      ;
      by element;
      main = "        ";
      if insyslib then output;      /* output main entry */
      if insyslib & inalias then do;
         main = element;
         element = alias;
         output;   /* output an alias entry */
      end;

  proc printto print=rptothr;
  proc print uniform noobs data=esyslib;
  id element;
  var type syslib main;
  title "Applied elements and their syslibs";

  proc printto print=orphans;
  proc print uniform noobs data=orphane;
  id element;
  var type;
  title "Applied elements without any defined syslibs";

  /*                                                                       */
  /* Now that we've got all the applied elements and their syslibs, we     */
  /* need to associate the syslibs with datasets.                          */

  data _NULL_;
    file gimin noprint old;
    format filter $char80.;
    put "CSI &vcsi                                         ";
    put "ZONE &vzone                                       ";
    put "ENTRY DDDEF                                       ";
    put "SUBENTRY ENAME,DATASET,PATH,VOLUME                ";
    stop;

  proc AFCSMP1;

  /* Read the DDDEF query results and build the initial DDDEFS dataset    */

  data dddefs0;
    keep syslib
         dataset
         volume
         path
      ;
    retain syslib "        "
           dataset "                                        "
           volume "      "
           path
      ;
    infile gimout length=len eof=eof;
    input @1 aline $varying200. len;
    if aline =: "TYPE=DDDEF" then do;
       if syslib ne "        " then do;
          output;
          path = repeat(' ',255);
          dataset = repeat(' ',44);
          volume = "      ";
       end;
       input @1 aline $varying200. len;
       syslib = scan(aline,1," ");
       return;
    end;
    if scan(aline,1,'=') = "SUBENTRY" then do;
       type = scan(aline,2,'=');
       input @1 aline $varying200. len;
       if type =: "DATASET" then dataset = aline;
       if type =: "VOLUME" then volume = aline;
       if type =: "PATH" then do;
          path = aline;
          dataset = " ";
          volume = "      ";
       end;
       return;
    end;
    return;
  eof:
    output;
    stop;

  proc sort data=dddefs0; by syslib;

  proc sort data=lsyslib; by syslib;

  /*                                                                    */
  /* Now, combine the lmods and dddefs (lsyslib and dddefs0) to         */
  /* add dataset info to the lmods.                                     */

  data lsyslib2;
    merge lsyslib(in=keeper)
          dddefs0
      ;
      by syslib;
    if keeper;

  proc sort data=esyslib; by syslib;

  /* Now, combine the elements and dddefs (esyslib and dddefs0) to      */
  /* add dataset info to the non-lmod elements.                         */

  data esyslib2;
    merge esyslib(in=keeper)
          dddefs0
      ;
      by syslib;
    if keeper;

  /* Separate the things needing to be iebcopied someplace from the     */
  /* things handled by sync jobs.                                       */

data lmodsync
     lmodcopy
  ;
  drop lmod
       path
  ;
  set lsyslib2;
  element = lmod;
  if volume =: "SY" or path ne "" then output lmodsync;
                                  else output lmodcopy;

proc sort data=lmodcopy nodupkey ; by syslib element;
proc sort data=lmodcopy; by syslib main element;

data elemsync
     elemcopy
  ;
  drop path;
  set esyslib2;
  if volume =: "SY" or path ne "" then output elemsync;
                                  else output elemcopy;

proc sort data=elemcopy nodupkey ; by syslib element;
proc sort data=elemcopy; by syslib main element;


data outdsns;                       /* read the dddef-prod dataset file */
  infile outdsns;
  keep syslib outdd outdsn;
  input @1 aline $char80. ;
  if substr(aline,1,1) = "*" then return;
  syslib = scan(aline,1," ");
  outdd  = scan(aline,2," ");
  outdsn = scan(aline,3," ");
  output;

proc sort data=outdsns; by syslib;

proc printto print=TRACE;

proc print uniform noobs data=lmodsync;
title "LMODs handled by SYSRES SYNC";

proc print uniform noobs data=lmodcopy;
title "LMODs needing to be copied";

proc print uniform noobs data=elemsync;
title "Elements handled by SYSRES SYNC";

proc print uniform noobs data=elemcopy;
title "Elements needing to be copied";

proc print uniform noobs data=outdsns;
title "Output dataset names";

 /*
 ** Add output dataset DDNAMEs and datasets to LMODs for IEBCOPY.
 */

data lmodout;
  merge lmodcopy(in=keeper)
        outdsns
    ;
  by syslib;
  if keeper;

 /* Add output dataset DDNAMEs and datasets to other elements */

data elemout;
  merge elemcopy(in=keeper)
        outdsns
    ;
  by syslib;
  if keeper;

 /*
 ** Generate JCL header.  Do this in a separate step in case there are no
 ** non-LMOD elements.
 */

 data _NULL_;   /* first, the base JCL and input libraries */
   file install noprint;
   put "//INSTALL  JOB";
   put "//*";
   put "//* JCL GENERATED BY APPSINCE ON &SYSDATE &SYSTIME";
   PUT "//* ZONE &VZONE FOR SYSMODS APPLIED BETWEEN &WFRMDATE (&VFRMDATE)";
   PUT "//*                                 AND     &WTODATE (&VTODATE)";
   put "//*";

 /* Generate JCL for non-LMOD elements */

 data _NULL_;   /* first, the base JCL and input libraries */
   file install mod noprint;
   retain x -1;
   set elemout;
     by syslib;
   if _N_ = 1 then do;
      put "//ELEMENTS EXEC PGM=IEBCOPY,REGION=8M";
      put "//SYSPRINT DD   SYSOUT=*";
      put "//SYSUT3   DD   UNIT=SYSDA,SPACE=(TRK,(10,10))";
      put "//SYSUT4   DD   UNIT=SYSDA,SPACE=(TRK,(10,10))";
      put "//*";
      put "//* GENERATED DD STATEMENTS FOR NON-LMOD INPUT LIBRARIES";
      put "//*";
   end;
   if first.syslib then do;
      put "//" syslib @11 " DD   DISP=SHR,DSN=" dataset;
   end;

 proc sort data=elemout nodupkey out=elemodd; by outdd;

 data _NULL_;   /* Next, output libraries */
   file install mod noprint;
   retain x -1;
   set elemodd;
     by outdd;
   if _N_ = 1 then do;
      put "//*";
      put "//* GENERATED DD STATEMENTS FOR NON-LMOD OUTPUT LIBRARIES";
      put "//*";
   end;
   if first.outdd then do;
      if outdd NE "" then
      put "//" OUTDD @11 " DD   DISP=SHR,DSN=" OUTDSN;
   end;

 data _NULL_;   /* Finally, output SYSIN */
   file install mod noprint;
   retain x -1;
   set elemout;
     by syslib;
   if _N_ = 1 then do;
      put "//*";
      put "//SYSIN   DD   *";
   end;
   if first.syslib then do;
      if outdd = "" then outdd = "????????";
      put " COPY INDD=((" SYSLIB +X ",R)),OUTDD=" OUTDD;
   end;
   if main =: " " then put "  S M=" ELEMENT;
   else put "  S M=" element @20 "* ALIAS OF " main "*";

 /* Generate JCL for LOD elements */

 data _NULL_;   /* first, the base JCL and input libraries */
   file install mod noprint;
   retain x -1;
   set lmodout;
     by syslib;
   if _N_ = 1 then do;
      put "//LMODS    EXEC PGM=IEBCOPY,REGION=8M";
      put "//SYSPRINT DD   SYSOUT=*";
      put "//SYSUT3   DD   UNIT=SYSDA,SPACE=(TRK,(10,10))";
      put "//SYSUT4   DD   UNIT=SYSDA,SPACE=(TRK,(10,10))";
      put "//*";
      put "//* GENERATED DD STATEMENTS FOR LMOD INPUT LIBRARIES";
      put "//*";
   end;
   if first.syslib then do;
      put "//" syslib @11 " DD   DISP=SHR,DSN=" dataset;
   end;

 proc sort data=lmodout nodupkey out=lmododd; by outdd;

 data _NULL_;   /* Next, output libraries */
   file install mod noprint;
   retain x -1;
   set lmododd;
     by outdd;
   if _N_ = 1 then do;
      put "//*";
      put "//* GENERATED DD STATEMENTS FOR LMOD OUTPUT LIBRARIES";
      put "//*";
   end;
   if first.outdd then do;
      if outdd NE "" then
      put "//" OUTDD @11 " DD   DISP=SHR,DSN=" OUTDSN;
   end;

 data _NULL_;   /* Finally, output SYSIN */
   file install mod noprint;
   retain x -1;
   set lmodout;
     by syslib;
   if _N_ = 1 then do;
      put "//*";
      put "//SYSIN   DD   *";
   end;
   if first.syslib then do;
      if outdd = "" then outdd = "????????";
      put " COPYMOD INDD=((" SYSLIB +X ",R)),OUTDD=" OUTDD;
   end;
   if main =: " " then put "  S M=" ELEMENT;
   else put "  S M=" element @20 "* ALIAS OF " main "*";
./ ADD NAME=APSELECT 0100-03192-03192-0827-00034-00034-00000-TRLH
  %MACRO APSELECT(CSI=SYSS.GLOBAL.CSI,ZONE=TARGZ14,FROMDATE=,TODATE=);
    %global vcsi vzone vfrmdate vtodate wfrmdate wtodate;
    %let vcsi=&csi;
    %let vzone=&zone;
    data _NULL_;
      vfdate = "&fromdate";
      if index(vfdate,'/') > 0 then do;
         mfdate = input(vfdate,mmddyy8.);
         jfdate = put(mfdate,julian5.);
      end;
      else jfdate = vfdate;
      call symput('vfrmdate',jfdate);
      wdate = input(jfdate,julian5.);
      wfdate = trim(left(put(wdate,worddate18.)));
      call symput('wfrmdate',wfdate);
      /* */
      FORMAT VTDATE $8.;
      vtdate = "&todate";
      if vtdate = "" then do;
         vtdate = put(date(),julian5.);
      end;
      if index(vtdate,'/') > 0 then do;
         mtdate = input(vtdate,mmddyy8.);
         jtdate = put(mtdate,julian5.);
      end;
      else do;
         jtdate = vtdate;
      end;
      call symput('vtodate',jtdate);
      wdate = input(jtdate,julian5.);
      wtdate = trim(left(put(wdate,worddate18.)));
      call symput('wtodate',wtdate);
      stop;
  %mend APSELECT;
./ ADD NAME=ASMSMP1  0101-03190-03191-0803-00047-00043-00000-TRLH
//TRLHMJCL JOB (TRLH,6C,),
//            'Rich Hobt',
//            MSGCLASS=T,
//            NOTIFY=&SYSUID,
//            CLASS=X
//DEFAULT  OUTPUT CLASS=*,JESDS=ALL,DEFAULT=YES,
//     NAME=('Rich Hobt'),
//     ROOM=('6C'),
// BUILDING=('Western'),
//     DEPT=('SYSW'),
//  ADDRESS=('3101 Western Ave.',
//           'Seattle, WA.  98121',
//           'U.S.A.',
//           'Planet Earth')
//*
//*  This JCL is from: TRLH.AFCSMP1.SRC(ASMJCL)
//*
//*--------------------------------------------------------------------
//*
//*  THIS JOB ASSEMBLES AND LINKS AFCSMP1
//*
//ASM      EXEC PGM=ASMA90,
//         PARM='OBJECT,NODECK,XREF(FULL),RENT'
//SYSLIB   DD   DISP=SHR,DSN=SYS1.MACLIB
//         DD   DISP=SHR,DSN=SYS1.MODGEN
//         DD   DISP=SHR,DSN=TRLH.AFCSMP1.SRC                <-- CHANGE
//SYSUT1   DD   DSN=&&SYSUT1,SPACE=(4096,(120,120),,,ROUND),UNIT=VIO,
//         DCB=BUFNO=1
//SYSPRINT DD   SYSOUT=*
//SYSLIN   DD   DSN=&&OBJ,SPACE=(3040,(40,40),,,ROUND),UNIT=VIO,
//         DISP=(MOD,PASS),
//         DCB=(BLKSIZE=3040,LRECL=80,RECFM=FBS,BUFNO=1)
//SYSIN    DD   DISP=SHR,DSN=TRLH.AFCSMP1.SRC(AFCSMP1)       <-- CHANGE
//*--------------------------------------------------------------------
// IF (RC<=4) THEN
//LINK     EXEC PGM=HEWL,
//         PARM='MAP,LIST,LET,RENT,REFR,REUS'
//SYSLIN   DD   DSN=&&OBJ,DISP=(OLD,DELETE)
//         DD   DDNAME=SYSIN
//SYSLMOD  DD   DISP=SHR,DSN=TRLH.PDSE.LOAD                  <-- CHANGE
//SYSUT1   DD   DSN=&&SYSUT1,SPACE=(1024,(120,120),,,ROUND),UNIT=VIO,
//         DCB=BUFNO=1
//SYSPRINT DD   SYSOUT=*
//L.SYSIN  DD *
 NAME AFCSMP1(R)
//*
// ENDIF
./ ADD NAME=CLEAR    0100-03199-03199-1052-00009-00009-00000-TRLH
         MACRO
         CLEAR &TEXT
         AIF   (N'&TEXT NE 1).ERROR1
         MVI   &TEXT,C' '
         MVC   &TEXT+1(L'&TEXT-1),&TEXT
         MEXIT
.ERROR1  MNOTE 20,'*** MISSING OPERAND ***'
         MEXIT
         MEND
./ ADD NAME=ENTERX   0100-03190-03190-0806-00149-00149-00000-TRLH
         MACRO
&SUBR    ENTERX &BASES,&SAVE,&CSECT,&AMODE=24,&RMODE=24
.*   THIS MACRO, USED WITH THE LEAVE MACRO, WILL PERFORM
.*   STANDARD HOUSEKEEPING FOR A CSECT, INCLUDING SAVEAREA
.*   CONSTRUCTION AND CHAINING, AND GETTING SOME STORAGE,
.*   IF THAT IS DESIRED.
.*   THE LEAVE MACRO WILL FREE THE GOTTEN STORAGE
.*   THE OPERANDS ARE
.*       &SUBR    ENTER  &BASES,&SAVE,&CSECT,&AMODE=,&RMODE=
.*    WHERE
.*       &SUBR    IS THE NAME OF THE CSECT
.*       &BASES   ARE THE BASE REGISTERS FOR THE ROUTINE
.*       &SAVE    IS THE LABEL FOR A SAVEAREA, OR A SUBPOOL
.*                AND LENGTH FOR THE STORAGE OBTAIN
.*                OR, IF NUMERIC, THE OFFSET OFF OF R1 OF A PASSED
.*                SAVEAREA TO USE. (,,C) TO CLEAR THE SAVEAREA
.*       &CSECT   TO CONTINUE AN EXISTING CSECT WITH ENTRY
.*                POINT &SUBR
.*
.*    EXAMPLES -
.*               ENTER 13,*
.*
.*       THIS WILL GENERATE NON-REENTRANT CODE, USING SAVEAREA
.*       AS THE SAVE AREA LABEL, AND REGISTER 13 FOR THE BASE
.*       REGISTER.
.*
.*       RENTMOD  ENTER (12,11),(,LDSECT)
.*
.*       THIS WILL GENERATE REENTRANT CODE WITH REGISTERS 12 AND
.*       11 FOR BASE REGISTERS.  A STORAGE OBTAIN WILL BE DONE FOR THE
.*       DEFAULT SUBPOOL (0) WITH A LENGTH 'LDSECT'.
.*
         GBLC  &LV,&SP
         LCLA  &K,&N
         LCLC  &AREA,&B(16),&SUBNAME,&S
&SUBNAME SETC  '&SUBR'
         AIF   ('&SUBNAME' NE '').SUBSPEC
&SUBNAME SETC  'MAIN'         DEFAULT CSECT NAME
.SUBSPEC AIF   ('&CSECT' EQ '').NOTENT  IS IT AN ENTRY POINT?
&CSECT   CSECT                          CONTINUE CSECT
.SUBCONT ANOP
&SUBNAME DS    0F
         ENTRY &SUBNAME
         SAVE  (14,12),T,'&CSECT &SYSDATE &SYSTIME &SUBNAME'
         AGO   .CSSPEC
.NOTENT  ANOP                           NEW CSECT
&SUBNAME CSECT
.SUBSTRT ANOP
&SUBNAME RMODE &RMODE
&SUBNAME AMODE &AMODE
         ENTRY &SUBNAME
         SAVE  (14,12),T,'&SUBNAME &SYSDATE &SYSTIME'
.CSSPEC  ANOP
         AIF   ('&BASES(1)' EQ '15' OR '&BASES' EQ '').R15SET
         AIF   ('&BASES(1)' EQ '13' AND '&SAVE' NE '').R15SET
         LR    &BASES(1),15  SET FIRST BASE REG
.R15SET  CNOP  0,4
&S       SETC  '&SUBNAME'
         AIF   (N'&SAVE EQ 2).P4   SUBPOOL, SIZE SPEC?
         AIF   ('&SAVE' EQ '').P3  NO SAVEAREA - DEFAULT
&AREA    SETC  '&SAVE'
         AIF   ('&SAVE' NE '*').P2
&AREA    SETC  'SAVEAREA'
.P2      AIF   ('&BASES(1)' NE '13').P4
&S       SETC  '*'
         USING &SUBNAME,15
         ST    14,&AREA+4
         LA    14,&AREA
         ST    14,8(13)
         L     14,&AREA+4
         ST    13,&AREA+4
         BAL   13,*+76        SKIP AROUND THE SAVEAREA
         DROP  15
         AGO   .P4
.P3      AIF   ('&BASES(1)' NE '13').P4
         MNOTE 8,'*** CONTENTS OF REG 13 ARE LOST.  NO SAVE AREA WAS ESX
               TABLISHED.'
.P4      AIF   ('&BASES(1)' NE '14' OR '&SAVE' EQ '').P5
         MNOTE 8,'*** MACRO RESTRICTION - REG 14 MUST NOT BE USED AS THX
               E FIRST BASE REGISTER IF A SAVE AREA IS USED.'
.P5      AIF   ('&BASES' EQ '').P9
&N       SETA  N'&BASES
.P6      ANOP
&K       SETA  &K+1
&B(&K)   SETC  ','.'&BASES(&K)'
         AIF   (N'&SAVE EQ 1).PE
         AIF   ('&BASES(&K)' NE '13').P7
         MNOTE 8,'*** REG 13 MAY NOT BE USED AS A BASE REGISTER FOR REEX
               NTRANT CODE.'
         AGO   .P7
.PE      AIF   ('&BASES(&K+1)' NE '13' OR '&SAVE' EQ '').P7
         MNOTE 8,'*** WHEN USING A SAVE AREA, REG 13 MAY NOT BE USED ASX
                A SECONDARY BASE REGISTER.'
.P7      AIF   ('&BASES(&K+1)' NE '').P6
         USING &S&B(1)&B(2)&B(3)&B(4)&B(5)&B(6)&B(7)&B(8)&B(9)&B(10)&B(X
               11)&B(12)&B(13)&B(14)&B(15)&B(16)
&K       SETA  1
         AIF   ('&BASES(1)' NE '13' OR '&SAVE' EQ '').P8
&AREA    DC    18F'0'
.P8      AIF   (&K GE &N).P10
         LA    &BASES(&K+1),2048(,&BASES(&K))
         LA    &BASES(&K+1),2048(,&BASES(&K+1))
&K       SETA  &K+1
         AGO   .P8
.P9      USING &SUBNAME,15
.P10     AIF   (N'&SAVE GE 2).P13
         AIF   ('&SAVE' EQ '' OR '&BASES(1)' EQ '13').P12
.*       AIF   ('&SAVE(1)' GE '0').P16  NUMERIC MEANS A PASSED AREA
         AIF   (T'&SAVE(1) NE 'U').P16  NUMERIC MEANS A PASSED AREA
         ST    14,&AREA+4
         LA    14,&AREA
         ST    14,8(13)
         L     14,&AREA+4
         ST    13,&AREA+4
.P11     BAL   13,*+76       SKIP AROUND THE SAVEAREA
&AREA    DC    18F'0'
.P12     MEXIT
.P13     ANOP
&LV      SETC  '&SAVE(2)'
&SP      SETC  '0'
         AIF   ('&SAVE(1)' EQ '').P14
&SP      SETC  '&SAVE(1)'
.P14     ANOP               DO A STORAGE OBTAIN FOR THE AREA
         STORAGE OBTAIN,LENGTH=&LV,SP=&SP,LOC=BELOW
.*                            CHAIN THE SAVEAREAS
         XC    0(4,1),0(1)    ZERO FIRST WORD
         ST    13,4(1)        PRIOR SAVEAREA ADDRESS TO MINE
         ST    1,8(13)        MY SAVEAREA ADDRESS TO HIS
         LR    2,13           KEEP THE SAVEAREA ADDRESS FOR REGS
         LR    13,1           THIS IS MY SAVEAREA
         AIF   ('&SAVE(3)' NE 'C').P15   CLEAR THE SAVEAREA?
         LA    4,12(,13)      YES, POINT PAST THE CHAIN
         L     5,=A(&LV)      GET THE SIZE
         LA    6,12           MINUS THE CHAIN AREA (12 BYTES )
         SR    5,6            GIVES THE AMOUNT TO CLEAR
         SR    7,7            CLEAR THE FROM COUNT AND CLEAR BYTE
         MVCL  4,6            WHEE, CLEAR IT OUT
         LM    14,7,12(2)     RESTORE THE ORIGINAL REGISTERS
         MEXIT
.P15     ANOP
         LM    14,2,12(2)     RESTORE ORIGINAL REGS
         MEXIT
.P16     L     1,&AREA+0(1)   NUMERIC &SAVE IMPLIES A PASSED SAVEAREA
         ST    13,4(1)        PRIOR SAVEAREA ADDRESS TO MINE
         ST    1,8(13)        MY SAVEAREA ADDRESS TO HIS
         LR    2,13           KEEP THE SAVEAREA ADDRESS FOR REGS
         LR    13,1           THIS IS MY SAVEAREA
         LM    0,2,20(2)      RESTORE ORIGINAL REGS
         MEND
./ ADD NAME=EXECJCL  0103-03190-03192-0824-00034-00022-00000-TRLH
//TRLHCJCL JOB (TRLH,6C,),
//            'Rich Hobt',
//            MSGCLASS=T,
//            NOTIFY=&SYSUID,
//            CLASS=T
//DEFAULT  OUTPUT CLASS=*,JESDS=ALL,DEFAULT=YES,
//     NAME=('Rich Hobt'),
//     ROOM=('6C'),
// BUILDING=('Western'),
//     DEPT=('SYSW'),
//  ADDRESS=('3101 Western Ave.',
//           'Seattle, WA.  98121',
//           'U.S.A.',
//           'Planet Earth')
//*
//*  This JCL is from: TRLH.AFCSMP1.SRC(EXECJCL)
//*
//*---------------------------------------------------------------------
//AFCSMP1  EXEC PGM=AFCSMP1,REGION=64M
//SYSUDUMP DD   SYSOUT=*
//GIMPRINT DD   SYSOUT=*
//GIMOUT   DD   SYSOUT=*,RECFM=VB,LRECL=1028,BLKSIZE=27998
//GIMIN    DD   *
* Report all function sysmods in all zones in the given csi
CSI SYSS.GLOBAL.CSI
ZONE *
ENTRY SYSMOD
*  Include the FMID, description, feature number, FESN, install date,
*  and install time.
SUBENTRY ENAME,DESCRIPTION,FESN,INSTALLDATE,INSTALLTIME
*  Only take sysmods applied/accepted, and those that are not in error
*  or SUPed
FILTER (SMODTYPE='FUNCTION')&((APPLY='YES')|(ACCEPT='YES'))            *
&(LASTSUP='')&(ERROR='NO')
./ ADD NAME=FUNCLIST 0103-03192-03338-1052-00614-00595-00000-TRLH
//TRLHLIST JOB (TRLH,6C,),
//            'Rich Hobt',
//            MSGCLASS=T,
//            NOTIFY=&SYSUID,
//            CLASS=X
/*JOBPARM K=0
//*XEQ    AFEX01
//DEFAULT  OUTPUT CLASS=*,JESDS=ALL,DEFAULT=YES,
//     NAME=('Rich Hobt'),
//     ROOM=('6C'),
// BUILDING=('Western'),
//     DEPT=('SYSW'),
//  ADDRESS=('3101 Western Ave.',
//           'Seattle, WA.  98121',
//           'U.S.A.',
//           'Planet Earth')
//*
//*  This JCL is from: TRLH.SAS2.CNTL(FUNCLIST)
//*
//********************************************************************/
//*                                                                  */
//* THIS JOB PRODUCES A SCRIPT/VS DATA STREAM TO PRINT A TABLE       */
//* SHOWING ALL FUNCTIONS RECEIVED, APPLIED, AND/OR ACCEPTED IN ALL  */
//* THE ZONES ASSOCIATED WITH A GIVEN SMPE GLOBAL ZONE.  IT ALSO     */
//* PRODUCES REPORTS SHOWING FMIDS NEEDING TO BE APPLIED, ACCEPTED,  */
//* OR REJECTED.  THE REPORTS ARE IN SCRIPT INPUT FORMAT AND ARE     */
//* PLACED IN SYSW.MVS.DOC MEMBERS STARTING WITH #FUNC.              */
//*                                                                  */
//* 02/23/00  PKS   Put HTML in dataset                              */
//*                                                                  */
//* 10/07/97  TRLH  Extract zone name from global zone to use        */
//*                 in headings.                                     */
//*                                                                  */
//* 09/16/97  TRLH  ADD REPORTS FOR GLOBAL ZONE FMIDS TO BE          */
//*                 ADDED AND DELETED                                */
//* 12/20/96  TRLH  ADD HTML OUTPUT                                  */
//*                                                                  */
//********************************************************************/
//*                                                                  */
//* MAKE SURE THAT THE ZONE AND GZONE VARIABLES ARE SET CORRECTLY
//*
// SET ZONE=IBM                 IBM
// SET GZONE=SYSS.GLOBAL.CSI
//*
//*SET ZONE=CA                   COMPUTER ASSOCIATES
//*SET GZONE=SYSS.CA.GLOBAL.CSI
//*
//*SET ZONE=BB                   BOOLE
//*SET GZONE=SYSS.GLOBAL.CSI
//*
//*SET ZONE=BET                  BETA
//*SET GZONE=SYSS.GLOBAL.CSI
//*
//*SET ZONE=CCC                  CANDLE CC
//*SET GZONE=SYSS.GLOBAL.CSI
//*
//*SET ZONE=COG                  CANDLE OG
//*SET GZONE=SYSS.GLOBAL.CSI
//*
//*SET ZONE=CW                   COMPUWARE
//*SET GZONE=SYSS.GLOBAL.CSI
//*
//*--------------------------------------------------------------------
//SAS      EXEC SAS,PARM='SORT=4,SYSPARM=&ZONE./&GZONE.'
//GIMIN    DD   DISP=(NEW,PASS),DSN=&&SYSIN,
//  UNIT=VIO,SPACE=(TRK,(5,5)),
//  RECFM=FB,LRECL=80,BLKSIZE=0
//GIMOUT   DD   DISP=(NEW,PASS),DSN=&&SYSOUT,
//  UNIT=SYSDA,SPACE=(TRK,(90,90)),
//  RECFM=VB,LRECL=1028,BLKSIZE=0
//GIMPRINT DD   SYSOUT=*
//FMIDXRF  DD   DISP=SHR,DSN=SYSW.FMIDXRF.DATA
//REPORT   DD   DISP=SHR,DSN=SYSW.MVS.DOC(#Z&ZONE.TAB)
//APPFMID  DD   DISP=SHR,DSN=SYSW.MVS.DOC(#Z&ZONE.APP)
//ACCFMID  DD   DISP=SHR,DSN=SYSW.MVS.DOC(#Z&ZONE.ACC)
//REJFMID  DD   DISP=SHR,DSN=SYSW.MVS.DOC(#Z&ZONE.REJ)
//DELFMID  DD   DISP=SHR,DSN=SYSW.MVS.DOC(#Z&ZONE.GZD)
//ADDFMID  DD   DISP=SHR,DSN=SYSW.MVS.DOC(#Z&ZONE.GZA)
//HTML     DD   DISP=SHR,DSN=SYSW.MVS.DOC.HTML(#Z&ZONE.HTM)
//*REPORT   DD   SYSOUT=*
//*APPFMID  DD   SYSOUT=*
//*ACCFMID  DD   SYSOUT=*
//*REJFMID  DD   SYSOUT=*
//*DELFMID  DD   SYSOUT=*
//*ADDFMID  DD   SYSOUT=*
//*HTML     DD   SYSOUT=*
//SYSIN    DD   *
  OPTIONS LS=255 VSAMLOAD NOMPRINT SYMBOLGEN NODATE NONUMBER NOSOURCE2
          NOMACROGEN NOCENTER;

  /*
  ** RETRIEVE THE ZONE INDEX AND FMID LIST FROM THE GLOBAL ZONE
  */

  DATA _NULL_;
    FILE GIMIN NOPRINT OLD ;
    PARMS = SYSPARM();
    ZONE  = SCAN(PARMS,1,'/');
    GZONE  = SCAN(PARMS,2,'/');
    CALL SYMPUT('ZONE',ZONE);
    PUT "CSI " GZONE;
    PUT "ZONE GLOBAL                                       ";
    PUT "ENTRY GLOBALZONE                                  ";
    PUT "SUBENTRY ZONEINDEX,FMID                           ";
    STOP;

  PROC AFCSMP1;

  DATA ZONES (KEEP=ZONE ZONETYP)
       GZFMID (KEEP=FMID)
    ;
    RETAIN SUBENTRY "         "
      ;
    INFILE GIMOUT LENGTH=LEN;
    INPUT @1 ALINE $VARYING200. LEN;
    IF INDEX(ALINE,"SUBENTRY=") > 0 THEN DO;
       SUBENTRY = SCAN(ALINE,2,"=");
       RETURN;
    END;
    IF SUBENTRY = "FMID" THEN DO;
       FMID = ALINE;
       OUTPUT GZFMID;
       RETURN;
    END;
    IF SUBENTRY = "ZONEINDEX" THEN DO;
       ZONE = SCAN(ALINE,1,",");
       ZONETYP = SCAN(ALINE,3,",");
       OUTPUT ZONES;
       RETURN;
    END;

  PROC SORT DATA=GZFMID; BY FMID;

  /*
  ** RETRIEVE THE GLOBAL ZONE FUNCTIONS
  */

  DATA _NULL_;
    FILE GIMIN NOPRINT OLD ;
    PARMS = SYSPARM();
    GZONE  = SCAN(PARMS,2,'/');
    PUT "CSI " GZONE;
    PUT "ZONE GLOBAL                                       ";
    PUT "ENTRY SYSMOD                                      ";
    PUT "SUBENTRY ENAME,DESCRIPTION,FESN,RECDATE,RECTIME   ";
    PUT "FILTER (SMODTYPE='FUNCTION')&(ERROR='NO')         ";
    STOP;

  PROC AFCSMP1;

  DATA GLOBAL;
    INFILE GIMOUT LENGTH=LEN EOF=EOF;
    FORMAT INSTDATE DATE.
           INSTTIME TIME.
      ;
    LENGTH DESCR $64;
    RETAIN NOTFIRST 0
           FMID     "       "
           FESN     "        "
           ZONE     "       "
           DESCR
           INSTDATE
           INSTTIME
      ;
    KEEP FMID
         ZONE
         FESN
         DESCR
         INSTDATE
         INSTTIME
      ;
    INPUT @1 ALINE $VARYING200. LEN;
    IF ALINE =: "TYPE=SYSMOD" THEN DO;  /* NEW SYSMOD */
       IF NOTFIRST THEN OUTPUT;
       NOTFIRST = 1;
       FESN     = "       ";
       DESCR    = REPEAT(" ",64);
       INSTDATE = 0;
       INSTTIME = 0;
       INPUT @1 ALINE $VARYING200. LEN;
       FMID = SCAN(ALINE,1);
       ZONE = SCAN(ALINE,2);
       RETURN;
    END;
    IF ALINE =: "SUBENTRY=DESCRIPTION" THEN DO;
       INPUT @1 DESCR $VARYING200. LEN;
       RETURN;
    END;
    IF ALINE =: "SUBENTRY=FESN" THEN DO;
       INPUT @1 FESN $VARYING200. LEN;
       RETURN;
    END;
    IF ALINE =: "SUBENTRY=RECDATE" THEN DO;
       INPUT @1 ALINE $VARYING200. LEN;
       INSTDATE = DATEJUL(ALINE);
       RETURN;
    END;
    IF ALINE =: "SUBENTRY=RECTIME" THEN DO;
       INPUT @1 ALINE $VARYING200. LEN;
       INSTTIME = HMS(SCAN(ALINE,1,":"),SCAN(ALINE,2,":"),SCAN(ALINE,3,":"));
       RETURN;
    END;
    RETURN;

  EOF:
    OUTPUT;

  /*
  ** RETRIEVE THE TARGET AND DLIB ZONE FUNCTIONS
  */

  DATA _NULL_;
    FILE GIMIN NOPRINT OLD ;
    PARMS = SYSPARM();
    GZONE  = SCAN(PARMS,2,'/');
    PUT "CSI " GZONE;
    PUT "ZONE *";
    PUT "ENTRY SYSMOD";
    PUT "SUBENTRY ENAME,DESCRIPTION,FESN,INSTALLDATE,INSTALLTIME";
    PUT "FILTER (SMODTYPE='FUNCTION')&((APPLY='YES')|(ACCEPT='YES'))" @72 "*";
    PUT "&(LASTSUP='')&(ERROR='NO')";
    STOP;

  PROC AFCSMP1;

  DATA TARGDLIB;
    INFILE GIMOUT LENGTH=LEN EOF=EOF;
    FORMAT INSTDATE DATE.
           INSTTIME TIME.
      ;
    LENGTH DESCR $64;
    RETAIN NOTFIRST 0
           FMID     "       "
           FESN     "        "
           ZONE     "       "
           DESCR
           INSTDATE
           INSTTIME
      ;
    KEEP FMID
         ZONE
         FESN
         DESCR
         INSTDATE
         INSTTIME
      ;
    INPUT @1 ALINE $VARYING200. LEN;
    IF ALINE =: "TYPE=SYSMOD" THEN DO;  /* NEW SYSMOD */
       IF NOTFIRST THEN OUTPUT;
       NOTFIRST = 1;
       FESN     = "       ";
       DESCR    = REPEAT(" ",64);
       INSTDATE = 0;
       INSTTIME = 0;
       INPUT @1 ALINE $VARYING200. LEN;
       FMID = SCAN(ALINE,1);
       ZONE = SCAN(ALINE,2);
       RETURN;
    END;
    IF ALINE =: "SUBENTRY=DESCRIPTION" THEN DO;
       INPUT @1 DESCR $VARYING200. LEN;
       RETURN;
    END;
    IF ALINE =: "SUBENTRY=FESN" THEN DO;
       INPUT @1 FESN $VARYING200. LEN;
       RETURN;
    END;
    IF ALINE =: "SUBENTRY=INSTALLDATE" THEN DO;
       INPUT @1 ALINE $VARYING200. LEN;
       INSTDATE = DATEJUL(ALINE);
       RETURN;
    END;
    IF ALINE =: "SUBENTRY=INSTALLTIME" THEN DO;
       INPUT @1 ALINE $VARYING200. LEN;
       INSTTIME = HMS(SCAN(ALINE,1,":"),SCAN(ALINE,2,":"),SCAN(ALINE,3,":"));
       RETURN;
    END;
    RETURN;

  EOF:
    OUTPUT;

  /* SORT ALL THE FUNCTIONS BY ZONE                               */

  PROC SORT DATA=GLOBAL; BY ZONE FMID;
  PROC SORT DATA=TARGDLIB; BY ZONE FMID;
  PROC SORT DATA=ZONES;    BY ZONE;

  DATA FUNCTION;
    MERGE GLOBAL
          TARGDLIB
          ZONES
          ;
    BY ZONE;

  PROC SORT DATA=FUNCTION OUT=FUNCTION NODUPS; BY FMID;

  /*PROC PRINT UNIFORM NOOBS DATA=FUNCTION;*/

  /* PRODUCE A SAS DATASET CONTAINING FMIDS, DESCRIPTIONS, AND    */
  /* PRODUCT NUMBERS SO WE CAN MAKE A PRETTY REPORT.              */

  DATA FMIDXRF;
    INFILE FMIDXRF;
    LENGTH DESC_EXT $64;
    DROP DESC1 DESC2;
    INPUT @1  DESC2    $CHAR20.
          @22 FMID     $CHAR7.
          @31 PGMNO    $CHAR7.
          @39 COMPID   $CHAR9.
          @49 REL      $CHAR3.
          @93 DESC1    $CHAR29.
      ;
    DESC_EXT = TRIM(DESC1) || " " || DESC2;
    IF SUBSTR(DESC2,1,1) NE "*" THEN OUTPUT;

  PROC SORT DATA=FMIDXRF; BY FMID;

  DATA ACCEPTED
       APPLIED
       BOTH;
    MERGE FUNCTION(IN=APPLIED)
          FMIDXRF(IN=HASDESC);
    BY FMID;
    IF APPLIED;
    IF DESCR = "" THEN DESCR = DESC_EXT;
    IF DESCR = "" THEN DESCR = "???";
    IF ZONETYP =: "DLIB" THEN OUTPUT ACCEPTED;
                         ELSE OUTPUT APPLIED;
    OUTPUT BOTH;

  PROC SORT DATA=BOTH; BY ZONE FMID;

  PROC PRINT DATA=BOTH UNIFORM NOOBS;
  TITLE "FMIDS BY ZONE ";
  BY ZONE;
  PAGEBY ZONE;
  VAR FMID DESCR INSTDATE;

  PROC SORT DATA=BOTH; BY FMID INSTDATE ZONE;

  DATA GZOK
       GZADD
       GZDEL0
    ;
    MERGE GZFMID(IN=INGZONE)
          BOTH(IN=INUSE)
      ;
      BY FMID;
    IF INGZONE AND INUSE THEN OUTPUT GZOK;
    IF INGZONE AND NOT INUSE THEN OUTPUT GZDEL0;
    IF NOT INGZONE AND INUSE THEN OUTPUT GZADD;

 /*
 ** The fmids deserving deletion from the global zone fmid list
 ** don't have descriptions from smpe, so try to get them from
 ** the FMIDXRF data.
 */

    DATA GZDEL;
    MERGE GZDEL0(IN=KEEPIT)
          FMIDXRF
      ;
    BY FMID;
    DESCR = DESC_EXT;
    IF KEEPIT;

PROC SORT DATA=GZDEL NODUPKEY; BY FMID;
PROC SORT DATA=GZADD NODUPKEY; BY FMID;

DATA _NULL_;
  RETAIN X     -1
         ONOFF 0
    ;
  TODAE = DATE();
  TYME = TIME();
  TODAY = TRIM(LEFT(PUT(TODAE,WORDDATE.))) || " " || TRIM(PUT(TYME,TIME5.));
  SET BOTH END=THATSALL;
    BY FMID;
  IF _N_ = 1 THEN DO;
   /* DCF */
    FILE REPORT NOPRINT;
    PUT ".* SMPE ACTIVE FMIDS (By FMID)                              ";
    PUT ".*                                                          ";
    PUT ".*                                                          ";
    PUT ".* if this member is being formatted on its own (not part   ";
    PUT ".* of $MANUAL) define the 'menu' font.  Otherwise it is     ";
    PUT ".* defined in $MANUAL.                                      ";
    PUT ".*                                                          ";
    PUT ".if &$PN = 0                                                ";
    PUT ".th .df menu type('gothic' 08) codepage T1D0BASE            ";
    PUT ".rh on                                                      ";
    PUT "&ZONE FUNCTIONs installed at AFC (" TODAY +X ")";
    PUT ".sp                                                         ";
    PUT ".rh off                                                     ";
    PUT ".*                                                          ";
    PUT ".* use 'menu' font because it's small (8 point)             ";
    PUT ".*                                                          ";
    PUT ".bf menu                                                    ";
    PUT ".if &$LDEV eq 38PPNS90 .go p3800                            ";
    PUT ".if &$LDEV eq AFPA     .go p3800                            ";
    PUT ".*                                                          ";
    PUT ".* set table definition for a dataset (wider width)         ";
    PUT ".*                                                          ";
    PUT ":rdef id=ractid cwidths='9m 20m 9m 11m 5m *'                ";
    PUT "      align='left left center center center left'           ";
    PUT "      valign='center center center center center center'    ";
    PUT "      concat = 'yes no yes yes yes no'                      ";
    PUT ":table id=actid refid=ractid split=yes width=74m            ";
    PUT ".go table                                                   ";
    PUT "...p3800                                                    ";
    PUT ".*                                                          ";
    PUT ".* set table definition for a 3800 (default width)          ";
    PUT ".*                                                          ";
    PUT ":rdef id=ractid cwidths='10m 32m 10m 13m 6m *'              ";
    PUT "      align='left left center center center left'           ";
    PUT "      valign='center center center center center center'    ";
    PUT "      concat = 'yes no yes yes yes no'                      ";
    PUT ":table id=actid refid=ractid split=yes                      ";
    PUT "...table                                                    ";
    PUT ".*                                                          ";
    PUT ".* build the table rows                                     ";
    PUT ".*                                                          ";
    PUT ":thd                                                        ";
    PUT ":c.FMID :c.DESCRIPTION :c.PGMNO :c.COMPID :c.REL :c.ZONES   ";
    PUT ":ethd                                                       ";
   /* HTML */
    FILE HTML NOPRINT;
    PUT "<HTML>                                                     ";
    PUT "<HEAD>                                                     ";
    PUT "<TITLE>&ZONE SMPE Function List</TITLE>                ";
    PUT "</HEAD>                                                    ";
    PUT "<H2><CENTER>&ZONE SMPE Functions</CENTER></H2>      ";
    PUT "<BODY><P><P>                                               ";
    PUT "<!-- SMPE ACTIVE FMIDS (BY FMID)                         -->";
    PUT "<!--                                                     -->";
    PUT "<CENTER>";
    PUT "<TABLE BORDER=1 WIDTH=99% CELLSPACING=1 CELLPADDING=1>     ";
    PUT "<CAPTION>&ZONE FMIDs installed at AFC as of " TODAY @;
    PUT "</CAPTION>";
    PUT " ";
    PUT "<TR ALIGN=CENTER VALIGN=MIDDLE>";
    PUT " <TD BGCOLOR='FFC0C0'>FMID</TD>";
    PUT " <TD BGCOLOR='FFC0C0'>Description</TD>";
    PUT " <TD BGCOLOR='FFC0C0'>Pgm. no.</TD>";
    PUT " <TD BGCOLOR='FFC0C0'>Comp. ID</TD>";
    PUT " <TD BGCOLOR='FFC0C0'>Rel</TD>";
    PUT " <TD BGCOLOR='FFC0C0'>ZONE(s)</TD>";
    PUT "</TR>";
    PUT " ";
  END;
  IF FIRST.FMID THEN DO;
    IF ONOFF = 1 THEN DO;
       BG = "BGCOLOR='FFFFFF'";
       ONOFF = 0;
    END;
    ELSE DO;
       BG = "BGCOLOR='COFFCO'";
       ONOFF = 1;
    END;
   /* DCF */
    FILE REPORT NOPRINT;
    PUT ":row";
    PUT ":c." FMID;
    PUT ":C." DESCR;
    /*IF DESC2 NE "" THEN PUT DESC2;*/
    PUT ":c." PGMNO;
    PUT ":c." COMPID;
    PUT ":c." REL;
    PUT ":c." ZONE INSTDATE MMDDYY.;
   /* HTML */
    FILE HTML NOPRINT;
    PUT "<TR>";
    PUT " <TD ALIGN=CENTER " BG ">" FMID "</TD>";
    PUT " <TD " BG ">" DESCR "</TD>";
    IF PGMNO NE "" THEN PUT " <TD " BG ">" PGMNO "</TD>";
       ELSE PUT " <TD " BG ">&nbsp</TD>";
    IF COMPID NE "" THEN PUT " <TD " BG ">" COMPID "</TD>";
       ELSE PUT " <TD " BG ">&nbsp</TD>";
    IF REL NE "" THEN PUT " <TD " BG ">" REL "</TD>";
       ELSE PUT " <TD " BG ">&nbsp</TD>";
    IF LAST.FMID THEN PUT " <TD " BG ">" ZONE INSTDATE MMDDYY. "</TD></TR>";
                 ELSE PUT " <TD " BG ">" ZONE INSTDATE MMDDYY. ;
  END;
  ELSE DO;
   /* DCF */
    FILE REPORT NOPRINT;
    PUT ZONE INSTDATE MMDDYY.;
   /* HTML */
    FILE HTML NOPRINT;
    IF LAST.FMID THEN PUT " <BR />" ZONE INSTDATE MMDDYY. "</TD></TR>";
                 ELSE PUT " <BR />" ZONE INSTDATE MMDDYY. ;
  END;
  IF THATSALL = 1 THEN DO;
   /* DCF */
    FILE REPORT NOPRINT;
    PUT ".*                                                          ";
    PUT ".* set the caption and end the table                        ";
    PUT ".*                                                          ";
    PUT ":TCAP.&ZONE FMIDs installed at Airborne (as of " TODAY +X ")";
    PUT ":etable.                                                    ";
    PUT ".*                                                          ";
    PUT ".* restore font to whatever it was previously and cancel    ";
    PUT ".* the running heading.                                     ";
    PUT ".*                                                          ";
    PUT ".rh cancel                                                  ";
    PUT ".pf                                                         ";
   /* HTML */
    FILE HTML NOPRINT;
    PUT "</TABLE>";
    PUT "</CENTER>";
    PUT "</body>";
    PUT "</html>";
  END;

DATA NAPPLY
     NACCEPT
     NREJECT
  ;
  RETAIN GLOBAL 0
         DLIB   0
         TARGET 0
    ;
  DROP DLIB TARGET GLOBAL;
  SET BOTH;
    BY FMID;
  IF ZONETYP =: "DLIB" THEN DLIB = DLIB + 1;
  IF ZONETYP =: "TARGET" THEN TARGET = TARGET + 1;
  IF ZONE =: "GLOBAL" THEN GLOBAL = GLOBAL + 1;
  IF LAST.FMID THEN DO;
     IF TARGET = 0 AND GLOBAL > 0 THEN OUTPUT NAPPLY;
     IF TARGET > 0 AND DLIB = 0 THEN OUTPUT NACCEPT;
     IF DLIB > 0 AND GLOBAL > 0 THEN OUTPUT NREJECT;
     GLOBAL = 0;
     DLIB = 0;
     TARGET = 0;
  END;

 /*PROC PRINT UNIFORM NOOBS DATA=BOTH;
TITLE "DIAGNOSTIC OUTPUT - DATASET BOTH";*/

DATA _NULL_;
  RETAIN X -1;
  TODAE = DATE();
  TODAY = TRIM(LEFT(PUT(TODAE,WORDDATE.)));
  FILE APPFMID NOPRINT;
  SET NAPPLY END=THATSALL;
  IF _N_ = 1 THEN DO;
     PUT ".SP";
     PUT "FMID's in need of APPLY (as of " TODAY +X "):";
     PUT ":ul";
  END;
  PUT ":LI." FMID DESCR "(RECEIVED " INSTDATE +X ")";
  IF THATSALL THEN PUT ":EUL";

DATA _NULL_;
  RETAIN X -1;
  TODAE = DATE();
  TODAY = TRIM(LEFT(PUT(TODAE,WORDDATE.)));
  FILE ACCFMID NOPRINT;
  SET NACCEPT END=THATSALL;
  IF _N_ = 1 THEN DO;
     PUT ".SP";
     PUT "FMID's in need of ACCEPT (as of " TODAY +X "):";
     PUT ":ul";
  END;
  IF ZONE = "TARGFOC" THEN RETURN;
  PUT ":LI." FMID ZONE DESCR;
  IF THATSALL THEN PUT ":EUL";

DATA _NULL_;
  RETAIN X -1;
  TODAE = DATE();
  TODAY = TRIM(LEFT(PUT(TODAE,WORDDATE.)));
  FILE REJFMID NOPRINT;
  SET NREJECT END=THATSALL;
  IF _N_ = 1 THEN DO;
     PUT ".SP";
     PUT ":H2.FMID's in need of REJECTion (as of " TODAY +X "):";
     PUT ":ul";
  END;
  PUT ":LI." FMID ZONE DESCR;
  IF THATSALL THEN PUT ":EUL";

DATA _NULL_;
  RETAIN X -1;
  TODAE = DATE();
  TODAY = TRIM(LEFT(PUT(TODAE,WORDDATE.)));
  FILE DELFMID NOPRINT;
  SET GZDEL END=THATSALL;
  IF _N_ = 1 THEN DO;
     PUT ".SP";
     PUT ":H2.FMID'S in GLOBAL zone FMID list but shouldn't be ";
     PUT "(as of " TODAY +X "):";
     PUT ":ul";
  END;
  PUT ":LI." FMID DESCR;
  IF THATSALL THEN PUT ":EUL";

DATA _NULL_;
  RETAIN X -1;
  TODAE = DATE();
  TODAY = TRIM(LEFT(PUT(TODAE,WORDDATE.)));
  FILE ADDFMID NOPRINT;
  SET GZADD END=THATSALL;
  IF _N_ = 1 THEN DO;
     PUT ".SP";
     PUT ":H2.FMID'S not in GLOBAL zone FMID list that should be ";
     PUT "(as of " TODAY +X "):";
     PUT ":ul";
  END;
  PUT ":LI." FMID ZONE DESCR;
  IF THATSALL THEN PUT ":EUL";
/*
./ ADD NAME=LEAVEX   0100-03190-03190-0807-00014-00014-00000-TRLH
         MACRO
&NAME    LEAVEX &EQ,&RC=
         GBLC  &LV,&SP
&NAME    LR    2,13
         L     13,4(13)
         AIF   ('&RC' EQ '').L0
         LA    15,&RC         LOAD THE RETURN CODE
.L0      STM   15,1,16(13)  STORE RETURN REGS
         AIF   ('&LV' EQ '').L1  ANYTHING TO FREE?
         STORAGE RELEASE,LENGTH=&LV,SP=&SP,ADDR=(2)
.L1      RETURN (14,12),T     RETURN FROM WHENCE WE CAME
         AIF   ('&EQ' NE 'EQ').L4  REGISTERS TOO?
         EQUREGS
.L4      MEND
